From 00760f1062099ef5cce71a3668dbf35e5d780cb1 Mon Sep 17 00:00:00 2001
From: "bo.yang" <bo.yang@amlogic.com>
Date: Wed, 19 Feb 2014 10:01:45 +0800
Subject: [PATCH 3447/5965] dvb: add dvb support for m6tvd

by shijie.rong@amlogic.com
---
 arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd   |   95 +
 arch/arm/configs/meson6tvd_defconfig          |    5 +-
 drivers/amlogic/Kconfig                       |    2 +-
 drivers/amlogic/Makefile                      |   11 +-
 drivers/amlogic/dvb_tv/Kconfig                |  270 +
 drivers/amlogic/dvb_tv/Makefile               |   27 +
 drivers/amlogic/dvb_tv/aml_dmx.c              | 3025 +++++++++++
 drivers/amlogic/dvb_tv/aml_dvb.c              | 1533 ++++++
 drivers/amlogic/dvb_tv/aml_dvb.h              |  261 +
 drivers/amlogic/dvb_tv/aml_fe.c               | 1895 +++++++
 drivers/amlogic/dvb_tv/aml_fe.h               |  163 +
 drivers/amlogic/dvb_tv/amlci/Makefile         |   10 +
 drivers/amlogic/dvb_tv/amlci/aml_ci.c         |  485 ++
 drivers/amlogic/dvb_tv/amlci/aml_ci.h         |   23 +
 drivers/amlogic/dvb_tv/amlci/aml_iobus.c      |  580 ++
 drivers/amlogic/dvb_tv/amlci/aml_iobus.h      |   15 +
 drivers/amlogic/dvb_tv/amlci/aml_pcmcia.c     |  194 +
 drivers/amlogic/dvb_tv/amlci/aml_pcmcia.h     |   32 +
 drivers/amlogic/dvb_tv/amldemod/Makefile      |   26 +
 .../dvb_tv/amldemod/acf_filter_coefficient.h  |  253 +
 drivers/amlogic/dvb_tv/amldemod/aml_demod.c   |  734 +++
 drivers/amlogic/dvb_tv/amldemod/aml_demod.h   |  227 +
 drivers/amlogic/dvb_tv/amldemod/amlfrontend.c | 1309 +++++
 drivers/amlogic/dvb_tv/amldemod/amlfrontend.h |   75 +
 drivers/amlogic/dvb_tv/amldemod/demod_func.c  | 2518 +++++++++
 drivers/amlogic/dvb_tv/amldemod/demod_func.h  | 2601 +++++++++
 drivers/amlogic/dvb_tv/amldemod/dvbc_func.c   |  735 +++
 drivers/amlogic/dvb_tv/amldemod/dvbt_func.c   | 1599 ++++++
 drivers/amlogic/dvb_tv/amldemod/i2c_func.c    |  446 ++
 drivers/amlogic/dvb_tv/amldemod/tuner_func.c  |  236 +
 drivers/amlogic/dvb_tv/atbm887x/Kconfig       |   21 +
 drivers/amlogic/dvb_tv/atbm887x/Makefile      |    7 +
 drivers/amlogic/dvb_tv/atbm887x/atbm886x.c    | 3786 +++++++++++++
 drivers/amlogic/dvb_tv/atbm887x/atbm886x.h    |  306 ++
 drivers/amlogic/dvb_tv/atbm887x/atbm887x.c    | 4315 +++++++++++++++
 drivers/amlogic/dvb_tv/atbm887x/atbm887x.h    |  312 ++
 .../amlogic/dvb_tv/atbm887x/atbmfrontend.c    |  288 +
 drivers/amlogic/dvb_tv/cresta/Makefile        |    4 +
 .../amlogic/dvb_tv/cresta/ctc703_firmware.c   | 1713 ++++++
 .../amlogic/dvb_tv/cresta/ctc703_frontend.c   |  428 ++
 drivers/amlogic/dvb_tv/cresta/ctc703_func.c   |  497 ++
 drivers/amlogic/dvb_tv/cresta/ctc703_func.h   |  164 +
 drivers/amlogic/dvb_tv/mxl101/Makefile        |    3 +
 .../dvb_tv/mxl101/MaxLinearDataTypes.h        |  176 +
 .../amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.c  |  261 +
 .../amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.h  |   52 +
 .../amlogic/dvb_tv/mxl101/MxL101SF_PhyCfg.c   |  272 +
 .../dvb_tv/mxl101/MxL101SF_PhyCtrlApi.c       | 1980 +++++++
 .../dvb_tv/mxl101/MxL101SF_PhyCtrlApi.h       |  407 ++
 .../amlogic/dvb_tv/mxl101/MxL101SF_PhyDefs.h  |  196 +
 .../amlogic/dvb_tv/mxl101/demod_MxL101SF.c    |  219 +
 .../amlogic/dvb_tv/mxl101/demod_MxL101SF.h    |   38 +
 drivers/amlogic/dvb_tv/mxl101/drvCofdmDmd.c   |  549 ++
 drivers/amlogic/dvb_tv/mxl101/mxlfrontend.c   |  225 +
 drivers/amlogic/dvb_tv/si2176/Makefile        |    4 +
 .../amlogic/dvb_tv/si2176/si2176_frontend.c   | 1025 ++++
 drivers/amlogic/dvb_tv/si2176/si2176_func.c   | 4667 +++++++++++++++++
 drivers/amlogic/dvb_tv/si2176/si2176_func.h   | 2633 ++++++++++
 drivers/amlogic/dvb_tv/si2177/Makefile        |    4 +
 .../amlogic/dvb_tv/si2177/si2177_frontend.c   |  995 ++++
 drivers/amlogic/dvb_tv/si2177/si2177_func.c   | 3475 ++++++++++++
 drivers/amlogic/dvb_tv/si2177/si2177_func.h   | 3034 +++++++++++
 drivers/amlogic/dvb_tv/si2196/Makefile        |    3 +
 .../amlogic/dvb_tv/si2196/si2196_frontend.c   |  907 ++++
 drivers/amlogic/dvb_tv/si2196/si2196_func.c   | 3384 ++++++++++++
 drivers/amlogic/dvb_tv/si2196/si2196_func.h   | 4261 +++++++++++++++
 drivers/media/Kconfig                         |    1 +
 drivers/media/dvb-core/Kconfig                |    2 +-
 drivers/media/dvb-core/demux.h                |   42 +-
 drivers/media/dvb-core/dmxdev.h               |    2 +-
 drivers/media/dvb-core/dvb_ca_en50221.h       |    2 +-
 drivers/media/dvb-core/dvb_frontend.c         |  718 ++-
 drivers/media/dvb-core/dvb_frontend.h         |   93 +-
 drivers/media/dvb-core/dvb_net.c              |    2 +-
 drivers/media/dvb-core/dvbdev.c               |    2 +-
 drivers/media/dvb-core/dvbdev.h               |    1 +
 include/linux/amlogic/amdsc.h                 |   40 +
 include/uapi/linux/dvb/frontend.h             |  153 +-
 78 files changed, 60981 insertions(+), 73 deletions(-)
 create mode 100755 drivers/amlogic/dvb_tv/Kconfig
 create mode 100755 drivers/amlogic/dvb_tv/Makefile
 create mode 100755 drivers/amlogic/dvb_tv/aml_dmx.c
 create mode 100755 drivers/amlogic/dvb_tv/aml_dvb.c
 create mode 100755 drivers/amlogic/dvb_tv/aml_dvb.h
 create mode 100755 drivers/amlogic/dvb_tv/aml_fe.c
 create mode 100755 drivers/amlogic/dvb_tv/aml_fe.h
 create mode 100755 drivers/amlogic/dvb_tv/amlci/Makefile
 create mode 100755 drivers/amlogic/dvb_tv/amlci/aml_ci.c
 create mode 100755 drivers/amlogic/dvb_tv/amlci/aml_ci.h
 create mode 100755 drivers/amlogic/dvb_tv/amlci/aml_iobus.c
 create mode 100755 drivers/amlogic/dvb_tv/amlci/aml_iobus.h
 create mode 100755 drivers/amlogic/dvb_tv/amlci/aml_pcmcia.c
 create mode 100755 drivers/amlogic/dvb_tv/amlci/aml_pcmcia.h
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/Makefile
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/acf_filter_coefficient.h
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/aml_demod.c
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/aml_demod.h
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/amlfrontend.h
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/demod_func.c
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/demod_func.h
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/dvbc_func.c
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/dvbt_func.c
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/i2c_func.c
 create mode 100755 drivers/amlogic/dvb_tv/amldemod/tuner_func.c
 create mode 100755 drivers/amlogic/dvb_tv/atbm887x/Kconfig
 create mode 100755 drivers/amlogic/dvb_tv/atbm887x/Makefile
 create mode 100755 drivers/amlogic/dvb_tv/atbm887x/atbm886x.c
 create mode 100755 drivers/amlogic/dvb_tv/atbm887x/atbm886x.h
 create mode 100755 drivers/amlogic/dvb_tv/atbm887x/atbm887x.c
 create mode 100755 drivers/amlogic/dvb_tv/atbm887x/atbm887x.h
 create mode 100755 drivers/amlogic/dvb_tv/atbm887x/atbmfrontend.c
 create mode 100755 drivers/amlogic/dvb_tv/cresta/Makefile
 create mode 100755 drivers/amlogic/dvb_tv/cresta/ctc703_firmware.c
 create mode 100755 drivers/amlogic/dvb_tv/cresta/ctc703_frontend.c
 create mode 100755 drivers/amlogic/dvb_tv/cresta/ctc703_func.c
 create mode 100755 drivers/amlogic/dvb_tv/cresta/ctc703_func.h
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/Makefile
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/MaxLinearDataTypes.h
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.c
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.h
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCfg.c
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCtrlApi.c
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCtrlApi.h
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyDefs.h
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/demod_MxL101SF.c
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/demod_MxL101SF.h
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/drvCofdmDmd.c
 create mode 100755 drivers/amlogic/dvb_tv/mxl101/mxlfrontend.c
 create mode 100755 drivers/amlogic/dvb_tv/si2176/Makefile
 create mode 100755 drivers/amlogic/dvb_tv/si2176/si2176_frontend.c
 create mode 100755 drivers/amlogic/dvb_tv/si2176/si2176_func.c
 create mode 100755 drivers/amlogic/dvb_tv/si2176/si2176_func.h
 create mode 100755 drivers/amlogic/dvb_tv/si2177/Makefile
 create mode 100755 drivers/amlogic/dvb_tv/si2177/si2177_frontend.c
 create mode 100755 drivers/amlogic/dvb_tv/si2177/si2177_func.c
 create mode 100755 drivers/amlogic/dvb_tv/si2177/si2177_func.h
 create mode 100755 drivers/amlogic/dvb_tv/si2196/Makefile
 create mode 100755 drivers/amlogic/dvb_tv/si2196/si2196_frontend.c
 create mode 100755 drivers/amlogic/dvb_tv/si2196/si2196_func.c
 create mode 100755 drivers/amlogic/dvb_tv/si2196/si2196_func.h
 mode change 100644 => 100755 drivers/media/Kconfig
 mode change 100644 => 100755 drivers/media/dvb-core/Kconfig
 mode change 100644 => 100755 drivers/media/dvb-core/demux.h
 mode change 100644 => 100755 drivers/media/dvb-core/dmxdev.h
 mode change 100644 => 100755 drivers/media/dvb-core/dvb_ca_en50221.h
 mode change 100644 => 100755 drivers/media/dvb-core/dvb_frontend.c
 mode change 100644 => 100755 drivers/media/dvb-core/dvb_frontend.h
 mode change 100644 => 100755 drivers/media/dvb-core/dvb_net.c
 mode change 100644 => 100755 drivers/media/dvb-core/dvbdev.c
 mode change 100644 => 100755 drivers/media/dvb-core/dvbdev.h
 create mode 100755 include/linux/amlogic/amdsc.h
 mode change 100644 => 100755 include/uapi/linux/dvb/frontend.h

diff --git a/arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd b/arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd
index 3fe9311efb72..cb779da63338 100755
--- a/arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd
@@ -729,5 +729,100 @@
 		>;
 	};
 
+//$$ MATCH "dvb_p_ts0_pins_match" = "&dvb_p_ts0_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 8 = "amlogic,clrmask"
+//$$ L2 PROP_STR 12 = "amlogic,pins"
+	dvb_p_ts0_pins: dvb_p_ts0_pins {
+		amlogic,setmask = <3 0x3F>;
+		amlogic,clrmask = <1 0xCCC41
+				   4 0x2000000
+				   7 0x20000000
+				   9 0x431F>;
+		amlogic,pins = "GPIOY_9","GPIOY_10","GPIOY_11","GPIOY_12","GPIOY_13","GPIOY_14","GPIOY_15","GPIOY_16","GPIOY_0","GPIOY_1","GPIOY_4","GPIOY_8";
+	};
+
+//$$ MATCH "dvb_s_ts0_pins_match" = "&dvb_s_ts0_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 8 = "amlogic,clrmask"
+//$$ L2 PROP_STR 12 = "amlogic,pins"
+	dvb_s_ts0_pins: dvb_s_ts0_pins {
+		amlogic,setmask = <3 0x2F>;
+		amlogic,clrmask = <1 0xCCC41
+				   4 0x2000000
+				   7 0x20000000
+				   9 0x4310>;
+		amlogic,pins = "GPIOY_9","GPIOY_10","GPIOY_11","GPIOY_12","GPIOY_13","GPIOY_14","GPIOY_15","GPIOY_16","GPIOY_0","GPIOY_1","GPIOY_4","GPIOY_8";
+	};
+
+	//$$ MATCH "dvb_p_ts1_pins_match" = "&dvb_p_ts1_pins"
+	dvb_p_ts1_pins: dvb_p_ts1_pins {
+	};
+
+	//$$ MATCH "dvb_s_ts1_pins_match" = "&dvb_s_ts1_pins"
+	dvb_s_ts1_pins: dvb_s_ts1_pins {
+	};
+
+	//$$ MATCH "dvb_p_ts2_pins_match" = "&dvb_p_ts2_pins"
+	dvb_p_ts2_pins: dvb_p_ts2_pins {
+	};
+
+	//$$ MATCH "dvb_s_ts2_pins_match" = "&dvb_s_ts2_pins"
+	dvb_s_ts2_pins: dvb_s_ts2_pins {
+	};
+
+	//$$ MATCH "dvb_fe_pins_match" = "&dvb_fe_pins"
+	dvb_fe_pins: dvb_fe_pins {
+	};
+
+
+	amlogic_dvb_fe_device {
+		compatible = "amlogic,dvbfe";
+		dev_name = "amlogic-dvb-fe";
+		status = "ok";
+		dtv_demod0 = <0>;    /**   DTV demod: M6=0, MXL101=2, ATBM8869=4 */
+		dtv_demod0_i2c_adap_id = <0>;
+		dtv_demod0_i2c_addr = <0x60>;
+		dtv_demod0_reset_value = <0>;
+		dtv_demod0_reset_gpio = "GPIOX_8" ;
+		fe0_dtv_demod = <0>;
+		fe0_ts = <2>;
+		fe0_dev = <0>;
+		fe0_mem = <0>;
+		reserve-memory = <0x06400000>;
+		reserve-iomap = "true";
+		tuner0 = <6>;
+		tuner0_i2c_adap_id = <1>;
+		tuner0_i2c_addr = <0x60>;
+		tuner0_reset_value = <0>;
+		tuner0_reset_gpio =  "GPIOX_8" ;  /*GPIOX_8   76*/
+		fe0_tuner = <0>;
+		atv_demod0 = <6>;
+		fe0_atv_demod = <0>;
+		fe1_tuner = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&dvb_fe_pins>;
+	};
+
+	amlogic_dvb_device {
+		compatible = "amlogic,dvb";
+		/*"parallel","serial","disable"*/
+		ts0 = "parallel";
+		ts1 = "serial";
+		ts2 = "parallel";
+		ts0_control = <0>;
+		ts1_control = <0>;
+		ts2_control = <0x800>;
+		ts0_invert = <0>;
+		ts1_invert = <0>;
+		ts2_invert = <1>;
+		pinctrl-names = "p_ts0", "s_ts0", "p_ts1", "s_ts1", "p_ts2", "s_ts2";
+		pinctrl-0 = <&dvb_p_ts0_pins>;
+		pinctrl-1 = <&dvb_s_ts0_pins>;
+		pinctrl-2 = <&dvb_p_ts1_pins>;
+		pinctrl-3 = <&dvb_s_ts1_pins>;
+		pinctrl-4 = <&dvb_p_ts2_pins>;
+		pinctrl-5 = <&dvb_s_ts2_pins>;
+	};
 }; /* end of / */
 
diff --git a/arch/arm/configs/meson6tvd_defconfig b/arch/arm/configs/meson6tvd_defconfig
index 64a90d53c9e0..48195247cdfc 100755
--- a/arch/arm/configs/meson6tvd_defconfig
+++ b/arch/arm/configs/meson6tvd_defconfig
@@ -163,14 +163,15 @@ CONFIG_TVIN_VBI=y
 CONFIG_TVIN_HDMI=y
 # CONFIG_TVIN_BT656 is not set
 # CONFIG_TVIN_CSI is not set
-CONFIG_POST_PROCESS_MANAGER=y
-CONFIG_POST_PROCESS_MANAGER_PPSCALER=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE=y
 CONFIG_AMLOGIC_CAPTURE_FRAME_ROTATE=y
 CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER=y
 CONFIG_AMLOGIC_IONVIDEO=y
 CONFIG_DEINTERLACE=y
 CONFIG_AM_VECM=y
+CONFIG_AM_DVB=y
+CONFIG_AM_M6_DEMOD=y
+CONFIG_AM_SI2177=y
 CONFIG_MALI400=y
 CONFIG_MALI400_DEBUG=y
 # CONFIG_CRYPTO_AML_HW_CRYPRO is not set
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index 9a4c7d4c6935..5247fc51749e 100755
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -90,7 +90,7 @@ source "drivers/amlogic/deinterlace/Kconfig"
 source "drivers/amlogic/mipi/Kconfig"
 #source "drivers/amlogic/d2d3/Kconfig"
 source "drivers/amlogic/amvecm/Kconfig"
-
+source "drivers/amlogic/dvb_tv/Kconfig"
 #deferred module for speed
 #source "drivers/amlogic/load_deferred_module/Kconfig"
 
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 41c4274b5e47..ffb54d919012 100755
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -92,18 +92,9 @@ obj-$(CONFIG_AMAUDIO) += amaudio/
 obj-y += mhl/
 obj-y += hdmi/
 
-ifeq ($(CONFIG_AM_NEW_TV_ARCH),y)
-#obj-$(CONFIG_AM_DVB) += dvb_tv/
-else
-#obj-$(CONFIG_AM_DVB) += dvb/
-endif
-
+obj-$(CONFIG_AM_DVB) += dvb_tv/
 obj-$(CONFIG_AM_SMARTCARD) += smartcard/
 
-ifneq ($(CONFIG_AM_NEW_TV_ARCH),y)
-#obj-y += demod/
-endif
-
 obj-$(CONFIG_AM_WIFI) += wifi/
 obj-$(CONFIG_SDIO_DHD_CDC_WIFI_40181_MODULE) += ../../../hardware/wifi/broadcom/drivers/ap6xxx/broadcm_40181/
 obj-$(CONFIG_RTL8188EU) += ../../../hardware/wifi/realtek/drivers/8188eu/rtl8xxx_EU/
diff --git a/drivers/amlogic/dvb_tv/Kconfig b/drivers/amlogic/dvb_tv/Kconfig
new file mode 100755
index 000000000000..c2136c5a8e72
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/Kconfig
@@ -0,0 +1,270 @@
+#
+# DVB driver configuration
+#
+
+menu "Amlogic DVB driver"
+
+config AM_DVB
+	tristate "AMLOGIC DVB driver"
+	default n
+	select DVB_CORE
+	help
+		Select to enable AMLogic DVB driver.
+
+menu "AMLOGIC CI Driver"
+
+config AM_CI
+	tristate "Amlogic Common Interface driver"
+	default n
+	depends on AM_DVB
+	select AM_PCMCIA
+	select AM_IOBUS
+	help
+		Select to enable Amlogic CI driver.
+
+config AM_PCMCIA
+	tristate "Amlogic PCMCIA driver"
+	default n
+	help
+		Select to enable Amlogic PCMCIA driver.
+
+config AM_IOBUS
+	tristate "Amlogic IOBUS driver"
+	default n
+	help
+		Select to enable Amlogic IOBUS driver.
+
+endmenu
+
+if !OF
+config AMLOGIC_DYNAMIC_FEANDDMX_CONFIG
+	bool "Support Dynamic Frontend And Demux Config"
+	default n
+	depends on AM_DVB
+	help
+		Support dynamic frontend and demux config.
+
+if !AMLOGIC_DYNAMIC_FEANDDMX_CONFIG
+
+config AMLOGIC_TS0
+	bool "Enable TS0"
+	default n
+	depends on AM_DVB
+	help
+		Enable TS0.
+
+config AMLOGIC_S_TS0
+	bool "Serial TS0"
+	default n
+	depends on AMLOGIC_TS0
+	help
+		TS0 in serial mode.
+
+config AMLOGIC_TS0_INVERT_S2P1_FEC_ERROR
+	bool "Invert FEC_ERROR TS0"
+	default n
+	depends on AMLOGIC_S_TS0
+	help
+		TS0 FEC_ERROR invert
+
+config AMLOGIC_TS0_INVERT_S2P1_FEC_DATA
+	bool "Invert FEC_DATA TS0"
+	default n
+	depends on AMLOGIC_S_TS0
+	help
+		TS0 FEC_DATA invert
+
+config AMLOGIC_TS0_INVERT_S2P1_FEC_SYNC
+	bool "Invert FEC_SYNC TS0"
+	default n
+	depends on AMLOGIC_S_TS0
+	help
+		TS0 FEC_SYNC invert
+
+config AMLOGIC_TS0_INVERT_S2P1_FEC_VALID
+	bool "Invert FEC_VALID TS0"
+	default n
+	depends on AMLOGIC_S_TS0
+	help
+		TS0 FEC_VALID invert
+
+config AMLOGIC_TS0_INVERT_S2P1_FEC_CLK
+	bool "Invert FEC_CLK TS0"
+	default n
+	depends on AMLOGIC_S_TS0
+	help
+		TS0 FEC_CLK invert
+
+config AMLOGIC_TS1
+	bool "Enable TS1"
+	default n
+	depends on AM_DVB
+	help
+		Enable TS1.
+
+config AMLOGIC_S_TS1
+	bool "Serial TS1"
+	default n
+	depends on AMLOGIC_TS1
+	help
+		TS1 in serial mode.
+
+config AMLOGIC_TS1_INVERT_S2P1_FEC_ERROR
+	bool "Invert FEC_ERROR TS1"
+	default n
+	depends on AMLOGIC_S_TS1
+	help
+		TS1 FEC_ERROR invert
+
+config AMLOGIC_TS1_INVERT_S2P1_FEC_DATA
+	bool "Invert FEC_DATA TS1"
+	default n
+	depends on AMLOGIC_S_TS1
+	help
+		TS1 FEC_DATA invert
+
+config AMLOGIC_TS1_INVERT_S2P1_FEC_SYNC
+	bool "Invert FEC_SYNC TS1"
+	default n
+	depends on AMLOGIC_S_TS1
+	help
+		TS1 FEC_SYNC invert
+
+config AMLOGIC_TS1_INVERT_S2P1_FEC_VALID
+	bool "Invert FEC_VALID TS1"
+	default n
+	depends on AMLOGIC_S_TS1
+	help
+		TS1 FEC_VALID invert
+
+config AMLOGIC_TS1_INVERT_S2P1_FEC_CLK
+	bool "Invert FEC_CLK TS1"
+	default n
+	depends on AMLOGIC_S_TS1
+	help
+		TS1 FEC_CLK invert
+
+config AMLOGIC_TS2
+	bool "Enable TS2"
+	default n
+	depends on AM_DVB
+	help
+		Enable TS2.
+
+config AMLOGIC_S_TS2
+	bool "Serial TS2"
+	default n
+	depends on AMLOGIC_TS2
+	help
+		TS2 in serial mode.
+
+config AMLOGIC_TS2_INVERT_S2P1_FEC_ERROR
+	bool "Invert FEC_ERROR TS2"
+	default n
+	depends on AMLOGIC_S_TS2
+	help
+		TS2 FEC_ERROR invert
+
+config AMLOGIC_TS2_INVERT_S2P1_FEC_DATA
+	bool "Invert FEC_DATA TS2"
+	default n
+	depends on AMLOGIC_S_TS2
+	help
+		TS2 FEC_DATA invert
+
+config AMLOGIC_TS2_INVERT_S2P1_FEC_SYNC
+	bool "Invert FEC_SYNC TS2"
+	default n
+	depends on AMLOGIC_S_TS2
+	help
+		TS2 FEC_SYNC invert
+
+config AMLOGIC_TS2_INVERT_S2P1_FEC_VALID
+	bool "Invert FEC_VALID TS2"
+	default n
+	depends on AMLOGIC_S_TS2
+	help
+		TS2 FEC_VALID invert
+
+config AMLOGIC_TS2_INVERT_S2P1_FEC_CLK
+	bool "Invert FEC_CLK TS2"
+	default n
+	depends on AMLOGIC_S_TS2
+	help
+		TS2 FEC_CLK invert
+
+endif
+endif
+
+config AM_MXL101
+	tristate "MXL101 demod driver"
+	default n
+	depends on AM_DVB
+	help
+		Select to enable MXL101(dvbt) demod driver.
+
+config AM_AVL6211
+	tristate "AVL6211 demod driver"
+	default n
+	depends on AM_DVB
+	help
+		Select to enable AVL6211(dvbs2) demod driver.
+
+config AM_SI2168
+	tristate "SI2168 demod driver"
+	default n
+	depends on AM_DVB
+	help
+		Select to enable SI2168(dvbt,dvbt2) demod driver.
+
+config AM_ITE9133
+	tristate "ITE9133 demod driver"
+	default n
+	depends on AM_DVB
+	help
+		Select to enable ITE9133(dvbt) demod driver.
+
+config AM_ITE9173
+	tristate "ITE9173 demod driver"
+	default n
+	depends on AM_DVB
+	help
+		Select to enable ITE9173(isdbt) demod driver.
+
+config AM_M6_DEMOD
+	tristate "M6 demod driver"
+	default n
+	depends on AM_DVB
+	help
+		Select to enable M6 demod driver.
+
+config AM_SI2176
+    tristate "SI2176 tuner driver"
+    default n
+    depends on AM_DVB
+	help
+		Select to enable SI2176 driver.
+config AM_SI2196
+    tristate "SI2196 tuner driver"
+    default n
+    depends on AM_DVB
+	help
+		Select to enable SI2196 driver.
+config AM_CTC703
+	tristate "CRESTA tuner driver"
+	default n
+	depends on AM_DVB
+	help
+		select the cresta tuner.
+
+source "drivers/amlogic/dvb_tv/atbm887x/Kconfig"
+
+config AM_SI2177
+	tristate "SI2177 tuner"
+	default n
+	depends on AM_DVB
+	help
+		select the 2177 tuner.
+
+endmenu
+
diff --git a/drivers/amlogic/dvb_tv/Makefile b/drivers/amlogic/dvb_tv/Makefile
new file mode 100755
index 000000000000..c4fb82f74256
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/Makefile
@@ -0,0 +1,27 @@
+#
+# Makefile for the DVB driver.
+#
+
+obj-$(CONFIG_AM_DVB) += aml.o
+
+aml-objs=aml_dvb.o aml_dmx.o aml_fe.o
+
+obj-$(CONFIG_AM_CI) += amlci/
+
+obj-$(CONFIG_AM_MXL101) += mxl101/
+
+#obj-$(CONFIG_AM_AVL6211) += avl6211/
+
+#obj-$(CONFIG_AM_SI2168) += si2168/
+
+#obj-$(CONFIG_AM_ITE9133) += ite9133/
+
+#obj-$(CONFIG_AM_ITE9173) += ite9173/
+
+obj-$(CONFIG_AM_M6_DEMOD) += amldemod/
+
+obj-$(CONFIG_AM_SI2176) += si2176/
+obj-$(CONFIG_AM_SI2196) += si2196/
+obj-$(CONFIG_AM_CTC703) += cresta/
+obj-$(CONFIG_AM_ATBM8869) += atbm887x/
+obj-$(CONFIG_AM_SI2177) += si2177/
diff --git a/drivers/amlogic/dvb_tv/aml_dmx.c b/drivers/amlogic/dvb_tv/aml_dmx.c
new file mode 100755
index 000000000000..1467245bd3a8
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/aml_dmx.c
@@ -0,0 +1,3025 @@
+/*
+ * AMLOGIC Smart card driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <linux/dma-mapping.h>
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+#include <mach/am_regs.h>
+#endif
+
+#include <mach/pinmux.h>
+
+#include "aml_dvb.h"
+
+#include "../amports/streambuf.h"
+
+#define ENABLE_SEC_BUFF_WATCHDOG
+#define USE_AHB_MODE
+
+#define pr_dbg(fmt, args...)\
+	do{\
+		if(debug_dmx)\
+			printk("DVB: " fmt, ## args);\
+	}while(0)
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+
+MODULE_PARM_DESC(debug_dmx, "\n\t\t Enable demux debug information");
+static int debug_dmx = 0;
+module_param(debug_dmx, int, S_IRUGO);
+
+MODULE_PARM_DESC(debug_irq, "\n\t\t Enable demux IRQ debug information");
+static int debug_irq = 0;
+module_param(debug_irq, int, S_IRUGO);
+
+
+#define DMX_READ_REG(i,r)\
+	((i)?((i==1)?READ_MPEG_REG(r##_2):READ_MPEG_REG(r##_3)):READ_MPEG_REG(r))
+
+#define DMX_WRITE_REG(i,r,d)\
+	do{\
+	if(i==1) {\
+		WRITE_MPEG_REG(r##_2,d);\
+	} else if(i==2) {\
+		WRITE_MPEG_REG(r##_3,d);\
+	}\
+	else {\
+		WRITE_MPEG_REG(r,d);\
+	}\
+	}while(0)
+
+#define READ_PERI_REG				READ_CBUS_REG
+#define WRITE_PERI_REG			WRITE_CBUS_REG
+
+#define READ_ASYNC_FIFO_REG(i,r)\
+	((i) ? READ_PERI_REG(ASYNC_FIFO2_##r) : READ_PERI_REG(ASYNC_FIFO_##r))
+
+#define WRITE_ASYNC_FIFO_REG(i,r,d)\
+	do {\
+		if (i==1) {\
+			WRITE_PERI_REG(ASYNC_FIFO2_##r, d);\
+		} else {\
+			WRITE_PERI_REG(ASYNC_FIFO_##r, d);\
+		}\
+	}while(0)
+
+#define CLEAR_ASYNC_FIFO_REG_MASK(i,reg,mask) WRITE_ASYNC_FIFO_REG(i, reg, (READ_ASYNC_FIFO_REG(i, reg)&(~(mask))))
+
+#define DVR_FEED(f)							\
+	((f) && ((f)->type == DMX_TYPE_TS) &&					\
+	(((f)->ts_type & (TS_PACKET | TS_DEMUX)) == TS_PACKET))
+
+#define NO_SUB
+
+#define SYS_CHAN_COUNT    (4)
+#define SEC_GRP_LEN_0     (0xc)
+#define SEC_GRP_LEN_1     (0xc)
+#define SEC_GRP_LEN_2     (0xc)
+#define SEC_GRP_LEN_3     (0xc)
+#define LARGE_SEC_BUFF_MASK  0xFFFFFFFF
+#define LARGE_SEC_BUFF_COUNT 32
+#define WATCHDOG_TIMER    250
+
+#define DEMUX_INT_MASK\
+			((0<<(AUDIO_SPLICING_POINT))    |\
+			(0<<(VIDEO_SPLICING_POINT))     |\
+			(0<<(OTHER_PES_READY))          |\
+			(1<<(SUB_PES_READY))            |\
+			(1<<(SECTION_BUFFER_READY))     |\
+			(0<<(OM_CMD_READ_PENDING))      |\
+			(1<<(TS_ERROR_PIN))             |\
+			(1<<(NEW_PDTS_READY))           |\
+			(0<<(DUPLICATED_PACKET))        |\
+			(0<<(DIS_CONTINUITY_PACKET)))
+
+#define TS_SRC_MAX 3
+
+
+/*Reset the demux device*/
+void dmx_reset_hw(struct aml_dvb *dvb);
+void dmx_reset_hw_ex(struct aml_dvb *dvb, int reset_irq);
+static int dmx_remove_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed);
+static void reset_async_fifos(struct aml_dvb *dvb);
+static int dmx_add_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed);
+
+/*Audio & Video PTS value*/
+static u32 video_pts = 0;
+static u32 audio_pts = 0;
+static u32 first_video_pts = 0;
+static u32 first_audio_pts = 0;
+static int demux_skipbyte = 0;
+static int tsfile_clkdiv = 4;
+
+/*Section buffer watchdog*/
+static void section_buffer_watchdog_func(unsigned long arg)
+{
+	struct aml_dvb *dvb = (struct aml_dvb*)arg;
+	struct aml_dmx *dmx;
+	u32 section_busy32 = 0, om_cmd_status32 = 0, demux_channel_activity32 = 0;
+	u16 demux_int_status1 = 0;
+	u32 device_no = 0;
+	u32 filter_number = 0;
+	u32 i = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	for(device_no=0; device_no<DMX_DEV_COUNT; device_no++) {
+		dmx = &dvb->dmx[device_no];
+
+		if(dmx->init) {
+			om_cmd_status32 = DMX_READ_REG(device_no, OM_CMD_STATUS);
+			demux_channel_activity32 = DMX_READ_REG(device_no, DEMUX_CHANNEL_ACTIVITY);
+			section_busy32 = DMX_READ_REG(device_no, SEC_BUFF_BUSY);
+#if 1
+			if(om_cmd_status32 & 0x8fc2) { // bit 15:12 -- om_cmd_count
+						       // bit  11:9 -- overflow_count
+						       // bit   8:6 -- om_overwrite_count
+						       // bit     1 -- om_cmd_overflow
+				/*BUG: If the recoder is running, return*/
+				if (dmx->record)
+					goto end;
+				/*Reset the demux*/
+				pr_error("reset the demux %04x\t%03x\t%03x\t%03x\t%01x\t%01x\t%x\t%x\tdmx%d:status:0x%x\n",
+							(om_cmd_status32 >> 12) & 0xf,
+							(om_cmd_status32 >> 9) & 0x7,
+							(om_cmd_status32 >> 6) & 0x7,
+							(om_cmd_status32 >> 3) & 0x7,
+							(om_cmd_status32 >> 2) & 0x1,
+							(om_cmd_status32 >> 1) & 0x1,
+							demux_channel_activity32,
+							section_busy32,
+							dmx->id,
+							om_cmd_status32);
+
+				dmx_reset_hw_ex(dvb, 0);
+				goto end;
+			}
+#else
+			/*
+			// bit 15:12 -- om_cmd_count (read only)
+			// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
+			// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
+			// bit   5:3 -- type_stb_om_w_rd (read only)
+			// bit     2 -- unit_start_stb_om_w_rd (read only)
+			// bit     1 -- om_cmd_overflow (read only)
+			// bit     0 -- om_cmd_pending (read)
+			// bit     0 -- om_cmd_read_finished (write)
+			*/
+			if(om_cmd_status32 & 0x0002) {
+				pr_error("reset the demux\n");
+				dmx_reset_hw_ex(dvb, 0);
+				goto end;
+			}
+#endif
+			section_busy32 = DMX_READ_REG(device_no, SEC_BUFF_BUSY);
+			if((section_busy32 & LARGE_SEC_BUFF_MASK) == LARGE_SEC_BUFF_MASK)  {
+				/*All the largest section buffers occupied, clear buffers*/
+				DMX_WRITE_REG(device_no, SEC_BUFF_READY, section_busy32);
+			} else {
+				for(i = 0; i < SEC_BUF_COUNT; i++) {
+					if(section_busy32 & (1 << i)) {
+						DMX_WRITE_REG(device_no, SEC_BUFF_NUMBER, i);
+						filter_number = (DMX_READ_REG(device_no, SEC_BUFF_NUMBER) >> 8);
+						if((filter_number >= 31) /* >=31, do not handle this case*/  ||
+						   ((filter_number<FILTER_COUNT) && dmx->filter[filter_number].used)) {
+							section_busy32 &= ~(1 << i);
+						}
+					}
+				}
+				if(section_busy32) {
+					/*Clear invalid buffers*/
+					DMX_WRITE_REG(device_no, SEC_BUFF_READY, section_busy32);
+					pr_error("clear invalid buffers 0x%x\n", section_busy32);
+				}
+#if 0
+				section_busy32 = 0x7fffffff;
+				for(i = 0; i < SEC_BUF_BUSY_SIZE; i++) {
+					dmx->section_busy[i] = ((i == SEC_BUF_BUSY_SIZE-1) ?
+							DMX_READ_REG(device_no, SEC_BUFF_BUSY) : dmx->section_busy[i+1]);
+					section_busy32 &= dmx->section_busy[i];
+				}
+
+				/*count the number of '1' bits*/
+				i = section_busy32;
+				i = (i & 0x55555555) + ((i & 0xaaaaaaaa) >> 1);
+				i = (i & 0x33333333) + ((i & 0xcccccccc) >> 2);
+				i = (i & 0x0f0f0f0f) + ((i & 0xf0f0f0f0) >> 4);
+				i = (i & 0x00ff00ff) + ((i & 0xff00ff00) >> 8);
+				i = (i & 0x0000ffff) + ((i & 0xffff0000) >> 16);
+				if(i > LARGE_SEC_BUFF_COUNT) {
+					/*too long some of the section buffers are being processed*/
+					DMX_WRITE_REG(device_no, SEC_BUFF_READY, section_busy32);
+				}
+#endif
+			}
+			demux_int_status1 = DMX_READ_REG(device_no, STB_INT_STATUS) & 0xfff7;
+			if(demux_int_status1 & (1 << TS_ERROR_PIN)) {
+				DMX_WRITE_REG(device_no, STB_INT_STATUS, (1 << TS_ERROR_PIN));
+			}
+		}
+	}
+
+end:
+	spin_unlock_irqrestore(&dvb->slock, flags);
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	mod_timer(&dvb->watchdog_timer, jiffies+msecs_to_jiffies(WATCHDOG_TIMER));
+#endif
+	return;
+}
+
+static inline int sec_filter_match(struct aml_dmx *dmx, struct aml_filter *f, u8 *p)
+{
+	int b;
+	u8 neq = 0;
+
+	if(!f->used || !dmx->channel[f->chan_id].used)
+		return 0;
+
+	for(b=0; b<FILTER_LEN; b++) {
+		u8 xor = p[b]^f->value[b];
+
+		if(xor&f->maskandmode[b])
+			return 0;
+
+		if(xor&f->maskandnotmode[b])
+			neq = 1;
+	}
+
+	if(f->neq && !neq)
+		return 0;
+
+	return 1;
+}
+
+static int section_crc(struct aml_dmx *dmx, struct aml_filter *f, u8 *p)
+{
+	int sec_len = (((p[1]&0xF)<<8)|p[2])+3;
+	struct dvb_demux_feed *feed = dmx->channel[f->chan_id].feed;
+
+	if(feed->feed.sec.check_crc) {
+		struct dvb_demux *demux = feed->demux;
+		struct dmx_section_feed *sec = &feed->feed.sec;
+		int section_syntax_indicator;
+
+		section_syntax_indicator = ((p[1] & 0x80) != 0);
+		sec->seclen  = sec_len;
+		sec->crc_val = ~0;
+		if (demux->check_crc32(feed, p, sec_len)) {
+			pr_error("section CRC check failed!\n");
+
+#if 0
+			int i;
+
+			for(i=0; i<sec_len; i++)
+			{
+				printk("%02x ", p[i]);
+				if(!((i+1)%16))
+					printk("\n");
+			}
+			printk("\nerror section data\n");
+#endif
+			return 0;
+		}
+
+#if 0
+			int i;
+
+			for(i=0; i<sec_len; i++)
+			{
+				printk("%02x ", p[i]);
+				if(!((i+1)%16))
+					printk("\n");
+			}
+			printk("\nsection data\n");
+#endif
+	}
+
+	return 1;
+}
+
+static void section_notify(struct aml_dmx *dmx, struct aml_filter *f, u8 *p)
+{
+	int sec_len = (((p[1]&0xF)<<8)|p[2])+3;
+	struct dvb_demux_feed *feed = dmx->channel[f->chan_id].feed;
+
+	if(feed && feed->cb.sec) {
+		feed->cb.sec(p, sec_len, NULL, 0, f->filter, DMX_OK);
+	}
+}
+
+static void hardware_match_section(struct aml_dmx *dmx, u16 sec_num, u16 buf_num)
+{
+	u8 *p = (u8*)dmx->sec_buf[buf_num].addr;
+	struct aml_filter *f;
+	int chid, i;
+	int need_crc = 1;
+
+	if(sec_num>=FILTER_COUNT) {
+		pr_dbg("sec_num invalid: %d\n", sec_num);
+		return;
+	}
+
+	dma_sync_single_for_cpu(NULL, dmx->sec_pages_map+(buf_num<<0x0c), (1<<0x0c), DMA_FROM_DEVICE);
+
+	f = &dmx->filter[sec_num];
+	chid = f->chan_id;
+
+	for(i=0; i<FILTER_COUNT; i++) {
+		f = &dmx->filter[i];
+		if(f->chan_id!=chid)
+			continue;
+		if(sec_filter_match(dmx, f, p)) {
+			if(need_crc){
+				if(!section_crc(dmx, f, p))
+					return;
+				need_crc = 0;
+			}
+
+			section_notify(dmx, f, p);
+		}
+	}
+}
+
+static void software_match_section(struct aml_dmx *dmx, u16 buf_num)
+{
+	u8 *p = (u8*)dmx->sec_buf[buf_num].addr;
+	struct aml_filter *f, *fmatch = NULL;
+	int i, fid = -1;
+
+	dma_sync_single_for_cpu(NULL, dmx->sec_pages_map+(buf_num<<0x0c), (1<<0x0c), DMA_FROM_DEVICE);
+
+	for(i=0; i<FILTER_COUNT; i++) {
+		f = &dmx->filter[i];
+
+		if(sec_filter_match(dmx, f, p)) {
+			pr_dbg("[software match]filter %d match, pid %d\n",
+				i, dmx->channel[f->chan_id].pid);
+			if (!fmatch){
+				fmatch = f;
+				fid = i;
+			} else {
+				pr_dbg("[software match]Muli-filter match this section, will skip this section\n");
+				return;
+			}
+		}
+	}
+
+	if (fmatch) {
+		pr_dbg("[software match]dispatch section to filter %d pid %d\n", fid, dmx->channel[fmatch->chan_id].pid);
+		if(section_crc(dmx, fmatch, p)){
+			section_notify(dmx, fmatch, p);
+		}
+	} else {
+		pr_dbg("[software match]this section do not match any filter!!!\n");
+	}
+}
+
+static void process_section(struct aml_dmx *dmx)
+{
+	u32 ready, i,sec_busy;
+	u16 sec_num;
+
+	//pr_dbg("section\n");
+	ready = DMX_READ_REG(dmx->id, SEC_BUFF_READY);
+	if(ready) {
+#ifdef USE_AHB_MODE
+	//	WRITE_ISA_REG(AHB_BRIDGE_CTRL1, READ_ISA_REG (AHB_BRIDGE_CTRL1) | (1 << 31));
+	//	WRITE_ISA_REG(AHB_BRIDGE_CTRL1, READ_ISA_REG (AHB_BRIDGE_CTRL1) & (~ (1 << 31)));
+#endif
+
+		for(i=0; i<SEC_BUF_COUNT; i++) {
+			if (ready & (1 << i)) {
+				/* get section busy */
+				sec_busy = DMX_READ_REG(dmx->id, SEC_BUFF_BUSY);
+				/* get filter number */
+				DMX_WRITE_REG(dmx->id, SEC_BUFF_NUMBER, i);
+				sec_num = (DMX_READ_REG(dmx->id, SEC_BUFF_NUMBER) >> 8);
+
+				/*
+				 * sec_buf_watchdog_count dispatch:
+				 * byte0 -- always busy=0 's watchdog count
+				 * byte1 -- always busy=1 & filter_num=31 's watchdog count
+				*/
+
+				/* sec_busy is not set, check busy=0 watchdog count */
+				if (! (sec_busy & (1 << i))) {
+					/* clear other wd count of this buffer */
+					dmx->sec_buf_watchdog_count[i] &= 0x000000ff;
+					dmx->sec_buf_watchdog_count[i] += 0x1;
+					pr_dbg("bit%d ready=1, busy=0, sec_num=%d for %d times\n",i,sec_num,dmx->sec_buf_watchdog_count[i]);
+					if (dmx->sec_buf_watchdog_count[i] >= 5) {
+						pr_dbg("busy=0 reach the max count, try software match.\n");
+						software_match_section(dmx, i);
+						dmx->sec_buf_watchdog_count[i] = 0;
+						DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, (1 << i));
+					}
+					continue;
+				}
+
+				/* filter_num == 31 && busy == 1, check watchdog count */
+				if (sec_num >= 31) {
+					/* clear other wd count of this buffer */
+					dmx->sec_buf_watchdog_count[i] &= 0x0000ff00;
+					dmx->sec_buf_watchdog_count[i] += 0x100;
+					pr_dbg("bit%d ready=1,busy=1,sec_num=%d for %d times\n",i,sec_num,dmx->sec_buf_watchdog_count[i]>>8);
+					if (dmx->sec_buf_watchdog_count[i] >= 0x500) {
+						pr_dbg("busy=1&filter_num=31 reach the max count, clear the buf ready & busy!\n");
+						software_match_section(dmx, i);
+						dmx->sec_buf_watchdog_count[i] = 0;
+						DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, (1 << i));
+						DMX_WRITE_REG(dmx->id, SEC_BUFF_BUSY, (1 << i));
+					}
+					continue;
+				}
+
+				/* now, ready & busy are both set and filter number is valid */
+				if (dmx->sec_buf_watchdog_count[i] != 0)
+					dmx->sec_buf_watchdog_count[i] = 0;
+
+				/* process this section */
+				hardware_match_section(dmx, sec_num, i);
+
+				/* clear the ready & busy bit */
+				DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, (1 << i));
+				DMX_WRITE_REG(dmx->id, SEC_BUFF_BUSY, (1 << i));
+			}
+		}
+	}
+}
+
+#ifdef NO_SUB
+static void process_sub(struct aml_dmx *dmx)
+{
+
+	int rd_ptr=0;
+
+	int wr_ptr=READ_MPEG_REG(PARSER_SUB_WP);
+	int start_ptr=READ_MPEG_REG(PARSER_SUB_START_PTR);
+	int end_ptr=READ_MPEG_REG(PARSER_SUB_END_PTR);
+
+	unsigned char *buffer1=0,*buffer2=0;
+	unsigned char *buffer1_virt=0, *buffer2_virt=0;
+	int len1=0,len2=0;
+
+
+	rd_ptr=READ_MPEG_REG(PARSER_SUB_RP);
+	if(!rd_ptr)
+		return;
+	if(rd_ptr>wr_ptr)
+	{
+		len1=end_ptr-rd_ptr+8;
+		buffer1=(unsigned char*)rd_ptr;
+
+		len2=wr_ptr-start_ptr;
+		buffer2=(unsigned char*)start_ptr;
+
+		rd_ptr=start_ptr+len2;
+	}
+	else if(rd_ptr<wr_ptr)
+	{
+		len1=wr_ptr-rd_ptr;
+		buffer1=(unsigned char *)rd_ptr;
+		rd_ptr+=len1;
+		len2=0;
+	}
+	else if(rd_ptr==wr_ptr)
+	{
+		pr_dbg("no data\n");
+	}
+
+
+	if(buffer1)
+		buffer1_virt=phys_to_virt((long unsigned int)buffer1);
+	if(buffer2)
+		buffer2_virt=phys_to_virt((long unsigned int)buffer2);
+
+	if(len1)
+		dma_sync_single_for_cpu(NULL, (dma_addr_t)buffer1, len1, DMA_FROM_DEVICE);
+	if(len2)
+		dma_sync_single_for_cpu(NULL, (dma_addr_t)buffer2, len2, DMA_FROM_DEVICE);
+
+	if(dmx->channel[2].used)
+	{
+		if(dmx->channel[2].feed && dmx->channel[2].feed->cb.ts)
+		{
+			dmx->channel[2].feed->cb.ts(buffer1_virt,len1,buffer2_virt,len2,&dmx->channel[2].feed->feed.ts,DMX_OK);
+		}
+	}
+	WRITE_MPEG_REG(PARSER_SUB_RP,rd_ptr);
+}
+#endif
+
+static void process_pes(struct aml_dmx *dmx)
+{
+}
+
+static void process_om_read(struct aml_dmx *dmx)
+{
+	unsigned i;
+	unsigned short om_cmd_status_data_0 = 0;
+	unsigned short om_cmd_status_data_1 = 0;
+//	unsigned short om_cmd_status_data_2 = 0;
+	unsigned short om_cmd_data_out = 0;
+
+	om_cmd_status_data_0 = DMX_READ_REG(dmx->id, OM_CMD_STATUS);
+	om_cmd_status_data_1 = DMX_READ_REG(dmx->id, OM_CMD_DATA);
+//	om_cmd_status_data_2 = DMX_READ_REG(dmx->id, OM_CMD_DATA2);
+
+	if(om_cmd_status_data_0 & 1) {
+		DMX_WRITE_REG(dmx->id, OM_DATA_RD_ADDR, (1<<15) | ((om_cmd_status_data_1 & 0xff) << 2));
+		for(i = 0; i<(((om_cmd_status_data_1 >> 7) & 0x1fc) >> 1); i++) {
+			om_cmd_data_out = DMX_READ_REG(dmx->id, OM_DATA_RD);
+		}
+
+		om_cmd_data_out = DMX_READ_REG(dmx->id, OM_DATA_RD_ADDR);
+		DMX_WRITE_REG(dmx->id, OM_DATA_RD_ADDR, 0);
+		DMX_WRITE_REG(dmx->id, OM_CMD_STATUS, 1);
+	}
+}
+
+static void dmx_irq_bh_handler(unsigned long arg)
+{
+#if 0
+	struct aml_dmx *dmx = (struct aml_dmx*)arg;
+	u32 status;
+
+	status = DMX_READ_REG(dmx->id, STB_INT_STATUS);
+
+	if(status) {
+		DMX_WRITE_REG(dmx->id, STB_INT_STATUS, status);
+	}
+#endif
+	return;
+}
+
+static irqreturn_t dmx_irq_handler(int irq_number, void *para)
+{
+	extern void dvb_frontend_retune(struct dvb_frontend *fe);
+	struct aml_dmx *dmx = (struct aml_dmx*)para;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	u32 status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	status = DMX_READ_REG(dmx->id, STB_INT_STATUS);
+	if(!status) goto irq_handled;
+
+	if(debug_irq){
+		pr_dbg("demux %d irq status: 0x08%x\n", dmx->id, status);
+	}
+
+	if(status & (1<<SECTION_BUFFER_READY)) {
+		process_section(dmx);
+	}
+#ifdef NO_SUB
+        if(status & (1<<SUB_PES_READY)) {
+		/*If the subtitle is set by tsdemux, do not parser in demux driver.*/
+		if(dmx->sub_chan==-1){
+			process_sub(dmx);
+		}
+	}
+#endif
+	if(status & (1<<OTHER_PES_READY)) {
+		process_pes(dmx);
+	}
+	if(status & (1<<OM_CMD_READ_PENDING)) {
+		process_om_read(dmx);
+	}
+	if(status & (1<<DUPLICATED_PACKET)) {
+	}
+	if(status & (1<<DIS_CONTINUITY_PACKET)) {
+	}
+	if(status & (1<<VIDEO_SPLICING_POINT)) {
+	}
+	if(status & (1<<AUDIO_SPLICING_POINT)) {
+	}
+	if(status & (1<<TS_ERROR_PIN)) {
+		//pr_error("TS_ERROR_PIN\n");
+	}
+	 if (status & (1 << NEW_PDTS_READY)) {
+		 u32 pdts_status = DMX_READ_REG(dmx->id, STB_PTS_DTS_STATUS);
+
+		if (pdts_status & (1 << VIDEO_PTS_READY)){
+			video_pts = DMX_READ_REG(dmx->id, VIDEO_PTS_DEMUX);
+			if(!first_video_pts || 0 > (int)(video_pts - first_video_pts))
+				first_video_pts = video_pts;
+		}
+
+		if (pdts_status & (1 << AUDIO_PTS_READY)){
+		   	audio_pts = DMX_READ_REG(dmx->id, AUDIO_PTS_DEMUX);
+			if(!first_audio_pts || 0 > (int)(audio_pts - first_audio_pts))
+				first_audio_pts = audio_pts;
+		}
+	}
+
+	if(dmx->irq_handler) {
+		dmx->irq_handler(dmx->dmx_irq, (void*)dmx->id);
+	}
+
+	DMX_WRITE_REG(dmx->id, STB_INT_STATUS, status);
+
+	tasklet_schedule(&dmx->dmx_tasklet);
+
+	{
+		if(!dmx->int_check_time){
+			dmx->int_check_time  = jiffies;
+			dmx->int_check_count = 0;
+		}
+
+		if(jiffies_to_msecs(jiffies - dmx->int_check_time)>=100 || dmx->int_check_count>1000){
+			if(dmx->int_check_count > 1000){
+				struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+				pr_error("Too many interrupts (%d interrupts in %d ms)!\n",
+						dmx->int_check_count, jiffies_to_msecs(jiffies - dmx->int_check_time));
+				if(dmx->fe && !dmx->in_tune){
+					DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+					dvb_frontend_retune(dmx->fe);
+				}
+				dmx_reset_hw_ex(dvb, 0);
+			}
+			dmx->int_check_time = 0;
+		}
+
+		dmx->int_check_count++;
+
+		if(dmx->in_tune){
+			dmx->error_check++;
+			if(dmx->error_check>200){
+				DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+			}
+		}
+	}
+
+irq_handled:
+	spin_unlock_irqrestore(&dvb->slock, flags);
+	return IRQ_HANDLED;
+}
+
+static inline int dmx_get_order(unsigned long size){
+	int order;
+
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+
+	return order;
+}
+
+static void dvr_irq_bh_handler(unsigned long arg)
+{
+	struct aml_asyncfifo *afifo = (struct aml_asyncfifo *)arg;
+	struct aml_dvb *dvb = afifo->dvb;
+	struct aml_dmx *dmx;
+	u32 size, total;
+	int i, factor;
+	unsigned long flags;
+
+	if(debug_irq){
+		pr_dbg("async fifo %d irq\n", afifo->id);
+	}
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dvb && afifo->source >= AM_DMX_0 && afifo->source < AM_DMX_MAX) {
+		dmx = &dvb->dmx[afifo->source];
+		if (dmx->init && dmx->record) {
+			total  = afifo->buf_len/afifo->flush_size;
+			factor = dmx_get_order(total);
+			size   = afifo->buf_len >> factor;
+
+			for(i=0; i<CHANNEL_COUNT; i++) {
+				if(dmx->channel[i].used && dmx->channel[i].dvr_feed) {
+					int cnt;
+
+					if(afifo->buf_read > afifo->buf_toggle){
+						cnt = total - afifo->buf_read;
+						dma_sync_single_for_cpu(NULL, afifo->pages_map+afifo->buf_read*size, cnt*size, DMA_FROM_DEVICE);
+						dmx->channel[i].dvr_feed->cb.ts((u8*)afifo->pages+afifo->buf_read*size, cnt*size, NULL, 0, &dmx->channel[i].dvr_feed->feed.ts, DMX_OK);
+						afifo->buf_read = 0;
+					}
+
+					if(afifo->buf_toggle > afifo->buf_read){
+						cnt = afifo->buf_toggle - afifo->buf_read;
+						dma_sync_single_for_cpu(NULL, afifo->pages_map+afifo->buf_read*size, cnt*size, DMA_FROM_DEVICE);
+						dmx->channel[i].dvr_feed->cb.ts((u8*)afifo->pages+afifo->buf_read*size, cnt*size, NULL, 0, &dmx->channel[i].dvr_feed->feed.ts, DMX_OK);
+						afifo->buf_read = afifo->buf_toggle;
+					}
+
+					pr_dbg("write data to dvr\n");
+					break;
+				}
+			}
+
+		}
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+	return;
+}
+
+static irqreturn_t dvr_irq_handler(int irq_number, void *para)
+{
+	struct aml_asyncfifo *afifo = (struct aml_asyncfifo *)para;
+	int factor = dmx_get_order(afifo->buf_len/afifo->flush_size);
+
+	afifo->buf_toggle++;
+	afifo->buf_toggle %= (1 << factor);
+	tasklet_schedule(&afifo->asyncfifo_tasklet);
+	return  IRQ_HANDLED;
+}
+
+/*Enable the STB*/
+static void stb_enable(struct aml_dvb *dvb)
+{
+	int out_src, des_in, en_des, fec_clk, hiu ,dec_clk_en;
+	int src, tso_src, i;
+	u32 fec_s0, fec_s1;
+	u32 invert0, invert1;
+
+	switch(dvb->stb_source) {
+		case AM_TS_SRC_DMX0:
+			src = dvb->dmx[0].source;
+		break;
+		case AM_TS_SRC_DMX1:
+			src = dvb->dmx[1].source;
+		break;
+		case AM_TS_SRC_DMX2:
+			src = dvb->dmx[2].source;
+		break;
+		default:
+			src = dvb->stb_source;
+		break;
+	}
+	printk("[dmx]src is %d\n",src);
+	switch(src) {
+		case AM_TS_SRC_TS0:
+			fec_clk = tsfile_clkdiv;
+			hiu     = 0;
+		break;
+		case AM_TS_SRC_TS1:
+			fec_clk = tsfile_clkdiv;
+			hiu     = 0;
+		break;
+		case AM_TS_SRC_TS2:
+			fec_clk = tsfile_clkdiv;
+			hiu     = 0;
+		break;
+		case AM_TS_SRC_S_TS0:
+			fec_clk = tsfile_clkdiv;
+			hiu     = 0;
+		break;
+		case AM_TS_SRC_S_TS1:
+			fec_clk = tsfile_clkdiv;
+			hiu     = 0;
+		break;
+		case AM_TS_SRC_S_TS2:
+			fec_clk = tsfile_clkdiv;
+			hiu     = 0;
+		break;
+		case AM_TS_SRC_HIU:
+			fec_clk = tsfile_clkdiv;
+			hiu     = 1;
+		break;
+		default:
+			fec_clk = 0;
+			hiu     = 0;
+		break;
+	}
+
+	switch(dvb->dsc_source) {
+		case AM_DMX_0:
+			des_in = 0;
+			en_des = 1;
+			dec_clk_en=1;
+		break;
+		case AM_DMX_1:
+			des_in = 1;
+			en_des = 1;
+			dec_clk_en=1;
+		break;
+		case AM_DMX_2:
+			des_in = 2;
+			en_des = 1;
+			dec_clk_en=1;
+		break;
+		default:
+			des_in = 0;
+			en_des = 0;
+			dec_clk_en=0;
+		break;
+	}
+
+	switch(dvb->tso_source) {
+		case AM_TS_SRC_DMX0:
+			tso_src = dvb->dmx[0].source;
+		break;
+		case AM_TS_SRC_DMX1:
+			tso_src = dvb->dmx[1].source;
+		break;
+		case AM_TS_SRC_DMX2:
+			tso_src = dvb->dmx[2].source;
+		break;
+		default:
+			tso_src = dvb->tso_source;
+		break;
+	}
+
+	switch(tso_src) {
+		case AM_TS_SRC_TS0:
+			out_src = 0;
+		break;
+		case AM_TS_SRC_TS1:
+			out_src = 1;
+		break;
+		case AM_TS_SRC_TS2:
+			out_src = 2;
+		break;
+		case AM_TS_SRC_S_TS0:
+		case AM_TS_SRC_S_TS1:
+		case AM_TS_SRC_S_TS2:
+			out_src = 6;
+		break;
+		case AM_TS_SRC_HIU:
+			out_src = 7;
+		break;
+		default:
+			out_src = 0;
+		break;
+	}
+
+	fec_s0  = 0;
+	fec_s1  = 0;
+	invert0 = 0;
+	invert1 = 0;
+
+	for(i = 0; i < TS_IN_COUNT; i++){
+		if(dvb->ts[i].s2p_id == 0)
+			fec_s0 = i;
+		else if(dvb->ts[i].s2p_id == 1)
+			fec_s1 = i;
+	}
+
+	invert0 = dvb->s2p[0].invert;
+	invert1 = dvb->s2p[1].invert;
+
+	WRITE_MPEG_REG(STB_TOP_CONFIG,
+		(invert1<<INVERT_S2P1_FEC_CLK) |
+		(fec_s1<<S2P1_FEC_SERIAL_SEL)  |
+		(out_src<<TS_OUTPUT_SOURCE) |
+		(des_in<<DES_INPUT_SEL)     |
+		(en_des<<ENABLE_DES_PL)     |
+		(dec_clk_en<<ENABLE_DES_PL_CLK)|
+		(invert0<<INVERT_S2P0_FEC_CLK) |
+		(fec_s0<<S2P0_FEC_SERIAL_SEL));
+
+	if(dvb->reset_flag)
+		hiu = 0;
+
+	WRITE_MPEG_REG(TS_FILE_CONFIG,
+		(demux_skipbyte << 16)                  |
+		(6<<DES_OUT_DLY)                      |
+		(3<<TRANSPORT_SCRAMBLING_CONTROL_ODD) |
+		(hiu<<TS_HIU_ENABLE)                  |
+		(fec_clk<<FEC_FILE_CLK_DIV));
+}
+
+int dsc_set_pid(struct aml_dsc *dsc, int pid)
+{
+	u32 data;
+
+	WRITE_MPEG_REG(TS_PL_PID_INDEX, (dsc->id & 0x0f)>>1);
+	data = READ_MPEG_REG(TS_PL_PID_DATA);
+	if(dsc->id&1) {
+		data &= 0xFFFF0000;
+		data |= pid;
+	} else {
+		data &= 0xFFFF;
+		data |= (pid<<16);
+	}
+	WRITE_MPEG_REG(TS_PL_PID_INDEX, (dsc->id & 0x0f)>>1);
+	WRITE_MPEG_REG(TS_PL_PID_DATA, data);
+	WRITE_MPEG_REG(TS_PL_PID_INDEX, 0);
+	pr_dbg("set DSC %d PID %d\n", dsc->id, pid);
+	return 0;
+}
+
+int dsc_set_key(struct aml_dsc *dsc, int type, u8 *key)
+{
+	u16 k0, k1, k2, k3;
+	u32 key0, key1;
+
+	k0 = (key[0]<<8)|key[1];
+	k1 = (key[2]<<8)|key[3];
+	k2 = (key[4]<<8)|key[5];
+	k3 = (key[6]<<8)|key[7];
+
+	key0 = (k0<<16)|k1;
+	key1 = (k2<<16)|k3;
+	WRITE_MPEG_REG(COMM_DESC_KEY0, key0);
+	WRITE_MPEG_REG(COMM_DESC_KEY1, key1);
+	WRITE_MPEG_REG(COMM_DESC_KEY_RW, (dsc->id + type*DSC_COUNT));
+
+	pr_dbg("set DSC %d type %d key %04x %04x %04x %04x\n", dsc->id, type,
+			k0, k1, k2, k3);
+	return 0;
+}
+
+int dsc_release(struct aml_dsc *dsc)
+{
+	u32 data;
+
+	WRITE_MPEG_REG(TS_PL_PID_INDEX, (dsc->id & 0x0f)>>1);
+	data = READ_MPEG_REG(TS_PL_PID_DATA);
+	if(dsc->id&1) {
+		data |= 1<<PID_MATCH_DISABLE_LOW;
+	} else {
+		data |= 1<<PID_MATCH_DISABLE_HIGH;
+	}
+	WRITE_MPEG_REG(TS_PL_PID_INDEX, (dsc->id & 0x0f)>>1);
+	WRITE_MPEG_REG(TS_PL_PID_DATA, data);
+
+	pr_dbg("release DSC %d\n", dsc->id);
+	return 0;
+}
+
+/*Set section buffer*/
+static int dmx_alloc_sec_buffer(struct aml_dmx *dmx)
+{
+	unsigned long base;
+	unsigned long grp_addr[SEC_BUF_GRP_COUNT];
+	int grp_len[SEC_BUF_GRP_COUNT];
+	int i;
+
+	if(dmx->sec_pages)
+		return 0;
+
+	grp_len[0] = (1<<SEC_GRP_LEN_0)*8;
+	grp_len[1] = (1<<SEC_GRP_LEN_1)*8;
+	grp_len[2] = (1<<SEC_GRP_LEN_2)*8;
+	grp_len[3] = (1<<SEC_GRP_LEN_3)*8;
+
+	dmx->sec_total_len = grp_len[0]+grp_len[1]+grp_len[2]+grp_len[3];
+	dmx->sec_pages = __get_free_pages(GFP_KERNEL, get_order(dmx->sec_total_len));
+	if(!dmx->sec_pages) {
+		pr_error("cannot allocate section buffer %d bytes %d order\n", dmx->sec_total_len, get_order(dmx->sec_total_len));
+		return -1;
+	}
+	dmx->sec_pages_map = dma_map_single(NULL, (void*)dmx->sec_pages, dmx->sec_total_len, DMA_FROM_DEVICE);
+
+	grp_addr[0] = dmx->sec_pages_map;
+
+	grp_addr[1] = grp_addr[0]+grp_len[0];
+	grp_addr[2] = grp_addr[1]+grp_len[1];
+	grp_addr[3] = grp_addr[2]+grp_len[2];
+
+	dmx->sec_buf[0].addr = dmx->sec_pages;
+	dmx->sec_buf[0].len  = grp_len[0]/8;
+
+	for(i=1; i<SEC_BUF_COUNT; i++) {
+		dmx->sec_buf[i].addr = dmx->sec_buf[i-1].addr+dmx->sec_buf[i-1].len;
+		dmx->sec_buf[i].len  = grp_len[i/8]/8;
+	}
+
+	base = grp_addr[0]&0xFFFF0000;
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base>>16);
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START, (((grp_addr[0]-base)>>8)<<16)|((grp_addr[1]-base)>>8));
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START, (((grp_addr[2]-base)>>8)<<16)|((grp_addr[3]-base)>>8));
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE, SEC_GRP_LEN_0|
+		(SEC_GRP_LEN_1<<4)|
+		(SEC_GRP_LEN_2<<8)|
+		(SEC_GRP_LEN_3<<12));
+
+	return 0;
+}
+
+#ifdef NO_SUB
+/*Set subtitle buffer*/
+static int dmx_alloc_sub_buffer(struct aml_dmx *dmx)
+{
+	unsigned long addr;
+
+	if(dmx->sub_pages)
+		return 0;
+
+	dmx->sub_buf_len = 64*1024;
+	dmx->sub_pages = __get_free_pages(GFP_KERNEL, get_order(dmx->sub_buf_len));
+	if(!dmx->sub_pages) {
+		pr_error("cannot allocate subtitle buffer\n");
+		return -1;
+	}
+	dmx->sub_pages_map = dma_map_single(NULL, (void*)dmx->sub_pages, dmx->sub_buf_len, DMA_FROM_DEVICE);
+
+	addr = virt_to_phys((void*)dmx->sub_pages);
+	DMX_WRITE_REG(dmx->id, SB_START, addr>>12);
+	DMX_WRITE_REG(dmx->id, SB_LAST_ADDR, (dmx->sub_buf_len>>3));
+	return 0;
+}
+#endif /*NO_SUB*/
+
+/*Set PES buffer*/
+static int dmx_alloc_pes_buffer(struct aml_dmx *dmx)
+{
+	unsigned long addr;
+
+	if(dmx->pes_pages)
+		return 0;
+
+	dmx->pes_buf_len = 64*1024;
+	dmx->pes_pages = __get_free_pages(GFP_KERNEL, get_order(dmx->pes_buf_len));
+	if(!dmx->pes_pages) {
+		pr_error("cannot allocate pes buffer\n");
+		return -1;
+	}
+	dmx->pes_pages_map = dma_map_single(NULL, (void*)dmx->pes_pages, dmx->pes_buf_len, DMA_FROM_DEVICE);
+
+	addr = virt_to_phys((void*)dmx->pes_pages);
+	DMX_WRITE_REG(dmx->id, OB_START, addr>>12);
+	DMX_WRITE_REG(dmx->id, OB_LAST_ADDR, (dmx->pes_buf_len>>3));
+	return 0;
+}
+
+/*Allocate ASYNC FIFO Buffer*/
+static int asyncfifo_alloc_buffer(struct aml_asyncfifo *afifo)
+{
+	if(afifo->pages)
+		return 0;
+
+	afifo->buf_toggle = 0;
+	afifo->buf_read   = 0;
+	afifo->buf_len = 512*1024;
+	pr_error("async fifo %d buf size %d, flush size %d\n", afifo->id, afifo->buf_len, afifo->flush_size);
+	if (afifo->flush_size <= 0) {
+		afifo->flush_size = afifo->buf_len>>1;
+	}
+	afifo->pages = __get_free_pages(GFP_KERNEL, get_order(afifo->buf_len));
+	if(!afifo->pages) {
+		pr_error("cannot allocate async fifo buffer\n");
+		return -1;
+	}
+	afifo->pages_map = dma_map_single(NULL, (void*)afifo->pages, afifo->buf_len, DMA_FROM_DEVICE);
+
+	afifo->pages_map = dma_map_single(NULL, (void*)afifo->pages, afifo->buf_len, DMA_FROM_DEVICE);
+
+	return 0;
+}
+
+int async_fifo_init(struct aml_asyncfifo *afifo)
+{
+	int irq;
+
+	if (afifo->init)
+		return 0;
+	afifo->source  = AM_DMX_MAX;
+	afifo->pages = 0;
+	afifo->buf_toggle = 0;
+	afifo->buf_read = 0;
+	afifo->buf_len = 0;
+
+	if (afifo->asyncfifo_irq == -1) {
+		pr_error("no irq for ASYNC_FIFO%d\n", afifo->id);
+		/*Do not return error*/
+		return 0;
+	}
+	tasklet_init(&afifo->asyncfifo_tasklet, dvr_irq_bh_handler, (unsigned long)afifo);
+	irq = request_irq(afifo->asyncfifo_irq, dvr_irq_handler, IRQF_SHARED, "dvr irq", afifo);
+
+	/*alloc buffer*/
+	asyncfifo_alloc_buffer(afifo);
+
+	afifo->init = 1;
+
+	return 0;
+}
+
+int async_fifo_deinit(struct aml_asyncfifo *afifo)
+{
+	if (! afifo->init)
+		return 0;
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG1, 1 << ASYNC_FIFO_FLUSH_EN);
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG2, 1 << ASYNC_FIFO_FILL_EN);
+	if (afifo->pages) {
+		dma_unmap_single(NULL, afifo->pages_map, afifo->buf_len, DMA_FROM_DEVICE);
+		free_pages(afifo->pages, get_order(afifo->buf_len));
+		afifo->pages = 0;
+
+        dma_unmap_single(NULL,  afifo->pages_map, afifo->buf_len, DMA_FROM_DEVICE);
+		afifo->pages_map = 0;
+	}
+	afifo->source  = AM_DMX_MAX;
+	afifo->buf_toggle = 0;
+	afifo->buf_read = 0;
+	afifo->buf_len = 0;
+
+	if (afifo->asyncfifo_irq != -1) {
+		free_irq(afifo->asyncfifo_irq, afifo);
+		tasklet_kill(&afifo->asyncfifo_tasklet);
+	}
+
+	afifo->init = 0;
+
+	return 0;
+}
+
+/*Initalize the registers*/
+static int dmx_init(struct aml_dmx *dmx)
+{
+	struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+	int irq;
+
+	if(dmx->init) return 0;
+
+	pr_dbg("demux init\n");
+
+	/*Register irq handlers*/
+	if(dmx->dmx_irq!=-1) {
+		pr_dbg("request irq\n");
+		tasklet_init(&dmx->dmx_tasklet, dmx_irq_bh_handler, (unsigned long)dmx);
+		irq = request_irq(dmx->dmx_irq, dmx_irq_handler, IRQF_SHARED, "dmx irq", dmx);
+	}
+
+/*	if(dmx->dvr_irq!=-1) {
+		tasklet_init(&dmx->dvr_tasklet, dvr_irq_bh_handler, (unsigned long)dmx);
+		irq = request_irq(dmx->dvr_irq, dvr_irq_handler, IRQF_SHARED, "dvr irq", dmx);
+
+
+	}
+	if (dmx_alloc_asyncfifo_buffer(dmx) < 0)
+			return -1;
+*/
+	/*Allocate buffer*/
+	if(dmx_alloc_sec_buffer(dmx)<0)
+		return -1;
+#ifdef NO_SUB
+	if(dmx_alloc_sub_buffer(dmx)<0)
+		return -1;
+#endif
+	if(dmx_alloc_pes_buffer(dmx)<0)
+		return -1;
+
+	/*Reset the hardware*/
+	if (!dvb->dmx_init) {
+		init_timer(&dvb->watchdog_timer);
+		dvb->watchdog_timer.function = section_buffer_watchdog_func;
+		dvb->watchdog_timer.expires  = jiffies + msecs_to_jiffies(WATCHDOG_TIMER);
+		dvb->watchdog_timer.data     = (unsigned long)dvb;
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+		add_timer(&dvb->watchdog_timer);
+#endif
+		dmx_reset_hw(dvb);
+	}
+
+	dvb->dmx_init++;
+
+	memset(dmx->sec_buf_watchdog_count, 0, sizeof(dmx->sec_buf_watchdog_count));
+
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	memset(g_ts_config, 0, sizeof(struct aml_dmx_ts_config) * TS_SRC_MAX);
+#endif
+
+	dmx->init = 1;
+
+	return 0;
+}
+
+/*Release the resource*/
+static int dmx_deinit(struct aml_dmx *dmx)
+{
+	struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+
+	if(!dmx->init) return 0;
+
+	DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0);
+
+	dvb->dmx_init--;
+
+	/*Reset the hardware*/
+	if(!dvb->dmx_init) {
+		dmx_reset_hw(dvb);
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+		del_timer_sync(&dvb->watchdog_timer);
+#endif
+	}
+
+	if(dmx->sec_pages) {
+        dma_unmap_single(NULL,  dmx->sec_pages_map, dmx->sec_total_len, DMA_FROM_DEVICE);
+		free_pages(dmx->sec_pages, get_order(dmx->sec_total_len));
+		dmx->sec_pages = 0;
+        dmx->sec_pages_map = 0;
+	}
+#ifdef NO_SUB
+	if(dmx->sub_pages) {
+		dma_unmap_single(NULL,  dmx->sub_pages_map, dmx->sub_buf_len, DMA_FROM_DEVICE);
+		free_pages(dmx->sub_pages, get_order(dmx->sub_buf_len));
+		dmx->sub_pages = 0;
+	}
+#endif
+	if(dmx->pes_pages) {
+		dma_unmap_single(NULL,  dmx->pes_pages_map, dmx->pes_buf_len, DMA_FROM_DEVICE);
+		free_pages(dmx->pes_pages, get_order(dmx->pes_buf_len));
+		dmx->pes_pages = 0;
+	}
+
+	if(dmx->dmx_irq!=-1) {
+		free_irq(dmx->dmx_irq, dmx);
+		tasklet_kill(&dmx->dmx_tasklet);
+	}
+/*	if(dmx->dvr_irq!=-1) {
+		free_irq(dmx->dvr_irq, dmx);
+		tasklet_kill(&dmx->dvr_tasklet);
+	}
+*/
+	dmx->init = 0;
+
+	return 0;
+}
+
+/*Check the record flag*/
+static int dmx_get_record_flag(struct aml_dmx *dmx)
+{
+	int i, linked = 0, record_flag = 0;
+	struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+
+	/*Check whether a async fifo connected to this dmx*/
+	for (i=0; i<ASYNCFIFO_COUNT; i++) {
+		if (! dvb->asyncfifo[i].init)
+			continue;
+		if (dvb->asyncfifo[i].source == dmx->id) {
+			linked = 1;
+			break;
+		}
+	}
+
+
+	for(i=0; i<CHANNEL_COUNT; i++) {
+		if(dmx->channel[i].used && dmx->channel[i].dvr_feed) {
+			if (! dmx->record) {
+				dmx->record = 1;
+
+				if (linked) {
+					/*A new record will start, must reset the async fifos for linking the right demux*/
+					reset_async_fifos(dvb);
+				}
+			}
+			if (linked) {
+				record_flag = 1;
+			}
+			goto find_done;
+		}
+	}
+
+	if (dmx->record) {
+		dmx->record = 0;
+		if (linked) {
+			/*A record will stop, reset the async fifos for linking the right demux*/
+			reset_async_fifos(dvb);
+		}
+	}
+
+
+find_done:
+	return record_flag;
+}
+
+
+/*Enable the demux device*/
+static int dmx_enable(struct aml_dmx *dmx)
+{
+	struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+	int fec_sel, hi_bsf, fec_ctrl, record;
+	int fec_core_sel;
+	int set_stb = 0, fec_s = 0;
+	int s2p_id;
+	u32 invert0 = 0, invert1 = 0, fec_s0 = 0, fec_s1 = 0;
+
+	record = dmx_get_record_flag(dmx);
+
+	switch(dmx->source) {
+		case AM_TS_SRC_TS0:
+			fec_sel  = 0;
+			fec_ctrl = dvb->ts[0].control;
+			record   = record?1:0;
+			break;
+		case AM_TS_SRC_TS1:
+			fec_sel  = 1;
+			fec_ctrl = dvb->ts[1].control;
+			record   = record?1:0;
+		break;
+		case AM_TS_SRC_TS2:
+			fec_sel  = 2;
+			fec_ctrl = dvb->ts[2].control;
+			record   = record?1:0;
+		break;
+		case AM_TS_SRC_S_TS0:
+		case AM_TS_SRC_S_TS1:
+		case AM_TS_SRC_S_TS2:
+			s2p_id   = 0;
+			fec_ctrl = 0;
+			if(dmx->source == AM_TS_SRC_S_TS0){
+				s2p_id   = dvb->ts[0].s2p_id;
+				fec_ctrl = dvb->ts[0].control;
+			}else if(dmx->source == AM_TS_SRC_S_TS1){
+				s2p_id   = dvb->ts[1].s2p_id;
+				fec_ctrl = dvb->ts[1].control;
+			}else if(dmx->source == AM_TS_SRC_S_TS2){
+				s2p_id   = dvb->ts[2].s2p_id;
+				fec_ctrl = dvb->ts[2].control;
+			}
+			fec_sel = (s2p_id == 1) ? 5 : 6;
+			record  = record?1:0;
+			set_stb = 1;
+			fec_s   = dmx->source - AM_TS_SRC_S_TS0;
+		break;
+		case AM_TS_SRC_HIU:
+			fec_sel  = 7;
+			fec_ctrl = 0;
+			record   = 0;
+		break;
+		default:
+			fec_sel  = 0;
+			fec_ctrl = 0;
+			record   = 0;
+		break;
+	}
+	pr_dbg("dmx %d enable: src %d, record %d\n", dmx->id, dmx->source, record);
+
+	if(dmx->channel[0].used || dmx->channel[1].used)
+		hi_bsf = 1;
+	else
+		hi_bsf = 0;
+	if (dvb->dsc_source == dmx->id)
+		fec_core_sel = 1;
+	else
+		fec_core_sel = 0;
+	if(dmx->chan_count) {
+		if(set_stb){
+			u32 v = READ_MPEG_REG(STB_TOP_CONFIG);
+			int i;
+
+			for(i = 0; i < TS_IN_COUNT; i++){
+				if (dvb->ts[i].s2p_id == 0){
+					fec_s0 = i;
+				}else if(dvb->ts[i].s2p_id == 1){
+					fec_s1 = i;
+				}
+			}
+
+			invert0 = dvb->s2p[0].invert;
+			invert1 = dvb->s2p[1].invert;
+
+			v |= (fec_s0<<S2P0_FEC_SERIAL_SEL)|
+				(invert0<<INVERT_S2P0_FEC_CLK)|
+				(fec_s1<<S2P1_FEC_SERIAL_SEL) |
+				(invert1<<INVERT_S2P1_FEC_CLK);
+			WRITE_MPEG_REG(STB_TOP_CONFIG, v);
+		}
+
+		/*Initialize the registers*/
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+		DMX_WRITE_REG(dmx->id, DEMUX_MEM_REQ_EN,
+#ifdef USE_AHB_MODE
+			(1<<SECTION_AHB_DMA_EN)         |
+			(0<<SUB_AHB_DMA_EN)       |
+			(1<<OTHER_PES_AHB_DMA_EN)       |
+#endif
+			(1<<SECTION_PACKET)             |
+			(1<<VIDEO_PACKET)               |
+			(1<<AUDIO_PACKET)               |
+			(1<<SUB_PACKET)                 |
+			(1<<OTHER_PES_PACKET));
+	 	DMX_WRITE_REG(dmx->id, PES_STRONG_SYNC, 0x1234);
+ 		DMX_WRITE_REG(dmx->id, DEMUX_ENDIAN,
+			(7<<OTHER_ENDIAN)               |
+			(7<<BYPASS_ENDIAN)              |
+			(0<<SECTION_ENDIAN));
+		DMX_WRITE_REG(dmx->id, TS_HIU_CTL,
+			(0<<LAST_BURST_THRESHOLD)       |
+			(hi_bsf<<USE_HI_BSF_INTERFACE));
+
+
+		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
+			(fec_core_sel<<FEC_CORE_SEL)    |
+			(fec_sel<<FEC_SEL)              |
+			(fec_ctrl<<0));
+		DMX_WRITE_REG(dmx->id, STB_OM_CTL,
+			(0x40<<MAX_OM_DMA_COUNT)        |
+			(0x7f<<LAST_OM_ADDR));
+		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL,
+			(0<<BYPASS_USE_RECODER_PATH)          |
+			(0<<INSERT_AUDIO_PES_STRONG_SYNC)     |
+			(0<<INSERT_VIDEO_PES_STRONG_SYNC)     |
+			(0<<OTHER_INT_AT_PES_BEGINING)        |
+			(0<<DISCARD_AV_PACKAGE)               |
+			((!!dmx->dump_ts_select)<<TS_RECORDER_SELECT)               |
+			(record<<TS_RECORDER_ENABLE)          |
+			(1<<KEEP_DUPLICATE_PACKAGE)           |
+			//(1<<SECTION_END_WITH_TABLE_ID)        |
+			(1<<ENABLE_FREE_CLK_FEC_DATA_VALID)   |
+			(1<<ENABLE_FREE_CLK_STB_REG)          |
+			(1<<STB_DEMUX_ENABLE));
+	} else {
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL, 0);
+		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0);
+	}
+
+
+	return 0;
+}
+
+/*Get the channel's ID by its PID*/
+static int dmx_get_chan(struct aml_dmx *dmx, int pid)
+{
+	int id;
+
+	for(id=0; id<CHANNEL_COUNT; id++) {
+		if(dmx->channel[id].used && dmx->channel[id].pid==pid)
+			return id;
+	}
+
+	return -1;
+}
+
+/*Get the channel's target*/
+static u32 dmx_get_chan_target(struct aml_dmx *dmx, int cid)
+{
+	u32 type;
+
+	if(!dmx->channel[cid].used) {
+		return 0xFFFF;
+	}
+
+	if(dmx->channel[cid].type==DMX_TYPE_SEC) {
+		type = SECTION_PACKET;
+	} else {
+		switch(dmx->channel[cid].pes_type) {
+			case DMX_PES_AUDIO:
+				type = AUDIO_PACKET;
+			break;
+			case DMX_PES_VIDEO:
+				type = VIDEO_PACKET;
+			break;
+			case DMX_PES_SUBTITLE:
+			case DMX_PES_TELETEXT:
+				type = SUB_PACKET;
+			break;
+			default:
+				type = OTHER_PES_PACKET;
+			break;
+		}
+	}
+
+	pr_dbg("chan target: %x %x\n", type, dmx->channel[cid].pid);
+	return (type<<PID_TYPE)|dmx->channel[cid].pid;
+}
+
+/*Get the advance value of the channel*/
+static inline u32 dmx_get_chan_advance(struct aml_dmx *dmx, int cid)
+{
+	return 0;
+}
+
+/*Set the channel registers*/
+static int dmx_set_chan_regs(struct aml_dmx *dmx, int cid)
+{
+	u32 data, addr, advance, max;
+
+	pr_dbg("set channel (id:%d PID:0x%x) registers\n", cid, dmx->channel[cid].pid);
+
+	while(DMX_READ_REG(dmx->id, FM_WR_ADDR) & 0x8000) {
+		udelay(1);
+	}
+
+	if(cid&1) {
+		data = (dmx_get_chan_target(dmx, cid-1)<<16) | dmx_get_chan_target(dmx, cid);
+		advance = (dmx_get_chan_advance(dmx, cid)<<8) | dmx_get_chan_advance(dmx, cid-1);
+	} else {
+		data = (dmx_get_chan_target(dmx, cid)<<16) | dmx_get_chan_target(dmx, cid+1);
+		advance = (dmx_get_chan_advance(dmx, cid+1)<<8) | dmx_get_chan_advance(dmx, cid);
+	}
+	addr = cid>>1;
+	DMX_WRITE_REG(dmx->id, FM_WR_DATA, data);
+	DMX_WRITE_REG(dmx->id, FM_WR_ADDR, (advance<<16)|0x8000|addr);
+
+	pr_dbg("write fm %x:%x\n", (advance<<16)|0x8000|addr, data);
+
+	for(max=CHANNEL_COUNT-1; max>0; max--) {
+		if(dmx->channel[max].used)
+			break;
+	}
+
+	data = DMX_READ_REG(dmx->id, MAX_FM_COMP_ADDR)&0xF0;
+	DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, data|(max>>1));
+
+	pr_dbg("write fm comp %x\n", data|(max>>1));
+
+	if(DMX_READ_REG(dmx->id, OM_CMD_STATUS)&0x8e00) {
+		pr_error("error send cmd %x\n", DMX_READ_REG(dmx->id, OM_CMD_STATUS));
+	}
+
+	if(cid == 0)
+		first_video_pts = 0;
+	else if(cid == 1)
+		first_audio_pts = 0;
+
+	return 0;
+}
+
+/*Get the filter target*/
+static int dmx_get_filter_target(struct aml_dmx *dmx, int fid, u32 *target, u8 *advance)
+{
+	struct dmx_section_filter *filter;
+	struct aml_filter *f;
+	int i, cid, neq_bytes;
+
+	fid = fid&0xFFFF;
+	f = &dmx->filter[fid];
+
+	if(!f->used) {
+		target[0] = 0x1fff;
+		advance[0] = 0;
+		for(i=1; i<FILTER_LEN; i++) {
+			target[i] = 0x9fff;
+			advance[i] = 0;
+		}
+		return 0;
+	}
+
+	cid = f->chan_id;
+	filter = f->filter;
+
+	neq_bytes = 0;
+	if(filter->filter_mode[0]!=0xFF) {
+		neq_bytes = 2;
+	} else {
+		for(i=3; i<FILTER_LEN; i++) {
+			if(filter->filter_mode[i]!=0xFF)
+				neq_bytes++;
+		}
+	}
+
+	f->neq = 0;
+
+	for(i=0; i<FILTER_LEN; i++) {
+		u8 value = filter->filter_value[i];
+		u8 mask  = filter->filter_mask[i];
+		u8 mode  = filter->filter_mode[i];
+		u8 mb, mb1, nb, v, t, adv = 0;
+
+		if(!i) {
+			mb = 1;
+			mb1= 1;
+			v  = 0;
+			if(mode==0xFF) {
+				t = mask&0xF0;
+				mb1 = 0;
+				adv |= t^0xF0;
+				v   |= (value&0xF0)|adv;
+
+				t = mask&0x0F;
+				mb  = 0;
+				adv |= t^0x0F;
+				v   |= (value&0x0F)|adv;
+			}
+
+			target[i] = (mb<<SECTION_FIRSTBYTE_MASKLOW)         |
+				(mb1<<SECTION_FIRSTBYTE_MASKHIGH)           |
+				(0<<SECTION_FIRSTBYTE_DISABLE_PID_CHECK)    |
+				(cid<<SECTION_FIRSTBYTE_PID_INDEX)          |
+				v;
+			advance[i] = adv;
+		} else {
+			if(i < 3){
+				value = 0;
+				mask  = 0;
+				mode  = 0xff;
+			}
+			mb = 1;
+			nb = 0;
+			v = 0;
+
+			if((i>=3) && mask) {
+			if(mode==0xFF) {
+				mb  = 0;
+				nb  = 0;
+				adv = mask^0xFF;
+				v   = value|adv;
+			} else {
+				if(neq_bytes==1) {
+					mb  = 0;
+					nb  = 1;
+					adv = mask^0xFF;
+					v   = value&~adv;
+				}
+			}
+			}
+			target[i] = (mb<<SECTION_RESTBYTE_MASK)             |
+				(nb<<SECTION_RESTBYTE_MASK_EQ)              |
+				(0<<SECTION_RESTBYTE_DISABLE_PID_CHECK)     |
+				(cid<<SECTION_RESTBYTE_PID_INDEX)           |
+				v;
+			advance[i] = adv;
+		}
+
+		f->value[i] = value;
+		f->maskandmode[i] = mask&mode;
+		f->maskandnotmode[i] = mask&~mode;
+
+		if(f->maskandnotmode[i])
+			f->neq = 1;
+	}
+
+	return 0;
+}
+
+/*Set the filter registers*/
+static int dmx_set_filter_regs(struct aml_dmx *dmx, int fid)
+{
+	u32 t1[FILTER_LEN], t2[FILTER_LEN];
+	u8 advance1[FILTER_LEN], advance2[FILTER_LEN];
+	u32 addr, data, max, adv;
+	int i;
+
+	pr_dbg("set filter (id:%d) registers\n", fid);
+
+	if(fid&1) {
+		dmx_get_filter_target(dmx, fid-1, t1, advance1);
+		dmx_get_filter_target(dmx, fid, t2, advance2);
+	} else {
+		dmx_get_filter_target(dmx, fid, t1, advance1);
+		dmx_get_filter_target(dmx, fid+1, t2, advance2);
+	}
+
+	for(i=0; i<FILTER_LEN; i++) {
+		while(DMX_READ_REG(dmx->id, FM_WR_ADDR) & 0x8000) {
+			udelay(1);
+		}
+
+		data = (t1[i]<<16)|t2[i];
+		addr = (fid>>1)|((i+1)<<4);
+		adv  = (advance1[i]<<8)|advance2[i];
+
+		DMX_WRITE_REG(dmx->id, FM_WR_DATA, data);
+		DMX_WRITE_REG(dmx->id, FM_WR_ADDR, (adv<<16)|0x8000|addr);
+
+		pr_dbg("write fm %x:%x\n", (adv<<16)|0x8000|addr, data);
+	}
+
+	for(max=FILTER_COUNT-1; max>0; max--) {
+		if(dmx->filter[max].used)
+			break;
+	}
+
+	data = DMX_READ_REG(dmx->id, MAX_FM_COMP_ADDR)&0xF;
+	DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, data|((max>>1)<<4));
+
+	pr_dbg("write fm comp %x\n", data|((max>>1)<<4));
+
+	if(DMX_READ_REG(dmx->id, OM_CMD_STATUS)&0x8e00) {
+		pr_error("error send cmd %x\n",DMX_READ_REG(dmx->id, OM_CMD_STATUS));
+	}
+
+	return 0;
+}
+
+/*Clear the filter's buffer*/
+static void dmx_clear_filter_buffer(struct aml_dmx *dmx, int fid)
+{
+	u32 section_busy32 = DMX_READ_REG(dmx->id, SEC_BUFF_READY);
+	u32 filter_number;
+	int i;
+
+	if(!section_busy32)
+		return;
+
+	for(i = 0; i < SEC_BUF_COUNT; i++) {
+		if(section_busy32 & (1 << i)) {
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_NUMBER, i);
+			filter_number = (DMX_READ_REG(dmx->id, SEC_BUFF_NUMBER) >> 8);
+			if(filter_number != fid) {
+				section_busy32 &= ~(1 << i);
+			}
+		}
+	}
+
+	if(section_busy32) {
+		DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, section_busy32);
+	}
+}
+
+static void async_fifo_set_regs(struct aml_asyncfifo *afifo, int source_val)
+{
+	u32 start_addr = virt_to_phys((void*)afifo->pages);
+	u32 size = afifo->buf_len;
+	u32 flush_size = afifo->flush_size;
+	int factor = dmx_get_order(size/flush_size);
+
+	pr_dbg("ASYNC FIFO id=%d, link to DMX%d, start_addr %x, buf_size %d, source value 0x%x, factor %d\n",
+			afifo->id, afifo->source, start_addr, size, source_val, factor);
+	/* Destination address*/
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG0, start_addr);
+
+	/* Setup flush parameters*/
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+						(0 << ASYNC_FIFO_TO_HIU)   |
+						(0 << ASYNC_FIFO_FLUSH)    |   // don't flush the path
+						(1 << ASYNC_FIFO_RESET)    |   // reset the path
+						(1 << ASYNC_FIFO_WRAP_EN)  |   // wrap enable
+						(0 << ASYNC_FIFO_FLUSH_EN) |   // disable the flush path
+						//(0x3 << ASYNC_FIFO_FLUSH_CNT_LSB);     // flush 3 x 32  32-bit words
+						//(0x7fff << ASYNC_FIFO_FLUSH_CNT_LSB);     // flush 4MBytes of data
+						(((size >> 7) & 0x7fff) << ASYNC_FIFO_FLUSH_CNT_LSB));     // number of 128-byte blocks to flush
+
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1, READ_ASYNC_FIFO_REG(afifo->id, REG1) & ~(1 << ASYNC_FIFO_RESET));     // clear the reset signal
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1, READ_ASYNC_FIFO_REG(afifo->id, REG1) | (1 << ASYNC_FIFO_FLUSH_EN));   // Enable flush
+
+	/*Setup Fill parameters*/
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+					(1 <<  ASYNC_FIFO_ENDIAN_LSB)  |
+					(0 <<  ASYNC_FIFO_FILL_EN)     |   // disable fill path to reset fill path
+					//(96 << ASYNC_FIFO_FILL_CNT_LSB);   // 3 x 32  32-bit words
+					(0 << ASYNC_FIFO_FILL_CNT_LSB));   // forever FILL;
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2, READ_ASYNC_FIFO_REG(afifo->id, REG2) | (1 <<  ASYNC_FIFO_FILL_EN));       // Enable fill path
+
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG3, (READ_ASYNC_FIFO_REG(afifo->id, REG3)&0xffff0000) | ((((size >> (factor + 7)) - 1) & 0x7fff) << ASYNC_FLUSH_SIZE_IRQ_LSB)); // generate flush interrupt
+
+	/* Connect the STB DEMUX to ASYNC_FIFO*/
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2, READ_ASYNC_FIFO_REG(afifo->id, REG2) | (source_val << ASYNC_FIFO_SOURCE_LSB));
+}
+
+/*Reset the ASYNC FIFOS when a ASYNC FIFO connect to a different DMX*/
+static void reset_async_fifos(struct aml_dvb *dvb)
+{
+	struct aml_asyncfifo *low_dmx_fifo = NULL;
+	struct aml_asyncfifo *high_dmx_fifo = NULL;
+	int i, j;
+	int record_enable;
+
+	pr_dbg("reset ASYNC FIFOs\n");
+	for (i=0; i<ASYNCFIFO_COUNT; i++) {
+		if (! dvb->asyncfifo[i].init)
+			continue;
+		pr_dbg("Disable ASYNC FIFO id=%d\n", dvb->asyncfifo[i].id);
+		CLEAR_ASYNC_FIFO_REG_MASK(dvb->asyncfifo[i].id, REG1, 1 << ASYNC_FIFO_FLUSH_EN);
+		CLEAR_ASYNC_FIFO_REG_MASK(dvb->asyncfifo[i].id, REG2, 1 << ASYNC_FIFO_FILL_EN);
+		if (READ_ASYNC_FIFO_REG(dvb->asyncfifo[i].id,REG2)&(1 << ASYNC_FIFO_FILL_EN) ||
+			READ_ASYNC_FIFO_REG(dvb->asyncfifo[i].id,REG1)&(1 << ASYNC_FIFO_FLUSH_EN)) {
+			pr_dbg("Set reg failed\n");
+		} else {
+			pr_dbg("Set reg ok\n");
+		}
+		dvb->asyncfifo[i].buf_toggle = 0;
+		dvb->asyncfifo[i].buf_read = 0;
+	}
+
+	for (j=0; j<DMX_DEV_COUNT; j++) {
+		if (! dvb->dmx[j].init)
+			continue;
+		record_enable = 0;
+		for (i=0; i<ASYNCFIFO_COUNT; i++) {
+			if (! dvb->asyncfifo[i].init)
+				continue;
+
+			if (dvb->dmx[j].record && dvb->dmx[j].id == dvb->asyncfifo[i].source) {
+				/*This dmx is linked to the async fifo, Enable the TS_RECORDER_ENABLE*/
+				record_enable = 1;
+				if (! low_dmx_fifo) {
+					low_dmx_fifo = &dvb->asyncfifo[i];
+				} else if (low_dmx_fifo->source > dvb->asyncfifo[i].source) {
+					high_dmx_fifo = low_dmx_fifo;
+					low_dmx_fifo = &dvb->asyncfifo[i];
+				} else if (low_dmx_fifo->source < dvb->asyncfifo[i].source) {
+					high_dmx_fifo = &dvb->asyncfifo[i];
+				}
+
+				break;
+			}
+		}
+		pr_dbg("Set DMX%d TS_RECORDER_ENABLE to %d\n", dvb->dmx[j].id, record_enable ? 1 : 0);
+		if (record_enable) {
+			//DMX_SET_REG_MASK(dvb->dmx[j].id, DEMUX_CONTROL, 1<<TS_RECORDER_ENABLE);
+			DMX_WRITE_REG(dvb->dmx[j].id, DEMUX_CONTROL, DMX_READ_REG(dvb->dmx[j].id, DEMUX_CONTROL)|(1<<TS_RECORDER_ENABLE));
+		} else {
+			//DMX_CLEAR_REG_MASK(dvb->dmx[j].id, DEMUX_CONTROL, 1<<TS_RECORDER_ENABLE);
+			DMX_WRITE_REG(dvb->dmx[j].id, DEMUX_CONTROL, DMX_READ_REG(dvb->dmx[j].id, DEMUX_CONTROL)&(~(1<<TS_RECORDER_ENABLE)));
+		}
+	}
+
+	/*Set the async fifo regs*/
+	if (low_dmx_fifo) {
+		async_fifo_set_regs(low_dmx_fifo, 0x3);
+
+		if (high_dmx_fifo) {
+			async_fifo_set_regs(high_dmx_fifo, 0x2);
+		}
+	}
+}
+
+/*Reset the demux device*/
+void dmx_reset_hw(struct aml_dvb *dvb)
+{
+	dmx_reset_hw_ex(dvb, 1);
+}
+
+/*Reset the demux device*/
+void dmx_reset_hw_ex(struct aml_dvb *dvb, int reset_irq)
+{
+	int id, times;
+
+	pr_dbg("demux reset begin\n");
+
+	for (id=0; id<DMX_DEV_COUNT; id++) {
+		if(!dvb->dmx[id].init)
+			continue;
+		if(reset_irq){
+			if(dvb->dmx[id].dmx_irq!=-1) {
+				disable_irq(dvb->dmx[id].dmx_irq);
+			}
+			if(dvb->dmx[id].dvr_irq!=-1) {
+				disable_irq(dvb->dmx[id].dvr_irq);
+			}
+		}
+	}
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if(reset_irq){
+		del_timer_sync(&dvb->watchdog_timer);
+	}
+#endif
+
+	WRITE_MPEG_REG(RESET1_REGISTER, RESET_DEMUXSTB);
+
+	for (id=0; id<DMX_DEV_COUNT; id++) {
+		times = 0;
+		while(times++ < 1000000) {
+			if (!(DMX_READ_REG(id, OM_CMD_STATUS)&0x01))
+				break;
+		}
+	}
+
+	WRITE_MPEG_REG(STB_TOP_CONFIG, 0);
+
+	for (id=0; id<DMX_DEV_COUNT; id++) {
+		u32 version, data;
+
+		if(!dvb->dmx[id].init)
+			continue;
+
+		if(reset_irq){
+			if(dvb->dmx[id].dmx_irq!=-1) {
+				enable_irq(dvb->dmx[id].dmx_irq);
+			}
+			if(dvb->dmx[id].dvr_irq!=-1) {
+				enable_irq(dvb->dmx[id].dvr_irq);
+			}
+		}
+		DMX_WRITE_REG(id, DEMUX_CONTROL, 0x0000);
+		version = DMX_READ_REG(id, STB_VERSION);
+		DMX_WRITE_REG(id, STB_TEST_REG, version);
+		pr_dbg("STB %d hardware version : %d\n", id, version);
+		DMX_WRITE_REG(id, STB_TEST_REG, 0x5550);
+		data = DMX_READ_REG(id, STB_TEST_REG);
+		if(data!=0x5550)
+			pr_error("STB %d register access failed\n", id);
+		DMX_WRITE_REG(id, STB_TEST_REG, 0xaaa0);
+		data = DMX_READ_REG(id, STB_TEST_REG);
+		if(data!=0xaaa0)
+			pr_error("STB %d register access failed\n", id);
+		DMX_WRITE_REG(id, MAX_FM_COMP_ADDR, 0x0000);
+		DMX_WRITE_REG(id, STB_INT_MASK, 0);
+		DMX_WRITE_REG(id, STB_INT_STATUS, 0xffff);
+		DMX_WRITE_REG(id, FEC_INPUT_CONTROL, 0);
+	}
+
+	stb_enable(dvb);
+
+	for(id=0; id<DMX_DEV_COUNT; id++)
+	{
+		struct aml_dmx *dmx = &dvb->dmx[id];
+		int n;
+		unsigned long addr;
+		unsigned long base;
+		unsigned long grp_addr[SEC_BUF_GRP_COUNT];
+		int grp_len[SEC_BUF_GRP_COUNT];
+		if(!dvb->dmx[id].init)
+			continue;
+
+
+		if(dmx->sec_pages) {
+			grp_len[0] = (1<<SEC_GRP_LEN_0)*8;
+			grp_len[1] = (1<<SEC_GRP_LEN_1)*8;
+			grp_len[2] = (1<<SEC_GRP_LEN_2)*8;
+			grp_len[3] = (1<<SEC_GRP_LEN_3)*8;
+
+
+			grp_addr[0] = virt_to_phys((void*)dmx->sec_pages);
+			grp_addr[1] = grp_addr[0]+grp_len[0];
+			grp_addr[2] = grp_addr[1]+grp_len[1];
+			grp_addr[3] = grp_addr[2]+grp_len[2];
+
+			base = grp_addr[0]&0xFFFF0000;
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base>>16);
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START, (((grp_addr[0]-base)>>8)<<16)|((grp_addr[1]-base)>>8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START, (((grp_addr[2]-base)>>8)<<16)|((grp_addr[3]-base)>>8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE, SEC_GRP_LEN_0|
+				(SEC_GRP_LEN_1<<4)|
+				(SEC_GRP_LEN_2<<8)|
+				(SEC_GRP_LEN_3<<12));
+		}
+
+		if(dmx->sub_pages) {
+			addr = virt_to_phys((void*)dmx->sub_pages);
+			DMX_WRITE_REG(dmx->id, SB_START, addr>>12);
+			DMX_WRITE_REG(dmx->id, SB_LAST_ADDR, (dmx->sub_buf_len>>3));
+		}
+
+		if(dmx->pes_pages) {
+			addr = virt_to_phys((void*)dmx->pes_pages);
+			DMX_WRITE_REG(dmx->id, OB_START, addr>>12);
+			DMX_WRITE_REG(dmx->id, OB_LAST_ADDR, (dmx->pes_buf_len>>3));
+		}
+
+		for(n=0; n<CHANNEL_COUNT; n++)
+		{
+			struct aml_channel *chan = &dmx->channel[n];
+
+			if(chan->used)
+			{
+				dmx_set_chan_regs(dmx, n);
+			}
+		}
+
+		for(n=0; n<FILTER_COUNT; n++)
+		{
+			struct aml_filter *filter = &dmx->filter[n];
+
+			if(filter->used)
+			{
+				dmx_set_filter_regs(dmx, n);
+			}
+		}
+
+		dmx_enable(&dvb->dmx[id]);
+	}
+
+	for(id=0; id<DSC_COUNT; id++)
+	{
+		struct aml_dsc *dsc = &dvb->dsc[id];
+
+		if(dsc->used)
+		{
+			dsc_set_pid(dsc, dsc->pid);
+
+			if(dsc->set&1)
+				dsc_set_key(dsc, 0, dsc->even);
+			if(dsc->set&2)
+				dsc_set_key(dsc, 1, dsc->odd);
+		}
+	}
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if(reset_irq){
+		mod_timer(&dvb->watchdog_timer, jiffies+msecs_to_jiffies(WATCHDOG_TIMER));
+	}
+#endif
+
+	pr_dbg("demux reset end\n");
+}
+
+/*Allocate subtitle pes buffer*/
+static int alloc_subtitle_pes_buffer(struct aml_dmx * dmx)
+{
+	int start_ptr=0;
+	stream_buf_t *sbuff=0;
+	 u32 phy_addr;
+	start_ptr=READ_MPEG_REG(PARSER_SUB_START_PTR);
+	if(start_ptr)
+	{
+		WRITE_MPEG_REG(PARSER_SUB_RP, start_ptr);
+		goto exit;
+	}
+	//rsj//sbuff=get_stream_buffer(BUF_TYPE_SUBTITLE);
+	if(sbuff)
+	{
+		 phy_addr = sbuff->buf_start;
+
+        	WRITE_MPEG_REG(PARSER_SUB_RP, phy_addr);
+        	WRITE_MPEG_REG(PARSER_SUB_START_PTR, phy_addr);
+        	WRITE_MPEG_REG(PARSER_SUB_END_PTR, phy_addr + sbuff->buf_size - 8);
+
+		pr_dbg("pes buff=:%x %x\n",phy_addr,sbuff->buf_size);
+	}
+	else
+	{
+		pr_dbg("Error stream buffer\n");
+	}
+exit:
+	return 0;
+}
+
+
+/*Allocate a new channel*/
+int dmx_alloc_chan(struct aml_dmx *dmx, int type, int pes_type, int pid)
+{
+	int id = -1;
+	int ret;
+
+	if(type==DMX_TYPE_TS) {
+		switch(pes_type) {
+			case DMX_PES_VIDEO:
+				if(!dmx->channel[0].used)
+					id = 0;
+			break;
+			case DMX_PES_AUDIO:
+				if(!dmx->channel[1].used)
+					id = 1;
+			break;
+			case DMX_PES_SUBTITLE:
+			case DMX_PES_TELETEXT:
+				if(!dmx->channel[2].used)
+					id = 2;
+				alloc_subtitle_pes_buffer(dmx);
+			break;
+			case DMX_PES_PCR:
+				if(!dmx->channel[3].used)
+					id = 3;
+			break;
+			case DMX_PES_OTHER:
+			{
+				int i;
+				for(i=SYS_CHAN_COUNT; i<CHANNEL_COUNT; i++) {
+					if(!dmx->channel[i].used) {
+						id = i;
+						break;
+					}
+				}
+			}
+			break;
+			default:
+			break;
+		}
+	} else {
+		int i;
+		for(i=SYS_CHAN_COUNT; i<CHANNEL_COUNT; i++) {
+			if(!dmx->channel[i].used) {
+				id = i;
+				break;
+			}
+		}
+	}
+
+	if(id==-1) {
+		pr_error("too many channels\n");
+		return -1;
+	}
+
+	pr_dbg("allocate channel(id:%d PID:0x%x)\n", id, pid);
+
+	if(id <= 3) {
+		if ((ret=dmx_get_chan(dmx, pid))>=0 && DVR_FEED(dmx->channel[ret].feed)) {
+			dmx_remove_feed(dmx, dmx->channel[ret].feed);
+			dmx->channel[id].dvr_feed = dmx->channel[ret].feed;
+			dmx->channel[id].dvr_feed->priv = (void*)id;
+		} else {
+			dmx->channel[id].dvr_feed = NULL;
+		}
+	}
+
+	dmx->channel[id].type = type;
+	dmx->channel[id].pes_type = pes_type;
+	dmx->channel[id].pid  = pid;
+	dmx->channel[id].used = 1;
+	dmx->channel[id].filter_count = 0;
+
+	dmx_set_chan_regs(dmx, id);
+
+	dmx->chan_count++;
+
+	dmx_enable(dmx);
+
+	return id;
+}
+
+/*Free a channel*/
+void dmx_free_chan(struct aml_dmx *dmx, int cid)
+{
+	pr_dbg("free channel(id:%d PID:0x%x)\n", cid, dmx->channel[cid].pid);
+
+	dmx->channel[cid].used = 0;
+	dmx_set_chan_regs(dmx, cid);
+
+	if(cid==2){
+		u32 parser_sub_start_ptr;
+
+		parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
+		WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_start_ptr);
+		WRITE_MPEG_REG(PARSER_SUB_WP, parser_sub_start_ptr);
+	}
+
+	dmx->chan_count--;
+
+	dmx_enable(dmx);
+
+	/*Special pes type channel, check its dvr feed*/
+	if (cid <= 3 && dmx->channel[cid].dvr_feed) {
+		/*start the dvr feed*/
+		dmx_add_feed(dmx, dmx->channel[cid].dvr_feed);
+	}
+}
+
+/*Add a section*/
+static int dmx_chan_add_filter(struct aml_dmx *dmx, int cid, struct dvb_demux_filter *filter)
+{
+	int id = -1;
+	int i;
+
+	for(i=0; i<FILTER_COUNT; i++) {
+		if(!dmx->filter[i].used) {
+			id = i;
+			break;
+		}
+	}
+
+	if(id==-1) {
+		pr_error("too many filters\n");
+		return -1;
+	}
+
+	pr_dbg("channel(id:%d PID:0x%x) add filter(id:%d)\n", cid, filter->feed->pid, id);
+
+	dmx->filter[id].chan_id = cid;
+	dmx->filter[id].used = 1;
+	dmx->filter[id].filter = (struct dmx_section_filter*)filter;
+	dmx->channel[cid].filter_count++;
+
+	dmx_set_filter_regs(dmx, id);
+
+	return id;
+}
+
+static void dmx_remove_filter(struct aml_dmx *dmx, int cid, int fid)
+{
+	pr_dbg("channel(id:%d PID:0x%x) remove filter(id:%d)\n", cid, dmx->channel[cid].pid, fid);
+
+	dmx->filter[fid].used = 0;
+	dmx->channel[cid].filter_count--;
+
+	dmx_set_filter_regs(dmx, fid);
+	dmx_clear_filter_buffer(dmx, fid);
+}
+
+static int dmx_add_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed)
+{
+	int id, ret;
+	struct dvb_demux_filter *filter;
+	struct dvb_demux_feed *dfeed = NULL;
+
+	switch(feed->type)
+	{
+		case DMX_TYPE_TS:
+			pr_dbg("%s: DMX_TYPE_TS\n", __func__);
+			if((ret=dmx_get_chan(dmx, feed->pid))>=0) {
+				if (DVR_FEED(dmx->channel[ret].feed)){
+					if (DVR_FEED(feed)){
+						/*dvr feed already work*/
+						pr_error("PID %d already used(DVR)\n", feed->pid);
+						return -EBUSY;
+					}
+					dfeed = dmx->channel[ret].feed;
+					dmx_remove_feed(dmx, dfeed);
+				} else {
+					if (DVR_FEED(feed) && (! dmx->channel[ret].dvr_feed)){
+						/*just store the dvr_feed*/
+						dmx->channel[ret].dvr_feed = feed;
+						feed->priv = (void*)ret;
+						if (! dmx->record){
+							dmx_enable(dmx);
+						}
+						return 0;
+					}else{
+						pr_error("PID %d already used\n", feed->pid);
+						return -EBUSY;
+					}
+				}
+			}
+			if((ret=dmx_alloc_chan(dmx, feed->type, feed->pes_type, feed->pid))<0) {
+				pr_dbg("%s: alloc chan error, ret=%d\n", __func__, ret);
+				return ret;
+			}
+			dmx->channel[ret].feed = feed;
+			feed->priv = (void*)ret;
+			dmx->channel[ret].dvr_feed = NULL;
+			/*dvr*/
+			if (DVR_FEED(feed)){
+				dmx->channel[ret].dvr_feed = feed;
+				feed->priv = (void*)ret;
+				if (! dmx->record){
+					dmx_enable(dmx);
+				}
+			}else if (dfeed){
+				dmx->channel[ret].dvr_feed = dfeed;
+				dfeed->priv = (void*)ret;
+				if (! dmx->record){
+					dmx_enable(dmx);
+				}
+			}
+
+		break;
+		case DMX_TYPE_SEC:
+			pr_dbg("%s: DMX_TYPE_SEC\n", __func__);
+			if((ret=dmx_get_chan(dmx, feed->pid))>=0) {
+				if (DVR_FEED(dmx->channel[ret].feed)){
+					dfeed = dmx->channel[ret].feed;
+					dmx_remove_feed(dmx, dfeed);
+				} else {
+					pr_error("PID %d already used\n", feed->pid);
+					return -EBUSY;
+				}
+			}
+			if((id=dmx_alloc_chan(dmx, feed->type, feed->pes_type, feed->pid))<0) {
+				return id;
+			}
+			for(filter=feed->filter; filter; filter=filter->next) {
+				if((ret=dmx_chan_add_filter(dmx, id, filter))>=0) {
+					filter->hw_handle = ret;
+				} else {
+					filter->hw_handle = (u16)-1;
+				}
+			}
+			dmx->channel[id].feed = feed;
+			feed->priv = (void*)id;
+			dmx->channel[id].dvr_feed = NULL;
+			if (dfeed){
+				dmx->channel[id].dvr_feed = dfeed;
+				dfeed->priv = (void*)id;
+				if (! dmx->record){
+					dmx_enable(dmx);
+				}
+			}
+		break;
+		default:
+			return -EINVAL;
+		break;
+	}
+
+	dmx->feed_count++;
+
+	return 0;
+}
+
+static int dmx_remove_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed)
+{
+	struct dvb_demux_filter *filter;
+	struct dvb_demux_feed *dfeed = NULL;
+
+	switch(feed->type)
+	{
+		case DMX_TYPE_TS:
+			if (dmx->channel[(int)feed->priv].feed == dmx->channel[(int)feed->priv].dvr_feed){
+				dmx_free_chan(dmx, (int)feed->priv);
+			} else {
+				if (feed == dmx->channel[(int)feed->priv].feed) {
+					dfeed = dmx->channel[(int)feed->priv].dvr_feed;
+					dmx_free_chan(dmx, (int)feed->priv);
+					if (dfeed) {
+						/*start the dvr feed*/
+						dmx_add_feed(dmx, dfeed);
+					}
+				} else if (feed == dmx->channel[(int)feed->priv].dvr_feed) {
+					/*just remove the dvr_feed*/
+					dmx->channel[(int)feed->priv].dvr_feed = NULL;
+					if (dmx->record) {
+						dmx_enable(dmx);
+					}
+				} else {
+					/*This must never happen*/
+					pr_error("%s: unknown feed\n", __func__);
+					return -EINVAL;
+				}
+			}
+
+		break;
+		case DMX_TYPE_SEC:
+			for(filter=feed->filter; filter; filter=filter->next) {
+				if(filter->hw_handle!=(u16)-1)
+					dmx_remove_filter(dmx, (int)feed->priv, (int)filter->hw_handle);
+			}
+			dfeed = dmx->channel[(int)feed->priv].dvr_feed;
+			dmx_free_chan(dmx, (int)feed->priv);
+			if (dfeed) {
+				/*start the dvr feed*/
+				dmx_add_feed(dmx, dfeed);
+			}
+		break;
+		default:
+			return -EINVAL;
+		break;
+	}
+
+	dmx->feed_count--;
+	return 0;
+}
+
+int aml_dmx_hw_init(struct aml_dmx *dmx)
+{
+	//struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+	unsigned long flags;
+	int ret;
+
+	/*Demux initialize*/
+	spin_lock_irqsave(&dmx->slock, flags);
+	ret = dmx_init(dmx);
+	spin_unlock_irqrestore(&dmx->slock, flags);
+
+	return ret;
+}
+
+int aml_dmx_hw_deinit(struct aml_dmx *dmx)
+{
+	unsigned long flags;
+	int ret;
+	spin_lock_irqsave(&dmx->slock, flags);
+	ret = dmx_deinit(dmx);
+	spin_unlock_irqrestore(&dmx->slock, flags);
+
+	return ret;
+}
+
+int aml_asyncfifo_hw_init(struct aml_asyncfifo *afifo)
+{
+	unsigned long flags;
+	int ret;
+
+	/*Async FIFO initialize*/
+	spin_lock_irqsave(&afifo->slock, flags);
+	ret = async_fifo_init(afifo);
+	spin_unlock_irqrestore(&afifo->slock, flags);
+
+	return ret;
+}
+
+int aml_asyncfifo_hw_deinit(struct aml_asyncfifo *afifo)
+{
+	unsigned long flags;
+	int ret;
+	spin_lock_irqsave(&afifo->slock, flags);
+	ret = async_fifo_deinit(afifo);
+	spin_unlock_irqrestore(&afifo->slock, flags);
+
+	return ret;
+}
+
+int aml_asyncfifo_hw_reset(struct aml_asyncfifo *afifo)
+{
+	unsigned long flags;
+	int ret, src = -1;
+	spin_lock_irqsave(&afifo->slock, flags);
+	if (afifo->init) {
+		src = afifo->source;
+		async_fifo_deinit(afifo);
+	}
+	ret = async_fifo_init(afifo);
+	/* restore the source */
+	if (src != -1) {
+		afifo->source = src;
+	}
+	if(ret==0 && afifo->dvb) {
+		reset_async_fifos(afifo->dvb);
+	}
+	spin_unlock_irqrestore(&afifo->slock, flags);
+
+	return ret;
+}
+
+int aml_dmx_hw_start_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	struct aml_dmx *dmx = (struct aml_dmx*)dvbdmxfeed->demux;
+	//struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dmx->slock, flags);
+	ret = dmx_add_feed(dmx, dvbdmxfeed);
+	spin_unlock_irqrestore(&dmx->slock, flags);
+
+	return ret;
+}
+
+int aml_dmx_hw_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	struct aml_dmx *dmx = (struct aml_dmx*)dvbdmxfeed->demux;
+	//struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dmx->slock, flags);
+	dmx_remove_feed(dmx, dvbdmxfeed);
+	spin_unlock_irqrestore(&dmx->slock, flags);
+
+	return 0;
+}
+
+int aml_dmx_hw_set_source(struct dmx_demux* demux, dmx_source_t src)
+{
+	struct aml_dmx *dmx = (struct aml_dmx*)demux;
+	struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+	int ret = 0;
+	int hw_src;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dmx->slock, flags);
+
+	hw_src = dmx->source;
+
+	switch(src) {
+		case DMX_SOURCE_FRONT0:
+			hw_src = (dvb->ts[0].mode == AM_TS_SERIAL) ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
+		break;
+		case DMX_SOURCE_FRONT1:
+			hw_src = (dvb->ts[1].mode == AM_TS_SERIAL) ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
+		break;
+		case DMX_SOURCE_FRONT2:
+			hw_src = (dvb->ts[2].mode == AM_TS_SERIAL) ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
+		break;
+		case DMX_SOURCE_DVR0:
+			hw_src = AM_TS_SRC_HIU;
+		break;
+		default:
+			pr_error("illegal demux source %d\n", src);
+			ret = -EINVAL;
+		break;
+	}
+
+	if(hw_src != dmx->source) {
+		dmx->source = hw_src;
+		dmx_reset_hw_ex(dvb, 0);
+	}
+
+	spin_unlock_irqrestore(&dmx->slock, flags);
+
+	return ret;
+}
+
+int aml_stb_hw_set_source(struct aml_dvb *dvb, dmx_source_t src)
+{
+	unsigned long flags;
+	int hw_src;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	hw_src = dvb->stb_source;
+
+	switch(src) {
+		case DMX_SOURCE_FRONT0:
+			hw_src = (dvb->ts[0].mode == AM_TS_SERIAL) ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
+		break;
+		case DMX_SOURCE_FRONT1:
+			hw_src = (dvb->ts[1].mode == AM_TS_SERIAL) ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
+		break;
+		case DMX_SOURCE_FRONT2:
+			hw_src = (dvb->ts[2].mode == AM_TS_SERIAL) ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
+		break;
+		case DMX_SOURCE_DVR0:
+			hw_src = AM_TS_SRC_HIU;
+		break;
+		case DMX_SOURCE_FRONT0+100:
+			hw_src = AM_TS_SRC_DMX0;
+		break;
+		case DMX_SOURCE_FRONT1+100:
+			hw_src = AM_TS_SRC_DMX1;
+		break;
+		case DMX_SOURCE_FRONT2+100:
+			hw_src = AM_TS_SRC_DMX2;
+		break;
+		default:
+			pr_error("illegal demux source %d\n", src);
+			ret = -EINVAL;
+		break;
+	}
+
+	if(dvb->stb_source != hw_src){
+		dvb->stb_source = hw_src;
+		dmx_reset_hw_ex(dvb, 0);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_dsc_hw_set_source(struct aml_dvb *dvb, aml_ts_source_t src)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if(src != dvb->dsc_source){
+		dvb->dsc_source = src;
+		dmx_reset_hw_ex(dvb, 0);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_tso_hw_set_source(struct aml_dvb *dvb, dmx_source_t src)
+{
+	int ret = 0;
+	unsigned long flags;
+	int hw_src;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	hw_src = dvb->tso_source;
+
+	switch(src) {
+		case DMX_SOURCE_FRONT0:
+			hw_src = (dvb->ts[0].mode == AM_TS_SERIAL) ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
+		break;
+		case DMX_SOURCE_FRONT1:
+			hw_src = (dvb->ts[1].mode == AM_TS_SERIAL) ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
+		break;
+		case DMX_SOURCE_FRONT2:
+			hw_src = (dvb->ts[2].mode == AM_TS_SERIAL) ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
+		break;
+		case DMX_SOURCE_DVR0:
+			hw_src = AM_TS_SRC_HIU;
+		break;
+		case DMX_SOURCE_FRONT0+100:
+			hw_src = AM_TS_SRC_DMX0;
+		break;
+		case DMX_SOURCE_FRONT1+100:
+			hw_src = AM_TS_SRC_DMX1;
+		break;
+		case DMX_SOURCE_FRONT2+100:
+			hw_src = AM_TS_SRC_DMX2;
+		break;
+		default:
+			pr_error("illegal demux source %d\n", src);
+			ret = -EINVAL;
+		break;
+	}
+
+	if(hw_src != dvb->tso_source){
+		dvb->tso_source = hw_src;
+		dmx_reset_hw_ex(dvb, 0);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_asyncfifo_hw_set_source(struct aml_asyncfifo *afifo, aml_dmx_id_t src)
+{
+	int ret = -1;
+	unsigned long flags;
+
+	spin_lock_irqsave(&afifo->slock, flags);
+
+	pr_dbg("asyncfifo %d set source %d->%d", afifo->id, afifo->source, src);
+	switch(src) {
+		case AM_DMX_0:
+		case AM_DMX_1:
+		case AM_DMX_2:
+			if (afifo->source != src) {
+				afifo->source = src;
+				ret = 0;
+			}
+		break;
+		default:
+			pr_error("illegal async fifo source %d\n", src);
+			ret = -EINVAL;
+		break;
+	}
+
+	if(ret==0 && afifo->dvb){
+		reset_async_fifos(afifo->dvb);
+	}
+
+	spin_unlock_irqrestore(&afifo->slock, flags);
+
+	return ret;
+}
+
+int aml_dmx_hw_set_dump_ts_select(struct dmx_demux* demux, int dump_ts_select)
+{
+	struct aml_dmx *dmx = (struct aml_dmx*)demux;
+	struct aml_dvb *dvb = (struct aml_dvb*)dmx->demux.priv;
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dmx->slock, flags);
+	dump_ts_select = !!dump_ts_select;
+	if (dmx->dump_ts_select != dump_ts_select){
+		dmx->dump_ts_select = dump_ts_select;
+		dmx_reset_hw_ex(dvb, 0);
+	}
+	spin_unlock_irqrestore(&dmx->slock, flags);
+
+	return ret;
+}
+
+u32 aml_dmx_get_video_pts(struct aml_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = video_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+u32 aml_dmx_get_audio_pts(struct aml_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = audio_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+u32 aml_dmx_get_first_video_pts(struct aml_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = first_video_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+u32 aml_dmx_get_first_audio_pts(struct aml_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = first_audio_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+int aml_dmx_set_skipbyte(struct aml_dvb *dvb, int skipbyte)
+{
+	if (demux_skipbyte != skipbyte) {
+		pr_dbg("set skip byte %d\n", skipbyte);
+		demux_skipbyte = skipbyte;
+		dmx_reset_hw_ex(dvb, 0);
+	}
+
+	return 0;
+}
+
+int aml_dmx_set_demux(struct aml_dvb *dvb, int id)
+{
+	aml_stb_hw_set_source(dvb, DMX_SOURCE_DVR0);
+	if(id < DMX_DEV_COUNT){
+		struct aml_dmx *dmx = &dvb->dmx[id];
+		aml_dmx_hw_set_source((struct dmx_demux*)dmx, DMX_SOURCE_DVR0);
+	}
+
+	return 0;
+}
+
+int _set_tsfile_clkdiv(struct aml_dvb *dvb, int clkdiv)
+{
+	if (tsfile_clkdiv != clkdiv) {
+		pr_dbg("set ts file clock div %d\n", clkdiv);
+		tsfile_clkdiv = clkdiv;
+		dmx_reset_hw(dvb);
+	}
+
+	return 0;
+}
+static ssize_t stb_set_tsfile_clkdiv(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	int div = (int)simple_strtol(buf, NULL, 10);
+	_set_tsfile_clkdiv(aml_get_dvb_device(), div);
+	return size;
+}
+static ssize_t stb_get_tsfile_clkdiv(struct class *class, struct class_attribute *attr,char *buf)
+{
+	ssize_t ret;
+	ret = sprintf(buf, "%d\n", tsfile_clkdiv);\
+	return ret;
+}
+
+#define DEMUX_SCAMBLE_FUNC_DECL(i)  \
+static ssize_t dmx_reg_value_show_demux##i##_scramble(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	int data = 0;\
+	int aflag = 0;\
+	int vflag = 0;\
+	ssize_t ret = 0;\
+	data = DMX_READ_REG(i, DEMUX_SCRAMBLING_STATE);\
+	if ((data & 0x01 )== 0x01){\
+		vflag = 1;}\
+	if ((data & 0x02 )== 0x02){\
+		aflag = 1;}\
+	ret = sprintf(buf, "%d %d\n", vflag, aflag);\
+	return ret;\
+}
+
+#if DMX_DEV_COUNT>0
+	DEMUX_SCAMBLE_FUNC_DECL(0)
+#endif
+
+#if DMX_DEV_COUNT>1
+	DEMUX_SCAMBLE_FUNC_DECL(1)
+#endif
+
+
+static ssize_t dmx_reg_addr_show_source(struct class *class, struct class_attribute *attr,char *buf);
+static ssize_t dmx_reg_addr_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size);
+static ssize_t dmx_id_show_source(struct class *class, struct class_attribute *attr,char *buf);
+static ssize_t dmx_id_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size);
+static ssize_t dmx_reg_value_show_source(struct class *class, struct class_attribute *attr,char *buf);
+static ssize_t dmx_reg_value_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size);
+
+
+static int reg_addr=0;
+static int dmx_id=0;
+static struct class_attribute aml_dmx_class_attrs[] = {
+	__ATTR(dmx_id,  S_IRUGO | S_IWUSR, dmx_id_show_source, dmx_id_store_source),
+	__ATTR(register_addr,  S_IRUGO | S_IWUSR, dmx_reg_addr_show_source, dmx_reg_addr_store_source),
+	__ATTR(register_value,  S_IRUGO | S_IWUSR, dmx_reg_value_show_source, dmx_reg_value_store_source),
+	__ATTR(tsfile_clkdiv,  S_IRUGO | S_IWUSR, stb_get_tsfile_clkdiv, stb_set_tsfile_clkdiv),
+
+	#define DEMUX_SCAMBLE_ATTR_DECL(i)\
+		__ATTR(demux##i##_scramble,  S_IRUGO | S_IWUSR, dmx_reg_value_show_demux##i##_scramble, NULL)
+	#if DMX_DEV_COUNT>0
+		DEMUX_SCAMBLE_ATTR_DECL(0),
+	#endif
+	#if DMX_DEV_COUNT>1
+		DEMUX_SCAMBLE_ATTR_DECL(1),
+	#endif
+	__ATTR_NULL
+};
+
+static struct class aml_dmx_class = {
+	.name = "dmx",
+	.class_attrs = aml_dmx_class_attrs,
+};
+
+
+static ssize_t dmx_id_show_source(struct class *class, struct class_attribute *attr,char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "%d\n", dmx_id);
+	return ret;
+}
+static ssize_t dmx_id_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	int id=0;
+	id=simple_strtol(buf,0,16);
+
+	if(id<0||id>2)
+	{
+		pr_dbg("dmx id must 0 ~2\n");
+	}
+	else
+	{
+		dmx_id=id;
+	}
+
+	return size;
+}
+
+
+static ssize_t dmx_reg_addr_show_source(struct class *class, struct class_attribute *attr,char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "%x\n", reg_addr);
+	return ret;
+}
+static ssize_t dmx_reg_addr_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	int addr=0;
+	addr=simple_strtol(buf,0,16);
+	reg_addr=addr;
+	return size;
+}
+
+
+static ssize_t dmx_reg_value_show_source(struct class *class, struct class_attribute *attr,char *buf)
+{
+	int ret,value;
+	value=READ_MPEG_REG(reg_addr);
+	ret = sprintf(buf, "%x\n", value);
+	return ret;
+}
+static ssize_t dmx_reg_value_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	int value=0;
+	value=simple_strtol(buf,0,16);
+	WRITE_MPEG_REG(reg_addr,value);
+	return size;
+}
+
+int aml_regist_dmx_class(void)
+{
+
+	if(class_register(&aml_dmx_class)<0) {
+                pr_error("register class error\n");
+        }
+
+	return 0;
+}
+
+
+int aml_unregist_dmx_class(void)
+{
+
+	class_unregister(&aml_dmx_class);
+	return 0;
+}
+
+static struct aml_dmx* get_dmx_from_src(aml_ts_source_t src)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = NULL;
+	int i;
+
+	if(dvb){
+		switch(src){
+			case AM_TS_SRC_TS0:
+			case AM_TS_SRC_TS1:
+			case AM_TS_SRC_TS2:
+			case AM_TS_SRC_S_TS0:
+			case AM_TS_SRC_S_TS1:
+			case AM_TS_SRC_S_TS2:
+				for(i=0; i<DMX_DEV_COUNT; i++){
+					if(dvb->dmx[i].source == src){
+						dmx = &dvb->dmx[i];
+						break;
+					}
+				}
+				break;
+			case AM_TS_SRC_DMX0:
+				if(0>DMX_DEV_COUNT){
+					dmx = &dvb->dmx[0];
+				}
+				break;
+			case AM_TS_SRC_DMX1:
+				if(1>DMX_DEV_COUNT){
+					dmx = &dvb->dmx[1];
+				}
+				break;
+			case AM_TS_SRC_DMX2:
+				if(2>DMX_DEV_COUNT){
+					dmx = &dvb->dmx[2];
+				}
+				break;
+			default:
+				break;
+		}
+	}
+
+	return dmx;
+}
+
+void aml_dmx_register_frontend(aml_ts_source_t src, struct dvb_frontend *fe)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if(dmx){
+		dmx->fe = fe;
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void aml_dmx_before_retune(aml_ts_source_t src, struct dvb_frontend *fe)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if(dmx){
+		dmx->fe = fe;
+		dmx->in_tune = 1;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void aml_dmx_after_retune(aml_ts_source_t src, struct dvb_frontend *fe)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if(dmx){
+		dmx->fe = fe;
+		dmx->in_tune = 0;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void aml_dmx_start_error_check(aml_ts_source_t src, struct dvb_frontend *fe)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if(dmx){
+		dmx->fe = fe;
+		dmx->error_check = 0;
+		dmx->int_check_time = 0;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+int  aml_dmx_stop_error_check(aml_ts_source_t src, struct dvb_frontend *fe)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if(dmx){
+		dmx->fe = fe;
+		ret = dmx->error_check;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
diff --git a/drivers/amlogic/dvb_tv/aml_dvb.c b/drivers/amlogic/dvb_tv/aml_dvb.c
new file mode 100755
index 000000000000..c353df685ef2
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/aml_dvb.c
@@ -0,0 +1,1533 @@
+/*
+ * AMLOGIC DVB driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#define ENABLE_DEMUX_DRIVER
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/amstream.h>
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+#include <mach/am_regs.h>
+#endif
+
+#include <mach/mod_gate.h>
+#include <linux/gpio.h>
+#include <linux/spinlock.h>
+#include <linux/amlogic/amdsc.h>
+#include <linux/string.h>
+#include <linux/pinctrl/consumer.h>
+#include "aml_dvb.h"
+
+#define pr_dbg(fmt, args...)\
+	do{\
+		if(debug_dvb)\
+			printk("DVB: " fmt, ## args);\
+	}while(0)
+#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
+
+MODULE_PARM_DESC(debug_dvb, "\n\t\t Enable dvb debug information");
+static int debug_dvb = 1;
+module_param(debug_dvb, int, S_IRUGO);
+
+#define CARD_NAME "amlogic-dvb"
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static struct aml_dvb aml_dvb_device;
+static struct class   aml_stb_class;
+
+static int aml_tsdemux_reset(void);
+static int aml_tsdemux_set_reset_flag(void);
+static int aml_tsdemux_request_irq(irq_handler_t handler, void *data);
+static int aml_tsdemux_free_irq(void);
+static int aml_tsdemux_set_vid(int vpid);
+static int aml_tsdemux_set_aid(int apid);
+static int aml_tsdemux_set_sid(int spid);
+static int aml_tsdemux_set_skipbyte(int skipbyte);
+static int aml_tsdemux_set_demux(int id);
+
+static struct tsdemux_ops aml_tsdemux_ops = {
+.reset          = aml_tsdemux_reset,
+.set_reset_flag = aml_tsdemux_set_reset_flag,
+.request_irq    = aml_tsdemux_request_irq,
+.free_irq       = aml_tsdemux_free_irq,
+.set_vid        = aml_tsdemux_set_vid,
+.set_aid        = aml_tsdemux_set_aid,
+.set_sid        = aml_tsdemux_set_sid,
+.set_skipbyte   = aml_tsdemux_set_skipbyte,
+.set_demux      = aml_tsdemux_set_demux
+};
+
+static void aml_dvb_dmx_release(struct aml_dvb *advb, struct aml_dmx *dmx)
+{
+	int i;
+
+	dvb_net_release(&dmx->dvb_net);
+	aml_dmx_hw_deinit(dmx);
+	dmx->demux.dmx.close(&dmx->demux.dmx);
+	dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->mem_fe);
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->hw_fe[i]);
+	}
+
+	dvb_dmxdev_release(&dmx->dmxdev);
+	dvb_dmx_release(&dmx->demux);
+}
+
+static int aml_dvb_dmx_init(struct aml_dvb *advb, struct aml_dmx *dmx, int id)
+{
+	int i, ret;
+#ifndef CONFIG_OF
+	struct resource *res;
+	char buf[32];
+#endif
+	switch(id){
+		case 0:
+			dmx->dmx_irq = INT_DEMUX;
+			break;
+		case 1:
+			dmx->dmx_irq = INT_DEMUX_1;
+			break;
+		case 2:
+			dmx->dmx_irq = INT_DEMUX_2;
+			break;
+	}
+
+#ifndef CONFIG_OF
+	snprintf(buf, sizeof(buf), "demux%d_irq", id);
+	res = platform_get_resource_byname(advb->pdev, IORESOURCE_IRQ, buf);
+	if (res) {
+		dmx->dmx_irq = res->start;
+	}
+#endif
+
+	dmx->source  = -1;
+	dmx->dump_ts_select = 0;
+	dmx->dvr_irq = -1;
+
+	dmx->demux.dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING | DMX_PES_FILTERING | DMX_MEMORY_BASED_FILTERING | DMX_TS_DESCRAMBLING);
+	dmx->demux.filternum = dmx->demux.feednum = FILTER_COUNT;
+	dmx->demux.priv = advb;
+	dmx->demux.start_feed = aml_dmx_hw_start_feed;
+	dmx->demux.stop_feed = aml_dmx_hw_stop_feed;
+	dmx->demux.write_to_decoder = NULL;
+	spin_lock_init(&dmx->slock);
+
+	if ((ret = dvb_dmx_init(&dmx->demux)) < 0) {
+		pr_error("dvb_dmx failed: error %d\n",ret);
+		goto error_dmx_init;
+	}
+
+	dmx->dmxdev.filternum = dmx->demux.feednum;
+	dmx->dmxdev.demux = &dmx->demux.dmx;
+	dmx->dmxdev.capabilities = 0;
+	if ((ret = dvb_dmxdev_init(&dmx->dmxdev, &advb->dvb_adapter)) < 0) {
+		pr_error("dvb_dmxdev_init failed: error %d\n",ret);
+		goto error_dmxdev_init;
+	}
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		int source = i+DMX_FRONTEND_0;
+		dmx->hw_fe[i].source = source;
+
+		if ((ret = dmx->demux.dmx.add_frontend(&dmx->demux.dmx, &dmx->hw_fe[i])) < 0) {
+			pr_error("adding hw_frontend to dmx failed: error %d",ret);
+			dmx->hw_fe[i].source = 0;
+			goto error_add_hw_fe;
+		}
+	}
+
+	dmx->mem_fe.source = DMX_MEMORY_FE;
+	if ((ret = dmx->demux.dmx.add_frontend(&dmx->demux.dmx, &dmx->mem_fe)) < 0) {
+		pr_error("adding mem_frontend to dmx failed: error %d",ret);
+		goto error_add_mem_fe;
+	}
+
+	if ((ret = dmx->demux.dmx.connect_frontend(&dmx->demux.dmx, &dmx->hw_fe[1])) < 0) {
+		pr_error("connect frontend failed: error %d",ret);
+		goto error_connect_fe;
+	}
+
+	dmx->id = id;
+	dmx->aud_chan = -1;
+	dmx->vid_chan = -1;
+	dmx->sub_chan = -1;
+
+	if ((ret = aml_dmx_hw_init(dmx)) <0) {
+		pr_error("demux hw init error %d", ret);
+		dmx->id = -1;
+		goto error_dmx_hw_init;
+	}
+
+	dvb_net_init(&advb->dvb_adapter, &dmx->dvb_net, &dmx->demux.dmx);
+
+	return 0;
+error_dmx_hw_init:
+error_connect_fe:
+	dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->mem_fe);
+error_add_mem_fe:
+error_add_hw_fe:
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		if (dmx->hw_fe[i].source)
+			dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->hw_fe[i]);
+	}
+	dvb_dmxdev_release(&dmx->dmxdev);
+error_dmxdev_init:
+	dvb_dmx_release(&dmx->demux);
+error_dmx_init:
+	return ret;
+}
+struct aml_dvb* aml_get_dvb_device(void)
+{
+	return &aml_dvb_device;
+}
+
+EXPORT_SYMBOL(aml_get_dvb_device);
+
+static int dvb_dsc_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct aml_dvb *dvb = dvbdev->priv;
+	struct aml_dsc *dsc;
+	int id;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	for(id=0; id<DSC_COUNT; id++) {
+		if(!dvb->dsc[id].used) {
+			dvb->dsc[id].used = 1;
+			dvbdev->users++;
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(id>=DSC_COUNT) {
+		pr_error("too many descrambler\n");
+		return -EBUSY;
+	}
+
+	dsc = &dvb->dsc[id];
+	dsc->id   = id;
+	dsc->pid  = -1;
+	dsc->set  = 0;
+	dsc->dvb  = dvb;
+
+	file->private_data = dsc;
+	return 0;
+}
+
+static long dvb_dsc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct aml_dsc *dsc = file->private_data;
+	struct aml_dvb *dvb = dsc->dvb;
+	struct am_dsc_key key;
+	int ret = 0, i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	switch(cmd) {
+		case AMDSC_IOC_SET_PID:
+			for(i=0; i<DSC_COUNT; i++) {
+				if(i==dsc->id)
+					continue;
+				if(dvb->dsc[i].used && (dvb->dsc[i].pid==arg)) {
+					ret = -EBUSY;
+				}
+			}
+			dsc->pid = arg;
+			dsc_set_pid(dsc, dsc->pid);
+		break;
+		case AMDSC_IOC_SET_KEY:
+			if (copy_from_user(&key, (void __user *)arg, sizeof(struct am_dsc_key))) {
+				ret = -EFAULT;
+			} else {
+				if(key.type)
+					memcpy(dsc->odd, key.key, 8);
+				else
+					memcpy(dsc->even, key.key, 8);
+				dsc->set |= 1<<(key.type);
+				dsc_set_key(dsc, key.type, key.key);
+			}
+		break;
+		default:
+			ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+static int dvb_dsc_release(struct inode *inode, struct file *file)
+{
+	struct aml_dsc *dsc = file->private_data;
+	struct aml_dvb *dvb = dsc->dvb;
+	unsigned long flags;
+
+	//dvb_generic_release(inode, file);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dsc->used = 0;
+	dsc_release(dsc);
+	dvb->dsc_dev->users--;
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+static int aml_dvb_asyncfifo_init(struct aml_dvb *advb, struct aml_asyncfifo *asyncfifo, int id)
+{
+#ifndef CONFIG_OF
+	struct resource *res;
+	char buf[32];
+#endif
+
+	if(id == 0)
+		asyncfifo->asyncfifo_irq = INT_ASYNC_FIFO_FLUSH;
+	else
+		asyncfifo->asyncfifo_irq = INT_ASYNC_FIFO2_FLUSH;
+
+#ifndef CONFIG_OF
+	snprintf(buf, sizeof(buf), "dvr%d_irq", id);
+	res = platform_get_resource_byname(advb->pdev, IORESOURCE_IRQ, buf);
+	if (res) {
+		asyncfifo->asyncfifo_irq = res->start;
+	}
+#endif
+
+	spin_lock_init(&asyncfifo->slock);
+	asyncfifo->dvb = advb;
+	asyncfifo->id = id;
+	asyncfifo->init = 0;
+	asyncfifo->flush_size = 256*1024;
+
+	return aml_asyncfifo_hw_init(asyncfifo);
+}
+
+static void aml_dvb_asyncfifo_release(struct aml_dvb *advb, struct aml_asyncfifo *asyncfifo)
+{
+	aml_asyncfifo_hw_deinit(asyncfifo);
+}
+
+/*Show the STB input source*/
+static ssize_t stb_show_source(struct class *class, struct class_attribute *attr,char *buf)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+	char *src;
+
+	switch(dvb->stb_source) {
+		case AM_TS_SRC_TS0:
+		case AM_TS_SRC_S_TS0:
+			src = "ts0";
+		break;
+		case AM_TS_SRC_TS1:
+		case AM_TS_SRC_S_TS1:
+			src = "ts1";
+		break;
+		case AM_TS_SRC_TS2:
+		case AM_TS_SRC_S_TS2:
+			src = "ts2";
+		break;
+		case AM_TS_SRC_HIU:
+			src = "hiu";
+		break;
+		case AM_TS_SRC_DMX0:
+			src = "dmx0";
+		break;
+		case AM_TS_SRC_DMX1:
+			src = "dmx1";
+		break;
+		case AM_TS_SRC_DMX2:
+			src = "dmx2";
+		break;
+		default:
+			src = "";
+		break;
+	}
+
+	ret = sprintf(buf, "%s\n", src);
+	return ret;
+}
+
+/*Set the STB input source*/
+static ssize_t stb_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+    dmx_source_t src = -1;
+
+    if(!strncmp("ts0", buf, 3)) {
+    	src = DMX_SOURCE_FRONT0;
+    } else if(!strncmp("ts1", buf, 3)) {
+    	src = DMX_SOURCE_FRONT1;
+    } else if(!strncmp("ts2", buf, 3)) {
+    	src = DMX_SOURCE_FRONT2;
+    } else if(!strncmp("hiu", buf, 3)) {
+    	src = DMX_SOURCE_DVR0;
+    } else if(!strncmp("dmx0", buf, 4)) {
+        src = DMX_SOURCE_FRONT0+100;
+    } else if(!strncmp("dmx1", buf, 4)) {
+        src = DMX_SOURCE_FRONT1+100;
+    } else if(!strncmp("dmx2", buf, 4)) {
+        src = DMX_SOURCE_FRONT2+100;
+    }
+    if(src!=-1) {
+    	aml_stb_hw_set_source(&aml_dvb_device, src);
+    }
+
+    return size;
+}
+/*Show the descrambler's input source*/
+static ssize_t dsc_show_source(struct class *class,struct class_attribute *attr, char *buf)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+	char *src;
+
+	switch(dvb->dsc_source) {
+		case AM_DMX_0:
+			src = "dmx0";
+		break;
+		case AM_DMX_1:
+			src = "dmx1";
+		break;
+		case AM_DMX_2:
+			src = "dmx2";
+		break;
+		default:
+			src = "";
+		break;
+	}
+
+	ret = sprintf(buf, "%s\n", src);
+	return ret;
+}
+
+/*Set the descrambler's input source*/
+static ssize_t dsc_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	dmx_source_t src = -1;
+
+	if(!strncmp("dmx0", buf, 4)) {
+		src = AM_DMX_0;
+	} else if(!strncmp("dmx1", buf, 4)) {
+		src = AM_DMX_1;
+	}else if(!strncmp("dmx2", buf, 4)) {
+		src = AM_DMX_2;
+	}
+
+	if(src!=-1) {
+		aml_dsc_hw_set_source(&aml_dvb_device, src);
+	}
+
+	return size;
+}
+
+/*Show the TS output source*/
+static ssize_t tso_show_source(struct class *class, struct class_attribute *attr,char *buf)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+	char *src;
+
+	switch(dvb->tso_source) {
+		case AM_TS_SRC_TS0:
+		case AM_TS_SRC_S_TS0:
+			src = "ts0";
+		break;
+		case AM_TS_SRC_TS1:
+		case AM_TS_SRC_S_TS1:
+			src = "ts1";
+		break;
+		case AM_TS_SRC_TS2:
+		case AM_TS_SRC_S_TS2:
+			src = "ts2";
+		break;
+		case AM_TS_SRC_HIU:
+			src = "hiu";
+		break;
+		case AM_TS_SRC_DMX0:
+			src = "dmx0";
+		break;
+		case AM_TS_SRC_DMX1:
+			src = "dmx1";
+		break;
+		case AM_TS_SRC_DMX2:
+			src = "dmx2";
+		break;
+		default:
+			src = "";
+		break;
+	}
+
+	ret = sprintf(buf, "%s\n", src);
+	return ret;
+}
+
+/*Set the TS output source*/
+static ssize_t tso_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+    dmx_source_t src = -1;
+
+    if(!strncmp("ts0", buf, 3)) {
+    	src = DMX_SOURCE_FRONT0;
+    } else if(!strncmp("ts1", buf, 3)) {
+    	src = DMX_SOURCE_FRONT1;
+    } else if(!strncmp("ts2", buf, 3)) {
+    	src = DMX_SOURCE_FRONT2;
+    } else if(!strncmp("hiu", buf, 3)) {
+    	src = DMX_SOURCE_DVR0;
+    } else if(!strncmp("dmx0", buf, 4)) {
+        src = DMX_SOURCE_FRONT0+100;
+    } else if(!strncmp("dmx1", buf, 4)) {
+        src = DMX_SOURCE_FRONT1+100;
+    } else if(!strncmp("dmx2", buf, 4)) {
+        src = DMX_SOURCE_FRONT2+100;
+    }
+    if(src!=-1) {
+    	aml_tso_hw_set_source(&aml_dvb_device, src);
+    }
+
+    return size;
+}
+
+
+
+
+/*Show the STB input source*/
+#define DEMUX_SOURCE_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_source(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_dmx *dmx = &dvb->dmx[i];\
+	ssize_t ret = 0;\
+	char *src;\
+	switch(dmx->source) {\
+		case AM_TS_SRC_TS0:\
+		case AM_TS_SRC_S_TS0:\
+			src = "ts0";\
+		break;\
+		case AM_TS_SRC_TS1:\
+		case AM_TS_SRC_S_TS1:\
+			src = "ts1";\
+		break;\
+		case AM_TS_SRC_TS2:\
+		case AM_TS_SRC_S_TS2:\
+			src = "ts2";\
+		break;\
+		case AM_TS_SRC_HIU:\
+			src = "hiu";\
+		break;\
+		default:\
+			src = "";\
+		break;\
+	}\
+	ret = sprintf(buf, "%s\n", src);\
+	return ret;\
+}\
+static ssize_t demux##i##_store_source(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    dmx_source_t src = -1;\
+    \
+	if(!strncmp("ts0", buf, 3)) {\
+    	src = DMX_SOURCE_FRONT0;\
+    } else if(!strncmp("ts1", buf, 3)) {\
+    	src = DMX_SOURCE_FRONT1;\
+    } else if(!strncmp("ts2", buf, 3)) {\
+    	src = DMX_SOURCE_FRONT2;\
+    } else if(!strncmp("hiu", buf, 3)) {\
+    	src = DMX_SOURCE_DVR0;\
+    }\
+    if(src!=-1) {\
+    	aml_dmx_hw_set_source(aml_dvb_device.dmx[i].dmxdev.demux, src);\
+    }\
+    return size;\
+}
+
+/*Show free filters count*/
+#define DEMUX_FREE_FILTERS_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_free_filters(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_dmx *dmx = &dvb->dmx[i];\
+	int fid, count;\
+	ssize_t ret = 0;\
+	unsigned long flags;\
+	spin_lock_irqsave(&dvb->slock, flags);\
+	count = 0;\
+	for(fid = 0; fid < FILTER_COUNT; fid++){\
+		if(!dmx->filter[fid].used)\
+			count++;\
+	}\
+	spin_unlock_irqrestore(&dvb->slock, flags);\
+	ret = sprintf(buf, "%d\n", count);\
+	return ret;\
+}
+
+/*Show filter users count*/
+#define DEMUX_FILTER_USERS_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_filter_users(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_dmx *dmx = &dvb->dmx[i];\
+	int dmxdevfid, count;\
+	ssize_t ret = 0;\
+	unsigned long flags;\
+	spin_lock_irqsave(&dvb->slock, flags);\
+	count = 0;\
+	for(dmxdevfid = 0; dmxdevfid < dmx->dmxdev.filternum; dmxdevfid++){\
+		if(dmx->dmxdev.filter[dmxdevfid].state >= DMXDEV_STATE_ALLOCATED)\
+			count++;\
+	}\
+	if(count > dmx->demux_filter_user){\
+		count = dmx->demux_filter_user;\
+	}else{\
+		dmx->demux_filter_user = count;\
+	}\
+	spin_unlock_irqrestore(&dvb->slock, flags);\
+	ret = sprintf(buf, "%d\n", count);\
+	return ret;\
+}\
+static ssize_t demux##i##_store_filter_used(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_dmx *dmx = &dvb->dmx[i];\
+	unsigned long filter_used;\
+	char *endp;\
+	unsigned long flags;\
+	filter_used = simple_strtol(buf, &endp, 0);\
+	spin_lock_irqsave(&dvb->slock, flags);\
+	if(filter_used){\
+		if(dmx->demux_filter_user < FILTER_COUNT)\
+			dmx->demux_filter_user++;\
+	}else{\
+		if(dmx->demux_filter_user > 0)\
+			dmx->demux_filter_user--;\
+	}\
+	spin_unlock_irqrestore(&dvb->slock, flags);\
+	return size;\
+}
+
+
+/*Show ts header*/
+#define DEMUX_TS_HEADER_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_ts_header(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	int hdr = 0;\
+	if(i == 0)\
+		hdr = READ_MPEG_REG(TS_HEAD_1);\
+	else if(i==1)\
+		hdr = READ_MPEG_REG(TS_HEAD_1_2);\
+	else if(i==2)\
+		hdr = READ_MPEG_REG(TS_HEAD_1_3);\
+	return sprintf(buf, "%08x\n", hdr);\
+}
+
+/*Show channel activity*/
+#define DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_channel_activity(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	int f = 0;\
+	if(i == 0)\
+		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY);\
+	else if(i==1)\
+		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY_2);\
+	else if(i==2)\
+		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY_3);\
+	return sprintf(buf, "%08x\n", f);\
+}
+
+/*DVR record mode*/
+#define DVR_MODE_FUNC_DECL(i)  \
+static ssize_t dvr##i##_show_mode(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_dmx *dmx = &dvb->dmx[i];\
+	ssize_t ret = 0;\
+	char *mode;\
+	if(dmx->dump_ts_select) {\
+		mode = "ts";\
+	}else{\
+		mode = "pid";\
+	}\
+	ret = sprintf(buf, "%s\n", mode);\
+	return ret;\
+}\
+static ssize_t dvr##i##_store_mode(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    struct aml_dvb *dvb = &aml_dvb_device;\
+    struct aml_dmx *dmx = &dvb->dmx[i];\
+    int dump_ts_select = -1;\
+    \
+    if(!strncmp("pid", buf, 3) && dmx->dump_ts_select) {\
+    	dump_ts_select = 0;\
+    } else if(!strncmp("ts", buf, 2) && !dmx->dump_ts_select) {\
+    	dump_ts_select = 1;\
+    }\
+    if(dump_ts_select!=-1) {\
+    	aml_dmx_hw_set_dump_ts_select(aml_dvb_device.dmx[i].dmxdev.demux, dump_ts_select);\
+    }\
+    return size;\
+}
+
+#if DMX_DEV_COUNT>0
+	DEMUX_SOURCE_FUNC_DECL(0)
+	DEMUX_FREE_FILTERS_FUNC_DECL(0)
+	DEMUX_FILTER_USERS_FUNC_DECL(0)
+	DVR_MODE_FUNC_DECL(0)
+	DEMUX_TS_HEADER_FUNC_DECL(0)
+	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(0)
+#endif
+#if DMX_DEV_COUNT>1
+	DEMUX_SOURCE_FUNC_DECL(1)
+	DEMUX_FREE_FILTERS_FUNC_DECL(1)
+	DEMUX_FILTER_USERS_FUNC_DECL(1)
+	DVR_MODE_FUNC_DECL(1)
+	DEMUX_TS_HEADER_FUNC_DECL(1)
+	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(1)
+#endif
+#if DMX_DEV_COUNT>2
+	DEMUX_SOURCE_FUNC_DECL(2)
+	DEMUX_FREE_FILTERS_FUNC_DECL(2)
+	DEMUX_FILTER_USERS_FUNC_DECL(2)
+	DVR_MODE_FUNC_DECL(2)
+	DEMUX_TS_HEADER_FUNC_DECL(2)
+	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(2)
+#endif
+
+/*Show free descramblers count*/
+static ssize_t dsc_show_free_dscs(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	int fid, count;
+	ssize_t ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	count = 0;
+	for(fid = 0; fid < DSC_COUNT; fid++){
+		if(!dvb->dsc[fid].used)
+			count++;
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	ret = sprintf(buf, "%d\n", count);
+	return ret;
+}
+
+/*Show the async fifo source*/
+#define ASYNCFIFO_SOURCE_FUNC_DECL(i)  \
+static ssize_t asyncfifo##i##_show_source(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_asyncfifo *afifo = &dvb->asyncfifo[i];\
+	ssize_t ret = 0;\
+	char *src;\
+	switch(afifo->source) {\
+		case AM_DMX_0:\
+			src = "dmx0";\
+		break;\
+		case AM_DMX_1:\
+			src = "dmx1";\
+		break;\
+		case AM_DMX_2:\
+			src = "dmx2";\
+		break;\
+		default:\
+			src = "";\
+		break;\
+	}\
+	ret = sprintf(buf, "%s\n", src);\
+	return ret;\
+}\
+static ssize_t asyncfifo##i##_store_source(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    aml_dmx_id_t src = -1;\
+    \
+	if(!strncmp("dmx0", buf, 4)) {\
+    	src = AM_DMX_0;\
+    } else if(!strncmp("dmx1", buf, 4)) {\
+    	src = AM_DMX_1;\
+    } else if(!strncmp("dmx2", buf, 4)) {\
+    	src = AM_DMX_2;\
+    }\
+    if(src!=-1) {\
+    	aml_asyncfifo_hw_set_source(&aml_dvb_device.asyncfifo[i], src);\
+    }\
+    return size;\
+}
+
+#if ASYNCFIFO_COUNT>0
+	ASYNCFIFO_SOURCE_FUNC_DECL(0)
+#endif
+#if ASYNCFIFO_COUNT>1
+	ASYNCFIFO_SOURCE_FUNC_DECL(1)
+#endif
+
+/*Show the async fifo flush size*/
+#define ASYNCFIFO_FLUSHSIZE_FUNC_DECL(i)  \
+static ssize_t asyncfifo##i##_show_flush_size(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_asyncfifo *afifo = &dvb->asyncfifo[i];\
+	ssize_t ret = 0;\
+	ret = sprintf(buf, "%d\n", afifo->flush_size);\
+	return ret;\
+}\
+static ssize_t asyncfifo##i##_store_flush_size(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_asyncfifo *afifo = &dvb->asyncfifo[i];\
+	int fsize = (int)simple_strtol(buf, NULL, 10);\
+	if (fsize != afifo->flush_size) {\
+		afifo->flush_size = fsize;\
+    	aml_asyncfifo_hw_reset(&aml_dvb_device.asyncfifo[i]);\
+    }\
+    return size;\
+}
+
+#if ASYNCFIFO_COUNT>0
+	ASYNCFIFO_FLUSHSIZE_FUNC_DECL(0)
+#endif
+#if ASYNCFIFO_COUNT>1
+	ASYNCFIFO_FLUSHSIZE_FUNC_DECL(1)
+#endif
+
+
+extern void dmx_reset_hw_ex(struct aml_dvb *dvb, int reset_irq);
+
+/*Reset the Demux*/
+static ssize_t demux_do_reset(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	if(!strncmp("1", buf, 1)) {
+		struct aml_dvb *dvb = &aml_dvb_device;
+		unsigned long flags;
+
+		spin_lock_irqsave(&dvb->slock, flags);
+		pr_dbg("Reset demux, call dmx_reset_hw\n");
+		dmx_reset_hw_ex(dvb, 0);
+		spin_unlock_irqrestore(&dvb->slock, flags);
+	}
+
+	return size;
+}
+
+/*Show the Video PTS value*/
+static ssize_t demux_show_video_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", aml_dmx_get_video_pts(dvb));
+
+	return ret;
+}
+
+/*Show the Audio PTS value*/
+static ssize_t demux_show_audio_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", aml_dmx_get_audio_pts(dvb));
+
+	return ret;
+}
+
+/*Show the First Video PTS value*/
+static ssize_t demux_show_first_video_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", aml_dmx_get_first_video_pts(dvb));
+
+	return ret;
+}
+
+/*Show the First Audio PTS value*/
+static ssize_t demux_show_first_audio_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", aml_dmx_get_first_audio_pts(dvb));
+
+	return ret;
+}
+
+static ssize_t stb_show_hw_setting(struct class *class, struct class_attribute *attr, char *buf)
+{
+	int r, total = 0;
+	int i;
+	struct aml_dvb *dvb = &aml_dvb_device;
+	int invert, ctrl;
+
+	for(i=0; i<TS_IN_COUNT; i++){
+		struct aml_ts_input *ts = &dvb->ts[i];
+
+		if(ts->s2p_id != -1){
+			invert = dvb->s2p[ts->s2p_id].invert;
+		}else{
+			invert = 0;
+		}
+
+		ctrl = ts->control;
+
+		r = sprintf(buf, "ts%d %s control: 0x%x invert: 0x%x\n", i,
+				ts->mode==AM_TS_DISABLE?"disable":(ts->mode==AM_TS_SERIAL?"serial":"parallel"),
+				ctrl, invert);
+		buf += r;
+		total += r;
+	}
+
+	return total;
+}
+
+static ssize_t stb_store_hw_setting(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+	int id, ctrl, invert, r, mode;
+	char mname[32];
+	char pname[32];
+	unsigned long flags;
+	struct aml_ts_input *ts;
+	struct aml_dvb *dvb = &aml_dvb_device;
+
+	r = sscanf(buf, "%d %s %x %x", &id, mname, &ctrl, &invert);
+	if(r != 4)
+		return -EINVAL;
+
+	if(id < 0 || id >= TS_IN_COUNT)
+		return -EINVAL;
+
+	if((mname[0] == 's') || (mname[0] == 'S')){
+		sprintf(pname, "s_ts%d", id);
+		mode = AM_TS_SERIAL;
+	}else if((mname[0] == 'p') || (mname[0] == 'P')){
+		sprintf(pname, "p_ts%d", id);
+		mode = AM_TS_PARALLEL;
+	}else{
+		mode = AM_TS_DISABLE;
+	}
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	ts = &dvb->ts[id];
+
+	if((mode == AM_TS_SERIAL) && (ts->mode != AM_TS_SERIAL)){
+		int i;
+		int scnt = 0;
+
+		for(i = 0; i < TS_IN_COUNT; i++){
+			if(dvb->ts[i].s2p_id != -1){
+				scnt++;
+			}
+		}
+
+		if(scnt >= S2P_COUNT){
+			pr_error("no free s2p\n");
+		}else{
+			ts->s2p_id = scnt;
+		}
+	}
+
+	if((mode != AM_TS_SERIAL) || (ts->s2p_id != -1)){
+		if(ts->pinctrl){
+			devm_pinctrl_put(ts->pinctrl);
+			ts->pinctrl = NULL;
+		}
+
+		ts->pinctrl  = devm_pinctrl_get_select(&dvb->pdev->dev, pname);
+		ts->mode     = mode;
+		ts->control  = ctrl;
+
+		if(mode == AM_TS_SERIAL){
+			dvb->s2p[ts->s2p_id].invert = invert;
+		}else{
+			ts->s2p_id = -1;
+		}
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return count;
+}
+
+static struct file_operations dvb_dsc_fops = {
+        .owner          = THIS_MODULE,
+        .read           = NULL,
+        .write          = NULL,
+        .unlocked_ioctl = dvb_dsc_ioctl,
+        .open           = dvb_dsc_open,
+        .release        = dvb_dsc_release,
+        .poll           = NULL,
+};
+
+static struct dvb_device dvbdev_dsc = {
+        .priv           = NULL,
+        .users          = DSC_COUNT,
+        .writers        = DSC_COUNT,
+        .fops           = &dvb_dsc_fops,
+};
+
+static struct class_attribute aml_stb_class_attrs[] = {
+	__ATTR(hw_setting, S_IRUGO|S_IWUSR, stb_show_hw_setting, stb_store_hw_setting),
+	__ATTR(source,  S_IRUGO | S_IWUSR, stb_show_source, stb_store_source),
+	__ATTR(dsc_source,  S_IRUGO | S_IWUSR, dsc_show_source, dsc_store_source),
+	__ATTR(tso_source,  S_IRUGO | S_IWUSR, tso_show_source, tso_store_source),
+#define DEMUX_SOURCE_ATTR_DECL(i)\
+		__ATTR(demux##i##_source,  S_IRUGO | S_IWUSR, demux##i##_show_source, demux##i##_store_source)
+#define DEMUX_FREE_FILTERS_ATTR_DECL(i)\
+		__ATTR(demux##i##_free_filters,  S_IRUGO | S_IWUSR, demux##i##_show_free_filters, NULL)
+#define DEMUX_FILTER_USERS_ATTR_DECL(i)\
+		__ATTR(demux##i##_filter_users,  S_IRUGO | S_IWUSR, demux##i##_show_filter_users, demux##i##_store_filter_used)
+#define DVR_MODE_ATTR_DECL(i)\
+		__ATTR(dvr##i##_mode,  S_IRUGO | S_IWUSR, dvr##i##_show_mode, dvr##i##_store_mode)
+#define DEMUX_TS_HEADER_ATTR_DECL(i)\
+		__ATTR(demux##i##_ts_header,  S_IRUGO | S_IWUSR, demux##i##_show_ts_header, NULL)
+#define DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(i)\
+		__ATTR(demux##i##_channel_activity,  S_IRUGO | S_IWUSR, demux##i##_show_channel_activity, NULL)
+#if DMX_DEV_COUNT>0
+	DEMUX_SOURCE_ATTR_DECL(0),
+	DEMUX_FREE_FILTERS_ATTR_DECL(0),
+	DEMUX_FILTER_USERS_ATTR_DECL(0),
+	DVR_MODE_ATTR_DECL(0),
+	DEMUX_TS_HEADER_ATTR_DECL(0),
+	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(0),
+#endif
+#if DMX_DEV_COUNT>1
+	DEMUX_SOURCE_ATTR_DECL(1),
+	DEMUX_FREE_FILTERS_ATTR_DECL(1),
+	DEMUX_FILTER_USERS_ATTR_DECL(1),
+	DVR_MODE_ATTR_DECL(1),
+	DEMUX_TS_HEADER_ATTR_DECL(1),
+	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(1),
+#endif
+#if DMX_DEV_COUNT>2
+	DEMUX_SOURCE_ATTR_DECL(2),
+	DEMUX_FREE_FILTERS_ATTR_DECL(2),
+	DEMUX_FILTER_USERS_ATTR_DECL(2),
+	DVR_MODE_ATTR_DECL(2),
+	DEMUX_TS_HEADER_ATTR_DECL(2),
+	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(2),
+#endif
+#define ASYNCFIFO_SOURCE_ATTR_DECL(i)\
+		__ATTR(asyncfifo##i##_source,  S_IRUGO | S_IWUSR, asyncfifo##i##_show_source, asyncfifo##i##_store_source)
+#define ASYNCFIFO_FLUSHSIZE_ATTR_DECL(i)\
+		__ATTR(asyncfifo##i##_flush_size,  S_IRUGO | S_IWUSR, asyncfifo##i##_show_flush_size, asyncfifo##i##_store_flush_size)
+#if ASYNCFIFO_COUNT>0
+	ASYNCFIFO_SOURCE_ATTR_DECL(0),
+	ASYNCFIFO_FLUSHSIZE_ATTR_DECL(0),
+#endif
+#if ASYNCFIFO_COUNT>1
+	ASYNCFIFO_SOURCE_ATTR_DECL(1),
+	ASYNCFIFO_FLUSHSIZE_ATTR_DECL(1),
+#endif
+	__ATTR(demux_reset,  S_IRUGO | S_IWUSR, NULL, demux_do_reset),
+	__ATTR(video_pts,  S_IRUGO | S_IWUSR, demux_show_video_pts, NULL),
+	__ATTR(audio_pts,  S_IRUGO | S_IWUSR, demux_show_audio_pts, NULL),
+	__ATTR(first_video_pts,  S_IRUGO | S_IWUSR, demux_show_first_video_pts, NULL),
+	__ATTR(first_audio_pts,  S_IRUGO | S_IWUSR, demux_show_first_audio_pts, NULL),
+	__ATTR(free_dscs,  S_IRUGO | S_IWUSR, dsc_show_free_dscs, NULL),
+	__ATTR_NULL
+};
+
+static struct class aml_stb_class = {
+	.name = "stb",
+	.class_attrs = aml_stb_class_attrs,
+};
+
+extern int aml_regist_dmx_class(void);
+extern int aml_unregist_dmx_class(void);
+
+static int aml_dvb_probe(struct platform_device *pdev)
+{
+	struct aml_dvb *advb;
+	int i, ret = 0;
+	struct devio_aml_platform_data *pd_dvb;
+
+	pr_dbg("probe amlogic dvb driver\n");
+
+	switch_mod_gate_by_name("demux", 1);
+
+	advb = &aml_dvb_device;
+	memset(advb, 0, sizeof(aml_dvb_device));
+
+	spin_lock_init(&advb->slock);
+
+	advb->dev  = &pdev->dev;
+	advb->pdev = pdev;
+	advb->dsc_source=AM_DMX_MAX;
+	advb->stb_source=-1;
+	advb->tso_source=-1;
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		advb->dmx[i].dmx_irq = -1;
+		advb->dmx[i].dvr_irq = -1;
+	}
+
+#ifdef CONFIG_OF
+	if(pdev->dev.of_node){
+		int s2p_id = 0;
+
+		for (i=0; i<TS_IN_COUNT; i++){
+			char buf[32];
+			const char *str;
+			u32 value;
+
+			advb->ts[i].mode   = AM_TS_DISABLE;
+			advb->ts[i].s2p_id = -1;
+
+			snprintf(buf, sizeof(buf), "ts%d", i);
+			ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+			if(!ret){
+				if(!strcmp(str, "serial")){
+					pr_dbg("%s: serial\n", buf);
+
+					if(s2p_id >= S2P_COUNT){
+						pr_error("no free s2p\n");
+					}else{
+						snprintf(buf, sizeof(buf), "s_ts%d", i);
+						advb->ts[i].mode    = AM_TS_SERIAL;
+						advb->ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
+						advb->ts[i].s2p_id  = s2p_id;
+
+						s2p_id++;
+					}
+				}else if(!strcmp(str, "parallel")){
+					pr_dbg("%s: parallel\n", buf);
+					snprintf(buf, sizeof(buf), "p_ts%d", i);
+					advb->ts[i].mode    = AM_TS_PARALLEL;
+					advb->ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
+				}else{
+					advb->ts[i].mode    = AM_TS_DISABLE;
+					advb->ts[i].pinctrl = NULL;
+				}
+			}
+
+			snprintf(buf, sizeof(buf), "ts%d_control", i);
+			ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+			if(!ret){
+				pr_dbg("%s: 0x%x\n", buf, value);
+				advb->ts[i].control = value;
+			}
+
+			if(advb->ts[i].s2p_id != -1){
+				snprintf(buf, sizeof(buf), "ts%d_invert", i);
+				ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+				if(!ret){
+					pr_dbg("%s: 0x%x\n", buf, value);
+					advb->s2p[advb->ts[i].s2p_id].invert = value;
+				}
+			}
+		}
+	}
+#endif
+
+	pd_dvb = (struct devio_aml_platform_data*)advb->dev->platform_data;
+
+	ret = dvb_register_adapter(&advb->dvb_adapter, CARD_NAME, THIS_MODULE, advb->dev, adapter_nr);
+	if (ret < 0) {
+		return ret;
+	}
+
+	for (i=0; i<DMX_DEV_COUNT; i++)
+		advb->dmx[i].id = -1;
+
+	advb->dvb_adapter.priv = advb;
+	dev_set_drvdata(advb->dev, advb);
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		if ((ret=aml_dvb_dmx_init(advb, &advb->dmx[i], i))<0) {
+			goto error;
+		}
+	}
+
+	/*Register descrambler device*/
+	ret = dvb_register_device(&advb->dvb_adapter, &advb->dsc_dev,
+                                   &dvbdev_dsc, advb, DVB_DEVICE_DSC);
+	if(ret<0) {
+		goto error;
+	}
+
+	/*Init the async fifos*/
+	for (i=0; i<ASYNCFIFO_COUNT; i++) {
+		if ((ret=aml_dvb_asyncfifo_init(advb, &advb->asyncfifo[i], i))<0) {
+			goto error;
+		}
+	}
+
+	aml_regist_dmx_class();
+
+	if(class_register(&aml_stb_class)<0) {
+		pr_error("register class error\n");
+		goto error;
+	}
+
+	//rsj//tsdemux_set_ops(&aml_tsdemux_ops);
+
+	return ret;
+error:
+	for (i=0; i<ASYNCFIFO_COUNT; i++) {
+		if (advb->asyncfifo[i].id!=-1) {
+			aml_dvb_asyncfifo_release(advb, &advb->asyncfifo[i]);
+		}
+	}
+
+	if(advb->dsc_dev) {
+		dvb_unregister_device(advb->dsc_dev);
+	}
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		if (advb->dmx[i].id!=-1) {
+			aml_dvb_dmx_release(advb, &advb->dmx[i]);
+		}
+	}
+	dvb_unregister_adapter(&advb->dvb_adapter);
+
+	return ret;
+}
+
+static int aml_dvb_remove(struct platform_device *pdev)
+{
+	struct aml_dvb *advb = (struct aml_dvb*)dev_get_drvdata(&pdev->dev);
+	int i;
+
+//rsj//	tsdemux_set_ops(NULL);
+
+	aml_unregist_dmx_class();
+	class_unregister(&aml_stb_class);
+
+	dvb_unregister_device(advb->dsc_dev);
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		aml_dvb_dmx_release(advb, &advb->dmx[i]);
+	}
+	dvb_unregister_adapter(&advb->dvb_adapter);
+
+	for (i=0; i<TS_IN_COUNT; i++){
+		if(advb->ts[i].pinctrl)
+			devm_pinctrl_put(advb->ts[i].pinctrl);
+	}
+
+	switch_mod_gate_by_name("demux", 0);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id aml_dvb_dt_match[]={
+	{
+		.compatible = "amlogic,dvb",
+	},
+	{},
+};
+#endif /*CONFIG_OF*/
+
+static struct platform_driver aml_dvb_driver = {
+	.probe		= aml_dvb_probe,
+	.remove		= aml_dvb_remove,
+	.driver		= {
+		.name	= "amlogic-dvb",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = aml_dvb_dt_match,
+#endif
+	}
+};
+
+static int __init aml_dvb_init(void)
+{
+	pr_dbg("aml dvb init\n");
+	return platform_driver_register(&aml_dvb_driver);
+}
+
+static void __exit aml_dvb_exit(void)
+{
+	pr_dbg("aml dvb exit\n");
+	platform_driver_unregister(&aml_dvb_driver);
+}
+
+/*Get the STB source demux*/
+static struct aml_dmx* get_stb_dmx(void)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx = NULL;
+	int i;
+
+	switch(dvb->stb_source){
+		case AM_TS_SRC_DMX0:
+			dmx = &dvb->dmx[0];
+		break;
+		case AM_TS_SRC_DMX1:
+			dmx = &dvb->dmx[1];
+		break;
+		case AM_TS_SRC_DMX2:
+			dmx = &dvb->dmx[2];
+		break;
+		default:
+			for(i=0; i<DMX_DEV_COUNT; i++) {
+				dmx = &dvb->dmx[i];
+				if(dmx->source==dvb->stb_source) {
+					return dmx;
+				}
+			}
+		break;
+	}
+
+	return dmx;
+}
+
+static int aml_tsdemux_reset(void)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	if(dvb->reset_flag) {
+		dvb->reset_flag = 0;
+		dmx_reset_hw_ex(dvb, 0);
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+static int aml_tsdemux_set_reset_flag(void)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dvb->reset_flag = 1;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+
+}
+
+/*Add the amstream irq handler*/
+static int aml_tsdemux_request_irq(irq_handler_t handler, void *data)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+	if(dmx) {
+		dmx->irq_handler = handler;
+		dmx->irq_data = data;
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+/*Free the amstream irq handler*/
+static int aml_tsdemux_free_irq(void)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+	if(dmx) {
+		dmx->irq_handler = NULL;
+		dmx->irq_data = NULL;
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+/*Reset the video PID*/
+static int aml_tsdemux_set_vid(int vpid)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dmx = get_stb_dmx();
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dmx->slock, flags);
+
+		if(dmx->vid_chan!=-1) {
+			dmx_free_chan(dmx, dmx->vid_chan);
+			dmx->vid_chan = -1;
+		}
+
+		if((vpid>=0) && (vpid<0x1FFF)) {
+			dmx->vid_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_VIDEO, vpid);
+			if(dmx->vid_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dmx->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+/*Reset the audio PID*/
+static int aml_tsdemux_set_aid(int apid)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dmx = get_stb_dmx();
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dmx->slock, flags);
+
+		if(dmx->aud_chan!=-1) {
+			dmx_free_chan(dmx, dmx->aud_chan);
+			dmx->aud_chan = -1;
+		}
+
+		if((apid>=0) && (apid<0x1FFF)) {
+			dmx->aud_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_AUDIO, apid);
+			if(dmx->aud_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dmx->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+/*Reset the subtitle PID*/
+static int aml_tsdemux_set_sid(int spid)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dmx = get_stb_dmx();
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dmx->slock, flags);
+
+		if(dmx->sub_chan!=-1) {
+			dmx_free_chan(dmx, dmx->sub_chan);
+			dmx->sub_chan = -1;
+		}
+
+		if((spid>=0) && (spid<0x1FFF)) {
+			dmx->sub_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_SUBTITLE, spid);
+			if(dmx->sub_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dmx->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+static int aml_tsdemux_set_skipbyte(int skipbyte)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	aml_dmx_set_skipbyte(dvb, skipbyte);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+static int aml_tsdemux_set_demux(int id)
+{
+	struct aml_dvb *dvb = &aml_dvb_device;
+
+	aml_dmx_set_demux(dvb, id);
+	return 0;
+}
+
+module_init(aml_dvb_init);
+module_exit(aml_dvb_exit);
+
+MODULE_DESCRIPTION("driver for the AMLogic DVB card");
+MODULE_AUTHOR("AMLOGIC");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/amlogic/dvb_tv/aml_dvb.h b/drivers/amlogic/dvb_tv/aml_dvb.h
new file mode 100755
index 000000000000..3a1628be482b
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/aml_dvb.h
@@ -0,0 +1,261 @@
+#ifndef _AML_DVB_H_
+#define _AML_DVB_H_
+
+#include <linux/interrupt.h>
+#include <linux/socket.h>
+#include <linux/netdevice.h>
+#include <linux/i2c.h>
+
+#include <uapi/linux/dvb/video.h>
+#include <uapi/linux/dvb/audio.h>
+#include <uapi/linux/dvb/dmx.h>
+#include <uapi/linux/dvb/ca.h>
+#include <uapi/linux/dvb/osd.h>
+#include <uapi/linux/dvb/net.h>
+#include <uapi/linux/dvb/frontend.h>
+
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+
+#include "../../media/dvb-core/dvbdev.h"
+#include "../../media/dvb-core/demux.h"
+#include "../../media/dvb-core/dvb_demux.h"
+#include "../../media/dvb-core/dmxdev.h"
+#include "../../media/dvb-core/dvb_filter.h"
+#include "../../media/dvb-core/dvb_net.h"
+#include "../../media/dvb-core/dvb_ringbuffer.h"
+#include "../../media/dvb-core/dvb_frontend.h"
+
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+
+#define TS_IN_COUNT       3
+#define S2P_COUNT         2
+
+#define DMX_DEV_COUNT     3
+#define FE_DEV_COUNT      2
+#define CHANNEL_COUNT     31
+#define FILTER_COUNT      31
+#define FILTER_LEN        15
+#define DSC_COUNT         8
+#define SEC_BUF_GRP_COUNT 4
+#define SEC_BUF_BUSY_SIZE 4
+#define SEC_BUF_COUNT     (SEC_BUF_GRP_COUNT*8)
+#define ASYNCFIFO_COUNT 2
+
+typedef enum{
+	AM_DMX_0=0,
+	AM_DMX_1,
+	AM_DMX_2,
+	AM_DMX_MAX,
+}aml_dmx_id_t;
+
+typedef enum {
+	AM_TS_SRC_TS0,
+	AM_TS_SRC_TS1,
+	AM_TS_SRC_TS2,
+	AM_TS_SRC_S_TS0,
+	AM_TS_SRC_S_TS1,
+	AM_TS_SRC_S_TS2,
+	AM_TS_SRC_HIU,
+	AM_TS_SRC_DMX0,
+	AM_TS_SRC_DMX1,
+	AM_TS_SRC_DMX2
+} aml_ts_source_t;
+
+struct aml_sec_buf {
+	unsigned long        addr;
+	int                  len;
+};
+
+struct aml_channel {
+	int                  type;
+	dmx_ts_pes_t     pes_type;
+	int                  pid;
+	int                  used;
+	int                  filter_count;
+	struct dvb_demux_feed     *feed;
+	struct dvb_demux_feed     *dvr_feed;
+};
+
+struct aml_filter {
+	int                  chan_id;
+	int                  used;
+	struct dmx_section_filter *filter;
+	u8                   value[FILTER_LEN];
+	u8                   maskandmode[FILTER_LEN];
+	u8                   maskandnotmode[FILTER_LEN];
+	u8                   neq;
+};
+
+struct aml_dsc {
+	int                  pid;
+	u8                   even[8];
+	u8                   odd[8];
+	int                  used;
+	int                  set;
+	int                  id;
+	struct aml_dvb      *dvb;
+};
+
+struct aml_dmx {
+	struct dvb_demux     demux;
+	struct dmxdev        dmxdev;
+	int                  id;
+	int                  feed_count;
+	int                  chan_count;
+	aml_ts_source_t      source;
+	int                  init;
+	int                  record;
+	struct dmx_frontend  hw_fe[DMX_DEV_COUNT];
+	struct dmx_frontend  mem_fe;
+	struct dvb_net       dvb_net;
+	spinlock_t           slock;
+	int                  dmx_irq;
+	int                  dvr_irq;
+	struct tasklet_struct     dmx_tasklet;
+	struct tasklet_struct     dvr_tasklet;
+	unsigned long        sec_pages;
+	unsigned long        sec_pages_map;
+	int                  sec_total_len;
+	struct aml_sec_buf   sec_buf[SEC_BUF_COUNT];
+	unsigned long        pes_pages;
+	unsigned long        pes_pages_map;
+	int                  pes_buf_len;
+	unsigned long        sub_pages;
+	unsigned long        sub_pages_map;
+	int                  sub_buf_len;
+	struct aml_channel   channel[CHANNEL_COUNT];
+	struct aml_filter    filter[FILTER_COUNT];
+	irq_handler_t        irq_handler;
+	void                *irq_data;
+	int                  aud_chan;
+	int                  vid_chan;
+	int                  sub_chan;
+	u32                  section_busy[SEC_BUF_BUSY_SIZE];
+	struct dvb_frontend *fe;
+	int                  int_check_count;
+	u32                  int_check_time;
+	int                  in_tune;
+	int                  error_check;
+	int                  dump_ts_select;
+	int                  sec_buf_watchdog_count[SEC_BUF_COUNT];
+
+	int                  demux_filter_user;
+};
+
+struct aml_asyncfifo {
+	int	id;
+	int	init;
+	int	asyncfifo_irq;
+	aml_dmx_id_t	source;
+	unsigned long	pages;
+	unsigned long   pages_map;
+	int	buf_len;
+	int	buf_toggle;
+	int buf_read;
+	int flush_size;
+	struct tasklet_struct     asyncfifo_tasklet;
+	spinlock_t           slock;
+	struct aml_dvb *dvb;
+};
+
+enum{
+	AM_TS_DISABLE,
+	AM_TS_PARALLEL,
+	AM_TS_SERIAL
+};
+
+struct aml_ts_input {
+	int                  mode;
+	struct pinctrl      *pinctrl;
+	int                  control;
+	int                  s2p_id;
+};
+
+struct aml_s2p {
+	int    invert;
+};
+
+struct aml_dvb {
+	struct dvb_device    dvb_dev;
+	struct aml_ts_input  ts[TS_IN_COUNT];
+	struct aml_s2p       s2p[S2P_COUNT];
+	struct aml_dmx       dmx[DMX_DEV_COUNT];
+	struct aml_dsc       dsc[DSC_COUNT];
+	struct aml_asyncfifo asyncfifo[ASYNCFIFO_COUNT];
+	struct dvb_device   *dsc_dev;
+	struct dvb_adapter   dvb_adapter;
+	struct device       *dev;
+	struct platform_device *pdev;
+	aml_ts_source_t      stb_source;
+	aml_ts_source_t      dsc_source;
+	aml_ts_source_t      tso_source;
+	int                  dmx_init;
+	int                  reset_flag;
+	spinlock_t           slock;
+	struct timer_list    watchdog_timer;
+};
+
+
+/*AMLogic demux interface*/
+extern int aml_dmx_hw_init(struct aml_dmx *dmx);
+extern int aml_dmx_hw_deinit(struct aml_dmx *dmx);
+extern int aml_dmx_hw_start_feed(struct dvb_demux_feed *dvbdmxfeed);
+extern int aml_dmx_hw_stop_feed(struct dvb_demux_feed *dvbdmxfeed);
+extern int aml_dmx_hw_set_source(struct dmx_demux* demux, dmx_source_t src);
+extern int aml_stb_hw_set_source(struct aml_dvb *dvb, dmx_source_t src);
+extern int aml_dsc_hw_set_source(struct aml_dvb *dvb, aml_ts_source_t src);
+extern int aml_tso_hw_set_source(struct aml_dvb *dvb, dmx_source_t src);
+extern int aml_dmx_set_skipbyte(struct aml_dvb *dvb, int skipbyte);
+extern int aml_dmx_set_demux(struct aml_dvb *dvb, int id);
+extern int aml_dmx_hw_set_dump_ts_select(struct dmx_demux* demux, int dump_ts_select);
+
+extern int  dmx_alloc_chan(struct aml_dmx *dmx, int type, int pes_type, int pid);
+extern void dmx_free_chan(struct aml_dmx *dmx, int cid);
+
+extern int dmx_get_ts_serial(aml_ts_source_t src);
+
+/*AMLogic dsc interface*/
+extern int dsc_set_pid(struct aml_dsc *dsc, int pid);
+extern int dsc_set_key(struct aml_dsc *dsc, int type, u8 *key);
+extern int dsc_release(struct aml_dsc *dsc);
+
+/*AMLogic ASYNC FIFO interface*/
+extern int aml_asyncfifo_hw_init(struct aml_asyncfifo *afifo);
+extern int aml_asyncfifo_hw_deinit(struct aml_asyncfifo *afifo);
+extern int aml_asyncfifo_hw_set_source(struct aml_asyncfifo *afifo, aml_dmx_id_t src);
+extern int aml_asyncfifo_hw_reset(struct aml_asyncfifo *afifo);
+
+/*Get the Audio & Video PTS*/
+extern u32 aml_dmx_get_video_pts(struct aml_dvb *dvb);
+extern u32 aml_dmx_get_audio_pts(struct aml_dvb *dvb);
+extern u32 aml_dmx_get_first_video_pts(struct aml_dvb *dvb);
+extern u32 aml_dmx_get_first_audio_pts(struct aml_dvb *dvb);
+
+/*Get the DVB device*/
+extern struct aml_dvb* aml_get_dvb_device(void);
+
+/*Demod interface*/
+extern void aml_dmx_register_frontend(aml_ts_source_t src, struct dvb_frontend *fe);
+extern void aml_dmx_before_retune(aml_ts_source_t src, struct dvb_frontend *fe);
+extern void aml_dmx_after_retune(aml_ts_source_t src, struct dvb_frontend *fe);
+extern void aml_dmx_start_error_check(aml_ts_source_t src, struct dvb_frontend *fe);
+extern int  aml_dmx_stop_error_check(aml_ts_source_t src, struct dvb_frontend *fe);
+
+struct devio_aml_platform_data {
+	int (*io_setup)(void*);
+	int (*io_cleanup)(void*);
+	int (*io_power)(void *, int enable);
+	int (*io_reset)(void *, int enable);
+};
+
+
+#endif
+
diff --git a/drivers/amlogic/dvb_tv/aml_fe.c b/drivers/amlogic/dvb_tv/aml_fe.c
new file mode 100755
index 000000000000..800dccecd7f2
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/aml_fe.c
@@ -0,0 +1,1895 @@
+/*
+ * AMLOGIC DVB frontend driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+//#include <linux/videodev2.h>
+//s#include <linux/pinctrl/consumer.h>
+//#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include "aml_fe.h"
+
+#define pr_dbg(fmt, args...)\
+	do{\
+		if(debug_fe)\
+			printk("FE: " fmt, ## args);\
+	}while(0)
+#define pr_error(fmt, args...) printk("FE: " fmt, ## args)
+
+MODULE_PARM_DESC(debug_fe, "\n\t\t Enable frontend debug information");
+static int debug_fe = 1;
+module_param(debug_fe, int, S_IRUGO);
+
+#define AFC_BEST_LOCK      50
+#define ATV_AFC_1_0MHZ   1000000
+#define ATV_AFC_2_0MHZ	 2000000
+
+#define AML_FE_MAX_RES		50
+
+static int slow_mode=0;
+module_param(slow_mode,int,0644);
+MODULE_DESCRIPTION("search the channel by slow_mode,by add +1MHz\n");
+
+static struct aml_fe_drv *tuner_drv_list = NULL;
+static struct aml_fe_drv *atv_demod_drv_list = NULL;
+static struct aml_fe_drv *dtv_demod_drv_list = NULL;
+static struct aml_fe_man  fe_man;
+
+#ifndef CONFIG_OF
+static struct platform_device *g_aml_fe_pdev = NULL;
+static u32	 aml_fe_num_resources = 0;
+static struct resource aml_fe_resource[AML_FE_MAX_RES];
+static char *aml_fe_buf = NULL;
+static size_t aml_fe_size;
+#endif
+
+static u32 aml_fe_suspended = 0;
+
+static DEFINE_SPINLOCK(lock);
+static int aml_fe_afc_closer(struct dvb_frontend *fe,int minafcfreq,int maxafcfqreq);
+
+typedef int (*hook_func_t)(void);
+void aml_fe_hook_cvd(hook_func_t atv_mode,hook_func_t cvd_hv_lock)
+{
+//	aml_fe_hook_atv_status = atv_mode;
+//	aml_fe_hook_hv_lock = cvd_hv_lock;
+//	printk("[aml_fe]%s \n",__func__);
+}
+
+
+static struct aml_fe_drv** aml_get_fe_drv_list(aml_fe_dev_type_t type)
+{
+	switch(type){
+		case AM_DEV_TUNER:
+			return &tuner_drv_list;
+		case AM_DEV_ATV_DEMOD:
+			return &atv_demod_drv_list;
+		case AM_DEV_DTV_DEMOD:
+			return &dtv_demod_drv_list;
+		default:
+			return NULL;
+	}
+}
+
+int aml_register_fe_drv(aml_fe_dev_type_t type, struct aml_fe_drv *drv)
+{
+	if(drv){
+		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
+		unsigned long flags;
+
+		spin_lock_irqsave(&lock, flags);
+
+		drv->next = *list;
+		*list = drv;
+
+		drv->ref = 0;
+
+		spin_unlock_irqrestore(&lock, flags);
+	}
+
+	return 0;
+}
+
+int aml_unregister_fe_drv(aml_fe_dev_type_t type, struct aml_fe_drv *drv)
+{
+	int ret = 0;
+
+	if(drv){
+		struct aml_fe_drv *pdrv, *pprev;
+		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
+		unsigned long flags;
+
+		spin_lock_irqsave(&lock, flags);
+
+		if(drv->ref){
+			for(pprev = NULL, pdrv = *list;
+				pdrv;
+				pprev = pdrv, pdrv = pdrv->next){
+				if(pdrv == drv){
+					if(pprev)
+						pprev->next = pdrv->next;
+					else
+						*list = pdrv->next;
+					break;
+				}
+			}
+		}else{
+			pr_error("fe driver %d is inused\n", drv->id);
+			ret = -1;
+		}
+
+		spin_unlock_irqrestore(&lock, flags);
+	}
+
+	return ret;
+}
+
+int aml_fe_analog_set_frontend(struct dvb_frontend* fe)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct analog_parameters p;
+	int ret = -1;
+
+	p.frequency  = c->frequency;
+	p.soundsys   = c->analog.soundsys;
+	p.audmode    = c->analog.audmode;
+	p.std        = c->analog.std;
+	p.reserved   = c->analog.reserved;
+
+	/*set tuner&ademod such as philipse tuner*/
+	if(fe->ops.analog_ops.set_params){
+		fe->ops.analog_ops.set_params(fe);
+		ret = 0;
+	}
+	if(fe->ops.tuner_ops.set_params){
+		ret = fe->ops.tuner_ops.set_params(fe);
+	}
+
+	if(ret == 0){
+		afe->params.frequency = c->frequency;
+		afe->params.inversion = c->inversion;
+		afe->params.analog  = c->analog;
+	}
+
+	return ret;
+}
+
+static int aml_fe_analog_get_frontend(struct dvb_frontend* fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct aml_fe *afe = fe->demodulator_priv;
+
+	p->frequency = afe->params.frequency;
+	pr_dbg("[%s] params.frequency:%d\n",__func__,p->frequency);
+
+	return 0;
+}
+
+static int aml_fe_analog_read_status(struct dvb_frontend* fe, fe_status_t* status)
+{
+    int ret = 0;
+    if(!status)
+        return -1;
+    /*atv only demod locked is vaild*/
+    if(fe->ops.analog_ops.get_status)
+	    fe->ops.analog_ops.get_status(fe, status);
+    else if(fe->ops.tuner_ops.get_status)
+        ret = fe->ops.tuner_ops.get_status(fe, status);
+
+    return ret;
+}
+
+static int aml_fe_analog_read_signal_strength(struct dvb_frontend* fe, u16 *strength)
+{
+	int ret = -1;
+	u16 s;
+	s=0;
+	if(fe->ops.analog_ops.has_signal){
+
+		fe->ops.analog_ops.has_signal(fe);
+		*strength = s;
+		ret = 0;
+	}else if(fe->ops.tuner_ops.get_rf_strength){
+		ret = fe->ops.tuner_ops.get_rf_strength(fe, strength);
+	}
+
+	return ret;
+}
+static int aml_fe_analog_read_signal_snr(struct dvb_frontend* fe, u16 *snr)
+{
+    if(!snr)
+    {
+        pr_error("[aml_fe..]%s null pointer error.\n",__func__);
+        return -1;
+    }
+    if(fe->ops.analog_ops.get_snr)
+        *snr = (unsigned short)fe->ops.analog_ops.get_snr(fe);
+    return 0;
+}
+static enum dvbfe_algo aml_fe_get_analog_algo(struct dvb_frontend *dev)
+{
+        return DVBFE_ALGO_CUSTOM;
+}
+#if 0
+//+1 M or the step from api,then get tuner lock status,if lock get demod lock
+  // status,if lock update the analog_parameter
+static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
+{
+	fe_status_t tuner_state;
+	fe_status_t ade_state;
+	int minafcfreq, maxafcfreq;
+//set the afc_range and start freq
+	if(p->u.analog.afc_range==0)
+		p->u.analog.afc_range=ATV_AFC_1_0MHZ;
+	tuner_state = FE_TIMEDOUT;
+	ade_state   = FE_TIMEDOUT;
+	minafcfreq  = p->frequency  - p->u.analog.afc_range;
+	maxafcfreq = p->frequency + p->u.analog.afc_range;
+	pr_dbg("[%s] is working,afc_range=%d.\n",__func__,p->u.analog.afc_range);
+//from the min freq start
+	p->frequency = minafcfreq;
+	if( fe->ops.set_frontend(fe, p)){
+		pr_error("[%s]the func of set_param err.\n",__func__);
+		return DVBFE_ALGO_SEARCH_FAILED;
+	}
+//atuo bettween afc range
+	if(likely(fe->ops.tuner_ops.get_status && fe->ops.analog_ops.get_status && fe->ops.set_frontend))
+	{
+		 while( p->frequency<=maxafcfreq)
+		{
+			pr_dbg("[%s] p->frequency=[%d] is processing\n",__func__,p->frequency);
+			fe->ops.tuner_ops.get_status(fe, &tuner_state);
+			fe->ops.analog_ops.get_status(fe, &ade_state);
+			if(FE_HAS_LOCK==ade_state && FE_HAS_LOCK==tuner_state){
+				if(aml_fe_afc_closer(fe,p,minafcfreq,maxafcfreq)<0){
+					return  DVBFE_ALGO_SEARCH_FAILED;
+				}
+
+			pr_dbg("[%s] afc end  :p->frequency=[%d] has lock,search success.\n",__func__,p->frequency);
+	            	return DVBFE_ALGO_SEARCH_SUCCESS;
+
+			}
+ 			else
+			{
+				pr_dbg("[%s] freq is[%d] unlock\n",__func__,p->frequency);
+				p->frequency +=  ATV_AFC_1_0MHZ;
+				if(p->frequency >maxafcfreq)
+				{
+					p->frequency -=  ATV_AFC_1_0MHZ;
+					pr_dbg("[%s] p->frequency=[%d] over maxafcfreq=[%d].search failed.\n",__func__,p->frequency,maxafcfreq);
+					return DVBFE_ALGO_SEARCH_FAILED;
+				}
+				if( fe->ops.set_frontend(fe, p)){
+					pr_error("[%s] the func of set_frontend err.\n",__func__);
+					return  DVBFE_ALGO_SEARCH_FAILED;
+				}
+			}
+		}
+        }
+
+	   return DVBFE_ALGO_SEARCH_FAILED;
+}
+#endif
+//this func set two ways to search the channel
+//1.if the afc_range>1Mhz,set the freq  more than once
+//2. if the afc_range<=1MHz,set the freq only once ,on the mid freq
+
+static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	fe_status_t tuner_state;
+	fe_status_t ade_state;
+	int minafcfreq, maxafcfreq;
+	int frist_step;
+	int afc_step;
+	struct aml_fe *fee;
+	fee = fe->demodulator_priv;
+
+	if(c->analog.flag & ANALOG_FLAG_MANUL_SCAN){
+		pr_dbg("[%s]:set the mannul scan mode and current freq [%d]\n",__func__,c->frequency);
+		if( fe->ops.set_frontend(fe)){
+		    pr_dbg("[%s]the func of set_param err.\n",__func__);
+		    return DVBFE_ALGO_SEARCH_FAILED;
+		}
+		fe->ops.tuner_ops.get_status(fe, &tuner_state);
+		fe->ops.analog_ops.get_status(fe, &ade_state);
+		if(FE_HAS_LOCK==ade_state && FE_HAS_LOCK==tuner_state){
+		    pr_dbg("[%s] manul scan mode:p->frequency=[%d] has lock,search success.\n",__func__,c->frequency);
+		    return DVBFE_ALGO_SEARCH_SUCCESS;
+		}
+		else
+		    return DVBFE_ALGO_SEARCH_FAILED;
+	}
+	else if(c->analog.afc_range==0)
+	{
+		pr_dbg("[%s]:afc_range==0,skip the search\n",__func__);
+		return DVBFE_ALGO_SEARCH_FAILED;
+	}
+
+//set the frist_step
+	if(c->analog.afc_range>ATV_AFC_1_0MHZ)
+		frist_step=ATV_AFC_1_0MHZ;
+	else
+		frist_step=c->analog.afc_range;
+//set the afc_range and start freq
+	tuner_state = FE_TIMEDOUT;
+	ade_state   = FE_TIMEDOUT;
+	minafcfreq  = c->frequency  - c->analog.afc_range;
+	maxafcfreq  = c->frequency + c->analog.afc_range;
+	pr_dbg("[%s] is working,afc_range=%d,the received freq=[%d]\n",__func__,c->analog.afc_range,c->frequency);
+	pr_dbg("the tuner type is [%d]\n",fee->tuner->drv->id);
+//from the min freq start,and set the afc_step
+	if(slow_mode || fee->tuner->drv->id ==  AM_TUNER_FQ1216 || AM_TUNER_HTM == fee->tuner->drv->id ){
+		pr_dbg("[%s]this is slow mode to search the channel\n",__func__);
+		c->frequency = minafcfreq;
+		afc_step=ATV_AFC_1_0MHZ;
+	}
+	else if(!slow_mode && fee->tuner->drv->id== AM_TUNER_SI2176){
+		c->frequency = minafcfreq+frist_step;
+		afc_step=ATV_AFC_2_0MHZ;
+	}
+	else{
+		pr_dbg("[%s]this is ukown tuner type and on slow_mode to search the channel\n",__func__);
+		c->frequency = minafcfreq;
+		afc_step=ATV_AFC_1_0MHZ;
+	}
+	if( fe->ops.set_frontend(fe)){
+		pr_error("[%s]the func of set_param err.\n",__func__);
+		return DVBFE_ALGO_SEARCH_FAILED;
+	}
+//atuo bettween afc range
+	if(likely(fe->ops.tuner_ops.get_status && fe->ops.analog_ops.get_status && fe->ops.set_frontend))
+	{
+		 while( c->frequency<=maxafcfreq)
+		{
+			pr_dbg("[%s] p->frequency=[%d] is processing\n",__func__,c->frequency);
+			fe->ops.tuner_ops.get_status(fe, &tuner_state);
+			fe->ops.analog_ops.get_status(fe, &ade_state);
+			if(FE_HAS_LOCK==ade_state && FE_HAS_LOCK==tuner_state){
+				if(aml_fe_afc_closer(fe,minafcfreq,maxafcfreq)==0){
+					pr_dbg("[%s] afc end  :p->frequency=[%d] has lock,search success.\n",__func__,c->frequency);
+	            	return DVBFE_ALGO_SEARCH_SUCCESS;
+				}
+			}
+			pr_dbg("[%s] freq is[%d] unlock\n",__func__,c->frequency);
+			c->frequency +=  afc_step;
+			if(c->frequency >maxafcfreq)
+			{
+				c->frequency -=  afc_step;
+				pr_dbg("[%s] p->frequency=[%d] over maxafcfreq=[%d].search failed.\n",__func__,c->frequency,maxafcfreq);
+				return DVBFE_ALGO_SEARCH_FAILED;
+			}
+			if( fe->ops.set_frontend(fe)){
+				pr_error("[%s] the func of set_frontend err.\n",__func__);
+				return  DVBFE_ALGO_SEARCH_FAILED;
+			}
+		}
+        }
+
+	   return DVBFE_ALGO_SEARCH_FAILED;
+}
+
+static int aml_fe_afc_closer(struct dvb_frontend *fe,int minafcfreq,int maxafcfqreq)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int afc = 100;
+	__u32 set_freq;
+	int count=10;
+
+	//do the auto afc make sure the afc<50k or the range from api
+	if(fe->ops.analog_ops.get_afc &&fe->ops.set_frontend){
+		set_freq=c->frequency;
+
+		while(afc > AFC_BEST_LOCK){
+
+			fe->ops.analog_ops.get_afc(fe);
+			c->frequency += afc*1000;
+
+			if(unlikely(c->frequency>maxafcfqreq) ){
+				 pr_dbg("[%s]:[%d] is exceed maxafcfqreq[%d]\n",__func__,c->frequency,maxafcfqreq);
+				 c->frequency=set_freq;
+				 return -1;
+			}
+			if( unlikely(c->frequency<minafcfreq)){
+				 pr_dbg("[%s]:[%d ] is exceed minafcfreq[%d]\n",__func__,c->frequency,minafcfreq);
+				 c->frequency=set_freq;
+				 return -1;
+			}
+			if(likely(!(count--))){
+				 pr_dbg("[%s]:exceed the afc count\n",__func__);
+				 c->frequency=set_freq;
+				 return -1;
+			}
+
+			fe->ops.set_frontend(fe);
+
+			pr_dbg("[aml_fe..]%s get afc %d khz, freq %u.\n",__func__,afc, c->frequency);
+		}
+
+		pr_dbg("[aml_fe..]%s get afc %d khz done, freq %u.\n",__func__,afc, c->frequency);
+	}
+
+    return 0;
+}
+
+
+
+static int aml_fe_set_mode(struct dvb_frontend *dev, fe_type_t type)
+{
+	struct aml_fe *fe;
+	aml_fe_mode_t mode;
+	unsigned long flags;
+	fe = dev->demodulator_priv;
+	//type=FE_ATSC;
+	switch(type){
+		case FE_QPSK:
+			mode = AM_FE_QPSK;
+			pr_dbg("set mode -> QPSK\n");
+			break;
+		case FE_QAM:
+			pr_dbg("set mode -> QAM\n");
+			mode = AM_FE_QAM;
+			break;
+		case FE_OFDM:
+			pr_dbg("set mode -> OFDM\n");
+			mode = AM_FE_OFDM;
+			break;
+		case FE_ATSC:
+			pr_dbg("set mode -> ATSC\n");
+			mode = AM_FE_ATSC;
+			break;
+		case FE_ISDBT:
+			pr_dbg("set mode -> ISDBT\n");
+			mode = AM_FE_ISDBT;
+			break;
+		case FE_DTMB:
+			pr_dbg("set mode -> DTMB\n");
+			mode = AM_FE_DTMB;
+			break;
+		case FE_ANALOG:
+			pr_dbg("set mode -> ANALOG\n");
+			mode = AM_FE_ANALOG;
+			break;
+		default:
+			pr_error("illegal fe type %d\n", type);
+			return -1;
+	}
+
+	if(fe->mode == mode)
+	{
+		pr_dbg("[%s]:the mode is not change!!!!\n",__func__);
+		return 0;
+	}
+
+	if(fe->mode != AM_FE_UNKNOWN){
+		if(fe->dtv_demod && (fe->dtv_demod->drv->capability & fe->mode) && fe->dtv_demod->drv->leave_mode)
+				fe->dtv_demod->drv->leave_mode(fe, fe->mode);
+		if(fe->atv_demod && (fe->atv_demod->drv->capability & fe->mode) && fe->atv_demod->drv->leave_mode)
+				fe->atv_demod->drv->leave_mode(fe, fe->mode);
+		if(fe->tuner && (fe->tuner->drv->capability & fe->mode) && fe->tuner->drv->leave_mode)
+				fe->tuner->drv->leave_mode(fe, fe->mode);
+
+		if(fe->mode & AM_FE_DTV_MASK)
+			aml_dmx_register_frontend(fe->ts, NULL);
+
+		fe->mode = AM_FE_UNKNOWN;
+	}
+
+	if(!(mode & fe->capability)){
+		int i;
+
+		spin_lock_irqsave(&lock, flags);
+		for(i = 0; i < FE_DEV_COUNT; i++){
+			if((mode & fe_man.fe[i].capability) && (fe_man.fe[i].dev_id == fe->dev_id))
+				break;
+		}
+		spin_unlock_irqrestore(&lock, flags);
+
+		if(i >= FE_DEV_COUNT){
+			pr_error("frontend %p do not support mode %x, capability %x\n", fe, mode, fe->capability);
+			return -1;
+		}
+
+		fe = &fe_man.fe[i];
+		dev->demodulator_priv = fe;
+	}
+
+	if(fe->mode & AM_FE_DTV_MASK){
+		aml_dmx_register_frontend(fe->ts, NULL);
+		fe->mode = 0;
+	}
+
+	spin_lock_irqsave(&fe->slock, flags);
+
+	memset(&fe->fe->ops.tuner_ops, 0, sizeof(fe->fe->ops.tuner_ops));
+	memset(&fe->fe->ops.analog_ops, 0, sizeof(fe->fe->ops.analog_ops));
+	memset(&fe->fe->ops.info,0,sizeof(fe->fe->ops.info));
+	fe->fe->ops.release = NULL;
+	fe->fe->ops.release_sec = NULL;
+	fe->fe->ops.init = NULL;
+	fe->fe->ops.sleep = NULL;
+	fe->fe->ops.write = NULL;
+	fe->fe->ops.tune = NULL;
+	fe->fe->ops.get_frontend_algo = NULL;
+	fe->fe->ops.set_frontend = NULL;
+	fe->fe->ops.get_tune_settings = NULL;
+	fe->fe->ops.get_frontend = NULL;
+	fe->fe->ops.read_status = NULL;
+	fe->fe->ops.read_ber = NULL;
+	fe->fe->ops.read_signal_strength = NULL;
+	fe->fe->ops.read_snr = NULL;
+	fe->fe->ops.read_ucblocks = NULL;
+	fe->fe->ops.set_qam_mode = NULL;
+	fe->fe->ops.diseqc_reset_overload = NULL;
+	fe->fe->ops.diseqc_send_master_cmd = NULL;
+	fe->fe->ops.diseqc_recv_slave_reply = NULL;
+	fe->fe->ops.diseqc_send_burst = NULL;
+	fe->fe->ops.set_tone = NULL;
+	fe->fe->ops.set_voltage = NULL;
+	fe->fe->ops.enable_high_lnb_voltage = NULL;
+	fe->fe->ops.dishnetwork_send_legacy_command = NULL;
+	fe->fe->ops.i2c_gate_ctrl = NULL;
+	fe->fe->ops.ts_bus_ctrl = NULL;
+	fe->fe->ops.search = NULL;
+	fe->fe->ops.track = NULL;
+	fe->fe->ops.set_property = NULL;
+	fe->fe->ops.get_property = NULL;
+	memset(&fe->fe->ops.blindscan_ops, 0, sizeof(fe->fe->ops.blindscan_ops));
+	fe->fe->ops.asyncinfo.set_frontend_asyncenable = 0;
+	if(fe->tuner && fe->tuner->drv && (mode & fe->tuner->drv->capability) && fe->tuner->drv->get_ops){
+		fe->tuner->drv->get_ops(fe->tuner, mode, &fe->fe->ops.tuner_ops);
+	}
+
+	if(fe->atv_demod && fe->atv_demod->drv && (mode & fe->atv_demod->drv->capability) && fe->atv_demod->drv->get_ops){
+		fe->atv_demod->drv->get_ops(fe->atv_demod, mode, &fe->fe->ops.analog_ops);
+		fe->fe->ops.set_frontend = aml_fe_analog_set_frontend;
+		fe->fe->ops.get_frontend = aml_fe_analog_get_frontend;
+		fe->fe->ops.read_status  = aml_fe_analog_read_status;
+		fe->fe->ops.read_signal_strength = aml_fe_analog_read_signal_strength;
+		fe->fe->ops.read_snr     = aml_fe_analog_read_signal_snr;
+		fe->fe->ops.get_frontend_algo = aml_fe_get_analog_algo;
+		fe->fe->ops.search       =  aml_fe_analog_search;
+	}
+
+	if(fe->dtv_demod && fe->dtv_demod->drv && (mode & fe->dtv_demod->drv->capability) && fe->dtv_demod->drv->get_ops){
+		fe->dtv_demod->drv->get_ops(fe->dtv_demod, mode, &fe->fe->ops);
+	}
+
+	spin_unlock_irqrestore(&fe->slock, flags);
+
+	if(fe->dtv_demod && (fe->dtv_demod->drv->capability & mode) && fe->dtv_demod->drv->enter_mode)
+		fe->dtv_demod->drv->enter_mode(fe, mode);
+	if(fe->atv_demod && (fe->atv_demod->drv->capability & mode) && fe->atv_demod->drv->enter_mode)
+		fe->atv_demod->drv->enter_mode(fe, mode);
+	if(fe->tuner && (fe->tuner->drv->capability & mode) && fe->tuner->drv->enter_mode)
+		fe->tuner->drv->enter_mode(fe, mode);
+
+	if(mode & AM_FE_DTV_MASK){
+		aml_dmx_register_frontend(fe->ts, fe->fe);
+	}
+	strcpy(fe->fe->ops.info.name, "amlogic dvb frontend");
+
+	fe->fe->ops.info.type = type;
+	fe->mode = mode;
+
+	return 0;
+}
+
+static int aml_fe_read_ts(struct dvb_frontend *dev, int *ts)
+{
+	struct aml_fe *fe;
+
+	fe = dev->demodulator_priv;
+
+	*ts = fe->ts;
+	return 0;
+}
+
+#ifndef CONFIG_OF
+struct resource *aml_fe_platform_get_resource_byname(const char *name)
+{
+	int i;
+
+	for (i = 0; i < aml_fe_num_resources; i++) {
+		struct resource *r = &aml_fe_resource[i];
+
+		if (!strcmp(r->name, name))
+			return r;
+	}
+	return NULL;
+}
+#endif /*CONFIG_OF*/
+
+static int aml_fe_dev_init(struct aml_dvb *dvb, struct platform_device *pdev, aml_fe_dev_type_t type, struct aml_fe_dev *dev, int id)
+{
+#ifndef CONFIG_OF
+	struct resource *res;
+#endif
+	char *name = NULL;
+	char buf[32];
+	int ret;
+	u32 value;
+	const char *str;
+	aml_tuner_type_t tunerid;
+
+	switch(type){
+		case AM_DEV_TUNER:
+			name = "tuner";
+			break;
+		case AM_DEV_ATV_DEMOD:
+			name = "atv_demod";
+			break;
+		case AM_DEV_DTV_DEMOD:
+			name = "dtv_demod";
+			break;
+		default:
+			break;
+	}
+
+	snprintf(buf, sizeof(buf), "%s%d", name, id);
+#ifdef CONFIG_OF
+	printk("---------------CONFIG_OF-------------\n");
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if(ret){
+		return 0;
+	}else{
+		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
+		struct aml_fe_drv *drv;
+		unsigned long flags;
+		tunerid = value;
+
+		spin_lock_irqsave(&lock, flags);
+
+	/*	for(drv = *list; drv; drv = drv->next){
+			if(!strcmp(drv->name, str)){
+				drv->ref++;
+				break;
+			}
+		}*/
+		for(drv = *list; drv; drv = drv->next){
+			if(drv->id == tunerid){
+				drv->ref++;
+				break;
+			}
+		}
+
+		spin_unlock_irqrestore(&lock, flags);
+
+		if(drv){
+				dev->drv = drv;
+			}else{
+				pr_err("cannot find %s%d driver: %d\n", name, id, tunerid);
+				return -1;
+			}
+	}
+
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
+		struct aml_fe_drv *drv;
+		int type = res->start;
+		unsigned long flags;
+
+		spin_lock_irqsave(&lock, flags);
+
+		for(drv = *list; drv; drv = drv->next){
+			if(drv->id == type){
+				drv->ref++;
+				break;
+			}
+		}
+
+		spin_unlock_irqrestore(&lock, flags);
+
+		if(drv){
+			dev->drv = drv;
+		}else{
+			pr_error("cannot find %s%d driver: %d\n", name, id, type);
+			return -1;
+		}
+	}else{
+		return 0;
+	}
+#endif /*CONFIG_OF*/
+
+	snprintf(buf, sizeof(buf), "%s%d_i2c_adap_id", name, id);
+#ifdef CONFIG_OF
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if(!ret){
+		dev->i2c_adap_id = value;
+		dev->i2c_adap = i2c_get_adapter(value);
+		pr_dbg("%s: %d\n", buf, dev->i2c_adap_id);
+	}else{
+		dev->i2c_adap_id = -1;
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int adap = res->start;
+
+		dev->i2c_adap_id = adap;
+		dev->i2c_adap = i2c_get_adapter(adap);
+	}else{
+		dev->i2c_adap_id = -1;
+	}
+#endif /*CONFIG_OF*/
+
+	snprintf(buf, sizeof(buf), "%s%d_i2c_addr", name, id);
+#ifdef CONFIG_OF
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if(!ret){
+		dev->i2c_addr = value;
+		pr_dbg("%s: %d\n", buf, dev->i2c_addr);
+	}else{
+		dev->i2c_addr = -1;
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int addr = res->start;
+
+		dev->i2c_addr = addr;
+	}else{
+		dev->i2c_addr = -1;
+	}
+#endif
+
+	snprintf(buf, sizeof(buf), "%s%d_reset_gpio", name, id);
+#ifdef CONFIG_OF
+	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+	if(!ret){
+		dev->reset_gpio = amlogic_gpio_name_map_num(str);
+		pr_dbg("%s: %s\n", buf, str);
+	}else{
+		dev->reset_gpio = -1;
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int gpio = res->start;
+
+		dev->reset_gpio = gpio;
+	}else{
+		dev->reset_gpio = -1;
+	}
+#endif /*CONFIG_OF*/
+
+	snprintf(buf, sizeof(buf), "%s%d_reset_value", name, id);
+#ifdef CONFIG_OF
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if(!ret){
+		dev->reset_value = value;
+		pr_dbg("%s: %d\n", buf, dev->reset_value);
+	}else{
+		dev->reset_value = -1;
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int v = res->start;
+
+		dev->reset_value = v;
+	}else{
+		dev->reset_value = 0;
+	}
+#endif /*CONFIG_OF*/
+
+	snprintf(buf, sizeof(buf), "%s%d_tunerpower", name, id);
+#ifdef CONFIG_OF
+	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+	if(!ret){
+		dev->tuner_power_gpio = amlogic_gpio_name_map_num(str);
+		pr_dbg("%s: %s\n", buf, str);
+	}else{
+		dev->tuner_power_gpio = -1;
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int gpio = res->start;
+
+		dev->tuner_power_gpio = gpio;
+	}else{
+		dev->tuner_power_gpio = -1;
+	}
+#endif /*CONFIG_OF*/
+
+	snprintf(buf, sizeof(buf), "%s%d_lnbpower", name, id);
+#ifdef CONFIG_OF
+	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+	if(!ret){
+		dev->lnb_power_gpio = amlogic_gpio_name_map_num(str);
+		pr_dbg("%s: %s\n", buf, str);
+	}else{
+		dev->lnb_power_gpio = -1;
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int gpio = res->start;
+
+		dev->lnb_power_gpio = gpio;
+	}else{
+		dev->lnb_power_gpio = -1;
+	}
+#endif
+
+	snprintf(buf, sizeof(buf), "%s%d_antoverload", name, id);
+#ifdef CONFIG_OF
+	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+	if(!ret){
+		dev->antoverload_gpio = amlogic_gpio_name_map_num(str);
+		pr_dbg("%s: %s\n", buf, str);
+	}else{
+		dev->antoverload_gpio = -1;
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int gpio = res->start;
+
+		dev->antoverload_gpio = gpio;
+	}else{
+		dev->antoverload_gpio = -1;
+	}
+#endif /*CONFIG_OF*/
+
+	if(dev->drv->init){
+		ret = dev->drv->init(dev);
+		if(ret != 0){
+			dev->drv = NULL;
+            pr_error("[aml_fe..]%s error.\n",__func__);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int aml_fe_dev_release(struct aml_dvb *dvb, aml_fe_dev_type_t type, struct aml_fe_dev *dev)
+{
+	if(dev->drv && dev->drv->release){
+		dev->drv->ref--;
+		dev->drv->release(dev);
+	}
+
+	dev->drv = NULL;
+	return 0;
+}
+long *mem_buf;
+int memstart;
+static int aml_fe_man_init(struct aml_dvb *dvb, struct platform_device *pdev, struct aml_fe *fe, int id)
+{
+#ifndef CONFIG_OF
+	struct resource *res;
+#endif
+	char buf[32];
+	int tuner_cap = 0xFFFFFFFF;
+	int demod_cap = 0;
+	u32 value;
+	int ret;
+
+
+	snprintf(buf, sizeof(buf), "fe%d_tuner", id);
+
+#ifdef CONFIG_OF
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if(!ret){
+		int id = value;
+		if((id < 0) || (id >= FE_DEV_COUNT) || !fe_man.tuner[id].drv){
+			pr_error("invalid tuner device id %d\n", id);
+			return -1;
+		}
+
+		fe->tuner = &fe_man.tuner[id];
+		fe->init = 1;
+
+		tuner_cap &= fe->tuner->drv->capability;
+
+		pr_dbg("%s: %d\n", buf, id);
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int id = res->start;
+		if((id < 0) || (id >= FE_DEV_COUNT) || !fe_man.tuner[id].drv){
+			pr_error("invalid tuner device id %d\n", id);
+			return -1;
+		}
+
+		fe->tuner = &fe_man.tuner[id];
+		fe->init = 1;
+
+		tuner_cap &= fe->tuner->drv->capability;
+	}
+#endif /*CONFIG_OF*/
+
+	snprintf(buf, sizeof(buf), "fe%d_atv_demod", id);
+#ifdef CONFIG_OF
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if(!ret){
+		int id = value;
+		if((id < 0) || (id >= FE_DEV_COUNT) || !fe_man.atv_demod[id].drv){
+			pr_error("invalid ATV demod device id %d\n", id);
+			return -1;
+		}
+
+		fe->atv_demod = &fe_man.atv_demod[id];
+		fe->init = 1;
+
+		demod_cap |= fe->atv_demod->drv->capability;
+		pr_dbg("%s: %d\n", buf, id);
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int id = res->start;
+		if((id < 0) || (id >= FE_DEV_COUNT) || !fe_man.atv_demod[id].drv){
+			pr_error("invalid ATV demod device id %d\n", id);
+			return -1;
+		}
+
+		fe->atv_demod = &fe_man.atv_demod[id];
+		fe->init = 1;
+
+		demod_cap |= fe->atv_demod->drv->capability;
+	}
+#endif /*CONFIG_OF*/
+
+	snprintf(buf, sizeof(buf), "fe%d_dtv_demod", id);
+#ifdef CONFIG_OF
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if(!ret){
+		int id = value;
+		if((id < 0) || (id >= FE_DEV_COUNT) || !fe_man.dtv_demod[id].drv){
+			pr_error("invalid DTV demod device id %d\n", id);
+			return -1;
+		}
+
+		fe->dtv_demod = &fe_man.dtv_demod[id];
+		fe->init = 1;
+
+		demod_cap |= fe->dtv_demod->drv->capability;
+		pr_dbg("%s: %d\n", buf, id);
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int id = res->start;
+
+		pr_dbg("[dvb] res->start is %d\n",res->start);
+		if((id < 0) || (id >= FE_DEV_COUNT) || !fe_man.dtv_demod[id].drv){
+			pr_error("invalid DTV demod device id %d\n", id);
+			return -1;
+		}
+
+		fe->dtv_demod = &fe_man.dtv_demod[id];
+		fe->init = 1;
+
+		demod_cap |= fe->dtv_demod->drv->capability;
+	}
+#endif /*CONFIG_OF*/
+
+	snprintf(buf, sizeof(buf), "fe%d_ts", id);
+#ifdef CONFIG_OF
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if(!ret){
+		int id = value;
+		aml_ts_source_t ts = AM_TS_SRC_TS0;
+
+		switch(id){
+			case 0:
+				ts = AM_TS_SRC_TS0;
+				break;
+			case 1:
+				ts = AM_TS_SRC_TS1;
+				break;
+			case 2:
+				ts = AM_TS_SRC_TS2;
+				break;
+			default:
+				break;
+		}
+
+		fe->ts = ts;
+		pr_dbg("%s: %d\n", buf, id);
+	}
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int id = res->start;
+		aml_ts_source_t ts = AM_TS_SRC_TS0;
+
+		switch(id){
+			case 0:
+				ts = AM_TS_SRC_TS0;
+				break;
+			case 1:
+				ts = AM_TS_SRC_TS1;
+				break;
+			case 2:
+				ts = AM_TS_SRC_TS2;
+				break;
+			default:
+				break;
+		}
+
+		fe->ts = ts;
+	}
+#endif /*CONFIG_OF*/
+	{
+		int memend;
+		int memsize;
+		snprintf(buf, sizeof(buf), "fe%d_mem", id);
+		ret = find_reserve_block(pdev->dev.of_node->name,0);
+		if(ret < 0){
+		    pr_err("aml_fe memory resource undefined.\n");
+		}else{
+			memstart = (phys_addr_t)get_reserve_block_addr(ret);
+			memsize = (phys_addr_t)get_reserve_block_size(ret);
+			memend = memstart+memsize;
+			mem_buf=(long*)phys_to_virt(memstart/*+0x40000000*/);
+		//	mem_buf = (long*)(memstart+0x40000000);
+			printk("memend is %x,memstart is %x,memsize is %x\n",memend,memstart,memsize);
+			printk("mem reset g\n");
+			memset(mem_buf,0,memsize-1);
+			printk("mem reset o\n");
+	}
+	}
+
+	snprintf(buf, sizeof(buf), "fe%d_dev", id);
+#ifdef CONFIG_OF
+	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+	if(!ret){
+		int id = value;
+
+		if((id >= 0) && (id < FE_DEV_COUNT))
+			fe->dev_id = id;
+		else
+			fe->dev_id = 0;
+	}else{
+		fe->dev_id = 0;
+	}
+	pr_dbg("%s: %d\n", buf, fe->dev_id);
+#else /*CONFIG_OF*/
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	res = aml_fe_platform_get_resource_byname(buf);
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+#endif
+	if(res){
+		int id = res->start;
+
+		if((id >= 0) && (id < FE_DEV_COUNT))
+			fe->dev_id = id;
+		else
+			fe->dev_id = 0;
+	}else{
+		fe->dev_id = 0;
+	}
+#endif /*CONFIG_OF*/
+
+	if(fe->init){
+		int reg = 1;
+		int prev;
+		int ret;
+
+
+		spin_lock_init(&fe->slock);
+		fe->mode = AM_FE_UNKNOWN;
+		fe->capability = (tuner_cap & demod_cap);
+		pr_dbg("fe: %p cap: %x tuner: %x demod: %x\n", fe, fe->capability, tuner_cap, demod_cap);
+
+		for(prev = 0; prev < id; prev++){
+			struct aml_fe *prev_fe = &fe_man.fe[prev];
+
+			if(prev_fe->init && (prev_fe->dev_id == fe->dev_id)){
+				reg = 0;
+				break;
+			}
+		}
+			fe->fe = &fe_man.dev[fe->dev_id];
+		if(reg){
+			fe->fe->demodulator_priv = fe;
+			fe->fe->ops.set_mode = aml_fe_set_mode;
+			fe->fe->ops.read_ts  = aml_fe_read_ts;
+
+			ret = dvb_register_frontend(&dvb->dvb_adapter, fe->fe);
+			if(ret){
+				pr_error("register fe%d failed\n", fe->dev_id);
+				return -1;
+			}
+		}
+
+		if(fe->tuner)
+			fe->tuner->fe = fe;
+		if(fe->atv_demod)
+			fe->atv_demod->fe = fe;
+		if(fe->dtv_demod)
+			fe->dtv_demod->fe = fe;
+	}
+
+	return 0;
+}
+
+static int aml_fe_man_release(struct aml_dvb *dvb, struct aml_fe *fe)
+{
+	if(fe->init){
+		aml_dmx_register_frontend(fe->ts, NULL);
+		dvb_unregister_frontend(fe->fe);
+		dvb_frontend_detach(fe->fe);
+		fe->init = 0;
+	}
+
+	return 0;
+}
+static ssize_t tuner_name_show(struct class *cls,struct class_attribute *attr,char *buf)
+{
+        size_t len = 0;
+        struct aml_fe_drv *drv;
+        unsigned long flags;
+
+        struct aml_fe_drv **list = aml_get_fe_drv_list(AM_DEV_TUNER);
+        spin_lock_irqsave(&lock, flags);
+        for(drv = *list; drv; drv = drv->next){
+	        len += sprintf(buf+len,"%s\n", drv->name);
+        }
+        spin_unlock_irqrestore(&lock, flags);
+        return len;
+}
+
+static ssize_t atv_demod_name_show(struct class *cls,struct class_attribute *attr,char *buf)
+{
+	size_t len = 0;
+	struct aml_fe_drv *drv;
+	unsigned long flags;
+
+	struct aml_fe_drv **list = aml_get_fe_drv_list(AM_DEV_ATV_DEMOD);
+	spin_lock_irqsave(&lock, flags);
+	for(drv = *list; drv; drv = drv->next){
+		len += sprintf(buf+len,"%s\n", drv->name);
+	}
+	spin_unlock_irqrestore(&lock, flags);
+	return len;
+}
+
+static ssize_t dtv_demod_name_show(struct class *cls,struct class_attribute *attr,char *buf)
+{
+	size_t len = 0;
+	struct aml_fe_drv *drv;
+	unsigned long flags;
+
+	struct aml_fe_drv **list = aml_get_fe_drv_list(AM_DEV_DTV_DEMOD);
+	spin_lock_irqsave(&lock, flags);
+	for(drv = *list; drv; drv = drv->next){
+		len += sprintf(buf+len,"%s\n", drv->name);
+	}
+	spin_unlock_irqrestore(&lock, flags);
+	return len;
+}
+
+static ssize_t setting_show(struct class *cls,struct class_attribute *attr,char *buf)
+{
+	int r, total = 0;
+	int i;
+	struct aml_fe_man *fm = &fe_man;
+
+	r = sprintf(buf, "tuners:\n");
+	buf += r;
+	total += r;
+	for(i=0; i<FE_DEV_COUNT; i++){
+		struct aml_fe_dev *dev = &fm->tuner[i];
+		if(dev->drv){
+			r = sprintf(buf, "\t%d: %s i2s_id: %d i2c_addr: 0x%x reset_gpio: 0x%x reset_level: %d\n",
+					i,
+					dev->drv->name,
+					dev->i2c_adap_id,
+					dev->i2c_addr,
+					dev->reset_gpio,
+					dev->reset_value);
+			buf += r;
+			total += r;
+		}
+	}
+
+	r = sprintf(buf, "atv_demod:\n");
+	buf += r;
+	total += r;
+	for(i=0; i<FE_DEV_COUNT; i++){
+		struct aml_fe_dev *dev = &fm->atv_demod[i];
+		if(dev->drv){
+			r = sprintf(buf, "\t%d: %s i2s_id: %d i2c_addr: 0x%x reset_gpio: 0x%x reset_level: %d\n",
+					i,
+					dev->drv->name,
+					dev->i2c_adap_id,
+					dev->i2c_addr,
+					dev->reset_gpio,
+					dev->reset_value);
+			buf += r;
+			total += r;
+		}
+	}
+
+	r = sprintf(buf, "dtv_demod:\n");
+	buf += r;
+	total += r;
+	for(i=0; i<FE_DEV_COUNT; i++){
+		struct aml_fe_dev *dev = &fm->dtv_demod[i];
+		if(dev->drv){
+			r = sprintf(buf, "\t%d: %s i2s_id: %d i2c_addr: 0x%x reset_gpio: 0x%x reset_level: %d\n",
+					i,
+					dev->drv->name,
+					dev->i2c_adap_id,
+					dev->i2c_addr,
+					dev->reset_gpio,
+					dev->reset_value);
+			buf += r;
+			total += r;
+		}
+	}
+
+	r = sprintf(buf, "frontends:\n");
+	buf += r;
+	total += r;
+	for(i=0; i<FE_DEV_COUNT; i++){
+		struct aml_fe *fe = &fm->fe[i];
+
+		if(fe->init){
+			r = sprintf(buf, "\t%d: device: %d ts: %d tuner: %s atv_demod: %s dtv_demod: %s\n",
+					i,
+					fe->dev_id,
+					fe->ts,
+					fe->tuner ? fe->tuner->drv->name : "none",
+					fe->atv_demod ? fe->atv_demod->drv->name : "none",
+					fe->dtv_demod ? fe->dtv_demod->drv->name : "none");
+			buf += r;
+			total += r;
+		}
+	}
+
+	return total;
+}
+
+#ifndef CONFIG_OF
+
+static ssize_t aml_fe_show_dynamic_config(struct class *class, struct class_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	return ret;
+}
+
+static ssize_t aml_fe_store_dynamic_config(struct class *class, struct class_attribute *attr, const char *buf, size_t size)
+{
+	struct aml_fe_man *fe_man_pre = platform_get_drvdata(g_aml_fe_pdev);
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	int i;
+	char *s, *p, *t;
+
+	/*user not release fe, we can not config fe*/
+	if(aml_fe_buf && (aml_fe_size == size) && !(memcmp(aml_fe_buf, buf, aml_fe_size))){
+		return -1;
+	}
+
+	for(i = 0; i < aml_fe_num_resources; i++){
+		if(aml_fe_resource[i].name){
+			kfree(aml_fe_resource[i].name);
+			aml_fe_resource[i].name = NULL;
+		}
+	}
+
+	aml_fe_num_resources = 0;
+
+	i = 0;
+	p = (char*)buf;
+	while ((s = strstr(p, "|")) != NULL) {
+		*s = '\0';
+		pr_dbg("%s\n", p);
+		if(i % 2 == 0){
+			aml_fe_resource[aml_fe_num_resources].start = simple_strtol(p, NULL, 0);
+		}
+		else{
+			t = kmalloc(strlen(p) + 1, GFP_KERNEL);
+			if(t){
+				memcpy(t, p, strlen(p) + 1);
+				aml_fe_resource[aml_fe_num_resources].name = t;
+
+				aml_fe_num_resources++;
+			}
+			else{
+				pr_error("kmalloc fail\n");
+			}
+		}
+		i++;
+		p = s+1;
+	}
+
+	pr_dbg("num res %d\n", aml_fe_num_resources);
+
+	for (i = 0; i < aml_fe_num_resources; i++) {
+		struct resource *r = &aml_fe_resource[i];
+
+		pr_dbg("%d | %s\n", r->start, r->name);
+	}
+
+	/* release pre aml fe man and dev */
+	if(fe_man_pre){
+		platform_set_drvdata(g_aml_fe_pdev, NULL);
+
+		for(i = 0; i < FE_DEV_COUNT; i++){
+			aml_fe_man_release(dvb, &fe_man_pre->fe[i]);
+		}
+
+		for(i = 0; i < FE_DEV_COUNT; i++){
+			aml_fe_dev_release(dvb, AM_DEV_DTV_DEMOD, &fe_man_pre->dtv_demod[i]);
+			aml_fe_dev_release(dvb, AM_DEV_ATV_DEMOD, &fe_man_pre->atv_demod[i]);
+			aml_fe_dev_release(dvb, AM_DEV_TUNER, &fe_man_pre->tuner[i]);
+		}
+	}
+
+	for(i = 0; i < FE_DEV_COUNT; i++){
+		if(aml_fe_dev_init(dvb, g_aml_fe_pdev, AM_DEV_TUNER, &fe_man.tuner[i], i)<0)
+			return -1;
+		if(aml_fe_dev_init(dvb, g_aml_fe_pdev, AM_DEV_ATV_DEMOD, &fe_man.atv_demod[i], i)<0)
+			return -1;
+		if(aml_fe_dev_init(dvb, g_aml_fe_pdev, AM_DEV_DTV_DEMOD, &fe_man.dtv_demod[i], i)<0)
+			return -1;
+	}
+
+	for(i = 0; i < FE_DEV_COUNT; i++){
+		if(aml_fe_man_init(dvb, g_aml_fe_pdev, &fe_man.fe[i], i)<0)
+			return -1;
+	}
+
+
+
+	platform_set_drvdata(g_aml_fe_pdev, &fe_man);
+
+	/*save config for compare*/
+	if(aml_fe_buf){
+		kfree(aml_fe_buf);
+		aml_fe_buf = NULL;
+	}
+
+	aml_fe_buf = kmalloc(size, GFP_KERNEL);
+	if(aml_fe_buf){
+		aml_fe_size = size;
+	}
+	else{
+		pr_error("kmalloc buf fail\n");
+	}
+
+	return size;
+}
+
+#endif /*CONFIG_OF*/
+
+static ssize_t aml_fe_show_suspended_flag(struct class *class, struct class_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%d\n", aml_fe_suspended);
+
+	return ret;
+}
+
+static ssize_t aml_fe_store_suspended_flag(struct class *class, struct class_attribute *attr, const char *buf, size_t size)
+{
+	aml_fe_suspended = simple_strtol(buf, 0, 0);
+
+	return size;
+}
+
+static struct class_attribute aml_fe_cls_attrs[] = {
+	__ATTR(tuner_name,  S_IRUGO | S_IWUSR, tuner_name_show, NULL),
+	__ATTR(atv_demod_name,  S_IRUGO | S_IWUSR, atv_demod_name_show, NULL),
+	__ATTR(dtv_demod_name,  S_IRUGO | S_IWUSR, dtv_demod_name_show, NULL),
+	__ATTR(setting,  S_IRUGO | S_IWUSR, setting_show, NULL),
+
+#ifndef CONFIG_OF
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	__ATTR(aml_fe_dynamic_config,  S_IRUGO | S_IWUSR, aml_fe_show_dynamic_config, aml_fe_store_dynamic_config),
+#endif
+#endif
+
+	__ATTR(aml_fe_suspended_flag,  S_IRUGO | S_IWUSR, aml_fe_show_suspended_flag, aml_fe_store_suspended_flag),
+	__ATTR_NULL
+};
+
+static struct class aml_fe_class = {
+	.name = "amlfe",
+	.class_attrs = aml_fe_cls_attrs,
+};
+
+static int aml_fe_probe(struct platform_device *pdev)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	int i;
+
+
+#if defined(CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG) && !defined(CONFIG_OF)
+	platform_set_drvdata(pdev, NULL);
+	g_aml_fe_pdev = pdev;
+#else
+	for(i = 0; i < FE_DEV_COUNT; i++){
+		if(aml_fe_dev_init(dvb, pdev, AM_DEV_TUNER, &fe_man.tuner[i], i)<0)
+			return -1;
+		if(aml_fe_dev_init(dvb, pdev, AM_DEV_ATV_DEMOD, &fe_man.atv_demod[i], i)<0)
+			return -1;
+		if(aml_fe_dev_init(dvb, pdev, AM_DEV_DTV_DEMOD, &fe_man.dtv_demod[i], i)<0)
+			return -1;
+	}
+
+	for(i = 0; i < FE_DEV_COUNT; i++){
+		if(aml_fe_man_init(dvb, pdev, &fe_man.fe[i], i)<0)
+			return -1;
+	}
+
+#ifdef CONFIG_OF
+	fe_man.pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+#endif
+
+	platform_set_drvdata(pdev, &fe_man);
+#endif
+
+	if(class_register(&aml_fe_class) < 0) {
+		pr_error("[aml_fe..] register class error\n");
+	}
+
+	pr_dbg("[aml_fe..] probe ok.\n");
+
+	return 0;
+}
+
+static int aml_fe_remove(struct platform_device *pdev)
+{
+	struct aml_fe_man *fe_man = platform_get_drvdata(pdev);
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	int i;
+
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	if(fe_man){
+#endif
+		platform_set_drvdata(pdev, NULL);
+
+		for(i = 0; i < FE_DEV_COUNT; i++){
+			aml_fe_man_release(dvb, &fe_man->fe[i]);
+		}
+
+		for(i = 0; i < FE_DEV_COUNT; i++){
+			aml_fe_dev_release(dvb, AM_DEV_DTV_DEMOD, &fe_man->dtv_demod[i]);
+			aml_fe_dev_release(dvb, AM_DEV_ATV_DEMOD, &fe_man->atv_demod[i]);
+			aml_fe_dev_release(dvb, AM_DEV_TUNER, &fe_man->tuner[i]);
+		}
+
+		if(fe_man->pinctrl)
+			devm_pinctrl_put(fe_man->pinctrl);
+
+#if defined (CONFIG_AMLOGIC_DYNAMIC_FEANDDMX_CONFIG)
+	}
+#endif
+
+	class_unregister(&aml_fe_class);
+
+	return 0;
+}
+
+static int aml_fe_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int i;
+
+	for(i = 0; i < FE_DEV_COUNT; i++){
+		struct aml_fe *fe = &fe_man.fe[i];
+
+		if(fe->tuner && fe->tuner->drv && fe->tuner->drv->suspend){
+			fe->tuner->drv->suspend(fe->tuner);
+		}
+
+		if(fe->atv_demod && fe->atv_demod->drv && fe->atv_demod->drv->suspend){
+			fe->atv_demod->drv->suspend(fe->atv_demod);
+		}
+
+		if(fe->dtv_demod && fe->dtv_demod->drv && fe->dtv_demod->drv->suspend){
+			fe->dtv_demod->drv->suspend(fe->dtv_demod);
+		}
+	}
+
+	aml_fe_suspended = 1;
+
+	return 0;
+}
+
+static int aml_fe_resume(struct platform_device *dev)
+{
+	int i;
+
+	for(i = 0; i < FE_DEV_COUNT; i++){
+		struct aml_fe *fe = &fe_man.fe[i];
+
+		if(fe->tuner && fe->tuner->drv && fe->tuner->drv->resume){
+			fe->tuner->drv->resume(fe->tuner);
+		}
+
+		if(fe->atv_demod && fe->atv_demod->drv && fe->atv_demod->drv->resume){
+			fe->atv_demod->drv->resume(fe->atv_demod);
+		}
+
+		if(fe->dtv_demod && fe->dtv_demod->drv && fe->dtv_demod->drv->resume){
+			fe->dtv_demod->drv->resume(fe->dtv_demod);
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id aml_fe_dt_match[]={
+	{
+		.compatible = "amlogic,dvbfe",
+	},
+	{},
+};
+#endif /*CONFIG_OF*/
+
+static struct platform_driver aml_fe_driver = {
+	.probe		= aml_fe_probe,
+	.remove		= aml_fe_remove,
+	.suspend        = aml_fe_suspend,
+	.resume         = aml_fe_resume,
+	.driver		= {
+		.name	= "amlogic-dvb-fe",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = aml_fe_dt_match,
+#endif
+	}
+};
+const char *audmode_to_str(unsigned short audmode)
+{
+  /*  switch(audmode)
+    {
+        case V4L2_TUNER_AUDMODE_NULL:
+            return "V4L2_TUNER_AUDMODE_NULL";
+            break;
+        case V4L2_TUNER_MODE_MONO:
+            return "V4L2_TUNER_MODE_MONO";
+            break;
+        case V4L2_TUNER_MODE_STEREO:
+            return "V4L2_TUNER_MODE_STEREO";
+            break;
+        case V4L2_TUNER_MODE_LANG2:
+            return "V4L2_TUNER_MODE_LANG2";
+            break;
+        case V4L2_TUNER_MODE_SAP:
+            return "V4L2_TUNER_MODE_SAP";
+            break;
+        case V4L2_TUNER_SUB_LANG1:
+            return "V4L2_TUNER_SUB_LANG1";
+            break;
+        case V4L2_TUNER_MODE_LANG1_LANG2:
+            return "V4L2_TUNER_MODE_LANG1_LANG2";
+            break;
+        default:
+            return "NO AUDMODE";
+            break;
+    }*/
+	return 0;
+}
+EXPORT_SYMBOL(audmode_to_str);
+const char *soundsys_to_str(unsigned short sys)
+{
+/*    switch(sys)
+    {
+        case V4L2_TUNER_SYS_NULL:
+            return "V4L2_TUNER_SYS_NULL";
+            break;
+         case V4L2_TUNER_SYS_A2_BG:
+            return "V4L2_TUNER_SYS_A2_BG";
+            break;
+         case V4L2_TUNER_SYS_A2_DK1:
+            return "V4L2_TUNER_SYS_A2_DK1";
+            break;
+         case V4L2_TUNER_SYS_A2_DK2:
+            return "V4L2_TUNER_SYS_A2_DK2";
+            break;
+         case V4L2_TUNER_SYS_A2_DK3:
+            return "V4L2_TUNER_SYS_A2_DK3";
+            break;
+         case V4L2_TUNER_SYS_A2_M:
+            return "V4L2_TUNER_SYS_A2_M";
+            break;
+         case V4L2_TUNER_SYS_NICAM_BG:
+            return "V4L2_TUNER_SYS_NICAM_BG";
+            break;
+        case V4L2_TUNER_SYS_NICAM_I:
+            return "V4L2_TUNER_SYS_NICAM_I";
+            break;
+        case V4L2_TUNER_SYS_NICAM_DK:
+            return "V4L2_TUNER_SYS_NICAM_DK";
+            break;
+        case V4L2_TUNER_SYS_NICAM_L:
+            return "V4L2_TUNER_SYS_NICAM_L";
+            break;
+        case V4L2_TUNER_SYS_EIAJ:
+            return "V4L2_TUNER_SYS_EIAJ";
+            break;
+        case V4L2_TUNER_SYS_BTSC:
+            return "V4L2_TUNER_SYS_BTSC";
+            break;
+        case V4L2_TUNER_SYS_FM_RADIO:
+            return "V4L2_TUNER_SYS_FM_RADIO";
+            break;
+        default:
+            return "NO SOUND SYS";
+            break;
+    }*/
+    return 0;
+}
+EXPORT_SYMBOL(soundsys_to_str);
+
+const char *v4l2_std_to_str(v4l2_std_id std)
+{
+    switch(std){
+        case V4L2_STD_PAL_B:
+            return "V4L2_STD_PAL_B";
+            break;
+        case V4L2_STD_PAL_B1:
+            return "V4L2_STD_PAL_B1";
+            break;
+        case V4L2_STD_PAL_G:
+            return "V4L2_STD_PAL_G";
+            break;
+        case V4L2_STD_PAL_H:
+            return "V4L2_STD_PAL_H";
+            break;
+        case V4L2_STD_PAL_I:
+            return "V4L2_STD_PAL_I";
+            break;
+        case V4L2_STD_PAL_D:
+            return "V4L2_STD_PAL_D";
+            break;
+        case V4L2_STD_PAL_D1:
+            return "V4L2_STD_PAL_D1";
+            break;
+        case V4L2_STD_PAL_K:
+            return "V4L2_STD_PAL_K";
+            break;
+        case V4L2_STD_PAL_M:
+            return "V4L2_STD_PAL_M";
+            break;
+        case V4L2_STD_PAL_N:
+            return "V4L2_STD_PAL_N";
+            break;
+        case V4L2_STD_PAL_Nc:
+            return "V4L2_STD_PAL_Nc";
+            break;
+        case V4L2_STD_PAL_60:
+            return "V4L2_STD_PAL_60";
+            break;
+        case V4L2_STD_NTSC_M:
+            return "V4L2_STD_NTSC_M";
+            break;
+        case V4L2_STD_NTSC_M_JP:
+            return "V4L2_STD_NTSC_M_JP";
+            break;
+        case V4L2_STD_NTSC_443:
+            return "V4L2_STD_NTSC_443";
+            break;
+        case V4L2_STD_NTSC_M_KR:
+            return "V4L2_STD_NTSC_M_KR";
+            break;
+        case V4L2_STD_SECAM_B:
+            return "V4L2_STD_SECAM_B";
+            break;
+         case V4L2_STD_SECAM_D:
+            return "V4L2_STD_SECAM_D";
+            break;
+        case V4L2_STD_SECAM_G:
+            return "V4L2_STD_SECAM_G";
+            break;
+        case V4L2_STD_SECAM_H:
+            return "V4L2_STD_SECAM_H";
+            break;
+        case V4L2_STD_SECAM_K:
+            return "V4L2_STD_SECAM_K";
+            break;
+        case V4L2_STD_SECAM_K1:
+            return "V4L2_STD_SECAM_K1";
+            break;
+        case V4L2_STD_SECAM_L:
+            return "V4L2_STD_SECAM_L";
+            break;
+        case V4L2_STD_SECAM_LC:
+            return "V4L2_STD_SECAM_LC";
+            break;
+        case V4L2_STD_ATSC_8_VSB:
+            return "V4L2_STD_ATSC_8_VSB";
+            break;
+         case V4L2_STD_ATSC_16_VSB:
+            return "V4L2_STD_ATSC_16_VSB";
+            break;
+	    /*
+         case V4L2_COLOR_STD_PAL:
+            return "V4L2_COLOR_STD_PAL";
+            break;
+         case V4L2_COLOR_STD_NTSC:
+            return "V4L2_COLOR_STD_NTSC";
+            break;
+        case V4L2_COLOR_STD_SECAM:
+            return "V4L2_COLOR_STD_SECAM";
+            break;
+            */
+        case V4L2_STD_MN:
+            return "V4L2_STD_MN";
+            break;
+        case V4L2_STD_B:
+            return "V4L2_STD_B";
+            break;
+         case V4L2_STD_GH:
+            return "V4L2_STD_GH";
+            break;
+        case V4L2_STD_DK:
+            return "V4L2_STD_DK";
+            break;
+        case V4L2_STD_PAL_BG:
+            return "V4L2_STD_PAL_BG";
+            break;
+        case V4L2_STD_PAL_DK:
+            return "V4L2_STD_PAL_DK";
+            break;
+        case V4L2_STD_PAL:
+            return "V4L2_STD_PAL";
+            break;
+        case V4L2_STD_NTSC:
+            return "V4L2_STD_NTSC";
+            break;
+        case V4L2_STD_SECAM_DK:
+            return "V4L2_STD_SECAM_DK";
+            break;
+        case V4L2_STD_SECAM:
+            return "V4L2_STD_SECAM";
+            break;
+        case V4L2_STD_525_60:
+            return "V4L2_STD_525_60";
+            break;
+        case V4L2_STD_625_50:
+            return "V4L2_STD_625_50";
+            break;
+        case V4L2_STD_ATSC:
+            return "V4L2_STD_ATSC";
+            break;
+         case V4L2_STD_ALL:
+            return "V4L2_STD_ALL";
+            break;
+         default:
+            return "V4L2_STD_UNKNOWN";
+            break;
+    }
+}
+EXPORT_SYMBOL(v4l2_std_to_str);
+const char* fe_type_to_str(fe_type_t type)
+{
+    switch(type)
+    {
+        case FE_QPSK:
+            return "FE_QPSK";
+            break;
+        case FE_QAM:
+            return "FE_QAM";
+            break;
+        case FE_OFDM:
+            return "FE_OFDM";
+            break;
+        case FE_ATSC:
+            return "FE_ATSC";
+            break;
+        case FE_ANALOG:
+            return "FE_ANALOG";
+            break;
+		case FE_ISDBT:
+			return "FE_ISDBT";
+			break;
+		case FE_DTMB:
+            return "FE_DTMB";
+            break;
+       default:
+            return "UNKONW TYPE";
+            break;
+    }
+}
+static int __init aml_fe_init(void)
+{
+	return platform_driver_register(&aml_fe_driver);
+}
+
+
+static void __exit aml_fe_exit(void)
+{
+	platform_driver_unregister(&aml_fe_driver);
+}
+
+module_init(aml_fe_init);
+module_exit(aml_fe_exit);
+
+
+MODULE_DESCRIPTION("amlogic frontend driver");
+MODULE_AUTHOR("L+#= +0=1");
diff --git a/drivers/amlogic/dvb_tv/aml_fe.h b/drivers/amlogic/dvb_tv/aml_fe.h
new file mode 100755
index 000000000000..7291481d2031
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/aml_fe.h
@@ -0,0 +1,163 @@
+#ifndef _AML_FE_H_
+#define _AML_FE_H_
+
+#include <linux/interrupt.h>
+#include <linux/socket.h>
+#include <linux/netdevice.h>
+#include <linux/i2c.h>
+
+#include <uapi/linux/dvb/video.h>
+#include <uapi/linux/dvb/audio.h>
+#include <uapi/linux/dvb/dmx.h>
+#include <uapi/linux/dvb/ca.h>
+#include <uapi/linux/dvb/osd.h>
+#include <uapi/linux/dvb/net.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include "../../media/dvb-core/dvbdev.h"
+#include "../../media/dvb-core/demux.h"
+#include "../../media/dvb-core/dvb_demux.h"
+#include "../../media/dvb-core/dmxdev.h"
+#include "../../media/dvb-core/dvb_filter.h"
+#include "../../media/dvb-core/dvb_net.h"
+#include "../../media/dvb-core/dvb_ringbuffer.h"
+#include "../../media/dvb-core/dvb_frontend.h"
+#include "aml_dvb.h"
+#include "../../../include/uapi/linux/videodev2.h"
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/pinctrl/consumer.h>
+
+
+
+typedef enum{
+	AM_FE_UNKNOWN = 0,
+	AM_FE_QPSK = 1,
+	AM_FE_QAM  = 2,
+	AM_FE_OFDM = 4,
+	AM_FE_ATSC = 8,
+	AM_FE_ANALOG = 16,
+	AM_FE_DTMB = 32,
+	AM_FE_ISDBT = 64
+}aml_fe_mode_t;
+
+#define AM_FE_DTV_MASK (AM_FE_QPSK|AM_FE_QAM|AM_FE_OFDM|AM_FE_ATSC|AM_FE_DTMB|AM_FE_ISDBT)
+
+typedef enum{
+	AM_TUNER_SI2176     = 1,
+        AM_TUNER_SI2196     =2,
+	AM_TUNER_FQ1216 = 3,
+	AM_TUNER_HTM = 4,
+	AM_TUNER_CTC703=5,
+	AM_TUNER_SI2177 = 6
+}aml_tuner_type_t;
+
+typedef enum{
+	AM_ATV_DEMOD_SI2176 = 1,
+    AM_ATV_DEMOD_SI2196 =2,
+	AM_ATV_DEMOD_FQ1216 =3,
+	AM_ATV_DEMOD_HTM = 4,
+	AM_ATV_DEMOD_CTC703 = 5,
+	AM_ATV_DEMOD_SI2177 =6
+}aml_atv_demod_type_t;
+
+typedef enum{
+	AM_DTV_DEMOD_M1     = 0,
+	AM_DTV_DEMOD_SI2176 = 1,
+	AM_DTV_DEMOD_MXL101 = 2,
+	AM_DTV_DEMOD_SI2196 = 3,
+	AM_DTV_DEMOD_AVL6211 = 4,
+	AM_DTV_DEMOD_SI2168 = 5,
+	AM_DTV_DEMOD_ITE9133 = 6,
+	AM_DTV_DEMOD_ITE9173 = 7
+}aml_dtv_demod_type_t;
+
+typedef enum{
+	AM_DEV_TUNER,
+	AM_DEV_ATV_DEMOD,
+	AM_DEV_DTV_DEMOD
+}aml_fe_dev_type_t;
+
+struct aml_fe_dev;
+struct aml_fe;
+struct aml_fe_drv{
+	struct aml_fe_drv    *next;
+	aml_tuner_type_t      id;
+	char    *name;
+	int      capability;
+	int (*init)(struct aml_fe_dev *dev);
+	int (*release)(struct aml_fe_dev *dev);
+	int (*resume)(struct aml_fe_dev *dev);
+	int (*suspend)(struct aml_fe_dev *dev);
+	int (*get_ops)(struct aml_fe_dev *dev, int mode, void *ops);
+	int (*enter_mode)(struct aml_fe *fe, int mode);
+	int (*leave_mode)(struct aml_fe *fe, int mode);
+	int      ref;
+};
+
+struct aml_fe_dev{
+	/*point to parent aml_fe*/
+	struct aml_fe *fe;
+	int      i2c_adap_id;
+	int      i2c_addr;
+	struct i2c_adapter *i2c_adap;
+	int      reset_gpio;
+	int      reset_value;
+	struct aml_fe_drv *drv;
+	wait_queue_head_t  lock_wq;
+	void    *priv_data;
+
+	/*for tuner power control*/
+	int      tuner_power_gpio;
+	/*for dtv dvbsx lnb power control*/
+	int      lnb_power_gpio;
+	/*for ant overload control, it possible in dtv dvbsx and depond on fe hw*/
+	int      antoverload_gpio;
+};
+
+struct aml_fe{
+	struct dvb_frontend *fe;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend es;
+#endif /*CONFIG_HAS_EARLYSUSPEND*/
+	spinlock_t slock;
+	int      init;
+	int      mode;
+	int      dev_id;
+	int      capability;
+	aml_ts_source_t    ts;
+	struct aml_fe_dev *tuner;
+	struct aml_fe_dev *atv_demod;
+	struct aml_fe_dev *dtv_demod;
+	//struct dvb_frontend_parameters params;
+	struct dtv_frontend_properties params;
+
+};
+
+struct aml_fe_man{
+	struct aml_fe       fe[FE_DEV_COUNT];
+	struct aml_fe_dev   tuner[FE_DEV_COUNT];
+	struct aml_fe_dev   atv_demod[FE_DEV_COUNT];
+	struct aml_fe_dev   dtv_demod[FE_DEV_COUNT];
+	struct dvb_frontend dev[FE_DEV_COUNT];
+	struct pinctrl     *pinctrl;
+};
+
+extern int aml_register_fe_drv(aml_fe_dev_type_t type, struct aml_fe_drv *drv);
+
+extern int aml_unregister_fe_drv(aml_fe_dev_type_t type, struct aml_fe_drv *drv);
+
+extern const char* soundsys_to_str(unsigned short soundsys);
+extern const char* audmode_to_str(unsigned short soundsys);
+extern const char* v4l2_std_to_str(v4l2_std_id std);
+extern const char* fe_type_to_str(fe_type_t type);
+#endif /*_AML_FE_H_*/
diff --git a/drivers/amlogic/dvb_tv/amlci/Makefile b/drivers/amlogic/dvb_tv/amlci/Makefile
new file mode 100755
index 000000000000..0cb4b690ede3
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amlci/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the DVB driver.
+#
+
+obj-$(CONFIG_AM_IOBUS) +=aml_iobus.o
+obj-$(CONFIG_AM_PCMCIA) +=aml_pcmcia.o
+obj-$(CONFIG_AM_CI) +=aml_ci.o
+
+EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
+
diff --git a/drivers/amlogic/dvb_tv/amlci/aml_ci.c b/drivers/amlogic/dvb_tv/amlci/aml_ci.c
new file mode 100755
index 000000000000..e2c2e6dae194
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amlci/aml_ci.c
@@ -0,0 +1,485 @@
+
+#include <linux/signal.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <mach/gpio.h>
+#include <mach/gpio_data.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#include "aml_ci.h"
+#include "aml_iobus.h"
+
+static int aml_ci_debug=0;
+
+module_param_named(ci_debug, aml_ci_debug, int, 0644);
+MODULE_PARM_DESC(ci_debug, "enable verbose debug messages");
+
+#define pr_dbg(fmt, args...) do{if (aml_ci_debug) printk("CI: " fmt, ## args);}while(0)
+#define pr_error(fmt, args...) printk(KERN_ERR "CI: " fmt, ## args)
+
+
+static int aml_ci_read_attr_mem(struct dvb_ca_en50221 *en50221, int slot, int addr)
+{
+	//struct aml_ci *ci = en50221->data;
+	//struct aml_dvb *dvb = ci->ci_priv;
+
+	//pr_dbg("Slot(%d): Request Attribute Mem Read\n", slot);
+
+	if (slot != 0)
+		return -EINVAL;
+
+	return aml_iobus_attr_read(addr);
+}
+
+static int aml_ci_write_attr_mem(struct dvb_ca_en50221 *en50221, int slot, int addr, u8 data)
+{
+	//pr_dbg("Slot(%d): Request Attribute Mem Write\n", slot);
+
+	if (slot != 0)
+		return -EINVAL;
+
+	return aml_iobus_attr_write(addr, data);
+}
+
+static int aml_ci_read_cam_ctl(struct dvb_ca_en50221 *en50221, int slot, u8 addr)
+{
+	//pr_dbg("Slot(%d): Request CAM control Read\n", slot);
+
+	if (slot != 0)
+		return -EINVAL;
+
+	return aml_iobus_io_read(addr);
+}
+
+static int aml_ci_write_cam_ctl(struct dvb_ca_en50221 *en50221, int slot, u8 addr, u8 data)
+{
+
+	//pr_dbg("Slot(%d): Request CAM control Write\n", slot);
+
+	if (slot != 0)
+		return -EINVAL;
+
+	return aml_iobus_io_write(addr, data);
+}
+
+static int aml_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)
+{
+	struct aml_ci *ci = en50221->data;
+
+	pr_dbg("Slot(%d): Slot RESET\n", slot);
+	aml_pcmcia_reset(&ci->pc);
+	dvb_ca_en50221_camready_irq(en50221, 0);
+
+	return 0;
+}
+
+static int aml_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)
+{
+
+	pr_dbg("Slot(%d): Slot shutdown\n", slot);
+
+	return 0;
+}
+
+static int aml_ci_ts_control(struct dvb_ca_en50221 *en50221, int slot)
+{
+
+	pr_dbg("Slot(%d): TS control\n", slot);
+
+	return 0;
+}
+
+static int aml_ci_slot_status(struct dvb_ca_en50221 *en50221, int slot, int open)
+{
+	struct aml_ci *ci = en50221->data;
+
+	pr_dbg("Slot(%d): Poll Slot status\n", slot);
+
+	if (ci->pc.slot_state == MODULE_INSERTED) {
+		pr_dbg("CA Module present and ready\n");
+		return DVB_CA_EN50221_POLL_CAM_PRESENT | DVB_CA_EN50221_POLL_CAM_READY;
+	} else {
+		pr_error("CA Module not present or not ready\n");
+	}
+
+	return 0;
+}
+
+static int aml_ci_slot_ts(struct dvb_ca_en50221 *en50221, int slot)
+{
+	struct aml_ci *ci = en50221->data;
+
+	pr_dbg("Slot(%d): Slot ts\n", slot);
+
+}
+
+int aml_ci_init(struct platform_device *pdev, struct aml_dvb *dvb, struct aml_ci **cip)
+{
+	struct dvb_adapter *dvb_adapter	= &dvb->dvb_adapter;
+	struct aml_ci *ci = NULL;
+	int ca_flags = 0, result;
+	char buf[32];
+	int id = 0;
+	struct resource *res;
+
+	ci = kzalloc(sizeof(struct aml_ci), GFP_KERNEL);
+	if (!ci) {
+		pr_error("Out of memory!, exiting ..\n");
+		result = -ENOMEM;
+		goto err;
+	}
+
+	ci->id = 0;
+	ci->ts = 0xffff;
+	snprintf(buf, sizeof(buf), "ci%d_ts", id);
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
+	if(res){
+		int id = res->start;
+		aml_ts_source_t ts = AM_TS_SRC_TS0;
+
+		switch(id){
+			case 0:
+				ts = AM_TS_SRC_TS0;
+				break;
+			case 1:
+				ts = AM_TS_SRC_TS1;
+				break;
+			case 2:
+				ts = AM_TS_SRC_TS2;
+				break;
+			default:
+				break;
+		}
+
+		ci->ts = ts;
+	}
+
+	ci->priv		= dvb;
+	//aml->ci	= ci;
+	ca_flags		= DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE;
+	/* register CA interface */
+	ci->en50221.owner		= THIS_MODULE;
+	ci->en50221.read_attribute_mem	= aml_ci_read_attr_mem;
+	ci->en50221.write_attribute_mem	= aml_ci_write_attr_mem;
+	ci->en50221.read_cam_control	= aml_ci_read_cam_ctl;
+	ci->en50221.write_cam_control	= aml_ci_write_cam_ctl;
+	ci->en50221.slot_reset		= aml_ci_slot_reset;
+	ci->en50221.slot_shutdown	= aml_ci_slot_shutdown;
+	ci->en50221.slot_ts_enable	= aml_ci_ts_control;
+	ci->en50221.poll_slot_status	= aml_ci_slot_status;
+	ci->en50221.data		= ci;
+	ci->en50221.get_ts	= aml_ci_slot_ts;
+
+	mutex_init(&ci->ci_lock);
+
+	pr_dbg("Registering EN50221 device\n");
+	result = dvb_ca_en50221_init(dvb_adapter, &ci->en50221, ca_flags, 1);
+	if (result != 0) {
+		pr_error( "EN50221: Initialization failed <%d>\n", result);
+		goto err;
+	}
+
+	*cip = ci;
+
+	pr_dbg("Registered EN50221 device\n");
+
+	return 0;
+err:
+	kfree(ci);
+	return result;
+}
+EXPORT_SYMBOL_GPL(aml_ci_init);
+
+void aml_ci_exit(struct aml_ci *ci)
+{
+	pr_dbg("Unregistering EN50221 device\n");
+	if (ci)
+		dvb_ca_en50221_release(&ci->en50221);
+	kfree(ci);
+}
+EXPORT_SYMBOL_GPL(aml_ci_exit);
+
+
+
+static struct aml_ci *ci;
+
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+
+#define GPIO_CD1  PAD_GPIOX_9
+#define GPIO_CD2  PAD_GPIOX_9
+#define GPIO_RST  PAD_GPIOB_11
+#define GPIO_nPWR  PAD_GPIOX_12
+
+#define IRQ_GPIO_CD1  INT_GPIO_5
+
+static int io_setup(void)
+{
+	//gpioX09:
+		//reg5[10],Reg8[0]
+	//gpioX12:
+		//Reg3[21]
+	static pinmux_item_t ci_gpioX_pins[] = {
+	    {
+	        .reg = PINMUX_REG(5),
+	        .clrmask = 0x1 << 10
+	    },
+	    {
+	        .reg = PINMUX_REG(8),
+	        .clrmask = 0x1
+	    },
+	    {
+	        .reg = PINMUX_REG(3),
+	        .clrmask = 0x1 << 21
+	    },
+	    PINMUX_END_ITEM
+	};
+	static pinmux_set_t ci_gpioX_pinmux_set = {
+	    .chip_select = NULL,
+	    .pinmux = &ci_gpioX_pins[0]
+	};
+	pinmux_set(&ci_gpioX_pinmux_set);
+
+	//gpioB11:
+		//reg0[2],Reg3[6],Reg5[15]
+	static pinmux_item_t ci_gpioB_pins[] = {
+	    {
+	        .reg = PINMUX_REG(0),
+	        .clrmask = 0x1 << 2
+	    },
+	    {
+	        .reg = PINMUX_REG(3),
+	        .clrmask = 0x1 << 6
+	    },
+	    {
+	        .reg = PINMUX_REG(5),
+	        .clrmask = 0x1 << 15
+	    },
+	    PINMUX_END_ITEM
+	};
+	static pinmux_set_t ci_gpioB_pinmux_set = {
+	    .chip_select = NULL,
+	    .pinmux = &ci_gpioB_pins[0]
+	};
+	pinmux_set(&ci_gpioB_pinmux_set);
+
+	return 0;
+}
+static int io_power(int enable)
+{
+	int ret = 0;
+	ret = gpio_out(GPIO_nPWR, enable?1:0);
+	return ret;
+}
+static int io_reset(int enable)
+{
+	int ret = 0;
+	ret = gpio_out(GPIO_RST, enable?1:0);
+	return ret;
+}
+static int io_init_irq(int flag)
+{
+	gpio_set_status(GPIO_CD1, gpio_status_in);
+	if (flag == IRQF_TRIGGER_RISING)
+		gpio_irq_set(GPIO_CD1, GPIO_IRQ(IRQ_GPIO_CD1-INT_GPIO_0, GPIO_IRQ_RISING));
+	else if (flag == IRQF_TRIGGER_FALLING)
+		gpio_irq_set(GPIO_CD1, GPIO_IRQ(IRQ_GPIO_CD1-INT_GPIO_0, GPIO_IRQ_FALLING));
+	else if (flag == IRQF_TRIGGER_HIGH)
+		gpio_irq_set(GPIO_CD1, GPIO_IRQ(IRQ_GPIO_CD1-INT_GPIO_0, GPIO_IRQ_HIGH));
+	else if (flag == IRQF_TRIGGER_LOW)
+		gpio_irq_set(GPIO_CD1, GPIO_IRQ(IRQ_GPIO_CD1-INT_GPIO_0, GPIO_IRQ_LOW));
+	else
+		return -1;
+	return 0;
+}
+static int io_get_cd1(void)
+{
+	int ret = 0;
+	ret = gpio_in_get(GPIO_CD1);
+	return ret;
+}
+static int io_get_cd2(void)
+{
+	int ret = 0;
+	ret = gpio_in_get(GPIO_CD2);
+	return ret;
+}
+
+static int cam_plugin(struct aml_pcmcia *pc, int plugin)
+{
+	struct aml_ci *ci = (struct aml_ci *)pc->priv;
+
+	if(plugin)
+		dvb_ca_en50221_camchange_irq(&ci->en50221, 0, DVB_CA_EN50221_CAMCHANGE_INSERTED);
+	else
+		dvb_ca_en50221_camchange_irq(&ci->en50221, 0, DVB_CA_EN50221_CAMCHANGE_REMOVED);
+	return 0;
+}
+
+static ssize_t aml_ci_ts_show(struct class *class, struct class_attribute *attr,char *buf)
+{
+	int ret;
+	struct aml_ci *ci = container_of(class,struct aml_ci,class);
+	ret = sprintf(buf, "ts%d\n", ci->ts);
+	return ret;
+}
+
+static struct class_attribute amlci_class_attrs[] = {
+	__ATTR(ts,  S_IRUGO | S_IWUSR, aml_ci_ts_show, NULL),
+	__ATTR_NULL
+};
+
+static int aml_ci_register_class(struct aml_ci *ci)
+{
+#define CLASS_NAME_LEN 48
+	int ret;
+	struct class *clp;
+
+	clp = &(ci->class);
+
+	clp->name = kzalloc(CLASS_NAME_LEN,GFP_KERNEL);
+	if (!clp->name)
+		return -ENOMEM;
+
+	snprintf((char *)clp->name, CLASS_NAME_LEN, "amlci-%d", ci->id);
+	clp->owner = THIS_MODULE;
+	clp->class_attrs = amlci_class_attrs;
+	ret = class_register(clp);
+	if (ret)
+		kfree(clp->name);
+
+	return 0;
+}
+
+static int aml_ci_unregister_class(struct aml_ci *ci)
+{
+	class_unregister(&ci->class);
+	kzfree(ci->class.name);
+	return 0;
+}
+
+void aml_pcmcia_alloc(struct aml_pcmcia **pcmcia)
+{
+	*pcmcia = &ci->pc;
+	(*pcmcia)->irq = IRQ_GPIO_CD1;
+	(*pcmcia)->init_irq = io_init_irq;
+	(*pcmcia)->get_cd1 = io_get_cd1;
+	(*pcmcia)->get_cd2 = io_get_cd2;
+	(*pcmcia)->pwr = io_power;
+	(*pcmcia)->rst = io_reset;
+	(*pcmcia)->pcmcia_plugin = cam_plugin;
+	(*pcmcia)->slot_state = MODULE_XTRACTED;
+	(*pcmcia)->priv = ci;
+}
+
+static int aml_ci_probe(struct platform_device *pdev)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_pcmcia *pc;
+	int err=0;
+
+	printk("Amlogic CI Init\n");
+
+	if((err = aml_ci_init(pdev, dvb, &ci))<0)
+		return err;
+	if((err=aml_iobus_init())<0)
+		goto fail1;
+	io_setup();
+	aml_pcmcia_alloc(&pc);
+	if((err=aml_pcmcia_init(pc))<0)
+		goto fail2;
+
+	platform_set_drvdata(pdev, ci);
+	aml_ci_register_class(ci);
+
+	return 0;
+
+fail2:
+	aml_iobus_exit();
+fail1:
+	aml_ci_exit(ci);
+	return err;
+
+}
+
+static int aml_ci_remove(struct platform_device *pdev)
+{
+	aml_ci_unregister_class(ci);
+	platform_set_drvdata(pdev, NULL);
+
+	aml_pcmcia_exit(&ci->pc);
+	aml_iobus_exit();
+
+	aml_ci_exit(ci);
+
+	return 0;
+}
+
+static int aml_ci_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	printk("Amlogic CI Suspend!\n");
+	aml_pcmcia_exit(&ci->pc);
+	aml_iobus_exit();
+
+	return 0;
+}
+
+static int aml_ci_resume(struct platform_device *pdev)
+{
+	struct aml_pcmcia *pc;
+	int err=0;
+
+	printk("Amlogic CI Resume!\n");
+	if((err=aml_iobus_init())<0)
+		goto fail1;
+	io_setup();
+	aml_pcmcia_alloc(&pc);
+	if((err=aml_pcmcia_init(pc))<0)
+		goto fail2;
+	return 0;
+
+fail2:
+	aml_iobus_exit();
+fail1:
+	aml_ci_exit(ci);
+	return err;
+}
+
+static struct platform_driver aml_ci_driver = {
+	.probe		= aml_ci_probe,
+	.remove		= aml_ci_remove,
+	.suspend        = aml_ci_suspend,
+	.resume         = aml_ci_resume,
+	.driver		= {
+		.name	= "amlogic-ci",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static int __init aml_ci_mod_init(void)
+{
+	return platform_driver_register(&aml_ci_driver);
+}
+
+static void __exit aml_ci_mod_exit(void)
+{
+	printk("Amlogic CI Exit\n");
+	platform_driver_unregister(&aml_ci_driver);
+}
+
+
+
+module_init(aml_ci_mod_init);
+module_exit(aml_ci_mod_exit);
+
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/amlogic/dvb_tv/amlci/aml_ci.h b/drivers/amlogic/dvb_tv/amlci/aml_ci.h
new file mode 100755
index 000000000000..349d5a2734c0
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amlci/aml_ci.h
@@ -0,0 +1,23 @@
+#ifndef __AML_CI_H_
+#define __AML_CI_H_
+
+#include "../aml_dvb.h"
+#include "aml_pcmcia.h"
+#include "dvb_ca_en50221.h"
+
+
+struct aml_ci {
+	struct dvb_ca_en50221		en50221;
+	struct aml_pcmcia			pc;
+	struct mutex				ci_lock;
+	int                                       ts;
+	void						*priv;
+	int                                       id;
+	struct class                        class;
+};
+
+extern int aml_ci_init(struct platform_device *pdev, struct aml_dvb *dvb, struct aml_ci **cip);
+extern void aml_ci_exit(struct aml_ci *ci);
+
+#endif /* __AML_CI_H_ */
+
diff --git a/drivers/amlogic/dvb_tv/amlci/aml_iobus.c b/drivers/amlogic/dvb_tv/amlci/aml_iobus.c
new file mode 100755
index 000000000000..f7aba47a9bfa
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amlci/aml_iobus.c
@@ -0,0 +1,580 @@
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <plat/io.h>
+#include <mach/register.h>
+#include <mach/pinmux.h>
+
+#include "aml_iobus.h"
+
+static int aml_iobus_debug=0;
+module_param_named(iobus_debug, aml_iobus_debug, int, 0644);
+MODULE_PARM_DESC(iobus_debug, "enable verbose debug messages");
+
+static spinlock_t iobus_lock;
+
+#define pr_dbg(fmt, args...) do{if (aml_iobus_debug) printk("IOBUS: " fmt, ## args);}while(0)
+#define pr_error(fmt, args...) printk(KERN_ERR "IOBUS: " fmt, ## args)
+
+#define event_length_bit  24
+#define bus_1st_sel_1_bit 22  // 00-gpio, 01-reserved, 10-addr, 11-data
+#define bus_2nd_sel_1_bit 20
+#define bus_1st_sel_0_bit 18
+#define bus_2nd_sel_0_bit 16
+
+#define clock_divide_ext_bit   24
+#define s_bus_start_bit        20
+#define no_sclk_on_pin_bit     19
+#define invert_sclk_in_bit     18
+#define sdata_send_busy_bit    17
+#define one_sdata_received_bit 16
+#define sdata_parity_bit       15
+#define sdata_send_type_bit    14
+#define sdata_receive_type_bit 13
+#define invert_request_out_bit 12
+#define request_out_sel_bit     8
+#define stop_request_count_bit  0
+
+#define bus_width_1_bit 28
+#define bus_start_pin_1_bit 24
+#define bus_sel_chang_point_1_bit 16
+#define bus_width_0_bit 12
+#define bus_start_pin_0_bit 8
+#define bus_sel_chang_point_0_bit 0
+
+#define clock_divide_bit      24
+#define clock_output_sel_bit  20
+#define inc_event_addr_bit       19
+#define async_fifo_endian_bit    18
+#define send_to_async_fifo_bit   17
+#define data_in_serial_lsb_bit   16
+#define invert_no_wait_condition_2_0_bit   15
+#define invert_no_wait_condition_2_1_bit   14
+#define invert_no_wait_condition_2_2_bit   13
+#define invert_data_bus_bit   12
+#define invert_clock_in_bit   11
+#define event_wait_clk_en_bit 10
+#define data_in_serial_bit     9
+#define invert_data_in_clk_bit 8
+#define data_in_begin_bit      4
+#define data_in_clk_sel_bit    0
+
+#define     no_wait_condition_0_bit  28
+#define     no_wait_condition_1_bit  24
+#define     no_wait_condition_2_bit  20
+#define     irq_input_sel_bit        16
+#define     interrupt_status_bit     13
+#define     enable_sdata_irq         12
+#define     invert_irq_0_bit         11
+#define     invert_irq_1_bit         10
+#define     enable_transfer_end_irq   9
+#define     enable_second_ext_irq_bit 8
+#define     no_wait_condition_check_point_bit 0
+
+#define SETnXcfg()	\
+	({ \
+		aml_set_reg32_bits(P_PREG_PAD_GPIO0_EN_N, 0, 28, 2);/*GPIOA28~29 OUT*/ \
+		aml_set_reg32_bits(P_PREG_PAD_GPIO1_EN_N, 1, 12, 1);/*GPIOB12 IN*/ \
+	})
+#define SETAcfg()		aml_set_reg32_bits(P_PREG_PAD_GPIO0_EN_N, 0, 0, 12) /*GPIOA0~11 OUT*/
+
+#define SETnCE(v)		aml_set_reg32_bits(P_PREG_PAD_GPIO0_O, (v), 29, 1)
+#define SETnREG(v)	aml_set_reg32_bits(P_PREG_PAD_GPIO0_O, (v), 28, 1)
+#define GETIREQ()		aml_get_reg32_bits(P_PREG_PAD_GPIO1_I, 12, 1)
+
+#define EN(c)		SETn##c(0)
+#define DIS(c)	SETn##c(1)
+
+#define RDDELAY(n) msleep(n)
+#define WRDELAY(n) msleep(n)
+
+
+// For Attr Write Signal
+#define CIPLUS_WR_OUTOUT_CF0            0x000004f5      //WR  0x0000040f
+#define CIPLUS_WR_OUTOUT_CF1            0x0001ffff      //RD
+#define CIPLUS_WR_OUTOUT_CF2            0x0002ffff
+#define CIPLUS_WR_OUTOUT_CF3            0x0003ffff
+// For Attr Read Signal
+#define CIPLUS_RD_OUTOUT_CF0            0x0000ffff
+#define CIPLUS_RD_OUTOUT_CF1            0x000104f5
+#define CIPLUS_RD_OUTOUT_CF2            0x0002ffff
+#define CIPLUS_RD_OUTOUT_CF3            0x0003ffff
+// For Attr Write Bus
+#define CIPLUS_WR_BUS_CONFIG ( \
+                                (3  << bus_width_1_bit) \
+                               |(13 << bus_start_pin_1_bit ) \
+                               |(3  << bus_sel_chang_point_1_bit ) \
+                               |(8  << bus_width_0_bit) \
+                               |(5  << bus_start_pin_0_bit ) \
+                               |(3  << bus_sel_chang_point_0_bit ) \
+                             )
+// For Attr Read Bus
+#define CIPLUS_RD_BUS_CONFIG ( \
+                                (3  << bus_width_1_bit) \
+                               |(13 << bus_start_pin_1_bit ) \
+                               |(3  << bus_sel_chang_point_1_bit ) \
+                               |(8  << bus_width_0_bit) \
+                               |(5  << bus_start_pin_0_bit ) \
+                               |(3  << bus_sel_chang_point_0_bit ) \
+                             )
+void ci_wr_config(void)
+{
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_WR_OUTOUT_CF0);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_WR_OUTOUT_CF1);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_WR_OUTOUT_CF2);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_WR_OUTOUT_CF3);
+}
+void ci_rd_config(void)
+{
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_RD_OUTOUT_CF0);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_RD_OUTOUT_CF1);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_RD_OUTOUT_CF2);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_RD_OUTOUT_CF3);
+}
+
+// For IO Write Signal
+#define CIPLUS_IOWR_OUTOUT_CF0            0x0000ffff
+#define CIPLUS_IOWR_OUTOUT_CF1            0x0001ffff
+#define CIPLUS_IOWR_OUTOUT_CF2            0x0002ffff       // IORD
+#define CIPLUS_IOWR_OUTOUT_CF3            0x000304f5       // IOWR
+// For IO Read Signal
+#define CIPLUS_IORD_OUTOUT_CF0            0x0000ffff
+#define CIPLUS_IORD_OUTOUT_CF1            0x0001ffff
+#define CIPLUS_IORD_OUTOUT_CF2            0x000204f5
+#define CIPLUS_IORD_OUTOUT_CF3            0x0003ffff
+// For IO Write Bus
+#define CIPLUS_IOWR_BUS_CONFIG ( \
+                                (2  << bus_width_1_bit) \
+                               |(13 << bus_start_pin_1_bit ) \
+                               |(3  << bus_sel_chang_point_1_bit ) \
+                               |(8  << bus_width_0_bit) \
+                               |(5  << bus_start_pin_0_bit ) \
+                               |(3  << bus_sel_chang_point_0_bit ) \
+                             )
+// For IO Read Bus
+#define CIPLUS_IORD_BUS_CONFIG ( \
+                                (2  << bus_width_1_bit) \
+                               |(13 << bus_start_pin_1_bit ) \
+                               |(3  << bus_sel_chang_point_1_bit ) \
+                               |(8  << bus_width_0_bit) \
+                               |(5  << bus_start_pin_0_bit ) \
+                               |(3  << bus_sel_chang_point_0_bit ) \
+                             )
+void ci_iowr_config(void)
+{
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_IOWR_OUTOUT_CF0);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_IOWR_OUTOUT_CF1);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_IOWR_OUTOUT_CF2);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_IOWR_OUTOUT_CF3);
+}
+void ci_iord_config(void)
+{
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_IORD_OUTOUT_CF0);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_IORD_OUTOUT_CF1);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_IORD_OUTOUT_CF2);
+	aml_write_reg32(P_STREAM_OUTPUT_CONFIG, CIPLUS_IORD_OUTOUT_CF3);
+}
+
+#define CIPLUS_W_EVENT_INFO ( \
+                                (254     << event_length_bit ) \
+                               |(2      << bus_1st_sel_1_bit) \
+                               |(2      << bus_2nd_sel_1_bit) \
+                               |(1      << bus_1st_sel_0_bit) \
+                               |(3      << bus_2nd_sel_0_bit) \
+                               |(0xffff ) \
+                             )
+#define CIPLUS_R_EVENT_INFO ( \
+                                (245     << event_length_bit ) \
+                               |(2      << bus_1st_sel_1_bit) \
+                               |(2      << bus_2nd_sel_1_bit) \
+                               |(1      << bus_1st_sel_0_bit) \
+                               |(1      << bus_2nd_sel_0_bit) \
+                               |(0xffff ) \
+                             )
+#define CIPLUS_DATA_IN_OE ( \
+                                (1  << data_in_clk_sel_bit) \
+                               |(5   <<data_in_begin_bit) \
+                             )
+#define CIPLUS_DATA_IN_IORD ( \
+                                (2  << data_in_clk_sel_bit) \
+                               |(5   <<data_in_begin_bit) \
+                             )
+
+unsigned int aml_iobus_attr_read(unsigned int addr)
+{
+	unsigned int event_ctrl;
+	unsigned int data;
+	unsigned char val;
+	unsigned int addrl = addr&0x7;
+	unsigned char addrh = addr >> 3;
+
+	aml_set_reg32_bits(P_PREG_PAD_GPIO0_O, (addrh&0xfff), 0, 12);
+
+	ci_rd_config();
+	// Config bus, data/addr
+	aml_write_reg32(P_STREAM_BUS_CONFIG, CIPLUS_RD_BUS_CONFIG);
+	// Config event info
+	aml_write_reg32(P_STREAM_EVENT_INFO, CIPLUS_R_EVENT_INFO);
+	// Config data_in
+	aml_write_reg32(P_STREAM_DATA_IN_CONFIG, CIPLUS_DATA_IN_OE);
+
+	// Config event ctrl
+	event_ctrl =  (addrl<<24)      // address
+			|(0<<16)         // data
+			|(0<<1)          // repeat 0 times, total 1 times
+			|1;              // start event
+	aml_write_reg32(P_STREAM_EVENT_CTL, event_ctrl);
+
+	// Test Rd Finish, and Close Stream Interface
+	while(1){
+		if((aml_read_reg32(P_STREAM_EVENT_CTL) & 0x00000001) == 0) break;
+	}
+
+	data = aml_read_reg32(P_STREAM_EVENT_CTL);
+	val  = (data>>16);
+	aml_write_reg32(P_STREAM_EVENT_INFO, 0x0000ffff);
+//	printk("Read : ATTR[0x%x] = 0x%x\n", addr, val);
+	return val;
+}
+EXPORT_SYMBOL(aml_iobus_attr_read);
+
+int aml_iobus_attr_write(unsigned int addr, unsigned char val)
+{
+	unsigned int event_ctrl;
+	unsigned int addrl = addr&0x7;
+	unsigned char addrh = addr >> 3;
+
+	aml_set_reg32_bits(P_PREG_PAD_GPIO0_O, (addrh&0xfff), 0, 12);
+
+	ci_wr_config();
+	// Config bus, data/addr
+	aml_write_reg32(P_STREAM_BUS_CONFIG, CIPLUS_WR_BUS_CONFIG);
+	// Config event info
+	aml_write_reg32(P_STREAM_EVENT_INFO, CIPLUS_W_EVENT_INFO);
+
+	// Config event ctrl
+	event_ctrl =  (addrl<<24)      // address
+			|((val)<<16)    // data
+			|(0<<1)          // repeat 0 times, total 1 times
+			|1;              // start event
+	aml_write_reg32(P_STREAM_EVENT_CTL, event_ctrl);
+
+	// Test Wr Finish, and Close STREAM Interface
+	while(1){
+		if((aml_read_reg32(P_STREAM_EVENT_CTL) & 0x00000001) == 0) break;
+	}
+
+	aml_write_reg32(P_STREAM_EVENT_INFO, 0x0000ffff);
+	printk("Write : ATTR[0x%x] = 0x%x\n", addr, val);
+	return 0;
+}
+EXPORT_SYMBOL(aml_iobus_attr_write);
+
+unsigned int aml_iobus_io_read(unsigned char addr)
+{
+	unsigned int event_ctrl;
+	unsigned int data;
+	unsigned char val;
+
+	ci_iord_config();
+	// Config bus, data/addr
+	aml_write_reg32(P_STREAM_BUS_CONFIG, CIPLUS_IORD_BUS_CONFIG);
+	// Config event info
+	aml_write_reg32(P_STREAM_EVENT_INFO, CIPLUS_R_EVENT_INFO);
+	// Config data_in
+	aml_write_reg32(P_STREAM_DATA_IN_CONFIG, CIPLUS_DATA_IN_IORD);
+
+	// Config event ctrl
+	event_ctrl =  (addr<<24)      // address
+			|(0<<16)         // data
+			|(0<<1)          // repeat 0 times, total 1 times
+			|1;              // start event
+	aml_write_reg32(P_STREAM_EVENT_CTL, event_ctrl);
+
+	// Test Rd Finish, and Close Stream Interface
+	while(1){
+		if((aml_read_reg32(P_STREAM_EVENT_CTL) & 0x00000001) == 0) break;
+	}
+
+	data = aml_read_reg32(P_STREAM_EVENT_CTL);
+	val  = (data>>16);
+	aml_write_reg32(P_STREAM_EVENT_INFO, 0x0000ffff);
+//	printk("Read : IO[0x%x] = 0x%x\n", addr, val);
+	return val;
+}
+EXPORT_SYMBOL(aml_iobus_io_read);
+
+int aml_iobus_io_write(unsigned char addr, unsigned char val)
+{
+	unsigned int event_ctrl;
+
+	ci_iowr_config();
+	// Config bus, data/addr
+	aml_write_reg32(P_STREAM_BUS_CONFIG, CIPLUS_IOWR_BUS_CONFIG);
+	// Config event info
+	aml_write_reg32(P_STREAM_EVENT_INFO, CIPLUS_W_EVENT_INFO);
+
+	// Config event ctrl
+	event_ctrl =  (addr<<24)      // address
+			|((val)<<16)    // data
+			|(0<<1)          // repeat 0 times, total 1 times
+			|1;              // start event
+	aml_write_reg32(P_STREAM_EVENT_CTL, event_ctrl);
+
+	// Test Wr Finish, and Close STREAM Interface
+	while(1){
+		if((aml_read_reg32(P_STREAM_EVENT_CTL) & 0x00000001) == 0) break;
+	}
+
+	aml_write_reg32(P_STREAM_EVENT_INFO, 0x0000ffff);
+//	printk("Write : IO[0x%x] = 0x%x\n", addr, val);
+	return 0;
+}
+EXPORT_SYMBOL(aml_iobus_io_write);
+
+
+static int io_set_pinmux(void)
+{
+	//gpioA00-A11 gpioA28-A29:
+		//reg0[6-10],reg3[0-5],reg4[18-21],reg7[16-17],reg6[20-23],reg8[11]
+	//streamif00-15:
+		//reg7[0-15]
+	static pinmux_item_t bus_gpioA_pins[] = {
+	    {
+	        .reg = PINMUX_REG(0),
+	        .clrmask = 0x1f << 6
+	    },
+	    {
+	        .reg = PINMUX_REG(3),
+	        .clrmask = 0x3f
+	    },
+	    {
+	        .reg = PINMUX_REG(4),
+	        .clrmask = 0xf << 18
+	    },
+	    {
+	        .reg = PINMUX_REG(7),
+	        .setmask = 0xffff
+	    },
+	    {
+	        .reg = PINMUX_REG(7),
+	        .clrmask = 0x3 << 16
+	    },
+	    {
+	        .reg = PINMUX_REG(6),
+	        .clrmask = 0xf << 20
+	    },
+	    {
+	        .reg = PINMUX_REG(8),
+	        .clrmask = 0x1 << 11
+	    },
+	    PINMUX_END_ITEM
+	};
+	static pinmux_set_t bus_gpioA_pinmux_set = {
+	    .chip_select = NULL,
+	    .pinmux = &bus_gpioA_pins[0]
+	};
+	pinmux_set(&bus_gpioA_pinmux_set);
+
+	//gpioB12:
+		//reg0[2],reg3[17],reg5[5]
+	static pinmux_item_t bus_gpioB_pins[] = {
+	    {
+	        .reg = PINMUX_REG(0),
+	        .clrmask = 0x1 << 2
+	    },
+	    {
+	        .reg = PINMUX_REG(3),
+	        .clrmask = 0x1 << 17
+	    },
+	    {
+	        .reg = PINMUX_REG(5),
+	        .clrmask = 0x1 << 5
+	    },
+	    PINMUX_END_ITEM
+	};
+	static pinmux_set_t bus_gpioB_pinmux_set = {
+	    .chip_select = NULL,
+	    .pinmux = &bus_gpioB_pins[0]
+	};
+	pinmux_set(&bus_gpioB_pinmux_set);
+
+	return 0;
+}
+
+int aml_iobus_init(void)
+{
+	aml_write_reg32(P_STREAM_EVENT_INFO, 0xffff);
+	io_set_pinmux();
+
+	/*init gpio direction*/
+	SETnXcfg();
+	SETAcfg();
+
+	/*init gpio states*/
+	EN(REG);
+	EN(CE);
+
+	spin_lock_init(&iobus_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(aml_iobus_init);
+
+int aml_iobus_exit(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(aml_iobus_exit);
+
+
+
+#include <linux/device.h>
+#include <linux/slab.h>
+
+static ssize_t aml_iobus_write_help(struct class *class, struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "echo XXXX > %s\n\tXXXX - value in hex.\n", attr->attr.name);
+	return ret;
+}
+static ssize_t aml_iobus_iow_help(struct class *class, struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "echo (r|w)(i|a) addr data > %s\n\taddr, data - value in hex.\n", attr->attr.name);
+	return ret;
+}
+static ssize_t aml_iobus_test_addr_write(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	unsigned int d = simple_strtol(buf,0,16);
+	printk("AD:%x\n", d);
+//	SETADDR(d);
+	return size;
+}
+static ssize_t aml_iobus_test_data_write(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	unsigned int d = simple_strtol(buf,0,16);
+	printk("DA:%x\n", d);
+//	SETDATA(d);
+	return size;
+}
+static ssize_t aml_iobus_test_io_write(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+    int n = 0;
+    char *buf_orig, *ps, *token;
+    char *parm[3];
+    unsigned int addr = 0, val = 0, retval = 0;
+
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	ps = buf_orig;
+	while (1) {
+		token = strsep(&ps, " \n");
+		if (token == NULL)
+			break;
+		if (*token == '\0')
+			continue;
+        parm[n++] = token;
+	}
+
+    if ((n > 0) && (strlen(parm[0]) != 2))
+    {
+        pr_err("invalid command\n");
+        kfree(buf_orig);
+        return size;
+    }
+
+    if ((parm[0][0] == 'r'))
+    {
+        if (n != 2)
+        {
+            pr_err("read: invalid parameter\n");
+            kfree(buf_orig);
+            return size;
+        }
+        addr = simple_strtol(parm[1], NULL, 16);
+        pr_err("%s 0x%x\n", parm[0], addr);
+        switch (parm[0][1])
+        {
+            case 'i':
+                retval = aml_iobus_io_read(addr);
+                break;
+            case 'a':
+                retval = aml_iobus_attr_read(addr);
+                break;
+	     default:
+		 	break;
+        }
+        pr_info("%s: 0x%x --> 0x%x\n", parm[0], addr, retval);
+    }
+    else if ((parm[0][0] == 'w'))
+    {
+        if (n != 3)
+        {
+            pr_err("write: invalid parameter\n");
+            kfree(buf_orig);
+            return size;
+        }
+        addr = simple_strtol(parm[1], NULL, 16);
+        val  = simple_strtol(parm[2], NULL, 16);
+        pr_err("%s 0x%x 0x%x", parm[0], addr, val);
+        switch (parm[0][1])
+        {
+            case 'i':
+	        retval = aml_iobus_io_write(addr, val);
+                break;
+            case 'a':
+	        retval = aml_iobus_attr_write(addr, val);
+                break;
+	     default:
+		 	break;
+        }
+        pr_info("%s: 0x%x <-- 0x%x\n", parm[0], addr, retval);
+    }
+    else
+    {
+        pr_err("invalid command\n");
+    }
+
+	kfree(buf_orig);
+    return size;
+}
+
+static struct class_attribute aml_iobus_class_attrs[] = {
+    __ATTR(ad,  S_IRUGO | S_IWUSR, aml_iobus_write_help, aml_iobus_test_addr_write),
+    __ATTR(da,  S_IRUGO | S_IWUSR, aml_iobus_write_help, aml_iobus_test_data_write),
+    __ATTR(io,  S_IRUGO | S_IWUSR, aml_iobus_iow_help, aml_iobus_test_io_write),
+    __ATTR_NULL
+};
+
+static struct class aml_iobus_class = {
+    .name = "aml_iobus_test",
+    .class_attrs = aml_iobus_class_attrs,
+};
+
+static int __init aml_iobus_mod_init(void)
+{
+	printk("Amlogic IOBUS Init\n");
+	class_register(&aml_iobus_class);
+	return 0;
+}
+
+static void __exit aml_iobus_mod_exit(void)
+{
+	printk("Amlogic IOBUS Exit\n");
+	class_unregister(&aml_iobus_class);
+}
+
+module_init(aml_iobus_mod_init);
+module_exit(aml_iobus_mod_exit);
+
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/amlogic/dvb_tv/amlci/aml_iobus.h b/drivers/amlogic/dvb_tv/amlci/aml_iobus.h
new file mode 100755
index 000000000000..94531b0c2743
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amlci/aml_iobus.h
@@ -0,0 +1,15 @@
+
+#ifndef _AML_IOBUS_
+#define _AML_IOBUS_
+
+int aml_iobus_init(void);
+int aml_iobus_exit(void);
+
+unsigned int aml_iobus_io_read(unsigned char addr);
+int aml_iobus_io_write(unsigned char addr, unsigned char val);
+
+unsigned int aml_iobus_attr_read(unsigned int addr);
+int aml_iobus_attr_write(unsigned int addr, unsigned char val);
+
+#endif/*_AML_IOBUS_*/
+
diff --git a/drivers/amlogic/dvb_tv/amlci/aml_pcmcia.c b/drivers/amlogic/dvb_tv/amlci/aml_pcmcia.c
new file mode 100755
index 000000000000..e2b2e07c952a
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amlci/aml_pcmcia.c
@@ -0,0 +1,194 @@
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <mach/gpio_data.h>
+
+#include "aml_pcmcia.h"
+
+static int aml_pcmcia_debug=0;
+
+module_param_named(pcmcia_debug, aml_pcmcia_debug, int, 0644);
+MODULE_PARM_DESC(pcmcia_debug, "enable verbose debug messages");
+
+#define pr_dbg(fmt, args...) do{if (aml_pcmcia_debug) printk("PCMCIA: " fmt, ## args);}while(0)
+#define pr_error(fmt, args...) printk(KERN_ERR "PCMCIA: " fmt, ## args)
+
+
+static int pcmcia_plugin(struct aml_pcmcia *pc)
+{
+	if (pc->slot_state == MODULE_XTRACTED) {
+		pr_dbg(" CAM Plugged IN: Adapter(%d) Slot(0)\n", 0);
+		udelay(50);
+		aml_pcmcia_reset(pc);
+		/*wait unplug*/
+		pc->init_irq(IRQF_TRIGGER_RISING);
+		udelay(500);
+		pc->slot_state = MODULE_INSERTED;
+	}
+	aml_pcmcia_reset(pc);
+	udelay(100);
+	pc->pcmcia_plugin(pc, 1);
+
+	return 0;
+}
+
+static int pcmcia_unplug(struct aml_pcmcia *pc)
+{
+	if (pc->slot_state == MODULE_INSERTED) {
+		pr_dbg(" CAM Unplugged: Adapter(%d) Slot(0)\n", 0);
+		udelay(50);
+		aml_pcmcia_reset(pc);
+		/*wait plugin*/
+		pc->init_irq(IRQF_TRIGGER_FALLING);
+		udelay(500);
+		pc->slot_state = MODULE_XTRACTED;
+	}
+	udelay(100);
+	pc->pcmcia_plugin(pc, 0);
+
+	return 0;
+}
+
+
+static irqreturn_t pcmcia_irq_handler(int irq, void *dev_id)
+{
+	struct aml_pcmcia *pc = (struct aml_pcmcia *)dev_id;
+	disable_irq_nosync(pc->irq);
+	schedule_work(&pc->pcmcia_work);
+	enable_irq(pc->irq);
+	return IRQ_HANDLED;
+}
+
+static void aml_pcmcia_work(struct work_struct *work)
+{
+	int cd1, cd2;
+	struct aml_pcmcia *pc = container_of(work, struct aml_pcmcia, pcmcia_work);
+
+	cd1 = pc->get_cd1();
+	cd2 = pc->get_cd2();
+
+	if(cd1 != cd2) {
+		pr_error("CAM card not inerted correctly or CAM card not supported.\n");
+	} else {
+		if (!cd1) {
+			pr_error("Adapter(%d) Slot(0): CAM Plugin\n", 0);
+			pcmcia_plugin(pc);
+		} else {
+			pr_error("Adapter(%d) Slot(0): CAM Unplug\n", 0);
+			pcmcia_unplug(pc);
+		}
+	}
+}
+
+static struct aml_pcmcia *pc_cur;
+
+int aml_pcmcia_init(struct aml_pcmcia *pc)
+{
+	int err=0;
+
+	pc->rst(0);
+	/*power on*/
+	pc->pwr(0);
+	/*assuming cam unpluged, config the INT to waiting-for-plugin mode*/
+	pc->init_irq(IRQF_TRIGGER_LOW);
+
+	INIT_WORK(&pc->pcmcia_work, aml_pcmcia_work);
+
+	err = request_irq(INT_GPIO_5, pcmcia_irq_handler, IRQF_DISABLED, "aml-pcmcia", pc);
+
+	if (err != 0) {
+		pr_error("ERROR: IRQ registration failed ! <%d>", err);
+		return -ENODEV;
+	}
+
+	pc_cur = pc;
+	return 0;
+}
+EXPORT_SYMBOL(aml_pcmcia_init);
+
+int aml_pcmcia_exit(struct aml_pcmcia *pc)
+{
+	free_irq(pc->irq, pc);
+	return 0;
+}
+EXPORT_SYMBOL(aml_pcmcia_exit);
+
+int aml_pcmcia_reset(struct aml_pcmcia *pc)
+{
+	pr_dbg("CAM RESET-->\n");
+	udelay(500); /* Wait.. */
+	pc->rst(1);
+	udelay(500);
+	pc->rst(0);
+	msleep(100);
+	return 0;
+}
+EXPORT_SYMBOL(aml_pcmcia_reset);
+
+
+
+static ssize_t aml_pcmcia_test_cmd(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	printk("pcmcia cmd: %s\n", buf);
+	if(pc_cur) {
+		if(memcmp(buf, "reset", 5)==0)
+			aml_pcmcia_reset(pc_cur);
+		else if(memcmp(buf, "on", 2)==0)
+			pc_cur->pwr(1);
+		else if(memcmp(buf, "off", 3)==0)
+			pc_cur->pwr(0);
+		else if(memcmp(buf, "poll", 4)==0)
+			schedule_work(&pc_cur->pcmcia_work);
+		else if(memcmp(buf, "intr", 4)==0)
+			pc_cur->init_irq(IRQF_TRIGGER_RISING);
+		else if(memcmp(buf, "intf", 4)==0)
+			pc_cur->init_irq(IRQF_TRIGGER_FALLING);
+	}
+	return size;
+}
+
+static struct class_attribute aml_pcmcia_class_attrs[] = {
+    __ATTR(cmd,  S_IRUGO | S_IWUSR, NULL, aml_pcmcia_test_cmd),
+    __ATTR_NULL
+};
+
+static struct class aml_pcmcia_class = {
+    .name = "aml_pcmcia_test",
+    .class_attrs = aml_pcmcia_class_attrs,
+};
+
+static int __init aml_pcmcia_mod_init(void)
+{
+	printk("Amlogic PCMCIA Init\n");
+
+	class_register(&aml_pcmcia_class);
+
+	return 0;
+}
+
+static void __exit aml_pcmcia_mod_exit(void)
+{
+	printk("Amlogic PCMCIA Exit\n");
+
+	class_unregister(&aml_pcmcia_class);
+}
+
+
+
+module_init(aml_pcmcia_mod_init);
+module_exit(aml_pcmcia_mod_exit);
+
+MODULE_LICENSE("GPL");
+
+
+
+
diff --git a/drivers/amlogic/dvb_tv/amlci/aml_pcmcia.h b/drivers/amlogic/dvb_tv/amlci/aml_pcmcia.h
new file mode 100755
index 000000000000..c5ee530edfed
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amlci/aml_pcmcia.h
@@ -0,0 +1,32 @@
+
+#ifndef _AML_PCMCIA_
+#define _AML_PCMCIA_
+
+enum aml_slot_state {
+	MODULE_INSERTED			= 3,
+	MODULE_XTRACTED			= 4
+};
+
+struct aml_pcmcia{
+	enum aml_slot_state		slot_state;
+	struct work_struct		pcmcia_work;
+
+	int irq;
+	int (*init_irq)(int flag);
+	int (*get_cd1)(void);
+	int (*get_cd2)(void);
+	int (*pwr)(int enable);
+	int (*rst)(int enable);
+
+	int (*pcmcia_plugin)(struct aml_pcmcia *pc, int plugin);
+
+	void *priv;
+};
+
+int aml_pcmcia_init(struct aml_pcmcia *pc);
+int aml_pcmcia_exit(struct aml_pcmcia *pc);
+int aml_pcmcia_reset(struct aml_pcmcia *pc);
+
+
+#endif /*_AML_PCMCIA_*/
+
diff --git a/drivers/amlogic/dvb_tv/amldemod/Makefile b/drivers/amlogic/dvb_tv/amldemod/Makefile
new file mode 100755
index 000000000000..11443093650a
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/Makefile
@@ -0,0 +1,26 @@
+
+obj-$(CONFIG_AM_M6_DEMOD) += aml_fe.o
+
+aml_fe-objs := demod_func.o  dvbc_func.o i2c_func.o tuner_func.o #dvbt_func.o
+
+#aml_fe-objs += mxl/MxL5007.o
+#aml_fe-objs += mxl/MxL5007_API.o
+#aml_fe-objs += mxl/MxL_User_Define.o
+#aml_fe-objs += nxp/tuner_fj2207.o
+#aml_fe-objs += nxp/tmbslNT220x.o
+#aml_fe-objs += nxp/tmbslNT220xInstance.o
+#aml_fe-objs += nxp/tmddNT220x.o
+#aml_fe-objs += nxp/tmddNT220xInstance.o
+#aml_fe-objs += nxp/tmddNT220x_Advanced.o
+#aml_fe-objs += si2176/si2176_func.o
+
+##ifeq ($(CONFIG_AM_DEMOD_DVBAPI), y)
+aml_fe-objs += amlfrontend.o
+##endif
+
+##ifeq ($(CONFIG_AM_DEMOD_DEBUG), y)
+aml_fe-objs	+= aml_demod.o
+##endif
+
+EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
+
diff --git a/drivers/amlogic/dvb_tv/amldemod/acf_filter_coefficient.h b/drivers/amlogic/dvb_tv/amldemod/acf_filter_coefficient.h
new file mode 100755
index 000000000000..59541360ef19
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/acf_filter_coefficient.h
@@ -0,0 +1,253 @@
+
+void program_acf(int acf1[20], int acf2[33])
+{
+    int i;
+
+    for (i=0; i<20; i++)
+        apb_write_reg(DVBT_BASE+(0x2c+i)*4, acf1[i]);
+    for (i=0; i<33; i++) {
+        apb_write_reg(DVBT_BASE+0xfe*4, i);
+        apb_write_reg(DVBT_BASE+0xff*4, acf2[i]);
+    }
+}
+
+void ini_acf_iireq_src_45m_8m(void)
+{
+    int acf1[] = {0x294,0x085,0x076,0x01e,
+                  0x27c,0x0af,0x2bf,0x06d,
+                  0x265,0x0d8,0x270,0x05e,
+                  0x257,0x0ef,0x25b,0x04b,
+                  0x24f,0x0fc,0x254,0x04d};
+    int acf2[] = {0x3f3fff,0x3da7cd,0x3c0f9b,0x3a7768,0x38df35,0x373f01,
+                  0x3596cd,0x33ee98,0x323e62,0x307e2b,0x2eb5f3,0x2ce5b9,
+                  0x2b057e,0x290d41,0x26fd00,0x24dcbd,0x229477,0x202c2c,
+                  0x1d93dc,0x1ac386,0x17b328,0x144ac1,0x106a4d,0x0be1c8,
+                  0x07e129,0x04d0cc,0x015064,0x3d47ec,0x38675e,0x326eb1,
+                  0x326e4d,0x326e4d,0x00064d};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_45m_7m(void)
+{
+    int acf1[] = {0x283,0x091,0x02f,0x01e,
+                  0x26a,0x0b8,0x296,0x06d,
+                  0x253,0x0dc,0x257,0x05e,
+                  0x245,0x0f1,0x246,0x04b,
+                  0x23d,0x0fc,0x241,0x04d};
+    int acf2[] = {0x3f3fff,0x3dafce,0x3c1f9c,0x3a8769,0x38ef37,0x374f03,
+                  0x35aecf,0x34069b,0x325665,0x30962e,0x2ecdf6,0x2cfdbc,
+                  0x2b1581,0x291d43,0x271503,0x24e4bf,0x229c78,0x202c2d,
+                  0x1d8bdc,0x1ab384,0x179325,0x141abc,0x102a46,0x0b81be,
+                  0x07711c,0x0448bd,0x00b052,0x3c7fd6,0x374740,0x308684,
+                  0x308610,0x308610,0x000610};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_45m_6m(void)
+{
+    int acf1[] = {0x272,0x09e,0x3dc,0x01e,
+                  0x259,0x0c0,0x272,0x06d,
+                  0x242,0x0e1,0x240,0x05e,
+                  0x235,0x0f3,0x234,0x04b,
+                  0x22e,0x0fd,0x230,0x04d};
+    int acf2[] = {0x3f47ff,0x3dbfcf,0x3c379e,0x3aa76d,0x391f3c,0x378709,
+                  0x35e6d6,0x343ea2,0x328e6d,0x30d636,0x2f0dfe,0x2d35c4,
+                  0x2b4d88,0x294d49,0x273d08,0x2504c4,0x22b47c,0x203c2f,
+                  0x1d9bde,0x1ac386,0x17a327,0x1432bf,0x104249,0x0ba9c2,
+                  0x07a922,0x0490c5,0x01185c,0x3d0fe5,0x383f58,0x3286af,
+                  0x328650,0x328650,0x000650};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_45m_5m(void)
+{
+    int acf1[] = {0x260,0x0ab,0x37e,0x02e,
+                  0x249,0x0ca,0x251,0x06d,
+                  0x233,0x0e6,0x22d,0x05e,
+                  0x227,0x0f5,0x224,0x04b,
+                  0x220,0x0fd,0x221,0x04d};
+    int acf2[] = {0x3f3fff,0x3db7cf,0x3c279d,0x3a9f6c,0x39073a,0x377707,
+                  0x35d6d4,0x3436a0,0x328e6b,0x30d636,0x2f15ff,0x2d4dc6,
+                  0x2b758c,0x29854f,0x278511,0x256ccf,0x232c89,0x20cc3f,
+                  0x1e33f0,0x1b6b9b,0x185b3d,0x14e2d5,0x10f260,0x0c51d7,
+                  0x082934,0x04f8d4,0x014066,0x3ccfe4,0x372f46,0x2f5673,
+                  0x2f55ea,0x2f55ea,0x0005ea};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_2857m_8m(void)
+{
+    int acf1[] = {0x2df,0x059,0x144,0x00e,
+                  0x2d3,0x08f,0x38d,0x06f,
+                  0x2c6,0x0c5,0x302,0x05e,
+                  0x2be,0x0e7,0x2d6,0x04b,
+                  0x2b7,0x0f9,0x2c8,0x04d};
+    int acf2[] = {0x3f3fff,0x3dbfcf,0x3c379e,0x3aaf6d,0x391f3c,0x37870a,
+                  0x35eed7,0x344ea3,0x32a66f,0x30f639,0x2f3602,0x2d65c9,
+                  0x2b858e,0x299552,0x278d12,0x2564cf,0x231c88,0x20b43d,
+                  0x1e13ec,0x1b3395,0x181336,0x1492cc,0x109254,0x0be1cb,
+                  0x07c127,0x0498c7,0x00f85b,0x3cbfde,0x377747,0x309e88,
+                  0x309e13,0x309e13,0x000613};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_2857m_7m(void)
+{
+    int acf1[] = {0x2c6,0x067,0x10f,0x01e,
+                  0x2b4,0x099,0x344,0x06f,
+                  0x2a2,0x0cb,0x2cb,0x05e,
+                  0x297,0x0ea,0x2a7,0x04b,
+                  0x28f,0x0fa,0x29c,0x04d};
+    int acf2[] = {0x3f3fff,0x3dbfcf,0x3c379e,0x3aa76d,0x39173b,0x378709,
+                  0x35e6d6,0x3446a2,0x329e6d,0x30e637,0x2f2600,0x2d4dc7,
+                  0x2b6d8c,0x297d4e,0x276d0e,0x2544cb,0x22fc84,0x208438,
+                  0x1de3e7,0x1b0b90,0x17eb30,0x146ac7,0x107250,0x0bc9c6,
+                  0x07b124,0x0490c5,0x00f85b,0x3cc7df,0x37974a,0x30ce8d,
+                  0x30ce19,0x30ce19,0x000619};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_2857m_6m(void)
+{
+    int acf1[] = {0x2ac,0x076,0x0c9,0x01e,
+                  0x297,0x0a4,0x2fd,0x06d,
+                  0x281,0x0d2,0x299,0x05e,
+                  0x274,0x0ed,0x27d,0x04b,
+                  0x26c,0x0fb,0x274,0x04d};
+    int acf2[] = {0x3f3fff,0x3db7cf,0x3c279d,0x3a976b,0x390739,0x376f07,
+                  0x35ced3,0x342e9f,0x327e6a,0x30c634,0x2f05fc,0x2d35c4,
+                  0x2b5d89,0x29654c,0x275d0c,0x253cca,0x22fc83,0x209439,
+                  0x1dfbe9,0x1b2b93,0x181b35,0x14b2ce,0x10ca5a,0x0c41d4,
+                  0x084935,0x0538d9,0x01c071,0x3db7fa,0x38bf6b,0x327eb9,
+                  0x327e4f,0x327e4f,0x00064f};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_2857m_5m(void)
+{
+    int acf1[] = {0x292,0x087,0x06e,0x01e,
+                  0x27a,0x0b0,0x2b9,0x06d,
+                  0x262,0x0d8,0x26d,0x05e,
+                  0x254,0x0f0,0x258,0x04b,
+                  0x24c,0x0fc,0x252,0x04d};
+    int acf2[] = {0x3f3fff,0x3db7ce,0x3c279d,0x3a976b,0x38ff38,0x376706,
+                  0x35c6d2,0x341e9d,0x326e68,0x30ae31,0x2eedf9,0x2d15c0,
+                  0x2b2d84,0x293546,0x272506,0x24fcc2,0x22ac7b,0x203c2f,
+                  0x1d9bde,0x1ac386,0x17a327,0x1422be,0x103247,0x0b91bf,
+                  0x07891e,0x0470c1,0x00e858,0x3ccfde,0x37bf4d,0x313e96,
+                  0x313e27,0x313e27,0x000627};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_24m_8m(void)
+{
+    int acf1[] = {0x303,0x048,0x17e,0x00e,
+                  0x302,0x081,0x3f8,0x00a,
+                  0x300,0x0bd,0x35b,0x05e,
+                  0x2fe,0x0e3,0x325,0x04b,
+                  0x2fb,0x0f8,0x313,0x04d};
+    int acf2[] = {0x3f47ff,0x3dc7d0,0x3c3fa0,0x3abf6f,0x392f3e,0x37a70d,
+                  0x360eda,0x346ea7,0x32c673,0x31163d,0x2f5606,0x2d8dce,
+                  0x2bad93,0x29bd56,0x27b517,0x258cd4,0x23448d,0x20cc41,
+                  0x1e2bf0,0x1b4b98,0x182338,0x149ace,0x109255,0x0bd1ca,
+                  0x07a123,0x0468c2,0x00b054,0x3c5fd4,0x37073a,0x302e79,
+                  0x302e05,0x302e05,0x000605};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_24m_7m(void)
+{
+    int acf1[] = {0x2e7,0x055,0x153,0x00e,
+                  0x2dd,0x08b,0x3a5,0x06f,
+                  0x2d2,0x0c4,0x315,0x05e,
+                  0x2cb,0x0e6,0x2e7,0x04b,
+                  0x2c5,0x0f9,0x2d8,0x04d};
+    int acf2[] = {0x3f3fff,0x3dbfcf,0x3c379e,0x3aaf6d,0x391f3c,0x37870a,
+                  0x35eed7,0x344ea3,0x32a66f,0x30ee39,0x2f2e02,0x2d65c9,
+                  0x2b858e,0x298d51,0x278511,0x255cce,0x231487,0x20a43c,
+                  0x1e0beb,0x1b3394,0x181335,0x1492cb,0x109254,0x0be1ca,
+                  0x07b925,0x0480c5,0x00d858,0x3c87d8,0x373740,0x305e80,
+                  0x305e0b,0x305e0b,0x00060b};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_24m_6m(void)
+{
+    int acf1[] = {0x2c9,0x065,0x118,0x01e,
+                  0x2b9,0x097,0x34f,0x06f,
+                  0x2a7,0x0ca,0x2d3,0x05e,
+                  0x29c,0x0e9,0x2ae,0x04b,
+                  0x295,0x0fa,0x2a2,0x04d};
+    int acf2[] = {0x3f3fff,0x3db7cf,0x3c2f9d,0x3a9f6c,0x390f3a,0x377707,
+                  0x35d6d4,0x342ea0,0x32866b,0x30ce34,0x2f05fd,0x2d35c3,
+                  0x2b5588,0x295d4b,0x27550b,0x252cc8,0x22dc80,0x206c35,
+                  0x1dcbe4,0x1af38c,0x17cb2d,0x144ac3,0x104a4b,0x0b99c1,
+                  0x07791d,0x0448be,0x00b052,0x3c6fd4,0x37473f,0x30c686,
+                  0x30c618,0x30c618,0x000618};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_24m_5m(void)
+{
+    int acf1[] = {0x2ab,0x077,0x0c6,0x01e,
+                  0x295,0x0a5,0x2fa,0x06d,
+                  0x27f,0x0d2,0x297,0x05e,
+                  0x272,0x0ed,0x27b,0x04b,
+                  0x26a,0x0fb,0x272,0x04d};
+    int acf2[] = {0x3f3fff,0x3db7cf,0x3c2f9e,0x3aa76c,0x39173b,0x377f08,
+                  0x35ded5,0x343ea1,0x328e6c,0x30de36,0x2f15ff,0x2d45c6,
+                  0x2b658a,0x29754d,0x27650d,0x253cca,0x22f483,0x208438,
+                  0x1de3e7,0x1b0b90,0x17eb30,0x1472c7,0x107a51,0x0bd9c8,
+                  0x07c927,0x04a8c9,0x01205f,0x3cf7e4,0x37e752,0x31669a,
+                  0x31662c,0x31662c,0x00062c};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_207m_8m(void)
+{
+    int acf1[] = {0x327,0x039,0x1a5,0x07b,
+                  0x332,0x076,0x05c,0x06e,
+                  0x33e,0x0b6,0x3b8,0x05e,
+                  0x344,0x0e0,0x37a,0x04b,
+                  0x345,0x0f7,0x365,0x04d};
+    int acf2[] = {0x3f47ff,0x3dcfd1,0x3c57a1,0x3ad772,0x394f42,0x37c711,
+                  0x3636df,0x34a6ad,0x32fe7a,0x315645,0x2f9e0f,0x2dd5d7,
+                  0x2bfd9d,0x2a0d61,0x280d21,0x25e4df,0x239c98,0x212c4d,
+                  0x1e8bfc,0x1baba4,0x188344,0x14fad9,0x10ea61,0x0c29d4,
+                  0x07e92d,0x04a8cb,0x00f05c,0x3c87da,0x371f3e,0x30267a,
+                  0x302604,0x302604,0x000604};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_207m_7m(void)
+{
+    int acf1[] = {0x307,0x046,0x182,0x00e,
+                  0x306,0x080,0x002,0x00a,
+                  0x306,0x0bd,0x364,0x05e,
+                  0x304,0x0e3,0x32d,0x04b,
+                  0x301,0x0f8,0x31b,0x04d};
+    int acf2[] = {0x3f47ff,0x3dc7d0,0x3c47a0,0x3abf6f,0x39373f,0x37a70d,
+                  0x3616db,0x3476a8,0x32d674,0x31263f,0x2f6608,0x2d9dd0,
+                  0x2bbd96,0x29d559,0x27cd19,0x25a4d7,0x235c90,0x20ec45,
+                  0x1e53f4,0x1b739d,0x18533d,0x14d2d4,0x10d25c,0x0c19d1,
+                  0x07e12c,0x04a8ca,0x00f05c,0x3c8fdb,0x372740,0x302e7c,
+                  0x302e05,0x302e05,0x000605};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_207m_6m(void)
+{
+    int acf1[] = {0x2e6,0x056,0x151,0x00e,
+                  0x2db,0x08c,0x3a1,0x06f,
+                  0x2d0,0x0c4,0x312,0x05e,
+                  0x2c9,0x0e6,0x2e4,0x04b,
+                  0x2c3,0x0f9,0x2d6,0x04d};
+    int acf2[] = {0x3f47ff,0x3dbfd0,0x3c3f9f,0x3ab76e,0x39273d,0x37970b,
+                  0x35fed9,0x345ea5,0x32b671,0x31063b,0x2f4604,0x2d75cb,
+                  0x2b9590,0x29a553,0x279513,0x256cd0,0x232489,0x20b43d,
+                  0x1e0bec,0x1b3395,0x180b35,0x148acb,0x108253,0x0bd1c8,
+                  0x07a123,0x0470c2,0x00c055,0x3c77d6,0x372f3e,0x306e80,
+                  0x306e0d,0x306e0d,0x00060d};
+      program_acf(acf1, acf2);
+}
+void ini_acf_iireq_src_207m_5m(void)
+{
+    int acf1[] = {0x2c3,0x068,0x109,0x01e,
+                  0x2b1,0x09a,0x33d,0x06f,
+                  0x29f,0x0cc,0x2c6,0x05e,
+                  0x293,0x0ea,0x2a3,0x04b,
+                  0x28c,0x0fa,0x298,0x04d};
+    int acf2[] = {0x3f3fff,0x3db7ce,0x3c279d,0x3a976b,0x38ff38,0x376706,
+                  0x35c6d2,0x341e9e,0x327669,0x30be32,0x2ef5fb,0x2d25c1,
+                  0x2b4586,0x295549,0x274509,0x251cc6,0x22dc80,0x206c34,
+                  0x1dcbe4,0x1afb8d,0x17db2e,0x1462c5,0x106a4f,0x0bc9c6,
+                  0x07b124,0x0488c5,0x00e859,0x3cafdc,0x377f47,0x30ee8c,
+                  0x30ee1d,0x30ee1d,0x00061d};
+      program_acf(acf1, acf2);
+}
\ No newline at end of file
diff --git a/drivers/amlogic/dvb_tv/amldemod/aml_demod.c b/drivers/amlogic/dvb_tv/amldemod/aml_demod.c
new file mode 100755
index 000000000000..5a6e78671e0d
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/aml_demod.c
@@ -0,0 +1,734 @@
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/ctype.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <mach/am_regs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+
+#include <asm/fiq.h>
+#include <asm/uaccess.h>
+#include "aml_demod.h"
+#include "demod_func.h"
+
+#include <linux/slab.h>
+//#include "sdio/sdio_init.h"
+#define DRIVER_NAME "aml_demod"
+#define MODULE_NAME "aml_demod"
+#define DEVICE_NAME "aml_demod"
+#define DEVICE_UI_NAME "aml_demod_ui"
+
+const char aml_demod_dev_id[] = "aml_demod";
+
+/*#ifndef CONFIG_AM_DEMOD_DVBAPI
+static struct aml_demod_i2c demod_i2c;
+static struct aml_demod_sta demod_sta;
+#else
+  extern struct aml_demod_i2c demod_i2c;
+  extern struct aml_demod_sta demod_sta;
+#endif*/
+static struct aml_demod_i2c demod_i2c;
+static struct aml_demod_sta demod_sta;
+static int read_start;
+
+int sdio_read_ddr(unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
+{
+	return 0;
+}
+int sdio_write_ddr(unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
+{
+	return 0;
+}
+
+int read_reg(int addr)
+{
+	addr=addr+DEMOD_BASE;
+	return apb_read_reg(addr);
+}
+
+static char buf_all[4*1024*1024];
+
+int read_memory_to_file(struct aml_cap_data *cap)
+{
+		int i,j,k,l,n,x;
+		int buf[1024];
+		char buf_in[32];
+		x=0;
+	//	printf("set read addr (KB) is");scanf("%d",&tmp);
+ 	    i=0<<10;
+ 	 //   printf("set length (KB) is");scanf("%d",&tmp);
+ 	    j=4096<<10;
+ 	    n=j+i;
+
+		for(i=0;i<n/32;i++){
+		    	for(k=0;k<8;k++){
+			    		buf[k]=read_reg(read_start+(k+(8*i))*4);
+							buf_in[4*k + 0] = (buf[k] >> 0)&0xff;
+							buf_in[4*k + 1] = (buf[k] >> 8)&0xff;
+							buf_in[4*k + 2] = (buf[k] >> 16)&0xff;
+							buf_in[4*k + 3] = (buf[k] >> 24)&0xff;
+		    	}
+		    	for(k=0;k<32;k++){
+		    		buf_all[32*x+k]=buf_in[k];
+		    	}
+		    	x++;
+		    //	if((32*x+k)>(128*1024)){
+		    //		fwrite(buf_all,128*1024,1,fp);
+		   // 		x=0;
+		  //  	}
+		    //	fwrite(g_sdio_buf_rd[id],g_sdio_buf_rd_byte_count,1,fp);
+			//		hcap_bin2dec(buf_out, buf_in);
+
+				/*	if (tmp){
+			    	for(j=0;j<25;j++){
+			    		fprintf(fp,"%x\n",buf_out[j]);
+					  //	usleep(2);
+						//  printf("%x\n",buf_out[j]);
+			    	}
+			    }
+			    else{
+			    	for(j=0;j<32;j++){
+			    		fprintf(fp,"%x\n",buf_in[j]);
+					  //	usleep(2);
+						//  printf("%x\n",buf_in[j]);
+			    	}
+			    }*/
+			     if((read_start+(k+(8*i))*4-0x40000000)>app_apb_read_reg(0x9e)){
+				read_start=app_apb_read_reg(0x9d)+0x40000000;
+				l=(k+(8*i))*4;
+				printk("stop addr is %x\n",l);
+				i=0;j=l;
+				n=cap->cap_size*0x100000-l;
+			}
+		}
+		return 0;
+}
+
+void wait_capture(int cap_cur_addr, int depth_MB, int start)
+{
+	int readfirst;
+	int tmp;
+	int time_out;
+	int last=0x90000000;
+	time_out = readfirst = 0;
+	tmp = depth_MB<<20;
+  while (tmp&&(time_out<1000)) //10seconds time out
+  {
+  	time_out = time_out + 1;
+  	msleep(1);
+   	readfirst = app_apb_read_reg(cap_cur_addr);
+   	if((last-readfirst)>0)
+   		tmp=0;
+   	else
+   		last=readfirst;
+	//	usleep(1000);
+	//	readsecond= app_apb_read_reg(cap_cur_addr);
+
+	//	if((readsecond-start)>tmp)
+//			tmp=0;
+//		if((readsecond-readfirst)<0)  // turn around
+//			tmp=0;
+		printk("First  %x = [%08x],[%08x]%x\n",cap_cur_addr, readfirst,last,(last-readfirst));
+//		printf("Second %x = [%08x]\n",cap_cur_addr, readsecond);
+		msleep(10);
+  }
+  read_start=readfirst+0x40000000;
+  printk("read_start is %x\n",read_start);
+
+}
+
+
+int cap_adc_data(struct aml_cap_data *cap)
+{
+	int tmp;
+	int tb_depth;
+	printk("capture ADC\n ");
+//	printf("set mem_start (you can read in kernel start log(memstart is ).(hex)  :  ");
+//	scanf("%x",&tmp);
+	tmp=0x94400000;
+	app_apb_write_reg(0x9d, cap->cap_addr);
+	app_apb_write_reg(0x9e, cap->cap_addr+cap->cap_size*0x100000);   //0x8000000-128m, 0x400000-4m
+	read_start=tmp+0x40000000;
+	//printf("set afifo rate. (hex)(adc_clk/demod_clk)*256+2 :  ");		//(adc_clk/demod_clk)*256+2
+  //  scanf("%x",&tmp);
+	cap->cap_afifo=0x60;
+    app_apb_write_reg(0x15, 0x18715f2);
+  	app_apb_write_reg(0x15, (app_apb_read_reg(0x15)&0xfff00fff) | ((cap->cap_afifo&0xff) << 12) ); // set afifo
+
+    app_apb_write_reg(0x9b, 0x1c9);// capture ADC 10bits
+    app_apb_write_reg(0x7f, 0x00008000); // enable testbus 0x8000
+
+    tb_depth = cap->cap_size;//127;
+    tmp = 9;
+    app_apb_write_reg(0x9b, (app_apb_read_reg(0x9b) &~ 0x1f) | tmp);// set testbus width
+
+    tmp = 0x100000;
+    app_apb_write_reg(0x9c, tmp);// by ADC data enable
+  //  printf("Set test mode. (0 is normal ,1 is testmode) :  ");  //0
+  //  scanf("%d",&tmp);
+  	tmp=0;
+    if (tmp ==1) app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 10)); // set test mode;
+    else         app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) &~ (1 << 10)); // close test mode;
+
+    app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) &~ (1 << 9)); // close cap;
+    app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) |  (1 << 9)); // open  cap;
+
+    app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) |  (1 << 7)); // close tb;
+    app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) &~ (1 << 7)); // open  tb;
+
+    app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) |  (1 << 5)); // close intlv;
+
+    app_apb_write_reg(0x303, 0x8);// open dc_arbit
+
+    tmp = 0;
+    if (tmp)  app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) &~ (1 << 5)); // open  intlv;
+
+    app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) &~ (1 << 8)); // go  tb;
+
+    wait_capture(0x9f,tb_depth, app_apb_read_reg(0x9d));
+
+    app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 8)); // stop  tb;
+    app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 7)); // close tb;
+    return 0;
+}
+
+
+
+static DECLARE_WAIT_QUEUE_HEAD(lock_wq);
+
+static ssize_t aml_demod_info(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf)
+{
+    return 0;
+}
+
+static struct class_attribute aml_demod_class_attrs[] = {
+    __ATTR(info,
+	   S_IRUGO | S_IWUSR,
+	   aml_demod_info,
+	   NULL),
+    __ATTR_NULL
+};
+
+static struct class aml_demod_class = {
+    .name = "aml_demod",
+    .class_attrs = aml_demod_class_attrs,
+};
+
+static irqreturn_t aml_demod_isr(int irq, void *dev_id)
+{
+#if 0
+    if (demod_sta.dvb_mode == 0) {
+	//dvbc_isr(&demod_sta);
+	if(dvbc_isr_islock()){
+		printk("sync4\n");
+		if(waitqueue_active(&lock_wq))
+			wake_up_interruptible(&lock_wq);
+	}
+    }
+    else {
+	dvbt_isr(&demod_sta);
+    }
+#endif
+    return IRQ_HANDLED;
+}
+
+static int aml_demod_open(struct inode *inode, struct file *file)
+{
+    printk("Amlogic Demod DVB-T/C Open\n");
+    return 0;
+}
+
+static int aml_demod_release(struct inode *inode, struct file *file)
+
+{
+    printk("Amlogic Demod DVB-T/C Release\n");
+    return 0;
+}
+#if 0
+static int amdemod_islock(void)
+{
+	struct aml_demod_sts demod_sts;
+	if(demod_sta.dvb_mode == 0) {
+		dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
+		return demod_sts.ch_sts&0x1;
+	} else if(demod_sta.dvb_mode == 1) {
+		dvbt_status(&demod_sta, &demod_i2c, &demod_sts);
+		return demod_sts.ch_sts>>12&0x1;
+	}
+	return 0;
+}
+#endif
+
+extern long *mem_buf;
+void mem_read(struct aml_demod_mem* arg)
+{
+	int data;
+	int addr;
+	addr = arg->addr;
+	data = arg->dat;
+//	memcpy(mem_buf[addr],data,1);
+	printk("[addr %x] data is %x\n",addr,data);
+}
+#ifdef CONFIG_AM_SI2176
+extern	int si2176_get_strength(void);
+#endif
+
+#ifdef CONFIG_AM_SI2177
+extern	int si2177_get_strength(void);
+#endif
+
+static long aml_demod_ioctl(struct file *file,
+                        unsigned int cmd, unsigned long arg)
+{
+	int i=0;
+	int step;
+	int strength=0;
+
+    switch (cmd) {
+
+		case AML_DEMOD_GET_RSSI :
+			printk("Ioctl Demod GET_RSSI. \n");
+			#ifdef CONFIG_AM_SI2176
+			 strength=si2176_get_strength();
+			 printk("[si2176] strength is %d\n",strength-256);
+			#endif
+
+			#ifdef CONFIG_AM_SI2177
+			 strength=si2177_get_strength();
+			 printk("[si2177] strength is %d\n",strength-256);
+			#endif
+
+			break;
+
+	case AML_DEMOD_SET_TUNER :
+	     printk("Ioctl Demod Set Tuner.\n");
+		  demod_set_tuner(&demod_sta, &demod_i2c, (struct aml_tuner_sys *)arg);
+		break;
+
+    	case AML_DEMOD_SET_SYS :
+		printk("Ioctl Demod Set System\n");
+		demod_set_sys(&demod_sta, &demod_i2c, (struct aml_demod_sys *)arg);
+		break;
+
+    	case AML_DEMOD_GET_SYS :
+		printk("Ioctl Demod Get System\n");
+
+	//	demod_get_sys(&demod_i2c, (struct aml_demod_sys *)arg);
+		break;
+
+    	case AML_DEMOD_TEST :
+		printk("Ioctl Demod Test. It is blank now\n");
+		//demod_msr_clk(13);
+		//demod_msr_clk(14);
+		//demod_calc_clk(&demod_sta);
+		break;
+
+    	case AML_DEMOD_TURN_ON :
+		printk("Ioctl Demod Turn ON.It is blank now\n");
+		//demod_turn_on(&demod_sta, (struct aml_demod_sys *)arg);
+		break;
+
+	case AML_DEMOD_TURN_OFF :
+		printk("Ioctl Demod Turn OFF.It is blank now\n");
+		//demod_turn_off(&demod_sta, (struct aml_demod_sys *)arg);
+		break;
+
+	case AML_DEMOD_DVBC_SET_CH :
+		printk("Ioctl DVB-C Set Channel. \n");
+		dvbc_set_ch(&demod_sta, &demod_i2c, (struct aml_demod_dvbc *)arg);
+		break;
+
+    	case AML_DEMOD_DVBC_GET_CH :
+	//	printk("Ioctl DVB-C Get Channel. It is blank\n");
+		dvbc_status(&demod_sta, &demod_i2c, (struct aml_demod_sts *)arg);
+		break;
+	case AML_DEMOD_DVBC_TEST :
+		printk("Ioctl DVB-C Test. It is blank\n");
+		//dvbc_get_test_out(0xb, 1000, (u32 *)arg);
+		break;
+	case AML_DEMOD_DVBT_SET_CH :
+		printk("Ioctl DVB-T Set Channel\n");
+		dvbt_set_ch(&demod_sta, &demod_i2c, (struct aml_demod_dvbt *)arg);
+		break;
+
+    	case AML_DEMOD_DVBT_GET_CH :
+		printk("Ioctl DVB-T Get Channel\n");
+	//	dvbt_status(&demod_sta, &demod_i2c, (struct aml_demod_sts *)arg);
+		break;
+
+    	case AML_DEMOD_DVBT_TEST :
+		printk("Ioctl DVB-T Test. It is blank\n");
+		//dvbt_get_test_out(0x1e, 1000, (u32 *)arg);
+		break;
+
+	case AML_DEMOD_DTMB_SET_CH:
+		dtmb_set_ch(&demod_sta, &demod_i2c, (struct aml_demod_dtmb *)arg);
+		break;
+
+	case AML_DEMOD_DTMB_GET_CH:
+		break;
+
+	case AML_DEMOD_DTMB_TEST:
+		break;
+
+	case AML_DEMOD_ATSC_SET_CH:
+		atsc_set_ch(&demod_sta, &demod_i2c, (struct aml_demod_atsc *)arg);
+		break;
+
+	case AML_DEMOD_ATSC_GET_CH:
+		check_atsc_fsm_status();
+		break;
+
+	case AML_DEMOD_ATSC_TEST:
+		break;
+
+	case AML_DEMOD_SET_REG :
+	//	printk("Ioctl Set Register\n");
+   		demod_set_reg((struct aml_demod_reg *)arg);
+		break;
+
+	case AML_DEMOD_GET_REG :
+	//	printk("Ioctl Get Register\n");
+   		demod_get_reg((struct aml_demod_reg *)arg);
+		break;
+
+ 	case AML_DEMOD_SET_REGS :
+		break;
+
+ 	case AML_DEMOD_GET_REGS :
+		break;
+
+	case AML_DEMOD_RESET_MEM :
+		memset(mem_buf,0,64*1024*1024-1);
+		printk("set mem ok\n");
+		break;
+
+ 	case AML_DEMOD_READ_MEM :
+		step=arg;
+		printk("[%x]0x%lx------------------\n",i,mem_buf[step]);
+		for(i=step;i<step+1024;i++){
+		printk("0x%lx,",mem_buf[i]);
+		}
+		break;
+	case AML_DEMOD_SET_MEM :
+		/*step=(struct aml_demod_mem)arg;
+		printk("[%x]0x%x------------------\n",i,mem_buf[step]);
+		for(i=step;i<1024-1;i++){
+		printk("0x%x,",mem_buf[i]);
+		}*/
+		mem_read((struct aml_demod_mem *)arg);
+		break;
+
+	case AML_DEMOD_ATSC_IRQ:
+		atsc_read_iqr_reg();
+		break;
+
+    default:
+		printk("Enter Default ! 0x%X\n", cmd);
+		printk("AML_DEMOD_GET_REGS=0x%08X\n", AML_DEMOD_GET_REGS);
+		printk("AML_DEMOD_SET_REGS=0x%08X\n", AML_DEMOD_SET_REGS);
+	return -EINVAL;
+    }
+
+    return 0;
+}
+
+const static struct file_operations aml_demod_fops = {
+    .owner    = THIS_MODULE,
+    .open     = aml_demod_open,
+    .release  = aml_demod_release,
+    .unlocked_ioctl    = aml_demod_ioctl,
+};
+
+
+static int aml_demod_ui_open(struct inode *inode, struct file *file)
+{
+    printk("Amlogic aml_demod_ui_open Open\n");
+    return 0;
+}
+
+static int aml_demod_ui_release(struct inode *inode, struct file *file)
+
+{
+    printk("Amlogic aml_demod_ui_open Release\n");
+    return 0;
+}
+
+static ssize_t aml_demod_ui_read(struct file *file, char __user *buf, size_t count, loff_t * ppos)
+{
+	char *capture_buf=buf_all;
+	int res=0;
+	if(count >= 4*1024*1024){
+		count=4*1024*1024;
+	}else if(count == 0){
+		return 0;
+	}
+
+	res = copy_to_user((void *)buf, (char *)capture_buf, count);
+	if(res<0){
+		printk("[aml_demod_ui_read]res is %d",res);
+		return res;
+	}
+
+	return count;
+
+
+
+}
+
+static ssize_t aml_demod_ui_write(struct file *file, const char *buf,
+                                  size_t count, loff_t * ppos)
+{
+	return 0;
+
+}
+
+
+
+static struct device *aml_demod_ui_dev;
+static dev_t aml_demod_devno_ui;
+static struct cdev*  aml_demod_cdevp_ui;
+
+
+const static struct file_operations aml_demod_ui_fops = {
+    .owner    = THIS_MODULE,
+    .open     = aml_demod_ui_open,
+    .release  = aml_demod_ui_release,
+    .read     = aml_demod_ui_read,
+    .write    = aml_demod_ui_write,
+ //   .unlocked_ioctl    = aml_demod_ui_ioctl,
+};
+#if 0
+static ssize_t aml_demod_ui_info(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf)
+{
+    return 0;
+}
+
+static struct class_attribute aml_demod_ui_class_attrs[] = {
+    __ATTR(info,
+	   S_IRUGO | S_IWUSR,
+	   aml_demod_ui_info,
+	   NULL),
+    __ATTR_NULL
+};
+#endif
+
+static struct class aml_demod_ui_class = {
+    .name = "aml_demod_ui",
+//    .class_attrs = aml_demod_ui_class_attrs,
+};
+
+
+
+int aml_demod_ui_init(void)
+{
+	int r=0;
+
+	r = class_register(&aml_demod_ui_class);
+    if (r) {
+        printk("create aml_demod class fail\r\n");
+        class_unregister(&aml_demod_ui_class);
+		return r;
+    }
+
+	r = alloc_chrdev_region(&aml_demod_devno_ui, 0, 1, DEVICE_UI_NAME);
+	if(r < 0){
+		printk(KERN_ERR"aml_demod_ui: faild to alloc major number\n");
+		r = - ENODEV;
+		unregister_chrdev_region(aml_demod_devno_ui, 1);
+		class_unregister(&aml_demod_ui_class);
+		return r;
+	}
+
+	aml_demod_cdevp_ui = kmalloc(sizeof(struct cdev), GFP_KERNEL);
+	if(!aml_demod_cdevp_ui){
+		printk(KERN_ERR"aml_demod_ui: failed to allocate memory\n");
+		r = -ENOMEM;
+		unregister_chrdev_region(aml_demod_devno_ui, 1);
+		kfree(aml_demod_cdevp_ui);
+		class_unregister(&aml_demod_ui_class);
+		return r;
+	}
+	// connect the file operation with cdev
+	cdev_init(aml_demod_cdevp_ui, &aml_demod_ui_fops);
+	aml_demod_cdevp_ui->owner = THIS_MODULE;
+	// connect the major/minor number to cdev
+	r = cdev_add(aml_demod_cdevp_ui, aml_demod_devno_ui, 1);
+	if(r){
+		printk(KERN_ERR "aml_demod_ui:failed to add cdev\n");
+		unregister_chrdev_region(aml_demod_devno_ui, 1);
+		cdev_del(aml_demod_cdevp_ui);
+		kfree(aml_demod_cdevp_ui);
+		class_unregister(&aml_demod_ui_class);
+		return r;
+	}
+
+	 aml_demod_ui_dev = device_create(&aml_demod_ui_class, NULL,
+				  MKDEV(MAJOR(aml_demod_devno_ui),0), NULL,
+				  DEVICE_UI_NAME);
+
+    if (IS_ERR(aml_demod_ui_dev)) {
+        printk("Can't create aml_demod device\n");
+        unregister_chrdev_region(aml_demod_devno_ui, 1);
+		cdev_del(aml_demod_cdevp_ui);
+		kfree(aml_demod_cdevp_ui);
+		class_unregister(&aml_demod_ui_class);
+		return r;
+    }
+
+	return r;
+
+}
+
+void aml_demod_exit_ui(void)
+{
+	unregister_chrdev_region(aml_demod_devno_ui, 1);
+    cdev_del(aml_demod_cdevp_ui);
+    kfree(aml_demod_cdevp_ui);
+	class_unregister(&aml_demod_ui_class);
+
+}
+
+
+static struct device *aml_demod_dev;
+static dev_t aml_demod_devno;
+static struct cdev*  aml_demod_cdevp;
+
+#ifdef CONFIG_AM_DEMOD_DVBAPI
+int aml_demod_init(void)
+#else
+static int __init aml_demod_init(void)
+#endif
+{
+    int r = 0;
+
+    printk("Amlogic Demod DVB-T/C DebugIF Init\n");
+
+    init_waitqueue_head(&lock_wq);
+
+    /* hook demod isr */
+    r = request_irq(INT_DEMOD, &aml_demod_isr,
+                    IRQF_SHARED, "aml_demod",
+                    (void *)aml_demod_dev_id);
+
+    if (r) {
+        printk("aml_demod irq register error.\n");
+        r = -ENOENT;
+        goto err0;
+    }
+
+    /* sysfs node creation */
+    r = class_register(&aml_demod_class);
+    if (r) {
+        printk("create aml_demod class fail\r\n");
+        goto err1;
+    }
+
+	r = alloc_chrdev_region(&aml_demod_devno, 0, 1, DEVICE_NAME);
+	if(r < 0){
+		printk(KERN_ERR"aml_demod: faild to alloc major number\n");
+		r = - ENODEV;
+		goto err2;
+	}
+
+	aml_demod_cdevp = kmalloc(sizeof(struct cdev), GFP_KERNEL);
+	if(!aml_demod_cdevp){
+		printk(KERN_ERR"aml_demod: failed to allocate memory\n");
+		r = -ENOMEM;
+		goto err3;
+	}
+	// connect the file operation with cdev
+	cdev_init(aml_demod_cdevp, &aml_demod_fops);
+	aml_demod_cdevp->owner = THIS_MODULE;
+	// connect the major/minor number to cdev
+	r = cdev_add(aml_demod_cdevp, aml_demod_devno, 1);
+	if(r){
+		printk(KERN_ERR "aml_demod:failed to add cdev\n");
+		goto err4;
+	}
+
+    aml_demod_dev = device_create(&aml_demod_class, NULL,
+				  MKDEV(MAJOR(aml_demod_devno),0), NULL,
+				  DEVICE_NAME);
+
+    if (IS_ERR(aml_demod_dev)) {
+        printk("Can't create aml_demod device\n");
+        goto err5;
+    }
+	 printk("Amlogic Demod DVB-T/C DebugIF Init ok----------------\n");
+#if defined(CONFIG_AM_AMDEMOD_FPGA_VER) && !defined(CONFIG_AM_DEMOD_DVBAPI)
+    printk("sdio_init \n");
+    sdio_init();
+#endif
+	aml_demod_ui_init();
+
+    return (0);
+
+  err5:
+    cdev_del(aml_demod_cdevp);
+  err4:
+    kfree(aml_demod_cdevp);
+
+  err3:
+    unregister_chrdev_region(aml_demod_devno, 1);
+
+  err2:
+    free_irq(INT_DEMOD, (void *)aml_demod_dev_id);
+
+  err1:
+    class_unregister(&aml_demod_class);
+
+  err0:
+    return r;
+}
+
+#ifdef CONFIG_AM_DEMOD_DVBAPI
+void aml_demod_exit(void)
+#else
+static void __exit aml_demod_exit(void)
+#endif
+{
+    printk("Amlogic Demod DVB-T/C DebugIF Exit\n");
+
+    unregister_chrdev_region(aml_demod_devno, 1);
+    device_destroy(&aml_demod_class, MKDEV(MAJOR(aml_demod_devno),0));
+    cdev_del(aml_demod_cdevp);
+    kfree(aml_demod_cdevp);
+
+    free_irq(INT_DEMOD, (void *)aml_demod_dev_id);
+
+    class_unregister(&aml_demod_class);
+
+	aml_demod_exit_ui();
+}
+
+#ifndef CONFIG_AM_DEMOD_DVBAPI
+module_init(aml_demod_init);
+module_exit(aml_demod_exit);
+
+MODULE_LICENSE("GPL");
+//MODULE_AUTHOR(DRV_AUTHOR);
+//MODULE_DESCRIPTION(DRV_DESC);
+#endif
+
diff --git a/drivers/amlogic/dvb_tv/amldemod/aml_demod.h b/drivers/amlogic/dvb_tv/amldemod/aml_demod.h
new file mode 100755
index 000000000000..8e2685214725
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/aml_demod.h
@@ -0,0 +1,227 @@
+#ifndef AML_DEMOD_H
+#define AML_DEMOD_H
+#ifndef CONFIG_AM_DEMOD_FPGA_VER
+#define CONFIG_AM_DEMOD_FPGA_VER
+#endif//CONFIG_AM_DEMOD_FPGA_VER
+
+//#include <linux/types.h>
+#define u8_t u8
+#define u16_t u16
+#define u32_t u32
+
+
+
+struct aml_demod_i2c {
+    u8_t  tuner;   // type
+    u8_t  addr;    // slave addr
+    u32_t scl_oe;
+    u32_t scl_out;
+    u32_t scl_in;
+    u8_t  scl_bit;
+    u32_t sda_oe;
+    u32_t sda_out;
+    u32_t sda_in;
+    u8_t  sda_bit;
+    u8_t  udelay;  // us
+    u8_t  retries;
+    u8_t  debug;   // 1:debug
+    u8_t  tmp;     // spare
+    u8_t i2c_id;
+    void *i2c_priv;
+};
+
+struct aml_tuner_sys {
+    u8_t  mode;     //
+    u8_t  amp;    //
+    u8_t  if_agc_speed;
+	u32_t ch_freq;
+	u32_t if_freq;
+	u32_t rssi;
+	u32_t delay;
+	u8_t  bandwith;
+};
+
+
+
+struct aml_demod_sys {
+    u8_t  clk_en;     // 1:on
+    u8_t  clk_src;    // 2 bits
+    u8_t  clk_div;    // 7 bits
+    u8_t  pll_n;      // 5 bits
+    u16_t pll_m;      // 9 bits
+    u8_t  pll_od;     // 7 bits
+    u8_t  pll_sys_xd; // 5 bits
+    u8_t  pll_adc_xd; // 5 bits
+    u8_t  agc_sel;    // pin mux
+    u8_t  adc_en;     // 1:on
+    u8_t  debug;      // 1:debug
+    u32_t i2c;        // pointer
+    u32_t adc_clk;
+	u32_t demod_clk;
+};
+
+struct aml_demod_sts {
+    u32_t ch_sts;
+    u32_t freq_off;   // Hz
+    u32_t ch_pow;
+    u32_t ch_snr;
+    u32_t ch_ber;
+    u32_t ch_per;
+    u32_t symb_rate;
+    u32_t dat0;
+    u32_t dat1;
+};
+
+struct aml_demod_sta {
+    u8_t  clk_en;     // on/off
+    u8_t  adc_en;     // on/off
+    u32_t clk_freq;   // kHz
+    u32_t adc_freq;   // kHz
+    u8_t  dvb_mode;   // dvb-t/c mode
+    u8_t  ch_mode;    // 16,32,..,256QAM or 2K,4K,8K
+    u8_t  agc_mode;   // if, rf or both.
+    u8_t  tuner;      // type
+    u32_t ch_freq;    // kHz
+    u16_t ch_if;      // kHz
+    u16_t ch_bw;      // kHz
+    u16_t symb_rate;  // kHz
+    u8_t  debug;
+    u8_t  tmp;
+    u32_t sts;        // pointer
+};
+
+struct aml_demod_dvbc {
+    u8_t  mode;
+    u8_t  tmp;
+    u16_t symb_rate;
+    u32_t ch_freq;
+    u32_t dat0;
+    u32_t dat1;
+};
+
+struct aml_demod_dvbt {
+    u8_t  bw;
+    u8_t  sr;
+    u8_t  ifreq;
+    u8_t  agc_mode;
+    u32_t ch_freq;
+    u32_t dat0;
+    u32_t dat1;
+    u32_t layer;
+
+};
+
+struct aml_demod_dtmb {
+    u8_t  bw;
+    u8_t  sr;
+    u8_t  ifreq;
+    u8_t  agc_mode;
+    u32_t ch_freq;
+    u32_t dat0;
+    u32_t dat1;
+	u32_t mode;
+
+};
+
+struct aml_demod_atsc {
+    u8_t  bw;
+    u8_t  sr;
+    u8_t  ifreq;
+    u8_t  agc_mode;
+    u32_t ch_freq;
+    u32_t dat0;
+    u32_t dat1;
+	u32_t mode;
+
+};
+
+struct aml_demod_mem {
+    u32_t addr;
+    u32_t dat;
+
+
+};
+
+struct aml_cap_data {
+	u32_t cap_addr;
+	u32_t cap_size;
+	u32_t cap_afifo;
+
+};
+
+
+
+
+struct aml_demod_reg {
+    u8_t  mode; // 0: dvbc, 1: demod, 2: dvbt, 3:other, 10:i2c
+    u8_t  rw;   // 0: read, 1: write.
+    u32_t addr;
+    u32_t val;
+};
+
+struct aml_demod_regs {
+    u8_t  mode; // 0: dvbc, 1: demod, 2: dvbt, 3:other, 10:i2c
+    u8_t  rw;   // 0: read, 1: write.
+    u32_t addr;
+    u32_t addr_len;
+    u32_t n;
+    u32_t vals[1];/*[mode i2c]: write:n*u32_t, read:n*u8_t*/
+};
+struct fpga_m1_sdio {
+	  unsigned long addr;
+	  unsigned long byte_count;
+	  unsigned char *data_buf;
+} ;
+
+#define AML_DEMOD_SET_SYS        _IOW('D',  0, struct aml_demod_sys)
+#define AML_DEMOD_GET_SYS        _IOR('D',  1, struct aml_demod_sys)
+#define AML_DEMOD_TEST           _IOR('D',  2, u32_t)
+#define AML_DEMOD_TURN_ON        _IOR('D',  3, u32_t)
+#define AML_DEMOD_TURN_OFF       _IOR('D',  4, u32_t)
+#define AML_DEMOD_SET_TUNER      _IOW('D',  5, struct aml_tuner_sys)
+#define AML_DEMOD_GET_RSSI       _IOR('D',  6, u32_t)
+
+
+
+#define AML_DEMOD_DVBC_SET_CH    _IOW('D', 10, struct aml_demod_dvbc)
+#define AML_DEMOD_DVBC_GET_CH    _IOR('D', 11, struct aml_demod_dvbc)
+#define AML_DEMOD_DVBC_TEST      _IOR('D', 12, u32_t)
+
+#define AML_DEMOD_DVBT_SET_CH    _IOW('D', 20, struct aml_demod_dvbt)
+#define AML_DEMOD_DVBT_GET_CH    _IOR('D', 21, struct aml_demod_dvbt)
+#define AML_DEMOD_DVBT_TEST      _IOR('D', 22, u32_t)
+
+#define AML_DEMOD_DTMB_SET_CH    _IOW('D', 50, struct aml_demod_dtmb)
+#define AML_DEMOD_DTMB_GET_CH    _IOR('D', 51, struct aml_demod_dtmb)
+#define AML_DEMOD_DTMB_TEST      _IOR('D', 52, u32_t)
+
+#define AML_DEMOD_ATSC_SET_CH    _IOW('D', 60, struct aml_demod_atsc)
+#define AML_DEMOD_ATSC_GET_CH    _IOR('D', 61, struct aml_demod_atsc)
+#define AML_DEMOD_ATSC_TEST      _IOR('D', 62, u32_t)
+#define AML_DEMOD_ATSC_IRQ       _IOR('D', 63, u32_t)
+
+
+#define AML_DEMOD_RESET_MEM		  _IOR('D', 70, u32_t)
+#define	AML_DEMOD_READ_MEM		  _IOR('D', 71, u32_t)
+#define AML_DEMOD_SET_MEM		  _IOR('D', 72, struct aml_demod_mem)
+
+
+
+#define AML_DEMOD_SET_REG        _IOW('D', 30, struct aml_demod_reg)
+#define AML_DEMOD_GET_REG        _IOR('D', 31, struct aml_demod_reg)
+#define AML_DEMOD_SET_REGS        _IOW('D', 32, struct aml_demod_regs)
+#define AML_DEMOD_GET_REGS        _IOR('D', 33, struct aml_demod_regs)
+#define FPGA2M1_SDIO_WR_DDR      _IOW('D', 40, struct fpga_m1_sdio)
+#define FPGA2M1_SDIO_RD_DDR      _IOR('D', 41, struct fpga_m1_sdio)
+#define FPGA2M1_SDIO_INIT        _IO('D', 42)
+#define FPGA2M1_SDIO_EXIT        _IO('D', 43)
+
+int read_memory_to_file(struct aml_cap_data *cap);
+int read_reg(int addr);
+void wait_capture(int cap_cur_addr, int depth_MB, int start);
+int cap_adc_data(struct aml_cap_data *cap);
+
+
+
+
+#endif /* AML_DEMOD_H */
diff --git a/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c b/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
new file mode 100755
index 000000000000..8729207229ab
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
@@ -0,0 +1,1309 @@
+/*****************************************************************
+**
+**  Copyright (C) 2009 Amlogic,Inc.
+**  All rights reserved
+**        Filename : amlfrontend.c
+**
+**  comment:
+**        Driver for m6_demod demodulator
+**  author :
+**	    Shijie.Rong@amlogic
+**  version :
+**	    v1.0	 12/3/13
+*****************************************************************/
+
+/*
+    Driver for m6_demod demodulator
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+#include <mach/am_regs.h>
+#endif
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include "../aml_fe.h"
+
+#include "aml_demod.h"
+#include "demod_func.h"
+#include "../aml_dvb.h"
+#include "amlfrontend.h"
+
+#define pr_dbg(fmt, args...)\
+	do{\
+		if(debug_aml)\
+			printk("FE: " fmt, ## args);\
+	}while(0)
+
+MODULE_PARM_DESC(debug_aml, "\n\t\t Enable frontend debug information");
+static int debug_aml = 1;
+module_param(debug_aml, int, S_IRUGO);
+
+#define pr_error(fmt, args...) printk("M6_DEMOD: "fmt, ## args)
+
+static int last_lock=-1;
+#define DEMOD_DEVICE_NAME  "m6_demod"
+
+
+static int freq_dvbc=0;
+static struct aml_demod_sta demod_status;
+static fe_modulation_t atsc_mode=VSB_8;
+
+
+MODULE_PARM_DESC(frontend_mode, "\n\t\t Frontend mode 0-DVBC, 1-DVBT");
+static int frontend_mode = -1;
+module_param(frontend_mode, int, S_IRUGO);
+
+MODULE_PARM_DESC(frontend_i2c, "\n\t\t IIc adapter id of frontend");
+static int frontend_i2c = -1;
+module_param(frontend_i2c, int, S_IRUGO);
+
+MODULE_PARM_DESC(frontend_tuner, "\n\t\t Frontend tuner type 0-NULL, 1-DCT7070, 2-Maxliner, 3-FJ2207, 4-TD1316");
+static int frontend_tuner = -1;
+module_param(frontend_tuner, int, S_IRUGO);
+
+MODULE_PARM_DESC(frontend_tuner_addr, "\n\t\t Tuner IIC address of frontend");
+static int frontend_tuner_addr = -1;
+module_param(frontend_tuner_addr, int, S_IRUGO);
+static int autoflags=0,autoFlagsTrig=0;
+static struct mutex aml_lock;
+
+static int M6_Demod_Dvbc_Init(struct aml_fe_dev *dev,int mode);
+
+
+static ssize_t dvbc_auto_sym_show(struct class *cls,struct class_attribute *attr,char *buf)
+{
+        return sprintf(buf, "dvbc_autoflags: %s\n", autoflags?"on":"off");
+}
+static ssize_t dvbc_auto_sym_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
+{
+		int mode = simple_strtol(buf,0,16);
+		printk("autoflags is %d\n",mode);
+		autoFlagsTrig = 1;
+		autoflags = mode;
+		return count;
+
+}
+
+#ifdef CONFIG_AM_SI2176
+extern	int si2176_get_strength(void);
+#endif
+static ssize_t dvbc_para_show(struct class *cls,struct class_attribute *attr,char *buf)
+{
+	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	char *pbuf=buf;
+	int strength=0;
+
+	mutex_lock(&aml_lock);
+
+	dvbc_status(&demod_status,&demod_i2c, &demod_sts);
+	#ifdef CONFIG_AM_SI2176
+			 strength=si2176_get_strength();
+	#endif
+	pbuf+=sprintf(pbuf, "dvbc_para: ch_sts is %d", demod_sts.ch_sts);
+	pbuf+=sprintf(pbuf, "snr %d dB \n", demod_sts.ch_snr/100);
+	pbuf+=sprintf(pbuf, "ber %d", demod_sts.ch_ber);
+	pbuf+=sprintf(pbuf, "per %d \n", demod_sts.ch_per);
+	pbuf+=sprintf(pbuf, "srate %d", demod_sts.symb_rate);
+	pbuf+=sprintf(pbuf, "freqoff %d kHz \n", demod_sts.freq_off);
+	pbuf+=sprintf(pbuf, "power is %d db", demod_sts.ch_pow);
+	pbuf+=sprintf(pbuf, "tuner strength -%d db", (256-strength));
+
+	mutex_unlock(&aml_lock);
+
+	return pbuf-buf;
+}
+static ssize_t dvbc_para_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
+{
+	int mode = simple_strtol(buf,0,16);
+	printk("autoflags is %d\n",mode);
+	return count;
+}
+
+static int readregdata=0;
+
+static ssize_t dvbc_reg_show(struct class *cls,struct class_attribute *attr,char *buf)
+{
+//	int readregaddr=0;
+	char *pbuf=buf;
+	pbuf+=sprintf(pbuf, "%x", readregdata);
+
+	printk("read dvbc_reg\n");
+	return pbuf-buf;
+
+}
+
+static ssize_t dvbc_reg_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
+{
+	int setregaddr=0;
+	int setregdata=0;
+	int settunerfreq=0;
+	int n=0;
+    char *buf_orig, *ps, *token;
+    char *parm[8];
+	struct aml_cap_data cap;
+    buf_orig = kstrdup(buf, GFP_KERNEL);
+    ps = buf_orig;
+	printk("write dvbc_reg\n");
+	mutex_lock(&aml_lock);
+ 	while (1) {
+            token = strsep(&ps, "\b");
+            if (token == NULL)
+                    break;
+            if (*token == '\0')
+                    continue;
+            parm[n++] = token;
+			printk("parm[%p]\n",parm[n]);
+    }
+	if (!strncmp(parm[0],"w",strlen("w")))  //write reg
+    {
+     /*   if (n != 2)
+        {
+                pr_err("read: invalid parameter\n");
+                kfree(buf_orig);
+                return count;
+        }*/
+        printk("write\n");
+        setregaddr = simple_strtol(parm[1], NULL, 16);
+		setregdata = simple_strtol(parm[2], NULL, 16);
+		printk("[debug][W]reg[%x]now set to[%x]\n",setregaddr,setregdata);
+		apb_write_reg(QAM_BASE+setregaddr,setregdata);
+		printk("[debug][W]reg[%x]now set to[%x]\n",setregaddr,setregdata);
+	}else if(!strncmp(parm[0],"r",strlen("r")))   //read reg
+    {
+        setregaddr = simple_strtol(parm[1], NULL, 16);
+		readregdata=apb_read_reg(QAM_BASE+setregaddr);
+		printk("[debug][R]reg[%x]now is[%x]\n",setregaddr,setregdata);
+	}else if(!strncmp(parm[0],"c",strlen("c")))   //capture data
+    {
+      /*  if (n != 2)
+        {
+                pr_err("read: invalid parameter\n");
+                kfree(buf_orig);
+                return count;
+        }*/
+      //  setregaddr = simple_strtol(parm[1], NULL, 16);
+	    cap.cap_addr=0x94400000;
+		cap.cap_size=4*1024*1024;
+		cap.cap_afifo=0x60;
+	  	cap_adc_data(&cap);
+		printk("[capture]now begin to capture data[%x][%x]\n",cap.cap_addr,cap.cap_size);
+	}else if(!strncmp(parm[0],"t",strlen("t")))   //set tuner
+    {
+        settunerfreq = simple_strtol(parm[1], NULL, 16);
+
+		printk("[debug][R]reg[%x]now is[%x]\n",setregaddr,setregdata);
+	}else
+                printk("invalid command\n");
+        kfree(buf_orig);
+
+		mutex_unlock(&aml_lock);
+        return count;
+
+
+}
+
+
+
+static CLASS_ATTR(auto_sym,0644,dvbc_auto_sym_show,dvbc_auto_sym_store);
+static CLASS_ATTR(dvbc_para,0644,dvbc_para_show,dvbc_para_store);
+static CLASS_ATTR(dvbc_reg,0666,dvbc_reg_show,dvbc_reg_store);
+
+
+static irqreturn_t amdemod_isr(int irq, void *data)
+{
+/*	struct aml_fe_dev *state = data;
+
+	#define dvb_isr_islock()	(((frontend_mode==0)&&dvbc_isr_islock()) \
+								||((frontend_mode==1)&&dvbt_isr_islock()))
+	#define dvb_isr_monitor()       do { if(frontend_mode==1) dvbt_isr_monitor(); }while(0)
+	#define dvb_isr_cancel()	do { if(frontend_mode==1) dvbt_isr_cancel(); \
+		else if(frontend_mode==0) dvbc_isr_cancel();}while(0)
+
+
+	dvb_isr_islock();
+	{
+		if(waitqueue_active(&state->lock_wq))
+			wake_up_interruptible(&state->lock_wq);
+	}
+
+	dvb_isr_monitor();
+
+	dvb_isr_cancel();*/
+
+	return IRQ_HANDLED;
+}
+
+static int install_isr(struct aml_fe_dev *state)
+{
+	int r = 0;
+
+	/* hook demod isr */
+	pr_dbg("amdemod irq register[IRQ(%d)].\n", INT_DEMOD);
+	r = request_irq(INT_DEMOD, &amdemod_isr,
+				IRQF_SHARED, "amldemod",
+				(void *)state);
+	if (r) {
+		pr_error("amdemod irq register error.\n");
+	}
+	return r;
+}
+
+static void uninstall_isr(struct aml_fe_dev *state)
+{
+	pr_dbg("amdemod irq unregister[IRQ(%d)].\n", INT_DEMOD);
+
+	free_irq(INT_DEMOD, (void*)state);
+}
+
+
+static int amdemod_qam(fe_modulation_t qam)
+{
+	switch(qam)
+	{
+		case QAM_16:  return 0;
+		case QAM_32:  return 1;
+		case QAM_64:  return 2;
+		case QAM_128: return 3;
+		case QAM_256: return 4;
+		case VSB_8:	  return 5;
+		case QAM_AUTO:	  return 6;
+		default:          return 2;
+	}
+	return 2;
+}
+
+
+static int amdemod_stat_islock(struct aml_fe_dev *dev, int mode)
+{
+	struct aml_demod_sts demod_sts;
+	int lock_status;
+
+	if(mode==0){
+		/*DVBC*/
+		//dvbc_status(state->sta, state->i2c, &demod_sts);
+		demod_sts.ch_sts = apb_read_reg(QAM_BASE+0x18);
+		return (demod_sts.ch_sts&0x1);
+	} else if (mode==1){
+		/*DVBT*/
+		lock_status=(apb_read_reg(DVBT_BASE+(0x2a<<2)))&0xf;
+		if((lock_status==9)||(lock_status==10)&&(((apb_read_reg(DVBT_BASE+(0x0a<<2))>>20)&0x3ff)!=0)){
+			return 1;
+		}else{
+			return 0;
+		}
+	 //((apb_read_reg(DVBT_BASE+0x0)>>12)&0x1);//dvbt_get_status_ops()->get_status(&demod_sts, &demod_sta);
+	}else if (mode==2){
+		/*ISDBT*/
+	//	return dvbt_get_status_ops()->get_status(demod_sts, demod_sta);
+	}else if (mode==3){
+		/*ATSC*/
+			if((atsc_mode==QAM_64)||(atsc_mode==QAM_256)){
+				return ((atsc_read_iqr_reg()>>16)==0x1f);//
+			}else if(atsc_mode==VSB_8){
+				return (atsc_read_reg(0x0980)==0x79);
+			}else{
+				return ((atsc_read_iqr_reg()>>16)==0x1f);
+			}
+	}else if (mode==4){
+		/*DTMB*/
+			printk("DTMB lock status is %lu\n",((apb_read_reg(DTMB_BASE+(0x0e3<<2))>>12)&0x1));
+			return (apb_read_reg(DTMB_BASE+(0x0e3<<2))>>12)&0x1;
+	}
+	return 0;
+}
+#define amdemod_dvbc_stat_islock(dev)  amdemod_stat_islock((dev), 0)
+#define amdemod_dvbt_stat_islock(dev)  amdemod_stat_islock((dev), 1)
+#define amdemod_isdbt_stat_islock(dev)  amdemod_stat_islock((dev), 2)
+#define amdemod_atsc_stat_islock(dev)  amdemod_stat_islock((dev), 3)
+#define amdemod_dtmb_stat_islock(dev)  amdemod_stat_islock((dev), 4)
+
+
+static int m6_demod_dvbc_set_qam_mode(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_dvbc param;//mode 0:16, 1:32, 2:64, 3:128, 4:256
+	memset(&param, 0, sizeof(param));
+	param.mode = amdemod_qam(c->modulation);
+	dvbc_set_qam_mode(param.mode);
+	return 0;
+}
+
+
+static void m6_demod_dvbc_release(struct dvb_frontend *fe)
+{
+	struct aml_fe_dev *state = fe->demodulator_priv;
+
+	uninstall_isr(state);
+
+	kfree(state);
+}
+
+
+static int m6_demod_dvbc_read_status(struct dvb_frontend *fe, fe_status_t * status)
+{
+//	struct aml_fe_dev *dev = afe->dtv_demod;
+	struct aml_demod_sts demod_sts;
+//	struct aml_demod_sta demod_sta;
+//	struct aml_demod_i2c demod_i2c;
+	int ilock;
+	demod_sts.ch_sts = apb_read_reg(QAM_BASE+0x18);
+//	dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
+	if(demod_sts.ch_sts&0x1)
+	{
+		ilock=1;
+		*status = FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC;
+	}
+	else
+	{
+		ilock=0;
+		*status = FE_TIMEDOUT;
+	}
+	if(last_lock != ilock){
+		pr_error("%s.\n", ilock? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
+		last_lock = ilock;
+	}
+
+	return  0;
+}
+
+static int m6_demod_dvbc_read_ber(struct dvb_frontend *fe, u32 * ber)
+{
+	//struct aml_fe_dev *dev = afe->dtv_demod;
+	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+
+
+	dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
+	*ber = demod_sts.ch_ber;
+	return 0;
+}
+
+static int m6_demod_dvbc_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*strength=256-tuner_get_ch_power(dev);
+
+	return 0;
+}
+
+static int m6_demod_dvbc_read_snr(struct dvb_frontend *fe, u16 * snr)
+{
+	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+	dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
+	*snr = demod_sts.ch_snr/100;
+	return 0;
+}
+
+static int m6_demod_dvbc_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)
+{
+	*ucblocks=0;
+	return 0;
+}
+
+extern int aml_fe_analog_set_frontend(struct dvb_frontend* fe);
+static int m6_demod_dvbc_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_dvbc param;//mode 0:16, 1:32, 2:64, 3:128, 4:256
+	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int error,times;
+	demod_i2c.tuner=dev->drv->id;
+	demod_i2c.addr=dev->i2c_addr;
+	times = 2;
+	memset(&param, 0, sizeof(param));
+	param.ch_freq = c->frequency/1000;
+	param.mode = amdemod_qam(c->modulation);
+	param.symb_rate = c->symbol_rate/1000;
+	if((param.mode==3)&&(demod_status.tmp!=Adc_mode)){
+		M6_Demod_Dvbc_Init(dev,Adc_mode);
+		printk("M6_Demod_Dvbc_Init,Adc_mode\n");
+	}else{
+	//	M6_Demod_Dvbc_Init(dev,Cry_mode);
+	}
+	if(autoflags==0){
+	//	printk("QAM_TUNING mode \n");
+		//	flag=0;
+	}
+	if((autoflags==1)&&(autoFlagsTrig == 0)&&(freq_dvbc==param.ch_freq)){
+		printk("now is auto symbrating\n");
+		return 0;
+	}
+	autoFlagsTrig = 0;
+	last_lock = -1;
+	pr_dbg("[m6_demod_dvbc_set_frontend]PARA demod_i2c.tuner is %d||||demod_i2c.addr is %d||||param.ch_freq is %d||||param.symb_rate is %d,param.mode is %d\n",
+		demod_i2c.tuner,demod_i2c.addr,param.ch_freq,param.symb_rate,param.mode);
+retry:
+	aml_dmx_before_retune(afe->ts, fe);
+	aml_fe_analog_set_frontend(fe);
+	dvbc_set_ch(&demod_status, &demod_i2c, &param);
+	if(autoflags==1){
+		printk("QAM_PLAYING mode,start auto sym\n");
+		dvbc_set_auto_symtrack();
+	//	flag=1;
+	}
+//rsj_debug
+
+    dvbc_status(&demod_status,&demod_i2c, &demod_sts);
+	freq_dvbc=param.ch_freq;
+
+	times--;
+	if(amdemod_dvbc_stat_islock(dev) && times){
+		int lock;
+
+		aml_dmx_start_error_check(afe->ts, fe);
+		msleep(20);
+		error = aml_dmx_stop_error_check(afe->ts, fe);
+		lock  = amdemod_dvbc_stat_islock(dev);
+		if((error > 200) || !lock){
+			pr_error("amlfe too many error, error count:%d lock statuc:%d, retry\n", error, lock);
+			goto retry;
+		}
+	}
+
+	aml_dmx_after_retune(afe->ts, fe);
+
+	afe->params = *c;
+/*	afe->params.frequency = c->frequency;
+	afe->params.u.qam.symbol_rate = c->symbol_rate;
+	afe->params.u.qam.modulation = c->modulation;*/
+
+
+	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",c->frequency,c->symbol_rate);
+	return  0;
+
+}
+
+static int m6_demod_dvbc_get_frontend(struct dvb_frontend *fe)
+{//these content will be writed into eeprom .
+
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int qam_mode;
+	qam_mode=apb_read_reg(QAM_BASE+0x008);
+	afe->params.modulation=(qam_mode&7)+1;
+	printk("[mode] is %d\n",afe->params.modulation);
+
+	*c=afe->params;
+/*	c->modulation= afe->params.u.qam.modulation;
+	c->frequency= afe->params.frequency;
+	c->symbol_rate= afe->params.u.qam.symbol_rate;*/
+	return 0;
+}
+
+
+static int M6_Demod_Dvbc_Init(struct aml_fe_dev *dev,int mode)
+{
+	struct aml_demod_sys sys;
+	struct aml_demod_i2c i2c;
+	pr_dbg("AML Demod DVB-C init\r\n");
+	memset(&sys, 0, sizeof(sys));
+	memset(&i2c, 0, sizeof(i2c));
+	i2c.tuner = dev->drv->id;
+	i2c.addr = dev->i2c_addr;
+	// 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC
+	demod_status.dvb_mode = M6_Dvbc;
+
+	if(mode==Adc_mode){
+    	sys.adc_clk=35000;
+    	sys.demod_clk=100000;
+		demod_status.tmp=Adc_mode;
+	}else{
+		sys.adc_clk=Adc_Clk_24M;
+    	sys.demod_clk=Demod_Clk_72M;
+		demod_status.tmp=Cry_mode;
+	}
+	demod_status.ch_if=Si2176_5M_If*1000;
+	pr_dbg("[%s]adc_clk is %d,demod_clk is %d\n",__func__,sys.adc_clk,sys.demod_clk);
+	autoFlagsTrig = 1;
+	demod_set_sys(&demod_status, &i2c, &sys);
+	return 0;
+}
+
+
+static void m6_demod_dvbt_release(struct dvb_frontend *fe)
+{
+	struct aml_fe_dev *state = fe->demodulator_priv;
+
+	uninstall_isr(state);
+
+	kfree(state);
+}
+
+
+static int m6_demod_dvbt_read_status(struct dvb_frontend *fe, fe_status_t * status)
+{
+//	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+	int ilock;
+	unsigned char s=0;
+	s = dvbt_get_status_ops()->get_status(&demod_sta, &demod_i2c);
+	if(s==1)
+	{
+		ilock=1;
+		*status = FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC;
+	}
+	else
+	{
+		ilock=0;
+		*status = FE_TIMEDOUT;
+	}
+	if(last_lock != ilock){
+		pr_error("%s.\n", ilock? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
+		last_lock = ilock;
+	}
+
+	return  0;
+}
+
+static int m6_demod_dvbt_read_ber(struct dvb_frontend *fe, u32 * ber)
+{
+//	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+
+
+	*ber = dvbt_get_status_ops()->get_ber(&demod_sta, &demod_i2c)&0xffff;
+	return 0;
+}
+
+static int m6_demod_dvbt_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*strength=256-tuner_get_ch_power(dev);
+	printk("[RSJ]tuner strength is %d dbm\n",*strength);
+	return 0;
+}
+
+static int m6_demod_dvbt_read_snr(struct dvb_frontend *fe, u16 * snr)
+{
+//	struct aml_fe *afe = fe->demodulator_priv;
+//	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	struct aml_demod_sta demod_sta;
+
+
+	*snr = dvbt_get_status_ops()->get_snr(&demod_sta, &demod_i2c);
+	*snr/=8;
+	printk("[RSJ]snr is %d dbm\n",*snr);
+	return 0;
+}
+
+static int m6_demod_dvbt_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)
+{
+	*ucblocks=0;
+	return 0;
+}
+
+
+
+static int m6_demod_dvbt_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	//struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	int error,times;
+	struct aml_demod_dvbt param;
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	demod_i2c.tuner=dev->drv->id;
+	demod_i2c.addr=dev->i2c_addr;
+
+	times = 2;
+
+    //////////////////////////////////////
+    // bw == 0 : 8M
+    //       1 : 7M
+    //       2 : 6M
+    //       3 : 5M
+    // agc_mode == 0: single AGC
+    //             1: dual AGC
+    //////////////////////////////////////
+    memset(&param, 0, sizeof(param));
+	param.ch_freq = c->frequency/1000;
+	param.bw = c->bandwidth_hz;
+	param.agc_mode = 1;
+	/*ISDBT or DVBT : 0 is QAM, 1 is DVBT, 2 is ISDBT, 3 is DTMB, 4 is ATSC */
+	param.dat0 = 1;
+	last_lock = -1;
+
+retry:
+	aml_dmx_before_retune(AM_TS_SRC_TS2, fe);
+	aml_fe_analog_set_frontend(fe);
+	dvbt_set_ch(&demod_status, &demod_i2c, &param);
+
+	/*	for(count=0;count<10;count++){
+			if(amdemod_dvbt_stat_islock(dev)){
+				printk("first lock success\n");
+				break;
+			}
+
+			msleep(200);
+		}	*/
+//rsj_debug
+
+//
+
+	times--;
+	if(amdemod_dvbt_stat_islock(dev) && times){
+		int lock;
+
+		aml_dmx_start_error_check(AM_TS_SRC_TS2, fe);
+		msleep(20);
+		error = aml_dmx_stop_error_check(AM_TS_SRC_TS2, fe);
+		lock  = amdemod_dvbt_stat_islock(dev);
+		if((error > 200) || !lock){
+			pr_error("amlfe too many error, error count:%d lock statuc:%d, retry\n", error, lock);
+			goto retry;
+		}
+	}
+
+	aml_dmx_after_retune(AM_TS_SRC_TS2, fe);
+
+
+	afe->params = *c;
+
+
+//	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",p->frequency,p->u.qam.symbol_rate);
+	return  0;
+
+}
+
+static int m6_demod_dvbt_get_frontend(struct dvb_frontend *fe)
+{//these content will be writed into eeprom .
+
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_fe *afe = fe->demodulator_priv;
+
+	*c = afe->params;
+	return 0;
+}
+
+
+
+int M6_Demod_Dvbt_Init(struct aml_fe_dev *dev)
+{
+	struct aml_demod_sys sys;
+	struct aml_demod_i2c i2c;
+
+	pr_dbg("AML Demod DVB-T init\r\n");
+
+	memset(&sys, 0, sizeof(sys));
+	memset(&i2c, 0, sizeof(i2c));
+	memset(&demod_status, 0, sizeof(demod_status));
+	i2c.tuner = dev->drv->id;
+	i2c.addr = dev->i2c_addr;
+	// 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC
+	demod_status.dvb_mode = M6_Dvbt_Isdbt;
+	sys.adc_clk=Adc_Clk_24M;
+	sys.demod_clk=Demod_Clk_60M;
+	demod_status.ch_if=Si2176_5M_If*1000;
+	demod_set_sys(&demod_status, &i2c, &sys);
+	return 0;
+}
+
+
+static void m6_demod_atsc_release(struct dvb_frontend *fe)
+{
+	struct aml_fe_dev *state = fe->demodulator_priv;
+
+	uninstall_isr(state);
+
+	kfree(state);
+}
+
+static int m6_demod_atsc_set_qam_mode(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_atsc param;//mode  3:64,  5:256, 7:vsb
+	fe_modulation_t mode;
+	memset(&param, 0, sizeof(param));
+	mode = c->modulation;
+	printk("mode is %d\n",mode);
+	atsc_qam_set(mode);
+	return 0;
+}
+
+
+
+static int m6_demod_atsc_read_status(struct dvb_frontend *fe, fe_status_t * status)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+//	struct aml_demod_i2c demod_i2c;
+//	struct aml_demod_sta demod_sta;
+	int ilock;
+	unsigned char s=0;
+	s = amdemod_atsc_stat_islock(dev);
+	if(s==1)
+	{
+		ilock=1;
+		*status = FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC;
+	}
+	else
+	{
+		ilock=0;
+		*status = FE_TIMEDOUT;
+	}
+	if(last_lock != ilock){
+		pr_error("%s.\n", ilock? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
+		last_lock = ilock;
+	}
+
+	return  0;
+}
+
+static int m6_demod_atsc_read_ber(struct dvb_frontend *fe, u32 * ber)
+{
+//	struct aml_fe *afe = fe->demodulator_priv;
+//	struct aml_fe_dev *dev = afe->dtv_demod;
+//	struct aml_demod_sts demod_sts;
+//	struct aml_demod_i2c demod_i2c;
+//	struct aml_demod_sta demod_sta;
+
+// check_atsc_fsm_status();
+	return 0;
+}
+
+static int m6_demod_atsc_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*strength=tuner_get_ch_power(dev);
+	return 0;
+}
+
+static int m6_demod_atsc_read_snr(struct dvb_frontend *fe, u16 * snr)
+{
+//	struct aml_fe *afe = fe->demodulator_priv;
+//	struct aml_fe_dev *dev = afe->dtv_demod;
+
+//	struct aml_demod_sts demod_sts;
+//	struct aml_demod_i2c demod_i2c;
+//	struct aml_demod_sta demod_sta;
+
+//	* snr=check_atsc_fsm_status();
+	return 0;
+}
+
+static int m6_demod_atsc_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)
+{
+	*ucblocks=0;
+	return 0;
+}
+
+static int m6_demod_atsc_set_frontend(struct dvb_frontend *fe)
+{
+//	struct amlfe_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_atsc param;
+//	struct aml_demod_sta demod_sta;
+//	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	int error,times;
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	demod_i2c.tuner=dev->drv->id;
+	demod_i2c.addr=dev->i2c_addr;
+	times = 2;
+
+	memset(&param, 0, sizeof(param));
+	param.ch_freq = c->frequency/1000;
+
+	last_lock = -1;
+	//p->u.vsb.modulation=QAM_64;
+	atsc_mode=c->modulation;
+   // param.mode = amdemod_qam(p->u.vsb.modulation);
+   	param.mode=c->modulation;
+
+retry:
+	aml_dmx_before_retune(AM_TS_SRC_TS2, fe);
+	aml_fe_analog_set_frontend(fe);
+	atsc_set_ch(&demod_status, &demod_i2c, &param);
+
+	/*{
+		int ret;
+		ret = wait_event_interruptible_timeout(dev->lock_wq, amdemod_atsc_stat_islock(dev), 4*HZ);
+		if(!ret)	pr_error("amlfe wait lock timeout.\n");
+	}*/
+//rsj_debug
+	/*	int count;
+		for(count=0;count<10;count++){
+			if(amdemod_atsc_stat_islock(dev)){
+				printk("first lock success\n");
+				break;
+			}
+
+			msleep(200);
+		}	*/
+
+	times--;
+	if(amdemod_atsc_stat_islock(dev) && times){
+		int lock;
+
+		aml_dmx_start_error_check(AM_TS_SRC_TS2, fe);
+		msleep(20);
+		error = aml_dmx_stop_error_check(AM_TS_SRC_TS2, fe);
+		lock  = amdemod_atsc_stat_islock(dev);
+		if((error > 200) || !lock){
+			pr_error("amlfe too many error, error count:%d lock statuc:%d, retry\n", error, lock);
+			goto retry;
+		}
+	}
+
+	aml_dmx_after_retune(AM_TS_SRC_TS2, fe);
+
+	afe->params = *c;
+//	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",p->frequency,p->u.qam.symbol_rate);
+	return  0;
+
+}
+
+static int m6_demod_atsc_get_frontend(struct dvb_frontend *fe)
+{//these content will be writed into eeprom .
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_fe *afe = fe->demodulator_priv;
+	printk("c->frequency is %d\n",c->frequency);
+	*c = afe->params;
+	return 0;
+}
+
+
+
+int M6_Demod_Atsc_Init(struct aml_fe_dev *dev)
+{
+	struct aml_demod_sys sys;
+	struct aml_demod_i2c i2c;
+
+	pr_dbg("AML Demod ATSC init\r\n");
+
+	memset(&sys, 0, sizeof(sys));
+	memset(&i2c, 0, sizeof(i2c));
+	memset(&demod_status, 0, sizeof(demod_status));
+	// 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC
+	demod_status.dvb_mode = M6_Atsc;
+	sys.adc_clk=Adc_Clk_25_2M;//Adc_Clk_26M;
+	sys.demod_clk=Demod_Clk_75M;//Demod_Clk_71M;//Demod_Clk_78M;
+	demod_status.ch_if=6350;
+	demod_status.tmp=Adc_mode;
+	demod_set_sys(&demod_status, &i2c, &sys);;
+	return 0;
+}
+
+
+//dtmb 20140106 for m6d
+
+static void m6_demod_dtmb_release(struct dvb_frontend *fe)
+{
+	struct aml_fe_dev *state = fe->demodulator_priv;
+
+	uninstall_isr(state);
+
+	kfree(state);
+}
+
+static int m6_demod_dtmb_read_status(struct dvb_frontend *fe, fe_status_t * status)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+//	struct aml_demod_i2c demod_i2c;
+//	struct aml_demod_sta demod_sta;
+	int ilock;
+	unsigned char s=0;
+//	s = amdemod_dtmb_stat_islock(dev);
+//	if(s==1)
+	s = dtmb_read_snr();
+	s = amdemod_dtmb_stat_islock(dev);
+	if(s==1)
+	{
+		ilock=1;
+		*status = FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC;
+	}
+	else
+	{
+		ilock=0;
+		*status = FE_TIMEDOUT;
+	}
+	if(last_lock != ilock){
+		pr_error("%s.\n", ilock? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
+		last_lock = ilock;
+	}
+
+	return  0;
+}
+
+static int m6_demod_dtmb_read_ber(struct dvb_frontend *fe, u32 * ber)
+{
+//	struct aml_fe *afe = fe->demodulator_priv;
+//	struct aml_fe_dev *dev = afe->dtv_demod;
+//	struct aml_demod_sts demod_sts;
+//	struct aml_demod_i2c demod_i2c;
+//	struct aml_demod_sta demod_sta;
+
+// check_atsc_fsm_status();
+	return 0;
+}
+
+static int m6_demod_dtmb_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*strength=tuner_get_ch_power(dev);
+	return 0;
+}
+
+static int m6_demod_dtmb_read_snr(struct dvb_frontend *fe, u16 * snr)
+{
+//	struct aml_fe *afe = fe->demodulator_priv;
+//	struct aml_fe_dev *dev = afe->dtv_demod;
+
+//	struct aml_demod_sts demod_sts;
+//	struct aml_demod_i2c demod_i2c;
+//	struct aml_demod_sta demod_sta;
+
+//	* snr=check_atsc_fsm_status();
+	return 0;
+}
+
+static int m6_demod_dtmb_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)
+{
+	*ucblocks=0;
+	return 0;
+}
+
+static int m6_demod_dtmb_set_frontend(struct dvb_frontend *fe)
+{
+
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_demod_dtmb param;
+//	struct aml_demod_sta demod_sta;
+//	struct aml_demod_sts demod_sts;
+	struct aml_demod_i2c demod_i2c;
+	int times;
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	demod_i2c.tuner=dev->drv->id;
+	demod_i2c.addr=dev->i2c_addr;
+	times = 2;
+	printk("m6_demod_dtmb_set_frontend,freq is %d\n",c->frequency);
+	memset(&param, 0, sizeof(param));
+	param.ch_freq = c->frequency/1000;
+
+	last_lock = -1;
+
+//	aml_dmx_before_retune(AM_TS_SRC_TS2, fe);
+	aml_fe_analog_set_frontend(fe);
+	dtmb_set_ch(&demod_status, &demod_i2c, &param);
+
+	/*{
+		int ret;
+		ret = wait_event_interruptible_timeout(dev->lock_wq, amdemod_atsc_stat_islock(dev), 4*HZ);
+		if(!ret)	pr_error("amlfe wait lock timeout.\n");
+	}*/
+//rsj_debug
+	/*	int count;
+		for(count=0;count<10;count++){
+			if(amdemod_atsc_stat_islock(dev)){
+				printk("first lock success\n");
+				break;
+			}
+
+			msleep(200);
+		}	*/
+
+/*	times--;
+	if(amdemod_dtmb_stat_islock(dev) && times){
+		int lock;
+
+		aml_dmx_start_error_check(AM_TS_SRC_TS2, fe);
+		msleep(20);
+		error = aml_dmx_stop_error_check(AM_TS_SRC_TS2, fe);
+		lock  = amdemod_dtmb_stat_islock(dev);
+		if((error > 200) || !lock){
+			pr_error("amlfe too many error, error count:%d lock statuc:%d, retry\n", error, lock);
+			goto retry;
+		}
+	}
+
+	aml_dmx_after_retune(AM_TS_SRC_TS2, fe);*/
+
+	afe->params = *c;
+//	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",p->frequency,p->u.qam.symbol_rate);
+	return  0;
+
+}
+
+static int m6_demod_dtmb_get_frontend(struct dvb_frontend *fe)
+{//these content will be writed into eeprom .
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct aml_fe *afe = fe->demodulator_priv;
+	printk("p->frequency is %d\n",c->frequency);
+	*c = afe->params;
+	return 0;
+}
+
+
+
+int M6_Demod_Dtmb_Init(struct aml_fe_dev *dev)
+{
+	struct aml_demod_sys sys;
+	struct aml_demod_i2c i2c;
+
+	pr_dbg("AML Demod DTMB init\r\n");
+
+	memset(&sys, 0, sizeof(sys));
+	memset(&i2c, 0, sizeof(i2c));
+	memset(&demod_status, 0, sizeof(demod_status));
+	// 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC
+	demod_status.dvb_mode = M6_Dtmb;
+	sys.adc_clk=Adc_Clk_25M;//Adc_Clk_26M;
+	sys.demod_clk=Demod_Clk_100M;
+	demod_status.ch_if=Si2176_5M_If;
+	demod_status.tmp=Adc_mode;
+	demod_set_sys(&demod_status, &i2c, &sys);;
+	return 0;
+}
+
+
+static int m6_demod_fe_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+	struct dvb_frontend_ops *fe_ops = (struct dvb_frontend_ops*)ops;
+	if(mode == AM_FE_OFDM){
+
+	fe_ops->info.frequency_min = 51000000;
+	fe_ops->info.frequency_max = 858000000;
+	fe_ops->info.frequency_stepsize = 0;
+	fe_ops->info.frequency_tolerance = 0;
+	fe_ops->info.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS;
+	fe_ops->release = m6_demod_dvbt_release;
+	fe_ops->set_frontend = m6_demod_dvbt_set_frontend;
+	fe_ops->get_frontend = m6_demod_dvbt_get_frontend;
+	fe_ops->read_status = m6_demod_dvbt_read_status;
+	fe_ops->read_ber = m6_demod_dvbt_read_ber;
+	fe_ops->read_signal_strength = m6_demod_dvbt_read_signal_strength;
+	fe_ops->read_snr = m6_demod_dvbt_read_snr;
+	fe_ops->read_ucblocks = m6_demod_dvbt_read_ucblocks;
+
+	pr_dbg("=========================dvbt demod init\r\n");
+	M6_Demod_Dvbt_Init(dev);
+	}
+	else if(mode == AM_FE_QAM){
+	fe_ops->info.frequency_min = 51000000;
+	fe_ops->info.frequency_max = 858000000;
+	fe_ops->info.frequency_stepsize = 0;
+	fe_ops->info.frequency_tolerance = 0;
+	fe_ops->info.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 |FE_CAN_QAM_32|FE_CAN_QAM_128|FE_CAN_QAM_256|
+			FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS;
+
+	fe_ops->release = m6_demod_dvbc_release;
+	fe_ops->set_frontend = m6_demod_dvbc_set_frontend;
+	fe_ops->get_frontend = m6_demod_dvbc_get_frontend;
+	fe_ops->read_status = m6_demod_dvbc_read_status;
+	fe_ops->read_ber = m6_demod_dvbc_read_ber;
+	fe_ops->read_signal_strength = m6_demod_dvbc_read_signal_strength;
+	fe_ops->read_snr = m6_demod_dvbc_read_snr;
+	fe_ops->read_ucblocks = m6_demod_dvbc_read_ucblocks;
+	fe_ops->set_qam_mode = m6_demod_dvbc_set_qam_mode;
+
+//	init_waitqueue_head(&dev->lock_wq);
+	install_isr(dev);
+	pr_dbg("=========================dvbc demod init\r\n");
+	M6_Demod_Dvbc_Init(dev,Adc_mode);
+	}else if(mode == AM_FE_ATSC){
+
+	fe_ops->info.frequency_min = 51000000;
+	fe_ops->info.frequency_max = 858000000;
+	fe_ops->info.frequency_stepsize = 0;
+	fe_ops->info.frequency_tolerance = 0;
+	fe_ops->info.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS;
+
+	fe_ops->release = m6_demod_atsc_release;
+	fe_ops->set_frontend = m6_demod_atsc_set_frontend;
+	fe_ops->get_frontend = m6_demod_atsc_get_frontend;
+	fe_ops->read_status = m6_demod_atsc_read_status;
+	fe_ops->read_ber = m6_demod_atsc_read_ber;
+	fe_ops->read_signal_strength = m6_demod_atsc_read_signal_strength;
+	fe_ops->read_snr = m6_demod_atsc_read_snr;
+	fe_ops->read_ucblocks = m6_demod_atsc_read_ucblocks;
+	fe_ops->set_qam_mode = m6_demod_atsc_set_qam_mode;
+	M6_Demod_Atsc_Init(dev);
+	}else if(mode == AM_FE_DTMB){
+
+	fe_ops->info.frequency_min = 51000000;
+	fe_ops->info.frequency_max = 858000000;
+	fe_ops->info.frequency_stepsize = 0;
+	fe_ops->info.frequency_tolerance = 0;
+	fe_ops->info.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS;
+
+	fe_ops->release = m6_demod_dtmb_release;
+	fe_ops->set_frontend = m6_demod_dtmb_set_frontend;
+	fe_ops->get_frontend = m6_demod_dtmb_get_frontend;
+	fe_ops->read_status = m6_demod_dtmb_read_status;
+	fe_ops->read_ber = m6_demod_dtmb_read_ber;
+	fe_ops->read_signal_strength = m6_demod_dtmb_read_signal_strength;
+	fe_ops->read_snr = m6_demod_dtmb_read_snr;
+	fe_ops->read_ucblocks = m6_demod_dtmb_read_ucblocks;
+	M6_Demod_Dtmb_Init(dev);
+	}
+	return 0;
+}
+
+static int m6_demod_fe_resume(struct aml_fe_dev *dev)
+{
+	pr_dbg("m6_demod_fe_resume\n");
+//	M6_Demod_Dvbc_Init(dev);
+	return 0;
+
+}
+
+static int m6_demod_fe_suspend(struct aml_fe_dev *dev)
+{
+	return 0;
+}
+
+static int m6_demod_fe_enter_mode(struct aml_fe *fe, int mode)
+{
+	autoFlagsTrig = 1;
+	/*struct aml_fe_dev *dev=fe->dtv_demod;
+	printk("fe->mode is %d",fe->mode);
+	if(fe->mode==AM_FE_OFDM){
+		M1_Demod_Dvbt_Init(dev);
+	}else if(fe->mode==AM_FE_QAM){
+		M1_Demod_Dvbc_Init(dev);
+	}else if (fe->mode==AM_FE_ATSC){
+		M6_Demod_Atsc_Init(dev);
+	}*/
+	return 0;
+}
+
+static int m6_demod_fe_leave_mode(struct aml_fe *fe, int mode)
+{
+	return 0;
+}
+
+
+
+
+static struct aml_fe_drv m6_demod_dtv_demod_drv = {
+.id         = AM_DTV_DEMOD_M1,
+.name       = "M6_DEMOD",
+.capability = AM_FE_QPSK|AM_FE_QAM|AM_FE_ATSC|AM_FE_OFDM|AM_FE_DTMB,
+.get_ops    = m6_demod_fe_get_ops,
+.suspend    = m6_demod_fe_suspend,
+.resume     = m6_demod_fe_resume,
+.enter_mode = m6_demod_fe_enter_mode,
+.leave_mode = m6_demod_fe_leave_mode
+};
+struct class *m6_clsp;
+struct class *m6_para_clsp;
+
+static int __init m6demodfrontend_init(void)
+{
+	int ret;
+	pr_dbg("register m6_demod demod driver\n");
+	ret=0;
+
+	mutex_init(&aml_lock);
+
+	m6_clsp = class_create(THIS_MODULE,DEMOD_DEVICE_NAME);
+    if(!m6_clsp)
+    {
+            pr_error("[m6 demod]%s:create class error.\n",__func__);
+            return PTR_ERR(m6_clsp);
+    }
+    ret = class_create_file(m6_clsp, &class_attr_auto_sym);
+    if(ret)
+            pr_error("[m6 demod]%s create  class file error.\n",__func__);
+
+    ret = class_create_file(m6_clsp, &class_attr_dvbc_para);
+    if(ret)
+            pr_error("[m6 demod]%s create  class file error.\n",__func__);
+
+	 ret = class_create_file(m6_clsp, &class_attr_dvbc_reg);
+    if(ret)
+            pr_error("[m6 demod]%s create  class file error.\n",__func__);
+
+
+	return aml_register_fe_drv(AM_DEV_DTV_DEMOD, &m6_demod_dtv_demod_drv);
+}
+
+
+static void __exit m6demodfrontend_exit(void)
+{
+	pr_dbg("unregister m6_demod demod driver\n");
+
+	mutex_destroy(&aml_lock);
+
+	class_remove_file(m6_clsp, &class_attr_auto_sym);
+	class_remove_file(m6_clsp, &class_attr_dvbc_para);
+	class_remove_file(m6_clsp, &class_attr_dvbc_reg);
+	class_destroy(m6_clsp);
+	aml_unregister_fe_drv(AM_DEV_DTV_DEMOD, &m6_demod_dtv_demod_drv);
+}
+
+fs_initcall(m6demodfrontend_init);
+module_exit(m6demodfrontend_exit);
+
+
+MODULE_DESCRIPTION("m6_demod DVB-T/DVB-C Demodulator driver");
+MODULE_AUTHOR("RSJ");
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/amlogic/dvb_tv/amldemod/amlfrontend.h b/drivers/amlogic/dvb_tv/amldemod/amlfrontend.h
new file mode 100755
index 000000000000..6f68ba476f11
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/amlfrontend.h
@@ -0,0 +1,75 @@
+/*****************************************************************
+**
+**  Copyright (C) 2010 Amlogic,Inc.
+**  All rights reserved
+**        Filename : amlfrontend.h
+**
+**  comment:
+**        Driver for aml demodulator
+**
+*****************************************************************/
+
+#ifndef _AMLFRONTEND_H
+#define _AMLFRONTEND_H
+
+struct amlfe_config {
+	int                   fe_mode;
+	int                   i2c_id;
+	int                   tuner_type;
+	int                   tuner_addr;
+};
+enum M6_Demod_Tuner_If
+{
+		Si2176_5M_If = 5,
+		Si2176_6M_If = 6
+};
+// 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC
+enum M6_Demod_Dvb_Mode
+{
+		M6_Dvbc = 0,
+		M6_Dvbt_Isdbt = 1 ,
+		M6_Atsc	= 2 ,
+		M6_Dtmb	= 3 ,
+};
+
+
+
+
+#define Adc_Clk_35M		35714     //adc clk    dvbc
+#define Demod_Clk_71M 	71428	  //demod clk
+
+#define Adc_Clk_24M		24000
+#define Demod_Clk_72M 	    72000
+#define Demod_Clk_60M 	    60000
+
+
+#define Adc_Clk_28M		28571 	  //dvbt,isdbt
+#define Demod_Clk_66M 	66666
+
+#define Adc_Clk_26M			26000   //atsc  air
+#define Demod_Clk_78M 	  78000//
+
+#define Adc_Clk_25_2M			25200   //atsc  cable
+#define Demod_Clk_75M 	  75600//
+
+#define Adc_Clk_25M			25000   //dtmb
+#define Demod_Clk_100M 	  100000//
+
+
+
+#define Adc_Clk_27M			27777   //atsc
+#define Demod_Clk_83M 	  83333//
+
+enum M6_Demod_Pll_Mode
+{
+		Cry_mode = 0,
+		Adc_mode = 1
+};
+
+
+/*
+struct dvb_frontend *aml_fe_dvbc_attach(const struct aml_fe_config *config, const int id);
+struct dvb_frontend *aml_fe_dvbt_attach(const struct aml_fe_config *config, const int id);
+*/
+
+#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/demod_func.c b/drivers/amlogic/dvb_tv/amldemod/demod_func.c
new file mode 100755
index 000000000000..712dcab182b2
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/demod_func.c
@@ -0,0 +1,2518 @@
+//#include "register.h"
+//#include "c_arc_pointer_reg.h"
+//#include "a9_func.h"
+//#include "clk_util.h"
+//#include "c_stimulus.h"
+//#include "a9_l2_func.h"
+
+#include "demod_func.h"
+#include "aml_demod.h"
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include "acf_filter_coefficient.h"
+#define M6D
+
+
+#define pr_dbg(fmt, args...)\
+	do{\
+		if(debug_demod)\
+			printk("FE: " fmt, ## args);\
+	}while(0)
+#define pr_error(fmt, args...) printk("FE: " fmt, ## args)
+
+MODULE_PARM_DESC(debug_demod, "\n\t\t Enable frontend debug information");
+static int debug_demod = 1;
+module_param(debug_demod, int, S_IRUGO);
+
+//8vsb
+static atsc_cfg_t list_8vsb[22] = {
+	{0x0733, 0x00, 0},
+	{0x0734, 0xff, 0},
+	{0x0716, 0x02, 0},		//F06[7] invert spectrum  0x02 0x06
+	{0x05e7, 0x00, 0},
+	{0x05e8, 0x00, 0},
+	{0x0f06, 0x80, 0},
+	{0x0f09, 0x04, 0},
+	{0x070c, 0x18, 0},
+	{0x070d, 0x9d, 0},
+	{0x070e, 0x89, 0},
+	{0x070f, 0x6a, 0},
+	{0x0710, 0x75, 0},
+	{0x0711, 0x6f, 0},
+	{0x072a, 0x02, 0},
+	{0x072c, 0x02, 0},
+	{0x090d, 0x03, 0},
+	{0x090e, 0x02, 0},
+	{0x090f, 0x00, 0},
+	{0x0900, 0x01, 0},
+	{0x0900, 0x00, 0},
+	{0x0f00, 0x01, 0},
+	{0x0000, 0x00, 1}};
+
+
+//64qam
+static atsc_cfg_t list_qam64[111] = {
+	{0x0900, 0x01, 0},
+	{0x0f04, 0x08, 0},
+	{0x0f06, 0x80, 0},
+	{0x0f07, 0x00, 0},
+	{0x0f00, 0xe0, 0},
+	{0x0f00, 0xec, 0},
+	{0x0001, 0x05, 0},
+	{0x0002, 0x61, 0},///0x61 invert spectrum
+	{0x0003, 0x3e, 0},
+	{0x0004, 0xed, 0},//0x9d
+	{0x0005, 0x10, 0},
+	{0x0006, 0xc0, 0},
+	{0x0007, 0x5c, 0},
+	{0x0008, 0x0f, 0},
+	{0x0009, 0x4f, 0},
+	{0x000a, 0xfc, 0},
+	{0x000b, 0x0c, 0},
+	{0x000c, 0x6c, 0},
+	{0x000d, 0x3a, 0},
+	{0x000e, 0x10, 0},
+	{0x000f, 0x02, 0},
+	{0x0011, 0x00, 0},
+	{0x0012, 0xf5, 0},
+	{0x0013, 0x74, 0},
+	{0x0014, 0xb9, 0},
+	{0x0015, 0x1f, 0},
+	{0x0016, 0x80, 0},
+	{0x0017, 0x1f, 0},
+	{0x0018, 0x0f, 0},
+	{0x001e, 0x00, 0},
+	{0x001f, 0x00, 0},
+	{0x0023, 0x03, 0},
+	{0x0025, 0x20, 0},
+	{0x0026, 0xff, 0},
+	{0x0027, 0xff, 0},
+	{0x0028, 0xf8, 0},
+	{0x0200, 0x20, 0},
+	{0x0201, 0x62, 0},
+	{0x0202, 0x23, 0},
+	{0x0204, 0x19, 0},
+	{0x0205, 0x74, 0},
+	{0x0206, 0xab, 0},
+	{0x0207, 0xff, 0},
+	{0x0208, 0xc0, 0},
+	{0x0209, 0xff, 0},
+	{0x0211, 0xc0, 0},
+	{0x0212, 0xb0, 0},
+	{0x0213, 0x05, 0},
+	{0x0215, 0x08, 0},
+	{0x0222, 0xe0, 0},
+	{0x0223, 0xf0, 0},
+	{0x0226, 0x40, 0},
+	{0x0229, 0x23, 0},
+	{0x022a, 0x02, 0},
+	{0x022c, 0x01, 0},
+	{0x022e, 0x01, 0},
+	{0x022f, 0x25, 0},
+	{0x0230, 0x40, 0},
+	{0x0231, 0x01, 0},
+	{0x0734, 0xff, 0},
+	{0x073a, 0xff, 0},
+	{0x073b, 0x04, 0},
+	{0x073c, 0x08, 0},
+	{0x073d, 0x08, 0},
+	{0x073e, 0x01, 0},
+	{0x073f, 0xf8, 0},
+	{0x0740, 0xf1, 0},
+	{0x0741, 0xf3, 0},
+	{0x0742, 0xff, 0},
+	{0x0743, 0x0f, 0},
+	{0x0744, 0x1a, 0},
+	{0x0745, 0x16, 0},
+	{0x0746, 0x00, 0},
+	{0x0747, 0xe3, 0},
+	{0x0748, 0xce, 0},
+	{0x0749, 0xd4, 0},
+	{0x074a, 0x00, 0},
+	{0x074b, 0x4b, 0},
+	{0x074c, 0x00, 0},
+	{0x074d, 0xa2, 0},
+	{0x074e, 0x00, 0},
+	{0x074f, 0xe6, 0},
+	{0x0750, 0x00, 0},
+	{0x0751, 0x00, 0},
+	{0x0752, 0x01, 0},
+	{0x0753, 0x03, 0},
+	{0x0400, 0x00, 0},
+	{0x0408, 0x04, 0},
+	{0x040e, 0xe0, 0},
+	{0x0500, 0x02, 0},
+	{0x05e7, 0x00, 0},
+	{0x05e8, 0x00, 0},
+	{0x0f09, 0x18, 0},
+	{0x070c, 0x20, 0},
+	{0x070d, 0x41, 0},//0x49
+	{0x070e, 0x04, 0},//0x37
+	{0x070f, 0x00, 0},
+	{0x0710, 0x00, 0},
+	{0x0711, 0x00, 0},
+	{0x0716, 0xf0, 0},
+	{0x090f, 0x00, 0},
+	{0x0900, 0x01, 1},
+	{0x0900, 0x00, 0},
+	{0x0001, 0xf5, 0},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0x05, 0},
+	{0x0001, 0x05, 1},
+	{0x0000, 0x00, 1}};
+
+
+// 256qam
+static atsc_cfg_t list_qam256[113] = {
+	{0x0900, 0x01, 0},
+	{0x0f04, 0x08, 0},
+	{0x0f06, 0x80, 0},
+	{0x0f00, 0xe0, 0},
+	{0x0f00, 0xec, 0},
+	{0x0001, 0x05, 0},
+	{0x0002, 0x01, 0},  //0x09
+	{0x0003, 0x2c, 0},
+	{0x0004, 0x91, 0},
+	{0x0005, 0x10, 0},
+	{0x0006, 0xc0, 0},
+	{0x0007, 0x5c, 0},
+	{0x0008, 0x0f, 0},
+	{0x0009, 0x4f, 0},
+	{0x000a, 0xfc, 0},
+	{0x000b, 0x0c, 0},
+	{0x000c, 0x6c, 0},
+	{0x000d, 0x3a, 0},
+	{0x000e, 0x10, 0},
+	{0x000f, 0x02, 0},
+	{0x0011, 0x80, 0},
+	{0x0012, 0xf5, 0},   //a5
+	{0x0013, 0x74, 0},
+	{0x0014, 0xb9, 0},
+	{0x0015, 0x1f, 0},
+	{0x0016, 0x80, 0},
+	{0x0017, 0x1f, 0},
+	{0x0018, 0x0f, 0},
+	{0x001e, 0x00, 0},
+	{0x001f, 0x00, 0},
+	{0x0023, 0x03, 0},
+	{0x0025, 0x20, 0},
+	{0x0026, 0xff, 0},
+	{0x0027, 0xff, 0},
+	{0x0028, 0xf8, 0},
+	{0x0200, 0x20, 0},
+	{0x0201, 0x62, 0},
+	{0x0202, 0x23, 0},
+	{0x0204, 0x19, 0},
+	{0x0205, 0x76, 0},
+	{0x0206, 0xd2, 0},
+	{0x0207, 0xff, 0},
+	{0x0208, 0xc0, 0},
+	{0x0209, 0xff, 0},
+	{0x0211, 0xc0, 0},
+	{0x0212, 0xb0, 0},
+	{0x0213, 0x05, 0},
+	{0x0215, 0x08, 0},
+	{0x0222, 0xf0, 0},
+	{0x0223, 0xff, 0},
+	{0x0226, 0x40, 0},
+	{0x0229, 0x23, 0},
+	{0x022a, 0x02, 0},
+	{0x022c, 0x01, 0},
+	{0x022e, 0x01, 0},
+	{0x022f, 0x05, 0},
+	{0x0230, 0x40, 0},
+	{0x0231, 0x01, 0},
+	{0x0400, 0x02, 0},
+	{0x0401, 0x30, 0},
+	{0x0402, 0x13, 0},
+	{0x0406, 0x06, 0},
+	{0x0408, 0x04, 0},
+	{0x040e, 0xe0, 0},
+	{0x0411, 0x02, 0},
+	{0x073a, 0x02, 0},
+	{0x073b, 0x09, 0},
+	{0x073c, 0x0c, 0},
+	{0x073d, 0x08, 0},
+	{0x073e, 0xfd, 0},
+	{0x073f, 0xf2, 0},
+	{0x0740, 0xed, 0},
+	{0x0741, 0xf4, 0},
+	{0x0742, 0x03, 0},
+	{0x0743, 0x15, 0},
+	{0x0744, 0x1d, 0},
+	{0x0745, 0x15, 0},
+	{0x0746, 0xfc, 0},
+	{0x0747, 0xde, 0},
+	{0x0748, 0xcc, 0},
+	{0x0749, 0xd6, 0},
+	{0x074a, 0x04, 0},
+	{0x074b, 0x4f, 0},
+	{0x074c, 0x00, 0},
+	{0x074d, 0xa2, 0},
+	{0x074e, 0x00, 0},
+	{0x074f, 0xe3, 0},
+	{0x0750, 0x00, 0},
+	{0x0751, 0xfc, 0},
+	{0x0752, 0x00, 0},
+	{0x0753, 0x03, 0},
+	{0x0500, 0x02, 0},
+	{0x05e7, 0x00, 0},
+	{0x05e8, 0x00, 0},
+	{0x0f09, 0x18, 0},
+	{0x070c, 0x20, 0},
+	{0x070d, 0x49, 0},
+	{0x070e, 0x37, 0},
+	{0x070f, 0x00, 0},
+	{0x0710, 0x00, 0},
+	{0x0711, 0x00, 0},
+	{0x0716, 0xf0, 0},
+	{0x090f, 0x00, 0},
+	{0x0900, 0x01, 1},
+	{0x0900, 0x00, 0},
+	{0x0001, 0xf5, 0},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0xf5, 1},
+	{0x0001, 0x05, 0},
+	{0x0001, 0x05, 1},
+	{0x0000, 0x00, 1}};
+
+
+#if (defined CONFIG_AM_SI2176)
+#include "../si2176/si2176_func.h"
+extern struct si2176_device_s *si2176_devp;
+extern void si2176_set_frequency(unsigned int freq);
+#elif (defined CONFIG_AM_SI2177)
+#include "../si2177/si2177_func.h"
+extern struct si2177_device_s *si2177_devp;
+extern void si2177_set_frequency(unsigned int freq);
+#endif
+
+#if (defined CONFIG_AM_SI2176)
+extern	int si2176_get_strength(void);
+
+int demod_set_tuner(struct aml_demod_sta *demod_sta,
+		  struct aml_demod_i2c *demod_i2c,
+		  struct aml_tuner_sys *tuner_sys)
+{
+	unsigned int freq;
+	int err_code;
+	freq=tuner_sys->ch_freq;
+	pr_dbg("freq is %d\n",freq);
+	err_code = si2176_init(&si2176_devp->tuner_client,&si2176_devp->si_cmd_reply,&si2176_devp->si_common_reply);
+        err_code = si2176_configure(&si2176_devp->tuner_client,&si2176_devp->si_prop,&si2176_devp->si_cmd_reply,&si2176_devp->si_common_reply);
+        if(err_code)
+        {
+                pr_dbg("[si2176..]%s init si2176 error.\n",__func__);
+                return err_code;
+        }
+		si2176_devp->si_prop.dtv_lif_out.amp = tuner_sys->amp;
+		si2176_devp->si_prop.dtv_lif_freq.offset = tuner_sys->if_freq;
+		si2176_devp->si_prop.dtv_agc_speed.if_agc_speed = tuner_sys->if_agc_speed;
+		si2176_devp->si_prop.dtv_mode.bw = tuner_sys->bandwith&0xf;
+		si2176_devp->si_prop.dtv_mode.modulation = tuner_sys->mode&0xf;
+		si2176_devp->si_prop.dtv_mode.invert_spectrum=SI2176_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL&0x1;
+		pr_dbg("amp is %d,offset is %d,amp+offset is %x,if_agc_speed is %x,mode is %x\n",si2176_devp->si_prop.dtv_lif_out.amp,si2176_devp->si_prop.dtv_lif_out.offset,((si2176_devp->si_prop.dtv_lif_out.offset)+((si2176_devp->si_prop.dtv_lif_out.amp)<<8)),si2176_devp->si_prop.dtv_agc_speed.if_agc_speed,
+						((si2176_devp->si_prop.dtv_mode.bw)+((si2176_devp->si_prop.dtv_mode.modulation)<<4)+((si2176_devp->si_prop.dtv_mode.invert_spectrum)<<8)));
+		if(si2176_set_property(&si2176_devp->tuner_client,0,0x703,((si2176_devp->si_prop.dtv_mode.bw)+((si2176_devp->si_prop.dtv_mode.modulation)<<4)+((si2176_devp->si_prop.dtv_mode.invert_spectrum)<<8)),&si2176_devp->si_cmd_reply))
+					pr_error("[si2176..]%s set dtv_mode error.\n",__func__);
+		if(si2176_set_property(&si2176_devp->tuner_client,0,0x707,(si2176_devp->si_prop.dtv_lif_out.offset)+((si2176_devp->si_prop.dtv_lif_out.amp)<<8),&si2176_devp->si_cmd_reply))
+					pr_error("[si2176..]%s set dtv lif out amp error.\n",__func__);
+		pr_dbg("if is %d\n",si2176_devp->si_prop.dtv_lif_freq.offset);
+		if(si2176_set_property(&si2176_devp->tuner_client,0,0x706,si2176_devp->si_prop.dtv_lif_freq.offset,&si2176_devp->si_cmd_reply))
+					pr_error("[si2176..]%s set dtv lif out if error.\n",__func__);
+
+
+
+		si2176_set_frequency(freq);
+		demod_sta->ch_if=tuner_sys->if_freq;
+		msleep(tuner_sys->delay);
+		tuner_sys->rssi=si2176_get_strength();
+		return 0;
+}
+#elif (defined CONFIG_AM_SI2177)
+int demod_set_tuner(struct aml_demod_sta *demod_sta,
+		  struct aml_demod_i2c *demod_i2c,
+		  struct aml_tuner_sys *tuner_sys)
+{
+	unsigned int freq;
+	int err_code;
+	freq=tuner_sys->ch_freq;
+	pr_dbg("freq is %d\n",freq);
+	err_code = si2177_init(&si2177_devp->tuner_client,&si2177_devp->si_cmd_reply,&si2177_devp->si_common_reply);
+        err_code = si2177_configure(&si2177_devp->tuner_client,&si2177_devp->si_prop,&si2177_devp->si_cmd_reply,&si2177_devp->si_common_reply);
+        if(err_code)
+        {
+                pr_error("[si2176..]%s init si2176 error.\n",__func__);
+                return err_code;
+        }
+		si2177_devp->si_prop.dtv_lif_out.amp = tuner_sys->amp;
+		si2177_devp->si_prop.dtv_lif_freq.offset = tuner_sys->if_freq;
+		pr_dbg("amp is %d,offset is %d,amp+offset is %x\n",si2177_devp->si_prop.dtv_lif_out.amp,si2177_devp->si_prop.dtv_lif_out.offset,((si2177_devp->si_prop.dtv_lif_out.offset)+((si2177_devp->si_prop.dtv_lif_out.amp)<<8)));
+		if(si2177_set_property(&si2177_devp->tuner_client,0,0x707,(si2177_devp->si_prop.dtv_lif_out.offset)+((si2177_devp->si_prop.dtv_lif_out.amp)<<8),&si2177_devp->si_cmd_reply))
+					pr_error("[si2177..]%s set dtv lif out amp error.\n",__func__);
+		pr_dbg("if is %d\n",si2177_devp->si_prop.dtv_lif_freq.offset);
+		if(si2177_set_property(&si2177_devp->tuner_client,0,0x706,si2177_devp->si_prop.dtv_lif_freq.offset,&si2177_devp->si_cmd_reply))
+					pr_error("[si2177..]%s set dtv lif out if error.\n",__func__);
+
+		si2177_set_frequency(freq);
+		demod_sta->ch_if=tuner_sys->if_freq;
+		return 0;
+}
+#else
+
+int demod_set_tuner(struct aml_demod_sta *demod_sta,
+		  struct aml_demod_i2c *demod_i2c,
+		  struct aml_tuner_sys *tuner_sys){
+		return;
+
+}
+
+
+#endif
+
+
+void demod_set_adc_core_clk(int clk_adc, int clk_dem,int dvb_mode)//dvbt dvbc 28571, 66666
+{
+    int unit, error;
+    demod_dig_clk_t dig_clk_cfg;
+    demod_adc_clk_t adc_clk_cfg;
+    int pll_m, pll_n, pll_od, div_dem, div_adc;
+    int freq_osc, freq_vco, freq_out, freq_dem, freq_adc;
+    int freq_dem_act, freq_adc_act, err_tmp, best_err;
+    unit = 10000; // 10000 as 1 MHz, 0.1 kHz resolution.
+    freq_osc = 24*unit;
+    adc_clk_cfg.d32 = 0;
+    dig_clk_cfg.d32 = 0;
+	div_dem=freq_dem_act=freq_adc=err_tmp=freq_dem=0;
+    if (clk_adc > 0) {
+        adc_clk_cfg.b.reset = 0;
+        adc_clk_cfg.b.pll_pd = 0;    // 1  shutdown
+        if (clk_adc < 1000)
+            freq_adc = clk_adc*unit;
+        else
+            freq_adc = clk_adc*unit/1000;
+    }
+    else {
+        adc_clk_cfg.b.pll_pd = 1;
+    }
+
+    if (clk_dem > 0) {
+        dig_clk_cfg.b.demod_clk_en = 1;
+        dig_clk_cfg.b.demod_clk_sel = 3;    //  1  1G
+        if(dvb_mode == M6_Atsc){
+	//		dig_clk_cfg.b.demod_clk_sel = 1;
+		}
+        if (clk_dem < 1000)
+            freq_dem = clk_dem*unit;
+        else
+            freq_dem = clk_dem*unit/1000;
+    }
+    else {
+        dig_clk_cfg.b.demod_clk_en = 0;
+    }
+
+    error = 1;
+    best_err = 100*unit;
+    for (pll_m=1; pll_m<512; pll_m++) {
+        for (pll_n=1; pll_n<=5; pll_n++) {
+            freq_vco = freq_osc * pll_m / pll_n;
+            if (freq_vco<750*unit || freq_vco>1500*unit) continue;
+
+            for (pll_od=0; pll_od<3; pll_od++) {
+                freq_out = freq_vco / (1<<pll_od);
+			//	printk("pll_od is %d\n",pll_od);
+                if (freq_out > 800*unit) continue;
+
+				#ifdef M6D
+                div_dem = freq_vco / freq_dem;
+				#else
+                div_dem = freq_out / freq_dem;
+				#endif
+                if (div_dem==0 || div_dem>127) continue;
+
+                freq_dem_act = freq_out / div_dem;
+                err_tmp = freq_dem_act - freq_dem;
+
+                div_adc = freq_out / freq_adc / 2;
+                div_adc *= 2;
+                if (div_adc==0 || div_adc>31) continue;
+
+                freq_adc_act = freq_out / div_adc;
+                if (freq_adc_act-freq_adc > unit/5) continue;
+
+                if (err_tmp >= best_err) continue;
+
+                adc_clk_cfg.b.pll_m = pll_m;
+                adc_clk_cfg.b.pll_n = pll_n;
+                adc_clk_cfg.b.pll_od = pll_od;
+				#ifdef M6D
+                adc_clk_cfg.b.pll_xd = div_adc;
+                #else
+				adc_clk_cfg.b.pll_xd = div_adc-1;//div_adc-1(m6l);
+				#endif
+                dig_clk_cfg.b.demod_clk_div = div_dem-1;  // 1/75-1
+                #ifdef extadc
+				if(dvb_mode == M6_Atsc){
+					dig_clk_cfg.b.demod_clk_div = 1000000/clk_dem - 1;
+					pr_dbg("[ATSC]use ext dmd clk,dig_clk_cfg.b.demod_clk_div is %x\n ",dig_clk_cfg.b.demod_clk_div);
+				}
+				#endif
+                error = 0;
+                best_err = err_tmp;
+            }
+        }
+    }
+
+    pll_m = adc_clk_cfg.b.pll_m;
+    pll_n = adc_clk_cfg.b.pll_n;
+    pll_od = adc_clk_cfg.b.pll_od;
+	#ifdef M6D
+    div_adc = adc_clk_cfg.b.pll_xd;
+	#else
+	div_adc = adc_clk_cfg.b.pll_xd + 1;
+	#endif
+    div_dem = dig_clk_cfg.b.demod_clk_div + 1;
+
+    if (error) {
+        pr_error(" ERROR DIG %7d kHz  ADC %7d kHz\n",freq_dem/(unit/1000), freq_adc/(unit/1000));
+    }
+    else {
+      /*  printf("dig_clk_cfg %x \n",dig_clk_cfg.d32);
+        printf("adc_clk_cfg %x \n",adc_clk_cfg.d32);
+        printf("Whether write configure to IC?");
+        scanf("%d", &tmp);
+        if (tmp == 1)
+        {
+        reg.addr = 0xf11041d0; reg.val = dig_clk_cfg.d32;ioctl(fd, AML_DEMOD_SET_REG, &reg);
+        reg.addr = 0xf11042a8; reg.val = adc_clk_cfg.d32;ioctl(fd, AML_DEMOD_SET_REG, &reg);
+        }*/
+
+	  /*adc_extclk_sel
+	  0: crystal
+	  1: fclk_div2 = 1GHz
+	  2: fclk_div3 = 666M
+	  3: fclk_div5 = 400M
+	  4: fclk_div7 = 285M
+	  5:mp2_clk_out    freq?
+	  6: no----------
+	  7: no------------
+
+	  */
+	  #ifdef extadc
+	 //shutdown demodclk to save power
+	//	dig_clk_cfg.b.demod_clk_sel = 1;  // 1GHZ
+	//	adc_clk_cfg.b.pll_pd = 1;		  //shutdown adc_pll
+	//	dig_clk_cfg.b.demod_clk_div = (1000000/clk_dem)-1;// 1GHZ/70M -1
+	//	printk("demod_clk_sel is %d,pll_pd is %d, demod_clk_div is %d\n",dig_clk_cfg.b.demod_clk_sel,adc_clk_cfg.b.pll_pd,dig_clk_cfg.b.demod_clk_div);
+	  //enable extclk
+		dig_clk_cfg.b.adc_extclk_div=(1000000/clk_adc)-1;//27;     1GHZ/35M-1
+	    dig_clk_cfg.b.adc_extclk_en=1;					//enable
+	    dig_clk_cfg.b.adc_extclk_sel=1;
+        dig_clk_cfg.b.use_adc_extclk=1;
+		pr_dbg("adc_extclk_en is %d,adc_extclk_div is %d,clk_adc is %d\n",dig_clk_cfg.b.adc_extclk_en,dig_clk_cfg.b.adc_extclk_div,clk_adc);
+
+	#endif
+		demod_set_cbus_reg(dig_clk_cfg.d32, ADC_REG6);
+		demod_set_cbus_reg(adc_clk_cfg.d32, ADC_REG1);
+        pr_dbg("dig_clk_cfg.d32 is %x,adc_clk_cfg.d32 is %x\n",dig_clk_cfg.d32,adc_clk_cfg.d32);
+        freq_vco = freq_osc * pll_m / pll_n;
+        freq_out = freq_vco / (1<<pll_od);
+        freq_dem_act = freq_vco / div_dem;
+        freq_adc_act = freq_out / div_adc;
+
+        pr_dbg(" ADC PLL  M %3d   N %3d\n", pll_m, pll_n);
+        pr_dbg(" ADC PLL OD %3d  XD %3d\n", pll_od, div_adc);
+        pr_dbg(" DIG SRC SEL %2d  DIV %2d\n", 3, div_dem);
+        pr_dbg(" DIG %7d kHz %7d kHz\n", freq_dem/(unit/1000), freq_dem_act/(unit/1000));
+        pr_dbg(" ADC %7d kHz %7d kHz\n", freq_adc/(unit/1000), freq_adc_act/(unit/1000));
+    }
+}
+
+void demod_set_cbus_reg(int data, int addr)
+{
+//	__raw_writel(data,CBUS_REG_ADDR(addr));
+	addr=CBUS_REG_ADDR(addr);
+	*(volatile unsigned long*)addr = data;
+
+}
+
+unsigned long demod_read_cbus_reg(int addr)
+{
+//	return __raw_readl(CBUS_REG_ADDR(addr));
+	unsigned long tmp;
+	addr = CBUS_REG_ADDR(addr);
+    tmp = *(volatile unsigned long*)addr;
+    return tmp;
+
+}
+
+
+void demod_set_demod_reg(unsigned long data, unsigned long addr)
+{
+//	__raw_writel(data,(DEMOD_BASE+addr));
+	addr=DEMOD_BASE+addr;
+	*(volatile unsigned long*)addr = data;
+}
+
+unsigned long demod_read_demod_reg(unsigned long addr)
+{
+//	return __raw_readl(DEMOD_BASE+addr);
+	unsigned long tmp;
+	addr = DEMOD_BASE+addr;
+    tmp = *(volatile unsigned long*)addr;
+    return tmp;
+}
+
+
+
+void clocks_set_sys_defaults(unsigned char dvb_mode)
+{
+	demod_cfg0_t cfg0;
+	demod_set_cbus_reg(ADC_REG1_VALUE,ADC_REG1);
+	demod_set_cbus_reg(ADC_REG2_VALUE,ADC_REG2);
+	demod_set_cbus_reg(ADC_REG3_VALUE,ADC_REG3);
+	demod_set_cbus_reg(ADC_REG4_VALUE,ADC_REG4);
+	demod_set_cbus_reg(ADC_REG5_VALUE,ADC_REG5);
+	demod_set_cbus_reg(ADC_REG6_VALUE,ADC_REG6);
+
+	demod_set_demod_reg(DEMOD_REG1_VALUE,DEMOD_REG1);
+	demod_set_demod_reg(DEMOD_REG2_VALUE,DEMOD_REG2);
+	demod_set_demod_reg(DEMOD_REG3_VALUE,DEMOD_REG3);
+	cfg0.b.mode=7;
+	cfg0.b.adc_format=1;
+	if(dvb_mode==M6_Dvbc)    //// 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC
+	{
+		cfg0.b.ts_sel=2;
+	}else if((dvb_mode==M6_Dvbt_Isdbt)||(dvb_mode==M6_Dtmb)){
+		cfg0.b.ts_sel=1;
+		cfg0.b.adc_regout=1;
+	}else if(dvb_mode==M6_Atsc){
+		cfg0.b.ts_sel=4;
+	}
+	demod_set_demod_reg(cfg0.d32,DEMOD_REG1);
+	pr_dbg("0xc8020c00 is %lx,dvb_mode is %d\n",demod_read_demod_reg(0xc00),dvb_mode);
+
+}
+
+void dtmb_write_reg(int reg_addr, int reg_data)
+{
+	apb_write_reg(DTMB_BASE+(reg_addr<<2),reg_data);
+}
+
+long dtmb_read_reg(int reg_addr)
+{
+    return apb_read_reg(DTMB_BASE+(reg_addr<<2));
+}
+
+
+
+
+void atsc_write_reg(int reg_addr, int reg_data)
+{
+    apb_write_reg(ATSC_BASE, (reg_addr&0xffff)<<8 | (reg_data&0xff));
+}
+
+unsigned long atsc_read_reg(int reg_addr)
+{
+    unsigned long tmp;
+
+    apb_write_reg(ATSC_BASE+4, (reg_addr&0xffff)<<8);
+    tmp = apb_read_reg(ATSC_BASE);
+
+    return tmp&0xff;
+}
+
+unsigned long atsc_read_iqr_reg(void)
+{
+    unsigned long tmp;
+
+    tmp = apb_read_reg(ATSC_BASE+8);
+	pr_dbg("[atsc irq] is %lx\n",tmp);
+    return tmp&0xffffffff;
+}
+
+
+int atsc_qam_set(fe_modulation_t mode){
+	int i,j;
+	if(mode==VSB_8)		//5-8vsb, 2-64qam, 4-256qam
+	{
+
+	    for (i=0; list_8vsb[i].adr != 0; i++) {
+	        if (list_8vsb[i].rw){
+	            atsc_read_reg(list_8vsb[i].adr);
+			//	msleep(2);
+	        }
+	        else{
+	            atsc_write_reg(list_8vsb[i].adr, list_8vsb[i].dat);
+			//	msleep(2);
+	        }
+	    }
+		j=15589;
+		pr_dbg("8-vsb mode\n");
+	}else if(mode==QAM_64){
+
+	    for (i=0; list_qam64[i].adr != 0; i++) {
+	        if (list_qam64[i].rw){
+	            atsc_read_reg(list_qam64[i].adr);
+				msleep(2);
+	        }else{
+	            atsc_write_reg(list_qam64[i].adr, list_qam64[i].dat);
+				msleep(2);
+	        }
+	    }
+		j=16588;//33177;
+		pr_dbg("64qam mode\n");
+	}else if(mode==QAM_256){
+
+	    for (i=0; list_qam256[i].adr != 0; i++) {
+	        if (list_qam256[i].rw){
+	            atsc_read_reg(list_qam256[i].adr);
+				msleep(2);
+	        }else{
+	            atsc_write_reg(list_qam256[i].adr, list_qam256[i].dat);
+				msleep(2);
+	        }
+	    }
+		j=15649;//31298;
+		pr_dbg("256qam mode\n");
+	}else{
+		for (i=0; list_qam256[i].adr != 0; i++) {
+	        if (list_qam256[i].rw){
+	            atsc_read_reg(list_qam256[i].adr);
+				msleep(2);
+	        }else{
+	            atsc_write_reg(list_qam256[i].adr, list_qam256[i].dat);
+				msleep(2);
+	        }
+	    }
+		j=15649;//31298;
+		pr_dbg("256qam mode\n");
+
+	}
+	return j;
+
+}
+
+void atsc_initial(struct aml_demod_sta *demod_sta)
+{
+    int fc,fs,cr,ck, j;
+	fe_modulation_t mode;
+	mode=demod_sta->ch_mode;
+
+	j=atsc_qam_set(mode);//set mode
+
+	fs = demod_sta->adc_freq;//KHZ 25200
+	fc = demod_sta->ch_if;//KHZ 6350
+
+	cr = (fc*(1<<17)/fs)*(1<<6) ;
+	ck = fs*j/10-(1<<25);  //  ck_rate = (f_samp / f_vsb /2 -1)*(1<<25);  	  double f_vsb = 10.76238;// double f_64q = 5.056941;// double f_256q = 5.360537;
+
+
+	atsc_write_reg(0x070e,cr&0xff);
+	atsc_write_reg(0x070d,(cr>>8)&0xff);
+	atsc_write_reg(0x070c,(cr>>16)&0xff);
+
+	if(demod_sta->ch_mode==VSB_8){
+		atsc_write_reg(0x0711,ck&0xff);
+		atsc_write_reg(0x0710,(ck>>8)&0xff);
+		atsc_write_reg(0x070f,(ck>>16)&0xff);
+	}
+	pr_dbg("0x70e is %x, 0x70d is %x, 0x70c is %x\n",cr&0xff,(cr>>8)&0xff,(cr>>16)&0xff);
+	pr_dbg("fs is %d(SR),fc is %d(IF),cr is %x,ck is %x\n",fs,fc,cr,ck);
+}
+
+
+
+int atsc_set_ch(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c,
+			struct aml_demod_atsc *demod_atsc)
+{
+	int ret = 0;
+	u8 demod_mode;
+	u8 bw, sr, ifreq, agc_mode;
+	u32 ch_freq;
+	bw		 = demod_atsc->bw;
+	sr		 = demod_atsc->sr;
+	ifreq	 = demod_atsc->ifreq;
+	agc_mode = demod_atsc->agc_mode;
+	ch_freq  = demod_atsc->ch_freq;
+	demod_mode = demod_atsc->dat0;
+	demod_sta->ch_mode	 = demod_atsc->mode; // TODO
+	demod_sta->agc_mode  = agc_mode;
+	demod_sta->ch_freq	 = ch_freq;
+	demod_sta->dvb_mode  = demod_mode;
+	demod_sta->ch_bw	 = (8-bw)*1000;
+  	atsc_initial(demod_sta);
+	pr_dbg("ATSC mode\n");
+	return ret;
+}
+#if 0
+static dtmb_cfg_t list_dtmb_v1[99] = {
+	{0x00000000, 0x01, 0},
+	{0x00001000, 0x02, 0},
+	{0x00000000, 0x03, 0},
+	{0x00000000, 0x04, 0},
+	{0x00000000, 0x05, 0},
+	{0x00000000, 0x06, 0},
+	{0x007fffff, 0x07, 0},
+	{0x0000000f, 0x08, 0},
+	{0x00003000, 0x09, 0},
+	{0x00000001, 0x0a, 0},
+	{0x0c403006, 0x0b, 0},
+	{0x44444400, 0x0c, 0},
+	{0x1412c320, 0x0d, 0},
+	{0x00000152, 0x10, 0},
+	{0x47080137, 0x11, 0},
+	{0x02200a16, 0x12, 0},
+	{0x42190190, 0x13, 0},
+	{0x7f807f80, 0x14, 0},
+	{0x0000199a, 0x15, 0},
+	{0x000a1466, 0x18, 0},
+	{0x00274217, 0x1a, 0},
+	{0x00131036, 0x1b, 1},
+	{0x00000396, 0x1c, 0},
+	{0x0037f3cc, 0x1d, 0},
+	{0x00000029, 0x1e, 0},
+	{0x0004f031, 0x1f, 0},
+	{0x00f3cbd4, 0x20, 0},
+	{0x0000007e, 0x21, 0},
+	{0x23270b6a, 0x22, 0},
+	{0x5f700c1b, 0x23, 0},
+	{0x00133c2b, 0x24, 0},
+	{0x2d3e0f12, 0x25, 0},
+	{0x06363038, 0x26, 0},
+	{0x060e0a3e, 0x27, 0},
+	{0x0015161f, 0x28, 0},
+	{0x0809031b, 0x29, 0},
+	{0x181c0307, 0x2a, 0},
+	{0x051f1a1b, 0x2b, 0},
+	{0x00451dce, 0x2c, 0},
+	{0x242fde12, 0x2d, 0},
+	{0x0034e8fa, 0x2e, 0},
+	{0x00000007, 0x30, 0},
+	{0x16000d0c, 0x31, 0},
+	{0x0000011f, 0x32, 0},
+	{0x01000200, 0x33, 0},
+	{0x10bbf376, 0x34, 0},
+	{0x00000044, 0x35, 0},
+	{0x00000000, 0x36, 0},
+	{0x00000000, 0x37, 0},
+	{0x00000000, 0x38, 0},
+	{0x00000000, 0x39, 0},
+	{0x00000031, 0x3a, 0},
+	{0x4d6b0a58, 0x3b, 0},
+	{0x00000c04, 0x3c, 0},
+	{0x0d3b0a50, 0x3d, 0},
+	{0x03140480, 0x3e, 0},
+	{0x05e60452, 0x3f, 0},
+	{0x05780400, 0x40, 0},
+	{0x0063c025, 0x41, 0},
+	{0x05050202, 0x42, 0},
+	{0x5e4a0a14, 0x43, 0},
+	{0x00003b42, 0x44, 0},
+	{0xa53080ff, 0x45, 0},
+	{0x00000000, 0x46, 0},
+	{0x00133202, 0x47, 0},
+	{0x01f00000, 0x48, 0},
+	{0x00000000, 0x49, 0},
+	{0x00000000, 0x4a, 0},
+	{0x00000000, 0x4b, 0},
+	{0x00000000, 0x4c, 0},
+	{0x20405dc8, 0x4d, 0},
+	{0x00000000, 0x4e, 0},
+	{0x1f0205df, 0x4f, 0},
+	{0x00001120, 0x50, 0},
+	{0x4f190803, 0x51, 0},
+	{0x00000000, 0x52, 0},
+	{0x00000040, 0x53, 0},
+	{0x00100050, 0x54, 0},
+	{0x00cd1000, 0x55, 0},
+	{0x00010fab, 0x56, 0},
+	{0x03f0fc3f, 0x58, 0},
+	{0x02005014, 0x59, 0},
+	{0x01405014, 0x5a, 0},
+	{0x00014284, 0x5b, 0},
+	{0x00000320, 0x5c, 0},
+	{0x14130e05, 0x5d, 0},
+	{0x4321c963, 0x5f, 0},
+	{0x624668f8, 0x60, 0},
+	{0xccc08888, 0x61, 0},
+	{0x13212111, 0x62, 0},
+	{0x21100000, 0x63, 0},
+	{0x624668f8, 0x64, 0},
+	{0xccc08888, 0x65, 0},
+	{0x13212111, 0x66, 0},
+	{0x21100000, 0x67, 0},
+	{0x624668f8, 0x68, 0},
+	{0xccc08888, 0x69, 0},
+	{0x0, 0x0, 0}
+};
+#endif
+
+extern int memstart;
+
+void dtmb_initial(struct aml_demod_sta *demod_sta)
+{
+
+	pr_dbg("[dtmb]mem_buf is 0x%x\n",memstart);
+	dtmb_write_reg(0x049, memstart);
+	dtmb_write_reg(0x010, 0x52);
+	dtmb_write_reg(0x047, 0x33202);  //20 bits, 1 - fpga. 0 - m6tvd
+	dtmb_write_reg(0xd, 0x141a0320); // increase interleaver0 waiting time.
+    dtmb_write_reg(0xc, 0x41444400); // shorten che waiting time.
+#if 0
+	int i;
+	  for (i=0; list_dtmb_v1[i].adr != 0; i++) {
+	        if (list_dtmb_v1[i].rw){
+	            apb_read_reg(DTMB_BASE+((list_dtmb_v1[i].adr)<<2));
+			//	msleep(2);
+	        }
+	        else{
+	            apb_write_reg(DTMB_BASE+((list_dtmb_v1[i].adr)<<2), list_dtmb_v1[i].dat);
+			//	msleep(2);
+	        }
+	    }
+#endif
+
+
+}
+
+int dtmb_read_snr(void){
+	int tmp,che_snr,snr,snr_avg,fec_lock,reg_46;
+	int fsm_state,fec_ldpc_it_avg,local_state,fbe_in_num,SC_mode,time_eq;
+	int time_cnt=0,fec_bch_add;
+	int ddc_phase,icfo_phase,fcfo_phase,ddc_phase_new,reg_6b;
+	int mobi_det_power;
+    int mobile_times;
+    int ctrl_che_working_state;
+	mobile_times = 0;
+
+	tmp=dtmb_read_reg(0x0e3);
+	fec_ldpc_it_avg = dtmb_read_reg(0xdd) & 0xffff;
+	fec_bch_add = dtmb_read_reg(0xdf);
+	fec_lock = (tmp >> 12) & 0x1;
+	che_snr = tmp & 0xfff;
+    if(che_snr >= 2048)
+        che_snr = che_snr - 4096;
+	snr = che_snr/32;
+    snr_avg = (tmp >> 13) & 0xfff;
+    if(snr_avg >= 2048)
+        snr_avg = snr_avg - 4096;
+    snr_avg = snr_avg / 32;
+	pr_dbg("[dtmb] snr is %d,snr_avg is %d,fec_lock is %d,fec_bch_add is %d,fec_ldpc_it_avg is %d\n",snr,snr_avg,fec_lock,fec_bch_add,fec_ldpc_it_avg/256);
+	ctrl_che_working_state = (dtmb_read_reg(0xf1) >> 28) & 0x3;
+    if(((snr_avg < 1  && ctrl_che_working_state == 0) || (snr < 1  && ctrl_che_working_state == 1)) && fec_lock) { // false lock, reset
+//	if((snr_avg<=0)&&(fec_lock==1)){
+		printk("reset dtmb\n");
+		dtmb_reset();
+		return 0;
+	}else{
+		 if(fec_lock && fec_ldpc_it_avg < (3 * 256)){
+			 pr_dbg("-----------  lock ! ------------ \n");
+			 return 1;
+		 }else{
+			fsm_state = dtmb_read_reg(0xd7) & 0xf;
+            local_state = 2;
+			 while(fsm_state < 8 && time_cnt < 10) {// state change to pm
+                msleep(50);
+                fsm_state = dtmb_read_reg(0xd7) & 0xf;
+                time_cnt++;
+                local_state = 3;
+                pr_dbg("*************** local_state = %d ************ \n", local_state);
+            }
+
+			 if(fsm_state >= 8) { // check whether SC and two path mode
+		     	  fbe_in_num = (dtmb_read_reg(0xe4) >> 16) & 0x3ff;  // two path distance
+		     	  SC_mode = (dtmb_read_reg(0xe6) >> 24) & 0x1;
+		     	  time_eq = (dtmb_read_reg(0x46) >> 16) & 0x1;
+		     	  fec_ldpc_it_avg = dtmb_read_reg(0xdd) & 0xffff;
+
+			  	  mobi_det_power = (dtmb_read_reg(0xf1)>>8) & 0x7ffff;
+
+             	  if(mobi_det_power > 10) {
+             	      mobile_times = 8;
+             	      dtmb_write_reg(0x46, (dtmb_read_reg(0x46) & 0xfffffff9) + (1 << 1)); // set mobile mode
+             	  }
+             	  else {
+             	      mobile_times -= 1;
+             	      if(mobile_times <= 0) {
+             	          dtmb_write_reg(0x46, (dtmb_read_reg(0x46) & 0xfffffff9)); // set static mode
+             	          mobile_times = 0;
+             	      }
+             	  }
+
+		     	  local_state = 4;
+		     	  pr_dbg("*************** local_state = %d ************ \n", local_state);
+		     	  if(mobile_times > 0)
+                         pr_dbg("***************  mobile state ************ \n");
+		     	  if(time_eq){  // in time_eq mode
+		     	      local_state = 5;
+		     	      pr_dbg("*************** local_state = %d ************ \n", local_state);
+
+		     	      if(SC_mode == 1 || fbe_in_num < 30){ // MC mode or not two path mode, restore normal mode
+		     	          dtmb_write_reg(0x2e, 0x131a747d);  // cancel timing-loop
+		     	          dtmb_write_reg(0xd, 0x141a0320); // increase interleaver0 waiting time.
+		     	          reg_46 = dtmb_read_reg(0x46);
+		                reg_46 = reg_46 &~ ((1<<20) + (1<<16));           // bypass fe and set time_eq
+		                dtmb_write_reg(0x46, reg_46);
+		                pr_dbg(" ------------ normal mode -------------\n");
+		                local_state = 6;
+		                pr_dbg("*************** local_state = %d ************ \n", local_state);
+
+		     	      }
+		        }
+		        else {
+		            local_state = 7;
+		            pr_dbg("*************** local_state = %d ************ \n", local_state);
+
+		            if(SC_mode == 0 && fbe_in_num > 30 && fec_ldpc_it_avg > 640/*2.5*256*/) { // switch to time_eq mode
+		                ddc_phase  = dtmb_read_reg(0x15) & 0xffffff;
+		                icfo_phase = dtmb_read_reg(0xe0) & 0xfffff;
+		                fcfo_phase = dtmb_read_reg(0xe1) & 0xfffff;
+
+		                if(icfo_phase > (1<<19))
+		                    icfo_phase -= (1<<20);
+		                if(fcfo_phase > (1<<19))
+		                    fcfo_phase -= (1<<20);
+		                ddc_phase_new = ddc_phase + icfo_phase*4 + fcfo_phase;
+		                //printf("before is DDC_phase %x, now is %x \n", ddc_phase, ddc_phase_new);
+		                dtmb_write_reg(0x15, ddc_phase_new);
+
+		                //printf("switch to time_eq configure : 0 -- No, 1 -- yes");
+		                //scanf("%d", &tmp);
+		                tmp = 1;
+		                if(tmp == 1) {
+		                    dtmb_write_reg(0x2e, 0x31a747d);  // start timing-loop
+		                    dtmb_write_reg(0x0d, 0x14400640);  // delay fec sync time
+		                    reg_46 = dtmb_read_reg(0x46);
+		                    reg_46 = reg_46 | ((1<<20) + (1<<16));           // bypass fe and set time_eq
+		                    dtmb_write_reg(0x46, reg_46);
+
+		                    reg_6b = dtmb_read_reg(0x6b);
+		                    reg_6b = (reg_6b &~(0x3<<16)) | (1<<17);           // set tune auto
+		                    dtmb_write_reg(0x6b, reg_6b);
+		                }
+		                pr_dbg(" ------------ time_eq mode -------------\n");
+		                local_state = 8;
+		                pr_dbg("*************** local_state = %d ************ \n", local_state);
+		                dtmb_reset();
+	                        }
+	                    }
+	                }else if(time_cnt >=10) // don't sync, all reset
+                        {
+                            local_state = 9;
+                            pr_dbg("*************** local_state = %d ************ \n", local_state);
+
+                            dtmb_register_reset();
+                            dtmb_write_reg(0x49,memstart); //set memory
+                            dtmb_write_reg(0x10,0x52); //set memory
+                            dtmb_write_reg(0xd, 0x141a0320); // increase interleaver0 waiting time.
+                            dtmb_write_reg(0xc, 0x41444400); // shorten che waiting time.
+                            dtmb_write_reg(0x47,0x33202);
+							dtmb_write_reg(0x18,0x000a1316); // shorten mobile detect time.
+                        }
+
+		 }
+
+	}
+
+	return 0;
+
+}
+
+
+
+void dtmb_reset(void)
+{
+	dtmb_write_reg(0x01, dtmb_read_reg(0x01) | (0x3 << 0));
+	dtmb_write_reg(0x01, dtmb_read_reg(0x01) &~ (0x3 << 0));
+}
+
+void dtmb_register_reset()
+{
+    dtmb_write_reg(0x01, dtmb_read_reg(0x01) | (1 << 0));
+    dtmb_write_reg(0x01, dtmb_read_reg(0x01) &~ (1 << 0));
+}
+
+
+
+
+int dtmb_set_ch(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c,
+			struct aml_demod_dtmb *demod_dtmb)
+{
+	int ret = 0;
+	u8 demod_mode;
+	u8 bw, sr, ifreq, agc_mode;
+	u32 ch_freq;
+	bw		 = demod_dtmb->bw;
+	sr		 = demod_dtmb->sr;
+	ifreq	 = demod_dtmb->ifreq;
+	agc_mode = demod_dtmb->agc_mode;
+	ch_freq  = demod_dtmb->ch_freq;
+	demod_mode = demod_dtmb->dat0;
+	demod_sta->ch_mode	 = demod_dtmb->mode; // TODO
+	demod_sta->agc_mode  = agc_mode;
+	demod_sta->ch_freq	 = ch_freq;
+	demod_sta->dvb_mode  = demod_mode;
+	demod_sta->ch_bw	 = (8-bw)*1000;
+  	dtmb_initial(demod_sta);
+	pr_dbg("DTMB mode\n");
+	return ret;
+}
+
+
+
+/*int dvbc_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbc *demod_dvbc)
+{
+    int ret = 0;
+    u16 symb_rate;
+    u8  mode;
+    u32 ch_freq;
+
+   printk("f=%d, s=%d, q=%d\n", demod_dvbc->ch_freq, demod_dvbc->symb_rate, demod_dvbc->mode);
+
+    mode      = demod_dvbc->mode;
+    symb_rate = demod_dvbc->symb_rate;
+    ch_freq   = demod_dvbc->ch_freq;
+	demod_i2c->tuner=7;
+    if (mode > 4) {
+	printk("Error: Invalid QAM mode option %d\n", mode);
+	mode = 2;
+       	ret = -1;
+    }
+
+    if (symb_rate<1000 || symb_rate>7000) {
+	printk("Error: Invalid Symbol Rate option %d\n", symb_rate);
+	symb_rate = 6875;
+	ret = -1;
+    }
+
+    if (ch_freq<1000 || ch_freq>900000) {
+	printk("Error: Invalid Channel Freq option %d\n", ch_freq);
+	ch_freq = 474000;
+	ret = -1;
+    }
+
+    // if (ret != 0) return ret;
+
+    // Set DVB-C
+  //  (*DEMOD_REG0) &= ~1;
+
+    demod_sta->dvb_mode  = 0;    // 0:dvb-c, 1:dvb-t
+    demod_sta->ch_mode   = mode; // 0:16, 1:32, 2:64, 3:128, 4:256
+    demod_sta->agc_mode  = 1;    // 0:NULL, 1:IF, 2:RF, 3:both
+    demod_sta->ch_freq   = ch_freq;
+    demod_sta->tuner     = demod_i2c->tuner;
+
+    if(demod_i2c->tuner == 1)
+        demod_sta->ch_if     = 36130; // TODO  DCT tuner
+    else if (demod_i2c->tuner == 2)
+        demod_sta->ch_if     = 4570; // TODO  Maxlinear tuner
+    else if (demod_i2c->tuner == 7)
+        demod_sta->ch_if     = 5000; // TODO  Si2176 tuner
+
+    demod_sta->ch_bw     = 8000;  // TODO
+    demod_sta->symb_rate = symb_rate;
+
+    // Set Tuner
+    tuner_set_ch(demod_sta, demod_i2c);
+
+ //   mdelay((demod_sta->ch_freq % 10) * 1000);
+	qam_initial(mode);
+  //  dvbc_reg_initial(demod_sta);
+
+    return ret;
+}  */
+
+
+
+int dvbt_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbt *demod_dvbt)
+{
+    int ret = 0;
+    u8_t demod_mode = 1;
+    u8_t bw, sr, ifreq, agc_mode;
+    u32_t ch_freq;
+
+    bw       = demod_dvbt->bw;
+    sr       = demod_dvbt->sr;
+    ifreq    = demod_dvbt->ifreq;
+    agc_mode = demod_dvbt->agc_mode;
+    ch_freq  = demod_dvbt->ch_freq;
+    demod_mode = demod_dvbt->dat0;
+    if (ch_freq<1000 || ch_freq>900000000) {
+	//printk("Error: Invalid Channel Freq option %d\n", ch_freq);
+	ch_freq = 474000;
+	ret = -1;
+    }
+
+    if (demod_mode<0||demod_mode>4) {
+    	//printk("Error: Invalid demod mode option %d\n", demod_mode);
+    	//printk("Note: 0 is QAM, 1 is DVBT , 2 is ISDBT, 3 is DTMB, 4 is ATSC\n");
+    	demod_mode = 1;
+    	ret = -1;
+    }
+
+    //demod_sta->dvb_mode  = 1;
+    demod_sta->ch_mode   = 0; // TODO
+    demod_sta->agc_mode  = agc_mode;
+    demod_sta->ch_freq   = ch_freq;
+    demod_sta->dvb_mode  = demod_mode;
+ /*   if (demod_i2c->tuner == 1)
+	demod_sta->ch_if = 36130;
+    else if (demod_i2c->tuner == 2)
+	demod_sta->ch_if = 4570;
+    else if (demod_i2c->tuner == 3)
+	demod_sta->ch_if = 4000;// It is nouse.(alan)
+    else if (demod_i2c->tuner == 7)
+	demod_sta->ch_if = 5000;//silab 5000kHz IF*/
+
+
+    demod_sta->ch_bw     = (8-bw)*1000;
+    demod_sta->symb_rate = 0; // TODO
+
+//	bw=0;
+    demod_mode=1;
+    //for si2176 IF:5M   sr 28.57
+    sr=4;ifreq=4;
+	if(bw==BANDWIDTH_AUTO){
+		demod_mode=2;
+	}
+    ofdm_initial(
+  		  bw            ,// 00:8M 01:7M 10:6M 11:5M
+     		sr            ,// 00:45M 01:20.8333M 10:20.7M 11:28.57  100:24m
+     		ifreq         ,// 000:36.13M 001:-5.5M 010:4.57M 011:4M 100:5M
+     		demod_mode-1    ,// 00:DVBT,01:ISDBT
+     		1        // 0: Unsigned, 1:TC
+    	) ;
+    pr_dbg("DVBT/ISDBT mode\n");
+
+
+    return ret;
+}
+
+extern int clk_measure(char index);
+int demod_set_sys(struct aml_demod_sta *demod_sta,
+		  struct aml_demod_i2c *demod_i2c,
+		  struct aml_demod_sys *demod_sys)
+{
+	int adc_clk;
+//	demod_sta->tmp=Adc_mode;
+    unsigned char dvb_mode;
+    int clk_adc,clk_dem;
+    dvb_mode=demod_sta->dvb_mode;
+    clk_adc=demod_sys->adc_clk;
+	clk_dem=demod_sys->demod_clk;
+	pr_dbg("demod_set_sys,clk_adc is %d,clk_demod is %d,demod_sta.tmp is %d\n",clk_adc,clk_dem,demod_sta->tmp);
+    clocks_set_sys_defaults(dvb_mode);
+	if(demod_sta->tmp==Adc_mode){
+		demod_set_cbus_reg(ADC_REG4_VALUE,ADC_REG4);
+		pr_dbg("Adc_mode\n");
+	}
+	else{
+		demod_set_cbus_reg(ADC_REG4_CRY_VALUE,ADC_REG4);
+		pr_dbg("Cry_mode\n");
+	}
+    demod_set_adc_core_clk(clk_adc, clk_dem,dvb_mode);
+	demod_sta->adc_freq=clk_adc;
+	demod_sta->clk_freq=clk_dem;
+	adc_clk=clk_measure(17);
+	adc_clk=clk_measure(56);
+
+    return 0;
+}
+
+void demod_set_reg(struct aml_demod_reg *demod_reg)
+{
+	 if(demod_reg->mode==0){
+		demod_reg->addr=demod_reg->addr+QAM_BASE;
+	}else if((demod_reg->mode==1)||((demod_reg->mode==2))){
+		demod_reg->addr=demod_reg->addr*4+DVBT_BASE;
+	}else if(demod_reg->mode==3){
+	//	demod_reg->addr=ATSC_BASE;
+	}
+	else if(demod_reg->mode==4){
+		demod_reg->addr=demod_reg->addr*4+DEMOD_CFG_BASE;
+	}else if(demod_reg->mode==5){
+		demod_reg->addr=demod_reg->addr+DEMOD_BASE;
+	//	printk("DEMOD_BASE    	0xf1100000+addr*4 \n ISDBT_BASE 	  	0xf1100000+addr*4\n QAM_BASE	  	0xf1100400+addr\n DEMOD_CFG_BASE	0xf1100c00+addr\n");
+	}else if(demod_reg->mode==7){
+
+
+	}
+	if(demod_reg->mode==3)
+		atsc_write_reg(demod_reg->addr, demod_reg->val);
+	//	apb_write_reg(demod_reg->addr, (demod_reg->val&0xffff)<<8 | (demod_reg->val&0xff));
+	else
+   		apb_write_reg(demod_reg->addr, demod_reg->val);
+}
+
+
+void demod_get_reg(struct aml_demod_reg *demod_reg)
+{
+    if(demod_reg->mode==0){
+		demod_reg->addr=demod_reg->addr+QAM_BASE;
+	}else if((demod_reg->mode==1)||(demod_reg->mode==2)){
+		demod_reg->addr=demod_reg->addr*4+DVBT_BASE;
+	}else if(demod_reg->mode==3){
+	//	demod_reg->addr=demod_reg->addr+ATSC_BASE;
+	}else if(demod_reg->mode==4){
+		demod_reg->addr=demod_reg->addr*4+DEMOD_CFG_BASE;
+	}else if(demod_reg->mode==5){
+		demod_reg->addr=demod_reg->addr+DEMOD_BASE;
+	//	printk("DEMOD_BASE    	0xf1100000+addr*4 \n ISDBT_BASE 	  	0xf1100000+addr*4\n QAM_BASE	  	0xf1100400+addr\n DEMOD_CFG_BASE	0xf1100c00+addr\n");
+	}else if(demod_reg->mode==7){
+
+
+	}
+
+	if(demod_reg->mode==3){
+		demod_reg->val=atsc_read_reg(demod_reg->addr);
+	//	apb_write_reg(ATSC_BASE+4, (demod_reg->addr&0xffff)<<8);
+	//	demod_reg->val = apb_read_reg(ATSC_BASE)&0xff;
+	}else if(demod_reg->mode==6){
+		demod_reg->val=atsc_read_iqr_reg();
+	//	apb_write_reg(ATSC_BASE+4, (demod_reg->addr&0xffff)<<8);
+	//	demod_reg->val = apb_read_reg(ATSC_BASE)&0xff;
+	}
+	else
+   		demod_reg->val = apb_read_reg(demod_reg->addr);
+}
+
+
+void demod_reset()
+{
+    Wr(RESET0_REGISTER, (1<<8));
+}
+
+void demod_set_irq_mask()
+{
+ (*(volatile unsigned long *)(P_SYS_CPU_0_IRQ_IN4_INTR_MASK)) |= (1 << 8);
+}
+
+void demod_clr_irq_stat()
+{
+   (*(volatile unsigned long *)(P_SYS_CPU_0_IRQ_IN4_INTR_STAT)) |= (1 << 8);
+}
+
+void demod_set_adc_core_clk_quick(int clk_adc_cfg, int clk_dem_cfg)
+{
+ /*   volatile unsigned long *demod_dig_clk = P_HHI_DEMOD_CLK_CNTL;
+    volatile unsigned long *demod_adc_clk = P_HHI_ADC_PLL_CNTL;
+    int unit;
+    demod_dig_clk_t dig_clk_cfg;
+    demod_adc_clk_t adc_clk_cfg;
+    int pll_m, pll_n, pll_od, div_dem, div_adc;
+    int freq_osc, freq_vco, freq_out, freq_dem_act, freq_adc_act;
+
+    unit = 10000; // 10000 as 1 MHz, 0.1 kHz resolution.
+    freq_osc = 25*unit;
+
+    adc_clk_cfg.d32 = clk_adc_cfg;
+    dig_clk_cfg.d32 = clk_dem_cfg;
+
+    pll_m = adc_clk_cfg.b.pll_m;
+    pll_n = adc_clk_cfg.b.pll_n;
+    pll_od = adc_clk_cfg.b.pll_od;
+    div_adc = adc_clk_cfg.b.pll_xd;
+    div_dem = dig_clk_cfg.b.demod_clk_div + 1;
+
+    *demod_dig_clk = dig_clk_cfg.d32;
+    *demod_adc_clk = adc_clk_cfg.d32;
+
+    freq_vco = freq_osc * pll_m / pll_n;
+    freq_out = freq_vco / (1<<pll_od);
+    freq_dem_act = freq_out / div_dem;
+    freq_adc_act = freq_out / div_adc;*/
+
+    //printk(" ADC PLL  M %3d   N %3d\n", pll_m, pll_n);
+    //printk(" ADC PLL OD %3d  XD %3d\n", pll_od, div_adc);
+    //printk(" DIG SRC SEL %2d  DIV %2d\n", 3, div_dem);
+    //printk(" DIG %7d kHz ADC %7d kHz\n",
+               //       freq_dem_act/(unit/1000), freq_adc_act/(unit/1000));
+}
+
+/*void demod_set_adc_core_clk(int clk_adc, int clk_dem)
+{
+    volatile unsigned long *demod_dig_clk = P_HHI_DEMOD_CLK_CNTL;
+    volatile unsigned long *demod_adc_clk = P_HHI_ADC_PLL_CNTL;
+    int unit, error;
+    demod_dig_clk_t dig_clk_cfg;
+    demod_adc_clk_t adc_clk_cfg;
+    int pll_m, pll_n, pll_od, div_dem, div_adc;
+    int freq_osc, freq_vco, freq_out, freq_dem, freq_adc;
+    int freq_dem_act, freq_adc_act, err_tmp, best_err;
+
+    unit = 10000; // 10000 as 1 MHz, 0.1 kHz resolution.
+    freq_osc = 25*unit;
+    adc_clk_cfg.d32 = 0;
+    dig_clk_cfg.d32 = 0;
+
+    if (clk_adc > 0) {
+        adc_clk_cfg.b.reset = 0;
+        adc_clk_cfg.b.pll_pd = 0;
+        if (clk_adc < 1000)
+            freq_adc = clk_adc*unit;
+        else
+            freq_adc = clk_adc*unit/1000;
+    }
+    else {
+        adc_clk_cfg.b.pll_pd = 1;
+    }
+
+    if (clk_dem > 0) {
+        dig_clk_cfg.b.demod_clk_en = 1;
+        dig_clk_cfg.b.demod_clk_sel = 3;
+        if (clk_dem < 1000)
+            freq_dem = clk_dem*unit;
+        else
+            freq_dem = clk_dem*unit/1000;
+    }
+    else {
+        dig_clk_cfg.b.demod_clk_en = 0;
+    }
+
+    error = 1;
+    best_err = 100*unit;
+    for (pll_m=1; pll_m<512; pll_m++) {
+        for (pll_n=1; pll_n<=5; pll_n++) {
+            freq_vco = freq_osc * pll_m / pll_n;
+            if (freq_vco<750*unit || freq_vco>1500*unit) continue;
+
+            for (pll_od=0; pll_od<3; pll_od++) {
+                freq_out = freq_vco / (1<<pll_od);
+                if (freq_out > 800*unit) continue;
+
+                div_dem = freq_out / freq_dem;
+                if (div_dem==0 || div_dem>127) continue;
+
+                freq_dem_act = freq_out / div_dem;
+                err_tmp = freq_dem_act - freq_dem;
+
+                div_adc = freq_out / freq_adc / 2;
+                div_adc *= 2;
+                if (div_adc==0 || div_adc>31) continue;
+
+                freq_adc_act = freq_out / div_adc;
+                if (freq_adc_act-freq_adc > unit/5) continue;
+
+                if (err_tmp >= best_err) continue;
+
+                adc_clk_cfg.b.pll_m = pll_m;
+                adc_clk_cfg.b.pll_n = pll_n;
+                adc_clk_cfg.b.pll_od = pll_od;
+                adc_clk_cfg.b.pll_xd = div_adc;
+                dig_clk_cfg.b.demod_clk_div = div_dem - 1;
+
+                error = 0;
+                best_err = err_tmp;
+            }
+        }
+    }
+
+    pll_m = adc_clk_cfg.b.pll_m;
+    pll_n = adc_clk_cfg.b.pll_n;
+    pll_od = adc_clk_cfg.b.pll_od;
+    div_adc = adc_clk_cfg.b.pll_xd;
+    div_dem = dig_clk_cfg.b.demod_clk_div + 1;
+
+    if (error) {
+        //printk(" ERROR DIG %7d kHz  ADC %7d kHz\n",
+                    //      freq_dem/(unit/1000), freq_adc/(unit/1000));
+    }
+    else {
+        *demod_dig_clk = dig_clk_cfg.d32;
+        *demod_adc_clk = adc_clk_cfg.d32;
+
+        freq_vco = freq_osc * pll_m / pll_n;
+        freq_out = freq_vco / (1<<pll_od);
+        freq_dem_act = freq_out / div_dem;
+        freq_adc_act = freq_out / div_adc;
+
+        //printk(" ADC PLL  M %3d   N %3d\n", pll_m, pll_n);
+        //printk(" ADC PLL OD %3d  XD %3d\n", pll_od, div_adc);
+        //printk(" DIG SRC SEL %2d  DIV %2d\n", 3, div_dem);
+        //printk(" DIG %7d kHz %7d kHz\n",
+//                          freq_dem/(unit/1000), freq_dem_act/(unit/1000));
+        //printk(" ADC %7d kHz %7d kHz\n",
+                  //        freq_adc/(unit/1000), freq_adc_act/(unit/1000));
+    }
+}*/
+
+void apb_write_reg(int addr, int data)
+{
+    *(volatile unsigned long*)addr = data;
+//	printk("[write]addr is %x,data is %x\n",addr,data);
+}
+
+unsigned long apb_read_reg(int addr)
+{
+    unsigned long tmp;
+
+    tmp = *(volatile unsigned long*)addr;
+//	printk("[read]addr is %x,data is %x\n",addr,tmp);
+    return tmp;
+}
+
+void apb_write_regb(int addr, int index, int data)
+{
+    unsigned long tmp;
+
+    tmp = *(volatile unsigned *)addr;
+    tmp &= ~(1<<index);
+    tmp |= (data<<index);
+    *(volatile unsigned *)addr = tmp;
+}
+
+void enable_qam_int(int idx)
+{
+    unsigned long mask;
+
+    mask = apb_read_reg(QAM_BASE+0xd0);
+    mask |= (1<<idx);
+    apb_write_reg(QAM_BASE+0xd0, mask);
+}
+
+void disable_qam_int(int idx)
+{
+    unsigned long mask;
+
+    mask = apb_read_reg(QAM_BASE+0xd0);
+    mask &= ~(1<<idx);
+    apb_write_reg(QAM_BASE+0xd0, mask);
+}
+
+char *qam_int_name[] = {"      ADC",
+			"   Symbol",
+			"       RS",
+			" In_Sync0",
+			" In_Sync1",
+			" In_Sync2",
+			" In_Sync3",
+			" In_Sync4",
+			"Out_Sync0",
+			"Out_Sync1",
+			"Out_Sync2",
+			"Out_Sync3",
+			"Out_Sync4",
+			"In_SyncCo",
+			"OutSyncCo",
+			"  In_Dagc",
+			" Out_Dagc",
+			"  Eq_Mode",
+			"RS_Uncorr"};
+
+#define OFDM_INT_STS         (volatile unsigned long *)(DVBT_BASE+4*0x0d)
+#define OFDM_INT_EN          (volatile unsigned long *)(DVBT_BASE+4*0x0e)
+
+void enable_ofdm_int(int ofdm_irq)
+{
+    // clear ofdm/xxx status
+    (*OFDM_INT_STS) &= ~(1<<ofdm_irq);
+    // enable ofdm/xxx irq
+    (*OFDM_INT_EN) |= (1<<ofdm_irq);
+}
+
+void disable_ofdm_int(int ofdm_irq)
+{
+    unsigned long tmp;
+
+    // disable ofdm/xxx irq
+    tmp = (*OFDM_INT_EN);
+    tmp &= ~(1<<ofdm_irq);
+    (*OFDM_INT_EN) = tmp;
+    // clear ofdm/xxx status
+    (*OFDM_INT_STS) &= ~(1<<ofdm_irq);
+}
+
+char *ofdm_int_name[] = {"PFS_FCFO",
+			 "PFS_ICFO",
+			 " CS_FCFO",
+			 " PFS_SFO",
+			 " PFS_TPS",
+			 "      SP",
+			 "     CCI",
+			 "  Symbol",
+			 " In_Sync",
+			 "Out_Sync",
+			 "FSM Stat"};
+
+unsigned long read_ofdm_int(void)
+{
+    unsigned long stat, mask, tmp;
+    int idx;
+    char buf[80];
+
+    // read ofdm/xxx status
+    tmp = (*OFDM_INT_STS);
+    mask = (*OFDM_INT_EN);
+    stat = tmp & mask;
+
+    for (idx=0; idx<11; idx++) {
+	if (stat>>idx&1) {
+	    strcpy(buf, "OFDM ");
+	    strcat(buf, ofdm_int_name[idx]);
+	    strcat(buf, " INT %d    STATUS   %x");
+	    //printk(buf, idx, stat);
+	}
+    }
+    // clear ofdm/xxx status
+    (*OFDM_INT_STS) = 0;
+
+    return stat;
+}
+
+#define PHS_LOOP_OPEN
+
+void qam_read_all_regs(void)
+{
+    int i, addr;
+    unsigned long tmp;
+
+    for (i=0; i<0xf0; i+=4) {
+        addr = QAM_BASE + i;
+	tmp = *(volatile unsigned *)addr;
+//	pr_dbg("QAM addr 0x%02x  value 0x%08x\n", i, tmp);
+    }
+}
+
+void  ini_icfo_pn_index (int mode) // 00:DVBT,01:ISDBT
+{
+    if (mode == 0)
+    {
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000031);apb_write_reg(DVBT_BASE+0x3fc, 0x00030000);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000032);apb_write_reg(DVBT_BASE+0x3fc, 0x00057036);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000033);apb_write_reg(DVBT_BASE+0x3fc, 0x0009c08d);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000034);apb_write_reg(DVBT_BASE+0x3fc, 0x000c90c0);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000035);apb_write_reg(DVBT_BASE+0x3fc, 0x001170ff);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000036);apb_write_reg(DVBT_BASE+0x3fc, 0x0014d11a);
+    }
+    else if (mode == 1)
+    {
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000031);apb_write_reg(DVBT_BASE+0x3fc, 0x00085046);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000032);apb_write_reg(DVBT_BASE+0x3fc, 0x0019a0e9);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000033);apb_write_reg(DVBT_BASE+0x3fc, 0x0024b1dc);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000034);apb_write_reg(DVBT_BASE+0x3fc, 0x003b3313);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000035);apb_write_reg(DVBT_BASE+0x3fc, 0x0048d409);
+       apb_write_reg(DVBT_BASE+0x3f8, 0x00000036);apb_write_reg(DVBT_BASE+0x3fc, 0x00527509);
+    }
+}
+
+void tfd_filter_coff_ini(void)
+{
+    int i;
+    int coef[] = {
+        0xf900, 0xfe00, 0x0000, 0x0000, 0x0100, 0x0100, 0x0000, 0x0000,
+        0xfd00, 0xf700, 0x0000, 0x0000, 0x4c00, 0x0000, 0x0000, 0x0000,
+        0x2200, 0x0c00, 0x0000, 0x0000, 0xf700, 0xf700, 0x0000, 0x0000,
+        0x0300, 0x0900, 0x0000, 0x0000, 0x0600, 0x0600, 0x0000, 0x0000,
+        0xfc00, 0xf300, 0x0000, 0x0000, 0x2e00, 0x0000, 0x0000, 0x0000,
+        0x3900, 0x1300, 0x0000, 0x0000, 0xfa00, 0xfa00, 0x0000, 0x0000,
+        0x0100, 0x0200, 0x0000, 0x0000, 0xf600, 0x0000, 0x0000, 0x0000,
+        0x0700, 0x0700, 0x0000, 0x0000, 0xfe00, 0xfb00, 0x0000, 0x0000,
+        0x0900, 0x0000, 0x0000, 0x0000, 0x3200, 0x1100, 0x0000, 0x0000,
+        0x0400, 0x0400, 0x0000, 0x0000, 0xfe00, 0xfb00, 0x0000, 0x0000,
+        0x0e00, 0x0000, 0x0000, 0x0000, 0xfb00, 0xfb00, 0x0000, 0x0000,
+        0x0100, 0x0200, 0x0000, 0x0000, 0xf400, 0x0000, 0x0000, 0x0000,
+        0x3900, 0x1300, 0x0000, 0x0000, 0x1700, 0x1700, 0x0000, 0x0000,
+        0xfc00, 0xf300, 0x0000, 0x0000, 0x0c00, 0x0000, 0x0000, 0x0000,
+        0x0300, 0x0900, 0x0000, 0x0000, 0xee00, 0x0000, 0x0000, 0x0000,
+        0x2200, 0x0c00, 0x0000, 0x0000, 0x2600, 0x2600, 0x0000, 0x0000,
+        0xfd00, 0xf700, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000,
+        0xf900, 0xfe00, 0x0000, 0x0000, 0x0400, 0x0b00, 0x0000, 0x0000,
+        0xf900, 0x0000, 0x0000, 0x0000, 0x0700, 0x0200, 0x0000, 0x0000,
+        0x2100, 0x2100, 0x0000, 0x0000, 0x0200, 0x0700, 0x0000, 0x0000,
+        0xf900, 0x0000, 0x0000, 0x0000, 0x0b00, 0x0400, 0x0000, 0x0000,
+        0xfe00, 0xf900, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000,
+        0xf700, 0xfd00, 0x0000, 0x0000, 0x2600, 0x2600, 0x0000, 0x0000,
+        0x0c00, 0x2200, 0x0000, 0x0000, 0xee00, 0x0000, 0x0000, 0x0000,
+        0x0900, 0x0300, 0x0000, 0x0000, 0x0c00, 0x0000, 0x0000, 0x0000,
+        0xf300, 0xfc00, 0x0000, 0x0000, 0x1700, 0x1700, 0x0000, 0x0000,
+        0x1300, 0x3900, 0x0000, 0x0000, 0xf400, 0x0000, 0x0000, 0x0000,
+        0x0200, 0x0100, 0x0000, 0x0000, 0xfb00, 0xfb00, 0x0000, 0x0000,
+        0x0e00, 0x0000, 0x0000, 0x0000, 0xfb00, 0xfe00, 0x0000, 0x0000,
+        0x0400, 0x0400, 0x0000, 0x0000, 0x1100, 0x3200, 0x0000, 0x0000,
+        0x0900, 0x0000, 0x0000, 0x0000, 0xfb00, 0xfe00, 0x0000, 0x0000,
+        0x0700, 0x0700, 0x0000, 0x0000, 0xf600, 0x0000, 0x0000, 0x0000,
+        0x0200, 0x0100, 0x0000, 0x0000, 0xfa00, 0xfa00, 0x0000, 0x0000,
+        0x1300, 0x3900, 0x0000, 0x0000, 0x2e00, 0x0000, 0x0000, 0x0000,
+        0xf300, 0xfc00, 0x0000, 0x0000, 0x0600, 0x0600, 0x0000, 0x0000,
+        0x0900, 0x0300, 0x0000, 0x0000, 0xf700, 0xf700, 0x0000, 0x0000,
+        0x0c00, 0x2200, 0x0000, 0x0000, 0x4c00, 0x0000, 0x0000, 0x0000,
+        0xf700, 0xfd00, 0x0000, 0x0000, 0x0100, 0x0100, 0x0000, 0x0000,
+        0xfe00, 0xf900, 0x0000, 0x0000, 0x0b00, 0x0400, 0x0000, 0x0000,
+        0xfc00, 0xfc00, 0x0000, 0x0000, 0x0200, 0x0700, 0x0000, 0x0000,
+        0x4200, 0x0000, 0x0000, 0x0000, 0x0700, 0x0200, 0x0000, 0x0000,
+        0xfc00, 0xfc00, 0x0000, 0x0000, 0x0400, 0x0b00, 0x0000, 0x0000};
+
+    for (i=0; i<336; i++) {
+        apb_write_reg(DVBT_BASE+0x99*4, (i<<16) | coef[i]);
+        apb_write_reg(DVBT_BASE+0x03*4, (1<<12));
+    }
+}
+
+/*int dvbt_check_status(int)
+{
+		int i;
+		unsigned int status;
+		int signal=0;
+		char status_num[8];
+		status=apb_read_reg(DVBT_BASE+(0x2a<<2);
+		for(i=0;i<8;i++){
+			status_num[i]=status<<i&0xf;
+			if(status_num[i]>3){
+				signal=1;
+				printk("dvbt have signal \n");
+			}else{
+				signal=0;
+				printk("dvbt have no signal \n");
+			}
+		}
+
+
+
+}*/
+
+
+extern int memstart;
+void ofdm_initial(
+    int bandwidth, // 00:8M 01:7M 10:6M 11:5M
+    int samplerate,// 00:45M 01:20.8333M 10:20.7M 11:28.57 100: 24.00
+    int IF,        // 000:36.13M 001:-5.5M 010:4.57M 011:4M 100:5M
+    int mode,       // 00:DVBT,01:ISDBT
+    int tc_mode     // 0: Unsigned, 1:TC
+)
+{
+    int tmp;
+    int ch_if;
+    int adc_freq;
+	printk("[ofdm_initial]bandwidth is %d,samplerate is %d,IF is %d, mode is %d,tc_mode is %d\n",bandwidth,samplerate,IF,mode,tc_mode);
+    switch(IF)
+    {
+        case 0: ch_if = 36130;break;
+        case 1: ch_if = -5500;break;
+        case 2: ch_if = 4570;break;
+        case 3: ch_if = 4000;break;
+        case 4: ch_if = 5000;break;
+        default: ch_if = 4000;break;
+    }
+    switch(samplerate)
+    {
+        case 0: adc_freq = 45000;break;
+        case 1: adc_freq = 20833;break;
+        case 2: adc_freq = 20700;break;
+        case 3: adc_freq = 28571;break;
+		case 4: adc_freq = 24000;break;
+        default: adc_freq = 28571;break;
+    }
+
+    apb_write_reg(DVBT_BASE+(0x02<<2), 0x00800000);  // SW reset bit[23] ; write anything to zero
+    apb_write_reg(DVBT_BASE+(0x00<<2), 0x00000000);
+
+    apb_write_reg(DVBT_BASE+(0xe<<2), 0xffff); // enable interrupt
+
+    if (mode == 0) { // DVBT
+       switch (samplerate)
+       {
+         case 0 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x00005a00);break;  // 45MHz
+         case 1 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x000029aa);break;  // 20.833
+         case 2 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x00002966);break;  // 20.7   SAMPLERATE*512
+         case 3 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x00003924);break;  // 28.571
+         case 4 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x00003000);break;  // 24
+         default: apb_write_reg(DVBT_BASE+(0x08<<2), 0x00003924);break;  // 28.571
+       }
+    }
+    else { //ISDBT
+       switch (samplerate)
+       {
+         case 0 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x0000580d);break;  // 45MHz
+         case 1 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x0000290d);break;  // 20.833 = 56/7 * 20.8333 / (512/63)*512
+         case 2 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x000028da);break;  // 20.7
+         case 3 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x0000383F);break;  // 28.571  3863
+         case 4 : apb_write_reg(DVBT_BASE+(0x08<<2), 0x00002F40);break;  // 24
+         default: apb_write_reg(DVBT_BASE+(0x08<<2), 0x00003863);break;  // 28.571
+       }
+    }
+//	memstart=0x93900000;
+	printk("memstart is %x \n",memstart);
+    apb_write_reg(DVBT_BASE+(0x10<<2), memstart);//0x8f300000
+
+    apb_write_reg(DVBT_BASE+(0x14<<2), 0xe81c4ff6);   // AGC_TARGET 0xf0121385
+
+    switch(samplerate)
+    {
+       case 0 : apb_write_reg(DVBT_BASE+(0x15<<2), 0x018c2df2); break;
+       case 1 : apb_write_reg(DVBT_BASE+(0x15<<2), 0x0185bdf2); break;
+       case 2 : apb_write_reg(DVBT_BASE+(0x15<<2), 0x0185bdf2); break;
+       case 3 : apb_write_reg(DVBT_BASE+(0x15<<2), 0x0187bdf2); break;
+       case 4 : apb_write_reg(DVBT_BASE+(0x15<<2), 0x0187bdf2); break;
+       default: apb_write_reg(DVBT_BASE+(0x15<<2), 0x0187bdf2); break;
+    }
+    if (tc_mode == 1) apb_write_regb(DVBT_BASE+(0x15<<2),11,0);// For TC mode. Notice, For ADC input is Unsigned, For Capture Data, It is TC.
+    apb_write_regb(DVBT_BASE+(0x15<<2),26,1); // [19:0] = [I , Q], I is high, Q is low. This bit is swap I/Q.
+
+    apb_write_reg(DVBT_BASE+(0x16<<2), 0x00047f80);  // AGC_IFGAIN_CTRL
+    apb_write_reg(DVBT_BASE+(0x17<<2), 0x00027f80);  // AGC_RFGAIN_CTRL
+    apb_write_reg(DVBT_BASE+(0x18<<2), 0x00000190);  // AGC_IFGAIN_ACCUM
+    apb_write_reg(DVBT_BASE+(0x19<<2), 0x00000190);  // AGC_RFGAIN_ACCUM
+    if (ch_if <0) ch_if += adc_freq;
+    if (ch_if > adc_freq) ch_if -= adc_freq;
+
+    tmp = ch_if * (1<<15) / adc_freq;
+    apb_write_reg(DVBT_BASE + (0x20<<2), tmp);
+
+    apb_write_reg(DVBT_BASE+(0x21<<2), 0x001ff000);  // DDC CS_FCFO_ADJ_CTRL
+    apb_write_reg(DVBT_BASE+(0x22<<2), 0x00000000);  // DDC ICFO_ADJ_CTRL
+    apb_write_reg(DVBT_BASE+(0x23<<2), 0x00004000);  // DDC TRACK_FCFO_ADJ_CTRL
+
+    apb_write_reg(DVBT_BASE+(0x27<<2), (1<<23)|(3<<19)|(3<<15)|(1000<<4)|9); // {8'd0,1'd1,4'd3,4'd3,11'd50,4'd9});//FSM_1
+    apb_write_reg(DVBT_BASE+(0x28<<2), (100<<13)|1000);//{8'd0,11'd40,13'd50});//FSM_2
+	apb_write_reg(DVBT_BASE+(0x29<<2), (31<<20)|(1<<16)|(24<<9)|(3<<6)|20);//{5'd0,7'd127,1'd0,3'd0,7'd24,3'd5,6'd20});
+
+    if (mode == 0) { // DVBT
+
+        if (bandwidth==0) { // 8M
+            switch(samplerate)
+            {
+               case 0: ini_acf_iireq_src_45m_8m();  apb_write_reg(DVBT_BASE+(0x44<<2), 0x004ebf2e); break;// 45M
+               case 1: ini_acf_iireq_src_207m_8m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x00247551); break;//20.833M
+               case 2: ini_acf_iireq_src_207m_8m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x00243999); break;//20.7M
+               case 3: ini_acf_iireq_src_2857m_8m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x0031ffcd); break;//28.57M
+               case 4: ini_acf_iireq_src_24m_8m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x002A0000); break;//24M
+               default: ini_acf_iireq_src_2857m_8m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x0031ffcd); break;//28.57M
+            }
+        }
+        else if (bandwidth==1) { // 7M
+            switch(samplerate)
+            {
+               case 0: ini_acf_iireq_src_45m_7m();  apb_write_reg(DVBT_BASE+(0x44<<2), 0x0059ff10); break;// 45M
+               case 1: ini_acf_iireq_src_207m_7m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x0029aaa6); break;//20.833M
+               case 2: ini_acf_iireq_src_207m_7m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x00296665); break;//20.7M
+               case 3: ini_acf_iireq_src_2857m_7m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x00392491); break;//28.57M
+               case 4: ini_acf_iireq_src_24m_7m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x00300000); break;//24M
+               default: ini_acf_iireq_src_2857m_7m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x00392491); break;//28.57M
+            }
+        }
+        else if (bandwidth==2) { // 6M
+            switch(samplerate)
+            {
+               case 0: ini_acf_iireq_src_45m_6m();  apb_write_reg(DVBT_BASE+(0x44<<2), 0x00690000); break;// 45M
+               case 1: ini_acf_iireq_src_207m_6m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x00309c3e); break;//20.833M
+               case 2: ini_acf_iireq_src_207m_6m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x002eaaaa); break;//20.7M
+               case 3: ini_acf_iireq_src_2857m_6m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x0042AA69); break;//28.57M
+               case 4: ini_acf_iireq_src_24m_6m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x00380000); break;//24M
+               default: ini_acf_iireq_src_2857m_6m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x0042AA69); break;//28.57M
+            }
+        }
+        else {// 5M
+            switch(samplerate)
+            {
+               case 0: ini_acf_iireq_src_45m_5m();  apb_write_reg(DVBT_BASE+(0x44<<2), 0x007dfbe0); break;// 45M
+               case 1: ini_acf_iireq_src_207m_5m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x003a554f); break;//20.833M
+               case 2: ini_acf_iireq_src_207m_5m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x0039f5c0); break;//20.7M
+               case 3: ini_acf_iireq_src_2857m_5m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x004FFFFE); break;//28.57M
+               case 4: ini_acf_iireq_src_24m_5m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x00433333); break;//24M
+               default: ini_acf_iireq_src_2857m_5m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x004FFFFE); break;//28.57M
+            }
+        }
+    }
+    else // ISDBT
+    {
+        switch(samplerate)
+        {
+           case 0: ini_acf_iireq_src_45m_6m();  apb_write_reg(DVBT_BASE+(0x44<<2), 0x00589800);break;// 45M     SampleRate/(symbolRate)*2^20, symbolRate = 512/63 for isdbt
+           case 1: ini_acf_iireq_src_207m_6m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x002903d4);break;// 20.833M
+           case 2: ini_acf_iireq_src_207m_6m(); apb_write_reg(DVBT_BASE+(0x44<<2), 0x00280ccc);break;// 20.7M
+           case 3: ini_acf_iireq_src_2857m_6m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x00383fc8);break;// 28.57M
+           case 4: ini_acf_iireq_src_24m_6m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x002F4000); break;//24M
+           default: ini_acf_iireq_src_2857m_6m();apb_write_reg(DVBT_BASE+(0x44<<2), 0x00383fc8);break;//28.57M
+        }
+    }
+
+    if (mode == 0)// DVBT
+        apb_write_reg(DVBT_BASE+(0x02<<2), (bandwidth<<20)|0x10002);
+    else          // ISDBT
+        apb_write_reg(DVBT_BASE+(0x02<<2), (1<<20)|0x1001a);//{0x000,2'h1,20'h1_001a});    // For ISDBT , bandwith should be 1,
+
+    apb_write_reg(DVBT_BASE+(0x45<<2), 0x00000000);  // SRC SFO_ADJ_CTRL
+ 	  apb_write_reg(DVBT_BASE+(0x46<<2), 0x02004000);  // SRC SFO_ADJ_CTRL
+    apb_write_reg(DVBT_BASE+(0x48<<2), 0x000c0287);  // DAGC_CTRL1
+    apb_write_reg(DVBT_BASE+(0x49<<2), 0x00000005);  // DAGC_CTRL2
+    apb_write_reg(DVBT_BASE+(0x4c<<2), 0x00000bbf);  // CCI_RP
+    apb_write_reg(DVBT_BASE+(0x4d<<2), 0x00000376);  // CCI_RPSQ
+    apb_write_reg(DVBT_BASE+(0x4e<<2), 0x0f0f1d09);  // CCI_CTRL
+    apb_write_reg(DVBT_BASE+(0x4f<<2), 0x00000000);  // CCI DET_INDX1
+    apb_write_reg(DVBT_BASE+(0x50<<2), 0x00000000);  // CCI DET_INDX2
+    apb_write_reg(DVBT_BASE+(0x51<<2), 0x00000000);  // CCI_NOTCH1_A1
+    apb_write_reg(DVBT_BASE+(0x52<<2), 0x00000000);  // CCI_NOTCH1_A2
+    apb_write_reg(DVBT_BASE+(0x53<<2), 0x00000000);  // CCI_NOTCH1_B1
+    apb_write_reg(DVBT_BASE+(0x54<<2), 0x00000000);  // CCI_NOTCH2_A1
+    apb_write_reg(DVBT_BASE+(0x55<<2), 0x00000000);  // CCI_NOTCH2_A2
+    apb_write_reg(DVBT_BASE+(0x56<<2), 0x00000000);  // CCI_NOTCH2_B1
+    apb_write_reg(DVBT_BASE+(0x58<<2), 0x00000885);  // MODE_DETECT_CTRL // 582
+    if (mode == 0) //DVBT
+    	apb_write_reg(DVBT_BASE+(0x5c<<2), 0x00001011);  //
+    else
+    	apb_write_reg(DVBT_BASE+(0x5c<<2), 0x00000753);  // ICFO_EST_CTRL ISDBT ICFO thres = 2
+
+    apb_write_reg(DVBT_BASE+(0x5f<<2), 0x0ffffe10);  // TPS_FCFO_CTRL
+    apb_write_reg(DVBT_BASE+(0x61<<2), 0x0000006c);  // FWDT ctrl
+ 	apb_write_reg(DVBT_BASE+(0x68<<2), 0x128c3929);
+    apb_write_reg(DVBT_BASE+(0x69<<2), 0x91017f2d);  // 0x1a8
+    apb_write_reg(DVBT_BASE+(0x6b<<2), 0x00442211);  // 0x1a8
+    apb_write_reg(DVBT_BASE+(0x6c<<2), 0x01fc400a);  // 0x
+    apb_write_reg(DVBT_BASE+(0x6d<<2), 0x0030303f);  // 0x
+    apb_write_reg(DVBT_BASE+(0x73<<2), 0xffffffff);  // CCI0_PILOT_UPDATE_CTRL
+    apb_write_reg(DVBT_BASE+(0x74<<2), 0xffffffff);  // CCI0_DATA_UPDATE_CTRL
+    apb_write_reg(DVBT_BASE+(0x75<<2), 0xffffffff);  // CCI1_PILOT_UPDATE_CTRL
+    apb_write_reg(DVBT_BASE+(0x76<<2), 0xffffffff);  // CCI1_DATA_UPDATE_CTRL
+
+    tmp = mode==0 ? 0x000001a2 : 0x00000da2;
+    apb_write_reg(DVBT_BASE+(0x78<<2), tmp);  // FEC_CTR
+
+    apb_write_reg(DVBT_BASE+(0x7d<<2), 0x0000009d);
+    apb_write_reg(DVBT_BASE+(0x7e<<2), 0x00004000);
+    apb_write_reg(DVBT_BASE+(0x7f<<2), 0x00008000);
+
+
+    apb_write_reg(DVBT_BASE+((0x8b+0)<<2), 0x20002000);
+    apb_write_reg(DVBT_BASE+((0x8b+1)<<2), 0x20002000);
+    apb_write_reg(DVBT_BASE+((0x8b+2)<<2), 0x20002000);
+    apb_write_reg(DVBT_BASE+((0x8b+3)<<2), 0x20002000);
+    apb_write_reg(DVBT_BASE+((0x8b+4)<<2), 0x20002000);
+    apb_write_reg(DVBT_BASE+((0x8b+5)<<2), 0x20002000);
+    apb_write_reg(DVBT_BASE+((0x8b+6)<<2), 0x20002000);
+    apb_write_reg(DVBT_BASE+((0x8b+7)<<2), 0x20002000);
+
+    apb_write_reg(DVBT_BASE+(0x93<<2), 0x31);
+    apb_write_reg(DVBT_BASE+(0x94<<2), 0x00);
+    apb_write_reg(DVBT_BASE+(0x95<<2), 0x7f1);
+    apb_write_reg(DVBT_BASE+(0x96<<2), 0x20);
+
+    apb_write_reg(DVBT_BASE+(0x98<<2), 0x03f9115a);
+    apb_write_reg(DVBT_BASE+(0x9b<<2), 0x000005df);
+
+    apb_write_reg(DVBT_BASE+(0x9c<<2), 0x00100000);// TestBus write valid, 0 is system clk valid
+    apb_write_reg(DVBT_BASE+(0x9d<<2), 0x01000000);// DDR Start address
+    apb_write_reg(DVBT_BASE+(0x9e<<2), 0x02000000);// DDR End   address
+
+    apb_write_regb(DVBT_BASE+(0x9b<<2),7,0);// Enable Testbus dump to DDR
+    apb_write_regb(DVBT_BASE+(0x9b<<2),8,0);// Run Testbus dump to DDR
+
+    apb_write_reg(DVBT_BASE+(0xd6<<2), 0x00000003);
+    //apb_write_reg(DVBT_BASE+(0xd7<<2), 0x00000008);
+    apb_write_reg(DVBT_BASE+(0xd8<<2), 0x00000120);
+    apb_write_reg(DVBT_BASE+(0xd9<<2), 0x01010101);
+
+    ini_icfo_pn_index(mode);
+    tfd_filter_coff_ini();
+
+    calculate_cordic_para();
+	msleep(1);
+ //   delay_us(1);
+
+    apb_write_reg(DVBT_BASE+(0x02<<2), apb_read_reg(DVBT_BASE+(0x02<<2)) | (1 << 0));
+    apb_write_reg(DVBT_BASE+(0x02<<2), apb_read_reg(DVBT_BASE+(0x02<<2)) | (1 << 24));
+
+//	dvbt_check_status();
+
+}
+
+void calculate_cordic_para()
+{
+    apb_write_reg(DVBT_BASE+0x0c, 0x00000040);
+}
+
+char *ofdm_fsm_name[] = {"    IDLE",
+			 "     AGC",
+			 "     CCI",
+			 "     ACQ",
+			 "    SYNC",
+			 "TRACKING",
+			 "  TIMING",
+			 " SP_SYNC",
+			 " TPS_DEC",
+			 "FEC_LOCK",
+			 "FEC_LOST"};
+
+void check_fsm_state(void)
+{
+    unsigned long tmp;
+
+    tmp = apb_read_reg(DVBT_BASE+0xa8);
+    //printk(">>>>>>>>>>>>>>>>>>>>>>>>> OFDM FSM From %d        to %d\n", tmp>>4&0xf, tmp&0xf);
+
+    if ((tmp&0xf)==3) {
+        apb_write_regb(DVBT_BASE+(0x9b<<2),8,1);//Stop dump testbus;
+        apb_write_regb(DVBT_BASE+(0x0f<<2),0,1);
+        tmp = apb_read_reg(DVBT_BASE+(0x9f<<2));
+        //printk(">>>>>>>>>>>>>>>>>>>>>>>>> STOP DUMP DATA To DDR : End Addr %d,Is it overflow?%d\n", tmp>>1, tmp&0x1);
+    }
+
+}
+
+void ofdm_read_all_regs()
+{
+    int i;
+    unsigned long tmp;
+
+    for (i=0; i<0xff; i++) {
+	tmp = apb_read_reg(DVBT_BASE+0x00+i*4);
+	//printk("OFDM Reg (0x%x) is 0x%x\n", i, tmp);
+    }
+
+}
+
+static int dvbt_get_status(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+	return apb_read_reg(DVBT_BASE+0x0)>>12&1;
+}
+
+
+static int dvbt_get_ber(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+	pr_dbg("[RSJ]per is %lu\n",apb_read_reg(DVBT_BASE+(0xbf<<2)));
+	return apb_read_reg(DVBT_BASE+(0xbf<<2));
+//	return dvbt_ber();/*unit: 1e-7*/
+}
+
+static int dvbt_get_snr(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+	pr_dbg("2snr is %lu\n",((apb_read_reg(DVBT_BASE+(0x0a<<2)))>>20)&0x3ff);
+	return ((apb_read_reg(DVBT_BASE+(0x0a<<2)))>>20)&0x3ff;/*dBm: bit0~bit2=decimal*/
+}
+
+static int dvbt_get_strength(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+//	int dbm = dvbt_get_ch_power(demod_sta, demod_i2c);
+//	return dbm;
+	return 0;
+}
+
+static int dvbt_get_ucblocks(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+	return 0;
+//	return dvbt_get_per();
+}
+
+struct demod_status_ops* dvbt_get_status_ops(void)
+{
+	static struct demod_status_ops ops = {
+		.get_status = dvbt_get_status,
+		.get_ber = dvbt_get_ber,
+		.get_snr = dvbt_get_snr,
+		.get_strength = dvbt_get_strength,
+		.get_ucblocks = dvbt_get_ucblocks,
+	};
+
+	return &ops;
+}
+
+int app_apb_read_reg(int addr)
+{
+	return (int)(apb_read_reg(DVBT_BASE+(addr<<2)));
+
+}
+
+int app_apb_write_reg(int addr,int data)
+{
+	apb_write_reg((DVBT_BASE+(addr<<2)),data);
+	return 0;
+}
+
+
+void monitor_isdbt(void)
+{
+     int SNR;
+     int SNR_SP          = 500;
+     int SNR_TPS         = 0;
+     int SNR_CP          = 0;
+     int timeStamp       = 0;
+     int SFO_residual    = 0;
+     int SFO_esti        = 0;
+     int FCFO_esti       = 0;
+     int FCFO_residual   = 0;
+     int AGC_Gain        = 0;
+     int RF_AGC          = 0;
+     int Signal_power    = 0;
+     int FECFlag         = 0;
+     int EQ_seg_ratio    = 0;
+     int tps_0           = 0;
+     int tps_1           = 0;
+     int tps_2           = 0;
+
+     int time_stamp;
+     int SFO;
+     int FCFO;
+     int timing_adj;
+     int RS_CorrectNum;
+
+     int cnt;
+     int tmpAGCGain;
+	 tmpAGCGain      = 0;
+	 cnt = 0;
+
+//     app_apb_write_reg(0x8, app_apb_read_reg(0x8) & ~(1 << 17));  // TPS symbol index update : active high
+     time_stamp      =  app_apb_read_reg(0x07)&0xffff       ;
+     SNR             =  app_apb_read_reg(0x0a)              ;
+     FECFlag         = (app_apb_read_reg(0x00)>>11)&0x3     ;
+     SFO             =  app_apb_read_reg(0x47)&0xfff        ;
+     SFO_esti        =  app_apb_read_reg(0x60)&0xfff        ;
+     FCFO_esti       = (app_apb_read_reg(0x60)>>11)&0xfff   ;
+     FCFO            = (app_apb_read_reg(0x26))&0xffffff    ;
+     RF_AGC          =  app_apb_read_reg(0x0c)&0x1fff       ;
+     timing_adj      =  app_apb_read_reg(0x6f)&0x1fff       ;
+     RS_CorrectNum   =  app_apb_read_reg(0xc1)&0xfffff      ;
+     Signal_power    = (app_apb_read_reg(0x1b))&0x1ff       ;
+     EQ_seg_ratio    =  app_apb_read_reg(0x6e)&0x3ffff      ;
+     tps_0           =  app_apb_read_reg(0x64);
+     tps_1           =  app_apb_read_reg(0x65);
+     tps_2           =  app_apb_read_reg(0x66)&0xf;
+
+     timeStamp       = (time_stamp>>8) * 68 + (time_stamp & 0x7f);
+     SFO_residual    = (SFO>0x7ff)? (SFO - 0x1000): SFO;
+     FCFO_residual   = (FCFO>0x7fffff)? (FCFO - 0x1000000): FCFO;
+     //RF_AGC          = (RF_AGC>0x3ff)? (RF_AGC - 0x800): RF_AGC;
+     FCFO_esti       = (FCFO_esti>0x7ff)?(FCFO_esti - 0x1000):FCFO_esti;
+     SNR_CP          = (SNR)&0x3ff;
+     SNR_TPS         = (SNR>>10)&0x3ff;
+     SNR_SP          = (SNR>>20)&0x3ff;
+     SNR_SP          = (SNR_SP  > 0x1ff)? SNR_SP - 0x400: SNR_SP;
+     SNR_TPS         = (SNR_TPS > 0x1ff)? SNR_TPS- 0x400: SNR_TPS;
+     SNR_CP          = (SNR_CP  > 0x1ff)? SNR_CP - 0x400: SNR_CP;
+     AGC_Gain        = tmpAGCGain >> 4;
+     tmpAGCGain      = (AGC_Gain>0x3ff)?AGC_Gain-0x800:AGC_Gain;
+     timing_adj      = (timing_adj > 0xfff)? timing_adj - 0x2000: timing_adj;
+     EQ_seg_ratio    = (EQ_seg_ratio > 0x1ffff)? EQ_seg_ratio - 0x40000 : EQ_seg_ratio;
+
+     pr_dbg("T %4x SP %3d TPS %3d CP %3d EQS %8x RSC %4d SFO %4d FCFO %4d Vit %4x Timing %3d SigP %3x FEC %x RSErr %8x ReSyn %x tps %03x%08x"
+         ,app_apb_read_reg(0xbf)
+         ,SNR_SP
+         ,SNR_TPS
+         ,SNR_CP
+//         ,EQ_seg_ratio
+         ,app_apb_read_reg(0x62)
+         ,RS_CorrectNum
+         ,SFO_residual
+         ,FCFO_residual
+         ,RF_AGC
+         ,timing_adj
+         ,Signal_power
+         ,FECFlag
+         ,app_apb_read_reg(0x0b)
+         ,(app_apb_read_reg(0xc0)>>20)&0xff
+         ,app_apb_read_reg(0x05)&0xfff
+         ,app_apb_read_reg(0x04)
+					);
+      pr_dbg("\n");
+
+
+}
+
+
+
+
+int find_2(int data, int *table, int len)
+{
+	  int end;
+	  int index;
+	  int start;
+	  int cnt=0;
+	  start = 0;
+	  end   = len;
+	  //printf("data is %d\n",data);
+	  while ((len > 1)&&(cnt < 10))
+	  {
+	  	 cnt ++ ;
+	  	 index = (len/2);
+	  	 if (data > table[start + index])
+	  	 	{
+	  	 	  start = start + index;
+	  	 	  len   = len - index - 1;
+	  	 	}
+	  	 if (data < table[start + index])
+	  	 	{
+	  	 	  len   = index + 1;
+	  	 	}
+	  	 else if (data == table[start+index])
+	  	 	{
+	  	 		start = start + index;
+	  	 	  break;
+	  	 	}
+	  }
+	  return start;
+}
+
+
+int read_atsc_all_reg(void)
+{
+	return 0;
+#if 0
+	int i,j,k;
+	j=4;
+	unsigned long data;
+	pr_dbg("system agc is:");		//system agc
+	for(i=0xc00;i<=0xc0c;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0xc80;i<=0xc87;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			printk("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		printk("%02x   ",data);
+		j++;
+	}
+	pr_dbg("\n vsb control is:");		//vsb control
+	j=4;
+	for(i=0x900;i<=0x905;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			printk("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x908;i<=0x912;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		printk("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x917;i<=0x91b;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x980;i<=0x992;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	pr_dbg("\n vsb demod is:");		//vsb demod
+	j=4;
+	for(i=0x700;i<=0x711;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x716;i<=0x720;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x722;i<=0x724;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x726;i<=0x72c;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x730;i<=0x732;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x735;i<=0x751;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x780;i<=0x795;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x752;i<=0x755;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	printk("\n vsb equalizer is:");		//vsb equalizer
+	j=4;
+	for(i=0x501;i<=0x5ff;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	printk("\n vsb fec is:");		//vsb fec
+	j=4;
+	for(i=0x601;i<=0x601;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x682;i<=0x685;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	printk("\n qam demod is:");		//qam demod
+	j=4;
+	for(i=0x1;i<=0x1a;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x25;i<=0x28;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x101;i<=0x10b;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x206;i<=0x207;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	printk("\n qam equalize is:");		//qam equalize
+	j=4;
+	for(i=0x200;i<=0x23d;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	j=4;
+	for(i=0x260;i<=0x275;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	printk("\n qam fec is:");		//qam fec
+	j=4;
+	for(i=0x400;i<=0x418;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	pr_dbg("\n system mpeg formatter is:");		//system mpeg formatter
+	j=4;
+	for(i=0xf00;i<=0xf09;i++){
+		data=atsc_read_reg(i);
+		if(j==4){
+			pr_dbg("\n[addr:0x%x]",i);
+		    j=0;
+		}
+		pr_dbg("%02x   ",data);
+		j++;
+	}
+	pr_dbg("\n\n");
+	return 0;
+#endif
+
+}
+
+
+int check_atsc_fsm_status()
+{
+	int SNR;
+	int atsc_snr=0;
+     int SNR_dB;
+     int SNR_table[56] = {0 ,7   ,9   ,11  ,14  ,17  ,22  ,27  ,34  ,43  ,54  ,
+     	                  68  ,86  ,108 ,136 ,171 ,215 ,271 ,341 ,429 ,540 ,
+     	                  566 ,592 ,620 ,649 ,680 ,712 ,746 ,781 ,818 ,856 ,
+     	                  896 ,939 ,983 ,1029,1078,1182,1237,1237,1296,1357,
+     	                  1708,2150,2707,3408,4291,5402,6800,8561,10778,13568,
+     	                  16312,17081,18081,19081,65536};
+     int SNR_dB_table[56] = {360,350,340,330,320,310,300,290,280,270,260,
+     	                     250,240,230,220,210,200,190,180,170,160,
+     	                     158,156,154,152,150,148,146,144,142,140,
+     	                     138,136,134,132,130,128,126,124,122,120,
+     	                     110,100,90 ,80 ,70 ,60 ,50 ,40 ,30 ,20 ,
+     	                     12 ,10 ,4  ,2  ,0  };
+
+     int tmp[3];
+     int cr;
+     int ck;
+     int SM;
+     int tni;
+	 int ber;
+	 int per;
+
+     int cnt;
+     cnt = 0;
+	 ber=0;
+	 per=0;
+
+//     g_demod_mode    = 2;
+     tni             =  atsc_read_reg((0x08)>>16);
+//	 g_demod_mode    = 4;
+     tmp[0]          =  atsc_read_reg(0x0511);
+     tmp[1]          =  atsc_read_reg(0x0512);
+     SNR             =  (tmp[0]<<8) + tmp[1];
+     SNR_dB          = SNR_dB_table[find_2(SNR,SNR_table,56)];
+
+     tmp[0]          =  atsc_read_reg(0x0780);
+     tmp[1]          =  atsc_read_reg(0x0781);
+     tmp[2]          =  atsc_read_reg(0x0782);
+     cr              =  tmp[0]+ (tmp[1]<<8) + (tmp[2]<<16);
+     tmp[0]          =  atsc_read_reg(0x0786);
+     tmp[1]          =  atsc_read_reg(0x0787);
+     tmp[2]          =  atsc_read_reg(0x0788);
+     ck              =  (tmp[0]<<16) + (tmp[1]<<8) + tmp[2];
+     ck              =  (ck > 8388608)? ck - 16777216:ck;
+     SM              =  atsc_read_reg(0x0980);
+//ber per
+	atsc_write_reg(0x0601,atsc_read_reg(0x0601)&(~(1<<3)));
+	atsc_write_reg(0x0601,atsc_read_reg(0x0601)|(1<<3));
+	ber=atsc_read_reg(0x0683)+(atsc_read_reg(0x0682)<<8);
+	per=atsc_read_reg(0x0685)+(atsc_read_reg(0x0684)<<8);
+
+//	read_atsc_all_reg();
+
+     pr_dbg("INT %x SNR %x SNRdB %d.%d FSM %x cr %d ck %d,ber is %d, per is %d\n"
+         ,tni
+         ,SNR
+         ,(SNR_dB/10)
+         ,(SNR_dB-(SNR_dB/10)*10)
+         ,SM
+         ,cr
+         ,ck
+         ,ber
+         ,per
+					);
+     atsc_snr=(SNR_dB/10);
+     return atsc_snr;
+
+
+
+ /*   unsigned long sm,snr1,snr2,snr;
+    static int fec_lock_cnt = 0;
+
+    delay_us(10000);
+    sm = atsc_read_reg(0x0980);
+    snr1 = atsc_read_reg(0x0511)&0xff;
+    snr2 = atsc_read_reg(0x0512)&0xff;
+    snr  = (snr1 << 8) + snr2;
+
+    printk(">>>>>>>>>>>>>>>>>>>>>>>>> OFDM FSM %x    SNR %x\n", sm&0xff, snr);
+
+    if (sm == 0x79) stimulus_finish_pass();*/
+}
diff --git a/drivers/amlogic/dvb_tv/amldemod/demod_func.h b/drivers/amlogic/dvb_tv/amldemod/demod_func.h
new file mode 100755
index 000000000000..99fd37f22727
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/demod_func.h
@@ -0,0 +1,2601 @@
+
+#ifdef DEMOD_FUNC_H
+#else
+#define DEMOD_FUNC_H
+
+#include <linux/types.h>
+#include <mach/am_regs.h>
+/*#include <mach/register.h>
+#include <mach/avosstyle_io.h>
+#include <mach/io.h>*/
+#include "aml_demod.h"
+#include "../aml_fe.h"
+#include "amlfrontend.h"
+
+
+//#define DEMOD_BASE     APB_REG_ADDR(0x20000)
+#define DEMOD_BASE APB_REG_ADDR(0x20000)
+
+//#define DEMOD_BASE 0xc8020000
+#define DTMB_BASE  (DEMOD_BASE+0x000)
+#define DVBT_BASE  (DEMOD_BASE+0x000)
+#define ISDBT_BASE (DEMOD_BASE+0x000)
+#define QAM_BASE   (DEMOD_BASE+0x400)
+#define ATSC_BASE  (DEMOD_BASE+0x800)
+#define DEMOD_CFG_BASE  (DEMOD_BASE+0xC00)
+
+#define ADC_REG1_VALUE		 0x003b0232
+#define ADC_REG2_VALUE		 0x814d3928
+#define ADC_REG3_VALUE		 0x6b425012
+#define ADC_REG4_VALUE		 0x101
+#define ADC_REG4_CRY_VALUE 0x301
+#define ADC_REG5_VALUE		 0x70b
+#define ADC_REG6_VALUE		 0x713
+
+#define ADC_REG1	 0x10aa
+#define ADC_REG2	 0x10ab
+#define ADC_REG3	 0x10ac
+#define ADC_REG4	 0x10ad
+#define ADC_REG5	 0x1073
+#define ADC_REG6	 0x1074
+
+
+#define DEMOD_REG1_VALUE		 0x0000d007
+#define DEMOD_REG2_VALUE		 0x2e805400
+#define DEMOD_REG3_VALUE		 0x201
+
+
+#define DEMOD_REG1		 0xc00
+#define DEMOD_REG2		 0xc04
+#define DEMOD_REG3		 0xc08
+
+
+
+#define Wr(addr, data)   WRITE_CBUS_REG(addr, data) /**(volatile unsigned long *)(0xc1100000|(addr<<2))=data*/
+#define Rd(addr)             READ_CBUS_REG(addr)            /**(volatile unsigned long *)(0xc1100000|(addr<<2))*/
+// i2c functions
+//int aml_i2c_sw_test_bus(struct aml_demod_i2c *adap, char *name);
+int am_demod_i2c_xfer(struct aml_demod_i2c *adap, struct i2c_msg *msgs, int num);
+int init_tuner_fj2207(struct aml_demod_sta *demod_sta,
+		      struct aml_demod_i2c *adap);
+int set_tuner_fj2207(struct aml_demod_sta *demod_sta,
+		     struct aml_demod_i2c *adap);
+
+int get_fj2207_ch_power(void);
+int tuner_get_ch_power(struct aml_fe_dev *adap);
+int tda18273_tuner_set_frequncy(unsigned int dwFrequency,unsigned int dwStandard);
+
+
+int tuner_set_ch (struct aml_demod_sta *demod_sta,
+		  struct aml_demod_i2c *demod_i2c);
+int demod_set_tuner(struct aml_demod_sta *demod_sta,
+		  struct aml_demod_i2c *demod_i2c,
+		  struct aml_tuner_sys *tuner_sys);
+
+
+//dvbt
+int dvbt_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbt *demod_dvbt);
+
+struct demod_status_ops {
+	int (*get_status)(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c);
+	int (*get_ber)(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c);
+	int (*get_snr)(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c);
+	int (*get_strength)(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c);
+	int (*get_ucblocks)(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c);
+};
+
+struct demod_status_ops* dvbt_get_status_ops(void);
+
+//dvbc
+
+int dvbc_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbc *demod_dvbc);
+int dvbc_status(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_sts *demod_sts);
+int dvbc_isr_islock(void);
+void dvbc_isr(struct aml_demod_sta *demod_sta);
+u32 dvbc_set_qam_mode(unsigned char mode);
+u32 dvbc_get_status(void);
+u32 dvbc_set_auto_symtrack(void);
+
+
+
+//atsc
+
+int atsc_set_ch(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c,
+			struct aml_demod_atsc *demod_atsc);
+int check_atsc_fsm_status(void);
+
+void atsc_write_reg(int reg_addr, int reg_data);
+
+unsigned long atsc_read_reg(int reg_addr);
+
+unsigned long atsc_read_iqr_reg(void);
+
+int atsc_qam_set(fe_modulation_t mode);
+
+
+void qam_initial(int qam_id) ;
+
+
+//dtmb
+
+int dtmb_set_ch(struct aml_demod_sta *demod_sta,
+			struct aml_demod_i2c *demod_i2c,
+			struct aml_demod_dtmb *demod_atsc);
+
+void dtmb_reset(void);
+
+int dtmb_read_snr(void);
+
+void dtmb_write_reg(int reg_addr, int reg_data);
+long dtmb_read_reg(int reg_addr);
+void dtmb_register_reset(void);
+
+
+
+
+
+
+
+// demod functions
+void apb_write_reg(int reg, int val);
+unsigned long  apb_read_reg (int reg);
+int app_apb_write_reg(int addr,int data);
+int app_apb_read_reg(int addr);
+
+void demod_set_cbus_reg(int data, int addr);
+unsigned long demod_read_cbus_reg(int addr);
+void demod_set_demod_reg(unsigned long data, unsigned long addr);
+unsigned long demod_read_demod_reg(unsigned long addr);
+
+
+
+
+
+
+
+
+
+
+
+
+void ofdm_initial(
+    int bandwidth, // 00:8M 01:7M 10:6M 11:5M
+    int samplerate,// 00:45M 01:20.8333M 10:20.7M 11:28.57
+    int IF,        // 000:36.13M 001:-5.5M 010:4.57M 011:4M 100:5M
+    int mode,       // 00:DVBT,01:ISDBT
+    int tc_mode     // 0: Unsigned, 1:TC
+) ;
+
+void monitor_isdbt(void);
+void demod_set_reg(struct aml_demod_reg *demod_reg);
+void demod_get_reg(struct aml_demod_reg *demod_reg);
+
+
+//void demod_calc_clk(struct aml_demod_sta *demod_sta);
+int demod_set_sys(struct aml_demod_sta *demod_sta,
+		  struct aml_demod_i2c *demod_i2c,
+		  struct aml_demod_sys *demod_sys);
+//int demod_get_sys(struct aml_demod_i2c *demod_i2c,
+//		  struct aml_demod_sys *demod_sys);
+//int dvbt_set_ch(struct aml_demod_sta *demod_sta,
+//		struct aml_demod_i2c *demod_i2c,
+//		struct aml_demod_dvbt *demod_dvbt);
+//int tuner_set_ch (struct aml_demod_sta *demod_sta,
+//		  struct aml_demod_i2c *demod_i2c);
+
+//typedef char               int8_t;
+//typedef short int          int16_t;
+//typedef int                int32_t;
+//typedef long               int64_t;
+/*typedef unsigned char      uint8_t;
+typedef unsigned short int uint16_t;
+typedef unsigned int       uint32_t;
+typedef unsigned long      uint64_t;*/
+
+/*typedef unsigned   char    u8_t;
+typedef signed     char    s8_t;
+typedef unsigned   short   u16_t;
+typedef signed     short   s16_t;
+typedef unsigned   int     u32_t;
+typedef signed     int     s32_t;
+typedef unsigned   long    u64_t;
+typedef signed     long    s64_t;*/
+
+
+//#define extadc
+
+
+typedef union demod_dig_clk {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned demod_clk_div:7;
+        unsigned reserved0:1;
+        unsigned demod_clk_en:1;
+        unsigned demod_clk_sel:2;
+        unsigned reserved1:5;
+        unsigned adc_extclk_div:7;  // 34
+        unsigned use_adc_extclk:1;   // 1
+        unsigned adc_extclk_en:1;   //  1
+        unsigned adc_extclk_sel:3;    //   1
+        unsigned reserved2:4;
+    } b;
+} demod_dig_clk_t;
+
+typedef union demod_adc_clk {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned pll_m:9;
+        unsigned pll_n:5;
+        unsigned pll_od:2;
+        unsigned pll_xd:5;
+        unsigned reserved0:3;
+        unsigned pll_ss_clk:4;
+        unsigned pll_ss_en:1;
+        unsigned reset:1;
+        unsigned pll_pd:1;
+        unsigned reserved1:1;
+    } b;
+} demod_adc_clk_t;
+
+typedef struct demod_cfg_regs {
+    volatile uint32_t cfg0;
+    volatile uint32_t cfg1;
+    volatile uint32_t cfg2;
+    volatile uint32_t cfg3;
+    volatile uint32_t info0;
+    volatile uint32_t info1;
+} demod_cfg_regs_t;
+
+typedef union demod_cfg0 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned mode:4;
+        unsigned ts_sel:4;
+        unsigned test_bus_clk:1;
+        unsigned adc_ext:1;
+        unsigned adc_rvs:1;
+        unsigned adc_swap:1;
+        unsigned adc_format:1;
+        unsigned adc_regout:1;
+        unsigned adc_regsel:1;
+        unsigned adc_regadj:5;
+        unsigned adc_value:10;
+        unsigned adc_test:1;
+        unsigned ddr_sel:1;
+    } b;
+} demod_cfg0_t;
+
+typedef union demod_cfg1 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved:8;
+        unsigned ref_top:2;
+        unsigned ref_bot:2;
+        unsigned cml_xs:2;
+        unsigned cml_1s:2;
+        unsigned vdda_sel:2;
+        unsigned bias_sel_sha:2;
+        unsigned bias_sel_mdac2:2;
+        unsigned bias_sel_mdac1:2;
+        unsigned fast_chg:1;
+        unsigned rin_sel:3;
+        unsigned en_ext_vbg:1;
+        unsigned en_cmlgen_res:1;
+        unsigned en_ext_vdd12:1;
+        unsigned en_ext_ref:1;
+    } b;
+} demod_cfg1_t;
+
+typedef union demod_cfg2 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned en_adc:1;
+        unsigned biasgen_ibipt_sel:2;
+        unsigned biasgen_ibic_sel:2;
+        unsigned biasgen_rsv:4;
+        unsigned biasgen_en:1;
+        unsigned biasgen_bias_sel_adc:2;
+        unsigned biasgen_bias_sel_cml1:2;
+        unsigned biasgen_bias_sel_ref_op:2;
+        unsigned clk_phase_sel:1;
+        unsigned reserved:15;
+    } b;
+} demod_cfg2_t;
+
+typedef union demod_cfg3 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned dc_arb_mask:3;
+        unsigned dc_arb_enable:1;
+        unsigned reserved:28;
+    } b;
+} demod_cfg3_t;
+
+typedef struct dtmb_cfg_regs {
+    volatile uint32_t dtmb_cfg_00;
+    volatile uint32_t dtmb_cfg_01;
+    volatile uint32_t dtmb_cfg_02;
+    volatile uint32_t dtmb_cfg_03;
+    volatile uint32_t dtmb_cfg_04;
+    volatile uint32_t dtmb_cfg_05;
+    volatile uint32_t dtmb_cfg_06;
+    volatile uint32_t dtmb_cfg_07;
+    volatile uint32_t dtmb_cfg_08;
+    volatile uint32_t dtmb_cfg_09;
+    volatile uint32_t dtmb_cfg_0a;
+    volatile uint32_t dtmb_cfg_0b;
+    volatile uint32_t dtmb_cfg_0c;
+    volatile uint32_t dtmb_cfg_0d;
+    volatile uint32_t dtmb_cfg_0e;
+    volatile uint32_t dtmb_cfg_0f;
+    volatile uint32_t dtmb_cfg_10;
+    volatile uint32_t dtmb_cfg_11;
+    volatile uint32_t dtmb_cfg_12;
+    volatile uint32_t dtmb_cfg_13;
+    volatile uint32_t dtmb_cfg_14;
+    volatile uint32_t dtmb_cfg_15;
+    volatile uint32_t dtmb_cfg_16;
+    volatile uint32_t dtmb_cfg_17;
+    volatile uint32_t dtmb_cfg_18;
+    volatile uint32_t dtmb_cfg_19;
+    volatile uint32_t dtmb_cfg_1a;
+    volatile uint32_t dtmb_cfg_1b;
+    volatile uint32_t dtmb_cfg_1c;
+    volatile uint32_t dtmb_cfg_1d;
+    volatile uint32_t dtmb_cfg_1e;
+    volatile uint32_t dtmb_cfg_1f;
+    volatile uint32_t dtmb_cfg_20;
+    volatile uint32_t dtmb_cfg_21;
+    volatile uint32_t dtmb_cfg_22;
+    volatile uint32_t dtmb_cfg_23;
+    volatile uint32_t dtmb_cfg_24;
+    volatile uint32_t dtmb_cfg_25;
+    volatile uint32_t dtmb_cfg_26;
+    volatile uint32_t dtmb_cfg_27;
+    volatile uint32_t dtmb_cfg_28;
+    volatile uint32_t dtmb_cfg_29;
+    volatile uint32_t dtmb_cfg_2a;
+    volatile uint32_t dtmb_cfg_2b;
+    volatile uint32_t dtmb_cfg_2c;
+    volatile uint32_t dtmb_cfg_2d;
+    volatile uint32_t dtmb_cfg_2e;
+    volatile uint32_t dtmb_cfg_2f;
+    volatile uint32_t dtmb_cfg_30;
+    volatile uint32_t dtmb_cfg_31;
+    volatile uint32_t dtmb_cfg_32;
+    volatile uint32_t dtmb_cfg_33;
+    volatile uint32_t dtmb_cfg_34;
+    volatile uint32_t dtmb_cfg_35;
+    volatile uint32_t dtmb_cfg_36;
+    volatile uint32_t dtmb_cfg_37;
+    volatile uint32_t dtmb_cfg_38;
+    volatile uint32_t dtmb_cfg_39;
+    volatile uint32_t dtmb_cfg_3a;
+    volatile uint32_t dtmb_cfg_3b;
+    volatile uint32_t dtmb_cfg_3c;
+    volatile uint32_t dtmb_cfg_3d;
+    volatile uint32_t dtmb_cfg_3e;
+    volatile uint32_t dtmb_cfg_3f;
+    volatile uint32_t dtmb_cfg_40;
+    volatile uint32_t dtmb_cfg_41;
+    volatile uint32_t dtmb_cfg_42;
+    volatile uint32_t dtmb_cfg_43;
+    volatile uint32_t dtmb_cfg_44;
+    volatile uint32_t dtmb_cfg_45;
+    volatile uint32_t dtmb_cfg_46;
+    volatile uint32_t dtmb_cfg_47;
+    volatile uint32_t dtmb_cfg_48;
+    volatile uint32_t dtmb_cfg_49;
+    volatile uint32_t dtmb_cfg_4a;
+    volatile uint32_t dtmb_cfg_4b;
+    volatile uint32_t dtmb_cfg_4c;
+    volatile uint32_t dtmb_cfg_4d;
+    volatile uint32_t dtmb_cfg_4e;
+    volatile uint32_t dtmb_cfg_4f;
+    volatile uint32_t dtmb_cfg_50;
+    volatile uint32_t dtmb_cfg_51;
+    volatile uint32_t dtmb_cfg_52;
+    volatile uint32_t dtmb_cfg_53;
+    volatile uint32_t dtmb_cfg_54;
+    volatile uint32_t dtmb_cfg_55;
+    volatile uint32_t dtmb_cfg_56;
+    volatile uint32_t dtmb_cfg_57;
+    volatile uint32_t dtmb_cfg_58;
+    volatile uint32_t dtmb_cfg_59;
+    volatile uint32_t dtmb_cfg_5a;
+    volatile uint32_t dtmb_cfg_5b;
+    volatile uint32_t dtmb_cfg_5c;
+    volatile uint32_t dtmb_cfg_5d;
+    volatile uint32_t dtmb_cfg_5e;
+    volatile uint32_t dtmb_cfg_5f;
+    volatile uint32_t dtmb_cfg_60;
+    volatile uint32_t dtmb_cfg_61;
+    volatile uint32_t dtmb_cfg_62;
+    volatile uint32_t dtmb_cfg_63;
+    volatile uint32_t dtmb_cfg_64;
+    //volatile uint32_t dtmb_cfg_65;
+    //volatile uint32_t dtmb_cfg_66;
+    //volatile uint32_t dtmb_cfg_67;
+    //volatile uint32_t dtmb_cfg_68;
+    //volatile uint32_t dtmb_cfg_69;
+    //volatile uint32_t dtmb_cfg_6a;
+    //volatile uint32_t dtmb_cfg_6b;
+    //volatile uint32_t dtmb_cfg_6c;
+    //volatile uint32_t dtmb_cfg_6d;
+    //volatile uint32_t dtmb_cfg_6e;
+    //volatile uint32_t dtmb_cfg_6f;
+    //volatile uint32_t dtmb_cfg_70;
+    //volatile uint32_t dtmb_cfg_71;
+    //volatile uint32_t dtmb_cfg_72;
+    //volatile uint32_t dtmb_cfg_73;
+    //volatile uint32_t dtmb_cfg_74;
+    //volatile uint32_t dtmb_cfg_75;
+    //volatile uint32_t dtmb_cfg_76;
+    //volatile uint32_t dtmb_cfg_77;
+    //volatile uint32_t dtmb_cfg_78;
+    //volatile uint32_t dtmb_cfg_79;
+    //volatile uint32_t dtmb_cfg_7a;
+    //volatile uint32_t dtmb_cfg_7b;
+    //volatile uint32_t dtmb_cfg_7c;
+    //volatile uint32_t dtmb_cfg_7d;
+    //volatile uint32_t dtmb_cfg_7e;
+    //volatile uint32_t dtmb_cfg_7f;
+    //volatile uint32_t dtmb_cfg_80;
+    //volatile uint32_t dtmb_cfg_81;
+    //volatile uint32_t dtmb_cfg_82;
+    //volatile uint32_t dtmb_cfg_83;
+    //volatile uint32_t dtmb_cfg_84;
+    //volatile uint32_t dtmb_cfg_85;
+    //volatile uint32_t dtmb_cfg_86;
+    //volatile uint32_t dtmb_cfg_87;
+    //volatile uint32_t dtmb_cfg_88;
+    //volatile uint32_t dtmb_cfg_89;
+    //volatile uint32_t dtmb_cfg_8a;
+    //volatile uint32_t dtmb_cfg_8b;
+    //volatile uint32_t dtmb_cfg_8c;
+    //volatile uint32_t dtmb_cfg_8d;
+    //volatile uint32_t dtmb_cfg_8e;
+    //volatile uint32_t dtmb_cfg_8f;
+    //volatile uint32_t dtmb_cfg_90;
+    //volatile uint32_t dtmb_cfg_91;
+    //volatile uint32_t dtmb_cfg_92;
+    //volatile uint32_t dtmb_cfg_93;
+    //volatile uint32_t dtmb_cfg_94;
+    //volatile uint32_t dtmb_cfg_95;
+    //volatile uint32_t dtmb_cfg_96;
+    //volatile uint32_t dtmb_cfg_97;
+    //volatile uint32_t dtmb_cfg_98;
+    //volatile uint32_t dtmb_cfg_99;
+    //volatile uint32_t dtmb_cfg_9a;
+    //volatile uint32_t dtmb_cfg_9b;
+    //volatile uint32_t dtmb_cfg_9c;
+    //volatile uint32_t dtmb_cfg_9d;
+    //volatile uint32_t dtmb_cfg_9e;
+    //volatile uint32_t dtmb_cfg_9f;
+} dtmb_cfg_regs_t;
+
+typedef union dtmb_cfg_00 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved0:32;
+    } b;
+} dtmb_cfg_00_t;
+
+typedef union dtmb_cfg_01 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ctrl_sw_rst:1;
+        unsigned reserved0:31;
+    } b;
+} dtmb_cfg_01_t;
+
+typedef union dtmb_cfg_02 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned testbus_addr:16;
+        unsigned testbus_en:1;
+        unsigned reserved0:15;
+    } b;
+} dtmb_cfg_02_t;
+
+typedef union dtmb_cfg_03 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tb_act_width:5;
+        unsigned reserved0:3;
+        unsigned tb_dc_mk:3;
+        unsigned reserved1:1;
+        unsigned tb_capture_stop:1;
+        unsigned tb_self_test:1;
+        unsigned reserved2:18;
+    } b;
+} dtmb_cfg_03_t;
+
+typedef union dtmb_cfg_04 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tb_v:32;
+    } b;
+} dtmb_cfg_04_t;
+
+typedef union dtmb_cfg_05 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tb_addr_begin:32;
+    } b;
+} dtmb_cfg_05_t;
+
+typedef union dtmb_cfg_06 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tb_addr_end:32;
+    } b;
+} dtmb_cfg_06_t;
+
+typedef union dtmb_cfg_07 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ctrl_fsm_enable:1;
+        unsigned ctrl_afifo_enable:1;
+        unsigned ctrl_agc_enable:1;
+        unsigned ctrl_ddc_enable:1;
+        unsigned ctrl_dc_enable:1;
+        unsigned ctrl_acf_enable:1;
+        unsigned ctrl_src_enable:1;
+        unsigned ctrl_dagc_enable:1;
+        unsigned ctrl_sfifo_enable:1;
+        unsigned ctrl_iqib_enable:1;
+        unsigned ctrl_cci_enable:1;
+        unsigned ctrl_fft2048_enable:1;
+        unsigned ctrl_ts_enable:1;
+        unsigned ctrl_corr_enable:1;
+        unsigned ctrl_fe_enable:1;
+        unsigned ctrl_fft512_enable:1;
+        unsigned ctrl_pnphase_enable:1;
+        unsigned ctrl_sfo_enable:1;
+        unsigned ctrl_pm_enable:1;
+        unsigned ctrl_che_enable:1;
+        unsigned ctrl_fec_enable:1;
+        unsigned ctrl_tps_enable:1;
+        unsigned reserved0:10;
+    } b;
+} dtmb_cfg_07_t;
+
+typedef union dtmb_cfg_08 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ctrl_src_pnphase_loop:1;
+        unsigned ctrl_src_sfo_loop:1;
+        unsigned ctrl_ddc_fcfo_loop:1;
+        unsigned ctrl_ddc_icfo_loop:1;
+        unsigned reserved0:28;
+    } b;
+} dtmb_cfg_08_t;
+
+typedef union dtmb_cfg_09 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ctrl_fsm_state:5;
+        unsigned reserved0:3;
+        unsigned ctrl_fsm_v:1;
+        unsigned reserved1:23;
+    } b;
+} dtmb_cfg_09_t;
+
+typedef union dtmb_cfg_0a {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ctrl_fast_agc:1;
+        unsigned ctrl_agc_bypass:1;
+        unsigned ctrl_pm_hold:1;
+        unsigned reserved0:29;
+    } b;
+} dtmb_cfg_0a_t;
+
+typedef union dtmb_cfg_0b {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ctrl_ts_q:10;
+        unsigned reserved0:2;
+        unsigned ctrl_pnphase_q:7;
+        unsigned reserved1:1;
+        unsigned ctrl_sfo_q:4;
+        unsigned ctrl_cfo_q:8;
+    } b;
+} dtmb_cfg_0b_t;
+
+typedef union dtmb_cfg_0c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ctrl_agc_to_th:8;
+        unsigned ctrl_ts_to_th:4;
+        unsigned ctrl_pnphase_to_th:4;
+        unsigned ctrl_sfo_to_th:4;
+        unsigned ctrl_fe_to_th:4;
+        unsigned reserved0:8;
+    } b;
+} dtmb_cfg_0c_t;
+
+typedef union dtmb_cfg_0d {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved0:32;
+    } b;
+} dtmb_cfg_0d_t;
+
+typedef union dtmb_cfg_0e {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved0:32;
+    } b;
+} dtmb_cfg_0e_t;
+
+typedef union dtmb_cfg_0f {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved0:32;
+    } b;
+} dtmb_cfg_0f_t;
+
+typedef union dtmb_cfg_10 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned afifo_nco_rate:8;
+        unsigned afifo_data_format:1;
+        unsigned afifo_bypass:1;
+        unsigned reserved0:22;
+    } b;
+} dtmb_cfg_10_t;
+
+typedef union dtmb_cfg_11 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned agc_target:4;
+        unsigned agc_cal_intv:2;
+        unsigned reserved0:2;
+        unsigned agc_gain_step2:6;
+        unsigned reserved1:2;
+        unsigned agc_gain_step1:6;
+        unsigned reserved2:2;
+        unsigned agc_a_filter_coef2:3;
+        unsigned reserved3:1;
+        unsigned agc_a_filter_coef1:3;
+        unsigned reserved4:1;
+    } b;
+} dtmb_cfg_11_t;
+
+typedef union dtmb_cfg_12 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned agc_imp_thresh:4;
+        unsigned agc_imp_en:1;
+        unsigned agc_iq_exchange:1;
+        unsigned reserved0:2;
+        unsigned agc_clip_ratio:5;
+        unsigned reserved1:3;
+        unsigned agc_signal_clip_thr:6;
+        unsigned reserved2:2;
+        unsigned agc_sd_rate:7;
+        unsigned reserved3:1;
+    } b;
+} dtmb_cfg_12_t;
+
+typedef union dtmb_cfg_13 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned agc_rffb_value:11;
+        unsigned reserved0:1;
+        unsigned agc_iffb_value:11;
+        unsigned reserved1:1;
+        unsigned agc_gain_step_rf:1;
+        unsigned agc_rfgain_freeze:1;
+        unsigned agc_tuning_slope:1;
+        unsigned agc_rffb_set:1;
+        unsigned agc_gain_step_if:1;
+        unsigned agc_ifgain_freeze:1;
+        unsigned agc_if_only:1;
+        unsigned agc_iffb_set:1;
+    } b;
+} dtmb_cfg_13_t;
+
+typedef union dtmb_cfg_14 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned agc_rffb_gain_sat_i:8;
+        unsigned agc_rffb_gain_sat:8;
+        unsigned agc_iffb_gain_sat_i:8;
+        unsigned agc_iffb_gain_sat:8;
+    } b;
+} dtmb_cfg_14_t;
+
+typedef union dtmb_cfg_15 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ddc_phase:15;
+        unsigned reserved0:17;
+    } b;
+} dtmb_cfg_15_t;
+
+typedef union dtmb_cfg_16 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ddc_delta_phase:25;
+        unsigned reserved0:3;
+        unsigned ddc_feedback_clear:1;
+        unsigned reserved1:3;
+    } b;
+} dtmb_cfg_16_t;
+
+typedef union dtmb_cfg_17 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ddc_bypass:1;
+        unsigned reserved0:31;
+    } b;
+} dtmb_cfg_17_t;
+
+typedef union dtmb_cfg_18 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned dc_hold:1;
+        unsigned dc_set_val:1;
+        unsigned dc_alpha:2;
+        unsigned reserved0:28;
+    } b;
+} dtmb_cfg_18_t;
+
+typedef union dtmb_cfg_19 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned dc_set_avg_q:16;
+        unsigned dc_set_avg_i:16;
+    } b;
+} dtmb_cfg_19_t;
+
+typedef union dtmb_cfg_1a {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef65:11;
+        unsigned reserved0:1;
+        unsigned coef66:11;
+        unsigned reserved1:1;
+        unsigned acf_bypass:1;
+        unsigned reserved2:7;
+    } b;
+} dtmb_cfg_1a_t;
+
+typedef union dtmb_cfg_1b {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef63:11;
+        unsigned reserved0:1;
+        unsigned coef64:11;
+        unsigned reserved1:9;
+    } b;
+} dtmb_cfg_1b_t;
+
+typedef union dtmb_cfg_1c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef62:10;
+        unsigned reserved0:22;
+    } b;
+} dtmb_cfg_1c_t;
+
+typedef union dtmb_cfg_1d {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef60:10;
+        unsigned reserved0:2;
+        unsigned coef61:10;
+        unsigned reserved1:10;
+    } b;
+} dtmb_cfg_1d_t;
+
+typedef union dtmb_cfg_1e {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef59:9;
+        unsigned reserved0:23;
+    } b;
+} dtmb_cfg_1e_t;
+
+typedef union dtmb_cfg_1f {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef57:9;
+        unsigned reserved0:3;
+        unsigned coef58:9;
+        unsigned reserved1:11;
+    } b;
+} dtmb_cfg_1f_t;
+
+typedef union dtmb_cfg_20 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef54:8;
+        unsigned coef55:8;
+        unsigned coef56:8;
+        unsigned reserved0:8;
+    } b;
+} dtmb_cfg_20_t;
+
+typedef union dtmb_cfg_21 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef53:7;
+        unsigned reserved0:25;
+    } b;
+} dtmb_cfg_21_t;
+
+typedef union dtmb_cfg_22 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef49:7;
+        unsigned reserved0:1;
+        unsigned coef50:7;
+        unsigned reserved1:1;
+        unsigned coef51:7;
+        unsigned reserved2:1;
+        unsigned coef52:7;
+        unsigned reserved3:1;
+    } b;
+} dtmb_cfg_22_t;
+
+typedef union dtmb_cfg_23 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef45:7;
+        unsigned reserved0:1;
+        unsigned coef46:7;
+        unsigned reserved1:1;
+        unsigned coef47:7;
+        unsigned reserved2:1;
+        unsigned coef48:7;
+        unsigned reserved3:1;
+    } b;
+} dtmb_cfg_23_t;
+
+typedef union dtmb_cfg_24 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef42:6;
+        unsigned reserved0:2;
+        unsigned coef43:6;
+        unsigned reserved1:2;
+        unsigned coef44:6;
+        unsigned reserved2:10;
+    } b;
+} dtmb_cfg_24_t;
+
+typedef union dtmb_cfg_25 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef38:6;
+        unsigned reserved0:2;
+        unsigned coef39:6;
+        unsigned reserved1:2;
+        unsigned coef40:6;
+        unsigned reserved2:2;
+        unsigned coef41:6;
+        unsigned reserved3:2;
+    } b;
+} dtmb_cfg_25_t;
+
+typedef union dtmb_cfg_26 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef34:6;
+        unsigned reserved0:2;
+        unsigned coef35:6;
+        unsigned reserved1:2;
+        unsigned coef36:6;
+        unsigned reserved2:2;
+        unsigned coef37:6;
+        unsigned reserved3:2;
+    } b;
+} dtmb_cfg_26_t;
+
+typedef union dtmb_cfg_27 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef30:6;
+        unsigned reserved0:2;
+        unsigned coef31:6;
+        unsigned reserved1:2;
+        unsigned coef32:6;
+        unsigned reserved2:2;
+        unsigned coef33:6;
+        unsigned reserved3:2;
+    } b;
+} dtmb_cfg_27_t;
+
+typedef union dtmb_cfg_28 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef27:5;
+        unsigned reserved0:3;
+        unsigned coef28:5;
+        unsigned reserved1:3;
+        unsigned coef29:5;
+        unsigned reserved2:11;
+    } b;
+} dtmb_cfg_28_t;
+
+typedef union dtmb_cfg_29 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef23:5;
+        unsigned reserved0:3;
+        unsigned coef24:5;
+        unsigned reserved1:3;
+        unsigned coef25:5;
+        unsigned reserved2:3;
+        unsigned coef26:5;
+        unsigned reserved3:3;
+    } b;
+} dtmb_cfg_29_t;
+
+typedef union dtmb_cfg_2a {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef19:5;
+        unsigned reserved0:3;
+        unsigned coef20:5;
+        unsigned reserved1:3;
+        unsigned coef21:5;
+        unsigned reserved2:3;
+        unsigned coef22:5;
+        unsigned reserved3:3;
+    } b;
+} dtmb_cfg_2a_t;
+
+typedef union dtmb_cfg_2b {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef15:5;
+        unsigned reserved0:3;
+        unsigned coef16:5;
+        unsigned reserved1:3;
+        unsigned coef17:5;
+        unsigned reserved2:3;
+        unsigned coef18:5;
+        unsigned reserved3:3;
+    } b;
+} dtmb_cfg_2b_t;
+
+typedef union dtmb_cfg_2c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef08:4;
+        unsigned coef09:4;
+        unsigned coef10:4;
+        unsigned coef11:4;
+        unsigned coef12:4;
+        unsigned coef13:4;
+        unsigned coef14:4;
+        unsigned reserved0:4;
+    } b;
+} dtmb_cfg_2c_t;
+
+typedef union dtmb_cfg_2d {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned coef00:4;
+        unsigned coef01:4;
+        unsigned coef02:4;
+        unsigned coef03:4;
+        unsigned coef04:4;
+        unsigned coef05:4;
+        unsigned coef06:4;
+        unsigned coef07:4;
+    } b;
+} dtmb_cfg_2d_t;
+
+typedef union dtmb_cfg_2e {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned src_norm_inrate:23;
+        unsigned reserved0:9;
+    } b;
+} dtmb_cfg_2e_t;
+
+typedef union dtmb_cfg_2f {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned src_init_phase:24;
+        unsigned src_init_ini:1;
+        unsigned reserved0:7;
+    } b;
+} dtmb_cfg_2f_t;
+
+typedef union dtmb_cfg_30 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sfifo_out_len:4;
+        unsigned reserved0:28;
+    } b;
+} dtmb_cfg_30_t;
+
+typedef union dtmb_cfg_31 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned dagc_target_pow_n:6;
+        unsigned reserved0:2;
+        unsigned dagc_target_pow_p:6;
+        unsigned reserved1:2;
+        unsigned dagc_gain_ctrl:8;
+        unsigned dagc_bw:3;
+        unsigned reserved2:1;
+        unsigned dagc_hold:1;
+        unsigned reserved3:3;
+    } b;
+} dtmb_cfg_31_t;
+
+typedef union dtmb_cfg_32 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned iqib_step_b:2;
+        unsigned iqib_step_a:2;
+        unsigned iqib_period:3;
+        unsigned reserved0:25;
+    } b;
+} dtmb_cfg_32_t;
+
+typedef union dtmb_cfg_33 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned iqib_set_b:12;
+        unsigned iqib_set_a:10;
+        unsigned reserved0:2;
+        unsigned iqib_set_val:1;
+        unsigned iqib_hold:1;
+        unsigned reserved1:6;
+    } b;
+} dtmb_cfg_33_t;
+
+typedef union dtmb_cfg_34 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned cci_rpsq_n:10;
+        unsigned reserved0:2;
+        unsigned cci_rp_n:13;
+        unsigned reserved1:3;
+        unsigned cci_det_en:1;
+        unsigned cci_bypass:1;
+        unsigned reserved2:2;
+    } b;
+} dtmb_cfg_34_t;
+
+typedef union dtmb_cfg_35 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned cci_avr_times:3;
+        unsigned reserved0:1;
+        unsigned cci_det_thres:3;
+        unsigned reserved1:25;
+    } b;
+} dtmb_cfg_35_t;
+
+typedef union dtmb_cfg_36 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned cci_notch1_a1:10;
+        unsigned reserved0:2;
+        unsigned cci_notch1_en:1;
+        unsigned reserved1:19;
+    } b;
+} dtmb_cfg_36_t;
+
+typedef union dtmb_cfg_37 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned cci_notch1_b1:10;
+        unsigned reserved0:2;
+        unsigned cci_notch1_a2:10;
+        unsigned reserved1:10;
+    } b;
+} dtmb_cfg_37_t;
+
+typedef union dtmb_cfg_38 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned cci_notch2_a1:10;
+        unsigned reserved0:2;
+        unsigned cci_notch2_en:1;
+        unsigned reserved1:3;
+        unsigned cci_mpthres:16;
+    } b;
+} dtmb_cfg_38_t;
+
+typedef union dtmb_cfg_39 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned cci_notch2_b1:10;
+        unsigned reserved0:2;
+        unsigned cci_notch2_a2:10;
+        unsigned reserved1:10;
+    } b;
+} dtmb_cfg_39_t;
+
+typedef union dtmb_cfg_3a {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ts_gain:2;
+        unsigned reserved0:2;
+        unsigned ts_sat_shift:3;
+        unsigned reserved1:1;
+        unsigned ts_fixpn_en:1;
+        unsigned ts_fixpn:2;
+        unsigned reserved2:21;
+    } b;
+} dtmb_cfg_3a_t;
+
+typedef union dtmb_cfg_3b {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned fe_lock_len:4;
+        unsigned fe_sat_shift:3;
+        unsigned reserved0:1;
+        unsigned fe_cut:4;
+        unsigned reserved1:4;
+        unsigned fe_modify:16;
+    } b;
+} dtmb_cfg_3b_t;
+
+typedef union dtmb_cfg_3c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned pnphase_offset2:4;
+        unsigned pnphase_offset1:4;
+        unsigned pnphase_offset0:4;
+        unsigned reserved0:20;
+    } b;
+} dtmb_cfg_3c_t;
+
+typedef union dtmb_cfg_3d {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned pnphase_gain:2;
+        unsigned reserved0:2;
+        unsigned pnphase_sat_shift:4;
+        unsigned pnphase_cut:4;
+        unsigned reserved1:4;
+        unsigned pnphase_modify:16;
+    } b;
+} dtmb_cfg_3d_t;
+
+typedef union dtmb_cfg_3e {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sfo_cfo_pn0_modify:16;
+        unsigned sfo_sfo_pn0_modify:16;
+    } b;
+} dtmb_cfg_3e_t;
+
+typedef union dtmb_cfg_3f {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sfo_cfo_pn1_modify:16;
+        unsigned sfo_sfo_pn1_modify:16;
+    } b;
+} dtmb_cfg_3f_t;
+
+typedef union dtmb_cfg_40 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sfo_cfo_pn2_modify:16;
+        unsigned sfo_sfo_pn2_modify:16;
+    } b;
+} dtmb_cfg_40_t;
+
+typedef union dtmb_cfg_41 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sfo_sat_shift:4;
+        unsigned sfo_gain:2;
+        unsigned sfo_timingoff_en:1;
+        unsigned sfo_timing_offset:1;
+        unsigned sfo_dist:2;
+        unsigned reserved0:2;
+        unsigned sfo_cfo_cut:4;
+        unsigned sfo_sfo_cut:4;
+        unsigned reserved1:12;
+    } b;
+} dtmb_cfg_41_t;
+
+typedef union dtmb_cfg_42 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned pm_gd_short_pst:5;
+        unsigned reserved0:3;
+        unsigned pm_gd_short_pre:5;
+        unsigned reserved1:3;
+        unsigned pm_gd_long_pst:6;
+        unsigned reserved2:2;
+        unsigned pm_gd_long_pre:6;
+        unsigned reserved3:2;
+    } b;
+} dtmb_cfg_42_t;
+
+typedef union dtmb_cfg_43 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned pm_big_offset:5;
+        unsigned reserved0:3;
+        unsigned pm_small_offset:5;
+        unsigned reserved1:3;
+        unsigned pm_big_shift:4;
+        unsigned pm_small_shift:4;
+        unsigned pm_noise_gain:3;
+        unsigned pm_select_gain:3;
+        unsigned pm_select_ch_gain:2;
+    } b;
+} dtmb_cfg_43_t;
+
+typedef union dtmb_cfg_44 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned pm_accu_times:4;
+        unsigned reserved0:28;
+    } b;
+} dtmb_cfg_44_t;
+
+typedef union dtmb_cfg_45 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tps_run_tim_limit:10;
+        unsigned reserved0:2;
+        unsigned tps_suc_limit:7;
+        unsigned reserved1:1;
+        unsigned tps_q_th:7;
+        unsigned reserved2:1;
+        unsigned tps_alpha:3;
+        unsigned reserved3:1;
+    } b;
+} dtmb_cfg_45_t;
+
+typedef union dtmb_cfg_46 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tps_known:1;
+        unsigned static_channel:1;
+        unsigned reserved0:2;
+        unsigned constell:2;
+        unsigned reserved1:2;
+        unsigned code_rate:2;
+        unsigned intlv_mode:1;
+        unsigned qam4_nr:1;
+        unsigned freq_reverse:1;
+        unsigned reserved2:19;
+    } b;
+} dtmb_cfg_46_t;
+
+typedef union dtmb_cfg_47 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ldpc_it_min:8;
+        unsigned ldpc_it_max:8;
+        unsigned ldpc_it_auto:1;
+        unsigned ldpc_it_dchk:1;
+        unsigned bch_off:1;
+        unsigned ts_clk_neg:1;
+        unsigned ts_fast:1;
+        unsigned dc_ugt:1;
+        unsigned sw_reset_freq_di:1;
+        unsigned sw_reset_4qam_nr:1;
+        unsigned sw_reset_time_di:1;
+        unsigned sw_reset_ldpc:1;
+        unsigned sw_reset_bch:1;
+        unsigned sw_reset_ber:1;
+        unsigned tbus_cfg:3;
+        unsigned fifo_base:1;
+    } b;
+} dtmb_cfg_47_t;
+
+typedef union dtmb_cfg_48 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned fec_debug_len:16;
+        unsigned fec_debug_mode:1;
+        unsigned fec_debug_on:1;
+        unsigned fec_lock_cfg:3;
+        unsigned fec_lost_cfg:3;
+        unsigned bad_to_zero:1;
+        unsigned fec_debug_spare:7;
+    } b;
+} dtmb_cfg_48_t;
+
+typedef union dtmb_cfg_49 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned data_ddr_adr:32;
+    } b;
+} dtmb_cfg_49_t;
+
+typedef union dtmb_cfg_4a {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned debug_ddr_adr:32;
+    } b;
+} dtmb_cfg_4a_t;
+
+typedef union dtmb_cfg_4b {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sim_dat_b0:6;
+        unsigned sim_dat_b1:6;
+        unsigned sim_dat_b2:6;
+        unsigned sim_dat_b3:6;
+        unsigned sim_dat_b4:6;
+        unsigned reserved:2;
+    } b;
+} dtmb_cfg_4b_t;
+
+typedef union dtmb_cfg_4c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sim_dat_b5:6;
+        unsigned sim_end:3;
+        unsigned sim_vld:1;
+        unsigned sim_head:1;
+        unsigned sim_ini:1;
+        unsigned sim_mode:1;
+        unsigned reserved:19;
+    } b;
+} dtmb_cfg_4c_t;
+
+typedef union dtmb_cfg_4d {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned che_eqin_f_mcci_thr:4;
+        unsigned che_ch_mh_thr      :12;
+        unsigned che_tune_thr       :4;
+        unsigned che_tune_cnt_thr   :12;
+    } b;
+} dtmb_cfg_4d_t;
+
+typedef union dtmb_cfg_4e {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned che_ch_noise_pow   :15;
+        unsigned che_ch_noise_pow_en:1;
+        unsigned che_up_noise_pow   :15;
+        unsigned che_up_noise_pow_en:1;
+    } b;
+} dtmb_cfg_4e_t;
+
+typedef union dtmb_cfg_4f {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned che_up_mh_thr:13;
+        unsigned reserved0    :3;
+        unsigned che_belta    :5;
+        unsigned che_belta_en :1;
+        unsigned reserved1    :2;
+        unsigned che_alpha    :5;
+        unsigned che_alpha_en :1;
+        unsigned reserved2    :2;
+    } b;
+} dtmb_cfg_4f_t;
+
+typedef union dtmb_cfg_50 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned che_clk_fcy_indx    :2;
+        unsigned che_iter_time_en    :1;
+        unsigned reserved0           :1;
+        unsigned che_iter_time_mobile:4;
+        unsigned che_iter_time_static:4;
+        unsigned bp_last_itera       :1;
+        unsigned reserved1           :19;
+    } b;
+} dtmb_cfg_50_t;
+
+typedef union dtmb_cfg_51 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned che_m_init_snr1:8;
+        unsigned che_m_init_snr2:8;
+        unsigned che_m_init_snr3:8;
+        unsigned che_m_init_snr4:8;
+    } b;
+} dtmb_cfg_51_t;
+
+typedef union dtmb_cfg_52 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned frame_mc_header_dly:16;
+        unsigned pn_mc_header_dly   :16;
+    } b;
+} dtmb_cfg_52_t;
+
+typedef union dtmb_cfg_53 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned frame_sc_header_dly:16;
+        unsigned pn_sc_header_dly   :16;
+    } b;
+} dtmb_cfg_53_t;
+
+typedef union dtmb_cfg_54 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned seg_bypass       :1;
+        unsigned seg_num_1seg_log2:3;
+        unsigned seg_alpha        :3;
+        unsigned seg_read_val     :1;
+        unsigned seg_read_addr    :12;
+        unsigned reserved         :12;
+    } b;
+} dtmb_cfg_54_t;
+
+typedef union dtmb_cfg_55 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_55_t;
+
+typedef union dtmb_cfg_56 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_56_t;
+
+typedef union dtmb_cfg_57 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_57_t;
+
+typedef union dtmb_cfg_58 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_58_t;
+
+typedef union dtmb_cfg_59 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_59_t;
+
+typedef union dtmb_cfg_5a {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_5a_t;
+
+typedef union dtmb_cfg_5b {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_5b_t;
+
+typedef union dtmb_cfg_5c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_5c_t;
+
+typedef union dtmb_cfg_5d {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_5d_t;
+
+typedef union dtmb_cfg_5e {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_5e_t;
+
+typedef union dtmb_cfg_5f {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_5f_t;
+
+typedef union dtmb_cfg_60 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_60_t;
+
+typedef union dtmb_cfg_61 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_61_t;
+
+typedef union dtmb_cfg_62 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_62_t;
+
+typedef union dtmb_cfg_63 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_63_t;
+
+typedef union dtmb_cfg_64 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved         :32;
+    } b;
+} dtmb_cfg_64_t;
+
+typedef struct dvbc_cfg_regs {
+    volatile uint32_t dvbc_cfg_00;
+    volatile uint32_t dvbc_cfg_04;
+    volatile uint32_t dvbc_cfg_08;
+    volatile uint32_t dvbc_cfg_0c;
+    volatile uint32_t dvbc_cfg_10;
+    volatile uint32_t dvbc_cfg_14;
+    volatile uint32_t dvbc_cfg_18;
+    volatile uint32_t dvbc_cfg_1c;
+    volatile uint32_t dvbc_cfg_20;
+    volatile uint32_t dvbc_cfg_24;
+    volatile uint32_t dvbc_cfg_28;
+    volatile uint32_t dvbc_cfg_2c;
+    volatile uint32_t dvbc_cfg_30;
+    volatile uint32_t dvbc_cfg_34;
+    volatile uint32_t dvbc_cfg_38;
+    volatile uint32_t dvbc_cfg_3c;
+    volatile uint32_t dvbc_cfg_40;
+    volatile uint32_t dvbc_cfg_44;
+    volatile uint32_t dvbc_cfg_48;
+    volatile uint32_t dvbc_cfg_4c;
+    volatile uint32_t dvbc_cfg_50;
+    volatile uint32_t dvbc_cfg_54;
+    volatile uint32_t dvbc_cfg_58;
+    volatile uint32_t dvbc_cfg_5c;
+    volatile uint32_t dvbc_cfg_60;
+    volatile uint32_t dvbc_cfg_64;
+    volatile uint32_t dvbc_cfg_68;
+    volatile uint32_t dvbc_cfg_6c;
+    volatile uint32_t dvbc_cfg_70;
+    volatile uint32_t dvbc_cfg_74;
+    volatile uint32_t dvbc_cfg_78;
+    volatile uint32_t dvbc_cfg_7c;
+    volatile uint32_t dvbc_cfg_80;
+    volatile uint32_t dvbc_cfg_84;
+    volatile uint32_t dvbc_cfg_88;
+    volatile uint32_t dvbc_cfg_8c;
+    volatile uint32_t dvbc_cfg_90;
+    volatile uint32_t dvbc_cfg_94;
+    volatile uint32_t dvbc_cfg_98;
+    volatile uint32_t dvbc_cfg_9c;
+    volatile uint32_t dvbc_cfg_a0;
+    volatile uint32_t dvbc_cfg_a4;
+    volatile uint32_t dvbc_cfg_a8;
+    volatile uint32_t dvbc_cfg_ac;
+    volatile uint32_t dvbc_cfg_b0;
+    volatile uint32_t dvbc_cfg_b4;
+    volatile uint32_t dvbc_cfg_b8;
+    volatile uint32_t dvbc_cfg_bc;
+    volatile uint32_t dvbc_cfg_c0;
+    volatile uint32_t dvbc_cfg_c4;
+    volatile uint32_t dvbc_cfg_c8;
+    volatile uint32_t dvbc_cfg_cc;
+    volatile uint32_t dvbc_cfg_d0;
+    volatile uint32_t dvbc_cfg_d4;
+    volatile uint32_t dvbc_cfg_d8;
+    volatile uint32_t dvbc_cfg_dc;
+    volatile uint32_t dvbc_cfg_e0;
+    volatile uint32_t dvbc_cfg_e4;
+    volatile uint32_t dvbc_cfg_e8;
+    volatile uint32_t dvbc_cfg_ec;
+} dvbc_cfg_regs_t;
+
+typedef union dvbc_cfg_00 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved:32;
+    } b;
+} dvbc_cfg_00_t;
+
+typedef union dvbc_cfg_04 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sw_qam_enable:1;
+        unsigned qam_imq_cfg:1;
+        unsigned reserved0:1;
+        unsigned nyq_bypass_cfg:1;
+        unsigned fsm_en:1;
+        unsigned fast_agc:1;
+        unsigned reserved1:2;
+        unsigned dc_enable:1;
+        unsigned dc_alpha:3;
+        unsigned not_used:20;
+    } b;
+} dvbc_cfg_04_t;
+
+typedef union dvbc_cfg_08 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned qam_mode_cfg:3;
+        unsigned qam_test_en:1;
+        unsigned qam_test_addr:5;
+        unsigned reserved:7;
+        unsigned hcap_en:1;
+        unsigned dvbc_topstate_ct1:3;
+        unsigned fsm_state_d:3;
+        unsigned fsm_state_v:1;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_08_t;
+
+typedef union dvbc_cfg_0c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned symb_cnt_cfg:16;
+        unsigned adc_cnt_cfg:16;
+    } b;
+} dvbc_cfg_0c_t;
+
+typedef union dvbc_cfg_10 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned rs_cnt_cfg:16;
+        unsigned afifo_nco_rate:8;
+        unsigned afifo_bypass:1;
+        unsigned not_used:7;
+    } b;
+} dvbc_cfg_10_t;
+
+typedef union dvbc_cfg_14 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_snr:12;
+        unsigned ber_before_rs:20;
+    } b;
+} dvbc_cfg_14_t;
+
+typedef union dvbc_cfg_18 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tst_sync:7;
+        unsigned not_used:9;
+        unsigned per_rs:16;
+    } b;
+} dvbc_cfg_18_t;
+
+typedef union dvbc_cfg_1c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_dov:1;
+        unsigned eq_doq:12;
+        unsigned eq_doi:12;
+        unsigned not_used:7;
+    } b;
+} dvbc_cfg_1c_t;
+
+typedef union dvbc_cfg_20 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned phs_reset_cfg:1;
+        unsigned tim_mu2_cfg_accurate:5;
+        unsigned tim_mu1_cfg_accurate:5;
+        unsigned tim_sync_cfg_accurate:4;
+        unsigned tim_trk_cfg_accurate:4;
+        unsigned tim_shr_cfg_accurate:4;
+        unsigned sw_tim_select:1;
+        unsigned phs_mu:4;
+        unsigned phs_track_enable:1;
+        unsigned phs_track_eqin_enable:1;
+        unsigned phs_track_in_smma:1;
+        unsigned not_used:1;
+    } b;
+} dvbc_cfg_20_t;
+
+typedef union dvbc_cfg_24 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned phs_offset_cfg:23;
+        unsigned tim_mu1_min:5;
+        unsigned tim_mu2_min:4;
+    } b;
+} dvbc_cfg_24_t;
+
+typedef union dvbc_cfg_28 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned phs_offset_act:23;
+        unsigned not_used:9;
+    } b;
+} dvbc_cfg_28_t;
+
+typedef union dvbc_cfg_2c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_max_frq_off:30;
+        unsigned not_used:2;
+    } b;
+} dvbc_cfg_2c_t;
+
+typedef union dvbc_cfg_30 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sw_tim_sweep_onoff_cfg:1;
+        unsigned tim_sweep_speed_cfg:5;
+        unsigned tim_mu2_cfg_coarse:5;
+        unsigned tim_mu1_cfg_coarse:5;
+        unsigned tim_sync_cfg_coarse:4;
+        unsigned tim_trk_cfg_coarse:4;
+        unsigned tim_shr_cfg_coarse:4;
+        unsigned tim_reset_cfg:1;
+        unsigned hw_fsm_ctrl:3;
+    } b;
+} dvbc_cfg_30_t;
+
+typedef union dvbc_cfg_34 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sw_symbol_rate:16;
+        unsigned sampling_rate:16;
+    } b;
+} dvbc_cfg_34_t;
+
+typedef union dvbc_cfg_38 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tim_sweep_range_cfg:24;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_38_t;
+
+typedef union dvbc_cfg_3c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned q_uneven_report:32;
+    } b;
+} dvbc_cfg_3c_t;
+
+typedef union dvbc_cfg_40 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sync_trk_cfg:4;
+        unsigned sync_acq_cfg:4;
+        unsigned sync_reset_cfg:1;
+        unsigned hw_symbol_rate_step:7;
+        unsigned not_used:16;
+    } b;
+} dvbc_cfg_40_t;
+
+typedef union dvbc_cfg_44 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ts_ctrl_cfg:4;
+        unsigned ts_serial_cfg:1;
+        unsigned reserved:3;
+        unsigned hw_symbol_rate_max:16;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_44_t;
+
+typedef union dvbc_cfg_48 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned ted_sel_cfg:3;
+        unsigned reserved:5;
+        unsigned hw_symbol_rate_min:16;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_48_t;
+
+typedef union dvbc_cfg_4c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_miu_test:8;
+        unsigned eq_q_uneven_cfg:8;
+        unsigned eq_extra_tag_conf:2;
+        unsigned not_used:14;
+    } b;
+} dvbc_cfg_4c_t;
+
+typedef union dvbc_cfg_50 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_seglen:3;
+        unsigned sw_eq_enable:1;
+        unsigned ted_disable:1;
+        unsigned hw_eq_dfe_disable:1;
+        unsigned reserved0:2;
+        unsigned eq_cfg_cr_shift_time:4;
+        unsigned input_state:12;
+        unsigned input_state_en:1;
+        unsigned reserved1:3;
+        unsigned sw_eq_smma_reset_ctrl:1;
+        unsigned reserved2:1;
+        unsigned not_used:2;
+    } b;
+} dvbc_cfg_50_t;
+
+typedef union dvbc_cfg_54 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_dfemiu2:4;
+        unsigned eq_cfg_dfemiu1:4;
+        unsigned eq_cfg_dfemiu0:4;
+        unsigned reserved:4;
+        unsigned eq_cfg_ffemiu2:4;
+        unsigned eq_cfg_ffemiu1:4;
+        unsigned eq_cfg_ffemiu0:4;
+        unsigned eq_cfg_firbeta1:2;
+        unsigned eq_cfg_firbeta0:2;
+    } b;
+} dvbc_cfg_54_t;
+
+typedef union dvbc_cfg_58 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_initpos1:6;
+        unsigned reserved0:2;
+        unsigned eq_cfg_initpos0:6;
+        unsigned reserved1:2;
+        unsigned eq_cfg_phstr_lp1:8;
+        unsigned eq_cfg_phstr_lp0:8;
+    } b;
+} dvbc_cfg_58_t;
+
+typedef union dvbc_cfg_5c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_initvalq0:10;
+        unsigned reserved:6;
+        unsigned eq_cfg_initvali0:10;
+        unsigned not_used:6;
+    } b;
+} dvbc_cfg_5c_t;
+
+typedef union dvbc_cfg_60 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_initvalq1:10;
+        unsigned reserved:6;
+        unsigned eq_cfg_initvali1:10;
+        unsigned not_used:6;
+    } b;
+} dvbc_cfg_60_t;
+
+typedef union dvbc_cfg_64 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_crth3tim:6;
+        unsigned reserved0:2;
+        unsigned eq_cfg_crth2tim:6;
+        unsigned reserved1:2;
+        unsigned eq_cfg_crth1:6;
+        unsigned reserved2:2;
+        unsigned eq_cfg_crth0:6;
+        unsigned not_used:2;
+    } b;
+} dvbc_cfg_64_t;
+
+typedef union dvbc_cfg_68 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_crth3snr:12;
+        unsigned reserved:4;
+        unsigned eq_cfg_crth2snr:12;
+        unsigned not_used:4;
+    } b;
+} dvbc_cfg_68_t;
+
+typedef union dvbc_cfg_6c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_crppmth2:6;
+        unsigned reserved0:2;
+        unsigned eq_cfg_crppmth1:7;
+        unsigned reserved1:1;
+        unsigned eq_cfg_crppmth0:5;
+        unsigned eq_cr_amp_th:11;
+    } b;
+} dvbc_cfg_6c_t;
+
+typedef union dvbc_cfg_70 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_crlpk2:2;
+        unsigned reserved:6;
+        unsigned eq_cfg_crlpk1:8;
+        unsigned eq_cfg_crlpk0_s:8;
+        unsigned eq_cfg_crlpk0:8;
+    } b;
+} dvbc_cfg_70_t;
+
+typedef union dvbc_cfg_74 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_mma2lms:12;
+        unsigned reserved:4;
+        unsigned eq_cfg_ddlms:12;
+        unsigned not_used:4;
+    } b;
+} dvbc_cfg_74_t;
+
+typedef union dvbc_cfg_78 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned adc_in:10;
+        unsigned reserved:22;
+    } b;
+} dvbc_cfg_78_t;
+
+typedef union dvbc_cfg_7c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_mma:12;
+        unsigned eq_cfg_norm:12;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_7c_t;
+
+typedef union dvbc_cfg_80 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_smma1:12;
+        unsigned eq_cfg_smma0:12;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_80_t;
+
+typedef union dvbc_cfg_84 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_smma3:12;
+        unsigned eq_cfg_smma2:12;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_84_t;
+
+typedef union dvbc_cfg_88 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_smma5:12;
+        unsigned eq_cfg_smma4:12;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_88_t;
+
+typedef union dvbc_cfg_8c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cfg_smma7:12;
+        unsigned eq_cfg_smma6:12;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_8c_t;
+
+typedef union dvbc_cfg_90 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_offset_cfg:11;
+        unsigned agc_gain_step1:6;
+        unsigned agc_gain_step2:6;
+        unsigned agc_a_filter_coef1:3;
+        unsigned agc_a_filter_coef2:3;
+        unsigned not_used:3;
+    } b;
+} dvbc_cfg_90_t;
+
+typedef union dvbc_cfg_94 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned agc_target:4;
+        unsigned agc_sd_rate:3;
+        unsigned agc_cal_intv:2;
+        unsigned agc_gain_step_if:1;
+        unsigned agc_ifgain_freeze:1;
+        unsigned agc_if_only:1;
+        unsigned agc_iffb_set:1;
+        unsigned agc_rfgain_freeze:1;
+        unsigned agc_tuning_slope:1;
+        unsigned agc_rffb_set:1;
+        unsigned iffb_gain_sat_i:8;
+        unsigned iffb_gain_sat:8;
+    } b;
+} dvbc_cfg_94_t;
+
+typedef union dvbc_cfg_98 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned agc_rffb_value:11;
+        unsigned agc_iffb_value:11;
+        unsigned rffb_gain_sat:8;
+        unsigned agc_gain_step_rf:1;
+        unsigned dagc_pow_det:1;
+    } b;
+} dvbc_cfg_98_t;
+
+typedef union dvbc_cfg_9c {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned agc_avg_power:9;
+        unsigned agc_rffb_gain:11;
+        unsigned agc_iffb_gain:11;
+        unsigned not_used:1;
+    } b;
+} dvbc_cfg_9c_t;
+
+typedef union dvbc_cfg_a0 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned dagc_gain_ctrl:7;
+        unsigned dagc_hold:1;
+        unsigned target_pow_p:6;
+        unsigned dagc_bw:3;
+        unsigned dagc_rstn:1;
+        unsigned rffb_gain_sat_i:8;
+        unsigned sw_agc_enable:1;
+        unsigned adc_format:1;
+        unsigned agc_da_sw:1;
+        unsigned agc_gain_rate:3;
+    } b;
+} dvbc_cfg_a0_t;
+
+typedef union dvbc_cfg_a4 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned dagc_gain_cnt:7;
+        unsigned dagc_state:1;
+        unsigned dagc_avg_pow:9;
+        unsigned agc_stable:1;
+        unsigned agc_in_target:1;
+        unsigned reserved0:1;
+        unsigned eq_state:4;
+        unsigned not_used:8;
+    } b;
+} dvbc_cfg_a4_t;
+
+typedef union dvbc_cfg_a8 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned cci1_b1:10;
+        unsigned cci1_a2:10;
+        unsigned cci1_a1:10;
+        unsigned reserved:1;
+        unsigned cci1_enable:1;
+    } b;
+} dvbc_cfg_a8_t;
+
+typedef union dvbc_cfg_ac {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned cci2_b1:10;
+        unsigned cci2_a2:10;
+        unsigned cci2_a1:10;
+        unsigned reserved:1;
+        unsigned cci2_enable:1;
+    } b;
+} dvbc_cfg_ac_t;
+
+typedef union dvbc_cfg_b0 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned test:32;
+    } b;
+} dvbc_cfg_b0_t;
+
+typedef union dvbc_cfg_b4 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_cr_angle:30;
+        unsigned not_used:2;
+    } b;
+} dvbc_cfg_b4_t;
+
+typedef union dvbc_cfg_b8 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned tim_acc_pc0:32;
+    } b;
+} dvbc_cfg_b8_t;
+
+typedef union dvbc_cfg_bc {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned reserved:32;
+    } b;
+} dvbc_cfg_bc_t;
+
+typedef union dvbc_cfg_c0 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned fec_lost_th:4;
+        unsigned eq_mma_th:4;
+        unsigned search_symbol_rate_th:4;
+        unsigned agc_stable_th:4;
+        unsigned fine_symbol_rate_th:4;
+        unsigned eq_smma_th:4;
+        unsigned fec_lost_th_smma:4;
+        unsigned reserved:4;
+    } b;
+} dvbc_cfg_c0_t;
+
+typedef union dvbc_cfg_c4 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned state_probe:32;
+    } b;
+} dvbc_cfg_c4_t;
+
+typedef union dvbc_cfg_c8 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned hw_symbol_rate:16;
+        unsigned sync_fail:1;
+        unsigned dc_offset:10;
+        unsigned reserved:5;
+    } b;
+} dvbc_cfg_c8_t;
+
+typedef union dvbc_cfg_cc {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned err_occur_cnt:16;
+        unsigned fec_eq_mma_cnt:8;
+        unsigned reserved:8;
+    } b;
+} dvbc_cfg_cc_t;
+
+typedef union dvbc_cfg_d0 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned int_mask:32;
+    } b;
+} dvbc_cfg_d0_t;
+
+typedef union dvbc_cfg_d4 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned int_status:32;
+    } b;
+} dvbc_cfg_d4_t;
+
+typedef union dvbc_cfg_d8 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_coefq_max:16;
+        unsigned eq_coefi_max:16;
+    } b;
+} dvbc_cfg_d8_t;
+
+typedef union dvbc_cfg_dc {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sum_phase_err_report:32;
+    } b;
+} dvbc_cfg_dc_t;
+
+typedef union dvbc_cfg_e0 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_angle:30;
+        unsigned reserved:2;
+    } b;
+} dvbc_cfg_e0_t;
+
+typedef union dvbc_cfg_e4 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned segm_cnt:16;
+        unsigned symb_cnt_eq:16;
+    } b;
+} dvbc_cfg_e4_t;
+
+typedef union dvbc_cfg_e8 {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned sw_eq_smma_reset_n:1;
+        unsigned err_occur_rst:1;
+        unsigned demod_enable:1;
+        unsigned soft_trigger_h9:9;
+    } b;
+} dvbc_cfg_e8_t;
+
+typedef union dvbc_cfg_ec {
+    /** raw register data */
+    uint32_t d32;
+    /** register bits */
+    struct {
+        unsigned eq_restore_angle:30;
+        unsigned reserved:2;
+    } b;
+} dvbc_cfg_ec_t;
+
+typedef struct atsc_cfg {
+    int adr;
+    int dat;
+    int rw;
+} atsc_cfg_t;
+
+struct agc_power_tab {
+	char name[128];
+	int level;
+	int ncalcE;
+	int *calcE;
+};
+
+typedef struct dtmb_cfg {
+    int dat;
+    int adr;
+    int rw;
+} dtmb_cfg_t;
+
+
+
+void demod_reset(void);
+void demod_set_irq_mask(void);
+void demod_clr_irq_stat(void);
+void demod_set_adc_core_clk(int, int, int);
+void demod_set_adc_core_clk_fix(int clk_adc, int clk_dem);
+void calculate_cordic_para(void);
+void ofdm_read_all_regs(void);
+void demod_set_adc_core_clk_quick(int clk_adc_cfg, int clk_dem_cfg);
+
+
+#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/dvbc_func.c b/drivers/amlogic/dvb_tv/amldemod/dvbc_func.c
new file mode 100755
index 000000000000..b1216c668b46
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/dvbc_func.c
@@ -0,0 +1,735 @@
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include "aml_demod.h"
+#include "demod_func.h"
+
+
+u32 dvbc_set_qam_mode(unsigned char mode)
+{
+	printk("auto change mode ,now mode is %d\n",mode);
+	apb_write_reg(QAM_BASE+0x008, (mode&7));  // qam mode
+	switch(mode){
+		case 0 : // 16 QAM
+		apb_write_reg(QAM_BASE+0x054, 0x23460224);	// EQ_FIR_CTL,
+		apb_write_reg(QAM_BASE+0x068, 0x00c000c0);	// EQ_CRTH_SNR
+		apb_write_reg(QAM_BASE+0x074,  0x50001a0);	// EQ_TH_LMS  40db	13db
+		apb_write_reg(QAM_BASE+0x07c, 0x003001e9);	// EQ_NORM and EQ_TH_MMA
+		//apb_write_reg(QAM_BASE+0x080, 0x000be1ff);  // EQ_TH_SMMA0
+		apb_write_reg(QAM_BASE+0x080, 0x000e01fe);	// EQ_TH_SMMA0
+		apb_write_reg(QAM_BASE+0x084, 0x00000000);	// EQ_TH_SMMA1
+		apb_write_reg(QAM_BASE+0x088, 0x00000000);	// EQ_TH_SMMA2
+		apb_write_reg(QAM_BASE+0x08c, 0x00000000);	// EQ_TH_SMMA3
+		//apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);  // AGC_CTRL  ALPS tuner
+		//apb_write_reg(QAM_BASE+0x094, 0x7f80292b);  // Pilips Tuner
+		//apb_write_reg(QAM_BASE+0x094, 0x7f80292d);  // Pilips Tuner
+		apb_write_reg(QAM_BASE+0x094, 0x7f80092d);	// Pilips Tuner
+		 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f66); // by raymond 20121213
+		break;
+
+		case 1 : // 32 QAM
+			apb_write_reg(QAM_BASE+0x054, 0x24560506);	// EQ_FIR_CTL,
+			apb_write_reg(QAM_BASE+0x068, 0x00c000c0);	// EQ_CRTH_SNR
+			//apb_write_reg(QAM_BASE+0x074, 0x5000260);   // EQ_TH_LMS	40db  19db
+			apb_write_reg(QAM_BASE+0x074,  0x50001f0);	// EQ_TH_LMS  40db	17.5db
+			apb_write_reg(QAM_BASE+0x07c, 0x00500102);	// EQ_TH_MMA  0x000001cc
+			apb_write_reg(QAM_BASE+0x080, 0x00077140);	// EQ_TH_SMMA0
+			apb_write_reg(QAM_BASE+0x084, 0x001fb000);	// EQ_TH_SMMA1
+			apb_write_reg(QAM_BASE+0x088, 0x00000000);	// EQ_TH_SMMA2
+			apb_write_reg(QAM_BASE+0x08c, 0x00000000);	// EQ_TH_SMMA3
+			//apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);  // AGC_CTRL  ALPS tuner
+			//apb_write_reg(QAM_BASE+0x094, 0x7f80292b);  // Pilips Tuner
+			apb_write_reg(QAM_BASE+0x094, 0x7f80092b);	// Pilips Tuner
+			 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f66); // by raymond 20121213
+		break;
+
+		case 2 : // 64 QAM
+		//apb_write_reg(QAM_BASE+0x054, 0x2256033a);  // EQ_FIR_CTL,
+		apb_write_reg(QAM_BASE+0x054, 0x2336043a);	// EQ_FIR_CTL, by raymond
+		apb_write_reg(QAM_BASE+0x068, 0x00c000c0);	// EQ_CRTH_SNR
+		//apb_write_reg(QAM_BASE+0x074, 0x5000260);  // EQ_TH_LMS  40db  19db
+		apb_write_reg(QAM_BASE+0x074,  0x5000230);	// EQ_TH_LMS  40db	17.5db
+		apb_write_reg(QAM_BASE+0x07c, 0x007001bd);	// EQ_TH_MMA
+		apb_write_reg(QAM_BASE+0x080, 0x000580ed);	// EQ_TH_SMMA0
+		apb_write_reg(QAM_BASE+0x084, 0x001771fb);	// EQ_TH_SMMA1
+		apb_write_reg(QAM_BASE+0x088, 0x00000000);	// EQ_TH_SMMA2
+		apb_write_reg(QAM_BASE+0x08c, 0x00000000);	// EQ_TH_SMMA3
+		//apb_write_reg(QAM_BASE+0x094, 0x7f800d2c); // AGC_CTRL  ALPS tuner
+		//apb_write_reg(QAM_BASE+0x094, 0x7f80292c); // Pilips & maxlinear Tuner
+		apb_write_reg(QAM_BASE+0x094, 0x7f802b3d);	// Pilips Tuner & maxlinear Tuner
+		//apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);  // Pilips Tuner & maxlinear Tuner
+		 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f66); // by raymond 20121213
+		break;
+
+		case 3 : // 128 QAM
+		//apb_write_reg(QAM_BASE+0x054, 0x2557046a);  // EQ_FIR_CTL,
+		apb_write_reg(QAM_BASE+0x054, 0x2437067a);	// EQ_FIR_CTL, by raymond 20121213
+		apb_write_reg(QAM_BASE+0x068, 0x00c000d0);	// EQ_CRTH_SNR
+		// apb_write_reg(QAM_BASE+0x074, 0x02440240);  // EQ_TH_LMS  18.5db  18db
+		// apb_write_reg(QAM_BASE+0x074, 0x04000400);  // EQ_TH_LMS  22db  22.5db
+		apb_write_reg(QAM_BASE+0x074,  0x5000260);	// EQ_TH_LMS  40db	19db
+		//apb_write_reg(QAM_BASE+0x07c, 0x00b000f2);  // EQ_TH_MMA0x000000b2
+		apb_write_reg(QAM_BASE+0x07c, 0x00b00132);	// EQ_TH_MMA0x000000b2 by raymond 20121213
+		apb_write_reg(QAM_BASE+0x080, 0x0003a09d);	// EQ_TH_SMMA0
+		apb_write_reg(QAM_BASE+0x084, 0x000f8150);	// EQ_TH_SMMA1
+		apb_write_reg(QAM_BASE+0x088, 0x001a51f8);	// EQ_TH_SMMA2
+		apb_write_reg(QAM_BASE+0x08c, 0x00000000);	// EQ_TH_SMMA3
+		//apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);  // AGC_CTRL  ALPS tuner
+		//apb_write_reg(QAM_BASE+0x094, 0x7f80292c);  // Pilips Tuner
+		apb_write_reg(QAM_BASE+0x094, 0x7f80092c);	// Pilips Tuner
+		 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f66); // by raymond 20121213
+		break;
+
+		case 4 : // 256 QAM
+		//apb_write_reg(QAM_BASE+0x054, 0xa2580588);  // EQ_FIR_CTL,
+		apb_write_reg(QAM_BASE+0x054, 0xa25905f9);	// EQ_FIR_CTL, by raymond 20121213
+		apb_write_reg(QAM_BASE+0x068, 0x01e00220);	// EQ_CRTH_SNR
+		//apb_write_reg(QAM_BASE+0x074,  0x50002a0);  // EQ_TH_LMS	40db  19db
+		apb_write_reg(QAM_BASE+0x074,  0x5000270);	// EQ_TH_LMS  40db	19db by raymond 201211213
+		apb_write_reg(QAM_BASE+0x07c, 0x00f001a5);	// EQ_TH_MMA
+		apb_write_reg(QAM_BASE+0x080, 0x0002c077);	// EQ_TH_SMMA0
+		apb_write_reg(QAM_BASE+0x084, 0x000bc0fe);	// EQ_TH_SMMA1
+		apb_write_reg(QAM_BASE+0x088, 0x0013f17e);	// EQ_TH_SMMA2
+		apb_write_reg(QAM_BASE+0x08c, 0x01bc01f9);	// EQ_TH_SMMA3
+		//apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);  // AGC_CTRL  ALPS tuner
+		//apb_write_reg(QAM_BASE+0x094, 0x7f80292c);  // Pilips Tuner
+		//apb_write_reg(QAM_BASE+0x094, 0x7f80292d);  // Maxlinear Tuner
+		apb_write_reg(QAM_BASE+0x094, 0x7f80092d);	// Maxlinear Tuner
+		 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121213, when adc=35M,sys=70M, its better than 0x61f2f66
+		break;
+		default:   //64qam
+			//apb_write_reg(QAM_BASE+0x054, 0x2256033a);  // EQ_FIR_CTL,
+		apb_write_reg(QAM_BASE+0x054, 0x2336043a);	// EQ_FIR_CTL, by raymond
+		apb_write_reg(QAM_BASE+0x068, 0x00c000c0);	// EQ_CRTH_SNR
+		//apb_write_reg(QAM_BASE+0x074, 0x5000260);  // EQ_TH_LMS  40db  19db
+		apb_write_reg(QAM_BASE+0x074,  0x5000230);	// EQ_TH_LMS  40db	17.5db
+		apb_write_reg(QAM_BASE+0x07c, 0x007001bd);	// EQ_TH_MMA
+		apb_write_reg(QAM_BASE+0x080, 0x000580ed);	// EQ_TH_SMMA0
+		apb_write_reg(QAM_BASE+0x084, 0x001771fb);	// EQ_TH_SMMA1
+		apb_write_reg(QAM_BASE+0x088, 0x00000000);	// EQ_TH_SMMA2
+		apb_write_reg(QAM_BASE+0x08c, 0x00000000);	// EQ_TH_SMMA3
+		//apb_write_reg(QAM_BASE+0x094, 0x7f800d2c); // AGC_CTRL  ALPS tuner
+		//apb_write_reg(QAM_BASE+0x094, 0x7f80292c); // Pilips & maxlinear Tuner
+		apb_write_reg(QAM_BASE+0x094, 0x7f802b3d);	// Pilips Tuner & maxlinear Tuner
+		//apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);  // Pilips Tuner & maxlinear Tuner
+		 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f66); // by raymond 20121213
+		break;
+		}
+		return 0;
+}
+
+
+u32 dvbc_get_status(void)
+{
+//	printk("c4 is %x\n",apb_read_reg(QAM_BASE+0xc4));
+	return apb_read_reg(QAM_BASE+0xc4)&0xf;
+}
+EXPORT_SYMBOL(dvbc_get_status);
+
+
+static u32 dvbc_get_ch_power(void)
+{
+    u32 tmp;
+    u32 ad_power;
+    u32 agc_gain;
+    u32 ch_power;
+
+    tmp = apb_read_reg(QAM_BASE+0x09c);
+
+    ad_power = (tmp>>22)&0x1ff;
+    agc_gain = (tmp>>0)&0x7ff;
+
+    ad_power = ad_power>>4;
+    // ch_power = lookuptable(agc_gain) + ad_power; TODO
+    ch_power = (ad_power & 0xffff) + ((agc_gain & 0xffff) << 16) ;
+
+    return ch_power;
+}
+
+static u32 dvbc_get_snr(void)
+{
+    u32 tmp, snr;
+
+    tmp = apb_read_reg(QAM_BASE+0x14)&0xfff;
+    snr = tmp * 100 / 32;  // * 1e2
+
+    return snr;
+}
+
+static u32 dvbc_get_ber(void)
+{
+    u32 rs_ber;
+    u32 rs_packet_len;
+
+    rs_packet_len = apb_read_reg(QAM_BASE+0x10)&0xffff;
+    rs_ber = apb_read_reg(QAM_BASE+0x14)>>12&0xfffff;
+
+    // rs_ber = rs_ber / 204.0 / 8.0 / rs_packet_len;
+    if(rs_packet_len == 0)
+	rs_ber = 1000000;
+    else
+	rs_ber = rs_ber * 613 / rs_packet_len;  // 1e-6
+
+    return rs_ber;
+}
+
+static u32 dvbc_get_per(void)
+{
+    u32 rs_per;
+    u32 rs_packet_len;
+	u32 acc_rs_per_times;
+
+    rs_packet_len = apb_read_reg(QAM_BASE+0x10)&0xffff;
+    rs_per = apb_read_reg(QAM_BASE+0x18)>>16&0xffff;
+
+    acc_rs_per_times = apb_read_reg(QAM_BASE+0xcc)&0xffff;
+    //rs_per = rs_per / rs_packet_len;
+
+    if(rs_packet_len == 0)
+	rs_per = 10000;
+    else
+	rs_per = 10000 * rs_per / rs_packet_len;  // 1e-4
+
+    //return rs_per;
+    return acc_rs_per_times;
+}
+
+static u32 dvbc_get_symb_rate(void)
+{
+    u32 tmp;
+    u32 adc_freq;
+    u32 symb_rate;
+
+    adc_freq = apb_read_reg(QAM_BASE+0x34)>>16&0xffff;
+    tmp = apb_read_reg(QAM_BASE+0xb8);
+
+    if((tmp>>15) == 0)
+	symb_rate = 0;
+    else
+	symb_rate = 10 * (adc_freq<<12) / (tmp>>15); // 1e4
+
+    return symb_rate;
+}
+
+static int dvbc_get_freq_off(void)
+{
+    int tmp;
+    int symb_rate;
+    int freq_off;
+
+    symb_rate = dvbc_get_symb_rate();
+    tmp = apb_read_reg(QAM_BASE+0xe0)&0x3fffffff;
+    if (tmp>>29&1) tmp -= (1<<30);
+
+    freq_off = ((tmp>>16) * 25 * (symb_rate>>10)) >> 3;
+
+    return freq_off;
+}
+
+static void dvbc_set_test_bus(u8 sel)
+{
+    u32 tmp;
+
+    tmp = apb_read_reg(QAM_BASE+0x08);
+    tmp &= ~(0x1f<<4);
+    tmp |= ((sel&0x1f)<<4) | (1<<3);
+    apb_write_reg(QAM_BASE+0x08, tmp);
+}
+
+void dvbc_get_test_out(u8 sel, u32 len, u32 *buf)
+{
+    int i, cnt;
+
+    dvbc_set_test_bus(sel);
+
+    for (i=0, cnt=0; i<len-4 && cnt<1000000; i++) {
+	buf[i] = apb_read_reg(QAM_BASE+0xb0);
+	if (buf[i]>>11&1) {
+	    buf[i++] = apb_read_reg(QAM_BASE+0xb0);
+	    buf[i++] = apb_read_reg(QAM_BASE+0xb0);
+	    buf[i++] = apb_read_reg(QAM_BASE+0xb0);
+	    buf[i++] = apb_read_reg(QAM_BASE+0xb0);
+	}
+	else {
+	    i--;
+	}
+
+	cnt++;
+    }
+}
+#if 0
+static void dvbc_sw_reset(int addr, int idx)
+{
+    u32 tmp;
+
+    tmp = apb_read_reg(QAM_BASE+addr);
+
+    tmp &= ~(1<<idx);
+    apb_write_reg(QAM_BASE+addr, tmp);
+
+    udelay(1);
+
+    tmp |= (1<<idx);
+    apb_write_reg(QAM_BASE+addr, tmp);
+}
+
+static void dvbc_reset(void)
+{
+    dvbc_sw_reset(0x04, 0);
+}
+
+static void dvbc_eq_reset(void)
+{
+    dvbc_sw_reset(0x50, 3);
+}
+
+static void dvbc_eq_smma_reset(void)
+{
+    dvbc_sw_reset(0xe8, 0);
+}
+#endif
+static void dvbc_reg_initial(struct aml_demod_sta *demod_sta)
+{
+    u32 clk_freq;
+    u32 adc_freq;
+    u8  tuner;
+    u8  ch_mode;
+    u8  agc_mode;
+    u32 ch_freq;
+    u16 ch_if;
+    u16 ch_bw;
+    u16 symb_rate;
+    u32 phs_cfg;
+    int afifo_ctr;
+    int max_frq_off, tmp;
+
+    clk_freq  = demod_sta->clk_freq ; // kHz
+    adc_freq  = demod_sta->adc_freq ; // kHz
+//    adc_freq  = 25414;
+    tuner     = demod_sta->tuner    ;
+    ch_mode   = demod_sta->ch_mode  ;
+    agc_mode  = demod_sta->agc_mode ;
+    ch_freq   = demod_sta->ch_freq  ; // kHz
+    ch_if     = demod_sta->ch_if    ; // kHz
+    ch_bw     = demod_sta->ch_bw    ; // kHz
+    symb_rate = demod_sta->symb_rate; // k/sec
+    printk("in dvbc_func, clk_freq is %d, adc_freq is %d,ch_mode is %d,ch_if is %d\n", clk_freq, adc_freq,ch_mode,ch_if);
+//	apb_write_reg(DEMOD_CFG_BASE,0x00000007);
+    // disable irq
+    apb_write_reg(QAM_BASE+0xd0, 0);
+
+    // reset
+    //dvbc_reset();
+    apb_write_reg(QAM_BASE+0x4, apb_read_reg(QAM_BASE+0x4) &~ (1 << 4)); // disable fsm_en
+	  apb_write_reg(QAM_BASE+0x4, apb_read_reg(QAM_BASE+0x4) &~ (1 << 0)); // Sw disable demod
+	  apb_write_reg(QAM_BASE+0x4, apb_read_reg(QAM_BASE+0x4) | (1 << 0)); // Sw enable demod
+
+    apb_write_reg(QAM_BASE+0x000, 0x00000000);  // QAM_STATUS
+    apb_write_reg(QAM_BASE+0x004, 0x00000f00);  // QAM_GCTL0
+    apb_write_reg(QAM_BASE+0x008, (ch_mode&7));  // qam mode
+
+    switch (ch_mode) {
+    case 0 : // 16 QAM
+       	apb_write_reg(QAM_BASE+0x054, 0x23460224);  // EQ_FIR_CTL,
+       	apb_write_reg(QAM_BASE+0x068, 0x00c000c0);  // EQ_CRTH_SNR
+       	apb_write_reg(QAM_BASE+0x074,  0x50001a0);  // EQ_TH_LMS  40db  13db
+       	apb_write_reg(QAM_BASE+0x07c, 0x003001e9);  // EQ_NORM and EQ_TH_MMA
+       	//apb_write_reg(QAM_BASE+0x080, 0x000be1ff);  // EQ_TH_SMMA0
+       	apb_write_reg(QAM_BASE+0x080, 0x000e01fe);  // EQ_TH_SMMA0
+       	apb_write_reg(QAM_BASE+0x084, 0x00000000);  // EQ_TH_SMMA1
+       	apb_write_reg(QAM_BASE+0x088, 0x00000000);  // EQ_TH_SMMA2
+       	apb_write_reg(QAM_BASE+0x08c, 0x00000000);  // EQ_TH_SMMA3
+       	//apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);  // AGC_CTRL  ALPS tuner
+       	//apb_write_reg(QAM_BASE+0x094, 0x7f80292b);  // Pilips Tuner
+       	//apb_write_reg(QAM_BASE+0x094, 0x7f80292d);  // Pilips Tuner
+       	apb_write_reg(QAM_BASE+0x094, 0x7f80092d);  // Pilips Tuner
+       	 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121213
+	break;
+
+    case 1 : // 32 QAM
+       	apb_write_reg(QAM_BASE+0x054, 0x24560506);  // EQ_FIR_CTL,
+       	apb_write_reg(QAM_BASE+0x068, 0x00c000c0);  // EQ_CRTH_SNR
+       	//apb_write_reg(QAM_BASE+0x074, 0x5000260);   // EQ_TH_LMS  40db  19db
+       	apb_write_reg(QAM_BASE+0x074,  0x50001f0);  // EQ_TH_LMS  40db  17.5db
+       	apb_write_reg(QAM_BASE+0x07c, 0x00500102);  // EQ_TH_MMA  0x000001cc
+       	apb_write_reg(QAM_BASE+0x080, 0x00077140);  // EQ_TH_SMMA0
+       	apb_write_reg(QAM_BASE+0x084, 0x001fb000);  // EQ_TH_SMMA1
+       	apb_write_reg(QAM_BASE+0x088, 0x00000000);  // EQ_TH_SMMA2
+       	apb_write_reg(QAM_BASE+0x08c, 0x00000000);  // EQ_TH_SMMA3
+       	//apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);  // AGC_CTRL  ALPS tuner
+       	//apb_write_reg(QAM_BASE+0x094, 0x7f80292b);  // Pilips Tuner
+       	apb_write_reg(QAM_BASE+0x094, 0x7f80092b);  // Pilips Tuner
+       	 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121213
+	break;
+
+    case 2 : // 64 QAM
+	//apb_write_reg(QAM_BASE+0x054, 0x2256033a);  // EQ_FIR_CTL,
+	apb_write_reg(QAM_BASE+0x054, 0x2336043a);  // EQ_FIR_CTL, by raymond
+	apb_write_reg(QAM_BASE+0x068, 0x00c000c0);  // EQ_CRTH_SNR
+	//apb_write_reg(QAM_BASE+0x074, 0x5000260);  // EQ_TH_LMS  40db  19db
+	apb_write_reg(QAM_BASE+0x074,  0x5000230);  // EQ_TH_LMS  40db  17.5db
+	apb_write_reg(QAM_BASE+0x07c, 0x007001bd);  // EQ_TH_MMA
+	apb_write_reg(QAM_BASE+0x080, 0x000580ed);  // EQ_TH_SMMA0
+	apb_write_reg(QAM_BASE+0x084, 0x001771fb);  // EQ_TH_SMMA1
+	apb_write_reg(QAM_BASE+0x088, 0x00000000);  // EQ_TH_SMMA2
+	apb_write_reg(QAM_BASE+0x08c, 0x00000000);  // EQ_TH_SMMA3
+	//apb_write_reg(QAM_BASE+0x094, 0x7f800d2c); // AGC_CTRL  ALPS tuner
+	//apb_write_reg(QAM_BASE+0x094, 0x7f80292c); // Pilips & maxlinear Tuner
+	apb_write_reg(QAM_BASE+0x094, 0x7f802b3d);  // Pilips Tuner & maxlinear Tuner
+	//apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);  // Pilips Tuner & maxlinear Tuner
+	 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121213
+	break;
+
+    case 3 : // 128 QAM
+	//apb_write_reg(QAM_BASE+0x054, 0x2557046a);  // EQ_FIR_CTL,
+	apb_write_reg(QAM_BASE+0x054, 0x2437067a);  // EQ_FIR_CTL, by raymond 20121213
+	apb_write_reg(QAM_BASE+0x068, 0x00c000d0);  // EQ_CRTH_SNR
+	// apb_write_reg(QAM_BASE+0x074, 0x02440240);  // EQ_TH_LMS  18.5db  18db
+	// apb_write_reg(QAM_BASE+0x074, 0x04000400);  // EQ_TH_LMS  22db  22.5db
+	apb_write_reg(QAM_BASE+0x074,  0x5000260);  // EQ_TH_LMS  40db  19db
+	//apb_write_reg(QAM_BASE+0x07c, 0x00b000f2);  // EQ_TH_MMA0x000000b2
+	apb_write_reg(QAM_BASE+0x07c, 0x00b00132);  // EQ_TH_MMA0x000000b2 by raymond 20121213
+	apb_write_reg(QAM_BASE+0x080, 0x0003a09d);  // EQ_TH_SMMA0
+	apb_write_reg(QAM_BASE+0x084, 0x000f8150);  // EQ_TH_SMMA1
+	apb_write_reg(QAM_BASE+0x088, 0x001a51f8);  // EQ_TH_SMMA2
+	apb_write_reg(QAM_BASE+0x08c, 0x00000000);  // EQ_TH_SMMA3
+	//apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);  // AGC_CTRL  ALPS tuner
+	//apb_write_reg(QAM_BASE+0x094, 0x7f80292c);  // Pilips Tuner
+	apb_write_reg(QAM_BASE+0x094, 0x7f80092c);  // Pilips Tuner
+	 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121213
+	break;
+
+    case 4 : // 256 QAM
+	//apb_write_reg(QAM_BASE+0x054, 0xa2580588);  // EQ_FIR_CTL,
+	apb_write_reg(QAM_BASE+0x054, 0xa25905f9);  // EQ_FIR_CTL, by raymond 20121213
+	apb_write_reg(QAM_BASE+0x068, 0x01e00220);  // EQ_CRTH_SNR
+	//apb_write_reg(QAM_BASE+0x074,  0x50002a0);  // EQ_TH_LMS  40db  19db
+	apb_write_reg(QAM_BASE+0x074,  0x5000270);  // EQ_TH_LMS  40db  19db by raymond 201211213
+	apb_write_reg(QAM_BASE+0x07c, 0x00f001a5);  // EQ_TH_MMA
+	apb_write_reg(QAM_BASE+0x080, 0x0002c077);  // EQ_TH_SMMA0
+	apb_write_reg(QAM_BASE+0x084, 0x000bc0fe);  // EQ_TH_SMMA1
+	apb_write_reg(QAM_BASE+0x088, 0x0013f17e);  // EQ_TH_SMMA2
+	apb_write_reg(QAM_BASE+0x08c, 0x01bc01f9);  // EQ_TH_SMMA3
+	//apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);  // AGC_CTRL  ALPS tuner
+	//apb_write_reg(QAM_BASE+0x094, 0x7f80292c);  // Pilips Tuner
+	//apb_write_reg(QAM_BASE+0x094, 0x7f80292d);  // Maxlinear Tuner
+	apb_write_reg(QAM_BASE+0x094, 0x7f80092d);  // Maxlinear Tuner
+	 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121213, when adc=35M,sys=70M, its better than 0x61f2f66
+	break;
+	default:   //64qam
+		//apb_write_reg(QAM_BASE+0x054, 0x2256033a);  // EQ_FIR_CTL,
+	apb_write_reg(QAM_BASE+0x054, 0x2336043a);  // EQ_FIR_CTL, by raymond
+	apb_write_reg(QAM_BASE+0x068, 0x00c000c0);  // EQ_CRTH_SNR
+	//apb_write_reg(QAM_BASE+0x074, 0x5000260);  // EQ_TH_LMS  40db  19db
+	apb_write_reg(QAM_BASE+0x074,  0x5000230);  // EQ_TH_LMS  40db  17.5db
+	apb_write_reg(QAM_BASE+0x07c, 0x007001bd);  // EQ_TH_MMA
+	apb_write_reg(QAM_BASE+0x080, 0x000580ed);  // EQ_TH_SMMA0
+	apb_write_reg(QAM_BASE+0x084, 0x001771fb);  // EQ_TH_SMMA1
+	apb_write_reg(QAM_BASE+0x088, 0x00000000);  // EQ_TH_SMMA2
+	apb_write_reg(QAM_BASE+0x08c, 0x00000000);  // EQ_TH_SMMA3
+	//apb_write_reg(QAM_BASE+0x094, 0x7f800d2c); // AGC_CTRL  ALPS tuner
+	//apb_write_reg(QAM_BASE+0x094, 0x7f80292c); // Pilips & maxlinear Tuner
+	apb_write_reg(QAM_BASE+0x094, 0x7f802b3d);  // Pilips Tuner & maxlinear Tuner
+	//apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);  // Pilips Tuner & maxlinear Tuner
+	 apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121213
+	break;
+    }
+
+    //apb_write_reg(QAM_BASE+0x00c, 0xfffffffe);  // adc_cnt, symb_cnt
+    apb_write_reg(QAM_BASE+0x00c, 0xffff8ffe);  // adc_cnt, symb_cnt	by raymond 20121213
+    if (clk_freq == 0)
+        afifo_ctr = 0;
+    else
+        afifo_ctr = (adc_freq * 256 / clk_freq) + 2;
+    if(afifo_ctr > 255) afifo_ctr = 255;
+    apb_write_reg(QAM_BASE+0x010, (afifo_ctr<<16) | 8000); // afifo, rs_cnt_cfg
+
+    //apb_write_reg(QAM_BASE+0x020, 0x21353e54);  // PHS_reset & TIM_CTRO_ACCURATE  sw_tim_select=0
+	  //apb_write_reg(QAM_BASE+0x020, 0x21b53e54); //modified by qiancheng
+	  apb_write_reg(QAM_BASE+0x020, 0x61b53e54); //modified by qiancheng by raymond 20121208  0x63b53e54 for cci
+	//  apb_write_reg(QAM_BASE+0x020, 0x6192bfe2); //modifed by ligg 20130613 auto symb_rate scan
+    if (adc_freq == 0)
+        phs_cfg = 0;
+    else
+        phs_cfg = (1<<31) / adc_freq * ch_if / (1<<8);   //  8*fo/fs*2^20 fo=36.125, fs = 28.57114, = 21d775
+    // printk("phs_cfg = %x\n", phs_cfg);
+    apb_write_reg(QAM_BASE+0x024, 0x4c000000 | (phs_cfg&0x7fffff));  // PHS_OFFSET, IF offset,
+
+    if(adc_freq == 0)
+       max_frq_off = 0;
+    else
+    {
+       max_frq_off = (1<<29) / symb_rate;   // max_frq_off = (400KHz * 2^29) / (AD=28571 * symbol_rate=6875)
+       tmp = 40000000 / adc_freq;
+       max_frq_off = tmp * max_frq_off;
+    }
+    printk("max_frq_off is %x,\n",max_frq_off);
+    apb_write_reg(QAM_BASE+0x02c, max_frq_off&0x3fffffff);  // max frequency offset, by raymond 20121208
+
+    //apb_write_reg(QAM_BASE+0x030, 0x011bf400);  // TIM_CTL0 start speed is 0,  when know symbol rate
+	apb_write_reg(QAM_BASE+0x030, 0x245cf451); //MODIFIED BY QIANCHENG
+//	apb_write_reg(QAM_BASE+0x030, 0x245bf451); //modified by ligg 20130613 --auto symb_rate scan
+    apb_write_reg(QAM_BASE+0x034, ((adc_freq & 0xffff) << 16) | (symb_rate&0xffff) );
+
+    apb_write_reg(QAM_BASE+0x038, 0x00400000);  // TIM_SWEEP_RANGE 16000
+
+/************* hw state machine config **********/
+    apb_write_reg(QAM_BASE+0x040, 0x003c); // configure symbol rate step step 0
+
+    // modified 0x44 0x48
+    apb_write_reg(QAM_BASE+0x044, (symb_rate&0xffff)*256); // blind search, configure max symbol_rate      for 7218  fb=3.6M
+    //apb_write_reg(QAM_BASE+0x048, 3600*256); // configure min symbol_rate fb = 6.95M
+    apb_write_reg(QAM_BASE+0x048, 3400*256); // configure min symbol_rate fb = 6.95M
+
+    //apb_write_reg(QAM_BASE+0x0c0, 0xffffff68); // threshold
+    //apb_write_reg(QAM_BASE+0x0c0, 0xffffff6f); // threshold
+    //apb_write_reg(QAM_BASE+0x0c0, 0xfffffd68); // threshold
+    //apb_write_reg(QAM_BASE+0x0c0, 0xffffff68); // threshold
+    //apb_write_reg(QAM_BASE+0x0c0, 0xffffff68); // threshold
+    //apb_write_reg(QAM_BASE+0x0c0, 0xffff2f67); // threshold for skyworth
+   // apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121208
+   // apb_write_reg(QAM_BASE+0x0c0, 0x061f2f66); // by raymond 20121213, remove it to every constellation
+/************* hw state machine config **********/
+
+    apb_write_reg(QAM_BASE+0x04c, 0x00008800);  // reserved
+
+    //apb_write_reg(QAM_BASE+0x050, 0x00000002);  // EQ_CTL0
+    apb_write_reg(QAM_BASE+0x050, 0x01472002);  // EQ_CTL0 by raymond 20121208
+
+    //apb_write_reg(QAM_BASE+0x058, 0xff550e1e);  // EQ_FIR_INITPOS
+    apb_write_reg(QAM_BASE+0x058, 0xff100e1e);  // EQ_FIR_INITPOS for skyworth
+
+    apb_write_reg(QAM_BASE+0x05c, 0x019a0000);  // EQ_FIR_INITVAL0
+    apb_write_reg(QAM_BASE+0x060, 0x019a0000);  // EQ_FIR_INITVAL1
+
+    //apb_write_reg(QAM_BASE+0x064, 0x01101128);  // EQ_CRTH_TIMES
+    apb_write_reg(QAM_BASE+0x064, 0x010a1128);  // EQ_CRTH_TIMES for skyworth
+    apb_write_reg(QAM_BASE+0x06c, 0x00041a05);  // EQ_CRTH_PPM
+
+    apb_write_reg(QAM_BASE+0x070, 0xffb9aa01);  // EQ_CRLP
+
+    //apb_write_reg(QAM_BASE+0x090, 0x00020bd5); // agc control
+    apb_write_reg(QAM_BASE+0x090, 0x00000bd5); // agc control
+
+    // agc control
+    // apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);   // AGC_CTRL  ALPS tuner
+    // apb_write_reg(QAM_BASE+0x094, 0x7f80292c);     // Pilips Tuner
+    if ((agc_mode&1)==0)
+	apb_write_reg(QAM_BASE+0x094, apb_read_reg(QAM_BASE+0x94) | (0x1 << 10));     // freeze if agc
+    if ((agc_mode&2)==0) // IF control
+	apb_write_reg(QAM_BASE+0x094, apb_read_reg(QAM_BASE+0x94) | (0x1 << 13));     // freeze rf agc
+
+    //apb_write_reg(QAM_BASE+0x094, 0x7f80292d);     // Maxlinear Tuner
+
+    apb_write_reg(QAM_BASE+0x098, 0x9fcc8190);  // AGC_IFGAIN_CTRL
+    //apb_write_reg(QAM_BASE+0x0a0, 0x0e028c00);  // AGC_RFGAIN_CTRL 0x0e020800
+    //apb_write_reg(QAM_BASE+0x0a0, 0x0e03cc00);  // AGC_RFGAIN_CTRL 0x0e020800
+    //apb_write_reg(QAM_BASE+0x0a0, 0x0e028700);  // AGC_RFGAIN_CTRL 0x0e020800 now
+    //apb_write_reg(QAM_BASE+0x0a0, 0x0e03cd00);  // AGC_RFGAIN_CTRL 0x0e020800
+    //apb_write_reg(QAM_BASE+0x0a0, 0x0603cd11);  // AGC_RFGAIN_CTRL 0x0e020800 by raymond, if Adjcent channel test, maybe it need change.20121208 ad invert
+    apb_write_reg(QAM_BASE+0x0a0, 0x0603cd10);  // AGC_RFGAIN_CTRL 0x0e020800 by raymond, if Adjcent channel test, maybe it need change.20121208 ad invert,20130221, suit for two path channel.
+
+    apb_write_reg(QAM_BASE+0x004, apb_read_reg(QAM_BASE+0x004)|0x33);  // IMQ, QAM Enable
+
+    // start hardware machine
+    //dvbc_sw_reset(0x004, 4);
+    apb_write_reg(QAM_BASE+0x4, apb_read_reg(QAM_BASE+0x4) | (1 << 4));
+    apb_write_reg(QAM_BASE+0x0e8, (apb_read_reg(QAM_BASE+0x0e8)|(1<<2)));
+
+    // clear irq status
+    apb_read_reg(QAM_BASE+0xd4);
+
+    // enable irq
+    apb_write_reg(QAM_BASE+0xd0, 0x7fff<<3);
+
+
+//auto track
+	//	dvbc_set_auto_symtrack();
+}
+
+u32 dvbc_set_auto_symtrack()
+{
+	  apb_write_reg(QAM_BASE+0x030, 0x245bf45c);//open track
+	  apb_write_reg(QAM_BASE+0x020, 0x61b2bf5c);
+	  apb_write_reg(QAM_BASE+0x044, (7000&0xffff)*256);
+	  apb_write_reg(QAM_BASE+0x038, 0x00220000);
+	  apb_write_reg(QAM_BASE+0x4, apb_read_reg(QAM_BASE+0x4) &~ (1 << 0)); // Sw disable demod
+	  apb_write_reg(QAM_BASE+0x4, apb_read_reg(QAM_BASE+0x4) | (1 << 0)); // Sw enable demod
+	  return 0;
+}
+
+int dvbc_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbc *demod_dvbc)
+{
+    int ret = 0;
+    u16 symb_rate;
+    u8  mode;
+    u32 ch_freq;
+
+   printk("f=%d, s=%d, q=%d\n", demod_dvbc->ch_freq, demod_dvbc->symb_rate, demod_dvbc->mode);
+   demod_i2c->tuner = 7;
+    mode      = demod_dvbc->mode;
+    symb_rate = demod_dvbc->symb_rate;
+    ch_freq   = demod_dvbc->ch_freq;
+    if (mode > 4) {
+	printk("Error: Invalid QAM mode option %d\n", mode);
+	mode = 2;
+       	ret = -1;
+    }
+
+    if (symb_rate<1000 || symb_rate>7000) {
+	printk("Error: Invalid Symbol Rate option %d\n", symb_rate);
+	symb_rate = 6875;
+	ret = -1;
+    }
+
+    if (ch_freq<1000 || ch_freq>900000) {
+	printk("Error: Invalid Channel Freq option %d\n", ch_freq);
+	ch_freq = 474000;
+	ret = -1;
+    }
+
+    // if (ret != 0) return ret;
+    demod_sta->dvb_mode  = 0;
+    demod_sta->ch_mode   = mode; // 0:16, 1:32, 2:64, 3:128, 4:256
+    demod_sta->agc_mode  = 1;    // 0:NULL, 1:IF, 2:RF, 3:both
+    demod_sta->ch_freq   = ch_freq;
+    demod_sta->tuner     = demod_i2c->tuner;
+
+    if(demod_i2c->tuner == 1)
+        demod_sta->ch_if     = 36130; // TODO  DCT tuner
+    else if (demod_i2c->tuner == 2)
+        demod_sta->ch_if     = 4570; // TODO  Maxlinear tuner
+    else if (demod_i2c->tuner == 7)
+     //   demod_sta->ch_if     = 5000; // TODO  Si2176 tuner
+
+    demod_sta->ch_bw     = 8000;  // TODO
+    demod_sta->symb_rate = symb_rate;
+    dvbc_reg_initial(demod_sta);
+
+    return ret;
+}
+
+int dvbc_status(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_sts *demod_sts)
+{
+	struct aml_fe_dev *dev;
+	int ftmp,tmp;
+	dev=NULL;
+    demod_sts->ch_sts = apb_read_reg(QAM_BASE+0x18);
+    demod_sts->ch_pow = dvbc_get_ch_power();
+    demod_sts->ch_snr = dvbc_get_snr();
+    demod_sts->ch_ber = dvbc_get_ber();
+    demod_sts->ch_per = dvbc_get_per();
+    demod_sts->symb_rate = dvbc_get_symb_rate();
+    demod_sts->freq_off = dvbc_get_freq_off();
+    //demod_sts->dat0 = apb_read_reg(QAM_BASE+0x28);
+//    demod_sts->dat0 = tuner_get_ch_power(demod_i2c);
+    demod_sts->dat1 = tuner_get_ch_power(dev);
+#if 1
+
+    ftmp = demod_sts->ch_sts;
+	printk("[dvbc debug] ch_sts is %x\n",ftmp);
+	ftmp = demod_sts->ch_snr;
+    ftmp /= 100;
+    printk("snr %d dB ", ftmp);
+    ftmp = demod_sts->ch_ber;
+    printk("ber %.d ", ftmp);
+    tmp = demod_sts->ch_per;
+    printk("per %d ", tmp);
+    ftmp = demod_sts->symb_rate;
+    printk("srate %.d ", ftmp);
+    ftmp = demod_sts->freq_off;
+    printk("freqoff %.d kHz ", ftmp);
+    tmp = demod_sts->dat1;
+    printk("strength %ddb  0xe0 status is %lu ,b4 status is %lu", tmp,(
+	apb_read_reg(QAM_BASE+0xe0)&0xffff),(apb_read_reg(QAM_BASE+0xb4)&0xffff));
+	printk("dagc_gain is %lu ", apb_read_reg(QAM_BASE+0xa4)&0x7f);
+	tmp = demod_sts->ch_pow;
+	printk("power is %ddb \n",(tmp & 0xffff));
+
+#endif
+
+    return 0;
+}
+
+void dvbc_enable_irq(int dvbc_irq)
+{
+    u32 mask;
+
+    // clear status
+    apb_read_reg(QAM_BASE+0xd4);
+    // enable irq
+    mask = apb_read_reg(QAM_BASE+0xd0);
+    mask |= (1<<dvbc_irq);
+    apb_write_reg(QAM_BASE+0xd0, mask);
+}
+
+void dvbc_disable_irq(int dvbc_irq)
+{
+    u32 mask;
+
+    // disable irq
+    mask = apb_read_reg(QAM_BASE+0xd0);
+    mask &= ~(1<<dvbc_irq);
+    apb_write_reg(QAM_BASE+0xd0, mask);
+    // clear status
+    apb_read_reg(QAM_BASE+0xd4);
+}
+
+char *dvbc_irq_name[] = {
+    "      ADC",
+    "   Symbol",
+    "       RS",
+    " In_Sync0",
+    " In_Sync1",
+    " In_Sync2",
+    " In_Sync3",
+    " In_Sync4",
+    "Out_Sync0",
+    "Out_Sync1",
+    "Out_Sync2",
+    "Out_Sync3",
+    "Out_Sync4",
+    "In_SyncCo",
+    "OutSyncCo",
+    "  In_Dagc",
+    " Out_Dagc",
+    "  Eq_Mode",
+    "RS_Uncorr"};
+
+void dvbc_isr(struct aml_demod_sta *demod_sta)
+{
+    u32 stat, mask;
+    int dvbc_irq;
+
+    stat = apb_read_reg(QAM_BASE+0xd4);
+    mask = apb_read_reg(QAM_BASE+0xd0);
+    stat &= mask;
+
+    for (dvbc_irq=0; dvbc_irq<20; dvbc_irq++) {
+	if (stat>>dvbc_irq&1) {
+	    if (demod_sta->debug)
+		printk("irq: dvbc %2d %s %8x\n",
+		       dvbc_irq, dvbc_irq_name[dvbc_irq], stat);
+	    // dvbc_disable_irq(dvbc_irq);
+	}
+    }
+}
+
+int dvbc_isr_islock(void)
+{
+#define IN_SYNC4_MASK (0x80)
+
+    u32 stat, mask;
+
+    stat = apb_read_reg(QAM_BASE+0xd4);
+    apb_write_reg(QAM_BASE+0xd4, 0);
+    mask = apb_read_reg(QAM_BASE+0xd0);
+    stat &= mask;
+
+    return ((stat&IN_SYNC4_MASK)==IN_SYNC4_MASK);
+}
+
diff --git a/drivers/amlogic/dvb_tv/amldemod/dvbt_func.c b/drivers/amlogic/dvb_tv/amldemod/dvbt_func.c
new file mode 100755
index 000000000000..df99e358ad05
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/dvbt_func.c
@@ -0,0 +1,1599 @@
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include "aml_demod.h"
+#include "demod_func.h"
+
+static int debug_amldvbt;
+module_param(debug_amldvbt, int, 0644);
+MODULE_PARM_DESC(debug_amldvbt, "turn on debugging (default: 0)");
+#define dprintk(args...) do { if (debug_amldvbt) { printk(KERN_DEBUG "AMLDVBT: "); printk(args); printk("\n"); } } while (0)
+
+static int tuner_type = 3;
+
+static void set_ACF_coef(int ADsample, int bandwidth)
+{
+    if (ADsample == 45)	{
+	// Set ACF and IIREQ
+	if (bandwidth == 0) {//8M Hz
+	    apb_write_reg(2, 0x2c ,0x255);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x0B5);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x091);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x02E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x253);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x0CB);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x2CD);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x07C);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x250);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0E4);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x276);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x05D);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x24D);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0F3);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x25E);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x05A);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x24A);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0FD);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x256);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04B);// ACF_STAGE5_GAIN
+
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003effff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003cefbe);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003adf7c);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x0038bf39);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x003696f5);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x003466b0);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x00322e69);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x002fee21);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x002dadd9);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002b6d91);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x00291d48);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x0026ccfe);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x00245cb2);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x0021d463);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x001f2410);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x001c3bb6);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x00192b57);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x0015e2f1);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x00127285);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x000eca14);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x000ac99b);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x00063913);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x0000c073);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x003a3fb4);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x00347ecf);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x002ff649);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x002a8dab);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x002444f0);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x001d0c1b);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x000fc300);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x000118ce);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x003c17c3);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x00000751);
+	}
+	else if (bandwidth==1) {// 7Mhz
+
+	    apb_write_reg(2, 0x2c ,0x24B);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x0BD);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x04B);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x03E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x246);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x0D1);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x2A2);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x07C);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x241);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0E7);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x25B);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x05D);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x23D);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0F5);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x248);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x05A);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x23A);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0FD);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x242);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04B);// ACF_STAGE5_GAIN
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003f07ff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003cffbf);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003aef7e);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x0038d73c);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x0036b6f9);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x003486b3);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x00324e6d);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x00300e25);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x002dcddd);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002b8594);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x00292d4b);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x0026d500);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x00245cb3);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x0021cc62);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x001f0c0d);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x001c1bb3);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x0018fb52);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x0015b2eb);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x00123a7f);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x000e9a0e);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x000a9995);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x0006090d);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x0000a06e);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x003a57b3);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x0034ded8);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x00309659);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x002b75c4);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x0025350e);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x001dec37);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x00126b28);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x00031130);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x003cffec);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x00000767);
+	}
+	else if (bandwidth==2) {// 6MHz
+	    apb_write_reg(2, 0x2c ,0x240);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x0C6);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x3F9);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x03E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x23A);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x0D7);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x27B);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x07C);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x233);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0EA);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x244);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x05D);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x22F);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0F6);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x235);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x05A);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x22B);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0FD);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x231);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04B);// ACF_STAGE5_GAIN
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003f07ff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003cffbf);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003aef7e);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x0038d73c);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x0036b6f8);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x003486b3);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x0032466c);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x002ffe24);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x002dadda);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002b5d90);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x0028fd45);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x002694f9);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x002414ab);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x00217458);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x001ea402);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x001ba3a5);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x00187342);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x00151ad9);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x0011926b);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x000dc9f6);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x0009a178);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x0004d8eb);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x003f4045);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x0038e785);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x00337eab);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x002f3e2d);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x002a1599);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x0023ace1);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x001b33fb);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x000cd29c);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x0001c0c1);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x003cefde);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x0000076a);
+	}
+	else { // 5MHz
+	    apb_write_reg(2, 0x2c ,0x236);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x0CE);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x39A);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x03E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x22F);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x0DE);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x257);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x07C);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x227);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0EE);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x230);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x05D);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x222);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0F8);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x225);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x05A);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x21E);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0FE);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x222);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04B);// ACF_STAGE5_GAIN
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003effff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003ce7bd);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003ac77a);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x0038a737);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x00367ef2);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x00344eac);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x00321e66);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x002fee20);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x002dbdda);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002b8d94);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x00295d4e);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x00272508);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x0024dcc0);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x00227475);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x001fe426);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x001d1bd1);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x001a2374);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x0016e311);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x00136aa6);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x000fba33);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x000ba9b8);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x0007092e);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x0001988e);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x003b37d0);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x0035aef3);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x00316673);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x002c45de);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x0025e527);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x001da444);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x000deaea);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x000178bf);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x003cb7d6);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x00000765);
+	}
+    }
+    else if (ADsample == 28) {
+	// 28.5714 MHz Set ACF
+	if (bandwidth == 0) {  //8M Hz
+
+	    apb_write_reg(2, 0x2c ,0x2DB);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x05B);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x163);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x00E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x2D5);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x08B);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x3BC);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x06D);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x2CF);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0BF);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x321);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x008);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x2C9);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0E3);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x2EE);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x058);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x2C3);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0F8);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x2DD);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04D);// ACF_STAGE5_GAIN
+
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003ef7ff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003d37c0);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003c3f94);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x003b0f78);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x0038c73f);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x00369ef1);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x003576be);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x0033b698);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x0031164d);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002f1dfd);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x002de5cf);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x002c15a2);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x0029f560);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x0027bd1b);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x00252ccf);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x0022bc7c);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x00207c34);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x001da3e5);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x001a9b83);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x0017db27);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x001432c6);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x000fa23e);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x000b91af);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x00077136);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x0002c090);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x003ec01a);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x003a3f92);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x00354efa);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x002fee54);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x002a35a3);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x0023f4e4);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x001cdc12);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x00000316);
+	}
+	else if (bandwidth==1) {
+	    apb_write_reg(2, 0x2c ,0x2C2);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x069);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x134);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x00E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x2B7);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x095);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x36F);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x06D);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x2AA);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0C6);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x2E5);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x008);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x2A1);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0E6);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x2BA);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x058);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x299);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0F9);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x2AC);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04D);// ACF_STAGE5_GAIN
+
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003ee7ff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003d1fbc);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003bf790);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x003a876a);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x00388f31);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x0036c6f3);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x003536bf);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x00334689);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x00310644);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002ef5fd);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x002d45c2);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x002b7d8c);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x00298550);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x00278510);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x00252ccc);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x0022847c);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x00201427);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x001e03e0);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x001b6b9b);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x0017c336);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x0013e2b8);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x0010b246);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x000d81e8);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x00084966);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x0003089c);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x003f0022);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x003aaf9c);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x00360f0c);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x00312e74);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x002c05d3);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x00268d2a);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x0020bc76);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x000003b3);
+	}
+	else if (bandwidth==2) {// 6MHz
+
+	    apb_write_reg(2, 0x2c ,0x2A9);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x078);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x0F4);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x01E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x299);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x0A1);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x321);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x078);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x288);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0CD);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x2AE);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x05F);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x27C);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0E9);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x28B);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x058);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x273);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0FA);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x281);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04D);// ACF_STAGE5_GAIN
+
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003f17ff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003d3fc4);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003b7f8a);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x0039df55);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x00381720);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x00360ee2);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x00342ea1);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x0032ee6e);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x0031e64e);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x00300e22);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x002daddc);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x002b758f);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x0029ad51);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x0027ad18);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x00250ccd);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x00227476);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x00204c2a);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x001de3e6);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x001a838a);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x0016ab12);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x00137a9d);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x00113a4a);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x000db1f8);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x0007c15f);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x00022883);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x003df803);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x00398f79);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x0034d6e6);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x002fd64b);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x002a8da7);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x002504fa);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x001f2443);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x00000382);
+	}
+	else {
+	    apb_write_reg(2, 0x2c ,0x28F);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x088);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x09E);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x01E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x27C);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x0AD);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x2D6);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x078);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x268);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0D4);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x27C);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x05F);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x25B);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0ED);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x262);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x058);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x252);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0FB);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x25A);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04D);// ACF_STAGE5_GAIN
+
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003f17ff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003d4fc5);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003baf8e);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x003a3f5d);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x0038df32);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x00374703);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x00354ec9);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x00333e88);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x00314e47);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002f860c);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x002d9dd2);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x002b5590);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x0028cd42);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x00266cf2);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x00245cab);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x00225c6b);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x00200427);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x001d4bd5);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x001a9b7d);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x00183b2b);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x0015b2e1);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x00122a83);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x000d49fc);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x0007594e);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x00024080);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x003e980e);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x003ab796);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x00368f15);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x00320e8a);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x002d25f4);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x0027ad4f);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x00219496);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x000003c9);
+	}
+    }
+    else {
+	// 20.7 MHz Set ACF
+	if (bandwidth == 0) {   //8M Hz
+
+	    apb_write_reg(2, 0x2c ,0x318);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x03E);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x1AE);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x00E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x326);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x074);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x074);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x06F);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x336);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0B1);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x3C9);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x008);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x33F);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0DC);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x384);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x05A);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x340);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0F6);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x36D);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04B);// ACF_STAGE5_GAIN
+
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003f37ff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003d97cc);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003bf798);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x003a4f64);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x0038a72f);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x0036f6f9);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x003546c3);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x0033868c);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x0031be54);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002fe61a);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x002e05df);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x002c15a2);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x002a1562);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x0027f520);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x0025c4dc);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x00236c93);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x0020f446);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x001e4bf4);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x001b739d);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x00185b3d);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x0014ead5);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x00111a62);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x000cb9df);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x00079148);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x00030093);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x003f802a);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x003b77b2);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x0036a725);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x0030ae7b);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x00285d9f);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x001abc46);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x000f8a85);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x00000187);
+	}
+	else if (bandwidth==1) {
+	    apb_write_reg(2, 0x2c ,0x2F9);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x04C);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x18E);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x00E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x2FD);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x07F);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x01A);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x06D);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x300);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0B8);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x372);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x05F);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x301);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0DF);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x335);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x05A);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x2FE);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0F7);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x320);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04B);// ACF_STAGE5_GAIN
+
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003f37ff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003d8fcc);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003bef97);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x003a4762);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x0038972d);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x0036e6f7);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x00352ec1);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x00336e89);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x00319e50);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002fce16);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x002de5db);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x002bf59d);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x0029ed5e);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x0027d51c);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x00259cd7);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x0023448e);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x0020cc41);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x001e23ef);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x001b4b98);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x00183339);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x0014cad1);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x0010fa5e);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x000c99dc);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x00078145);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x0002f892);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x003f802a);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x003b8fb3);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x0036d729);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x00310682);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x00290dae);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x001c0c67);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x0010a2ad);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x000001a8);
+	}
+	else if (bandwidth==2) {// 6MHz
+	    apb_write_reg(2, 0x2c ,0x2D9);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x05C);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x161);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x00E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x2D4);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x08B);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x3B8);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x06B);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x2CD);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0C0);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x31E);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x05F);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x2C7);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0E3);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x2EB);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x05A);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x2C1);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0F8);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x2DA);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04B);// ACF_STAGE5_GAIN
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003f2fff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003d87cb);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003bdf96);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x003a2f60);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x00387f2a);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x0036c6f4);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x00350ebd);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x00334684);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x0031764b);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002f9e11);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x002db5d4);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x002bbd97);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x0029b557);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x00279515);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x00255ccf);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x00230c87);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x0020943a);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x001debe8);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x001b1b91);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x00180b33);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x0014aacc);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x0010e25a);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x000c91da);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x00078945);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x00031895);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x003fa82e);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x003bbfb8);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x00371730);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x0031668c);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x00299dbc);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x001d1480);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x00119acf);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x000001c4);
+	}
+	else {
+	    apb_write_reg(2, 0x2c ,0x2B9);// ACF_STAGE1_A1
+	    apb_write_reg(2, 0x2d ,0x06E);// ACF_STAGE1_A2
+	    apb_write_reg(2, 0x2e ,0x11E);// ACF_STAGE1_B1
+	    apb_write_reg(2, 0x2f ,0x01E);// ACF_STAGE1_GAIN
+	    apb_write_reg(2, 0x30 ,0x2AB);// ACF_STAGE2_A1
+	    apb_write_reg(2, 0x31 ,0x099);// ACF_STAGE2_A2
+	    apb_write_reg(2, 0x32 ,0x351);// ACF_STAGE2_B1
+	    apb_write_reg(2, 0x33 ,0x06B);// ACF_STAGE2_GAIN
+	    apb_write_reg(2, 0x34 ,0x29D);// ACF_STAGE3_A1
+	    apb_write_reg(2, 0x35 ,0x0C8);// ACF_STAGE3_A2
+	    apb_write_reg(2, 0x36 ,0x2D0);// ACF_STAGE3_B1
+	    apb_write_reg(2, 0x37 ,0x05F);// ACF_STAGE3_GAIN
+	    apb_write_reg(2, 0x38 ,0x292);// ACF_STAGE4_A1
+	    apb_write_reg(2, 0x39 ,0x0E7);// ACF_STAGE4_A2
+	    apb_write_reg(2, 0x3a ,0x2A8);// ACF_STAGE4_B1
+	    apb_write_reg(2, 0x3b ,0x05A);// ACF_STAGE4_GAIN
+	    apb_write_reg(2, 0x3c ,0x28A);// ACF_STAGE5_A1
+	    apb_write_reg(2, 0x3d ,0x0F9);// ACF_STAGE5_A2
+	    apb_write_reg(2, 0x3e ,0x29B);// ACF_STAGE5_B1
+	    apb_write_reg(2, 0x3f ,0x04B);// ACF_STAGE5_GAIN
+
+	    apb_write_reg(2, 0xfe, 0x000);apb_write_reg(2, 0xff, 0x003f2fff);
+	    apb_write_reg(2, 0xfe, 0x001);apb_write_reg(2, 0xff, 0x003d7fca);
+	    apb_write_reg(2, 0xfe, 0x002);apb_write_reg(2, 0xff, 0x003bcf94);
+	    apb_write_reg(2, 0xfe, 0x003);apb_write_reg(2, 0xff, 0x003a1f5e);
+	    apb_write_reg(2, 0xfe, 0x004);apb_write_reg(2, 0xff, 0x00386727);
+	    apb_write_reg(2, 0xfe, 0x005);apb_write_reg(2, 0xff, 0x0036a6f0);
+	    apb_write_reg(2, 0xfe, 0x006);apb_write_reg(2, 0xff, 0x0034e6b8);
+	    apb_write_reg(2, 0xfe, 0x007);apb_write_reg(2, 0xff, 0x0033167f);
+	    apb_write_reg(2, 0xfe, 0x008);apb_write_reg(2, 0xff, 0x00314645);
+	    apb_write_reg(2, 0xfe, 0x009);apb_write_reg(2, 0xff, 0x002f660a);
+	    apb_write_reg(2, 0xfe, 0x00a);apb_write_reg(2, 0xff, 0x002d75cd);
+	    apb_write_reg(2, 0xfe, 0x00b);apb_write_reg(2, 0xff, 0x002b758e);
+	    apb_write_reg(2, 0xfe, 0x00c);apb_write_reg(2, 0xff, 0x0029654e);
+	    apb_write_reg(2, 0xfe, 0x00d);apb_write_reg(2, 0xff, 0x0027450a);
+	    apb_write_reg(2, 0xfe, 0x00e);apb_write_reg(2, 0xff, 0x002504c4);
+	    apb_write_reg(2, 0xfe, 0x00f);apb_write_reg(2, 0xff, 0x0022a47b);
+	    apb_write_reg(2, 0xfe, 0x010);apb_write_reg(2, 0xff, 0x0020242d);
+	    apb_write_reg(2, 0xfe, 0x011);apb_write_reg(2, 0xff, 0x001d7bdb);
+	    apb_write_reg(2, 0xfe, 0x012);apb_write_reg(2, 0xff, 0x001aa383);
+	    apb_write_reg(2, 0xfe, 0x013);apb_write_reg(2, 0xff, 0x00178b24);
+	    apb_write_reg(2, 0xfe, 0x014);apb_write_reg(2, 0xff, 0x00142abd);
+	    apb_write_reg(2, 0xfe, 0x015);apb_write_reg(2, 0xff, 0x0010624a);
+	    apb_write_reg(2, 0xfe, 0x016);apb_write_reg(2, 0xff, 0x000c11ca);
+	    apb_write_reg(2, 0xfe, 0x017);apb_write_reg(2, 0xff, 0x00070935);
+	    apb_write_reg(2, 0xfe, 0x018);apb_write_reg(2, 0xff, 0x00029885);
+	    apb_write_reg(2, 0xfe, 0x019);apb_write_reg(2, 0xff, 0x003f281e);
+	    apb_write_reg(2, 0xfe, 0x01a);apb_write_reg(2, 0xff, 0x003b3fa9);
+	    apb_write_reg(2, 0xfe, 0x01b);apb_write_reg(2, 0xff, 0x00369720);
+	    apb_write_reg(2, 0xfe, 0x01c);apb_write_reg(2, 0xff, 0x0030ce7b);
+	    apb_write_reg(2, 0xfe, 0x01d);apb_write_reg(2, 0xff, 0x0028dda7);
+	    apb_write_reg(2, 0xfe, 0x01e);apb_write_reg(2, 0xff, 0x001c6464);
+	    apb_write_reg(2, 0xfe, 0x01f);apb_write_reg(2, 0xff, 0x0011b2c7);
+	    apb_write_reg(2, 0xfe, 0x020);apb_write_reg(2, 0xff, 0x000001cb);
+	}
+    }
+}
+
+static void dvbt_reg_initial(struct aml_demod_sta *demod_sta)
+{
+    u32 clk_freq;
+    u32 adc_freq;
+    u8  ch_mode;
+    u8  agc_mode;
+    u32 ch_freq;
+    u16 ch_if;
+    u16 ch_bw;
+    u16 symb_rate;
+
+    u8  bw;
+    u8  sr;
+    u8  ifreq;
+    u32 tmp;
+
+    clk_freq  = demod_sta->clk_freq ; // kHz
+    adc_freq  = demod_sta->adc_freq ; // kHz
+    ch_mode   = demod_sta->ch_mode  ;
+    agc_mode  = demod_sta->agc_mode ;
+    ch_freq   = demod_sta->ch_freq  ; // kHz
+    ch_if     = demod_sta->ch_if    ; // kHz
+    ch_bw     = demod_sta->ch_bw    ; // kHz
+    symb_rate = demod_sta->symb_rate; // k/sec
+
+    bw = 8 - ch_bw/1000;
+    sr = adc_freq > 40000 ? 3 :	adc_freq > 24000 ? 2 :
+	adc_freq > 20770 ? 1 : 0;
+    ifreq = ch_if > 35000 ? 0 : 1;
+
+    //////////////////////////////////////
+    // bw == 0 : 8M
+    //       1 : 7M
+    //       2 : 6M
+    //       3 : 5M
+    // sr == 0 : 20.7M
+    //       1 : 20.8333M
+    //       2 : 28.5714M
+    //       3 : 45M
+    // ifreq == 0: 36.13MHz
+    //          1: 4.57MHz
+    // agc_mode == 0: single AGC
+    //             1: dual AGC
+    //////////////////////////////////////
+    apb_write_reg(2, 0x02, 0x00800000);  // SW reset bit[23] ; write anything to zero
+    apb_write_reg(2, 0x00, 0x00000000);
+
+    switch (sr) {
+    case 0: apb_write_reg(2, 0x08, 0x00002966);break;
+    case 1: apb_write_reg(2, 0x08, 0x00002999);break;
+    case 2: apb_write_reg(2, 0x08, 0x00003924);break;
+    case 3: apb_write_reg(2, 0x08, 0x00005a00);break;  // sample_rate	//45M
+    default : break;
+    }
+
+    apb_write_reg(2, 0x0d, 0x00000000);
+    apb_write_reg(2, 0x0e, 0x00000000);
+    dvbt_enable_irq( 8 );
+
+    apb_write_reg(2, 0x11, 0x00100002);   // FSM [15:0] TIMER_FEC_LOST
+    apb_write_reg(2, 0x12, 0x02100201);   // FSM
+    apb_write_reg(2, 0x14, 0xe81c4ff6);   // AGC_TARGET 0xf0121385
+    apb_write_reg(2, 0x15, 0x02050ca6);   // AGC_CTRL
+
+    switch (sr) {
+    case 0: apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0x5b << 12));break;
+    case 1: apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0x5b << 12));break;
+    case 2: apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0x7b << 12));break;
+    case 3: apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0xc2 << 12));break;  // sample_rate	//45M
+    default : break;
+    }
+
+    if (agc_mode ==0) apb_write_reg(2, 0x16, 0x67f80);  // AGC_IFGAIN_CTRL
+    else if (agc_mode ==1) apb_write_reg(2, 0x16, 0x07f80);  // AGC_IFGAIN_CTRL
+
+    apb_write_reg(2, 0x17, 0x07f80);  // AGC_RFGAIN_CTRL
+    apb_write_reg(2, 0x18, 0x00000000);  // AGC_IFGAIN_ACCUM
+    apb_write_reg(2, 0x19, 0x00000000);  // AGC_RFGAIN_ACCUM
+
+    /*
+    if (ifreq == 0){
+    	switch (sr){
+	case 0: apb_write_reg(2, 0x20, 0x00002096);break;  // DDC NORM_PHASE    36.13M IF  For 20.7M sample rate
+        case 1: apb_write_reg(2, 0x20, 0x000021a9);break;  // DDC NORM_PHASE    36.13M IF  For 20.8333M sample rate
+        case 2: apb_write_reg(2, 0x20, 0x000021dc);break;  // DDC NORM_PHASE    36.13M IF  For 28.57142M sample rate
+        case 3: apb_write_reg(2, 0x20, 0x000066e2);break;  // DDC NORM_PHASE    36.13M IF  For 45M sample rate
+        default :break;
+	}
+    }
+    else if (ifreq == 1){
+    	switch (sr){
+	case 0: apb_write_reg(2, 0x20, 0x00001c42);break;  // DDC NORM_PHASE    4.57M IF  For 20.7M sample rate
+        case 1: apb_write_reg(2, 0x20, 0x00001c1f);break;  // DDC NORM_PHASE    4.57M IF  For 20.8333M sample rate
+        case 2: apb_write_reg(2, 0x20, 0x00001479);break;  // DDC NORM_PHASE    4.57M IF  For 28.57142M sample rate
+        case 3: apb_write_reg(2, 0x20, 0x0000d00);break;  // DDC NORM_PHASE    4.57M IF  For 45M sample rate
+        default : break;
+	}
+    }
+    */
+
+    tmp = ch_if * (1<<15) / adc_freq;
+    tmp &= 0x3fff;
+    apb_write_reg(2, 0x20, tmp);
+    if (demod_sta->debug)
+	printk("IF: %d kHz  ADC: %d kHz  DDC: %04x\n", ch_if, adc_freq, tmp);
+
+    apb_write_reg(2, 0x21, 0x001ff000);  // DDC CS_FCFO_ADJ_CTRL
+    apb_write_reg(2, 0x22, 0x00000000);  // DDC ICFO_ADJ_CTRL
+    apb_write_reg(2, 0x23, 0x00004000);  // DDC TRACK_FCFO_ADJ_CTRL
+    apb_write_reg(2, 0x27, 0x00a98200);
+    // [23] agc state mode [22:19] icfo_time_limit ;[18:15] tps_time_limit ;[14:4] cs_cfo_thres ;  [3:0] fsm_state_d;
+    //            1              010,1                   001,1                000,0010,0000,                xxxx
+    apb_write_reg(2, 0x28, 0x04028032);
+    // [31:24] cs_Q_thres; [23:13] sfo_thres;  FSM [12:0] fcfo_thres;;
+    //      0000,0100,        0000,0010,100          0,0000,0011,0010
+    apb_write_reg(2, 0x29, 0x0051117F);
+    //apb_write_reg(2, 0x29, 0x00010f7F);
+    //  [18:16] fec_rs_sh_ctrl ;[15:9] fsm_total_timer;[8:6] modeDet_time_limit; FSM [5:0] sfo_time_limit; ;
+    //        01,                ()   0000,111             1,01                     11,1111
+
+    // SRC NORM_INRATE
+    switch(bw){
+    case 0: tmp = (1 << 14) * adc_freq / 125 / 8 * 7;break;
+    case 1: tmp = (1 << 14) * adc_freq / 125;break;
+    case 2: tmp = (1 << 14) * adc_freq / 125 / 6 * 7;break;
+    case 3: tmp = (1 << 14) * adc_freq / 125 / 5 * 7;break;
+    default:	tmp = (1 << 14) * adc_freq / 125 / 8 * 7;break;
+    }
+    apb_write_reg(2, 0x44, tmp&0x7fffff);
+
+    apb_write_reg(2, 0x45, 0x00000000);  // SRC SRC_PHASE_INI
+    apb_write_reg(2, 0x46, 0x02004000);  // SRC SFO_ADJ_CTRL SFO limit 0x100!!
+    apb_write_reg(2, 0x48, 0xc0287);     // DAGC_CTRL
+    apb_write_reg(2, 0x49, 0x00000005);  // DAGC_CTRL1
+    apb_write_reg(2, 0x4c, 0x00000bbf);  // CCI_RP
+    apb_write_reg(2, 0x4d, 0x00000376);  // CCI_RPSQ
+    apb_write_reg(2, 0x4e, 0x00202109);  // CCI_CTRL
+    apb_write_reg(2, 0x52, 0x00000000);  // CCI_NOTCH1_A2
+    apb_write_reg(2, 0x53, 0x00000000);  // CCI_NOTCH1_B1
+    apb_write_reg(2, 0x54, 0x00c00000);  // CCI_NOTCH2_A1
+    apb_write_reg(2, 0x55, 0x00000000);  // CCI_NOTCH2_A2
+    apb_write_reg(2, 0x56, 0x00000000);  // CCI_NOTCH2_B1
+    apb_write_reg(2, 0x57, 0x00000000);  // CCI_NOTCH2_B1
+    apb_write_reg(2, 0x58, 0x00000886);  // MODE_DETECT_CTRL
+    apb_write_reg(2, 0x5c, 0x00001011);  // ICFO_EST_CTRL
+    apb_write_reg(2, 0x5f, 0x00010503);  // TPS_FCFO_CTRL
+    apb_write_reg(2, 0x61, 0x00000003);  // DE_PN_CTRL
+    apb_write_reg(2, 0x61, apb_read_reg(2, 0x61) | (1<<2));  // DE_PN_CTRL SP sync close , Use TPS only ;
+    apb_write_reg(2, 0x68, 0x004060c0);  // CHAN_EST_CTRL0
+    apb_write_reg(2, 0x68, apb_read_reg(2, 0x68) &~(1<<7));  // SNR report filter;
+    //apb_write_reg(2, 0x68, apb_read_reg(2, 0x68) &~(1<<13));  // Timing Adjust Shutdown;
+    apb_write_reg(2, 0x69, 0x148c3812);  // CHAN_EST_CTRL1
+    //apb_write_reg(2, 0x69, apb_read_reg(2, 0x69) | (1<<10));  // Disable FD data update
+    //apb_write_reg(2, 0x69, apb_read_reg(2, 0x69) | (1<<9));  // set FD coeff
+    //apb_write_reg(2, 0x69, apb_read_reg(2, 0x69) | (1<<8));  // set TD coeff
+    apb_write_reg(2, 0x6a, 0x9101012d);  // CHAN_EST_CTRL2
+    apb_write_reg(2, 0x6b, 0x00442211);  // CHAN_EST_CTRL2
+    apb_write_reg(2, 0x6c, 0x01fc040a);  // CHAN_EST_CTRL3
+    apb_write_reg(2, 0x6d, 0x0030303f);  // SET SNR THRESHOLD
+    apb_write_reg(2, 0x73, 0xffffffff);  // CCI0_PILOT_UPDATE_CTRL
+    apb_write_reg(2, 0x74, 0xffffffff);  // CCI0_DATA_UPDATE_CTRL
+    apb_write_reg(2, 0x75, 0xffffffff);  // CCI1_PILOT_UPDATE_CTRL
+    apb_write_reg(2, 0x76, 0xffffffff);  // CCI1_DATA_UPDATE_CTRL
+
+    // Set ACF and ACFEQ coeffecient
+    switch(sr){
+    case 0: set_ACF_coef(21, bw);break;
+    case 1: set_ACF_coef(21, bw);break;
+    case 2: set_ACF_coef(28, bw);break;
+    case 3: set_ACF_coef(45, bw);break;
+    default : break;
+    }
+    apb_write_reg(2, 0x78, 0x000001a2);  // FEC_CTRL  parallel mode ; [27:24] is TS clk/valid/sync/error
+    apb_write_reg(2, 0x7d, 0x0000009d);
+    apb_write_reg(2, 0xd6, 0x00000003);
+    apb_write_reg(2, 0xd7, 0x00000008);
+    apb_write_reg(2, 0xd8, 0x00000120);
+    apb_write_reg(2, 0xd9, 0x01010101);
+    apb_write_reg(2, 0x04, 0x00000000);  // TPS Current, QPSK, none Hierarchy, HP, LP 1/2
+
+    tmp = (1<<25) | ((bw&3)<<20) | (1<<16) | (1<<1);
+    apb_write_reg(2, 0x02, tmp);
+    apb_write_reg(2, 0x03, (1<<6)); // Cordic parameter Calc
+
+    udelay(1);
+
+    tmp = apb_read_reg(2, 0x02);
+    tmp |= (1<<24) | 1; // FSM, Demod enable.
+    apb_write_reg(2, 0x02, tmp);
+}
+
+
+int dvbt_set_ch(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_dvbt *demod_dvbt)
+{
+    int ret = 0;
+    u8 bw, sr, ifreq, agc_mode;
+    u32 ch_freq;
+
+    bw       = demod_dvbt->bw;
+    sr       = demod_dvbt->sr;
+    ifreq    = demod_dvbt->ifreq;
+    agc_mode = demod_dvbt->agc_mode;
+    ch_freq  = demod_dvbt->ch_freq;
+
+    // Set registers
+    //////////////////////////////////////
+    // bw == 0 : 8M
+    //       1 : 7M
+    //       2 : 6M
+    //       3 : 5M
+    // sr == 0 : 20.7M
+    //       1 : 20.8333M
+    //       2 : 28.5714M
+    //       3 : 45M
+    // ifreq == 0: 36.13MHz
+    //          1: 4.57MHz
+    // agc_mode == 0: single AGC
+    //             1: dual AGC
+    //////////////////////////////////////
+    if (bw > 3) {
+    	printk("Error: Invalid Bandwidth option %d\n", bw);
+	bw = 0;
+	ret = -1;
+    }
+
+    if (sr > 3) {
+    	printk("Error: Invalid Sampling Freq option %d\n", sr);
+	sr = 2;
+	ret = -1;
+    }
+
+    if (ifreq > 1) {
+    	printk("Error: Invalid IFreq option %d\n", ifreq);
+	ifreq = 0;
+	ret = -1;
+    }
+
+    if (agc_mode > 3) {
+    	printk("Error: Invalid AGC mode option %d\n", agc_mode);
+	agc_mode = 0;
+	ret = -1;
+    }
+
+    // if (ret != 0) return ret;
+
+    // Set DVB-T
+    (*DEMOD_REG0) |= 1;
+
+    demod_sta->dvb_mode  = 1;
+    demod_sta->ch_mode   = 0; // TODO
+    demod_sta->agc_mode  = agc_mode;
+    demod_sta->ch_freq   = ch_freq;
+    if (demod_i2c->tuner == 1)
+	demod_sta->ch_if = 36130;
+    else if (demod_i2c->tuner == 2)
+	demod_sta->ch_if = 4570;
+
+    demod_sta->ch_bw     = (8-bw)*1000;
+    demod_sta->symb_rate = 0; // TODO
+
+    // Set Tuner
+    if (ch_freq<1000 || ch_freq>900000) {
+	    printk("Error: Invalid Channel Freq option %d, Skip Set tuner\n", ch_freq);
+	    //ch_freq = 474000;
+	    ret = -1;
+    }
+    else    {
+  //  tuner_set_ch(demod_sta, demod_i2c);
+    }
+
+
+    if ((ch_freq%100)==2) {
+    	printk("Input frequency is XXX002, Skip initial demod\n");
+    }
+    else{
+    dvbt_reg_initial(demod_sta);
+    }
+
+    dvbt_enable_irq(7);// open symbolhead int
+
+    tuner_type = demod_i2c->tuner;
+
+    return ret;
+}
+
+static int dvbt_get_ch_power(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+    u32 ad_power;
+    ad_power = agc_power_to_dbm((apb_read_reg(2, 0x1c)&0x7ff),apb_read_reg(2, 0x1b)&0x1ff,0,demod_i2c->tuner);
+    return ad_power;
+}
+
+int dvbt_sfo(void)
+{
+    int sfo;
+    sfo             =  apb_read_reg(2, 0x47)&0xfff    ;
+    sfo             = (sfo>0x7ff)? (sfo - 0x1000): sfo;
+    return (sfo);
+}
+
+int dvbt_fcfo(void)
+{
+    int fcfo;
+    fcfo            = (apb_read_reg(2, 0x26))&0xffffff    ;
+    fcfo            = (fcfo>0x7fffff)? (fcfo - 0x1000000): fcfo;
+    return (fcfo);
+}
+
+static int dvbt_total_packet_error(void){return (apb_read_reg(2, 0xbf));}
+static int dvbt_super_frame_counter(void){return (apb_read_reg(2, 0xc0)&0xfffff);}
+static int dvbt_packet_correct_in_sframe(void){ return( apb_read_reg(2, 0xc1)&0xfffff );}
+//static int dvbt_resync_counter(void){return((apb_read_reg(2, 0xc0)>>20)&0xff);}
+
+static int dvbt_packets_per_sframe(void)
+{
+    u32 tmp;
+    int hier_mode;
+    int constel;
+    int hp_code_rate;
+    int lp_code_rate;
+    int hier_sel;
+    int code_rate;
+    int ret;
+
+    tmp = apb_read_reg(2, 0x06);
+    constel = tmp>>13&3;
+    hier_mode = tmp>>10&7;
+    hp_code_rate = tmp>>7&7;
+    lp_code_rate = tmp>>4&7;
+
+    if (hier_mode == 0)	{
+	code_rate = hp_code_rate;
+    }
+    else {
+	tmp = apb_read_reg(2, 0x78);
+	hier_sel = tmp>>9&1;
+	if (hier_sel == 0) {
+	    constel = 0; // QPSK;
+	    code_rate = hp_code_rate;
+	}
+	else {
+	    constel = constel==2 ? 1 : 0;
+	    code_rate = lp_code_rate;
+	}
+    }
+
+    switch(code_rate){
+    case      0 : ret = (constel==0)?1008:(constel==1)?2016:3024; break;
+    case      1 : ret = (constel==0)?1344:(constel==1)?2688:4032; break;
+    case      2 : ret = (constel==0)?1512:(constel==1)?3024:4536; break;
+    case      3 : ret = (constel==0)?1680:(constel==1)?3360:5040; break;
+    case      4 : ret = (constel==0)?1764:(constel==1)?3528:5292; break;
+    default: ret = (constel==0)?1008:(constel==1)?2016:3024; break;
+    }
+    return ret;
+}
+
+static int dvbt_get_per(void)
+{
+    int packets_per_sframe;
+    int error;
+    int per;
+
+    packets_per_sframe = dvbt_packets_per_sframe();
+    error = packets_per_sframe - dvbt_packet_correct_in_sframe();
+    per = 1000*error/packets_per_sframe;
+
+    return (per);
+}
+
+static void dvbt_set_test_bus(u8 sel)
+{
+    u32 tmp;
+
+    tmp = apb_read_reg(2, 0x7f);
+    tmp &= ~(0x1f);
+    tmp |= ((1<<15) | (1<<5) | (sel&0x1f));
+    apb_write_reg(2, 0x7f, tmp);
+}
+/*
+void dvbt_get_test_out(u8 sel, u32 len, u32 *buf)
+{
+    int i;
+
+    dvbt_set_test_bus(sel);
+
+    for (i=0; i<len; i++) {
+	buf[i] = apb_read_reg(2, 0x13);
+    }
+}
+*/
+void dvbt_get_test_out(u8 sel, u32 len, u32 *buf)
+{
+    int i, cnt;
+
+    dvbt_set_test_bus(sel);
+
+    for (i=0, cnt=0; i<len-4 && cnt<1000000; i++) {
+	buf[i] = apb_read_reg(2, 0x13);
+	if ((buf[i]>>10)&0x1) {
+	    buf[i++] = apb_read_reg(2, 0x13);
+	    buf[i++] = apb_read_reg(2, 0x13);
+	    buf[i++] = apb_read_reg(2, 0x13);
+	    buf[i++] = apb_read_reg(2, 0x13);
+	    buf[i++] = apb_read_reg(2, 0x13);
+	    buf[i++] = apb_read_reg(2, 0x13);
+	    buf[i++] = apb_read_reg(2, 0x13);
+	    buf[i++] = apb_read_reg(2, 0x13);
+	}
+	else {
+	    i--;
+	}
+
+	cnt++;
+    }
+}
+
+static int dvbt_get_avg_per(void)
+{
+    int packets_per_sframe;
+    static int err_last;
+    static int err_now;
+    static int rsnum_now;
+    static int rsnum_last;
+    int per;
+
+    packets_per_sframe = dvbt_packets_per_sframe();
+    rsnum_last = rsnum_now;
+    rsnum_now  = dvbt_super_frame_counter();
+    err_last   = err_now;
+    err_now    = dvbt_total_packet_error();
+    if (rsnum_now != rsnum_last)
+        per = 1000*(err_now - err_last) /
+	    ((rsnum_now-rsnum_last)*packets_per_sframe);
+    else
+        per = 123;
+
+    return (per);
+}
+
+int dvbt_status(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c,
+		struct aml_demod_sts *demod_sts)
+{
+    // if parameters are needed to calc, pass the struct to func.
+    // all small funcs like read_snr() should be static.
+
+    demod_sts->ch_snr = apb_read_reg(2, 0x0a);
+    demod_sts->ch_per = dvbt_get_per();
+    demod_sts->ch_pow = dvbt_get_ch_power(demod_sta, demod_i2c);
+    demod_sts->ch_ber = apb_read_reg(2, 0x0b);
+    demod_sts->ch_sts = apb_read_reg(2, 0);
+    demod_sts->dat0   = dvbt_get_avg_per();
+    demod_sts->dat1   = apb_read_reg(2, 0x06);
+    return 0;
+}
+
+
+static int dvbt_get_status(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+	return apb_read_reg(2, 0x0)>>12&1;
+}
+
+static int dvbt_ber(void);
+
+static int dvbt_get_ber(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+	return dvbt_ber();/*unit: 1e-7*/
+}
+
+static int dvbt_get_snr(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+	return apb_read_reg(2,0x0a)&0x3ff;/*dBm: bit0~bit2=decimal*/
+}
+
+static int dvbt_get_strength(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+	int dbm = dvbt_get_ch_power(demod_sta, demod_i2c);
+	return dbm;
+}
+
+static int dvbt_get_ucblocks(struct aml_demod_sta *demod_sta,
+		struct aml_demod_i2c *demod_i2c)
+{
+	return dvbt_get_per();
+}
+
+struct demod_status_ops* dvbt_get_status_ops(void)
+{
+	static struct demod_status_ops ops = {
+		.get_status = dvbt_get_status,
+		.get_ber = dvbt_get_ber,
+		.get_snr = dvbt_get_snr,
+		.get_strength = dvbt_get_strength,
+		.get_ucblocks = dvbt_get_ucblocks,
+	};
+
+	return &ops;
+}
+
+void dvbt_enable_irq(int dvbt_irq)
+{
+    // clear status & enable irq
+    (*OFDM_INT_STS) &= ~(1<<dvbt_irq);
+    (*OFDM_INT_EN) |= (1<<dvbt_irq);
+}
+
+void dvbt_disable_irq(int dvbt_irq)
+{
+    // disable irq & clear status
+    (*OFDM_INT_EN) &= ~(1<<dvbt_irq);
+    (*OFDM_INT_STS) &= ~(1<<dvbt_irq);
+}
+
+char *dvbt_irq_name[] = {
+    "PFS_FCFO",
+    "PFS_ICFO",
+    " CS_FCFO",
+    " PFS_SFO",
+    " PFS_TPS",
+    "      SP",
+    "     CCI",
+    "  Symbol",
+    " In_Sync",
+    "Out_Sync",
+    "FSM Stat"};
+
+void dvbt_isr(struct aml_demod_sta *demod_sta)
+{
+    u32 stat, mask;
+    int dvbt_irq;
+
+    stat = (*OFDM_INT_STS);
+    mask = (*OFDM_INT_EN);
+    stat &= mask;
+
+    for (dvbt_irq=0; dvbt_irq<11; dvbt_irq++) {
+	if (stat>>dvbt_irq&1) {
+	    if (demod_sta->debug)
+		printk("irq: aml_demod dvbt %2d %s %8x %8x\n",
+		       dvbt_irq, dvbt_irq_name[dvbt_irq], stat, mask);
+	    // dvbt_disable_irq(dvbt_irq);
+	}
+    }
+    // clear status
+    (*OFDM_INT_STS) = 0;
+}
+
+
+static int demod_monitor_ave(void);
+int dvbt_isr_islock(void)
+{
+#define IN_SYNC_MASK (0x100)
+
+    u32 stat, mask;
+
+    stat = (*OFDM_INT_STS);
+    *OFDM_INT_STS = stat & (~IN_SYNC_MASK);
+
+    mask = (*OFDM_INT_EN);
+    stat &= mask;
+
+    return ((stat&IN_SYNC_MASK)==IN_SYNC_MASK);
+}
+
+
+int dvbt_isr_monitor(void)
+{
+#define SYM_HEAD_MASK (0x80)
+	u32 stat, mask;
+
+	stat = (*OFDM_INT_STS);
+	*OFDM_INT_STS = stat & (~SYM_HEAD_MASK);
+
+	mask = (*OFDM_INT_EN);
+	stat &= mask;
+
+	if ((stat&SYM_HEAD_MASK) == SYM_HEAD_MASK) // symbol_head int
+		demod_monitor_ave();
+
+	return 0;
+}
+
+int dvbt_isr_cancel(void)
+{
+	*OFDM_INT_STS = 0;
+	*OFDM_INT_EN = 0;
+	return 0;
+}
+
+static int demod_monitor_instant(void)
+{
+     int SNR;
+     int SNR_SP          = 500;
+     int SNR_TPS         = 0;
+     int SNR_CP          = 0;
+     int SFO_residual    = 0;
+     int SFO_esti        = 0;
+     int FCFO_esti       = 0;
+     int FCFO_residual   = 0;
+     int AGC_Gain        = 0;
+     int be_vit_error    = 0;
+     int Signal_power    = 0;
+     int FECFlag         = 0;
+     int EQ_seg_ratio    = 0;
+     int tps_0           = 0;
+     int tps_1           = 0;
+     int tps_2           = 0;
+     int cci_blank       = 0;
+
+     int SFO                ;
+     int FCFO               ;
+     int timing_adj         ;
+     int RS_CorrectNum      ;
+     int RS_Error_sum       ;
+     int resync_times       ;
+     int tps_summary        ;
+
+     int tps_window         ;
+     int tps_guard          ;
+     int tps_constell       ;
+     int tps_Hier_none      ;
+     int tps_Hier_alpha     ;
+     int tps_HP_cr          ;
+     int tps_LP_cr          ;
+
+
+     int tmpAGCGain;
+
+     // Read Registers
+     SNR             = apb_read_reg(2,0x0a)              ;
+     FECFlag         = (apb_read_reg(2,0x00)>>11)&0x3     ;
+     SFO             = apb_read_reg(2,0x47)&0xfff        ;
+     SFO_esti        = apb_read_reg(2,0x60)&0xfff        ;
+     FCFO_esti       = (apb_read_reg(2,0x60)>>11)&0xfff   ;
+     FCFO            = (apb_read_reg(2,0x26))&0xffffff    ;
+     be_vit_error    = apb_read_reg(2,0x0c)&0x1fff       ;
+     timing_adj      = apb_read_reg(2,0x6f)&0x1fff       ;
+     RS_CorrectNum   = apb_read_reg(2,0xc1)&0xfffff      ;
+     Signal_power    = (apb_read_reg(2,0x1b))&0x1ff       ;
+     EQ_seg_ratio    = apb_read_reg(2,0x6e)&0x3ffff      ;
+     tps_0           = apb_read_reg(2,0x64);
+     tps_1           = apb_read_reg(2,0x65);
+     tps_2           = apb_read_reg(2,0x66)&0xf;
+     tps_summary     = apb_read_reg(2,0x04)&0x7fff;
+     cci_blank       = (apb_read_reg(2,0x66)>>16);
+     RS_Error_sum    = apb_read_reg(2,0xbf)&0x3ffff;
+     resync_times    = (apb_read_reg(2,0xc0)>>20)&0xff;
+     AGC_Gain        = apb_read_reg(2,0x1c)&0x7ff;
+
+     // Calc
+     SFO_residual    = (SFO>0x7ff)? (SFO - 0x1000): SFO;
+     FCFO_residual   = (FCFO>0x7fffff)? (FCFO - 0x1000000): FCFO;
+     FCFO_esti       = (FCFO_esti>0x7ff)?(FCFO_esti - 0x1000):FCFO_esti;
+     SNR_CP          = (SNR)&0x3ff;
+     SNR_TPS         = (SNR>>10)&0x3ff;
+     SNR_SP          = (SNR>>20)&0x3ff;
+     SNR_SP          = (SNR_SP  > 0x1ff)? SNR_SP - 0x400: SNR_SP;
+     SNR_TPS         = (SNR_TPS > 0x1ff)? SNR_TPS- 0x400: SNR_TPS;
+     SNR_CP          = (SNR_CP  > 0x1ff)? SNR_CP - 0x400: SNR_CP;
+     tmpAGCGain      = AGC_Gain;
+     timing_adj      = (timing_adj > 0xfff)? timing_adj - 0x2000: timing_adj;
+
+     tps_window      = (tps_summary&0x3);
+     tps_guard       = ((tps_summary>>2)&0x3);
+     tps_constell    = ((tps_summary>>13)&0x3);
+     tps_Hier_none   = (((tps_summary>>10)&0x7)==0)?1:0;
+     tps_Hier_alpha  = (tps_summary>>11)&0x3;
+     tps_Hier_alpha  = (tps_Hier_alpha==3)?4: tps_Hier_alpha;
+     tps_LP_cr       = (tps_summary>>4)&0x7;
+     tps_HP_cr       = (tps_summary>>7)&0x7;
+
+     printk("\n\n");
+     switch(tps_window){
+     case 0: printk("2K ");break;
+     case 1: printk("8K ");break;
+     case 2: printk("4K ");break;
+     default: printk("UnWin ");break;
+    }
+     switch(tps_guard){
+     case 0: printk("1/32 ");break;
+     case 1: printk("1/16 ");break;
+     case 2: printk("1/ 8 ");break;
+     case 3: printk("1/ 4 ");break;
+     default: printk("UnGuard ");break;
+     }
+     switch(tps_constell){
+     case 0: printk(" QPSK ");break;
+     case 1: printk("16QAM ");break;
+     case 2: printk("64QAM ");break;
+     default: printk("UnConstl ");break;
+     }
+     switch(tps_Hier_none){
+     case 0: printk("Hiera ");break;
+     case 1: printk("non-H ");break;
+     default: printk("UnHier ");break;
+    }
+     printk("%d ",tps_Hier_alpha);
+     printk("HP ");
+     switch(tps_HP_cr){
+     case 0: printk("1/2 ");break;
+     case 1: printk("2/3 ");break;
+     case 2: printk("3/4 ");break;
+     case 3: printk("5/6 ");break;
+     case 4: printk("7/8 ");break;
+     default: printk("UnHCr ");break;
+     }
+     printk("LP ");
+     switch(tps_LP_cr){
+     case 0: printk("1/2 ");break;
+     case 1: printk("2/3 ");break;
+     case 2: printk("3/4 ");break;
+     case 3: printk("5/6 ");break;
+     case 4: printk("7/8 ");break;
+     default: printk("UnLCr ");break;
+     }
+     printk("\n");
+     printk("P %4x ",RS_Error_sum);
+     printk("SP %2d ",SNR_SP);
+     printk("TPS %2d ",SNR_TPS);
+     printk("CP %2d ",SNR_CP);
+     printk("EQS %2x ",EQ_seg_ratio);
+     printk("RSC %4d ",RS_CorrectNum);
+     printk("SFO %3d ",SFO_residual);
+     printk("FCFO %4d ",FCFO_residual);
+     printk("Vit %3x ",be_vit_error);
+     printk("Timing %3d ",timing_adj);
+     printk("SigP %3x ",Signal_power);
+     printk("AGC %d ",tmpAGCGain);
+     printk("SigP %d ", agc_power_to_dbm(tmpAGCGain,  Signal_power,0, tuner_type));
+     printk("FEC %x ",FECFlag);
+     printk("ReSyn %x ",resync_times);
+     printk("cciB %x",cci_blank);
+
+     printk("\n");
+
+     return 0;
+
+}
+
+int serial_div(int a, int b)
+{
+	 int c;
+	 int cnt;
+	 int b_buf;
+	 if (b ==0)   return( 0x7fffffff);
+	 if (a ==0)   return( 0);
+
+	 c = 0;
+	 cnt = 0;
+
+	 a = (a <0)?-1*a:a;
+	 b = (b <0)?-1*b:b;
+
+	 b_buf = b;
+
+	 while (a >= b){
+	 	 b = b<<1;
+	 	 cnt++;
+ 	}
+ 	while (b > b_buf){
+ 		  b = b >> 1;
+ 		  c = c << 1;
+ 		  if (a > b) {
+ 		  	c = c + 1;
+ 		  	a = a - b;
+ 		  }
+ 	}
+ 	return c;
+
+}
+
+static int ave0, bit_unit_L;
+
+static int dvbt_ber(void)
+{
+	int BER_e_n7 = serial_div(ave0 * 40,bit_unit_L);
+	return BER_e_n7;
+}
+
+static int demod_monitor_ave(void)
+{
+  	static int i=0;
+  	static int ave[3]={0,0,0};
+
+ 	 ave[0] = ave[0] + (apb_read_reg(2,0x0b)&0x7ff);
+ 	 ave[1] = ave[1] + (apb_read_reg(2,0x0a)&0x3ff);
+ 	 ave[2] = ave[2] + (apb_read_reg(2,0x0c)&0x1fff);
+
+ 	 i ++;
+
+	if (i >= 8192)
+	{
+		int tps_mode;
+		int tps_constell;
+		int r_t;
+		int mode_L;
+		int const_L;
+		int SNR_Int;
+		int SNR_fra;
+
+		if(debug_amldvbt)
+			demod_monitor_instant();
+
+		r_t            = apb_read_reg(2,0x04);
+		tps_mode       = r_t&0x3;
+		tps_constell   = (r_t>>13)&0x3;
+		mode_L         = (tps_mode==0)?1: (tps_mode==1)?4 :2;
+		const_L        = (tps_constell==0)?2: (tps_constell==1)?4 :6;
+		bit_unit_L     = 189 * mode_L * const_L;
+		SNR_Int        = (ave[1]>>16);
+		switch((ave[1]>>13)&0x7) {
+		    case 0: SNR_fra = 0;break;
+		    case 1: SNR_fra = 125;break;
+		    case 2: SNR_fra = 250;break;
+		    case 3: SNR_fra = 375;break;
+		    case 4: SNR_fra = 500;break;
+		    case 5: SNR_fra = 625;break;
+		    case 6: SNR_fra = 750;break;
+		    case 7: SNR_fra = 875;break;
+		    default : SNR_fra = 0;break;
+		}
+
+		ave0 = ave[0];
+
+		if(debug_amldvbt)
+			printk("RSBi %d Thresh %d SNR %d.%d Vit %x \n\n",(ave[0]>>3)*5,(bit_unit_L*8),SNR_Int,SNR_fra,(ave[2]>>13));
+		i = 0;
+		ave[0]=ave[1]=ave[2]=0;
+
+   }
+
+   return i;
+}
+
+int dvbt_switch_to_HP(void)
+{
+	apb_write_reg(2, 0x78, apb_read_reg(2, 0x78) &~ (1<<9));
+	return 0;
+}
+
+int dvbt_switch_to_LP(void)
+{
+	apb_write_reg(2, 0x78, apb_read_reg(2, 0x78) | (1<<9));
+	return 0;
+}
+
+int dvbt_shutdown(void)
+{
+	apb_write_reg(2, 0x02, 0x00800000);  // SW reset bit[23] ; write anything to zero
+	apb_write_reg(2, 0x00, 0x00000000);
+	return 0;
+}
+
+int dvbt_get_params(struct aml_demod_sta *demod_sta,
+		      struct aml_demod_i2c *adap,
+		      	int  *code_rate_HP,  /* high priority stream code rate */
+			int  *code_rate_LP,  /* low priority stream code rate */
+			int  *constellation, /* modulation type (see above) */
+			int  *transmission_mode,
+			int  *guard_interval,
+			int  *hierarchy_information )
+{
+	int tps_summary,tps_window,tps_guard,tps_constell,tps_Hier_none;
+	int tps_Hier_alpha,tps_LP_cr,tps_HP_cr;
+
+	tps_summary     = apb_read_reg(2,0x04)&0x7fff;
+
+	tps_window      = (tps_summary&0x3);
+	tps_guard       = ((tps_summary>>2)&0x3);
+	tps_constell    = ((tps_summary>>13)&0x3);
+	tps_Hier_none   = (((tps_summary>>10)&0x7)==0)?1:0;
+	tps_Hier_alpha  = (tps_summary>>11)&0x3;
+	tps_Hier_alpha  = (tps_Hier_alpha==3)?4: tps_Hier_alpha;
+	tps_LP_cr       = (tps_summary>>4)&0x7;
+	tps_HP_cr       = (tps_summary>>7)&0x7;
+
+	if(code_rate_HP)
+		*code_rate_HP = tps_HP_cr;/*1/2:2/3:3/4:5/6:7/8*/
+	if(code_rate_LP)
+		*code_rate_LP = tps_LP_cr;/*1/2:2/3:3/4:5/6:7/8*/
+	if(constellation)
+		*constellation = tps_constell;/*QPSK/16QAM/64QAM*/
+	if(transmission_mode)
+		*transmission_mode = tps_window;/*2K/8K/4K*/
+	if(guard_interval)
+		*guard_interval = tps_guard;/*1/32:1/16:1/8:1/4*/
+	if(hierarchy_information)
+		*hierarchy_information = tps_Hier_alpha;/*1/2/4*/
+
+	return 0;
+}
+
+
diff --git a/drivers/amlogic/dvb_tv/amldemod/i2c_func.c b/drivers/amlogic/dvb_tv/amldemod/i2c_func.c
new file mode 100755
index 000000000000..e6c1d7f2630a
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/i2c_func.c
@@ -0,0 +1,446 @@
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include "aml_demod.h"
+#include "demod_func.h"
+
+// basic functions
+static void sw_i2c_setscl(struct aml_demod_i2c *adap, unsigned val)
+{
+    u32 oe, scl;
+
+    oe = *(volatile u32 *)(adap->scl_oe);
+    oe &= ~(1<<adap->scl_bit);
+    *(volatile u32 *)(adap->scl_oe) = oe;
+
+    scl = *(volatile u32 *)(adap->scl_out);
+    if(val)
+        scl |= (1<<(adap->scl_bit));
+    else
+        scl &= ~(1<<(adap->scl_bit));
+    *(volatile u32 *)(adap->scl_out) = scl;
+}
+
+static void sw_i2c_setsda(struct aml_demod_i2c *adap, unsigned val)
+{
+    u32 oe, sda;
+
+    oe = *(volatile u32 *)(adap->sda_oe);
+    oe &= ~(1<<adap->sda_bit);
+    *(volatile u32 *)(adap->sda_oe) = oe;
+
+    sda = *(volatile u32 *)(adap->sda_out);
+    if(val)
+        sda |= (1<<(adap->sda_bit));
+    else
+        sda &= ~(1<<(adap->sda_bit));
+    *(volatile u32 *)(adap->sda_out) = sda;
+}
+
+static int sw_i2c_getscl(struct aml_demod_i2c *adap)
+{
+    u32 oe, scl;
+
+    oe = *(volatile u32 *)(adap->scl_oe);
+    oe |= (1<<adap->scl_bit);
+    *(volatile u32 *)(adap->scl_oe) = oe;
+
+    scl = *(volatile u32 *)(adap->scl_in);
+    scl = (scl>>adap->scl_bit)&1;
+
+    return scl;
+}
+
+static int sw_i2c_getsda(struct aml_demod_i2c *adap)
+{
+    u32 oe, sda;
+
+    oe = *(volatile u32 *)(adap->sda_oe);
+    oe |= (1<<adap->sda_bit);
+    *(volatile u32 *)(adap->sda_oe) = oe;
+
+    sda = *(volatile u32 *)(adap->sda_in);
+    sda = (sda>>adap->sda_bit)&1;
+
+    return sda;
+}
+
+// set high/low with delay
+static inline void sdalo(struct aml_demod_i2c *adap)
+{
+    sw_i2c_setsda(adap, 0);
+    udelay(adap->udelay);
+}
+
+static inline void sdahi(struct aml_demod_i2c *adap)
+{
+    sw_i2c_setsda(adap, 1);
+    udelay(adap->udelay);
+}
+
+static inline void scllo(struct aml_demod_i2c *adap)
+{
+    sw_i2c_setscl(adap, 0);
+    udelay(adap->udelay);
+}
+
+static inline void sclhi(struct aml_demod_i2c *adap)
+{
+    sw_i2c_setscl(adap, 1);
+    udelay(adap->udelay);
+}
+
+// i2c patterns
+static void i2c_start(struct aml_demod_i2c *adap)
+{
+    sdahi(adap);
+    sclhi(adap);
+    sdalo(adap);
+    scllo(adap);
+}
+
+static void i2c_stop(struct aml_demod_i2c *adap)
+{
+    sdalo(adap);
+    sclhi(adap);
+    sdahi(adap);
+}
+
+static int i2c_outb(struct aml_demod_i2c *adap, unsigned char c)
+{
+    int i, sb, ack;
+
+    /* assert: scl is low */
+    for (i=7; i>=0; i--) {
+        sb = c>>i&1;
+
+        sw_i2c_setsda(adap, sb);
+        udelay(adap->udelay);
+        sclhi(adap);
+        scllo(adap);
+    }
+    sdahi(adap);
+    sclhi(adap);
+
+    ack = !sw_i2c_getsda(adap); /* ack: sda low -> success */
+    scllo(adap);
+
+    if (adap->debug) printk("i2c: out 0x%02x  ack %d\n", c, ack);
+
+    return ack;
+}
+
+static int i2c_inb(struct aml_demod_i2c *adap)
+{
+    int i;
+    unsigned char indata = 0;
+
+    /* assert: scl is low */
+    sdahi(adap);
+    for (i=0; i<8; i++) {
+        sclhi(adap);
+        indata *= 2;
+        if (sw_i2c_getsda(adap))
+            indata |= 0x01;
+        scllo(adap);
+    }
+    /* assert: scl is low */
+
+    if (adap->debug) printk("i2c: in  0x%02x\n", indata);
+
+    return indata;
+}
+
+static int aml_i2c_sw_test_bus(struct aml_demod_i2c *adap, char *name)
+{
+    int scl, sda;
+
+    sda = sw_i2c_getsda(adap);
+    scl = sw_i2c_getscl(adap);
+    if (!scl || !sda) {
+        printk("%s: bus seems to be busy\n", name);
+        goto bailout;
+    }
+
+    sdalo(adap);
+    sda = sw_i2c_getsda(adap);
+    scl = sw_i2c_getscl(adap);
+    if (sda) {
+        printk("%s: SDA stuck high!\n", name);
+        goto bailout;
+    }
+    if (!scl) {
+        printk("%s: SCL unexpected low while pulling SDA low!\n", name);
+        goto bailout;
+    }
+
+    sdahi(adap);
+    sda = sw_i2c_getsda(adap);
+    scl = sw_i2c_getscl(adap);
+    if (!sda) {
+        printk("%s: SDA stuck low!\n", name);
+        goto bailout;
+    }
+    if (!scl) {
+        printk("%s: SCL unexpected low while pulling SDA high!\n", name);
+        goto bailout;
+    }
+
+    scllo(adap);
+    sda = sw_i2c_getsda(adap);
+    scl = sw_i2c_getscl(adap);
+    if (scl) {
+        printk("%s: SCL stuck high!\n", name);
+        goto bailout;
+    }
+    if (!sda) {
+        printk("%s: SDA unexpected low while pulling SCL low!\n", name);
+        goto bailout;
+    }
+
+    sclhi(adap);
+    sda = sw_i2c_getsda(adap);
+    scl = sw_i2c_getscl(adap);
+    if (!scl) {
+        printk("%s: SCL stuck low!\n", name);
+        goto bailout;
+    }
+    if (!sda) {
+        printk("%s: SDA unexpected low while pulling SCL high!\n", name);
+        goto bailout;
+    }
+    if (adap->debug) printk("%s: Test OK\n", name);
+    return 0;
+
+bailout:
+    sdahi(adap);
+    sclhi(adap);
+    return -ENODEV;
+}
+
+static int try_address(struct aml_demod_i2c *adap,
+		       unsigned char addr, int retries)
+{
+    int i, ret = 0;
+
+    for (i=0; i<=retries; i++) {
+        ret = i2c_outb(adap, addr);
+        if (ret == 1 || i == retries)
+            break;
+        if (adap->debug) printk("emitting stop condition\n");
+        i2c_stop(adap);
+        udelay(adap->udelay);
+        if (adap->debug) printk("emitting start condition\n");
+        i2c_start(adap);
+    }
+    if (i && ret && adap->debug)
+	printk("Used %d tries to %s client at 0x%02x: %s\n",
+	       i + 1, addr & 1 ? "read from" : "write to", addr >> 1,
+	       ret == 1 ? "success" : "failed, timeout?");
+    return ret;
+}
+
+static int sendbytes(struct aml_demod_i2c *adap, struct i2c_msg *msg)
+{
+    unsigned char *temp = msg->buf;
+    int count = msg->len;
+    unsigned short nak_ok = msg->flags & I2C_M_IGNORE_NAK;
+    int retval;
+    int wrcount = 0;
+
+    while (count > 0) {
+        retval = i2c_outb(adap, *temp);
+
+        /* OK/ACK; or ignored NAK */
+        if ((retval > 0) || (nak_ok && (retval == 0))) {
+            count--;
+            temp++;
+            wrcount++;
+        } else if (retval == 0) {
+            printk("Error: sendbytes: NAK bailout.\n");
+            return -EIO;
+        } else {
+            printk("Error: sendbytes: error %d\n", retval);
+            return retval;
+        }
+    }
+    return wrcount;
+}
+
+static void acknak(struct aml_demod_i2c *adap, int is_ack)
+{
+    /* assert: sda is high */
+    if (is_ack) sw_i2c_setsda(adap, 0);
+    udelay(adap->udelay);
+    sclhi(adap);
+    scllo(adap);
+}
+
+static int readbytes(struct aml_demod_i2c *adap, struct i2c_msg *msg)
+{
+    int inval;
+    int rdcount = 0;    /* counts bytes read */
+    unsigned char *temp = msg->buf;
+    int count = msg->len;
+    const unsigned flags = msg->flags;
+
+    while (count > 0) {
+        inval = i2c_inb(adap);
+        if (inval >= 0) {
+            *temp = inval;
+            rdcount++;
+        } else {   /* read timed out */
+            break;
+        }
+
+        temp++;
+        count--;
+
+        /* Some SMBus transactions require that we receive the
+           transaction length as the first read byte. */
+        if (rdcount == 1 && (flags & I2C_M_RECV_LEN)) {
+            if (inval <= 0 || inval > I2C_SMBUS_BLOCK_MAX) {
+                if (!(flags & I2C_M_NO_RD_ACK)) acknak(adap, 0);
+                printk("Error: readbytes: invalid block length (%d)\n", inval);
+                return -EREMOTEIO;
+            }
+            /* The original count value accounts for the extra
+               bytes, that is, either 1 for a regular transaction,
+               or 2 for a PEC transaction. */
+            count += inval;
+            msg->len += inval;
+        }
+
+        if (!(flags & I2C_M_NO_RD_ACK)) acknak(adap, count);
+    }
+    return rdcount;
+}
+
+static int bit_doAddress(struct aml_demod_i2c *adap, struct i2c_msg *msg)
+{
+    unsigned short flags = msg->flags;
+    unsigned short nak_ok = msg->flags & I2C_M_IGNORE_NAK;
+    unsigned char addr;
+    int ret, retries;
+
+    retries = nak_ok ? 0 : adap->retries;
+
+    if (flags & I2C_M_TEN) {
+        /* a ten bit address */
+        addr = 0xf0 | ((msg->addr >> 7) & 0x03);
+        if (adap->debug) printk("i2c addr0: %d\n", addr);
+        /* try extended address code...*/
+        ret = try_address(adap, addr, retries);
+        if ((ret != 1) && !nak_ok)  {
+            printk("Error: died at extended address code\n");
+            return -EREMOTEIO;
+        }
+        /* the remaining 8 bit address */
+        ret = i2c_outb(adap, msg->addr & 0x7f);
+        if ((ret != 1) && !nak_ok) {
+            /* the chip did not ack / xmission error occurred */
+            printk("Error: died at 2nd address code\n");
+            return -EREMOTEIO;
+        }
+        if (flags & I2C_M_RD) {
+            if (adap->debug) printk("emitting repeated start condition\n");
+            i2c_start(adap);
+            /* okay, now switch into reading mode */
+            addr |= 0x01;
+            ret = try_address(adap, addr, retries);
+            if ((ret != 1) && !nak_ok) {
+                printk("Error: died at repeated address code\n");
+                return -EREMOTEIO;
+            }
+        }
+    }
+    else { /* normal 7bit address  */
+        addr = msg->addr << 1;
+        if (flags & I2C_M_RD)
+            addr |= 1;
+        if (flags & I2C_M_REV_DIR_ADDR)
+            addr ^= 1;
+        ret = try_address(adap, addr, retries);
+        if ((ret != 1) && !nak_ok)
+            return -ENXIO;
+    }
+
+    return 0;
+}
+
+// i2c read/write function
+static int aml_i2c_sw_bit_xfer(struct aml_demod_i2c *adap, struct i2c_msg msgs[], int num)
+{
+    struct i2c_msg *pmsg;
+    int i, ret;
+    unsigned short nak_ok;
+
+    if (adap->debug) printk("emitting start condition\n");
+    i2c_start(adap);
+    for (i = 0; i < num; i++) {
+        pmsg = &msgs[i];
+        nak_ok = pmsg->flags & I2C_M_IGNORE_NAK;
+        if (!(pmsg->flags & I2C_M_NOSTART)) {
+            if (i) {
+                if (adap->debug) printk("emitting repeated start condition\n");
+                i2c_start(adap);
+            }
+            ret = bit_doAddress(adap, pmsg);
+            if ((ret != 0) && !nak_ok) {
+                printk("NAK from device addr 0x%02x msg #%d\n",
+		       msgs[i].addr, i);
+                goto bailout;
+            }
+        }
+        if (pmsg->flags & I2C_M_RD) {
+            /* read bytes into buffer*/
+            ret = readbytes(adap, pmsg);
+            if (ret >= 1 && adap->debug)
+                printk("read %d byte%s\n", ret, ret == 1 ? "" : "s");
+            if (ret < pmsg->len) {
+                if (ret >= 0)
+                    ret = -EREMOTEIO;
+                goto bailout;
+            }
+        } else {
+            /* write bytes from buffer */
+            ret = sendbytes(adap, pmsg);
+            if (ret >= 1 && adap->debug)
+                printk("wrote %d byte%s\n", ret, ret == 1 ? "" : "s");
+            if (ret < pmsg->len) {
+                if (ret >= 0)
+                    ret = -EREMOTEIO;
+                goto bailout;
+            }
+        }
+    }
+    ret = i;
+
+bailout:
+    if (adap->debug) printk("emitting stop condition\n");
+    i2c_stop(adap);
+
+    return ret;
+}
+
+int am_demod_i2c_xfer(struct aml_demod_i2c *adap, struct i2c_msg msgs[], int num)
+{
+    int ret=0;
+
+    //printk("adap->scl_oe[%x], adap->i2c_priv[%p], adap->i2c_id[%x]\n", adap->scl_oe, adap->i2c_priv, adap->i2c_id);
+    if(adap->scl_oe)
+    {
+    	ret = aml_i2c_sw_bit_xfer(adap, msgs, num);
+    }
+    else
+    {
+    	if(adap->i2c_priv){
+		//printk("msgs[%p], num[%x]\n", msgs, num);
+		ret = i2c_transfer((struct i2c_adapter *)adap->i2c_priv, msgs, num);
+	} else {
+    		printk("i2c error, no valid i2c\n");
+    	}
+    }
+    return ret;
+}
+
diff --git a/drivers/amlogic/dvb_tv/amldemod/tuner_func.c b/drivers/amlogic/dvb_tv/amldemod/tuner_func.c
new file mode 100755
index 000000000000..9001306edaf6
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/amldemod/tuner_func.c
@@ -0,0 +1,236 @@
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+
+//#include <dvb_frontend.h>
+
+#include "aml_demod.h"
+#include "demod_func.h"
+
+
+//#include "mxl/MxL5007_API.h"
+//#include "../tuners/si2176_func.h"
+
+static int configure_first=-1;
+
+static int set_tuner_DCT7070X(struct aml_demod_sta *demod_sta,
+			      struct aml_demod_i2c *adap)
+{
+    int ret = 0;
+    unsigned char data[6];
+    unsigned long ch_freq, ftmp;
+    struct i2c_msg msg;
+
+    ch_freq = demod_sta->ch_freq;
+    //printk("Set Tuner DCT7070X to %ld kHz\n", ch_freq);
+
+    ftmp = (ch_freq+36125)*10/625;  // ftmp=(ch_freq+GX_IF_FREQUENCY)
+    data[0] = ftmp>>8&0xff;
+    data[1] = ftmp&0xff;
+    data[2] = 0x8b;              // 62.5 kHz
+
+    if (ch_freq < 153000)
+	data[3] = 0x01;
+    else if (ch_freq < 430000)
+	data[3] = 0x06;
+    else
+	data[3] = 0x0c;
+
+    data[4] = 0xc3;
+
+    msg.addr = adap->addr;
+    msg.flags = 0; // I2C_M_IGNORE_NAK;
+    msg.len = 5;
+    msg.buf = data;
+
+    ret = am_demod_i2c_xfer(adap, &msg, 1);
+
+    return ret;
+}
+
+/*int tuner_set_ch(struct aml_demod_sta *demod_sta, struct aml_demod_i2c *adap)
+{
+    int ret = 0;
+    printk("Set tuner: 1 is DCT70707, 1 is Mxl5007, 3 is FJ2207, 4 is TD1316, 5 is XUGUAN DMTX-6A, 6 is Si2176\n");
+    switch (adap->tuner) {
+    case 0 : // NULL
+	printk("Warning: NULL Tuner\n");
+	break;
+
+    case 1 : // DCT
+	ret = set_tuner_DCT7070X(demod_sta, adap);
+	break;
+
+    case 2 : // Maxliner
+	ret = set_tuner_MxL5007(demod_sta, adap);
+	break;
+
+    case 3 : // NXP
+	ret = set_tuner_fj2207(demod_sta, adap);
+	break;
+
+    case 4 : // TD1316
+	ret = set_tuner_TD1316(demod_sta, adap);
+	break;
+
+    case 5 :
+	ret = set_tuner_xuguan(demod_sta, adap);
+	break;
+
+    case 6 : //Si2176
+	ret = set_tuner_si2176(demod_sta, adap);
+	break;
+
+    default :
+	return -1;
+    }
+
+    return 0;
+}*/
+#if (defined CONFIG_AM_SI2176)
+extern	int si2176_get_strength(void);
+#elif (defined CONFIG_AM_SI2177)
+extern	int si2177_get_strength(void);
+#endif
+
+int tuner_get_ch_power(struct aml_fe_dev *adap)
+{
+    int ret = 0;
+	int strength=0;
+
+#if (defined CONFIG_AM_SI2176)
+	 strength=si2176_get_strength();
+#elif (defined CONFIG_AM_SI2177)
+	 strength=si2177_get_strength();
+#endif
+
+	 return strength;
+}
+
+struct dvb_tuner_info * tuner_get_info( int type, int mode)
+{
+	/*type :  0-NULL, 1-DCT7070, 2-Maxliner, 3-FJ2207, 4-TD1316*/
+	/*mode: 0-DVBC 1-DVBT */
+	static struct dvb_tuner_info tinfo_null = {};
+
+	static struct dvb_tuner_info tinfo_MXL5003S[2] = {
+		[1] = {/*DVBT*/
+			.name = "Maxliner",
+			.frequency_min = 44000000,
+			.frequency_max = 885000000,
+		}
+	};
+	static struct dvb_tuner_info tinfo_FJ2207[2] = {
+		[0] = {/*DVBC*/
+			.name = "FJ2207",
+			.frequency_min = 54000000,
+			.frequency_max = 870000000,
+		},
+		[1] = {/*DVBT*/
+			.name = "FJ2207",
+			.frequency_min = 174000000,
+			.frequency_max = 864000000,
+		},
+	};
+	static struct dvb_tuner_info tinfo_DCT7070[2] = {
+		[0] = {/*DVBC*/
+			.name = "DCT7070",
+			.frequency_min = 51000000,
+			.frequency_max = 860000000,
+		}
+	};
+	static struct dvb_tuner_info tinfo_TD1316[2] = {
+		[1] = {/*DVBT*/
+			.name = "TD1316",
+			.frequency_min = 51000000,
+			.frequency_max = 858000000,
+		}
+	};
+	static struct dvb_tuner_info tinfo_SI2176[2] = {
+		[0] = {/*DVBC*/
+//#error please add SI2176 code
+			.name = "SI2176",
+			.frequency_min = 51000000,
+			.frequency_max = 860000000,
+		}
+	};
+
+	struct dvb_tuner_info *tinfo[] = {
+		&tinfo_null,
+		tinfo_DCT7070,
+		tinfo_MXL5003S,
+		tinfo_FJ2207,
+		tinfo_TD1316,
+		tinfo_SI2176
+	};
+
+	if((type<0)||(type>4)||(mode<0)||(mode>1))
+		return tinfo[0];
+
+	return &tinfo[type][mode];
+}
+
+struct agc_power_tab * tuner_get_agc_power_table(int type) {
+	/*type :  0-NULL, 1-DCT7070, 2-Maxliner, 3-FJ2207, 4-TD1316*/
+	static int calcE_FJ2207[31]={87,118,138,154,172,197,245,273,292,312,
+						 327,354,406,430,448,464,481,505,558,583,
+						 599,616,632,653,698,725,745,762,779,801,
+						 831};
+	static int calcE_Maxliner[79]={543,552,562,575,586,596,608,618,627,635,
+						    645,653,662,668,678,689,696,705,715,725,
+						    733,742,752,763,769,778,789,800,807,816,
+						    826,836,844,854,864,874,884,894,904,913,
+						    923,932,942,951,961,970,980,990,1000,1012,
+						    1022,1031,1040,1049,1059,1069,1079,1088,1098,1107,
+						    1115,1123,1132,1140,1148,1157,1165,1173,1179,1186,
+						    1192,1198,1203,1208,1208,1214,1217,1218,1220};
+
+	static struct agc_power_tab power_tab[] = {
+		[0] = {"null", 0, 0, NULL},
+		[1] = {
+			.name="DCT7070",
+			.level=0,
+			.ncalcE=0,
+			.calcE=NULL,
+		},
+		[2] = {
+			.name="Maxlear",
+			.level=-22,
+			.ncalcE=sizeof(calcE_Maxliner)/sizeof(int),
+			.calcE=calcE_Maxliner,
+		},
+		[3] = {
+			.name="FJ2207",
+			.level=-62,
+			.ncalcE=sizeof(calcE_FJ2207)/sizeof(int),
+			.calcE=calcE_FJ2207,
+		},
+		[4] = {
+			.name="TD1316",
+			.level=0,
+			.ncalcE=0,
+			.calcE=NULL,
+		},
+	};
+
+	if(type>=2 && type<=3)
+		return &power_tab[type];
+	else
+		return &power_tab[3];
+};
+
+
+int  agc_power_to_dbm(int agc_gain, int ad_power, int offset, int tuner)
+{
+	struct agc_power_tab *ptab = tuner_get_agc_power_table(tuner);
+	int est_rf_power;
+	int j;
+
+	for(j=0; j<ptab->ncalcE; j++)
+		if(agc_gain<=ptab->calcE[j])
+			break;
+
+	est_rf_power = ptab->level - j - (ad_power>>4) + 12 + offset;
+
+	return (est_rf_power);
+}
+
diff --git a/drivers/amlogic/dvb_tv/atbm887x/Kconfig b/drivers/amlogic/dvb_tv/atbm887x/Kconfig
new file mode 100755
index 000000000000..8638e9e39d17
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/atbm887x/Kconfig
@@ -0,0 +1,21 @@
+#
+# Atbm887x driver configuration
+#
+menuconfig AM_ATBM8869
+	tristate "ATBM8869 demod driver"
+	default n
+	depends on AM_DVB
+	help
+		Select to enable AM_ATBM8878 demod driver.
+
+if AM_ATBM8869
+
+config ATBM8869_TS_PARALLEL_MODE
+	bool "ATBM8869_TS_PARALLEL_MODE"
+	depends on AM_ATBM8869
+	default n
+	help
+	 select ATBM8869_TS_PARALLEL_MODE,default is ATBM8869_TS_SERIAL_MODE
+
+endif
+
diff --git a/drivers/amlogic/dvb_tv/atbm887x/Makefile b/drivers/amlogic/dvb_tv/atbm887x/Makefile
new file mode 100755
index 000000000000..bf8dbb991914
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/atbm887x/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_AM_ATBM8869) += atbm8878_fe.o
+
+atbm8878_fe-objs = atbm887x.o atbmfrontend.o  ###log_calc.o atbmdvbc.o atbm884x.o tuner_func.o i2c_func.o
+
+##atbm8859_fe-objs += si2176/si2176_func.o
+
+EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
diff --git a/drivers/amlogic/dvb_tv/atbm887x/atbm886x.c b/drivers/amlogic/dvb_tv/atbm887x/atbm886x.c
new file mode 100755
index 000000000000..22e28055bde5
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/atbm887x/atbm886x.c
@@ -0,0 +1,3786 @@
+/*****************************************************************************
+Copyright 2012, AltoBeam Inc. All rights reserved.
+
+File Name: atbm886x.c
+Description: Software development source codes for ATBM886x DTMB/DVBC demodulator
+(for SoC only supporting the fixed point calculation)
+Version: 1.0.3
+Released 2012-10-18
+
+===============================================================================
+Brief introduction for software porting
+
+--------------------------------------------------------------------------------
+[Basic functions for porting]
+
+There are four basic functions which are called by other predefined APIs.
+Developer needs to implement them according to certain SoC/OS platform.
+All functions for porting are listed at below:
+
+SemodHardwareReset()
+	This function is to control the output of SoC GPIO which is connected to the RESETN pin of demodulator.
+DelayMS()
+	This function is to generate time delay as required.
+I2CRead()
+	This function is to conduct a single read transaction on I2C bus.
+I2CWrite()
+	This function is to conduct a single write transaction on I2C bus.
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[Configuration according to hardware environment]
+
+Some environment variables need to be specified according to a certain hardware design.
+The configuration for these varibles is included in function ATBMPowerOnInit().
+All items for customization and the allowed values for each are listed at below:
+
+MPEG_TS_mode_t
+	ui8TSTransferType: TS_PARALLEL_MODE / TS_SERIAL_MODE
+	ui8OutputEdge: TS_OUTPUT_FALLING_EDGE / TS_OUTPUT_RISING_EDGE
+	ui8TSSPIMSBSelection: TS_SPI_MSB_ON_DATA_BIT7 / TS_SPI_MSB_ON_DATA_BIT0
+	ui8TSSSIOutputSelection: TS_SSI_OUTPUT_ON_DATA_BIT7 / TS_SSI_OUTPUT_ON_DATA_BIT0
+	ui8SPIClockConstantOutput: TS_CLOCK_CONST_OUTPUT / TS_CLOCK_VALID_OUTPUT
+DVBC_Params_t
+	ui8InputMode: DVBC_IF_INPUT / DVBC_IQ_INPUT
+	i32SymbolRate: (1000k ~ 8000k symbol/sec)
+tuner_config_t
+	ui8IQmode: SWAP_IQ / NO_SWAP_IQ
+	ui8DTMBBandwithMHz: (6MHz, 7MHz and 8MHz bandwidth)
+	dbIFFrequency: (4MHz~11MHz, 36MHz~37MHz)
+custom_config_t
+	ui8ATBMSlaveAddr: 0x80 / 0x88
+	ui8CrystalOrOscillator:CRYSTAL / OSCILLATOR
+	ui8DtmbDvbcMode: ATBM_DTMB_MODE / ATBM_DVBC_MODE
+
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[Predefined API functions to be called]
+There are a set of predefined functions provided in the SDK source codes.
+Simply call some top-level functions to make a basic DTV application, including:
+
+ATBMPowerOnInit()
+       This function is to initialize demodulator after power up, this is the first function
+       must be called before any other demodulator functions.
+ATBMSetConfigParas(custom_config_t stCustomConfigp)
+	This function config the parameter to the global variable ,it should be called
+	before ATBMSetDTMBMode() or ATBMSetDVBCMode()
+ATBMSetDTMBMode()
+	This function sets the demodulator working in DTMB mode.
+ATBMSetDVBCMode()
+        This function sets the demodulator working in DVB-C mode.
+--------------------------------------------------------------------------------
+
+For more information, please refer to the complete SDK user manual.
+===============================================================================
+******************************************************************************/
+
+
+#include <linux/dvb/frontend.h>
+#include <linux/i2c.h>
+#include "../../../media/dvb/dvb-core/dvb_frontend.h"
+#include "../aml_dvb.h"
+#include "atbm886x.h"
+extern struct i2c_adapter *i2c_adap_atbm;
+
+uint8           ui8ATBMSlaveAddr         = 0x40;   /*either 0x80 or 0x88 */
+uint8           ui8ATBMSoftwareVersion = 10;     /*SW guide version = ui8ATBMSoftwareVersion/10 */
+uint32          ui32DvbcOscFreq;
+uint32          ui32DvbcSymbolRate;
+custom_config_t stCustomConfig;  /*global config parameter*/
+
+
+/****************************************************************************
+
+   The following are APIs users need to implement based on their platform.
+   If the enum define is not the same as your i2c return value,
+   You should change the header file to modify the enum ATBM_I2CREADWRITE_STATUS
+   which value is success for i2c write.
+
+****************************************************************************/
+extern ATBM_I2CREADWRITE_STATUS I2CWrite(uint8 ui8I2CSlaveAddr, uint8 *ui8pData, int i32Length)
+ {
+   /* I2C write, please port this function*/
+  // 	printk("\n[I2CWrite] enter I2CSlaveAddr is %x,length is %d,data[0] is %x,data[1] is %x",ui8I2CSlaveAddr,i32Length,ui8pData[0],ui8pData[1]);
+   /* I2C write, please port this function*/
+   int ret = 0;
+//	unsigned char regbuf[1];			/*8 bytes reg addr, regbuf 1 byte*/
+	struct i2c_msg msg;			/*construct 2 msgs, 1 for reg addr, 1 for reg value, send together*/
+
+//	regbuf[0] = I2CSlaveAddr & 0xff;
+
+	memset(&msg, 0, sizeof(msg));
+
+	/*write reg address*/
+/*	msg[0].addr = (state->config.demod_addr);
+	msg[0].flags = 0;
+	msg[0].buf = regbuf;
+	msg[0].len = 1;*/
+
+
+	/*write value*/
+	msg.addr = ui8I2CSlaveAddr;
+	msg.flags = 0;  //I2C_M_NOSTART;	/*i2c_transfer will emit a stop flag, so we should send 2 msg together,
+																// * and the second msg's flag=I2C_M_NOSTART, to get the right timing*/
+	msg.buf = ui8pData;
+	msg.len = i32Length;
+#if 0
+
+	/*write reg address*/
+	msg[0].addr = 0x80;
+	msg[0].flags = 0;
+	msg[0].buf = 0x7;
+	msg[0].len = 1;
+
+	/*write value*/
+	msg[1].addr = 0x80;
+	msg[1].flags = I2C_M_NOSTART;	/*i2c_transfer will emit a stop flag, so we should send 2 msg together,
+																 * and the second msg's flag=I2C_M_NOSTART, to get the right timing*/
+	msg[1].buf = 0x8;
+	msg[1].len = 1;
+#endif
+	struct i2c_adapter *i2c_adap;
+	i2c_adap = i2c_get_adapter(0);
+	if(!i2c_adap){
+		printk("i2c_adap is null\n");
+		return;
+	}
+	ret = i2c_transfer((struct i2c_adapter *)i2c_adap_atbm, &msg, 1);
+	if(ret<0){
+		printk(" %s: writereg error, errno is %d \n", __FUNCTION__, ret);
+		return 0;
+	}
+      return ATBM_I2CREADWRITE_OK;
+ }
+
+extern ATBM_I2CREADWRITE_STATUS I2CRead(uint8 ui8I2CSlaveAddr, uint8 *ui8pData, int i32Length)
+ {
+   /* I2C write, please port this function*/
+     /* I2C read, please port this function*/
+	// 	printk("\n[I2CRead] enter ");
+		 u_int32 nRetCode = 0;
+
+	//	printk("\n[I2CWrite] enter I2CSlaveAddr is %x,length is %d,data[0] is %x,data[1] is %x",ui8I2CSlaveAddr,i32Length,ui8pData[0],ui8pData[1]);
+		 struct i2c_msg msg[1];
+
+		 if(ui8pData == 0 || i32Length == 0)
+		 {
+			 printk("atbm8859 read register parameter error !!\n");
+			 return 0;
+		 }
+
+		 //read real data
+		 memset(msg, 0, sizeof(msg));
+		 msg[0].addr = ui8I2CSlaveAddr;
+		 msg[0].flags |=  I2C_M_RD;  //write  I2C_M_RD=0x01
+		 msg[0].len = i32Length;
+		 msg[0].buf = ui8pData;
+		 struct i2c_adapter *i2c_adap;
+		i2c_adap = i2c_get_adapter(0);
+		if(!i2c_adap){
+		printk("i2c_adap is null\n");
+		return;
+	}
+		 nRetCode = i2c_transfer((struct i2c_adapter *)i2c_adap_atbm, msg, 1);
+
+		 if(nRetCode != 1)
+		 {
+			 printk("atbm8859_readregister reg failure!\n");
+			 return 0;
+		 }
+      return ATBM_I2CREADWRITE_OK;
+ }
+
+
+/******************************************************************************
+I2CRead:  Read one register by one step I2C format, parameters:
+   I2CSlaveAddr:  I2C slave address;
+   addr_length:   address length, here is 2 bytes;
+   addr_dat:      pointer to 2 bytes register address;
+   data_length:   Data length (in byte) to read, here is 1 byte;
+   reg_dat:       pointer to retuned 1 byte register value;
+
+   Reading register 0x0004 the I2C sequences is:
+   S_0x80_A_0x00_A_0x04_A_S_0x81_A_0x01_N_P
+
+   S:I2C start;
+   A:ACK;
+   N:NACK;
+   P:stop
+****************************************************************************/
+extern ATBM_I2CREADWRITE_STATUS I2CReadOneStep(uint8 ui8I2CSlaveAddr, uint16 addr_length, uint8 *addr_dat,  uint16 data_length, uint8 *reg_dat)
+{
+ /*I2C read in one step format, please port this function if needed*/
+    return ATBM_I2CREADWRITE_OK;
+}
+
+/******************************************************************************
+I2CWriteWithRestart: Write one register by one step I2C format, parameters:
+   I2CSlaveAddr:  I2C slave address;
+   addr_length:   address length number, here is 2 bytes;
+   addr_dat:      pointer to 2 bytes register address;
+   data_length:   Data length (in byte) to write, here is 1 byte;
+   reg_dat:       pointer to 1 byte register value;
+
+   Writing register 0x0004 with 0x01 the I2C sequences is:
+   S_0x80_A_0x00_A_0x04_A_S_0x80_A_0x01_A_P
+
+   S:I2C start; A:ACK; N:NACK; P:stop
+   ******Attention a start is needed after sending the register's address.
+****************************************************************************/
+extern ATBM_I2CREADWRITE_STATUS I2CWriteWithRestart(uint8 ui8I2CSlaveAddr, uint8 addr_length, uint8 *addr_dat,  uint8 data_length, uint8 *reg_dat)
+{
+ /*I2C write in one step format, please port this function if needed*/
+    return ATBM_I2CREADWRITE_OK;
+}
+extern void DemodHardwareReset(void) {
+
+	// <to be implemented by user>
+}
+
+
+extern void Delayms (int ms) {
+	msleep(ms);
+	//  <to be implemented by user>
+
+}
+
+
+
+/****************************************************************************
+
+   The following are APIs predefined by AltoBeam.
+   You should change the values of the variables for configuration in function
+   ATBMPowerOnInit() according to hardware design.
+
+****************************************************************************/
+
+
+
+/****************************************************************************
+Next 3 functions is used for fix edition SDK calculation
+******************************************************************************/
+int SNR_log_table_int[]=
+{
+		0, 100,
+		2, 104,
+		4, 109,
+		6, 114,
+		8, 120,
+		10, 125,
+		12, 131,
+		14, 138,
+		16, 144,
+		18, 151,
+		20, 158,
+		22, 166,
+		24, 173,
+		26, 182,
+		28, 190,
+		30, 199,
+		32, 208
+};
+
+int LeftTable(int InValue)
+{
+	int OutValue = 0;
+	int TableSize = sizeof(SNR_log_table_int)/sizeof(int);
+	int i;
+	for(i=0; i<TableSize; i+=2)
+	{
+		if(InValue<=SNR_log_table_int[i+1])
+		{
+			OutValue = SNR_log_table_int[i];
+			return OutValue;
+		}
+	}
+	OutValue = 32;
+	return OutValue;
+}
+
+uint32 Log10Convert(uint32 InValue)
+{
+	uint8       		indx = 0;
+	uint32		        u32_temp = 1;
+	uint32              InValue_left;
+	uint32 log_ret;
+
+	do {
+		u32_temp = u32_temp << 1;
+		if (InValue < u32_temp)
+			break;
+	}while(++indx < 32);
+
+	log_ret = 301*indx/100;
+
+	InValue_left = InValue*100/(1<<indx);
+
+	log_ret = log_ret + LeftTable(InValue_left)/10;
+
+	//printf(" InValue = %d  log ret = %d\n", InValue,  log_ret);
+	return log_ret;
+}
+
+int  FixPow(int x,uint32 y)
+{
+	int i32Rst = x;
+	uint32 i;
+	if (y == 0)
+	{
+		return 1;
+	}
+
+	for (i = 0;i<y;i++)
+	{
+		i32Rst*= x;
+	}
+	return i32Rst;
+}
+
+
+
+
+/****************************************************************************
+Function:     ATBMPowerOnInit
+Parameters:   none
+Return:       power_on_status
+Description:
+          This function close the reference clock and set  I2C gate off from demod to tuner.
+******************************************************************************/
+int ATBMPowerOnInit()
+{
+	printf("%s\n",__func__);
+	int power_on_status = 0;
+	uint8 ui8pll, reset_status;
+
+	uint8 ui8ChipID;
+	stCustomConfig.stTunerConfig.ui8IQmode              = SWAP_IQ;
+	stCustomConfig.stTunerConfig.ui8DTMBBandwithMHz     = 8; //unit: MHz
+	stCustomConfig.stTunerConfig.ui32IFFrequency        = 5000; //unit: KHz
+
+	//demod config
+	#ifdef CONFIG_ATBM8869_TS_PARALLEL_MODE
+	printk("this is ATBM8869 TS_PARALLEL_MODE \n");
+	stCustomConfig.stTsMode.ui8TSTransferType           = TS_PARALLEL_MODE;
+	#else
+	printk("this is ATBM8869 TS_SERIAL_MODE \n");
+	stCustomConfig.stTsMode.ui8TSTransferType           = TS_SERIAL_MODE;
+	#endif
+	stCustomConfig.stTsMode.ui8OutputEdge               = TS_OUTPUT_RISING_EDGE;
+	stCustomConfig.stTsMode.ui8SPIClockConstantOutput   = TS_CLOCK_VALID_OUTPUT;
+	stCustomConfig.stTsMode.ui8TSSPIMSBSelection        = TS_SPI_MSB_ON_DATA_BIT7;
+	stCustomConfig.stTsMode.ui8TSSSIOutputSelection     = TS_SSI_OUTPUT_ON_DATA_BIT0;
+	stCustomConfig.ui8CrystalOrOscillator               = CRYSTAL;  // when dbSampleClkFrequency == 30.4 then use CRYSTAL macro   and dbSampleClkFrequency == 24.0 then use OSCILLATOR
+	stCustomConfig.ui32SampleClkFrequency               = 30400; //unit: KHz
+
+	//dvbc config
+	stCustomConfig.stDvbcParams.i32SymbolRate           = 6875;//unit: KSymbol/sec, the default value is 6875K in China DVBC broadcasting
+	stCustomConfig.stDvbcParams.ui8InputMode            = DVBC_IF_INPUT;
+	ui8ChipID = ATBMChipID();
+	printk("ui8ChipID is %x\n",ui8ChipID);
+
+	if(ui8ChipID == 0x40)
+	{
+		ATBMWrite(0x01, 0x0c, 0x00);
+		ATBMWrite(0x06, 0x06, 0x00);
+		ATBMWrite(0x01, 0x03, 0x00);
+		ATBMRead(0x06, 0x0e, &ui8pll);
+		ATBMWrite(0x06, 0x04, 0x01);
+		ui8pll |= 0x01;
+		ATBMWrite(0x06, 0x0e,ui8pll);
+		ui8pll &= 0xfe;
+		ATBMWrite(0x06, 0x0e,ui8pll);
+		ATBMWrite(0x06, 0x04, 0x00);
+	}
+	else if(ui8ChipID == 0x30)
+	{
+		reset_status = ATBMReset(stCustomConfig.ui8CrystalOrOscillator); //Check hardware state
+		if(reset_status ==0)
+		{
+			printf("please check Crystal or oscillator setting\n");
+		}
+		ATBMWrite(0x06, 0x06, 0x00);
+		ATBMWrite(0x01, 0x03, 0x00);
+	}
+	else
+	{
+		printf("power on init failed, chip not correctly detected\n");
+		return -1;
+	}
+	Delayms(1);/*1 ms*/
+	return power_on_status;
+}
+
+/****************************************************************************
+Function:     ATBMChipID
+Parameters:   none
+Return:       ChipID
+Description: This function checks ATBM886x chip ID,  The chip ID of ATBM886x is 0x40.
+******************************************************************************/
+uint8 ATBMChipID()
+{
+	uint8 ui8ChipID;
+	if(ATBM_I2CREADWRITE_OK == ATBMRead(0x00, 0x00,&ui8ChipID))
+	{
+		return ui8ChipID;
+	}
+	return 0xff;
+}
+
+/****************************************************************************
+Function:    ATBMCheckDemodStatus
+Parameters:  none
+Return:      PLL lock status
+
+Description:
+     Call this function when crystal is used. if PLL locked, hardware reset is not needed.
+     This function is called before configuring demodulator registers.
+	 This function check demodulator status after power on or hardware reset
+     If 1 is returned, demodulator in ready status.
+     If 0 is returned, demodulator need hardware reset or power on.
+******************************************************************************/
+uint8 ATBMCheckDemodStatus()
+{
+	uint8 ui8CheckTimes = 0;
+	uint8 ui8Analog, ui8PLLState, ui8Tmp, ui8HardwareState, ui8ChipID;
+	uint8 ui8Step = 0x20;
+
+	ATBMRead(0x06, 0x07, &ui8HardwareState);
+	if(ui8HardwareState!=5)
+	{
+		return 0;
+	}
+	ATBMRead(0x00, 0x00, &ui8ChipID);
+	if(ui8ChipID == 0x20)
+	{
+		return 1;
+	}
+	ui8PLLState = ATBMCheckPLLStatus();  //check state 0, no register change
+	if(ui8PLLState == 1)
+	{
+		return 1;
+	}
+
+	ATBMRead(0x02, 0x14, &ui8Tmp);
+	while(ui8CheckTimes<5)
+	{
+		if((ui8Tmp&0x02) == 0x02)
+		{
+			ATBMWrite(0x06, 0x06, 0x02); //open
+		}else
+		{
+			ATBMWrite(0x06, 0x06, 0x00);
+		}
+		ui8Analog = ui8CheckTimes*ui8Step;
+		if(ui8CheckTimes == 4)
+		{
+			ui8Analog = 0x60;
+		}
+		ATBMWrite(0x06, 0x0d, ui8Analog);
+		if(ui8CheckTimes == 4)
+		{
+			ATBMWrite(0x06, 0x05, 0x00);
+		}
+		Delayms(10);
+		ui8PLLState = ATBMCheckPLLStatus();
+		if(ui8PLLState == 1)
+		{
+			return 1;
+		}
+		ui8CheckTimes = ui8CheckTimes + 1;
+	}
+	return 0;
+}
+
+/****************************************************************************
+Function:    PLLLock_Flag
+Parameters:  none
+Return:      demodulator PLL lock status
+
+Description:
+	 when internal PLL is locked, the returned value is 1.
+******************************************************************************/
+ uint8 PLLLockFlag()
+ {
+	 uint8 ui8Flag;
+	 int i32Iter = 0;
+	 while(i32Iter<20)
+	 {
+		 ATBMRead(0x06, 0x11, &ui8Flag);
+		 if((ui8Flag&0x01) != 0x01)
+		 {
+			 return 0;
+		 }
+		 i32Iter++;
+	 }
+	 return 1;
+ }
+
+ /****************************************************************************
+ Function:    Digtal_PLL_Lock_Flag
+ Parameters:  none
+ Return:      demodulator PLL lock status
+
+ Description:
+ when DVB-C register set a value different from the default value,
+ if PLL unlocked, the register will be cleared to default value.
+ If PLL aways locked, the register will not be changed.
+ ******************************************************************************/
+ unsigned char Digtal_PLL_Lock_Flag()
+ {
+	 int check_times = 0;
+	 uint8 locked_flag = 0;
+	 uint32 cla_in = 0, cla_out = 0x04;
+
+	 ATBMWrite(0x00, 0x13, 0x01);
+	 ATBMDVBCWrite(0x348, cla_out);
+	 while(check_times<3)
+	 {
+		 ATBMDVBCRead(0x348, &cla_in);
+		 if(cla_in != cla_out)
+		 {
+
+			 locked_flag = 0;
+			 break;
+		 }
+		 else
+		 {
+			 locked_flag = 1;
+		 }
+		 Delayms(10);
+		 check_times = check_times + 1;
+	 }
+	 ATBMWrite(0x00, 0x13, 0x00);
+	 return locked_flag;
+ }
+
+/****************************************************************************
+Function:    ATBMCheckPLLStatus
+Parameters:  none
+Return:      PLL status
+Description:
+	 When demodulator PLL locked and stable, the returned value is 1.
+******************************************************************************/
+ uint8 ATBMCheckPLLStatus(void)
+ {
+	 uint8 ui8PllState,pll_digtal_state, ui8Tmp;
+
+	 ui8PllState = PLLLockFlag();
+	 if(ui8PllState == 1)
+	 {
+		 ATBMRead(0x02, 0x14, &ui8Tmp);
+		 if((ui8Tmp&0x02) != 0x02)
+		 {
+			 ATBMWrite(0x06, 0x06, 0x02);
+		 }
+		 else
+		 {
+			 ATBMWrite(0x06, 0x06, 0x00);
+		 }
+	 }
+	 else
+	 {
+		 return 0;
+	 }
+	 Delayms(10);
+	 ui8PllState = PLLLockFlag();
+	 if(ui8PllState == 1)
+	 {
+		 pll_digtal_state = Digtal_PLL_Lock_Flag();
+		 if(pll_digtal_state == 1)
+		 {
+			 return 1;
+		 }
+
+	 }
+	 return 0;
+ }
+
+ /****************************************************************************
+ Function:    ATBMReset
+ Parameters:  ui8CryOrOsc
+ Return:      1, succed. 0:  failed
+ Description:
+ This function resets ATBM8869T demodulator if PLL is not locked. this is a
+ compatible function used in ATBMInit or be called after suspend.
+ for example, transfer from  suspend mode to standby mode.
+ ******************************************************************************/
+ int ATBMReset(uint8 ui8CryOrOsc)
+ {
+
+	 uint8 ui8HardwareState, ui8CheckResult = 0;
+	 uint8 ui8Loop, ui8Tmp;
+	 /* After hardware power on properly or reset correctly,
+	 * ui8HardwareState value should be 0x05 when using crystal, 3.3V PLL
+	 * ui8HardwareState value should be 0x07 when using oscillator, 3.3V PLL */
+
+	 if(ui8CryOrOsc==CRYSTAL)
+	 {
+		 //Software checking, when power on failed, it will return 0 because I2C error or PLL error
+		 ui8CheckResult = ATBMCheckDemodStatus();
+		 if(ui8CheckResult == 1)
+		 {
+			 return 1;
+		 }
+		 //Hardware checking, usually used after demodulator resume from suspend mode
+		 for(ui8Loop=0; ui8Loop<2; ui8Loop++)
+		 {
+			 if(ui8CheckResult != 1)
+			 {
+				 // printf("I2C Error or it is not properly power up, need hardware reset\n");
+				 DemodHardwareReset();    //hardware check
+				 Delayms(50);
+				 ui8CheckResult = ATBMCheckDemodStatus();
+			 }
+			 else
+			 {
+				 return 1;
+			 }
+		 }
+		 return 0;
+	 }
+
+	 if(ui8CryOrOsc==OSCILLATOR)
+	 {
+		 ATBMRead(0x06, 0x07, &ui8HardwareState);
+		 for(ui8Loop=0; ui8Loop<10; ui8Loop++)
+		 {
+			 if(ui8HardwareState!=0x07)
+			 {
+				 // printf("I2C Error or it is not properly power up, need hardware reset\n");
+				 DemodHardwareReset();
+				 Delayms(100);
+				 ATBMRead(0x06, 0x07, &ui8HardwareState);
+			 }
+			 else
+			 {
+				 ATBMRead(0x02, 0x14, &ui8Tmp);
+				 if((ui8Tmp&0x02) != 0x02)
+				 {
+					 ATBMWrite(0x06, 0x06, 0x02);
+				 }
+				 else
+				 {
+					 ATBMWrite(0x06, 0x06, 0x00);
+				 }
+				 break;
+			 }
+		 }
+
+		 if( ui8Loop == 10)
+		 {
+			 return 0;
+		 }else
+		 {
+			 return 1;
+		 }
+	 }
+	 return 0;
+ }
+
+/****************************************************************************
+Function:    ATBM_I2CByPassOn
+Parameters:  none
+Return:      none
+Description: Enable demod to pass I2C commands between tuner and host.
+ ****************************************************************************/
+void ATBMI2CByPassOn()
+{
+	ATBMWrite(0x01,0x03,1); /* the 3st parameter:1-> Enable demod to pass I2C commands between tuner and host. */
+}
+
+/****************************************************************************
+Function:    ATBM_I2CByPassOff
+Parameters:  none
+Return:      none
+Description: Disable the I2C pass-through. Tuner is disconnected from the I2C BUS after this function is called.
+****************************************************************************/
+void ATBMI2CByPassOff()
+{
+	ATBMWrite(0x01,0x03,0); /*the 3st parameter:0-> Disable demod to pass I2C commands between tuner and host*/
+}
+
+/****************************************************************************
+Function:    ATBMLockedFlag
+Parameters:  none
+Return:      1: locked, 0:unlocked
+Description: This function checks ATBM886x Demod locking status
+****************************************************************************/
+int ATBMLockedFlag()
+{
+	 uint8 ui8DTMBFEC           = 0;
+	 uint8 ui8CurReceivingMode;
+	 uint32   ui32DvbcStatus         = 0;
+
+	// ATBMRead(0x00, 0x13, &ui8CurReceivingMode); /*0:DTMB, 1:DVB-C*/
+	 ui8CurReceivingMode = 0x00;
+	 if(ui8CurReceivingMode == 0x00) /*DTMB*/
+	 {
+	 	 ATBMRead(0x03, 0x0d, &ui8DTMBFEC);
+	//	  printf("TS lock is %x\n",ui8DTMBFEC);
+	     ATBMRead(0x0b, 0x08, &ui8DTMBFEC);/*read DTMB internal register*/
+	//	 printf("FEC lock is %x\n",ui8DTMBFEC);
+
+		 if(((ui8DTMBFEC&0x01) == 0x01)&&(ui8DTMBFEC != 0xff)) /*FER locked:bit0*/
+		 {
+			 return 1;
+		 }
+	 }
+	 if(ui8CurReceivingMode == 0x01)
+	 {
+		 ATBMDVBCRead(0x08, &ui32DvbcStatus);/*read DVB-C internal register*/
+		 if(ui32DvbcStatus&0x20) /*bit 5 is locked flag*/
+		 {
+			 return 1;   /*DVB-C FEC locked*/
+		 }
+	}
+	return 0;
+}
+
+
+/****************************************************************************
+Function:    ATBM_sync_state
+Parameters:  none
+Return:      2:lock, 1: sync, 0:unlocked
+Description: This function checks ATBM886x signal state, this is an internal
+             function used by ATBMChannelLockCheck.
+****************************************************************************/
+int ATBM_sync_state()
+{
+	uint8 i, dtmb_fec, signal_sync, sync_times = 0;
+	for(i=0; i<10; i++)
+	{
+		ATBMRead(0x0b, 0x08, &dtmb_fec);
+		if(dtmb_fec&0x01) //bit 0
+		{
+			return 2;           //DTMB FEC locked
+		}
+		ATBMRead(0x08, 0x2B, &signal_sync);
+		if(signal_sync == 6)
+		{
+			sync_times++;
+		}
+		Delayms(30);
+	}
+	if(sync_times >= 3)
+	{
+		return 1;
+	}else
+	{
+		return 0;
+	}
+}
+
+/****************************************************************************
+Function:    ATBMChannelLockCheck
+Parameters:  none
+Return:      1: locked, 0:unlocked
+Description: This function keeps checking ATBM886x signal locking status until it's Locked or time out.
+             This function can be used for Auto channel scanning.
+****************************************************************************/
+int ATBMChannelLockCheck()
+{
+	uint8 dtmb_fec = 0;
+	int check_result;
+	uint32 dvbc_status = 0;
+	uint32 i32Iter;
+	uint8 cur_receiving_mode;
+	uint32 check_times = 6; //default DTMB: 100ms + 6*300ms timeout
+	uint32 dvbc_time_out = 600; //milliseconds
+	ATBMRead(0x00, 0x13, &cur_receiving_mode); //0:DTMB, 1:DVB-C
+	if(cur_receiving_mode == 0) //DTMB
+	{
+		for(i32Iter =0; i32Iter<2; i32Iter++)
+		{
+			ATBMRead(0x0b, 0x08, &dtmb_fec);
+			if(dtmb_fec&0x01) //bit 0
+			{
+				return 1;           //DTMB FEC locked
+			}
+			Delayms(50);
+		}
+		for(i32Iter=0; i32Iter<check_times; i32Iter++)
+		{
+			check_result = ATBM_sync_state();
+			if(check_result == 2)
+			{
+				return 1; //FEC locked
+			}
+			if(check_result ==0)
+			{
+				return 0; //signal unsync
+			}
+		}
+	}
+	if(cur_receiving_mode == 1) //DVB-C
+	{
+		check_times = dvbc_time_out/20;
+		for(i32Iter=0; i32Iter<check_times; i32Iter++)
+		{
+			ATBMDVBCRead(0x08, &dvbc_status);       //read DVB-C internal register
+			if(dvbc_status&0x20) //bit 5
+			{
+				return 1;           //DVB-C FEC locked
+			}
+			Delayms(20);
+		}
+	}
+	return 0; //FEC not locked
+}
+
+
+/****************************************************************************
+Function:    ATBMChannelLockCheckForManual
+Parameters:  none
+Return:      1: locked, 0:unlocked
+Description: This function keeps checking ATBM886x signal locking status until it's Locked or time out.
+             This function can be used for Manual channel scanning.
+****************************************************************************/
+int ATBMChannelLockCheckForManual()
+{
+	uint8  ui8DTMBFEC          = 0;
+	uint32  ui32DVBCStatus       = 0;
+	uint8  ui8CurReceivingMode;
+	uint32 ui32DTMBTimeOut     = 5000;  /*5000 millisecond*/
+	uint32 ui32DVBCTimeOut     = 600;  //milliseconds
+	int    i32CheckTimes;
+	int    i32Iter;
+
+    ATBMRead(0x00, 0x13, &ui8CurReceivingMode); /*0:DTMB, 1:DVB-C*/
+	if(ui8CurReceivingMode == 0) /*DTMB*/
+	{
+		i32CheckTimes = ui32DTMBTimeOut/20;
+		for(i32Iter=0; i32Iter<i32CheckTimes; i32Iter++)
+		{
+			ATBMRead(0x0b, 0x08, &ui8DTMBFEC);
+			if(ui8DTMBFEC&0x01) /*bit 0*/
+			{
+				return 1;           /*DTMB FEC locked*/
+			}
+			Delayms(20);
+		}
+	}
+	if(ui8CurReceivingMode == 1) /*DVB-C*/
+	{
+		i32CheckTimes = ui32DVBCTimeOut/20;
+		for(i32Iter=0; i32Iter<i32CheckTimes; i32Iter++)
+		{
+			ATBMDVBCRead(0x08, &ui32DVBCStatus);       /*read DVB-C internal register*/
+			if(ui32DVBCStatus&0x20) /*bit 5*/
+			{
+				return 1;           /*DVB-C FEC locked*/
+			}
+			Delayms(20);
+		}
+	}
+	return 0;
+}
+
+/****************************************************************************
+Function:    ATBMHoldDSP
+Parameters:  none
+Return:      none
+Description: This function should be called before set tuner frequency.
+ ****************************************************************************/
+ void ATBMHoldDSP()
+ {
+	 ATBMWrite(0x00, 0x05, 0x01);
+ }
+
+ /****************************************************************************
+Function:    ATBMStartDSP
+Parameters:  none
+Return:      none
+Description: This function should be called after set tuner frequency.Attention: ATBMHoldDSP and ATBMStartDSP should be used together.
+ ****************************************************************************/
+ void ATBMStartDSP()
+ {
+	 ATBMWrite(0x00, 0x05, 0x00);
+ }
+/****************************************************************************
+Function:    ATBM_Standby
+Parameters:  none
+Return:      none
+Description:
+      This function put demodulator in standby mode, it can cut off part power,
+	  the demodulator can wake up at once by calling ATBM_Standby_WakeUp.
+	  two goals:
+	  1, cut off part power when demodulator put in standby mode
+	  2, put TS output pin in high-z state.
+ ****************************************************************************/
+void ATBMStandby()
+{
+	uint8 ui8ADCPD,ui8TSEdge,ui8RefStandby, ui8ADCRfv,ui8GPORge;
+
+	ATBMRead(0x06, 0x00,&ui8RefStandby);
+	ATBMRead(0x06, 0x02,&ui8ADCPD);
+	ATBMRead(0x03, 0x01,&ui8TSEdge);
+	ATBMRead(0x06, 0x0d,&ui8ADCRfv);
+	ATBMRead(0x10, 0xf7,&ui8GPORge);
+
+	ui8RefStandby |= 0x02;
+	ui8ADCPD      |= 0x01;
+	ui8TSEdge     |= 0x02;
+	ui8ADCRfv     |=0x08;
+	ui8GPORge     |=0x01;
+
+	ATBMWrite(0x00, 0x05, 0x01);
+	ATBMWrite(0x06, 0x0d, ui8ADCRfv);
+	ATBMWrite(0x06, 0x00, ui8RefStandby);
+	ATBMWrite(0x06, 0x02, ui8ADCPD);
+	ATBMWrite(0x15, 0x00, 0x00);
+	ATBMWrite(0x03, 0x01, ui8TSEdge); /*all TS output PINs will be high-z*/
+	ATBMWrite(0x10, 0xf7, ui8GPORge);
+	ATBMWrite(0x00, 0x19, 0x00);
+}
+
+/****************************************************************************
+Function:    ATBM_Standby_WakeUp
+Parameters:  none
+Return:      none
+Description: Put demodulator in previous normal working mode from standby mode
+ ****************************************************************************/
+void ATBMStandbyWakeUp()
+{
+	uint8 ui8ADCPD,ui8TSEdge,ui8RefStandby,ui8ADCRfv,ui8GPORge;
+
+	ATBMRead(0x06, 0x00,&ui8RefStandby);
+	ATBMRead(0x06, 0x02,&ui8ADCPD);
+	ATBMRead(0x03, 0x01,&ui8TSEdge);
+	ATBMRead(0x06, 0x0d,&ui8ADCRfv);
+	ATBMRead(0x10, 0xf7,&ui8GPORge);
+	ui8RefStandby  &= 0xfd;  //bit1 set 0
+	ui8ADCPD       &= 0xfe;     //bit0 set 0
+	ui8TSEdge      &= 0xfd;    //bit1 set 0
+	ui8ADCRfv      &= 0xf7;
+	ui8GPORge      &= 0xfe; //bit 0 set 0
+
+	ATBMWrite(0x06, 0x00, ui8RefStandby);
+	ATBMWrite(0x06, 0x02, ui8ADCPD);
+	ATBMWrite(0x15, 0x00, 0x01);
+	ATBMWrite(0x03, 0x01, ui8TSEdge); //all TS output PINs will be in normal mode
+	ATBMWrite(0x10, 0xf7, ui8GPORge);
+	ATBMWrite(0x06, 0x0d, ui8ADCRfv);
+	ATBMWrite(0x00, 0x19, 0x01);
+	ATBMWrite(0x00, 0x05, 0x00);
+
+}
+
+/****************************************************************************
+Function:    ATBM_Suspend
+Parameters:  none
+Return:      none
+Description:
+    Put ATBM886x demodulator in suspend mode, Hardware reset is needed to wake up
+    the demodulator. if external oscillator is used Hardware pull down is used
+	to enter suspend mode.
+****************************************************************************/
+void ATBMSuspend()
+{
+	uint8 ui8ChipID;
+	ui8ChipID = ATBMChipID();
+	if(ui8ChipID == 0x40)
+	{
+       	ATBMWrite(0x06, 0x06, 0x2);
+	}
+	ATBMStandby();
+	ATBMWrite(0x01, 0x0c, 0x00); //I2C clock switch
+	ATBMWrite(0x06, 0x04, 0x01); //shutdown PLL
+	ATBMWrite(0x06, 0x0e, 0x02); //shut down crystal clock
+}
+
+/****************************************************************************
+Function:       ATBMSignalStrength
+Parameters:     none
+Return:         unsigned short PWM value, in the range of 0--1023
+Description:
+     This function checks ATBM886x signal strength: when signal is weak the number
+     will be big; The smaller the PWM is, the stronger the signal strength detected.
+ ****************************************************************************/
+int ATBMSignalStrength()
+{
+    uint8 ui8PWM0, ui8PWM1;
+
+    ATBMWrite(0x08,0x4d, 1); /*latch read only registers*/
+    ATBMRead(0x10,0x28,&ui8PWM0);
+    ATBMRead(0x10,0x29,&ui8PWM1);
+    ATBMWrite(0x08,0x4d, 0);
+    return  (((ui8PWM1&0x03)<<8)|ui8PWM0);
+}
+
+ /****************************************************************************
+ Function:    ATBMSetDTMBMode
+ Parameters:  none
+ Return:      none
+ Description:
+	This function initializes ATBM886x in DTMB mode, selects DTMB receiving mode,
+	then calls ATBMInit function.
+	ATBMSetConfigParas function should be called before this function.
+ ******************************************************************************/
+ void ATBMSetDTMBMode(void)
+ {
+	 stCustomConfig.ui8DtmbDvbcMode = ATBM_DTMB_MODE;
+
+	 ATBMInit();
+ }
+
+/****************************************************************************
+Function:        ATBMSignalNoiseRatio
+Parameters:      none
+Return:          uint32 (dB)
+Description:
+     This function checks ATBM886x signal-to-noise ratio.
+     Can be used for signal quality evaluation.
+ ****************************************************************************/
+ uint32 ATBMSignalNoiseRatio()
+ {
+	 uint8  ui8PNValue,ui8PN, ui8TmpNoise,ui8IsSc,ui8SignalH, ui8SignalM, ui8SignalL,ui8NoiseH,ui8NoiseM, ui8NoiseL;
+	 int    i32SignalPower,i32NoisePower;
+	 uint32 ui32SNR = 0;
+
+	 ATBMWrite(0x08, 0x4d, 1);/*lock register value*/
+
+	 ATBMRead(0x08, 0x2d,&ui8PNValue);
+	 ui8PN       = (ui8PNValue&0x03);
+	 ATBMRead(0x14, 0xAF,&ui8TmpNoise);
+	 ATBMRead(0x0d, 0x0f,&ui8IsSc);
+
+	 if(ui8IsSc !=1 )
+	 {
+		 ATBMRead(0x0f, 0x1d,&ui8SignalL);
+		 ATBMRead(0x0f, 0x1e,&ui8SignalM);
+		 ATBMRead(0x0f, 0x1f,&ui8SignalH);
+		 ATBMRead(0x0f, 0x1a,&ui8NoiseL);
+		 ATBMRead(0x0f, 0x1b,&ui8NoiseM);
+		 ATBMRead(0x0f, 0x1c,&ui8NoiseH);
+		 i32SignalPower = ((ui8SignalH&0x0f)<<16)+(ui8SignalM<<8)+ui8SignalL;
+		 i32NoisePower  = ((ui8NoiseH&0x07)<<16)+(ui8NoiseM<<8)+ui8NoiseL;
+		 if(i32SignalPower == 0)
+		 {
+			 i32SignalPower = 1; //signal_power should >0 in log calculation;
+		 }
+		 // 		 dbSNR = (double) (10*(log10(i32SignalPower*1.0/(i32NoisePower+1))));
+		 ui32SNR = Log10Convert(i32SignalPower)-Log10Convert(i32NoisePower+1);
+	 }
+	 if(ui8IsSc ==1 )
+	 {
+		 if(ui8PN == 2) //PN595
+		 {
+			 ATBMRead(0x14, 0xdc,&ui8SignalL);
+			 ATBMRead(0x14, 0xdd,&ui8SignalM);
+			 ATBMRead(0x14, 0xde,&ui8SignalH);
+			 i32SignalPower = ((ui8SignalH&0x0f)<<16)+(ui8SignalM<<8)+ui8SignalL;
+			 i32SignalPower = i32SignalPower/16;
+			 if(ui8TmpNoise != 3)
+			 {
+				 ATBMRead(0x14, 0xf8,&ui8NoiseL);
+				 ATBMRead(0x14, 0xf9,&ui8NoiseH);
+				 i32NoisePower = ((ui8NoiseH&0x3f)<<8) + ui8NoiseL;
+			 }
+			 else
+			 {
+				 ATBMRead(0x13, 0x40,&ui8NoiseL);
+				 ATBMRead(0x13, 0x41,&ui8NoiseH);
+				 i32NoisePower = ((ui8NoiseH&0x3f)<<8) + ui8NoiseL;
+			 }
+			 if(i32SignalPower == 0)
+			 {
+				 i32SignalPower = 1; //signal_power should >0 in log calculation;
+			 }
+			 // 			 dbSNR = (double) (10*(log10(i32SignalPower*1.0/(i32NoisePower+1))));
+			 ui32SNR = Log10Convert(i32SignalPower)-Log10Convert(i32NoisePower+1);
+		 }
+
+		 if((ui8PN == 1)||(ui8PN == 3)) //PN420 & PN945
+		 {
+			 ATBMRead(0x09, 0xcc,&ui8SignalL);
+			 ATBMRead(0x09, 0xcd,&ui8SignalH);
+			 i32SignalPower = (ui8SignalH<<8) + ui8SignalL;
+			 ATBMRead(0x09, 0xed,&ui8NoiseL);
+			 ATBMRead(0x09, 0xee,&ui8NoiseH);
+			 i32NoisePower  = ((ui8NoiseH&0x3f)<<8) + ui8NoiseL;
+
+			 if(i32SignalPower == 0)
+			 {
+				 i32SignalPower = 1; //signal_power >0;
+			 }
+			 if(i32NoisePower == 0)
+			 {
+				 // 				 dbSNR = (double)(10*(log10(i32SignalPower*1.0/(i32NoisePower + 1))));
+				 ui32SNR = Log10Convert(i32SignalPower)-Log10Convert(i32NoisePower+1);
+			 }
+			 else
+			 {
+				 // 				 dbSNR = (double)(10*(log10(i32SignalPower*1.0/i32NoisePower)));
+				 ui32SNR = Log10Convert(i32SignalPower)-Log10Convert(i32NoisePower);
+			 }
+		 }
+	 }
+
+	 ATBMWrite(0x08,0x4d, 0);
+
+	 return ui32SNR;
+ }
+ /****************************************************************************
+ Function:           ATBMSignalDivideNoise
+ Parameters:      none
+ Return:             SNR
+
+ Description:
+ This function is an internal function called by ATBMSignalQuality()
+ ****************************************************************************/
+ uint32 ATBMSignalDivideNoise()
+ {
+	 uint8 LockValue;
+
+	 uint8 pn_value,PN;
+	 uint8 tmp_noise;
+	 uint8 is_sc;
+	 uint32 SNR = 0;
+
+	 uint8 signal_h, signal_m, signal_l;
+	 uint8 noise_h,noise_m, noise_l;
+	 uint32 signal_power = 0;
+	 uint32 noise_power = 0;
+
+	 LockValue =1; /*lock register value*/
+	 ATBMWrite(0x08, 0x4d, LockValue);
+
+	 ATBMRead(0x08, 0x2d, &pn_value);
+	 PN = (uint8)(pn_value&0x03);
+
+	 ATBMRead(0x14, 0xAF, &tmp_noise);
+	 ATBMRead(0x0d, 0x0f, &is_sc);
+	 if(is_sc!=1)
+	 {
+		 ATBMRead(0x0f, 0x1d, &signal_l);
+		 ATBMRead(0x0f, 0x1e, &signal_m);
+		 ATBMRead(0x0f, 0x1f, &signal_h);
+		 ATBMRead(0x0f, 0x1a, &noise_l);
+		 ATBMRead(0x0f, 0x1b, &noise_m);
+		 ATBMRead(0x0f, 0x1c, &noise_h);
+		 signal_power = ((signal_h&0x0f)<<16)+(signal_m<<8)+signal_l;
+		 noise_power  = ((noise_h&0x07)<<16)+(noise_m<<8)+noise_l;
+		 if(signal_power ==0)
+		 {
+			 signal_power =1; //signal_power should >0 in log calculation;
+		 }
+		 SNR = (uint32) (signal_power/(noise_power+1));
+	 }
+	 if(is_sc==1)
+	 {
+		 if(PN==2) //PN595
+		 {
+			 ATBMRead(0x14, 0xdc, &signal_l);
+			 ATBMRead(0x14, 0xdd, &signal_m);
+			 ATBMRead(0x14, 0xde, &signal_h);
+			 signal_power = ((signal_h&0x0f)<<16)+(signal_m<<8)+signal_l;
+			 signal_power = signal_power/16;
+			 if(tmp_noise!=3)
+			 {
+				 ATBMRead(0x14, 0xf8, &noise_l);
+				 ATBMRead(0x14, 0xf9, &noise_h);
+				 noise_power = ((noise_h&0x3f)<<8) + noise_l;
+			 }
+			 else
+			 {
+				 ATBMRead(0x13, 0x40, &noise_l);
+				 ATBMRead(0x13, 0x41, &noise_h);
+				 noise_power = ((noise_h&0x3f)<<8) + noise_l;
+			 }
+			 if(signal_power ==0)
+			 {
+				 signal_power =1; //signal_power should >0 in log calculation;
+			 }
+			 SNR = (uint32)(signal_power/(noise_power+1));
+
+		 }
+
+		 if( (PN==1)||(PN==3) ) //PN420 & PN945
+		 {
+
+			 ATBMRead(0x09, 0xcc, &signal_l);
+			 ATBMRead(0x09, 0xcd, &signal_h);
+			 signal_power = (signal_h<<8) + signal_l;
+			 ATBMRead(0x09, 0xed, &noise_l);
+			 ATBMRead(0x09, 0xee, &noise_h);
+			 noise_power = ((noise_h&0x3f)<<8) + noise_l;
+
+			 if(signal_power ==0)
+			 {
+				 signal_power = 1; //signal_power >0;
+			 }
+			 if(noise_power==0)
+			 {
+				 // printf("noise_power is 0,  signal error!");
+				 SNR = (uint32)(signal_power/(noise_power + 1));
+			 }
+			 else
+			 {
+				 SNR = (uint32)(signal_power/noise_power);
+			 }
+		 }
+	 }
+	 LockValue = 0; /*cancel the lock*/
+	 ATBMWrite(0x08,0x4d, LockValue);
+	 return SNR;
+ }
+/****************************************************************************
+Function:    ATBMSignalQuality
+Parameters:  none
+Return:      i32SNR100per, the signal quality evaluated value.
+Description:
+     This function checks ATBM886x signal-to-noise ratio.
+     Can be used for signal quality evaluation:
+	 max value:99, min:20
+ ****************************************************************************/
+int ATBMSignalQuality()
+{
+	uint8  ui8TPSCode, ui8TSSync;
+	int    i32SNR = 0;
+	int    i32SNR100per;
+	uint32 ui32SNRdB = 0;
+	uint32 ui32FrameError;
+
+//	ui32SNRdB    = ATBMSignalNoiseRatio(); //ATBM886x
+	i32SNR = ATBMSignalDivideNoise();
+	ui8TPSCode = ATBMGetTPS();
+	ATBMRead(0x03, 0x0d,&ui8TSSync);
+	if(ui8TSSync != 1)
+	{
+		ATBMRead(0x03, 0x0d,&ui8TSSync);
+	}
+	ui32FrameError = ATBMFrameErrorRatio();
+
+	i32SNR100per = 20;
+	if((ui8TPSCode <11)&&(ui8TPSCode>2))/*4QAM FEC:0.6 0.8*/
+	{
+		if(i32SNR>100)
+		{
+			i32SNR100per = 90+ i32SNR/100;
+		}
+		else if(i32SNR>60)
+		{
+			i32SNR100per = 80 + (i32SNR-60)/4 ;
+		}
+		else if(i32SNR>20)
+		{
+			i32SNR100per = 60 + (i32SNR-20)/2;
+		}
+		else if(i32SNR>5)
+		{
+			i32SNR100per = 40 + i32SNR;
+		}
+		else
+		{
+			i32SNR100per = 40;
+		}
+	}
+
+	if((ui8TPSCode <17)&&(ui8TPSCode>10)) /*For 16QAM FEC:0.6 0.8*/
+	{
+		if(i32SNR>100)
+		{
+			i32SNR100per = 90+ i32SNR/100;
+		}
+		else if(i32SNR>70)
+		{
+			i32SNR100per = 80 + (i32SNR-70)/3 ;
+		}
+		else if(i32SNR>30)
+		{
+			i32SNR100per = 60 + (i32SNR-30)/2;
+		}
+		else if(i32SNR>10)
+		{
+			i32SNR100per = 50 + (i32SNR-10)/2;
+		}
+		else
+		{
+			i32SNR100per = 40;
+		}
+	}
+	if((ui8TPSCode <25)&&(ui8TPSCode>16))/*64QAM FEC:0.6; 32QAM 0.8*/
+	{
+
+		if(i32SNR>100)
+		{
+			i32SNR100per = 90+ i32SNR/100;
+		}
+		else if(i32SNR>70)
+		{
+			i32SNR100per = 80 + (i32SNR-70)/3 ;
+		}
+		else if(i32SNR>30)
+		{
+			i32SNR100per = 60 + (i32SNR-30)/2;
+		}
+		else if(i32SNR>20)
+		{
+			i32SNR100per = 30+ i32SNR;
+		}
+		else
+		{
+			i32SNR100per = 40;
+		}
+	}
+
+	//re-evaluation
+	if((ui8TSSync ==1)&&(ui32FrameError == 0)) //no frame error
+	{
+		//default:5, you can change this value form 0--10, for evaluation
+		i32SNR100per +=5;
+	}
+	else if((ui8TSSync ==1)&&(ui32FrameError!=0))
+	{
+		i32SNR100per = i32SNR100per - 10;
+	}
+	else
+	{
+		i32SNR100per = 30;
+	}
+	if(i32SNR100per>99)
+	{
+		i32SNR100per = 99;
+	}
+
+	return i32SNR100per;
+}
+
+/****************************************************************************
+Function:    ATBMSignalStrength_reference
+Parameters:  none
+Return:      signal_percent
+Description:
+	This function is a sample of signal strength evaluation.
+	the value AGC_A, AGC_B, AGC_C should be calibrated according to can tuner used.
+****************************************************************************/
+uint16 ATBMSignalStrength_reference()
+{
+	uint8 agc0, agc1,LockValue;
+	uint16 agc_value;
+	uint16 signal_percent;
+
+	//agc_value can be read from register 0x1028, 0x1029,  the AGC Value is related with AGC voltage: about (1024/3.3)*V_agc,
+	//Refer to SDK document. the following value should be changed according to Tuner used.
+
+	uint16 AGC_A = 186; //about AGC 0.6V, Signal strength:80
+	uint16 AGC_B = 496; //about AGC 1.6V, Signal strength:60
+	uint16 AGC_C = 930; //about AGC 3.0V, Signal strength:20
+
+	LockValue =1; /*lock register value*/
+	ATBMWrite(0x08,0x4d, LockValue);
+
+	ATBMRead(0x10, 0x28, &agc0);
+	ATBMRead(0x10, 0x29, &agc1);
+
+	LockValue = 0;
+	ATBMWrite(0x08,0x4d, LockValue);
+	agc_value = (uint16)(((agc1&0x03)<<8)|agc0);
+
+	/*Tuner Reference evaluation*/
+	if(agc_value <=AGC_A)
+	{
+		signal_percent = 80;
+	}
+	else if(agc_value <=AGC_B)
+	{
+		signal_percent = (uint16)((AGC_B - agc_value)*20/(AGC_B - AGC_A) + 60);
+	}
+	else if(agc_value <=AGC_C)
+	{
+		signal_percent = (uint16)((AGC_C - agc_value)*40/(AGC_C - AGC_B) + 20);
+	}
+	else
+	{
+		signal_percent = 20;
+	}
+
+	return signal_percent;
+}
+
+/****************************************************************************
+Function:    ATBMFrameErrorRatio
+Parameters:  none
+Return:      ui32FrameErrorRatio
+Description:
+	This function counts pre-BCH error frames in specified frame window size
+	(Default 2048 frames), then print and return pre-BCH frames error ratio.
+****************************************************************************/
+uint32 ATBMFrameErrorRatio()
+{
+
+	uint8  ui8FrameError0, ui8FrameError1;
+	uint8  ui8ArrFrameCountMax[2];
+	uint32 ui32FrameErrorRatio;
+
+	ATBMRead(0x0B, 0x09,&ui8ArrFrameCountMax[0]);
+	ATBMRead(0x0B, 0x0A,&ui8ArrFrameCountMax[1]);
+	ATBMWrite(0x08, 0x4d, 1);  /*latch read only registers*/
+	ATBMRead(0x0B, 0x14,&ui8FrameError0);
+	ATBMRead(0x0b, 0x15,&ui8FrameError1);
+	ATBMWrite(0x08, 0x4d, 0);
+	if((ui8ArrFrameCountMax[1] == 0)&&(ui8ArrFrameCountMax[0] == 0))
+	{
+		//printf("I2C error\n");
+		ui32FrameErrorRatio = 0;
+		return ui32FrameErrorRatio;
+	}
+	ui32FrameErrorRatio = (1000*((ui8FrameError1&0x7f)*256 + ui8FrameError0))/((ui8ArrFrameCountMax[1]&0x7f)*256 + ui8ArrFrameCountMax[0]);
+//	printk("ui32FrameErrorRatio is %d,ui8FrameError0 is %d,ui8FrameError1 is %dui8ArrFrameCountMax[0] is %d,ui8ArrFrameCountMax[1] is %d\n",ui32FrameErrorRatio,ui8FrameError0,ui8FrameError1,ui8ArrFrameCountMax[0],ui8ArrFrameCountMax[1]);
+	return  ui32FrameErrorRatio;
+}
+
+/****************************************************************************
+Function:    ATBMPreBCHBlockErrorRatio
+Parameters:  none
+Return:      ui32BlockErrorRatio
+
+Description:
+    This function counts blocks with error in specified block window size,
+    Then calculate and return pre-BCH block error ratio.
+****************************************************************************/
+uint32 ATBMPreBCHBlockErrorRatio()
+{
+
+	uint8 ui8BlockCountMax[2];
+	uint8 ui8PreBCHBerCount[2];
+	uint8 ui8LockValue;
+	uint32 ui32BlockErrorRatio;
+
+	ATBMRead(0x0B, 0x10,&ui8BlockCountMax[0]);
+	ATBMRead(0x0B, 0x11,&ui8BlockCountMax[1]);
+
+	ui8LockValue =1;
+	ATBMWrite(0x08, 0x4d, ui8LockValue);  /*latch read only registers*/
+	ATBMRead(0x0B, 0x12,&ui8PreBCHBerCount[0]);
+	ATBMRead(0x0B, 0x13,&ui8PreBCHBerCount[1]);
+	ui8LockValue = 0;
+	ATBMWrite(0x08, 0x4d, ui8LockValue);
+	if((ui8BlockCountMax[0] == 0)&&(ui8BlockCountMax[1]==0))
+	{
+		//printf("I2C error\n");
+		ui32BlockErrorRatio = 0;
+		return ui32BlockErrorRatio;
+	}
+	ui32BlockErrorRatio  = (ui8PreBCHBerCount[1]*256 + ui8PreBCHBerCount[0])/(ui8BlockCountMax[1]*256 + ui8BlockCountMax[0]);
+	//printf(" DTMB Pre-BCH Block error ratio = %f\n", dbBlockErrorRatio);
+	return ui32BlockErrorRatio;
+}
+
+/****************************************************************************
+Function:    ATBMBER_Calc
+Parameters:  none
+Return:      BER
+
+Description:
+    This function returns calculated BER.
+****************************************************************************/
+uint32 ATBMBER_Calc()
+{
+	uint8 ber_count[3];
+	uint32 ber_calc = 0;
+	uint8 LockValue;
+
+	LockValue =1;
+	ATBMWrite(0x08, 0x4d, LockValue);  /*latch read only registers*/
+	ATBMRead(0x0B, 0x21, &ber_count[0]);
+	ATBMRead(0x0B, 0x22, &ber_count[1]);
+	ATBMRead(0x0B, 0x23, &ber_count[2]);
+	LockValue = 0;
+	ATBMWrite(0x08, 0x4d, LockValue);
+
+	ber_calc  = ((ber_count[2]&0x07)*256*256 + ber_count[1]*256 + ber_count[0])/FixPow(2,27) ; //134217728
+	return ber_calc;
+}
+
+
+/****************************DVBC Parameters************************************************/
+uint8  ui8DVBCI2CBurstMode = 0;
+// uint32 dbCMS0022MaxSymbolRateRatio         = (1.0/4);
+// uint32 dbCMS0022CIC2DELAY                  = (3.0);
+// uint32 dbCMS0022CIC3DELAY                  = (0.0);
+uint8  ui8ADvbcCciAci[]=
+{
+	0x0a, 0x3b, 0x28,
+	0x0a, 0x42, 0x10,
+	0x0a, 0x43, 0x05,
+	0x0a, 0x46, 0x00,
+	0x0a, 0x47, 0x01,
+	0x0a, 0x48, 0x14,
+	0x0a, 0x49, 0x00,
+	0x0a, 0x4a, 0x76,
+	0x0a, 0x52, 0x10,
+	0x0a, 0x53, 0x52,
+	0x0a, 0x54, 0xb1,
+	0x0a, 0x58, 0x00,
+	0x0a, 0x59, 0x40,
+	0x0a, 0x5b, 0x00,
+	0x0a, 0x5c, 0x1f,
+	0x0a, 0x5d, 0x05,
+	0x0a, 0x5e, 0x20,
+	0x0a, 0x5f, 0x00,
+	0x0a, 0x60, 0x04,
+	0x0a, 0x62, 0x1e,
+	0x0a, 0x91, 0x0f,
+	0x0a, 0x95, 0x38,
+	0x0a, 0xa0, 0xff,
+	0x0a, 0xa1, 0xfa,
+	0x0a, 0xa2, 0x00,
+	0x0a, 0xac, 0xff,
+	0x0a, 0xb2, 0x00,
+	0x0a, 0xb3, 0xff,
+	0x0a, 0xb4, 0x0f,
+	0x0a, 0xb5, 0x68,
+	0x0a, 0xb7, 0x5c,
+	0x0a, 0xb9, 0xff,
+	0x0a, 0xba, 0x0f,
+	0x0a, 0xbe, 0x9d,
+	0x0a, 0xc0, 0x14,
+	0x0a, 0xd2, 0x30,
+	0x0a, 0xd3, 0x00,
+	0x0a, 0xd4, 0x05,
+	0x0a, 0xd5, 0x40,
+	0x0a, 0xd9, 0x0a,
+	0x10, 0x81, 0xfa,
+	0x10, 0x82, 0x00,
+	0x10, 0x9d, 0x00,
+	0x10, 0x9f, 0x00,
+	0x10, 0xa1, 0x00,
+	0x10, 0xa2, 0x00,
+	0x10, 0xa7, 0x0b,
+	0x10, 0xac, 0x4d
+};
+
+static uint8 ui8ADtmbInternal[]=
+{
+	0x00, 0x16, 0x1d, //DTMB mode
+	0x09, 0x88, 0x08,
+	0x09, 0x89, 0x0c,
+	0x09, 0x9a, 0x40,
+	0x09, 0x35,0x14,
+	0x0a, 0xf9, 0x00,
+	0x0e, 0x01, 0x08,
+	0x08, 0x52, 0x28,
+	0x0c, 0x24, 0x0a,
+	0x0c, 0x26, 0x0a
+};
+static uint8 uiA8DvbcInternal[]=
+{
+	0x00, 0x0a, 0x00,
+	0x00, 0x09, 0x00,
+	0x00, 0x13, 0x01,
+	0x15, 0x18, 0x01,
+	0x15, 0x15, 0x01,
+	0x15, 0x20, 0x00,
+	0x15, 0x21, 0x80,
+	0x15, 0x2e, 0x01
+};
+
+uint8 ui8AATBM886xCommonReg[]=
+{
+	0x02, 0x45, 0x33,
+	0x02, 0x4a, 0x96,
+	0x02, 0xc6, 0x00,
+	0x02, 0xc7, 0x01
+};
+uint8 ui8AATBM886xDtmbSet[]=
+{
+	0x02, 0x28, 0x01,
+	0x02, 0xa6, 0x10,
+	0x02, 0xa9, 0x60,
+	0x02, 0xcb, 0x68,
+	0x02, 0xcc, 0x70,
+	0x02, 0x49, 0x30
+};
+uint8 ui8AATBM886xDvbcSet[]=
+{
+	0x02, 0x28, 0x00,
+	0x02, 0x3c, 0x0c,
+	0x02, 0x49, 0x29,
+	0x02, 0xa6, 0x14,
+	0x02, 0xa9, 0x4a,
+	0x02, 0xcb, 0x40,
+	0x02, 0xcc, 0x43,
+	0x15, 0x12, 0x00
+};
+
+uint8 ui8AATBM886xDtmb30Dot4MSet[]=
+{
+	0x02, 0xC5, 0x05,
+	0x02, 0x4E, 0x08,
+	0x02, 0x3E, 0x1C,
+	0x02, 0x3B, 0x1C,
+	0x0A, 0xFB, 0x00,
+	0x02, 0x3C, 0x16
+};
+uint8 ui8AATBM886xDtmb24MSet[]=
+{
+	0x02, 0xC5, 0x15,
+	0x02, 0x4E, 0x10,
+	0x02, 0x3E, 0x28,
+	0x02, 0x3B, 0x28,
+	0x0A, 0xFB, 0x01,
+	0x02, 0x3C, 0x1C
+};
+uint8 ui8ATBM886xDvbc30Dot4MSet[]=
+{
+	0x02, 0xC5, 0x05,
+	0x02, 0x4E, 0x08,
+	0x02, 0x3E, 0x1C,
+	0x02, 0x3B, 0x1C
+};
+uint8 ui8AATBM886xDvbc24MSet[]=
+{
+	0x02, 0xC5, 0x15,
+	0x02, 0x4E, 0x10,
+	0x02, 0x3E, 0x28,
+	0x02, 0x3B, 0x28
+};
+
+
+
+ /****************************************************************************
+ Function:    ATBMSetDVBCMode
+ Parameters:  none
+ Return:      none
+ Description:
+	  This function initializes ATBM886x in DVB-C mode, selects DVB-C receiving mode,
+	  then calls ATBMInit function
+	  ATBMSetConfigParas function should be called before this function.
+ ******************************************************************************/
+void ATBMSetDVBCMode(void)
+ {
+	 stCustomConfig.ui8DtmbDvbcMode = ATBM_DVBC_MODE;
+
+	 ATBMInit();
+ }
+
+/****************************************************************************
+Function:   ATBMDVBCSNR
+Parameters:   None
+Return:    DVBC signal-to-noise ratio in dB format
+
+Description:
+	Calculate  DVB-C SNR:
+******************************************************************************/
+int ATBMDVBCSNR()
+{
+	int ui32DVBCSNR;
+	int    i32Tmp,i32Tmp1;
+
+	ui32DVBCSNR = 0;
+	ATBMDVBCRead(0x3C4,&i32Tmp);
+	ATBMDVBCRead(0x3d0,&i32Tmp1);
+	i32Tmp    = i32Tmp&0xffff;
+	i32Tmp1   = (i32Tmp1&0x7)+1; //pow(2,i32Tmp1) means QAM
+
+	if(i32Tmp ==0)
+	{
+		i32Tmp = 1;
+	}
+
+	if((i32Tmp1==4) ||(i32Tmp1==6) ||(i32Tmp1==8))
+	{
+		if(i32Tmp!=0)
+		{
+// 			dbDVBCSNR = -20*log10(i32Tmp/65536.0)-0.8;//QAM=16,64,256
+			ui32DVBCSNR = -2*(Log10Convert(i32Tmp)-Log10Convert(65536))-1;
+		}
+	}
+	else if( (i32Tmp1==5) ||(i32Tmp1==7))
+	{
+		if(i32Tmp !=0)
+		{
+// 			dbDVBCSNR = -20*log10(i32Tmp/65536.0)-4.0;//QAM=32,128
+			ui32DVBCSNR = -2*(Log10Convert(i32Tmp)-Log10Convert(65536))-4;
+
+		}
+	}
+	else
+	{
+		ui32DVBCSNR=0;
+
+	}
+	//  printf("DVBC SNR = %f dB\n",dbDVBCSNR);
+	return ui32DVBCSNR;
+
+}
+
+/****************************************************************************
+Function:   ATBMDVBCBER
+Parameters: BerExponent: scientific notation exponent
+Return:     ui32BerCoeffient: RS corrected Bit error rate real number.
+Description:
+	Calculate DVB-C RS bit error rate.
+******************************************************************************/
+uint32   ATBMDVBCBER(int *pi32BerExponent)
+{
+	uint8  ui8Adata[2];
+	uint8  ui8Iter;
+	int    i32Tmp;
+	int    i32TotalBits = 13369344; //SampleSize: 8192*204*8
+	int    i32EPara = 0;
+	int    i32CorrectedBerBits = 0;
+	uint32 ui32BerCoeffient =0;
+
+	ATBMRead(0x15, 0x23,&ui8Adata[1]);
+	ATBMRead(0x15, 0x22,&ui8Adata[0]);
+	i32CorrectedBerBits = ui8Adata[1]*256 + ui8Adata[0];
+	ATBMRead(0x15, 0x21,&ui8Adata[1]);
+	ATBMRead(0x15, 0x20,&ui8Adata[0]);
+	i32TotalBits        = (ui8Adata[1]*256 + ui8Adata[0])*204*8;
+	if((i32CorrectedBerBits ==0)||(i32TotalBits == 0))
+	{
+		ui32BerCoeffient = 0;
+		*pi32BerExponent = 0;
+		//printf("PreRsBer = %f E- %d\n",dbBerCoeffient, *BerExponent);
+		return ui32BerCoeffient;
+	}
+	for (ui8Iter=0;ui8Iter<12;ui8Iter++)
+	{
+		i32Tmp = i32CorrectedBerBits/i32TotalBits;
+		if (i32Tmp)
+		{
+			ui32BerCoeffient = i32CorrectedBerBits/i32TotalBits;
+			break;
+		}
+		else
+		{
+			i32EPara +=1;
+			i32CorrectedBerBits *=10;
+		}
+	}
+	*pi32BerExponent  = i32EPara;
+	//printf("PreRsBer = %f E- %d\n",dbBerCoeffient, *BerExponent);
+	return ui32BerCoeffient;
+}
+
+/****************************************************************************
+Function:   ATBMDVBCUncorrectablePER
+Parameters: i32pPktsExponent: scientific notation exponent
+Return:   ui32PktsCoeffient: error packets rate real number.
+Description:
+	This function counts DVB-C ui8AData packet which contains uncorrected error and calculate packet error rates.
+******************************************************************************/
+uint32  ATBMDVBCUncorrectablePER(int *i32pPktsExponent )
+{
+	uint8  ui8AData[2],ui8Iter;
+	int    i32Tmp;
+	int    i32TotalPkts = 8192; //SampleSize: 8192 packets
+	int    i32EPara = 0;
+	int    i32UncorrectedPackets = 0;
+	uint32 ui32PktsCoeffient = 0;
+
+	ATBMRead(0x15, 0x27,&ui8AData[1]);
+	ATBMRead(0x15, 0x26,&ui8AData[0]);
+	i32UncorrectedPackets = ui8AData[1]*256 + ui8AData[0];
+	ATBMRead(0x15, 0x21,&ui8AData[1]);
+	ATBMRead(0x15, 0x20,&ui8AData[0]);
+	i32TotalPkts          = ui8AData[1]*256 + ui8AData[0];
+
+	if((i32UncorrectedPackets ==0)||(i32TotalPkts == 0))
+	{
+		ui32PktsCoeffient   = 0;
+		*i32pPktsExponent = 0;
+		//printf("Pks Error = %f E- %d\n",dbPktsCoeffient, *i32pPktsExponent);
+		return ui32PktsCoeffient;
+	}
+	for (ui8Iter=0;ui8Iter<12;ui8Iter++)
+	{
+		i32Tmp = i32UncorrectedPackets/i32TotalPkts;
+		if (i32Tmp)
+		{
+			ui32PktsCoeffient = (i32UncorrectedPackets)/i32TotalPkts;
+			break;
+		}
+		else
+		{
+			i32EPara += 1;
+			i32UncorrectedPackets *=10;
+		}
+	}
+	*i32pPktsExponent  = i32EPara;
+	//printf("Pks Error = %f E- %d\n",dbPktsCoeffient, *i32pPktsExponent);
+	return ui32PktsCoeffient;
+
+}
+
+/****************************************************************************
+Function:     ATBMDVBCGetQAM
+Parameters:   None
+Return:       QAM_index
+Description:
+	Get DVB-C QAM index
+	4: 16QAM
+	5: 32QAM
+	6: 64QAM
+	7: 128QAM
+	8: 256QAM
+******************************************************************************/
+uint8   ATBMDVBCGetQAM()
+{
+	uint8 ui8QAMIndex;
+	int   i32Tmp;
+
+	ATBMDVBCRead(0x3d0,&i32Tmp);
+	ui8QAMIndex = (uint8)((i32Tmp&0x7)+1); //pow(2,tmp) means QAM
+	//printf("DVB-C signal QAM index = %d \n", QAM_index);
+	return ui8QAMIndex;
+}
+
+/*****************************************************************************
+Function:    ATBMDVBCSignalStrength
+Parameters:  none
+Return:      XgcGain
+Description:
+    This function checks DVB-C external IF gain value used by the XGC. The function
+    can be used for DVB-C signal strength evaluation.
+    Different Tuner have different XgcGain Range. It is needed to test XgcGain value
+    on different signal strength level to make a Tuner's private signal strength evaluation function.
+*****************************************************************************/
+int ATBMDVBCSignalStrength()
+{
+	int i32XgcGain;
+	int i32XgcGain1;
+
+	ATBMDVBCRead(0x114,&i32XgcGain1);
+	i32XgcGain = (int)(i32XgcGain1&0xfff);
+//	printf(" XgcGain = 0x%x\n", XgcGain);
+	return i32XgcGain;
+}
+
+/****************************************************************************
+Function:		ATBMDVBCInit
+Parameters:   stCustomConfig
+Return: 		None
+Description:
+	Call this function to configure all DVBC related registers.
+******************************************************************************/
+void ATBMDVBCInit( custom_config_t stCustomConfig)
+{
+
+	uint8  ui8RegH, ui8RegL , ui8Rst, ui8TmpData, ui8pll;
+	uint8 ui8ATBMChipID;
+	uint16 ui16ParamsDvbcRatio;
+	int    i32TmpRst;
+	//int    i32Length = 0;
+	int    i32RifControl;
+	//int    i32DebugData = 0;
+	int	   i32ItbCoarseFrequencyOffset;
+	int ui32OSCFreq = 0;
+	int ui32IFFreq = 0;
+	uint32 ui32SymbolRateM, ui32SysClk,ui32ItbCoarseFrequencyOffset;
+	ui8ATBMChipID = ATBMChipID();
+	ATBMDVBCWrite(0x04, 0x1);  //DVBC Module Reset
+	if(stCustomConfig.stDvbcParams.ui8InputMode == DVBC_IF_INPUT)
+	{
+		i32RifControl = 0x01; //IF mode
+		ATBMDVBCWrite(0x100, i32RifControl);
+
+		//886x special register
+		if(ui8ATBMChipID == 0x40)
+		{
+			ATBMDVBCWrite(0x104,0x01);
+			ATBMDVBCWrite(0x304,0x05);
+		}
+
+	}else
+	{
+		i32RifControl = 0x00; //IQmode
+		ATBMDVBCWrite(0x100, i32RifControl);
+		ATBMDVBCWrite(0x104,0x01);  //gain control
+		ATBMDVBCWrite(0x118, 0x00);
+		ATBMWriteRegArray(ui8ADvbcCciAci,sizeof(ui8ADvbcCciAci)/sizeof(uint8));
+	}
+
+	ui32SymbolRateM = (stCustomConfig.stDvbcParams.i32SymbolRate);
+
+	//886x special register setting
+	if(ui8ATBMChipID == 0x40)
+	{
+		ui16ParamsDvbcRatio = (uint16)(ui32SymbolRateM*1032/1000);
+		ui8RegH = ui16ParamsDvbcRatio/256;
+		ui8RegL = ui16ParamsDvbcRatio&0xff;
+		ATBMWrite(0x02, 0x53, ui8RegL);
+		ATBMWrite(0x02, 0x54, ui8RegH);
+		if(stCustomConfig.ui32SampleClkFrequency == 30400) //30.4MHz crystal
+		{
+			ATBMRead(0x06, 0x0e,&ui8TmpData);
+			if(ui8TmpData&0x08)
+			{
+				ui8Rst =(uint8)(4778125/ui32SymbolRateM/40);
+			}else
+			{
+				ui8Rst =(uint8)(4180000/ui32SymbolRateM/40);
+			}
+			ATBMWrite(0x15, 0x37, ui8Rst);
+		}
+		if(stCustomConfig.ui32SampleClkFrequency == 24000) //24MHz crystal
+		{
+			ATBMRead(0x06, 0x0e,&ui8TmpData);
+			if(ui8TmpData&0x08)
+			{
+				ui32SysClk = 64;
+			}else
+			{
+				ui32SysClk = 72;
+			}
+			ui8Rst =(uint8)(6875*ui32SysClk/ui32SymbolRateM/4);
+			ATBMWrite(0x15, 0x37, ui8Rst);
+		}
+	}
+	//end for 886x
+
+	ui32DvbcSymbolRate = stCustomConfig.stDvbcParams.i32SymbolRate;
+	if(stCustomConfig.ui32SampleClkFrequency == 24000) //24MHz crystal
+	{
+		ui32OSCFreq = stCustomConfig.ui32SampleClkFrequency*2;
+		if(ui8ATBMChipID == 0x30)
+		{
+			ATBMDVBCWrite(0x104,0x14);
+		}
+	}
+	else
+	{
+		ui32OSCFreq = stCustomConfig.ui32SampleClkFrequency;
+		if(ui8ATBMChipID == 0x30)
+		{
+			ATBMDVBCWrite(0x104,0x34);
+		}
+	}
+	ui32DvbcOscFreq= ui32OSCFreq;
+	if(stCustomConfig.stDvbcParams.ui8InputMode == DVBC_IF_INPUT)
+	{
+		ui32IFFreq = stCustomConfig.stTunerConfig.ui32IFFrequency;
+		i32TmpRst = (ui32OSCFreq>ui32IFFreq?(ui32OSCFreq - ui32IFFreq):(ui32IFFreq -ui32OSCFreq)*-1);
+		if (ui32OSCFreq>ui32IFFreq)
+		{
+			ui32ItbCoarseFrequencyOffset = i32TmpRst/100;
+			ui32ItbCoarseFrequencyOffset = (8388608*ui32ItbCoarseFrequencyOffset/(ui32OSCFreq/100)*16);//no problem
+			ATBMDVBCWrite(DVBC_COARSE_FREQUENCY_OFFSET_ADDR,ui32ItbCoarseFrequencyOffset);
+		}
+		else
+		{
+			i32ItbCoarseFrequencyOffset= (8388608*(i32TmpRst/100)/(ui32OSCFreq/100)*16);//no problem
+			ATBMDVBCWrite(DVBC_COARSE_FREQUENCY_OFFSET_ADDR,i32ItbCoarseFrequencyOffset);
+		}
+	}
+	ATBMDVBCSetCarrier(ui32OSCFreq,	ui32SymbolRateM);
+	ATBMDVBCSetSymbolRate(ui32OSCFreq, ui32SymbolRateM);
+	ATBMDVBCSetQAM();
+
+	ATBMDVBCWrite(0x20c,0x10);
+	ATBMDVBCWrite(0x204,0x400); //DVB-C symbol rate offset related
+	ATBMDVBCWrite(0x04, 0x00);  //DVBC Module start processing
+	if(ui8ATBMChipID == 0x40)
+	{
+		if(stCustomConfig.ui32SampleClkFrequency == 24000) //24MHz crystal
+		{
+			ATBMWrite(0x01, 0x0c, 0x00);
+			Delayms(1);/*1 ms*/
+			ATBMRead(0x06, 0x0e, &ui8pll);
+			ATBMWrite(0x06, 0x04, 0x01);
+			ui8pll |= 0x01;
+			ATBMWrite(0x06, 0x0e,ui8pll);
+			ui8pll &= 0xfe;
+			ATBMWrite(0x06, 0x0e,ui8pll);
+			ATBMWrite(0x06, 0x04, 0x00);
+			Delayms(1);/*1 ms*/
+			ATBMWrite(0x01, 0x0c, 0x01);
+		}
+	}
+}
+
+/****************************************************************************
+Function:		ATBMDVBCSetSymbolRate
+Parameters:     ui32OscFreq: OSC sampling frequency, in KHz
+                ui32SymbolRateM, symbol rate, in Ksbps
+Return: 		None
+Description:
+	Call this function to configure all DVB-C  symbol rate related registers.
+******************************************************************************/
+void ATBMDVBCSetSymbolRate(uint32 ui32OscFreq, uint32 ui32SymbolRateM)
+{
+	uint32  ui32Log2DecFactor;
+	uint32	ui32DecCicOutputShift;
+	uint32	ui32AfcSlowControlTC;
+	uint32	ui32TrlSampleRate;
+	uint32	ui32TrlSampleRateRecip;
+// 	uint32  ui32CicDcGain;
+
+	// Calculate factor by which decimation filter must reduce rate
+// 	ui32Log2DecFactor = (uint32)(floor(log10(((dbCMS0022MaxSymbolRateRatio*dbOscFreq)/dbSymbolRateM))/log10(2.0)));
+	ui32Log2DecFactor = (Log10Convert(ui32OscFreq)-Log10Convert(4)-Log10Convert(ui32SymbolRateM))/Log10Convert(2);
+	// Samples per symbol
+	if(ui32Log2DecFactor > 3)
+	{
+		ui32Log2DecFactor=3;
+	}
+//  	ui32TrlSampleRate = ((1<<16)*2/(dbSmpsPerSymb/(1<<ui32Log2DecFactor)));
+	ui32TrlSampleRate = 131072*FixPow(2,ui32Log2DecFactor)*ui32SymbolRateM/ui32OscFreq;
+	ATBMDVBCWrite(DVBC_SAMPLE_RATE_ADDR, ui32TrlSampleRate);
+
+//  ui32TrlSampleRateRecip = (int)(((1<<11)*(dbSmpsPerSymb/(1<<ui32Log2DecFactor))/2));
+	ui32TrlSampleRateRecip = 1024*FixPow(2,ui32Log2DecFactor)*ui32OscFreq/ui32SymbolRateM;
+
+
+	if(ui32TrlSampleRateRecip > 0x3fff)
+	{
+		ui32TrlSampleRateRecip = 0x3fff;
+	}
+	ATBMDVBCWrite(DVBC_SAMPLE_RATE_RECIP_ADDR, ui32TrlSampleRateRecip);
+	// Calculate CIC gain
+// 	dbCicDcGain  = pow(2*(1<<(ui32Log2DecFactor-1)),(int)dbCMS0022CIC2DELAY);
+// 	//Calculate CIC gain *=
+// 	dbCicDcGain *= pow(3*(1<<(ui32Log2DecFactor-1)),(int)dbCMS0022CIC3DELAY);
+	ui32DecCicOutputShift = 1;
+
+	if(ui32Log2DecFactor ==1)
+	{
+		ui32DecCicOutputShift = 4;
+	}
+	if(ui32Log2DecFactor == 2)
+	{
+		ui32DecCicOutputShift = 7;
+	}
+	if(ui32Log2DecFactor == 3)
+	{
+		ui32DecCicOutputShift = 10;
+	}
+
+// 	ui32CicDcGain = 1;
+
+// 	ui32DecCicOutputShift = (ui32Log2DecFactor > 0) ? ((uint32)((log10(dbCicDcGain)/log10(2.0))+0.5)+1) : 1;
+// 	ui32DecCicOutputShift = (ui32Log2DecFactor > 0) ? (((Log10Convert(ui32CicDcGain)/Log10Convert(2))+1)) : 1;
+	ATBMDVBCWrite(DVBC_OUTPUT_SHIFT_ADDR, ui32DecCicOutputShift);
+	ATBMDVBCWrite(DVBC_DECIMATION_FACTOR_ADDR,ui32Log2DecFactor);
+	// Program AFC tracking time constant as function of symbol rate
+	ui32AfcSlowControlTC = (1<<(ui32Log2DecFactor+2));
+	ATBMDVBCWrite(DVBC_SLOW_CONTROL_TC_ADDR,ui32AfcSlowControlTC);
+}
+
+/****************************************************************************
+Function:	ATBMDVBCSetCarrier
+Parameters: ui32OscFreq: OSC sampling frequency, 30400, in kHz
+            ui32SymbolRateM, symbol rate.
+Return: 	None
+Description:
+	Call this function to configure DVBC registers according to OSC frequency
+	and symbol rate.
+******************************************************************************/
+void   ATBMDVBCSetCarrier(uint32 ui32OscFreq,uint32 ui32SymbolRateM)
+{
+	int	    i32IfSrchStartFreq;
+	int	    i32IfSrchStepFreq;
+	uint32	ui32TimSearchLockTimeout;
+	uint32	ui32PlCarrierFrequencyRange;
+	uint32	ui32CarrierLockAcquireTimeout;
+	uint32  ui32IfSearchStartFoOvrFsamp;
+	uint32  ui32IfSearchStepFstpOvrFsamp;
+// 	double  dbWinEndFreqMHz = 3*dbSymbolRateM/20;
+
+// 	ui32IfSearchStartFoOvrFsamp = /*dbWinEndFreqMHz*/3*ui32SymbolRateM/ui32OscFreq/20;
+	ui32IfSearchStartFoOvrFsamp = /*dbWinEndFreqMHz*/393216*ui32SymbolRateM/(ui32OscFreq/5);
+	if(ui32SymbolRateM != 0)
+	{
+// 		ui32IfSearchStepFstpOvrFsamp = ui32SymbolRateM*5/ui32OscFreq/100;
+		ui32IfSearchStepFstpOvrFsamp = 131072*ui32SymbolRateM/(ui32OscFreq/5);
+	}
+	else
+	{
+		ui32IfSearchStepFstpOvrFsamp = 0;
+	}
+// 	i32IfSrchStartFreq = (int)(((dbIfSearchStartFoOvrFsamp)*(1<<27))+0.5);
+	i32IfSrchStartFreq = ui32IfSearchStartFoOvrFsamp*1024/100;
+
+	ATBMDVBCWrite(DVBC_SEARCH_RANGE_ADDR,i32IfSrchStartFreq);
+
+	i32IfSrchStepFreq = ui32IfSearchStepFstpOvrFsamp*1024/100;
+	ATBMDVBCWrite(DVBC_SEARCH_STEP_ADDR,i32IfSrchStepFreq);
+	// Program parameters for fine stepped carrier search
+	// Step size
+	ui32TimSearchLockTimeout = 20;	// 20 for 1% step;
+	ATBMDVBCWrite(DVBC_PL_CARRIER_STEP_FREQUENCY_ADDR,ui32TimSearchLockTimeout);
+	// Search range
+	ui32PlCarrierFrequencyRange = 39;// 39 for +/-15% limits
+	ATBMDVBCWrite(DVBC_PL_CARRIER_FREQUENCY_RANGE_ADDR,ui32PlCarrierFrequencyRange);
+	// Standard times and thresholds for all other QAM levels
+	ui32CarrierLockAcquireTimeout = 4;
+	ATBMDVBCWrite(DVBC_CARRIER_LOCK_ACQUIRE_TIMEOUT_ADDR, ui32CarrierLockAcquireTimeout);
+
+}
+
+/****************************************************************************
+Function:	ATBMDVBCSetQAM
+Parameters: none
+Return: 	None
+Description:Call this function to configure DVBC QAM related registers:
+******************************************************************************/
+void ATBMDVBCSetQAM()
+{
+	int	i32BitSyncDetectTimeout;
+	ATBMDVBCWrite(DVBC_AUTO_EQU_SEARCH_ADDR,0x3f8); //Auto QAM detect
+	i32BitSyncDetectTimeout = 60000/(256*16);
+	ATBMDVBCWrite(DVBC_BITSYNC_DETECT_TIMEOUT_ADDR,i32BitSyncDetectTimeout);
+}
+
+void   ATBMSetConfigParas(custom_config_t stCustomConfigp)
+{
+	stCustomConfig = stCustomConfigp;
+}
+
+/****************************************************************************
+Function:     ATBMInit
+Parameters:   none
+Return:       none
+Description:
+    Initializes ATBM886x demodulator and configures all necessary registers.
+    The demodulator will start processing incoming data after this function is called.
+******************************************************************************/
+void ATBMInit()
+{
+	uint8 ui8ATBMChipID;
+	Delayms(1);/*1 ms*/
+	ATBMWrite(0x01, 0x0c, 0x01);//i2c clock using PLL, 1:PLL, 0:Crystal.
+	//Delayms(10); /*10 ms*/
+	ATBMWrite(0x00, 0x04, 0x00);
+	ATBMWrite(0x10, 0xf7, 0xe8);
+	ATBMWrite(0x10, 0xfb, 0x07);
+	ui8ATBMChipID = ATBMChipID();
+	if(ui8ATBMChipID == 0x40)
+	{
+		ATBMWriteRegArray(ui8AATBM886xCommonReg,sizeof(ui8AATBM886xCommonReg)/sizeof(unsigned char));
+	}
+	ATBMConfig( stCustomConfig);
+	if(stCustomConfig.ui8DtmbDvbcMode == ATBM_DVBC_MODE)
+	{
+		ATBMWriteRegArray(uiA8DvbcInternal,sizeof(uiA8DvbcInternal)/sizeof(unsigned char));
+
+		if(stCustomConfig.stDvbcParams.ui8InputMode == DVBC_IF_INPUT)
+		{
+			ATBMWrite(0x15, 0x11, 0x01);
+			if(ui8ATBMChipID == 0x40)
+			{
+				ATBMWrite(0x15, 0x12, 0x00);
+			}
+			if(ui8ATBMChipID == 0x30)
+			{
+				ATBMWrite(0x15, 0x12, 0x01);
+			}
+			ATBMWrite(0x00, 0x16, 0x00);
+		}
+		if(stCustomConfig.stDvbcParams.ui8InputMode == DVBC_IQ_INPUT)
+		{
+			ATBMWrite(0x00, 0x16, 0x03);
+		}
+		if(ui8ATBMChipID == 0x40)
+		{
+			ATBMWrite(0x02, 0x52, 0x01);
+			ATBMWriteRegArray(ui8AATBM886xDvbcSet,sizeof(ui8AATBM886xDvbcSet)/sizeof(uint8));
+			if(stCustomConfig.ui32SampleClkFrequency == 24000)
+			{
+				ATBMWriteRegArray(ui8AATBM886xDvbc24MSet,sizeof(ui8AATBM886xDvbc24MSet)/sizeof(uint8));
+			}
+			if(stCustomConfig.ui32SampleClkFrequency == 30400)
+			{
+				ATBMWriteRegArray(ui8ATBM886xDvbc30Dot4MSet,sizeof(ui8ATBM886xDvbc30Dot4MSet)/sizeof(uint8));
+			}
+		}
+		ATBMDVBCInit(stCustomConfig);
+	}
+	else //DTMB mode
+	{
+		ATBMWrite(0x00, 0x0a, 0x01);
+		ATBMWrite(0x00, 0x09, 0x01);
+		ATBMWrite(0x00, 0x13, 0x00); //DTMB mode
+		ATBMWrite(0x15, 0x18, 0x00);
+		ATBMWrite(0x15, 0x15, 0x00);
+		ATBMWrite(0x15, 0x11, 0x00);
+		ATBMWrite(0x15, 0x12, 0x00);
+		if(ui8ATBMChipID == 0x40)
+		{
+			ATBMWrite(0x02, 0x52, 0x00);
+			ATBMWriteRegArray(ui8AATBM886xDtmbSet,sizeof(ui8AATBM886xDtmbSet)/sizeof(unsigned char));
+			if(stCustomConfig.ui32SampleClkFrequency == 24000)
+			{
+				ATBMWriteRegArray(ui8AATBM886xDtmb24MSet,sizeof(ui8AATBM886xDtmb24MSet)/sizeof(unsigned char));
+			}
+			if(stCustomConfig.ui32SampleClkFrequency == 30400)
+			{
+				ATBMWriteRegArray(ui8AATBM886xDtmb30Dot4MSet,sizeof(ui8AATBM886xDtmb30Dot4MSet)/sizeof(unsigned char));
+			}
+		}
+		ATBMWriteRegArray(ui8ADtmbInternal,sizeof(ui8ADtmbInternal)/sizeof(unsigned char));
+	}
+
+	ATBMWrite(0x08,0x00,0xa0);
+	ATBMWrite(0x08,0x01,0x16);
+	ATBMWrite(0x00, 0x04, 1);	// write 1 config done
+
+#if ATMB_DBG_OUTPUT
+	ATBMDebugRegister();
+#endif
+}
+
+/****************************************************************************
+Function:    ATBMConfig
+Parameters:  custom_config
+Return:      none
+
+Description:
+     Set registers according to customer's configuration,
+     This function configures ATBM886x.
+ ******************************************************************************/
+ void ATBMConfig( custom_config_t stCustomConfigp)
+ {
+	 /*Demodulator default clock 30.4MHz; Tuner IF 36.166Mhz*/
+	 ATBMSetOSC(stCustomConfigp.stTunerConfig,stCustomConfigp.ui32SampleClkFrequency);
+	 /*Configures  MPEG TS output  mode*/
+	 ATBMSetTSMode(stCustomConfigp.stTsMode);
+	 ATBMWrite(0x01, 0x02, 1);	 //I2C related
+	 ATBMWrite(0x02, 0x0c, ui8ATBMSoftwareVersion);
+ }
+
+ /****************************************************************************
+Function:    ATBMSetTSMode
+Parameters:  stTSMode
+Return:      none
+Description:
+      This function configures Transport stream interface mode.
+******************************************************************************/
+void ATBMSetTSMode( MPEG_TS_mode_t stTSMode)
+{
+	uint8 ui8ChipID;
+	uint8 ui8SerialEnabled =0x0;/*parallel clock out */
+	uint8 ui8TSOutputEdegeMode = stTSMode.ui8OutputEdge;
+	uint8 ui8TsClockMode = stTSMode.ui8SPIClockConstantOutput;
+
+	/*0x00: SPI data align with rising edge of TSBCLK; 0x01: SPI data align with falling edge of TSBCLK*/
+	ATBMWrite(0x03,0x01, ui8TSOutputEdegeMode);
+	ATBMWrite(0x03,0x06, ui8TsClockMode);  /*either free running or only active when data are valid*/
+	ATBMWrite(0x03,0x11, 0);
+	ATBMRead(0x00,0x00, &ui8ChipID);
+	if(ui8ChipID == 0x40)
+	{
+		ATBMWrite(0x03,0x12, 1);//886x special
+		ATBMWrite(0x0b,0x24, 0x01);
+	}
+	if(stTSMode.ui8TSTransferType==TS_SERIAL_MODE)
+	{
+		ui8SerialEnabled = 0x01;    /*enable serial TS mode */
+
+		//SSI_sync_hold_cycle = 0x00; //0x00:1 bit sync;0x01: 8 bit sync
+		/*0: serial sync  holds 1 cycle; 1: serial sync holds 8 cycles*/
+		//ATBMWrite(0x03,0x0f, SSI_sync_hold_cycle);
+
+		/*0:disable serial mode; 1: enable serial mode */
+		ATBMWrite(0x03,0x05, ui8SerialEnabled);
+		if(stTSMode.ui8TSSSIOutputSelection == TS_SSI_OUTPUT_ON_DATA_BIT0)
+		{
+			ATBMWrite(0x03, 0x1f, 0x00);
+		}else
+		{
+			ATBMWrite(0x03, 0x1f, 0x01);
+		}
+	}
+	else
+	{
+		ui8SerialEnabled =0x0; /*parallel clock output */
+		/*0: disable serial mode; 1:enable serial mode */
+		ATBMWrite(0x03,0x05, ui8SerialEnabled);
+		if(stTSMode.ui8TSSPIMSBSelection == TS_SPI_MSB_ON_DATA_BIT7)
+		{
+			ATBMWrite(0x03, 0x1f, 0x00);
+		}else
+		{
+			ATBMWrite(0x03, 0x1f, 0x01);
+		}
+	}
+}
+
+/****************************************************************************
+Function:    ATBMSetOSC
+Parameters:  stTunerConfig, ui32SampleClkFrequency
+Return:      1 for success,0 for error
+Description:
+     This function configures ATBM886x according to external Clock source
+     and  Tuner IF frequency.
+ ******************************************************************************/
+int ATBMSetOSC( tuner_config_t stTunerConfig, uint32 ui32SampleClkFrequency)
+{
+	/*Demodulator default registers are for 30.4 MHz crystal, no need to list here.*/
+	uint8  ui8ARXFLT[6];
+	uint8  ui8BandWidth;
+	uint8  ui8SwapIQ;
+	uint8  ui8ARge[3], ui8ChipID;
+	uint8 ui8Tmp;
+	uint16 ui16ParamsFSADC, ui16ParamsIFFreq;
+	uint32 ui32ParamsFSADCInverse;
+	int    i32FreqLifTmp;
+	int    i32RateRatioTmp;
+	uint32 ui32TunerIFFrequency = stTunerConfig.ui32IFFrequency/100;
+	uint32 ui32CLKFreq = ui32SampleClkFrequency/100;//0.1MHz origin is MHz
+	ATBMRead(0x00,0x00, &ui8ChipID);
+	if(stTunerConfig.ui8IQmode == SWAP_IQ)
+	{
+		ui8SwapIQ = 0x03;
+		ATBMWrite(0x0c,0x01, ui8SwapIQ);
+	}
+	else
+	{
+		ATBMWrite(0x0c,0x01, 0x01);
+	}
+	/* 0x0A03~0x0A05 are only related to sampling frequency;
+	* 0x0A00~0x0A02 are related to sampling frequency and tuner IF frequency.*/
+	if(ui32TunerIFFrequency>ui32CLKFreq)
+	{
+		i32FreqLifTmp=(26353589*(ui32TunerIFFrequency-ui32CLKFreq)/ui32CLKFreq);
+	}
+	else //low IF
+	{
+		i32FreqLifTmp=(26353589*ui32TunerIFFrequency/ui32CLKFreq);
+	}
+	ui8ARXFLT[0] = (uint8)(i32FreqLifTmp&0xff);
+	ui8ARXFLT[1] = (uint8)((i32FreqLifTmp>>8)&0xff);
+	ui8ARXFLT[2] = (uint8)((i32FreqLifTmp>>16)&0xff);
+
+	ATBMWrite(0x0A,0x00, ui8ARXFLT[0]);
+	ATBMWrite(0x0A,0x01, ui8ARXFLT[1]);
+	ATBMWrite(0x0A,0x02, ui8ARXFLT[2]);
+	//printf("IF freq_lif: 0x%x 0x%x  0x%x\n", ui8ARXFLT[0], ui8ARXFLT[1], ui8ARXFLT[2]);
+
+	ui8BandWidth = stTunerConfig.ui8DTMBBandwithMHz;
+	i32RateRatioTmp = (4194304*ui32CLKFreq/(ui8BandWidth*152));
+
+	//i32RateRatioTmp=(int)floor(2*dbCLKFreq*(1<<19)/30.4 + 0.5);
+	ui8ARXFLT[3] = (uint8)(i32RateRatioTmp&0xff);
+	ui8ARXFLT[4] = (uint8)((i32RateRatioTmp>>8)&0xff);
+	ui8ARXFLT[5] = (uint8)((i32RateRatioTmp>>16)&0x1f);
+	ATBMWrite(0x0A,0x03, ui8ARXFLT[3]);
+	ATBMWrite(0x0A,0x04, ui8ARXFLT[4]);
+	ATBMWrite(0x0A,0x05, ui8ARXFLT[5]);
+	//printf("ADC rate ratio: 0x%x 0x%x  0x%x\n", ui8ARXFLT[3], ui8ARXFLT[4], ui8ARXFLT[5]);
+	if(ui32CLKFreq == 240) //24MHz crystal, register should set here.
+	{
+		ATBMRead(0x06,0x0e,&ui8Tmp);
+		ATBMWrite(0x06,0x0e, ui8Tmp|0x4);
+		if(ui8ChipID == 0x30)
+		{
+			ATBMWrite(0x0a,0xfb,0x02);
+		}
+		if(ui8ChipID == 0x40)
+		{
+			ATBMWrite(0x0a,0xfb,0x01);
+		}
+	}
+	ATBMRead(0x00,0x00, &ui8ChipID);
+	if(ui8ChipID == 0x40)
+	{
+		ui16ParamsFSADC = (uint16)(ui32CLKFreq * 2048/10);
+		ui8ARge[1] = ui16ParamsFSADC/256;
+		ui8ARge[0] = ui16ParamsFSADC&0xff;
+		ATBMWrite(0x02, 0x33, ui8ARge[0]);
+		ATBMWrite(0x02, 0x34, ui8ARge[1]);
+		ui32ParamsFSADCInverse = 20971520/ui32CLKFreq;
+		ui8ARge[0] = (uint8)(ui32ParamsFSADCInverse&0xff);
+		ui8ARge[1] = (uint8)((ui32ParamsFSADCInverse>>8)&0xff);
+		ui8ARge[2] = (uint8)((ui32ParamsFSADCInverse>>16)&0x01);
+		ATBMWrite(0x02, 0x9d, ui8ARge[0]);
+		ATBMWrite(0x02, 0x9e, ui8ARge[1]);
+		//ATBMWrite(0x02, 0x9f, ui8ARge[2]);
+		if(ui32CLKFreq == 240) //24MHz crystal, register should set here.
+		{
+			ui8ARge[2] = ui8ARge[2]|0x02;
+			ATBMWrite(0x02, 0x9f, ui8ARge[2]);
+		}
+		if(ui32CLKFreq == 304) //30.4MHz crystal, register should set here.
+		{
+			ATBMWrite(0x02, 0x9f, ui8ARge[2]);
+		}
+		if(ui32TunerIFFrequency > ui32CLKFreq)
+		{
+			ui16ParamsIFFreq = (ui32TunerIFFrequency-ui32CLKFreq)*2048/10;//to mhz
+		}
+		else //low IF
+		{
+			ui16ParamsIFFreq = ui32TunerIFFrequency*2048/10;
+		}
+		ui8ARge[1] = ui16ParamsIFFreq/256;
+		ui8ARge[0] = ui16ParamsIFFreq&0xff;
+		ATBMWrite(0x02, 0x31,  ui8ARge[0]);
+		ATBMWrite(0x02, 0x32,  ui8ARge[1]);
+		if(ui8BandWidth == 8)
+		{
+			ATBMWrite(0x02, 0x51, 0x00);
+		}
+		else if(ui8BandWidth == 7)
+		{
+			ATBMWrite(0x02, 0x51, 0x01);
+		}
+		else if(ui8BandWidth == 6)
+		{
+			ATBMWrite(0x08, 0x44, 0x00);
+			ATBMWrite(0x14, 0x8a, 0x0f);
+			ATBMWrite(0x02, 0x51, 0x02);
+		}else
+		{
+			ATBMWrite(0x02, 0x51, 0x00);
+		}
+		if(ui32CLKFreq == 240)
+		{
+			ATBMWrite(0x02, 0x90, 0xd0);
+			ATBMWrite(0x02, 0x91, 0x93);
+			ATBMWrite(0x02, 0x92, 0x01);
+		}
+		if(ui32CLKFreq == 304)
+		{
+			ATBMWrite(0x02, 0x90, 0x00);
+			ATBMWrite(0x02, 0x91, 0xe0);
+			ATBMWrite(0x02, 0x92, 0x01);
+		}
+	}
+	return 1;
+}
+
+/****************************************************************************
+Function:    ATBMGetTPS
+Parameters:  none
+Return:      TPS index
+Description:
+      This function checks signal TPS. The return value is TPS index in GB20600-2006
+ ****************************************************************************/
+uint8 ATBMGetTPS()
+{
+	uint8 ui8TPS;
+    if(ATBM_I2CREADWRITE_OK == ATBMRead(0x0d,0x04,&ui8TPS))
+		return ui8TPS;
+	else
+		return 0xff;
+}
+
+
+/****************************************************************************
+Function:    ATBMDebugRegister
+Parameters:  none
+Return:      none
+Description:
+      This function checks Demodulator registers,  used for debug purpose
+ ****************************************************************************/
+void ATBMDebugRegister()
+{
+   /*common register*/
+	uint8 ui8SoftwareVersion;
+	uint8  ui8dDmodState;
+	uint8  ui8ConfigDone;
+ 	uint8  ui8FreqOffset;
+ 	uint8  ui8SDPReset;
+	uint8  ui8I2CByPassState;
+	uint8  ui8CANTuner;
+	uint8  ui8ARXFLT[6];
+	/*tuner related config*/
+	uint8  ui8ADCConfig;
+	uint8  ui8LNAOnOff;
+	uint8  ui8FatalRst, ui8WeakRst;
+	/*TS interface configuration*/
+	uint8 ui8SamplingEdegeMode;
+	uint8 ui8SerialEnabled;
+	uint8 ui8ClockOutSelect;
+
+	ATBMRead(0x02, 0x0c,&ui8SoftwareVersion);
+	ATBMRead(0x06, 0x07,&ui8dDmodState);
+	ATBMRead(0x00, 0x04,&ui8ConfigDone);
+	ATBMRead(0x00, 0x0A,&ui8SDPReset);
+	printf("Current software version: %d\n", ui8SoftwareVersion);
+	printf("ui8dDmodState:0x%x configure done:0x%x ui8SDPReset:0x%x\n",ui8dDmodState, ui8ConfigDone,ui8SDPReset);
+
+	/*Demod passing I2C commands between host and tuner. 0:disable 1:enable.*/
+	ATBMRead(0x01, 0x03,&ui8I2CByPassState);
+   	ATBMRead(0x00, 0x01,&ui8CANTuner);
+	printf("bypass state:0x%x; Tuner used(silicon tuner=0):0x%x\n", ui8I2CByPassState, ui8CANTuner);
+
+	ATBMRead(0x06, 0x02,&ui8ADCConfig);
+	ATBMRead(0x10, 0x30,&ui8LNAOnOff);
+	printf("tuner ui8ADCConfig: 0x%x; ui8LNAOnOff: 0x%x\n", ui8ADCConfig, ui8LNAOnOff);
+
+   	ATBMRead(0x08, 0x00,&ui8FreqOffset);
+	printf("ui8FreqOffset 0x08_0x00: 0x%x\n", ui8FreqOffset);
+	ATBMRead(0x08, 0x01,&ui8FreqOffset);
+	printf("ui8FreqOffset 0x08_0x01: 0x%x\n", ui8FreqOffset);
+
+	ATBMRead(0x0A, 0x00,&ui8ARXFLT[0]);
+	ATBMRead(0x0A, 0x01,&ui8ARXFLT[1]);
+	ATBMRead(0x0A, 0x02,&ui8ARXFLT[2]);
+	ATBMRead(0x0A, 0x03,&ui8ARXFLT[3]);
+	ATBMRead(0x0A, 0x04,&ui8ARXFLT[4]);
+	ATBMRead(0x0A, 0x05,&ui8ARXFLT[5]);
+	printf("IF freq_lif: 0x%x 0x%x  0x%x\n", ui8ARXFLT[0], ui8ARXFLT[1], ui8ARXFLT[2]);
+	printf("ADC rate ratio: 0x%x 0x%x  0x%x\n", ui8ARXFLT[3], ui8ARXFLT[4], ui8ARXFLT[5]);
+
+	ATBMRead(0x00, 0x09,&ui8FatalRst);
+	ATBMRead(0x00, 0x0a,&ui8WeakRst);
+	printf("DSP reset options ui8FatalRst = 0x%x, ui8WeakRst =  0x%x\n", ui8FatalRst, ui8WeakRst);
+
+	ATBMRead(0x03, 0x01,&ui8SamplingEdegeMode);/*0x00: rising edge TS output; 0x01: falling edge TS output*/
+	ATBMRead(0x03, 0x05,&ui8SerialEnabled);    /*0: disable serial mode; 1: enable serial mode */
+	ATBMRead(0x03, 0x0b,&ui8ClockOutSelect);   /*0: SPI clock output; 1: TS serial clock output */
+
+	printf("TS interface ui8SerialEnabled= %d ui8SamplingEdegeMode =%d, clock select ui8ClockOutSelect%d\n",\
+		ui8SerialEnabled,ui8SamplingEdegeMode, ui8ClockOutSelect);
+}
+
+/****************************************************************************
+Function:    ATBMWriteRegArray
+Parameters:  *ui8ARegTable, i32TableLen
+Return:      none
+Description:
+      This function writes a group of registers to demodulator
+ ****************************************************************************/
+void ATBMWriteRegArray(uint8 *ui8ARegTable, int i32TableLen)
+{
+   int i32Iter;
+   for(i32Iter=0;i32Iter<i32TableLen;i32Iter+=3)
+   {
+         ATBMWrite(ui8ARegTable[i32Iter],ui8ARegTable[i32Iter+1],ui8ARegTable[i32Iter+2]);
+   }
+}
+
+/****************************************************************************
+Function:    ATBMDebugRegArray
+Parameters:  *ui8ARegTable, i32TableLen
+Return:      none
+Description:
+     This function reads a group of registers from demodulator and prints them
+     for debug purposes.
+ ****************************************************************************/
+void ATBMDebugRegArray(uint8 *ui8ARegTable, int i32TableLen)
+{
+   int i32Iter;
+   uint8 ui8RegData;
+   for(i32Iter=0;i32Iter<i32TableLen;i32Iter+=3)
+   {
+        ATBMRead(ui8ARegTable[i32Iter],ui8ARegTable[i32Iter+1],&ui8RegData);
+   }
+}
+
+/****************************************************************************
+Function:   ATBMDVBCWrite
+Parameters: ui32AAddress: Register physical address ;ui32Data:data need to write to the register
+ui32Data - 32bit data
+Return:    I2C write status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+	For DVB-C register write, It is an encapsulated function by calling ATBMTransWrite function.
+******************************************************************************/
+ATBM_I2CREADWRITE_STATUS ATBMDVBCWrite(uint32 ui32AAddress, uint32 ui32Data)
+{
+
+	uint8 ui8AWData[4];
+	uint8 ui8AddrL, ui8AddrH;
+
+
+	ui8AddrL = ui32AAddress&0xff;
+	ui8AddrH = (ui32AAddress>>8)&0xff;
+
+	ui8AWData[0]=ui32Data&0xff,ui8AWData[1]=(ui32Data>>8)&0xff,ui8AWData[2]=(ui32Data>>16)&0xff,ui8AWData[3]=(ui32Data>>24)&0xff;
+
+	//Add mutex lock here if there is multi-thread operation of demodulator's I2C
+	//the following I2C operations will not be interrupted.
+	DVBCWriteValue(0x15, 0x03, 0x0);
+	DVBCWriteValue(0x15, 0x01, ui8AddrL);
+	DVBCWriteValue(0x15, 0x02, ui8AddrH);
+
+	DVBCWriteValue(0x15, 0x04, ui8AWData[0]);
+	DVBCWriteValue(0x15, 0x05, ui8AWData[1]);
+	DVBCWriteValue(0x15, 0x06, ui8AWData[2]);
+	DVBCWriteValue(0x15, 0x07, ui8AWData[3]);
+
+	DVBCWriteValue(0x15, 0x03, 0x01);
+
+	DVBCWriteValue(0x15, 0x03, 0x0);
+	//Release mutex lock.
+	printf(" %x %x\n", ui32AAddress, ui32Data);
+	return ATBM_I2CREADWRITE_OK;
+}
+
+
+/****************************************************************************
+Function:      ATBMDVBCRead
+Parameters:    ui32AAddress: Register physical address ;ui32pValue:32-bit data read from target register
+Return:        I2C write status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+	For DVB-C register read, It is an encapsulated function by calling
+	ATBMTransWrite and ATBMTransRead functions.
+******************************************************************************/
+ATBM_I2CREADWRITE_STATUS ATBMDVBCRead(uint32  ui32AAddress,uint32 *ui32pValue)
+{
+
+	uint8 ui8RoLatchOn=1,ui8RoLatchOff=0;
+	uint8 ui8Data[4];
+	uint8 ui8AddrL, ui8AddrH;
+	uint32 ui32Ddata;
+	ui8AddrL = ui32AAddress&0xff;
+	ui8AddrH = (ui32AAddress>>8)&0xff;
+
+	//Add mutex lock here if there is multi-thread operation of demodulator's I2C
+	//the following I2C operations will not be interrupted.
+
+	DVBCWriteValue(0x08, 0x4d, ui8RoLatchOff);
+	DVBCWriteValue(0x15, 0x03, 0x0);
+	DVBCWriteValue(0x15, 0x01, ui8AddrL);
+	DVBCWriteValue(0x15, 0x02, ui8AddrH);
+
+	DVBCWriteValue(0x08, 0x4d, ui8RoLatchOn);
+	DVBCReadValue(0x15, 0x08,&ui8Data[0]);
+	DVBCReadValue(0x15, 0x09,&ui8Data[1]);
+	DVBCReadValue(0x15, 0x0a,&ui8Data[2]);
+	DVBCReadValue(0x15, 0x0b,&ui8Data[3]);
+	DVBCWriteValue(0x08, 0x4d, ui8RoLatchOff);
+
+        //Release mutex lock.
+
+	ui32Ddata = (ui8Data[3]<<24) + (ui8Data[2]<<16) + (ui8Data[1]<<8) +ui8Data[0];
+	*ui32pValue = ui32Ddata;
+	return ATBM_I2CREADWRITE_OK;
+}
+
+/****************************************************************************
+Function:      ATBMCarrierOffset
+Parameters:    none
+Return:        i32CarrierOffset1:(KHz)
+
+Description:
+      This function checks DTMB signal carrier offset on field testing environment.
+      This function is not meant to be used by customers. It's a debug utility to be used by FAEs.
+ ****************************************************************************/
+int ATBMCarrierOffset()
+{
+	uint32 mCarrierOffset;
+	int CarrierOffset;
+	uint8 pbuff[4];
+	uint8 LockValue;
+
+	LockValue =1; /*lock register value*/
+	ATBMWrite(0x08,0x4d, LockValue);
+
+	ATBMRead(0x08, 0x27, &pbuff[0]);//carrier_offset_est[7:0]
+	ATBMRead(0x08, 0x28, &pbuff[1]);//carrier_offset_est[15:8]
+	ATBMRead(0x08, 0x29, &pbuff[2]);//carrier_offset_est[21:16]
+
+	LockValue = 0; /*lock register value*/
+	ATBMWrite(0x08,0x4d, LockValue);
+
+	/*=  carrier offset  =*/
+	if(pbuff[2]&0x80)
+	{
+		mCarrierOffset = (0xffffff+1- (((pbuff[2]&0xff)<<16)+(pbuff[1]<<8)+pbuff[0]))*143/1000;
+		mCarrierOffset = (mCarrierOffset/1000);
+		CarrierOffset = 0 - mCarrierOffset;
+		printf("DTMB signal  Carrier Offset = -%d KHz\n", mCarrierOffset);
+	}
+	else
+	{
+		mCarrierOffset= ((((pbuff[2]&0xff)<<16)+(pbuff[1]<<8)+pbuff[0]))*143/1000;
+		mCarrierOffset = mCarrierOffset/1000;
+		CarrierOffset = mCarrierOffset;
+		printf("DTMB signal Carrier Offset = %d KHz\n", mCarrierOffset);
+	}
+	return CarrierOffset;
+}
+
+
+/****************************************************************************
+Function:      ATBM_DVBC_CarrierOffset
+Parameters:    none
+Return:        DVBC_CarrierOffset(KHz)
+
+Description:
+	This function checks DVB-C signal carrier offset on field testing environment.
+	This function is not meant to be used by customers. It's a debug utility to be used by FAEs.
+****************************************************************************/
+int    ATBMDVBCCarrierOffset()
+{
+	int tmp;
+	int dtmp;
+	uint32 acq_status;
+	int ItbCarFreqOffset_stat,ItbCoarseFrequencyOffset,ChannelCentreFrequency;
+	int DVBC_CarrierOffset;
+	//-------Carrier frequency offset, reg ItbCarFreqOffset_stat---------------
+	ATBMDVBCRead(0x3C0, &tmp); //32bit signed
+	//printf("DVB-C carrier offset 0x3C0 = %d\n", tmp);
+	dtmp = tmp;
+	if(tmp<0)
+		dtmp = -tmp;
+	ItbCarFreqOffset_stat = (dtmp/1000)*(ui32DvbcSymbolRate/10)/53687;//khz
+	if(tmp<0)
+	ItbCarFreqOffset_stat = - ItbCarFreqOffset_stat;
+	//-----ChannelCentreFrequency , reg ItbFrequencyStatus------------------------
+	ATBMDVBCRead(0x11c, &tmp); //27bit signed
+	//printf("DVB-C carrier offset 0x11C= %d\n",tmp);
+
+	tmp = tmp&0x7ffffff;
+	dtmp = tmp;
+	if(tmp&(0x1<<26))
+	{
+		dtmp=-(0x7ffffff-dtmp+1);
+	}
+	if(dtmp<0)
+	{
+		dtmp = -dtmp;
+		ChannelCentreFrequency = (dtmp/100)*(ui32DvbcOscFreq/100)/13422; //khz
+		ChannelCentreFrequency = -ChannelCentreFrequency;
+	}else
+	{
+		ChannelCentreFrequency = (dtmp/100)*(ui32DvbcOscFreq/100)/13422; //khz
+	}
+	//------ItbCoarseFrequencyOffset--------------------------------------------
+	ATBMDVBCRead(0x118, &tmp); //32bit signed
+	dtmp = tmp;
+	if (tmp<0)
+	{
+		dtmp = -tmp;
+	}
+	//printf("DVB-C carrier offset 0x118  = %d\n", tmp);
+	ItbCoarseFrequencyOffset = (dtmp/100)*(ui32DvbcOscFreq/100)/13422; //khz
+	//-----------  calculate overall_CFO -------------
+	if(ChannelCentreFrequency<0)
+	{
+		DVBC_CarrierOffset =  ChannelCentreFrequency  + ItbCoarseFrequencyOffset+ ItbCarFreqOffset_stat;
+	}
+	else
+	{
+		DVBC_CarrierOffset =  ChannelCentreFrequency  - ItbCoarseFrequencyOffset+ ItbCarFreqOffset_stat;
+	}
+	ATBMDVBCRead(0x3d0, &acq_status);
+	if(acq_status&(0x20))
+	{
+		DVBC_CarrierOffset = DVBC_CarrierOffset;
+	}
+	else
+	{
+		DVBC_CarrierOffset = -DVBC_CarrierOffset;
+	}
+	printf("DVB-C signal Carrier Offset = %d KHz\n", DVBC_CarrierOffset);
+	return DVBC_CarrierOffset;
+}
+
+/****************************************************************************
+Function:	ATBM_DVBC_GetSymbolRate
+Parameters:   none
+Return: 	symbol_rate(K symbol/s)
+
+Description:
+    Call this function to Check DVB-C Symbol Rate, valid for DVB-C mode.
+******************************************************************************/
+uint32 ATBMDVBCGetSymbolRate()
+{
+	uint8 mode;
+	uint32 uTrlSampleRate;
+	int uTrlSampleRateError;
+	uint32 uDecLog2DecFactor;
+	int dProgrammedSymbRate;
+	int dOffset;
+	uint32 symbol_rate;
+	ATBMDVBCRead(0x218, &uTrlSampleRateError);
+	ATBMDVBCRead(0x210, &uTrlSampleRate);
+	ATBMDVBCRead(0x124, &uDecLog2DecFactor);
+	ATBMRead(0x00, 0x13,&mode);
+	if((mode != 0x01)||(uTrlSampleRate == 0)) //Not in DVB-C mode or I2C Error
+	{
+		return 0;
+	}
+	dProgrammedSymbRate = (ui32DvbcOscFreq*uTrlSampleRate+ ((1<<(uDecLog2DecFactor+1))*(1<<15)))/((1<<(uDecLog2DecFactor+1))*(1<<16));
+	if(dProgrammedSymbRate == 0)
+	{
+		dProgrammedSymbRate = dProgrammedSymbRate +1;
+	}
+	dOffset = ((uTrlSampleRateError/137439)*ui32DvbcOscFreq)/(dProgrammedSymbRate *(1<<uDecLog2DecFactor));
+	symbol_rate = dProgrammedSymbRate;
+	if(dOffset>=0)
+	{
+		symbol_rate = symbol_rate + (symbol_rate*dOffset + 500000) /1000000;
+	}
+	else
+	{
+		symbol_rate = symbol_rate + (symbol_rate*dOffset - 500000) /1000000;
+	}
+	printf("dProgrammedSymbRate = %d, symbol rate = %d K\n", dProgrammedSymbRate, symbol_rate);
+	return symbol_rate;
+}
+
+int ATBM_PPM_Test()
+{
+	uint8  ui8APhiAdj[2];
+	uint8  ui8ASCPPM[2];
+	uint8  ui8ALCPPM[2];
+	uint8  ui8pABuffTmp[4];
+	uint8  ui8LockValue;
+	uint8  ui8HeaderMode;
+	uint32 ui32Bias = 0;
+	uint32 ui32AcqRateFrac, ui32AcqRateFracCurr;
+	int    i32OffsetPPM;
+
+	ui8LockValue =1; /*lock register value*/
+	ATBMWrite(0x08, 0x4d, ui8LockValue);
+	ATBMRead(0x08, 0x39,&ui8APhiAdj[0]);//ui8APhiAdj[7:0]
+	ATBMRead(0x08, 0x3a,&ui8APhiAdj[1]);//ui8APhiAdj[13:8]
+	ATBMRead(0x08, 0x5B,&ui8ASCPPM[0]);
+	ATBMRead(0x08, 0x5C,&ui8ASCPPM[1]);
+	ATBMRead(0x08, 0x85,&ui8ALCPPM[0]);
+	ATBMRead(0x08, 0x86,&ui8ALCPPM[1]);
+	ATBMRead(0x08, 0x00,&ui8pABuffTmp[0]);//ui32AcqRateFrac[7:0]
+	ATBMRead(0x08, 0x01,&ui8pABuffTmp[1]);//ui32AcqRateFrac[12:8]
+
+	ui8LockValue = 0; /*cancel the lock*/
+	ATBMWrite(0x08,0x4d, ui8LockValue);
+	ui32AcqRateFrac = (ui8pABuffTmp[1]*256)+ui8pABuffTmp[0];
+	ui32AcqRateFracCurr = ui32AcqRateFrac;
+	ATBMRead(0x08,0x2d,&ui8HeaderMode);
+	if(ui8APhiAdj[1]&(0x20)) // sign bit, negative
+	{
+		//ui32Bias= (0xfff+1- (((ui8APhiAdj[1]&0x3f)*256)+ ui8APhiAdj[0]))*1000000/8388608;//power(2,23)
+		ui32Bias= (0x3fff+1- (((ui8APhiAdj[1]&0x3f)*256)+ ui8APhiAdj[0]))*1192/10000;//power(2,23)
+		ui32AcqRateFrac = ui32AcqRateFrac -ui32Bias;
+	}else
+	{
+		ui32Bias = ((((ui8APhiAdj[1]&0x3f)*256)+ ui8APhiAdj[0]))*1192/10000;
+		ui32AcqRateFrac = ui32AcqRateFrac + ui32Bias;
+	}
+	if((ui8HeaderMode&0x3)==2) //single-carrier mode
+	{
+		if(ui8ASCPPM[1]&(0x01))//sign bit, negative
+		{
+			//      ui32Bias =(0x1ff+1-(((ui8ASCPPM[1]&0x01)*256)+ ui8ASCPPM[0]))*1000000/262144;//power(2,18)
+			ui32Bias =(0x1ff+1-(((ui8ASCPPM[1]&0x01)*256)+ ui8ASCPPM[0]))*38/10;//power(2,18)
+			ui32AcqRateFrac = ui32AcqRateFrac - ui32Bias;
+			ui8pABuffTmp[3]= (ui32AcqRateFrac>>8)&0xff;
+			ui8pABuffTmp[2]= ui32AcqRateFrac&0xff;
+		}
+		else{
+			ui32Bias =((( ui8ASCPPM[1]&0x01)*256)+ ui8ASCPPM[0])*38/10;
+			ui32AcqRateFrac = ui32AcqRateFrac + ui32Bias;
+			ui8pABuffTmp[3]= (ui32AcqRateFrac>>8)&0xff;
+			ui8pABuffTmp[2]= ui32AcqRateFrac&0xff;
+		}
+	}
+	//multi-carrier mode: ui8APhiAdj + ui8ALCPPM
+	else if( ((ui8HeaderMode&0x3)==1)||(( ui8HeaderMode&0x3)==3)  )//multi-carrier mode
+	{
+		if(ui8ALCPPM[1]&(0x80))//sign bit
+		{
+			ui32Bias=(0xffff+1- (((ui8ALCPPM[1])*256)+ ui8ALCPPM[0]))*1192/10000;//power(2,23)
+			ui32AcqRateFrac = ui32AcqRateFrac - ui32Bias;
+			ui8pABuffTmp[3]= (ui32AcqRateFrac>>8)&0xff;
+			ui8pABuffTmp[2]= ui32AcqRateFrac&0xff;
+		}
+		else{
+			ui32Bias = ((( ui8ALCPPM[1])*256)+ ui8ALCPPM[0])*1192/10000;
+			ui32AcqRateFrac = ui32AcqRateFrac + ui32Bias;
+			ui8pABuffTmp[3]= (ui32AcqRateFrac>>8)&0xff;
+			ui8pABuffTmp[2]= ui32AcqRateFrac&0xff;
+		}
+
+	}
+	i32OffsetPPM = ui32AcqRateFrac - ui32AcqRateFracCurr;
+	printf("The current sampling frequency offset is about %d ppm\n", i32OffsetPPM);
+	printf("The current values are: [0x0801] = 0x%x [0x0800] = 0x%x\n",ui8pABuffTmp[1],ui8pABuffTmp[0]);
+	printf("The ideal values for minimal offset are: [0x0801] = 0x%x [0x0800]=0x%x\n", ui8pABuffTmp[3], ui8pABuffTmp[2]);
+	return i32OffsetPPM;
+}
+
+void ATBM_GPO_I2CINT_Output(uint8 ui8Level)
+{
+	uint8 ui8GPIOReg;
+	ATBMRead(0x10, 0xf7,&ui8GPIOReg);
+	ui8GPIOReg |= 0x20; //Set bit5, Enable I2CINT output
+	if(ui8Level == 0)
+		ui8GPIOReg &= 0xef; //Clear bit4, I2CINT pin output 0
+	else
+		ui8GPIOReg |= 0x10; //Set bit4, I2CINT pin output 1
+	ATBMWrite(0x10, 0xf7, ui8GPIOReg);
+}
+
+void ATBM_GPO_PWM1_Output(uint8 ui8Level)
+{
+	uint8 ui8GPIOReg;
+	ATBMRead(0x10, 0xf7,&ui8GPIOReg);
+	ui8GPIOReg |= 0x08; //Set bit3,Enable PWM1 output
+	if(ui8Level == 0)
+		ui8GPIOReg &= 0xfb; //clear bit2,PWM1 pin output 0
+	else
+		ui8GPIOReg |= 0x04; //set bit2,PWM1 pin output 1
+	ATBMWrite(0x10, 0xf7, ui8GPIOReg);
+}
+
+void ATBM_GPO_TestIO23_Output(uint8 ui8Level)
+{
+	uint8 ui8GPOReg;
+	uint8 ui8Data;
+	ATBMRead(0x10, 0xf7,&ui8GPOReg);
+	ATBMRead(0x10, 0xfb,&ui8Data);
+	ui8GPOReg |= 0x80; //Set bit7,Enable TestIO23 output
+	ui8Data|= 0x04; //set bit2
+	if(ui8Level == 0)
+	{
+		ui8Data&=0xef; //clear bit4, this bit is output level
+	}
+	else
+	{
+		ui8Data|= 0x10; //set bit4 as High level
+	}
+	ATBMWrite(0x10, 0xfb, ui8Data);
+	ATBMWrite(0x10, 0xf7, ui8GPOReg);
+}
+
+/****************************************************************************
+Function:    ATBM_TestIO23_Indicate_TS_Lock
+Parameters: none
+Return:      none
+Description:
+    Enable lock indicator output on testIO23 when TS lock detected.
+****************************************************************************/
+void ATBM_TestIO23_Indicate_TS_Lock()
+{
+     uint8 ui8GPOReg;
+     uint8 ui8Data;
+     ATBMRead(0x10, 0xf7,&ui8GPOReg);
+     ATBMRead(0x10, 0xfb,&ui8Data);
+     ui8GPOReg|= 0x80; //set bit7
+     ui8Data&=0xfb;  //clear bit2
+     ATBMWrite(0x10, 0xfb, ui8Data);
+     ATBMWrite(0x10, 0xf7, ui8GPOReg);
+     ATBMWrite(0x00, 0x1a, 0x00); //TestIO23 using TS lock.
+}
+
+/****************************************************************************
+Function:    ATBM_TestIO23_Indicate_FEC_No_Error
+Parameters:  none
+Return:      none
+Description:
+    TestIO23 auto output high only when FEC no Error occurred.
+    Strict on lock indicator, if FEC error occurred, lock indicator will be off.
+    Lock indicator will be on only if not FEC error occurred
+****************************************************************************/
+void ATBM_TestIO23_Indicate_FEC_No_Error()
+{
+     uint8 ui8LockUseErrorInv;
+     ui8LockUseErrorInv = 0x01;
+     ATBM_TestIO23_Indicate_TS_Lock();          //enable TestIO23 normal output
+     ATBMWrite(0x00, 0x1a, ui8LockUseErrorInv); //TestIO23 using FEC no error
+}
+
+void ATBM_GPO_TestIO20_Output(uint8 ui8Level)
+{
+	uint8 ui8GPOReg;
+	uint8 ui8Data;
+	ATBMRead(0x10, 0xf7,&ui8GPOReg);
+	ATBMRead(0x10, 0xfb,&ui8Data);
+	ui8GPOReg |= 0x40; //Set bit6,Enable TestIO20 output
+	ui8Data|=0x02; //set bit1 enable
+	if(ui8Level == 0)
+	{
+		ui8Data&=0xf7; //clear bit3
+	}
+	else
+	{
+		ui8Data|=0x08; //set bit3 output 1
+	}
+	ATBMWrite(0x10, 0xfb, ui8Data);
+	ATBMWrite(0x10, 0xf7, ui8GPOReg);
+}
+
+/****************************************************************************
+Function:    ATBM_TestIO20_Indicate_FEC_Error
+Parameters: none
+Return:      none
+Description:
+     Enable error indicator output on testIO20 when FEC error detected.
+****************************************************************************/
+void ATBM_TestIO20_Indicate_FEC_Error()
+{
+     uint8 ui8GPOReg;
+     uint8 ui8Data;
+     ATBMRead(0x10, 0xf7,&ui8GPOReg);
+     ATBMRead(0x10, 0xfb,&ui8Data);
+     ui8GPOReg|= 0x40; //set bit6
+     ui8Data&=0xfd;  //clear bit1
+     ATBMWrite(0x10, 0xfb, ui8Data);
+     ATBMWrite(0x10, 0xf7, ui8GPOReg);
+     ATBMWrite(0x00, 0x1b, 0x00 );    //TestIO20 using FEC error
+}
+
+/****************************************************************************
+Function:    ATBM_TestIO20_Indicate_TS_Unlock
+Parameters:  none
+Return:      none
+Description:
+    Strict on Error indicator, if lock occurred (TS sync is true),
+    error indicator will be off.
+    error indicator will be on when TS sync is not checked.
+****************************************************************************/
+void ATBM_TestIO20_Indicate_TS_Unlock()
+{
+     uint8 ui8ErrorUseLockInv;
+     ui8ErrorUseLockInv = 0x01;
+     ATBM_TestIO20_Indicate_FEC_Error(); //enable TestIO20 normal output error
+     ATBMWrite(0x00, 0x1b, ui8ErrorUseLockInv); //using TS unlock
+}
+
+/****************************************************************************
+Function:    ATBMErrorDurationMillisecond
+Parameters:  ms (0--275 milliseconds)
+Return:      none
+Description:
+  Set error indicator duration time.
+  The default time is 8.6MS (0x800*4.2us), register value is 0x800.
+  The maximum value is 275 milliseconds
+****************************************************************************/
+void ATBMErrorOnDurationMillisecond(int i32MS)
+{
+     int   i32SetValue;
+     uint8 ui8RegHigh, ui8RegLow;
+     i32SetValue = (int)(i32MS*10000/42);
+     ui8RegLow = (uint8)(i32SetValue&0xff);
+     ui8RegHigh = (uint8)(i32SetValue/256);
+     ATBMWrite(0x15, 0x2b, ui8RegLow);
+     ATBMWrite(0x15, 0x2c, ui8RegHigh);
+}
+/****************************************************************************
+Function:    ATBMLockOffDurationMillisecond
+Parameters:  ms (0--1100 milliseconds)
+Return:      none
+Description:
+  Set lock indicator off Duration time after unlocked.
+  The default time is 34.4ms:(0x800*16.8us), register value is 0x800.
+  The maximum value is 1100 milliseconds
+****************************************************************************/
+void ATBMLockOffDurationMillisecond(int i32MS)
+{
+     int i32SetValue;
+     uint8 ui8RegHigh, ui8RegLow;
+     i32SetValue = (int)(i32MS*10000/168);
+     ui8RegLow = (uint8)(i32SetValue&0xff);
+     ui8RegHigh = (uint8)(i32SetValue/256);
+     ATBMWrite(0x03, 0x19, ui8RegLow);
+     ATBMWrite(0x03, 0x1a, ui8RegHigh);
+}
+
+/****************************************************************************
+Function:    ATBM_GetGuradInterval
+Parameters:  none
+Return:      gi_interval
+
+Description:
+   Function to get guard interval from TPS value: 420 595, 945
+****************************************************************************/
+DTMB_GUARD_INTERVAL  ATBM_GetGuradInterval()
+{
+	uint8 pn_value,PN;
+	DTMB_GUARD_INTERVAL gi_interval;
+	ATBMRead(0x08, 0x2d,&pn_value);
+	PN = (uint8)(pn_value&0x03);
+	// check Guard interval
+	if(PN == 2)
+	{
+		gi_interval = GI_595;
+	}
+	else if(PN == 1)
+	{
+
+		gi_interval = GI_420;
+	}
+	else if(PN == 3)
+	{
+
+		gi_interval= GI_945;
+	}
+	else
+	{
+		gi_interval = GI_UNKNOWN;
+	}
+	return gi_interval;
+}
+
+/****************************************************************************
+Function:    ATBM_GetQamIndex
+Parameters:  none
+Return:      code_rate
+
+Description:
+   Function to get QAM from TPS value
+   4QAM-NR, 4QAM, 16QAM, 32QAM, 64QAM
+****************************************************************************/
+DTMB_QAM_INDEX  ATBM_GetQamIndex()
+{
+	uint8 tps_code;
+	DTMB_QAM_INDEX qam_index;
+	ATBMRead(0x0d, 0x04,&tps_code);
+	if((tps_code>24)||(tps_code<3))
+	{
+		qam_index =DTMB_QAM_UNKNOWN;
+		return qam_index;
+	}
+	if(tps_code<=4)
+	{
+		qam_index = DTMB_QAM_4QAM_NR;
+	}
+	else if(tps_code<=10)
+	{
+		qam_index = DTMB_QAM_4QAM;;
+	}
+	else if(tps_code<=16)
+	{
+		qam_index = DTMB_QAM_16QAM;
+	}
+	else if(tps_code<=18)
+	{
+		qam_index = DTMB_QAM_32QAM;
+	}
+	else if(tps_code<=24)
+	{
+		qam_index = DTMB_QAM_64QAM;
+	}
+	else
+	{
+		qam_index = DTMB_QAM_UNKNOWN;
+	}
+	return qam_index;
+}
+
+/****************************************************************************
+Function:    ATBM_GetCodeRate
+Parameters:  none
+Return:      code_rate
+
+Description:
+   Function to get FEC code rate from TPS value: 0.4, 0.6, 0.8
+****************************************************************************/
+DTMB_CODE_RATE  ATBM_GetCodeRate()
+{
+	uint8 tps_code;
+	DTMB_CODE_RATE code_rate;
+	ATBMRead(0x0d, 0x04,&tps_code);
+	if((tps_code>24)||(tps_code<3))
+	{
+		code_rate = DTMB_CODE_RATE_UNKNOWN;
+		return code_rate;
+	}
+	if((tps_code == 5)||(tps_code == 6))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_4;
+	}
+	else if ((tps_code == 11)||(tps_code == 12))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_4;
+	}
+	else if((tps_code == 19)||(tps_code == 20))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_4;
+	}
+	else if((tps_code == 7)||(tps_code == 8))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_6;
+	}
+	else if((tps_code == 13)||(tps_code == 14))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_6;
+	}
+	else if((tps_code == 21)||(tps_code == 22))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_6;
+	}
+	else
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_8;
+	}
+	return code_rate;
+}
+
+/****************************************************************************
+Function:    ATBM_GetInterleavingMode
+Parameters:  none
+Return:      time_interleave
+
+Description:
+Function to get Time interleaving mode from TPS value: 240 or 720
+****************************************************************************/
+DTMB_TIME_INTERLEAVE  ATBM_GetInterleavingMode()
+{
+	uint8 tps_code;
+	DTMB_TIME_INTERLEAVE time_interleave = DTMB_TIME_INTERLEAVER_UNKNOWN;
+	ATBMRead(0x0d, 0x04,&tps_code);
+
+	if((tps_code>24)||(tps_code<3))
+	{
+		time_interleave = DTMB_TIME_INTERLEAVER_UNKNOWN;
+		return time_interleave;
+	}
+	if((tps_code%2) == 0)
+	{
+		time_interleave = DTMB_TIME_INTERLEAVER_720;
+	}
+	if((tps_code%2) != 0)
+	{
+		time_interleave = DTMB_TIME_INTERLEAVER_240;
+	}
+	return  time_interleave;
+}
+
+/****************************************************************************
+Function:    ATBM_GetCarrierMode
+Parameters:  none
+Return:      carrier_mode
+
+Description:
+Function to get carrier mode: single carrier or Multi-carrier
+****************************************************************************/
+DTMB_CARRIER_MODE   ATBM_GetCarrierMode()
+{
+	uint8 is_sc;
+	DTMB_CARRIER_MODE carrier_mode;
+	ATBMRead(0x0d, 0x0f,&is_sc);
+	//check carrier mode
+	if(is_sc == 1)
+	{
+		carrier_mode = DTMB_SINGLE_CARRIER;
+	}
+	else if(is_sc == 0)
+	{
+
+		carrier_mode = DTMB_MULTI_CARRIER;
+	}
+	else
+	{
+		carrier_mode = DTMB_CARRIER_UNKNOWN;
+	}
+	return carrier_mode;
+}
+
+/****************************************************************************
+Function:    ATBMGetSignalParameters
+Parameters:  singal_params
+Return:       none
+
+Description:
+API to get all DTMB signal parameters:
+Carrier mode, Constellation QAM index,  FEC code rate, Guard interval
+and time interleaving mode.
+****************************************************************************/
+void ATBMGetSignalParameters(DTMB_SIGNAL_PARAMS *singal_params)
+{
+	singal_params->dtmb_carrier_mode = ATBM_GetCarrierMode();
+
+	singal_params->dtmb_qam_index =  ATBM_GetQamIndex();
+
+	singal_params->dtmb_code_rate = ATBM_GetCodeRate();
+
+	singal_params->dtmb_guard_interval =   ATBM_GetGuradInterval();
+
+	singal_params->dtmb_time_interleave = ATBM_GetInterleavingMode();
+}
+
+/****************************************************************************
+Function:    ATBMGetDTMBBitRate
+Parameters:  none
+Return:       payload
+
+Description:
+API to get DTMB MPEG2 TS payload in unit of Kbps
+****************************************************************************/
+int  ATBMGetDTMBBitRate()
+{
+	DTMB_CODE_RATE code_rate;
+	DTMB_QAM_INDEX qam_index;
+	DTMB_GUARD_INTERVAL gi_interval;
+
+	int payload = 0;
+
+	qam_index =  ATBM_GetQamIndex();
+	code_rate = ATBM_GetCodeRate();
+	gi_interval =   ATBM_GetGuradInterval();
+
+	if(qam_index == DTMB_QAM_4QAM)
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_4)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 5414;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 5198;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 4813;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_6)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 8122;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 7797;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 7219;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 10829;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 10396;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 9626;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else
+		{
+			payload = 0;
+		}
+	}
+	else if (qam_index == DTMB_QAM_16QAM)
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_4)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 10829;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 10396;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 9626;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_6)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 16243;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 15593;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 14438;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 21658;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 20791;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 19251;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else
+		{
+			payload = 0;
+		}
+	}
+	else if (qam_index == DTMB_QAM_64QAM)
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_4)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 16243;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 15593;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 14438;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_6)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 24365;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 23390;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 21658;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 32486;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 31187;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 28877;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else
+		{
+			payload = 0;
+		}
+	}
+	else if((qam_index == DTMB_QAM_32QAM))
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 27072;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 25989;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 24064;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}else
+		{
+			payload = 0;
+		}
+	}
+	else if((qam_index == DTMB_QAM_4QAM_NR))
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 5414;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 5198;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 4813;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}else
+		{
+			payload = 0;
+		}
+	}
+	else
+	{
+		payload = 0;
+	}
+	return payload;
+}
+
+/*Internal function used by ATBMSetClock64M*/
+void ATBMSetTS_SPIClock64M()
+{
+	unsigned char tmp_data;
+	ATBMRead(0x06, 0x0e, &tmp_data);
+	tmp_data&=0x8f; //clear bit[14:12]
+	tmp_data|=0x60; //set bit[14:12]:110
+	ATBMWrite(0x06, 0x0e, tmp_data);
+}
+
+/*Internal function used by ATBMSetClock64M*/
+void ATBMSetSYS_Clock64M()
+{
+	unsigned char adc_rfv0, adc_rfv1;
+	ATBMRead(0x06, 0x0d, &adc_rfv0);
+	adc_rfv0&=0x7f; //clear bit7
+	ATBMRead(0x06, 0x0e, &adc_rfv1);
+	adc_rfv1&=0xf7; //clear bit[11]
+
+	adc_rfv0|=0x80; //set bit[7]:1
+	ATBMWrite(0x06, 0x0d, adc_rfv0);
+	adc_rfv1|=0x08; //set bit[11]:1
+	ATBMWrite(0x06, 0x0e, adc_rfv1);
+}
+
+/*Internal function used by ATBMSetClock72M*/
+void ATBMSetTS_SPIClock72M()
+{
+	unsigned char tmp_data;
+	ATBMRead(0x06, 0x0e, &tmp_data);
+	tmp_data&=0x8f; //clear bit[14:12], default is 72M for 24MHz Crystal
+	tmp_data|=0x00;//set bit[14:12]:000
+	ATBMWrite(0x06, 0x0e, tmp_data);
+}
+
+/*Internal function used by ATBMSetClock72M*/
+void ATBMSetSYS_Clock72M()
+{
+	unsigned char adc_rfv0,adc_rfv1;
+	ATBMRead(0x06, 0x0e, &adc_rfv1);
+	adc_rfv1&=0xf7; //clear bit[11]
+	ATBMRead(0x06, 0x0d, &adc_rfv0);
+	adc_rfv0&=0x7f; //clear bit7
+
+	adc_rfv0|=0x00;//set bit[7]:0
+	ATBMWrite(0x06, 0x0d, adc_rfv0);
+	adc_rfv1|=0x00;//set bit[11]:0
+	ATBMWrite(0x06, 0x0e, adc_rfv1);
+}
+
+/****************************************************************************
+Function:    ATBMSetClock64M
+Parameters:  none
+Return:      none
+
+Description:
+      Call this function to change TS SPI clock,and sys clock to 64MHz,
+      the default used clock is 72MHz with 24MHz crystal  or oscillator.
+
+	  Valid only for 24MHz crystal or oscillator.
+******************************************************************************/
+void ATBMSetClock64M()
+{
+	unsigned char ui8Rst;
+	ATBMWrite(0x01, 0x0c, 0);
+	Delayms(2);
+	ATBMSetTS_SPIClock64M();
+	ATBMSetSYS_Clock64M();
+	if((ui32DvbcSymbolRate > 7500)||(ui32DvbcSymbolRate < 1000))
+	{
+		ui32DvbcSymbolRate = 6875;
+	}
+	ui8Rst =(uint8)(6875*16/ui32DvbcSymbolRate);
+	ATBMWrite(0x15, 0x37, ui8Rst);
+	Delayms(2);
+	ATBMWrite(0x01, 0x0c, 1);
+}
+
+/****************************************************************************
+Function:    ATBMSetClock72M
+Parameters:  none
+Return:      none
+
+Description:
+      Call this function to change TS SPI clock,and sys clock to 72MHz,
+      the default used clock is 72MHz with 24MHz crystal or oscillator.
+
+	  Valid only for 24MHz crystal or oscillator.
+******************************************************************************/
+void ATBMSetClock72M()
+{
+	unsigned char ui8Rst;
+	ATBMWrite(0x01, 0x0c, 0);
+	Delayms(2);
+	ATBMSetTS_SPIClock72M();
+	ATBMSetSYS_Clock72M();
+	if((ui32DvbcSymbolRate > 7500)||(ui32DvbcSymbolRate < 1000))
+	{
+		ui32DvbcSymbolRate = 6875;
+	}
+	ui8Rst =(uint8)(6875*18/ui32DvbcSymbolRate);
+	ATBMWrite(0x15, 0x37, ui8Rst);
+	Delayms(2);
+	ATBMWrite(0x01, 0x0c, 1);
+}
+
+/****************************************************************************
+Function:    ATBMRead
+Parameters:  ui8BaseAddr, ui8RegisterAddr, *ui8pValue
+Return:      I2C read status:ATBM_I2CREADWRITE_OK is OK
+Description:
+     ATBM886x demodulator register Reading API, it calls I2CRead.
+****************************************************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMRead(uint8 ui8BaseAddr, uint8 ui8RegisterAddr,uint8 *ui8pValue)
+{
+	uint8 ui8AddrData[2];
+
+	ATBM_I2CREADWRITE_STATUS enumRetval = ATBM_I2CREADWRITE_OK;
+	ui8AddrData[0] = ui8BaseAddr;
+	ui8AddrData[1] = ui8RegisterAddr;
+	//Option 1:One step I2C format, please port this function according to I2C format of this function..
+//	enumRetval = I2CReadOneStep(ui8ATBMSlaveAddr, 2, ui8AddrData, 1, ui8pValue);
+
+	//Option 2: two step format, returned status from low level I2C interface
+                    //shoud be processsed here if needed.
+	enumRetval = I2CWrite(ui8ATBMSlaveAddr, ui8AddrData, 2);
+	enumRetval = I2CRead(ui8ATBMSlaveAddr, ui8pValue, 1);
+
+	//Release mutex lock
+   return enumRetval;
+}
+
+/****************************************************************************
+Function:    ATBMWrite
+Parameters:  ui8BaseAddr, ui8RegisterAddr, ui8Data
+Return:      I2C write status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+     ATBM886x demodulator register Writing API, It calls I2C low level interface.
+    ****************************************************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMWrite(uint8 ui8BaseAddr, uint8 ui8RegisterAddr, uint8 ui8Data)
+{
+
+	ATBM_I2CREADWRITE_STATUS enumRetval =  ATBM_I2CREADWRITE_OK ;
+	uint8 i2c_data[2];
+    uint8 reg_data[1];
+
+
+	i2c_data[0] = ui8BaseAddr;
+	i2c_data[1] = ui8RegisterAddr;
+	reg_data[0] = ui8Data;
+
+        //Option l: One step I2C format
+//        enumRetval = I2CWriteWithRestart(ui8ATBMSlaveAddr, 2, i2c_data, 1, reg_data);
+
+	//Option 2: two step format, returned status from low level I2C interface
+                    //should be processed here if needed.
+		//Add mutex lock here if there is multi-thread operation of demodulator's I2C
+	//the following I2C operations will not be interrupted.
+	enumRetval = I2CWrite(ui8ATBMSlaveAddr, i2c_data, 2);
+	enumRetval = I2CWrite(ui8ATBMSlaveAddr, reg_data, 1);
+
+	//Release mutex lock
+#if ATMB_DBG_OUTPUT
+	printf("%x %x %x\n", ui8BaseAddr, ui8RegisterAddr, ui8Data);
+#endif
+	return enumRetval;
+}
+
+/****************************************************************************
+Function:    ATBMTransRead
+Parameters:  ui8BaseAddr, ui8RegisterAddr,ui8pValue
+Return:      I2C read status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+     ATBM886x demodulator register Reading API, This function is used for DVB-C transfer.
+****************************************************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMTransRead(uint8 ui8BaseAddr, uint8 ui8RegisterAddr,uint8 *ui8pValue)
+{
+	ATBM_I2CREADWRITE_STATUS enumRetval =  ATBM_I2CREADWRITE_OK ;
+	uint8 ui8AddrData[2];
+	ui8AddrData[0] = ui8BaseAddr;
+	ui8AddrData[1] = ui8RegisterAddr;
+
+		//Option 1:One step I2C format, please port this function according to I2C format of this function..
+	enumRetval = I2CReadOneStep(ui8ATBMSlaveAddr, 2, ui8AddrData, 1, ui8pValue);
+
+	//Option 2: two step format, returned status from low level I2C interface
+                    //should be processed here if needed.
+	enumRetval = I2CWrite(ui8ATBMSlaveAddr, ui8AddrData, 2);
+	enumRetval = I2CRead(ui8ATBMSlaveAddr, ui8pValue, 1);
+
+	//Release mutex lock
+   return enumRetval;
+
+}
+
+
+/****************************************************************************
+Function:        ATBMTransWrite
+Parameters:  ui8BaseAddr, ui8RegisterAddr, ui8Data
+Return:      I2C write status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+     ATBM886x demodulator register Writing API, It calls low level I2C interface
+****************************************************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMTransWrite(uint8 ui8BaseAddr, uint8 ui8RegisterAddr, uint8 ui8Data)
+{
+	ATBM_I2CREADWRITE_STATUS enumRetval =  ATBM_I2CREADWRITE_OK ;
+	uint8 i2c_data[2];
+    uint8 reg_data[1];
+
+
+	i2c_data[0] = ui8BaseAddr;
+	i2c_data[1] = ui8RegisterAddr;
+	reg_data[0] = ui8Data;
+
+        //Option l: One step I2C format
+        enumRetval = I2CWriteWithRestart(ui8ATBMSlaveAddr, 2, i2c_data, 1, reg_data);
+
+	//Option 2: two step format, returned status from low level I2C interface
+                    //should be processed here if needed.
+		//Add mutex lock here if there is multi-thread operation of demodulator's I2C
+	//the following I2C operations will not be interrupted.
+	//enumRetval = I2CWrite(ui8ATBMSlaveAddr, i2c_data, 2);
+	//enumRetval = I2CWrite(ui8ATBMSlaveAddr, reg_data, 1);
+
+	//Release mutex lock
+#if ATMB_DBG_OUTPUT
+	printf("%x %x %x\n", ui8BaseAddr, ui8RegisterAddr, ui8Data);
+#endif
+	return enumRetval;
+}
+
+
diff --git a/drivers/amlogic/dvb_tv/atbm887x/atbm886x.h b/drivers/amlogic/dvb_tv/atbm887x/atbm886x.h
new file mode 100755
index 000000000000..514be9316604
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/atbm887x/atbm886x.h
@@ -0,0 +1,306 @@
+/*****************************************************************************
+Copyright 2012-2020, AltoBeam Inc. All rights reserved.
+
+File Name: atbm886x.h
+******************************************************************************/
+#ifndef ATBM886X_H
+#define ATBM886X_H
+
+#define printf printk
+
+/*Common data type redefine for atbm886x.h/c*/
+typedef unsigned char u_int8;
+typedef unsigned short u_int16;
+typedef unsigned int u_int32;
+
+
+typedef unsigned char uint8;
+typedef unsigned short uint16;
+typedef unsigned int   uint32;
+
+
+
+#define ATMB_DBG_OUTPUT   0
+
+
+
+/**********************************************************************************************************************************
+*struct MPEG_TS_mode_t
+*@ui8TSTransferType: TS stream transfer type, can be set to parallel(8 bit data bus) or serial(1 bit data bus) mode
+*@Demod output edge: demod will output TS data on this edge of TS stream clock
+*@ui8SPIClockConstantOutput: TS stream clock can be set outputting all the time or only during TS data valid (188 bytes)
+**********************************************************************************************************************************/
+/*****************ui8TSTransferType Option Value***************************/
+#define TS_PARALLEL_MODE             1
+#define TS_SERIAL_MODE               0
+/**********************ui8OutputEdge Option Value***************************/
+#define TS_OUTPUT_FALLING_EDGE       1
+#define TS_OUTPUT_RISING_EDGE        0
+/**********************ui8TSSPIMSBSelection Option Value******************/
+#define TS_SPI_MSB_ON_DATA_BIT7      1
+#define TS_SPI_MSB_ON_DATA_BIT0      0
+/**********************ui8TSSSIOutputSelection Option Value***************/
+#define TS_SSI_OUTPUT_ON_DATA_BIT7   1
+#define TS_SSI_OUTPUT_ON_DATA_BIT0   0
+/**********************ui8SPIClockConstantOutput Option Value*************/
+#define TS_CLOCK_CONST_OUTPUT        1
+#define TS_CLOCK_VALID_OUTPUT        0
+typedef struct MPEG_TS_mode_t
+{
+	uint8 ui8TSTransferType;
+	uint8 ui8OutputEdge;
+	uint8 ui8TSSPIMSBSelection;
+	uint8 ui8TSSSIOutputSelection;
+	uint8 ui8SPIClockConstantOutput;
+}MPEG_TS_mode_t;
+
+/**********************************************************************************************************************************
+*struct DVBC_Params_t
+*i32SymbolRate: typically use 6875K
+*ui8InputMode : for DVBC parameter config
+**********************************************************************************************************************************/
+/**********************ui8InputMode Option Value****************************/
+#define DVBC_IF_INPUT                0
+#define DVBC_IQ_INPUT                1
+typedef struct DVBC_Params_t
+{
+	uint8 ui8InputMode;
+	int	  i32SymbolRate;
+}DVBC_Params_t;
+
+/**********************************************************************************************************************************
+*struct tuner_config_t
+*@dbIFFrequency: tuner IF frequency output in MHz.  Most CAN Tuners' are 36M, 36.166M
+*@or 36.125 MHz (Typical IF used by DVB-C tuners)
+*@ui8IQmode: demod needs to know if IQ is swapped or not on hardware board
+**********************************************************************************************************************************/
+/**********************ui8IQmode Option Value*******************************/
+#define SWAP_IQ                      0
+#define NO_SWAP_IQ                   1
+typedef struct tuner_config_t
+{
+	uint8  ui8IQmode;
+	uint8  ui8DTMBBandwithMHz;/**/
+	uint32 ui32IFFrequency;
+}tuner_config_t;
+
+/**********************************************************************************************************************************
+* struct     custom_config_t
+*@tuner_config: struct of tuner configuration
+*@stTsMode: struct of TS mode
+*@ui8CrystalOrOscillator: demod can use crystal or oscillator
+*@dbSampleClkFrequency: crystal or oscillator frequency on hardware board for demod
+*@ui8DtmbDvbcMode:select receiving mode DTMB or DVB-C for ATBM886x
+*@stDvbcParams: DVB-C parameters
+**********************************************************************************************************************************/
+/**********************ui8CrystalOrOscillator Option Value*****************/
+#define CRYSTAL                      0
+#define OSCILLATOR                   1
+/**********************ui8DtmbDvbcMode Option Value************************/
+#define ATBM_DTMB_MODE               1
+#define ATBM_DVBC_MODE               0
+typedef struct custom_config_t
+{
+	uint8          ui8CrystalOrOscillator;
+	uint8          ui8DtmbDvbcMode;
+	tuner_config_t stTunerConfig;
+	MPEG_TS_mode_t stTsMode;
+	uint32         ui32SampleClkFrequency;
+	DVBC_Params_t  stDvbcParams;
+}custom_config_t;
+
+typedef enum _ATBM_I2CREADWRITE_STATUS
+{
+	ATBM_I2CREADWRITE_OK    =0,
+	ATBM_I2CREADWRITE_ERROR
+}ATBM_I2CREADWRITE_STATUS;
+
+
+
+typedef enum _DTMB_QAM_INDEX
+{
+	DTMB_QAM_UNKNOWN = 0,
+	DTMB_QAM_4QAM_NR,
+	DTMB_QAM_4QAM,
+	DTMB_QAM_16QAM,
+	DTMB_QAM_32QAM,
+	DTMB_QAM_64QAM
+}DTMB_QAM_INDEX;
+
+// Code rate
+typedef enum _DTMB_CODE_RATE
+{
+	DTMB_CODE_RATE_UNKNOWN = 0,
+	DTMB_CODE_RATE_0_DOT_4,
+	DTMB_CODE_RATE_0_DOT_6,
+	DTMB_CODE_RATE_0_DOT_8
+}DTMB_CODE_RATE;
+
+// Time interleaving
+typedef enum _DTMB_TIME_INTERLEAVE
+{
+	DTMB_TIME_INTERLEAVER_UNKNOWN = 0,
+	DTMB_TIME_INTERLEAVER_240,
+	DTMB_TIME_INTERLEAVER_720
+}DTMB_TIME_INTERLEAVE;
+
+//Single carrier or Multi-Carrier
+typedef enum _DTMB_CARRIER_MODE
+{
+	DTMB_CARRIER_UNKNOWN = 0,
+	DTMB_SINGLE_CARRIER,
+	DTMB_MULTI_CARRIER
+}DTMB_CARRIER_MODE;
+
+typedef enum _DTMB_GUARD_INTERVAL
+{
+	GI_UNKNOWN = 0,
+	GI_420,
+	GI_595,
+	GI_945
+}DTMB_GUARD_INTERVAL;
+
+typedef struct STRU_DTMB_SIGNAL_PARAMS
+{
+	DTMB_CARRIER_MODE dtmb_carrier_mode;
+	DTMB_QAM_INDEX dtmb_qam_index;
+	DTMB_CODE_RATE dtmb_code_rate;
+	DTMB_TIME_INTERLEAVE dtmb_time_interleave;
+	DTMB_GUARD_INTERVAL dtmb_guard_interval;
+}DTMB_SIGNAL_PARAMS;
+
+
+/********DTMB and DVB-C common API functions******************************/
+int    ATBMPowerOnInit();
+uint8  ATBMChipID();
+void   ATBMI2CByPassOn();
+void   ATBMI2CByPassOff();
+int    ATBMLockedFlag();
+int    ATBMChannelLockCheck();
+int    ATBMChannelLockCheckForManual();
+void   ATBMHoldDSP();
+void   ATBMStartDSP();
+void   ATBMStandby();
+void   ATBMStandbyWakeUp();
+void   ATBMSuspend();
+
+/****DTMB API Functions***************************************************/
+void   ATBMSetDTMBMode();
+int    ATBMSignalStrength();
+uint32 ATBMSignalNoiseRatio();
+int    ATBMSignalQuality();
+uint32 ATBMFrameErrorRatio();
+uint32 ATBMPreBCHBlockErrorRatio();
+uint32 ATBMBER_Calc();
+int    ATBM_PPM_Test();
+int ATBMCarrierOffset();
+int  ATBMGetDTMBBitRate();
+
+/****DVBC API Macro define************************************************/
+#define ATBM_DEBUG_DVBC                           0      /*default no debug output*/
+// #define CMS0022_COARSE_CARRIER_ACQ_SWEEP_STEP    5/100
+#define DVBC_SAMPLE_RATE_ADDR                     0x210
+#define DVBC_SAMPLE_RATE_RECIP_ADDR               0x214
+#define DVBC_OUTPUT_SHIFT_ADDR                    0x128
+#define DVBC_DECIMATION_FACTOR_ADDR               0x124
+#define DVBC_SLOW_CONTROL_TC_ADDR                 0x3BC
+#define DVBC_CARRIER_LOCK_ACQUIRE_TIMEOUT_ADDR    0x348
+#define DVBC_PL_CARRIER_FREQUENCY_RANGE_ADDR      0x38C
+#define DVBC_PL_CARRIER_STEP_FREQUENCY_ADDR       0x388
+#define DVBC_COARSE_FREQUENCY_OFFSET_ADDR         0x118
+#define DVBC_SEARCH_STEP_ADDR                     0x3B0
+#define DVBC_SEARCH_RANGE_ADDR                    0x3B4
+#define DVBC_BITSYNC_DETECT_TIMEOUT_ADDR          0x364
+#define DVBC_AUTO_EQU_SEARCH_ADDR                 0x3CC
+/****DVB-C API Functions*************************************************/
+void   ATBMSetDVBCMode();// this function may be changed later
+int ATBMDVBCSNR();
+uint32 ATBMDVBCBER(int *i32pBerExponent);
+uint32 ATBMDVBCUncorrectablePER(int *i32pPktsExponent);
+uint8  ATBMDVBCGetQAM();
+int    ATBMDVBCSignalStrength();
+uint32 ATBMDVBCGetSymbolRate();
+int ATBMDVBCCarrierOffset();
+
+/*************DVB-C internal functions************************/
+void   ATBMDVBCInit( custom_config_t stCustomConfig);
+void   ATBMDVBCSetSymbolRate(uint32 ui32OSCFreq, uint32 ui32SymbolRateM);
+void   ATBMDVBCSetCarrier(uint32 ui32OSCFreq,uint32 ui32SymbolRateM);
+void   ATBMDVBCSetQAM();
+
+/******************Demodulator Internal functions***********************/
+void   ATBMSetConfigParas(custom_config_t stCustomConfigp);
+void   ATBMInit();
+void   ATBMConfig( custom_config_t stCustomConfig);
+void   ATBMSetTSMode( MPEG_TS_mode_t stTSMode);   /*Default SPI , it can be configured to Serial mode*/
+int    ATBMSetOSC( tuner_config_t stTunerConfig, uint32 ui32SampleClkFrequency);
+uint8  ATBMGetTPS();
+void   ATBMDebugRegister();
+uint8  ATBMCheckDemodStatus();
+int    ATBMReset(uint8 ui8CryOrOsc);
+uint8  ATBMCheckPLLStatus(void);
+/****DTMB I2C interface functions****************************************/
+void   ATBMWriteRegArray(uint8 *ui8ARegTable, int i32TableLen);
+void   ATBMDebugRegArray(uint8 *ui8ARegTable, int i32TableLen);
+ATBM_I2CREADWRITE_STATUS  ATBMRead(uint8 ui8BaseAddr, uint8 ui8RegisterAddr,uint8 *ui8pValue);
+ATBM_I2CREADWRITE_STATUS  ATBMWrite(uint8 ui8BaseAddr, uint8 ui8RegisterAddr, uint8 ui8Data);
+/****DVB-C I2C interface functions***************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMTransRead(uint8 ui8BaseAddr, uint8 ui8RegisterAddr,uint8 *ui8pValue);
+ATBM_I2CREADWRITE_STATUS  ATBMTransWrite(uint8 ui8BaseAddr, uint8 ui8RegisterAddr, uint8 ui8Data);
+ATBM_I2CREADWRITE_STATUS  ATBMDVBCWrite(uint32 ui32AAddress,uint32 ui32Data);
+ATBM_I2CREADWRITE_STATUS  ATBMDVBCRead(uint32 ui32AAddress,uint32 *ui32pValue);
+
+/****General interface functions*****************************************/
+uint32 ATBMPreBCHBlockErrorRatio();
+void   ATBM_GPO_I2CINT_Output(uint8 ui8Level);
+void   ATBM_GPO_PWM1_Output(uint8 ui8Level);
+void   ATBM_GPO_TestIO23_Output(uint8 ui8Level);
+void   ATBM_TestIO23_Indicate_TS_Lock();
+void   ATBM_TestIO23_Indicate_FEC_No_Error();
+void   ATBM_GPO_TestIO20_Output(uint8 ui8Level);
+void   ATBM_TestIO20_Indicate_FEC_Error();
+void   ATBM_TestIO20_Indicate_TS_Unlock();
+void   ATBMErrorOnDurationMillisecond(int i32MS);
+void   ATBMLockOffDurationMillisecond(int i32MS);
+
+
+//API of Getting DTMB signal parameters
+DTMB_GUARD_INTERVAL   ATBM_GetGuradInterval();
+DTMB_QAM_INDEX        ATBM_GetQamIndex();
+DTMB_CODE_RATE        ATBM_GetCodeRate();
+DTMB_TIME_INTERLEAVE  ATBM_GetInterleavingMode();
+DTMB_CARRIER_MODE     ATBM_GetCarrierMode();
+void                  ATBMGetSignalParameters(DTMB_SIGNAL_PARAMS *singal_params);
+
+
+/****extern interface functions******************************************/
+extern void Delayms (int i32MS);
+extern void DemodHardwareReset(void);
+extern ATBM_I2CREADWRITE_STATUS  I2CWrite(uint8 ui8I2CSlaveAddr, uint8 *ui8pData, int i32Length);
+extern ATBM_I2CREADWRITE_STATUS  I2CRead(uint8 ui8I2CSlaveAddr, uint8 *ui8pData, int i32Length);
+extern ATBM_I2CREADWRITE_STATUS  I2CReadOneStep(uint8 ui8I2CSlaveAddr, uint16 addr_length, uint8 *addr_dat,  uint16 data_length, uint8 *reg_dat);
+extern ATBM_I2CREADWRITE_STATUS  I2CWriteWithRestart(uint8 ui8I2CSlaveAddr, uint8 addr_length, uint8 *addr_dat,  uint8 data_length, uint8 *reg_dat);
+
+
+#define DVBCWriteValue(BaseAddr,RegAddr,WriteValue) {\
+   ATBM_I2CREADWRITE_STATUS enumStatus;\
+   enumStatus =ATBMTransWrite(BaseAddr,RegAddr,WriteValue);\
+   if(ATBM_I2CREADWRITE_OK != enumStatus)\
+   {\
+       return enumStatus;\
+   }\
+}
+
+#define DVBCReadValue(BaseAddr,RegAddr,ReadValue) {\
+	ATBM_I2CREADWRITE_STATUS enumStatus;\
+	enumStatus =ATBMTransRead(BaseAddr,RegAddr,ReadValue);\
+	if(ATBM_I2CREADWRITE_OK != enumStatus)\
+{\
+	return enumStatus;\
+}\
+}
+
+//////////////////
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/dvb_tv/atbm887x/atbm887x.c b/drivers/amlogic/dvb_tv/atbm887x/atbm887x.c
new file mode 100755
index 000000000000..2a93fb0e2cde
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/atbm887x/atbm887x.c
@@ -0,0 +1,4315 @@
+/*****************************************************************************
+Copyright 2012-2020, AltoBeam all rights reserved.
+
+File Name: atbm887x.c
+Description: Software development source codes for ATBM887X DTMB/DVBC demodulator
+(for SoC only supporting the fixed point calculation)
+Version: 1.0.5
+Released 2013-02-22
+
+===============================================================================
+Brief introduction for software porting
+
+--------------------------------------------------------------------------------
+[Basic functions for porting]
+
+There are four basic functions which are to be called by other predefined APIs.
+Developer needs to implement them according to a certain SoC/OS platform.
+All functions for porting are listed at below:
+
+SemodHardwareReset()
+	This function is to control the output of SoC GPIO which is connected to the RESETN pin of demodulator.
+DelayMS()
+	This function is to generate time delay as required.
+I2CRead()
+	This function is to conduct a single read transaction on I2C bus.
+I2CWrite()
+	This function is to conduct a single write transaction on I2C bus.
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[Configuration according to hardware environment]
+
+Some environment variables need to be specified according to a certain hardware design.
+The configuration for these varibles is included in function ATBMPowerOnInit().
+All items for customization and the allowed values for each are listed at below:
+
+MPEG_TS_mode_t
+	ui8TSTransferType: TS_PARALLEL_MODE / TS_SERIAL_MODE
+	ui8OutputEdge: TS_OUTPUT_FALLING_EDGE / TS_OUTPUT_RISING_EDGE
+	ui8TSSPIMSBSelection: TS_SPI_MSB_ON_DATA_BIT7 / TS_SPI_MSB_ON_DATA_BIT0
+	ui8TSSSIOutputSelection: TS_SSI_OUTPUT_ON_DATA_BIT7 / TS_SSI_OUTPUT_ON_DATA_BIT0
+	ui8SPIClockConstantOutput: TS_CLOCK_CONST_OUTPUT / TS_CLOCK_VALID_OUTPUT
+DVBC_Params_t
+	ui8InputMode: DVBC_IF_INPUT / DVBC_IQ_INPUT
+	i32SymbolRate: (1000k ~ 8000k symbol/sec)
+tuner_config_t
+	ui8IQmode: SWAP_IQ / NO_SWAP_IQ
+	ui8DTMBBandwithMHz: (6MHz, 7MHz and 8MHz bandwidth)
+	dbIFFrequency: (4MHz~11MHz, 36MHz~44MHz)
+custom_config_t
+	ui8ATBMSlaveAddr: 0x80 / 0x88
+	ui8CrystalOrOscillator:CRYSTAL / OSCILLATOR
+	ui8DtmbDvbcMode: ATBM_DTMB_MODE / ATBM_DVBC_MODE
+
+--------------------------------------------------------------------------------
+
+--------------------------------------------------------------------------------
+[Predefined API functions to be called]
+There are a set of predefined functions provided in the SDK source codes.
+Simply call some top-level functions to make a basic DTV application, including:
+
+ATBMPowerOnInit()
+       This function is to initialize demodulator after power up, this is the first function
+       must be called before any other demodulator functions.
+ATBMSetConfigParas(custom_config_t stCustomConfigp)
+	This function config the parameter to the global variable ,it should be called
+	before ATBMSetDTMBMode() or ATBMSetDVBCMode()
+ATBMSetDTMBMode()
+	This function sets the demodulator working in DTMB mode.
+ATBMSetDVBCMode()
+        This function sets the demodulator working in DVB-C mode.
+--------------------------------------------------------------------------------
+
+For more information, please refer to the complete SDK user manual.
+===============================================================================
+******************************************************************************/
+
+
+#include <linux/dvb/frontend.h>
+#include <linux/i2c.h>
+#include "../../../media/dvb/dvb-core/dvb_frontend.h"
+#include "../aml_dvb.h"
+#include "atbm887x.h"
+extern struct i2c_adapter *i2c_adap_atbm;
+
+uint8           ui8ATBMSlaveAddr         = 0x40;   /*either 0x80 or 0x88 */
+uint8           ui8ATBMSoftwareVersion = 10;     /*SW guide version = ui8ATBMSoftwareVersion/10 */
+uint32          ui32DvbcOscFreq;
+uint32          ui32DvbcSymbolRate;
+custom_config_t stCustomConfig;  /*global config parameter*/
+
+static uint8 ui8gIQInitValue = 0x01; /*Used to record Demodulator init configuration, may be 0x01 or 0x03, set by ATBMSetOSC*/
+/****************************************************************************
+
+   The following are APIs users need to implement based on their platform.
+   If the enum define is not the same as your i2c return value,
+   You should change the header file to modify the enum ATBM_I2CREADWRITE_STATUS
+   which value is success for i2c write.
+
+****************************************************************************/
+extern ATBM_I2CREADWRITE_STATUS I2CWrite(uint8 ui8I2CSlaveAddr, uint8 *ui8pData, int i32Length)
+ {
+   /* I2C write, please port this function*/
+  // 	printk("\n[I2CWrite] enter I2CSlaveAddr is %x,length is %d,data[0] is %x,data[1] is %x",ui8I2CSlaveAddr,i32Length,ui8pData[0],ui8pData[1]);
+   /* I2C write, please port this function*/
+   int ret = 0;
+//	unsigned char regbuf[1];			/*8 bytes reg addr, regbuf 1 byte*/
+	struct i2c_msg msg;			/*construct 2 msgs, 1 for reg addr, 1 for reg value, send together*/
+
+//	regbuf[0] = I2CSlaveAddr & 0xff;
+
+	memset(&msg, 0, sizeof(msg));
+
+	/*write reg address*/
+/*	msg[0].addr = (state->config.demod_addr);
+	msg[0].flags = 0;
+	msg[0].buf = regbuf;
+	msg[0].len = 1;*/
+
+
+	/*write value*/
+	msg.addr = ui8I2CSlaveAddr;
+	msg.flags = 0;  //I2C_M_NOSTART;	/*i2c_transfer will emit a stop flag, so we should send 2 msg together,
+																// * and the second msg's flag=I2C_M_NOSTART, to get the right timing*/
+	msg.buf = ui8pData;
+	msg.len = i32Length;
+#if 0
+
+	/*write reg address*/
+	msg[0].addr = 0x80;
+	msg[0].flags = 0;
+	msg[0].buf = 0x7;
+	msg[0].len = 1;
+
+	/*write value*/
+	msg[1].addr = 0x80;
+	msg[1].flags = I2C_M_NOSTART;	/*i2c_transfer will emit a stop flag, so we should send 2 msg together,
+																 * and the second msg's flag=I2C_M_NOSTART, to get the right timing*/
+	msg[1].buf = 0x8;
+	msg[1].len = 1;
+#endif
+	struct i2c_adapter *i2c_adap;
+	i2c_adap = i2c_get_adapter(0);
+	if(!i2c_adap){
+		printk("i2c_adap is null\n");
+		return;
+	}
+	ret = i2c_transfer((struct i2c_adapter *)i2c_adap_atbm, &msg, 1);
+	if(ret<0){
+		printk(" %s: writereg error, errno is %d \n", __FUNCTION__, ret);
+		return 0;
+	}
+      return ATBM_I2CREADWRITE_OK;
+ }
+
+extern ATBM_I2CREADWRITE_STATUS I2CRead(uint8 ui8I2CSlaveAddr, uint8 *ui8pData, int i32Length)
+ {
+   /* I2C write, please port this function*/
+     /* I2C read, please port this function*/
+	// 	printk("\n[I2CRead] enter ");
+		 u_int32 nRetCode = 0;
+
+	//	printk("\n[I2CWrite] enter I2CSlaveAddr is %x,length is %d,data[0] is %x,data[1] is %x",ui8I2CSlaveAddr,i32Length,ui8pData[0],ui8pData[1]);
+		 struct i2c_msg msg[1];
+
+		 if(ui8pData == 0 || i32Length == 0)
+		 {
+			 printk("atbm8859 read register parameter error !!\n");
+			 return 0;
+		 }
+
+		 //read real data
+		 memset(msg, 0, sizeof(msg));
+		 msg[0].addr = ui8I2CSlaveAddr;
+		 msg[0].flags |=  I2C_M_RD;  //write  I2C_M_RD=0x01
+		 msg[0].len = i32Length;
+		 msg[0].buf = ui8pData;
+		 struct i2c_adapter *i2c_adap;
+		i2c_adap = i2c_get_adapter(0);
+		if(!i2c_adap){
+		printk("i2c_adap is null\n");
+		return;
+	}
+		 nRetCode = i2c_transfer((struct i2c_adapter *)i2c_adap_atbm, msg, 1);
+
+		 if(nRetCode != 1)
+		 {
+			 printk("atbm8859_readregister reg failure!\n");
+			 return 0;
+		 }
+      return ATBM_I2CREADWRITE_OK;
+ }
+
+
+/******************************************************************************
+I2CRead:  Read one register by one step I2C format, parameters:
+   I2CSlaveAddr:  I2C slave address;
+   addr_length:   address length, here is 2 bytes;
+   addr_dat:      pointer to 2 bytes register address;
+   data_length:   Data length (in byte) to read, here is 1 byte;
+   reg_dat:       pointer to retuned 1 byte register value;
+
+   Reading register 0x0004 the I2C sequences is:
+   S_0x80_A_0x00_A_0x04_A_S_0x81_A_0x01_N_P
+
+   S:I2C start;
+   A:ACK;
+   N:NACK;
+   P:stop
+****************************************************************************/
+extern ATBM_I2CREADWRITE_STATUS I2CReadOneStep(uint8 ui8I2CSlaveAddr, uint16 addr_length, uint8 *addr_dat,  uint16 data_length, uint8 *reg_dat)
+{
+ /*I2C read in one step format, please port this function if needed*/
+    return ATBM_I2CREADWRITE_OK;
+}
+
+/******************************************************************************
+I2CWriteWithRestart: Write one register by one step I2C format, parameters:
+   I2CSlaveAddr:  I2C slave address;
+   addr_length:   address length number, here is 2 bytes;
+   addr_dat:      pointer to 2 bytes register address;
+   data_length:   Data length (in byte) to write, here is 1 byte;
+   reg_dat:       pointer to 1 byte register value;
+
+   Writing register 0x0004 with 0x01 the I2C sequences is:
+   S_0x80_A_0x00_A_0x04_A_S_0x80_A_0x01_A_P
+
+   S:I2C start; A:ACK; N:NACK; P:stop
+   ******Attention a start is needed after sending the register's address.
+****************************************************************************/
+extern ATBM_I2CREADWRITE_STATUS I2CWriteWithRestart(uint8 ui8I2CSlaveAddr, uint8 addr_length, uint8 *addr_dat,  uint8 data_length, uint8 *reg_dat)
+{
+ /*I2C write in one step format, please port this function if needed*/
+    return ATBM_I2CREADWRITE_OK;
+}
+extern void DemodHardwareReset(void) {
+
+	// <to be implemented by user>
+}
+
+
+extern void Delayms (int ms) {
+	msleep(ms);
+	//  <to be implemented by user>
+
+}
+
+
+
+/****************************************************************************
+
+   The following are APIs predefined by AltoBeam.
+   You should change the values of the variables for configuration in function
+   ATBMPowerOnInit() according to hardware design.
+
+****************************************************************************/
+
+
+
+/****************************************************************************
+Next 3 functions is used for fix edition SDK calculation
+******************************************************************************/
+int SNR_log_table_int[]=
+{
+		0, 100,
+		2, 104,
+		4, 109,
+		6, 114,
+		8, 120,
+		10, 125,
+		12, 131,
+		14, 138,
+		16, 144,
+		18, 151,
+		20, 158,
+		22, 166,
+		24, 173,
+		26, 182,
+		28, 190,
+		30, 199,
+		32, 208
+};
+
+int LeftTable(int InValue)
+{
+	int OutValue = 0;
+	int TableSize = sizeof(SNR_log_table_int)/sizeof(int);
+	int i;
+	for(i=0; i<TableSize; i+=2)
+	{
+		if(InValue<=SNR_log_table_int[i+1])
+		{
+			OutValue = SNR_log_table_int[i];
+			return OutValue;
+		}
+	}
+	OutValue = 32;
+	return OutValue;
+}
+
+uint32 Log10Convert(uint32 InValue)
+{
+	uint8       		indx = 0;
+	uint32		        u32_temp = 1;
+	uint32              InValue_left;
+	uint32 log_ret;
+
+	do {
+		u32_temp = u32_temp << 1;
+		if (InValue < u32_temp)
+			break;
+	}while(++indx < 32);
+
+	log_ret = 301*indx/100;
+
+	InValue_left = InValue*100/(1<<indx);
+
+	log_ret = log_ret + LeftTable(InValue_left)/10;
+
+	//printf(" InValue = %d  log ret = %d\n", InValue,  log_ret);
+	return log_ret;
+}
+
+int  FixPow(int x,uint32 y)
+{
+	int i32Rst = x;
+	uint32 i;
+	if (y == 0)
+	{
+		return 1;
+	}
+
+	for (i = 1; i<y; i++)
+	{
+		i32Rst*= x;
+	}
+	return i32Rst;
+}
+
+/**********************if add calcu overflow ,use this function*************************/
+void ATBM64Add(ATBM64Data *pstSum,uint32 ui32Addend)
+{
+	uint32 ui32LowPart;
+	ui32LowPart = pstSum->ui32Low;
+	pstSum->ui32Low += ui32Addend;
+	if (ui32LowPart > pstSum->ui32Low)
+	{
+		pstSum->ui32High++;
+	}
+}
+
+/**********************2 32bit data multipe,then use the next fuction *****************/
+void ATBM64Mult(ATBM64Data *pstRst,uint32 m1, uint32 m2)
+{
+	uint32 ui32LowPart,ui32Tmp;
+	pstRst->ui32Low = (m1&0xffff) * (m2&0xffff);
+	pstRst->ui32High = (m1>>16) * (m2>>16);
+
+	ui32LowPart = pstRst->ui32Low;
+	ui32Tmp = (m1>>16) * (m2&0xffff);
+	pstRst->ui32Low  += (ui32Tmp<<16);
+	pstRst->ui32High += (ui32Tmp>>16);
+	if(ui32LowPart > pstRst->ui32Low)
+	{
+		pstRst->ui32High++;
+	}
+
+	ui32LowPart = pstRst->ui32Low;
+	ui32Tmp = (m2>>16) * (m1&0xffff);
+	pstRst->ui32Low  += (ui32Tmp<<16);
+	pstRst->ui32High += (ui32Tmp>>16);
+	if(ui32LowPart > pstRst->ui32Low)
+	{
+		pstRst->ui32High++;
+	}
+}
+
+uint8  ATBM64ComPare(ATBM64Data stPara,ATBM64Data stPara1)
+{
+	uint8 ui8Flag = 0;//default :stPara<=stPara1
+	if (stPara.ui32Low>=stPara1.ui32Low)
+	{
+		if (stPara.ui32High >= stPara1.ui32High)
+		{
+			ui8Flag = 1;
+		}
+	}
+	else
+	{
+		if (stPara.ui32High > stPara1.ui32High)
+		{
+			ui8Flag = 1;
+		}
+	}
+	return ui8Flag;
+
+}
+uint32 ATBM64Div(ATBM64Data stDivisor,ATBM64Data stDividend)
+{
+	uint8  ui8DivLeftShit = 0;
+	uint32 ui32Rst = 0;
+	ATBM64Data stDataTmp = stDividend;
+	if (stDivisor.ui32High == 0&&stDivisor.ui32Low == 0)
+	{
+		return 0;
+	}
+	else if (stDividend.ui32High == 0&&stDividend.ui32Low == 0)
+	{
+		return 0;
+	}
+	else if (stDividend.ui32High > stDivisor.ui32High)
+	{
+		return 0;
+	}
+	else if (!ATBM64ComPare(stDivisor,stDividend))
+	{
+		return 0;
+	}
+	else if (stDividend.ui32High == 0 && stDivisor.ui32High == 0)
+	{
+		return stDivisor.ui32Low/stDividend.ui32Low;
+	}
+	else// normal condition  stDivisor >= stDividend
+	{
+		for (ui8DivLeftShit;;)
+		{
+			++ui8DivLeftShit;
+			stDataTmp.ui32High<<=1;
+			if(stDataTmp.ui32Low&0x80000000)
+			{
+				stDataTmp.ui32High +=1;
+			}
+			stDataTmp.ui32Low<<=1;
+
+			if (!ATBM64ComPare(stDivisor,stDataTmp)||stDataTmp.ui32High>=0x80000000)
+			{
+				if (stDataTmp.ui32High<0x80000000)
+				{
+					stDataTmp.ui32Low>>=1;
+					if (stDataTmp.ui32High&1)
+					{
+						stDataTmp.ui32Low |= 0x80000000;
+					}
+					stDataTmp.ui32High>>=1;
+					ui8DivLeftShit--;
+				}
+
+
+				stDivisor.ui32High -= stDataTmp.ui32High;
+				if(stDivisor.ui32Low >= stDataTmp.ui32Low)
+				{
+					stDivisor.ui32Low -= stDataTmp.ui32Low;
+				}
+				else
+				{
+					stDivisor.ui32Low +=0xffffffff - stDataTmp.ui32Low;
+					stDivisor.ui32Low += 1;
+					stDivisor.ui32High -= 1;
+				}
+				ui32Rst = (1<<ui8DivLeftShit);;
+				break;
+			}
+		}
+		ui32Rst += ATBM64Div(stDivisor,stDividend);
+	}
+	return ui32Rst;
+}
+ATBM64Data ATBM64DivReturn64(ATBM64Data stDivisor,ATBM64Data stDividend)
+{
+	uint8  ui8DivLeftShit = 0;
+	uint32 ui32LowPart;
+	ATBM64Data i64Data,i64Data1;
+	ATBM64Data stDataTmp = stDividend;
+	i64Data.ui32High = 0;
+	i64Data.ui32Low = 0;
+	if (stDivisor.ui32High == 0&&stDivisor.ui32Low == 0)
+	{
+		return i64Data;
+	}
+	else if (stDividend.ui32High == 0&&stDividend.ui32Low == 0)
+	{
+		return i64Data;
+	}
+	else if (stDividend.ui32High > stDivisor.ui32High)
+	{
+		return i64Data;
+	}
+	else if (!ATBM64ComPare(stDivisor,stDividend))
+	{
+		return i64Data;
+	}
+	else if (stDividend.ui32High == 0 && stDivisor.ui32High == 0)
+	{
+		i64Data.ui32Low = stDivisor.ui32Low/stDividend.ui32Low;
+		return i64Data;
+	}
+	else// normal condition  stDivisor >= stDividend
+	{
+		for (ui8DivLeftShit;;)
+		{
+			++ui8DivLeftShit;
+			stDataTmp.ui32High<<=1;
+			if(stDataTmp.ui32Low&0x80000000)
+			{
+				stDataTmp.ui32High +=1;
+			}
+			stDataTmp.ui32Low<<=1;
+			if (!ATBM64ComPare(stDivisor,stDataTmp)||stDataTmp.ui32High>=0x80000000)
+			{
+				if (stDataTmp.ui32High<0x80000000)
+				{
+					stDataTmp.ui32Low>>=1;
+					if (stDataTmp.ui32High&1)
+					{
+						stDataTmp.ui32Low |= 0x80000000;
+					}
+					stDataTmp.ui32High>>=1;
+					ui8DivLeftShit--;
+				}
+
+
+				stDivisor.ui32High -= stDataTmp.ui32High;
+				if(stDivisor.ui32Low >= stDataTmp.ui32Low)
+				{
+					stDivisor.ui32Low -= stDataTmp.ui32Low;
+				}
+				else
+				{
+					stDivisor.ui32Low +=0xffffffff - stDataTmp.ui32Low;
+					stDivisor.ui32Low += 1;
+					stDivisor.ui32High -= 1;
+				}
+				if (ui8DivLeftShit>=32)
+				{
+					i64Data.ui32High = (1<<(ui8DivLeftShit-32));
+					i64Data.ui32Low = 0;
+				}
+				else
+				{
+					i64Data.ui32Low = (1<<ui8DivLeftShit);
+					i64Data.ui32High = 0;
+				}
+				break;
+			}
+		}
+		i64Data1 = ATBM64DivReturn64(stDivisor,stDividend);
+		ui32LowPart = i64Data.ui32Low;
+		i64Data.ui32Low += i64Data1.ui32Low;
+		i64Data.ui32High += i64Data1.ui32High;
+		if (ui32LowPart>i64Data.ui32Low)
+		{
+			i64Data.ui32High+=1;
+		}
+
+	}
+	return i64Data;
+}
+
+
+/****************************************************************************
+Function:     ATBMPowerOnInit
+Parameters:   none
+Return:       power_on_status
+Description:
+          This function close the reference clock and set  I2C gate off from demod to tuner.
+******************************************************************************/
+int ATBMPowerOnInit()
+{
+	printf("%s\n",__func__);
+	int power_on_status = 0;
+	uint8 ui8pll, reset_status;
+
+	uint8 ui8ChipID;
+	stCustomConfig.stTunerConfig.ui8IQmode              = SWAP_IQ;
+	stCustomConfig.stTunerConfig.ui8DTMBBandwithMHz     = 8; //unit: MHz
+	stCustomConfig.stTunerConfig.ui32IFFrequency        = 5000; //unit: KHz
+
+	//demod config
+	#ifdef CONFIG_ATBM8869_TS_PARALLEL_MODE
+	printk("this is ATBM8869 TS_PARALLEL_MODE \n");
+	stCustomConfig.stTsMode.ui8TSTransferType           = TS_PARALLEL_MODE;
+	#else
+	printk("this is ATBM8869 TS_SERIAL_MODE \n");
+	stCustomConfig.stTsMode.ui8TSTransferType           = TS_SERIAL_MODE;
+	#endif
+	stCustomConfig.stTsMode.ui8OutputEdge               = TS_OUTPUT_RISING_EDGE;
+	stCustomConfig.stTsMode.ui8SPIClockConstantOutput   = TS_CLOCK_VALID_OUTPUT;
+	stCustomConfig.stTsMode.ui8TSSPIMSBSelection        = TS_SPI_MSB_ON_DATA_BIT7;
+	stCustomConfig.stTsMode.ui8TSSSIOutputSelection     = TS_SSI_OUTPUT_ON_DATA_BIT0;
+	stCustomConfig.ui8CrystalOrOscillator               = CRYSTAL;  // when dbSampleClkFrequency == 30.4 then use CRYSTAL macro   and dbSampleClkFrequency == 24.0 then use OSCILLATOR
+	stCustomConfig.ui32SampleClkFrequency               = 30400; //unit: KHz
+
+	//dvbc config
+	stCustomConfig.stDvbcParams.i32SymbolRate           = 6875;//unit: KSymbol/sec, the default value is 6875K in China DVBC broadcasting
+	stCustomConfig.stDvbcParams.ui8InputMode            = DVBC_IF_INPUT;
+
+	ui8ChipID = ATBMChipID();
+	printk("ui8ChipID is %x\n",ui8ChipID);
+
+	if(ui8ChipID == 0x40)
+	{
+		ATBMWrite(0x01, 0x0c, 0x00);
+		ATBMWrite(0x06, 0x06, 0x00);
+		ATBMWrite(0x01, 0x03, 0x00);
+		ATBMRead(0x06, 0x0e, &ui8pll);
+		ATBMWrite(0x06, 0x04, 0x01);
+		ui8pll |= 0x01;
+		ATBMWrite(0x06, 0x0e,ui8pll);
+		ui8pll &= 0xfe;
+		ATBMWrite(0x06, 0x0e,ui8pll);
+		ATBMWrite(0x06, 0x04, 0x00);
+	}
+	else if(ui8ChipID == 0x30)
+	{
+		reset_status = ATBMReset(stCustomConfig.ui8CrystalOrOscillator); //Check hardware state
+		if(reset_status ==0)
+		{
+			printf("please check Crystal or oscillator setting\n");
+		}
+		ATBMWrite(0x06, 0x06, 0x00);
+		ATBMWrite(0x01, 0x03, 0x00);
+	}
+	else
+	{
+		printf("power on init failed, chip not correctly detected\n");
+		return -1;
+	}
+	Delayms(1);/*1 ms*/
+	return power_on_status;
+}
+
+/****************************************************************************
+Function:     ATBMChipID
+Parameters:   none
+Return:       ChipID
+Description: This function checks ATBM887X chip ID,  The chip ID of ATBM887X is 0x40.
+******************************************************************************/
+uint8 ATBMChipID()
+{
+	uint8 ui8ChipID;
+	if(ATBM_I2CREADWRITE_OK == ATBMRead(0x00, 0x00,&ui8ChipID))
+	{
+		return ui8ChipID;
+	}
+	return 0xff;
+}
+
+/****************************************************************************
+Function:    ATBMCheckDemodStatus
+Parameters:  none
+Return:      PLL lock status
+
+Description:
+     Call this function when crystal is used. if PLL locked, hardware reset is not needed.
+     This function is called before configuring demodulator registers.
+	 This function check demodulator status after power on or hardware reset
+     If 1 is returned, demodulator in ready status.
+     If 0 is returned, demodulator need hardware reset or power on.
+******************************************************************************/
+uint8 ATBMCheckDemodStatus()
+{
+	uint8 ui8CheckTimes = 0;
+	uint8 ui8Analog, ui8PLLState, ui8Tmp, ui8HardwareState, ui8ChipID;
+	uint8 ui8Step = 0x20;
+
+	ATBMRead(0x06, 0x07, &ui8HardwareState);
+	if(ui8HardwareState!=5)
+	{
+		return 0;
+	}
+	ATBMRead(0x00, 0x00, &ui8ChipID);
+	if(ui8ChipID == 0x20)
+	{
+		return 1;
+	}
+	ui8PLLState = ATBMCheckPLLStatus();  //check state 0, no register change
+	if(ui8PLLState == 1)
+	{
+		return 1;
+	}
+
+	ATBMRead(0x02, 0x14, &ui8Tmp);
+	while(ui8CheckTimes<5)
+	{
+		if((ui8Tmp&0x02) == 0x02)
+		{
+			ATBMWrite(0x06, 0x06, 0x02); //open
+		}else
+		{
+			ATBMWrite(0x06, 0x06, 0x00);
+		}
+		ui8Analog = ui8CheckTimes*ui8Step;
+		if(ui8CheckTimes == 4)
+		{
+			ui8Analog = 0x60;
+		}
+		ATBMWrite(0x06, 0x0d, ui8Analog);
+		if(ui8CheckTimes == 4)
+		{
+			ATBMWrite(0x06, 0x05, 0x00);
+		}
+		Delayms(10);
+		ui8PLLState = ATBMCheckPLLStatus();
+		if(ui8PLLState == 1)
+		{
+			return 1;
+		}
+		ui8CheckTimes = ui8CheckTimes + 1;
+	}
+	return 0;
+}
+
+/****************************************************************************
+Function:    PLLLock_Flag
+Parameters:  none
+Return:      demodulator PLL lock status
+
+Description:
+	 when internal PLL is locked, the returned value is 1.
+******************************************************************************/
+ uint8 PLLLockFlag()
+ {
+	 uint8 ui8Flag;
+	 int i32Iter = 0;
+	 while(i32Iter<20)
+	 {
+		 ATBMRead(0x06, 0x11, &ui8Flag);
+		 if((ui8Flag&0x01) != 0x01)
+		 {
+			 return 0;
+		 }
+		 i32Iter++;
+	 }
+	 return 1;
+ }
+
+ /****************************************************************************
+ Function:    Digtal_PLL_Lock_Flag
+ Parameters:  none
+ Return:      demodulator PLL lock status
+
+ Description:
+ when DVB-C register set a value different from the default value,
+ if PLL unlocked, the register will be cleared to default value.
+ If PLL aways locked, the register will not be changed.
+ ******************************************************************************/
+ unsigned char Digtal_PLL_Lock_Flag()
+ {
+	 int check_times = 0;
+	 uint8 locked_flag = 0;
+	 uint32 cla_in = 0, cla_out = 0x04;
+
+	 ATBMWrite(0x00, 0x13, 0x01);
+	 ATBMDVBCWrite(0x348, cla_out);
+	 while(check_times<3)
+	 {
+		 ATBMDVBCRead(0x348, &cla_in);
+		 if(cla_in != cla_out)
+		 {
+
+			 locked_flag = 0;
+			 break;
+		 }
+		 else
+		 {
+			 locked_flag = 1;
+		 }
+		 Delayms(10);
+		 check_times = check_times + 1;
+	 }
+	 ATBMWrite(0x00, 0x13, 0x00);
+	 return locked_flag;
+ }
+
+/****************************************************************************
+Function:    ATBMCheckPLLStatus
+Parameters:  none
+Return:      PLL status
+Description:
+	 When demodulator PLL locked and stable, the returned value is 1.
+******************************************************************************/
+ uint8 ATBMCheckPLLStatus(void)
+ {
+	 uint8 ui8PllState,pll_digtal_state, ui8Tmp;
+
+	 ui8PllState = PLLLockFlag();
+	 if(ui8PllState == 1)
+	 {
+		 ATBMRead(0x02, 0x14, &ui8Tmp);
+		 if((ui8Tmp&0x02) != 0x02)
+		 {
+			 ATBMWrite(0x06, 0x06, 0x02);
+		 }
+		 else
+		 {
+			 ATBMWrite(0x06, 0x06, 0x00);
+		 }
+	 }
+	 else
+	 {
+		 return 0;
+	 }
+	 Delayms(10);
+	 ui8PllState = PLLLockFlag();
+	 if(ui8PllState == 1)
+	 {
+		 pll_digtal_state = Digtal_PLL_Lock_Flag();
+		 if(pll_digtal_state == 1)
+		 {
+			 return 1;
+		 }
+
+	 }
+	 return 0;
+ }
+
+ /****************************************************************************
+ Function:    ATBMReset
+ Parameters:  ui8CryOrOsc
+ Return:      1, succed. 0:  failed
+ Description:
+ This function resets ATBM887X demodulator if PLL is not locked. this is a
+ compatible function used in ATBMInit or be called after suspend.
+ for example, transfer from  suspend mode to standby mode.
+ ******************************************************************************/
+ int ATBMReset(uint8 ui8CryOrOsc)
+ {
+
+	 uint8 ui8HardwareState, ui8CheckResult = 0;
+	 uint8 ui8Loop, ui8Tmp;
+	 /* After hardware power on properly or reset correctly,
+	 * ui8HardwareState value should be 0x05 when using crystal, 3.3V PLL
+	 * ui8HardwareState value should be 0x07 when using oscillator, 3.3V PLL */
+
+	 if(ui8CryOrOsc==CRYSTAL)
+	 {
+		 //Software checking, when power on failed, it will return 0 because I2C error or PLL error
+		 ui8CheckResult = ATBMCheckDemodStatus();
+		 if(ui8CheckResult == 1)
+		 {
+			 return 1;
+		 }
+		 //Hardware checking, usually used after demodulator resume from suspend mode
+		 for(ui8Loop=0; ui8Loop<2; ui8Loop++)
+		 {
+			 if(ui8CheckResult != 1)
+			 {
+				 // printf("I2C Error or it is not properly power up, need hardware reset\n");
+				 DemodHardwareReset();    //hardware check
+				 Delayms(50);
+				 ui8CheckResult = ATBMCheckDemodStatus();
+			 }
+			 else
+			 {
+				 return 1;
+			 }
+		 }
+		 return 0;
+	 }
+
+	 if(ui8CryOrOsc==OSCILLATOR)
+	 {
+		 ATBMRead(0x06, 0x07, &ui8HardwareState);
+		 for(ui8Loop=0; ui8Loop<10; ui8Loop++)
+		 {
+			 if(ui8HardwareState!=0x07)
+			 {
+				 // printf("I2C Error or it is not properly power up, need hardware reset\n");
+				 DemodHardwareReset();
+				 Delayms(100);
+				 ATBMRead(0x06, 0x07, &ui8HardwareState);
+			 }
+			 else
+			 {
+				 ATBMRead(0x02, 0x14, &ui8Tmp);
+				 if((ui8Tmp&0x02) != 0x02)
+				 {
+					 ATBMWrite(0x06, 0x06, 0x02);
+				 }
+				 else
+				 {
+					 ATBMWrite(0x06, 0x06, 0x00);
+				 }
+				 break;
+			 }
+		 }
+
+		 if( ui8Loop == 10)
+		 {
+			 return 0;
+		 }else
+		 {
+			 return 1;
+		 }
+	 }
+	 return 0;
+ }
+
+/****************************************************************************
+Function:    ATBM_I2CByPassOn
+Parameters:  none
+Return:      none
+Description: Enable demod to pass I2C commands between tuner and host.
+ ****************************************************************************/
+void ATBMI2CByPassOn()
+{
+	ATBMWrite(0x01,0x03,1); /* the 3st parameter:1-> Enable demod to pass I2C commands between tuner and host. */
+}
+
+/****************************************************************************
+Function:    ATBM_I2CByPassOff
+Parameters:  none
+Return:      none
+Description: Disable the I2C pass-through. Tuner is disconnected from the I2C BUS after this function is called.
+****************************************************************************/
+void ATBMI2CByPassOff()
+{
+	ATBMWrite(0x01,0x03,0); /*the 3st parameter:0-> Disable demod to pass I2C commands between tuner and host*/
+}
+
+/****************************************************************************
+Function:    ATBMLockedFlag
+Parameters:  none
+Return:      1: locked, 0:unlocked
+Description: This function checks ATBM887X Demod locking status
+****************************************************************************/
+int ATBMLockedFlag()
+{
+	 uint8 ui8DTMBFEC           = 0;
+	 uint8 ui8CurReceivingMode;
+	 uint32   ui32DvbcStatus         = 0;
+
+	// ATBMRead(0x00, 0x13, &ui8CurReceivingMode); /*0:DTMB, 1:DVB-C*/
+	 ui8CurReceivingMode = 0x00;
+	 if(ui8CurReceivingMode == 0x00) /*DTMB*/
+	 {
+	 	 ATBMRead(0x03, 0x0d, &ui8DTMBFEC);
+	//	  printf("TS lock is %x\n",ui8DTMBFEC);
+	     ATBMRead(0x0b, 0x08, &ui8DTMBFEC);/*read DTMB internal register*/
+	//	 printf("FEC lock is %x\n",ui8DTMBFEC);
+
+		 if(((ui8DTMBFEC&0x01) == 0x01)&&(ui8DTMBFEC != 0xff)) /*FER locked:bit0*/
+		 {
+			 return 1;
+		 }
+	 }
+	 if(ui8CurReceivingMode == 0x01)
+	 {
+		 ATBMDVBCRead(0x08, &ui32DvbcStatus);/*read DVB-C internal register*/
+		 if(ui32DvbcStatus&0x20) /*bit 5 is locked flag*/
+		 {
+			 return 1;   /*DVB-C FEC locked*/
+		 }
+	}
+	return 0;
+}
+
+
+/****************************************************************************
+Function:    ATBM_sync_state
+Parameters:  none
+Return:      2:lock, 1: sync, 0:unlocked
+Description: This function checks ATBM887X signal state, this is an internal
+             function used by ATBMChannelLockCheck.
+****************************************************************************/
+int ATBM_sync_state()
+{
+	uint8 i, dtmb_fec, signal_sync, sync_times = 0;
+	for(i=0; i<10; i++)
+	{
+		ATBMRead(0x0b, 0x08, &dtmb_fec);
+		if(dtmb_fec&0x01) //bit 0
+		{
+			return 2;           //DTMB FEC locked
+		}
+		ATBMRead(0x08, 0x2B, &signal_sync);
+		if(signal_sync == 6)
+		{
+			sync_times++;
+		}
+		Delayms(30);
+	}
+	if(sync_times >= 3)
+	{
+		return 1;
+	}else
+	{
+		return 0;
+	}
+}
+
+/****************************************************************************
+Function:    ATBMChannelLockCheck
+Parameters:  none
+Return:      1: locked, 0:unlocked
+Description: This function can be used for Auto channel scanning.
+	     It keeps checking ATBM887x signal locking status until it's locked or timeout.
+
+
+             Using Sample:
+
+			 ATBMHoldDSP();
+			 ATBMI2CByPassOn();            //Tuner I2C via demodulator switch on
+			 SetTunerFrequency( 666MHZ)    //sample tuner frequency
+			 ATBMI2CByPassOff();           //Tuner I2C via demodulator switch off
+			 ATBMStartDSP();
+      			 ATBMChannelLockCheck();       //keep checking lock-status until locked or timeout
+****************************************************************************/
+int ATBMChannelLockCheck()
+{
+	uint8 dtmb_fec = 0;
+	int check_result;
+	uint32 dvbc_status = 0;
+	uint32 i32Iter;
+	uint8 cur_receiving_mode;
+	uint32 check_times = 6; //default DTMB: 100ms + 6*300ms timeout
+	uint32 dvbc_time_out = 600; //milliseconds
+	ATBMRead(0x00, 0x13, &cur_receiving_mode); //0:DTMB, 1:DVB-C
+	if(cur_receiving_mode == 0) //DTMB
+	{
+		for(i32Iter =0; i32Iter<2; i32Iter++)
+		{
+			ATBMRead(0x0b, 0x08, &dtmb_fec);
+			if(dtmb_fec&0x01) //bit 0
+			{
+				return 1;           //DTMB FEC locked
+			}
+			Delayms(50);
+		}
+
+		for(i32Iter=0; i32Iter<check_times; i32Iter++)
+		{
+			check_result = ATBM_sync_state();
+			if(check_result == 2)
+			{
+				return 1; //FEC locked
+			}
+
+			if(check_result ==0)
+			{
+				return 0; //signal unsync
+			}
+		}
+	}
+	if(cur_receiving_mode == 1) //DVB-C
+	{
+		check_times = dvbc_time_out/20;
+		for(i32Iter=0; i32Iter<check_times; i32Iter++)
+		{
+			ATBMDVBCRead(0x08, &dvbc_status);       //read DVB-C internal register
+			if(dvbc_status&0x20) //bit 5
+			{
+				return 1;           //DVB-C FEC locked
+			}
+			Delayms(20);
+		}
+	}
+	return 0; //FEC not locked
+}
+
+/****************************************************************************
+Function:    ATBMChannelLockCheckforAutoSwap
+Parameters:  none
+Return:      1: locked, 0:unlocked
+Description: This function can be used for Auto channel scanning.
+             It keeps checking spectrum inversion state and locking status
+             until it's locked or timeout.
+	     This function should be used to replace the above normal ATBMChannelLockCheck()
+             if the spectrum inversion is not certain.
+
+             Using Sample:
+
+			 ATBMHoldDSP();
+			 ATBMI2CByPassOn();            //Tuner I2C via demodulator switch on
+			 SetTunerFrequency( 666MHZ)    //sample tuner frequency
+			 ATBMI2CByPassOff();           //Tuner I2C via demodulator switch off
+			 ATBMStartDSP();
+      			 ATBMChannelLockCheckforAutoSwap();     //Instead of the normal ATBMChannelLockCheck(), spectrum auto swap function is supported
+****************************************************************************/
+int ATBMChannelLockCheckforAutoSwap()
+{
+	uint8 dtmb_fec = 0;
+	int check_result;
+	uint32 dvbc_status = 0;
+	uint32 i32Iter;
+	uint8 cur_receiving_mode;
+	uint32 check_times = 4; //default DTMB:100ms + 4*300ms timeout
+	uint32 dvbc_time_out = 600; //milliseconds
+
+	ATBMRead(0x00, 0x13, &cur_receiving_mode); //0:DTMB, 1:DVB-C
+	if(cur_receiving_mode == 0) //DTMB
+	{
+		for(i32Iter =0; i32Iter<2; i32Iter++)
+		{
+			ATBMRead(0x0b, 0x08, &dtmb_fec);
+			if(dtmb_fec&0x01) //bit 0
+			{
+				return 1;           //DTMB FEC locked
+			}
+			Delayms(50);
+		}
+		/*First using Default IQ*/
+		ATBMWrite(0x0c,0x01, ui8gIQInitValue);
+		Delayms(50);
+		/*Check on IQ default */
+		for(i32Iter=0; i32Iter<check_times; i32Iter++)
+		{
+			check_result = ATBM_sync_state();
+			if(check_result == 2)
+			{
+				return 1; //FEC locked
+			}
+			if(check_result ==0)
+			{
+				ATBMWrite(0x0c,0x01, ui8gIQInitValue);
+				break; //signal sync failed
+			}
+		}
+
+		/*Using inverted IQ*/
+		if(ui8gIQInitValue == 0x01)
+		{
+			ATBMWrite(0x0c,0x01, 0x03);
+		}
+		if(ui8gIQInitValue == 0x03)
+		{
+			ATBMWrite(0x0c,0x01, 0x01);
+		}
+		Delayms(50);
+		/*Check on IQ swap inverted */
+		check_times = 5;
+		for(i32Iter=0; i32Iter<check_times; i32Iter++)
+		{
+			check_result = ATBM_sync_state();
+			if(check_result == 2)
+			{
+				return 1; //FEC locked
+			}
+			if(check_result ==0)
+			{
+				ATBMWrite(0x0c,0x01, ui8gIQInitValue);
+				break; //signal sync failed
+			}
+		}
+	}
+	if(cur_receiving_mode == 1) //DVB-C
+	{
+		check_times = dvbc_time_out/20;
+		for(i32Iter=0; i32Iter<check_times; i32Iter++)
+		{
+			ATBMDVBCRead(0x08, &dvbc_status);       //read DVB-C internal register
+			if(dvbc_status&0x20) //bit 5
+			{
+				return 1;           //DVB-C FEC locked
+			}
+			Delayms(20);
+		}
+	}
+	/*Write back to default IQ if not locked*/
+	if(cur_receiving_mode == 0) //DTMB
+	{
+		ATBMWrite(0x0c,0x01, ui8gIQInitValue);
+	}
+	return 0; //FEC not locked
+}
+
+/****************************************************************************
+Function:    ATBMGetDTMBIQ
+Parameters:  *pu8IQState
+Return:      none
+Description: This function is used to get current IQ state in demodulator.
+             Can be used to record IQ state in Channel scanning mode.
+
+             Using Sample:
+
+			 ATBMHoldDSP();
+			 ATBMI2CByPassOn();            //Tuner I2C via demodulator switch on
+			 SetTunerFrequency( 666MHZ)    //sample tuner frequency
+			 ATBMI2CByPassOff();           //Tuner I2C via demodulator switch off
+			 ATBMStartDSP();
+      			 ATBMChannelLockCheckforAutoSwap();     //Instead of the normal ATBMChannelLockCheck(), spectrum auto swap function is supported
+			 //if signal locked
+			 {
+                 ATBMGetDTMBIQ( unsigned char *pu8IQState); //Record IQ state in channel scaning mode
+			 }
+****************************************************************************/
+void ATBMGetDTMBIQ(unsigned char *pu8IQState)
+{
+	uint8 u8IQRegValue, dtmb_fec;
+	//Default value
+	if(ui8gIQInitValue == 0x01)
+	{
+		*pu8IQState = NO_SWAP_IQ;
+	}else
+	{
+		*pu8IQState = SWAP_IQ;
+	}
+	ATBMRead(0x0b, 0x08, &dtmb_fec);
+	if(dtmb_fec&0x01) //bit 0
+	{
+		ATBMRead(0x0C, 0x01, &u8IQRegValue);
+		if((u8IQRegValue&0x03) == 0x01)
+		{
+			*pu8IQState = NO_SWAP_IQ;
+		}else
+		{
+			*pu8IQState = SWAP_IQ;
+		}
+	}
+}
+/****************************************************************************
+Function:    ATBMGetDTMBIQ
+Parameters:  u8IQState
+Return:      none
+Description: This function is used to set IQ state for demodulator.
+             the IQ state was recorded and stored in channel searching process.
+			 here just set IQ state to the right state  when working in playing
+			 TV or channel switching mode(No used in Scanning mode)
+
+             Using Sample:
+
+			 ATBMHoldDSP();
+			 ATBMI2CByPassOn();            //Tuner I2C via demodulator switch on
+			 SetTunerFrequency( 666MHZ)    //sample tuner frequency
+			 ATBMI2CByPassOff();           //Tuner I2C via demodulator switch off
+			 ATBMStartDSP();
+      		 ATBMSetDTMBIQ(u8IQState); //Set Current IQ state.
+****************************************************************************/
+void ATBMSetDTMBIQ(unsigned char u8IQState)
+{
+	if(SWAP_IQ == u8IQState)
+	{
+		ATBMWrite(0x0c,0x01, 0x03);
+	}else
+	{
+		ATBMWrite(0x0c,0x01, 0x01);
+	}
+}
+/****************************************************************************
+Function:    ATBMChannelLockCheckForManual
+Parameters:  none
+Return:      1: locked, 0:unlocked
+Description: This function can be used for Manual channel scanning.
+	     It keeps spectrum inversion state and locking status
+             until it's locked or timeout.
+	     It takes longer time than ATBMChannelLockCheckforAutoSwap() but more accurate.
+****************************************************************************/
+int ATBMChannelLockCheckForManual()
+{
+	uint8  ui8DTMBFEC          = 0;
+	uint32  ui32DVBCStatus       = 0;
+	uint8  ui8CurReceivingMode;
+	uint32 ui32DTMBTimeOut     = 3000;  /*3000 milliseconds for IQ Normal and 3000 milliseconds for IQ inverted*/
+	uint32 ui32DVBCTimeOut     = 600;  //milliseconds
+	int    i32CheckTimes;
+	int    i32Iter;
+
+  ATBMRead(0x00, 0x13, &ui8CurReceivingMode); /*0:DTMB, 1:DVB-C*/
+	if(ui8CurReceivingMode == 0) /*DTMB*/
+	{
+		i32CheckTimes = ui32DTMBTimeOut/20;
+		/*First using Default IQ*/
+		ATBMWrite(0x0c,0x01, ui8gIQInitValue);
+		for(i32Iter=0; i32Iter<i32CheckTimes; i32Iter++)
+		{
+			ATBMRead(0x0b, 0x08, &ui8DTMBFEC);
+			if(ui8DTMBFEC&0x01) /*bit 0*/
+			{
+				return 1;           /*DTMB FEC locked*/
+			}
+			Delayms(20);
+		}
+		/*Using inverted IQ*/
+		if(ui8gIQInitValue == 0x01)
+		{
+			ATBMWrite(0x0c,0x01, 0x03);
+		}
+		if(ui8gIQInitValue == 0x03)
+		{
+			ATBMWrite(0x0c,0x01, 0x01);
+		}
+		for(i32Iter=0; i32Iter<i32CheckTimes; i32Iter++)
+		{
+			ATBMRead(0x0b, 0x08, &ui8DTMBFEC);
+			if(ui8DTMBFEC&0x01) /*bit 0*/
+			{
+				return 1;           /*DTMB FEC locked*/
+			}
+			Delayms(20);
+		}
+		/*Write back to default IQ if not locked*/
+		ATBMWrite(0x0c,0x01, ui8gIQInitValue);
+	}
+	if(ui8CurReceivingMode == 1) /*DVB-C*/
+	{
+		i32CheckTimes = ui32DVBCTimeOut/20;
+		for(i32Iter=0; i32Iter<i32CheckTimes; i32Iter++)
+		{
+			ATBMDVBCRead(0x08, &ui32DVBCStatus);       /*read DVB-C internal register*/
+			if(ui32DVBCStatus&0x20) /*bit 5*/
+			{
+				return 1;           /*DVB-C FEC locked*/
+			}
+			Delayms(20);
+		}
+	}
+	return 0;
+}
+
+/****************************************************************************
+Function:    ATBMHoldDSP
+Parameters:  none
+Return:      none
+Description: This function should be called before set tuner frequency.
+ ****************************************************************************/
+ void ATBMHoldDSP()
+ {
+	 ATBMWrite(0x00, 0x05, 0x01);
+ }
+
+ /****************************************************************************
+Function:    ATBMStartDSP
+Parameters:  none
+Return:      none
+Description: This function should be called after set tuner frequency.Attention: ATBMHoldDSP and ATBMStartDSP should be used together.
+ ****************************************************************************/
+ void ATBMStartDSP()
+ {
+	 ATBMWrite(0x00, 0x05, 0x00);
+ }
+/****************************************************************************
+Function:    ATBM_Standby
+Parameters:  none
+Return:      none
+Description:
+      This function put demodulator in standby mode, it can cut off part power,
+	  the demodulator can wake up at once by calling ATBM_Standby_WakeUp.
+	  two goals:
+	  1, cut off part power when demodulator put in standby mode
+	  2, put TS output pin in high-z state.
+ ****************************************************************************/
+void ATBMStandby()
+{
+	uint8 ui8ADCPD,ui8TSEdge,ui8RefStandby, ui8ADCRfv,ui8GPORge;
+
+	ATBMRead(0x06, 0x00,&ui8RefStandby);
+	ATBMRead(0x06, 0x02,&ui8ADCPD);
+	ATBMRead(0x03, 0x01,&ui8TSEdge);
+	ATBMRead(0x06, 0x0d,&ui8ADCRfv);
+	ATBMRead(0x10, 0xf7,&ui8GPORge);
+
+	ui8RefStandby |= 0x02;
+	ui8ADCPD      |= 0x01;
+	ui8TSEdge     |= 0x02;
+	ui8ADCRfv     |=0x08;
+	ui8GPORge     |=0x01;
+
+	ATBMWrite(0x00, 0x05, 0x01);
+	ATBMWrite(0x06, 0x0d, ui8ADCRfv);
+	ATBMWrite(0x06, 0x00, ui8RefStandby);
+	ATBMWrite(0x06, 0x02, ui8ADCPD);
+	ATBMWrite(0x15, 0x00, 0x00);
+	ATBMWrite(0x03, 0x01, ui8TSEdge); /*all TS output PINs will be high-z*/
+	ATBMWrite(0x10, 0xf7, ui8GPORge);
+	ATBMWrite(0x00, 0x19, 0x00);
+}
+
+/****************************************************************************
+Function:    ATBM_Standby_WakeUp
+Parameters:  none
+Return:      none
+Description: Put demodulator in previous normal working mode from standby mode
+ ****************************************************************************/
+void ATBMStandbyWakeUp()
+{
+	uint8 ui8ADCPD,ui8TSEdge,ui8RefStandby,ui8ADCRfv,ui8GPORge;
+
+	ATBMRead(0x06, 0x00,&ui8RefStandby);
+	ATBMRead(0x06, 0x02,&ui8ADCPD);
+	ATBMRead(0x03, 0x01,&ui8TSEdge);
+	ATBMRead(0x06, 0x0d,&ui8ADCRfv);
+	ATBMRead(0x10, 0xf7,&ui8GPORge);
+	ui8RefStandby  &= 0xfd;  //bit1 set 0
+	ui8ADCPD       &= 0xfe;     //bit0 set 0
+	ui8TSEdge      &= 0xfd;    //bit1 set 0
+	ui8ADCRfv      &= 0xf7;
+	ui8GPORge      &= 0xfe; //bit 0 set 0
+
+	ATBMWrite(0x06, 0x00, ui8RefStandby);
+	ATBMWrite(0x06, 0x02, ui8ADCPD);
+	ATBMWrite(0x15, 0x00, 0x01);
+	ATBMWrite(0x03, 0x01, ui8TSEdge); //all TS output PINs will be in normal mode
+	ATBMWrite(0x10, 0xf7, ui8GPORge);
+	ATBMWrite(0x06, 0x0d, ui8ADCRfv);
+	ATBMWrite(0x00, 0x19, 0x01);
+	ATBMWrite(0x00, 0x05, 0x00);
+
+}
+
+/****************************************************************************
+Function:    ATBM_Suspend
+Parameters:  none
+Return:      none
+Description:
+    Put ATBM887X demodulator in suspend mode, Hardware reset is needed to wake up
+    the demodulator. if external oscillator is used Hardware pull down is used
+	to enter suspend mode.
+****************************************************************************/
+void ATBMSuspend()
+{
+	uint8 ui8ChipID;
+	ui8ChipID = ATBMChipID();
+	if(ui8ChipID == 0x40)
+	{
+       	ATBMWrite(0x06, 0x06, 0x2);
+	}
+	ATBMStandby();
+	ATBMWrite(0x01, 0x0c, 0x00); //I2C clock switch
+	ATBMWrite(0x06, 0x04, 0x01); //shutdown PLL
+	ATBMWrite(0x06, 0x0e, 0x02); //shut down crystal clock
+}
+
+/****************************************************************************
+Function:       ATBMSignalStrength
+Parameters:     none
+Return:         unsigned short PWM value, in the range of 0--1023
+Description:
+     This function checks ATBM887X signal strength: when signal is weak the number
+     will be big; The smaller the PWM is, the stronger the signal strength detected.
+ ****************************************************************************/
+int ATBMSignalStrength()
+{
+    uint8 ui8PWM0, ui8PWM1;
+
+    ATBMWrite(0x08,0x4d, 1); /*latch read only registers*/
+    ATBMRead(0x10,0x28,&ui8PWM0);
+    ATBMRead(0x10,0x29,&ui8PWM1);
+    ATBMWrite(0x08,0x4d, 0);
+    return  (((ui8PWM1&0x03)<<8)|ui8PWM0);
+}
+
+ /****************************************************************************
+ Function:    ATBMSetDTMBMode
+ Parameters:  none
+ Return:      none
+ Description:
+	This function initializes ATBM887X in DTMB mode, selects DTMB receiving mode,
+	then calls ATBMInit function.
+	ATBMSetConfigParas function should be called before this function.
+ ******************************************************************************/
+ void ATBMSetDTMBMode(void)
+ {
+	 stCustomConfig.ui8DtmbDvbcMode = ATBM_DTMB_MODE;
+
+	 ATBMInit();
+ }
+
+/****************************************************************************
+Function:        ATBMSignalNoiseRatio
+Parameters:      none
+Return:          uint32 (dB)
+Description:
+     This function checks ATBM887X signal-to-noise ratio.
+     Can be used for signal quality evaluation.
+ ****************************************************************************/
+ uint32 ATBMSignalNoiseRatio()
+ {
+	 uint8  ui8PNValue,ui8PN, ui8TmpNoise,ui8IsSc,ui8SignalH, ui8SignalM, ui8SignalL,ui8NoiseH,ui8NoiseM, ui8NoiseL;
+	 int    i32SignalPower,i32NoisePower;
+	 uint32 ui32SNR = 0;
+
+	 ATBMWrite(0x08, 0x4d, 1);/*lock register value*/
+
+	 ATBMRead(0x08, 0x2d,&ui8PNValue);
+	 ui8PN       = (ui8PNValue&0x03);
+	 ATBMRead(0x14, 0xAF,&ui8TmpNoise);
+	 ATBMRead(0x0d, 0x0f,&ui8IsSc);
+
+	 if(ui8IsSc !=1 )
+	 {
+		 ATBMRead(0x0f, 0x1d,&ui8SignalL);
+		 ATBMRead(0x0f, 0x1e,&ui8SignalM);
+		 ATBMRead(0x0f, 0x1f,&ui8SignalH);
+		 ATBMRead(0x0f, 0x1a,&ui8NoiseL);
+		 ATBMRead(0x0f, 0x1b,&ui8NoiseM);
+		 ATBMRead(0x0f, 0x1c,&ui8NoiseH);
+		 i32SignalPower = ((ui8SignalH&0x0f)<<16)+(ui8SignalM<<8)+ui8SignalL;
+		 i32NoisePower  = ((ui8NoiseH&0x07)<<16)+(ui8NoiseM<<8)+ui8NoiseL;
+		 if(i32SignalPower == 0)
+		 {
+			 i32SignalPower = 1; //signal_power should >0 in log calculation;
+		 }
+		 // 		 dbSNR = (double) (10*(log10(i32SignalPower*1.0/(i32NoisePower+1))));
+		 ui32SNR = Log10Convert(i32SignalPower)-Log10Convert(i32NoisePower+1);
+	 }
+	 if(ui8IsSc ==1 )
+	 {
+		 if(ui8PN == 2) //PN595
+		 {
+			 ATBMRead(0x14, 0xdc,&ui8SignalL);
+			 ATBMRead(0x14, 0xdd,&ui8SignalM);
+			 ATBMRead(0x14, 0xde,&ui8SignalH);
+			 i32SignalPower = ((ui8SignalH&0x0f)<<16)+(ui8SignalM<<8)+ui8SignalL;
+			 i32SignalPower = i32SignalPower/16;
+			 if(ui8TmpNoise != 3)
+			 {
+				 ATBMRead(0x14, 0xf8,&ui8NoiseL);
+				 ATBMRead(0x14, 0xf9,&ui8NoiseH);
+				 i32NoisePower = ((ui8NoiseH&0x3f)<<8) + ui8NoiseL;
+			 }
+			 else
+			 {
+				 ATBMRead(0x13, 0x40,&ui8NoiseL);
+				 ATBMRead(0x13, 0x41,&ui8NoiseH);
+				 i32NoisePower = ((ui8NoiseH&0x3f)<<8) + ui8NoiseL;
+			 }
+			 if(i32SignalPower == 0)
+			 {
+				 i32SignalPower = 1; //signal_power should >0 in log calculation;
+			 }
+			 // 			 dbSNR = (double) (10*(log10(i32SignalPower*1.0/(i32NoisePower+1))));
+			 ui32SNR = Log10Convert(i32SignalPower)-Log10Convert(i32NoisePower+1);
+		 }
+
+		 if((ui8PN == 1)||(ui8PN == 3)) //PN420 & PN945
+		 {
+			 ATBMRead(0x09, 0xcc,&ui8SignalL);
+			 ATBMRead(0x09, 0xcd,&ui8SignalH);
+			 i32SignalPower = (ui8SignalH<<8) + ui8SignalL;
+			 ATBMRead(0x09, 0xed,&ui8NoiseL);
+			 ATBMRead(0x09, 0xee,&ui8NoiseH);
+			 i32NoisePower  = ((ui8NoiseH&0x3f)<<8) + ui8NoiseL;
+
+			 if(i32SignalPower == 0)
+			 {
+				 i32SignalPower = 1; //signal_power >0;
+			 }
+			 if(i32NoisePower == 0)
+			 {
+				 // 				 dbSNR = (double)(10*(log10(i32SignalPower*1.0/(i32NoisePower + 1))));
+				 ui32SNR = Log10Convert(i32SignalPower)-Log10Convert(i32NoisePower+1);
+			 }
+			 else
+			 {
+				 // 				 dbSNR = (double)(10*(log10(i32SignalPower*1.0/i32NoisePower)));
+				 ui32SNR = Log10Convert(i32SignalPower)-Log10Convert(i32NoisePower);
+			 }
+		 }
+	 }
+
+	 ATBMWrite(0x08,0x4d, 0);
+
+	 return ui32SNR;
+ }
+ /****************************************************************************
+ Function:           ATBMSignalDivideNoise
+ Parameters:      none
+ Return:             SNR
+
+ Description:
+ This function is an internal function called by ATBMSignalQuality()
+ ****************************************************************************/
+ uint32 ATBMSignalDivideNoise()
+ {
+	 uint8 LockValue;
+
+	 uint8 pn_value,PN;
+	 uint8 tmp_noise;
+	 uint8 is_sc;
+	 uint32 SNR = 0;
+
+	 uint8 signal_h, signal_m, signal_l;
+	 uint8 noise_h,noise_m, noise_l;
+	 uint32 signal_power = 0;
+	 uint32 noise_power = 0;
+
+	 LockValue =1; /*lock register value*/
+	 ATBMWrite(0x08, 0x4d, LockValue);
+
+	 ATBMRead(0x08, 0x2d, &pn_value);
+	 PN = (uint8)(pn_value&0x03);
+
+	 ATBMRead(0x14, 0xAF, &tmp_noise);
+	 ATBMRead(0x0d, 0x0f, &is_sc);
+	 if(is_sc!=1)
+	 {
+		 ATBMRead(0x0f, 0x1d, &signal_l);
+		 ATBMRead(0x0f, 0x1e, &signal_m);
+		 ATBMRead(0x0f, 0x1f, &signal_h);
+		 ATBMRead(0x0f, 0x1a, &noise_l);
+		 ATBMRead(0x0f, 0x1b, &noise_m);
+		 ATBMRead(0x0f, 0x1c, &noise_h);
+		 signal_power = ((signal_h&0x0f)<<16)+(signal_m<<8)+signal_l;
+		 noise_power  = ((noise_h&0x07)<<16)+(noise_m<<8)+noise_l;
+		 if(signal_power ==0)
+		 {
+			 signal_power =1; //signal_power should >0 in log calculation;
+		 }
+		 SNR = (uint32) (signal_power/(noise_power+1));
+	 }
+	 if(is_sc==1)
+	 {
+		 if(PN==2) //PN595
+		 {
+			 ATBMRead(0x14, 0xdc, &signal_l);
+			 ATBMRead(0x14, 0xdd, &signal_m);
+			 ATBMRead(0x14, 0xde, &signal_h);
+			 signal_power = ((signal_h&0x0f)<<16)+(signal_m<<8)+signal_l;
+			 signal_power = signal_power/16;
+			 if(tmp_noise!=3)
+			 {
+				 ATBMRead(0x14, 0xf8, &noise_l);
+				 ATBMRead(0x14, 0xf9, &noise_h);
+				 noise_power = ((noise_h&0x3f)<<8) + noise_l;
+			 }
+			 else
+			 {
+				 ATBMRead(0x13, 0x40, &noise_l);
+				 ATBMRead(0x13, 0x41, &noise_h);
+				 noise_power = ((noise_h&0x3f)<<8) + noise_l;
+			 }
+			 if(signal_power ==0)
+			 {
+				 signal_power =1; //signal_power should >0 in log calculation;
+			 }
+			 SNR = (uint32)(signal_power/(noise_power+1));
+
+		 }
+
+		 if( (PN==1)||(PN==3) ) //PN420 & PN945
+		 {
+
+			 ATBMRead(0x09, 0xcc, &signal_l);
+			 ATBMRead(0x09, 0xcd, &signal_h);
+			 signal_power = (signal_h<<8) + signal_l;
+			 ATBMRead(0x09, 0xed, &noise_l);
+			 ATBMRead(0x09, 0xee, &noise_h);
+			 noise_power = ((noise_h&0x3f)<<8) + noise_l;
+
+			 if(signal_power ==0)
+			 {
+				 signal_power = 1; //signal_power >0;
+			 }
+			 if(noise_power==0)
+			 {
+				 // printf("noise_power is 0,  signal error!");
+				 SNR = (uint32)(signal_power/(noise_power + 1));
+			 }
+			 else
+			 {
+				 SNR = (uint32)(signal_power/noise_power);
+			 }
+		 }
+	 }
+	 LockValue = 0; /*cancel the lock*/
+	 ATBMWrite(0x08,0x4d, LockValue);
+	 return SNR;
+ }
+/****************************************************************************
+Function:    ATBMSignalQuality
+Parameters:  none
+Return:      i32SNR100per, the signal quality evaluated value.
+Description:
+     This function checks ATBM887X signal-to-noise ratio.
+     Can be used for signal quality evaluation:
+	 max value:99, min:20
+ ****************************************************************************/
+int ATBMSignalQuality()
+{
+	uint8  ui8TPSCode, ui8TSSync;
+	int    i32SNR = 0;
+	int    i32SNR100per;
+	uint32 ui32SNRdB = 0;
+	uint32 ui32FrameError;
+
+//	ui32SNRdB    = ATBMSignalNoiseRatio(); //ATBM887X
+	i32SNR = ATBMSignalDivideNoise();
+	ui8TPSCode = ATBMGetTPS();
+	ATBMRead(0x03, 0x0d,&ui8TSSync);
+	if(ui8TSSync != 1)
+	{
+		ATBMRead(0x03, 0x0d,&ui8TSSync);
+	}
+	ui32FrameError = ATBMFrameErrorRatio();
+
+	i32SNR100per = 20;
+	if((ui8TPSCode <11)&&(ui8TPSCode>2))/*4QAM FEC:0.6 0.8*/
+	{
+		if(i32SNR>100)
+		{
+			i32SNR100per = 90+ i32SNR/100;
+		}
+		else if(i32SNR>60)
+		{
+			i32SNR100per = 80 + (i32SNR-60)/4 ;
+		}
+		else if(i32SNR>20)
+		{
+			i32SNR100per = 60 + (i32SNR-20)/2;
+		}
+		else if(i32SNR>5)
+		{
+			i32SNR100per = 40 + i32SNR;
+		}
+		else
+		{
+			i32SNR100per = 40;
+		}
+	}
+
+	if((ui8TPSCode <17)&&(ui8TPSCode>10)) /*For 16QAM FEC:0.6 0.8*/
+	{
+		if(i32SNR>100)
+		{
+			i32SNR100per = 90+ i32SNR/100;
+		}
+		else if(i32SNR>70)
+		{
+			i32SNR100per = 80 + (i32SNR-70)/3 ;
+		}
+		else if(i32SNR>30)
+		{
+			i32SNR100per = 60 + (i32SNR-30)/2;
+		}
+		else if(i32SNR>10)
+		{
+			i32SNR100per = 50 + (i32SNR-10)/2;
+		}
+		else
+		{
+			i32SNR100per = 40;
+		}
+	}
+	if((ui8TPSCode <25)&&(ui8TPSCode>16))/*64QAM FEC:0.6; 32QAM 0.8*/
+	{
+
+		if(i32SNR>100)
+		{
+			i32SNR100per = 90+ i32SNR/100;
+		}
+		else if(i32SNR>70)
+		{
+			i32SNR100per = 80 + (i32SNR-70)/3 ;
+		}
+		else if(i32SNR>30)
+		{
+			i32SNR100per = 60 + (i32SNR-30)/2;
+		}
+		else if(i32SNR>20)
+		{
+			i32SNR100per = 30+ i32SNR;
+		}
+		else
+		{
+			i32SNR100per = 40;
+		}
+	}
+
+	//re-evaluation
+	if((ui8TSSync ==1)&&(ui32FrameError == 0)) //no frame error
+	{
+		//default:5, you can change this value form 0--10, for evaluation
+		i32SNR100per +=5;
+	}
+	else if((ui8TSSync ==1)&&(ui32FrameError!=0))
+	{
+		i32SNR100per = i32SNR100per - 10;
+	}
+	else
+	{
+		i32SNR100per = 30;
+	}
+	if(i32SNR100per>99)
+	{
+		i32SNR100per = 99;
+	}
+
+	return i32SNR100per;
+}
+
+/****************************************************************************
+Function:    ATBMSignalStrength_reference
+Parameters:  none
+Return:      signal_percent
+Description:
+	This function is a sample of signal strength evaluation.
+	the value AGC_A, AGC_B, AGC_C should be calibrated according to can tuner used.
+****************************************************************************/
+uint16 ATBMSignalStrength_reference()
+{
+	uint8 agc0, agc1,LockValue;
+	uint16 agc_value;
+	uint16 signal_percent;
+
+	//agc_value can be read from register 0x1028, 0x1029,  the AGC Value is related with AGC voltage: about (1024/3.3)*V_agc,
+	//Refer to SDK document. the following value should be changed according to Tuner used.
+
+	uint16 AGC_A = 186; //about AGC 0.6V, Signal strength:80
+	uint16 AGC_B = 496; //about AGC 1.6V, Signal strength:60
+	uint16 AGC_C = 930; //about AGC 3.0V, Signal strength:20
+
+	LockValue =1; /*lock register value*/
+	ATBMWrite(0x08,0x4d, LockValue);
+
+	ATBMRead(0x10, 0x28, &agc0);
+	ATBMRead(0x10, 0x29, &agc1);
+
+	LockValue = 0;
+	ATBMWrite(0x08,0x4d, LockValue);
+	agc_value = (uint16)(((agc1&0x03)<<8)|agc0);
+
+	/*Tuner Reference evaluation*/
+	if(agc_value <=AGC_A)
+	{
+		signal_percent = 80;
+	}
+	else if(agc_value <=AGC_B)
+	{
+		signal_percent = (uint16)((AGC_B - agc_value)*20/(AGC_B - AGC_A) + 60);
+	}
+	else if(agc_value <=AGC_C)
+	{
+		signal_percent = (uint16)((AGC_C - agc_value)*40/(AGC_C - AGC_B) + 20);
+	}
+	else
+	{
+		signal_percent = 20;
+	}
+
+	return signal_percent;
+}
+
+/****************************************************************************
+Function:    ATBMFrameErrorRatio
+Parameters:  none
+Return:      ui32FrameErrorRatio
+Description:
+	This function counts pre-BCH error frames in specified frame window size
+	(Default 2048 frames), then print and return pre-BCH frames error ratio.
+	return error frame number per 1000 frames.
+****************************************************************************/
+uint32 ATBMFrameErrorRatio()
+{
+
+	uint8  ui8FrameError0, ui8FrameError1;
+	uint8  ui8ArrFrameCountMax[2];
+	uint32 ui32FrameErrorRatio;
+
+	ATBMRead(0x0B, 0x09,&ui8ArrFrameCountMax[0]);
+	ATBMRead(0x0B, 0x0A,&ui8ArrFrameCountMax[1]);
+	ATBMWrite(0x08, 0x4d, 1);  /*latch read only registers*/
+	ATBMRead(0x0B, 0x14,&ui8FrameError0);
+	ATBMRead(0x0b, 0x15,&ui8FrameError1);
+	ATBMWrite(0x08, 0x4d, 0);
+	if((ui8ArrFrameCountMax[1] == 0)&&(ui8ArrFrameCountMax[0] == 0))
+	{
+		//printf("I2C error\n");
+		ui32FrameErrorRatio = 0;
+		return ui32FrameErrorRatio;
+	}
+	ui32FrameErrorRatio = ((1000 * (ui8FrameError1&0x7f)*256 + ui8FrameError0))/((ui8ArrFrameCountMax[1]&0x7f)*256 + ui8ArrFrameCountMax[0]);
+    //printf(" DTMB frame error number per 1000 frames = %d\n", ui32FrameErrorRatio);
+	return  ui32FrameErrorRatio;
+}
+
+/****************************************************************************
+Function:    ATBMPreBCHBlockErrorRatio
+Parameters:  none
+Return:      ui32BlockErrorRatio
+
+Description:
+    This function counts blocks with error in specified block window size,
+    Then calculate and return pre-BCH block error ratio.
+	return BCH error blocks number per 1000 blocks
+****************************************************************************/
+uint32 ATBMPreBCHBlockErrorRatio()
+{
+
+	uint8 ui8BlockCountMax[2];
+	uint8 ui8PreBCHBerCount[2];
+	uint8 ui8LockValue;
+	uint32 ui32BlockErrorRatio;
+
+	ATBMRead(0x0B, 0x10,&ui8BlockCountMax[0]);
+	ATBMRead(0x0B, 0x11,&ui8BlockCountMax[1]);
+
+	ui8LockValue =1;
+	ATBMWrite(0x08, 0x4d, ui8LockValue);  /*latch read only registers*/
+	ATBMRead(0x0B, 0x12,&ui8PreBCHBerCount[0]);
+	ATBMRead(0x0B, 0x13,&ui8PreBCHBerCount[1]);
+	ui8LockValue = 0;
+	ATBMWrite(0x08, 0x4d, ui8LockValue);
+	if((ui8BlockCountMax[0] == 0)&&(ui8BlockCountMax[1]==0))
+	{
+		//printf("I2C error\n");
+		ui32BlockErrorRatio = 0;
+		return ui32BlockErrorRatio;
+	}
+	ui32BlockErrorRatio  = (1000 * (ui8PreBCHBerCount[1]*256 + ui8PreBCHBerCount[0]))/(ui8BlockCountMax[1]*256 + ui8BlockCountMax[0]);
+	//printf(" DTMB Pre-BCH Block error block number per 1000 blocks = %d\n", ui32BlockErrorRatio);
+	return ui32BlockErrorRatio;
+}
+
+/****************************************************************************
+Function:    ATBMBER_Calc
+Parameters:  none
+Return:      BER
+
+Description:
+    This function returns calculated BER.
+****************************************************************************/
+uint32 ATBMBER_Calc(uint32 *i32pBerExponent)
+{
+	uint8 ber_count[3];
+	uint32 ui32BerWinSize, ui32BitErrorCount = 0;
+	uint8 ui8Iter, LockValue;
+	uint32 i32Tmp, ui32BerCoeffient = 0;
+	int    i32EPara = 0;
+
+	LockValue =1;
+	ATBMWrite(0x08, 0x4d, LockValue);  /*latch read only registers*/
+	ATBMRead(0x0B, 0x21, &ber_count[0]);
+	ATBMRead(0x0B, 0x22, &ber_count[1]);
+	ATBMRead(0x0B, 0x23, &ber_count[2]);
+	LockValue = 0;
+	ATBMWrite(0x08, 0x4d, LockValue);
+
+	ui32BerWinSize = FixPow(2,27);
+	ui32BitErrorCount  = ((ber_count[2]&0x07)*256*256 + ber_count[1]*256 + ber_count[0]);
+
+	if((ui32BitErrorCount ==0)||(ui32BerWinSize == 0))
+	{
+		ui32BerCoeffient = 0;
+		*i32pBerExponent = 0;
+		//printf("BER = %d E- %d\n",ui32BerCoeffient, *i32pBerExponent);
+		return ui32BerCoeffient;
+	}
+	for (ui8Iter=0; ui8Iter<12; ui8Iter++)
+	{
+		i32Tmp = ui32BitErrorCount/ui32BerWinSize;
+		if (i32Tmp)
+		{
+			ui32BerCoeffient = (ui32BitErrorCount)/ui32BerWinSize;
+			break;
+		}
+		else
+		{
+			i32EPara += 1;
+			ui32BitErrorCount *=10;
+		}
+	}
+	*i32pBerExponent  = i32EPara;
+	//printf("BER = %d E- %d\n",ui32BerCoeffient, *i32pBerExponent);
+	return ui32BerCoeffient;
+}
+
+/****************************DVBC Parameters************************************************/
+uint8  ui8DVBCI2CBurstMode = 0;
+// uint32 dbCMS0022MaxSymbolRateRatio         = (1.0/4);
+// uint32 dbCMS0022CIC2DELAY                  = (3.0);
+// uint32 dbCMS0022CIC3DELAY                  = (0.0);
+uint8  ui8ADvbcCciAci[]=
+{
+	0x0a, 0x3b, 0x28,
+	0x0a, 0x42, 0x10,
+	0x0a, 0x43, 0x05,
+	0x0a, 0x46, 0x00,
+	0x0a, 0x47, 0x01,
+	0x0a, 0x48, 0x14,
+	0x0a, 0x49, 0x00,
+	0x0a, 0x4a, 0x76,
+	0x0a, 0x52, 0x10,
+	0x0a, 0x53, 0x52,
+	0x0a, 0x54, 0xb1,
+	0x0a, 0x58, 0x00,
+	0x0a, 0x59, 0x40,
+	0x0a, 0x5b, 0x00,
+	0x0a, 0x5c, 0x1f,
+	0x0a, 0x5d, 0x05,
+	0x0a, 0x5e, 0x20,
+	0x0a, 0x5f, 0x00,
+	0x0a, 0x60, 0x04,
+	0x0a, 0x62, 0x1e,
+	0x0a, 0x91, 0x0f,
+	0x0a, 0x95, 0x38,
+	0x0a, 0xa0, 0xff,
+	0x0a, 0xa1, 0xfa,
+	0x0a, 0xa2, 0x00,
+	0x0a, 0xac, 0xff,
+	0x0a, 0xb2, 0x00,
+	0x0a, 0xb3, 0xff,
+	0x0a, 0xb4, 0x0f,
+	0x0a, 0xb5, 0x68,
+	0x0a, 0xb7, 0x5c,
+	0x0a, 0xb9, 0xff,
+	0x0a, 0xba, 0x0f,
+	0x0a, 0xbe, 0x9d,
+	0x0a, 0xc0, 0x14,
+	0x0a, 0xd2, 0x30,
+	0x0a, 0xd3, 0x00,
+	0x0a, 0xd4, 0x05,
+	0x0a, 0xd5, 0x40,
+	0x0a, 0xd9, 0x0a,
+	0x10, 0x81, 0xfa,
+	0x10, 0x82, 0x00,
+	0x10, 0x9d, 0x00,
+	0x10, 0x9f, 0x00,
+	0x10, 0xa1, 0x00,
+	0x10, 0xa2, 0x00,
+	0x10, 0xa7, 0x0b,
+	0x10, 0xac, 0x4d
+};
+
+static uint8 ui8ADtmbInternal[]=
+{
+	0x00, 0x16, 0x1d, //DTMB mode
+	0x09, 0x88, 0x08,
+	0x09, 0x89, 0x0c,
+	0x09, 0x9a, 0x40,
+	0x09, 0x35,0x14,
+	0x0a, 0xf9, 0x00,
+	0x0e, 0x01, 0x08,
+	0x08, 0x52, 0x28,
+	0x0c, 0x24, 0x0a,
+	0x0c, 0x26, 0x0a
+};
+static uint8 uiA8DvbcInternal[]=
+{
+	0x00, 0x0a, 0x00,
+	0x00, 0x09, 0x00,
+	0x00, 0x13, 0x01,
+	0x15, 0x18, 0x01,
+	0x15, 0x15, 0x01,
+	0x15, 0x20, 0x00,
+	0x15, 0x21, 0x80,
+	0x15, 0x2e, 0x01
+};
+
+uint8 ui8AATBM887XCommonReg[]=
+{
+	0x02, 0x45, 0x33,
+	0x02, 0x4a, 0x96,
+	0x02, 0xc6, 0x00,
+	0x02, 0xc7, 0x01
+};
+uint8 ui8AATBM887XDtmbSet[]=
+{
+	0x02, 0x28, 0x01,
+	0x02, 0xa6, 0x10,
+	0x02, 0xa9, 0x60,
+	0x02, 0xcb, 0x68,
+	0x02, 0xcc, 0x70,
+	0x02, 0x49, 0x30
+};
+uint8 ui8AATBM887XDvbcSet[]=
+{
+	0x02, 0x28, 0x00,
+	0x02, 0x3c, 0x0c,
+	0x02, 0x49, 0x29,
+	0x02, 0xa6, 0x14,
+	0x02, 0xa9, 0x4a,
+	0x02, 0xcb, 0x40,
+	0x02, 0xcc, 0x43,
+	0x15, 0x12, 0x00
+};
+
+uint8 ui8AATBM887XDtmb30Dot4MSet[]=
+{
+	0x02, 0xC5, 0x05,
+	0x02, 0x4E, 0x08,
+	0x02, 0x3E, 0x1C,
+	0x02, 0x3B, 0x1C,
+	0x0A, 0xFB, 0x00,
+	0x02, 0x3C, 0x16
+};
+uint8 ui8AATBM887XDtmb24MSet[]=
+{
+	0x02, 0xC5, 0x15,
+	0x02, 0x4E, 0x10,
+	0x02, 0x3E, 0x28,
+	0x02, 0x3B, 0x28,
+	0x0A, 0xFB, 0x01,
+	0x02, 0x3C, 0x1C,
+	0x14, 0x47, 0xc0,
+	0x13, 0x55, 0x00
+};
+uint8 ui8ATBM887XDvbc30Dot4MSet[]=
+{
+	0x02, 0xC5, 0x05,
+	0x02, 0x4E, 0x08,
+	0x02, 0x3E, 0x1C,
+	0x02, 0x3B, 0x1C
+};
+uint8 ui8AATBM887XDvbc24MSet[]=
+{
+	0x02, 0xC5, 0x15,
+	0x02, 0x4E, 0x10,
+	0x02, 0x3E, 0x28,
+	0x02, 0x3B, 0x28
+};
+
+uint8 uiAATBMDynamicSetting[]={
+	0x09, 0x88, 0x08,
+	0x09, 0x89, 0x08,
+	0x09, 0x8b, 0x08,
+	0x09, 0x04, 0x01,
+	0x09, 0x05, 0x02,
+	0x09, 0x57, 0x00,
+	0x09, 0x5a, 0x02,
+	0x09, 0x59, 0x40,
+	0x09, 0x5b, 0x40
+};
+ /****************************************************************************
+ Function:    ATBMSetDVBCMode
+ Parameters:  none
+ Return:      none
+ Description:
+	  This function initializes ATBM887X in DVB-C mode, selects DVB-C receiving mode,
+	  then calls ATBMInit function
+	  ATBMSetConfigParas function should be called before this function.
+ ******************************************************************************/
+void ATBMSetDVBCMode(void)
+ {
+	 stCustomConfig.ui8DtmbDvbcMode = ATBM_DVBC_MODE;
+
+	 ATBMInit();
+ }
+
+/****************************************************************************
+Function:   ATBMDVBCSNR
+Parameters:   None
+Return:    DVBC signal-to-noise ratio in dB format
+
+Description:
+	Calculate  DVB-C SNR:
+******************************************************************************/
+int ATBMDVBCSNR()
+{
+	int ui32DVBCSNR;
+	int    i32Tmp,i32Tmp1;
+
+	ui32DVBCSNR = 0;
+	ATBMDVBCRead(0x3C4,&i32Tmp);
+	ATBMDVBCRead(0x3d0,&i32Tmp1);
+	i32Tmp    = i32Tmp&0xffff;
+	i32Tmp1   = (i32Tmp1&0x7)+1; //pow(2,i32Tmp1) means QAM
+
+	if(i32Tmp ==0)
+	{
+		i32Tmp = 1;
+	}
+
+	if((i32Tmp1==4) ||(i32Tmp1==6) ||(i32Tmp1==8))
+	{
+		if(i32Tmp!=0)
+		{
+// 			dbDVBCSNR = -20*log10(i32Tmp/65536.0)-0.8;//QAM=16,64,256
+			ui32DVBCSNR = -2*(Log10Convert(i32Tmp)-Log10Convert(65536))-1;
+		}
+	}
+	else if( (i32Tmp1==5) ||(i32Tmp1==7))
+	{
+		if(i32Tmp !=0)
+		{
+// 			dbDVBCSNR = -20*log10(i32Tmp/65536.0)-4.0;//QAM=32,128
+			ui32DVBCSNR = -2*(Log10Convert(i32Tmp)-Log10Convert(65536))-4;
+
+		}
+	}
+	else
+	{
+		ui32DVBCSNR=0;
+
+	}
+	//  printf("DVBC SNR = %f dB\n",dbDVBCSNR);
+	return ui32DVBCSNR;
+
+}
+
+/****************************************************************************
+Function:   ATBMDVBCBER
+Parameters: BerExponent: scientific notation exponent
+Return:     ui32BerCoeffient: RS corrected Bit error rate real number.
+Description:
+	Calculate DVB-C RS bit error rate.
+******************************************************************************/
+uint32   ATBMDVBCBER(int *pi32BerExponent)
+{
+	uint8  ui8Adata[2];
+	uint8  ui8Iter;
+	int    i32Tmp;
+	int    i32TotalBits = 13369344; //SampleSize: 8192*204*8
+	int    i32EPara = 0;
+	int    i32CorrectedBerBits = 0;
+	uint32 ui32BerCoeffient =0;
+
+	ATBMRead(0x15, 0x23,&ui8Adata[1]);
+	ATBMRead(0x15, 0x22,&ui8Adata[0]);
+	i32CorrectedBerBits = ui8Adata[1]*256 + ui8Adata[0];
+	ATBMRead(0x15, 0x21,&ui8Adata[1]);
+	ATBMRead(0x15, 0x20,&ui8Adata[0]);
+	i32TotalBits        = (ui8Adata[1]*256 + ui8Adata[0])*204*8;
+	if((i32CorrectedBerBits ==0)||(i32TotalBits == 0))
+	{
+		ui32BerCoeffient = 0;
+		*pi32BerExponent = 0;
+		//printf("PreRsBer = %d E- %d\n",ui32BerCoeffient, *BerExponent);
+		return ui32BerCoeffient;
+	}
+	for (ui8Iter=0;ui8Iter<12;ui8Iter++)
+	{
+		i32Tmp = i32CorrectedBerBits/i32TotalBits;
+		if (i32Tmp)
+		{
+			ui32BerCoeffient = i32CorrectedBerBits/i32TotalBits;
+			break;
+		}
+		else
+		{
+			i32EPara +=1;
+			i32CorrectedBerBits *=10;
+		}
+	}
+	*pi32BerExponent  = i32EPara;
+	//printf("PreRsBer = %d E- %d\n",ui32BerCoeffient, *BerExponent);
+	return ui32BerCoeffient;
+}
+
+
+/****************************************************************************
+Function:   ATBMDVBCUncorrectablePER
+Parameters: i32pPktsExponent: scientific notation exponent
+Return:   ui32PktsCoeffient: error packets rate real number.
+Description:
+	This function counts DVB-C ui8AData packet which contains uncorrected error and calculate packet error rates.
+******************************************************************************/
+uint32  ATBMDVBCUncorrectablePER(int *i32pPktsExponent )
+{
+	uint8  ui8AData[2],ui8Iter;
+	int    i32Tmp;
+	int    i32TotalPkts = 8192; //SampleSize: 8192 packets
+	int    i32EPara = 0;
+	int    i32UncorrectedPackets = 0;
+	uint32 ui32PktsCoeffient = 0;
+
+	ATBMRead(0x15, 0x27,&ui8AData[1]);
+	ATBMRead(0x15, 0x26,&ui8AData[0]);
+	i32UncorrectedPackets = ui8AData[1]*256 + ui8AData[0];
+	ATBMRead(0x15, 0x21,&ui8AData[1]);
+	ATBMRead(0x15, 0x20,&ui8AData[0]);
+	i32TotalPkts          = ui8AData[1]*256 + ui8AData[0];
+
+	if((i32UncorrectedPackets ==0)||(i32TotalPkts == 0))
+	{
+		ui32PktsCoeffient   = 0;
+		*i32pPktsExponent = 0;
+		//printf("Pks Error = %d E- %d\n",ui32PktsCoeffient, *i32pPktsExponent);
+		return ui32PktsCoeffient;
+	}
+	for (ui8Iter=0;ui8Iter<12;ui8Iter++)
+	{
+		i32Tmp = i32UncorrectedPackets/i32TotalPkts;
+		if (i32Tmp)
+		{
+			ui32PktsCoeffient = (i32UncorrectedPackets)/i32TotalPkts;
+			break;
+		}
+		else
+		{
+			i32EPara += 1;
+			i32UncorrectedPackets *=10;
+		}
+	}
+	*i32pPktsExponent  = i32EPara;
+	//printf("Pks Error = %d E- %d\n",ui32PktsCoeffient, *i32pPktsExponent);
+	return ui32PktsCoeffient;
+
+}
+
+/****************************************************************************
+Function:     ATBMDVBCGetQAM
+Parameters:   None
+Return:       QAM_index
+Description:
+	Get DVB-C QAM index
+	4: 16QAM
+	5: 32QAM
+	6: 64QAM
+	7: 128QAM
+	8: 256QAM
+******************************************************************************/
+uint8   ATBMDVBCGetQAM()
+{
+	uint8 ui8QAMIndex;
+	int   i32Tmp;
+
+	ATBMDVBCRead(0x3d0,&i32Tmp);
+	ui8QAMIndex = (uint8)((i32Tmp&0x7)+1); //pow(2,tmp) means QAM
+	//printf("DVB-C signal QAM index = %d \n", QAM_index);
+	return ui8QAMIndex;
+}
+
+/*****************************************************************************
+Function:    ATBMDVBCSignalStrength
+Parameters:  none
+Return:      XgcGain
+Description:
+    This function checks DVB-C external IF gain value used by the XGC. The function
+    can be used for DVB-C signal strength evaluation.
+    Different Tuner have different XgcGain Range. It is needed to test XgcGain value
+    on different signal strength level to make a Tuner's private signal strength evaluation function.
+*****************************************************************************/
+int ATBMDVBCSignalStrength()
+{
+	int i32XgcGain;
+	int i32XgcGain1;
+
+	ATBMDVBCRead(0x114,&i32XgcGain1);
+	i32XgcGain = (int)(i32XgcGain1&0xfff);
+//	printf(" XgcGain = 0x%x\n", XgcGain);
+	return i32XgcGain;
+}
+
+/****************************************************************************
+Function:		ATBMDVBCInit
+Parameters:   stCustomConfig
+Return: 		None
+Description:
+	Call this function to configure all DVBC related registers.
+******************************************************************************/
+void ATBMDVBCInit( custom_config_t stCustomConfig)
+{
+
+	uint8  ui8RegH, ui8RegL , ui8Rst, ui8TmpData, ui8pll;
+	uint8 ui8ATBMChipID;
+	uint16 ui16ParamsDvbcRatio;
+	int    i32TmpRst;
+	//int    i32Length = 0;
+	int    i32RifControl;
+	//int    i32DebugData = 0;
+	int	   i32ItbCoarseFrequencyOffset;
+	int ui32OSCFreq = 0;
+	int ui32IFFreq = 0;
+	uint32 ui32SymbolRateM, ui32SysClk,ui32ItbCoarseFrequencyOffset;
+	ATBM64Data i64Data,i64Data1;
+	ui8ATBMChipID = ATBMChipID();
+	ATBMDVBCWrite(0x04, 0x1);  //DVBC Module Reset
+	if(stCustomConfig.stDvbcParams.ui8InputMode == DVBC_IF_INPUT)
+	{
+		i32RifControl = 0x01; //IF mode
+		ATBMDVBCWrite(0x100, i32RifControl);
+
+		//886x special register
+		if(ui8ATBMChipID == 0x40)
+		{
+			ATBMDVBCWrite(0x104,0x01);
+			ATBMDVBCWrite(0x304,0x05);
+		}
+
+	}else
+	{
+		i32RifControl = 0x00; //IQmode
+		ATBMDVBCWrite(0x100, i32RifControl);
+		ATBMDVBCWrite(0x104,0x01);  //gain control
+		ATBMDVBCWrite(0x118, 0x00);
+		ATBMWriteRegArray(ui8ADvbcCciAci,sizeof(ui8ADvbcCciAci)/sizeof(uint8));
+	}
+
+	ui32SymbolRateM = (stCustomConfig.stDvbcParams.i32SymbolRate);
+
+	//886x special register setting
+	if(ui8ATBMChipID == 0x40)
+	{
+		ui16ParamsDvbcRatio = (uint16)(ui32SymbolRateM*1032/1000);
+		ui8RegH = ui16ParamsDvbcRatio/256;
+		ui8RegL = ui16ParamsDvbcRatio&0xff;
+		ATBMWrite(0x02, 0x53, ui8RegL);
+		ATBMWrite(0x02, 0x54, ui8RegH);
+		if(stCustomConfig.ui32SampleClkFrequency == 30400) //30.4MHz crystal
+		{
+			ATBMRead(0x06, 0x0e,&ui8TmpData);
+			if(ui8TmpData&0x08)
+			{
+				ui8Rst =(uint8)(4778125/ui32SymbolRateM/40);
+			}else
+			{
+				ui8Rst =(uint8)(4180000/ui32SymbolRateM/40);
+			}
+			ATBMWrite(0x15, 0x37, ui8Rst);
+		}
+		if(stCustomConfig.ui32SampleClkFrequency == 24000) //24MHz crystal
+		{
+			ATBMRead(0x06, 0x0e,&ui8TmpData);
+			if(ui8TmpData&0x08)
+			{
+				ui32SysClk = 64;
+			}else
+			{
+				ui32SysClk = 72;
+			}
+			ui8Rst =(uint8)(6875*ui32SysClk/ui32SymbolRateM/4);
+			ATBMWrite(0x15, 0x37, ui8Rst);
+		}
+	}
+	//end for 886x
+
+	ui32DvbcSymbolRate = stCustomConfig.stDvbcParams.i32SymbolRate;
+	if(stCustomConfig.ui32SampleClkFrequency == 24000) //24MHz crystal
+	{
+		ui32OSCFreq = stCustomConfig.ui32SampleClkFrequency*2;
+		if(ui8ATBMChipID == 0x30)
+		{
+			ATBMDVBCWrite(0x104,0x14);
+		}
+	}
+	else
+	{
+		ui32OSCFreq = stCustomConfig.ui32SampleClkFrequency;
+		if(ui8ATBMChipID == 0x30)
+		{
+			ATBMDVBCWrite(0x104,0x34);
+		}
+	}
+	ui32DvbcOscFreq= ui32OSCFreq;
+	if(stCustomConfig.stDvbcParams.ui8InputMode == DVBC_IF_INPUT)
+	{
+		ui32IFFreq = stCustomConfig.stTunerConfig.ui32IFFrequency;
+		i32TmpRst = (ui32OSCFreq>ui32IFFreq?(ui32OSCFreq - ui32IFFreq):(ui32IFFreq -ui32OSCFreq)*-1);
+		if (ui32OSCFreq>ui32IFFreq)
+		{
+// 			ui32ItbCoarseFrequencyOffset = i32TmpRst/100;
+// 			ui32ItbCoarseFrequencyOffset = (8388608*ui32ItbCoarseFrequencyOffset/(ui32OSCFreq/100)*16);//no problem
+			//commnet: i32TmpRst*8388608**16*100/100/ui32OSCFreq = 134217728*i32TmpRst/ui32OSCFreq
+
+
+			ATBM64Mult(&i64Data,134217728,i32TmpRst);
+			i64Data1.ui32High = 0;
+			i64Data1.ui32Low = ui32OSCFreq;
+			ui32ItbCoarseFrequencyOffset = ATBM64Div(i64Data,i64Data1);
+
+			ATBMDVBCWrite(DVBC_COARSE_FREQUENCY_OFFSET_ADDR,ui32ItbCoarseFrequencyOffset);
+		}
+		else
+		{
+// 			i32ItbCoarseFrequencyOffset= (8388608*(i32TmpRst/100)/(ui32OSCFreq/100)*16);//no problem
+            i32TmpRst = i32TmpRst*(-1);
+			ATBM64Mult(&i64Data,134217728,i32TmpRst);
+			i64Data1.ui32High = 0;
+			i64Data1.ui32Low = ui32OSCFreq;
+			i32ItbCoarseFrequencyOffset = ATBM64Div(i64Data,i64Data1);
+            i32ItbCoarseFrequencyOffset = i32ItbCoarseFrequencyOffset *(-1);
+			ATBMDVBCWrite(DVBC_COARSE_FREQUENCY_OFFSET_ADDR,i32ItbCoarseFrequencyOffset);
+		}
+	}
+	ATBMDVBCSetCarrier(ui32OSCFreq,	ui32SymbolRateM);
+	ATBMDVBCSetSymbolRate(ui32OSCFreq, ui32SymbolRateM);
+	ATBMDVBCSetQAM();
+
+	ATBMDVBCWrite(0x394,0xc7);
+	ATBMDVBCWrite(0x39c,0x36);
+
+	ATBMDVBCWrite(0x20c,0x10);
+	ATBMDVBCWrite(0x204,0x400); //DVB-C symbol rate offset related
+	ATBMDVBCWrite(0x04, 0x00);  //DVBC Module start processing
+	if(ui8ATBMChipID == 0x40)
+	{
+		if(stCustomConfig.ui32SampleClkFrequency == 24000) //24MHz crystal
+		{
+			ATBMWrite(0x01, 0x0c, 0x00);
+			Delayms(1);/*1 ms*/
+			ATBMRead(0x06, 0x0e, &ui8pll);
+			ATBMWrite(0x06, 0x04, 0x01);
+			ui8pll |= 0x01;
+			ATBMWrite(0x06, 0x0e,ui8pll);
+			ui8pll &= 0xfe;
+			ATBMWrite(0x06, 0x0e,ui8pll);
+			ATBMWrite(0x06, 0x04, 0x00);
+			Delayms(1);/*1 ms*/
+			ATBMWrite(0x01, 0x0c, 0x01);
+		}
+	}
+}
+
+/****************************************************************************
+Function:		ATBMDVBCSetSymbolRate
+Parameters:     ui32OscFreq: OSC sampling frequency, in KHz
+                ui32SymbolRateM, symbol rate, in Ksbps
+Return: 		None
+Description:
+	Call this function to configure all DVB-C  symbol rate related registers.
+******************************************************************************/
+void ATBMDVBCSetSymbolRate(uint32 ui32OscFreq, uint32 ui32SymbolRateM)
+{
+	uint32  ui32Log2DecFactor;
+	uint32	ui32DecCicOutputShift;
+	uint32	ui32AfcSlowControlTC;
+	uint32	ui32TrlSampleRate;
+	uint32	ui32TrlSampleRateRecip;
+// 	uint32  ui32CicDcGain;
+
+	// Calculate factor by which decimation filter must reduce rate
+// 	ui32Log2DecFactor = (uint32)(floor(log10(((dbCMS0022MaxSymbolRateRatio*dbOscFreq)/dbSymbolRateM))/log10(2.0)));
+	ui32Log2DecFactor = (Log10Convert(ui32OscFreq)-Log10Convert(4)-Log10Convert(ui32SymbolRateM))/Log10Convert(2);
+	// Samples per symbol
+	if(ui32Log2DecFactor > 3)
+	{
+		ui32Log2DecFactor=3;
+	}
+//  	ui32TrlSampleRate = ((1<<16)*2/(dbSmpsPerSymb/(1<<ui32Log2DecFactor)));
+	ui32TrlSampleRate = 131072*FixPow(2,ui32Log2DecFactor)*ui32SymbolRateM/ui32OscFreq;
+	ATBMDVBCWrite(DVBC_SAMPLE_RATE_ADDR, ui32TrlSampleRate);
+
+//  ui32TrlSampleRateRecip = (int)(((1<<11)*(dbSmpsPerSymb/(1<<ui32Log2DecFactor))/2));
+	ui32TrlSampleRateRecip = 1024*FixPow(2,ui32Log2DecFactor)*ui32OscFreq/ui32SymbolRateM;
+
+
+	if(ui32TrlSampleRateRecip > 0x3fff)
+	{
+		ui32TrlSampleRateRecip = 0x3fff;
+	}
+	ATBMDVBCWrite(DVBC_SAMPLE_RATE_RECIP_ADDR, ui32TrlSampleRateRecip);
+	// Calculate CIC gain
+// 	dbCicDcGain  = pow(2*(1<<(ui32Log2DecFactor-1)),(int)dbCMS0022CIC2DELAY);
+// 	//Calculate CIC gain *=
+// 	dbCicDcGain *= pow(3*(1<<(ui32Log2DecFactor-1)),(int)dbCMS0022CIC3DELAY);
+	ui32DecCicOutputShift = 1;
+
+	if(ui32Log2DecFactor ==1)
+	{
+		ui32DecCicOutputShift = 4;
+	}
+	if(ui32Log2DecFactor == 2)
+	{
+		ui32DecCicOutputShift = 7;
+	}
+	if(ui32Log2DecFactor == 3)
+	{
+		ui32DecCicOutputShift = 10;
+	}
+
+// 	ui32CicDcGain = 1;
+
+// 	ui32DecCicOutputShift = (ui32Log2DecFactor > 0) ? ((uint32)((log10(dbCicDcGain)/log10(2.0))+0.5)+1) : 1;
+// 	ui32DecCicOutputShift = (ui32Log2DecFactor > 0) ? (((Log10Convert(ui32CicDcGain)/Log10Convert(2))+1)) : 1;
+	ATBMDVBCWrite(DVBC_OUTPUT_SHIFT_ADDR, ui32DecCicOutputShift);
+	ATBMDVBCWrite(DVBC_DECIMATION_FACTOR_ADDR,ui32Log2DecFactor);
+	// Program AFC tracking time constant as function of symbol rate
+	ui32AfcSlowControlTC = (1<<(ui32Log2DecFactor+2));
+	ATBMDVBCWrite(DVBC_SLOW_CONTROL_TC_ADDR,ui32AfcSlowControlTC);
+}
+
+/****************************************************************************
+Function:	ATBMDVBCSetCarrier
+Parameters: ui32OscFreq: OSC sampling frequency, 30400, in kHz
+            ui32SymbolRateM, symbol rate.
+Return: 	None
+Description:
+	Call this function to configure DVBC registers according to OSC frequency
+	and symbol rate.
+******************************************************************************/
+void   ATBMDVBCSetCarrier(uint32 ui32OscFreq,uint32 ui32SymbolRateM)
+{
+	int	    i32IfSrchStartFreq;
+	int	    i32IfSrchStepFreq;
+	uint32	ui32TimSearchLockTimeout;
+	uint32	ui32PlCarrierFrequencyRange;
+	uint32	ui32CarrierLockAcquireTimeout;
+	uint32  ui32IfSearchStartFoOvrFsamp;
+	uint32  ui32IfSearchStepFstpOvrFsamp;
+// 	double  dbWinEndFreqMHz = 3*dbSymbolRateM/20;
+
+// 	ui32IfSearchStartFoOvrFsamp = /*dbWinEndFreqMHz*/3*ui32SymbolRateM/ui32OscFreq/20;
+	ui32IfSearchStartFoOvrFsamp = /*dbWinEndFreqMHz*/393216*ui32SymbolRateM/(ui32OscFreq/5);
+	if(ui32SymbolRateM != 0)
+	{
+// 		ui32IfSearchStepFstpOvrFsamp = ui32SymbolRateM*5/ui32OscFreq/100;
+		ui32IfSearchStepFstpOvrFsamp = 131072*ui32SymbolRateM/(ui32OscFreq/5);
+	}
+	else
+	{
+		ui32IfSearchStepFstpOvrFsamp = 0;
+	}
+// 	i32IfSrchStartFreq = (int)(((dbIfSearchStartFoOvrFsamp)*(1<<27))+0.5);
+	i32IfSrchStartFreq = ui32IfSearchStartFoOvrFsamp*1024/100;
+
+	ATBMDVBCWrite(DVBC_SEARCH_RANGE_ADDR,i32IfSrchStartFreq);
+
+	i32IfSrchStepFreq = ui32IfSearchStepFstpOvrFsamp*1024/100;
+	ATBMDVBCWrite(DVBC_SEARCH_STEP_ADDR,i32IfSrchStepFreq);
+	// Program parameters for fine stepped carrier search
+	// Step size
+	ui32TimSearchLockTimeout = 20;	// 20 for 1% step;
+	ATBMDVBCWrite(DVBC_PL_CARRIER_STEP_FREQUENCY_ADDR,ui32TimSearchLockTimeout);
+	// Search range
+	ui32PlCarrierFrequencyRange = 39;// 39 for +/-15% limits
+	ATBMDVBCWrite(DVBC_PL_CARRIER_FREQUENCY_RANGE_ADDR,ui32PlCarrierFrequencyRange);
+	// Standard times and thresholds for all other QAM levels
+	ui32CarrierLockAcquireTimeout = 4;
+	ATBMDVBCWrite(DVBC_CARRIER_LOCK_ACQUIRE_TIMEOUT_ADDR, ui32CarrierLockAcquireTimeout);
+
+}
+
+/****************************************************************************
+Function:	ATBMDVBCSetQAM
+Parameters: none
+Return: 	None
+Description:Call this function to configure DVBC QAM related registers:
+******************************************************************************/
+void ATBMDVBCSetQAM()
+{
+	int	i32BitSyncDetectTimeout;
+	ATBMDVBCWrite(DVBC_AUTO_EQU_SEARCH_ADDR,0x3f8); //Auto QAM detect
+	i32BitSyncDetectTimeout = 60000/(256*16);
+	ATBMDVBCWrite(DVBC_BITSYNC_DETECT_TIMEOUT_ADDR,i32BitSyncDetectTimeout);
+}
+
+void   ATBMSetConfigParas(custom_config_t stCustomConfigp)
+{
+	stCustomConfig = stCustomConfigp;
+}
+
+/****************************************************************************
+Function:     ATBMInit
+Parameters:   none
+Return:       none
+Description:
+    Initializes ATBM887X demodulator and configures all necessary registers.
+    The demodulator will start processing incoming data after this function is called.
+******************************************************************************/
+void ATBMInit()
+{
+	uint8 ui8ATBMChipID;
+	Delayms(1);/*1 ms*/
+	ATBMWrite(0x01, 0x0c, 0x01);//i2c clock using PLL, 1:PLL, 0:Crystal.
+	//Delayms(10); /*10 ms*/
+	ATBMWrite(0x00, 0x04, 0x00);
+	ATBMWrite(0x10, 0xf7, 0xe8);
+	ATBMWrite(0x10, 0xfb, 0x07);
+	ui8ATBMChipID = ATBMChipID();
+	if(ui8ATBMChipID == 0x40)
+	{
+		ATBMWriteRegArray(ui8AATBM887XCommonReg,sizeof(ui8AATBM887XCommonReg)/sizeof(unsigned char));
+	}
+	ATBMConfig( stCustomConfig);
+	if(stCustomConfig.ui8DtmbDvbcMode == ATBM_DVBC_MODE)
+	{
+		ATBMWriteRegArray(uiA8DvbcInternal,sizeof(uiA8DvbcInternal)/sizeof(unsigned char));
+
+		if(stCustomConfig.stDvbcParams.ui8InputMode == DVBC_IF_INPUT)
+		{
+			ATBMWrite(0x15, 0x11, 0x01);
+			if(ui8ATBMChipID == 0x40)
+			{
+				ATBMWrite(0x15, 0x12, 0x00);
+			}
+			if(ui8ATBMChipID == 0x30)
+			{
+				ATBMWrite(0x15, 0x12, 0x01);
+			}
+			ATBMWrite(0x00, 0x16, 0x00);
+		}
+		if(stCustomConfig.stDvbcParams.ui8InputMode == DVBC_IQ_INPUT)
+		{
+			ATBMWrite(0x00, 0x16, 0x03);
+		}
+		if(ui8ATBMChipID == 0x40)
+		{
+			ATBMWrite(0x02, 0x52, 0x01);
+			ATBMWriteRegArray(ui8AATBM887XDvbcSet,sizeof(ui8AATBM887XDvbcSet)/sizeof(uint8));
+			if(stCustomConfig.ui32SampleClkFrequency == 24000)
+			{
+				ATBMWriteRegArray(ui8AATBM887XDvbc24MSet,sizeof(ui8AATBM887XDvbc24MSet)/sizeof(uint8));
+			}
+			if(stCustomConfig.ui32SampleClkFrequency == 30400)
+			{
+				ATBMWriteRegArray(ui8ATBM887XDvbc30Dot4MSet,sizeof(ui8ATBM887XDvbc30Dot4MSet)/sizeof(uint8));
+			}
+		}
+		ATBMDVBCInit(stCustomConfig);
+	}
+	else //DTMB mode
+	{
+		ATBMWrite(0x00, 0x0a, 0x01);
+		ATBMWrite(0x00, 0x09, 0x01);
+		ATBMWrite(0x00, 0x13, 0x00); //DTMB mode
+		ATBMWrite(0x15, 0x18, 0x00);
+		ATBMWrite(0x15, 0x15, 0x00);
+		ATBMWrite(0x15, 0x11, 0x00);
+		ATBMWrite(0x15, 0x12, 0x00);
+		if(ui8ATBMChipID == 0x40)
+		{
+			ATBMWrite(0x02, 0x52, 0x00);
+			ATBMWriteRegArray(ui8AATBM887XDtmbSet,sizeof(ui8AATBM887XDtmbSet)/sizeof(unsigned char));
+			if(stCustomConfig.ui32SampleClkFrequency == 24000)
+			{
+				ATBMWriteRegArray(ui8AATBM887XDtmb24MSet,sizeof(ui8AATBM887XDtmb24MSet)/sizeof(unsigned char));
+			}
+			if(stCustomConfig.ui32SampleClkFrequency == 30400)
+			{
+				ATBMWriteRegArray(ui8AATBM887XDtmb30Dot4MSet,sizeof(ui8AATBM887XDtmb30Dot4MSet)/sizeof(unsigned char));
+			}
+		}
+		ATBMWriteRegArray(ui8ADtmbInternal,sizeof(ui8ADtmbInternal)/sizeof(unsigned char));
+		ATBMWriteRegArray(uiAATBMDynamicSetting,sizeof(uiAATBMDynamicSetting)/sizeof(unsigned char));
+	}
+
+	ATBMWrite(0x08,0x00,0xa0);
+	ATBMWrite(0x08,0x01,0x16);
+	ATBMWrite(0x00, 0x04, 1);	// write 1 config done
+
+#if ATMB_DBG_OUTPUT
+	ATBMDebugRegister();
+#endif
+}
+
+/****************************************************************************
+Function:    ATBMConfig
+Parameters:  custom_config
+Return:      none
+
+Description:
+     Set registers according to customer's configuration,
+     This function configures ATBM887X.
+ ******************************************************************************/
+ void ATBMConfig( custom_config_t stCustomConfigp)
+ {
+	 /*Demodulator default clock 30.4MHz; Tuner IF 36.166Mhz*/
+	 ATBMSetOSC(stCustomConfigp.stTunerConfig,stCustomConfigp.ui32SampleClkFrequency);
+	 /*Configures  MPEG TS output  mode*/
+	 ATBMSetTSMode(stCustomConfigp.stTsMode);
+	 ATBMWrite(0x01, 0x02, 1);	 //I2C related
+	 ATBMWrite(0x02, 0x0c, ui8ATBMSoftwareVersion);
+ }
+
+ /****************************************************************************
+Function:    ATBMSetTSMode
+Parameters:  stTSMode
+Return:      none
+Description:
+      This function configures Transport stream interface mode.
+******************************************************************************/
+void ATBMSetTSMode( MPEG_TS_mode_t stTSMode)
+{
+	uint8 ui8ChipID;
+	uint8 ui8SerialEnabled =0x0;/*parallel clock out */
+	uint8 ui8TSOutputEdegeMode = stTSMode.ui8OutputEdge;
+	uint8 ui8TsClockMode = stTSMode.ui8SPIClockConstantOutput;
+
+	/*0x00: SPI data align with rising edge of TSBCLK; 0x01: SPI data align with falling edge of TSBCLK*/
+	ATBMWrite(0x03,0x01, ui8TSOutputEdegeMode);
+	ATBMWrite(0x03,0x06, ui8TsClockMode);  /*either free running or only active when data are valid*/
+	ATBMWrite(0x03,0x11, 0);
+	ATBMRead(0x00,0x00, &ui8ChipID);
+	if(ui8ChipID == 0x40)
+	{
+		ATBMWrite(0x03,0x12, 1);//886x special
+		ATBMWrite(0x0b,0x24, 0x01);
+	}
+	if(stTSMode.ui8TSTransferType==TS_SERIAL_MODE)
+	{
+		ui8SerialEnabled = 0x01;    /*enable serial TS mode */
+
+		//SSI_sync_hold_cycle = 0x00; //0x00:1 bit sync;0x01: 8 bit sync
+		/*0: serial sync  holds 1 cycle; 1: serial sync holds 8 cycles*/
+		//ATBMWrite(0x03,0x0f, SSI_sync_hold_cycle);
+
+		/*0:disable serial mode; 1: enable serial mode */
+		ATBMWrite(0x03,0x05, ui8SerialEnabled);
+		if(stTSMode.ui8TSSSIOutputSelection == TS_SSI_OUTPUT_ON_DATA_BIT0)
+		{
+			ATBMWrite(0x03, 0x1f, 0x00);
+		}else
+		{
+			ATBMWrite(0x03, 0x1f, 0x01);
+		}
+	}
+	else
+	{
+		ui8SerialEnabled =0x0; /*parallel clock output */
+		/*0: disable serial mode; 1:enable serial mode */
+		ATBMWrite(0x03,0x05, ui8SerialEnabled);
+		if(stTSMode.ui8TSSPIMSBSelection == TS_SPI_MSB_ON_DATA_BIT7)
+		{
+			ATBMWrite(0x03, 0x1f, 0x00);
+		}else
+		{
+			ATBMWrite(0x03, 0x1f, 0x01);
+		}
+	}
+}
+
+/****************************************************************************
+Function:    ATBMSetOSC
+Parameters:  stTunerConfig, ui32SampleClkFrequency
+Return:      1 for success,0 for error
+Description:
+     This function configures ATBM887X according to external Clock source
+     and  Tuner IF frequency.
+ ******************************************************************************/
+int ATBMSetOSC( tuner_config_t stTunerConfig, uint32 ui32SampleClkFrequency)
+{
+	/*Demodulator default registers are for 30.4 MHz crystal, no need to list here.*/
+	uint8  ui8ARXFLT[6];
+	uint8  ui8BandWidth;
+	uint8  ui8SwapIQ;
+	uint8  ui8ARge[3], ui8ChipID;
+	uint8 ui8Tmp;
+	uint16 ui16ParamsFSADC, ui16ParamsIFFreq;
+	uint32 ui32ParamsFSADCInverse;
+	uint32    u32FreqLifTmp, u32tempValue;
+	uint32    u32RateRatioTmp;
+	ATBM64Data u64Data0, u64Data1;
+	uint32 ui32TunerIFFrequency = stTunerConfig.ui32IFFrequency/10;
+	uint32 ui32CLKFreq = ui32SampleClkFrequency/10;//0.1MHz origin is MHz
+	uint32 ui32CLKFreqKHz = ui32SampleClkFrequency;
+	uint32 ui32TunerIFFrequencyKHz = stTunerConfig.ui32IFFrequency;
+	ATBMRead(0x00,0x00, &ui8ChipID);
+	if(stTunerConfig.ui8IQmode == SWAP_IQ)
+	{
+		ui8SwapIQ = 0x03;
+		ATBMWrite(0x0c,0x01, ui8SwapIQ);
+		ui8gIQInitValue = ui8SwapIQ;
+	}
+	else
+	{
+		ATBMWrite(0x0c,0x01, 0x01);
+		ui8gIQInitValue = 0x01;
+	}
+	/* 0x0A03~0x0A05 are only related to sampling frequency;
+	* 0x0A00~0x0A02 are related to sampling frequency and tuner IF frequency.*/
+
+
+
+	if(ui32TunerIFFrequency>ui32CLKFreq)
+	{
+	//	i32FreqLifTmp=(26353589*(ui32TunerIFFrequency-ui32CLKFreq)/ui32CLKFreqKHz);
+		//u64Data0.ui32Low = 26353589;
+        u32tempValue = ui32TunerIFFrequencyKHz-ui32CLKFreqKHz;
+		ATBM64Mult(&u64Data1 ,26353589, u32tempValue);
+		ATBM64Mult(&u64Data0, ui32CLKFreqKHz, 1);
+		u32FreqLifTmp = ATBM64Div(u64Data1,u64Data0);
+	}
+	else //low IF
+	{
+		//i32FreqLifTmp=(26353589*ui32TunerIFFrequency/ui32CLKFreq);
+		ATBM64Mult(&u64Data1 ,26353589, ui32TunerIFFrequencyKHz);
+		ATBM64Mult(&u64Data0, ui32CLKFreqKHz, 1);
+		u32FreqLifTmp = ATBM64Div(u64Data1,u64Data0);
+	}
+	ui8ARXFLT[0] = (uint8)(u32FreqLifTmp&0xff);
+	ui8ARXFLT[1] = (uint8)((u32FreqLifTmp>>8)&0xff);
+	ui8ARXFLT[2] = (uint8)((u32FreqLifTmp>>16)&0xff);
+
+	ATBMWrite(0x0A,0x00, ui8ARXFLT[0]);
+	ATBMWrite(0x0A,0x01, ui8ARXFLT[1]);
+	ATBMWrite(0x0A,0x02, ui8ARXFLT[2]);
+	//printf("IF freq_lif: 0x%x 0x%x  0x%x\n", ui8ARXFLT[0], ui8ARXFLT[1], ui8ARXFLT[2]);
+
+	ui8BandWidth = stTunerConfig.ui8DTMBBandwithMHz;
+	//i32RateRatioTmp = (4194304*ui32CLKFreq/(ui8BandWidth*152));
+	u32RateRatioTmp = (131072*ui32CLKFreqKHz/(ui8BandWidth*19*25)); //152/8 = 19
+	//i32RateRatioTmp=(int)floor(2*dbCLKFreq*(1<<19)/30.4 + 0.5);
+	ui8ARXFLT[3] = (uint8)(u32RateRatioTmp&0xff);
+	ui8ARXFLT[4] = (uint8)((u32RateRatioTmp>>8)&0xff);
+	ui8ARXFLT[5] = (uint8)((u32RateRatioTmp>>16)&0x1f);
+	ATBMWrite(0x0A,0x03, ui8ARXFLT[3]);
+	ATBMWrite(0x0A,0x04, ui8ARXFLT[4]);
+	ATBMWrite(0x0A,0x05, ui8ARXFLT[5]);
+	//printf("ADC rate ratio: 0x%x 0x%x  0x%x\n", ui8ARXFLT[3], ui8ARXFLT[4], ui8ARXFLT[5]);
+	if(ui32CLKFreq == 2400) //24MHz crystal, register should set here.
+	{
+		ATBMRead(0x06,0x0e,&ui8Tmp);
+		ATBMWrite(0x06,0x0e, ui8Tmp|0x4);
+		if(ui8ChipID == 0x30)
+		{
+			ATBMWrite(0x0a,0xfb,0x02);
+		}
+		if(ui8ChipID == 0x40)
+		{
+			ATBMWrite(0x0a,0xfb,0x01);
+		}
+	}
+	ATBMRead(0x00,0x00, &ui8ChipID);
+	if(ui8ChipID == 0x40)
+	{
+		ui16ParamsFSADC = (uint16)(ui32CLKFreq * 2048/100);
+		ui8ARge[1] = ui16ParamsFSADC/256;
+		ui8ARge[0] = ui16ParamsFSADC&0xff;
+		ATBMWrite(0x02, 0x33, ui8ARge[0]);
+		ATBMWrite(0x02, 0x34, ui8ARge[1]);
+		ui32ParamsFSADCInverse = 209715200/ui32CLKFreq;
+		ui8ARge[0] = (uint8)(ui32ParamsFSADCInverse&0xff);
+		ui8ARge[1] = (uint8)((ui32ParamsFSADCInverse>>8)&0xff);
+		ui8ARge[2] = (uint8)((ui32ParamsFSADCInverse>>16)&0x01);
+		ATBMWrite(0x02, 0x9d, ui8ARge[0]);
+		ATBMWrite(0x02, 0x9e, ui8ARge[1]);
+		//ATBMWrite(0x02, 0x9f, ui8ARge[2]);
+		if(ui32CLKFreq == 2400) //24MHz crystal, register should set here.
+		{
+			ui8ARge[2] = ui8ARge[2]|0x02;
+			ATBMWrite(0x02, 0x9f, ui8ARge[2]);
+		}
+		if(ui32CLKFreq == 3040) //30.4MHz crystal, register should set here.
+		{
+			ATBMWrite(0x02, 0x9f, ui8ARge[2]);
+		}
+		if(ui32TunerIFFrequency > ui32CLKFreq)
+		{
+			ui16ParamsIFFreq = (ui32TunerIFFrequency-ui32CLKFreq)*2048/100;//to mhz
+		}
+		else //low IF
+		{
+			ui16ParamsIFFreq = ui32TunerIFFrequency*2048/100;
+		}
+		ui8ARge[1] = ui16ParamsIFFreq/256;
+		ui8ARge[0] = ui16ParamsIFFreq&0xff;
+		ATBMWrite(0x02, 0x31,  ui8ARge[0]);
+		ATBMWrite(0x02, 0x32,  ui8ARge[1]);
+		if(ui8BandWidth == 8)
+		{
+			ATBMWrite(0x02, 0x51, 0x00);
+		}
+		else if(ui8BandWidth == 7)
+		{
+			ATBMWrite(0x02, 0x51, 0x01);
+		}
+		else if(ui8BandWidth == 6)
+		{
+			ATBMWrite(0x08, 0x44, 0x00);
+			ATBMWrite(0x14, 0x8a, 0x0f);
+			ATBMWrite(0x02, 0x51, 0x02);
+		}else
+		{
+			ATBMWrite(0x02, 0x51, 0x00);
+		}
+		if(ui32CLKFreq == 2400)
+		{
+			ATBMWrite(0x02, 0x90, 0xd0);
+			ATBMWrite(0x02, 0x91, 0x93);
+			ATBMWrite(0x02, 0x92, 0x01);
+		}
+		if(ui32CLKFreq == 3040)
+		{
+			ATBMWrite(0x02, 0x90, 0x00);
+			ATBMWrite(0x02, 0x91, 0xe0);
+			ATBMWrite(0x02, 0x92, 0x01);
+		}
+	}
+	return 1;
+}
+
+/****************************************************************************
+Function:    ATBMGetTPS
+Parameters:  none
+Return:      TPS index
+Description:
+      This function checks signal TPS. The return value is TPS index in GB20600-2006
+ ****************************************************************************/
+uint8 ATBMGetTPS()
+{
+	uint8 ui8TPS;
+    if(ATBM_I2CREADWRITE_OK == ATBMRead(0x0d,0x04,&ui8TPS))
+		return ui8TPS;
+	else
+		return 0xff;
+}
+
+
+/****************************************************************************
+Function:    ATBMDebugRegister
+Parameters:  none
+Return:      none
+Description:
+      This function checks Demodulator registers,  used for debug purpose
+ ****************************************************************************/
+void ATBMDebugRegister()
+{
+   /*common register*/
+	uint8 ui8SoftwareVersion;
+	uint8  ui8dDmodState;
+	uint8  ui8ConfigDone;
+ 	uint8  ui8FreqOffset;
+ 	uint8  ui8SDPReset;
+	uint8  ui8I2CByPassState;
+	uint8  ui8CANTuner;
+	uint8  ui8ARXFLT[6];
+	/*tuner related config*/
+	uint8  ui8ADCConfig;
+	uint8  ui8LNAOnOff;
+	uint8  ui8FatalRst, ui8WeakRst;
+	/*TS interface configuration*/
+	uint8 ui8SamplingEdegeMode;
+	uint8 ui8SerialEnabled;
+	uint8 ui8ClockOutSelect;
+
+	ATBMRead(0x02, 0x0c,&ui8SoftwareVersion);
+	ATBMRead(0x06, 0x07,&ui8dDmodState);
+	ATBMRead(0x00, 0x04,&ui8ConfigDone);
+	ATBMRead(0x00, 0x0A,&ui8SDPReset);
+	printf("Current software version: %d\n", ui8SoftwareVersion);
+	printf("ui8dDmodState:0x%x configure done:0x%x ui8SDPReset:0x%x\n",ui8dDmodState, ui8ConfigDone,ui8SDPReset);
+
+	/*Demod passing I2C commands between host and tuner. 0:disable 1:enable.*/
+	ATBMRead(0x01, 0x03,&ui8I2CByPassState);
+   	ATBMRead(0x00, 0x01,&ui8CANTuner);
+	printf("bypass state:0x%x; Tuner used(silicon tuner=0):0x%x\n", ui8I2CByPassState, ui8CANTuner);
+
+	ATBMRead(0x06, 0x02,&ui8ADCConfig);
+	ATBMRead(0x10, 0x30,&ui8LNAOnOff);
+	printf("tuner ui8ADCConfig: 0x%x; ui8LNAOnOff: 0x%x\n", ui8ADCConfig, ui8LNAOnOff);
+
+   	ATBMRead(0x08, 0x00,&ui8FreqOffset);
+	printf("ui8FreqOffset 0x08_0x00: 0x%x\n", ui8FreqOffset);
+	ATBMRead(0x08, 0x01,&ui8FreqOffset);
+	printf("ui8FreqOffset 0x08_0x01: 0x%x\n", ui8FreqOffset);
+
+	ATBMRead(0x0A, 0x00,&ui8ARXFLT[0]);
+	ATBMRead(0x0A, 0x01,&ui8ARXFLT[1]);
+	ATBMRead(0x0A, 0x02,&ui8ARXFLT[2]);
+	ATBMRead(0x0A, 0x03,&ui8ARXFLT[3]);
+	ATBMRead(0x0A, 0x04,&ui8ARXFLT[4]);
+	ATBMRead(0x0A, 0x05,&ui8ARXFLT[5]);
+	printf("IF freq_lif: 0x%x 0x%x  0x%x\n", ui8ARXFLT[0], ui8ARXFLT[1], ui8ARXFLT[2]);
+	printf("ADC rate ratio: 0x%x 0x%x  0x%x\n", ui8ARXFLT[3], ui8ARXFLT[4], ui8ARXFLT[5]);
+
+	ATBMRead(0x00, 0x09,&ui8FatalRst);
+	ATBMRead(0x00, 0x0a,&ui8WeakRst);
+	printf("DSP reset options ui8FatalRst = 0x%x, ui8WeakRst =  0x%x\n", ui8FatalRst, ui8WeakRst);
+
+	ATBMRead(0x03, 0x01,&ui8SamplingEdegeMode);/*0x00: rising edge TS output; 0x01: falling edge TS output*/
+	ATBMRead(0x03, 0x05,&ui8SerialEnabled);    /*0: disable serial mode; 1: enable serial mode */
+	ATBMRead(0x03, 0x0b,&ui8ClockOutSelect);   /*0: SPI clock output; 1: TS serial clock output */
+
+	printf("TS interface ui8SerialEnabled= %d ui8SamplingEdegeMode =%d, clock select ui8ClockOutSelect%d\n",\
+		ui8SerialEnabled,ui8SamplingEdegeMode, ui8ClockOutSelect);
+}
+
+/****************************************************************************
+Function:    ATBMWriteRegArray
+Parameters:  *ui8ARegTable, i32TableLen
+Return:      none
+Description:
+      This function writes a group of registers to demodulator
+ ****************************************************************************/
+void ATBMWriteRegArray(uint8 *ui8ARegTable, int i32TableLen)
+{
+   int i32Iter;
+   for(i32Iter=0;i32Iter<i32TableLen;i32Iter+=3)
+   {
+         ATBMWrite(ui8ARegTable[i32Iter],ui8ARegTable[i32Iter+1],ui8ARegTable[i32Iter+2]);
+   }
+}
+
+/****************************************************************************
+Function:    ATBMDebugRegArray
+Parameters:  *ui8ARegTable, i32TableLen
+Return:      none
+Description:
+     This function reads a group of registers from demodulator and prints them
+     for debug purposes.
+ ****************************************************************************/
+void ATBMDebugRegArray(uint8 *ui8ARegTable, int i32TableLen)
+{
+   int i32Iter;
+   uint8 ui8RegData;
+   for(i32Iter=0;i32Iter<i32TableLen;i32Iter+=3)
+   {
+        ATBMRead(ui8ARegTable[i32Iter],ui8ARegTable[i32Iter+1],&ui8RegData);
+   }
+}
+
+/****************************************************************************
+Function:   ATBMDVBCWrite
+Parameters: ui32AAddress: Register physical address ;ui32Data:data need to write to the register
+ui32Data - 32bit data
+Return:    I2C write status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+	For DVB-C register write, It is an encapsulated function by calling ATBMTransWrite function.
+******************************************************************************/
+ATBM_I2CREADWRITE_STATUS ATBMDVBCWrite(uint32 ui32AAddress, uint32 ui32Data)
+{
+
+	uint8 ui8AWData[4];
+	uint8 ui8AddrL, ui8AddrH;
+
+
+	ui8AddrL = ui32AAddress&0xff;
+	ui8AddrH = (ui32AAddress>>8)&0xff;
+
+	ui8AWData[0]=ui32Data&0xff,ui8AWData[1]=(ui32Data>>8)&0xff,ui8AWData[2]=(ui32Data>>16)&0xff,ui8AWData[3]=(ui32Data>>24)&0xff;
+
+	//Add mutex lock here if there is multi-thread operation of demodulator's I2C
+	//the following I2C operations will not be interrupted.
+	//**Attention DVBCWriteValue Micro will return if error occurred, if Mutex used, should change DVBCWriteValue as a function
+	DVBCWriteValue(0x15, 0x03, 0x0);
+	DVBCWriteValue(0x15, 0x01, ui8AddrL);
+	DVBCWriteValue(0x15, 0x02, ui8AddrH);
+
+	DVBCWriteValue(0x15, 0x04, ui8AWData[0]);
+	DVBCWriteValue(0x15, 0x05, ui8AWData[1]);
+	DVBCWriteValue(0x15, 0x06, ui8AWData[2]);
+	DVBCWriteValue(0x15, 0x07, ui8AWData[3]);
+
+	DVBCWriteValue(0x15, 0x03, 0x01);
+
+	DVBCWriteValue(0x15, 0x03, 0x0);
+	//Release mutex lock.
+	printf(" %x %x\n", ui32AAddress, ui32Data);
+	return ATBM_I2CREADWRITE_OK;
+}
+
+
+/****************************************************************************
+Function:      ATBMDVBCRead
+Parameters:    ui32AAddress: Register physical address ;ui32pValue:32-bit data read from target register
+Return:        I2C write status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+	For DVB-C register read, It is an encapsulated function by calling
+	ATBMTransWrite and ATBMTransRead functions.
+******************************************************************************/
+ATBM_I2CREADWRITE_STATUS ATBMDVBCRead(uint32  ui32AAddress,uint32 *ui32pValue)
+{
+
+	uint8 ui8RoLatchOn=1,ui8RoLatchOff=0;
+	uint8 ui8Data[4];
+	uint8 ui8AddrL, ui8AddrH;
+	uint32 ui32Ddata;
+	ui8AddrL = ui32AAddress&0xff;
+	ui8AddrH = (ui32AAddress>>8)&0xff;
+
+	//Add mutex lock here if there is multi-thread operation of demodulator's I2C
+	//the following I2C operations will not be interrupted.
+    //**Attention: DVBCWriteValue and DVBCReadValue Micro will return if error occurred, if Mutex used should change the two Micro as a function
+	DVBCWriteValue(0x08, 0x4d, ui8RoLatchOff);
+	DVBCWriteValue(0x15, 0x03, 0x0);
+	DVBCWriteValue(0x15, 0x01, ui8AddrL);
+	DVBCWriteValue(0x15, 0x02, ui8AddrH);
+
+	DVBCWriteValue(0x08, 0x4d, ui8RoLatchOn);
+	DVBCReadValue(0x15, 0x08,&ui8Data[0]);
+	DVBCReadValue(0x15, 0x09,&ui8Data[1]);
+	DVBCReadValue(0x15, 0x0a,&ui8Data[2]);
+	DVBCReadValue(0x15, 0x0b,&ui8Data[3]);
+	DVBCWriteValue(0x08, 0x4d, ui8RoLatchOff);
+
+        //Release mutex lock.
+
+	ui32Ddata = (ui8Data[3]<<24) + (ui8Data[2]<<16) + (ui8Data[1]<<8) +ui8Data[0];
+	*ui32pValue = ui32Ddata;
+	return ATBM_I2CREADWRITE_OK;
+}
+
+/****************************************************************************
+Function:      ATBMCarrierOffset
+Parameters:    none
+Return:        i32CarrierOffset1:(KHz)
+
+Description:
+      This function checks DTMB signal carrier offset on field testing environment.
+      This function is not meant to be used by customers. It's a debug utility to be used by FAEs.
+ ****************************************************************************/
+int ATBMCarrierOffset()
+{
+	uint32 mCarrierOffset;
+	int CarrierOffset;
+	uint8 pbuff[4];
+	uint8 LockValue;
+
+	LockValue =1; /*lock register value*/
+	ATBMWrite(0x08,0x4d, LockValue);
+
+	ATBMRead(0x08, 0x27, &pbuff[0]);//carrier_offset_est[7:0]
+	ATBMRead(0x08, 0x28, &pbuff[1]);//carrier_offset_est[15:8]
+	ATBMRead(0x08, 0x29, &pbuff[2]);//carrier_offset_est[21:16]
+
+	LockValue = 0; /*lock register value*/
+	ATBMWrite(0x08,0x4d, LockValue);
+
+	/*=  carrier offset  =*/
+	if(pbuff[2]&0x80)
+	{
+		mCarrierOffset = (0xffffff+1- (((pbuff[2]&0xff)<<16)+(pbuff[1]<<8)+pbuff[0]))*143/1000;
+		mCarrierOffset = (mCarrierOffset/1000);
+		CarrierOffset = 0 - mCarrierOffset;
+		printf("DTMB signal  Carrier Offset = -%d KHz\n", mCarrierOffset);
+	}
+	else
+	{
+		mCarrierOffset= ((((pbuff[2]&0xff)<<16)+(pbuff[1]<<8)+pbuff[0]))*143/1000;
+		mCarrierOffset = mCarrierOffset/1000;
+		CarrierOffset = mCarrierOffset;
+		printf("DTMB signal Carrier Offset = %d KHz\n", mCarrierOffset);
+	}
+	return CarrierOffset;
+}
+
+
+/****************************************************************************
+Function:      ATBM_DVBC_CarrierOffset
+Parameters:    none
+Return:        DVBC_CarrierOffset(KHz)
+
+Description:
+	This function checks DVB-C signal carrier offset on field testing environment.
+	This function is not meant to be used by customers. It's a debug utility to be used by FAEs.
+****************************************************************************/
+int    ATBMDVBCCarrierOffset()
+{
+	int tmp;
+	int dtmp;
+	uint32 acq_status;
+	int ItbCarFreqOffset_stat,ItbCoarseFrequencyOffset,ChannelCentreFrequency;
+	int DVBC_CarrierOffset;
+	//-------Carrier frequency offset, reg ItbCarFreqOffset_stat---------------
+	ATBMDVBCRead(0x3C0, &tmp); //32bit signed
+	//printf("DVB-C carrier offset 0x3C0 = %d\n", tmp);
+	dtmp = tmp;
+	if(tmp<0)
+		dtmp = -tmp;
+	ItbCarFreqOffset_stat = (dtmp/1000)*(ui32DvbcSymbolRate/10)/53687;//khz
+	if(tmp<0)
+	ItbCarFreqOffset_stat = - ItbCarFreqOffset_stat;
+	//-----ChannelCentreFrequency , reg ItbFrequencyStatus------------------------
+	ATBMDVBCRead(0x11c, &tmp); //27bit signed
+	//printf("DVB-C carrier offset 0x11C= %d\n",tmp);
+
+	tmp = tmp&0x7ffffff;
+	dtmp = tmp;
+	if(tmp&(0x1<<26))
+	{
+		dtmp=-(0x7ffffff-dtmp+1);
+	}
+	if(dtmp<0)
+	{
+		dtmp = -dtmp;
+		ChannelCentreFrequency = (dtmp/100)*(ui32DvbcOscFreq/100)/13422; //khz
+		ChannelCentreFrequency = -ChannelCentreFrequency;
+	}else
+	{
+		ChannelCentreFrequency = (dtmp/100)*(ui32DvbcOscFreq/100)/13422; //khz
+	}
+	//------ItbCoarseFrequencyOffset--------------------------------------------
+	ATBMDVBCRead(0x118, &tmp); //32bit signed
+	dtmp = tmp;
+	if (tmp<0)
+	{
+		dtmp = -tmp;
+	}
+	//printf("DVB-C carrier offset 0x118  = %d\n", tmp);
+	ItbCoarseFrequencyOffset = (dtmp/100)*(ui32DvbcOscFreq/100)/13422; //khz
+	//-----------  calculate overall_CFO -------------
+	if(ChannelCentreFrequency<0)
+	{
+		DVBC_CarrierOffset =  ChannelCentreFrequency  + ItbCoarseFrequencyOffset+ ItbCarFreqOffset_stat;
+	}
+	else
+	{
+		DVBC_CarrierOffset =  ChannelCentreFrequency  - ItbCoarseFrequencyOffset+ ItbCarFreqOffset_stat;
+	}
+	ATBMDVBCRead(0x3d0, &acq_status);
+	if(acq_status&(0x20))
+	{
+		DVBC_CarrierOffset = DVBC_CarrierOffset;
+	}
+	else
+	{
+		DVBC_CarrierOffset = -DVBC_CarrierOffset;
+	}
+	printf("DVB-C signal Carrier Offset = %d KHz\n", DVBC_CarrierOffset);
+	return DVBC_CarrierOffset;
+}
+
+/****************************************************************************
+Function:	ATBM_DVBC_GetSymbolRate
+Parameters:   none
+Return: 	symbol_rate(K symbol/s)
+
+Description:
+    Call this function to Check DVB-C Symbol Rate, valid for DVB-C mode.
+******************************************************************************/
+uint32 ATBMDVBCGetSymbolRate()
+{
+	uint8 mode;
+	uint32 uTrlSampleRate;
+	int uTrlSampleRateError;
+	uint32 uDecLog2DecFactor;
+	int dProgrammedSymbRate;
+	int dOffset;
+	uint32 symbol_rate;
+	ATBMDVBCRead(0x218, &uTrlSampleRateError);
+	ATBMDVBCRead(0x210, &uTrlSampleRate);
+	ATBMDVBCRead(0x124, &uDecLog2DecFactor);
+	ATBMRead(0x00, 0x13,&mode);
+	if((mode != 0x01)||(uTrlSampleRate == 0)) //Not in DVB-C mode or I2C Error
+	{
+		return 0;
+	}
+	dProgrammedSymbRate = (ui32DvbcOscFreq*uTrlSampleRate+ ((1<<(uDecLog2DecFactor+1))*(1<<15)))/((1<<(uDecLog2DecFactor+1))*(1<<16));
+	if(dProgrammedSymbRate == 0)
+	{
+		dProgrammedSymbRate = dProgrammedSymbRate +1;
+	}
+	dOffset = ((uTrlSampleRateError/137439)*ui32DvbcOscFreq)/(dProgrammedSymbRate *(1<<uDecLog2DecFactor));
+	symbol_rate = dProgrammedSymbRate;
+	if(dOffset>=0)
+	{
+		symbol_rate = symbol_rate + (symbol_rate*dOffset + 500000) /1000000;
+	}
+	else
+	{
+		symbol_rate = symbol_rate + (symbol_rate*dOffset - 500000) /1000000;
+	}
+	printf("dProgrammedSymbRate = %d, symbol rate = %d K\n", dProgrammedSymbRate, symbol_rate);
+	return symbol_rate;
+}
+
+int ATBM_PPM_Test()
+{
+	uint8  ui8APhiAdj[2];
+	uint8  ui8ASCPPM[2];
+	uint8  ui8ALCPPM[2];
+	uint8  ui8pABuffTmp[4];
+	uint8  ui8LockValue;
+	uint8  ui8HeaderMode;
+	uint32 ui32Bias = 0;
+	uint32 ui32AcqRateFrac, ui32AcqRateFracCurr;
+	int    i32OffsetPPM;
+
+	ui8LockValue =1; /*lock register value*/
+	ATBMWrite(0x08, 0x4d, ui8LockValue);
+	ATBMRead(0x08, 0x39,&ui8APhiAdj[0]);//ui8APhiAdj[7:0]
+	ATBMRead(0x08, 0x3a,&ui8APhiAdj[1]);//ui8APhiAdj[13:8]
+	ATBMRead(0x08, 0x5B,&ui8ASCPPM[0]);
+	ATBMRead(0x08, 0x5C,&ui8ASCPPM[1]);
+	ATBMRead(0x08, 0x85,&ui8ALCPPM[0]);
+	ATBMRead(0x08, 0x86,&ui8ALCPPM[1]);
+	ATBMRead(0x08, 0x00,&ui8pABuffTmp[0]);//ui32AcqRateFrac[7:0]
+	ATBMRead(0x08, 0x01,&ui8pABuffTmp[1]);//ui32AcqRateFrac[12:8]
+
+	ui8LockValue = 0; /*cancel the lock*/
+	ATBMWrite(0x08,0x4d, ui8LockValue);
+	ui32AcqRateFrac = (ui8pABuffTmp[1]*256)+ui8pABuffTmp[0];
+	ui32AcqRateFracCurr = ui32AcqRateFrac;
+	ATBMRead(0x08,0x2d,&ui8HeaderMode);
+	if(ui8APhiAdj[1]&(0x20)) // sign bit, negative
+	{
+		//ui32Bias= (0xfff+1- (((ui8APhiAdj[1]&0x3f)*256)+ ui8APhiAdj[0]))*1000000/8388608;//power(2,23)
+		ui32Bias= (0x3fff+1- (((ui8APhiAdj[1]&0x3f)*256)+ ui8APhiAdj[0]))*1192/10000;//power(2,23)
+		ui32AcqRateFrac = ui32AcqRateFrac -ui32Bias;
+	}else
+	{
+		ui32Bias = ((((ui8APhiAdj[1]&0x3f)*256)+ ui8APhiAdj[0]))*1192/10000;
+		ui32AcqRateFrac = ui32AcqRateFrac + ui32Bias;
+	}
+	if((ui8HeaderMode&0x3)==2) //single-carrier mode
+	{
+		if(ui8ASCPPM[1]&(0x01))//sign bit, negative
+		{
+			//      ui32Bias =(0x1ff+1-(((ui8ASCPPM[1]&0x01)*256)+ ui8ASCPPM[0]))*1000000/262144;//power(2,18)
+			ui32Bias =(0x1ff+1-(((ui8ASCPPM[1]&0x01)*256)+ ui8ASCPPM[0]))*38/10;//power(2,18)
+			ui32AcqRateFrac = ui32AcqRateFrac - ui32Bias;
+			ui8pABuffTmp[3]= (ui32AcqRateFrac>>8)&0xff;
+			ui8pABuffTmp[2]= ui32AcqRateFrac&0xff;
+		}
+		else{
+			ui32Bias =((( ui8ASCPPM[1]&0x01)*256)+ ui8ASCPPM[0])*38/10;
+			ui32AcqRateFrac = ui32AcqRateFrac + ui32Bias;
+			ui8pABuffTmp[3]= (ui32AcqRateFrac>>8)&0xff;
+			ui8pABuffTmp[2]= ui32AcqRateFrac&0xff;
+		}
+	}
+	//multi-carrier mode: ui8APhiAdj + ui8ALCPPM
+	else if( ((ui8HeaderMode&0x3)==1)||(( ui8HeaderMode&0x3)==3)  )//multi-carrier mode
+	{
+		if(ui8ALCPPM[1]&(0x80))//sign bit
+		{
+			ui32Bias=(0xffff+1- (((ui8ALCPPM[1])*256)+ ui8ALCPPM[0]))*1192/10000;//power(2,23)
+			ui32AcqRateFrac = ui32AcqRateFrac - ui32Bias;
+			ui8pABuffTmp[3]= (ui32AcqRateFrac>>8)&0xff;
+			ui8pABuffTmp[2]= ui32AcqRateFrac&0xff;
+		}
+		else{
+			ui32Bias = ((( ui8ALCPPM[1])*256)+ ui8ALCPPM[0])*1192/10000;
+			ui32AcqRateFrac = ui32AcqRateFrac + ui32Bias;
+			ui8pABuffTmp[3]= (ui32AcqRateFrac>>8)&0xff;
+			ui8pABuffTmp[2]= ui32AcqRateFrac&0xff;
+		}
+
+	}
+	i32OffsetPPM = ui32AcqRateFrac - ui32AcqRateFracCurr;
+	printf("The current sampling frequency offset is about %d ppm\n", i32OffsetPPM);
+	printf("The current values are: [0x0801] = 0x%x [0x0800] = 0x%x\n",ui8pABuffTmp[1],ui8pABuffTmp[0]);
+	printf("The ideal values for minimal offset are: [0x0801] = 0x%x [0x0800]=0x%x\n", ui8pABuffTmp[3], ui8pABuffTmp[2]);
+	return i32OffsetPPM;
+}
+
+void ATBM_GPO_I2CINT_Output(uint8 ui8Level)
+{
+	uint8 ui8GPIOReg;
+	ATBMRead(0x10, 0xf7,&ui8GPIOReg);
+	ui8GPIOReg |= 0x20; //Set bit5, Enable I2CINT output
+	if(ui8Level == 0)
+		ui8GPIOReg &= 0xef; //Clear bit4, I2CINT pin output 0
+	else
+		ui8GPIOReg |= 0x10; //Set bit4, I2CINT pin output 1
+	ATBMWrite(0x10, 0xf7, ui8GPIOReg);
+}
+
+void ATBM_GPO_PWM1_Output(uint8 ui8Level)
+{
+	uint8 ui8GPIOReg;
+	ATBMRead(0x10, 0xf7,&ui8GPIOReg);
+	ui8GPIOReg |= 0x08; //Set bit3,Enable PWM1 output
+	if(ui8Level == 0)
+		ui8GPIOReg &= 0xfb; //clear bit2,PWM1 pin output 0
+	else
+		ui8GPIOReg |= 0x04; //set bit2,PWM1 pin output 1
+	ATBMWrite(0x10, 0xf7, ui8GPIOReg);
+}
+
+void ATBM_GPO_TestIO23_Output(uint8 ui8Level)
+{
+	uint8 ui8GPOReg;
+	uint8 ui8Data;
+	ATBMRead(0x10, 0xf7,&ui8GPOReg);
+	ATBMRead(0x10, 0xfb,&ui8Data);
+	ui8GPOReg |= 0x80; //Set bit7,Enable TestIO23 output
+	ui8Data|= 0x04; //set bit2
+	if(ui8Level == 0)
+	{
+		ui8Data&=0xef; //clear bit4, this bit is output level
+	}
+	else
+	{
+		ui8Data|= 0x10; //set bit4 as High level
+	}
+	ATBMWrite(0x10, 0xfb, ui8Data);
+	ATBMWrite(0x10, 0xf7, ui8GPOReg);
+}
+
+/****************************************************************************
+Function:    ATBM_TestIO23_Indicate_TS_Lock
+Parameters: none
+Return:      none
+Description:
+    Enable lock indicator output on testIO23 when TS lock detected.
+****************************************************************************/
+void ATBM_TestIO23_Indicate_TS_Lock()
+{
+     uint8 ui8GPOReg;
+     uint8 ui8Data;
+     ATBMRead(0x10, 0xf7,&ui8GPOReg);
+     ATBMRead(0x10, 0xfb,&ui8Data);
+     ui8GPOReg|= 0x80; //set bit7
+     ui8Data&=0xfb;  //clear bit2
+     ATBMWrite(0x10, 0xfb, ui8Data);
+     ATBMWrite(0x10, 0xf7, ui8GPOReg);
+     ATBMWrite(0x00, 0x1a, 0x00); //TestIO23 using TS lock.
+}
+
+/****************************************************************************
+Function:    ATBM_TestIO23_Indicate_FEC_No_Error
+Parameters:  none
+Return:      none
+Description:
+    TestIO23 auto output high only when FEC no Error occurred.
+    Strict on lock indicator, if FEC error occurred, lock indicator will be off.
+    Lock indicator will be on only if not FEC error occurred
+****************************************************************************/
+void ATBM_TestIO23_Indicate_FEC_No_Error()
+{
+     uint8 ui8LockUseErrorInv;
+     ui8LockUseErrorInv = 0x01;
+     ATBM_TestIO23_Indicate_TS_Lock();          //enable TestIO23 normal output
+     ATBMWrite(0x00, 0x1a, ui8LockUseErrorInv); //TestIO23 using FEC no error
+}
+
+void ATBM_GPO_TestIO20_Output(uint8 ui8Level)
+{
+	uint8 ui8GPOReg;
+	uint8 ui8Data;
+	ATBMRead(0x10, 0xf7,&ui8GPOReg);
+	ATBMRead(0x10, 0xfb,&ui8Data);
+	ui8GPOReg |= 0x40; //Set bit6,Enable TestIO20 output
+	ui8Data|=0x02; //set bit1 enable
+	if(ui8Level == 0)
+	{
+		ui8Data&=0xf7; //clear bit3
+	}
+	else
+	{
+		ui8Data|=0x08; //set bit3 output 1
+	}
+	ATBMWrite(0x10, 0xfb, ui8Data);
+	ATBMWrite(0x10, 0xf7, ui8GPOReg);
+}
+
+/****************************************************************************
+Function:    ATBM_TestIO20_Indicate_FEC_Error
+Parameters: none
+Return:      none
+Description:
+     Enable error indicator output on testIO20 when FEC error detected.
+****************************************************************************/
+void ATBM_TestIO20_Indicate_FEC_Error()
+{
+     uint8 ui8GPOReg;
+     uint8 ui8Data;
+     ATBMRead(0x10, 0xf7,&ui8GPOReg);
+     ATBMRead(0x10, 0xfb,&ui8Data);
+     ui8GPOReg|= 0x40; //set bit6
+     ui8Data&=0xfd;  //clear bit1
+     ATBMWrite(0x10, 0xfb, ui8Data);
+     ATBMWrite(0x10, 0xf7, ui8GPOReg);
+     ATBMWrite(0x00, 0x1b, 0x00 );    //TestIO20 using FEC error
+}
+
+/****************************************************************************
+Function:    ATBM_TestIO20_Indicate_TS_Unlock
+Parameters:  none
+Return:      none
+Description:
+    Strict on Error indicator, if lock occurred (TS sync is true),
+    error indicator will be off.
+    error indicator will be on when TS sync is not checked.
+****************************************************************************/
+void ATBM_TestIO20_Indicate_TS_Unlock()
+{
+     uint8 ui8ErrorUseLockInv;
+     ui8ErrorUseLockInv = 0x01;
+     ATBM_TestIO20_Indicate_FEC_Error(); //enable TestIO20 normal output error
+     ATBMWrite(0x00, 0x1b, ui8ErrorUseLockInv); //using TS unlock
+}
+
+/****************************************************************************
+Function:    ATBMErrorDurationMillisecond
+Parameters:  ms (0--275 milliseconds)
+Return:      none
+Description:
+  Set error indicator duration time.
+  The default time is 8.6MS (0x800*4.2us), register value is 0x800.
+  The maximum value is 275 milliseconds
+****************************************************************************/
+void ATBMErrorOnDurationMillisecond(int i32MS)
+{
+     int   i32SetValue;
+     uint8 ui8RegHigh, ui8RegLow;
+     i32SetValue = (int)(i32MS*10000/42);
+     ui8RegLow = (uint8)(i32SetValue&0xff);
+     ui8RegHigh = (uint8)(i32SetValue/256);
+     ATBMWrite(0x15, 0x2b, ui8RegLow);
+     ATBMWrite(0x15, 0x2c, ui8RegHigh);
+}
+/****************************************************************************
+Function:    ATBMLockOffDurationMillisecond
+Parameters:  ms (0--1100 milliseconds)
+Return:      none
+Description:
+  Set lock indicator off Duration time after unlocked.
+  The default time is 34.4ms:(0x800*16.8us), register value is 0x800.
+  The maximum value is 1100 milliseconds
+****************************************************************************/
+void ATBMLockOffDurationMillisecond(int i32MS)
+{
+     int i32SetValue;
+     uint8 ui8RegHigh, ui8RegLow;
+     i32SetValue = (int)(i32MS*10000/168);
+     ui8RegLow = (uint8)(i32SetValue&0xff);
+     ui8RegHigh = (uint8)(i32SetValue/256);
+     ATBMWrite(0x03, 0x19, ui8RegLow);
+     ATBMWrite(0x03, 0x1a, ui8RegHigh);
+}
+
+/****************************************************************************
+Function:    ATBM_GetGuradInterval
+Parameters:  none
+Return:      gi_interval
+
+Description:
+   Function to get guard interval from TPS value: 420 595, 945
+****************************************************************************/
+DTMB_GUARD_INTERVAL  ATBM_GetGuradInterval()
+{
+	uint8 pn_value,PN;
+	DTMB_GUARD_INTERVAL gi_interval;
+	ATBMRead(0x08, 0x2d,&pn_value);
+	PN = (uint8)(pn_value&0x03);
+	// check Guard interval
+	if(PN == 2)
+	{
+		gi_interval = GI_595;
+	}
+	else if(PN == 1)
+	{
+
+		gi_interval = GI_420;
+	}
+	else if(PN == 3)
+	{
+
+		gi_interval= GI_945;
+	}
+	else
+	{
+		gi_interval = GI_UNKNOWN;
+	}
+	return gi_interval;
+}
+
+/****************************************************************************
+Function:    ATBM_GetQamIndex
+Parameters:  none
+Return:      code_rate
+
+Description:
+   Function to get QAM from TPS value
+   4QAM-NR, 4QAM, 16QAM, 32QAM, 64QAM
+****************************************************************************/
+DTMB_QAM_INDEX  ATBM_GetQamIndex()
+{
+	uint8 tps_code;
+	DTMB_QAM_INDEX qam_index;
+	ATBMRead(0x0d, 0x04,&tps_code);
+	if((tps_code>24)||(tps_code<3))
+	{
+		qam_index =DTMB_QAM_UNKNOWN;
+		return qam_index;
+	}
+	if(tps_code<=4)
+	{
+		qam_index = DTMB_QAM_4QAM_NR;
+	}
+	else if(tps_code<=10)
+	{
+		qam_index = DTMB_QAM_4QAM;;
+	}
+	else if(tps_code<=16)
+	{
+		qam_index = DTMB_QAM_16QAM;
+	}
+	else if(tps_code<=18)
+	{
+		qam_index = DTMB_QAM_32QAM;
+	}
+	else if(tps_code<=24)
+	{
+		qam_index = DTMB_QAM_64QAM;
+	}
+	else
+	{
+		qam_index = DTMB_QAM_UNKNOWN;
+	}
+	return qam_index;
+}
+
+/****************************************************************************
+Function:    ATBM_GetCodeRate
+Parameters:  none
+Return:      code_rate
+
+Description:
+   Function to get FEC code rate from TPS value: 0.4, 0.6, 0.8
+****************************************************************************/
+DTMB_CODE_RATE  ATBM_GetCodeRate()
+{
+	uint8 tps_code;
+	DTMB_CODE_RATE code_rate;
+	ATBMRead(0x0d, 0x04,&tps_code);
+	if((tps_code>24)||(tps_code<3))
+	{
+		code_rate = DTMB_CODE_RATE_UNKNOWN;
+		return code_rate;
+	}
+	if((tps_code == 5)||(tps_code == 6))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_4;
+	}
+	else if ((tps_code == 11)||(tps_code == 12))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_4;
+	}
+	else if((tps_code == 19)||(tps_code == 20))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_4;
+	}
+	else if((tps_code == 7)||(tps_code == 8))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_6;
+	}
+	else if((tps_code == 13)||(tps_code == 14))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_6;
+	}
+	else if((tps_code == 21)||(tps_code == 22))
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_6;
+	}
+	else
+	{
+		code_rate = DTMB_CODE_RATE_0_DOT_8;
+	}
+	return code_rate;
+}
+
+/****************************************************************************
+Function:    ATBM_GetInterleavingMode
+Parameters:  none
+Return:      time_interleave
+
+Description:
+Function to get Time interleaving mode from TPS value: 240 or 720
+****************************************************************************/
+DTMB_TIME_INTERLEAVE  ATBM_GetInterleavingMode()
+{
+	uint8 tps_code;
+	DTMB_TIME_INTERLEAVE time_interleave = DTMB_TIME_INTERLEAVER_UNKNOWN;
+	ATBMRead(0x0d, 0x04,&tps_code);
+
+	if((tps_code>24)||(tps_code<3))
+	{
+		time_interleave = DTMB_TIME_INTERLEAVER_UNKNOWN;
+		return time_interleave;
+	}
+	if((tps_code%2) == 0)
+	{
+		time_interleave = DTMB_TIME_INTERLEAVER_720;
+	}
+	if((tps_code%2) != 0)
+	{
+		time_interleave = DTMB_TIME_INTERLEAVER_240;
+	}
+	return  time_interleave;
+}
+
+/****************************************************************************
+Function:    ATBM_GetCarrierMode
+Parameters:  none
+Return:      carrier_mode
+
+Description:
+Function to get carrier mode: single carrier or Multi-carrier
+****************************************************************************/
+DTMB_CARRIER_MODE   ATBM_GetCarrierMode()
+{
+	uint8 is_sc;
+	DTMB_CARRIER_MODE carrier_mode;
+	ATBMRead(0x0d, 0x0f,&is_sc);
+	//check carrier mode
+	if(is_sc == 1)
+	{
+		carrier_mode = DTMB_SINGLE_CARRIER;
+	}
+	else if(is_sc == 0)
+	{
+
+		carrier_mode = DTMB_MULTI_CARRIER;
+	}
+	else
+	{
+		carrier_mode = DTMB_CARRIER_UNKNOWN;
+	}
+	return carrier_mode;
+}
+
+/****************************************************************************
+Function:    ATBMGetSignalParameters
+Parameters:  singal_params
+Return:       none
+
+Description:
+API to get all DTMB signal parameters:
+Carrier mode, Constellation QAM index,  FEC code rate, Guard interval
+and time interleaving mode.
+****************************************************************************/
+void ATBMGetSignalParameters(DTMB_SIGNAL_PARAMS *singal_params)
+{
+	singal_params->dtmb_carrier_mode = ATBM_GetCarrierMode();
+
+	singal_params->dtmb_qam_index =  ATBM_GetQamIndex();
+
+	singal_params->dtmb_code_rate = ATBM_GetCodeRate();
+
+	singal_params->dtmb_guard_interval =   ATBM_GetGuradInterval();
+
+	singal_params->dtmb_time_interleave = ATBM_GetInterleavingMode();
+}
+
+/****************************************************************************
+Function:    ATBMGetDTMBBitRate
+Parameters:  none
+Return:       payload
+
+Description:
+API to get DTMB MPEG2 TS payload in unit of Kbps
+****************************************************************************/
+int  ATBMGetDTMBBitRate()
+{
+	DTMB_CODE_RATE code_rate;
+	DTMB_QAM_INDEX qam_index;
+	DTMB_GUARD_INTERVAL gi_interval;
+
+	int payload = 0;
+
+	qam_index =  ATBM_GetQamIndex();
+	code_rate = ATBM_GetCodeRate();
+	gi_interval =   ATBM_GetGuradInterval();
+
+	if(qam_index == DTMB_QAM_4QAM)
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_4)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 5414;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 5198;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 4813;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_6)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 8122;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 7797;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 7219;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 10829;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 10396;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 9626;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else
+		{
+			payload = 0;
+		}
+	}
+	else if (qam_index == DTMB_QAM_16QAM)
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_4)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 10829;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 10396;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 9626;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_6)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 16243;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 15593;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 14438;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 21658;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 20791;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 19251;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else
+		{
+			payload = 0;
+		}
+	}
+	else if (qam_index == DTMB_QAM_64QAM)
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_4)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 16243;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 15593;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 14438;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_6)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 24365;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 23390;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 21658;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 32486;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 31187;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 28877;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}
+		else
+		{
+			payload = 0;
+		}
+	}
+	else if((qam_index == DTMB_QAM_32QAM))
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 27072;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 25989;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 24064;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}else
+		{
+			payload = 0;
+		}
+	}
+	else if((qam_index == DTMB_QAM_4QAM_NR))
+	{
+		if (code_rate == DTMB_CODE_RATE_0_DOT_8)
+		{
+			if(gi_interval == GI_420)
+			{
+				payload = 5414;
+			}
+			else if(gi_interval == GI_595)
+			{
+				payload = 5198;
+			}
+			else if (gi_interval == GI_945)
+			{
+				payload = 4813;
+			}
+			else
+			{
+				payload = 0;
+			}
+		}else
+		{
+			payload = 0;
+		}
+	}
+	else
+	{
+		payload = 0;
+	}
+	if(stCustomConfig.stTunerConfig.ui8DTMBBandwithMHz == 7)
+	{
+         payload = payload*7/8;
+	}
+	if(stCustomConfig.stTunerConfig.ui8DTMBBandwithMHz == 6)
+	{
+         payload = payload*6/8;
+	}
+	return payload;
+}
+
+/*Internal function used by ATBMSetClock64M*/
+void ATBMSetTS_SPIClock64M()
+{
+	unsigned char tmp_data;
+	ATBMRead(0x06, 0x0e, &tmp_data);
+	tmp_data&=0x8f; //clear bit[14:12]
+	tmp_data|=0x60; //set bit[14:12]:110
+	ATBMWrite(0x06, 0x0e, tmp_data);
+}
+
+/*Internal function used by ATBMSetClock64M*/
+void ATBMSetSYS_Clock64M()
+{
+	unsigned char adc_rfv0, adc_rfv1;
+	unsigned char ui8Rst;
+	unsigned char chip_id;
+	ATBMRead(0x00, 0x00, &chip_id);
+
+	ATBMWrite(0x01, 0x0c, 0);
+	Delayms(2);
+	ATBMRead(0x06, 0x0d, &adc_rfv0);
+	adc_rfv0&=0x7f; //clear bit7
+	ATBMRead(0x06, 0x0e, &adc_rfv1);
+	adc_rfv1&=0xf7; //clear bit[11]
+
+	adc_rfv0|=0x80; //set bit[7]:1
+	ATBMWrite(0x06, 0x0d, adc_rfv0);
+	adc_rfv1|=0x08; //set bit[11]:1
+	ATBMWrite(0x06, 0x0e, adc_rfv1);
+    Delayms(2);
+	if((ui32DvbcSymbolRate > 7500)||(ui32DvbcSymbolRate < 1000))
+	{
+		ui32DvbcSymbolRate = 6875;
+	}
+	ui8Rst =(uint8)(6875*16/ui32DvbcSymbolRate);
+	if(chip_id == 0x40)
+	{
+		ATBMWrite(0x15, 0x37, ui8Rst);
+	}
+	ATBMWrite(0x01, 0x0c, 1);
+}
+
+/*Internal function used by ATBMSetClock72M*/
+void ATBMSetTS_SPIClock72M()
+{
+	unsigned char tmp_data;
+	ATBMRead(0x06, 0x0e, &tmp_data);
+	tmp_data&=0x8f; //clear bit[14:12], default is 72M for 24MHz Crystal
+	tmp_data|=0x00;//set bit[14:12]:000
+	ATBMWrite(0x06, 0x0e, tmp_data);
+}
+
+/*Internal function used by ATBMSetClock72M*/
+void ATBMSetSYS_Clock72M()
+{
+	unsigned char adc_rfv0,adc_rfv1;
+	unsigned char ui8Rst;
+	unsigned char chip_id;
+	ATBMRead(0x00, 0x00, &chip_id);
+
+	ATBMWrite(0x01, 0x0c, 0);
+	Delayms(2);
+	ATBMRead(0x06, 0x0e, &adc_rfv1);
+	adc_rfv1&=0xf7; //clear bit[11]
+	ATBMRead(0x06, 0x0d, &adc_rfv0);
+	adc_rfv0&=0x7f; //clear bit7
+
+	adc_rfv0|=0x00;//set bit[7]:0
+	ATBMWrite(0x06, 0x0d, adc_rfv0);
+	adc_rfv1|=0x00;//set bit[11]:0
+	ATBMWrite(0x06, 0x0e, adc_rfv1);
+	Delayms(2);
+	if((ui32DvbcSymbolRate > 7500)||(ui32DvbcSymbolRate < 1000))
+	{
+		ui32DvbcSymbolRate = 6875;
+	}
+	ui8Rst =(uint8)(6875*16/ui32DvbcSymbolRate);
+	if(chip_id == 0x40)
+	{
+		ATBMWrite(0x15, 0x37, ui8Rst);
+	}
+	Delayms(2);
+	ATBMWrite(0x01, 0x0c, 1);
+}
+
+/****************************************************************************
+Function:    ATBMSetClock64M
+Parameters:  none
+Return:      none
+
+Description:
+      Call this function to change TS SPI clock,and sys clock to 64MHz,
+      the default used clock is 72MHz with 24MHz crystal  or oscillator.
+
+	  Valid only for 24MHz crystal or oscillator.
+******************************************************************************/
+void ATBMSetClock64M()
+{
+	ATBMSetTS_SPIClock64M();
+	ATBMSetSYS_Clock64M();
+}
+
+/****************************************************************************
+Function:    ATBMSetClock72M
+Parameters:  none
+Return:      none
+
+Description:
+      Call this function to change TS SPI clock,and sys clock to 72MHz,
+      the default used clock is 72MHz with 24MHz crystal or oscillator.
+
+	  Valid only for 24MHz crystal or oscillator.
+******************************************************************************/
+void ATBMSetClock72M()
+{
+	ATBMSetTS_SPIClock72M();
+	ATBMSetSYS_Clock72M();
+}
+
+/****************************************************************************
+Function:    ATBMRead
+Parameters:  ui8BaseAddr, ui8RegisterAddr, *ui8pValue
+Return:      I2C read status:ATBM_I2CREADWRITE_OK is OK
+Description:
+     ATBM887X demodulator register Reading API, it calls I2CRead.
+****************************************************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMRead(uint8 ui8BaseAddr, uint8 ui8RegisterAddr,uint8 *ui8pValue)
+{
+	uint8 ui8AddrData[2];
+
+	ATBM_I2CREADWRITE_STATUS enumRetval = ATBM_I2CREADWRITE_OK;
+	ui8AddrData[0] = ui8BaseAddr;
+	ui8AddrData[1] = ui8RegisterAddr;
+
+	//Option 1:One step I2C format, please port this function according to I2C format of this function..
+//	enumRetval = I2CReadOneStep(ui8ATBMSlaveAddr, 2, ui8AddrData, 1, ui8pValue);
+
+	//Option 2: two step format, returned status from low level I2C interface
+                    //shoud be processsed here if needed.
+	enumRetval = I2CWrite(ui8ATBMSlaveAddr, ui8AddrData, 2);
+	enumRetval = I2CRead(ui8ATBMSlaveAddr, ui8pValue, 1);
+
+	//Release mutex lock
+   return enumRetval;
+}
+
+/****************************************************************************
+Function:    ATBMWrite
+Parameters:  ui8BaseAddr, ui8RegisterAddr, ui8Data
+Return:      I2C write status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+     ATBM887X demodulator register Writing API, It calls I2C low level interface.
+    ****************************************************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMWrite(uint8 ui8BaseAddr, uint8 ui8RegisterAddr, uint8 ui8Data)
+{
+
+	ATBM_I2CREADWRITE_STATUS enumRetval =  ATBM_I2CREADWRITE_OK ;
+	uint8 i2c_data[2];
+    uint8 reg_data[1];
+
+
+	i2c_data[0] = ui8BaseAddr;
+	i2c_data[1] = ui8RegisterAddr;
+	reg_data[0] = ui8Data;
+
+        //Option l: One step I2C format
+//        enumRetval = I2CWriteWithRestart(ui8ATBMSlaveAddr, 2, i2c_data, 1, reg_data);
+
+	//Option 2: two step format, returned status from low level I2C interface
+                    //should be processed here if needed.
+		//Add mutex lock here if there is multi-thread operation of demodulator's I2C
+	//the following I2C operations will not be interrupted.
+	enumRetval = I2CWrite(ui8ATBMSlaveAddr, i2c_data, 2);
+	enumRetval = I2CWrite(ui8ATBMSlaveAddr, reg_data, 1);
+
+	//Release mutex lock
+#if ATMB_DBG_OUTPUT
+	printf("%x %x %x\n", ui8BaseAddr, ui8RegisterAddr, ui8Data);
+#endif
+	return enumRetval;
+}
+
+/****************************************************************************
+Function:    ATBMTransRead
+Parameters:  ui8BaseAddr, ui8RegisterAddr,ui8pValue
+Return:      I2C read status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+     ATBM887X demodulator register Reading API, This function is used for DVB-C transfer.
+****************************************************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMTransRead(uint8 ui8BaseAddr, uint8 ui8RegisterAddr,uint8 *ui8pValue)
+{
+	ATBM_I2CREADWRITE_STATUS enumRetval =  ATBM_I2CREADWRITE_OK ;
+	uint8 ui8AddrData[2];
+	ui8AddrData[0] = ui8BaseAddr;
+	ui8AddrData[1] = ui8RegisterAddr;
+
+		//Option 1:One step I2C format, please port this function according to I2C format of this function..
+	enumRetval = I2CReadOneStep(ui8ATBMSlaveAddr, 2, ui8AddrData, 1, ui8pValue);
+
+	//Option 2: two step format, returned status from low level I2C interface
+                    //should be processed here if needed.
+	enumRetval = I2CWrite(ui8ATBMSlaveAddr, ui8AddrData, 2);
+	enumRetval = I2CRead(ui8ATBMSlaveAddr, ui8pValue, 1);
+
+	//Release mutex lock
+   return enumRetval;
+
+}
+
+
+/****************************************************************************
+Function:        ATBMTransWrite
+Parameters:  ui8BaseAddr, ui8RegisterAddr, ui8Data
+Return:      I2C write status:ATBM_I2CREADWRITE_OK is OK
+
+Description:
+     ATBM887X demodulator register Writing API, It calls low level I2C interface
+****************************************************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMTransWrite(uint8 ui8BaseAddr, uint8 ui8RegisterAddr, uint8 ui8Data)
+{
+	ATBM_I2CREADWRITE_STATUS enumRetval =  ATBM_I2CREADWRITE_OK ;
+	uint8 i2c_data[2];
+    uint8 reg_data[1];
+
+
+	i2c_data[0] = ui8BaseAddr;
+	i2c_data[1] = ui8RegisterAddr;
+	reg_data[0] = ui8Data;
+
+        //Option l: One step I2C format
+        enumRetval = I2CWriteWithRestart(ui8ATBMSlaveAddr, 2, i2c_data, 1, reg_data);
+
+	//Option 2: two step format, returned status from low level I2C interface
+                    //should be processed here if needed.
+		//Add mutex lock here if there is multi-thread operation of demodulator's I2C
+	//the following I2C operations will not be interrupted.
+	//enumRetval = I2CWrite(ui8ATBMSlaveAddr, i2c_data, 2);
+	//enumRetval = I2CWrite(ui8ATBMSlaveAddr, reg_data, 1);
+
+	//Release mutex lock
+#if ATMB_DBG_OUTPUT
+	printf("%x %x %x\n", ui8BaseAddr, ui8RegisterAddr, ui8Data);
+#endif
+	return enumRetval;
+}
+
+
diff --git a/drivers/amlogic/dvb_tv/atbm887x/atbm887x.h b/drivers/amlogic/dvb_tv/atbm887x/atbm887x.h
new file mode 100755
index 000000000000..4efd2f5329f1
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/atbm887x/atbm887x.h
@@ -0,0 +1,312 @@
+/*****************************************************************************
+Copyright 2012-2020, AltoBeam all rights reserved.
+
+File Name: atbm887x.h
+******************************************************************************/
+#ifndef ATBM887X_H
+#define ATBM887X_H
+
+#define printf printk
+
+/*Common data type redefine for atbm886x.h/c*/
+typedef unsigned char u_int8;
+typedef unsigned short u_int16;
+typedef unsigned int u_int32;
+
+
+typedef unsigned char uint8;
+typedef unsigned short uint16;
+typedef unsigned int   uint32;
+
+
+
+#define ATMB_DBG_OUTPUT   1
+typedef struct st64Data
+{
+	uint32 ui32Low,ui32High;
+}ATBM64Data;
+
+
+/**********************************************************************************************************************************
+*struct MPEG_TS_mode_t
+*@ui8TSTransferType: TS stream transfer type, can be set to parallel(8 bit data bus) or serial(1 bit data bus) mode
+*@Demod output edge: demod will output TS data on this edge of TS stream clock
+*@ui8SPIClockConstantOutput: TS stream clock can be set outputting all the time or only during TS data valid (188 bytes)
+**********************************************************************************************************************************/
+/*****************ui8TSTransferType Option Value***************************/
+#define TS_PARALLEL_MODE             1
+#define TS_SERIAL_MODE               0
+/**********************ui8OutputEdge Option Value***************************/
+#define TS_OUTPUT_FALLING_EDGE       1
+#define TS_OUTPUT_RISING_EDGE        0
+/**********************ui8TSSPIMSBSelection Option Value******************/
+#define TS_SPI_MSB_ON_DATA_BIT7      1
+#define TS_SPI_MSB_ON_DATA_BIT0      0
+/**********************ui8TSSSIOutputSelection Option Value***************/
+#define TS_SSI_OUTPUT_ON_DATA_BIT7   1
+#define TS_SSI_OUTPUT_ON_DATA_BIT0   0
+/**********************ui8SPIClockConstantOutput Option Value*************/
+#define TS_CLOCK_CONST_OUTPUT        1
+#define TS_CLOCK_VALID_OUTPUT        0
+typedef struct MPEG_TS_mode_t
+{
+	uint8 ui8TSTransferType;
+	uint8 ui8OutputEdge;
+	uint8 ui8TSSPIMSBSelection;
+	uint8 ui8TSSSIOutputSelection;
+	uint8 ui8SPIClockConstantOutput;
+}MPEG_TS_mode_t;
+
+/**********************************************************************************************************************************
+*struct DVBC_Params_t
+*i32SymbolRate: typically use 6875K
+*ui8InputMode : for DVBC parameter config
+**********************************************************************************************************************************/
+/**********************ui8InputMode Option Value****************************/
+#define DVBC_IF_INPUT                0
+#define DVBC_IQ_INPUT                1
+typedef struct DVBC_Params_t
+{
+	uint8 ui8InputMode;
+	int	  i32SymbolRate;
+}DVBC_Params_t;
+
+/**********************************************************************************************************************************
+*struct tuner_config_t
+*@dbIFFrequency: tuner IF frequency output in MHz.  Most CAN Tuners' are 36M, 36.166M
+*@or 36.125 MHz (Typical IF used by DVB-C tuners)
+*@ui8IQmode: demod needs to know if IQ is swapped or not on hardware board
+**********************************************************************************************************************************/
+/**********************ui8IQmode Option Value*******************************/
+#define SWAP_IQ                      0
+#define NO_SWAP_IQ                   1
+typedef struct tuner_config_t
+{
+	uint8  ui8IQmode;
+	uint8  ui8DTMBBandwithMHz;/**/
+	uint32 ui32IFFrequency;
+}tuner_config_t;
+
+/**********************************************************************************************************************************
+* struct     custom_config_t
+*@tuner_config: struct of tuner configuration
+*@stTsMode: struct of TS mode
+*@ui8CrystalOrOscillator: demod can use crystal or oscillator
+*@dbSampleClkFrequency: crystal or oscillator frequency on hardware board for demod
+*@ui8DtmbDvbcMode:select receiving mode DTMB or DVB-C for ATBM887x
+*@stDvbcParams: DVB-C parameters
+**********************************************************************************************************************************/
+/**********************ui8CrystalOrOscillator Option Value*****************/
+#define CRYSTAL                      0
+#define OSCILLATOR                   1
+/**********************ui8DtmbDvbcMode Option Value************************/
+#define ATBM_DTMB_MODE               1
+#define ATBM_DVBC_MODE               0
+typedef struct custom_config_t
+{
+	uint8          ui8CrystalOrOscillator;
+	uint8          ui8DtmbDvbcMode;
+	tuner_config_t stTunerConfig;
+	MPEG_TS_mode_t stTsMode;
+	uint32         ui32SampleClkFrequency;
+	DVBC_Params_t  stDvbcParams;
+}custom_config_t;
+
+typedef enum _ATBM_I2CREADWRITE_STATUS
+{
+	ATBM_I2CREADWRITE_OK    =0,
+	ATBM_I2CREADWRITE_ERROR
+}ATBM_I2CREADWRITE_STATUS;
+
+
+
+typedef enum _DTMB_QAM_INDEX
+{
+	DTMB_QAM_UNKNOWN = 0,
+	DTMB_QAM_4QAM_NR,
+	DTMB_QAM_4QAM,
+	DTMB_QAM_16QAM,
+	DTMB_QAM_32QAM,
+	DTMB_QAM_64QAM
+}DTMB_QAM_INDEX;
+
+// Code rate
+typedef enum _DTMB_CODE_RATE
+{
+	DTMB_CODE_RATE_UNKNOWN = 0,
+	DTMB_CODE_RATE_0_DOT_4,
+	DTMB_CODE_RATE_0_DOT_6,
+	DTMB_CODE_RATE_0_DOT_8
+}DTMB_CODE_RATE;
+
+// Time interleaving
+typedef enum _DTMB_TIME_INTERLEAVE
+{
+	DTMB_TIME_INTERLEAVER_UNKNOWN = 0,
+	DTMB_TIME_INTERLEAVER_240,
+	DTMB_TIME_INTERLEAVER_720
+}DTMB_TIME_INTERLEAVE;
+
+//Single carrier or Multi-Carrier
+typedef enum _DTMB_CARRIER_MODE
+{
+	DTMB_CARRIER_UNKNOWN = 0,
+	DTMB_SINGLE_CARRIER,
+	DTMB_MULTI_CARRIER
+}DTMB_CARRIER_MODE;
+
+typedef enum _DTMB_GUARD_INTERVAL
+{
+	GI_UNKNOWN = 0,
+	GI_420,
+	GI_595,
+	GI_945
+}DTMB_GUARD_INTERVAL;
+
+typedef struct STRU_DTMB_SIGNAL_PARAMS
+{
+	DTMB_CARRIER_MODE dtmb_carrier_mode;
+	DTMB_QAM_INDEX dtmb_qam_index;
+	DTMB_CODE_RATE dtmb_code_rate;
+	DTMB_TIME_INTERLEAVE dtmb_time_interleave;
+	DTMB_GUARD_INTERVAL dtmb_guard_interval;
+}DTMB_SIGNAL_PARAMS;
+
+
+/********DTMB and DVB-C common API functions******************************/
+int    ATBMPowerOnInit();
+uint8  ATBMChipID();
+void   ATBMI2CByPassOn();
+void   ATBMI2CByPassOff();
+int    ATBMLockedFlag();
+int    ATBMChannelLockCheck();
+int    ATBMChannelLockCheckForManual();
+void   ATBMHoldDSP();
+void   ATBMStartDSP();
+void   ATBMStandby();
+void   ATBMStandbyWakeUp();
+void   ATBMSuspend();
+
+/****DTMB API Functions***************************************************/
+void   ATBMSetDTMBMode();
+int    ATBMSignalStrength();
+uint32 ATBMSignalNoiseRatio();
+int    ATBMSignalQuality();
+uint32 ATBMFrameErrorRatio();
+uint32 ATBMPreBCHBlockErrorRatio();
+uint32 ATBMBER_Calc();
+int    ATBM_PPM_Test();
+int ATBMCarrierOffset();
+int  ATBMGetDTMBBitRate();
+int ATBMChannelLockCheckforAutoSwap();
+void ATBMGetDTMBIQ(unsigned char *pu8IQState); /*Get IQ state when signal is locked */
+void ATBMSetDTMBIQ(unsigned char u8IQState);  /*Set IQ state*/
+
+/****DVBC API Macro define************************************************/
+#define ATBM_DEBUG_DVBC                           0      /*default no debug output*/
+// #define CMS0022_COARSE_CARRIER_ACQ_SWEEP_STEP    5/100
+#define DVBC_SAMPLE_RATE_ADDR                     0x210
+#define DVBC_SAMPLE_RATE_RECIP_ADDR               0x214
+#define DVBC_OUTPUT_SHIFT_ADDR                    0x128
+#define DVBC_DECIMATION_FACTOR_ADDR               0x124
+#define DVBC_SLOW_CONTROL_TC_ADDR                 0x3BC
+#define DVBC_CARRIER_LOCK_ACQUIRE_TIMEOUT_ADDR    0x348
+#define DVBC_PL_CARRIER_FREQUENCY_RANGE_ADDR      0x38C
+#define DVBC_PL_CARRIER_STEP_FREQUENCY_ADDR       0x388
+#define DVBC_COARSE_FREQUENCY_OFFSET_ADDR         0x118
+#define DVBC_SEARCH_STEP_ADDR                     0x3B0
+#define DVBC_SEARCH_RANGE_ADDR                    0x3B4
+#define DVBC_BITSYNC_DETECT_TIMEOUT_ADDR          0x364
+#define DVBC_AUTO_EQU_SEARCH_ADDR                 0x3CC
+/****DVB-C API Functions*************************************************/
+void   ATBMSetDVBCMode();// this function may be changed later
+int ATBMDVBCSNR();
+uint32 ATBMDVBCBER(int *i32pBerExponent);
+uint32 ATBMDVBCUncorrectablePER(int *i32pPktsExponent);
+uint8  ATBMDVBCGetQAM();
+int    ATBMDVBCSignalStrength();
+uint32 ATBMDVBCGetSymbolRate();
+int ATBMDVBCCarrierOffset();
+
+/*************DVB-C internal functions************************/
+void   ATBMDVBCInit( custom_config_t stCustomConfig);
+void   ATBMDVBCSetSymbolRate(uint32 ui32OSCFreq, uint32 ui32SymbolRateM);
+void   ATBMDVBCSetCarrier(uint32 ui32OSCFreq,uint32 ui32SymbolRateM);
+void   ATBMDVBCSetQAM();
+
+/******************Demodulator Internal functions***********************/
+void   ATBMSetConfigParas(custom_config_t stCustomConfigp);
+void   ATBMInit();
+void   ATBMConfig( custom_config_t stCustomConfig);
+void   ATBMSetTSMode( MPEG_TS_mode_t stTSMode);   /*Default SPI , it can be configured to Serial mode*/
+int    ATBMSetOSC( tuner_config_t stTunerConfig, uint32 ui32SampleClkFrequency);
+uint8  ATBMGetTPS();
+void   ATBMDebugRegister();
+uint8  ATBMCheckDemodStatus();
+int    ATBMReset(uint8 ui8CryOrOsc);
+uint8  ATBMCheckPLLStatus(void);
+/****DTMB I2C interface functions****************************************/
+void   ATBMWriteRegArray(uint8 *ui8ARegTable, int i32TableLen);
+void   ATBMDebugRegArray(uint8 *ui8ARegTable, int i32TableLen);
+ATBM_I2CREADWRITE_STATUS  ATBMRead(uint8 ui8BaseAddr, uint8 ui8RegisterAddr,uint8 *ui8pValue);
+ATBM_I2CREADWRITE_STATUS  ATBMWrite(uint8 ui8BaseAddr, uint8 ui8RegisterAddr, uint8 ui8Data);
+/****DVB-C I2C interface functions***************************************/
+ATBM_I2CREADWRITE_STATUS  ATBMTransRead(uint8 ui8BaseAddr, uint8 ui8RegisterAddr,uint8 *ui8pValue);
+ATBM_I2CREADWRITE_STATUS  ATBMTransWrite(uint8 ui8BaseAddr, uint8 ui8RegisterAddr, uint8 ui8Data);
+ATBM_I2CREADWRITE_STATUS  ATBMDVBCWrite(uint32 ui32AAddress,uint32 ui32Data);
+ATBM_I2CREADWRITE_STATUS  ATBMDVBCRead(uint32 ui32AAddress,uint32 *ui32pValue);
+
+/****General interface functions*****************************************/
+uint32 ATBMPreBCHBlockErrorRatio();
+void   ATBM_GPO_I2CINT_Output(uint8 ui8Level);
+void   ATBM_GPO_PWM1_Output(uint8 ui8Level);
+void   ATBM_GPO_TestIO23_Output(uint8 ui8Level);
+void   ATBM_TestIO23_Indicate_TS_Lock();
+void   ATBM_TestIO23_Indicate_FEC_No_Error();
+void   ATBM_GPO_TestIO20_Output(uint8 ui8Level);
+void   ATBM_TestIO20_Indicate_FEC_Error();
+void   ATBM_TestIO20_Indicate_TS_Unlock();
+void   ATBMErrorOnDurationMillisecond(int i32MS);
+void   ATBMLockOffDurationMillisecond(int i32MS);
+
+
+//API of Getting DTMB signal parameters
+DTMB_GUARD_INTERVAL   ATBM_GetGuradInterval();
+DTMB_QAM_INDEX        ATBM_GetQamIndex();
+DTMB_CODE_RATE        ATBM_GetCodeRate();
+DTMB_TIME_INTERLEAVE  ATBM_GetInterleavingMode();
+DTMB_CARRIER_MODE     ATBM_GetCarrierMode();
+void                  ATBMGetSignalParameters(DTMB_SIGNAL_PARAMS *singal_params);
+
+
+/****extern interface functions******************************************/
+extern void Delayms (int i32MS);
+extern void DemodHardwareReset(void);
+extern ATBM_I2CREADWRITE_STATUS  I2CWrite(uint8 ui8I2CSlaveAddr, uint8 *ui8pData, int i32Length);
+extern ATBM_I2CREADWRITE_STATUS  I2CRead(uint8 ui8I2CSlaveAddr, uint8 *ui8pData, int i32Length);
+extern ATBM_I2CREADWRITE_STATUS  I2CReadOneStep(uint8 ui8I2CSlaveAddr, uint16 addr_length, uint8 *addr_dat,  uint16 data_length, uint8 *reg_dat);
+extern ATBM_I2CREADWRITE_STATUS  I2CWriteWithRestart(uint8 ui8I2CSlaveAddr, uint8 addr_length, uint8 *addr_dat,  uint8 data_length, uint8 *reg_dat);
+
+
+#define DVBCWriteValue(BaseAddr,RegAddr,WriteValue) {\
+   ATBM_I2CREADWRITE_STATUS enumStatus;\
+   enumStatus =ATBMTransWrite(BaseAddr,RegAddr,WriteValue);\
+   if(ATBM_I2CREADWRITE_OK != enumStatus)\
+   {\
+       return enumStatus;\
+   }\
+}
+
+#define DVBCReadValue(BaseAddr,RegAddr,ReadValue) {\
+	ATBM_I2CREADWRITE_STATUS enumStatus;\
+	enumStatus =ATBMTransRead(BaseAddr,RegAddr,ReadValue);\
+	if(ATBM_I2CREADWRITE_OK != enumStatus)\
+{\
+	return enumStatus;\
+}\
+}
+
+//////////////////
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/dvb_tv/atbm887x/atbmfrontend.c b/drivers/amlogic/dvb_tv/atbm887x/atbmfrontend.c
new file mode 100755
index 000000000000..77911b75c237
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/atbm887x/atbmfrontend.c
@@ -0,0 +1,288 @@
+/*****************************************************************
+**
+**  Copyright (C) 2009 Amlogic,Inc.
+**  All rights reserved
+**        Filename : atbmfrontend.c
+**
+**  comment:
+**        Driver for ATBM8869 demodulator
+**  author :
+**	    Shijie.Rong@amlogic
+**  version :
+**	    v1.0	 12/3/13
+*****************************************************************/
+
+/*
+    Driver for atbm8869 demodulator
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+#include <mach/am_regs.h>
+#endif
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include "atbm886x.h"
+#include "../aml_fe.h"
+
+#include <mach/i2c_aml.h>
+#if 1
+#define pr_dbg(args...) printk("ATBM: " args)
+#else
+#define pr_dbg(args...)
+#endif
+static struct mutex atbm_lock;
+
+
+#define pr_error(args...) printk("ATBM: " args)
+struct i2c_adapter *i2c_adap_atbm;
+
+
+static int atbm8869_read_status(struct dvb_frontend *fe, fe_status_t * status)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	unsigned char s=0;
+	mutex_lock(&atbm_lock);
+	s=ATBMLockedFlag();
+	mutex_unlock(&atbm_lock);
+//	printk("s is %d\n",s);
+	if(s==1)
+	{
+		*status = FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC;
+	}
+	else
+	{
+		*status = FE_TIMEDOUT;
+	}
+
+	return  0;
+}
+
+static int atbm8869_read_ber(struct dvb_frontend *fe, u32 * ber)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	mutex_lock(&atbm_lock);
+	*ber=ATBMFrameErrorRatio();
+	mutex_unlock(&atbm_lock);
+	return 0;
+}
+
+#if (defined CONFIG_AM_M6_DEMOD)
+extern int tuner_get_ch_power(struct aml_fe_dev *adap);
+#endif
+static int atbm8869_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	mutex_lock(&atbm_lock);
+#if (defined CONFIG_AM_M6_DEMOD)
+	*strength=256-tuner_get_ch_power(dev);
+#endif
+	mutex_unlock(&atbm_lock);
+	return 0;
+}
+
+static int atbm8869_read_snr(struct dvb_frontend *fe, u16 * snr)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	mutex_lock(&atbm_lock);
+	*snr=ATBMSignalNoiseRatio();
+	mutex_unlock(&atbm_lock);
+	return 0;
+}
+
+static int atbm8869_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)
+{
+	*ucblocks=0;
+	return 0;
+}
+extern int aml_fe_analog_set_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters* params);
+static int atbm8869_set_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int times,error;
+	times=2;
+	printk("atbm8869_set_frontend\n");
+	//The following procedures are to set the tuner's center frequency to switch channel
+
+//	ATBMHoldDSP();
+//	Delayms(5);
+retry:
+
+	mutex_lock(&atbm_lock);
+	aml_fe_analog_set_frontend(fe,p);   //666000Khz  set tuner
+	mutex_unlock(&atbm_lock);
+//	Delayms(50);
+//	ATBMStartDSP();
+	times--;
+	if(ATBMLockedFlag() && times){
+		int lock;
+
+		aml_dmx_start_error_check(afe->ts, fe);
+		msleep(20);
+		error = aml_dmx_stop_error_check(afe->ts, fe);
+		lock  = ATBMLockedFlag();
+		if((error > 200) || !lock){
+			pr_error("amlfe too many error, error count:%d lock statuc:%d, retry\n", error, lock);
+			goto retry;
+		}
+	}
+
+
+	aml_dmx_after_retune(afe->ts, fe);
+	afe->params = *p;
+	msleep(200);
+	return  0;
+}
+
+static int atbm8869_get_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
+{//these content will be writed into eeprom .
+
+	struct aml_fe *afe = fe->demodulator_priv;
+
+	*p = afe->params;
+	return 0;
+}
+
+static int atbm8869_fe_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+	struct dvb_frontend_ops *fe_ops = (struct dvb_frontend_ops*)ops;
+	int ret;
+	pr_dbg("=========================demod init\r\n");
+	fe_ops->info.frequency_min = 51000000;
+	fe_ops->info.frequency_max = 950000000;
+	fe_ops->info.frequency_stepsize = 0;
+	fe_ops->info.frequency_tolerance = 0;
+	fe_ops->info.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS;
+
+	fe_ops->set_frontend = atbm8869_set_frontend;
+	fe_ops->get_frontend = atbm8869_get_frontend;
+	fe_ops->read_status = atbm8869_read_status;
+	fe_ops->read_ber = atbm8869_read_ber;
+	fe_ops->read_signal_strength = atbm8869_read_signal_strength;
+	fe_ops->read_snr = atbm8869_read_snr;
+	fe_ops->read_ucblocks = atbm8869_read_ucblocks;
+	i2c_adap_atbm=dev->i2c_adap;
+	return 0;
+/*	ret=ATBMPowerOnInit();
+	if(ret==-1){
+		pr_dbg("=========================dtmb demod error\r\n");
+		return -1;
+	}
+	ATBMSetDTMBMode();
+	return 0;*/
+}
+
+static int atbm8869_fe_enter_mode(struct aml_fe *fe, int mode)
+{
+	struct aml_fe_dev *dev = fe->dtv_demod;
+	struct m6tv_dtmb_platform_data *patbm_op = NULL;
+
+	patbm_op = (struct m6tv_dtmb_platform_data*)fe->dtv_demod->frontend_opration;
+
+	if(NULL != patbm_op)
+	{
+		if(NULL != patbm_op->atbm_device_reset)
+		{
+			patbm_op->atbm_device_reset();
+		}
+	}
+
+	pr_dbg("=========================atbm8869_fe_enter_modet\r\n");
+
+	ATBMPowerOnInit();
+
+	ATBMSetDTMBMode();
+	msleep(200);
+
+	return 0;
+}
+
+static int atbm8869_fe_resume(struct aml_fe_dev *dev)
+{
+	printk("atbm8869_fe_resume\n");
+	struct m6tv_dtmb_platform_data *patbm_op = NULL;
+	patbm_op = (struct m6tv_dtmb_platform_data*)dev->frontend_opration;
+	if(NULL != patbm_op)
+	{
+		if(NULL != patbm_op->machine_panel_type)
+		{
+			int panelindex = patbm_op->machine_panel_type();
+			if(2 == panelindex)
+				return 0;
+		}
+
+		if(NULL != patbm_op->atbm_device_reset)
+		{
+			patbm_op->atbm_device_reset();
+		}
+	}
+	i2c_adap_atbm=dev->i2c_adap;
+	ATBMPowerOnInit();
+	ATBMSetDTMBMode();
+	return 0;
+
+}
+
+static int atbm8869_fe_suspend(struct aml_fe_dev *dev)
+{
+	return 0;
+}
+
+static struct aml_fe_drv atbm8869_dtv_demod_drv = {
+.id         = AM_DTV_DEMOD_ATBM8869,
+.name       = "Atbm8869",
+.capability = AM_FE_DTMB,
+.get_ops    = atbm8869_fe_get_ops,
+.enter_mode = atbm8869_fe_enter_mode,
+.suspend    = atbm8869_fe_suspend,
+.resume     = atbm8869_fe_resume
+};
+
+static int __init atbmfrontend_init(void)
+{
+	pr_dbg("register atbm8869 demod driver\n");
+	mutex_init(&atbm_lock);
+	return aml_register_fe_drv(AM_DEV_DTV_DEMOD, &atbm8869_dtv_demod_drv);
+}
+
+
+static void __exit atbmfrontend_exit(void)
+{
+	pr_dbg("unregister atbm8869 demod driver\n");
+	mutex_destroy(&atbm_lock);
+	aml_unregister_fe_drv(AM_DEV_DTV_DEMOD, &atbm8869_dtv_demod_drv);
+}
+
+fs_initcall(atbmfrontend_init);
+module_exit(atbmfrontend_exit);
+
+
+MODULE_DESCRIPTION("atbm8869 DTMB Demodulator driver");
+MODULE_AUTHOR("RSJ");
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/amlogic/dvb_tv/cresta/Makefile b/drivers/amlogic/dvb_tv/cresta/Makefile
new file mode 100755
index 000000000000..9627deea5be0
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/cresta/Makefile
@@ -0,0 +1,4 @@
+
+obj-$(CONFIG_AM_CTC703) += ctc703_fe.o
+
+ctc703_fe-objs =ctc703_firmware.o ctc703_func.o ctc703_frontend.o
diff --git a/drivers/amlogic/dvb_tv/cresta/ctc703_firmware.c b/drivers/amlogic/dvb_tv/cresta/ctc703_firmware.c
new file mode 100755
index 000000000000..aa5251f833f2
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/cresta/ctc703_firmware.c
@@ -0,0 +1,1713 @@
+// Copyright (c) 2011, Xceive Product <info@xceive.com>
+//
+// Permission to use, copy, and/or modify this software, only with Xceive ICs,
+// for any
+// purpose with or without fee is hereby granted, provided that the above
+// copyright notice and this permission notice appear in all source code
+// copies.
+//
+// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+//
+//
+// Automatically generated C header file for
+// control of the XC7000 via the i2c interface.
+//
+// Filename : XC7000_firmwares.h
+// Generated : 2012/8/15 W 10:04:09
+// Firmware version : 0.5; Release Number: 16.0
+//
+// (c) 2012, Xceive Product
+//
+
+#ifndef __XC7000_FIRMWARES_H
+#define __XC7000_FIRMWARES_H
+
+
+// ************************************************************
+// *** BASE FIRMWARE FILES
+// *** These declarations are not used directly by user
+// ************************************************************
+
+unsigned char xc7000_fw[16497] = {
+          0x00, 0x00,          /* RESET */
+          0x00, 0x03,          /* Length = 3 bytes */
+          0x00, 0x3D, 0x00,
+          0x80, 0x0A,          /* WAIT 010[ms] */
+          0x00, 0x03,          /* Length = 3 bytes */
+          0x00, 0x02, 0x3D,
+          0x00, 0x03,          /* Length = 3 bytes */
+          0x00, 0x02, 0x1F,
+          0x40, 0x04,          /* Length = 16388 bytes */
+          0x00, 0x28, 0x08, 0xE0, 0xD0, 0x59, 0xF2, 0x08, 0xF2, 0x01,
+          0x08, 0xF9, 0xB2, 0x22, 0xF2, 0x01, 0x08, 0xFC, 0xB2, 0x22,
+          0xF2, 0x01, 0x09, 0x01, 0xB2, 0x22, 0xF2, 0x01, 0x09, 0x31,
+          0xB2, 0x22, 0xF2, 0x01, 0x09, 0x66, 0xB2, 0x22, 0xF2, 0x01,
+          0x09, 0x3C, 0xB2, 0x22, 0xF2, 0x01, 0x09, 0xC9, 0xB2, 0x22,
+          0xF2, 0x01, 0x09, 0xC0, 0xE0, 0x05, 0x17, 0xAB, 0xEA, 0xAB,
+          0xE0, 0x00, 0x15, 0x8E, 0xD2, 0x02, 0xF0, 0x2C, 0xEA, 0xAB,
+          0xD5, 0x80, 0xE0, 0x05, 0x10, 0xDB, 0xDB, 0x25, 0xCB, 0x04,
+          0xD2, 0x00, 0xFB, 0x2C, 0xD1, 0x72, 0xF1, 0x2C, 0xD1, 0xA1,
+          0xC1, 0x06, 0xF1, 0x2C, 0xD5, 0x00, 0xC5, 0x02, 0xE0, 0x05,
+          0x18, 0x32, 0xE0, 0x05, 0x1A, 0x20, 0xF5, 0x01, 0x09, 0x25,
+          0xD1, 0x9B, 0xF6, 0x18, 0xD2, 0x4F, 0x4D, 0xE2, 0xF5, 0x01,
+          0x09, 0x25, 0xF1, 0x2C, 0xE0, 0x05, 0x18, 0x29, 0xE0, 0x05,
+          0x18, 0x5E, 0xE0, 0x05, 0x14, 0xEA, 0xD5, 0x80, 0xE0, 0x05,
+          0x18, 0x32, 0xE0, 0x05, 0x11, 0xF9, 0xC2, 0x20, 0xF2, 0x09,
+          0xE0, 0x05, 0x11, 0xF9, 0xE0, 0x05, 0x0E, 0x81, 0xF5, 0x05,
+          0x09, 0xA0, 0xD2, 0x03, 0xF0, 0x2C, 0xE0, 0x05, 0x1E, 0x59,
+          0xF5, 0x01, 0x09, 0x64, 0xD1, 0x77, 0xF2, 0x18, 0xF2, 0x01,
+          0x09, 0x3C, 0xB2, 0x22, 0xF1, 0x2C, 0xEA, 0xAB, 0xD1, 0x50,
+          0xF3, 0x18, 0xA3, 0x33, 0xD1, 0x3E, 0xF2, 0x18, 0x4E, 0xFE,
+          0xF2, 0x01, 0x09, 0x53, 0xD1, 0x40, 0xD2, 0x02, 0xF1, 0x2C,
+          0xD1, 0x46, 0xF5, 0x18, 0xC2, 0x6A, 0x4D, 0x2D, 0xD1, 0x30,
+          0xF2, 0x18, 0xA2, 0x23, 0x22, 0x25, 0xF1, 0x2C, 0xC2, 0x10,
+          0xF2, 0x09, 0xD2, 0x01, 0x22, 0x32, 0x13, 0x32, 0xD1, 0x50,
+          0xF1, 0x3C, 0xD1, 0xF0, 0x01, 0x13, 0xF2, 0x18, 0xD1, 0x3A,
+          0xF4, 0x18, 0x04, 0x42, 0xD1, 0x3B, 0x84, 0x49, 0x84, 0x48,
+          0xF1, 0x4C, 0xC2, 0x01, 0xF2, 0x09, 0xE8, 0xFC, 0xD2, 0x04,
+          0xF0, 0x2C, 0xE0, 0x05, 0x11, 0xB7, 0xF5, 0x01, 0x09, 0x71,
+          0xB5, 0x52, 0xF5, 0x01, 0x0A, 0xAB, 0xB5, 0x52, 0xF5, 0x01,
+          0x08, 0xFC, 0xE9, 0x3C, 0xD5, 0x20, 0xE0, 0x05, 0x13, 0x06,
+          0xD6, 0x16, 0xD5, 0x14, 0xE0, 0x05, 0x1E, 0xC8, 0xD7, 0x95,
+          0xC7, 0x60, 0xD6, 0x80, 0xC6, 0xE0, 0xD5, 0x2A, 0xC5, 0xE0,
+          0xE0, 0x05, 0x1E, 0xAF, 0xD2, 0x01, 0xD1, 0x3D, 0xC1, 0x03,
+          0xF1, 0x2C, 0xD1, 0x3E, 0xC1, 0x03, 0xF1, 0x2C, 0xD2, 0x06,
+          0xF0, 0x2C, 0xE0, 0x05, 0x15, 0x87, 0xD1, 0x51, 0xD2, 0x05,
+          0x22, 0x52, 0xF1, 0x2C, 0xA2, 0x51, 0xF5, 0x01, 0x09, 0x98,
+          0xD6, 0x00, 0xE0, 0x06, 0x0E, 0x7C, 0xF6, 0x05, 0x09, 0x98,
+          0xD5, 0x02, 0xA5, 0x53, 0xE0, 0x05, 0x15, 0x82, 0xF2, 0x01,
+          0x09, 0xAA, 0xE0, 0x05, 0x14, 0x12, 0xE9, 0xAA, 0xD1, 0x39,
+          0xD2, 0x00, 0xF1, 0x2C, 0xD2, 0x00, 0xD1, 0x5F, 0xF1, 0x2C,
+          0xE0, 0x05, 0x14, 0xCB, 0xD2, 0x07, 0xF0, 0x2C, 0xE0, 0x05,
+          0x15, 0x6F, 0xD2, 0x01, 0xD1, 0x40, 0xF1, 0x2C, 0xE0, 0x05,
+          0x0E, 0x90, 0xA5, 0x59, 0xD6, 0x6A, 0xC6, 0x01, 0xE0, 0x05,
+          0x0E, 0x62, 0xD1, 0x7C, 0xD2, 0x00, 0xF1, 0x2C, 0xD1, 0xA0,
+          0xC1, 0x06, 0xF1, 0x2C, 0xD1, 0xB2, 0xD2, 0x50, 0xF1, 0x2C,
+          0xEA, 0xAB, 0xE0, 0x06, 0x16, 0xA5, 0xE0, 0x06, 0x17, 0x9F,
+          0xE0, 0x06, 0x14, 0xEA, 0xE0, 0x06, 0x18, 0xEE, 0xEA, 0xAB,
+          0xE0, 0x06, 0x14, 0x63, 0xD6, 0x08, 0xD7, 0x30, 0xC7, 0xCC,
+          0xE0, 0x06, 0x1E, 0xCC, 0xE0, 0x06, 0x16, 0xA5, 0xD6, 0x00,
+          0xE0, 0x06, 0x0E, 0x7C, 0xD0, 0xE5, 0x00, 0x06, 0xF2, 0x08,
+          0xC5, 0x03, 0xE0, 0x06, 0x1E, 0x93, 0xB1, 0x78, 0xF1, 0x01,
+          0x09, 0xEB, 0x81, 0x23, 0xA1, 0x1B, 0x11, 0x17, 0xF1, 0x01,
+          0x09, 0xEB, 0xB5, 0x52, 0xF5, 0x05, 0x09, 0xD9, 0xE0, 0x06,
+          0x17, 0x9F, 0xE0, 0x06, 0x14, 0xCB, 0xE9, 0xF7, 0xE0, 0x06,
+          0x17, 0x9F, 0xE0, 0x06, 0x1E, 0xE1, 0xE0, 0x06, 0x15, 0x6F,
+          0xE0, 0x06, 0x14, 0xCB, 0xE0, 0x06, 0x14, 0x20, 0xE0, 0x06,
+          0x16, 0x06, 0xE0, 0x06, 0x0E, 0x90, 0xF6, 0x01, 0x0A, 0x06,
+          0x82, 0x23, 0xC1, 0x0A, 0xF1, 0x09, 0xD0, 0x51, 0xF1, 0x08,
+          0xA2, 0x14, 0x86, 0x13, 0xD7, 0x6A, 0xC7, 0x01, 0xE0, 0x06,
+          0x0E, 0x62, 0xE0, 0x06, 0x14, 0xA9, 0xE0, 0x06, 0x18, 0xEE,
+          0xC1, 0x19, 0xF1, 0x09, 0xE0, 0x06, 0x0E, 0x90, 0xF6, 0x01,
+          0x0A, 0x4E, 0xE0, 0x06, 0x14, 0x63, 0xF5, 0x68, 0xD1, 0xA0,
+          0x4D, 0xD5, 0xF1, 0x05, 0x0A, 0x4E, 0xF6, 0x1C, 0xA6, 0x63,
+          0xF8, 0x68, 0xF6, 0x1C, 0xB6, 0x64, 0xF7, 0x68, 0xF6, 0x1C,
+          0xE0, 0x09, 0x15, 0x87, 0xF9, 0x01, 0x0A, 0x2B, 0xD0, 0x93,
+          0xD1, 0xC2, 0xC1, 0x01, 0xF0, 0x1C, 0xA0, 0x03, 0xD1, 0x20,
+          0xC1, 0x03, 0xF0, 0x1C, 0xEA, 0x4E, 0xF2, 0x05, 0x0A, 0x4E,
+          0xD0, 0x1B, 0xC0, 0x01, 0xD1, 0x3A, 0x5C, 0x81, 0xD1, 0x0D,
+          0x5F, 0xF1, 0x17, 0x7C, 0xF7, 0x05, 0x0A, 0x42, 0xF1, 0x08,
+          0xF1, 0x01, 0x0A, 0x3C, 0xB1, 0x12, 0xF0, 0x1C, 0xEA, 0x4C,
+          0xD0, 0x51, 0xD1, 0x03, 0xF0, 0x1C, 0xE0, 0x06, 0x14, 0xEA,
+          0xEA, 0x4C, 0xD1, 0x03, 0xF0, 0x1C, 0xD0, 0x93, 0xD1, 0xC2,
+          0xC1, 0x01, 0xF0, 0x1C, 0xA0, 0x03, 0xD1, 0x20, 0xC1, 0x03,
+          0xF0, 0x1C, 0xE0, 0x06, 0x14, 0x12, 0xD0, 0xEF, 0xF7, 0x08,
+          0xA7, 0x73, 0xD6, 0x08, 0x4E, 0xEB, 0x27, 0x76, 0xF0, 0x7C,
+          0xF7, 0x05, 0x0A, 0x7F, 0xD0, 0x58, 0xF7, 0x08, 0xD0, 0xB2,
+          0xC0, 0x03, 0xF8, 0x08, 0xD6, 0x22, 0x16, 0x68, 0x87, 0x79,
+          0x87, 0x79, 0x5E, 0xFA, 0xF0, 0x6C, 0xF6, 0x05, 0x0A, 0x66,
+          0xA1, 0x61, 0xEA, 0x7C, 0xD6, 0x01, 0xC6, 0x60, 0xE0, 0x06,
+          0x1E, 0xA1, 0xD7, 0x01, 0x2C, 0x87, 0xD6, 0x06, 0xC6, 0x60,
+          0xE0, 0x06, 0x1E, 0xA1, 0x87, 0x79, 0x87, 0x79, 0xD1, 0x00,
+          0xD8, 0x33, 0x5C, 0x78, 0xF8, 0x01, 0x0A, 0x7C, 0xD8, 0x38,
+          0x5C, 0x78, 0xF8, 0x05, 0x0A, 0x7C, 0xD1, 0x01, 0xD0, 0x3D,
+          0xC0, 0x03, 0xF0, 0x1C, 0xE0, 0x06, 0x1E, 0x59, 0xF6, 0x05,
+          0x0A, 0x9B, 0xE0, 0x06, 0x1E, 0x84, 0xD1, 0xBE, 0xC1, 0x07,
+          0x5D, 0xD6, 0xF1, 0x05, 0x0A, 0x9B, 0xD1, 0x4F, 0xC1, 0x08,
+          0x5D, 0x6D, 0xD0, 0x4C, 0xF1, 0x05, 0x0A, 0x9B, 0xD4, 0x0A,
+          0xF0, 0x4C, 0xE0, 0x06, 0x11, 0xB7, 0xB6, 0x64, 0xF6, 0x01,
+          0x0A, 0xA5, 0xB6, 0x62, 0xF6, 0x01, 0x0A, 0xA3, 0xEA, 0xAB,
+          0xD0, 0x4C, 0xF4, 0x08, 0xB4, 0x42, 0xF0, 0x4C, 0xF4, 0x05,
+          0x0A, 0xAB, 0xD4, 0x14, 0xF0, 0x4C, 0xE0, 0x06, 0x1F, 0x57,
+          0xD1, 0x01, 0xD0, 0x59, 0xF0, 0x1C, 0xD1, 0x00, 0xD0, 0x40,
+          0xF0, 0x1C, 0xF0, 0x0E, 0xE0, 0x00, 0x1E, 0xED, 0xD2, 0x74,
+          0xD3, 0x00, 0xF2, 0x3C, 0xD2, 0xEE, 0xD3, 0x00, 0xF2, 0x3C,
+          0xD2, 0x39, 0xD3, 0x01, 0xF2, 0x3C, 0xE0, 0x02, 0x1E, 0xF3,
+          0xA3, 0x01, 0xF3, 0x01, 0x0B, 0x46, 0xB3, 0x32, 0xF3, 0x01,
+          0x0B, 0x41, 0xB3, 0x32, 0xF3, 0x01, 0x0B, 0x3F, 0xB3, 0x32,
+          0xF3, 0x01, 0x0C, 0x57, 0xB3, 0x32, 0xF3, 0x01, 0x0B, 0xD9,
+          0xB3, 0x32, 0xF3, 0x01, 0x0B, 0x3A, 0xB3, 0x34, 0xF3, 0x01,
+          0x0B, 0xC2, 0xB3, 0x32, 0xF3, 0x01, 0x0C, 0x1C, 0xB3, 0x32,
+          0xF3, 0x01, 0x0C, 0x4B, 0xB3, 0x34, 0xF3, 0x01, 0x0C, 0x23,
+          0xB3, 0x32, 0xF3, 0x01, 0x0C, 0x33, 0xB3, 0x32, 0xF3, 0x01,
+          0x0B, 0xD3, 0xB3, 0x34, 0xF3, 0x01, 0x0C, 0x48, 0xB3, 0x32,
+          0xF3, 0x01, 0x0C, 0x57, 0xB3, 0x34, 0xB3, 0x32, 0xF3, 0x01,
+          0x0C, 0x75, 0xB3, 0x32, 0xF3, 0x01, 0x0C, 0x78, 0xB3, 0x34,
+          0xB3, 0x32, 0xF3, 0x01, 0x0C, 0x7B, 0xB3, 0x32, 0xF3, 0x01,
+          0x0C, 0x7E, 0xB3, 0x34, 0xF3, 0x01, 0x0C, 0x81, 0xB3, 0x32,
+          0xB3, 0x32, 0xB3, 0x32, 0xF3, 0x01, 0x0C, 0x94, 0xB3, 0x32,
+          0xF3, 0x01, 0x0C, 0x9C, 0xB3, 0x32, 0xB3, 0x32, 0xF3, 0x01,
+          0x0C, 0x8B, 0xB3, 0x32, 0xB3, 0x32, 0xB3, 0x32, 0xF3, 0x01,
+          0x0B, 0x9D, 0xD4, 0x00, 0xC4, 0x80, 0x2F, 0xC4, 0xF3, 0x05,
+          0x0B, 0x36, 0x84, 0x45, 0x2F, 0xC4, 0x84, 0x4B, 0x2F, 0xC4,
+          0xF3, 0x05, 0x0B, 0x26, 0x84, 0x43, 0x2F, 0xC4, 0xF3, 0x05,
+          0x0B, 0x2E, 0x84, 0x47, 0x2F, 0xC4, 0xF3, 0x05, 0x0B, 0x1E,
+          0x84, 0x49, 0x2F, 0xC4, 0xD2, 0x80, 0x02, 0x23, 0xF2, 0x1C,
+          0xEC, 0xAB, 0xA4, 0x11, 0xD2, 0x80, 0xF6, 0x28, 0xA2, 0x23,
+          0xF5, 0x28, 0xE0, 0x04, 0x1E, 0xAF, 0xEC, 0xAB, 0xA4, 0x11,
+          0xE0, 0x04, 0x1E, 0xA1, 0xD2, 0x80, 0xF2, 0x6C, 0xA2, 0x23,
+          0xF2, 0x5C, 0xEC, 0xAB, 0xA4, 0x11, 0xD2, 0x80, 0xF6, 0x28,
+          0xA2, 0x23, 0xF5, 0x28, 0xE0, 0x04, 0x1F, 0x36, 0xEC, 0xAB,
+          0x82, 0x06, 0x82, 0x27, 0xF2, 0x1C, 0xEC, 0xAB, 0xD2, 0xC4,
+          0xF2, 0x1C, 0xE0, 0x04, 0x13, 0x44, 0xEC, 0xAB, 0xD2, 0x3D,
+          0xEC, 0x42, 0xD2, 0x3F, 0xD3, 0x00, 0xF2, 0x3C, 0xD2, 0x3C,
+          0xEC, 0x42, 0xF0, 0x1F, 0xD3, 0x03, 0xE0, 0x03, 0x15, 0xFC,
+          0xD2, 0x1C, 0xC2, 0x01, 0xD5, 0xFA, 0xD6, 0x21, 0xF3, 0x28,
+          0xF5, 0x3C, 0xA2, 0x23, 0xA5, 0x53, 0xB6, 0x62, 0xF6, 0x05,
+          0x0B, 0x4E, 0xD4, 0x1A, 0xE0, 0x04, 0x1F, 0x2F, 0xE0, 0x04,
+          0x1F, 0x40, 0xD6, 0x07, 0xB5, 0x52, 0xF5, 0x01, 0x0B, 0x5F,
+          0xD6, 0x00, 0xD4, 0x12, 0xD5, 0x31, 0xE0, 0x04, 0x1F, 0x2F,
+          0xD3, 0x80, 0xD2, 0x56, 0xF2, 0x3C, 0xE0, 0x00, 0x13, 0x16,
+          0xE0, 0x00, 0x11, 0x0D, 0xD4, 0x01, 0xD5, 0x00, 0xE0, 0x04,
+          0x1E, 0xC8, 0xD4, 0x07, 0xD6, 0x00, 0xD5, 0x64, 0xE0, 0x04,
+          0x1F, 0x2F, 0xE0, 0x04, 0x18, 0x6F, 0xE0, 0x04, 0x14, 0xEA,
+          0xE0, 0x04, 0x1F, 0x91, 0xE0, 0x04, 0x1C, 0x62, 0xE0, 0x04,
+          0x19, 0x1C, 0xD6, 0x01, 0xD4, 0x0E, 0xD5, 0x44, 0xE0, 0x04,
+          0x1F, 0x0B, 0xE0, 0x04, 0x14, 0xCB, 0xD4, 0x2B, 0xE0, 0x04,
+          0x1E, 0xC8, 0xD5, 0x15, 0xD4, 0x0E, 0xE0, 0x04, 0x1E, 0xC8,
+          0xE0, 0x04, 0x18, 0x29, 0xD3, 0x61, 0xC3, 0x10, 0xD5, 0xFC,
+          0xF5, 0x3C, 0xE0, 0x04, 0x16, 0x25, 0xE0, 0x04, 0x16, 0x1E,
+          0xD3, 0x02, 0xE0, 0x03, 0x15, 0xFC, 0xD2, 0x25, 0xC2, 0x04,
+          0xD3, 0x00, 0xF2, 0x3C, 0xEC, 0xA5, 0xA1, 0x12, 0xD2, 0x35,
+          0xC2, 0x07, 0xF2, 0x1C, 0xD3, 0x60, 0xC3, 0x47, 0x26, 0x31,
+          0xD4, 0x00, 0xD5, 0xF0, 0xE0, 0x04, 0x1F, 0x2F, 0xD4, 0x01,
+          0xA6, 0x11, 0xD5, 0xCC, 0xE0, 0x04, 0x1F, 0x2F, 0xA6, 0x11,
+          0xD4, 0x1F, 0xD5, 0xEE, 0xE0, 0x04, 0x1F, 0x2F, 0xF1, 0x05,
+          0x0B, 0xB7, 0xE0, 0x04, 0x15, 0xF4, 0xEB, 0xBB, 0xD3, 0x02,
+          0x23, 0x31, 0xE0, 0x03, 0x15, 0xFC, 0xF0, 0x1F, 0xF1, 0x01,
+          0x0C, 0xA5, 0xE0, 0x04, 0x0E, 0x81, 0xA0, 0x4D, 0xEC, 0xA6,
+          0xD3, 0x07, 0x2C, 0xFD, 0x91, 0x18, 0xF0, 0x01, 0x0B, 0xCB,
+          0xD2, 0xF0, 0x02, 0x20, 0xF2, 0x1C, 0xEC, 0xAB, 0xD0, 0x06,
+          0x93, 0x1F, 0xF3, 0x05, 0x0B, 0xD0, 0xA0, 0x11, 0xD2, 0x3E,
+          0xF2, 0x0C, 0xEC, 0xAB, 0xD2, 0x4A, 0x91, 0x11, 0xF2, 0x1C,
+          0xE0, 0x04, 0x14, 0xEA, 0xEC, 0xAB, 0xD2, 0x5E, 0xD3, 0x0F,
+          0x2F, 0xFD, 0xF2, 0x3C, 0xEC, 0xAB, 0xD3, 0x0F, 0x2F, 0xCF,
+          0xF3, 0x01, 0x0B, 0xF5, 0xB3, 0x32, 0xF3, 0x01, 0x0B, 0xFA,
+          0xB3, 0x32, 0xF3, 0x01, 0x0C, 0x01, 0xB3, 0x32, 0xF3, 0x01,
+          0x0C, 0x05, 0xB3, 0x32, 0xF3, 0x01, 0x0C, 0x08, 0xB3, 0x32,
+          0xF3, 0x01, 0x0C, 0x0B, 0xB3, 0x32, 0xF3, 0x01, 0x0C, 0x15,
+          0xEC, 0xAB, 0xD2, 0x3A, 0xF2, 0x1C, 0xE0, 0x00, 0x1E, 0x05,
+          0xEC, 0xA5, 0xA7, 0x11, 0xE0, 0x07, 0x1C, 0x14, 0xD7, 0x1F,
+          0xE0, 0x07, 0x1B, 0xF0, 0xEC, 0xAB, 0xA7, 0x11, 0xE0, 0x07,
+          0x1B, 0xE2, 0xEC, 0xAB, 0xE0, 0x07, 0x1C, 0x62, 0xEC, 0xAB,
+          0xE0, 0x07, 0x1B, 0x88, 0xEC, 0xAB, 0xD2, 0x25, 0xC2, 0x04,
+          0xDA, 0x00, 0xF2, 0xAC, 0xD2, 0x59, 0xF2, 0xAC, 0xA2, 0x11,
+          0xE0, 0x02, 0x1E, 0x15, 0xEC, 0xAB, 0xD2, 0x25, 0xC2, 0x04,
+          0xDA, 0x00, 0xF2, 0xAC, 0xE0, 0x00, 0x17, 0xAB, 0xEC, 0xAB,
+          0xF0, 0x1F, 0xF1, 0x01, 0x0C, 0xA5, 0xE0, 0x04, 0x0E, 0x81,
+          0xA0, 0x4D, 0xEC, 0xA6, 0xD3, 0x80, 0x2F, 0xFD, 0x83, 0x3F,
+          0xE0, 0x07, 0x16, 0x65, 0xF7, 0x01, 0x0C, 0x2B, 0xD3, 0x00,
+          0xD2, 0x75, 0x02, 0x23, 0xD3, 0x0F, 0x2F, 0xFD, 0xF2, 0x3C,
+          0xE0, 0x04, 0x16, 0x69, 0xEC, 0x43, 0xD2, 0x25, 0xC2, 0x04,
+          0xDA, 0x00, 0xF2, 0xAC, 0xD2, 0x98, 0xD3, 0x03, 0x24, 0xFD,
+          0x42, 0x34, 0xD3, 0x04, 0x2F, 0xFD, 0x81, 0x19, 0xF2, 0x1C,
+          0xE0, 0x04, 0x18, 0x29, 0xEC, 0xAB, 0xF2, 0x1C, 0xE0, 0x04,
+          0x0F, 0x8D, 0xE0, 0x04, 0x0E, 0x94, 0xEC, 0xAB, 0xD2, 0x66,
+          0xF2, 0x1C, 0xEC, 0xAB, 0xD2, 0x89, 0xD3, 0x03, 0x24, 0xFD,
+          0x42, 0x34, 0x81, 0x17, 0xD3, 0x01, 0x2F, 0xFD, 0x02, 0x23,
+          0xA2, 0x23, 0x81, 0x13, 0xF2, 0x1C, 0xEC, 0xAB, 0xF0, 0x1F,
+          0xD7, 0xEE, 0xD3, 0x01, 0xF7, 0x3C, 0xD7, 0x25, 0xC7, 0x04,
+          0xDA, 0x00, 0xF7, 0xAC, 0xA2, 0x11, 0xE0, 0x02, 0x1E, 0x15,
+          0xE0, 0x04, 0x1C, 0x62, 0xD7, 0x3A, 0xF7, 0x1C, 0xE0, 0x04,
+          0x0F, 0x8D, 0xE0, 0x04, 0x0E, 0x94, 0xD7, 0x3A, 0xF7, 0x1C,
+          0xE0, 0x04, 0x0E, 0x81, 0xD7, 0x74, 0xF7, 0x4C, 0xF0, 0x1F,
+          0xE0, 0x01, 0x0F, 0xEE, 0xD0, 0x01, 0xEC, 0xA6, 0xE0, 0x01,
+          0x1F, 0x66, 0xEC, 0xAB, 0xE0, 0x01, 0x1F, 0x6C, 0xEC, 0xAB,
+          0xD7, 0x4E, 0xF7, 0x1C, 0xEC, 0xAB, 0xD7, 0x4F, 0xF7, 0x1C,
+          0xEC, 0xAB, 0xD5, 0x0F, 0x2C, 0xD1, 0xE0, 0x04, 0x15, 0xFC,
+          0xEC, 0xAB, 0xD3, 0x01, 0x2F, 0xFD, 0xD7, 0xA4, 0xF7, 0x3C,
+          0xEC, 0xAB, 0xD3, 0xFF, 0x2F, 0xFD, 0xD7, 0xAE, 0xC7, 0x03,
+          0xF7, 0x3C, 0xEC, 0xAB, 0xF0, 0x1F, 0xEC, 0xAB, 0xEC, 0xAB,
+          0xD6, 0x0F, 0x2E, 0xE1, 0xD2, 0x3F, 0xC2, 0x03, 0xF2, 0x6C,
+          0xE0, 0x04, 0x16, 0x25, 0xEC, 0xAB, 0xD7, 0x0F, 0x2F, 0xF1,
+          0xD2, 0x40, 0xC2, 0x03, 0xF2, 0x7C, 0xE0, 0x04, 0x16, 0x1E,
+          0xEC, 0xAB, 0xEC, 0xAB, 0xD0, 0x00, 0xD2, 0x59, 0xF2, 0x0C,
+          0xE0, 0x04, 0x15, 0x65, 0xF0, 0x1B, 0xD2, 0x74, 0xF3, 0x28,
+          0x93, 0x31, 0xD2, 0x39, 0xF2, 0x3C, 0xF0, 0x0E, 0xE0, 0x00,
+          0x1E, 0xED, 0xA3, 0x01, 0xF3, 0x01, 0x0D, 0xBA, 0xB3, 0x32,
+          0xF3, 0x01, 0x0D, 0x71, 0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x6C,
+          0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x69, 0xB3, 0x32, 0xF3, 0x01,
+          0x0D, 0x67, 0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x59, 0xB3, 0x32,
+          0xF3, 0x01, 0x0D, 0x6F, 0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x50,
+          0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x4B, 0xB3, 0x32, 0xF3, 0x01,
+          0x0D, 0x4E, 0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x5D, 0xB3, 0x32,
+          0xF3, 0x01, 0x0D, 0x62, 0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x65,
+          0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x49, 0xB3, 0x34, 0xF3, 0x01,
+          0x0D, 0x78, 0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x83, 0xB3, 0x32,
+          0xF3, 0x01, 0x0D, 0x86, 0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x92,
+          0xB3, 0x32, 0xF3, 0x01, 0x0D, 0x99, 0xB3, 0x32, 0xB3, 0x32,
+          0xF3, 0x01, 0x0D, 0xAC, 0xD4, 0x00, 0xC4, 0x80, 0x2F, 0xC4,
+          0xF3, 0x05, 0x0D, 0x1A, 0x84, 0x43, 0x2F, 0xC4, 0xF3, 0x05,
+          0x0D, 0x12, 0x84, 0x43, 0x2F, 0xC4, 0xF3, 0x05, 0x0D, 0xB3,
+          0x84, 0x45, 0x2F, 0xC4, 0xF3, 0x05, 0x0D, 0x16, 0x84, 0x43,
+          0x2F, 0xC4, 0xF3, 0x05, 0x0D, 0x26, 0x84, 0x43, 0x2F, 0xC4,
+          0xF3, 0x05, 0x0D, 0x2A, 0x84, 0x43, 0x2F, 0xC4, 0xF3, 0x05,
+          0x0D, 0x2E, 0x84, 0x43, 0x2F, 0xC4, 0xF3, 0x05, 0x0D, 0x44,
+          0xED, 0x4B, 0x13, 0x04, 0xD2, 0x80, 0x02, 0x23, 0xED, 0x84,
+          0x13, 0x04, 0xD2, 0xFB, 0x02, 0x23, 0xED, 0x84, 0x82, 0x06,
+          0x82, 0x27, 0xD3, 0xFF, 0xC3, 0x07, 0x4F, 0xEF, 0xF3, 0x01,
+          0x0D, 0x25, 0xD3, 0x34, 0x12, 0x23, 0xF0, 0x20, 0xED, 0xBC,
+          0xED, 0x84, 0x13, 0x04, 0xD2, 0x89, 0x02, 0x23, 0xED, 0x84,
+          0x13, 0x04, 0xD2, 0x98, 0x02, 0x23, 0xED, 0x84, 0x10, 0x04,
+          0xF0, 0x01, 0x0D, 0x40, 0xB3, 0x02, 0xF3, 0x01, 0x0D, 0x3E,
+          0xB3, 0x06, 0xF3, 0x01, 0x0D, 0x42, 0xB3, 0x08, 0xF3, 0x01,
+          0x0D, 0x3C, 0xD0, 0x00, 0xED, 0xBC, 0xD2, 0x44, 0xED, 0x84,
+          0xD2, 0x31, 0xED, 0x84, 0xD2, 0x4D, 0xED, 0x84, 0xD2, 0x45,
+          0xED, 0x84, 0x13, 0x04, 0xD2, 0x95, 0xC2, 0x03, 0x02, 0x23,
+          0xED, 0x84, 0xD2, 0x53, 0xED, 0x84, 0xD0, 0x58, 0xC0, 0x1B,
+          0xED, 0xBC, 0xD2, 0x39, 0xED, 0x84, 0xD0, 0x05, 0xE0, 0x04,
+          0x1F, 0x40, 0x84, 0x48, 0x1C, 0xC9, 0x84, 0x48, 0x84, 0x48,
+          0x1C, 0xC4, 0xED, 0xBC, 0xE0, 0x00, 0x1E, 0x66, 0xF0, 0x0D,
+          0xED, 0xBC, 0xD2, 0x02, 0xE0, 0x02, 0x1E, 0xD0, 0x80, 0x3D,
+          0xED, 0xBC, 0xD2, 0x0C, 0xC2, 0x01, 0xED, 0x84, 0xD2, 0x85,
+          0xED, 0x84, 0xD2, 0x40, 0xED, 0x84, 0xE0, 0x00, 0x1E, 0x84,
+          0xED, 0xBC, 0xE0, 0x00, 0x1E, 0x93, 0xED, 0xBC, 0xD2, 0x58,
+          0xED, 0x84, 0xE0, 0x00, 0x14, 0x20, 0xD2, 0x57, 0xF0, 0x28,
+          0x80, 0x0D, 0x80, 0x0B, 0xED, 0xBC, 0xD2, 0x89, 0xF4, 0x28,
+          0xD0, 0x64, 0x24, 0x40, 0xD2, 0x2A, 0xC2, 0x03, 0xF5, 0x28,
+          0xE0, 0x04, 0x1A, 0x43, 0xA0, 0x41, 0xED, 0xBC, 0xD2, 0x56,
+          0xF0, 0x28, 0xED, 0xBC, 0xD2, 0x89, 0xF3, 0x28, 0xD2, 0x2A,
+          0xC2, 0x03, 0xF4, 0x28, 0x5C, 0xF4, 0xD2, 0x9B, 0xF3, 0x28,
+          0xD4, 0x5D, 0x5F, 0xF4, 0x2C, 0xCF, 0xED, 0xBC, 0xD1, 0xA5,
+          0xF1, 0x18, 0xD0, 0x01, 0xF1, 0x01, 0x0D, 0xBC, 0xD0, 0x00,
+          0xED, 0xBC, 0xD0, 0x00, 0xD2, 0x69, 0xD3, 0x08, 0xF4, 0x28,
+          0xF4, 0x01, 0x0D, 0xAB, 0xA2, 0x23, 0xB3, 0x32, 0xF3, 0x05,
+          0x0D, 0x9C, 0xD2, 0x68, 0xF3, 0x28, 0xD4, 0xC0, 0xC4, 0xFF,
+          0x2C, 0xC3, 0xF4, 0x05, 0x0D, 0xAB, 0xD0, 0x01, 0xED, 0xBC,
+          0xD2, 0x0E, 0xE0, 0x02, 0x1E, 0xA1, 0x83, 0x39, 0xD4, 0x0F,
+          0x2C, 0xF4, 0xED, 0xBC, 0xD2, 0xE5, 0xC2, 0x03, 0xD4, 0x3F,
+          0x2C, 0xC0, 0x02, 0x24, 0xF0, 0x28, 0xED, 0xBC, 0xE0, 0x00,
+          0x1E, 0x4C, 0xE0, 0x00, 0x1E, 0xF3, 0xF0, 0x0E, 0xED, 0xEB,
+          0xF0, 0x0A, 0xFB, 0x08, 0xFB, 0x01, 0x0E, 0x20, 0xF7, 0x18,
+          0xF7, 0x01, 0x0D, 0xD1, 0xD8, 0x00, 0xD8, 0x0D, 0x08, 0x87,
+          0xF6, 0x80, 0xA8, 0x67, 0xF9, 0x28, 0xF8, 0x94, 0x19, 0x7B,
+          0xF9, 0x01, 0x0E, 0x20, 0xD8, 0x1D, 0xF8, 0x88, 0x78, 0x8B,
+          0xD9, 0x01, 0x2C, 0x89, 0xF8, 0x05, 0x0E, 0x57, 0xBB, 0xB2,
+          0xD9, 0x00, 0xC9, 0x04, 0x28, 0xB9, 0x08, 0x58, 0xF9, 0x88,
+          0xF9, 0x05, 0x0E, 0x3D, 0xD9, 0x00, 0xC9, 0x04, 0x27, 0xB9,
+          0xD9, 0x00, 0xC9, 0xD0, 0x07, 0x97, 0xF9, 0x78, 0xF9, 0x01,
+          0x0E, 0x22, 0xF9, 0x05, 0x0E, 0x4C, 0xF0, 0x0A, 0xD8, 0x00,
+          0xC8, 0x30, 0xD9, 0x0C, 0xFA, 0x90, 0x48, 0x9A, 0xA9, 0x93,
+          0xDA, 0x00, 0xCA, 0x18, 0x1A, 0xA9, 0xFA, 0x05, 0x0D, 0xEF,
+          0x1A, 0x68, 0xD9, 0xA5, 0xF9, 0xAC, 0xD8, 0x15, 0xD7, 0x00,
+          0xC7, 0xB0, 0xD9, 0x08, 0xDB, 0x00, 0xCB, 0x04, 0xF9, 0x01,
+          0x0E, 0x08, 0xFA, 0x80, 0xF7, 0xAC, 0xB9, 0x92, 0xA8, 0x83,
+          0x07, 0x7B, 0xEE, 0x00, 0xD7, 0x00, 0xC7, 0xAC, 0xD8, 0x0C,
+          0xF9, 0x80, 0xF7, 0x9C, 0xA8, 0x83, 0xF9, 0x80, 0xF2, 0x9C,
+          0x89, 0x9D, 0x89, 0x9F, 0xD7, 0x00, 0xC7, 0x34, 0x17, 0x7B,
+          0xF9, 0x01, 0x0E, 0x20, 0xA8, 0x83, 0x07, 0x7B, 0xFA, 0x80,
+          0xFA, 0x01, 0x0E, 0x15, 0xFA, 0xA0, 0xF7, 0xAC, 0xB9, 0x92,
+          0xEE, 0x15, 0xF0, 0x06, 0xEE, 0x21, 0xDA, 0x00, 0xCA, 0x1C,
+          0x17, 0x8A, 0xF7, 0x9C, 0xA9, 0x93, 0xF8, 0x9C, 0xD9, 0x0E,
+          0x09, 0x9B, 0xF6, 0x90, 0xA9, 0x63, 0xFA, 0x90, 0xF4, 0xAC,
+          0xA9, 0x93, 0xFA, 0x90, 0xF2, 0xAC, 0xAA, 0xA3, 0xD7, 0x00,
+          0xFA, 0x7C, 0xAA, 0xA3, 0xF7, 0x60, 0xFA, 0x7C, 0xD8, 0x00,
+          0xC8, 0x8C, 0xAB, 0xB3, 0xF8, 0xBC, 0xF0, 0x06, 0xF0, 0x02,
+          0xD9, 0x0E, 0x09, 0x9B, 0xF6, 0x90, 0xA9, 0x63, 0xFA, 0x90,
+          0xF4, 0xAC, 0xA9, 0x95, 0xFA, 0x90, 0xF2, 0xAC, 0xD8, 0x00,
+          0xC8, 0x8C, 0xAB, 0xB3, 0xF8, 0xBC, 0xF0, 0x06, 0xF0, 0x02,
+          0xF8, 0x9C, 0xDA, 0x00, 0xCA, 0x64, 0x07, 0x8A, 0xD9, 0x00,
+          0xF7, 0x9C, 0xDA, 0x00, 0xCA, 0x1C, 0x17, 0x8A, 0xF7, 0x9C,
+          0xEE, 0x3D, 0xBB, 0xB2, 0xD8, 0x00, 0xC8, 0x50, 0xD9, 0x00,
+          0xC9, 0x04, 0x48, 0x9B, 0xD9, 0x00, 0xF8, 0x9C, 0xF0, 0x06,
+          0xF0, 0x02, 0xF0, 0x0E, 0xF3, 0x18, 0xA1, 0x13, 0xF2, 0x18,
+          0x41, 0x20, 0xA1, 0x13, 0xF4, 0x18, 0xE0, 0x03, 0x1E, 0xAF,
+          0xB2, 0x22, 0xF2, 0x05, 0x0E, 0x66, 0xF0, 0x02, 0xD2, 0x0F,
+          0x83, 0x09, 0x13, 0x23, 0x61, 0x13, 0x71, 0x13, 0x2F, 0xCE,
+          0x71, 0x13, 0xA0, 0x11, 0xF0, 0x02, 0xD1, 0x3D, 0xF1, 0x18,
+          0xE0, 0x00, 0x0E, 0x6E, 0xF0, 0x02, 0xD1, 0x3C, 0xF1, 0x18,
+          0xE0, 0x00, 0x0E, 0x6E, 0xF0, 0x02, 0xD0, 0x11, 0xE0, 0x00,
+          0x0E, 0x7C, 0xF0, 0x02, 0xE0, 0x00, 0x0E, 0x81, 0xD1, 0x22,
+          0xE0, 0x01, 0x0E, 0x7C, 0x2C, 0xCD, 0xF0, 0x02, 0xD0, 0x32,
+          0xE0, 0x00, 0x0E, 0x7C, 0xF0, 0x02, 0xD0, 0xFF, 0xE0, 0x00,
+          0x0E, 0x7C, 0xF0, 0x02, 0xE0, 0x05, 0x0E, 0x81, 0x80, 0x52,
+          0xD6, 0x32, 0xE0, 0x06, 0x0E, 0x7C, 0xA5, 0x62, 0x06, 0x05,
+          0xD5, 0x16, 0xE0, 0x05, 0x1E, 0xC8, 0xD2, 0x3F, 0xF3, 0x28,
+          0xE0, 0x06, 0x16, 0x2C, 0xD5, 0x06, 0xA7, 0x6C, 0xF7, 0x05,
+          0x0E, 0xA8, 0xA5, 0x61, 0xDB, 0xD7, 0xCB, 0x03, 0xFB, 0x5C,
+          0xD6, 0xD6, 0xC6, 0x06, 0xE0, 0x05, 0x0E, 0x62, 0xE0, 0x05,
+          0x0E, 0x90, 0xF5, 0x01, 0x0E, 0xB7, 0xD5, 0x00, 0xE0, 0x05,
+          0x0E, 0x7C, 0xA5, 0x53, 0xD6, 0x72, 0xC6, 0x01, 0xE0, 0x05,
+          0x0E, 0x62, 0xD5, 0x03, 0xE0, 0x07, 0x0E, 0x81, 0x25, 0x57,
+          0xD6, 0x83, 0xC6, 0x01, 0xE0, 0x05, 0x0E, 0x62, 0xD3, 0x01,
+          0xF2, 0x3C, 0xE0, 0x05, 0x0E, 0x8C, 0xE0, 0x05, 0x0E, 0x81,
+          0xA0, 0x51, 0xA7, 0x51, 0xD5, 0x12, 0xD6, 0x44, 0xE0, 0x05,
+          0x1F, 0x0B, 0xD7, 0x01, 0xD5, 0x12, 0xD6, 0x65, 0xE0, 0x05,
+          0x1F, 0x0B, 0xD7, 0x07, 0xF0, 0x05, 0x0E, 0xD8, 0xD7, 0x04,
+          0xD6, 0xCA, 0xE0, 0x05, 0x1F, 0x0B, 0xD5, 0xCC, 0xE0, 0x05,
+          0x0E, 0x7C, 0x3F, 0xD0, 0xD5, 0x13, 0xD6, 0xFF, 0xE0, 0x05,
+          0x1F, 0x0B, 0xD3, 0x01, 0x3F, 0xFC, 0xA7, 0x05, 0xD8, 0x86,
+          0xE0, 0x08, 0x0E, 0x77, 0xB8, 0x8C, 0xF8, 0x01, 0x0E, 0xF0,
+          0xD5, 0x13, 0xD6, 0x20, 0xE0, 0x05, 0x1F, 0x0B, 0xA7, 0x03,
+          0xD6, 0x44, 0xE0, 0x05, 0x1F, 0x0B, 0xE0, 0x05, 0x16, 0x69,
+          0xD2, 0x75, 0x02, 0x20, 0xE0, 0x07, 0x16, 0x65, 0xF7, 0x01,
+          0x0E, 0xFD, 0xD2, 0x75, 0xF7, 0x28, 0xD5, 0x13, 0xD6, 0xB9,
+          0xE0, 0x05, 0x1F, 0x0B, 0xF0, 0x05, 0x0F, 0x05, 0xD7, 0x04,
+          0xD6, 0x86, 0xE0, 0x05, 0x1F, 0x0B, 0xD5, 0x05, 0xE0, 0x06,
+          0x16, 0x65, 0xF6, 0x05, 0x0F, 0x1B, 0xD5, 0x04, 0xD6, 0x99,
+          0xE0, 0x06, 0x0E, 0x7C, 0xF6, 0x05, 0x0F, 0x1B, 0xE0, 0x05,
+          0x0E, 0x85, 0xD3, 0x03, 0x25, 0x53, 0xF5, 0x05, 0x0F, 0x1B,
+          0xE0, 0x05, 0x0E, 0x90, 0xD6, 0x94, 0xC6, 0x02, 0xE0, 0x05,
+          0x0E, 0x62, 0xD6, 0x8C, 0xC6, 0x02, 0xE0, 0x05, 0x0E, 0x62,
+          0xD6, 0x00, 0xC6, 0x81, 0xF5, 0x05, 0x0F, 0x29, 0xD6, 0x00,
+          0xC6, 0x01, 0xD5, 0x08, 0xE0, 0x05, 0x1E, 0xCC, 0xD5, 0x88,
+          0xE0, 0x05, 0x0E, 0x7C, 0xD6, 0x7D, 0xC6, 0x01, 0xE0, 0x05,
+          0x0E, 0x62, 0xE0, 0x05, 0x0E, 0x81, 0xD2, 0x43, 0xF2, 0x5C,
+          0xD5, 0xEE, 0xE0, 0x05, 0x0E, 0x7C, 0x83, 0x52, 0xF3, 0x0D,
+          0xA3, 0x33, 0xD2, 0x54, 0xF2, 0x3C, 0xA7, 0x51, 0xD5, 0x10,
+          0xD6, 0x77, 0xE0, 0x05, 0x1F, 0x0B, 0xD5, 0xDD, 0xE0, 0x05,
+          0x0E, 0x7C, 0xD2, 0x55, 0xF2, 0x5C, 0xE0, 0x05, 0x16, 0x2C,
+          0xD2, 0x7D, 0xC2, 0x03, 0x02, 0x25, 0xF3, 0x28, 0xD2, 0x35,
+          0xF2, 0x3C, 0xE0, 0x05, 0x1F, 0xD2, 0xE0, 0x05, 0x1F, 0xB4,
+          0xE0, 0x07, 0x0E, 0x81, 0xF7, 0x01, 0x0F, 0x5C, 0xE0, 0x05,
+          0x0E, 0x8C, 0xEF, 0x66, 0xE0, 0x06, 0x16, 0x2C, 0xDB, 0xD9,
+          0xCB, 0x03, 0xFB, 0x6C, 0xD5, 0x06, 0xA7, 0x6C, 0xF7, 0x05,
+          0x0F, 0x66, 0xA5, 0x61, 0xDB, 0xD6, 0xCB, 0x03, 0xFB, 0x5C,
+          0xD6, 0xA3, 0xC6, 0x06, 0xE0, 0x05, 0x0E, 0x62, 0xDB, 0xD8,
+          0xCB, 0x03, 0xFB, 0x5C, 0xD6, 0x02, 0xC6, 0x07, 0xE0, 0x05,
+          0x0E, 0x62, 0xD7, 0x02, 0xD5, 0x00, 0xD6, 0x87, 0xE0, 0x05,
+          0x1F, 0x2F, 0xD3, 0xA8, 0xC3, 0x66, 0xE0, 0x05, 0x16, 0x65,
+          0xF5, 0x05, 0x0F, 0x85, 0xE0, 0x05, 0x0E, 0x81, 0xF5, 0x01,
+          0x0F, 0x85, 0xD3, 0x14, 0xC3, 0x6D, 0xA7, 0x31, 0xD5, 0x17,
+          0xD6, 0xF0, 0xE0, 0x05, 0x1F, 0x2F, 0xE0, 0x05, 0x11, 0xF9,
+          0xF0, 0x02, 0xD4, 0x32, 0xE0, 0x04, 0x0E, 0x77, 0xA5, 0x41,
+          0xD4, 0x1E, 0xE0, 0x04, 0x1E, 0xC8, 0xD4, 0xCC, 0xE0, 0x04,
+          0x0E, 0x7C, 0xF4, 0x01, 0x0F, 0x9E, 0xD4, 0x1F, 0xD5, 0x03,
+          0xE0, 0x04, 0x1E, 0xC8, 0xEF, 0xA5, 0xD4, 0xDD, 0xE0, 0x04,
+          0x0E, 0x77, 0xD5, 0x88, 0xC5, 0x02, 0xE0, 0x04, 0x0E, 0x62,
+          0xD4, 0xEE, 0xE0, 0x04, 0x0E, 0x77, 0xD5, 0x0B, 0xE0, 0x06,
+          0x16, 0x65, 0xF6, 0x05, 0x0F, 0xB6, 0xE0, 0x05, 0x0E, 0x85,
+          0xD3, 0x05, 0x23, 0x35, 0xD5, 0x92, 0xC5, 0x02, 0x05, 0x54,
+          0xF5, 0x58, 0x05, 0x53, 0xD4, 0x21, 0xE0, 0x04, 0x1E, 0xC8,
+          0xD4, 0x54, 0xE0, 0x04, 0x0E, 0x77, 0xD2, 0x48, 0xF2, 0x4C,
+          0xA5, 0x41, 0xD4, 0x25, 0xE0, 0x04, 0x1E, 0xC8, 0xD4, 0x86,
+          0xE0, 0x04, 0x0E, 0x77, 0xD2, 0xB4, 0xC2, 0x02, 0x02, 0x24,
+          0xF5, 0x28, 0x80, 0x53, 0xE0, 0x07, 0x16, 0x65, 0xF7, 0x01,
+          0x0F, 0xCF, 0xD5, 0x02, 0xD4, 0x27, 0xE0, 0x04, 0x1E, 0xC8,
+          0xD3, 0x01, 0x2D, 0xCF, 0x80, 0x03, 0x24, 0xCF, 0xD5, 0xAE,
+          0xC5, 0x02, 0xE0, 0x04, 0x0E, 0x62, 0x80, 0x07, 0xD3, 0x02,
+          0x2F, 0xCF, 0x1D, 0xDF, 0xD2, 0x47, 0xF2, 0x1C, 0xD4, 0xFD,
+          0xC4, 0xFF, 0xE0, 0x04, 0x15, 0x4D, 0xD4, 0xFF, 0xE0, 0x04,
+          0x0E, 0x77, 0xD5, 0xDA, 0xC5, 0x02, 0xE0, 0x04, 0x0E, 0x62,
+          0xE0, 0x04, 0x11, 0xF9, 0xF0, 0x02, 0xD2, 0x4B, 0xD3, 0xE0,
+          0xC3, 0x01, 0xF2, 0x3C, 0xD2, 0x3A, 0xF2, 0x0C, 0x80, 0x03,
+          0xD4, 0x44, 0xE0, 0x04, 0x0E, 0x7C, 0xDB, 0xDB, 0xCB, 0x03,
+          0xFB, 0x4C, 0xF4, 0x01, 0x10, 0x11, 0xD3, 0x80, 0xC3, 0x25,
+          0x4F, 0xCF, 0xA6, 0x33, 0xDB, 0xDC, 0xCB, 0x03, 0xFB, 0x0C,
+          0xDB, 0xDD, 0xCB, 0x03, 0xFB, 0x6C, 0xD2, 0x3C, 0xF4, 0x28,
+          0xD5, 0x32, 0xE0, 0x04, 0x1E, 0xF7, 0xF2, 0x4C, 0xE0, 0x04,
+          0x0F, 0x8D, 0xE0, 0x04, 0x0E, 0x94, 0xE0, 0x04, 0x1F, 0x57,
+          0xD4, 0x88, 0xE0, 0x04, 0x0E, 0x7C, 0xD5, 0x7D, 0xC5, 0x01,
+          0xE0, 0x04, 0x0E, 0x62, 0xD3, 0x00, 0xD2, 0x50, 0xF2, 0x3C,
+          0xD2, 0x40, 0xF2, 0x3C, 0xD2, 0x58, 0xF2, 0x3C, 0xD2, 0x30,
+          0xF2, 0x3C, 0xD3, 0x00, 0xE0, 0x04, 0x0E, 0x90, 0xF4, 0x05,
+          0x10, 0x29, 0xD3, 0x04, 0xD2, 0x51, 0xF2, 0x3C, 0xE0, 0x04,
+          0x14, 0x12, 0xF0, 0x02, 0xD3, 0x01, 0x3F, 0xFC, 0xD1, 0x15,
+          0xD2, 0x11, 0xE0, 0x01, 0x1F, 0x0B, 0xF0, 0x02, 0xA3, 0x01,
+          0xD1, 0x14, 0xD2, 0x32, 0xE0, 0x01, 0x1F, 0x0B, 0x83, 0x03,
+          0xD1, 0x10, 0xD2, 0x11, 0xE0, 0x01, 0x1F, 0x0B, 0xD1, 0x14,
+          0xD2, 0xFF, 0xE0, 0x01, 0x1F, 0x0B, 0xF0, 0x02, 0xE0, 0x00,
+          0x1F, 0x4C, 0xD6, 0x35, 0xF1, 0x68, 0xD6, 0x54, 0xF3, 0x68,
+          0xF3, 0x0D, 0xD7, 0x08, 0x02, 0x07, 0x82, 0x29, 0xA6, 0x21,
+          0xE0, 0x06, 0x1A, 0xAC, 0x42, 0x13, 0xD6, 0x60, 0xF6, 0x2C,
+          0xD4, 0x00, 0xD3, 0x00, 0xD5, 0x01, 0xD6, 0x69, 0x06, 0x63,
+          0xF0, 0x68, 0xD6, 0x6B, 0x06, 0x63, 0xF1, 0x68, 0x56, 0xEC,
+          0x57, 0xDE, 0x2F, 0xFA, 0xF7, 0x05, 0x10, 0x81, 0xD5, 0x02,
+          0xD6, 0x6D, 0x06, 0x63, 0xF0, 0x68, 0xD6, 0x6F, 0x06, 0x63,
+          0xF1, 0x68, 0x56, 0xEC, 0x57, 0xDE, 0x2F, 0xFA, 0xF7, 0x05,
+          0x10, 0x81, 0xA4, 0x43, 0x82, 0x22, 0xD7, 0x88, 0xC7, 0x13,
+          0x4F, 0x2F, 0xF7, 0x05, 0x10, 0x78, 0x97, 0x49, 0xF7, 0x01,
+          0x10, 0x56, 0x72, 0x24, 0xD4, 0x00, 0xA3, 0x33, 0x97, 0x33,
+          0xF7, 0x01, 0x10, 0x56, 0xD3, 0x00, 0xF0, 0x19, 0x10, 0xBE,
+          0xA6, 0x51, 0xE0, 0x06, 0x10, 0x35, 0xE0, 0x06, 0x0E, 0x81,
+          0xA9, 0x61, 0xD8, 0x00, 0xD7, 0xE0, 0xC7, 0x0F, 0x5F, 0x2F,
+          0x1E, 0xEB, 0xF6, 0x05, 0x10, 0x90, 0xD8, 0x01, 0x82, 0x22,
+          0xD6, 0xED, 0xF7, 0x68, 0xF7, 0x01, 0x10, 0x99, 0xB7, 0x72,
+          0xA8, 0x85, 0xF7, 0x01, 0x10, 0x99, 0xB8, 0x82, 0xD6, 0x37,
+          0xF6, 0x8C, 0xD6, 0x15, 0xD7, 0xBA, 0xE0, 0x06, 0x1F, 0x0B,
+          0xA8, 0x21, 0xD6, 0x16, 0xD7, 0xF3, 0xE0, 0x06, 0x1F, 0x0B,
+          0xD6, 0x5A, 0xF6, 0x4C, 0xA8, 0x41, 0xD6, 0x10, 0xD7, 0x42,
+          0xE0, 0x06, 0x1F, 0x0B, 0xA6, 0x31, 0xE0, 0x06, 0x10, 0x2E,
+          0xD6, 0x3F, 0xE0, 0x06, 0x10, 0xD3, 0xE0, 0x06, 0x1F, 0xF7,
+          0x97, 0x6F, 0xF7, 0x05, 0x10, 0xB6, 0xE0, 0x06, 0x10, 0xBF,
+          0xD6, 0x12, 0xE0, 0x06, 0x10, 0xF4, 0xD6, 0x12, 0xE0, 0x06,
+          0x10, 0xDB, 0xF0, 0x02, 0xD1, 0x20, 0xD0, 0x00, 0x1C, 0xCD,
+          0xA4, 0x01, 0xE0, 0x04, 0x10, 0xD3, 0xD5, 0x20, 0xF5, 0x09,
+          0xE0, 0x04, 0x1F, 0xF7, 0x93, 0x4F, 0xF3, 0x01, 0x10, 0xCD,
+          0x3C, 0xCD, 0x81, 0x13, 0xF1, 0x05, 0x10, 0xC1, 0xD2, 0x68,
+          0xF2, 0x0C, 0xF0, 0x02, 0xA3, 0x01, 0xD1, 0x15, 0xD2, 0x72,
+          0xE0, 0x01, 0x1F, 0x2F, 0xC1, 0x02, 0xF1, 0x09, 0xF0, 0x02,
+          0xD2, 0x68, 0xF1, 0x28, 0xC3, 0x08, 0xF3, 0x09, 0xE0, 0x06,
+          0x1F, 0xF7, 0x93, 0x69, 0xF3, 0x05, 0x10, 0xE7, 0xA1, 0x13,
+          0xF0, 0x19, 0x10, 0xEC, 0xD3, 0x0A, 0x4F, 0x6F, 0xF3, 0x01,
+          0x10, 0xF3, 0xB1, 0x12, 0xF2, 0x1C, 0xA6, 0x11, 0xE0, 0x06,
+          0x10, 0xD3, 0xB0, 0x02, 0xF0, 0x05, 0x10, 0xDD, 0xF0, 0x02,
+          0xD2, 0x68, 0xF1, 0x28, 0xC3, 0x08, 0xF3, 0x09, 0xE0, 0x06,
+          0x1F, 0xF7, 0xA3, 0x6E, 0xF3, 0x05, 0x11, 0x00, 0xA1, 0x13,
+          0xF0, 0x19, 0x11, 0x05, 0xD3, 0x09, 0x4F, 0x6F, 0xF3, 0x01,
+          0x11, 0x0C, 0xB1, 0x12, 0xF2, 0x1C, 0xA6, 0x11, 0xE0, 0x06,
+          0x10, 0xD3, 0xB0, 0x02, 0xF0, 0x05, 0x10, 0xF6, 0xF0, 0x02,
+          0xD1, 0x01, 0xE0, 0x01, 0x10, 0x35, 0xD2, 0xB9, 0xC2, 0x07,
+          0xD1, 0x69, 0xD3, 0x08, 0xD4, 0x3B, 0xE0, 0x01, 0x11, 0x30,
+          0xD2, 0x96, 0xC2, 0x0B, 0xD1, 0x6B, 0xD3, 0x08, 0xD4, 0x03,
+          0xE0, 0x01, 0x11, 0x30, 0xD1, 0x02, 0xE0, 0x01, 0x10, 0x35,
+          0xD2, 0xFE, 0xC2, 0x0A, 0xD1, 0x6D, 0xD3, 0x08, 0xD4, 0x3B,
+          0xE0, 0x01, 0x11, 0x30, 0xD2, 0x82, 0xC2, 0x10, 0xD1, 0x6F,
+          0xD3, 0x08, 0xD4, 0x03, 0xE0, 0x01, 0x11, 0x30, 0xF0, 0x02,
+          0xA5, 0x31, 0xE0, 0x05, 0x10, 0xD3, 0xD3, 0x00, 0xA5, 0x31,
+          0xE0, 0x05, 0x10, 0x2E, 0xA5, 0x11, 0xA6, 0x21, 0xE0, 0x05,
+          0x11, 0x46, 0xF5, 0x01, 0x11, 0x45, 0xF0, 0x5C, 0xA0, 0x03,
+          0xD4, 0x0A, 0x01, 0x54, 0xA3, 0x33, 0x94, 0x33, 0xF4, 0x01,
+          0x11, 0x34, 0xF0, 0x02, 0xD3, 0x08, 0xD2, 0x00, 0xA7, 0x01,
+          0xD5, 0x16, 0xD6, 0xF3, 0xE0, 0x05, 0x1F, 0x2F, 0xC4, 0x08,
+          0xF4, 0x09, 0xE0, 0x05, 0x1F, 0xF7, 0x4E, 0xD1, 0xF6, 0x05,
+          0x11, 0x64, 0x5C, 0xD1, 0xF4, 0x05, 0x11, 0x70, 0xF2, 0x01,
+          0x11, 0x5B, 0x94, 0x33, 0x73, 0x34, 0xA2, 0x61, 0x00, 0x03,
+          0xD4, 0x88, 0xC4, 0x13, 0x5C, 0x0C, 0xF4, 0x01, 0x11, 0x48,
+          0xF0, 0x19, 0x11, 0x6F, 0xF2, 0x05, 0x11, 0x68, 0x94, 0x33,
+          0x73, 0x34, 0xA2, 0x61, 0x10, 0x03, 0xD4, 0xE8, 0xC4, 0x03,
+          0x5C, 0x0C, 0xF4, 0x05, 0x11, 0x48, 0xD0, 0x00, 0xF0, 0x02,
+          0xD2, 0x47, 0xF0, 0x28, 0xF0, 0x01, 0x11, 0xA4, 0xB0, 0x02,
+          0xF0, 0x05, 0x11, 0xB6, 0xD4, 0x0A, 0xE0, 0x04, 0x1E, 0xD0,
+          0xF5, 0x05, 0x11, 0x80, 0xE0, 0x07, 0x11, 0xF9, 0xC5, 0x01,
+          0x85, 0x53, 0xD3, 0x00, 0xC3, 0x04, 0x4D, 0xF5, 0xD3, 0x00,
+          0xC3, 0x40, 0x4F, 0x5F, 0x11, 0x31, 0xF1, 0x01, 0x11, 0xB6,
+          0xD2, 0x48, 0xF0, 0x28, 0x00, 0x01, 0xA3, 0x00, 0x20, 0x03,
+          0x93, 0x05, 0xF3, 0x01, 0x11, 0x93, 0xD0, 0x02, 0xD2, 0x48,
+          0xF3, 0x28, 0x13, 0x30, 0xF3, 0x01, 0x11, 0xB6, 0xF2, 0x0C,
+          0xA5, 0x01, 0xD4, 0x25, 0xE0, 0x04, 0x1E, 0xC8, 0xA4, 0x03,
+          0xD5, 0xAE, 0xC5, 0x02, 0xE0, 0x04, 0x0E, 0x62, 0xF0, 0x19,
+          0x11, 0xB6, 0xD4, 0x0A, 0xE0, 0x04, 0x1E, 0xD0, 0xF5, 0x01,
+          0x11, 0xB6, 0x85, 0x53, 0xD3, 0x80, 0xC3, 0x01, 0x4D, 0xF5,
+          0xD3, 0x00, 0xC3, 0x20, 0x4F, 0x5F, 0x11, 0x31, 0xF1, 0x01,
+          0x11, 0xB6, 0xA4, 0x11, 0xE0, 0x04, 0x15, 0x4D, 0xF0, 0x02,
+          0xE0, 0x00, 0x1E, 0x66, 0xA6, 0x01, 0xD4, 0xAE, 0xC4, 0x03,
+          0xF7, 0x48, 0xE0, 0x06, 0x1A, 0xA7, 0xF6, 0x05, 0x11, 0xF4,
+          0xA6, 0x21, 0xD7, 0x60, 0xE0, 0x06, 0x1A, 0xA7, 0xF6, 0x01,
+          0x11, 0xF7, 0xD4, 0x5B, 0xF3, 0x48, 0x13, 0x36, 0xF4, 0x3C,
+          0xD4, 0x54, 0xF1, 0x48, 0x21, 0x16, 0xA6, 0x31, 0xD7, 0x01,
+          0xE0, 0x06, 0x1A, 0xA7, 0xF6, 0x01, 0x11, 0xDF, 0xD4, 0x5B,
+          0xD5, 0x00, 0xF4, 0x5C, 0xD4, 0x3B, 0xF2, 0x48, 0xD5, 0x10,
+          0x42, 0x51, 0xF4, 0x2C, 0xD0, 0x02, 0xF0, 0x19, 0x11, 0xF8,
+          0xD4, 0x61, 0xF5, 0x48, 0xF5, 0x05, 0x11, 0xEB, 0xD4, 0x41,
+          0xF7, 0x48, 0x07, 0x73, 0xE0, 0x06, 0x1E, 0xD8, 0xD0, 0x01,
+          0xF0, 0x19, 0x11, 0xF8, 0xD4, 0x42, 0xF7, 0x48, 0x07, 0x73,
+          0xD6, 0x15, 0xE0, 0x06, 0x1E, 0xC8, 0xD0, 0x01, 0xF0, 0x19,
+          0x11, 0xF8, 0xD0, 0x03, 0xF0, 0x19, 0x11, 0xF8, 0xD0, 0x00,
+          0xF0, 0x02, 0xD1, 0x3D, 0xD0, 0x02, 0xE0, 0x00, 0x1E, 0xC8,
+          0xC1, 0x01, 0xF1, 0x09, 0xD1, 0x1F, 0xE0, 0x00, 0x1E, 0xC8,
+          0xF0, 0x02, 0xD1, 0x5E, 0xF0, 0x18, 0xF0, 0x05, 0x12, 0x11,
+          0xE0, 0x07, 0x16, 0x65, 0xF7, 0x05, 0x12, 0x7B, 0xE0, 0x07,
+          0x0E, 0x81, 0xF7, 0x01, 0x12, 0x7B, 0xF0, 0x19, 0x12, 0x1D,
+          0xD1, 0x08, 0x12, 0x01, 0xF2, 0x01, 0x12, 0x5B, 0xD1, 0x07,
+          0x12, 0x01, 0xF2, 0x01, 0x12, 0x7B, 0xD1, 0x09, 0x12, 0x01,
+          0xF2, 0x05, 0x12, 0x5C, 0xE0, 0x07, 0x12, 0xB9, 0x8A, 0xA9,
+          0xAA, 0xA9, 0x8A, 0xA7, 0xD7, 0x01, 0xD3, 0x80, 0xD5, 0x00,
+          0xD4, 0xFF, 0xC4, 0xFF, 0xD6, 0xF0, 0xC6, 0xFF, 0x02, 0xA6,
+          0x91, 0x21, 0x22, 0x21, 0x22, 0x32, 0x51, 0x2C, 0x52, 0xD2,
+          0x2E, 0xED, 0xF2, 0x05, 0x12, 0x39, 0x06, 0x67, 0xD2, 0x10,
+          0x4E, 0xE6, 0xF2, 0x05, 0x12, 0x29, 0xF0, 0x19, 0x12, 0x4B,
+          0xA5, 0x53, 0xF4, 0x0D, 0x43, 0x54, 0xD2, 0x0C, 0x4E, 0xE5,
+          0xF2, 0x05, 0x12, 0x27, 0x7A, 0xA7, 0x6A, 0xA7, 0xFA, 0x01,
+          0x12, 0x48, 0x87, 0x72, 0x92, 0x79, 0xF2, 0x01, 0x12, 0x23,
+          0xD0, 0xFF, 0xF0, 0x19, 0x12, 0x7B, 0xD1, 0x3B, 0xF1, 0x18,
+          0xD2, 0x70, 0xC2, 0x7D, 0x44, 0xDE, 0xD2, 0x90, 0xC2, 0x7D,
+          0x45, 0xED, 0x2C, 0xC9, 0xF4, 0x01, 0x12, 0x57, 0xD3, 0x82,
+          0xD1, 0x56, 0xF1, 0x3C, 0xF0, 0x19, 0x12, 0x67, 0xD0, 0x00,
+          0x92, 0x0F, 0xF2, 0x01, 0x12, 0x61, 0xD2, 0xF0, 0x1C, 0xCE,
+          0xD2, 0x80, 0x00, 0x02, 0xD2, 0xFF, 0x2C, 0xCE, 0xD1, 0x56,
+          0xF1, 0x0C, 0xD2, 0x00, 0xD1, 0x34, 0xF1, 0x2C, 0xD1, 0x61,
+          0xF1, 0x2C, 0xE0, 0x07, 0x12, 0xB9, 0xD2, 0x80, 0x02, 0xA2,
+          0xD3, 0x00, 0xC3, 0xFF, 0x2F, 0xEF, 0x42, 0x3C, 0x51, 0xD3,
+          0x2E, 0xED, 0xA2, 0x23, 0xD1, 0xED, 0xF1, 0x2C, 0xF0, 0x19,
+          0x12, 0xB8, 0xD2, 0x80, 0xD1, 0x56, 0xF1, 0x2C, 0xE0, 0x07,
+          0x12, 0xB9, 0xD2, 0x80, 0x02, 0xA2, 0xD3, 0x00, 0xC3, 0xFF,
+          0x2F, 0xEF, 0x42, 0x3C, 0x51, 0xD3, 0x2E, 0xED, 0xA2, 0x23,
+          0xD1, 0xED, 0xF1, 0x2C, 0xD2, 0x40, 0x02, 0xA2, 0xD3, 0x80,
+          0xC3, 0xFF, 0x2F, 0xEF, 0x42, 0x3C, 0x51, 0xD3, 0x2E, 0xED,
+          0xF2, 0x05, 0x12, 0x9A, 0xD2, 0x20, 0x02, 0xA2, 0xD3, 0xC0,
+          0xC3, 0xFF, 0x2F, 0xEF, 0xD1, 0x60, 0xF2, 0x18, 0x82, 0x24,
+          0x13, 0x32, 0xD1, 0x54, 0xF2, 0x18, 0x23, 0x32, 0xD2, 0x80,
+          0x13, 0x23, 0xA3, 0x33, 0x93, 0x32, 0xD1, 0x34, 0xF1, 0x3C,
+          0xD1, 0x35, 0xF2, 0x18, 0x82, 0x22, 0x03, 0x23, 0xD2, 0x40,
+          0x12, 0x23, 0xF2, 0x05, 0x12, 0xB5, 0xD2, 0xFF, 0x12, 0x20,
+          0xF2, 0x05, 0x12, 0x1D, 0xF0, 0x19, 0x12, 0x5B, 0xD2, 0x01,
+          0xD1, 0x61, 0xF1, 0x2C, 0xF0, 0x02, 0xD5, 0x31, 0xE0, 0x05,
+          0x0E, 0x7C, 0xD4, 0xB5, 0x04, 0x45, 0xF1, 0x48, 0x82, 0x19,
+          0x82, 0x29, 0xD5, 0xFF, 0x2D, 0xD5, 0xE0, 0x05, 0x1F, 0x4C,
+          0xA0, 0x55, 0x80, 0x05, 0xD4, 0x54, 0xF5, 0x48, 0xB5, 0x52,
+          0xF5, 0x01, 0x12, 0xCF, 0xA5, 0x11, 0xA1, 0x21, 0xA2, 0x51,
+          0x11, 0x01, 0x02, 0x02, 0x05, 0x12, 0xA5, 0x53, 0x83, 0x53,
+          0xF0, 0x02, 0xD5, 0xCC, 0xE0, 0x05, 0x0E, 0x7C, 0xF5, 0x01,
+          0x12, 0xE6, 0xD3, 0x43, 0xF6, 0x38, 0xD5, 0x1B, 0xE0, 0x05,
+          0x1E, 0xC8, 0xD3, 0x56, 0xD4, 0x80, 0xF3, 0x4C, 0xE0, 0x05,
+          0x13, 0x78, 0xF0, 0x19, 0x12, 0xF7, 0xD3, 0x61, 0xF0, 0x38,
+          0xD3, 0x43, 0xF1, 0x38, 0x80, 0x06, 0x16, 0xDC, 0xD5, 0x1B,
+          0xE0, 0x05, 0x1E, 0xC8, 0xF0, 0x01, 0x12, 0xF5, 0xE0, 0x05,
+          0x13, 0x8C, 0xF0, 0x19, 0x12, 0xF7, 0xE0, 0x05, 0x13, 0xBD,
+          0xD5, 0x00, 0xC5, 0x20, 0xE0, 0x05, 0x13, 0x06, 0xE0, 0x05,
+          0x0E, 0x81, 0xD6, 0xEC, 0xC6, 0x02, 0xE0, 0x05, 0x0E, 0x62,
+          0xE0, 0x05, 0x13, 0x16, 0xE0, 0x05, 0x13, 0x44, 0xF0, 0x02,
+          0xD2, 0x10, 0xE0, 0x02, 0x0E, 0x7C, 0xD1, 0xBB, 0xC1, 0x02,
+          0x01, 0x12, 0xF4, 0x18, 0xD1, 0x5D, 0xF3, 0x18, 0x83, 0x34,
+          0x83, 0x33, 0xD2, 0x2A, 0xC2, 0xE0, 0xE0, 0x02, 0x1E, 0xAF,
+          0xF0, 0x02, 0xD2, 0x56, 0xF0, 0x28, 0xD5, 0x00, 0xD3, 0x1C,
+          0xD4, 0x88, 0xE0, 0x03, 0x1F, 0x2F, 0xD1, 0x00, 0xA5, 0x01,
+          0xD4, 0xF8, 0xD3, 0x1D, 0xE0, 0x03, 0x1F, 0x2F, 0xD5, 0x00,
+          0xD2, 0x80, 0x12, 0x02, 0xF2, 0x01, 0x13, 0x2A, 0xD1, 0x01,
+          0xD5, 0x00, 0xD4, 0x30, 0xE0, 0x03, 0x1F, 0x2F, 0xD2, 0xED,
+          0xF2, 0x28, 0xD5, 0x01, 0x2D, 0xD2, 0xD3, 0x1C, 0xD4, 0x99,
+          0xE0, 0x03, 0x1F, 0x2F, 0x82, 0x23, 0xD5, 0x01, 0x2D, 0xD2,
+          0xD3, 0x1D, 0xD4, 0x22, 0xE0, 0x03, 0x1F, 0x2F, 0xC2, 0x02,
+          0xF2, 0x09, 0xA5, 0x11, 0xD3, 0x1C, 0xD4, 0x88, 0xE0, 0x03,
+          0x1F, 0x2F, 0xF0, 0x02, 0xD3, 0x56, 0xF0, 0x38, 0xD2, 0xC9,
+          0xE0, 0x02, 0x0E, 0x77, 0xD3, 0xC4, 0x03, 0x32, 0xF1, 0x38,
+          0xD2, 0x00, 0xC2, 0x20, 0xA3, 0x01, 0xE0, 0x02, 0x1A, 0x43,
+          0x81, 0x12, 0x31, 0x12, 0xA1, 0x13, 0x81, 0x13, 0xD2, 0xCC,
+          0xE0, 0x02, 0x0E, 0x7C, 0xF2, 0x01, 0x13, 0x5D, 0xD3, 0x00,
+          0xF0, 0x19, 0x13, 0x5F, 0x83, 0x12, 0xF3, 0x0D, 0xD2, 0x1C,
+          0xE0, 0x02, 0x1E, 0xCC, 0xD2, 0x34, 0xA3, 0x11, 0xE0, 0x02,
+          0x1E, 0xCC, 0xD2, 0x10, 0xE0, 0x02, 0x0E, 0x7C, 0xF2, 0x01,
+          0x13, 0x6F, 0xD3, 0x18, 0xC3, 0x02, 0xF0, 0x19, 0x13, 0x71,
+          0xD3, 0xC2, 0xC3, 0x01, 0xD2, 0x81, 0x12, 0x02, 0xA4, 0x20,
+          0x22, 0x24, 0xE0, 0x02, 0x0E, 0x62, 0xF0, 0x02, 0xE0, 0x00,
+          0x1F, 0x4C, 0xD4, 0x60, 0xF1, 0x48, 0x81, 0x18, 0x10, 0x01,
+          0xA5, 0x00, 0xF5, 0x01, 0x13, 0x82, 0xF0, 0x0D, 0xA3, 0x09,
+          0x93, 0x36, 0x85, 0x36, 0x10, 0x50, 0x85, 0x08, 0xD4, 0x5D,
+          0xF4, 0x5C, 0xE0, 0x02, 0x1E, 0xDC, 0xF0, 0x02, 0xE0, 0x00,
+          0x1F, 0x4C, 0xD4, 0x60, 0xF1, 0x48, 0xD4, 0x34, 0xF3, 0x48,
+          0x81, 0x18, 0x10, 0x01, 0xD4, 0x54, 0xF5, 0x48, 0x20, 0x05,
+          0x85, 0x36, 0x00, 0x05, 0xD4, 0x55, 0xF1, 0x48, 0xE0, 0x06,
+          0x0E, 0x81, 0xF6, 0x01, 0x13, 0xA2, 0xE0, 0x06, 0x0E, 0x8C,
+          0xA6, 0x63, 0xD4, 0xC0, 0x04, 0x46, 0xF4, 0x48, 0xF1, 0x01,
+          0x13, 0xAD, 0xD5, 0x00, 0xC5, 0x08, 0x14, 0x54, 0x14, 0x04,
+          0xF0, 0x19, 0x13, 0xAE, 0x14, 0x40, 0xA5, 0x49, 0x87, 0x57,
+          0x85, 0x76, 0x15, 0x54, 0x85, 0x58, 0xD4, 0x5D, 0xF4, 0x5C,
+          0xD4, 0x42, 0xF4, 0x7C, 0xD6, 0x15, 0xE0, 0x06, 0x1E, 0xC8,
+          0xE0, 0x02, 0x1E, 0xDC, 0xF0, 0x02, 0xE0, 0x00, 0x1F, 0x4C,
+          0xD4, 0x60, 0xF1, 0x48, 0x81, 0x18, 0x10, 0x01, 0xA5, 0x00,
+          0xF5, 0x05, 0x13, 0xC7, 0xF0, 0x0D, 0x80, 0x08, 0xE0, 0x06,
+          0x0E, 0x8C, 0xA5, 0x61, 0xE0, 0x06, 0x0E, 0x81, 0xF6, 0x05,
+          0x13, 0xE7, 0xD4, 0xE7, 0x04, 0x45, 0xF2, 0x48, 0xA6, 0x01,
+          0xE0, 0x06, 0x14, 0x06, 0xD4, 0x5D, 0xF4, 0x7C, 0xA0, 0x61,
+          0xD4, 0x55, 0xF1, 0x48, 0xF1, 0x01, 0x13, 0xE1, 0x82, 0x29,
+          0x82, 0x29, 0x02, 0x20, 0xF0, 0x19, 0x14, 0x03, 0xD5, 0xFF,
+          0x2E, 0xE5, 0x02, 0x20, 0xF2, 0x0D, 0xF0, 0x19, 0x14, 0x03,
+          0xD4, 0xEA, 0x04, 0x45, 0xF2, 0x48, 0xD4, 0x55, 0xF1, 0x48,
+          0xF1, 0x01, 0x13, 0xFA, 0x82, 0x23, 0xD5, 0x80, 0xC5, 0x7F,
+          0x2E, 0xE5, 0x06, 0x20, 0xE0, 0x06, 0x14, 0x06, 0xD4, 0x5D,
+          0xF4, 0x7C, 0xA2, 0x61, 0xF0, 0x19, 0x14, 0x03, 0x82, 0x28,
+          0x82, 0x26, 0x06, 0x20, 0xE0, 0x06, 0x14, 0x06, 0xD4, 0x5D,
+          0xF4, 0x7C, 0xA2, 0x61, 0xF2, 0x0D, 0xE0, 0x01, 0x1E, 0xDC,
+          0xF0, 0x02, 0xD1, 0x56, 0xF2, 0x18, 0xA5, 0x21, 0xA4, 0x01,
+          0xE0, 0x04, 0x1A, 0x29, 0x83, 0x23, 0x4F, 0x5F, 0x22, 0x23,
+          0x11, 0x52, 0x00, 0x43, 0xF0, 0x02, 0xD0, 0x51, 0xF1, 0x08,
+          0xD3, 0x52, 0xF0, 0x38, 0x10, 0x01, 0xF0, 0x01, 0x14, 0x1F,
+          0xF3, 0x1C, 0xA2, 0x11, 0xD3, 0xDE, 0xC3, 0x02, 0xE0, 0x02,
+          0x0E, 0x62, 0xF0, 0x02, 0xD0, 0x05, 0xC0, 0x60, 0xE0, 0x00,
+          0x1E, 0xA1, 0xA3, 0x01, 0xE0, 0x03, 0x1E, 0xA1, 0xD0, 0xF8,
+          0xC0, 0x3F, 0x2C, 0xEC, 0xF0, 0x05, 0x14, 0x32, 0x82, 0x2A,
+          0x82, 0x2A, 0x81, 0x1D, 0x1D, 0xDE, 0xF0, 0x19, 0x14, 0x34,
+          0xD1, 0xFF, 0xC1, 0x1F, 0x82, 0x44, 0x82, 0x25, 0xE0, 0x02,
+          0x1A, 0x6D, 0xD0, 0x00, 0xC0, 0x06, 0x00, 0x02, 0xE0, 0x01,
+          0x1A, 0x6D, 0x81, 0x13, 0x11, 0x01, 0x90, 0x11, 0x21, 0x10,
+          0xD3, 0x57, 0xF3, 0x1C, 0xD3, 0x58, 0xF2, 0x38, 0x84, 0x25,
+          0xD0, 0x03, 0x24, 0x40, 0x85, 0x15, 0x04, 0x45, 0x2D, 0xDC,
+          0x2E, 0xEC, 0x22, 0x20, 0x02, 0x21, 0x82, 0x25, 0x01, 0x24,
+          0xF3, 0x1C, 0xE0, 0x03, 0x0E, 0x90, 0xF3, 0x01, 0x14, 0x62,
+          0xD2, 0x00, 0xD3, 0xE0, 0xF0, 0x38, 0x4C, 0xDC, 0xF0, 0x05,
+          0x14, 0x60, 0xA2, 0x23, 0xA3, 0x33, 0xA0, 0x26, 0xF0, 0x01,
+          0x14, 0x57, 0xD3, 0x51, 0xF3, 0x2C, 0xF0, 0x02, 0xD3, 0x06,
+          0xC3, 0x60, 0xE0, 0x03, 0x1E, 0xA1, 0xD0, 0x7A, 0xF4, 0x08,
+          0xF0, 0x5C, 0xDA, 0x03, 0x82, 0x4B, 0x22, 0x2A, 0x02, 0x24,
+          0x4E, 0x5E, 0x81, 0x5B, 0x21, 0x1A, 0x01, 0x15, 0x4D, 0x4D,
+          0x02, 0x12, 0xA0, 0x03, 0xF1, 0x08, 0x01, 0x12, 0xF0, 0x1C,
+          0xA0, 0x03, 0xF6, 0x08, 0xA6, 0x63, 0xF0, 0x6C, 0x84, 0x47,
+          0x85, 0x57, 0xD3, 0x7D, 0xF2, 0x38, 0xD6, 0x7F, 0xF7, 0x68,
+          0xD8, 0x7E, 0xF9, 0x88, 0xF9, 0x01, 0x14, 0x8F, 0xB1, 0x92,
+          0xF1, 0x01, 0x14, 0x93, 0xB1, 0x12, 0xF1, 0x01, 0x14, 0x9E,
+          0x51, 0xCD, 0xF0, 0x19, 0x14, 0x94, 0x5F, 0xC9, 0xF6, 0x7C,
+          0xF0, 0x19, 0x14, 0xA0, 0x41, 0xDC, 0x01, 0x71, 0xAA, 0x12,
+          0x81, 0x13, 0x01, 0x12, 0xF3, 0x1C, 0xFA, 0x05, 0x14, 0xA3,
+          0xA9, 0x93, 0xF0, 0x19, 0x14, 0xA4, 0x4F, 0xD8, 0xF6, 0x7C,
+          0xA9, 0x93, 0xF0, 0x19, 0x14, 0xA4, 0xB9, 0x92, 0xD1, 0x03,
+          0x2D, 0x91, 0xD8, 0x7E, 0xF8, 0x9C, 0xF0, 0x02, 0xD1, 0x49,
+          0xF2, 0x18, 0xF2, 0x05, 0x14, 0xC3, 0xE0, 0x03, 0x0E, 0x90,
+          0xF3, 0x01, 0x14, 0xC3, 0xE0, 0x00, 0x1E, 0x4C, 0xD2, 0xDC,
+          0xC2, 0x03, 0x5E, 0xCE, 0xF2, 0x05, 0x14, 0xC3, 0xD1, 0x4B,
+          0xF2, 0x18, 0xF2, 0x01, 0x14, 0xC0, 0xB2, 0x22, 0xF1, 0x2C,
+          0xF0, 0x19, 0x14, 0xCA, 0xD3, 0x00, 0xF0, 0x19, 0x14, 0xC8,
+          0xD1, 0x4B, 0xD2, 0xE0, 0xC2, 0x01, 0xF1, 0x2C, 0xD3, 0x01,
+          0xD1, 0x5F, 0xF1, 0x3C, 0xF0, 0x02, 0xD1, 0x5F, 0xF0, 0x18,
+          0xD1, 0x67, 0xF2, 0x18, 0x12, 0x20, 0xF2, 0x01, 0x14, 0xDB,
+          0xF1, 0x0C, 0xD1, 0xBF, 0xC1, 0x02, 0xE0, 0x00, 0x0E, 0x62,
+          0x80, 0x02, 0xB0, 0x02, 0xE0, 0x00, 0x15, 0x4D, 0xF0, 0x02,
+          0xD0, 0x71, 0xF1, 0x08, 0xA1, 0x13, 0xD2, 0x3F, 0x2D, 0xDE,
+          0xF0, 0x1C, 0xF1, 0x05, 0x14, 0xE9, 0xD2, 0x01, 0xE0, 0x02,
+          0x10, 0xDB, 0xE0, 0x02, 0x11, 0x71, 0xF0, 0x02, 0xD1, 0x4A,
+          0xF2, 0x18, 0xD3, 0x03, 0x22, 0x23, 0xE0, 0x07, 0x16, 0x65,
+          0xF7, 0x05, 0x14, 0xFF, 0xE0, 0x03, 0x0E, 0x81, 0xF3, 0x01,
+          0x14, 0xFF, 0xA2, 0x23, 0xD3, 0x00, 0xE0, 0x03, 0x0E, 0x7C,
+          0x02, 0x23, 0x93, 0x29, 0xF3, 0x01, 0x14, 0xFF, 0xD2, 0x04,
+          0xD3, 0x05, 0xD0, 0x11, 0xC0, 0x03, 0x40, 0x23, 0xD1, 0x8A,
+          0xD2, 0x03, 0xF5, 0x08, 0xD3, 0xFF, 0x2F, 0x5F, 0xF1, 0x3C,
+          0xA1, 0x13, 0x85, 0x59, 0x85, 0x59, 0xF1, 0x5C, 0xA0, 0x03,
+          0xA1, 0x15, 0xB2, 0x22, 0xF2, 0x05, 0x15, 0x05, 0xF5, 0x08,
+          0xF1, 0x5C, 0xA1, 0x13, 0xA0, 0x03, 0xF5, 0x08, 0x83, 0x53,
+          0xF1, 0x3C, 0xD1, 0x99, 0xC1, 0x03, 0xF3, 0x18, 0xB3, 0x34,
+          0xF3, 0x01, 0x15, 0x25, 0xD1, 0x8D, 0xD3, 0x28, 0xF1, 0x3C,
+          0xA1, 0x13, 0xD3, 0xA0, 0xF1, 0x3C, 0xE0, 0x03, 0x15, 0x2A,
+          0xE0, 0x03, 0x15, 0x39, 0xF0, 0x02, 0xD1, 0x72, 0xF2, 0x18,
+          0xD1, 0xA1, 0xC1, 0x06, 0xF3, 0x18, 0x1E, 0xEF, 0xF2, 0x01,
+          0x15, 0x38, 0xD1, 0x90, 0xD3, 0x8C, 0xF1, 0x3C, 0xA1, 0x13,
+          0xD3, 0xC8, 0xF1, 0x3C, 0xF0, 0x02, 0xD1, 0x72, 0xF2, 0x18,
+          0xF2, 0x01, 0x15, 0x41, 0xD4, 0x78, 0xD5, 0xB4, 0xF0, 0x19,
+          0x15, 0x48, 0xD1, 0xA1, 0xC1, 0x06, 0xF2, 0x18, 0xF2, 0x01,
+          0x15, 0x4C, 0xD4, 0x78, 0xD5, 0xB4, 0xD1, 0x8D, 0xF1, 0x4C,
+          0xA1, 0x13, 0xF1, 0x5C, 0xF0, 0x02, 0xF0, 0x01, 0x15, 0x64,
+          0xD4, 0xCC, 0xE0, 0x04, 0x0E, 0x7C, 0xF4, 0x05, 0x15, 0x5F,
+          0xD1, 0x33, 0xF2, 0x18, 0x04, 0x20, 0x95, 0x41, 0xF5, 0x05,
+          0x15, 0x5B, 0xD4, 0x01, 0x95, 0x47, 0xF5, 0x01, 0x15, 0x5F,
+          0xD4, 0x03, 0xD1, 0x33, 0xF1, 0x4C, 0xD3, 0x1D, 0xE0, 0x03,
+          0x1E, 0xC8, 0xF0, 0x02, 0xD0, 0x00, 0xC0, 0xB0, 0xD1, 0x40,
+          0xC1, 0x42, 0xF0, 0x1C, 0xD0, 0x00, 0xC0, 0xB4, 0xD1, 0x0F,
+          0xF0, 0x1C, 0xF0, 0x02, 0xD2, 0x00, 0xE0, 0x02, 0x0E, 0x7C,
+          0xD0, 0x61, 0xF1, 0x08, 0x81, 0x12, 0x01, 0x12, 0xD0, 0xDA,
+          0x00, 0x01, 0xF2, 0x08, 0xD0, 0x00, 0xC0, 0xB0, 0xF0, 0x2C,
+          0xD0, 0x00, 0xC0, 0xB4, 0xD1, 0x01, 0x2D, 0xDE, 0xF0, 0x1C,
+          0xF0, 0x02, 0xD1, 0x5C, 0xC1, 0x01, 0xE0, 0x00, 0x0E, 0x62,
+          0xF0, 0x02, 0xD2, 0x30, 0xF1, 0x28, 0xD3, 0x03, 0x2D, 0xDF,
+          0xF2, 0x1C, 0xA0, 0x16, 0xF0, 0x02, 0xE0, 0x05, 0x15, 0x87,
+          0x85, 0x52, 0xE0, 0x05, 0x15, 0x82, 0xE0, 0x05, 0x0E, 0x90,
+          0xA5, 0x59, 0xD6, 0x6A, 0xC6, 0x01, 0xE0, 0x05, 0x0E, 0x62,
+          0xD1, 0x5B, 0xD2, 0x00, 0xF1, 0x2C, 0xD2, 0x00, 0xD1, 0xED,
+          0xF1, 0x2C, 0xD5, 0x14, 0xD1, 0x4C, 0xF1, 0x5C, 0xD6, 0x0C,
+          0xE0, 0x05, 0x1E, 0xC8, 0xE0, 0x05, 0x10, 0x44, 0xE0, 0x05,
+          0x12, 0x03, 0xD2, 0x00, 0xD1, 0x62, 0xF1, 0x2C, 0xE0, 0x05,
+          0x12, 0xD5, 0xE0, 0x05, 0x10, 0x44, 0xD1, 0x9B, 0xD2, 0x20,
+          0xF1, 0x2C, 0xA1, 0x17, 0xD2, 0x00, 0xF1, 0x2C, 0xA1, 0x17,
+          0xD2, 0x2B, 0xF1, 0x2C, 0xE0, 0x05, 0x18, 0x29, 0xE0, 0x05,
+          0x18, 0x5E, 0xE0, 0x05, 0x15, 0x65, 0xE0, 0x05, 0x11, 0xF9,
+          0xD1, 0x77, 0xD2, 0x50, 0xF1, 0x2C, 0xD2, 0x41, 0xE0, 0x05,
+          0x16, 0x65, 0xF5, 0x01, 0x15, 0xCB, 0xD2, 0x51, 0xD5, 0x10,
+          0xA6, 0x21, 0xE0, 0x05, 0x1E, 0xC8, 0xE0, 0x05, 0x14, 0xEA,
+          0xD1, 0x41, 0xC1, 0x03, 0xF2, 0x18, 0xF2, 0x01, 0x15, 0xE3,
+          0xD1, 0x40, 0xC1, 0x03, 0xF2, 0x18, 0xD5, 0xFD, 0xC5, 0xFF,
+          0x2E, 0xE5, 0xF1, 0x2C, 0xE0, 0x05, 0x16, 0x1E, 0xD1, 0x43,
+          0xC1, 0x03, 0xD2, 0x09, 0xF1, 0x2C, 0xF0, 0x02, 0xD6, 0x88,
+          0xC6, 0x88, 0xD1, 0xF8, 0xF2, 0x18, 0x82, 0x28, 0x82, 0x28,
+          0x1E, 0xE2, 0xA1, 0x13, 0xF2, 0x18, 0x1E, 0xE2, 0xD5, 0x29,
+          0xC5, 0xE0, 0xD7, 0x10, 0xE0, 0x05, 0x1E, 0xAF, 0xF0, 0x02,
+          0xD5, 0x29, 0xC5, 0xE0, 0xD7, 0x11, 0xD6, 0x88, 0xC6, 0x88,
+          0xE0, 0x05, 0x1E, 0xAF, 0xF0, 0x02, 0xA2, 0x03, 0x82, 0x23,
+          0xD1, 0xF8, 0xF1, 0x2C, 0x82, 0x03, 0xA1, 0x13, 0xF1, 0x2C,
+          0xE0, 0x00, 0x15, 0xE4, 0xF0, 0x02, 0xD1, 0x3D, 0xC1, 0x03,
+          0xF2, 0x18, 0xD1, 0x3E, 0xC1, 0x03, 0xF3, 0x18, 0x13, 0x32,
+          0xF3, 0x01, 0x16, 0x1D, 0xA3, 0x21, 0xF1, 0x3C, 0xD6, 0x02,
+          0x26, 0x63, 0xD1, 0x35, 0xC1, 0x03, 0x01, 0x16, 0xF5, 0x18,
+          0xA1, 0x13, 0xF4, 0x18, 0xD3, 0x2A, 0xC3, 0xE0, 0xE0, 0x03,
+          0x1E, 0xAF, 0xF0, 0x02, 0xD3, 0x37, 0xD1, 0x40, 0xC1, 0x03,
+          0xF4, 0x18, 0xE0, 0x03, 0x1E, 0xC8, 0xF0, 0x02, 0xD3, 0x36,
+          0xD1, 0x3F, 0xC1, 0x03, 0xF4, 0x18, 0xE0, 0x03, 0x1E, 0xC8,
+          0xF0, 0x02, 0xD0, 0x00, 0xE0, 0x03, 0x0E, 0x8C, 0xE0, 0x04,
+          0x16, 0x65, 0xF4, 0x01, 0x16, 0x36, 0xA0, 0x31, 0xF0, 0x19,
+          0x16, 0x64, 0xE0, 0x04, 0x0E, 0x81, 0xF4, 0x05, 0x16, 0x5E,
+          0xF3, 0x01, 0x16, 0x64, 0xB3, 0x32, 0xD0, 0x01, 0xF3, 0x01,
+          0x16, 0x64, 0xE0, 0x04, 0x0E, 0x90, 0xD0, 0x05, 0xF4, 0x01,
+          0x16, 0x64, 0xD4, 0xC9, 0xE0, 0x04, 0x0E, 0x77, 0xB4, 0x4E,
+          0xF4, 0x01, 0x16, 0x5B, 0xB4, 0x42, 0xD0, 0x03, 0xF4, 0x01,
+          0x16, 0x64, 0xB4, 0x42, 0xF4, 0x01, 0x16, 0x5B, 0xB4, 0x42,
+          0xF4, 0x01, 0x16, 0x5B, 0xB4, 0x42, 0xF4, 0x01, 0x16, 0x5B,
+          0xD0, 0x02, 0xF0, 0x19, 0x16, 0x64, 0xD0, 0x04, 0xF0, 0x19,
+          0x16, 0x64, 0xD1, 0x4A, 0xF2, 0x18, 0xD1, 0x03, 0x20, 0x21,
+          0xA0, 0x0D, 0x00, 0x03, 0xF0, 0x02, 0xD0, 0x77, 0xE0, 0x00,
+          0x0E, 0x7C, 0xF0, 0x02, 0xE0, 0x06, 0x0E, 0x81, 0xF6, 0x05,
+          0x16, 0x81, 0xD2, 0x75, 0xF1, 0x28, 0x85, 0x17, 0xD3, 0x01,
+          0x3D, 0xD3, 0xD3, 0xCC, 0x73, 0x35, 0xD2, 0xB0, 0xC2, 0x02,
+          0xF2, 0x3C, 0xD2, 0x8A, 0xC2, 0x02, 0xD3, 0x04, 0x13, 0x35,
+          0xF2, 0x3C, 0xA2, 0x23, 0xB3, 0x36, 0xF2, 0x3C, 0xF0, 0x19,
+          0x16, 0xA4, 0xD2, 0x75, 0xE0, 0x06, 0x16, 0x65, 0xF6, 0x05,
+          0x16, 0x87, 0xA2, 0x23, 0xF1, 0x28, 0x85, 0x17, 0xD3, 0x01,
+          0x2D, 0xD3, 0x3D, 0xD3, 0xD3, 0xCC, 0xE0, 0x07, 0x16, 0x65,
+          0xF7, 0x05, 0x16, 0x9A, 0xD3, 0x33, 0xE0, 0x07, 0x0E, 0x85,
+          0xF7, 0x01, 0x16, 0x99, 0xF5, 0x05, 0x16, 0x99, 0xD3, 0x42,
+          0x03, 0x35, 0x73, 0x35, 0xD2, 0xB1, 0xC2, 0x02, 0xF2, 0x3C,
+          0x83, 0x33, 0xA2, 0x23, 0xF2, 0x3C, 0x83, 0x33, 0xA2, 0x23,
+          0xF2, 0x3C, 0xF0, 0x02, 0xD0, 0x00, 0xE0, 0x03, 0x17, 0xAB,
+          0xE0, 0x03, 0x19, 0x08, 0xD1, 0x03, 0xD2, 0x00, 0xA3, 0x11,
+          0xE0, 0x03, 0x18, 0xE4, 0x02, 0x23, 0xB1, 0x12, 0xF1, 0x05,
+          0x16, 0xAC, 0xA2, 0x24, 0xD1, 0x79, 0xF1, 0x2C, 0xF2, 0x01,
+          0x16, 0xBE, 0xE0, 0x03, 0x0E, 0x81, 0xF3, 0x01, 0x16, 0xBE,
+          0xE0, 0x03, 0x11, 0xF9, 0xD3, 0x01, 0xE0, 0x03, 0x17, 0xDB,
+          0xF4, 0x01, 0x16, 0xD3, 0xD1, 0xAF, 0xC1, 0x03, 0xF2, 0x18,
+          0xA2, 0x23, 0xD5, 0x01, 0x2E, 0xE5, 0xF1, 0x2C, 0xF2, 0x05,
+          0x16, 0xD7, 0xE0, 0x03, 0x17, 0xFC, 0xF3, 0x01, 0x16, 0xD7,
+          0xD3, 0x01, 0xF0, 0x19, 0x17, 0x10, 0xD1, 0xAF, 0xC1, 0x03,
+          0xD2, 0x00, 0xF1, 0x2C, 0xD1, 0x72, 0xF2, 0x18, 0xD1, 0xA1,
+          0xC1, 0x06, 0xF1, 0x18, 0x1E, 0xED, 0xF2, 0x05, 0x16, 0xF5,
+          0xD1, 0x8C, 0xF6, 0x18, 0xA1, 0x15, 0xF7, 0x18, 0xD8, 0x3D,
+          0xC8, 0x0A, 0x38, 0x87, 0x42, 0xC6, 0x83, 0x22, 0xF3, 0x05,
+          0x16, 0xF0, 0xD8, 0xFF, 0xC8, 0x1F, 0x38, 0x87, 0x43, 0xC6,
+          0xF3, 0x05, 0x16, 0xF5, 0xD1, 0x31, 0xF1, 0x18, 0x3E, 0xFD,
+          0xF2, 0x05, 0x17, 0x10, 0xD3, 0x02, 0xE0, 0x03, 0x17, 0xDB,
+          0xF4, 0x01, 0x17, 0x01, 0xE0, 0x03, 0x17, 0xFC, 0xF3, 0x01,
+          0x17, 0x01, 0xD3, 0x01, 0xF0, 0x19, 0x17, 0x10, 0xD3, 0x03,
+          0xE0, 0x03, 0x17, 0xDB, 0xF4, 0x01, 0x17, 0x0D, 0xE0, 0x03,
+          0x17, 0xFC, 0xF3, 0x01, 0x17, 0x0D, 0xD3, 0x01, 0xF0, 0x19,
+          0x17, 0x10, 0xD0, 0x00, 0xF0, 0x19, 0x17, 0x13, 0xA0, 0x31,
+          0xE0, 0x03, 0x18, 0x1A, 0xD1, 0x72, 0xF3, 0x18, 0xE0, 0x04,
+          0x1A, 0x20, 0x3F, 0xF4, 0xF3, 0x01, 0x17, 0x2A, 0xE0, 0x03,
+          0x14, 0xEA, 0xD1, 0x9B, 0xF5, 0x18, 0xD6, 0x4F, 0x4C, 0xDA,
+          0xF4, 0x01, 0x17, 0x35, 0xF1, 0x6C, 0xF3, 0x01, 0x17, 0x2A,
+          0xD0, 0x01, 0xE0, 0x03, 0x18, 0x1A, 0xF0, 0x19, 0x17, 0x35,
+          0xD1, 0xA1, 0xC1, 0x06, 0xF3, 0x18, 0xE0, 0x04, 0x19, 0xFB,
+          0xD1, 0xA1, 0xC1, 0x06, 0xF4, 0x18, 0x3F, 0xF4, 0xF3, 0x01,
+          0x17, 0x3A, 0xE0, 0x03, 0x17, 0x4C, 0xD0, 0x01, 0xE0, 0x03,
+          0x18, 0x1A, 0xD1, 0xA2, 0xC1, 0x06, 0xF1, 0x0C, 0xF0, 0x02,
+          0xD1, 0x31, 0xF1, 0x0C, 0x85, 0x03, 0xD3, 0x10, 0xD4, 0x88,
+          0xE0, 0x03, 0x1F, 0x0B, 0xA5, 0x02, 0x85, 0x52, 0xD3, 0x08,
+          0xD4, 0xCB, 0xE0, 0x03, 0x1F, 0x0B, 0xF0, 0x02, 0xD1, 0x72,
+          0xF2, 0x18, 0xD1, 0xA1, 0xC1, 0x06, 0xF1, 0x18, 0x1E, 0xED,
+          0xD5, 0x01, 0x15, 0x52, 0xD3, 0x08, 0xD4, 0x66, 0xE0, 0x03,
+          0x1F, 0x0B, 0xF2, 0x01, 0x17, 0x5D, 0xD3, 0x01, 0xF0, 0x19,
+          0x17, 0x74, 0xD1, 0x9B, 0xF2, 0x18, 0xD1, 0x10, 0x5F, 0xDE,
+          0xF3, 0x01, 0x17, 0x74, 0xD1, 0x8C, 0xF4, 0x18, 0xA1, 0x15,
+          0xF5, 0x18, 0xD6, 0x3D, 0xC6, 0x0A, 0x36, 0x65, 0x43, 0xEC,
+          0x83, 0x32, 0xF3, 0x05, 0x17, 0x74, 0xD6, 0xFF, 0xC6, 0x1F,
+          0x36, 0x65, 0x43, 0xEC, 0xF3, 0x05, 0x17, 0x76, 0xE0, 0x03,
+          0x17, 0x3E, 0xD2, 0x0C, 0x15, 0x20, 0xD3, 0x0E, 0xD4, 0xB8,
+          0xE0, 0x03, 0x1F, 0x0B, 0xF0, 0x02, 0x82, 0x09, 0xF2, 0x05,
+          0x17, 0x85, 0x81, 0x05, 0xD2, 0x03, 0x25, 0xCE, 0xF0, 0x19,
+          0x17, 0x8F, 0xD1, 0x0C, 0x15, 0x01, 0x82, 0x59, 0xF2, 0x01,
+          0x17, 0x8E, 0xB5, 0x58, 0xA1, 0x19, 0xF0, 0x19, 0x17, 0x87,
+          0x81, 0x15, 0xD3, 0x0E, 0xD4, 0xFC, 0xE0, 0x03, 0x1F, 0x0B,
+          0xA5, 0x11, 0xD4, 0x75, 0xE0, 0x03, 0x1F, 0x0B, 0xF0, 0x02,
+          0xD1, 0x23, 0x11, 0x10, 0xA2, 0x10, 0x21, 0x12, 0xE0, 0x01,
+          0x17, 0x7D, 0xF0, 0x02, 0xD5, 0xA2, 0xC5, 0x06, 0xF6, 0x58,
+          0xF6, 0x01, 0x17, 0xAA, 0xE0, 0x03, 0x1E, 0xE1, 0xD5, 0x9A,
+          0xC5, 0x03, 0xD6, 0x01, 0xF5, 0x6C, 0xF0, 0x02, 0xD6, 0x0F,
+          0xE0, 0x06, 0x1E, 0xD4, 0xD4, 0xFF, 0x21, 0xC4, 0x82, 0x79,
+          0x82, 0x29, 0x20, 0xFC, 0xD3, 0x95, 0xF5, 0x38, 0x10, 0x05,
+          0x94, 0x01, 0x20, 0x04, 0xA3, 0x33, 0xF5, 0x38, 0x11, 0x15,
+          0x94, 0x11, 0x21, 0x14, 0xA3, 0x33, 0xF5, 0x38, 0x12, 0x25,
+          0x94, 0x21, 0x22, 0x24, 0xD3, 0x89, 0xF3, 0x0C, 0xA3, 0x37,
+          0xF3, 0x1C, 0xA3, 0x37, 0xF3, 0x2C, 0xA3, 0x37, 0xE0, 0x06,
+          0x1E, 0x4C, 0xF3, 0x6C, 0xD6, 0x2A, 0xC6, 0x03, 0xF8, 0x68,
+          0x57, 0x0C, 0xF7, 0x05, 0x17, 0xD8, 0x87, 0x85, 0x88, 0x83,
+          0x07, 0x78, 0x4F, 0x0F, 0xF7, 0x05, 0x17, 0xDA, 0xD6, 0x62,
+          0xF6, 0x7C, 0xF0, 0x02, 0xD4, 0x89, 0xD5, 0x03, 0x44, 0x05,
+          0xF2, 0x48, 0xA4, 0x43, 0xF1, 0x48, 0xA4, 0x43, 0xF3, 0x48,
+          0xB5, 0x02, 0xF5, 0x05, 0x17, 0xF3, 0xD4, 0x9B, 0xF5, 0x48,
+          0xD4, 0x10, 0x15, 0x54, 0xF5, 0x01, 0x17, 0xF2, 0xB5, 0x52,
+          0xF5, 0x01, 0x17, 0xF2, 0xB5, 0x52, 0xF5, 0x05, 0x17, 0xF3,
+          0xD1, 0x0A, 0x4D, 0xED, 0x45, 0xFE, 0xA6, 0x01, 0xE0, 0x06,
+          0x18, 0xE4, 0x15, 0x56, 0x11, 0x51, 0xF1, 0x0D, 0xF0, 0x02,
+          0xD4, 0x98, 0xD5, 0x03, 0x44, 0x05, 0xF3, 0x48, 0x02, 0x31,
+          0xA5, 0x20, 0xF5, 0x05, 0x18, 0x0A, 0xF3, 0x01, 0x18, 0x18,
+          0xD2, 0x00, 0xA4, 0x43, 0xF0, 0x19, 0x18, 0x13, 0xA4, 0x43,
+          0xF5, 0x48, 0x13, 0x35, 0x4D, 0x2D, 0xF5, 0x01, 0x18, 0x13,
+          0xF3, 0x01, 0x18, 0x18, 0xF2, 0x48, 0xB4, 0x42, 0xF4, 0x2C,
+          0xD0, 0x01, 0xF0, 0x19, 0x18, 0x19, 0xD0, 0x00, 0xF0, 0x02,
+          0xD0, 0x9B, 0xF1, 0x08, 0xE0, 0x01, 0x19, 0x4D, 0xA0, 0x07,
+          0xF1, 0x08, 0xE0, 0x01, 0x17, 0x4C, 0xA0, 0x07, 0xF1, 0x08,
+          0xE0, 0x01, 0x17, 0x98, 0xE0, 0x01, 0x1F, 0x1B, 0xF0, 0x02,
+          0xE0, 0x00, 0x18, 0x1A, 0xE0, 0x00, 0x1E, 0xE1, 0xE0, 0x00,
+          0x18, 0x5E, 0xE0, 0x00, 0x18, 0x69, 0xF0, 0x02, 0xD1, 0x00,
+          0xE0, 0x04, 0x17, 0xAB, 0xD4, 0x01, 0xE0, 0x04, 0x17, 0xDB,
+          0xF5, 0x01, 0x18, 0x3E, 0xE0, 0x04, 0x17, 0xFC, 0xF4, 0x05,
+          0x18, 0x51, 0xD4, 0x02, 0xE0, 0x04, 0x17, 0xDB, 0xF5, 0x01,
+          0x18, 0x47, 0xE0, 0x04, 0x17, 0xFC, 0xF4, 0x05, 0x18, 0x51,
+          0xD4, 0x03, 0xE0, 0x04, 0x17, 0xDB, 0xF5, 0x01, 0x18, 0x50,
+          0xE0, 0x04, 0x17, 0xFC, 0xF4, 0x05, 0x18, 0x51, 0xD4, 0x00,
+          0xA1, 0x41, 0xE0, 0x04, 0x18, 0x29, 0xC3, 0x04, 0xF3, 0x09,
+          0xB0, 0x02, 0xF0, 0x01, 0x18, 0x5B, 0xF1, 0x05, 0x18, 0x32,
+          0xE0, 0x04, 0x18, 0xF9, 0xF0, 0x02, 0xD0, 0x1F, 0xD2, 0x00,
+          0xD1, 0xFF, 0xE0, 0x00, 0x1F, 0x2F, 0xC3, 0x16, 0xF3, 0x09,
+          0xD2, 0x01, 0xE0, 0x00, 0x1F, 0x2F, 0xF0, 0x02, 0xD0, 0x2B,
+          0xE0, 0x00, 0x1E, 0xC8, 0xD3, 0xFF, 0xF3, 0x09, 0xF0, 0x02,
+          0xD7, 0x0F, 0xD8, 0x02, 0xC8, 0x02, 0xD9, 0x70, 0xC9, 0xC3,
+          0xE0, 0x07, 0x1F, 0x36, 0xE0, 0x07, 0x18, 0x5E, 0xD3, 0x10,
+          0xD0, 0x00, 0xD1, 0x00, 0xD2, 0x00, 0xD7, 0x0F, 0xE0, 0x07,
+          0x1E, 0xD4, 0xD5, 0xFF, 0x24, 0xD5, 0x01, 0x14, 0x84, 0x89,
+          0x84, 0x49, 0x02, 0x24, 0x24, 0xC5, 0x00, 0x04, 0xD5, 0xFF,
+          0xF5, 0x09, 0xB3, 0x32, 0xF3, 0x05, 0x18, 0x7C, 0xD6, 0x95,
+          0x80, 0x09, 0xF6, 0x0C, 0xA6, 0x63, 0x81, 0x19, 0xF6, 0x1C,
+          0xA6, 0x63, 0x82, 0x29, 0xF6, 0x2C, 0xD6, 0x2A, 0xC6, 0x03,
+          0xD5, 0xFA, 0x15, 0x50, 0xF6, 0x5C, 0xA6, 0x63, 0xD5, 0xFA,
+          0x15, 0x51, 0xB5, 0x56, 0xF6, 0x5C, 0xA6, 0x63, 0xD5, 0xFA,
+          0x15, 0x52, 0xB5, 0x56, 0xF6, 0x5C, 0xD7, 0x0F, 0xD8, 0x83,
+          0xC8, 0x7F, 0xD9, 0x77, 0xC9, 0xC3, 0xE0, 0x07, 0x1F, 0x36,
+          0xF0, 0x02, 0xD1, 0x09, 0xC1, 0x03, 0xD2, 0x04, 0x41, 0x20,
+          0xF4, 0x18, 0xD3, 0x1D, 0xE0, 0x03, 0x1E, 0xC8, 0xD3, 0x00,
+          0xD4, 0x98, 0xF4, 0x3C, 0xA5, 0x31, 0xA4, 0x47, 0xA1, 0x13,
+          0xF3, 0x18, 0xB2, 0x22, 0xF2, 0x05, 0x18, 0xB6, 0xE0, 0x03,
+          0x18, 0x29, 0xE0, 0x00, 0x1E, 0xE1, 0xD1, 0x4E, 0xF1, 0x18,
+          0xF1, 0x01, 0x18, 0xD5, 0xA5, 0x11, 0xD3, 0x0E, 0xD4, 0xB8,
+          0xE0, 0x03, 0x1F, 0x0B, 0x85, 0x19, 0xD3, 0x08, 0xD4, 0xCB,
+          0xE0, 0x03, 0x1F, 0x0B, 0x85, 0x1D, 0xD3, 0x10, 0xD4, 0x88,
+          0xE0, 0x03, 0x1F, 0x2F, 0xD5, 0x00, 0xD3, 0x04, 0xD4, 0x74,
+          0xE0, 0x03, 0x1F, 0x0B, 0xD5, 0x00, 0xD3, 0x05, 0xD4, 0xBB,
+          0xE0, 0x03, 0x1F, 0x2F, 0xE0, 0x00, 0x18, 0x5E, 0xE0, 0x00,
+          0x18, 0x69, 0xF0, 0x02, 0xD1, 0x89, 0xD3, 0x03, 0x41, 0x03,
+          0xF2, 0x18, 0xD1, 0x2A, 0xC1, 0x03, 0x01, 0x10, 0xF3, 0x18,
+          0x5C, 0xEF, 0xF0, 0x02, 0xE0, 0x00, 0x14, 0xDC, 0xC1, 0x18,
+          0xF1, 0x09, 0xF0, 0x19, 0x18, 0xF8, 0xD1, 0x00, 0xF0, 0x1C,
+          0xE0, 0x00, 0x18, 0x5E, 0xF0, 0x02, 0xD3, 0x04, 0xD1, 0x89,
+          0xD2, 0x9B, 0xC2, 0x03, 0xF0, 0x18, 0xF2, 0x0C, 0xA1, 0x17,
+          0xA2, 0x23, 0xB3, 0x32, 0xF3, 0x05, 0x18, 0xFD, 0xD1, 0x9A,
+          0xC1, 0x03, 0xF1, 0x3C, 0xF0, 0x02, 0xD1, 0x9A, 0xC1, 0x03,
+          0xF0, 0x18, 0xF0, 0x01, 0x19, 0x0F, 0xE0, 0x00, 0x18, 0xF9,
+          0xD1, 0x92, 0xF4, 0x18, 0xD2, 0x9F, 0xC2, 0x03, 0xF5, 0x28,
+          0xD0, 0x07, 0x20, 0x05, 0x00, 0x04, 0xA0, 0x09, 0x80, 0x07,
+          0xF1, 0x0C, 0xF2, 0x0C, 0xF0, 0x02, 0xD2, 0x00, 0xD3, 0x87,
+          0xD4, 0x02, 0xE0, 0x02, 0x1F, 0x0B, 0xD2, 0x06, 0xD3, 0xD4,
+          0xD4, 0x3F, 0xE0, 0x02, 0x1F, 0x0B, 0xD2, 0x04, 0xD3, 0x30,
+          0xD4, 0x04, 0xE0, 0x02, 0x1F, 0x0B, 0xD2, 0x05, 0xD3, 0x52,
+          0xD4, 0x00, 0xE0, 0x02, 0x1F, 0x0B, 0xD3, 0x10, 0xE0, 0x02,
+          0x1F, 0x0B, 0xD2, 0x06, 0xD3, 0xFE, 0xD4, 0x01, 0xE0, 0x02,
+          0x1F, 0x0B, 0xD2, 0x07, 0xD3, 0x00, 0xD4, 0x00, 0xE0, 0x02,
+          0x1F, 0x0B, 0xD2, 0x07, 0xD3, 0x31, 0xD4, 0x01, 0xE0, 0x02,
+          0x1F, 0x0B, 0xD2, 0x05, 0xD3, 0xFE, 0xD4, 0x00, 0xE0, 0x02,
+          0x1F, 0x0B, 0xD2, 0x05, 0xD3, 0x76, 0xD4, 0x02, 0xE0, 0x02,
+          0x1F, 0x2F, 0xF0, 0x02, 0xD2, 0x00, 0xA3, 0x02, 0xD5, 0x03,
+          0x23, 0x35, 0xD4, 0x45, 0xF5, 0x48, 0x95, 0x55, 0x03, 0x35,
+          0xD4, 0x3A, 0xF4, 0x48, 0x84, 0x49, 0xD5, 0x10, 0xC5, 0x0E,
+          0x4D, 0xC9, 0x03, 0x35, 0xD4, 0x2D, 0xC4, 0x06, 0x04, 0x43,
+          0xF8, 0x48, 0xD6, 0x06, 0xD7, 0xD4, 0xE0, 0x06, 0x1F, 0x0B,
+          0xA1, 0x01, 0xD5, 0x5D, 0x5D, 0x1D, 0xF5, 0x01, 0x19, 0x8F,
+          0xD4, 0x33, 0xC4, 0x06, 0x04, 0x41, 0xF3, 0x48, 0x85, 0x3F,
+          0x85, 0x5F, 0x88, 0x39, 0xD6, 0x06, 0xD7, 0x96, 0xE0, 0x06,
+          0x1F, 0x0B, 0xF5, 0x01, 0x19, 0x8E, 0x88, 0x39, 0x88, 0x89,
+          0xD6, 0x03, 0xD7, 0xB9, 0xE0, 0x06, 0x1F, 0x2F, 0xD2, 0x01,
+          0xD4, 0x45, 0xF5, 0x48, 0x95, 0x55, 0xF5, 0x01, 0x19, 0x89,
+          0x88, 0x35, 0xD6, 0x06, 0xD7, 0x54, 0xE0, 0x06, 0x1F, 0x0B,
+          0xF0, 0x19, 0x19, 0x8E, 0xA8, 0x31, 0xD6, 0x06, 0xD7, 0xDA,
+          0xE0, 0x06, 0x1F, 0x0B, 0xD1, 0x5C, 0xD4, 0x33, 0xC4, 0x06,
+          0x04, 0x41, 0xF3, 0x48, 0xD5, 0x0F, 0x2E, 0x3D, 0xE0, 0x06,
+          0x1B, 0x65, 0x83, 0x39, 0xD5, 0x03, 0x2C, 0x35, 0xD6, 0x05,
+          0xD7, 0x10, 0xE0, 0x06, 0x1F, 0x0B, 0x83, 0x35, 0xD5, 0x03,
+          0x2C, 0x35, 0x85, 0x84, 0x1C, 0x85, 0xD6, 0x05, 0xD7, 0x52,
+          0xE0, 0x06, 0x1F, 0x0B, 0x83, 0x35, 0xA8, 0x31, 0xD6, 0x04,
+          0xD7, 0x74, 0xE0, 0x06, 0x1F, 0x0B, 0x88, 0x39, 0xD6, 0x05,
+          0xD7, 0xBB, 0xE0, 0x06, 0x1F, 0x2F, 0x83, 0x3D, 0xD5, 0x01,
+          0x2D, 0xD3, 0xF5, 0x01, 0x19, 0xC4, 0xD4, 0x72, 0xF5, 0x48,
+          0xD4, 0xA1, 0xC4, 0x06, 0xF4, 0x48, 0x1D, 0xD8, 0xF5, 0x05,
+          0x19, 0xC4, 0xD8, 0x08, 0xD6, 0x05, 0xD7, 0x52, 0xE0, 0x06,
+          0x1F, 0x0B, 0xF2, 0x05, 0x19, 0xD3, 0x83, 0x33, 0xD8, 0x07,
+          0xD6, 0x03, 0x18, 0x83, 0xD5, 0x0F, 0x15, 0x05, 0xF5, 0x05,
+          0x19, 0xD0, 0x18, 0x83, 0x18, 0x83, 0xD7, 0xB9, 0xE0, 0x06,
+          0x1F, 0x2F, 0xD4, 0x78, 0xF4, 0x0C, 0xF0, 0x02, 0xD2, 0x72,
+          0xF0, 0x28, 0xF0, 0x05, 0x19, 0xED, 0xD2, 0x9B, 0xF4, 0x28,
+          0xD1, 0x47, 0x5C, 0xC1, 0xA2, 0x27, 0xA0, 0x41, 0xA2, 0x27,
+          0xF3, 0x28, 0xD1, 0x01, 0x4D, 0xDF, 0x2C, 0xCD, 0xD2, 0x92,
+          0xF3, 0x28, 0xD1, 0x2C, 0xC1, 0x01, 0x4D, 0xDF, 0x2C, 0xCD,
+          0xF0, 0x19, 0x19, 0xF8, 0xD2, 0x9B, 0xF4, 0x28, 0xD1, 0x4F,
+          0xD5, 0x16, 0x11, 0x15, 0x5C, 0xC1, 0xA2, 0x2D, 0xF3, 0x28,
+          0xD1, 0x12, 0x4D, 0xDF, 0x2C, 0x4D, 0xD2, 0x72, 0xF2, 0x0C,
+          0xF0, 0x02, 0xD2, 0xA1, 0xC2, 0x06, 0xF0, 0x28, 0xD4, 0x9B,
+          0xF4, 0x48, 0xD5, 0x89, 0xF5, 0x58, 0xD3, 0x92, 0xF3, 0x38,
+          0xF0, 0x05, 0x1A, 0x10, 0xD1, 0x64, 0x4F, 0xDF, 0xD1, 0x2A,
+          0x4C, 0xC1, 0xD1, 0xC8, 0x4D, 0xD1, 0x20, 0xDC, 0x2C, 0xCF,
+          0xF0, 0x19, 0x1A, 0x1C, 0xD1, 0x90, 0xC1, 0x01, 0x4F, 0xFD,
+          0xD1, 0x16, 0x4C, 0x1C, 0xD1, 0xB4, 0x4D, 0x1D, 0x10, 0xDC,
+          0x1C, 0xCF, 0xF0, 0x01, 0x1A, 0x1F, 0xD0, 0x00, 0xD2, 0xA1,
+          0xC2, 0x06, 0xF2, 0x0C, 0xF0, 0x02, 0xE0, 0x00, 0x19, 0xD6,
+          0xD1, 0x4F, 0xD2, 0x9C, 0xF0, 0x05, 0x1A, 0x27, 0xD1, 0x6A,
+          0xF2, 0x1C, 0xF0, 0x02, 0x44, 0xDC, 0xF4, 0x05, 0x1A, 0x40,
+          0xD4, 0x01, 0x7F, 0xC4, 0x7C, 0x1C, 0x13, 0x43, 0x61, 0x13,
+          0xA2, 0x31, 0x6C, 0xCD, 0xB2, 0x22, 0xA4, 0x20, 0xF4, 0x05,
+          0x1A, 0x32, 0xA1, 0x01, 0xD4, 0x0F, 0x14, 0x43, 0x60, 0x04,
+          0x70, 0x04, 0xA4, 0x33, 0x71, 0x14, 0xF0, 0x19, 0x1A, 0x42,
+          0xA1, 0x01, 0xD0, 0x00, 0xF0, 0x02, 0xA2, 0x01, 0xA3, 0x11,
+          0xE0, 0x02, 0x1A, 0x29, 0xD6, 0x08, 0x60, 0x26, 0xD4, 0x01,
+          0x7D, 0x3C, 0xB5, 0x52, 0x4C, 0xE9, 0xF4, 0x05, 0x1A, 0x50,
+          0xD5, 0x08, 0x16, 0x65, 0x62, 0x35, 0x73, 0x16, 0xE0, 0x02,
+          0x1A, 0x29, 0xD4, 0xFF, 0x4C, 0x2C, 0xF4, 0x01, 0x1A, 0x5A,
+          0xD2, 0xFF, 0x1C, 0xCE, 0xF0, 0x02, 0xD6, 0xFF, 0x2E, 0xC6,
+          0x2C, 0x1E, 0x27, 0x24, 0xD6, 0x08, 0x75, 0x76, 0x73, 0x06,
+          0x27, 0x34, 0x05, 0x57, 0x74, 0x16, 0x27, 0x24, 0x05, 0x57,
+          0x85, 0x5F, 0x27, 0x34, 0x87, 0x72, 0x00, 0x57, 0xF0, 0x02,
+          0x94, 0x01, 0xF4, 0x05, 0x1A, 0x73, 0xD0, 0x00, 0xF0, 0x19,
+          0x1A, 0xA6, 0xD7, 0xFF, 0xC7, 0x1F, 0x4C, 0x0F, 0xF4, 0x01,
+          0x1A, 0x79, 0xA0, 0x71, 0xD4, 0x01, 0x7D, 0x0C, 0xD8, 0x10,
+          0x18, 0x85, 0xD7, 0xF0, 0xC7, 0x02, 0xF4, 0x78, 0x28, 0x84,
+          0xB5, 0x56, 0x60, 0x05, 0xD5, 0x00, 0xC5, 0x20, 0xD6, 0x0C,
+          0xD4, 0x00, 0xC4, 0x20, 0x04, 0x45, 0xD1, 0x00, 0xC1, 0x20,
+          0x2D, 0xDC, 0xF1, 0x05, 0x1A, 0x9A, 0x81, 0x04, 0x31, 0x14,
+          0xD4, 0x00, 0xC4, 0x20, 0x4C, 0x1C, 0xF4, 0x05, 0x1A, 0x9A,
+          0xA0, 0x11, 0xF4, 0x78, 0x18, 0x84, 0xF0, 0x19, 0x1A, 0x86,
+          0xA7, 0x73, 0x85, 0x53, 0xB6, 0x62, 0xF6, 0x05, 0x1A, 0x86,
+          0xD4, 0x00, 0xC4, 0x20, 0x14, 0x40, 0x84, 0x47, 0x18, 0x84,
+          0xA8, 0x83, 0x80, 0x83, 0xF0, 0x02, 0x4E, 0xCD, 0xF1, 0x0D,
+          0x4F, 0xDC, 0x10, 0x23, 0xF0, 0x02, 0xE0, 0x00, 0x1A, 0xE3,
+          0xE0, 0x00, 0x1A, 0xF0, 0xD5, 0xCE, 0xC5, 0x03, 0xF2, 0x58,
+          0xA5, 0x53, 0x05, 0x52, 0xF1, 0x58, 0xD5, 0x45, 0xF5, 0x1C,
+          0xD5, 0x44, 0xC5, 0x01, 0x86, 0x22, 0x05, 0x56, 0xF3, 0x58,
+          0xA5, 0x53, 0xF4, 0x58, 0xA7, 0x41, 0xA8, 0x31, 0xE0, 0x07,
+          0x1A, 0x43, 0x83, 0x76, 0x87, 0x78, 0x33, 0x37, 0xD7, 0x00,
+          0xC7, 0x01, 0x13, 0x37, 0xA7, 0x41, 0xA8, 0x01, 0xE0, 0x07,
+          0x1A, 0x43, 0xA4, 0x71, 0x84, 0x76, 0x87, 0x78, 0x34, 0x47,
+          0xD7, 0x00, 0xC7, 0x01, 0x14, 0x47, 0xA7, 0x41, 0xA8, 0x31,
+          0xE0, 0x07, 0x1A, 0x43, 0xD3, 0x7F, 0x23, 0x37, 0x83, 0x3D,
+          0xA3, 0x35, 0x83, 0x35, 0xD5, 0x44, 0xF5, 0x3C, 0xA7, 0x01,
+          0xE0, 0x07, 0x1B, 0x01, 0xF0, 0x02, 0xD3, 0x46, 0xC3, 0x01,
+          0xF2, 0x38, 0x55, 0xEC, 0x12, 0x20, 0x40, 0x52, 0xD5, 0x05,
+          0x03, 0x35, 0xF2, 0x38, 0x55, 0xCE, 0x12, 0x20, 0x40, 0x52,
+          0xF0, 0x02, 0xD2, 0x02, 0xD4, 0x4A, 0xC4, 0x01, 0xF3, 0x48,
+          0x4F, 0xCF, 0xF3, 0x05, 0x1A, 0xFC, 0xB4, 0x44, 0xB2, 0x22,
+          0xA6, 0x22, 0xF6, 0x05, 0x1A, 0xF3, 0xA2, 0x23, 0xD4, 0xCE,
+          0xC4, 0x03, 0xF4, 0x2C, 0xF0, 0x02, 0xD4, 0x45, 0xF1, 0x48,
+          0xD5, 0x0F, 0xE0, 0x05, 0x1B, 0x65, 0xA7, 0x11, 0xD5, 0x02,
+          0xD6, 0x20, 0xE0, 0x05, 0x1F, 0x0B, 0xD4, 0x44, 0xF2, 0x48,
+          0x95, 0x1B, 0xF5, 0x05, 0x1B, 0x33, 0xA7, 0x21, 0xD5, 0x02,
+          0xD6, 0x93, 0xE0, 0x05, 0x1F, 0x0B, 0xD3, 0x01, 0xD5, 0xB0,
+          0xC5, 0x04, 0x4D, 0x0D, 0xF5, 0x05, 0x1B, 0x3D, 0x95, 0x15,
+          0xF5, 0x05, 0x1B, 0x23, 0x80, 0x27, 0x84, 0x29, 0xA2, 0x41,
+          0xF0, 0x19, 0x1B, 0x26, 0xD2, 0x01, 0xD4, 0x01, 0xD0, 0x00,
+          0x84, 0x46, 0x07, 0x42, 0xD5, 0x02, 0xD6, 0xFA, 0xE0, 0x05,
+          0x1F, 0x0B, 0xA7, 0x01, 0xD5, 0x03, 0xD6, 0x85, 0xE0, 0x05,
+          0x1F, 0x0B, 0xF0, 0x19, 0x1B, 0x3E, 0xA7, 0x21, 0xD5, 0x02,
+          0xD6, 0xFA, 0xE0, 0x05, 0x1F, 0x0B, 0x87, 0x2D, 0xD5, 0x03,
+          0xD6, 0x00, 0xE0, 0x05, 0x1F, 0x0B, 0xD3, 0x02, 0xD7, 0x00,
+          0xB5, 0x32, 0xF5, 0x05, 0x1B, 0x43, 0xD7, 0x01, 0xD5, 0x06,
+          0xD6, 0x11, 0xE0, 0x05, 0x1F, 0x0B, 0xD7, 0x01, 0x95, 0x17,
+          0xF5, 0x01, 0x1B, 0x4C, 0xD7, 0x04, 0xD5, 0x04, 0xD6, 0xDB,
+          0xE0, 0x05, 0x1F, 0x0B, 0xA7, 0x31, 0xD5, 0x07, 0xD6, 0x64,
+          0xE0, 0x05, 0x1F, 0x2F, 0xD4, 0x38, 0xF4, 0x3C, 0xE0, 0x05,
+          0x1B, 0x73, 0xD4, 0xE0, 0xC4, 0x03, 0x04, 0x43, 0xF7, 0x48,
+          0xD4, 0xE3, 0xC4, 0x03, 0xF4, 0x7C, 0xD5, 0x08, 0xD6, 0xA8,
+          0xE0, 0x05, 0x1F, 0x2F, 0xF0, 0x02, 0xD4, 0x45, 0xF1, 0x48,
+          0xA1, 0x1A, 0xD5, 0x44, 0x25, 0x51, 0xD6, 0x41, 0x06, 0x65,
+          0xA7, 0x01, 0xD5, 0x03, 0xE0, 0x05, 0x1F, 0x0B, 0xD4, 0x4D,
+          0xF4, 0x0C, 0xF0, 0x02, 0xD4, 0x45, 0xF1, 0x48, 0xD5, 0x02,
+          0x5F, 0xD1, 0xD5, 0x05, 0xD6, 0xEE, 0xE0, 0x05, 0x1F, 0x0B,
+          0xF0, 0x02, 0xD2, 0x25, 0xC2, 0x04, 0xF1, 0x28, 0xA1, 0x13,
+          0x83, 0x1F, 0x83, 0x35, 0xF3, 0x05, 0x1B, 0x87, 0xF2, 0x1C,
+          0x02, 0x21, 0xF2, 0x0C, 0xF0, 0x02, 0xD5, 0x0D, 0xC5, 0xE0,
+          0xD6, 0x3C, 0xC6, 0x17, 0xD7, 0x23, 0xC7, 0x42, 0xE0, 0x05,
+          0x1E, 0xAF, 0xD6, 0x01, 0xD5, 0x21, 0xE0, 0x05, 0x1E, 0xC8,
+          0xD6, 0x10, 0xD5, 0x24, 0xE0, 0x05, 0x1E, 0xC8, 0xE0, 0x05,
+          0x11, 0xF9, 0xD6, 0x00, 0xD5, 0x32, 0xE0, 0x05, 0x1E, 0xC8,
+          0xD1, 0x00, 0xD0, 0x00, 0xD6, 0xC2, 0xC6, 0x01, 0xD5, 0x33,
+          0xE0, 0x05, 0x1E, 0xCC, 0xD2, 0x00, 0xC2, 0x01, 0xB2, 0x22,
+          0xD3, 0xA0, 0xF3, 0x09, 0xD5, 0x0A, 0xE0, 0x05, 0x1E, 0xD0,
+          0xA1, 0x01, 0xA0, 0x61, 0xD3, 0x00, 0xC3, 0x20, 0x4F, 0xCF,
+          0xF3, 0x05, 0x1B, 0xE0, 0xD3, 0xFD, 0x47, 0xEF, 0xF7, 0x05,
+          0x1B, 0xA7, 0x13, 0x23, 0xF3, 0x05, 0x1B, 0xD0, 0xD6, 0x78,
+          0xC6, 0x05, 0xD3, 0x12, 0xC3, 0x02, 0x4F, 0xCF, 0xF3, 0x05,
+          0x1B, 0xCB, 0xD3, 0x35, 0xC3, 0x02, 0x16, 0x30, 0xA5, 0x01,
+          0xE0, 0x05, 0x1A, 0x43, 0xD3, 0x00, 0xC3, 0x2D, 0x36, 0x35,
+          0xD5, 0x33, 0xE0, 0x05, 0x1E, 0xCC, 0xD1, 0x00, 0xA0, 0x61,
+          0xF0, 0x01, 0x1B, 0xA7, 0x11, 0x01, 0xF1, 0x01, 0x1B, 0xE0,
+          0x93, 0x11, 0xF3, 0x05, 0x1B, 0xD9, 0xF1, 0x0D, 0x83, 0x09,
+          0x83, 0x39, 0x4F, 0xDF, 0xF3, 0x01, 0x1B, 0xE0, 0xF2, 0x05,
+          0x1B, 0xA7, 0x80, 0x03, 0xF0, 0x02, 0xD4, 0x0F, 0x2F, 0x0C,
+          0xD5, 0x0D, 0xD6, 0xA7, 0xE0, 0x05, 0x1F, 0x0B, 0x87, 0x09,
+          0xD5, 0x09, 0xD6, 0x33, 0xE0, 0x05, 0x1F, 0x2F, 0xE0, 0x05,
+          0x18, 0x5E, 0xF0, 0x02, 0xD1, 0x5C, 0xF2, 0x18, 0xC1, 0x10,
+          0xF1, 0x09, 0xD5, 0x06, 0xE0, 0x05, 0x1E, 0xD4, 0x83, 0x73,
+          0x84, 0x75, 0xD1, 0x01, 0x2F, 0xFD, 0x2C, 0xC1, 0x3D, 0xF4,
+          0xF1, 0x05, 0x1C, 0x10, 0x84, 0x42, 0xB4, 0x42, 0x02, 0x24,
+          0xD1, 0x1F, 0x57, 0xED, 0x11, 0x12, 0x42, 0x71, 0x97, 0x21,
+          0x22, 0x27, 0xA7, 0x21, 0xD5, 0x0D, 0xD6, 0xFB, 0xE0, 0x05,
+          0x1F, 0x2F, 0xB0, 0x02, 0xF0, 0x05, 0x1B, 0xF2, 0xA0, 0x11,
+          0xD1, 0x5C, 0xF1, 0x2C, 0xF0, 0x02, 0xD6, 0x04, 0xD4, 0x07,
+          0xD5, 0x64, 0xE0, 0x04, 0x1F, 0x0B, 0xD6, 0x02, 0xD4, 0x08,
+          0xD5, 0xA8, 0xE0, 0x04, 0x1F, 0x0B, 0xD6, 0x01, 0xD4, 0x09,
+          0xD5, 0x22, 0xE0, 0x04, 0x1F, 0x0B, 0xD5, 0x1C, 0x82, 0x02,
+          0x15, 0x25, 0xE0, 0x04, 0x1E, 0xDC, 0xD3, 0x60, 0xF2, 0x38,
+          0xA2, 0x2F, 0xA2, 0x2F, 0x10, 0x20, 0xA1, 0x01, 0xD3, 0x10,
+          0xD4, 0x90, 0xC4, 0x06, 0xD5, 0x05, 0x5E, 0x1C, 0xF6, 0x05,
+          0x1C, 0x3A, 0x81, 0x12, 0x83, 0x33, 0xB5, 0x52, 0xF5, 0x05,
+          0x1C, 0x32, 0xB6, 0x14, 0xD4, 0x0C, 0xD5, 0xB0, 0xE0, 0x04,
+          0x1F, 0x0B, 0xD5, 0xDC, 0xD6, 0x03, 0xE0, 0x04, 0x1F, 0x0B,
+          0xD6, 0x01, 0xD4, 0x00, 0xD5, 0xBB, 0xE0, 0x04, 0x1F, 0x0B,
+          0xA6, 0x31, 0xD4, 0x0C, 0xD5, 0xFE, 0xE0, 0x04, 0x1F, 0x0B,
+          0x86, 0x35, 0xD4, 0x0D, 0xD5, 0x20, 0xE0, 0x04, 0x1F, 0x0B,
+          0xD2, 0x60, 0x36, 0x12, 0xA6, 0x63, 0xD4, 0x0D, 0xD5, 0x63,
+          0xE0, 0x04, 0x1F, 0x2F, 0xD2, 0xD8, 0x36, 0x12, 0xD3, 0x5C,
+          0xF3, 0x6C, 0xD4, 0x0D, 0xD5, 0xFB, 0xE0, 0x04, 0x1F, 0x2F,
+          0xF0, 0x02, 0xD4, 0x0C, 0xD5, 0xFC, 0xD6, 0x00, 0xE0, 0x04,
+          0x1F, 0x0B, 0xD6, 0x00, 0xD4, 0x00, 0xD5, 0xBB, 0xE0, 0x04,
+          0x1F, 0x0B, 0xD6, 0x00, 0xD4, 0x09, 0xD5, 0x22, 0xE0, 0x04,
+          0x1F, 0x0B, 0xD6, 0x02, 0xD5, 0x87, 0xD4, 0x00, 0xE0, 0x04,
+          0x1F, 0x0B, 0xD6, 0x01, 0xD4, 0x0E, 0xD5, 0x44, 0xE0, 0x04,
+          0x1F, 0x0B, 0xD6, 0x00, 0xD4, 0x06, 0xD5, 0x33, 0xE0, 0x04,
+          0x1F, 0x2F, 0xF0, 0x02, 0xD2, 0x86, 0xD0, 0x3C, 0xF1, 0x08,
+          0xF2, 0x1C, 0xD1, 0x0A, 0xC1, 0x90, 0xF0, 0x1C, 0xA2, 0x23,
+          0xA0, 0x03, 0xF1, 0x08, 0xF2, 0x1C, 0xD1, 0xBC, 0xC1, 0x55,
+          0xF0, 0x1C, 0xA2, 0x23, 0xD0, 0x5E, 0xF1, 0x08, 0xF2, 0x1C,
+          0xD1, 0x08, 0xF0, 0x1C, 0xE0, 0x03, 0x0F, 0x8D, 0xE0, 0x03,
+          0x0E, 0x94, 0xD5, 0xA8, 0xC5, 0x66, 0xD3, 0x17, 0xD4, 0xF0,
+          0xE0, 0x03, 0x1F, 0x0B, 0xE0, 0x03, 0x1F, 0x57, 0xE0, 0x03,
+          0x10, 0x44, 0xE0, 0x03, 0x12, 0x03, 0xD0, 0xED, 0xD1, 0x02,
+          0xF0, 0x1C, 0xE0, 0x03, 0x12, 0xD5, 0xE0, 0x03, 0x10, 0x44,
+          0xD5, 0x00, 0xD3, 0x0E, 0xD4, 0x44, 0xE0, 0x03, 0x1F, 0x0B,
+          0xD3, 0x02, 0xD4, 0x94, 0xC4, 0x02, 0xE0, 0x03, 0x0E, 0x62,
+          0xD1, 0x00, 0xD0, 0x5F, 0xF0, 0x1C, 0xD0, 0x5D, 0xF0, 0x1C,
+          0xE0, 0x03, 0x14, 0xCB, 0xD3, 0x00, 0xC3, 0x20, 0xE0, 0x03,
+          0x13, 0x06, 0xD5, 0x00, 0xD3, 0x00, 0xD4, 0x87, 0xE0, 0x03,
+          0x1F, 0x2F, 0xD5, 0x01, 0xD3, 0x06, 0xD4, 0x33, 0xE0, 0x03,
+          0x1F, 0x0B, 0xD3, 0x4F, 0xF3, 0x38, 0xE0, 0x03, 0x1B, 0xE2,
+          0xE0, 0x03, 0x1F, 0xF1, 0xD5, 0x00, 0xD3, 0x02, 0xD4, 0x20,
+          0xE0, 0x03, 0x1F, 0x2F, 0xD5, 0x00, 0xD3, 0x06, 0xD4, 0x11,
+          0xE0, 0x03, 0x1F, 0x2F, 0xF0, 0x02, 0xD6, 0x41, 0xD5, 0x10,
+          0xE0, 0x05, 0x1E, 0xC8, 0xD5, 0x11, 0xC5, 0xE0, 0xD7, 0x03,
+          0xD6, 0x36, 0xC6, 0x02, 0xE0, 0x05, 0x1E, 0xAF, 0xD7, 0x6A,
+          0xC7, 0x14, 0xD6, 0xA9, 0xC6, 0x14, 0xE0, 0x05, 0x1E, 0xAF,
+          0xD7, 0x49, 0xC7, 0x4C, 0xD6, 0x2F, 0xC6, 0x0D, 0xE0, 0x05,
+          0x1E, 0xAF, 0xD5, 0x0D, 0xC5, 0xE0, 0xD6, 0x3C, 0xC6, 0x17,
+          0xD7, 0x23, 0xC7, 0x42, 0xE0, 0x05, 0x1E, 0xAF, 0xD6, 0xFF,
+          0xC6, 0x05, 0xD5, 0x3B, 0xE0, 0x05, 0x1E, 0xCC, 0xD6, 0x03,
+          0xD5, 0x1E, 0xE0, 0x05, 0x1E, 0xC8, 0xD6, 0x00, 0xD5, 0x21,
+          0xE0, 0x05, 0x1E, 0xC8, 0xD6, 0x04, 0xD5, 0x27, 0xE0, 0x05,
+          0x1E, 0xC8, 0xD6, 0x31, 0xD5, 0x35, 0xE0, 0x05, 0x1E, 0xC8,
+          0xD6, 0x10, 0xD5, 0x24, 0xE0, 0x05, 0x1E, 0xC8, 0xE0, 0x05,
+          0x11, 0xF9, 0xF0, 0x02, 0xD2, 0x00, 0xE0, 0x02, 0x1D, 0xF8,
+          0xA7, 0x21, 0xE0, 0x07, 0x1B, 0x7C, 0xA0, 0x21, 0xF0, 0x02,
+          0xE0, 0x04, 0x1F, 0x6C, 0xA5, 0x31, 0xE0, 0x05, 0x1F, 0x66,
+          0xE0, 0x05, 0x1D, 0x17, 0x4E, 0xD2, 0xF6, 0x01, 0x1D, 0x2C,
+          0xA2, 0x51, 0xA0, 0x31, 0xA1, 0x41, 0xF0, 0x02, 0xD2, 0x80,
+          0xD3, 0x80, 0xD6, 0x00, 0xD7, 0x80, 0xD8, 0x80, 0xDA, 0x00,
+          0xCA, 0x71, 0xE0, 0x0A, 0x1B, 0x7C, 0xD7, 0x60, 0xD8, 0x60,
+          0xE0, 0x04, 0x1D, 0x1F, 0xD7, 0xA0, 0xD8, 0x60, 0xE0, 0x04,
+          0x1D, 0x1F, 0xD7, 0x60, 0xD8, 0xA0, 0xE0, 0x04, 0x1D, 0x1F,
+          0xD7, 0xA0, 0xD8, 0xA0, 0xE0, 0x04, 0x1D, 0x1F, 0xD7, 0x70,
+          0xD8, 0x70, 0xE0, 0x04, 0x1D, 0x1F, 0xD7, 0x90, 0xD8, 0x70,
+          0xE0, 0x04, 0x1D, 0x1F, 0xD7, 0x70, 0xD8, 0x90, 0xE0, 0x04,
+          0x1D, 0x1F, 0xD7, 0x90, 0xD8, 0x90, 0xE0, 0x04, 0x1D, 0x1F,
+          0xD7, 0x80, 0xD8, 0x80, 0xE0, 0x04, 0x1D, 0x1F, 0xA3, 0x51,
+          0xD7, 0x80, 0xA8, 0x31, 0xE0, 0x04, 0x1D, 0x1F, 0xDA, 0x00,
+          0xCA, 0x81, 0x0A, 0xA2, 0xE0, 0x0A, 0x1B, 0x7C, 0xDA, 0x00,
+          0xCA, 0x82, 0x0A, 0xA3, 0xE0, 0x0A, 0x1B, 0x7C, 0xD0, 0x01,
+          0xD1, 0x20, 0xA8, 0x31, 0x27, 0x10, 0x17, 0x27, 0xDA, 0x00,
+          0xCA, 0x81, 0x0A, 0xA7, 0xE0, 0x0A, 0x1B, 0x7C, 0xE0, 0x04,
+          0x1D, 0x1F, 0x27, 0x10, 0x07, 0x27, 0xDA, 0x00, 0xCA, 0x81,
+          0x0A, 0xA7, 0xE0, 0x0A, 0x1B, 0x7C, 0xE0, 0x04, 0x1D, 0x1F,
+          0xA0, 0x03, 0xD9, 0x04, 0x2D, 0x90, 0xF9, 0x01, 0x1D, 0x6C,
+          0xA2, 0x41, 0xDA, 0x00, 0xCA, 0x87, 0x0A, 0xA2, 0xE0, 0x0A,
+          0x1B, 0x7C, 0xDA, 0xFF, 0xCA, 0xFF, 0xE0, 0x0A, 0x1B, 0x7C,
+          0xD1, 0x10, 0x17, 0x21, 0xDA, 0x00, 0xCA, 0x81, 0x0A, 0xA7,
+          0xE0, 0x0A, 0x1B, 0x7C, 0xE0, 0x04, 0x1D, 0x1F, 0x07, 0x21,
+          0xDA, 0x00, 0xCA, 0x81, 0x0A, 0xA7, 0xE0, 0x0A, 0x1B, 0x7C,
+          0xE0, 0x04, 0x1D, 0x1F, 0xA2, 0x41, 0xDA, 0x00, 0xCA, 0x87,
+          0x0A, 0xA2, 0xE0, 0x0A, 0x1B, 0x7C, 0x81, 0x13, 0xF1, 0x05,
+          0x1D, 0x8E, 0xDA, 0xFF, 0xCA, 0xFF, 0xE0, 0x0A, 0x1B, 0x7C,
+          0xD0, 0x01, 0xD1, 0x20, 0xA7, 0x21, 0x28, 0x10, 0x18, 0x38,
+          0xDA, 0x00, 0xCA, 0x82, 0x0A, 0xA8, 0xE0, 0x0A, 0x1B, 0x7C,
+          0xE0, 0x04, 0x1D, 0x1F, 0x28, 0x10, 0x08, 0x38, 0xDA, 0x00,
+          0xCA, 0x82, 0x0A, 0xA8, 0xE0, 0x0A, 0x1B, 0x7C, 0xE0, 0x04,
+          0x1D, 0x1F, 0xA0, 0x03, 0xD9, 0x04, 0x2D, 0x90, 0xF9, 0x01,
+          0x1D, 0xAE, 0xA3, 0x51, 0xDA, 0x00, 0xCA, 0x88, 0x0A, 0xA3,
+          0xE0, 0x0A, 0x1B, 0x7C, 0xDA, 0xFF, 0xCA, 0xFF, 0xE0, 0x0A,
+          0x1B, 0x7C, 0xD1, 0x10, 0x18, 0x31, 0xDA, 0x00, 0xCA, 0x82,
+          0x0A, 0xA8, 0xE0, 0x0A, 0x1B, 0x7C, 0xE0, 0x04, 0x1D, 0x1F,
+          0x08, 0x31, 0xDA, 0x00, 0xCA, 0x82, 0x0A, 0xA8, 0xE0, 0x0A,
+          0x1B, 0x7C, 0xE0, 0x04, 0x1D, 0x1F, 0xA3, 0x51, 0xDA, 0x00,
+          0xCA, 0x88, 0x0A, 0xA3, 0xE0, 0x0A, 0x1B, 0x7C, 0x81, 0x13,
+          0xF1, 0x05, 0x1D, 0xD0, 0xA3, 0x51, 0xDA, 0xFF, 0xCA, 0xFF,
+          0xE0, 0x0A, 0x1B, 0x7C, 0xA0, 0x21, 0xA1, 0x31, 0xA2, 0x61,
+          0xA7, 0x11, 0xE0, 0x07, 0x1F, 0x6C, 0xA7, 0x01, 0xE0, 0x07,
+          0x1F, 0x66, 0xF0, 0x02, 0xD2, 0x03, 0xE0, 0x07, 0x1E, 0x30,
+          0xE0, 0x03, 0x1B, 0x88, 0xE0, 0x03, 0x1E, 0x3A, 0xB2, 0x22,
+          0xF2, 0x05, 0x1D, 0xFB, 0xE0, 0x00, 0x1E, 0x48, 0xF0, 0x02,
+          0xE0, 0x00, 0x1C, 0x81, 0xD0, 0x00, 0xE0, 0x00, 0x18, 0xAC,
+          0xD2, 0x00, 0xD0, 0x10, 0xD1, 0x77, 0xE0, 0x00, 0x1F, 0x2F,
+          0xE0, 0x00, 0x1C, 0xDC, 0xD0, 0x28, 0xE0, 0x00, 0x1C, 0x14,
+          0xF0, 0x02, 0xD1, 0x3A, 0xF1, 0x0C, 0xE0, 0x00, 0x1E, 0x05,
+          0xD1, 0xC5, 0xC1, 0x03, 0xF1, 0x18, 0xE0, 0x01, 0x1C, 0x14,
+          0xD2, 0x1F, 0xE0, 0x02, 0x1B, 0xF0, 0xE0, 0x00, 0x1D, 0x2D,
+          0xD2, 0x86, 0xD3, 0x3C, 0xF4, 0x28, 0xF3, 0x4C, 0xA2, 0x23,
+          0xD3, 0x3D, 0xF4, 0x28, 0xF3, 0x4C, 0xA2, 0x23, 0xD3, 0x5E,
+          0xF4, 0x28, 0xF3, 0x4C, 0xF0, 0x02, 0xD1, 0x07, 0xD2, 0x26,
+          0xC2, 0x06, 0xD0, 0x00, 0xF2, 0x0C, 0xA2, 0x23, 0xB1, 0x12,
+          0xF1, 0x05, 0x1E, 0x34, 0xF0, 0x02, 0xD1, 0x03, 0xD2, 0x26,
+          0xC2, 0x06, 0xF3, 0x28, 0x44, 0xCF, 0xF4, 0x01, 0x1E, 0x43,
+          0xF2, 0x0C, 0xA0, 0x31, 0xA2, 0x23, 0xB1, 0x12, 0xF1, 0x05,
+          0x1E, 0x3D, 0xF0, 0x02, 0xD2, 0x27, 0xC2, 0x06, 0xF0, 0x28,
+          0xF0, 0x02, 0xD2, 0x09, 0xE0, 0x02, 0x1E, 0xD0, 0xD0, 0x08,
+          0x0D, 0xFC, 0x62, 0x30, 0x0E, 0xEC, 0x10, 0x12, 0x80, 0x04,
+          0xD1, 0x67, 0xF2, 0x18, 0x60, 0x02, 0xF0, 0x02, 0xD0, 0x02,
+          0xE0, 0x00, 0x1E, 0xD0, 0x81, 0x1D, 0x83, 0x13, 0x82, 0x15,
+          0x84, 0x17, 0x1F, 0xF4, 0x1D, 0xDE, 0xD0, 0x01, 0x2C, 0xCF,
+          0x2C, 0xCD, 0xF0, 0x02, 0xD2, 0x01, 0xC2, 0x60, 0xE0, 0x02,
+          0x1E, 0xA1, 0x92, 0x48, 0xD4, 0x5B, 0xF1, 0x48, 0x81, 0x1E,
+          0x11, 0x21, 0xA4, 0x10, 0xF4, 0x01, 0x1E, 0x76, 0xD4, 0x08,
+          0x01, 0x14, 0xF0, 0x19, 0x1E, 0x79, 0xD4, 0xF8, 0xC4, 0xFF,
+          0x01, 0x14, 0x91, 0x18, 0xE0, 0x03, 0x1F, 0x50, 0xE0, 0x04,
+          0x1F, 0x4C, 0x10, 0x34, 0xD4, 0x54, 0xF3, 0x48, 0xF3, 0x0D,
+          0x40, 0x13, 0xF0, 0x02, 0xD2, 0x0B, 0xE0, 0x02, 0x1E, 0xD0,
+          0x93, 0x38, 0xD0, 0x08, 0xC0, 0x08, 0x00, 0x03, 0x80, 0x04,
+          0xD2, 0x56, 0xF1, 0x28, 0x81, 0x1E, 0x30, 0x01, 0xA0, 0x03,
+          0x90, 0x02, 0xF0, 0x02, 0xD2, 0x03, 0xC2, 0x60, 0xE0, 0x02,
+          0x1E, 0xA1, 0x80, 0x3A, 0x80, 0x0B, 0xB0, 0x02, 0xD2, 0x0B,
+          0x73, 0x32, 0xD2, 0x3F, 0x2C, 0xC2, 0x84, 0x4A, 0x1D, 0x4F,
+          0xF0, 0x02, 0xF0, 0x0A, 0xD2, 0x00, 0xC2, 0xA4, 0xF2, 0x0C,
+          0xC2, 0xA8, 0xF1, 0x28, 0xF1, 0x01, 0x1E, 0xA6, 0xC2, 0x9C,
+          0xF1, 0x28, 0xC2, 0xA0, 0xF2, 0x28, 0xF0, 0x06, 0xF0, 0x02,
+          0xD5, 0xC0, 0xC5, 0x1F, 0x2D, 0xD0, 0xF5, 0x05, 0x1E, 0xBA,
+          0xD3, 0xE5, 0xC3, 0x03, 0xD5, 0x3F, 0x2D, 0xD0, 0x03, 0x35,
+          0xF3, 0x1C, 0xF0, 0x0A, 0xD3, 0x00, 0xC3, 0x9C, 0xF3, 0x1C,
+          0xC3, 0xA0, 0xF3, 0x2C, 0xC3, 0xA4, 0xF3, 0x0C, 0xC3, 0xA8,
+          0xF4, 0x38, 0xF4, 0x01, 0x1E, 0xC3, 0xF0, 0x06, 0xF0, 0x02,
+          0xC0, 0x80, 0xE0, 0x00, 0x1E, 0xAF, 0xF0, 0x02, 0xC0, 0xA0,
+          0xE0, 0x00, 0x1E, 0xAF, 0xF0, 0x02, 0xC0, 0x20, 0xE0, 0x00,
+          0x1E, 0xA1, 0xF0, 0x02, 0xC0, 0x70, 0xE0, 0x00, 0x1E, 0xA1,
+          0xF0, 0x02, 0xD0, 0x13, 0xE0, 0x00, 0x1E, 0xC8, 0xF0, 0x02,
+          0xD2, 0x41, 0xF2, 0x1C, 0xE0, 0x00, 0x1E, 0xD8, 0xF0, 0x02,
+          0xF0, 0x0A, 0xD1, 0x0D, 0xC1, 0x78, 0xD0, 0x00, 0xC0, 0xA4,
+          0xF0, 0x1C, 0xC0, 0xA8, 0xF1, 0x08, 0xF1, 0x01, 0x1E, 0xE8,
+          0xF0, 0x06, 0xF0, 0x02, 0xD1, 0x00, 0xC1, 0x94, 0xF0, 0x18,
+          0xC1, 0x98, 0xF1, 0x18, 0xF0, 0x02, 0xD1, 0x00, 0xC1, 0x98,
+          0xF1, 0x0C, 0xF0, 0x02, 0xA2, 0x23, 0xF2, 0x0D, 0xD3, 0x0F,
+          0x2F, 0xDF, 0x81, 0x19, 0xD4, 0x01, 0x2D, 0x2C, 0x64, 0x43,
+          0x65, 0x53, 0x1C, 0xC4, 0x3C, 0xC5, 0x14, 0x13, 0x55, 0xDF,
+          0x85, 0x52, 0xB5, 0x52, 0x03, 0x35, 0x82, 0x23, 0xF4, 0x05,
+          0x1E, 0xFC, 0xF0, 0x02, 0xD3, 0xFA, 0xF4, 0x38, 0x87, 0x03,
+          0xD5, 0x01, 0x65, 0x57, 0x1C, 0xC9, 0xF3, 0x4C, 0xA3, 0x33,
+          0x03, 0x30, 0xF4, 0x38, 0xA5, 0x11, 0xA6, 0x21, 0xE0, 0x04,
+          0x1E, 0xF7, 0xF3, 0x4C, 0xF0, 0x02, 0xD0, 0xFA, 0xF1, 0x08,
+          0xD2, 0x00, 0xF0, 0x2C, 0xC2, 0x74, 0xA0, 0x03, 0xF3, 0x08,
+          0xA0, 0x03, 0xD5, 0x01, 0x2D, 0x1D, 0xF5, 0x01, 0x1F, 0x2A,
+          0xF4, 0x08, 0xE0, 0x02, 0x1E, 0xAF, 0xA2, 0x23, 0x81, 0x13,
+          0xF1, 0x05, 0x1F, 0x20, 0xF0, 0x02, 0xE0, 0x00, 0x1F, 0x0B,
+          0xE0, 0x03, 0x1F, 0x1B, 0xE0, 0x03, 0x1E, 0xE1, 0xF0, 0x02,
+          0x83, 0x02, 0xD4, 0xF0, 0xA5, 0x11, 0xE0, 0x03, 0x1F, 0x0B,
+          0xA3, 0x33, 0xA5, 0x21, 0xE0, 0x03, 0x1F, 0x2F, 0xF0, 0x02,
+          0xD0, 0x00, 0xC0, 0x70, 0xE0, 0x00, 0x1E, 0xA1, 0xD3, 0x0F,
+          0x2C, 0xEF, 0x82, 0x29, 0x2D, 0xEF, 0xD3, 0x99, 0xC3, 0x03,
+          0xF3, 0x1C, 0xF0, 0x02, 0xD1, 0x3B, 0xF0, 0x19, 0x1F, 0x51,
+          0xF0, 0x02, 0xD1, 0x3A, 0xF0, 0x18, 0xD1, 0x66, 0xF1, 0x18,
+          0xE0, 0x00, 0x1A, 0x5C, 0xF0, 0x02, 0xD1, 0x3A, 0xF0, 0x18,
+          0xE0, 0x02, 0x0E, 0x81, 0xF2, 0x01, 0x1F, 0x63, 0xE0, 0x02,
+          0x0E, 0x8C, 0x82, 0x22, 0xA2, 0x2F, 0x82, 0x28, 0x10, 0x02,
+          0xD1, 0x3B, 0xF1, 0x0C, 0xF0, 0x02, 0xD1, 0x11, 0xD2, 0x70,
+          0xA3, 0x01, 0xE0, 0x01, 0x1F, 0x2F, 0xF0, 0x02, 0xD1, 0x11,
+          0xD2, 0xF8, 0xA3, 0x01, 0xE0, 0x01, 0x1F, 0x2F, 0xF0, 0x02,
+          0xA2, 0x01, 0xD1, 0x00, 0xD0, 0x09, 0xE0, 0x00, 0x1F, 0x2F,
+          0xF0, 0x02, 0xD2, 0x01, 0xD3, 0xF8, 0xA4, 0x01, 0xE0, 0x02,
+          0x1F, 0x2F, 0xC4, 0x30, 0xF4, 0x09, 0xD2, 0x01, 0xD3, 0xFF,
+          0xD4, 0x01, 0xE0, 0x02, 0x1F, 0x2F, 0xC4, 0x28, 0xF4, 0x09,
+          0xD2, 0x00, 0xE0, 0x02, 0x1E, 0xD4, 0x80, 0x3C, 0x80, 0x0D,
+          0xD2, 0x01, 0xD3, 0xFF, 0xD4, 0x00, 0xE0, 0x02, 0x1F, 0x2F,
+          0xF0, 0x02, 0xD0, 0x00, 0xD1, 0xFE, 0xD2, 0x03, 0xE0, 0x00,
+          0x1F, 0x2F, 0xD0, 0x01, 0xE0, 0x00, 0x1F, 0x72, 0xD0, 0x18,
+          0xE0, 0x00, 0x1F, 0x78, 0xD1, 0x14, 0xE0, 0x01, 0x1F, 0x78,
+          0xD3, 0x64, 0xF3, 0x0C, 0xA3, 0x33, 0xF3, 0x1C, 0xD0, 0x00,
+          0xC0, 0x7D, 0xE0, 0x00, 0x1A, 0x43, 0xD3, 0x63, 0xF3, 0x0C,
+          0xD1, 0xE0, 0xC1, 0x46, 0xD2, 0x61, 0xC2, 0x10, 0xD0, 0x00,
+          0xE0, 0x00, 0x1F, 0x36, 0xD0, 0x00, 0xE0, 0x00, 0x1F, 0x72,
+          0xF0, 0x02, 0xE0, 0x00, 0x16, 0x2C, 0xD5, 0x64, 0xF4, 0x58,
+          0xB5, 0x52, 0xF1, 0x58, 0xD5, 0x89, 0xC5, 0x03, 0x05, 0x50,
+          0xF3, 0x58, 0xE0, 0x03, 0x1A, 0x43, 0x33, 0x13, 0xD2, 0xFA,
+          0xC2, 0x0C, 0x13, 0x23, 0x83, 0x3D, 0xA3, 0x33, 0x83, 0x33,
+          0xD5, 0x0F, 0x5C, 0x3D, 0x15, 0x53, 0x43, 0x45, 0xA4, 0x30,
+          0x25, 0x34, 0xD3, 0x0F, 0xD4, 0x30, 0xE0, 0x03, 0x1F, 0x0B,
+          0xF0, 0x02, 0xE0, 0x00, 0x16, 0x2C, 0xD5, 0x64, 0xF4, 0x58,
+          0xB5, 0x52, 0xF1, 0x58, 0xD5, 0xFD, 0xC5, 0x02, 0x05, 0x50,
+          0xF3, 0x58, 0xE0, 0x03, 0x1A, 0x43, 0x33, 0x13, 0xD2, 0x58,
+          0xC2, 0x0C, 0x13, 0x23, 0xA6, 0x30, 0x23, 0x36, 0x83, 0x3D,
+          0xA3, 0x33, 0x85, 0x33, 0xD6, 0x0F, 0x4E, 0xDA, 0xF6, 0x01,
+          0x1F, 0xEC, 0xD5, 0x0F, 0xD3, 0x0E, 0xD4, 0x30, 0xE0, 0x03,
+          0x1F, 0x2F, 0xF0, 0x02, 0xD1, 0xD8, 0xD2, 0x00, 0xD0, 0x02,
+          0xE0, 0x00, 0x1F, 0x0B, 0xF0, 0x02, 0xD0, 0x0A, 0xE0, 0x00,
+          0x1E, 0xD4, 0x81, 0x15, 0xD2, 0x0F, 0x2C, 0xED, 0xF0, 0x02,
+          0xF0, 0x19, 0x0D, 0xBF, 0x90, 0x00, 0x88, 0x00, 0x30, 0x00,
+          0x34, 0x00, 0x24, 0x00, 0x6C, 0x00, 0xD6, 0x07, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0xC0,
+          0x60, 0x2F, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x1E, 0x00, 0x22, 0x00, 0x00, 0x62, 0x4D, 0x00, 0x10,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0xEC, 0xB1, 0x07, 0x36, 0x07, 0x4D,
+          0x00, 0x00, 0xAA, 0xAC, 0x07, 0x50, 0x07, 0x86, 0x00, 0x00,
+          0x88, 0xE0, 0x07, 0x89, 0x07, 0xBD, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x0C, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0xFA, 0xBC,
+          0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
+          0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0xA0,
+          0x00, 0x00, 0x00, 0x28, 0x00, 0xA0, 0x00, 0x00, 0x02, 0xEE,
+          0x03, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x01, 0x33,
+          0x00, 0x00, 0x00, 0x0C, 0x01, 0x80, 0x00, 0x09, 0x00, 0x23,
+          0x00, 0xC0, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x3A,
+          0x00, 0x27, 0x00, 0x3A, 0x00, 0x1D, 0x00, 0x35, 0x00, 0x1D,
+          0x00, 0x35, 0x00, 0x27, 0x00, 0x3A, 0x00, 0x27, 0x00, 0x3A,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x11, 0x4C, 0x14,
+          0x54, 0x11, 0x5C, 0x14, 0x54, 0x11, 0x6C, 0x14, 0x50, 0x0C,
+          0x4C, 0x14, 0x36, 0x94, 0x09, 0xF8, 0x5F, 0x28, 0xF7, 0x00,
+          0xFF, 0x90, 0xFF, 0x70, 0xFF, 0x50, 0x12, 0x00, 0x2A, 0xCC,
+          0x12, 0x00, 0x12, 0x66, 0x16, 0x00, 0x16, 0x8F, 0x16, 0xF5,
+          0x18, 0x66, 0x19, 0xC2, 0x19, 0x5C, 0x1A, 0x00, 0x19, 0x84,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x14, 0xA7, 0xE8, 0x80, 0x06, 0x99, 0xD9, 0x30, 0x19, 0x64,
+          0x28, 0xA0, 0x20, 0x00, 0x1A, 0x00, 0x80, 0x00, 0x80, 0x00,
+          0x00, 0x00, 0x02, 0x0D, 0x02, 0x71, 0x18, 0x20, 0x24, 0x20,
+          0x30, 0x20, 0x2A, 0x0E, 0x32, 0x12, 0x3A, 0x16, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xFF, 0xD0,
+          0x00, 0x60, 0xFF, 0xA0, 0x00, 0x90, 0xFF, 0x70, 0x00, 0xA0,
+          0x00, 0x02, 0x00, 0x02, 0xCF, 0xFF, 0x00, 0x00, 0x10, 0xA3,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x1F, 0x9A, 0x32, 0x76, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x9F, 0xFB, 0x4E, 0xE0, 0x10, 0x61, 0xC4, 0x46,
+          0x6F, 0xF0, 0x00, 0xF3, 0x29, 0x80, 0x7F, 0xF4, 0x5C, 0x22,
+          0x84, 0x5A, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x7E,
+          0x6F, 0xA0, 0x16, 0x4B, 0x08, 0x6D, 0xF4, 0x27, 0x58, 0x7F,
+          0x40, 0x21, 0x49, 0x12, 0xB0, 0x09, 0x03, 0x26, 0x7A, 0x77,
+          0xAA, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x20, 0x82, 0x80, 0x21, 0x7F, 0x83, 0xC3, 0x77, 0x00, 0x0D,
+          0x00, 0x08, 0x00, 0x06, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01,
+          0x00, 0x00, 0x00, 0xA0, 0x00, 0xA2, 0x00, 0xD6, 0x02, 0xD0,
+          0x02, 0x60, 0x06, 0xDC, 0x05, 0x78, 0x0D, 0x98, 0x52, 0x00,
+          0x03, 0xF9, 0xCD, 0x10, 0x00, 0x01, 0x29, 0x1E, 0x01, 0x02,
+          0x52, 0x1E, 0x00, 0x02, 0x00, 0x1E, 0x01, 0x04, 0x00, 0x10,
+          0x00, 0x04, 0x01, 0xE1, 0x00, 0x06, 0x01, 0x00, 0x00, 0x06,
+          0xA0, 0x05, 0x00, 0x03, 0x0A, 0xAC, 0xAA, 0x53, 0x4A, 0x4A,
+          0x06, 0xCA, 0xA6, 0xB3, 0x4C, 0x0A, 0x26, 0xCA, 0xA9, 0x13,
+          0x44, 0x4A, 0x26, 0xCA, 0xA8, 0xB3, 0x44, 0x4A, 0xA0, 0x08,
+          0x00, 0x01, 0xCC, 0x35, 0xCC, 0x35, 0x3F, 0x00, 0xBF, 0x00,
+          0x01, 0x00, 0x81, 0x00, 0xA0, 0x0C, 0x00, 0x03, 0x77, 0x65,
+          0xD0, 0xAA, 0x37, 0x12, 0x57, 0x40, 0xF2, 0xAA, 0xC8, 0xC8,
+          0x57, 0x40, 0xF2, 0xAA, 0xCE, 0xCE, 0xA0, 0x0D, 0x00, 0x02,
+          0x10, 0x92, 0x9B, 0x3C, 0x21, 0x12, 0x9B, 0x3C, 0xA0, 0x11,
+          0x00, 0x06, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x00, 0x00, 0x0C,
+          0x08, 0xDA, 0xB4, 0xDA, 0x0B, 0x2D, 0x00, 0x14, 0x08, 0x00,
+          0x00, 0x0C, 0x08, 0xDA, 0xB4, 0xDA, 0x0B, 0x2D, 0x00, 0x1B,
+          0x06, 0x28, 0x10, 0x60, 0x20, 0x91, 0xCD, 0x18, 0x0B, 0x2E,
+          0xA0, 0x12, 0x00, 0x07, 0x00, 0x7D, 0x83, 0x27, 0xFC, 0x4C,
+          0x7F, 0x9D, 0x2A, 0x49, 0x2B, 0x61, 0xFA, 0x26, 0x00, 0x0A,
+          0x90, 0xC8, 0x89, 0x13, 0x50, 0x8A, 0x2C, 0x8D, 0x55, 0x21,
+          0x48, 0x07, 0x00, 0x59, 0x25, 0x28, 0xF6, 0x8A, 0xE1, 0xDA,
+          0x4C, 0x6D, 0xAC, 0xE5, 0x7C, 0x24, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x18, 0x0F, 0xB2, 0x2C, 0xF2, 0xDE, 0x21,
+          0x00, 0x59, 0x1C, 0xCD, 0xB1, 0xB3, 0x12, 0x4D, 0x4D, 0x8D,
+          0x35, 0x30, 0xC8, 0x2A, 0xA0, 0x17, 0x00, 0x0E, 0x00, 0x5A,
+          0x05, 0x72, 0x13, 0x86, 0xAD, 0xC5, 0x4E, 0x16, 0x85, 0x0A,
+          0x38, 0x48, 0xDA, 0x4C, 0xEB, 0x6C, 0x52, 0xCB, 0xB6, 0xCD,
+          0xCA, 0xCE, 0xD4, 0x66, 0xB1, 0x2F, 0x00, 0x6D, 0x85, 0x75,
+          0x13, 0xB6, 0xB2, 0x2A, 0xA8, 0x16, 0x84, 0x14, 0x3A, 0xC6,
+          0xDC, 0xD4, 0xEB, 0x6D, 0x55, 0x2B, 0x64, 0x92, 0x2A, 0xAE,
+          0xDB, 0x66, 0xD5, 0x31, 0x00, 0x6D, 0x45, 0x6D, 0x13, 0x80,
+          0x16, 0x40, 0x2E, 0x1A, 0xD4, 0x93, 0x20, 0x69, 0x20, 0x32,
+          0x8D, 0x6D, 0x45, 0x4B, 0x85, 0xB6, 0x22, 0xAE, 0x1A, 0xD6,
+          0x8B, 0x2B, 0x00, 0x6D, 0x85, 0x75, 0x13, 0x45, 0x1A, 0x44,
+          0x2D, 0xA3, 0x55, 0x43, 0x3A, 0xD1, 0x63, 0x42, 0x81, 0x46,
+          0x40, 0x8B, 0x68, 0xB6, 0x31, 0x2E, 0xDB, 0x66, 0xD5, 0x31,
+          0x00, 0x0A, 0x24, 0x64, 0x33, 0xA8, 0xB6, 0x48, 0xCD, 0x03,
+          0x44, 0x85, 0x3B, 0x50, 0x22, 0xC0, 0xD0, 0x36, 0x48, 0x4B,
+          0xAD, 0xA2, 0x33, 0x0D, 0x1B, 0x66, 0x8D, 0x2C, 0x00, 0x09,
+          0x24, 0x62, 0xB3, 0x24, 0x92, 0x2A, 0xC8, 0xD4, 0x44, 0x29,
+          0x3A, 0xDB, 0x62, 0xCC, 0xED, 0xA8, 0x4D, 0x23, 0x6D, 0x16,
+          0x4A, 0x4D, 0xB4, 0x67, 0x51, 0x2D, 0xA0, 0x17, 0x00, 0x0E,
+          0x00, 0x60, 0x2D, 0x70, 0x52, 0x2D, 0xB5, 0x13, 0x2E, 0xDA,
+          0x92, 0xB5, 0x3B, 0x56, 0xD2, 0xD2, 0xEB, 0x51, 0x33, 0x33,
+          0x68, 0xB1, 0x31, 0x2E, 0xDB, 0x57, 0x2D, 0x32, 0x00, 0x50,
+          0x35, 0x68, 0x53, 0xA8, 0xD9, 0x50, 0xCB, 0x69, 0x13, 0x2D,
+          0x34, 0x69, 0x12, 0x32, 0xD8, 0xD9, 0x2D, 0x33, 0x46, 0xD9,
+          0x22, 0xAE, 0xD6, 0xD7, 0x53, 0x30, 0x00, 0x0D, 0x6D, 0x63,
+          0x53, 0x6D, 0x91, 0x52, 0xCC, 0x24, 0x92, 0xAD, 0x23, 0x6D,
+          0x90, 0xCA, 0xEB, 0x21, 0x35, 0x53, 0xA8, 0xD9, 0x31, 0x4E,
+          0xD6, 0xD6, 0xCD, 0x34, 0x00, 0x50, 0x35, 0x68, 0x53, 0x24,
+          0x91, 0x33, 0x4E, 0xA8, 0x93, 0x4D, 0x20, 0x6D, 0x90, 0x34,
+          0x86, 0x91, 0x22, 0xD3, 0x64, 0x91, 0x52, 0xCE, 0xD6, 0xD7,
+          0x53, 0x34, 0x00, 0x6D, 0x45, 0x6D, 0x13, 0x6C, 0x6D, 0x4C,
+          0xCC, 0x90, 0x93, 0x55, 0x22, 0x49, 0x11, 0x2C, 0xEB, 0x11,
+          0x33, 0x53, 0x46, 0xD1, 0x43, 0x4E, 0x1A, 0xD6, 0x8B, 0x35,
+          0x00, 0x5B, 0x6D, 0x6C, 0xD3, 0x40, 0xCD, 0x20, 0xCD, 0x84,
+          0x93, 0x55, 0x22, 0xD1, 0x11, 0x44, 0xE8, 0x49, 0x34, 0xD3,
+          0x68, 0x6D, 0x30, 0xCE, 0xA0, 0x56, 0xA1, 0x33, 0xA0, 0x19,
+          0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x86, 0x51, 0xD2, 0x35,
+          0xA4, 0x92, 0xA5, 0xB5, 0x25, 0x65, 0x00, 0x01, 0xB6, 0x15,
+          0x16, 0xB1, 0xA6, 0xD2, 0xA9, 0x12, 0x41, 0x66, 0x00, 0x00,
+          0x2D, 0x09, 0x6D, 0xB5, 0xA6, 0xD2, 0x59, 0x16, 0x41, 0x65,
+          0x80, 0x1F, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x80, 0x20,
+          0x00, 0x01, 0x00, 0x51, 0x00, 0x4C, 0x80, 0x21, 0x00, 0x01,
+          0x00, 0x06, 0x00, 0x00, 0xA0, 0x23, 0x00, 0x04, 0x00, 0x00,
+          0x00, 0x00, 0x02, 0x02, 0x65, 0x14, 0x00, 0x00, 0x00, 0x06,
+          0x98, 0x00, 0x01, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88,
+          0x82, 0x66, 0x00, 0x09, 0x08, 0x04, 0x42, 0x42, 0x01, 0x10,
+          0x00, 0x09, 0x90, 0x09, 0x06, 0x64, 0x02, 0x41, 0x00, 0x00,
+          0x09, 0x00, 0x40, 0x02, 0x40, 0x10, 0x80, 0x24, 0x00, 0x01,
+          0x00, 0xCC, 0x00, 0x33, 0x00, 0x1A, 0x00, 0x0D, 0x00, 0x00,
+          0x00, 0x40, 0x00, 0x01, 0x00, 0x06, 0x00, 0x44, 0x00, 0x50,
+          0x00, 0x04, 0xC0, 0xC7, 0xC0, 0xC7, 0xA0, 0xC0, 0xA0, 0xC0,
+          0xA0, 0x2C, 0x00, 0x01, 0x00, 0x00, 0x7B, 0x73, 0xA0, 0x2E,
+          0x00, 0x07, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x56, 0x95, 0x4A,
+          0x48, 0xCB, 0x34, 0x02, 0xCB, 0x20, 0x4B, 0x22, 0xF8, 0x08,
+          0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x20, 0x80, 0x35, 0x00, 0x01, 0x00, 0x08,
+          0x00, 0x31, 0xA0, 0x3A, 0x00, 0x02, 0x79, 0x5F, 0x5F, 0x18,
+          0x7A, 0x8A, 0x7A, 0x28, 0x78, 0x6F, 0x8F, 0x10, 0x7D, 0x8F,
+          0x8F, 0x10, 0xA8, 0x9F, 0x9F, 0x10, 0x7A, 0x8A, 0x7A, 0x28,
+          0xA0, 0x3B, 0x00, 0x01, 0x07, 0xFF, 0x05, 0xFF, 0x0C, 0x0B,
+          0x07, 0x0B, 0x03, 0xE0, 0x02, 0x0C, 0x01, 0x0E, 0x00, 0x89,
+          0x00, 0x45, 0x00, 0x23, 0x00, 0x11, 0x00, 0x09, 0x00, 0x04,
+          0x00, 0x02, 0x00, 0x01, 0x17, 0x51, 0x13, 0xBB, 0x11, 0x19,
+          0x11, 0x19, 0x11, 0x19, 0x11, 0x19, 0x17, 0x51, 0x13, 0xBB,
+          0x11, 0x19, 0x17, 0x51, 0x13, 0xBB, 0x11, 0x19, 0x00, 0x03,
+          0x00, 0x6A, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x64, 0x28,
+          0x03, 0x20, 0x07, 0x30, 0x00, 0x00, 0x46, 0x10, 0x64, 0x28,
+          0x02, 0xEE, 0x07, 0x30, 0x00, 0x00, 0x46, 0x10, 0x64, 0x28,
+          0x02, 0x8A, 0x06, 0xA4, 0x00, 0x00, 0x46, 0x10, 0x64, 0x28,
+          0x02, 0xBC, 0x07, 0x30, 0x00, 0x00, 0x46, 0x10, 0x64, 0x28,
+          0x02, 0x8A, 0x06, 0xA4, 0x00, 0xA0, 0x00, 0xD8, 0x00, 0xD8,
+          0x03, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0xE0, 0x2A, 0x00, 0x02, 0x60, 0x95, 0xE0, 0x80,
+          0x60, 0x95, 0xE0, 0x80, 0x60, 0x95, 0xE0, 0x80, 0x60, 0x95,
+          0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
+          0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06,
+          0x00, 0x07, 0x00, 0x08, 0x00, 0x09, 0x00, 0x0A, 0x00, 0x0B,
+          0x00, 0x0C, 0x00, 0x0D, 0x00, 0x0E, 0x00, 0x0F, 0x00, 0x1C,
+          0x00, 0x1D, 0x00, 0x1E, 0x00, 0x1F, 0x01, 0x0C, 0x01, 0x0D,
+          0x01, 0x0E, 0x01, 0x0F, 0x01, 0x1C, 0x01, 0x1D, 0x01, 0x1E,
+          0x01, 0x1F, 0x01, 0x2C, 0x01, 0x2D, 0x01, 0x2E, 0x01, 0x2F,
+          0x01, 0x3C, 0x01, 0x3D, 0x01, 0x3E, 0x01, 0x3F, 0x01, 0x4C,
+          0x01, 0x4D, 0x01, 0x4E, 0x01, 0x4F, 0x01, 0x5C, 0x01, 0x5D,
+          0x01, 0x5E, 0x01, 0x5F, 0x01, 0x6C, 0x01, 0x6D, 0x01, 0x6E,
+          0x01, 0x6F, 0x01, 0x7C, 0x01, 0x7D, 0x01, 0x7E, 0x01, 0x7F,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x0E, 0x00, 0x10, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12,
+          0x00, 0x12, 0x00, 0x0E, 0x00, 0x10, 0x00, 0x12, 0x00, 0x0E,
+          0x00, 0x10, 0x00, 0x12, 0x16, 0x94, 0x12, 0x10, 0x13, 0x37,
+          0x12, 0x10, 0x0F, 0x92, 0x0F, 0x92, 0x17, 0x28, 0x12, 0x10,
+          0x0F, 0x0D, 0x17, 0x28, 0x13, 0xA2, 0x10, 0x21, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
+          0x00, 0xFF, 0x00, 0xF0, 0x00, 0xDC, 0x00, 0xC8, 0x00, 0x78,
+          0x00, 0x64, 0x00, 0x50, 0x00, 0x3C, 0x00, 0x28, 0x00, 0x1E,
+          0x00, 0x14, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0xA0,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0,
+          0x52, 0x14, 0x03, 0x20, 0x13, 0x70, 0x15, 0xC8, 0x56, 0x40,
+          0x07, 0xD0, 0xCD, 0xC0, 0x7F, 0xFF, 0x10, 0xA0, 0x14, 0xB0,
+          0x67, 0x08, 0x69, 0x60, 0x0F, 0xFF, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x1C,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x04,
+          0x00, 0x06, 0x00, 0x04, 0x00, 0x01, 0x09, 0x02, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x02, 0x3F,
+          0x01, 0x3F, 0x03, 0xFC, 0x00, 0x3F, 0x00, 0x3F, 0x38, 0x0F,
+          0x38, 0x0E, 0x38, 0x0D, 0x38, 0x0C, 0x38, 0x0B, 0x38, 0x0A,
+          0x38, 0x09, 0x38, 0x08, 0x38, 0x07, 0x38, 0x06, 0x38, 0x05,
+          0x38, 0x04, 0x38, 0x03, 0x38, 0x02, 0x38, 0x01, 0xB8, 0x00,
+          0x08, 0x0F, 0x08, 0x0E, 0x08, 0x0D, 0x08, 0x0C, 0x08, 0x0B,
+          0x08, 0x0A, 0x48, 0x0F, 0x48, 0x0E, 0x48, 0x0D, 0x48, 0x0C,
+          0x48, 0x0B, 0x48, 0x0A, 0x48, 0x09, 0x48, 0x08, 0x48, 0x07,
+          0x48, 0x06, 0x48, 0x05, 0x48, 0x04, 0x48, 0x03, 0x48, 0x02,
+          0x48, 0x01, 0xC8, 0x00, 0x47, 0x0F, 0x47, 0x0E, 0x47, 0x0D,
+          0x47, 0x0C, 0x47, 0x0B, 0x47, 0x0A, 0x47, 0x09, 0x47, 0x08,
+          0x47, 0x07, 0x47, 0x06, 0x47, 0x05, 0x47, 0x04, 0x47, 0x03,
+          0x47, 0x02, 0x47, 0x01, 0x47, 0x00, 0x46, 0x07, 0x46, 0x06,
+          0x46, 0x04, 0x46, 0x03, 0x46, 0x02, 0x46, 0x00, 0x45, 0x07,
+          0x45, 0x06, 0x45, 0x04, 0x45, 0x03, 0x45, 0x02, 0x45, 0x00,
+          0x44, 0x07, 0x44, 0x06, 0x44, 0x04, 0x44, 0x03, 0x44, 0x02,
+          0x44, 0x00, 0x43, 0x09, 0x43, 0x07, 0x43, 0x06, 0x43, 0x04,
+          0x43, 0x03, 0x43, 0x02, 0x43, 0x01, 0x43, 0x00, 0x03, 0x43,
+          0x03, 0x42, 0x03, 0x41, 0x03, 0x40, 0x03, 0xC5, 0x03, 0xC3,
+          0x03, 0xC1, 0x03, 0xC0, 0x03, 0xD0, 0x03, 0xE4, 0x03, 0xE2,
+          0x03, 0xE0, 0x03, 0xF0, 0x00, 0xC0, 0x00, 0x80, 0x00, 0x40,
+          0x00, 0x00, 0x47, 0x0C, 0x47, 0x08, 0x47, 0x04, 0x47, 0x00,
+          0x46, 0x00, 0x45, 0x00, 0x44, 0x00, 0x43, 0x00, 0x42, 0x00,
+          0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0xA0, 0x12, 0x00, 0x07, 0x00, 0x71, 0xC4, 0x27,
+          0xB6, 0xCB, 0x7F, 0xDC, 0xC8, 0xF9, 0x15, 0x64, 0xCA, 0x28,
+          0x00, 0x00, 0x00, 0x07, 0xC0, 0x30, 0x61, 0xF4, 0x4D, 0x91,
+          0xAB, 0x75, 0x82, 0x24, 0x00, 0x00, 0x00, 0x07, 0xC0, 0x30,
+          0x61, 0xF4, 0x4D, 0x91, 0xAB, 0x75, 0x82, 0x24, 0x00, 0x7F,
+          0xC5, 0x27, 0xFF, 0x2B, 0x36, 0xDD, 0x48, 0xED, 0x95, 0x6A,
+          0x04, 0x29, 0x00, 0x7F, 0x84, 0xA0, 0xE2, 0x89, 0x0F, 0xD1,
+          0x4F, 0x88, 0xB3, 0x49, 0x44, 0x26, 0x00, 0x0C, 0x38, 0x8E,
+          0x1E, 0xC5, 0x48, 0x93, 0x4E, 0xD9, 0x2B, 0x58, 0xA8, 0x26,
+          0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0xA0, 0x19, 0x00, 0x06, 0x00, 0x0D,
+          0xB0, 0xA4, 0x6D, 0xB9, 0x64, 0x92, 0xA5, 0xE0, 0x08, 0x07,
+          0x00, 0x0D, 0x6D, 0x96, 0xFA, 0xCA, 0x6F, 0xDB, 0x65, 0xB5,
+          0xBA, 0x58, 0x00, 0x0C, 0x2D, 0x86, 0xDB, 0x49, 0xAB, 0x23,
+          0x95, 0xD2, 0x3A, 0x58, 0x00, 0x0D, 0xB6, 0xA5, 0xE2, 0xC8,
+          0xA6, 0xD2, 0xA9, 0x6D, 0x26, 0xAB, 0x00, 0x10, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x0D, 0x80, 0x90, 0xF6, 0xC5, 0xA3,
+          0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0xA0, 0x2E, 0x00, 0x07, 0x00, 0x0F, 0xF0, 0xCF,
+          0xC0, 0x30, 0x48, 0x94, 0xCA, 0x49, 0x53, 0x55, 0x36, 0x27,
+          0x00, 0x60, 0x02, 0x06, 0xC0, 0x48, 0x6B, 0x6D, 0x4D, 0xB6,
+          0x54, 0xF8, 0x9C, 0x27, 0x00, 0x60, 0x02, 0x06, 0xC0, 0x48,
+          0x6B, 0x6D, 0x4D, 0xB6, 0x54, 0xF8, 0x9C, 0x27, 0x00, 0x7F,
+          0xF5, 0x2F, 0xFE, 0xB4, 0xEA, 0x95, 0x4E, 0x49, 0x34, 0xD3,
+          0x84, 0x29, 0x00, 0x6D, 0x6A, 0xC8, 0xD6, 0x0A, 0xB4, 0x93,
+          0x2D, 0x84, 0xAC, 0xBB, 0x74, 0x23, 0x00, 0x7C, 0x2B, 0x0D,
+          0xB2, 0x32, 0xFF, 0x93, 0x2E, 0xB5, 0x2C, 0xD7, 0xD8, 0x24,
+          0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x90, 0x00, 0x90, 0x11,
+          0x90, 0x22, 0x90, 0x33, 0x90, 0x44, 0x90, 0x55, 0x90, 0x66,
+          0x90, 0x77, 0x90, 0x88, 0x90, 0x99, 0x91, 0x00, 0x91, 0x11,
+          0x91, 0x22, 0x91, 0x33, 0x91, 0x44, 0x91, 0x55, 0x91, 0x66,
+          0x91, 0x77, 0x91, 0x88, 0x91, 0x99, 0x92, 0x00, 0x92, 0x11,
+          0x92, 0x22, 0x92, 0x33, 0x92, 0x44, 0x92, 0x55, 0x80, 0x00,
+          0x80, 0x11, 0x80, 0x22, 0x80, 0x33, 0x80, 0x44, 0x80, 0x55,
+          0x80, 0x66, 0x80, 0x77, 0x80, 0x88, 0x80, 0x99, 0x81, 0x00,
+          0x81, 0x11, 0x81, 0x22, 0x81, 0x33, 0x81, 0x44, 0x81, 0x55,
+          0x81, 0x66, 0x81, 0x77, 0x81, 0x88, 0x81, 0x99, 0x82, 0x00,
+          0x82, 0x11, 0x82, 0x22, 0x82, 0x33, 0x82, 0x44, 0x82, 0x55,
+          0x82, 0x66, 0x82, 0x77, 0x82, 0x88, 0x82, 0x99, 0x83, 0x00,
+          0x83, 0x11, 0x83, 0x22, 0x83, 0x33, 0x83, 0x44, 0x83, 0x55,
+          0x83, 0x66, 0x83, 0x77, 0x83, 0x88, 0x83, 0x99, 0x84, 0x00,
+          0x84, 0x11, 0x84, 0x22, 0x84, 0x33, 0x84, 0x44, 0x84, 0x55,
+          0x84, 0x66, 0x84, 0x77, 0x84, 0x88, 0x84, 0x99, 0x85, 0x11,
+          0x85, 0x22, 0x85, 0x33, 0x85, 0x44, 0x85, 0x55, 0x85, 0x66,
+          0x85, 0x77, 0x10, 0x00, 0x10, 0x11, 0x10, 0x22, 0x10, 0x33,
+          0x10, 0x44, 0x10, 0x55, 0x10, 0x66, 0x10, 0x77, 0x10, 0x88,
+          0x10, 0x99, 0x11, 0x00, 0x11, 0x11, 0x11, 0x22, 0x11, 0x33,
+          0x11, 0x44, 0x11, 0x55, 0x11, 0x66, 0x11, 0x77, 0x11, 0x88,
+          0x11, 0x99, 0x12, 0x00, 0x12, 0x11, 0x12, 0x22, 0x12, 0x33,
+          0x12, 0x44, 0x12, 0x55, 0x12, 0x66, 0x12, 0x77, 0x12, 0x88,
+          0x12, 0x99, 0x13, 0x00, 0x13, 0x11, 0x13, 0x22, 0x13, 0x33,
+          0x13, 0x44, 0x13, 0x55, 0x13, 0x66, 0x13, 0x77, 0x13, 0x88,
+          0x13, 0x99, 0x14, 0x00, 0x14, 0x11, 0x14, 0x22, 0x14, 0x33,
+          0x14, 0x44, 0x14, 0x55, 0x14, 0x66, 0x14, 0x77, 0x14, 0x88,
+          0x14, 0x99, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+          0x00, 0x0C,          /* Length = 12 bytes */
+          0x00, 0x06, 0x00, 0x0A, 0x6D, 0x8C, 0xF2, 0xD8, 0xCF, 0x2A,
+          0x39, 0x04,
+          0x00, 0x04,          /* Length = 4 bytes */
+          0x00, 0x07, 0x08, 0x0A,
+          0x00, 0x12,          /* Length = 18 bytes */
+          0x00, 0x09, 0x00, 0x01, 0x6D, 0x18, 0xFA, 0x0D, 0xC1, 0x12,
+          0x18, 0x64, 0x3C, 0xFA, 0xF7, 0xE1, 0x0C, 0x2C,
+          0x00, 0x06,          /* Length = 6 bytes */
+          0x00, 0x0A, 0x00, 0x0D, 0xB6, 0x66,
+          0x00, 0x0C,          /* Length = 12 bytes */
+          0x00, 0x0B, 0x80, 0xF9, 0xD7, 0x3E, 0x75, 0xC1, 0x8A, 0xE4,
+          0x02, 0x00,
+          0x00, 0x03,          /* Length = 3 bytes */
+          0x00, 0x2D, 0xFF,
+          0x00, 0x03,          /* Length = 3 bytes */
+          0x00, 0x02, 0x2E,
+          0x00, 0x03,          /* Length = 3 bytes */
+          0x00, 0x02, 0x1F,
+          0x00, 0x05,          /* Length = 5 bytes */
+          0x00, 0x00, 0x00, 0x00, 0x88,
+          0x80, 0x0A,          /* WAIT 010[ms] */
+          0xFF, 0xFF           /* END OF SEQUENCE. TOTAL MEMORY REQ'D = 16497 BYTES */
+};
+
+#endif
+
+
diff --git a/drivers/amlogic/dvb_tv/cresta/ctc703_frontend.c b/drivers/amlogic/dvb_tv/cresta/ctc703_frontend.c
new file mode 100755
index 000000000000..c7fd2b9a13fb
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/cresta/ctc703_frontend.c
@@ -0,0 +1,428 @@
+/*
+* Author: kele bai <kele.bai@amlogic.com>
+*
+* Copyright (C) 2010 Amlogic Inc.
+ *
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/dvb/frontend.h>
+#include "ctc703_func.h"
+#include<mach/gpio_data.h>
+#include<linux/delay.h>
+#include<mach/gpio.h>
+
+#define MODEULE_NAME    "ctc703"
+#define CTC703_TUNER_I2C_NAME           "ctc703_tuner_i2c"
+#define ERROR                  1
+static bool ctc703_debug = false;
+module_param(ctc703_debug,bool,0644);
+MODULE_PARM_DESC(ctc703_debug,"\n enble /disable the ctc703 debug information.\n");
+
+#define ctprintk  if(ctc703_debug) printk
+static struct ctc703_device_s  *ctc_devp;
+static void ctc703_set_std(void);
+static int ctc703_get_atv_status(struct dvb_frontend *dvb_fe, atv_status_t *atv_status);
+static int ctc703_get_afc(struct dvb_frontend *fe);
+static int ctc703_get_snr(struct dvb_frontend *fe);
+
+static void sound_store(const char *buff, v4l2_std_id *std)
+{
+        if(!strncmp(buff,"dk",2))
+                *std |= V4L2_STD_PAL_DK;
+        else if(!strncmp(buff,"bg",2))
+                *std |= V4L2_STD_PAL_BG;
+        else if(!strncmp(buff,"i",1))
+                *std |= V4L2_STD_PAL_I;
+        else if(!strncmp(buff,"n",1))
+                *std |= V4L2_STD_PAL_N;
+        else if(!strncmp(buff,"nm",2))
+                *std |= V4L2_STD_NTSC_M;
+        else if(!strncmp(buff,"pm",2))
+                *std |= V4L2_STD_PAL_M;
+        else if(!strncmp(buff,"l",1))
+                *std |= V4L2_STD_SECAM_L;
+        else if(!strncmp(buff,"lc",2))
+                *std |= V4L2_STD_SECAM_LC;
+        else
+                pr_info("invaild command.\n");
+}
+
+static ssize_t ctc703_show(struct class *cls,struct class_attribute * attr,char *buff)
+{
+    return 0;
+}
+static ssize_t ctc703_store(struct class *cls,struct class_attribute *attr,char *buf,size_t count)
+{
+    char *parm[4];
+    char *buff,*buf_orig,*ps;
+    unsigned int err_code=0,n=0;
+    v4l2_std_id  std;
+    atv_status_t  atv_status={0};
+	//unsigned short lock = 0;
+    int afc_fre = 0;
+    unsigned short int  quality=0;
+    unsigned short snr = 0;
+    printk("buf=%s\n",buf);
+    buf_orig = kstrdup(buf, GFP_KERNEL);
+    ps = buf_orig;
+    printk("ps=%s\n",ps);
+    while (1) {
+               buff= strsep(&ps, " \n");
+               printk("buff=%s\n",buff);
+                if (buff == NULL)
+                        break;
+                if (*buff == '\0')
+                        continue;
+                parm[n] = buff;
+                printk("parm[%d]=%s\n",n,parm[n++]);
+        }
+  //  printk("parm[n]=%s\n",parm[n]);
+    if(!strncmp(parm[0],"tune",strlen("tune")))
+        {
+            ctc_devp->parm.frequency = simple_strtol(parm[1], NULL, 10);
+            printk("set the freq:%d\n",ctc_devp->parm.frequency );
+            err_code = xc_set_rf_frequency(ctc_devp->parm.frequency);
+            if(err_code)
+                printk("[ctc703..]%s set frequency error %d.\n",__func__,err_code);
+
+        }
+     else if(!strncmp(parm[0],"std",strlen("std")))
+        {
+                if(!strncmp(parm[1],"pal",3))
+                {
+                        std= V4L2_COLOR_STD_PAL;
+                        sound_store(parm[2],&std);
+                }
+                else if(!strncmp(parm[1],"ntsc",4))
+                {
+                        std= V4L2_COLOR_STD_NTSC;
+                        sound_store(parm[2],&std);
+                }
+                else if(!strncmp(parm[1],"secam",5))
+                {
+                        std= V4L2_COLOR_STD_SECAM;
+                        sound_store(parm[2],&std);
+                }
+                ctc_devp->parm.std  =std;
+                ctc703_set_std();
+                printk("[ctc703..]%s set std color %s, audio type %s.\n",__func__,\
+                                v4l2_std_to_str(0xff000000&ctc_devp->parm.std), v4l2_std_to_str(0xffffff&ctc_devp->parm.std));
+        }
+    else if(!strncmp(parm[0],"atv_status",strlen("atv_status")))
+    {
+   	if (WaitForLock()== 1)
+	{
+		  atv_status.atv_lock= 1;
+	}
+	else
+		atv_status.atv_lock= 0;
+    	xc_get_frequency_error(&afc_fre);
+        atv_status.afc = afc_fre;
+    	if(xc_read_reg(XREG_SNR,&snr))
+    	{
+        	printk("[ctc703..]%s get snr error.\n",__func__);
+        	return 0;
+    	}
+        atv_status.snr =snr;
+        xc_get_quality(&quality);
+ //	atv_status->audmode = si2176_devp->si_cmd_reply.atv_status.audio_demod_mode;
+        atv_status.std = ctc_devp->parm.std;
+        printk("[si2176..]%s:tune %d afc %d_hz,snr %d,atv lock %d ,quality %d ,std color %s audio %s.\n",__func__,ctc_devp->parm.frequency,atv_status.afc, atv_status.snr,
+                        atv_status.atv_lock,quality, v4l2_std_to_str(atv_status.std&0xff000000),v4l2_std_to_str(atv_status.std&0xffffff));
+
+	 	}
+	 else if(!strncmp(parm[0],"set_channel",strlen("set_channel")))
+	 	{
+	 	ctc_devp->parm.frequency = simple_strtol(parm[1], NULL, 10);
+	 	printk("lock=%d\n",xc_scan_channel(ctc_devp->parm.frequency));
+	 	}
+        else
+                printk("invalid command\n");
+        return count;
+}
+static CLASS_ATTR(ctc703_debug, 0644, ctc703_show, ctc703_store);
+
+
+static int ctc703_tuner_init_fe(struct aml_fe_dev *fe)
+{
+    if(!fe)
+    {
+        printk("[ctc703..]%s null pointer error.\n",__func__);
+        return -ERROR;
+    }
+    ctc_devp->tuner_client.adapter = fe->i2c_adap;
+    ctc_devp->tuner_client.addr = fe->i2c_addr;
+    printk("i2c_addr=%d\n",fe->i2c_addr);
+    xc_set_i2c_client(&ctc_devp->tuner_client);
+    if(!sprintf(ctc_devp->tuner_client.name,CTC703_TUNER_I2C_NAME))
+    {
+        printk("[ctc703..]%s sprintf name error.\n",__func__);
+    }
+    //reset
+    ctc_devp->cpram.reset_gpio = fe->reset_gpio;
+    ctc_devp->cpram.reset_value = fe->reset_value;
+   // xc_reset();
+
+    printk("ctc703 init  is ok!\n");
+    return 0;
+}
+int xc_reset()
+{
+
+       gpio_out(ctc_devp->cpram.reset_gpio,0);
+       mdelay(100);
+       gpio_out(ctc_devp->cpram.reset_gpio,1);
+       printk("[%s]tuner reset:reset_gpio=[%d] \n",__func__,ctc_devp->cpram.reset_gpio);
+    return XC_RESULT_SUCCESS;
+}
+static int ctc703_enter_mode(struct aml_fe *fe, int mode)
+{
+    //-/+ 1.25m
+    unsigned short afc_range[]={0x50,0xfb0};
+    xc_initialize();
+    //set rf mode to off-air
+    xc_set_rf_mode(0);
+    xc_write_seek_frequency(2,afc_range);
+    return 0;
+}
+static int ctc703_leave_mode(struct aml_fe *fe, int mode)
+{
+   if(xc_shutdown())
+   {
+        printk("[ctc703..]%s error.\n",__func__);
+        return -ERROR;
+   }
+   return 0;
+
+}
+static int ctc703_suspend(struct aml_fe_dev *dev)
+{
+	 if(xc_shutdown())
+   {
+        printk("[ctc703..]%s error.\n",__func__);
+        return -ERROR;
+   }
+   return 0;
+}
+
+static int ctc703_resume(struct aml_fe_dev *dev)
+{
+	    //-/+ 1.25m
+    unsigned short afc_range[]={0x50,0xfb0};
+    if(0 != xc_initialize())
+	{
+		printk("[%s]:xc_initialize is err\n",__func__);
+	}
+    //set rf mode to off-air
+    xc_set_rf_mode(0);
+    xc_write_seek_frequency(2,afc_range);
+	printk("[%s]: ctc tuner resume is ok",__func__);
+    return 0;
+}
+
+static void ctc703_get_demod_state(struct dvb_frontend *fe, void *state);
+
+static void ctc703_set_frequency(void)
+{
+    int err_code = 0;
+    ctprintk("[ctc703..]%s set frequency %u.\n",__func__,ctc_devp->parm.frequency);
+    err_code = xc_set_rf_frequency(ctc_devp->parm.frequency);
+	msleep(200);
+    if(err_code)
+        printk("[ctc703..]%s set frequency error %d.\n",__func__,err_code);
+}
+static void ctc703_set_std(void)
+{
+    int return_code = 0;
+    ctprintk("[ctc703..]%s set std color %s, audio mode %s.\n",__func__,v4l2_std_to_str(ctc_devp->parm.std&0xff000000),
+                v4l2_std_to_str(ctc_devp->parm.std&0xffffff));
+	//	on the basis of audio mode  ,func can analysis the video mode and audio mode
+    return_code = xc_set_tv_standard(ctc_devp->parm.std&0xffffff);
+	msleep(50);
+    if(return_code)
+        printk("[ctc703..]%s set std error.\n",__func__);
+}
+static int ctc703_set_param(struct dvb_frontend *fe,struct dvb_frontend_parameters *param)
+{
+    struct dvb_analog_parameters *analog_param;
+    if(!param)
+    {
+        printk("[ctc703..]%s null pointer error.\n",__func__);
+        return -ERROR;
+    }
+    analog_param = &param->u.analog;
+     if(analog_param->std != ctc_devp->parm.std)
+    {
+        ctc_devp->parm.std = analog_param->std;
+        ctc703_set_std();
+    }
+    if(param->frequency != ctc_devp->parm.frequency)
+    {
+        ctc_devp->parm.frequency = param->frequency;
+        ctc703_set_frequency();
+    }
+
+    return 0;
+}
+static int ctc703_tuner_get_ops(struct aml_fe_dev *fe, int mode, void* ops)
+{
+    struct dvb_tuner_ops *ctc703_tuner_ops  = (struct dvb_tuner_ops*)ops;
+    ctc703_tuner_ops->info.frequency_min  = 1000000;
+    ctc703_tuner_ops->info.frequency_max = 1023000000;
+    ctc703_tuner_ops->set_params             = ctc703_set_param;
+    ctc703_tuner_ops->get_status=   ctc703_get_demod_state;
+
+
+    return 0;
+}
+struct aml_fe_drv ctc703_tuner_drv ={
+    .name           = "ctc703_tuner",
+    .id                 = AM_TUNER_CTC703,
+    .capability     = AM_FE_ANALOG|AM_FE_QPSK|AM_FE_QAM|AM_FE_ATSC|AM_FE_OFDM,
+    .init               = ctc703_tuner_init_fe,
+    .enter_mode = ctc703_enter_mode,
+    .leave_mode = ctc703_leave_mode,
+    .get_ops       = ctc703_tuner_get_ops,
+    .suspend	=	ctc703_suspend,
+    .resume		=	ctc703_resume,
+};
+static int ctc703_get_afc(struct dvb_frontend *fe)
+{
+    int afc_fre = 0;
+    xc_get_frequency_error(&afc_fre);
+    return afc_fre/1000;
+}
+static int ctc703_get_snr(struct dvb_frontend *fe)
+{
+    unsigned short snr = 0;
+    if(xc_read_reg(XREG_SNR,&snr))
+    {
+        printk("[ctc703..]%s get snr error.\n",__func__);
+        return 0;
+    }
+    return snr;
+}
+static void ctc703_get_demod_state(struct dvb_frontend *fe, void *state)
+{
+   // unsigned short lock = 0;
+    fe_status_t *status = (fe_status_t*)state;
+    if(!state)
+    {
+        printk("[ctc703..] %s null pointer error.\n",__func__);
+        return;
+    }
+  /* if(xc_get_lock_status(&lock))
+    {
+        printk("[ctc703..] %s get lock error.\n",__func__);
+        return;
+    }
+    switch(lock)
+    {
+        case 0:
+            *status = FE_TIMEDOUT;
+            break;
+        case 1:
+            *status = FE_HAS_LOCK;
+            break;
+        case 2:
+            *status = FE_REINIT;
+            break;
+        default:
+            break;
+    }
+    */
+
+    if (WaitForLock()== 1)
+    {
+	*status = FE_HAS_LOCK;
+    }
+    else
+	*status = FE_TIMEDOUT;
+
+
+}
+
+
+static int ctc703_get_atv_status(struct dvb_frontend *dvb_fe, atv_status_t *atv_status)
+{
+ //   unsigned int lock_status = 0;
+        if(!atv_status)
+        {
+            	printk("[ctc703..]%s: null pointer error.\n",__func__);
+            	return -ERROR;
+        }
+        if (WaitForLock()== 1)
+	{
+		atv_status->atv_lock= 1;
+	}
+	else
+		atv_status->atv_lock= 0;
+	//xc_get_lock_status(&lock_status);
+       // atv_status->atv_lock = lock_status;
+        atv_status->afc = ctc703_get_afc(dvb_fe);
+        atv_status->snr =ctc703_get_snr(dvb_fe);
+   //    atv_status->audmode = si2176_devp->si_cmd_reply.atv_status.audio_demod_mode;
+        atv_status->std &= ctc_devp->parm.std;
+        ctprintk("[ctc..]%s afc %d_khz,snr %d,atv lock %d ,std color %s audio %s.\n",\
+		__func__,atv_status->afc, atv_status->snr,atv_status->atv_lock, \
+		v4l2_std_to_str(atv_status->std&0xff000000),v4l2_std_to_str(atv_status->std&0xffffff));
+        return 0;
+}
+
+static int ctc703_analog_get_ops(struct aml_fe_dev *fe,int mode, void *ops)
+{
+    struct analog_demod_ops *ctc703_demod_ops = (struct analog_demod_ops *)ops;
+    ctc703_demod_ops->get_afc         = ctc703_get_afc;
+    ctc703_demod_ops->get_snr         = ctc703_get_snr;
+    ctc703_demod_ops->get_status    = ctc703_get_demod_state;
+    ctc703_demod_ops->get_atv_status = ctc703_get_atv_status;
+    return 0;
+}
+struct aml_fe_drv ctc703_demod_drv ={
+    .name           = "ctc703_atv_demod",
+    .id                 = AM_ATV_DEMOD_CTC703,
+    .capability     = AM_FE_ANALOG,
+    .get_ops       = ctc703_analog_get_ops,
+};
+static int __init ctc703_module_init(void)
+{
+    int ret=0;
+    ctc_devp = kmalloc(sizeof(ctc703_device_t), GFP_KERNEL);
+    if(!ctc_devp)
+    {
+        printk("[ctc703..] %s, no memory to allocate.\n",__func__);
+        return -ENOMEM;
+    }
+    ctc_devp->clsp = class_create(THIS_MODULE, MODEULE_NAME);
+    if(!ctc_devp->clsp)
+    {
+        printk("[ctc703..] %s create class error.\n",__func__);
+    }
+    if((ret=class_create_file(ctc_devp->clsp,&class_attr_ctc703_debug)) < 0)
+    {
+            printk("%s: fail to create ctc_debug attribute file.\n", __func__);
+    }
+    //class_create_file(struct class * class,const struct class_attribute * attr);
+    aml_register_fe_drv(AM_DEV_TUNER, &ctc703_tuner_drv);
+    aml_register_fe_drv(AM_DEV_ATV_DEMOD, &ctc703_demod_drv);
+    printk("[%s]:ctc703 tuner module  init\n",__func__);
+
+    return 0;
+
+}
+static void __exit ctc703_module_exit(void)
+{
+    class_destroy(ctc_devp->clsp);
+    if(ctc_devp)
+        kfree(ctc_devp);
+    aml_unregister_fe_drv(AM_DEV_TUNER, &ctc703_tuner_drv);
+    aml_unregister_fe_drv(AM_DEV_ATV_DEMOD, &ctc703_demod_drv);
+
+}
+fs_initcall(ctc703_module_init);
+module_exit(ctc703_module_exit);
diff --git a/drivers/amlogic/dvb_tv/cresta/ctc703_func.c b/drivers/amlogic/dvb_tv/cresta/ctc703_func.c
new file mode 100755
index 000000000000..50bc6a2a4ab8
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/cresta/ctc703_func.c
@@ -0,0 +1,497 @@
+/*
+*
+* Author: kele bai <kele.bai@amlogic.com>
+*
+* Copyright (C) 2010 Amlogic Inc.
+ *
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include "ctc703_func.h"
+#define CTC703_MAX_STANDARD_NUM     7
+//only for mono
+static struct i2c_client  *ctc703_client = NULL;
+const static struct ctc703_standard_s tv_standard[CTC703_MAX_STANDARD_NUM]={
+{V4L2_STD_PAL_M         , 0x0478, 0x8020 },
+{V4L2_STD_PAL_N         , 0x0478, 0x8020 },
+{V4L2_STD_NTSC_M      , 0x0478, 0x8020 },
+{V4L2_STD_PAL_B          , 0x0878, 0x8045 },
+{V4L2_STD_PAL_I           , 0x0e78, 0x8009 },
+{V4L2_STD_PAL_DK       , 0x1478, 0x8009 },
+{ V4L2_STD_SECAM_DK , 0x1478, 0x8009 }
+};
+void xc_set_i2c_client(struct i2c_client *client)
+{
+    ctc703_client = client;
+}
+int xc_send_i2c_data(unsigned char *bytes_to_send, int nb_bytes_to_send)
+{
+    int i2c_flag,i;
+    i2c_flag=0;
+    i=0;
+    if(!ctc703_client)
+    {
+        printk("[ctc703..]%s i2c client hasn't init.\n",__func__);
+        return XC_RESULT_I2C_WRITE_FAILURE;
+    }
+            struct i2c_msg msg[] = {
+	        {
+			.addr	= ctc703_client->addr,
+			.flags	= 0,    //|I2C_M_TEN,
+			.len	        = nb_bytes_to_send,
+			.buf	        = bytes_to_send,
+	        }
+
+	    };
+
+repeat:
+    i2c_flag = i2c_transfer(ctc703_client->adapter, msg, 1);
+    if (i2c_flag < 0)
+    {
+        printk("%s: error in write addr 0x%x %d,byte(s) should be read,. \n", __func__, ctc703_client->addr,nb_bytes_to_send);
+        if (i++ < I2C_TRY_MAX_CNT) {
+            printk("%s: error in wirte addr 0x%x, try again!!!\n", __func__,ctc703_client->addr);
+            goto repeat;
+        }
+        else
+            return XC_RESULT_I2C_WRITE_FAILURE;
+    }
+    else
+    {
+        //pr_info("%s: write %d bytes\n", __func__, inbbytes);
+        return XC_RESULT_SUCCESS;
+    }
+}
+
+int xc_read_i2c_data(void *bytes_received, int nb_bytes_to_receive)
+{
+     int i2c_flag = 0, i=0;
+   if(!ctc703_client)
+    {
+        printk("[ctc703..]%s i2c client hasn't init.\n",__func__);
+        return XC_RESULT_I2C_WRITE_FAILURE;
+    }
+    struct i2c_msg msg[] = {
+	    {
+			.addr	= ctc703_client->addr|0x1,
+			.flags	= I2C_M_RD,
+			.len	        = nb_bytes_to_receive,
+			.buf	        = bytes_received,
+	    }
+
+	};
+repeat:
+    i2c_flag = i2c_transfer(ctc703_client->adapter, msg, 1);
+    if (i2c_flag < 0)
+    {
+        printk("%s: error in write addr 0x%x byte(s) should be read,. \n", __func__, ctc703_client->addr|0x1,nb_bytes_to_receive);
+        if (i++ < I2C_TRY_MAX_CNT) {
+            printk("%s: error in wirte addr 0x%x, try again!!!\n", __func__,ctc703_client->addr|0x1);
+            goto repeat;
+        }
+        else
+            return XC_RESULT_I2C_READ_FAILURE;
+    }
+    else
+    {
+        //pr_info("%s: write %d bytes\n", __func__, inbbytes);
+        return XC_RESULT_SUCCESS;
+    }
+}
+
+void xc_wait(int wait_ms)
+{
+  mdelay(wait_ms);
+}
+
+int xc_write_reg(unsigned short int regAddr, unsigned short int i2cData)
+{
+  unsigned char buf[4];
+  int WatchDogTimer = 5;
+  int result;
+  buf[0] = (regAddr >> 8) & 0xFF;
+  buf[1] = regAddr & 0xFF;
+  buf[2] = (i2cData >> 8) & 0xFF;
+  buf[3] = i2cData & 0xFF;
+  result = xc_send_i2c_data(buf, 4);
+  if ( result == XC_RESULT_SUCCESS)
+  {
+    // wait for busy flag to clear
+    while ((WatchDogTimer > 0) && (result == XC_RESULT_SUCCESS))
+    {
+      buf[0] = 0;
+      buf[1] = XREG_BUSY;
+      result = xc_send_i2c_data(buf, 2);
+      if (result == XC_RESULT_SUCCESS)
+      {
+        result = xc_read_i2c_data(buf, 2);
+        if (result == XC_RESULT_SUCCESS)
+        {
+          if ((buf[0] == 0) && (buf[1] == 0))
+          {
+            // busy flag cleared
+            break;
+          }
+          else
+          {
+            xc_wait(100);     // wait 5 ms
+            WatchDogTimer--;
+          }
+        }
+      }
+    }
+  }
+  if (WatchDogTimer < 0)
+  {
+    result = XC_RESULT_I2C_WRITE_FAILURE;
+  }
+  return result;
+}
+
+int xc_read_reg(unsigned short regAddr, unsigned short int *i2cData)
+{
+  unsigned char buf[2];
+  int result;
+
+  buf[0] = (regAddr >> 8) & 0xFF;
+  buf[1] = regAddr & 0xFF;
+  result = xc_send_i2c_data(buf, 2);
+  if (result!=XC_RESULT_SUCCESS)
+    return result;
+
+  result = xc_read_i2c_data(buf, 2);
+  if (result!=XC_RESULT_SUCCESS)
+    return result;
+
+  *i2cData = buf[0] * 256 + buf[1];
+  return result;
+}
+
+int xc_load_i2c_sequence()
+{
+  int i,nbytes_to_send,result;
+  unsigned int length, pos, index;
+  unsigned char buf[XC_MAX_I2C_WRITE_LENGTH];
+
+  index=0;
+  while ((xc7000_fw[index]!=0xFF) || (xc7000_fw[index+1]!=0xFF))
+  {
+    length = (xc7000_fw[index]<<8) + (xc7000_fw[index+1]);
+    if (length==0x0000)
+    {
+      //this is in fact a RESET command
+      result = xc_reset();
+      index += 2;
+      if (result!=XC_RESULT_SUCCESS)
+        return result;
+    }
+    else if (length & 0x8000)
+    {
+      //this is in fact a WAIT command
+      xc_wait(length & 0x7FFF);
+      index += 2;
+    }
+    else
+    {
+      //send i2c data whilst ensuring individual transactions do
+      //not exceed XC_MAX_I2C_WRITE_LENGTH bytes
+      index += 2;
+      buf[0] = xc7000_fw[index];
+      buf[1] = xc7000_fw[index + 1];
+      pos = 2;
+      while (pos < length)
+      {
+        if ((length - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)
+        {
+          nbytes_to_send = XC_MAX_I2C_WRITE_LENGTH;
+        }
+        else
+        {
+          nbytes_to_send = (length - pos + 2);
+        }
+        for (i=2; i<nbytes_to_send; i++)
+        {
+          buf[i] = xc7000_fw[index + pos + i - 2];
+        }
+        result = xc_send_i2c_data(buf, nbytes_to_send);
+
+        if (result!=XC_RESULT_SUCCESS)
+          return result;
+
+        pos += nbytes_to_send - 2;
+      }
+      index += length;
+    }
+  }
+  return XC_RESULT_SUCCESS;
+}
+
+int xc_initialize()
+{
+    int result;
+    // if base firmware has changed, then do hardware reset and reload base
+    // firmware file
+
+       //reset function in frontend
+       result = xc_reset();
+       if (result!=XC_RESULT_SUCCESS)
+           return result;
+
+       result = xc_load_i2c_sequence();
+
+       if (result!=XC_RESULT_SUCCESS)
+           return result;
+       xc_write_reg(XREG_INIT, 0);
+
+    // if standard-specific firmware has changed then reload standard-specific firmware file
+    /*if ( std_firmware_changed )
+    {
+
+        current_tv_mode_ptr = new_tv_mode_ptr;
+        current_channel_map_ptr = new_channel_map_ptr;
+
+        xc_set_tv_standard(new_tv_mode_ptr);
+
+        //do not return error if channel is incorrect...
+        xc_set_channel( current_IF_Freq_khz, current_channel_ptr );
+        xc_wait(30);                                                     // wait 30ms
+    }*/
+
+    return XC_RESULT_SUCCESS;
+}
+
+int xc_set_tv_standard(v4l2_std_id id )
+{
+    int i=0, error_code=0;
+    struct ctc703_standard_s *curr_standard = NULL;
+    for(i=0; i<CTC703_MAX_STANDARD_NUM; i++)
+    {
+        if(id == tv_standard[i].id)
+        {
+            curr_standard = &tv_standard[i];
+            break;
+        }
+    }
+    if(i >= CTC703_MAX_STANDARD_NUM)
+        printk("[ctc703..]%s not support %s.\n",__func__,v4l2_std_to_str(id));
+    error_code = xc_write_reg(XREG_VIDEO_MODE, curr_standard->vidmode);
+    if (error_code == XC_RESULT_SUCCESS)
+        error_code = xc_write_reg(XREG_AUDIO_MODE, curr_standard->audmode);
+    return error_code;
+}
+
+int xc_set_rf_frequency(long frequency_in_hz)
+{
+  unsigned int frequency_code;
+  if ((frequency_in_hz>1023000000) || (frequency_in_hz<1000000))
+    return XC_RESULT_OUT_OF_RANGE;
+
+  frequency_code = (unsigned int)(frequency_in_hz / 15625L);
+  return xc_write_reg(XREG_RF_FREQ ,frequency_code);
+}
+
+int xc_FineTune_RF_frequency(long frequency_in_hz)
+{
+  unsigned int frequency_code;
+  if ((frequency_in_hz>1023000000) || (frequency_in_hz<1000000))
+    return XC_RESULT_OUT_OF_RANGE;
+
+  frequency_code = (unsigned int)(frequency_in_hz / 15625L);
+  return xc_write_reg(XREG_FINERFFREQ ,frequency_code);
+}
+
+int xc_set_if_frequency(long frequency_in_hz)
+{
+  unsigned int frequency_code = ( (frequency_in_hz/1000) * 1024)/1000;
+  return xc_write_reg(XREG_IF_OUT ,frequency_code);
+}
+/*
+int xc_set_channel(long if_freq_khz, XC_CHANNEL * channel_ptr)
+{
+    long  rf_freq_khz;
+
+    if ( channel_ptr != NULL )
+    {
+      rf_freq_khz = channel_ptr->frequency *250/16;            // convert from Mhz to Khz
+
+      xc_set_if_frequency(if_freq_khz*1000);           // Set IF out Freq: base on SCode, DCode
+
+      return xc_FineTune_RF_frequency(rf_freq_khz*1000 );      // XC7000 change Freq;
+    }
+  return XC_RESULT_OUT_OF_RANGE;
+}
+*/
+int xc_set_Xtal_frequency(long xtalFreqInKHz)
+{
+  unsigned int xtalRatio = (32000 * 0x8000)/xtalFreqInKHz;
+  return xc_write_reg(XREG_XTALFREQ ,xtalRatio);
+}
+
+int xc_set_rf_mode(unsigned short SourceType)
+{
+  return xc_write_reg(XREG_SIGNALSOURCE, SourceType);
+}
+
+int xc_set_DDIMode(unsigned short ddimode)
+{
+  return xc_write_reg(XREG_DDIMODE ,ddimode);
+}
+
+int xc_shutdown()
+{
+  return xc_write_reg(XREG_POWER_DOWN, 0);
+}
+
+int xc_get_ADC_Envelope(unsigned short *adc_envelope)
+{
+  return xc_read_reg(XREG_ADC_ENV, adc_envelope);
+}
+
+// Obtain current frequency error
+// Refer to datasheet for values.
+int xc_get_frequency_error(int *frequency_error_hz)
+{
+  unsigned short int data;
+  short int signed_data;
+  int result;
+
+  result = xc_read_reg(XREG_FREQ_ERROR, &data);
+  if (result)
+    return result;
+
+  signed_data = (short int)data;
+  (*frequency_error_hz) = signed_data * 15625;
+
+  return 0;
+}
+
+// Obtain current lock status.
+// Refer to datasheet for values.
+int xc_get_lock_status(unsigned short int *lock_status)
+{
+  return xc_read_reg(XREG_LOCK, lock_status);
+}
+
+// Obtain Version codes.
+// Refer to datasheet for values.
+int xc_get_version(unsigned char* hw_majorversion,
+                       unsigned char* hw_minorversion,
+                       unsigned char* fw_majorversion,
+                       unsigned char* fw_minorversion)
+{
+  unsigned short int data;
+  int result;
+
+  result = xc_read_reg(XREG_VERSION, &data);
+  if (result)
+    return result;
+
+    (*hw_majorversion) = (data>>12) & 0x0F;
+    (*hw_minorversion) = (data>>8) & 0x0F;
+    (*fw_majorversion) = (data>>4) & 0x0F;
+    (*fw_minorversion) = (data) & 0x0F;
+
+  return 0;
+}
+
+// Obtain Product ID.
+// Refer to datasheet for values.
+int xc_get_product_id(unsigned short int *product_id)
+{
+  return xc_read_reg(XREG_PRODUCT_ID, product_id);
+}
+
+// Obtain current horizontal video frequency.
+// Refer to datasheet for values.
+int xc_get_hsync_freq(int *hsync_freq_hz)
+{
+  unsigned short int regData;
+  int result;
+
+  result = xc_read_reg(XREG_HSYNC_FREQ, &regData);
+  if (result)
+    return result;
+  (*hsync_freq_hz) = ((regData & 0x0fff) * 763)/100;
+  return result;
+}
+
+ // Obtain current number of lines per frame.
+ // Refer to datasheet for values.
+int xc_get_frame_lines(unsigned short int *frame_lines)
+{
+  return xc_read_reg(XREG_FRAME_LINES, frame_lines);
+}
+
+// Obtain current video signal quality.
+// Refer to datasheet for values.
+int xc_get_quality(unsigned short int *quality)
+{
+  return xc_read_reg(XREG_QUALITY, quality);
+}
+
+// Get the Clock Freq of the tuner
+int xc_get_clock_freq(unsigned short int *clock_freq)
+{
+  return xc_read_reg(XREG_CLOCKFREQ, clock_freq);
+}
+
+unsigned short int WaitForLock()
+{
+  unsigned short int lockState = 0;
+  int watchDogCount = 40;
+  while ((lockState == 0) && (watchDogCount > 0))
+  {
+    xc_get_lock_status(&lockState);
+    if (lockState != 1)
+    {
+      xc_wait(5);      // wait 5 ms
+      watchDogCount--;
+    }
+  }
+  return lockState;
+}
+
+bool xc_scan_channel(long chnl_freq)
+{
+  	long freq_error;
+  	long  min_freq_error;
+	long max_freq_error;
+  	unsigned short int quality=0, max_quality=0;
+  int res=0;
+  bool  chnl_found = false;
+
+  if (xc_set_rf_frequency(chnl_freq) != XC_RESULT_SUCCESS)
+    return false;
+  if (WaitForLock()== 1)
+  {
+    chnl_found = true;
+    //add new channel
+  }
+  return chnl_found;
+}
+
+//numberOfSeek declare the number of afc range,
+int xc_write_seek_frequency(int numberOfSeek, short int afc_range[])
+{
+  // each unit of seekFreqcies is 15.625 KHz
+  int seekIndex, commStatus = 0;
+  commStatus = xc_write_reg(XREG_SEEK_MODE, numberOfSeek << 4);
+  for (seekIndex=0; seekIndex < numberOfSeek; seekIndex++)
+  {
+    commStatus |= xc_write_reg(XREG_SEEK_MODE, (afc_range[seekIndex] << 4) + seekIndex + 1);
+  }
+  return commStatus;
+}
+
+// change the channle, like xc_set_channel
+void xc_channel_tuning(long rf_freq_khz, int if_freq_khz )
+{
+  xc_set_if_frequency(if_freq_khz * 1000);
+  xc_FineTune_RF_frequency(rf_freq_khz * 1000);
+  xc_wait(10);                             // wait to make sure the channel is stable!
+}
+
+
diff --git a/drivers/amlogic/dvb_tv/cresta/ctc703_func.h b/drivers/amlogic/dvb_tv/cresta/ctc703_func.h
new file mode 100755
index 000000000000..c73b1b6d67eb
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/cresta/ctc703_func.h
@@ -0,0 +1,164 @@
+/*
+*
+* Author: kele bai <kele.bai@amlogic.com>
+*
+* Copyright (C) 2010 Amlogic Inc.
+ *
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef  __CTC703_FUNC_H
+#define __CTC703_FUNC_H
+#include <linux/i2c.h>
+#include "../aml_fe.h"
+
+#define I2C_TRY_MAX_CNT                                     3
+
+#define XC_RESULT_SUCCESS                               0
+#define XC_RESULT_RESET_FAILURE                   1
+#define XC_RESULT_I2C_WRITE_FAILURE            2
+#define XC_RESULT_I2C_READ_FAILURE              3
+#define XC_RESULT_OUT_OF_RANGE                    5
+
+#define XC_MAX_I2C_WRITE_LENGTH                     64
+
+#define XC_RESULT_SUCCESS                               0
+#define XC_RESULT_RESET_FAILURE                   1
+#define XC_RESULT_I2C_WRITE_FAILURE            2
+#define XC_RESULT_I2C_READ_FAILURE              3
+#define XC_RESULT_OUT_OF_RANGE                    5
+//write only register define
+#define XREG_INIT                                                   0x00
+#define XREG_VIDEO_MODE                                   0x01
+#define XREG_AUDIO_MODE                                   0x02
+#define XREG_RF_FREQ                                          0x03
+#define XREG_D_CODE                                            0x04
+#define XREG_IF_OUT                                              0x05
+#define XREG_SEEK_MODE                                     0x07
+#define XREG_POWER_DOWN                                0x0A
+#define XREG_SIGNALSOURCE                              0x0D
+#define XREG_SMOOTHEDCVBS                             0x0E
+#define XREG_XTALFREQ                                        0x0F
+#define XREG_FINERFFREQ                                    0x10
+#define XREG_DDIMODE                                          0x11
+//read only register define
+#define XREG_ADC_ENV                                          0x00
+#define XREG_QUALITY                                           0x01
+#define XREG_FRAME_LINES                                  0x02
+#define XREG_HSYNC_FREQ                                  0x03
+#define XREG_LOCK                                                 0x04
+#define XREG_FREQ_ERROR                                  0x05
+#define XREG_SNR                                                   0x06
+#define XREG_VERSION                                          0x07
+#define XREG_PRODUCT_ID                                   0x08
+#define XREG_BUSY                                                 0x09
+#define XREG_CLOCKFREQ                                     0x10
+extern unsigned char xc7000_fw[16497];
+extern void xc_set_i2c_client(struct i2c_client *client);
+
+// Sends data bytes to xc4000 via I2C starting with
+// bytes_to_send[0] and ending with bytes_to_send[nb_bytes_to_send-1]
+extern int xc_send_i2c_data(unsigned char *bytes_to_send, int nb_bytes_to_send);
+
+// Reads data bytes from xc4000 via I2C starting with
+// bytes_received[0] and ending with bytes_received[nb_bytes_to_receive-1]
+int xc_read_i2c_data( void *bytes_received, int nb_bytes_to_receive);
+
+// Does hardware reset
+extern int xc_reset(void);
+
+// Waits for wait_ms milliseconds
+extern void xc_wait(int wait_ms);
+
+extern int xc_write_reg(unsigned short regAddr, unsigned short i2cData);
+
+extern int xc_read_reg( unsigned short regAddr, unsigned short *i2cData);
+
+// Download firmware
+extern int xc_load_i2c_sequence(void);
+
+// Perform calibration and initialize default parameter
+extern int xc_initialize(void);
+
+// Initialize device according to supplied tv mode.
+extern int xc_set_tv_standard(v4l2_std_id id);
+
+extern int xc_set_rf_frequency(long frequency_in_hz);
+
+extern int xc_FineTune_RF_frequency(long frequency_in_hz);
+
+extern int xc_set_if_frequency(long frequency_in_hz);
+
+extern int  xc_get_clock_freq(unsigned short int *clock_freq);
+// to set the TV channel.
+//int xc_set_channel(long if_freq_khz, XC_CHANNEL* new_channel_ptr);
+
+extern int xc_set_rf_mode(unsigned short SourceType);
+
+// set crystal frequency, input value is KHz
+extern int xc_set_Xtal_frequency(long xtalFreqInKHz);
+
+extern int xc_set_DDIMode(unsigned short ddimode);
+
+// Power-down device.
+extern int xc_shutdown();
+
+// Get ADC envelope value.
+extern int xc_get_ADC_Envelope(unsigned short *adc_envelope);
+
+// Get current frequency error.
+extern int xc_get_frequency_error(int *frequency_error_mhz);
+
+// Get lock status.
+extern int xc_get_lock_status(unsigned short *lock_status);
+extern unsigned short int WaitForLock();
+
+// Get device version information.
+extern int xc_get_version( unsigned char* hw_majorversion,unsigned char* hw_minorversion,
+                        unsigned char* fw_majorversion, unsigned char* fw_minorversion);
+
+// Get device product ID.
+extern int xc_get_product_id(unsigned short *product_id);
+
+// Get horizontal sync frequency.
+extern int xc_get_hsync_freq(int *hsync_freq_hz);
+
+// Get number of lines per frame.
+extern int xc_get_frame_lines(unsigned short *frame_lines);
+
+// Get quality estimate.
+extern int xc_get_quality(unsigned short *quality);
+
+// Get the Clock Freq of the tuner
+extern int xc_get_clock_freq(unsigned short *clock_freq);
+
+// tune a channel and return the lock status
+extern bool xc_scan_channel(long chnl_freq);
+
+extern int xc_write_seek_frequency(int numberOfSeek, short afc_range[]);
+
+// change the channle, like xc_set_channel
+extern void xc_channel_tuning(long rf_freq_khz, int if_freq_khz );
+
+typedef struct ctc703_standard_s{
+    v4l2_std_id       id;
+    unsigned short audmode;
+    unsigned short vidmode;
+}ctc703_standard_t;
+
+typedef struct ctc703_param_s{
+    int reset_gpio;
+    int reset_value;
+}ctc703_param_t;
+typedef struct ctc703_device_s{
+    struct i2c_client tuner_client;
+    struct class *clsp;
+    struct analog_parameters parm;
+    struct ctc703_param_s cpram;
+}ctc703_device_t;
+
+//---------------------------------------------------------------------------
+#endif
+
diff --git a/drivers/amlogic/dvb_tv/mxl101/Makefile b/drivers/amlogic/dvb_tv/mxl101/Makefile
new file mode 100755
index 000000000000..334c7b8e3eed
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_AM_MXL101) += mxl101_fe.o
+
+mxl101_fe-objs =  mxlfrontend.o	MxL101SF_PhyCfg.o	MxL101SF_OEM_Drv.o	MxL101SF_PhyCtrlApi.o	demod_MxL101SF.o
diff --git a/drivers/amlogic/dvb_tv/mxl101/MaxLinearDataTypes.h b/drivers/amlogic/dvb_tv/mxl101/MaxLinearDataTypes.h
new file mode 100755
index 000000000000..c114d9a35b8f
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/MaxLinearDataTypes.h
@@ -0,0 +1,176 @@
+/*******************************************************************************
+ *
+ * FILE NAME          : MaxLinearDataTypes.h
+ *
+ * AUTHOR             : Brenndon Lee
+ * DATE CREATED       : Jul/31, 2006
+ *
+ * DESCRIPTION        : This file contains MaxLinear-defined data types.
+ *                      Instead of using ANSI C data type directly in source code
+ *                      All module should include this header file.
+ *                      And conditional compilation switch is also declared
+ *                      here.
+ *
+ *******************************************************************************
+ *                Copyright (c) 2006, MaxLinear, Inc.
+ ******************************************************************************/
+
+#ifndef __MAXLINEAR_DATA_TYPES_H__
+#define __MAXLINEAR_DATA_TYPES_H__
+
+//#include "MsTypes.h"
+/******************************************************************************
+    Include Header Files
+    (No absolute paths - paths handled by make file)
+******************************************************************************/
+
+/******************************************************************************
+    Macros
+******************************************************************************/
+#define __WINDOWS_PLATFORM__
+
+// Macro for contitional compilation of code in driver
+// This macro will be defined if there is a need to control Demod from driver
+// for eg. running GraphEdit.
+// if there is no need to allow control of demod from driver this macro will be
+// disabled
+//#define MXL_LIB_CTRL
+
+//#define _TARGET_FPGA_V6_
+
+#define BIG_TO_LITTLE_16(ptr, offset)    ((ptr[offset++] << 8)| ptr[offset++])
+
+#define WRITE_OP  0
+#define READ_OP   1
+
+/******************************************************************************
+    User-Defined Types (Typedefs)
+******************************************************************************/
+#define	 MS_U8		unsigned char
+#define	 MS_U16		unsigned short
+#define	 MS_U32		unsigned int
+#define	 MS_S8		signed char
+#define	 MS_S16		signed short
+#define	 MS_S32		signed int
+
+
+
+
+typedef MS_U8  UINT8;
+typedef MS_U16 UINT16;
+typedef MS_U32   UINT32;
+typedef MS_S8           SINT8;
+typedef MS_S16          SINT16;
+typedef MS_S32            SINT32;
+//typedef float          REAL32;
+//typedef double         REAL64;
+
+#ifdef __WINDOWS_PLATFORM__
+
+typedef enum
+{
+  MXL_TRUE = 0,
+  MXL_FALSE = 1,
+
+} MXL_STATUS;
+
+typedef enum
+{
+  MXL_DISABLE = 0,
+  MXL_ENABLE,
+
+  MXL_NO_FREEZE = 0,
+  MXL_FREEZE,
+
+  MXL_UNLOCKED = 0,
+  MXL_LOCKED,
+
+  MXL_OFF = 0,
+  MXL_ON
+
+} MXL_BOOL;
+
+#else // __WINDOWS_PLATFORM__
+
+#ifdef TRUE
+#undef TRUE
+#endif
+
+#ifdef FALSE
+#undef FALSE
+#endif
+
+#ifdef NULL
+#undef NULL
+#endif
+#define NULL 0
+
+#ifdef BOOL
+#undef BOOL
+#endif
+
+typedef enum
+{
+  TRUE = 1,
+  FALSE = 0,
+
+  PASSED = 1,
+  FAILED = 0,
+
+  GOOD = 1,
+  BAD = 0,
+
+  YES = 1,
+  NO = 0,
+
+  ENABLED = 1,
+  DISABLED = 0,
+
+  ON = 1,
+  OFF = 0,
+
+  SUCCESS = 1,
+  FAIL = 0,
+
+  VALID = 1,
+  INVALID = 0,
+
+  BUSY = 1,
+  IDLE = 0,
+
+} BOOL;
+#endif  //  __WINDOWS_PLATFORM__
+
+// The macro for memory-mapped register access
+
+#define HWD_REG32(addr)             (*(volatile UINT32*)addr)
+
+#define HWD_REG_WRITE32(addr, data) (*(volatile UINT32*)addr = (UINT32)data)
+#define HWD_REG_WRITE16(addr, data) (*(volatile UINT16*)addr = (UINT16)data)
+#define HWD_REG_WRITE08(addr, data) (*(volatile UINT8*)addr = (UINT8)data)
+
+#define HWD_REG_READ32(addr)        (*(volatile UINT32*)addr)
+#define HWD_REG_READ16(addr)        (*(volatile UINT16*)addr)
+#define HWD_REG_READ08(addr)        (*(volatile UINT8*)addr)
+
+#define PHY_REG32(addr)             (*(volatile UINT32*)addr)
+
+#define PHY_REG_WRITE32(addr, data) (*(volatile UINT32*)addr = (UINT32)data)
+#define PHY_REG_WRITE16(addr, data) (*(volatile UINT16*)addr = (UINT16)data)
+#define PHY_REG_WRITE08(addr, data) (*(volatile UINT8*)addr = (UINT8)data)
+
+#define PHY_REG_READ32(addr)        (*(volatile UINT32*)addr)
+#define PHY_REG_READ16(addr)        (*(volatile UINT16*)addr)
+#define PHY_REG_READ08(addr)        (*(volatile UINT8*)addr)
+
+
+/******************************************************************************
+    Global Variable Declarations
+******************************************************************************/
+
+/******************************************************************************
+    Prototypes
+******************************************************************************/
+
+#endif /* __MAXLINEAR_DATA_TYPES_H__ */
+
diff --git a/drivers/amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.c b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.c
new file mode 100755
index 000000000000..12829b8977f8
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.c
@@ -0,0 +1,261 @@
+/*******************************************************************************
+ *
+ * FILE NAME          : MxL101SF_OEM_Drv.cpp
+ *
+ * AUTHOR             : Brenndon Lee
+ * DATE CREATED       : 1/24/2008
+ *
+ * DESCRIPTION        : This file contains I2C emulation routine
+ *
+ *******************************************************************************
+ *                Copyright (c) 2006, MaxLinear, Inc.
+ ******************************************************************************/
+
+#include "MxL101SF_OEM_Drv.h"
+//#include "MsTypes.h"
+//#include "drvIIC.h"
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : Ctrl_ReadRegister
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/24/2008
+--|                 8/22/2008
+--|
+--| DESCRIPTION   : This function reads register data of the provided-address
+--|
+--| RETURN VALUE  : True or False
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS Ctrl_ReadRegister(UINT8 regAddr, UINT8 *dataPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  // User should implememnt his own I2C read register routine corresponding to
+  // his hardaware.
+
+  //printf("MxL Reg Read : Addr - 0x%x, data - 0x%x\n", regAddr, *dataPtr);
+  //i2cSlaveAddr<<1;
+  //i2cSlaveAddr|=0x1;
+  //UINT8 i2cSlaveAddr = 0xC1;
+  UINT8 i2cSlaveAddr = fe->i2c_addr;
+  UINT8 u8Reg[2];
+  u8Reg[0] = 0xFB;
+  u8Reg[1] = regAddr;
+  I2CWrite(i2cSlaveAddr, u8Reg, 2, fe);
+  if(I2CRead(i2cSlaveAddr, dataPtr, 1, fe)==0)
+  {
+		status = MXL_FALSE;
+  }
+ /*  if(MDrv_IIC_Read(i2cSlaveAddr,u8Reg,2,dataPtr,1)==FALSE)
+  {
+	  	status = MXL_FALSE;
+  }	*/
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : Ctrl_WriteRegister
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/24/2008
+--|
+--| DESCRIPTION   : This function writes the provided value to the specified
+--|                 address.
+--|
+--| RETURN VALUE  : True or False
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS Ctrl_WriteRegister(UINT8 regAddr, UINT8 regData, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  // User should implememnt his own I2C write register routine corresponding to
+  // his hardaware.
+
+ // printf("MxL Reg Write : Addr - 0x%x, data - 0x%x\n", regAddr, regData);
+  //i2cSlaveAddr<<1;
+  //i2cSlaveAddr &= 0xFE;
+//  UINT8 i2cSlaveAddr = 0xC0;
+  UINT8 i2cSlaveAddr = fe->i2c_addr;
+  UINT8 u8Reg[2];
+  u8Reg[0] = regAddr;
+  u8Reg[1] = regData;
+//  I2CWrite(i2cSlaveAddr, &regAddr, 1);
+  if(I2CWrite(i2cSlaveAddr, u8Reg, 2, fe)==0)
+  {
+		status = MXL_FALSE;
+  }
+/*  if(MDrv_IIC_Write(i2cSlaveAddr,&regAddr,1,&regData,1)==FALSE)
+  {
+	  	status = MXL_FALSE;
+  }*/
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : Ctrl_Sleep
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 8/31/2009
+--|
+--| DESCRIPTION   : This function will cause the calling thread to be suspended
+--|                 from execution until the number of milliseconds specified by
+--|                 the argument time has elapsed
+--|
+--| RETURN VALUE  : True or False
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS Ctrl_Sleep(UINT16 TimeinMilliseconds)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  // User should implememnt his own sleep routine corresponding to
+  // his Operating System platform.
+	udelay(TimeinMilliseconds);
+  //printf("Ctrl_Sleep : %d msec's\n", Time);
+ // SysDelay(TimeinMilliseconds);
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : Ctrl_GetTime
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 10/05/2009
+--|
+--| DESCRIPTION   : This function will return current system's timestamp in
+--|                 milliseconds resolution.
+--|
+--| RETURN VALUE  : True or False
+--|
+--|---------------------------------------------------------------------------*/
+
+extern unsigned int jiffies_to_msecs(const unsigned long j);
+
+MXL_STATUS Ctrl_GetTime(UINT32 *TimeinMilliseconds)
+{
+  //*TimeinMilliseconds = current systems timestamp in milliseconds.
+  // User should implement his own routine to get current system's timestamp in milliseconds.
+//  *TimeinMilliseconds = MsOS_GetSystemTime();
+//	printk("Ctrl_GetTime\n");
+	*TimeinMilliseconds=jiffies_to_msecs(jiffies);
+//	printk("Ctrl_GetTime,TimeinMilliseconds is %d\n",*TimeinMilliseconds);
+  return MXL_TRUE;
+}
+
+int I2CWrite(UINT8 I2CSlaveAddr, UINT8 *data, int length, struct aml_fe_dev *fe)
+ {
+//	printk("\n[I2CWrite] enter I2CSlaveAddr is %x,length is %d,data[0] is %x,data[1] is %x\n",I2CSlaveAddr,length,data[0],data[1]);
+   /* I2C write, please port this function*/
+   int ret = 0;
+//	unsigned char regbuf[1];			/*8 bytes reg addr, regbuf 1 byte*/
+	struct i2c_msg msg;			/*construct 2 msgs, 1 for reg addr, 1 for reg value, send together*/
+
+//	regbuf[0] = I2CSlaveAddr & 0xff;
+
+	memset(&msg, 0, sizeof(msg));
+
+	/*write reg address*/
+/*	msg[0].addr = (state->config.demod_addr);
+	msg[0].flags = 0;
+	msg[0].buf = regbuf;
+	msg[0].len = 1;*/
+
+
+	/*write value*/
+	msg.addr = I2CSlaveAddr;
+	msg.flags = 0;  //I2C_M_NOSTART;	/*i2c_transfer will emit a stop flag, so we should send 2 msg together,
+																// * and the second msg's flag=I2C_M_NOSTART, to get the right timing*/
+	msg.buf = data;
+	msg.len = length;
+#if 0
+
+	/*write reg address*/
+	msg[0].addr = 0x80;
+	msg[0].flags = 0;
+	msg[0].buf = 0x7;
+	msg[0].len = 1;
+
+	/*write value*/
+	msg[1].addr = 0x80;
+	msg[1].flags = I2C_M_NOSTART;	/*i2c_transfer will emit a stop flag, so we should send 2 msg together,
+																 * and the second msg's flag=I2C_M_NOSTART, to get the right timing*/
+	msg[1].buf = 0x8;
+	msg[1].len = 1;
+
+#endif
+
+//	int i2c_id = -1;
+	/*cfg->demod_addr=0;
+	cfg->tuner_addr=0;
+	cfg->i2c_id=0;
+	cfg->reset_pin=0;*/
+	/*i2c_handle = i2c_get_adapter(i2c_id,i2c_handle);
+	if (!i2c_handle) {
+		printk("cannot get i2c adaptor\n");
+		return 0;
+	}*/
+	ret = i2c_transfer(fe->i2c_adap, &msg, 1);
+	if(ret<0){
+		printk(" %s: writereg error, errno is %d \n", __FUNCTION__, ret);
+		return 0;
+	}
+	else
+		return 1;
+      return 1;
+ }
+
+int  I2CRead(UINT8 I2CSlaveAddr, UINT8 *data, int length, struct aml_fe_dev *fe)
+ {
+     /* I2C read, please port this function*/
+	// 	printk("\n[I2CRead] enter ");
+		 UINT32 nRetCode = 0;
+		 struct i2c_msg msg[1];
+
+		 if(data == 0 || length == 0)
+		 {
+			 printk("mxl101 read register parameter error !!\n");
+			 return 0;
+		 }
+
+	//	 gx1001_set_addr(state, regaddr) ; //set reg address first
+
+		 //read real data
+		 memset(msg, 0, sizeof(msg));
+		 msg[0].addr = I2CSlaveAddr;
+		 msg[0].flags |=  I2C_M_RD;  //write  I2C_M_RD=0x01
+		 msg[0].len = length;
+		 msg[0].buf = data;
+
+
+//	int i2c_id = -1;
+	/*cfg->demod_addr=0;
+	cfg->tuner_addr=0;
+	cfg->i2c_id=0;
+	cfg->reset_pin=0;*/
+	//	printk("\n[I2CRead] get i2c_adapter");
+	/*	i2c_handle = i2c_get_adapter(i2c_id);
+		if (!i2c_handle) {
+			printk("cannot get i2c adaptor\n");
+		}*/
+
+
+		 nRetCode = i2c_transfer(fe->i2c_adap, msg, 1);
+
+		 if(nRetCode != 1)
+		 {
+			 printk("mxl101_readregister reg failure!\n");
+			 return 0;
+		 }
+        return 1;
+ }
+
diff --git a/drivers/amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.h b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.h
new file mode 100755
index 000000000000..e8ecf925015c
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_OEM_Drv.h
@@ -0,0 +1,52 @@
+/*******************************************************************************
+ *
+ * FILE NAME          : MxL101SF_OEM_Drv.h
+ *
+ * AUTHOR             : Brenndon Lee
+ *
+ * DATE CREATED       : Jan/22/2008
+ *
+ * DESCRIPTION        : This file contains I2C-related constants
+ *
+ *******************************************************************************
+ *                Copyright (c) 2006, MaxLinear, Inc.
+ ******************************************************************************/
+
+#ifndef __MXL_CTRL_HWD_H__
+#define __MXL_CTRL_HWD_H__
+
+/******************************************************************************
+    Include Header Files
+    (No absolute paths - paths handled by make file)
+******************************************************************************/
+
+#include "MaxLinearDataTypes.h"
+#include <linux/i2c.h>
+#include "demod_MxL101SF.h"
+#include "../aml_fe.h"
+#include "MxL101SF_OEM_Drv.h"
+
+/******************************************************************************
+    Macros
+******************************************************************************/
+
+#define MxL_DLL_DEBUG0  printf
+
+/******************************************************************************
+    User-Defined Types (Typedefs)
+******************************************************************************/
+
+/******************************************************************************
+    Global Variable Declarations
+******************************************************************************/
+
+/******************************************************************************
+    Prototypes
+******************************************************************************/
+MXL_STATUS Ctrl_Sleep(UINT16 TimeinMilliseconds);
+MXL_STATUS Ctrl_GetTime(UINT32 *TimeinMilliseconds);
+int I2CWrite(UINT8 I2CSlaveAddr, UINT8 *data, int length, struct aml_fe_dev *fe);
+int I2CRead(UINT8 I2CSlaveAddr, UINT8 *data, int length, struct aml_fe_dev *fe);
+
+#endif /* __MXL_CTRL_HWD_H__*/
+
diff --git a/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCfg.c b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCfg.c
new file mode 100755
index 000000000000..9f5b7bfd866b
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCfg.c
@@ -0,0 +1,272 @@
+/*******************************************************************************
+ *
+ * FILE NAME          : MxL101SF_PhyCfg.cpp
+ *
+ * AUTHOR             : Brenndon Lee
+ *
+ * DATE CREATED       : 1/22/2008
+ *
+ * DESCRIPTION        : This file contains control parameters for only MxL101SF
+ *
+ *******************************************************************************
+ *                Copyright (c) 2006, MaxLinear, Inc.
+ ******************************************************************************/
+
+#include "MxL101SF_PhyDefs.h"
+
+REG_CTRL_INFO_T MxL_101OverwriteDefault[] =
+{
+  {0xC8, 0xFF, 0x40},
+  {0x8D, 0x01, 0x01},
+  {0x42, 0xFF, 0x33},
+  {0x71, 0xFF, 0x66},
+  {0x72, 0xFF, 0x01},
+  {0x73, 0xFF, 0x00},
+  {0x71, 0xFF, 0xE6},
+  {0x83, 0xFF, 0x64},
+  {0x85, 0xFF, 0x64},
+  {0x88, 0xFF, 0xF0},
+  {0x6F, 0xFF, 0xB7},
+  {0x98, 0xFF, 0x40},
+  {0x99, 0xFF, 0x18},
+  {0x00, 0xFF, 0x01},
+  {0x81, 0xFF, 0x05},
+  {0xF4, 0xFF, 0x07},
+  {0xD4, 0x1F, 0x2F},
+  {0xD6, 0xFF, 0x0C},
+  {0x00, 0xFF, 0x00},
+  {0, 0, 0}
+};
+
+REG_CTRL_INFO_T MxL_101SuspendMode[] =
+{
+  {0x1C, 0xFF, 0x00},
+  {0x04, 0xFF, 0x02},
+  {0x02, 0xFF, 0x00},
+  {0x01, 0xFF, 0x00},
+  {0x06, 0xDF, 0x00},
+  {0x09, 0xFE, 0x00},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_101WakeUp[] =
+{
+  {0x04, 0xFF, 0x00},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_MpegDataOutToTSIF[] =
+{
+  {0x17, 0xC0, 0xC0},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_PhySoftReset[] =
+{
+  {0xFF, 0xFF, 0x00},
+  {0x02, 0xFF, 0x01},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_TunerDemodMode[] =
+{
+  {0x03, 0xFF, 0x01},
+  {0x7D, 0x40, 0x00},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_TunerMode[] =
+{
+  {0x03, 0xFF, 0x00},
+  {0x7D, 0x40, 0x40},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_TopMasterEnable[] =
+{
+  {0x01, 0xFF, 0x01},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_TopMasterDisable[] =
+{
+  {0x01, 0xFF, 0x00},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_PhyTuneRF[] =
+{
+  {0x1D, 0x7F, 0x00},
+  {0x1E, 0xFF, 0x00},
+  {0x1F, 0xFF, 0x00},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_StartTune[] =
+{
+  {0x00, 0xFF, 0x01},
+  {0x81, 0x1C, 0x04},
+  {0x00, 0xFF, 0x00},
+  {0x1C, 0xFF, 0x01},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_IrqClear[] =
+{
+  {0x0E, 0xFF, 0xFF},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_ResetPerCount[] =
+{
+  {0x20, 0x01, 0x01},
+  {0x20, 0x01, 0x00},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_CableSettings[] =
+{
+  {0x0A, 0x10, 0x10},
+  {0x0A, 0x0F, 0x04},
+  {0x3F, 0x3F, 0x01},
+  {0x44, 0xF0, 0x60},
+  {0x46, 0xF0, 0x10},
+  {0x48, 0xF0, 0x70},
+  {0x48, 0x0F, 0x0C},
+  {0x0D, 0x03, 0x02},
+  {0x4D, 0xFF, 0x40},
+  {0x69, 0x01, 0x01},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_EnableCellId[] =
+{
+  {0x00, 0xFF, 0x01},
+  {0x7E, 0xFF, 0x05},
+  {0x00, 0xFF, 0x00},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_DisableCellId[] =
+{
+  {0x00, 0xFF, 0x01},
+  {0x7E, 0xFF, 0x04},
+  {0x00, 0xFF, 0x00},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_EnableChanScan[] =
+{
+  {0x00, 0xFF, 0x01},
+  {0x81, 0xFF, 0x04},
+  {0xF4, 0xFF, 0x03},
+  {0x00, 0xFF, 0x00},
+  {0,    0,    0}
+};
+
+REG_CTRL_INFO_T MxL_DisableChanScan[] =
+{
+  {0x00, 0xFF, 0x01},
+  {0x81, 0xFF, 0x05},
+  {0xF4, 0xFF, 0x07},
+  {0x00, 0xFF, 0x00},
+  {0,    0,    0}
+};
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : Ctrl_ProgramRegisters
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/15/2008
+--|
+--| DESCRIPTION   : This function writes multiple registers with provided data array.
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS Ctrl_ProgramRegisters(PREG_CTRL_INFO_T ctrlRegInfoPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_TRUE;
+  UINT16 i;
+  UINT8 tmp;
+
+  for (i = 0; ctrlRegInfoPtr[i].regAddr|ctrlRegInfoPtr[i].mask|ctrlRegInfoPtr[i].data; i++)
+  {
+    // Check if partial bits of register were updated
+    if (ctrlRegInfoPtr[i].mask != 0xFF)
+    {
+      status = Ctrl_ReadRegister(ctrlRegInfoPtr[i].regAddr, &tmp, fe);
+      if (status != MXL_TRUE) break;;
+    }
+
+    tmp &= ~ctrlRegInfoPtr[i].mask;
+    tmp |= ctrlRegInfoPtr[i].data;
+
+    status |= Ctrl_WriteRegister(ctrlRegInfoPtr[i].regAddr, tmp, fe);
+    if (status != MXL_TRUE) break;
+  }
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : Ctrl_PhyTune
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/15/2008
+--|                 5/4/2010 - Mahee
+--|
+--| DESCRIPTION   : Tune to the specified RF frequency with bandwidth
+--|
+--|                 The provided input frequency and bandwidth's unit is MHz.
+--|                 Changed to increase frequency resolution.
+--|
+--| RETURN VALUE  : PREG_CTRL_INFO_T
+--|
+--|---------------------------------------------------------------------------*/
+
+PREG_CTRL_INFO_T Ctrl_PhyTune(UINT32 frequency, UINT8 bandwidth)
+{
+  UINT32 freq;
+  UINT8 filt_bw;
+
+  // Set Channel Bandwidth
+  switch (bandwidth)
+  {
+    case 6:
+      filt_bw = 21;
+      break;
+
+    case 7:
+      filt_bw = 42;
+      break;
+
+    case 8:
+      filt_bw = 63;
+      break;
+
+    default:
+      filt_bw = 0x63;
+      break;
+  }
+
+  // Calculate RF Channel
+  frequency /= 15625;
+
+  // Do round
+  freq = frequency;
+
+  // Abort Tune. This control is in the arrary
+  // Set Bandwidth
+  MxL_PhyTuneRF[0].data = filt_bw;
+
+  // Set RF
+  MxL_PhyTuneRF[1].data = (freq & 0xFF);       // Fractional part
+  MxL_PhyTuneRF[2].data = (freq >> 8 ) & 0xFF; // Integer part
+
+  // Start Tune. This control is in the arrary
+  return MxL_PhyTuneRF;
+}
diff --git a/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCtrlApi.c b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCtrlApi.c
new file mode 100755
index 000000000000..744bef0631a1
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCtrlApi.c
@@ -0,0 +1,1980 @@
+/*******************************************************************************
+ *
+ * FILE NAME          : MxL101SF_PhyCtrlApi.cpp
+ *
+ * AUTHOR             : Brenndon Lee
+ * DATE CREATED       : 1/22/2008
+ *
+ * DESCRIPTION        : This file contains control APIs that configure MxL101SF
+ *                      and read back the statistics through I2C interface.
+ *
+ *******************************************************************************
+ *                Copyright (c) 2006, MaxLinear, Inc.
+ ******************************************************************************/
+
+#include "MxL101SF_PhyCtrlApi.h"
+#include "MxL101SF_PhyDefs.h"
+#include "MxL101SF_OEM_Drv.h"
+
+
+#if 0
+#define printdebug printf
+#else
+#define printdebug(a...)
+#endif
+
+const UINT8 MxLCtrlVersion[] = {6, 3, 8, 1};
+
+// Variable to store tuned frequency for RSSI calculation
+UINT32 MxLTunedFreq = 0;
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_SoftResetDevice
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 9/8/2008
+--|
+--| DESCRIPTION   : By writing any value into address 0xFF (AIC), all control
+--|                 registers are initialized to the default value.
+--|                 AIC - Address Initiated Command
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_SoftResetDevice(struct aml_fe_dev *fe)
+{
+  return Ctrl_ProgramRegisters(MxL_PhySoftReset, fe);
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_GetChipInfo
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 2/7/2008
+--|
+--| DESCRIPTION   : This function returns MxL101SF Chip Id and version information.
+--|                 Chip Id of MxL101SF has 0x61
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_GetChipInfo(PMXL_DEV_INFO_T DevInfoPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_FALSE;
+  UINT8 readBack;
+
+  status = Ctrl_ReadRegister(CHIP_ID_REG, &readBack, fe);
+  DevInfoPtr->DevId = readBack;
+
+  status |= Ctrl_ReadRegister(TOP_CHIP_REV_ID_REG, &readBack, fe);
+  DevInfoPtr->DevVer = (readBack & 0x0F);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_SetMxLDeviceMode
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/15/2008
+--|
+--| DESCRIPTION   : MxL101SF has a built-in RF Tuner in addtion to DVB-T BB block
+--|                 In tuner only mode, Digial BB will be disabled.
+--|                 MXL_TUNER_MODE : Tuner mode, MXL_SOC_MODE : SOC mode
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_SetMxLDeviceMode(PMXL_DEV_MODE_CFG_T DevModePtr, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_FALSE;
+
+  // Set Device mode
+  if (DevModePtr->DeviceMode == MXL_SOC_MODE)
+    status = Ctrl_ProgramRegisters(MxL_TunerDemodMode, fe);
+  else if (DevModePtr->DeviceMode == MXL_TUNER_MODE)
+    status = Ctrl_ProgramRegisters(MxL_TunerMode, fe);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_TopMasterControl
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 4/17/2009
+--|
+--| DESCRIPTION   : Power up Tuner
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_TopMasterControl(PMXL_TOP_MASTER_CFG_T TopMasterCtrlPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_FALSE;
+
+  if (TopMasterCtrlPtr->TopMasterEnable == MXL_DISABLE)
+    status = Ctrl_ProgramRegisters(MxL_TopMasterDisable, fe);
+  else
+    status = Ctrl_ProgramRegisters(MxL_TopMasterEnable, fe);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_InitTunerDemod
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 7/30/2009
+--|
+--| DESCRIPTION   : Initializing Tuner and Demod block of MxL101SF
+--|                 before tuning to a certain frequency.
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_InitTunerDemod(struct aml_fe_dev *fe)
+{
+  return Ctrl_ProgramRegisters(MxL_101OverwriteDefault, fe);
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_EnableMpegOutput
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 12/19/2008
+--|
+--| DESCRIPTION   : Enable TSIF for MPEG-2 data output
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_EnableMpegOutput(struct aml_fe_dev *fe)
+{
+  return Ctrl_ProgramRegisters(MxL_MpegDataOutToTSIF, fe);
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_ConfigMpegOut
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/15/2008
+--|
+--| DESCRIPTION   : For Transport stream output through ASI(MPEG TS) interface
+--|                 the following parameters are needed to configure after or before
+--|                 demod lock.
+--|                  TS output mode : Seral or Parallel
+--|                  CLK Phase : Normal or Inverted
+--|                  MPEG Valid Polarity : Low or High
+--|                  MPEG Sync Polarity  : Low or High
+--|                  MPEG CLK Frequency  : 0 - 36.571429MHz
+--|                                      : 1 - 2.285714MHz
+--|                                      : 2 - 4.571429MHz
+--|                                      : 3 - 6.857143MHz
+--|                                      : 4 - 9.142857MHz
+--|                                      : 5 - 13.714286MHz
+--|                                      : 6 - 18.285714MHz
+--|                                      : 7 - 27.428571MHz
+--|                 * MxL101SF Feature
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_ConfigMpegOut(PMXL_MPEG_CFG_T MpegOutCfgPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_TRUE;
+  UINT8 mode, tmp;
+
+  mode = 0xC0; // MPEG Out
+
+  // Configure MPEG Clock phase
+  if (MpegOutCfgPtr->MpegClkPhase == MPEG_CLK_IN_PHASE)
+    mode &= ~V6_INVERTED_CLK_PHASE;
+  else
+    mode |= V6_INVERTED_CLK_PHASE;;
+
+  if (MpegOutCfgPtr->MpegClkFreq > MPEG_CLOCK_27_428571MHz)
+    MpegOutCfgPtr->MpegClkFreq = MPEG_CLOCK_27_428571MHz;
+
+  mode |= (((UINT8)MpegOutCfgPtr->MpegClkFreq) << 2);
+
+  status = Ctrl_WriteRegister(V6_MPEG_OUT_CLK_INV_REG, mode, fe);
+
+  // Configure data input mode, MPEG Valid polarity, MPEG Sync polarity
+  // Get current configuration
+  status |= Ctrl_ReadRegister(V6_MPEG_OUT_CTRL_REG, &mode, fe);
+  mode &= 0xF0;
+
+  // Data Input mode
+  if (MpegOutCfgPtr->SerialOrPar == MPEG_DATA_PARALLEL)
+  {
+    mode |= V6_MPEG_DATA_PARALLEL;
+  }
+  else
+  {
+    mode |= V6_MPEG_DATA_SERIAL;
+
+    // If serial interface is selected, configure MSB or LSB order in transmission
+    status |= Ctrl_ReadRegister(V6_MPEG_INOUT_BIT_ORDER_CTRL_REG, &tmp, fe);
+
+    if (MpegOutCfgPtr->LsbOrMsbFirst == MPEG_SERIAL_MSB_1ST)
+      tmp |= V6_MPEG_SER_MSB_FIRST;
+    else
+      tmp &= ~V6_MPEG_SER_MSB_FIRST; // LSB First
+
+    status |= Ctrl_WriteRegister(V6_MPEG_INOUT_BIT_ORDER_CTRL_REG, tmp, fe);
+  }
+
+  // MPEG Sync polarity
+  if (MpegOutCfgPtr->MpegSyncPol == MPEG_CLK_IN_PHASE)
+    mode &= ~V6_INVERTED_MPEG_SYNC;
+  else
+    mode |= V6_INVERTED_MPEG_SYNC;
+
+  // MPEG Valid polarity
+  if (MpegOutCfgPtr->MpegValidPol == MPEG_CLK_IN_PHASE)
+    mode &= ~V6_INVERTED_MPEG_VALID;
+  else
+    mode |= V6_INVERTED_MPEG_VALID;
+
+  status |= Ctrl_WriteRegister(V6_MPEG_OUT_CTRL_REG, mode, fe);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_ConfigDevPowerSavingMode
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 10/20/2009
+--|
+--| DESCRIPTION   : This function configures Standby mode and Sleep mode to
+--|                 control power consumption.
+--|
+--| RETURN VALUE  : True or False
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_ConfigDevPowerSavingMode(PMXL_PWR_MODE_CFG_T PwrModePtr, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_FALSE;
+
+  switch (PwrModePtr->PowerMode)
+  {
+    case STANDBY_ON:
+    case SLEEP_ON:
+      status = Ctrl_ProgramRegisters(MxL_101SuspendMode, fe);
+      break;
+
+    case STANDBY_OFF:
+    case SLEEP_OFF:
+      status = Ctrl_ProgramRegisters(MxL_101WakeUp, fe);
+      status |= MxL101SF_API_SoftResetDevice(fe);
+      status |= MxL101SF_API_InitTunerDemod(fe);
+      break;
+
+    default:
+      break;
+  }
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_TuneRF
+--|
+--| AUTHOR        : Brenndon Lee
+--|                 Mahendra Kondur - updated new topmastercontrol function name
+--|
+--|
+--| DATE CREATED  : 1/15/2008
+--|                 10/23/2009
+--|                 11/20/2009 - Settings for TPS Cell ID
+--|
+--| DESCRIPTION   : After power-on initialization, when channel frequency has
+--|                 changed, this function shall be called
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_TuneRF(PMXL_RF_TUNE_CFG_T TuneParamPtr, struct aml_fe_dev *fe)
+{
+  PREG_CTRL_INFO_T ctrlArrayPtr;
+  MXL_DEMOD_LOCK_STATUS_T cpLock;
+  MXL_BOOL cpLockStatus = MXL_OFF;
+  UINT8 status = MXL_FALSE;
+  UINT8 mxl_mode;
+  UINT8 regData = 0;
+  UINT32 cellIdStartTime;
+  UINT32 StartTime;
+  UINT32 cellIdEndTime;
+  UINT16 TimeOut;
+  UINT8 agcLockStatus;
+  printdebug("MxL101SF_API_TuneRF] in\n");
+  // Stop Tune
+  status = Ctrl_WriteRegister(START_TUNE_REG, 0, fe);
+
+  // Check Device mode
+  status |= Ctrl_ReadRegister(MXL_MODE_REG, &mxl_mode, fe);
+printdebug("mxl_mode is %d,\n",mxl_mode);
+  // Fill out registers for channel tune
+  ctrlArrayPtr = Ctrl_PhyTune(TuneParamPtr->Frequency, TuneParamPtr->Bandwidth);
+
+  if (!ctrlArrayPtr) return MXL_FALSE;
+
+  // Program registers
+  status |= Ctrl_ProgramRegisters(ctrlArrayPtr, fe);
+
+  // Enable TPS Cell ID feature
+  printf("TuneParamPtr->TpsCellIdRbCtrl is %d\n",TuneParamPtr->TpsCellIdRbCtrl);
+  if (TuneParamPtr->TpsCellIdRbCtrl == MXL_ENABLE)
+    status |= Ctrl_ProgramRegisters(MxL_EnableCellId, fe);
+
+  // Start tune
+  status |= Ctrl_ProgramRegisters(MxL_StartTune, fe);
+
+ if ((mxl_mode & MXL_DEV_MODE_MASK) == MXL_SOC_MODE)
+  {
+    Ctrl_GetTime(&cellIdStartTime);
+    Ctrl_GetTime(&StartTime);
+    cellIdEndTime = cellIdStartTime;
+    TimeOut = 300;
+
+    while ((cellIdEndTime - cellIdStartTime) < TimeOut)
+    {
+      // Check for CP Lock
+      status |= MxLWare_API_GetDemodStatus(MXL_DEMOD_CP_LOCK_REQ, &cpLock, fe);
+
+      if (cpLock.Status == MXL_LOCKED)
+      {
+        cpLockStatus = MXL_ON;
+        break;
+      }
+
+      Ctrl_GetTime(&cellIdEndTime);
+    }
+
+    if (cpLockStatus == MXL_OFF)
+    {
+      if (TuneParamPtr->TpsCellIdRbCtrl != MXL_ENABLE)
+        status |= Ctrl_WriteRegister(START_TUNE_REG, 0, fe);
+
+      status |= Ctrl_WriteRegister(0x00, 0x01, fe);
+      status |= Ctrl_ReadRegister(0x81, &regData, fe);
+      regData = regData & 0xE3;
+      status |= Ctrl_WriteRegister(0x81, regData, fe);
+      status |= Ctrl_WriteRegister(0x00, 0x00, fe);
+
+      if (TuneParamPtr->TpsCellIdRbCtrl != MXL_ENABLE)
+        status |= Ctrl_WriteRegister(START_TUNE_REG, 1, fe);
+    }
+
+    // Prep Demod to extract TPS cell ID
+    if (TuneParamPtr->TpsCellIdRbCtrl == MXL_ENABLE)
+    {
+      Ctrl_GetTime(&cellIdStartTime);
+      Ctrl_GetTime(&StartTime);
+      cellIdEndTime = cellIdStartTime;
+      TimeOut = 1024;
+
+      // Check for AGC Lock
+      status = Ctrl_ReadRegister(V6_AGC_LOCK_REG, &regData, fe);
+      agcLockStatus = (regData & V6_AGC_LOCK_MASK) >> 5;
+
+      if (agcLockStatus)
+        TimeOut = 2048;
+
+      while ((cellIdEndTime - cellIdStartTime) < 350)
+      {
+        // Check for CP Lock
+        status |= MxLWare_API_GetDemodStatus(MXL_DEMOD_CP_LOCK_REQ, &cpLock, fe);
+
+        if (cpLock.Status == MXL_UNLOCKED)
+        {
+          if ((cellIdEndTime - StartTime) < TimeOut)
+            Ctrl_GetTime(&cellIdStartTime);
+          else
+            break;
+        }
+        Ctrl_GetTime(&cellIdEndTime);
+      }
+
+      status |= Ctrl_ProgramRegisters(MxL_DisableCellId, fe);
+
+    }
+  }
+printdebug("MxL101SF_API_TuneRF] out\n");
+  MxLTunedFreq = TuneParamPtr->Frequency;
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetSNR
+--|
+--| AUTHOR        : Brenndon Lee
+--|                 Mahendra Kondur - Support for Interger calculation of SNR
+--|
+--| DATE CREATED  : 1/24/2008
+--|                 1/12/2010
+--|
+--| DESCRIPTION   : This function returns SNR(Signal to Noise Ratio).
+--|                 SNR is calculated as follows after reading 10bit register
+--|                 Folting-point calculation:
+--|                  SNR = 10 * SNR_REG_VALUE / 64 - 2.5  dB
+--|                 Integer calculation:
+--|                  10000 x SNR = 1563 x SNR_REG_VALUE - 25000  dB
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetSNR(PMXL_DEMOD_SNR_INFO_T SnrPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_FALSE;
+  UINT32 snrCalc;
+  UINT16 snrData;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_SNR_RB_LSB_REG, &rawData, fe);
+  snrData = rawData;
+ // printf("[MxL101SF_API_DemodGetSNR] snrData_lsb  is %x\n",snrData);
+  status |= Ctrl_ReadRegister(V6_SNR_RB_MSB_REG, &rawData, fe);
+  snrData |= (rawData & 0x03) << 8;
+//  printf("[MxL101SF_API_DemodGetSNR] snrData_msb  is %x\n",rawData);
+  if (status == MXL_TRUE)
+  {
+    snrCalc =  CALCULATE_SNR(snrData);
+    SnrPtr->SNR = snrCalc;
+  }
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetBER
+--|
+--| AUTHOR        : Brenndon Lee
+--|                 Mahendra Kondur - Support for Interger calculation of BER
+--|
+--| DATE CREATED  : 1/24/2008
+--|                 2/24/2010
+--|
+--| DESCRIPTION   : This function returns BER(Bit Error Ratio).
+--|                 Floating-point calculation
+--|                  BER = (AVG_ERRORS x 4)/(N_ACCUMULATE x 64 x 188 x 8)
+--|                 Integer calculation
+--|                  1e10 x BER = (AVG_ERRORS x 4 x 3247)
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetBER(PMXL_DEMOD_BER_INFO_T BerInfoPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+  UINT32 berCalc;
+  UINT32 n_accumulate;
+  UINT16 avg_errors;
+  UINT8 rawData;
+
+  avg_errors = 0;
+  status = Ctrl_ReadRegister(V6_RS_AVG_ERRORS_LSB_REG, &rawData, fe);
+  avg_errors = rawData;
+
+  status |= Ctrl_ReadRegister(V6_RS_AVG_ERRORS_MSB_REG, &rawData, fe);
+  avg_errors |= (rawData << 8);
+
+  status |= Ctrl_ReadRegister(V6_N_ACCUMULATE_REG, &rawData, fe);
+  n_accumulate = rawData;
+
+  berCalc = CALCULATE_BER(avg_errors, n_accumulate);
+//printf("[MxL101SF_API_DemodGetBER] berCalc  is %x\n",berCalc);
+  if (status == MXL_TRUE)
+  {
+    BerInfoPtr->BER = berCalc;
+  }
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetSyncLockStatus
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 5/6/2009
+--|
+--| DESCRIPTION   : This function return SYNC_LOCK Status
+--|                 if 1, Locked
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetSyncLockStatus(PMXL_DEMOD_LOCK_STATUS_T SyncLockPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_SYNC_LOCK_REG, &rawData, fe);
+printdebug("[MxL101SF_API_DemodGetSyncLockStatus] rawData  is %x\n",rawData);
+  if (status == MXL_TRUE)
+  {
+    if ((rawData & SYNC_LOCK_MASK) >> 4)
+      SyncLockPtr->Status = MXL_LOCKED;
+    else
+      SyncLockPtr->Status = MXL_UNLOCKED;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetRsLockStatus
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 4/30/2008
+--|
+--| DESCRIPTION   : This function returns RS Lock status
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetRsLockStatus(PMXL_DEMOD_LOCK_STATUS_T RsLockPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_RS_LOCK_DET_REG, &rawData, fe);
+//printdebug("[MxL101SF_API_DemodGetRsLockStatus] rawData  is %x\n",rawData);
+  if (status == MXL_TRUE)
+  {
+    if ((rawData & RS_LOCK_DET_MASK) >> 3)
+      RsLockPtr->Status = MXL_LOCKED;
+    else
+      RsLockPtr->Status = MXL_UNLOCKED;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetCpLockStatus
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 4/30/2008
+--|
+--| DESCRIPTION   : This function returns CP Lock status
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetCpLockStatus(PMXL_DEMOD_LOCK_STATUS_T CpLockPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_CP_LOCK_DET_REG, &rawData, fe);
+printdebug("[MxL101SF_API_DemodGetCpLockStatus] rawData  is %x\n",rawData);
+  if (status == MXL_TRUE)
+  {
+    if((rawData & V6_CP_LOCK_DET_MASK) >> 2)
+      CpLockPtr->Status = MXL_LOCKED;
+    else
+      CpLockPtr->Status = MXL_UNLOCKED;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodResetIrqStatus
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/24/2008
+--|                 9/09/2008
+--|
+--| DESCRIPTION   : This function clears IRQ status registers
+--|                 Writing 0xFF to this register will clear
+--|                 the previous status
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodResetIrqStatus(struct aml_fe_dev *fe)
+{
+  return Ctrl_ProgramRegisters(MxL_IrqClear, fe);
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetTpsCodeRate
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/24/2008
+--|
+--| DESCRIPTION   : This function returns code rate of TPS parameters
+--|                 bit<2:0> - 000:1/2, 001:2/3, 010:3/4, 011:5/6, 100:7/8
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetTpsCodeRate(PMXL_DEMOD_TPS_INFO_T TpsCodeRatePtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_CODE_RATE_TPS_REG, &rawData, fe);
+printdebug("[MxL101SF_API_DemodGetTpsCodeRate] rawData  is %x\n",rawData);
+  if (status == MXL_TRUE)
+    TpsCodeRatePtr->TpsInfo = rawData & V6_CODE_RATE_TPS_MASK;
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetTpsHierarchy
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/24/2008
+--|
+--| DESCRIPTION   : This function returns Hiearchy information of TPS parameters
+--|                 bit<6:4> - 000:Non hierarchy, 001:1, 010:2, 011:4
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetTpsHierarchy(PMXL_DEMOD_TPS_INFO_T TpsHierarchyPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_TPS_HIERACHY_REG, &rawData, fe);
+printdebug("[MxL101SF_API_DemodGetTpsHierarchy] rawData  is %x\n",rawData);
+  if (status == MXL_TRUE)
+    TpsHierarchyPtr->TpsInfo = (rawData & V6_TPS_HIERARCHY_INFO_MASK) >> 6;
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_ConfigStreamPriority
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 1/14/2010
+--|
+--| DESCRIPTION   : This API will config High priority or Low priority stream
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_ConfigStreamPriority(PMXL_DEMOD_TS_PRIORITY_CFG_T TsPriorityPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_TPS_HPORLP_REG, &rawData, fe);
+
+  if (status == MXL_TRUE)
+  {
+    if (TsPriorityPtr->StreamPriority == LP_STREAM)
+      rawData = (rawData | 0x80);
+    else
+      rawData = (rawData & 0x7F);
+
+    status |= Ctrl_WriteRegister(V6_TPS_HPORLP_REG, rawData, fe);
+  }
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetHierarchicalAlphaValue
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 1/14/2010
+--|
+--| DESCRIPTION   : This function returns Hierarchical Alpha of TPS parameters
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetHierarchicalAlphaValue(PMXL_DEMOD_TPS_INFO_T TpsAlphaPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_TPS_ALPHA_REG, &rawData, fe);
+printdebug("[MxL101SF_API_DemodGetHierarchicalAlphaValue] rawData  is %x\n",rawData);
+  if (status == MXL_TRUE)
+    TpsAlphaPtr->TpsInfo = (rawData & V6_TPS_ALPHA_MASK);
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetTpsConstellation
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/24/2008
+--|
+--| DESCRIPTION   : This function return Constellation status bit information
+--|                 Constellation, 00 : QPSK, 01 : 16QAM, 10:64QAM
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetTpsConstellation(PMXL_DEMOD_TPS_INFO_T TpsConstellationPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 tpsParams;
+
+  status = Ctrl_ReadRegister(V6_MODORDER_TPS_REG, &tpsParams, fe);
+ printdebug("[MxL101SF_API_DemodGetTpsConstellation] tpsParams  is %x\n",tpsParams);
+  if (status == MXL_TRUE)
+    TpsConstellationPtr->TpsInfo = (tpsParams & V6_PARAM_CONSTELLATION_MASK) >> 4 ;
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetTpsFftMode
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/24/2008
+--|
+--| DESCRIPTION   : This function return FFT Mode status bit information
+--|                 FFT Mode, 00:2K, 01:8K, 10:4K
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetTpsFftMode(PMXL_DEMOD_TPS_INFO_T TpsFftModePtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 tpsParams;
+
+  status = Ctrl_ReadRegister(V6_MODE_TPS_REG, &tpsParams, fe);
+  printdebug("[MxL101SF_API_DemodGetTpsFftMode] tpsParams  is %x\n",tpsParams);
+  if (status == MXL_TRUE)
+    TpsFftModePtr->TpsInfo = (tpsParams & V6_PARAM_FFT_MODE_MASK) >> 2 ;
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetTpsGuardInterval
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/24/2008
+--|
+--| DESCRIPTION   : This function return GI status bit information
+--|                 00:1/32, 01:1/16, 10:1/8, 11:1/4
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetTpsGuardInterval(PMXL_DEMOD_TPS_INFO_T TpsGIPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 tpsParams;
+
+  status = Ctrl_ReadRegister(V6_CP_TPS_REG, &tpsParams, fe);
+ printdebug("[MxL101SF_API_DemodGetTpsGuardInterval] tpsParams  is %x\n",tpsParams);
+  if (status == MXL_TRUE)
+    TpsGIPtr->TpsInfo = (tpsParams & V6_PARAM_GI_MASK) >> 4 ;
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetTpsLock
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 7/29/2008
+--|
+--| DESCRIPTION   : This function returns Tps lock status bit information.
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetTpsLock(PMXL_DEMOD_LOCK_STATUS_T TpsLockPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 tpsParams;
+
+  status = Ctrl_ReadRegister(V6_TPS_LOCK_REG, &tpsParams, fe);
+  printf("[MxL101SF_API_DemodGetTpsLock] tpsParams is %x\n",tpsParams);
+  if (status == MXL_TRUE)
+  {
+    if((tpsParams & V6_PARAM_TPS_LOCK_MASK) >> 6)
+      TpsLockPtr->Status = MXL_LOCKED;
+    else
+      TpsLockPtr->Status = MXL_UNLOCKED;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetPacketErrorCount
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 3/13/2008
+--|
+--| DESCRIPTION   : This function returns TS Packet error count.
+--|
+--|                  PER Count = FEC_PER_COUNT * (2 ** (FEC_PER_SCALE * 4))
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetPacketErrorCount(PMXL_DEMOD_PEC_INFO_T PecInfoPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+  UINT32 fec_per_count, fec_per_scale;
+  UINT8 rawData;
+
+  // FEC_PER_COUNT Register
+  status = Ctrl_ReadRegister(V6_FEC_PER_COUNT_REG, &rawData, fe);
+  fec_per_count = rawData;
+
+  // FEC_PER_SCALE Register
+  status |= Ctrl_ReadRegister(V6_FEC_PER_SCALE_REG, &rawData, fe);
+
+  rawData &= V6_FEC_PER_SCALE_MASK;
+  rawData *= 4;
+
+  fec_per_scale = 1 << rawData;
+
+  fec_per_count *= fec_per_scale;
+
+  PecInfoPtr->PEC = fec_per_count;
+  printdebug("[MxL101SF_API_DemodGetPacketErrorCount] fec_per_count  is %x\n",fec_per_count);
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodResetPacketErrorCount
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 3/13/2008
+--|
+--| DESCRIPTION   : This function resets TS Packet error count.
+--|
+--|                 After setting 7th bit of V5_PER_COUNT_RESET_REG,
+--|                 it should be reset to 0.
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodResetPacketErrorCount(struct aml_fe_dev *fe)
+{
+  return Ctrl_ProgramRegisters(MxL_ResetPerCount, fe);
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_TunerGetLockStatus
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 7/3/2008
+--|
+--| DESCRIPTION   : This function provides RF synthesizer lock status
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_TunerGetLockStatus(PMXL_TUNER_LOCK_STATUS_T TunerLockStatusPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 data;
+
+  // Initialize
+  TunerLockStatusPtr->RefSynthLock = MXL_UNLOCKED;
+  TunerLockStatusPtr->RfSynthLock = MXL_UNLOCKED;
+
+  status = Ctrl_ReadRegister(V6_RF_LOCK_STATUS_REG, &data, fe);
+
+  if (status == MXL_TRUE)
+  {
+    if ((data & 3) == 3)
+      TunerLockStatusPtr->RefSynthLock = MXL_LOCKED;;  // Locked
+
+    if ((data & 0xc) == 0xc)
+      TunerLockStatusPtr->RfSynthLock = MXL_LOCKED;;  // Locked
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_TunerSetIFOutputFreq
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 7/7/2008
+--|                 2/24/2010
+--|
+--| DESCRIPTION   : In Tuner only mode of MxL101SF, this function configures
+--|                 IF output frequency
+--|                 Support for IF Frequency in integer format
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_TunerSetIFOutputFreq(PMXL_TUNER_IF_FREQ_T IfFreqParamPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+  UINT8 control;
+  UINT16 IFFCW;
+
+  // Set IF polarity
+  if (IfFreqParamPtr->IF_Polarity == TUNER_NORMAL_IF_SPECTRUM)
+    control = TUNER_NORMAL_IF_SPECTRUM;
+  else
+    control = TUNER_INVERT_IF_SPECTRUM;
+
+  if (IfFreqParamPtr->IF_Index < IF_OTHER_35MHZ_45MHZ)
+  {
+    control |= (UINT8)IfFreqParamPtr->IF_Index;
+  }
+
+  status = Ctrl_WriteRegister(V6_TUNER_IF_SEL_REG, control, fe);
+
+  IfFreqParamPtr->IF_Freq /= 1000000;
+
+  if (IfFreqParamPtr->IF_Index == 0)
+  {
+    control = 0x08;
+
+    IFFCW = (UINT16)(IfFreqParamPtr->IF_Freq / (108 * 4096));
+  }
+  else if (IfFreqParamPtr->IF_Index == 15)
+  {
+    control = 0x08;
+
+    IFFCW = (UINT16)(IfFreqParamPtr->IF_Freq / (216 * 4096));
+  }
+  else
+  {
+    control = 0;
+    IFFCW = 0;
+  }
+
+  control |= (IFFCW >> 8);
+  status |= Ctrl_WriteRegister(V6_TUNER_IF_FCW_BYP_REG, control, fe);
+
+  control = IFFCW & 0x00FF;
+  status |= Ctrl_WriteRegister(V6_TUNER_IF_FCW_REG, control, fe);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_TunerLoopThruControl
+--|
+--| AUTHOR        : Brenndon Lee
+--|                 Mahendra
+--|
+--| DATE CREATED  : 7/7/2008
+--|                 8/4/2009
+--|
+--| DESCRIPTION   : If loop through mode is enabled, RF signal from the antenna
+--|                 is looped through to an external demodulator.
+--|                  0 : Disable, 1: Enable,
+--|                 API is reorganised according to the MxL101SF control structure
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_TunerLoopThruControl(MXL_BOOL EnableDisable, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+  UINT8 control;
+
+  if (EnableDisable == MXL_DISABLE) control = 0; // Disable
+  else control = 1;             // Enable
+
+  status = Ctrl_WriteRegister(V6_TUNER_LOOP_THRU_CTRL_REG, control, fe);
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_XtalSelect
+--|
+--| AUTHOR        : Brenndon Lee
+--|                 Mahendra Kondur
+--|
+--| DATE CREATED  : 7/7/2008
+--|                 8/4/2009
+--|
+--| DESCRIPTION   : Select XTAL frequency of CLK out
+--|                 4 : 24MHz, 8 : 28.8MHz, 7 : 27 MHz, 12 : 48 MHz
+--|                 API is reorganised according to the MxL1x1SF control structure
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_XtalSelect(MXL_XTAL_FREQ_E XtalFreq, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_TRUE;
+
+  status = Ctrl_WriteRegister(V6_DIG_CLK_FREQ_SEL_REG, (UINT8)XtalFreq, fe);
+  status |= Ctrl_WriteRegister(V6_DIG_RFREFSELECT_REG, ((UINT8)XtalFreq)|0xA0, fe);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_XtalClkOutGain
+--|
+--| AUTHOR        : Brenndon Lee
+--|                 Mahendra Kondur
+--|
+--| DATE CREATED  : 7/7/2008
+--|                 8/4/2009
+--|
+--| DESCRIPTION   : If Xtal Clock out is enabled, then a valid clk out gain value
+--|                 should be programmed to the chip.
+--|                 API is reorganised according to the MxL1x1SF control structure
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_XtalClkOutGain(MXL_XTAL_CLK_OUT_GAIN_E ClkOutGain, struct aml_fe_dev *fe)
+{
+  if (ClkOutGain > CLK_OUT_18_75dB) ClkOutGain = CLK_OUT_18_75dB;
+
+  return Ctrl_WriteRegister(V6_XTAL_CLK_OUT_GAIN_REG, (UINT8)ClkOutGain, fe);
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_XtalClkOutControl
+--|
+--| AUTHOR        : Brenndon Lee
+--|                 Mahendra Kondur
+--|
+--| DATE CREATED  : 7/7/2008
+--|                 8/4/2009
+--|
+--| DESCRIPTION   : XTAL Clock out control
+--|                  0 : Disable, 1: Enable,
+--|                 API is reorganised according to the MxL1x1SF control structure
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_XtalClkOutControl(MXL_BOOL EnableDisable, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_TRUE;
+  UINT8 control;
+
+  status = Ctrl_ReadRegister(V6_DIG_XTAL_ENABLE_REG, &control, fe);
+
+  if (EnableDisable == MXL_DISABLE) control &= 0xDF; // Disable
+  else control |= 0x20;             // Enable
+
+  status |= Ctrl_WriteRegister(V6_DIG_XTAL_ENABLE_REG, control, fe);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_XtalBiasControl
+--|
+--| AUTHOR        : Brenndon Lee
+--|                 Mahendra Kondur
+--|
+--| DATE CREATED  : 7/7/2008
+--|                 8/4/2009
+--|
+--| DESCRIPTION   : 0 : 200uA, 1 : 575 uA, ...
+--|                 API is reorganised according to the MxL1x1SF control structure
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_XtalBiasControl(MXL_XTAL_BIAS_E XtalBias, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+  UINT8 control;
+
+  control = 0x10;          // Xtal Enable
+
+  if (XtalBias > I894_2uA) XtalBias = I894_2uA;
+
+  control |= (UINT8)XtalBias;
+
+  status = Ctrl_WriteRegister(V6_DIG_XTAL_BIAS_REG, control, fe);
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_XtalCapControl
+--|
+--| AUTHOR        : Brenndon Lee
+--|                 Mahendra Kondur
+--|
+--| DATE CREATED  : 7/7/2008
+--|                 8/4/2009
+--|
+--| DESCRIPTION   : XTAL Clock Cap control
+--|                 0 : 10pF, 1 : 1 pF, ...
+--|                 API is reorganised according to the MxL1x1SF control structure
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_XtalCapControl(UINT8 XtalCapacitor, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  if ((XtalCapacitor < 26) || (XtalCapacitor == 0x3F))
+    status = Ctrl_WriteRegister(V6_XTAL_CAP_REG, XtalCapacitor, fe);
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_ConfigXtalSettings
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 8/4/2009
+--|
+--| DESCRIPTION   : This API shall configure XTAL settings for MxL101SF
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_ConfigXtalSettings(PMXL_XTAL_CFG_T XtalCfgPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+
+  status = MxL101SF_API_TunerLoopThruControl(XtalCfgPtr->LoopThruEnable, fe);
+  status |= MxL101SF_API_XtalSelect(XtalCfgPtr->XtalFreq, fe);
+  status |= MxL101SF_API_XtalClkOutGain(XtalCfgPtr->XtalClkOutGain, fe);
+  status |= MxL101SF_API_XtalClkOutControl(XtalCfgPtr->XtalClkOutEnable, fe);
+  status |= MxL101SF_API_XtalBiasControl(XtalCfgPtr->XtalBiasCurrent, fe);
+  status |= MxL101SF_API_XtalCapControl(XtalCfgPtr->XtalCap, fe);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_GetTunerSignalStrength
+--|
+--| AUTHOR        : Mahendra
+--|
+--| DATE CREATED  : 10/20/2009
+--|
+--| DESCRIPTION   : This API shall give MxL101SF's RF Signal Strength in dBm unit
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_GetTunerSignalStrength(PMXL_SIGNAL_STATS_T SigQualityPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+  UINT8 regData;
+  UINT16 rxPwr;
+  SINT16 rfPwrAdj = 0;
+
+  status = Ctrl_WriteRegister(0x00, 0x02, fe);
+
+  status |= Ctrl_ReadRegister(V6_DIG_RF_PWR_LSB_REG, &regData, fe);
+  rxPwr = regData;
+
+  status |= Ctrl_ReadRegister(V6_DIG_RF_PWR_MSB_REG, &regData, fe);
+  rxPwr |= (regData & 0x07) << 8;
+  MxLTunedFreq = MxLTunedFreq/1000000;
+
+  if (MxLTunedFreq <= 131) rfPwrAdj = - 4;
+  else if (MxLTunedFreq <= 143) rfPwrAdj = 40;
+  else if (MxLTunedFreq <= 296) rfPwrAdj = 36;
+  else if (MxLTunedFreq <= 308) rfPwrAdj = 41;
+  else if (MxLTunedFreq <= 320) rfPwrAdj = 44;
+  else if (MxLTunedFreq <= 332) rfPwrAdj = 52;
+  else if (MxLTunedFreq <= 422) rfPwrAdj = 39;
+  else if (MxLTunedFreq <= 506) rfPwrAdj = 33;
+  else if (MxLTunedFreq <= 566) rfPwrAdj = 25;
+  else if (MxLTunedFreq <= 650) rfPwrAdj = 20;
+  else if (MxLTunedFreq <= 800) rfPwrAdj = 14;
+  else if (MxLTunedFreq <= 860) rfPwrAdj = 21;
+  else if (MxLTunedFreq > 860) rfPwrAdj = 29;
+
+  SigQualityPtr->SignalStrength = ((rxPwr + rfPwrAdj) / 8) - 119;
+
+  status |= Ctrl_WriteRegister(0x00, 0x00, fe);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_ConfigCableSettings
+--|
+--| AUTHOR        : Mahendra
+--|
+--| DATE CREATED  : 11/05/2009
+--|
+--| DESCRIPTION   : This API shall configure DVBC settings on MxL101SF
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_ConfigCableSettings(struct aml_fe_dev *fe)
+{
+  return Ctrl_ProgramRegisters(MxL_CableSettings, fe);
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_ConfigGPOPins
+--|
+--| AUTHOR        : Mahendra
+--|
+--| DATE CREATED  : 10/02/2009
+--|
+--| DESCRIPTION   : API to confugure GPIO Pins of MxL101SF
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_ConfigGPOPins(PMXL_DEV_GPO_CFG_T GpoPinCfgPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status = MXL_FALSE;
+  UINT8 regData = 0;
+  UINT8 gpoMask = 0;
+
+  status = Ctrl_ReadRegister(V6_GPO_CTRL_REG, &regData, fe);
+
+  switch(GpoPinCfgPtr->GpoPinId)
+  {
+    case MXL_GPO_0:
+      gpoMask = V6_GPO_0_MASK;
+      break;
+
+    case MXL_GPO_1:
+      gpoMask = V6_GPO_1_MASK;
+      break;
+
+    default:
+      break;
+  }
+
+  if (GpoPinCfgPtr->GpoPinCtrl)
+    regData |= gpoMask;
+  else
+    regData &= ~gpoMask;
+
+  status |= Ctrl_WriteRegister(V6_GPO_CTRL_REG, regData, fe);
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_DemodGetCellId
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 11/19/2009
+--|
+--| DESCRIPTION   : This API Enables TPS Cell ID Feature
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_DemodGetCellId(PMXL_DEMOD_CELL_ID_INFO_T tpsCellId, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+  UINT8 regData;
+  UINT16 CellId;
+
+  status = Ctrl_WriteRegister(0x00, 0x02, fe);
+
+  status |= Ctrl_ReadRegister(0x98, &regData, fe);
+  CellId = regData;
+
+  status |= Ctrl_ReadRegister(0x99, &regData, fe);
+  CellId |= regData << 8;
+
+  tpsCellId->TpsCellId = CellId;
+
+  status |= Ctrl_WriteRegister(0x00, 0x00, fe);
+printdebug("[MxL101SF_API_DemodGetCellId] CellId  is %x\n",CellId);
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_GetAGCLock
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/15/2010
+--|
+--| DESCRIPTION   : This function return AGC_LOCK status bit information
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_GetAGCLock(PMXL_DEMOD_LOCK_STATUS_T AgcLockPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_AGC_LOCK_REG, &rawData, fe);
+
+  if (status == MXL_TRUE)
+  {
+    if((rawData & V6_AGC_LOCK_MASK) >> 5)
+      AgcLockPtr->Status = MXL_LOCKED;
+    else
+      AgcLockPtr->Status = MXL_UNLOCKED;
+  }
+
+  return status;
+}
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_GetFECLock
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 1/15/2010
+--|
+--| DESCRIPTION   : This function return FEC_LOCK status bit information
+--|                 if set to 1, FEC_LOCK
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_GetFECLock(PMXL_DEMOD_LOCK_STATUS_T FecLockPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_IRQ_STATUS_REG, &rawData, fe);
+
+  if (status == MXL_TRUE)
+  {
+    if((rawData & IRQ_MASK_FEC_LOCK) >> 4)
+      FecLockPtr->Status = MXL_LOCKED;
+    else
+      FecLockPtr->Status = MXL_UNLOCKED;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_ConfigSpectrum
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 4/19/2010
+--|
+--| DESCRIPTION   : This function will configures MxL101SF to process inverted
+--|                 signal.
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_ConfigSpectrum(PMXL_DEMOD_SPECTRUM_CFG_T SpectrumCfgPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+  UINT8 rawData;
+
+  status = Ctrl_ReadRegister(V6_SPECTRUM_CTRL_REG, &rawData, fe);
+
+  if (status == MXL_TRUE)
+  {
+    if(SpectrumCfgPtr->SpectrumCfg == MXL_ENABLE)
+      rawData &= ~V6_SPECTRUM_MASK;
+    else
+      rawData |= V6_SPECTRUM_MASK;
+
+    status |= Ctrl_WriteRegister(V6_SPECTRUM_CTRL_REG, rawData, fe);
+  }
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_ConfigChannelScan
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 2/22/2010
+--|
+--| DESCRIPTION   : This function Enables or Disables Channel Scan functionality
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_ConfigChannelScan(PMXL_TUNER_CHAN_SCAN_CFG_T ChanScanCfgPtr, struct aml_fe_dev *fe)
+{
+  UINT8 Status = MXL_FALSE;
+
+  if (ChanScanCfgPtr->ChanScanCfg == MXL_ENABLE)
+    Ctrl_ProgramRegisters(MxL_EnableChanScan, fe);
+  else
+    Ctrl_ProgramRegisters(MxL_DisableChanScan, fe);
+
+  return (MXL_STATUS)Status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_GetChannelOffset
+--|
+--| AUTHOR        : Brenndon Lee
+--|
+--| DATE CREATED  : 2/22/2010
+--|
+--| DESCRIPTION   : This function returns offset for a channel
+--|                 Frequency offset will be valid only if FEC lock has been achieved
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_GetChannelOffset(PMXL_TUNER_CHAN_OFFSET_T ChanOffsetPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+  UINT8 rawData;
+  SINT16 freqOffset;
+
+  status = Ctrl_WriteRegister(0, 2, fe);
+
+  // Read 0x9B registe first, otherwise V6_FREQ_OFFSET_LSB_REG/V6_FREQ_OFFSET_LSB_REG will return 0
+  status |= Ctrl_ReadRegister(0x9B, &rawData, fe);
+  status |= Ctrl_ReadRegister(V6_FREQ_OFFSET_LSB_REG, &rawData, fe);
+  freqOffset = rawData;
+  status |= Ctrl_ReadRegister(V6_FREQ_OFFSET_MSB_REG, &rawData, fe);
+  status |= Ctrl_WriteRegister(0, 0, fe);
+
+  freqOffset |= (rawData << 8);
+  freqOffset &= 0x3FF;
+
+  // Check the sign bit
+  if (freqOffset & 0x0200)
+  {
+    // Negative number, extend sign bit
+    freqOffset |= 0xFC00;
+  }
+
+  ChanOffsetPtr->ChanOffset = (freqOffset * 2048) + 2048;
+
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxL101SF_API_CheckChannel
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 02/22/2010
+--|                 05/01/2010
+--|
+--| DESCRIPTION   : This API will check for presence of singnal at different lock
+--|                 levels (i.e CP, TPS, RS, FEC) for a given frequency.
+--|                 - Removed checking for FEC lock.
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxL101SF_API_CheckChannel(PMXL_TUNER_CHECK_CHAN_REQ_T ChanScanCtrlPtr, struct aml_fe_dev *fe)
+{
+  UINT8 status;
+  UINT32 StartTime;
+  UINT32 EndTime;
+  UINT16 TimeOut = 512;
+  MXL_DEMOD_LOCK_STATUS_T  demodLockStatus;
+  MXL_BOOL agcLockStatus = MXL_OFF;
+  MXL_RF_TUNE_CFG_T mxlChanCfg;
+
+
+
+  mxlChanCfg.Frequency = ChanScanCtrlPtr->Frequency;
+  mxlChanCfg.Bandwidth = ChanScanCtrlPtr->Bandwidth;
+  mxlChanCfg.TpsCellIdRbCtrl = ChanScanCtrlPtr->TpsCellIdRbCtrl;
+  Ctrl_GetTime(&StartTime);
+  EndTime = StartTime;
+
+  MxL101SF_API_TuneRF((PMXL_RF_TUNE_CFG_T)&mxlChanCfg, fe);
+
+ // Reset IRQ status
+  status = MxL101SF_API_DemodResetIrqStatus(fe);
+  ChanScanCtrlPtr->ChanPresent = MXL_FALSE;
+
+  while ((EndTime - StartTime) < TimeOut)
+  {
+    status |= MxL101SF_API_GetAGCLock(&demodLockStatus, fe);
+    if (demodLockStatus.Status == MXL_LOCKED)
+    {
+      agcLockStatus = MXL_ON;
+      TimeOut = 2048;
+    }
+    else
+    {
+      agcLockStatus = MXL_OFF;
+      if (ChanScanCtrlPtr->TpsCellIdRbCtrl == MXL_ENABLE)
+        TimeOut = 1024;
+      else
+        TimeOut = 512;
+    }
+
+    // Check if channel is available. Start with CP Lock
+    status |= MxL101SF_API_DemodGetCpLockStatus(&demodLockStatus, fe);
+
+    if (demodLockStatus.Status == MXL_LOCKED)
+    {
+      TimeOut = TimeOut - (EndTime - StartTime);
+      break;
+    }
+
+     Ctrl_GetTime(&EndTime);
+  }
+
+  if (ChanScanCtrlPtr->ChanScanCtrl == MXL_BREAK_AT_CP_LOCK)
+  {
+    // Break if interested to check channel status only till CP Lock
+    if (demodLockStatus.Status == MXL_LOCKED)
+      ChanScanCtrlPtr->ChanPresent = MXL_TRUE;
+
+    goto EXIT;
+  }
+
+  if (demodLockStatus.Status == MXL_LOCKED)
+  {
+    // CP is locked, check TPS Lock
+    TimeOut = TimeOut + 512;
+    EndTime = StartTime;
+    while ((EndTime - StartTime) < TimeOut)  // < 1536ms (1024+512)
+    {
+      status |= MxL101SF_API_DemodGetTpsLock(&demodLockStatus, fe);
+
+      if (demodLockStatus.Status == MXL_LOCKED)
+      {
+        break;
+      }
+
+       Ctrl_GetTime(&EndTime);
+    }
+
+    if (ChanScanCtrlPtr->ChanScanCtrl == MXL_BREAK_AT_TPS_LOCK)
+    {
+      // Break if interested to check channel status only till TPS Lock
+      if (demodLockStatus.Status == MXL_LOCKED)
+        ChanScanCtrlPtr->ChanPresent = MXL_TRUE;
+
+      goto EXIT;
+    }
+
+    if (demodLockStatus.Status == MXL_LOCKED)
+    {
+      // TPS is locked, check RS Lock
+      TimeOut = TimeOut + 3464;
+      EndTime = StartTime;
+
+      while ((EndTime - StartTime) < TimeOut) // < 5 secs (1024+512+3464)
+      {
+        status |= MxL101SF_API_DemodGetRsLockStatus(&demodLockStatus, fe);
+
+        if (demodLockStatus.Status == MXL_LOCKED)
+        {
+          break;
+        }
+
+         Ctrl_GetTime(&EndTime);
+      }
+
+      if (ChanScanCtrlPtr->ChanScanCtrl == MXL_BREAK_AT_RS_LOCK)
+      {
+        // Break if interested to check channel status only till RS Lock
+        if (demodLockStatus.Status == MXL_LOCKED)
+          ChanScanCtrlPtr->ChanPresent = MXL_TRUE;
+
+        goto EXIT;
+      }
+      if (demodLockStatus.Status == MXL_LOCKED)
+      {
+        ChanScanCtrlPtr->ChanPresent = MXL_TRUE;
+      } // RS Lock
+    } // TPS Lock
+  } // CP Lock
+
+EXIT:
+  return (MXL_STATUS)status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxLWare_API_ConfigDevice
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 08/08/2009
+--|
+--| DESCRIPTION   : The general device configuration shall be handled
+--|                 through this API
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxLWare_API_ConfigDevice(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  switch (CmdType)
+  {
+    case MXL_DEV_SOFT_RESET_CFG:
+      status = MxL101SF_API_SoftResetDevice(fe);
+      break;
+
+    case MXL_DEV_OPERATIONAL_MODE_CFG:
+      status = MxL101SF_API_SetMxLDeviceMode((PMXL_DEV_MODE_CFG_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEV_XTAL_SETTINGS_CFG:
+      status = MxL101SF_API_ConfigXtalSettings((PMXL_XTAL_CFG_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEV_101SF_OVERWRITE_DEFAULTS_CFG:
+      status = MxL101SF_API_InitTunerDemod(fe);
+      break;
+
+    case MXL_DEV_101SF_POWER_MODE_CFG:
+      status = MxL101SF_API_ConfigDevPowerSavingMode((PMXL_PWR_MODE_CFG_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEV_MPEG_OUT_CFG:
+      status = MxL101SF_API_ConfigMpegOut((PMXL_MPEG_CFG_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEV_GPO_PINS_CFG:
+      status = MxL101SF_API_ConfigGPOPins((PMXL_DEV_GPO_CFG_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEV_CABLE_CFG:
+      status = MxL101SF_API_ConfigCableSettings(fe);
+      break;
+
+    default:
+      break;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxLWare_API_GetDeviceStatus
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 08/08/2009
+--|
+--| DESCRIPTION   : The general device inquiries shall be handled
+--|                 through this API
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxLWare_API_GetDeviceStatus(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  switch (CmdType)
+  {
+    case MXL_DEV_ID_VERSION_REQ:
+      status = MxL101SF_API_GetChipInfo((PMXL_DEV_INFO_T)ParamPtr, fe);
+      break;
+
+    default:
+      break;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxLWare_API_GetDemodStatus
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 08/08/2009
+--|
+--| DESCRIPTION   : The demod specific inquiries shall be handled
+--|                 through this API
+--|                 - Support for MXL_DEMOD_TPS_HIERARCHICAL_ALPHA_REQ
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxLWare_API_GetDemodStatus(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  switch (CmdType)
+  {
+    case MXL_DEMOD_SNR_REQ:
+      status = MxL101SF_API_DemodGetSNR((PMXL_DEMOD_SNR_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_BER_REQ:
+      status = MxL101SF_API_DemodGetBER((PMXL_DEMOD_BER_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_TPS_CODE_RATE_REQ:
+      status = MxL101SF_API_DemodGetTpsCodeRate((PMXL_DEMOD_TPS_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_TPS_HIERARCHY_REQ:
+      status = MxL101SF_API_DemodGetTpsHierarchy((PMXL_DEMOD_TPS_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_TPS_CONSTELLATION_REQ:
+      status = MxL101SF_API_DemodGetTpsConstellation((PMXL_DEMOD_TPS_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_TPS_FFT_MODE_REQ:
+      status = MxL101SF_API_DemodGetTpsFftMode((PMXL_DEMOD_TPS_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_TPS_HIERARCHICAL_ALPHA_REQ:
+      status = MxL101SF_API_DemodGetHierarchicalAlphaValue((PMXL_DEMOD_TPS_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_TPS_GUARD_INTERVAL_REQ:
+      status = MxL101SF_API_DemodGetTpsGuardInterval((PMXL_DEMOD_TPS_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_TPS_LOCK_REQ:
+      status = MxL101SF_API_DemodGetTpsLock((PMXL_DEMOD_LOCK_STATUS_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_TPS_CELL_ID_REQ:
+      status = MxL101SF_API_DemodGetCellId((PMXL_DEMOD_CELL_ID_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_PACKET_ERROR_COUNT_REQ:
+      status = MxL101SF_API_DemodGetPacketErrorCount((PMXL_DEMOD_PEC_INFO_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_SYNC_LOCK_REQ:
+      status = MxL101SF_API_DemodGetSyncLockStatus((PMXL_DEMOD_LOCK_STATUS_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_RS_LOCK_REQ:
+      status = MxL101SF_API_DemodGetRsLockStatus((PMXL_DEMOD_LOCK_STATUS_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_CP_LOCK_REQ:
+      status = MxL101SF_API_DemodGetCpLockStatus((PMXL_DEMOD_LOCK_STATUS_T)ParamPtr, fe);
+      break;
+
+    default:
+      break;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxLWare_API_ConfigDemod
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 08/08/2009
+--|                 03/12/2010
+--|                 04/20/2010
+--|
+--| DESCRIPTION   : The demod block specific configuration shall be handled
+--|                 through this API
+--|                 - Support for MXL_DEMOD_STREAM_PRIORITY_CFG
+--|                 - Support for MXL_DEMOD_SPECTRUM_CFG
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxLWare_API_ConfigDemod(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  switch (CmdType)
+  {
+    case MXL_DEMOD_RESET_IRQ_CFG:
+      status = MxL101SF_API_DemodResetIrqStatus(fe);
+      break;
+
+    case MXL_DEMOD_RESET_PEC_CFG:
+      status = MxL101SF_API_DemodResetPacketErrorCount(fe);
+      break;
+
+    case MXL_DEMOD_TS_PRIORITY_CFG:
+      status = MxL101SF_API_ConfigStreamPriority((PMXL_DEMOD_TS_PRIORITY_CFG_T)ParamPtr, fe);
+      break;
+
+    case MXL_DEMOD_SPECTRUM_CFG:
+      status = MxL101SF_API_ConfigSpectrum((PMXL_DEMOD_SPECTRUM_CFG_T)ParamPtr, fe);
+      break;
+
+    default:
+      break;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxLWare_API_ConfigTuner
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 08/08/2009
+--|                 02/22/2010
+--|
+--| DESCRIPTION   : The tuner block specific configuration shall be handled
+--|                 through this API
+--|                 Support for MXL_TUNER_CHAN_SCAN_CFG
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxLWare_API_ConfigTuner(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  switch (CmdType)
+  {
+    case MXL_TUNER_TOP_MASTER_CFG:
+      status = MxL101SF_API_TopMasterControl((PMXL_TOP_MASTER_CFG_T)ParamPtr, fe);
+      break;
+
+    case MXL_TUNER_CHAN_TUNE_CFG:
+      status = MxL101SF_API_TuneRF((PMXL_RF_TUNE_CFG_T)ParamPtr, fe);
+      break;
+
+    case MXL_TUNER_IF_OUTPUT_FREQ_CFG:
+      status = MxL101SF_API_TunerSetIFOutputFreq((PMXL_TUNER_IF_FREQ_T)ParamPtr, fe);
+      break;
+
+    case MXL_TUNER_CHAN_SCAN_CFG:
+      status = MxL101SF_API_ConfigChannelScan((PMXL_TUNER_CHAN_SCAN_CFG_T)ParamPtr, fe);
+      break;
+
+    default:
+      break;
+  }
+
+  return status;
+}
+
+/*------------------------------------------------------------------------------
+--| FUNCTION NAME : MxLWare_API_GetTunerStatus
+--|
+--| AUTHOR        : Mahendra Kondur
+--|
+--| DATE CREATED  : 08/08/2009
+--|                 02/22/2010
+--|
+--| DESCRIPTION   : The tuner specific inquiries shall be handled
+--|                 through this API
+--|                 Support for MXL_TUNER_CHAN_OFFSET_REQ &
+--|                 MXL_TUNER_CHECK_CHAN_REQ
+--|
+--| RETURN VALUE  : MXL_STATUS
+--|
+--|---------------------------------------------------------------------------*/
+
+MXL_STATUS MxLWare_API_GetTunerStatus(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe)
+{
+  MXL_STATUS status = MXL_TRUE;
+
+  switch (CmdType)
+  {
+    case MXL_TUNER_LOCK_STATUS_REQ:
+      status = MxL101SF_API_TunerGetLockStatus((PMXL_TUNER_LOCK_STATUS_T)ParamPtr, fe);
+      break;
+
+    case MXL_TUNER_SIGNAL_STRENGTH_REQ:
+      status = MxL101SF_API_GetTunerSignalStrength((PMXL_SIGNAL_STATS_T)ParamPtr, fe);
+      break;
+
+    case MXL_TUNER_CHAN_OFFSET_REQ:
+      status = MxL101SF_API_GetChannelOffset((PMXL_TUNER_CHAN_OFFSET_T)ParamPtr, fe);
+      break;
+
+   case MXL_TUNER_CHECK_CHAN_STATUS_REQ:
+      status = MxL101SF_API_CheckChannel((PMXL_TUNER_CHECK_CHAN_REQ_T)ParamPtr, fe);
+      break;
+
+   default:
+      break;
+  }
+
+  return status;
+}
diff --git a/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCtrlApi.h b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCtrlApi.h
new file mode 100755
index 000000000000..7e8de6d7c06c
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyCtrlApi.h
@@ -0,0 +1,407 @@
+/*******************************************************************************
+ *
+ * FILE NAME          : MxL101SF_PhyCtrlApi.h
+ *
+ * AUTHOR             : Brenndon Lee
+ *                      Mahendra Kondur - code seperation
+ *
+ * DATE CREATED       : 5/18/2009
+ *                      10/22/2009
+ *
+ * DESCRIPTION        : This file is header file for MxL101SF_PhyCtrlApi.cpp
+ *
+ *******************************************************************************
+ *                Copyright (c) 2006, MaxLinear, Inc.
+ ******************************************************************************/
+
+#ifndef __MXL101SF_PHY_CTRL_API_H__
+#define __MXL101SF_PHY_CTRL_API_H__
+
+/******************************************************************************
+    Include Header Files
+    (No absolute paths - paths handled by make file)
+******************************************************************************/
+#include "MaxLinearDataTypes.h"
+#include "../aml_fe.h"
+
+/******************************************************************************
+    Macros
+******************************************************************************/
+
+#define CALCULATE_SNR(data)        ((1563 * data) - 25000)
+#define CALCULATE_BER(avg_errors, count)  (UINT32)(avg_errors * 4 * 3247)
+
+#define MXL_TUNER_MODE         0
+#define MXL_SOC_MODE           1
+#define MXL_DEV_MODE_MASK      0x01
+
+/******************************************************************************
+    User-Defined Types (Typedefs)
+******************************************************************************/
+
+/* Command Types  */
+typedef enum
+{
+  // MxL Device configure command
+  MXL_DEV_SOFT_RESET_CFG = 0,
+  MXL_DEV_XTAL_SETTINGS_CFG,
+  MXL_DEV_ID_VERSION_REQ,
+  MXL_DEV_OPERATIONAL_MODE_CFG,
+  MXL_DEV_GPO_PINS_CFG,
+  MXL_DEV_CABLE_CFG,
+
+  // MxL101SF Config specific commands
+  MXL_DEV_101SF_OVERWRITE_DEFAULTS_CFG,
+  MXL_DEV_101SF_POWER_MODE_CFG,
+  MXL_DEV_MPEG_OUT_CFG,
+
+  // Reset/Clear Demod status
+  MXL_DEMOD_RESET_IRQ_CFG,
+  MXL_DEMOD_RESET_PEC_CFG,
+  MXL_DEMOD_TS_PRIORITY_CFG,
+
+  // Demod Config commands
+  MXL_DEMOD_SPECTRUM_CFG,
+
+  // Demod Status and Info command
+  MXL_DEMOD_SNR_REQ,
+  MXL_DEMOD_BER_REQ,
+  MXL_DEMOD_TPS_CODE_RATE_REQ,
+  MXL_DEMOD_TPS_HIERARCHY_REQ,
+  MXL_DEMOD_TPS_CONSTELLATION_REQ,
+  MXL_DEMOD_TPS_FFT_MODE_REQ,
+  MXL_DEMOD_TPS_HIERARCHICAL_ALPHA_REQ,
+  MXL_DEMOD_TPS_GUARD_INTERVAL_REQ,
+  MXL_DEMOD_TPS_CELL_ID_REQ,
+  MXL_DEMOD_TPS_LOCK_REQ,
+  MXL_DEMOD_PACKET_ERROR_COUNT_REQ,
+  MXL_DEMOD_SYNC_LOCK_REQ,
+  MXL_DEMOD_RS_LOCK_REQ,
+  MXL_DEMOD_CP_LOCK_REQ,
+
+  // Tuner Config commands
+  MXL_TUNER_TOP_MASTER_CFG,
+  MXL_TUNER_CHAN_TUNE_CFG,
+  MXL_TUNER_IF_OUTPUT_FREQ_CFG,
+
+  // Tuner Status and Info command
+  MXL_TUNER_LOCK_STATUS_REQ,
+  MXL_TUNER_SIGNAL_STRENGTH_REQ,
+
+  // Channel Scan commands
+  MXL_TUNER_CHAN_SCAN_CFG,
+  MXL_TUNER_CHECK_CHAN_STATUS_REQ,
+  MXL_TUNER_CHAN_OFFSET_REQ,
+
+  MAX_NUM_CMD
+} MXL_CMD_TYPE_E;
+
+// MXL_DEV_ID_VERSION_REQ
+typedef struct
+{
+  UINT8 DevId;                    /* OUT, Device Id of MxL101SF Device */
+  UINT8 DevVer;                   /* OUT, Device Version of MxL101SF Device */
+} MXL_DEV_INFO_T, *PMXL_DEV_INFO_T;
+
+// MXL_DEV_POWER_MODE_CFG
+typedef enum
+{
+  STANDBY_ON = 0,
+  SLEEP_ON,
+  STANDBY_OFF,
+  SLEEP_OFF,
+} MXL_PWR_MODE_E;
+
+typedef struct
+{
+  MXL_PWR_MODE_E PowerMode;       /* IN, Power mode for MxL101SF Device */
+} MXL_PWR_MODE_CFG_T, *PMXL_PWR_MODE_CFG_T;
+
+// MXL_TUNER_TOP_MASTER_CFG
+typedef struct
+{
+  MXL_BOOL  TopMasterEnable;      /* IN, Enable or Disable MxL101SF Tuner */
+}MXL_TOP_MASTER_CFG_T, *PMXL_TOP_MASTER_CFG_T;
+
+// MXL_DEV_OPERATIONAL_MODE_CFG
+typedef struct
+{
+  UINT8 DeviceMode;             /* IN, Operational mode of MxL101SF */
+} MXL_DEV_MODE_CFG_T, *PMXL_DEV_MODE_CFG_T;
+
+// MXL_DEMOD_SNR_REQ
+typedef struct
+{
+  UINT32 SNR;                   /* OUT, SNR data from MXL101SF */
+} MXL_DEMOD_SNR_INFO_T, *PMXL_DEMOD_SNR_INFO_T;
+
+// MXL_DEMOD_BER_REQ
+typedef struct
+{
+  UINT32 BER;                 /* OUT, BER data from MXL101SF */
+} MXL_DEMOD_BER_INFO_T, *PMXL_DEMOD_BER_INFO_T;
+
+// MXL_DEMOD_RESET_PEC
+typedef struct
+{
+  UINT32 PEC;               /* OUT, PEC data from MXL101SF */
+}MXL_DEMOD_PEC_INFO_T, *PMXL_DEMOD_PEC_INFO_T;
+
+// MXL_TUNER_CHAN_TUNE_CFG
+typedef struct
+{
+  UINT32 Frequency;                       /* IN, Frequency in MHz */
+  UINT8 Bandwidth;                        /* IN, Channel Bandwidth in MHz */
+  MXL_BOOL TpsCellIdRbCtrl;               /* IN, Enable TPS Cell ID Read Back feature */
+} MXL_RF_TUNE_CFG_T, *PMXL_RF_TUNE_CFG_T;
+
+// Tune RF Lock Status MXL_TUNER_LOCK_STATUS_REQ
+typedef struct
+{
+  MXL_BOOL RfSynthLock;               /* OUT, RF SYNT Lock status of MXL101SF Tuner */
+  MXL_BOOL RefSynthLock;              /* OUT, REF SYNT Lock status of MXL101SF Tuner */
+} MXL_TUNER_LOCK_STATUS_T, *PMXL_TUNER_LOCK_STATUS_T;
+
+// MXL_DEMOD_TPS_CONSTELLATION_REQ
+// MXL_DEMOD_TPS_CODE_RATE_REQ
+// MXL_DEMOD_TPS_FFT_MODE_REQ
+// MXL_DEMOD_TPS_GUARD_INTERVAL_REQ
+// MXL_DEMOD_TPS_HIERARCHY_REQ
+typedef struct
+{
+  UINT8 TpsInfo;                      /* OUT, TPS data for respective TPS command */
+}MXL_DEMOD_TPS_INFO_T, *PMXL_DEMOD_TPS_INFO_T;
+
+// MXL_DEMOD_TPS_LOCK_REQ
+// MXL_DEMOD_RS_LOCK_REQ
+// MXL_DEMOD_CP_LOCK_REQ
+// MXL_DEMOD_RS_LOCK_REQ
+typedef struct
+{
+  MXL_BOOL Status;                  /* OUT, Lock status of MxL101SF */
+} MXL_DEMOD_LOCK_STATUS_T, *PMXL_DEMOD_LOCK_STATUS_T;
+
+// MXL_DEMOD_TS_PRIORITY_CFG
+typedef enum
+{
+  HP_STREAM = 0,
+  LP_STREAM,
+}MXL_HPORLP_E;
+
+typedef struct
+{
+  MXL_HPORLP_E StreamPriority;         /* IN,  Value to select transport stream priority*/
+} MXL_DEMOD_TS_PRIORITY_CFG_T, *PMXL_DEMOD_TS_PRIORITY_CFG_T;
+
+// MXL_TUNER_IF_OUTPUT_FREQ_CFG
+typedef enum
+{
+  IF_OTHER_12MHZ = 0,
+  IF_4_0MHZ,
+  IF_4_5MHZ,
+  IF_4_57MHZ,
+  IF_5_0MHZ,
+  IF_5_38MHZ,
+  IF_6_0MHZ,
+  IF_6_28MHZ,
+  IF_7_2MHZ,
+  IF_35_250MHZ,
+  IF_36_0MHZ,
+  IF_36_15MHZ,
+  IF_44_0MHZ,
+  IF_OTHER_35MHZ_45MHZ = 0x0F,
+} MXL_IF_FREQ_E;
+
+typedef struct
+{
+  MXL_IF_FREQ_E   IF_Index;               /* IN, Index for predefined IF frequency */
+  UINT8           IF_Polarity;            /* IN, IF Spectrum - Normal or Inverted */
+  UINT32          IF_Freq;                /* IN, IF Frequency in Hz for non-predefined frequencies */
+} MXL_TUNER_IF_FREQ_T, *PMXL_TUNER_IF_FREQ_T;
+
+// MXL_DEV_XTAL_SETTINGS_CFG
+typedef enum
+{
+  XTAL_24MHz = 4,
+  XTAL_27MHz = 7,
+  XTAL_28_8MHz = 8,
+  XTAL_48MHz = 12,
+  XTAL_NA = 13
+} MXL_XTAL_FREQ_E;
+
+typedef enum
+{
+  I123_5uA = 0,
+  I238_8uA,
+  I351_4uA,
+  I462_4uA,
+  I572_0uA,
+  I680_4uA,
+  I787_8uA,
+  I894_2uA,
+  XTAL_BIAS_NA
+} MXL_XTAL_BIAS_E;
+
+typedef enum
+{
+  CLK_OUT_0dB = 0,
+  CLK_OUT_1_25dB,
+  CLK_OUT_2_50dB,
+  CLK_OUT_3_75dB,
+  CLK_OUT_5_00dB,
+  CLK_OUT_6_25dB,
+  CLK_OUT_7_50dB,
+  CLK_OUT_8_75dB,
+  CLK_OUT_10_0dB,
+  CLK_OUT_11_25dB,
+  CLK_OUT_12_50dB,
+  CLK_OUT_13_75dB,
+  CLK_OUT_15_00dB,
+  CLK_OUT_16_25dB,
+  CLK_OUT_17_50dB,
+  CLK_OUT_18_75dB,
+  CLK_OUT_NA
+} MXL_XTAL_CLK_OUT_GAIN_E;
+
+typedef struct
+{
+  MXL_XTAL_FREQ_E           XtalFreq;             /* IN, XTAL frequency */
+  MXL_XTAL_BIAS_E           XtalBiasCurrent;      /* IN, XTAL Bias current */
+  UINT8                     XtalCap;              /* IN, XTAL Capacitance value */
+  MXL_BOOL                  XtalClkOutEnable;     /* IN, XTAL Clock out control */
+  MXL_XTAL_CLK_OUT_GAIN_E   XtalClkOutGain;       /* IN, XTAL Clock out gain value */
+  MXL_BOOL                  LoopThruEnable;       /* IN, Frequency loop thru */
+} MXL_XTAL_CFG_T, *PMXL_XTAL_CFG_T;
+
+// MXL_DEMOD_MPEG_OUT_CFG
+typedef enum
+{
+  MPEG_CLOCK_36_571429MHz = 0,
+  MPEG_CLOCK_2_285714MHz,
+  MPEG_CLOCK_4_571429MHz,
+  MPEG_CLOCK_6_857143MHz,
+  MPEG_CLOCK_9_142857MHz,
+  MPEG_CLOCK_13_714286MHz,
+  MPEG_CLOCK_18_285714MHz,
+  MPEG_CLOCK_27_428571MHz
+} MPEG_CLOCK_FREQ_E;
+
+typedef enum
+{
+  MPEG_ACTIVE_LOW = 0,
+  MPEG_ACTIVE_HIGH,
+
+  MPEG_CLK_POSITIVE  = 0,
+  MPEG_CLK_NEGATIVE,
+
+  MPEG_CLK_IN_PHASE = 0,
+  MPEG_CLK_INVERTED,
+
+  MPEG_CLK_EXTERNAL = 0,
+  MPEG_CLK_INTERNAL
+} MPEG_CLK_FMT_E;
+
+typedef enum
+{
+  MPEG_SERIAL_LSB_1ST = 0,
+  MPEG_SERIAL_MSB_1ST,
+
+  MPEG_DATA_SERIAL  = 0,
+  MPEG_DATA_PARALLEL,
+
+  MPEG_SYNC_WIDTH_BIT = 0,
+  MPEG_SYNC_WIDTH_BYTE
+} MPEG_DATA_FMT_E;
+
+typedef struct
+{
+  MPEG_DATA_FMT_E   SerialOrPar;             /* IN, Serial or Parallel mode */
+  MPEG_DATA_FMT_E   LsbOrMsbFirst;           /* IN, Serial mode MSB or LSB first */
+  MPEG_CLOCK_FREQ_E MpegClkFreq;             /* IN, MPEG Clock frequency */
+  MPEG_CLK_FMT_E    MpegValidPol;            /* IN, MPEG Valid polarity */
+  MPEG_CLK_FMT_E    MpegClkPhase;            /* IN, MPEG Clock phase */
+  MPEG_CLK_FMT_E    MpegSyncPol;             /* IN, MPEG SYNC Polarity */
+} MXL_MPEG_CFG_T, *PMXL_MPEG_CFG_T;
+
+// MXL_DEV_GPO_PINS_CFG
+typedef enum
+{
+  MXL_GPO_0 = 0,
+  MXL_GPO_1,
+  MXL_GPO_NA
+} MXL_GPO_E;
+
+typedef struct
+{
+  MXL_GPO_E           GpoPinId;           /* IN, GPIO Pin ID */
+  MXL_BOOL            GpoPinCtrl;         /* IN, GPIO Pin control */
+} MXL_DEV_GPO_CFG_T, *PMXL_DEV_GPO_CFG_T;
+
+// MXL_TUNER_SIGNAL_STRENGTH_REQ
+typedef struct
+{
+  SINT32 SignalStrength;                    /* OUT, Tuner Signal strength in dBm */
+} MXL_SIGNAL_STATS_T, *PMXL_SIGNAL_STATS_T;
+
+// MXL_DEMOD_TPS_CELL_ID_REQ
+typedef struct
+{
+  UINT16 TpsCellId;                      /* OUT, TPS Cell ID Info */
+}MXL_DEMOD_CELL_ID_INFO_T, *PMXL_DEMOD_CELL_ID_INFO_T;
+
+// MXL_TUNER_CHECK_CHAN_REQ
+typedef enum
+{
+  MXL_BREAK_AT_CP_LOCK = 1,       /* Break after CP Lock */
+  MXL_BREAK_AT_TPS_LOCK,          /* Break after TPS Lock */
+  MXL_BREAK_AT_RS_LOCK,           /* Break after RS Lock */
+  MXL_FULL_MODE                   /* Default mode, break after FEC lcok */
+}MXL_CHAN_SCAN_CTRL_E;
+
+typedef struct
+{
+  MXL_CHAN_SCAN_CTRL_E ChanScanCtrl;   /* IN, value of Highest lock level check for a frequency */
+  UINT32 Frequency;                    /* IN, Frequency in MHz */
+  UINT8 Bandwidth;                     /* IN, Channel Bandwidth in MHz */
+  MXL_BOOL TpsCellIdRbCtrl;            /* IN, Enable TPS Cell ID Read Back feature */
+  MXL_STATUS ChanPresent;              /* OUT, Indicates presence of a frequency */
+} MXL_TUNER_CHECK_CHAN_REQ_T, *PMXL_TUNER_CHECK_CHAN_REQ_T;
+
+// MXL_TUNER_CHAN_OFFSET_REQ
+typedef struct
+{
+  SINT32 ChanOffset;                      /* OUT, Frequency Offset for a Channel in Hz*/
+}MXL_TUNER_CHAN_OFFSET_T, *PMXL_TUNER_CHAN_OFFSET_T;
+
+// MXL_TUNER_CHAN_SCAN_CFG
+typedef struct
+{
+  MXL_BOOL ChanScanCfg;                      /* IN, Enable or Disable Channel Scan */
+}MXL_TUNER_CHAN_SCAN_CFG_T, *PMXL_TUNER_CHAN_SCAN_CFG_T;
+
+/* MXL_DEMOD_SPECTRUM_CFG */
+typedef struct
+{
+  MXL_BOOL SpectrumCfg;                      /* IN, Enable or Disable inverted signal processing */
+}MXL_DEMOD_SPECTRUM_CFG_T, *PMXL_DEMOD_SPECTRUM_CFG_T;
+
+/******************************************************************************
+    Global Variable Declarations
+******************************************************************************/
+
+/******************************************************************************
+    Prototypes
+******************************************************************************/
+
+MXL_STATUS MxLWare_API_ConfigDevice(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe);
+MXL_STATUS MxLWare_API_GetDeviceStatus(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe);
+MXL_STATUS MxLWare_API_ConfigDemod(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe);
+MXL_STATUS MxLWare_API_GetDemodStatus(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe);
+MXL_STATUS MxLWare_API_ConfigTuner(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe);
+MXL_STATUS MxLWare_API_GetTunerStatus(MXL_CMD_TYPE_E CmdType, void *ParamPtr, struct aml_fe_dev *fe);
+
+#endif /* __MXL1X1SF_PHY_CTRL_API_H__*/
+
+
+
+
diff --git a/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyDefs.h b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyDefs.h
new file mode 100755
index 000000000000..a17d5dd29dae
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/MxL101SF_PhyDefs.h
@@ -0,0 +1,196 @@
+/*******************************************************************************
+ *
+ * FILE NAME          : MxL101SF_PhyDefs.h
+ *
+ * AUTHOR             : Brenndon Lee
+ * DATE CREATED       : 5/18/2009
+ *
+ * DESCRIPTION        : This file contains MxL101SF common control register
+ *                      definitions
+ *
+ *******************************************************************************
+ *                Copyright (c) 2006, MaxLinear, Inc.
+ ******************************************************************************/
+
+#ifndef __MXL101SF_PHY_DEFS_H__
+#define __MXL101SF_PHY_DEFS_H__
+
+/******************************************************************************
+    Include Header Files
+    (No absolute paths - paths handled by make file)
+******************************************************************************/
+#include "MaxLinearDataTypes.h"
+#include "MxL101SF_PhyCtrlApi.h"
+#include "../aml_fe.h"
+
+/******************************************************************************
+    Macros
+******************************************************************************/
+
+#define CHIP_ID_REG                  0xFC
+#define TOP_CHIP_REV_ID_REG          0xFA
+
+#define V6_SNR_RB_LSB_REG            0x27
+#define V6_SNR_RB_MSB_REG            0x28
+
+#define V6_N_ACCUMULATE_REG          0x11
+#define V6_RS_AVG_ERRORS_LSB_REG     0x2C
+#define V6_RS_AVG_ERRORS_MSB_REG     0x2D
+
+#define V6_IRQ_STATUS_REG            0x24
+#define  IRQ_MASK_FEC_LOCK       0x10
+
+#define V6_SYNC_LOCK_REG             0x28
+#define SYNC_LOCK_MASK           0x10
+
+#define V6_RS_LOCK_DET_REG           0x28
+#define  RS_LOCK_DET_MASK        0x08
+
+#define V6_INITACQ_NODETECT_REG    0x20
+#define V6_FORCE_NFFT_CPSIZE_REG   0x20
+
+#define V6_CODE_RATE_TPS_REG       0x29
+#define V6_CODE_RATE_TPS_MASK      0x07
+
+#define V6_CP_LOCK_DET_REG        0x28
+#define V6_CP_LOCK_DET_MASK       0x04
+
+#define V6_TPS_HIERACHY_REG        0x29
+#define V6_TPS_HIERARCHY_INFO_MASK  0x40
+
+#define V6_TPS_HPORLP_REG        0x20
+#define V6_TPS_HPORLP_INFO_MASK  0x80
+
+#define V6_MODORDER_TPS_REG        0x2A
+#define V6_PARAM_CONSTELLATION_MASK   0x30
+
+#define V6_TPS_ALPHA_REG        0x2A
+#define V6_TPS_ALPHA_MASK   0x03
+
+#define V6_MODE_TPS_REG            0x2A
+#define V6_PARAM_FFT_MODE_MASK        0x0C
+
+#define V6_CP_TPS_REG             0x29
+#define V6_PARAM_GI_MASK              0x30
+
+#define V6_AGC_LOCK_REG             0x26
+#define V6_AGC_LOCK_MASK              0x20
+
+#define V6_TPS_LOCK_REG           0x2A
+#define V6_PARAM_TPS_LOCK_MASK        0x40
+
+#define V6_FEC_PER_COUNT_REG      0x2E
+#define V6_FEC_PER_SCALE_REG      0x2B
+#define V6_FEC_PER_SCALE_MASK        0x03
+
+#define V6_PIN_MUX_MODE_REG       0x1B
+#define V6_ENABLE_PIN_MUX            0x1E
+
+#define V6_MPEG_OUT_CLK_INV_REG    0x17
+#define V6_MPEG_OUT_CTRL_REG       0x18
+
+#define V6_INVERTED_CLK_PHASE       0x20
+#define V6_MPEG_DATA_PARALLEL    0x01
+#define V6_MPEG_DATA_SERIAL      0x02
+
+#define V6_INVERTED_MPEG_SYNC       0x04
+#define V6_INVERTED_MPEG_VALID      0x08
+
+#define V6_MPEG_INOUT_BIT_ORDER_CTRL_REG  0x19
+#define V6_MPEG_SER_MSB_FIRST                0x80
+#define MPEG_SER_MSB_FIRST_ENABLED        0x01
+
+#define V6_TUNER_LOOP_THRU_CONTROL_REG  0x09
+#define V6_ENABLE_LOOP_THRU               0x01
+
+#define TOTAL_NUM_IF_OUTPUT_FREQ       16
+
+#define TUNER_NORMAL_IF_SPECTRUM       0x0
+#define TUNER_INVERT_IF_SPECTRUM       0x10
+
+#define V6_TUNER_IF_SEL_REG              0x06
+#define V6_TUNER_IF_FCW_REG              0x3C
+#define V6_TUNER_IF_FCW_BYP_REG          0x3D
+#define V6_RF_LOCK_STATUS_REG            0x23
+
+#define V6_DIG_CLK_FREQ_SEL_REG  0x07
+#define V6_REF_SYNTH_INT_REG     0x5C
+#define V6_REF_SYNTH_REMAIN_REG  0x58
+#define V6_DIG_RFREFSELECT_REG   0x32
+#define V6_XTAL_CLK_OUT_GAIN_REG   0x31
+#define V6_TUNER_LOOP_THRU_CTRL_REG      0x09
+#define V6_DIG_XTAL_ENABLE_REG  0x06
+#define V6_DIG_XTAL_BIAS_REG  0x66
+#define V6_XTAL_CAP_REG    0x08
+
+#define V6_GPO_CTRL_REG     0x18
+#define V6_GPO_0_MASK       0x10
+#define V6_GPO_1_MASK       0x20
+
+#define MXL_MODE_REG    0x03
+#define START_TUNE_REG  0x1C
+
+#define V6_DIG_RF_PWR_LSB_REG   0x46
+#define V6_DIG_RF_PWR_MSB_REG   0x47
+
+#define V6_AGC_LOCK_REG         0x26
+#define V6_AGC_LOCK_MASK        0x20
+
+#define V6_TPS_CELL_ID_LSB_REG  0x98
+#define V6_TPS_CELL_ID_MSB_REG  0x99
+
+#define V6_FREQ_OFFSET_LSB_REG  0x9D
+#define V6_FREQ_OFFSET_MSB_REG  0x9E
+
+#define V6_SPECTRUM_CTRL_REG  0x8D
+#define V6_SPECTRUM_MASK  0x01
+
+/******************************************************************************
+    User-Defined Types (Typedefs)
+******************************************************************************/
+
+typedef struct
+{
+  UINT8 regAddr;
+  UINT8 mask;
+  UINT8 data;
+} REG_CTRL_INFO_T, *PREG_CTRL_INFO_T;
+
+/******************************************************************************
+    Global Variable Declarations
+******************************************************************************/
+
+extern REG_CTRL_INFO_T MxL_101OverwriteDefault[];
+extern REG_CTRL_INFO_T MxL_101SuspendMode[];
+extern REG_CTRL_INFO_T MxL_101WakeUp[];
+extern REG_CTRL_INFO_T MxL_MpegDataOutToTSIF[];
+extern REG_CTRL_INFO_T MxL_PhySoftReset[];
+extern REG_CTRL_INFO_T MxL_TunerDemodMode[];
+extern REG_CTRL_INFO_T MxL_TunerMode[];
+extern REG_CTRL_INFO_T MxL_TopMasterEnable[];
+extern REG_CTRL_INFO_T MxL_TopMasterDisable[];
+extern REG_CTRL_INFO_T MxL_IrqClear[];
+extern REG_CTRL_INFO_T MxL_ResetPerCount[];
+extern REG_CTRL_INFO_T MxL_CableSettings[];
+extern REG_CTRL_INFO_T MxL_EnableCellId[];
+extern REG_CTRL_INFO_T MxL_DisableCellId[];
+extern REG_CTRL_INFO_T MxL_EnableChanScan[];
+extern REG_CTRL_INFO_T MxL_DisableChanScan[];
+extern REG_CTRL_INFO_T MxL_StartTune[];
+
+/******************************************************************************
+    Prototypes
+******************************************************************************/
+
+MXL_STATUS Ctrl_ProgramRegisters(PREG_CTRL_INFO_T ctrlRegInfoPtr, struct aml_fe_dev *fe);
+PREG_CTRL_INFO_T Ctrl_PhyTune(UINT32 frequency, UINT8 bandwidth);
+
+// OEM specific APIs
+MXL_STATUS Ctrl_ReadRegister(UINT8 regAddr, UINT8 *dataPtr, struct aml_fe_dev *fe);
+MXL_STATUS Ctrl_WriteRegister(UINT8 regAddr, UINT8 regData, struct aml_fe_dev *fe);
+
+#endif /* __MXL101SF_PHY_CFG_H__*/
+
+
+
+
diff --git a/drivers/amlogic/dvb_tv/mxl101/demod_MxL101SF.c b/drivers/amlogic/dvb_tv/mxl101/demod_MxL101SF.c
new file mode 100755
index 000000000000..9aca6e583272
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/demod_MxL101SF.c
@@ -0,0 +1,219 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2008 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (MStar Confidential Information) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////
+//
+/// @file MSB122x.c
+/// @brief MSB122x DVBT, VIF Controller Interface
+/// @author MStar Semiconductor, Inc.
+//
+////////////////////////////////////////////////////////////////////////////////
+#include "demod_MxL101SF.h"
+#include "MxL101SF_OEM_Drv.h"
+#include "MxL101SF_PhyCtrlApi.h"
+#include "MxL101SF_PhyDefs.h"
+
+//#define MS_DEBUG
+#ifdef MS_DEBUG
+#define MXL_MSB(x)          x
+#else
+#define MXL_MSB(x)          //x
+#endif
+
+void MxL101SF_Init(struct aml_fe_dev *fe)
+{
+  //UINT32 loop;
+  MXL_DEV_INFO_T mxlDevInfo;
+  MXL_XTAL_CFG_T mxlXtalCfg;
+  MXL_DEV_MODE_CFG_T mxlDevMode;
+  MXL_MPEG_CFG_T mxlMpegOutCfg;
+  MXL_TOP_MASTER_CFG_T mxlTopMasterCfg;
+  //MXL_RF_TUNE_CFG_T mxlChanCfg;
+  //MXL_DEMOD_LOCK_STATUS_T rsLockStatus;
+  //MXL_DEMOD_SNR_INFO_T snr;
+  //MXL_DEMOD_BER_INFO_T ber;
+ // MXL_SIGNAL_STATS_T sigStrength;
+  //MXL_DEMOD_CELL_ID_INFO_T tpsCellIdInfo;
+
+  // Open LPT driver for I2C communcation
+  //Ctrl_I2cConnect(99);
+
+  // 1. Do SW Reset
+  MxLWare_API_ConfigDevice(MXL_DEV_SOFT_RESET_CFG, NULL, fe);
+
+  // 2. Read Back chip id and version
+  //    Expecting CHIP ID = 0x61, Version = 0x6
+
+  MxLWare_API_GetDeviceStatus(MXL_DEV_ID_VERSION_REQ, &mxlDevInfo, fe);
+  printf("MxL101SF : ChipId = 0x%x, Version = 0x%x\n", mxlDevInfo.DevId, mxlDevInfo.DevVer);
+
+  // 3. Init Tuner and Demod
+  MxLWare_API_ConfigDevice(MXL_DEV_101SF_OVERWRITE_DEFAULTS_CFG, NULL, fe);
+
+  // Step 4
+  // Enable Loop Through if needed
+  // Enable Clock Out and configure Clock Out gain if needed
+  // Configure MxL101SF XTAL frequency
+  // Configure XTAL Bias value if needed
+
+  // Xtal Capacitance value must be configured in accordance
+  // with XTAL datasheets requirement.
+  mxlXtalCfg.XtalFreq = XTAL_24MHz;
+  mxlXtalCfg.LoopThruEnable = MXL_ENABLE;//MXL_DISABLE;
+  mxlXtalCfg.XtalBiasCurrent = XTAL_BIAS_NA;
+  mxlXtalCfg.XtalCap = 0x12; //0x12
+  mxlXtalCfg.XtalClkOutEnable = MXL_DISABLE;
+  mxlXtalCfg.XtalClkOutGain = CLK_OUT_NA;
+  MxLWare_API_ConfigDevice(MXL_DEV_XTAL_SETTINGS_CFG, &mxlXtalCfg, fe);
+
+  // 5. Set Baseband mode, SOC or Tuner only mode
+  mxlDevMode.DeviceMode = MXL_SOC_MODE;
+  MxLWare_API_ConfigDevice(MXL_DEV_OPERATIONAL_MODE_CFG, &mxlDevMode, fe);
+
+
+  // 6. Configure MPEG Out
+  // CLK, MPEG_CLK_INV, Polarity of MPEG Valid/MPEG Sync
+  mxlMpegOutCfg.MpegClkFreq = MPEG_CLOCK_36_571429MHz;//MPEG_CLOCK_9_142857MHz;//MPEG_CLOCK_36_571429MHz;
+  mxlMpegOutCfg.LsbOrMsbFirst = MPEG_SERIAL_MSB_1ST;
+  mxlMpegOutCfg.MpegClkPhase = MPEG_CLK_IN_PHASE;//MPEG_CLK_IN_PHASE;
+  mxlMpegOutCfg.MpegSyncPol = MPEG_CLK_IN_PHASE;
+  mxlMpegOutCfg.MpegValidPol = MPEG_CLK_IN_PHASE;
+
+#ifdef CONFIG_AMLOGIC_S_TS2
+  mxlMpegOutCfg.SerialOrPar = MPEG_DATA_SERIAL;
+#else
+  mxlMpegOutCfg.SerialOrPar = MPEG_DATA_PARALLEL;
+#endif
+
+  MxLWare_API_ConfigDevice(MXL_DEV_MPEG_OUT_CFG, &mxlMpegOutCfg, fe);
+
+  // 7. Enable Top Master Control
+  mxlTopMasterCfg.TopMasterEnable = MXL_ENABLE;
+  MxLWare_API_ConfigTuner(MXL_TUNER_TOP_MASTER_CFG, &mxlTopMasterCfg, fe);
+
+
+
+
+}
+
+void MxL101SF_Tune(UINT32 u32TunerFreq, UINT8 u8BandWidth, struct aml_fe_dev *fe)
+{
+	 MXL_RF_TUNE_CFG_T mxlChanCfg;
+	 // 8. Tune RF with channel frequency and bandwidth
+	/* if(u32TunerFreq<177500||u32TunerFreq>868000)
+	 {
+	 	printf("input u32TunerFreq=%d error\n",u32TunerFreq);
+		return;
+	 }
+	 if(u8BandWidth<6||u8BandWidth>8)
+	 {
+	 	printf("input u8BandWidth=%d error\n",u8BandWidth);
+	    return;
+	 }*/
+
+ 	 // 8. Tune RF with channel frequency and bandwidth
+ 	 printf("u32TunerFreq is %d,u8BandWidth is %d\n",u32TunerFreq,u8BandWidth);
+ 	 mxlChanCfg.Bandwidth = u8BandWidth;
+ 	 mxlChanCfg.Frequency = u32TunerFreq;//u32TunerFreq*1000;
+ 	 mxlChanCfg.TpsCellIdRbCtrl = MXL_ENABLE;  // Enable TPS Cell ID feature
+ 	 MxLWare_API_ConfigTuner(MXL_TUNER_CHAN_TUNE_CFG, &mxlChanCfg, fe);
+}
+
+UINT32 MxL101SF_GetSNR(struct aml_fe_dev *fe)
+{
+	MXL_DEMOD_SNR_INFO_T snr;
+	// Read back SNR
+    MxLWare_API_GetDemodStatus(MXL_DEMOD_SNR_REQ, &snr, fe);
+  //  MXL_MSB(printf("MxL101SF : Demod SNR = %d dB\n", snr.SNR));
+	return snr.SNR/10000;
+}
+
+MXL_BOOL MxL101SF_GetLock(struct aml_fe_dev *fe)
+{
+	MXL_DEMOD_LOCK_STATUS_T rsLockStatus;
+	// Read back RS Lock Status
+    MxLWare_API_GetDemodStatus(MXL_DEMOD_RS_LOCK_REQ, &rsLockStatus, fe);
+    MXL_MSB(printf("MxL101SF : RS Lock Status = 0x%x\n", rsLockStatus.Status));
+	return rsLockStatus.Status;
+}
+
+UINT32 MxL101SF_GetBER(struct aml_fe_dev *fe)
+{
+	MXL_DEMOD_BER_INFO_T ber;
+	// Read back BER
+    MxLWare_API_GetDemodStatus(MXL_DEMOD_BER_REQ, &ber, fe);
+  //  MXL_MSB(printf("MxL101SF : Demod BER = %d\n", ber.BER));
+	return ber.BER;
+}
+
+SINT32 MxL101SF_GetSigStrength(struct aml_fe_dev *fe)
+{
+	MXL_SIGNAL_STATS_T sigStrength;
+	// Read back Signal Strength
+    MxLWare_API_GetTunerStatus(MXL_TUNER_SIGNAL_STRENGTH_REQ, &sigStrength, fe);
+ //   MXL_MSB(printf("MxL101SF : Signal Strength = %d dBm\n", sigStrength.SignalStrength));
+	return sigStrength.SignalStrength;
+}
+
+UINT16 MxL101SF_GetTPSCellID(struct aml_fe_dev *fe)
+{
+	MXL_DEMOD_CELL_ID_INFO_T tpsCellIdInfo;
+    // Read back TPS Cell ID
+    MxLWare_API_GetDemodStatus(MXL_DEMOD_TPS_CELL_ID_REQ, &tpsCellIdInfo, fe);
+    MXL_MSB(printf("MxL101SF : TPS Cell ID = %04X\n", tpsCellIdInfo.TpsCellId));
+	return tpsCellIdInfo.TpsCellId;
+}
+
+void MxL101SF_PowerOnOff(UINT8 u8PowerOn, struct aml_fe_dev *fe)
+{
+	MXL_CMD_TYPE_E CmdType = MXL_DEV_101SF_POWER_MODE_CFG;
+	MXL_PWR_MODE_CFG_T PwrMode;
+	if(u8PowerOn==0)
+	{
+		PwrMode.PowerMode = STANDBY_OFF;
+		if(MxLWare_API_ConfigDevice(CmdType,&PwrMode,fe)!=MXL_TRUE)
+		{
+			printf("MxL101SF_PowerOff failed\n");
+		}
+		else
+		{
+			printf("MxL101SF_PowerOff ok\n");
+		}
+	}
+}
+
+void Mxl101SF_Debug(struct aml_fe_dev *fe)
+{
+	UINT32  tpsCellIdInfo;
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_SNR_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_BER_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_TPS_CODE_RATE_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_TPS_HIERARCHY_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_TPS_CONSTELLATION_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_TPS_FFT_MODE_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_TPS_HIERARCHICAL_ALPHA_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_TPS_GUARD_INTERVAL_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_TPS_LOCK_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_TPS_CELL_ID_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_PACKET_ERROR_COUNT_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_SYNC_LOCK_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_RS_LOCK_REQ, &tpsCellIdInfo, fe);
+	MxLWare_API_GetDemodStatus(MXL_DEMOD_CP_LOCK_REQ, &tpsCellIdInfo, fe);
+
+
+}
+
diff --git a/drivers/amlogic/dvb_tv/mxl101/demod_MxL101SF.h b/drivers/amlogic/dvb_tv/mxl101/demod_MxL101SF.h
new file mode 100755
index 000000000000..7dafeab12016
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/demod_MxL101SF.h
@@ -0,0 +1,38 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2008 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (MStar Confidential Information) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+#ifndef _MXL101SF_H_
+#define _MXL101SF_H_
+
+#include "MaxLinearDataTypes.h"
+
+#include <linux/dvb/frontend.h>
+#include "../../../media/dvb/dvb-core/dvb_frontend.h"
+#include "../aml_fe.h"
+#define printf printk
+
+extern void MxL101SF_Init(struct aml_fe_dev *fe);
+extern void MxL101SF_Tune(UINT32 u32TunerFreq, UINT8 u8BandWidth, struct aml_fe_dev *fe);
+extern UINT32 MxL101SF_GetSNR(struct aml_fe_dev *fe);
+extern MXL_BOOL MxL101SF_GetLock(struct aml_fe_dev *fe);
+extern UINT32 MxL101SF_GetBER(struct aml_fe_dev *fe);
+extern SINT32 MxL101SF_GetSigStrength(struct aml_fe_dev *fe);
+extern UINT16 MxL101SF_GetTPSCellID(struct aml_fe_dev *fe);
+extern void MxL101SF_PowerOnOff(UINT8 u8PowerOn, struct aml_fe_dev *fe);
+extern void Mxl101SF_Debug(struct aml_fe_dev *fe);
+#endif
+
diff --git a/drivers/amlogic/dvb_tv/mxl101/drvCofdmDmd.c b/drivers/amlogic/dvb_tv/mxl101/drvCofdmDmd.c
new file mode 100755
index 000000000000..4b9e1619c472
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/drvCofdmDmd.c
@@ -0,0 +1,549 @@
+#include "MsCommon.h"
+//#include "drvIIC.h"
+//#include "drvTuner.h"
+#include "drvGPIO.h"
+#include "drvSAR.h"
+#include "drvCofdmDmd.h" //Temp for use
+//#include "Default.h"
+#include "demod_MxL101SF.h"
+
+//#define MS_DEBUG
+#ifdef MS_DEBUG
+#define DBG_MSB(x)          x
+#else
+#define DBG_MSB(x)          //x
+#endif
+
+//-------------------------------------------------------------------------------------------------
+//  Local Defines
+//-------------------------------------------------------------------------------------------------
+#define DVBC_MSEC_LOOP              ( CPU_CLOCK_FREQ/1000/4 )
+#define DVBC_DELAY(_loop)           { volatile int i; for (i=0; i<(_loop)*DVBC_MSEC_LOOP; i++); }
+
+#define COFDMDMD_MUTEX_TIMEOUT       (2000)
+//#define Mon_Signal_MUTEX_TIMEOUT         100
+#define COFDMDMD_EVENT_TIMEOUT          100// MSOS_WAIT_FOREVER
+
+//-------------------------------------------------------------------------------------------------
+//  Type and Structure
+//-------------------------------------------------------------------------------------------------
+
+
+#define CHG_COFDMDMD_EVENT_CLEAR(_event)    	MsOS_ClearEvent(_s32EventId, 0xFFFFFFFF);   \
+                                        MsOS_SetEvent(_s32EventId, _event);
+#define CHG_COFDMDMD_EVENT(_event)    	MsOS_SetEvent(_s32EventId, _event);
+
+
+//-------------------------------------------------------------------------------------------------
+//  Local Variables
+//-------------------------------------------------------------------------------------------------
+static MS_BOOL 	 					bInited     = FALSE;
+#define MONITOR_Signal_TASK_STACK              (2048*2)
+static MS_S32                       _s32TaskId = -1;
+static MS_S32                       _s32MutexId;
+static MS_S32                       _s32EventId;
+//static TaskState                    _eTaskState;
+static MS_BOOL _plock = FALSE;
+
+
+CofdmDMD_Param _pParam;
+
+#define MON_SIGNAL_DBG_ENABLE
+
+#ifdef MON_SIGNAL_DBG_ENABLE
+#define MON_SIGNAL_DBG(_print)          _print
+#else
+#define MON_SIGNAL_DBG(_print)
+#endif
+
+#ifdef MON_SIGNAL_DBG_ENABLE
+#define MON_SIGNAL_ERR(_print)	        _print
+#else
+#define MON_SIGNAL_ERR(_print)
+#endif
+
+/// Channel scan return value definition
+typedef enum _COFDMDMD_result
+{
+    E_COFDMDMD_OK,                                                        ///< No error
+    E_COFDMDMD_FAIL,                                                      ///< Function error
+    E_COFDMDMD_PARAM_ERROR,                                               ///< Function parameter error
+    E_COFDMDMD_TIMEOUT,                                                   ///< COFDMDMD timeout
+} __attribute__((packed)) COFDMDMD_Result;
+
+typedef enum _COFDMDMD_Event
+{
+    E_COFDMDMD_EVENT_TUNE     = 0x0000001,
+    E_COFDMDMD_EVENT_WAITLOCK     = 0x0000002,
+    E_COFDMDMD_EVENT_END     = 0x0000004,
+} __attribute__((packed)) CCOFDMDMD_Event;
+
+
+COFDMDMD_Result MApi_COFDMDMD_GetEvent(CCOFDMDMD_Event *peEvent)
+{
+    MS_U32              u32Events = 0;
+    //printf("[+]MApi_COFDMDMD_GetEvent\n");
+    if (MsOS_WaitEvent(_s32EventId, E_COFDMDMD_EVENT_TUNE | E_COFDMDMD_EVENT_WAITLOCK | E_COFDMDMD_EVENT_END,
+                       &u32Events, E_OR_CLEAR, COFDMDMD_EVENT_TIMEOUT))
+    {
+        *peEvent = (CCOFDMDMD_Event)u32Events;
+        //printf("[-]MApi_COFDMDMD_GetEvent,u32Events=0x%x,OK\n",u32Events);
+        return E_COFDMDMD_OK;
+    }
+
+    *peEvent =  (CCOFDMDMD_Event)u32Events;
+    //printf("[-]MApi_COFDMDMD_GetEvent,u32Events=0x%x,FAIL\n",u32Events);
+    return E_COFDMDMD_TIMEOUT;
+}
+
+static void _Mon_Signal_Task(void)
+{
+    static MS_U32 _u32TimeOut = 10;
+    CCOFDMDMD_Event     u32Events;
+	MS_U32 _u32tunetime = 0;
+     //int i;
+    while (1)
+    {
+        {
+            MApi_COFDMDMD_GetEvent(&u32Events);
+            switch(u32Events)
+            {
+                case E_COFDMDMD_EVENT_TUNE:
+                    MsOS_ClearEvent(_s32EventId, 0xFFFFFFFF);
+                    MON_SIGNAL_DBG(printf("\n E_TUNE_START\n"));
+					_u32tunetime = MsOS_GetSystemTime();
+					MON_SIGNAL_DBG(printf("\n Before tune :%d\n",_u32tunetime));
+					MxL101SF_Tune(_pParam.u32TunerFreq,_pParam.u8BandWidth);
+					MON_SIGNAL_DBG(printf("\n After tune :%d\n",MsOS_GetSystemTime()));
+					MON_SIGNAL_DBG(printf("\n tune time :%d\n",MsOS_GetSystemTime()-_u32tunetime));
+                    CHG_COFDMDMD_EVENT(E_COFDMDMD_EVENT_END);
+					break;
+					/*
+					//not used by kevin.deng
+					_u32TimeOut = 1;
+                    CHG_COFDMDMD_EVENT(E_COFDMDMD_EVENT_WAITLOCK);
+                    break;
+					*/
+                case E_COFDMDMD_EVENT_WAITLOCK:
+                    MON_SIGNAL_DBG(printf("\n E_TUNE_WAIT_LOCK\n"));
+                    MsOS_DelayTask(50);
+                    if(MxL101SF_GetLock())
+                    {
+                        _plock = TRUE;
+                        MON_SIGNAL_DBG(printf("\n _TUNE_LOCK\n"));
+                        MsOS_ClearEvent(_s32EventId, E_COFDMDMD_EVENT_WAITLOCK);
+                        CHG_COFDMDMD_EVENT(E_COFDMDMD_EVENT_END);
+                    }
+                    else if(_u32TimeOut--)
+                    {
+                        MON_SIGNAL_DBG(printf("\n _u32TimeOut\n"));
+                        CHG_COFDMDMD_EVENT(E_COFDMDMD_EVENT_WAITLOCK);
+                    }
+                    else
+                    {
+                        _plock = FALSE;
+                        MON_SIGNAL_DBG(printf("\n _TUNE_UNLOCK\n"));
+                        CHG_COFDMDMD_EVENT_CLEAR(E_COFDMDMD_EVENT_TUNE);
+                    }
+                    break;
+                case E_COFDMDMD_EVENT_TUNE|E_COFDMDMD_EVENT_WAITLOCK:
+                    MON_SIGNAL_DBG(printf("\n E_COFDMDMD_EVENT_TUNE|E_COFDMDMD_EVENT_WAITLOCK\n"));
+                    CHG_COFDMDMD_EVENT_CLEAR(E_COFDMDMD_EVENT_TUNE);
+                    break;
+
+                case E_COFDMDMD_EVENT_TUNE|E_COFDMDMD_EVENT_END:
+                    MON_SIGNAL_DBG(printf("\n E_COFDMDMD_EVENT_TUNE|E_COFDMDMD_EVENT_END\n"));
+                    CHG_COFDMDMD_EVENT_CLEAR(E_COFDMDMD_EVENT_TUNE);
+                    break;
+                case E_COFDMDMD_EVENT_END:
+                    MsOS_ClearEvent(_s32EventId, 0xFFFFFFFF);
+                    MON_SIGNAL_DBG(printf("\n E_TUNE_END\n"));
+                    break;
+                default:
+                    break;
+
+            }
+        }
+    }
+}
+ MS_BOOL MApi_Mon_Signal_Init(void)
+{
+#if (!(DYNMEM_STACK))
+    static MS_U8 _pTaskStack[MONITOR_Signal_TASK_STACK];
+#endif
+    if (_s32TaskId >= 0)
+    {
+        return FALSE;
+    }
+
+    _s32MutexId = MsOS_CreateMutex(E_MSOS_FIFO, "OfDmd_Mutex");
+    if (_s32MutexId < 0)
+    {
+        GEN_EXCEP;
+        return FALSE;
+    }
+    _s32EventId = MsOS_CreateEventGroup("CCOFDMDMD_Event");
+    if (_s32EventId < 0)
+    {
+        GEN_EXCEP;
+        MsOS_DeleteMutex(_s32MutexId);
+        return FALSE;
+    }
+#if (DYNMEM_STACK)
+    _pTaskStack = MsOS_AllocateMemory(MONITOR_Signal_TASK_STACK, gs32CachedPoolID);
+    if (_pTaskStack == NULL)
+    {
+        GEN_EXCEP;
+        MsOS_DeleteEventGroup(_s32EventId);
+        MsOS_DeleteMutex(_s32MutexId);
+        return FALSE;
+    }
+#endif
+    _s32TaskId = MsOS_CreateTask((TaskEntry)_Mon_Signal_Task,
+                                 NULL,
+                                 E_TASK_PRI_LOWEST, // Note! Adjust the task priority to E_TASK_PRI_LOW.
+                                 TRUE,
+                                 _pTaskStack,
+                                 MONITOR_Signal_TASK_STACK,
+                                 "Mon_Signal_Task");
+    if (_s32TaskId < 0)
+    {
+        GEN_EXCEP;
+        //MsOS_FreeMemory(_pTaskStack, gs32CachedPoolID);
+        MsOS_DeleteEventGroup(_s32EventId);
+        MsOS_DeleteMutex(_s32MutexId);
+        return FALSE;
+    }
+    return TRUE;
+}
+
+////////////////////////////////////////////////////////////
+
+//-------------------------------------------------------------------------------------------------
+//  Local Variables
+//-------------------------------------------------------------------------------------------------
+MS_U32 SysDelay(MS_U32 dwMs)
+{
+    if (bInited)
+    {
+        MsOS_DelayTask(dwMs);
+    }
+    else
+    {
+        DVBC_DELAY(dwMs);
+    }
+    return (0);
+
+}
+
+
+static void _Demod_HwReset(void)
+{
+    extern void MApi_Demod_HWReset(MS_BOOL bReset);
+    MApi_Demod_HWReset(TRUE);
+    SysDelay(100);
+    MApi_Demod_HWReset(FALSE);
+}
+
+static MS_BOOL _Demod_Init(void)
+{
+    _Demod_HwReset();
+	SysDelay(200);
+	MxL101SF_Init();
+	return TRUE;
+}
+
+/*
+//Mstar Cofdm comman interface
+MS_BOOL MDrv_CofdmDmd_Check_lock(void)
+{
+	static MS_U8 u8Check = 0;
+    if(MxL101SF_GetLock() != _plock)
+    {
+    	u8Check++;
+		if(u8Check>=20)
+		{
+			u8Check = 0;
+        	_plock = !_plock;
+        	printf("\n Retune deomod\n");
+        	CHG_COFDMDMD_EVENT(E_COFDMDMD_EVENT_TUNE);
+		}
+    }
+	else
+	{
+		u8Check = 0;
+	}
+	return _plock;
+}
+
+*/
+MS_BOOL MDrv_CofdmDmd_Init(void)
+{
+    bInited = FALSE;
+	_Demod_Init();
+    MApi_Mon_Signal_Init();
+    bInited = TRUE;
+    return TRUE;
+}
+
+
+MS_BOOL MDrv_CofdmDmd_Open(void)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+
+MS_BOOL MDrv_CofdmDmd_Close(void)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_Reset(void)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_U32  Mdrv_DigitalTuner_SetFreq(CofdmDMD_Param *pParam)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_Restart(CofdmDMD_Param *pParam)
+{
+    MS_U32  			dwError = 0;
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+       _pParam = *pParam;
+       CHG_COFDMDMD_EVENT(E_COFDMDMD_EVENT_TUNE);
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return (dwError ) ? FALSE : TRUE;
+
+}
+
+MS_BOOL MDrv_CofdmDmd_SetMode(CofdmDMD_Mode *pMode)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_TsOut(MS_BOOL bEnable)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_PowerOnOff(MS_BOOL bPowerOn)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    	MxL101SF_PowerOnOff(bPowerOn);
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_SetBW(MS_U32 u32BW)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_GetBW(MS_U32 *pu32BW)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_GetLock(MS_BOOL *pbLock)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+        *pbLock = MxL101SF_GetLock();
+    }
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_GetSNR(MS_U32 *pu32SNR)
+{
+	#define DEFAULT_SNR_MIN 0
+    #define DEFAULT_SNR_MAX 35
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+		*pu32SNR = MxL101SF_GetSNR();
+		DBG_MSB(printf("snr=%d\n",*pu32SNR));
+    }
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE ;
+}
+
+MS_BOOL MDrv_CofdmDmd_GetBER(float *pfBER)
+{
+	*pfBER = MxL101SF_GetBER();
+	return TRUE;
+}
+
+
+MS_BOOL MDrv_CofdmDmd_GetPWR(MS_S32 *ps32Signal)
+{
+	#define DEFAULT_PWR_MIN (255)
+	#define DEFAULT_PWR_MAX (0)
+
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+        if (TRUE == MxL101SF_GetLock() )
+        {
+			*ps32Signal = MxL101SF_GetSigStrength();
+        }
+
+        else
+        {
+	        *ps32Signal = 0;
+        }
+    }
+
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE ;
+
+}
+
+
+MS_BOOL MDrv_CofdmDmd_GetParam(CofdmDMD_Param *pParam)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+    }
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_Config(MS_U8 *pRegParam)
+{
+    if (MsOS_ObtainMutex(_s32MutexId, COFDMDMD_MUTEX_TIMEOUT) == FALSE)
+    {
+        DBG_MSB(printf("%s: Obtain mutex failed.\n", __FUNCTION__));
+        return FALSE;
+    }
+    else
+    {
+
+    }
+    MsOS_ReleaseMutex(_s32MutexId);
+    return TRUE;
+}
+
+MS_BOOL MDrv_CofdmDmd_I2C_ByPass(MS_BOOL bOn)
+{
+    return TRUE;
+}
+
+
diff --git a/drivers/amlogic/dvb_tv/mxl101/mxlfrontend.c b/drivers/amlogic/dvb_tv/mxl101/mxlfrontend.c
new file mode 100755
index 000000000000..2ff83ddabcd2
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl101/mxlfrontend.c
@@ -0,0 +1,225 @@
+/*****************************************************************
+**
+**  Copyright (C) 2009 Amlogic,Inc.
+**  All rights reserved
+**        Filename : mxlfrontend.c
+**
+**  comment:
+**        Driver for MXL101 demodulator
+**  author :
+**	    Shijie.Rong@amlogic
+**  version :
+**	    v1.0	 12/3/13
+*****************************************************************/
+
+/*
+    Driver for MXL101 demodulator
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+#include <mach/am_regs.h>
+#endif
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include "demod_MxL101SF.h"
+#include "../aml_fe.h"
+
+#if 1
+#define pr_dbg(args...) printk("MXL: " args)
+#else
+#define pr_dbg(args...)
+#endif
+
+#define pr_error(args...) printk("MXL: " args)
+
+static int mxl101_read_status(struct dvb_frontend *fe, fe_status_t * status)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	unsigned char s=0;
+	//msleep(1000);
+	s=MxL101SF_GetLock(dev);
+	/*ber=MxL101SF_GetBER();
+	snr=MxL101SF_GetSNR();
+	strength=MxL101SF_GetSigStrength();
+	printk("ber is %d,snr is%d,strength is%d\n",ber,snr,strength);
+	s=1;*/
+	if(s==1)
+	{
+		*status = FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC;
+	}
+	else
+	{
+		*status = FE_TIMEDOUT;
+	}
+
+	return  0;
+}
+
+static int mxl101_read_ber(struct dvb_frontend *fe, u32 * ber)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*ber=MxL101SF_GetBER(dev);
+	return 0;
+}
+
+static int mxl101_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*strength=MxL101SF_GetSigStrength(dev);
+	return 0;
+}
+
+static int mxl101_read_snr(struct dvb_frontend *fe, u16 * snr)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	*snr=MxL101SF_GetSNR(dev) ;
+	return 0;
+}
+
+static int mxl101_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)
+{
+	*ucblocks=0;
+	return 0;
+}
+
+static int mxl101_set_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+
+	UINT8 bandwidth=8;
+	bandwidth=p->u.ofdm.bandwidth;
+	if(bandwidth==0)
+		bandwidth=8;
+	else if(bandwidth==1)
+		bandwidth=7;
+	else if(bandwidth==2)
+		bandwidth=6;
+	else
+		bandwidth=8;
+	MxL101SF_Tune(p->frequency,bandwidth, dev);
+//	demod_connect(state, p->frequency,p->u.qam.modulation,p->u.qam.symbol_rate);
+	afe->params = *p;
+//	Mxl101SF_Debug();
+	pr_dbg("mxl101=>frequency=%d,symbol_rate=%d\r\n",p->frequency,p->u.qam.symbol_rate);
+	return  0;
+}
+
+static int mxl101_get_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
+{//these content will be writed into eeprom .
+
+	struct aml_fe *afe = fe->demodulator_priv;
+
+	*p = afe->params;
+	return 0;
+}
+
+static int mxl101_fe_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+	struct dvb_frontend_ops *fe_ops = (struct dvb_frontend_ops*)ops;
+
+	fe_ops->info.frequency_min = 51000000;
+	fe_ops->info.frequency_max = 858000000;
+	fe_ops->info.frequency_stepsize = 166667;
+	fe_ops->info.frequency_tolerance = 0;
+	fe_ops->info.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS;
+
+	fe_ops->set_frontend = mxl101_set_frontend;
+	fe_ops->get_frontend = mxl101_get_frontend;
+	fe_ops->read_status = mxl101_read_status;
+	fe_ops->read_ber = mxl101_read_ber;
+	fe_ops->read_signal_strength = mxl101_read_signal_strength;
+	fe_ops->read_snr = mxl101_read_snr;
+	fe_ops->read_ucblocks = mxl101_read_ucblocks;
+
+	return 0;
+}
+
+static int mxl101_fe_enter_mode(struct aml_fe *fe, int mode)
+{
+	struct aml_fe_dev *dev = fe->dtv_demod;
+
+	pr_dbg("=========================demod init\r\n");
+	gpio_direction_output(dev->reset_gpio, dev->reset_value);
+	msleep(300);
+	gpio_direction_output(dev->reset_gpio, !dev->reset_value); //enable tuner power
+	msleep(200);
+	MxL101SF_Init(dev);
+
+	return 0;
+}
+
+static int mxl101_fe_resume(struct aml_fe_dev *dev)
+{
+	printk("mxl101_fe_resume\n");
+	gpio_direction_output(dev->reset_gpio, dev->reset_value);
+	msleep(300);
+	gpio_direction_output(dev->reset_gpio, !dev->reset_value); //enable tuner power
+	msleep(200);
+	MxL101SF_Init(dev);
+	return 0;
+
+}
+
+static int mxl101_fe_suspend(struct aml_fe_dev *dev)
+{
+	return 0;
+}
+
+static struct aml_fe_drv mxl101_dtv_demod_drv = {
+.id         = AM_DTV_DEMOD_MXL101,
+.name       = "Mxl101",
+.capability = AM_FE_OFDM,
+.get_ops    = mxl101_fe_get_ops,
+.enter_mode = mxl101_fe_enter_mode,
+.suspend    = mxl101_fe_suspend,
+.resume     = mxl101_fe_resume
+};
+
+static int __init mxlfrontend_init(void)
+{
+	pr_dbg("register mxl101 demod driver\n");
+	return aml_register_fe_drv(AM_DEV_DTV_DEMOD, &mxl101_dtv_demod_drv);
+}
+
+
+static void __exit mxlfrontend_exit(void)
+{
+	pr_dbg("unregister mxl101 demod driver\n");
+	aml_unregister_fe_drv(AM_DEV_DTV_DEMOD, &mxl101_dtv_demod_drv);
+}
+
+fs_initcall(mxlfrontend_init);
+module_exit(mxlfrontend_exit);
+
+
+MODULE_DESCRIPTION("mxl101 DVB-T Demodulator driver");
+MODULE_AUTHOR("RSJ");
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/amlogic/dvb_tv/si2176/Makefile b/drivers/amlogic/dvb_tv/si2176/Makefile
new file mode 100755
index 000000000000..98115a3dc2c1
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2176/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_AM_SI2176) += si2176_fe.o
+
+si2176_fe-objs =si2176_func.o si2176_frontend.o
+
diff --git a/drivers/amlogic/dvb_tv/si2176/si2176_frontend.c b/drivers/amlogic/dvb_tv/si2176/si2176_frontend.c
new file mode 100755
index 000000000000..471b633c3e72
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2176/si2176_frontend.c
@@ -0,0 +1,1025 @@
+/*
+ * Silicon labs si2176 Tuner Device Driver
+ *
+ * Author: Bobby Yang <bo.yang@amlogic.com>
+ *
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/* Standard Liniux Headers */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/dvb/frontend.h>
+#include <mach/gpio_data.h>
+#include<mach/gpio.h>
+
+/* Amlogic Headers */
+
+/* Local Headers */
+#include "si2176_func.h"
+
+#define SI2176_TUNER_I2C_NAME           "si2176_tuner_i2c"
+#define TUNER_DEVICE_NAME                "si2176"
+#ifndef ERROR
+#define ERROR                           1
+#endif
+#define CVD_SI2176_RSSI
+static int si2176_debug = 0;
+/* save time for changing source */
+static int si2176_loaded_firmware = 0;
+static unsigned int enble_AutoLoadFirmware = 0;
+
+module_param(si2176_debug, int, 0644);
+MODULE_PARM_DESC(si2176_debug, "\n si2176_debug \n");
+
+static unsigned short audio_delay = 100;
+module_param(audio_delay, ushort, 0644);
+MODULE_PARM_DESC(audio_delay, "\n the delay for audio mode detection by ms\n");
+
+#define siprintk if(si2176_debug) printk
+#define ssiprintk if(si2176_debug==2) printk
+
+struct si2176_device_s *si2176_devp;
+static void get_mono_sound_mode(unsigned int *);
+void si2176_set_frequency(unsigned int freq);
+static void si2176_set_std(void);
+int si2176_get_strength(void);
+int si2176_get_strength(void){
+	  int strength=100;
+	  if(si2176_tuner_status(&si2176_devp->tuner_client, SI2176_ATV_STATUS_CMD_INTACK_OK, &si2176_devp->si_cmd_reply)!=0)
+    	 {
+        	printk("[si2176..]%s:get si2176 tuner status error!!!\n",__func__);
+        	return -ERROR;
+         }
+    	else
+        	strength = si2176_devp->si_cmd_reply.tuner_status.rssi;//-256;
+		return strength;
+}
+
+
+static void sound_store(const char *buff, v4l2_std_id *std)
+{
+        if(!strncmp(buff,"dk",2))
+                *std |= V4L2_STD_PAL_DK;
+        else if(!strncmp(buff,"bg",2))
+                *std |= V4L2_STD_B;
+        else if(!strncmp(buff,"i",1))
+                *std |= V4L2_STD_PAL_I;
+        else if(!strncmp(buff,"nm",2))
+                *std |= V4L2_STD_NTSC;
+        else if(!strncmp(buff,"pm",2))
+                *std |= V4L2_STD_PAL_M;
+        else if(!strncmp(buff,"l",1))
+                *std |= V4L2_STD_SECAM_L;
+        else if(!strncmp(buff,"lc",2))
+                *std |= V4L2_STD_SECAM_LC;
+		else if(!strncmp(buff,"n",1))
+                *std |= V4L2_STD_PAL_N;
+        else
+                pr_info("invaild command.\n");
+}
+static ssize_t si2176_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
+{
+        int n = 0;
+        unsigned char ret =0;
+        char *buf_orig, *ps, *token;
+        char *parm[4];
+        unsigned int addr = 0, val = 0;
+        v4l2_std_id  std;
+        buf_orig = kstrdup(buf, GFP_KERNEL);
+        ps = buf_orig;
+        while (1) {
+                token = strsep(&ps, " \n");
+                if (token == NULL)
+                        break;
+                if (*token == '\0')
+                        continue;
+                parm[n++] = token;
+        }
+
+        if (!strncmp(parm[0],"rs",strlen("rs")))
+        {
+                if (n != 2)
+                {
+                        pr_err("read: invalid parameter\n");
+                        kfree(buf_orig);
+                        return count;
+                }
+                addr = simple_strtol(parm[1], NULL, 16);
+                pr_err("%s 0x%x\n", parm[0], addr);
+                si2176_get_property(&si2176_devp->tuner_client, 0, addr, &si2176_devp->si_cmd_reply);
+                pr_info("%s: 0x%x --> 0x%x\n", parm[0], addr, si2176_devp->si_cmd_reply.get_property.data);
+        }
+        else if (!strncmp(parm[0],"ws",strlen("ws")))
+        {
+                addr = simple_strtol(parm[1], NULL, 16);
+                val  = simple_strtol(parm[2], NULL, 16);
+                pr_err("%s 0x%x 0x%x", parm[0], addr, val);
+                si2176_set_property(&si2176_devp->tuner_client,0,addr,val,&si2176_devp->si_cmd_reply);
+                pr_info("%s: 0x%x <-- 0x%x\n", parm[0], addr, val);
+        }
+        else if(!strncmp(parm[0],"atv_restart",strlen("atv_restart")))
+        {
+                ret = si2176_atv_restart(&si2176_devp->tuner_client, 0,  &si2176_devp->si_cmd_reply);
+                if(ret)
+                        pr_info("[tuner..] atv_restart error.\n");
+        }
+        else if(!strncmp(parm[0],"dtv_restart",strlen("atv_restart")))
+        {
+                ret = si2176_dtv_restart(&si2176_devp->tuner_client, &si2176_devp->si_cmd_reply);
+                if(ret)
+                        pr_info("[tuner..] atv_restart error.\n");
+        }
+        else if(!strcmp(parm[0],"tune"))
+        {
+                val  = simple_strtol(parm[1], NULL, 10);
+                //SI2176_TUNER_TUNE_FREQ_CMD_MODE_ATV = 1
+                si2176_tune(&si2176_devp->tuner_client, si2176_devp->parm.mode, val, &si2176_devp->si_cmd_reply, &si2176_devp->si_common_reply);
+        }
+        else if(!strcmp(parm[0],"tuner_status"))
+        {
+                //1=SI2176_ATV_STATUS_CMD_INTACK_CLEAR
+                si2176_tuner_status(&si2176_devp->tuner_client, 1, &si2176_devp->si_cmd_reply);
+                printk("\n[tuner_status.vco_code]:%d        \n[tuner_status.tc]:%d     \n[tuner_status.rssil]:%d  \n[tuner_status.rssih]:%d"
+                                "\n[tuner_status.rssi]:%d   \n[tuner_status.freq]:%d \n[tuner_status.mode]:%d \n", si2176_devp->si_cmd_reply.tuner_status.vco_code,
+                                si2176_devp->si_cmd_reply.tuner_status.tc, si2176_devp->si_cmd_reply.tuner_status.rssil, si2176_devp->si_cmd_reply.tuner_status.rssih,
+                                si2176_devp->si_cmd_reply.tuner_status.rssi,  si2176_devp->si_cmd_reply.tuner_status.freq,   si2176_devp->si_cmd_reply.tuner_status.mode);
+        }
+        else if(!strncmp(parm[0],"atv_status",strlen("atv_status")))
+        {
+                //1=SI2176_ATV_STATUS_CMD_INTACK_CLEAR
+                si2176_cmdreplyobj_t *si_cmd_reply = &si2176_devp->si_cmd_reply;
+                si2176_atv_status(&si2176_devp->tuner_client, 1, si_cmd_reply);
+                printk("\n[atv_status.chl]:%d   \n[atv_status.pcl]:%d       \n[atv_status.dl]:%d   \n[atv_status.snrl]:%d"
+                                "\n[atv_status.snrh]:%d  \n[atv_status.video_snr]:%d    \n[atv_status.afc_freq]:%d    \n[atv_status.video_sc_spacing]:%d"
+                                "\n[atv_status.video_sys]:%d    \n[atv_status.color]:%d      \n[atv_status.audio_chan_bw]:%d \n[atv_status.audio_sys]:%d"
+                                "\n[atv_status.audio_demod_mode]:%d     \n[atv_status.sound_level]:%d       \n[atv_status.trans]:%d.\n",
+                                si_cmd_reply->atv_status.chl,   si_cmd_reply->atv_status.pcl,  si_cmd_reply->atv_status.dl,   si_cmd_reply->atv_status.snrl,
+                                si_cmd_reply->atv_status.snrh,  si_cmd_reply->atv_status.video_snr,   si_cmd_reply->atv_status.afc_freq,  si_cmd_reply->atv_status.video_sc_spacing,
+                                si_cmd_reply->atv_status.video_sys,    si_cmd_reply->atv_status.color, si_cmd_reply->atv_status.audio_chan_bw,  si_cmd_reply->atv_status.audio_sys,
+                                si_cmd_reply->atv_status.audio_demod_mode,  si_cmd_reply->atv_status.sound_level,   si_cmd_reply->atv_status.trans);
+        }
+	else  if(!strncmp(parm[0],"descramble",strlen("descramble")))
+	{
+		pr_info("[2176]:descramble is on\n");
+		si2176_cmdreplyobj_t *si_cmd_reply = &si2176_devp->si_cmd_reply;
+		if (si2176_config_pins(&si2176_devp->tuner_client,      /* turn off BCLK1 and XOUT */
+				SI2176_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1,
+	    	        	SI2176_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ,
+	    			SI2176_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_1,
+				SI2176_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ,
+			    	SI2176_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE,
+		    	   	SI2176_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ,
+    				SI2176_CONFIG_PINS_CMD_BCLK1_MODE_DISABLE,
+				SI2176_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ,
+				SI2176_CONFIG_PINS_CMD_XOUT_MODE_DISABLE,
+				si_cmd_reply) !=0)
+		{
+	    		pr_info("%s: config pins error:%d!!!!\n", __func__, ERROR_SI2176_SENDING_COMMAND);
+	    		return ERROR_SI2176_SENDING_COMMAND;
+		}
+	}
+	else  if(!strncmp(parm[0],"disdescramble",strlen("disdescramble")))
+	{
+		pr_info("[2176]:descramble is down\n");
+		si2176_cmdreplyobj_t *si_cmd_reply = &si2176_devp->si_cmd_reply;
+		if (si2176_config_pins(&si2176_devp->tuner_client,	    /* turn off BCLK1 and XOUT */
+				SI2176_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE,
+				SI2176_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ,
+				SI2176_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE,
+				SI2176_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ,
+				SI2176_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE,
+				SI2176_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ,
+				SI2176_CONFIG_PINS_CMD_BCLK1_MODE_DISABLE,
+				SI2176_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ,
+				SI2176_CONFIG_PINS_CMD_XOUT_MODE_DISABLE,
+				si_cmd_reply) !=0)
+		{
+		pr_info("%s: config pins error:%d!!!!\n", __func__, ERROR_SI2176_SENDING_COMMAND);
+		return ERROR_SI2176_SENDING_COMMAND;
+		}
+
+	}
+        else if(!strncmp(parm[0],"mono_mode",strlen("mono_mode")))
+        {
+                get_mono_sound_mode(&val);
+                printk("[si2176..]%s get mono 0x%x,mode %s.\n",__func__,val,v4l2_std_to_str((v4l2_std_id)val));
+        }
+        else if(!strncmp(parm[0],"enter_atv",strlen("enter_atv")))
+        {
+                si2176_devp->parm.mode                 = SI2176_TUNER_TUNE_FREQ_CMD_MODE_ATV;
+				si2176_loaded_firmware = 1;
+                si2176_init(&si2176_devp->tuner_client,&si2176_devp->si_cmd_reply,&si2176_devp->si_common_reply);
+                si2176_configure(&si2176_devp->tuner_client,&si2176_devp->si_prop,&si2176_devp->si_cmd_reply,&si2176_devp->si_common_reply);
+        }
+        else if(!strncmp(parm[0],"std",strlen("std")))
+        {
+                if(!strncmp(parm[1],"pal",3))
+                {
+                        std= V4L2_COLOR_STD_PAL;
+                        sound_store(parm[2],&std);
+                }
+                else if(!strncmp(parm[1],"ntsc",4))
+                {
+                        std= V4L2_COLOR_STD_NTSC;
+                        sound_store(parm[2],&std);
+                }
+                else if(!strncmp(parm[1],"secam",5))
+                {
+                        std= V4L2_COLOR_STD_SECAM;
+                        sound_store(parm[2],&std);
+                }
+                si2176_devp->parm.std  =std;
+                si2176_set_std();
+                siprintk("[si2176..]%s set std color %s, audio type %s.\n",__func__,\
+                                v4l2_std_to_str(0xff000000&si2176_devp->parm.std), v4l2_std_to_str(0xffffff&si2176_devp->parm.std));
+        }
+		else if(!strncmp(parm[0],"cvbs_amp",strlen("cvbs_amp")))
+		{
+			si2176_devp->si_prop.atv_cvbs_out.amp=simple_strtol(parm[1], NULL, 10);
+			if(si2176_set_property(&si2176_devp->tuner_client, 0,0x609,((si2176_devp->si_prop.atv_cvbs_out.amp & 0xff)<<8)|(25 & 0xff), &si2176_devp->si_cmd_reply))
+            printk("[si2176..]%s set cvbs_amp out error.\n",__func__);
+
+		}
+		else
+                printk("invalid command\n");
+        kfree(buf_orig);
+        return count;
+}
+
+static ssize_t si2176_show(struct class *cls,struct class_attribute *attr,char *buff)
+{
+        return 0;
+}
+
+static ssize_t si2176_autoLoadFirmware_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
+{
+  if(buf[0] == '0'){
+    enble_AutoLoadFirmware = 0;
+  }else if(buf[0] == '1'){
+    enble_AutoLoadFirmware = 1;
+  }
+  return count;
+}
+
+static ssize_t si2176_autoLoadFirmware_show(struct class *cls,struct class_attribute *attr,char *buff)
+{
+  return sprintf(buff, "%s\n", enble_AutoLoadFirmware? "ON": "OFF");
+}
+
+static CLASS_ATTR(si2176_debug,0644,si2176_show,si2176_store);
+static CLASS_ATTR(si2176_autoLoadFirmware,0644,si2176_autoLoadFirmware_show,si2176_autoLoadFirmware_store);
+
+#ifdef  CVD_SI2176_RSSI
+int cvd_get_rf_strength(void)
+{
+	 int cvd_rssi=0;
+	 if(!si2176_devp)
+	 	return 0;
+	 cvd_rssi=si2176_devp->si_cmd_reply.tuner_status.rssi;
+	 return ((cvd_rssi>0)?cvd_rssi:0);
+}
+EXPORT_SYMBOL(cvd_get_rf_strength);
+#endif
+
+
+static int si2176_get_rf_strength(struct dvb_frontend *fe, unsigned short *strength)
+{
+        if(!strength)
+        {
+                printk("[si2176..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        if(si2176_tuner_status(&si2176_devp->tuner_client, SI2176_ATV_STATUS_CMD_INTACK_OK, &si2176_devp->si_cmd_reply)!=0)
+        {
+                pr_info("[si2176..]%s:get si2176 tuner status error!!!\n",__func__);
+                return -ERROR;
+        }
+        else
+                *strength = si2176_devp->si_cmd_reply.tuner_status.rssi;
+        return 0;
+}
+
+static int si2176_get_tuner_status(struct dvb_frontend *dvb_fe, tuner_status_t *status)
+{
+        si2176_cmdreplyobj_t  *si_cmd_reply = &si2176_devp->si_cmd_reply;
+        if(!status)
+        {
+                printk("[si2176..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        //SI2176_ATV_STATUS_CMD_INTACK_OK = 0
+        if(si2176_tuner_status(&si2176_devp->tuner_client, 0, si_cmd_reply)!=0)
+        {
+                printk("[si2176..]%s:get si2176 tuner status error.\n",__func__);
+                return -ERROR;
+        }
+        status->frequency = si_cmd_reply->tuner_status.freq;
+        status->mode        = si_cmd_reply->tuner_status.mode;
+        status->rssi           = si_cmd_reply->tuner_status.rssi;
+        if(si_cmd_reply->tuner_status.rssih ||si_cmd_reply->tuner_status.rssil)
+        {
+                status->tuner_locked = 0;
+                siprintk("[si2176..]%s rssi %d dismatch <%d, %d>.\n",__func__, (si_cmd_reply->tuner_status.rssi<<24),
+                                (si2176_devp->si_prop.atv_rsq_rssi_threshold.lo),(si2176_devp->si_prop.atv_rsq_rssi_threshold.hi));
+        }
+        else
+        {
+                status->tuner_locked = 1;
+                siprintk("[si2176..]%s rssi %d dismatch <%d, %d>.\n",__func__, si_cmd_reply->tuner_status.rssi,
+                                si2176_devp->si_prop.atv_rsq_rssi_threshold.lo,si2176_devp->si_prop.atv_rsq_rssi_threshold.hi);
+        }
+        siprintk(" frequency %u, mode %d,tuner locked %d.\n",status->frequency, status->mode, status->tuner_locked);
+        return 0;
+}
+
+static int  si2176_tuner_fine_tune(struct dvb_frontend *dvb_fe, int offset_khz)
+{
+
+        if(si2176_fine_tune(&si2176_devp->tuner_client,0,offset_khz<<1,&si2176_devp->si_cmd_reply)!=0)
+        {
+                printk("[si2176..]%s: si2176 fine tune error.\n",__func__);
+                return -ERROR;
+        }
+        else
+        {
+                if(si2176_debug)
+                        printk("[si2176..]%s: si2176 fine tune %d khz.\n", __func__, offset_khz);
+                return 0;
+        }
+}
+
+void si2176_set_frequency(unsigned int freq)
+{
+        int ret = 0;
+        if(si2176_debug)
+	    printk("[%s]:now mode is %d(0-DTV,1-ATV)\n",__func__,si2176_devp->parm.mode);
+        ret = si2176_tune(&si2176_devp->tuner_client, si2176_devp->parm.mode, freq, &si2176_devp->si_cmd_reply, &si2176_devp->si_common_reply);
+        if (ret)
+                siprintk("[si2176..]%s: tune frequency error:%d.\n", __func__, ret);
+}
+static void si2176_set_std(void)
+{
+        unsigned char color_mode=SI2176_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC;
+	unsigned char video_sys=SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I;
+	unsigned char  ret=0;
+        v4l2_std_id ptstd = si2176_devp->parm.std;
+        /*set color standard of atv:pal & ntsc*/
+        if (ptstd & (V4L2_COLOR_STD_PAL | V4L2_COLOR_STD_NTSC))
+        {
+                color_mode = SI2176_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC;
+        }
+        else if (ptstd & (V4L2_COLOR_STD_SECAM))
+        {
+                color_mode = SI2176_ATV_VIDEO_MODE_PROP_COLOR_SECAM;
+        }
+
+        /* set audio standard of tuner:secam*/
+        if (ptstd & V4L2_STD_B)
+        {
+                si2176_devp->fre_offset = 2250000;
+                video_sys = SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B;
+        }
+        else if (ptstd & V4L2_STD_GH)
+        {
+                si2176_devp->fre_offset = 2250000;
+                video_sys = SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH;
+        }
+        else if ((ptstd & V4L2_STD_NTSC) || ((ptstd & V4L2_STD_PAL_M)))
+        {
+                si2176_devp->fre_offset = 1750000;
+                video_sys = SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M;
+        }
+        else if (ptstd & (V4L2_STD_PAL_N | V4L2_STD_PAL_Nc))
+        {
+                si2176_devp->fre_offset = 1750000;
+                video_sys = SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_N;
+        }
+        else if (ptstd & V4L2_STD_PAL_I)
+        {
+                si2176_devp->fre_offset = 2750000;
+                video_sys = SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I;
+        }
+        else if (ptstd & V4L2_STD_DK)
+        {
+                si2176_devp->fre_offset = 2750000;
+                video_sys = SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK;
+        }
+        else if (ptstd & V4L2_STD_SECAM_L)
+        {
+                si2176_devp->fre_offset = 2750000;
+                video_sys = SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_L;
+        }
+        else if (ptstd & V4L2_STD_SECAM_LC)
+        {
+                si2176_devp->fre_offset = 2750000;
+                video_sys = SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LP;
+        }
+        ret = si2176_set_property(&si2176_devp->tuner_client, 0, 0x604, color_mode<<4|video_sys, &si2176_devp->si_cmd_reply);
+        if(ret)
+                printk("[si2176..]%s:set std %llu error\n",__func__, (unsigned long long)ptstd);
+        siprintk("[si2176..]%s: color %d,video_mode.video_sys:%d.\n", __func__, color_mode, video_sys);
+        if(si2176_atv_restart(&si2176_devp->tuner_client, 0,  &si2176_devp->si_cmd_reply))
+                printk("[si2176..]%s: atv restart error.\n", __func__);
+}
+
+static int si2176_set_params(struct dvb_frontend *fe, struct dvb_frontend_parameters *parm)
+{
+    int strength=100;
+    if(FE_ANALOG == fe->ops.info.type)
+    {
+	    if(parm->u.analog.std != si2176_devp->parm.std)
+	    {
+	        si2176_devp->parm.std  = parm->u.analog.std;
+	        si2176_set_std();
+                siprintk("[si2176..]%s set std color %s, audio type %s.\n",__func__,\
+                            v4l2_std_to_str(0xff000000&si2176_devp->parm.std), v4l2_std_to_str(0xffffff&si2176_devp->parm.std));
+	    }
+            if(parm->frequency  != si2176_devp->parm.frequency)
+	    {
+	        si2176_devp->parm.frequency  = parm->frequency;
+	        si2176_set_frequency(si2176_devp->parm.frequency + si2176_devp->fre_offset);
+                siprintk("[si2176..]%s set frequency %u. frequency offset is %d.\n",__func__,si2176_devp->parm.frequency,si2176_devp->fre_offset);
+	    }
+        /*
+	    else if(parm->u.analog.audmode != si2176_devp->parm.audmode)
+	    {
+	        printk("[si2176..] %s no audmode case catch error.\n",__func__);
+	    }
+	    else if(parm->u.analog.soundsys != si2176_devp->parm.soundsys)
+	    {
+		printk("[si2176..] %s no soundsys case catch error.\n",__func__);
+	    }
+            else if(parm->u.analog.reserved != si2176_devp->parm.reserved)
+            {
+                printk("[si2176..] %s no case catch resevred.\n",__func__);
+            }*/
+	}
+    else
+	{
+	/*	if(FE_QAM == fe->ops.info.type)
+		{
+			if(QAM_128 == parm->u.qam.modulation)
+			{
+				si2176_devp->si_prop.dtv_lif_out.amp = 22;
+				if(si2176_set_property(&si2176_devp->tuner_client,0,0x707,22,&si2176_devp->si_cmd_reply))
+					printk("[si2176..]%s set dtv lif out amp 22error.\n",__func__);
+			}
+			else
+			{
+				si2176_devp->si_prop.dtv_lif_out.amp = 25;
+				if(si2176_set_property(&si2176_devp->tuner_client,0,0x707,25,&si2176_devp->si_cmd_reply))
+					printk("[si2176..]%s set dtv lif out amp 25 error.\n",__func__);
+			}
+		}*/
+		 if(FE_ATSC==fe->ops.info.type){
+				si2176_devp->si_prop.dtv_lif_freq.offset=6350;
+				printk("FE_ATSC set para if is %d\n",si2176_devp->si_prop.dtv_lif_freq.offset);
+				if(si2176_set_property(&si2176_devp->tuner_client,0,0x706,si2176_devp->si_prop.dtv_lif_freq.offset,&si2176_devp->si_cmd_reply))
+					printk("[si2176..]%s set dtv lif out if error.\n",__func__);
+			//	parm->frequency=parm->frequency+2500000;//for atsc 2.5mhz
+		}
+		if(FE_QAM == fe->ops.info.type){
+			si2176_devp->si_prop.dtv_lif_freq.offset=5000;
+			printk("FE_QAM set para if is %d\n",si2176_devp->si_prop.dtv_lif_freq.offset);
+			if(si2176_set_property(&si2176_devp->tuner_client,0,0x706,si2176_devp->si_prop.dtv_lif_freq.offset,&si2176_devp->si_cmd_reply))
+					printk("[si2176..]%s set dtv lif out if error.\n",__func__);
+			if(parm->u.qam.modulation==QAM_256){
+				si2176_devp->si_prop.dtv_lif_out.amp = 23;
+			}else{
+				si2176_devp->si_prop.dtv_lif_out.amp = 23;
+			}
+			printk("amp is %d,offset is %d,amp+offset is %x\n",si2176_devp->si_prop.dtv_lif_out.amp,si2176_devp->si_prop.dtv_lif_out.offset,((si2176_devp->si_prop.dtv_lif_out.offset)+((si2176_devp->si_prop.dtv_lif_out.amp)<<8)));
+			if(si2176_set_property(&si2176_devp->tuner_client,0,0x707,(si2176_devp->si_prop.dtv_lif_out.offset)+((si2176_devp->si_prop.dtv_lif_out.amp)<<8),&si2176_devp->si_cmd_reply))
+					printk("[si2176..]%s set dtv lif out amp error.\n",__func__);
+		}
+
+
+
+		si2176_devp->parm.frequency  = parm->frequency;
+		si2176_set_frequency(si2176_devp->parm.frequency);
+		printk("[si2176..]%s set frequency %u. \n",__func__,si2176_devp->parm.frequency);
+		if(si2176_tuner_status(&si2176_devp->tuner_client, SI2176_ATV_STATUS_CMD_INTACK_OK, &si2176_devp->si_cmd_reply)!=0)
+		{
+        	printk("[si2176..]%s:get si2176 tuner status error!!!\n",__func__);
+        	return -ERROR;
+		}
+		else
+		    strength = si2176_devp->si_cmd_reply.tuner_status.rssi-256;
+//		printk("strength is %d\n",strength);
+     }
+
+    return 0;
+}
+//try audmode B,CH,I,DK,return the sound level
+static unsigned char set_video_audio_mode(unsigned char color,unsigned char audmode)
+{
+        int ret = 0;
+        ret = si2176_set_property(&si2176_devp->tuner_client, 0, 0x604, color<<4|audmode, &si2176_devp->si_cmd_reply);
+        ret = si2176_atv_restart(&si2176_devp->tuner_client, 0,  &si2176_devp->si_cmd_reply);
+        mdelay(audio_delay);
+        if(ret)
+                printk("[si2176..]%s set sound mode %d error.\n",__func__,audmode);
+        ret = si2176_atv_status(&si2176_devp->tuner_client, SI2176_ATV_STATUS_CMD_INTACK_OK, &si2176_devp->si_cmd_reply);
+        if(ret)
+                printk("[si2176..]%s:get si2176 atv status error.\n",__func__);
+        if(!ret)
+                return si2176_devp->si_cmd_reply.atv_status.sound_level;
+        else
+                return ret;
+}
+static void get_mono_sound_mode(unsigned int *mode)
+{
+        unsigned char max_level=0, cu_level=0;
+        //set audio mode B=0,GH=1,I=4,DK=5
+        cu_level = set_video_audio_mode(si2176_devp->si_prop.atv_video_mode.color,SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B);
+        if(cu_level > max_level)
+        {
+                max_level = cu_level;
+                *mode = V4L2_STD_B;
+        }
+        cu_level = set_video_audio_mode(si2176_devp->si_prop.atv_video_mode.color,SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH);
+        if(cu_level > max_level)
+        {
+                max_level = cu_level;
+                *mode = V4L2_STD_GH;
+        }
+        cu_level = set_video_audio_mode(si2176_devp->si_prop.atv_video_mode.color,SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I);
+        if(cu_level > max_level)
+        {
+                max_level = cu_level;
+                *mode = V4L2_STD_PAL_I;
+        }
+        cu_level = set_video_audio_mode(si2176_devp->si_prop.atv_video_mode.color,SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK);
+        if(cu_level > max_level)
+        {
+                max_level = cu_level;
+                *mode = V4L2_STD_DK;
+        }
+        siprintk("[si2176..]%s auto result audio mode is 0x%x,%s.\n",__func__, *mode,v4l2_std_to_str((v4l2_std_id)*mode));
+        //revert the color&audmode
+        si2176_set_property(&si2176_devp->tuner_client, 0, 0x604, si2176_devp->si_prop.atv_video_mode.color<<4|si2176_devp->si_prop.atv_video_mode.video_sys, &si2176_devp->si_cmd_reply);
+        si2176_atv_restart(&si2176_devp->tuner_client, 0,  &si2176_devp->si_cmd_reply);
+}
+static int si2176_set_config(struct dvb_frontend *fe, void *arg)
+{
+        tuner_param_t *param = (tuner_param_t*)arg;
+        unsigned int data = 0;
+
+        if(!arg)
+        {
+                printk("[si2176..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        switch(param->cmd)
+        {
+                case TUNER_CMD_AUDIO_MUTE:
+                        //SI2176_ATV_AF_OUT_PROP = 0x060b
+                        if(si2176_set_property(&si2176_devp->tuner_client, 0,0x60b, 0, &si2176_devp->si_cmd_reply))
+                        {
+                                printk("[si2176..]%s mute tuner error.\n",__func__);
+                                return -ERROR;
+                        }
+                        break;
+                case TUNER_CMD_AUDIO_ON:
+                        data = (si2176_devp->si_prop.atv_af_out.volume & SI2176_ATV_AF_OUT_PROP_VOLUME_MASK) << SI2176_ATV_AF_OUT_PROP_VOLUME_LSB |
+                               (si2176_devp->si_prop.atv_af_out.soft_mute & SI2176_ATV_AF_OUT_PROP_SOFT_MUTE_MASK) << SI2176_ATV_AF_OUT_PROP_SOFT_MUTE_LSB;
+                        if(si2176_set_property(&si2176_devp->tuner_client, 0,0x60b, data, &si2176_devp->si_cmd_reply))
+                        {
+                                printk("[si2176..]%s set tuner volume error.\n",__func__);
+                                return -ERROR;
+                        }
+                        break;
+                case TUNER_CMD_TUNER_POWER_DOWN:
+                        if(si2176_power_down(&si2176_devp->tuner_client, &si2176_devp->si_cmd_reply))
+                        {
+                                printk("[si2176..]%s power down tuner error.\n",__func__);
+                                return -ERROR;
+                        }
+                        siprintk("[si2176..]%s power down tuner TUNER_CMD_TUNER_POWER_DOWN.\n",__func__);
+                        si2176_loaded_firmware =  0;
+                        break;
+                case TUNER_CMD_TUNER_POWER_ON:
+                        if(si2176_init(&si2176_devp->tuner_client, &si2176_devp->si_cmd_reply, &si2176_devp->si_common_reply))
+                        {
+                                pr_info("[si2176..]%s: si2176 initializate error.\n",__func__);
+                                return -ERROR;
+                        }
+                        if(si2176_configure(&si2176_devp->tuner_client, &si2176_devp->si_prop, &si2176_devp->si_cmd_reply, &si2176_devp->si_common_reply))
+                                printk("[si2176..]%s: si2176 configure atv&dtv error.\n",__func__);
+                        si2176_loaded_firmware =  1;
+                        break;
+                case TUNER_CMD_SET_VOLUME:
+                        if(param->parm > SI2176_ATV_AF_OUT_PROP_VOLUME_VOLUME_MAX)
+                                param->parm = SI2176_ATV_AF_OUT_PROP_VOLUME_VOLUME_MAX;
+                        si2176_devp->si_prop.atv_af_out.volume = param->parm;
+                        if(si2176_set_property(&si2176_devp->tuner_client, 0,0x60b, si2176_devp->si_prop.atv_af_out.volume, &si2176_devp->si_cmd_reply))
+                                printk("[si2176..]%s set tuner volume error.\n",__func__);
+                        break;
+                case TUNER_CMD_GET_MONO_MODE:
+                        get_mono_sound_mode(&param->parm);
+                        break;
+                case TUNER_CMD_SET_LEAP_SETP_SIZE:
+                        si2176_devp->parm.leap_step = param->parm;
+                        break;
+                case TUNER_CMD_SET_BEST_LOCK_RANGE:
+                        break;
+                case TUNER_CMD_GET_BEST_LOCK_RANGE:
+                        break;
+		case TUNER_CMD_SET_CVBS_AMP_OUT:
+			si2176_devp->si_prop.atv_cvbs_out.amp=param->parm;
+			if(si2176_set_property(&si2176_devp->tuner_client, 0,0x609,((si2176_devp->si_prop.atv_cvbs_out.amp & 0xff)<<8)|(25 & 0xff), &si2176_devp->si_cmd_reply))
+			printk("[si2176..]%s set cvbs_amp out error.\n",__func__);
+			break;
+		case TUNER_CMD_GET_CVBS_AMP_OUT:
+			if(si2176_get_property(&si2176_devp->tuner_client,0,0x609,&si2176_devp->si_cmd_reply))
+			{
+			printk("[si2176..]:%s:get cvbs amp error.\n",__func__);
+			}
+			param->parm=si2176_devp->si_cmd_reply.get_property.data;
+			printk("[si2176..]%s:get the cvbs amp out is %d\n",__func__,param->parm);
+			break;
+                default:
+                        break;
+        }
+        return 0;
+}
+static void si2176_get_status(struct dvb_frontend *fe, void *stat);
+static void si2176_get_pll_status(struct dvb_frontend *fe, void *stat);
+
+static int si2176_tuner_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+        struct dvb_tuner_ops *si2176_tuner_ops  = (struct dvb_tuner_ops*)ops;
+        if(!ops)
+        {
+                printk("[si2176..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        si2176_tuner_ops->info.frequency_min    = SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MIN;
+        si2176_tuner_ops->info.frequency_max   = SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MAX;
+        switch(mode)
+        {
+                case AM_FE_QPSK:
+                        //SI2176_DTV_MODE_PROP_MODULATION_ISDBT = 4
+                        si2176_devp->si_prop.dtv_mode.modulation = 4;
+                        break;
+                case AM_FE_QAM:
+                        //SI2176_DTV_MODE_PROP_MODULATION_DVBC = 3
+                        si2176_devp->si_prop.dtv_mode.modulation = 3;
+                        break;
+                case AM_FE_OFDM:
+                        //SI2176_DTV_MODE_PROP_MODULATION_DVBT = 2
+                        si2176_devp->si_prop.dtv_mode.modulation = 2;
+                        break;
+                case AM_FE_ATSC:
+                        //SI2176_DTV_MODE_PROP_MODULATION_ATSC = 0
+                        si2176_devp->si_prop.dtv_mode.modulation = 0;
+                        break;
+                case AM_FE_ANALOG:
+                        break;
+				case AM_FE_DTMB:
+                        //SI2176_DTV_MODE_PROP_MODULATION_DTMB = 6
+                        si2176_devp->si_prop.dtv_mode.modulation = 6;
+                        break;
+                default:
+                        printk("[si2176..] %s no mode to match %d.\n",__func__, mode);
+                        break;
+        }
+        if(AM_FE_ANALOG == mode)//the auto afc step size 1/2 M
+        {
+                si2176_tuner_ops->info.frequency_step = 0x0;
+                //fine tune
+                si2176_tuner_ops->fine_tune             = si2176_tuner_fine_tune;
+                //the box for expand
+                si2176_tuner_ops->set_config           = si2176_set_config;
+                si2176_devp->parm.mode                 = SI2176_TUNER_TUNE_FREQ_CMD_MODE_ATV;
+        }
+        else//dtv doesn't use auto afc
+        {
+                if(si2176_set_property(&si2176_devp->tuner_client, 0, 0x703,
+                                        si2176_devp->si_prop.dtv_mode.modulation<<4|8,
+                                        &si2176_devp->si_cmd_reply))
+                        printk("[si2176..] %s mode %d si2176_set_property error.",__func__, mode);
+                si2176_devp->parm.mode                 = SI2176_TUNER_TUNE_FREQ_CMD_MODE_DTV;
+                si2176_tuner_ops->info.frequency_step = 0x0;
+        }
+        si2176_tuner_ops->get_rf_strength       = si2176_get_rf_strength;
+        si2176_tuner_ops->get_tuner_status    = si2176_get_tuner_status;
+        si2176_tuner_ops->get_status              =si2176_get_status;
+	si2176_tuner_ops->get_pll_status              =si2176_get_pll_status;
+        //set std&frequency
+        si2176_tuner_ops->set_params     	  = si2176_set_params;
+        return 0;
+}
+
+static int si2176_tuner_fe_init(struct aml_fe_dev *dev)
+{
+
+        int error_code = 0;
+        if(!dev)
+        {
+                printk("[si2176..]%s: null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        si2176_devp->tuner_client.adapter = dev->i2c_adap;
+        si2176_devp->tuner_client.addr    = dev->i2c_addr;
+        if(!sprintf(si2176_devp->tuner_client.name,SI2176_TUNER_I2C_NAME))
+        {
+                printk("[si2176..]%s sprintf name error.\n",__func__);
+        }
+       gpio_out(dev->reset_gpio,0);
+       mdelay(100);
+       gpio_out(dev->reset_gpio,1);
+       printk("[%s]tuner reset.dev->reset_value=[%d] \n",__func__,dev->reset_value);
+      return error_code;
+}
+
+static int si2176_enter_mode(struct aml_fe *fe, int mode)
+{
+        int err_code;
+		if(si2176_loaded_firmware && enble_AutoLoadFirmware)
+			return 0;
+		si2176_loaded_firmware = 1;
+        err_code = si2176_init(&si2176_devp->tuner_client,&si2176_devp->si_cmd_reply,&si2176_devp->si_common_reply);
+        err_code = si2176_configure(&si2176_devp->tuner_client,&si2176_devp->si_prop,&si2176_devp->si_cmd_reply,&si2176_devp->si_common_reply);
+		if(err_code)
+        {
+                printk("[si2176..]%s init si2176 error.\n",__func__);
+                return err_code;
+        }
+        return 0;
+}
+static int si2176_leave_mode(struct aml_fe *fe, int mode)
+{
+        int err_code;
+	si2176_devp->parm.std=0;
+	si2176_devp->parm.frequency=0;
+		if(si2176_loaded_firmware && enble_AutoLoadFirmware)
+			return 0;
+        err_code = si2176_power_down(&si2176_devp->tuner_client, &si2176_devp->si_cmd_reply);
+		if(err_code)
+        {
+                printk("[si2176..]%s power down si2176 error.\n",__func__);
+                return err_code;
+        }
+        return 0;
+}
+
+static int si2176_suspend(struct aml_fe_dev *dev)
+{
+	int err_code;
+	si2176_devp->parm.frequency=0;
+	si2176_devp->parm.std = 0;
+	si2176_loaded_firmware = 0;
+	err_code = si2176_power_down(&si2176_devp->tuner_client, &si2176_devp->si_cmd_reply);
+	 if(err_code)
+        {
+        printk("[si2176..]%s si2176 standby mode is err.\n",__func__);
+        return err_code;
+        }
+	 return 0;
+
+}
+static int si2176_resume(struct aml_fe_dev *dev)
+{
+	int err_code;
+	gpio_out(dev->reset_gpio,0);
+	udelay(200);
+	gpio_out(dev->reset_gpio,1);
+	si2176_loaded_firmware = 1;
+        err_code = si2176_init(&si2176_devp->tuner_client,&si2176_devp->si_cmd_reply,&si2176_devp->si_common_reply);
+        err_code = si2176_configure(&si2176_devp->tuner_client,&si2176_devp->si_prop,&si2176_devp->si_cmd_reply,&si2176_devp->si_common_reply);
+        if(err_code)
+        {
+                printk("[si2176..]%s resume si2176 error.\n",__func__);
+                return err_code;
+        }
+        return 0;
+}
+static struct aml_fe_drv si2176_tuner_drv = {
+        .name    = "si2176_tuner",
+        .capability = AM_FE_ANALOG|AM_FE_QPSK|AM_FE_QAM|AM_FE_ATSC|AM_FE_OFDM|AM_FE_DTMB,
+        .id      = AM_TUNER_SI2176,
+        .get_ops = si2176_tuner_get_ops,
+        .init    = si2176_tuner_fe_init,
+        .enter_mode = si2176_enter_mode,
+        .leave_mode = si2176_leave_mode,
+        .suspend = si2176_suspend,
+        .resume = si2176_resume,
+};
+
+static int si2176_analog_get_afc(struct dvb_frontend *fe)
+{
+        if(si2176_atv_status(&si2176_devp->tuner_client, SI2176_ATV_STATUS_CMD_INTACK_OK, &si2176_devp->si_cmd_reply)!=0)
+        {
+                pr_info("[si2176..]%s: get si2176 atv status error.\n",__func__);
+                return -ERROR;
+        }
+        else
+                return si2176_devp->si_cmd_reply.atv_status.afc_freq;
+}
+static int si2176_analog_get_snr(struct dvb_frontend *fe)
+{
+        if(si2176_atv_status(&si2176_devp->tuner_client, SI2176_ATV_STATUS_CMD_INTACK_OK, &si2176_devp->si_cmd_reply)!=0)
+        {
+                pr_info("[si2176..]%s: get si2176 atv status error.\n",__func__);
+                return -ERROR;
+        }
+        else
+                return si2176_devp->si_cmd_reply.atv_status.video_snr;
+}
+//tuner lock status & demod lock status should be same in silicon tuner
+static void si2176_get_status(struct dvb_frontend *fe, void *stat)
+{
+        fe_status_t *status = (fe_status_t*)stat;
+        if(!status)
+        {
+                printk("[si2176..]%s: null pointer error.\n",__func__);
+                return;
+        }
+        if(si2176_atv_status(&si2176_devp->tuner_client, SI2176_ATV_STATUS_CMD_INTACK_OK, &si2176_devp->si_cmd_reply))
+        {
+                pr_info("[si2176..]%s:get si2176 atv status error.\n",__func__);
+                return;
+        }
+        else
+        {
+                if(si2176_devp->si_cmd_reply.atv_status.chl)
+                        *status = FE_HAS_LOCK;
+                else
+                        *status = FE_TIMEDOUT;
+        }
+}
+//tuner lock status & demod lock status should be same in silicon tuner
+static void si2176_get_pll_status(struct dvb_frontend *fe, void *stat)
+{
+        fe_status_t *status = (fe_status_t*)stat;
+        if(!status)
+        {
+                printk("[si2176..]%s: null pointer error.\n",__func__);
+                return;
+        }
+        if(si2176_atv_status(&si2176_devp->tuner_client, SI2176_ATV_STATUS_CMD_INTACK_OK, &si2176_devp->si_cmd_reply))
+        {
+                pr_info("[si2176..]%s:get si2176 atv status error.\n",__func__);
+                return;
+        }
+        else
+        {
+                if(si2176_devp->si_cmd_reply.atv_status.pcl&&si2176_devp->si_cmd_reply.atv_status.dl)
+                        *status = FE_HAS_LOCK;
+                else
+                        *status = FE_TIMEDOUT;
+        }
+}
+
+static int si2176_analog_get_atv_status(struct dvb_frontend *dvb_fe, atv_status_t *atv_status)
+{
+		si2176_cmdreplyobj_t  *si_cmd_reply = &si2176_devp->si_cmd_reply;
+//get the tuner_status to give cvd to use
+	if(si2176_tuner_status(&si2176_devp->tuner_client, 0, si_cmd_reply)!=0)
+        {
+                printk("[si2176..]%s:the patch:get si2176 tuner status error.\n",__func__);
+                return -ERROR;
+        }
+        if(!atv_status)
+        {
+                printk("[si2176..]%s: null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        if(si2176_atv_status(&si2176_devp->tuner_client, SI2176_ATV_STATUS_CMD_INTACK_OK, &si2176_devp->si_cmd_reply)!=0)
+        {
+                pr_info("[si2176..]%s:get si2176 atv status error.\n",__func__);
+                return -ERROR;
+        }
+        else
+        {
+                atv_status->afc = si2176_devp->si_cmd_reply.atv_status.afc_freq;
+                atv_status->snr =si2176_devp->si_cmd_reply.atv_status.video_snr;
+                atv_status->atv_lock = si2176_devp->si_cmd_reply.atv_status.chl;
+                atv_status->audmode = si2176_devp->si_cmd_reply.atv_status.audio_demod_mode;
+                atv_status->std &= 0;
+                if(si2176_devp->si_cmd_reply.atv_status.color)
+                        atv_status->std |= V4L2_COLOR_STD_SECAM;
+                else
+                        atv_status->std = V4L2_COLOR_STD_PAL;
+                switch(si2176_devp->si_cmd_reply.atv_status.video_sys)
+                {
+                        case 0:
+                                atv_status->std |=V4L2_STD_B;
+                                break;
+                        case 1:
+                                atv_status->std |=V4L2_STD_GH;
+                                break;
+                        case 2:
+                                atv_status->std |=V4L2_STD_PAL_M;
+                                break;
+                        case 3:
+                                atv_status->std |=V4L2_STD_PAL_N;
+                                break;
+                        case 4:
+                                atv_status->std |=V4L2_STD_PAL_I;
+                                break;
+                        case 5:
+                                atv_status->std |=V4L2_STD_DK;
+                                break;
+                        case 6:
+                                atv_status->std |=V4L2_STD_SECAM_L;
+                                break;
+                        case 7:
+                                atv_status->std |=V4L2_STD_SECAM_LC;
+                                break;
+                        default:
+                                break;
+                }
+
+        }
+//it is the si2176_debug==2,the printk is valid
+		ssiprintk("[si2176..]%s afc %d,snr %d,atv lock %d audmode %d,std color %s audio %s.\n",__func__,atv_status->afc, atv_status->snr,
+                        atv_status->atv_lock, atv_status->audmode, v4l2_std_to_str(atv_status->std&0xff000000),v4l2_std_to_str(atv_status->std&0xffffff));
+        return 0;
+}
+
+static int si2176_analog_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+
+        struct analog_demod_ops *si2176_analog_ops = (struct analog_demod_ops*)ops;
+        if(!ops)
+        {
+                printk("[si2176..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        si2176_analog_ops->get_afc               = si2176_analog_get_afc;
+        si2176_analog_ops->get_snr               = si2176_analog_get_snr;
+        si2176_analog_ops->get_status          = si2176_get_status;
+	si2176_analog_ops->get_pll_status          = si2176_get_pll_status;
+        si2176_analog_ops->get_atv_status   = si2176_analog_get_atv_status;
+        return 0;
+}
+
+static struct aml_fe_drv si2176_analog_drv = {
+        .name    = "si2176_atv_demod",
+        .capability = AM_FE_ANALOG,
+        .id      = AM_ATV_DEMOD_SI2176 ,
+        .get_ops = si2176_analog_get_ops
+};
+
+static int __init si2176_tuner_init(void)
+{
+        int ret = 0;
+        si2176_devp = kmalloc(sizeof(struct si2176_device_s), GFP_KERNEL);
+
+        if(!si2176_devp)
+        {
+                pr_info("[si2176..] %s:allocate memory error,no enough memory for struct si2176_dev_s.\n",__func__);
+                return -ENOMEM;
+        }
+        memset(si2176_devp, 0, sizeof(struct si2176_device_s));
+
+        si2176_devp->clsp = class_create(THIS_MODULE,TUNER_DEVICE_NAME);
+        if(!si2176_devp->clsp)
+        {
+                pr_info("[si2176..]%s:create class error.\n",__func__);
+                kfree(si2176_devp);
+                si2176_devp = NULL;
+                return PTR_ERR(si2176_devp->clsp);
+        }
+        ret = class_create_file(si2176_devp->clsp, &class_attr_si2176_debug);
+        if(ret)
+                pr_err("[si2176]%s create si2176 class file error.\n",__func__);
+        ret = class_create_file(si2176_devp->clsp, &class_attr_si2176_autoLoadFirmware);
+        if(ret)
+                pr_err("[si2176]%s create autoLoadFirmware class file error.\n",__func__);
+        /*initialize the tuner common struct and register*/
+        aml_register_fe_drv(AM_DEV_TUNER, &si2176_tuner_drv);
+        aml_register_fe_drv(AM_DEV_ATV_DEMOD, &si2176_analog_drv);
+        printk("[si2176..]%s.\n",__func__);
+        return 0;
+}
+
+static void __exit si2176_tuner_exit(void)
+{
+        class_destroy(si2176_devp->clsp);
+        kfree(si2176_devp);
+        aml_unregister_fe_drv(AM_DEV_ATV_DEMOD, &si2176_analog_drv);
+        aml_unregister_fe_drv(AM_DEV_TUNER, &si2176_tuner_drv);
+        pr_info("[si2176..]%s: driver removed ok.\n",__func__);
+}
+
+MODULE_AUTHOR("kele.bai <kele.bai@amlogic.com>");
+MODULE_DESCRIPTION("si2176 tuner device driver");
+MODULE_LICENSE("GPL");
+
+fs_initcall(si2176_tuner_init);
+module_exit(si2176_tuner_exit);
+
diff --git a/drivers/amlogic/dvb_tv/si2176/si2176_func.c b/drivers/amlogic/dvb_tv/si2176/si2176_func.c
new file mode 100755
index 000000000000..359b0abe22d1
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2176/si2176_func.c
@@ -0,0 +1,4667 @@
+/*
+ * Silicon labs si2176 Tuner Device Driver
+ *
+ * Author: Bobby Yang <bo.yang@amlogic.com>
+ *
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/* Standard Liniux Headers */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+/* Local Headers */
+#include "si2176_func.h"
+
+
+#define I2C_TRY_MAX_CNT       3  //max try counter
+
+static unsigned int si2176_version = 29; //the old available firmware is 42
+static unsigned int delay_det=85;
+static unsigned int cvbs_amp=110;
+static unsigned int descramble=0;
+module_param(si2176_version, uint, 0664);
+MODULE_PARM_DESC(si2176_version, "\n si2176_version \n");
+module_param(delay_det, uint, 0644);
+MODULE_PARM_DESC(delay_det, "delay set freq time\n");
+module_param(cvbs_amp,uint,0644);
+MODULE_PARM_DESC(cvbs_amp, "\n si2176_cvbs_amp_out \n");
+module_param(descramble,uint,0644);
+MODULE_PARM_DESC(descramble, "\n descramble \n");
+
+
+
+static int __init si2176_tuner_parse_param(char *str)
+{
+        unsigned char *ptr = str;
+        printk("[si2176..] %s bootargs is %s.\n",__func__,str);
+        if(strstr(ptr,"b29"))
+                si2176_version = 29;
+        else if(strstr(ptr,"b30"))
+                si2176_version = 30;
+		else if(strstr(ptr,"b32"))
+				si2176_version = 32;
+		else if (strstr(ptr,"2177_30_b5"))
+				si2176_version = 33;
+        else
+                return -1;
+        return 0;
+}
+__setup("tuner=",si2176_tuner_parse_param);
+/* for lg tuner type */
+//b29 is the 3.2B7,it  support the sound_level
+static unsigned char firmwaretable_b29[] = {
+        0x04,0x01,0x01,0x00,0xEE,0xA4,0x94,0x17,
+        0x07,0x05,0x99,0x31,0x5B,0xB5,0x2D,0x90,
+        0x0F,0x76,0x41,0x39,0xE7,0x17,0xF3,0xA5,
+        0x05,0xBC,0x8B,0x61,0x0A,0xF1,0x3F,0x10,
+        0x22,0x52,0x13,0xFD,0xB0,0x7F,0x05,0x53,
+        0x05,0x01,0x7A,0x86,0x58,0x91,0xD6,0xA4,
+        0x22,0xC4,0xB5,0x5C,0xB8,0xD3,0x11,0xDE,
+        0x05,0x20,0x20,0x2A,0x43,0x44,0x4F,0x28,
+        0x22,0x87,0x6D,0x1E,0x90,0xE2,0xC6,0x02,
+        0x05,0x13,0x29,0x80,0x96,0x0D,0x29,0x15,
+        0x2A,0x7C,0x0C,0xA6,0x50,0xA0,0x62,0xD1,
+        0x05,0xCA,0x09,0xC0,0xA4,0x9D,0x4C,0x68,
+        0x2A,0xA6,0xC8,0x75,0x64,0x76,0x6D,0xC8,
+        0x05,0x81,0x1D,0x07,0x71,0x53,0x14,0xAC,
+        0x22,0x7B,0x4D,0x6D,0x86,0x15,0xEA,0xD0,
+        0x05,0x05,0xC3,0x11,0xEF,0x16,0x70,0x74,
+        0x2A,0x98,0xD8,0xBF,0xAF,0xC9,0xDA,0xE6,
+        0x05,0x7D,0xE7,0xA5,0x3F,0xA6,0x52,0xBC,
+        0x2F,0x1D,0x03,0x92,0x90,0x97,0xE5,0x39,
+        0x29,0x85,0x25,0xD5,0xF4,0xE8,0xED,0x7F,
+        0x0F,0xB0,0xB7,0xD4,0xEB,0x5B,0x69,0xD8,
+        0x05,0xDD,0x8B,0xFB,0xD2,0xD6,0x6F,0x0D,
+        0x22,0x4D,0xBE,0xBB,0xF9,0xAA,0x15,0x9B,
+        0x0F,0xB4,0x87,0xC2,0xDB,0x5C,0x7D,0xDB,
+        0x22,0xDD,0x93,0xED,0x25,0x7A,0xFC,0xB7,
+        0x05,0xE5,0xB1,0x9C,0xA4,0xC5,0x3E,0x3A,
+        0x27,0x6E,0x5F,0x8B,0xDF,0x77,0x16,0x1A,
+        0x27,0x89,0x03,0xDC,0x00,0x16,0x61,0xA0,
+        0x2F,0x05,0x92,0xA0,0x54,0xCC,0x06,0x96,
+        0x27,0x3F,0x94,0x85,0x36,0x55,0x40,0x85,
+        0x27,0xD2,0x2D,0x3E,0xAD,0x44,0x3D,0xFB,
+        0x2F,0x5B,0x25,0xF1,0xC5,0xD8,0x8B,0x7D,
+        0x27,0x55,0x85,0xAC,0x60,0x06,0xD4,0x22,
+        0x2F,0xB2,0x15,0x29,0xE3,0x5D,0xEE,0x3F,
+        0x2F,0x57,0xC6,0x33,0xA3,0xDA,0xED,0xF8,
+        0x27,0x00,0x45,0x66,0x8C,0x0B,0xB2,0xC6,
+        0x2F,0x66,0x5A,0xC7,0xEF,0x78,0x6B,0xB0,
+        0x2F,0x88,0xB4,0x2B,0xD9,0x93,0x22,0xFD,
+        0x27,0x86,0x29,0x2E,0xEA,0x16,0xB6,0x8D,
+        0x2F,0x65,0x8F,0x33,0xCF,0xB7,0xEE,0x70,
+        0x27,0xB2,0xD1,0xB5,0x3D,0xDE,0x07,0x4E,
+        0x27,0xBB,0x13,0xAC,0xF8,0xBC,0xAD,0x02,
+        0x2E,0x87,0x86,0xBD,0x81,0x07,0xB9,0xBD,
+        0x07,0x6F,0x55,0x74,0x26,0x02,0x87,0xD3,
+        0x2F,0xE4,0x16,0x64,0xC7,0xA0,0xCA,0x0E,
+        0x27,0xF3,0x00,0xEC,0x26,0xD5,0xB0,0x52,
+        0x2F,0x01,0xB2,0x7E,0xDF,0x2E,0x08,0x1F,
+        0x0F,0xDD,0xF7,0x94,0x2F,0xAE,0xE3,0xBE,
+        0x27,0x65,0xC4,0x5B,0x02,0xCB,0x22,0xE8,
+        0x2F,0x60,0x59,0xA1,0x48,0xE8,0xAF,0xD8,
+        0x2F,0xC3,0xA1,0x9F,0x82,0xD6,0x5F,0x30,
+        0x27,0xCF,0x75,0x5F,0x3F,0x63,0xF2,0x84,
+        0x2F,0x9E,0xEF,0xD3,0x4D,0x50,0xB2,0xC5,
+        0x27,0x4D,0xAA,0x58,0x3C,0x0C,0x8C,0x1B,
+        0x2F,0xE7,0x86,0xC6,0x35,0x71,0x8F,0x45,
+        0x27,0x0C,0x6A,0xE7,0x36,0xEA,0xC6,0x1B,
+        0x2F,0x18,0x86,0x76,0xD8,0x5E,0x90,0x29,
+        0x21,0x30,0x30,0x4D,0xF8,0xA9,0x19,0x3A,
+        0x0F,0x58,0xFF,0x4F,0x6A,0x07,0xE0,0x4D,
+        0x27,0x14,0x14,0x07,0x3A,0x86,0x98,0xDD,
+        0x2F,0x3C,0x67,0x4B,0x2A,0x4C,0x96,0xA2,
+        0x2F,0xF4,0x54,0x6C,0xDD,0xF6,0x5A,0x37,
+        0x27,0x80,0x77,0x8D,0x5C,0x8B,0xFF,0xAA,
+        0x2F,0x6F,0x2C,0x2D,0x2D,0x6A,0x90,0xFB,
+        0x2F,0x56,0x56,0x07,0x28,0xBB,0x3C,0xCF,
+        0x27,0x10,0xEE,0x04,0x36,0x67,0x61,0x53,
+        0x27,0xC1,0x8A,0x35,0xFB,0xB2,0xA6,0xF2,
+        0x27,0x74,0xD0,0x1E,0x66,0x38,0xB6,0x6A,
+        0x27,0x87,0x65,0xF9,0xF7,0x3C,0xC4,0x7B,
+        0x27,0x6E,0xCA,0x12,0xD8,0x5C,0x41,0x23,
+        0x2F,0x8D,0xA6,0x2E,0xAF,0xFF,0x18,0x0A,
+        0x2F,0xB7,0xEC,0xE7,0xFD,0xCA,0x91,0x37,
+        0x27,0x39,0xE0,0x6E,0x20,0x25,0xA3,0x77,
+        0x2F,0x4E,0xDC,0x4E,0xB6,0x00,0x40,0x3E,
+        0x22,0xC9,0xA3,0x33,0xB2,0x64,0xBE,0xAA,
+        0x0F,0xBB,0xC1,0x23,0x71,0x27,0xDD,0xC6,
+        0x0F,0xC4,0xEE,0xA9,0xBD,0x0C,0x8E,0x7F,
+        0x07,0x0C,0xE5,0xC9,0xE5,0x44,0x76,0xA8,
+        0x22,0x6C,0xB6,0x00,0x41,0xB8,0x7E,0x92,
+        0x07,0x60,0x69,0xB8,0x5E,0x61,0xAE,0x69,
+        0x0F,0xF2,0x06,0xEC,0xFC,0x2F,0xD4,0x37,
+        0x07,0x22,0x79,0x99,0xEC,0x08,0xD4,0x59,
+        0x07,0x1D,0xBF,0x96,0x14,0xB5,0x1C,0x15,
+        0x0F,0x5C,0xA5,0xDE,0x6A,0x2E,0xC5,0xFE,
+        0x0F,0x96,0x26,0x6D,0x1D,0x22,0xE7,0xE3,
+        0x05,0xA7,0x01,0x13,0x2A,0x36,0xC3,0xF5,
+        0x2A,0x5A,0x72,0x4B,0x87,0x71,0x59,0x87,
+        0x05,0x93,0xE2,0x4A,0x49,0xD7,0x6E,0x69,
+        0x23,0x1F,0x25,0x60,0x6E,0x1D,0x50,0x4A,
+        0x07,0x86,0xB1,0x82,0x29,0x46,0xBF,0x3E,
+        0x05,0x3E,0xD8,0x04,0x7D,0x4B,0xEB,0x68
+};
+static unsigned char firmwaretable_b2a[] = {
+        0x04,0x01,0x80,0x00,0x4F,0x6C,0x6E,0x8D,
+        0x05,0xE8,0x41,0xBC,0xAA,0xDE,0x9F,0xA8,
+        0x07,0xDA,0x3C,0x94,0xFE,0x7E,0x04,0x5E,
+        0x27,0xCE,0x85,0xDB,0x8E,0x2D,0x22,0x5D,
+        0x2F,0x6A,0xC3,0x98,0x3A,0xAC,0x8D,0x1B,
+        0x2F,0x00,0x1B,0x4B,0x28,0xB8,0xD5,0x08,
+        0x23,0xAF,0x05,0x51,0xAA,0xAA,0x0F,0x91,
+        0x07,0xF4,0x11,0xA5,0x63,0xCB,0x80,0x27,
+        0x0F,0xCE,0x8D,0xA5,0x9A,0xD9,0x76,0x3B,
+        0x07,0x60,0xAC,0x01,0x2E,0x9D,0x5D,0x67,
+        0x2F,0x48,0x05,0xE7,0xC7,0xBC,0x62,0x5A,
+        0x29,0x6E,0x34,0xF9,0xD2,0xB1,0x65,0x21,
+        0x0F,0x69,0xEA,0x15,0x06,0xF9,0x08,0xB4,
+        0x0F,0x32,0xD3,0x96,0x62,0x7E,0xCB,0xB9,
+        0x07,0x73,0x83,0x92,0xD0,0x86,0xD5,0xEB,
+        0x22,0x56,0xAA,0x71,0xBD,0xCD,0x94,0xC0,
+        0x07,0x98,0x3D,0xCB,0x55,0xD4,0x0D,0x01,
+        0x2A,0x19,0x2D,0xC5,0x75,0xE6,0x5B,0xF5,
+        0x0F,0xA3,0xB6,0x16,0x66,0x2C,0x2D,0xE9,
+        0x2D,0x15,0xAC,0x7D,0x40,0x0D,0xDD,0xE1,
+        0x07,0xAC,0x05,0x46,0xA4,0x66,0xA5,0xF8,
+        0x22,0x20,0x86,0xEA,0x6F,0x62,0x4E,0x40,
+        0x07,0x53,0x03,0xD4,0x02,0xF4,0x7C,0x8D,
+        0x22,0x6B,0x4E,0x4E,0x79,0xC8,0x98,0xB0,
+        0x0F,0x9D,0x54,0xF1,0x14,0xFD,0xDB,0x1A,
+        0x2A,0x48,0xCA,0xF0,0x1C,0xE3,0x9A,0xC2,
+        0x07,0x19,0x41,0xC1,0x9A,0x65,0xAA,0x60,
+        0x2A,0x68,0xAC,0xFA,0x4C,0x04,0x14,0x6A,
+        0x07,0x53,0xAE,0x26,0x69,0x7D,0x4A,0x9B,
+        0x22,0x53,0x0D,0x62,0x38,0x47,0x6C,0x58,
+        0x0F,0x8B,0x8F,0x82,0x3B,0x31,0x71,0x06,
+        0x2F,0xDD,0x6F,0x1D,0x37,0x07,0x1E,0x5A,
+        0x27,0x9B,0x4D,0x23,0x6B,0xD3,0x14,0x64,
+        0x27,0x28,0xB3,0xAE,0xCB,0x1D,0x86,0x93,
+        0x2D,0x43,0xEE,0xAC,0xB1,0xB0,0xCC,0xB0,
+        0x07,0x1B,0x29,0x37,0xA3,0xB1,0x0E,0x29,
+        0x2D,0xA0,0x43,0x5D,0x91,0x34,0x56,0x06,
+        0x0F,0xE9,0x13,0xCD,0x87,0xD6,0x8A,0x38,
+        0x27,0x9C,0xC7,0x0B,0x51,0xE7,0x5C,0xFD,
+        0x21,0x65,0xCA,0x28,0x91,0xD3,0x6D,0x98,
+        0x0F,0x82,0xC4,0x8E,0xAF,0x6C,0x99,0x27,
+        0x07,0x9E,0x4E,0xF4,0x07,0x79,0xF0,0xEC,
+        0x07,0x54,0x8E,0x4F,0x66,0x7D,0xE7,0xCB,
+        0x07,0x4B,0xEB,0xEA,0x08,0xDA,0xBC,0x04,
+        0x07,0xA5,0xE0,0x2C,0xC0,0x9A,0x9E,0x97,
+        0x27,0x0E,0x73,0x55,0xCA,0xB2,0x6A,0xCF,
+        0x2F,0xE7,0xE6,0x8B,0xD3,0x62,0x10,0x9F,
+        0x2B,0x53,0xFA,0x9A,0x56,0x20,0x6B,0xAD,
+        0x07,0xF5,0xAD,0x5C,0xBE,0xC8,0x07,0xDB,
+        0x2F,0x2B,0xA3,0x57,0xC7,0x62,0xC9,0x6D,
+        0x27,0x7A,0xD2,0x79,0x52,0xFC,0xE6,0x8B,
+        0x2F,0xED,0x27,0xD5,0x00,0xB5,0x3F,0xAB,
+        0x22,0x11,0xB2,0x02,0xDA,0x87,0x44,0x27,
+        0x07,0x98,0xAB,0x54,0xC2,0x87,0x50,0x45,
+        0x2F,0xF1,0x35,0x7E,0x4D,0x04,0x75,0x76,
+        0x24,0x4C,0x0E,0x5F,0xFB,0x11,0x68,0x3F,
+        0x07,0x0B,0x38,0x8D,0x69,0x4B,0x9C,0x99,
+        0x22,0x67,0x58,0x07,0xCC,0x6E,0xD3,0x3C,
+        0x07,0x51,0xFB,0x8F,0x6A,0x47,0x8D,0x03,
+        0x22,0x89,0xB0,0x19,0x79,0xF5,0xCE,0xED,
+        0x07,0x68,0x38,0xDF,0x03,0xFB,0x8E,0x4B,
+        0x0F,0x34,0xF9,0x4E,0xE6,0x17,0x38,0x0E,
+        0x07,0x7D,0xFE,0x10,0x77,0x79,0xE4,0x52,
+        0x2D,0xA0,0x54,0x49,0x83,0x4C,0xAB,0xA9,
+        0x0F,0x21,0x21,0x25,0xDD,0x32,0xDE,0x5C,
+        0x0F,0xC2,0x7F,0x5A,0xED,0xB7,0x1E,0x34,
+        0x07,0x0A,0x03,0x79,0x52,0x8C,0xEB,0x31,
+        0x22,0x83,0x1A,0x86,0x72,0xF5,0xBD,0xC0,
+        0x0F,0x7E,0x4C,0xCA,0xC5,0x04,0x3F,0xCB,
+        0x2A,0x05,0x81,0x9E,0x1F,0x7F,0x31,0x67,
+        0x07,0xCD,0xEB,0x9C,0xF4,0x61,0x3D,0x68,
+        0x2A,0x1C,0x3D,0x27,0x2E,0xDF,0x33,0x87,
+        0x07,0x86,0x10,0xA3,0xBE,0x5C,0x9C,0x13,
+        0x07,0xF2,0xAA,0x43,0xDE,0xB0,0x44,0xAC,
+        0x0F,0xB6,0x4C,0xBA,0xEC,0xDD,0xC2,0x51,
+        0x2A,0xE5,0x9C,0xF1,0x75,0x97,0xA2,0x3B,
+        0x0F,0x2E,0x0E,0x26,0x9D,0xEB,0x50,0xBC,
+        0x27,0xAA,0xE7,0xD6,0x3F,0x70,0x41,0x69,
+        0x27,0xFF,0x00,0x3D,0x50,0x6E,0x68,0xF8,
+        0x23,0x12,0x30,0xB0,0x34,0x89,0xD9,0x9C,
+        0x0F,0x96,0xA7,0x13,0xCE,0x2A,0xB7,0x50,
+        0x27,0x5E,0x3E,0x64,0xCE,0xE9,0x97,0x56,
+        0x29,0xFB,0xE3,0xFC,0xBF,0xE5,0x32,0xEB,
+        0x0F,0x2C,0xF4,0x8D,0x08,0x82,0x82,0x2A,
+        0x2A,0x27,0xED,0xC0,0x18,0x45,0x94,0x74,
+        0x07,0x51,0x91,0x34,0x60,0x01,0x7E,0x76,
+        0x22,0x59,0x15,0xD6,0x96,0x41,0xA8,0x81,
+        0x0F,0x97,0x64,0xBD,0x4D,0x0B,0xED,0x51,
+        0x27,0x5B,0xED,0x76,0xD1,0xC9,0xAF,0x11,
+        0x2C,0x04,0xDE,0x5E,0x3D,0xB9,0x1F,0x3B,
+        0x07,0x16,0x63,0x97,0xEE,0x2B,0x0A,0x13,
+        0x22,0xB7,0x0D,0xEC,0x30,0x83,0xEC,0xD1,
+        0x07,0x84,0xDD,0x1D,0xBE,0xC9,0x2F,0x8C,
+        0x2A,0xC6,0xF9,0x0E,0x27,0x86,0xE9,0x5F,
+        0x07,0x87,0xED,0x70,0x92,0x00,0x7E,0x8F,
+        0x0F,0xA0,0x0F,0xCD,0x31,0x14,0xE1,0x17,
+        0x0F,0x96,0x59,0xAA,0x51,0x5D,0xEF,0x93,
+        0x25,0x5E,0xB7,0xFA,0xC8,0xF9,0x5A,0x11,
+        0x07,0x46,0x69,0x29,0xAD,0x1A,0xB4,0x86,
+        0x2F,0xD8,0x24,0xE2,0xFF,0xB0,0xE2,0x83,
+        0x21,0x39,0x12,0x74,0x77,0x0F,0x4B,0x81,
+        0x07,0xFB,0x5E,0x43,0xBF,0xCE,0xCC,0x18,
+        0x0F,0x0B,0x8D,0x81,0xD3,0x72,0x88,0xAB,
+        0x0F,0xF6,0x60,0xEF,0x2B,0x9E,0x6F,0x1A,
+        0x0F,0x9A,0x0F,0xCB,0xD3,0x14,0x62,0xFB,
+        0x07,0x1F,0x4C,0xFF,0x52,0x98,0x8E,0x2D,
+        0x0F,0xFD,0xEE,0xDC,0xAA,0x97,0x5B,0x51,
+        0x07,0x50,0x77,0xA6,0x32,0xDF,0xEF,0x32,
+        0x0F,0x2D,0x26,0x1C,0x4F,0xBF,0x1C,0xE2,
+        0x07,0x0F,0x55,0x9C,0xDD,0x71,0xDE,0xE7,
+        0x0F,0x08,0xF6,0xD9,0xD4,0xFA,0xCF,0x6F,
+        0x0F,0x46,0xB6,0xC0,0x55,0x62,0xBC,0x82,
+        0x0F,0xF2,0x04,0xF8,0x20,0x7E,0x75,0x18,
+        0x07,0x73,0xF2,0x66,0x0E,0x79,0xEC,0xD9,
+        0x27,0x07,0x77,0x6B,0x0F,0x81,0x08,0x59,
+        0x27,0x14,0x97,0x56,0x7D,0x61,0xA8,0x85,
+        0x2F,0x1D,0x9D,0xB9,0x9E,0x70,0x47,0x1D,
+        0x2F,0x5E,0xC4,0xBC,0xA0,0x21,0x6E,0xCC,
+        0x2F,0x5C,0x64,0xDF,0x1A,0x93,0x25,0x88,
+        0x2F,0xA7,0xEC,0x6B,0x0B,0x07,0x0E,0xAB,
+        0x27,0x65,0x0B,0x1A,0xC3,0x79,0x07,0x1F,
+        0x21,0xD4,0xF1,0xF2,0xEC,0xDE,0xA9,0x6B,
+        0x05,0x1A,0x1D,0x28,0x76,0xA0,0xF0,0x6C,
+        0x2F,0x73,0x6A,0x87,0xF2,0xDA,0xAD,0x09,
+        0x2F,0xCC,0x2A,0xFE,0xCD,0x92,0x13,0x15,
+        0x2F,0xA3,0x2A,0x18,0xB2,0xF9,0x3C,0x84,
+        0x27,0x2B,0x28,0x2C,0xBF,0x71,0x42,0x6A,
+        0x27,0x07,0xF0,0xAF,0xC6,0x2A,0x13,0x3E,
+        0x2F,0x08,0xC2,0xD6,0x1E,0x99,0xE7,0xA6,
+        0x27,0xEE,0x35,0xB1,0x20,0xFD,0x45,0x87,
+        0x27,0xE4,0xE4,0xEB,0xD8,0xC6,0xB6,0xB3,
+        0x27,0xF8,0x2F,0xDE,0x1E,0x4F,0x60,0x43,
+        0x27,0xA8,0xC6,0xE0,0x01,0x14,0x83,0x5E,
+        0x27,0xD5,0x15,0x06,0xCD,0x10,0xEC,0x6B,
+        0x2F,0x90,0x7B,0x98,0x36,0xB1,0xBD,0x90,
+        0x2F,0xD2,0x76,0x50,0x1A,0xE6,0x0A,0xB8,
+        0x2F,0xBB,0x78,0x91,0xAB,0xC5,0x98,0xEE,
+        0x27,0x5E,0x44,0x77,0xBD,0xE4,0xE6,0x7B,
+        0x2F,0x68,0x76,0x29,0x61,0x3C,0x26,0x4C,
+        0x27,0x0D,0x32,0x4E,0xE5,0xBD,0xE2,0x53,
+        0x29,0x49,0x1C,0xBC,0x35,0x03,0x3B,0xDF,
+        0x07,0x21,0x4F,0xA5,0xD3,0x77,0x03,0x8F,
+        0x2D,0x92,0x23,0xA6,0x6C,0xB5,0x5C,0x2B,
+        0x07,0x8E,0x90,0x98,0x3E,0x41,0x32,0x3F,
+        0x25,0xCE,0xF4,0x39,0x82,0x53,0xE1,0x4B,
+        0x0F,0x39,0xB8,0x29,0xC2,0xB4,0x18,0x66,
+        0x2F,0x01,0xAD,0x51,0xFA,0xAD,0xFF,0x34,
+        0x27,0xC6,0xFD,0x7B,0x4B,0x49,0x43,0x5E,
+        0x2F,0x1E,0x98,0xE8,0x0B,0xD5,0x1D,0xB9,
+        0x2F,0x92,0x25,0xF6,0x89,0x29,0xBE,0x32,
+        0x26,0x85,0xB7,0x59,0x20,0x0C,0x21,0xB2,
+        0x07,0x93,0xC6,0xDA,0x6C,0xF1,0x28,0x76,
+        0x27,0x85,0xB5,0x62,0x69,0x62,0x94,0x89,
+        0x29,0x8C,0x4A,0x8A,0x64,0x69,0x2C,0xFB,
+        0x07,0x75,0xF4,0x79,0xE2,0xA7,0xEA,0x8C,
+        0x2C,0xB1,0xC2,0x7C,0xE3,0x5D,0x81,0x56,
+        0x0F,0x25,0xFB,0xC2,0x92,0x5C,0x67,0xF1,
+        0x27,0xD2,0xC8,0x18,0xF5,0x70,0xB3,0x91,
+        0x2F,0x42,0xDE,0x50,0xF8,0x4D,0x89,0xAF,
+        0x2F,0x20,0x7B,0x34,0x7A,0x2F,0x49,0x65,
+        0x27,0xFA,0xC8,0x4A,0x06,0x91,0x47,0x17,
+        0x27,0xBB,0x53,0xCE,0xE5,0x9D,0x4D,0xBB,
+        0x2F,0x92,0x3D,0x53,0x82,0x1C,0xF0,0x96,
+        0x21,0x71,0x87,0x0A,0x60,0xA7,0x9D,0xCB,
+        0x07,0x7A,0x46,0x0C,0x2E,0x9A,0xC4,0x24,
+        0x2A,0xE3,0xCE,0x5E,0x17,0x6D,0xAA,0x52,
+        0x0F,0xDD,0xB5,0x7B,0xEE,0x5B,0xE1,0xF4,
+        0x2F,0x69,0x2E,0x5D,0x7C,0x2D,0xCC,0xE3,
+        0x21,0x18,0x09,0xEF,0x26,0x3C,0x72,0xDB,
+        0x0F,0xFC,0x23,0x7E,0x61,0x8B,0xAD,0x1B,
+        0x0F,0x40,0x67,0x73,0x1D,0xCE,0xD0,0x2C,
+        0x0F,0x53,0x07,0x45,0x63,0x9A,0xA7,0x17,
+        0x22,0x0F,0x79,0x41,0x58,0x43,0xF8,0x6B,
+        0x07,0xD4,0x06,0x70,0x5A,0xC0,0x63,0x2A,
+        0x0F,0x10,0x74,0xF0,0x80,0x6F,0x1F,0x2D,
+        0x27,0xAA,0xBB,0x07,0xAE,0xD9,0x73,0xA5,
+        0x2F,0x1B,0x21,0x9E,0xD9,0x19,0xDC,0x0A,
+        0x2F,0x31,0xB5,0x3C,0xB5,0xE9,0xBE,0xDB,
+        0x27,0xAB,0x63,0xE9,0xDF,0x2D,0xD5,0x37,
+        0x27,0x1C,0xB4,0x06,0x31,0x0C,0xAF,0xF1,
+        0x2F,0xAF,0x37,0x12,0xBE,0x56,0x3F,0x31,
+        0x2F,0x79,0x92,0x0D,0x8A,0x06,0xB8,0xF2,
+        0x27,0x55,0x16,0x59,0xBD,0xD8,0x9C,0xC8,
+        0x2F,0x3D,0x4F,0x72,0x78,0xC0,0x6D,0xEA,
+        0x2E,0xAD,0x2D,0xB3,0x3F,0x1E,0x39,0xA5,
+        0x0F,0xD0,0x2C,0x21,0x64,0x01,0x0C,0x85,
+        0x27,0x77,0x3A,0x75,0xAD,0x8F,0x26,0x79,
+        0x2F,0xDE,0x65,0x36,0x09,0xEC,0xB1,0x04,
+        0x2F,0xFA,0xEF,0x5A,0x19,0x67,0xE8,0x0E,
+        0x27,0x3C,0x71,0x25,0x59,0x78,0x4B,0x41,
+        0x0F,0xF3,0x13,0xD7,0xA2,0xDA,0x18,0x1D,
+        0x27,0x36,0x9A,0x7B,0x8D,0xD0,0x3C,0x24,
+        0x23,0x23,0xAB,0x1D,0x01,0xD9,0xA6,0xEB,
+        0x07,0xB1,0xCF,0x2B,0x8B,0x99,0x4F,0x1F,
+        0x27,0x95,0xF3,0x6C,0xF5,0x12,0xB3,0xE6,
+        0x2F,0x64,0xB9,0xB4,0xA1,0x13,0x60,0x16,
+        0x24,0xD3,0x65,0x46,0xF0,0xBC,0x11,0x1E,
+        0x0F,0xB4,0xF9,0xCD,0x17,0x5E,0xC8,0x88,
+        0x27,0xD6,0xD4,0x96,0xB3,0x96,0xD8,0x8F,
+        0x27,0x6A,0xC7,0xAC,0x01,0x0A,0xF0,0xDF,
+        0x0F,0xD4,0x23,0x5C,0x61,0xC1,0x24,0x73,
+        0x27,0xF9,0x13,0xA6,0x86,0xB5,0x6B,0x65,
+        0x2C,0xAD,0xA9,0x85,0xDF,0xA6,0xD3,0x48,
+        0x0F,0x97,0x73,0x4C,0x38,0xCE,0xD6,0xC5,
+        0x24,0x8C,0x19,0x31,0xE0,0xEB,0xD2,0xAE,
+        0x07,0x73,0x8C,0x00,0x99,0xAF,0x7F,0xC6,
+        0x0F,0x0F,0x66,0x4A,0xE4,0xB8,0x90,0x0F,
+        0x25,0xEC,0xF2,0xA1,0xBC,0xB4,0x1F,0xC9,
+        0x07,0x63,0x78,0xD1,0xFF,0x41,0xDF,0x40,
+        0x07,0x65,0x61,0x3A,0x73,0x09,0x0D,0xDD,
+        0x0F,0x9A,0xD8,0x72,0x19,0xDA,0x01,0x30,
+        0x2F,0x6D,0x8C,0x69,0x43,0x2C,0xB0,0x16,
+        0x24,0xE5,0x5E,0x9F,0x40,0xB0,0x4E,0x2C,
+        0x0F,0xE6,0xCC,0x32,0xD7,0xD6,0x78,0x5D,
+        0x2F,0x80,0x46,0xD4,0x71,0x87,0x51,0x87,
+        0x21,0x77,0xAB,0x08,0x15,0x97,0xF0,0x9F,
+        0x07,0xE0,0x28,0x57,0x92,0x35,0xDC,0x1F,
+        0x27,0xE0,0xA2,0xDA,0xFB,0x29,0x97,0x4C,
+        0x2F,0xF5,0xC2,0x21,0xBC,0xBD,0x2A,0x5A,
+        0x27,0xE1,0xAE,0x22,0x7C,0xD9,0x45,0xEC,
+        0x2F,0x8B,0xCB,0x74,0x7C,0x01,0x87,0x0D,
+        0x27,0x55,0x76,0x2B,0x6C,0x32,0xA3,0xBC,
+        0x2F,0x2A,0x87,0xD1,0xAE,0x0B,0xA5,0x96,
+        0x27,0x66,0x57,0xB8,0x4B,0xBD,0x60,0xCC,
+        0x2D,0x24,0xAC,0x84,0x32,0x8E,0xE6,0xA7,
+        0x07,0x6F,0x67,0xBC,0x43,0x6A,0x95,0x10,
+        0x22,0x3E,0x4C,0xCD,0x1D,0x31,0x88,0xF0,
+        0x07,0x82,0x8F,0x95,0x61,0x44,0x98,0xFA,
+        0x2E,0x2C,0x7A,0x23,0x24,0x97,0x3D,0x8E,
+        0x07,0xF8,0xB8,0xD4,0xFF,0x33,0x06,0xA5,
+        0x07,0xCA,0xEA,0xA7,0x38,0xC5,0x06,0x3C,
+        0x0F,0xA9,0x1D,0x9A,0x1E,0x69,0xF8,0x30,
+        0x0F,0xFD,0x6C,0xED,0xB2,0x92,0xDB,0x15,
+        0x07,0x75,0x44,0xBD,0xC5,0x47,0x93,0x2C,
+        0x07,0x53,0xD2,0x37,0xAF,0x7F,0x07,0xF9,
+        0x2F,0xDD,0x6A,0xD2,0xBA,0xAD,0xD3,0xA0,
+        0x21,0x03,0x81,0x14,0xE9,0x65,0x73,0xFD,
+        0x07,0xAA,0xCD,0x54,0x0A,0x0F,0xE1,0xD5,
+        0x0F,0x94,0xD3,0x81,0xD2,0x84,0xA3,0xCE,
+        0x27,0xD1,0xB0,0x0B,0xAD,0xF0,0x7E,0xD3,
+        0x2F,0x0C,0x4C,0x01,0x84,0x13,0x4A,0xED,
+        0x27,0x23,0x80,0x0F,0x5B,0xE1,0xBE,0x78,
+        0x2F,0x70,0xFF,0x5A,0xB7,0xD6,0x08,0xBE,
+        0x27,0x01,0xF1,0x72,0x93,0x74,0x36,0xDB,
+        0x23,0x63,0xB1,0xB4,0xD9,0x40,0x82,0xC8,
+        0x07,0x04,0xF6,0xD8,0xDC,0x53,0xC3,0xF0,
+        0x27,0x51,0x67,0x87,0x74,0x63,0xEC,0xAE,
+        0x2A,0x09,0xCE,0x78,0xAC,0x58,0xAC,0x1D,
+        0x0F,0xF3,0x3B,0xB3,0x69,0x11,0xA2,0x65,
+        0x27,0x09,0x0E,0x70,0xEC,0x84,0x5C,0x04,
+        0x27,0x1E,0x75,0x63,0xEE,0x39,0x6F,0xAA,
+        0x24,0x16,0xCB,0xA5,0x4C,0xC5,0xAE,0x76,
+        0x07,0x2D,0x27,0xDD,0xB7,0x12,0x88,0x03,
+        0x26,0x52,0x85,0x4A,0xEB,0x7E,0x56,0x15,
+        0x07,0x1D,0x4B,0x2B,0x8B,0x09,0x0A,0x8E,
+        0x27,0x60,0x48,0xE7,0xE1,0xAD,0xF0,0xED,
+        0x27,0xCD,0x98,0x39,0xB4,0x52,0xDA,0x77,
+        0x27,0xA1,0x40,0x67,0xAC,0x95,0xBA,0x23,
+        0x27,0xA6,0x26,0x36,0xDC,0x9F,0x16,0xA8,
+        0x27,0xE9,0xD9,0xAB,0xCE,0xED,0x65,0x80,
+        0x24,0x13,0x86,0x27,0xC1,0x78,0xD3,0xDF,
+        0x07,0x1B,0x9A,0x4C,0x88,0x46,0xBE,0xCF,
+        0x27,0x03,0xE5,0xBA,0x57,0x12,0x89,0x34,
+        0x27,0xB5,0xD3,0xE6,0x89,0xAD,0xDD,0xF8,
+        0x2F,0xA0,0x96,0xCC,0xE5,0xA9,0xA3,0x0F,
+        0x27,0x09,0x02,0x9F,0x6C,0x1A,0x60,0x3A,
+        0x2F,0x04,0x4F,0x94,0xE2,0xF3,0xAC,0x2D,
+        0x23,0x6F,0x29,0x6B,0x63,0x52,0x57,0xB6,
+        0x0F,0xC3,0xBC,0xAB,0x81,0xE4,0x23,0x33,
+        0x0F,0x3B,0xC3,0x09,0xF6,0xB5,0x5D,0x3D,
+        0x07,0x85,0x0B,0x9D,0xBB,0xAC,0x50,0x3B,
+        0x2E,0x1E,0x79,0x38,0xEB,0x33,0x51,0xA5,
+        0x07,0x4B,0x25,0xA2,0x90,0x14,0x92,0xE4,
+        0x2F,0x66,0x44,0x37,0x8A,0x3E,0x5E,0x85,
+        0x2F,0xD4,0x3C,0x1C,0x70,0xC0,0xCF,0x74,
+        0x27,0x82,0xB1,0x2F,0x36,0x66,0xAA,0xDE,
+        0x27,0x88,0x2C,0xC3,0x67,0x3B,0xE2,0xB5,
+        0x2F,0x22,0x37,0x2A,0xD5,0x68,0x0E,0x12,
+        0x22,0x8A,0x34,0xD1,0xDE,0x7F,0x62,0x2B,
+        0x0F,0x8D,0x83,0xF6,0x50,0x68,0x93,0x24,
+        0x2F,0x15,0x96,0x8A,0xB9,0x1D,0x6E,0xCC,
+        0x27,0xE9,0x79,0x69,0x4E,0xBA,0x34,0x9E,
+        0x27,0xB3,0x07,0x84,0xB9,0x53,0x44,0xCE,
+        0x2F,0x6C,0x6A,0xC7,0x4B,0xA7,0x66,0x09,
+        0x2F,0xDE,0xDC,0xB3,0x06,0x65,0xD3,0xFC,
+        0x2A,0x45,0x0D,0xB4,0x32,0x38,0x47,0xF4,
+        0x07,0x89,0xCE,0x76,0x31,0xE7,0xB1,0xBA,
+        0x27,0xBF,0x76,0x59,0x16,0xA1,0x32,0x86,
+        0x27,0xE8,0x59,0x45,0x54,0x74,0xF3,0x01,
+        0x2F,0x8B,0x2D,0x52,0xA7,0xD7,0xF9,0x77,
+        0x2A,0xC3,0x00,0x65,0xD0,0xDB,0xCA,0x29,
+        0x07,0xD7,0x5D,0x9E,0x0D,0x54,0x20,0x6D,
+        0x27,0xC0,0xE7,0x52,0xCD,0x36,0x8A,0x8A,
+        0x21,0x77,0x8A,0x8E,0x8A,0xE3,0xDF,0x92,
+        0x07,0xDE,0x17,0x4F,0x35,0xBB,0x03,0x81,
+        0x25,0xF2,0x86,0x11,0x3C,0x71,0xDD,0x32,
+        0x07,0xD5,0xF5,0x0D,0xEE,0x87,0x67,0x81,
+        0x23,0x04,0xD1,0x8B,0x6D,0x6B,0xE1,0x23,
+        0x07,0x1A,0x50,0x4D,0x28,0x7C,0x33,0xC7,
+        0x27,0x22,0x03,0x29,0x3E,0x77,0x20,0x24,
+        0x27,0x3F,0xE6,0x75,0x32,0x13,0x7D,0x65,
+        0x24,0x34,0xB7,0xCE,0xE1,0x93,0x10,0xC9,
+        0x07,0xF8,0xF7,0xCF,0x00,0xCD,0x84,0xD3,
+        0x0F,0x43,0x4B,0x43,0x1A,0x07,0x1B,0x24,
+        0x27,0x37,0x57,0x3D,0x2D,0xDF,0x12,0x4D,
+        0x27,0x7D,0x40,0x45,0x47,0xC9,0x32,0x9E,
+        0x26,0x70,0xA4,0x84,0x6B,0x5D,0xC7,0xE3,
+        0x07,0xF6,0xC6,0xF5,0xE0,0x72,0x95,0x59,
+        0x2F,0x4F,0x2F,0xB1,0x75,0x5B,0x7F,0x45,
+        0x27,0xF3,0xC1,0xDE,0x19,0xF3,0xE1,0x99,
+        0x22,0x1A,0x3E,0x65,0x58,0xD0,0xA3,0x45,
+        0x07,0xFB,0x0A,0x95,0x96,0x8A,0x73,0x1B,
+        0x27,0xAD,0x70,0xA8,0xA4,0xBE,0x99,0x7A,
+        0x27,0x50,0x10,0x42,0x15,0xE9,0x94,0xDB,
+        0x2F,0x91,0xCD,0xB6,0x22,0x02,0x58,0x8D,
+        0x27,0xBA,0x29,0xB3,0x6D,0x3D,0x26,0x54,
+        0x2F,0xFC,0x7D,0xDE,0x88,0xE8,0xCE,0x49,
+        0x2F,0x40,0xFA,0x39,0x62,0x98,0x57,0x83,
+        0x27,0x1E,0xFE,0xCE,0x1E,0xB2,0xF1,0x5A,
+        0x27,0x2E,0x58,0x51,0x63,0x3E,0xD8,0x93,
+        0x27,0x99,0x8F,0x41,0x53,0xCE,0x2C,0x0E,
+        0x27,0x6E,0x10,0x81,0x47,0xC6,0x1D,0xCB,
+        0x27,0x3C,0x14,0x02,0x50,0x47,0x15,0xED,
+        0x2A,0x64,0x79,0x96,0x67,0x4E,0xCF,0x3D,
+        0x0F,0xE1,0x2D,0x5D,0x8E,0xCB,0x92,0xF1,
+        0x2F,0x35,0xD9,0xF1,0x6A,0x47,0xA7,0x0F,
+        0x27,0x71,0xB5,0x04,0xD5,0x31,0xAA,0x03,
+        0x27,0x7A,0x14,0x7B,0xE9,0x80,0xBA,0x2A,
+        0x25,0xAF,0xD9,0x39,0x18,0xF6,0x5E,0x41,
+        0x07,0x00,0x64,0xF6,0xD7,0x41,0xC2,0x33,
+        0x2F,0xD2,0xCA,0x8F,0xC5,0xFA,0x3B,0x13,
+        0x2F,0x3E,0x8B,0x3B,0x24,0x72,0xF9,0x06,
+        0x27,0x9D,0x50,0x4E,0xBA,0xC7,0x3D,0x3E,
+        0x23,0xF0,0x63,0xAD,0x06,0x77,0x3B,0x81,
+        0x07,0x96,0x0E,0xAB,0x19,0xA5,0x65,0xA2,
+        0x0F,0x9F,0x10,0x33,0x9E,0x9B,0xC2,0xF6,
+        0x07,0x89,0xB4,0x94,0xDD,0xD8,0x80,0xB4,
+        0x27,0x74,0xD6,0x7E,0x77,0x02,0x50,0xDB,
+        0x27,0x5F,0x5A,0x68,0xC0,0x17,0xB2,0xFB,
+        0x27,0xDF,0x4A,0xCD,0xEB,0x17,0x41,0x2E,
+        0x2F,0x60,0x09,0xDE,0xDB,0xD3,0x37,0xE7,
+        0x25,0x5B,0xB8,0xBE,0x72,0xC1,0xF7,0xC3,
+        0x07,0xBC,0xB5,0x39,0xB1,0x9D,0xF8,0xE9,
+        0x2F,0x3A,0x0D,0x45,0xAE,0xFF,0x11,0x79,
+        0x29,0xEB,0x8E,0x38,0x91,0xD9,0x80,0x95,
+        0x0F,0x14,0x37,0xE5,0x2F,0x50,0xE3,0xCE,
+        0x2F,0xC4,0xEB,0x6E,0xD4,0xE8,0x31,0x24,
+        0x2F,0x78,0xB7,0xB8,0x2A,0xB1,0xAC,0xA8,
+        0x23,0x41,0xBA,0x85,0x50,0x52,0x5E,0xDE,
+        0x0F,0x86,0x86,0x0D,0xDF,0x67,0x5A,0xE9,
+        0x2F,0x27,0xA2,0x53,0xB2,0xCF,0x54,0x33,
+        0x27,0x03,0x05,0x32,0x4A,0xA6,0xC0,0x1B,
+        0x27,0xDC,0xA1,0xC7,0xA4,0xF0,0xFD,0x6D,
+        0x23,0xEF,0x74,0x8A,0xAA,0x2F,0x93,0x18,
+        0x0F,0xAF,0x86,0x23,0xAF,0xB9,0x06,0xCC,
+        0x0F,0x7D,0xCF,0xA6,0x5A,0x5E,0xFC,0x4E,
+        0x0F,0x8C,0x48,0xD3,0xCE,0x97,0x9F,0xFC,
+        0x07,0x06,0x01,0x82,0xDB,0x73,0x18,0x7F,
+        0x07,0x1C,0xE4,0x91,0x17,0xB9,0x94,0x53,
+        0x2F,0x53,0xD3,0x45,0xC5,0x5D,0x27,0xD7,
+        0x27,0x99,0xEC,0x71,0xF0,0x2D,0x8B,0x5A,
+        0x2F,0x45,0x35,0xEC,0xDC,0x3B,0xED,0x68,
+        0x2F,0x96,0x1D,0x38,0x2A,0x5F,0x25,0xB0,
+        0x2F,0xBC,0x5B,0x09,0x62,0xC3,0x70,0x5D,
+        0x2F,0x5E,0x89,0xF8,0xF7,0x1B,0xB6,0xF0,
+        0x2F,0x8C,0x85,0x0A,0xF0,0x45,0x0E,0x1C,
+        0x2F,0x61,0x41,0x4A,0x5F,0x52,0x0E,0xE3,
+        0x2F,0xBE,0x57,0x5E,0x59,0xC3,0x62,0x29,
+        0x27,0xBD,0x67,0x4F,0x7D,0xC7,0xE3,0xB8,
+        0x2F,0xCD,0x73,0xFD,0x9B,0xD4,0x48,0x49,
+        0x29,0xE7,0x3F,0x70,0x88,0xA2,0x7C,0xAD,
+        0x0F,0x69,0x90,0x85,0x19,0x26,0xFE,0x1E,
+        0x27,0xE7,0x4C,0x20,0x0E,0x78,0x71,0xD0,
+        0x27,0xD3,0xEC,0x39,0xA7,0x49,0xDC,0x0A,
+        0x2F,0xFE,0x60,0x0C,0x94,0x7A,0x5E,0xAC,
+        0x27,0xE6,0xB2,0xDE,0x2E,0xA7,0x6A,0x82,
+        0x27,0x99,0x07,0x28,0xA8,0xC9,0xD0,0x7D,
+        0x2F,0xFB,0xF1,0x4A,0x82,0x1D,0x3B,0x3C,
+        0x2F,0xAA,0x7E,0x91,0x08,0x19,0x40,0x45,
+        0x2F,0x9A,0x14,0x9E,0xA1,0xD0,0xD9,0x89,
+        0x27,0xE9,0x9A,0x5A,0x1A,0x2A,0x73,0x10,
+        0x27,0x0C,0xB6,0x1F,0x37,0xD6,0x6E,0x4A,
+        0x27,0x7B,0x91,0x11,0x13,0x42,0xBA,0x77,
+        0x27,0xC0,0xA7,0xF5,0x56,0xC1,0x48,0xDD,
+        0x27,0xCE,0xF9,0xFE,0x31,0x70,0x5D,0x77,
+        0x2F,0x6E,0xE9,0x4E,0x65,0x7F,0x39,0xEB,
+        0x07,0x7D,0x9F,0xF3,0x29,0xE4,0x44,0x7D,
+        0x07,0x72,0xCF,0xB3,0xC1,0xA4,0x41,0x9E,
+        0x0F,0xAF,0xD4,0x2A,0x79,0x05,0x56,0x17,
+        0x2F,0x3A,0xCE,0x89,0x31,0xCB,0x4F,0x29,
+        0x2D,0xA0,0xDC,0x67,0x3A,0xA2,0x81,0xF6,
+        0x0F,0xE3,0x9D,0xAF,0xF7,0x53,0x5B,0xBB,
+        0x07,0x40,0xD5,0xCD,0x53,0xDD,0x36,0xF5,
+        0x07,0xE3,0xA8,0xA6,0x8B,0xA7,0xFF,0xBD,
+        0x27,0xEF,0xBB,0x40,0xBC,0x48,0xF6,0x17,
+        0x25,0x78,0xE9,0x5B,0x1C,0xF1,0xBD,0xBA,
+        0x07,0xAD,0x46,0x1A,0x9C,0xAA,0x09,0x56,
+        0x07,0x8C,0xD4,0xDD,0xE2,0x48,0xF9,0x08,
+        0x0F,0x2C,0x9F,0x2B,0x98,0x79,0x60,0xF2,
+        0x27,0xE5,0xE8,0xB1,0x60,0xC3,0xF9,0xCC,
+        0x2D,0x2D,0x6E,0x7F,0x94,0x00,0x25,0x92,
+        0x0F,0x35,0xD0,0x2B,0xC5,0xAD,0x91,0xE5,
+        0x07,0xBC,0x7C,0xFB,0xE7,0xE4,0x5C,0x9C,
+        0x0F,0xC0,0x76,0x99,0x7E,0x78,0x5F,0xE2,
+        0x2F,0x4B,0xD0,0x82,0xC2,0x13,0x32,0xB2,
+        0x27,0x2A,0x34,0xDA,0x57,0x44,0x20,0x2A,
+        0x27,0x0B,0xC2,0x4E,0xCD,0x77,0xB0,0x0A,
+        0x21,0x95,0x92,0x63,0x00,0x2E,0x07,0x48,
+        0x0F,0x5C,0x08,0x45,0x47,0x05,0xAD,0xBB,
+        0x27,0x2C,0x38,0x2A,0xEB,0xC7,0x83,0x11,
+        0x2C,0xE7,0x6F,0xEE,0xB5,0xBB,0xC3,0x1F,
+        0x0F,0x03,0xCA,0x2E,0x58,0xAC,0x43,0xAF,
+        0x27,0xFC,0xF8,0x7F,0xEE,0x74,0x59,0x1A,
+        0x2A,0xA6,0xB9,0x96,0xCA,0x75,0x5B,0xDD,
+        0x07,0x43,0x5D,0x2E,0x90,0x49,0x4B,0x1F,
+        0x2F,0x28,0xE8,0xE1,0x68,0x98,0x62,0x9E,
+        0x2B,0xCC,0x18,0xBF,0xB6,0x30,0x45,0x0B,
+        0x0F,0xA5,0x26,0x5F,0xF2,0x4E,0x8D,0x4C,
+        0x2F,0x1D,0x2E,0x2B,0xBD,0x51,0xE0,0x8B,
+        0x22,0xC9,0x0F,0x84,0x7B,0x1E,0xD3,0x3B,
+        0x0F,0xC5,0x59,0x5B,0xEF,0x74,0xAE,0x9D,
+        0x0F,0x9C,0x3C,0x2E,0xBD,0xE7,0xCF,0x33,
+        0x0F,0xF2,0xD0,0x95,0xFD,0x16,0x91,0xEC,
+        0x27,0xD1,0x25,0x1E,0x42,0xE4,0x76,0xA5,
+        0x27,0xB2,0x51,0xF4,0x47,0x86,0x96,0x3C,
+        0x2F,0x86,0xD4,0xC3,0xEB,0x0F,0x61,0xC5,
+        0x2F,0x02,0xC7,0xD2,0xF3,0x08,0x37,0x11,
+        0x2F,0x6E,0x76,0xB8,0x3C,0x8D,0xB2,0x3C,
+        0x27,0x9A,0x63,0x1C,0xE7,0x0F,0x30,0xA9,
+        0x2F,0x99,0x35,0x0B,0x4F,0x30,0xD8,0x40,
+        0x2F,0x05,0xB5,0x9B,0x25,0xDC,0xAA,0x04,
+        0x2F,0x7E,0xC8,0xA0,0x9A,0xCF,0x5B,0x02,
+        0x2F,0xF1,0xAE,0x6A,0xC0,0xF2,0x7F,0x26,
+        0x27,0xD0,0xB5,0x4F,0xF2,0x49,0xE3,0x6B,
+        0x2F,0x05,0x93,0x36,0x06,0x87,0x4F,0xCC,
+        0x2F,0x23,0xEC,0x7C,0x4C,0x72,0x9A,0x3C,
+        0x2F,0x6B,0x54,0xF8,0x3B,0x61,0x5E,0x2C,
+        0x2F,0x64,0x81,0x71,0x57,0xAB,0x7E,0x00,
+        0x27,0x1B,0xDF,0x60,0x87,0xEC,0x09,0xCE,
+        0x27,0xD9,0x0F,0x88,0x85,0x66,0x30,0x75,
+        0x2B,0x4A,0xDA,0x8E,0x70,0x95,0xE1,0x03,
+        0x07,0x7F,0xB4,0x6C,0x2A,0x75,0x26,0xB4,
+        0x27,0x0F,0x2B,0x5C,0x41,0x5E,0x1B,0x17,
+        0x27,0xC1,0xC3,0xFD,0x47,0x80,0xF3,0x0C,
+        0x2D,0xA0,0xD6,0x52,0xD4,0x7D,0x36,0x56,
+        0x0F,0x33,0x9A,0x66,0x38,0x78,0x41,0xDB,
+        0x27,0x5F,0xA3,0x2B,0x2E,0x2C,0x10,0x4B,
+        0x2F,0xB9,0xE4,0x5A,0xB5,0x4F,0x77,0xC5,
+        0x27,0x71,0x81,0x09,0xCB,0x75,0x8B,0xBE,
+        0x2F,0x51,0xF0,0xBF,0xCF,0x7E,0x86,0x1F,
+        0x0F,0x99,0x38,0x76,0x15,0x09,0xE3,0xD4,
+        0x2F,0xEC,0xF4,0x74,0x81,0x20,0xBD,0x72,
+        0x2F,0xD7,0x2F,0x9B,0xCC,0x51,0x20,0xFB,
+        0x2F,0xF6,0x33,0x61,0xDA,0x43,0xDF,0x18,
+        0x0F,0xD2,0x46,0x42,0x53,0xFB,0x33,0x85,
+        0x0F,0xC2,0xE3,0xFA,0x62,0x71,0x50,0x3F,
+        0x2F,0xE0,0xD4,0xB9,0xEB,0xBB,0x2F,0xEA,
+        0x2F,0xB1,0x81,0x68,0x7C,0xAE,0x15,0x12,
+        0x2F,0xAD,0x25,0xB8,0xC9,0xD4,0xDE,0x0F,
+        0x2F,0x8E,0xF4,0xBB,0x6E,0xDE,0x58,0x90,
+        0x2F,0xAF,0x29,0xFD,0x4D,0xF4,0x6F,0xCD,
+        0x2F,0x43,0x04,0x98,0x64,0x8A,0x05,0x8C,
+        0x27,0x63,0xE2,0x80,0x63,0xE3,0x79,0x4E,
+        0x27,0xE8,0x83,0x73,0x9F,0x52,0x3E,0x0B,
+        0x2F,0xF4,0x4C,0xF1,0x20,0xE1,0x61,0x87,
+        0x27,0x2F,0x13,0x94,0x95,0x0A,0x95,0x5E,
+        0x2F,0x8B,0xB7,0x5A,0x4E,0x68,0x74,0x38,
+        0x27,0xF0,0xB0,0x06,0x0C,0x5E,0xFC,0x83,
+        0x22,0x58,0x90,0x75,0xD6,0x11,0xD7,0x23,
+        0x0F,0xD1,0x1D,0x83,0xFB,0x05,0xC1,0xB5,
+        0x27,0xC0,0x9C,0xCD,0x2E,0x86,0x59,0x3F,
+        0x27,0xC5,0x8F,0x00,0xCD,0x54,0xBF,0x63,
+        0x27,0x0B,0x2A,0xF0,0xD5,0xE0,0xE7,0x7D,
+        0x27,0x79,0x4B,0xA8,0x6A,0x63,0x4F,0x6E,
+        0x27,0x22,0xF9,0xE0,0xA4,0x15,0xD1,0xE9,
+        0x2F,0xEE,0xB9,0xEC,0x42,0x47,0x31,0xD9,
+        0x2F,0xCE,0x73,0x1C,0x27,0xF5,0x83,0xF0,
+        0x2B,0xC8,0xB2,0x41,0x37,0xEC,0x07,0x65,
+        0x0F,0x1E,0x28,0x57,0x8B,0x7F,0xBD,0x0E,
+        0x07,0xFE,0x98,0x3E,0xCA,0xCA,0xE7,0xB8,
+        0x07,0x9D,0x32,0x82,0x84,0x7F,0x6B,0x05,
+        0x2F,0x8D,0x92,0xFC,0x4A,0x2B,0xDA,0xEC,
+        0x27,0xD1,0x0E,0x34,0x61,0xB0,0x50,0x3A,
+        0x27,0x0F,0x34,0xCC,0xF6,0xB6,0xF7,0x35,
+        0x2C,0x22,0x0C,0xDA,0xCA,0xBF,0x60,0xFB,
+        0x0F,0xA9,0x87,0xC4,0x65,0x52,0xA1,0xDE,
+        0x27,0x63,0x6C,0xAE,0xED,0x2E,0x5A,0xE9,
+        0x21,0x05,0xD7,0x22,0x50,0x14,0xD8,0x13,
+        0x07,0x7F,0xDA,0xCE,0xAA,0xA4,0x09,0x6D,
+        0x2F,0xBF,0x0C,0xF7,0xFD,0xE0,0x62,0xB4,
+        0x2A,0x4C,0x6E,0x4B,0xC9,0x21,0xFC,0x7F,
+        0x07,0x84,0xB9,0x4B,0x0D,0x2F,0x95,0x06,
+        0x0F,0x42,0xB8,0x0B,0xF1,0xAD,0xAB,0x6E,
+        0x0F,0xFC,0x3B,0x3C,0xD0,0x2F,0x84,0x53,
+        0x2F,0xA1,0x07,0x6A,0xF0,0x3F,0xB5,0x9E,
+        0x29,0x2F,0xA6,0x58,0x9B,0x4D,0xE4,0x8B,
+        0x07,0xF5,0xD7,0x4F,0x34,0xE6,0x71,0x48,
+        0x2F,0x26,0xA3,0x2E,0x0F,0x2E,0xA8,0x08,
+        0x27,0xB7,0xCA,0x34,0x7B,0x52,0xF1,0xE2,
+        0x27,0xB3,0x6B,0x90,0x56,0xC4,0x79,0x31,
+        0x27,0xE8,0x83,0x3B,0xB5,0x0D,0x87,0xB7,
+        0x2F,0x8D,0x54,0xF7,0x05,0x9E,0xB4,0x3D,
+        0x2F,0xB9,0x79,0x24,0x1E,0x21,0x53,0x15,
+        0x27,0x3A,0x0D,0xC7,0x85,0xE0,0x03,0xCC,
+        0x2B,0x7B,0x51,0x51,0xF1,0x90,0x53,0x4B,
+        0x0F,0xA1,0x95,0xD0,0x39,0x2F,0x9B,0x52,
+        0x27,0x97,0xF8,0x1A,0x24,0x30,0xE6,0x97,
+        0x27,0xFB,0xBA,0x50,0x03,0xDE,0x9A,0x09,
+        0x2F,0x21,0xCF,0xDA,0x40,0xC6,0x03,0x2D,
+        0x27,0x74,0x62,0xCF,0x6D,0x4C,0x86,0x43,
+        0x2B,0x5C,0x13,0x29,0xC6,0xFD,0x0E,0x22,
+        0x07,0x21,0xAC,0x96,0x7B,0xFB,0xD5,0xF6,
+        0x2F,0x20,0x74,0x6D,0xBD,0x29,0x03,0xE3,
+        0x27,0x7C,0xFD,0x09,0x9D,0xC5,0x4B,0xFD,
+        0x2F,0xBD,0x3C,0xA2,0x37,0xFC,0x6B,0x28,
+        0x27,0xEE,0x95,0x11,0x10,0x61,0xCE,0x72,
+        0x27,0xEF,0x0C,0x70,0x0B,0x3D,0x56,0xA3,
+        0x27,0x50,0x90,0xF9,0x36,0x07,0x11,0x1D,
+        0x2C,0x65,0x31,0x07,0xB1,0x1E,0x03,0xE3,
+        0x07,0x6E,0x29,0x99,0x36,0xB7,0x11,0xB0,
+        0x27,0x92,0x21,0xC3,0xDC,0x3E,0x91,0x1F,
+        0x2F,0xA2,0xEE,0x78,0x4D,0xEB,0x8B,0xA6,
+        0x2F,0x56,0x48,0xDA,0x15,0x60,0x5F,0x4C,
+        0x07,0xF4,0x25,0xAE,0x8C,0xC5,0x2C,0x0D,
+        0x27,0xCE,0xB1,0x4C,0x31,0x14,0x5C,0xDF,
+        0x2F,0x74,0x51,0xE0,0x62,0x9A,0x25,0x4B,
+        0x27,0xB0,0xCD,0xAF,0x31,0xB8,0x8C,0x81,
+        0x27,0xA6,0x7A,0xF0,0x8B,0xE6,0x17,0xED,
+        0x2F,0xCA,0xC1,0x4B,0xBD,0x28,0x73,0x77,
+        0x2C,0x22,0x87,0x83,0x30,0xF1,0x56,0x72,
+        0x07,0x21,0x06,0x4D,0xA3,0xAD,0xD5,0xE8,
+        0x2F,0xFA,0x37,0xAC,0xA6,0x58,0x25,0xF5,
+        0x2F,0x00,0x54,0xA1,0xC2,0x9D,0x4F,0xE9,
+        0x2F,0x7E,0xDA,0x01,0xF0,0x47,0x84,0x8C,
+        0x27,0x8C,0xF1,0x40,0xE7,0x17,0x05,0xED,
+        0x0F,0x94,0xE2,0x9A,0x69,0x4A,0xC8,0xE7,
+        0x0F,0xC5,0xFE,0xF2,0x7D,0xC7,0x1A,0x65,
+        0x0F,0xE4,0x06,0x6C,0xA8,0x7E,0xA3,0x9F,
+        0x2B,0xBE,0x61,0x2F,0x40,0xC1,0xF8,0xFB,
+        0x07,0x1B,0xC1,0x5E,0x3B,0x7C,0x15,0x1F,
+        0x27,0x0E,0x3A,0xD4,0xB3,0xE6,0x27,0xA7,
+        0x27,0x40,0x00,0x5E,0x99,0x6D,0x1E,0x8C,
+        0x2F,0x44,0xE4,0x28,0x60,0x9D,0x42,0x26,
+        0x27,0x54,0xBA,0xA5,0xFA,0x96,0x59,0x12,
+        0x26,0x61,0x6C,0x3B,0xE3,0x15,0x58,0x11,
+        0x0F,0x11,0x25,0x40,0x8F,0x24,0xEC,0x56,
+        0x27,0x30,0xD4,0xD1,0xEE,0xD3,0x2E,0x84,
+        0x2F,0x34,0x99,0xBB,0x5E,0x31,0x6B,0xD3,
+        0x27,0xE1,0x00,0xF0,0x77,0x25,0x32,0x21,
+        0x2F,0x40,0x78,0xB8,0x4D,0x20,0x89,0x19,
+        0x2B,0x83,0x7D,0xF7,0xF1,0xA1,0x39,0xCC,
+        0x0F,0x01,0x88,0x06,0xBE,0xDA,0x16,0x54,
+        0x2F,0x8C,0xC7,0x46,0xBA,0x97,0x3B,0xA0,
+        0x27,0x11,0x2D,0x48,0x50,0x3D,0x43,0x13,
+        0x27,0x26,0x09,0x6A,0x28,0x31,0xE9,0x4F,
+        0x2F,0x27,0x21,0xCD,0x1F,0x0F,0x14,0xFD,
+        0x27,0x08,0x17,0xAC,0x19,0xE1,0xEE,0x81,
+        0x27,0x06,0x46,0x31,0xD0,0xD9,0x8C,0x3A,
+        0x2F,0x6C,0xC9,0x22,0x76,0xBF,0x2D,0xC0,
+        0x27,0x59,0x94,0x9C,0x6F,0x00,0x99,0xD8,
+        0x27,0x6B,0x80,0xAF,0x62,0xDA,0x3B,0xB0,
+        0x2F,0x1E,0x9E,0x0B,0x1C,0x96,0xCC,0xB8,
+        0x2F,0x9E,0x6C,0x3B,0x90,0x8B,0x99,0x63,
+        0x2B,0xF1,0x2A,0x8E,0x19,0x08,0x92,0x5C,
+        0x07,0x64,0x29,0x69,0x21,0x1F,0x74,0x04,
+        0x2F,0x5F,0xDF,0x2B,0x94,0xEA,0x11,0xDC,
+        0x27,0x03,0x8C,0x02,0x94,0x97,0xE9,0xFA,
+        0x2B,0x98,0x04,0xE2,0xB9,0xD3,0xCA,0x1D,
+        0x07,0xB6,0x5F,0xF8,0x49,0x32,0x5D,0xE1,
+        0x2E,0xDE,0xA9,0xDA,0x52,0x08,0x1F,0x4F,
+        0x0F,0x43,0xBA,0x71,0xD3,0x15,0x83,0xDE,
+        0x0F,0x1D,0x57,0x70,0x35,0x6F,0xBB,0xE2,
+        0x27,0x2B,0xAD,0xF0,0x15,0x9C,0xF8,0x85,
+        0x29,0xAE,0x9B,0xCD,0x37,0xC8,0x20,0xA3,
+        0x0F,0x73,0xC8,0x53,0xE0,0x6F,0x5C,0x13,
+        0x0F,0x4A,0x21,0xC0,0xE2,0xD5,0xDC,0x57,
+        0x0F,0xB7,0xED,0x6D,0xA0,0x9E,0xDA,0xA3,
+        0x07,0x70,0x2A,0xF1,0xAA,0x56,0x45,0x1F,
+        0x07,0xF4,0x7D,0x57,0x9F,0x15,0x92,0x34,
+        0x07,0x1A,0x7B,0x3F,0x7E,0xE2,0x5E,0xD6,
+        0x27,0x5E,0xC5,0x15,0xA1,0x73,0x87,0x4E,
+        0x24,0x85,0xDA,0x47,0x8A,0xDD,0xA4,0xF1,
+        0x0F,0xE9,0x59,0xD0,0xA7,0x01,0xE8,0xC7,
+        0x27,0x66,0x37,0x72,0xAC,0x79,0xAD,0x5E,
+        0x27,0x9E,0xBB,0xDB,0x4F,0xF7,0x0D,0xAD,
+        0x2F,0xAE,0x85,0xB2,0xF8,0x01,0x6F,0x02,
+        0x27,0x80,0xB8,0xC7,0x95,0xD7,0x64,0xCA,
+        0x2A,0x24,0xE2,0x6C,0xA9,0xAA,0xF3,0xAB,
+        0x07,0x06,0x04,0x0B,0xB4,0x8B,0x5F,0xA3,
+        0x0F,0x81,0x66,0x1F,0xDC,0x76,0xB6,0x7B,
+        0x2B,0x80,0x14,0x7C,0xBD,0xF3,0xA9,0xEF,
+        0x0F,0x69,0x85,0xDF,0xAC,0x12,0x4F,0x1B,
+        0x23,0xC0,0x55,0x05,0xE5,0x77,0xA8,0xD1,
+        0x07,0xED,0xE9,0x86,0x13,0xDB,0xB6,0x2A,
+        0x27,0x6A,0xF7,0x23,0x6F,0x81,0xDD,0xE0,
+        0x27,0x55,0x4E,0xFC,0x58,0xD9,0xE5,0x63,
+        0x2F,0x86,0xC8,0xCB,0xB6,0x60,0x13,0x2A,
+        0x2F,0x6F,0x28,0x43,0x39,0x1C,0x28,0x3B,
+        0x2F,0x2B,0xD4,0x95,0x09,0xC8,0x23,0xC9,
+        0x27,0x9C,0x94,0xF8,0x88,0x7F,0xAB,0xED,
+        0x2F,0x65,0x8D,0xF2,0x0E,0xBF,0xB5,0x15,
+        0x27,0x64,0xA0,0x68,0x5C,0xC1,0x47,0x31,
+        0x27,0x39,0x2D,0x05,0x01,0x16,0xD5,0x42,
+        0x27,0xC4,0x6F,0xF1,0x9E,0x63,0xF8,0x95,
+        0x2F,0xAC,0xD6,0xDB,0x24,0x2D,0x25,0xC2,
+        0x27,0xB5,0xA5,0xA8,0x84,0x44,0xB5,0x73,
+        0x2F,0x74,0x54,0xAE,0x96,0xDC,0xCB,0xCE,
+        0x2F,0x46,0x51,0xE5,0x84,0x60,0xF8,0x10,
+        0x22,0x61,0x94,0x75,0xEB,0x96,0x9B,0x90,
+        0x07,0xB2,0xC3,0x35,0x94,0x82,0x68,0x74,
+        0x23,0x04,0x44,0x4F,0x51,0xE3,0x1E,0xE0,
+        0x0F,0x81,0x60,0x60,0x4C,0x82,0xEE,0x24,
+        0x2F,0xE5,0x31,0xD5,0xBA,0xE6,0x9A,0xBC,
+        0x2F,0x44,0x5C,0xF5,0x10,0x72,0x51,0x77,
+        0x29,0xA4,0xF9,0x14,0xC3,0x67,0x94,0x41,
+        0x07,0xF1,0xF6,0x20,0xC8,0xFA,0xF8,0x36,
+        0x2F,0x53,0x2F,0x01,0x4C,0xE3,0x51,0x22,
+        0x22,0x4C,0x54,0x37,0xC6,0x80,0x78,0x80,
+        0x07,0x80,0xF4,0x6E,0xF5,0xD3,0xEB,0x32,
+        0x2F,0x60,0xFC,0x4A,0x8E,0xFC,0x54,0x59,
+        0x2F,0x16,0xF6,0xF2,0xCB,0x5D,0x7E,0x4F,
+        0x24,0xE6,0x76,0xD5,0x20,0x47,0x28,0x95,
+        0x0F,0x71,0x59,0xB2,0x69,0x5B,0x4A,0x54,
+        0x25,0xA7,0xF5,0x4F,0xC6,0x83,0xB1,0xF8,
+        0x07,0x64,0x1A,0x30,0x1B,0xA7,0x0A,0x96,
+        0x07,0x2E,0x9C,0x49,0xBF,0x84,0x8F,0xB8,
+        0x2F,0x70,0x58,0xBA,0x0F,0x52,0x22,0xEE,
+        0x27,0x56,0x82,0x2C,0x69,0x74,0xDD,0x8C,
+        0x27,0xF0,0x22,0x67,0xA8,0x27,0xE5,0x49,
+        0x2B,0x24,0xA7,0xF6,0xB3,0x00,0xEB,0xF8,
+        0x0F,0x80,0xB4,0x7B,0x2D,0x4F,0xFC,0x5D,
+        0x2F,0xE2,0x9F,0x91,0x35,0x20,0x92,0xC3,
+        0x2F,0x2E,0x6C,0xC9,0xBF,0x87,0xAF,0x15,
+        0x27,0xBD,0x6D,0x88,0xA0,0xA9,0x12,0x81,
+        0x27,0xD1,0x53,0xE6,0xAD,0x29,0xC5,0x88,
+        0x2C,0xA4,0xE1,0x71,0x02,0x16,0x2F,0x40,
+        0x0F,0x4C,0x89,0xBF,0xAC,0xA0,0xD1,0xC5,
+        0x07,0x93,0x6A,0x4A,0xAE,0x49,0x9D,0x08,
+        0x07,0xF5,0x0A,0x81,0x60,0x86,0xBD,0xC0,
+        0x07,0x01,0xEA,0xBF,0x17,0x71,0xFD,0xC6,
+        0x27,0xED,0x1C,0xDA,0xCF,0x1B,0x15,0xC3,
+        0x24,0x42,0x35,0x96,0x40,0xF4,0x4B,0x66,
+        0x0F,0x7E,0xED,0x10,0x9E,0x4A,0xB9,0x77,
+        0x27,0x48,0x57,0xA5,0xC0,0xBA,0x45,0x3F,
+        0x27,0x5D,0x5F,0x72,0xA6,0xF5,0x2F,0x05,
+        0x2A,0xA2,0xFD,0x30,0x29,0x92,0xF6,0xDB,
+        0x07,0xEF,0xD0,0x9E,0x85,0x66,0x66,0xA5,
+        0x2F,0x7D,0x2B,0x8E,0x17,0x1D,0x62,0x5F,
+        0x27,0xAA,0xFC,0xBB,0x33,0xD6,0x23,0xAE,
+        0x07,0x8A,0xEA,0xED,0x27,0x94,0xA1,0x17,
+        0x22,0xA4,0xF5,0xEC,0x4E,0x2B,0xC1,0x80,
+        0x07,0xA2,0x9A,0xE7,0x65,0x02,0x67,0xCD,
+        0x2F,0xEE,0x15,0x9E,0x44,0x05,0xD8,0xC1,
+        0x07,0x4B,0x06,0x93,0xBE,0x69,0xF6,0x19,
+        0x27,0x21,0x58,0x39,0x12,0xAE,0x93,0x88,
+        0x27,0x50,0x6B,0xD6,0xE2,0xDD,0x7D,0xE7,
+        0x27,0xA0,0xBF,0x06,0xA7,0x1E,0x1B,0x78,
+        0x27,0xBB,0xDF,0x6C,0xBD,0xBF,0xF4,0xEA,
+        0x2F,0xFB,0x3F,0x87,0x48,0x49,0x31,0xD5,
+        0x2F,0x58,0x72,0x1E,0xC4,0x11,0x59,0x1A,
+        0x2F,0x47,0x41,0xF9,0x52,0x81,0x24,0xE8,
+        0x2F,0x65,0xF2,0x73,0xE3,0x11,0x13,0x3A,
+        0x2F,0x10,0x8E,0xFD,0x53,0x64,0xC3,0x7D,
+        0x2F,0xCD,0x92,0xAF,0x58,0x06,0x6D,0x90,
+        0x2F,0x55,0xD5,0x96,0x9D,0x87,0x96,0xB7,
+        0x27,0xA0,0x52,0x87,0x25,0x22,0x4C,0x8B,
+        0x2F,0xD0,0x5E,0x58,0x13,0x6B,0x2C,0xD7,
+        0x2E,0x69,0xAB,0x78,0x86,0x9B,0x7F,0x73,
+        0x07,0x28,0xCB,0x9B,0xEF,0xAB,0xE2,0x4E,
+        0x2F,0x6C,0xBB,0x96,0x6B,0xB9,0x80,0x18,
+        0x21,0x8D,0xCD,0xFB,0xB0,0xC6,0xB3,0xF8,
+        0x0F,0x88,0x39,0x17,0x78,0xD6,0x80,0x92,
+        0x2F,0x46,0x17,0x34,0x41,0x56,0xFE,0x4D,
+        0x2F,0xFB,0x4B,0xF8,0x94,0x54,0x83,0xB1,
+        0x27,0xE1,0xAF,0x2F,0xDB,0xB9,0x41,0x08,
+        0x27,0xEE,0x84,0xEB,0x50,0x8A,0xA4,0xF0,
+        0x2F,0xD9,0x63,0x31,0x38,0xC3,0x3C,0xAA,
+        0x27,0x06,0x04,0x9E,0x31,0x9D,0xC2,0xD6,
+        0x2F,0xCC,0x64,0x4F,0xA2,0x65,0x79,0x56,
+        0x2F,0x56,0x92,0xBB,0xF0,0xC0,0x5F,0x95,
+        0x2F,0x2A,0x3D,0x86,0x04,0x22,0xDA,0xC5,
+        0x27,0xFC,0x46,0x35,0x09,0xE0,0xC7,0x09,
+        0x2F,0xC3,0x69,0x84,0x16,0x5F,0x1C,0xD1,
+        0x27,0xC2,0x1B,0xB0,0xF6,0x03,0x45,0xD7,
+        0x2F,0x05,0x16,0x68,0x82,0x28,0xE2,0xDB,
+        0x29,0xCE,0x7C,0xEA,0xD0,0x15,0xF4,0x0A,
+        0x0F,0xBF,0x3E,0xB1,0x21,0xFB,0xC6,0x39,
+        0x2F,0xA0,0x28,0xF4,0x4C,0xBA,0x3E,0x07,
+        0x2F,0x73,0x9E,0xD5,0x13,0x5D,0xCA,0xFF,
+        0x29,0x21,0x59,0xE7,0x8A,0x78,0xEB,0x2B,
+        0x0F,0xD6,0x24,0xEE,0x0D,0x6F,0xBF,0x6F,
+        0x2F,0x2A,0xA2,0xE0,0xA2,0xD5,0x3C,0x87,
+        0x27,0x70,0x63,0xCE,0x27,0x49,0x65,0x4A,
+        0x2F,0xD8,0x06,0xAE,0x56,0xDD,0x73,0x85,
+        0x2F,0x63,0x66,0x81,0x07,0xA7,0x7F,0x8E,
+        0x27,0xE8,0x1F,0x8E,0xD2,0x81,0x09,0xE8,
+        0x27,0x86,0xB6,0xAD,0x85,0x72,0x2F,0x56,
+        0x27,0xD2,0xF4,0x24,0x60,0xF5,0x18,0x59,
+        0x27,0x94,0x9D,0x73,0x47,0x55,0xEC,0xA1,
+        0x2F,0x89,0xDC,0x83,0x74,0x88,0x20,0xD1,
+        0x2F,0x45,0x75,0xC2,0x09,0xE7,0x60,0xA8,
+        0x2F,0x90,0xEB,0xAF,0x72,0x7D,0xA4,0xF4,
+        0x2F,0xFE,0x86,0x6F,0xA7,0xBA,0xB3,0x76,
+        0x27,0xD5,0x1F,0x8B,0x9E,0xEB,0xED,0x0D,
+        0x2F,0xA9,0x4F,0x0D,0x90,0xB4,0x98,0xAC,
+        0x27,0xC6,0x43,0x32,0x34,0xD8,0xCC,0x66,
+        0x2F,0xA3,0x3E,0x9F,0x17,0xF5,0x06,0x90,
+        0x2F,0x4B,0xCF,0x0A,0xED,0xD6,0xCA,0x83,
+        0x2F,0x62,0x12,0x24,0x94,0x13,0x50,0x67,
+        0x2F,0xC9,0xC5,0xFE,0xA2,0x88,0x30,0xD7,
+        0x27,0xC2,0x94,0x79,0x39,0x4F,0x2E,0x00,
+        0x2F,0xAD,0xA3,0x04,0x78,0x5A,0xA8,0xCA,
+        0x27,0xD6,0x34,0x5C,0x27,0x6F,0x70,0xAD,
+        0x27,0xBB,0xDA,0x43,0x74,0x06,0xCD,0x42,
+        0x2F,0x9F,0xDF,0x82,0x6C,0x52,0x65,0x30,
+        0x2F,0xBE,0x2B,0xAA,0x2D,0x35,0xF4,0xD1,
+        0x27,0x5B,0x02,0xC2,0x90,0x5B,0xC7,0x52,
+        0x27,0x46,0xB7,0xF9,0x5C,0x82,0x45,0x7A,
+        0x26,0xFF,0x46,0x8D,0xFB,0xCF,0xBD,0x71,
+        0x07,0x89,0x70,0x42,0x03,0x70,0x81,0xDB,
+        0x07,0xD4,0x4A,0xE5,0x4D,0x01,0x26,0x4D,
+        0x07,0xFF,0x2D,0xBE,0x4A,0x6C,0xA9,0x2E,
+        0x0F,0xAA,0xD1,0xC2,0x8E,0x98,0x34,0x22,
+        0x0F,0x31,0x46,0x10,0xCF,0x3A,0x07,0xC1,
+        0x0F,0x27,0x5C,0x08,0xAC,0xE5,0x07,0x9D,
+        0x07,0xD3,0x91,0x7F,0xBF,0xFE,0xA8,0x8C,
+        0x27,0x5F,0x01,0xD0,0x2D,0x01,0xC7,0x6A,
+        0x2F,0xBD,0x14,0xB5,0xA7,0xC1,0x9F,0x50,
+        0x27,0xC0,0x74,0x1F,0x26,0x5C,0x7E,0x8D,
+        0x24,0x20,0x13,0x93,0x42,0x0D,0xF2,0x02,
+        0x07,0x62,0xF6,0x4F,0x85,0x2A,0x2F,0x38,
+        0x27,0x45,0x42,0xBD,0x73,0xC7,0xFC,0xAA,
+        0x2F,0x0B,0xEA,0xCA,0xE2,0xAE,0x22,0xC2,
+        0x27,0x35,0x7A,0x98,0xE3,0x3F,0x07,0x47,
+        0x2F,0x7F,0x4E,0xE7,0x75,0x73,0xBD,0x31,
+        0x27,0xDC,0x8D,0x57,0xDC,0x61,0x42,0xF1,
+        0x27,0x3C,0x2B,0x37,0x03,0x97,0xC9,0xC6,
+        0x2B,0x12,0x49,0x41,0xB1,0x45,0x40,0x81,
+        0x07,0x28,0x29,0x7B,0x8A,0xFE,0x52,0xA2,
+        0x07,0xBE,0xD2,0x5A,0x7E,0xF1,0x26,0xFD,
+        0x07,0xAB,0x88,0x4A,0x29,0xA5,0xFE,0x4F,
+        0x27,0xB9,0x3E,0xA1,0xB9,0x31,0xDC,0x97,
+        0x2B,0x01,0x66,0xC1,0xA9,0x20,0x05,0x76,
+        0x0F,0x69,0x67,0x6D,0x1D,0x79,0xEB,0x90,
+        0x22,0x3F,0xDC,0x3E,0x30,0xE7,0x6F,0x82,
+        0x07,0x21,0xA6,0x3D,0xC3,0x40,0x84,0x5D,
+        0x27,0xFF,0x7A,0x8F,0xBC,0xC1,0x12,0xA1,
+        0x27,0xBE,0xBC,0x58,0xF7,0x4E,0x1B,0x17,
+        0x27,0x10,0x26,0x85,0x68,0x1B,0x03,0x40,
+        0x2F,0x55,0x87,0xAE,0x18,0xE9,0x61,0xAC,
+        0x2F,0x83,0x88,0xE3,0x44,0x36,0xB5,0x1F,
+        0x2F,0x07,0xAC,0xA3,0xB6,0xB3,0xB3,0x7B,
+        0x27,0xD3,0x95,0x7C,0x56,0xA0,0xCF,0xF9,
+        0x2A,0x18,0x9F,0xA9,0x88,0xEB,0x3C,0xAD,
+        0x07,0x2A,0xFA,0x95,0x46,0x70,0x26,0x7A,
+        0x27,0x0F,0xBA,0xAD,0xC4,0xC3,0x72,0x60,
+        0x2D,0x1E,0xC1,0xB9,0xB3,0x06,0x8E,0x39,
+        0x07,0xB7,0xAA,0xA0,0x5F,0xE5,0xE5,0xE4,
+        0x27,0xE6,0xA7,0xDB,0x69,0x37,0x87,0xB8,
+        0x26,0xCF,0x19,0xE8,0x63,0xB4,0xD0,0xAB,
+        0x07,0xF4,0x4B,0x11,0xF2,0x26,0x59,0x19,
+        0x0F,0x90,0x3D,0xE6,0x4D,0x77,0xFD,0x23,
+        0x07,0xFA,0x0C,0xB5,0x67,0xED,0xFE,0x01,
+        0x0F,0x56,0xE8,0x48,0x16,0xF4,0xAB,0x07,
+        0x2F,0xF0,0xB7,0xFD,0xB8,0x8F,0x11,0xF9,
+        0x27,0xD5,0x61,0x33,0xA8,0x05,0x50,0x27,
+        0x07,0xA5,0x18,0xF5,0x1D,0x0C,0xA7,0x27,
+        0x2D,0x29,0xE3,0xC7,0x5A,0xAC,0x69,0x99,
+        0x07,0x2C,0xB5,0xEA,0x3B,0x66,0x25,0x55,
+        0x27,0x9E,0xCB,0xE3,0xC5,0x14,0x0B,0xC0,
+        0x2F,0xB2,0x5A,0xDB,0x09,0x66,0x3B,0x5E,
+        0x27,0x08,0x5F,0x5D,0x24,0x63,0xDD,0x16,
+        0x2F,0x35,0x60,0xE0,0xD0,0x77,0xAB,0xD0,
+        0x2F,0x55,0x65,0x7E,0x13,0xE4,0xF8,0x01,
+        0x27,0x86,0xE3,0x69,0xE8,0x77,0x20,0xAE,
+        0x27,0xFB,0x42,0x8D,0x13,0x16,0x75,0x6C,
+        0x27,0x90,0xF7,0x07,0xEF,0x66,0xF5,0x71,
+        0x27,0xCD,0x03,0xA6,0xEC,0xA4,0x60,0xC8,
+        0x2F,0xFD,0xB9,0x79,0xCE,0xDA,0x23,0x31,
+        0x27,0xC0,0x7B,0x98,0x7E,0x17,0x35,0x10,
+        0x27,0x9B,0xEB,0x75,0x40,0x67,0xE4,0x39,
+        0x27,0xB3,0xBD,0xB0,0x56,0x43,0x63,0xF7,
+        0x27,0x86,0xD7,0xD0,0x62,0x4E,0x39,0xD5,
+        0x2F,0xDE,0x85,0x5F,0x5A,0x3D,0xDF,0x91,
+        0x2F,0x48,0xA6,0xC9,0x9D,0x1A,0x1A,0x90,
+        0x2F,0x19,0xEB,0xEF,0x76,0x03,0x20,0x48,
+        0x2F,0xF9,0x8D,0xD8,0x9D,0xFE,0x6D,0x2B,
+        0x2B,0x03,0x30,0x76,0x42,0xB2,0x8D,0x35,
+        0x07,0x6A,0x2B,0x8F,0xEC,0x5F,0xCF,0x38,
+        0x2E,0x21,0x99,0x24,0xE4,0x18,0xFC,0xD7,
+        0x07,0x94,0xFB,0xC8,0x02,0x46,0xD4,0x7E,
+        0x2F,0xF6,0x07,0x2A,0x23,0x43,0xB2,0x7E,
+        0x27,0x4B,0xDC,0xE1,0xCD,0x6B,0x50,0x3D,
+        0x27,0x33,0x95,0x08,0xDF,0x44,0xC5,0xEA,
+        0x2F,0x21,0x26,0xDE,0xE2,0x1C,0x1A,0x4E,
+        0x27,0x7E,0x3C,0x8B,0xDC,0x3F,0xBA,0xCE,
+        0x27,0x62,0xCE,0xA5,0x8B,0x9C,0x06,0xA2,
+        0x27,0xDF,0xB8,0xDC,0x04,0x1C,0x3E,0xC2,
+        0x2F,0x1E,0xA2,0x3D,0xF7,0xD1,0x02,0xF2,
+        0x2F,0x9D,0x36,0x19,0xC0,0x91,0x17,0xAB,
+        0x07,0xCA,0x1D,0x37,0x12,0xCB,0x0B,0x55,
+        0x27,0x7C,0xB0,0x44,0xD4,0xA5,0xF5,0x30,
+        0x27,0x62,0x1A,0x97,0xEF,0x50,0x4C,0xC9,
+        0x2D,0x95,0x03,0x5F,0x1A,0x25,0x1E,0xA5,
+        0x0F,0x80,0xC1,0x2F,0xF2,0x4A,0x10,0x3D,
+        0x27,0xBC,0x35,0x42,0xFA,0x1C,0x45,0x37,
+        0x2F,0xAA,0x94,0xEF,0xF4,0x5B,0x5B,0x61,
+        0x2F,0x1E,0x9E,0xF6,0xDA,0x5A,0x57,0x7A,
+        0x27,0xA5,0x0F,0xD4,0x16,0x96,0xEF,0xE6,
+        0x27,0x58,0x34,0x82,0x19,0x99,0xB0,0x9B,
+        0x21,0x2A,0x53,0x79,0x44,0x00,0xB7,0xAF,
+        0x07,0x56,0x2F,0xEB,0xBD,0x76,0x41,0x2C,
+        0x2F,0x43,0xDD,0x24,0xFB,0x3C,0x14,0xE8,
+        0x27,0x8B,0x36,0x54,0xD1,0x1F,0x6C,0xDC,
+        0x27,0x1A,0x7F,0x43,0x5B,0xBB,0xC6,0xCC,
+        0x2F,0x48,0xFB,0xE3,0x11,0xF4,0xA3,0x66,
+        0x27,0x75,0x97,0x10,0x0C,0xC3,0x0C,0x71,
+        0x2F,0x8B,0x53,0x99,0xAB,0x47,0xF1,0xE1,
+        0x2F,0xC2,0x2F,0x65,0x45,0x15,0x57,0x7E,
+        0x2F,0x83,0x03,0xF5,0xC8,0xF0,0xDA,0xBB,
+        0x27,0x59,0x70,0x80,0x92,0xC1,0x60,0x0E,
+        0x27,0xF4,0x2E,0x33,0xD4,0xA8,0xB8,0x25,
+        0x2F,0xD4,0x4C,0xEB,0xC4,0x22,0x8A,0x10,
+        0x27,0xC7,0x75,0x6F,0x0E,0x9C,0x44,0x84,
+        0x29,0x16,0xCE,0x7A,0xB2,0x87,0x83,0x31,
+        0x07,0x4E,0x73,0xF1,0x5E,0xE9,0x1A,0x3D,
+        0x2F,0xE8,0x1F,0x74,0x59,0x17,0x01,0xB8,
+        0x27,0x06,0x85,0x3C,0xE9,0x5D,0x39,0xAC,
+        0x29,0x1E,0xDC,0x2F,0x0E,0xCD,0xB5,0xEC,
+        0x07,0x5C,0x20,0x8E,0x2F,0x98,0xAD,0x49,
+        0x2F,0xC5,0x88,0x9B,0x27,0x58,0xB0,0x1E,
+        0x2F,0xCD,0xA0,0x0D,0xA1,0x66,0xFC,0x9F,
+        0x2F,0xE2,0xE2,0x15,0xC4,0x0C,0x70,0x58,
+        0x27,0xC3,0x09,0xC5,0xD6,0xC9,0x4E,0x9E,
+        0x27,0xB6,0xE5,0x47,0xFD,0x57,0x34,0x0D,
+        0x27,0xDF,0xD3,0xA3,0xB1,0x5F,0x7E,0xC0,
+        0x2F,0xA3,0x21,0xC0,0x1B,0x95,0x79,0x98,
+        0x2F,0x86,0x84,0xBB,0xB6,0xE7,0x88,0xF1,
+        0x0F,0xCA,0x77,0x1E,0x0B,0xA5,0x37,0x13,
+        0x07,0x50,0xF8,0x58,0xCF,0xE1,0x58,0x22,
+        0x2F,0xE5,0xE6,0xFB,0x18,0x64,0x19,0xBE,
+        0x2D,0x36,0x61,0x4E,0xB4,0x78,0xB4,0xA5,
+        0x0F,0x0A,0x18,0xDA,0x40,0x68,0xC0,0x04,
+        0x0F,0x51,0x25,0xD4,0x50,0xAB,0xF9,0x32,
+        0x0F,0x4E,0x52,0xAA,0xC2,0x37,0x44,0x85,
+        0x27,0xB8,0x0F,0x4F,0x00,0xC7,0xED,0xA3,
+        0x21,0xBE,0x47,0x90,0x17,0x3D,0x90,0x3F,
+        0x0F,0x07,0x53,0x5A,0xDB,0x70,0x54,0xBC,
+        0x27,0x4D,0x0F,0xC0,0xF8,0xC6,0xDF,0xC8,
+        0x07,0x49,0x0F,0x96,0xCF,0x39,0x5E,0x40,
+        0x2F,0x51,0x56,0xAC,0xA3,0xEA,0xD8,0x41,
+        0x27,0xAB,0x88,0x73,0x49,0x29,0x41,0x5E,
+        0x27,0xA4,0x99,0x6A,0x62,0x58,0x90,0xBB,
+        0x22,0x69,0x4D,0x66,0x01,0x42,0x2B,0xBE,
+        0x07,0x34,0x3F,0x8B,0xA0,0x8E,0x9E,0x1C,
+        0x0F,0xF9,0x97,0x90,0x1D,0x32,0xC8,0xEA,
+        0x0F,0x5F,0xA0,0x3D,0x8C,0x76,0x71,0x60,
+        0x2E,0xEC,0x3A,0x43,0xF2,0x29,0xBF,0x42,
+        0x0F,0xD0,0x0B,0xBB,0x6F,0x4B,0xD2,0xDD,
+        0x07,0x74,0x5C,0x6A,0xEB,0xC6,0x84,0x6F,
+        0x07,0xA6,0x3B,0x51,0xE6,0x41,0x09,0x4E,
+        0x2F,0xB4,0xC5,0xB5,0xBF,0x46,0x9E,0x88,
+        0x2B,0x8C,0x54,0x27,0x92,0x47,0x0A,0x3B,
+        0x07,0x0C,0x46,0x8B,0x54,0x02,0x2F,0x27,
+        0x2C,0x60,0xB3,0xB8,0xA8,0xEF,0xFB,0x9F,
+        0x07,0xFD,0x9C,0x61,0xD8,0x05,0x0C,0x8B,
+        0x07,0xA9,0x42,0xE0,0x86,0x17,0xE7,0x61,
+        0x07,0x49,0xE0,0xD4,0x06,0xC6,0xF9,0x96,
+        0x27,0x0A,0x8C,0xA7,0x17,0x92,0x6C,0x3E,
+        0x21,0x82,0x2A,0xB1,0x69,0x4F,0xB4,0xCF,
+        0x07,0x79,0x59,0x4D,0x76,0xAD,0x9D,0x4D,
+        0x0F,0x06,0x01,0xE6,0x4E,0xCE,0x24,0x9D,
+        0x0F,0x0B,0xEC,0xA2,0xE5,0xB1,0x6D,0x04,
+        0x2F,0x99,0x4E,0xD2,0x95,0x7D,0xEE,0x3B,
+        0x2B,0xF0,0x5E,0x3C,0xAA,0x8B,0x7D,0x29,
+        0x07,0x55,0x45,0x57,0x62,0x6E,0x3D,0xD5,
+        0x07,0xAC,0x90,0x56,0x1F,0xC0,0x38,0xDD,
+        0x07,0x8F,0xBA,0x99,0x0A,0x7D,0x17,0xA2,
+        0x2F,0x03,0x66,0x01,0xBA,0xB9,0x3B,0x0C,
+        0x23,0x75,0xE3,0x4E,0x7C,0x02,0x2F,0xA7,
+        0x07,0xEC,0x07,0xDD,0x14,0xB4,0xBB,0x6E,
+        0x07,0x28,0x42,0xC9,0xD9,0xF3,0x72,0x3D,
+        0x27,0xE4,0x25,0x0F,0x4D,0xB5,0x36,0x5C,
+        0x2F,0x6D,0x45,0xB1,0xC9,0x49,0x53,0x4D,
+        0x2F,0x76,0x4E,0xD2,0xC9,0xFB,0xFF,0x17,
+        0x22,0x92,0x7B,0x16,0xBC,0x60,0x15,0x88,
+        0x07,0xD9,0xB5,0xAE,0x12,0x37,0x58,0xEE,
+        0x27,0x57,0x32,0x63,0xD1,0x3B,0xA3,0xC1,
+        0x27,0x21,0xDD,0xC2,0x1A,0x71,0xE4,0xD0,
+        0x27,0x77,0x8E,0x8F,0x8E,0x75,0xC3,0xA9,
+        0x27,0x90,0xF1,0x15,0x65,0x94,0xFD,0xC7,
+        0x23,0xBD,0x0C,0xC0,0x0D,0xA5,0xE8,0x09,
+        0x0F,0x82,0x83,0x29,0xFD,0x19,0xAB,0xBB,
+        0x27,0xEB,0x27,0x17,0xF7,0x0E,0x80,0xA8,
+        0x2F,0xC0,0xC8,0x99,0x86,0xB7,0xFC,0x76,
+        0x29,0x5B,0x35,0x60,0xBA,0x3C,0xF4,0x67,
+        0x07,0xB9,0x68,0xC2,0xC3,0x13,0x2F,0xE4,
+        0x27,0x7B,0xEB,0x83,0x88,0xB4,0x67,0x34,
+        0x2B,0xF8,0x44,0x85,0x99,0x6E,0x4F,0x8C,
+        0x07,0x06,0x8F,0x33,0xC7,0xA3,0xE1,0x3E,
+        0x07,0x05,0x03,0x94,0x18,0x20,0x41,0x67,
+        0x07,0xFB,0x2D,0x7F,0x6C,0x1E,0x8D,0x53,
+        0x05,0x68,0x9A,0x84,0x63,0x09,0x21,0x7F,
+        0x25,0xE2,0x76,0x81,0x23,0x4D,0x12,0x42,
+        0x07,0xD5,0x01,0x64,0x2E,0x98,0x7B,0x7E,
+        0x07,0x68,0xF3,0x24,0x93,0x10,0x6B,0x5E,
+        0x07,0xDC,0xF6,0x6F,0x0D,0x6B,0xF0,0x60,
+        0x0F,0x14,0x1F,0x6C,0xFD,0x1D,0x91,0x9B,
+        0x0F,0xF3,0x71,0xFB,0x14,0xAE,0x6D,0xE3,
+        0x0F,0x7A,0x50,0x65,0xB6,0x2F,0x9E,0x84,
+        0x0F,0x03,0xFD,0x59,0x4F,0xBE,0xF5,0xED,
+        0x0F,0x1A,0xF6,0xE5,0x5B,0xFE,0xF6,0x15,
+        0x0F,0x32,0x3E,0x12,0x12,0xC4,0x8E,0x05,
+        0x07,0x25,0xD1,0xDD,0xD7,0x18,0x3F,0xFB,
+        0x0F,0x4C,0xBB,0x27,0xDB,0x1C,0xF4,0x6F,
+        0x0F,0x05,0x37,0xE8,0xA3,0xEC,0x4A,0x46,
+        0x07,0xD5,0x15,0x31,0xFA,0x01,0x12,0x00,
+        0x07,0xA9,0xEF,0x47,0xE3,0x57,0x98,0x67,
+        0x2B,0xC5,0xB2,0xD6,0x3E,0x87,0xB6,0xA8,
+        0x0F,0xD9,0xE8,0x88,0xE9,0x66,0xEA,0xDB,
+        0x0F,0xF6,0x57,0x2C,0xC3,0x43,0xF4,0x2E,
+        0x0F,0x9B,0xD5,0x74,0xA2,0x42,0x5F,0xFC,
+        0x07,0x2C,0x8D,0x4A,0x2E,0x36,0xE8,0x23,
+        0x0F,0x6A,0x0C,0xAD,0xDD,0x50,0xD7,0xAE,
+        0x2F,0xAE,0x85,0x7F,0x2F,0xE5,0x02,0xA0,
+        0x24,0xCA,0xDE,0xF5,0xE9,0x32,0x37,0xF7,
+        0x0F,0xE5,0x17,0xFE,0x5D,0x97,0x4E,0x73,
+        0x22,0x80,0x1C,0xF3,0xBD,0x8B,0x99,0x6C,
+        0x07,0x62,0x50,0x0A,0x95,0x32,0xBE,0x86,
+        0x0F,0x3D,0x2F,0xEA,0x81,0x8F,0x0B,0xC7,
+        0x07,0x7E,0x0F,0xE4,0x1F,0xD5,0x97,0x55,
+        0x0F,0xED,0x79,0x75,0xD2,0xF5,0x3F,0xF0,
+        0x0F,0xEE,0x80,0x5D,0xF2,0xAF,0xCD,0xB9,
+        0x05,0xC3,0x4F,0x1C,0xB2,0x9A,0xEA,0xE3,
+        0x27,0x87,0xB1,0xC0,0x06,0x26,0xAB,0x90,
+        0x0F,0xC2,0xE2,0x5C,0x3D,0xBA,0xF1,0xE8,
+        0x07,0x37,0x30,0x60,0x40,0x11,0x43,0xA6,
+        0x0F,0x99,0x26,0x3F,0x88,0x13,0xAB,0x8B,
+        0x2F,0xFA,0xC3,0xDB,0xBF,0x0B,0x1E,0xA2,
+        0x29,0xCA,0x2C,0xE2,0xC9,0xFB,0x05,0x10,
+        0x0F,0x73,0x2B,0xA3,0xE1,0x6A,0x93,0xFA,
+        0x05,0xE7,0x2E,0xFA,0x40,0xC6,0x41,0xF2,
+        0x2D,0x4E,0x2F,0x31,0xF4,0xD3,0xB9,0xBB,
+        0x05,0xF2,0x8E,0x48,0xDE,0x91,0x5B,0x6A
+};
+
+static unsigned char firmwaretable_b30[] = {
+        0x04,0x01,0x01,0x00,0xEE,0xA4,0x94,0x17,
+        0x07,0x05,0x99,0x31,0x5B,0xB5,0x2D,0x90,
+        0x0F,0x76,0x41,0x39,0xE7,0x17,0xF3,0xA5,
+        0x05,0xBC,0x8B,0x61,0x0A,0xF1,0x3F,0x10,
+        0x22,0x52,0x13,0xFD,0xB0,0x7F,0x05,0x53,
+        0x05,0x01,0x7A,0x86,0x58,0x91,0xD6,0xA4,
+        0x22,0xC4,0xB5,0x5C,0xB8,0xD3,0x11,0xDE,
+        0x05,0x20,0x20,0x2A,0x43,0x44,0x4F,0x28,
+        0x22,0x87,0x6D,0x1E,0x90,0xE2,0xC6,0x02,
+        0x05,0x13,0x29,0x80,0x96,0x0D,0x29,0x15,
+        0x2A,0x7C,0x0C,0xA6,0x50,0xA0,0x62,0xD1,
+        0x05,0xCA,0x09,0xC0,0xA4,0x9D,0x4C,0x68,
+        0x2A,0xA6,0xC8,0x75,0x64,0x76,0x6D,0xC8,
+        0x05,0x81,0x1D,0x07,0x71,0x53,0x14,0xAC,
+        0x22,0x7B,0x4D,0x6D,0x86,0x15,0xEA,0xD0,
+        0x05,0x05,0xC3,0x11,0xEF,0x16,0x70,0x74,
+        0x2A,0x98,0xD8,0xBF,0xAF,0xC9,0xDA,0xE6,
+        0x05,0x7D,0xE7,0xA5,0x3F,0xA6,0x52,0xBC,
+        0x2F,0x1D,0x03,0x92,0x90,0x97,0xE5,0x39,
+        0x29,0x85,0x25,0xD5,0xF4,0xE8,0xED,0x7F,
+        0x0F,0xB0,0xB7,0xD4,0xEB,0x5B,0x69,0xD8,
+        0x05,0xDD,0x8B,0xFB,0xD2,0xD6,0x6F,0x0D,
+        0x22,0x4D,0xBE,0xBB,0xF9,0xAA,0x15,0x9B,
+        0x0F,0xB4,0x87,0xC2,0xDB,0x5C,0x7D,0xDB,
+        0x22,0xDD,0x93,0xED,0x25,0x7A,0xFC,0xB7,
+        0x05,0xE5,0xB1,0x9C,0xA4,0xC5,0x3E,0x3A,
+        0x27,0x6E,0x5F,0x8B,0xDF,0x77,0x16,0x1A,
+        0x27,0x89,0x03,0xDC,0x00,0x16,0x61,0xA0,
+        0x2F,0x05,0x92,0xA0,0x54,0xCC,0x06,0x96,
+        0x27,0x3F,0x94,0x85,0x36,0x55,0x40,0x85,
+        0x27,0xD2,0x2D,0x3E,0xAD,0x44,0x3D,0xFB,
+        0x2F,0x5B,0x25,0xF1,0xC5,0xD8,0x8B,0x7D,
+        0x27,0x55,0x85,0xAC,0x60,0x06,0xD4,0x22,
+        0x2F,0xB2,0x15,0x29,0xE3,0x5D,0xEE,0x3F,
+        0x2F,0x57,0xC6,0x33,0xA3,0xDA,0xED,0xF8,
+        0x27,0x00,0x45,0x66,0x8C,0x0B,0xB2,0xC6,
+        0x2F,0x66,0x5A,0xC7,0xEF,0x78,0x6B,0xB0,
+        0x2F,0x88,0xB4,0x2B,0xD9,0x93,0x22,0xFD,
+        0x27,0x86,0x29,0x2E,0xEA,0x16,0xB6,0x8D,
+        0x2F,0x65,0x8F,0x33,0xCF,0xB7,0xEE,0x70,
+        0x27,0xB2,0xD1,0xB5,0x3D,0xDE,0x07,0x4E,
+        0x27,0xBB,0x13,0xAC,0xF8,0xBC,0xAD,0x02,
+        0x2E,0x87,0x86,0xBD,0x81,0x07,0xB9,0xBD,
+        0x07,0x6F,0x55,0x74,0x26,0x02,0x87,0xD3,
+        0x2F,0xE4,0x16,0x64,0xC7,0xA0,0xCA,0x0E,
+        0x27,0xF3,0x00,0xEC,0x26,0xD5,0xB0,0x52,
+        0x2F,0x01,0xB2,0x7E,0xDF,0x2E,0x08,0x1F,
+        0x0F,0xDD,0xF7,0x94,0x2F,0xAE,0xE3,0xBE,
+        0x27,0x65,0xC4,0x5B,0x02,0xCB,0x22,0xE8,
+        0x2F,0x60,0x59,0xA1,0x48,0xE8,0xAF,0xD8,
+        0x2F,0xC3,0xA1,0x9F,0x82,0xD6,0x5F,0x30,
+        0x27,0xCF,0x75,0x5F,0x3F,0x63,0xF2,0x84,
+        0x2F,0x9E,0xEF,0xD3,0x4D,0x50,0xB2,0xC5,
+        0x27,0x4D,0xAA,0x58,0x3C,0x0C,0x8C,0x1B,
+        0x2F,0xE7,0x86,0xC6,0x35,0x71,0x8F,0x45,
+        0x27,0x0C,0x6A,0xE7,0x36,0xEA,0xC6,0x1B,
+        0x2F,0x18,0x86,0x76,0xD8,0x5E,0x90,0x29,
+        0x21,0x30,0x30,0x4D,0xF8,0xA9,0x19,0x3A,
+        0x0F,0x58,0xFF,0x4F,0x6A,0x07,0xE0,0x4D,
+        0x27,0x14,0x14,0x07,0x3A,0x86,0x98,0xDD,
+        0x2F,0x3C,0x67,0x4B,0x2A,0x4C,0x96,0xA2,
+        0x2F,0xF4,0x54,0x6C,0xDD,0xF6,0x5A,0x37,
+        0x27,0x80,0x77,0x8D,0x5C,0x8B,0xFF,0xAA,
+        0x2F,0x6F,0x2C,0x2D,0x2D,0x6A,0x90,0xFB,
+        0x2F,0x56,0x56,0x07,0x28,0xBB,0x3C,0xCF,
+        0x27,0x10,0xEE,0x04,0x36,0x67,0x61,0x53,
+        0x27,0xC1,0x8A,0x35,0xFB,0xB2,0xA6,0xF2,
+        0x27,0x74,0xD0,0x1E,0x66,0x38,0xB6,0x6A,
+        0x27,0x87,0x65,0xF9,0xF7,0x3C,0xC4,0x7B,
+        0x27,0x6E,0xCA,0x12,0xD8,0x5C,0x41,0x23,
+        0x2F,0x8D,0xA6,0x2E,0xAF,0xFF,0x18,0x0A,
+        0x2F,0xB7,0xEC,0xE7,0xFD,0xCA,0x91,0x37,
+        0x27,0x39,0xE0,0x6E,0x20,0x25,0xA3,0x77,
+        0x2F,0x4E,0xDC,0x4E,0xB6,0x00,0x40,0x3E,
+        0x22,0xC9,0xA3,0x33,0xB2,0x64,0xBE,0xAA,
+        0x0F,0xBB,0xC1,0x23,0x71,0x27,0xDD,0xC6,
+        0x0F,0xC4,0xEE,0xA9,0xBD,0x0C,0x8E,0x7F,
+        0x07,0x0C,0xE5,0xC9,0xE5,0x44,0x76,0xA8,
+        0x22,0x6C,0xB6,0x00,0x41,0xB8,0x7E,0x92,
+        0x07,0x60,0x69,0xB8,0x5E,0x61,0xAE,0x69,
+        0x0F,0xF2,0x06,0xEC,0xFC,0x2F,0xD4,0x37,
+        0x07,0x22,0x79,0x99,0xEC,0x08,0xD4,0x59,
+        0x07,0x1D,0xBF,0x96,0x14,0xB5,0x1C,0x15,
+        0x0F,0x5C,0xA5,0xDE,0x6A,0x2E,0xC5,0xFE,
+        0x0F,0x96,0x26,0x6D,0x1D,0x22,0xE7,0xE3,
+        0x05,0xA7,0x01,0x13,0x2A,0x36,0xC3,0xF5,
+        0x2A,0x5A,0x72,0x4B,0x87,0x71,0x59,0x87,
+        0x05,0x93,0xE2,0x4A,0x49,0xD7,0x6E,0x69,
+        0x23,0x1F,0x25,0x60,0x6E,0x1D,0x50,0x4A,
+        0x07,0x86,0xB1,0x82,0x29,0x46,0xBF,0x3E,
+        0x05,0x3E,0xD8,0x04,0x7D,0x4B,0xEB,0x68
+};
+
+static unsigned char firmwaretable_32_b11[] = {
+    0x04,0x01,0x01,0x00,0xEE,0xA4,0xB2,0x08,
+    0x05,0x8D,0xC5,0x99,0x19,0x46,0xEF,0x90,
+    0x2F,0x81,0xE9,0x4E,0x9F,0xC7,0xFB,0x5A,
+    0x2F,0xF7,0x56,0x1D,0x6E,0x71,0x19,0xDF,
+    0x21,0x72,0x87,0x9E,0xD0,0xE8,0xDF,0x61,
+    0x0F,0xFF,0xB8,0xB7,0xBE,0x10,0xE9,0x66,
+    0x05,0xB7,0x6B,0x06,0xEF,0x7E,0x4D,0xED,
+    0x2A,0x57,0xC2,0x17,0x70,0x3E,0xBD,0x7A,
+    0x05,0xC8,0x7D,0x38,0x2A,0xD0,0xAA,0xA1,
+    0x22,0x0C,0xE3,0xAA,0x8A,0x14,0x0A,0xF3,
+    0x0F,0xD3,0x27,0x8F,0x0D,0x96,0x72,0x6F,
+    0x07,0xB3,0xAB,0x7D,0xD5,0xEE,0x0C,0xAD,
+    0x07,0xFC,0xA8,0x98,0x7B,0x12,0x5B,0x44,
+    0x05,0xBB,0x18,0xC8,0x1F,0xE7,0x43,0x60,
+    0x2A,0xFA,0xEE,0xD6,0x8A,0x65,0x05,0x4A,
+    0x05,0xC8,0xD3,0x2C,0xD6,0xB4,0x85,0xE1,
+    0x2A,0x3E,0x27,0x89,0x99,0xB9,0xB6,0x4F,
+    0x05,0x96,0x27,0xAB,0xE1,0xE0,0x7A,0x37,
+    0x2A,0xA3,0xB6,0x96,0x3A,0x36,0x21,0x9F,
+    0x05,0x0A,0x0A,0xA9,0xE3,0x35,0x01,0x59,
+    0x2A,0x0A,0x28,0x4E,0x85,0xEE,0x8C,0x42,
+    0x05,0x6E,0x0D,0x83,0xDB,0xB7,0x92,0x0A,
+    0x2A,0x56,0x94,0x53,0x36,0x7B,0x65,0x33,
+    0x05,0x55,0x02,0x77,0x1D,0x00,0x1F,0xD8,
+    0x2A,0x76,0x38,0xED,0x1B,0x01,0x1A,0xB2,
+    0x05,0x90,0xA8,0x3E,0xEC,0xC7,0xA9,0x84,
+    0x22,0x2D,0xDD,0xDB,0xA2,0xF2,0x27,0x85,
+    0x05,0xFC,0x86,0x95,0xE5,0x7B,0x8D,0xA3,
+    0x22,0x49,0xAE,0xE3,0xFA,0xCD,0xDC,0xC8,
+    0x05,0x4E,0x0F,0x21,0x82,0x6B,0x40,0xF5,
+    0x22,0x69,0x23,0xD5,0x82,0x6A,0x3F,0xF0,
+    0x0F,0x86,0x00,0x42,0x46,0x66,0x77,0xD0,
+    0x0F,0xBE,0x14,0xE4,0xCD,0x0D,0xAB,0x76,
+    0x05,0x3C,0x40,0x61,0x4A,0xDE,0x23,0x2B,
+    0x2F,0xCF,0x9D,0x80,0x31,0x81,0xC3,0xFA,
+    0x21,0xAC,0xBA,0x33,0x6B,0x7E,0x41,0xE9,
+    0x0F,0x9B,0x24,0xAC,0x5C,0xEC,0x74,0xA0,
+    0x05,0x38,0x66,0x42,0x1E,0x12,0xF1,0xA8,
+    0x2F,0x8A,0x6E,0x8E,0x34,0x2D,0x33,0x34,
+    0x27,0x29,0x56,0xCC,0x80,0x6E,0x95,0xB6,
+    0x27,0x17,0xBC,0x39,0x73,0x7A,0x2B,0x0E,
+    0x27,0xCA,0x00,0x13,0xEC,0xEE,0x63,0x13,
+    0x2F,0x72,0x39,0x10,0xEE,0xC8,0xF4,0x66,
+    0x27,0x3D,0xD5,0x7E,0xE0,0x69,0x37,0x57,
+    0x2F,0x41,0x7E,0x3B,0x8B,0xB9,0x6C,0x5D,
+    0x26,0x8F,0x13,0x54,0x2E,0xE8,0x70,0x20,
+    0x0F,0x9C,0x7C,0xEA,0x62,0xCD,0x5F,0x4E,
+    0x2A,0x25,0x0C,0x89,0x25,0xB4,0x63,0xB5,
+    0x05,0xB8,0x44,0x63,0xE0,0x8A,0xD6,0x4C,
+    0x2F,0x54,0xD9,0x5B,0xD8,0x35,0x3F,0x87,
+    0x2F,0xB6,0x7F,0xD4,0x9A,0xC6,0x51,0x36,
+    0x27,0x3B,0x33,0x35,0x92,0xD3,0xF0,0x00,
+    0x2F,0xDE,0x58,0xE5,0x5B,0xDC,0xBB,0xDA,
+    0x27,0x72,0x6A,0xD6,0xBF,0xE9,0x69,0x81,
+    0x2F,0xC8,0x79,0xA1,0xB9,0xD7,0x72,0x2A,
+    0x27,0x2C,0x56,0x7B,0x40,0x2B,0xB5,0xBE,
+    0x2F,0x63,0x54,0x3F,0xC1,0x66,0xEF,0x87,
+    0x2F,0x1A,0x40,0x90,0x78,0x23,0x41,0xB6,
+    0x27,0x28,0xC7,0xE3,0x26,0xDB,0x10,0x93,
+    0x2F,0x8A,0x10,0x30,0xF9,0x88,0x7B,0x3E,
+    0x2F,0x48,0xB0,0x16,0x61,0xB2,0x35,0x32,
+    0x27,0x20,0x76,0x52,0xBF,0x88,0x78,0x65,
+    0x2F,0x89,0x5B,0x2A,0x31,0x29,0x73,0x15,
+    0x2A,0x1E,0x8A,0x7C,0x64,0xCF,0x58,0x88,
+    0x07,0x2D,0xC8,0x5F,0x94,0x6C,0x1D,0x92,
+    0x2F,0x93,0x1A,0x51,0x80,0xB8,0xBF,0xF4,
+    0x2F,0xF3,0xC3,0xB8,0x13,0xF8,0x3E,0x9C,
+    0x27,0x61,0xFB,0xF2,0xB2,0x22,0x4E,0xD1,
+    0x2F,0x47,0x0F,0xD0,0xC7,0xC6,0x9F,0x8A,
+    0x2F,0x25,0x35,0xBD,0x64,0x14,0xD1,0x50,
+    0x2F,0x7A,0x68,0x18,0xBC,0xE9,0xCB,0x51,
+    0x27,0xD7,0xB4,0xE2,0x0B,0x25,0x5E,0xAF,
+    0x27,0x82,0x65,0x26,0x79,0xA0,0x41,0x6B,
+    0x2F,0xD1,0xCA,0x96,0x79,0xD3,0x93,0x1F,
+    0x27,0xA6,0x80,0xF4,0xB2,0x64,0x4B,0x94,
+    0x27,0x0B,0xD9,0x49,0x3C,0xB6,0x1B,0x06,
+    0x27,0x72,0x8D,0x58,0x5D,0xFC,0x09,0xE3,
+    0x2F,0x2E,0x56,0x8A,0xD6,0x62,0xA7,0xD6,
+    0x27,0xE1,0x41,0x14,0xC1,0xBB,0x72,0x49,
+    0x2F,0xAB,0x26,0xFF,0x66,0x7C,0x03,0x16,
+    0x07,0x50,0x4C,0x29,0x0E,0x62,0xF1,0x37,
+    0x27,0x4E,0x16,0x4E,0x63,0x20,0x32,0xB5,
+    0x27,0x1B,0x81,0x09,0x77,0x15,0xE1,0xD1,
+    0x27,0xE0,0xD3,0xF5,0x19,0x69,0x8A,0x3A,
+    0x27,0x4A,0x43,0xB2,0xB4,0xCC,0xA0,0x3C,
+    0x2F,0x21,0x01,0x66,0xCF,0xB9,0x05,0x5E,
+    0x27,0x4D,0xE2,0x52,0x42,0x30,0xC2,0x67,
+    0x27,0xAC,0x2F,0xFC,0x78,0xEC,0x1B,0x09,
+    0x2F,0x0B,0xFA,0xE7,0x08,0x3B,0x58,0x53,
+    0x27,0x16,0xFC,0x05,0x4E,0x5C,0x56,0x2A,
+    0x27,0xF0,0x4B,0x91,0x01,0xA8,0x9B,0x4A,
+    0x2F,0xDF,0x68,0x43,0xDF,0xCD,0x2D,0xF6,
+    0x27,0xEE,0x4E,0xDF,0x03,0x97,0x59,0x9F,
+    0x27,0x54,0x13,0x3D,0xCE,0x8A,0x24,0xDE,
+    0x27,0x33,0x83,0x5C,0x79,0x7F,0x5A,0x58,
+    0x27,0xAD,0xFF,0x39,0x64,0x1D,0xCA,0x61,
+    0x2F,0x58,0xE9,0x3B,0xF3,0x79,0x61,0x8F,
+    0x07,0xCF,0xE4,0x3E,0xD0,0xD1,0xDB,0x61,
+    0x2F,0xE7,0xAE,0xE9,0x21,0x34,0xC7,0x5D,
+    0x27,0x95,0xA6,0xC5,0x03,0x0F,0x54,0x6F,
+    0x2F,0xBE,0xED,0x91,0xA4,0x31,0x0E,0x5D,
+    0x07,0xEF,0x57,0x94,0xD2,0xE3,0x32,0xC1,
+    0x27,0xB5,0x6A,0x6A,0x8E,0x90,0x2C,0xF0,
+    0x27,0x21,0xDF,0x6E,0xD5,0xE0,0xB0,0x61,
+    0x2F,0xBD,0x7B,0xD9,0x03,0x98,0x56,0xA4,
+    0x2F,0x22,0xFD,0x7E,0x3E,0x77,0xD9,0x0F,
+    0x27,0xE7,0x93,0x7D,0x3B,0x46,0x3B,0x77,
+    0x27,0x68,0xCE,0x0C,0x27,0xCF,0xB1,0x03,
+    0x2F,0x7F,0xC5,0x32,0x99,0x3D,0x8D,0x4B,
+    0x27,0xCE,0xD9,0x37,0xE3,0xE5,0x27,0x52,
+    0x0F,0xBD,0x39,0xE9,0xB0,0x65,0xD4,0x6D,
+    0x27,0x79,0x47,0x7E,0x4E,0x4A,0x60,0x7E,
+    0x27,0xEC,0x91,0x91,0xDB,0x2B,0x71,0x0A,
+    0x22,0xC0,0x2B,0x15,0xB4,0xB2,0xB1,0xFF,
+    0x0F,0xBA,0xAA,0xE6,0x90,0x2B,0x8D,0x2B,
+    0x27,0x8C,0xDB,0x3D,0x1D,0xE3,0x50,0x21,
+    0x2B,0x53,0x06,0x11,0x92,0xC5,0xF7,0xE9,
+    0x0F,0x92,0x20,0xF2,0x39,0xDE,0xDA,0x27,
+    0x0F,0x02,0xB9,0xDC,0x8E,0x0C,0xD6,0x96,
+    0x2F,0x78,0x58,0x0E,0x19,0x0F,0x00,0xE8,
+    0x27,0x81,0x88,0xB0,0xB4,0x52,0x40,0xF0,
+    0x29,0xFF,0x4F,0xFE,0x36,0x00,0xBE,0x58,
+    0x07,0x36,0x6A,0x07,0xA1,0x30,0x6F,0xEE,
+    0x2D,0x2C,0x1C,0x8E,0x9A,0x2E,0x2C,0x9B,
+    0x0F,0xB6,0xAD,0xA4,0xD3,0xC9,0x94,0x68,
+    0x0F,0x49,0x46,0xAB,0x38,0x27,0x86,0x4D,
+    0x0F,0x84,0x88,0xA5,0xB5,0x7B,0x08,0x5E,
+    0x07,0x5E,0x63,0x70,0xF0,0xBB,0xBD,0xE3,
+    0x0F,0xB7,0xD5,0x61,0xF5,0x3E,0x55,0x26,
+    0x2B,0x77,0x3F,0xD2,0xE3,0x83,0x2A,0x65,
+    0x0F,0x9E,0x59,0x08,0xA3,0x85,0xD2,0x6B,
+    0x23,0x54,0x61,0x83,0x62,0x27,0x39,0x66,
+    0x07,0xDC,0x69,0x24,0xE5,0xA9,0x8E,0xFC,
+    0x07,0x5B,0xAC,0x71,0xFC,0x2B,0x24,0x74,
+    0x2F,0xDB,0xD6,0xCF,0xB8,0xC8,0x6A,0xA2,
+    0x2F,0x8D,0xFE,0x5A,0x02,0xB3,0x52,0xE0,
+    0x07,0xEC,0x71,0xF3,0xA5,0x4A,0xBC,0x2D,
+    0x27,0xCA,0x0B,0xBF,0xA8,0x3B,0xA8,0xC4,
+    0x27,0xEB,0x74,0x32,0x8F,0xE9,0x00,0x58,
+    0x2F,0x4B,0x98,0xA0,0xC9,0x1E,0x70,0x83,
+    0x27,0x5F,0xCE,0x0F,0x26,0x24,0x17,0x5C,
+    0x27,0x14,0xC6,0xFF,0xE3,0x83,0x1E,0x71,
+    0x2F,0x79,0x6F,0xE6,0x95,0x55,0x00,0x05,
+    0x27,0x9D,0xDF,0xAE,0x70,0xBF,0x19,0xD5,
+    0x27,0xF3,0xB7,0x12,0xE6,0x3A,0x88,0x62,
+    0x2F,0x42,0x85,0xA0,0x0E,0xCB,0x6D,0x13,
+    0x2F,0x67,0x78,0xDF,0xEE,0xFC,0x23,0xF9,
+    0x27,0x90,0x17,0xCE,0x49,0x02,0x3E,0x4F,
+    0x2F,0x67,0x71,0x26,0xD5,0x21,0x55,0x91,
+    0x2F,0xBE,0xF4,0xBE,0x4A,0x37,0x26,0x03,
+    0x2F,0xC1,0x04,0xB6,0x3E,0xB5,0xA0,0x75,
+    0x25,0x2C,0x51,0xDC,0x2D,0xE8,0x09,0x0B,
+    0x0F,0x5F,0x1F,0x97,0x3A,0x97,0xCE,0x79,
+    0x27,0x66,0x01,0x30,0x41,0x91,0x82,0xCF,
+    0x2F,0x3C,0x84,0x65,0x28,0x72,0xCE,0x53,
+    0x2F,0xC4,0x65,0x1F,0x04,0xEF,0xFA,0x48,
+    0x27,0x19,0xD5,0xF8,0x1B,0x3A,0x00,0xAB,
+    0x27,0xB2,0xCA,0x25,0xC3,0xE6,0xA4,0x55,
+    0x2B,0xB1,0xD8,0x69,0x34,0x83,0x7A,0xBF,
+    0x0F,0x50,0x35,0x83,0xC1,0x11,0x5E,0x7E,
+    0x27,0x3A,0x6B,0x1E,0xA8,0x4E,0x57,0x8B,
+    0x2F,0x00,0x09,0x75,0x58,0x7C,0x15,0x68,
+    0x2D,0x82,0xD7,0x3D,0x76,0xAB,0x42,0xA6,
+    0x0F,0x73,0xD4,0x2C,0x3B,0x8D,0x8D,0x78,
+    0x27,0x36,0xE0,0xD7,0x79,0xAE,0x7B,0x65,
+    0x2F,0x2F,0x4C,0x10,0x6A,0x9D,0x96,0xE9,
+    0x2F,0x69,0x14,0x7C,0x96,0x79,0x27,0xA7,
+    0x27,0xFA,0x85,0x09,0xC8,0xDC,0x26,0xD3,
+    0x27,0xC0,0x87,0xAC,0x9B,0x4E,0xB2,0x20,
+    0x2F,0x30,0xCC,0xC0,0x1B,0x57,0xDE,0x1E,
+    0x2F,0x06,0x4B,0x32,0xC0,0x2B,0x4D,0xD8,
+    0x2F,0x6A,0x03,0xF7,0x79,0xAC,0xED,0x0B,
+    0x2B,0x93,0x4E,0xFD,0xD9,0xDA,0x65,0xC5,
+    0x0F,0x8C,0xB3,0xFC,0xF0,0x27,0x8C,0x6D,
+    0x0F,0x3B,0x72,0x57,0x98,0xE9,0x18,0x6A,
+    0x07,0x6B,0xEB,0x3A,0x7B,0x42,0xBF,0x92,
+    0x22,0x13,0x45,0x24,0x1F,0x61,0x96,0x35,
+    0x0F,0x40,0x1E,0xF9,0xB5,0x51,0x2A,0xAB,
+    0x0F,0xDF,0x0E,0xF3,0x4B,0xAC,0x93,0x59,
+    0x07,0xC3,0xA7,0x20,0xDB,0x7A,0xF1,0xD5,
+    0x0F,0xE7,0xA1,0xF3,0x47,0xCD,0x40,0x33,
+    0x0F,0x0D,0x21,0x69,0x5E,0x96,0x92,0xDD,
+    0x0F,0x88,0xB2,0x51,0xFA,0x1E,0xF4,0x66,
+    0x0F,0x9F,0x32,0x90,0xC0,0x4A,0x33,0x2B,
+    0x0F,0xF6,0xBE,0x2A,0x80,0x53,0xC8,0x2A,
+    0x05,0x63,0x84,0xB8,0x02,0x56,0xF1,0xE9,
+    0x2F,0x97,0x3D,0x52,0x01,0x0B,0x96,0x7C,
+    0x23,0x89,0xD9,0xCF,0x8C,0xF7,0x2C,0xB2,
+    0x05,0x9B,0xBD,0xE8,0x5B,0xB1,0x70,0x94,
+    0x23,0xA7,0x82,0x14,0x92,0xF5,0x5A,0x82,
+    0x07,0x7C,0xBC,0x3E,0x3C,0x9C,0xC0,0x46,
+    0x05,0x8A,0x87,0xC0,0xC3,0x92,0x13,0xD2
+};
+
+typedef struct firmware_struct {
+	unsigned char firmware_len;
+	unsigned char firmware_table[16];
+} firmware_struct;
+
+
+firmware_struct Si2177_FW_3_0b5[] = {
+{ 16 , { 0xBF,0x21,0xB1,0xF8,0x50,0xD4,0xBD,0xDA,0x05,0x05,0xEE,0xC4,0xC2,0x3D,0x38,0x3E } },
+{ 8 , { 0x05,0x37,0x88,0x3C,0xE8,0x9D,0x8C,0x73 } },
+{ 16 , { 0x37,0x7E,0x76,0x05,0x28,0xFF,0xE7,0x9E,0xFF,0xB2,0xAC,0xA8,0x4C,0x34,0x27,0xD5 } },
+{ 16 , { 0x37,0x61,0x1B,0x98,0x42,0x2A,0xF4,0x94,0x3A,0x41,0x54,0x62,0xC5,0x63,0x64,0xE8 } },
+{ 8 , { 0x0F,0x25,0x9C,0x90,0x29,0xF4,0x01,0xB9 } },
+{ 16 , { 0x3F,0x19,0x38,0xD3,0xCF,0x93,0x28,0xE7,0x0F,0x88,0x6E,0x9A,0x63,0x9D,0xC8,0xA9 } },
+{ 11 , { 0x3A,0xF5,0x4F,0x80,0x53,0xA7,0x3B,0x61,0x61,0xB8,0x8E } },
+{ 11 , { 0x07,0x35,0xFD,0xB8,0x08,0x47,0xD6,0xEF,0x42,0x55,0xB3 } },
+{ 11 , { 0x0F,0x37,0x0E,0x93,0x3C,0xC5,0x95,0x6E,0x4A,0x16,0x87 } },
+{ 8 , { 0x07,0xE0,0x62,0xC7,0x47,0x85,0x6F,0xE4 } },
+{ 16 , { 0x3F,0xD1,0xE5,0xEB,0x0F,0xF8,0x8F,0x2E,0x92,0xEC,0xF8,0xF5,0xF5,0x4B,0x03,0x60 } },
+{ 14 , { 0x4A,0xA5,0xC6,0x07,0x43,0x80,0x4D,0x16,0x73,0x23,0x62,0x4A,0x40,0xC6 } },
+{ 8 , { 0x07,0xE8,0xC4,0x65,0xF3,0xE8,0xA8,0x40 } },
+{ 9 , { 0x38,0xC6,0xF7,0xA0,0x83,0xDE,0x0A,0x2B,0xD9 } },
+{ 16 , { 0x0F,0x90,0x5C,0x69,0x81,0x8E,0x3B,0x10,0x0F,0x04,0xB5,0x39,0xC5,0x45,0xD1,0x30 } },
+{ 16 , { 0x07,0x94,0xB3,0xE8,0x5A,0xCD,0x12,0x3E,0x0F,0x52,0x02,0x0B,0x4C,0xA8,0x53,0x25 } },
+{ 11 , { 0x0F,0x74,0xE6,0x3B,0xC2,0x52,0x80,0x11,0x4A,0xD8,0xF7 } },
+{ 14 , { 0x07,0x12,0x8F,0xAF,0x41,0xAA,0x21,0x92,0x45,0x97,0xDE,0x8C,0xDF,0x61 } },
+{ 8 , { 0x07,0x6C,0xF5,0xD0,0x97,0x73,0x1D,0x64 } },
+{ 9 , { 0x30,0x59,0x7F,0xD1,0xF3,0x95,0x19,0x8C,0x83 } },
+{ 11 , { 0x0F,0xA5,0xEB,0x96,0x1A,0xF7,0xDD,0xCF,0x42,0xCF,0x67 } },
+{ 8 , { 0x07,0xBF,0x08,0xF6,0x58,0x2B,0xE6,0xF6 } },
+{ 16 , { 0x3F,0x7A,0x11,0xF4,0x49,0xA2,0x2B,0x77,0xAA,0xFC,0xA4,0x62,0x96,0x92,0x2E,0x2E } },
+{ 14 , { 0x42,0x2E,0xA7,0x07,0x4D,0x77,0x36,0x86,0x14,0xA8,0xF6,0x42,0x50,0xED } },
+{ 16 , { 0x07,0xC9,0xCC,0xF5,0x96,0x73,0x36,0x27,0x0F,0x46,0xAD,0xB8,0x42,0xBB,0x20,0x5D } },
+{ 8 , { 0x07,0x65,0x6C,0x82,0x0F,0xD3,0x75,0x2C } },
+{ 12 , { 0x33,0x94,0xF7,0xCA,0x9B,0x4B,0x3D,0x9D,0x60,0x6A,0xF1,0xCF } },
+{ 11 , { 0x0F,0x32,0x3B,0x72,0xF8,0x49,0x84,0xFB,0x42,0x0F,0x42 } },
+{ 11 , { 0x07,0x26,0x87,0x28,0x8F,0x05,0xA3,0xAD,0x4A,0x59,0xC3 } },
+{ 16 , { 0x0A,0xBE,0xBB,0x9F,0x7D,0xE9,0x1A,0x74,0x12,0xD6,0xED,0xA3,0xB8,0x4A,0xDE,0x61 } },
+{ 8 , { 0x0F,0xB0,0x9C,0x7C,0x83,0xAE,0x64,0x9E } },
+{ 9 , { 0x30,0x48,0xE3,0xC4,0xDF,0xB6,0x69,0xB1,0x28 } },
+{ 11 , { 0x0F,0x33,0xAF,0x5A,0x2A,0xCE,0xFF,0xC2,0x4A,0x91,0x28 } },
+{ 8 , { 0x0F,0xF9,0xC1,0x42,0xA9,0x47,0x1C,0x6F } },
+{ 15 , { 0x36,0x39,0xE5,0x7D,0x4E,0xFE,0x74,0xA9,0x56,0x6F,0xB5,0x45,0x4E,0x3B,0x11 } },
+{ 8 , { 0x07,0x89,0xCB,0x17,0x5D,0x68,0x45,0xE4 } },
+{ 16 , { 0x3F,0xE5,0x65,0x79,0xE1,0x2F,0x88,0xAE,0x71,0x61,0xC6,0x44,0x08,0x9A,0xEC,0xA6 } },
+{ 8 , { 0x07,0x69,0x5C,0x05,0xA4,0x7B,0x8C,0xB8 } },
+{ 16 , { 0x3F,0xFD,0xF6,0x55,0x1C,0xE7,0x84,0xEF,0x78,0xA2,0x15,0x4C,0x27,0x20,0xE2,0xFC } },
+{ 9 , { 0x30,0x72,0x05,0x23,0x31,0xA9,0x3F,0x1C,0xD0 } },
+{ 11 , { 0x07,0xF3,0xC2,0xC4,0x9E,0xD9,0xD3,0x2E,0x42,0x0A,0x09 } },
+{ 8 , { 0x07,0x7F,0x52,0x33,0xF7,0x79,0x0C,0x79 } },
+{ 16 , { 0x3F,0xC0,0xCC,0xD6,0x65,0xC1,0xD2,0xEC,0x6F,0xB4,0xDC,0x42,0x26,0xCC,0xDF,0x8F } },
+{ 8 , { 0x07,0x7C,0x43,0x52,0xB1,0x44,0x70,0xDC } },
+{ 9 , { 0x38,0x66,0xE8,0x62,0xEA,0xE4,0xBA,0xFF,0xBB } },
+{ 8 , { 0x0F,0x22,0xFA,0xF3,0xA6,0xE9,0xDC,0xFB } },
+{ 15 , { 0x3E,0xE3,0x1F,0x9D,0xC0,0x56,0xB9,0xDD,0x71,0xA1,0x42,0x1C,0xD4,0x7C,0x0E } },
+{ 15 , { 0x0F,0x6A,0x56,0xB2,0x84,0x4F,0xB2,0xA9,0x4E,0x67,0x14,0x82,0x57,0x3F,0xC8 } },
+{ 11 , { 0x0F,0x87,0xA0,0x15,0x24,0x5F,0x03,0xF9,0x4A,0x50,0xB3 } },
+{ 8 , { 0x0F,0x5B,0x7E,0x34,0x20,0x7A,0xC3,0xCF } },
+{ 12 , { 0x33,0x5C,0xCB,0x58,0x7F,0x83,0x83,0xF7,0xC0,0x9E,0xC0,0x89 } },
+{ 11 , { 0x0F,0x03,0x21,0x5C,0x19,0x58,0x3B,0x1F,0x42,0xB8,0x7B } },
+{ 11 , { 0x07,0xDA,0x87,0x66,0x4A,0x8F,0xDB,0xCE,0x4A,0x04,0xBF } },
+{ 8 , { 0x0F,0xD1,0xA3,0x5A,0xEC,0xB0,0xE1,0xA0 } },
+{ 12 , { 0x3B,0xF6,0x00,0xE4,0x3D,0xDD,0x51,0x25,0x27,0xD2,0x50,0xB6 } },
+{ 8 , { 0x0F,0xA2,0x36,0x93,0x50,0xD5,0xF8,0xE1 } },
+{ 16 , { 0x3F,0x18,0x99,0xAE,0x84,0x94,0xE4,0x94,0xDE,0x75,0x12,0xE3,0xAA,0xD2,0x3D,0x18 } },
+{ 11 , { 0x42,0xDB,0x33,0x07,0x2B,0x3C,0x18,0x8C,0x92,0x18,0x69 } },
+{ 16 , { 0x07,0x6C,0x85,0xAA,0x6D,0xFD,0x7A,0xBD,0x07,0xB1,0x16,0x9B,0x5B,0xBA,0x9E,0x52 } },
+{ 16 , { 0x3F,0x96,0x5C,0x2B,0x48,0x02,0x12,0x13,0x54,0xDD,0xAA,0x3F,0x44,0x14,0x6E,0x87 } },
+{ 14 , { 0x4D,0x4C,0xF3,0x8A,0x52,0x04,0x0F,0x23,0x9C,0x12,0x15,0xB3,0xBA,0x00 } },
+{ 14 , { 0x4D,0x2B,0x05,0x56,0x44,0x3A,0x07,0x40,0x3A,0x70,0xDA,0x3C,0x41,0xB2 } },
+{ 12 , { 0x33,0xFB,0xE7,0x39,0x88,0x89,0x25,0x73,0x29,0xDB,0x47,0x09 } },
+{ 11 , { 0x0F,0x39,0x30,0x9F,0xF9,0xD5,0x7B,0xB5,0x42,0x11,0x97 } },
+{ 16 , { 0x07,0xC2,0xCD,0xF1,0x7C,0x63,0x5B,0x26,0x07,0x04,0xDD,0x5B,0x94,0x45,0xC8,0x9C } },
+{ 14 , { 0x07,0x0C,0x4A,0x33,0xFA,0x28,0x1D,0x6B,0x4D,0x11,0xDC,0xA2,0xA7,0x84 } },
+{ 11 , { 0x0F,0xD1,0x46,0xE6,0x27,0xBB,0xAD,0x8D,0x42,0xCE,0x58 } },
+{ 11 , { 0x0F,0xD5,0xE3,0x25,0x5F,0x6F,0x1E,0xFC,0x42,0x93,0x8D } },
+{ 8 , { 0x0F,0xD9,0xAB,0xC7,0xD7,0x96,0xF8,0xBE } },
+{ 9 , { 0x30,0xA5,0x11,0xDE,0x14,0x5E,0xA3,0x07,0xBE } },
+{ 8 , { 0x0F,0xFF,0xB5,0x28,0x4F,0xCF,0xA7,0x3C } },
+{ 16 , { 0x3F,0x86,0x17,0x1A,0x00,0x6C,0xBF,0x7F,0x83,0xB2,0x3F,0xE4,0xD2,0xFF,0xC2,0x18 } },
+{ 16 , { 0x37,0x37,0x1B,0x81,0x82,0xFE,0x8C,0xC2,0x8A,0xB1,0x1C,0x4A,0x4B,0x8A,0x94,0x66 } },
+{ 16 , { 0x37,0x80,0x53,0x9C,0x2B,0x32,0x97,0xE4,0x7A,0x5A,0xE2,0xF3,0x75,0x47,0xA6,0xF1 } },
+{ 16 , { 0x3F,0x44,0xCF,0x82,0x2F,0xD8,0x5D,0xED,0x9F,0xC0,0x3A,0x28,0x7F,0x7C,0x21,0x53 } },
+{ 15 , { 0x3E,0x31,0x35,0xA6,0xF3,0xC8,0xAA,0x7E,0x98,0x8E,0x60,0x80,0xE0,0xE6,0xCC } },
+{ 8 , { 0x07,0xB8,0x98,0xC0,0xA5,0xC9,0x9E,0x6A } },
+{ 11 , { 0x32,0xEC,0x2E,0x11,0xB6,0x4C,0x71,0xBF,0xC2,0x31,0x1C } },
+{ 8 , { 0x0F,0x00,0x13,0x7B,0x74,0xBC,0xD8,0x8B } },
+{ 11 , { 0x32,0x7F,0xFD,0x3D,0x1A,0x34,0x1C,0x25,0x50,0xBB,0xD3 } },
+{ 8 , { 0x07,0x7E,0xAE,0x2A,0x43,0x25,0x07,0x9C } },
+{ 13 , { 0x34,0x8C,0xF2,0xD5,0x5D,0x83,0xF7,0xD6,0x82,0xD4,0x12,0xB5,0x7B } },
+{ 8 , { 0x07,0xBC,0xC7,0x76,0x7E,0xDD,0xF4,0xA2 } },
+{ 16 , { 0x3F,0x91,0x33,0x61,0xAB,0x3A,0x7F,0x94,0x75,0x86,0xC8,0x5B,0xB6,0xE9,0x4C,0x6F } },
+{ 16 , { 0x37,0xB4,0x2A,0x7D,0xFB,0xDD,0x19,0x38,0xA4,0x06,0xE3,0xF9,0x02,0x25,0x1D,0x5D } },
+{ 16 , { 0x37,0x80,0xDD,0xAC,0x0A,0x35,0x44,0xC4,0xC9,0x80,0x46,0x5A,0x84,0x78,0x32,0x08 } },
+{ 16 , { 0x37,0x2D,0xA5,0x43,0xA2,0x87,0xDC,0x80,0xE9,0xE0,0xDA,0xDD,0x7B,0xD0,0x94,0x9E } },
+{ 16 , { 0x3F,0xD8,0x40,0x1F,0xDC,0x59,0x13,0xC3,0xEA,0x88,0x9F,0x8E,0xD5,0xB8,0x7D,0xDF } },
+{ 16 , { 0x37,0x94,0xB8,0x51,0x44,0x90,0x8B,0x9A,0xF7,0x4C,0x51,0xCB,0x3D,0xA7,0xEC,0x49 } },
+{ 16 , { 0x3F,0x6E,0x1D,0xD3,0xDB,0x45,0xC1,0x0C,0xA2,0x8E,0xA7,0xD4,0x32,0x7A,0x41,0x13 } },
+{ 16 , { 0x3F,0xFA,0x54,0xF6,0xCB,0x58,0x83,0x00,0x60,0x60,0x06,0x62,0x42,0xAD,0xD2,0xD9 } },
+{ 16 , { 0x37,0xAD,0x2E,0xDB,0x84,0xB3,0xFE,0xB6,0x7C,0xA9,0x6D,0x2D,0x40,0x30,0x10,0x15 } },
+{ 16 , { 0x37,0x3D,0xBC,0x3F,0xA5,0xD1,0x7F,0x67,0x2F,0xEE,0x6D,0x40,0x5E,0x9C,0x27,0xCF } },
+{ 16 , { 0x3F,0x56,0xDD,0xBE,0x1E,0xC1,0xDE,0xC4,0x2D,0xC5,0xA9,0xC1,0xF6,0x90,0xF5,0x60 } },
+{ 16 , { 0x37,0x2E,0xCF,0x9E,0x9E,0x48,0x77,0x0A,0xEF,0x20,0x7F,0xC2,0x3D,0xF3,0x89,0x09 } },
+{ 12 , { 0x4B,0x61,0x03,0x39,0x0F,0x42,0x5F,0x38,0xB8,0xE0,0xB1,0x6F } },
+{ 16 , { 0x37,0xC0,0xD5,0xD8,0xEE,0xA6,0xD2,0xFA,0x1D,0x3C,0x14,0xE4,0xA8,0x46,0x39,0x81 } },
+{ 11 , { 0x42,0xCA,0x93,0x0F,0x49,0xDE,0x8A,0xFD,0x03,0xA9,0x8D } },
+{ 16 , { 0x3F,0x00,0x49,0x34,0x7E,0xC3,0xF5,0x0A,0x2D,0x92,0xAC,0x4D,0x5F,0x4A,0x79,0x5C } },
+{ 14 , { 0x35,0x62,0xD2,0xB7,0xEB,0x20,0x05,0x91,0x94,0xB3,0xAA,0xC1,0x99,0x0F } },
+{ 16 , { 0x0F,0x6A,0x19,0xA9,0x88,0x8C,0x15,0x60,0x07,0x46,0x2D,0xAF,0xAF,0x89,0x27,0x5B } },
+{ 8 , { 0x07,0xD9,0x28,0x8D,0x41,0xEA,0x18,0x2D } },
+{ 13 , { 0x3C,0xD9,0x32,0x17,0x25,0x6E,0x6F,0xA3,0xAB,0x11,0x31,0x68,0x94 } },
+{ 8 , { 0x0F,0xF1,0x57,0xF0,0xA4,0x1C,0x39,0x3F } },
+{ 16 , { 0x3F,0xF2,0xF4,0xAE,0xB6,0xD9,0xC2,0xE5,0x32,0x4C,0xCC,0xBE,0xFA,0xE0,0xF4,0xB5 } },
+{ 12 , { 0x4B,0xB6,0xAB,0x11,0x07,0x5E,0xFD,0x85,0x07,0x12,0x00,0x4E } },
+{ 16 , { 0x0F,0x62,0x77,0x4B,0x1C,0xE7,0xF6,0xCF,0x0F,0x6A,0x38,0xE0,0x0F,0xD3,0x38,0xF5 } },
+{ 15 , { 0x46,0x56,0x66,0xEA,0x53,0x0F,0xB1,0x07,0xE1,0xF9,0x0F,0x5D,0x1F,0x87,0xF8 } },
+{ 12 , { 0x43,0x78,0x82,0xAD,0x07,0xFE,0x7D,0xA3,0x16,0x91,0xDB,0xE5 } },
+{ 16 , { 0x3F,0x6E,0x45,0x3F,0xBF,0x02,0x48,0x32,0x36,0x9C,0x4A,0xCB,0xDA,0x27,0x8B,0x1D } },
+{ 16 , { 0x3F,0x80,0x02,0x95,0x30,0x74,0xFB,0xC6,0x4B,0x04,0xFC,0xE1,0x0B,0xCD,0x4B,0x79 } },
+{ 16 , { 0x3F,0xB6,0x0A,0xFE,0x6C,0x99,0x59,0x3A,0xD2,0xD9,0x04,0xBF,0x7D,0x39,0xE5,0xB3 } },
+{ 16 , { 0x3F,0x59,0x27,0x2B,0x03,0x7B,0xE3,0xE2,0xFF,0x1B,0x86,0x58,0x5D,0xDD,0xA2,0x3B } },
+{ 16 , { 0x37,0x42,0x1B,0x79,0xAD,0x8F,0x9B,0x68,0x3A,0x81,0xFA,0x18,0x37,0xC4,0x4F,0x3D } },
+{ 16 , { 0x3F,0x14,0x7C,0x79,0x53,0x52,0xA5,0x31,0xA3,0x19,0x57,0xC2,0xDE,0xB5,0x6A,0x14 } },
+{ 16 , { 0x3F,0x7E,0x5E,0xB9,0xFE,0xBF,0xCD,0x3E,0xC4,0xA9,0x43,0x9A,0xF8,0xA8,0xF7,0x88 } },
+{ 16 , { 0x37,0x99,0xEC,0xB0,0xD5,0x6C,0x71,0x8F,0x91,0x44,0x74,0x4A,0x1B,0x39,0x94,0x29 } },
+{ 16 , { 0x3F,0x40,0x38,0x62,0xDD,0x93,0xFB,0xCB,0x05,0xD9,0x88,0x18,0x33,0xB7,0x8A,0xE3 } },
+{ 14 , { 0x35,0xA6,0x13,0x62,0xFF,0x44,0x4C,0xF0,0x04,0xCA,0xBA,0xE6,0x5B,0x93 } },
+{ 16 , { 0x07,0xFE,0x29,0x6D,0xAD,0x38,0xD1,0xE9,0x07,0xA3,0x64,0x82,0x18,0x5E,0x46,0x84 } },
+{ 8 , { 0x07,0x15,0x32,0x84,0x60,0x3E,0xCA,0x70 } },
+{ 16 , { 0x37,0x29,0x2C,0xA9,0xD8,0xD6,0x8B,0x10,0x0A,0x60,0x9C,0xA0,0x68,0x6B,0x55,0xE7 } },
+{ 16 , { 0x37,0x8B,0x84,0xB7,0x98,0x73,0x79,0x45,0xD8,0x14,0x8F,0xFB,0x76,0x9C,0x3F,0xA0 } },
+{ 12 , { 0x3B,0xF1,0x16,0x24,0xC8,0x0B,0x2F,0xF6,0x82,0x38,0x2B,0x04 } },
+{ 16 , { 0x0F,0xD4,0xA4,0xF8,0x07,0x6C,0x30,0x5F,0x0F,0x2C,0xF3,0xC5,0x41,0x31,0xF2,0xC9 } },
+{ 8 , { 0x07,0x96,0x56,0x07,0x18,0x1C,0xBA,0x48 } },
+{ 16 , { 0x37,0x3A,0xCA,0x6D,0xB5,0xC7,0x14,0xDD,0xE5,0x68,0x63,0x10,0x70,0x7D,0xAF,0x36 } },
+{ 12 , { 0x4B,0x20,0x19,0xE4,0x07,0x1E,0xBB,0x82,0x34,0xE1,0x73,0x30 } },
+{ 8 , { 0x0F,0x38,0x5B,0xBA,0xBD,0x26,0xBF,0xEE } },
+{ 16 , { 0x3F,0x57,0x0D,0x9B,0x6B,0x4A,0xD0,0x74,0xC0,0x8A,0x92,0x68,0xA0,0x3C,0xA8,0xF1 } },
+{ 16 , { 0x37,0xE9,0x6E,0x50,0x76,0x7C,0x51,0x06,0x70,0x1B,0x06,0x6F,0x42,0xDC,0x8E,0x3E } },
+{ 16 , { 0x37,0x2E,0xAB,0x45,0x2C,0xBE,0xDA,0x19,0xA4,0xD5,0xC9,0x66,0xB9,0x0B,0x3A,0x0B } },
+{ 14 , { 0x35,0x68,0x6B,0xCC,0x33,0x46,0xF4,0x5F,0x17,0xE5,0x02,0xF0,0xCD,0x65 } },
+{ 8 , { 0x07,0xBB,0xE2,0xB6,0xCF,0x13,0xD3,0x6F } },
+{ 16 , { 0x3F,0x12,0xA4,0x99,0x1E,0x91,0x51,0x3D,0x77,0x99,0xE4,0x3C,0x7D,0xF4,0xA6,0xBB } },
+{ 10 , { 0x31,0x9C,0x6A,0x32,0xCE,0x00,0x1E,0x36,0x59,0x25 } },
+{ 16 , { 0x0F,0x6A,0x0B,0x4C,0x7E,0x1F,0x11,0x54,0x0F,0x24,0x71,0xA6,0xC2,0xDA,0x3B,0xBC } },
+{ 16 , { 0x0F,0x19,0x13,0x70,0x9E,0x0A,0xF4,0xB5,0x0F,0x58,0x5E,0xC5,0xFC,0x30,0xA4,0x42 } },
+{ 8 , { 0x07,0xBC,0xFA,0xCC,0xBD,0x2B,0x76,0xC0 } },
+{ 12 , { 0x3B,0x72,0xF4,0xCE,0x70,0x40,0x39,0xFC,0xBA,0xD0,0xA2,0x4F } },
+{ 16 , { 0x0F,0x3B,0x9F,0x47,0xED,0xBA,0xA7,0x72,0x0F,0x29,0x3A,0x7A,0x97,0xDA,0x12,0x9C } },
+{ 8 , { 0x0F,0x34,0x49,0x97,0x2B,0xB6,0xD0,0x66 } },
+{ 16 , { 0x3F,0xAD,0xFB,0xC5,0xDF,0x94,0x43,0xB3,0xE2,0x24,0x27,0x37,0xA1,0x50,0xB6,0x09 } },
+{ 10 , { 0x39,0x1D,0x5F,0x06,0x1B,0x96,0x0D,0x48,0x22,0x67 } },
+{ 16 , { 0x0F,0x02,0xBA,0xB1,0xDD,0xEA,0x97,0xD3,0x07,0x9E,0x8B,0xD7,0xBB,0x41,0x0A,0x72 } },
+{ 13 , { 0x0F,0x25,0xE3,0x4D,0x16,0x55,0x16,0x3B,0x44,0x08,0xB1,0x9D,0x63 } },
+{ 16 , { 0x0F,0xF5,0x2A,0xDF,0x2A,0xB7,0x2B,0x0B,0x0F,0xE2,0xFF,0xCC,0x0D,0x37,0x7A,0x9E } },
+{ 14 , { 0x45,0x84,0xCE,0x77,0x29,0x6D,0x07,0x09,0x0C,0x6B,0x83,0x21,0x2C,0x15 } },
+{ 8 , { 0x07,0x63,0xA0,0x85,0xEF,0x5A,0xD3,0x55 } },
+{ 9 , { 0x38,0xD5,0xC5,0xC5,0x3C,0xCB,0x70,0x54,0x69 } },
+{ 8 , { 0x07,0x7D,0xA2,0x73,0x6A,0x98,0x4D,0x27 } },
+{ 16 , { 0x3F,0x6C,0xE6,0x12,0x77,0x30,0x22,0x34,0xBB,0x27,0xBB,0xCD,0x4E,0xD0,0xE6,0xDF } },
+{ 16 , { 0x3F,0x10,0x54,0x9A,0x1F,0x07,0x35,0x14,0xE1,0x33,0x0A,0x9B,0x67,0x4D,0xA0,0x5D } },
+{ 12 , { 0x3B,0x56,0x33,0x93,0xC9,0xB3,0x30,0xA1,0x23,0xC8,0xDD,0xF5 } },
+{ 8 , { 0x07,0xB2,0x01,0x59,0x31,0xDA,0xE4,0xDF } },
+{ 16 , { 0x37,0xA6,0x2C,0xC8,0x2C,0x67,0x87,0xE6,0x00,0x8F,0x3E,0xC7,0x52,0x90,0xBE,0xD4 } },
+{ 11 , { 0x4A,0x72,0x20,0x07,0x61,0xFC,0x3E,0x1C,0x7F,0xF4,0x77 } },
+{ 14 , { 0x07,0xB2,0x8A,0x78,0xE5,0xED,0x6F,0x10,0x4D,0x47,0x27,0xA0,0x3A,0x71 } },
+{ 8 , { 0x07,0xF6,0x45,0x4E,0x76,0x6D,0x01,0xCC } },
+{ 16 , { 0x37,0x71,0xE1,0x5E,0xAF,0x55,0x06,0x4B,0x95,0x12,0xFF,0x95,0x6B,0x49,0xC4,0x46 } },
+{ 9 , { 0x38,0xCC,0x51,0x29,0xB5,0x81,0x39,0x55,0xB9 } },
+{ 8 , { 0x0F,0xD8,0xB3,0xDF,0xE6,0x61,0x5B,0x03 } },
+{ 16 , { 0x3F,0xE8,0x82,0xC6,0x1F,0x26,0xBE,0x33,0x3A,0x7A,0x1C,0xBF,0x31,0x90,0x25,0x6B } },
+{ 16 , { 0x3F,0x75,0x0F,0xDB,0x5A,0x87,0x26,0x5E,0x67,0x24,0xC3,0xB4,0xE9,0x43,0xAE,0x95 } },
+{ 16 , { 0x3F,0xAF,0xE1,0xC1,0x3B,0x56,0x3F,0x19,0xC5,0xE1,0xC4,0xBB,0x63,0x0A,0xC3,0x4E } },
+{ 13 , { 0x34,0x26,0xDC,0x69,0xF4,0xA9,0xAC,0x3B,0x98,0x13,0xF6,0x4E,0xAB } },
+{ 8 , { 0x0F,0xD4,0x90,0x19,0x0A,0xA5,0x8D,0xB8 } },
+{ 16 , { 0x3F,0xD2,0x8D,0xC3,0xA7,0x13,0x44,0x4C,0x23,0xF6,0xD2,0xDC,0xAB,0x0F,0x55,0x82 } },
+{ 12 , { 0x4B,0x84,0xBA,0x97,0x0F,0x79,0x49,0xDF,0x1E,0xF9,0xA1,0x48 } },
+{ 12 , { 0x33,0xE7,0x23,0x04,0xA1,0x71,0x37,0x3C,0x99,0x5D,0xF2,0x06 } },
+{ 8 , { 0x0F,0x27,0xDF,0xFD,0xB0,0xEA,0xD5,0xDD } },
+{ 16 , { 0x37,0x8D,0x8A,0xDB,0xDF,0x3F,0xF7,0xCD,0xC7,0x9E,0x7F,0x05,0xFD,0x77,0x33,0x20 } },
+{ 11 , { 0x4A,0xDA,0x04,0x0F,0x6A,0xD1,0xB2,0xAA,0x1A,0x55,0x55 } },
+{ 16 , { 0x3F,0x39,0xCB,0x0A,0x0C,0x92,0xE1,0xDB,0xB9,0xC6,0x7D,0x11,0x04,0xC7,0x87,0x66 } },
+{ 15 , { 0x3E,0x1D,0x65,0x83,0x25,0xCD,0xFE,0x86,0x48,0xD3,0xC1,0x7B,0x03,0x05,0x87 } },
+{ 16 , { 0x0F,0x4A,0x31,0xF5,0x39,0x24,0xB8,0x37,0x0F,0x96,0x51,0xCE,0xC1,0xC1,0xF6,0x4B } },
+{ 16 , { 0x3F,0xF5,0xCC,0xC2,0x04,0xFC,0x8C,0xAD,0xD6,0x20,0x76,0x08,0x85,0x63,0x2B,0xD1 } },
+{ 16 , { 0x3F,0xC3,0x83,0x8A,0xEA,0xF7,0x89,0x94,0x3E,0xE3,0x93,0x5E,0xEC,0xDF,0x40,0x01 } },
+{ 12 , { 0x3B,0x1C,0x23,0x40,0xF6,0xD5,0x01,0xF6,0x2A,0x93,0xE4,0x1D } },
+{ 8 , { 0x0F,0x0F,0x83,0xE8,0x76,0x50,0x92,0xFA } },
+{ 16 , { 0x37,0x82,0x47,0x45,0x7E,0xE2,0x0F,0x32,0x49,0xCD,0x37,0x38,0x2B,0x4B,0x9A,0x8A } },
+{ 12 , { 0x43,0x05,0xC8,0x40,0x0F,0x02,0xE3,0x6D,0x30,0x61,0xF1,0x98 } },
+{ 16 , { 0x37,0x91,0x37,0xCB,0x68,0x81,0x9A,0xA8,0x61,0xCE,0xBF,0x67,0xC2,0x06,0xE8,0x09 } },
+{ 16 , { 0x37,0x12,0xA4,0x7A,0xE4,0x73,0x20,0x90,0xAA,0x78,0x49,0xD0,0xD9,0xE1,0x18,0x47 } },
+{ 16 , { 0x3F,0x52,0x80,0x43,0x40,0x41,0x19,0xFA,0xE5,0x06,0x64,0x39,0x94,0x2A,0xB1,0xA4 } },
+{ 16 , { 0x37,0xB5,0xDD,0x62,0x66,0x1E,0x0B,0x00,0x0E,0x81,0x73,0x44,0xDB,0xDC,0xC5,0x37 } },
+{ 16 , { 0x37,0xF1,0x6B,0x04,0xA6,0xFD,0x2E,0xD3,0x03,0x6B,0x8E,0xAA,0x9F,0x76,0xC5,0xA4 } },
+{ 16 , { 0x3F,0x0E,0xAA,0x91,0x72,0xC3,0xFC,0xCD,0x1B,0xD2,0xA3,0x74,0x29,0xF8,0x3F,0xE3 } },
+{ 16 , { 0x37,0x24,0xD1,0x29,0xAF,0x44,0xB2,0x93,0x93,0x91,0x69,0xC9,0xE3,0x9D,0x56,0x93 } },
+{ 16 , { 0x37,0x2F,0x93,0xAC,0x2F,0x95,0x12,0x32,0x7E,0x48,0x21,0xC5,0xE1,0xBC,0xA7,0xAD } },
+{ 9 , { 0x38,0x9C,0xD0,0x3C,0x03,0x8B,0x7E,0x43,0x07 } },
+{ 16 , { 0x07,0xC3,0xE2,0x9B,0x18,0x67,0x79,0xE0,0x0F,0xEF,0x99,0xF4,0x9C,0xF2,0xFE,0xF7 } },
+{ 8 , { 0x0F,0x52,0xB4,0x2B,0xEA,0xDE,0x46,0xCE } },
+{ 9 , { 0x30,0x3B,0x55,0x5E,0x2C,0x34,0x56,0xD4,0x0C } },
+{ 8 , { 0x07,0xC7,0x87,0xE0,0x46,0x48,0xD1,0x1B } },
+{ 15 , { 0x36,0xDD,0x84,0xBA,0x2B,0x8C,0x84,0x56,0xA1,0x62,0x14,0x49,0x06,0xDA,0x5F } },
+{ 8 , { 0x0F,0xB6,0x5B,0xF3,0x92,0xFC,0x8D,0xAA } },
+{ 11 , { 0x3A,0xC6,0xAD,0x54,0x97,0x23,0x5A,0x03,0x17,0xDD,0x64 } },
+{ 12 , { 0x07,0xB2,0x2B,0x95,0x16,0x06,0x37,0xB1,0x4B,0xFA,0x31,0x04 } },
+{ 8 , { 0x07,0xF0,0x84,0xFA,0x66,0xED,0x51,0xCD } },
+{ 16 , { 0x3F,0xDF,0x05,0x91,0xCC,0xE7,0x9D,0x26,0x0F,0x01,0xA9,0x2F,0x1B,0xB8,0x0A,0xBB } },
+{ 16 , { 0x3F,0xF1,0x49,0xCE,0x04,0x53,0xA9,0x9F,0xA1,0xAC,0x0E,0x58,0x01,0x7C,0x67,0x35 } },
+{ 10 , { 0x49,0x4C,0x0F,0x9C,0xB0,0xCD,0x55,0xD9,0xF6,0x70 } },
+{ 16 , { 0x3F,0xDE,0x13,0xB5,0x3B,0xDE,0x4E,0x47,0x0B,0x5F,0xB4,0x18,0x04,0xDE,0xE0,0xD2 } },
+{ 14 , { 0x3D,0x85,0x5E,0xE1,0x71,0x69,0xCD,0x41,0xF0,0x5B,0x96,0xD4,0x29,0x72 } },
+{ 8 , { 0x07,0x8E,0xCC,0xDB,0xD8,0x27,0x78,0x0B } },
+{ 16 , { 0x37,0x38,0x08,0x9E,0xC7,0xE3,0x95,0xF2,0xCD,0x5D,0xCA,0xC9,0x47,0xBB,0xE0,0x04 } },
+{ 14 , { 0x4D,0x11,0x72,0x0F,0x5E,0x1D,0x07,0xAD,0x6B,0x91,0x10,0x83,0x73,0xF5 } },
+{ 16 , { 0x3F,0x12,0x72,0xA8,0x60,0x89,0xA3,0xB0,0xED,0xBE,0x1D,0x50,0x40,0x53,0x68,0x05 } },
+{ 10 , { 0x49,0x23,0x07,0x4B,0xB2,0x11,0x36,0x62,0xDB,0x95 } },
+{ 12 , { 0x3B,0x5D,0xBD,0xB1,0xEC,0x89,0x9C,0x14,0x04,0xA7,0xCF,0x91 } },
+{ 8 , { 0x07,0xF6,0xB7,0xC4,0xF5,0xDB,0xD6,0x63 } },
+{ 11 , { 0x32,0x85,0x4A,0x56,0x1E,0x4B,0xAA,0xC6,0xD3,0xC8,0xED } },
+{ 8 , { 0x0F,0x06,0x72,0x2F,0x17,0xE1,0xCA,0x13 } },
+{ 16 , { 0x37,0x52,0x65,0xC2,0xC7,0xFB,0x89,0xFF,0xC0,0x3F,0xFC,0x71,0x9D,0x25,0x78,0xA0 } },
+{ 11 , { 0x42,0xF2,0x84,0x0F,0x27,0x44,0x0C,0x66,0x46,0xDA,0x5C } },
+{ 16 , { 0x37,0x22,0x51,0x61,0x14,0x17,0xBF,0x7F,0x9F,0x66,0x66,0x5E,0xA9,0xDC,0x8D,0xDB } },
+{ 16 , { 0x3F,0xFE,0xE5,0x71,0x5C,0x57,0xE1,0x45,0x8C,0xBF,0x9B,0x64,0xA3,0xFB,0xF8,0x70 } },
+{ 16 , { 0x37,0x3C,0x21,0x70,0x1E,0xB8,0x7F,0x67,0x87,0xB7,0xAF,0x60,0xB8,0xC3,0x90,0xAE } },
+{ 12 , { 0x43,0xC1,0x59,0xF0,0x0F,0x1B,0x98,0x95,0x23,0x1F,0x78,0xF8 } },
+{ 16 , { 0x07,0xC4,0x9F,0x90,0x47,0x00,0x75,0xAB,0x07,0x98,0xD5,0xE6,0xCE,0x04,0x38,0x1E } },
+{ 13 , { 0x0F,0xD5,0x47,0x57,0xDC,0xE1,0xE1,0xFF,0x4C,0x51,0xFC,0xD4,0x87 } },
+{ 8 , { 0x0F,0xCE,0x8A,0x5C,0xFA,0xDD,0x0E,0x91 } },
+{ 16 , { 0x3F,0x0C,0xE7,0x71,0x60,0x3E,0x73,0x63,0x7C,0x5C,0xD0,0x7C,0xB0,0xD3,0x12,0x07 } },
+{ 16 , { 0x3F,0x48,0xB6,0x42,0x9D,0xA2,0x2E,0x0F,0x84,0xA6,0x63,0xCF,0x3D,0xBA,0x70,0xBA } },
+{ 13 , { 0x44,0x4B,0x8D,0xBB,0x82,0x07,0xED,0xB2,0xDB,0x83,0x50,0xEC,0xB9 } },
+{ 16 , { 0x47,0x58,0x73,0xE5,0x80,0x68,0x3A,0x05,0x0F,0x4F,0x8C,0xCB,0xB0,0x41,0x9D,0x55 } },
+{ 9 , { 0x38,0xDE,0x4B,0x78,0xD8,0x07,0x9F,0x91,0xA7 } },
+{ 16 , { 0x0F,0xDD,0x11,0xF5,0xEA,0xCB,0x86,0x31,0x0F,0xBB,0xE2,0x90,0x54,0x2A,0xF5,0x72 } },
+{ 16 , { 0x07,0x16,0x1A,0x60,0xFE,0x8D,0xBB,0xEE,0x0F,0x82,0xCD,0x90,0xE1,0x7E,0x7A,0x66 } },
+{ 16 , { 0x4F,0x1E,0xBB,0xA1,0xAB,0x6E,0xA9,0x6E,0x0F,0x57,0xCD,0x9B,0x84,0x4C,0x79,0xBA } },
+{ 8 , { 0x07,0xFA,0xD6,0x7D,0xA2,0x3A,0x39,0x5D } },
+{ 16 , { 0x3F,0xB8,0x9E,0xD7,0x7A,0xEA,0x9E,0x94,0xC3,0x09,0x07,0x81,0x77,0xB0,0xFB,0xBC } },
+{ 16 , { 0x37,0x08,0x37,0x2A,0x6F,0xBE,0x2D,0x2D,0x27,0x41,0x41,0x23,0xAA,0x33,0xE4,0x22 } },
+{ 14 , { 0x3D,0x82,0x43,0x9B,0xCA,0x91,0x6C,0x3E,0xBD,0x6E,0xDF,0x30,0x4B,0x30 } },
+{ 8 , { 0x07,0xDB,0x20,0xD6,0xF6,0x82,0x22,0x6A } },
+{ 10 , { 0x39,0x8B,0x3F,0x89,0xD8,0x3A,0x93,0x6B,0x9E,0xC7 } },
+{ 11 , { 0x0F,0xB8,0x7C,0xB1,0x17,0xBD,0x12,0xE4,0x42,0xEF,0xFF } },
+{ 16 , { 0x0F,0x60,0x65,0x98,0x8B,0xA1,0x3F,0x68,0x07,0x6F,0x7D,0xB5,0x1F,0x50,0xE4,0x8C } },
+{ 16 , { 0x3F,0x1A,0x52,0x7B,0x5A,0x8C,0x21,0x96,0xBE,0xEC,0x41,0xCA,0x41,0x4D,0xB3,0x40 } },
+{ 15 , { 0x36,0x19,0xEA,0x24,0x82,0x68,0xF4,0x94,0xD9,0x32,0x88,0x08,0x80,0xD8,0xA8 } },
+{ 15 , { 0x0F,0xC2,0xA8,0x88,0x1A,0x13,0xE9,0x71,0x4E,0xC9,0x44,0x2B,0xF7,0xA7,0xC2 } },
+{ 8 , { 0x07,0xDF,0x40,0x91,0x36,0x50,0x67,0x54 } },
+{ 16 , { 0x3F,0xFC,0x1A,0x13,0xB3,0xC5,0x79,0xE2,0x3C,0x41,0x25,0x51,0x11,0x22,0xE1,0x8E } },
+{ 10 , { 0x49,0xEB,0x07,0x52,0x3D,0x83,0x21,0xE1,0xC6,0xC3 } },
+{ 16 , { 0x37,0x38,0x99,0xD0,0x79,0xBE,0x79,0x36,0x35,0x74,0x36,0x2C,0x35,0x8F,0x68,0x95 } },
+{ 16 , { 0x37,0xB9,0x7E,0x02,0x7D,0xA8,0xD5,0xF7,0x88,0x78,0x5D,0x84,0x12,0x6C,0x61,0x79 } },
+{ 14 , { 0x3D,0xEE,0x31,0xFB,0x94,0x3E,0x12,0xF2,0x48,0x69,0x0B,0x45,0xD0,0xF2 } },
+{ 8 , { 0x07,0x58,0x12,0x06,0xA9,0x9C,0x4E,0xB8 } },
+{ 16 , { 0x3F,0x43,0x49,0x56,0x87,0x35,0x32,0xD9,0xD7,0xF8,0x6A,0x4D,0xD5,0x0D,0xAB,0x41 } },
+{ 8 , { 0x07,0xF2,0x3E,0x03,0x8A,0xCD,0x9A,0x33 } },
+{ 16 , { 0x37,0x2F,0x03,0x02,0xBA,0x6A,0x1D,0xBB,0x04,0x41,0x9A,0x2D,0xFC,0x3D,0x2E,0x8B } },
+{ 11 , { 0x32,0xA9,0x46,0xBA,0x15,0xEB,0x89,0xD9,0x31,0xD9,0x3B } },
+{ 11 , { 0x0F,0xC1,0xBA,0x17,0x15,0xD7,0x5D,0xF2,0x4A,0xF0,0x9A } },
+{ 16 , { 0x0F,0xD6,0x67,0x39,0x57,0xFA,0xA9,0xF4,0x07,0xAA,0x67,0x94,0x43,0x80,0x9F,0x92 } },
+{ 15 , { 0x3E,0xF1,0xD0,0x74,0xAB,0x8C,0x65,0x3C,0x6B,0x9D,0x52,0x4A,0x32,0x85,0xE2 } },
+{ 13 , { 0x0F,0xEC,0x54,0xAB,0x98,0xB4,0xC3,0x60,0x44,0xB1,0x0A,0xFF,0xCC } },
+{ 8 , { 0x0F,0x06,0x90,0x91,0x8F,0xE6,0xB9,0xB0 } },
+{ 16 , { 0x37,0xFE,0x8D,0xDC,0xF0,0xEE,0x13,0xCE,0x52,0xF0,0xCF,0x8E,0xC1,0x0F,0x50,0x53 } },
+{ 16 , { 0x3F,0xDA,0xA8,0xA3,0x0E,0xB0,0xD1,0xF9,0x5B,0x84,0xF3,0xA9,0xF4,0x53,0x30,0x9F } },
+{ 16 , { 0x37,0xD1,0x96,0xCE,0x04,0xB2,0x00,0xB3,0xED,0x9D,0x0B,0xF6,0xC5,0x0C,0x8D,0x11 } },
+{ 13 , { 0x4C,0x3E,0x02,0x0A,0xD3,0x0F,0xF4,0x07,0x05,0x8C,0xB2,0x35,0x58 } },
+{ 8 , { 0x07,0xA8,0xF2,0xC2,0x8D,0x4E,0x09,0x17 } },
+{ 16 , { 0x3F,0xB8,0xF0,0x39,0x43,0x6B,0x99,0x0E,0xF9,0xB5,0x8B,0x4B,0xAB,0xF4,0x89,0x9B } },
+{ 15 , { 0x46,0xDC,0x23,0x96,0xFF,0xDA,0x67,0x07,0x43,0x32,0x86,0x98,0xF4,0x16,0xD8 } },
+{ 16 , { 0x37,0x7E,0x89,0xCC,0x0A,0x11,0x5C,0x15,0x44,0xE0,0x7F,0x07,0xD2,0x84,0xD0,0x89 } },
+{ 8 , { 0x07,0x58,0x0B,0xFB,0x86,0x8A,0x15,0x5B } },
+{ 16 , { 0x37,0xE8,0xC7,0xA5,0xFB,0xCA,0x15,0xA3,0x73,0x21,0x48,0xA5,0x01,0xF8,0x02,0x6D } },
+{ 16 , { 0x47,0x90,0xAD,0xAB,0x23,0x9F,0x1C,0xD1,0x07,0xA5,0x2D,0xDA,0x7D,0xD8,0x1A,0x93 } },
+{ 16 , { 0x3F,0x6C,0x78,0xD0,0x93,0x51,0x32,0x13,0xF5,0x31,0x5B,0x81,0x0A,0xC9,0x7D,0x78 } },
+{ 8 , { 0x07,0x1E,0x5E,0xCA,0x94,0xD5,0xAC,0x36 } },
+{ 16 , { 0x37,0x81,0x62,0x6E,0xF0,0x57,0x7B,0xBD,0xA1,0xC6,0x27,0x43,0xFA,0x94,0x60,0x51 } },
+{ 14 , { 0x45,0xC2,0x9B,0xC0,0x3B,0xC3,0x0F,0xAD,0x27,0x05,0x30,0x42,0x8B,0xB5 } },
+{ 16 , { 0x37,0x41,0xB3,0x68,0x5D,0x45,0x9D,0xF6,0x1B,0xA0,0xA8,0xF8,0xE0,0x3C,0x3B,0xE2 } },
+{ 16 , { 0x4F,0x3B,0xC5,0xDD,0x66,0x4E,0x34,0x4D,0x07,0x1B,0xB7,0xB7,0x91,0x0A,0x16,0x02 } },
+{ 8 , { 0x07,0x4E,0xCA,0xA6,0xC9,0xBB,0xED,0x13 } },
+{ 14 , { 0x35,0x6B,0x54,0x76,0xAF,0xAE,0x99,0x31,0x50,0xA1,0xF6,0xCD,0xD8,0x09 } },
+{ 8 , { 0x07,0x0B,0x8E,0x8D,0x4E,0x76,0x43,0xC3 } },
+{ 9 , { 0x38,0xA0,0xDC,0x85,0x10,0x36,0xAF,0x08,0xCF } },
+{ 16 , { 0x0F,0x2C,0xE0,0x87,0x76,0xF5,0x35,0xE6,0x07,0x36,0x11,0xD5,0x54,0xDE,0x1B,0x5F } },
+{ 8 , { 0x07,0xFD,0xE5,0x38,0x62,0xEB,0x5B,0x3A } },
+{ 12 , { 0x3B,0x8D,0x13,0x42,0xDA,0x9C,0xF7,0x44,0xFA,0xF2,0x36,0x63 } },
+{ 12 , { 0x07,0x81,0x52,0xA9,0x09,0x16,0x1C,0x59,0x43,0xA2,0x94,0x52 } },
+{ 8 , { 0x0F,0x03,0x28,0x69,0x47,0xFD,0x3D,0x02 } },
+{ 16 , { 0x3F,0xE6,0x7D,0x07,0x0B,0xF0,0xAA,0xB6,0xCA,0x0D,0x18,0x55,0x53,0xA0,0x56,0x56 } },
+{ 13 , { 0x3C,0x65,0x7D,0xC0,0x23,0x85,0xDD,0x21,0x69,0x7B,0xFF,0x44,0x9E } },
+{ 8 , { 0x0F,0xCD,0x81,0x71,0x90,0x1B,0x42,0x2B } },
+{ 16 , { 0x3F,0x5E,0x33,0x19,0x91,0xD0,0xA2,0x17,0xA6,0xED,0x02,0x84,0x6F,0x4F,0xC0,0x67 } },
+{ 14 , { 0x45,0x60,0x88,0x51,0xD8,0x54,0x07,0xD5,0xD9,0xC3,0x29,0xF0,0x85,0x98 } },
+{ 16 , { 0x07,0x11,0xED,0x7E,0x4A,0xB5,0x85,0x55,0x0F,0xBA,0xCA,0x55,0xBB,0x39,0x2A,0xA6 } },
+{ 16 , { 0x37,0x11,0x18,0xDE,0x57,0xFE,0x66,0x70,0x2D,0x6C,0x56,0x18,0x7F,0x10,0xDF,0xB6 } },
+{ 10 , { 0x39,0xF8,0x7F,0x56,0xE2,0x3A,0x7B,0x55,0x6A,0xEC } },
+{ 8 , { 0x0F,0x0E,0xAD,0x4D,0x8E,0x00,0x06,0xCB } },
+{ 16 , { 0x37,0xAE,0x90,0xE3,0x86,0xA5,0x5C,0x0F,0x2E,0x20,0x78,0x90,0xED,0x54,0x1F,0x18 } },
+{ 15 , { 0x3E,0x61,0x60,0x83,0x21,0xBE,0xCF,0x2E,0x04,0x91,0x4F,0xB4,0xE3,0x60,0xF3 } },
+{ 16 , { 0x0F,0xA6,0x1F,0x08,0x4F,0x81,0x29,0xEC,0x0F,0x18,0x70,0x0D,0x34,0xE9,0x73,0x64 } },
+{ 8 , { 0x0F,0x79,0x96,0x0D,0x78,0xB1,0x0A,0x32 } },
+{ 16 , { 0x37,0x27,0xB5,0x9E,0xEC,0xCD,0xA0,0xD5,0x36,0x15,0xB1,0x77,0x3A,0x71,0x15,0x70 } },
+{ 15 , { 0x36,0xDA,0xD0,0xF9,0xF8,0xB3,0x39,0x6B,0x2D,0xC4,0xD5,0x4B,0xCC,0xAD,0x27 } },
+{ 16 , { 0x07,0xF0,0x92,0x1C,0x74,0x87,0xB9,0x1E,0x07,0xB0,0x9F,0xB5,0x42,0xC6,0x8E,0x0E } },
+{ 12 , { 0x33,0xBE,0x5E,0x78,0xB1,0x9A,0xD7,0xBE,0x8D,0x8E,0x47,0x8E } },
+{ 16 , { 0x0F,0xD1,0x61,0x6F,0x32,0x27,0x55,0xB0,0x47,0x84,0xDB,0xF3,0x19,0xD7,0xCF,0xA0 } },
+{ 16 , { 0x0F,0x4C,0x5E,0xC6,0xAB,0x62,0xB9,0x1C,0x07,0x23,0xA4,0x04,0xBB,0xB7,0xE8,0x3E } },
+{ 16 , { 0x07,0xB9,0x1D,0xEC,0xDA,0x51,0x7C,0xEE,0x07,0xEF,0x36,0x6F,0x99,0xA7,0x60,0xEE } },
+{ 10 , { 0x31,0xF1,0xA1,0xB0,0x7E,0xF4,0xF0,0xFB,0xD7,0x03 } },
+{ 11 , { 0x07,0xA5,0xD3,0x30,0x8B,0x9E,0x18,0xCA,0x4A,0xFE,0xF8 } },
+{ 8 , { 0x0F,0x3C,0x2C,0x93,0xDE,0xDD,0x4D,0x7D } },
+{ 10 , { 0x31,0x3D,0x04,0x75,0x1D,0xD7,0x88,0xCF,0x79,0x47 } },
+{ 14 , { 0x07,0xB0,0x2F,0x40,0xB4,0xBB,0xCD,0xF8,0x45,0x04,0x36,0xAE,0xDD,0x1E } },
+{ 12 , { 0x07,0x20,0x97,0x04,0xCB,0xCD,0x75,0xF6,0x4B,0xF0,0x67,0xFD } },
+{ 8 , { 0x07,0x63,0x8D,0x9E,0xA6,0x73,0x6C,0x66 } },
+{ 16 , { 0x37,0xDD,0xEE,0x63,0xFB,0x69,0xD9,0x97,0x29,0xCD,0x9C,0x28,0xCB,0xF5,0x84,0x14 } },
+{ 14 , { 0x4D,0x6E,0xC5,0x07,0xD3,0xF9,0x07,0x93,0xD9,0xC3,0xA8,0x73,0xCE,0x2D } },
+{ 16 , { 0x0F,0x50,0xA5,0x8D,0xA4,0x37,0x28,0x5F,0x0F,0x52,0xCD,0xA7,0xDC,0xD4,0x65,0xE2 } },
+{ 15 , { 0x4E,0x8C,0xEF,0x15,0x9C,0xBF,0x86,0x07,0x2E,0x1F,0x32,0xA7,0x2F,0x6B,0x57 } },
+{ 16 , { 0x0F,0x91,0x68,0xD0,0x0B,0x9C,0xD5,0xE4,0x0F,0xFF,0x25,0x1C,0x00,0xF7,0xAB,0xFD } },
+{ 16 , { 0x3F,0x13,0x90,0x4A,0x31,0xAA,0x30,0xFD,0x23,0x42,0x47,0x48,0x93,0x6A,0x67,0xE1 } },
+{ 16 , { 0x37,0x18,0x15,0x7E,0xC8,0x54,0xB6,0x4E,0x2A,0xC6,0x5E,0x7B,0x10,0x33,0x6E,0x4A } },
+{ 16 , { 0x3F,0x1F,0x68,0xD6,0xE9,0xC4,0x67,0x0A,0x85,0x73,0x8F,0x2C,0xED,0xBF,0x28,0x05 } },
+{ 10 , { 0x49,0xC3,0x07,0x50,0x3B,0x78,0xBE,0x7A,0xEC,0x55 } },
+{ 16 , { 0x37,0xA6,0x01,0x77,0x03,0x70,0xA6,0xAF,0x1D,0x20,0x64,0xB5,0xD1,0x65,0xAA,0xAF } },
+{ 12 , { 0x3B,0x66,0x4A,0x9E,0x1C,0x9B,0xBF,0xC2,0xBD,0xE1,0x2D,0xC8 } },
+{ 8 , { 0x07,0xE8,0xD1,0x66,0x37,0x01,0x14,0xB8 } },
+{ 9 , { 0x30,0xA6,0xD6,0xD4,0x63,0x39,0x57,0x59,0x07 } },
+{ 16 , { 0x0F,0xDF,0x1B,0xDB,0xE2,0xBA,0x2B,0x24,0x0F,0x7B,0xBB,0x49,0x89,0xC8,0x66,0x1F } },
+{ 8 , { 0x07,0x9E,0x4E,0x3E,0x1A,0x84,0xC2,0x54 } },
+{ 16 , { 0x37,0xD7,0x37,0x60,0x62,0xC9,0x78,0x31,0x90,0xC7,0xA2,0x94,0xF0,0x52,0xC4,0xF9 } },
+{ 16 , { 0x3F,0x05,0x4D,0xE0,0xE2,0x40,0xA7,0x92,0x03,0x1C,0xB0,0x0B,0xED,0xFF,0x7D,0xE9 } },
+{ 10 , { 0x39,0xDE,0xA0,0x71,0x01,0x82,0xA7,0x55,0x2A,0x84 } },
+{ 8 , { 0x0F,0x15,0x60,0xBF,0xAE,0x55,0xDF,0xE3 } },
+{ 16 , { 0x3F,0x75,0xB1,0x9F,0x82,0x1A,0x65,0x0D,0x59,0x65,0x2F,0x10,0x51,0xA8,0x95,0x7D } },
+{ 10 , { 0x41,0xD2,0x0F,0x44,0x8F,0x80,0x6C,0xF0,0x4B,0x43 } },
+{ 12 , { 0x0F,0x28,0x34,0xC5,0x8D,0x81,0xD1,0xBE,0x43,0x77,0x0A,0x5D } },
+{ 8 , { 0x07,0xD9,0xBA,0x5C,0xE1,0xD0,0x70,0x8E } },
+{ 16 , { 0x3F,0x93,0xDC,0x98,0x4F,0x52,0xBC,0x9E,0x11,0x1A,0x45,0x53,0x67,0xE4,0x49,0x3F } },
+{ 13 , { 0x4C,0xA0,0xA1,0x4B,0xD1,0x07,0x25,0x20,0xC2,0x6E,0x39,0x89,0x4C } },
+{ 16 , { 0x07,0x87,0x44,0xBF,0x88,0x9A,0x36,0x6D,0x07,0xB4,0x0A,0x8E,0xAD,0x38,0x07,0xA2 } },
+{ 15 , { 0x4E,0x41,0x05,0xA4,0x52,0x84,0x93,0x07,0x50,0xDD,0x56,0x01,0x5A,0x8B,0xAE } },
+{ 16 , { 0x3F,0x5F,0x20,0xA9,0xC3,0x5E,0x96,0xE1,0xAD,0x1F,0x47,0x05,0x73,0xBA,0x67,0x30 } },
+{ 16 , { 0x3F,0x8B,0x9C,0x55,0x2E,0x6A,0x7F,0x88,0x87,0x61,0xDA,0x61,0x85,0xE1,0x6D,0xD4 } },
+{ 16 , { 0x3F,0xA1,0x4B,0xD7,0x69,0xD3,0xF0,0xB5,0x84,0x23,0xFF,0x2E,0x75,0x1C,0x3D,0x29 } },
+{ 9 , { 0x30,0x39,0x00,0xC9,0xFA,0x81,0x8D,0xEC,0x39 } },
+{ 8 , { 0x0F,0x2E,0x6E,0x74,0x4A,0x61,0xCF,0x65 } },
+{ 16 , { 0x3F,0x47,0x90,0xE3,0x6B,0x9D,0x69,0x94,0xF6,0x41,0x74,0xD4,0xA8,0x6E,0xFF,0x1A } },
+{ 11 , { 0x3A,0x51,0xCA,0xC7,0xFB,0x0F,0x80,0x84,0x69,0xA5,0x77 } },
+{ 16 , { 0x0F,0x02,0x65,0xA8,0x3C,0x56,0x34,0x5A,0x07,0x1D,0xFB,0xB0,0x28,0x1C,0xF2,0x46 } },
+{ 14 , { 0x45,0x3E,0x3B,0xCD,0xB4,0x0D,0x07,0x19,0x55,0x8D,0x5C,0x47,0x5C,0xEE } },
+{ 12 , { 0x43,0x40,0x9A,0xA5,0x0F,0x85,0x9F,0x44,0xD6,0x13,0x96,0x52 } },
+{ 16 , { 0x3F,0x4A,0x42,0x0D,0xEA,0x94,0x6F,0xF2,0x71,0xE0,0xF4,0xCE,0xE8,0x06,0xB9,0x70 } },
+{ 16 , { 0x37,0x42,0x01,0x45,0xFB,0x15,0x97,0xB9,0xDB,0x1D,0x6F,0x85,0x2E,0xCF,0xFB,0x46 } },
+{ 16 , { 0x3F,0xB0,0x3F,0x54,0xAE,0x7B,0xD1,0xCB,0xB9,0xE3,0x61,0x66,0x45,0xAD,0x8A,0xD4 } },
+{ 13 , { 0x44,0x77,0x86,0x5D,0x20,0x07,0x55,0xD0,0xB1,0xE4,0x79,0x66,0xC5 } },
+{ 8 , { 0x07,0x97,0xBB,0x36,0xC6,0xCA,0x63,0x7B } },
+{ 14 , { 0x35,0xFE,0x06,0x3A,0xB5,0x7A,0x96,0x81,0x71,0x20,0xB7,0x92,0x02,0xA4 } },
+{ 8 , { 0x07,0x4C,0xED,0x96,0x46,0x61,0xEE,0x30 } },
+{ 16 , { 0x3F,0xFF,0x0D,0x10,0xE7,0x39,0x25,0xC2,0xCA,0xBC,0x8B,0x3D,0x5A,0x44,0xA4,0xF8 } },
+{ 15 , { 0x46,0xEB,0xAA,0x98,0xE9,0x2C,0xBD,0x07,0x01,0x63,0x82,0x19,0x65,0x31,0x84 } },
+{ 16 , { 0x3F,0x58,0xFA,0x1E,0x5D,0x4E,0x9A,0xCF,0x1C,0x51,0x7B,0xE2,0x8D,0xE6,0xA2,0x10 } },
+{ 16 , { 0x37,0x94,0x7B,0x52,0x03,0xC5,0x18,0x86,0xB6,0xD1,0x44,0x3B,0xBD,0x69,0xDC,0x21 } },
+{ 16 , { 0x3F,0xB9,0x57,0xEA,0xA5,0x13,0xBE,0x6B,0xF3,0x0A,0x54,0x85,0x8D,0x77,0x44,0x69 } },
+{ 16 , { 0x37,0x29,0xB7,0xE1,0xAD,0xC0,0x47,0x53,0xB2,0x3F,0x10,0x9E,0xDC,0x70,0x71,0x22 } },
+{ 16 , { 0x3F,0x14,0xCA,0x0D,0x42,0x9B,0x02,0x25,0xD5,0x43,0xBD,0xB4,0xB4,0xF4,0x0E,0x8A } },
+{ 14 , { 0x4D,0xE6,0xF8,0xC8,0x36,0x22,0x07,0x67,0xC0,0x28,0x4F,0xB4,0xF0,0xBF } },
+{ 13 , { 0x44,0xB0,0x86,0x2E,0x98,0x07,0x5A,0x2B,0x23,0x14,0x75,0x08,0x85 } },
+{ 12 , { 0x4B,0x37,0x90,0x92,0x0F,0x69,0x7F,0x43,0xE5,0x5E,0x1D,0xBA } },
+{ 16 , { 0x37,0x6F,0xED,0x83,0x81,0x1B,0x11,0x4C,0x27,0x82,0x22,0x32,0x74,0xCB,0xBF,0xB4 } },
+{ 16 , { 0x37,0x8E,0xFC,0xDC,0x2D,0x93,0xA8,0x19,0x58,0x86,0x3B,0x74,0xB0,0xB7,0x79,0x5C } },
+{ 16 , { 0x47,0x0E,0xA6,0xEF,0xBF,0x9B,0xAF,0x73,0x07,0xAB,0xDE,0xF0,0x70,0x07,0xBA,0xCB } },
+{ 11 , { 0x4A,0x43,0xCC,0x07,0x69,0x9B,0xED,0x59,0x5C,0x91,0xED } },
+{ 9 , { 0x30,0xEB,0xA0,0xA2,0x75,0xD2,0x2B,0xA3,0x52 } },
+{ 16 , { 0x07,0xF3,0xB4,0xA9,0x75,0x4C,0x97,0xC6,0x07,0x33,0x44,0x76,0x7A,0xD1,0xF2,0x4E } },
+{ 16 , { 0x07,0x65,0x1C,0xAB,0xE1,0x9E,0x83,0xCC,0x0F,0x77,0x0B,0xB9,0x11,0x65,0x59,0x4A } },
+{ 15 , { 0x0F,0x45,0xDD,0xE8,0x58,0x2B,0x7B,0xB0,0x46,0x55,0x36,0x83,0x02,0xC7,0xED } },
+{ 16 , { 0x0F,0x8F,0xB9,0x0D,0xB4,0xA1,0x23,0x21,0x0F,0x35,0x51,0x00,0xD1,0xC9,0x1C,0x59 } },
+{ 13 , { 0x3C,0x89,0x2D,0x0D,0x45,0x36,0x2F,0x46,0x28,0xDC,0x43,0x95,0xE1 } },
+{ 8 , { 0x0F,0x77,0x09,0x07,0x56,0xBC,0x50,0xD4 } },
+{ 16 , { 0x37,0x9C,0x70,0x02,0xEE,0x41,0xB2,0x36,0xA7,0x99,0x6E,0x5E,0xAD,0xAB,0x1B,0x01 } },
+{ 16 , { 0x3F,0x8A,0xA8,0xBD,0x6E,0x6A,0x74,0x37,0xF7,0x2A,0x89,0x47,0x91,0x75,0x4C,0xFB } },
+{ 14 , { 0x45,0xE5,0x74,0xB2,0xBB,0x6E,0x0F,0x3B,0xC4,0x2E,0x57,0xDA,0x90,0x9B } },
+{ 12 , { 0x3B,0xD1,0xB0,0xFC,0x79,0xBD,0xF5,0xB8,0xA4,0x63,0x37,0x97 } },
+{ 16 , { 0x0F,0x54,0xEA,0x19,0x33,0x1F,0x43,0x1E,0x0F,0xE7,0x32,0x43,0xAE,0x27,0xFB,0xD2 } },
+{ 8 , { 0x0F,0x3A,0x48,0x55,0x48,0x5A,0x16,0x0E } },
+{ 11 , { 0x3A,0xBF,0xA9,0x8D,0x02,0x34,0x58,0x6D,0xE0,0x89,0x6A } },
+{ 8 , { 0x0F,0x84,0xDF,0xCA,0xFD,0x33,0x0C,0xFF } },
+{ 12 , { 0x3B,0x6D,0x30,0x86,0x93,0x33,0x8B,0xBD,0x86,0xFE,0x86,0xDB } },
+{ 8 , { 0x07,0x98,0x0C,0x52,0x0F,0xC3,0x23,0x6A } },
+{ 10 , { 0x39,0x89,0xF5,0x34,0x03,0xF0,0xAE,0x70,0xA0,0x33 } },
+{ 11 , { 0x0F,0x12,0x47,0x09,0x2D,0x0F,0xBC,0xF8,0x42,0x67,0xAE } },
+{ 14 , { 0x07,0xED,0x76,0x41,0xC2,0xD3,0x39,0xDE,0x45,0x4F,0x2B,0x2E,0x2C,0x89 } },
+{ 14 , { 0x07,0xFB,0xBA,0x30,0xC0,0xDD,0xF5,0x06,0x45,0x10,0x62,0x58,0x63,0xA0 } },
+{ 8 , { 0x07,0xED,0xA3,0x2A,0xAE,0x0F,0x91,0xDB } },
+{ 16 , { 0x3F,0xB1,0xC1,0xF6,0xEF,0x12,0x9B,0x3E,0x65,0xF7,0x4F,0x21,0x31,0xB8,0x2E,0x23 } },
+{ 12 , { 0x3B,0x9C,0xD2,0xE4,0x4C,0xAD,0x3F,0xF1,0x3D,0xF7,0xBD,0x56 } },
+{ 12 , { 0x07,0x01,0xEA,0x75,0xF4,0x2A,0xD3,0xC6,0x4B,0xDC,0x4C,0x6A } },
+{ 16 , { 0x0F,0xA2,0x38,0xE3,0xBF,0x4E,0x78,0x83,0x0F,0xCC,0x5A,0x4E,0x96,0xB0,0x2E,0xFA } },
+{ 8 , { 0x07,0xE8,0x5A,0x55,0x26,0x2C,0xB5,0x1D } },
+{ 16 , { 0x3F,0x26,0xEF,0x93,0x95,0x13,0x6A,0x36,0xE3,0x81,0x81,0x9A,0x6C,0x00,0x21,0x60 } },
+{ 16 , { 0x3F,0x6D,0xF1,0x70,0x5F,0x19,0xDD,0xB9,0x28,0xB1,0xE8,0x06,0xF1,0x35,0x7F,0x14 } },
+{ 16 , { 0x37,0xAE,0x87,0x10,0xD7,0xCF,0x8F,0xD6,0xBF,0x53,0x76,0x3A,0xD4,0x94,0x1A,0xEC } },
+{ 16 , { 0x37,0xC5,0x41,0xC5,0x2A,0x32,0x72,0x9A,0x4A,0x62,0x88,0xD3,0x1E,0x58,0xED,0x5A } },
+{ 16 , { 0x37,0x41,0x33,0xA6,0xB2,0x4C,0xF2,0x01,0x92,0x14,0xBD,0x7D,0xB2,0x3F,0xEF,0xE1 } },
+{ 16 , { 0x3F,0xEC,0x09,0xF1,0x3D,0x09,0xFE,0x0B,0xA9,0xEA,0xAB,0x45,0x72,0xA4,0x1F,0x43 } },
+{ 15 , { 0x3E,0x3D,0xD0,0x37,0xBA,0xE9,0xB6,0xDE,0xE4,0xAF,0x22,0x7A,0x18,0x48,0xEE } },
+{ 8 , { 0x0F,0x05,0xF1,0x64,0x74,0x28,0x1B,0x93 } },
+{ 16 , { 0x37,0x47,0x68,0xA8,0x7F,0x0E,0x0A,0xD4,0x6C,0xC0,0x0D,0xF0,0x82,0x86,0x83,0x1E } },
+{ 16 , { 0x37,0xBD,0x51,0x92,0x8E,0xCE,0x04,0x83,0x95,0xBC,0xAB,0x2A,0x2B,0x5D,0x5D,0x85 } },
+{ 16 , { 0x3F,0x39,0x1C,0x2C,0x62,0x37,0x74,0xF4,0xBF,0xB1,0x96,0x75,0xBC,0x6B,0x81,0xFD } },
+{ 16 , { 0x37,0x24,0xC9,0xFA,0x39,0xD8,0xC1,0x40,0x49,0x78,0x4A,0x0A,0xAB,0x0E,0x6F,0x34 } },
+{ 16 , { 0x3F,0xB0,0x13,0xBA,0x55,0x70,0x67,0x51,0x34,0x87,0xA9,0x8C,0x5B,0x4F,0x6A,0x14 } },
+{ 16 , { 0x37,0xC9,0x85,0xCD,0xFB,0xF9,0x87,0x68,0x1B,0xB6,0xB6,0xED,0x4A,0x03,0xC5,0xE3 } },
+{ 16 , { 0x37,0xA8,0x1D,0xFA,0x88,0xBA,0x0E,0x45,0x98,0x9C,0xCC,0x15,0xCC,0x6C,0x34,0xC6 } },
+{ 16 , { 0x37,0x12,0x71,0x87,0x21,0xD8,0x35,0x81,0xFE,0x50,0xEB,0x70,0x9B,0x3D,0x0F,0x24 } },
+{ 16 , { 0x37,0x48,0x21,0xC0,0x54,0xEB,0x80,0xBE,0x58,0x2C,0x7A,0xBF,0xE1,0x55,0xAC,0x0A } },
+{ 16 , { 0x3F,0xAC,0xE6,0x81,0x16,0xE1,0x94,0x35,0x9E,0x3F,0x44,0x01,0xD9,0x39,0xF6,0x96 } },
+{ 16 , { 0x3F,0x87,0x2E,0xC2,0x20,0x44,0x09,0x82,0xD5,0x5A,0xF0,0x5C,0x4F,0x4A,0x24,0xE4 } },
+{ 16 , { 0x37,0x58,0x7B,0x6F,0x8C,0xF9,0x84,0x6A,0x60,0xDB,0xB7,0xBB,0x2C,0x13,0xBF,0x2B } },
+{ 16 , { 0x37,0xD8,0x21,0x0F,0x40,0x35,0x0E,0x46,0x72,0x27,0x4A,0x4E,0x88,0x8E,0x27,0xF8 } },
+{ 10 , { 0x39,0x8C,0x56,0x15,0xF5,0xE2,0xAA,0x99,0x98,0x80 } },
+{ 8 , { 0x0F,0x5A,0x04,0xD3,0x73,0x75,0x7D,0x5A } },
+{ 14 , { 0x35,0xC7,0x99,0x87,0xBC,0xC8,0x19,0xF8,0xC0,0xFA,0xAD,0x03,0xF7,0xE5 } },
+{ 8 , { 0x07,0x7F,0xA5,0xD1,0xCC,0x2F,0xA2,0x83 } },
+{ 16 , { 0x3F,0x53,0xD7,0xC5,0xE9,0xD5,0xC2,0x72,0xAC,0x4F,0xF9,0xE1,0x13,0x0E,0x8B,0x76 } },
+{ 16 , { 0x3F,0x9C,0xFD,0xFC,0x8B,0x2A,0x8C,0x58,0x20,0xC5,0x4B,0x79,0x5A,0x7A,0xC8,0x35 } },
+{ 16 , { 0x37,0x52,0x61,0x5D,0x2C,0x37,0x3C,0x7C,0x27,0x2B,0x56,0x28,0xA4,0x29,0x89,0x0E } },
+{ 16 , { 0x3F,0xDE,0x96,0x85,0x21,0x5B,0x42,0x0E,0x23,0xD3,0xBF,0xDC,0x3C,0x36,0x55,0xE5 } },
+{ 16 , { 0x3F,0xE6,0x7E,0x72,0x37,0x4E,0x37,0xEB,0x3E,0x80,0xEE,0x8F,0xED,0x4C,0xBE,0xE0 } },
+{ 11 , { 0x3A,0xF7,0xAD,0xD0,0x67,0x3F,0xFA,0x83,0xD9,0x46,0xC5 } },
+{ 8 , { 0x07,0x41,0xDB,0x56,0x6C,0xEF,0xDF,0xA9 } },
+{ 16 , { 0x3F,0x7B,0x59,0xE3,0x57,0x3A,0x43,0x46,0xA3,0xFB,0x1B,0xC4,0xCD,0x40,0x5B,0xBB } },
+{ 16 , { 0x3F,0x3D,0x37,0x62,0xE9,0x61,0x90,0x2C,0xAA,0x1C,0x53,0xCD,0x16,0x3D,0xEA,0xE9 } },
+{ 16 , { 0x37,0x5E,0xAC,0xDC,0x22,0xD4,0x48,0xE1,0x0E,0x2E,0x46,0xB4,0xFC,0xD7,0x92,0xB9 } },
+{ 16 , { 0x37,0x00,0x45,0xE4,0x2C,0x11,0xB7,0x3A,0x79,0x67,0x7F,0x45,0x86,0xB2,0xE5,0xD8 } },
+{ 10 , { 0x41,0x4F,0x07,0x91,0x17,0x0B,0xDD,0x28,0xDE,0x9F } },
+{ 16 , { 0x3F,0x9B,0x06,0x46,0x87,0xF1,0x83,0x1F,0xDD,0xE4,0x4D,0xD4,0xAB,0x0F,0x51,0x8E } },
+{ 16 , { 0x37,0x01,0x73,0x10,0x44,0x79,0xF4,0x00,0x00,0x55,0x5D,0x87,0x88,0xFD,0x11,0x5D } },
+{ 11 , { 0x32,0x78,0x0B,0xA8,0x77,0x42,0x2B,0xD6,0xB5,0xFC,0x55 } },
+{ 8 , { 0x0F,0x8D,0x29,0x21,0xFD,0x22,0xCA,0xB7 } },
+{ 16 , { 0x37,0x08,0x2C,0x76,0xDA,0x2B,0xDC,0x12,0xAB,0xC0,0x94,0xC5,0x1D,0x6D,0x7F,0x0B } },
+{ 16 , { 0x37,0xB6,0x4A,0xC6,0xE0,0x36,0xC6,0x51,0x27,0x90,0x3B,0xAA,0xDD,0x85,0x62,0xBC } },
+{ 16 , { 0x3F,0xA0,0x29,0x29,0x43,0xB0,0x96,0x14,0xF9,0x6B,0x86,0xBD,0xBD,0xAD,0x99,0x85 } },
+{ 16 , { 0x3F,0xB0,0x4F,0x3B,0x70,0x33,0xB4,0x4D,0x51,0xA8,0x61,0xAA,0xDF,0x6F,0xDC,0x4B } },
+{ 16 , { 0x37,0x1C,0x91,0x82,0xCC,0xF8,0x51,0x02,0xE3,0x2C,0x29,0x76,0x02,0x2E,0x48,0x3D } },
+{ 16 , { 0x4F,0x93,0x5F,0x26,0xA3,0xA8,0x6A,0x4B,0x07,0xEA,0x6C,0x7C,0xED,0x1A,0x18,0x89 } },
+{ 13 , { 0x3C,0x35,0xDE,0xE4,0xF2,0x10,0xC7,0x6B,0xF3,0x4A,0x92,0x71,0xFC } },
+{ 16 , { 0x07,0xAC,0xD9,0x0E,0xBB,0x10,0xFA,0xF4,0x07,0xB6,0x10,0x48,0x8B,0x75,0x88,0x08 } },
+{ 8 , { 0x0F,0x48,0xCC,0x6D,0xC4,0x40,0x1F,0xAD } },
+{ 9 , { 0x38,0x46,0x81,0xAD,0x86,0x94,0x7F,0x98,0xFA } },
+{ 8 , { 0x07,0x9C,0xEB,0x03,0x7C,0x62,0xB9,0x25 } },
+{ 16 , { 0x3F,0x8D,0xC0,0x24,0xF9,0x4E,0xB5,0xE0,0x05,0x37,0xBE,0x8A,0x8A,0xCC,0xE1,0x9B } },
+{ 16 , { 0x3F,0xED,0xD6,0x84,0x39,0x2D,0xAD,0xF2,0xD1,0xC9,0x98,0x58,0xD3,0xBB,0x7D,0x4A } },
+{ 16 , { 0x47,0x6D,0x97,0x3E,0x93,0xF7,0x16,0xFE,0x07,0x82,0xA5,0xD2,0x9A,0xF0,0x19,0x3C } },
+{ 16 , { 0x3F,0x68,0x5C,0x5A,0x3F,0xA7,0xE7,0x42,0xC6,0x2A,0x6C,0x3B,0xE7,0xC7,0x7B,0xE1 } },
+{ 11 , { 0x42,0xCB,0x39,0x07,0x59,0x5C,0x8C,0xF3,0xB1,0x46,0x37 } },
+{ 16 , { 0x3F,0x3B,0xC2,0x98,0xBD,0x94,0x10,0x15,0xBC,0x76,0xA0,0x98,0x8E,0x6F,0x09,0xEA } },
+{ 12 , { 0x4B,0x9E,0x75,0x9C,0x0F,0x2E,0xED,0xEE,0x09,0x3B,0x0F,0xDF } },
+{ 16 , { 0x0F,0x70,0x5B,0x7D,0x1A,0x36,0x09,0x14,0x0F,0x18,0xDD,0x9D,0x72,0x99,0x10,0x51 } },
+{ 16 , { 0x37,0x46,0x82,0x0C,0xF3,0xF5,0xA7,0x33,0xFD,0xD3,0x54,0xDE,0xC0,0x97,0xEF,0x49 } },
+{ 11 , { 0x4A,0x61,0xE7,0x07,0xE6,0x7F,0x70,0xB9,0xC2,0xBC,0x1B } },
+{ 16 , { 0x07,0xCC,0x93,0x86,0xE0,0x2B,0x4D,0x3D,0x07,0x23,0x8A,0x2F,0xD7,0x49,0x9A,0x6D } },
+{ 8 , { 0x07,0x0A,0xCF,0x3A,0x24,0x67,0x2A,0x63 } },
+{ 11 , { 0x3A,0xC2,0xC9,0x06,0x90,0xBD,0x45,0x5D,0xAB,0xFC,0x7C } },
+{ 13 , { 0x0F,0x5C,0x63,0xB6,0xE8,0xF8,0x4C,0x03,0x4C,0x13,0xC5,0x44,0x45 } },
+{ 16 , { 0x0F,0xB5,0x7F,0xFF,0xF8,0x2C,0xA7,0x7A,0x4F,0xD1,0xAA,0x18,0x7A,0x42,0xE7,0x6A } },
+{ 8 , { 0x07,0x56,0xFD,0xCA,0x84,0x27,0x09,0xA0 } },
+{ 15 , { 0x36,0x5F,0x77,0x76,0x77,0x10,0xEE,0x1D,0x1B,0x5D,0x32,0xCB,0xC5,0x1F,0x1E } },
+{ 15 , { 0x07,0x49,0x7D,0x86,0xE2,0x53,0x2A,0x36,0x46,0xC3,0xC2,0x2D,0xCB,0xBB,0xC4 } },
+{ 16 , { 0x0F,0xDC,0x74,0x41,0xCA,0xC6,0x87,0xC5,0x07,0x24,0x52,0x58,0x1B,0x73,0xE3,0xDF } },
+{ 15 , { 0x46,0x69,0x5B,0xFF,0x46,0xA8,0xD0,0x07,0xE3,0x46,0x2C,0x1B,0xA6,0x12,0x30 } },
+{ 16 , { 0x37,0xD4,0xE0,0xD1,0xDA,0x09,0xE6,0x65,0x3B,0xC6,0x2C,0xA9,0x8A,0x5B,0x59,0xF8 } },
+{ 16 , { 0x37,0x6A,0x6D,0x61,0x48,0x58,0x13,0xB1,0x48,0xE9,0xD9,0x0F,0x8E,0x22,0x30,0x9D } },
+{ 16 , { 0x37,0x84,0xE6,0x21,0xFD,0x23,0xA9,0x85,0x23,0x52,0x68,0x2C,0xDE,0x07,0x9F,0x06 } },
+{ 16 , { 0x37,0xBF,0x16,0xA5,0x7E,0x14,0x45,0xE2,0x20,0xDC,0x77,0x5E,0xF1,0xF8,0xB8,0xB2 } },
+{ 16 , { 0x3F,0x0D,0x41,0x9B,0x88,0x55,0x39,0x4A,0x33,0xA9,0x0F,0x26,0x8B,0xFC,0x70,0xAC } },
+{ 10 , { 0x41,0x70,0x0F,0x76,0xBD,0x5A,0xED,0x08,0x09,0x04 } },
+{ 16 , { 0x0F,0xEA,0x6E,0x20,0xC8,0xD3,0x19,0xA3,0x07,0x60,0x16,0x50,0x6C,0xC9,0x4B,0x6F } },
+{ 11 , { 0x32,0x97,0x0F,0x94,0x24,0x6C,0x5F,0x97,0xC2,0xE2,0x55 } },
+{ 13 , { 0x0F,0x7C,0x3E,0xA8,0x8C,0xC4,0xF4,0x83,0x44,0x24,0x5A,0x1B,0xF2 } },
+{ 8 , { 0x07,0x01,0xC5,0x03,0x17,0x44,0xB9,0x97 } },
+{ 16 , { 0x37,0x75,0x9A,0xD9,0x9C,0x26,0x49,0x09,0xDF,0xCB,0x23,0x2E,0xF6,0xBD,0xB3,0x92 } },
+{ 11 , { 0x32,0xE5,0xCF,0x57,0x9C,0xF4,0x13,0x27,0xC8,0xD8,0xD9 } },
+{ 11 , { 0x0F,0xCE,0xF0,0x4A,0x6C,0xDF,0x4F,0xF5,0x4A,0xB2,0x1D } },
+{ 8 , { 0x0F,0x32,0xC1,0x9A,0xAC,0x00,0xB0,0x79 } },
+{ 16 , { 0x3F,0xEB,0x6B,0x6A,0x75,0xE5,0x01,0x4A,0x73,0x44,0x54,0x49,0x34,0xA9,0x9A,0x1A } },
+{ 16 , { 0x4F,0x7D,0xBE,0x96,0xC1,0x63,0x46,0x61,0x07,0xAC,0x09,0x7D,0x47,0xDC,0x62,0xB3 } },
+{ 14 , { 0x35,0x6F,0x4E,0x24,0xCB,0x25,0x62,0xA6,0xAB,0x37,0xE2,0xAC,0xE3,0x13 } },
+{ 16 , { 0x07,0x93,0x60,0x60,0xB1,0x8D,0xC6,0xBB,0x07,0x29,0xBC,0x5C,0x13,0x8D,0x39,0xF4 } },
+{ 8 , { 0x0F,0xAF,0x57,0xC7,0xB8,0x9E,0x72,0x0F } },
+{ 16 , { 0x37,0xF0,0xC3,0x26,0xAA,0x26,0x48,0x7C,0x42,0xCA,0xB8,0x23,0x1B,0xC4,0xE8,0xB3 } },
+{ 15 , { 0x46,0x67,0xC8,0xF8,0x0A,0x70,0x94,0x07,0x3C,0xF5,0xC8,0x66,0xE9,0x14,0x0C } },
+{ 15 , { 0x36,0xA5,0x8E,0x38,0x1A,0xED,0x60,0x56,0x31,0x78,0xDE,0x6A,0x96,0xE3,0xEE } },
+{ 16 , { 0x0F,0xAC,0x49,0xAD,0xBB,0x3B,0xCA,0x70,0x07,0xF7,0x4E,0xFC,0xE8,0x34,0x3E,0x7E } },
+{ 8 , { 0x0F,0xE4,0xAE,0xEE,0x2B,0x08,0xEE,0xD0 } },
+{ 16 , { 0x3F,0xE7,0x40,0x35,0x54,0xDF,0x0F,0x71,0x4A,0x92,0xC3,0xDF,0x8B,0x52,0x72,0xE7 } },
+{ 12 , { 0x33,0x3C,0x92,0x3B,0xA2,0x2F,0x2D,0xD5,0x38,0xBB,0xF4,0xC1 } },
+{ 8 , { 0x0F,0x07,0xFC,0x05,0xBB,0x58,0x06,0x5A } },
+{ 9 , { 0x38,0x37,0x9A,0x45,0x6F,0x99,0xCE,0xC9,0xF6 } },
+{ 16 , { 0x0F,0x72,0x45,0xC8,0x00,0x0D,0x68,0xAA,0x07,0xDE,0xDF,0x82,0x69,0x0E,0x32,0xE9 } },
+{ 16 , { 0x07,0x78,0xC1,0x67,0x9E,0x54,0x8A,0x2B,0x07,0xEA,0xA7,0x77,0xD4,0x9E,0xE5,0xE3 } },
+{ 8 , { 0x07,0xB6,0xB9,0xFE,0xBE,0xD9,0x74,0x8A } },
+{ 12 , { 0x33,0x88,0x98,0xA2,0xC2,0x9F,0x73,0x68,0x12,0xAB,0xC5,0x1C } },
+{ 8 , { 0x07,0xBB,0xD3,0x37,0x63,0x4C,0x82,0x3F } },
+{ 16 , { 0x3F,0xD3,0xD1,0xD6,0x5A,0xED,0x66,0xB7,0xAB,0x9F,0x84,0xE6,0xE5,0x0F,0x1E,0x93 } },
+{ 16 , { 0x37,0xFB,0x70,0x41,0x8C,0xD8,0x54,0x2A,0x99,0xD0,0x57,0x8F,0xE7,0x09,0x91,0x3C } },
+{ 16 , { 0x37,0x5B,0x65,0x7A,0x89,0x19,0xF8,0xAD,0x6E,0x25,0x02,0x48,0xA4,0xBE,0xE2,0xD2 } },
+{ 16 , { 0x3F,0x2C,0x56,0x91,0xB0,0xFA,0x21,0x6E,0x88,0xC0,0x24,0x84,0x93,0xBA,0xC7,0x6E } },
+{ 16 , { 0x3F,0xD6,0x00,0x15,0x3F,0x12,0x31,0x6D,0x12,0x53,0x27,0xDC,0xAC,0x8C,0x77,0xED } },
+{ 13 , { 0x44,0xD3,0x8E,0xEF,0xE2,0x0F,0x81,0xD6,0xCB,0xBA,0xA0,0x64,0x40 } },
+{ 16 , { 0x37,0xDC,0x24,0xEA,0x2D,0xCB,0x61,0xA7,0x1A,0x97,0xFF,0x6B,0xA0,0x5C,0xB8,0xF9 } },
+{ 16 , { 0x37,0x30,0x53,0x4C,0x24,0x5D,0x31,0x12,0x57,0x02,0x7C,0x0E,0x41,0x80,0x79,0xC1 } },
+{ 10 , { 0x49,0xC8,0x0F,0x23,0x35,0xC5,0xD2,0x8A,0xC9,0x16 } },
+{ 16 , { 0x37,0x3C,0xED,0x06,0x89,0xCA,0x5C,0xE6,0x02,0x2E,0x09,0xA2,0xC3,0xF0,0x64,0x32 } },
+{ 16 , { 0x0F,0xF2,0x4F,0x8F,0xDE,0x9F,0xBA,0x5C,0x0F,0x67,0xB2,0xC5,0xB9,0x28,0xCC,0x2E } },
+{ 16 , { 0x07,0xF8,0xE1,0xF2,0x5E,0xFF,0xCE,0xC6,0x07,0x9F,0x9D,0x23,0x64,0xAC,0x9B,0x67 } },
+{ 16 , { 0x07,0x2A,0x4C,0x3D,0x14,0xBB,0xD4,0x31,0x0F,0x0C,0x24,0xD2,0x12,0x8C,0xD1,0x65 } },
+{ 16 , { 0x37,0x12,0x02,0x1B,0xEC,0x92,0xEF,0x9E,0x56,0xA7,0x96,0x6E,0xB2,0x8D,0x12,0x2F } },
+{ 16 , { 0x37,0xAB,0x09,0x10,0x3C,0x5C,0x1C,0xE5,0x4A,0x38,0x19,0xC8,0x7A,0xA9,0x7C,0x60 } },
+{ 16 , { 0x3F,0x05,0xDE,0x7F,0x76,0x75,0x33,0x73,0x43,0x68,0xB4,0xC2,0xD0,0xA8,0x47,0xAC } },
+{ 16 , { 0x3F,0x40,0xE3,0xB5,0x09,0xF4,0xF0,0x07,0x1A,0x4E,0x61,0x25,0x0D,0x25,0x34,0x28 } },
+{ 16 , { 0x3F,0x77,0xA1,0xA0,0xC2,0x84,0x9F,0x70,0xF0,0x5F,0x71,0x0E,0x1F,0x68,0xA7,0x3F } },
+{ 16 , { 0x3F,0x3A,0x52,0x96,0x83,0x9A,0x02,0x06,0x35,0x2A,0x1C,0x3A,0x75,0xBA,0x65,0xD8 } },
+{ 12 , { 0x43,0x34,0x82,0x22,0x07,0xDE,0x9A,0xE0,0xE3,0x0C,0x23,0x86 } },
+{ 16 , { 0x37,0x1F,0x51,0x23,0xD9,0x7B,0x66,0x1C,0x8C,0xE0,0xA5,0xB6,0xA8,0x89,0xA3,0x4C } },
+{ 16 , { 0x37,0xB2,0xC7,0x45,0x42,0xCA,0x16,0xE9,0x86,0xEA,0xA9,0x8A,0x22,0xEF,0xB4,0xCA } },
+{ 16 , { 0x37,0xD7,0xD1,0x5F,0x7B,0x33,0x07,0x21,0x52,0x59,0x61,0x89,0xF3,0x90,0xF8,0xEA } },
+{ 14 , { 0x4D,0xC3,0x87,0xBB,0x9D,0xAF,0x0F,0xBC,0x66,0x33,0xBE,0x92,0x62,0xEF } },
+{ 16 , { 0x3F,0x62,0xA8,0xCE,0xF1,0xB2,0x3D,0x16,0xCF,0xD6,0x21,0x1F,0xA3,0x48,0x26,0xC8 } },
+{ 10 , { 0x41,0x43,0x07,0xC2,0x55,0x4B,0x1D,0xEA,0x49,0x68 } },
+{ 13 , { 0x3C,0xD4,0xE5,0xA3,0x20,0xCB,0x42,0x9D,0xC4,0xFC,0x7E,0xAB,0xCA } },
+{ 8 , { 0x07,0xB1,0x04,0xB5,0x51,0xE4,0xDF,0x9F } },
+{ 16 , { 0x37,0x1F,0x5E,0xEB,0xAC,0x9C,0x8C,0xE9,0xF9,0xA1,0xBB,0x8A,0x68,0x47,0x61,0xA2 } },
+{ 16 , { 0x37,0x04,0x7B,0xC4,0xE1,0x7F,0x2B,0xBE,0x2A,0x60,0x13,0xC7,0x50,0xA1,0xB8,0x36 } },
+{ 10 , { 0x39,0x35,0xAE,0x58,0xAA,0x84,0xEA,0x76,0x52,0xCC } },
+{ 8 , { 0x07,0x69,0x40,0x3F,0x04,0x60,0x17,0x2C } },
+{ 16 , { 0x37,0xD4,0x50,0x3E,0x2E,0xCE,0x73,0xF2,0xED,0x7E,0x12,0x5A,0xF1,0x21,0xFA,0xEC } },
+{ 8 , { 0x0F,0x54,0x0A,0x35,0x46,0xF8,0xA4,0x34 } },
+{ 12 , { 0x3B,0x1A,0x6B,0x4D,0x95,0xCE,0x02,0x0D,0x54,0x48,0x11,0x49 } },
+{ 16 , { 0x07,0xE2,0x68,0x94,0x50,0x03,0x14,0xD5,0x07,0x1E,0x04,0xD6,0x66,0x5B,0xF0,0x8B } },
+{ 8 , { 0x07,0xD8,0xD1,0x2F,0x35,0x9C,0x42,0x9F } },
+{ 16 , { 0x3F,0xD1,0xDA,0x9A,0xF7,0x0E,0x1D,0xAD,0xD2,0x16,0xD7,0x2B,0xD3,0x74,0x89,0x92 } },
+{ 16 , { 0x3F,0xBA,0x99,0xBA,0x03,0x40,0xB0,0xE5,0x21,0x57,0x3A,0x4C,0x91,0x9F,0x8B,0x73 } },
+{ 15 , { 0x49,0x68,0x07,0x9F,0xCE,0xC6,0xE1,0xFE,0xB7,0xC8,0x44,0xD0,0xAC,0x97,0x5E } },
+{ 8 , { 0x0F,0x86,0xF1,0xFE,0x3B,0x83,0x5B,0x71 } },
+{ 10 , { 0x39,0x5C,0xEE,0xC6,0xAB,0xA2,0x32,0xB6,0xCD,0x1E } },
+{ 16 , { 0x0F,0xDB,0xD5,0x00,0x80,0xE5,0x8F,0xF4,0x07,0x9F,0xCE,0x1A,0x6D,0x00,0x91,0x8F } },
+{ 8 , { 0x0F,0xDC,0x4B,0xE8,0x37,0xAC,0x80,0xE7 } },
+{ 9 , { 0x38,0x0D,0x16,0xF8,0x22,0x6D,0x54,0xB5,0x72 } },
+{ 11 , { 0x0F,0x3F,0xCB,0x62,0x48,0xA7,0xB9,0x92,0x4A,0x85,0x17 } },
+{ 8 , { 0x07,0xCA,0x4B,0x40,0x47,0xA0,0x82,0xF6 } },
+{ 16 , { 0x3F,0x01,0xC0,0x03,0x69,0x3F,0x89,0x4A,0xAA,0x24,0xC2,0x3C,0x24,0xA4,0x0A,0x12 } },
+{ 16 , { 0x37,0xD8,0x01,0x02,0x77,0xAB,0xB4,0xC1,0xC9,0xB4,0x04,0x68,0x15,0xBE,0x6A,0xEC } },
+{ 10 , { 0x39,0x2C,0x13,0x17,0x37,0xE1,0xF9,0xF6,0xEE,0x00 } },
+{ 15 , { 0x0F,0x06,0x30,0x10,0x12,0x3B,0x7C,0xDB,0x4E,0x33,0xB6,0xAF,0xEF,0x95,0x0E } },
+{ 16 , { 0x0F,0xE0,0xF5,0xE4,0xFA,0xEA,0x82,0x32,0x0F,0xA6,0x8D,0x92,0x58,0x06,0xDF,0x08 } },
+{ 16 , { 0x37,0x52,0x3C,0xA9,0x93,0xE8,0xFC,0x3F,0x1A,0x44,0x67,0x10,0xEE,0x0C,0xBF,0x23 } },
+{ 10 , { 0x41,0x20,0x07,0xE8,0xA2,0xB8,0x53,0x92,0x44,0x14 } },
+{ 16 , { 0x3F,0x15,0xA4,0xE8,0x4B,0x85,0x0C,0x9D,0xC4,0x9C,0x60,0x2F,0x42,0x5E,0xF6,0xEE } },
+{ 16 , { 0x3F,0x55,0x5A,0xAD,0x27,0x5F,0xDC,0x07,0xEF,0x32,0x7E,0x58,0xD2,0xFA,0x2A,0x4A } },
+{ 8 , { 0x07,0xBD,0xD5,0x42,0x09,0x21,0x5E,0xD5 } },
+{ 12 , { 0x3B,0x18,0x38,0x33,0x0B,0x23,0x35,0x69,0xB1,0x65,0x91,0x0C } },
+{ 16 , { 0x0F,0x81,0xA7,0xDA,0x78,0x40,0xE2,0x71,0x07,0x2C,0x50,0x4E,0x27,0xB3,0x61,0xE6 } },
+{ 15 , { 0x3E,0x83,0xCC,0xDB,0xCF,0x1F,0xC7,0x07,0x06,0xB3,0x98,0xF7,0x51,0x18,0x91 } },
+{ 16 , { 0x0F,0x8C,0x4F,0xEF,0x7E,0x6A,0x7D,0x58,0x07,0xFC,0xCD,0xCC,0xF6,0x1C,0xB9,0x73 } },
+{ 16 , { 0x07,0xF3,0x72,0xCC,0x1E,0x9E,0x11,0xCC,0x07,0x2C,0x65,0xF1,0x73,0xDB,0xFE,0x79 } },
+{ 8 , { 0x07,0xFB,0x7F,0x9D,0x8C,0x26,0x05,0x5A } },
+{ 9 , { 0x38,0xCE,0xD2,0x5A,0x36,0xC6,0x18,0x62,0xC9 } },
+{ 11 , { 0x0F,0xE4,0x9C,0xEA,0x55,0x57,0x84,0x37,0x4A,0x8A,0x90 } },
+{ 8 , { 0x07,0x6D,0xC9,0xA9,0x20,0xFC,0x83,0xF8 } },
+{ 15 , { 0x36,0xCB,0x14,0x43,0x10,0x8C,0x98,0x38,0x76,0x25,0x4E,0xBA,0x68,0x79,0xB7 } },
+{ 8 , { 0x0F,0x99,0x87,0xAB,0x3D,0x0D,0x21,0x82 } },
+{ 15 , { 0x36,0x82,0xB5,0xAA,0xF8,0xB2,0xBC,0xDD,0x00,0xD7,0xE1,0x42,0x38,0xB2,0x7D } },
+{ 8 , { 0x07,0x40,0x3D,0x78,0xDB,0x54,0x66,0xCA } },
+{ 13 , { 0x34,0xAF,0x5F,0x79,0x9B,0xF9,0x60,0x55,0x75,0xE0,0x6B,0x94,0x3C } },
+{ 16 , { 0x0F,0x81,0xAE,0x7E,0x06,0xC7,0x27,0x9F,0x07,0xD2,0x33,0xC1,0x0E,0x97,0x51,0xED } },
+{ 16 , { 0x0F,0x23,0x3C,0xCA,0x98,0x51,0x36,0xFC,0x47,0x5D,0x47,0x14,0x9C,0x43,0xBB,0x42 } },
+{ 16 , { 0x07,0x5A,0xE1,0x01,0xEF,0xE4,0x77,0xCA,0x07,0xC4,0xF9,0x29,0x20,0x13,0xA5,0xC1 } },
+{ 13 , { 0x07,0x8B,0xB8,0xD3,0xA3,0xC9,0xA4,0xEE,0x4C,0xCB,0xCB,0x74,0x0E } },
+{ 8 , { 0x0F,0x94,0x40,0xDC,0x4A,0xA9,0x1A,0x30 } },
+{ 16 , { 0x37,0x06,0x49,0xC5,0xA7,0xF4,0x91,0x9C,0xB6,0x9E,0x0F,0x83,0xFD,0x8B,0xF9,0x67 } },
+{ 16 , { 0x37,0x85,0x94,0x0A,0x41,0x14,0x42,0xA8,0x68,0x1F,0xAB,0xC1,0x8D,0xA0,0xD0,0x54 } },
+{ 16 , { 0x37,0x2F,0x03,0xEF,0xEA,0x78,0x16,0xC3,0xB6,0xEF,0xA5,0xE2,0x8C,0xC2,0x5D,0xB6 } },
+{ 12 , { 0x43,0xAF,0x0C,0x94,0x0F,0xC7,0xD1,0x32,0x5A,0x52,0xC6,0x5A } },
+{ 8 , { 0x07,0x91,0x72,0x13,0x08,0x57,0x30,0xB6 } },
+{ 16 , { 0x37,0x6D,0x6F,0x19,0xEE,0xB4,0x6F,0x00,0x1B,0x49,0xA2,0xD8,0xE1,0x3A,0x9E,0x47 } },
+{ 14 , { 0x45,0xD5,0xFB,0x6D,0x44,0x21,0x07,0xD8,0x13,0xF5,0x21,0x6B,0xDC,0x60 } },
+{ 8 , { 0x07,0x6B,0x70,0xE2,0xBB,0xB0,0x57,0xC1 } },
+{ 9 , { 0x38,0xB9,0x67,0x42,0x0E,0xDB,0x02,0xD6,0xC9 } },
+{ 8 , { 0x07,0x11,0xF6,0x9D,0x3B,0xC8,0x66,0xC1 } },
+{ 16 , { 0x37,0x91,0xA4,0x40,0x6D,0xC7,0x10,0x5F,0xB6,0xC8,0x59,0x55,0x59,0x6C,0x66,0x92 } },
+{ 16 , { 0x3F,0x0B,0xF7,0x08,0x80,0x30,0xE9,0x19,0x64,0x69,0xE1,0xCE,0x90,0x03,0x88,0xE5 } },
+{ 12 , { 0x43,0xF9,0xEB,0x0D,0x07,0xB3,0xAC,0x79,0x50,0x7A,0x71,0x81 } },
+{ 16 , { 0x37,0xAD,0x92,0x83,0x55,0x86,0x1A,0xA2,0x9C,0xA7,0xBC,0x6E,0x62,0xD1,0x13,0x09 } },
+{ 16 , { 0x3F,0x69,0x5C,0x04,0x2A,0x3E,0x2B,0xBC,0xDC,0x0F,0x31,0x71,0xDD,0x45,0xFD,0xE3 } },
+{ 16 , { 0x37,0x01,0xA3,0x13,0xAD,0xEB,0xEF,0x95,0x59,0xA7,0xF8,0x1B,0x8E,0x7E,0xE2,0xB5 } },
+{ 16 , { 0x3F,0x8D,0xCA,0x8A,0x62,0x0F,0xF9,0xDA,0xC2,0xAB,0x30,0x94,0x89,0x13,0x3F,0xB5 } },
+{ 13 , { 0x44,0x13,0x19,0x74,0x65,0x05,0x10,0x80,0xE7,0x42,0x88,0x82,0xEC } },
+{ 16 , { 0x37,0xC4,0x35,0x3F,0x16,0x05,0x58,0x44,0x79,0x75,0xE6,0x97,0x11,0x0F,0x7F,0xEE } },
+{ 16 , { 0x37,0x33,0x82,0x31,0x49,0x1E,0x56,0x05,0x82,0xF2,0xB0,0xD2,0x8F,0x3B,0x56,0xF8 } },
+{ 16 , { 0x37,0x74,0x0C,0xE0,0xC0,0x2B,0xC5,0xCD,0xFD,0x9B,0x30,0x34,0x08,0xFA,0xAA,0xDF } },
+{ 16 , { 0x3F,0xD8,0x1D,0xD5,0xCF,0x32,0x6D,0xF2,0xF2,0x90,0xEF,0x51,0x16,0x89,0x2D,0x75 } },
+{ 16 , { 0x37,0xE5,0x67,0xA4,0xF4,0x90,0xFF,0x5B,0x52,0x0B,0x4E,0xF1,0xF7,0xE9,0x0C,0x98 } },
+{ 16 , { 0x37,0xB9,0x2B,0x9A,0x6D,0xB8,0x02,0x03,0xD4,0x6C,0x58,0x2C,0xE7,0x97,0xF7,0x8A } },
+{ 16 , { 0x3F,0x65,0x61,0x93,0xDA,0x29,0x88,0xE9,0x85,0x0F,0xEE,0xD4,0x5E,0x18,0x82,0x5E } },
+{ 16 , { 0x3F,0x01,0x83,0xB0,0x32,0x5C,0x76,0xBA,0x30,0x2D,0x6C,0xE0,0x2F,0x96,0x04,0x25 } },
+{ 16 , { 0x37,0x17,0x4E,0x91,0x10,0xD2,0xB9,0x9F,0x9B,0x68,0x5F,0x84,0xB7,0xF6,0x3F,0x9F } },
+{ 16 , { 0x3F,0x4F,0x0B,0xDD,0x28,0x52,0xF3,0x6E,0x8A,0x6C,0x07,0xD1,0x7A,0x52,0xE6,0xFC } },
+{ 13 , { 0x3C,0x2C,0x7E,0x6D,0xAE,0xFD,0x2B,0xC1,0x21,0xB4,0x4C,0x78,0x89 } },
+{ 16 , { 0x07,0x16,0x9A,0xEC,0xA4,0xF3,0xEB,0xD3,0x07,0xA4,0x56,0xDE,0xDF,0x04,0x05,0xCB } },
+{ 16 , { 0x37,0xDD,0xFB,0x88,0x60,0x7F,0x6D,0x5F,0x1A,0xCF,0x0C,0xC8,0x94,0x82,0x63,0x1F } },
+{ 16 , { 0x3F,0x94,0x23,0x91,0xFB,0xDB,0xC1,0x02,0x5C,0x69,0xBA,0x49,0xE4,0xFD,0x90,0x6C } },
+{ 16 , { 0x3F,0x1C,0xF5,0x74,0x3A,0xAA,0x02,0xA3,0x4A,0x69,0x8E,0x2A,0xFF,0x30,0xFA,0x71 } },
+{ 16 , { 0x3F,0x0E,0x07,0x8C,0xEC,0x21,0x9F,0x9A,0xF2,0xBD,0x30,0xA5,0x6C,0xB9,0x2A,0xD5 } },
+{ 16 , { 0x3F,0x21,0x1D,0xC7,0x0D,0xF4,0xE0,0x71,0x14,0xFE,0x88,0xD0,0xB3,0x90,0x30,0x77 } },
+{ 16 , { 0x37,0x3D,0x55,0x05,0x42,0x07,0x3F,0xC1,0x5E,0x45,0xA2,0x6D,0xA2,0xF4,0x1E,0xDC } },
+{ 16 , { 0x3F,0xA1,0x5B,0xB5,0x6A,0x9C,0x8F,0x22,0x4D,0x0F,0x8A,0xBE,0x4A,0xF8,0x8D,0xB8 } },
+{ 16 , { 0x3F,0xC0,0xD7,0x2C,0x97,0xB5,0x96,0xF6,0x37,0x13,0xB7,0x70,0x3B,0xC7,0xCE,0x3B } },
+{ 16 , { 0x37,0x2E,0x7D,0x7B,0x5E,0xEA,0x83,0x72,0x62,0x01,0xDC,0x5E,0x8E,0xCF,0x44,0x52 } },
+{ 16 , { 0x3F,0x54,0x59,0xB7,0x0A,0x69,0x37,0x51,0xB9,0x72,0x50,0xB0,0xC8,0xF3,0xDF,0x0F } },
+{ 16 , { 0x37,0x9C,0x35,0xB1,0x3B,0x93,0x84,0x5F,0xF4,0xB0,0x2F,0xA0,0xB9,0xC9,0x1C,0x09 } },
+{ 16 , { 0x37,0xC4,0x03,0xB8,0x6A,0xDD,0xC3,0x7F,0x3D,0x88,0xFA,0x9E,0x46,0xBF,0x67,0x3C } },
+{ 11 , { 0x42,0x92,0x5D,0x07,0x16,0x24,0x54,0x46,0x48,0x3D,0xDA } },
+{ 16 , { 0x37,0x29,0x6B,0x4B,0x22,0xCA,0x10,0x55,0x0C,0xF3,0x94,0x4F,0x39,0x45,0x57,0xC1 } },
+{ 15 , { 0x36,0xF8,0x9F,0xED,0xB2,0x9D,0xA0,0x92,0xFC,0x09,0x42,0xFF,0x51,0xD8,0x70 } },
+{ 14 , { 0x07,0x2A,0x9F,0xD6,0x5F,0x90,0x8C,0x27,0x45,0xD7,0x7C,0xA1,0x3C,0x27 } },
+{ 8 , { 0x0F,0x39,0x9A,0x9A,0x63,0x03,0xFA,0x94 } },
+{ 16 , { 0x37,0x47,0xF1,0x16,0xC3,0xD6,0x7B,0x88,0x6D,0x8B,0x15,0x30,0xD5,0xEB,0x25,0x22 } },
+{ 16 , { 0x37,0xD1,0xD7,0x78,0xBC,0xF7,0xC4,0xDD,0xA0,0x45,0x89,0x08,0x54,0x95,0xA8,0x12 } },
+{ 16 , { 0x37,0x24,0x55,0x7F,0xA5,0x20,0xE2,0x51,0x06,0xEE,0x40,0x98,0xF1,0x47,0xA1,0x9E } },
+{ 11 , { 0x32,0x4C,0x65,0xB2,0x97,0x7D,0x88,0x13,0xCE,0x17,0x4E } },
+{ 8 , { 0x07,0xA9,0x71,0x73,0xE8,0x0E,0x03,0x8B } },
+{ 16 , { 0x3F,0xF1,0x11,0x00,0x5B,0xCA,0xE8,0x92,0xDE,0xCB,0x25,0xB5,0xBA,0x2C,0x61,0x02 } },
+{ 16 , { 0x37,0x7B,0xA5,0x54,0x4D,0xDA,0x95,0xC1,0x3B,0xB3,0x80,0xAE,0xAC,0x03,0xEA,0xF2 } },
+{ 16 , { 0x37,0xB2,0xCE,0x77,0x35,0x7C,0x20,0x57,0x05,0x35,0xFA,0x5E,0x8A,0xD9,0x09,0x65 } },
+{ 16 , { 0x3F,0xA6,0x89,0xF1,0xCB,0x7F,0xD3,0x1D,0x0C,0x97,0x6E,0x7F,0x31,0x7B,0x67,0xDF } },
+{ 10 , { 0x41,0x78,0x0F,0xF8,0xB9,0xD0,0x37,0xBD,0xB4,0x92 } },
+{ 16 , { 0x07,0x22,0x23,0x00,0xB7,0xA1,0x75,0xEE,0x07,0x40,0x28,0x63,0x9D,0x45,0x68,0x4B } },
+{ 16 , { 0x37,0xB7,0xA3,0x6D,0xFB,0x16,0xC4,0x23,0x1D,0x7E,0xB8,0x87,0x45,0x9D,0x6E,0x03 } },
+{ 16 , { 0x37,0xF1,0x0D,0x4E,0xAB,0xA0,0xF0,0x47,0xE8,0x6E,0xB4,0x68,0xAD,0xC6,0x38,0x20 } },
+{ 16 , { 0x37,0x6E,0xF5,0x4E,0xC2,0xE6,0x51,0x6D,0xD2,0xC1,0x63,0x01,0xB5,0x6D,0x5F,0xFD } },
+{ 9 , { 0x30,0x72,0xCE,0xAE,0xFE,0x96,0xC4,0x20,0x70 } },
+{ 11 , { 0x07,0x39,0xCC,0xFB,0x91,0xB9,0xA7,0x66,0x4A,0xF6,0xB8 } },
+{ 8 , { 0x07,0xA1,0xE8,0x8D,0x69,0xE2,0x04,0xA2 } },
+{ 16 , { 0x37,0x06,0x3F,0x8C,0x15,0x4A,0x5D,0xF6,0x6F,0xD6,0x25,0x35,0x20,0x3C,0x9F,0x9D } },
+{ 16 , { 0x3F,0x52,0x8D,0xFC,0x2A,0x47,0x00,0x6C,0xC6,0x3D,0x1E,0x8B,0xFE,0x65,0xC7,0x31 } },
+{ 16 , { 0x3F,0xC9,0x13,0x38,0xE8,0x26,0xDE,0x16,0xD9,0xBD,0x16,0x06,0xD8,0x5A,0x26,0x36 } },
+{ 16 , { 0x3F,0x31,0xAC,0x7E,0xA8,0x90,0xF6,0x3A,0x02,0x59,0x6B,0xF1,0x1E,0x02,0x1B,0xD1 } },
+{ 10 , { 0x41,0x8D,0x0F,0x60,0xD8,0x95,0xC9,0x3C,0x0B,0x2A } },
+{ 16 , { 0x0F,0x17,0xA0,0xDA,0x40,0x72,0x9A,0x78,0x07,0x4C,0x6B,0x32,0xAD,0x21,0x9C,0xB0 } },
+{ 8 , { 0x0F,0x6A,0x23,0x4C,0x65,0x56,0x33,0x0D } },
+{ 12 , { 0x33,0x7F,0xA0,0x9C,0xC7,0x08,0x60,0xCB,0x35,0x59,0x22,0xAA } },
+{ 16 , { 0x07,0x3B,0xDB,0xFF,0x14,0x24,0xCB,0x64,0x0F,0xF5,0x60,0xE6,0x68,0x48,0xF3,0x43 } },
+{ 16 , { 0x07,0x78,0x60,0x84,0x3F,0xC7,0x43,0xEE,0x0F,0xA8,0xA1,0x0F,0xCF,0xE1,0x3F,0x86 } },
+{ 16 , { 0x0F,0xC0,0x67,0x53,0xC3,0x8E,0x5E,0x0A,0x07,0x7C,0x30,0xDA,0x6C,0x6A,0xCA,0xAA } },
+{ 16 , { 0x0F,0x07,0x88,0x95,0x22,0xB7,0x88,0xBC,0x07,0x4A,0x2C,0xB3,0x7A,0xB9,0x75,0x22 } },
+{ 11 , { 0x07,0x2A,0x62,0x95,0x87,0x61,0x93,0x59,0x42,0xEA,0x8F } },
+{ 16 , { 0x0F,0x62,0x4C,0xC9,0x92,0xA0,0x43,0x96,0x0F,0x7C,0xD1,0x8B,0x51,0x25,0x67,0xC4 } },
+{ 16 , { 0x07,0x39,0x88,0x93,0xDE,0x93,0x29,0x80,0x07,0xA7,0xAE,0x2A,0xE0,0xB1,0xB4,0x79 } },
+{ 16 , { 0x0F,0x1C,0xDE,0x1C,0xEB,0x0F,0x9C,0x74,0x0F,0xC5,0xC2,0x09,0x0A,0xED,0x50,0x79 } },
+{ 8 , { 0x07,0x0B,0x1A,0x05,0x6D,0x49,0xE0,0xFB } },
+{ 16 , { 0x37,0x2A,0xBA,0x74,0x71,0xA9,0x88,0xCB,0x42,0x3E,0x0D,0x5F,0x1A,0xD2,0xAA,0xE1 } },
+{ 11 , { 0x32,0x02,0x90,0xE7,0xD3,0x09,0xFA,0x1A,0xC8,0x33,0x65 } },
+{ 15 , { 0x05,0xA6,0x9F,0x84,0x95,0x2F,0x16,0x7B,0x4E,0xCD,0xEA,0xBD,0x84,0xB1,0xC0 } },
+{ 16 , { 0x07,0xF4,0x5F,0x53,0xA9,0x9D,0xC2,0x2F,0x0F,0x86,0xA5,0x30,0x58,0x55,0x79,0xF4 } },
+{ 16 , { 0x0F,0xAF,0x6F,0x5D,0x7D,0xD5,0x5E,0xB2,0x07,0x4C,0x26,0x58,0xA7,0x42,0xBC,0x88 } },
+{ 16 , { 0x0F,0x66,0xF8,0xAE,0xA1,0x28,0x54,0x49,0x07,0x77,0x84,0x7E,0xF5,0xD6,0xF2,0x1C } },
+{ 8 , { 0x07,0x2E,0xFD,0xAD,0xB8,0x75,0xFE,0xE1 } },
+{ 9 , { 0x38,0x8B,0x53,0xED,0xF4,0x54,0x51,0x36,0xFC } },
+{ 16 , { 0x0F,0xCD,0x55,0xD1,0x59,0xC8,0xFB,0xF0,0x0F,0xFB,0x6D,0x1D,0xFE,0x5B,0xEE,0x2E } },
+{ 16 , { 0x0F,0xF9,0xA0,0xF7,0xCB,0x23,0x7D,0x43,0x0F,0x3D,0xB8,0x0B,0x82,0x66,0xC8,0xB1 } },
+{ 9 , { 0x38,0x9E,0xDD,0xDE,0xDD,0x88,0xC2,0xD1,0x83 } },
+{ 16 , { 0x0F,0xE9,0xCA,0xB0,0xF9,0x8B,0x10,0xB0,0x0F,0xEE,0x0C,0x59,0x94,0x87,0x00,0xAF } },
+{ 16 , { 0x37,0x17,0x34,0x12,0xB6,0xB0,0xAB,0xEA,0xD9,0xB7,0x7B,0x4C,0x85,0xA1,0xE3,0x99 } },
+{ 10 , { 0x49,0x96,0x0F,0xE1,0xAD,0xB7,0xA8,0xDE,0xF5,0x51 } },
+{ 16 , { 0x07,0xFD,0x04,0xDE,0xB1,0x80,0xFA,0x56,0x0F,0x56,0xCC,0xDB,0xF2,0x2B,0x38,0xE3 } },
+{ 16 , { 0x0F,0xC6,0x2F,0x42,0x67,0x15,0x5F,0xDB,0x07,0x21,0xF4,0x54,0x8E,0x31,0x45,0x44 } },
+{ 15 , { 0x0F,0x54,0xD7,0xEC,0x08,0x9A,0x13,0xD3,0x4E,0xE7,0xDC,0x69,0xA9,0xEC,0x98 } },
+{ 16 , { 0x0F,0xAB,0x2F,0x3F,0x45,0x7A,0xD1,0x61,0x05,0xFE,0x24,0x54,0x46,0x54,0x61,0x1F } },
+{ 13 , { 0x3C,0x1C,0x56,0x93,0xC7,0x68,0xF5,0x2A,0x4B,0xA1,0x29,0x84,0x25 } },
+{ 16 , { 0x0F,0xDB,0x0F,0x14,0x77,0xAC,0xC5,0xC8,0x07,0xCA,0xCA,0x31,0x22,0x97,0x36,0x40 } },
+{ 11 , { 0x07,0xD3,0x2C,0x22,0x69,0x8E,0xEC,0xD9,0x42,0x1C,0x11 } },
+{ 16 , { 0x0F,0xE6,0x96,0x1E,0xA9,0x3C,0x25,0x8A,0x07,0x49,0x16,0x97,0xE8,0x2B,0xA1,0xCA } },
+{ 8 , { 0x0F,0xD8,0x78,0xF7,0x58,0x40,0xA0,0x0A } },
+{ 16 , { 0x3F,0x77,0x26,0x27,0xEF,0x07,0xBE,0xB1,0x17,0xF7,0x21,0x48,0x15,0x63,0x02,0xAB } },
+{ 10 , { 0x39,0xF0,0x01,0x60,0x65,0xD7,0xC2,0x23,0x19,0xDC } },
+{ 12 , { 0x07,0x01,0xB1,0x42,0xEE,0x5D,0x1B,0xDB,0x4B,0xA0,0xD3,0xD7 } },
+{ 16 , { 0x07,0xF0,0xD1,0x0F,0x00,0x04,0x54,0xF5,0x05,0x34,0x94,0x2F,0xDC,0xAA,0x34,0xEB } }
+};
+
+
+
+
+
+//#define NB_LINES (sizeof(firmwaretable)/(8*sizeof(unsigned char)))
+
+#ifdef USING_ATV_FILTER
+static unsigned char dlif_vidfilt_table[] = {0};
+#define DLIF_VIDFILT_LINES (sizeof(dlif_vidfilt_table)/(8*sizeof(unsigned char)))
+#endif
+
+static si2176_common_reply_struct  reply;
+/************************************************************************************************************************
+NAME:		   si2176_readcommandbytes function
+DESCRIPTION:Read inbbytes from the i2c device into pucdatabuffer, return number of bytes read
+Parameter: iI2CIndex, the index of the first byte to read.
+Parameter: inbbytes, the number of bytes to read.
+Parameter: *pucdatabuffer, a pointer to a buffer used to store the bytes
+Porting:    Replace with embedded system I2C read function
+Returns:    Actual number of bytes read.
+ ************************************************************************************************************************/
+static int si2176_readcommandbytes(struct i2c_client *si2176, int inbbytes, unsigned char *pucdatabuffer)
+{
+        int i2c_flag = 0;
+        int i = 0;
+        unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
+
+        struct i2c_msg msg[] = {
+                {
+                        .addr  = si2176->addr,
+                        .flags  = I2C_M_RD,
+                        .len     = inbbytes,
+                        .buf     = pucdatabuffer,
+                },
+        };
+
+repeat:
+        i2c_flag = i2c_transfer(si2176->adapter, msg, 1);
+        if (i2c_flag < 0) {
+                pr_err("%s: error in read sli2176, %d byte(s) should be read,. \n", __func__, inbbytes);
+                if (i++ < i2c_try_cnt) {
+                        pr_err("%s: error in read sli2176, try again!!!\n", __func__);
+                        goto repeat;
+                }
+                else
+                        return -EIO;
+        }
+        else {
+                //pr_info("%s: read %d bytes\n", __func__, inbbytes);
+                return inbbytes;
+        }
+}
+
+/************************************************************************************************************************
+NAME:  si2176_writecommandbytes
+DESCRIPTION:  Write inbbytes from pucdatabuffer to the i2c device, return number of bytes written
+Porting:    Replace with inbbytes system I2C write function
+Returns:    Number of bytes written
+ ************************************************************************************************************************/
+static int si2176_writecommandbytes(struct i2c_client *si2176, int inbbytes, unsigned char *pucdatabuffer)
+{
+        int i2c_flag = 0;
+        int i = 0;
+        unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
+
+        struct i2c_msg msg[] = {
+                {
+                        .addr	= si2176->addr,
+                        .flags	= 0,    //|I2C_M_TEN,
+                        .len	= inbbytes,
+                        .buf	= pucdatabuffer,
+                }
+
+        };
+
+repeat:
+        i2c_flag = i2c_transfer(si2176->adapter, msg, 1);
+        if (i2c_flag < 0) {
+                pr_err("%s: error in write sli2176, %d byte(s) should be read,. \n", __func__, inbbytes);
+                if (i++ < i2c_try_cnt) {
+                        pr_err("%s: error in wirte sli2176, try again!!!\n", __func__);
+                        goto repeat;
+                }
+                else
+                        return -EIO;
+        }
+        else {
+                //pr_info("%s: write %d bytes\n", __func__, inbbytes);
+                return inbbytes;
+        }
+}
+
+/***********************************************************************************************************************
+  sli2176_pollforcts function
+Use:        CTS checking function
+Used to check the CTS bit until it is set before sending the next command
+Comments:   The status byte definition being identical for all commands,
+using this function to fill the status structure hels reducing the code size
+Comments:   waitForCTS = 1 => I2C polling
+waitForCTS = 2 => INTB followed by a read (reading a HW byte using the cypress chip)
+max timeout = 100 ms
+
+Porting:    If reading INTB is not possible, the waitForCTS = 2 case can be removed
+
+Parameter: waitForCTS          a flag indicating if waiting for CTS is required
+Returns:   1 if the CTS bit is set, 0 otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2176_pollforcts(struct i2c_client *si2176)
+{
+        unsigned char error_code = 0;
+        unsigned char loop_count = 0;
+        unsigned char rspbytebuffer[1];
+
+        for (loop_count=0; loop_count<50; loop_count++) { /* wait a maximum of 50*25ms = 1.25s  */
+                if (si2176_readcommandbytes(si2176, 1, rspbytebuffer) != 1)
+                        error_code = ERROR_SI2176_POLLING_CTS;
+                else
+                        error_code = NO_SI2176_ERROR;
+                if (error_code || (rspbytebuffer[0] & 0x80))
+                        goto exit;
+                mdelay(2); /* CTS not set, wait 2ms and retry */
+        }
+        error_code = ERROR_SI2176_CTS_TIMEOUT;
+
+exit:
+        if (error_code)
+                pr_info("%s: poll cts function error:%d!!!...............\n", __func__, error_code);
+
+        return error_code;
+}
+
+/***********************************************************************************************************************
+  SI2176_CurrentResponseStatus function
+Use:        status checking function
+Used to fill the SI2176_COMMON_REPLY_struct members with the ptDataBuffer byte's bits
+Comments:   The status byte definition being identical for all commands,
+using this function to fill the status structure hels reducing the code size
+
+Parameter: *ret          the SI2176_COMMON_REPLY_struct
+Parameter: ptDataBuffer  a single byte received when reading a command's response (the first byte)
+Returns:   0 if the err bit (bit 6) is unset, 1 otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2176_currentresponsestatus(si2176_common_reply_struct *common_reply, unsigned char ptdatabuffer)
+{
+        /* _status_code_insertion_start */
+        common_reply->tunint = ((ptdatabuffer >> 0 ) & 0x01);
+        common_reply->atvint = ((ptdatabuffer >> 1 ) & 0x01);
+        common_reply->dtvint = ((ptdatabuffer >> 2 ) & 0x01);
+        common_reply->err    = ((ptdatabuffer >> 6 ) & 0x01);
+        common_reply->cts    = ((ptdatabuffer >> 7 ) & 0x01);
+        /* _status_code_insertion_point */
+        return (common_reply->err ? ERROR_SI2176_ERR : NO_SI2176_ERROR);
+}
+
+/***********************************************************************************************************************
+  si2176_pollforresponse function
+Use:        command response retrieval function
+Used to retrieve the command response in the provided buffer,
+poll for response either by I2C polling or wait for INTB
+Comments:   The status byte definition being identical for all commands,
+using this function to fill the status structure hels reducing the code size
+Comments:   waitForCTS = 1 => I2C polling
+waitForCTS = 2 => INTB followed by a read (reading a HW byte using the cypress chip)
+max timeout = 100 ms
+
+Porting:    If reading INTB is not possible, the waitForCTS = 2 case can be removed
+
+Parameter:  waitforresponse  a flag indicating if waiting for the response is required
+Parameter:  nbbytes          the number of response bytes to read
+Parameter:  pbytebuffer      a buffer into which bytes will be stored
+Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2176_pollforresponse(struct i2c_client *si2176, unsigned char waitforresponse, unsigned int nbbytes, unsigned char *pbytebuffer, si2176_common_reply_struct *common_reply)
+{
+        unsigned char error_code;
+        unsigned char loop_count;
+
+        for (loop_count=0; loop_count<50; loop_count++) { /* wait a maximum of 50*2ms = 100ms                        */
+                switch (waitforresponse) { /* type of response polling?                                */
+                        case 0 : /* no polling? valid option, but shouldn't have been called */
+                                error_code = NO_SI2176_ERROR; /* return no error                                          */
+                                goto exit;
+
+                        case 1 : /* I2C polling status?                                      */
+                                if (si2176_readcommandbytes(si2176, nbbytes, pbytebuffer) != nbbytes)
+                                        error_code = ERROR_SI2176_POLLING_RESPONSE;
+                                else
+                                        error_code = NO_SI2176_ERROR;
+                                if (error_code)
+                                        goto exit;	/* if error, exit with error code */
+                                if (pbytebuffer[0] & 0x80)	  /* CTS set? */
+                                {
+                                        error_code = si2176_currentresponsestatus(common_reply, pbytebuffer[0]);
+                                        goto exit; /* exit whether ERR set or not   */
+                                }
+                                break;
+
+                        default :
+                                error_code = ERROR_SI2176_PARAMETER_OUT_OF_RANGE; /* support debug of invalid CTS poll parameter   */
+                                goto exit;
+                }
+                mdelay(2); /* CTS not set, wait 2ms and retry                         */
+        }
+        error_code = ERROR_SI2176_CTS_TIMEOUT;
+
+exit:
+        return error_code;
+}
+
+/************************************************************************************************************************
+NAME: CheckStatus
+DESCRIPTION:     Read Si2170 STATUS byte and return decoded status
+Parameter:  Si2170 Context (I2C address)
+Parameter:  Status byte (TUNINT, ATVINT, DTVINT, ERR, CTS, CHLINT, and CHL flags).
+Returns:    Si2170/I2C transaction error code
+ ************************************************************************************************************************/
+#if 0
+static int si2176_check_status(struct i2c_client *si2176, si2176_common_reply_struct *common_reply)
+{
+        unsigned char buffer[1];
+        /* read STATUS byte */
+        if (si2176_pollforresponse(si2176, 1, 1, buffer, common_reply) != 0)
+        {
+                return ERROR_SI2176_POLLING_RESPONSE;
+        }
+
+        return 0;
+}
+#endif
+/***********************************************************************************************************************
+NAME: Si2170_L1_API_Patch
+DESCRIPTION: Patch information function
+Used to send a number of bytes to the Si2170. Useful to download the firmware.
+Parameter:   *api    a pointer to the api context to initialize
+Parameter:  waitForCTS flag for CTS checking prior to sending a Si2170 API Command
+Parameter:  waitForResponse flag for CTS checking and Response readback after sending Si2170 API Command
+Parameter:  number of bytes to transmit
+Parameter:  Databuffer containing the bytes to transfer in an unsigned char array.
+Returns:   0 if no error, else a nonzero int representing an error
+ ***********************************************************************************************************************/
+static unsigned char si2176_api_patch(struct i2c_client *si2176, int inbbytes, unsigned char *pucdatabuffer, si2176_common_reply_struct *common_reply)
+{
+        unsigned char res = 0;
+        unsigned char error_code = 0;
+        unsigned char rspbytebuffer[1];
+
+        res = si2176_pollforcts(si2176);
+        if (res != NO_SI2176_ERROR)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, res);
+                return res;
+        }
+
+        res = si2176_writecommandbytes(si2176, inbbytes, pucdatabuffer);
+        if (res!=inbbytes)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, ERROR_SI2176_SENDING_COMMAND);
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, common_reply);
+        if (error_code)
+                pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+
+        return error_code;
+}
+
+
+/* _commands_insertion_start */
+#ifdef SI2176_AGC_OVERRIDE_CMD
+/*---------------------------------------------------*/
+/* SI2176_AGC_OVERRIDE COMMAND                     */
+/*---------------------------------------------------*/
+static unsigned char si2176_agc_override(struct i2c_client *si2176,
+                unsigned char   force_max_gain,
+                unsigned char   force_top_gain,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (force_max_gain > SI2176_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MAX)
+                        || (force_top_gain > SI2176_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MAX) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_AGC_OVERRIDE_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( force_max_gain & SI2176_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MASK ) << SI2176_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_LSB|
+                        ( force_top_gain & SI2176_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MASK ) << SI2176_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_LSB);
+
+        if (si2176_writecommandbytes(si2176, 2, cmdbytebuffer) != 2)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->agc_override.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_AGC_OVERRIDE_CMD */
+#ifdef SI2176_ATV_CW_TEST_CMD
+/*---------------------------------------------------*/
+/* SI2176_ATV_CW_TEST COMMAND                      */
+/*---------------------------------------------------*/
+static unsigned char si2176_atv_cw_test(struct i2c_client *si2176,
+                unsigned char   pc_lock,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (pc_lock > SI2176_ATV_CW_TEST_CMD_PC_LOCK_MAX) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code) goto exit;
+
+        cmdbytebuffer[0] = SI2176_ATV_CW_TEST_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( pc_lock & SI2176_ATV_CW_TEST_CMD_PC_LOCK_MASK ) << SI2176_ATV_CW_TEST_CMD_PC_LOCK_LSB);
+
+        if (si2176_writecommandbytes(si2176, 2, cmdbytebuffer) != 2) error_code = ERROR_SI2176_SENDING_COMMAND;
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->atv_cw_test.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_ATV_CW_TEST_CMD */
+#ifdef SI2176_ATV_RESTART_CMD
+/*---------------------------------------------------*/
+/* SI2176_ATV_RESTART COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char si2176_atv_restart(struct i2c_client *si2176,
+                unsigned char   mode,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (mode > SI2176_ATV_RESTART_CMD_MODE_MAX) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_ATV_RESTART_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( mode & SI2176_ATV_RESTART_CMD_MODE_MASK ) << SI2176_ATV_RESTART_CMD_MODE_LSB);
+
+        if (si2176_writecommandbytes(si2176, 2, cmdbytebuffer) != 2)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->atv_restart.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_ATV_RESTART_CMD */
+#ifdef SI2176_DTV_RESTART_CMD
+/*---------------------------------------------------*/
+/* SI2176_DTV_RESTART COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char si2176_dtv_restart(struct i2c_client *si2176, si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[1];
+
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_DTV_RESTART_CMD;
+        if (si2176_writecommandbytes(si2176, 1, cmdbytebuffer) != 1)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->atv_restart.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_ATV_RESTART_CMD */
+
+#ifdef SI2176_ATV_STATUS_CMD
+/*---------------------------------------------------*/
+/* SI2176_ATV_STATUS COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char si2176_atv_status(struct i2c_client *si2176,
+                unsigned char intack,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[12];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (intack > SI2176_ATV_STATUS_CMD_INTACK_MAX) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_ATV_STATUS_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( intack & SI2176_ATV_STATUS_CMD_INTACK_MASK ) << SI2176_ATV_STATUS_CMD_INTACK_LSB);
+
+        if (si2176_writecommandbytes(si2176, 2, cmdbytebuffer) != 2)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 12, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->atv_status.status = &reply;
+                if (!error_code)
+                {
+                        rsp->atv_status.chlint           =   (( ( (rspbytebuffer[1]  )) >> SI2176_ATV_STATUS_RESPONSE_CHLINT_LSB           ) & SI2176_ATV_STATUS_RESPONSE_CHLINT_MASK           );
+                        rsp->atv_status.pclint           =   (( ( (rspbytebuffer[1]  )) >> SI2176_ATV_STATUS_RESPONSE_PCLINT_LSB           ) & SI2176_ATV_STATUS_RESPONSE_PCLINT_MASK           );
+                        rsp->atv_status.dlint             =   (( ( (rspbytebuffer[1]  )) >> SI2176_ATV_STATUS_RESPONSE_DLINT_LSB            ) & SI2176_ATV_STATUS_RESPONSE_DLINT_MASK            );
+                        rsp->atv_status.snrlint          =   (( ( (rspbytebuffer[1]  )) >> SI2176_ATV_STATUS_RESPONSE_SNRLINT_LSB          ) & SI2176_ATV_STATUS_RESPONSE_SNRLINT_MASK          );
+                        rsp->atv_status.snrhint         =   (( ( (rspbytebuffer[1]  )) >> SI2176_ATV_STATUS_RESPONSE_SNRHINT_LSB          ) & SI2176_ATV_STATUS_RESPONSE_SNRHINT_MASK          );
+                        rsp->atv_status.chl                =   (( ( (rspbytebuffer[2]  )) >> SI2176_ATV_STATUS_RESPONSE_CHL_LSB              ) & SI2176_ATV_STATUS_RESPONSE_CHL_MASK              );
+                        rsp->atv_status.pcl               =   (( ( (rspbytebuffer[2]  )) >> SI2176_ATV_STATUS_RESPONSE_PCL_LSB              ) & SI2176_ATV_STATUS_RESPONSE_PCL_MASK              );
+                        rsp->atv_status.dl                 =   (( ( (rspbytebuffer[2]  )) >> SI2176_ATV_STATUS_RESPONSE_DL_LSB               ) & SI2176_ATV_STATUS_RESPONSE_DL_MASK               );
+                        rsp->atv_status.snrl              =   (( ( (rspbytebuffer[2]  )) >> SI2176_ATV_STATUS_RESPONSE_SNRL_LSB             ) & SI2176_ATV_STATUS_RESPONSE_SNRL_MASK             );
+                        rsp->atv_status.snrh             =   (( ( (rspbytebuffer[2]  )) >> SI2176_ATV_STATUS_RESPONSE_SNRH_LSB             ) & SI2176_ATV_STATUS_RESPONSE_SNRH_MASK             );
+                        rsp->atv_status.video_snr     =   (( ( (rspbytebuffer[3]  )) >> SI2176_ATV_STATUS_RESPONSE_VIDEO_SNR_LSB        ) & SI2176_ATV_STATUS_RESPONSE_VIDEO_SNR_MASK        );
+                        rsp->atv_status.afc_freq       = (((( ( (rspbytebuffer[4]  ) | (rspbytebuffer[5]  << 8 )) >> SI2176_ATV_STATUS_RESPONSE_AFC_FREQ_LSB         ) & SI2176_ATV_STATUS_RESPONSE_AFC_FREQ_MASK) <<SI2176_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>SI2176_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT         );
+                        rsp->atv_status.video_sc_spacing = (((( ( (rspbytebuffer[6]  ) | (rspbytebuffer[7]  << 8 )) >> SI2176_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_LSB ) & SI2176_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_MASK) <<SI2176_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT ) >>SI2176_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT );
+                        rsp->atv_status.video_sys    =   (( ( (rspbytebuffer[8]  )) >> SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB        ) & SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK        );
+                        rsp->atv_status.color            =   (( ( (rspbytebuffer[8]  )) >> SI2176_ATV_STATUS_RESPONSE_COLOR_LSB            ) & SI2176_ATV_STATUS_RESPONSE_COLOR_MASK            );
+                        rsp->atv_status.trans            =   (( ( (rspbytebuffer[8]  )) >> SI2176_ATV_STATUS_RESPONSE_TRANS_LSB            ) & SI2176_ATV_STATUS_RESPONSE_TRANS_MASK            );
+                        rsp->atv_status.audio_sys    =   (( ( (rspbytebuffer[9]  )) >> SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_LSB        ) & SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_MASK        );
+                        rsp->atv_status.audio_demod_mode =   (( ( (rspbytebuffer[9]  )) >> SI2176_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_LSB ) & SI2176_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_MASK );
+                        rsp->atv_status.audio_chan_bw    =   (( ( (rspbytebuffer[10] )) >> SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_LSB    ) & SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_MASK    );
+                        rsp->atv_status.sound_level = rspbytebuffer[11];
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_ATV_STATUS_CMD */
+#ifdef SI2176_CONFIG_PINS_CMD
+/*---------------------------------------------------*/
+/* SI2176_CONFIG_PINS COMMAND                      */
+/*---------------------------------------------------*/
+ unsigned char si2176_config_pins(struct i2c_client *si2176,
+                unsigned char   gpio1_mode,
+                unsigned char   gpio1_read,
+                unsigned char   gpio2_mode,
+                unsigned char   gpio2_read,
+                unsigned char   gpio3_mode,
+                unsigned char   gpio3_read,
+                unsigned char   bclk1_mode,
+                unsigned char   bclk1_read,
+                unsigned char   xout_mode,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[6];
+        unsigned char rspbytebuffer[6];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (gpio1_mode > SI2176_CONFIG_PINS_CMD_GPIO1_MODE_MAX)
+                        || (gpio1_read > SI2176_CONFIG_PINS_CMD_GPIO1_READ_MAX)
+                        || (gpio2_mode > SI2176_CONFIG_PINS_CMD_GPIO2_MODE_MAX)
+                        || (gpio2_read > SI2176_CONFIG_PINS_CMD_GPIO2_READ_MAX)
+                        || (gpio3_mode > SI2176_CONFIG_PINS_CMD_GPIO3_MODE_MAX)
+                        || (gpio3_read > SI2176_CONFIG_PINS_CMD_GPIO3_READ_MAX)
+                        || (bclk1_mode > SI2176_CONFIG_PINS_CMD_BCLK1_MODE_MAX)
+                        || (bclk1_read > SI2176_CONFIG_PINS_CMD_BCLK1_READ_MAX)
+                        || (xout_mode  > SI2176_CONFIG_PINS_CMD_XOUT_MODE_MAX ) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_CONFIG_PINS_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( gpio1_mode & SI2176_CONFIG_PINS_CMD_GPIO1_MODE_MASK ) << SI2176_CONFIG_PINS_CMD_GPIO1_MODE_LSB|
+                        ( gpio1_read & SI2176_CONFIG_PINS_CMD_GPIO1_READ_MASK ) << SI2176_CONFIG_PINS_CMD_GPIO1_READ_LSB);
+        cmdbytebuffer[2] = (unsigned char) ( ( gpio2_mode & SI2176_CONFIG_PINS_CMD_GPIO2_MODE_MASK ) << SI2176_CONFIG_PINS_CMD_GPIO2_MODE_LSB|
+                        ( gpio2_read & SI2176_CONFIG_PINS_CMD_GPIO2_READ_MASK ) << SI2176_CONFIG_PINS_CMD_GPIO2_READ_LSB);
+        cmdbytebuffer[3] = (unsigned char) ( ( gpio3_mode & SI2176_CONFIG_PINS_CMD_GPIO3_MODE_MASK ) << SI2176_CONFIG_PINS_CMD_GPIO3_MODE_LSB|
+                        ( gpio3_read & SI2176_CONFIG_PINS_CMD_GPIO3_READ_MASK ) << SI2176_CONFIG_PINS_CMD_GPIO3_READ_LSB);
+        cmdbytebuffer[4] = (unsigned char) ( ( bclk1_mode & SI2176_CONFIG_PINS_CMD_BCLK1_MODE_MASK ) << SI2176_CONFIG_PINS_CMD_BCLK1_MODE_LSB|
+                        ( bclk1_read & SI2176_CONFIG_PINS_CMD_BCLK1_READ_MASK ) << SI2176_CONFIG_PINS_CMD_BCLK1_READ_LSB);
+        cmdbytebuffer[5] = (unsigned char) ( ( xout_mode  & SI2176_CONFIG_PINS_CMD_XOUT_MODE_MASK  ) << SI2176_CONFIG_PINS_CMD_XOUT_MODE_LSB );
+
+        if (si2176_writecommandbytes(si2176, 6, cmdbytebuffer) != 6)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 6, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->config_pins.status = &reply;
+                if (!error_code)
+                {
+                        rsp->config_pins.gpio1_mode  =   (( ( (rspbytebuffer[1]  )) >> SI2176_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB  ) & SI2176_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK  );
+                        rsp->config_pins.gpio1_state =   (( ( (rspbytebuffer[1]  )) >> SI2176_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB ) & SI2176_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK );
+                        rsp->config_pins.gpio2_mode  =   (( ( (rspbytebuffer[2]  )) >> SI2176_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB  ) & SI2176_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK  );
+                        rsp->config_pins.gpio2_state =   (( ( (rspbytebuffer[2]  )) >> SI2176_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB ) & SI2176_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK );
+                        rsp->config_pins.gpio3_mode  =   (( ( (rspbytebuffer[3]  )) >> SI2176_CONFIG_PINS_RESPONSE_GPIO3_MODE_LSB  ) & SI2176_CONFIG_PINS_RESPONSE_GPIO3_MODE_MASK  );
+                        rsp->config_pins.gpio3_state =   (( ( (rspbytebuffer[3]  )) >> SI2176_CONFIG_PINS_RESPONSE_GPIO3_STATE_LSB ) & SI2176_CONFIG_PINS_RESPONSE_GPIO3_STATE_MASK );
+                        rsp->config_pins.bclk1_mode  =   (( ( (rspbytebuffer[4]  )) >> SI2176_CONFIG_PINS_RESPONSE_BCLK1_MODE_LSB  ) & SI2176_CONFIG_PINS_RESPONSE_BCLK1_MODE_MASK  );
+                        rsp->config_pins.bclk1_state =   (( ( (rspbytebuffer[4]  )) >> SI2176_CONFIG_PINS_RESPONSE_BCLK1_STATE_LSB ) & SI2176_CONFIG_PINS_RESPONSE_BCLK1_STATE_MASK );
+                        rsp->config_pins.xout_mode   =   (( ( (rspbytebuffer[5]  )) >> SI2176_CONFIG_PINS_RESPONSE_XOUT_MODE_LSB   ) & SI2176_CONFIG_PINS_RESPONSE_XOUT_MODE_MASK   );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_CONFIG_PINS_CMD */
+#ifdef SI2176_EXIT_BOOTLOADER_CMD
+/*---------------------------------------------------*/
+/* SI2176_EXIT_BOOTLOADER COMMAND                  */
+/*---------------------------------------------------*/
+static unsigned char si2176_exit_bootloader(struct i2c_client *si2176,
+                unsigned char   func,
+                unsigned char   ctsien,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (func   > SI2176_EXIT_BOOTLOADER_CMD_FUNC_MAX  )
+                        || (ctsien > SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_MAX) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code) goto exit;
+
+        cmdbytebuffer[0] = SI2176_EXIT_BOOTLOADER_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( func   & SI2176_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << SI2176_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+                        ( ctsien & SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+
+        if (si2176_writecommandbytes(si2176, 2, cmdbytebuffer) != 2) error_code = ERROR_SI2176_SENDING_COMMAND;
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->exit_bootloader.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_EXIT_BOOTLOADER_CMD */
+#ifdef SI2176_FINE_TUNE_CMD
+/*---------------------------------------------------*/
+/* SI2176_FINE_TUNE COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char si2176_fine_tune(struct i2c_client *si2176,
+                unsigned char   reserved,
+                int   offset_500hz,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[4];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (reserved     > SI2176_FINE_TUNE_CMD_RESERVED_MAX    )
+                        || (offset_500hz > SI2176_FINE_TUNE_CMD_OFFSET_500HZ_MAX)  || (offset_500hz < SI2176_FINE_TUNE_CMD_OFFSET_500HZ_MIN) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_FINE_TUNE_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( reserved     & SI2176_FINE_TUNE_CMD_RESERVED_MASK     ) << SI2176_FINE_TUNE_CMD_RESERVED_LSB    );
+        cmdbytebuffer[2] = (unsigned char) ( ( offset_500hz & SI2176_FINE_TUNE_CMD_OFFSET_500HZ_MASK ) << SI2176_FINE_TUNE_CMD_OFFSET_500HZ_LSB);
+        cmdbytebuffer[3] = (unsigned char) ((( offset_500hz & SI2176_FINE_TUNE_CMD_OFFSET_500HZ_MASK ) << SI2176_FINE_TUNE_CMD_OFFSET_500HZ_LSB)>>8);
+
+        if (si2176_writecommandbytes(si2176, 4, cmdbytebuffer) != 4)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->fine_tune.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_FINE_TUNE_CMD */
+#ifdef SI2176_GET_PROPERTY_CMD
+/*---------------------------------------------------*/
+/* SI2176_GET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char si2176_get_property(struct i2c_client *si2176,
+                unsigned char   reserved,
+                unsigned int    prop,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[4];
+        unsigned char rspbytebuffer[4];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (reserved > SI2176_GET_PROPERTY_CMD_RESERVED_MAX) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_GET_PROPERTY_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( reserved & SI2176_GET_PROPERTY_CMD_RESERVED_MASK ) << SI2176_GET_PROPERTY_CMD_RESERVED_LSB);
+        cmdbytebuffer[2] = (unsigned char) ( ( prop     & SI2176_GET_PROPERTY_CMD_PROP_MASK     ) << SI2176_GET_PROPERTY_CMD_PROP_LSB    );
+        cmdbytebuffer[3] = (unsigned char) ((( prop     & SI2176_GET_PROPERTY_CMD_PROP_MASK     ) << SI2176_GET_PROPERTY_CMD_PROP_LSB    )>>8);
+
+        if (si2176_writecommandbytes(si2176, 4, cmdbytebuffer) != 4)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 4, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->get_property.status = &reply;
+                if (!error_code)
+                {
+                        rsp->get_property.reserved =   (( ( (rspbytebuffer[1]  )) >> SI2176_GET_PROPERTY_RESPONSE_RESERVED_LSB ) & SI2176_GET_PROPERTY_RESPONSE_RESERVED_MASK );
+                        rsp->get_property.data     =   (( ( (rspbytebuffer[2]  ) | (rspbytebuffer[3]  << 8 )) >> SI2176_GET_PROPERTY_RESPONSE_DATA_LSB     ) & SI2176_GET_PROPERTY_RESPONSE_DATA_MASK     );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_GET_PROPERTY_CMD */
+#ifdef SI2176_GET_REV_CMD
+/*---------------------------------------------------*/
+/* SI2176_GET_REV COMMAND                          */
+/*---------------------------------------------------*/
+static unsigned char si2176_get_rev(struct i2c_client *si2176,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[10];
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code) goto exit;
+
+        cmdbytebuffer[0] = SI2176_GET_REV_CMD;
+
+        if (si2176_writecommandbytes(si2176, 1, cmdbytebuffer) != 1) error_code = ERROR_SI2176_SENDING_COMMAND;
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 10, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->get_rev.status = &reply;
+                if (!error_code)
+                {
+                        rsp->get_rev.pn       =   (( ( (rspbytebuffer[1]  )) >> SI2176_GET_REV_RESPONSE_PN_LSB       ) & SI2176_GET_REV_RESPONSE_PN_MASK       );
+                        rsp->get_rev.fwmajor  =   (( ( (rspbytebuffer[2]  )) >> SI2176_GET_REV_RESPONSE_FWMAJOR_LSB  ) & SI2176_GET_REV_RESPONSE_FWMAJOR_MASK  );
+                        rsp->get_rev.fwminor  =   (( ( (rspbytebuffer[3]  )) >> SI2176_GET_REV_RESPONSE_FWMINOR_LSB  ) & SI2176_GET_REV_RESPONSE_FWMINOR_MASK  );
+                        rsp->get_rev.patch    =   (( ( (rspbytebuffer[4]  ) | (rspbytebuffer[5]  << 8 )) >> SI2176_GET_REV_RESPONSE_PATCH_LSB    ) & SI2176_GET_REV_RESPONSE_PATCH_MASK    );
+                        rsp->get_rev.cmpmajor =   (( ( (rspbytebuffer[6]  )) >> SI2176_GET_REV_RESPONSE_CMPMAJOR_LSB ) & SI2176_GET_REV_RESPONSE_CMPMAJOR_MASK );
+                        rsp->get_rev.cmpminor =   (( ( (rspbytebuffer[7]  )) >> SI2176_GET_REV_RESPONSE_CMPMINOR_LSB ) & SI2176_GET_REV_RESPONSE_CMPMINOR_MASK );
+                        rsp->get_rev.cmpbuild =   (( ( (rspbytebuffer[8]  )) >> SI2176_GET_REV_RESPONSE_CMPBUILD_LSB ) & SI2176_GET_REV_RESPONSE_CMPBUILD_MASK );
+                        rsp->get_rev.chiprev  =   (( ( (rspbytebuffer[9]  )) >> SI2176_GET_REV_RESPONSE_CHIPREV_LSB  ) & SI2176_GET_REV_RESPONSE_CHIPREV_MASK  );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_GET_REV_CMD */
+#ifdef SI2176_PART_INFO_CMD
+/*---------------------------------------------------*/
+/* SI2176_PART_INFO COMMAND                        */
+/*---------------------------------------------------*/
+static unsigned char si2176_part_info(struct i2c_client *si2176,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[13];
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code) goto exit;
+
+        cmdbytebuffer[0] = SI2176_PART_INFO_CMD;
+
+        if (si2176_writecommandbytes(si2176, 1, cmdbytebuffer) != 1) error_code = ERROR_SI2176_SENDING_COMMAND;
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 13, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->part_info.status = &reply;
+                if (!error_code)
+                {
+                        rsp->part_info.chiprev  =   (( ( (rspbytebuffer[1]  )) >> SI2176_PART_INFO_RESPONSE_CHIPREV_LSB  ) & SI2176_PART_INFO_RESPONSE_CHIPREV_MASK  );
+                        rsp->part_info.part     =   (( ( (rspbytebuffer[2]  )) >> SI2176_PART_INFO_RESPONSE_PART_LSB     ) & SI2176_PART_INFO_RESPONSE_PART_MASK     );
+                        rsp->part_info.pmajor   =   (( ( (rspbytebuffer[3]  )) >> SI2176_PART_INFO_RESPONSE_PMAJOR_LSB   ) & SI2176_PART_INFO_RESPONSE_PMAJOR_MASK   );
+                        rsp->part_info.pminor   =   (( ( (rspbytebuffer[4]  )) >> SI2176_PART_INFO_RESPONSE_PMINOR_LSB   ) & SI2176_PART_INFO_RESPONSE_PMINOR_MASK   );
+                        rsp->part_info.pbuild   =   (( ( (rspbytebuffer[5]  )) >> SI2176_PART_INFO_RESPONSE_PBUILD_LSB   ) & SI2176_PART_INFO_RESPONSE_PBUILD_MASK   );
+                        rsp->part_info.reserved =   (( ( (rspbytebuffer[6]  ) | (rspbytebuffer[7]  << 8 )) >> SI2176_PART_INFO_RESPONSE_RESERVED_LSB ) & SI2176_PART_INFO_RESPONSE_RESERVED_MASK );
+                        rsp->part_info.serial   =   (( ( (rspbytebuffer[8]  ) | (rspbytebuffer[9]  << 8 ) | (rspbytebuffer[10] << 16 ) | (rspbytebuffer[11] << 24 )) >> SI2176_PART_INFO_RESPONSE_SERIAL_LSB   ) & SI2176_PART_INFO_RESPONSE_SERIAL_MASK   );
+                        rsp->part_info.romid    =   (( ( (rspbytebuffer[12] )) >> SI2176_PART_INFO_RESPONSE_ROMID_LSB    ) & SI2176_PART_INFO_RESPONSE_ROMID_MASK    );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_PART_INFO_CMD */
+#ifdef SI2176_POWER_DOWN_CMD
+/*---------------------------------------------------*/
+/* SI2176_POWER_DOWN COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char si2176_power_down(struct i2c_client *si2176,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[1];
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_POWER_DOWN_CMD;
+
+        if (si2176_writecommandbytes(si2176, 1, cmdbytebuffer) != 1)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->power_down.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_POWER_DOWN_CMD */
+#ifdef SI2176_POWER_UP_CMD
+/*---------------------------------------------------*/
+/* SI2176_POWER_UP COMMAND                         */
+/*---------------------------------------------------*/
+static unsigned char si2176_power_up(struct i2c_client *si2176,
+                unsigned char   subcode,
+                unsigned char   reserved1,
+                unsigned char   reserved2,
+                unsigned char   reserved3,
+                unsigned char   clock_mode,
+                unsigned char   clock_freq,
+                unsigned char   addr_mode,
+                unsigned char   func,
+                unsigned char   ctsien,
+                unsigned char   wake_up,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[9];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (subcode    > SI2176_POWER_UP_CMD_SUBCODE_MAX   )  || (subcode    < SI2176_POWER_UP_CMD_SUBCODE_MIN   )
+                        || (reserved1  > SI2176_POWER_UP_CMD_RESERVED1_MAX )  || (reserved1  < SI2176_POWER_UP_CMD_RESERVED1_MIN )
+                        || (reserved2  > SI2176_POWER_UP_CMD_RESERVED2_MAX )
+                        || (reserved3  > SI2176_POWER_UP_CMD_RESERVED3_MAX )
+                        || (clock_mode > SI2176_POWER_UP_CMD_CLOCK_MODE_MAX)  || (clock_mode < SI2176_POWER_UP_CMD_CLOCK_MODE_MIN)
+                        || (clock_freq > SI2176_POWER_UP_CMD_CLOCK_FREQ_MAX)
+                        || (addr_mode  > SI2176_POWER_UP_CMD_ADDR_MODE_MAX )
+                        || (func       > SI2176_POWER_UP_CMD_FUNC_MAX      )
+                        || (ctsien     > SI2176_POWER_UP_CMD_CTSIEN_MAX    )
+                        || (wake_up    > SI2176_POWER_UP_CMD_WAKE_UP_MAX   )  || (wake_up    < SI2176_POWER_UP_CMD_WAKE_UP_MIN   ) )
+
+        {
+                if(SI2176_DEBUG)
+                        pr_info("%s: DEBUG_RANGE_CHECK!!!!\n", __func__);
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+        }
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_POWER_UP_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( subcode    & SI2176_POWER_UP_CMD_SUBCODE_MASK    ) << SI2176_POWER_UP_CMD_SUBCODE_LSB   );
+        cmdbytebuffer[2] = (unsigned char) ( ( reserved1  & SI2176_POWER_UP_CMD_RESERVED1_MASK  ) << SI2176_POWER_UP_CMD_RESERVED1_LSB );
+        cmdbytebuffer[3] = (unsigned char) ( ( reserved2  & SI2176_POWER_UP_CMD_RESERVED2_MASK  ) << SI2176_POWER_UP_CMD_RESERVED2_LSB );
+        cmdbytebuffer[4] = (unsigned char) ( ( reserved3  & SI2176_POWER_UP_CMD_RESERVED3_MASK  ) << SI2176_POWER_UP_CMD_RESERVED3_LSB );
+        cmdbytebuffer[5] = (unsigned char) ( ( clock_mode & SI2176_POWER_UP_CMD_CLOCK_MODE_MASK ) << SI2176_POWER_UP_CMD_CLOCK_MODE_LSB|
+                        ( clock_freq & SI2176_POWER_UP_CMD_CLOCK_FREQ_MASK ) << SI2176_POWER_UP_CMD_CLOCK_FREQ_LSB);
+        cmdbytebuffer[6] = (unsigned char) ( ( addr_mode  & SI2176_POWER_UP_CMD_ADDR_MODE_MASK  ) << SI2176_POWER_UP_CMD_ADDR_MODE_LSB );
+        cmdbytebuffer[7] = (unsigned char) ( ( func       & SI2176_POWER_UP_CMD_FUNC_MASK       ) << SI2176_POWER_UP_CMD_FUNC_LSB      |
+                        ( ctsien     & SI2176_POWER_UP_CMD_CTSIEN_MASK     ) << SI2176_POWER_UP_CMD_CTSIEN_LSB    );
+        cmdbytebuffer[8] = (unsigned char) ( ( wake_up    & SI2176_POWER_UP_CMD_WAKE_UP_MASK    ) << SI2176_POWER_UP_CMD_WAKE_UP_LSB   );
+
+        if (si2176_writecommandbytes(si2176, 9, cmdbytebuffer) != 9)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                if (error_code)
+                        pr_info("%s: si2176_writecommandbytes!!!!\n", __func__);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+
+                rsp->power_up.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_POWER_UP_CMD */
+#ifdef SI2176_SET_PROPERTY_CMD
+/*---------------------------------------------------*/
+/* SI2176_SET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char si2176_set_property(struct i2c_client *si2176,
+                unsigned char   reserved,
+                unsigned int    prop,
+                unsigned int    data,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[6];
+        unsigned char rspbytebuffer[4];
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_SET_PROPERTY_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( reserved & SI2176_SET_PROPERTY_CMD_RESERVED_MASK ) << SI2176_SET_PROPERTY_CMD_RESERVED_LSB);
+        cmdbytebuffer[2] = (unsigned char) ( ( prop     & SI2176_SET_PROPERTY_CMD_PROP_MASK     ) << SI2176_SET_PROPERTY_CMD_PROP_LSB    );
+        cmdbytebuffer[3] = (unsigned char) ((( prop     & SI2176_SET_PROPERTY_CMD_PROP_MASK     ) << SI2176_SET_PROPERTY_CMD_PROP_LSB    )>>8);
+        cmdbytebuffer[4] = (unsigned char) ( ( data     & SI2176_SET_PROPERTY_CMD_DATA_MASK     ) << SI2176_SET_PROPERTY_CMD_DATA_LSB    );
+        cmdbytebuffer[5] = (unsigned char) ((( data     & SI2176_SET_PROPERTY_CMD_DATA_MASK     ) << SI2176_SET_PROPERTY_CMD_DATA_LSB    )>>8);
+
+        if (si2176_writecommandbytes(si2176, 6, cmdbytebuffer) != 6)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 4, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->set_property.status = &reply;
+                if (!error_code)
+                {
+                        rsp->set_property.reserved =   (( ( (rspbytebuffer[1]  )) >> SI2176_SET_PROPERTY_RESPONSE_RESERVED_LSB ) & SI2176_SET_PROPERTY_RESPONSE_RESERVED_MASK );
+                        rsp->set_property.data     =   (( ( (rspbytebuffer[2]  ) | (rspbytebuffer[3]  << 8 )) >> SI2176_SET_PROPERTY_RESPONSE_DATA_LSB     ) & SI2176_SET_PROPERTY_RESPONSE_DATA_MASK     );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_SET_PROPERTY_CMD */
+#ifdef SI2176_STANDBY_CMD
+/*---------------------------------------------------*/
+/* SI2176_STANDBY COMMAND                          */
+/*---------------------------------------------------*/
+static unsigned char si2176_standby(struct i2c_client *si2176,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[1];
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_STANDBY_CMD;
+
+        if (si2176_writecommandbytes(si2176, 1, cmdbytebuffer) != 1)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->standby.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_STANDBY_CMD */
+#ifdef SI2176_TUNER_STATUS_CMD
+/*---------------------------------------------------*/
+/* SI2176_TUNER_STATUS COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char si2176_tuner_status(struct i2c_client *si2176,
+                unsigned char   intack,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[12];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (intack > SI2176_TUNER_STATUS_CMD_INTACK_MAX) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_TUNER_STATUS_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( intack & SI2176_TUNER_STATUS_CMD_INTACK_MASK ) << SI2176_TUNER_STATUS_CMD_INTACK_LSB);
+
+        if (si2176_writecommandbytes(si2176, 2, cmdbytebuffer) != 2)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 12, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->tuner_status.status = &reply;
+                if (!error_code)
+                {
+                        rsp->tuner_status.tcint          = (( ( (rspbytebuffer[1]  )) >> SI2176_TUNER_STATUS_RESPONSE_TCINT_LSB    ) & SI2176_TUNER_STATUS_RESPONSE_TCINT_MASK    );
+                        rsp->tuner_status.rssilint      = (( ( (rspbytebuffer[1]  )) >> SI2176_TUNER_STATUS_RESPONSE_RSSILINT_LSB ) & SI2176_TUNER_STATUS_RESPONSE_RSSILINT_MASK );
+                        rsp->tuner_status.rssihint     = (( ( (rspbytebuffer[1]  )) >> SI2176_TUNER_STATUS_RESPONSE_RSSIHINT_LSB ) & SI2176_TUNER_STATUS_RESPONSE_RSSIHINT_MASK );
+                        rsp->tuner_status.tc              = (( ( (rspbytebuffer[2]  )) >> SI2176_TUNER_STATUS_RESPONSE_TC_LSB       ) & SI2176_TUNER_STATUS_RESPONSE_TC_MASK       );
+                        rsp->tuner_status.rssil          = (( ( (rspbytebuffer[2]  )) >> SI2176_TUNER_STATUS_RESPONSE_RSSIL_LSB    ) & SI2176_TUNER_STATUS_RESPONSE_RSSIL_MASK    );
+                        rsp->tuner_status.rssih         = (( ( (rspbytebuffer[2]  )) >> SI2176_TUNER_STATUS_RESPONSE_RSSIH_LSB    ) & SI2176_TUNER_STATUS_RESPONSE_RSSIH_MASK    );
+                        rsp->tuner_status.rssi           = (((( ( (rspbytebuffer[3]  )) >> SI2176_TUNER_STATUS_RESPONSE_RSSI_LSB     ) & SI2176_TUNER_STATUS_RESPONSE_RSSI_MASK) <<SI2176_TUNER_STATUS_RESPONSE_RSSI_SHIFT ) >>SI2176_TUNER_STATUS_RESPONSE_RSSI_SHIFT     );
+                        rsp->tuner_status.freq          = (( ( (rspbytebuffer[4]  ) | (rspbytebuffer[5]  << 8 ) | (rspbytebuffer[6]  << 16 ) | (rspbytebuffer[7]  << 24 )) >> SI2176_TUNER_STATUS_RESPONSE_FREQ_LSB     ) & SI2176_TUNER_STATUS_RESPONSE_FREQ_MASK     );
+                        rsp->tuner_status.mode        = (( ( (rspbytebuffer[8]  )) >> SI2176_TUNER_STATUS_RESPONSE_MODE_LSB     ) & SI2176_TUNER_STATUS_RESPONSE_MODE_MASK     );
+                        rsp->tuner_status.vco_code = (((( ( (rspbytebuffer[10] ) | (rspbytebuffer[11] << 8 )) >> SI2176_TUNER_STATUS_RESPONSE_VCO_CODE_LSB ) & SI2176_TUNER_STATUS_RESPONSE_VCO_CODE_MASK) <<SI2176_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT ) >>SI2176_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_TUNER_STATUS_CMD */
+#ifdef SI2176_TUNER_TUNE_FREQ_CMD
+/*---------------------------------------------------*/
+/* SI2176_TUNER_TUNE_FREQ COMMAND                  */
+/*---------------------------------------------------*/
+unsigned char si2176_tuner_tune_freq(struct i2c_client *si2176,
+                unsigned char   mode,
+                unsigned long   freq,
+                si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[8];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (mode > SI2176_TUNER_TUNE_FREQ_CMD_MODE_MAX)
+                        || (freq > SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MAX)  || (freq < SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MIN) )
+                return ERROR_SI2176_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2176_pollforcts(si2176);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2176_TUNER_TUNE_FREQ_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( mode & SI2176_TUNER_TUNE_FREQ_CMD_MODE_MASK ) << SI2176_TUNER_TUNE_FREQ_CMD_MODE_LSB);
+        cmdbytebuffer[2] = (unsigned char)0x00;
+        cmdbytebuffer[3] = (unsigned char)0x00;
+        cmdbytebuffer[4] = (unsigned char) ( ( freq & SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2176_TUNER_TUNE_FREQ_CMD_FREQ_LSB);
+        cmdbytebuffer[5] = (unsigned char) ((( freq & SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2176_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>8);
+        cmdbytebuffer[6] = (unsigned char) ((( freq & SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2176_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>16);
+        cmdbytebuffer[7] = (unsigned char) ((( freq & SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2176_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>24);
+
+        if (si2176_writecommandbytes(si2176, 8, cmdbytebuffer) != 8)
+        {
+                error_code = ERROR_SI2176_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2176_pollforresponse(si2176, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->tuner_tune_freq.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2176_TUNER_TUNE_FREQ_CMD */
+/* _commands_insertion_point */
+
+/* _send_command2_insertion_start */
+
+/* --------------------------------------------*/
+/* SEND_COMMAND2 FUNCTION                      */
+/* --------------------------------------------*/
+unsigned char si2176_sendcommand(struct i2c_client *si2176, int cmd, si2176_cmdobj_t *c, si2176_cmdreplyobj_t *rsp)
+{
+        switch (cmd)
+        {
+#ifdef SI2176_AGC_OVERRIDE_CMD
+                case SI2176_AGC_OVERRIDE_CMD:
+                        return si2176_agc_override(si2176, c->agc_override.force_max_gain, c->agc_override.force_top_gain, rsp);
+                        break;
+#endif /*     SI2176_AGC_OVERRIDE_CMD */
+#ifdef SI2176_ATV_CW_TEST_CMD
+                case SI2176_ATV_CW_TEST_CMD:
+                        return si2176_atv_cw_test(si2176, c->atv_cw_test.pc_lock, rsp);
+                        break;
+#endif /*     SI2176_ATV_CW_TEST_CMD */
+#ifdef SI2176_ATV_RESTART_CMD
+                case SI2176_ATV_RESTART_CMD:
+                        return si2176_atv_restart(si2176, c->atv_restart.mode, rsp);
+                        break;
+#endif /*     SI2176_ATV_RESTART_CMD */
+#ifdef SI2176_ATV_STATUS_CMD
+                case SI2176_ATV_STATUS_CMD:
+                        return si2176_atv_status(si2176, c->atv_status.intack, rsp);
+                        break;
+#endif /*     SI2176_ATV_STATUS_CMD */
+#ifdef SI2176_CONFIG_PINS_CMD
+                case SI2176_CONFIG_PINS_CMD:
+                        return si2176_config_pins(si2176, c->config_pins.gpio1_mode, c->config_pins.gpio1_read, c->config_pins.gpio2_mode, c->config_pins.gpio2_read, c->config_pins.gpio3_mode, c->config_pins.gpio3_read, c->config_pins.bclk1_mode, c->config_pins.bclk1_read, c->config_pins.xout_mode, rsp);
+                        break;
+#endif /*     SI2176_CONFIG_PINS_CMD */
+#ifdef SI2176_EXIT_BOOTLOADER_CMD
+                case SI2176_EXIT_BOOTLOADER_CMD:
+                        return si2176_exit_bootloader(si2176, c->exit_bootloader.func, c->exit_bootloader.ctsien, rsp);
+                        break;
+#endif /*     SI2176_EXIT_BOOTLOADER_CMD */
+#ifdef SI2176_FINE_TUNE_CMD
+                case SI2176_FINE_TUNE_CMD:
+                        return si2176_fine_tune(si2176, c->fine_tune.reserved, c->fine_tune.offset_500hz, rsp);
+                        break;
+#endif /*     SI2176_FINE_TUNE_CMD */
+#ifdef SI2176_GET_PROPERTY_CMD
+                case SI2176_GET_PROPERTY_CMD:
+                        return si2176_get_property(si2176, c->get_property.reserved, c->get_property.prop, rsp);
+                        break;
+#endif /*     SI2176_GET_PROPERTY_CMD */
+#ifdef SI2176_GET_REV_CMD
+                case SI2176_GET_REV_CMD:
+                        return si2176_get_rev(si2176, rsp);
+                        break;
+#endif /*     SI2176_GET_REV_CMD */
+#ifdef SI2176_PART_INFO_CMD
+                case SI2176_PART_INFO_CMD:
+                        return si2176_part_info(si2176, rsp);
+                        break;
+#endif /*     SI2176_PART_INFO_CMD */
+#ifdef SI2176_POWER_DOWN_CMD
+                case SI2176_POWER_DOWN_CMD:
+                        return si2176_power_down(si2176, rsp);
+                        break;
+#endif /*     SI2176_POWER_DOWN_CMD */
+#ifdef SI2176_POWER_UP_CMD
+                case SI2176_POWER_UP_CMD:
+                        return si2176_power_up(si2176, c->power_up.subcode, c->power_up.reserved1, c->power_up.reserved2, c->power_up.reserved3, c->power_up.clock_mode, c->power_up.clock_freq, c->power_up.addr_mode, c->power_up.func, c->power_up.ctsien, c->power_up.wake_up, rsp);
+                        break;
+#endif /*     SI2176_POWER_UP_CMD */
+#ifdef SI2176_SET_PROPERTY_CMD
+                case SI2176_SET_PROPERTY_CMD:
+                        return si2176_set_property(si2176, c->set_property.reserved, c->set_property.prop, c->set_property.data, rsp);
+                        break;
+#endif /*     SI2176_SET_PROPERTY_CMD */
+#ifdef SI2176_STANDBY_CMD
+                case SI2176_STANDBY_CMD:
+                        return si2176_standby(si2176, rsp);
+                        break;
+#endif /*     SI2176_STANDBY_CMD */
+#ifdef SI2176_TUNER_STATUS_CMD
+                case SI2176_TUNER_STATUS_CMD:
+                        return si2176_tuner_status(si2176, c->tuner_status.intack, rsp);
+                        break;
+#endif /*     SI2176_TUNER_STATUS_CMD */
+#ifdef SI2176_TUNER_TUNE_FREQ_CMD
+                case SI2176_TUNER_TUNE_FREQ_CMD:
+                        return si2176_tuner_tune_freq(si2176, c->tuner_tune_freq.mode, c->tuner_tune_freq.freq, rsp);
+                        break;
+#endif /*     SI2176_TUNER_TUNE_FREQ_CMD */
+                default :
+                        break;
+        }
+        return 0;
+}
+/* _send_command2_insertion_point */
+
+/***********************************************************************************************************************
+  si2176_setproperty function
+Use:        property set function
+Used to call L1_SET_PROPERTY with the property Id and data provided.
+Comments:   This is a way to make sure CTS is polled when setting a property
+Parameter: *api     the SI2176 context
+Parameter: waitforcts flag to wait for a CTS before issuing the property command
+Parameter: waitforresponse flag to wait for a CTS after issuing the property command
+Parameter: prop     the property Id
+Parameter: data     the property bytes
+Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2176_setproperty(struct i2c_client *si2176, unsigned int prop, int  data, si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char  reserved          = 0;
+        return si2176_set_property(si2176, reserved, prop, data, rsp);
+}
+
+/***********************************************************************************************************************
+  si2176_getproperty function
+Use:        property get function
+Used to call L1_GET_PROPERTY with the property Id provided.
+Comments:   This is a way to make sure CTS is polled when retrieving a property
+Parameter: *api     the SI2176 context
+Parameter: waitforcts flag to wait for a CTS before issuing the property command
+Parameter: waitforresponse flag to wait for a CTS after issuing the property command
+Parameter: prop     the property Id
+Parameter: *data    a buffer to store the property bytes into
+Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2176_getproperty(struct i2c_client *si2176, unsigned int prop, int *data, si2176_cmdreplyobj_t *rsp)
+{
+        unsigned char reserved = 0;
+        unsigned char res;
+        res = si2176_get_property(si2176, reserved, prop, rsp);
+        *data = rsp->get_property.data;
+        return res;
+}
+
+/* _set_property2_insertion_start */
+
+/* --------------------------------------------*/
+/* SET_PROPERTY2 FUNCTION                      */
+/* --------------------------------------------*/
+unsigned char si2176_sendproperty(struct i2c_client *si2176, unsigned int prop, si2176_propobj_t *p, si2176_cmdreplyobj_t *rsp)
+{
+        int data = 0;
+        switch (prop)
+        {
+#ifdef SI2176_ATV_AFC_RANGE_PROP
+                case SI2176_ATV_AFC_RANGE_PROP:
+                        data = (p->atv_afc_range.range_khz & SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK) << SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+                        break;
+#endif /*     SI2176_ATV_AFC_RANGE_PROP */
+#ifdef SI2176_ATV_AF_OUT_PROP
+                case SI2176_ATV_AF_OUT_PROP:
+                        data = (p->atv_af_out.volume & SI2176_ATV_AF_OUT_PROP_VOLUME_MASK) << SI2176_ATV_AF_OUT_PROP_VOLUME_LSB |
+                               (p->atv_af_out.soft_mute & SI2176_ATV_AF_OUT_PROP_SOFT_MUTE_MASK) << SI2176_ATV_AF_OUT_PROP_SOFT_MUTE_LSB;
+                        break;
+#endif /*     SI2176_ATV_AF_OUT_PROP */
+#ifdef SI2176_ATV_AGC_SPEED_PROP
+                case SI2176_ATV_AGC_SPEED_PROP:
+                        data = (p->atv_agc_speed.if_agc_speed & SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB ;
+                        break;
+#endif /*     SI2176_ATV_AGC_SPEED_PROP */
+#ifdef SI2176_ATV_AUDIO_MODE_PROP
+                case SI2176_ATV_AUDIO_MODE_PROP:
+                        data = (p->atv_audio_mode.audio_sys  & SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK ) << SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB  |
+                                (p->atv_audio_mode.demod_mode & SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK) << SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB  |
+                                (p->atv_audio_mode.chan_bw    & SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK   ) << SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB ;
+                        break;
+#endif /*     SI2176_ATV_AUDIO_MODE_PROP */
+#ifdef SI2176_ATV_CVBS_OUT_PROP
+                case SI2176_ATV_CVBS_OUT_PROP:
+                        data = (p->atv_cvbs_out.offset & SI2176_ATV_CVBS_OUT_PROP_OFFSET_MASK) << SI2176_ATV_CVBS_OUT_PROP_OFFSET_LSB  |
+                                (p->atv_cvbs_out.amp    & SI2176_ATV_CVBS_OUT_PROP_AMP_MASK   ) << SI2176_ATV_CVBS_OUT_PROP_AMP_LSB ;
+                        break;
+#endif /*     SI2176_ATV_CVBS_OUT_PROP */
+#ifdef SI2176_ATV_CVBS_OUT_FINE_PROP
+                case SI2176_ATV_CVBS_OUT_FINE_PROP:
+                        data = (p->atv_cvbs_out_fine.offset & SI2176_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK) << SI2176_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB  |
+                                (p->atv_cvbs_out_fine.amp    & SI2176_ATV_CVBS_OUT_FINE_PROP_AMP_MASK   ) << SI2176_ATV_CVBS_OUT_FINE_PROP_AMP_LSB ;
+                        break;
+#endif /*     SI2176_ATV_CVBS_OUT_FINE_PROP */
+#ifdef SI2176_ATV_IEN_PROP
+                case SI2176_ATV_IEN_PROP:
+                        data = (p->atv_ien.chlien  & SI2176_ATV_IEN_PROP_CHLIEN_MASK ) << SI2176_ATV_IEN_PROP_CHLIEN_LSB  |
+                                (p->atv_ien.pclien  & SI2176_ATV_IEN_PROP_PCLIEN_MASK ) << SI2176_ATV_IEN_PROP_PCLIEN_LSB  |
+                                (p->atv_ien.dlien   & SI2176_ATV_IEN_PROP_DLIEN_MASK  ) << SI2176_ATV_IEN_PROP_DLIEN_LSB  |
+                                (p->atv_ien.snrlien & SI2176_ATV_IEN_PROP_SNRLIEN_MASK) << SI2176_ATV_IEN_PROP_SNRLIEN_LSB  |
+                                (p->atv_ien.snrhien & SI2176_ATV_IEN_PROP_SNRHIEN_MASK) << SI2176_ATV_IEN_PROP_SNRHIEN_LSB ;
+                        break;
+#endif /*     SI2176_ATV_IEN_PROP */
+#ifdef SI2176_ATV_INT_SENSE_PROP
+                case SI2176_ATV_INT_SENSE_PROP:
+                        data = (p->atv_int_sense.chlnegen  & SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_MASK ) << SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+                                (p->atv_int_sense.pclnegen  & SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_MASK ) << SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_LSB  |
+                                (p->atv_int_sense.dlnegen   & SI2176_ATV_INT_SENSE_PROP_DLNEGEN_MASK  ) << SI2176_ATV_INT_SENSE_PROP_DLNEGEN_LSB  |
+                                (p->atv_int_sense.snrlnegen & SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK) << SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB  |
+                                (p->atv_int_sense.snrhnegen & SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK) << SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB  |
+                                (p->atv_int_sense.chlposen  & SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_MASK ) << SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_LSB  |
+                                (p->atv_int_sense.pclposen  & SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_MASK ) << SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_LSB  |
+                                (p->atv_int_sense.dlposen   & SI2176_ATV_INT_SENSE_PROP_DLPOSEN_MASK  ) << SI2176_ATV_INT_SENSE_PROP_DLPOSEN_LSB  |
+                                (p->atv_int_sense.snrlposen & SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK) << SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB  |
+                                (p->atv_int_sense.snrhposen & SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK) << SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB ;
+                        break;
+#endif /*     SI2176_ATV_INT_SENSE_PROP */
+#ifdef SI2176_ATV_MIN_LVL_LOCK_PROP
+                case SI2176_ATV_MIN_LVL_LOCK_PROP:
+                        data = (p->atv_min_lvl_lock.thrs & SI2176_ATV_MIN_LVL_LOCK_PROP_THRS_MASK) << SI2176_ATV_MIN_LVL_LOCK_PROP_THRS_LSB ;
+                        break;
+#endif /*     SI2176_ATV_MIN_LVL_LOCK_PROP */
+#ifdef SI2176_ATV_RF_TOP_PROP
+                case SI2176_ATV_RF_TOP_PROP:
+                        data = (p->atv_rf_top.atv_rf_top & SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK) << SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB ;
+                        break;
+#endif /*     SI2176_ATV_RF_TOP_PROP */
+#ifdef SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP
+                case SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP:
+                        data = (p->atv_rsq_rssi_threshold.lo & SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+                                (p->atv_rsq_rssi_threshold.hi & SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+                        break;
+#endif /*     SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef SI2176_ATV_RSQ_SNR_THRESHOLD_PROP
+                case SI2176_ATV_RSQ_SNR_THRESHOLD_PROP:
+                        data = (p->atv_rsq_snr_threshold.lo & SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK) << SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB  |
+                                (p->atv_rsq_snr_threshold.hi & SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK) << SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB ;
+                        break;
+#endif /*     SI2176_ATV_RSQ_SNR_THRESHOLD_PROP */
+#ifdef Si2176_ATV_SOUND_AGC_SPEED_PROP
+                case Si2176_ATV_SOUND_AGC_SPEED_PROP:
+                        data = (p->atv_sound_agc.other_systems & Si2176_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK) << Si2176_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB |
+                                (p->atv_sound_agc.system_l & Si2176_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK) << Si2176_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB;
+                        break;
+#endif
+#ifdef SI2176_ATV_SIF_OUT_PROP
+                case SI2176_ATV_SIF_OUT_PROP:
+                        data = (p->atv_sif_out.offset & SI2176_ATV_SIF_OUT_PROP_OFFSET_MASK) << SI2176_ATV_SIF_OUT_PROP_OFFSET_LSB  |
+                                (p->atv_sif_out.amp    & SI2176_ATV_SIF_OUT_PROP_AMP_MASK   ) << SI2176_ATV_SIF_OUT_PROP_AMP_LSB ;
+                        break;
+#endif /*     SI2176_ATV_SIF_OUT_PROP */
+#ifdef SI2176_ATV_SOUND_AGC_LIMIT_PROP
+                case SI2176_ATV_SOUND_AGC_LIMIT_PROP:
+                        data = (p->atv_sound_agc_limit.max_gain & SI2176_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK) << SI2176_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB  |
+                                (p->atv_sound_agc_limit.min_gain & SI2176_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK) << SI2176_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB ;
+                        break;
+#endif /*     SI2176_ATV_SOUND_AGC_LIMIT_PROP */
+#ifdef SI2176_ATV_VIDEO_EQUALIZER_PROP
+                case SI2176_ATV_VIDEO_EQUALIZER_PROP:
+                        data = (p->atv_video_equalizer.slope & SI2176_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK) << SI2176_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB ;
+                        break;
+#endif /*     SI2176_ATV_VIDEO_EQUALIZER_PROP */
+#ifdef SI2176_ATV_VIDEO_MODE_PROP
+                case SI2176_ATV_VIDEO_MODE_PROP:
+                        data = (p->atv_video_mode.video_sys       & SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK      ) << SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB  |
+                                (p->atv_video_mode.color           & SI2176_ATV_VIDEO_MODE_PROP_COLOR_MASK          ) << SI2176_ATV_VIDEO_MODE_PROP_COLOR_LSB  |
+                                (p->atv_video_mode.trans           & SI2176_ATV_VIDEO_MODE_PROP_TRANS_MASK          ) << SI2176_ATV_VIDEO_MODE_PROP_TRANS_LSB  |
+                                (p->atv_video_mode.invert_signal   & SI2176_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK  ) << SI2176_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB ;
+                        break;
+#endif /*     SI2176_ATV_VIDEO_MODE_PROP */
+#ifdef SI2176_ATV_VSNR_CAP_PROP
+                case SI2176_ATV_VSNR_CAP_PROP:
+                        data = (p->atv_vsnr_cap.atv_vsnr_cap & SI2176_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK) << SI2176_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB ;
+                        break;
+#endif /*     SI2176_ATV_VSNR_CAP_PROP */
+#ifdef SI2176_ATV_VSYNC_TRACKING_PROP
+                case SI2176_ATV_VSYNC_TRACKING_PROP:
+                        data = (p->atv_vsync_tracking.min_pulses_to_lock   & SI2176_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK  ) << SI2176_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB  |
+                                (p->atv_vsync_tracking.min_fields_to_unlock & SI2176_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK) << SI2176_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB ;
+                        break;
+#endif /*     SI2176_ATV_VSYNC_TRACKING_PROP */
+
+#ifdef SI2176_ATV_HSYNC_OUT_PROP
+                case SI2176_ATV_HSYNC_OUT_PROP:
+                        data = (p->atv_hsync_out.offset & SI2176_ATV_HSYNC_OUT_PROP_OFFSET_MASK  ) << SI2176_ATV_HSYNC_OUT_PROP_OFFSET_LSB  |
+                                (p->atv_hsync_out.width & SI2176_ATV_HSYNC_OUT_PROP_WIDTH_MASK) << SI2176_ATV_HSYNC_OUT_PROP_WIDTH_LSB |
+                                (p->atv_hsync_out.gpio_sel & SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_MASK) << SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_LSB;
+                        break;
+#endif /*     SI2176_ATV_VSYNC_TRACKING_PROP */
+
+#ifdef SI2176_CRYSTAL_TRIM_PROP
+                case SI2176_CRYSTAL_TRIM_PROP:
+                        data = (p->crystal_trim.xo_cap & SI2176_CRYSTAL_TRIM_PROP_XO_CAP_MASK) << SI2176_CRYSTAL_TRIM_PROP_XO_CAP_LSB ;
+                        break;
+#endif /*     SI2176_CRYSTAL_TRIM_PROP */
+#ifdef SI2176_DTV_LIF_FREQ_PROP
+                case SI2176_DTV_LIF_FREQ_PROP:
+                        data = (p->dtv_lif_freq.offset & SI2176_DTV_LIF_FREQ_PROP_OFFSET_MASK) << SI2176_DTV_LIF_FREQ_PROP_OFFSET_LSB ;
+                        break;
+#endif /*     SI2176_DTV_LIF_FREQ_PROP */
+#ifdef SI2176_DTV_LIF_OUT_PROP
+                case SI2176_DTV_LIF_OUT_PROP:
+                        data = (p->dtv_lif_out.offset & SI2176_DTV_LIF_OUT_PROP_OFFSET_MASK) << SI2176_DTV_LIF_OUT_PROP_OFFSET_LSB  |
+                                (p->dtv_lif_out.amp    & SI2176_DTV_LIF_OUT_PROP_AMP_MASK   ) << SI2176_DTV_LIF_OUT_PROP_AMP_LSB ;
+                        break;
+#endif /*     SI2176_DTV_LIF_OUT_PROP */
+#ifdef SI2176_DTV_MODE_PROP
+                case SI2176_DTV_MODE_PROP:
+                        data = (p->dtv_mode.bw              & SI2176_DTV_MODE_PROP_BW_MASK             ) << SI2176_DTV_MODE_PROP_BW_LSB  |
+                                (p->dtv_mode.modulation      & SI2176_DTV_MODE_PROP_MODULATION_MASK     ) << SI2176_DTV_MODE_PROP_MODULATION_LSB  |
+                                (p->dtv_mode.invert_spectrum & SI2176_DTV_MODE_PROP_INVERT_SPECTRUM_MASK) << SI2176_DTV_MODE_PROP_INVERT_SPECTRUM_LSB ;
+                        break;
+#endif /*     SI2176_DTV_MODE_PROP */
+#ifdef SI2176_DTV_RF_TOP_PROP
+                case SI2176_DTV_RF_TOP_PROP:
+                        data = (p->dtv_rf_top.dtv_rf_top & SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK) << SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB ;
+                        break;
+#endif /*     SI2176_DTV_RF_TOP_PROP */
+#ifdef SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP
+                case SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP:
+                        data = (p->dtv_rsq_rssi_threshold.lo & SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+                                (p->dtv_rsq_rssi_threshold.hi & SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+                        break;
+#endif /*     SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef SI2176_MASTER_IEN_PROP
+                case SI2176_MASTER_IEN_PROP:
+                        data = (p->master_ien.tunien & SI2176_MASTER_IEN_PROP_TUNIEN_MASK) << SI2176_MASTER_IEN_PROP_TUNIEN_LSB  |
+                                (p->master_ien.atvien & SI2176_MASTER_IEN_PROP_ATVIEN_MASK) << SI2176_MASTER_IEN_PROP_ATVIEN_LSB  |
+                                (p->master_ien.dtvien & SI2176_MASTER_IEN_PROP_DTVIEN_MASK) << SI2176_MASTER_IEN_PROP_DTVIEN_LSB  |
+                                (p->master_ien.errien & SI2176_MASTER_IEN_PROP_ERRIEN_MASK) << SI2176_MASTER_IEN_PROP_ERRIEN_LSB  |
+                                (p->master_ien.ctsien & SI2176_MASTER_IEN_PROP_CTSIEN_MASK) << SI2176_MASTER_IEN_PROP_CTSIEN_LSB ;
+                        break;
+#endif /*     SI2176_MASTER_IEN_PROP */
+#ifdef SI2176_TUNER_BLOCKED_VCO_PROP
+                case SI2176_TUNER_BLOCKED_VCO_PROP:
+                        data = (p->tuner_blocked_vco.vco_code & SI2176_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK) << SI2176_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB ;
+                        break;
+#endif /*     SI2176_TUNER_BLOCKED_VCO_PROP */
+#ifdef SI2176_TUNER_IEN_PROP
+                case SI2176_TUNER_IEN_PROP:
+                        data = (p->tuner_ien.tcien    & SI2176_TUNER_IEN_PROP_TCIEN_MASK   ) << SI2176_TUNER_IEN_PROP_TCIEN_LSB  |
+                                (p->tuner_ien.rssilien & SI2176_TUNER_IEN_PROP_RSSILIEN_MASK) << SI2176_TUNER_IEN_PROP_RSSILIEN_LSB  |
+                                (p->tuner_ien.rssihien & SI2176_TUNER_IEN_PROP_RSSIHIEN_MASK) << SI2176_TUNER_IEN_PROP_RSSIHIEN_LSB ;
+                        break;
+#endif /*     SI2176_TUNER_IEN_PROP */
+#ifdef SI2176_TUNER_INT_SENSE_PROP
+                case SI2176_TUNER_INT_SENSE_PROP:
+                        data = (p->tuner_int_sense.tcnegen    & SI2176_TUNER_INT_SENSE_PROP_TCNEGEN_MASK   ) << SI2176_TUNER_INT_SENSE_PROP_TCNEGEN_LSB  |
+                                (p->tuner_int_sense.rssilnegen & SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK) << SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB  |
+                                (p->tuner_int_sense.rssihnegen & SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK) << SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB  |
+                                (p->tuner_int_sense.tcposen    & SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_MASK   ) << SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_LSB  |
+                                (p->tuner_int_sense.rssilposen & SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK) << SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB  |
+                                (p->tuner_int_sense.rssihposen & SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK) << SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB ;
+                        break;
+#endif /*     SI2176_TUNER_INT_SENSE_PROP */
+#ifdef SI2176_TUNER_LO_INJECTION_PROP
+                case SI2176_TUNER_LO_INJECTION_PROP:
+                        data = (p->tuner_lo_injection.band_1 & SI2176_TUNER_LO_INJECTION_PROP_BAND_1_MASK) << SI2176_TUNER_LO_INJECTION_PROP_BAND_1_LSB  |
+                                (p->tuner_lo_injection.band_2 & SI2176_TUNER_LO_INJECTION_PROP_BAND_2_MASK) << SI2176_TUNER_LO_INJECTION_PROP_BAND_2_LSB  |
+                                (p->tuner_lo_injection.band_3 & SI2176_TUNER_LO_INJECTION_PROP_BAND_3_MASK) << SI2176_TUNER_LO_INJECTION_PROP_BAND_3_LSB  |
+                                (p->tuner_lo_injection.band_4 & SI2176_TUNER_LO_INJECTION_PROP_BAND_4_MASK) << SI2176_TUNER_LO_INJECTION_PROP_BAND_4_LSB  |
+                                (p->tuner_lo_injection.band_5 & SI2176_TUNER_LO_INJECTION_PROP_BAND_5_MASK) << SI2176_TUNER_LO_INJECTION_PROP_BAND_5_LSB ;
+                        break;
+#endif /*     SI2176_TUNER_LO_INJECTION_PROP */
+                default :
+                        break;
+        }
+        return si2176_setproperty(si2176, prop , data, rsp);
+}
+/* _set_property2_insertion_point */
+
+/* _get_property2_insertion_start */
+
+/* --------------------------------------------*/
+/* GET_PROPERTY2 FUNCTION                       */
+/* --------------------------------------------*/
+unsigned char si2176_receiveproperty(struct i2c_client *si2176, unsigned int prop, si2176_propobj_t *p, si2176_cmdreplyobj_t *rsp)
+{
+        int data, res;
+
+        res = si2176_getproperty(si2176, prop, &data, rsp);
+
+        if (res!=NO_SI2176_ERROR)
+                return res;
+        switch (prop)
+        {
+#ifdef SI2176_ATV_AFC_RANGE_PROP
+                case SI2176_ATV_AFC_RANGE_PROP:
+                        p->atv_afc_range.range_khz = (data >> SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB) & SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK;
+                        break;
+#endif /*     SI2176_ATV_AFC_RANGE_PROP */
+#ifdef SI2176_ATV_AF_OUT_PROP
+                case SI2176_ATV_AF_OUT_PROP:
+                        p->atv_af_out.volume = (data >> SI2176_ATV_AF_OUT_PROP_VOLUME_LSB) & SI2176_ATV_AF_OUT_PROP_VOLUME_MASK;
+                        p->atv_af_out.soft_mute = (data >> SI2176_ATV_AF_OUT_PROP_SOFT_MUTE_LSB) & SI2176_ATV_AF_OUT_PROP_SOFT_MUTE_MASK;
+                        break;
+#endif /*     SI2176_ATV_AF_OUT_PROP */
+#ifdef SI2176_ATV_AGC_SPEED_PROP
+                case SI2176_ATV_AGC_SPEED_PROP:
+                        p->atv_agc_speed.if_agc_speed = (data >> SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB) & SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK;
+                        break;
+#endif /*     SI2176_ATV_AGC_SPEED_PROP */
+#ifdef SI2176_ATV_AUDIO_MODE_PROP
+                case SI2176_ATV_AUDIO_MODE_PROP:
+                        p->atv_audio_mode.audio_sys      = (data >> SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB ) & SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK;
+                        p->atv_audio_mode.demod_mode = (data >> SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB) & SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK;
+                        p->atv_audio_mode.chan_bw        = (data >> SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB   ) & SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK;
+                        break;
+#endif /*     SI2176_ATV_AUDIO_MODE_PROP */
+#ifdef SI2176_ATV_CVBS_OUT_PROP
+                case SI2176_ATV_CVBS_OUT_PROP:
+                        p->atv_cvbs_out.offset = (data >> SI2176_ATV_CVBS_OUT_PROP_OFFSET_LSB) & SI2176_ATV_CVBS_OUT_PROP_OFFSET_MASK;
+                        p->atv_cvbs_out.amp   = (data >> SI2176_ATV_CVBS_OUT_PROP_AMP_LSB   ) & SI2176_ATV_CVBS_OUT_PROP_AMP_MASK;
+                        break;
+#endif /*     SI2176_ATV_CVBS_OUT_PROP */
+#ifdef SI2176_ATV_CVBS_OUT_FINE_PROP
+                case SI2176_ATV_CVBS_OUT_FINE_PROP:
+                        p->atv_cvbs_out_fine.offset = (data >> SI2176_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB) & SI2176_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK;
+                        p->atv_cvbs_out_fine.amp   = (data >> SI2176_ATV_CVBS_OUT_FINE_PROP_AMP_LSB   ) & SI2176_ATV_CVBS_OUT_FINE_PROP_AMP_MASK;
+                        break;
+#endif /*     SI2176_ATV_CVBS_OUT_FINE_PROP */
+#ifdef SI2176_ATV_IEN_PROP
+                case SI2176_ATV_IEN_PROP:
+                        p->atv_ien.chlien   = (data >> SI2176_ATV_IEN_PROP_CHLIEN_LSB ) & SI2176_ATV_IEN_PROP_CHLIEN_MASK;
+                        p->atv_ien.pclien   = (data >> SI2176_ATV_IEN_PROP_PCLIEN_LSB ) & SI2176_ATV_IEN_PROP_PCLIEN_MASK;
+                        p->atv_ien.dlien     = (data >> SI2176_ATV_IEN_PROP_DLIEN_LSB  ) & SI2176_ATV_IEN_PROP_DLIEN_MASK;
+                        p->atv_ien.snrlien  = (data >> SI2176_ATV_IEN_PROP_SNRLIEN_LSB) & SI2176_ATV_IEN_PROP_SNRLIEN_MASK;
+                        p->atv_ien.snrhien = (data >> SI2176_ATV_IEN_PROP_SNRHIEN_LSB) & SI2176_ATV_IEN_PROP_SNRHIEN_MASK;
+                        break;
+#endif /*     SI2176_ATV_IEN_PROP */
+#ifdef SI2176_ATV_INT_SENSE_PROP
+                case SI2176_ATV_INT_SENSE_PROP:
+                        p->atv_int_sense.chlnegen  = (data >> SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_LSB ) & SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_MASK;
+                        p->atv_int_sense.pclnegen  = (data >> SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_LSB ) & SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_MASK;
+                        p->atv_int_sense.dlnegen    = (data >> SI2176_ATV_INT_SENSE_PROP_DLNEGEN_LSB  ) & SI2176_ATV_INT_SENSE_PROP_DLNEGEN_MASK;
+                        p->atv_int_sense.snrlnegen = (data >> SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB) & SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK;
+                        p->atv_int_sense.snrhnegen = (data >> SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB) & SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK;
+                        p->atv_int_sense.chlposen   = (data >> SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_LSB ) & SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_MASK;
+                        p->atv_int_sense.pclposen   = (data >> SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_LSB ) & SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_MASK;
+                        p->atv_int_sense.dlposen     = (data >> SI2176_ATV_INT_SENSE_PROP_DLPOSEN_LSB  ) & SI2176_ATV_INT_SENSE_PROP_DLPOSEN_MASK;
+                        p->atv_int_sense.snrlposen  = (data >> SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB) & SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK;
+                        p->atv_int_sense.snrhposen = (data >> SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB) & SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK;
+                        break;
+#endif /*     SI2176_ATV_INT_SENSE_PROP */
+#ifdef SI2176_ATV_MIN_LVL_LOCK_PROP
+                case SI2176_ATV_MIN_LVL_LOCK_PROP:
+                        p->atv_min_lvl_lock.thrs = (data >> SI2176_ATV_MIN_LVL_LOCK_PROP_THRS_LSB) & SI2176_ATV_MIN_LVL_LOCK_PROP_THRS_MASK;
+                        break;
+#endif /*     SI2176_ATV_MIN_LVL_LOCK_PROP */
+#ifdef SI2176_ATV_RF_TOP_PROP
+                case SI2176_ATV_RF_TOP_PROP:
+                        p->atv_rf_top.atv_rf_top = (data >> SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB) & SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK;
+                        break;
+#endif /*     SI2176_ATV_RF_TOP_PROP */
+#ifdef SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP
+                case SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP:
+                        p->atv_rsq_rssi_threshold.lo = (data >> SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB) & SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK;
+                        p->atv_rsq_rssi_threshold.hi = (data >> SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB) & SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK;
+                        break;
+#endif /*     SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef SI2176_ATV_RSQ_SNR_THRESHOLD_PROP
+                case SI2176_ATV_RSQ_SNR_THRESHOLD_PROP:
+                        p->atv_rsq_snr_threshold.lo = (data >> SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB) & SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK;
+                        p->atv_rsq_snr_threshold.hi = (data >> SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB) & SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK;
+                        break;
+#endif /*     SI2176_ATV_RSQ_SNR_THRESHOLD_PROP */
+#ifdef SI2176_ATV_SIF_OUT_PROP
+                case SI2176_ATV_SIF_OUT_PROP:
+                        p->atv_sif_out.offset  = (data >> SI2176_ATV_SIF_OUT_PROP_OFFSET_LSB) & SI2176_ATV_SIF_OUT_PROP_OFFSET_MASK;
+                        p->atv_sif_out.amp    = (data >> SI2176_ATV_SIF_OUT_PROP_AMP_LSB   ) & SI2176_ATV_SIF_OUT_PROP_AMP_MASK;
+                        break;
+#endif /*     SI2176_ATV_SIF_OUT_PROP */
+#ifdef SI2176_ATV_SOUND_AGC_LIMIT_PROP
+                case SI2176_ATV_SOUND_AGC_LIMIT_PROP:
+                        p->atv_sound_agc_limit.max_gain = (data >> SI2176_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB) & SI2176_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK;
+                        p->atv_sound_agc_limit.min_gain  = (data >> SI2176_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB) & SI2176_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK;
+                        break;
+#endif /*     SI2176_ATV_SOUND_AGC_LIMIT_PROP */
+#ifdef SI2176_ATV_VIDEO_EQUALIZER_PROP
+                case SI2176_ATV_VIDEO_EQUALIZER_PROP:
+                        p->atv_video_equalizer.slope = (data >> SI2176_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB) & SI2176_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK;
+                        break;
+#endif /*     SI2176_ATV_VIDEO_EQUALIZER_PROP */
+#ifdef SI2176_ATV_VIDEO_MODE_PROP
+                case SI2176_ATV_VIDEO_MODE_PROP:
+                        p->atv_video_mode.video_sys     = (data >> SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB      ) & SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK;
+                        p->atv_video_mode.color             = (data >> SI2176_ATV_VIDEO_MODE_PROP_COLOR_LSB          ) & SI2176_ATV_VIDEO_MODE_PROP_COLOR_MASK;
+                        p->atv_video_mode.trans             = (data >> SI2176_ATV_VIDEO_MODE_PROP_TRANS_LSB          ) & SI2176_ATV_VIDEO_MODE_PROP_TRANS_MASK;
+                        p->atv_video_mode.invert_signal = (data >> SI2176_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB  ) & SI2176_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK;
+                        break;
+#endif /*     SI2176_ATV_VIDEO_MODE_PROP */
+#ifdef SI2176_ATV_VSNR_CAP_PROP
+                case SI2176_ATV_VSNR_CAP_PROP:
+                        p->atv_vsnr_cap.atv_vsnr_cap = (data >> SI2176_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB) & SI2176_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK;
+                        break;
+#endif /*     SI2176_ATV_VSNR_CAP_PROP */
+#ifdef SI2176_ATV_VSYNC_TRACKING_PROP
+                case SI2176_ATV_VSYNC_TRACKING_PROP:
+                        p->atv_vsync_tracking.min_pulses_to_lock   = (data >> SI2176_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB  ) & SI2176_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK;
+                        p->atv_vsync_tracking.min_fields_to_unlock = (data >> SI2176_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB) & SI2176_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK;
+                        break;
+#endif /*     SI2176_ATV_VSYNC_TRACKING_PROP */
+#ifdef SI2176_ATV_HSYNC_OUT_PROP
+                case SI2176_ATV_HSYNC_OUT_PROP:
+                        p->atv_hsync_out.offset = (data >> SI2176_ATV_HSYNC_OUT_PROP_OFFSET_LSB  ) & SI2176_ATV_HSYNC_OUT_PROP_OFFSET_MASK;
+                        p->atv_hsync_out.width = (data >> SI2176_ATV_HSYNC_OUT_PROP_WIDTH_LSB) & SI2176_ATV_HSYNC_OUT_PROP_WIDTH_MASK;
+						p->atv_hsync_out.gpio_sel = (data >> SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_LSB) & SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_MASK;
+                        break;
+#endif /*     SI2176_ATV_HSYNC_TRACKING_PROP */
+
+#ifdef SI2176_CRYSTAL_TRIM_PROP
+                case SI2176_CRYSTAL_TRIM_PROP:
+                        p->crystal_trim.xo_cap = (data >> SI2176_CRYSTAL_TRIM_PROP_XO_CAP_LSB) & SI2176_CRYSTAL_TRIM_PROP_XO_CAP_MASK;
+                        break;
+#endif /*     SI2176_CRYSTAL_TRIM_PROP */
+#ifdef SI2176_MASTER_IEN_PROP
+                case SI2176_MASTER_IEN_PROP:
+                        p->master_ien.tunien = (data >> SI2176_MASTER_IEN_PROP_TUNIEN_LSB) & SI2176_MASTER_IEN_PROP_TUNIEN_MASK;
+                        p->master_ien.atvien = (data >> SI2176_MASTER_IEN_PROP_ATVIEN_LSB) & SI2176_MASTER_IEN_PROP_ATVIEN_MASK;
+                        p->master_ien.dtvien = (data >> SI2176_MASTER_IEN_PROP_DTVIEN_LSB) & SI2176_MASTER_IEN_PROP_DTVIEN_MASK;
+                        p->master_ien.errien = (data >> SI2176_MASTER_IEN_PROP_ERRIEN_LSB) & SI2176_MASTER_IEN_PROP_ERRIEN_MASK;
+                        p->master_ien.ctsien = (data >> SI2176_MASTER_IEN_PROP_CTSIEN_LSB) & SI2176_MASTER_IEN_PROP_CTSIEN_MASK;
+                        break;
+#endif /*     SI2176_MASTER_IEN_PROP */
+#ifdef SI2176_TUNER_BLOCKED_VCO_PROP
+                case SI2176_TUNER_BLOCKED_VCO_PROP:
+                        p->tuner_blocked_vco.vco_code = (data >> SI2176_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB) & SI2176_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK;
+                        break;
+#endif /*     SI2176_TUNER_BLOCKED_VCO_PROP */
+#ifdef SI2176_TUNER_IEN_PROP
+                case SI2176_TUNER_IEN_PROP:
+                        p->tuner_ien.tcien      = (data >> SI2176_TUNER_IEN_PROP_TCIEN_LSB   ) & SI2176_TUNER_IEN_PROP_TCIEN_MASK;
+                        p->tuner_ien.rssilien  = (data >> SI2176_TUNER_IEN_PROP_RSSILIEN_LSB) & SI2176_TUNER_IEN_PROP_RSSILIEN_MASK;
+                        p->tuner_ien.rssihien = (data >> SI2176_TUNER_IEN_PROP_RSSIHIEN_LSB) & SI2176_TUNER_IEN_PROP_RSSIHIEN_MASK;
+                        break;
+#endif /*     SI2176_TUNER_IEN_PROP */
+#ifdef SI2176_TUNER_INT_SENSE_PROP
+                case SI2176_TUNER_INT_SENSE_PROP:
+                        p->tuner_int_sense.tcnegen      = (data >> SI2176_TUNER_INT_SENSE_PROP_TCNEGEN_LSB   ) & SI2176_TUNER_INT_SENSE_PROP_TCNEGEN_MASK;
+                        p->tuner_int_sense.rssilnegen  = (data >> SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB) & SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK;
+                        p->tuner_int_sense.rssihnegen = (data >> SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB) & SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK;
+                        p->tuner_int_sense.tcposen      = (data >> SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_LSB   ) & SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_MASK;
+                        p->tuner_int_sense.rssilposen  = (data >> SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB) & SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK;
+                        p->tuner_int_sense.rssihposen = (data >> SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB) & SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK;
+                        break;
+#endif /*     SI2176_TUNER_INT_SENSE_PROP */
+#ifdef SI2176_TUNER_LO_INJECTION_PROP
+                case SI2176_TUNER_LO_INJECTION_PROP:
+                        p->tuner_lo_injection.band_1 = (data >> SI2176_TUNER_LO_INJECTION_PROP_BAND_1_LSB) & SI2176_TUNER_LO_INJECTION_PROP_BAND_1_MASK;
+                        p->tuner_lo_injection.band_2 = (data >> SI2176_TUNER_LO_INJECTION_PROP_BAND_2_LSB) & SI2176_TUNER_LO_INJECTION_PROP_BAND_2_MASK;
+                        p->tuner_lo_injection.band_3 = (data >> SI2176_TUNER_LO_INJECTION_PROP_BAND_3_LSB) & SI2176_TUNER_LO_INJECTION_PROP_BAND_3_MASK;
+                        p->tuner_lo_injection.band_4 = (data >> SI2176_TUNER_LO_INJECTION_PROP_BAND_4_LSB) & SI2176_TUNER_LO_INJECTION_PROP_BAND_4_MASK;
+                        p->tuner_lo_injection.band_5 = (data >> SI2176_TUNER_LO_INJECTION_PROP_BAND_5_LSB) & SI2176_TUNER_LO_INJECTION_PROP_BAND_5_MASK;
+                        break;
+#endif /*     SI2176_TUNER_LO_INJECTION_PROP */
+                default :
+                        break;
+        }
+        return res;
+}
+
+/************************************************************************************************************************
+NAME: si2176_SetupATVDefaults
+DESCRIPTION: Setup si2176 ATV startup configuration
+This is a list of all the ATV configuration properties.   Depending on your application, only a subset may be required.
+The properties are stored in the global property structure 'prop'.  The function ATVConfig(..) must be called
+after any properties are modified.
+Parameter:  none
+Returns:    0 if successful
+Programming Guide Reference:    Flowchart A.5 (ATV Setup flowchart)
+
+ ************************************************************************************************************************/
+static int si2176_setupatvdefaults(si2176_propobj_t *prop)
+{
+        prop->atv_cvbs_out.amp                                     = cvbs_amp;
+        prop->atv_cvbs_out.offset                                   = 25;
+        prop->atv_sif_out.amp                                         = 60;
+        prop->atv_sif_out.offset                                       = 135;
+        prop->atv_sound_agc.other_systems                  = 4;
+        prop->atv_sound_agc.system_l                           = 5;
+        prop->atv_sound_agc_limit.min_gain                   = -84;
+        prop->atv_sound_agc_limit.max_gain                  = 72;
+        prop->atv_afc_range.range_khz                          = 2000;
+        prop->atv_rf_top.atv_rf_top                     = SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO;
+        prop->atv_vsync_tracking.min_pulses_to_lock    = 2;
+        prop->atv_vsync_tracking.min_fields_to_unlock  = 16;
+	if(si2176_version == 32){
+			prop->atv_hsync_out.offset = SI2176_ATV_HSYNC_OUT_PROP_OFFSET_DEFAULT;
+        		prop->atv_hsync_out.width = SI2176_ATV_HSYNC_OUT_PROP_WIDTH_DEFAULT;
+			prop->atv_hsync_out.gpio_sel = SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_GPIO1;
+	}
+        prop->atv_vsnr_cap.atv_vsnr_cap                       = 0;
+        prop->atv_cvbs_out_fine.amp                              = 100;
+        prop->atv_cvbs_out_fine.offset                            = 4;
+#ifdef SI2176_B30
+        prop->atv_agc_speed.if_agc_speed                    = 178;//patch for skyworth
+#elif defined(SI2176_B2A)
+        prop->atv_agc_speed.if_agc_speed                = SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+#endif
+        prop->atv_min_lvl_lock.thrs                                 = 34;
+        prop->atv_af_out.volume                                     = 53;
+        prop->atv_af_out.soft_mute                                  = 0;
+        if (si2176_version == 32) { // for version 32_b11
+            prop->atv_af_out.soft_mute = 1;
+        }
+        prop->atv_rsq_rssi_threshold.hi                          = 0;
+        prop->atv_rsq_rssi_threshold.lo                          = -80;
+        prop->atv_rsq_snr_threshold.hi                          = 60;//40;
+        prop->atv_rsq_snr_threshold.lo                          = 10;//25;
+        prop->atv_video_equalizer.slope                        = 0;
+        prop->atv_int_sense.chlnegen                   = SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE;
+        prop->atv_int_sense.chlposen                   = SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE;
+        prop->atv_int_sense.dlnegen                     = SI2176_ATV_INT_SENSE_PROP_DLNEGEN_DISABLE;
+        prop->atv_int_sense.dlposen                     = SI2176_ATV_INT_SENSE_PROP_DLPOSEN_ENABLE;
+        prop->atv_int_sense.pclnegen                   = SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE;
+        prop->atv_int_sense.pclposen                   = SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE;
+        prop->atv_int_sense.snrhnegen                = SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_DISABLE;
+        prop->atv_int_sense.snrhposen                = SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_ENABLE;
+        prop->atv_int_sense.snrlnegen                 = SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_DISABLE;
+        prop->atv_int_sense.snrlposen                 = SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_ENABLE;
+        prop->atv_ien.chlien                                 = SI2176_ATV_IEN_PROP_CHLIEN_ENABLE;     /* enable only CHL to drive ATVINT */
+        prop->atv_ien.dlien                                   = SI2176_ATV_IEN_PROP_DLIEN_ENABLE;
+        prop->atv_ien.pclien                                 = SI2176_ATV_IEN_PROP_PCLIEN_ENABLE;
+        prop->atv_ien.snrhien                               = SI2176_ATV_IEN_PROP_SNRHIEN_ENABLE;
+        prop->atv_ien.snrlien                                = SI2176_ATV_IEN_PROP_SNRLIEN_ENABLE;
+        prop->atv_audio_mode.audio_sys            = SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO;
+        prop->atv_audio_mode.chan_bw              = SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT;
+        prop->atv_audio_mode.demod_mode       = SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_FM1;
+        prop->atv_video_mode.video_sys             = SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK;
+        prop->atv_video_mode.trans                     = SI2176_ATV_VIDEO_MODE_PROP_TRANS_CABLE;//SI2176_ATV_VIDEO_MODE_PROP_TRANS_TERRESTRIAL;
+        prop->atv_video_mode.color                     = SI2176_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC;
+
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2176_SetupCommonDefaults
+DESCRIPTION: Setup si2176 Common startup configuration
+This is a list of all the common configuration properties.   Depending on your application, only a subset may be required.
+The properties are stored in the global property structure 'prop'.  The function CommonConfig(..) must be called
+after any of these properties are modified.
+Parameter:  none
+Returns:    0 if successful
+Programming Guide Reference:    Flowchart A.6a (Common setup flowchart)
+ ************************************************************************************************************************/
+static int si2176_setupcommondefaults(si2176_propobj_t *prop)
+{
+        /**** Enable Interrupt Sources *******/
+        prop->master_ien.atvien = SI2176_MASTER_IEN_PROP_ATVIEN_ON;
+        prop->master_ien.ctsien = SI2176_MASTER_IEN_PROP_CTSIEN_ON;
+        prop->master_ien.dtvien = SI2176_MASTER_IEN_PROP_DTVIEN_OFF;//SI2176_MASTER_IEN_PROP_DTVIEN_OFF;
+        prop->master_ien.errien = SI2176_MASTER_IEN_PROP_ERRIEN_OFF;
+        prop->master_ien.tunien = SI2176_MASTER_IEN_PROP_TUNIEN_ON;
+        /* Crystal Trim adjustment */
+        prop->crystal_trim.xo_cap = 8;
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2176_SetupTunerDefaults
+DESCRIPTION: Setup si2176 Tuner startup configuration
+This is a list of all the Tuner configuration properties.   Depending on your application, only a subset may be required.
+The properties are stored in the global property structure 'prop'.  The function TunerConfig(..) must be called
+after any of these properties are modified.
+Parameter:  none
+Returns:    0 if successful
+Programming Guide Reference:    Flowchart A.6a (Tuner setup flowchart)
+ ************************************************************************************************************************/
+static int si2176_setuptunerdefaults(si2176_propobj_t *prop)
+{
+
+        /* Setting si2176_TUNER_IEN_PROP property */
+        prop->tuner_ien.tcien               = SI2176_TUNER_IEN_PROP_TCIEN_ENABLE; /* enable only TC to drive TUNINT */
+        prop->tuner_ien.rssilien           = SI2176_TUNER_IEN_PROP_RSSILIEN_ENABLE;
+        prop->tuner_ien.rssihien          = SI2176_TUNER_IEN_PROP_RSSIHIEN_DISABLE;
+
+        /* Setting si2176_TUNER_BLOCK_VCO_PROP property */
+        prop->tuner_blocked_vco.vco_code   = 0x8000;
+
+        /* Setting si2176_TUNER_INT_SENSE_PROP property */
+        prop->tuner_int_sense.rssihnegen  = SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE;
+        prop->tuner_int_sense.rssihposen  = SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE;
+        prop->tuner_int_sense.rssilnegen   = SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE;
+        prop->tuner_int_sense.rssilposen   = SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE;
+        prop->tuner_int_sense.tcnegen      = SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE;
+        prop->tuner_int_sense.tcposen      = SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE;
+
+
+        /* Setting si2176_TUNER_LO_INJECTION_PROP property */
+        prop->tuner_lo_injection.band_1     = SI2176_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE;
+        prop->tuner_lo_injection.band_2     = SI2176_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE;
+        prop->tuner_lo_injection.band_3     = SI2176_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE;
+        prop->tuner_lo_injection.band_4     = SI2176_TUNER_LO_INJECTION_PROP_BAND_4_LOW_SIDE;
+        prop->tuner_lo_injection.band_5     = SI2176_TUNER_LO_INJECTION_PROP_BAND_5_LOW_SIDE;
+
+        return 0;
+}
+
+/************************************************************************************************************************
+NAME: si2176_ATVConfig
+DESCRIPTION: Setup si2176 ATV properties configuration
+This function will download all the ATV configuration properties stored in the global structure 'prop.
+Depending on your application, only a subset may be required to be modified.
+The function si2176_SetupATVDefaults() should be called before the first call to this function. Afterwards
+to change a property change the appropriate element in the property structure 'prop' and call this routine.
+Use the comments above the SetProperty2 calls as a guide to the parameters which are changed.
+Parameter:  Pointer to si2176 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+Programming Guide Reference:    Flowchart A.5 (ATV setup flowchart)
+ ************************************************************************************************************************/
+int si2176_atvconfig(struct i2c_client *si2176, si2176_propobj_t *prop, si2176_cmdreplyobj_t *rsp)
+{
+
+        /* Set ATV_CVBS_OUT property */
+        //prop.atv_cvbs_out.amp,
+        //prop.atv_cvbs_out.offset
+        if (si2176_sendproperty(si2176, SI2176_ATV_CVBS_OUT_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_SIF_OUT property */
+        //prop.atv_sif_out.amp,
+        //prop.atv_sif_out.offset
+        if (si2176_sendproperty(si2176, SI2176_ATV_SIF_OUT_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+        if(si2176_sendproperty(si2176, Si2176_ATV_SOUND_AGC_SPEED_PROP, prop, rsp) !=0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+        /* Set the si2176_ATV_SOUND_AGC_LIMIT property */
+        //prop.atv_sif_out.min_gain,
+        //prop.atv_sif_out.max_gain
+        if (si2176_sendproperty(si2176, SI2176_ATV_SOUND_AGC_LIMIT_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+        /* Set the ATV_AFC_RANGE property */
+        //prop.atv_afc_range.range_khz
+        if (si2176_sendproperty(si2176, SI2176_ATV_AFC_RANGE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_RF_TOP property */
+        //prop.atv_rf_top.atv_rf_top
+        if (si2176_sendproperty(si2176, SI2176_ATV_RF_TOP_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_VSYNC_TRACKING property */
+        //prop.atv_vsync_tracking.min_pulses_to_lock,
+        //prop.atv_vsync_tracking.min_fields_to_unlock
+        if (si2176_sendproperty(si2176, SI2176_ATV_VSYNC_TRACKING_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_HSYNC_OUT property */
+        //prop.atv_hsync_out.offset,
+        //prop.atv_hsync_out.width,
+        //prop.atv_hsync_out.gpio_sel,
+		if(si2176_version == 32){
+        	if (si2176_sendproperty(si2176, SI2176_ATV_HSYNC_OUT_PROP, prop, rsp) != 0)
+        	{
+               	 return ERROR_SI2176_SENDING_COMMAND;
+        	}
+		}
+        /* Set the ATV_VSNR_CAP property */
+        //prop.atv_vsnr_cap.atv_vsnr_cap
+        if (si2176_sendproperty(si2176, SI2176_ATV_VSNR_CAP_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_CVBS_OUT_FINE property */
+        //prop.atv_cvbs_out_fine.amp,
+        //prop.atv_cvbs_out_fine.offset
+        if (si2176_sendproperty(si2176, SI2176_ATV_CVBS_OUT_FINE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_AGC_SPEED property */
+        //prop.atv_agc_speed.if_agc_speed
+        if (si2176_sendproperty(si2176, SI2176_ATV_AGC_SPEED_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_MIN_LVL_LOCK property */
+        //prop.atv_min_lvl_lock.thrs
+        //prop.atv_min_lvl_lock.tol
+        if (si2176_sendproperty(si2176, SI2176_ATV_MIN_LVL_LOCK_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_AF_OUT property */
+        //prop.atv_af_out.volume
+        if (si2176_sendproperty(si2176, SI2176_ATV_AF_OUT_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /*Set the ATV_RSSI_RSQ_THRESHOLD property */
+        //prop.atv_rsq_rssi_threshold.hi,
+        //prop.atv_rsq_rssi_threshold.lo
+        if (si2176_sendproperty(si2176, SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /*Set the ATV_SNR_RSQ_THRESHOLD property */
+        //prop.atv_rsq_snr_threshold.hi,
+        //prop.atv_rsq_snr_threshold.lo
+        if (si2176_sendproperty(si2176, SI2176_ATV_RSQ_SNR_THRESHOLD_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /*Set the ATV_VIDEO_EQUALIZER property */
+        //prop.atv_video_equalizer.slope
+        if (si2176_sendproperty(si2176, SI2176_ATV_VIDEO_EQUALIZER_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /*Set the ATV_INT_SENSE property */
+        //prop.atv_int_sense.chlnegen,
+        //prop.atv_int_sense.chlposen,
+        //prop.atv_int_sense.dlnegen,
+        //prop.atv_int_sense.dlposen,
+        //prop.atv_int_sense.pclnegen,
+        //prop.atv_int_sense.pclposen,
+        //prop.atv_int_sense.snrhnegen,
+        //prop.atv_int_sense.snrhposen,
+        //prop.atv_int_sense.snrlnegen,
+        //prop.atv_int_sense.snrlposen
+        if (si2176_sendproperty(si2176, SI2176_ATV_INT_SENSE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+        /* setup ATV_IEN_PROP  IEN properties to enable ATVINT on CHL  */
+
+        /* prop.atv_ien.chlien,
+           prop.atv_ien.pclien,
+           prop.atv_ien.dlien ,
+           prop.atv_ien.snrlien,
+           prop.atv_ien.snrhien */
+        if (si2176_sendproperty(si2176, SI2176_ATV_IEN_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_AUDIO_MODE property */
+        /*rop.atv_audio_mode.audio_sys,
+          prop.atv_audio_mode.chan_bw,
+          prop.atv_audio_mode.demod_mode  */
+        if (si2176_sendproperty(si2176, SI2176_ATV_AUDIO_MODE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set the ATV_VIDEO_MODE property */
+        /*prop.atv_video_mode.video_sys,
+          prop.atv_video_mode.trans,
+          prop.atv_video_mode.color  */
+        if (si2176_sendproperty(si2176, SI2176_ATV_VIDEO_MODE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        return 0;
+}
+
+/************************************************************************************************************************
+NAME: si2176_CommonConfig
+DESCRIPTION: Setup si2176 Common properties configuration
+This function will download all the DTV configuration properties stored in the global structure 'prop.
+Depending on your application, only a subset may be required to be modified.
+The function si2176_SetupCommonDefaults() should be called before the first call to this function. Afterwards
+to change a property change the appropriate element in the property structure 'prop' and call this routine.
+Use the comments above the si2176_sendproperty calls as a guide to the parameters which are changed.
+Parameter:  Pointer to si2176 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+Programming Guide Reference:    Flowchart A.6a (Common setup flowchart)
+ ************************************************************************************************************************/
+int si2176_commonconfig(struct i2c_client *si2176, si2176_propobj_t *prop, si2176_cmdreplyobj_t *rsp)
+{
+
+        /* Setting si2176_MASTER_IEN_PROP property */
+        /***
+          prop.master_ien.atvien,
+          prop.master_ien.ctsien,
+          prop.master_ien.dtvien,
+          prop.master_ien.errien,
+          prop.master_ien.tunien  */
+
+        if (si2176_sendproperty(si2176, SI2176_MASTER_IEN_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting si2176_CRYSTAL_TRIM_PROP */
+        //rop.crystal_trim.xo_cap
+        if (si2176_sendproperty(si2176, SI2176_CRYSTAL_TRIM_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2176_TunerConfig
+DESCRIPTION: Setup si2176 Tuner (RF to IF analog path) properties configuration
+This function will download all the DTV configuration properties stored in the global structure 'prop.
+Depending on your application, only a subset may be required to be modified.
+The function si2176_SetupTunerDefaults() should be called before the first call to this function. Afterwards
+to change a property change the appropriate element in the property structure 'prop' and call this routine.
+Use the comments above the si2176_sendproperty calls as a guide to the parameters which are changed.
+Parameter:  Pointer to si2176 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+Programming Guide Reference:    Flowchart A.6a (Tuner setup flowchart)
+ ************************************************************************************************************************/
+int si2176_tunerconfig(struct i2c_client *si2176, si2176_propobj_t *prop, si2176_cmdreplyobj_t *rsp)
+{
+        /* Set TUNER_IEN property */
+        /*rop.tuner_ien.tcien,
+          prop.tuner_ien.rssilien,
+          prop.tuner_ien.rssihien */
+        if (si2176_sendproperty(si2176, SI2176_TUNER_IEN_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting TUNER_BLOCKED_VCO property */
+        /*rop.tuner_blocked_vco.vco_code, */
+        if (si2176_sendproperty(si2176, SI2176_TUNER_BLOCKED_VCO_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+        /* Setting si2176_TUNER_INT_SENSE_PROP property */
+        /*    rop.tuner_int_sense.rssihnegen,
+              prop.tuner_int_sense.rssihposen,
+              prop.tuner_int_sense.rssilnegen,
+              prop.tuner_int_sense.rssilposen,
+              prop.tuner_int_sense.tcnegen,
+              prop.tuner_int_sense.tcposen */
+
+        if (si2176_sendproperty(si2176, SI2176_TUNER_INT_SENSE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting si2176_TUNER_LO_INJECTION_PROP property */
+        /*rop.tuner_lo_injection.band_1,
+          prop.tuner_lo_injection.band_2,
+          prop.tuner_lo_injection.band_3,
+          prop.tuner_lo_injection.band_4,
+          prop.tuner_lo_injection.band_5 */
+        if (si2176_sendproperty(si2176, SI2176_TUNER_LO_INJECTION_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+
+        return 0;
+}
+/************************************************************************************************************************
+NAME: Si2170_SetupDTVDefaults
+DESCRIPTION: Setup Si2170 DTV startup configuration
+This is a list of all the DTV configuration properties.   Depending on your application, only a subset may be required.
+The properties are stored in the global property structure 'prop'.  The function DTVConfig(..) must be called
+after any properties are modified.
+Parameter:  none
+Returns:    0 if successful
+Programming Guide Reference:    Flowchart A.6 (DTV setup flowchart)
+
+ ************************************************************************************************************************/
+static int si2176_setupdtvdefaults(si2176_propobj_t *prop, int ch_mode)
+{
+        prop->dtv_config_if_port.dtv_out_type   = SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1;
+        prop->dtv_config_if_port.dtv_agc_source = SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL;
+        prop->dtv_lif_freq.offset = 5000;
+        prop->dtv_mode.bw = SI2176_DTV_MODE_PROP_BW_BW_8MHZ;
+        prop->dtv_mode.invert_spectrum = SI2176_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL;
+        //set in the get tuner ops
+        prop->dtv_mode.modulation = SI2176_DTV_MODE_PROP_MODULATION_DVBC;//SI2176_DTV_MODE_PROP_MODULATION_DVBC;
+        prop->dtv_rsq_rssi_threshold.hi=0;
+        prop->dtv_rsq_rssi_threshold.lo=-80;
+        prop->dtv_ext_agc.max_10mv=250;
+        prop->dtv_ext_agc.min_10mv=50;
+        if(ch_mode == 4)
+                prop->dtv_lif_out.amp=25;//22;//27;//23;
+        else
+                prop->dtv_lif_out.amp=25;//27;
+
+        prop->dtv_lif_out.offset=148;
+        prop->dtv_agc_speed.agc_decim=SI2176_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;
+        prop->dtv_agc_speed.if_agc_speed=SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+        prop->dtv_rf_top.dtv_rf_top=SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO;
+        prop->dtv_int_sense.chlnegen=SI2176_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE;
+        prop->dtv_int_sense.chlposen=SI2176_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE;
+        prop->dtv_ien.chlien  = SI2176_DTV_IEN_PROP_CHLIEN_ENABLE;      /* enable only CHL to drive DTVINT */
+        return 0;
+}
+/************************************************************************************************************************
+NAME: Si2170_DTVConfig
+DESCRIPTION: Setup Si2170 DTV properties configuration
+This function will download all the DTV configuration properties stored in the global structure 'prop.
+Depending on your application, only a subset may be required to be modified.
+The function Si2170_SetupDTVDefaults() should be called before the first call to this function. Afterwards
+to change a property change the appropriate element in the property structure 'prop' and call this routine.
+Use the comments above the Si2170_L1_SetProperty2 calls as a guide to the parameters which are changed.
+Parameter:  Pointer to Si2170 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+Programming Guide Reference:    Flowchart A.6 (DTV setup flowchart)
+ ************************************************************************************************************************/
+int si2176_dtvconfig(struct i2c_client *si2176, si2176_propobj_t *prop, si2176_cmdreplyobj_t *rsp)
+{
+
+        /* Setting DTV_CONFIG_IF_PORT_PROP property */
+        /*	prop.dtv_config_if_port.dtv_out_type,
+                prop.dtv_config_if_port.dtv_agc_source */
+        if (si2176_sendproperty(si2176, SI2176_DTV_CONFIG_IF_PORT_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_LIF_FREQ_PROP */
+        //	prop.dtv_lif_freq.offset
+        if (si2176_sendproperty(si2176, SI2176_DTV_LIF_FREQ_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_MODE_PROP property */
+        /*	prop.dtv_mode.bw,
+                prop.dtv_mode.invert_spectrum,
+                prop.dtv_mode.modulation*/
+        if (si2176_sendproperty(si2176, SI2176_DTV_MODE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_RSQ_RSSI_THRESHOLD property */
+        //	prop.dtv_rsq_rssi_threshold.hi,
+        //	prop.dtv_rsq_rssi_threshold.lo
+        if (si2176_sendproperty(si2176, SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_EXT_AGC property */
+        //	prop.dtv_ext_agc.max_10mv,
+        //	prop.dtv_ext_agc.min_10mv
+        if (si2176_sendproperty(si2176, SI2176_DTV_EXT_AGC_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_LIF_OUT property */
+        //	prop.dtv_lif_out.amp,
+        //	prop.dtv_lif_out.offset
+        if (si2176_sendproperty(si2176, SI2176_DTV_LIF_OUT_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_AGC_SPEED property */
+        //	prop.dtv_agc_speed.agc_decim,
+        //	prop.dtv_agc_speed.if_agc_speed
+        if (si2176_sendproperty(si2176, SI2176_DTV_AGC_SPEED_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_RF_TOP property */
+        //	prop.dtv_rf_top.dtv_rf_top
+        if (si2176_sendproperty(si2176, SI2176_DTV_RF_TOP_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_INT_SENSE property */
+        //	prop.dtv_int_sense.chlnegen,
+        //	prop.dtv_int_sense.chlposen
+        if (si2176_sendproperty(si2176, SI2176_DTV_INT_SENSE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        /* Set DTV_IEN property */
+        /*	prop.dtv_ien.chlien */
+        if (si2176_sendproperty(si2176, SI2176_DTV_IEN_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+
+        return 0;
+}
+
+
+/************************************************************************************************************************
+NAME: si2176_Tune
+DESCRIPTIION: Tune si2176 in specified mode (ATV/DTV) at center frequency, wait for TUNINT and xTVINT with timeout
+
+Parameter:  Pointer to si2176 Context (I2C address)
+Parameter:  Mode (ATV or DTV) use si2176_TUNER_TUNE_FREQ_CMD_MODE_ATV or si2176_TUNER_TUNE_FREQ_CMD_MODE_DTV constants
+Parameter:  frequency (Hz) as a unsigned long integer
+Parameter:  rsp - commandResp structure to returns tune status info.
+Returns:    0 if channel found.  A nonzero value means either an error occurred or channel not locked.
+Programming Guide Reference:    Flowchart A.7 (Tune flowchart)
+ ************************************************************************************************************************/
+int si2176_tune(struct i2c_client *si2176, unsigned char mode, unsigned long freq, si2176_cmdreplyobj_t *rsp, si2176_common_reply_struct *common_reply)
+{
+        int return_code = 0,count = 0;
+
+        if (si2176_tuner_tune_freq(si2176, mode, freq, rsp) != 0)
+        {
+               // pr_info("%s: tuner tune freq error:%d!!!!\n", __func__, ERROR_SI2176_SENDING_COMMAND);
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+        mdelay(5);
+        for (count=50; count ;count--)
+        {
+                return_code = si2176_pollforcts(si2176);
+                if (!return_code)
+                        break;
+                mdelay(2);
+        }
+        if (!count)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, return_code);
+                return return_code;
+        }
+        mdelay(delay_det);
+#if 0
+        /* wait for TUNINT, timeout is 150ms */
+        for (count=75; count ;count--)
+        {
+                if ((return_code = si2176_check_status(si2176, common_reply)) != 0)
+                        return return_code;
+                if (common_reply->tunint)
+                        break;
+                mdelay(2);
+        }
+        if (!count)
+        {
+                pr_info("%s: ERROR_SI2176_TUNINT_TIMEOUT error:%d!!!!\n", __func__, ERROR_SI2176_TUNINT_TIMEOUT);
+                return ERROR_SI2176_TUNINT_TIMEOUT;
+        }
+        /* wait for xTVINT, timeout is 350ms for ATVINT and 6 ms for DTVINT */
+        count = ((mode==SI2176_TUNER_TUNE_FREQ_CMD_MODE_ATV) ? 300 : 3);
+        for (;count ;count--)
+        {
+                if ((return_code = si2176_check_status(si2176, common_reply)) != 0)
+                        return return_code;
+                if ((mode==SI2176_TUNER_TUNE_FREQ_CMD_MODE_ATV) ? common_reply->atvint : common_reply->dtvint)
+                        break;
+                mdelay(2);
+        }
+        if (!count)
+        {
+                pr_info("%s: ERROR_SI2176_XTVINT_TIMEOUT error:%d!!!!\n", __func__, ERROR_SI2176_XTVINT_TIMEOUT);
+                return ERROR_SI2176_XTVINT_TIMEOUT;
+        }
+#endif
+        return return_code;
+}
+
+/************************************************************************************************************************
+NAME: si2176_LoadVideofilter
+DESCRIPTION:        Load video filters from vidfiltTable in si2176_write_xTV_video_coeffs.h file into si2176
+Programming Guide Reference:    Flowchart A.4 (Download Video Filters flowchart)
+
+Parameter:  si2176 Context (I2C address)
+Parameter:  pointer to video filter table array
+Parameter:  number of lines in video filter table array (size in bytes / BYTES_PER_LINE)
+Returns:    si2176/I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2176_loadvideofilter(struct i2c_client *si2176, unsigned char* vidfilttable, int lines, si2176_common_reply_struct *common_reply)
+{
+#define BYTES_PER_LINE 8
+        int line;
+
+        /* for each 8 bytes in VIDFILT_TABLE */
+        for (line = 0; line < lines; line++)
+        {
+                /* send that 8 byte I2C command to si2176 */
+                if (si2176_api_patch(si2176, BYTES_PER_LINE, vidfilttable+BYTES_PER_LINE*line, common_reply) != 0)
+                {
+                        return ERROR_SI2176_SENDING_COMMAND;
+                }
+        }
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2176_Configure
+DESCRIPTION: Setup si2176 video filters, GPIOs/clocks, Common Properties startup, Tuner startup, ATV startup, and DTV startup.
+Parameter:  Pointer to si2176 Context (I2C address)
+Parameter:  rsp - commandResp structure buffer.
+Returns:    I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2176_configure(struct i2c_client *si2176, si2176_propobj_t *prop, si2176_cmdreplyobj_t *rsp, si2176_common_reply_struct *common_reply)
+{
+        int return_code = 0;
+
+        /* load ATV video filter file */
+#ifdef USING_ATV_FILTER
+        if ((return_code = si2176_loadvideofilter(si2176, dlif_vidfilt_table, DLIF_VIDFILT_LINES, common_reply) != 0)
+                        return return_code;
+#endif
+
+		if(descramble){
+                        /* Set the GPIO Pins using the CONFIG_PINS command*/
+                        if (si2176_config_pins(si2176,      /* turn off BCLK1 and XOUT */
+                                        SI2176_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1,
+                                        SI2176_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ,
+                                        SI2176_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_1,
+                                        SI2176_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ,
+                                        SI2176_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE,
+                                        SI2176_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ,
+                                        SI2176_CONFIG_PINS_CMD_BCLK1_MODE_DISABLE,
+                                        SI2176_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ,
+                                        SI2176_CONFIG_PINS_CMD_XOUT_MODE_DISABLE,
+                                        rsp) !=0)
+                        {
+							pr_info("%s: config pins error:%d!!!!\n", __func__, ERROR_SI2176_SENDING_COMMAND);
+                        	return ERROR_SI2176_SENDING_COMMAND;
+                        }
+		}else{
+                        if (si2176_config_pins(si2176,      /* turn off BCLK1 and XOUT */
+                                        SI2176_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE,
+                                        SI2176_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ,
+                                        SI2176_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE,
+                                        SI2176_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ,
+                                        SI2176_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE,
+                                        SI2176_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ,
+                                        SI2176_CONFIG_PINS_CMD_BCLK1_MODE_DISABLE,
+                                        SI2176_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ,
+                                        SI2176_CONFIG_PINS_CMD_XOUT_MODE_DISABLE,
+                                        rsp) !=0)
+                        {
+                        pr_info("%s: config pins error:%d!!!!\n", __func__, ERROR_SI2176_SENDING_COMMAND);
+                        return ERROR_SI2176_SENDING_COMMAND;
+                        }
+		}
+#if  1
+                        /* Set Common Properties startup configuration */
+                        si2176_setupcommondefaults(prop);
+                        if ((return_code = si2176_commonconfig(si2176, prop, rsp)) != 0)
+                        {
+                                pr_info("%s: setup command defaults error:%d!!!!\n", __func__, return_code);
+                                return return_code;
+                        }
+
+                        /* Set Tuner Properties startup configuration */
+                        si2176_setuptunerdefaults(prop);
+                        if ((return_code = si2176_tunerconfig(si2176, prop, rsp)) != 0)
+                        {
+                                pr_info("%s: setup tuner defaults error:%d!!!!\n", __func__, return_code);
+                                return return_code;
+                        }
+                        /* Set ATV startup configuration */
+                        si2176_setupatvdefaults(prop);
+                        if ((return_code = si2176_atvconfig(si2176, prop, rsp)) != 0)
+                        {
+                                pr_info("%s: setup atv defaults error:%d!!!!\n", __func__, return_code);
+                                return return_code;
+                        }
+                        /* Set DTV startup configuration */
+                        si2176_setupdtvdefaults(prop, 4);
+                        if ((return_code = si2176_dtvconfig(si2176, prop, rsp)) != 0)
+                        {
+                                pr_info("%s: setup dtv defaults error:%d!!!!\n", __func__, return_code);
+                                return return_code;
+                        }
+#endif
+                        return return_code;
+}
+/************************************************************************************************************************
+NAME: si2176_LoadFirmware
+DESCRIPTON: Load firmware from FIRMWARE_TABLE array in si2176_Firmware_x_y_build_z.h file into si2176
+Requires si2176 to be in bootloader mode after PowerUp
+Programming Guide Reference:    Flowchart A.3 (Download FW PATCH flowchart)
+
+Parameter:  si2176 Context (I2C address)
+Parameter:  pointer to firmware table array
+Parameter:  number of lines in firmware table array (size in bytes / BYTES_PER_LINE)
+Returns:    si2176/I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2176_loadfirmware(struct i2c_client *si2176, unsigned char* firmwaretable, int lines, si2176_common_reply_struct *common_reply)
+{
+        int return_code = 0;
+        int line;
+
+        /* for each 8 bytes in FIRMWARE_TABLE */
+        for (line = 0; line < lines; line++)
+        {
+                /* send that 8 byte I2C command to si2176 */
+                if (si2176_api_patch(si2176, 8, firmwaretable+8*line, common_reply) != 0)
+                {
+                        return ERROR_SI2176_LOADING_FIRMWARE;
+                }
+        }
+        return return_code;
+}
+
+int si2177_loadfirmware(struct i2c_client *si2176, struct firmware_struct * firmwaretable, int lines, si2176_common_reply_struct *common_reply)
+{
+        int return_code = 0;
+        int line;
+
+
+        for (line = 0; line < lines; line++)
+        {
+
+                if (si2176_api_patch(si2176, firmwaretable[line].firmware_len, firmwaretable[line].firmware_table, common_reply) != 0){
+                        return ERROR_SI2176_LOADING_FIRMWARE;
+                }
+
+        }
+        return return_code;
+}
+
+
+/************************************************************************************************************************
+NAME: si2176_StartFirmware
+DESCRIPTION: Start si2176 firmware (put the si2176 into run mode)
+Parameter:   si2176 Context (I2C address)
+Parameter (passed by Reference): 	ExitBootloadeer Response Status byte : tunint, atvint, dtvint, err, cts
+Returns:     I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2176_startfirmware(struct i2c_client *si2176, si2176_cmdreplyobj_t *rsp)
+{
+
+        if (si2176_exit_bootloader(si2176, SI2176_EXIT_BOOTLOADER_CMD_FUNC_TUNER, SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_OFF, rsp) != 0)
+        {
+                return ERROR_SI2176_STARTING_FIRMWARE;
+        }
+
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2176_PowerUpWithPatch
+DESCRIPTION: Send si2176 API PowerUp Command with PowerUp to bootloader,
+Check the Chip rev and part, and ROMID are compared to expected values.
+Load the Firmware Patch then Start the Firmware.
+Programming Guide Reference:    Flowchart A.2a (POWER_UP with patch flowchart)
+
+Parameter:  si2176 Context (I2C address)
+Returns:    si2176/I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2176_powerupwithpatch(struct i2c_client *si2176, si2176_cmdreplyobj_t *rsp, si2176_common_reply_struct *common_reply)
+{
+        int return_code = 0, num = 0;
+
+        return_code = si2176_power_up(si2176,          /* always wait for CTS prior to POWER_UP command */
+                        SI2176_POWER_UP_CMD_SUBCODE_CODE,
+                        SI2176_POWER_UP_CMD_RESERVED1_RESERVED,
+                        SI2176_POWER_UP_CMD_RESERVED2_RESERVED,
+                        SI2176_POWER_UP_CMD_RESERVED3_RESERVED,
+                        SI2176_POWER_UP_CMD_CLOCK_MODE_XTAL,
+                        SI2176_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ,
+                        SI2176_POWER_UP_CMD_ADDR_MODE_CURRENT,
+                        SI2176_POWER_UP_CMD_FUNC_BOOTLOADER,        /* start in bootloader mode */
+                        SI2176_POWER_UP_CMD_CTSIEN_DISABLE,
+                        SI2176_POWER_UP_CMD_WAKE_UP_WAKE_UP,
+                        rsp);
+        if (return_code)
+                pr_info("%s: si2176_power_up error:%d!!!\n", __func__, return_code);
+
+#if 0
+        /* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+        if (si2176_part_info(si2176, &rsp) != 0)
+                return ERROR_SI2176_SENDING_COMMAND;
+        /* Check the Chip revision, part and ROMID against expected values and report an error if incompatible */
+        if (rsp.part_info.chiprev != chiprev)
+                return ERROR_SI2176_INCOMPATIBLE_PART;
+        /* Part Number is represented as the last 2 digits */
+        if (rsp.part_info.part != part)
+                return ERROR_SI2176_INCOMPATIBLE_PART;
+        /* Part Major Version in ASCII */
+        if (rsp.part_info.pmajor != partmajorversion)
+                return ERROR_SI2176_INCOMPATIBLE_PART;
+
+#endif
+        mdelay(25);
+        /* Load the Firmware */
+        if (si2176_version == 30)  // for version B30
+        {
+                num = sizeof(firmwaretable_b30)/(8*sizeof(unsigned char));
+                return_code = si2176_loadfirmware(si2176, firmwaretable_b30, num, common_reply);
+        }
+        else if (si2176_version == 29)  // for version B29,just is 3.2B7
+        {
+                num = sizeof(firmwaretable_b29)/(8*sizeof(unsigned char));
+                return_code = si2176_loadfirmware(si2176, firmwaretable_b29, num, common_reply);
+        }
+        else if (si2176_version == 42)  // for version B2A
+        {
+                printk("si2176 load firmware b2a.\n");
+                num = sizeof(firmwaretable_b2a)/(8*sizeof(unsigned char));
+                return_code = si2176_loadfirmware(si2176, firmwaretable_b2a, num, common_reply);
+        }
+		else if (si2176_version == 32)  // for version 32_b11
+		{
+			    printk("si2176 load firmware firmwaretable_32_b11.\n");
+                num = sizeof(firmwaretable_32_b11)/(8*sizeof(unsigned char));
+                return_code = si2176_loadfirmware(si2176, firmwaretable_32_b11, num, common_reply);
+		}
+		else if (si2176_version == 33) //for version 2177_30_b_5
+		{
+				printk("si2177 load firmware firmwaretable_2177_30_b_5.\n");
+				num = (sizeof(Si2177_FW_3_0b5)/(sizeof(firmware_struct)));
+				return_code = si2177_loadfirmware(si2176,Si2177_FW_3_0b5,num,common_reply);
+		}
+        else
+        {
+                num = sizeof(firmwaretable_b30)/(8*sizeof(unsigned char));
+                return_code = si2176_loadfirmware(si2176, firmwaretable_b30, num, common_reply);
+        }
+
+        if (return_code != 0)
+        {
+                pr_info("%s: si2176_loadfirmware error:%d!!!\n", __func__, return_code);
+                return return_code;
+        }
+
+        /*Start the Firmware */
+        if ((return_code = si2176_startfirmware(si2176, rsp)) != 0) /* Start firmware */
+        {
+                pr_info("%s: si2176_startfirmware error:%d!!!\n", __func__, return_code);
+                return return_code;
+        }
+        mdelay(50);
+        if (si2176_get_rev(si2176, rsp) != 0)
+        {
+                pr_info("%s: si2176_get_rev error:%d!!!\n", __func__, ERROR_SI2176_SENDING_COMMAND);
+                return ERROR_SI2176_SENDING_COMMAND;
+        }
+        else
+        {
+                pr_info("%s: rsp.get_rev.pn :      %d \n", __func__, rsp->get_rev.pn);
+                pr_info("%s: rsp.get_rev.fwmajor : %d \n", __func__, rsp->get_rev.fwmajor);
+                pr_info("%s: rsp.get_rev.fwminor : %d \n", __func__, rsp->get_rev.fwminor);
+                pr_info("%s: rsp.get_rev.patch :   %d \n", __func__, rsp->get_rev.patch);
+                pr_info("%s: rsp.get_rev.cmpmajor :%d \n", __func__, rsp->get_rev.cmpmajor);
+                pr_info("%s: rsp.get_rev.cmpminor :%d \n", __func__, rsp->get_rev.cmpminor);
+                pr_info("%s: rsp.get_rev.cmpbuild :%d \n", __func__, rsp->get_rev.cmpbuild);
+                pr_info("%s: rsp.get_rev.chiprev : %d \n", __func__, (u32)rsp->get_rev.chiprev);
+        }
+
+        return return_code;
+}
+
+
+/************************************************************************************************************************
+NAME: si2176_Init
+DESCRIPTION:Reset and Initialize si2176
+Parameter:  si2176 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2176_init(struct i2c_client *si2176, si2176_cmdreplyobj_t *rsp, si2176_common_reply_struct *common_reply)
+{
+        int return_code = 0;
+
+        /* Reset si2176 */
+        /* TODO: SendRSTb requires porting to toggle the RSTb line low -> high */
+        //sendrstb();
+
+        return_code = si2176_powerupwithpatch(si2176, rsp, common_reply);
+        if (return_code)		/* PowerUp into bootloader */
+        {
+                pr_info("%s: init si2176 error!!!\n", __func__);
+        }
+
+        /* At this point, FW is loaded and started.  Return 0*/
+        return return_code;
+}
+
+
+
+
diff --git a/drivers/amlogic/dvb_tv/si2176/si2176_func.h b/drivers/amlogic/dvb_tv/si2176/si2176_func.h
new file mode 100755
index 000000000000..665949fdf7bb
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2176/si2176_func.h
@@ -0,0 +1,2633 @@
+/*
+ * Sli2176 Device Driver
+ *
+ * Author: Bobby Yang <bo.yang@amlogic.com>
+ *
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __SLI2176_FUN_H
+#define __SLI2176_FUN_H
+
+#include <linux/tvin/tvin.h>
+#include "../aml_fe.h"
+#define NO_SI2176_ERROR                                                 0x00
+#define ERROR_SI2176_PARAMETER_OUT_OF_RANGE  0x01
+#define ERROR_SI2176_ALLOCATING_CONTEXT             0x02
+#define ERROR_SI2176_SENDING_COMMAND                  0x03
+#define ERROR_SI2176_CTS_TIMEOUT                             0x04
+#define ERROR_SI2176_ERR                                               0x05
+#define ERROR_SI2176_POLLING_CTS                              0x06
+#define ERROR_SI2176_POLLING_RESPONSE                 0x07
+#define ERROR_SI2176_LOADING_FIRMWARE                 0x08
+#define ERROR_SI2176_LOADING_BOOTBLOCK               0x09
+#define ERROR_SI2176_STARTING_FIRMWARE               0x0a
+#define ERROR_SI2176_SW_RESET                                   0x0b
+#define ERROR_SI2176_INCOMPATIBLE_PART                0x0c
+#define ERROR_SI2176_TUNINT_TIMEOUT                       0x0d
+#define ERROR_SI2176_XTVINT_TIMEOUT                       0x0e
+
+/* status structure definition */
+typedef struct { /* si2176_common_reply_struct */
+    unsigned char   tunint;
+    unsigned char   atvint;
+    unsigned char   dtvint;
+    unsigned char   err;
+    unsigned char   cts;
+} si2176_common_reply_struct;
+
+/* _status_defines_insertion_start */
+#define SI2176_COMMAND_PROTOTYPES
+
+
+/* STATUS fields definition */
+/* STATUS, TUNINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2176_STATUS_TUNINT_LSB                            0
+#define  SI2176_STATUS_TUNINT_MASK                         0x01
+#define SI2176_STATUS_TUNINT_NOT_TRIGGERED     0
+#define SI2176_STATUS_TUNINT_TRIGGERED              1
+/* STATUS, ATVINT field definition (size 1, lsb 1, unsigned)*/
+#define  SI2176_STATUS_ATVINT_LSB                            1
+#define  SI2176_STATUS_ATVINT_MASK                         0x01
+#define SI2176_STATUS_ATVINT_NOT_TRIGGERED     0
+#define SI2176_STATUS_ATVINT_TRIGGERED              1
+/* STATUS, DTVINT field definition (size 1, lsb 2, unsigned)*/
+#define  SI2176_STATUS_DTVINT_LSB                            2
+#define  SI2176_STATUS_DTVINT_MASK                         0x01
+#define SI2176_STATUS_DTVINT_NOT_TRIGGERED     0
+#define SI2176_STATUS_DTVINT_TRIGGERED              1
+/* STATUS, ERR field definition (size 1, lsb 6, unsigned)*/
+#define  SI2176_STATUS_ERR_LSB                                  6
+#define  SI2176_STATUS_ERR_MASK                               0x01
+#define SI2176_STATUS_ERR_ERROR                            1
+#define SI2176_STATUS_ERR_NO_ERROR                     0
+/* STATUS, CTS field definition (size 1, lsb 7, unsigned)*/
+#define  SI2176_STATUS_CTS_LSB                                   7
+#define  SI2176_STATUS_CTS_MASK                               0x01
+#define SI2176_STATUS_CTS_COMPLETED                   1
+#define SI2176_STATUS_CTS_WAIT                                0
+
+/* _status_defines_insertion_point */
+
+/* _commands_defines_insertion_start */
+/* SI2176_AGC_OVERRIDE command definition */
+#define SI2176_AGC_OVERRIDE_CMD                               0x44
+
+#ifdef    SI2176_AGC_OVERRIDE_CMD
+
+typedef struct { /* SI2176_AGC_OVERRIDE_CMD_struct */
+     unsigned char   force_max_gain;
+     unsigned char   force_top_gain;
+} si2176_agc_override_cmd_struct;
+
+/* AGC_OVERRIDE command, FORCE_MAX_GAIN field definition (size 1, lsb 0, unsigned) */
+#define  SI2176_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_LSB          0
+#define  SI2176_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MASK       0x01
+#define  SI2176_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MIN           0
+#define  SI2176_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MAX          1
+#define SI2176_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_DISABLE  0
+#define SI2176_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_ENABLE   1
+/* AGC_OVERRIDE command, FORCE_TOP_GAIN field definition (size 1, lsb 1, unsigned) */
+#define  SI2176_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_LSB           1
+#define  SI2176_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MASK        0x01
+#define  SI2176_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MIN           0
+#define  SI2176_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MAX          1
+#define SI2176_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_DISABLE  0
+#define SI2176_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_ENABLE   1
+
+typedef struct { /* SI2176_AGC_OVERRIDE_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_agc_override_cmd_reply_struct;
+
+#endif /* SI2176_AGC_OVERRIDE_CMD */
+
+/* SI2176_ATV_CW_TEST command definition */
+//#define SI2176_ATV_CW_TEST_CMD 0x53
+
+#ifdef    SI2176_ATV_CW_TEST_CMD
+
+typedef struct { /* SI2176_ATV_CW_TEST_CMD_struct */
+     unsigned char   pc_lock;
+} si2176_atv_cw_test_cmd_struct;
+
+/* ATV_CW_TEST command, PC_LOCK field definition (size 1, lsb 0, unsigned) */
+#define  SI2176_ATV_CW_TEST_CMD_PC_LOCK_LSB          0
+#define  SI2176_ATV_CW_TEST_CMD_PC_LOCK_MASK       0x01
+#define  SI2176_ATV_CW_TEST_CMD_PC_LOCK_MIN          0
+#define  SI2176_ATV_CW_TEST_CMD_PC_LOCK_MAX         1
+#define SI2176_ATV_CW_TEST_CMD_PC_LOCK_LOCK       1
+#define SI2176_ATV_CW_TEST_CMD_PC_LOCK_UNLOCK  0
+
+typedef struct { /* SI2176_ATV_CW_TEST_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_atv_cw_test_cmd_reply_struct;
+
+#endif /* SI2176_ATV_CW_TEST_CMD */
+
+/* SI2176_ATV_RESTART command definition */
+#define SI2176_ATV_RESTART_CMD                                         0x51
+
+#ifdef    SI2176_ATV_RESTART_CMD
+
+typedef struct { /* SI2176_ATV_RESTART_CMD_struct */
+     unsigned char   mode;
+} si2176_atv_restart_cmd_struct;
+
+/* ATV_RESTART command, MODE field definition (size 1, lsb 0, unsigned) */
+#define  SI2176_ATV_RESTART_CMD_MODE_LSB                     0
+#define  SI2176_ATV_RESTART_CMD_MODE_MASK                  0x01
+#define  SI2176_ATV_RESTART_CMD_MODE_MIN                      0
+#define  SI2176_ATV_RESTART_CMD_MODE_MAX                     1
+#define SI2176_ATV_RESTART_CMD_MODE_AUDIO_ONLY      1
+#define SI2176_ATV_RESTART_CMD_MODE_AUDIO_VIDEO    0
+
+typedef struct { /* SI2176_ATV_RESTART_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_atv_restart_cmd_reply_struct;
+
+#endif /* SI2176_ATV_RESTART_CMD */
+
+/* SI2176_ATV_STATUS command definition */
+#define SI2176_ATV_STATUS_CMD                                                  0x52
+
+#ifdef    SI2176_ATV_STATUS_CMD
+
+typedef struct { /* SI2176_ATV_STATUS_CMD_struct */
+     unsigned char   intack;
+} si2176_atv_status_cmd_struct;
+
+/* ATV_STATUS command, INTACK field definition (size 1, lsb 0, unsigned) */
+#define  SI2176_ATV_STATUS_CMD_INTACK_LSB                    0
+#define  SI2176_ATV_STATUS_CMD_INTACK_MASK                 0x01
+#define  SI2176_ATV_STATUS_CMD_INTACK_MIN                    0
+#define  SI2176_ATV_STATUS_CMD_INTACK_MAX                   1
+#define SI2176_ATV_STATUS_CMD_INTACK_CLEAR               1
+#define SI2176_ATV_STATUS_CMD_INTACK_OK                      0
+
+typedef struct { /* SI2176_ATV_STATUS_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+      unsigned char   chlint;
+      unsigned char   pclint;
+      unsigned char   dlint;
+      unsigned char   snrlint;
+      unsigned char   snrhint;
+      unsigned char   audio_chan_bw;
+      unsigned char   chl;
+      unsigned char   pcl;
+      unsigned char   dl;
+      unsigned char   snrl;
+      unsigned char   snrh;
+      unsigned char   video_snr;
+               int             afc_freq;
+               int             video_sc_spacing;
+      unsigned char   video_sys;
+      unsigned char   color;
+      unsigned char   trans;
+      unsigned char   audio_sys;
+      unsigned char   audio_demod_mode;
+      unsigned char   sound_level;
+      unsigned char   resrved;
+}  si2176_atv_status_cmd_reply_struct;
+/* ATV_STATUS command, CHLINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_CHLINT_LSB                  0
+#define  SI2176_ATV_STATUS_RESPONSE_CHLINT_MASK               0x01
+#define SI2176_ATV_STATUS_RESPONSE_CHLINT_CHANGED       1
+#define SI2176_ATV_STATUS_RESPONSE_CHLINT_NO_CHANGE   0
+/* ATV_STATUS command, PCLINT field definition (size 1, lsb 1, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_PCLINT_LSB                   1
+#define  SI2176_ATV_STATUS_RESPONSE_PCLINT_MASK                0x01
+#define SI2176_ATV_STATUS_RESPONSE_PCLINT_CHANGED        1
+#define SI2176_ATV_STATUS_RESPONSE_PCLINT_NO_CHANGE    0
+/* ATV_STATUS command, DLINT field definition (size 1, lsb 2, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_DLINT_LSB                      2
+#define  SI2176_ATV_STATUS_RESPONSE_DLINT_MASK                   0x01
+#define SI2176_ATV_STATUS_RESPONSE_DLINT_CHANGED           1
+#define SI2176_ATV_STATUS_RESPONSE_DLINT_NO_CHANGE       0
+/* ATV_STATUS command, SNRLINT field definition (size 1, lsb 3, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_SNRLINT_LSB                 3
+#define  SI2176_ATV_STATUS_RESPONSE_SNRLINT_MASK              0x01
+#define SI2176_ATV_STATUS_RESPONSE_SNRLINT_CHANGED      1
+#define SI2176_ATV_STATUS_RESPONSE_SNRLINT_NO_CHANGE  0
+/* ATV_STATUS command, SNRHINT field definition (size 1, lsb 4, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_SNRHINT_LSB                 4
+#define  SI2176_ATV_STATUS_RESPONSE_SNRHINT_MASK              0x01
+#define SI2176_ATV_STATUS_RESPONSE_SNRHINT_CHANGED      1
+#define SI2176_ATV_STATUS_RESPONSE_SNRHINT_NO_CHANGE  0
+/* ATV_STATUS command, AUDIO_CHAN_BW field definition (size 4, lsb 0, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_LSB                         0
+#define  SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_MASK                      0x0f
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_12X_OVERMOD      3
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_150_KHZ_OFFSET  8
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_15_KHZ_OFFSET    5
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_30_KHZ_OFFSET    6
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_4X_OVERMOD         1
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_75_KHZ_OFFSET     7
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_7P5_KHZ_OFFSET  4
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_8X_OVERMOD         2
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_RSVD                       0
+/* ATV_STATUS command, CHL field definition (size 1, lsb 0, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_CHL_LSB                                            0
+#define  SI2176_ATV_STATUS_RESPONSE_CHL_MASK                                         0x01
+#define SI2176_ATV_STATUS_RESPONSE_CHL_CHANNEL                                 1
+#define SI2176_ATV_STATUS_RESPONSE_CHL_NO_CHANNEL                          0
+/* ATV_STATUS command, PCL field definition (size 1, lsb 1, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_PCL_LSB                                            1
+#define  SI2176_ATV_STATUS_RESPONSE_PCL_MASK                                         0x01
+#define SI2176_ATV_STATUS_RESPONSE_PCL_LOCKED                                    1
+#define SI2176_ATV_STATUS_RESPONSE_PCL_NO_LOCK                                  0
+/* ATV_STATUS command, DL field definition (size 1, lsb 2, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_DL_LSB                                              2
+#define  SI2176_ATV_STATUS_RESPONSE_DL_MASK                                           0x01
+#define SI2176_ATV_STATUS_RESPONSE_DL_LOCKED                                       1
+#define SI2176_ATV_STATUS_RESPONSE_DL_NO_LOCK                                     0
+/* ATV_STATUS command, SNRL field definition (size 1, lsb 3, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_SNRL_LSB                                         3
+#define  SI2176_ATV_STATUS_RESPONSE_SNRL_MASK                                      0x01
+#define SI2176_ATV_STATUS_RESPONSE_SNRL_SNR_LOW                               1
+#define SI2176_ATV_STATUS_RESPONSE_SNRL_SNR_NOT_LOW                      0
+/* ATV_STATUS command, SNRH field definition (size 1, lsb 4, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_SNRH_LSB                                         4
+#define  SI2176_ATV_STATUS_RESPONSE_SNRH_MASK                                      0x01
+#define SI2176_ATV_STATUS_RESPONSE_SNRH_SNR_HIGH                             1
+#define SI2176_ATV_STATUS_RESPONSE_SNRH_SNR_NOT_HIGH                    0
+/* ATV_STATUS command, VIDEO_SNR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_VIDEO_SNR_LSB                               0
+#define  SI2176_ATV_STATUS_RESPONSE_VIDEO_SNR_MASK                            0xff
+/* ATV_STATUS command, AFC_FREQ field definition (size 16, lsb 0, signed)*/
+#define  SI2176_ATV_STATUS_RESPONSE_AFC_FREQ_LSB                                 0
+#define  SI2176_ATV_STATUS_RESPONSE_AFC_FREQ_MASK                              0xffff
+#define  SI2176_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT                             16
+/* ATV_STATUS command, VIDEO_SC_SPACING field definition (size 16, lsb 0, signed)*/
+#define  SI2176_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_LSB                0
+#define  SI2176_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_MASK             0xffff
+#define  SI2176_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT            16
+/* ATV_STATUS command, VIDEO_SYS field definition (size 3, lsb 0, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB                                0
+#define  SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK                             0x07
+#define SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_B                                     0
+#define SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_DK                                  5
+#define SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_GH                                  1
+#define SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_I                                      4
+#define SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_L                                     6
+#define SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_LP                                   7
+#define SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_M                                     2
+#define SI2176_ATV_STATUS_RESPONSE_VIDEO_SYS_N                                     3
+/* ATV_STATUS command, COLOR field definition (size 1, lsb 4, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_COLOR_LSB                                        4
+#define  SI2176_ATV_STATUS_RESPONSE_COLOR_MASK                                     0x01
+#define SI2176_ATV_STATUS_RESPONSE_COLOR_PAL_NTSC                             0
+#define SI2176_ATV_STATUS_RESPONSE_COLOR_SECAM                                   1
+/* ATV_STATUS command, TRANS field definition (size 1, lsb 6, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_TRANS_LSB                                         6
+#define  SI2176_ATV_STATUS_RESPONSE_TRANS_MASK                                      0x01
+#define SI2176_ATV_STATUS_RESPONSE_TRANS_CABLE                                     1
+#define SI2176_ATV_STATUS_RESPONSE_TRANS_TERRESTRIAL                        0
+/* ATV_STATUS command, AUDIO_SYS field definition (size 4, lsb 0, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_LSB                                  0
+#define  SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_MASK                               0x0f
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_A2                                     3
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK2                            4
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK3                            5
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK4                            9
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_BTSC                                6
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_EIAJ                                  7
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO                               1
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO_NICAM                  2
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_RSVD                                0
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_SCAN                                8
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_SYS_WIDE_SCAN                     10
+/* ATV_STATUS command, AUDIO_DEMOD_MODE field definition (size 2, lsb 4, unsigned)*/
+#define  SI2176_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_LSB                 4
+#define  SI2176_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_MASK              0x03
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_AM                   1
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_FM1                 2
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_FM2                 3
+#define SI2176_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_SIF                  0
+
+#endif /* SI2176_ATV_STATUS_CMD */
+
+/* SI2176_CONFIG_PINS command definition */
+#define SI2176_CONFIG_PINS_CMD                                                                            0x12
+
+#ifdef    SI2176_CONFIG_PINS_CMD
+
+typedef struct { /* SI2176_CONFIG_PINS_CMD_struct */
+     unsigned char   gpio1_mode;
+     unsigned char   gpio1_read;
+     unsigned char   gpio2_mode;
+     unsigned char   gpio2_read;
+     unsigned char   gpio3_mode;
+     unsigned char   gpio3_read;
+     unsigned char   bclk1_mode;
+     unsigned char   bclk1_read;
+     unsigned char   xout_mode;
+} si2176_config_pins_cmd_struct;
+/* CONFIG_PINS command, GPIO1_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2176_CONFIG_PINS_CMD_GPIO1_MODE_LSB                                     0
+#define  SI2176_CONFIG_PINS_CMD_GPIO1_MODE_MASK                                  0x7f
+#define  SI2176_CONFIG_PINS_CMD_GPIO1_MODE_MIN                                     0
+#define  SI2176_CONFIG_PINS_CMD_GPIO1_MODE_MAX                                    3
+#define SI2176_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE                            1
+#define SI2176_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_0                             2
+#define SI2176_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1                             3
+#define SI2176_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE                      0
+/* CONFIG_PINS command, GPIO1_READ field definition (size 1, lsb 7, unsigned) */
+#define  SI2176_CONFIG_PINS_CMD_GPIO1_READ_LSB                                       7
+#define  SI2176_CONFIG_PINS_CMD_GPIO1_READ_MASK                                    0x01
+#define  SI2176_CONFIG_PINS_CMD_GPIO1_READ_MIN                                        0
+#define  SI2176_CONFIG_PINS_CMD_GPIO1_READ_MAX                                       1
+#define SI2176_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ                    0
+#define SI2176_CONFIG_PINS_CMD_GPIO1_READ_READ                                    1
+/* CONFIG_PINS command, GPIO2_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2176_CONFIG_PINS_CMD_GPIO2_MODE_LSB                                       0
+#define  SI2176_CONFIG_PINS_CMD_GPIO2_MODE_MASK                                    0x7f
+#define  SI2176_CONFIG_PINS_CMD_GPIO2_MODE_MIN                                       0
+#define  SI2176_CONFIG_PINS_CMD_GPIO2_MODE_MAX                                      3
+#define SI2176_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE                              1
+#define SI2176_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_0                               2
+#define SI2176_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_1                               3
+#define SI2176_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE                        0
+/* CONFIG_PINS command, GPIO2_READ field definition (size 1, lsb 7, unsigned) */
+#define  SI2176_CONFIG_PINS_CMD_GPIO2_READ_LSB                                        7
+#define  SI2176_CONFIG_PINS_CMD_GPIO2_READ_MASK                                     0x01
+#define  SI2176_CONFIG_PINS_CMD_GPIO2_READ_MIN                                        0
+#define  SI2176_CONFIG_PINS_CMD_GPIO2_READ_MAX                                       1
+#define SI2176_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ                     0
+#define SI2176_CONFIG_PINS_CMD_GPIO2_READ_READ                                     1
+/* CONFIG_PINS command, GPIO3_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2176_CONFIG_PINS_CMD_GPIO3_MODE_LSB                                        0
+#define  SI2176_CONFIG_PINS_CMD_GPIO3_MODE_MASK                                     0x7f
+#define  SI2176_CONFIG_PINS_CMD_GPIO3_MODE_MIN                                        0
+#define  SI2176_CONFIG_PINS_CMD_GPIO3_MODE_MAX                                       3
+#define SI2176_CONFIG_PINS_CMD_GPIO3_MODE_DISABLE                               1
+#define SI2176_CONFIG_PINS_CMD_GPIO3_MODE_DRIVE_0                                2
+#define SI2176_CONFIG_PINS_CMD_GPIO3_MODE_DRIVE_1                                3
+#define SI2176_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE                         0
+/* CONFIG_PINS command, GPIO3_READ field definition (size 1, lsb 7, unsigned) */
+#define  SI2176_CONFIG_PINS_CMD_GPIO3_READ_LSB                                         7
+#define  SI2176_CONFIG_PINS_CMD_GPIO3_READ_MASK                                      0x01
+#define  SI2176_CONFIG_PINS_CMD_GPIO3_READ_MIN                                          0
+#define  SI2176_CONFIG_PINS_CMD_GPIO3_READ_MAX                                         1
+#define SI2176_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ                       0
+#define SI2176_CONFIG_PINS_CMD_GPIO3_READ_READ                                       1
+/* CONFIG_PINS command, BCLK1_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2176_CONFIG_PINS_CMD_BCLK1_MODE_LSB                                          0
+#define  SI2176_CONFIG_PINS_CMD_BCLK1_MODE_MASK                                       0x7f
+#define  SI2176_CONFIG_PINS_CMD_BCLK1_MODE_MIN                                          0
+#define  SI2176_CONFIG_PINS_CMD_BCLK1_MODE_MAX                                         26
+#define SI2176_CONFIG_PINS_CMD_BCLK1_MODE_DISABLE                                  1
+#define SI2176_CONFIG_PINS_CMD_BCLK1_MODE_NO_CHANGE                           0
+#define SI2176_CONFIG_PINS_CMD_BCLK1_MODE_XOUT                                       10
+#define SI2176_CONFIG_PINS_CMD_BCLK1_MODE_XOUT_HIGH                            11
+/* CONFIG_PINS command, BCLK1_READ field definition (size 1, lsb 7, unsigned) */
+#define  SI2176_CONFIG_PINS_CMD_BCLK1_READ_LSB                                          7
+#define  SI2176_CONFIG_PINS_CMD_BCLK1_READ_MASK                                      0x01
+#define  SI2176_CONFIG_PINS_CMD_BCLK1_READ_MIN                                         0
+#define  SI2176_CONFIG_PINS_CMD_BCLK1_READ_MAX                                        1
+#define SI2176_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ                      0
+#define SI2176_CONFIG_PINS_CMD_BCLK1_READ_READ                                      1
+/* CONFIG_PINS command, XOUT_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2176_CONFIG_PINS_CMD_XOUT_MODE_LSB                                        0
+#define  SI2176_CONFIG_PINS_CMD_XOUT_MODE_MASK                                     0x7f
+#define  SI2176_CONFIG_PINS_CMD_XOUT_MODE_MIN                                         0
+#define  SI2176_CONFIG_PINS_CMD_XOUT_MODE_MAX                                        10
+#define SI2176_CONFIG_PINS_CMD_XOUT_MODE_DISABLE                                  1
+#define SI2176_CONFIG_PINS_CMD_XOUT_MODE_NO_CHANGE                           0
+#define SI2176_CONFIG_PINS_CMD_XOUT_MODE_XOUT                                       10
+
+typedef struct { /* SI2176_CONFIG_PINS_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+      unsigned char   gpio1_mode;
+      unsigned char   gpio1_state;
+      unsigned char   gpio2_mode;
+      unsigned char   gpio2_state;
+      unsigned char   gpio3_mode;
+      unsigned char   gpio3_state;
+      unsigned char   bclk1_mode;
+      unsigned char   bclk1_state;
+      unsigned char   xout_mode;
+}  si2176_config_pins_cmd_reply_struct;
+/* CONFIG_PINS command, GPIO1_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB                            0
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK                         0x7f
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO1_MODE_DISABLE                    1
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_0                    2
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_1                    3
+/* CONFIG_PINS command, GPIO1_STATE field definition (size 1, lsb 7, unsigned)*/
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB                           7
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK                        0x01
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_0                    0
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_1                    1
+/* CONFIG_PINS command, GPIO2_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB                            0
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK                         0x7f
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO2_MODE_DISABLE                    1
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_0                    2
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_1                    3
+/* CONFIG_PINS command, GPIO2_STATE field definition (size 1, lsb 7, unsigned)*/
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB                            7
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK                        0x01
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_0                    0
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_1                    1
+/* CONFIG_PINS command, GPIO3_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO3_MODE_LSB                            0
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO3_MODE_MASK                         0x7f
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO3_MODE_DISABLE                    1
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO3_MODE_DRIVE_0                    2
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO3_MODE_DRIVE_1                    3
+/* CONFIG_PINS command, GPIO3_STATE field definition (size 1, lsb 7, unsigned)*/
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO3_STATE_LSB                           7
+#define  SI2176_CONFIG_PINS_RESPONSE_GPIO3_STATE_MASK                        0x01
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO3_STATE_READ_0                    0
+#define SI2176_CONFIG_PINS_RESPONSE_GPIO3_STATE_READ_1                    1
+/* CONFIG_PINS command, BCLK1_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2176_CONFIG_PINS_RESPONSE_BCLK1_MODE_LSB                            0
+#define  SI2176_CONFIG_PINS_RESPONSE_BCLK1_MODE_MASK                         0x7f
+#define SI2176_CONFIG_PINS_RESPONSE_BCLK1_MODE_DISABLE                   1
+#define SI2176_CONFIG_PINS_RESPONSE_BCLK1_MODE_XOUT                         10
+#define SI2176_CONFIG_PINS_RESPONSE_BCLK1_MODE_XOUT_HIGH              11
+/* CONFIG_PINS command, BCLK1_STATE field definition (size 1, lsb 7, unsigned)*/
+#define  SI2176_CONFIG_PINS_RESPONSE_BCLK1_STATE_LSB                          7
+#define  SI2176_CONFIG_PINS_RESPONSE_BCLK1_STATE_MASK                       0x01
+#define SI2176_CONFIG_PINS_RESPONSE_BCLK1_STATE_READ_0                    0
+#define SI2176_CONFIG_PINS_RESPONSE_BCLK1_STATE_READ_1                    1
+/* CONFIG_PINS command, XOUT_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2176_CONFIG_PINS_RESPONSE_XOUT_MODE_LSB                              0
+#define  SI2176_CONFIG_PINS_RESPONSE_XOUT_MODE_MASK                           0x7f
+#define SI2176_CONFIG_PINS_RESPONSE_XOUT_MODE_DISABLE                      1
+#define SI2176_CONFIG_PINS_RESPONSE_XOUT_MODE_XOUT                            10
+
+#endif /* SI2176_CONFIG_PINS_CMD */
+
+/* SI2176_DOWNLOAD_DATASET_CONTINUE command definition */
+//#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD 0xb9
+
+#ifdef    SI2176_DOWNLOAD_DATASET_CONTINUE_CMD
+
+typedef struct { /* SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_struct */
+     unsigned char   data0;
+     unsigned char   data1;
+     unsigned char   data2;
+     unsigned char   data3;
+     unsigned char   data4;
+     unsigned char   data5;
+     unsigned char   data6;
+} si2176_download_dataset_continue_cmd_struct;
+
+/* DOWNLOAD_DATASET_CONTINUE command, DATA0 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_LSB               0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MASK            0xff
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MIN               0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MAX              255
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MIN  0
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MAX 255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA1 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_LSB               0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MASK            0xff
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MIN               0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MAX              255
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MIN  0
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MAX 255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA2 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_LSB               0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MASK            0xff
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MIN               0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MAX              255
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MIN  0
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MAX 255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA3 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_LSB               0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MASK            0xff
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MIN                0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MAX              255
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MIN   0
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA4 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_LSB                0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MASK             0xff
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MIN                0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MAX               255
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MIN   0
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA5 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_LSB                0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MASK             0xff
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MIN                 0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MAX                255
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MIN    0
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MAX   255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA6 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_LSB                 0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MASK              0xff
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MIN                  0
+#define  SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MAX                 255
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MIN     0
+#define SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MAX    255
+
+typedef struct { /* SI2176_DOWNLOAD_DATASET_CONTINUE_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_download_dataset_continue_cmd_reply_struct;
+
+#endif /* SI2176_DOWNLOAD_DATASET_CONTINUE_CMD */
+
+/* SI2176_DOWNLOAD_DATASET_START command definition */
+//#define SI2176_DOWNLOAD_DATASET_START_CMD 0xb8
+
+#ifdef    SI2176_DOWNLOAD_DATASET_START_CMD
+
+typedef struct { /* SI2176_DOWNLOAD_DATASET_START_CMD_struct */
+     unsigned char   dataset_id;
+     unsigned char   dataset_checksum;
+     unsigned char   data0;
+     unsigned char   data1;
+     unsigned char   data2;
+     unsigned char   data3;
+     unsigned char   data4;
+} si2176_download_dataset_start_cmd_struct;
+/* DOWNLOAD_DATASET_START command, DATASET_ID field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_LSB                        0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MASK                     0xff
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MIN                         0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MAX                        29
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_B     6
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_DK   7
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_G     8
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_I       9
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_L      10
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_M     11
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_B       12
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_DK     13
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_G       14
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_I        15
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_L       16
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_M      17
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_B           21
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_DK        22
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_G           23
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_I            24
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_L           25
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_M          26
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_ALIF_6  27
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_ALIF_7  28
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_ALIF_8  29
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_B           0
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DK        1
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DTV_6  18
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DTV_7  19
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DTV_8  20
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_G           2
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_I            3
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_L           4
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_M          5
+/* DOWNLOAD_DATASET_START command, DATASET_CHECKSUM field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_LSB         0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MASK      0xff
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MIN         0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MAX        255
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MIN  0
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA0 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA0_LSB              0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA0_MASK           0xff
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA0_MIN               0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA0_MAX              255
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MIN   0
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA1 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA1_LSB               0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA1_MASK            0xff
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA1_MIN               0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA1_MAX              255
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MIN   0
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA2 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA2_LSB                0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA2_MASK             0xff
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA2_MIN                 0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA2_MAX                255
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MIN    0
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA3 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA3_LSB                 0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA3_MASK              0xff
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA3_MIN                 0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA3_MAX                255
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MIN    0
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MAX   255
+/* DOWNLOAD_DATASET_START command, DATA4 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA4_LSB                 0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA4_MASK              0xff
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA4_MIN                 0
+#define  SI2176_DOWNLOAD_DATASET_START_CMD_DATA4_MAX                255
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MIN    0
+#define SI2176_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MAX   255
+
+typedef struct { /* SI2176_DOWNLOAD_DATASET_START_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_download_dataset_start_cmd_reply_struct;
+
+#endif /* SI2176_DOWNLOAD_DATASET_START_CMD */
+
+/* SI2176_DTV_RESTART command definition */
+#define SI2176_DTV_RESTART_CMD 0x61
+
+#ifdef    SI2176_DTV_RESTART_CMD
+
+typedef struct { /* SI2176_DTV_RESTART_CMD_struct */
+       unsigned char   nothing;
+} si2176_dtv_restart_cmd_struct;
+
+
+typedef struct { /* SI2176_DTV_RESTART_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_dtv_restart_cmd_reply_struct;
+
+#endif /* SI2176_DTV_RESTART_CMD */
+
+/* SI2176_DTV_STATUS command definition */
+#define SI2176_DTV_STATUS_CMD 0x62
+
+#ifdef    SI2176_DTV_STATUS_CMD
+
+typedef struct { /* SI2176_DTV_STATUS_CMD_struct */
+     unsigned char   intack;
+} si2176_dtv_status_cmd_struct;
+
+/* DTV_STATUS command, INTACK field definition (size 1, lsb 0, unsigned) */
+#define  SI2176_DTV_STATUS_CMD_INTACK_LSB          0
+#define  SI2176_DTV_STATUS_CMD_INTACK_MASK       0x01
+#define  SI2176_DTV_STATUS_CMD_INTACK_MIN          0
+#define  SI2176_DTV_STATUS_CMD_INTACK_MAX         1
+#define SI2176_DTV_STATUS_CMD_INTACK_CLEAR      1
+#define SI2176_DTV_STATUS_CMD_INTACK_OK             0
+
+typedef struct { /* SI2176_DTV_STATUS_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+      unsigned char   chlint;
+      unsigned char   chl;
+      unsigned char   bw;
+      unsigned char   modulation;
+}  si2176_dtv_status_cmd_reply_struct;
+
+/* DTV_STATUS command, CHLINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2176_DTV_STATUS_RESPONSE_CHLINT_LSB                 0
+#define  SI2176_DTV_STATUS_RESPONSE_CHLINT_MASK              0x01
+#define SI2176_DTV_STATUS_RESPONSE_CHLINT_CHANGED       1
+#define SI2176_DTV_STATUS_RESPONSE_CHLINT_NO_CHANGE   0
+/* DTV_STATUS command, CHL field definition (size 1, lsb 0, unsigned)*/
+#define  SI2176_DTV_STATUS_RESPONSE_CHL_LSB                       0
+#define  SI2176_DTV_STATUS_RESPONSE_CHL_MASK                    0x01
+#define SI2176_DTV_STATUS_RESPONSE_CHL_CHANNEL              1
+#define SI2176_DTV_STATUS_RESPONSE_CHL_NO_CHANNEL       0
+/* DTV_STATUS command, BW field definition (size 4, lsb 0, unsigned)*/
+#define  SI2176_DTV_STATUS_RESPONSE_BW_LSB                         0
+#define  SI2176_DTV_STATUS_RESPONSE_BW_MASK                      0x0f
+#define SI2176_DTV_STATUS_RESPONSE_BW_BW_6MHZ                6
+#define SI2176_DTV_STATUS_RESPONSE_BW_BW_7MHZ                7
+#define SI2176_DTV_STATUS_RESPONSE_BW_BW_8MHZ                8
+/* DTV_STATUS command, MODULATION field definition (size 4, lsb 4, unsigned)*/
+#define  SI2176_DTV_STATUS_RESPONSE_MODULATION_LSB       4
+#define  SI2176_DTV_STATUS_RESPONSE_MODULATION_MASK    0x0f
+#define SI2176_DTV_STATUS_RESPONSE_MODULATION_ATSC      0
+#define SI2176_DTV_STATUS_RESPONSE_MODULATION_DTMB      6
+#define SI2176_DTV_STATUS_RESPONSE_MODULATION_DVBC      3
+#define SI2176_DTV_STATUS_RESPONSE_MODULATION_DVBT       2
+#define SI2176_DTV_STATUS_RESPONSE_MODULATION_ISDBC     5
+#define SI2176_DTV_STATUS_RESPONSE_MODULATION_ISDBT     4
+#define SI2176_DTV_STATUS_RESPONSE_MODULATION_QAM_US  1
+
+#endif /* SI2176_DTV_STATUS_CMD */
+
+/* SI2176_EXIT_BOOTLOADER command definition */
+#define SI2176_EXIT_BOOTLOADER_CMD                                             0x01
+
+#ifdef    SI2176_EXIT_BOOTLOADER_CMD
+
+typedef struct { /* SI2176_EXIT_BOOTLOADER_CMD_struct */
+     unsigned char   func;
+     unsigned char   ctsien;
+} si2176_exit_bootloader_cmd_struct;
+
+/* EXIT_BOOTLOADER command, FUNC field definition (size 4, lsb 0, unsigned) */
+#define  SI2176_EXIT_BOOTLOADER_CMD_FUNC_LSB                        0
+#define  SI2176_EXIT_BOOTLOADER_CMD_FUNC_MASK                     0x0f
+#define  SI2176_EXIT_BOOTLOADER_CMD_FUNC_MIN                        0
+#define  SI2176_EXIT_BOOTLOADER_CMD_FUNC_MAX                       1
+#define SI2176_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER       0
+#define SI2176_EXIT_BOOTLOADER_CMD_FUNC_TUNER                   1
+/* EXIT_BOOTLOADER command, CTSIEN field definition (size 1, lsb 7, unsigned) */
+#define  SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_LSB                     7
+#define  SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_MASK                 0x01
+#define  SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_MIN                     0
+#define  SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_MAX                    1
+#define SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_OFF                     0
+#define SI2176_EXIT_BOOTLOADER_CMD_CTSIEN_ON                       1
+
+typedef struct { /* SI2176_EXIT_BOOTLOADER_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_exit_bootloader_cmd_reply_struct;
+
+#endif /* SI2176_EXIT_BOOTLOADER_CMD */
+
+/* SI2176_FINE_TUNE command definition */
+#define SI2176_FINE_TUNE_CMD                                                            0x45
+
+#ifdef    SI2176_FINE_TUNE_CMD
+
+typedef struct { /* SI2176_FINE_TUNE_CMD_struct */
+     unsigned char   reserved;
+                       int    offset_500hz;
+} si2176_fine_tune_cmd_struct;
+
+/* FINE_TUNE command, RESERVED field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_FINE_TUNE_CMD_RESERVED_LSB                             0
+#define  SI2176_FINE_TUNE_CMD_RESERVED_MASK                          0xff
+#define  SI2176_FINE_TUNE_CMD_RESERVED_MIN                             0
+#define  SI2176_FINE_TUNE_CMD_RESERVED_MAX                            0
+#define SI2176_FINE_TUNE_CMD_RESERVED_RESERVED                 0
+/* FINE_TUNE command, OFFSET_500HZ field definition (size 16, lsb 0, signed) */
+#define  SI2176_FINE_TUNE_CMD_OFFSET_500HZ_LSB                      0
+#define  SI2176_FINE_TUNE_CMD_OFFSET_500HZ_MASK                   0xffff
+#define  SI2176_FINE_TUNE_CMD_OFFSET_500HZ_SHIFT                  16
+#define  SI2176_FINE_TUNE_CMD_OFFSET_500HZ_MIN                      -4000
+#define  SI2176_FINE_TUNE_CMD_OFFSET_500HZ_MAX                     4000
+#define SI2176_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MIN  -4000
+#define SI2176_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MAX  4000
+
+typedef struct { /* SI2176_FINE_TUNE_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_fine_tune_cmd_reply_struct;
+
+#endif /* SI2176_FINE_TUNE_CMD */
+
+/* SI2176_GET_PROPERTY command definition */
+#define SI2176_GET_PROPERTY_CMD                                                    0x15
+
+#ifdef    SI2176_GET_PROPERTY_CMD
+
+typedef struct { /* SI2176_GET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned   int    prop;
+} si2176_get_property_cmd_struct;
+
+/* GET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_GET_PROPERTY_CMD_RESERVED_LSB                     0
+#define  SI2176_GET_PROPERTY_CMD_RESERVED_MASK                  0xff
+#define  SI2176_GET_PROPERTY_CMD_RESERVED_MIN                      0
+#define  SI2176_GET_PROPERTY_CMD_RESERVED_MAX                     0
+#define SI2176_GET_PROPERTY_CMD_RESERVED_RESERVED_MIN  0
+#define SI2176_GET_PROPERTY_CMD_RESERVED_RESERVED_MAX 0
+/* GET_PROPERTY command, PROP field definition (size 16, lsb 0, unsigned) */
+#define  SI2176_GET_PROPERTY_CMD_PROP_LSB                                0
+#define  SI2176_GET_PROPERTY_CMD_PROP_MASK                             0xffff
+#define  SI2176_GET_PROPERTY_CMD_PROP_MIN                                0
+#define  SI2176_GET_PROPERTY_CMD_PROP_MAX                               65535
+#define SI2176_GET_PROPERTY_CMD_PROP_PROP_MIN                      0
+#define SI2176_GET_PROPERTY_CMD_PROP_PROP_MAX                     65535
+
+typedef struct { /* SI2176_GET_PROPERTY_CMD_REPLY_struct */
+      si2176_common_reply_struct * status;
+      unsigned char   reserved;
+      unsigned int    data;
+}  si2176_get_property_cmd_reply_struct;
+
+/* GET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_GET_PROPERTY_RESPONSE_RESERVED_LSB         0
+#define  SI2176_GET_PROPERTY_RESPONSE_RESERVED_MASK      0xff
+/* GET_PROPERTY command, DATA field definition (size 16, lsb 0, unsigned)*/
+#define  SI2176_GET_PROPERTY_RESPONSE_DATA_LSB                   0
+#define  SI2176_GET_PROPERTY_RESPONSE_DATA_MASK                0xffff
+
+#endif /* SI2176_GET_PROPERTY_CMD */
+
+/* SI2176_GET_REV command definition */
+#define SI2176_GET_REV_CMD                                                                  0x11
+
+#ifdef    SI2176_GET_REV_CMD
+
+typedef struct { /* SI2176_GET_REV_CMD_struct */
+    unsigned char   nothing;
+} si2176_get_rev_cmd_struct;
+
+
+typedef struct { /* SI2176_GET_REV_CMD_REPLY_struct */
+      si2176_common_reply_struct * status;
+      unsigned  char                          pn;
+      unsigned  char                          fwmajor;
+      unsigned  char                          fwminor;
+      unsigned  int                             patch;
+      unsigned  char                          cmpmajor;
+      unsigned  char                          cmpminor;
+      unsigned  char                          cmpbuild;
+      unsigned  char                          chiprev;
+}  si2176_get_rev_cmd_reply_struct;
+
+/* GET_REV command, PN field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_GET_REV_RESPONSE_PN_LSB                                   0
+#define  SI2176_GET_REV_RESPONSE_PN_MASK                                0xff
+/* GET_REV command, FWMAJOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_GET_REV_RESPONSE_FWMAJOR_LSB                       0
+#define  SI2176_GET_REV_RESPONSE_FWMAJOR_MASK                    0xff
+/* GET_REV command, FWMINOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_GET_REV_RESPONSE_FWMINOR_LSB                       0
+#define  SI2176_GET_REV_RESPONSE_FWMINOR_MASK                    0xff
+/* GET_REV command, PATCH field definition (size 16, lsb 0, unsigned)*/
+#define  SI2176_GET_REV_RESPONSE_PATCH_LSB                            0
+#define  SI2176_GET_REV_RESPONSE_PATCH_MASK                         0xffff
+/* GET_REV command, CMPMAJOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_GET_REV_RESPONSE_CMPMAJOR_LSB                     0
+#define  SI2176_GET_REV_RESPONSE_CMPMAJOR_MASK                  0xff
+/* GET_REV command, CMPMINOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_GET_REV_RESPONSE_CMPMINOR_LSB                     0
+#define  SI2176_GET_REV_RESPONSE_CMPMINOR_MASK                  0xff
+/* GET_REV command, CMPBUILD field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_GET_REV_RESPONSE_CMPBUILD_LSB                      0
+#define  SI2176_GET_REV_RESPONSE_CMPBUILD_MASK                   0xff
+#define SI2176_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MIN   0
+#define SI2176_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MAX  255
+/* GET_REV command, CHIPREV field definition (size 4, lsb 0, unsigned)*/
+#define  SI2176_GET_REV_RESPONSE_CHIPREV_LSB                        0
+#define  SI2176_GET_REV_RESPONSE_CHIPREV_MASK                     0x0f
+#define SI2176_GET_REV_RESPONSE_CHIPREV_A                              1
+#define SI2176_GET_REV_RESPONSE_CHIPREV_B                              2
+
+#endif /* SI2176_GET_REV_CMD */
+
+/* SI2176_PART_INFO command definition */
+#define SI2176_PART_INFO_CMD                                                            0x02
+
+#ifdef    SI2176_PART_INFO_CMD
+
+typedef struct { /* SI2176_PART_INFO_CMD_struct */
+     unsigned char   nothing;
+} si2176_part_info_cmd_struct;
+
+
+typedef struct { /* SI2176_PART_INFO_CMD_REPLY_struct */
+      si2176_common_reply_struct * status;
+      unsigned char   chiprev;
+      unsigned char   romid;
+      unsigned char   part;
+      unsigned char   pmajor;
+      unsigned char   pminor;
+      unsigned char   pbuild;
+      unsigned int    reserved;
+      unsigned long   serial;
+}  si2176_part_info_cmd_reply_struct;
+
+/* PART_INFO command, CHIPREV field definition (size 4, lsb 0, unsigned)*/
+#define  SI2176_PART_INFO_RESPONSE_CHIPREV_LSB           0
+#define  SI2176_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+#define SI2176_PART_INFO_RESPONSE_CHIPREV_A                 1
+#define SI2176_PART_INFO_RESPONSE_CHIPREV_B                 2
+/* PART_INFO command, ROMID field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_PART_INFO_RESPONSE_ROMID_LSB                0
+#define  SI2176_PART_INFO_RESPONSE_ROMID_MASK             0xff
+/* PART_INFO command, PART field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_PART_INFO_RESPONSE_PART_LSB                   0
+#define  SI2176_PART_INFO_RESPONSE_PART_MASK                0xff
+/* PART_INFO command, PMAJOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_PART_INFO_RESPONSE_PMAJOR_LSB               0
+#define  SI2176_PART_INFO_RESPONSE_PMAJOR_MASK            0xff
+/* PART_INFO command, PMINOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_PART_INFO_RESPONSE_PMINOR_LSB               0
+#define  SI2176_PART_INFO_RESPONSE_PMINOR_MASK            0xff
+/* PART_INFO command, PBUILD field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_PART_INFO_RESPONSE_PBUILD_LSB                0
+#define  SI2176_PART_INFO_RESPONSE_PBUILD_MASK             0xff
+/* PART_INFO command, RESERVED field definition (size 16, lsb 0, unsigned)*/
+#define  SI2176_PART_INFO_RESPONSE_RESERVED_LSB         0
+#define  SI2176_PART_INFO_RESPONSE_RESERVED_MASK      0xffff
+/* PART_INFO command, SERIAL field definition (size 32, lsb 0, unsigned)*/
+#define  SI2176_PART_INFO_RESPONSE_SERIAL_LSB                0
+#define  SI2176_PART_INFO_RESPONSE_SERIAL_MASK             0xffffffff
+
+#endif /* SI2176_PART_INFO_CMD */
+
+/* SI2176_POWER_DOWN command definition */
+#define SI2176_POWER_DOWN_CMD                                               0x13
+
+#ifdef    SI2176_POWER_DOWN_CMD
+
+typedef struct { /* SI2176_POWER_DOWN_CMD_struct */
+       unsigned char   nothing;
+} si2176_power_down_cmd_struct;
+
+
+typedef struct { /* SI2176_POWER_DOWN_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_power_down_cmd_reply_struct;
+
+#endif /* SI2176_POWER_DOWN_CMD */
+
+/* SI2176_POWER_UP command definition */
+#define SI2176_POWER_UP_CMD                                                    0xc0
+
+#ifdef    SI2176_POWER_UP_CMD
+
+typedef struct { /* SI2176_POWER_UP_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   reserved1;
+     unsigned char   reserved2;
+     unsigned char   reserved3;
+     unsigned char   clock_mode;
+     unsigned char   clock_freq;
+     unsigned char   addr_mode;
+     unsigned char   func;
+     unsigned char   ctsien;
+     unsigned char   wake_up;
+} si2176_power_up_cmd_struct;
+
+/* POWER_UP command, SUBCODE field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_POWER_UP_CMD_SUBCODE_LSB                  0
+#define  SI2176_POWER_UP_CMD_SUBCODE_MASK               0xff
+#define  SI2176_POWER_UP_CMD_SUBCODE_MIN                   5
+#define  SI2176_POWER_UP_CMD_SUBCODE_MAX                  5
+#define SI2176_POWER_UP_CMD_SUBCODE_CODE                5
+/* POWER_UP command, RESERVED1 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_POWER_UP_CMD_RESERVED1_LSB               0
+#define  SI2176_POWER_UP_CMD_RESERVED1_MASK            0xff
+#define  SI2176_POWER_UP_CMD_RESERVED1_MIN               1
+#define  SI2176_POWER_UP_CMD_RESERVED1_MAX              1
+#define SI2176_POWER_UP_CMD_RESERVED1_RESERVED   1
+/* POWER_UP command, RESERVED2 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_POWER_UP_CMD_RESERVED2_LSB                0
+#define  SI2176_POWER_UP_CMD_RESERVED2_MASK             0xff
+#define  SI2176_POWER_UP_CMD_RESERVED2_MIN                0
+#define  SI2176_POWER_UP_CMD_RESERVED2_MAX               0
+#define SI2176_POWER_UP_CMD_RESERVED2_RESERVED    0
+/* POWER_UP command, RESERVED3 field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_POWER_UP_CMD_RESERVED3_LSB                0
+#define  SI2176_POWER_UP_CMD_RESERVED3_MASK             0xff
+#define  SI2176_POWER_UP_CMD_RESERVED3_MIN                0
+#define  SI2176_POWER_UP_CMD_RESERVED3_MAX               0
+#define SI2176_POWER_UP_CMD_RESERVED3_RESERVED    0
+/* POWER_UP command, CLOCK_MODE field definition (size 2, lsb 0, unsigned) */
+#define  SI2176_POWER_UP_CMD_CLOCK_MODE_LSB              0
+#define  SI2176_POWER_UP_CMD_CLOCK_MODE_MASK           0x03
+#define  SI2176_POWER_UP_CMD_CLOCK_MODE_MIN              1
+#define  SI2176_POWER_UP_CMD_CLOCK_MODE_MAX             3
+#define SI2176_POWER_UP_CMD_CLOCK_MODE_EXTCLK       1
+#define SI2176_POWER_UP_CMD_CLOCK_MODE_XTAL            3
+/* POWER_UP command, CLOCK_FREQ field definition (size 2, lsb 2, unsigned) */
+#define  SI2176_POWER_UP_CMD_CLOCK_FREQ_LSB              2
+#define  SI2176_POWER_UP_CMD_CLOCK_FREQ_MASK           0x03
+#define  SI2176_POWER_UP_CMD_CLOCK_FREQ_MIN               0
+#define  SI2176_POWER_UP_CMD_CLOCK_FREQ_MAX              2
+#define SI2176_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+/* POWER_UP command, ADDR_MODE field definition (size 1, lsb 4, unsigned) */
+#define  SI2176_POWER_UP_CMD_ADDR_MODE_LSB                4
+#define  SI2176_POWER_UP_CMD_ADDR_MODE_MASK             0x01
+#define  SI2176_POWER_UP_CMD_ADDR_MODE_MIN                 0
+#define  SI2176_POWER_UP_CMD_ADDR_MODE_MAX                1
+#define SI2176_POWER_UP_CMD_ADDR_MODE_CAPTURE       1
+#define SI2176_POWER_UP_CMD_ADDR_MODE_CURRENT       0
+/* POWER_UP command, FUNC field definition (size 4, lsb 0, unsigned) */
+#define  SI2176_POWER_UP_CMD_FUNC_LSB                             0
+#define  SI2176_POWER_UP_CMD_FUNC_MASK                          0x0f
+#define  SI2176_POWER_UP_CMD_FUNC_MIN                             0
+#define  SI2176_POWER_UP_CMD_FUNC_MAX                            1
+#define SI2176_POWER_UP_CMD_FUNC_BOOTLOADER            0
+#define SI2176_POWER_UP_CMD_FUNC_NORMAL                      1
+/* POWER_UP command, CTSIEN field definition (size 1, lsb 7, unsigned) */
+#define  SI2176_POWER_UP_CMD_CTSIEN_LSB                          7
+#define  SI2176_POWER_UP_CMD_CTSIEN_MASK                       0x01
+#define  SI2176_POWER_UP_CMD_CTSIEN_MIN                          0
+#define  SI2176_POWER_UP_CMD_CTSIEN_MAX                         1
+#define SI2176_POWER_UP_CMD_CTSIEN_DISABLE                  0
+#define SI2176_POWER_UP_CMD_CTSIEN_ENABLE                   1
+/* POWER_UP command, WAKE_UP field definition (size 1, lsb 0, unsigned) */
+#define  SI2176_POWER_UP_CMD_WAKE_UP_LSB                     0
+#define  SI2176_POWER_UP_CMD_WAKE_UP_MASK                  0x01
+#define  SI2176_POWER_UP_CMD_WAKE_UP_MIN                      1
+#define  SI2176_POWER_UP_CMD_WAKE_UP_MAX                     1
+#define SI2176_POWER_UP_CMD_WAKE_UP_WAKE_UP            1
+
+typedef struct { /* SI2176_POWER_UP_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_power_up_cmd_reply_struct;
+
+#endif /* SI2176_POWER_UP_CMD */
+
+/* SI2176_SET_PROPERTY command definition */
+#define SI2176_SET_PROPERTY_CMD                                         0x14
+
+#ifdef    SI2176_SET_PROPERTY_CMD
+
+typedef struct { /* SI2176_SET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned int      prop;
+     unsigned int      data;
+} si2176_set_property_cmd_struct;
+
+/* SET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned) */
+#define  SI2176_SET_PROPERTY_CMD_RESERVED_LSB         0
+#define  SI2176_SET_PROPERTY_CMD_RESERVED_MASK      0xff
+#define  SI2176_SET_PROPERTY_CMD_RESERVED_MIN         0
+#define  SI2176_SET_PROPERTY_CMD_RESERVED_MAX        255.0
+/* SET_PROPERTY command, PROP field definition (size 16, lsb 0, unsigned) */
+#define  SI2176_SET_PROPERTY_CMD_PROP_LSB                   0
+#define  SI2176_SET_PROPERTY_CMD_PROP_MASK                0xffff
+#define  SI2176_SET_PROPERTY_CMD_PROP_MIN                   0
+#define  SI2176_SET_PROPERTY_CMD_PROP_MAX                  65535
+#define SI2176_SET_PROPERTY_CMD_PROP_PROP_MIN        0
+#define SI2176_SET_PROPERTY_CMD_PROP_PROP_MAX       65535
+/* SET_PROPERTY command, DATA field definition (size 16, lsb 0, unsigned) */
+#define  SI2176_SET_PROPERTY_CMD_DATA_LSB                   0
+#define  SI2176_SET_PROPERTY_CMD_DATA_MASK                0xffff
+#define  SI2176_SET_PROPERTY_CMD_DATA_MIN                   0
+#define  SI2176_SET_PROPERTY_CMD_DATA_MAX                  65535
+#define SI2176_SET_PROPERTY_CMD_DATA_DATA_MIN         0
+#define SI2176_SET_PROPERTY_CMD_DATA_DATA_MAX        65535
+
+typedef struct { /* SI2176_SET_PROPERTY_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+      unsigned  char                           reserved;
+      unsigned  int                              data;
+}  si2176_set_property_cmd_reply_struct;
+
+/* SET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned)*/
+#define  SI2176_SET_PROPERTY_RESPONSE_RESERVED_LSB                      0
+#define  SI2176_SET_PROPERTY_RESPONSE_RESERVED_MASK                   0xff
+#define SI2176_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+#define SI2176_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX 0
+/* SET_PROPERTY command, DATA field definition (size 16, lsb 0, unsigned)*/
+#define  SI2176_SET_PROPERTY_RESPONSE_DATA_LSB                                 0
+#define  SI2176_SET_PROPERTY_RESPONSE_DATA_MASK                              0xffff
+
+#endif /* SI2176_SET_PROPERTY_CMD */
+
+/* SI2176_STANDBY command definition */
+#define SI2176_STANDBY_CMD                                                                             0x16
+
+#ifdef    SI2176_STANDBY_CMD
+
+typedef struct { /* SI2176_STANDBY_CMD_struct */
+        unsigned char   nothing;
+} si2176_standby_cmd_struct;
+
+
+typedef struct { /* SI2176_STANDBY_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_standby_cmd_reply_struct;
+
+#endif /* SI2176_STANDBY_CMD */
+
+/* SI2176_TUNER_STATUS command definition */
+#define SI2176_TUNER_STATUS_CMD                                                                 0x42
+
+#ifdef    SI2176_TUNER_STATUS_CMD
+
+typedef struct { /* SI2176_TUNER_STATUS_CMD_struct */
+     unsigned char   intack;
+} si2176_tuner_status_cmd_struct;
+
+/* TUNER_STATUS command, INTACK field definition (size 1, lsb 0, unsigned) */
+#define  SI2176_TUNER_STATUS_CMD_INTACK_LSB                             0
+#define  SI2176_TUNER_STATUS_CMD_INTACK_MASK                          0x01
+#define  SI2176_TUNER_STATUS_CMD_INTACK_MIN                             0
+#define  SI2176_TUNER_STATUS_CMD_INTACK_MAX                            1
+#define SI2176_TUNER_STATUS_CMD_INTACK_CLEAR                         1
+#define SI2176_TUNER_STATUS_CMD_INTACK_OK                                0
+
+typedef struct { /* SI2176_TUNER_STATUS_CMD_REPLY_struct */
+      si2176_common_reply_struct * status;
+      unsigned  char                          tcint;
+      unsigned  char                          rssilint;
+      unsigned  char                          rssihint;
+                         int                           vco_code;
+      unsigned  char                          tc;
+      unsigned  char                          rssil;
+      unsigned  char                          rssih;
+                      char                           rssi;
+      unsigned    int                            freq;
+      unsigned  char                          mode;
+      unsigned  char                          resrved;
+}  si2176_tuner_status_cmd_reply_struct;
+
+/* TUNER_STATUS command, TCINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_TCINT_LSB                      0
+#define  SI2176_TUNER_STATUS_RESPONSE_TCINT_MASK                   0x01
+#define SI2176_TUNER_STATUS_RESPONSE_TCINT_CHANGED            1
+#define SI2176_TUNER_STATUS_RESPONSE_TCINT_NO_CHANGE        0
+/* TUNER_STATUS command, RSSILINT field definition (size 1, lsb 1, unsigned)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSILINT_LSB                1
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSILINT_MASK             0x01
+#define SI2176_TUNER_STATUS_RESPONSE_RSSILINT_CHANGED      1
+#define SI2176_TUNER_STATUS_RESPONSE_RSSILINT_NO_CHANGE  0
+/* TUNER_STATUS command, RSSIHINT field definition (size 1, lsb 2, unsigned)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSIHINT_LSB                2
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSIHINT_MASK             0x01
+#define SI2176_TUNER_STATUS_RESPONSE_RSSIHINT_CHANGED      1
+#define SI2176_TUNER_STATUS_RESPONSE_RSSIHINT_NO_CHANGE  0
+/* TUNER_STATUS command, VCO_CODE field definition (size 16, lsb 0, signed)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_VCO_CODE_LSB              0
+#define  SI2176_TUNER_STATUS_RESPONSE_VCO_CODE_MASK           0xffff
+#define  SI2176_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT          16
+/* TUNER_STATUS command, TC field definition (size 1, lsb 0, unsigned)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_TC_LSB                             0
+#define  SI2176_TUNER_STATUS_RESPONSE_TC_MASK                          0x01
+#define SI2176_TUNER_STATUS_RESPONSE_TC_BUSY                           0
+#define SI2176_TUNER_STATUS_RESPONSE_TC_DONE                           1
+/* TUNER_STATUS command, RSSIL field definition (size 1, lsb 1, unsigned)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSIL_LSB                        1
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSIL_MASK                     0x01
+#define SI2176_TUNER_STATUS_RESPONSE_RSSIL_LOW                        1
+#define SI2176_TUNER_STATUS_RESPONSE_RSSIL_OK                           0
+/* TUNER_STATUS command, RSSIH field definition (size 1, lsb 2, unsigned)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSIH_LSB                        2
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSIH_MASK                     0x01
+#define SI2176_TUNER_STATUS_RESPONSE_RSSIH_HIGH                       1
+#define SI2176_TUNER_STATUS_RESPONSE_RSSIH_OK                           0
+/* TUNER_STATUS command, RSSI field definition (size 8, lsb 0, signed)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSI_LSB                           0
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSI_MASK                        0xff
+#define  SI2176_TUNER_STATUS_RESPONSE_RSSI_SHIFT                       24
+/* TUNER_STATUS command, FREQ field definition (size 32, lsb 0, unsigned)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_FREQ_LSB                          0
+#define  SI2176_TUNER_STATUS_RESPONSE_FREQ_MASK                       0xffffffff
+/* TUNER_STATUS command, MODE field definition (size 1, lsb 0, unsigned)*/
+#define  SI2176_TUNER_STATUS_RESPONSE_MODE_LSB                         0
+#define  SI2176_TUNER_STATUS_RESPONSE_MODE_MASK                      0x01
+#define SI2176_TUNER_STATUS_RESPONSE_MODE_ATV                          1
+#define SI2176_TUNER_STATUS_RESPONSE_MODE_DTV                          0
+
+#endif /* SI2176_TUNER_STATUS_CMD */
+
+/* SI2176_TUNER_TUNE_FREQ command definition */
+#define SI2176_TUNER_TUNE_FREQ_CMD                                                  0x41
+
+#ifdef    SI2176_TUNER_TUNE_FREQ_CMD
+
+typedef struct { /* SI2176_TUNER_TUNE_FREQ_CMD_struct */
+     unsigned char   mode;
+     unsigned long   freq;
+} si2176_tuner_tune_freq_cmd_struct;
+
+/* TUNER_TUNE_FREQ command, MODE field definition (size 1, lsb 0, unsigned) */
+#define  SI2176_TUNER_TUNE_FREQ_CMD_MODE_LSB                            0
+#define  SI2176_TUNER_TUNE_FREQ_CMD_MODE_MASK                         0x01
+#define  SI2176_TUNER_TUNE_FREQ_CMD_MODE_MIN                            0
+#define  SI2176_TUNER_TUNE_FREQ_CMD_MODE_MAX                           1
+#define SI2176_TUNER_TUNE_FREQ_CMD_MODE_ATV                             1
+#define SI2176_TUNER_TUNE_FREQ_CMD_MODE_DTV                             0
+/* TUNER_TUNE_FREQ command, FREQ field definition (size 32, lsb 0, unsigned) */
+#define  SI2176_TUNER_TUNE_FREQ_CMD_FREQ_LSB                             0
+#define  SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MASK                          0xffffffff
+#define  SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MIN                             43000000
+#define  SI2176_TUNER_TUNE_FREQ_CMD_FREQ_MAX                            1002000000
+#define SI2176_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MIN                  43000000
+#define SI2176_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MAX                 1002000000
+
+typedef struct { /* SI2176_TUNER_TUNE_FREQ_CMD_REPLY_struct */
+       si2176_common_reply_struct * status;
+}  si2176_tuner_tune_freq_cmd_reply_struct;
+
+#endif /* SI2176_TUNER_TUNE_FREQ_CMD */
+
+/* _commands_defines_insertion_point */
+
+/* _commands_struct_insertion_start */
+
+/* --------------------------------------------*/
+/* COMMANDS STRUCT                             */
+/* This is used to store all command fields    */
+/* --------------------------------------------*/
+typedef union { /* SI2176_CmdObj union */
+    #ifdef    SI2176_AGC_OVERRIDE_CMD
+              si2176_agc_override_cmd_struct               agc_override;
+    #endif /* SI2176_AGC_OVERRIDE_CMD */
+    #ifdef    SI2176_ATV_CW_TEST_CMD
+              si2176_atv_cw_test_cmd_struct                atv_cw_test;
+    #endif /* SI2176_ATV_CW_TEST_CMD */
+    #ifdef    SI2176_ATV_RESTART_CMD
+              si2176_atv_restart_cmd_struct                  atv_restart;
+    #endif /* SI2176_ATV_RESTART_CMD */
+    #ifdef    SI2176_ATV_STATUS_CMD
+              si2176_atv_status_cmd_struct                   atv_status;
+    #endif /* SI2176_ATV_STATUS_CMD */
+    #ifdef    SI2176_CONFIG_PINS_CMD
+              si2176_config_pins_cmd_struct                 config_pins;
+    #endif /* SI2176_CONFIG_PINS_CMD */
+    #ifdef    si2176_download_dataset_continue_cmd
+              si2176_download_dataset_continue_cmd_struct  download_dataset_continue;
+    #endif /* SI2176_DOWNLOAD_DATASET_CONTINUE_CMD */
+    #ifdef    SI2176_DOWNLOAD_DATASET_START_CMD
+              si2176_download_dataset_start_cmd_struct     download_dataset_start;
+    #endif /* SI2176_DOWNLOAD_DATASET_START_CMD */
+    #ifdef    SI2176_DTV_RESTART_CMD
+              si2176_dtv_restart_cmd_struct                dtv_restart;
+    #endif /* SI2176_DTV_RESTART_CMD */
+    #ifdef    SI2176_DTV_STATUS_CMD
+              si2176_dtv_status_cmd_struct                 dtv_status;
+    #endif /* SI2176_DTV_STATUS_CMD */
+    #ifdef    SI2176_EXIT_BOOTLOADER_CMD
+              si2176_exit_bootloader_cmd_struct         exit_bootloader;
+    #endif /* SI2176_EXIT_BOOTLOADER_CMD */
+    #ifdef    SI2176_FINE_TUNE_CMD
+              si2176_fine_tune_cmd_struct                   fine_tune;
+    #endif /* SI2176_FINE_TUNE_CMD */
+    #ifdef    SI2176_GET_PROPERTY_CMD
+              si2176_get_property_cmd_struct             get_property;
+    #endif /* SI2176_GET_PROPERTY_CMD */
+    #ifdef    SI2176_GET_REV_CMD
+              si2176_get_rev_cmd_struct                      get_rev;
+    #endif /* SI2176_GET_REV_CMD */
+    #ifdef    SI2176_PART_INFO_CMD
+              si2176_part_info_cmd_struct                    part_info;
+    #endif /* SI2176_PART_INFO_CMD */
+    #ifdef    SI2176_POWER_DOWN_CMD
+              si2176_power_down_cmd_struct              power_down;
+    #endif /* SI2176_POWER_DOWN_CMD */
+    #ifdef    SI2176_POWER_UP_CMD
+              si2176_power_up_cmd_struct                   power_up;
+    #endif /* SI2176_POWER_UP_CMD */
+    #ifdef    SI2176_SET_PROPERTY_CMD
+              si2176_set_property_cmd_struct               set_property;
+    #endif /* SI2176_SET_PROPERTY_CMD */
+    #ifdef    SI2176_STANDBY_CMD
+              si2176_standby_cmd_struct                      standby;
+    #endif /* SI2176_STANDBY_CMD */
+    #ifdef    SI2176_TUNER_STATUS_CMD
+              si2176_tuner_status_cmd_struct               tuner_status;
+    #endif /* SI2176_TUNER_STATUS_CMD */
+    #ifdef    SI2176_TUNER_TUNE_FREQ_CMD
+              si2176_tuner_tune_freq_cmd_struct          tuner_tune_freq;
+    #endif /* SI2176_TUNER_TUNE_FREQ_CMD */
+} si2176_cmdobj_t;
+/* _commands_struct_insertion_point */
+
+/* _commands_reply_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* COMMANDS REPLY STRUCT                       */
+  /* This stores all command reply fields        */
+  /* --------------------------------------------*/
+typedef struct { /* SI2176_CmdReplyObj struct */
+    #ifdef    SI2176_AGC_OVERRIDE_CMD
+              si2176_agc_override_cmd_reply_struct              agc_override;
+    #endif /* SI2176_AGC_OVERRIDE_CMD */
+    #ifdef    SI2176_ATV_CW_TEST_CMD
+              si2176_atv_cw_test_cmd_reply_struct                 atv_cw_test;
+    #endif /* SI2176_ATV_CW_TEST_CMD */
+    #ifdef    SI2176_ATV_RESTART_CMD
+              si2176_atv_restart_cmd_reply_struct                  atv_restart;
+    #endif /* SI2176_ATV_RESTART_CMD */
+    #ifdef    SI2176_ATV_STATUS_CMD
+              si2176_atv_status_cmd_reply_struct                   atv_status;
+    #endif /* SI2176_ATV_STATUS_CMD */
+    #ifdef    SI2176_CONFIG_PINS_CMD
+              si2176_config_pins_cmd_reply_struct                 config_pins;
+    #endif /* SI2176_CONFIG_PINS_CMD */
+    #ifdef    SI2176_DOWNLOAD_DATASET_CONTINUE_CMD
+              si2176_download_dataset_continue_cmd_reply_struct  download_dataset_continue;
+    #endif /* SI2176_DOWNLOAD_DATASET_CONTINUE_CMD */
+    #ifdef    SI2176_DOWNLOAD_DATASET_START_CMD
+              si2176_download_dataset_start_cmd_reply_struct        download_dataset_start;
+    #endif /* SI2176_DOWNLOAD_DATASET_START_CMD */
+    #ifdef    SI2176_EXIT_BOOTLOADER_CMD
+              si2176_exit_bootloader_cmd_reply_struct                     exit_bootloader;
+    #endif /* SI2176_EXIT_BOOTLOADER_CMD */
+    #ifdef    SI2176_FINE_TUNE_CMD
+              si2176_fine_tune_cmd_reply_struct                               fine_tune;
+    #endif /* SI2176_FINE_TUNE_CMD */
+    #ifdef    SI2176_GET_PROPERTY_CMD
+              si2176_get_property_cmd_reply_struct                         get_property;
+    #endif /* SI2176_GET_PROPERTY_CMD */
+    #ifdef    SI2176_GET_REV_CMD
+              si2176_get_rev_cmd_reply_struct                    get_rev;
+    #endif /* SI2176_GET_REV_CMD */
+    #ifdef    SI2176_PART_INFO_CMD
+              si2176_part_info_cmd_reply_struct                  part_info;
+    #endif /* SI2176_PART_INFO_CMD */
+    #ifdef    SI2176_POWER_DOWN_CMD
+              si2176_power_down_cmd_reply_struct           power_down;
+    #endif /* SI2176_POWER_DOWN_CMD */
+    #ifdef    SI2176_POWER_UP_CMD
+              si2176_power_up_cmd_reply_struct                power_up;
+    #endif /* SI2176_POWER_UP_CMD */
+    #ifdef    SI2176_SET_PROPERTY_CMD
+              si2176_set_property_cmd_reply_struct           set_property;
+    #endif /* SI2176_SET_PROPERTY_CMD */
+    #ifdef    SI2176_STANDBY_CMD
+              si2176_standby_cmd_reply_struct                  standby;
+    #endif /* SI2176_STANDBY_CMD */
+    #ifdef    SI2176_TUNER_STATUS_CMD
+              si2176_tuner_status_cmd_reply_struct           tuner_status;
+    #endif /* SI2176_TUNER_STATUS_CMD */
+    #ifdef    SI2176_TUNER_TUNE_FREQ_CMD
+              si2176_tuner_tune_freq_cmd_reply_struct      tuner_tune_freq;
+    #endif /* SI2176_TUNER_TUNE_FREQ_CMD */
+} si2176_cmdreplyobj_t;
+/* _commands_reply_struct_insertion_point */
+
+/* _properties_defines_insertion_start */
+/* SI2176 ATV_AFC_RANGE property definition */
+#define   SI2176_ATV_AFC_RANGE_PROP                                     0x0610
+
+#ifdef    SI2176_ATV_AFC_RANGE_PROP
+
+typedef struct { /* SI2176_ATV_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+} si2176_atv_afc_range_prop_struct;
+
+/* ATV_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+#define SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB             0
+#define SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK          0xffff
+#define SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT   1000
+#define SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_100_KHZ    100
+#define SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_500_KHZ    500
+#define SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_1000_KHZ  1000
+#define SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_1500_KHZ  1500
+#define SI2176_ATV_AFC_RANGE_PROP_RANGE_KHZ_2000_KHZ  2000
+
+#endif /* SI2176_ATV_AFC_RANGE_PROP */
+
+/* SI2176 ATV_AF_OUT property definition */
+#define   SI2176_ATV_AF_OUT_PROP                                           0x060b
+
+#ifdef    SI2176_ATV_AF_OUT_PROP
+
+typedef struct { /* SI2176_ATV_AF_OUT_PROP_struct */
+      unsigned char   volume;
+      unsigned char   soft_mute;
+} si2176_atv_af_out_prop_struct;
+
+/* ATV_AF_OUT property, VOLUME field definition (NO TITLE)*/
+#define  SI2176_ATV_AF_OUT_PROP_VOLUME_LSB                  0
+#define  SI2176_ATV_AF_OUT_PROP_VOLUME_MASK               0x3f
+#define  SI2176_ATV_AF_OUT_PROP_VOLUME_DEFAULT         0
+#define SI2176_ATV_AF_OUT_PROP_VOLUME_VOLUME_MIN   0
+#define SI2176_ATV_AF_OUT_PROP_VOLUME_VOLUME_MAX  63
+#define  SI2176_ATV_AF_OUT_PROP_SOFT_MUTE_LSB                8
+#define  SI2176_ATV_AF_OUT_PROP_SOFT_MUTE_MASK               0x1
+#define  SI2176_ATV_AF_OUT_PROP_SOFT_MUTE_DEFAULT            0
+
+#endif /* SI2176_ATV_AF_OUT_PROP */
+
+/* SI2176 ATV_AGC_SPEED property definition */
+#define   SI2176_ATV_AGC_SPEED_PROP                                   0x0611
+
+#ifdef    SI2176_ATV_AGC_SPEED_PROP
+
+typedef struct { /* SI2176_ATV_AGC_SPEED_PROP_struct */
+      unsigned char   if_agc_speed;
+} si2176_atv_agc_speed_prop_struct;
+
+/* ATV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define  SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB           0
+#define  SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+#define  SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT  0
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO          0
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_89               89
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_105             105
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_121             121
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_137             137
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_158             158
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_172             172
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_185             185
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_196             196
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_206             206
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_216             216
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_219             219
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_222             222
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_248             248
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_250             250
+#define SI2176_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_251             251
+
+#endif /* SI2176_ATV_AGC_SPEED_PROP */
+
+/* SI2176 ATV_AUDIO_MODE property definition */
+#define   SI2176_ATV_AUDIO_MODE_PROP                                            0x0602
+
+#ifdef    SI2176_ATV_AUDIO_MODE_PROP
+
+typedef struct { /* SI2176_ATV_AUDIO_MODE_PROP_struct */
+      unsigned char   audio_sys;
+      unsigned char   chan_bw;
+      unsigned char   demod_mode;
+} si2176_atv_audio_mode_prop_struct;
+
+/* ATV_AUDIO_MODE property, AUDIO_SYS field definition (NO TITLE)*/
+#define  SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB           0
+#define  SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK        0x0f
+#define  SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_DEFAULT  0
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_DEFAULT   0
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO        1
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO_NICAM  2
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2              3
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2_DK2     4
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2_DK3     5
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_BTSC         6
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_EIAJ           7
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_SCAN        8
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2_DK4     9
+#define SI2176_ATV_AUDIO_MODE_PROP_AUDIO_SYS_WIDE_SCAN   10
+
+/* ATV_AUDIO_MODE property, CHAN_BW field definition (NO TITLE)*/
+#define  SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB             8
+#define  SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK          0x0f
+#define  SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT    0
+#define SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT     0
+#define SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_4X_OVERMOD         1
+#define SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_8X_OVERMOD         2
+#define SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_12X_OVERMOD       3
+#define SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_7P5_KHZ_OFFSET  4
+#define SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_15_KHZ_OFFSET    5
+#define SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_30_KHZ_OFFSET    6
+#define SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_75_KHZ_OFFSET    7
+#define SI2176_ATV_AUDIO_MODE_PROP_CHAN_BW_150_KHZ_OFFSET  8
+
+/* ATV_AUDIO_MODE property, DEMOD_MODE field definition (NO TITLE)*/
+#define  SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB                  4
+#define  SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK               0x03
+#define  SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_DEFAULT         0
+#define SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_SIF                     0
+#define SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_AM                      1
+#define SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_FM1                    2
+#define SI2176_ATV_AUDIO_MODE_PROP_DEMOD_MODE_FM2                    3
+
+#endif /* SI2176_ATV_AUDIO_MODE_PROP */
+
+/* SI2176 ATV_CVBS_OUT property definition */
+#define   SI2176_ATV_CVBS_OUT_PROP                                      0x0609
+
+#ifdef    SI2176_ATV_CVBS_OUT_PROP
+
+typedef struct { /* SI2176_ATV_CVBS_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+} si2176_atv_cvbs_out_prop_struct;
+
+/* ATV_CVBS_OUT property, AMP field definition (NO TITLE)*/
+#define  SI2176_ATV_CVBS_OUT_PROP_AMP_LSB                   8
+#define  SI2176_ATV_CVBS_OUT_PROP_AMP_MASK                0xff
+#define  SI2176_ATV_CVBS_OUT_PROP_AMP_DEFAULT          200
+#define SI2176_ATV_CVBS_OUT_PROP_AMP_AMP_MIN           0
+#define SI2176_ATV_CVBS_OUT_PROP_AMP_AMP_MAX          255
+
+/* ATV_CVBS_OUT property, OFFSET field definition (NO TITLE)*/
+#define  SI2176_ATV_CVBS_OUT_PROP_OFFSET_LSB                0
+#define  SI2176_ATV_CVBS_OUT_PROP_OFFSET_MASK             0xff
+#define  SI2176_ATV_CVBS_OUT_PROP_OFFSET_DEFAULT       25
+#define SI2176_ATV_CVBS_OUT_PROP_OFFSET_OFFSET_MIN  0
+#define SI2176_ATV_CVBS_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* SI2176_ATV_CVBS_OUT_PROP */
+
+/* SI2176 ATV_CVBS_OUT_FINE property definition */
+#define   SI2176_ATV_CVBS_OUT_FINE_PROP                     0x0614
+
+#ifdef    SI2176_ATV_CVBS_OUT_FINE_PROP
+
+typedef struct { /* SI2176_ATV_CVBS_OUT_FINE_PROP_struct */
+      unsigned char   amp;
+                      char   offset;
+} si2176_atv_cvbs_out_fine_prop_struct;
+
+/* ATV_CVBS_OUT_FINE property, AMP field definition (NO TITLE)*/
+#define  SI2176_ATV_CVBS_OUT_FINE_PROP_AMP_LSB            8
+#define  SI2176_ATV_CVBS_OUT_FINE_PROP_AMP_MASK         0xff
+#define  SI2176_ATV_CVBS_OUT_FINE_PROP_AMP_DEFAULT   100
+#define SI2176_ATV_CVBS_OUT_FINE_PROP_AMP_AMP_MIN    25
+#define SI2176_ATV_CVBS_OUT_FINE_PROP_AMP_AMP_MAX   100
+
+/* ATV_CVBS_OUT_FINE property, OFFSET field definition (NO TITLE)*/
+#define  SI2176_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB                 0
+#define  SI2176_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK              0xff
+#define  SI2176_ATV_CVBS_OUT_FINE_PROP_OFFSET_DEFAULT        0
+#define SI2176_ATV_CVBS_OUT_FINE_PROP_OFFSET_OFFSET_MIN   -128
+#define SI2176_ATV_CVBS_OUT_FINE_PROP_OFFSET_OFFSET_MAX  127
+
+#endif /* SI2176_ATV_CVBS_OUT_FINE_PROP */
+
+/* SI2176 ATV_IEN property definition */
+#define   SI2176_ATV_IEN_PROP                                           0x0601
+
+#ifdef    SI2176_ATV_IEN_PROP
+
+typedef struct { /* SI2176_ATV_IEN_PROP_struct */
+      unsigned char   chlien;
+      unsigned char   dlien;
+      unsigned char   pclien;
+      unsigned char   snrhien;
+      unsigned char   snrlien;
+} si2176_atv_ien_prop_struct;
+
+/* ATV_IEN property, CHLIEN field definition (NO TITLE)*/
+#define  SI2176_ATV_IEN_PROP_CHLIEN_LSB                 0
+#define  SI2176_ATV_IEN_PROP_CHLIEN_MASK              0x01
+#define  SI2176_ATV_IEN_PROP_CHLIEN_DEFAULT        0
+#define SI2176_ATV_IEN_PROP_CHLIEN_DISABLE          0
+#define SI2176_ATV_IEN_PROP_CHLIEN_ENABLE           1
+
+/* ATV_IEN property, DLIEN field definition (NO TITLE)*/
+#define  SI2176_ATV_IEN_PROP_DLIEN_LSB                    2
+#define  SI2176_ATV_IEN_PROP_DLIEN_MASK                 0x01
+#define  SI2176_ATV_IEN_PROP_DLIEN_DEFAULT           0
+#define SI2176_ATV_IEN_PROP_DLIEN_DISABLE             0
+#define SI2176_ATV_IEN_PROP_DLIEN_ENABLE              1
+
+/* ATV_IEN property, PCLIEN field definition (NO TITLE)*/
+#define  SI2176_ATV_IEN_PROP_PCLIEN_LSB                  1
+#define  SI2176_ATV_IEN_PROP_PCLIEN_MASK               0x01
+#define  SI2176_ATV_IEN_PROP_PCLIEN_DEFAULT         0
+#define SI2176_ATV_IEN_PROP_PCLIEN_DISABLE           0
+#define SI2176_ATV_IEN_PROP_PCLIEN_ENABLE            1
+
+/* ATV_IEN property, SNRHIEN field definition (NO TITLE)*/
+#define  SI2176_ATV_IEN_PROP_SNRHIEN_LSB               4
+#define  SI2176_ATV_IEN_PROP_SNRHIEN_MASK            0x01
+#define  SI2176_ATV_IEN_PROP_SNRHIEN_DEFAULT      0
+#define SI2176_ATV_IEN_PROP_SNRHIEN_DISABLE        0
+#define SI2176_ATV_IEN_PROP_SNRHIEN_ENABLE         1
+
+/* ATV_IEN property, SNRLIEN field definition (NO TITLE)*/
+#define  SI2176_ATV_IEN_PROP_SNRLIEN_LSB                3
+#define  SI2176_ATV_IEN_PROP_SNRLIEN_MASK             0x01
+#define  SI2176_ATV_IEN_PROP_SNRLIEN_DEFAULT       0
+#define SI2176_ATV_IEN_PROP_SNRLIEN_DISABLE         0
+#define SI2176_ATV_IEN_PROP_SNRLIEN_ENABLE          1
+
+#endif /* SI2176_ATV_IEN_PROP */
+
+/* SI2176 ATV_INT_SENSE property definition */
+#define   SI2176_ATV_INT_SENSE_PROP                            0x0613
+
+#ifdef    SI2176_ATV_INT_SENSE_PROP
+
+typedef struct { /* SI2176_ATV_INT_SENSE_PROP_struct */
+      unsigned char   chlnegen;
+      unsigned char   chlposen;
+      unsigned char   dlnegen;
+      unsigned char   dlposen;
+      unsigned char   pclnegen;
+      unsigned char   pclposen;
+      unsigned char   snrhnegen;
+      unsigned char   snrhposen;
+      unsigned char   snrlnegen;
+      unsigned char   snrlposen;
+} si2176_atv_int_sense_prop_struct;
+
+/* ATV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_LSB             0
+#define  SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_MASK          0x01
+#define  SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+#define SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE      0
+#define SI2176_ATV_INT_SENSE_PROP_CHLNEGEN_ENABLE       1
+
+/* ATV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_LSB             8
+#define  SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_MASK          0x01
+#define  SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_DEFAULT   1
+#define SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_DISABLE     0
+#define SI2176_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE      1
+
+/* ATV_INT_SENSE property, DLNEGEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_DLNEGEN_LSB               2
+#define  SI2176_ATV_INT_SENSE_PROP_DLNEGEN_MASK            0x01
+#define  SI2176_ATV_INT_SENSE_PROP_DLNEGEN_DEFAULT     0
+#define SI2176_ATV_INT_SENSE_PROP_DLNEGEN_DISABLE       0
+#define SI2176_ATV_INT_SENSE_PROP_DLNEGEN_ENABLE        1
+
+/* ATV_INT_SENSE property, DLPOSEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_DLPOSEN_LSB              10
+#define  SI2176_ATV_INT_SENSE_PROP_DLPOSEN_MASK           0x01
+#define  SI2176_ATV_INT_SENSE_PROP_DLPOSEN_DEFAULT    1
+#define SI2176_ATV_INT_SENSE_PROP_DLPOSEN_DISABLE      0
+#define SI2176_ATV_INT_SENSE_PROP_DLPOSEN_ENABLE       1
+
+/* ATV_INT_SENSE property, PCLNEGEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_LSB           1
+#define  SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_MASK        0x01
+#define  SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_DEFAULT  0
+#define SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE    0
+#define SI2176_ATV_INT_SENSE_PROP_PCLNEGEN_ENABLE     1
+
+/* ATV_INT_SENSE property, PCLPOSEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_LSB             9
+#define  SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_MASK          0x01
+#define  SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_DEFAULT    1
+#define SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_DISABLE      0
+#define SI2176_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE       1
+
+/* ATV_INT_SENSE property, SNRHNEGEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB           4
+#define  SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK        0x01
+#define  SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_DEFAULT  0
+#define SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_DISABLE    0
+#define SI2176_ATV_INT_SENSE_PROP_SNRHNEGEN_ENABLE     1
+
+/* ATV_INT_SENSE property, SNRHPOSEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB            12
+#define  SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK         0x01
+#define  SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_DEFAULT   1
+#define SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_DISABLE     0
+#define SI2176_ATV_INT_SENSE_PROP_SNRHPOSEN_ENABLE      1
+
+/* ATV_INT_SENSE property, SNRLNEGEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB             3
+#define  SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK          0x01
+#define  SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_DEFAULT   0
+#define SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_DISABLE     0
+#define SI2176_ATV_INT_SENSE_PROP_SNRLNEGEN_ENABLE      1
+
+/* ATV_INT_SENSE property, SNRLPOSEN field definition (NO TITLE)*/
+#define  SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB            11
+#define  SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK         0x01
+#define  SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_DEFAULT   1
+#define SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_DISABLE     0
+#define SI2176_ATV_INT_SENSE_PROP_SNRLPOSEN_ENABLE      1
+
+#endif /* SI2176_ATV_INT_SENSE_PROP */
+
+/* SI2176 ATV_MIN_LVL_LOCK property definition */
+#define   SI2176_ATV_MIN_LVL_LOCK_PROP                                  0x060f
+
+#ifdef    SI2176_ATV_MIN_LVL_LOCK_PROP
+
+typedef struct { /* SI2176_ATV_MIN_LVL_LOCK_PROP_struct */
+      unsigned char   thrs;
+} si2176_atv_min_lvl_lock_prop_struct;
+
+/* ATV_MIN_LVL_LOCK property, THRS field definition (NO TITLE)*/
+#define  SI2176_ATV_MIN_LVL_LOCK_PROP_THRS_LSB              0
+#define  SI2176_ATV_MIN_LVL_LOCK_PROP_THRS_MASK           0xff
+#define  SI2176_ATV_MIN_LVL_LOCK_PROP_THRS_DEFAULT     34
+#endif /* SI2176_ATV_MIN_LVL_LOCK_PROP */
+
+/* SI2176 ATV_RF_TOP property definition */
+#define   SI2176_ATV_RF_TOP_PROP                                              0x0612
+
+#ifdef    SI2176_ATV_RF_TOP_PROP
+
+typedef struct { /* SI2176_ATV_RF_TOP_PROP_struct */
+      unsigned char   atv_rf_top;
+} si2176_atv_rf_top_prop_struct;
+
+/* ATV_RF_TOP property, ATV_RF_TOP field definition (NO TITLE)*/
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB              0
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK           0xff
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_DEFAULT     0
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO            0
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_0DB               6
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_M1DB            7
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_M2DB            8
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_M4DB            10
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_M5DB            11
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_M6DB            12
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_M7DB            13
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_M8DB            14
+#define SI2176_ATV_RF_TOP_PROP_ATV_RF_TOP_M9DB            15
+
+#endif /* SI2176_ATV_RF_TOP_PROP */
+
+/* SI2176 ATV_RSQ_RSSI_THRESHOLD property definition */
+#define   SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP                0x0605
+
+#ifdef    SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP
+
+typedef struct { /* SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_struct */
+               char   hi;
+               char   lo;
+} si2176_atv_rsq_rssi_threshold_prop_struct;
+
+/* ATV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+#define  SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB              8
+#define  SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK           0xff
+#define  SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT    0
+#define SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN         -128
+#define SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX        127
+
+/* ATV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+#define  SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB             0
+#define  SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK          0xff
+#define  SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT    -70
+#define SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN        -128
+#define SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX       127
+
+#endif /* SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP */
+
+/* SI2176 ATV_RSQ_SNR_THRESHOLD property definition */
+#define   SI2176_ATV_RSQ_SNR_THRESHOLD_PROP                           0x0606
+
+#ifdef    SI2176_ATV_RSQ_SNR_THRESHOLD_PROP
+
+typedef struct { /* SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_struct */
+      unsigned char   hi;
+      unsigned char   lo;
+} si2176_atv_rsq_snr_threshold_prop_struct;
+
+/* ATV_RSQ_SNR_THRESHOLD property, HI field definition (NO TITLE)*/
+#define  SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB            8
+#define  SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK         0xff
+#define  SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_HI_DEFAULT   45
+#define SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_HI_HI_MIN         0
+#define SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_HI_HI_MAX       255
+
+/* ATV_RSQ_SNR_THRESHOLD property, LO field definition (NO TITLE)*/
+#define  SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB           0
+#define  SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK        0xff
+#define  SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_LO_DEFAULT  25
+#define SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LO_MIN       0
+#define SI2176_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LO_MAX     255
+
+#endif /* SI2176_ATV_RSQ_SNR_THRESHOLD_PROP */
+
+/* SI2176 ATV_SIF_OUT property definition */
+#define   SI2176_ATV_SIF_OUT_PROP                                          0x060a
+
+#ifdef    SI2176_ATV_SIF_OUT_PROP
+
+typedef struct { /* SI2176_ATV_SIF_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+} si2176_atv_sif_out_prop_struct;
+
+/* ATV_SIF_OUT property, AMP field definition (NO TITLE)*/
+#define  SI2176_ATV_SIF_OUT_PROP_AMP_LSB                          8
+#define  SI2176_ATV_SIF_OUT_PROP_AMP_MASK                       0xff
+#define  SI2176_ATV_SIF_OUT_PROP_AMP_DEFAULT                 60
+#define SI2176_ATV_SIF_OUT_PROP_AMP_AMP_MIN                  0
+#define SI2176_ATV_SIF_OUT_PROP_AMP_AMP_MAX                 255
+
+/* ATV_SIF_OUT property, OFFSET field definition (NO TITLE)*/
+#define  SI2176_ATV_SIF_OUT_PROP_OFFSET_LSB                    0
+#define  SI2176_ATV_SIF_OUT_PROP_OFFSET_MASK                 0xff
+#define  SI2176_ATV_SIF_OUT_PROP_OFFSET_DEFAULT          135
+#define SI2176_ATV_SIF_OUT_PROP_OFFSET_OFFSET_MIN     0
+#define SI2176_ATV_SIF_OUT_PROP_OFFSET_OFFSET_MAX    255
+
+#endif /* SI2176_ATV_SIF_OUT_PROP */
+
+/* SI2176 ATV_SOUND_AGC_LIMIT property definition */
+#define   SI2176_ATV_SOUND_AGC_LIMIT_PROP                       0x0618
+
+#ifdef    SI2176_ATV_SOUND_AGC_LIMIT_PROP
+
+typedef struct { /* SI2176_ATV_SOUND_AGC_LIMIT_PROP_struct */
+               char   max_gain;
+               char   min_gain;
+} si2176_atv_sound_agc_limit_prop_struct;
+
+/* ATV_SOUND_AGC_LIMIT property, MAX_GAIN field definition (NO TITLE)*/
+#define  SI2176_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB                      0
+#define  SI2176_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK                  0xff
+#define  SI2176_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_DEFAULT            84
+#define SI2176_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MAX_GAIN_MIN  -84
+#define SI2176_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MAX_GAIN_MAX  84
+
+/* ATV_SOUND_AGC_LIMIT property, MIN_GAIN field definition (NO TITLE)*/
+#define  SI2176_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB                       8
+#define  SI2176_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK                    0xff
+#define  SI2176_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_DEFAULT              -84
+#define SI2176_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MIN_GAIN_MIN      -84
+#define SI2176_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MIN_GAIN_MAX     84
+
+#endif /* SI2176_ATV_SOUND_AGC_LIMIT_PROP */
+/* Si2176 ATV_SOUND_AGC_SPEED property definition */
+#define  Si2176_ATV_SOUND_AGC_SPEED_PROP 0x0619
+
+#ifdef   Si2176_ATV_SOUND_AGC_SPEED_PROP
+
+    typedef struct { /* Si2176_ATV_SOUND_AGC_SPEED_PROP_struct */
+      unsigned char   other_systems;
+      unsigned char   system_l;
+   } si2176_atv_sound_agc_speed_prop_struct;
+
+   /* ATV_SOUND_AGC_SPEED property, OTHER_SYSTEMS field definition (NO TITLE)*/
+   #define  Si2176_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB         8
+   #define  Si2176_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK        0xff
+   #define  Si2176_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_DEFAULT    4
+    #define Si2176_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_OTHER_SYSTEMS_MIN  0
+    #define Si2176_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_OTHER_SYSTEMS_MAX  15
+
+   /* ATV_SOUND_AGC_SPEED property, SYSTEM_L field definition (NO TITLE)*/
+   #define  Si2176_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB         0
+   #define  Si2176_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK        0xff
+   #define  Si2176_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_DEFAULT    5
+    #define Si2176_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_SYSTEM_L_MIN  0
+    #define Si2176_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_SYSTEM_L_MAX  15
+
+#endif /* Si2176_ATV_SOUND_AGC_SPEED_PROP */
+
+/* SI2176 ATV_VIDEO_EQUALIZER property definition */
+#define   SI2176_ATV_VIDEO_EQUALIZER_PROP                                       0x0608
+
+#ifdef    SI2176_ATV_VIDEO_EQUALIZER_PROP
+
+typedef struct { /* SI2176_ATV_VIDEO_EQUALIZER_PROP_struct */
+               char   slope;
+} si2176_atv_video_equalizer_prop_struct;
+
+/* ATV_VIDEO_EQUALIZER property, SLOPE field definition (NO TITLE)*/
+#define  SI2176_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB                 0
+#define  SI2176_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK              0xff
+#define  SI2176_ATV_VIDEO_EQUALIZER_PROP_SLOPE_DEFAULT       0
+#define SI2176_ATV_VIDEO_EQUALIZER_PROP_SLOPE_SLOPE_MIN    -8
+#define SI2176_ATV_VIDEO_EQUALIZER_PROP_SLOPE_SLOPE_MAX   7
+
+#endif /* SI2176_ATV_VIDEO_EQUALIZER_PROP */
+
+/* SI2176 ATV_VIDEO_MODE property definition */
+#define   SI2176_ATV_VIDEO_MODE_PROP                                                0x0604
+
+#ifdef    SI2176_ATV_VIDEO_MODE_PROP
+
+typedef struct { /* SI2176_ATV_VIDEO_MODE_PROP_struct */
+      unsigned char   color;
+      unsigned char   invert_signal;
+      unsigned char   trans;
+      unsigned char   video_sys;
+} si2176_atv_video_mode_prop_struct;
+
+/* ATV_VIDEO_MODE property, COLOR field definition (NO TITLE)*/
+#define  SI2176_ATV_VIDEO_MODE_PROP_COLOR_LSB                         4
+#define  SI2176_ATV_VIDEO_MODE_PROP_COLOR_MASK                      0x01
+#define  SI2176_ATV_VIDEO_MODE_PROP_COLOR_DEFAULT                0
+#define SI2176_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC               0
+#define SI2176_ATV_VIDEO_MODE_PROP_COLOR_SECAM                     1
+
+/* ATV_VIDEO_MODE property, INVERT_SIGNAL field definition (NO TITLE)*/
+#define  SI2176_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB          10
+#define  SI2176_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK       0x01
+#define  SI2176_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_DEFAULT  0
+#define SI2176_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_NORMAL     0
+#define SI2176_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_INVERTED  1
+
+/* ATV_VIDEO_MODE property, TRANS field definition (NO TITLE)*/
+#define  SI2176_ATV_VIDEO_MODE_PROP_TRANS_LSB                           8
+#define  SI2176_ATV_VIDEO_MODE_PROP_TRANS_MASK                        0x01
+#define  SI2176_ATV_VIDEO_MODE_PROP_TRANS_DEFAULT                 0
+#define SI2176_ATV_VIDEO_MODE_PROP_TRANS_TERRESTRIAL          0
+#define SI2176_ATV_VIDEO_MODE_PROP_TRANS_CABLE                       1
+
+/* ATV_VIDEO_MODE property, VIDEO_SYS field definition (NO TITLE)*/
+#define  SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB                   0
+#define  SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK                0x07
+#define  SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DEFAULT         0
+#define SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B                        0
+#define SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH                     1
+#define SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M                        2
+#define SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_N                        3
+#define SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I                         4
+#define SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK                     5
+#define SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_L                        6
+#define SI2176_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LP                      7
+
+#endif /* SI2176_ATV_VIDEO_MODE_PROP */
+
+/* SI2176 ATV_VSNR_CAP property definition */
+#define   SI2176_ATV_VSNR_CAP_PROP                                                  0x0616
+
+#ifdef    SI2176_ATV_VSNR_CAP_PROP
+
+typedef struct { /* SI2176_ATV_VSNR_CAP_PROP_struct */
+      unsigned char   atv_vsnr_cap;
+} si2176_atv_vsnr_cap_prop_struct;
+
+/* ATV_VSNR_CAP property, ATV_VSNR_CAP field definition (NO TITLE)*/
+#define  SI2176_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB                               0
+#define  SI2176_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK                            0xff
+#define  SI2176_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_DEFAULT                      0
+#define SI2176_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MIN   0
+#define SI2176_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MAX  127
+
+#endif /* SI2176_ATV_VSNR_CAP_PROP */
+
+/* SI2176 ATV_VSYNC_TRACKING property definition */
+#define   SI2176_ATV_VSYNC_TRACKING_PROP                                                        0x0615
+
+#ifdef    SI2176_ATV_VSYNC_TRACKING_PROP
+
+typedef struct { /* SI2176_ATV_VSYNC_TRACKING_PROP_struct */
+      unsigned char   min_fields_to_unlock;
+      unsigned char   min_pulses_to_lock;
+} si2176_atv_vsync_tracking_prop_struct;
+
+/* ATV_VSYNC_TRACKING property, MIN_FIELDS_TO_UNLOCK field definition (NO TITLE)*/
+#define  SI2176_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB            8
+#define  SI2176_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK         0xff
+#define  SI2176_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_DEFAULT   16
+#define SI2176_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MIN_FIELDS_TO_UNLOCK_MIN  0
+#define SI2176_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MIN_FIELDS_TO_UNLOCK_MAX  255
+
+/* ATV_VSYNC_TRACKING property, MIN_PULSES_TO_LOCK field definition (NO TITLE)*/
+#define  SI2176_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB                0
+#define  SI2176_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK             0xff
+#define  SI2176_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_DEFAULT      4
+#define SI2176_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MIN_PULSES_TO_LOCK_MIN   0
+#define SI2176_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MIN_PULSES_TO_LOCK_MAX  9
+
+#endif /* SI2176_ATV_VSYNC_TRACKING_PROP */
+
+
+/* SI2176 ATV_HSYNC_OUT property definition */
+#define   SI2176_ATV_HSYNC_OUT_PROP                                                        0x061e
+
+#ifdef    SI2176_ATV_HSYNC_OUT_PROP
+
+typedef struct { /* SI2176_ATV_HSYNC_OUT_PROP_struct */
+      unsigned char offset;
+      unsigned char width;
+      unsigned char gpio_sel;
+} si2176_atv_hsync_out_prop_struct;
+
+/* ATV_HSYNC_OUT property, offset field definition (NO TITLE)*/
+#define  SI2176_ATV_HSYNC_OUT_PROP_OFFSET_LSB	 8
+#define  SI2176_ATV_HSYNC_OUT_PROP_OFFSET_MASK		0xff
+#define  SI2176_ATV_HSYNC_OUT_PROP_OFFSET_DEFAULT		0
+#define  SI2176_ATV_HSYNC_OUT_PROP_OFFSET_MIN	-128
+#define  SI2176_ATV_HSYNC_OUT_PROP_OFFSET_MAX	127
+
+/* ATV_HSYNC_OUT property, width field definition (NO TITLE)*/
+#define  SI2176_ATV_HSYNC_OUT_PROP_WIDTH_LSB	2
+#define  SI2176_ATV_HSYNC_OUT_PROP_WIDTH_MASK	0x3f
+#define  SI2176_ATV_HSYNC_OUT_PROP_WIDTH_DEFAULT	42
+#define  SI2176_ATV_HSYNC_OUT_PROP_WIDTH_MIN	0
+#define  SI2176_ATV_HSYNC_OUT_PROP_WIDTH_MAX	51
+
+/* ATV_HSYNC_OUT property, gpio_sel field definition (NO TITLE)*/
+#define  SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_LSB		0
+#define  SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_MASK	0x03
+#define  SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_DEFAULT		0
+#define  SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_NONE	0
+#define  SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_GPIO1	1
+#define  SI2176_ATV_HSYNC_OUT_PROP_GPIO_SEL_GPIO2	2
+
+#endif /* SI2176_ATV_HSYNC_OUT_PROP */
+
+
+/* SI2176 CRYSTAL_TRIM property definition */
+#define   SI2176_CRYSTAL_TRIM_PROP                                        0x0402
+
+#ifdef    SI2176_CRYSTAL_TRIM_PROP
+
+typedef struct { /* SI2176_CRYSTAL_TRIM_PROP_struct */
+      unsigned char   xo_cap;
+} si2176_crystal_trim_prop_struct;
+
+/* CRYSTAL_TRIM property, XO_CAP field definition (NO TITLE)*/
+#define  SI2176_CRYSTAL_TRIM_PROP_XO_CAP_LSB                 0
+#define  SI2176_CRYSTAL_TRIM_PROP_XO_CAP_MASK              0x0f
+#define  SI2176_CRYSTAL_TRIM_PROP_XO_CAP_DEFAULT        8
+#define SI2176_CRYSTAL_TRIM_PROP_XO_CAP_XO_CAP_MIN   0
+#define SI2176_CRYSTAL_TRIM_PROP_XO_CAP_XO_CAP_MAX  15
+
+#endif /* SI2176_CRYSTAL_TRIM_PROP */
+
+/* SI2176 DTV_AGC_SPEED property definition */
+#define   SI2176_DTV_AGC_SPEED_PROP 0x0708
+
+#ifdef    SI2176_DTV_AGC_SPEED_PROP
+
+typedef struct { /* SI2176_DTV_AGC_SPEED_PROP_struct */
+      unsigned char   agc_decim;
+      unsigned char   if_agc_speed;
+} si2176_dtv_agc_speed_prop_struct;
+
+/* DTV_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+#define  SI2176_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB            8
+#define  SI2176_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK         0x03
+#define  SI2176_DTV_AGC_SPEED_PROP_AGC_DECIM_DEFAULT   0
+#define SI2176_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF             0
+#define SI2176_DTV_AGC_SPEED_PROP_AGC_DECIM_2                  1
+#define SI2176_DTV_AGC_SPEED_PROP_AGC_DECIM_4                  2
+#define SI2176_DTV_AGC_SPEED_PROP_AGC_DECIM_8                  3
+
+/* DTV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define  SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB             0
+#define  SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK          0xff
+#define  SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO            0
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39                  39
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_54                  54
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_63                  63
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_89                  89
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_105                105
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_121                121
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_137                137
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_158                158
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_172                172
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_185                185
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_196                196
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_206                206
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_216                216
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_219                219
+#define SI2176_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_222                222
+
+#endif /* SI2176_DTV_AGC_SPEED_PROP */
+
+/* SI2176 DTV_CONFIG_IF_PORT property definition */
+#define   SI2176_DTV_CONFIG_IF_PORT_PROP                                    0x0702
+
+#ifdef    SI2176_DTV_CONFIG_IF_PORT_PROP
+
+typedef struct { /* SI2176_DTV_CONFIG_IF_PORT_PROP_struct */
+      unsigned char   dtv_agc_source;
+      unsigned char   dtv_out_type;
+} si2176_dtv_config_if_port_prop_struct;
+
+/* DTV_CONFIG_IF_PORT property, DTV_AGC_SOURCE field definition (NO TITLE)*/
+#define  SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB                      8
+#define  SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK                   0x07
+#define  SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DEFAULT             0
+#define SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL            0
+#define SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DLIF_AGC_3DB    1
+#define SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DLIF_AGC_FULL  3
+
+/* DTV_CONFIG_IF_PORT property, DTV_OUT_TYPE field definition (NO TITLE)*/
+#define  SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB                            0
+#define  SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK                         0x0f
+#define  SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_DEFAULT                   0
+#define SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1                        0
+#define SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF2                        1
+#define SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF1A               4
+#define SI2176_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF2A               5
+
+#endif /* SI2176_DTV_CONFIG_IF_PORT_PROP */
+
+/* SI2176 DTV_EXT_AGC property definition */
+#define   SI2176_DTV_EXT_AGC_PROP 0x0705
+
+#ifdef    SI2176_DTV_EXT_AGC_PROP
+
+typedef struct { /* SI2176_DTV_EXT_AGC_PROP_struct */
+      unsigned char   max_10mv;
+      unsigned char   min_10mv;
+} si2176_dtv_ext_agc_prop_struct;
+
+/* DTV_EXT_AGC property, MAX_10MV field definition (NO TITLE)*/
+#define  SI2176_DTV_EXT_AGC_PROP_MAX_10MV_LSB                         8
+#define  SI2176_DTV_EXT_AGC_PROP_MAX_10MV_MASK                      0xff
+#define  SI2176_DTV_EXT_AGC_PROP_MAX_10MV_DEFAULT                250
+#define SI2176_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN      0
+#define SI2176_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX     255
+
+/* DTV_EXT_AGC property, MIN_10MV field definition (NO TITLE)*/
+#define  SI2176_DTV_EXT_AGC_PROP_MIN_10MV_LSB                          0
+#define  SI2176_DTV_EXT_AGC_PROP_MIN_10MV_MASK                       0xff
+#define  SI2176_DTV_EXT_AGC_PROP_MIN_10MV_DEFAULT                 50
+#define SI2176_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN        0
+#define SI2176_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX       255
+
+#endif /* SI2176_DTV_EXT_AGC_PROP */
+
+/* SI2176 DTV_IEN property definition */
+#define   SI2176_DTV_IEN_PROP 0x0701
+
+#ifdef    SI2176_DTV_IEN_PROP
+
+typedef struct { /* SI2176_DTV_IEN_PROP_struct */
+      unsigned char   chlien;
+} si2176_dtv_ien_prop_struct;
+
+/* DTV_IEN property, CHLIEN field definition (NO TITLE)*/
+#define  SI2176_DTV_IEN_PROP_CHLIEN_LSB                 0
+#define  SI2176_DTV_IEN_PROP_CHLIEN_MASK              0x01
+#define  SI2176_DTV_IEN_PROP_CHLIEN_DEFAULT        0
+#define SI2176_DTV_IEN_PROP_CHLIEN_DISABLE          0
+#define SI2176_DTV_IEN_PROP_CHLIEN_ENABLE           1
+
+#endif /* SI2176_DTV_IEN_PROP */
+
+/* SI2176 DTV_INT_SENSE property definition */
+#define   SI2176_DTV_INT_SENSE_PROP 0x070a
+
+#ifdef    SI2176_DTV_INT_SENSE_PROP
+
+typedef struct { /* SI2176_DTV_INT_SENSE_PROP_struct */
+      unsigned char   chlnegen;
+      unsigned char   chlposen;
+} si2176_dtv_int_sense_prop_struct;
+
+/* DTV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+#define  SI2176_DTV_INT_SENSE_PROP_CHLNEGEN_LSB             0
+#define  SI2176_DTV_INT_SENSE_PROP_CHLNEGEN_MASK          0x01
+#define  SI2176_DTV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+#define SI2176_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE      0
+#define SI2176_DTV_INT_SENSE_PROP_CHLNEGEN_ENABLE       1
+
+/* DTV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+#define  SI2176_DTV_INT_SENSE_PROP_CHLPOSEN_LSB             8
+#define  SI2176_DTV_INT_SENSE_PROP_CHLPOSEN_MASK          0x01
+#define  SI2176_DTV_INT_SENSE_PROP_CHLPOSEN_DEFAULT    1
+#define SI2176_DTV_INT_SENSE_PROP_CHLPOSEN_DISABLE      0
+#define SI2176_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE       1
+
+#endif /* SI2176_DTV_INT_SENSE_PROP */
+
+/* SI2176 DTV_LIF_FREQ property definition */
+#define   SI2176_DTV_LIF_FREQ_PROP 0x0706
+
+#ifdef    SI2176_DTV_LIF_FREQ_PROP
+
+typedef struct { /* SI2176_DTV_LIF_FREQ_PROP_struct */
+      unsigned int    offset;
+} si2176_dtv_lif_freq_prop_struct;
+
+/* DTV_LIF_FREQ property, OFFSET field definition (NO TITLE)*/
+#define  SI2176_DTV_LIF_FREQ_PROP_OFFSET_LSB                    0
+#define  SI2176_DTV_LIF_FREQ_PROP_OFFSET_MASK                 0xffff
+#define  SI2176_DTV_LIF_FREQ_PROP_OFFSET_DEFAULT           5000
+#define SI2176_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN      0
+#define SI2176_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX     7000
+
+#endif /* SI2176_DTV_LIF_FREQ_PROP */
+
+/* SI2176 DTV_LIF_OUT property definition */
+#define   SI2176_DTV_LIF_OUT_PROP 0x0707
+
+#ifdef    SI2176_DTV_LIF_OUT_PROP
+
+typedef struct { /* SI2176_DTV_LIF_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+} si2176_dtv_lif_out_prop_struct;
+
+/* DTV_LIF_OUT property, AMP field definition (NO TITLE)*/
+#define  SI2176_DTV_LIF_OUT_PROP_AMP_LSB                8
+#define  SI2176_DTV_LIF_OUT_PROP_AMP_MASK             0xff
+#define  SI2176_DTV_LIF_OUT_PROP_AMP_DEFAULT       27
+#define SI2176_DTV_LIF_OUT_PROP_AMP_AMP_MIN        0
+#define SI2176_DTV_LIF_OUT_PROP_AMP_AMP_MAX       255
+
+/* DTV_LIF_OUT property, OFFSET field definition (NO TITLE)*/
+#define  SI2176_DTV_LIF_OUT_PROP_OFFSET_LSB                 0
+#define  SI2176_DTV_LIF_OUT_PROP_OFFSET_MASK              0xff
+#define  SI2176_DTV_LIF_OUT_PROP_OFFSET_DEFAULT        148
+#define SI2176_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MIN   0
+#define SI2176_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* SI2176_DTV_LIF_OUT_PROP */
+
+/* SI2176 DTV_MODE property definition */
+#define   SI2176_DTV_MODE_PROP 0x0703
+
+#ifdef    SI2176_DTV_MODE_PROP
+
+typedef struct { /* SI2176_DTV_MODE_PROP_struct */
+      unsigned char   bw;
+      unsigned char   invert_spectrum;
+      unsigned char   modulation;
+} si2176_dtv_mode_prop_struct;
+
+/* DTV_MODE property, BW field definition (NO TITLE)*/
+#define  SI2176_DTV_MODE_PROP_BW_LSB                      0
+#define  SI2176_DTV_MODE_PROP_BW_MASK                   0x0f
+#define  SI2176_DTV_MODE_PROP_BW_DEFAULT             8
+#define SI2176_DTV_MODE_PROP_BW_BW_6MHZ             6
+#define SI2176_DTV_MODE_PROP_BW_BW_7MHZ             7
+#define SI2176_DTV_MODE_PROP_BW_BW_8MHZ             8
+
+/* DTV_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+#define  SI2176_DTV_MODE_PROP_INVERT_SPECTRUM_LSB            8
+#define  SI2176_DTV_MODE_PROP_INVERT_SPECTRUM_MASK         0x01
+#define  SI2176_DTV_MODE_PROP_INVERT_SPECTRUM_DEFAULT   0
+#define SI2176_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL     0
+#define SI2176_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+/* DTV_MODE property, MODULATION field definition (NO TITLE)*/
+#define  SI2176_DTV_MODE_PROP_MODULATION_LSB            4
+#define  SI2176_DTV_MODE_PROP_MODULATION_MASK         0x0f
+#define  SI2176_DTV_MODE_PROP_MODULATION_DEFAULT   2
+#define SI2176_DTV_MODE_PROP_MODULATION_ATSC           0
+#define SI2176_DTV_MODE_PROP_MODULATION_QAM_US      1
+#define SI2176_DTV_MODE_PROP_MODULATION_DVBT           2
+#define SI2176_DTV_MODE_PROP_MODULATION_DVBC           3
+#define SI2176_DTV_MODE_PROP_MODULATION_ISDBT          4
+#define SI2176_DTV_MODE_PROP_MODULATION_ISDBC          5
+#define SI2176_DTV_MODE_PROP_MODULATION_DTMB           6
+
+#endif /* SI2176_DTV_MODE_PROP */
+
+/* SI2176 DTV_RF_TOP property definition */
+#define   SI2176_DTV_RF_TOP_PROP 0x0709
+
+#ifdef    SI2176_DTV_RF_TOP_PROP
+
+typedef struct { /* SI2176_DTV_RF_TOP_PROP_struct */
+      unsigned char   dtv_rf_top;
+} si2176_dtv_rf_top_prop_struct;
+
+/* DTV_RF_TOP property, DTV_RF_TOP field definition (NO TITLE)*/
+#define  SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB            0
+#define  SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK         0xff
+#define  SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_DEFAULT   0
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO           0
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_0DB              6
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_M1DB           7
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_M2DB           8
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_M4DB          10
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_M5DB          11
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_M6DB          12
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_M7DB          13
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_M8DB          14
+#define SI2176_DTV_RF_TOP_PROP_DTV_RF_TOP_M9DB          15
+
+#endif /* SI2176_DTV_RF_TOP_PROP */
+
+/* SI2176 DTV_RSQ_RSSI_THRESHOLD property definition */
+#define   SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP 0x0704
+
+#ifdef    SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP
+
+typedef struct { /* SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_struct */
+               char   hi;
+               char   lo;
+} si2176_dtv_rsq_rssi_threshold_prop_struct;
+
+/* DTV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+#define  SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB              8
+#define  SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK           0xff
+#define  SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT     0
+#define SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN          -128
+#define SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX        127
+
+/* DTV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+#define  SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB            0
+#define  SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK         0xff
+#define  SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT   -80
+#define SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN       -128
+#define SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX      127
+
+#endif /* SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP */
+
+/* SI2176 MASTER_IEN property definition */
+#define   SI2176_MASTER_IEN_PROP                                    0x0401
+
+#ifdef    SI2176_MASTER_IEN_PROP
+
+typedef struct { /* SI2176_MASTER_IEN_PROP_struct */
+      unsigned char   atvien;
+      unsigned char   ctsien;
+      unsigned char   dtvien;
+      unsigned char   errien;
+      unsigned char   tunien;
+} si2176_master_ien_prop_struct;
+
+/* MASTER_IEN property, ATVIEN field definition (NO TITLE)*/
+#define  SI2176_MASTER_IEN_PROP_ATVIEN_LSB            1
+#define  SI2176_MASTER_IEN_PROP_ATVIEN_MASK         0x01
+#define  SI2176_MASTER_IEN_PROP_ATVIEN_DEFAULT   0
+#define SI2176_MASTER_IEN_PROP_ATVIEN_OFF             0
+#define SI2176_MASTER_IEN_PROP_ATVIEN_ON               1
+
+/* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+#define  SI2176_MASTER_IEN_PROP_CTSIEN_LSB            7
+#define  SI2176_MASTER_IEN_PROP_CTSIEN_MASK         0x01
+#define  SI2176_MASTER_IEN_PROP_CTSIEN_DEFAULT   0
+#define SI2176_MASTER_IEN_PROP_CTSIEN_OFF             0
+#define SI2176_MASTER_IEN_PROP_CTSIEN_ON               1
+
+/* MASTER_IEN property, DTVIEN field definition (NO TITLE)*/
+#define  SI2176_MASTER_IEN_PROP_DTVIEN_LSB            2
+#define  SI2176_MASTER_IEN_PROP_DTVIEN_MASK         0x01
+#define  SI2176_MASTER_IEN_PROP_DTVIEN_DEFAULT   0
+#define SI2176_MASTER_IEN_PROP_DTVIEN_OFF             0
+#define SI2176_MASTER_IEN_PROP_DTVIEN_ON               1
+
+/* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+#define  SI2176_MASTER_IEN_PROP_ERRIEN_LSB             6
+#define  SI2176_MASTER_IEN_PROP_ERRIEN_MASK          0x01
+#define  SI2176_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+#define SI2176_MASTER_IEN_PROP_ERRIEN_OFF              0
+#define SI2176_MASTER_IEN_PROP_ERRIEN_ON                1
+
+/* MASTER_IEN property, TUNIEN field definition (NO TITLE)*/
+#define  SI2176_MASTER_IEN_PROP_TUNIEN_LSB             0
+#define  SI2176_MASTER_IEN_PROP_TUNIEN_MASK          0x01
+#define  SI2176_MASTER_IEN_PROP_TUNIEN_DEFAULT    0
+#define SI2176_MASTER_IEN_PROP_TUNIEN_OFF               0
+#define SI2176_MASTER_IEN_PROP_TUNIEN_ON                1
+
+#endif /* SI2176_MASTER_IEN_PROP */
+
+/* SI2176 TUNER_BLOCKED_VCO property definition */
+#define   SI2176_TUNER_BLOCKED_VCO_PROP                         0x0504
+
+#ifdef    SI2176_TUNER_BLOCKED_VCO_PROP
+
+typedef struct { /* SI2176_TUNER_BLOCKED_VCO_PROP_struct */
+               int    vco_code;
+} si2176_tuner_blocked_vco_prop_struct;
+
+/* TUNER_BLOCKED_VCO property, VCO_CODE field definition (NO TITLE)*/
+#define  SI2176_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB             0
+#define  SI2176_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK          0xffff
+#define  SI2176_TUNER_BLOCKED_VCO_PROP_VCO_CODE_DEFAULT    0x8000
+#endif /* SI2176_TUNER_BLOCKED_VCO_PROP */
+
+/* SI2176 TUNER_IEN property definition */
+#define   SI2176_TUNER_IEN_PROP                                     0x0501
+
+#ifdef    SI2176_TUNER_IEN_PROP
+
+typedef struct { /* SI2176_TUNER_IEN_PROP_struct */
+      unsigned char   rssihien;
+      unsigned char   rssilien;
+      unsigned char   tcien;
+} si2176_tuner_ien_prop_struct;
+
+/* TUNER_IEN property, RSSIHIEN field definition (NO TITLE)*/
+#define  SI2176_TUNER_IEN_PROP_RSSIHIEN_LSB             2
+#define  SI2176_TUNER_IEN_PROP_RSSIHIEN_MASK          0x01
+#define  SI2176_TUNER_IEN_PROP_RSSIHIEN_DEFAULT    0
+#define SI2176_TUNER_IEN_PROP_RSSIHIEN_DISABLE      0
+#define SI2176_TUNER_IEN_PROP_RSSIHIEN_ENABLE       1
+
+/* TUNER_IEN property, RSSILIEN field definition (NO TITLE)*/
+#define  SI2176_TUNER_IEN_PROP_RSSILIEN_LSB             1
+#define  SI2176_TUNER_IEN_PROP_RSSILIEN_MASK          0x01
+#define  SI2176_TUNER_IEN_PROP_RSSILIEN_DEFAULT    0
+#define SI2176_TUNER_IEN_PROP_RSSILIEN_DISABLE      0
+#define SI2176_TUNER_IEN_PROP_RSSILIEN_ENABLE       1
+
+/* TUNER_IEN property, TCIEN field definition (NO TITLE)*/
+#define  SI2176_TUNER_IEN_PROP_TCIEN_LSB                    0
+#define  SI2176_TUNER_IEN_PROP_TCIEN_MASK                 0x01
+#define  SI2176_TUNER_IEN_PROP_TCIEN_DEFAULT           0
+#define SI2176_TUNER_IEN_PROP_TCIEN_DISABLE             0
+#define SI2176_TUNER_IEN_PROP_TCIEN_ENABLE              1
+
+#endif /* SI2176_TUNER_IEN_PROP */
+
+/* SI2176 TUNER_INT_SENSE property definition */
+#define   SI2176_TUNER_INT_SENSE_PROP                          0x0505
+
+#ifdef    SI2176_TUNER_INT_SENSE_PROP
+
+typedef struct { /* SI2176_TUNER_INT_SENSE_PROP_struct */
+      unsigned char   rssihnegen;
+      unsigned char   rssihposen;
+      unsigned char   rssilnegen;
+      unsigned char   rssilposen;
+      unsigned char   tcnegen;
+      unsigned char   tcposen;
+} si2176_tuner_int_sense_prop_struct;
+
+/* TUNER_INT_SENSE property, RSSIHNEGEN field definition (NO TITLE)*/
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB             2
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK          0x01
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DEFAULT    0
+#define SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE      0
+#define SI2176_TUNER_INT_SENSE_PROP_RSSIHNEGEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, RSSIHPOSEN field definition (NO TITLE)*/
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB             10
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK          0x01
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DEFAULT    1
+#define SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DISABLE      0
+#define SI2176_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, RSSILNEGEN field definition (NO TITLE)*/
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB             1
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK          0x01
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_DEFAULT    0
+#define SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE      0
+#define SI2176_TUNER_INT_SENSE_PROP_RSSILNEGEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, RSSILPOSEN field definition (NO TITLE)*/
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB             9
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK          0x01
+#define  SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_DEFAULT    1
+#define SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_DISABLE      0
+#define SI2176_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, TCNEGEN field definition (NO TITLE)*/
+#define  SI2176_TUNER_INT_SENSE_PROP_TCNEGEN_LSB                   0
+#define  SI2176_TUNER_INT_SENSE_PROP_TCNEGEN_MASK               0x01
+#define  SI2176_TUNER_INT_SENSE_PROP_TCNEGEN_DEFAULT         0
+#define SI2176_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE           0
+#define SI2176_TUNER_INT_SENSE_PROP_TCNEGEN_ENABLE            1
+
+/* TUNER_INT_SENSE property, TCPOSEN field definition (NO TITLE)*/
+#define  SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_LSB                  8
+#define  SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_MASK               0x01
+#define  SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_DEFAULT         1
+#define SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_DISABLE           0
+#define SI2176_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE            1
+
+#endif /* SI2176_TUNER_INT_SENSE_PROP */
+
+/* SI2176 TUNER_LO_INJECTION property definition */
+#define   SI2176_TUNER_LO_INJECTION_PROP                                    0x0506
+
+#ifdef    SI2176_TUNER_LO_INJECTION_PROP
+
+typedef struct { /* SI2176_TUNER_LO_INJECTION_PROP_struct */
+      unsigned char   band_1;
+      unsigned char   band_2;
+      unsigned char   band_3;
+      unsigned char   band_4;
+      unsigned char   band_5;
+} si2176_tuner_lo_injection_prop_struct;
+
+/* TUNER_LO_INJECTION property, BAND_1 field definition (NO TITLE)*/
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_1_LSB              0
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_1_MASK           0x01
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_1_DEFAULT    1
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_1_LOW_SIDE   0
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_2 field definition (NO TITLE)*/
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_2_LSB              1
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_2_MASK           0x01
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_2_DEFAULT    0
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE   0
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_2_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_3 field definition (NO TITLE)*/
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_3_LSB              2
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_3_MASK           0x01
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_3_DEFAULT    0
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE   0
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_3_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_4 field definition (NO TITLE)*/
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_4_LSB              3
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_4_MASK          0x01
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_4_DEFAULT    0
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_4_LOW_SIDE   0
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_4_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_5 field definition (NO TITLE)*/
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_5_LSB             4
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_5_MASK          0x01
+#define  SI2176_TUNER_LO_INJECTION_PROP_BAND_5_DEFAULT    0
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_5_LOW_SIDE   0
+#define SI2176_TUNER_LO_INJECTION_PROP_BAND_5_HIGH_SIDE  1
+
+#endif /* SI2176_TUNER_LO_INJECTION_PROP */
+
+/* _properties_defines_insertion_point */
+
+/* _properties_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* PROPERTIES STRUCT                           */
+  /* This stores all property fields             */
+  /* --------------------------------------------*/
+  typedef struct {
+    #ifdef    SI2176_ATV_AFC_RANGE_PROP
+              si2176_atv_afc_range_prop_struct               atv_afc_range;
+    #endif /* SI2176_ATV_AFC_RANGE_PROP */
+    #ifdef    SI2176_ATV_AF_OUT_PROP
+              si2176_atv_af_out_prop_struct                     atv_af_out;
+    #endif /* SI2176_ATV_AF_OUT_PROP */
+    #ifdef    SI2176_ATV_AGC_SPEED_PROP
+              si2176_atv_agc_speed_prop_struct             atv_agc_speed;
+    #endif /* SI2176_ATV_AGC_SPEED_PROP */
+    #ifdef    SI2176_ATV_AUDIO_MODE_PROP
+              si2176_atv_audio_mode_prop_struct           atv_audio_mode;
+    #endif /* SI2176_ATV_AUDIO_MODE_PROP */
+    #ifdef    SI2176_ATV_CVBS_OUT_PROP
+              si2176_atv_cvbs_out_prop_struct                atv_cvbs_out;
+    #endif /* SI2176_ATV_CVBS_OUT_PROP */
+    #ifdef    SI2176_ATV_CVBS_OUT_FINE_PROP
+              si2176_atv_cvbs_out_fine_prop_struct        atv_cvbs_out_fine;
+    #endif /* SI2176_ATV_CVBS_OUT_FINE_PROP */
+    #ifdef    SI2176_ATV_IEN_PROP
+              si2176_atv_ien_prop_struct                         atv_ien;
+    #endif /* SI2176_ATV_IEN_PROP */
+    #ifdef    SI2176_ATV_INT_SENSE_PROP
+              si2176_atv_int_sense_prop_struct              atv_int_sense;
+    #endif /* SI2176_ATV_INT_SENSE_PROP */
+    #ifdef    SI2176_ATV_MIN_LVL_LOCK_PROP
+              si2176_atv_min_lvl_lock_prop_struct          atv_min_lvl_lock;
+    #endif /* SI2176_ATV_MIN_LVL_LOCK_PROP */
+    #ifdef    SI2176_ATV_RF_TOP_PROP
+              si2176_atv_rf_top_prop_struct                    atv_rf_top;
+    #endif /* SI2176_ATV_RF_TOP_PROP */
+    #ifdef    SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP
+              si2176_atv_rsq_rssi_threshold_prop_struct  atv_rsq_rssi_threshold;
+    #endif /* SI2176_ATV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef    SI2176_ATV_RSQ_SNR_THRESHOLD_PROP
+              si2176_atv_rsq_snr_threshold_prop_struct   atv_rsq_snr_threshold;
+    #endif /* SI2176_ATV_RSQ_SNR_THRESHOLD_PROP */
+    #ifdef    SI2176_ATV_SIF_OUT_PROP
+              si2176_atv_sif_out_prop_struct                    atv_sif_out;
+    #endif /* SI2176_ATV_SIF_OUT_PROP */
+    #ifdef    Si2176_ATV_SOUND_AGC_SPEED_PROP
+              si2176_atv_sound_agc_speed_prop_struct   atv_sound_agc;
+    #endif /*Si2176_ATV_SOUND_AGC_SPEED_PROP*/
+    #ifdef    SI2176_ATV_SOUND_AGC_LIMIT_PROP
+              si2176_atv_sound_agc_limit_prop_struct     atv_sound_agc_limit;
+    #endif /* SI2176_ATV_SOUND_AGC_LIMIT_PROP */
+    #ifdef    SI2176_ATV_VIDEO_EQUALIZER_PROP
+              si2176_atv_video_equalizer_prop_struct     atv_video_equalizer;
+    #endif /* SI2176_ATV_VIDEO_EQUALIZER_PROP */
+    #ifdef    SI2176_ATV_VIDEO_MODE_PROP
+              si2176_atv_video_mode_prop_struct           atv_video_mode;
+    #endif /* SI2176_ATV_VIDEO_MODE_PROP */
+    #ifdef    SI2176_ATV_VSNR_CAP_PROP
+              si2176_atv_vsnr_cap_prop_struct                atv_vsnr_cap;
+    #endif /* SI2176_ATV_VSNR_CAP_PROP */
+    #ifdef    SI2176_ATV_VSYNC_TRACKING_PROP
+              si2176_atv_vsync_tracking_prop_struct      atv_vsync_tracking;
+    #endif /* SI2176_ATV_VSYNC_TRACKING_PROP */
+	#ifdef    SI2176_ATV_HSYNC_OUT_PROP
+              si2176_atv_hsync_out_prop_struct      atv_hsync_out;
+    #endif /* SI2176_ATV_HSYNC_OUT_PROP */
+    #ifdef    SI2176_CRYSTAL_TRIM_PROP
+              si2176_crystal_trim_prop_struct                  crystal_trim;
+    #endif /* SI2176_CRYSTAL_TRIM_PROP */
+    #ifdef    SI2176_DTV_AGC_SPEED_PROP
+              si2176_dtv_agc_speed_prop_struct            dtv_agc_speed;
+    #endif /* SI2176_DTV_AGC_SPEED_PROP */
+    #ifdef    SI2176_DTV_CONFIG_IF_PORT_PROP
+              si2176_dtv_config_if_port_prop_struct        dtv_config_if_port;
+    #endif /* SI2176_DTV_CONFIG_IF_PORT_PROP */
+    #ifdef    SI2176_DTV_EXT_AGC_PROP
+              si2176_dtv_ext_agc_prop_struct                 dtv_ext_agc;
+    #endif /* SI2176_DTV_EXT_AGC_PROP */
+    #ifdef    SI2176_DTV_IEN_PROP
+              si2176_dtv_ien_prop_struct                        dtv_ien;
+    #endif /* SI2176_DTV_IEN_PROP */
+    #ifdef    SI2176_DTV_INT_SENSE_PROP
+              si2176_dtv_int_sense_prop_struct              dtv_int_sense;
+    #endif /* SI2176_DTV_INT_SENSE_PROP */
+    #ifdef    SI2176_DTV_LIF_FREQ_PROP
+              si2176_dtv_lif_freq_prop_struct                   dtv_lif_freq;
+    #endif /* SI2176_DTV_LIF_FREQ_PROP */
+    #ifdef    SI2176_DTV_LIF_OUT_PROP
+              si2176_dtv_lif_out_prop_struct                    dtv_lif_out;
+    #endif /* SI2176_DTV_LIF_OUT_PROP */
+    #ifdef    SI2176_DTV_MODE_PROP
+              si2176_dtv_mode_prop_struct                     dtv_mode;
+    #endif /* SI2176_DTV_MODE_PROP */
+    #ifdef    SI2176_DTV_RF_TOP_PROP
+              si2176_dtv_rf_top_prop_struct                     dtv_rf_top;
+    #endif /* SI2176_DTV_RF_TOP_PROP */
+    #ifdef    SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP
+              si2176_dtv_rsq_rssi_threshold_prop_struct  dtv_rsq_rssi_threshold;
+    #endif /* SI2176_DTV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef    SI2176_MASTER_IEN_PROP
+              si2176_master_ien_prop_struct                    master_ien;
+    #endif /* SI2176_MASTER_IEN_PROP */
+    #ifdef    SI2176_TUNER_BLOCKED_VCO_PROP
+              si2176_tuner_blocked_vco_prop_struct       tuner_blocked_vco;
+    #endif /* SI2176_TUNER_BLOCKED_VCO_PROP */
+    #ifdef    SI2176_TUNER_IEN_PROP
+              si2176_tuner_ien_prop_struct                      tuner_ien;
+    #endif /* SI2176_TUNER_IEN_PROP */
+    #ifdef    SI2176_TUNER_INT_SENSE_PROP
+              si2176_tuner_int_sense_prop_struct            tuner_int_sense;
+    #endif /* SI2176_TUNER_INT_SENSE_PROP */
+    #ifdef    SI2176_TUNER_LO_INJECTION_PROP
+              si2176_tuner_lo_injection_prop_struct         tuner_lo_injection;
+    #endif /* SI2176_TUNER_LO_INJECTION_PROP */
+} si2176_propobj_t;
+/* _properties_struct_insertion_point */
+
+typedef struct si2176_device_s{
+    struct class *clsp;
+    struct i2c_client tuner_client;
+    si2176_common_reply_struct si_common_reply;
+    si2176_propobj_t     si_prop;
+    si2176_cmdreplyobj_t si_cmd_reply;
+    struct analog_parameters parm;
+    int fre_offset;
+}si2176_device_t;
+
+int si2176_init(struct i2c_client *si2176, si2176_cmdreplyobj_t *rsp, si2176_common_reply_struct *common_reply);
+//int si2176_powerupwithpatch(struct i2c_client *si2176, si2176_cmdreplyobj_t *rsp, si2176_common_reply_struct *common_reply);
+//int si2176_loadfirmware(struct i2c_client *si2176, unsigned char* firmwaretable, int lines, si2176_common_reply_struct *common_reply);
+//int si2176_startfirmware(struct i2c_client *si2176, si2176_cmdreplyobj_t *rsp, si2176_common_reply_struct *common_reply);
+int si2176_configure(struct i2c_client *si2176, si2176_propobj_t *prop, si2176_cmdreplyobj_t *rsp, si2176_common_reply_struct *common_reply);
+unsigned char si2176_config_pins(struct i2c_client *si2176,
+                unsigned char   gpio1_mode,
+                unsigned char   gpio1_read,
+                unsigned char   gpio2_mode,
+                unsigned char   gpio2_read,
+                unsigned char   gpio3_mode,
+                unsigned char   gpio3_read,
+                unsigned char   bclk1_mode,
+                unsigned char   bclk1_read,
+                unsigned char   xout_mode,
+                si2176_cmdreplyobj_t *rsp);
+
+
+//int si2176_loadvideofilter(struct i2c_client *si2176, unsigned char* vidfilttable, int lines, si2176_common_reply_struct *common_reply);
+int si2176_tune(struct i2c_client *si2176, unsigned char mode, unsigned long freq, si2176_cmdreplyobj_t *rsp, si2176_common_reply_struct *common_reply);
+int si2176_atvconfig(struct i2c_client *si2176, si2176_propobj_t *prop, si2176_cmdreplyobj_t *rsp);
+int si2176_dtvconfig(struct i2c_client *si2176, si2176_propobj_t *prop, si2176_cmdreplyobj_t *rsp);
+//int si2176_tunerconfig(struct i2c_client *si2176, si2176_propobj_t *prop, si2176_cmdreplyobj_t *rsp);
+//int si2176_setuptunerdefaults(si2176_propobj_t *prop);
+//int si2176_setupcommondefaults(si2176_propobj_t *prop);
+//int si2176_setupatvdefaults(si2176_propobj_t *prop);
+unsigned char si2176_atv_status(struct i2c_client *si2176, unsigned char intack, si2176_cmdreplyobj_t *rsp);
+unsigned char si2176_tuner_status(struct i2c_client *si2176, unsigned char intack, si2176_cmdreplyobj_t *rsp);
+unsigned char si2176_power_down(struct i2c_client *si2176, si2176_cmdreplyobj_t *rsp);
+unsigned char si2176_fine_tune(struct i2c_client *si2176, unsigned char reserved,int offset_500hz, si2176_cmdreplyobj_t *rsp);
+unsigned char si2176_atv_restart(struct i2c_client *si2176, unsigned char   mode,  si2176_cmdreplyobj_t *rsp);
+unsigned char si2176_dtv_restart(struct i2c_client *si2176, si2176_cmdreplyobj_t *rsp);
+unsigned char si2176_set_property(struct i2c_client *si2176,unsigned char   reserved, unsigned int prop, unsigned int data,  si2176_cmdreplyobj_t *rsp);
+unsigned char si2176_get_property(struct i2c_client *si2176, unsigned char   reserved,unsigned int  prop, si2176_cmdreplyobj_t *rsp);
+#endif /* __SLI2176_FUN_H */
diff --git a/drivers/amlogic/dvb_tv/si2177/Makefile b/drivers/amlogic/dvb_tv/si2177/Makefile
new file mode 100755
index 000000000000..f5d15f1996cc
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2177/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_AM_SI2177) += si2177_fe.o
+
+si2177_fe-objs =si2177_func.o si2177_frontend.o
+
diff --git a/drivers/amlogic/dvb_tv/si2177/si2177_frontend.c b/drivers/amlogic/dvb_tv/si2177/si2177_frontend.c
new file mode 100755
index 000000000000..cc51779e7547
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2177/si2177_frontend.c
@@ -0,0 +1,995 @@
+/*
+ * Silicon labs si2177 Tuner Device Driver
+ *
+ * Author: Bobby Yang <bo.yang@amlogic.com>
+ *
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/* Standard Liniux Headers */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <uapi/linux/dvb/frontend.h>
+//#include <mach/gpio_data.h>
+#include<mach/gpio.h>
+
+/* Amlogic Headers */
+
+/* Local Headers */
+#include "si2177_func.h"
+#ifdef CONFIG_AM_ATBM8869
+#include "../atbm887x/atbm886x.h"
+#endif
+
+#define SI2177_TUNER_I2C_NAME           "si2177_tuner_i2c"
+#define TUNER_DEVICE_NAME                "si2177"
+#ifndef ERROR
+#define ERROR                           1
+#endif
+#define CVD_SI2177_RSSI
+static int si2177_debug = 1;
+module_param(si2177_debug, int, 0644);
+MODULE_PARM_DESC(si2177_debug, "\n si2177_debug \n");
+
+static unsigned short audio_delay = 100;
+module_param(audio_delay, ushort, 0644);
+MODULE_PARM_DESC(audio_delay, "\n the delay for audio mode detection by ms\n");
+
+#define siprintk if(si2177_debug) printk
+#define ssiprintk if(si2177_debug==2) printk
+
+struct si2177_device_s *si2177_devp;
+static void get_mono_sound_mode(unsigned int *);
+void si2177_set_frequency(unsigned int freq);
+static void si2177_set_std(void);
+int si2177_get_strength(void);
+static int si2177_xout_on(void);
+
+
+int si2177_get_strength(void){
+	  int strength=100;
+	  if(si2177_tuner_status(&si2177_devp->tuner_client, SI2177_ATV_STATUS_CMD_INTACK_OK, &si2177_devp->si_cmd_reply)!=0)
+    	 {
+        	printk("[si2177..]%s:get si2177 tuner status error!!!\n",__func__);
+        	return -ERROR;
+         }
+    	else
+        	strength = si2177_devp->si_cmd_reply.tuner_status.rssi;//-256;
+		return strength;
+}
+
+
+static void sound_store(const char *buff, v4l2_std_id *std)
+{
+        if(!strncmp(buff,"dk",2))
+                *std |= V4L2_STD_PAL_DK;
+        else if(!strncmp(buff,"bg",2))
+                *std |= V4L2_STD_B;
+        else if(!strncmp(buff,"i",1))
+                *std |= V4L2_STD_PAL_I;
+        else if(!strncmp(buff,"nm",2))
+                *std |= V4L2_STD_NTSC;
+        else if(!strncmp(buff,"pm",2))
+                *std |= V4L2_STD_PAL_M;
+        else if(!strncmp(buff,"l",1))
+                *std |= V4L2_STD_SECAM_L;
+        else if(!strncmp(buff,"lc",2))
+                *std |= V4L2_STD_SECAM_LC;
+		else if(!strncmp(buff,"n",1))
+                *std |= V4L2_STD_PAL_N;
+        else
+                pr_info("invaild command.\n");
+}
+static ssize_t si2177_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
+{
+ /*       int n = 0;
+        unsigned char ret =0;
+        char *buf_orig, *ps, *token;
+        char *parm[4];
+        unsigned int addr = 0, val = 0;
+        v4l2_std_id  std;
+        buf_orig = kstrdup(buf, GFP_KERNEL);
+        ps = buf_orig;
+        while (1) {
+                token = strsep(&ps, " \n");
+                if (token == NULL)
+                        break;
+                if (*token == '\0')
+                        continue;
+                parm[n++] = token;
+        }
+
+        if (!strncmp(parm[0],"rs",strlen("rs")))
+        {
+                if (n != 2)
+                {
+                        pr_err("read: invalid parameter\n");
+                        kfree(buf_orig);
+                        return count;
+                }
+                addr = simple_strtol(parm[1], NULL, 16);
+                pr_err("%s 0x%x\n", parm[0], addr);
+                si2177_get_property(&si2177_devp->tuner_client, 0, addr, &si2177_devp->si_cmd_reply);
+                pr_info("%s: 0x%x --> 0x%x\n", parm[0], addr, si2177_devp->si_cmd_reply.get_property.data);
+        }
+        else if (!strncmp(parm[0],"ws",strlen("ws")))
+        {
+                addr = simple_strtol(parm[1], NULL, 16);
+                val  = simple_strtol(parm[2], NULL, 16);
+                pr_err("%s 0x%x 0x%x", parm[0], addr, val);
+                si2177_set_property(&si2177_devp->tuner_client,0,addr,val,&si2177_devp->si_cmd_reply);
+                pr_info("%s: 0x%x <-- 0x%x\n", parm[0], addr, val);
+        }
+        else if(!strncmp(parm[0],"atv_restart",strlen("atv_restart")))
+        {
+                ret = si2177_atv_restart(&si2177_devp->tuner_client, 0,  &si2177_devp->si_cmd_reply);
+                if(ret)
+                        pr_info("[tuner..] atv_restart error.\n");
+        }
+        else if(!strncmp(parm[0],"dtv_restart",strlen("atv_restart")))
+        {
+                ret = si2177_dtv_restart(&si2177_devp->tuner_client, &si2177_devp->si_cmd_reply);
+                if(ret)
+                        pr_info("[tuner..] atv_restart error.\n");
+        }
+        else if(!strcmp(parm[0],"tune"))
+        {
+                val  = simple_strtol(parm[1], NULL, 10);
+                //SI2177_TUNER_TUNE_FREQ_CMD_MODE_ATV = 1
+                si2177_tune(&si2177_devp->tuner_client, si2177_devp->parm.mode, val, &si2177_devp->si_cmd_reply, &si2177_devp->si_common_reply);
+        }
+        else if(!strcmp(parm[0],"tuner_status"))
+        {
+                //1=SI2177_ATV_STATUS_CMD_INTACK_CLEAR
+                si2177_tuner_status(&si2177_devp->tuner_client, 1, &si2177_devp->si_cmd_reply);
+                printk("\n[tuner_status.vco_code]:%d        \n[tuner_status.tc]:%d     \n[tuner_status.rssil]:%d  \n[tuner_status.rssih]:%d"
+                                "\n[tuner_status.rssi]:%d   \n[tuner_status.freq]:%d \n[tuner_status.mode]:%d \n", si2177_devp->si_cmd_reply.tuner_status.vco_code,
+                                si2177_devp->si_cmd_reply.tuner_status.tc, si2177_devp->si_cmd_reply.tuner_status.rssil, si2177_devp->si_cmd_reply.tuner_status.rssih,
+                                si2177_devp->si_cmd_reply.tuner_status.rssi,  si2177_devp->si_cmd_reply.tuner_status.freq,   si2177_devp->si_cmd_reply.tuner_status.mode);
+        }
+        else if(!strncmp(parm[0],"atv_status",strlen("atv_status")))
+        {
+                //1=SI2177_ATV_STATUS_CMD_INTACK_CLEAR
+                si2177_cmdreplyobj_t *si_cmd_reply = &si2177_devp->si_cmd_reply;
+                si2177_atv_status(&si2177_devp->tuner_client, 1, si_cmd_reply);
+                printk("\n[atv_status.chl]:%d   \n[atv_status.pcl]:%d       \n[atv_status.dl]:%d   \n[atv_status.snrl]:%d"
+                                "\n[atv_status.snrh]:%d  \n[atv_status.video_snr]:%d    \n[atv_status.afc_freq]:%d    \n[atv_status.video_sc_spacing]:%d"
+                                "\n[atv_status.video_sys]:%d    \n[atv_status.color]:%d      \n[atv_status.audio_chan_bw]:%d \n[atv_status.audio_sys]:%d"
+                                "\n[atv_status.audio_demod_mode]:%d     \n[atv_status.sound_level]:%d       \n[atv_status.trans/lines]:%d.\n",
+                                si_cmd_reply->atv_status.chl,   si_cmd_reply->atv_status.pcl,  si_cmd_reply->atv_status.dl,   si_cmd_reply->atv_status.snrl,
+                                si_cmd_reply->atv_status.snrh,  si_cmd_reply->atv_status.video_snr,   si_cmd_reply->atv_status.afc_freq,  si_cmd_reply->atv_status.video_sc_spacing,
+                                si_cmd_reply->atv_status.video_sys,    si_cmd_reply->atv_status.color, si_cmd_reply->atv_status.audio_chan_bw,  si_cmd_reply->atv_status.audio_sys,
+                                si_cmd_reply->atv_status.audio_demod_mode,  si_cmd_reply->atv_status.sound_level,   si_cmd_reply->atv_status.lines);
+        }
+        else if(!strncmp(parm[0],"mono_mode",strlen("mono_mode")))
+        {
+                get_mono_sound_mode(&val);
+                printk("[si2177..]%s get mono 0x%x,mode %s.\n",__func__,val,v4l2_std_to_str((v4l2_std_id)val));
+        }
+        else if(!strncmp(parm[0],"enter_atv",strlen("enter_atv")))
+        {
+                si2177_devp->parm.mode                 = SI2177_TUNER_TUNE_FREQ_CMD_MODE_ATV;
+                si2177_init(&si2177_devp->tuner_client,&si2177_devp->si_cmd_reply,&si2177_devp->si_common_reply);
+                si2177_configure(&si2177_devp->tuner_client,&si2177_devp->si_prop,&si2177_devp->si_cmd_reply,&si2177_devp->si_common_reply);
+        }
+        else if(!strncmp(parm[0],"std",strlen("std")))
+        {
+                if(!strncmp(parm[1],"pal",3))
+                {
+                        std= V4L2_COLOR_STD_PAL;
+                        sound_store(parm[2],&std);
+                }
+                else if(!strncmp(parm[1],"ntsc",4))
+                {
+                        std= V4L2_COLOR_STD_NTSC;
+                        sound_store(parm[2],&std);
+                }
+                else if(!strncmp(parm[1],"secam",5))
+                {
+                        std= V4L2_COLOR_STD_SECAM;
+                        sound_store(parm[2],&std);
+                }
+                si2177_devp->parm.std  =std;
+                si2177_set_std();
+                siprintk("[si2177..]%s set std color %s, audio type %s.\n",__func__,\
+                                v4l2_std_to_str(0xff000000&si2177_devp->parm.std), v4l2_std_to_str(0xffffff&si2177_devp->parm.std));
+        }
+		else if(!strncmp(parm[0],"cvbs_amp",strlen("cvbs_amp")))
+		{
+			si2177_devp->si_prop.atv_cvbs_out.amp=simple_strtol(parm[1], NULL, 10);
+			if(si2177_set_property(&si2177_devp->tuner_client, 0,0x609,((si2177_devp->si_prop.atv_cvbs_out.amp & 0xff)<<8)|(25 & 0xff), &si2177_devp->si_cmd_reply))
+            printk("[si2177..]%s set cvbs_amp out error.\n",__func__);
+
+		}
+		else if(!strncmp(parm[0],"xout",strlen("xout")))
+		{
+			if(!si2177_xout_on())
+				printk("xoout is ok\n");
+
+		}
+		else
+                printk("invalid command\n");
+        kfree(buf_orig);
+        return count;*/
+}
+
+static ssize_t si2177_show(struct class *cls,struct class_attribute *attr,char *buff)
+{
+        return 0;
+}
+static CLASS_ATTR(si2177_debug,0644,si2177_show,si2177_store);
+
+#ifdef  CVD_SI2177_RSSI
+int cvd_get_rf_strength(void)
+{
+	 int cvd_rssi=0;
+	 if(!si2177_devp)
+	 	return 0;
+	 cvd_rssi=si2177_devp->si_cmd_reply.tuner_status.rssi;
+	 return ((cvd_rssi>0)?cvd_rssi:0);
+}
+EXPORT_SYMBOL(cvd_get_rf_strength);
+#endif
+
+
+static int si2177_get_rf_strength(struct dvb_frontend *fe, unsigned short *strength)
+{
+        if(!strength)
+        {
+                printk("[si2177..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        if(si2177_tuner_status(&si2177_devp->tuner_client, SI2177_ATV_STATUS_CMD_INTACK_OK, &si2177_devp->si_cmd_reply)!=0)
+        {
+                pr_info("[si2177..]%s:get si2177 tuner status error!!!\n",__func__);
+                return -ERROR;
+        }
+        else
+                *strength = si2177_devp->si_cmd_reply.tuner_status.rssi;
+        return 0;
+}
+
+static int si2177_get_tuner_status(struct dvb_frontend *dvb_fe, tuner_status_t *status)
+{
+        si2177_cmdreplyobj_t  *si_cmd_reply = &si2177_devp->si_cmd_reply;
+        if(!status)
+        {
+                printk("[si2177..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        //SI2177_ATV_STATUS_CMD_INTACK_OK = 0
+        if(si2177_tuner_status(&si2177_devp->tuner_client, 0, si_cmd_reply)!=0)
+        {
+                printk("[si2177..]%s:get si2177 tuner status error.\n",__func__);
+                return -ERROR;
+        }
+        status->frequency = si_cmd_reply->tuner_status.freq;
+        status->mode        = si_cmd_reply->tuner_status.mode;
+        status->rssi           = si_cmd_reply->tuner_status.rssi;
+        if(si_cmd_reply->tuner_status.rssih ||si_cmd_reply->tuner_status.rssil)
+        {
+                status->tuner_locked = 0;
+                siprintk("[si2177..]%s rssi %d dismatch <%d, %d>.\n",__func__, (si_cmd_reply->tuner_status.rssi<<24),
+                                (si2177_devp->si_prop.atv_rsq_rssi_threshold.lo),(si2177_devp->si_prop.atv_rsq_rssi_threshold.hi));
+        }
+        else
+        {
+                status->tuner_locked = 1;
+                siprintk("[si2177..]%s rssi %d dismatch <%d, %d>.\n",__func__, si_cmd_reply->tuner_status.rssi,
+                                si2177_devp->si_prop.atv_rsq_rssi_threshold.lo,si2177_devp->si_prop.atv_rsq_rssi_threshold.hi);
+        }
+        siprintk(" frequency %u, mode %d,tuner locked %d.\n",status->frequency, status->mode, status->tuner_locked);
+        return 0;
+}
+
+static int  si2177_tuner_fine_tune(struct dvb_frontend *dvb_fe, int offset_khz)
+{
+
+        if(si2177_fine_tune(&si2177_devp->tuner_client,0,0,offset_khz<<1,&si2177_devp->si_cmd_reply)!=0)
+        {
+                printk("[si2177..]%s: si2177 fine tune error.\n",__func__);
+                return -ERROR;
+        }
+        else
+        {
+                if(si2177_debug)
+                        printk("[si2177..]%s: si2177 fine tune %d khz.\n", __func__, offset_khz);
+                return 0;
+        }
+}
+static int si2177_xout_on()
+{
+    int return_code;
+    printk("Si2177_XoutOn:  Turning Xout ON\n");
+
+    if ((return_code = si2177_config_clocks(&si2177_devp->tuner_client,
+                                              SI2177_CONFIG_CLOCKS_CMD_SUBCODE_CODE,
+                                              SI2177_POWER_UP_CMD_CLOCK_MODE_XTAL,
+                                              SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_EN_XOUT,
+                                              &si2177_devp->si_cmd_reply)) != NO_SI2177_ERROR)
+    	return return_code;
+
+    return NO_SI2177_ERROR;
+}
+
+
+void si2177_set_frequency(unsigned int freq)
+{
+        int ret = 0;
+        if(si2177_debug)
+	    printk("[%s]:now mode is %d(0-DTV,1-ATV)\n",__func__,si2177_devp->parm.mode);
+        ret = si2177_tune(&si2177_devp->tuner_client, si2177_devp->parm.mode, freq, &si2177_devp->si_cmd_reply, &si2177_devp->si_common_reply);
+        if (ret)
+                siprintk("[si2177..]%s: tune frequency error:%d.\n", __func__, ret);
+}
+static void si2177_set_std(void)
+{
+        unsigned char color_mode=SI2177_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC;
+	unsigned char video_sys=SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I;
+	unsigned char  ret=0;
+        v4l2_std_id ptstd = si2177_devp->parm.std;
+        /*set color standard of atv:pal & ntsc*/
+    /*    if (ptstd & (V4L2_COLOR_STD_PAL | V4L2_COLOR_STD_NTSC))
+        {
+                color_mode = SI2177_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC;
+        }
+        else if (ptstd & (V4L2_COLOR_STD_SECAM))
+        {
+                color_mode = SI2177_ATV_VIDEO_MODE_PROP_COLOR_SECAM;
+        }*/
+
+        /* set audio standard of tuner:secam*/
+        if (ptstd & V4L2_STD_B)
+        {
+                si2177_devp->fre_offset = 2250000;
+                video_sys = SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B;
+        }
+        else if (ptstd & V4L2_STD_GH)
+        {
+                si2177_devp->fre_offset = 2250000;
+                video_sys = SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH;
+        }
+        else if ((ptstd & V4L2_STD_NTSC) || ((ptstd & V4L2_STD_PAL_M)))
+        {
+                si2177_devp->fre_offset = 1750000;
+                video_sys = SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M;
+        }
+        else if (ptstd & (V4L2_STD_PAL_N | V4L2_STD_PAL_Nc))
+        {
+                si2177_devp->fre_offset = 1750000;
+                video_sys = SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_N;
+        }
+        else if (ptstd & V4L2_STD_PAL_I)
+        {
+                si2177_devp->fre_offset = 2750000;
+                video_sys = SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I;
+        }
+        else if (ptstd & V4L2_STD_DK)
+        {
+                si2177_devp->fre_offset = 2750000;
+                video_sys = SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK;
+        }
+        else if (ptstd & V4L2_STD_SECAM_L)
+        {
+                si2177_devp->fre_offset = 2750000;
+                video_sys = SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_L;
+        }
+        else if (ptstd & V4L2_STD_SECAM_LC)
+        {
+                si2177_devp->fre_offset = 2750000;
+                video_sys = SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LP;
+        }
+        ret = si2177_set_property(&si2177_devp->tuner_client, 0, 0x604, color_mode<<4|video_sys, &si2177_devp->si_cmd_reply);
+        if(ret)
+                printk("[si2177..]%s:set std %llu error\n",__func__, (unsigned long long)ptstd);
+        siprintk("[si2177..]%s: color %d,video_mode.video_sys:%d.\n", __func__, color_mode, video_sys);
+        if(si2177_atv_restart(&si2177_devp->tuner_client, 0,  &si2177_devp->si_cmd_reply))
+                printk("[si2177..]%s: atv restart error.\n", __func__);
+}
+
+static int si2177_set_params(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+    int strength=100;
+    if(FE_ANALOG == fe->ops.info.type)
+    {
+	    if(c->analog.std != si2177_devp->parm.std)
+	    {
+	        si2177_devp->parm.std  = c->analog.std;
+	        si2177_set_std();
+                siprintk("[si2177..]%s set std color %s, audio type %s.\n",__func__,\
+                            v4l2_std_to_str(0xff000000&si2177_devp->parm.std), v4l2_std_to_str(0xffffff&si2177_devp->parm.std));
+	    }
+            if(c->frequency  != si2177_devp->parm.frequency)
+	    {
+	        si2177_devp->parm.frequency  = c->frequency;
+	        si2177_set_frequency(si2177_devp->parm.frequency + si2177_devp->fre_offset);
+                siprintk("[si2177..]%s set frequency %u. frequency offset is %d.\n",__func__,si2177_devp->parm.frequency,si2177_devp->fre_offset);
+	    }
+        /*
+	    else if(parm->u.analog.audmode != si2177_devp->parm.audmode)
+	    {
+	        printk("[si2177..] %s no audmode case catch error.\n",__func__);
+	    }
+	    else if(parm->u.analog.soundsys != si2177_devp->parm.soundsys)
+	    {
+		printk("[si2177..] %s no soundsys case catch error.\n",__func__);
+	    }
+            else if(parm->u.analog.reserved != si2177_devp->parm.reserved)
+            {
+                printk("[si2177..] %s no case catch resevred.\n",__func__);
+            }*/
+	}
+    else
+	{
+	/*	if(FE_QAM == fe->ops.info.type)
+		{
+			if(QAM_128 == parm->u.qam.modulation)
+			{
+				si2177_devp->si_prop.dtv_lif_out.amp = 22;
+				if(si2177_set_property(&si2177_devp->tuner_client,0,0x707,22,&si2177_devp->si_cmd_reply))
+					printk("[si2177..]%s set dtv lif out amp 22error.\n",__func__);
+			}
+			else
+			{
+				si2177_devp->si_prop.dtv_lif_out.amp = 25;
+				if(si2177_set_property(&si2177_devp->tuner_client,0,0x707,25,&si2177_devp->si_cmd_reply))
+					printk("[si2177..]%s set dtv lif out amp 25 error.\n",__func__);
+			}
+		}*/
+		 if(FE_ATSC==fe->ops.info.type){
+				si2177_devp->si_prop.dtv_lif_freq.offset=6350;
+				printk("FE_ATSC set para if is %d\n",si2177_devp->si_prop.dtv_lif_freq.offset);
+				if(si2177_set_property(&si2177_devp->tuner_client,0,0x706,si2177_devp->si_prop.dtv_lif_freq.offset,&si2177_devp->si_cmd_reply))
+					printk("[si2177..]%s set dtv lif out if error.\n",__func__);
+			//	parm->frequency=parm->frequency+2500000;//for atsc 2.5mhz
+		}else if(FE_QAM == fe->ops.info.type){
+			si2177_devp->si_prop.dtv_lif_freq.offset=6000;
+			printk("FE_QAM set para if is %d\n",si2177_devp->si_prop.dtv_lif_freq.offset);
+			if(si2177_set_property(&si2177_devp->tuner_client,0,0x706,si2177_devp->si_prop.dtv_lif_freq.offset,&si2177_devp->si_cmd_reply))
+					printk("[si2177..]%s set dtv lif out if error.\n",__func__);
+			if(c->modulation==QAM_256){
+				si2177_devp->si_prop.dtv_lif_out.amp = 23;
+			}else{
+				si2177_devp->si_prop.dtv_lif_out.amp = 23;
+			}
+			printk("amp is %d,offset is %d,amp+offset is %x\n",si2177_devp->si_prop.dtv_lif_out.amp,si2177_devp->si_prop.dtv_lif_out.offset,((si2177_devp->si_prop.dtv_lif_out.offset)+((si2177_devp->si_prop.dtv_lif_out.amp)<<8)));
+			if(si2177_set_property(&si2177_devp->tuner_client,0,0x707,(si2177_devp->si_prop.dtv_lif_out.offset)+((si2177_devp->si_prop.dtv_lif_out.amp)<<8),&si2177_devp->si_cmd_reply))
+					printk("[si2177..]%s set dtv lif out amp error.\n",__func__);
+		}else if(FE_DTMB == fe->ops.info.type){
+			si2177_devp->si_prop.dtv_lif_out.amp = 21;
+			if(si2177_set_property(&si2177_devp->tuner_client,0,0x707,(si2177_devp->si_prop.dtv_lif_out.offset)+((si2177_devp->si_prop.dtv_lif_out.amp)<<8),&si2177_devp->si_cmd_reply))
+					printk("[si2177..]%s set dtv lif out amp error.\n",__func__);
+
+			printk("FE_DTMB amp is %d,offset is %d,amp+offset is %x\n",si2177_devp->si_prop.dtv_lif_out.amp,si2177_devp->si_prop.dtv_lif_out.offset,((si2177_devp->si_prop.dtv_lif_out.offset)+((si2177_devp->si_prop.dtv_lif_out.amp)<<8)));
+
+		}
+
+		si2177_devp->parm.frequency  = c->frequency;
+		si2177_set_frequency(si2177_devp->parm.frequency);
+		printk("[si2177..]%s set frequency %u. \n",__func__,si2177_devp->parm.frequency);
+		if(si2177_tuner_status(&si2177_devp->tuner_client, SI2177_ATV_STATUS_CMD_INTACK_OK, &si2177_devp->si_cmd_reply)!=0)
+		{
+        	printk("[si2177..]%s:get si2177 tuner status error!!!\n",__func__);
+        	return -ERROR;
+		}
+		else
+		    strength = si2177_devp->si_cmd_reply.tuner_status.rssi-256;
+		printk("strength is %d\n",strength);
+     }
+
+    return 0;
+}
+//try audmode B,CH,I,DK,return the sound level
+static unsigned char set_video_audio_mode(unsigned char color,unsigned char audmode)
+{
+        int ret = 0;
+        ret = si2177_set_property(&si2177_devp->tuner_client, 0, 0x604, color<<4|audmode, &si2177_devp->si_cmd_reply);
+        ret = si2177_atv_restart(&si2177_devp->tuner_client, 0,  &si2177_devp->si_cmd_reply);
+        mdelay(audio_delay);
+        if(ret)
+                printk("[si2177..]%s set sound mode %d error.\n",__func__,audmode);
+        ret = si2177_atv_status(&si2177_devp->tuner_client, SI2177_ATV_STATUS_CMD_INTACK_OK, &si2177_devp->si_cmd_reply);
+        if(ret)
+                printk("[si2177..]%s:get si2177 atv status error.\n",__func__);
+        if(!ret)
+                return si2177_devp->si_cmd_reply.atv_status.sound_level;
+        else
+                return ret;
+}
+static void get_mono_sound_mode(unsigned int *mode)
+{
+        unsigned char max_level=0, cu_level=0;
+        //set audio mode B=0,GH=1,I=4,DK=5
+        cu_level = set_video_audio_mode(si2177_devp->si_prop.atv_video_mode.color,SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B);
+        if(cu_level > max_level)
+        {
+                max_level = cu_level;
+                *mode = V4L2_STD_B;
+        }
+        cu_level = set_video_audio_mode(si2177_devp->si_prop.atv_video_mode.color,SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH);
+        if(cu_level > max_level)
+        {
+                max_level = cu_level;
+                *mode = V4L2_STD_GH;
+        }
+        cu_level = set_video_audio_mode(si2177_devp->si_prop.atv_video_mode.color,SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I);
+        if(cu_level > max_level)
+        {
+                max_level = cu_level;
+                *mode = V4L2_STD_PAL_I;
+        }
+        cu_level = set_video_audio_mode(si2177_devp->si_prop.atv_video_mode.color,SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK);
+        if(cu_level > max_level)
+        {
+                max_level = cu_level;
+                *mode = V4L2_STD_DK;
+        }
+        siprintk("[si2177..]%s auto result audio mode is 0x%x,%s.\n",__func__, *mode,v4l2_std_to_str((v4l2_std_id)*mode));
+        //revert the color&audmode
+        si2177_set_property(&si2177_devp->tuner_client, 0, 0x604, si2177_devp->si_prop.atv_video_mode.color<<4|si2177_devp->si_prop.atv_video_mode.video_sys, &si2177_devp->si_cmd_reply);
+        si2177_atv_restart(&si2177_devp->tuner_client, 0,  &si2177_devp->si_cmd_reply);
+}
+static int si2177_set_config(struct dvb_frontend *fe, void *arg)
+{
+        tuner_param_t *param = (tuner_param_t*)arg;
+        if(!arg)
+        {
+                printk("[si2177..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        switch(param->cmd)
+        {
+                case TUNER_CMD_AUDIO_MUTE:
+                        //SI2177_ATV_AF_OUT_PROP = 0x060b
+                        if(si2177_set_property(&si2177_devp->tuner_client, 0,0x60b, 0, &si2177_devp->si_cmd_reply))
+                        {
+                                printk("[si2177..]%s mute tuner error.\n",__func__);
+                                return -ERROR;
+                        }
+                        break;
+                case TUNER_CMD_AUDIO_ON:
+                        if(si2177_set_property(&si2177_devp->tuner_client, 0,0x60b, si2177_devp->si_prop.atv_af_out.volume, &si2177_devp->si_cmd_reply))
+                        {
+                                printk("[si2177..]%s set tuner volume error.\n",__func__);
+                                return -ERROR;
+                        }
+                        break;
+                case TUNER_CMD_TUNER_POWER_DOWN:
+                        if(si2177_power_down(&si2177_devp->tuner_client, &si2177_devp->si_cmd_reply))
+                        {
+                                printk("[si2177..]%s power down tuner error.\n",__func__);
+                                return -ERROR;
+                        }
+                        siprintk("[si2177..]%s power down tuner TUNER_CMD_TUNER_POWER_DOWN.\n",__func__);
+                        break;
+                case TUNER_CMD_TUNER_POWER_ON:
+                        if(si2177_init(&si2177_devp->tuner_client, &si2177_devp->si_cmd_reply, &si2177_devp->si_common_reply))
+                        {
+                                pr_info("[si2177..]%s: si2177 initializate error.\n",__func__);
+                                return -ERROR;
+                        }
+                        if(si2177_configure(&si2177_devp->tuner_client, &si2177_devp->si_prop, &si2177_devp->si_cmd_reply, &si2177_devp->si_common_reply))
+                                printk("[si2177..]%s: si2177 configure atv&dtv error.\n",__func__);
+                        break;
+                case TUNER_CMD_SET_VOLUME:
+                        if(param->parm > SI2177_ATV_AF_OUT_PROP_VOLUME_VOLUME_MAX)
+                                param->parm = SI2177_ATV_AF_OUT_PROP_VOLUME_VOLUME_MAX;
+                        si2177_devp->si_prop.atv_af_out.volume = param->parm;
+                        if(si2177_set_property(&si2177_devp->tuner_client, 0,0x60b, si2177_devp->si_prop.atv_af_out.volume, &si2177_devp->si_cmd_reply))
+                                printk("[si2177..]%s set tuner volume error.\n",__func__);
+                        break;
+                case TUNER_CMD_GET_MONO_MODE:
+                        get_mono_sound_mode(&param->parm);
+                        break;
+                case TUNER_CMD_SET_LEAP_SETP_SIZE:
+                        si2177_devp->parm.leap_step = param->parm;
+                        break;
+                case TUNER_CMD_SET_BEST_LOCK_RANGE:
+                        break;
+                case TUNER_CMD_GET_BEST_LOCK_RANGE:
+                        break;
+		case TUNER_CMD_SET_CVBS_AMP_OUT:
+			si2177_devp->si_prop.atv_cvbs_out.amp=param->parm;
+			if(si2177_set_property(&si2177_devp->tuner_client, 0,0x609,((si2177_devp->si_prop.atv_cvbs_out.amp & 0xff)<<8)|(25 & 0xff), &si2177_devp->si_cmd_reply))
+			printk("[si2177..]%s set cvbs_amp out error.\n",__func__);
+			break;
+		case TUNER_CMD_GET_CVBS_AMP_OUT:
+			if(si2177_get_property(&si2177_devp->tuner_client,0,0x609,&si2177_devp->si_cmd_reply))
+			{
+			printk("[si2177..]:%s:get cvbs amp error.\n",__func__);
+			}
+			param->parm=si2177_devp->si_cmd_reply.get_property.data;
+			printk("[si2177..]%s:get the cvbs amp out is %d\n",__func__,param->parm);
+			break;
+                default:
+                        break;
+        }
+        return 0;
+}
+static void si2177_get_status(struct dvb_frontend *fe, void *stat);
+static void si2177_get_pll_status(struct dvb_frontend *fe, void *stat);
+
+static int si2177_tuner_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+        struct dvb_tuner_ops *si2177_tuner_ops  = (struct dvb_tuner_ops*)ops;
+        if(!ops)
+        {
+                printk("[si2177..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        si2177_tuner_ops->info.frequency_min    = SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MIN;
+        si2177_tuner_ops->info.frequency_max   = SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MAX;
+        switch(mode)
+        {
+                case AM_FE_QPSK:
+                        //SI2177_DTV_MODE_PROP_MODULATION_ISDBT = 4
+                        si2177_devp->si_prop.dtv_mode.modulation = 4;
+                        break;
+                case AM_FE_QAM:
+                        //SI2177_DTV_MODE_PROP_MODULATION_DVBC = 3
+                        si2177_devp->si_prop.dtv_mode.modulation = 3;
+                        break;
+                case AM_FE_OFDM:
+                        //SI2177_DTV_MODE_PROP_MODULATION_DVBT = 2
+                        si2177_devp->si_prop.dtv_mode.modulation = 2;
+                        break;
+                case AM_FE_ATSC:
+                        //SI2177_DTV_MODE_PROP_MODULATION_ATSC = 0
+                        si2177_devp->si_prop.dtv_mode.modulation = 0;
+                        break;
+                case AM_FE_ANALOG:
+                        break;
+				case AM_FE_DTMB:
+                        //SI2176_DTV_MODE_PROP_MODULATION_DTMB = 6
+                        si2177_devp->si_prop.dtv_mode.modulation = 6;
+                        break;
+                default:
+                        printk("[si2177..] %s no mode to match %d.\n",__func__, mode);
+                        break;
+        }
+
+        if(AM_FE_ANALOG == mode)//the auto afc step size 1/2 M
+        {
+                si2177_tuner_ops->info.frequency_step = 0x0;
+                //fine tune
+                si2177_tuner_ops->fine_tune             = si2177_tuner_fine_tune;
+                //the box for expand
+                si2177_tuner_ops->set_config           = si2177_set_config;
+                si2177_devp->parm.mode                 = SI2177_TUNER_TUNE_FREQ_CMD_MODE_ATV;
+        }
+        else//dtv doesn't use auto afc
+        {
+                if(si2177_set_property(&si2177_devp->tuner_client, 0, 0x703,
+                                        si2177_devp->si_prop.dtv_mode.modulation<<4|8,
+                                        &si2177_devp->si_cmd_reply))
+                        printk("[si2177..] %s mode %d si2177_set_property error.",__func__, mode);
+                si2177_devp->parm.mode                 = SI2177_TUNER_TUNE_FREQ_CMD_MODE_DTV;
+                si2177_tuner_ops->info.frequency_step = 0x0;
+        }
+        si2177_tuner_ops->get_rf_strength       = si2177_get_rf_strength;
+        si2177_tuner_ops->get_tuner_status    = si2177_get_tuner_status;
+        si2177_tuner_ops->get_status              =si2177_get_status;
+	si2177_tuner_ops->get_pll_status              =si2177_get_pll_status;
+        //set std&frequency
+        si2177_tuner_ops->set_params     	  = si2177_set_params;
+
+        return 0;
+}
+
+#define TUNER_POWER_GPIO_OWNER  "TUNER_OWNER"
+
+static int si2177_tuner_fe_init(struct aml_fe_dev *dev)
+{
+
+        int error_code = 0;
+        if(!dev)
+        {
+                printk("[si2177..]%s: null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        si2177_devp->tuner_client.adapter = dev->i2c_adap;
+        si2177_devp->tuner_client.addr    = dev->i2c_addr;
+        if(!sprintf(si2177_devp->tuner_client.name,SI2177_TUNER_I2C_NAME))
+        {
+                printk("[si2177..]%s sprintf name error.\n",__func__);
+        }
+		amlogic_gpio_request(dev->reset_gpio,TUNER_POWER_GPIO_OWNER);//lock
+
+	   amlogic_gpio_direction_output(dev->reset_gpio,0,TUNER_POWER_GPIO_OWNER);
+	   udelay(400);
+	   amlogic_gpio_direction_output(dev->reset_gpio,1,TUNER_POWER_GPIO_OWNER);
+
+		amlogic_gpio_free(dev->reset_gpio,TUNER_POWER_GPIO_OWNER); //free
+
+  /*     gpio_out(dev->reset_gpio,0);
+       udelay(400);
+       gpio_out(dev->reset_gpio,1);*/
+       printk("[%s]tuner reset.dev->reset_value=[%d],i2c_addr is %x \n",__func__,dev->reset_value,dev->i2c_addr);
+      return error_code;
+}
+
+static int si2177_enter_mode(struct aml_fe *fe, int mode)
+{
+        int err_code;
+        err_code = si2177_init(&si2177_devp->tuner_client,&si2177_devp->si_cmd_reply,&si2177_devp->si_common_reply);
+        err_code = si2177_configure(&si2177_devp->tuner_client,&si2177_devp->si_prop,&si2177_devp->si_cmd_reply,&si2177_devp->si_common_reply);
+		if(err_code)
+        {
+                printk("[si2177..]%s init si2177 error.\n",__func__);
+                return err_code;
+        }
+        return 0;
+}
+static int si2177_leave_mode(struct aml_fe *fe, int mode)
+{
+        int err_code;
+	si2177_devp->parm.frequency=0;
+	si2177_devp->parm.std=0;
+        err_code = si2177_power_down(&si2177_devp->tuner_client, &si2177_devp->si_cmd_reply);
+        if(err_code)
+        {
+                printk("[si2177..]%s power down si2177 error.\n",__func__);
+                return err_code;
+        }
+        return 0;
+}
+
+static int si2177_suspend(struct aml_fe_dev *dev)
+{
+	int err_code;
+	si2177_devp->parm.frequency=0;
+	si2177_devp->parm.std=0;
+	err_code = si2177_power_down(&si2177_devp->tuner_client, &si2177_devp->si_cmd_reply);
+	 if(err_code)
+        {
+        printk("[si2177..]%s si2177 standby mode is err.\n",__func__);
+        return err_code;
+        }
+	 return 0;
+
+}
+static int si2177_resume(struct aml_fe_dev *dev)
+{
+	int err_code;
+	amlogic_gpio_request(dev->reset_gpio,TUNER_POWER_GPIO_OWNER);//lock
+
+   amlogic_gpio_direction_output(dev->reset_gpio,0,TUNER_POWER_GPIO_OWNER);
+   udelay(400);
+   amlogic_gpio_direction_output(dev->reset_gpio,1,TUNER_POWER_GPIO_OWNER);
+
+	amlogic_gpio_free(dev->reset_gpio,TUNER_POWER_GPIO_OWNER); //free
+
+        err_code = si2177_init(&si2177_devp->tuner_client,&si2177_devp->si_cmd_reply,&si2177_devp->si_common_reply);
+        err_code = si2177_configure(&si2177_devp->tuner_client,&si2177_devp->si_prop,&si2177_devp->si_cmd_reply,&si2177_devp->si_common_reply);
+        if(err_code)
+        {
+                printk("[si2177..]%s resume si2177 error.\n",__func__);
+                return err_code;
+        }
+        return 0;
+}
+static struct aml_fe_drv si2177_tuner_drv = {
+        .name    = "si2177_tuner",
+        .capability = AM_FE_ANALOG|AM_FE_QPSK|AM_FE_QAM|AM_FE_ATSC|AM_FE_OFDM|AM_FE_DTMB,
+        .id      = AM_TUNER_SI2177,
+        .get_ops = si2177_tuner_get_ops,
+        .init    = si2177_tuner_fe_init,
+        .enter_mode = si2177_enter_mode,
+        .leave_mode = si2177_leave_mode,
+        .suspend = si2177_suspend,
+        .resume = si2177_resume,
+};
+
+static int si2177_analog_get_afc(struct dvb_frontend *fe)
+{
+        if(si2177_atv_status(&si2177_devp->tuner_client, SI2177_ATV_STATUS_CMD_INTACK_OK, &si2177_devp->si_cmd_reply)!=0)
+        {
+                pr_info("[si2177..]%s: get si2177 atv status error.\n",__func__);
+                return -ERROR;
+        }
+        else
+                return si2177_devp->si_cmd_reply.atv_status.afc_freq;
+}
+static int si2177_analog_get_snr(struct dvb_frontend *fe)
+{
+        if(si2177_atv_status(&si2177_devp->tuner_client, SI2177_ATV_STATUS_CMD_INTACK_OK, &si2177_devp->si_cmd_reply)!=0)
+        {
+                pr_info("[si2177..]%s: get si2177 atv status error.\n",__func__);
+                return -ERROR;
+        }
+        else
+                return si2177_devp->si_cmd_reply.atv_status.video_snr;
+}
+//tuner lock status & demod lock status should be same in silicon tuner
+static void si2177_get_status(struct dvb_frontend *fe, void *stat)
+{
+        fe_status_t *status = (fe_status_t*)stat;
+        if(!status)
+        {
+                printk("[si2177..]%s: null pointer error.\n",__func__);
+                return;
+        }
+        if(si2177_atv_status(&si2177_devp->tuner_client, SI2177_ATV_STATUS_CMD_INTACK_OK, &si2177_devp->si_cmd_reply))
+        {
+                pr_info("[si2177..]%s:get si2177 atv status error.\n",__func__);
+                return;
+        }
+        else
+        {
+                if(si2177_devp->si_cmd_reply.atv_status.chl)
+                        *status = FE_HAS_LOCK;
+                else
+                        *status = FE_TIMEDOUT;
+        }
+}
+//tuner lock status & demod lock status should be same in silicon tuner
+static void si2177_get_pll_status(struct dvb_frontend *fe, void *stat)
+{
+        fe_status_t *status = (fe_status_t*)stat;
+        if(!status)
+        {
+                printk("[si2177..]%s: null pointer error.\n",__func__);
+                return;
+        }
+        if(si2177_atv_status(&si2177_devp->tuner_client, SI2177_ATV_STATUS_CMD_INTACK_OK, &si2177_devp->si_cmd_reply))
+        {
+                pr_info("[si2177..]%s:get si2177 atv status error.\n",__func__);
+                return;
+        }
+        else
+        {
+                if(si2177_devp->si_cmd_reply.atv_status.pcl&&si2177_devp->si_cmd_reply.atv_status.dl)
+                        *status = FE_HAS_LOCK;
+                else
+                        *status = FE_TIMEDOUT;
+        }
+}
+
+static int si2177_analog_get_atv_status(struct dvb_frontend *dvb_fe, atv_status_t *atv_status)
+{
+		si2177_cmdreplyobj_t  *si_cmd_reply = &si2177_devp->si_cmd_reply;
+//get the tuner_status to give cvd to use
+	if(si2177_tuner_status(&si2177_devp->tuner_client, 0, si_cmd_reply)!=0)
+        {
+                printk("[si2177..]%s:the patch:get si2177 tuner status error.\n",__func__);
+                return -ERROR;
+        }
+        if(!atv_status)
+        {
+                printk("[si2177..]%s: null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        if(si2177_atv_status(&si2177_devp->tuner_client, SI2177_ATV_STATUS_CMD_INTACK_OK, &si2177_devp->si_cmd_reply)!=0)
+        {
+                pr_info("[si2177..]%s:get si2177 atv status error.\n",__func__);
+                return -ERROR;
+        }
+        else
+        {
+                atv_status->afc = si2177_devp->si_cmd_reply.atv_status.afc_freq;
+                atv_status->snr =si2177_devp->si_cmd_reply.atv_status.video_snr;
+                atv_status->atv_lock = si2177_devp->si_cmd_reply.atv_status.chl;
+                atv_status->audmode = si2177_devp->si_cmd_reply.atv_status.audio_demod_mode;
+                atv_status->std &= 0;
+                if(si2177_devp->si_cmd_reply.atv_status.color);
+        //                atv_status->std |= V4L2_COLOR_STD_SECAM;
+                else;
+  //                      atv_status->std = V4L2_COLOR_STD_PAL;
+                switch(si2177_devp->si_cmd_reply.atv_status.video_sys)
+                {
+                        case 0:
+                                atv_status->std |=V4L2_STD_B;
+                                break;
+                        case 1:
+                                atv_status->std |=V4L2_STD_GH;
+                                break;
+                        case 2:
+                                atv_status->std |=V4L2_STD_PAL_M;
+                                break;
+                        case 3:
+                                atv_status->std |=V4L2_STD_PAL_N;
+                                break;
+                        case 4:
+                                atv_status->std |=V4L2_STD_PAL_I;
+                                break;
+                        case 5:
+                                atv_status->std |=V4L2_STD_DK;
+                                break;
+                        case 6:
+                                atv_status->std |=V4L2_STD_SECAM_L;
+                                break;
+                        case 7:
+                                atv_status->std |=V4L2_STD_SECAM_LC;
+                                break;
+                        default:
+                                break;
+                }
+
+        }
+//it is the si2177_debug==2,the printk is valid
+		ssiprintk("[si2177..]%s afc %d,snr %d,atv lock %d audmode %d,std color %s audio %s.\n",__func__,atv_status->afc, atv_status->snr,
+                        atv_status->atv_lock, atv_status->audmode, v4l2_std_to_str(atv_status->std&0xff000000),v4l2_std_to_str(atv_status->std&0xffffff));
+        return 0;
+}
+
+static int si2177_analog_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+
+        struct analog_demod_ops *si2177_analog_ops = (struct analog_demod_ops*)ops;
+        if(!ops)
+        {
+                printk("[si2177..]%s null pointer error.\n",__func__);
+                return -ERROR;
+        }
+        si2177_analog_ops->get_afc               = si2177_analog_get_afc;
+        si2177_analog_ops->get_snr               = si2177_analog_get_snr;
+        si2177_analog_ops->get_status          = si2177_get_status;
+	si2177_analog_ops->get_pll_status          = si2177_get_pll_status;
+        si2177_analog_ops->get_atv_status   = si2177_analog_get_atv_status;
+        return 0;
+}
+
+static struct aml_fe_drv si2177_analog_drv = {
+        .name    = "si2177_atv_demod",
+        .capability = AM_FE_ANALOG,
+        .id      = AM_ATV_DEMOD_SI2177 ,//2177 bsp follow the si2176
+        .get_ops = si2177_analog_get_ops
+};
+
+static int __init si2177_tuner_init(void)
+{
+        int ret = 0;
+        si2177_devp = kmalloc(sizeof(struct si2177_device_s), GFP_KERNEL);
+
+        if(!si2177_devp)
+        {
+                pr_info("[si2177..] %s:allocate memory error,no enough memory for struct si2177_dev_s.\n",__func__);
+                return -ENOMEM;
+        }
+        memset(si2177_devp, 0, sizeof(struct si2177_device_s));
+
+        si2177_devp->clsp = class_create(THIS_MODULE,TUNER_DEVICE_NAME);
+        if(!si2177_devp->clsp)
+        {
+                pr_info("[si2177..]%s:create class error.\n",__func__);
+                kfree(si2177_devp);
+                si2177_devp = NULL;
+                return PTR_ERR(si2177_devp->clsp);
+        }
+        ret = class_create_file(si2177_devp->clsp, &class_attr_si2177_debug);
+        if(ret)
+                pr_err("[si2177]%s create si2177 class file error.\n",__func__);
+        /*initialize the tuner common struct and register*/
+        aml_register_fe_drv(AM_DEV_TUNER, &si2177_tuner_drv);
+        aml_register_fe_drv(AM_DEV_ATV_DEMOD, &si2177_analog_drv);
+        printk("[si2177..]%s.\n",__func__);
+        return 0;
+}
+
+static void __exit si2177_tuner_exit(void)
+{
+        class_destroy(si2177_devp->clsp);
+        kfree(si2177_devp);
+        aml_unregister_fe_drv(AM_DEV_ATV_DEMOD, &si2177_analog_drv);
+        aml_unregister_fe_drv(AM_DEV_TUNER, &si2177_tuner_drv);
+        pr_info("[si2177..]%s: driver removed ok.\n",__func__);
+}
+
+MODULE_AUTHOR("kele.bai <kele.bai@amlogic.com>");
+MODULE_DESCRIPTION("si2177 tuner device driver");
+MODULE_LICENSE("GPL");
+
+fs_initcall(si2177_tuner_init);
+module_exit(si2177_tuner_exit);
+
diff --git a/drivers/amlogic/dvb_tv/si2177/si2177_func.c b/drivers/amlogic/dvb_tv/si2177/si2177_func.c
new file mode 100755
index 000000000000..c9c9548e0549
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2177/si2177_func.c
@@ -0,0 +1,3475 @@
+/*
+ * Silicon labs si2177 Tuner Device Driver
+ *
+ * Author: Bobby Yang <hui.fang@amlogic.com>
+ *
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/* Standard Liniux Headers */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+/* Local Headers */
+#include "si2177_func.h"
+
+
+#define I2C_TRY_MAX_CNT       3  //max try counter
+
+static unsigned int si2177_version = 33; //the old available firmware is 42
+static unsigned int delay_det=85;
+static unsigned int cvbs_amp=100;
+module_param(si2177_version, uint, 0664);
+MODULE_PARM_DESC(si2177_version, "\n si2177_version \n");
+module_param(delay_det, uint, 0644);
+MODULE_PARM_DESC(delay_det, "delay set freq time\n");
+module_param(cvbs_amp,uint,0644);
+MODULE_PARM_DESC(cvbs_amp, "\n si2177_cvbs_amp_out \n");
+
+
+static int __init si2177_tuner_parse_param(char *str)
+{
+        unsigned char *ptr = str;
+        printk("[si2177..] %s bootargs is %s.\n",__func__,str);
+        if(strstr(ptr,"b29"))
+                si2177_version = 29;
+        else if(strstr(ptr,"b30"))
+                si2177_version = 30;
+		else if(strstr(ptr,"b32"))
+				si2177_version = 32;
+		else if (strstr(ptr,"2177_30_b5"))
+				si2177_version = 33;
+        else
+                return -1;
+        return 0;
+}
+__setup("tuner=",si2177_tuner_parse_param);
+
+
+typedef struct firmware_struct {
+	unsigned int firmware_len;
+	unsigned char firmware_table[16];
+} firmware_struct;
+
+
+firmware_struct SI2177_FW_3_0b5[] = {
+{ 16 , { 0xBF,0x21,0xB1,0xF8,0x50,0xD4,0xBD,0xDA,0x05,0x05,0xEE,0xC4,0xC2,0x3D,0x38,0x3E } },
+{ 8 , { 0x05,0x37,0x88,0x3C,0xE8,0x9D,0x8C,0x73 } },
+{ 16 , { 0x37,0x7E,0x76,0x05,0x28,0xFF,0xE7,0x9E,0xFF,0xB2,0xAC,0xA8,0x4C,0x34,0x27,0xD5 } },
+{ 16 , { 0x37,0x61,0x1B,0x98,0x42,0x2A,0xF4,0x94,0x3A,0x41,0x54,0x62,0xC5,0x63,0x64,0xE8 } },
+{ 8 , { 0x0F,0x25,0x9C,0x90,0x29,0xF4,0x01,0xB9 } },
+{ 16 , { 0x3F,0x19,0x38,0xD3,0xCF,0x93,0x28,0xE7,0x0F,0x88,0x6E,0x9A,0x63,0x9D,0xC8,0xA9 } },
+{ 11 , { 0x3A,0xF5,0x4F,0x80,0x53,0xA7,0x3B,0x61,0x61,0xB8,0x8E } },
+{ 11 , { 0x07,0x35,0xFD,0xB8,0x08,0x47,0xD6,0xEF,0x42,0x55,0xB3 } },
+{ 11 , { 0x0F,0x37,0x0E,0x93,0x3C,0xC5,0x95,0x6E,0x4A,0x16,0x87 } },
+{ 8 , { 0x07,0xE0,0x62,0xC7,0x47,0x85,0x6F,0xE4 } },
+{ 16 , { 0x3F,0xD1,0xE5,0xEB,0x0F,0xF8,0x8F,0x2E,0x92,0xEC,0xF8,0xF5,0xF5,0x4B,0x03,0x60 } },
+{ 14 , { 0x4A,0xA5,0xC6,0x07,0x43,0x80,0x4D,0x16,0x73,0x23,0x62,0x4A,0x40,0xC6 } },
+{ 8 , { 0x07,0xE8,0xC4,0x65,0xF3,0xE8,0xA8,0x40 } },
+{ 9 , { 0x38,0xC6,0xF7,0xA0,0x83,0xDE,0x0A,0x2B,0xD9 } },
+{ 16 , { 0x0F,0x90,0x5C,0x69,0x81,0x8E,0x3B,0x10,0x0F,0x04,0xB5,0x39,0xC5,0x45,0xD1,0x30 } },
+{ 16 , { 0x07,0x94,0xB3,0xE8,0x5A,0xCD,0x12,0x3E,0x0F,0x52,0x02,0x0B,0x4C,0xA8,0x53,0x25 } },
+{ 11 , { 0x0F,0x74,0xE6,0x3B,0xC2,0x52,0x80,0x11,0x4A,0xD8,0xF7 } },
+{ 14 , { 0x07,0x12,0x8F,0xAF,0x41,0xAA,0x21,0x92,0x45,0x97,0xDE,0x8C,0xDF,0x61 } },
+{ 8 , { 0x07,0x6C,0xF5,0xD0,0x97,0x73,0x1D,0x64 } },
+{ 9 , { 0x30,0x59,0x7F,0xD1,0xF3,0x95,0x19,0x8C,0x83 } },
+{ 11 , { 0x0F,0xA5,0xEB,0x96,0x1A,0xF7,0xDD,0xCF,0x42,0xCF,0x67 } },
+{ 8 , { 0x07,0xBF,0x08,0xF6,0x58,0x2B,0xE6,0xF6 } },
+{ 16 , { 0x3F,0x7A,0x11,0xF4,0x49,0xA2,0x2B,0x77,0xAA,0xFC,0xA4,0x62,0x96,0x92,0x2E,0x2E } },
+{ 14 , { 0x42,0x2E,0xA7,0x07,0x4D,0x77,0x36,0x86,0x14,0xA8,0xF6,0x42,0x50,0xED } },
+{ 16 , { 0x07,0xC9,0xCC,0xF5,0x96,0x73,0x36,0x27,0x0F,0x46,0xAD,0xB8,0x42,0xBB,0x20,0x5D } },
+{ 8 , { 0x07,0x65,0x6C,0x82,0x0F,0xD3,0x75,0x2C } },
+{ 12 , { 0x33,0x94,0xF7,0xCA,0x9B,0x4B,0x3D,0x9D,0x60,0x6A,0xF1,0xCF } },
+{ 11 , { 0x0F,0x32,0x3B,0x72,0xF8,0x49,0x84,0xFB,0x42,0x0F,0x42 } },
+{ 11 , { 0x07,0x26,0x87,0x28,0x8F,0x05,0xA3,0xAD,0x4A,0x59,0xC3 } },
+{ 16 , { 0x0A,0xBE,0xBB,0x9F,0x7D,0xE9,0x1A,0x74,0x12,0xD6,0xED,0xA3,0xB8,0x4A,0xDE,0x61 } },
+{ 8 , { 0x0F,0xB0,0x9C,0x7C,0x83,0xAE,0x64,0x9E } },
+{ 9 , { 0x30,0x48,0xE3,0xC4,0xDF,0xB6,0x69,0xB1,0x28 } },
+{ 11 , { 0x0F,0x33,0xAF,0x5A,0x2A,0xCE,0xFF,0xC2,0x4A,0x91,0x28 } },
+{ 8 , { 0x0F,0xF9,0xC1,0x42,0xA9,0x47,0x1C,0x6F } },
+{ 15 , { 0x36,0x39,0xE5,0x7D,0x4E,0xFE,0x74,0xA9,0x56,0x6F,0xB5,0x45,0x4E,0x3B,0x11 } },
+{ 8 , { 0x07,0x89,0xCB,0x17,0x5D,0x68,0x45,0xE4 } },
+{ 16 , { 0x3F,0xE5,0x65,0x79,0xE1,0x2F,0x88,0xAE,0x71,0x61,0xC6,0x44,0x08,0x9A,0xEC,0xA6 } },
+{ 8 , { 0x07,0x69,0x5C,0x05,0xA4,0x7B,0x8C,0xB8 } },
+{ 16 , { 0x3F,0xFD,0xF6,0x55,0x1C,0xE7,0x84,0xEF,0x78,0xA2,0x15,0x4C,0x27,0x20,0xE2,0xFC } },
+{ 9 , { 0x30,0x72,0x05,0x23,0x31,0xA9,0x3F,0x1C,0xD0 } },
+{ 11 , { 0x07,0xF3,0xC2,0xC4,0x9E,0xD9,0xD3,0x2E,0x42,0x0A,0x09 } },
+{ 8 , { 0x07,0x7F,0x52,0x33,0xF7,0x79,0x0C,0x79 } },
+{ 16 , { 0x3F,0xC0,0xCC,0xD6,0x65,0xC1,0xD2,0xEC,0x6F,0xB4,0xDC,0x42,0x26,0xCC,0xDF,0x8F } },
+{ 8 , { 0x07,0x7C,0x43,0x52,0xB1,0x44,0x70,0xDC } },
+{ 9 , { 0x38,0x66,0xE8,0x62,0xEA,0xE4,0xBA,0xFF,0xBB } },
+{ 8 , { 0x0F,0x22,0xFA,0xF3,0xA6,0xE9,0xDC,0xFB } },
+{ 15 , { 0x3E,0xE3,0x1F,0x9D,0xC0,0x56,0xB9,0xDD,0x71,0xA1,0x42,0x1C,0xD4,0x7C,0x0E } },
+{ 15 , { 0x0F,0x6A,0x56,0xB2,0x84,0x4F,0xB2,0xA9,0x4E,0x67,0x14,0x82,0x57,0x3F,0xC8 } },
+{ 11 , { 0x0F,0x87,0xA0,0x15,0x24,0x5F,0x03,0xF9,0x4A,0x50,0xB3 } },
+{ 8 , { 0x0F,0x5B,0x7E,0x34,0x20,0x7A,0xC3,0xCF } },
+{ 12 , { 0x33,0x5C,0xCB,0x58,0x7F,0x83,0x83,0xF7,0xC0,0x9E,0xC0,0x89 } },
+{ 11 , { 0x0F,0x03,0x21,0x5C,0x19,0x58,0x3B,0x1F,0x42,0xB8,0x7B } },
+{ 11 , { 0x07,0xDA,0x87,0x66,0x4A,0x8F,0xDB,0xCE,0x4A,0x04,0xBF } },
+{ 8 , { 0x0F,0xD1,0xA3,0x5A,0xEC,0xB0,0xE1,0xA0 } },
+{ 12 , { 0x3B,0xF6,0x00,0xE4,0x3D,0xDD,0x51,0x25,0x27,0xD2,0x50,0xB6 } },
+{ 8 , { 0x0F,0xA2,0x36,0x93,0x50,0xD5,0xF8,0xE1 } },
+{ 16 , { 0x3F,0x18,0x99,0xAE,0x84,0x94,0xE4,0x94,0xDE,0x75,0x12,0xE3,0xAA,0xD2,0x3D,0x18 } },
+{ 11 , { 0x42,0xDB,0x33,0x07,0x2B,0x3C,0x18,0x8C,0x92,0x18,0x69 } },
+{ 16 , { 0x07,0x6C,0x85,0xAA,0x6D,0xFD,0x7A,0xBD,0x07,0xB1,0x16,0x9B,0x5B,0xBA,0x9E,0x52 } },
+{ 16 , { 0x3F,0x96,0x5C,0x2B,0x48,0x02,0x12,0x13,0x54,0xDD,0xAA,0x3F,0x44,0x14,0x6E,0x87 } },
+{ 14 , { 0x4D,0x4C,0xF3,0x8A,0x52,0x04,0x0F,0x23,0x9C,0x12,0x15,0xB3,0xBA,0x00 } },
+{ 14 , { 0x4D,0x2B,0x05,0x56,0x44,0x3A,0x07,0x40,0x3A,0x70,0xDA,0x3C,0x41,0xB2 } },
+{ 12 , { 0x33,0xFB,0xE7,0x39,0x88,0x89,0x25,0x73,0x29,0xDB,0x47,0x09 } },
+{ 11 , { 0x0F,0x39,0x30,0x9F,0xF9,0xD5,0x7B,0xB5,0x42,0x11,0x97 } },
+{ 16 , { 0x07,0xC2,0xCD,0xF1,0x7C,0x63,0x5B,0x26,0x07,0x04,0xDD,0x5B,0x94,0x45,0xC8,0x9C } },
+{ 14 , { 0x07,0x0C,0x4A,0x33,0xFA,0x28,0x1D,0x6B,0x4D,0x11,0xDC,0xA2,0xA7,0x84 } },
+{ 11 , { 0x0F,0xD1,0x46,0xE6,0x27,0xBB,0xAD,0x8D,0x42,0xCE,0x58 } },
+{ 11 , { 0x0F,0xD5,0xE3,0x25,0x5F,0x6F,0x1E,0xFC,0x42,0x93,0x8D } },
+{ 8 , { 0x0F,0xD9,0xAB,0xC7,0xD7,0x96,0xF8,0xBE } },
+{ 9 , { 0x30,0xA5,0x11,0xDE,0x14,0x5E,0xA3,0x07,0xBE } },
+{ 8 , { 0x0F,0xFF,0xB5,0x28,0x4F,0xCF,0xA7,0x3C } },
+{ 16 , { 0x3F,0x86,0x17,0x1A,0x00,0x6C,0xBF,0x7F,0x83,0xB2,0x3F,0xE4,0xD2,0xFF,0xC2,0x18 } },
+{ 16 , { 0x37,0x37,0x1B,0x81,0x82,0xFE,0x8C,0xC2,0x8A,0xB1,0x1C,0x4A,0x4B,0x8A,0x94,0x66 } },
+{ 16 , { 0x37,0x80,0x53,0x9C,0x2B,0x32,0x97,0xE4,0x7A,0x5A,0xE2,0xF3,0x75,0x47,0xA6,0xF1 } },
+{ 16 , { 0x3F,0x44,0xCF,0x82,0x2F,0xD8,0x5D,0xED,0x9F,0xC0,0x3A,0x28,0x7F,0x7C,0x21,0x53 } },
+{ 15 , { 0x3E,0x31,0x35,0xA6,0xF3,0xC8,0xAA,0x7E,0x98,0x8E,0x60,0x80,0xE0,0xE6,0xCC } },
+{ 8 , { 0x07,0xB8,0x98,0xC0,0xA5,0xC9,0x9E,0x6A } },
+{ 11 , { 0x32,0xEC,0x2E,0x11,0xB6,0x4C,0x71,0xBF,0xC2,0x31,0x1C } },
+{ 8 , { 0x0F,0x00,0x13,0x7B,0x74,0xBC,0xD8,0x8B } },
+{ 11 , { 0x32,0x7F,0xFD,0x3D,0x1A,0x34,0x1C,0x25,0x50,0xBB,0xD3 } },
+{ 8 , { 0x07,0x7E,0xAE,0x2A,0x43,0x25,0x07,0x9C } },
+{ 13 , { 0x34,0x8C,0xF2,0xD5,0x5D,0x83,0xF7,0xD6,0x82,0xD4,0x12,0xB5,0x7B } },
+{ 8 , { 0x07,0xBC,0xC7,0x76,0x7E,0xDD,0xF4,0xA2 } },
+{ 16 , { 0x3F,0x91,0x33,0x61,0xAB,0x3A,0x7F,0x94,0x75,0x86,0xC8,0x5B,0xB6,0xE9,0x4C,0x6F } },
+{ 16 , { 0x37,0xB4,0x2A,0x7D,0xFB,0xDD,0x19,0x38,0xA4,0x06,0xE3,0xF9,0x02,0x25,0x1D,0x5D } },
+{ 16 , { 0x37,0x80,0xDD,0xAC,0x0A,0x35,0x44,0xC4,0xC9,0x80,0x46,0x5A,0x84,0x78,0x32,0x08 } },
+{ 16 , { 0x37,0x2D,0xA5,0x43,0xA2,0x87,0xDC,0x80,0xE9,0xE0,0xDA,0xDD,0x7B,0xD0,0x94,0x9E } },
+{ 16 , { 0x3F,0xD8,0x40,0x1F,0xDC,0x59,0x13,0xC3,0xEA,0x88,0x9F,0x8E,0xD5,0xB8,0x7D,0xDF } },
+{ 16 , { 0x37,0x94,0xB8,0x51,0x44,0x90,0x8B,0x9A,0xF7,0x4C,0x51,0xCB,0x3D,0xA7,0xEC,0x49 } },
+{ 16 , { 0x3F,0x6E,0x1D,0xD3,0xDB,0x45,0xC1,0x0C,0xA2,0x8E,0xA7,0xD4,0x32,0x7A,0x41,0x13 } },
+{ 16 , { 0x3F,0xFA,0x54,0xF6,0xCB,0x58,0x83,0x00,0x60,0x60,0x06,0x62,0x42,0xAD,0xD2,0xD9 } },
+{ 16 , { 0x37,0xAD,0x2E,0xDB,0x84,0xB3,0xFE,0xB6,0x7C,0xA9,0x6D,0x2D,0x40,0x30,0x10,0x15 } },
+{ 16 , { 0x37,0x3D,0xBC,0x3F,0xA5,0xD1,0x7F,0x67,0x2F,0xEE,0x6D,0x40,0x5E,0x9C,0x27,0xCF } },
+{ 16 , { 0x3F,0x56,0xDD,0xBE,0x1E,0xC1,0xDE,0xC4,0x2D,0xC5,0xA9,0xC1,0xF6,0x90,0xF5,0x60 } },
+{ 16 , { 0x37,0x2E,0xCF,0x9E,0x9E,0x48,0x77,0x0A,0xEF,0x20,0x7F,0xC2,0x3D,0xF3,0x89,0x09 } },
+{ 12 , { 0x4B,0x61,0x03,0x39,0x0F,0x42,0x5F,0x38,0xB8,0xE0,0xB1,0x6F } },
+{ 16 , { 0x37,0xC0,0xD5,0xD8,0xEE,0xA6,0xD2,0xFA,0x1D,0x3C,0x14,0xE4,0xA8,0x46,0x39,0x81 } },
+{ 11 , { 0x42,0xCA,0x93,0x0F,0x49,0xDE,0x8A,0xFD,0x03,0xA9,0x8D } },
+{ 16 , { 0x3F,0x00,0x49,0x34,0x7E,0xC3,0xF5,0x0A,0x2D,0x92,0xAC,0x4D,0x5F,0x4A,0x79,0x5C } },
+{ 14 , { 0x35,0x62,0xD2,0xB7,0xEB,0x20,0x05,0x91,0x94,0xB3,0xAA,0xC1,0x99,0x0F } },
+{ 16 , { 0x0F,0x6A,0x19,0xA9,0x88,0x8C,0x15,0x60,0x07,0x46,0x2D,0xAF,0xAF,0x89,0x27,0x5B } },
+{ 8 , { 0x07,0xD9,0x28,0x8D,0x41,0xEA,0x18,0x2D } },
+{ 13 , { 0x3C,0xD9,0x32,0x17,0x25,0x6E,0x6F,0xA3,0xAB,0x11,0x31,0x68,0x94 } },
+{ 8 , { 0x0F,0xF1,0x57,0xF0,0xA4,0x1C,0x39,0x3F } },
+{ 16 , { 0x3F,0xF2,0xF4,0xAE,0xB6,0xD9,0xC2,0xE5,0x32,0x4C,0xCC,0xBE,0xFA,0xE0,0xF4,0xB5 } },
+{ 12 , { 0x4B,0xB6,0xAB,0x11,0x07,0x5E,0xFD,0x85,0x07,0x12,0x00,0x4E } },
+{ 16 , { 0x0F,0x62,0x77,0x4B,0x1C,0xE7,0xF6,0xCF,0x0F,0x6A,0x38,0xE0,0x0F,0xD3,0x38,0xF5 } },
+{ 15 , { 0x46,0x56,0x66,0xEA,0x53,0x0F,0xB1,0x07,0xE1,0xF9,0x0F,0x5D,0x1F,0x87,0xF8 } },
+{ 12 , { 0x43,0x78,0x82,0xAD,0x07,0xFE,0x7D,0xA3,0x16,0x91,0xDB,0xE5 } },
+{ 16 , { 0x3F,0x6E,0x45,0x3F,0xBF,0x02,0x48,0x32,0x36,0x9C,0x4A,0xCB,0xDA,0x27,0x8B,0x1D } },
+{ 16 , { 0x3F,0x80,0x02,0x95,0x30,0x74,0xFB,0xC6,0x4B,0x04,0xFC,0xE1,0x0B,0xCD,0x4B,0x79 } },
+{ 16 , { 0x3F,0xB6,0x0A,0xFE,0x6C,0x99,0x59,0x3A,0xD2,0xD9,0x04,0xBF,0x7D,0x39,0xE5,0xB3 } },
+{ 16 , { 0x3F,0x59,0x27,0x2B,0x03,0x7B,0xE3,0xE2,0xFF,0x1B,0x86,0x58,0x5D,0xDD,0xA2,0x3B } },
+{ 16 , { 0x37,0x42,0x1B,0x79,0xAD,0x8F,0x9B,0x68,0x3A,0x81,0xFA,0x18,0x37,0xC4,0x4F,0x3D } },
+{ 16 , { 0x3F,0x14,0x7C,0x79,0x53,0x52,0xA5,0x31,0xA3,0x19,0x57,0xC2,0xDE,0xB5,0x6A,0x14 } },
+{ 16 , { 0x3F,0x7E,0x5E,0xB9,0xFE,0xBF,0xCD,0x3E,0xC4,0xA9,0x43,0x9A,0xF8,0xA8,0xF7,0x88 } },
+{ 16 , { 0x37,0x99,0xEC,0xB0,0xD5,0x6C,0x71,0x8F,0x91,0x44,0x74,0x4A,0x1B,0x39,0x94,0x29 } },
+{ 16 , { 0x3F,0x40,0x38,0x62,0xDD,0x93,0xFB,0xCB,0x05,0xD9,0x88,0x18,0x33,0xB7,0x8A,0xE3 } },
+{ 14 , { 0x35,0xA6,0x13,0x62,0xFF,0x44,0x4C,0xF0,0x04,0xCA,0xBA,0xE6,0x5B,0x93 } },
+{ 16 , { 0x07,0xFE,0x29,0x6D,0xAD,0x38,0xD1,0xE9,0x07,0xA3,0x64,0x82,0x18,0x5E,0x46,0x84 } },
+{ 8 , { 0x07,0x15,0x32,0x84,0x60,0x3E,0xCA,0x70 } },
+{ 16 , { 0x37,0x29,0x2C,0xA9,0xD8,0xD6,0x8B,0x10,0x0A,0x60,0x9C,0xA0,0x68,0x6B,0x55,0xE7 } },
+{ 16 , { 0x37,0x8B,0x84,0xB7,0x98,0x73,0x79,0x45,0xD8,0x14,0x8F,0xFB,0x76,0x9C,0x3F,0xA0 } },
+{ 12 , { 0x3B,0xF1,0x16,0x24,0xC8,0x0B,0x2F,0xF6,0x82,0x38,0x2B,0x04 } },
+{ 16 , { 0x0F,0xD4,0xA4,0xF8,0x07,0x6C,0x30,0x5F,0x0F,0x2C,0xF3,0xC5,0x41,0x31,0xF2,0xC9 } },
+{ 8 , { 0x07,0x96,0x56,0x07,0x18,0x1C,0xBA,0x48 } },
+{ 16 , { 0x37,0x3A,0xCA,0x6D,0xB5,0xC7,0x14,0xDD,0xE5,0x68,0x63,0x10,0x70,0x7D,0xAF,0x36 } },
+{ 12 , { 0x4B,0x20,0x19,0xE4,0x07,0x1E,0xBB,0x82,0x34,0xE1,0x73,0x30 } },
+{ 8 , { 0x0F,0x38,0x5B,0xBA,0xBD,0x26,0xBF,0xEE } },
+{ 16 , { 0x3F,0x57,0x0D,0x9B,0x6B,0x4A,0xD0,0x74,0xC0,0x8A,0x92,0x68,0xA0,0x3C,0xA8,0xF1 } },
+{ 16 , { 0x37,0xE9,0x6E,0x50,0x76,0x7C,0x51,0x06,0x70,0x1B,0x06,0x6F,0x42,0xDC,0x8E,0x3E } },
+{ 16 , { 0x37,0x2E,0xAB,0x45,0x2C,0xBE,0xDA,0x19,0xA4,0xD5,0xC9,0x66,0xB9,0x0B,0x3A,0x0B } },
+{ 14 , { 0x35,0x68,0x6B,0xCC,0x33,0x46,0xF4,0x5F,0x17,0xE5,0x02,0xF0,0xCD,0x65 } },
+{ 8 , { 0x07,0xBB,0xE2,0xB6,0xCF,0x13,0xD3,0x6F } },
+{ 16 , { 0x3F,0x12,0xA4,0x99,0x1E,0x91,0x51,0x3D,0x77,0x99,0xE4,0x3C,0x7D,0xF4,0xA6,0xBB } },
+{ 10 , { 0x31,0x9C,0x6A,0x32,0xCE,0x00,0x1E,0x36,0x59,0x25 } },
+{ 16 , { 0x0F,0x6A,0x0B,0x4C,0x7E,0x1F,0x11,0x54,0x0F,0x24,0x71,0xA6,0xC2,0xDA,0x3B,0xBC } },
+{ 16 , { 0x0F,0x19,0x13,0x70,0x9E,0x0A,0xF4,0xB5,0x0F,0x58,0x5E,0xC5,0xFC,0x30,0xA4,0x42 } },
+{ 8 , { 0x07,0xBC,0xFA,0xCC,0xBD,0x2B,0x76,0xC0 } },
+{ 12 , { 0x3B,0x72,0xF4,0xCE,0x70,0x40,0x39,0xFC,0xBA,0xD0,0xA2,0x4F } },
+{ 16 , { 0x0F,0x3B,0x9F,0x47,0xED,0xBA,0xA7,0x72,0x0F,0x29,0x3A,0x7A,0x97,0xDA,0x12,0x9C } },
+{ 8 , { 0x0F,0x34,0x49,0x97,0x2B,0xB6,0xD0,0x66 } },
+{ 16 , { 0x3F,0xAD,0xFB,0xC5,0xDF,0x94,0x43,0xB3,0xE2,0x24,0x27,0x37,0xA1,0x50,0xB6,0x09 } },
+{ 10 , { 0x39,0x1D,0x5F,0x06,0x1B,0x96,0x0D,0x48,0x22,0x67 } },
+{ 16 , { 0x0F,0x02,0xBA,0xB1,0xDD,0xEA,0x97,0xD3,0x07,0x9E,0x8B,0xD7,0xBB,0x41,0x0A,0x72 } },
+{ 13 , { 0x0F,0x25,0xE3,0x4D,0x16,0x55,0x16,0x3B,0x44,0x08,0xB1,0x9D,0x63 } },
+{ 16 , { 0x0F,0xF5,0x2A,0xDF,0x2A,0xB7,0x2B,0x0B,0x0F,0xE2,0xFF,0xCC,0x0D,0x37,0x7A,0x9E } },
+{ 14 , { 0x45,0x84,0xCE,0x77,0x29,0x6D,0x07,0x09,0x0C,0x6B,0x83,0x21,0x2C,0x15 } },
+{ 8 , { 0x07,0x63,0xA0,0x85,0xEF,0x5A,0xD3,0x55 } },
+{ 9 , { 0x38,0xD5,0xC5,0xC5,0x3C,0xCB,0x70,0x54,0x69 } },
+{ 8 , { 0x07,0x7D,0xA2,0x73,0x6A,0x98,0x4D,0x27 } },
+{ 16 , { 0x3F,0x6C,0xE6,0x12,0x77,0x30,0x22,0x34,0xBB,0x27,0xBB,0xCD,0x4E,0xD0,0xE6,0xDF } },
+{ 16 , { 0x3F,0x10,0x54,0x9A,0x1F,0x07,0x35,0x14,0xE1,0x33,0x0A,0x9B,0x67,0x4D,0xA0,0x5D } },
+{ 12 , { 0x3B,0x56,0x33,0x93,0xC9,0xB3,0x30,0xA1,0x23,0xC8,0xDD,0xF5 } },
+{ 8 , { 0x07,0xB2,0x01,0x59,0x31,0xDA,0xE4,0xDF } },
+{ 16 , { 0x37,0xA6,0x2C,0xC8,0x2C,0x67,0x87,0xE6,0x00,0x8F,0x3E,0xC7,0x52,0x90,0xBE,0xD4 } },
+{ 11 , { 0x4A,0x72,0x20,0x07,0x61,0xFC,0x3E,0x1C,0x7F,0xF4,0x77 } },
+{ 14 , { 0x07,0xB2,0x8A,0x78,0xE5,0xED,0x6F,0x10,0x4D,0x47,0x27,0xA0,0x3A,0x71 } },
+{ 8 , { 0x07,0xF6,0x45,0x4E,0x76,0x6D,0x01,0xCC } },
+{ 16 , { 0x37,0x71,0xE1,0x5E,0xAF,0x55,0x06,0x4B,0x95,0x12,0xFF,0x95,0x6B,0x49,0xC4,0x46 } },
+{ 9 , { 0x38,0xCC,0x51,0x29,0xB5,0x81,0x39,0x55,0xB9 } },
+{ 8 , { 0x0F,0xD8,0xB3,0xDF,0xE6,0x61,0x5B,0x03 } },
+{ 16 , { 0x3F,0xE8,0x82,0xC6,0x1F,0x26,0xBE,0x33,0x3A,0x7A,0x1C,0xBF,0x31,0x90,0x25,0x6B } },
+{ 16 , { 0x3F,0x75,0x0F,0xDB,0x5A,0x87,0x26,0x5E,0x67,0x24,0xC3,0xB4,0xE9,0x43,0xAE,0x95 } },
+{ 16 , { 0x3F,0xAF,0xE1,0xC1,0x3B,0x56,0x3F,0x19,0xC5,0xE1,0xC4,0xBB,0x63,0x0A,0xC3,0x4E } },
+{ 13 , { 0x34,0x26,0xDC,0x69,0xF4,0xA9,0xAC,0x3B,0x98,0x13,0xF6,0x4E,0xAB } },
+{ 8 , { 0x0F,0xD4,0x90,0x19,0x0A,0xA5,0x8D,0xB8 } },
+{ 16 , { 0x3F,0xD2,0x8D,0xC3,0xA7,0x13,0x44,0x4C,0x23,0xF6,0xD2,0xDC,0xAB,0x0F,0x55,0x82 } },
+{ 12 , { 0x4B,0x84,0xBA,0x97,0x0F,0x79,0x49,0xDF,0x1E,0xF9,0xA1,0x48 } },
+{ 12 , { 0x33,0xE7,0x23,0x04,0xA1,0x71,0x37,0x3C,0x99,0x5D,0xF2,0x06 } },
+{ 8 , { 0x0F,0x27,0xDF,0xFD,0xB0,0xEA,0xD5,0xDD } },
+{ 16 , { 0x37,0x8D,0x8A,0xDB,0xDF,0x3F,0xF7,0xCD,0xC7,0x9E,0x7F,0x05,0xFD,0x77,0x33,0x20 } },
+{ 11 , { 0x4A,0xDA,0x04,0x0F,0x6A,0xD1,0xB2,0xAA,0x1A,0x55,0x55 } },
+{ 16 , { 0x3F,0x39,0xCB,0x0A,0x0C,0x92,0xE1,0xDB,0xB9,0xC6,0x7D,0x11,0x04,0xC7,0x87,0x66 } },
+{ 15 , { 0x3E,0x1D,0x65,0x83,0x25,0xCD,0xFE,0x86,0x48,0xD3,0xC1,0x7B,0x03,0x05,0x87 } },
+{ 16 , { 0x0F,0x4A,0x31,0xF5,0x39,0x24,0xB8,0x37,0x0F,0x96,0x51,0xCE,0xC1,0xC1,0xF6,0x4B } },
+{ 16 , { 0x3F,0xF5,0xCC,0xC2,0x04,0xFC,0x8C,0xAD,0xD6,0x20,0x76,0x08,0x85,0x63,0x2B,0xD1 } },
+{ 16 , { 0x3F,0xC3,0x83,0x8A,0xEA,0xF7,0x89,0x94,0x3E,0xE3,0x93,0x5E,0xEC,0xDF,0x40,0x01 } },
+{ 12 , { 0x3B,0x1C,0x23,0x40,0xF6,0xD5,0x01,0xF6,0x2A,0x93,0xE4,0x1D } },
+{ 8 , { 0x0F,0x0F,0x83,0xE8,0x76,0x50,0x92,0xFA } },
+{ 16 , { 0x37,0x82,0x47,0x45,0x7E,0xE2,0x0F,0x32,0x49,0xCD,0x37,0x38,0x2B,0x4B,0x9A,0x8A } },
+{ 12 , { 0x43,0x05,0xC8,0x40,0x0F,0x02,0xE3,0x6D,0x30,0x61,0xF1,0x98 } },
+{ 16 , { 0x37,0x91,0x37,0xCB,0x68,0x81,0x9A,0xA8,0x61,0xCE,0xBF,0x67,0xC2,0x06,0xE8,0x09 } },
+{ 16 , { 0x37,0x12,0xA4,0x7A,0xE4,0x73,0x20,0x90,0xAA,0x78,0x49,0xD0,0xD9,0xE1,0x18,0x47 } },
+{ 16 , { 0x3F,0x52,0x80,0x43,0x40,0x41,0x19,0xFA,0xE5,0x06,0x64,0x39,0x94,0x2A,0xB1,0xA4 } },
+{ 16 , { 0x37,0xB5,0xDD,0x62,0x66,0x1E,0x0B,0x00,0x0E,0x81,0x73,0x44,0xDB,0xDC,0xC5,0x37 } },
+{ 16 , { 0x37,0xF1,0x6B,0x04,0xA6,0xFD,0x2E,0xD3,0x03,0x6B,0x8E,0xAA,0x9F,0x76,0xC5,0xA4 } },
+{ 16 , { 0x3F,0x0E,0xAA,0x91,0x72,0xC3,0xFC,0xCD,0x1B,0xD2,0xA3,0x74,0x29,0xF8,0x3F,0xE3 } },
+{ 16 , { 0x37,0x24,0xD1,0x29,0xAF,0x44,0xB2,0x93,0x93,0x91,0x69,0xC9,0xE3,0x9D,0x56,0x93 } },
+{ 16 , { 0x37,0x2F,0x93,0xAC,0x2F,0x95,0x12,0x32,0x7E,0x48,0x21,0xC5,0xE1,0xBC,0xA7,0xAD } },
+{ 9 , { 0x38,0x9C,0xD0,0x3C,0x03,0x8B,0x7E,0x43,0x07 } },
+{ 16 , { 0x07,0xC3,0xE2,0x9B,0x18,0x67,0x79,0xE0,0x0F,0xEF,0x99,0xF4,0x9C,0xF2,0xFE,0xF7 } },
+{ 8 , { 0x0F,0x52,0xB4,0x2B,0xEA,0xDE,0x46,0xCE } },
+{ 9 , { 0x30,0x3B,0x55,0x5E,0x2C,0x34,0x56,0xD4,0x0C } },
+{ 8 , { 0x07,0xC7,0x87,0xE0,0x46,0x48,0xD1,0x1B } },
+{ 15 , { 0x36,0xDD,0x84,0xBA,0x2B,0x8C,0x84,0x56,0xA1,0x62,0x14,0x49,0x06,0xDA,0x5F } },
+{ 8 , { 0x0F,0xB6,0x5B,0xF3,0x92,0xFC,0x8D,0xAA } },
+{ 11 , { 0x3A,0xC6,0xAD,0x54,0x97,0x23,0x5A,0x03,0x17,0xDD,0x64 } },
+{ 12 , { 0x07,0xB2,0x2B,0x95,0x16,0x06,0x37,0xB1,0x4B,0xFA,0x31,0x04 } },
+{ 8 , { 0x07,0xF0,0x84,0xFA,0x66,0xED,0x51,0xCD } },
+{ 16 , { 0x3F,0xDF,0x05,0x91,0xCC,0xE7,0x9D,0x26,0x0F,0x01,0xA9,0x2F,0x1B,0xB8,0x0A,0xBB } },
+{ 16 , { 0x3F,0xF1,0x49,0xCE,0x04,0x53,0xA9,0x9F,0xA1,0xAC,0x0E,0x58,0x01,0x7C,0x67,0x35 } },
+{ 10 , { 0x49,0x4C,0x0F,0x9C,0xB0,0xCD,0x55,0xD9,0xF6,0x70 } },
+{ 16 , { 0x3F,0xDE,0x13,0xB5,0x3B,0xDE,0x4E,0x47,0x0B,0x5F,0xB4,0x18,0x04,0xDE,0xE0,0xD2 } },
+{ 14 , { 0x3D,0x85,0x5E,0xE1,0x71,0x69,0xCD,0x41,0xF0,0x5B,0x96,0xD4,0x29,0x72 } },
+{ 8 , { 0x07,0x8E,0xCC,0xDB,0xD8,0x27,0x78,0x0B } },
+{ 16 , { 0x37,0x38,0x08,0x9E,0xC7,0xE3,0x95,0xF2,0xCD,0x5D,0xCA,0xC9,0x47,0xBB,0xE0,0x04 } },
+{ 14 , { 0x4D,0x11,0x72,0x0F,0x5E,0x1D,0x07,0xAD,0x6B,0x91,0x10,0x83,0x73,0xF5 } },
+{ 16 , { 0x3F,0x12,0x72,0xA8,0x60,0x89,0xA3,0xB0,0xED,0xBE,0x1D,0x50,0x40,0x53,0x68,0x05 } },
+{ 10 , { 0x49,0x23,0x07,0x4B,0xB2,0x11,0x36,0x62,0xDB,0x95 } },
+{ 12 , { 0x3B,0x5D,0xBD,0xB1,0xEC,0x89,0x9C,0x14,0x04,0xA7,0xCF,0x91 } },
+{ 8 , { 0x07,0xF6,0xB7,0xC4,0xF5,0xDB,0xD6,0x63 } },
+{ 11 , { 0x32,0x85,0x4A,0x56,0x1E,0x4B,0xAA,0xC6,0xD3,0xC8,0xED } },
+{ 8 , { 0x0F,0x06,0x72,0x2F,0x17,0xE1,0xCA,0x13 } },
+{ 16 , { 0x37,0x52,0x65,0xC2,0xC7,0xFB,0x89,0xFF,0xC0,0x3F,0xFC,0x71,0x9D,0x25,0x78,0xA0 } },
+{ 11 , { 0x42,0xF2,0x84,0x0F,0x27,0x44,0x0C,0x66,0x46,0xDA,0x5C } },
+{ 16 , { 0x37,0x22,0x51,0x61,0x14,0x17,0xBF,0x7F,0x9F,0x66,0x66,0x5E,0xA9,0xDC,0x8D,0xDB } },
+{ 16 , { 0x3F,0xFE,0xE5,0x71,0x5C,0x57,0xE1,0x45,0x8C,0xBF,0x9B,0x64,0xA3,0xFB,0xF8,0x70 } },
+{ 16 , { 0x37,0x3C,0x21,0x70,0x1E,0xB8,0x7F,0x67,0x87,0xB7,0xAF,0x60,0xB8,0xC3,0x90,0xAE } },
+{ 12 , { 0x43,0xC1,0x59,0xF0,0x0F,0x1B,0x98,0x95,0x23,0x1F,0x78,0xF8 } },
+{ 16 , { 0x07,0xC4,0x9F,0x90,0x47,0x00,0x75,0xAB,0x07,0x98,0xD5,0xE6,0xCE,0x04,0x38,0x1E } },
+{ 13 , { 0x0F,0xD5,0x47,0x57,0xDC,0xE1,0xE1,0xFF,0x4C,0x51,0xFC,0xD4,0x87 } },
+{ 8 , { 0x0F,0xCE,0x8A,0x5C,0xFA,0xDD,0x0E,0x91 } },
+{ 16 , { 0x3F,0x0C,0xE7,0x71,0x60,0x3E,0x73,0x63,0x7C,0x5C,0xD0,0x7C,0xB0,0xD3,0x12,0x07 } },
+{ 16 , { 0x3F,0x48,0xB6,0x42,0x9D,0xA2,0x2E,0x0F,0x84,0xA6,0x63,0xCF,0x3D,0xBA,0x70,0xBA } },
+{ 13 , { 0x44,0x4B,0x8D,0xBB,0x82,0x07,0xED,0xB2,0xDB,0x83,0x50,0xEC,0xB9 } },
+{ 16 , { 0x47,0x58,0x73,0xE5,0x80,0x68,0x3A,0x05,0x0F,0x4F,0x8C,0xCB,0xB0,0x41,0x9D,0x55 } },
+{ 9 , { 0x38,0xDE,0x4B,0x78,0xD8,0x07,0x9F,0x91,0xA7 } },
+{ 16 , { 0x0F,0xDD,0x11,0xF5,0xEA,0xCB,0x86,0x31,0x0F,0xBB,0xE2,0x90,0x54,0x2A,0xF5,0x72 } },
+{ 16 , { 0x07,0x16,0x1A,0x60,0xFE,0x8D,0xBB,0xEE,0x0F,0x82,0xCD,0x90,0xE1,0x7E,0x7A,0x66 } },
+{ 16 , { 0x4F,0x1E,0xBB,0xA1,0xAB,0x6E,0xA9,0x6E,0x0F,0x57,0xCD,0x9B,0x84,0x4C,0x79,0xBA } },
+{ 8 , { 0x07,0xFA,0xD6,0x7D,0xA2,0x3A,0x39,0x5D } },
+{ 16 , { 0x3F,0xB8,0x9E,0xD7,0x7A,0xEA,0x9E,0x94,0xC3,0x09,0x07,0x81,0x77,0xB0,0xFB,0xBC } },
+{ 16 , { 0x37,0x08,0x37,0x2A,0x6F,0xBE,0x2D,0x2D,0x27,0x41,0x41,0x23,0xAA,0x33,0xE4,0x22 } },
+{ 14 , { 0x3D,0x82,0x43,0x9B,0xCA,0x91,0x6C,0x3E,0xBD,0x6E,0xDF,0x30,0x4B,0x30 } },
+{ 8 , { 0x07,0xDB,0x20,0xD6,0xF6,0x82,0x22,0x6A } },
+{ 10 , { 0x39,0x8B,0x3F,0x89,0xD8,0x3A,0x93,0x6B,0x9E,0xC7 } },
+{ 11 , { 0x0F,0xB8,0x7C,0xB1,0x17,0xBD,0x12,0xE4,0x42,0xEF,0xFF } },
+{ 16 , { 0x0F,0x60,0x65,0x98,0x8B,0xA1,0x3F,0x68,0x07,0x6F,0x7D,0xB5,0x1F,0x50,0xE4,0x8C } },
+{ 16 , { 0x3F,0x1A,0x52,0x7B,0x5A,0x8C,0x21,0x96,0xBE,0xEC,0x41,0xCA,0x41,0x4D,0xB3,0x40 } },
+{ 15 , { 0x36,0x19,0xEA,0x24,0x82,0x68,0xF4,0x94,0xD9,0x32,0x88,0x08,0x80,0xD8,0xA8 } },
+{ 15 , { 0x0F,0xC2,0xA8,0x88,0x1A,0x13,0xE9,0x71,0x4E,0xC9,0x44,0x2B,0xF7,0xA7,0xC2 } },
+{ 8 , { 0x07,0xDF,0x40,0x91,0x36,0x50,0x67,0x54 } },
+{ 16 , { 0x3F,0xFC,0x1A,0x13,0xB3,0xC5,0x79,0xE2,0x3C,0x41,0x25,0x51,0x11,0x22,0xE1,0x8E } },
+{ 10 , { 0x49,0xEB,0x07,0x52,0x3D,0x83,0x21,0xE1,0xC6,0xC3 } },
+{ 16 , { 0x37,0x38,0x99,0xD0,0x79,0xBE,0x79,0x36,0x35,0x74,0x36,0x2C,0x35,0x8F,0x68,0x95 } },
+{ 16 , { 0x37,0xB9,0x7E,0x02,0x7D,0xA8,0xD5,0xF7,0x88,0x78,0x5D,0x84,0x12,0x6C,0x61,0x79 } },
+{ 14 , { 0x3D,0xEE,0x31,0xFB,0x94,0x3E,0x12,0xF2,0x48,0x69,0x0B,0x45,0xD0,0xF2 } },
+{ 8 , { 0x07,0x58,0x12,0x06,0xA9,0x9C,0x4E,0xB8 } },
+{ 16 , { 0x3F,0x43,0x49,0x56,0x87,0x35,0x32,0xD9,0xD7,0xF8,0x6A,0x4D,0xD5,0x0D,0xAB,0x41 } },
+{ 8 , { 0x07,0xF2,0x3E,0x03,0x8A,0xCD,0x9A,0x33 } },
+{ 16 , { 0x37,0x2F,0x03,0x02,0xBA,0x6A,0x1D,0xBB,0x04,0x41,0x9A,0x2D,0xFC,0x3D,0x2E,0x8B } },
+{ 11 , { 0x32,0xA9,0x46,0xBA,0x15,0xEB,0x89,0xD9,0x31,0xD9,0x3B } },
+{ 11 , { 0x0F,0xC1,0xBA,0x17,0x15,0xD7,0x5D,0xF2,0x4A,0xF0,0x9A } },
+{ 16 , { 0x0F,0xD6,0x67,0x39,0x57,0xFA,0xA9,0xF4,0x07,0xAA,0x67,0x94,0x43,0x80,0x9F,0x92 } },
+{ 15 , { 0x3E,0xF1,0xD0,0x74,0xAB,0x8C,0x65,0x3C,0x6B,0x9D,0x52,0x4A,0x32,0x85,0xE2 } },
+{ 13 , { 0x0F,0xEC,0x54,0xAB,0x98,0xB4,0xC3,0x60,0x44,0xB1,0x0A,0xFF,0xCC } },
+{ 8 , { 0x0F,0x06,0x90,0x91,0x8F,0xE6,0xB9,0xB0 } },
+{ 16 , { 0x37,0xFE,0x8D,0xDC,0xF0,0xEE,0x13,0xCE,0x52,0xF0,0xCF,0x8E,0xC1,0x0F,0x50,0x53 } },
+{ 16 , { 0x3F,0xDA,0xA8,0xA3,0x0E,0xB0,0xD1,0xF9,0x5B,0x84,0xF3,0xA9,0xF4,0x53,0x30,0x9F } },
+{ 16 , { 0x37,0xD1,0x96,0xCE,0x04,0xB2,0x00,0xB3,0xED,0x9D,0x0B,0xF6,0xC5,0x0C,0x8D,0x11 } },
+{ 13 , { 0x4C,0x3E,0x02,0x0A,0xD3,0x0F,0xF4,0x07,0x05,0x8C,0xB2,0x35,0x58 } },
+{ 8 , { 0x07,0xA8,0xF2,0xC2,0x8D,0x4E,0x09,0x17 } },
+{ 16 , { 0x3F,0xB8,0xF0,0x39,0x43,0x6B,0x99,0x0E,0xF9,0xB5,0x8B,0x4B,0xAB,0xF4,0x89,0x9B } },
+{ 15 , { 0x46,0xDC,0x23,0x96,0xFF,0xDA,0x67,0x07,0x43,0x32,0x86,0x98,0xF4,0x16,0xD8 } },
+{ 16 , { 0x37,0x7E,0x89,0xCC,0x0A,0x11,0x5C,0x15,0x44,0xE0,0x7F,0x07,0xD2,0x84,0xD0,0x89 } },
+{ 8 , { 0x07,0x58,0x0B,0xFB,0x86,0x8A,0x15,0x5B } },
+{ 16 , { 0x37,0xE8,0xC7,0xA5,0xFB,0xCA,0x15,0xA3,0x73,0x21,0x48,0xA5,0x01,0xF8,0x02,0x6D } },
+{ 16 , { 0x47,0x90,0xAD,0xAB,0x23,0x9F,0x1C,0xD1,0x07,0xA5,0x2D,0xDA,0x7D,0xD8,0x1A,0x93 } },
+{ 16 , { 0x3F,0x6C,0x78,0xD0,0x93,0x51,0x32,0x13,0xF5,0x31,0x5B,0x81,0x0A,0xC9,0x7D,0x78 } },
+{ 8 , { 0x07,0x1E,0x5E,0xCA,0x94,0xD5,0xAC,0x36 } },
+{ 16 , { 0x37,0x81,0x62,0x6E,0xF0,0x57,0x7B,0xBD,0xA1,0xC6,0x27,0x43,0xFA,0x94,0x60,0x51 } },
+{ 14 , { 0x45,0xC2,0x9B,0xC0,0x3B,0xC3,0x0F,0xAD,0x27,0x05,0x30,0x42,0x8B,0xB5 } },
+{ 16 , { 0x37,0x41,0xB3,0x68,0x5D,0x45,0x9D,0xF6,0x1B,0xA0,0xA8,0xF8,0xE0,0x3C,0x3B,0xE2 } },
+{ 16 , { 0x4F,0x3B,0xC5,0xDD,0x66,0x4E,0x34,0x4D,0x07,0x1B,0xB7,0xB7,0x91,0x0A,0x16,0x02 } },
+{ 8 , { 0x07,0x4E,0xCA,0xA6,0xC9,0xBB,0xED,0x13 } },
+{ 14 , { 0x35,0x6B,0x54,0x76,0xAF,0xAE,0x99,0x31,0x50,0xA1,0xF6,0xCD,0xD8,0x09 } },
+{ 8 , { 0x07,0x0B,0x8E,0x8D,0x4E,0x76,0x43,0xC3 } },
+{ 9 , { 0x38,0xA0,0xDC,0x85,0x10,0x36,0xAF,0x08,0xCF } },
+{ 16 , { 0x0F,0x2C,0xE0,0x87,0x76,0xF5,0x35,0xE6,0x07,0x36,0x11,0xD5,0x54,0xDE,0x1B,0x5F } },
+{ 8 , { 0x07,0xFD,0xE5,0x38,0x62,0xEB,0x5B,0x3A } },
+{ 12 , { 0x3B,0x8D,0x13,0x42,0xDA,0x9C,0xF7,0x44,0xFA,0xF2,0x36,0x63 } },
+{ 12 , { 0x07,0x81,0x52,0xA9,0x09,0x16,0x1C,0x59,0x43,0xA2,0x94,0x52 } },
+{ 8 , { 0x0F,0x03,0x28,0x69,0x47,0xFD,0x3D,0x02 } },
+{ 16 , { 0x3F,0xE6,0x7D,0x07,0x0B,0xF0,0xAA,0xB6,0xCA,0x0D,0x18,0x55,0x53,0xA0,0x56,0x56 } },
+{ 13 , { 0x3C,0x65,0x7D,0xC0,0x23,0x85,0xDD,0x21,0x69,0x7B,0xFF,0x44,0x9E } },
+{ 8 , { 0x0F,0xCD,0x81,0x71,0x90,0x1B,0x42,0x2B } },
+{ 16 , { 0x3F,0x5E,0x33,0x19,0x91,0xD0,0xA2,0x17,0xA6,0xED,0x02,0x84,0x6F,0x4F,0xC0,0x67 } },
+{ 14 , { 0x45,0x60,0x88,0x51,0xD8,0x54,0x07,0xD5,0xD9,0xC3,0x29,0xF0,0x85,0x98 } },
+{ 16 , { 0x07,0x11,0xED,0x7E,0x4A,0xB5,0x85,0x55,0x0F,0xBA,0xCA,0x55,0xBB,0x39,0x2A,0xA6 } },
+{ 16 , { 0x37,0x11,0x18,0xDE,0x57,0xFE,0x66,0x70,0x2D,0x6C,0x56,0x18,0x7F,0x10,0xDF,0xB6 } },
+{ 10 , { 0x39,0xF8,0x7F,0x56,0xE2,0x3A,0x7B,0x55,0x6A,0xEC } },
+{ 8 , { 0x0F,0x0E,0xAD,0x4D,0x8E,0x00,0x06,0xCB } },
+{ 16 , { 0x37,0xAE,0x90,0xE3,0x86,0xA5,0x5C,0x0F,0x2E,0x20,0x78,0x90,0xED,0x54,0x1F,0x18 } },
+{ 15 , { 0x3E,0x61,0x60,0x83,0x21,0xBE,0xCF,0x2E,0x04,0x91,0x4F,0xB4,0xE3,0x60,0xF3 } },
+{ 16 , { 0x0F,0xA6,0x1F,0x08,0x4F,0x81,0x29,0xEC,0x0F,0x18,0x70,0x0D,0x34,0xE9,0x73,0x64 } },
+{ 8 , { 0x0F,0x79,0x96,0x0D,0x78,0xB1,0x0A,0x32 } },
+{ 16 , { 0x37,0x27,0xB5,0x9E,0xEC,0xCD,0xA0,0xD5,0x36,0x15,0xB1,0x77,0x3A,0x71,0x15,0x70 } },
+{ 15 , { 0x36,0xDA,0xD0,0xF9,0xF8,0xB3,0x39,0x6B,0x2D,0xC4,0xD5,0x4B,0xCC,0xAD,0x27 } },
+{ 16 , { 0x07,0xF0,0x92,0x1C,0x74,0x87,0xB9,0x1E,0x07,0xB0,0x9F,0xB5,0x42,0xC6,0x8E,0x0E } },
+{ 12 , { 0x33,0xBE,0x5E,0x78,0xB1,0x9A,0xD7,0xBE,0x8D,0x8E,0x47,0x8E } },
+{ 16 , { 0x0F,0xD1,0x61,0x6F,0x32,0x27,0x55,0xB0,0x47,0x84,0xDB,0xF3,0x19,0xD7,0xCF,0xA0 } },
+{ 16 , { 0x0F,0x4C,0x5E,0xC6,0xAB,0x62,0xB9,0x1C,0x07,0x23,0xA4,0x04,0xBB,0xB7,0xE8,0x3E } },
+{ 16 , { 0x07,0xB9,0x1D,0xEC,0xDA,0x51,0x7C,0xEE,0x07,0xEF,0x36,0x6F,0x99,0xA7,0x60,0xEE } },
+{ 10 , { 0x31,0xF1,0xA1,0xB0,0x7E,0xF4,0xF0,0xFB,0xD7,0x03 } },
+{ 11 , { 0x07,0xA5,0xD3,0x30,0x8B,0x9E,0x18,0xCA,0x4A,0xFE,0xF8 } },
+{ 8 , { 0x0F,0x3C,0x2C,0x93,0xDE,0xDD,0x4D,0x7D } },
+{ 10 , { 0x31,0x3D,0x04,0x75,0x1D,0xD7,0x88,0xCF,0x79,0x47 } },
+{ 14 , { 0x07,0xB0,0x2F,0x40,0xB4,0xBB,0xCD,0xF8,0x45,0x04,0x36,0xAE,0xDD,0x1E } },
+{ 12 , { 0x07,0x20,0x97,0x04,0xCB,0xCD,0x75,0xF6,0x4B,0xF0,0x67,0xFD } },
+{ 8 , { 0x07,0x63,0x8D,0x9E,0xA6,0x73,0x6C,0x66 } },
+{ 16 , { 0x37,0xDD,0xEE,0x63,0xFB,0x69,0xD9,0x97,0x29,0xCD,0x9C,0x28,0xCB,0xF5,0x84,0x14 } },
+{ 14 , { 0x4D,0x6E,0xC5,0x07,0xD3,0xF9,0x07,0x93,0xD9,0xC3,0xA8,0x73,0xCE,0x2D } },
+{ 16 , { 0x0F,0x50,0xA5,0x8D,0xA4,0x37,0x28,0x5F,0x0F,0x52,0xCD,0xA7,0xDC,0xD4,0x65,0xE2 } },
+{ 15 , { 0x4E,0x8C,0xEF,0x15,0x9C,0xBF,0x86,0x07,0x2E,0x1F,0x32,0xA7,0x2F,0x6B,0x57 } },
+{ 16 , { 0x0F,0x91,0x68,0xD0,0x0B,0x9C,0xD5,0xE4,0x0F,0xFF,0x25,0x1C,0x00,0xF7,0xAB,0xFD } },
+{ 16 , { 0x3F,0x13,0x90,0x4A,0x31,0xAA,0x30,0xFD,0x23,0x42,0x47,0x48,0x93,0x6A,0x67,0xE1 } },
+{ 16 , { 0x37,0x18,0x15,0x7E,0xC8,0x54,0xB6,0x4E,0x2A,0xC6,0x5E,0x7B,0x10,0x33,0x6E,0x4A } },
+{ 16 , { 0x3F,0x1F,0x68,0xD6,0xE9,0xC4,0x67,0x0A,0x85,0x73,0x8F,0x2C,0xED,0xBF,0x28,0x05 } },
+{ 10 , { 0x49,0xC3,0x07,0x50,0x3B,0x78,0xBE,0x7A,0xEC,0x55 } },
+{ 16 , { 0x37,0xA6,0x01,0x77,0x03,0x70,0xA6,0xAF,0x1D,0x20,0x64,0xB5,0xD1,0x65,0xAA,0xAF } },
+{ 12 , { 0x3B,0x66,0x4A,0x9E,0x1C,0x9B,0xBF,0xC2,0xBD,0xE1,0x2D,0xC8 } },
+{ 8 , { 0x07,0xE8,0xD1,0x66,0x37,0x01,0x14,0xB8 } },
+{ 9 , { 0x30,0xA6,0xD6,0xD4,0x63,0x39,0x57,0x59,0x07 } },
+{ 16 , { 0x0F,0xDF,0x1B,0xDB,0xE2,0xBA,0x2B,0x24,0x0F,0x7B,0xBB,0x49,0x89,0xC8,0x66,0x1F } },
+{ 8 , { 0x07,0x9E,0x4E,0x3E,0x1A,0x84,0xC2,0x54 } },
+{ 16 , { 0x37,0xD7,0x37,0x60,0x62,0xC9,0x78,0x31,0x90,0xC7,0xA2,0x94,0xF0,0x52,0xC4,0xF9 } },
+{ 16 , { 0x3F,0x05,0x4D,0xE0,0xE2,0x40,0xA7,0x92,0x03,0x1C,0xB0,0x0B,0xED,0xFF,0x7D,0xE9 } },
+{ 10 , { 0x39,0xDE,0xA0,0x71,0x01,0x82,0xA7,0x55,0x2A,0x84 } },
+{ 8 , { 0x0F,0x15,0x60,0xBF,0xAE,0x55,0xDF,0xE3 } },
+{ 16 , { 0x3F,0x75,0xB1,0x9F,0x82,0x1A,0x65,0x0D,0x59,0x65,0x2F,0x10,0x51,0xA8,0x95,0x7D } },
+{ 10 , { 0x41,0xD2,0x0F,0x44,0x8F,0x80,0x6C,0xF0,0x4B,0x43 } },
+{ 12 , { 0x0F,0x28,0x34,0xC5,0x8D,0x81,0xD1,0xBE,0x43,0x77,0x0A,0x5D } },
+{ 8 , { 0x07,0xD9,0xBA,0x5C,0xE1,0xD0,0x70,0x8E } },
+{ 16 , { 0x3F,0x93,0xDC,0x98,0x4F,0x52,0xBC,0x9E,0x11,0x1A,0x45,0x53,0x67,0xE4,0x49,0x3F } },
+{ 13 , { 0x4C,0xA0,0xA1,0x4B,0xD1,0x07,0x25,0x20,0xC2,0x6E,0x39,0x89,0x4C } },
+{ 16 , { 0x07,0x87,0x44,0xBF,0x88,0x9A,0x36,0x6D,0x07,0xB4,0x0A,0x8E,0xAD,0x38,0x07,0xA2 } },
+{ 15 , { 0x4E,0x41,0x05,0xA4,0x52,0x84,0x93,0x07,0x50,0xDD,0x56,0x01,0x5A,0x8B,0xAE } },
+{ 16 , { 0x3F,0x5F,0x20,0xA9,0xC3,0x5E,0x96,0xE1,0xAD,0x1F,0x47,0x05,0x73,0xBA,0x67,0x30 } },
+{ 16 , { 0x3F,0x8B,0x9C,0x55,0x2E,0x6A,0x7F,0x88,0x87,0x61,0xDA,0x61,0x85,0xE1,0x6D,0xD4 } },
+{ 16 , { 0x3F,0xA1,0x4B,0xD7,0x69,0xD3,0xF0,0xB5,0x84,0x23,0xFF,0x2E,0x75,0x1C,0x3D,0x29 } },
+{ 9 , { 0x30,0x39,0x00,0xC9,0xFA,0x81,0x8D,0xEC,0x39 } },
+{ 8 , { 0x0F,0x2E,0x6E,0x74,0x4A,0x61,0xCF,0x65 } },
+{ 16 , { 0x3F,0x47,0x90,0xE3,0x6B,0x9D,0x69,0x94,0xF6,0x41,0x74,0xD4,0xA8,0x6E,0xFF,0x1A } },
+{ 11 , { 0x3A,0x51,0xCA,0xC7,0xFB,0x0F,0x80,0x84,0x69,0xA5,0x77 } },
+{ 16 , { 0x0F,0x02,0x65,0xA8,0x3C,0x56,0x34,0x5A,0x07,0x1D,0xFB,0xB0,0x28,0x1C,0xF2,0x46 } },
+{ 14 , { 0x45,0x3E,0x3B,0xCD,0xB4,0x0D,0x07,0x19,0x55,0x8D,0x5C,0x47,0x5C,0xEE } },
+{ 12 , { 0x43,0x40,0x9A,0xA5,0x0F,0x85,0x9F,0x44,0xD6,0x13,0x96,0x52 } },
+{ 16 , { 0x3F,0x4A,0x42,0x0D,0xEA,0x94,0x6F,0xF2,0x71,0xE0,0xF4,0xCE,0xE8,0x06,0xB9,0x70 } },
+{ 16 , { 0x37,0x42,0x01,0x45,0xFB,0x15,0x97,0xB9,0xDB,0x1D,0x6F,0x85,0x2E,0xCF,0xFB,0x46 } },
+{ 16 , { 0x3F,0xB0,0x3F,0x54,0xAE,0x7B,0xD1,0xCB,0xB9,0xE3,0x61,0x66,0x45,0xAD,0x8A,0xD4 } },
+{ 13 , { 0x44,0x77,0x86,0x5D,0x20,0x07,0x55,0xD0,0xB1,0xE4,0x79,0x66,0xC5 } },
+{ 8 , { 0x07,0x97,0xBB,0x36,0xC6,0xCA,0x63,0x7B } },
+{ 14 , { 0x35,0xFE,0x06,0x3A,0xB5,0x7A,0x96,0x81,0x71,0x20,0xB7,0x92,0x02,0xA4 } },
+{ 8 , { 0x07,0x4C,0xED,0x96,0x46,0x61,0xEE,0x30 } },
+{ 16 , { 0x3F,0xFF,0x0D,0x10,0xE7,0x39,0x25,0xC2,0xCA,0xBC,0x8B,0x3D,0x5A,0x44,0xA4,0xF8 } },
+{ 15 , { 0x46,0xEB,0xAA,0x98,0xE9,0x2C,0xBD,0x07,0x01,0x63,0x82,0x19,0x65,0x31,0x84 } },
+{ 16 , { 0x3F,0x58,0xFA,0x1E,0x5D,0x4E,0x9A,0xCF,0x1C,0x51,0x7B,0xE2,0x8D,0xE6,0xA2,0x10 } },
+{ 16 , { 0x37,0x94,0x7B,0x52,0x03,0xC5,0x18,0x86,0xB6,0xD1,0x44,0x3B,0xBD,0x69,0xDC,0x21 } },
+{ 16 , { 0x3F,0xB9,0x57,0xEA,0xA5,0x13,0xBE,0x6B,0xF3,0x0A,0x54,0x85,0x8D,0x77,0x44,0x69 } },
+{ 16 , { 0x37,0x29,0xB7,0xE1,0xAD,0xC0,0x47,0x53,0xB2,0x3F,0x10,0x9E,0xDC,0x70,0x71,0x22 } },
+{ 16 , { 0x3F,0x14,0xCA,0x0D,0x42,0x9B,0x02,0x25,0xD5,0x43,0xBD,0xB4,0xB4,0xF4,0x0E,0x8A } },
+{ 14 , { 0x4D,0xE6,0xF8,0xC8,0x36,0x22,0x07,0x67,0xC0,0x28,0x4F,0xB4,0xF0,0xBF } },
+{ 13 , { 0x44,0xB0,0x86,0x2E,0x98,0x07,0x5A,0x2B,0x23,0x14,0x75,0x08,0x85 } },
+{ 12 , { 0x4B,0x37,0x90,0x92,0x0F,0x69,0x7F,0x43,0xE5,0x5E,0x1D,0xBA } },
+{ 16 , { 0x37,0x6F,0xED,0x83,0x81,0x1B,0x11,0x4C,0x27,0x82,0x22,0x32,0x74,0xCB,0xBF,0xB4 } },
+{ 16 , { 0x37,0x8E,0xFC,0xDC,0x2D,0x93,0xA8,0x19,0x58,0x86,0x3B,0x74,0xB0,0xB7,0x79,0x5C } },
+{ 16 , { 0x47,0x0E,0xA6,0xEF,0xBF,0x9B,0xAF,0x73,0x07,0xAB,0xDE,0xF0,0x70,0x07,0xBA,0xCB } },
+{ 11 , { 0x4A,0x43,0xCC,0x07,0x69,0x9B,0xED,0x59,0x5C,0x91,0xED } },
+{ 9 , { 0x30,0xEB,0xA0,0xA2,0x75,0xD2,0x2B,0xA3,0x52 } },
+{ 16 , { 0x07,0xF3,0xB4,0xA9,0x75,0x4C,0x97,0xC6,0x07,0x33,0x44,0x76,0x7A,0xD1,0xF2,0x4E } },
+{ 16 , { 0x07,0x65,0x1C,0xAB,0xE1,0x9E,0x83,0xCC,0x0F,0x77,0x0B,0xB9,0x11,0x65,0x59,0x4A } },
+{ 15 , { 0x0F,0x45,0xDD,0xE8,0x58,0x2B,0x7B,0xB0,0x46,0x55,0x36,0x83,0x02,0xC7,0xED } },
+{ 16 , { 0x0F,0x8F,0xB9,0x0D,0xB4,0xA1,0x23,0x21,0x0F,0x35,0x51,0x00,0xD1,0xC9,0x1C,0x59 } },
+{ 13 , { 0x3C,0x89,0x2D,0x0D,0x45,0x36,0x2F,0x46,0x28,0xDC,0x43,0x95,0xE1 } },
+{ 8 , { 0x0F,0x77,0x09,0x07,0x56,0xBC,0x50,0xD4 } },
+{ 16 , { 0x37,0x9C,0x70,0x02,0xEE,0x41,0xB2,0x36,0xA7,0x99,0x6E,0x5E,0xAD,0xAB,0x1B,0x01 } },
+{ 16 , { 0x3F,0x8A,0xA8,0xBD,0x6E,0x6A,0x74,0x37,0xF7,0x2A,0x89,0x47,0x91,0x75,0x4C,0xFB } },
+{ 14 , { 0x45,0xE5,0x74,0xB2,0xBB,0x6E,0x0F,0x3B,0xC4,0x2E,0x57,0xDA,0x90,0x9B } },
+{ 12 , { 0x3B,0xD1,0xB0,0xFC,0x79,0xBD,0xF5,0xB8,0xA4,0x63,0x37,0x97 } },
+{ 16 , { 0x0F,0x54,0xEA,0x19,0x33,0x1F,0x43,0x1E,0x0F,0xE7,0x32,0x43,0xAE,0x27,0xFB,0xD2 } },
+{ 8 , { 0x0F,0x3A,0x48,0x55,0x48,0x5A,0x16,0x0E } },
+{ 11 , { 0x3A,0xBF,0xA9,0x8D,0x02,0x34,0x58,0x6D,0xE0,0x89,0x6A } },
+{ 8 , { 0x0F,0x84,0xDF,0xCA,0xFD,0x33,0x0C,0xFF } },
+{ 12 , { 0x3B,0x6D,0x30,0x86,0x93,0x33,0x8B,0xBD,0x86,0xFE,0x86,0xDB } },
+{ 8 , { 0x07,0x98,0x0C,0x52,0x0F,0xC3,0x23,0x6A } },
+{ 10 , { 0x39,0x89,0xF5,0x34,0x03,0xF0,0xAE,0x70,0xA0,0x33 } },
+{ 11 , { 0x0F,0x12,0x47,0x09,0x2D,0x0F,0xBC,0xF8,0x42,0x67,0xAE } },
+{ 14 , { 0x07,0xED,0x76,0x41,0xC2,0xD3,0x39,0xDE,0x45,0x4F,0x2B,0x2E,0x2C,0x89 } },
+{ 14 , { 0x07,0xFB,0xBA,0x30,0xC0,0xDD,0xF5,0x06,0x45,0x10,0x62,0x58,0x63,0xA0 } },
+{ 8 , { 0x07,0xED,0xA3,0x2A,0xAE,0x0F,0x91,0xDB } },
+{ 16 , { 0x3F,0xB1,0xC1,0xF6,0xEF,0x12,0x9B,0x3E,0x65,0xF7,0x4F,0x21,0x31,0xB8,0x2E,0x23 } },
+{ 12 , { 0x3B,0x9C,0xD2,0xE4,0x4C,0xAD,0x3F,0xF1,0x3D,0xF7,0xBD,0x56 } },
+{ 12 , { 0x07,0x01,0xEA,0x75,0xF4,0x2A,0xD3,0xC6,0x4B,0xDC,0x4C,0x6A } },
+{ 16 , { 0x0F,0xA2,0x38,0xE3,0xBF,0x4E,0x78,0x83,0x0F,0xCC,0x5A,0x4E,0x96,0xB0,0x2E,0xFA } },
+{ 8 , { 0x07,0xE8,0x5A,0x55,0x26,0x2C,0xB5,0x1D } },
+{ 16 , { 0x3F,0x26,0xEF,0x93,0x95,0x13,0x6A,0x36,0xE3,0x81,0x81,0x9A,0x6C,0x00,0x21,0x60 } },
+{ 16 , { 0x3F,0x6D,0xF1,0x70,0x5F,0x19,0xDD,0xB9,0x28,0xB1,0xE8,0x06,0xF1,0x35,0x7F,0x14 } },
+{ 16 , { 0x37,0xAE,0x87,0x10,0xD7,0xCF,0x8F,0xD6,0xBF,0x53,0x76,0x3A,0xD4,0x94,0x1A,0xEC } },
+{ 16 , { 0x37,0xC5,0x41,0xC5,0x2A,0x32,0x72,0x9A,0x4A,0x62,0x88,0xD3,0x1E,0x58,0xED,0x5A } },
+{ 16 , { 0x37,0x41,0x33,0xA6,0xB2,0x4C,0xF2,0x01,0x92,0x14,0xBD,0x7D,0xB2,0x3F,0xEF,0xE1 } },
+{ 16 , { 0x3F,0xEC,0x09,0xF1,0x3D,0x09,0xFE,0x0B,0xA9,0xEA,0xAB,0x45,0x72,0xA4,0x1F,0x43 } },
+{ 15 , { 0x3E,0x3D,0xD0,0x37,0xBA,0xE9,0xB6,0xDE,0xE4,0xAF,0x22,0x7A,0x18,0x48,0xEE } },
+{ 8 , { 0x0F,0x05,0xF1,0x64,0x74,0x28,0x1B,0x93 } },
+{ 16 , { 0x37,0x47,0x68,0xA8,0x7F,0x0E,0x0A,0xD4,0x6C,0xC0,0x0D,0xF0,0x82,0x86,0x83,0x1E } },
+{ 16 , { 0x37,0xBD,0x51,0x92,0x8E,0xCE,0x04,0x83,0x95,0xBC,0xAB,0x2A,0x2B,0x5D,0x5D,0x85 } },
+{ 16 , { 0x3F,0x39,0x1C,0x2C,0x62,0x37,0x74,0xF4,0xBF,0xB1,0x96,0x75,0xBC,0x6B,0x81,0xFD } },
+{ 16 , { 0x37,0x24,0xC9,0xFA,0x39,0xD8,0xC1,0x40,0x49,0x78,0x4A,0x0A,0xAB,0x0E,0x6F,0x34 } },
+{ 16 , { 0x3F,0xB0,0x13,0xBA,0x55,0x70,0x67,0x51,0x34,0x87,0xA9,0x8C,0x5B,0x4F,0x6A,0x14 } },
+{ 16 , { 0x37,0xC9,0x85,0xCD,0xFB,0xF9,0x87,0x68,0x1B,0xB6,0xB6,0xED,0x4A,0x03,0xC5,0xE3 } },
+{ 16 , { 0x37,0xA8,0x1D,0xFA,0x88,0xBA,0x0E,0x45,0x98,0x9C,0xCC,0x15,0xCC,0x6C,0x34,0xC6 } },
+{ 16 , { 0x37,0x12,0x71,0x87,0x21,0xD8,0x35,0x81,0xFE,0x50,0xEB,0x70,0x9B,0x3D,0x0F,0x24 } },
+{ 16 , { 0x37,0x48,0x21,0xC0,0x54,0xEB,0x80,0xBE,0x58,0x2C,0x7A,0xBF,0xE1,0x55,0xAC,0x0A } },
+{ 16 , { 0x3F,0xAC,0xE6,0x81,0x16,0xE1,0x94,0x35,0x9E,0x3F,0x44,0x01,0xD9,0x39,0xF6,0x96 } },
+{ 16 , { 0x3F,0x87,0x2E,0xC2,0x20,0x44,0x09,0x82,0xD5,0x5A,0xF0,0x5C,0x4F,0x4A,0x24,0xE4 } },
+{ 16 , { 0x37,0x58,0x7B,0x6F,0x8C,0xF9,0x84,0x6A,0x60,0xDB,0xB7,0xBB,0x2C,0x13,0xBF,0x2B } },
+{ 16 , { 0x37,0xD8,0x21,0x0F,0x40,0x35,0x0E,0x46,0x72,0x27,0x4A,0x4E,0x88,0x8E,0x27,0xF8 } },
+{ 10 , { 0x39,0x8C,0x56,0x15,0xF5,0xE2,0xAA,0x99,0x98,0x80 } },
+{ 8 , { 0x0F,0x5A,0x04,0xD3,0x73,0x75,0x7D,0x5A } },
+{ 14 , { 0x35,0xC7,0x99,0x87,0xBC,0xC8,0x19,0xF8,0xC0,0xFA,0xAD,0x03,0xF7,0xE5 } },
+{ 8 , { 0x07,0x7F,0xA5,0xD1,0xCC,0x2F,0xA2,0x83 } },
+{ 16 , { 0x3F,0x53,0xD7,0xC5,0xE9,0xD5,0xC2,0x72,0xAC,0x4F,0xF9,0xE1,0x13,0x0E,0x8B,0x76 } },
+{ 16 , { 0x3F,0x9C,0xFD,0xFC,0x8B,0x2A,0x8C,0x58,0x20,0xC5,0x4B,0x79,0x5A,0x7A,0xC8,0x35 } },
+{ 16 , { 0x37,0x52,0x61,0x5D,0x2C,0x37,0x3C,0x7C,0x27,0x2B,0x56,0x28,0xA4,0x29,0x89,0x0E } },
+{ 16 , { 0x3F,0xDE,0x96,0x85,0x21,0x5B,0x42,0x0E,0x23,0xD3,0xBF,0xDC,0x3C,0x36,0x55,0xE5 } },
+{ 16 , { 0x3F,0xE6,0x7E,0x72,0x37,0x4E,0x37,0xEB,0x3E,0x80,0xEE,0x8F,0xED,0x4C,0xBE,0xE0 } },
+{ 11 , { 0x3A,0xF7,0xAD,0xD0,0x67,0x3F,0xFA,0x83,0xD9,0x46,0xC5 } },
+{ 8 , { 0x07,0x41,0xDB,0x56,0x6C,0xEF,0xDF,0xA9 } },
+{ 16 , { 0x3F,0x7B,0x59,0xE3,0x57,0x3A,0x43,0x46,0xA3,0xFB,0x1B,0xC4,0xCD,0x40,0x5B,0xBB } },
+{ 16 , { 0x3F,0x3D,0x37,0x62,0xE9,0x61,0x90,0x2C,0xAA,0x1C,0x53,0xCD,0x16,0x3D,0xEA,0xE9 } },
+{ 16 , { 0x37,0x5E,0xAC,0xDC,0x22,0xD4,0x48,0xE1,0x0E,0x2E,0x46,0xB4,0xFC,0xD7,0x92,0xB9 } },
+{ 16 , { 0x37,0x00,0x45,0xE4,0x2C,0x11,0xB7,0x3A,0x79,0x67,0x7F,0x45,0x86,0xB2,0xE5,0xD8 } },
+{ 10 , { 0x41,0x4F,0x07,0x91,0x17,0x0B,0xDD,0x28,0xDE,0x9F } },
+{ 16 , { 0x3F,0x9B,0x06,0x46,0x87,0xF1,0x83,0x1F,0xDD,0xE4,0x4D,0xD4,0xAB,0x0F,0x51,0x8E } },
+{ 16 , { 0x37,0x01,0x73,0x10,0x44,0x79,0xF4,0x00,0x00,0x55,0x5D,0x87,0x88,0xFD,0x11,0x5D } },
+{ 11 , { 0x32,0x78,0x0B,0xA8,0x77,0x42,0x2B,0xD6,0xB5,0xFC,0x55 } },
+{ 8 , { 0x0F,0x8D,0x29,0x21,0xFD,0x22,0xCA,0xB7 } },
+{ 16 , { 0x37,0x08,0x2C,0x76,0xDA,0x2B,0xDC,0x12,0xAB,0xC0,0x94,0xC5,0x1D,0x6D,0x7F,0x0B } },
+{ 16 , { 0x37,0xB6,0x4A,0xC6,0xE0,0x36,0xC6,0x51,0x27,0x90,0x3B,0xAA,0xDD,0x85,0x62,0xBC } },
+{ 16 , { 0x3F,0xA0,0x29,0x29,0x43,0xB0,0x96,0x14,0xF9,0x6B,0x86,0xBD,0xBD,0xAD,0x99,0x85 } },
+{ 16 , { 0x3F,0xB0,0x4F,0x3B,0x70,0x33,0xB4,0x4D,0x51,0xA8,0x61,0xAA,0xDF,0x6F,0xDC,0x4B } },
+{ 16 , { 0x37,0x1C,0x91,0x82,0xCC,0xF8,0x51,0x02,0xE3,0x2C,0x29,0x76,0x02,0x2E,0x48,0x3D } },
+{ 16 , { 0x4F,0x93,0x5F,0x26,0xA3,0xA8,0x6A,0x4B,0x07,0xEA,0x6C,0x7C,0xED,0x1A,0x18,0x89 } },
+{ 13 , { 0x3C,0x35,0xDE,0xE4,0xF2,0x10,0xC7,0x6B,0xF3,0x4A,0x92,0x71,0xFC } },
+{ 16 , { 0x07,0xAC,0xD9,0x0E,0xBB,0x10,0xFA,0xF4,0x07,0xB6,0x10,0x48,0x8B,0x75,0x88,0x08 } },
+{ 8 , { 0x0F,0x48,0xCC,0x6D,0xC4,0x40,0x1F,0xAD } },
+{ 9 , { 0x38,0x46,0x81,0xAD,0x86,0x94,0x7F,0x98,0xFA } },
+{ 8 , { 0x07,0x9C,0xEB,0x03,0x7C,0x62,0xB9,0x25 } },
+{ 16 , { 0x3F,0x8D,0xC0,0x24,0xF9,0x4E,0xB5,0xE0,0x05,0x37,0xBE,0x8A,0x8A,0xCC,0xE1,0x9B } },
+{ 16 , { 0x3F,0xED,0xD6,0x84,0x39,0x2D,0xAD,0xF2,0xD1,0xC9,0x98,0x58,0xD3,0xBB,0x7D,0x4A } },
+{ 16 , { 0x47,0x6D,0x97,0x3E,0x93,0xF7,0x16,0xFE,0x07,0x82,0xA5,0xD2,0x9A,0xF0,0x19,0x3C } },
+{ 16 , { 0x3F,0x68,0x5C,0x5A,0x3F,0xA7,0xE7,0x42,0xC6,0x2A,0x6C,0x3B,0xE7,0xC7,0x7B,0xE1 } },
+{ 11 , { 0x42,0xCB,0x39,0x07,0x59,0x5C,0x8C,0xF3,0xB1,0x46,0x37 } },
+{ 16 , { 0x3F,0x3B,0xC2,0x98,0xBD,0x94,0x10,0x15,0xBC,0x76,0xA0,0x98,0x8E,0x6F,0x09,0xEA } },
+{ 12 , { 0x4B,0x9E,0x75,0x9C,0x0F,0x2E,0xED,0xEE,0x09,0x3B,0x0F,0xDF } },
+{ 16 , { 0x0F,0x70,0x5B,0x7D,0x1A,0x36,0x09,0x14,0x0F,0x18,0xDD,0x9D,0x72,0x99,0x10,0x51 } },
+{ 16 , { 0x37,0x46,0x82,0x0C,0xF3,0xF5,0xA7,0x33,0xFD,0xD3,0x54,0xDE,0xC0,0x97,0xEF,0x49 } },
+{ 11 , { 0x4A,0x61,0xE7,0x07,0xE6,0x7F,0x70,0xB9,0xC2,0xBC,0x1B } },
+{ 16 , { 0x07,0xCC,0x93,0x86,0xE0,0x2B,0x4D,0x3D,0x07,0x23,0x8A,0x2F,0xD7,0x49,0x9A,0x6D } },
+{ 8 , { 0x07,0x0A,0xCF,0x3A,0x24,0x67,0x2A,0x63 } },
+{ 11 , { 0x3A,0xC2,0xC9,0x06,0x90,0xBD,0x45,0x5D,0xAB,0xFC,0x7C } },
+{ 13 , { 0x0F,0x5C,0x63,0xB6,0xE8,0xF8,0x4C,0x03,0x4C,0x13,0xC5,0x44,0x45 } },
+{ 16 , { 0x0F,0xB5,0x7F,0xFF,0xF8,0x2C,0xA7,0x7A,0x4F,0xD1,0xAA,0x18,0x7A,0x42,0xE7,0x6A } },
+{ 8 , { 0x07,0x56,0xFD,0xCA,0x84,0x27,0x09,0xA0 } },
+{ 15 , { 0x36,0x5F,0x77,0x76,0x77,0x10,0xEE,0x1D,0x1B,0x5D,0x32,0xCB,0xC5,0x1F,0x1E } },
+{ 15 , { 0x07,0x49,0x7D,0x86,0xE2,0x53,0x2A,0x36,0x46,0xC3,0xC2,0x2D,0xCB,0xBB,0xC4 } },
+{ 16 , { 0x0F,0xDC,0x74,0x41,0xCA,0xC6,0x87,0xC5,0x07,0x24,0x52,0x58,0x1B,0x73,0xE3,0xDF } },
+{ 15 , { 0x46,0x69,0x5B,0xFF,0x46,0xA8,0xD0,0x07,0xE3,0x46,0x2C,0x1B,0xA6,0x12,0x30 } },
+{ 16 , { 0x37,0xD4,0xE0,0xD1,0xDA,0x09,0xE6,0x65,0x3B,0xC6,0x2C,0xA9,0x8A,0x5B,0x59,0xF8 } },
+{ 16 , { 0x37,0x6A,0x6D,0x61,0x48,0x58,0x13,0xB1,0x48,0xE9,0xD9,0x0F,0x8E,0x22,0x30,0x9D } },
+{ 16 , { 0x37,0x84,0xE6,0x21,0xFD,0x23,0xA9,0x85,0x23,0x52,0x68,0x2C,0xDE,0x07,0x9F,0x06 } },
+{ 16 , { 0x37,0xBF,0x16,0xA5,0x7E,0x14,0x45,0xE2,0x20,0xDC,0x77,0x5E,0xF1,0xF8,0xB8,0xB2 } },
+{ 16 , { 0x3F,0x0D,0x41,0x9B,0x88,0x55,0x39,0x4A,0x33,0xA9,0x0F,0x26,0x8B,0xFC,0x70,0xAC } },
+{ 10 , { 0x41,0x70,0x0F,0x76,0xBD,0x5A,0xED,0x08,0x09,0x04 } },
+{ 16 , { 0x0F,0xEA,0x6E,0x20,0xC8,0xD3,0x19,0xA3,0x07,0x60,0x16,0x50,0x6C,0xC9,0x4B,0x6F } },
+{ 11 , { 0x32,0x97,0x0F,0x94,0x24,0x6C,0x5F,0x97,0xC2,0xE2,0x55 } },
+{ 13 , { 0x0F,0x7C,0x3E,0xA8,0x8C,0xC4,0xF4,0x83,0x44,0x24,0x5A,0x1B,0xF2 } },
+{ 8 , { 0x07,0x01,0xC5,0x03,0x17,0x44,0xB9,0x97 } },
+{ 16 , { 0x37,0x75,0x9A,0xD9,0x9C,0x26,0x49,0x09,0xDF,0xCB,0x23,0x2E,0xF6,0xBD,0xB3,0x92 } },
+{ 11 , { 0x32,0xE5,0xCF,0x57,0x9C,0xF4,0x13,0x27,0xC8,0xD8,0xD9 } },
+{ 11 , { 0x0F,0xCE,0xF0,0x4A,0x6C,0xDF,0x4F,0xF5,0x4A,0xB2,0x1D } },
+{ 8 , { 0x0F,0x32,0xC1,0x9A,0xAC,0x00,0xB0,0x79 } },
+{ 16 , { 0x3F,0xEB,0x6B,0x6A,0x75,0xE5,0x01,0x4A,0x73,0x44,0x54,0x49,0x34,0xA9,0x9A,0x1A } },
+{ 16 , { 0x4F,0x7D,0xBE,0x96,0xC1,0x63,0x46,0x61,0x07,0xAC,0x09,0x7D,0x47,0xDC,0x62,0xB3 } },
+{ 14 , { 0x35,0x6F,0x4E,0x24,0xCB,0x25,0x62,0xA6,0xAB,0x37,0xE2,0xAC,0xE3,0x13 } },
+{ 16 , { 0x07,0x93,0x60,0x60,0xB1,0x8D,0xC6,0xBB,0x07,0x29,0xBC,0x5C,0x13,0x8D,0x39,0xF4 } },
+{ 8 , { 0x0F,0xAF,0x57,0xC7,0xB8,0x9E,0x72,0x0F } },
+{ 16 , { 0x37,0xF0,0xC3,0x26,0xAA,0x26,0x48,0x7C,0x42,0xCA,0xB8,0x23,0x1B,0xC4,0xE8,0xB3 } },
+{ 15 , { 0x46,0x67,0xC8,0xF8,0x0A,0x70,0x94,0x07,0x3C,0xF5,0xC8,0x66,0xE9,0x14,0x0C } },
+{ 15 , { 0x36,0xA5,0x8E,0x38,0x1A,0xED,0x60,0x56,0x31,0x78,0xDE,0x6A,0x96,0xE3,0xEE } },
+{ 16 , { 0x0F,0xAC,0x49,0xAD,0xBB,0x3B,0xCA,0x70,0x07,0xF7,0x4E,0xFC,0xE8,0x34,0x3E,0x7E } },
+{ 8 , { 0x0F,0xE4,0xAE,0xEE,0x2B,0x08,0xEE,0xD0 } },
+{ 16 , { 0x3F,0xE7,0x40,0x35,0x54,0xDF,0x0F,0x71,0x4A,0x92,0xC3,0xDF,0x8B,0x52,0x72,0xE7 } },
+{ 12 , { 0x33,0x3C,0x92,0x3B,0xA2,0x2F,0x2D,0xD5,0x38,0xBB,0xF4,0xC1 } },
+{ 8 , { 0x0F,0x07,0xFC,0x05,0xBB,0x58,0x06,0x5A } },
+{ 9 , { 0x38,0x37,0x9A,0x45,0x6F,0x99,0xCE,0xC9,0xF6 } },
+{ 16 , { 0x0F,0x72,0x45,0xC8,0x00,0x0D,0x68,0xAA,0x07,0xDE,0xDF,0x82,0x69,0x0E,0x32,0xE9 } },
+{ 16 , { 0x07,0x78,0xC1,0x67,0x9E,0x54,0x8A,0x2B,0x07,0xEA,0xA7,0x77,0xD4,0x9E,0xE5,0xE3 } },
+{ 8 , { 0x07,0xB6,0xB9,0xFE,0xBE,0xD9,0x74,0x8A } },
+{ 12 , { 0x33,0x88,0x98,0xA2,0xC2,0x9F,0x73,0x68,0x12,0xAB,0xC5,0x1C } },
+{ 8 , { 0x07,0xBB,0xD3,0x37,0x63,0x4C,0x82,0x3F } },
+{ 16 , { 0x3F,0xD3,0xD1,0xD6,0x5A,0xED,0x66,0xB7,0xAB,0x9F,0x84,0xE6,0xE5,0x0F,0x1E,0x93 } },
+{ 16 , { 0x37,0xFB,0x70,0x41,0x8C,0xD8,0x54,0x2A,0x99,0xD0,0x57,0x8F,0xE7,0x09,0x91,0x3C } },
+{ 16 , { 0x37,0x5B,0x65,0x7A,0x89,0x19,0xF8,0xAD,0x6E,0x25,0x02,0x48,0xA4,0xBE,0xE2,0xD2 } },
+{ 16 , { 0x3F,0x2C,0x56,0x91,0xB0,0xFA,0x21,0x6E,0x88,0xC0,0x24,0x84,0x93,0xBA,0xC7,0x6E } },
+{ 16 , { 0x3F,0xD6,0x00,0x15,0x3F,0x12,0x31,0x6D,0x12,0x53,0x27,0xDC,0xAC,0x8C,0x77,0xED } },
+{ 13 , { 0x44,0xD3,0x8E,0xEF,0xE2,0x0F,0x81,0xD6,0xCB,0xBA,0xA0,0x64,0x40 } },
+{ 16 , { 0x37,0xDC,0x24,0xEA,0x2D,0xCB,0x61,0xA7,0x1A,0x97,0xFF,0x6B,0xA0,0x5C,0xB8,0xF9 } },
+{ 16 , { 0x37,0x30,0x53,0x4C,0x24,0x5D,0x31,0x12,0x57,0x02,0x7C,0x0E,0x41,0x80,0x79,0xC1 } },
+{ 10 , { 0x49,0xC8,0x0F,0x23,0x35,0xC5,0xD2,0x8A,0xC9,0x16 } },
+{ 16 , { 0x37,0x3C,0xED,0x06,0x89,0xCA,0x5C,0xE6,0x02,0x2E,0x09,0xA2,0xC3,0xF0,0x64,0x32 } },
+{ 16 , { 0x0F,0xF2,0x4F,0x8F,0xDE,0x9F,0xBA,0x5C,0x0F,0x67,0xB2,0xC5,0xB9,0x28,0xCC,0x2E } },
+{ 16 , { 0x07,0xF8,0xE1,0xF2,0x5E,0xFF,0xCE,0xC6,0x07,0x9F,0x9D,0x23,0x64,0xAC,0x9B,0x67 } },
+{ 16 , { 0x07,0x2A,0x4C,0x3D,0x14,0xBB,0xD4,0x31,0x0F,0x0C,0x24,0xD2,0x12,0x8C,0xD1,0x65 } },
+{ 16 , { 0x37,0x12,0x02,0x1B,0xEC,0x92,0xEF,0x9E,0x56,0xA7,0x96,0x6E,0xB2,0x8D,0x12,0x2F } },
+{ 16 , { 0x37,0xAB,0x09,0x10,0x3C,0x5C,0x1C,0xE5,0x4A,0x38,0x19,0xC8,0x7A,0xA9,0x7C,0x60 } },
+{ 16 , { 0x3F,0x05,0xDE,0x7F,0x76,0x75,0x33,0x73,0x43,0x68,0xB4,0xC2,0xD0,0xA8,0x47,0xAC } },
+{ 16 , { 0x3F,0x40,0xE3,0xB5,0x09,0xF4,0xF0,0x07,0x1A,0x4E,0x61,0x25,0x0D,0x25,0x34,0x28 } },
+{ 16 , { 0x3F,0x77,0xA1,0xA0,0xC2,0x84,0x9F,0x70,0xF0,0x5F,0x71,0x0E,0x1F,0x68,0xA7,0x3F } },
+{ 16 , { 0x3F,0x3A,0x52,0x96,0x83,0x9A,0x02,0x06,0x35,0x2A,0x1C,0x3A,0x75,0xBA,0x65,0xD8 } },
+{ 12 , { 0x43,0x34,0x82,0x22,0x07,0xDE,0x9A,0xE0,0xE3,0x0C,0x23,0x86 } },
+{ 16 , { 0x37,0x1F,0x51,0x23,0xD9,0x7B,0x66,0x1C,0x8C,0xE0,0xA5,0xB6,0xA8,0x89,0xA3,0x4C } },
+{ 16 , { 0x37,0xB2,0xC7,0x45,0x42,0xCA,0x16,0xE9,0x86,0xEA,0xA9,0x8A,0x22,0xEF,0xB4,0xCA } },
+{ 16 , { 0x37,0xD7,0xD1,0x5F,0x7B,0x33,0x07,0x21,0x52,0x59,0x61,0x89,0xF3,0x90,0xF8,0xEA } },
+{ 14 , { 0x4D,0xC3,0x87,0xBB,0x9D,0xAF,0x0F,0xBC,0x66,0x33,0xBE,0x92,0x62,0xEF } },
+{ 16 , { 0x3F,0x62,0xA8,0xCE,0xF1,0xB2,0x3D,0x16,0xCF,0xD6,0x21,0x1F,0xA3,0x48,0x26,0xC8 } },
+{ 10 , { 0x41,0x43,0x07,0xC2,0x55,0x4B,0x1D,0xEA,0x49,0x68 } },
+{ 13 , { 0x3C,0xD4,0xE5,0xA3,0x20,0xCB,0x42,0x9D,0xC4,0xFC,0x7E,0xAB,0xCA } },
+{ 8 , { 0x07,0xB1,0x04,0xB5,0x51,0xE4,0xDF,0x9F } },
+{ 16 , { 0x37,0x1F,0x5E,0xEB,0xAC,0x9C,0x8C,0xE9,0xF9,0xA1,0xBB,0x8A,0x68,0x47,0x61,0xA2 } },
+{ 16 , { 0x37,0x04,0x7B,0xC4,0xE1,0x7F,0x2B,0xBE,0x2A,0x60,0x13,0xC7,0x50,0xA1,0xB8,0x36 } },
+{ 10 , { 0x39,0x35,0xAE,0x58,0xAA,0x84,0xEA,0x76,0x52,0xCC } },
+{ 8 , { 0x07,0x69,0x40,0x3F,0x04,0x60,0x17,0x2C } },
+{ 16 , { 0x37,0xD4,0x50,0x3E,0x2E,0xCE,0x73,0xF2,0xED,0x7E,0x12,0x5A,0xF1,0x21,0xFA,0xEC } },
+{ 8 , { 0x0F,0x54,0x0A,0x35,0x46,0xF8,0xA4,0x34 } },
+{ 12 , { 0x3B,0x1A,0x6B,0x4D,0x95,0xCE,0x02,0x0D,0x54,0x48,0x11,0x49 } },
+{ 16 , { 0x07,0xE2,0x68,0x94,0x50,0x03,0x14,0xD5,0x07,0x1E,0x04,0xD6,0x66,0x5B,0xF0,0x8B } },
+{ 8 , { 0x07,0xD8,0xD1,0x2F,0x35,0x9C,0x42,0x9F } },
+{ 16 , { 0x3F,0xD1,0xDA,0x9A,0xF7,0x0E,0x1D,0xAD,0xD2,0x16,0xD7,0x2B,0xD3,0x74,0x89,0x92 } },
+{ 16 , { 0x3F,0xBA,0x99,0xBA,0x03,0x40,0xB0,0xE5,0x21,0x57,0x3A,0x4C,0x91,0x9F,0x8B,0x73 } },
+{ 15 , { 0x49,0x68,0x07,0x9F,0xCE,0xC6,0xE1,0xFE,0xB7,0xC8,0x44,0xD0,0xAC,0x97,0x5E } },
+{ 8 , { 0x0F,0x86,0xF1,0xFE,0x3B,0x83,0x5B,0x71 } },
+{ 10 , { 0x39,0x5C,0xEE,0xC6,0xAB,0xA2,0x32,0xB6,0xCD,0x1E } },
+{ 16 , { 0x0F,0xDB,0xD5,0x00,0x80,0xE5,0x8F,0xF4,0x07,0x9F,0xCE,0x1A,0x6D,0x00,0x91,0x8F } },
+{ 8 , { 0x0F,0xDC,0x4B,0xE8,0x37,0xAC,0x80,0xE7 } },
+{ 9 , { 0x38,0x0D,0x16,0xF8,0x22,0x6D,0x54,0xB5,0x72 } },
+{ 11 , { 0x0F,0x3F,0xCB,0x62,0x48,0xA7,0xB9,0x92,0x4A,0x85,0x17 } },
+{ 8 , { 0x07,0xCA,0x4B,0x40,0x47,0xA0,0x82,0xF6 } },
+{ 16 , { 0x3F,0x01,0xC0,0x03,0x69,0x3F,0x89,0x4A,0xAA,0x24,0xC2,0x3C,0x24,0xA4,0x0A,0x12 } },
+{ 16 , { 0x37,0xD8,0x01,0x02,0x77,0xAB,0xB4,0xC1,0xC9,0xB4,0x04,0x68,0x15,0xBE,0x6A,0xEC } },
+{ 10 , { 0x39,0x2C,0x13,0x17,0x37,0xE1,0xF9,0xF6,0xEE,0x00 } },
+{ 15 , { 0x0F,0x06,0x30,0x10,0x12,0x3B,0x7C,0xDB,0x4E,0x33,0xB6,0xAF,0xEF,0x95,0x0E } },
+{ 16 , { 0x0F,0xE0,0xF5,0xE4,0xFA,0xEA,0x82,0x32,0x0F,0xA6,0x8D,0x92,0x58,0x06,0xDF,0x08 } },
+{ 16 , { 0x37,0x52,0x3C,0xA9,0x93,0xE8,0xFC,0x3F,0x1A,0x44,0x67,0x10,0xEE,0x0C,0xBF,0x23 } },
+{ 10 , { 0x41,0x20,0x07,0xE8,0xA2,0xB8,0x53,0x92,0x44,0x14 } },
+{ 16 , { 0x3F,0x15,0xA4,0xE8,0x4B,0x85,0x0C,0x9D,0xC4,0x9C,0x60,0x2F,0x42,0x5E,0xF6,0xEE } },
+{ 16 , { 0x3F,0x55,0x5A,0xAD,0x27,0x5F,0xDC,0x07,0xEF,0x32,0x7E,0x58,0xD2,0xFA,0x2A,0x4A } },
+{ 8 , { 0x07,0xBD,0xD5,0x42,0x09,0x21,0x5E,0xD5 } },
+{ 12 , { 0x3B,0x18,0x38,0x33,0x0B,0x23,0x35,0x69,0xB1,0x65,0x91,0x0C } },
+{ 16 , { 0x0F,0x81,0xA7,0xDA,0x78,0x40,0xE2,0x71,0x07,0x2C,0x50,0x4E,0x27,0xB3,0x61,0xE6 } },
+{ 15 , { 0x3E,0x83,0xCC,0xDB,0xCF,0x1F,0xC7,0x07,0x06,0xB3,0x98,0xF7,0x51,0x18,0x91 } },
+{ 16 , { 0x0F,0x8C,0x4F,0xEF,0x7E,0x6A,0x7D,0x58,0x07,0xFC,0xCD,0xCC,0xF6,0x1C,0xB9,0x73 } },
+{ 16 , { 0x07,0xF3,0x72,0xCC,0x1E,0x9E,0x11,0xCC,0x07,0x2C,0x65,0xF1,0x73,0xDB,0xFE,0x79 } },
+{ 8 , { 0x07,0xFB,0x7F,0x9D,0x8C,0x26,0x05,0x5A } },
+{ 9 , { 0x38,0xCE,0xD2,0x5A,0x36,0xC6,0x18,0x62,0xC9 } },
+{ 11 , { 0x0F,0xE4,0x9C,0xEA,0x55,0x57,0x84,0x37,0x4A,0x8A,0x90 } },
+{ 8 , { 0x07,0x6D,0xC9,0xA9,0x20,0xFC,0x83,0xF8 } },
+{ 15 , { 0x36,0xCB,0x14,0x43,0x10,0x8C,0x98,0x38,0x76,0x25,0x4E,0xBA,0x68,0x79,0xB7 } },
+{ 8 , { 0x0F,0x99,0x87,0xAB,0x3D,0x0D,0x21,0x82 } },
+{ 15 , { 0x36,0x82,0xB5,0xAA,0xF8,0xB2,0xBC,0xDD,0x00,0xD7,0xE1,0x42,0x38,0xB2,0x7D } },
+{ 8 , { 0x07,0x40,0x3D,0x78,0xDB,0x54,0x66,0xCA } },
+{ 13 , { 0x34,0xAF,0x5F,0x79,0x9B,0xF9,0x60,0x55,0x75,0xE0,0x6B,0x94,0x3C } },
+{ 16 , { 0x0F,0x81,0xAE,0x7E,0x06,0xC7,0x27,0x9F,0x07,0xD2,0x33,0xC1,0x0E,0x97,0x51,0xED } },
+{ 16 , { 0x0F,0x23,0x3C,0xCA,0x98,0x51,0x36,0xFC,0x47,0x5D,0x47,0x14,0x9C,0x43,0xBB,0x42 } },
+{ 16 , { 0x07,0x5A,0xE1,0x01,0xEF,0xE4,0x77,0xCA,0x07,0xC4,0xF9,0x29,0x20,0x13,0xA5,0xC1 } },
+{ 13 , { 0x07,0x8B,0xB8,0xD3,0xA3,0xC9,0xA4,0xEE,0x4C,0xCB,0xCB,0x74,0x0E } },
+{ 8 , { 0x0F,0x94,0x40,0xDC,0x4A,0xA9,0x1A,0x30 } },
+{ 16 , { 0x37,0x06,0x49,0xC5,0xA7,0xF4,0x91,0x9C,0xB6,0x9E,0x0F,0x83,0xFD,0x8B,0xF9,0x67 } },
+{ 16 , { 0x37,0x85,0x94,0x0A,0x41,0x14,0x42,0xA8,0x68,0x1F,0xAB,0xC1,0x8D,0xA0,0xD0,0x54 } },
+{ 16 , { 0x37,0x2F,0x03,0xEF,0xEA,0x78,0x16,0xC3,0xB6,0xEF,0xA5,0xE2,0x8C,0xC2,0x5D,0xB6 } },
+{ 12 , { 0x43,0xAF,0x0C,0x94,0x0F,0xC7,0xD1,0x32,0x5A,0x52,0xC6,0x5A } },
+{ 8 , { 0x07,0x91,0x72,0x13,0x08,0x57,0x30,0xB6 } },
+{ 16 , { 0x37,0x6D,0x6F,0x19,0xEE,0xB4,0x6F,0x00,0x1B,0x49,0xA2,0xD8,0xE1,0x3A,0x9E,0x47 } },
+{ 14 , { 0x45,0xD5,0xFB,0x6D,0x44,0x21,0x07,0xD8,0x13,0xF5,0x21,0x6B,0xDC,0x60 } },
+{ 8 , { 0x07,0x6B,0x70,0xE2,0xBB,0xB0,0x57,0xC1 } },
+{ 9 , { 0x38,0xB9,0x67,0x42,0x0E,0xDB,0x02,0xD6,0xC9 } },
+{ 8 , { 0x07,0x11,0xF6,0x9D,0x3B,0xC8,0x66,0xC1 } },
+{ 16 , { 0x37,0x91,0xA4,0x40,0x6D,0xC7,0x10,0x5F,0xB6,0xC8,0x59,0x55,0x59,0x6C,0x66,0x92 } },
+{ 16 , { 0x3F,0x0B,0xF7,0x08,0x80,0x30,0xE9,0x19,0x64,0x69,0xE1,0xCE,0x90,0x03,0x88,0xE5 } },
+{ 12 , { 0x43,0xF9,0xEB,0x0D,0x07,0xB3,0xAC,0x79,0x50,0x7A,0x71,0x81 } },
+{ 16 , { 0x37,0xAD,0x92,0x83,0x55,0x86,0x1A,0xA2,0x9C,0xA7,0xBC,0x6E,0x62,0xD1,0x13,0x09 } },
+{ 16 , { 0x3F,0x69,0x5C,0x04,0x2A,0x3E,0x2B,0xBC,0xDC,0x0F,0x31,0x71,0xDD,0x45,0xFD,0xE3 } },
+{ 16 , { 0x37,0x01,0xA3,0x13,0xAD,0xEB,0xEF,0x95,0x59,0xA7,0xF8,0x1B,0x8E,0x7E,0xE2,0xB5 } },
+{ 16 , { 0x3F,0x8D,0xCA,0x8A,0x62,0x0F,0xF9,0xDA,0xC2,0xAB,0x30,0x94,0x89,0x13,0x3F,0xB5 } },
+{ 13 , { 0x44,0x13,0x19,0x74,0x65,0x05,0x10,0x80,0xE7,0x42,0x88,0x82,0xEC } },
+{ 16 , { 0x37,0xC4,0x35,0x3F,0x16,0x05,0x58,0x44,0x79,0x75,0xE6,0x97,0x11,0x0F,0x7F,0xEE } },
+{ 16 , { 0x37,0x33,0x82,0x31,0x49,0x1E,0x56,0x05,0x82,0xF2,0xB0,0xD2,0x8F,0x3B,0x56,0xF8 } },
+{ 16 , { 0x37,0x74,0x0C,0xE0,0xC0,0x2B,0xC5,0xCD,0xFD,0x9B,0x30,0x34,0x08,0xFA,0xAA,0xDF } },
+{ 16 , { 0x3F,0xD8,0x1D,0xD5,0xCF,0x32,0x6D,0xF2,0xF2,0x90,0xEF,0x51,0x16,0x89,0x2D,0x75 } },
+{ 16 , { 0x37,0xE5,0x67,0xA4,0xF4,0x90,0xFF,0x5B,0x52,0x0B,0x4E,0xF1,0xF7,0xE9,0x0C,0x98 } },
+{ 16 , { 0x37,0xB9,0x2B,0x9A,0x6D,0xB8,0x02,0x03,0xD4,0x6C,0x58,0x2C,0xE7,0x97,0xF7,0x8A } },
+{ 16 , { 0x3F,0x65,0x61,0x93,0xDA,0x29,0x88,0xE9,0x85,0x0F,0xEE,0xD4,0x5E,0x18,0x82,0x5E } },
+{ 16 , { 0x3F,0x01,0x83,0xB0,0x32,0x5C,0x76,0xBA,0x30,0x2D,0x6C,0xE0,0x2F,0x96,0x04,0x25 } },
+{ 16 , { 0x37,0x17,0x4E,0x91,0x10,0xD2,0xB9,0x9F,0x9B,0x68,0x5F,0x84,0xB7,0xF6,0x3F,0x9F } },
+{ 16 , { 0x3F,0x4F,0x0B,0xDD,0x28,0x52,0xF3,0x6E,0x8A,0x6C,0x07,0xD1,0x7A,0x52,0xE6,0xFC } },
+{ 13 , { 0x3C,0x2C,0x7E,0x6D,0xAE,0xFD,0x2B,0xC1,0x21,0xB4,0x4C,0x78,0x89 } },
+{ 16 , { 0x07,0x16,0x9A,0xEC,0xA4,0xF3,0xEB,0xD3,0x07,0xA4,0x56,0xDE,0xDF,0x04,0x05,0xCB } },
+{ 16 , { 0x37,0xDD,0xFB,0x88,0x60,0x7F,0x6D,0x5F,0x1A,0xCF,0x0C,0xC8,0x94,0x82,0x63,0x1F } },
+{ 16 , { 0x3F,0x94,0x23,0x91,0xFB,0xDB,0xC1,0x02,0x5C,0x69,0xBA,0x49,0xE4,0xFD,0x90,0x6C } },
+{ 16 , { 0x3F,0x1C,0xF5,0x74,0x3A,0xAA,0x02,0xA3,0x4A,0x69,0x8E,0x2A,0xFF,0x30,0xFA,0x71 } },
+{ 16 , { 0x3F,0x0E,0x07,0x8C,0xEC,0x21,0x9F,0x9A,0xF2,0xBD,0x30,0xA5,0x6C,0xB9,0x2A,0xD5 } },
+{ 16 , { 0x3F,0x21,0x1D,0xC7,0x0D,0xF4,0xE0,0x71,0x14,0xFE,0x88,0xD0,0xB3,0x90,0x30,0x77 } },
+{ 16 , { 0x37,0x3D,0x55,0x05,0x42,0x07,0x3F,0xC1,0x5E,0x45,0xA2,0x6D,0xA2,0xF4,0x1E,0xDC } },
+{ 16 , { 0x3F,0xA1,0x5B,0xB5,0x6A,0x9C,0x8F,0x22,0x4D,0x0F,0x8A,0xBE,0x4A,0xF8,0x8D,0xB8 } },
+{ 16 , { 0x3F,0xC0,0xD7,0x2C,0x97,0xB5,0x96,0xF6,0x37,0x13,0xB7,0x70,0x3B,0xC7,0xCE,0x3B } },
+{ 16 , { 0x37,0x2E,0x7D,0x7B,0x5E,0xEA,0x83,0x72,0x62,0x01,0xDC,0x5E,0x8E,0xCF,0x44,0x52 } },
+{ 16 , { 0x3F,0x54,0x59,0xB7,0x0A,0x69,0x37,0x51,0xB9,0x72,0x50,0xB0,0xC8,0xF3,0xDF,0x0F } },
+{ 16 , { 0x37,0x9C,0x35,0xB1,0x3B,0x93,0x84,0x5F,0xF4,0xB0,0x2F,0xA0,0xB9,0xC9,0x1C,0x09 } },
+{ 16 , { 0x37,0xC4,0x03,0xB8,0x6A,0xDD,0xC3,0x7F,0x3D,0x88,0xFA,0x9E,0x46,0xBF,0x67,0x3C } },
+{ 11 , { 0x42,0x92,0x5D,0x07,0x16,0x24,0x54,0x46,0x48,0x3D,0xDA } },
+{ 16 , { 0x37,0x29,0x6B,0x4B,0x22,0xCA,0x10,0x55,0x0C,0xF3,0x94,0x4F,0x39,0x45,0x57,0xC1 } },
+{ 15 , { 0x36,0xF8,0x9F,0xED,0xB2,0x9D,0xA0,0x92,0xFC,0x09,0x42,0xFF,0x51,0xD8,0x70 } },
+{ 14 , { 0x07,0x2A,0x9F,0xD6,0x5F,0x90,0x8C,0x27,0x45,0xD7,0x7C,0xA1,0x3C,0x27 } },
+{ 8 , { 0x0F,0x39,0x9A,0x9A,0x63,0x03,0xFA,0x94 } },
+{ 16 , { 0x37,0x47,0xF1,0x16,0xC3,0xD6,0x7B,0x88,0x6D,0x8B,0x15,0x30,0xD5,0xEB,0x25,0x22 } },
+{ 16 , { 0x37,0xD1,0xD7,0x78,0xBC,0xF7,0xC4,0xDD,0xA0,0x45,0x89,0x08,0x54,0x95,0xA8,0x12 } },
+{ 16 , { 0x37,0x24,0x55,0x7F,0xA5,0x20,0xE2,0x51,0x06,0xEE,0x40,0x98,0xF1,0x47,0xA1,0x9E } },
+{ 11 , { 0x32,0x4C,0x65,0xB2,0x97,0x7D,0x88,0x13,0xCE,0x17,0x4E } },
+{ 8 , { 0x07,0xA9,0x71,0x73,0xE8,0x0E,0x03,0x8B } },
+{ 16 , { 0x3F,0xF1,0x11,0x00,0x5B,0xCA,0xE8,0x92,0xDE,0xCB,0x25,0xB5,0xBA,0x2C,0x61,0x02 } },
+{ 16 , { 0x37,0x7B,0xA5,0x54,0x4D,0xDA,0x95,0xC1,0x3B,0xB3,0x80,0xAE,0xAC,0x03,0xEA,0xF2 } },
+{ 16 , { 0x37,0xB2,0xCE,0x77,0x35,0x7C,0x20,0x57,0x05,0x35,0xFA,0x5E,0x8A,0xD9,0x09,0x65 } },
+{ 16 , { 0x3F,0xA6,0x89,0xF1,0xCB,0x7F,0xD3,0x1D,0x0C,0x97,0x6E,0x7F,0x31,0x7B,0x67,0xDF } },
+{ 10 , { 0x41,0x78,0x0F,0xF8,0xB9,0xD0,0x37,0xBD,0xB4,0x92 } },
+{ 16 , { 0x07,0x22,0x23,0x00,0xB7,0xA1,0x75,0xEE,0x07,0x40,0x28,0x63,0x9D,0x45,0x68,0x4B } },
+{ 16 , { 0x37,0xB7,0xA3,0x6D,0xFB,0x16,0xC4,0x23,0x1D,0x7E,0xB8,0x87,0x45,0x9D,0x6E,0x03 } },
+{ 16 , { 0x37,0xF1,0x0D,0x4E,0xAB,0xA0,0xF0,0x47,0xE8,0x6E,0xB4,0x68,0xAD,0xC6,0x38,0x20 } },
+{ 16 , { 0x37,0x6E,0xF5,0x4E,0xC2,0xE6,0x51,0x6D,0xD2,0xC1,0x63,0x01,0xB5,0x6D,0x5F,0xFD } },
+{ 9 , { 0x30,0x72,0xCE,0xAE,0xFE,0x96,0xC4,0x20,0x70 } },
+{ 11 , { 0x07,0x39,0xCC,0xFB,0x91,0xB9,0xA7,0x66,0x4A,0xF6,0xB8 } },
+{ 8 , { 0x07,0xA1,0xE8,0x8D,0x69,0xE2,0x04,0xA2 } },
+{ 16 , { 0x37,0x06,0x3F,0x8C,0x15,0x4A,0x5D,0xF6,0x6F,0xD6,0x25,0x35,0x20,0x3C,0x9F,0x9D } },
+{ 16 , { 0x3F,0x52,0x8D,0xFC,0x2A,0x47,0x00,0x6C,0xC6,0x3D,0x1E,0x8B,0xFE,0x65,0xC7,0x31 } },
+{ 16 , { 0x3F,0xC9,0x13,0x38,0xE8,0x26,0xDE,0x16,0xD9,0xBD,0x16,0x06,0xD8,0x5A,0x26,0x36 } },
+{ 16 , { 0x3F,0x31,0xAC,0x7E,0xA8,0x90,0xF6,0x3A,0x02,0x59,0x6B,0xF1,0x1E,0x02,0x1B,0xD1 } },
+{ 10 , { 0x41,0x8D,0x0F,0x60,0xD8,0x95,0xC9,0x3C,0x0B,0x2A } },
+{ 16 , { 0x0F,0x17,0xA0,0xDA,0x40,0x72,0x9A,0x78,0x07,0x4C,0x6B,0x32,0xAD,0x21,0x9C,0xB0 } },
+{ 8 , { 0x0F,0x6A,0x23,0x4C,0x65,0x56,0x33,0x0D } },
+{ 12 , { 0x33,0x7F,0xA0,0x9C,0xC7,0x08,0x60,0xCB,0x35,0x59,0x22,0xAA } },
+{ 16 , { 0x07,0x3B,0xDB,0xFF,0x14,0x24,0xCB,0x64,0x0F,0xF5,0x60,0xE6,0x68,0x48,0xF3,0x43 } },
+{ 16 , { 0x07,0x78,0x60,0x84,0x3F,0xC7,0x43,0xEE,0x0F,0xA8,0xA1,0x0F,0xCF,0xE1,0x3F,0x86 } },
+{ 16 , { 0x0F,0xC0,0x67,0x53,0xC3,0x8E,0x5E,0x0A,0x07,0x7C,0x30,0xDA,0x6C,0x6A,0xCA,0xAA } },
+{ 16 , { 0x0F,0x07,0x88,0x95,0x22,0xB7,0x88,0xBC,0x07,0x4A,0x2C,0xB3,0x7A,0xB9,0x75,0x22 } },
+{ 11 , { 0x07,0x2A,0x62,0x95,0x87,0x61,0x93,0x59,0x42,0xEA,0x8F } },
+{ 16 , { 0x0F,0x62,0x4C,0xC9,0x92,0xA0,0x43,0x96,0x0F,0x7C,0xD1,0x8B,0x51,0x25,0x67,0xC4 } },
+{ 16 , { 0x07,0x39,0x88,0x93,0xDE,0x93,0x29,0x80,0x07,0xA7,0xAE,0x2A,0xE0,0xB1,0xB4,0x79 } },
+{ 16 , { 0x0F,0x1C,0xDE,0x1C,0xEB,0x0F,0x9C,0x74,0x0F,0xC5,0xC2,0x09,0x0A,0xED,0x50,0x79 } },
+{ 8 , { 0x07,0x0B,0x1A,0x05,0x6D,0x49,0xE0,0xFB } },
+{ 16 , { 0x37,0x2A,0xBA,0x74,0x71,0xA9,0x88,0xCB,0x42,0x3E,0x0D,0x5F,0x1A,0xD2,0xAA,0xE1 } },
+{ 11 , { 0x32,0x02,0x90,0xE7,0xD3,0x09,0xFA,0x1A,0xC8,0x33,0x65 } },
+{ 15 , { 0x05,0xA6,0x9F,0x84,0x95,0x2F,0x16,0x7B,0x4E,0xCD,0xEA,0xBD,0x84,0xB1,0xC0 } },
+{ 16 , { 0x07,0xF4,0x5F,0x53,0xA9,0x9D,0xC2,0x2F,0x0F,0x86,0xA5,0x30,0x58,0x55,0x79,0xF4 } },
+{ 16 , { 0x0F,0xAF,0x6F,0x5D,0x7D,0xD5,0x5E,0xB2,0x07,0x4C,0x26,0x58,0xA7,0x42,0xBC,0x88 } },
+{ 16 , { 0x0F,0x66,0xF8,0xAE,0xA1,0x28,0x54,0x49,0x07,0x77,0x84,0x7E,0xF5,0xD6,0xF2,0x1C } },
+{ 8 , { 0x07,0x2E,0xFD,0xAD,0xB8,0x75,0xFE,0xE1 } },
+{ 9 , { 0x38,0x8B,0x53,0xED,0xF4,0x54,0x51,0x36,0xFC } },
+{ 16 , { 0x0F,0xCD,0x55,0xD1,0x59,0xC8,0xFB,0xF0,0x0F,0xFB,0x6D,0x1D,0xFE,0x5B,0xEE,0x2E } },
+{ 16 , { 0x0F,0xF9,0xA0,0xF7,0xCB,0x23,0x7D,0x43,0x0F,0x3D,0xB8,0x0B,0x82,0x66,0xC8,0xB1 } },
+{ 9 , { 0x38,0x9E,0xDD,0xDE,0xDD,0x88,0xC2,0xD1,0x83 } },
+{ 16 , { 0x0F,0xE9,0xCA,0xB0,0xF9,0x8B,0x10,0xB0,0x0F,0xEE,0x0C,0x59,0x94,0x87,0x00,0xAF } },
+{ 16 , { 0x37,0x17,0x34,0x12,0xB6,0xB0,0xAB,0xEA,0xD9,0xB7,0x7B,0x4C,0x85,0xA1,0xE3,0x99 } },
+{ 10 , { 0x49,0x96,0x0F,0xE1,0xAD,0xB7,0xA8,0xDE,0xF5,0x51 } },
+{ 16 , { 0x07,0xFD,0x04,0xDE,0xB1,0x80,0xFA,0x56,0x0F,0x56,0xCC,0xDB,0xF2,0x2B,0x38,0xE3 } },
+{ 16 , { 0x0F,0xC6,0x2F,0x42,0x67,0x15,0x5F,0xDB,0x07,0x21,0xF4,0x54,0x8E,0x31,0x45,0x44 } },
+{ 15 , { 0x0F,0x54,0xD7,0xEC,0x08,0x9A,0x13,0xD3,0x4E,0xE7,0xDC,0x69,0xA9,0xEC,0x98 } },
+{ 16 , { 0x0F,0xAB,0x2F,0x3F,0x45,0x7A,0xD1,0x61,0x05,0xFE,0x24,0x54,0x46,0x54,0x61,0x1F } },
+{ 13 , { 0x3C,0x1C,0x56,0x93,0xC7,0x68,0xF5,0x2A,0x4B,0xA1,0x29,0x84,0x25 } },
+{ 16 , { 0x0F,0xDB,0x0F,0x14,0x77,0xAC,0xC5,0xC8,0x07,0xCA,0xCA,0x31,0x22,0x97,0x36,0x40 } },
+{ 11 , { 0x07,0xD3,0x2C,0x22,0x69,0x8E,0xEC,0xD9,0x42,0x1C,0x11 } },
+{ 16 , { 0x0F,0xE6,0x96,0x1E,0xA9,0x3C,0x25,0x8A,0x07,0x49,0x16,0x97,0xE8,0x2B,0xA1,0xCA } },
+{ 8 , { 0x0F,0xD8,0x78,0xF7,0x58,0x40,0xA0,0x0A } },
+{ 16 , { 0x3F,0x77,0x26,0x27,0xEF,0x07,0xBE,0xB1,0x17,0xF7,0x21,0x48,0x15,0x63,0x02,0xAB } },
+{ 10 , { 0x39,0xF0,0x01,0x60,0x65,0xD7,0xC2,0x23,0x19,0xDC } },
+{ 12 , { 0x07,0x01,0xB1,0x42,0xEE,0x5D,0x1B,0xDB,0x4B,0xA0,0xD3,0xD7 } },
+{ 16 , { 0x07,0xF0,0xD1,0x0F,0x00,0x04,0x54,0xF5,0x05,0x34,0x94,0x2F,0xDC,0xAA,0x34,0xEB } }
+};
+
+
+
+
+
+//#define NB_LINES (sizeof(firmwaretable)/(8*sizeof(unsigned char)))
+
+#ifdef USING_ATV_FILTER
+static unsigned char dlif_vidfilt_table[] = {0};
+#define DLIF_VIDFILT_LINES (sizeof(dlif_vidfilt_table)/(8*sizeof(unsigned char)))
+#endif
+
+static si2177_common_reply_struct  reply;
+/************************************************************************************************************************
+NAME:		   si2177_readcommandbytes function
+DESCRIPTION:Read inbbytes from the i2c device into pucdatabuffer, return number of bytes read
+Parameter: iI2CIndex, the index of the first byte to read.
+Parameter: inbbytes, the number of bytes to read.
+Parameter: *pucdatabuffer, a pointer to a buffer used to store the bytes
+Porting:    Replace with embedded system I2C read function
+Returns:    Actual number of bytes read.
+ ************************************************************************************************************************/
+static int si2177_readcommandbytes(struct i2c_client *si2177, int inbbytes, unsigned char *pucdatabuffer)
+{
+        int i2c_flag = 0;
+        int i = 0;
+        unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
+
+        struct i2c_msg msg[] = {
+                {
+                        .addr  = si2177->addr,
+                        .flags  = I2C_M_RD,
+                        .len     = inbbytes,
+                        .buf     = pucdatabuffer,
+                },
+        };
+	//	printk("[%s]adapter is %x,si2177->addr is %x\n",__func__,si2177->adapter,si2177->addr);
+repeat:
+
+        i2c_flag = i2c_transfer(si2177->adapter, msg, 1);
+        if (i2c_flag < 0) {
+                pr_err("%s: error in read sli2177, %d byte(s) should be read,. \n", __func__, inbbytes);
+                if (i++ < i2c_try_cnt) {
+                        pr_err("%s: error in read sli2177, try again!!!\n", __func__);
+                        goto repeat;
+                }
+                else
+                        return -EIO;
+        }
+        else {
+                //pr_info("%s: read %d bytes\n", __func__, inbbytes);
+                return inbbytes;
+        }
+}
+
+/************************************************************************************************************************
+NAME:  si2177_writecommandbytes
+DESCRIPTION:  Write inbbytes from pucdatabuffer to the i2c device, return number of bytes written
+Porting:    Replace with inbbytes system I2C write function
+Returns:    Number of bytes written
+ ************************************************************************************************************************/
+static int si2177_writecommandbytes(struct i2c_client *si2177, int inbbytes, unsigned char *pucdatabuffer)
+{
+        int i2c_flag = 0;
+        int i = 0;
+        unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
+
+        struct i2c_msg msg[] = {
+                {
+                        .addr	= si2177->addr,
+                        .flags	= 0,    //|I2C_M_TEN,
+                        .len	= inbbytes,
+                        .buf	= pucdatabuffer,
+                }
+
+        };
+		//printk("[%s]adapter is %x,si2177->addr is %x\n",__func__,si2177->adapter,si2177->addr);
+repeat:
+        i2c_flag = i2c_transfer(si2177->adapter, msg, 1);
+        if (i2c_flag < 0) {
+                pr_err("%s: error in write sli2177, %d byte(s) should be read,. \n", __func__, inbbytes);
+                if (i++ < i2c_try_cnt) {
+                        pr_err("%s: error in wirte sli2177, try again!!!\n", __func__);
+                        goto repeat;
+                }
+                else
+                        return -EIO;
+        }
+        else {
+                //pr_info("%s: write %d bytes\n", __func__, inbbytes);
+                return inbbytes;
+        }
+}
+
+/***********************************************************************************************************************
+  sli2177_pollforcts function
+Use:        CTS checking function
+Used to check the CTS bit until it is set before sending the next command
+Comments:   The status byte definition being identical for all commands,
+using this function to fill the status structure hels reducing the code size
+Comments:   waitForCTS = 1 => I2C polling
+waitForCTS = 2 => INTB followed by a read (reading a HW byte using the cypress chip)
+max timeout = 100 ms
+
+Porting:    If reading INTB is not possible, the waitForCTS = 2 case can be removed
+
+Parameter: waitForCTS          a flag indicating if waiting for CTS is required
+Returns:   1 if the CTS bit is set, 0 otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2177_pollforcts(struct i2c_client *si2177)
+{
+        unsigned char error_code = 0;
+        unsigned char loop_count = 0;
+        unsigned char rspbytebuffer[1];
+
+        for (loop_count=0; loop_count<50; loop_count++) { /* wait a maximum of 50*25ms = 1.25s  */
+                if (si2177_readcommandbytes(si2177, 1, rspbytebuffer) != 1)
+                        error_code = ERROR_SI2177_POLLING_CTS;
+                else
+                        error_code = NO_SI2177_ERROR;
+                if (error_code || (rspbytebuffer[0] & 0x80))
+                        goto exit;
+                mdelay(2); /* CTS not set, wait 2ms and retry */
+        }
+        error_code = ERROR_SI2177_CTS_TIMEOUT;
+
+exit:
+        if (error_code)
+                pr_info("%s: poll cts function error:%d!!!...............\n", __func__, error_code);
+
+        return error_code;
+}
+
+/***********************************************************************************************************************
+  SI2177_CurrentResponseStatus function
+Use:        status checking function
+Used to fill the SI2177_COMMON_REPLY_struct members with the ptDataBuffer byte's bits
+Comments:   The status byte definition being identical for all commands,
+using this function to fill the status structure hels reducing the code size
+
+Parameter: *ret          the SI2177_COMMON_REPLY_struct
+Parameter: ptDataBuffer  a single byte received when reading a command's response (the first byte)
+Returns:   0 if the err bit (bit 6) is unset, 1 otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2177_currentresponsestatus(si2177_common_reply_struct *common_reply, unsigned char ptdatabuffer)
+{
+        /* _status_code_insertion_start */
+        common_reply->tunint = ((ptdatabuffer >> 0 ) & 0x01);
+        common_reply->atvint = ((ptdatabuffer >> 1 ) & 0x01);
+        common_reply->dtvint = ((ptdatabuffer >> 2 ) & 0x01);
+        common_reply->err    = ((ptdatabuffer >> 6 ) & 0x01);
+        common_reply->cts    = ((ptdatabuffer >> 7 ) & 0x01);
+        /* _status_code_insertion_point */
+        return (common_reply->err ? ERROR_SI2177_ERR : NO_SI2177_ERROR);
+}
+
+/***********************************************************************************************************************
+  si2177_pollforresponse function
+Use:        command response retrieval function
+Used to retrieve the command response in the provided buffer,
+poll for response either by I2C polling or wait for INTB
+Comments:   The status byte definition being identical for all commands,
+using this function to fill the status structure hels reducing the code size
+Comments:   waitForCTS = 1 => I2C polling
+waitForCTS = 2 => INTB followed by a read (reading a HW byte using the cypress chip)
+max timeout = 100 ms
+
+Porting:    If reading INTB is not possible, the waitForCTS = 2 case can be removed
+
+Parameter:  waitforresponse  a flag indicating if waiting for the response is required
+Parameter:  nbbytes          the number of response bytes to read
+Parameter:  pbytebuffer      a buffer into which bytes will be stored
+Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2177_pollforresponse(struct i2c_client *si2177, unsigned char waitforresponse, unsigned int nbbytes, unsigned char *pbytebuffer, si2177_common_reply_struct *common_reply)
+{
+        unsigned char error_code;
+        unsigned char loop_count;
+
+        for (loop_count=0; loop_count<50; loop_count++) { /* wait a maximum of 50*2ms = 100ms                        */
+                switch (waitforresponse) { /* type of response polling?                                */
+                        case 0 : /* no polling? valid option, but shouldn't have been called */
+                                error_code = NO_SI2177_ERROR; /* return no error                                          */
+                                goto exit;
+
+                        case 1 : /* I2C polling status?                                      */
+                                if (si2177_readcommandbytes(si2177, nbbytes, pbytebuffer) != nbbytes)
+                                        error_code = ERROR_SI2177_POLLING_RESPONSE;
+                                else
+                                        error_code = NO_SI2177_ERROR;
+                                if (error_code)
+                                        goto exit;	/* if error, exit with error code */
+                                if (pbytebuffer[0] & 0x80)	  /* CTS set? */
+                                {
+                                        error_code = si2177_currentresponsestatus(common_reply, pbytebuffer[0]);
+                                        goto exit; /* exit whether ERR set or not   */
+                                }
+                                break;
+
+                        default :
+                                error_code = ERROR_SI2177_PARAMETER_OUT_OF_RANGE; /* support debug of invalid CTS poll parameter   */
+                                goto exit;
+                }
+                mdelay(2); /* CTS not set, wait 2ms and retry                         */
+        }
+        error_code = ERROR_SI2177_CTS_TIMEOUT;
+
+exit:
+        return error_code;
+}
+
+/************************************************************************************************************************
+NAME: CheckStatus
+DESCRIPTION:     Read Si2170 STATUS byte and return decoded status
+Parameter:  Si2170 Context (I2C address)
+Parameter:  Status byte (TUNINT, ATVINT, DTVINT, ERR, CTS, CHLINT, and CHL flags).
+Returns:    Si2170/I2C transaction error code
+ ************************************************************************************************************************/
+#if 0
+static int si2177_check_status(struct i2c_client *si2177, si2177_common_reply_struct *common_reply)
+{
+        unsigned char buffer[1];
+        /* read STATUS byte */
+        if (si2177_pollforresponse(si2177, 1, 1, buffer, common_reply) != 0)
+        {
+                return ERROR_SI2177_POLLING_RESPONSE;
+        }
+
+        return 0;
+}
+#endif
+/***********************************************************************************************************************
+NAME: Si2170_L1_API_Patch
+DESCRIPTION: Patch information function
+Used to send a number of bytes to the Si2170. Useful to download the firmware.
+Parameter:   *api    a pointer to the api context to initialize
+Parameter:  waitForCTS flag for CTS checking prior to sending a Si2170 API Command
+Parameter:  waitForResponse flag for CTS checking and Response readback after sending Si2170 API Command
+Parameter:  number of bytes to transmit
+Parameter:  Databuffer containing the bytes to transfer in an unsigned char array.
+Returns:   0 if no error, else a nonzero int representing an error
+ ***********************************************************************************************************************/
+static unsigned char si2177_api_patch(struct i2c_client *si2177, int inbbytes, unsigned char *pucdatabuffer, si2177_common_reply_struct *common_reply)
+{
+        unsigned char res = 0;
+        unsigned char error_code = 0;
+        unsigned char rspbytebuffer[1];
+
+        res = si2177_pollforcts(si2177);
+        if (res != NO_SI2177_ERROR)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, res);
+                return res;
+        }
+
+        res = si2177_writecommandbytes(si2177, inbbytes, pucdatabuffer);
+        if (res!=inbbytes)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, ERROR_SI2177_SENDING_COMMAND);
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, common_reply);
+        if (error_code)
+                pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+
+        return error_code;
+}
+
+
+/* _commands_insertion_start */
+#ifdef SI2177_AGC_OVERRIDE_CMD
+/*---------------------------------------------------*/
+/* SI2177_AGC_OVERRIDE COMMAND                     */
+/*---------------------------------------------------*/
+static unsigned char si2177_agc_override(struct i2c_client *si2177,
+                unsigned char   force_max_gain,
+                unsigned char   force_top_gain,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (force_max_gain > SI2177_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MAX)
+                        || (force_top_gain > SI2177_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MAX) )
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_AGC_OVERRIDE_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( force_max_gain & SI2177_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MASK ) << SI2177_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_LSB|
+                        ( force_top_gain & SI2177_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MASK ) << SI2177_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_LSB);
+
+        if (si2177_writecommandbytes(si2177, 2, cmdbytebuffer) != 2)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->agc_override.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_AGC_OVERRIDE_CMD */
+#ifdef SI2177_ATV_CW_TEST_CMD
+/*---------------------------------------------------*/
+/* SI2177_ATV_CW_TEST COMMAND                      */
+/*---------------------------------------------------*/
+static unsigned char si2177_atv_cw_test(struct i2c_client *si2177,
+                unsigned char   pc_lock,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (pc_lock > SI2177_ATV_CW_TEST_CMD_PC_LOCK_MAX) )
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code) goto exit;
+
+        cmdbytebuffer[0] = SI2177_ATV_CW_TEST_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( pc_lock & SI2177_ATV_CW_TEST_CMD_PC_LOCK_MASK ) << SI2177_ATV_CW_TEST_CMD_PC_LOCK_LSB);
+
+        if (si2177_writecommandbytes(si2177, 2, cmdbytebuffer) != 2) error_code = ERROR_SI2177_SENDING_COMMAND;
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->atv_cw_test.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_ATV_CW_TEST_CMD */
+#ifdef SI2177_ATV_RESTART_CMD
+/*---------------------------------------------------*/
+/* SI2177_ATV_RESTART COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char si2177_atv_restart(struct i2c_client *si2177,
+                unsigned char   mode,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (mode > SI2177_ATV_RESTART_CMD_MODE_MAX) )
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_ATV_RESTART_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( mode & SI2177_ATV_RESTART_CMD_MODE_MASK ) << SI2177_ATV_RESTART_CMD_MODE_LSB);
+
+        if (si2177_writecommandbytes(si2177, 2, cmdbytebuffer) != 2)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->atv_restart.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_ATV_RESTART_CMD */
+#ifdef SI2177_DTV_RESTART_CMD
+/*---------------------------------------------------*/
+/* SI2177_DTV_RESTART COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char si2177_dtv_restart(struct i2c_client *si2177, si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[1];
+
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_DTV_RESTART_CMD;
+        if (si2177_writecommandbytes(si2177, 1, cmdbytebuffer) != 1)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->atv_restart.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_ATV_RESTART_CMD */
+
+#ifdef SI2177_ATV_STATUS_CMD
+/*---------------------------------------------------*/
+/* SI2177_ATV_STATUS COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char si2177_atv_status(struct i2c_client *si2177,
+                unsigned char intack,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[12];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (intack > SI2177_ATV_STATUS_CMD_INTACK_MAX) )
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_ATV_STATUS_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( intack & SI2177_ATV_STATUS_CMD_INTACK_MASK ) << SI2177_ATV_STATUS_CMD_INTACK_LSB);
+
+        if (si2177_writecommandbytes(si2177, 2, cmdbytebuffer) != 2)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 12, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->atv_status.status = &reply;
+                if (!error_code)
+                {
+                        rsp->atv_status.chlint           =   (( ( (rspbytebuffer[1]  )) >> SI2177_ATV_STATUS_RESPONSE_CHLINT_LSB           ) & SI2177_ATV_STATUS_RESPONSE_CHLINT_MASK           );
+                        rsp->atv_status.pclint           =   (( ( (rspbytebuffer[1]  )) >> SI2177_ATV_STATUS_RESPONSE_PCLINT_LSB           ) & SI2177_ATV_STATUS_RESPONSE_PCLINT_MASK           );
+                        rsp->atv_status.dlint             =   (( ( (rspbytebuffer[1]  )) >> SI2177_ATV_STATUS_RESPONSE_DLINT_LSB            ) & SI2177_ATV_STATUS_RESPONSE_DLINT_MASK            );
+                        rsp->atv_status.snrlint          =   (( ( (rspbytebuffer[1]  )) >> SI2177_ATV_STATUS_RESPONSE_SNRLINT_LSB          ) & SI2177_ATV_STATUS_RESPONSE_SNRLINT_MASK          );
+                        rsp->atv_status.snrhint         =   (( ( (rspbytebuffer[1]  )) >> SI2177_ATV_STATUS_RESPONSE_SNRHINT_LSB          ) & SI2177_ATV_STATUS_RESPONSE_SNRHINT_MASK          );
+                        rsp->atv_status.chl                =   (( ( (rspbytebuffer[2]  )) >> SI2177_ATV_STATUS_RESPONSE_CHL_LSB              ) & SI2177_ATV_STATUS_RESPONSE_CHL_MASK              );
+                        rsp->atv_status.pcl               =   (( ( (rspbytebuffer[2]  )) >> SI2177_ATV_STATUS_RESPONSE_PCL_LSB              ) & SI2177_ATV_STATUS_RESPONSE_PCL_MASK              );
+                        rsp->atv_status.dl                 =   (( ( (rspbytebuffer[2]  )) >> SI2177_ATV_STATUS_RESPONSE_DL_LSB               ) & SI2177_ATV_STATUS_RESPONSE_DL_MASK               );
+                        rsp->atv_status.snrl              =   (( ( (rspbytebuffer[2]  )) >> SI2177_ATV_STATUS_RESPONSE_SNRL_LSB             ) & SI2177_ATV_STATUS_RESPONSE_SNRL_MASK             );
+                        rsp->atv_status.snrh             =   (( ( (rspbytebuffer[2]  )) >> SI2177_ATV_STATUS_RESPONSE_SNRH_LSB             ) & SI2177_ATV_STATUS_RESPONSE_SNRH_MASK             );
+                        rsp->atv_status.video_snr     =   (( ( (rspbytebuffer[3]  )) >> SI2177_ATV_STATUS_RESPONSE_VIDEO_SNR_LSB        ) & SI2177_ATV_STATUS_RESPONSE_VIDEO_SNR_MASK        );
+                        rsp->atv_status.afc_freq       = (((( ( (rspbytebuffer[4]  ) | (rspbytebuffer[5]  << 8 )) >> SI2177_ATV_STATUS_RESPONSE_AFC_FREQ_LSB         ) & SI2177_ATV_STATUS_RESPONSE_AFC_FREQ_MASK) <<SI2177_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>SI2177_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT         );
+                        rsp->atv_status.video_sc_spacing = (((( ( (rspbytebuffer[6]  ) | (rspbytebuffer[7]  << 8 )) >> SI2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_LSB ) & SI2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_MASK) <<SI2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT ) >>SI2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT );
+                        rsp->atv_status.video_sys    =   (( ( (rspbytebuffer[8]  )) >> SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB        ) & SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK        );
+                        rsp->atv_status.color            =   (( ( (rspbytebuffer[8]  )) >> SI2177_ATV_STATUS_RESPONSE_COLOR_LSB            ) & SI2177_ATV_STATUS_RESPONSE_COLOR_MASK            );
+                        rsp->atv_status.lines            =   (( ( (rspbytebuffer[8]  )) >> SI2177_ATV_STATUS_RESPONSE_LINES_LSB            ) & SI2177_ATV_STATUS_RESPONSE_LINES_MASK            );
+                        rsp->atv_status.audio_sys    =   (( ( (rspbytebuffer[9]  )) >> SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_LSB        ) & SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MASK        );
+                        rsp->atv_status.audio_demod_mode =   (( ( (rspbytebuffer[9]  )) >> SI2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_LSB ) & SI2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_MASK );
+                        rsp->atv_status.audio_chan_bw    =   (( ( (rspbytebuffer[10] )) >> SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_LSB    ) & SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_MASK    );
+    					rsp->atv_status.sound_level      = (((( ( (rspbytebuffer[11] )) >> SI2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_LSB      ) & SI2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_MASK) <<SI2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_SHIFT ) >>SI2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_SHIFT      );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_ATV_STATUS_CMD */
+#ifdef    SI2177_CONFIG_CLOCKS_CMD
+ /*---------------------------------------------------*/
+/* SI2177_CONFIG_CLOCKS COMMAND                    */
+/*---------------------------------------------------*/
+unsigned char si2177_config_clocks  (struct i2c_client *si2177,
+                                         unsigned char   subcode,
+                                         unsigned char   clock_mode,
+                                         unsigned char   en_xout,
+										 si2177_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[3];
+    unsigned char rspByteBuffer[1];
+
+
+   pr_info("SI2177 CONFIG_CLOCKS\n ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((subcode    > SI2177_CONFIG_CLOCKS_CMD_SUBCODE_MAX   ) ||
+     (clock_mode > SI2177_CONFIG_CLOCKS_CMD_CLOCK_MODE_MAX) 	||
+     (en_xout    > SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_MAX    ) )
+     {
+      pr_info("%s out of range parameters\n",__func__);
+      return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+
+    cmdByteBuffer[0] = SI2177_CONFIG_CLOCKS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( subcode    & SI2177_CONFIG_CLOCKS_CMD_SUBCODE_MASK    ) << SI2177_CONFIG_CLOCKS_CMD_SUBCODE_LSB   );
+    cmdByteBuffer[2] = (unsigned char) ( ( clock_mode & SI2177_CONFIG_CLOCKS_CMD_CLOCK_MODE_MASK ) << SI2177_CONFIG_CLOCKS_CMD_CLOCK_MODE_LSB|
+                                         ( en_xout    & SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_MASK    ) << SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_LSB   );
+
+    if (si2177_writecommandbytes(si2177, 3, cmdByteBuffer) != 3) {
+      pr_info("Error writing CONFIG_CLOCKS bytes!\n");
+      return ERROR_SI2177_SENDING_COMMAND;
+    }
+
+    error_code = si2177_pollforresponse(si2177, 1,1, rspByteBuffer,&reply);
+    if (error_code) {
+      pr_info("Error polling CONFIG_CLOCKS response\n");
+      return error_code;
+    }
+
+
+    return NO_SI2177_ERROR;
+}
+#endif /* SI2177_CONFIG_CLOCKS_CMD */
+#ifdef SI2177_CONFIG_PINS_CMD
+/*---------------------------------------------------*/
+/* SI2177_CONFIG_PINS COMMAND                      */
+/*---------------------------------------------------*/
+static unsigned char si2177_config_pins(struct i2c_client *si2177,
+                unsigned char   gpio1_mode,
+                unsigned char   gpio1_read,
+                unsigned char   gpio2_mode,
+                unsigned char   gpio2_read,
+				unsigned char	reserved1,
+				unsigned char	reserved2,
+				unsigned char	reserved3,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[6];
+        unsigned char rspbytebuffer[6];
+
+#ifdef	 DEBUG_RANGE_CHECK
+  if ((gpio1_mode > SI2177_CONFIG_PINS_CMD_GPIO1_MODE_MAX) ) ||
+  (gpio1_read > SI2177_CONFIG_PINS_CMD_GPIO1_READ_MAX)  ||
+  (gpio2_mode > SI2177_CONFIG_PINS_CMD_GPIO2_MODE_MAX) ||
+  (gpio2_read > SI2177_CONFIG_PINS_CMD_GPIO2_READ_MAX) ||
+  (reserved1  > SI2177_CONFIG_PINS_CMD_RESERVED1_MAX )	|| (reserved1  < SI2177_CONFIG_PINS_CMD_RESERVED1_MIN ) ||
+  (reserved2  > SI2177_CONFIG_PINS_CMD_RESERVED2_MAX )	|| (reserved2  < SI2177_CONFIG_PINS_CMD_RESERVED2_MIN ) ||
+  (reserved3  > SI2177_CONFIG_PINS_CMD_RESERVED3_MAX )	|| (reserved3  < SI2177_CONFIG_PINS_CMD_RESERVED3_MIN ) ) ;
+  {
+	pr_info("%d out of range parameters\n", error_code);
+	return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+  }
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_CONFIG_PINS_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( gpio1_mode & SI2177_CONFIG_PINS_CMD_GPIO1_MODE_MASK ) << SI2177_CONFIG_PINS_CMD_GPIO1_MODE_LSB|
+                                         ( gpio1_read & SI2177_CONFIG_PINS_CMD_GPIO1_READ_MASK ) << SI2177_CONFIG_PINS_CMD_GPIO1_READ_LSB);
+    	cmdbytebuffer[2] = (unsigned char) ( ( gpio2_mode & SI2177_CONFIG_PINS_CMD_GPIO2_MODE_MASK ) << SI2177_CONFIG_PINS_CMD_GPIO2_MODE_LSB|
+                                         ( gpio2_read & SI2177_CONFIG_PINS_CMD_GPIO2_READ_MASK ) << SI2177_CONFIG_PINS_CMD_GPIO2_READ_LSB);
+    	cmdbytebuffer[3] = (unsigned char) ( ( reserved1  & SI2177_CONFIG_PINS_CMD_RESERVED1_MASK  ) << SI2177_CONFIG_PINS_CMD_RESERVED1_LSB );
+    	cmdbytebuffer[4] = (unsigned char) ( ( reserved2  & SI2177_CONFIG_PINS_CMD_RESERVED2_MASK  ) << SI2177_CONFIG_PINS_CMD_RESERVED2_LSB );
+    	cmdbytebuffer[5] = (unsigned char) ( ( reserved3  & SI2177_CONFIG_PINS_CMD_RESERVED3_MASK  ) << SI2177_CONFIG_PINS_CMD_RESERVED3_LSB );
+        if (si2177_writecommandbytes(si2177, 6, cmdbytebuffer) != 6)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 6, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+              //  rsp->config_pins.status = &reply;
+                if (!error_code)
+                {
+                            rsp->config_pins.gpio1_mode  =   (( ( (rspbytebuffer[1]  )) >> SI2177_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB  ) & SI2177_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK  );
+   							rsp->config_pins.gpio1_state =   (( ( (rspbytebuffer[1]  )) >> SI2177_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB ) & SI2177_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK );
+    						rsp->config_pins.gpio2_mode  =   (( ( (rspbytebuffer[2]  )) >> SI2177_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB  ) & SI2177_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK  );
+    						rsp->config_pins.gpio2_state =   (( ( (rspbytebuffer[2]  )) >> SI2177_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB ) & SI2177_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK );
+    						rsp->config_pins.reserved1   =   (( ( (rspbytebuffer[3]  )) >> SI2177_CONFIG_PINS_RESPONSE_RESERVED1_LSB   ) & SI2177_CONFIG_PINS_RESPONSE_RESERVED1_MASK   );
+   							rsp->config_pins.reserved2   =   (( ( (rspbytebuffer[4]  )) >> SI2177_CONFIG_PINS_RESPONSE_RESERVED2_LSB   ) & SI2177_CONFIG_PINS_RESPONSE_RESERVED2_MASK   );
+    						rsp->config_pins.reserved3   =   (( ( (rspbytebuffer[5]  )) >> SI2177_CONFIG_PINS_RESPONSE_RESERVED3_LSB   ) & SI2177_CONFIG_PINS_RESPONSE_RESERVED3_MASK   );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_CONFIG_PINS_CMD */
+#ifdef SI2177_EXIT_BOOTLOADER_CMD
+/*---------------------------------------------------*/
+/* SI2177_EXIT_BOOTLOADER COMMAND                  */
+/*---------------------------------------------------*/
+static unsigned char si2177_exit_bootloader(struct i2c_client *si2177,
+                unsigned char   func,
+                unsigned char   ctsien,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (func   > SI2177_EXIT_BOOTLOADER_CMD_FUNC_MAX  )
+                        || (ctsien > SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_MAX) )
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code) goto exit;
+
+        cmdbytebuffer[0] = SI2177_EXIT_BOOTLOADER_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( func   & SI2177_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << SI2177_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+                        ( ctsien & SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+
+        if (si2177_writecommandbytes(si2177, 2, cmdbytebuffer) != 2) error_code = ERROR_SI2177_SENDING_COMMAND;
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->exit_bootloader.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_EXIT_BOOTLOADER_CMD */
+#ifdef SI2177_FINE_TUNE_CMD
+/*---------------------------------------------------*/
+/* SI2177_FINE_TUNE COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char si2177_fine_tune(struct i2c_client *si2177,
+                                         unsigned char   persistence,
+                                         unsigned char   apply_to_lif,
+                int   offset_500hz,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[4];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (reserved     > SI2177_FINE_TUNE_CMD_RESERVED_MAX    )
+                        || (offset_500hz > SI2177_FINE_TUNE_CMD_OFFSET_500HZ_MAX)  || (offset_500hz < SI2177_FINE_TUNE_CMD_OFFSET_500HZ_MIN) )
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_FINE_TUNE_CMD;
+    	cmdbytebuffer[1] = (unsigned char) ( ( persistence  & SI2177_FINE_TUNE_CMD_PERSISTENCE_MASK  ) << SI2177_FINE_TUNE_CMD_PERSISTENCE_LSB |
+                                         ( apply_to_lif & SI2177_FINE_TUNE_CMD_APPLY_TO_LIF_MASK ) << SI2177_FINE_TUNE_CMD_APPLY_TO_LIF_LSB);
+        cmdbytebuffer[2] = (unsigned char) ( ( offset_500hz & SI2177_FINE_TUNE_CMD_OFFSET_500HZ_MASK ) << SI2177_FINE_TUNE_CMD_OFFSET_500HZ_LSB);
+        cmdbytebuffer[3] = (unsigned char) ((( offset_500hz & SI2177_FINE_TUNE_CMD_OFFSET_500HZ_MASK ) << SI2177_FINE_TUNE_CMD_OFFSET_500HZ_LSB)>>8);
+
+        if (si2177_writecommandbytes(si2177, 4, cmdbytebuffer) != 4)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->fine_tune.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_FINE_TUNE_CMD */
+#ifdef SI2177_GET_PROPERTY_CMD
+/*---------------------------------------------------*/
+/* SI2177_GET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char si2177_get_property(struct i2c_client *si2177,
+                unsigned char   reserved,
+                unsigned int    prop,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[4];
+        unsigned char rspbytebuffer[4];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (reserved > SI2177_GET_PROPERTY_CMD_RESERVED_MAX) )
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_GET_PROPERTY_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( reserved & SI2177_GET_PROPERTY_CMD_RESERVED_MASK ) << SI2177_GET_PROPERTY_CMD_RESERVED_LSB);
+        cmdbytebuffer[2] = (unsigned char) ( ( prop     & SI2177_GET_PROPERTY_CMD_PROP_MASK     ) << SI2177_GET_PROPERTY_CMD_PROP_LSB    );
+        cmdbytebuffer[3] = (unsigned char) ((( prop     & SI2177_GET_PROPERTY_CMD_PROP_MASK     ) << SI2177_GET_PROPERTY_CMD_PROP_LSB    )>>8);
+
+        if (si2177_writecommandbytes(si2177, 4, cmdbytebuffer) != 4)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 4, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->get_property.status = &reply;
+                if (!error_code)
+                {
+                        rsp->get_property.reserved =   (( ( (rspbytebuffer[1]  )) >> SI2177_GET_PROPERTY_RESPONSE_RESERVED_LSB ) & SI2177_GET_PROPERTY_RESPONSE_RESERVED_MASK );
+                        rsp->get_property.data     =   (( ( (rspbytebuffer[2]  ) | (rspbytebuffer[3]  << 8 )) >> SI2177_GET_PROPERTY_RESPONSE_DATA_LSB     ) & SI2177_GET_PROPERTY_RESPONSE_DATA_MASK     );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_GET_PROPERTY_CMD */
+#ifdef SI2177_GET_REV_CMD
+/*---------------------------------------------------*/
+/* SI2177_GET_REV COMMAND                          */
+/*---------------------------------------------------*/
+static unsigned char si2177_get_rev(struct i2c_client *si2177,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[10];
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code) goto exit;
+
+        cmdbytebuffer[0] = SI2177_GET_REV_CMD;
+
+        if (si2177_writecommandbytes(si2177, 1, cmdbytebuffer) != 1) error_code = ERROR_SI2177_SENDING_COMMAND;
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 10, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->get_rev.status = &reply;
+                if (!error_code)
+                {
+                        rsp->get_rev.pn       =   (( ( (rspbytebuffer[1]  )) >> SI2177_GET_REV_RESPONSE_PN_LSB       ) & SI2177_GET_REV_RESPONSE_PN_MASK       );
+                        rsp->get_rev.fwmajor  =   (( ( (rspbytebuffer[2]  )) >> SI2177_GET_REV_RESPONSE_FWMAJOR_LSB  ) & SI2177_GET_REV_RESPONSE_FWMAJOR_MASK  );
+                        rsp->get_rev.fwminor  =   (( ( (rspbytebuffer[3]  )) >> SI2177_GET_REV_RESPONSE_FWMINOR_LSB  ) & SI2177_GET_REV_RESPONSE_FWMINOR_MASK  );
+                        rsp->get_rev.patch    =   (( ( (rspbytebuffer[4]  ) | (rspbytebuffer[5]  << 8 )) >> SI2177_GET_REV_RESPONSE_PATCH_LSB    ) & SI2177_GET_REV_RESPONSE_PATCH_MASK    );
+                        rsp->get_rev.cmpmajor =   (( ( (rspbytebuffer[6]  )) >> SI2177_GET_REV_RESPONSE_CMPMAJOR_LSB ) & SI2177_GET_REV_RESPONSE_CMPMAJOR_MASK );
+                        rsp->get_rev.cmpminor =   (( ( (rspbytebuffer[7]  )) >> SI2177_GET_REV_RESPONSE_CMPMINOR_LSB ) & SI2177_GET_REV_RESPONSE_CMPMINOR_MASK );
+                        rsp->get_rev.cmpbuild =   (( ( (rspbytebuffer[8]  )) >> SI2177_GET_REV_RESPONSE_CMPBUILD_LSB ) & SI2177_GET_REV_RESPONSE_CMPBUILD_MASK );
+                        rsp->get_rev.chiprev  =   (( ( (rspbytebuffer[9]  )) >> SI2177_GET_REV_RESPONSE_CHIPREV_LSB  ) & SI2177_GET_REV_RESPONSE_CHIPREV_MASK  );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_GET_REV_CMD */
+#ifdef SI2177_PART_INFO_CMD
+/*---------------------------------------------------*/
+/* SI2177_PART_INFO COMMAND                        */
+/*---------------------------------------------------*/
+static unsigned char si2177_part_info(struct i2c_client *si2177,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[13];
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code) goto exit;
+
+        cmdbytebuffer[0] = SI2177_PART_INFO_CMD;
+
+        if (si2177_writecommandbytes(si2177, 1, cmdbytebuffer) != 1) error_code = ERROR_SI2177_SENDING_COMMAND;
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 13, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->part_info.status = &reply;
+                if (!error_code)
+                {
+                        rsp->part_info.chiprev  =   (( ( (rspbytebuffer[1]  )) >> SI2177_PART_INFO_RESPONSE_CHIPREV_LSB  ) & SI2177_PART_INFO_RESPONSE_CHIPREV_MASK  );
+                        rsp->part_info.part     =   (( ( (rspbytebuffer[2]  )) >> SI2177_PART_INFO_RESPONSE_PART_LSB     ) & SI2177_PART_INFO_RESPONSE_PART_MASK     );
+                        rsp->part_info.pmajor   =   (( ( (rspbytebuffer[3]  )) >> SI2177_PART_INFO_RESPONSE_PMAJOR_LSB   ) & SI2177_PART_INFO_RESPONSE_PMAJOR_MASK   );
+                        rsp->part_info.pminor   =   (( ( (rspbytebuffer[4]  )) >> SI2177_PART_INFO_RESPONSE_PMINOR_LSB   ) & SI2177_PART_INFO_RESPONSE_PMINOR_MASK   );
+                        rsp->part_info.pbuild   =   (( ( (rspbytebuffer[5]  )) >> SI2177_PART_INFO_RESPONSE_PBUILD_LSB   ) & SI2177_PART_INFO_RESPONSE_PBUILD_MASK   );
+                        rsp->part_info.reserved =   (( ( (rspbytebuffer[6]  ) | (rspbytebuffer[7]  << 8 )) >> SI2177_PART_INFO_RESPONSE_RESERVED_LSB ) & SI2177_PART_INFO_RESPONSE_RESERVED_MASK );
+                        rsp->part_info.serial   =   (( ( (rspbytebuffer[8]  ) | (rspbytebuffer[9]  << 8 ) | (rspbytebuffer[10] << 16 ) | (rspbytebuffer[11] << 24 )) >> SI2177_PART_INFO_RESPONSE_SERIAL_LSB   ) & SI2177_PART_INFO_RESPONSE_SERIAL_MASK   );
+                        rsp->part_info.romid    =   (( ( (rspbytebuffer[12] )) >> SI2177_PART_INFO_RESPONSE_ROMID_LSB    ) & SI2177_PART_INFO_RESPONSE_ROMID_MASK    );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_PART_INFO_CMD */
+#ifdef SI2177_POWER_DOWN_CMD
+/*---------------------------------------------------*/
+/* SI2177_POWER_DOWN COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char si2177_power_down(struct i2c_client *si2177,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[1];
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_POWER_DOWN_CMD;
+
+        if (si2177_writecommandbytes(si2177, 1, cmdbytebuffer) != 1)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->power_down.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_POWER_DOWN_CMD */
+#ifdef    SI2177_POWER_DOWN_HW_CMD
+ /*---------------------------------------------------*/
+/* SI2177_POWER_DOWN_HW COMMAND                    */
+/*---------------------------------------------------*/
+unsigned char si2177_power_down_hw   (struct i2c_client *si2177,
+                                         unsigned char   subcode,
+                                         unsigned char   pd_xo_osc,
+                                         unsigned char   reserved1,
+                                         unsigned char   en_xout,
+                                         unsigned char   reserved2,
+                                         unsigned char   pd_ldo,
+                                         unsigned char   reserved3,
+                                         unsigned char   reserved4,
+                                         unsigned char   reserved5,
+                                         unsigned char   reserved6,
+                                         unsigned char   reserved7,
+                                         unsigned char   reserved8)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[10];
+    unsigned char rspByteBuffer[1];
+
+
+    pr_info("SI2177 POWER_DOWN_HW ");
+
+    cmdByteBuffer[0] = SI2177_POWER_DOWN_HW_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( subcode   & SI2177_POWER_DOWN_HW_CMD_SUBCODE_MASK   ) << SI2177_POWER_DOWN_HW_CMD_SUBCODE_LSB  );
+    cmdByteBuffer[2] = (unsigned char) ( ( pd_xo_osc & SI2177_POWER_DOWN_HW_CMD_PD_XO_OSC_MASK ) << SI2177_POWER_DOWN_HW_CMD_PD_XO_OSC_LSB|
+                                         ( reserved1 & SI2177_POWER_DOWN_HW_CMD_RESERVED1_MASK ) << SI2177_POWER_DOWN_HW_CMD_RESERVED1_LSB|
+                                         ( en_xout   & SI2177_POWER_DOWN_HW_CMD_EN_XOUT_MASK   ) << SI2177_POWER_DOWN_HW_CMD_EN_XOUT_LSB  |
+                                         ( reserved2 & SI2177_POWER_DOWN_HW_CMD_RESERVED2_MASK ) << SI2177_POWER_DOWN_HW_CMD_RESERVED2_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( pd_ldo    & SI2177_POWER_DOWN_HW_CMD_PD_LDO_MASK    ) << SI2177_POWER_DOWN_HW_CMD_PD_LDO_LSB   );
+    cmdByteBuffer[4] = (unsigned char) ( ( reserved3 & SI2177_POWER_DOWN_HW_CMD_RESERVED3_MASK ) << SI2177_POWER_DOWN_HW_CMD_RESERVED3_LSB);
+    cmdByteBuffer[5] = (unsigned char) ( ( reserved4 & SI2177_POWER_DOWN_HW_CMD_RESERVED4_MASK ) << SI2177_POWER_DOWN_HW_CMD_RESERVED4_LSB);
+    cmdByteBuffer[6] = (unsigned char) ( ( reserved5 & SI2177_POWER_DOWN_HW_CMD_RESERVED5_MASK ) << SI2177_POWER_DOWN_HW_CMD_RESERVED5_LSB);
+    cmdByteBuffer[7] = (unsigned char) ( ( reserved6 & SI2177_POWER_DOWN_HW_CMD_RESERVED6_MASK ) << SI2177_POWER_DOWN_HW_CMD_RESERVED6_LSB);
+    cmdByteBuffer[8] = (unsigned char) ( ( reserved7 & SI2177_POWER_DOWN_HW_CMD_RESERVED7_MASK ) << SI2177_POWER_DOWN_HW_CMD_RESERVED7_LSB);
+    cmdByteBuffer[9] = (unsigned char) ( ( reserved8 & SI2177_POWER_DOWN_HW_CMD_RESERVED8_MASK ) << SI2177_POWER_DOWN_HW_CMD_RESERVED8_LSB);
+
+    if (si2177_writecommandbytes(si2177, 10, cmdByteBuffer) != 10) {
+      pr_info("Error writing POWER_DOWN_HW bytes!\n");
+      return ERROR_SI2177_SENDING_COMMAND;
+    }
+
+    error_code = si2177_pollforresponse(si2177, 1,1, rspByteBuffer,&reply);
+    if (error_code) {
+      pr_info("Error polling POWER_DOWN_HW response\n");
+      return error_code;
+    }
+    return NO_SI2177_ERROR;
+}
+#endif /* SI2177_POWER_DOWN_HW_CMD */
+
+#ifdef    SI2177_POWER_UP_CMD
+/* SI2177_POWER_UP COMMAND                         */
+/*---------------------------------------------------*/
+static unsigned char si2177_power_up(struct i2c_client *si2177,
+											unsigned char	subcode,
+											unsigned char	clock_mode,
+											unsigned char	en_xout,
+											unsigned char	pd_ldo,
+											unsigned char	reserved2,
+											unsigned char	reserved3,
+											unsigned char	reserved4,
+											unsigned char	reserved5,
+											unsigned char	reserved6,
+											unsigned char	reserved7,
+											unsigned char	reset,
+											unsigned char	clock_freq,
+											unsigned char	reserved8,
+											unsigned char	func,
+											unsigned char	reserved9,
+											unsigned char	ctsien,
+											unsigned char	wake_up,
+                							si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[15];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        		if ( 	   (subcode    > SI2177_POWER_UP_CMD_SUBCODE_MAX   )  || (subcode    < SI2177_POWER_UP_CMD_SUBCODE_MIN   )
+						|| (clock_mode > SI2177_POWER_UP_CMD_CLOCK_MODE_MAX)
+                        || (en_xout    > SI2177_POWER_UP_CMD_EN_XOUT_MAX   )
+                        || (pd_ldo     > SI2177_POWER_UP_CMD_PD_LDO_MAX    )
+                        || (reserved2  > SI2177_POWER_UP_CMD_RESERVED2_MAX )
+                        || (reserved3  > SI2177_POWER_UP_CMD_RESERVED3_MAX )
+                        || (reserved4  > SI2177_POWER_UP_CMD_RESERVED4_MAX )  || (reserved4  < SI2177_POWER_UP_CMD_RESERVED4_MIN )
+						|| (reserved5  > SI2177_POWER_UP_CMD_RESERVED5_MAX )  || (reserved5  < SI2177_POWER_UP_CMD_RESERVED5_MIN )
+						|| (reserved6  > SI2177_POWER_UP_CMD_RESERVED6_MAX )  || (reserved6  < SI2177_POWER_UP_CMD_RESERVED6_MIN )
+						|| (reserved7  > SI2177_POWER_UP_CMD_RESERVED7_MAX )  || (reserved7  < SI2177_POWER_UP_CMD_RESERVED7_MIN )
+						||	(reset      > SI2177_POWER_UP_CMD_RESET_MAX     )
+						|| (clock_freq > SI2177_POWER_UP_CMD_CLOCK_FREQ_MAX)
+						|| (reserved8  > SI2177_POWER_UP_CMD_RESERVED8_MAX )
+						|| (func       > SI2177_POWER_UP_CMD_FUNC_MAX      )
+						|| (reserved9  > SI2177_POWER_UP_CMD_RESERVED9_MAX )
+                        || (ctsien     > SI2177_POWER_UP_CMD_CTSIEN_MAX    )
+                        || (wake_up    > SI2177_POWER_UP_CMD_WAKE_UP_MAX   )  || (wake_up    < SI2177_POWER_UP_CMD_WAKE_UP_MIN   ) )
+
+        {
+                if(SI2177_DEBUG)
+                        pr_info("%s: DEBUG_RANGE_CHECK!!!!\n", __func__);
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+        }
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+			cmdbytebuffer[0] = SI2177_POWER_UP_CMD;
+			cmdbytebuffer[1] = (unsigned char) ( ( subcode	  & SI2177_POWER_UP_CMD_SUBCODE_MASK	) << SI2177_POWER_UP_CMD_SUBCODE_LSB   );
+			cmdbytebuffer[2] = (unsigned char) ( ( clock_mode & SI2177_POWER_UP_CMD_CLOCK_MODE_MASK ) << SI2177_POWER_UP_CMD_CLOCK_MODE_LSB|
+												 ( en_xout	  & SI2177_POWER_UP_CMD_EN_XOUT_MASK	) << SI2177_POWER_UP_CMD_EN_XOUT_LSB   );
+			cmdbytebuffer[3] = (unsigned char) ( ( pd_ldo	  & SI2177_POWER_UP_CMD_PD_LDO_MASK 	) << SI2177_POWER_UP_CMD_PD_LDO_LSB    );
+			cmdbytebuffer[4] = (unsigned char) ( ( reserved2  & SI2177_POWER_UP_CMD_RESERVED2_MASK	) << SI2177_POWER_UP_CMD_RESERVED2_LSB );
+			cmdbytebuffer[5] = (unsigned char) ( ( reserved3  & SI2177_POWER_UP_CMD_RESERVED3_MASK	) << SI2177_POWER_UP_CMD_RESERVED3_LSB );
+			cmdbytebuffer[6] = (unsigned char) ( ( reserved4  & SI2177_POWER_UP_CMD_RESERVED4_MASK	) << SI2177_POWER_UP_CMD_RESERVED4_LSB );
+			cmdbytebuffer[7] = (unsigned char) ( ( reserved5  & SI2177_POWER_UP_CMD_RESERVED5_MASK	) << SI2177_POWER_UP_CMD_RESERVED5_LSB );
+			cmdbytebuffer[8] = (unsigned char) ( ( reserved6  & SI2177_POWER_UP_CMD_RESERVED6_MASK	) << SI2177_POWER_UP_CMD_RESERVED6_LSB );
+			cmdbytebuffer[9] = (unsigned char) ( ( reserved7  & SI2177_POWER_UP_CMD_RESERVED7_MASK	) << SI2177_POWER_UP_CMD_RESERVED7_LSB );
+			cmdbytebuffer[10] = (unsigned char) ( ( reset	   & SI2177_POWER_UP_CMD_RESET_MASK 	 ) << SI2177_POWER_UP_CMD_RESET_LSB 	);
+			cmdbytebuffer[11] = (unsigned char) ( ( clock_freq & SI2177_POWER_UP_CMD_CLOCK_FREQ_MASK ) << SI2177_POWER_UP_CMD_CLOCK_FREQ_LSB);
+			cmdbytebuffer[12] = (unsigned char) ( ( reserved8  & SI2177_POWER_UP_CMD_RESERVED8_MASK  ) << SI2177_POWER_UP_CMD_RESERVED8_LSB );
+			cmdbytebuffer[13] = (unsigned char) ( ( func	   & SI2177_POWER_UP_CMD_FUNC_MASK		 ) << SI2177_POWER_UP_CMD_FUNC_LSB		|
+												 ( reserved9  & SI2177_POWER_UP_CMD_RESERVED9_MASK	) << SI2177_POWER_UP_CMD_RESERVED9_LSB |
+												 ( ctsien	  & SI2177_POWER_UP_CMD_CTSIEN_MASK 	) << SI2177_POWER_UP_CMD_CTSIEN_LSB    );
+			cmdbytebuffer[14] = (unsigned char) ( ( wake_up    & SI2177_POWER_UP_CMD_WAKE_UP_MASK	 ) << SI2177_POWER_UP_CMD_WAKE_UP_LSB	);
+
+        if (si2177_writecommandbytes(si2177, 15, cmdbytebuffer) != 15)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                if (error_code)
+                        pr_info("%s: si2177_writecommandbytes!!!!\n", __func__);
+        }
+		 mdelay(25);
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+
+                rsp->power_up.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_POWER_UP_CMD */
+#ifdef SI2177_SET_PROPERTY_CMD
+/*---------------------------------------------------*/
+/* SI2177_SET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char si2177_set_property(struct i2c_client *si2177,
+                unsigned char   reserved,
+                unsigned int    prop,
+                unsigned int    data,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[6];
+        unsigned char rspbytebuffer[4];
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_SET_PROPERTY_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( reserved & SI2177_SET_PROPERTY_CMD_RESERVED_MASK ) << SI2177_SET_PROPERTY_CMD_RESERVED_LSB);
+        cmdbytebuffer[2] = (unsigned char) ( ( prop     & SI2177_SET_PROPERTY_CMD_PROP_MASK     ) << SI2177_SET_PROPERTY_CMD_PROP_LSB    );
+        cmdbytebuffer[3] = (unsigned char) ((( prop     & SI2177_SET_PROPERTY_CMD_PROP_MASK     ) << SI2177_SET_PROPERTY_CMD_PROP_LSB    )>>8);
+        cmdbytebuffer[4] = (unsigned char) ( ( data     & SI2177_SET_PROPERTY_CMD_DATA_MASK     ) << SI2177_SET_PROPERTY_CMD_DATA_LSB    );
+        cmdbytebuffer[5] = (unsigned char) ((( data     & SI2177_SET_PROPERTY_CMD_DATA_MASK     ) << SI2177_SET_PROPERTY_CMD_DATA_LSB    )>>8);
+
+        if (si2177_writecommandbytes(si2177, 6, cmdbytebuffer) != 6)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 4, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->set_property.status = &reply;
+                if (!error_code)
+                {
+                        rsp->set_property.reserved =   (( ( (rspbytebuffer[1]  )) >> SI2177_SET_PROPERTY_RESPONSE_RESERVED_LSB ) & SI2177_SET_PROPERTY_RESPONSE_RESERVED_MASK );
+                        rsp->set_property.data     =   (( ( (rspbytebuffer[2]  ) | (rspbytebuffer[3]  << 8 )) >> SI2177_SET_PROPERTY_RESPONSE_DATA_LSB     ) & SI2177_SET_PROPERTY_RESPONSE_DATA_MASK     );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_SET_PROPERTY_CMD */
+#ifdef SI2177_STANDBY_CMD
+/*---------------------------------------------------*/
+/* SI2177_STANDBY COMMAND                          */
+/*---------------------------------------------------*/
+static unsigned char si2177_standby(struct i2c_client *si2177,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[1];
+        unsigned char rspbytebuffer[1];
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_STANDBY_CMD;
+
+        if (si2177_writecommandbytes(si2177, 1, cmdbytebuffer) != 1)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->standby.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_STANDBY_CMD */
+#ifdef SI2177_TUNER_STATUS_CMD
+/*---------------------------------------------------*/
+/* SI2177_TUNER_STATUS COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char si2177_tuner_status(struct i2c_client *si2177,
+                unsigned char   intack,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[2];
+        unsigned char rspbytebuffer[12];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (intack > SI2177_TUNER_STATUS_CMD_INTACK_MAX) )
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_TUNER_STATUS_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( intack & SI2177_TUNER_STATUS_CMD_INTACK_MASK ) << SI2177_TUNER_STATUS_CMD_INTACK_LSB);
+
+        if (si2177_writecommandbytes(si2177, 2, cmdbytebuffer) != 2)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 12, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->tuner_status.status = &reply;
+                if (!error_code)
+                {
+                        rsp->tuner_status.tcint          = (( ( (rspbytebuffer[1]  )) >> SI2177_TUNER_STATUS_RESPONSE_TCINT_LSB    ) & SI2177_TUNER_STATUS_RESPONSE_TCINT_MASK    );
+                        rsp->tuner_status.rssilint      = (( ( (rspbytebuffer[1]  )) >> SI2177_TUNER_STATUS_RESPONSE_RSSILINT_LSB ) & SI2177_TUNER_STATUS_RESPONSE_RSSILINT_MASK );
+                        rsp->tuner_status.rssihint     = (( ( (rspbytebuffer[1]  )) >> SI2177_TUNER_STATUS_RESPONSE_RSSIHINT_LSB ) & SI2177_TUNER_STATUS_RESPONSE_RSSIHINT_MASK );
+                        rsp->tuner_status.tc              = (( ( (rspbytebuffer[2]  )) >> SI2177_TUNER_STATUS_RESPONSE_TC_LSB       ) & SI2177_TUNER_STATUS_RESPONSE_TC_MASK       );
+                        rsp->tuner_status.rssil          = (( ( (rspbytebuffer[2]  )) >> SI2177_TUNER_STATUS_RESPONSE_RSSIL_LSB    ) & SI2177_TUNER_STATUS_RESPONSE_RSSIL_MASK    );
+                        rsp->tuner_status.rssih         = (( ( (rspbytebuffer[2]  )) >> SI2177_TUNER_STATUS_RESPONSE_RSSIH_LSB    ) & SI2177_TUNER_STATUS_RESPONSE_RSSIH_MASK    );
+                        rsp->tuner_status.rssi           = (((( ( (rspbytebuffer[3]  )) >> SI2177_TUNER_STATUS_RESPONSE_RSSI_LSB     ) & SI2177_TUNER_STATUS_RESPONSE_RSSI_MASK) <<SI2177_TUNER_STATUS_RESPONSE_RSSI_SHIFT ) >>SI2177_TUNER_STATUS_RESPONSE_RSSI_SHIFT     );
+                        rsp->tuner_status.freq          = (( ( (rspbytebuffer[4]  ) | (rspbytebuffer[5]  << 8 ) | (rspbytebuffer[6]  << 16 ) | (rspbytebuffer[7]  << 24 )) >> SI2177_TUNER_STATUS_RESPONSE_FREQ_LSB     ) & SI2177_TUNER_STATUS_RESPONSE_FREQ_MASK     );
+                        rsp->tuner_status.mode        = (( ( (rspbytebuffer[8]  )) >> SI2177_TUNER_STATUS_RESPONSE_MODE_LSB     ) & SI2177_TUNER_STATUS_RESPONSE_MODE_MASK     );
+                        rsp->tuner_status.vco_code = (((( ( (rspbytebuffer[10] ) | (rspbytebuffer[11] << 8 )) >> SI2177_TUNER_STATUS_RESPONSE_VCO_CODE_LSB ) & SI2177_TUNER_STATUS_RESPONSE_VCO_CODE_MASK) <<SI2177_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT ) >>SI2177_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT );
+                }
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_TUNER_STATUS_CMD */
+#ifdef SI2177_TUNER_TUNE_FREQ_CMD
+/*---------------------------------------------------*/
+/* SI2177_TUNER_TUNE_FREQ COMMAND                  */
+/*---------------------------------------------------*/
+unsigned char si2177_tuner_tune_freq(struct i2c_client *si2177,
+                unsigned char   mode,
+                unsigned long   freq,
+                si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char error_code = 0;
+        unsigned char cmdbytebuffer[8];
+        unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+        if ( (mode > SI2177_TUNER_TUNE_FREQ_CMD_MODE_MAX)
+                        || (freq > SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MAX)  || (freq < SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MIN) )
+                return ERROR_SI2177_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+        error_code = si2177_pollforcts(si2177);
+        if (error_code)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+                goto exit;
+        }
+
+        cmdbytebuffer[0] = SI2177_TUNER_TUNE_FREQ_CMD;
+        cmdbytebuffer[1] = (unsigned char) ( ( mode & SI2177_TUNER_TUNE_FREQ_CMD_MODE_MASK ) << SI2177_TUNER_TUNE_FREQ_CMD_MODE_LSB);
+        cmdbytebuffer[2] = (unsigned char)0x00;
+        cmdbytebuffer[3] = (unsigned char)0x00;
+        cmdbytebuffer[4] = (unsigned char) ( ( freq & SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2177_TUNER_TUNE_FREQ_CMD_FREQ_LSB);
+        cmdbytebuffer[5] = (unsigned char) ((( freq & SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2177_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>8);
+        cmdbytebuffer[6] = (unsigned char) ((( freq & SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2177_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>16);
+        cmdbytebuffer[7] = (unsigned char) ((( freq & SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2177_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>24);
+
+        if (si2177_writecommandbytes(si2177, 8, cmdbytebuffer) != 8)
+        {
+                error_code = ERROR_SI2177_SENDING_COMMAND;
+                pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+        }
+
+        if (!error_code)
+        {
+                error_code = si2177_pollforresponse(si2177, 1, 1, rspbytebuffer, &reply);
+                if (error_code)
+                        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+                rsp->tuner_tune_freq.status = &reply;
+        }
+exit:
+        return error_code;
+}
+#endif /* SI2177_TUNER_TUNE_FREQ_CMD */
+/* _commands_insertion_point */
+
+/* _send_command2_insertion_start */
+
+/* --------------------------------------------*/
+/* SEND_COMMAND2 FUNCTION                      */
+/* --------------------------------------------*/
+unsigned char si2177_sendcommand(struct i2c_client *si2177, int cmd, si2177_cmdobj_t *c, si2177_cmdreplyobj_t *rsp)
+{
+        switch (cmd)
+        {
+#ifdef SI2177_AGC_OVERRIDE_CMD
+                case SI2177_AGC_OVERRIDE_CMD:
+                        return si2177_agc_override(si2177, c->agc_override.force_max_gain, c->agc_override.force_top_gain, rsp);
+                        break;
+#endif /*     SI2177_AGC_OVERRIDE_CMD */
+#ifdef SI2177_ATV_CW_TEST_CMD
+                case SI2177_ATV_CW_TEST_CMD:
+                        return si2177_atv_cw_test(si2177, c->atv_cw_test.pc_lock, rsp);
+                        break;
+#endif /*     SI2177_ATV_CW_TEST_CMD */
+#ifdef SI2177_ATV_RESTART_CMD
+                case SI2177_ATV_RESTART_CMD:
+                        return si2177_atv_restart(si2177, c->atv_restart.mode, rsp);
+                        break;
+#endif /*     SI2177_ATV_RESTART_CMD */
+#ifdef SI2177_ATV_STATUS_CMD
+                case SI2177_ATV_STATUS_CMD:
+                        return si2177_atv_status(si2177, c->atv_status.intack, rsp);
+                        break;
+#endif /*     SI2177_ATV_STATUS_CMD */
+    #ifdef        SI2177_CONFIG_CLOCKS_CMD
+     case         SI2177_CONFIG_CLOCKS_CMD_CODE:
+       return si2177_config_clocks (si2177, c->config_clocks.subcode, c->config_clocks.clock_mode, c->config_clocks.en_xout,rsp );
+     break;
+    #endif /*     SI2177_CONFIG_CLOCKS_CMD */
+#ifdef SI2177_CONFIG_PINS_CMD
+                case SI2177_CONFIG_PINS_CMD:
+                      //  return si2177_config_pins(si2177, c->config_pins.gpio1_mode, c->config_pins.gpio1_read, c->config_pins.gpio2_mode, c->config_pins.gpio2_read, c->config_pins.gpio3_mode, c->config_pins.gpio3_read, c->config_pins.bclk1_mode, c->config_pins.bclk1_read, c->config_pins.xout_mode, rsp);
+						return si2177_config_pins (si2177, c->config_pins.gpio1_mode, c->config_pins.gpio1_read, c->config_pins.gpio2_mode, c->config_pins.gpio2_read, c->config_pins.reserved1, c->config_pins.reserved2, c->config_pins.reserved3 ,rsp);
+						break;
+#endif /*     SI2177_CONFIG_PINS_CMD */
+#ifdef SI2177_EXIT_BOOTLOADER_CMD
+                case SI2177_EXIT_BOOTLOADER_CMD:
+                        return si2177_exit_bootloader(si2177, c->exit_bootloader.func, c->exit_bootloader.ctsien, rsp);
+                        break;
+#endif /*     SI2177_EXIT_BOOTLOADER_CMD */
+#ifdef SI2177_FINE_TUNE_CMD
+                case SI2177_FINE_TUNE_CMD:
+                        return si2177_fine_tune(si2177, c->fine_tune.persistence,c->fine_tune.apply_to_lif,c->fine_tune.offset_500hz, rsp);
+                        break;
+#endif /*     SI2177_FINE_TUNE_CMD */
+#ifdef SI2177_GET_PROPERTY_CMD
+                case SI2177_GET_PROPERTY_CMD:
+                        return si2177_get_property(si2177, c->get_property.reserved, c->get_property.prop, rsp);
+                        break;
+#endif /*     SI2177_GET_PROPERTY_CMD */
+#ifdef SI2177_GET_REV_CMD
+                case SI2177_GET_REV_CMD:
+                        return si2177_get_rev(si2177, rsp);
+                        break;
+#endif /*     SI2177_GET_REV_CMD */
+#ifdef SI2177_PART_INFO_CMD
+                case SI2177_PART_INFO_CMD:
+                        return si2177_part_info(si2177, rsp);
+                        break;
+#endif /*     SI2177_PART_INFO_CMD */
+#ifdef SI2177_POWER_DOWN_CMD
+                case SI2177_POWER_DOWN_CMD:
+                        return si2177_power_down(si2177, rsp);
+                        break;
+#endif /*     SI2177_POWER_DOWN_CMD */
+
+#ifdef        SI2177_POWER_DOWN_HW_CMD
+     case         SI2177_POWER_DOWN_HW_CMD_CODE:
+       return si2177_power_down_hw (si2177, c->power_down_hw.subcode, c->power_down_hw.pd_xo_osc, c->power_down_hw.reserved1, c->power_down_hw.en_xout, c->power_down_hw.reserved2, c->power_down_hw.pd_ldo, c->power_down_hw.reserved3, c->power_down_hw.reserved4, c->power_down_hw.reserved5, c->power_down_hw.reserved6, c->power_down_hw.reserved7, c->power_down_hw.reserved8 );
+     break;
+#endif /*     SI2177_POWER_DOWN_HW_CMD */
+
+#ifdef SI2177_POWER_UP_CMD
+                case SI2177_POWER_UP_CMD:
+                        return si2177_power_up(si2177, c->power_up.subcode, c->power_up.clock_mode, c->power_up.en_xout, c->power_up.pd_ldo, c->power_up.reserved2, c->power_up.reserved3, c->power_up.reserved4, c->power_up.reserved5, c->power_up.reserved6, c->power_up.reserved7, c->power_up.reset, c->power_up.clock_freq, c->power_up.reserved8, c->power_up.func, c->power_up.reserved9, c->power_up.ctsien, c->power_up.wake_up,rsp);
+						break;
+#endif /*     SI2177_POWER_UP_CMD */
+#ifdef SI2177_SET_PROPERTY_CMD
+                case SI2177_SET_PROPERTY_CMD:
+                        return si2177_set_property(si2177, c->set_property.reserved, c->set_property.prop, c->set_property.data, rsp);
+                        break;
+#endif /*     SI2177_SET_PROPERTY_CMD */
+#ifdef SI2177_STANDBY_CMD
+                case SI2177_STANDBY_CMD:
+                        return si2177_standby(si2177, rsp);
+                        break;
+#endif /*     SI2177_STANDBY_CMD */
+#ifdef SI2177_TUNER_STATUS_CMD
+                case SI2177_TUNER_STATUS_CMD:
+                        return si2177_tuner_status(si2177, c->tuner_status.intack, rsp);
+                        break;
+#endif /*     SI2177_TUNER_STATUS_CMD */
+#ifdef SI2177_TUNER_TUNE_FREQ_CMD
+                case SI2177_TUNER_TUNE_FREQ_CMD:
+                        return si2177_tuner_tune_freq(si2177, c->tuner_tune_freq.mode, c->tuner_tune_freq.freq, rsp);
+                        break;
+#endif /*     SI2177_TUNER_TUNE_FREQ_CMD */
+                default :
+                        break;
+        }
+        return 0;
+}
+/* _send_command2_insertion_point */
+
+/***********************************************************************************************************************
+  si2177_setproperty function
+Use:        property set function
+Used to call L1_SET_PROPERTY with the property Id and data provided.
+Comments:   This is a way to make sure CTS is polled when setting a property
+Parameter: *api     the SI2177 context
+Parameter: waitforcts flag to wait for a CTS before issuing the property command
+Parameter: waitforresponse flag to wait for a CTS after issuing the property command
+Parameter: prop     the property Id
+Parameter: data     the property bytes
+Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2177_setproperty(struct i2c_client *si2177, unsigned int prop, int  data, si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char  reserved          = 0;
+        return si2177_set_property(si2177, reserved, prop, data, rsp);
+}
+
+/***********************************************************************************************************************
+  si2177_getproperty function
+Use:        property get function
+Used to call L1_GET_PROPERTY with the property Id provided.
+Comments:   This is a way to make sure CTS is polled when retrieving a property
+Parameter: *api     the SI2177 context
+Parameter: waitforcts flag to wait for a CTS before issuing the property command
+Parameter: waitforresponse flag to wait for a CTS after issuing the property command
+Parameter: prop     the property Id
+Parameter: *data    a buffer to store the property bytes into
+Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2177_getproperty(struct i2c_client *si2177, unsigned int prop, int *data, si2177_cmdreplyobj_t *rsp)
+{
+        unsigned char reserved = 0;
+        unsigned char res;
+        res = si2177_get_property(si2177, reserved, prop, rsp);
+        *data = rsp->get_property.data;
+        return res;
+}
+
+/* _set_property2_insertion_start */
+
+/* --------------------------------------------*/
+/* SET_PROPERTY2 FUNCTION                      */
+/* --------------------------------------------*/
+unsigned char si2177_sendproperty(struct i2c_client *si2177, unsigned int prop, si2177_propobj_t *p, si2177_cmdreplyobj_t *rsp)
+{
+        int data = 0;
+        switch (prop)
+        {
+#ifdef SI2177_ATV_AFC_RANGE_PROP
+                case SI2177_ATV_AFC_RANGE_PROP:
+                        data = (p->atv_afc_range.range_khz & SI2177_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK) << SI2177_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+                        break;
+#endif /*     SI2177_ATV_AFC_RANGE_PROP */
+#ifdef SI2177_ATV_AF_OUT_PROP
+                case SI2177_ATV_AF_OUT_PROP:
+                        data = ((p->atv_af_out.volume & SI2177_ATV_AF_OUT_PROP_VOLUME_MASK) << SI2177_ATV_AF_OUT_PROP_VOLUME_LSB) |
+								((p->atv_af_out.mute   & SI2177_ATV_AF_OUT_PROP_MUTE_MASK  ) << SI2177_ATV_AF_OUT_PROP_MUTE_LSB );
+                        break;
+#endif /*     SI2177_ATV_AF_OUT_PROP */
+#ifdef SI2177_ATV_AGC_SPEED_PROP
+                case SI2177_ATV_AGC_SPEED_PROP:
+                        data = (p->atv_agc_speed.if_agc_speed & SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB ;
+                        break;
+#endif /*     SI2177_ATV_AGC_SPEED_PROP */
+
+#ifdef		  SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP
+	case		 SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP:
+	 data = (p->atv_agc_speed_low_rssi.if_agc_speed & SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_MASK) << SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_LSB	|
+			 (p->atv_agc_speed_low_rssi.thld 		& SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_MASK		  ) << SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_LSB ;
+break;
+#endif /*	  SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP */
+
+#ifdef        SI2177_ATV_ARTIFICIAL_SNOW_PROP
+     case         SI2177_ATV_ARTIFICIAL_SNOW_PROP:
+      data = (p->atv_artificial_snow.gain   & SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK  ) << SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB  |
+              (p->atv_artificial_snow.sound  & SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_MASK ) << SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_LSB  |
+              (p->atv_artificial_snow.period & SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_MASK) << SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_LSB  |
+              (p->atv_artificial_snow.offset & SI2177_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK) << SI2177_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB ;
+break;
+#endif /*	  SI2177_ATV_ARTIFICIAL_SNOW_PROP */
+
+
+#ifdef SI2177_ATV_AUDIO_MODE_PROP
+                case SI2177_ATV_AUDIO_MODE_PROP:
+                        data = (p->atv_audio_mode.audio_sys  & SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK ) << SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB  |
+                                (p->atv_audio_mode.demod_mode & SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK) << SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB  |
+                                (p->atv_audio_mode.chan_bw    & SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK   ) << SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB ;
+                        break;
+#endif /*     SI2177_ATV_AUDIO_MODE_PROP */
+    #ifdef        SI2177_ATV_CONFIG_IF_PORT_PROP
+     case         SI2177_ATV_CONFIG_IF_PORT_PROP:
+      data = (p->atv_config_if_port.atv_out_type & SI2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK) << SI2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB ;
+     break;
+    #endif /*     SI2177_ATV_CONFIG_IF_PORT_PROP */
+#ifdef SI2177_ATV_CVBS_OUT_PROP
+                case SI2177_ATV_CVBS_OUT_PROP:
+                        data = (p->atv_cvbs_out.offset & SI2177_ATV_CVBS_OUT_PROP_OFFSET_MASK) << SI2177_ATV_CVBS_OUT_PROP_OFFSET_LSB  |
+                                (p->atv_cvbs_out.amp    & SI2177_ATV_CVBS_OUT_PROP_AMP_MASK   ) << SI2177_ATV_CVBS_OUT_PROP_AMP_LSB ;
+                        break;
+#endif /*     SI2177_ATV_CVBS_OUT_PROP */
+#ifdef SI2177_ATV_CVBS_OUT_FINE_PROP
+                case SI2177_ATV_CVBS_OUT_FINE_PROP:
+                        data = (p->atv_cvbs_out_fine.offset & SI2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK) << SI2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB  |
+                                (p->atv_cvbs_out_fine.amp    & SI2177_ATV_CVBS_OUT_FINE_PROP_AMP_MASK   ) << SI2177_ATV_CVBS_OUT_FINE_PROP_AMP_LSB ;
+                        break;
+#endif /*     SI2177_ATV_CVBS_OUT_FINE_PROP */
+    #ifdef        SI2177_ATV_HSYNC_OUT_PROP
+     case         SI2177_ATV_HSYNC_OUT_PROP:
+      data = (p->atv_hsync_out.gpio_sel & SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_MASK) << SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_LSB  |
+              (p->atv_hsync_out.width    & SI2177_ATV_HSYNC_OUT_PROP_WIDTH_MASK   ) << SI2177_ATV_HSYNC_OUT_PROP_WIDTH_LSB  |
+              (p->atv_hsync_out.offset   & SI2177_ATV_HSYNC_OUT_PROP_OFFSET_MASK  ) << SI2177_ATV_HSYNC_OUT_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     SI2177_ATV_HSYNC_OUT_PROP */
+#ifdef SI2177_ATV_IEN_PROP
+                case SI2177_ATV_IEN_PROP:
+                        data = (p->atv_ien.chlien  & SI2177_ATV_IEN_PROP_CHLIEN_MASK ) << SI2177_ATV_IEN_PROP_CHLIEN_LSB  |
+                                (p->atv_ien.pclien  & SI2177_ATV_IEN_PROP_PCLIEN_MASK ) << SI2177_ATV_IEN_PROP_PCLIEN_LSB  |
+                                (p->atv_ien.dlien   & SI2177_ATV_IEN_PROP_DLIEN_MASK  ) << SI2177_ATV_IEN_PROP_DLIEN_LSB  |
+                                (p->atv_ien.snrlien & SI2177_ATV_IEN_PROP_SNRLIEN_MASK) << SI2177_ATV_IEN_PROP_SNRLIEN_LSB  |
+                                (p->atv_ien.snrhien & SI2177_ATV_IEN_PROP_SNRHIEN_MASK) << SI2177_ATV_IEN_PROP_SNRHIEN_LSB ;
+                        break;
+#endif /*     SI2177_ATV_IEN_PROP */
+#ifdef SI2177_ATV_INT_SENSE_PROP
+                case SI2177_ATV_INT_SENSE_PROP:
+                        data = (p->atv_int_sense.chlnegen  & SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_MASK ) << SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+                                (p->atv_int_sense.pclnegen  & SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_MASK ) << SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_LSB  |
+                                (p->atv_int_sense.dlnegen   & SI2177_ATV_INT_SENSE_PROP_DLNEGEN_MASK  ) << SI2177_ATV_INT_SENSE_PROP_DLNEGEN_LSB  |
+                                (p->atv_int_sense.snrlnegen & SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK) << SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB  |
+                                (p->atv_int_sense.snrhnegen & SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK) << SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB  |
+                                (p->atv_int_sense.chlposen  & SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_MASK ) << SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_LSB  |
+                                (p->atv_int_sense.pclposen  & SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_MASK ) << SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_LSB  |
+                                (p->atv_int_sense.dlposen   & SI2177_ATV_INT_SENSE_PROP_DLPOSEN_MASK  ) << SI2177_ATV_INT_SENSE_PROP_DLPOSEN_LSB  |
+                                (p->atv_int_sense.snrlposen & SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK) << SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB  |
+                                (p->atv_int_sense.snrhposen & SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK) << SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB ;
+                        break;
+#endif /*     SI2177_ATV_INT_SENSE_PROP */
+    #ifdef        SI2177_ATV_PGA_TARGET_PROP
+     case         SI2177_ATV_PGA_TARGET_PROP:
+      data = (p->atv_pga_target.pga_target      & SI2177_ATV_PGA_TARGET_PROP_PGA_TARGET_MASK     ) << SI2177_ATV_PGA_TARGET_PROP_PGA_TARGET_LSB  |
+              (p->atv_pga_target.override_enable & SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK) << SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB ;
+     break;
+    #endif /*     SI2177_ATV_PGA_TARGET_PROP */
+#ifdef SI2177_ATV_RF_TOP_PROP
+                case SI2177_ATV_RF_TOP_PROP:
+                        data = (p->atv_rf_top.atv_rf_top & SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK) << SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB ;
+                        break;
+#endif /*     SI2177_ATV_RF_TOP_PROP */
+#ifdef SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP
+                case SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP:
+                        data = (p->atv_rsq_rssi_threshold.lo & SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+                                (p->atv_rsq_rssi_threshold.hi & SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+                        break;
+#endif /*     SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef SI2177_ATV_RSQ_SNR_THRESHOLD_PROP
+                case SI2177_ATV_RSQ_SNR_THRESHOLD_PROP:
+                        data = (p->atv_rsq_snr_threshold.lo & SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK) << SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB  |
+                                (p->atv_rsq_snr_threshold.hi & SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK) << SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB ;
+                        break;
+#endif /*     SI2177_ATV_RSQ_SNR_THRESHOLD_PROP */
+#ifdef SI2177_ATV_SOUND_AGC_SPEED_PROP
+                case SI2177_ATV_SOUND_AGC_SPEED_PROP:
+                        data = (p->atv_sound_agc_speed.other_systems & SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK) << SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB |
+                                (p->atv_sound_agc_speed.system_l & SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK) << SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB;
+                        break;
+#endif
+#ifdef SI2177_ATV_SIF_OUT_PROP
+                case SI2177_ATV_SIF_OUT_PROP:
+                        data = (p->atv_sif_out.offset & SI2177_ATV_SIF_OUT_PROP_OFFSET_MASK) << SI2177_ATV_SIF_OUT_PROP_OFFSET_LSB  |
+                                (p->atv_sif_out.amp    & SI2177_ATV_SIF_OUT_PROP_AMP_MASK   ) << SI2177_ATV_SIF_OUT_PROP_AMP_LSB ;
+                        break;
+#endif /*     SI2177_ATV_SIF_OUT_PROP */
+#ifdef SI2177_ATV_SOUND_AGC_LIMIT_PROP
+                case SI2177_ATV_SOUND_AGC_LIMIT_PROP:
+                        data = (p->atv_sound_agc_limit.max_gain & SI2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK) << SI2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB  |
+                                (p->atv_sound_agc_limit.min_gain & SI2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK) << SI2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB ;
+                        break;
+#endif /*     SI2177_ATV_SOUND_AGC_LIMIT_PROP */
+#ifdef        SI2177_ATV_SOUND_AGC_SPEED_PROP_c
+     case         SI2177_ATV_SOUND_AGC_SPEED_PROP:
+      *data = (p->atv_sound_agc_speed.system_l      & SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK     ) << SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB  |
+              (p->atv_sound_agc_speed.other_systems & SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK) << SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB ;
+     break;
+#endif
+#ifdef SI2177_ATV_VIDEO_EQUALIZER_PROP
+                case SI2177_ATV_VIDEO_EQUALIZER_PROP:
+                        data = (p->atv_video_equalizer.slope & SI2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK) << SI2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB ;
+                        break;
+#endif /*     SI2177_ATV_VIDEO_EQUALIZER_PROP */
+#ifdef SI2177_ATV_VIDEO_MODE_PROP
+                case SI2177_ATV_VIDEO_MODE_PROP:
+                        data = (p->atv_video_mode.video_sys       & SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK      ) << SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB  |
+                                (p->atv_video_mode.color           & SI2177_ATV_VIDEO_MODE_PROP_COLOR_MASK          ) << SI2177_ATV_VIDEO_MODE_PROP_COLOR_LSB  |
+                                (p->atv_video_mode.invert_signal   & SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK  ) << SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB ;
+                        break;
+#endif /*     SI2177_ATV_VIDEO_MODE_PROP */
+#ifdef SI2177_ATV_VSNR_CAP_PROP
+                case SI2177_ATV_VSNR_CAP_PROP:
+                        data = (p->atv_vsnr_cap.atv_vsnr_cap & SI2177_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK) << SI2177_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB ;
+                        break;
+#endif /*     SI2177_ATV_VSNR_CAP_PROP */
+#ifdef SI2177_ATV_VSYNC_TRACKING_PROP
+                case SI2177_ATV_VSYNC_TRACKING_PROP:
+                        data = (p->atv_vsync_tracking.min_pulses_to_lock   & SI2177_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK  ) << SI2177_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB  |
+                                (p->atv_vsync_tracking.min_fields_to_unlock & SI2177_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK) << SI2177_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB ;
+                        break;
+#endif /*     SI2177_ATV_VSYNC_TRACKING_PROP */
+#ifdef SI2177_CRYSTAL_TRIM_PROP
+                case SI2177_CRYSTAL_TRIM_PROP:
+                        data = (p->crystal_trim.xo_cap & SI2177_CRYSTAL_TRIM_PROP_XO_CAP_MASK) << SI2177_CRYSTAL_TRIM_PROP_XO_CAP_LSB ;
+                        break;
+#endif /*     SI2177_CRYSTAL_TRIM_PROP */
+#ifdef SI2177_DTV_LIF_FREQ_PROP
+                case SI2177_DTV_LIF_FREQ_PROP:
+                        data = (p->dtv_lif_freq.offset & SI2177_DTV_LIF_FREQ_PROP_OFFSET_MASK) << SI2177_DTV_LIF_FREQ_PROP_OFFSET_LSB ;
+                        break;
+#endif /*     SI2177_DTV_LIF_FREQ_PROP */
+#ifdef SI2177_DTV_LIF_OUT_PROP
+                case SI2177_DTV_LIF_OUT_PROP:
+                        data = (p->dtv_lif_out.offset & SI2177_DTV_LIF_OUT_PROP_OFFSET_MASK) << SI2177_DTV_LIF_OUT_PROP_OFFSET_LSB  |
+                                (p->dtv_lif_out.amp    & SI2177_DTV_LIF_OUT_PROP_AMP_MASK   ) << SI2177_DTV_LIF_OUT_PROP_AMP_LSB ;
+                        break;
+#endif /*     SI2177_DTV_LIF_OUT_PROP */
+
+
+#ifdef SI2177_DTV_MODE_PROP
+                case SI2177_DTV_MODE_PROP:
+                        data = (p->dtv_mode.bw              & SI2177_DTV_MODE_PROP_BW_MASK             ) << SI2177_DTV_MODE_PROP_BW_LSB  |
+                                (p->dtv_mode.modulation      & SI2177_DTV_MODE_PROP_MODULATION_MASK     ) << SI2177_DTV_MODE_PROP_MODULATION_LSB  |
+                                (p->dtv_mode.invert_spectrum & SI2177_DTV_MODE_PROP_INVERT_SPECTRUM_MASK) << SI2177_DTV_MODE_PROP_INVERT_SPECTRUM_LSB ;
+                        break;
+#endif /*     SI2177_DTV_MODE_PROP */
+#ifdef SI2177_DTV_RF_TOP_PROP
+                case SI2177_DTV_RF_TOP_PROP:
+                        data = (p->dtv_rf_top.dtv_rf_top & SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK) << SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB ;
+                        break;
+#endif /*     SI2177_DTV_RF_TOP_PROP */
+#ifdef SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP
+                case SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP:
+                        data = (p->dtv_rsq_rssi_threshold.lo & SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+                                (p->dtv_rsq_rssi_threshold.hi & SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+                        break;
+#endif /*     SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef SI2177_MASTER_IEN_PROP
+                case SI2177_MASTER_IEN_PROP:
+                        data = (p->master_ien.tunien & SI2177_MASTER_IEN_PROP_TUNIEN_MASK) << SI2177_MASTER_IEN_PROP_TUNIEN_LSB  |
+                                (p->master_ien.atvien & SI2177_MASTER_IEN_PROP_ATVIEN_MASK) << SI2177_MASTER_IEN_PROP_ATVIEN_LSB  |
+                                (p->master_ien.dtvien & SI2177_MASTER_IEN_PROP_DTVIEN_MASK) << SI2177_MASTER_IEN_PROP_DTVIEN_LSB  |
+                                (p->master_ien.errien & SI2177_MASTER_IEN_PROP_ERRIEN_MASK) << SI2177_MASTER_IEN_PROP_ERRIEN_LSB  |
+                                (p->master_ien.ctsien & SI2177_MASTER_IEN_PROP_CTSIEN_MASK) << SI2177_MASTER_IEN_PROP_CTSIEN_LSB ;
+                        break;
+#endif /*     SI2177_MASTER_IEN_PROP */
+#ifdef SI2177_TUNER_BLOCKED_VCO_PROP
+                case SI2177_TUNER_BLOCKED_VCO_PROP:
+                        data = (p->tuner_blocked_vco.vco_code & SI2177_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK) << SI2177_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB ;
+                        break;
+#endif /*     SI2177_TUNER_BLOCKED_VCO_PROP */
+#ifdef SI2177_TUNER_IEN_PROP
+                case SI2177_TUNER_IEN_PROP:
+                        data = (p->tuner_ien.tcien    & SI2177_TUNER_IEN_PROP_TCIEN_MASK   ) << SI2177_TUNER_IEN_PROP_TCIEN_LSB  |
+                                (p->tuner_ien.rssilien & SI2177_TUNER_IEN_PROP_RSSILIEN_MASK) << SI2177_TUNER_IEN_PROP_RSSILIEN_LSB  |
+                                (p->tuner_ien.rssihien & SI2177_TUNER_IEN_PROP_RSSIHIEN_MASK) << SI2177_TUNER_IEN_PROP_RSSIHIEN_LSB ;
+                        break;
+#endif /*     SI2177_TUNER_IEN_PROP */
+#ifdef SI2177_TUNER_INT_SENSE_PROP
+                case SI2177_TUNER_INT_SENSE_PROP:
+                        data = (p->tuner_int_sense.tcnegen    & SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_MASK   ) << SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_LSB  |
+                                (p->tuner_int_sense.rssilnegen & SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK) << SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB  |
+                                (p->tuner_int_sense.rssihnegen & SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK) << SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB  |
+                                (p->tuner_int_sense.tcposen    & SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_MASK   ) << SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_LSB  |
+                                (p->tuner_int_sense.rssilposen & SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK) << SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB  |
+                                (p->tuner_int_sense.rssihposen & SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK) << SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB ;
+                        break;
+#endif /*     SI2177_TUNER_INT_SENSE_PROP */
+#ifdef SI2177_TUNER_LO_INJECTION_PROP
+                case SI2177_TUNER_LO_INJECTION_PROP:
+                        data = (p->tuner_lo_injection.band_1 & SI2177_TUNER_LO_INJECTION_PROP_BAND_1_MASK) << SI2177_TUNER_LO_INJECTION_PROP_BAND_1_LSB  |
+                                (p->tuner_lo_injection.band_2 & SI2177_TUNER_LO_INJECTION_PROP_BAND_2_MASK) << SI2177_TUNER_LO_INJECTION_PROP_BAND_2_LSB  |
+                                (p->tuner_lo_injection.band_3 & SI2177_TUNER_LO_INJECTION_PROP_BAND_3_MASK) << SI2177_TUNER_LO_INJECTION_PROP_BAND_3_LSB  ;
+     break;
+#endif /*     SI2177_TUNER_LO_INJECTION_PROP */
+    #ifdef        SI2177_TUNER_RETURN_LOSS_PROP
+     case         SI2177_TUNER_RETURN_LOSS_PROP_CODE:
+      data = (p->tuner_return_loss.config & SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_MASK) << SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_LSB  |
+              (p->tuner_return_loss.mode   & SI2177_TUNER_RETURN_LOSS_PROP_MODE_MASK  ) << SI2177_TUNER_RETURN_LOSS_PROP_MODE_LSB ;
+     break;
+    #endif /*     SI2177_TUNER_RETURN_LOSS_PROP */
+    #ifdef        SI2177_XOUT_PROP
+     case         SI2177_XOUT_PROP_CODE:
+      data = (p->xout.amp & SI2177_XOUT_PROP_AMP_MASK) << SI2177_XOUT_PROP_AMP_LSB ;
+     break;
+#endif /*     SI2177_XOUT_PROP */
+                default :
+                        break;
+        }
+        return si2177_setproperty(si2177, prop , data, rsp);
+}
+/* _set_property2_insertion_point */
+
+/* _get_property2_insertion_start */
+
+/* --------------------------------------------*/
+/* GET_PROPERTY2 FUNCTION                       */
+/* --------------------------------------------*/
+unsigned char si2177_receiveproperty(struct i2c_client *si2177, unsigned int prop, si2177_propobj_t *p, si2177_cmdreplyobj_t *rsp)
+{
+        int data, res;
+
+        res = si2177_getproperty(si2177, prop, &data, rsp);
+
+        if (res!=NO_SI2177_ERROR)
+                return res;
+        switch (prop)
+        {
+#ifdef SI2177_ATV_AFC_RANGE_PROP
+                case SI2177_ATV_AFC_RANGE_PROP:
+                        p->atv_afc_range.range_khz = (data >> SI2177_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB) & SI2177_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK;
+                        break;
+#endif /*     SI2177_ATV_AFC_RANGE_PROP */
+#ifdef SI2177_ATV_AF_OUT_PROP
+                case SI2177_ATV_AF_OUT_PROP:
+                        p->atv_af_out.volume = (data >> SI2177_ATV_AF_OUT_PROP_VOLUME_LSB) & SI2177_ATV_AF_OUT_PROP_VOLUME_MASK;
+               			p->atv_af_out.mute   = (data >> SI2177_ATV_AF_OUT_PROP_MUTE_LSB  ) & SI2177_ATV_AF_OUT_PROP_MUTE_MASK;
+                        break;
+#endif /*     SI2177_ATV_AF_OUT_PROP */
+#ifdef SI2177_ATV_AGC_SPEED_PROP
+                case SI2177_ATV_AGC_SPEED_PROP:
+                        p->atv_agc_speed.if_agc_speed = (data >> SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB) & SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK;
+                        break;
+#endif /*     SI2177_ATV_AGC_SPEED_PROP */
+    #ifdef        SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP
+     case         SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP:
+               p->atv_agc_speed_low_rssi.if_agc_speed = (data >> SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_LSB) & SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_MASK;
+               p->atv_agc_speed_low_rssi.thld         = (data >> SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_LSB        ) & SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_MASK;
+     break;
+    #endif /*     SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP */
+    #ifdef        SI2177_ATV_ARTIFICIAL_SNOW_PROP
+     case         SI2177_ATV_ARTIFICIAL_SNOW_PROP:
+               p->atv_artificial_snow.gain   = (data >> SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB  ) & SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK;
+               p->atv_artificial_snow.sound  = (data >> SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_LSB ) & SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_MASK;
+               p->atv_artificial_snow.period = (data >> SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_LSB) & SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_MASK;
+               p->atv_artificial_snow.offset = (data >> SI2177_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB) & SI2177_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK;
+     break;
+    #endif /*     SI2177_ATV_ARTIFICIAL_SNOW_PROP */
+#ifdef SI2177_ATV_AUDIO_MODE_PROP
+                case SI2177_ATV_AUDIO_MODE_PROP:
+                        p->atv_audio_mode.audio_sys      = (data >> SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB ) & SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK;
+                        p->atv_audio_mode.demod_mode = (data >> SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB) & SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK;
+                        p->atv_audio_mode.chan_bw        = (data >> SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB   ) & SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK;
+                        break;
+#endif /*     SI2177_ATV_AUDIO_MODE_PROP */
+    #ifdef        SI2177_ATV_CONFIG_IF_PORT_PROP
+     case         SI2177_ATV_CONFIG_IF_PORT_PROP:
+               p->atv_config_if_port.atv_out_type = (data >> SI2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB) & SI2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK;
+     break;
+    #endif /*     SI2177_ATV_CONFIG_IF_PORT_PROP */
+#ifdef SI2177_ATV_CVBS_OUT_PROP
+                case SI2177_ATV_CVBS_OUT_PROP:
+                        p->atv_cvbs_out.offset = (data >> SI2177_ATV_CVBS_OUT_PROP_OFFSET_LSB) & SI2177_ATV_CVBS_OUT_PROP_OFFSET_MASK;
+                        p->atv_cvbs_out.amp   = (data >> SI2177_ATV_CVBS_OUT_PROP_AMP_LSB   ) & SI2177_ATV_CVBS_OUT_PROP_AMP_MASK;
+                        break;
+#endif /*     SI2177_ATV_CVBS_OUT_PROP */
+#ifdef SI2177_ATV_CVBS_OUT_FINE_PROP
+                case SI2177_ATV_CVBS_OUT_FINE_PROP:
+                        p->atv_cvbs_out_fine.offset = (data >> SI2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB) & SI2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK;
+                        p->atv_cvbs_out_fine.amp   = (data >> SI2177_ATV_CVBS_OUT_FINE_PROP_AMP_LSB   ) & SI2177_ATV_CVBS_OUT_FINE_PROP_AMP_MASK;
+                        break;
+#endif /*     SI2177_ATV_CVBS_OUT_FINE_PROP */
+    #ifdef        SI2177_ATV_HSYNC_OUT_PROP
+     case         SI2177_ATV_HSYNC_OUT_PROP:
+               p->atv_hsync_out.gpio_sel = (data >> SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_LSB) & SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_MASK;
+               p->atv_hsync_out.width    = (data >> SI2177_ATV_HSYNC_OUT_PROP_WIDTH_LSB   ) & SI2177_ATV_HSYNC_OUT_PROP_WIDTH_MASK;
+               p->atv_hsync_out.offset   = (data >> SI2177_ATV_HSYNC_OUT_PROP_OFFSET_LSB  ) & SI2177_ATV_HSYNC_OUT_PROP_OFFSET_MASK;
+     break;
+    #endif /*     SI2177_ATV_HSYNC_OUT_PROP */
+#ifdef SI2177_ATV_IEN_PROP
+                case SI2177_ATV_IEN_PROP:
+                        p->atv_ien.chlien   = (data >> SI2177_ATV_IEN_PROP_CHLIEN_LSB ) & SI2177_ATV_IEN_PROP_CHLIEN_MASK;
+                        p->atv_ien.pclien   = (data >> SI2177_ATV_IEN_PROP_PCLIEN_LSB ) & SI2177_ATV_IEN_PROP_PCLIEN_MASK;
+                        p->atv_ien.dlien     = (data >> SI2177_ATV_IEN_PROP_DLIEN_LSB  ) & SI2177_ATV_IEN_PROP_DLIEN_MASK;
+                        p->atv_ien.snrlien  = (data >> SI2177_ATV_IEN_PROP_SNRLIEN_LSB) & SI2177_ATV_IEN_PROP_SNRLIEN_MASK;
+                        p->atv_ien.snrhien = (data >> SI2177_ATV_IEN_PROP_SNRHIEN_LSB) & SI2177_ATV_IEN_PROP_SNRHIEN_MASK;
+                        break;
+#endif /*     SI2177_ATV_IEN_PROP */
+#ifdef SI2177_ATV_INT_SENSE_PROP
+                case SI2177_ATV_INT_SENSE_PROP:
+                        p->atv_int_sense.chlnegen  = (data >> SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_LSB ) & SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_MASK;
+                        p->atv_int_sense.pclnegen  = (data >> SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_LSB ) & SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_MASK;
+                        p->atv_int_sense.dlnegen    = (data >> SI2177_ATV_INT_SENSE_PROP_DLNEGEN_LSB  ) & SI2177_ATV_INT_SENSE_PROP_DLNEGEN_MASK;
+                        p->atv_int_sense.snrlnegen = (data >> SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB) & SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK;
+                        p->atv_int_sense.snrhnegen = (data >> SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB) & SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK;
+                        p->atv_int_sense.chlposen   = (data >> SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_LSB ) & SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_MASK;
+                        p->atv_int_sense.pclposen   = (data >> SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_LSB ) & SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_MASK;
+                        p->atv_int_sense.dlposen     = (data >> SI2177_ATV_INT_SENSE_PROP_DLPOSEN_LSB  ) & SI2177_ATV_INT_SENSE_PROP_DLPOSEN_MASK;
+                        p->atv_int_sense.snrlposen  = (data >> SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB) & SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK;
+                        p->atv_int_sense.snrhposen = (data >> SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB) & SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK;
+                        break;
+    #endif /*     SI2177_ATV_INT_SENSE_PROP */
+    #ifdef        SI2177_ATV_PGA_TARGET_PROP
+     case         SI2177_ATV_PGA_TARGET_PROP:
+               p->atv_pga_target.pga_target      = (data >> SI2177_ATV_PGA_TARGET_PROP_PGA_TARGET_LSB     ) & SI2177_ATV_PGA_TARGET_PROP_PGA_TARGET_MASK;
+               p->atv_pga_target.override_enable = (data >> SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB) & SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK;
+     break;
+    #endif /*     SI2177_ATV_PGA_TARGET_PROP */
+#ifdef SI2177_ATV_RF_TOP_PROP
+                case SI2177_ATV_RF_TOP_PROP:
+                        p->atv_rf_top.atv_rf_top = (data >> SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB) & SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK;
+                        break;
+#endif /*     SI2177_ATV_RF_TOP_PROP */
+#ifdef SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP
+                case SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP:
+                        p->atv_rsq_rssi_threshold.lo = (data >> SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB) & SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK;
+                        p->atv_rsq_rssi_threshold.hi = (data >> SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB) & SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK;
+                        break;
+#endif /*     SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef SI2177_ATV_RSQ_SNR_THRESHOLD_PROP
+                case SI2177_ATV_RSQ_SNR_THRESHOLD_PROP:
+                        p->atv_rsq_snr_threshold.lo = (data >> SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB) & SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK;
+                        p->atv_rsq_snr_threshold.hi = (data >> SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB) & SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK;
+                        break;
+#endif /*     SI2177_ATV_RSQ_SNR_THRESHOLD_PROP */
+#ifdef SI2177_ATV_SIF_OUT_PROP
+                case SI2177_ATV_SIF_OUT_PROP:
+                        p->atv_sif_out.offset  = (data >> SI2177_ATV_SIF_OUT_PROP_OFFSET_LSB) & SI2177_ATV_SIF_OUT_PROP_OFFSET_MASK;
+                        p->atv_sif_out.amp    = (data >> SI2177_ATV_SIF_OUT_PROP_AMP_LSB   ) & SI2177_ATV_SIF_OUT_PROP_AMP_MASK;
+                        break;
+#endif /*     SI2177_ATV_SIF_OUT_PROP */
+#ifdef SI2177_ATV_SOUND_AGC_LIMIT_PROP
+                case SI2177_ATV_SOUND_AGC_LIMIT_PROP:
+                        p->atv_sound_agc_limit.max_gain = (data >> SI2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB) & SI2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK;
+                        p->atv_sound_agc_limit.min_gain  = (data >> SI2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB) & SI2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK;
+                        break;
+#endif /*     SI2177_ATV_SOUND_AGC_LIMIT_PROP */
+    #ifdef        SI2177_ATV_SOUND_AGC_SPEED_PROP
+     case         SI2177_ATV_SOUND_AGC_SPEED_PROP:
+               p->atv_sound_agc_speed.system_l      = (data >> SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB     ) & SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK;
+               p->atv_sound_agc_speed.other_systems = (data >> SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB) & SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK;
+     break;
+    #endif /*     SI2177_ATV_SOUND_AGC_SPEED_PROP */
+#ifdef SI2177_ATV_VIDEO_EQUALIZER_PROP
+                case SI2177_ATV_VIDEO_EQUALIZER_PROP:
+                        p->atv_video_equalizer.slope = (data >> SI2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB) & SI2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK;
+                        break;
+#endif /*     SI2177_ATV_VIDEO_EQUALIZER_PROP */
+#ifdef SI2177_ATV_VIDEO_MODE_PROP
+                case SI2177_ATV_VIDEO_MODE_PROP:
+                        p->atv_video_mode.video_sys     = (data >> SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB      ) & SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK;
+                        p->atv_video_mode.color             = (data >> SI2177_ATV_VIDEO_MODE_PROP_COLOR_LSB          ) & SI2177_ATV_VIDEO_MODE_PROP_COLOR_MASK;
+               			p->atv_video_mode.invert_signal = (data >> SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB) & SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK;
+                        break;
+#endif /*     SI2177_ATV_VIDEO_MODE_PROP */
+#ifdef SI2177_ATV_VSNR_CAP_PROP
+                case SI2177_ATV_VSNR_CAP_PROP:
+                        p->atv_vsnr_cap.atv_vsnr_cap = (data >> SI2177_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB) & SI2177_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK;
+                        break;
+#endif /*     SI2177_ATV_VSNR_CAP_PROP */
+#ifdef SI2177_ATV_VSYNC_TRACKING_PROP
+                case SI2177_ATV_VSYNC_TRACKING_PROP:
+                        p->atv_vsync_tracking.min_pulses_to_lock   = (data >> SI2177_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB  ) & SI2177_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK;
+                        p->atv_vsync_tracking.min_fields_to_unlock = (data >> SI2177_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB) & SI2177_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK;
+                        break;
+#endif /*     SI2177_ATV_VSYNC_TRACKING_PROP */
+#ifdef SI2177_CRYSTAL_TRIM_PROP
+                case SI2177_CRYSTAL_TRIM_PROP:
+                        p->crystal_trim.xo_cap = (data >> SI2177_CRYSTAL_TRIM_PROP_XO_CAP_LSB) & SI2177_CRYSTAL_TRIM_PROP_XO_CAP_MASK;
+                        break;
+#endif /*     SI2177_CRYSTAL_TRIM_PROP */
+#ifdef SI2177_MASTER_IEN_PROP
+                case SI2177_MASTER_IEN_PROP:
+                        p->master_ien.tunien = (data >> SI2177_MASTER_IEN_PROP_TUNIEN_LSB) & SI2177_MASTER_IEN_PROP_TUNIEN_MASK;
+                        p->master_ien.atvien = (data >> SI2177_MASTER_IEN_PROP_ATVIEN_LSB) & SI2177_MASTER_IEN_PROP_ATVIEN_MASK;
+                        p->master_ien.dtvien = (data >> SI2177_MASTER_IEN_PROP_DTVIEN_LSB) & SI2177_MASTER_IEN_PROP_DTVIEN_MASK;
+                        p->master_ien.errien = (data >> SI2177_MASTER_IEN_PROP_ERRIEN_LSB) & SI2177_MASTER_IEN_PROP_ERRIEN_MASK;
+                        p->master_ien.ctsien = (data >> SI2177_MASTER_IEN_PROP_CTSIEN_LSB) & SI2177_MASTER_IEN_PROP_CTSIEN_MASK;
+                        break;
+#endif /*     SI2177_MASTER_IEN_PROP */
+#ifdef SI2177_TUNER_BLOCKED_VCO_PROP
+                case SI2177_TUNER_BLOCKED_VCO_PROP:
+                        p->tuner_blocked_vco.vco_code = (data >> SI2177_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB) & SI2177_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK;
+                        break;
+#endif /*     SI2177_TUNER_BLOCKED_VCO_PROP */
+#ifdef SI2177_TUNER_IEN_PROP
+                case SI2177_TUNER_IEN_PROP:
+                        p->tuner_ien.tcien      = (data >> SI2177_TUNER_IEN_PROP_TCIEN_LSB   ) & SI2177_TUNER_IEN_PROP_TCIEN_MASK;
+                        p->tuner_ien.rssilien  = (data >> SI2177_TUNER_IEN_PROP_RSSILIEN_LSB) & SI2177_TUNER_IEN_PROP_RSSILIEN_MASK;
+                        p->tuner_ien.rssihien = (data >> SI2177_TUNER_IEN_PROP_RSSIHIEN_LSB) & SI2177_TUNER_IEN_PROP_RSSIHIEN_MASK;
+                        break;
+#endif /*     SI2177_TUNER_IEN_PROP */
+#ifdef SI2177_TUNER_INT_SENSE_PROP
+                case SI2177_TUNER_INT_SENSE_PROP:
+                        p->tuner_int_sense.tcnegen      = (data >> SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_LSB   ) & SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_MASK;
+                        p->tuner_int_sense.rssilnegen  = (data >> SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB) & SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK;
+                        p->tuner_int_sense.rssihnegen = (data >> SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB) & SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK;
+                        p->tuner_int_sense.tcposen      = (data >> SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_LSB   ) & SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_MASK;
+                        p->tuner_int_sense.rssilposen  = (data >> SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB) & SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK;
+                        p->tuner_int_sense.rssihposen = (data >> SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB) & SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK;
+                        break;
+#endif /*     SI2177_TUNER_INT_SENSE_PROP */
+#ifdef SI2177_TUNER_LO_INJECTION_PROP
+                case SI2177_TUNER_LO_INJECTION_PROP:
+                        p->tuner_lo_injection.band_1 = (data >> SI2177_TUNER_LO_INJECTION_PROP_BAND_1_LSB) & SI2177_TUNER_LO_INJECTION_PROP_BAND_1_MASK;
+                        p->tuner_lo_injection.band_2 = (data >> SI2177_TUNER_LO_INJECTION_PROP_BAND_2_LSB) & SI2177_TUNER_LO_INJECTION_PROP_BAND_2_MASK;
+                        p->tuner_lo_injection.band_3 = (data >> SI2177_TUNER_LO_INJECTION_PROP_BAND_3_LSB) & SI2177_TUNER_LO_INJECTION_PROP_BAND_3_MASK;
+                        break;
+#endif /*     SI2177_TUNER_LO_INJECTION_PROP */
+    #ifdef        SI2177_TUNER_RETURN_LOSS_PROP
+     case         SI2177_TUNER_RETURN_LOSS_PROP:
+               p->tuner_return_loss.config = (data >> SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_LSB) & SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_MASK;
+               p->tuner_return_loss.mode   = (data >> SI2177_TUNER_RETURN_LOSS_PROP_MODE_LSB  ) & SI2177_TUNER_RETURN_LOSS_PROP_MODE_MASK;
+     break;
+    #endif /*     SI2177_TUNER_RETURN_LOSS_PROP */
+    #ifdef        SI2177_XOUT_PROP
+     case         SI2177_XOUT_PROP:
+               p->xout.amp = (data >> SI2177_XOUT_PROP_AMP_LSB) & SI2177_XOUT_PROP_AMP_MASK;
+     break;
+    #endif /*     SI2177_XOUT_PROP */
+    default :
+                        break;
+        }
+        return res;
+}
+
+/************************************************************************************************************************
+NAME: si2177_SetupATVDefaults
+DESCRIPTION: Setup si2177 ATV startup configuration
+This is a list of all the ATV configuration properties.   Depending on your application, only a subset may be required.
+The properties are stored in the global property structure 'prop'.  The function ATVConfig(..) must be called
+after any properties are modified.
+Parameter:  none
+Returns:    0 if successful
+Programming Guide Reference:    Flowchart A.5 (ATV Setup flowchart)
+
+ ************************************************************************************************************************/
+static int si2177_setupatvdefaults(si2177_propobj_t *prop)
+{
+
+#ifdef    SI2177_ATV_AFC_RANGE_PROP
+		  prop->atv_afc_range.range_khz 			 =	1000; /* (default  1000) */
+#endif /* SI2177_ATV_AFC_RANGE_PROP */
+
+#ifdef    SI2177_ATV_AF_OUT_PROP
+		  prop->atv_af_out.volume					 =	   53; /* (default	  0) */
+		  prop->atv_af_out.mute 					 = SI2177_ATV_AF_OUT_PROP_MUTE_NORMAL	; /* (default 'NORMAL') */
+#endif /* SI2177_ATV_AF_OUT_PROP */
+
+#ifdef    SI2177_ATV_AGC_SPEED_PROP
+		  prop->atv_agc_speed.if_agc_speed			 = 178 ; /* (default 'AUTO') */
+#endif /* SI2177_ATV_AGC_SPEED_PROP */
+
+#ifdef    SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP
+		  prop->atv_agc_speed_low_rssi.if_agc_speed  = SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_158 ; /* (default '158') */
+		  prop->atv_agc_speed_low_rssi.thld 		 =	-128; /* (default  -128) */
+#endif /* SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP */
+
+#ifdef    SI2177_ATV_ARTIFICIAL_SNOW_PROP
+		  prop->atv_artificial_snow.gain			 = SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_AUTO   ; /* (default 'AUTO') */
+		  prop->atv_artificial_snow.sound			 = SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_MUTE  ; /* (default 'MUTE') */
+		  prop->atv_artificial_snow.period			 = SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_LONG ; /* (default 'LONG') */
+		  prop->atv_artificial_snow.offset			 =	   0; /* (default	  0) */
+#endif /* SI2177_ATV_ARTIFICIAL_SNOW_PROP */
+
+#ifdef    SI2177_ATV_AUDIO_MODE_PROP
+		  prop->atv_audio_mode.audio_sys			 = SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO  ; /* (default 'DEFAULT') */
+		  prop->atv_audio_mode.demod_mode			 = SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_FM1	 ; /* (default 'SIF') */
+		  prop->atv_audio_mode.chan_bw				 = SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT	 ; /* (default 'DEFAULT') */
+#endif /* SI2177_ATV_AUDIO_MODE_PROP */
+
+#ifdef    SI2177_ATV_CONFIG_IF_PORT_PROP
+		  prop->atv_config_if_port.atv_out_type 	 = SI2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_CVBS_IF2B_SOUND_IF2A ; /* (default 'CVBS_IF2B_SOUND_IF2A') */
+#endif /* SI2177_ATV_CONFIG_IF_PORT_PROP */
+
+#ifdef    SI2177_ATV_CVBS_OUT_PROP
+		  prop->atv_cvbs_out.offset 				 =	  25; /* (default	 25) */
+		  prop->atv_cvbs_out.amp					 =	 cvbs_amp; /* (default	200) */
+#endif /* SI2177_ATV_CVBS_OUT_PROP */
+
+#ifdef    SI2177_ATV_CVBS_OUT_FINE_PROP
+		  prop->atv_cvbs_out_fine.offset			 =	   4; /* (default	  0) */
+		  prop->atv_cvbs_out_fine.amp				 =	 100; /* (default	100) */
+#endif /* SI2177_ATV_CVBS_OUT_FINE_PROP */
+
+#ifdef    SI2177_ATV_HSYNC_OUT_PROP
+		  prop->atv_hsync_out.gpio_sel				 = SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_GPIO1; /* (default 'NONE') */
+		  prop->atv_hsync_out.width 				 =	  42; /* (default	 42) */
+		  prop->atv_hsync_out.offset				 =	   0; /* (default	  0) */
+#endif /* SI2177_ATV_HSYNC_OUT_PROP */
+
+#ifdef    SI2177_ATV_IEN_PROP
+		  prop->atv_ien.chlien						 = SI2177_ATV_IEN_PROP_CHLIEN_ENABLE   ; /* (default 'ENABLE') */
+		  prop->atv_ien.pclien						 = SI2177_ATV_IEN_PROP_PCLIEN_DISABLE  ; /* (default 'DISABLE') */
+		  prop->atv_ien.dlien						 = SI2177_ATV_IEN_PROP_DLIEN_DISABLE   ; /* (default 'DISABLE') */
+		  prop->atv_ien.snrlien 					 = SI2177_ATV_IEN_PROP_SNRLIEN_DISABLE ; /* (default 'DISABLE') */
+		  prop->atv_ien.snrhien 					 = SI2177_ATV_IEN_PROP_SNRHIEN_DISABLE ; /* (default 'DISABLE') */
+#endif /* SI2177_ATV_IEN_PROP */
+
+#ifdef    SI2177_ATV_INT_SENSE_PROP
+		  prop->atv_int_sense.chlnegen				 = SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE  ; /* (default 'DISABLE') */
+		  prop->atv_int_sense.pclnegen				 = SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE  ; /* (default 'DISABLE') */
+		  prop->atv_int_sense.dlnegen				 = SI2177_ATV_INT_SENSE_PROP_DLNEGEN_DISABLE   ; /* (default 'DISABLE') */
+		  prop->atv_int_sense.snrlnegen 			 = SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_DISABLE ; /* (default 'DISABLE') */
+		  prop->atv_int_sense.snrhnegen 			 = SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_DISABLE ; /* (default 'DISABLE') */
+		  prop->atv_int_sense.chlposen				 = SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE   ; /* (default 'ENABLE') */
+		  prop->atv_int_sense.pclposen				 = SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE   ; /* (default 'ENABLE') */
+		  prop->atv_int_sense.dlposen				 = SI2177_ATV_INT_SENSE_PROP_DLPOSEN_ENABLE    ; /* (default 'ENABLE') */
+		  prop->atv_int_sense.snrlposen 			 = SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_ENABLE  ; /* (default 'ENABLE') */
+		  prop->atv_int_sense.snrhposen 			 = SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_ENABLE  ; /* (default 'ENABLE') */
+#endif /* SI2177_ATV_INT_SENSE_PROP */
+
+#ifdef    SI2177_ATV_PGA_TARGET_PROP
+		  prop->atv_pga_target.pga_target			 =	   0; /* (default	  0) */
+		  prop->atv_pga_target.override_enable		 = SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE ; /* (default 'DISABLE') */
+#endif /* SI2177_ATV_PGA_TARGET_PROP */
+
+#ifdef    SI2177_ATV_RF_TOP_PROP
+		  prop->atv_rf_top.atv_rf_top				 = SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO ; /* (default 'AUTO') */
+#endif /* SI2177_ATV_RF_TOP_PROP */
+
+#ifdef    SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP
+		  prop->atv_rsq_rssi_threshold.lo			 =	 -80; /* (default	-70) */
+		  prop->atv_rsq_rssi_threshold.hi			 =	   0; /* (default	  0) */
+#endif /* SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP */
+
+#ifdef    SI2177_ATV_RSQ_SNR_THRESHOLD_PROP
+		  prop->atv_rsq_snr_threshold.lo			 =	  10; /* (default	 25) */
+		  prop->atv_rsq_snr_threshold.hi			 =	  45; /* (default	 45) */
+#endif /* SI2177_ATV_RSQ_SNR_THRESHOLD_PROP */
+
+#ifdef    SI2177_ATV_SIF_OUT_PROP
+		  prop->atv_sif_out.offset					 =	 135; /* (default	135) */
+		  prop->atv_sif_out.amp 					 =	  60; /* (default	 60) */
+#endif /* SI2177_ATV_SIF_OUT_PROP */
+
+#ifdef    SI2177_ATV_SOUND_AGC_LIMIT_PROP
+		  prop->atv_sound_agc_limit.max_gain		 =	  84; /* (default	 84) */
+		  prop->atv_sound_agc_limit.min_gain		 =	 -84; /* (default	-84) */
+#endif /* SI2177_ATV_SOUND_AGC_LIMIT_PROP */
+
+#ifdef    SI2177_ATV_SOUND_AGC_SPEED_PROP
+		  prop->atv_sound_agc_speed.system_l		 =	   5; /* (default	  5) */
+		  prop->atv_sound_agc_speed.other_systems	 =	   4; /* (default	  4) */
+#endif /* SI2177_ATV_SOUND_AGC_SPEED_PROP */
+
+#ifdef    SI2177_ATV_VIDEO_EQUALIZER_PROP
+		  prop->atv_video_equalizer.slope			 =	   0; /* (default	  0) */
+#endif /* SI2177_ATV_VIDEO_EQUALIZER_PROP */
+
+#ifdef    SI2177_ATV_VIDEO_MODE_PROP
+		  prop->atv_video_mode.video_sys			 = SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK			 ; /* (default 'B') */
+		  prop->atv_video_mode.color				 = SI2177_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC		 ; /* (default 'PAL_NTSC') */
+		  prop->atv_video_mode.invert_signal		 = SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_NORMAL	 ; /* (default 'NORMAL') */
+#endif /* SI2177_ATV_VIDEO_MODE_PROP */
+
+#ifdef    SI2177_ATV_VSNR_CAP_PROP
+		  prop->atv_vsnr_cap.atv_vsnr_cap			 =	   0; /* (default	  0) */
+#endif /* SI2177_ATV_VSNR_CAP_PROP */
+
+
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2177_SetupCommonDefaults
+DESCRIPTION: Setup si2177 Common startup configuration
+This is a list of all the common configuration properties.   Depending on your application, only a subset may be required.
+The properties are stored in the global property structure 'prop'.  The function CommonConfig(..) must be called
+after any of these properties are modified.
+Parameter:  none
+Returns:    0 if successful
+Programming Guide Reference:    Flowchart A.6a (Common setup flowchart)
+ ************************************************************************************************************************/
+static int si2177_setupcommondefaults(si2177_propobj_t *prop)
+{
+#ifdef    SI2177_CRYSTAL_TRIM_PROP
+	  prop->crystal_trim.xo_cap 				 = SI2177_CRYSTAL_TRIM_PROP_XO_CAP_6P7PF ; /* (default '6p7pF') */
+#endif /* SI2177_CRYSTAL_TRIM_PROP */
+
+#ifdef    SI2177_MASTER_IEN_PROP
+	  prop->master_ien.tunien					 = SI2177_MASTER_IEN_PROP_TUNIEN_ON ; /* (default 'OFF') */
+	  prop->master_ien.atvien					 = SI2177_MASTER_IEN_PROP_ATVIEN_ON ; /* (default 'OFF') */
+	  prop->master_ien.dtvien					 = SI2177_MASTER_IEN_PROP_DTVIEN_OFF ; /* (default 'OFF') */
+	  prop->master_ien.errien					 = SI2177_MASTER_IEN_PROP_ERRIEN_OFF ; /* (default 'OFF') */
+	  prop->master_ien.ctsien					 = SI2177_MASTER_IEN_PROP_CTSIEN_ON ; /* (default 'OFF') */
+#endif /* SI2177_MASTER_IEN_PROP */
+
+#ifdef    SI2177_XOUT_PROP
+	  prop->xout.amp							 = SI2177_XOUT_PROP_AMP_HIGH ; /* (default 'HIGH') */
+#endif /* SI2177_XOUT_PROP */
+
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2177_SetupTunerDefaults
+DESCRIPTION: Setup si2177 Tuner startup configuration
+This is a list of all the Tuner configuration properties.   Depending on your application, only a subset may be required.
+The properties are stored in the global property structure 'prop'.  The function TunerConfig(..) must be called
+after any of these properties are modified.
+Parameter:  none
+Returns:    0 if successful
+Programming Guide Reference:    Flowchart A.6a (Tuner setup flowchart)
+ ************************************************************************************************************************/
+static int si2177_setuptunerdefaults(si2177_propobj_t *prop)
+{
+
+
+#ifdef    SI2177_TUNER_BLOCKED_VCO_PROP
+  prop->tuner_blocked_vco.vco_code           = 0x8000; /* (default 0x8000) */
+#endif /* SI2177_TUNER_BLOCKED_VCO_PROP */
+
+#ifdef    SI2177_TUNER_IEN_PROP
+  prop->tuner_ien.tcien                      = SI2177_TUNER_IEN_PROP_TCIEN_ENABLE     ; /* (default 'ENABLE') */
+  prop->tuner_ien.rssilien                   = SI2177_TUNER_IEN_PROP_RSSILIEN_ENABLE ; /* (default 'DISABLE') */
+  prop->tuner_ien.rssihien                   = SI2177_TUNER_IEN_PROP_RSSIHIEN_DISABLE ; /* (default 'DISABLE') */
+#endif /* SI2177_TUNER_IEN_PROP */
+
+#ifdef    SI2177_TUNER_INT_SENSE_PROP
+  prop->tuner_int_sense.tcnegen              = SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE    ; /* (default 'DISABLE') */
+  prop->tuner_int_sense.rssilnegen           = SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE ; /* (default 'DISABLE') */
+  prop->tuner_int_sense.rssihnegen           = SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE ; /* (default 'DISABLE') */
+  prop->tuner_int_sense.tcposen              = SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE     ; /* (default 'ENABLE') */
+  prop->tuner_int_sense.rssilposen           = SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE  ; /* (default 'ENABLE') */
+  prop->tuner_int_sense.rssihposen           = SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE  ; /* (default 'ENABLE') */
+#endif /* SI2177_TUNER_INT_SENSE_PROP */
+
+#ifdef    SI2177_TUNER_LO_INJECTION_PROP
+  prop->tuner_lo_injection.band_1            = SI2177_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE ; /* (default 'HIGH_SIDE') */
+  prop->tuner_lo_injection.band_2            = SI2177_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+  prop->tuner_lo_injection.band_3            = SI2177_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+#endif /* SI2177_TUNER_LO_INJECTION_PROP */
+
+#ifdef    SI2177_TUNER_RETURN_LOSS_PROP
+  prop->tuner_return_loss.config             = SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_127         ; /* (default '127') */
+  prop->tuner_return_loss.mode               = SI2177_TUNER_RETURN_LOSS_PROP_MODE_TERRESTRIAL   ; /* (default 'TERRESTRIAL') */
+#endif /* SI2177_TUNER_RETURN_LOSS_PROP */
+
+        return 0;
+}
+
+/************************************************************************************************************************
+NAME: si2177_ATVConfig
+DESCRIPTION: Setup si2177 ATV properties configuration
+This function will download all the ATV configuration properties stored in the global structure 'prop.
+Depending on your application, only a subset may be required to be modified.
+The function si2177_SetupATVDefaults() should be called before the first call to this function. Afterwards
+to change a property change the appropriate element in the property structure 'prop' and call this routine.
+Use the comments above the SetProperty2 calls as a guide to the parameters which are changed.
+Parameter:  Pointer to si2177 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+Programming Guide Reference:    Flowchart A.5 (ATV setup flowchart)
+ ************************************************************************************************************************/
+int si2177_atvconfig(struct i2c_client *si2177, si2177_propobj_t *prop, si2177_cmdreplyobj_t *rsp)
+{
+
+#ifdef    SI2177_ATV_AFC_RANGE_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_AFC_RANGE_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_AFC_RANGE_PROP */
+#ifdef    SI2177_ATV_AF_OUT_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_AF_OUT_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_AF_OUT_PROP */
+#ifdef    SI2177_ATV_AGC_SPEED_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_AGC_SPEED_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_AGC_SPEED_PROP */
+#ifdef    SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP */
+#ifdef    SI2177_ATV_ARTIFICIAL_SNOW_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_ARTIFICIAL_SNOW_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_ARTIFICIAL_SNOW_PROP */
+#ifdef    SI2177_ATV_AUDIO_MODE_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_AUDIO_MODE_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_AUDIO_MODE_PROP */
+#ifdef    SI2177_ATV_CONFIG_IF_PORT_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_CONFIG_IF_PORT_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_CONFIG_IF_PORT_PROP */
+#ifdef    SI2177_ATV_CVBS_OUT_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_CVBS_OUT_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_CVBS_OUT_PROP */
+#ifdef    SI2177_ATV_CVBS_OUT_FINE_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_CVBS_OUT_FINE_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_CVBS_OUT_FINE_PROP */
+#ifdef    SI2177_ATV_HSYNC_OUT_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_HSYNC_OUT_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_HSYNC_OUT_PROP */
+#ifdef    SI2177_ATV_IEN_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_IEN_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_IEN_PROP */
+#ifdef    SI2177_ATV_INT_SENSE_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_INT_SENSE_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_INT_SENSE_PROP */
+#ifdef    SI2177_ATV_PGA_TARGET_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_PGA_TARGET_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_PGA_TARGET_PROP */
+#ifdef    SI2177_ATV_RF_TOP_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_RF_TOP_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_RF_TOP_PROP */
+#ifdef    SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef    SI2177_ATV_RSQ_SNR_THRESHOLD_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_RSQ_SNR_THRESHOLD_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_RSQ_SNR_THRESHOLD_PROP */
+#ifdef    SI2177_ATV_SIF_OUT_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_SIF_OUT_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_SIF_OUT_PROP */
+#ifdef    SI2177_ATV_SOUND_AGC_LIMIT_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_SOUND_AGC_LIMIT_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_SOUND_AGC_LIMIT_PROP */
+#ifdef    SI2177_ATV_SOUND_AGC_SPEED_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_SOUND_AGC_SPEED_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_SOUND_AGC_SPEED_PROP */
+#ifdef    SI2177_ATV_VIDEO_EQUALIZER_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_VIDEO_EQUALIZER_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_VIDEO_EQUALIZER_PROP */
+#ifdef    SI2177_ATV_VIDEO_MODE_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_VIDEO_MODE_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_VIDEO_MODE_PROP */
+#ifdef    SI2177_ATV_VSNR_CAP_PROP
+  if (si2177_sendproperty(si2177, SI2177_ATV_VSNR_CAP_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_ATV_VSNR_CAP_PROP */
+
+        return 0;
+}
+
+/************************************************************************************************************************
+NAME: si2177_CommonConfig
+DESCRIPTION: Setup si2177 Common properties configuration
+This function will download all the DTV configuration properties stored in the global structure 'prop.
+Depending on your application, only a subset may be required to be modified.
+The function si2177_SetupCommonDefaults() should be called before the first call to this function. Afterwards
+to change a property change the appropriate element in the property structure 'prop' and call this routine.
+Use the comments above the si2177_sendproperty calls as a guide to the parameters which are changed.
+Parameter:  Pointer to si2177 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+Programming Guide Reference:    Flowchart A.6a (Common setup flowchart)
+ ************************************************************************************************************************/
+int si2177_commonconfig(struct i2c_client *si2177, si2177_propobj_t *prop, si2177_cmdreplyobj_t *rsp)
+{
+
+        /* Setting si2177_MASTER_IEN_PROP property */
+        /***
+          prop.master_ien.atvien,
+          prop.master_ien.ctsien,
+          prop.master_ien.dtvien,
+          prop.master_ien.errien,
+          prop.master_ien.tunien  */
+
+        if (si2177_sendproperty(si2177, SI2177_MASTER_IEN_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Setting si2177_CRYSTAL_TRIM_PROP */
+        //rop.crystal_trim.xo_cap
+        if (si2177_sendproperty(si2177, SI2177_CRYSTAL_TRIM_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+#ifdef    SI2177_XOUT_PROP
+  		if (si2177_sendproperty(si2177, SI2177_XOUT_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_XOUT_PROP */
+
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2177_TunerConfig
+DESCRIPTION: Setup si2177 Tuner (RF to IF analog path) properties configuration
+This function will download all the DTV configuration properties stored in the global structure 'prop.
+Depending on your application, only a subset may be required to be modified.
+The function si2177_SetupTunerDefaults() should be called before the first call to this function. Afterwards
+to change a property change the appropriate element in the property structure 'prop' and call this routine.
+Use the comments above the si2177_sendproperty calls as a guide to the parameters which are changed.
+Parameter:  Pointer to si2177 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+Programming Guide Reference:    Flowchart A.6a (Tuner setup flowchart)
+ ************************************************************************************************************************/
+int si2177_tunerconfig(struct i2c_client *si2177, si2177_propobj_t *prop, si2177_cmdreplyobj_t *rsp)
+{
+
+#ifdef    SI2177_TUNER_BLOCKED_VCO_PROP
+		  if (si2177_sendproperty(si2177, SI2177_TUNER_BLOCKED_VCO_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_TUNER_BLOCKED_VCO_PROP */
+#ifdef    SI2177_TUNER_IEN_PROP
+		  if (si2177_sendproperty(si2177, SI2177_TUNER_IEN_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_TUNER_IEN_PROP */
+#ifdef    SI2177_TUNER_INT_SENSE_PROP
+		  if (si2177_sendproperty(si2177, SI2177_TUNER_INT_SENSE_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_TUNER_INT_SENSE_PROP */
+#ifdef    SI2177_TUNER_LO_INJECTION_PROP
+		  if (si2177_sendproperty(si2177, SI2177_TUNER_LO_INJECTION_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_TUNER_LO_INJECTION_PROP */
+#ifdef    SI2177_TUNER_RETURN_LOSS_PROP
+		  if (si2177_sendproperty(si2177, SI2177_TUNER_RETURN_LOSS_PROP, prop, rsp) != NO_SI2177_ERROR) {return ERROR_SI2177_SENDING_COMMAND;}
+#endif /* SI2177_TUNER_RETURN_LOSS_PROP */
+        return 0;
+}
+/************************************************************************************************************************
+NAME: Si2170_SetupDTVDefaults
+DESCRIPTION: Setup Si2170 DTV startup configuration
+This is a list of all the DTV configuration properties.   Depending on your application, only a subset may be required.
+The properties are stored in the global property structure 'prop'.  The function DTVConfig(..) must be called
+after any properties are modified.
+Parameter:  none
+Returns:    0 if successful
+Programming Guide Reference:    Flowchart A.6 (DTV setup flowchart)
+
+ ************************************************************************************************************************/
+static int si2177_setupdtvdefaults(si2177_propobj_t *prop, int ch_mode)
+{
+        prop->dtv_config_if_port.dtv_out_type   = SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1;
+        prop->dtv_config_if_port.dtv_agc_source = SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL;
+        prop->dtv_lif_freq.offset = 5000;
+        prop->dtv_mode.bw = SI2177_DTV_MODE_PROP_BW_BW_8MHZ;
+        prop->dtv_mode.invert_spectrum = SI2177_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL;
+        //set in the get tuner ops
+        prop->dtv_mode.modulation = SI2177_DTV_MODE_PROP_MODULATION_DTMB;
+        prop->dtv_rsq_rssi_threshold.hi=0;
+        prop->dtv_rsq_rssi_threshold.lo=-80;
+        prop->dtv_ext_agc.max_10mv=250;
+        prop->dtv_ext_agc.min_10mv=50;
+        if(ch_mode == 4)
+                prop->dtv_lif_out.amp=25;//22;//27;//23;
+        else
+                prop->dtv_lif_out.amp=25;//27;
+
+        prop->dtv_lif_out.offset=148;
+        prop->dtv_agc_speed.agc_decim=SI2177_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;
+        prop->dtv_agc_speed.if_agc_speed=SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+        prop->dtv_rf_top.dtv_rf_top=SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO;
+        prop->dtv_int_sense.chlnegen=SI2177_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE;
+        prop->dtv_int_sense.chlposen=SI2177_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE;
+        prop->dtv_ien.chlien  = SI2177_DTV_IEN_PROP_CHLIEN_ENABLE;      /* enable only CHL to drive DTVINT */
+        return 0;
+}
+/************************************************************************************************************************
+NAME: Si2170_DTVConfig
+DESCRIPTION: Setup Si2170 DTV properties configuration
+This function will download all the DTV configuration properties stored in the global structure 'prop.
+Depending on your application, only a subset may be required to be modified.
+The function Si2170_SetupDTVDefaults() should be called before the first call to this function. Afterwards
+to change a property change the appropriate element in the property structure 'prop' and call this routine.
+Use the comments above the Si2170_L1_SetProperty2 calls as a guide to the parameters which are changed.
+Parameter:  Pointer to Si2170 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+Programming Guide Reference:    Flowchart A.6 (DTV setup flowchart)
+ ************************************************************************************************************************/
+int si2177_dtvconfig(struct i2c_client *si2177, si2177_propobj_t *prop, si2177_cmdreplyobj_t *rsp)
+{
+
+        /* Setting DTV_CONFIG_IF_PORT_PROP property */
+        /*	prop.dtv_config_if_port.dtv_out_type,
+                prop.dtv_config_if_port.dtv_agc_source */
+        if (si2177_sendproperty(si2177, SI2177_DTV_CONFIG_IF_PORT_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_LIF_FREQ_PROP */
+        //	prop.dtv_lif_freq.offset
+        if (si2177_sendproperty(si2177, SI2177_DTV_LIF_FREQ_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_MODE_PROP property */
+        /*	prop.dtv_mode.bw,
+                prop.dtv_mode.invert_spectrum,
+                prop.dtv_mode.modulation*/
+        if (si2177_sendproperty(si2177, SI2177_DTV_MODE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_RSQ_RSSI_THRESHOLD property */
+        //	prop.dtv_rsq_rssi_threshold.hi,
+        //	prop.dtv_rsq_rssi_threshold.lo
+        if (si2177_sendproperty(si2177, SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_EXT_AGC property */
+        //	prop.dtv_ext_agc.max_10mv,
+        //	prop.dtv_ext_agc.min_10mv
+        if (si2177_sendproperty(si2177, SI2177_DTV_EXT_AGC_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_LIF_OUT property */
+        //	prop.dtv_lif_out.amp,
+        //	prop.dtv_lif_out.offset
+        if (si2177_sendproperty(si2177, SI2177_DTV_LIF_OUT_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_AGC_SPEED property */
+        //	prop.dtv_agc_speed.agc_decim,
+        //	prop.dtv_agc_speed.if_agc_speed
+        if (si2177_sendproperty(si2177, SI2177_DTV_AGC_SPEED_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_RF_TOP property */
+        //	prop.dtv_rf_top.dtv_rf_top
+        if (si2177_sendproperty(si2177, SI2177_DTV_RF_TOP_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Setting DTV_INT_SENSE property */
+        //	prop.dtv_int_sense.chlnegen,
+        //	prop.dtv_int_sense.chlposen
+        if (si2177_sendproperty(si2177, SI2177_DTV_INT_SENSE_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        /* Set DTV_IEN property */
+        /*	prop.dtv_ien.chlien */
+        if (si2177_sendproperty(si2177, SI2177_DTV_IEN_PROP, prop, rsp) != 0)
+        {
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+
+        return 0;
+}
+
+
+/************************************************************************************************************************
+NAME: si2177_Tune
+DESCRIPTIION: Tune si2177 in specified mode (ATV/DTV) at center frequency, wait for TUNINT and xTVINT with timeout
+
+Parameter:  Pointer to si2177 Context (I2C address)
+Parameter:  Mode (ATV or DTV) use si2177_TUNER_TUNE_FREQ_CMD_MODE_ATV or si2177_TUNER_TUNE_FREQ_CMD_MODE_DTV constants
+Parameter:  frequency (Hz) as a unsigned long integer
+Parameter:  rsp - commandResp structure to returns tune status info.
+Returns:    0 if channel found.  A nonzero value means either an error occurred or channel not locked.
+Programming Guide Reference:    Flowchart A.7 (Tune flowchart)
+ ************************************************************************************************************************/
+int si2177_tune(struct i2c_client *si2177, unsigned char mode, unsigned long freq, si2177_cmdreplyobj_t *rsp, si2177_common_reply_struct *common_reply)
+{
+        int return_code = 0,count = 0;
+
+        if (si2177_tuner_tune_freq(si2177, mode, freq, rsp) != 0)
+        {
+               // pr_info("%s: tuner tune freq error:%d!!!!\n", __func__, ERROR_SI2177_SENDING_COMMAND);
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+        mdelay(5);
+        for (count=50; count ;count--)
+        {
+                return_code = si2177_pollforcts(si2177);
+                if (!return_code)
+                        break;
+                mdelay(2);
+        }
+        if (!count)
+        {
+                pr_info("%s: poll cts error:%d!!!!\n", __func__, return_code);
+                return return_code;
+        }
+        mdelay(delay_det);
+#if 0
+        /* wait for TUNINT, timeout is 150ms */
+        for (count=75; count ;count--)
+        {
+                if ((return_code = si2177_check_status(si2177, common_reply)) != 0)
+                        return return_code;
+                if (common_reply->tunint)
+                        break;
+                mdelay(2);
+        }
+        if (!count)
+        {
+                pr_info("%s: ERROR_SI2177_TUNINT_TIMEOUT error:%d!!!!\n", __func__, ERROR_SI2177_TUNINT_TIMEOUT);
+                return ERROR_SI2177_TUNINT_TIMEOUT;
+        }
+        /* wait for xTVINT, timeout is 350ms for ATVINT and 6 ms for DTVINT */
+        count = ((mode==SI2177_TUNER_TUNE_FREQ_CMD_MODE_ATV) ? 300 : 3);
+        for (;count ;count--)
+        {
+                if ((return_code = si2177_check_status(si2177, common_reply)) != 0)
+                        return return_code;
+                if ((mode==SI2177_TUNER_TUNE_FREQ_CMD_MODE_ATV) ? common_reply->atvint : common_reply->dtvint)
+                        break;
+                mdelay(2);
+        }
+        if (!count)
+        {
+                pr_info("%s: ERROR_SI2177_XTVINT_TIMEOUT error:%d!!!!\n", __func__, ERROR_SI2177_XTVINT_TIMEOUT);
+                return ERROR_SI2177_XTVINT_TIMEOUT;
+        }
+#endif
+        return return_code;
+}
+
+/************************************************************************************************************************
+NAME: si2177_LoadVideofilter
+DESCRIPTION:        Load video filters from vidfiltTable in si2177_write_xTV_video_coeffs.h file into si2177
+Programming Guide Reference:    Flowchart A.4 (Download Video Filters flowchart)
+
+Parameter:  si2177 Context (I2C address)
+Parameter:  pointer to video filter table array
+Parameter:  number of lines in video filter table array (size in bytes / BYTES_PER_LINE)
+Returns:    si2177/I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2177_loadvideofilter(struct i2c_client *si2177, unsigned char* vidfilttable, int lines, si2177_common_reply_struct *common_reply)
+{
+#define BYTES_PER_LINE 8
+        int line;
+
+        /* for each 8 bytes in VIDFILT_TABLE */
+        for (line = 0; line < lines; line++)
+        {
+                /* send that 8 byte I2C command to si2177 */
+                if (si2177_api_patch(si2177, BYTES_PER_LINE, vidfilttable+BYTES_PER_LINE*line, common_reply) != 0)
+                {
+                        return ERROR_SI2177_SENDING_COMMAND;
+                }
+        }
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2177_Configure
+DESCRIPTION: Setup si2177 video filters, GPIOs/clocks, Common Properties startup, Tuner startup, ATV startup, and DTV startup.
+Parameter:  Pointer to si2177 Context (I2C address)
+Parameter:  rsp - commandResp structure buffer.
+Returns:    I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2177_configure(struct i2c_client *si2177, si2177_propobj_t *prop, si2177_cmdreplyobj_t *rsp, si2177_common_reply_struct *common_reply)
+{
+        int return_code = 0;
+
+        /* load ATV video filter file */
+#ifdef USING_ATV_FILTER
+        if ((return_code = si2177_loadvideofilter(si2177, dlif_vidfilt_table, DLIF_VIDFILT_LINES, common_reply) != 0)
+                        return return_code;
+#endif
+#if 0
+                        /* Set the GPIO Pins using the CONFIG_PINS command*/
+                        if (si2177_config_pins(si2177,      /* turn off BCLK1 and XOUT */
+                                        SI2177_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE,
+                                        SI2177_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ,
+                                        SI2177_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE,
+                                        SI2177_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ,
+                                        SI2177_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE,
+                                        SI2177_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ,
+                                        SI2177_CONFIG_PINS_CMD_BCLK1_MODE_ENABLE,
+                                        SI2177_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ,
+                                        SI2177_CONFIG_PINS_CMD_XOUT_MODE_ENABLE,
+                                        rsp) !=0)
+                        {
+                        pr_info("%s: config pins error:%d!!!!\n", __func__, ERROR_SI2177_SENDING_COMMAND);
+                        return ERROR_SI2177_SENDING_COMMAND;
+                        }
+#endif
+#if  1
+                        /* Set Common Properties startup configuration */
+                        si2177_setupcommondefaults(prop);
+                        if ((return_code = si2177_commonconfig(si2177, prop, rsp)) != 0)
+                        {
+                                pr_info("%s: setup command defaults error:%d!!!!\n", __func__, return_code);
+                                return return_code;
+                        }
+
+                        /* Set Tuner Properties startup configuration */
+                        si2177_setuptunerdefaults(prop);
+                        if ((return_code = si2177_tunerconfig(si2177, prop, rsp)) != 0)
+                        {
+                                pr_info("%s: setup tuner defaults error:%d!!!!\n", __func__, return_code);
+                                return return_code;
+                        }
+                        /* Set ATV startup configuration */
+                        si2177_setupatvdefaults(prop);
+                        if ((return_code = si2177_atvconfig(si2177, prop, rsp)) != 0)
+                        {
+                                pr_info("%s: setup atv defaults error:%d!!!!\n", __func__, return_code);
+                                return return_code;
+                        }
+                        /* Set DTV startup configuration */
+                        si2177_setupdtvdefaults(prop, 4);
+                        if ((return_code = si2177_dtvconfig(si2177, prop, rsp)) != 0)
+                        {
+                                pr_info("%s: setup dtv defaults error:%d!!!!\n", __func__, return_code);
+                                return return_code;
+                        }
+#endif
+
+                        return return_code;
+}
+/************************************************************************************************************************
+NAME: si2177_LoadFirmware
+DESCRIPTON: Load firmware from FIRMWARE_TABLE array in si2177_Firmware_x_y_build_z.h file into si2177
+Requires si2177 to be in bootloader mode after PowerUp
+Programming Guide Reference:    Flowchart A.3 (Download FW PATCH flowchart)
+
+Parameter:  si2177 Context (I2C address)
+Parameter:  pointer to firmware table array
+Parameter:  number of lines in firmware table array (size in bytes / BYTES_PER_LINE)
+Returns:    si2177/I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+
+
+int si2177_loadfirmware(struct i2c_client *si2177, struct firmware_struct * firmwaretable, int lines, si2177_common_reply_struct *common_reply)
+{
+        int return_code = 0;
+        int line;
+
+
+        for (line = 0; line < lines; line++)
+        {
+
+                if (si2177_api_patch(si2177, firmwaretable[line].firmware_len, firmwaretable[line].firmware_table, common_reply) != 0){
+                        return ERROR_SI2177_LOADING_FIRMWARE;
+                }
+
+        }
+        return return_code;
+}
+
+
+/************************************************************************************************************************
+NAME: si2177_StartFirmware
+DESCRIPTION: Start si2177 firmware (put the si2177 into run mode)
+Parameter:   si2177 Context (I2C address)
+Parameter (passed by Reference): 	ExitBootloadeer Response Status byte : tunint, atvint, dtvint, err, cts
+Returns:     I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2177_startfirmware(struct i2c_client *si2177, si2177_cmdreplyobj_t *rsp)
+{
+
+        if (si2177_exit_bootloader(si2177, SI2177_EXIT_BOOTLOADER_CMD_FUNC_TUNER, SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_OFF, rsp) != 0)
+        {
+                return ERROR_SI2177_STARTING_FIRMWARE;
+        }
+
+        return 0;
+}
+/************************************************************************************************************************
+NAME: si2177_PowerUpWithPatch
+DESCRIPTION: Send si2177 API PowerUp Command with PowerUp to bootloader,
+Check the Chip rev and part, and ROMID are compared to expected values.
+Load the Firmware Patch then Start the Firmware.
+Programming Guide Reference:    Flowchart A.2a (POWER_UP with patch flowchart)
+
+Parameter:  si2177 Context (I2C address)
+Returns:    si2177/I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2177_powerupwithpatch(struct i2c_client *si2177, si2177_cmdreplyobj_t *rsp, si2177_common_reply_struct *common_reply)
+{
+        int return_code = 0, num = 0;
+
+        return_code = si2177_power_up(si2177,          /* always wait for CTS prior to POWER_UP command */
+                       	SI2177_POWER_UP_CMD_SUBCODE_CODE,
+                       	SI2177_POWER_UP_CMD_CLOCK_MODE_XTAL,
+                       	SI2177_POWER_UP_CMD_EN_XOUT_DIS_XOUT,
+						SI2177_POWER_UP_CMD_PD_LDO_LDO_POWER_UP,
+						SI2177_POWER_UP_CMD_RESERVED2_RESERVED,
+						SI2177_POWER_UP_CMD_RESERVED3_RESERVED,
+						SI2177_POWER_UP_CMD_RESERVED4_RESERVED,
+						SI2177_POWER_UP_CMD_RESERVED5_RESERVED,
+						SI2177_POWER_UP_CMD_RESERVED6_RESERVED,
+						SI2177_POWER_UP_CMD_RESERVED7_RESERVED,
+						SI2177_POWER_UP_CMD_RESET_RESET,
+						SI2177_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ,
+						SI2177_POWER_UP_CMD_RESERVED8_RESERVED,
+						SI2177_POWER_UP_CMD_FUNC_BOOTLOADER,
+						SI2177_POWER_UP_CMD_RESERVED9_RESERVED,
+						SI2177_POWER_UP_CMD_CTSIEN_DISABLE,
+						SI2177_POWER_UP_CMD_WAKE_UP_WAKE_UP,
+                        rsp);
+        if (return_code)
+                pr_info("%s: si2177_power_up error:%d!!!\n", __func__, return_code);
+
+#if 0
+        /* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+        if (si2177_part_info(si2177, &rsp) != 0)
+                return ERROR_SI2177_SENDING_COMMAND;
+        /* Check the Chip revision, part and ROMID against expected values and report an error if incompatible */
+        if (rsp.part_info.chiprev != chiprev)
+                return ERROR_SI2177_INCOMPATIBLE_PART;
+        /* Part Number is represented as the last 2 digits */
+        if (rsp.part_info.part != part)
+                return ERROR_SI2177_INCOMPATIBLE_PART;
+        /* Part Major Version in ASCII */
+        if (rsp.part_info.pmajor != partmajorversion)
+                return ERROR_SI2177_INCOMPATIBLE_PART;
+
+#endif
+        mdelay(25);
+/* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+
+		if (return_code = si2177_part_info(si2177,rsp)) {
+			pr_info ("SI2177__PART_INFO error %x, %s\n", return_code,__func__ );
+			return return_code;
+		}
+		pr_info("chiprev %d\n", 	   rsp->part_info.chiprev);
+		pr_info("part	 SI21%d\n",    rsp->part_info.part   );
+		pr_info("pmajor  %d\n", 	   rsp->part_info.pmajor );
+		if (rsp->part_info.pmajor >= 0x30) {
+		pr_info("pmajor '%c'\n",	   rsp->part_info.pmajor );
+		}
+		pr_info("pminor  %d\n", 	   rsp->part_info.pminor );
+		if (rsp->part_info.pminor >= 0x30) {
+		pr_info("pminor '%c'\n",	   rsp->part_info.pminor );
+		}
+		pr_info("pbuild %d\n",		   rsp->part_info.pbuild );
+		pr_info("romid %3d/0x%02x\n",  rsp->part_info.romid,  rsp->part_info.romid );
+
+     /* Load the Firmware */
+    //for version 2177_30_b_5
+    if(rsp->part_info.romid == 0x50){
+			/* Only load the Firmware if we are NOT a SI2177-A30 part*/
+		if ((rsp->part_info.pmajor == '3') && (rsp->part_info.pminor == '0') && (rsp->part_info.pbuild == 5))
+    	{
+          printk ("No firmware to download. Loading from NVM only\n" );
+    	}else{
+    		printk("si2177 load firmware firmwaretable_2177_30_b_5.\n");
+			num = (sizeof(SI2177_FW_3_0b5)/(sizeof(firmware_struct)));
+			return_code = si2177_loadfirmware(si2177,SI2177_FW_3_0b5,num,common_reply);
+
+		}
+
+	}else{
+		printk("[si2177..]%s:there is no correct firmaware to load because of the romid\n",__func__);
+		return return_code;
+	}
+	if (return_code != 0){
+        pr_info("%s: si2177_loadfirmware error:%d!!!\n", __func__, return_code);
+        return return_code;
+    }
+
+        /*Start the Firmware */
+    	if ((return_code = si2177_startfirmware(si2177, rsp)) != 0) /* Start firmware */
+        {
+                pr_info("%s: si2177_startfirmware error:%d!!!\n", __func__, return_code);
+                return return_code;
+        }
+        mdelay(50);
+        if (si2177_get_rev(si2177, rsp) != 0)
+        {
+                pr_info("%s: si2177_get_rev error:%d!!!\n", __func__, ERROR_SI2177_SENDING_COMMAND);
+                return ERROR_SI2177_SENDING_COMMAND;
+        }
+        else
+        {
+                pr_info("%s: rsp.get_rev.pn :      %d \n", __func__, rsp->get_rev.pn);
+                pr_info("%s: rsp.get_rev.fwmajor : %d \n", __func__, rsp->get_rev.fwmajor);
+                pr_info("%s: rsp.get_rev.fwminor : %d \n", __func__, rsp->get_rev.fwminor);
+                pr_info("%s: rsp.get_rev.patch :   %d \n", __func__, rsp->get_rev.patch);
+                pr_info("%s: rsp.get_rev.cmpmajor :%d \n", __func__, rsp->get_rev.cmpmajor);
+                pr_info("%s: rsp.get_rev.cmpminor :%d \n", __func__, rsp->get_rev.cmpminor);
+                pr_info("%s: rsp.get_rev.cmpbuild :%d \n", __func__, rsp->get_rev.cmpbuild);
+                pr_info("%s: rsp.get_rev.chiprev : %d \n", __func__, (u32)rsp->get_rev.chiprev);
+        }
+
+        return return_code;
+}
+
+
+/************************************************************************************************************************
+NAME: si2177_Init
+DESCRIPTION:Reset and Initialize si2177
+Parameter:  si2177 Context (I2C address)
+Returns:    I2C transaction error code, 0 if successful
+ ************************************************************************************************************************/
+int si2177_init(struct i2c_client *si2177, si2177_cmdreplyobj_t *rsp, si2177_common_reply_struct *common_reply)
+{
+        int return_code = 0;
+
+        /* Reset si2177 */
+        /* TODO: SendRSTb requires porting to toggle the RSTb line low -> high */
+        //sendrstb();
+
+        return_code = si2177_powerupwithpatch(si2177, rsp, common_reply);
+        if (return_code)		/* PowerUp into bootloader */
+        {
+                pr_info("%s: init si2177 error!!!\n", __func__);
+        }
+
+        /* At this point, FW is loaded and started.  Return 0*/
+        return return_code;
+}
+
+
+
+
diff --git a/drivers/amlogic/dvb_tv/si2177/si2177_func.h b/drivers/amlogic/dvb_tv/si2177/si2177_func.h
new file mode 100755
index 000000000000..cce8dd108458
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2177/si2177_func.h
@@ -0,0 +1,3034 @@
+/*
+ * Sli2177 Device Driver
+ *
+ * Author: Bobby Yang <hui.fang@amlogic.com>
+ *
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __SLI2177_FUN_H
+#define __SLI2177_FUN_H
+
+#include <linux/amlogic/tvin/tvin.h>
+#include "../aml_fe.h"
+#define NO_SI2177_ERROR                     0x00
+#define ERROR_SI2177_PARAMETER_OUT_OF_RANGE 0x01
+#define ERROR_SI2177_ALLOCATING_CONTEXT     0x02
+#define ERROR_SI2177_SENDING_COMMAND        0x03
+#define ERROR_SI2177_CTS_TIMEOUT            0x04
+#define ERROR_SI2177_ERR                    0x05
+#define ERROR_SI2177_POLLING_CTS            0x06
+#define ERROR_SI2177_POLLING_RESPONSE       0x07
+#define ERROR_SI2177_LOADING_FIRMWARE       0x08
+#define ERROR_SI2177_LOADING_BOOTBLOCK      0x09
+#define ERROR_SI2177_STARTING_FIRMWARE      0x0a
+#define ERROR_SI2177_SW_RESET               0x0b
+#define ERROR_SI2177_INCOMPATIBLE_PART      0x0c
+#define ERROR_SI2177_TUNINT_TIMEOUT         0x0d
+#define ERROR_SI2177_xTVINT_TIMEOUT         0x0e
+#define ERROR_SI2177_UNKNOWN_COMMAND        0xf0
+#define ERROR_SI2177_UNKNOWN_PROPERTY       0xf1
+
+
+/* status structure definition */
+typedef struct { /* si2177_common_reply_struct */
+    unsigned char   tunint;
+    unsigned char   atvint;
+    unsigned char   dtvint;
+    unsigned char   err;
+    unsigned char   cts;
+} si2177_common_reply_struct;
+
+/* _status_defines_insertion_start */
+#define SI2177_COMMAND_PROTOTYPES
+
+
+/* STATUS fields definition */
+/* STATUS, TUNINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2177_STATUS_TUNINT_LSB                            0
+#define  SI2177_STATUS_TUNINT_MASK                         0x01
+#define SI2177_STATUS_TUNINT_NOT_TRIGGERED     0
+#define SI2177_STATUS_TUNINT_TRIGGERED              1
+/* STATUS, ATVINT field definition (size 1, lsb 1, unsigned)*/
+#define  SI2177_STATUS_ATVINT_LSB                            1
+#define  SI2177_STATUS_ATVINT_MASK                         0x01
+#define SI2177_STATUS_ATVINT_NOT_TRIGGERED     0
+#define SI2177_STATUS_ATVINT_TRIGGERED              1
+/* STATUS, DTVINT field definition (size 1, lsb 2, unsigned)*/
+#define  SI2177_STATUS_DTVINT_LSB                            2
+#define  SI2177_STATUS_DTVINT_MASK                         0x01
+#define SI2177_STATUS_DTVINT_NOT_TRIGGERED     0
+#define SI2177_STATUS_DTVINT_TRIGGERED              1
+/* STATUS, ERR field definition (size 1, lsb 6, unsigned)*/
+#define  SI2177_STATUS_ERR_LSB                                  6
+#define  SI2177_STATUS_ERR_MASK                               0x01
+#define SI2177_STATUS_ERR_ERROR                            1
+#define SI2177_STATUS_ERR_NO_ERROR                     0
+/* STATUS, CTS field definition (size 1, lsb 7, unsigned)*/
+#define  SI2177_STATUS_CTS_LSB                                   7
+#define  SI2177_STATUS_CTS_MASK                               0x01
+#define SI2177_STATUS_CTS_COMPLETED                   1
+#define SI2177_STATUS_CTS_WAIT                                0
+
+/* _status_defines_insertion_point */
+
+/* _commands_defines_insertion_start */
+/* SI2177_AGC_OVERRIDE command definition */
+#define SI2177_AGC_OVERRIDE_CMD                               0x44
+
+#ifdef    SI2177_AGC_OVERRIDE_CMD
+
+typedef struct { /* SI2177_AGC_OVERRIDE_CMD_struct */
+     unsigned char   force_max_gain;
+     unsigned char   force_top_gain;
+} si2177_agc_override_cmd_struct;
+
+/* AGC_OVERRIDE command, FORCE_MAX_GAIN field definition (size 1, lsb 0, unsigned) */
+#define  SI2177_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_LSB          0
+#define  SI2177_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MASK       0x01
+#define  SI2177_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MIN           0
+#define  SI2177_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MAX          1
+#define SI2177_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_DISABLE  0
+#define SI2177_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_ENABLE   1
+/* AGC_OVERRIDE command, FORCE_TOP_GAIN field definition (size 1, lsb 1, unsigned) */
+#define  SI2177_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_LSB           1
+#define  SI2177_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MASK        0x01
+#define  SI2177_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MIN           0
+#define  SI2177_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MAX          1
+#define SI2177_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_DISABLE  0
+#define SI2177_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_ENABLE   1
+
+typedef struct { /* SI2177_AGC_OVERRIDE_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_agc_override_cmd_reply_struct;
+
+#endif /* SI2177_AGC_OVERRIDE_CMD */
+
+/* SI2177_ATV_CW_TEST command definition */
+//#define SI2177_ATV_CW_TEST_CMD 0x53
+
+#ifdef    SI2177_ATV_CW_TEST_CMD
+
+typedef struct { /* SI2177_ATV_CW_TEST_CMD_struct */
+     unsigned char   pc_lock;
+} si2177_atv_cw_test_cmd_struct;
+
+/* ATV_CW_TEST command, PC_LOCK field definition (size 1, lsb 0, unsigned) */
+#define  SI2177_ATV_CW_TEST_CMD_PC_LOCK_LSB          0
+#define  SI2177_ATV_CW_TEST_CMD_PC_LOCK_MASK       0x01
+#define  SI2177_ATV_CW_TEST_CMD_PC_LOCK_MIN          0
+#define  SI2177_ATV_CW_TEST_CMD_PC_LOCK_MAX         1
+#define SI2177_ATV_CW_TEST_CMD_PC_LOCK_LOCK       1
+#define SI2177_ATV_CW_TEST_CMD_PC_LOCK_UNLOCK  0
+
+typedef struct { /* SI2177_ATV_CW_TEST_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_atv_cw_test_cmd_reply_struct;
+
+#endif /* SI2177_ATV_CW_TEST_CMD */
+
+/* SI2177_ATV_RESTART command definition */
+#define SI2177_ATV_RESTART_CMD                                         0x51
+
+#ifdef    SI2177_ATV_RESTART_CMD
+
+typedef struct { /* SI2177_ATV_RESTART_CMD_struct */
+     unsigned char   mode;
+} si2177_atv_restart_cmd_struct;
+
+/* ATV_RESTART command, MODE field definition (size 1, lsb 0, unsigned) */
+#define  SI2177_ATV_RESTART_CMD_MODE_LSB                     0
+#define  SI2177_ATV_RESTART_CMD_MODE_MASK                  0x01
+#define  SI2177_ATV_RESTART_CMD_MODE_MIN                      0
+#define  SI2177_ATV_RESTART_CMD_MODE_MAX                     1
+#define SI2177_ATV_RESTART_CMD_MODE_AUDIO_ONLY      1
+#define SI2177_ATV_RESTART_CMD_MODE_AUDIO_VIDEO    0
+
+typedef struct { /* SI2177_ATV_RESTART_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_atv_restart_cmd_reply_struct;
+
+#endif /* SI2177_ATV_RESTART_CMD */
+
+/* SI2177_ATV_STATUS command definition */
+#define SI2177_ATV_STATUS_CMD                                                  0x52
+
+#ifdef    SI2177_ATV_STATUS_CMD
+
+typedef struct { /* SI2177_ATV_STATUS_CMD_struct */
+     unsigned char   intack;
+} si2177_atv_status_cmd_struct;
+
+/* ATV_STATUS command, INTACK field definition (size 1, lsb 0, unsigned) */
+#define  SI2177_ATV_STATUS_CMD_INTACK_LSB                    0
+#define  SI2177_ATV_STATUS_CMD_INTACK_MASK                 0x01
+#define  SI2177_ATV_STATUS_CMD_INTACK_MIN                    0
+#define  SI2177_ATV_STATUS_CMD_INTACK_MAX                   1
+#define SI2177_ATV_STATUS_CMD_INTACK_CLEAR               1
+#define SI2177_ATV_STATUS_CMD_INTACK_OK                      0
+
+typedef struct { /* SI2177_ATV_STATUS_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+      unsigned char   chlint;
+      unsigned char   pclint;
+      unsigned char   dlint;
+      unsigned char   snrlint;
+      unsigned char   snrhint;
+      unsigned char   audio_chan_bw;
+      unsigned char   chl;
+      unsigned char   pcl;
+      unsigned char   dl;
+      unsigned char   snrl;
+      unsigned char   snrh;
+      unsigned char   video_snr;
+               int             afc_freq;
+               int             video_sc_spacing;
+      unsigned char   video_sys;
+      unsigned char   color;
+      unsigned char   lines;
+      unsigned char   audio_sys;
+      unsigned char   audio_demod_mode;
+      unsigned char   sound_level;
+      unsigned char   resrved;
+}  si2177_atv_status_cmd_reply_struct;
+/* ATV_STATUS command, CHLINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_CHLINT_LSB                  0
+#define  SI2177_ATV_STATUS_RESPONSE_CHLINT_MASK               0x01
+#define SI2177_ATV_STATUS_RESPONSE_CHLINT_CHANGED       1
+#define SI2177_ATV_STATUS_RESPONSE_CHLINT_NO_CHANGE   0
+/* ATV_STATUS command, PCLINT field definition (size 1, lsb 1, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_PCLINT_LSB                   1
+#define  SI2177_ATV_STATUS_RESPONSE_PCLINT_MASK                0x01
+#define SI2177_ATV_STATUS_RESPONSE_PCLINT_CHANGED        1
+#define SI2177_ATV_STATUS_RESPONSE_PCLINT_NO_CHANGE    0
+/* ATV_STATUS command, DLINT field definition (size 1, lsb 2, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_DLINT_LSB                      2
+#define  SI2177_ATV_STATUS_RESPONSE_DLINT_MASK                   0x01
+#define SI2177_ATV_STATUS_RESPONSE_DLINT_CHANGED           1
+#define SI2177_ATV_STATUS_RESPONSE_DLINT_NO_CHANGE       0
+/* ATV_STATUS command, SNRLINT field definition (size 1, lsb 3, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_SNRLINT_LSB                 3
+#define  SI2177_ATV_STATUS_RESPONSE_SNRLINT_MASK              0x01
+#define SI2177_ATV_STATUS_RESPONSE_SNRLINT_CHANGED      1
+#define SI2177_ATV_STATUS_RESPONSE_SNRLINT_NO_CHANGE  0
+/* ATV_STATUS command, SNRHINT field definition (size 1, lsb 4, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_SNRHINT_LSB                 4
+#define  SI2177_ATV_STATUS_RESPONSE_SNRHINT_MASK              0x01
+#define SI2177_ATV_STATUS_RESPONSE_SNRHINT_CHANGED      1
+#define SI2177_ATV_STATUS_RESPONSE_SNRHINT_NO_CHANGE  0
+/* ATV_STATUS command, AUDIO_CHAN_BW field definition (size 4, lsb 0, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_LSB                         0
+#define  SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_MASK                      0x0f
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_12X_OVERMOD      3
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_150_KHZ_OFFSET  8
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_15_KHZ_OFFSET    5
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_30_KHZ_OFFSET    6
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_4X_OVERMOD         1
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_75_KHZ_OFFSET     7
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_7P5_KHZ_OFFSET  4
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_8X_OVERMOD         2
+    #define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_CUSTOM          9
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_RSVD                       0
+   #define  SI2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_LSB         0
+   #define  SI2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_MASK        0xff
+   #define  SI2177_ATV_STATUS_RESPONSE_SOUND_LEVEL_SHIFT       24
+/* ATV_STATUS command, CHL field definition (size 1, lsb 0, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_CHL_LSB                                            0
+#define  SI2177_ATV_STATUS_RESPONSE_CHL_MASK                                         0x01
+#define SI2177_ATV_STATUS_RESPONSE_CHL_CHANNEL                                 1
+#define SI2177_ATV_STATUS_RESPONSE_CHL_NO_CHANNEL                          0
+/* ATV_STATUS command, PCL field definition (size 1, lsb 1, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_PCL_LSB                                            1
+#define  SI2177_ATV_STATUS_RESPONSE_PCL_MASK                                         0x01
+#define SI2177_ATV_STATUS_RESPONSE_PCL_LOCKED                                    1
+#define SI2177_ATV_STATUS_RESPONSE_PCL_NO_LOCK                                  0
+/* ATV_STATUS command, DL field definition (size 1, lsb 2, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_DL_LSB                                              2
+#define  SI2177_ATV_STATUS_RESPONSE_DL_MASK                                           0x01
+#define SI2177_ATV_STATUS_RESPONSE_DL_LOCKED                                       1
+#define SI2177_ATV_STATUS_RESPONSE_DL_NO_LOCK                                     0
+/* ATV_STATUS command, SNRL field definition (size 1, lsb 3, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_SNRL_LSB                                         3
+#define  SI2177_ATV_STATUS_RESPONSE_SNRL_MASK                                      0x01
+#define SI2177_ATV_STATUS_RESPONSE_SNRL_SNR_LOW                               1
+#define SI2177_ATV_STATUS_RESPONSE_SNRL_SNR_NOT_LOW                      0
+/* ATV_STATUS command, SNRH field definition (size 1, lsb 4, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_SNRH_LSB                                         4
+#define  SI2177_ATV_STATUS_RESPONSE_SNRH_MASK                                      0x01
+#define SI2177_ATV_STATUS_RESPONSE_SNRH_SNR_HIGH                             1
+#define SI2177_ATV_STATUS_RESPONSE_SNRH_SNR_NOT_HIGH                    0
+/* ATV_STATUS command, VIDEO_SNR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_VIDEO_SNR_LSB                               0
+#define  SI2177_ATV_STATUS_RESPONSE_VIDEO_SNR_MASK                            0xff
+/* ATV_STATUS command, AFC_FREQ field definition (size 16, lsb 0, signed)*/
+#define  SI2177_ATV_STATUS_RESPONSE_AFC_FREQ_LSB                                 0
+#define  SI2177_ATV_STATUS_RESPONSE_AFC_FREQ_MASK                              0xffff
+#define  SI2177_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT                             16
+/* ATV_STATUS command, VIDEO_SC_SPACING field definition (size 16, lsb 0, signed)*/
+#define  SI2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_LSB                0
+#define  SI2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_MASK             0xffff
+#define  SI2177_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT            16
+/* ATV_STATUS command, VIDEO_SYS field definition (size 3, lsb 0, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB                                0
+#define  SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK                             0x07
+#define SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_B                                     0
+#define SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_DK                                  5
+#define SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_GH                                  1
+#define SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_I                                      4
+#define SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_L                                     6
+#define SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_LP                                   7
+#define SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_M                                     2
+#define SI2177_ATV_STATUS_RESPONSE_VIDEO_SYS_N                                     3
+/* ATV_STATUS command, COLOR field definition (size 1, lsb 4, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_COLOR_LSB                                        4
+#define  SI2177_ATV_STATUS_RESPONSE_COLOR_MASK                                     0x01
+#define SI2177_ATV_STATUS_RESPONSE_COLOR_PAL_NTSC                             0
+#define SI2177_ATV_STATUS_RESPONSE_COLOR_SECAM                                   1
+/* ATV_STATUS command, TRANS field definition (size 1, lsb 6, unsigned)*/
+   #define  SI2177_ATV_STATUS_RESPONSE_LINES_LSB         7
+   #define  SI2177_ATV_STATUS_RESPONSE_LINES_MASK        0x01
+    #define SI2177_ATV_STATUS_RESPONSE_LINES_525  0
+    #define SI2177_ATV_STATUS_RESPONSE_LINES_625  1
+/* ATV_STATUS command, AUDIO_SYS field definition (size 4, lsb 0, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_LSB                                  0
+#define  SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MASK                               0x0f
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_A2                                     3
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK2                            4
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK3                            5
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK4                            9
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_BTSC                                6
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_EIAJ                                  7
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO                               1
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO_NICAM                  2
+    #define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO_NICAM_10DB  12
+    #define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO_NICAM_6DB   11
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_RSVD                                0
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_SCAN                                8
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_SYS_WIDE_SCAN                     10
+/* ATV_STATUS command, AUDIO_DEMOD_MODE field definition (size 2, lsb 4, unsigned)*/
+#define  SI2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_LSB                 4
+#define  SI2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_MASK              0x03
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_AM                   1
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_FM1                 2
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_FM2                 3
+#define SI2177_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_SIF                  0
+
+#endif /* SI2177_ATV_STATUS_CMD */
+
+/* SI2177_CONFIG_CLOCKS command definition */
+#define   SI2177_CONFIG_CLOCKS_CMD 0xc0
+
+#ifdef    SI2177_CONFIG_CLOCKS_CMD
+  #define SI2177_CONFIG_CLOCKS_CMD_CODE 0x0100c0
+
+    typedef struct { /* SI2177_CONFIG_CLOCKS_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   clock_mode;
+     unsigned char   en_xout;
+   } si2177_config_clocks_cmd_struct;
+
+
+    typedef struct { /* SI2177_CONFIG_CLOCKS_CMD_REPLY_struct */
+       si2177_common_reply_struct * STATUS;
+   }  SI2177_CONFIG_CLOCKS_CMD_REPLY_struct;
+
+   /* CONFIG_CLOCKS command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  SI2177_CONFIG_CLOCKS_CMD_SUBCODE_LSB         0
+   #define  SI2177_CONFIG_CLOCKS_CMD_SUBCODE_MASK        0xff
+   #define  SI2177_CONFIG_CLOCKS_CMD_SUBCODE_MIN         0
+   #define  SI2177_CONFIG_CLOCKS_CMD_SUBCODE_MAX         0
+    #define SI2177_CONFIG_CLOCKS_CMD_SUBCODE_CODE  0
+   /* CONFIG_CLOCKS command, CLOCK_MODE field definition (address 2,size 2, lsb 0, unsigned) */
+   #define  SI2177_CONFIG_CLOCKS_CMD_CLOCK_MODE_LSB         0
+   #define  SI2177_CONFIG_CLOCKS_CMD_CLOCK_MODE_MASK        0x03
+   #define  SI2177_CONFIG_CLOCKS_CMD_CLOCK_MODE_MIN         0
+   #define  SI2177_CONFIG_CLOCKS_CMD_CLOCK_MODE_MAX         2
+    #define SI2177_CONFIG_CLOCKS_CMD_CLOCK_MODE_EXTCLK  2
+    #define SI2177_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL    0
+   /* CONFIG_CLOCKS command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+   #define  SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_LSB         2
+   #define  SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_MASK        0x07
+   #define  SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_MIN         0
+   #define  SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_MAX         3
+    #define SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_DIS_XOUT  0
+    #define SI2177_CONFIG_CLOCKS_CMD_EN_XOUT_EN_XOUT   3
+#endif /* SI2177_CONFIG_CLOCKS_CMD */
+
+/* SI2177_CONFIG_PINS command definition */
+#define   SI2177_CONFIG_PINS_CMD 0x12
+
+#ifdef    SI2177_CONFIG_PINS_CMD
+
+typedef struct { /* SI2177_CONFIG_PINS_CMD_struct */
+     unsigned char   gpio1_mode;
+     unsigned char   gpio1_read;
+     unsigned char   gpio2_mode;
+     unsigned char   gpio2_read;
+     unsigned char   reserved1;
+     unsigned char   reserved2;
+     unsigned char   reserved3;
+   } si2177_config_pins_cmd_struct;
+
+
+    typedef struct { /* SI2177_CONFIG_PINS_CMD_REPLY_struct */
+      si2177_common_reply_struct * STATUS;
+      unsigned char   gpio1_mode;
+      unsigned char   gpio1_state;
+      unsigned char   gpio2_mode;
+      unsigned char   gpio2_state;
+      unsigned char   reserved1;
+      unsigned char   reserved2;
+      unsigned char   reserved3;
+   }  si2177_config_pins_cmd_reply_struct;
+
+   /* CONFIG_PINS command, GPIO1_MODE field definition (address 1,size 7, lsb 0, unsigned) */
+   #define  SI2177_CONFIG_PINS_CMD_GPIO1_MODE_LSB         0
+   #define  SI2177_CONFIG_PINS_CMD_GPIO1_MODE_MASK        0x7f
+   #define  SI2177_CONFIG_PINS_CMD_GPIO1_MODE_MIN         0
+   #define  SI2177_CONFIG_PINS_CMD_GPIO1_MODE_MAX         3
+    #define SI2177_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE    1
+    #define SI2177_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_0    2
+    #define SI2177_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1    3
+    #define SI2177_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE  0
+   /* CONFIG_PINS command, GPIO1_READ field definition (address 1,size 1, lsb 7, unsigned) */
+   #define  SI2177_CONFIG_PINS_CMD_GPIO1_READ_LSB         7
+   #define  SI2177_CONFIG_PINS_CMD_GPIO1_READ_MASK        0x01
+   #define  SI2177_CONFIG_PINS_CMD_GPIO1_READ_MIN         0
+   #define  SI2177_CONFIG_PINS_CMD_GPIO1_READ_MAX         1
+    #define SI2177_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ  0
+    #define SI2177_CONFIG_PINS_CMD_GPIO1_READ_READ         1
+   /* CONFIG_PINS command, GPIO2_MODE field definition (address 2,size 7, lsb 0, unsigned) */
+   #define  SI2177_CONFIG_PINS_CMD_GPIO2_MODE_LSB         0
+   #define  SI2177_CONFIG_PINS_CMD_GPIO2_MODE_MASK        0x7f
+   #define  SI2177_CONFIG_PINS_CMD_GPIO2_MODE_MIN         0
+   #define  SI2177_CONFIG_PINS_CMD_GPIO2_MODE_MAX         3
+    #define SI2177_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE    1
+    #define SI2177_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_0    2
+    #define SI2177_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_1    3
+    #define SI2177_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE  0
+   /* CONFIG_PINS command, GPIO2_READ field definition (address 2,size 1, lsb 7, unsigned) */
+   #define  SI2177_CONFIG_PINS_CMD_GPIO2_READ_LSB         7
+   #define  SI2177_CONFIG_PINS_CMD_GPIO2_READ_MASK        0x01
+   #define  SI2177_CONFIG_PINS_CMD_GPIO2_READ_MIN         0
+   #define  SI2177_CONFIG_PINS_CMD_GPIO2_READ_MAX         1
+    #define SI2177_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ  0
+    #define SI2177_CONFIG_PINS_CMD_GPIO2_READ_READ         1
+   /* CONFIG_PINS command, RESERVED1 field definition (address 3,size 8, lsb 0, unsigned) */
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED1_LSB         0
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED1_MASK        0xff
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED1_MIN         1
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED1_MAX         1
+    #define SI2177_CONFIG_PINS_CMD_RESERVED1_RESERVED  1
+   /* CONFIG_PINS command, RESERVED2 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED2_LSB         0
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED2_MASK        0xff
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED2_MIN         1
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED2_MAX         1
+    #define SI2177_CONFIG_PINS_CMD_RESERVED2_RESERVED  1
+   /* CONFIG_PINS command, RESERVED3 field definition (address 5,size 8, lsb 0, unsigned) */
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED3_LSB         0
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED3_MASK        0xff
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED3_MIN         1
+   #define  SI2177_CONFIG_PINS_CMD_RESERVED3_MAX         1
+    #define SI2177_CONFIG_PINS_CMD_RESERVED3_RESERVED  1
+   /* CONFIG_PINS command, GPIO1_MODE field definition (address 1, size 7, lsb 0, unsigned)*/
+   #define  SI2177_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB         0
+   #define  SI2177_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK        0x7f
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO1_MODE_DISABLE  1
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_0  2
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_1  3
+   /* CONFIG_PINS command, GPIO1_STATE field definition (address 1, size 1, lsb 7, unsigned)*/
+   #define  SI2177_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB         7
+   #define  SI2177_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK        0x01
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_0  0
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_1  1
+   /* CONFIG_PINS command, GPIO2_MODE field definition (address 2, size 7, lsb 0, unsigned)*/
+   #define  SI2177_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB         0
+   #define  SI2177_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK        0x7f
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO2_MODE_DISABLE  1
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_0  2
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_1  3
+   /* CONFIG_PINS command, GPIO2_STATE field definition (address 2, size 1, lsb 7, unsigned)*/
+   #define  SI2177_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB         7
+   #define  SI2177_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK        0x01
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_0  0
+    #define SI2177_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_1  1
+   /* CONFIG_PINS command, RESERVED1 field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  SI2177_CONFIG_PINS_RESPONSE_RESERVED1_LSB         0
+   #define  SI2177_CONFIG_PINS_RESPONSE_RESERVED1_MASK        0xff
+    #define SI2177_CONFIG_PINS_RESPONSE_RESERVED1_RESERVED1_MIN  1
+    #define SI2177_CONFIG_PINS_RESPONSE_RESERVED1_RESERVED1_MAX  1
+   /* CONFIG_PINS command, RESERVED2 field definition (address 4, size 8, lsb 0, unsigned)*/
+   #define  SI2177_CONFIG_PINS_RESPONSE_RESERVED2_LSB         0
+   #define  SI2177_CONFIG_PINS_RESPONSE_RESERVED2_MASK        0xff
+    #define SI2177_CONFIG_PINS_RESPONSE_RESERVED2_RESERVED2_MIN  1
+    #define SI2177_CONFIG_PINS_RESPONSE_RESERVED2_RESERVED2_MAX  1
+   /* CONFIG_PINS command, RESERVED3 field definition (address 5, size 8, lsb 0, unsigned)*/
+   #define  SI2177_CONFIG_PINS_RESPONSE_RESERVED3_LSB         0
+   #define  SI2177_CONFIG_PINS_RESPONSE_RESERVED3_MASK        0xff
+    #define SI2177_CONFIG_PINS_RESPONSE_RESERVED3_RESERVED3_MIN  1
+    #define SI2177_CONFIG_PINS_RESPONSE_RESERVED3_RESERVED3_MAX  1
+
+
+#endif /* SI2177_CONFIG_PINS_CMD */
+
+/* SI2177_DOWNLOAD_DATASET_CONTINUE command definition */
+//#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD 0xb9
+
+#ifdef    SI2177_DOWNLOAD_DATASET_CONTINUE_CMD
+
+typedef struct { /* SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_struct */
+     unsigned char   data0;
+     unsigned char   data1;
+     unsigned char   data2;
+     unsigned char   data3;
+     unsigned char   data4;
+     unsigned char   data5;
+     unsigned char   data6;
+} si2177_download_dataset_continue_cmd_struct;
+
+/* DOWNLOAD_DATASET_CONTINUE command, DATA0 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_LSB               0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MASK            0xff
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MIN               0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MAX              255
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MIN  0
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MAX 255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA1 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_LSB               0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MASK            0xff
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MIN               0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MAX              255
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MIN  0
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MAX 255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA2 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_LSB               0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MASK            0xff
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MIN               0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MAX              255
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MIN  0
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MAX 255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA3 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_LSB               0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MASK            0xff
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MIN                0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MAX              255
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MIN   0
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA4 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_LSB                0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MASK             0xff
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MIN                0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MAX               255
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MIN   0
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA5 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_LSB                0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MASK             0xff
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MIN                 0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MAX                255
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MIN    0
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MAX   255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA6 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_LSB                 0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MASK              0xff
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MIN                  0
+#define  SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MAX                 255
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MIN     0
+#define SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MAX    255
+
+typedef struct { /* SI2177_DOWNLOAD_DATASET_CONTINUE_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_download_dataset_continue_cmd_reply_struct;
+
+#endif /* SI2177_DOWNLOAD_DATASET_CONTINUE_CMD */
+
+/* SI2177_DOWNLOAD_DATASET_START command definition */
+//#define SI2177_DOWNLOAD_DATASET_START_CMD 0xb8
+
+#ifdef    SI2177_DOWNLOAD_DATASET_START_CMD
+
+typedef struct { /* SI2177_DOWNLOAD_DATASET_START_CMD_struct */
+     unsigned char   dataset_id;
+     unsigned char   dataset_checksum;
+     unsigned char   data0;
+     unsigned char   data1;
+     unsigned char   data2;
+     unsigned char   data3;
+     unsigned char   data4;
+} si2177_download_dataset_start_cmd_struct;
+/* DOWNLOAD_DATASET_START command, DATASET_ID field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_LSB                        0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MASK                     0xff
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MIN                         0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MAX                        29
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_B     6
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_DK   7
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_G     8
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_I       9
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_L      10
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_M     11
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_B       12
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_DK     13
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_G       14
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_I        15
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_L       16
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_M      17
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_B           21
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_DK        22
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_G           23
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_I            24
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_L           25
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_M          26
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_ALIF_6  27
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_ALIF_7  28
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_ALIF_8  29
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_B           0
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DK        1
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DTV_6  18
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DTV_7  19
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DTV_8  20
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_G           2
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_I            3
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_L           4
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_M          5
+/* DOWNLOAD_DATASET_START command, DATASET_CHECKSUM field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_LSB         0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MASK      0xff
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MIN         0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MAX        255
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MIN  0
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA0 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA0_LSB              0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA0_MASK           0xff
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA0_MIN               0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA0_MAX              255
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MIN   0
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA1 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA1_LSB               0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA1_MASK            0xff
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA1_MIN               0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA1_MAX              255
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MIN   0
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA2 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA2_LSB                0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA2_MASK             0xff
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA2_MIN                 0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA2_MAX                255
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MIN    0
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA3 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA3_LSB                 0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA3_MASK              0xff
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA3_MIN                 0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA3_MAX                255
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MIN    0
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MAX   255
+/* DOWNLOAD_DATASET_START command, DATA4 field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA4_LSB                 0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA4_MASK              0xff
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA4_MIN                 0
+#define  SI2177_DOWNLOAD_DATASET_START_CMD_DATA4_MAX                255
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MIN    0
+#define SI2177_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MAX   255
+
+typedef struct { /* SI2177_DOWNLOAD_DATASET_START_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_download_dataset_start_cmd_reply_struct;
+
+#endif /* SI2177_DOWNLOAD_DATASET_START_CMD */
+
+/* SI2177_DTV_RESTART command definition */
+#define SI2177_DTV_RESTART_CMD 0x61
+
+#ifdef    SI2177_DTV_RESTART_CMD
+
+typedef struct { /* SI2177_DTV_RESTART_CMD_struct */
+       unsigned char   nothing;
+} si2177_dtv_restart_cmd_struct;
+
+
+typedef struct { /* SI2177_DTV_RESTART_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_dtv_restart_cmd_reply_struct;
+
+#endif /* SI2177_DTV_RESTART_CMD */
+
+/* SI2177_DTV_STATUS command definition */
+#define SI2177_DTV_STATUS_CMD 0x62
+
+#ifdef    SI2177_DTV_STATUS_CMD
+
+typedef struct { /* SI2177_DTV_STATUS_CMD_struct */
+     unsigned char   intack;
+} si2177_dtv_status_cmd_struct;
+
+/* DTV_STATUS command, INTACK field definition (size 1, lsb 0, unsigned) */
+#define  SI2177_DTV_STATUS_CMD_INTACK_LSB          0
+#define  SI2177_DTV_STATUS_CMD_INTACK_MASK       0x01
+#define  SI2177_DTV_STATUS_CMD_INTACK_MIN          0
+#define  SI2177_DTV_STATUS_CMD_INTACK_MAX         1
+#define SI2177_DTV_STATUS_CMD_INTACK_CLEAR      1
+#define SI2177_DTV_STATUS_CMD_INTACK_OK             0
+
+typedef struct { /* SI2177_DTV_STATUS_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+      unsigned char   chlint;
+      unsigned char   chl;
+      unsigned char   bw;
+      unsigned char   modulation;
+}  si2177_dtv_status_cmd_reply_struct;
+
+/* DTV_STATUS command, CHLINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2177_DTV_STATUS_RESPONSE_CHLINT_LSB                 0
+#define  SI2177_DTV_STATUS_RESPONSE_CHLINT_MASK              0x01
+#define SI2177_DTV_STATUS_RESPONSE_CHLINT_CHANGED       1
+#define SI2177_DTV_STATUS_RESPONSE_CHLINT_NO_CHANGE   0
+/* DTV_STATUS command, CHL field definition (size 1, lsb 0, unsigned)*/
+#define  SI2177_DTV_STATUS_RESPONSE_CHL_LSB                       0
+#define  SI2177_DTV_STATUS_RESPONSE_CHL_MASK                    0x01
+#define SI2177_DTV_STATUS_RESPONSE_CHL_CHANNEL              1
+#define SI2177_DTV_STATUS_RESPONSE_CHL_NO_CHANNEL       0
+/* DTV_STATUS command, BW field definition (size 4, lsb 0, unsigned)*/
+#define  SI2177_DTV_STATUS_RESPONSE_BW_LSB                         0
+#define  SI2177_DTV_STATUS_RESPONSE_BW_MASK                      0x0f
+#define SI2177_DTV_STATUS_RESPONSE_BW_BW_6MHZ                6
+#define SI2177_DTV_STATUS_RESPONSE_BW_BW_7MHZ                7
+#define SI2177_DTV_STATUS_RESPONSE_BW_BW_8MHZ                8
+/* DTV_STATUS command, MODULATION field definition (size 4, lsb 4, unsigned)*/
+#define  SI2177_DTV_STATUS_RESPONSE_MODULATION_LSB       4
+#define  SI2177_DTV_STATUS_RESPONSE_MODULATION_MASK    0x0f
+#define SI2177_DTV_STATUS_RESPONSE_MODULATION_ATSC      0
+#define SI2177_DTV_STATUS_RESPONSE_MODULATION_DTMB      6
+#define SI2177_DTV_STATUS_RESPONSE_MODULATION_DVBC      3
+#define SI2177_DTV_STATUS_RESPONSE_MODULATION_DVBT       2
+#define SI2177_DTV_STATUS_RESPONSE_MODULATION_ISDBC     5
+#define SI2177_DTV_STATUS_RESPONSE_MODULATION_ISDBT     4
+#define SI2177_DTV_STATUS_RESPONSE_MODULATION_QAM_US  1
+
+#endif /* SI2177_DTV_STATUS_CMD */
+
+/* SI2177_EXIT_BOOTLOADER command definition */
+#define SI2177_EXIT_BOOTLOADER_CMD                                             0x01
+
+#ifdef    SI2177_EXIT_BOOTLOADER_CMD
+
+typedef struct { /* SI2177_EXIT_BOOTLOADER_CMD_struct */
+     unsigned char   func;
+     unsigned char   ctsien;
+} si2177_exit_bootloader_cmd_struct;
+
+/* EXIT_BOOTLOADER command, FUNC field definition (size 4, lsb 0, unsigned) */
+#define  SI2177_EXIT_BOOTLOADER_CMD_FUNC_LSB                        0
+   #define  SI2177_EXIT_BOOTLOADER_CMD_FUNC_MASK        0x07
+#define  SI2177_EXIT_BOOTLOADER_CMD_FUNC_MIN                        0
+#define  SI2177_EXIT_BOOTLOADER_CMD_FUNC_MAX                       1
+#define SI2177_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER       0
+#define SI2177_EXIT_BOOTLOADER_CMD_FUNC_TUNER                   1
+/* EXIT_BOOTLOADER command, CTSIEN field definition (size 1, lsb 7, unsigned) */
+#define  SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_LSB                     7
+#define  SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_MASK                 0x01
+#define  SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_MIN                     0
+#define  SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_MAX                    1
+#define SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_OFF                     0
+#define SI2177_EXIT_BOOTLOADER_CMD_CTSIEN_ON                       1
+
+typedef struct { /* SI2177_EXIT_BOOTLOADER_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_exit_bootloader_cmd_reply_struct;
+
+#endif /* SI2177_EXIT_BOOTLOADER_CMD */
+
+/* SI2177_FINE_TUNE command definition */
+#define SI2177_FINE_TUNE_CMD                                                            0x45
+
+#ifdef    SI2177_FINE_TUNE_CMD
+
+typedef struct { /* SI2177_FINE_TUNE_CMD_struct */
+     unsigned char   persistence;
+     unsigned char   apply_to_lif;
+                       int    offset_500hz;
+} si2177_fine_tune_cmd_struct;
+
+/* FINE_TUNE command, RESERVED field definition (size 8, lsb 0, unsigned) */
+   #define  SI2177_FINE_TUNE_CMD_PERSISTENCE_LSB         0
+   #define  SI2177_FINE_TUNE_CMD_PERSISTENCE_MASK        0x01
+   #define  SI2177_FINE_TUNE_CMD_PERSISTENCE_MIN         0
+   #define  SI2177_FINE_TUNE_CMD_PERSISTENCE_MAX         1
+    #define SI2177_FINE_TUNE_CMD_PERSISTENCE_NON_PERSISTENT  0
+    #define SI2177_FINE_TUNE_CMD_PERSISTENCE_PERSISTENT      1
+   #define  SI2177_FINE_TUNE_CMD_APPLY_TO_LIF_LSB         1
+   #define  SI2177_FINE_TUNE_CMD_APPLY_TO_LIF_MASK        0x01
+   #define  SI2177_FINE_TUNE_CMD_APPLY_TO_LIF_MIN         0
+   #define  SI2177_FINE_TUNE_CMD_APPLY_TO_LIF_MAX         1
+    #define SI2177_FINE_TUNE_CMD_APPLY_TO_LIF_APPLY_TO_LIF         1
+    #define SI2177_FINE_TUNE_CMD_APPLY_TO_LIF_DO_NOT_APPLY_TO_LIF  0
+/* FINE_TUNE command, OFFSET_500HZ field definition (size 16, lsb 0, signed) */
+#define  SI2177_FINE_TUNE_CMD_OFFSET_500HZ_LSB                      0
+#define  SI2177_FINE_TUNE_CMD_OFFSET_500HZ_MASK                   0xffff
+#define  SI2177_FINE_TUNE_CMD_OFFSET_500HZ_SHIFT                  16
+#define  SI2177_FINE_TUNE_CMD_OFFSET_500HZ_MIN                      -4000
+#define  SI2177_FINE_TUNE_CMD_OFFSET_500HZ_MAX                     4000
+#define SI2177_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MIN  -4000
+#define SI2177_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MAX  4000
+
+typedef struct { /* SI2177_FINE_TUNE_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_fine_tune_cmd_reply_struct;
+
+#endif /* SI2177_FINE_TUNE_CMD */
+
+/* SI2177_GET_PROPERTY command definition */
+#define SI2177_GET_PROPERTY_CMD                                                    0x15
+
+#ifdef    SI2177_GET_PROPERTY_CMD
+
+typedef struct { /* SI2177_GET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned   int    prop;
+} si2177_get_property_cmd_struct;
+
+/* GET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_GET_PROPERTY_CMD_RESERVED_LSB                     0
+#define  SI2177_GET_PROPERTY_CMD_RESERVED_MASK                  0xff
+#define  SI2177_GET_PROPERTY_CMD_RESERVED_MIN                      0
+#define  SI2177_GET_PROPERTY_CMD_RESERVED_MAX                     0
+#define SI2177_GET_PROPERTY_CMD_RESERVED_RESERVED_MIN  0
+#define SI2177_GET_PROPERTY_CMD_RESERVED_RESERVED_MAX 0
+/* GET_PROPERTY command, PROP field definition (size 16, lsb 0, unsigned) */
+#define  SI2177_GET_PROPERTY_CMD_PROP_LSB                                0
+#define  SI2177_GET_PROPERTY_CMD_PROP_MASK                             0xffff
+#define  SI2177_GET_PROPERTY_CMD_PROP_MIN                                0
+#define  SI2177_GET_PROPERTY_CMD_PROP_MAX                               65535
+#define SI2177_GET_PROPERTY_CMD_PROP_PROP_MIN                      0
+#define SI2177_GET_PROPERTY_CMD_PROP_PROP_MAX                     65535
+
+typedef struct { /* SI2177_GET_PROPERTY_CMD_REPLY_struct */
+      si2177_common_reply_struct * status;
+      unsigned char   reserved;
+      unsigned int    data;
+}  si2177_get_property_cmd_reply_struct;
+
+/* GET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_GET_PROPERTY_RESPONSE_RESERVED_LSB         0
+#define  SI2177_GET_PROPERTY_RESPONSE_RESERVED_MASK      0xff
+/* GET_PROPERTY command, DATA field definition (size 16, lsb 0, unsigned)*/
+#define  SI2177_GET_PROPERTY_RESPONSE_DATA_LSB                   0
+#define  SI2177_GET_PROPERTY_RESPONSE_DATA_MASK                0xffff
+
+#endif /* SI2177_GET_PROPERTY_CMD */
+
+/* SI2177_GET_REV command definition */
+#define SI2177_GET_REV_CMD                                                                  0x11
+
+#ifdef    SI2177_GET_REV_CMD
+
+typedef struct { /* SI2177_GET_REV_CMD_struct */
+    unsigned char   nothing;
+} si2177_get_rev_cmd_struct;
+
+
+typedef struct { /* SI2177_GET_REV_CMD_REPLY_struct */
+      si2177_common_reply_struct * status;
+      unsigned  char                          pn;
+      unsigned  char                          fwmajor;
+      unsigned  char                          fwminor;
+      unsigned  int                             patch;
+      unsigned  char                          cmpmajor;
+      unsigned  char                          cmpminor;
+      unsigned  char                          cmpbuild;
+      unsigned  char                          chiprev;
+}  si2177_get_rev_cmd_reply_struct;
+
+/* GET_REV command, PN field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_GET_REV_RESPONSE_PN_LSB                                   0
+#define  SI2177_GET_REV_RESPONSE_PN_MASK                                0xff
+/* GET_REV command, FWMAJOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_GET_REV_RESPONSE_FWMAJOR_LSB                       0
+#define  SI2177_GET_REV_RESPONSE_FWMAJOR_MASK                    0xff
+/* GET_REV command, FWMINOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_GET_REV_RESPONSE_FWMINOR_LSB                       0
+#define  SI2177_GET_REV_RESPONSE_FWMINOR_MASK                    0xff
+/* GET_REV command, PATCH field definition (size 16, lsb 0, unsigned)*/
+#define  SI2177_GET_REV_RESPONSE_PATCH_LSB                            0
+#define  SI2177_GET_REV_RESPONSE_PATCH_MASK                         0xffff
+/* GET_REV command, CMPMAJOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_GET_REV_RESPONSE_CMPMAJOR_LSB                     0
+#define  SI2177_GET_REV_RESPONSE_CMPMAJOR_MASK                  0xff
+/* GET_REV command, CMPMINOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_GET_REV_RESPONSE_CMPMINOR_LSB                     0
+#define  SI2177_GET_REV_RESPONSE_CMPMINOR_MASK                  0xff
+/* GET_REV command, CMPBUILD field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_GET_REV_RESPONSE_CMPBUILD_LSB                      0
+#define  SI2177_GET_REV_RESPONSE_CMPBUILD_MASK                   0xff
+#define SI2177_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MIN   0
+#define SI2177_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MAX  255
+/* GET_REV command, CHIPREV field definition (size 4, lsb 0, unsigned)*/
+#define  SI2177_GET_REV_RESPONSE_CHIPREV_LSB                        0
+#define  SI2177_GET_REV_RESPONSE_CHIPREV_MASK                     0x0f
+#define SI2177_GET_REV_RESPONSE_CHIPREV_A                              1
+#define SI2177_GET_REV_RESPONSE_CHIPREV_B                              2
+
+#endif /* SI2177_GET_REV_CMD */
+
+/* SI2177_PART_INFO command definition */
+#define SI2177_PART_INFO_CMD                                                            0x02
+
+#ifdef    SI2177_PART_INFO_CMD
+
+typedef struct { /* SI2177_PART_INFO_CMD_struct */
+     unsigned char   nothing;
+} si2177_part_info_cmd_struct;
+
+
+typedef struct { /* SI2177_PART_INFO_CMD_REPLY_struct */
+      si2177_common_reply_struct * status;
+      unsigned char   chiprev;
+      unsigned char   romid;
+      unsigned char   part;
+      unsigned char   pmajor;
+      unsigned char   pminor;
+      unsigned char   pbuild;
+      unsigned int    reserved;
+      unsigned long   serial;
+}  si2177_part_info_cmd_reply_struct;
+
+/* PART_INFO command, CHIPREV field definition (size 4, lsb 0, unsigned)*/
+#define  SI2177_PART_INFO_RESPONSE_CHIPREV_LSB           0
+#define  SI2177_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+#define SI2177_PART_INFO_RESPONSE_CHIPREV_A                 1
+#define SI2177_PART_INFO_RESPONSE_CHIPREV_B                 2
+/* PART_INFO command, ROMID field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_PART_INFO_RESPONSE_ROMID_LSB                0
+#define  SI2177_PART_INFO_RESPONSE_ROMID_MASK             0xff
+/* PART_INFO command, PART field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_PART_INFO_RESPONSE_PART_LSB                   0
+#define  SI2177_PART_INFO_RESPONSE_PART_MASK                0xff
+/* PART_INFO command, PMAJOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_PART_INFO_RESPONSE_PMAJOR_LSB               0
+#define  SI2177_PART_INFO_RESPONSE_PMAJOR_MASK            0xff
+/* PART_INFO command, PMINOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_PART_INFO_RESPONSE_PMINOR_LSB               0
+#define  SI2177_PART_INFO_RESPONSE_PMINOR_MASK            0xff
+/* PART_INFO command, PBUILD field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_PART_INFO_RESPONSE_PBUILD_LSB                0
+#define  SI2177_PART_INFO_RESPONSE_PBUILD_MASK             0xff
+/* PART_INFO command, RESERVED field definition (size 16, lsb 0, unsigned)*/
+#define  SI2177_PART_INFO_RESPONSE_RESERVED_LSB         0
+#define  SI2177_PART_INFO_RESPONSE_RESERVED_MASK      0xffff
+/* PART_INFO command, SERIAL field definition (size 32, lsb 0, unsigned)*/
+#define  SI2177_PART_INFO_RESPONSE_SERIAL_LSB                0
+#define  SI2177_PART_INFO_RESPONSE_SERIAL_MASK             0xffffffff
+
+#endif /* SI2177_PART_INFO_CMD */
+
+/* SI2177_POWER_DOWN command definition */
+#define SI2177_POWER_DOWN_CMD                                               0x13
+
+#ifdef    SI2177_POWER_DOWN_CMD
+
+typedef struct { /* SI2177_POWER_DOWN_CMD_struct */
+       unsigned char   nothing;
+} si2177_power_down_cmd_struct;
+
+
+typedef struct { /* SI2177_POWER_DOWN_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_power_down_cmd_reply_struct;
+
+#endif /* SI2177_POWER_DOWN_CMD */
+
+/* SI2177_POWER_DOWN_HW command definition */
+#define   SI2177_POWER_DOWN_HW_CMD 0xc0
+
+#ifdef    SI2177_POWER_DOWN_HW_CMD
+  #define SI2177_POWER_DOWN_HW_CMD_CODE 0x0200c0
+
+    typedef struct { /* SI2177_POWER_DOWN_HW_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   pd_xo_osc;
+     unsigned char   reserved1;
+     unsigned char   en_xout;
+     unsigned char   reserved2;
+     unsigned char   pd_ldo;
+     unsigned char   reserved3;
+     unsigned char   reserved4;
+     unsigned char   reserved5;
+     unsigned char   reserved6;
+     unsigned char   reserved7;
+     unsigned char   reserved8;
+   } SI2177_POWER_DOWN_HW_CMD_struct;
+
+
+    typedef struct { /* SI2177_POWER_DOWN_HW_CMD_REPLY_struct */
+       si2177_common_reply_struct * STATUS;
+   }  SI2177_POWER_DOWN_HW_CMD_REPLY_struct;
+
+   /* POWER_DOWN_HW command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_SUBCODE_LSB         0
+   #define  SI2177_POWER_DOWN_HW_CMD_SUBCODE_MASK        0xff
+   #define  SI2177_POWER_DOWN_HW_CMD_SUBCODE_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_SUBCODE_MAX         0
+    #define SI2177_POWER_DOWN_HW_CMD_SUBCODE_CODE  0
+   /* POWER_DOWN_HW command, PD_XO_OSC field definition (address 2,size 1, lsb 0, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_PD_XO_OSC_LSB         0
+   #define  SI2177_POWER_DOWN_HW_CMD_PD_XO_OSC_MASK        0x01
+   #define  SI2177_POWER_DOWN_HW_CMD_PD_XO_OSC_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_PD_XO_OSC_MAX         1
+    #define SI2177_POWER_DOWN_HW_CMD_PD_XO_OSC_XO_OSC_POWER_DOWN  1
+    #define SI2177_POWER_DOWN_HW_CMD_PD_XO_OSC_XO_OSC_POWER_UP    0
+   /* POWER_DOWN_HW command, RESERVED1 field definition (address 2,size 1, lsb 1, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED1_LSB         1
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED1_MASK        0x01
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED1_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED1_MAX         0
+    #define SI2177_POWER_DOWN_HW_CMD_RESERVED1_RESERVED  0
+   /* POWER_DOWN_HW command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_EN_XOUT_LSB         2
+   #define  SI2177_POWER_DOWN_HW_CMD_EN_XOUT_MASK        0x07
+   #define  SI2177_POWER_DOWN_HW_CMD_EN_XOUT_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_EN_XOUT_MAX         3
+    #define SI2177_POWER_DOWN_HW_CMD_EN_XOUT_DIS_XOUT  0
+    #define SI2177_POWER_DOWN_HW_CMD_EN_XOUT_EN_XOUT   3
+   /* POWER_DOWN_HW command, RESERVED2 field definition (address 2,size 3, lsb 5, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED2_LSB         5
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED2_MASK        0x07
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED2_MIN         1
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED2_MAX         1
+    #define SI2177_POWER_DOWN_HW_CMD_RESERVED2_RESERVED  1
+   /* POWER_DOWN_HW command, PD_LDO field definition (address 3,size 1, lsb 0, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_PD_LDO_LSB         0
+   #define  SI2177_POWER_DOWN_HW_CMD_PD_LDO_MASK        0x01
+   #define  SI2177_POWER_DOWN_HW_CMD_PD_LDO_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_PD_LDO_MAX         1
+    #define SI2177_POWER_DOWN_HW_CMD_PD_LDO_LDO_POWER_DOWN  1
+    #define SI2177_POWER_DOWN_HW_CMD_PD_LDO_LDO_POWER_UP    0
+   /* POWER_DOWN_HW command, RESERVED3 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED3_LSB         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED3_MASK        0xff
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED3_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED3_MAX         0
+    #define SI2177_POWER_DOWN_HW_CMD_RESERVED3_RESERVED  0
+   /* POWER_DOWN_HW command, RESERVED4 field definition (address 5,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED4_LSB         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED4_MASK        0xff
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED4_MIN         1
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED4_MAX         1
+    #define SI2177_POWER_DOWN_HW_CMD_RESERVED4_RESERVED  1
+   /* POWER_DOWN_HW command, RESERVED5 field definition (address 6,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED5_LSB         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED5_MASK        0xff
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED5_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED5_MAX         0
+    #define SI2177_POWER_DOWN_HW_CMD_RESERVED5_RESERVED  0
+   /* POWER_DOWN_HW command, RESERVED6 field definition (address 7,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED6_LSB         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED6_MASK        0xff
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED6_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED6_MAX         0
+    #define SI2177_POWER_DOWN_HW_CMD_RESERVED6_RESERVED  0
+   /* POWER_DOWN_HW command, RESERVED7 field definition (address 8,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED7_LSB         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED7_MASK        0xff
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED7_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED7_MAX         0
+    #define SI2177_POWER_DOWN_HW_CMD_RESERVED7_RESERVED  0
+   /* POWER_DOWN_HW command, RESERVED8 field definition (address 9,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED8_LSB         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED8_MASK        0xff
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED8_MIN         0
+   #define  SI2177_POWER_DOWN_HW_CMD_RESERVED8_MAX         0
+    #define SI2177_POWER_DOWN_HW_CMD_RESERVED8_RESERVED  0
+#endif /* SI2177_POWER_DOWN_HW_CMD */
+
+/* SI2177_POWER_UP command definition */
+#define SI2177_POWER_UP_CMD                                                    0xc0
+
+#ifdef    SI2177_POWER_UP_CMD
+
+typedef struct { /* SI2177_POWER_UP_CMD_struct */
+	unsigned char	subcode;
+	unsigned char	clock_mode;
+	unsigned char	en_xout;
+	unsigned char	pd_ldo;
+	unsigned char	reserved2;
+	unsigned char	reserved3;
+	unsigned char	reserved4;
+	unsigned char	reserved5;
+	unsigned char	reserved6;
+	unsigned char	reserved7;
+	unsigned char	reset;
+	unsigned char	clock_freq;
+	unsigned char	reserved8;
+	unsigned char	func;
+	unsigned char	reserved9;
+	unsigned char	ctsien;
+	unsigned char	wake_up;
+
+} si2177_power_up_cmd_struct;
+
+ /* POWER_UP command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_SUBCODE_LSB         0
+   #define  SI2177_POWER_UP_CMD_SUBCODE_MASK        0xff
+   #define  SI2177_POWER_UP_CMD_SUBCODE_MIN         0
+   #define  SI2177_POWER_UP_CMD_SUBCODE_MAX         0
+    #define SI2177_POWER_UP_CMD_SUBCODE_CODE  0
+   /* POWER_UP command, CLOCK_MODE field definition (address 2,size 2, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_CLOCK_MODE_LSB         0
+   #define  SI2177_POWER_UP_CMD_CLOCK_MODE_MASK        0x03
+   #define  SI2177_POWER_UP_CMD_CLOCK_MODE_MIN         0
+   #define  SI2177_POWER_UP_CMD_CLOCK_MODE_MAX         2
+    #define SI2177_POWER_UP_CMD_CLOCK_MODE_EXTCLK  2
+    #define SI2177_POWER_UP_CMD_CLOCK_MODE_XTAL    0
+   /* POWER_UP command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+   #define  SI2177_POWER_UP_CMD_EN_XOUT_LSB         2
+   #define  SI2177_POWER_UP_CMD_EN_XOUT_MASK        0x07
+   #define  SI2177_POWER_UP_CMD_EN_XOUT_MIN         0
+   #define  SI2177_POWER_UP_CMD_EN_XOUT_MAX         3
+    #define SI2177_POWER_UP_CMD_EN_XOUT_DIS_XOUT  0
+    #define SI2177_POWER_UP_CMD_EN_XOUT_EN_XOUT   3
+   /* POWER_UP command, PD_LDO field definition (address 3,size 1, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_PD_LDO_LSB         0
+   #define  SI2177_POWER_UP_CMD_PD_LDO_MASK        0x01
+   #define  SI2177_POWER_UP_CMD_PD_LDO_MIN         0
+   #define  SI2177_POWER_UP_CMD_PD_LDO_MAX         1
+    #define SI2177_POWER_UP_CMD_PD_LDO_LDO_POWER_DOWN  1
+    #define SI2177_POWER_UP_CMD_PD_LDO_LDO_POWER_UP    0
+   /* POWER_UP command, RESERVED2 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_RESERVED2_LSB         0
+   #define  SI2177_POWER_UP_CMD_RESERVED2_MASK        0xff
+   #define  SI2177_POWER_UP_CMD_RESERVED2_MIN         0
+   #define  SI2177_POWER_UP_CMD_RESERVED2_MAX         0
+    #define SI2177_POWER_UP_CMD_RESERVED2_RESERVED  0
+   /* POWER_UP command, RESERVED3 field definition (address 5,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_RESERVED3_LSB         0
+   #define  SI2177_POWER_UP_CMD_RESERVED3_MASK        0xff
+   #define  SI2177_POWER_UP_CMD_RESERVED3_MIN         1
+   #define  SI2177_POWER_UP_CMD_RESERVED3_MAX         1
+    #define SI2177_POWER_UP_CMD_RESERVED3_RESERVED  1
+   /* POWER_UP command, RESERVED4 field definition (address 6,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_RESERVED4_LSB         0
+   #define  SI2177_POWER_UP_CMD_RESERVED4_MASK        0xff
+   #define  SI2177_POWER_UP_CMD_RESERVED4_MIN         1
+   #define  SI2177_POWER_UP_CMD_RESERVED4_MAX         1
+    #define SI2177_POWER_UP_CMD_RESERVED4_RESERVED  1
+   /* POWER_UP command, RESERVED5 field definition (address 7,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_RESERVED5_LSB         0
+   #define  SI2177_POWER_UP_CMD_RESERVED5_MASK        0xff
+   #define  SI2177_POWER_UP_CMD_RESERVED5_MIN         1
+   #define  SI2177_POWER_UP_CMD_RESERVED5_MAX         1
+    #define SI2177_POWER_UP_CMD_RESERVED5_RESERVED  1
+   /* POWER_UP command, RESERVED6 field definition (address 8,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_RESERVED6_LSB         0
+   #define  SI2177_POWER_UP_CMD_RESERVED6_MASK        0xff
+   #define  SI2177_POWER_UP_CMD_RESERVED6_MIN         1
+   #define  SI2177_POWER_UP_CMD_RESERVED6_MAX         1
+    #define SI2177_POWER_UP_CMD_RESERVED6_RESERVED  1
+   /* POWER_UP command, RESERVED7 field definition (address 9,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_RESERVED7_LSB         0
+   #define  SI2177_POWER_UP_CMD_RESERVED7_MASK        0xff
+   #define  SI2177_POWER_UP_CMD_RESERVED7_MIN         1
+   #define  SI2177_POWER_UP_CMD_RESERVED7_MAX         1
+    #define SI2177_POWER_UP_CMD_RESERVED7_RESERVED  1
+   /* POWER_UP command, RESET field definition (address 10,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_RESET_LSB         0
+   #define  SI2177_POWER_UP_CMD_RESET_MASK        0xff
+   #define  SI2177_POWER_UP_CMD_RESET_MIN         1
+   #define  SI2177_POWER_UP_CMD_RESET_MAX         1
+    #define SI2177_POWER_UP_CMD_RESET_RESET  1
+   /* POWER_UP command, CLOCK_FREQ field definition (address 11,size 2, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_CLOCK_FREQ_LSB         0
+   #define  SI2177_POWER_UP_CMD_CLOCK_FREQ_MASK        0x03
+   #define  SI2177_POWER_UP_CMD_CLOCK_FREQ_MIN         0
+   #define  SI2177_POWER_UP_CMD_CLOCK_FREQ_MAX         3
+    #define SI2177_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+   /* POWER_UP command, RESERVED8 field definition (address 12,size 8, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_RESERVED8_LSB         0
+   #define  SI2177_POWER_UP_CMD_RESERVED8_MASK        0xff
+   #define  SI2177_POWER_UP_CMD_RESERVED8_MIN         0
+   #define  SI2177_POWER_UP_CMD_RESERVED8_MAX         0
+    #define SI2177_POWER_UP_CMD_RESERVED8_RESERVED  0
+   /* POWER_UP command, FUNC field definition (address 13,size 3, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_FUNC_LSB         0
+   #define  SI2177_POWER_UP_CMD_FUNC_MASK        0x07
+   #define  SI2177_POWER_UP_CMD_FUNC_MIN         0
+   #define  SI2177_POWER_UP_CMD_FUNC_MAX         1
+    #define SI2177_POWER_UP_CMD_FUNC_BOOTLOADER  0
+    #define SI2177_POWER_UP_CMD_FUNC_NORMAL      1
+   /* POWER_UP command, RESERVED9 field definition (address 13,size 4, lsb 3, unsigned) */
+   #define  SI2177_POWER_UP_CMD_RESERVED9_LSB         3
+   #define  SI2177_POWER_UP_CMD_RESERVED9_MASK        0x0f
+   #define  SI2177_POWER_UP_CMD_RESERVED9_MIN         0
+   #define  SI2177_POWER_UP_CMD_RESERVED9_MAX         0
+    #define SI2177_POWER_UP_CMD_RESERVED9_RESERVED  0
+   /* POWER_UP command, CTSIEN field definition (address 13,size 1, lsb 7, unsigned) */
+   #define  SI2177_POWER_UP_CMD_CTSIEN_LSB         7
+   #define  SI2177_POWER_UP_CMD_CTSIEN_MASK        0x01
+   #define  SI2177_POWER_UP_CMD_CTSIEN_MIN         0
+   #define  SI2177_POWER_UP_CMD_CTSIEN_MAX         1
+    #define SI2177_POWER_UP_CMD_CTSIEN_DISABLE  0
+    #define SI2177_POWER_UP_CMD_CTSIEN_ENABLE   1
+   /* POWER_UP command, WAKE_UP field definition (address 14,size 1, lsb 0, unsigned) */
+   #define  SI2177_POWER_UP_CMD_WAKE_UP_LSB         0
+   #define  SI2177_POWER_UP_CMD_WAKE_UP_MASK        0x01
+   #define  SI2177_POWER_UP_CMD_WAKE_UP_MIN         1
+   #define  SI2177_POWER_UP_CMD_WAKE_UP_MAX         1
+    #define SI2177_POWER_UP_CMD_WAKE_UP_WAKE_UP  1
+
+typedef struct { /* SI2177_POWER_UP_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_power_up_cmd_reply_struct;
+
+#endif /* SI2177_POWER_UP_CMD */
+
+/* SI2177_SET_PROPERTY command definition */
+#define SI2177_SET_PROPERTY_CMD                                         0x14
+
+#ifdef    SI2177_SET_PROPERTY_CMD
+
+typedef struct { /* SI2177_SET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned int      prop;
+     unsigned int      data;
+} si2177_set_property_cmd_struct;
+
+/* SET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned) */
+#define  SI2177_SET_PROPERTY_CMD_RESERVED_LSB         0
+#define  SI2177_SET_PROPERTY_CMD_RESERVED_MASK      0xff
+#define  SI2177_SET_PROPERTY_CMD_RESERVED_MIN         0
+#define  SI2177_SET_PROPERTY_CMD_RESERVED_MAX        255.0
+/* SET_PROPERTY command, PROP field definition (size 16, lsb 0, unsigned) */
+#define  SI2177_SET_PROPERTY_CMD_PROP_LSB                   0
+#define  SI2177_SET_PROPERTY_CMD_PROP_MASK                0xffff
+#define  SI2177_SET_PROPERTY_CMD_PROP_MIN                   0
+#define  SI2177_SET_PROPERTY_CMD_PROP_MAX                  65535
+#define SI2177_SET_PROPERTY_CMD_PROP_PROP_MIN        0
+#define SI2177_SET_PROPERTY_CMD_PROP_PROP_MAX       65535
+/* SET_PROPERTY command, DATA field definition (size 16, lsb 0, unsigned) */
+#define  SI2177_SET_PROPERTY_CMD_DATA_LSB                   0
+#define  SI2177_SET_PROPERTY_CMD_DATA_MASK                0xffff
+#define  SI2177_SET_PROPERTY_CMD_DATA_MIN                   0
+#define  SI2177_SET_PROPERTY_CMD_DATA_MAX                  65535
+#define SI2177_SET_PROPERTY_CMD_DATA_DATA_MIN         0
+#define SI2177_SET_PROPERTY_CMD_DATA_DATA_MAX        65535
+
+typedef struct { /* SI2177_SET_PROPERTY_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+      unsigned  char                           reserved;
+      unsigned  int                              data;
+}  si2177_set_property_cmd_reply_struct;
+
+/* SET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned)*/
+#define  SI2177_SET_PROPERTY_RESPONSE_RESERVED_LSB                      0
+#define  SI2177_SET_PROPERTY_RESPONSE_RESERVED_MASK                   0xff
+#define SI2177_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+#define SI2177_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX 0
+/* SET_PROPERTY command, DATA field definition (size 16, lsb 0, unsigned)*/
+#define  SI2177_SET_PROPERTY_RESPONSE_DATA_LSB                                 0
+#define  SI2177_SET_PROPERTY_RESPONSE_DATA_MASK                              0xffff
+
+#endif /* SI2177_SET_PROPERTY_CMD */
+
+/* SI2177_STANDBY command definition */
+#define SI2177_STANDBY_CMD                                                                             0x16
+
+#ifdef    SI2177_STANDBY_CMD
+
+typedef struct { /* SI2177_STANDBY_CMD_struct */
+     unsigned char   type;
+} si2177_standby_cmd_struct;
+
+
+typedef struct { /* SI2177_STANDBY_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_standby_cmd_reply_struct;
+
+   /* STANDBY command, TYPE field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  SI2177_STANDBY_CMD_TYPE_LSB         0
+   #define  SI2177_STANDBY_CMD_TYPE_MASK        0x01
+   #define  SI2177_STANDBY_CMD_TYPE_MIN         0
+   #define  SI2177_STANDBY_CMD_TYPE_MAX         1
+    #define SI2177_STANDBY_CMD_TYPE_LNA_OFF  1
+    #define SI2177_STANDBY_CMD_TYPE_LNA_ON   0
+#endif /* SI2177_STANDBY_CMD */
+
+/* SI2177_TUNER_STATUS command definition */
+#define SI2177_TUNER_STATUS_CMD                                                                 0x42
+
+#ifdef    SI2177_TUNER_STATUS_CMD
+
+typedef struct { /* SI2177_TUNER_STATUS_CMD_struct */
+     unsigned char   intack;
+} si2177_tuner_status_cmd_struct;
+
+/* TUNER_STATUS command, INTACK field definition (size 1, lsb 0, unsigned) */
+#define  SI2177_TUNER_STATUS_CMD_INTACK_LSB                             0
+#define  SI2177_TUNER_STATUS_CMD_INTACK_MASK                          0x01
+#define  SI2177_TUNER_STATUS_CMD_INTACK_MIN                             0
+#define  SI2177_TUNER_STATUS_CMD_INTACK_MAX                            1
+#define SI2177_TUNER_STATUS_CMD_INTACK_CLEAR                         1
+#define SI2177_TUNER_STATUS_CMD_INTACK_OK                                0
+
+typedef struct { /* SI2177_TUNER_STATUS_CMD_REPLY_struct */
+      si2177_common_reply_struct * status;
+      unsigned  char                          tcint;
+      unsigned  char                          rssilint;
+      unsigned  char                          rssihint;
+                         int                           vco_code;
+      unsigned  char                          tc;
+      unsigned  char                          rssil;
+      unsigned  char                          rssih;
+                      char                           rssi;
+      unsigned    int                            freq;
+      unsigned  char                          mode;
+      unsigned  char                          resrved;
+}  si2177_tuner_status_cmd_reply_struct;
+
+/* TUNER_STATUS command, TCINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_TCINT_LSB                      0
+#define  SI2177_TUNER_STATUS_RESPONSE_TCINT_MASK                   0x01
+#define SI2177_TUNER_STATUS_RESPONSE_TCINT_CHANGED            1
+#define SI2177_TUNER_STATUS_RESPONSE_TCINT_NO_CHANGE        0
+/* TUNER_STATUS command, RSSILINT field definition (size 1, lsb 1, unsigned)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSILINT_LSB                1
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSILINT_MASK             0x01
+#define SI2177_TUNER_STATUS_RESPONSE_RSSILINT_CHANGED      1
+#define SI2177_TUNER_STATUS_RESPONSE_RSSILINT_NO_CHANGE  0
+/* TUNER_STATUS command, RSSIHINT field definition (size 1, lsb 2, unsigned)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSIHINT_LSB                2
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSIHINT_MASK             0x01
+#define SI2177_TUNER_STATUS_RESPONSE_RSSIHINT_CHANGED      1
+#define SI2177_TUNER_STATUS_RESPONSE_RSSIHINT_NO_CHANGE  0
+/* TUNER_STATUS command, VCO_CODE field definition (size 16, lsb 0, signed)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_VCO_CODE_LSB              0
+#define  SI2177_TUNER_STATUS_RESPONSE_VCO_CODE_MASK           0xffff
+#define  SI2177_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT          16
+/* TUNER_STATUS command, TC field definition (size 1, lsb 0, unsigned)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_TC_LSB                             0
+#define  SI2177_TUNER_STATUS_RESPONSE_TC_MASK                          0x01
+#define SI2177_TUNER_STATUS_RESPONSE_TC_BUSY                           0
+#define SI2177_TUNER_STATUS_RESPONSE_TC_DONE                           1
+/* TUNER_STATUS command, RSSIL field definition (size 1, lsb 1, unsigned)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSIL_LSB                        1
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSIL_MASK                     0x01
+#define SI2177_TUNER_STATUS_RESPONSE_RSSIL_LOW                        1
+#define SI2177_TUNER_STATUS_RESPONSE_RSSIL_OK                           0
+/* TUNER_STATUS command, RSSIH field definition (size 1, lsb 2, unsigned)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSIH_LSB                        2
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSIH_MASK                     0x01
+#define SI2177_TUNER_STATUS_RESPONSE_RSSIH_HIGH                       1
+#define SI2177_TUNER_STATUS_RESPONSE_RSSIH_OK                           0
+/* TUNER_STATUS command, RSSI field definition (size 8, lsb 0, signed)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSI_LSB                           0
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSI_MASK                        0xff
+#define  SI2177_TUNER_STATUS_RESPONSE_RSSI_SHIFT                       24
+/* TUNER_STATUS command, FREQ field definition (size 32, lsb 0, unsigned)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_FREQ_LSB                          0
+#define  SI2177_TUNER_STATUS_RESPONSE_FREQ_MASK                       0xffffffff
+/* TUNER_STATUS command, MODE field definition (size 1, lsb 0, unsigned)*/
+#define  SI2177_TUNER_STATUS_RESPONSE_MODE_LSB                         0
+#define  SI2177_TUNER_STATUS_RESPONSE_MODE_MASK                      0x01
+#define SI2177_TUNER_STATUS_RESPONSE_MODE_ATV                          1
+#define SI2177_TUNER_STATUS_RESPONSE_MODE_DTV                          0
+
+#endif /* SI2177_TUNER_STATUS_CMD */
+
+/* SI2177_TUNER_TUNE_FREQ command definition */
+#define SI2177_TUNER_TUNE_FREQ_CMD                                                  0x41
+
+#ifdef    SI2177_TUNER_TUNE_FREQ_CMD
+
+typedef struct { /* SI2177_TUNER_TUNE_FREQ_CMD_struct */
+     unsigned char   mode;
+     unsigned long   freq;
+} si2177_tuner_tune_freq_cmd_struct;
+
+/* TUNER_TUNE_FREQ command, MODE field definition (size 1, lsb 0, unsigned) */
+#define  SI2177_TUNER_TUNE_FREQ_CMD_MODE_LSB                            0
+#define  SI2177_TUNER_TUNE_FREQ_CMD_MODE_MASK                         0x01
+#define  SI2177_TUNER_TUNE_FREQ_CMD_MODE_MIN                            0
+#define  SI2177_TUNER_TUNE_FREQ_CMD_MODE_MAX                           1
+#define SI2177_TUNER_TUNE_FREQ_CMD_MODE_ATV                             1
+#define SI2177_TUNER_TUNE_FREQ_CMD_MODE_DTV                             0
+/* TUNER_TUNE_FREQ command, FREQ field definition (size 32, lsb 0, unsigned) */
+#define  SI2177_TUNER_TUNE_FREQ_CMD_FREQ_LSB                             0
+#define  SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MASK                          0xffffffff
+   #define  SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MIN         40000000
+#define  SI2177_TUNER_TUNE_FREQ_CMD_FREQ_MAX                            1002000000
+    #define SI2177_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MIN  40000000
+#define SI2177_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MAX                 1002000000
+
+typedef struct { /* SI2177_TUNER_TUNE_FREQ_CMD_REPLY_struct */
+       si2177_common_reply_struct * status;
+}  si2177_tuner_tune_freq_cmd_reply_struct;
+
+#endif /* SI2177_TUNER_TUNE_FREQ_CMD */
+
+/* _commands_defines_insertion_point */
+
+/* _commands_struct_insertion_start */
+
+/* --------------------------------------------*/
+/* COMMANDS STRUCT                             */
+/* This is used to store all command fields    */
+/* --------------------------------------------*/
+typedef union { /* SI2177_CmdObj union */
+    #ifdef    SI2177_AGC_OVERRIDE_CMD
+              si2177_agc_override_cmd_struct               agc_override;
+    #endif /* SI2177_AGC_OVERRIDE_CMD */
+    #ifdef    SI2177_ATV_CW_TEST_CMD
+              si2177_atv_cw_test_cmd_struct                atv_cw_test;
+    #endif /* SI2177_ATV_CW_TEST_CMD */
+    #ifdef    SI2177_ATV_RESTART_CMD
+              si2177_atv_restart_cmd_struct                  atv_restart;
+    #endif /* SI2177_ATV_RESTART_CMD */
+    #ifdef    SI2177_ATV_STATUS_CMD
+              si2177_atv_status_cmd_struct                   atv_status;
+    #endif /* SI2177_ATV_STATUS_CMD */
+    #ifdef    SI2177_CONFIG_CLOCKS_CMD
+              si2177_config_clocks_cmd_struct    config_clocks;
+    #endif /* SI2177_CONFIG_CLOCKS_CMD */
+    #ifdef    SI2177_CONFIG_PINS_CMD
+              si2177_config_pins_cmd_struct                 config_pins;
+    #endif /* SI2177_CONFIG_PINS_CMD */
+    #ifdef    SI2177_DOWNLOAD_DATASET_CONTINUE_CMD
+              si2177_download_dataset_continue_cmd_struct  download_dataset_continue;
+    #endif /* SI2177_DOWNLOAD_DATASET_CONTINUE_CMD */
+    #ifdef    SI2177_DOWNLOAD_DATASET_START_CMD
+              si2177_download_dataset_start_cmd_struct     download_dataset_start;
+    #endif /* SI2177_DOWNLOAD_DATASET_START_CMD */
+    #ifdef    SI2177_DTV_RESTART_CMD
+              si2177_dtv_restart_cmd_struct                dtv_restart;
+    #endif /* SI2177_DTV_RESTART_CMD */
+    #ifdef    SI2177_DTV_STATUS_CMD
+              si2177_dtv_status_cmd_struct                 dtv_status;
+    #endif /* SI2177_DTV_STATUS_CMD */
+    #ifdef    SI2177_EXIT_BOOTLOADER_CMD
+              si2177_exit_bootloader_cmd_struct         exit_bootloader;
+    #endif /* SI2177_EXIT_BOOTLOADER_CMD */
+    #ifdef    SI2177_FINE_TUNE_CMD
+              si2177_fine_tune_cmd_struct                   fine_tune;
+    #endif /* SI2177_FINE_TUNE_CMD */
+    #ifdef    SI2177_GET_PROPERTY_CMD
+              si2177_get_property_cmd_struct             get_property;
+    #endif /* SI2177_GET_PROPERTY_CMD */
+    #ifdef    SI2177_GET_REV_CMD
+              si2177_get_rev_cmd_struct                      get_rev;
+    #endif /* SI2177_GET_REV_CMD */
+    #ifdef    SI2177_PART_INFO_CMD
+              si2177_part_info_cmd_struct                    part_info;
+    #endif /* SI2177_PART_INFO_CMD */
+    #ifdef    SI2177_POWER_DOWN_CMD
+              si2177_power_down_cmd_struct              power_down;
+    #endif /* SI2177_POWER_DOWN_CMD */
+    #ifdef    SI2177_POWER_DOWN_HW_CMD
+              SI2177_POWER_DOWN_HW_CMD_struct    power_down_hw;
+    #endif /* SI2177_POWER_DOWN_HW_CMD */
+    #ifdef    SI2177_POWER_UP_CMD
+              si2177_power_up_cmd_struct                   power_up;
+    #endif /* SI2177_POWER_UP_CMD */
+    #ifdef    SI2177_SET_PROPERTY_CMD
+              si2177_set_property_cmd_struct               set_property;
+    #endif /* SI2177_SET_PROPERTY_CMD */
+    #ifdef    SI2177_STANDBY_CMD
+              si2177_standby_cmd_struct                      standby;
+    #endif /* SI2177_STANDBY_CMD */
+    #ifdef    SI2177_TUNER_STATUS_CMD
+              si2177_tuner_status_cmd_struct               tuner_status;
+    #endif /* SI2177_TUNER_STATUS_CMD */
+    #ifdef    SI2177_TUNER_TUNE_FREQ_CMD
+              si2177_tuner_tune_freq_cmd_struct          tuner_tune_freq;
+    #endif /* SI2177_TUNER_TUNE_FREQ_CMD */
+} si2177_cmdobj_t;
+/* _commands_struct_insertion_point */
+
+/* _commands_reply_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* COMMANDS REPLY STRUCT                       */
+  /* This stores all command reply fields        */
+  /* --------------------------------------------*/
+typedef struct { /* SI2177_CmdReplyObj struct */
+    #ifdef    SI2177_AGC_OVERRIDE_CMD
+              si2177_agc_override_cmd_reply_struct              agc_override;
+    #endif /* SI2177_AGC_OVERRIDE_CMD */
+    #ifdef    SI2177_ATV_CW_TEST_CMD
+              si2177_atv_cw_test_cmd_reply_struct                 atv_cw_test;
+    #endif /* SI2177_ATV_CW_TEST_CMD */
+    #ifdef    SI2177_ATV_RESTART_CMD
+              si2177_atv_restart_cmd_reply_struct                  atv_restart;
+    #endif /* SI2177_ATV_RESTART_CMD */
+    #ifdef    SI2177_ATV_STATUS_CMD
+              si2177_atv_status_cmd_reply_struct                   atv_status;
+    #endif /* SI2177_ATV_STATUS_CMD */
+    #ifdef    SI2177_CONFIG_CLOCKS_CMD
+              SI2177_CONFIG_CLOCKS_CMD_REPLY_struct    config_clocks;
+    #endif /* SI2177_CONFIG_CLOCKS_CMD */
+    #ifdef    SI2177_CONFIG_PINS_CMD
+              si2177_config_pins_cmd_reply_struct                 config_pins;
+    #endif /* SI2177_CONFIG_PINS_CMD */
+    #ifdef    SI2177_DOWNLOAD_DATASET_CONTINUE_CMD
+              si2177_download_dataset_continue_cmd_reply_struct  download_dataset_continue;
+    #endif /* SI2177_DOWNLOAD_DATASET_CONTINUE_CMD */
+    #ifdef    SI2177_DOWNLOAD_DATASET_START_CMD
+              si2177_download_dataset_start_cmd_reply_struct        download_dataset_start;
+    #endif /* SI2177_DOWNLOAD_DATASET_START_CMD */
+    #ifdef    SI2177_EXIT_BOOTLOADER_CMD
+              si2177_exit_bootloader_cmd_reply_struct                     exit_bootloader;
+    #endif /* SI2177_EXIT_BOOTLOADER_CMD */
+    #ifdef    SI2177_FINE_TUNE_CMD
+              si2177_fine_tune_cmd_reply_struct                               fine_tune;
+    #endif /* SI2177_FINE_TUNE_CMD */
+    #ifdef    SI2177_GET_PROPERTY_CMD
+              si2177_get_property_cmd_reply_struct                         get_property;
+    #endif /* SI2177_GET_PROPERTY_CMD */
+    #ifdef    SI2177_GET_REV_CMD
+              si2177_get_rev_cmd_reply_struct                    get_rev;
+    #endif /* SI2177_GET_REV_CMD */
+    #ifdef    SI2177_PART_INFO_CMD
+              si2177_part_info_cmd_reply_struct                  part_info;
+    #endif /* SI2177_PART_INFO_CMD */
+    #ifdef    SI2177_POWER_DOWN_CMD
+              si2177_power_down_cmd_reply_struct           power_down;
+    #endif /* SI2177_POWER_DOWN_CMD */
+    #ifdef    SI2177_POWER_DOWN_HW_CMD
+              SI2177_POWER_DOWN_HW_CMD_REPLY_struct    power_down_hw;
+    #endif /* SI2177_POWER_DOWN_HW_CMD */
+    #ifdef    SI2177_POWER_UP_CMD
+              si2177_power_up_cmd_reply_struct                power_up;
+    #endif /* SI2177_POWER_UP_CMD */
+    #ifdef    SI2177_SET_PROPERTY_CMD
+              si2177_set_property_cmd_reply_struct           set_property;
+    #endif /* SI2177_SET_PROPERTY_CMD */
+    #ifdef    SI2177_STANDBY_CMD
+              si2177_standby_cmd_reply_struct                  standby;
+    #endif /* SI2177_STANDBY_CMD */
+    #ifdef    SI2177_TUNER_STATUS_CMD
+              si2177_tuner_status_cmd_reply_struct           tuner_status;
+    #endif /* SI2177_TUNER_STATUS_CMD */
+    #ifdef    SI2177_TUNER_TUNE_FREQ_CMD
+              si2177_tuner_tune_freq_cmd_reply_struct      tuner_tune_freq;
+    #endif /* SI2177_TUNER_TUNE_FREQ_CMD */
+} si2177_cmdreplyobj_t;
+/* _commands_reply_struct_insertion_point */
+
+/* _properties_defines_insertion_start */
+/* SI2177 ATV_AFC_RANGE property definition */
+#define   SI2177_ATV_AFC_RANGE_PROP                                     0x0610
+
+#ifdef    SI2177_ATV_AFC_RANGE_PROP
+
+typedef struct { /* SI2177_ATV_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+} si2177_atv_afc_range_prop_struct;
+
+   /* ATV_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+   #define  SI2177_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+   #define  SI2177_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+   #define  SI2177_ATV_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    1000
+    #define SI2177_ATV_AFC_RANGE_PROP_RANGE_KHZ_RANGE_KHZ_MIN  0
+    #define SI2177_ATV_AFC_RANGE_PROP_RANGE_KHZ_RANGE_KHZ_MAX  65535
+
+#endif /* SI2177_ATV_AFC_RANGE_PROP */
+
+/* SI2177 ATV_AF_OUT property definition */
+#define   SI2177_ATV_AF_OUT_PROP                                           0x060b
+
+#ifdef    SI2177_ATV_AF_OUT_PROP
+
+typedef struct { /* SI2177_ATV_AF_OUT_PROP_struct */
+      unsigned char   mute;
+      unsigned char   volume;
+} si2177_atv_af_out_prop_struct;
+
+   #define  SI2177_ATV_AF_OUT_PROP_MUTE_LSB         6
+   #define  SI2177_ATV_AF_OUT_PROP_MUTE_MASK        0x01
+   #define  SI2177_ATV_AF_OUT_PROP_MUTE_DEFAULT    0
+    #define SI2177_ATV_AF_OUT_PROP_MUTE_NORMAL  0
+    #define SI2177_ATV_AF_OUT_PROP_MUTE_MUTE    1
+/* ATV_AF_OUT property, VOLUME field definition (NO TITLE)*/
+#define  SI2177_ATV_AF_OUT_PROP_VOLUME_LSB                  0
+#define  SI2177_ATV_AF_OUT_PROP_VOLUME_MASK               0x3f
+#define  SI2177_ATV_AF_OUT_PROP_VOLUME_DEFAULT         0
+#define SI2177_ATV_AF_OUT_PROP_VOLUME_VOLUME_MIN   0
+#define SI2177_ATV_AF_OUT_PROP_VOLUME_VOLUME_MAX  63
+
+#endif /* SI2177_ATV_AF_OUT_PROP */
+
+/* SI2177 ATV_AGC_SPEED property definition */
+#define   SI2177_ATV_AGC_SPEED_PROP                                   0x0611
+
+#ifdef    SI2177_ATV_AGC_SPEED_PROP
+
+typedef struct { /* SI2177_ATV_AGC_SPEED_PROP_struct */
+      unsigned char   if_agc_speed;
+} si2177_atv_agc_speed_prop_struct;
+
+/* ATV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define  SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB           0
+#define  SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+#define  SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT  0
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO          0
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_89               89
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_105             105
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_121             121
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_137             137
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_158             158
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_172             172
+    #define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_178     178
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_185             185
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_196             196
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_206             206
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_216             216
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_219             219
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_222             222
+    #define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_223     223
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_248             248
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_250             250
+#define SI2177_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_251             251
+
+#endif /* SI2177_ATV_AGC_SPEED_PROP */
+
+/* SI2177 ATV_AGC_SPEED_LOW_RSSI property definition */
+#define   SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP 0x0623
+
+#ifdef    SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP
+  #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_CODE 0x000623
+
+
+    typedef struct { /* SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_struct */
+      unsigned char   if_agc_speed;
+               char   thld;
+   } SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_struct;
+
+   /* ATV_AGC_SPEED_LOW_RSSI property, IF_AGC_SPEED field definition (NO TITLE)*/
+   #define  SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_LSB         0
+   #define  SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_MASK        0xff
+   #define  SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_DEFAULT    158
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_89      89
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_105     105
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_121     121
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_137     137
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_158     158
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_172     172
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_178     178
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_185     185
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_196     196
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_206     206
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_216     216
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_219     219
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_222     222
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_223     223
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_248     248
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_250     250
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_251     251
+
+   /* ATV_AGC_SPEED_LOW_RSSI property, THLD field definition (NO TITLE)*/
+   #define  SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_LSB         8
+   #define  SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_MASK        0xff
+   #define  SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_DEFAULT    -128
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_THLD_MIN  -128
+    #define SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_THLD_MAX  127
+
+#endif /* SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP */
+
+/* SI2177 ATV_ARTIFICIAL_SNOW property definition */
+#define   SI2177_ATV_ARTIFICIAL_SNOW_PROP 0x0624
+
+#ifdef    SI2177_ATV_ARTIFICIAL_SNOW_PROP
+  #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_CODE 0x000624
+
+
+    typedef struct { /* SI2177_ATV_ARTIFICIAL_SNOW_PROP_struct */
+      unsigned char   gain;
+               char   offset;
+      unsigned char   period;
+      unsigned char   sound;
+   } SI2177_ATV_ARTIFICIAL_SNOW_PROP_struct;
+
+   /* ATV_ARTIFICIAL_SNOW property, GAIN field definition (NO TITLE)*/
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB         0
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK        0x0f
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_DEFAULT    0
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_AUTO  0
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_0DB   1
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_6DB   2
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_12DB  3
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_18DB  4
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_24DB  5
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_30DB  6
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_36DB  7
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_42DB  8
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_GAIN_OFF   9
+
+   /* ATV_ARTIFICIAL_SNOW property, OFFSET field definition (NO TITLE)*/
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB         8
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK        0xff
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_DEFAULT    0
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_OFFSET_MIN  -128
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_OFFSET_MAX  127
+
+   /* ATV_ARTIFICIAL_SNOW property, PERIOD field definition (NO TITLE)*/
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_LSB         7
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_MASK        0x01
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_DEFAULT    0
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_LONG   0
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_PERIOD_SHORT  1
+
+   /* ATV_ARTIFICIAL_SNOW property, SOUND field definition (NO TITLE)*/
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_LSB         4
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_MASK        0x07
+   #define  SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_DEFAULT    0
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_MUTE          0
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_6DB           1
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_12DB          2
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_18DB          3
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_24DB          4
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_30DB          5
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_36DB          6
+    #define SI2177_ATV_ARTIFICIAL_SNOW_PROP_SOUND_PASS_THROUGH  7
+
+#endif /* SI2177_ATV_AGC_SPEED_PROP */
+
+/* SI2177 ATV_AUDIO_MODE property definition */
+#define   SI2177_ATV_AUDIO_MODE_PROP                                            0x0602
+
+#ifdef    SI2177_ATV_AUDIO_MODE_PROP
+
+typedef struct { /* SI2177_ATV_AUDIO_MODE_PROP_struct */
+      unsigned char   audio_sys;
+      unsigned char   chan_bw;
+      unsigned char   demod_mode;
+} si2177_atv_audio_mode_prop_struct;
+
+/* ATV_AUDIO_MODE property, AUDIO_SYS field definition (NO TITLE)*/
+#define  SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_LSB           0
+#define  SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MASK        0x0f
+#define  SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_DEFAULT  0
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_DEFAULT   0
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO        1
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO_NICAM  2
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2              3
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2_DK2     4
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2_DK3     5
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_BTSC         6
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_EIAJ           7
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_SCAN        8
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_A2_DK4     9
+#define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_WIDE_SCAN   10
+    #define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO_NICAM_6DB   11
+    #define SI2177_ATV_AUDIO_MODE_PROP_AUDIO_SYS_MONO_NICAM_10DB  12
+
+/* ATV_AUDIO_MODE property, CHAN_BW field definition (NO TITLE)*/
+#define  SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB             8
+#define  SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK          0x0f
+#define  SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT    0
+#define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT     0
+#define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_4X_OVERMOD         1
+#define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_8X_OVERMOD         2
+#define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_12X_OVERMOD       3
+#define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_7P5_KHZ_OFFSET  4
+#define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_15_KHZ_OFFSET    5
+#define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_30_KHZ_OFFSET    6
+#define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_75_KHZ_OFFSET    7
+#define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_150_KHZ_OFFSET  8
+    #define SI2177_ATV_AUDIO_MODE_PROP_CHAN_BW_CUSTOM          9
+
+/* ATV_AUDIO_MODE property, DEMOD_MODE field definition (NO TITLE)*/
+#define  SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_LSB                  4
+#define  SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_MASK               0x03
+#define  SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_DEFAULT         0
+#define SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_SIF                     0
+#define SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_AM                      1
+#define SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_FM1                    2
+#define SI2177_ATV_AUDIO_MODE_PROP_DEMOD_MODE_FM2                    3
+
+#endif /* SI2177_ATV_AUDIO_MODE_PROP */
+
+/* SI2177 ATV_CONFIG_IF_PORT property definition */
+#define   SI2177_ATV_CONFIG_IF_PORT_PROP 0x0603
+
+#ifdef    SI2177_ATV_CONFIG_IF_PORT_PROP
+  #define SI2177_ATV_CONFIG_IF_PORT_PROP_CODE 0x000603
+
+
+    typedef struct { /* SI2177_ATV_CONFIG_IF_PORT_PROP_struct */
+      unsigned char   atv_out_type;
+   } SI2177_ATV_CONFIG_IF_PORT_PROP_struct;
+
+   /* ATV_CONFIG_IF_PORT property, ATV_OUT_TYPE field definition (NO TITLE)*/
+   #define  SI2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB         0
+   #define  SI2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK        0x0f
+   #define  SI2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_DEFAULT    0
+    #define SI2177_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_CVBS_IF2B_SOUND_IF2A  0
+
+#endif /* SI2177_ATV_AUDIO_MODE_PROP */
+
+/* SI2177 ATV_CVBS_OUT property definition */
+#define   SI2177_ATV_CVBS_OUT_PROP                                      0x0609
+
+#ifdef    SI2177_ATV_CVBS_OUT_PROP
+
+typedef struct { /* SI2177_ATV_CVBS_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+} si2177_atv_cvbs_out_prop_struct;
+
+/* ATV_CVBS_OUT property, AMP field definition (NO TITLE)*/
+#define  SI2177_ATV_CVBS_OUT_PROP_AMP_LSB                   8
+#define  SI2177_ATV_CVBS_OUT_PROP_AMP_MASK                0xff
+#define  SI2177_ATV_CVBS_OUT_PROP_AMP_DEFAULT          200
+#define SI2177_ATV_CVBS_OUT_PROP_AMP_AMP_MIN           0
+#define SI2177_ATV_CVBS_OUT_PROP_AMP_AMP_MAX          255
+
+/* ATV_CVBS_OUT property, OFFSET field definition (NO TITLE)*/
+#define  SI2177_ATV_CVBS_OUT_PROP_OFFSET_LSB                0
+#define  SI2177_ATV_CVBS_OUT_PROP_OFFSET_MASK             0xff
+#define  SI2177_ATV_CVBS_OUT_PROP_OFFSET_DEFAULT       25
+#define SI2177_ATV_CVBS_OUT_PROP_OFFSET_OFFSET_MIN  0
+#define SI2177_ATV_CVBS_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* SI2177_ATV_CVBS_OUT_PROP */
+
+/* SI2177 ATV_CVBS_OUT_FINE property definition */
+#define   SI2177_ATV_CVBS_OUT_FINE_PROP                     0x0614
+
+#ifdef    SI2177_ATV_CVBS_OUT_FINE_PROP
+
+typedef struct { /* SI2177_ATV_CVBS_OUT_FINE_PROP_struct */
+      unsigned char   amp;
+                      char   offset;
+} si2177_atv_cvbs_out_fine_prop_struct;
+
+/* ATV_CVBS_OUT_FINE property, AMP field definition (NO TITLE)*/
+#define  SI2177_ATV_CVBS_OUT_FINE_PROP_AMP_LSB            8
+#define  SI2177_ATV_CVBS_OUT_FINE_PROP_AMP_MASK         0xff
+#define  SI2177_ATV_CVBS_OUT_FINE_PROP_AMP_DEFAULT   100
+#define SI2177_ATV_CVBS_OUT_FINE_PROP_AMP_AMP_MIN    25
+#define SI2177_ATV_CVBS_OUT_FINE_PROP_AMP_AMP_MAX   100
+
+/* ATV_CVBS_OUT_FINE property, OFFSET field definition (NO TITLE)*/
+#define  SI2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB                 0
+#define  SI2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK              0xff
+#define  SI2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_DEFAULT        0
+#define SI2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_OFFSET_MIN   -128
+#define SI2177_ATV_CVBS_OUT_FINE_PROP_OFFSET_OFFSET_MAX  127
+
+#endif /* SI2177_ATV_CVBS_OUT_FINE_PROP */
+
+/* SI2177 ATV_HSYNC_OUT property definition */
+#define   SI2177_ATV_HSYNC_OUT_PROP 0x0627
+
+#ifdef    SI2177_ATV_HSYNC_OUT_PROP
+
+
+
+    typedef struct { /* SI2177_ATV_HSYNC_OUT_PROP_struct */
+      unsigned char   gpio_sel;
+               char   offset;
+      unsigned char   width;
+   } SI2177_ATV_HSYNC_OUT_PROP_struct;
+
+   /* ATV_HSYNC_OUT property, GPIO_SEL field definition (NO TITLE)*/
+   #define  SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_LSB         0
+   #define  SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_MASK        0x03
+   #define  SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_DEFAULT    0
+    #define SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_NONE   0
+    #define SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_GPIO1  1
+    #define SI2177_ATV_HSYNC_OUT_PROP_GPIO_SEL_GPIO2  2
+
+   /* ATV_HSYNC_OUT property, OFFSET field definition (NO TITLE)*/
+   #define  SI2177_ATV_HSYNC_OUT_PROP_OFFSET_LSB         8
+   #define  SI2177_ATV_HSYNC_OUT_PROP_OFFSET_MASK        0xff
+   #define  SI2177_ATV_HSYNC_OUT_PROP_OFFSET_DEFAULT    0
+    #define SI2177_ATV_HSYNC_OUT_PROP_OFFSET_OFFSET_MIN  -128
+    #define SI2177_ATV_HSYNC_OUT_PROP_OFFSET_OFFSET_MAX  127
+
+   /* ATV_HSYNC_OUT property, WIDTH field definition (NO TITLE)*/
+   #define  SI2177_ATV_HSYNC_OUT_PROP_WIDTH_LSB         2
+   #define  SI2177_ATV_HSYNC_OUT_PROP_WIDTH_MASK        0x3f
+   #define  SI2177_ATV_HSYNC_OUT_PROP_WIDTH_DEFAULT    42
+    #define SI2177_ATV_HSYNC_OUT_PROP_WIDTH_WIDTH_MIN  0
+    #define SI2177_ATV_HSYNC_OUT_PROP_WIDTH_WIDTH_MAX  51
+
+#endif /* SI2177_ATV_HSYNC_OUT_PROP */
+
+/* SI2177 ATV_IEN property definition */
+#define   SI2177_ATV_IEN_PROP                                           0x0601
+
+#ifdef    SI2177_ATV_IEN_PROP
+
+typedef struct { /* SI2177_ATV_IEN_PROP_struct */
+      unsigned char   chlien;
+      unsigned char   dlien;
+      unsigned char   pclien;
+      unsigned char   snrhien;
+      unsigned char   snrlien;
+} si2177_atv_ien_prop_struct;
+
+/* ATV_IEN property, CHLIEN field definition (NO TITLE)*/
+#define  SI2177_ATV_IEN_PROP_CHLIEN_LSB                 0
+#define  SI2177_ATV_IEN_PROP_CHLIEN_MASK              0x01
+   #define  SI2177_ATV_IEN_PROP_CHLIEN_DEFAULT    1
+#define SI2177_ATV_IEN_PROP_CHLIEN_DISABLE          0
+#define SI2177_ATV_IEN_PROP_CHLIEN_ENABLE           1
+
+/* ATV_IEN property, DLIEN field definition (NO TITLE)*/
+#define  SI2177_ATV_IEN_PROP_DLIEN_LSB                    2
+#define  SI2177_ATV_IEN_PROP_DLIEN_MASK                 0x01
+#define  SI2177_ATV_IEN_PROP_DLIEN_DEFAULT           0
+#define SI2177_ATV_IEN_PROP_DLIEN_DISABLE             0
+#define SI2177_ATV_IEN_PROP_DLIEN_ENABLE              1
+
+/* ATV_IEN property, PCLIEN field definition (NO TITLE)*/
+#define  SI2177_ATV_IEN_PROP_PCLIEN_LSB                  1
+#define  SI2177_ATV_IEN_PROP_PCLIEN_MASK               0x01
+#define  SI2177_ATV_IEN_PROP_PCLIEN_DEFAULT         0
+#define SI2177_ATV_IEN_PROP_PCLIEN_DISABLE           0
+#define SI2177_ATV_IEN_PROP_PCLIEN_ENABLE            1
+
+/* ATV_IEN property, SNRHIEN field definition (NO TITLE)*/
+#define  SI2177_ATV_IEN_PROP_SNRHIEN_LSB               4
+#define  SI2177_ATV_IEN_PROP_SNRHIEN_MASK            0x01
+#define  SI2177_ATV_IEN_PROP_SNRHIEN_DEFAULT      0
+#define SI2177_ATV_IEN_PROP_SNRHIEN_DISABLE        0
+#define SI2177_ATV_IEN_PROP_SNRHIEN_ENABLE         1
+
+/* ATV_IEN property, SNRLIEN field definition (NO TITLE)*/
+#define  SI2177_ATV_IEN_PROP_SNRLIEN_LSB                3
+#define  SI2177_ATV_IEN_PROP_SNRLIEN_MASK             0x01
+#define  SI2177_ATV_IEN_PROP_SNRLIEN_DEFAULT       0
+#define SI2177_ATV_IEN_PROP_SNRLIEN_DISABLE         0
+#define SI2177_ATV_IEN_PROP_SNRLIEN_ENABLE          1
+
+#endif /* SI2177_ATV_IEN_PROP */
+
+/* SI2177 ATV_INT_SENSE property definition */
+#define   SI2177_ATV_INT_SENSE_PROP                            0x0613
+
+#ifdef    SI2177_ATV_INT_SENSE_PROP
+
+typedef struct { /* SI2177_ATV_INT_SENSE_PROP_struct */
+      unsigned char   chlnegen;
+      unsigned char   chlposen;
+      unsigned char   dlnegen;
+      unsigned char   dlposen;
+      unsigned char   pclnegen;
+      unsigned char   pclposen;
+      unsigned char   snrhnegen;
+      unsigned char   snrhposen;
+      unsigned char   snrlnegen;
+      unsigned char   snrlposen;
+} si2177_atv_int_sense_prop_struct;
+
+/* ATV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_LSB             0
+#define  SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_MASK          0x01
+#define  SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+#define SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE      0
+#define SI2177_ATV_INT_SENSE_PROP_CHLNEGEN_ENABLE       1
+
+/* ATV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_LSB             8
+#define  SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_MASK          0x01
+#define  SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_DEFAULT   1
+#define SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_DISABLE     0
+#define SI2177_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE      1
+
+/* ATV_INT_SENSE property, DLNEGEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_DLNEGEN_LSB               2
+#define  SI2177_ATV_INT_SENSE_PROP_DLNEGEN_MASK            0x01
+#define  SI2177_ATV_INT_SENSE_PROP_DLNEGEN_DEFAULT     0
+#define SI2177_ATV_INT_SENSE_PROP_DLNEGEN_DISABLE       0
+#define SI2177_ATV_INT_SENSE_PROP_DLNEGEN_ENABLE        1
+
+/* ATV_INT_SENSE property, DLPOSEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_DLPOSEN_LSB              10
+#define  SI2177_ATV_INT_SENSE_PROP_DLPOSEN_MASK           0x01
+#define  SI2177_ATV_INT_SENSE_PROP_DLPOSEN_DEFAULT    1
+#define SI2177_ATV_INT_SENSE_PROP_DLPOSEN_DISABLE      0
+#define SI2177_ATV_INT_SENSE_PROP_DLPOSEN_ENABLE       1
+
+/* ATV_INT_SENSE property, PCLNEGEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_LSB           1
+#define  SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_MASK        0x01
+#define  SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_DEFAULT  0
+#define SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE    0
+#define SI2177_ATV_INT_SENSE_PROP_PCLNEGEN_ENABLE     1
+
+/* ATV_INT_SENSE property, PCLPOSEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_LSB             9
+#define  SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_MASK          0x01
+#define  SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_DEFAULT    1
+#define SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_DISABLE      0
+#define SI2177_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE       1
+
+/* ATV_INT_SENSE property, SNRHNEGEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB           4
+#define  SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK        0x01
+#define  SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_DEFAULT  0
+#define SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_DISABLE    0
+#define SI2177_ATV_INT_SENSE_PROP_SNRHNEGEN_ENABLE     1
+
+/* ATV_INT_SENSE property, SNRHPOSEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB            12
+#define  SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK         0x01
+#define  SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_DEFAULT   1
+#define SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_DISABLE     0
+#define SI2177_ATV_INT_SENSE_PROP_SNRHPOSEN_ENABLE      1
+
+/* ATV_INT_SENSE property, SNRLNEGEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB             3
+#define  SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK          0x01
+#define  SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_DEFAULT   0
+#define SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_DISABLE     0
+#define SI2177_ATV_INT_SENSE_PROP_SNRLNEGEN_ENABLE      1
+
+/* ATV_INT_SENSE property, SNRLPOSEN field definition (NO TITLE)*/
+#define  SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB            11
+#define  SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK         0x01
+#define  SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_DEFAULT   1
+#define SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_DISABLE     0
+#define SI2177_ATV_INT_SENSE_PROP_SNRLPOSEN_ENABLE      1
+
+#endif /* SI2177_ATV_INT_SENSE_PROP */
+
+/* SI2177 ATV_MIN_LVL_LOCK property definition */
+#define   SI2177_ATV_MIN_LVL_LOCK_PROP                                  0x060f
+
+#ifdef    SI2177_ATV_MIN_LVL_LOCK_PROP
+
+typedef struct { /* SI2177_ATV_MIN_LVL_LOCK_PROP_struct */
+      unsigned char   thrs;
+} si2177_atv_min_lvl_lock_prop_struct;
+
+/* ATV_MIN_LVL_LOCK property, THRS field definition (NO TITLE)*/
+#define  SI2177_ATV_MIN_LVL_LOCK_PROP_THRS_LSB              0
+#define  SI2177_ATV_MIN_LVL_LOCK_PROP_THRS_MASK           0xff
+#define  SI2177_ATV_MIN_LVL_LOCK_PROP_THRS_DEFAULT     34
+#endif /* SI2177_ATV_MIN_LVL_LOCK_PROP */
+/* SI2177 ATV_PGA_TARGET property definition */
+#define   SI2177_ATV_PGA_TARGET_PROP 0x0617
+
+#ifdef    SI2177_ATV_PGA_TARGET_PROP
+  #define SI2177_ATV_PGA_TARGET_PROP_CODE 0x000617
+
+
+    typedef struct { /* SI2177_ATV_PGA_TARGET_PROP_struct */
+      unsigned char   override_enable;
+               char   pga_target;
+   } SI2177_ATV_PGA_TARGET_PROP_struct;
+
+   /* ATV_PGA_TARGET property, OVERRIDE_ENABLE field definition (NO TITLE)*/
+   #define  SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB         8
+   #define  SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK        0x01
+   #define  SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DEFAULT    0
+    #define SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE  0
+    #define SI2177_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_ENABLE   1
+
+   /* ATV_PGA_TARGET property, PGA_TARGET field definition (NO TITLE)*/
+   #define  SI2177_ATV_PGA_TARGET_PROP_PGA_TARGET_LSB         0
+   #define  SI2177_ATV_PGA_TARGET_PROP_PGA_TARGET_MASK        0xff
+   #define  SI2177_ATV_PGA_TARGET_PROP_PGA_TARGET_DEFAULT    0
+    #define SI2177_ATV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MIN  -13
+    #define SI2177_ATV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MAX  7
+
+#endif /* SI2177_ATV_PGA_TARGET_PROP */
+
+/* SI2177 ATV_RF_TOP property definition */
+#define   SI2177_ATV_RF_TOP_PROP                                              0x0612
+
+#ifdef    SI2177_ATV_RF_TOP_PROP
+
+typedef struct { /* SI2177_ATV_RF_TOP_PROP_struct */
+      unsigned char   atv_rf_top;
+} si2177_atv_rf_top_prop_struct;
+
+/* ATV_RF_TOP property, ATV_RF_TOP field definition (NO TITLE)*/
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB              0
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK           0xff
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_DEFAULT     0
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO            0
+    #define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_P2DB   4
+    #define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_P1DB   5
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_0DB               6
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M1DB            7
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M2DB            8
+    #define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M3DB   9
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M4DB            10
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M5DB            11
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M6DB            12
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M7DB            13
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M8DB            14
+#define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M9DB            15
+    #define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M10DB  16
+    #define SI2177_ATV_RF_TOP_PROP_ATV_RF_TOP_M11DB  17
+
+#endif /* SI2177_ATV_RF_TOP_PROP */
+
+/* SI2177 ATV_RSQ_RSSI_THRESHOLD property definition */
+#define   SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP                0x0605
+
+#ifdef    SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP
+
+typedef struct { /* SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_struct */
+               char   hi;
+               char   lo;
+} si2177_atv_rsq_rssi_threshold_prop_struct;
+
+/* ATV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+#define  SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB              8
+#define  SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK           0xff
+#define  SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT    0
+#define SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN         -128
+#define SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX        127
+
+/* ATV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+#define  SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB             0
+#define  SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK          0xff
+#define  SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT    -70
+#define SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN        -128
+#define SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX       127
+
+#endif /* SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP */
+
+/* SI2177 ATV_RSQ_SNR_THRESHOLD property definition */
+#define   SI2177_ATV_RSQ_SNR_THRESHOLD_PROP                           0x0606
+
+#ifdef    SI2177_ATV_RSQ_SNR_THRESHOLD_PROP
+
+typedef struct { /* SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_struct */
+      unsigned char   hi;
+      unsigned char   lo;
+} si2177_atv_rsq_snr_threshold_prop_struct;
+
+/* ATV_RSQ_SNR_THRESHOLD property, HI field definition (NO TITLE)*/
+#define  SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB            8
+#define  SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK         0xff
+#define  SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_DEFAULT   45
+#define SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_HI_MIN         0
+#define SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_HI_HI_MAX       255
+
+/* ATV_RSQ_SNR_THRESHOLD property, LO field definition (NO TITLE)*/
+#define  SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB           0
+#define  SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK        0xff
+#define  SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_DEFAULT  25
+#define SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LO_MIN       0
+#define SI2177_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LO_MAX     255
+
+#endif /* SI2177_ATV_RSQ_SNR_THRESHOLD_PROP */
+
+/* SI2177 ATV_SIF_OUT property definition */
+#define   SI2177_ATV_SIF_OUT_PROP                                          0x060a
+
+#ifdef    SI2177_ATV_SIF_OUT_PROP
+
+typedef struct { /* SI2177_ATV_SIF_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+} si2177_atv_sif_out_prop_struct;
+
+/* ATV_SIF_OUT property, AMP field definition (NO TITLE)*/
+#define  SI2177_ATV_SIF_OUT_PROP_AMP_LSB                          8
+#define  SI2177_ATV_SIF_OUT_PROP_AMP_MASK                       0xff
+#define  SI2177_ATV_SIF_OUT_PROP_AMP_DEFAULT                 60
+#define SI2177_ATV_SIF_OUT_PROP_AMP_AMP_MIN                  0
+#define SI2177_ATV_SIF_OUT_PROP_AMP_AMP_MAX                 255
+
+/* ATV_SIF_OUT property, OFFSET field definition (NO TITLE)*/
+#define  SI2177_ATV_SIF_OUT_PROP_OFFSET_LSB                    0
+#define  SI2177_ATV_SIF_OUT_PROP_OFFSET_MASK                 0xff
+#define  SI2177_ATV_SIF_OUT_PROP_OFFSET_DEFAULT          135
+#define SI2177_ATV_SIF_OUT_PROP_OFFSET_OFFSET_MIN     0
+#define SI2177_ATV_SIF_OUT_PROP_OFFSET_OFFSET_MAX    255
+
+#endif /* SI2177_ATV_SIF_OUT_PROP */
+
+/* SI2177 ATV_SOUND_AGC_LIMIT property definition */
+#define   SI2177_ATV_SOUND_AGC_LIMIT_PROP                       0x0618
+
+#ifdef    SI2177_ATV_SOUND_AGC_LIMIT_PROP
+
+typedef struct { /* SI2177_ATV_SOUND_AGC_LIMIT_PROP_struct */
+               char   max_gain;
+               char   min_gain;
+} si2177_atv_sound_agc_limit_prop_struct;
+
+/* ATV_SOUND_AGC_LIMIT property, MAX_GAIN field definition (NO TITLE)*/
+#define  SI2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB                      0
+#define  SI2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK                  0xff
+#define  SI2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_DEFAULT            84
+#define SI2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MAX_GAIN_MIN  -84
+#define SI2177_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MAX_GAIN_MAX  84
+
+/* ATV_SOUND_AGC_LIMIT property, MIN_GAIN field definition (NO TITLE)*/
+#define  SI2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB                       8
+#define  SI2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK                    0xff
+#define  SI2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_DEFAULT              -84
+#define SI2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MIN_GAIN_MIN      -84
+#define SI2177_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MIN_GAIN_MAX     84
+
+#endif /* SI2177_ATV_SOUND_AGC_LIMIT_PROP */
+/* SI2177 ATV_SOUND_AGC_SPEED property definition */
+#define  SI2177_ATV_SOUND_AGC_SPEED_PROP 0x0619
+
+#ifdef   SI2177_ATV_SOUND_AGC_SPEED_PROP
+
+    typedef struct { /* SI2177_ATV_SOUND_AGC_SPEED_PROP_struct */
+      unsigned char   other_systems;
+      unsigned char   system_l;
+   } si2177_atv_sound_agc_speed_prop_struct;
+
+   /* ATV_SOUND_AGC_SPEED property, OTHER_SYSTEMS field definition (NO TITLE)*/
+   #define  SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB         8
+   #define  SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK        0xff
+   #define  SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_DEFAULT    4
+    #define SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_OTHER_SYSTEMS_MIN  0
+    #define SI2177_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_OTHER_SYSTEMS_MAX  15
+
+   /* ATV_SOUND_AGC_SPEED property, SYSTEM_L field definition (NO TITLE)*/
+   #define  SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB         0
+   #define  SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK        0xff
+   #define  SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_DEFAULT    5
+    #define SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_SYSTEM_L_MIN  0
+    #define SI2177_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_SYSTEM_L_MAX  15
+
+#endif /* Si2177_ATV_SOUND_AGC_SPEED_PROP */
+
+/* SI2177 ATV_VIDEO_EQUALIZER property definition */
+#define   SI2177_ATV_VIDEO_EQUALIZER_PROP                                       0x0608
+
+#ifdef    SI2177_ATV_VIDEO_EQUALIZER_PROP
+
+typedef struct { /* SI2177_ATV_VIDEO_EQUALIZER_PROP_struct */
+               char   slope;
+} si2177_atv_video_equalizer_prop_struct;
+
+/* ATV_VIDEO_EQUALIZER property, SLOPE field definition (NO TITLE)*/
+#define  SI2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB                 0
+#define  SI2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK              0xff
+#define  SI2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_DEFAULT       0
+#define SI2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_SLOPE_MIN    -8
+#define SI2177_ATV_VIDEO_EQUALIZER_PROP_SLOPE_SLOPE_MAX   7
+
+#endif /* SI2177_ATV_VIDEO_EQUALIZER_PROP */
+
+/* SI2177 ATV_VIDEO_MODE property definition */
+#define   SI2177_ATV_VIDEO_MODE_PROP                                                0x0604
+
+#ifdef    SI2177_ATV_VIDEO_MODE_PROP
+
+typedef struct { /* SI2177_ATV_VIDEO_MODE_PROP_struct */
+      unsigned char   color;
+      unsigned char   invert_signal;
+      unsigned char   trans;
+      unsigned char   video_sys;
+} si2177_atv_video_mode_prop_struct;
+
+/* ATV_VIDEO_MODE property, COLOR field definition (NO TITLE)*/
+#define  SI2177_ATV_VIDEO_MODE_PROP_COLOR_LSB                         4
+#define  SI2177_ATV_VIDEO_MODE_PROP_COLOR_MASK                      0x01
+#define  SI2177_ATV_VIDEO_MODE_PROP_COLOR_DEFAULT                0
+#define SI2177_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC               0
+#define SI2177_ATV_VIDEO_MODE_PROP_COLOR_SECAM                     1
+
+/* ATV_VIDEO_MODE property, INVERT_SIGNAL field definition (NO TITLE)*/
+#define  SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB          10
+#define  SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK       0x01
+#define  SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_DEFAULT  0
+#define SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_NORMAL     0
+#define SI2177_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_INVERTED  1
+
+/* ATV_VIDEO_MODE property, TRANS field definition (NO TITLE)*/
+#define  SI2177_ATV_VIDEO_MODE_PROP_TRANS_LSB                           8
+#define  SI2177_ATV_VIDEO_MODE_PROP_TRANS_MASK                        0x01
+#define  SI2177_ATV_VIDEO_MODE_PROP_TRANS_DEFAULT                 0
+#define SI2177_ATV_VIDEO_MODE_PROP_TRANS_TERRESTRIAL          0
+#define SI2177_ATV_VIDEO_MODE_PROP_TRANS_CABLE                       1
+
+/* ATV_VIDEO_MODE property, VIDEO_SYS field definition (NO TITLE)*/
+#define  SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB                   0
+#define  SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK                0x07
+#define  SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DEFAULT         0
+#define SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B                        0
+#define SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH                     1
+#define SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M                        2
+#define SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_N                        3
+#define SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I                         4
+#define SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK                     5
+#define SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_L                        6
+#define SI2177_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LP                      7
+
+#endif /* SI2177_ATV_VIDEO_MODE_PROP */
+
+/* SI2177 ATV_VSNR_CAP property definition */
+#define   SI2177_ATV_VSNR_CAP_PROP                                                  0x0616
+
+#ifdef    SI2177_ATV_VSNR_CAP_PROP
+
+typedef struct { /* SI2177_ATV_VSNR_CAP_PROP_struct */
+      unsigned char   atv_vsnr_cap;
+} si2177_atv_vsnr_cap_prop_struct;
+
+/* ATV_VSNR_CAP property, ATV_VSNR_CAP field definition (NO TITLE)*/
+#define  SI2177_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB                               0
+#define  SI2177_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK                            0xff
+#define  SI2177_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_DEFAULT                      0
+#define SI2177_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MIN   0
+#define SI2177_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MAX  127
+
+#endif /* SI2177_ATV_VSNR_CAP_PROP */
+
+/* SI2177 ATV_VSYNC_TRACKING property definition */
+//#define   SI2177_ATV_VSYNC_TRACKING_PROP                                                        0x0615
+
+#ifdef    SI2177_ATV_VSYNC_TRACKING_PROP
+
+typedef struct { /* SI2177_ATV_VSYNC_TRACKING_PROP_struct */
+      unsigned char   min_fields_to_unlock;
+      unsigned char   min_pulses_to_lock;
+} si2177_atv_vsync_tracking_prop_struct;
+
+/* ATV_VSYNC_TRACKING property, MIN_FIELDS_TO_UNLOCK field definition (NO TITLE)*/
+#define  SI2177_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB            8
+#define  SI2177_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK         0xff
+#define  SI2177_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_DEFAULT   16
+#define SI2177_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MIN_FIELDS_TO_UNLOCK_MIN  0
+#define SI2177_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MIN_FIELDS_TO_UNLOCK_MAX  255
+
+/* ATV_VSYNC_TRACKING property, MIN_PULSES_TO_LOCK field definition (NO TITLE)*/
+#define  SI2177_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB                0
+#define  SI2177_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK             0xff
+#define  SI2177_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_DEFAULT      4
+#define SI2177_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MIN_PULSES_TO_LOCK_MIN   0
+#define SI2177_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MIN_PULSES_TO_LOCK_MAX  9
+
+#endif /* SI2177_ATV_VSYNC_TRACKING_PROP */
+
+/* SI2177 CRYSTAL_TRIM property definition */
+#define   SI2177_CRYSTAL_TRIM_PROP                                        0x0402
+
+#ifdef    SI2177_CRYSTAL_TRIM_PROP
+
+typedef struct { /* SI2177_CRYSTAL_TRIM_PROP_struct */
+      unsigned char   xo_cap;
+} si2177_crystal_trim_prop_struct;
+
+/* CRYSTAL_TRIM property, XO_CAP field definition (NO TITLE)*/
+#define  SI2177_CRYSTAL_TRIM_PROP_XO_CAP_LSB		 0
+#define  SI2177_CRYSTAL_TRIM_PROP_XO_CAP_MASK		 0x0f
+#define  SI2177_CRYSTAL_TRIM_PROP_XO_CAP_DEFAULT	8
+ #define SI2177_CRYSTAL_TRIM_PROP_XO_CAP_4P7PF	 0
+ #define SI2177_CRYSTAL_TRIM_PROP_XO_CAP_5P2PF	 2
+ #define SI2177_CRYSTAL_TRIM_PROP_XO_CAP_5P7PF	 4
+ #define SI2177_CRYSTAL_TRIM_PROP_XO_CAP_6P2PF	 6
+ #define SI2177_CRYSTAL_TRIM_PROP_XO_CAP_6P7PF	 8
+ #define SI2177_CRYSTAL_TRIM_PROP_XO_CAP_7P2PF	 10
+ #define SI2177_CRYSTAL_TRIM_PROP_XO_CAP_7P7PF	 12
+ #define SI2177_CRYSTAL_TRIM_PROP_XO_CAP_8P2PF	 14
+
+
+/* SI2177 DTV_AGC_FREEZE_INPUT property definition */
+
+#endif /* SI2177_CRYSTAL_TRIM_PROP */
+
+/* SI2177 DTV_AGC_SPEED property definition */
+#define   SI2177_DTV_AGC_SPEED_PROP 0x0708
+
+#ifdef    SI2177_DTV_AGC_SPEED_PROP
+
+typedef struct { /* SI2177_DTV_AGC_SPEED_PROP_struct */
+      unsigned char   agc_decim;
+      unsigned char   if_agc_speed;
+} si2177_dtv_agc_speed_prop_struct;
+
+/* DTV_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+#define  SI2177_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB            8
+#define  SI2177_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK         0x03
+#define  SI2177_DTV_AGC_SPEED_PROP_AGC_DECIM_DEFAULT   0
+#define SI2177_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF             0
+#define SI2177_DTV_AGC_SPEED_PROP_AGC_DECIM_2                  1
+#define SI2177_DTV_AGC_SPEED_PROP_AGC_DECIM_4                  2
+#define SI2177_DTV_AGC_SPEED_PROP_AGC_DECIM_8                  3
+
+/* DTV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define  SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB             0
+#define  SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK          0xff
+#define  SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO            0
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39                  39
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_54                  54
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_63                  63
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_89                  89
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_105                105
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_121                121
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_137                137
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_158                158
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_172                172
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_185                185
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_196                196
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_206                206
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_216                216
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_219                219
+#define SI2177_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_222                222
+
+#endif /* SI2177_DTV_AGC_SPEED_PROP */
+
+/* SI2177 DTV_CONFIG_IF_PORT property definition */
+#define   SI2177_DTV_CONFIG_IF_PORT_PROP                                    0x0702
+
+#ifdef    SI2177_DTV_CONFIG_IF_PORT_PROP
+
+typedef struct { /* SI2177_DTV_CONFIG_IF_PORT_PROP_struct */
+      unsigned char   dtv_agc_source;
+      unsigned char   dtv_out_type;
+} si2177_dtv_config_if_port_prop_struct;
+
+/* DTV_CONFIG_IF_PORT property, DTV_AGC_SOURCE field definition (NO TITLE)*/
+#define  SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB                      8
+#define  SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK                   0x07
+#define  SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DEFAULT             0
+#define SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL            0
+    #define SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_AGC1_3DB   1
+    #define SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_AGC2_3DB   2
+
+/* DTV_CONFIG_IF_PORT property, DTV_OUT_TYPE field definition (NO TITLE)*/
+#define  SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB                            0
+#define  SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK                         0x0f
+#define  SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_DEFAULT                   0
+#define SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1                        0
+#define SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF2                        1
+#define SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF1A               4
+#define SI2177_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF2A               5
+
+#endif /* SI2177_DTV_CONFIG_IF_PORT_PROP */
+
+/* SI2177 DTV_EXT_AGC property definition */
+#define   SI2177_DTV_EXT_AGC_PROP 0x0705
+
+#ifdef    SI2177_DTV_EXT_AGC_PROP
+
+typedef struct { /* SI2177_DTV_EXT_AGC_PROP_struct */
+      unsigned char   max_10mv;
+      unsigned char   min_10mv;
+} si2177_dtv_ext_agc_prop_struct;
+
+/* DTV_EXT_AGC property, MAX_10MV field definition (NO TITLE)*/
+#define  SI2177_DTV_EXT_AGC_PROP_MAX_10MV_LSB                         8
+#define  SI2177_DTV_EXT_AGC_PROP_MAX_10MV_MASK                      0xff
+#define  SI2177_DTV_EXT_AGC_PROP_MAX_10MV_DEFAULT                250
+#define SI2177_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN      0
+#define SI2177_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX     255
+
+/* DTV_EXT_AGC property, MIN_10MV field definition (NO TITLE)*/
+#define  SI2177_DTV_EXT_AGC_PROP_MIN_10MV_LSB                          0
+#define  SI2177_DTV_EXT_AGC_PROP_MIN_10MV_MASK                       0xff
+#define  SI2177_DTV_EXT_AGC_PROP_MIN_10MV_DEFAULT                 50
+#define SI2177_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN        0
+#define SI2177_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX       255
+
+#endif /* SI2177_DTV_EXT_AGC_PROP */
+
+/* SI2177 DTV_IEN property definition */
+#define   SI2177_DTV_IEN_PROP 0x0701
+
+#ifdef    SI2177_DTV_IEN_PROP
+
+typedef struct { /* SI2177_DTV_IEN_PROP_struct */
+      unsigned char   chlien;
+} si2177_dtv_ien_prop_struct;
+
+/* DTV_IEN property, CHLIEN field definition (NO TITLE)*/
+#define  SI2177_DTV_IEN_PROP_CHLIEN_LSB                 0
+#define  SI2177_DTV_IEN_PROP_CHLIEN_MASK              0x01
+   #define  SI2177_DTV_IEN_PROP_CHLIEN_DEFAULT    1
+#define SI2177_DTV_IEN_PROP_CHLIEN_DISABLE          0
+#define SI2177_DTV_IEN_PROP_CHLIEN_ENABLE           1
+
+#endif /* SI2177_DTV_IEN_PROP */
+
+/* SI2177 DTV_INT_SENSE property definition */
+#define   SI2177_DTV_INT_SENSE_PROP 0x070a
+
+#ifdef    SI2177_DTV_INT_SENSE_PROP
+
+typedef struct { /* SI2177_DTV_INT_SENSE_PROP_struct */
+      unsigned char   chlnegen;
+      unsigned char   chlposen;
+} si2177_dtv_int_sense_prop_struct;
+
+/* DTV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+#define  SI2177_DTV_INT_SENSE_PROP_CHLNEGEN_LSB             0
+#define  SI2177_DTV_INT_SENSE_PROP_CHLNEGEN_MASK          0x01
+#define  SI2177_DTV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+#define SI2177_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE      0
+#define SI2177_DTV_INT_SENSE_PROP_CHLNEGEN_ENABLE       1
+
+/* DTV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+#define  SI2177_DTV_INT_SENSE_PROP_CHLPOSEN_LSB             8
+#define  SI2177_DTV_INT_SENSE_PROP_CHLPOSEN_MASK          0x01
+#define  SI2177_DTV_INT_SENSE_PROP_CHLPOSEN_DEFAULT    1
+#define SI2177_DTV_INT_SENSE_PROP_CHLPOSEN_DISABLE      0
+#define SI2177_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE       1
+
+#endif /* SI2177_DTV_INT_SENSE_PROP */
+
+/* SI2177 DTV_LIF_FREQ property definition */
+#define   SI2177_DTV_LIF_FREQ_PROP 0x0706
+
+#ifdef    SI2177_DTV_LIF_FREQ_PROP
+
+typedef struct { /* SI2177_DTV_LIF_FREQ_PROP_struct */
+      unsigned int    offset;
+} si2177_dtv_lif_freq_prop_struct;
+
+/* DTV_LIF_FREQ property, OFFSET field definition (NO TITLE)*/
+#define  SI2177_DTV_LIF_FREQ_PROP_OFFSET_LSB                    0
+#define  SI2177_DTV_LIF_FREQ_PROP_OFFSET_MASK                 0xffff
+#define  SI2177_DTV_LIF_FREQ_PROP_OFFSET_DEFAULT           5000
+#define SI2177_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN      0
+#define SI2177_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX     7000
+
+#endif /* SI2177_DTV_LIF_FREQ_PROP */
+
+/* SI2177 DTV_LIF_OUT property definition */
+#define   SI2177_DTV_LIF_OUT_PROP 0x0707
+
+#ifdef    SI2177_DTV_LIF_OUT_PROP
+
+typedef struct { /* SI2177_DTV_LIF_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+} si2177_dtv_lif_out_prop_struct;
+
+/* DTV_LIF_OUT property, AMP field definition (NO TITLE)*/
+#define  SI2177_DTV_LIF_OUT_PROP_AMP_LSB                8
+#define  SI2177_DTV_LIF_OUT_PROP_AMP_MASK             0xff
+#define  SI2177_DTV_LIF_OUT_PROP_AMP_DEFAULT       27
+#define SI2177_DTV_LIF_OUT_PROP_AMP_AMP_MIN        0
+#define SI2177_DTV_LIF_OUT_PROP_AMP_AMP_MAX       255
+
+/* DTV_LIF_OUT property, OFFSET field definition (NO TITLE)*/
+#define  SI2177_DTV_LIF_OUT_PROP_OFFSET_LSB                 0
+#define  SI2177_DTV_LIF_OUT_PROP_OFFSET_MASK              0xff
+#define  SI2177_DTV_LIF_OUT_PROP_OFFSET_DEFAULT        148
+#define SI2177_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MIN   0
+#define SI2177_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* SI2177_DTV_LIF_OUT_PROP */
+
+/* SI2177 DTV_MODE property definition */
+#define   SI2177_DTV_MODE_PROP 0x0703
+
+#ifdef    SI2177_DTV_MODE_PROP
+
+typedef struct { /* SI2177_DTV_MODE_PROP_struct */
+      unsigned char   bw;
+      unsigned char   invert_spectrum;
+      unsigned char   modulation;
+} si2177_dtv_mode_prop_struct;
+
+/* DTV_MODE property, BW field definition (NO TITLE)*/
+#define  SI2177_DTV_MODE_PROP_BW_LSB                      0
+#define  SI2177_DTV_MODE_PROP_BW_MASK                   0x0f
+#define  SI2177_DTV_MODE_PROP_BW_DEFAULT             8
+#define SI2177_DTV_MODE_PROP_BW_BW_6MHZ             6
+#define SI2177_DTV_MODE_PROP_BW_BW_7MHZ             7
+#define SI2177_DTV_MODE_PROP_BW_BW_8MHZ             8
+    #define SI2177_DTV_MODE_PROP_BW_BW_1P7MHZ  9
+    #define SI2177_DTV_MODE_PROP_BW_BW_6P1MHZ  10
+
+/* DTV_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+#define  SI2177_DTV_MODE_PROP_INVERT_SPECTRUM_LSB            8
+#define  SI2177_DTV_MODE_PROP_INVERT_SPECTRUM_MASK         0x01
+#define  SI2177_DTV_MODE_PROP_INVERT_SPECTRUM_DEFAULT   0
+#define SI2177_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL     0
+#define SI2177_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+/* DTV_MODE property, MODULATION field definition (NO TITLE)*/
+#define  SI2177_DTV_MODE_PROP_MODULATION_LSB            4
+#define  SI2177_DTV_MODE_PROP_MODULATION_MASK         0x0f
+#define  SI2177_DTV_MODE_PROP_MODULATION_DEFAULT   2
+#define SI2177_DTV_MODE_PROP_MODULATION_ATSC           0
+#define SI2177_DTV_MODE_PROP_MODULATION_QAM_US      1
+#define SI2177_DTV_MODE_PROP_MODULATION_DVBT           2
+#define SI2177_DTV_MODE_PROP_MODULATION_DVBC           3
+#define SI2177_DTV_MODE_PROP_MODULATION_ISDBT          4
+#define SI2177_DTV_MODE_PROP_MODULATION_ISDBC          5
+#define SI2177_DTV_MODE_PROP_MODULATION_DTMB           6
+
+#endif /* SI2177_DTV_MODE_PROP */
+
+/* SI2177 DTV_RF_TOP property definition */
+#define   SI2177_DTV_RF_TOP_PROP 0x0709
+
+#ifdef    SI2177_DTV_RF_TOP_PROP
+
+typedef struct { /* SI2177_DTV_RF_TOP_PROP_struct */
+      unsigned char   dtv_rf_top;
+} si2177_dtv_rf_top_prop_struct;
+
+/* DTV_RF_TOP property, DTV_RF_TOP field definition (NO TITLE)*/
+#define  SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB            0
+#define  SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK         0xff
+#define  SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_DEFAULT   0
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO           0
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_0DB              6
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_M1DB           7
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_M2DB           8
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_M4DB          10
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_M5DB          11
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_M6DB          12
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_M7DB          13
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_M8DB          14
+#define SI2177_DTV_RF_TOP_PROP_DTV_RF_TOP_M9DB          15
+
+#endif /* SI2177_DTV_RF_TOP_PROP */
+
+/* SI2177 DTV_RSQ_RSSI_THRESHOLD property definition */
+#define   SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP 0x0704
+
+#ifdef    SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP
+
+typedef struct { /* SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_struct */
+               char   hi;
+               char   lo;
+} si2177_dtv_rsq_rssi_threshold_prop_struct;
+
+/* DTV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+#define  SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB              8
+#define  SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK           0xff
+#define  SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT     0
+#define SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN          -128
+#define SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX        127
+
+/* DTV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+#define  SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB            0
+#define  SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK         0xff
+#define  SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT   -80
+#define SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN       -128
+#define SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX      127
+
+#endif /* SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP */
+
+/* SI2177 MASTER_IEN property definition */
+#define   SI2177_MASTER_IEN_PROP                                    0x0401
+
+#ifdef    SI2177_MASTER_IEN_PROP
+
+typedef struct { /* SI2177_MASTER_IEN_PROP_struct */
+      unsigned char   atvien;
+      unsigned char   ctsien;
+      unsigned char   dtvien;
+      unsigned char   errien;
+      unsigned char   tunien;
+} si2177_master_ien_prop_struct;
+
+/* MASTER_IEN property, ATVIEN field definition (NO TITLE)*/
+#define  SI2177_MASTER_IEN_PROP_ATVIEN_LSB            1
+#define  SI2177_MASTER_IEN_PROP_ATVIEN_MASK         0x01
+#define  SI2177_MASTER_IEN_PROP_ATVIEN_DEFAULT   0
+#define SI2177_MASTER_IEN_PROP_ATVIEN_OFF             0
+#define SI2177_MASTER_IEN_PROP_ATVIEN_ON               1
+
+/* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+#define  SI2177_MASTER_IEN_PROP_CTSIEN_LSB            7
+#define  SI2177_MASTER_IEN_PROP_CTSIEN_MASK         0x01
+#define  SI2177_MASTER_IEN_PROP_CTSIEN_DEFAULT   0
+#define SI2177_MASTER_IEN_PROP_CTSIEN_OFF             0
+#define SI2177_MASTER_IEN_PROP_CTSIEN_ON               1
+
+/* MASTER_IEN property, DTVIEN field definition (NO TITLE)*/
+#define  SI2177_MASTER_IEN_PROP_DTVIEN_LSB            2
+#define  SI2177_MASTER_IEN_PROP_DTVIEN_MASK         0x01
+#define  SI2177_MASTER_IEN_PROP_DTVIEN_DEFAULT   0
+#define SI2177_MASTER_IEN_PROP_DTVIEN_OFF             0
+#define SI2177_MASTER_IEN_PROP_DTVIEN_ON               1
+
+/* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+#define  SI2177_MASTER_IEN_PROP_ERRIEN_LSB             6
+#define  SI2177_MASTER_IEN_PROP_ERRIEN_MASK          0x01
+#define  SI2177_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+#define SI2177_MASTER_IEN_PROP_ERRIEN_OFF              0
+#define SI2177_MASTER_IEN_PROP_ERRIEN_ON                1
+
+/* MASTER_IEN property, TUNIEN field definition (NO TITLE)*/
+#define  SI2177_MASTER_IEN_PROP_TUNIEN_LSB             0
+#define  SI2177_MASTER_IEN_PROP_TUNIEN_MASK          0x01
+#define  SI2177_MASTER_IEN_PROP_TUNIEN_DEFAULT    0
+#define SI2177_MASTER_IEN_PROP_TUNIEN_OFF               0
+#define SI2177_MASTER_IEN_PROP_TUNIEN_ON                1
+
+#endif /* SI2177_MASTER_IEN_PROP */
+
+/* SI2177 TUNER_BLOCKED_VCO property definition */
+#define   SI2177_TUNER_BLOCKED_VCO_PROP                         0x0504
+
+#ifdef    SI2177_TUNER_BLOCKED_VCO_PROP
+
+typedef struct { /* SI2177_TUNER_BLOCKED_VCO_PROP_struct */
+               int    vco_code;
+} si2177_tuner_blocked_vco_prop_struct;
+
+/* TUNER_BLOCKED_VCO property, VCO_CODE field definition (NO TITLE)*/
+#define  SI2177_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB             0
+#define  SI2177_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK          0xffff
+#define  SI2177_TUNER_BLOCKED_VCO_PROP_VCO_CODE_DEFAULT    0x8000
+    #define SI2177_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MIN  -32768
+    #define SI2177_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MAX  32767
+#endif /* SI2177_TUNER_BLOCKED_VCO_PROP */
+
+/* SI2177 TUNER_IEN property definition */
+#define   SI2177_TUNER_IEN_PROP                                     0x0501
+
+#ifdef    SI2177_TUNER_IEN_PROP
+
+typedef struct { /* SI2177_TUNER_IEN_PROP_struct */
+      unsigned char   rssihien;
+      unsigned char   rssilien;
+      unsigned char   tcien;
+} si2177_tuner_ien_prop_struct;
+
+/* TUNER_IEN property, RSSIHIEN field definition (NO TITLE)*/
+#define  SI2177_TUNER_IEN_PROP_RSSIHIEN_LSB             2
+#define  SI2177_TUNER_IEN_PROP_RSSIHIEN_MASK          0x01
+#define  SI2177_TUNER_IEN_PROP_RSSIHIEN_DEFAULT    0
+#define SI2177_TUNER_IEN_PROP_RSSIHIEN_DISABLE      0
+#define SI2177_TUNER_IEN_PROP_RSSIHIEN_ENABLE       1
+
+/* TUNER_IEN property, RSSILIEN field definition (NO TITLE)*/
+#define  SI2177_TUNER_IEN_PROP_RSSILIEN_LSB             1
+#define  SI2177_TUNER_IEN_PROP_RSSILIEN_MASK          0x01
+#define  SI2177_TUNER_IEN_PROP_RSSILIEN_DEFAULT    0
+#define SI2177_TUNER_IEN_PROP_RSSILIEN_DISABLE      0
+#define SI2177_TUNER_IEN_PROP_RSSILIEN_ENABLE       1
+
+/* TUNER_IEN property, TCIEN field definition (NO TITLE)*/
+#define  SI2177_TUNER_IEN_PROP_TCIEN_LSB                    0
+#define  SI2177_TUNER_IEN_PROP_TCIEN_MASK                 0x01
+   #define  SI2177_TUNER_IEN_PROP_TCIEN_DEFAULT    1
+#define SI2177_TUNER_IEN_PROP_TCIEN_DISABLE             0
+#define SI2177_TUNER_IEN_PROP_TCIEN_ENABLE              1
+
+#endif /* SI2177_TUNER_IEN_PROP */
+
+/* SI2177 TUNER_INT_SENSE property definition */
+#define   SI2177_TUNER_INT_SENSE_PROP                          0x0505
+
+#ifdef    SI2177_TUNER_INT_SENSE_PROP
+
+typedef struct { /* SI2177_TUNER_INT_SENSE_PROP_struct */
+      unsigned char   rssihnegen;
+      unsigned char   rssihposen;
+      unsigned char   rssilnegen;
+      unsigned char   rssilposen;
+      unsigned char   tcnegen;
+      unsigned char   tcposen;
+} si2177_tuner_int_sense_prop_struct;
+
+/* TUNER_INT_SENSE property, RSSIHNEGEN field definition (NO TITLE)*/
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB             2
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK          0x01
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DEFAULT    0
+#define SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE      0
+#define SI2177_TUNER_INT_SENSE_PROP_RSSIHNEGEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, RSSIHPOSEN field definition (NO TITLE)*/
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB             10
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK          0x01
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DEFAULT    1
+#define SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DISABLE      0
+#define SI2177_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, RSSILNEGEN field definition (NO TITLE)*/
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB             1
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK          0x01
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_DEFAULT    0
+#define SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE      0
+#define SI2177_TUNER_INT_SENSE_PROP_RSSILNEGEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, RSSILPOSEN field definition (NO TITLE)*/
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB             9
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK          0x01
+#define  SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_DEFAULT    1
+#define SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_DISABLE      0
+#define SI2177_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, TCNEGEN field definition (NO TITLE)*/
+#define  SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_LSB                   0
+#define  SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_MASK               0x01
+#define  SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_DEFAULT         0
+#define SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE           0
+#define SI2177_TUNER_INT_SENSE_PROP_TCNEGEN_ENABLE            1
+
+/* TUNER_INT_SENSE property, TCPOSEN field definition (NO TITLE)*/
+#define  SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_LSB                  8
+#define  SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_MASK               0x01
+#define  SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_DEFAULT         1
+#define SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_DISABLE           0
+#define SI2177_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE            1
+
+#endif /* SI2177_TUNER_INT_SENSE_PROP */
+
+/* SI2177 TUNER_LO_INJECTION property definition */
+#define   SI2177_TUNER_LO_INJECTION_PROP                                    0x0506
+
+#ifdef    SI2177_TUNER_LO_INJECTION_PROP
+
+typedef struct { /* SI2177_TUNER_LO_INJECTION_PROP_struct */
+      unsigned char   band_1;
+      unsigned char   band_2;
+      unsigned char   band_3;
+} si2177_tuner_lo_injection_prop_struct;
+
+/* TUNER_LO_INJECTION property, BAND_1 field definition (NO TITLE)*/
+#define  SI2177_TUNER_LO_INJECTION_PROP_BAND_1_LSB              0
+#define  SI2177_TUNER_LO_INJECTION_PROP_BAND_1_MASK           0x01
+#define  SI2177_TUNER_LO_INJECTION_PROP_BAND_1_DEFAULT    1
+#define SI2177_TUNER_LO_INJECTION_PROP_BAND_1_LOW_SIDE   0
+#define SI2177_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_2 field definition (NO TITLE)*/
+#define  SI2177_TUNER_LO_INJECTION_PROP_BAND_2_LSB              1
+#define  SI2177_TUNER_LO_INJECTION_PROP_BAND_2_MASK           0x01
+#define  SI2177_TUNER_LO_INJECTION_PROP_BAND_2_DEFAULT    0
+#define SI2177_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE   0
+#define SI2177_TUNER_LO_INJECTION_PROP_BAND_2_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_3 field definition (NO TITLE)*/
+#define  SI2177_TUNER_LO_INJECTION_PROP_BAND_3_LSB              2
+#define  SI2177_TUNER_LO_INJECTION_PROP_BAND_3_MASK           0x01
+#define  SI2177_TUNER_LO_INJECTION_PROP_BAND_3_DEFAULT    0
+#define SI2177_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE   0
+#define SI2177_TUNER_LO_INJECTION_PROP_BAND_3_HIGH_SIDE  1
+
+
+#endif /* SI2177_TUNER_LO_INJECTION_PROP */
+
+/* SI2177 TUNER_RETURN_LOSS property definition */
+#define   SI2177_TUNER_RETURN_LOSS_PROP 0x0507
+
+#ifdef    SI2177_TUNER_RETURN_LOSS_PROP
+  #define SI2177_TUNER_RETURN_LOSS_PROP_CODE 0x000507
+
+
+    typedef struct { /* SI2177_TUNER_RETURN_LOSS_PROP_struct */
+      unsigned char   config;
+      unsigned char   mode;
+   } SI2177_TUNER_RETURN_LOSS_PROP_struct;
+
+   /* TUNER_RETURN_LOSS property, CONFIG field definition (NO TITLE)*/
+   #define  SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_LSB         0
+   #define  SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_MASK        0xff
+   #define  SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_DEFAULT    127
+    #define SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_75   75
+    #define SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_83   83
+    #define SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_91   91
+    #define SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_103  103
+    #define SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_115  115
+    #define SI2177_TUNER_RETURN_LOSS_PROP_CONFIG_127  127
+
+   /* TUNER_RETURN_LOSS property, MODE field definition (NO TITLE)*/
+   #define  SI2177_TUNER_RETURN_LOSS_PROP_MODE_LSB         8
+   #define  SI2177_TUNER_RETURN_LOSS_PROP_MODE_MASK        0xff
+   #define  SI2177_TUNER_RETURN_LOSS_PROP_MODE_DEFAULT    0
+    #define SI2177_TUNER_RETURN_LOSS_PROP_MODE_TERRESTRIAL  0
+    #define SI2177_TUNER_RETURN_LOSS_PROP_MODE_CABLE        1
+
+#endif /* SI2177_TUNER_RETURN_LOSS_PROP */
+
+/* SI2177 XOUT property definition */
+#define   SI2177_XOUT_PROP 0x0404
+
+#ifdef    SI2177_XOUT_PROP
+  #define SI2177_XOUT_PROP_CODE 0x000404
+
+
+    typedef struct { /* SI2177_XOUT_PROP_struct */
+      unsigned char   amp;
+   } SI2177_XOUT_PROP_struct;
+
+   /* XOUT property, AMP field definition (NO TITLE)*/
+   #define  SI2177_XOUT_PROP_AMP_LSB         0
+   #define  SI2177_XOUT_PROP_AMP_MASK        0x01
+   #define  SI2177_XOUT_PROP_AMP_DEFAULT    0
+    #define SI2177_XOUT_PROP_AMP_HIGH  0
+    #define SI2177_XOUT_PROP_AMP_LOW   1
+
+#endif /* SI2177_XOUT_PROP */
+
+
+
+  /* --------------------------------------------*/
+  /* PROPERTIES STRUCT                           */
+  /* This stores all property fields             */
+  /* --------------------------------------------*/
+  typedef struct {
+    #ifdef    SI2177_ATV_AFC_RANGE_PROP
+              si2177_atv_afc_range_prop_struct               atv_afc_range;
+    #endif /* SI2177_ATV_AFC_RANGE_PROP */
+    #ifdef    SI2177_ATV_AF_OUT_PROP
+              si2177_atv_af_out_prop_struct                     atv_af_out;
+    #endif /* SI2177_ATV_AF_OUT_PROP */
+    #ifdef    SI2177_ATV_AGC_SPEED_PROP
+              si2177_atv_agc_speed_prop_struct             atv_agc_speed;
+    #endif /* SI2177_ATV_AGC_SPEED_PROP */
+    #ifdef    SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP
+              SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP_struct        atv_agc_speed_low_rssi;
+    #endif /* SI2177_ATV_AGC_SPEED_LOW_RSSI_PROP */
+    #ifdef    SI2177_ATV_ARTIFICIAL_SNOW_PROP
+              SI2177_ATV_ARTIFICIAL_SNOW_PROP_struct           atv_artificial_snow;
+    #endif /* SI2177_ATV_ARTIFICIAL_SNOW_PROP */
+    #ifdef    SI2177_ATV_AUDIO_MODE_PROP
+              si2177_atv_audio_mode_prop_struct           atv_audio_mode;
+    #endif /* SI2177_ATV_AUDIO_MODE_PROP */
+    #ifdef    SI2177_ATV_CONFIG_IF_PORT_PROP
+              SI2177_ATV_CONFIG_IF_PORT_PROP_struct            atv_config_if_port;
+    #endif /* SI2177_ATV_CONFIG_IF_PORT_PROP */
+    #ifdef    SI2177_ATV_CVBS_OUT_PROP
+              si2177_atv_cvbs_out_prop_struct                atv_cvbs_out;
+    #endif /* SI2177_ATV_CVBS_OUT_PROP */
+    #ifdef    SI2177_ATV_CVBS_OUT_FINE_PROP
+              si2177_atv_cvbs_out_fine_prop_struct        atv_cvbs_out_fine;
+    #endif /* SI2177_ATV_CVBS_OUT_FINE_PROP */
+    #ifdef    SI2177_ATV_HSYNC_OUT_PROP
+              SI2177_ATV_HSYNC_OUT_PROP_struct                 atv_hsync_out;
+    #endif /* SI2177_ATV_HSYNC_OUT_PROP */
+    #ifdef    SI2177_ATV_IEN_PROP
+              si2177_atv_ien_prop_struct                         atv_ien;
+    #endif /* SI2177_ATV_IEN_PROP */
+    #ifdef    SI2177_ATV_INT_SENSE_PROP
+              si2177_atv_int_sense_prop_struct              atv_int_sense;
+    #endif /* SI2177_ATV_INT_SENSE_PROP */
+    #ifdef    SI2177_ATV_PGA_TARGET_PROP
+              SI2177_ATV_PGA_TARGET_PROP_struct                atv_pga_target;
+    #endif /* SI2177_ATV_PGA_TARGET_PROP */
+    #ifdef    SI2177_ATV_RF_TOP_PROP
+              si2177_atv_rf_top_prop_struct                    atv_rf_top;
+    #endif /* SI2177_ATV_RF_TOP_PROP */
+    #ifdef    SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP
+              si2177_atv_rsq_rssi_threshold_prop_struct  atv_rsq_rssi_threshold;
+    #endif /* SI2177_ATV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef    SI2177_ATV_RSQ_SNR_THRESHOLD_PROP
+              si2177_atv_rsq_snr_threshold_prop_struct   atv_rsq_snr_threshold;
+    #endif /* SI2177_ATV_RSQ_SNR_THRESHOLD_PROP */
+    #ifdef    SI2177_ATV_SIF_OUT_PROP
+              si2177_atv_sif_out_prop_struct                    atv_sif_out;
+    #endif /* SI2177_ATV_SIF_OUT_PROP */
+    #ifdef    SI2177_ATV_SOUND_AGC_LIMIT_PROP
+              si2177_atv_sound_agc_limit_prop_struct           atv_sound_agc_limit;
+    #endif /* SI2177_ATV_SOUND_AGC_LIMIT_PROP */
+    #ifdef    SI2177_ATV_SOUND_AGC_SPEED_PROP
+              si2177_atv_sound_agc_speed_prop_struct           atv_sound_agc_speed;
+    #endif /* SI2177_ATV_SOUND_AGC_SPEED_PROP */
+    #ifdef    SI2177_ATV_VIDEO_EQUALIZER_PROP
+              si2177_atv_video_equalizer_prop_struct           atv_video_equalizer;
+    #endif /* SI2177_ATV_VIDEO_EQUALIZER_PROP */
+
+    #ifdef    SI2177_ATV_VIDEO_MODE_PROP
+              si2177_atv_video_mode_prop_struct           atv_video_mode;
+    #endif /* SI2177_ATV_VIDEO_MODE_PROP */
+    #ifdef    SI2177_ATV_VSNR_CAP_PROP
+              si2177_atv_vsnr_cap_prop_struct                atv_vsnr_cap;
+    #endif /* SI2177_ATV_VSNR_CAP_PROP */
+    #ifdef    SI2177_CRYSTAL_TRIM_PROP
+              si2177_crystal_trim_prop_struct                  crystal_trim;
+    #endif /* SI2177_CRYSTAL_TRIM_PROP */
+    #ifdef    SI2177_DTV_AGC_SPEED_PROP
+              si2177_dtv_agc_speed_prop_struct            dtv_agc_speed;
+    #endif /* SI2177_DTV_AGC_SPEED_PROP */
+    #ifdef    SI2177_DTV_CONFIG_IF_PORT_PROP
+              si2177_dtv_config_if_port_prop_struct        dtv_config_if_port;
+    #endif /* SI2177_DTV_CONFIG_IF_PORT_PROP */
+    #ifdef    SI2177_DTV_EXT_AGC_PROP
+              si2177_dtv_ext_agc_prop_struct                 dtv_ext_agc;
+    #endif /* SI2177_DTV_EXT_AGC_PROP */
+    #ifdef    SI2177_DTV_IEN_PROP
+              si2177_dtv_ien_prop_struct                        dtv_ien;
+    #endif /* SI2177_DTV_IEN_PROP */
+    #ifdef    SI2177_DTV_INT_SENSE_PROP
+              si2177_dtv_int_sense_prop_struct              dtv_int_sense;
+    #endif /* SI2177_DTV_INT_SENSE_PROP */
+    #ifdef    SI2177_DTV_LIF_FREQ_PROP
+              si2177_dtv_lif_freq_prop_struct                   dtv_lif_freq;
+    #endif /* SI2177_DTV_LIF_FREQ_PROP */
+    #ifdef    SI2177_DTV_LIF_OUT_PROP
+              si2177_dtv_lif_out_prop_struct                    dtv_lif_out;
+    #endif /* SI2177_DTV_LIF_OUT_PROP */
+    #ifdef    SI2177_DTV_MODE_PROP
+              si2177_dtv_mode_prop_struct                     dtv_mode;
+    #endif /* SI2177_DTV_MODE_PROP */
+    #ifdef    SI2177_DTV_RF_TOP_PROP
+              si2177_dtv_rf_top_prop_struct                     dtv_rf_top;
+    #endif /* SI2177_DTV_RF_TOP_PROP */
+    #ifdef    SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP
+              si2177_dtv_rsq_rssi_threshold_prop_struct  dtv_rsq_rssi_threshold;
+    #endif /* SI2177_DTV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef    SI2177_MASTER_IEN_PROP
+              si2177_master_ien_prop_struct                    master_ien;
+    #endif /* SI2177_MASTER_IEN_PROP */
+    #ifdef    SI2177_TUNER_BLOCKED_VCO_PROP
+              si2177_tuner_blocked_vco_prop_struct       tuner_blocked_vco;
+    #endif /* SI2177_TUNER_BLOCKED_VCO_PROP */
+    #ifdef    SI2177_TUNER_IEN_PROP
+              si2177_tuner_ien_prop_struct                      tuner_ien;
+    #endif /* SI2177_TUNER_IEN_PROP */
+    #ifdef    SI2177_TUNER_INT_SENSE_PROP
+              si2177_tuner_int_sense_prop_struct            tuner_int_sense;
+    #endif /* SI2177_TUNER_INT_SENSE_PROP */
+    #ifdef    SI2177_TUNER_LO_INJECTION_PROP
+              si2177_tuner_lo_injection_prop_struct         tuner_lo_injection;
+    #endif /* SI2177_TUNER_LO_INJECTION_PROP */
+    #ifdef    SI2177_TUNER_RETURN_LOSS_PROP
+              SI2177_TUNER_RETURN_LOSS_PROP_struct             tuner_return_loss;
+    #endif /* SI2177_TUNER_RETURN_LOSS_PROP */
+    #ifdef    SI2177_XOUT_PROP
+              SI2177_XOUT_PROP_struct                          xout;
+    #endif /* SI2177_XOUT_PROP */
+} si2177_propobj_t;
+/* _properties_struct_insertion_point */
+
+typedef struct si2177_device_s{
+    struct class *clsp;
+    struct i2c_client tuner_client;
+    si2177_common_reply_struct si_common_reply;
+    si2177_propobj_t     si_prop;
+    si2177_cmdreplyobj_t si_cmd_reply;
+    struct analog_parameters parm;
+    int fre_offset;
+}si2177_device_t;
+
+int si2177_init(struct i2c_client *si2177, si2177_cmdreplyobj_t *rsp, si2177_common_reply_struct *common_reply);
+//int si2177_powerupwithpatch(struct i2c_client *si2177, si2177_cmdreplyobj_t *rsp, si2177_common_reply_struct *common_reply);
+//int si2177_loadfirmware(struct i2c_client *si2177, unsigned char* firmwaretable, int lines, si2177_common_reply_struct *common_reply);
+//int si2177_startfirmware(struct i2c_client *si2177, si2177_cmdreplyobj_t *rsp, si2177_common_reply_struct *common_reply);
+int si2177_configure(struct i2c_client *si2177, si2177_propobj_t *prop, si2177_cmdreplyobj_t *rsp, si2177_common_reply_struct *common_reply);
+//int si2177_loadvideofilter(struct i2c_client *si2177, unsigned char* vidfilttable, int lines, si2177_common_reply_struct *common_reply);
+int si2177_tune(struct i2c_client *si2177, unsigned char mode, unsigned long freq, si2177_cmdreplyobj_t *rsp, si2177_common_reply_struct *common_reply);
+int si2177_atvconfig(struct i2c_client *si2177, si2177_propobj_t *prop, si2177_cmdreplyobj_t *rsp);
+int si2177_dtvconfig(struct i2c_client *si2177, si2177_propobj_t *prop, si2177_cmdreplyobj_t *rsp);
+//int si2177_tunerconfig(struct i2c_client *si2177, si2177_propobj_t *prop, si2177_cmdreplyobj_t *rsp);
+//int si2177_setuptunerdefaults(si2177_propobj_t *prop);
+//int si2177_setupcommondefaults(si2177_propobj_t *prop);
+//int si2177_setupatvdefaults(si2177_propobj_t *prop);
+unsigned char si2177_atv_status(struct i2c_client *si2177, unsigned char intack, si2177_cmdreplyobj_t *rsp);
+unsigned char si2177_tuner_status(struct i2c_client *si2177, unsigned char intack, si2177_cmdreplyobj_t *rsp);
+unsigned char si2177_power_down(struct i2c_client *si2177, si2177_cmdreplyobj_t *rsp);
+unsigned char si2177_fine_tune(struct i2c_client *si2177, unsigned char  persistence,unsigned char   apply_to_lif,int offset_500hz, si2177_cmdreplyobj_t *rsp);
+unsigned char si2177_atv_restart(struct i2c_client *si2177, unsigned char   mode,  si2177_cmdreplyobj_t *rsp);
+unsigned char si2177_dtv_restart(struct i2c_client *si2177, si2177_cmdreplyobj_t *rsp);
+unsigned char si2177_set_property(struct i2c_client *si2177,unsigned char   reserved, unsigned int prop, unsigned int data,  si2177_cmdreplyobj_t *rsp);
+unsigned char si2177_get_property(struct i2c_client *si2177, unsigned char   reserved,unsigned int  prop, si2177_cmdreplyobj_t *rsp);
+unsigned char si2177_config_clocks  (struct i2c_client *si2177,unsigned char  subcode,unsigned char clock_mode,unsigned char en_xout,si2177_cmdreplyobj_t *rsp);
+
+
+#endif /* __SLI2177_FUN_H */
diff --git a/drivers/amlogic/dvb_tv/si2196/Makefile b/drivers/amlogic/dvb_tv/si2196/Makefile
new file mode 100755
index 000000000000..b1ca2d251f7e
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2196/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_AM_SI2196) += si2196_fe.o
+
+si2196_fe-objs =si2196_func.o si2196_frontend.o
diff --git a/drivers/amlogic/dvb_tv/si2196/si2196_frontend.c b/drivers/amlogic/dvb_tv/si2196/si2196_frontend.c
new file mode 100755
index 000000000000..205871497fdc
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2196/si2196_frontend.c
@@ -0,0 +1,907 @@
+/*
+ * Silicon labs si2196 Tuner Device Driver
+ *
+ * Author: Bobby Yang <bo.yang@amlogic.com>
+ *
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/* Standard Liniux Headers */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/dvb/frontend.h>
+
+/* Local Headers */
+#include "../aml_fe.h"
+#include "si2196_func.h"
+
+
+#define SI2196_TUNER_I2C_NAME           "si2196_tuner_i2c"
+#define TUNER_DEVICE_NAME                 "si2196"
+
+static unsigned int si2196_debug = 0;
+module_param(si2196_debug,uint,0664);
+MODULE_PARM_DESC(si2196_debug,"\nenable print the lock state and tuner status\n");
+#define siprintk   if(si2196_debug) printk
+struct si2196_device_s *si2196_devp;
+#define ERROR   1
+/************************************************************************************************************************/
+/** globals for Top Level routine */
+static void si2196_set_frequency(unsigned int freq);
+static ssize_t si2196_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
+{
+    int n = 0;
+    unsigned char ret =0;
+    char *buf_orig, *ps, *token;
+    char *parm[4];
+    unsigned int addr = 0, val = 0;
+    buf_orig = kstrdup(buf, GFP_KERNEL);
+    ps = buf_orig;
+    while (1) {
+        token = strsep(&ps, " \n");
+        if (token == NULL)
+            break;
+        if (*token == '\0')
+            continue;
+        parm[n++] = token;
+    }
+
+    if (!strncmp(parm[0],"rs",strlen("rs")))
+    {
+        if (n != 2)
+        {
+            pr_err("read: invalid parameter\n");
+            kfree(buf_orig);
+            return count;
+        }
+        addr = simple_strtol(parm[1], NULL, 16);
+        printk("%s 0x%x\n", parm[0], addr);
+        si2196_get_property(&si2196_devp->tuner_client,0, addr, &si2196_devp->si_cmd_reply);
+        printk("%s: 0x%x --> 0x%x\n", parm[0], addr, si2196_devp->si_cmd_reply.get_property.data);
+    }
+    else if (!strncmp(parm[0],"ws",strlen("ws")))
+    {
+        addr = simple_strtol(parm[1], NULL, 16);
+        val  = simple_strtol(parm[2], NULL, 16);
+        printk("%s 0x%x 0x%x", parm[0], addr, val);
+        si2196_set_property(&si2196_devp->tuner_client, 0, addr,val, &si2196_devp->si_cmd_reply);
+        printk("%s: 0x%x <-- 0x%x\n", parm[0], addr, val);
+    }
+    else if(!strcmp(parm[0],"tune"))
+    {
+        val = simple_strtol(parm[1], NULL, 10);
+        si2196_set_frequency(val);
+    }
+    else if(!strcmp(parm[0],"tuner_status"))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client,SI2196_TUNER_STATUS_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+        if(!ret)
+        {
+            pr_info("tuner_status 0x%x",SI2196_TUNER_STATUS_CMD);
+            pr_info("tcint %u,rssilint %u,rssihint %u,vco_code %d,tc %u,rssil %u,rssih %u,rssi %d,freq %u,mode %u.\n",\
+            si2196_devp->si_cmd_reply.tuner_status.tcint, si2196_devp->si_cmd_reply.tuner_status.rssilint, si2196_devp->si_cmd_reply.tuner_status.rssihint,\
+            si2196_devp->si_cmd_reply.tuner_status.vco_code, si2196_devp->si_cmd_reply.tuner_status.tc,si2196_devp->si_cmd_reply.tuner_status.rssil,\
+            si2196_devp->si_cmd_reply.tuner_status.rssih, si2196_devp->si_cmd_reply.tuner_status.rssi,si2196_devp->si_cmd_reply.tuner_status.freq,\
+            si2196_devp->si_cmd_reply.tuner_status.mode);
+        }
+    }
+    else if(!strncmp(parm[0],"atv_status",strlen("atv_status")))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client, SI2196_ATV_STATUS_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+        if(!ret)
+        {
+            printk("atv_status 0x%x",SI2196_ATV_STATUS_CMD);
+            pr_info("audio_chan_bw %u,chl %u,pcl %u,dl %u, snrl %u,snrh %u,video_snr %u,"\
+                        "afc_freq %d,video_sc_spacing %d,video_sys %u,color %u, audio_sys %u\n",\
+            si2196_devp->si_cmd_reply.atv_status.audio_chan_bw,si2196_devp->si_cmd_reply.atv_status.chl,\
+            si2196_devp->si_cmd_reply.atv_status.pcl, si2196_devp->si_cmd_reply.atv_status.dl, si2196_devp->si_cmd_reply.atv_status.snrl,\
+            si2196_devp->si_cmd_reply.atv_status.snrh, si2196_devp->si_cmd_reply.atv_status.video_snr, si2196_devp->si_cmd_reply.atv_status.afc_freq, \
+            si2196_devp->si_cmd_reply.atv_status.video_sc_spacing, si2196_devp->si_cmd_reply.atv_status.video_sys, si2196_devp->si_cmd_reply.atv_status.color, \
+            si2196_devp->si_cmd_reply.atv_status.audio_sys);
+        }
+    }
+    else if(!strncmp(parm[0],"atv_restart",strlen("atv_restart")))
+    {
+        si2196_sendcommand(&si2196_devp->tuner_client, SI2196_ATV_RESTART_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+    }
+    else if(!strncmp(parm[0],"sd_afc",strlen("sd_afc")))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client, SI2196_SD_AFC_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+        if(!ret)
+            pr_info("sd_afc 0x%x,afc %d.\n",SI2196_SD_AFC_CMD,si2196_devp->si_cmd_reply.sd_afc.afc);
+    }
+    else if(!strncmp(parm[0],"sd_carrier_cnr",strlen("sd_carrier_cnr")))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client, SI2196_SD_CARRIER_CNR_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+        if(!ret)
+            pr_info("sd_carrier_cnr 0x%x primary %u, secondary %u.\n",SI2196_SD_CARRIER_CNR_CMD,si2196_devp->si_cmd_reply.sd_carrier_cnr.primary,si2196_devp->si_cmd_reply.sd_carrier_cnr.secondary);
+    }
+    else if(!strncmp(parm[0],"sd_casd",strlen("sd_casd")))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client, SI2196_SD_CASD_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+        if(!ret)
+            pr_info("sd_casd 0x%x -->casd %u.\n",SI2196_SD_CASD_CMD, si2196_devp->si_cmd_reply.sd_casd.casd);
+    }
+    else if(!strncmp(parm[0],"sd_dual_mono_id_lvl",strlen("sd_dual_mono_id_lvl")))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client, SI2196_SD_DUAL_MONO_ID_LVL_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+        if(!ret)
+            pr_info("sd_dual_mono_id_lvl 0x%x id_lvl %u.\n",SI2196_SD_DUAL_MONO_ID_LVL_CMD, si2196_devp->si_cmd_reply.sd_dual_mono_id_lvl.id_lvl);
+    }
+    else if(!strncmp(parm[0],"sd_nicam_status",strlen("sd_nicam_status")))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client, SI2196_SD_NICAM_STATUS_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+        if(!ret)
+        {
+            pr_info("sd_nicam_status 0x%x. ",SI2196_SD_NICAM_STATUS_CMD);
+            pr_info("errors %u,locked %u, mode %u,mono_backup %u,rss %u.\n",si2196_devp->si_cmd_reply.sd_nicam_status.errors,\
+                si2196_devp->si_cmd_reply.sd_nicam_status.locked,si2196_devp->si_cmd_reply.sd_nicam_status.mode,\
+                si2196_devp->si_cmd_reply.sd_nicam_status.mono_backup,si2196_devp->si_cmd_reply.sd_nicam_status.rss);
+        }
+
+    }
+    else if(!strncmp(parm[0],"sd_status",strlen("sd_status")))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client, SI2196_SD_STATUS_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+        if(!ret)
+        {
+            pr_info("sd_status 0x%x. ",SI2196_SD_STATUS_CMD);
+            pr_info("afcm %u,afcmint %u,agcs %u,agcsint %u,asdc %u,asdcint %u,nicam %u,nicamint %u,odm %u,"\
+                "odmint %u,over_dev %u,pcm %u,pcmint %u,sap_detected %u,scm %u,scmint %u,sd_agc %u,sif_agc %u,"\
+                "sound_mode_detected %u,sound_system_detected %u,sd_status_int %u.\n",
+                si2196_devp->si_cmd_reply.sd_status.afcm,si2196_devp->si_cmd_reply.sd_status.afcmint,si2196_devp->si_cmd_reply.sd_status.agcs,\
+                si2196_devp->si_cmd_reply.sd_status.agcsint,si2196_devp->si_cmd_reply.sd_status.asdc,si2196_devp->si_cmd_reply.sd_status.asdcint,\
+                si2196_devp->si_cmd_reply.sd_status.nicam,si2196_devp->si_cmd_reply.sd_status.nicamint,si2196_devp->si_cmd_reply.sd_status.odm,\
+                si2196_devp->si_cmd_reply.sd_status.odmint,si2196_devp->si_cmd_reply.sd_status.over_dev,si2196_devp->si_cmd_reply.sd_status.pcm,\
+                si2196_devp->si_cmd_reply.sd_status.pcmint,si2196_devp->si_cmd_reply.sd_status.sap_detected,si2196_devp->si_cmd_reply.sd_status.scm, \
+                si2196_devp->si_cmd_reply.sd_status.scmint,si2196_devp->si_cmd_reply.sd_status.sd_agc,si2196_devp->si_cmd_reply.sd_status.sif_agc,\
+                si2196_devp->si_cmd_reply.sd_status.sound_mode_detected,si2196_devp->si_cmd_reply.sd_status.sound_system_detected,si2196_devp->si_cmd_reply.sd_status.ssint);
+        }
+    }
+    else if(!strncmp(parm[0],"sd_stereo_id_lvl",strlen("sd_stereo_id_lvl")))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client, SI2196_SD_STEREO_ID_LVL_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+        if(!ret)
+            pr_info("sd_stereo_id_lvl 0x%x id_lvl %u.\n",SI2196_SD_STEREO_ID_LVL_CMD,si2196_devp->si_cmd_reply.sd_stereo_id_lvl.id_lvl);
+    }
+    else if(!strncmp(parm[0],"adac_powerup",strlen("adac_powerup")))
+    {
+        ret = si2196_sendcommand(&si2196_devp->tuner_client, SI2196_SD_ADAC_POWER_UP_CMD, &si2196_devp->si_cmd, &si2196_devp->si_cmd_reply);
+    }
+    else
+        pr_err("invalid command\n");
+
+    kfree(buf_orig);
+    return count;
+}
+static ssize_t si2196_show(struct class *cls, struct class_attribute *attr,char *buff)
+{
+    size_t len = 0;
+
+    return len;
+}
+static CLASS_ATTR(si2196_debug,0644,si2196_show,si2196_store);
+
+/* ---------------------------------------------------------------------- */
+
+static int si2196_get_rf_strength(struct dvb_frontend *fe, u16 *strength)
+{
+    if(!strength)
+        printk("[si2196..]%s null pointer error.\n",__func__);
+    if(si2196_tuner_status(&si2196_devp->tuner_client, 1, &si2196_devp->si_cmd_reply))
+    {
+        printk("[si2196..] %s si2196_tuner_status error.\n",__func__);
+        return -ERROR;
+    }
+    *strength = si2196_devp->si_cmd_reply.tuner_status.rssi;
+    return 0;
+}
+static int si2196_get_tuner_status(struct dvb_frontend *fe, tuner_status_t*tuner_status)
+{
+    struct tuner_status_s*tmp_status = NULL;
+    si2196_cmdreplyobj_t  *si_cmd_reply = &si2196_devp->si_cmd_reply;
+    if(!tuner_status)
+    {
+        printk("[si2196..] %s null pointer error.\n",__func__);
+        return -ERROR;
+    }
+    //intack = 1 (SI2196_TUNER_STATUS_CMD_INTACK_CLEAR)
+    if(si2196_tuner_status(&si2196_devp->tuner_client, 1, si_cmd_reply))
+    {
+        printk("[si2196..] %s si2196 get tuner status error.\n",__func__);
+        return -ERROR;
+    }
+    tmp_status = (struct tuner_status_s *)tuner_status;
+    tmp_status->frequency = si_cmd_reply->tuner_status.freq;
+    tmp_status->mode        = si_cmd_reply->tuner_status.mode;
+    tmp_status->rssi           = si_cmd_reply->tuner_status.rssi;
+    siprintk("[si2196..]%s rssi %d.threshold <%d.%d>.\n",__func__,si_cmd_reply->tuner_status.rssi,
+                    si_cmd_reply->tuner_status.rssil,si_cmd_reply->tuner_status.rssih);
+    if(si_cmd_reply->tuner_status.rssih ||si_cmd_reply->tuner_status.rssil)
+        tmp_status->tuner_locked = 0;
+    else
+        tmp_status->tuner_locked = 1;
+    return 0;
+
+}
+static int  si2196_tuner_fine_tune(struct dvb_frontend *fe, int offset_500hz)
+{
+    si2196_devp->si_cmd.fine_tune.offset_500hz = offset_500hz;
+    siprintk("[si2196..]%s fine offset %d.\n",__func__,offset_500hz);
+    if(si2196_sendcommand(&si2196_devp->tuner_client, SI2196_FINE_TUNE_CMD, &si2196_devp->si_cmd,&si2196_devp->si_cmd_reply)!=0)
+    {
+        pr_info("[si2196..]%s: si2196 fine tune error.\n",__func__);
+        return -ERROR;
+    }
+    return 0;
+}
+/*static void si2196_set_mode(void)
+{
+    unsigned short mode = SI2196_DTV_MODE_PROP_MODULATION_MASK;
+    switch(si2196_devp->parm.mode)
+    {
+        case AM_FE_QPSK:
+            mode = SI2196_DTV_MODE_PROP_MODULATION_ISDBT;
+            break;
+        case AM_FE_QAM:
+            mode = SI2196_DTV_MODE_PROP_MODULATION_DVBC;
+            break;
+	case AM_FE_OFDM:
+            mode = SI2196_DTV_MODE_PROP_MODULATION_DVBT;
+            break;
+        case AM_FE_ATSC:
+            mode = SI2196_DTV_MODE_PROP_MODULATION_ATSC;
+            break;
+	case AM_FE_ANALOG:
+            mode = SI2196_DTV_MODE_PROP_MODULATION_DEFAULT;
+            break;
+        default:
+            printk("[si2196..] %s no mode to match %d.\n",__func__, mode);
+            break;
+    }
+    //default bandwidth 8M 3->SI2196_DTV_MODE_PROP
+    if(si2196_set_property(&si2196_devp->tuner_client, 0, 0x703, mode<<4|8, &si2196_devp->si_cmd_reply))
+        printk("[si2196..] %s mode %d si2196_set_property error.",__func__, mode);
+}*/
+static void si2196_set_frequency(unsigned int freq)
+{
+    int ret = 0;
+    /*tune the tuner*/
+    ret = si2196_tune(&si2196_devp->tuner_client, 1, freq, &si2196_devp->si_cmd_reply);
+    if(ret)
+        printk("[si2196..]%s: set frequency error.\n", __func__);
+}
+static void si2196_set_soundsys(void)
+{
+    unsigned char ret = 0;
+    //SI2196_SD_SOUND_SYSTEM_PROP ->0xd04
+    ret = si2196_set_property(&si2196_devp->tuner_client,0, 0xd04, si2196_devp->parm.soundsys, &si2196_devp->si_cmd_reply);
+    if(ret)
+        printk("[si2196..]%s: set sound system error.\n", __func__);
+}
+static void si2196_set_audmode(void)
+{
+    unsigned char ret = 0;
+    //SI2196_SD_SOUND_MODE_PROP ->0xd05
+    ret = si2196_set_property(&si2196_devp->tuner_client,0, 0xd05, si2196_devp->sparm.sound_mode, &si2196_devp->si_cmd_reply);
+    if(ret)
+        printk("[si2196..]%s: set sound mode error.\n", __func__);
+}
+static void si2196_set_lang(void)
+{
+    unsigned char ret = 0;
+    //SI2196_SD_LANG_SELECT_PROP ->0xd07
+    ret = si2196_set_property(&si2196_devp->tuner_client,0, 0xd07, si2196_devp->sparm.lang, &si2196_devp->si_cmd_reply);
+    if(ret)
+        printk("[si2196..]%s: set sound lang error.\n", __func__);
+}
+static void si2196_set_std(void)
+{
+    v4l2_std_id ptstd = si2196_devp->parm.std;
+    unsigned char color_mode=0, video_sys=0, ret=0;
+    /*set color standard of atv*/
+   if (ptstd & (V4L2_COLOR_STD_PAL | V4L2_COLOR_STD_NTSC))
+        color_mode = SI2196_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC;
+    else if (ptstd & (V4L2_COLOR_STD_SECAM))
+        color_mode = SI2196_ATV_VIDEO_MODE_PROP_COLOR_SECAM;
+
+    /* set audio standard of tuner*/
+    if (ptstd & V4L2_STD_B)
+    {
+        video_sys = SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B;
+        si2196_devp->sparm.fre_offset = 2250000;
+    }
+    else if (ptstd & V4L2_STD_GH)
+    {
+        video_sys = SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH;
+        si2196_devp->sparm.fre_offset = 2250000;
+    }
+    else if ((ptstd & V4L2_STD_NTSC) || ((ptstd & V4L2_STD_PAL_M)))
+    {
+        video_sys = SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M;
+        si2196_devp->sparm.fre_offset = 1750000;
+    }
+    else if (ptstd & (V4L2_STD_PAL_N | V4L2_STD_PAL_Nc))
+    {
+        video_sys = SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_N;
+        si2196_devp->sparm.fre_offset = 1750000;
+    }
+    else if (ptstd & V4L2_STD_PAL_I)
+    {
+        video_sys = SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I;
+        si2196_devp->sparm.fre_offset = 2750000;
+    }
+    else if (ptstd & V4L2_STD_DK)
+    {
+        video_sys = SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK;
+        si2196_devp->sparm.fre_offset = 2750000;
+    }
+    else if (ptstd & V4L2_STD_SECAM_L)
+    {
+        video_sys = SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_L;
+        si2196_devp->sparm.fre_offset = 2750000;
+    }
+    else if (ptstd & V4L2_STD_SECAM_LC)
+    {
+        video_sys = SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LP;
+        si2196_devp->sparm.fre_offset = 2750000;
+    }
+
+    ret = si2196_set_property(&si2196_devp->tuner_client, 0, 0x604, color_mode<<4|video_sys, &si2196_devp->si_cmd_reply);
+    if(ret)
+        printk("[si2196..]%s:set std %ul error\n",__func__, (uint)ptstd);
+    siprintk("[si2196..]%s: color %s,video_mode.video_sys:%s. fre_offset is %d.\n", __func__, v4l2_std_to_str(si2196_devp->parm.std&0xffffff),
+                v4l2_std_to_str(si2196_devp->parm.std&0xff000000) ,si2196_devp->sparm.fre_offset);
+    if(si2196_atv_restart(&si2196_devp->tuner_client, 0,  &si2196_devp->si_cmd_reply))
+        printk("[si2196..]%s: atv restart error.\n", __func__);
+}
+
+static int si2196_set_params(struct dvb_frontend *fe, struct dvb_frontend_parameters *parm)
+{
+	int strength;
+   	if(FE_ANALOG==fe->ops.info.type){
+    		if(si2196_devp->parm.soundsys  != parm->u.analog.soundsys)
+    		{
+        		if(parm->u.analog.soundsys == V4L2_TUNER_SYS_NULL)
+            			//SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_AUTODETECT = 15
+           	 		si2196_devp->parm.soundsys = 15;
+        		else
+            			si2196_devp->parm.soundsys  = parm->u.analog.soundsys;
+        		siprintk("[si2196l..]%s set sound sys %s.\n",__func__,soundsys_to_str(si2196_devp->parm.soundsys));
+        		si2196_set_soundsys();
+    		}
+    		else if(si2196_devp->parm.std  != parm->u.analog.std)
+    		{
+        		si2196_devp->parm.std  = parm->u.analog.std;
+        		si2196_set_std();
+    		}
+    		else if(si2196_devp->parm.frequency  != parm->frequency)
+    		{
+        		si2196_devp->parm.frequency  = parm->frequency;
+        		si2196_set_frequency(si2196_devp->parm.frequency + si2196_devp->sparm.fre_offset);
+    		}
+    		else if(si2196_devp->parm.audmode != parm->u.analog.audmode)
+    		{
+        		si2196_devp->parm.audmode = parm->u.analog.audmode;
+       	 		switch(si2196_devp->parm.audmode)
+        		{
+            		case V4L2_TUNER_AUDMODE_NULL:
+                		//SI2196_SD_SOUND_MODE_PROP_MODE_AUTODETECT = 0
+                		si2196_devp->sparm.sound_mode = 0;
+                		break;
+            		case V4L2_TUNER_MODE_MONO:
+                		//SI2196_SD_SOUND_MODE_PROP_MODE_MONO = 1
+                		si2196_devp->sparm.sound_mode = 1;
+                		break;
+           		case V4L2_TUNER_MODE_STEREO:
+               			 //SI2196_SD_SOUND_MODE_PROP_MODE_STREO = 3
+                		si2196_devp->sparm.sound_mode = 3;
+                		break;
+            		case V4L2_TUNER_MODE_LANG2:
+            		case V4L2_TUNER_MODE_SAP:
+                		//SI2196_SD_LANG_SELECT_PROP_LANG_LANG_B
+               			 si2196_devp->sparm.lang = 1;
+                		break;
+            		case V4L2_TUNER_MODE_LANG1:
+               		 	//SI2196_SD_LANG_SELECT_PROP_LANG_LANG_A
+                		si2196_devp->sparm.lang = 0;
+                		break;
+           		case V4L2_TUNER_MODE_LANG1_LANG2:
+                		//SI2196_SD_SOUND_MODE_PROP_MODE_DUAL_MONO = 2
+                		si2196_devp->sparm.sound_mode = 2;
+                		//SI2196_SD_LANG_SELECT_PROP_LANG_DUAL_MONO = 2
+                		si2196_devp->sparm.lang = 2;
+                		break;
+            		default:
+                		break;
+        		}
+        		siprintk("[si2196..]%s set audmode %s.\n",__func__,audmode_to_str(si2196_devp->parm.audmode));
+       	 		si2196_set_lang();
+        		si2196_set_audmode();
+    		}
+ 			 /*  else if(si2196_devp->parm.std  != parm->u.analog.std)
+   			 {
+      			  si2196_devp->parm.std  = parm->u.analog.std;
+       		 	si2196_set_std();
+   			 }*/
+    		else
+    		{
+        		printk("[si2196..] %s no case catch error.\n",__func__);
+    		}
+   	}
+   	else{
+   		if(FE_QAM==fe->ops.info.type){
+			if(QAM_128==parm->u.qam.modulation){
+				si2196_devp->si_prop.dtv_lif_out.amp = 22;
+				if(si2196_set_property(&si2196_devp->tuner_client, 0, 0x707, 22, &si2196_devp->si_cmd_reply))
+					printk("[si2196..]%s set dtv lif out amp 22 error.\n",__func__);
+			}
+			else{
+				si2196_devp->si_prop.dtv_lif_out.amp = 25;
+				if(si2196_set_property(&si2196_devp->tuner_client, 0, 0x707, 25, &si2196_devp->si_cmd_reply))
+					printk("[si2196...]%s set dtv lif out amp 25 error.\n",__func__);
+			}
+		}
+		si2196_devp->parm.frequency = parm->frequency;
+		si2196_set_frequency(si2196_devp->parm.frequency);
+		printk("[si2196..]%s set frequency %u.\n",__func__,si2196_devp->parm.frequency);
+		msleep(500);
+		strength=100;
+		if(si2196_tuner_status(&si2196_devp->tuner_client,
+							SI2196_ATV_STATUS_CMD_INTACK_OK,
+							&si2196_devp->si_cmd_reply)!=0){
+       		 	printk("[si2196..]%s:get si2196 tuner status error!!!\n",__func__);
+        		return -ERROR;
+    		}
+    		else
+        		strength = si2196_devp->si_cmd_reply.tuner_status.rssi-256;
+		printk("strength is %d\n",strength);
+ 	}
+       return 0;
+}
+
+
+static void get_mono_sound_mode(unsigned int *mode)
+{
+    if(si2196_atv_status(&si2196_devp->tuner_client, 0, &si2196_devp->si_cmd_reply)!=0)
+    {
+            printk("[si2196..]%s:get si2196 atv status error.\n",__func__);
+            return;
+    }
+    switch(si2196_devp->si_cmd_reply.atv_status.video_sys)
+    {
+        case 0:
+            *mode = V4L2_STD_B;
+            break;
+        case 1:
+            *mode = V4L2_STD_DK;
+            break;
+        case 2:
+            *mode = V4L2_STD_MN;
+            break;
+        case 3:
+            *mode = V4L2_STD_DK;
+            break;
+        case 4:
+            *mode = V4L2_STD_PAL_I;
+            break;
+        case 5:
+            *mode = V4L2_STD_DK;
+            break;
+        case 6:
+            *mode = V4L2_STD_SECAM_L;
+            break;
+        case 7:
+            *mode = V4L2_STD_UNKNOWN;
+	    break;
+        default:
+            break;
+    }
+    siprintk("[si2196..]%s result is %s.\n",__func__,v4l2_std_to_str(*mode));
+}
+static int si2196_set_config(struct dvb_frontend *fe, void *arg)
+{
+   tuner_param_t *param = (tuner_param_t*)arg;
+	if(!arg)
+	{
+		printk("[si2196..]%s null pointer error.\n",__func__);
+		return -ERROR;
+	}
+	switch(param->cmd)
+	{
+		case TUNER_CMD_AUDIO_MUTE:
+			//SI2196_SD_PORT_VOLUME_MASTER_PROP = 0x0d11
+			if(si2196_set_property(&si2196_devp->tuner_client, 0,0xd11, -231, &si2196_devp->si_cmd_reply))
+			{
+				printk("[si2196..]%s mute tuner error.\n",__func__);
+				return -ERROR;
+			}
+			break;
+		case TUNER_CMD_AUDIO_ON:
+			if(si2196_set_property(&si2196_devp->tuner_client, 0,0xd11, si2196_devp->sparm.m_volume.volume, &si2196_devp->si_cmd_reply))
+			{
+				printk("[si2196..]%s set tuner volume error.\n",__func__);
+				return -ERROR;
+			}
+			break;
+		case TUNER_CMD_TUNER_POWER_DOWN:
+			if(si2196_power_down(&si2196_devp->tuner_client, &si2196_devp->si_cmd_reply))
+			{
+				printk("[si2196..]%s power down tuner error.\n",__func__);
+				return -ERROR;
+			}
+			siprintk("[si2196..]%s power down tuner TUNER_CMD_TUNER_POWER_DOWN.\n",__func__);
+			break;
+		case TUNER_CMD_TUNER_POWER_ON:
+			if(si2196_init(&si2196_devp->tuner_client, &si2196_devp->si_cmd_reply))
+			{
+				printk("[si2196..]%s: si2196 initializate error.\n",__func__);
+				return -ERROR;
+			}
+			if(si2196_configure(&si2196_devp->tuner_client,&si2196_devp->si_cmd_reply))
+        		    printk("[si2196..]%s: si2196 configure atv&dtv error.\n",__func__);
+			break;
+		case TUNER_CMD_SET_VOLUME:
+			if(param->parm > SI2196_SD_PORT_VOLUME_MASTER_PROP_VOLUME_VOLUME_MIN)
+				param->parm = SI2196_SD_PORT_VOLUME_MASTER_PROP_VOLUME_VOLUME_MAX;
+			si2196_devp->sparm.m_volume.volume = param->parm;
+			if(si2196_set_property(&si2196_devp->tuner_client, 0,0xd11, si2196_devp->sparm.m_volume.volume, &si2196_devp->si_cmd_reply))
+				printk("[si2196..]%s set tuner volume error.\n",__func__);
+			break;
+                case TUNER_CMD_GET_MONO_MODE:
+                        get_mono_sound_mode(&param->parm);
+                        break;
+		default:
+			break;
+    }
+    return 0;
+}
+static void si2196_analog_get_status(struct dvb_frontend *fe, void *status);
+
+static int si2196_tuner_get_ops(struct aml_fe_dev *fe, int mode, void *ops)
+{
+    struct dvb_tuner_ops *si2196_tuner_ops = (struct dvb_tuner_ops *)ops;
+    if(!ops)
+    {
+        printk("[si2196..]%s null pointer error.\n",__func__);
+        return -1;
+    }
+    si2196_tuner_ops->info.frequency_min    = SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MIN;
+    si2196_tuner_ops->info.frequency_max    = SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MAX;
+    switch(mode)
+    {
+        case AM_FE_QPSK:
+			//SI2196_DTV_MODE_PROP_MODULATION_ISDBT = 4
+            si2196_devp->sparm.dtv_mode.modulation = 4;
+            break;
+        case AM_FE_QAM:
+			//SI2196_DTV_MODE_PROP_MODULATION_DVBC = 3
+            si2196_devp->sparm.dtv_mode.modulation = 3;
+            break;
+		case AM_FE_OFDM:
+			//SI2196_DTV_MODE_PROP_MODULATION_DVBT = 2
+            si2196_devp->sparm.dtv_mode.modulation = 2;
+            break;
+        case AM_FE_ATSC:
+			//SI2196_DTV_MODE_PROP_MODULATION_ATSC = 0
+            si2196_devp->sparm.dtv_mode.modulation = 0;
+            break;
+	case AM_FE_ANALOG:
+            break;
+        default:
+            printk("[si2196..] %s no mode to match %d.\n",__func__, mode);
+            break;
+    }
+
+    if(mode == AM_FE_ANALOG)
+    {
+        /*silicon tuner fine tune*/
+        si2196_tuner_ops->fine_tune = si2196_tuner_fine_tune;
+        //the box for expand
+        si2196_tuner_ops->set_config = si2196_set_config;
+        si2196_devp->parm.mode = SI2196_TUNER_TUNE_FREQ_CMD_MODE_ATV;
+    }
+    else
+    {   if(si2196_set_property(&si2196_devp->tuner_client, 0, 0x703,
+    						si2196_devp->sparm.dtv_mode.modulation<<4|8,
+    						&si2196_devp->si_cmd_reply))
+        	printk("[si2196..] %s mode %d si2196_set_property error.",__func__, mode);
+        si2196_devp->parm.mode = SI2196_TUNER_TUNE_FREQ_CMD_MODE_DTV;
+    }
+    si2196_tuner_ops->info.frequency_step = 0x0;
+    si2196_tuner_ops->get_tuner_status = si2196_get_tuner_status;
+    si2196_tuner_ops->get_rf_strength = si2196_get_rf_strength;
+    si2196_tuner_ops->get_status = si2196_analog_get_status;
+    /*set analog parameters such as frequency,std,mode,sound sys,sound mode*/
+    si2196_tuner_ops->set_params = si2196_set_params;
+
+}
+static int si2196_tuner_fe_init(struct aml_fe_dev *fe)
+{
+    if(!fe)
+    {
+        printk("[si2196..]%s null pointer error.\n",__func__);
+        return -ERROR;
+    }
+    si2196_devp->tuner_client.adapter =  fe->i2c_adap;
+    si2196_devp->tuner_client.addr = fe->i2c_addr;
+    if(!sprintf(si2196_devp->tuner_client.name, SI2196_TUNER_I2C_NAME))
+    {
+        printk("[si2196..]%s sprintf name error.\n",__func__);
+    }
+   si2196_devp->si_cmd_reply.reply = kmalloc(sizeof(si2196_common_reply_struct),GFP_KERNEL);
+    /*reset silicon 2196 tuner*/
+    gpio_direction_output(fe->reset_gpio, fe->reset_value);
+    udelay(400);
+    gpio_direction_output(fe->reset_gpio, !fe->reset_value);
+    return 0;
+}
+
+
+static int si2196_enter_mode(struct aml_fe *fe, int mode)
+{
+
+       if(si2196_init(&si2196_devp->tuner_client, &si2196_devp->si_cmd_reply))
+    {
+        printk("[si2196..]%s si2196 initializate error.\n",__func__);
+        return -ERROR;
+    }
+    if(si2196_configure(&si2196_devp->tuner_client,  &si2196_devp->si_cmd_reply))
+    {
+        printk("[si2196..]%s si2196 config error.\n",__func__);
+        return -ERROR;
+    }
+    //duration = 20(SI2196_SD_ADAC_POWER_UP_CMD_DURATION_MIN)
+    if(si2196_adac_power_up(&si2196_devp->tuner_client, 20, &si2196_devp->si_cmd_reply))
+    {
+        printk("[si2196..]%s si2196 adac power up error.\n",__func__);
+        return -ERROR;
+    }
+        return 0;
+}
+static int si2196_leave_mode(struct aml_fe *fe, int mode)
+{
+        int err_code;
+        err_code = si2196_power_down(&si2196_devp->tuner_client, &si2196_devp->si_cmd_reply);
+        if(err_code)
+        {
+                printk("[si2196..]%s power down si2196 error.\n",__func__);
+                return err_code;
+        }
+	siprintk("[si2196..]%s power down tuner TUNER_CMD_TUNER_POWER_DOWN.\n",__func__);
+        return 0;
+}
+static struct aml_fe_drv si2196_tuner_drv = {
+        .name = TUNER_DEVICE_NAME,
+        .id       = AM_TUNER_SI2196,
+	.capability = AM_FE_ANALOG|AM_FE_QPSK|AM_FE_QAM|AM_FE_ATSC|AM_FE_OFDM,
+        .get_ops = si2196_tuner_get_ops,
+        .init       = si2196_tuner_fe_init,
+        .enter_mode=si2196_enter_mode,
+        .leave_mode=si2196_leave_mode
+};
+/*the analog driver*/
+static int si2196_analog_get_afc(struct dvb_frontend *fe)
+{
+    if(si2196_atv_status(&si2196_devp->tuner_client, 0, &si2196_devp->si_cmd_reply)!=0)
+    {
+            printk("[si2196..]%s:get si2196 atv status error.\n",__func__);
+            return -ERROR;
+    }
+    if(si2196_debug)
+        printk("[si2196..] %s afc: %d \n", __func__, si2196_devp->si_cmd_reply.atv_status.afc_freq);
+    return si2196_devp->si_cmd_reply.atv_status.afc_freq;
+}
+
+static int si2196_analog_get_snr(struct dvb_frontend *fe)
+{
+
+    //0=SI2176_ATV_STATUS_CMD_INTACK_OK
+    if(si2196_atv_status(&si2196_devp->tuner_client, 0, &si2196_devp->si_cmd_reply)!=0)
+    {
+        printk("[si2196..]%s:get si2196 atv status error.\n",__func__);
+        return -ERROR;
+    }
+    if(si2196_debug)
+        printk("[si2196..] %s snr: %d \n", __func__, si2196_devp->si_cmd_reply.atv_status.video_snr);
+    return si2196_devp->si_cmd_reply.atv_status.video_snr;
+}
+static void si2196_analog_get_status(struct dvb_frontend *dvb_fe, void *stat)
+{
+	fe_status_t *status=(fe_status_t *)stat;
+    if(!status)
+    {
+        printk("[si2196..]%s: null pointer error.\n",__func__);
+        return;
+    }
+    //0=SI2176_ATV_STATUS_CMD_INTACK_OK
+    if(si2196_atv_status(&si2196_devp->tuner_client, 0, &si2196_devp->si_cmd_reply)!=0)
+    {
+        printk("[si2196..]%s:get si2196 atv status error.\n",__func__);
+        return;
+    }
+    else
+    {
+        if(si2196_devp->si_cmd_reply.atv_status.chl)
+            *status = FE_HAS_LOCK;
+        else
+            *status = FE_TIMEDOUT;
+    }
+}
+
+
+static int si2196_analog_get_atv_status(struct dvb_frontend *fe, atv_status_t *atv_status)
+{
+    struct atv_status_s *atv_sts = atv_status;
+    if(!atv_status)
+    {
+        printk("[si2196..]%s: null pointer error.\n",__func__);
+        return -ERROR;
+    }
+    if(si2196_atv_status(&si2196_devp->tuner_client, SI2196_ATV_STATUS_CMD_INTACK_OK, &si2196_devp->si_cmd_reply)!=0)
+    {
+        pr_info("[si2196..]%s:get si2196 atv status error.\n",__func__);
+        return -ERROR;
+    }
+    else
+    {
+        atv_sts->afc = si2196_devp->si_cmd_reply.atv_status.afc_freq;
+        atv_sts->snr =si2196_devp->si_cmd_reply.atv_status.video_snr;
+        atv_sts->atv_lock = si2196_devp->si_cmd_reply.atv_status.chl;
+        atv_sts->audmode = si2196_devp->si_cmd_reply.atv_status.audio_sys;
+        atv_sts->std &= 0;
+        if(si2196_devp->si_cmd_reply.atv_status.color)
+            atv_sts->std |= V4L2_COLOR_STD_SECAM;
+        else
+            atv_sts->std = V4L2_COLOR_STD_PAL;
+        switch(si2196_devp->si_cmd_reply.atv_status.video_sys)
+        {
+            case 0:
+                atv_sts->std |=V4L2_STD_B;
+                break;
+            case 1:
+               atv_sts->std |=V4L2_STD_GH;
+               break;
+            case 2:
+               atv_sts->std |=V4L2_STD_PAL_M;
+               break;
+            case 3:
+               atv_sts->std |=V4L2_STD_PAL_N;
+               break;
+            case 4:
+               atv_sts->std |=V4L2_STD_PAL_I;
+               break;
+            case 5:
+               atv_sts->std |=V4L2_STD_DK;
+               break;
+            case 6:
+               atv_sts->std |=V4L2_STD_SECAM_L;
+               break;
+            case 7:
+               atv_sts->std |=V4L2_STD_SECAM_LC;
+               break;
+            default:
+                break;
+        }
+        siprintk("[si2196..]%s chl is %d, afc %d, snr %d,color %s audmode %s.\n",
+                    __func__,atv_sts->atv_lock,atv_sts->afc,atv_sts->snr,
+                    v4l2_std_to_str(atv_sts->std&0xff000000),v4l2_std_to_str(atv_sts->std&0xffffff));
+
+    }
+    return 0;
+}
+
+static int si2196_analog_get_sd_status(struct dvb_frontend *fe, sound_status_t *sd_status)
+{
+    unsigned char ret = 0;
+    sound_status_t *tmp_status = sd_status;
+    if(!tmp_status)
+    {
+        printk("[si2196..] %s null pointer error.\n",__func__);
+        return -ERROR;
+    }
+    ret = si2196_sd_status(&si2196_devp->tuner_client, &si2196_devp->si_cmd_reply, SI2196_SD_STATUS_CMD_INTACK_OK);
+    if(ret)
+    {
+        printk("[si2196..] %s si2196 get sd status error.\n",__func__);
+        return -ERROR;
+    }
+    tmp_status->sound_sys = si2196_devp->si_cmd_reply.sd_status.sound_system_detected;
+    tmp_status->sound_mode = si2196_devp->si_cmd_reply.sd_status.sound_mode_detected;
+    switch(tmp_status->sound_mode)
+    {
+        //SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_MONO = 1
+        case 1:
+            tmp_status->sound_mode = V4L2_TUNER_MODE_MONO;
+            break;
+        //SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_DUAL_MONO = 2
+        case 2:
+            tmp_status->sound_mode = V4L2_TUNER_MODE_LANG1_LANG2;
+            break;
+        //SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_STEREO = 3
+        case 3:
+            tmp_status->sound_mode = V4L2_TUNER_MODE_STEREO;
+            break;
+        default:
+            tmp_status->sound_mode = V4L2_TUNER_AUDMODE_NULL;
+            break;
+    }
+    if(si2196_devp->si_cmd_reply.sd_status.sap_detected)
+            tmp_status->sound_mode = V4L2_TUNER_MODE_SAP;
+    siprintk("[si2196..]%s sound sys %s. sound mode %s.\n",__func__,soundsys_to_str(tmp_status->sound_sys),
+                audmode_to_str(tmp_status->sound_mode));
+    return 0;
+
+}
+static int si2196_analog_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+    struct analog_demod_ops *si2196_analog_ops = (struct analog_demod_ops*)ops;
+    if(!ops)
+    {
+        printk("[si2196..]%s null pointer error.\n",__func__);
+        return -ERROR;
+    }
+    si2196_analog_ops->get_afc               = si2196_analog_get_afc;
+    si2196_analog_ops->get_snr               = si2196_analog_get_snr;
+    si2196_analog_ops->get_status      =  si2196_analog_get_status;
+    si2196_analog_ops->get_atv_status   = si2196_analog_get_atv_status;
+    si2196_analog_ops->get_sd_status    = si2196_analog_get_sd_status;
+    return 0;
+}
+static struct aml_fe_drv si2196_analog_drv = {
+    .name    = "si2196_atv_demod",
+    .capability = AM_FE_ANALOG,
+    .id      = AM_ATV_DEMOD_SI2196 ,
+    .get_ops = si2196_analog_get_ops
+};
+
+static int __init si2196_tuner_init(void)
+{
+    int ret = 0;
+    si2196_devp = kmalloc(sizeof(si2196_device_t), GFP_KERNEL);
+    if(!si2196_devp)
+    {
+        pr_info("[si2196..] %s:allocate memory error.\n",__func__);
+        return -ENOMEM;
+    }
+    si2196_devp->clsp = class_create(THIS_MODULE,TUNER_DEVICE_NAME);
+    if(!si2196_devp->clsp)
+    	{
+        pr_info("[%s]:create class error.",__func__);
+    	  kfree(si2196_devp);
+        si2196_devp = NULL;
+        return PTR_ERR(si2196_devp->clsp);
+	}
+    class_create_file(si2196_devp->clsp,&class_attr_si2196_debug);
+    aml_register_fe_drv(AM_DEV_TUNER,   &si2196_tuner_drv);
+    aml_register_fe_drv(AM_DEV_ATV_DEMOD, &si2196_analog_drv);
+    printk("[si2196..]%s.\n",__func__);
+    return ret;
+}
+
+static void __exit si2196_tuner_exit(void)
+{
+    if(SI2196_DEBUG)
+        pr_info( "%s . \n", __FUNCTION__ );
+    class_destroy(si2196_devp->clsp);
+    aml_unregister_fe_drv(AM_DEV_TUNER,   &si2196_tuner_drv);
+    aml_unregister_fe_drv(AM_DEV_ATV_DEMOD, &si2196_analog_drv);
+    kfree(si2196_devp);
+}
+
+MODULE_AUTHOR("kele bai <kele.bai@amlogic.com>");
+MODULE_DESCRIPTION("Silicon si2196 tuner i2c device driver");
+MODULE_LICENSE("GPL");
+fs_initcall(si2196_tuner_init);
+module_exit(si2196_tuner_exit);
+
diff --git a/drivers/amlogic/dvb_tv/si2196/si2196_func.c b/drivers/amlogic/dvb_tv/si2196/si2196_func.c
new file mode 100755
index 000000000000..7416430382fd
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2196/si2196_func.c
@@ -0,0 +1,3384 @@
+/*
+ * Silicon labs si2196 Tuner Device Driver
+ *
+ * Author: Bobby Yang <bo.yang@amlogic.com>
+ *
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/* Standard Liniux Headers */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+/* Local Headers */
+#include "si2196_func.h"
+
+
+#define I2C_TRY_MAX_CNT       3  //max try counter
+
+static unsigned int delay_det=65;
+module_param(delay_det, uint, 0644);
+MODULE_PARM_DESC(delay_det, "delay set freq time\n");
+/* for si2196 tuner type */
+unsigned char si2196_fw_1_2b1[] = {
+0x04,0x01,0x01,0x00,0xAE,0x45,0xB9,0x6D,
+0x05,0x02,0x2B,0x39,0xD2,0xE8,0xFD,0xF5,
+0x05,0x1C,0x5D,0x8F,0x78,0x6D,0xA2,0x09,
+0x2F,0x6D,0xA7,0x13,0x77,0x4A,0x13,0x7B,
+0x05,0xCD,0x80,0xE8,0x92,0x77,0x83,0x87,
+0x2A,0x5B,0xB0,0x1C,0x06,0x7E,0xE0,0xD1,
+0x05,0x46,0x34,0xC6,0xFB,0x4B,0xEE,0x51,
+0x2F,0xC3,0xFE,0xDA,0x23,0x94,0x03,0xF0,
+0x29,0xBB,0x2D,0x32,0x76,0xA6,0x18,0x5B,
+0x07,0x9E,0xE3,0xDB,0x83,0x25,0xCE,0xB4,
+0x2A,0x7A,0x90,0xA4,0x43,0x25,0xD4,0x43,
+0x07,0xD6,0xFB,0x49,0x26,0xD4,0x77,0xEE,
+0x27,0x49,0x65,0x7D,0x5B,0x15,0x9C,0x9C,
+0x2F,0x26,0x10,0x18,0x0B,0x97,0x20,0x5A,
+0x27,0x82,0x9D,0xD5,0x31,0xA1,0x34,0x32,
+0x27,0x38,0x32,0xCE,0xE4,0x9F,0x87,0x86,
+0x25,0x37,0x4A,0x09,0xB8,0x15,0xB6,0x54,
+0x0F,0x82,0xF9,0x3A,0xA6,0x8B,0x48,0x3C,
+0x2F,0xBB,0x5E,0x73,0xE8,0xD3,0x3A,0xC9,
+0x2F,0x4A,0x9D,0x95,0x17,0x6F,0x3C,0x78,
+0x27,0x2E,0x6D,0xD5,0x79,0x29,0xAE,0x36,
+0x2F,0xF7,0x3B,0x46,0x6C,0xED,0x2E,0x85,
+0x0F,0xC6,0x4F,0x2C,0x99,0xA6,0xCA,0x5E,
+0x0F,0x7C,0xB0,0xF0,0xE1,0xA1,0xB9,0x13,
+0x0F,0x12,0xCC,0xD9,0x09,0x9F,0xF4,0xFF,
+0x2A,0x7E,0x58,0x46,0x4A,0x18,0x6A,0xDC,
+0x07,0xE4,0xCC,0x09,0x95,0x75,0x6F,0xAA,
+0x07,0xFC,0x8B,0xF9,0x28,0xBA,0x76,0x78,
+0x0F,0x4B,0xED,0x22,0x63,0xE9,0xC8,0x7A,
+0x05,0x75,0xE1,0xDD,0xCF,0xCF,0xC6,0x24,
+0x22,0x11,0x1D,0x10,0x67,0xCD,0x16,0x82,
+0x05,0x05,0x47,0x99,0x54,0x5E,0xCB,0x43,
+0x22,0x77,0xFE,0x42,0x43,0x77,0xE6,0x10,
+0x05,0x04,0x0B,0xB7,0x77,0x4D,0x45,0x62,
+0x22,0xF2,0x3D,0xF4,0xA4,0x3D,0x22,0x2C,
+0x0F,0x24,0x1B,0x48,0x5F,0x52,0xCF,0x21,
+0x05,0x98,0x79,0x03,0xC8,0x75,0xC7,0x5A
+};
+
+
+//#define NB_LINES (sizeof(firmwaretable)/(8*sizeof(unsigned char)))
+
+#ifdef USING_ATV_FILTER
+    static unsigned char dlif_vidfilt_table[] = {0};
+    #define DLIF_VIDFILT_LINES (sizeof(dlif_vidfilt_table)/(8*sizeof(unsigned char)))
+#endif
+
+static si2196_common_reply_struct  reply;
+/************************************************************************************************************************
+  NAME:		   si2196_readcommandbytes function
+  DESCRIPTION:Read inbbytes from the i2c device into pucdatabuffer, return number of bytes read
+  Parameter: iI2CIndex, the index of the first byte to read.
+  Parameter: inbbytes, the number of bytes to read.
+  Parameter: *pucdatabuffer, a pointer to a buffer used to store the bytes
+  Porting:    Replace with embedded system I2C read function
+  Returns:    Actual number of bytes read.
+************************************************************************************************************************/
+static int si2196_readcommandbytes(struct i2c_client *si2196, int inbbytes, unsigned char *pucdatabuffer)
+{
+    int i2c_flag = 0;
+    int i = 0;
+    unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
+
+    struct i2c_msg msg[] = {
+        {
+            .addr  = si2196->addr,
+            .flags  = I2C_M_RD,
+            .len     = inbbytes,
+            .buf     = pucdatabuffer,
+        },
+    };
+
+repeat:
+    i2c_flag = i2c_transfer(si2196->adapter, msg, 1);
+    if (i2c_flag < 0) {
+        pr_err("%s: error in read sli2176, %d byte(s) should be read,. \n", __func__, inbbytes);
+        if (i++ < i2c_try_cnt) {
+            pr_err("%s: error in read sli2176, try again!!!\n", __func__);
+            goto repeat;
+        }
+        else
+            return -EIO;
+    }
+    else {
+        //pr_info("%s: read %d bytes\n", __func__, inbbytes);
+        return inbbytes;
+    }
+}
+
+/************************************************************************************************************************
+  NAME:  si2196_writecommandbytes
+  DESCRIPTION:  Write inbbytes from pucdatabuffer to the i2c device, return number of bytes written
+  Porting:    Replace with inbbytes system I2C write function
+  Returns:    Number of bytes written
+************************************************************************************************************************/
+static int si2196_writecommandbytes(struct i2c_client *si2196, int inbbytes, unsigned char *pucdatabuffer)
+{
+    int i2c_flag = 0;
+    int i = 0;
+    unsigned int i2c_try_cnt = I2C_TRY_MAX_CNT;
+
+    struct i2c_msg msg[] = {
+	    {
+			.addr	= si2196->addr,
+			.flags	= 0,    //|I2C_M_TEN,
+			.len	= inbbytes,
+			.buf	= pucdatabuffer,
+		}
+
+	};
+
+repeat:
+    i2c_flag = i2c_transfer(si2196->adapter, msg, 1);
+    if (i2c_flag < 0) {
+        pr_err("%s: error in write sli2176, %d byte(s) should be read,. \n", __func__, inbbytes);
+        if (i++ < i2c_try_cnt) {
+            pr_err("%s: error in wirte sli2176, try again!!!\n", __func__);
+            goto repeat;
+        }
+        else
+            return -EIO;
+    }
+    else {
+        //pr_info("%s: write %d bytes\n", __func__, inbbytes);
+        return inbbytes;
+    }
+}
+
+/***********************************************************************************************************************
+  sli2176_pollforcts function
+  Use:        CTS checking function
+              Used to check the CTS bit until it is set before sending the next command
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure hels reducing the code size
+  Comments:   waitForCTS = 1 => I2C polling
+              waitForCTS = 2 => INTB followed by a read (reading a HW byte using the cypress chip)
+              max timeout = 100 ms
+
+  Porting:    If reading INTB is not possible, the waitForCTS = 2 case can be removed
+
+  Parameter: waitForCTS          a flag indicating if waiting for CTS is required
+  Returns:   1 if the CTS bit is set, 0 otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2196_pollforcts(struct i2c_client *si2196)
+{
+    unsigned char error_code = 0;
+    unsigned char loop_count = 0;
+    unsigned char rspbytebuffer[1];
+
+    for (loop_count=0; loop_count<50; loop_count++) { /* wait a maximum of 50*25ms = 1.25s  */
+        if (si2196_readcommandbytes(si2196, 1, rspbytebuffer) != 1)
+            error_code = ERROR_SI2196_POLLING_CTS;
+        else
+            error_code = NO_SI2196_ERROR;
+        if (error_code || (rspbytebuffer[0] & 0x80))
+            goto exit;
+        mdelay(2); /* CTS not set, wait 2ms and retry */
+    }
+    error_code = ERROR_SI2196_CTS_TIMEOUT;
+
+exit:
+    if (error_code)
+        pr_info("%s: poll cts function error:%d!!!...............\n", __func__, error_code);
+
+    return error_code;
+}
+
+/***********************************************************************************************************************
+  SI2196_CurrentResponseStatus function
+  Use:        status checking function
+              Used to fill the SI2196_COMMON_REPLY_struct members with the ptDataBuffer byte's bits
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure hels reducing the code size
+
+  Parameter: *ret          the SI2196_COMMON_REPLY_struct
+  Parameter: ptDataBuffer  a single byte received when reading a command's response (the first byte)
+  Returns:   0 if the err bit (bit 6) is unset, 1 otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2196_currentresponsestatus(si2196_common_reply_struct *common_reply, unsigned char ptdatabuffer)
+{
+    /* _status_code_insertion_start */
+    common_reply->tunint = ((ptdatabuffer >> 0 ) & 0x01);
+    common_reply->atvint = ((ptdatabuffer >> 1 ) & 0x01);
+    common_reply->dtvint = ((ptdatabuffer >> 2 ) & 0x01);
+    common_reply->err    = ((ptdatabuffer >> 6 ) & 0x01);
+    common_reply->cts    = ((ptdatabuffer >> 7 ) & 0x01);
+    /* _status_code_insertion_point */
+    return (common_reply->err ? ERROR_SI2196_ERR : NO_SI2196_ERROR);
+}
+
+/***********************************************************************************************************************
+  si2196_pollforresponse function
+  Use:        command response retrieval function
+              Used to retrieve the command response in the provided buffer,
+              poll for response either by I2C polling or wait for INTB
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure hels reducing the code size
+  Comments:   waitForCTS = 1 => I2C polling
+              waitForCTS = 2 => INTB followed by a read (reading a HW byte using the cypress chip)
+              max timeout = 100 ms
+
+  Porting:    If reading INTB is not possible, the waitForCTS = 2 case can be removed
+
+  Parameter:  waitforresponse  a flag indicating if waiting for the response is required
+  Parameter:  nbbytes          the number of response bytes to read
+  Parameter:  pbytebuffer      a buffer into which bytes will be stored
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2196_pollforresponse(struct i2c_client *si2196, unsigned char waitforresponse, unsigned int nbbytes, unsigned char *pbytebuffer, si2196_common_reply_struct *common_reply)
+{
+    unsigned char error_code;
+    unsigned char loop_count;
+
+    for (loop_count=0; loop_count<100; loop_count++) { /* wait a maximum of 50*2ms = 100ms                        */
+        switch (waitforresponse) { /* type of response polling?                                */
+            case 0 : /* no polling? valid option, but shouldn't have been called */
+                error_code = NO_SI2196_ERROR; /* return no error                                          */
+                goto exit;
+
+            case 1 : /* I2C polling status?                                      */
+                if (si2196_readcommandbytes(si2196, nbbytes, pbytebuffer) != nbbytes)
+                    error_code = ERROR_SI2196_POLLING_RESPONSE;
+                else
+                    error_code = NO_SI2196_ERROR;
+                if (error_code)
+                    goto exit;	/* if error, exit with error code */
+                if (pbytebuffer[0] & 0x80)	  /* CTS set? */
+                {
+                    error_code = si2196_currentresponsestatus(common_reply, pbytebuffer[0]);
+                    goto exit; /* exit whether ERR set or not   */
+                }
+                break;
+
+            default :
+                error_code = ERROR_SI2196_PARAMETER_OUT_OF_RANGE; /* support debug of invalid CTS poll parameter   */
+                goto exit;
+        }
+        mdelay(2); /* CTS not set, wait 2ms and retry                         */
+    }
+    error_code = ERROR_SI2196_CTS_TIMEOUT;
+
+exit:
+    return error_code;
+}
+
+/************************************************************************************************************************
+  NAME: CheckStatus
+  DESCRIPTION:     Read Si2170 STATUS byte and return decoded status
+  Parameter:  Si2170 Context (I2C address)
+  Parameter:  Status byte (TUNINT, ATVINT, DTVINT, ERR, CTS, CHLINT, and CHL flags).
+  Returns:    Si2170/I2C transaction error code
+************************************************************************************************************************/
+
+int si2196_check_status(struct i2c_client *si2196, si2196_common_reply_struct *common_reply)
+{
+    unsigned char buffer[1];
+    /* read STATUS byte */
+    if (si2196_pollforresponse(si2196, 1, 1, buffer, common_reply) != 0)
+    {
+        return ERROR_SI2196_POLLING_RESPONSE;
+    }
+    pr_info("%s:status 0x%2x cts %d,err %d .\n",__func__,(*buffer),common_reply->cts,common_reply->err);
+    return 0;
+}
+
+/***********************************************************************************************************************
+  NAME: Si2170_L1_API_Patch
+  DESCRIPTION: Patch information function
+              Used to send a number of bytes to the Si2170. Useful to download the firmware.
+  Parameter:   *api    a pointer to the api context to initialize
+  Parameter:  waitForCTS flag for CTS checking prior to sending a Si2170 API Command
+  Parameter:  waitForResponse flag for CTS checking and Response readback after sending Si2170 API Command
+  Parameter:  number of bytes to transmit
+  Parameter:  Databuffer containing the bytes to transfer in an unsigned char array.
+  Returns:   0 if no error, else a nonzero int representing an error
+ ***********************************************************************************************************************/
+static unsigned char si2196_api_patch(struct i2c_client *si2196, int inbbytes, unsigned char *pucdatabuffer, si2196_common_reply_struct *common_reply)
+{
+    unsigned char res = 0;
+    unsigned char error_code = 0;
+    unsigned char rspbytebuffer[1];
+
+    res = si2196_pollforcts(si2196);
+    if (res != NO_SI2196_ERROR)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, res);
+        return res;
+    }
+
+    res = si2196_writecommandbytes(si2196, inbbytes, pucdatabuffer);
+    if (res!=inbbytes)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, ERROR_SI2196_SENDING_COMMAND);
+       return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, common_reply);
+    if (error_code)
+        pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+
+    return error_code;
+}
+
+
+/* _commands_insertion_start */
+#ifdef SI2196_AGC_OVERRIDE_CMD
+/*---------------------------------------------------*/
+/* SI2196_AGC_OVERRIDE COMMAND                     */
+/*---------------------------------------------------*/
+static unsigned char si2196_agc_override(struct i2c_client *si2196,
+        unsigned char   force_max_gain,
+        unsigned char   force_top_gain,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[2];
+    unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (force_max_gain > SI2196_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MAX)
+            || (force_top_gain > SI2196_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MAX) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_AGC_OVERRIDE_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( force_max_gain & SI2196_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MASK ) << SI2196_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_LSB|
+                                         ( force_top_gain & SI2196_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MASK ) << SI2196_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_LSB);
+
+    if (si2196_writecommandbytes(si2196, 2, cmdbytebuffer) != 2)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_AGC_OVERRIDE_CMD */
+#ifdef SI2196_ATV_CW_TEST_CMD
+/*---------------------------------------------------*/
+/* SI2196_ATV_CW_TEST COMMAND                      */
+/*---------------------------------------------------*/
+static unsigned char si2196_atv_cw_test(struct i2c_client *si2196,
+        unsigned char   pc_lock,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[2];
+    unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (pc_lock > SI2196_ATV_CW_TEST_CMD_PC_LOCK_MAX) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code) goto exit;
+
+    cmdbytebuffer[0] = SI2196_ATV_CW_TEST_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( pc_lock & SI2196_ATV_CW_TEST_CMD_PC_LOCK_MASK ) << SI2196_ATV_CW_TEST_CMD_PC_LOCK_LSB);
+
+    if (si2196_writecommandbytes(si2196, 2, cmdbytebuffer) != 2) error_code = ERROR_SI2196_SENDING_COMMAND;
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_ATV_CW_TEST_CMD */
+#ifdef SI2196_ATV_RESTART_CMD
+/*---------------------------------------------------*/
+/* SI2196_ATV_RESTART COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char si2196_atv_restart(struct i2c_client *si2196,
+        unsigned char   mode,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[2];
+    unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (mode > SI2196_ATV_RESTART_CMD_MODE_MAX) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_ATV_RESTART_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( mode & SI2196_ATV_RESTART_CMD_MODE_MASK ) << SI2196_ATV_RESTART_CMD_MODE_LSB);
+
+    if (si2196_writecommandbytes(si2196, 2, cmdbytebuffer) != 2)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+    mdelay(20);
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_ATV_RESTART_CMD */
+#ifdef SI2196_ATV_STATUS_CMD
+/*---------------------------------------------------*/
+/* SI2196_ATV_STATUS COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char si2196_atv_status(struct i2c_client *si2196,
+        unsigned char intack,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[2];
+    unsigned char rspbytebuffer[11];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (intack > SI2196_ATV_STATUS_CMD_INTACK_MAX) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_ATV_STATUS_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( intack & SI2196_ATV_STATUS_CMD_INTACK_MASK ) << SI2196_ATV_STATUS_CMD_INTACK_LSB);
+
+    if (si2196_writecommandbytes(si2196, 2, cmdbytebuffer) != 2)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 11, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+        if (!error_code)
+        {
+            rsp->atv_status.chlint           =   (( ( (rspbytebuffer[1]  )) >> SI2196_ATV_STATUS_RESPONSE_CHLINT_LSB           ) & SI2196_ATV_STATUS_RESPONSE_CHLINT_MASK           );
+            rsp->atv_status.pclint           =   (( ( (rspbytebuffer[1]  )) >> SI2196_ATV_STATUS_RESPONSE_PCLINT_LSB           ) & SI2196_ATV_STATUS_RESPONSE_PCLINT_MASK           );
+            rsp->atv_status.dlint             =   (( ( (rspbytebuffer[1]  )) >> SI2196_ATV_STATUS_RESPONSE_DLINT_LSB            ) & SI2196_ATV_STATUS_RESPONSE_DLINT_MASK            );
+            rsp->atv_status.snrlint          =   (( ( (rspbytebuffer[1]  )) >> SI2196_ATV_STATUS_RESPONSE_SNRLINT_LSB          ) & SI2196_ATV_STATUS_RESPONSE_SNRLINT_MASK          );
+            rsp->atv_status.snrhint         =   (( ( (rspbytebuffer[1]  )) >> SI2196_ATV_STATUS_RESPONSE_SNRHINT_LSB          ) & SI2196_ATV_STATUS_RESPONSE_SNRHINT_MASK          );
+            rsp->atv_status.chl                =   (( ( (rspbytebuffer[2]  )) >> SI2196_ATV_STATUS_RESPONSE_CHL_LSB              ) & SI2196_ATV_STATUS_RESPONSE_CHL_MASK              );
+            rsp->atv_status.pcl               =   (( ( (rspbytebuffer[2]  )) >> SI2196_ATV_STATUS_RESPONSE_PCL_LSB              ) & SI2196_ATV_STATUS_RESPONSE_PCL_MASK              );
+            rsp->atv_status.dl                 =   (( ( (rspbytebuffer[2]  )) >> SI2196_ATV_STATUS_RESPONSE_DL_LSB               ) & SI2196_ATV_STATUS_RESPONSE_DL_MASK               );
+            rsp->atv_status.snrl              =   (( ( (rspbytebuffer[2]  )) >> SI2196_ATV_STATUS_RESPONSE_SNRL_LSB             ) & SI2196_ATV_STATUS_RESPONSE_SNRL_MASK             );
+            rsp->atv_status.snrh             =   (( ( (rspbytebuffer[2]  )) >> SI2196_ATV_STATUS_RESPONSE_SNRH_LSB             ) & SI2196_ATV_STATUS_RESPONSE_SNRH_MASK             );
+            rsp->atv_status.video_snr     =   (( ( (rspbytebuffer[3]  )) >> SI2196_ATV_STATUS_RESPONSE_VIDEO_SNR_LSB        ) & SI2196_ATV_STATUS_RESPONSE_VIDEO_SNR_MASK        );
+            rsp->atv_status.afc_freq       = (((( ( (rspbytebuffer[4]  ) | (rspbytebuffer[5]  << 8 )) >> SI2196_ATV_STATUS_RESPONSE_AFC_FREQ_LSB         ) & SI2196_ATV_STATUS_RESPONSE_AFC_FREQ_MASK) <<SI2196_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>SI2196_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT         );
+            rsp->atv_status.video_sc_spacing = (((( ( (rspbytebuffer[6]  ) | (rspbytebuffer[7]  << 8 )) >> SI2196_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_LSB ) & SI2196_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_MASK) <<SI2196_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT ) >>SI2196_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT );
+            rsp->atv_status.video_sys    =   (( ( (rspbytebuffer[8]  )) >> SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB        ) & SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK        );
+            rsp->atv_status.color            =   (( ( (rspbytebuffer[8]  )) >> SI2196_ATV_STATUS_RESPONSE_COLOR_LSB            ) & SI2196_ATV_STATUS_RESPONSE_COLOR_MASK            );
+            rsp->atv_status.trans            =   (( ( (rspbytebuffer[8]  )) >> SI2196_ATV_STATUS_RESPONSE_TRANS_LSB            ) & SI2196_ATV_STATUS_RESPONSE_TRANS_MASK            );
+            rsp->atv_status.audio_sys    =   (( ( (rspbytebuffer[9]  )) >> SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_LSB        ) & SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_MASK        );
+            rsp->atv_status.audio_chan_bw    =   (( ( (rspbytebuffer[10] )) >> SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_LSB    ) & SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_MASK    );
+        }
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_ATV_STATUS_CMD */
+#ifdef    SI2196_SD_STATUS_CMD
+ /*---------------------------------------------------*/
+/* SI2196_SD_STATUS COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char si2196_sd_status(struct i2c_client *si2196,si2196_cmdreplyobj_t *rsp, unsigned char   intack)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[8];
+
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((intack > SI2196_SD_STATUS_CMD_INTACK_MAX) )
+    {
+            error_code++;
+            pr_info("\nOut of range: ");
+    }
+    pr_info("INTACK %d ", intack );
+    if (error_code) {
+      pr_info("%s:%d out of range parameters\n", __func__,error_code);
+      return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        return error_code;
+    }
+    cmdByteBuffer[0] = SI2196_SD_STATUS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( intack & SI2196_SD_STATUS_CMD_INTACK_MASK ) << SI2196_SD_STATUS_CMD_INTACK_LSB);
+
+    if (si2196_writecommandbytes(si2196, 2, cmdByteBuffer) != 2) {
+      pr_info("%s:Error writing SD_STATUS bytes!\n",__func__);
+      return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    error_code = si2196_pollforresponse(si2196, 1, 8, rspByteBuffer, &reply);
+    rsp->reply = &reply;
+    if (error_code) {
+      pr_info("%s:Error polling SD_STATUS response.\n",__func__);
+      return error_code;
+    }
+    rsp->sd_status.asdcint               =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_STATUS_RESPONSE_ASDCINT_LSB               ) & SI2196_SD_STATUS_RESPONSE_ASDCINT_MASK               );
+    rsp->sd_status.nicamint             =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_STATUS_RESPONSE_NICAMINT_LSB              ) & SI2196_SD_STATUS_RESPONSE_NICAMINT_MASK              );
+    rsp->sd_status.pcmint                =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_STATUS_RESPONSE_PCMINT_LSB                ) & SI2196_SD_STATUS_RESPONSE_PCMINT_MASK                );
+    rsp->sd_status.scmint                =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_STATUS_RESPONSE_SCMINT_LSB                ) & SI2196_SD_STATUS_RESPONSE_SCMINT_MASK                );
+    rsp->sd_status.odmint                =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_STATUS_RESPONSE_ODMINT_LSB                ) & SI2196_SD_STATUS_RESPONSE_ODMINT_MASK                );
+    rsp->sd_status.afcmint               =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_STATUS_RESPONSE_AFCMINT_LSB               ) & SI2196_SD_STATUS_RESPONSE_AFCMINT_MASK               );
+    rsp->sd_status.ssint                   =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_STATUS_RESPONSE_SSINT_LSB                 ) & SI2196_SD_STATUS_RESPONSE_SSINT_MASK                 );
+    rsp->sd_status.agcsint               =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_STATUS_RESPONSE_AGCSINT_LSB               ) & SI2196_SD_STATUS_RESPONSE_AGCSINT_MASK               );
+    rsp->sd_status.asdc                   =   (( ( (rspByteBuffer[2]  )) >> SI2196_SD_STATUS_RESPONSE_ASDC_LSB                  ) & SI2196_SD_STATUS_RESPONSE_ASDC_MASK                  );
+    rsp->sd_status.nicam                 =   (( ( (rspByteBuffer[2]  )) >> SI2196_SD_STATUS_RESPONSE_NICAM_LSB                 ) & SI2196_SD_STATUS_RESPONSE_NICAM_MASK                 );
+    rsp->sd_status.pcm                   =   (( ( (rspByteBuffer[2]  )) >> SI2196_SD_STATUS_RESPONSE_PCM_LSB                   ) & SI2196_SD_STATUS_RESPONSE_PCM_MASK                   );
+    rsp->sd_status.scm                   =   (( ( (rspByteBuffer[2]  )) >> SI2196_SD_STATUS_RESPONSE_SCM_LSB                   ) & SI2196_SD_STATUS_RESPONSE_SCM_MASK                   );
+    rsp->sd_status.odm                   =   (( ( (rspByteBuffer[2]  )) >> SI2196_SD_STATUS_RESPONSE_ODM_LSB                   ) & SI2196_SD_STATUS_RESPONSE_ODM_MASK                   );
+    rsp->sd_status.afcm                  =   (( ( (rspByteBuffer[2]  )) >> SI2196_SD_STATUS_RESPONSE_AFCM_LSB                  ) & SI2196_SD_STATUS_RESPONSE_AFCM_MASK                  );
+    rsp->sd_status.agcs                  =   (( ( (rspByteBuffer[2]  )) >> SI2196_SD_STATUS_RESPONSE_AGCS_LSB                  ) & SI2196_SD_STATUS_RESPONSE_AGCS_MASK                  );
+    rsp->sd_status.sound_mode_detected   =   (( ( (rspByteBuffer[3]  )) >> SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_LSB   ) & SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_MASK   );
+    rsp->sd_status.sound_system_detected =   (( ( (rspByteBuffer[3]  )) >> SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_LSB ) & SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_MASK );
+    rsp->sd_status.sap_detected          =   (( ( (rspByteBuffer[3]  )) >> SI2196_SD_STATUS_RESPONSE_SAP_DETECTED_LSB          ) & SI2196_SD_STATUS_RESPONSE_SAP_DETECTED_MASK          );
+    rsp->sd_status.over_dev              =   (( ( (rspByteBuffer[4]  )) >> SI2196_SD_STATUS_RESPONSE_OVER_DEV_LSB              ) & SI2196_SD_STATUS_RESPONSE_OVER_DEV_MASK              );
+    rsp->sd_status.sd_agc                =   (( ( (rspByteBuffer[5]  )) >> SI2196_SD_STATUS_RESPONSE_SD_AGC_LSB                ) & SI2196_SD_STATUS_RESPONSE_SD_AGC_MASK                );
+    rsp->sd_status.sif_agc               =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> SI2196_SD_STATUS_RESPONSE_SIF_AGC_LSB               ) & SI2196_SD_STATUS_RESPONSE_SIF_AGC_MASK               );
+
+    return NO_SI2196_ERROR;
+}
+#endif /* SI2196_SD_STATUS_CMD */
+#ifdef SI2196_SD_NICAM_STATUS_CMD
+unsigned char si2196_sd_nicam_status(struct i2c_client *si2196,si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[4];
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        return error_code;
+    }
+    cmdByteBuffer[0] = SI2196_SD_NICAM_STATUS_CMD;
+    if (si2196_writecommandbytes(si2196, 1, cmdByteBuffer) != 1) {
+      pr_info("%s:Error writing sd_nicam_status bytes!\n",__func__);
+      return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    error_code = si2196_pollforresponse(si2196, 1, 4, rspByteBuffer, &reply);
+    if (error_code) {
+        pr_info("%s:Error polling.\n",__func__);
+      return error_code;
+    }
+    rsp->sd_nicam_status.mode              =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_NICAM_STATUS_RESPONSE_MODE_LSB        ) & SI2196_SD_NICAM_STATUS_RESPONSE_MODE_MASK        );
+    rsp->sd_nicam_status.mono_backup =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_NICAM_STATUS_RESPONSE_MONO_BACKUP_LSB ) & SI2196_SD_NICAM_STATUS_RESPONSE_MONO_BACKUP_MASK );
+    rsp->sd_nicam_status.rss                  =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_NICAM_STATUS_RESPONSE_RSS_LSB         ) & SI2196_SD_NICAM_STATUS_RESPONSE_RSS_MASK         );
+    rsp->sd_nicam_status.locked             =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_NICAM_STATUS_RESPONSE_LOCKED_LSB      ) & SI2196_SD_NICAM_STATUS_RESPONSE_LOCKED_MASK      );
+    rsp->sd_nicam_status.errors             =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> SI2196_SD_NICAM_STATUS_RESPONSE_ERRORS_LSB      ) & SI2196_SD_NICAM_STATUS_RESPONSE_ERRORS_MASK      );
+    rsp->reply  = &reply;
+    return NO_SI2196_ERROR;
+}
+#endif /* SI2196_SD_NICAM_STATUS_CMD */
+#ifdef    SI2196_SD_CARRIER_CNR_CMD
+ /*---------------------------------------------------*/
+/* SI2196_SD_CARRIER_CNR COMMAND                   */
+/*---------------------------------------------------*/
+unsigned char si2196_sd_carrier_cnr(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[3];
+
+    cmdByteBuffer[0] = SI2196_SD_CARRIER_CNR_CMD;
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        return error_code;
+    }
+    if (si2196_writecommandbytes(si2196, 1, cmdByteBuffer) != 1)
+    {
+        pr_info("%s:Error writing sd_carrier_cnr bytes!\n",__func__);
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    error_code = si2196_pollforresponse(si2196, 1, 3, rspByteBuffer, &reply);
+    if (error_code)
+    {
+        pr_info("%s: poll for response error:%d!!!!\n", __func__, error_code);
+      return error_code;
+    }
+
+    rsp->sd_carrier_cnr.primary   =   (( ( (rspByteBuffer[1]  )) >> SI2196_SD_CARRIER_CNR_RESPONSE_PRIMARY_LSB   ) & SI2196_SD_CARRIER_CNR_RESPONSE_PRIMARY_MASK   );
+    rsp->sd_carrier_cnr.secondary =   (( ( (rspByteBuffer[2]  )) >> SI2196_SD_CARRIER_CNR_RESPONSE_SECONDARY_LSB ) & SI2196_SD_CARRIER_CNR_RESPONSE_SECONDARY_MASK );
+    rsp->reply = &reply;
+    return NO_SI2196_ERROR;
+}
+#endif /* SI2196_SD_CARRIER_CNR_CMD */
+#ifdef    SI2196_SD_AFC_CMD
+ /*---------------------------------------------------*/
+/* SI2196_SD_AFC COMMAND                           */
+/*---------------------------------------------------*/
+unsigned char si2196_sd_afc(struct i2c_client  *si2196, si2196_cmdreplyobj_t * rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[3];
+
+    cmdByteBuffer[0] = SI2196_SD_AFC_CMD;
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        return error_code;
+    }
+    if (si2196_writecommandbytes(si2196, 1, cmdByteBuffer) != 1)
+    {
+        pr_info("%s:Error writing sd_afc bytes!\n",__func__);
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    error_code = si2196_pollforresponse(si2196, 1, 3, rspByteBuffer, &reply);
+    if (error_code)
+    {
+      pr_info("%s:Error polling SD_AFC response.\n",__func__);
+      return error_code;
+    }
+
+    rsp->sd_afc.afc = (((( ( (rspByteBuffer[2]  )) >> SI2196_SD_AFC_RESPONSE_AFC_LSB ) & SI2196_SD_AFC_RESPONSE_AFC_MASK) <<SI2196_SD_AFC_RESPONSE_AFC_SHIFT ) >>SI2196_SD_AFC_RESPONSE_AFC_SHIFT );
+    rsp->reply = &reply;
+    return NO_SI2196_ERROR;
+}
+#endif /* SI2196_SD_AFC_CMD */
+#ifdef    SI2196_SD_STEREO_ID_LVL_CMD
+ /*---------------------------------------------------*/
+/* SI2196_SD_STEREO_ID_LVL COMMAND                 */
+/*---------------------------------------------------*/
+unsigned char si2196_sd_stereo_id_lvl (struct i2c_client *si2196,si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[4];
+
+    cmdByteBuffer[0] = SI2196_SD_STEREO_ID_LVL_CMD;
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        return error_code;
+    }
+    if (si2196_writecommandbytes(si2196, 1, cmdByteBuffer) != 1)
+    {
+        pr_info("%s:Error writing SD_STEREO_ID_LVL bytes!\n",__func__);
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    error_code = si2196_pollforresponse(si2196, 1, 4, rspByteBuffer, &reply);
+    if (error_code)
+    {
+      pr_info("%s:Error polling SD_AFC response.\n",__func__);
+      return error_code;
+    }
+    rsp->sd_stereo_id_lvl.id_lvl =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> SI2196_SD_STEREO_ID_LVL_RESPONSE_ID_LVL_LSB ) & SI2196_SD_STEREO_ID_LVL_RESPONSE_ID_LVL_MASK );
+    rsp->reply = &reply;
+    return NO_SI2196_ERROR;
+}
+#endif /* SI2196_SD_STEREO_ID_LVL_CMD */
+#ifdef    SI2196_SD_DUAL_MONO_ID_LVL_CMD
+ /*---------------------------------------------------*/
+/* SI2196_SD_DUAL_MONO_ID_LVL COMMAND              */
+/*---------------------------------------------------*/
+unsigned char si2196_sd_dual_mono_id_lvl (struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[4];
+
+    cmdByteBuffer[0] = SI2196_SD_DUAL_MONO_ID_LVL_CMD;
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        return error_code;
+    }
+    if (si2196_writecommandbytes(si2196, 1, cmdByteBuffer) != 1)
+    {
+        pr_info("%s:Error writing SI2196_SD_DUAL_MONO_ID_LVL bytes!\n",__func__);
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    error_code = si2196_pollforresponse(si2196, 1, 4, rspByteBuffer, &reply);
+    if (error_code)
+    {
+      pr_info("%s:Error polling SI2196_SD_DUAL_MONO_ID_LVL response.\n",__func__);
+      return error_code;
+    }
+    rsp->sd_dual_mono_id_lvl.id_lvl =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> SI2196_SD_DUAL_MONO_ID_LVL_RESPONSE_ID_LVL_LSB ) & SI2196_SD_DUAL_MONO_ID_LVL_RESPONSE_ID_LVL_MASK );
+    rsp->reply = &reply;
+    return NO_SI2196_ERROR;
+}
+#endif /* SI2196_SD_DUAL_MONO_ID_LVL_CMD */
+#ifdef    SI2196_SD_CASD_CMD
+ /*---------------------------------------------------*/
+/* SI2196_SD_CASD COMMAND                          */
+/*---------------------------------------------------*/
+unsigned char si2196_sd_casd(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[3];
+
+    cmdByteBuffer[0] = SI2196_SD_CASD_CMD;
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        return error_code;
+    }
+    if (si2196_writecommandbytes(si2196, 1, cmdByteBuffer) != 1)
+    {
+        pr_info("%s:Error writing SI2196_SD_CASD_CMD bytes!\n",__func__);
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    error_code = si2196_pollforresponse(si2196, 1, 3, rspByteBuffer, &reply);
+    if (error_code)
+    {
+      pr_info("%s:Error polling SI2196_SD_DUAL_MONO_ID_LVL response.\n",__func__);
+      return error_code;
+    }
+    rsp->sd_casd.casd =   (( ( (rspByteBuffer[2]  )) >> SI2196_SD_CASD_RESPONSE_CASD_LSB ) & SI2196_SD_CASD_RESPONSE_CASD_MASK );
+    rsp->reply = &reply;
+    return NO_SI2196_ERROR;
+}
+#endif /* SI2196_SD_CASD_CMD */
+
+
+#ifdef SI2196_CONFIG_PINS_CMD
+/*---------------------------------------------------*/
+/* SI2196_CONFIG_PINS COMMAND                      */
+/*---------------------------------------------------*/
+static unsigned char si2196_config_pins(struct i2c_client *si2196,
+        unsigned char   gpio1_mode,
+        unsigned char   gpio1_read,
+        unsigned char   gpio2_mode,
+        unsigned char   gpio2_read,
+        unsigned char   gpio3_mode,
+        unsigned char   gpio3_read,
+        unsigned char   bclk1_mode,
+        unsigned char   bclk1_read,
+        unsigned char   xout_mode,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[6];
+    unsigned char rspbytebuffer[6];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (gpio1_mode > SI2196_CONFIG_PINS_CMD_GPIO1_MODE_MAX)
+            || (gpio1_read > SI2196_CONFIG_PINS_CMD_GPIO1_READ_MAX)
+            || (gpio2_mode > SI2196_CONFIG_PINS_CMD_GPIO2_MODE_MAX)
+            || (gpio2_read > SI2196_CONFIG_PINS_CMD_GPIO2_READ_MAX)
+            || (gpio3_mode > SI2196_CONFIG_PINS_CMD_GPIO3_MODE_MAX)
+            || (gpio3_read > SI2196_CONFIG_PINS_CMD_GPIO3_READ_MAX)
+            || (bclk1_mode > SI2196_CONFIG_PINS_CMD_BCLK1_MODE_MAX)
+            || (bclk1_read > SI2196_CONFIG_PINS_CMD_BCLK1_READ_MAX)
+            || (xout_mode  > SI2196_CONFIG_PINS_CMD_XOUT_MODE_MAX ) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_CONFIG_PINS_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( gpio1_mode & SI2196_CONFIG_PINS_CMD_GPIO1_MODE_MASK ) << SI2196_CONFIG_PINS_CMD_GPIO1_MODE_LSB|
+                                         ( gpio1_read & SI2196_CONFIG_PINS_CMD_GPIO1_READ_MASK ) << SI2196_CONFIG_PINS_CMD_GPIO1_READ_LSB);
+    cmdbytebuffer[2] = (unsigned char) ( ( gpio2_mode & SI2196_CONFIG_PINS_CMD_GPIO2_MODE_MASK ) << SI2196_CONFIG_PINS_CMD_GPIO2_MODE_LSB|
+                                         ( gpio2_read & SI2196_CONFIG_PINS_CMD_GPIO2_READ_MASK ) << SI2196_CONFIG_PINS_CMD_GPIO2_READ_LSB);
+    cmdbytebuffer[3] = (unsigned char) ( ( gpio3_mode & SI2196_CONFIG_PINS_CMD_GPIO3_MODE_MASK ) << SI2196_CONFIG_PINS_CMD_GPIO3_MODE_LSB|
+                                         ( gpio3_read & SI2196_CONFIG_PINS_CMD_GPIO3_READ_MASK ) << SI2196_CONFIG_PINS_CMD_GPIO3_READ_LSB);
+    cmdbytebuffer[4] = (unsigned char) ( ( bclk1_mode & SI2196_CONFIG_PINS_CMD_BCLK1_MODE_MASK ) << SI2196_CONFIG_PINS_CMD_BCLK1_MODE_LSB|
+                                         ( bclk1_read & SI2196_CONFIG_PINS_CMD_BCLK1_READ_MASK ) << SI2196_CONFIG_PINS_CMD_BCLK1_READ_LSB);
+    cmdbytebuffer[5] = (unsigned char) ( ( xout_mode  & SI2196_CONFIG_PINS_CMD_XOUT_MODE_MASK  ) << SI2196_CONFIG_PINS_CMD_XOUT_MODE_LSB );
+
+    if (si2196_writecommandbytes(si2196, 6, cmdbytebuffer) != 6)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 6, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+        if (!error_code)
+        {
+            rsp->config_pins.gpio1_mode  =   (( ( (rspbytebuffer[1]  )) >> SI2196_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB  ) & SI2196_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK  );
+            rsp->config_pins.gpio1_state =   (( ( (rspbytebuffer[1]  )) >> SI2196_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB ) & SI2196_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK );
+            rsp->config_pins.gpio2_mode  =   (( ( (rspbytebuffer[2]  )) >> SI2196_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB  ) & SI2196_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK  );
+            rsp->config_pins.gpio2_state =   (( ( (rspbytebuffer[2]  )) >> SI2196_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB ) & SI2196_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK );
+            rsp->config_pins.gpio3_mode  =   (( ( (rspbytebuffer[3]  )) >> SI2196_CONFIG_PINS_RESPONSE_GPIO3_MODE_LSB  ) & SI2196_CONFIG_PINS_RESPONSE_GPIO3_MODE_MASK  );
+            rsp->config_pins.gpio3_state =   (( ( (rspbytebuffer[3]  )) >> SI2196_CONFIG_PINS_RESPONSE_GPIO3_STATE_LSB ) & SI2196_CONFIG_PINS_RESPONSE_GPIO3_STATE_MASK );
+            rsp->config_pins.bclk1_mode  =   (( ( (rspbytebuffer[4]  )) >> SI2196_CONFIG_PINS_RESPONSE_BCLK1_MODE_LSB  ) & SI2196_CONFIG_PINS_RESPONSE_BCLK1_MODE_MASK  );
+            rsp->config_pins.bclk1_state =   (( ( (rspbytebuffer[4]  )) >> SI2196_CONFIG_PINS_RESPONSE_BCLK1_STATE_LSB ) & SI2196_CONFIG_PINS_RESPONSE_BCLK1_STATE_MASK );
+            rsp->config_pins.xout_mode   =   (( ( (rspbytebuffer[5]  )) >> SI2196_CONFIG_PINS_RESPONSE_XOUT_MODE_LSB   ) & SI2196_CONFIG_PINS_RESPONSE_XOUT_MODE_MASK   );
+        }
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_CONFIG_PINS_CMD */
+#ifdef SI2196_EXIT_BOOTLOADER_CMD
+/*---------------------------------------------------*/
+/* SI2196_EXIT_BOOTLOADER COMMAND                  */
+/*---------------------------------------------------*/
+static unsigned char si2196_exit_bootloader(struct i2c_client *si2196,
+        unsigned char   func,
+        unsigned char   ctsien,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[2];
+    unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (func   > SI2196_EXIT_BOOTLOADER_CMD_FUNC_MAX  )
+            || (ctsien > SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_MAX) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code) goto exit;
+
+    cmdbytebuffer[0] = SI2196_EXIT_BOOTLOADER_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( func   & SI2196_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << SI2196_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+                                         ( ctsien & SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+
+    if (si2196_writecommandbytes(si2196, 2, cmdbytebuffer) != 2)
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_EXIT_BOOTLOADER_CMD */
+#ifdef SI2196_FINE_TUNE_CMD
+/*---------------------------------------------------*/
+/* SI2196_FINE_TUNE COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char si2196_fine_tune(struct i2c_client *si2196,
+        unsigned char   reserved,
+        int   offset_500hz,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[4];
+    unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (reserved     > SI2196_FINE_TUNE_CMD_RESERVED_MAX    )
+            || (offset_500hz > SI2196_FINE_TUNE_CMD_OFFSET_500HZ_MAX)  || (offset_500hz < SI2196_FINE_TUNE_CMD_OFFSET_500HZ_MIN) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_FINE_TUNE_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( reserved     & SI2196_FINE_TUNE_CMD_RESERVED_MASK     ) << SI2196_FINE_TUNE_CMD_RESERVED_LSB    );
+    cmdbytebuffer[2] = (unsigned char) ( ( offset_500hz & SI2196_FINE_TUNE_CMD_OFFSET_500HZ_MASK ) << SI2196_FINE_TUNE_CMD_OFFSET_500HZ_LSB);
+    cmdbytebuffer[3] = (unsigned char) ((( offset_500hz & SI2196_FINE_TUNE_CMD_OFFSET_500HZ_MASK ) << SI2196_FINE_TUNE_CMD_OFFSET_500HZ_LSB)>>8);
+
+    if (si2196_writecommandbytes(si2196, 4, cmdbytebuffer) != 4)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_FINE_TUNE_CMD */
+#ifdef SI2196_GET_PROPERTY_CMD
+/*---------------------------------------------------*/
+/* SI2196_GET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char si2196_get_property(struct i2c_client *si2196,
+        unsigned char   reserved,
+        unsigned int    prop,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[4];
+    unsigned char rspbytebuffer[4];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (reserved > SI2196_GET_PROPERTY_CMD_RESERVED_MAX) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_GET_PROPERTY_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( reserved & SI2196_GET_PROPERTY_CMD_RESERVED_MASK ) << SI2196_GET_PROPERTY_CMD_RESERVED_LSB);
+    cmdbytebuffer[2] = (unsigned char) ( ( prop     & SI2196_GET_PROPERTY_CMD_PROP_MASK     ) << SI2196_GET_PROPERTY_CMD_PROP_LSB    );
+    cmdbytebuffer[3] = (unsigned char) ((( prop     & SI2196_GET_PROPERTY_CMD_PROP_MASK     ) << SI2196_GET_PROPERTY_CMD_PROP_LSB    )>>8);
+
+    if (si2196_writecommandbytes(si2196, 4, cmdbytebuffer) != 4)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 4, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+        if (!error_code)
+        {
+            rsp->get_property.reserved =   (( ( (rspbytebuffer[1]  )) >> SI2196_GET_PROPERTY_RESPONSE_RESERVED_LSB ) & SI2196_GET_PROPERTY_RESPONSE_RESERVED_MASK );
+            rsp->get_property.data     =   (( ( (rspbytebuffer[2]  ) | (rspbytebuffer[3]  << 8 )) >> SI2196_GET_PROPERTY_RESPONSE_DATA_LSB     ) & SI2196_GET_PROPERTY_RESPONSE_DATA_MASK     );
+        }
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_GET_PROPERTY_CMD */
+#ifdef SI2196_GET_REV_CMD
+/*---------------------------------------------------*/
+/* SI2196_GET_REV COMMAND                          */
+/*---------------------------------------------------*/
+static unsigned char si2196_get_rev(struct i2c_client *si2196,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[1];
+    unsigned char rspbytebuffer[10];
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code) goto exit;
+
+    cmdbytebuffer[0] = SI2196_GET_REV_CMD;
+
+    if (si2196_writecommandbytes(si2196, 1, cmdbytebuffer) != 1) error_code = ERROR_SI2196_SENDING_COMMAND;
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 10, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+        if (!error_code)
+        {
+            rsp->get_rev.pn       =   (( ( (rspbytebuffer[1]  )) >> SI2196_GET_REV_RESPONSE_PN_LSB       ) & SI2196_GET_REV_RESPONSE_PN_MASK       );
+            rsp->get_rev.fwmajor  =   (( ( (rspbytebuffer[2]  )) >> SI2196_GET_REV_RESPONSE_FWMAJOR_LSB  ) & SI2196_GET_REV_RESPONSE_FWMAJOR_MASK  );
+            rsp->get_rev.fwminor  =   (( ( (rspbytebuffer[3]  )) >> SI2196_GET_REV_RESPONSE_FWMINOR_LSB  ) & SI2196_GET_REV_RESPONSE_FWMINOR_MASK  );
+            rsp->get_rev.patch    =   (( ( (rspbytebuffer[4]  ) | (rspbytebuffer[5]  << 8 )) >> SI2196_GET_REV_RESPONSE_PATCH_LSB    ) & SI2196_GET_REV_RESPONSE_PATCH_MASK    );
+            rsp->get_rev.cmpmajor =   (( ( (rspbytebuffer[6]  )) >> SI2196_GET_REV_RESPONSE_CMPMAJOR_LSB ) & SI2196_GET_REV_RESPONSE_CMPMAJOR_MASK );
+            rsp->get_rev.cmpminor =   (( ( (rspbytebuffer[7]  )) >> SI2196_GET_REV_RESPONSE_CMPMINOR_LSB ) & SI2196_GET_REV_RESPONSE_CMPMINOR_MASK );
+            rsp->get_rev.cmpbuild =   (( ( (rspbytebuffer[8]  )) >> SI2196_GET_REV_RESPONSE_CMPBUILD_LSB ) & SI2196_GET_REV_RESPONSE_CMPBUILD_MASK );
+            rsp->get_rev.chiprev  =   (( ( (rspbytebuffer[9]  )) >> SI2196_GET_REV_RESPONSE_CHIPREV_LSB  ) & SI2196_GET_REV_RESPONSE_CHIPREV_MASK  );
+        }
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_GET_REV_CMD */
+#ifdef SI2196_PART_INFO_CMD
+/*---------------------------------------------------*/
+/* SI2196_PART_INFO COMMAND                        */
+/*---------------------------------------------------*/
+static unsigned char si2196_part_info(struct i2c_client *si2196,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[1];
+    unsigned char rspbytebuffer[13];
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code) goto exit;
+
+    cmdbytebuffer[0] = SI2196_PART_INFO_CMD;
+
+    if (si2196_writecommandbytes(si2196, 1, cmdbytebuffer) != 1) error_code = ERROR_SI2196_SENDING_COMMAND;
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 13, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+        if (!error_code)
+        {
+            rsp->part_info.chiprev  =   (( ( (rspbytebuffer[1]  )) >> SI2196_PART_INFO_RESPONSE_CHIPREV_LSB  ) & SI2196_PART_INFO_RESPONSE_CHIPREV_MASK  );
+            rsp->part_info.part     =   (( ( (rspbytebuffer[2]  )) >> SI2196_PART_INFO_RESPONSE_PART_LSB     ) & SI2196_PART_INFO_RESPONSE_PART_MASK     );
+            rsp->part_info.pmajor   =   (( ( (rspbytebuffer[3]  )) >> SI2196_PART_INFO_RESPONSE_PMAJOR_LSB   ) & SI2196_PART_INFO_RESPONSE_PMAJOR_MASK   );
+            rsp->part_info.pminor   =   (( ( (rspbytebuffer[4]  )) >> SI2196_PART_INFO_RESPONSE_PMINOR_LSB   ) & SI2196_PART_INFO_RESPONSE_PMINOR_MASK   );
+            rsp->part_info.pbuild   =   (( ( (rspbytebuffer[5]  )) >> SI2196_PART_INFO_RESPONSE_PBUILD_LSB   ) & SI2196_PART_INFO_RESPONSE_PBUILD_MASK   );
+            rsp->part_info.reserved =   (( ( (rspbytebuffer[6]  ) | (rspbytebuffer[7]  << 8 )) >> SI2196_PART_INFO_RESPONSE_RESERVED_LSB ) & SI2196_PART_INFO_RESPONSE_RESERVED_MASK );
+            rsp->part_info.serial   =   (( ( (rspbytebuffer[8]  ) | (rspbytebuffer[9]  << 8 ) | (rspbytebuffer[10] << 16 ) | (rspbytebuffer[11] << 24 )) >> SI2196_PART_INFO_RESPONSE_SERIAL_LSB   ) & SI2196_PART_INFO_RESPONSE_SERIAL_MASK   );
+            rsp->part_info.romid    =   (( ( (rspbytebuffer[12] )) >> SI2196_PART_INFO_RESPONSE_ROMID_LSB    ) & SI2196_PART_INFO_RESPONSE_ROMID_MASK    );
+        }
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_PART_INFO_CMD */
+#ifdef SI2196_POWER_DOWN_CMD
+/*---------------------------------------------------*/
+/* SI2196_POWER_DOWN COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char si2196_power_down(struct i2c_client *si2196,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[1];
+    unsigned char rspbytebuffer[1];
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_POWER_DOWN_CMD;
+
+    if (si2196_writecommandbytes(si2196, 1, cmdbytebuffer) != 1)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_POWER_DOWN_CMD */
+#ifdef SI2196_POWER_UP_CMD
+/*---------------------------------------------------*/
+/* SI2196_POWER_UP COMMAND                         */
+/*---------------------------------------------------*/
+static unsigned char si2196_power_up(struct i2c_client *si2196,
+        unsigned char   subcode,
+        unsigned char   reserved1,
+        unsigned char   reserved2,
+        unsigned char   reserved3,
+        unsigned char   clock_mode,
+        unsigned char   clock_freq,
+        unsigned char   addr_mode,
+        unsigned char   func,
+        unsigned char   ctsien,
+        unsigned char   wake_up,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[9];
+    unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (subcode    > SI2196_POWER_UP_CMD_SUBCODE_MAX   )  || (subcode    < SI2196_POWER_UP_CMD_SUBCODE_MIN   )
+            || (reserved1  > SI2196_POWER_UP_CMD_RESERVED1_MAX )  || (reserved1  < SI2196_POWER_UP_CMD_RESERVED1_MIN )
+            || (reserved2  > SI2196_POWER_UP_CMD_RESERVED2_MAX )
+            || (reserved3  > SI2196_POWER_UP_CMD_RESERVED3_MAX )
+            || (clock_mode > SI2196_POWER_UP_CMD_CLOCK_MODE_MAX)  || (clock_mode < SI2196_POWER_UP_CMD_CLOCK_MODE_MIN)
+            || (clock_freq > SI2196_POWER_UP_CMD_CLOCK_FREQ_MAX)
+            || (addr_mode  > SI2196_POWER_UP_CMD_ADDR_MODE_MAX )
+            || (func       > SI2196_POWER_UP_CMD_FUNC_MAX      )
+            || (ctsien     > SI2196_POWER_UP_CMD_CTSIEN_MAX    )
+            || (wake_up    > SI2196_POWER_UP_CMD_WAKE_UP_MAX   )  || (wake_up    < SI2196_POWER_UP_CMD_WAKE_UP_MIN   ) )
+
+    {
+        if(SI2196_DEBUG)
+            pr_info("%s: DEBUG_RANGE_CHECK!!!!\n", __func__);
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+    }
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_POWER_UP_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( subcode    & SI2196_POWER_UP_CMD_SUBCODE_MASK    ) << SI2196_POWER_UP_CMD_SUBCODE_LSB   );
+    cmdbytebuffer[2] = (unsigned char) ( ( reserved1  & SI2196_POWER_UP_CMD_RESERVED1_MASK  ) << SI2196_POWER_UP_CMD_RESERVED1_LSB );
+    cmdbytebuffer[3] = (unsigned char) ( ( reserved2  & SI2196_POWER_UP_CMD_RESERVED2_MASK  ) << SI2196_POWER_UP_CMD_RESERVED2_LSB );
+    cmdbytebuffer[4] = (unsigned char) ( ( reserved3  & SI2196_POWER_UP_CMD_RESERVED3_MASK  ) << SI2196_POWER_UP_CMD_RESERVED3_LSB );
+    cmdbytebuffer[5] = (unsigned char) ( ( clock_mode & SI2196_POWER_UP_CMD_CLOCK_MODE_MASK ) << SI2196_POWER_UP_CMD_CLOCK_MODE_LSB|
+                                                                ( clock_freq & SI2196_POWER_UP_CMD_CLOCK_FREQ_MASK ) << SI2196_POWER_UP_CMD_CLOCK_FREQ_LSB);
+    cmdbytebuffer[6] = (unsigned char) ( ( addr_mode  & SI2196_POWER_UP_CMD_ADDR_MODE_MASK  ) << SI2196_POWER_UP_CMD_ADDR_MODE_LSB );
+    cmdbytebuffer[7] = (unsigned char) ( ( func       & SI2196_POWER_UP_CMD_FUNC_MASK       ) << SI2196_POWER_UP_CMD_FUNC_LSB      |
+                                                                ( ctsien     & SI2196_POWER_UP_CMD_CTSIEN_MASK     ) << SI2196_POWER_UP_CMD_CTSIEN_LSB    );
+    cmdbytebuffer[8] = (unsigned char) ( ( wake_up    & SI2196_POWER_UP_CMD_WAKE_UP_MASK    ) << SI2196_POWER_UP_CMD_WAKE_UP_LSB   );
+
+    if (si2196_writecommandbytes(si2196, 9, cmdbytebuffer) != 9)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        if (error_code)
+            pr_info("%s: si2196_writecommandbytes!!!!\n", __func__);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+
+        rsp->reply = &reply;
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_POWER_UP_CMD */
+#ifdef SI2196_SD_ADAC_POWER_UP_CMD
+unsigned char si2196_adac_power_up(struct i2c_client *si2196, unsigned char duration, si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[2];
+    unsigned char rspbytebuffer[1];
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_SD_ADAC_POWER_UP_CMD;
+    cmdbytebuffer[1] = duration;
+    if (si2196_writecommandbytes(si2196, 2, cmdbytebuffer) != 2)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+    }
+exit:
+    return error_code;
+}
+#endif
+#ifdef SI2196_SET_PROPERTY_CMD
+/*---------------------------------------------------*/
+/* SI2196_SET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char si2196_set_property(struct i2c_client *si2196,
+        unsigned char   reserved,
+        unsigned int    prop,
+        unsigned int    data,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[6];
+    unsigned char rspbytebuffer[4];
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_SET_PROPERTY_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( reserved & SI2196_SET_PROPERTY_CMD_RESERVED_MASK ) << SI2196_SET_PROPERTY_CMD_RESERVED_LSB);
+    cmdbytebuffer[2] = (unsigned char) ( ( prop     & SI2196_SET_PROPERTY_CMD_PROP_MASK     ) << SI2196_SET_PROPERTY_CMD_PROP_LSB    );
+    cmdbytebuffer[3] = (unsigned char) ((( prop     & SI2196_SET_PROPERTY_CMD_PROP_MASK     ) << SI2196_SET_PROPERTY_CMD_PROP_LSB    )>>8);
+    cmdbytebuffer[4] = (unsigned char) ( ( data     & SI2196_SET_PROPERTY_CMD_DATA_MASK     ) << SI2196_SET_PROPERTY_CMD_DATA_LSB    );
+    cmdbytebuffer[5] = (unsigned char) ((( data     & SI2196_SET_PROPERTY_CMD_DATA_MASK     ) << SI2196_SET_PROPERTY_CMD_DATA_LSB    )>>8);
+
+    if (si2196_writecommandbytes(si2196, 6, cmdbytebuffer) != 6)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 4, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+        if (!error_code)
+        {
+            rsp->set_property.reserved =   (( ( (rspbytebuffer[1]  )) >> SI2196_SET_PROPERTY_RESPONSE_RESERVED_LSB ) & SI2196_SET_PROPERTY_RESPONSE_RESERVED_MASK );
+            rsp->set_property.data     =   (( ( (rspbytebuffer[2]  ) | (rspbytebuffer[3]  << 8 )) >> SI2196_SET_PROPERTY_RESPONSE_DATA_LSB     ) & SI2196_SET_PROPERTY_RESPONSE_DATA_MASK     );
+        }
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_SET_PROPERTY_CMD */
+#ifdef SI2196_STANDBY_CMD
+/*---------------------------------------------------*/
+/* SI2196_STANDBY COMMAND                          */
+/*---------------------------------------------------*/
+static unsigned char si2196_standby(struct i2c_client *si2196,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[1];
+    unsigned char rspbytebuffer[1];
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_STANDBY_CMD;
+
+    if (si2196_writecommandbytes(si2196, 1, cmdbytebuffer) != 1)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_STANDBY_CMD */
+#ifdef SI2196_TUNER_STATUS_CMD
+/*---------------------------------------------------*/
+/* SI2196_TUNER_STATUS COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char si2196_tuner_status(struct i2c_client *si2196,
+        unsigned char   intack,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[2];
+    unsigned char rspbytebuffer[12];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (intack > SI2196_TUNER_STATUS_CMD_INTACK_MAX) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_TUNER_STATUS_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( intack & SI2196_TUNER_STATUS_CMD_INTACK_MASK ) << SI2196_TUNER_STATUS_CMD_INTACK_LSB);
+
+    if (si2196_writecommandbytes(si2196, 2, cmdbytebuffer) != 2)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 12, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+        if (!error_code)
+        {
+            rsp->tuner_status.tcint          = (( ( (rspbytebuffer[1]  )) >> SI2196_TUNER_STATUS_RESPONSE_TCINT_LSB    ) & SI2196_TUNER_STATUS_RESPONSE_TCINT_MASK    );
+            rsp->tuner_status.rssilint      = (( ( (rspbytebuffer[1]  )) >> SI2196_TUNER_STATUS_RESPONSE_RSSILINT_LSB ) & SI2196_TUNER_STATUS_RESPONSE_RSSILINT_MASK );
+            rsp->tuner_status.rssihint     = (( ( (rspbytebuffer[1]  )) >> SI2196_TUNER_STATUS_RESPONSE_RSSIHINT_LSB ) & SI2196_TUNER_STATUS_RESPONSE_RSSIHINT_MASK );
+            rsp->tuner_status.tc              = (( ( (rspbytebuffer[2]  )) >> SI2196_TUNER_STATUS_RESPONSE_TC_LSB       ) & SI2196_TUNER_STATUS_RESPONSE_TC_MASK       );
+            rsp->tuner_status.rssil          = (( ( (rspbytebuffer[2]  )) >> SI2196_TUNER_STATUS_RESPONSE_RSSIL_LSB    ) & SI2196_TUNER_STATUS_RESPONSE_RSSIL_MASK    );
+            rsp->tuner_status.rssih         = (( ( (rspbytebuffer[2]  )) >> SI2196_TUNER_STATUS_RESPONSE_RSSIH_LSB    ) & SI2196_TUNER_STATUS_RESPONSE_RSSIH_MASK    );
+            rsp->tuner_status.rssi           = (((( ( (rspbytebuffer[3]  )) >> SI2196_TUNER_STATUS_RESPONSE_RSSI_LSB     ) & SI2196_TUNER_STATUS_RESPONSE_RSSI_MASK) <<SI2196_TUNER_STATUS_RESPONSE_RSSI_SHIFT ) >>SI2196_TUNER_STATUS_RESPONSE_RSSI_SHIFT     );
+            rsp->tuner_status.freq          = (( ( (rspbytebuffer[4]  ) | (rspbytebuffer[5]  << 8 ) | (rspbytebuffer[6]  << 16 ) | (rspbytebuffer[7]  << 24 )) >> SI2196_TUNER_STATUS_RESPONSE_FREQ_LSB     ) & SI2196_TUNER_STATUS_RESPONSE_FREQ_MASK     );
+            rsp->tuner_status.mode        = (( ( (rspbytebuffer[8]  )) >> SI2196_TUNER_STATUS_RESPONSE_MODE_LSB     ) & SI2196_TUNER_STATUS_RESPONSE_MODE_MASK     );
+            rsp->tuner_status.vco_code = (((( ( (rspbytebuffer[10] ) | (rspbytebuffer[11] << 8 )) >> SI2196_TUNER_STATUS_RESPONSE_VCO_CODE_LSB ) & SI2196_TUNER_STATUS_RESPONSE_VCO_CODE_MASK) <<SI2196_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT ) >>SI2196_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT );
+            //rsp->tuner_status.status       = &reply;
+        }
+    }
+exit:
+    return error_code;
+}
+#endif /* SI2196_TUNER_STATUS_CMD */
+#ifdef SI2196_TUNER_TUNE_FREQ_CMD
+/*---------------------------------------------------*/
+/* SI2196_TUNER_TUNE_FREQ COMMAND                  */
+/*---------------------------------------------------*/
+unsigned char si2196_tuner_tune_freq(struct i2c_client *si2196,
+        unsigned char   mode,
+        unsigned long   freq,
+        si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdbytebuffer[8];
+    unsigned char rspbytebuffer[1];
+
+#ifdef DEBUG_RANGE_CHECK
+    if ( (mode > SI2196_TUNER_TUNE_FREQ_CMD_MODE_MAX)
+            || (freq > SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MAX)  || (freq < SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MIN) )
+        return ERROR_SI2196_PARAMETER_OUT_OF_RANGE;
+#endif /* DEBUG_RANGE_CHECK */
+
+    error_code = si2196_pollforcts(si2196);
+    if (error_code)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, error_code);
+        goto exit;
+    }
+
+    cmdbytebuffer[0] = SI2196_TUNER_TUNE_FREQ_CMD;
+    cmdbytebuffer[1] = (unsigned char) ( ( mode & SI2196_TUNER_TUNE_FREQ_CMD_MODE_MASK ) << SI2196_TUNER_TUNE_FREQ_CMD_MODE_LSB);
+    cmdbytebuffer[2] = (unsigned char)0x00;
+    cmdbytebuffer[3] = (unsigned char)0x00;
+    cmdbytebuffer[4] = (unsigned char) ( ( freq & SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2196_TUNER_TUNE_FREQ_CMD_FREQ_LSB);
+    cmdbytebuffer[5] = (unsigned char) ((( freq & SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2196_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>8);
+    cmdbytebuffer[6] = (unsigned char) ((( freq & SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2196_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>16);
+    cmdbytebuffer[7] = (unsigned char) ((( freq & SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << SI2196_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>24);
+
+    if (si2196_writecommandbytes(si2196, 8, cmdbytebuffer) != 8)
+    {
+        error_code = ERROR_SI2196_SENDING_COMMAND;
+        pr_info("%s: write command byte error:%d!!!!\n", __func__, error_code);
+    }
+
+    if (!error_code)
+    {
+        error_code = si2196_pollforresponse(si2196, 1, 1, rspbytebuffer, &reply);
+        if (error_code)
+            pr_info("%s: poll response error:%d!!!!\n", __func__, error_code);
+        rsp->reply = &reply;
+    }
+    pr_info("%s.\n",__func__);
+exit:
+    return error_code;
+}
+#endif /* SI2196_TUNER_TUNE_FREQ_CMD */
+/* _commands_insertion_point */
+
+/* _send_command2_insertion_start */
+
+/* --------------------------------------------*/
+/* SEND_COMMAND2 FUNCTION                      */
+/* --------------------------------------------*/
+unsigned char si2196_sendcommand(struct i2c_client *si2196, int cmd, si2196_cmdobj_t *c, si2196_cmdreplyobj_t *rsp)
+{
+    switch (cmd)
+    {
+#ifdef SI2196_AGC_OVERRIDE_CMD
+        case SI2196_AGC_OVERRIDE_CMD:
+            return si2196_agc_override(si2196, c->agc_override.force_max_gain, c->agc_override.force_top_gain, rsp);
+        break;
+#endif /*     SI2196_AGC_OVERRIDE_CMD */
+#ifdef SI2196_ATV_CW_TEST_CMD
+        case SI2196_ATV_CW_TEST_CMD:
+            return si2196_atv_cw_test(si2196, c->atv_cw_test.pc_lock, rsp);
+        break;
+#endif /*     SI2196_ATV_CW_TEST_CMD */
+#ifdef SI2196_ATV_RESTART_CMD
+        case SI2196_ATV_RESTART_CMD:
+            return si2196_atv_restart(si2196, c->atv_restart.mode, rsp);
+        break;
+#endif /*     SI2196_ATV_RESTART_CMD */
+#ifdef SI2196_ATV_STATUS_CMD
+        case SI2196_ATV_STATUS_CMD:
+            return si2196_atv_status(si2196, c->atv_status.intack, rsp);
+        break;
+#endif /*     SI2196_ATV_STATUS_CMD */
+#ifdef SI2196_CONFIG_PINS_CMD
+        case SI2196_CONFIG_PINS_CMD:
+            return si2196_config_pins(si2196, c->config_pins.gpio1_mode, c->config_pins.gpio1_read, c->config_pins.gpio2_mode, c->config_pins.gpio2_read, c->config_pins.gpio3_mode, c->config_pins.gpio3_read, c->config_pins.bclk1_mode, c->config_pins.bclk1_read, c->config_pins.xout_mode, rsp);
+        break;
+#endif /*     SI2196_CONFIG_PINS_CMD */
+#ifdef SI2196_EXIT_BOOTLOADER_CMD
+        case SI2196_EXIT_BOOTLOADER_CMD:
+            return si2196_exit_bootloader(si2196, c->exit_bootloader.func, c->exit_bootloader.ctsien, rsp);
+        break;
+#endif /*     SI2196_EXIT_BOOTLOADER_CMD */
+#ifdef SI2196_FINE_TUNE_CMD
+        case SI2196_FINE_TUNE_CMD:
+            return si2196_fine_tune(si2196, c->fine_tune.reserved, c->fine_tune.offset_500hz, rsp);
+        break;
+#endif /*     SI2196_FINE_TUNE_CMD */
+#ifdef SI2196_GET_PROPERTY_CMD
+        case SI2196_GET_PROPERTY_CMD:
+            return si2196_get_property(si2196, c->get_property.reserved, c->get_property.prop, rsp);
+        break;
+#endif /*     SI2196_GET_PROPERTY_CMD */
+#ifdef SI2196_GET_REV_CMD
+        case SI2196_GET_REV_CMD:
+            return si2196_get_rev(si2196, rsp);
+        break;
+#endif /*     SI2196_GET_REV_CMD */
+#ifdef SI2196_PART_INFO_CMD
+        case SI2196_PART_INFO_CMD:
+            return si2196_part_info(si2196, rsp);
+        break;
+#endif /*     SI2196_PART_INFO_CMD */
+#ifdef SI2196_POWER_DOWN_CMD
+        case SI2196_POWER_DOWN_CMD:
+            return si2196_power_down(si2196, rsp);
+        break;
+#endif /*     SI2196_POWER_DOWN_CMD */
+#ifdef SI2196_POWER_UP_CMD
+        case SI2196_POWER_UP_CMD:
+            return si2196_power_up(si2196, c->power_up.subcode, c->power_up.reserved1, c->power_up.reserved2, c->power_up.reserved3, c->power_up.clock_mode, c->power_up.clock_freq, c->power_up.addr_mode, c->power_up.func, c->power_up.ctsien, c->power_up.wake_up, rsp);
+        break;
+#endif /*     SI2196_POWER_UP_CMD */
+#ifdef SI2196_SET_PROPERTY_CMD
+        case SI2196_SET_PROPERTY_CMD:
+            return si2196_set_property(si2196, c->set_property.reserved, c->set_property.prop, c->set_property.data, rsp);
+        break;
+#endif /*     SI2196_SET_PROPERTY_CMD */
+#ifdef SI2196_STANDBY_CMD
+        case SI2196_STANDBY_CMD:
+            return si2196_standby(si2196, rsp);
+        break;
+#endif /*     SI2196_STANDBY_CMD */
+#ifdef SI2196_TUNER_STATUS_CMD
+        case SI2196_TUNER_STATUS_CMD:
+            return si2196_tuner_status(si2196, c->tuner_status.intack, rsp);
+        break;
+#endif /*     SI2196_TUNER_STATUS_CMD */
+#ifdef SI2196_TUNER_TUNE_FREQ_CMD
+        case SI2196_TUNER_TUNE_FREQ_CMD:
+            return si2196_tuner_tune_freq(si2196, c->tuner_tune_freq.mode, c->tuner_tune_freq.freq, rsp);
+        break;
+#endif /*     SI2196_TUNER_TUNE_FREQ_CMD */
+#ifdef SI2196_SD_ADAC_POWER_UP_CMD
+        case SI2196_SD_ADAC_POWER_UP_CMD:
+            return si2196_adac_power_up(si2196, c->sd_adac_power_up.duration, rsp);
+        break;
+#endif
+#ifdef SI2196_SD_AFC_CMD
+        case SI2196_SD_AFC_CMD:
+            return si2196_sd_afc(si2196, rsp);
+        break;
+#endif /* SI2196_SD_AFC_CMD */
+#ifdef SI2196_SD_CARRIER_CNR_CMD
+        case SI2196_SD_CARRIER_CNR_CMD:
+            return si2196_sd_carrier_cnr(si2196, rsp);
+        break;
+#endif /* SI2196_SD_CARRIER_CNR_CMD */
+#ifdef SI2196_SD_CASD_CMD
+        case SI2196_SD_CASD_CMD:
+            return si2196_sd_casd(si2196,rsp);
+        break;
+#endif /* SI2196_SD_CASD_CMD */
+#ifdef SI2196_SD_DUAL_MONO_ID_LVL_CMD
+        case SI2196_SD_DUAL_MONO_ID_LVL_CMD:
+            return si2196_sd_dual_mono_id_lvl(si2196, rsp);
+        break;
+#endif /* SI2196_SD_DUAL_MONO_ID_LVL_CMD */
+#ifdef SI2196_SD_NICAM_STATUS_CMD
+        case SI2196_SD_NICAM_STATUS_CMD:
+            return si2196_sd_nicam_status(si2196,rsp);
+#endif /* SI2196_SD_NICAM_STATUS_CMD */
+#ifdef SI2196_SD_STATUS_CMD
+        case SI2196_SD_STATUS_CMD:
+            return si2196_sd_status(si2196,rsp,c->sd_status.intack);
+        break;
+#endif /* SI2196_SD_STATUS_CMD */
+#ifdef SI2196_SD_STEREO_ID_LVL_CMD
+        case SI2196_SD_STEREO_ID_LVL_CMD:
+            return si2196_sd_stereo_id_lvl(si2196, rsp);
+        break;
+#endif /* SI2196_SD_STEREO_ID_LVL_CMD */
+        default :
+        break;
+    }
+    return 0;
+}
+/* _send_command2_insertion_point */
+
+/***********************************************************************************************************************
+  si2196_setproperty function
+  Use:        property set function
+              Used to call L1_SET_PROPERTY with the property Id and data provided.
+  Comments:   This is a way to make sure CTS is polled when setting a property
+  Parameter: *api     the SI2196 context
+  Parameter: waitforcts flag to wait for a CTS before issuing the property command
+  Parameter: waitforresponse flag to wait for a CTS after issuing the property command
+  Parameter: prop     the property Id
+  Parameter: data     the property bytes
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2196_setproperty(struct i2c_client *si2196, unsigned int prop, int  data, si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char  reserved          = 0;
+    return si2196_set_property(si2196, reserved, prop, data, rsp);
+}
+
+/***********************************************************************************************************************
+  si2196_getproperty function
+  Use:        property get function
+              Used to call L1_GET_PROPERTY with the property Id provided.
+  Comments:   This is a way to make sure CTS is polled when retrieving a property
+  Parameter: *api     the SI2196 context
+  Parameter: waitforcts flag to wait for a CTS before issuing the property command
+  Parameter: waitforresponse flag to wait for a CTS after issuing the property command
+  Parameter: prop     the property Id
+  Parameter: *data    a buffer to store the property bytes into
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+static unsigned char si2196_getproperty(struct i2c_client *si2196, unsigned int prop, int *data, si2196_cmdreplyobj_t *rsp)
+{
+    unsigned char reserved = 0;
+    unsigned char res;
+    res = si2196_get_property(si2196, reserved, prop, rsp);
+    *data = rsp->get_property.data;
+    return res;
+}
+
+/* _set_property2_insertion_start */
+
+/* --------------------------------------------*/
+/* SET_PROPERTY2 FUNCTION                      */
+/* --------------------------------------------*/
+unsigned char si2196_sendproperty(struct i2c_client *si2196, unsigned int prop, si2196_propobj_t *p, si2196_cmdreplyobj_t *rsp)
+{
+    int data = 0;
+#ifdef    SI2196_GET_PROPERTY_STRING
+    char msg[1000];
+#endif /* SI2196_GET_PROPERTY_STRING */
+    switch (prop)
+    {
+#ifdef SI2196_ATV_AFC_RANGE_PROP
+        case SI2196_ATV_AFC_RANGE_PROP:
+            data = (p->atv_afc_range.range_khz & SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK) << SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+        break;
+#endif /*     SI2196_ATV_AFC_RANGE_PROP */
+#ifdef SI2196_ATV_AGC_SPEED_PROP
+        case SI2196_ATV_AGC_SPEED_PROP:
+            data = (p->atv_agc_speed.if_agc_speed & SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB ;
+        break;
+#endif /*     SI2196_ATV_AGC_SPEED_PROP */
+#ifdef SI2196_ATV_AUDIO_MODE_PROP
+        case SI2196_ATV_AUDIO_MODE_PROP:
+            data = (p->atv_audio_mode.audio_sys  & SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_MASK ) << SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_LSB  |
+                       (p->atv_audio_mode.chan_bw    & SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK   ) << SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB ;
+        break;
+#endif /*     SI2196_ATV_AUDIO_MODE_PROP */
+#ifdef SI2196_ATV_CVBS_OUT_PROP
+        case SI2196_ATV_CVBS_OUT_PROP:
+            data = (p->atv_cvbs_out.offset & SI2196_ATV_CVBS_OUT_PROP_OFFSET_MASK) << SI2196_ATV_CVBS_OUT_PROP_OFFSET_LSB  |
+                       (p->atv_cvbs_out.amp    & SI2196_ATV_CVBS_OUT_PROP_AMP_MASK   ) << SI2196_ATV_CVBS_OUT_PROP_AMP_LSB ;
+        break;
+#endif /*     SI2196_ATV_CVBS_OUT_PROP */
+#ifdef SI2196_ATV_CVBS_OUT_FINE_PROP
+        case SI2196_ATV_CVBS_OUT_FINE_PROP:
+            data = (p->atv_cvbs_out_fine.offset & SI2196_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK) << SI2196_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB  |
+                       (p->atv_cvbs_out_fine.amp    & SI2196_ATV_CVBS_OUT_FINE_PROP_AMP_MASK   ) << SI2196_ATV_CVBS_OUT_FINE_PROP_AMP_LSB ;
+        break;
+#endif /*     SI2196_ATV_CVBS_OUT_FINE_PROP */
+#ifdef SI2196_ATV_IEN_PROP
+        case SI2196_ATV_IEN_PROP:
+            data = (p->atv_ien.chlien  & SI2196_ATV_IEN_PROP_CHLIEN_MASK ) << SI2196_ATV_IEN_PROP_CHLIEN_LSB  |
+                       (p->atv_ien.pclien  & SI2196_ATV_IEN_PROP_PCLIEN_MASK ) << SI2196_ATV_IEN_PROP_PCLIEN_LSB  |
+                       (p->atv_ien.dlien   & SI2196_ATV_IEN_PROP_DLIEN_MASK  ) << SI2196_ATV_IEN_PROP_DLIEN_LSB  |
+                       (p->atv_ien.snrlien & SI2196_ATV_IEN_PROP_SNRLIEN_MASK) << SI2196_ATV_IEN_PROP_SNRLIEN_LSB  |
+                       (p->atv_ien.snrhien & SI2196_ATV_IEN_PROP_SNRHIEN_MASK) << SI2196_ATV_IEN_PROP_SNRHIEN_LSB ;
+        break;
+#endif /*     SI2196_ATV_IEN_PROP */
+#ifdef SI2196_ATV_INT_SENSE_PROP
+        case SI2196_ATV_INT_SENSE_PROP:
+            data = (p->atv_int_sense.chlnegen  & SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_MASK ) << SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+                       (p->atv_int_sense.pclnegen  & SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_MASK ) << SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_LSB  |
+                       (p->atv_int_sense.dlnegen   & SI2196_ATV_INT_SENSE_PROP_DLNEGEN_MASK  ) << SI2196_ATV_INT_SENSE_PROP_DLNEGEN_LSB  |
+                       (p->atv_int_sense.snrlnegen & SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK) << SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB  |
+                       (p->atv_int_sense.snrhnegen & SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK) << SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB  |
+                       (p->atv_int_sense.chlposen  & SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_MASK ) << SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_LSB  |
+                       (p->atv_int_sense.pclposen  & SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_MASK ) << SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_LSB  |
+                       (p->atv_int_sense.dlposen   & SI2196_ATV_INT_SENSE_PROP_DLPOSEN_MASK  ) << SI2196_ATV_INT_SENSE_PROP_DLPOSEN_LSB  |
+                       (p->atv_int_sense.snrlposen & SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK) << SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB  |
+                       (p->atv_int_sense.snrhposen & SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK) << SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB ;
+        break;
+#endif /*     SI2196_ATV_INT_SENSE_PROP */
+#ifdef SI2196_ATV_RF_TOP_PROP
+        case SI2196_ATV_RF_TOP_PROP:
+            data = (p->atv_rf_top.atv_rf_top & SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK) << SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB ;
+        break;
+#endif /*     SI2196_ATV_RF_TOP_PROP */
+#ifdef SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP
+        case SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP:
+            data = (p->atv_rsq_rssi_threshold.lo & SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+                       (p->atv_rsq_rssi_threshold.hi & SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+        break;
+#endif /*     SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef SI2196_ATV_RSQ_SNR_THRESHOLD_PROP
+        case SI2196_ATV_RSQ_SNR_THRESHOLD_PROP:
+            data = (p->atv_rsq_snr_threshold.lo & SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK) << SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB  |
+                       (p->atv_rsq_snr_threshold.hi & SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK) << SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB ;
+        break;
+#endif /*     SI2196_ATV_RSQ_SNR_THRESHOLD_PROP */
+#ifdef SI2196_ATV_SOUND_AGC_LIMIT_PROP
+        case SI2196_ATV_SOUND_AGC_LIMIT_PROP:
+            data = (p->atv_sound_agc_limit.max_gain & SI2196_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK) << SI2196_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB  |
+                       (p->atv_sound_agc_limit.min_gain & SI2196_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK) << SI2196_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB ;
+        break;
+#endif /*     SI2196_ATV_SOUND_AGC_LIMIT_PROP */
+#ifdef SI2196_ATV_VIDEO_EQUALIZER_PROP
+        case SI2196_ATV_VIDEO_EQUALIZER_PROP:
+            data = (p->atv_video_equalizer.slope & SI2196_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK) << SI2196_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB ;
+        break;
+#endif /*     SI2196_ATV_VIDEO_EQUALIZER_PROP */
+#ifdef SI2196_ATV_VIDEO_MODE_PROP
+        case SI2196_ATV_VIDEO_MODE_PROP:
+            data = (p->atv_video_mode.video_sys       & SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK      ) << SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB  |
+                       (p->atv_video_mode.color           & SI2196_ATV_VIDEO_MODE_PROP_COLOR_MASK          ) << SI2196_ATV_VIDEO_MODE_PROP_COLOR_LSB  |
+                       (p->atv_video_mode.trans           & SI2196_ATV_VIDEO_MODE_PROP_TRANS_MASK          ) << SI2196_ATV_VIDEO_MODE_PROP_TRANS_LSB  |
+                       (p->atv_video_mode.invert_signal   & SI2196_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK  ) << SI2196_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB ;
+        break;
+#endif /*     SI2196_ATV_VIDEO_MODE_PROP */
+#ifdef SI2196_ATV_VSNR_CAP_PROP
+        case SI2196_ATV_VSNR_CAP_PROP:
+            data = (p->atv_vsnr_cap.atv_vsnr_cap & SI2196_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK) << SI2196_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB ;
+        break;
+#endif /*     SI2196_ATV_VSNR_CAP_PROP */
+#ifdef SI2196_CRYSTAL_TRIM_PROP
+        case SI2196_CRYSTAL_TRIM_PROP:
+            data = (p->crystal_trim.xo_cap & SI2196_CRYSTAL_TRIM_PROP_XO_CAP_MASK) << SI2196_CRYSTAL_TRIM_PROP_XO_CAP_LSB ;
+        break;
+#endif
+#ifdef SI2196_SD_AFC_MAX_PROP
+        case  SI2196_SD_AFC_MAX_PROP_CODE:
+            data = (p->sd_afc_max.max_afc & SI2196_SD_AFC_MAX_PROP_MAX_AFC_MASK) << SI2196_SD_AFC_MAX_PROP_MAX_AFC_LSB ;
+        break;
+#endif /*     SI2196_SD_AFC_MAX_PROP */
+#ifdef SI2196_SD_AFC_MUTE_PROP
+        case SI2196_SD_AFC_MUTE_PROP_CODE:
+            data = (p->sd_afc_mute.mute_thresh   & SI2196_SD_AFC_MUTE_PROP_MUTE_THRESH_MASK  ) << SI2196_SD_AFC_MUTE_PROP_MUTE_THRESH_LSB  |
+                       (p->sd_afc_mute.unmute_thresh & SI2196_SD_AFC_MUTE_PROP_UNMUTE_THRESH_MASK) << SI2196_SD_AFC_MUTE_PROP_UNMUTE_THRESH_LSB ;
+        break;
+#endif /*     SI2196_SD_AFC_MUTE_PROP */
+#ifdef SI2196_SD_AGC_PROP
+        case SI2196_SD_AGC_PROP_CODE:
+       data = (p->sd_agc.gain   & SI2196_SD_AGC_PROP_GAIN_MASK) << SI2196_SD_AGC_PROP_GAIN_LSB  |
+                  (p->sd_agc.freeze & SI2196_SD_AGC_PROP_FREEZE_MASK) << SI2196_SD_AGC_PROP_FREEZE_LSB ;
+     break;
+#endif /*     SI2196_SD_AGC_PROP */
+#ifdef SI2196_SD_ASD_PROP
+       case  SI2196_SD_ASD_PROP_CODE:
+        data = (p->sd_asd.iterations      & SI2196_SD_ASD_PROP_ITERATIONS_MASK) << SI2196_SD_ASD_PROP_ITERATIONS_LSB  |
+                  (p->sd_asd.enable_nicam_l  & SI2196_SD_ASD_PROP_ENABLE_NICAM_L_MASK ) << SI2196_SD_ASD_PROP_ENABLE_NICAM_L_LSB  |
+                  (p->sd_asd.enable_nicam_dk & SI2196_SD_ASD_PROP_ENABLE_NICAM_DK_MASK) << SI2196_SD_ASD_PROP_ENABLE_NICAM_DK_LSB  |
+                  (p->sd_asd.enable_nicam_i  & SI2196_SD_ASD_PROP_ENABLE_NICAM_I_MASK ) << SI2196_SD_ASD_PROP_ENABLE_NICAM_I_LSB  |
+                  (p->sd_asd.enable_nicam_bg & SI2196_SD_ASD_PROP_ENABLE_NICAM_BG_MASK) << SI2196_SD_ASD_PROP_ENABLE_NICAM_BG_LSB  |
+                  (p->sd_asd.enable_a2_m     & SI2196_SD_ASD_PROP_ENABLE_A2_M_MASK) << SI2196_SD_ASD_PROP_ENABLE_A2_M_LSB  |
+                  (p->sd_asd.enable_a2_dk    & SI2196_SD_ASD_PROP_ENABLE_A2_DK_MASK) << SI2196_SD_ASD_PROP_ENABLE_A2_DK_LSB  |
+                  (p->sd_asd.enable_a2_bg    & SI2196_SD_ASD_PROP_ENABLE_A2_BG_MASK) << SI2196_SD_ASD_PROP_ENABLE_A2_BG_LSB  |
+                  (p->sd_asd.enable_eiaj     & SI2196_SD_ASD_PROP_ENABLE_EIAJ_MASK) << SI2196_SD_ASD_PROP_ENABLE_EIAJ_LSB  |
+                  (p->sd_asd.enable_btsc     & SI2196_SD_ASD_PROP_ENABLE_BTSC_MASK) << SI2196_SD_ASD_PROP_ENABLE_BTSC_LSB ;
+      break;
+#endif /*     SI2196_SD_ASD_PROP */
+#ifdef SI2196_SD_CARRIER_MUTE_PROP
+      case SI2196_SD_CARRIER_MUTE_PROP_CODE:
+        data = (p->sd_carrier_mute.primary_thresh   & SI2196_SD_CARRIER_MUTE_PROP_PRIMARY_THRESH_MASK  ) << SI2196_SD_CARRIER_MUTE_PROP_PRIMARY_THRESH_LSB  |
+                   (p->sd_carrier_mute.secondary_thresh & SI2196_SD_CARRIER_MUTE_PROP_SECONDARY_THRESH_MASK) << SI2196_SD_CARRIER_MUTE_PROP_SECONDARY_THRESH_LSB ;
+      break;
+#endif /*     SI2196_SD_CARRIER_MUTE_PROP */
+#ifdef SI2196_SD_I2S_PROP
+     case  SI2196_SD_I2S_PROP_CODE:
+       data = (p->sd_i2s.lrclk_pol      & SI2196_SD_I2S_PROP_LRCLK_POL_MASK     ) << SI2196_SD_I2S_PROP_LRCLK_POL_LSB  |
+                  (p->sd_i2s.alignment      & SI2196_SD_I2S_PROP_ALIGNMENT_MASK     ) << SI2196_SD_I2S_PROP_ALIGNMENT_LSB  |
+                  (p->sd_i2s.lrclk_rate     & SI2196_SD_I2S_PROP_LRCLK_RATE_MASK    ) << SI2196_SD_I2S_PROP_LRCLK_RATE_LSB  |
+                  (p->sd_i2s.num_bits       & SI2196_SD_I2S_PROP_NUM_BITS_MASK      ) << SI2196_SD_I2S_PROP_NUM_BITS_LSB  |
+                  (p->sd_i2s.sclk_rate      & SI2196_SD_I2S_PROP_SCLK_RATE_MASK     ) << SI2196_SD_I2S_PROP_SCLK_RATE_LSB  |
+                  (p->sd_i2s.drive_strength & SI2196_SD_I2S_PROP_DRIVE_STRENGTH_MASK) << SI2196_SD_I2S_PROP_DRIVE_STRENGTH_LSB ;
+     break;
+#endif /*     SI2196_SD_I2S_PROP */
+#ifdef   SI2196_SD_IEN_PROP
+     case  SI2196_SD_IEN_PROP_CODE:
+       data = (p->sd_ien.asdcien  & SI2196_SD_IEN_PROP_ASDCIEN_MASK ) << SI2196_SD_IEN_PROP_ASDCIEN_LSB  |
+                  (p->sd_ien.nicamien & SI2196_SD_IEN_PROP_NICAMIEN_MASK) << SI2196_SD_IEN_PROP_NICAMIEN_LSB  |
+                  (p->sd_ien.pcmien   & SI2196_SD_IEN_PROP_PCMIEN_MASK  ) << SI2196_SD_IEN_PROP_PCMIEN_LSB  |
+                  (p->sd_ien.scmien   & SI2196_SD_IEN_PROP_SCMIEN_MASK  ) << SI2196_SD_IEN_PROP_SCMIEN_LSB  |
+                  (p->sd_ien.odmien   & SI2196_SD_IEN_PROP_ODMIEN_MASK  ) << SI2196_SD_IEN_PROP_ODMIEN_LSB  |
+                  (p->sd_ien.afcmien  & SI2196_SD_IEN_PROP_AFCMIEN_MASK ) << SI2196_SD_IEN_PROP_AFCMIEN_LSB  |
+                  (p->sd_ien.ssien    & SI2196_SD_IEN_PROP_SSIEN_MASK   ) << SI2196_SD_IEN_PROP_SSIEN_LSB  |
+                  (p->sd_ien.agcsien  & SI2196_SD_IEN_PROP_AGCSIEN_MASK ) << SI2196_SD_IEN_PROP_AGCSIEN_LSB ;
+     break;
+#endif /*     SI2196_SD_IEN_PROP */
+#ifdef SI2196_SD_INT_SENSE_PROP
+     case  SI2196_SD_INT_SENSE_PROP_CODE:
+       data = (p->sd_int_sense.asdcnegen  & SI2196_SD_INT_SENSE_PROP_ASDCNEGEN_MASK ) << SI2196_SD_INT_SENSE_PROP_ASDCNEGEN_LSB  |
+                  (p->sd_int_sense.nicamnegen & SI2196_SD_INT_SENSE_PROP_NICAMNEGEN_MASK) << SI2196_SD_INT_SENSE_PROP_NICAMNEGEN_LSB  |
+                  (p->sd_int_sense.pcmnegen   & SI2196_SD_INT_SENSE_PROP_PCMNEGEN_MASK  ) << SI2196_SD_INT_SENSE_PROP_PCMNEGEN_LSB  |
+                  (p->sd_int_sense.scmnegen   & SI2196_SD_INT_SENSE_PROP_SCMNEGEN_MASK  ) << SI2196_SD_INT_SENSE_PROP_SCMNEGEN_LSB  |
+                  (p->sd_int_sense.odmnegen   & SI2196_SD_INT_SENSE_PROP_ODMNEGEN_MASK  ) << SI2196_SD_INT_SENSE_PROP_ODMNEGEN_LSB  |
+                  (p->sd_int_sense.afcmnegen  & SI2196_SD_INT_SENSE_PROP_AFCMNEGEN_MASK ) << SI2196_SD_INT_SENSE_PROP_AFCMNEGEN_LSB  |
+                  (p->sd_int_sense.agcsnegen  & SI2196_SD_INT_SENSE_PROP_AGCSNEGEN_MASK ) << SI2196_SD_INT_SENSE_PROP_AGCSNEGEN_LSB  |
+                  (p->sd_int_sense.asdcposen  & SI2196_SD_INT_SENSE_PROP_ASDCPOSEN_MASK ) << SI2196_SD_INT_SENSE_PROP_ASDCPOSEN_LSB  |
+                  (p->sd_int_sense.nicamposen & SI2196_SD_INT_SENSE_PROP_NICAMPOSEN_MASK) << SI2196_SD_INT_SENSE_PROP_NICAMPOSEN_LSB  |
+                  (p->sd_int_sense.pcmposen   & SI2196_SD_INT_SENSE_PROP_PCMPOSEN_MASK  ) << SI2196_SD_INT_SENSE_PROP_PCMPOSEN_LSB  |
+                  (p->sd_int_sense.scmposen   & SI2196_SD_INT_SENSE_PROP_SCMPOSEN_MASK  ) << SI2196_SD_INT_SENSE_PROP_SCMPOSEN_LSB  |
+                  (p->sd_int_sense.odmposen   & SI2196_SD_INT_SENSE_PROP_ODMPOSEN_MASK  ) << SI2196_SD_INT_SENSE_PROP_ODMPOSEN_LSB  |
+                  (p->sd_int_sense.afcmposen  & SI2196_SD_INT_SENSE_PROP_AFCMPOSEN_MASK ) << SI2196_SD_INT_SENSE_PROP_AFCMPOSEN_LSB  |
+                  (p->sd_int_sense.agcsposen  & SI2196_SD_INT_SENSE_PROP_AGCSPOSEN_MASK ) << SI2196_SD_INT_SENSE_PROP_AGCSPOSEN_LSB ;
+     break;
+#endif /*     SI2196_SD_INT_SENSE_PROP */
+#ifdef  SI2196_SD_LANG_SELECT_PROP
+     case  SI2196_SD_LANG_SELECT_PROP_CODE:
+       data = (p->sd_lang_select.lang & SI2196_SD_LANG_SELECT_PROP_LANG_MASK) << SI2196_SD_LANG_SELECT_PROP_LANG_LSB ;
+     break;
+#endif /*     SI2196_SD_LANG_SELECT_PROP */
+#ifdef SI2196_SD_NICAM_PROP
+     case SI2196_SD_NICAM_PROP_CODE:
+       data = (p->sd_nicam.num_frames & SI2196_SD_NICAM_PROP_NUM_FRAMES_MASK) << SI2196_SD_NICAM_PROP_NUM_FRAMES_LSB  |
+                  (p->sd_nicam.force_rss  & SI2196_SD_NICAM_PROP_FORCE_RSS_MASK ) << SI2196_SD_NICAM_PROP_FORCE_RSS_LSB ;
+     break;
+#endif /*     SI2196_SD_NICAM_PROP */
+#ifdef SI2196_SD_NICAM_FAILOVER_THRESH_PROP
+     case SI2196_SD_NICAM_FAILOVER_THRESH_PROP_CODE:
+       data = (p->sd_nicam_failover_thresh.errors & SI2196_SD_NICAM_FAILOVER_THRESH_PROP_ERRORS_MASK) << SI2196_SD_NICAM_FAILOVER_THRESH_PROP_ERRORS_LSB ;
+     break;
+#endif /*     SI2196_SD_NICAM_FAILOVER_THRESH_PROP */
+#ifdef SI2196_SD_NICAM_RECOVER_THRESH_PROP
+     case SI2196_SD_NICAM_RECOVER_THRESH_PROP_CODE:
+       data = (p->sd_nicam_recover_thresh.errors & SI2196_SD_NICAM_RECOVER_THRESH_PROP_ERRORS_MASK) << SI2196_SD_NICAM_RECOVER_THRESH_PROP_ERRORS_LSB ;
+     break;
+#endif /*     SI2196_SD_NICAM_RECOVER_THRESH_PROP */
+#ifdef SI2196_SD_OVER_DEV_MODE_PROP
+     case SI2196_SD_OVER_DEV_MODE_PROP_CODE:
+       data = (p->sd_over_dev_mode.mode & SI2196_SD_OVER_DEV_MODE_PROP_MODE_MASK) << SI2196_SD_OVER_DEV_MODE_PROP_MODE_LSB ;
+     break;
+#endif /*     SI2196_SD_OVER_DEV_MODE_PROP */
+#ifdef SI2196_SD_OVER_DEV_MUTE_PROP
+     case SI2196_SD_OVER_DEV_MUTE_PROP_CODE:
+       data = (p->sd_over_dev_mute.mute_thresh   & SI2196_SD_OVER_DEV_MUTE_PROP_MUTE_THRESH_MASK  ) << SI2196_SD_OVER_DEV_MUTE_PROP_MUTE_THRESH_LSB  |
+                  (p->sd_over_dev_mute.unmute_thresh & SI2196_SD_OVER_DEV_MUTE_PROP_UNMUTE_THRESH_MASK) << SI2196_SD_OVER_DEV_MUTE_PROP_UNMUTE_THRESH_LSB ;
+     break;
+#endif /*     SI2196_SD_OVER_DEV_MUTE_PROP */
+#ifdef SI2196_SD_PILOT_LVL_CTRL_PROP
+     case SI2196_SD_PILOT_LVL_CTRL_PROP_CODE:
+       data = (p->sd_pilot_lvl_ctrl.lose_lvl & SI2196_SD_PILOT_LVL_CTRL_PROP_LOSE_LVL_MASK) << SI2196_SD_PILOT_LVL_CTRL_PROP_LOSE_LVL_LSB  |
+                  (p->sd_pilot_lvl_ctrl.acq_lvl  & SI2196_SD_PILOT_LVL_CTRL_PROP_ACQ_LVL_MASK ) << SI2196_SD_PILOT_LVL_CTRL_PROP_ACQ_LVL_LSB ;
+     break;
+#endif /*     SI2196_SD_PILOT_LVL_CTRL_PROP */
+#ifdef SI2196_SD_PORT_CONFIG_PROP
+     case SI2196_SD_PORT_CONFIG_PROP_CODE:
+       data = (p->sd_port_config.port         & SI2196_SD_PORT_CONFIG_PROP_PORT_MASK        ) << SI2196_SD_PORT_CONFIG_PROP_PORT_LSB  |
+                  (p->sd_port_config.balance_mode & SI2196_SD_PORT_CONFIG_PROP_BALANCE_MODE_MASK) << SI2196_SD_PORT_CONFIG_PROP_BALANCE_MODE_LSB ;
+     break;
+#endif /*     SI2196_SD_PORT_CONFIG_PROP */
+#ifdef SI2196_SD_PORT_MUTE_PROP
+     case SI2196_SD_PORT_MUTE_PROP_CODE:
+       data = (p->sd_port_mute.mute & SI2196_SD_PORT_MUTE_PROP_MUTE_MASK) << SI2196_SD_PORT_MUTE_PROP_MUTE_LSB ;
+     break;
+#endif /*     SI2196_SD_PORT_MUTE_PROP */
+#ifdef SI2196_SD_PORT_VOLUME_BALANCE_PROP
+     case SI2196_SD_PORT_VOLUME_BALANCE_PROP_CODE:
+       data = (p->sd_port_volume_balance.balance & SI2196_SD_PORT_VOLUME_BALANCE_PROP_BALANCE_MASK) << SI2196_SD_PORT_VOLUME_BALANCE_PROP_BALANCE_LSB ;
+     break;
+#endif /*     SI2196_SD_PORT_VOLUME_BALANCE_PROP */
+#ifdef SI2196_SD_PORT_VOLUME_LEFT_PROP
+     case SI2196_SD_PORT_VOLUME_LEFT_PROP_CODE:
+       data = (p->sd_port_volume_left.volume & SI2196_SD_PORT_VOLUME_LEFT_PROP_VOLUME_MASK) << SI2196_SD_PORT_VOLUME_LEFT_PROP_VOLUME_LSB ;
+     break;
+    #endif /*     SI2196_SD_PORT_VOLUME_LEFT_PROP */
+#ifdef SI2196_SD_PORT_VOLUME_MASTER_PROP
+     case SI2196_SD_PORT_VOLUME_MASTER_PROP_CODE:
+       data = (p->sd_port_volume_master.volume & SI2196_SD_PORT_VOLUME_MASTER_PROP_VOLUME_MASK) << SI2196_SD_PORT_VOLUME_MASTER_PROP_VOLUME_LSB ;
+     break;
+#endif /*     SI2196_SD_PORT_VOLUME_MASTER_PROP */
+#ifdef SI2196_SD_PORT_VOLUME_RIGHT_PROP
+     case SI2196_SD_PORT_VOLUME_RIGHT_PROP_CODE:
+       data = (p->sd_port_volume_right.volume & SI2196_SD_PORT_VOLUME_RIGHT_PROP_VOLUME_MASK) << SI2196_SD_PORT_VOLUME_RIGHT_PROP_VOLUME_LSB ;
+     break;
+#endif /*     SI2196_SD_PORT_VOLUME_RIGHT_PROP */
+#ifdef SI2196_SD_PRESCALER_AM_PROP
+     case SI2196_SD_PRESCALER_AM_PROP_CODE:
+       data = (p->sd_prescaler_am.gain & SI2196_SD_PRESCALER_AM_PROP_GAIN_MASK) << SI2196_SD_PRESCALER_AM_PROP_GAIN_LSB ;
+     break;
+#endif /*     SI2196_SD_PRESCALER_AM_PROP */
+#ifdef SI2196_SD_PRESCALER_EIAJ_PROP
+     case SI2196_SD_PRESCALER_EIAJ_PROP_CODE:
+       data = (p->sd_prescaler_eiaj.gain & SI2196_SD_PRESCALER_EIAJ_PROP_GAIN_MASK) << SI2196_SD_PRESCALER_EIAJ_PROP_GAIN_LSB ;
+     break;
+#endif /*     SI2196_SD_PRESCALER_EIAJ_PROP */
+#ifdef SI2196_SD_PRESCALER_FM_PROP
+     case SI2196_SD_PRESCALER_FM_PROP_CODE:
+       data = (p->sd_prescaler_fm.gain & SI2196_SD_PRESCALER_FM_PROP_GAIN_MASK) << SI2196_SD_PRESCALER_FM_PROP_GAIN_LSB ;
+     break;
+#endif /*     SI2196_SD_PRESCALER_FM_PROP */
+#ifdef SI2196_SD_PRESCALER_NICAM_PROP
+     case SI2196_SD_PRESCALER_NICAM_PROP_CODE:
+       data = (p->sd_prescaler_nicam.gain & SI2196_SD_PRESCALER_NICAM_PROP_GAIN_MASK) << SI2196_SD_PRESCALER_NICAM_PROP_GAIN_LSB ;
+     break;
+    #endif /*     SI2196_SD_PRESCALER_NICAM_PROP */
+#ifdef SI2196_SD_PRESCALER_SAP_PROP
+     case SI2196_SD_PRESCALER_SAP_PROP_CODE:
+       data = (p->sd_prescaler_sap.gain & SI2196_SD_PRESCALER_SAP_PROP_GAIN_MASK) << SI2196_SD_PRESCALER_SAP_PROP_GAIN_LSB ;
+     break;
+#endif /*     SI2196_SD_PRESCALER_SAP_PROP */
+#ifdef SI2196_SD_SOUND_MODE_PROP
+     case SI2196_SD_SOUND_MODE_PROP_CODE:
+       data = (p->sd_sound_mode.mode & SI2196_SD_SOUND_MODE_PROP_MODE_MASK) << SI2196_SD_SOUND_MODE_PROP_MODE_LSB ;
+     break;
+#endif /*     SI2196_SD_SOUND_MODE_PROP */
+#ifdef SI2196_SD_SOUND_SYSTEM_PROP
+     case SI2196_SD_SOUND_SYSTEM_PROP_CODE:
+       data = (p->sd_sound_system.system & SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_MASK) << SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_LSB ;
+     break;
+#endif /*     SI2196_SD_SOUND_SYSTEM_PROP */
+#ifdef SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP
+     case SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_CODE:
+       data = (p->sd_stereo_dm_id_lvl_acq.acq & SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_ACQ_MASK) << SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_ACQ_LSB ;
+     break;
+    #endif /*     SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP */
+#ifdef SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP
+     case SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_CODE:
+       data = (p->sd_stereo_dm_id_lvl_shift.acq_shift   & SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_ACQ_SHIFT_MASK  ) << SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_ACQ_SHIFT_LSB  |
+                  (p->sd_stereo_dm_id_lvl_shift.track_shift & SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_TRACK_SHIFT_MASK) << SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_TRACK_SHIFT_LSB ;
+     break;
+#endif /*     SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP */
+#ifdef SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP
+     case SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_CODE:
+       data = (p->sd_stereo_dm_id_lvl_track.track & SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_TRACK_MASK) << SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_TRACK_LSB ;
+     break;
+#endif /*     SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP */
+#ifdef SI2196_DTV_LIF_FREQ_PROP
+        case SI2196_DTV_LIF_FREQ_PROP:
+            data = (p->dtv_lif_freq.offset & SI2196_DTV_LIF_FREQ_PROP_OFFSET_MASK) << SI2196_DTV_LIF_FREQ_PROP_OFFSET_LSB ;
+        break;
+#endif /*     SI2196_DTV_LIF_FREQ_PROP */
+#ifdef SI2196_DTV_LIF_OUT_PROP
+        case SI2196_DTV_LIF_OUT_PROP:
+            data = (p->dtv_lif_out.offset & SI2196_DTV_LIF_OUT_PROP_OFFSET_MASK) << SI2196_DTV_LIF_OUT_PROP_OFFSET_LSB  |
+                       (p->dtv_lif_out.amp    & SI2196_DTV_LIF_OUT_PROP_AMP_MASK   ) << SI2196_DTV_LIF_OUT_PROP_AMP_LSB ;
+        break;
+#endif /*     SI2196_DTV_LIF_OUT_PROP */
+#ifdef SI2196_DTV_MODE_PROP
+        case SI2196_DTV_MODE_PROP:
+            data = (p->dtv_mode.bw              & SI2196_DTV_MODE_PROP_BW_MASK             ) << SI2196_DTV_MODE_PROP_BW_LSB  |
+                       (p->dtv_mode.modulation      & SI2196_DTV_MODE_PROP_MODULATION_MASK     ) << SI2196_DTV_MODE_PROP_MODULATION_LSB  |
+                       (p->dtv_mode.invert_spectrum & SI2196_DTV_MODE_PROP_INVERT_SPECTRUM_MASK) << SI2196_DTV_MODE_PROP_INVERT_SPECTRUM_LSB ;
+        break;
+#endif /*     SI2196_DTV_MODE_PROP */
+#ifdef SI2196_DTV_RF_TOP_PROP
+        case SI2196_DTV_RF_TOP_PROP:
+            data = (p->dtv_rf_top.dtv_rf_top & SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK) << SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB ;
+        break;
+#endif /*     SI2196_DTV_RF_TOP_PROP */
+#ifdef SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP
+        case SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP:
+            data = (p->dtv_rsq_rssi_threshold.lo & SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+                       (p->dtv_rsq_rssi_threshold.hi & SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+        break;
+#endif /*     SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef SI2196_MASTER_IEN_PROP
+        case SI2196_MASTER_IEN_PROP:
+            data = (p->master_ien.tunien & SI2196_MASTER_IEN_PROP_TUNIEN_MASK) << SI2196_MASTER_IEN_PROP_TUNIEN_LSB  |
+                       (p->master_ien.atvien & SI2196_MASTER_IEN_PROP_ATVIEN_MASK) << SI2196_MASTER_IEN_PROP_ATVIEN_LSB  |
+                       (p->master_ien.dtvien & SI2196_MASTER_IEN_PROP_DTVIEN_MASK) << SI2196_MASTER_IEN_PROP_DTVIEN_LSB  |
+                       (p->master_ien.sdien  & SI2196_MASTER_IEN_PROP_SDIEN_MASK ) << SI2196_MASTER_IEN_PROP_SDIEN_LSB  |
+                       (p->master_ien.errien & SI2196_MASTER_IEN_PROP_ERRIEN_MASK) << SI2196_MASTER_IEN_PROP_ERRIEN_LSB  |
+                       (p->master_ien.ctsien & SI2196_MASTER_IEN_PROP_CTSIEN_MASK) << SI2196_MASTER_IEN_PROP_CTSIEN_LSB ;
+        break;
+#endif /*     SI2196_MASTER_IEN_PROP */
+#ifdef SI2196_TUNER_BLOCKED_VCO_PROP
+        case SI2196_TUNER_BLOCKED_VCO_PROP:
+            data = (p->tuner_blocked_vco.vco_code & SI2196_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK) << SI2196_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB ;
+        break;
+#endif /*     SI2196_TUNER_BLOCKED_VCO_PROP */
+#ifdef SI2196_TUNER_IEN_PROP
+        case SI2196_TUNER_IEN_PROP:
+            data = (p->tuner_ien.tcien    & SI2196_TUNER_IEN_PROP_TCIEN_MASK   ) << SI2196_TUNER_IEN_PROP_TCIEN_LSB  |
+                       (p->tuner_ien.rssilien & SI2196_TUNER_IEN_PROP_RSSILIEN_MASK) << SI2196_TUNER_IEN_PROP_RSSILIEN_LSB  |
+                       (p->tuner_ien.rssihien & SI2196_TUNER_IEN_PROP_RSSIHIEN_MASK) << SI2196_TUNER_IEN_PROP_RSSIHIEN_LSB ;
+        break;
+#endif /*     SI2196_TUNER_IEN_PROP */
+#ifdef SI2196_TUNER_INT_SENSE_PROP
+        case SI2196_TUNER_INT_SENSE_PROP:
+            data = (p->tuner_int_sense.tcnegen    & SI2196_TUNER_INT_SENSE_PROP_TCNEGEN_MASK   ) << SI2196_TUNER_INT_SENSE_PROP_TCNEGEN_LSB  |
+                       (p->tuner_int_sense.rssilnegen & SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK) << SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB  |
+                       (p->tuner_int_sense.rssihnegen & SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK) << SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB  |
+                       (p->tuner_int_sense.tcposen    & SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_MASK   ) << SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_LSB  |
+                       (p->tuner_int_sense.rssilposen & SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK) << SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB  |
+                       (p->tuner_int_sense.rssihposen & SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK) << SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB ;
+        break;
+#endif /*     SI2196_TUNER_INT_SENSE_PROP */
+#ifdef SI2196_TUNER_LO_INJECTION_PROP
+        case SI2196_TUNER_LO_INJECTION_PROP:
+            data = (p->tuner_lo_injection.band_1 & SI2196_TUNER_LO_INJECTION_PROP_BAND_1_MASK) << SI2196_TUNER_LO_INJECTION_PROP_BAND_1_LSB  |
+                       (p->tuner_lo_injection.band_2 & SI2196_TUNER_LO_INJECTION_PROP_BAND_2_MASK) << SI2196_TUNER_LO_INJECTION_PROP_BAND_2_LSB  |
+                       (p->tuner_lo_injection.band_3 & SI2196_TUNER_LO_INJECTION_PROP_BAND_3_MASK) << SI2196_TUNER_LO_INJECTION_PROP_BAND_3_LSB  |
+                       (p->tuner_lo_injection.band_4 & SI2196_TUNER_LO_INJECTION_PROP_BAND_4_MASK) << SI2196_TUNER_LO_INJECTION_PROP_BAND_4_LSB  |
+                       (p->tuner_lo_injection.band_5 & SI2196_TUNER_LO_INJECTION_PROP_BAND_5_MASK) << SI2196_TUNER_LO_INJECTION_PROP_BAND_5_LSB ;
+        break;
+#endif /*     SI2196_TUNER_LO_INJECTION_PROP */
+#ifdef SI2196_ATV_VSYNC_TRACKING_PROP
+        case SI2196_ATV_VSYNC_TRACKING_PROP:
+            data = (p->atv_vsync_tracking.min_pulses_to_lock   & SI2196_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK  ) << SI2196_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB  |
+                       (p->atv_vsync_tracking.max_relock_retries   & SI2196_ATV_VSYNC_TRACKING_PROP_MAX_RELOCK_RETRIES_MASK  ) << SI2196_ATV_VSYNC_TRACKING_PROP_MAX_RELOCK_RETRIES_LSB  |
+                       (p->atv_vsync_tracking.min_fields_to_unlock & SI2196_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK) << SI2196_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB ;
+         break;
+#endif /*     SI2196_ATV_VSYNC_TRACKING_PROP */
+#ifdef SI2196_ATV_SOUND_AGC_SPEED_PROP_CODE
+        case SI2196_ATV_SOUND_AGC_SPEED_PROP_CODE:
+            data = (p->atv_sound_agc_speed.system_l & SI2196_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK     ) << SI2196_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB  |
+                       (p->atv_sound_agc_speed.other_systems & SI2196_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK) << SI2196_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB ;
+        break;
+#endif
+        default :
+        break;
+    }
+    return si2196_setproperty(si2196, prop , data, rsp);
+}
+/* _set_property2_insertion_point */
+
+/* _get_property2_insertion_start */
+
+/* --------------------------------------------*/
+/* GET_PROPERTY2 FUNCTION                       */
+/* --------------------------------------------*/
+unsigned char si2196_receiveproperty(struct i2c_client *si2196, unsigned int prop, si2196_propobj_t *p, si2196_cmdreplyobj_t *rsp)
+{
+    int data, res;
+
+    res = si2196_getproperty(si2196, prop, &data, rsp);
+
+    if (res!=NO_SI2196_ERROR)
+        return res;
+    switch (prop)
+    {
+#ifdef SI2196_ATV_AFC_RANGE_PROP
+        case SI2196_ATV_AFC_RANGE_PROP:
+            p->atv_afc_range.range_khz = (data >> SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB) & SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK;
+        break;
+#endif /*     SI2196_ATV_AFC_RANGE_PROP */
+#ifdef SI2196_ATV_AF_OUT_PROP
+        case SI2196_ATV_AF_OUT_PROP:
+            p->atv_af_out.volume = (data >> SI2196_ATV_AF_OUT_PROP_VOLUME_LSB) & SI2196_ATV_AF_OUT_PROP_VOLUME_MASK;
+        break;
+#endif /*     SI2196_ATV_AF_OUT_PROP */
+#ifdef SI2196_ATV_AGC_SPEED_PROP
+        case SI2196_ATV_AGC_SPEED_PROP:
+            p->atv_agc_speed.if_agc_speed = (data >> SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB) & SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK;
+        break;
+#endif /*     SI2196_ATV_AGC_SPEED_PROP */
+#ifdef SI2196_ATV_AUDIO_MODE_PROP
+        case SI2196_ATV_AUDIO_MODE_PROP:
+            p->atv_audio_mode.audio_sys      = (data >> SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_LSB ) & SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_MASK;
+            p->atv_audio_mode.chan_bw        = (data >> SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB   ) & SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK;
+        break;
+#endif /*     SI2196_ATV_AUDIO_MODE_PROP */
+#ifdef SI2196_ATV_CVBS_OUT_PROP
+        case SI2196_ATV_CVBS_OUT_PROP:
+            p->atv_cvbs_out.offset = (data >> SI2196_ATV_CVBS_OUT_PROP_OFFSET_LSB) & SI2196_ATV_CVBS_OUT_PROP_OFFSET_MASK;
+            p->atv_cvbs_out.amp   = (data >> SI2196_ATV_CVBS_OUT_PROP_AMP_LSB   ) & SI2196_ATV_CVBS_OUT_PROP_AMP_MASK;
+        break;
+#endif /*     SI2196_ATV_CVBS_OUT_PROP */
+#ifdef SI2196_ATV_CVBS_OUT_FINE_PROP
+        case SI2196_ATV_CVBS_OUT_FINE_PROP:
+            p->atv_cvbs_out_fine.offset = (data >> SI2196_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB) & SI2196_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK;
+            p->atv_cvbs_out_fine.amp   = (data >> SI2196_ATV_CVBS_OUT_FINE_PROP_AMP_LSB   ) & SI2196_ATV_CVBS_OUT_FINE_PROP_AMP_MASK;
+        break;
+#endif /*     SI2196_ATV_CVBS_OUT_FINE_PROP */
+#ifdef SI2196_ATV_IEN_PROP
+        case SI2196_ATV_IEN_PROP:
+            p->atv_ien.chlien   = (data >> SI2196_ATV_IEN_PROP_CHLIEN_LSB ) & SI2196_ATV_IEN_PROP_CHLIEN_MASK;
+            p->atv_ien.pclien   = (data >> SI2196_ATV_IEN_PROP_PCLIEN_LSB ) & SI2196_ATV_IEN_PROP_PCLIEN_MASK;
+            p->atv_ien.dlien     = (data >> SI2196_ATV_IEN_PROP_DLIEN_LSB  ) & SI2196_ATV_IEN_PROP_DLIEN_MASK;
+            p->atv_ien.snrlien  = (data >> SI2196_ATV_IEN_PROP_SNRLIEN_LSB) & SI2196_ATV_IEN_PROP_SNRLIEN_MASK;
+            p->atv_ien.snrhien = (data >> SI2196_ATV_IEN_PROP_SNRHIEN_LSB) & SI2196_ATV_IEN_PROP_SNRHIEN_MASK;
+        break;
+#endif /*     SI2196_ATV_IEN_PROP */
+#ifdef SI2196_ATV_INT_SENSE_PROP
+        case SI2196_ATV_INT_SENSE_PROP:
+            p->atv_int_sense.chlnegen  = (data >> SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_LSB ) & SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_MASK;
+            p->atv_int_sense.pclnegen  = (data >> SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_LSB ) & SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_MASK;
+            p->atv_int_sense.dlnegen    = (data >> SI2196_ATV_INT_SENSE_PROP_DLNEGEN_LSB  ) & SI2196_ATV_INT_SENSE_PROP_DLNEGEN_MASK;
+            p->atv_int_sense.snrlnegen = (data >> SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB) & SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK;
+            p->atv_int_sense.snrhnegen = (data >> SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB) & SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK;
+            p->atv_int_sense.chlposen   = (data >> SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_LSB ) & SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_MASK;
+            p->atv_int_sense.pclposen   = (data >> SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_LSB ) & SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_MASK;
+            p->atv_int_sense.dlposen     = (data >> SI2196_ATV_INT_SENSE_PROP_DLPOSEN_LSB  ) & SI2196_ATV_INT_SENSE_PROP_DLPOSEN_MASK;
+            p->atv_int_sense.snrlposen  = (data >> SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB) & SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK;
+            p->atv_int_sense.snrhposen = (data >> SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB) & SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK;
+        break;
+#endif /*     SI2196_ATV_INT_SENSE_PROP */
+#ifdef SI2196_ATV_MIN_LVL_LOCK_PROP
+        case SI2196_ATV_MIN_LVL_LOCK_PROP:
+            p->atv_min_lvl_lock.thrs = (data >> SI2196_ATV_MIN_LVL_LOCK_PROP_THRS_LSB) & SI2196_ATV_MIN_LVL_LOCK_PROP_THRS_MASK;
+        break;
+#endif /*     SI2196_ATV_MIN_LVL_LOCK_PROP */
+#ifdef SI2196_ATV_RF_TOP_PROP
+        case SI2196_ATV_RF_TOP_PROP:
+            p->atv_rf_top.atv_rf_top = (data >> SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB) & SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK;
+        break;
+#endif /*     SI2196_ATV_RF_TOP_PROP */
+#ifdef SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP
+        case SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP:
+            p->atv_rsq_rssi_threshold.lo = (data >> SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB) & SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK;
+            p->atv_rsq_rssi_threshold.hi = (data >> SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB) & SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK;
+        break;
+#endif /*     SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef SI2196_ATV_RSQ_SNR_THRESHOLD_PROP
+        case SI2196_ATV_RSQ_SNR_THRESHOLD_PROP:
+            p->atv_rsq_snr_threshold.lo = (data >> SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB) & SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK;
+            p->atv_rsq_snr_threshold.hi = (data >> SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB) & SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK;
+        break;
+#endif /*     SI2196_ATV_RSQ_SNR_THRESHOLD_PROP */
+#ifdef SI2196_ATV_SIF_OUT_PROP
+        case SI2196_ATV_SIF_OUT_PROP:
+            p->atv_sif_out.offset  = (data >> SI2196_ATV_SIF_OUT_PROP_OFFSET_LSB) & SI2196_ATV_SIF_OUT_PROP_OFFSET_MASK;
+            p->atv_sif_out.amp    = (data >> SI2196_ATV_SIF_OUT_PROP_AMP_LSB   ) & SI2196_ATV_SIF_OUT_PROP_AMP_MASK;
+        break;
+#endif /*     SI2196_ATV_SIF_OUT_PROP */
+#ifdef SI2196_ATV_SOUND_AGC_LIMIT_PROP
+        case SI2196_ATV_SOUND_AGC_LIMIT_PROP:
+            p->atv_sound_agc_limit.max_gain = (data >> SI2196_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB) & SI2196_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK;
+            p->atv_sound_agc_limit.min_gain  = (data >> SI2196_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB) & SI2196_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK;
+        break;
+#endif /*     SI2196_ATV_SOUND_AGC_LIMIT_PROP */
+#ifdef SI2196_ATV_VIDEO_EQUALIZER_PROP
+        case SI2196_ATV_VIDEO_EQUALIZER_PROP:
+            p->atv_video_equalizer.slope = (data >> SI2196_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB) & SI2196_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK;
+        break;
+#endif /*     SI2196_ATV_VIDEO_EQUALIZER_PROP */
+#ifdef SI2196_ATV_VIDEO_MODE_PROP
+        case SI2196_ATV_VIDEO_MODE_PROP:
+            p->atv_video_mode.video_sys     = (data >> SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB      ) & SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK;
+            p->atv_video_mode.color             = (data >> SI2196_ATV_VIDEO_MODE_PROP_COLOR_LSB          ) & SI2196_ATV_VIDEO_MODE_PROP_COLOR_MASK;
+            p->atv_video_mode.trans             = (data >> SI2196_ATV_VIDEO_MODE_PROP_TRANS_LSB          ) & SI2196_ATV_VIDEO_MODE_PROP_TRANS_MASK;
+            p->atv_video_mode.invert_signal = (data >> SI2196_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB  ) & SI2196_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK;
+        break;
+#endif /*     SI2196_ATV_VIDEO_MODE_PROP */
+#ifdef SI2196_ATV_VSNR_CAP_PROP
+        case SI2196_ATV_VSNR_CAP_PROP:
+            p->atv_vsnr_cap.atv_vsnr_cap = (data >> SI2196_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB) & SI2196_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK;
+        break;
+#endif /*     SI2196_ATV_VSNR_CAP_PROP */
+#ifdef SI2196_ATV_VSYNC_TRACKING_PROP
+        case SI2196_ATV_VSYNC_TRACKING_PROP:
+            p->atv_vsync_tracking.min_pulses_to_lock   = (data >> SI2196_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB  ) & SI2196_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK;
+            p->atv_vsync_tracking.min_fields_to_unlock = (data >> SI2196_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB) & SI2196_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK;
+        break;
+#endif /*     SI2196_ATV_VSYNC_TRACKING_PROP */
+#ifdef SI2196_CRYSTAL_TRIM_PROP
+        case SI2196_CRYSTAL_TRIM_PROP:
+            p->crystal_trim.xo_cap = (data >> SI2196_CRYSTAL_TRIM_PROP_XO_CAP_LSB) & SI2196_CRYSTAL_TRIM_PROP_XO_CAP_MASK;
+        break;
+#endif /*     SI2196_CRYSTAL_TRIM_PROP */
+#ifdef SI2196_MASTER_IEN_PROP
+        case SI2196_MASTER_IEN_PROP:
+            p->master_ien.tunien = (data >> SI2196_MASTER_IEN_PROP_TUNIEN_LSB) & SI2196_MASTER_IEN_PROP_TUNIEN_MASK;
+            p->master_ien.atvien = (data >> SI2196_MASTER_IEN_PROP_ATVIEN_LSB) & SI2196_MASTER_IEN_PROP_ATVIEN_MASK;
+            p->master_ien.dtvien = (data >> SI2196_MASTER_IEN_PROP_DTVIEN_LSB) & SI2196_MASTER_IEN_PROP_DTVIEN_MASK;
+            p->master_ien.errien = (data >> SI2196_MASTER_IEN_PROP_ERRIEN_LSB) & SI2196_MASTER_IEN_PROP_ERRIEN_MASK;
+            p->master_ien.ctsien = (data >> SI2196_MASTER_IEN_PROP_CTSIEN_LSB) & SI2196_MASTER_IEN_PROP_CTSIEN_MASK;
+        break;
+#endif /*     SI2196_MASTER_IEN_PROP */
+#ifdef SI2196_TUNER_BLOCKED_VCO_PROP
+        case SI2196_TUNER_BLOCKED_VCO_PROP:
+            p->tuner_blocked_vco.vco_code = (data >> SI2196_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB) & SI2196_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK;
+        break;
+#endif /*     SI2196_TUNER_BLOCKED_VCO_PROP */
+#ifdef SI2196_TUNER_IEN_PROP
+        case SI2196_TUNER_IEN_PROP:
+            p->tuner_ien.tcien      = (data >> SI2196_TUNER_IEN_PROP_TCIEN_LSB   ) & SI2196_TUNER_IEN_PROP_TCIEN_MASK;
+            p->tuner_ien.rssilien  = (data >> SI2196_TUNER_IEN_PROP_RSSILIEN_LSB) & SI2196_TUNER_IEN_PROP_RSSILIEN_MASK;
+            p->tuner_ien.rssihien = (data >> SI2196_TUNER_IEN_PROP_RSSIHIEN_LSB) & SI2196_TUNER_IEN_PROP_RSSIHIEN_MASK;
+        break;
+#endif /*     SI2196_TUNER_IEN_PROP */
+#ifdef SI2196_TUNER_INT_SENSE_PROP
+        case SI2196_TUNER_INT_SENSE_PROP:
+            p->tuner_int_sense.tcnegen      = (data >> SI2196_TUNER_INT_SENSE_PROP_TCNEGEN_LSB   ) & SI2196_TUNER_INT_SENSE_PROP_TCNEGEN_MASK;
+            p->tuner_int_sense.rssilnegen  = (data >> SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB) & SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK;
+            p->tuner_int_sense.rssihnegen = (data >> SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB) & SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK;
+            p->tuner_int_sense.tcposen      = (data >> SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_LSB   ) & SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_MASK;
+            p->tuner_int_sense.rssilposen  = (data >> SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB) & SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK;
+            p->tuner_int_sense.rssihposen = (data >> SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB) & SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK;
+        break;
+#endif /*     SI2196_TUNER_INT_SENSE_PROP */
+#ifdef SI2196_TUNER_LO_INJECTION_PROP
+        case SI2196_TUNER_LO_INJECTION_PROP:
+            p->tuner_lo_injection.band_1 = (data >> SI2196_TUNER_LO_INJECTION_PROP_BAND_1_LSB) & SI2196_TUNER_LO_INJECTION_PROP_BAND_1_MASK;
+            p->tuner_lo_injection.band_2 = (data >> SI2196_TUNER_LO_INJECTION_PROP_BAND_2_LSB) & SI2196_TUNER_LO_INJECTION_PROP_BAND_2_MASK;
+            p->tuner_lo_injection.band_3 = (data >> SI2196_TUNER_LO_INJECTION_PROP_BAND_3_LSB) & SI2196_TUNER_LO_INJECTION_PROP_BAND_3_MASK;
+            p->tuner_lo_injection.band_4 = (data >> SI2196_TUNER_LO_INJECTION_PROP_BAND_4_LSB) & SI2196_TUNER_LO_INJECTION_PROP_BAND_4_MASK;
+            p->tuner_lo_injection.band_5 = (data >> SI2196_TUNER_LO_INJECTION_PROP_BAND_5_LSB) & SI2196_TUNER_LO_INJECTION_PROP_BAND_5_MASK;
+        break;
+#endif /*     SI2196_TUNER_LO_INJECTION_PROP */
+        default :
+        break;
+    }
+    return res;
+}
+void si2196_setupsddefaults (si2196_propobj_t *prop)
+{
+  prop->sd_prescaler_am.gain                     =-6; /* (default    -6) */
+  prop->sd_prescaler_eiaj.gain                    = 14; /* (default    14) */
+  prop->sd_prescaler_fm.gain                      = 2; /* (default     2) */
+  prop->sd_prescaler_nicam.gain                = -9; /* (default    -9) */
+  prop->sd_prescaler_sap.gain                    = 2; /* (default     2) */
+
+  prop->sd_sound_mode.mode                    = SI2196_SD_SOUND_MODE_PROP_MODE_AUTODETECT ; /* (default 'AUTODETECT') */
+  prop->sd_sound_system.system               = SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_AUTODETECT ; /* (default 'AUTODETECT') */
+
+  prop->sd_i2s.lrclk_pol                               = SI2196_SD_I2S_PROP_LRCLK_POL_LEFT_0_RIGHT_1      ; /* (default 'LEFT_0_RIGHT_1') */
+  prop->sd_i2s.alignment                             = SI2196_SD_I2S_PROP_ALIGNMENT_I2S                 ; /* (default 'I2S') */
+  prop->sd_i2s.lrclk_rate                              = SI2196_SD_I2S_PROP_LRCLK_RATE_48KHZ              ; /* (default '48KHZ') */
+  prop->sd_i2s.num_bits                              = SI2196_SD_I2S_PROP_NUM_BITS_24                   ; /* (default '24') */
+  prop->sd_i2s.sclk_rate                              = SI2196_SD_I2S_PROP_SCLK_RATE_64X                 ; /* (default '64X') */
+  prop->sd_i2s.drive_strength                      = 1; /* (default     1) */
+
+  prop->sd_over_dev_mode.mode               = SI2196_SD_OVER_DEV_MODE_PROP_MODE_AUTODETECT ; /* (default 'AUTODETECT') */
+
+  prop->sd_over_dev_mute.mute_thresh     = 20; /* (default    20) */
+  prop->sd_over_dev_mute.unmute_thresh = 18; /* (default    18) */
+
+  prop->sd_afc_mute.mute_thresh               = 150; /* (default   150) */
+  prop->sd_afc_mute.unmute_thresh           = 130; /* (default   130) */
+
+  prop->sd_carrier_mute.primary_thresh      =    22; /* (default    22) */
+  prop->sd_carrier_mute.secondary_thresh =    26; /* (default    26) */
+
+  prop->sd_asd.iterations                             = 3; /* (default     3) */
+  prop->sd_asd.enable_nicam_l                   = SI2196_SD_ASD_PROP_ENABLE_NICAM_L_ENABLE  ; /* (default 'ENABLE') */
+  prop->sd_asd.enable_nicam_dk                = SI2196_SD_ASD_PROP_ENABLE_NICAM_DK_ENABLE ; /* (default 'ENABLE') */
+  prop->sd_asd.enable_nicam_i                   = SI2196_SD_ASD_PROP_ENABLE_NICAM_I_ENABLE  ; /* (default 'ENABLE') */
+  prop->sd_asd.enable_nicam_bg                = SI2196_SD_ASD_PROP_ENABLE_NICAM_BG_ENABLE ; /* (default 'ENABLE') */
+  prop->sd_asd.enable_a2_m                       = SI2196_SD_ASD_PROP_ENABLE_A2_M_ENABLE     ; /* (default 'ENABLE') */
+  prop->sd_asd.enable_a2_dk                      = SI2196_SD_ASD_PROP_ENABLE_A2_DK_ENABLE    ; /* (default 'ENABLE') */
+  prop->sd_asd.enable_a2_bg                      = SI2196_SD_ASD_PROP_ENABLE_A2_BG_ENABLE    ; /* (default 'ENABLE') */
+  prop->sd_asd.enable_eiaj                          = SI2196_SD_ASD_PROP_ENABLE_EIAJ_ENABLE     ; /* (default 'ENABLE') */
+  prop->sd_asd.enable_btsc                         = SI2196_SD_ASD_PROP_ENABLE_BTSC_ENABLE     ; /* (default 'ENABLE') */
+
+  prop->sd_ien.asdcien                                = SI2196_SD_IEN_PROP_ASDCIEN_ENABLE  ; /* (default 'DISABLE') */
+  prop->sd_ien.nicamien                              = SI2196_SD_IEN_PROP_NICAMIEN_DISABLE ; /* (default 'DISABLE') */
+  prop->sd_ien.pcmien                                 = SI2196_SD_IEN_PROP_PCMIEN_DISABLE   ; /* (default 'DISABLE') */
+  prop->sd_ien.scmien                                 = SI2196_SD_IEN_PROP_SCMIEN_DISABLE   ; /* (default 'DISABLE') */
+  prop->sd_ien.odmien                                 = SI2196_SD_IEN_PROP_ODMIEN_DISABLE   ; /* (default 'DISABLE') */
+  prop->sd_ien.afcmien                                = SI2196_SD_IEN_PROP_AFCMIEN_DISABLE  ; /* (default 'DISABLE') */
+  prop->sd_ien.ssien                                    = SI2196_SD_IEN_PROP_SSIEN_DISABLE    ; /* (default 'DISABLE') */
+  prop->sd_ien.agcsien                                = SI2196_SD_IEN_PROP_AGCSIEN_DISABLE  ; /* (default 'DISABLE') */
+
+  prop->sd_int_sense.asdcnegen              = SI2196_SD_INT_SENSE_PROP_ASDCNEGEN_DISABLE  ; /* (default 'DISABLE') */
+  prop->sd_int_sense.nicamnegen            = SI2196_SD_INT_SENSE_PROP_NICAMNEGEN_DISABLE ; /* (default 'DISABLE') */
+  prop->sd_int_sense.pcmnegen               = SI2196_SD_INT_SENSE_PROP_PCMNEGEN_DISABLE   ; /* (default 'DISABLE') */
+  prop->sd_int_sense.scmnegen               = SI2196_SD_INT_SENSE_PROP_SCMNEGEN_DISABLE   ; /* (default 'DISABLE') */
+  prop->sd_int_sense.odmnegen               = SI2196_SD_INT_SENSE_PROP_ODMNEGEN_DISABLE   ; /* (default 'DISABLE') */
+  prop->sd_int_sense.afcmnegen              = SI2196_SD_INT_SENSE_PROP_AFCMNEGEN_DISABLE  ; /* (default 'DISABLE') */
+  prop->sd_int_sense.agcsnegen               = SI2196_SD_INT_SENSE_PROP_AGCSNEGEN_DISABLE  ; /* (default 'DISABLE') */
+  prop->sd_int_sense.asdcposen               = SI2196_SD_INT_SENSE_PROP_ASDCPOSEN_ENABLE   ; /* (default 'ENABLE') */
+  prop->sd_int_sense.nicamposen             = SI2196_SD_INT_SENSE_PROP_NICAMPOSEN_ENABLE  ; /* (default 'ENABLE') */
+  prop->sd_int_sense.pcmposen                = SI2196_SD_INT_SENSE_PROP_PCMPOSEN_ENABLE    ; /* (default 'ENABLE') */
+  prop->sd_int_sense.scmposen                = SI2196_SD_INT_SENSE_PROP_SCMPOSEN_ENABLE    ; /* (default 'ENABLE') */
+  prop->sd_int_sense.odmposen                = SI2196_SD_INT_SENSE_PROP_ODMPOSEN_ENABLE    ; /* (default 'ENABLE') */
+  prop->sd_int_sense.afcmposen               = SI2196_SD_INT_SENSE_PROP_AFCMPOSEN_ENABLE   ; /* (default 'ENABLE') */
+  prop->sd_int_sense.agcsposen               = SI2196_SD_INT_SENSE_PROP_AGCSPOSEN_ENABLE   ; /* (default 'ENABLE') */
+
+
+  prop->sd_pilot_lvl_ctrl.lose_lvl                   = 26; /* (default    26) */
+  prop->sd_pilot_lvl_ctrl.acq_lvl                    = 53; /* (default    53) */
+
+
+  prop->sd_port_volume_left.volume           = 0; /* (default     0) */
+  prop->sd_port_volume_right.volume         = 0; /* (default     0) */
+
+
+  prop->sd_port_config.balance_mode        = SI2196_SD_PORT_CONFIG_PROP_BALANCE_MODE_BALANCE ; /* (default 'BALANCE') */
+  prop->sd_port_config.port                         = SI2196_SD_PORT_CONFIG_PROP_PORT_DAC;//SI2196_SD_PORT_CONFIG_PROP_PORT_I2S             ; /* (default 'I2S') */
+  prop->sd_port_mute.mute                         = SI2196_SD_PORT_MUTE_PROP_MUTE_MUTE_NONE ; /* (default 'MUTE_NONE') */
+  prop->sd_port_volume_balance.balance  = 0; /* (default     0) */
+
+  prop->sd_nicam_failover_thresh.errors    = 768; /* (default   768) */
+  prop->sd_nicam_recover_thresh.errors    = 160; /* (default   160) */
+
+  prop->sd_lang_select.lang                       = SI2196_SD_LANG_SELECT_PROP_LANG_LANG_A ; /* (default 'LANG_A') */
+
+  prop->sd_nicam.num_frames                   = 200; /* (default   200) */
+  prop->sd_nicam.force_rss                        = SI2196_SD_NICAM_PROP_FORCE_RSS_NORMAL  ; /* (default 'NORMAL') */
+
+  prop->sd_port_volume_master.volume     = 20; /* (default     0) */
+  prop->sd_afc_max.max_afc                      = 150; /* (default   150) */
+  prop->sd_agc.gain                                    = 16; /* (default    16) */
+  prop->sd_agc.freeze                                 = SI2196_SD_AGC_PROP_FREEZE_NORMAL ; /* (default 'NORMAL') */
+
+  prop->sd_stereo_dm_id_lvl_acq.acq          =  1000; /* (default  1000) */
+
+  prop->sd_stereo_dm_id_lvl_shift.acq_shift  = 7; /* (default     7) */
+  prop->sd_stereo_dm_id_lvl_shift.track_shift = 1; /* (default     1) */
+
+  prop->sd_stereo_dm_id_lvl_track.track        = 500; /* (default   500) */
+
+};
+
+
+/************************************************************************************************************************
+  NAME: si2196_SetupATVDefaults
+  DESCRIPTION: Setup si2196 ATV startup configuration
+  This is a list of all the ATV configuration properties.   Depending on your application, only a subset may be required.
+  The properties are stored in the global property structure 'prop'.  The function ATVConfig(..) must be called
+  after any properties are modified.
+  Parameter:  none
+  Returns:    0 if successful
+  Programming Guide Reference:    Flowchart A.5 (ATV Setup flowchart)
+
+************************************************************************************************************************/
+static int si2196_setupatvdefaults(si2196_propobj_t *prop)
+{
+    prop->atv_cvbs_out.amp                                     = 100;
+    prop->atv_cvbs_out.offset                                   =  30;
+    prop->atv_cvbs_out_fine.amp                              = 100;
+    prop->atv_cvbs_out_fine.offset                            = 0;
+    prop->atv_sound_agc_limit.min_gain                   = -84;
+    prop->atv_sound_agc_limit.max_gain                  = 30;
+    prop->atv_sound_agc_speed.system_l                = 5; /* (default     5) */
+    prop->atv_sound_agc_speed.other_systems       = 4; /* (default     4) */
+    prop->atv_afc_range.range_khz                          = 2000;
+    prop->atv_rf_top.atv_rf_top                                  = SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO;
+
+    prop->atv_vsync_tracking.min_pulses_to_lock    = 2;
+    prop->atv_vsync_tracking.max_relock_retries     = 0;
+    prop->atv_vsync_tracking.min_fields_to_unlock  = 16;
+
+    prop->atv_vsnr_cap.atv_vsnr_cap                       = 0; /* (default     0) */
+    prop->atv_vsnr_cap.frontend_noise                    = 0; /* (default     0) */
+    prop->atv_vsnr_cap.backend_noise                    = 0;
+
+    prop->atv_agc_speed.if_agc_speed                    = 178;//patch for skyworth
+
+    prop->atv_rsq_rssi_threshold.hi                          = 0;
+    prop->atv_rsq_rssi_threshold.lo                          = -127;
+
+    prop->atv_rsq_snr_threshold.hi                          = 60;//40;
+    prop->atv_rsq_snr_threshold.lo                          = 10;//25;
+
+    prop->atv_video_equalizer.slope                        = 0;
+
+    prop->atv_int_sense.chlnegen                   = SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE;
+    prop->atv_int_sense.chlposen                   = SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE;
+    prop->atv_int_sense.dlnegen                     = SI2196_ATV_INT_SENSE_PROP_DLNEGEN_DISABLE;
+    prop->atv_int_sense.dlposen                     = SI2196_ATV_INT_SENSE_PROP_DLPOSEN_ENABLE;
+    prop->atv_int_sense.pclnegen                   = SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE;
+    prop->atv_int_sense.pclposen                   = SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE;
+    prop->atv_int_sense.snrhnegen                = SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_DISABLE;
+    prop->atv_int_sense.snrhposen                = SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_ENABLE;
+    prop->atv_int_sense.snrlnegen                 = SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_DISABLE;
+    prop->atv_int_sense.snrlposen                 = SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_ENABLE;
+
+    prop->atv_ien.chlien                                 = SI2196_ATV_IEN_PROP_CHLIEN_ENABLE;     /* enable only CHL to drive ATVINT */
+    prop->atv_ien.dlien                                   = SI2196_ATV_IEN_PROP_DLIEN_ENABLE;
+    prop->atv_ien.pclien                                 = SI2196_ATV_IEN_PROP_PCLIEN_ENABLE;
+    prop->atv_ien.snrhien                               = SI2196_ATV_IEN_PROP_SNRHIEN_ENABLE;
+    prop->atv_ien.snrlien                                = SI2196_ATV_IEN_PROP_SNRLIEN_ENABLE;
+
+    prop->atv_audio_mode.audio_sys            = 0;//SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_MONO;
+    prop->atv_audio_mode.chan_bw              = SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT;
+
+    prop->atv_video_mode.video_sys             = 0;//SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK;
+    prop->atv_video_mode.trans                     = SI2196_ATV_VIDEO_MODE_PROP_TRANS_CABLE;//SI2196_ATV_VIDEO_MODE_PROP_TRANS_TERRESTRIAL;
+    prop->atv_video_mode.color                     = SI2196_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC;
+    prop->atv_video_mode.invert_signal         = 0; /* (default     0) */
+    return 0;
+}
+/************************************************************************************************************************
+  NAME: si2196_SetupCommonDefaults
+  DESCRIPTION: Setup si2196 Common startup configuration
+  This is a list of all the common configuration properties.   Depending on your application, only a subset may be required.
+  The properties are stored in the global property structure 'prop'.  The function CommonConfig(..) must be called
+  after any of these properties are modified.
+  Parameter:  none
+  Returns:    0 if successful
+  Programming Guide Reference:    Flowchart A.6a (Common setup flowchart)
+************************************************************************************************************************/
+static int si2196_setupcommondefaults(si2196_propobj_t *prop)
+{
+    /**** Enable Interrupt Sources *******/
+    prop->master_ien.atvien = SI2196_MASTER_IEN_PROP_ATVIEN_ON;
+    prop->master_ien.ctsien = SI2196_MASTER_IEN_PROP_CTSIEN_ON;
+    prop->master_ien.dtvien = SI2196_MASTER_IEN_PROP_DTVIEN_OFF;//SI2196_MASTER_IEN_PROP_DTVIEN_ON;
+    prop->master_ien.errien  = SI2196_MASTER_IEN_PROP_ERRIEN_ON;
+    prop->master_ien.sdien  = SI2196_MASTER_IEN_PROP_SDIEN_OFF;
+    prop->master_ien.tunien = SI2196_MASTER_IEN_PROP_TUNIEN_ON;
+    /* Crystal Trim adjustment */
+    prop->crystal_trim.xo_cap = 8;
+    return 0;
+}
+/************************************************************************************************************************
+  NAME: si2196_SetupTunerDefaults
+  DESCRIPTION: Setup si2196 Tuner startup configuration
+  This is a list of all the Tuner configuration properties.   Depending on your application, only a subset may be required.
+  The properties are stored in the global property structure 'prop'.  The function TunerConfig(..) must be called
+  after any of these properties are modified.
+  Parameter:  none
+  Returns:    0 if successful
+  Programming Guide Reference:    Flowchart A.6a (Tuner setup flowchart)
+************************************************************************************************************************/
+static int si2196_setuptunerdefaults(si2196_propobj_t *prop)
+{
+
+    /* Setting si2196_TUNER_IEN_PROP property */
+    prop->tuner_ien.tcien               = SI2196_TUNER_IEN_PROP_TCIEN_ENABLE; /* enable only TC to drive TUNINT */
+    prop->tuner_ien.rssilien           = SI2196_TUNER_IEN_PROP_RSSILIEN_ENABLE;
+    prop->tuner_ien.rssihien          = SI2196_TUNER_IEN_PROP_RSSIHIEN_DISABLE;
+
+    /* Setting si2196_TUNER_BLOCK_VCO_PROP property */
+    prop->tuner_blocked_vco.vco_code   = 0x8000;
+
+    /* Setting si2196_TUNER_INT_SENSE_PROP property */
+    prop->tuner_int_sense.rssihnegen  = SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE;
+    prop->tuner_int_sense.rssihposen  = SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE;
+    prop->tuner_int_sense.rssilnegen   = SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE;
+    prop->tuner_int_sense.rssilposen   = SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE;
+    prop->tuner_int_sense.tcnegen      = SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE;
+    prop->tuner_int_sense.tcposen      = SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE;
+
+
+   /* Setting si2196_TUNER_LO_INJECTION_PROP property */
+    prop->tuner_lo_injection.band_1     = SI2196_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE;
+    prop->tuner_lo_injection.band_2     = SI2196_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE;
+    prop->tuner_lo_injection.band_3     = SI2196_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE;
+    prop->tuner_lo_injection.band_4     = SI2196_TUNER_LO_INJECTION_PROP_BAND_4_LOW_SIDE;
+    prop->tuner_lo_injection.band_5     = SI2196_TUNER_LO_INJECTION_PROP_BAND_5_LOW_SIDE;
+
+    return 0;
+}
+#if 0
+void si2196_setupdtvdefaults (si2196_propobj_t *prop)
+{
+  prop->dtv_agc_freeze_input.level               = SI2196_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LOW  ; /* (default 'LOW') */
+  prop->dtv_agc_freeze_input.pin                 = SI2196_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE   ; /* (default 'NONE') */
+
+  prop->dtv_agc_speed.if_agc_speed               = SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO ; /* (default 'AUTO') */
+  prop->dtv_agc_speed.agc_decim                  = SI2196_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF     ; /* (default 'OFF') */
+
+  prop->dtv_config_if_port.dtv_out_type          = SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1   ; /* (default 'LIF_IF1') */
+  prop->dtv_config_if_port.dtv_agc_source        =     0; /* (default     0) */
+
+  prop->dtv_ext_agc.min_10mv                     =    50; /* (default    50) */
+  prop->dtv_ext_agc.max_10mv                     =   200; /* (default   200) */
+
+  prop->dtv_filter_select.filter                 = SI2196_DTV_FILTER_SELECT_PROP_FILTER_DEFAULT ; /* (default 'DEFAULT') */
+
+  prop->dtv_ien.chlien                           = SI2196_DTV_IEN_PROP_CHLIEN_ENABLE ; /* (default 'DISABLE') */
+
+  prop->dtv_initial_agc_speed.if_agc_speed       = SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO ; /* (default 'AUTO') */
+  prop->dtv_initial_agc_speed.agc_decim          = SI2196_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF     ; /* (default 'OFF') */
+
+  prop->dtv_initial_agc_speed_period.period      =     0; /* (default     0) */
+
+  prop->dtv_internal_zif.atsc                    = SI2196_DTV_INTERNAL_ZIF_PROP_ATSC_LIF   ; /* (default 'LIF') */
+  prop->dtv_internal_zif.qam_us              = SI2196_DTV_INTERNAL_ZIF_PROP_QAM_US_LIF ; /* (default 'LIF') */
+  prop->dtv_internal_zif.dvbt                    = SI2196_DTV_INTERNAL_ZIF_PROP_DVBT_LIF   ; /* (default 'LIF') */
+  prop->dtv_internal_zif.dvbc                    = SI2196_DTV_INTERNAL_ZIF_PROP_DVBC_LIF   ; /* (default 'LIF') */
+  prop->dtv_internal_zif.isdbt                   = SI2196_DTV_INTERNAL_ZIF_PROP_ISDBT_LIF  ; /* (default 'LIF') */
+  prop->dtv_internal_zif.isdbc                   = SI2196_DTV_INTERNAL_ZIF_PROP_ISDBC_LIF  ; /* (default 'LIF') */
+  prop->dtv_internal_zif.dtmb                    = SI2196_DTV_INTERNAL_ZIF_PROP_DTMB_LIF   ; /* (default 'LIF') */
+
+  prop->dtv_int_sense.chlnegen                   = SI2196_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE ; /* (default 'DISABLE') */
+  prop->dtv_int_sense.chlposen                   = SI2196_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE  ; /* (default 'ENABLE') */
+
+  prop->dtv_lif_freq.offset                      =  5000; /* (default  5000) */
+
+  prop->dtv_lif_out.offset                       =   148; /* (default   148) */
+  prop->dtv_lif_out.amp                          =    27; /* (default    27) */
+
+  prop->dtv_mode.bw                              = SI2196_DTV_MODE_PROP_BW_BW_8MHZ              ; /* (default 'BW_8MHZ') */
+  prop->dtv_mode.modulation                      = SI2196_DTV_MODE_PROP_MODULATION_DVBT         ; /* (default 'DVBT') */
+  prop->dtv_mode.invert_spectrum                 =     0; /* (default     0) */
+
+  prop->dtv_rf_top.dtv_rf_top                    = SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO ; /* (default 'AUTO') */
+
+  prop->dtv_rsq_rssi_threshold.lo                =   -80; /* (default   -80) */
+  prop->dtv_rsq_rssi_threshold.hi                =     0; /* (default     0) */
+
+}
+
+/*****************************************************************************************
+ NAME: SI2196_downloadDTVProperties
+  DESCRIPTION: Setup SI2196 DTV properties configuration
+  This function will download all the DTV configuration properties.
+  The function SetupDTVDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to SI2196 Context
+  Returns:    I2C transaction error code, NO_SI2196_ERROR if successful
+  Programming Guide Reference:    DTV setup flowchart
+******************************************************************************************/
+int  si2196_dtvconfig(si2196_propobj_t *prop)
+{
+#ifdef    SI2196_DTV_AGC_FREEZE_INPUT_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_AGC_FREEZE_INPUT_PROP_CODE        ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_AGC_FREEZE_INPUT_PROP */
+#ifdef    SI2196_DTV_AGC_SPEED_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_AGC_SPEED_PROP_CODE               ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_AGC_SPEED_PROP */
+#ifdef    SI2196_DTV_CONFIG_IF_PORT_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_CONFIG_IF_PORT_PROP_CODE          ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_CONFIG_IF_PORT_PROP */
+#ifdef    SI2196_DTV_EXT_AGC_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_EXT_AGC_PROP_CODE                 ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_EXT_AGC_PROP */
+#ifdef    SI2196_DTV_FILTER_SELECT_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_FILTER_SELECT_PROP_CODE           ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_FILTER_SELECT_PROP */
+#ifdef    SI2196_DTV_IEN_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_IEN_PROP_CODE                     ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_IEN_PROP */
+#ifdef    SI2196_DTV_INITIAL_AGC_SPEED_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_INITIAL_AGC_SPEED_PROP_CODE       ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_INITIAL_AGC_SPEED_PROP */
+#ifdef    SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+#ifdef    SI2196_DTV_INTERNAL_ZIF_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_INTERNAL_ZIF_PROP_CODE            ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_INTERNAL_ZIF_PROP */
+#ifdef    SI2196_DTV_INT_SENSE_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_INT_SENSE_PROP_CODE               ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_INT_SENSE_PROP */
+#ifdef    SI2196_DTV_LIF_FREQ_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_LIF_FREQ_PROP_CODE                ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_LIF_FREQ_PROP */
+#ifdef    SI2196_DTV_LIF_OUT_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_LIF_OUT_PROP_CODE                 ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_LIF_OUT_PROP */
+#ifdef    SI2196_DTV_MODE_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_MODE_PROP_CODE                    ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_MODE_PROP */
+#ifdef    SI2196_DTV_RF_TOP_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_RF_TOP_PROP_CODE                  ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_RF_TOP_PROP */
+#ifdef    SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP
+  if (SI2196_L1_SetProperty2(api, SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE      ) != NO_SI2196_ERROR) {return ERROR_SI2196_SENDING_COMMAND;}
+#endif /* SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP */
+return NO_SI2196_ERROR;
+};
+#endif
+
+
+/************************************************************************************************************************
+  NAME: si2196_ATVConfig
+  DESCRIPTION: Setup si2196 ATV properties configuration
+  This function will download all the ATV configuration properties stored in the global structure 'prop.
+  Depending on your application, only a subset may be required to be modified.
+  The function si2196_SetupATVDefaults() should be called before the first call to this function. Afterwards
+  to change a property change the appropriate element in the property structure 'prop' and call this routine.
+  Use the comments above the SetProperty2 calls as a guide to the parameters which are changed.
+  Parameter:  Pointer to si2196 Context (I2C address)
+  Returns:    I2C transaction error code, 0 if successful
+  Programming Guide Reference:    Flowchart A.5 (ATV setup flowchart)
+************************************************************************************************************************/
+int si2196_atvconfig(struct i2c_client *si2196, si2196_propobj_t *prop, si2196_cmdreplyobj_t *rsp)
+{
+
+   /* Set ATV_CVBS_OUT property */
+   //prop.atv_cvbs_out.amp,
+   //prop.atv_cvbs_out.offset
+   if (si2196_sendproperty(si2196, SI2196_ATV_CVBS_OUT_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /* Set the ATV_SIF_OUT property */
+   //prop.atv_sif_out.amp,
+   //prop.atv_sif_out.offset
+   /*if (si2196_sendproperty(si2196, SI2196_ATV_SIF_OUT_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }*/
+
+   /* Set the si2196_ATV_SOUND_AGC_LIMIT property */
+   //prop.atv_sif_out.min_gain,
+   //prop.atv_sif_out.max_gain
+   if (si2196_sendproperty(si2196, SI2196_ATV_SOUND_AGC_LIMIT_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+   /* Set the ATV_AFC_RANGE property */
+   //prop.atv_afc_range.range_khz
+   if (si2196_sendproperty(si2196, SI2196_ATV_AFC_RANGE_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /* Set the ATV_RF_TOP property */
+   //prop.atv_rf_top.atv_rf_top
+   if (si2196_sendproperty(si2196, SI2196_ATV_RF_TOP_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /* Set the ATV_VSYNC_TRACKING property */
+   //prop.atv_vsync_tracking.min_pulses_to_lock,
+   //prop.atv_vsync_tracking.min_fields_to_unlock
+   if (si2196_sendproperty(si2196, SI2196_ATV_VSYNC_TRACKING_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /* Set the ATV_VSNR_CAP property */
+   //prop.atv_vsnr_cap.atv_vsnr_cap
+   if (si2196_sendproperty(si2196, SI2196_ATV_VSNR_CAP_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /* Set the ATV_CVBS_OUT_FINE property */
+   //prop.atv_cvbs_out_fine.amp,
+   //prop.atv_cvbs_out_fine.offset
+   if (si2196_sendproperty(si2196, SI2196_ATV_CVBS_OUT_FINE_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /* Set the ATV_AGC_SPEED property */
+   //prop.atv_agc_speed.if_agc_speed
+   if (si2196_sendproperty(si2196, SI2196_ATV_AGC_SPEED_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /*Set the ATV_RSSI_RSQ_THRESHOLD property */
+   //prop.atv_rsq_rssi_threshold.hi,
+   //prop.atv_rsq_rssi_threshold.lo
+   if (si2196_sendproperty(si2196, SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /*Set the ATV_SNR_RSQ_THRESHOLD property */
+   //prop.atv_rsq_snr_threshold.hi,
+   //prop.atv_rsq_snr_threshold.lo
+   if (si2196_sendproperty(si2196, SI2196_ATV_RSQ_SNR_THRESHOLD_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /*Set the ATV_VIDEO_EQUALIZER property */
+    //prop.atv_video_equalizer.slope
+   if (si2196_sendproperty(si2196, SI2196_ATV_VIDEO_EQUALIZER_PROP, prop, rsp) != 0)
+   {
+        return ERROR_SI2196_SENDING_COMMAND;
+   }
+
+   /*Set the ATV_INT_SENSE property */
+   //prop.atv_int_sense.chlnegen,
+   //prop.atv_int_sense.chlposen,
+   //prop.atv_int_sense.dlnegen,
+   //prop.atv_int_sense.dlposen,
+   //prop.atv_int_sense.pclnegen,
+   //prop.atv_int_sense.pclposen,
+   //prop.atv_int_sense.snrhnegen,
+   //prop.atv_int_sense.snrhposen,
+   //prop.atv_int_sense.snrlnegen,
+   //prop.atv_int_sense.snrlposen
+    if (si2196_sendproperty(si2196, SI2196_ATV_INT_SENSE_PROP, prop, rsp) != 0)
+    {
+            return ERROR_SI2196_SENDING_COMMAND;
+    }
+    /* setup ATV_IEN_PROP  IEN properties to enable ATVINT on CHL  */
+
+    /* prop.atv_ien.chlien,
+    prop.atv_ien.pclien,
+    prop.atv_ien.dlien ,
+    prop.atv_ien.snrlien,
+    prop.atv_ien.snrhien */
+    if (si2196_sendproperty(si2196, SI2196_ATV_IEN_PROP, prop, rsp) != 0)
+    {
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    /* Set the ATV_AUDIO_MODE property */
+    /*rop.atv_audio_mode.audio_sys,
+        prop.atv_audio_mode.chan_bw,
+        prop.atv_audio_mode.demod_mode  */
+    if (si2196_sendproperty(si2196, SI2196_ATV_AUDIO_MODE_PROP, prop, rsp) != 0)
+    {
+            return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+   /* Set the ATV_VIDEO_MODE property */
+    /*prop.atv_video_mode.video_sys,
+        prop.atv_video_mode.trans,
+        prop.atv_video_mode.color  */
+    if (si2196_sendproperty(si2196, SI2196_ATV_VIDEO_MODE_PROP, prop, rsp) != 0)
+    {
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+#ifdef SI2196_ATV_SOUND_AGC_SPEED_PROP
+  if (si2196_sendproperty(si2196, SI2196_ATV_SOUND_AGC_SPEED_PROP_CODE, prop, rsp) != 0)
+    {
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+#endif /* SI2196_ATV_SOUND_AGC_SPEED_PROP */
+    return 0;
+}
+
+/************************************************************************************************************************
+  NAME: si2196_CommonConfig
+  DESCRIPTION: Setup si2196 Common properties configuration
+  This function will download all the DTV configuration properties stored in the global structure 'prop.
+  Depending on your application, only a subset may be required to be modified.
+  The function si2196_SetupCommonDefaults() should be called before the first call to this function. Afterwards
+  to change a property change the appropriate element in the property structure 'prop' and call this routine.
+  Use the comments above the si2196_sendproperty calls as a guide to the parameters which are changed.
+  Parameter:  Pointer to si2196 Context (I2C address)
+  Returns:    I2C transaction error code, 0 if successful
+  Programming Guide Reference:    Flowchart A.6a (Common setup flowchart)
+************************************************************************************************************************/
+int si2196_commonconfig(struct i2c_client *si2196, si2196_propobj_t *prop, si2196_cmdreplyobj_t *rsp)
+{
+
+    /* Setting si2196_MASTER_IEN_PROP property */
+    /***
+        prop.master_ien.atvien,
+        prop.master_ien.ctsien,
+        prop.master_ien.dtvien,
+        prop.master_ien.errien,
+        prop.master_ien.tunien  */
+
+    if (si2196_sendproperty(si2196, SI2196_MASTER_IEN_PROP, prop, rsp) != 0)
+    {
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    /* Setting si2196_CRYSTAL_TRIM_PROP */
+    //rop.crystal_trim.xo_cap
+    if (si2196_sendproperty(si2196, SI2196_CRYSTAL_TRIM_PROP, prop, rsp) != 0)
+    {
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+
+    return 0;
+}
+/*****************************************************************************************
+ NAME: SI2196_downloadSDProperties
+  DESCRIPTION: Setup SI2196 SD properties configuration
+  This function will download all the SD configuration properties.
+  The function SetupSDDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to SI2196 Context
+  Returns:    I2C transaction error code, NO_SI2196_ERROR if successful
+  Programming Guide Reference:    SD setup flowchart
+******************************************************************************************/
+int  si2196_stereoconfig(struct i2c_client *si2196, si2196_propobj_t *prop, si2196_cmdreplyobj_t *rsp)
+{
+#ifdef    SI2196_SD_AFC_MAX_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_AFC_MAX_PROP_CODE,prop,rsp) != NO_SI2196_ERROR)
+    return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_AFC_MAX_PROP */
+#ifdef    SI2196_SD_AFC_MUTE_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_AFC_MUTE_PROP_CODE,prop,rsp) != NO_SI2196_ERROR)
+    return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_AFC_MUTE_PROP */
+#ifdef    SI2196_SD_AGC_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_AGC_PROP_CODE,prop,rsp) != NO_SI2196_ERROR)
+      return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_AGC_PROP */
+#ifdef    SI2196_SD_ASD_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_ASD_PROP_CODE,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_ASD_PROP */
+#ifdef    SI2196_SD_CARRIER_MUTE_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_CARRIER_MUTE_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_CARRIER_MUTE_PROP */
+#ifdef    SI2196_SD_I2S_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_I2S_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_I2S_PROP */
+#ifdef    SI2196_SD_IEN_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_IEN_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_IEN_PROP */
+#ifdef    SI2196_SD_INT_SENSE_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_INT_SENSE_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_INT_SENSE_PROP */
+#ifdef    SI2196_SD_LANG_SELECT_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_LANG_SELECT_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_LANG_SELECT_PROP */
+#ifdef    SI2196_SD_NICAM_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_NICAM_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_NICAM_PROP */
+#ifdef    SI2196_SD_NICAM_FAILOVER_THRESH_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_NICAM_FAILOVER_THRESH_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_NICAM_FAILOVER_THRESH_PROP */
+#ifdef    SI2196_SD_NICAM_RECOVER_THRESH_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_NICAM_RECOVER_THRESH_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_NICAM_RECOVER_THRESH_PROP */
+#ifdef    SI2196_SD_OVER_DEV_MODE_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_OVER_DEV_MODE_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_OVER_DEV_MODE_PROP */
+#ifdef    SI2196_SD_OVER_DEV_MUTE_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_OVER_DEV_MUTE_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_OVER_DEV_MUTE_PROP */
+#ifdef    SI2196_SD_PILOT_LVL_CTRL_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PILOT_LVL_CTRL_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PILOT_LVL_CTRL_PROP */
+#ifdef    SI2196_SD_PORT_CONFIG_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PORT_CONFIG_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PORT_CONFIG_PROP */
+#ifdef    SI2196_SD_PORT_MUTE_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PORT_MUTE_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PORT_MUTE_PROP */
+#ifdef    SI2196_SD_PORT_VOLUME_BALANCE_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PORT_VOLUME_BALANCE_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PORT_VOLUME_BALANCE_PROP */
+#ifdef    SI2196_SD_PORT_VOLUME_LEFT_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PORT_VOLUME_LEFT_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PORT_VOLUME_LEFT_PROP */
+#ifdef    SI2196_SD_PORT_VOLUME_MASTER_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PORT_VOLUME_MASTER_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PORT_VOLUME_MASTER_PROP */
+#ifdef    SI2196_SD_PORT_VOLUME_RIGHT_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PORT_VOLUME_RIGHT_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PORT_VOLUME_RIGHT_PROP */
+#ifdef    SI2196_SD_PRESCALER_AM_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PRESCALER_AM_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PRESCALER_AM_PROP */
+#ifdef    SI2196_SD_PRESCALER_EIAJ_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PRESCALER_EIAJ_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PRESCALER_EIAJ_PROP */
+#ifdef    SI2196_SD_PRESCALER_FM_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PRESCALER_FM_PROP,prop,rsp) != NO_SI2196_ERROR)
+       return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PRESCALER_FM_PROP */
+#ifdef    SI2196_SD_PRESCALER_NICAM_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PRESCALER_NICAM_PROP,prop,rsp) != NO_SI2196_ERROR)
+        return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PRESCALER_NICAM_PROP */
+#ifdef    SI2196_SD_PRESCALER_SAP_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_PRESCALER_SAP_PROP,prop,rsp) != NO_SI2196_ERROR)
+         return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_PRESCALER_SAP_PROP */
+#ifdef    SI2196_SD_SOUND_MODE_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_SOUND_MODE_PROP,prop,rsp) != NO_SI2196_ERROR)
+         return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_SOUND_MODE_PROP */
+#ifdef    SI2196_SD_SOUND_SYSTEM_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_SOUND_SYSTEM_PROP,prop,rsp) != NO_SI2196_ERROR)
+         return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_SOUND_SYSTEM_PROP */
+#ifdef    SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP,prop,rsp) != NO_SI2196_ERROR)
+         return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP */
+#ifdef    SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP,prop,rsp) != NO_SI2196_ERROR)
+         return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP */
+#ifdef    SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP
+  if (si2196_sendproperty(si2196, SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP,prop,rsp) != NO_SI2196_ERROR)
+         return ERROR_SI2196_SENDING_COMMAND;
+#endif /* SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP */
+    return NO_SI2196_ERROR;
+};
+
+/************************************************************************************************************************
+  NAME: si2196_TunerConfig
+  DESCRIPTION: Setup si2196 Tuner (RF to IF analog path) properties configuration
+  This function will download all the DTV configuration properties stored in the global structure 'prop.
+  Depending on your application, only a subset may be required to be modified.
+  The function si2196_SetupTunerDefaults() should be called before the first call to this function. Afterwards
+  to change a property change the appropriate element in the property structure 'prop' and call this routine.
+  Use the comments above the si2196_sendproperty calls as a guide to the parameters which are changed.
+  Parameter:  Pointer to si2196 Context (I2C address)
+  Returns:    I2C transaction error code, 0 if successful
+  Programming Guide Reference:    Flowchart A.6a (Tuner setup flowchart)
+************************************************************************************************************************/
+int si2196_tunerconfig(struct i2c_client *si2196, si2196_propobj_t *prop, si2196_cmdreplyobj_t *rsp)
+{
+        /* Set TUNER_IEN property */
+        /*rop.tuner_ien.tcien,
+        prop.tuner_ien.rssilien,
+        prop.tuner_ien.rssihien */
+        if (si2196_sendproperty(si2196, SI2196_TUNER_IEN_PROP, prop, rsp) != 0)
+        {
+            return ERROR_SI2196_SENDING_COMMAND;
+        }
+
+        /* Setting TUNER_BLOCKED_VCO property */
+        /*rop.tuner_blocked_vco.vco_code, */
+        if (si2196_sendproperty(si2196, SI2196_TUNER_BLOCKED_VCO_PROP, prop, rsp) != 0)
+        {
+            return ERROR_SI2196_SENDING_COMMAND;
+        }
+        /* Setting si2196_TUNER_INT_SENSE_PROP property */
+        /*    rop.tuner_int_sense.rssihnegen,
+            prop.tuner_int_sense.rssihposen,
+            prop.tuner_int_sense.rssilnegen,
+            prop.tuner_int_sense.rssilposen,
+            prop.tuner_int_sense.tcnegen,
+            prop.tuner_int_sense.tcposen */
+
+        if (si2196_sendproperty(si2196, SI2196_TUNER_INT_SENSE_PROP, prop, rsp) != 0)
+        {
+            return ERROR_SI2196_SENDING_COMMAND;
+        }
+
+        /* Setting si2196_TUNER_LO_INJECTION_PROP property */
+        /*rop.tuner_lo_injection.band_1,
+        prop.tuner_lo_injection.band_2,
+        prop.tuner_lo_injection.band_3,
+        prop.tuner_lo_injection.band_4,
+        prop.tuner_lo_injection.band_5 */
+        if (si2196_sendproperty(si2196, SI2196_TUNER_LO_INJECTION_PROP, prop, rsp) != 0)
+        {
+            return ERROR_SI2196_SENDING_COMMAND;
+        }
+
+
+    return 0;
+}
+/************************************************************************************************************************
+NAME:Si2196_SetupDTVDefaults
+DESCRIPTION:Setup si2196 DTV startup configuration
+This is a list of all the DTV configuration properties. Depending on your application,only a subset maybe required.
+The properties are stored in the global property structure 'prop'. The function DTVConfig(....) must be called
+after any properties are modified.
+parameter:none
+returns:0 if successful
+programming Guide reference: Flowchart A.6(DTV setup flowchart)
+************************************************************************************************************************/
+static int si2196_setupdtvdefaults(si2196_propobj_t* prop,int ch_mode)
+{
+	prop->dtv_config_if_port.dtv_out_type  = SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1;
+	prop->dtv_config_if_port.dtv_agc_source = SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL;
+	prop->dtv_lif_freq.offset = 5000;
+	prop->dtv_mode.bw= SI2196_DTV_MODE_PROP_BW_BW_8MHZ;
+	prop->dtv_mode.invert_spectrum = SI2196_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL;
+	//set in the get tuner ops
+	//prop->dtv_mode.modulation = SI2196_DTV_MODE_PROP_MODULATION_DVBC;
+	prop->dtv_rsq_rssi_threshold.hi=0;
+    	prop->dtv_rsq_rssi_threshold.lo=-80;
+    	prop->dtv_ext_agc.max_10mv=200;
+    	prop->dtv_ext_agc.min_10mv=50;
+    	if(ch_mode == 4)
+        prop->dtv_lif_out.amp=22;//27;//23;
+    	else
+        prop->dtv_lif_out.amp=25;//27;
+
+   	 prop->dtv_lif_out.offset=148;
+    	prop->dtv_agc_speed.agc_decim=SI2196_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;
+    	prop->dtv_agc_speed.if_agc_speed=SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;
+    	prop->dtv_rf_top.dtv_rf_top=SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO;
+    	prop->dtv_int_sense.chlnegen=SI2196_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE;
+    	prop->dtv_int_sense.chlposen=SI2196_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE;
+    	prop->dtv_ien.chlien  = SI2196_DTV_IEN_PROP_CHLIEN_ENABLE;      /* enable only CHL to drive DTVINT */
+    	return 0;
+}
+/************************************************************************************************************************
+NAME: SI2196_DTV_Config
+DESCRIPTION:Setup Si2196 DTV properties configuration
+This function will download all the DTV configuration properties stored in the global structure 'prop'
+Depending on your application, only a subset may be required to be modified.
+  The function Si2196_SetupDTVDefaults() should be called before the first call to this function. Afterwards
+  to change a property change the appropriate element in the property structure 'prop' and call this routine.
+  Use the comments above the Si2196_L1_SetProperty2 calls as a guide to the parameters which are changed.
+  Parameter:  Pointer to Si2196 Context (I2C address)
+  Returns:    I2C transaction error code, 0 if successful
+  Programming Guide Reference:    Flowchart A.6 (DTV setup flowchart)
+  ************************************************************************************************************************/
+  int si2196_dtvconfig(struct i2c_client *si2196,si2196_propobj_t *prop,si2196_cmdreplyobj_t *rsp)
+{
+	/*DTV_CONFIG_IF_PORT_PROP property */
+	/*prop.dtv_config_if_port.dtv_out_type,
+	prop.dtv_config_if_port.dtv_agc_source */
+    if (si2196_sendproperty(si2196, SI2196_DTV_CONFIG_IF_PORT_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+	/* Setting DTV_LIF_FREQ_PROP */
+     //prop.dtv_lif_freq.offset
+    if (si2196_sendproperty(si2196, SI2196_DTV_LIF_FREQ_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+	/* Setting DTV_MODE_PROP property */
+ 	 /*	prop.dtv_mode.bw,
+	prop.dtv_mode.invert_spectrum,
+	prop.dtv_mode.modulation*/
+    if (si2196_sendproperty(si2196, SI2196_DTV_MODE_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+	/* Setting DTV_RSQ_RSSI_THRESHOLD property */
+	//	prop.dtv_rsq_rssi_threshold.hi,
+	//	prop.dtv_rsq_rssi_threshold.lo
+    if (si2196_sendproperty(si2196, SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+	/* Setting DTV_EXT_AGC property */
+	//	prop.dtv_ext_agc.max_10mv,
+	//	prop.dtv_ext_agc.min_10mv
+    if (si2196_sendproperty(si2196, SI2196_DTV_EXT_AGC_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+	/* Setting DTV_LIF_OUT property */
+	//	prop.dtv_lif_out.amp,
+	//	prop.dtv_lif_out.offset
+    if (si2196_sendproperty(si2196, SI2196_DTV_LIF_OUT_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+	/* Setting DTV_AGC_SPEED property */
+	//	prop.dtv_agc_speed.agc_decim,
+	//	prop.dtv_agc_speed.if_agc_speed
+    if (si2196_sendproperty(si2196, SI2196_DTV_AGC_SPEED_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+	/* Setting DTV_RF_TOP property */
+	//	prop.dtv_rf_top.dtv_rf_top
+    if (si2196_sendproperty(si2196, SI2196_DTV_RF_TOP_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+	 /* Setting DTV_INT_SENSE property */
+	//	prop.dtv_int_sense.chlnegen,
+	//	prop.dtv_int_sense.chlposen
+    if (si2196_sendproperty(si2196, SI2196_DTV_INT_SENSE_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+	  /* Set DTV_IEN property */
+	/*	prop.dtv_ien.chlien */
+    if (si2196_sendproperty(si2196, SI2196_DTV_IEN_PROP, prop, rsp) != 0){
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+   return 0;
+}
+
+
+/************************************************************************************************************************
+  NAME: si2196_Tune
+  DESCRIPTIION: Tune si2196 in specified mode (ATV/DTV) at center frequency, wait for TUNINT and xTVINT with timeout
+
+  Parameter:  Pointer to si2196 Context (I2C address)
+  Parameter:  Mode (ATV or DTV) use si2196_TUNER_TUNE_FREQ_CMD_MODE_ATV or si2196_TUNER_TUNE_FREQ_CMD_MODE_DTV constants
+  Parameter:  frequency (Hz) as a unsigned long integer
+  Parameter:  rsp - commandResp structure to returns tune status info.
+  Returns:    0 if channel found.  A nonzero value means either an error occurred or channel not locked.
+  Programming Guide Reference:    Flowchart A.7 (Tune flowchart)
+************************************************************************************************************************/
+int si2196_tune(struct i2c_client *si2196, unsigned char mode, unsigned long freq, si2196_cmdreplyobj_t *rsp)
+{
+    int return_code = 0,count = 0;
+
+    if (si2196_tuner_tune_freq(si2196, mode, freq, rsp) != 0)
+    {
+        pr_info("%s: tuner tune freq error:%d!!!!\n", __func__, ERROR_SI2196_SENDING_COMMAND);
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+    for (count=50; count ;count--)
+    {
+        return_code = si2196_pollforcts(si2196);
+        if (!return_code)
+            break;
+        mdelay(2);
+    }
+    if (!count)
+    {
+        pr_info("%s: poll cts error:%d!!!!\n", __func__, return_code);
+        return return_code;
+    }
+	mdelay(delay_det);
+#if 0
+    /* wait for TUNINT, timeout is 100ms */
+    for (count=50; count ;count--)
+    {
+        if ((return_code = si2196_check_status(si2196, common_reply)) != 0)
+            return return_code;
+        if (common_reply->tunint)
+            break;
+        mdelay(2);
+    }
+    if (!count)
+    {
+        pr_info("%s: ERROR_SI2196_TUNINT_TIMEOUT error:%d!!!!\n", __func__, ERROR_SI2196_TUNINT_TIMEOUT);
+        return ERROR_SI2196_TUNINT_TIMEOUT;
+    }
+    /* wait for xTVINT, timeout is 150ms for ATVINT and 6 ms for DTVINT */
+    count = ((mode==SI2196_TUNER_TUNE_FREQ_CMD_MODE_ATV) ? 75 : 3);
+    for (;count ;count--)
+    {
+        if ((return_code = si2196_check_status(si2196, common_reply)) != 0)
+            return return_code;
+        if ((mode==SI2196_TUNER_TUNE_FREQ_CMD_MODE_ATV) ? common_reply->atvint : common_reply->dtvint)
+            break;
+        mdelay(2);
+    }
+    if (!count)
+    {
+        pr_info("%s: ERROR_SI2196_XTVINT_TIMEOUT error:%d!!!!\n", __func__, ERROR_SI2196_XTVINT_TIMEOUT);
+        return ERROR_SI2196_XTVINT_TIMEOUT;
+    }
+    /*wait for sdint ,timeout is 200ms for sdint */
+    count = ((mode==SI2196_TUNER_TUNE_FREQ_CMD_MODE_ATV) ? 100 : 0);
+    for (;count ;count--)
+    {
+        if ((return_code = si2196_check_status(si2196, common_reply)) != 0)
+            return return_code;
+        if (common_reply->sdint)
+            break;
+        mdelay(2);
+    }
+    if (!count)
+    {
+        pr_info("%s: ERROR_SI2196_XSDINT_TIMEOUT error:%d!!!!\n", __func__, ERROR_SI2196_XTVINT_TIMEOUT);
+        return ERROR_SI2196_XTVINT_TIMEOUT;
+    }
+#endif
+    return return_code;
+}
+
+/************************************************************************************************************************
+  NAME: si2196_LoadVideofilter
+  DESCRIPTION:        Load video filters from vidfiltTable in si2196_write_xTV_video_coeffs.h file into si2196
+  Programming Guide Reference:    Flowchart A.4 (Download Video Filters flowchart)
+
+  Parameter:  si2196 Context (I2C address)
+  Parameter:  pointer to video filter table array
+  Parameter:  number of lines in video filter table array (size in bytes / BYTES_PER_LINE)
+  Returns:    si2196/I2C transaction error code, 0 if successful
+************************************************************************************************************************/
+int si2196_loadvideofilter(struct i2c_client *si2196, unsigned char* vidfilttable, int lines, si2196_common_reply_struct *common_reply)
+{
+#define BYTES_PER_LINE 8
+    int line;
+
+    /* for each 8 bytes in VIDFILT_TABLE */
+    for (line = 0; line < lines; line++)
+    {
+        /* send that 8 byte I2C command to si2196 */
+        if (si2196_api_patch(si2196, BYTES_PER_LINE, vidfilttable+BYTES_PER_LINE*line, &reply) != 0)
+        {
+            return ERROR_SI2196_SENDING_COMMAND;
+        }
+    }
+    common_reply = &reply;
+    return 0;
+}
+/************************************************************************************************************************
+  NAME: si2196_Configure
+  DESCRIPTION: Setup si2196 video filters, GPIOs/clocks, Common Properties startup, Tuner startup, ATV startup, and DTV startup.
+  Parameter:  Pointer to si2196 Context (I2C address)
+  Parameter:  rsp - commandResp structure buffer.
+  Returns:    I2C transaction error code, 0 if successful
+************************************************************************************************************************/
+int si2196_configure(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp)
+{
+    int return_code = 0;
+    si2196_propobj_t prop;
+    if(SI2196_DEBUG)
+        pr_info("%s: start!!!\n", __func__);
+
+    /* load ATV video filter file */
+#ifdef USING_ATV_FILTER
+    if ((return_code = si2196_loadvideofilter(si2196, dlif_vidfilt_table, DLIF_VIDFILT_LINES, rsp->reply) != 0)
+        return return_code;
+#endif
+
+    /* Set the GPIO Pins using the CONFIG_PINS command*/
+    if (si2196_config_pins(si2196,      /* turn off BCLK1 and XOUT */
+                           SI2196_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE,
+                           SI2196_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ,
+                           SI2196_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE,
+                           SI2196_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ,
+                           SI2196_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE,
+                           SI2196_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ,
+                           SI2196_CONFIG_PINS_CMD_BCLK1_MODE_DISABLE,
+                           SI2196_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ,
+                           SI2196_CONFIG_PINS_CMD_XOUT_MODE_XOUT,
+                           rsp) !=0)
+    {
+        pr_info("%s: config pins error:%d!!!!\n", __func__, ERROR_SI2196_SENDING_COMMAND);
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+#if  1
+    /* Set Common Properties startup configuration */
+    si2196_setupcommondefaults(&prop);
+    if ((return_code = si2196_commonconfig(si2196, &prop, rsp)) != 0)
+    {
+       pr_info("%s: setup command defaults error:%d!!!!\n", __func__, return_code);
+       return return_code;
+    }
+
+    /* Set Tuner Properties startup configuration */
+    si2196_setuptunerdefaults(&prop);
+    if ((return_code = si2196_tunerconfig(si2196, &prop, rsp)) != 0)
+    {
+        pr_info("%s: setup tuner defaults error:%d!!!!\n", __func__, return_code);
+        return return_code;
+    }
+    /* Set ATV startup configuration */
+    si2196_setupatvdefaults(&prop);
+    if ((return_code = si2196_atvconfig(si2196, &prop, rsp)) != 0)
+    {
+        pr_info("%s: setup atv defaults error:%d!!!!\n", __func__, return_code);
+        return return_code;
+    }
+    /*set dtv startup configuration*/
+    //si2196_setupdtvdefaults(prop);
+    //si2196_dtvconfig(prop);
+    /*set stereo demod default value*/
+    si2196_setupsddefaults(&prop);
+    if((return_code = si2196_stereoconfig(si2196, &prop, rsp))!=0)
+    {
+        pr_info("%s: setup stereo defaults error:%d!!!!\n", __func__, return_code);
+        return return_code;
+    }
+#endif
+
+    return return_code;
+}
+/************************************************************************************************************************
+  NAME: si2196_LoadFirmware
+  DESCRIPTON: Load firmware from FIRMWARE_TABLE array in si2196_Firmware_x_y_build_z.h file into si2196
+              Requires si2196 to be in bootloader mode after PowerUp
+  Programming Guide Reference:    Flowchart A.3 (Download FW PATCH flowchart)
+
+  Parameter:  si2196 Context (I2C address)
+  Parameter:  pointer to firmware table array
+  Parameter:  number of lines in firmware table array (size in bytes / BYTES_PER_LINE)
+  Returns:    si2196/I2C transaction error code, 0 if successful
+************************************************************************************************************************/
+int si2196_loadfirmware(struct i2c_client *si2196, unsigned char* firmwaretable, int lines, si2196_common_reply_struct *common_reply)
+{
+    int return_code = 0;
+    int line;
+
+    /* for each 8 bytes in FIRMWARE_TABLE */
+    for (line = 0; line < lines; line++)
+    {
+        /* send that 8 byte I2C command to si2196 */
+        if (si2196_api_patch(si2196, 8, firmwaretable+8*line, common_reply) != 0)
+        {
+            return ERROR_SI2196_LOADING_FIRMWARE;
+        }
+    }
+    return return_code;
+}
+
+/************************************************************************************************************************
+  NAME: si2196_StartFirmware
+  DESCRIPTION: Start si2196 firmware (put the si2196 into run mode)
+  Parameter:   si2196 Context (I2C address)
+  Parameter (passed by Reference): 	ExitBootloadeer Response Status byte : tunint, atvint, dtvint, err, cts
+  Returns:     I2C transaction error code, 0 if successful
+************************************************************************************************************************/
+int si2196_startfirmware(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp)
+{
+
+    if (si2196_exit_bootloader(si2196, SI2196_EXIT_BOOTLOADER_CMD_FUNC_TUNER, SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_OFF, rsp) != 0)
+    {
+        return ERROR_SI2196_STARTING_FIRMWARE;
+    }
+
+    return 0;
+}
+/************************************************************************************************************************
+  NAME: si2196_PowerUpWithPatch
+  DESCRIPTION: Send si2196 API PowerUp Command with PowerUp to bootloader,
+  Check the Chip rev and part, and ROMID are compared to expected values.
+  Load the Firmware Patch then Start the Firmware.
+  Programming Guide Reference:    Flowchart A.2a (POWER_UP with patch flowchart)
+
+  Parameter:  si2196 Context (I2C address)
+  Returns:    si2196/I2C transaction error code, 0 if successful
+************************************************************************************************************************/
+int si2196_powerupwithpatch(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp, si2196_common_reply_struct *common_reply)
+{
+    int return_code = 0, num = 0;
+
+    return_code = si2196_power_up(si2196,          /* always wait for CTS prior to POWER_UP command */
+                                  SI2196_POWER_UP_CMD_SUBCODE_CODE,
+                                  SI2196_POWER_UP_CMD_RESERVED1_RESERVED,
+                                  SI2196_POWER_UP_CMD_RESERVED2_RESERVED,
+                                  SI2196_POWER_UP_CMD_RESERVED3_RESERVED,
+                                  SI2196_POWER_UP_CMD_CLOCK_MODE_XTAL,
+                                  SI2196_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ,
+                                  SI2196_POWER_UP_CMD_ADDR_MODE_CURRENT,
+                                  SI2196_POWER_UP_CMD_FUNC_BOOTLOADER,        /* start in bootloader mode */
+                                  SI2196_POWER_UP_CMD_CTSIEN_DISABLE,
+                                  SI2196_POWER_UP_CMD_WAKE_UP_WAKE_UP,
+                                  rsp);
+    if (return_code)
+        pr_info("%s: si2196_power_up error:%d!!!\n", __func__, return_code);
+
+#if 0
+    /* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+    if (si2196_part_info(si2196, &rsp) != 0)
+        return ERROR_SI2196_SENDING_COMMAND;
+    /* Check the Chip revision, part and ROMID against expected values and report an error if incompatible */
+    if (rsp.part_info.chiprev != chiprev)
+        return ERROR_SI2196_INCOMPATIBLE_PART;
+    /* Part Number is represented as the last 2 digits */
+    if (rsp.part_info.part != part)
+        return ERROR_SI2196_INCOMPATIBLE_PART;
+    /* Part Major Version in ASCII */
+    if (rsp.part_info.pmajor != partmajorversion)
+        return ERROR_SI2196_INCOMPATIBLE_PART;
+
+#endif
+    mdelay(25);
+ /* Load the Firmware */
+        num = sizeof(si2196_fw_1_2b1)/(8*sizeof(unsigned char));
+        return_code = si2196_loadfirmware(si2196, si2196_fw_1_2b1, num, common_reply);
+
+
+    if (return_code != 0)
+    {
+        pr_info("%s: si2196_loadfirmware error:%d!!!\n", __func__, return_code);
+        return return_code;
+    }
+
+    /*Start the Firmware */
+    if ((return_code = si2196_startfirmware(si2196, rsp)) != 0) /* Start firmware */
+    {
+        pr_info("%s: si2196_startfirmware error:%d!!!\n", __func__, return_code);
+        return return_code;
+    }
+    mdelay(50);
+    if (si2196_get_rev(si2196, rsp) != 0)
+    {
+        pr_info("%s: si2196_get_rev error:%d!!!\n", __func__, ERROR_SI2196_SENDING_COMMAND);
+        return ERROR_SI2196_SENDING_COMMAND;
+    }
+    else
+    {
+        if(SI2196_DEBUG)
+            {
+                pr_info("%s: rsp.get_rev.pn :      %d \n", __func__, rsp->get_rev.pn);
+                pr_info("%s: rsp.get_rev.fwmajor : %d \n", __func__, rsp->get_rev.fwmajor);
+                pr_info("%s: rsp.get_rev.fwminor : %d \n", __func__, rsp->get_rev.fwminor);
+                pr_info("%s: rsp.get_rev.patch :   %d \n", __func__, rsp->get_rev.patch);
+                pr_info("%s: rsp.get_rev.cmpmajor :%d \n", __func__, rsp->get_rev.cmpmajor);
+                pr_info("%s: rsp.get_rev.cmpminor :%d \n", __func__, rsp->get_rev.cmpminor);
+                pr_info("%s: rsp.get_rev.cmpbuild :%d \n", __func__, rsp->get_rev.cmpbuild);
+                pr_info("%s: rsp.get_rev.chiprev : %d \n", __func__, (u32)rsp->get_rev.chiprev);
+            }
+    }
+
+    return return_code;
+}
+
+
+/************************************************************************************************************************
+  NAME: si2196_Init
+  DESCRIPTION:Reset and Initialize si2196
+  Parameter:  si2196 Context (I2C address)
+  Returns:    I2C transaction error code, 0 if successful
+************************************************************************************************************************/
+int si2196_init(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp)
+{
+    int return_code = 0;
+
+    /* Reset si2196 */
+    /* TODO: SendRSTb requires porting to toggle the RSTb line low -> high */
+    //sendrstb();
+
+    return_code = si2196_powerupwithpatch(si2196, rsp, rsp->reply);
+    if (return_code)		/* PowerUp into bootloader */
+    {
+        pr_info("%s: init si2196 error!!!\n", __func__);
+    }
+    /* At this point, FW is loaded and started.  Return 0*/
+    return return_code;
+}
+
+
+
diff --git a/drivers/amlogic/dvb_tv/si2196/si2196_func.h b/drivers/amlogic/dvb_tv/si2196/si2196_func.h
new file mode 100755
index 000000000000..2a682bf4f68b
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/si2196/si2196_func.h
@@ -0,0 +1,4261 @@
+/*
+ * Sli2176 Device Driver
+ *
+ * Author: Bobby Yang <bo.yang@amlogic.com>
+ *
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __SLI2196_FUN_H
+#define __SLI2196_FUN_H
+#include "../aml_fe.h"
+/*debug information*/
+#define SI2196_DEBUG                        1
+
+#define NO_SI2196_ERROR                     0x00
+#define ERROR_SI2196_PARAMETER_OUT_OF_RANGE 0x01
+#define ERROR_SI2196_ALLOCATING_CONTEXT     0x02
+#define ERROR_SI2196_SENDING_COMMAND        0x03
+#define ERROR_SI2196_CTS_TIMEOUT            0x04
+#define ERROR_SI2196_ERR                    0x05
+#define ERROR_SI2196_POLLING_CTS            0x06
+#define ERROR_SI2196_POLLING_RESPONSE       0x07
+#define ERROR_SI2196_LOADING_FIRMWARE       0x08
+#define ERROR_SI2196_LOADING_BOOTBLOCK      0x09
+#define ERROR_SI2196_STARTING_FIRMWARE      0x0a
+#define ERROR_SI2196_SW_RESET               0x0b
+#define ERROR_SI2196_INCOMPATIBLE_PART      0x0c
+/* _specific_error_value_insertion_start */
+#define ERROR_SI2196_TUNINT_TIMEOUT         0x0d
+#define ERROR_SI2196_xTVINT_TIMEOUT         0x0e
+#define ERROR_SI2196_SDINT_TIMEOUT          0x0f
+/* _specific_error_value_insertion_point */
+
+#define NO_SI2196_ERROR                                                 0x00
+#define ERROR_SI2196_PARAMETER_OUT_OF_RANGE  0x01
+#define ERROR_SI2196_ALLOCATING_CONTEXT             0x02
+#define ERROR_SI2196_SENDING_COMMAND                  0x03
+#define ERROR_SI2196_CTS_TIMEOUT                             0x04
+#define ERROR_SI2196_ERR                                               0x05
+#define ERROR_SI2196_POLLING_CTS                              0x06
+#define ERROR_SI2196_POLLING_RESPONSE                 0x07
+#define ERROR_SI2196_LOADING_FIRMWARE                 0x08
+#define ERROR_SI2196_LOADING_BOOTBLOCK               0x09
+#define ERROR_SI2196_STARTING_FIRMWARE               0x0a
+#define ERROR_SI2196_SW_RESET                                   0x0b
+#define ERROR_SI2196_INCOMPATIBLE_PART                0x0c
+#define ERROR_SI2196_TUNINT_TIMEOUT                       0x0d
+#define ERROR_SI2196_XTVINT_TIMEOUT                       0x0e
+
+/* status structure definition */
+typedef struct { /* si2196_common_reply_struct */
+    unsigned char   tunint;
+    unsigned char   atvint;
+    unsigned char   dtvint;
+    unsigned char   sdint;
+    unsigned char   err;
+    unsigned char   cts;
+} si2196_common_reply_struct;
+
+/* _status_defines_insertion_start */
+#define SI2196_COMMAND_PROTOTYPES
+
+
+/* STATUS fields definition */
+/* STATUS, TUNINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2196_STATUS_TUNINT_LSB                            0
+#define  SI2196_STATUS_TUNINT_MASK                         0x01
+#define SI2196_STATUS_TUNINT_NOT_TRIGGERED     0
+#define SI2196_STATUS_TUNINT_TRIGGERED              1
+/* STATUS, ATVINT field definition (size 1, lsb 1, unsigned)*/
+#define  SI2196_STATUS_ATVINT_LSB                            1
+#define  SI2196_STATUS_ATVINT_MASK                         0x01
+#define SI2196_STATUS_ATVINT_NOT_TRIGGERED     0
+#define SI2196_STATUS_ATVINT_TRIGGERED              1
+/* STATUS, DTVINT field definition (size 1, lsb 2, unsigned)*/
+#define  SI2196_STATUS_DTVINT_LSB                            2
+#define  SI2196_STATUS_DTVINT_MASK                         0x01
+#define SI2196_STATUS_DTVINT_NOT_TRIGGERED     0
+#define SI2196_STATUS_DTVINT_TRIGGERED              1
+/* STATUS, ERR field definition (size 1, lsb 6, unsigned)*/
+#define  SI2196_STATUS_ERR_LSB                                  6
+#define  SI2196_STATUS_ERR_MASK                               0x01
+#define SI2196_STATUS_ERR_ERROR                            1
+#define SI2196_STATUS_ERR_NO_ERROR                     0
+/* STATUS, CTS field definition (size 1, lsb 7, unsigned)*/
+#define  SI2196_STATUS_CTS_LSB                                   7
+#define  SI2196_STATUS_CTS_MASK                               0x01
+#define SI2196_STATUS_CTS_COMPLETED                   1
+#define SI2196_STATUS_CTS_WAIT                                0
+
+/* _status_defines_insertion_point */
+
+/* _commands_defines_insertion_start */
+/* SI2196_AGC_OVERRIDE command definition */
+#define SI2196_AGC_OVERRIDE_CMD                               0x44
+
+#ifdef    SI2196_AGC_OVERRIDE_CMD
+
+typedef struct { /* SI2196_AGC_OVERRIDE_CMD_struct */
+     unsigned char   force_max_gain;
+     unsigned char   force_top_gain;
+} si2196_agc_override_cmd_struct;
+
+/* AGC_OVERRIDE command, FORCE_MAX_GAIN field definition (size 1, lsb 0, unsigned) */
+#define  SI2196_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_LSB          0
+#define  SI2196_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MASK       0x01
+#define  SI2196_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MIN           0
+#define  SI2196_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MAX          1
+#define SI2196_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_DISABLE  0
+#define SI2196_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_ENABLE   1
+/* AGC_OVERRIDE command, FORCE_TOP_GAIN field definition (size 1, lsb 1, unsigned) */
+#define  SI2196_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_LSB           1
+#define  SI2196_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MASK        0x01
+#define  SI2196_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MIN           0
+#define  SI2196_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MAX          1
+#define SI2196_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_DISABLE  0
+#define SI2196_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_ENABLE   1
+
+typedef struct { /* SI2196_AGC_OVERRIDE_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_agc_override_cmd_reply_struct;
+
+#endif /* SI2196_AGC_OVERRIDE_CMD */
+
+/* SI2196_ATV_CW_TEST command definition */
+//#define SI2196_ATV_CW_TEST_CMD 0x53
+
+#ifdef    SI2196_ATV_CW_TEST_CMD
+
+typedef struct { /* SI2196_ATV_CW_TEST_CMD_struct */
+     unsigned char   pc_lock;
+} si2196_atv_cw_test_cmd_struct;
+
+/* ATV_CW_TEST command, PC_LOCK field definition (size 1, lsb 0, unsigned) */
+#define  SI2196_ATV_CW_TEST_CMD_PC_LOCK_LSB          0
+#define  SI2196_ATV_CW_TEST_CMD_PC_LOCK_MASK       0x01
+#define  SI2196_ATV_CW_TEST_CMD_PC_LOCK_MIN          0
+#define  SI2196_ATV_CW_TEST_CMD_PC_LOCK_MAX         1
+#define SI2196_ATV_CW_TEST_CMD_PC_LOCK_LOCK       1
+#define SI2196_ATV_CW_TEST_CMD_PC_LOCK_UNLOCK  0
+
+typedef struct { /* SI2196_ATV_CW_TEST_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_atv_cw_test_cmd_reply_struct;
+
+#endif /* SI2196_ATV_CW_TEST_CMD */
+
+/* SI2196_ATV_RESTART command definition */
+#define SI2196_ATV_RESTART_CMD                                         0x51
+
+#ifdef    SI2196_ATV_RESTART_CMD
+
+typedef struct { /* SI2196_ATV_RESTART_CMD_struct */
+     unsigned char   mode;
+} si2196_atv_restart_cmd_struct;
+
+/* ATV_RESTART command, MODE field definition (size 1, lsb 0, unsigned) */
+#define  SI2196_ATV_RESTART_CMD_MODE_LSB                     0
+#define  SI2196_ATV_RESTART_CMD_MODE_MASK                  0x01
+#define  SI2196_ATV_RESTART_CMD_MODE_MIN                      0
+#define  SI2196_ATV_RESTART_CMD_MODE_MAX                     1
+#define SI2196_ATV_RESTART_CMD_MODE_AUDIO_ONLY      1
+#define SI2196_ATV_RESTART_CMD_MODE_AUDIO_VIDEO    0
+
+typedef struct { /* SI2196_ATV_RESTART_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_atv_restart_cmd_reply_struct;
+
+#endif /* SI2196_ATV_RESTART_CMD */
+
+/* SI2196_ATV_STATUS command definition */
+#define SI2196_ATV_STATUS_CMD                                                  0x52
+
+#ifdef    SI2196_ATV_STATUS_CMD
+
+typedef struct { /* SI2196_ATV_STATUS_CMD_struct */
+     unsigned char   intack;
+} si2196_atv_status_cmd_struct;
+
+/* ATV_STATUS command, INTACK field definition (size 1, lsb 0, unsigned) */
+#define  SI2196_ATV_STATUS_CMD_INTACK_LSB                    0
+#define  SI2196_ATV_STATUS_CMD_INTACK_MASK                 0x01
+#define  SI2196_ATV_STATUS_CMD_INTACK_MIN                    0
+#define  SI2196_ATV_STATUS_CMD_INTACK_MAX                   1
+#define SI2196_ATV_STATUS_CMD_INTACK_CLEAR               1
+#define SI2196_ATV_STATUS_CMD_INTACK_OK                      0
+
+typedef struct { /* SI2196_ATV_STATUS_CMD_REPLY_struct */
+      unsigned char   chlint;
+      unsigned char   pclint;
+      unsigned char   dlint;
+      unsigned char   snrlint;
+      unsigned char   snrhint;
+      unsigned char   audio_chan_bw;
+      unsigned char   chl;
+      unsigned char   pcl;
+      unsigned char   dl;
+      unsigned char   snrl;
+      unsigned char   snrh;
+      unsigned char   video_snr;
+               int             afc_freq;
+               int             video_sc_spacing;
+      unsigned char   video_sys;
+      unsigned char   color;
+      unsigned char   trans;
+      unsigned char   audio_sys;
+}  si2196_atv_status_cmd_reply_struct;
+/* ATV_STATUS command, CHLINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_CHLINT_LSB                  0
+#define  SI2196_ATV_STATUS_RESPONSE_CHLINT_MASK               0x01
+#define SI2196_ATV_STATUS_RESPONSE_CHLINT_CHANGED       1
+#define SI2196_ATV_STATUS_RESPONSE_CHLINT_NO_CHANGE   0
+/* ATV_STATUS command, PCLINT field definition (size 1, lsb 1, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_PCLINT_LSB                   1
+#define  SI2196_ATV_STATUS_RESPONSE_PCLINT_MASK                0x01
+#define SI2196_ATV_STATUS_RESPONSE_PCLINT_CHANGED        1
+#define SI2196_ATV_STATUS_RESPONSE_PCLINT_NO_CHANGE    0
+/* ATV_STATUS command, DLINT field definition (size 1, lsb 2, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_DLINT_LSB                      2
+#define  SI2196_ATV_STATUS_RESPONSE_DLINT_MASK                   0x01
+#define SI2196_ATV_STATUS_RESPONSE_DLINT_CHANGED           1
+#define SI2196_ATV_STATUS_RESPONSE_DLINT_NO_CHANGE       0
+/* ATV_STATUS command, SNRLINT field definition (size 1, lsb 3, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_SNRLINT_LSB                 3
+#define  SI2196_ATV_STATUS_RESPONSE_SNRLINT_MASK              0x01
+#define SI2196_ATV_STATUS_RESPONSE_SNRLINT_CHANGED      1
+#define SI2196_ATV_STATUS_RESPONSE_SNRLINT_NO_CHANGE  0
+/* ATV_STATUS command, SNRHINT field definition (size 1, lsb 4, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_SNRHINT_LSB                 4
+#define  SI2196_ATV_STATUS_RESPONSE_SNRHINT_MASK              0x01
+#define SI2196_ATV_STATUS_RESPONSE_SNRHINT_CHANGED      1
+#define SI2196_ATV_STATUS_RESPONSE_SNRHINT_NO_CHANGE  0
+/* ATV_STATUS command, AUDIO_CHAN_BW field definition (size 4, lsb 0, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_LSB                         0
+#define  SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_MASK                      0x0f
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_12X_OVERMOD      3
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_150_KHZ_OFFSET  8
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_15_KHZ_OFFSET    5
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_30_KHZ_OFFSET    6
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_4X_OVERMOD         1
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_75_KHZ_OFFSET     7
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_7P5_KHZ_OFFSET  4
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_8X_OVERMOD         2
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_CHAN_BW_RSVD                       0
+/* ATV_STATUS command, CHL field definition (size 1, lsb 0, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_CHL_LSB                                            0
+#define  SI2196_ATV_STATUS_RESPONSE_CHL_MASK                                         0x01
+#define SI2196_ATV_STATUS_RESPONSE_CHL_CHANNEL                                 1
+#define SI2196_ATV_STATUS_RESPONSE_CHL_NO_CHANNEL                          0
+/* ATV_STATUS command, PCL field definition (size 1, lsb 1, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_PCL_LSB                                            1
+#define  SI2196_ATV_STATUS_RESPONSE_PCL_MASK                                         0x01
+#define SI2196_ATV_STATUS_RESPONSE_PCL_LOCKED                                    1
+#define SI2196_ATV_STATUS_RESPONSE_PCL_NO_LOCK                                  0
+/* ATV_STATUS command, DL field definition (size 1, lsb 2, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_DL_LSB                                              2
+#define  SI2196_ATV_STATUS_RESPONSE_DL_MASK                                           0x01
+#define SI2196_ATV_STATUS_RESPONSE_DL_LOCKED                                       1
+#define SI2196_ATV_STATUS_RESPONSE_DL_NO_LOCK                                     0
+/* ATV_STATUS command, SNRL field definition (size 1, lsb 3, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_SNRL_LSB                                         3
+#define  SI2196_ATV_STATUS_RESPONSE_SNRL_MASK                                      0x01
+#define SI2196_ATV_STATUS_RESPONSE_SNRL_SNR_LOW                               1
+#define SI2196_ATV_STATUS_RESPONSE_SNRL_SNR_NOT_LOW                      0
+/* ATV_STATUS command, SNRH field definition (size 1, lsb 4, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_SNRH_LSB                                         4
+#define  SI2196_ATV_STATUS_RESPONSE_SNRH_MASK                                      0x01
+#define SI2196_ATV_STATUS_RESPONSE_SNRH_SNR_HIGH                             1
+#define SI2196_ATV_STATUS_RESPONSE_SNRH_SNR_NOT_HIGH                    0
+/* ATV_STATUS command, VIDEO_SNR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_VIDEO_SNR_LSB                               0
+#define  SI2196_ATV_STATUS_RESPONSE_VIDEO_SNR_MASK                            0xff
+/* ATV_STATUS command, AFC_FREQ field definition (size 16, lsb 0, signed)*/
+#define  SI2196_ATV_STATUS_RESPONSE_AFC_FREQ_LSB                                 0
+#define  SI2196_ATV_STATUS_RESPONSE_AFC_FREQ_MASK                              0xffff
+#define  SI2196_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT                             16
+/* ATV_STATUS command, VIDEO_SC_SPACING field definition (size 16, lsb 0, signed)*/
+#define  SI2196_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_LSB                0
+#define  SI2196_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_MASK             0xffff
+#define  SI2196_ATV_STATUS_RESPONSE_VIDEO_SC_SPACING_SHIFT            16
+/* ATV_STATUS command, VIDEO_SYS field definition (size 3, lsb 0, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB                                0
+#define  SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK                             0x07
+#define SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_B                                     0
+#define SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_DK                                  5
+#define SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_GH                                  1
+#define SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_I                                      4
+#define SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_L                                     6
+#define SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_LP                                   7
+#define SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_M                                     2
+#define SI2196_ATV_STATUS_RESPONSE_VIDEO_SYS_N                                     3
+/* ATV_STATUS command, COLOR field definition (size 1, lsb 4, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_COLOR_LSB                                        4
+#define  SI2196_ATV_STATUS_RESPONSE_COLOR_MASK                                     0x01
+#define SI2196_ATV_STATUS_RESPONSE_COLOR_PAL_NTSC                             0
+#define SI2196_ATV_STATUS_RESPONSE_COLOR_SECAM                                   1
+/* ATV_STATUS command, TRANS field definition (size 1, lsb 6, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_TRANS_LSB                                         6
+#define  SI2196_ATV_STATUS_RESPONSE_TRANS_MASK                                      0x01
+#define SI2196_ATV_STATUS_RESPONSE_TRANS_CABLE                                     1
+#define SI2196_ATV_STATUS_RESPONSE_TRANS_TERRESTRIAL                        0
+/* ATV_STATUS command, AUDIO_SYS field definition (size 4, lsb 0, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_LSB                                  0
+#define  SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_MASK                               0x0f
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_A2                                     3
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK2                            4
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK3                            5
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_A2_DK4                            9
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_BTSC                                6
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_EIAJ                                  7
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO                               1
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_MONO_NICAM                  2
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_RSVD                                0
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_SCAN                                8
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_SYS_WIDE_SCAN                     10
+/* ATV_STATUS command, AUDIO_DEMOD_MODE field definition (size 2, lsb 4, unsigned)*/
+#define  SI2196_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_LSB                 4
+#define  SI2196_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_MASK              0x03
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_AM                   1
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_FM1                 2
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_FM2                 3
+#define SI2196_ATV_STATUS_RESPONSE_AUDIO_DEMOD_MODE_SIF                  0
+
+#endif /* SI2196_ATV_STATUS_CMD */
+
+/* SI2196_CONFIG_PINS command definition */
+#define SI2196_CONFIG_PINS_CMD                                                                            0x12
+
+#ifdef    SI2196_CONFIG_PINS_CMD
+
+typedef struct { /* SI2196_CONFIG_PINS_CMD_struct */
+     unsigned char   gpio1_mode;
+     unsigned char   gpio1_read;
+     unsigned char   gpio2_mode;
+     unsigned char   gpio2_read;
+     unsigned char   gpio3_mode;
+     unsigned char   gpio3_read;
+     unsigned char   bclk1_mode;
+     unsigned char   bclk1_read;
+     unsigned char   xout_mode;
+} si2196_config_pins_cmd_struct;
+/* CONFIG_PINS command, GPIO1_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2196_CONFIG_PINS_CMD_GPIO1_MODE_LSB                                     0
+#define  SI2196_CONFIG_PINS_CMD_GPIO1_MODE_MASK                                  0x7f
+#define  SI2196_CONFIG_PINS_CMD_GPIO1_MODE_MIN                                     0
+#define  SI2196_CONFIG_PINS_CMD_GPIO1_MODE_MAX                                    3
+#define SI2196_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE                            1
+#define SI2196_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_0                             2
+#define SI2196_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1                             3
+#define SI2196_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE                      0
+/* CONFIG_PINS command, GPIO1_READ field definition (size 1, lsb 7, unsigned) */
+#define  SI2196_CONFIG_PINS_CMD_GPIO1_READ_LSB                                       7
+#define  SI2196_CONFIG_PINS_CMD_GPIO1_READ_MASK                                    0x01
+#define  SI2196_CONFIG_PINS_CMD_GPIO1_READ_MIN                                        0
+#define  SI2196_CONFIG_PINS_CMD_GPIO1_READ_MAX                                       1
+#define SI2196_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ                    0
+#define SI2196_CONFIG_PINS_CMD_GPIO1_READ_READ                                    1
+/* CONFIG_PINS command, GPIO2_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2196_CONFIG_PINS_CMD_GPIO2_MODE_LSB                                       0
+#define  SI2196_CONFIG_PINS_CMD_GPIO2_MODE_MASK                                    0x7f
+#define  SI2196_CONFIG_PINS_CMD_GPIO2_MODE_MIN                                       0
+#define  SI2196_CONFIG_PINS_CMD_GPIO2_MODE_MAX                                      3
+#define SI2196_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE                              1
+#define SI2196_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_0                               2
+#define SI2196_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_1                               3
+#define SI2196_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE                        0
+/* CONFIG_PINS command, GPIO2_READ field definition (size 1, lsb 7, unsigned) */
+#define  SI2196_CONFIG_PINS_CMD_GPIO2_READ_LSB                                        7
+#define  SI2196_CONFIG_PINS_CMD_GPIO2_READ_MASK                                     0x01
+#define  SI2196_CONFIG_PINS_CMD_GPIO2_READ_MIN                                        0
+#define  SI2196_CONFIG_PINS_CMD_GPIO2_READ_MAX                                       1
+#define SI2196_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ                     0
+#define SI2196_CONFIG_PINS_CMD_GPIO2_READ_READ                                     1
+/* CONFIG_PINS command, GPIO3_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2196_CONFIG_PINS_CMD_GPIO3_MODE_LSB                                        0
+#define  SI2196_CONFIG_PINS_CMD_GPIO3_MODE_MASK                                     0x7f
+#define  SI2196_CONFIG_PINS_CMD_GPIO3_MODE_MIN                                        0
+#define  SI2196_CONFIG_PINS_CMD_GPIO3_MODE_MAX                                       3
+#define SI2196_CONFIG_PINS_CMD_GPIO3_MODE_DISABLE                               1
+#define SI2196_CONFIG_PINS_CMD_GPIO3_MODE_DRIVE_0                                2
+#define SI2196_CONFIG_PINS_CMD_GPIO3_MODE_DRIVE_1                                3
+#define SI2196_CONFIG_PINS_CMD_GPIO3_MODE_NO_CHANGE                         0
+/* CONFIG_PINS command, GPIO3_READ field definition (size 1, lsb 7, unsigned) */
+#define  SI2196_CONFIG_PINS_CMD_GPIO3_READ_LSB                                         7
+#define  SI2196_CONFIG_PINS_CMD_GPIO3_READ_MASK                                      0x01
+#define  SI2196_CONFIG_PINS_CMD_GPIO3_READ_MIN                                          0
+#define  SI2196_CONFIG_PINS_CMD_GPIO3_READ_MAX                                         1
+#define SI2196_CONFIG_PINS_CMD_GPIO3_READ_DO_NOT_READ                       0
+#define SI2196_CONFIG_PINS_CMD_GPIO3_READ_READ                                       1
+/* CONFIG_PINS command, BCLK1_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2196_CONFIG_PINS_CMD_BCLK1_MODE_LSB                                          0
+#define  SI2196_CONFIG_PINS_CMD_BCLK1_MODE_MASK                                       0x7f
+#define  SI2196_CONFIG_PINS_CMD_BCLK1_MODE_MIN                                          0
+#define  SI2196_CONFIG_PINS_CMD_BCLK1_MODE_MAX                                         26
+#define SI2196_CONFIG_PINS_CMD_BCLK1_MODE_DISABLE                                  1
+#define SI2196_CONFIG_PINS_CMD_BCLK1_MODE_NO_CHANGE                           0
+#define SI2196_CONFIG_PINS_CMD_BCLK1_MODE_XOUT                                       10
+#define SI2196_CONFIG_PINS_CMD_BCLK1_MODE_XOUT_HIGH                            11
+/* CONFIG_PINS command, BCLK1_READ field definition (size 1, lsb 7, unsigned) */
+#define  SI2196_CONFIG_PINS_CMD_BCLK1_READ_LSB                                          7
+#define  SI2196_CONFIG_PINS_CMD_BCLK1_READ_MASK                                      0x01
+#define  SI2196_CONFIG_PINS_CMD_BCLK1_READ_MIN                                         0
+#define  SI2196_CONFIG_PINS_CMD_BCLK1_READ_MAX                                        1
+#define SI2196_CONFIG_PINS_CMD_BCLK1_READ_DO_NOT_READ                      0
+#define SI2196_CONFIG_PINS_CMD_BCLK1_READ_READ                                      1
+/* CONFIG_PINS command, XOUT_MODE field definition (size 7, lsb 0, unsigned) */
+#define  SI2196_CONFIG_PINS_CMD_XOUT_MODE_LSB                                        0
+#define  SI2196_CONFIG_PINS_CMD_XOUT_MODE_MASK                                     0x7f
+#define  SI2196_CONFIG_PINS_CMD_XOUT_MODE_MIN                                         0
+#define  SI2196_CONFIG_PINS_CMD_XOUT_MODE_MAX                                        10
+#define SI2196_CONFIG_PINS_CMD_XOUT_MODE_DISABLE                                  1
+#define SI2196_CONFIG_PINS_CMD_XOUT_MODE_NO_CHANGE                           0
+#define SI2196_CONFIG_PINS_CMD_XOUT_MODE_XOUT                                       10
+
+typedef struct { /* SI2196_CONFIG_PINS_CMD_REPLY_struct */
+      unsigned char   gpio1_mode;
+      unsigned char   gpio1_state;
+      unsigned char   gpio2_mode;
+      unsigned char   gpio2_state;
+      unsigned char   gpio3_mode;
+      unsigned char   gpio3_state;
+      unsigned char   bclk1_mode;
+      unsigned char   bclk1_state;
+      unsigned char   xout_mode;
+}  si2196_config_pins_cmd_reply_struct;
+/* CONFIG_PINS command, GPIO1_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB                            0
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK                         0x7f
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO1_MODE_DISABLE                    1
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_0                    2
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_1                    3
+/* CONFIG_PINS command, GPIO1_STATE field definition (size 1, lsb 7, unsigned)*/
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB                           7
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK                        0x01
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_0                    0
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_1                    1
+/* CONFIG_PINS command, GPIO2_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB                            0
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK                         0x7f
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO2_MODE_DISABLE                    1
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_0                    2
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_1                    3
+/* CONFIG_PINS command, GPIO2_STATE field definition (size 1, lsb 7, unsigned)*/
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB                            7
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK                        0x01
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_0                    0
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_1                    1
+/* CONFIG_PINS command, GPIO3_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO3_MODE_LSB                            0
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO3_MODE_MASK                         0x7f
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO3_MODE_DISABLE                    1
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO3_MODE_DRIVE_0                    2
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO3_MODE_DRIVE_1                    3
+/* CONFIG_PINS command, GPIO3_STATE field definition (size 1, lsb 7, unsigned)*/
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO3_STATE_LSB                           7
+#define  SI2196_CONFIG_PINS_RESPONSE_GPIO3_STATE_MASK                        0x01
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO3_STATE_READ_0                    0
+#define SI2196_CONFIG_PINS_RESPONSE_GPIO3_STATE_READ_1                    1
+/* CONFIG_PINS command, BCLK1_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2196_CONFIG_PINS_RESPONSE_BCLK1_MODE_LSB                            0
+#define  SI2196_CONFIG_PINS_RESPONSE_BCLK1_MODE_MASK                         0x7f
+#define SI2196_CONFIG_PINS_RESPONSE_BCLK1_MODE_DISABLE                   1
+#define SI2196_CONFIG_PINS_RESPONSE_BCLK1_MODE_XOUT                         10
+#define SI2196_CONFIG_PINS_RESPONSE_BCLK1_MODE_XOUT_HIGH              11
+/* CONFIG_PINS command, BCLK1_STATE field definition (size 1, lsb 7, unsigned)*/
+#define  SI2196_CONFIG_PINS_RESPONSE_BCLK1_STATE_LSB                          7
+#define  SI2196_CONFIG_PINS_RESPONSE_BCLK1_STATE_MASK                       0x01
+#define SI2196_CONFIG_PINS_RESPONSE_BCLK1_STATE_READ_0                    0
+#define SI2196_CONFIG_PINS_RESPONSE_BCLK1_STATE_READ_1                    1
+/* CONFIG_PINS command, XOUT_MODE field definition (size 7, lsb 0, unsigned)*/
+#define  SI2196_CONFIG_PINS_RESPONSE_XOUT_MODE_LSB                              0
+#define  SI2196_CONFIG_PINS_RESPONSE_XOUT_MODE_MASK                           0x7f
+#define SI2196_CONFIG_PINS_RESPONSE_XOUT_MODE_DISABLE                      1
+#define SI2196_CONFIG_PINS_RESPONSE_XOUT_MODE_XOUT                            10
+
+#endif /* SI2196_CONFIG_PINS_CMD */
+
+/* SI2196_DOWNLOAD_DATASET_CONTINUE command definition */
+//#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD 0xb9
+
+#ifdef    SI2196_DOWNLOAD_DATASET_CONTINUE_CMD
+
+typedef struct { /* SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_struct */
+     unsigned char   data0;
+     unsigned char   data1;
+     unsigned char   data2;
+     unsigned char   data3;
+     unsigned char   data4;
+     unsigned char   data5;
+     unsigned char   data6;
+} si2196_download_dataset_continue_cmd_struct;
+
+/* DOWNLOAD_DATASET_CONTINUE command, DATA0 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_LSB               0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MASK            0xff
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MIN               0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MAX              255
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MIN  0
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MAX 255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA1 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_LSB               0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MASK            0xff
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MIN               0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MAX              255
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MIN  0
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MAX 255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA2 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_LSB               0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MASK            0xff
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MIN               0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MAX              255
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MIN  0
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MAX 255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA3 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_LSB               0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MASK            0xff
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MIN                0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MAX              255
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MIN   0
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA4 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_LSB                0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MASK             0xff
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MIN                0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MAX               255
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MIN   0
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MAX  255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA5 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_LSB                0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MASK             0xff
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MIN                 0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MAX                255
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MIN    0
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MAX   255
+/* DOWNLOAD_DATASET_CONTINUE command, DATA6 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_LSB                 0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MASK              0xff
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MIN                  0
+#define  SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MAX                 255
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MIN     0
+#define SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MAX    255
+
+typedef struct { /* SI2196_DOWNLOAD_DATASET_CONTINUE_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_download_dataset_continue_cmd_reply_struct;
+
+#endif /* SI2196_DOWNLOAD_DATASET_CONTINUE_CMD */
+
+/* SI2196_DOWNLOAD_DATASET_START command definition */
+//#define SI2196_DOWNLOAD_DATASET_START_CMD 0xb8
+
+#ifdef    SI2196_DOWNLOAD_DATASET_START_CMD
+
+typedef struct { /* SI2196_DOWNLOAD_DATASET_START_CMD_struct */
+     unsigned char   dataset_id;
+     unsigned char   dataset_checksum;
+     unsigned char   data0;
+     unsigned char   data1;
+     unsigned char   data2;
+     unsigned char   data3;
+     unsigned char   data4;
+} si2196_download_dataset_start_cmd_struct;
+/* DOWNLOAD_DATASET_START command, DATASET_ID field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_LSB                        0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MASK                     0xff
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MIN                         0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MAX                        29
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_B     6
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_DK   7
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_G     8
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_I       9
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_L      10
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBBYPASS_M     11
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_B       12
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_DK     13
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_G       14
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_I        15
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_L       16
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFBNOTCH_M      17
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_B           21
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_DK        22
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_G           23
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_I            24
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_L           25
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_APFB_LPF_M          26
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_ALIF_6  27
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_ALIF_7  28
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_ALIF_8  29
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_B           0
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DK        1
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DTV_6  18
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DTV_7  19
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_DTV_8  20
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_G           2
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_I            3
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_L           4
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_ID_VIDEOFILT_M          5
+/* DOWNLOAD_DATASET_START command, DATASET_CHECKSUM field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_LSB         0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MASK      0xff
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MIN         0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MAX        255
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MIN  0
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA0 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA0_LSB              0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA0_MASK           0xff
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA0_MIN               0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA0_MAX              255
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MIN   0
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA1 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA1_LSB               0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA1_MASK            0xff
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA1_MIN               0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA1_MAX              255
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MIN   0
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA2 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA2_LSB                0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA2_MASK             0xff
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA2_MIN                 0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA2_MAX                255
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MIN    0
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MAX  255
+/* DOWNLOAD_DATASET_START command, DATA3 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA3_LSB                 0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA3_MASK              0xff
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA3_MIN                 0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA3_MAX                255
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MIN    0
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MAX   255
+/* DOWNLOAD_DATASET_START command, DATA4 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA4_LSB                 0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA4_MASK              0xff
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA4_MIN                 0
+#define  SI2196_DOWNLOAD_DATASET_START_CMD_DATA4_MAX                255
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MIN    0
+#define SI2196_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MAX   255
+
+typedef struct { /* SI2196_DOWNLOAD_DATASET_START_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_download_dataset_start_cmd_reply_struct;
+
+#endif /* SI2196_DOWNLOAD_DATASET_START_CMD */
+
+/* SI2196_DTV_RESTART command definition */
+//#define SI2196_DTV_RESTART_CMD 0x61
+
+#ifdef    SI2196_DTV_RESTART_CMD
+
+typedef struct { /* SI2196_DTV_RESTART_CMD_struct */
+       unsigned char   nothing;
+} si2196_dtv_restart_cmd_struct;
+
+
+typedef struct { /* SI2196_DTV_RESTART_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_dtv_restart_cmd_reply_struct;
+
+#endif /* SI2196_DTV_RESTART_CMD */
+
+/* SI2196_DTV_STATUS command definition */
+//#define SI2196_DTV_STATUS_CMD 0x62
+
+#ifdef    SI2196_DTV_STATUS_CMD
+
+typedef struct { /* SI2196_DTV_STATUS_CMD_struct */
+     unsigned char   intack;
+} si2196_dtv_status_cmd_struct;
+
+/* DTV_STATUS command, INTACK field definition (size 1, lsb 0, unsigned) */
+#define  SI2196_DTV_STATUS_CMD_INTACK_LSB          0
+#define  SI2196_DTV_STATUS_CMD_INTACK_MASK       0x01
+#define  SI2196_DTV_STATUS_CMD_INTACK_MIN          0
+#define  SI2196_DTV_STATUS_CMD_INTACK_MAX         1
+#define SI2196_DTV_STATUS_CMD_INTACK_CLEAR      1
+#define SI2196_DTV_STATUS_CMD_INTACK_OK             0
+
+typedef struct { /* SI2196_DTV_STATUS_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+      unsigned char   chlint;
+      unsigned char   chl;
+      unsigned char   bw;
+      unsigned char   modulation;
+}  si2196_dtv_status_cmd_reply_struct;
+
+/* DTV_STATUS command, CHLINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2196_DTV_STATUS_RESPONSE_CHLINT_LSB                 0
+#define  SI2196_DTV_STATUS_RESPONSE_CHLINT_MASK              0x01
+#define SI2196_DTV_STATUS_RESPONSE_CHLINT_CHANGED       1
+#define SI2196_DTV_STATUS_RESPONSE_CHLINT_NO_CHANGE   0
+/* DTV_STATUS command, CHL field definition (size 1, lsb 0, unsigned)*/
+#define  SI2196_DTV_STATUS_RESPONSE_CHL_LSB                       0
+#define  SI2196_DTV_STATUS_RESPONSE_CHL_MASK                    0x01
+#define SI2196_DTV_STATUS_RESPONSE_CHL_CHANNEL              1
+#define SI2196_DTV_STATUS_RESPONSE_CHL_NO_CHANNEL       0
+/* DTV_STATUS command, BW field definition (size 4, lsb 0, unsigned)*/
+#define  SI2196_DTV_STATUS_RESPONSE_BW_LSB                         0
+#define  SI2196_DTV_STATUS_RESPONSE_BW_MASK                      0x0f
+#define SI2196_DTV_STATUS_RESPONSE_BW_BW_6MHZ                6
+#define SI2196_DTV_STATUS_RESPONSE_BW_BW_7MHZ                7
+#define SI2196_DTV_STATUS_RESPONSE_BW_BW_8MHZ                8
+/* DTV_STATUS command, MODULATION field definition (size 4, lsb 4, unsigned)*/
+#define  SI2196_DTV_STATUS_RESPONSE_MODULATION_LSB       4
+#define  SI2196_DTV_STATUS_RESPONSE_MODULATION_MASK    0x0f
+#define SI2196_DTV_STATUS_RESPONSE_MODULATION_ATSC      0
+#define SI2196_DTV_STATUS_RESPONSE_MODULATION_DTMB      6
+#define SI2196_DTV_STATUS_RESPONSE_MODULATION_DVBC      3
+#define SI2196_DTV_STATUS_RESPONSE_MODULATION_DVBT       2
+#define SI2196_DTV_STATUS_RESPONSE_MODULATION_ISDBC     5
+#define SI2196_DTV_STATUS_RESPONSE_MODULATION_ISDBT     4
+#define SI2196_DTV_STATUS_RESPONSE_MODULATION_QAM_US  1
+
+#endif /* SI2196_DTV_STATUS_CMD */
+
+/* SI2196_EXIT_BOOTLOADER command definition */
+#define SI2196_EXIT_BOOTLOADER_CMD                                             0x01
+
+#ifdef    SI2196_EXIT_BOOTLOADER_CMD
+
+typedef struct { /* SI2196_EXIT_BOOTLOADER_CMD_struct */
+     unsigned char   func;
+     unsigned char   ctsien;
+} si2196_exit_bootloader_cmd_struct;
+
+/* EXIT_BOOTLOADER command, FUNC field definition (size 4, lsb 0, unsigned) */
+#define  SI2196_EXIT_BOOTLOADER_CMD_FUNC_LSB                        0
+#define  SI2196_EXIT_BOOTLOADER_CMD_FUNC_MASK                     0x0f
+#define  SI2196_EXIT_BOOTLOADER_CMD_FUNC_MIN                        0
+#define  SI2196_EXIT_BOOTLOADER_CMD_FUNC_MAX                       1
+#define SI2196_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER       0
+#define SI2196_EXIT_BOOTLOADER_CMD_FUNC_TUNER                   1
+/* EXIT_BOOTLOADER command, CTSIEN field definition (size 1, lsb 7, unsigned) */
+#define  SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_LSB                     7
+#define  SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_MASK                 0x01
+#define  SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_MIN                     0
+#define  SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_MAX                    1
+#define SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_OFF                     0
+#define SI2196_EXIT_BOOTLOADER_CMD_CTSIEN_ON                       1
+
+typedef struct { /* SI2196_EXIT_BOOTLOADER_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_exit_bootloader_cmd_reply_struct;
+
+#endif /* SI2196_EXIT_BOOTLOADER_CMD */
+
+/* SI2196_FINE_TUNE command definition */
+#define SI2196_FINE_TUNE_CMD                                                            0x45
+
+#ifdef    SI2196_FINE_TUNE_CMD
+
+typedef struct { /* SI2196_FINE_TUNE_CMD_struct */
+     unsigned char   reserved;
+                       int    offset_500hz;
+} si2196_fine_tune_cmd_struct;
+
+/* FINE_TUNE command, RESERVED field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_FINE_TUNE_CMD_RESERVED_LSB                             0
+#define  SI2196_FINE_TUNE_CMD_RESERVED_MASK                          0xff
+#define  SI2196_FINE_TUNE_CMD_RESERVED_MIN                             0
+#define  SI2196_FINE_TUNE_CMD_RESERVED_MAX                            0
+#define SI2196_FINE_TUNE_CMD_RESERVED_RESERVED                 0
+/* FINE_TUNE command, OFFSET_500HZ field definition (size 16, lsb 0, signed) */
+#define  SI2196_FINE_TUNE_CMD_OFFSET_500HZ_LSB                      0
+#define  SI2196_FINE_TUNE_CMD_OFFSET_500HZ_MASK                   0xffff
+#define  SI2196_FINE_TUNE_CMD_OFFSET_500HZ_SHIFT                  16
+#define  SI2196_FINE_TUNE_CMD_OFFSET_500HZ_MIN                      -4000
+#define  SI2196_FINE_TUNE_CMD_OFFSET_500HZ_MAX                     4000
+#define SI2196_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MIN  -4000
+#define SI2196_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MAX  4000
+
+typedef struct { /* SI2196_FINE_TUNE_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_fine_tune_cmd_reply_struct;
+
+#endif /* SI2196_FINE_TUNE_CMD */
+
+/* SI2196_GET_PROPERTY command definition */
+#define SI2196_GET_PROPERTY_CMD                                                    0x15
+
+#ifdef    SI2196_GET_PROPERTY_CMD
+
+typedef struct { /* SI2196_GET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned   int    prop;
+} si2196_get_property_cmd_struct;
+
+/* GET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_GET_PROPERTY_CMD_RESERVED_LSB                     0
+#define  SI2196_GET_PROPERTY_CMD_RESERVED_MASK                  0xff
+#define  SI2196_GET_PROPERTY_CMD_RESERVED_MIN                      0
+#define  SI2196_GET_PROPERTY_CMD_RESERVED_MAX                     0
+#define SI2196_GET_PROPERTY_CMD_RESERVED_RESERVED_MIN  0
+#define SI2196_GET_PROPERTY_CMD_RESERVED_RESERVED_MAX 0
+/* GET_PROPERTY command, PROP field definition (size 16, lsb 0, unsigned) */
+#define  SI2196_GET_PROPERTY_CMD_PROP_LSB                                0
+#define  SI2196_GET_PROPERTY_CMD_PROP_MASK                             0xffff
+#define  SI2196_GET_PROPERTY_CMD_PROP_MIN                                0
+#define  SI2196_GET_PROPERTY_CMD_PROP_MAX                               65535
+#define SI2196_GET_PROPERTY_CMD_PROP_PROP_MIN                      0
+#define SI2196_GET_PROPERTY_CMD_PROP_PROP_MAX                     65535
+
+typedef struct { /* SI2196_GET_PROPERTY_CMD_REPLY_struct */
+      unsigned char   reserved;
+      unsigned int    data;
+}  si2196_get_property_cmd_reply_struct;
+
+/* GET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_GET_PROPERTY_RESPONSE_RESERVED_LSB         0
+#define  SI2196_GET_PROPERTY_RESPONSE_RESERVED_MASK      0xff
+/* GET_PROPERTY command, DATA field definition (size 16, lsb 0, unsigned)*/
+#define  SI2196_GET_PROPERTY_RESPONSE_DATA_LSB                   0
+#define  SI2196_GET_PROPERTY_RESPONSE_DATA_MASK                0xffff
+
+#endif /* SI2196_GET_PROPERTY_CMD */
+
+/* SI2196_GET_REV command definition */
+#define SI2196_GET_REV_CMD                                                                  0x11
+
+#ifdef    SI2196_GET_REV_CMD
+
+typedef struct { /* SI2196_GET_REV_CMD_struct */
+    unsigned char   nothing;
+} si2196_get_rev_cmd_struct;
+
+
+typedef struct { /* SI2196_GET_REV_CMD_REPLY_struct */
+      unsigned  char                          pn;
+      unsigned  char                          fwmajor;
+      unsigned  char                          fwminor;
+      unsigned  int                             patch;
+      unsigned  char                          cmpmajor;
+      unsigned  char                          cmpminor;
+      unsigned  char                          cmpbuild;
+      unsigned  char                          chiprev;
+}  si2196_get_rev_cmd_reply_struct;
+
+/* GET_REV command, PN field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_GET_REV_RESPONSE_PN_LSB                                   0
+#define  SI2196_GET_REV_RESPONSE_PN_MASK                                0xff
+/* GET_REV command, FWMAJOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_GET_REV_RESPONSE_FWMAJOR_LSB                       0
+#define  SI2196_GET_REV_RESPONSE_FWMAJOR_MASK                    0xff
+/* GET_REV command, FWMINOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_GET_REV_RESPONSE_FWMINOR_LSB                       0
+#define  SI2196_GET_REV_RESPONSE_FWMINOR_MASK                    0xff
+/* GET_REV command, PATCH field definition (size 16, lsb 0, unsigned)*/
+#define  SI2196_GET_REV_RESPONSE_PATCH_LSB                            0
+#define  SI2196_GET_REV_RESPONSE_PATCH_MASK                         0xffff
+/* GET_REV command, CMPMAJOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_GET_REV_RESPONSE_CMPMAJOR_LSB                     0
+#define  SI2196_GET_REV_RESPONSE_CMPMAJOR_MASK                  0xff
+/* GET_REV command, CMPMINOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_GET_REV_RESPONSE_CMPMINOR_LSB                     0
+#define  SI2196_GET_REV_RESPONSE_CMPMINOR_MASK                  0xff
+/* GET_REV command, CMPBUILD field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_GET_REV_RESPONSE_CMPBUILD_LSB                      0
+#define  SI2196_GET_REV_RESPONSE_CMPBUILD_MASK                   0xff
+#define SI2196_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MIN   0
+#define SI2196_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MAX  255
+/* GET_REV command, CHIPREV field definition (size 4, lsb 0, unsigned)*/
+#define  SI2196_GET_REV_RESPONSE_CHIPREV_LSB                        0
+#define  SI2196_GET_REV_RESPONSE_CHIPREV_MASK                     0x0f
+#define SI2196_GET_REV_RESPONSE_CHIPREV_A                              1
+#define SI2196_GET_REV_RESPONSE_CHIPREV_B                              2
+
+#endif /* SI2196_GET_REV_CMD */
+
+/* SI2196_PART_INFO command definition */
+#define SI2196_PART_INFO_CMD                                                            0x02
+
+#ifdef    SI2196_PART_INFO_CMD
+
+typedef struct { /* SI2196_PART_INFO_CMD_struct */
+     unsigned char   nothing;
+} si2196_part_info_cmd_struct;
+
+
+typedef struct { /* SI2196_PART_INFO_CMD_REPLY_struct */
+      unsigned char   chiprev;
+      unsigned char   romid;
+      unsigned char   part;
+      unsigned char   pmajor;
+      unsigned char   pminor;
+      unsigned char   pbuild;
+      unsigned int    reserved;
+      unsigned long   serial;
+}  si2196_part_info_cmd_reply_struct;
+
+/* PART_INFO command, CHIPREV field definition (size 4, lsb 0, unsigned)*/
+#define  SI2196_PART_INFO_RESPONSE_CHIPREV_LSB           0
+#define  SI2196_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+#define SI2196_PART_INFO_RESPONSE_CHIPREV_A                 1
+#define SI2196_PART_INFO_RESPONSE_CHIPREV_B                 2
+/* PART_INFO command, ROMID field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_PART_INFO_RESPONSE_ROMID_LSB                0
+#define  SI2196_PART_INFO_RESPONSE_ROMID_MASK             0xff
+/* PART_INFO command, PART field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_PART_INFO_RESPONSE_PART_LSB                   0
+#define  SI2196_PART_INFO_RESPONSE_PART_MASK                0xff
+/* PART_INFO command, PMAJOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_PART_INFO_RESPONSE_PMAJOR_LSB               0
+#define  SI2196_PART_INFO_RESPONSE_PMAJOR_MASK            0xff
+/* PART_INFO command, PMINOR field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_PART_INFO_RESPONSE_PMINOR_LSB               0
+#define  SI2196_PART_INFO_RESPONSE_PMINOR_MASK            0xff
+/* PART_INFO command, PBUILD field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_PART_INFO_RESPONSE_PBUILD_LSB                0
+#define  SI2196_PART_INFO_RESPONSE_PBUILD_MASK             0xff
+/* PART_INFO command, RESERVED field definition (size 16, lsb 0, unsigned)*/
+#define  SI2196_PART_INFO_RESPONSE_RESERVED_LSB         0
+#define  SI2196_PART_INFO_RESPONSE_RESERVED_MASK      0xffff
+/* PART_INFO command, SERIAL field definition (size 32, lsb 0, unsigned)*/
+#define  SI2196_PART_INFO_RESPONSE_SERIAL_LSB                0
+#define  SI2196_PART_INFO_RESPONSE_SERIAL_MASK             0xffffffff
+
+#endif /* SI2196_PART_INFO_CMD */
+
+/* SI2196_POWER_DOWN command definition */
+#define SI2196_POWER_DOWN_CMD                                               0x13
+
+#ifdef    SI2196_POWER_DOWN_CMD
+
+typedef struct { /* SI2196_POWER_DOWN_CMD_struct */
+       unsigned char   nothing;
+} si2196_power_down_cmd_struct;
+
+
+typedef struct { /* SI2196_POWER_DOWN_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_power_down_cmd_reply_struct;
+
+#endif /* SI2196_POWER_DOWN_CMD */
+
+/* SI2196_POWER_UP command definition */
+#define SI2196_POWER_UP_CMD                                                    0xc0
+
+#ifdef    SI2196_POWER_UP_CMD
+
+typedef struct { /* SI2196_POWER_UP_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   reserved1;
+     unsigned char   reserved2;
+     unsigned char   reserved3;
+     unsigned char   clock_mode;
+     unsigned char   clock_freq;
+     unsigned char   addr_mode;
+     unsigned char   func;
+     unsigned char   ctsien;
+     unsigned char   wake_up;
+} si2196_power_up_cmd_struct;
+
+/* POWER_UP command, SUBCODE field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_POWER_UP_CMD_SUBCODE_LSB                  0
+#define  SI2196_POWER_UP_CMD_SUBCODE_MASK               0xff
+#define  SI2196_POWER_UP_CMD_SUBCODE_MIN                   5
+#define  SI2196_POWER_UP_CMD_SUBCODE_MAX                  5
+#define SI2196_POWER_UP_CMD_SUBCODE_CODE                5
+/* POWER_UP command, RESERVED1 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_POWER_UP_CMD_RESERVED1_LSB               0
+#define  SI2196_POWER_UP_CMD_RESERVED1_MASK            0xff
+#define  SI2196_POWER_UP_CMD_RESERVED1_MIN               1
+#define  SI2196_POWER_UP_CMD_RESERVED1_MAX              1
+#define SI2196_POWER_UP_CMD_RESERVED1_RESERVED   1
+/* POWER_UP command, RESERVED2 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_POWER_UP_CMD_RESERVED2_LSB                0
+#define  SI2196_POWER_UP_CMD_RESERVED2_MASK             0xff
+#define  SI2196_POWER_UP_CMD_RESERVED2_MIN                0
+#define  SI2196_POWER_UP_CMD_RESERVED2_MAX               0
+#define SI2196_POWER_UP_CMD_RESERVED2_RESERVED    0
+/* POWER_UP command, RESERVED3 field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_POWER_UP_CMD_RESERVED3_LSB                0
+#define  SI2196_POWER_UP_CMD_RESERVED3_MASK             0xff
+#define  SI2196_POWER_UP_CMD_RESERVED3_MIN                0
+#define  SI2196_POWER_UP_CMD_RESERVED3_MAX               0
+#define SI2196_POWER_UP_CMD_RESERVED3_RESERVED    0
+/* POWER_UP command, CLOCK_MODE field definition (size 2, lsb 0, unsigned) */
+#define  SI2196_POWER_UP_CMD_CLOCK_MODE_LSB              0
+#define  SI2196_POWER_UP_CMD_CLOCK_MODE_MASK           0x03
+#define  SI2196_POWER_UP_CMD_CLOCK_MODE_MIN              1
+#define  SI2196_POWER_UP_CMD_CLOCK_MODE_MAX             3
+#define SI2196_POWER_UP_CMD_CLOCK_MODE_EXTCLK       1
+#define SI2196_POWER_UP_CMD_CLOCK_MODE_XTAL            3
+/* POWER_UP command, CLOCK_FREQ field definition (size 2, lsb 2, unsigned) */
+#define  SI2196_POWER_UP_CMD_CLOCK_FREQ_LSB              2
+#define  SI2196_POWER_UP_CMD_CLOCK_FREQ_MASK           0x03
+#define  SI2196_POWER_UP_CMD_CLOCK_FREQ_MIN               0
+#define  SI2196_POWER_UP_CMD_CLOCK_FREQ_MAX              2
+#define SI2196_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+/* POWER_UP command, ADDR_MODE field definition (size 1, lsb 4, unsigned) */
+#define  SI2196_POWER_UP_CMD_ADDR_MODE_LSB                4
+#define  SI2196_POWER_UP_CMD_ADDR_MODE_MASK             0x01
+#define  SI2196_POWER_UP_CMD_ADDR_MODE_MIN                 0
+#define  SI2196_POWER_UP_CMD_ADDR_MODE_MAX                1
+#define SI2196_POWER_UP_CMD_ADDR_MODE_CAPTURE       1
+#define SI2196_POWER_UP_CMD_ADDR_MODE_CURRENT       0
+/* POWER_UP command, FUNC field definition (size 4, lsb 0, unsigned) */
+#define  SI2196_POWER_UP_CMD_FUNC_LSB                             0
+#define  SI2196_POWER_UP_CMD_FUNC_MASK                          0x0f
+#define  SI2196_POWER_UP_CMD_FUNC_MIN                             0
+#define  SI2196_POWER_UP_CMD_FUNC_MAX                            1
+#define SI2196_POWER_UP_CMD_FUNC_BOOTLOADER            0
+#define SI2196_POWER_UP_CMD_FUNC_NORMAL                      1
+/* POWER_UP command, CTSIEN field definition (size 1, lsb 7, unsigned) */
+#define  SI2196_POWER_UP_CMD_CTSIEN_LSB                          7
+#define  SI2196_POWER_UP_CMD_CTSIEN_MASK                       0x01
+#define  SI2196_POWER_UP_CMD_CTSIEN_MIN                          0
+#define  SI2196_POWER_UP_CMD_CTSIEN_MAX                         1
+#define SI2196_POWER_UP_CMD_CTSIEN_DISABLE                  0
+#define SI2196_POWER_UP_CMD_CTSIEN_ENABLE                   1
+/* POWER_UP command, WAKE_UP field definition (size 1, lsb 0, unsigned) */
+#define  SI2196_POWER_UP_CMD_WAKE_UP_LSB                     0
+#define  SI2196_POWER_UP_CMD_WAKE_UP_MASK                  0x01
+#define  SI2196_POWER_UP_CMD_WAKE_UP_MIN                      1
+#define  SI2196_POWER_UP_CMD_WAKE_UP_MAX                     1
+#define SI2196_POWER_UP_CMD_WAKE_UP_WAKE_UP            1
+
+typedef struct { /* SI2196_POWER_UP_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_power_up_cmd_reply_struct;
+
+#endif /* SI2196_POWER_UP_CMD */
+/* SI2196_SD_ADAC_POWER_UP command definition */
+#define   SI2196_SD_ADAC_POWER_UP_CMD 0x8a
+
+#ifdef    SI2196_SD_ADAC_POWER_UP_CMD
+  #define SI2196_SD_ADAC_POWER_UP_CMD_CODE 0x01008a
+
+    typedef struct { /* SI2196_SD_ADAC_POWER_UP_CMD_struct */
+        unsigned char   duration;
+   } si2196_sd_adac_power_up_cmd_struct;
+
+
+    typedef struct { /* SI2196_SD_ADAC_POWER_UP_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+   }si2196_sd_adac_power_up_cmd_reply_struct;
+
+   /* SD_ADAC_POWER_UP command, DURATION field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  SI2196_SD_ADAC_POWER_UP_CMD_DURATION_LSB         0
+   #define  SI2196_SD_ADAC_POWER_UP_CMD_DURATION_MASK        0xff
+   #define  SI2196_SD_ADAC_POWER_UP_CMD_DURATION_MIN         20
+   #define  SI2196_SD_ADAC_POWER_UP_CMD_DURATION_MAX         255
+    #define SI2196_SD_ADAC_POWER_UP_CMD_DURATION_DURATION_MIN  20
+    #define SI2196_SD_ADAC_POWER_UP_CMD_DURATION_DURATION_MAX  255
+#endif /* SI2196_SD_ADAC_POWER_UP_CMD */
+
+/* SI2196_SD_AFC command definition */
+#define   SI2196_SD_AFC_CMD 0x84
+
+#ifdef    SI2196_SD_AFC_CMD
+  #define SI2196_SD_AFC_CMD_CODE 0x010084
+
+    typedef struct { /* SI2196_SD_AFC_CMD_struct */
+         unsigned char   nothing;
+    }si2196_sd_afc_cmd_struct;
+
+
+    typedef struct { /* SI2196_SD_AFC_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+       char   afc;
+   }si2196_sd_afc_cmd_reply_struct;
+
+   /* SD_AFC command, AFC field definition (address 2, size 8, lsb 0, signed)*/
+   #define  SI2196_SD_AFC_RESPONSE_AFC_LSB         0
+   #define  SI2196_SD_AFC_RESPONSE_AFC_MASK        0xff
+   #define  SI2196_SD_AFC_RESPONSE_AFC_SHIFT       24
+
+#endif /* SI2196_SD_AFC_CMD */
+
+/* SI2196_SD_CARRIER_CNR command definition */
+#define   SI2196_SD_CARRIER_CNR_CMD 0x83
+
+#ifdef    SI2196_SD_CARRIER_CNR_CMD
+  #define SI2196_SD_CARRIER_CNR_CMD_CODE 0x010083
+
+    typedef struct { /* SI2196_SD_CARRIER_CNR_CMD_struct */
+         unsigned char   nothing;
+    }si2196_sd_carrier_cnr_cmd_struct;
+
+
+    typedef struct { /* SI2196_SD_CARRIER_CNR_CMD_REPLY_struct */
+        unsigned char   primary;
+        unsigned char   secondary;
+   }si2196_sd_carrier_cnr_cmd_reply_struct;
+
+   /* SD_CARRIER_CNR command, PRIMARY field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  SI2196_SD_CARRIER_CNR_RESPONSE_PRIMARY_LSB         0
+   #define  SI2196_SD_CARRIER_CNR_RESPONSE_PRIMARY_MASK        0xff
+   /* SD_CARRIER_CNR command, SECONDARY field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  SI2196_SD_CARRIER_CNR_RESPONSE_SECONDARY_LSB         0
+   #define  SI2196_SD_CARRIER_CNR_RESPONSE_SECONDARY_MASK        0xff
+
+#endif /* SI2196_SD_CARRIER_CNR_CMD */
+
+/* SI2196_SD_CASD command definition */
+#define   SI2196_SD_CASD_CMD 0x8b
+
+#ifdef    SI2196_SD_CASD_CMD
+  #define SI2196_SD_CASD_CMD_CODE 0x01008b
+
+    typedef struct { /* SI2196_SD_CASD_CMD_struct */
+         unsigned char   nothing;
+    }si2196_sd_casd_cmd_struct;
+
+
+    typedef struct { /* SI2196_SD_CASD_CMD_REPLY_struct */
+        unsigned char   casd;
+   }si2196_sd_casd_cmd_reply_struct;
+
+   /* SD_CASD command, CASD field definition (address 2, size 4, lsb 0, unsigned)*/
+   #define  SI2196_SD_CASD_RESPONSE_CASD_LSB         0
+   #define  SI2196_SD_CASD_RESPONSE_CASD_MASK        0x0f
+    #define SI2196_SD_CASD_RESPONSE_CASD_A2_BG       0
+    #define SI2196_SD_CASD_RESPONSE_CASD_A2_DK_574   3
+    #define SI2196_SD_CASD_RESPONSE_CASD_A2_DK_625   1
+    #define SI2196_SD_CASD_RESPONSE_CASD_A2_DK_674   2
+    #define SI2196_SD_CASD_RESPONSE_CASD_A2_M        4
+    #define SI2196_SD_CASD_RESPONSE_CASD_BTSC        10
+    #define SI2196_SD_CASD_RESPONSE_CASD_EIAJ        9
+    #define SI2196_SD_CASD_RESPONSE_CASD_FM_RADIO    11
+    #define SI2196_SD_CASD_RESPONSE_CASD_NICAM_BG    5
+    #define SI2196_SD_CASD_RESPONSE_CASD_NICAM_DK    7
+    #define SI2196_SD_CASD_RESPONSE_CASD_NICAM_I     6
+    #define SI2196_SD_CASD_RESPONSE_CASD_NICAM_L     8
+    #define SI2196_SD_CASD_RESPONSE_CASD_STD_SEARCH  12
+
+#endif /* SI2196_SD_CASD_CMD */
+
+/* SI2196_SD_DUAL_MONO_ID_LVL command definition */
+#define   SI2196_SD_DUAL_MONO_ID_LVL_CMD 0x86
+
+#ifdef    SI2196_SD_DUAL_MONO_ID_LVL_CMD
+  #define SI2196_SD_DUAL_MONO_ID_LVL_CMD_CODE 0x010086
+
+    typedef struct { /* SI2196_SD_DUAL_MONO_ID_LVL_CMD_struct */
+         unsigned char   nothing;
+    }si2196_sd_dual_mono_id_lvl_cmd_struct;
+
+
+    typedef struct { /* SI2196_SD_DUAL_MONO_ID_LVL_CMD_REPLY_struct */
+        //si2196_common_reply_struct * status;
+        unsigned int    id_lvl;
+   }si2196_sd_dual_mono_id_lvl_cmd_reply_struct;
+
+   /* SD_DUAL_MONO_ID_LVL command, ID_LVL field definition (address 2, size 16, lsb 0, unsigned)*/
+   #define  SI2196_SD_DUAL_MONO_ID_LVL_RESPONSE_ID_LVL_LSB         0
+   #define  SI2196_SD_DUAL_MONO_ID_LVL_RESPONSE_ID_LVL_MASK        0xffff
+
+#endif /* SI2196_SD_DUAL_MONO_ID_LVL_CMD */
+
+/* SI2196_SD_NICAM_STATUS command definition */
+#define   SI2196_SD_NICAM_STATUS_CMD 0x82
+
+#ifdef    SI2196_SD_NICAM_STATUS_CMD
+  #define SI2196_SD_NICAM_STATUS_CMD_CODE 0x010082
+
+    typedef struct { /* SI2196_SD_NICAM_STATUS_CMD_struct */
+        unsigned char   nothing;
+    }si2196_sd_nicam_status_cmd_struct;
+
+
+    typedef struct { /* SI2196_SD_NICAM_STATUS_CMD_REPLY_struct */
+        //si2196_common_reply_struct * status;
+        unsigned char   mode;
+        unsigned char   mono_backup;
+        unsigned char   rss;
+        unsigned char   locked;
+        unsigned int      errors;
+   }si2196_sd_nicam_status_cmd_reply_struct;
+
+   /* SD_NICAM_STATUS command, MODE field definition (address 1, size 3, lsb 0, unsigned)*/
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_MODE_LSB         0
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_MODE_MASK        0x07
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_MODE_DATA        6
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_MODE_DUAL_SOUND  2
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_MODE_MONO_DATA   4
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_MODE_STEREO      0
+   /* SD_NICAM_STATUS command, MONO_BACKUP field definition (address 1, size 1, lsb 3, unsigned)*/
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_MONO_BACKUP_LSB         3
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_MONO_BACKUP_MASK        0x01
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_MONO_BACKUP_MONO    1
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_MONO_BACKUP_STEREO  0
+   /* SD_NICAM_STATUS command, RSS field definition (address 1, size 1, lsb 4, unsigned)*/
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_RSS_LSB         4
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_RSS_MASK        0x01
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_RSS_NOT_SET  0
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_RSS_SET      1
+   /* SD_NICAM_STATUS command, LOCKED field definition (address 1, size 1, lsb 5, unsigned)*/
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_LOCKED_LSB         5
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_LOCKED_MASK        0x01
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_LOCKED_LOCKED   1
+   #define SI2196_SD_NICAM_STATUS_RESPONSE_LOCKED_NO_LOCK  0
+   /* SD_NICAM_STATUS command, ERRORS field definition (address 2, size 16, lsb 0, unsigned)*/
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_ERRORS_LSB         0
+   #define  SI2196_SD_NICAM_STATUS_RESPONSE_ERRORS_MASK        0xffff
+
+#endif /* SI2196_SD_NICAM_STATUS_CMD */
+
+/* SI2196_SD_STATUS command definition */
+#define   SI2196_SD_STATUS_CMD 0x81
+
+#ifdef    SI2196_SD_STATUS_CMD
+  #define SI2196_SD_STATUS_CMD_CODE 0x010081
+
+    typedef struct { /* SI2196_SD_STATUS_CMD_struct */
+        unsigned char   intack;
+   } si2196_sd_status_cmd_struct;
+
+
+    typedef struct { /* SI2196_SD_STATUS_CMD_REPLY_struct */
+        //si2196_common_reply_struct * status;
+        unsigned char   asdcint;
+        unsigned char   nicamint;
+        unsigned char   pcmint;
+        unsigned char   scmint;
+        unsigned char   odmint;
+        unsigned char   afcmint;
+        unsigned char   ssint;
+        unsigned char   agcsint;
+        unsigned char   asdc;
+        unsigned char   nicam;
+        unsigned char   pcm;
+        unsigned char   scm;
+        unsigned char   odm;
+        unsigned char   afcm;
+        unsigned char   agcs;
+        unsigned char   sound_mode_detected;
+        unsigned char   sound_system_detected;
+        unsigned char   sap_detected;
+        unsigned char   over_dev;
+        unsigned char   sd_agc;
+        unsigned int      sif_agc;
+   } si2196_sd_status_cmd_reply_struct ;
+
+   /* SD_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  SI2196_SD_STATUS_CMD_INTACK_LSB         0
+   #define  SI2196_SD_STATUS_CMD_INTACK_MASK        0x01
+   #define  SI2196_SD_STATUS_CMD_INTACK_MIN         0
+   #define  SI2196_SD_STATUS_CMD_INTACK_MAX         1
+   #define SI2196_SD_STATUS_CMD_INTACK_CLEAR  1
+   #define SI2196_SD_STATUS_CMD_INTACK_OK     0
+   /* SD_STATUS command, ASDCINT field definition (address 1, size 1, lsb 0, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_ASDCINT_LSB         0
+   #define  SI2196_SD_STATUS_RESPONSE_ASDCINT_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_ASDCINT_CHANGED    1
+   #define SI2196_SD_STATUS_RESPONSE_ASDCINT_NO_CHANGE  0
+   /* SD_STATUS command, NICAMINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_NICAMINT_LSB         1
+   #define  SI2196_SD_STATUS_RESPONSE_NICAMINT_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_NICAMINT_CHANGED    1
+   #define SI2196_SD_STATUS_RESPONSE_NICAMINT_NO_CHANGE  0
+   /* SD_STATUS command, PCMINT field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_PCMINT_LSB         2
+   #define  SI2196_SD_STATUS_RESPONSE_PCMINT_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_PCMINT_CHANGED    1
+   #define SI2196_SD_STATUS_RESPONSE_PCMINT_NO_CHANGE  0
+   /* SD_STATUS command, SCMINT field definition (address 1, size 1, lsb 3, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_SCMINT_LSB         3
+   #define  SI2196_SD_STATUS_RESPONSE_SCMINT_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_SCMINT_CHANGED    1
+   #define SI2196_SD_STATUS_RESPONSE_SCMINT_NO_CHANGE  0
+   /* SD_STATUS command, ODMINT field definition (address 1, size 1, lsb 4, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_ODMINT_LSB         4
+   #define  SI2196_SD_STATUS_RESPONSE_ODMINT_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_ODMINT_CHANGED    1
+   #define SI2196_SD_STATUS_RESPONSE_ODMINT_NO_CHANGE  0
+   /* SD_STATUS command, AFCMINT field definition (address 1, size 1, lsb 5, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_AFCMINT_LSB         5
+   #define  SI2196_SD_STATUS_RESPONSE_AFCMINT_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_AFCMINT_CHANGED    1
+   #define SI2196_SD_STATUS_RESPONSE_AFCMINT_NO_CHANGE  0
+   /* SD_STATUS command, SSINT field definition (address 1, size 1, lsb 6, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_SSINT_LSB         6
+   #define  SI2196_SD_STATUS_RESPONSE_SSINT_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_SSINT_CHANGED    1
+   #define SI2196_SD_STATUS_RESPONSE_SSINT_NO_CHANGE  0
+   /* SD_STATUS command, AGCSINT field definition (address 1, size 1, lsb 7, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_AGCSINT_LSB         7
+   #define  SI2196_SD_STATUS_RESPONSE_AGCSINT_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_AGCSINT_CHANGED    1
+   #define SI2196_SD_STATUS_RESPONSE_AGCSINT_NO_CHANGE  0
+   /* SD_STATUS command, ASDC field definition (address 2, size 1, lsb 0, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_ASDC_LSB         0
+   #define  SI2196_SD_STATUS_RESPONSE_ASDC_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_ASDC_COMPLETE      1
+   #define SI2196_SD_STATUS_RESPONSE_ASDC_NOT_COMPLETE  0
+   /* SD_STATUS command, NICAM field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_NICAM_LSB         1
+   #define  SI2196_SD_STATUS_RESPONSE_NICAM_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_NICAM_LOCK     1
+   #define SI2196_SD_STATUS_RESPONSE_NICAM_NO_LOCK  0
+   /* SD_STATUS command, PCM field definition (address 2, size 1, lsb 2, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_PCM_LSB         2
+   #define  SI2196_SD_STATUS_RESPONSE_PCM_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_PCM_MUTED    1
+   #define SI2196_SD_STATUS_RESPONSE_PCM_UNMUTED  0
+   /* SD_STATUS command, SCM field definition (address 2, size 1, lsb 3, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_SCM_LSB         3
+   #define  SI2196_SD_STATUS_RESPONSE_SCM_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_SCM_MUTE     1
+   #define SI2196_SD_STATUS_RESPONSE_SCM_UNMUTED  0
+   /* SD_STATUS command, ODM field definition (address 2, size 1, lsb 4, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_ODM_LSB         4
+   #define  SI2196_SD_STATUS_RESPONSE_ODM_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_ODM_MUTED    1
+   #define SI2196_SD_STATUS_RESPONSE_ODM_UNMUTED  0
+   /* SD_STATUS command, AFCM field definition (address 2, size 1, lsb 5, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_AFCM_LSB         5
+   #define  SI2196_SD_STATUS_RESPONSE_AFCM_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_AFCM_MUTED    1
+   #define SI2196_SD_STATUS_RESPONSE_AFCM_UNMUTED  0
+   /* SD_STATUS command, AGCS field definition (address 2, size 1, lsb 7, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_AGCS_LSB         7
+   #define  SI2196_SD_STATUS_RESPONSE_AGCS_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_AGCS_SATURATED    1
+   #define SI2196_SD_STATUS_RESPONSE_AGCS_UNSATURATED  0
+   /* SD_STATUS command, SOUND_MODE_DETECTED field definition (address 3, size 2, lsb 0, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_LSB         0
+   #define  SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_MASK        0x03
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_DUAL_MONO  2
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_MONO       1
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_MODE_DETECTED_STEREO     3
+   /* SD_STATUS command, SOUND_SYSTEM_DETECTED field definition (address 3, size 4, lsb 2, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_LSB         2
+   #define  SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_MASK        0x0f
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_A2_BG     0
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_A2_DK1    1
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_A2_DK2    2
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_A2_DK3    3
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_A2_M      4
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_BTSC      10
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_EIAJ      9
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_FM_RADIO  11
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_NICAM_BG  5
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_NICAM_DK  7
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_NICAM_I   6
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_NICAM_L   8
+   #define SI2196_SD_STATUS_RESPONSE_SOUND_SYSTEM_DETECTED_UNKNOWN   12
+   /* SD_STATUS command, SAP_DETECTED field definition (address 3, size 1, lsb 6, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_SAP_DETECTED_LSB         6
+   #define  SI2196_SD_STATUS_RESPONSE_SAP_DETECTED_MASK        0x01
+   #define SI2196_SD_STATUS_RESPONSE_SAP_DETECTED_DETECTED      1
+   #define SI2196_SD_STATUS_RESPONSE_SAP_DETECTED_NOT_DETECTED  0
+   /* SD_STATUS command, OVER_DEV field definition (address 4, size 2, lsb 0, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_OVER_DEV_LSB         0
+   #define  SI2196_SD_STATUS_RESPONSE_OVER_DEV_MASK        0x03
+   #define SI2196_SD_STATUS_RESPONSE_OVER_DEV_HIGH_DEVIATION       2
+   #define SI2196_SD_STATUS_RESPONSE_OVER_DEV_NORMAL               1
+   #define SI2196_SD_STATUS_RESPONSE_OVER_DEV_VERY_HIGH_DEVIATION  3
+   /* SD_STATUS command, SD_AGC field definition (address 5, size 5, lsb 0, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_SD_AGC_LSB         0
+   #define  SI2196_SD_STATUS_RESPONSE_SD_AGC_MASK        0x1f
+   /* SD_STATUS command, SIF_AGC field definition (address 6, size 16, lsb 0, unsigned)*/
+   #define  SI2196_SD_STATUS_RESPONSE_SIF_AGC_LSB         0
+   #define  SI2196_SD_STATUS_RESPONSE_SIF_AGC_MASK        0xffff
+
+#endif /* SI2196_SD_STATUS_CMD */
+
+/* SI2196_SD_STEREO_ID_LVL command definition */
+#define   SI2196_SD_STEREO_ID_LVL_CMD 0x85
+
+#ifdef    SI2196_SD_STEREO_ID_LVL_CMD
+  #define SI2196_SD_STEREO_ID_LVL_CMD_CODE 0x010085
+
+    typedef struct { /* SI2196_SD_STEREO_ID_LVL_CMD_struct */
+         unsigned char   nothing;
+         } si2196_sd_stereo_id_lvl_cmd_struct;
+
+
+    typedef struct { /* SI2196_SD_STEREO_ID_LVL_CMD_REPLY_struct */
+        //si2196_common_reply_struct * status;
+        unsigned int    id_lvl;
+   }  si2196_sd_stereo_id_lvl_cmd_reply_struct;
+
+   /* SD_STEREO_ID_LVL command, ID_LVL field definition (address 2, size 16, lsb 0, unsigned)*/
+   #define  SI2196_SD_STEREO_ID_LVL_RESPONSE_ID_LVL_LSB         0
+   #define  SI2196_SD_STEREO_ID_LVL_RESPONSE_ID_LVL_MASK        0xffff
+
+#endif /* SI2196_SD_STEREO_ID_LVL_CMD */
+
+/* SI2196_SET_PROPERTY command definition */
+#define SI2196_SET_PROPERTY_CMD                                         0x14
+
+#ifdef    SI2196_SET_PROPERTY_CMD
+
+typedef struct { /* SI2196_SET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned int      prop;
+     unsigned int      data;
+} si2196_set_property_cmd_struct;
+
+/* SET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned) */
+#define  SI2196_SET_PROPERTY_CMD_RESERVED_LSB         0
+#define  SI2196_SET_PROPERTY_CMD_RESERVED_MASK      0xff
+#define  SI2196_SET_PROPERTY_CMD_RESERVED_MIN         0
+#define  SI2196_SET_PROPERTY_CMD_RESERVED_MAX        255.0
+/* SET_PROPERTY command, PROP field definition (size 16, lsb 0, unsigned) */
+#define  SI2196_SET_PROPERTY_CMD_PROP_LSB                   0
+#define  SI2196_SET_PROPERTY_CMD_PROP_MASK                0xffff
+#define  SI2196_SET_PROPERTY_CMD_PROP_MIN                   0
+#define  SI2196_SET_PROPERTY_CMD_PROP_MAX                  65535
+#define SI2196_SET_PROPERTY_CMD_PROP_PROP_MIN        0
+#define SI2196_SET_PROPERTY_CMD_PROP_PROP_MAX       65535
+/* SET_PROPERTY command, DATA field definition (size 16, lsb 0, unsigned) */
+#define  SI2196_SET_PROPERTY_CMD_DATA_LSB                   0
+#define  SI2196_SET_PROPERTY_CMD_DATA_MASK                0xffff
+#define  SI2196_SET_PROPERTY_CMD_DATA_MIN                   0
+#define  SI2196_SET_PROPERTY_CMD_DATA_MAX                  65535
+#define SI2196_SET_PROPERTY_CMD_DATA_DATA_MIN         0
+#define SI2196_SET_PROPERTY_CMD_DATA_DATA_MAX        65535
+
+typedef struct { /* SI2196_SET_PROPERTY_CMD_REPLY_struct */
+    //si2196_common_reply_struct * status;
+    unsigned  char                           reserved;
+    unsigned  int                              data;
+}  si2196_set_property_cmd_reply_struct;
+
+/* SET_PROPERTY command, RESERVED field definition (size 8, lsb 0, unsigned)*/
+#define  SI2196_SET_PROPERTY_RESPONSE_RESERVED_LSB                      0
+#define  SI2196_SET_PROPERTY_RESPONSE_RESERVED_MASK                   0xff
+#define SI2196_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+#define SI2196_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX 0
+/* SET_PROPERTY command, DATA field definition (size 16, lsb 0, unsigned)*/
+#define  SI2196_SET_PROPERTY_RESPONSE_DATA_LSB                                 0
+#define  SI2196_SET_PROPERTY_RESPONSE_DATA_MASK                              0xffff
+
+#endif /* SI2196_SET_PROPERTY_CMD */
+
+/* SI2196_STANDBY command definition */
+#define SI2196_STANDBY_CMD                                                                             0x16
+
+#ifdef    SI2196_STANDBY_CMD
+
+typedef struct { /* SI2196_STANDBY_CMD_struct */
+        unsigned char   nothing;
+} si2196_standby_cmd_struct;
+
+
+typedef struct { /* SI2196_STANDBY_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_standby_cmd_reply_struct;
+
+#endif /* SI2196_STANDBY_CMD */
+
+/* SI2196_TUNER_STATUS command definition */
+#define SI2196_TUNER_STATUS_CMD                                                                 0x42
+
+#ifdef    SI2196_TUNER_STATUS_CMD
+
+typedef struct { /* SI2196_TUNER_STATUS_CMD_struct */
+     unsigned char   intack;
+} si2196_tuner_status_cmd_struct;
+
+/* TUNER_STATUS command, INTACK field definition (size 1, lsb 0, unsigned) */
+#define  SI2196_TUNER_STATUS_CMD_INTACK_LSB                             0
+#define  SI2196_TUNER_STATUS_CMD_INTACK_MASK                          0x01
+#define  SI2196_TUNER_STATUS_CMD_INTACK_MIN                             0
+#define  SI2196_TUNER_STATUS_CMD_INTACK_MAX                            1
+#define SI2196_TUNER_STATUS_CMD_INTACK_CLEAR                         1
+#define SI2196_TUNER_STATUS_CMD_INTACK_OK                                0
+
+typedef struct { /* SI2196_TUNER_STATUS_CMD_REPLY_struct */
+      //si2196_common_reply_struct * status;
+      unsigned  char                          tcint;
+      unsigned  char                          rssilint;
+      unsigned  char                          rssihint;
+                         int                           vco_code;
+      unsigned  char                          tc;
+      unsigned  char                          rssil;
+      unsigned  char                          rssih;
+                      char                           rssi;
+      unsigned    int                            freq;
+      unsigned  char                          mode;
+      unsigned  char                          resrved;
+}  si2196_tuner_status_cmd_reply_struct;
+
+/* TUNER_STATUS command, TCINT field definition (size 1, lsb 0, unsigned)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_TCINT_LSB                      0
+#define  SI2196_TUNER_STATUS_RESPONSE_TCINT_MASK                   0x01
+#define SI2196_TUNER_STATUS_RESPONSE_TCINT_CHANGED            1
+#define SI2196_TUNER_STATUS_RESPONSE_TCINT_NO_CHANGE        0
+/* TUNER_STATUS command, RSSILINT field definition (size 1, lsb 1, unsigned)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSILINT_LSB                1
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSILINT_MASK             0x01
+#define SI2196_TUNER_STATUS_RESPONSE_RSSILINT_CHANGED      1
+#define SI2196_TUNER_STATUS_RESPONSE_RSSILINT_NO_CHANGE  0
+/* TUNER_STATUS command, RSSIHINT field definition (size 1, lsb 2, unsigned)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSIHINT_LSB                2
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSIHINT_MASK             0x01
+#define SI2196_TUNER_STATUS_RESPONSE_RSSIHINT_CHANGED      1
+#define SI2196_TUNER_STATUS_RESPONSE_RSSIHINT_NO_CHANGE  0
+/* TUNER_STATUS command, VCO_CODE field definition (size 16, lsb 0, signed)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_VCO_CODE_LSB              0
+#define  SI2196_TUNER_STATUS_RESPONSE_VCO_CODE_MASK           0xffff
+#define  SI2196_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT          16
+/* TUNER_STATUS command, TC field definition (size 1, lsb 0, unsigned)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_TC_LSB                             0
+#define  SI2196_TUNER_STATUS_RESPONSE_TC_MASK                          0x01
+#define SI2196_TUNER_STATUS_RESPONSE_TC_BUSY                           0
+#define SI2196_TUNER_STATUS_RESPONSE_TC_DONE                           1
+/* TUNER_STATUS command, RSSIL field definition (size 1, lsb 1, unsigned)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSIL_LSB                        1
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSIL_MASK                     0x01
+#define SI2196_TUNER_STATUS_RESPONSE_RSSIL_LOW                        1
+#define SI2196_TUNER_STATUS_RESPONSE_RSSIL_OK                           0
+/* TUNER_STATUS command, RSSIH field definition (size 1, lsb 2, unsigned)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSIH_LSB                        2
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSIH_MASK                     0x01
+#define SI2196_TUNER_STATUS_RESPONSE_RSSIH_HIGH                       1
+#define SI2196_TUNER_STATUS_RESPONSE_RSSIH_OK                           0
+/* TUNER_STATUS command, RSSI field definition (size 8, lsb 0, signed)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSI_LSB                           0
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSI_MASK                        0xff
+#define  SI2196_TUNER_STATUS_RESPONSE_RSSI_SHIFT                       24
+/* TUNER_STATUS command, FREQ field definition (size 32, lsb 0, unsigned)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_FREQ_LSB                          0
+#define  SI2196_TUNER_STATUS_RESPONSE_FREQ_MASK                       0xffffffff
+/* TUNER_STATUS command, MODE field definition (size 1, lsb 0, unsigned)*/
+#define  SI2196_TUNER_STATUS_RESPONSE_MODE_LSB                         0
+#define  SI2196_TUNER_STATUS_RESPONSE_MODE_MASK                      0x01
+#define SI2196_TUNER_STATUS_RESPONSE_MODE_ATV                          1
+#define SI2196_TUNER_STATUS_RESPONSE_MODE_DTV                          0
+
+#endif /* SI2196_TUNER_STATUS_CMD */
+
+/* SI2196_TUNER_TUNE_FREQ command definition */
+#define SI2196_TUNER_TUNE_FREQ_CMD                                                  0x41
+
+#ifdef    SI2196_TUNER_TUNE_FREQ_CMD
+
+typedef struct { /* SI2196_TUNER_TUNE_FREQ_CMD_struct */
+     unsigned char   mode;
+     unsigned long   freq;
+} si2196_tuner_tune_freq_cmd_struct;
+
+/* TUNER_TUNE_FREQ command, MODE field definition (size 1, lsb 0, unsigned) */
+#define  SI2196_TUNER_TUNE_FREQ_CMD_MODE_LSB                            0
+#define  SI2196_TUNER_TUNE_FREQ_CMD_MODE_MASK                         0x01
+#define  SI2196_TUNER_TUNE_FREQ_CMD_MODE_MIN                            0
+#define  SI2196_TUNER_TUNE_FREQ_CMD_MODE_MAX                           1
+#define SI2196_TUNER_TUNE_FREQ_CMD_MODE_ATV                             1
+#define SI2196_TUNER_TUNE_FREQ_CMD_MODE_DTV                             0
+/* TUNER_TUNE_FREQ command, FREQ field definition (size 32, lsb 0, unsigned) */
+#define  SI2196_TUNER_TUNE_FREQ_CMD_FREQ_LSB                             0
+#define  SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MASK                          0xffffffff
+#define  SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MIN                             43000000
+#define  SI2196_TUNER_TUNE_FREQ_CMD_FREQ_MAX                            1002000000
+#define SI2196_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MIN                  43000000
+#define SI2196_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MAX                 1002000000
+
+typedef struct { /* SI2196_TUNER_TUNE_FREQ_CMD_REPLY_struct */
+       si2196_common_reply_struct * status;
+}  si2196_tuner_tune_freq_cmd_reply_struct;
+
+#endif /* SI2196_TUNER_TUNE_FREQ_CMD */
+
+/* _commands_defines_insertion_point */
+
+/* _commands_struct_insertion_start */
+
+/* --------------------------------------------*/
+/* COMMANDS STRUCT                             */
+/* This is used to store all command fields    */
+/* --------------------------------------------*/
+typedef union { /* SI2196_CmdObj union */
+    #ifdef    SI2196_AGC_OVERRIDE_CMD
+              si2196_agc_override_cmd_struct               agc_override;
+    #endif /* SI2196_AGC_OVERRIDE_CMD */
+    #ifdef    SI2196_ATV_CW_TEST_CMD
+              si2196_atv_cw_test_cmd_struct                atv_cw_test;
+    #endif /* SI2196_ATV_CW_TEST_CMD */
+    #ifdef    SI2196_ATV_RESTART_CMD
+              si2196_atv_restart_cmd_struct                  atv_restart;
+    #endif /* SI2196_ATV_RESTART_CMD */
+    #ifdef    SI2196_ATV_STATUS_CMD
+              si2196_atv_status_cmd_struct                   atv_status;
+    #endif /* SI2196_ATV_STATUS_CMD */
+    #ifdef    SI2196_CONFIG_PINS_CMD
+              si2196_config_pins_cmd_struct                 config_pins;
+    #endif /* SI2196_CONFIG_PINS_CMD */
+    #ifdef    si2196_download_dataset_continue_cmd
+              si2196_download_dataset_continue_cmd_struct  download_dataset_continue;
+    #endif /* SI2196_DOWNLOAD_DATASET_CONTINUE_CMD */
+    #ifdef    SI2196_DOWNLOAD_DATASET_START_CMD
+              si2196_download_dataset_start_cmd_struct     download_dataset_start;
+    #endif /* SI2196_DOWNLOAD_DATASET_START_CMD */
+    #ifdef    SI2196_DTV_RESTART_CMD
+              si2196_dtv_restart_cmd_struct                dtv_restart;
+    #endif /* SI2196_DTV_RESTART_CMD */
+    #ifdef    SI2196_DTV_STATUS_CMD
+              si2196_dtv_status_cmd_struct                 dtv_status;
+    #endif /* SI2196_DTV_STATUS_CMD */
+    #ifdef    SI2196_EXIT_BOOTLOADER_CMD
+              si2196_exit_bootloader_cmd_struct         exit_bootloader;
+    #endif /* SI2196_EXIT_BOOTLOADER_CMD */
+    #ifdef    SI2196_FINE_TUNE_CMD
+              si2196_fine_tune_cmd_struct                   fine_tune;
+    #endif /* SI2196_FINE_TUNE_CMD */
+    #ifdef    SI2196_GET_PROPERTY_CMD
+              si2196_get_property_cmd_struct             get_property;
+    #endif /* SI2196_GET_PROPERTY_CMD */
+    #ifdef    SI2196_GET_REV_CMD
+              si2196_get_rev_cmd_struct                      get_rev;
+    #endif /* SI2196_GET_REV_CMD */
+    #ifdef    SI2196_PART_INFO_CMD
+              si2196_part_info_cmd_struct                    part_info;
+    #endif /* SI2196_PART_INFO_CMD */
+    #ifdef    SI2196_POWER_DOWN_CMD
+              si2196_power_down_cmd_struct              power_down;
+    #endif /* SI2196_POWER_DOWN_CMD */
+    #ifdef    SI2196_POWER_UP_CMD
+              si2196_power_up_cmd_struct                   power_up;
+    #endif /* SI2196_POWER_UP_CMD */
+     #ifdef    SI2196_SD_ADAC_POWER_UP_CMD
+              si2196_sd_adac_power_up_cmd_struct    sd_adac_power_up;
+    #endif /* SI2196_SD_ADAC_POWER_UP_CMD */
+    #ifdef    SI2196_SD_AFC_CMD
+              si2196_sd_afc_cmd_struct                        sd_afc;
+    #endif /* SI2196_SD_AFC_CMD */
+    #ifdef    SI2196_SD_CARRIER_CNR_CMD
+              si2196_sd_carrier_cnr_cmd_struct           sd_carrier_cnr;
+    #endif /* SI2196_SD_CARRIER_CNR_CMD */
+    #ifdef    SI2196_SD_CASD_CMD
+              si2196_sd_casd_cmd_struct                    sd_casd;
+    #endif /* SI2196_SD_CASD_CMD */
+    #ifdef    SI2196_SD_DUAL_MONO_ID_LVL_CMD
+              si2196_sd_dual_mono_id_lvl_cmd_struct  sd_dual_mono_id_lvl;
+    #endif /* SI2196_SD_DUAL_MONO_ID_LVL_CMD */
+    #ifdef    SI2196_SD_NICAM_STATUS_CMD
+              si2196_sd_nicam_status_cmd_struct      sd_nicam_status;
+    #endif /* SI2196_SD_NICAM_STATUS_CMD */
+    #ifdef    SI2196_SD_STATUS_CMD
+              si2196_sd_status_cmd_struct                  sd_status;
+    #endif /* SI2196_SD_STATUS_CMD */
+    #ifdef    SI2196_SD_STEREO_ID_LVL_CMD
+              si2196_sd_stereo_id_lvl_cmd_struct        sd_stereo_id_lvl;
+    #endif /* SI2196_SD_STEREO_ID_LVL_CMD */
+    #ifdef    SI2196_SET_PROPERTY_CMD
+              si2196_set_property_cmd_struct              set_property;
+    #endif /* SI2196_SET_PROPERTY_CMD */
+    #ifdef    SI2196_STANDBY_CMD
+              si2196_standby_cmd_struct                     standby;
+    #endif /* SI2196_STANDBY_CMD */
+    #ifdef    SI2196_TUNER_STATUS_CMD
+              si2196_tuner_status_cmd_struct              tuner_status;
+    #endif /* SI2196_TUNER_STATUS_CMD */
+    #ifdef    SI2196_TUNER_TUNE_FREQ_CMD
+              si2196_tuner_tune_freq_cmd_struct        tuner_tune_freq;
+    #endif /* SI2196_TUNER_TUNE_FREQ_CMD */
+} si2196_cmdobj_t;
+/* _commands_struct_insertion_point */
+
+/* _commands_reply_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* COMMANDS REPLY STRUCT                       */
+  /* This stores all command reply fields        */
+  /* --------------------------------------------*/
+typedef struct { /* SI2196_CmdReplyObj struct */
+            //for the common reply struct in every reply struct
+              si2196_common_reply_struct                              *reply;
+    #ifdef    SI2196_AGC_OVERRIDE_CMD
+              //si2196_agc_override_cmd_reply_struct              agc_override;
+    #endif /* SI2196_AGC_OVERRIDE_CMD */
+    #ifdef    SI2196_ATV_CW_TEST_CMD
+              //si2196_atv_cw_test_cmd_reply_struct                 atv_cw_test;
+    #endif /* SI2196_ATV_CW_TEST_CMD */
+    #ifdef    SI2196_ATV_RESTART_CMD
+              //si2196_atv_restart_cmd_reply_struct                  atv_restart;
+    #endif /* SI2196_ATV_RESTART_CMD */
+    #ifdef    SI2196_ATV_STATUS_CMD
+              si2196_atv_status_cmd_reply_struct                   atv_status;
+    #endif /* SI2196_ATV_STATUS_CMD */
+    #ifdef    SI2196_CONFIG_PINS_CMD
+              si2196_config_pins_cmd_reply_struct                 config_pins;
+    #endif /* SI2196_CONFIG_PINS_CMD */
+    #ifdef    SI2196_DOWNLOAD_DATASET_CONTINUE_CMD
+              //si2196_download_dataset_continue_cmd_reply_struct  download_dataset_continue;
+    #endif /* SI2196_DOWNLOAD_DATASET_CONTINUE_CMD */
+    #ifdef    SI2196_DOWNLOAD_DATASET_START_CMD
+              //si2196_download_dataset_start_cmd_reply_struct        download_dataset_start;
+    #endif /* SI2196_DOWNLOAD_DATASET_START_CMD */
+    #ifdef    SI2196_EXIT_BOOTLOADER_CMD
+              //si2196_exit_bootloader_cmd_reply_struct                     exit_bootloader;
+    #endif /* SI2196_EXIT_BOOTLOADER_CMD */
+    #ifdef    SI2196_FINE_TUNE_CMD
+              //si2196_fine_tune_cmd_reply_struct                               fine_tune;
+    #endif /* SI2196_FINE_TUNE_CMD */
+    #ifdef    SI2196_GET_PROPERTY_CMD
+              si2196_get_property_cmd_reply_struct                         get_property;
+    #endif /* SI2196_GET_PROPERTY_CMD */
+    #ifdef    SI2196_GET_REV_CMD
+              si2196_get_rev_cmd_reply_struct                                 get_rev;
+    #endif /* SI2196_GET_REV_CMD */
+    #ifdef    SI2196_PART_INFO_CMD
+              si2196_part_info_cmd_reply_struct                               part_info;
+    #endif /* SI2196_PART_INFO_CMD */
+    #ifdef    SI2196_POWER_DOWN_CMD
+              //si2196_power_down_cmd_reply_struct                         power_down;
+    #endif /* SI2196_POWER_DOWN_CMD */
+    #ifdef    SI2196_POWER_UP_CMD
+              //si2196_power_up_cmd_reply_struct                              power_up;
+    #endif /* SI2196_POWER_UP_CMD */
+    #ifdef    SI2196_SD_ADAC_POWER_UP_CMD
+              //si2196_sd_adac_power_up_cmd_reply_struct              sd_adac_power_up;
+    #endif /* SI2196_SD_ADAC_POWER_UP_CMD */
+    #ifdef    SI2196_SD_AFC_CMD
+              si2196_sd_afc_cmd_reply_struct                                   sd_afc;
+    #endif /* SI2196_SD_AFC_CMD */
+    #ifdef    SI2196_SD_CARRIER_CNR_CMD
+              si2196_sd_carrier_cnr_cmd_reply_struct                      sd_carrier_cnr;
+    #endif /* SI2196_SD_CARRIER_CNR_CMD */
+    #ifdef    SI2196_SD_CASD_CMD
+              si2196_sd_casd_cmd_reply_struct                                sd_casd;
+    #endif /* SI2196_SD_CASD_CMD */
+    #ifdef    SI2196_SD_DUAL_MONO_ID_LVL_CMD
+              si2196_sd_dual_mono_id_lvl_cmd_reply_struct            sd_dual_mono_id_lvl;
+    #endif /* SI2196_SD_DUAL_MONO_ID_LVL_CMD */
+    #ifdef    SI2196_SD_NICAM_STATUS_CMD
+              si2196_sd_nicam_status_cmd_reply_struct                   sd_nicam_status;
+    #endif /* SI2196_SD_NICAM_STATUS_CMD */
+    #ifdef    SI2196_SD_STATUS_CMD
+              si2196_sd_status_cmd_reply_struct                              sd_status;
+    #endif /* SI2196_SD_STATUS_CMD */
+    #ifdef    SI2196_SD_STEREO_ID_LVL_CMD
+              si2196_sd_stereo_id_lvl_cmd_reply_struct                    sd_stereo_id_lvl;
+    #endif /* SI2196_SD_STEREO_ID_LVL_CMD */
+    #ifdef    SI2196_SET_PROPERTY_CMD
+              si2196_set_property_cmd_reply_struct                         set_property;
+    #endif /* SI2196_SET_PROPERTY_CMD */
+    #ifdef    SI2196_STANDBY_CMD
+              //si2196_standby_cmd_reply_struct                                standby;
+    #endif /* SI2196_STANDBY_CMD */
+    #ifdef    SI2196_TUNER_STATUS_CMD
+              si2196_tuner_status_cmd_reply_struct                         tuner_status;
+    #endif /* SI2196_TUNER_STATUS_CMD */
+    #ifdef    SI2196_TUNER_TUNE_FREQ_CMD
+              //si2196_tuner_tune_freq_cmd_reply_struct                   tuner_tune_freq;
+    #endif /* SI2196_TUNER_TUNE_FREQ_CMD */
+} si2196_cmdreplyobj_t;
+/* _commands_reply_struct_insertion_point */
+
+/* _properties_defines_insertion_start */
+/* SI2196 ATV_AFC_RANGE property definition */
+#define   SI2196_ATV_AFC_RANGE_PROP                                     0x0610
+
+#ifdef    SI2196_ATV_AFC_RANGE_PROP
+
+typedef struct { /* SI2196_ATV_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+} si2196_atv_afc_range_prop_struct;
+
+/* ATV_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+#define SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB             0
+#define SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK          0xffff
+#define SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT   1000
+#define SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_100_KHZ    100
+#define SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_500_KHZ    500
+#define SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_1000_KHZ  1000
+#define SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_1500_KHZ  1500
+#define SI2196_ATV_AFC_RANGE_PROP_RANGE_KHZ_2000_KHZ  2000
+
+#endif /* SI2196_ATV_AFC_RANGE_PROP */
+
+
+/* SI2196 ATV_AGC_SPEED property definition */
+#define   SI2196_ATV_AGC_SPEED_PROP                                   0x0611
+
+#ifdef    SI2196_ATV_AGC_SPEED_PROP
+
+typedef struct { /* SI2196_ATV_AGC_SPEED_PROP_struct */
+      unsigned char   if_agc_speed;
+} si2196_atv_agc_speed_prop_struct;
+
+/* ATV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define  SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB           0
+#define  SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+#define  SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT  0
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO          0
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_89               89
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_105             105
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_121             121
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_137             137
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_158             158
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_172             172
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_185             185
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_196             196
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_206             206
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_216             216
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_219             219
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_222             222
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_248             248
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_250             250
+#define SI2196_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_251             251
+
+#endif /* SI2196_ATV_AGC_SPEED_PROP */
+
+/* SI2196 ATV_AUDIO_MODE property definition */
+#define   SI2196_ATV_AUDIO_MODE_PROP                                            0x0602
+
+#ifdef    SI2196_ATV_AUDIO_MODE_PROP
+
+typedef struct { /* SI2196_ATV_AUDIO_MODE_PROP_struct */
+      unsigned char   audio_sys;
+      unsigned char   chan_bw;
+} si2196_atv_audio_mode_prop_struct;
+
+/* ATV_AUDIO_MODE property, AUDIO_SYS field definition (NO TITLE)*/
+/* ATV_AUDIO_MODE property, AUDIO_SYS_FILT field definition (NO TITLE)*/
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_LSB               0
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_MASK            0x0f
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_DEFAULT      0
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_DEFAULT       0
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_MONO             1
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_MONO_NICAM  2
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_A2                    3
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_A2_DK2           4
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_A2_DK3           5
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_BTSC               6
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_EIAJ                 7
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_SCAN               8
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_A2_DK4            9
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_WIDE_SCAN    10
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_MONO_NICAM_6DB   11
+   #define SI2196_ATV_AUDIO_MODE_PROP_AUDIO_SYS_FILT_MONO_NICAM_10DB  12
+
+
+/* ATV_AUDIO_MODE property, CHAN_BW field definition (NO TITLE)*/
+#define  SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_LSB             8
+#define  SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_MASK          0x0f
+#define  SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT    0
+#define SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_DEFAULT     0
+#define SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_4X_OVERMOD         1
+#define SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_8X_OVERMOD         2
+#define SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_12X_OVERMOD       3
+#define SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_7P5_KHZ_OFFSET  4
+#define SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_15_KHZ_OFFSET    5
+#define SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_30_KHZ_OFFSET    6
+#define SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_75_KHZ_OFFSET    7
+#define SI2196_ATV_AUDIO_MODE_PROP_CHAN_BW_150_KHZ_OFFSET  8
+
+#endif /* SI2196_ATV_AUDIO_MODE_PROP */
+
+/* SI2196 ATV_CVBS_OUT property definition */
+#define   SI2196_ATV_CVBS_OUT_PROP                                      0x0609
+
+#ifdef    SI2196_ATV_CVBS_OUT_PROP
+
+typedef struct { /* SI2196_ATV_CVBS_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+} si2196_atv_cvbs_out_prop_struct;
+
+/* ATV_CVBS_OUT property, AMP field definition (NO TITLE)*/
+#define  SI2196_ATV_CVBS_OUT_PROP_AMP_LSB                   8
+#define  SI2196_ATV_CVBS_OUT_PROP_AMP_MASK                0xff
+#define  SI2196_ATV_CVBS_OUT_PROP_AMP_DEFAULT          200
+#define SI2196_ATV_CVBS_OUT_PROP_AMP_AMP_MIN           0
+#define SI2196_ATV_CVBS_OUT_PROP_AMP_AMP_MAX          255
+
+/* ATV_CVBS_OUT property, OFFSET field definition (NO TITLE)*/
+#define  SI2196_ATV_CVBS_OUT_PROP_OFFSET_LSB                0
+#define  SI2196_ATV_CVBS_OUT_PROP_OFFSET_MASK             0xff
+#define  SI2196_ATV_CVBS_OUT_PROP_OFFSET_DEFAULT       25
+#define SI2196_ATV_CVBS_OUT_PROP_OFFSET_OFFSET_MIN  0
+#define SI2196_ATV_CVBS_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* SI2196_ATV_CVBS_OUT_PROP */
+
+/* SI2196 ATV_CVBS_OUT_FINE property definition */
+#define   SI2196_ATV_CVBS_OUT_FINE_PROP                     0x0614
+
+#ifdef    SI2196_ATV_CVBS_OUT_FINE_PROP
+
+typedef struct { /* SI2196_ATV_CVBS_OUT_FINE_PROP_struct */
+      unsigned char   amp;
+                      char   offset;
+} si2196_atv_cvbs_out_fine_prop_struct;
+
+/* ATV_CVBS_OUT_FINE property, AMP field definition (NO TITLE)*/
+#define  SI2196_ATV_CVBS_OUT_FINE_PROP_AMP_LSB            8
+#define  SI2196_ATV_CVBS_OUT_FINE_PROP_AMP_MASK         0xff
+#define  SI2196_ATV_CVBS_OUT_FINE_PROP_AMP_DEFAULT   100
+#define SI2196_ATV_CVBS_OUT_FINE_PROP_AMP_AMP_MIN    25
+#define SI2196_ATV_CVBS_OUT_FINE_PROP_AMP_AMP_MAX   100
+
+/* ATV_CVBS_OUT_FINE property, OFFSET field definition (NO TITLE)*/
+#define  SI2196_ATV_CVBS_OUT_FINE_PROP_OFFSET_LSB                 0
+#define  SI2196_ATV_CVBS_OUT_FINE_PROP_OFFSET_MASK              0xff
+#define  SI2196_ATV_CVBS_OUT_FINE_PROP_OFFSET_DEFAULT        0
+#define SI2196_ATV_CVBS_OUT_FINE_PROP_OFFSET_OFFSET_MIN   -128
+#define SI2196_ATV_CVBS_OUT_FINE_PROP_OFFSET_OFFSET_MAX  127
+
+#endif /* SI2196_ATV_CVBS_OUT_FINE_PROP */
+
+/* SI2196 ATV_IEN property definition */
+#define   SI2196_ATV_IEN_PROP                                           0x0601
+
+#ifdef    SI2196_ATV_IEN_PROP
+
+typedef struct { /* SI2196_ATV_IEN_PROP_struct */
+      unsigned char   chlien;
+      unsigned char   dlien;
+      unsigned char   pclien;
+      unsigned char   snrhien;
+      unsigned char   snrlien;
+} si2196_atv_ien_prop_struct;
+
+/* ATV_IEN property, CHLIEN field definition (NO TITLE)*/
+#define  SI2196_ATV_IEN_PROP_CHLIEN_LSB                 0
+#define  SI2196_ATV_IEN_PROP_CHLIEN_MASK              0x01
+#define  SI2196_ATV_IEN_PROP_CHLIEN_DEFAULT        0
+#define SI2196_ATV_IEN_PROP_CHLIEN_DISABLE          0
+#define SI2196_ATV_IEN_PROP_CHLIEN_ENABLE           1
+
+/* ATV_IEN property, DLIEN field definition (NO TITLE)*/
+#define  SI2196_ATV_IEN_PROP_DLIEN_LSB                    2
+#define  SI2196_ATV_IEN_PROP_DLIEN_MASK                 0x01
+#define  SI2196_ATV_IEN_PROP_DLIEN_DEFAULT           0
+#define SI2196_ATV_IEN_PROP_DLIEN_DISABLE             0
+#define SI2196_ATV_IEN_PROP_DLIEN_ENABLE              1
+
+/* ATV_IEN property, PCLIEN field definition (NO TITLE)*/
+#define  SI2196_ATV_IEN_PROP_PCLIEN_LSB                  1
+#define  SI2196_ATV_IEN_PROP_PCLIEN_MASK               0x01
+#define  SI2196_ATV_IEN_PROP_PCLIEN_DEFAULT         0
+#define SI2196_ATV_IEN_PROP_PCLIEN_DISABLE           0
+#define SI2196_ATV_IEN_PROP_PCLIEN_ENABLE            1
+
+/* ATV_IEN property, SNRHIEN field definition (NO TITLE)*/
+#define  SI2196_ATV_IEN_PROP_SNRHIEN_LSB               4
+#define  SI2196_ATV_IEN_PROP_SNRHIEN_MASK            0x01
+#define  SI2196_ATV_IEN_PROP_SNRHIEN_DEFAULT      0
+#define SI2196_ATV_IEN_PROP_SNRHIEN_DISABLE        0
+#define SI2196_ATV_IEN_PROP_SNRHIEN_ENABLE         1
+
+/* ATV_IEN property, SNRLIEN field definition (NO TITLE)*/
+#define  SI2196_ATV_IEN_PROP_SNRLIEN_LSB                3
+#define  SI2196_ATV_IEN_PROP_SNRLIEN_MASK             0x01
+#define  SI2196_ATV_IEN_PROP_SNRLIEN_DEFAULT       0
+#define SI2196_ATV_IEN_PROP_SNRLIEN_DISABLE         0
+#define SI2196_ATV_IEN_PROP_SNRLIEN_ENABLE          1
+
+#endif /* SI2196_ATV_IEN_PROP */
+
+/* SI2196 ATV_INT_SENSE property definition */
+#define   SI2196_ATV_INT_SENSE_PROP                            0x0613
+
+#ifdef    SI2196_ATV_INT_SENSE_PROP
+
+typedef struct { /* SI2196_ATV_INT_SENSE_PROP_struct */
+      unsigned char   chlnegen;
+      unsigned char   chlposen;
+      unsigned char   dlnegen;
+      unsigned char   dlposen;
+      unsigned char   pclnegen;
+      unsigned char   pclposen;
+      unsigned char   snrhnegen;
+      unsigned char   snrhposen;
+      unsigned char   snrlnegen;
+      unsigned char   snrlposen;
+} si2196_atv_int_sense_prop_struct;
+
+/* ATV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_LSB             0
+#define  SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_MASK          0x01
+#define  SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+#define SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE      0
+#define SI2196_ATV_INT_SENSE_PROP_CHLNEGEN_ENABLE       1
+
+/* ATV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_LSB             8
+#define  SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_MASK          0x01
+#define  SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_DEFAULT   1
+#define SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_DISABLE     0
+#define SI2196_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE      1
+
+/* ATV_INT_SENSE property, DLNEGEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_DLNEGEN_LSB               2
+#define  SI2196_ATV_INT_SENSE_PROP_DLNEGEN_MASK            0x01
+#define  SI2196_ATV_INT_SENSE_PROP_DLNEGEN_DEFAULT     0
+#define SI2196_ATV_INT_SENSE_PROP_DLNEGEN_DISABLE       0
+#define SI2196_ATV_INT_SENSE_PROP_DLNEGEN_ENABLE        1
+
+/* ATV_INT_SENSE property, DLPOSEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_DLPOSEN_LSB              10
+#define  SI2196_ATV_INT_SENSE_PROP_DLPOSEN_MASK           0x01
+#define  SI2196_ATV_INT_SENSE_PROP_DLPOSEN_DEFAULT    1
+#define SI2196_ATV_INT_SENSE_PROP_DLPOSEN_DISABLE      0
+#define SI2196_ATV_INT_SENSE_PROP_DLPOSEN_ENABLE       1
+
+/* ATV_INT_SENSE property, PCLNEGEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_LSB           1
+#define  SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_MASK        0x01
+#define  SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_DEFAULT  0
+#define SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE    0
+#define SI2196_ATV_INT_SENSE_PROP_PCLNEGEN_ENABLE     1
+
+/* ATV_INT_SENSE property, PCLPOSEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_LSB             9
+#define  SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_MASK          0x01
+#define  SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_DEFAULT    1
+#define SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_DISABLE      0
+#define SI2196_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE       1
+
+/* ATV_INT_SENSE property, SNRHNEGEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_LSB           4
+#define  SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_MASK        0x01
+#define  SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_DEFAULT  0
+#define SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_DISABLE    0
+#define SI2196_ATV_INT_SENSE_PROP_SNRHNEGEN_ENABLE     1
+
+/* ATV_INT_SENSE property, SNRHPOSEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_LSB            12
+#define  SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_MASK         0x01
+#define  SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_DEFAULT   1
+#define SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_DISABLE     0
+#define SI2196_ATV_INT_SENSE_PROP_SNRHPOSEN_ENABLE      1
+
+/* ATV_INT_SENSE property, SNRLNEGEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_LSB             3
+#define  SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_MASK          0x01
+#define  SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_DEFAULT   0
+#define SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_DISABLE     0
+#define SI2196_ATV_INT_SENSE_PROP_SNRLNEGEN_ENABLE      1
+
+/* ATV_INT_SENSE property, SNRLPOSEN field definition (NO TITLE)*/
+#define  SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_LSB            11
+#define  SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_MASK         0x01
+#define  SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_DEFAULT   1
+#define SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_DISABLE     0
+#define SI2196_ATV_INT_SENSE_PROP_SNRLPOSEN_ENABLE      1
+
+#endif /* SI2196_ATV_INT_SENSE_PROP */
+
+/* SI2196 ATV_RF_TOP property definition */
+#define   SI2196_ATV_RF_TOP_PROP                                              0x0612
+
+#ifdef    SI2196_ATV_RF_TOP_PROP
+
+typedef struct { /* SI2196_ATV_RF_TOP_PROP_struct */
+      unsigned char   atv_rf_top;
+} si2196_atv_rf_top_prop_struct;
+
+/* ATV_RF_TOP property, ATV_RF_TOP field definition (NO TITLE)*/
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB              0
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK           0xff
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_DEFAULT     0
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO            0
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_0DB               6
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_M1DB            7
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_M2DB            8
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_M4DB            10
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_M5DB            11
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_M6DB            12
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_M7DB            13
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_M8DB            14
+#define SI2196_ATV_RF_TOP_PROP_ATV_RF_TOP_M9DB            15
+
+#endif /* SI2196_ATV_RF_TOP_PROP */
+
+/* SI2196 ATV_RSQ_RSSI_THRESHOLD property definition */
+#define   SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP                0x0605
+
+#ifdef    SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP
+
+typedef struct { /* SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_struct */
+               char   hi;
+               char   lo;
+} si2196_atv_rsq_rssi_threshold_prop_struct;
+
+/* ATV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+#define  SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB              8
+#define  SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK           0xff
+#define  SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT    0
+#define SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN         -128
+#define SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX        127
+
+/* ATV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+#define  SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB             0
+#define  SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK          0xff
+#define  SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT    -70
+#define SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN        -128
+#define SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX       127
+
+#endif /* SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP */
+
+/* SI2196 ATV_RSQ_SNR_THRESHOLD property definition */
+#define   SI2196_ATV_RSQ_SNR_THRESHOLD_PROP                           0x0606
+
+#ifdef    SI2196_ATV_RSQ_SNR_THRESHOLD_PROP
+
+typedef struct { /* SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_struct */
+      unsigned char   hi;
+      unsigned char   lo;
+} si2196_atv_rsq_snr_threshold_prop_struct;
+
+/* ATV_RSQ_SNR_THRESHOLD property, HI field definition (NO TITLE)*/
+#define  SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_HI_LSB            8
+#define  SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_HI_MASK         0xff
+#define  SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_HI_DEFAULT   45
+#define SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_HI_HI_MIN         0
+#define SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_HI_HI_MAX       255
+
+/* ATV_RSQ_SNR_THRESHOLD property, LO field definition (NO TITLE)*/
+#define  SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LSB           0
+#define  SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_LO_MASK        0xff
+#define  SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_LO_DEFAULT  25
+#define SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LO_MIN       0
+#define SI2196_ATV_RSQ_SNR_THRESHOLD_PROP_LO_LO_MAX     255
+
+#endif /* SI2196_ATV_RSQ_SNR_THRESHOLD_PROP */
+
+/* SI2196 ATV_SOUND_AGC_LIMIT property definition */
+#define   SI2196_ATV_SOUND_AGC_LIMIT_PROP                       0x0618
+
+#ifdef    SI2196_ATV_SOUND_AGC_LIMIT_PROP
+
+typedef struct { /* SI2196_ATV_SOUND_AGC_LIMIT_PROP_struct */
+               char   max_gain;
+               char   min_gain;
+} si2196_atv_sound_agc_limit_prop_struct;
+
+/* ATV_SOUND_AGC_LIMIT property, MAX_GAIN field definition (NO TITLE)*/
+#define  SI2196_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_LSB                      0
+#define  SI2196_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MASK                  0xff
+#define  SI2196_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_DEFAULT            84
+#define SI2196_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MAX_GAIN_MIN  -84
+#define SI2196_ATV_SOUND_AGC_LIMIT_PROP_MAX_GAIN_MAX_GAIN_MAX  84
+
+/* ATV_SOUND_AGC_LIMIT property, MIN_GAIN field definition (NO TITLE)*/
+#define  SI2196_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_LSB                       8
+#define  SI2196_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MASK                    0xff
+#define  SI2196_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_DEFAULT              -84
+#define SI2196_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MIN_GAIN_MIN      -84
+#define SI2196_ATV_SOUND_AGC_LIMIT_PROP_MIN_GAIN_MIN_GAIN_MAX     84
+
+#endif /* SI2196_ATV_SOUND_AGC_LIMIT_PROP */
+
+/* SI2196 ATV_SOUND_AGC_SPEED property definition */
+#define   SI2196_ATV_SOUND_AGC_SPEED_PROP 0x0619
+
+#ifdef    SI2196_ATV_SOUND_AGC_SPEED_PROP
+  #define SI2196_ATV_SOUND_AGC_SPEED_PROP_CODE 0x000619
+
+    typedef struct { /* SI2196_ATV_SOUND_AGC_SPEED_PROP_struct */
+      unsigned char   other_systems;
+      unsigned char   system_l;
+   } si2196_atv_sound_agc_speed_prop_struct;
+
+   /* ATV_SOUND_AGC_SPEED property, OTHER_SYSTEMS field definition (NO TITLE)*/
+   #define  SI2196_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_LSB         8
+   #define  SI2196_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_MASK        0xff
+   #define  SI2196_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_DEFAULT    4
+    #define SI2196_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_OTHER_SYSTEMS_MIN  0
+    #define SI2196_ATV_SOUND_AGC_SPEED_PROP_OTHER_SYSTEMS_OTHER_SYSTEMS_MAX  15
+
+   /* ATV_SOUND_AGC_SPEED property, SYSTEM_L field definition (NO TITLE)*/
+   #define  SI2196_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_LSB         0
+   #define  SI2196_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_MASK        0xff
+   #define  SI2196_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_DEFAULT    5
+    #define SI2196_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_SYSTEM_L_MIN  0
+    #define SI2196_ATV_SOUND_AGC_SPEED_PROP_SYSTEM_L_SYSTEM_L_MAX  15
+
+#endif /* SI2196_ATV_SOUND_AGC_SPEED_PROP */
+
+/* SI2196 ATV_VIDEO_EQUALIZER property definition */
+#define   SI2196_ATV_VIDEO_EQUALIZER_PROP                                       0x0608
+
+#ifdef    SI2196_ATV_VIDEO_EQUALIZER_PROP
+
+typedef struct { /* SI2196_ATV_VIDEO_EQUALIZER_PROP_struct */
+               char   slope;
+} si2196_atv_video_equalizer_prop_struct;
+
+/* ATV_VIDEO_EQUALIZER property, SLOPE field definition (NO TITLE)*/
+#define  SI2196_ATV_VIDEO_EQUALIZER_PROP_SLOPE_LSB                 0
+#define  SI2196_ATV_VIDEO_EQUALIZER_PROP_SLOPE_MASK              0xff
+#define  SI2196_ATV_VIDEO_EQUALIZER_PROP_SLOPE_DEFAULT       0
+#define SI2196_ATV_VIDEO_EQUALIZER_PROP_SLOPE_SLOPE_MIN    -8
+#define SI2196_ATV_VIDEO_EQUALIZER_PROP_SLOPE_SLOPE_MAX   7
+
+#endif /* SI2196_ATV_VIDEO_EQUALIZER_PROP */
+
+/* SI2196 ATV_VIDEO_MODE property definition */
+#define   SI2196_ATV_VIDEO_MODE_PROP                                                0x0604
+
+#ifdef    SI2196_ATV_VIDEO_MODE_PROP
+
+typedef struct { /* SI2196_ATV_VIDEO_MODE_PROP_struct */
+      unsigned char   color;
+      unsigned char   invert_signal;
+      unsigned char   trans;
+      unsigned char   video_sys;
+} si2196_atv_video_mode_prop_struct;
+
+/* ATV_VIDEO_MODE property, COLOR field definition (NO TITLE)*/
+#define  SI2196_ATV_VIDEO_MODE_PROP_COLOR_LSB                         4
+#define  SI2196_ATV_VIDEO_MODE_PROP_COLOR_MASK                      0x01
+#define  SI2196_ATV_VIDEO_MODE_PROP_COLOR_DEFAULT                0
+#define SI2196_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC               0
+#define SI2196_ATV_VIDEO_MODE_PROP_COLOR_SECAM                     1
+
+/* ATV_VIDEO_MODE property, INVERT_SIGNAL field definition (NO TITLE)*/
+#define  SI2196_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_LSB          10
+#define  SI2196_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_MASK       0x01
+#define  SI2196_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_DEFAULT  0
+#define SI2196_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_NORMAL     0
+#define SI2196_ATV_VIDEO_MODE_PROP_INVERT_SIGNAL_INVERTED  1
+
+/* ATV_VIDEO_MODE property, TRANS field definition (NO TITLE)*/
+#define  SI2196_ATV_VIDEO_MODE_PROP_TRANS_LSB                           8
+#define  SI2196_ATV_VIDEO_MODE_PROP_TRANS_MASK                        0x01
+#define  SI2196_ATV_VIDEO_MODE_PROP_TRANS_DEFAULT                 0
+#define SI2196_ATV_VIDEO_MODE_PROP_TRANS_TERRESTRIAL          0
+#define SI2196_ATV_VIDEO_MODE_PROP_TRANS_CABLE                       1
+
+/* ATV_VIDEO_MODE property, VIDEO_SYS field definition (NO TITLE)*/
+#define  SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB                   0
+#define  SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK                0x07
+#define  SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DEFAULT         0
+#define SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B                        0
+#define SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH                     1
+#define SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M                        2
+#define SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_N                        3
+#define SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I                         4
+#define SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK                     5
+#define SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_L                        6
+#define SI2196_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LP                      7
+
+#endif /* SI2196_ATV_VIDEO_MODE_PROP */
+
+/* SI2196 ATV_VSNR_CAP property definition */
+#define   SI2196_ATV_VSNR_CAP_PROP                                                  0x0616
+
+#ifdef    SI2196_ATV_VSNR_CAP_PROP
+
+typedef struct { /* SI2196_ATV_VSNR_CAP_PROP_struct */
+      unsigned char   atv_vsnr_cap;
+      unsigned char   backend_noise;
+      unsigned char   frontend_noise;
+} si2196_atv_vsnr_cap_prop_struct;
+
+/* ATV_VSNR_CAP property, ATV_VSNR_CAP field definition (NO TITLE)*/
+#define  SI2196_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB                               0
+#define  SI2196_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK                            0xff
+#define  SI2196_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_DEFAULT                      0
+#define SI2196_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MIN   0
+#define SI2196_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MAX  127
+
+#endif /* SI2196_ATV_VSNR_CAP_PROP */
+
+/* SI2196 ATV_VSYNC_TRACKING property definition */
+#define   SI2196_ATV_VSYNC_TRACKING_PROP                                                        0x0615
+
+#ifdef    SI2196_ATV_VSYNC_TRACKING_PROP
+
+typedef struct { /* SI2196_ATV_VSYNC_TRACKING_PROP_struct */
+      unsigned char   min_fields_to_unlock;
+      unsigned char   max_relock_retries;
+      unsigned char   min_pulses_to_lock;
+} si2196_atv_vsync_tracking_prop_struct;
+
+/* ATV_VSYNC_TRACKING property, MAX_RELOCK_RETRIES field definition (NO TITLE)*/
+ #define  SI2196_ATV_VSYNC_TRACKING_PROP_MAX_RELOCK_RETRIES_LSB         4
+ #define  SI2196_ATV_VSYNC_TRACKING_PROP_MAX_RELOCK_RETRIES_MASK        0x0f
+ #define  SI2196_ATV_VSYNC_TRACKING_PROP_MAX_RELOCK_RETRIES_DEFAULT    0
+ #define SI2196_ATV_VSYNC_TRACKING_PROP_MAX_RELOCK_RETRIES_MAX_RELOCK_RETRIES_MIN  0
+ #define SI2196_ATV_VSYNC_TRACKING_PROP_MAX_RELOCK_RETRIES_MAX_RELOCK_RETRIES_MAX  15
+
+/* ATV_VSYNC_TRACKING property, MIN_FIELDS_TO_UNLOCK field definition (NO TITLE)*/
+#define  SI2196_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_LSB            8
+#define  SI2196_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MASK         0xff
+#define  SI2196_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_DEFAULT   16
+#define SI2196_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MIN_FIELDS_TO_UNLOCK_MIN  0
+#define SI2196_ATV_VSYNC_TRACKING_PROP_MIN_FIELDS_TO_UNLOCK_MIN_FIELDS_TO_UNLOCK_MAX  255
+
+/* ATV_VSYNC_TRACKING property, MIN_PULSES_TO_LOCK field definition (NO TITLE)*/
+#define  SI2196_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_LSB                0
+#define  SI2196_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MASK             0xff
+#define  SI2196_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_DEFAULT      1
+#define SI2196_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MIN_PULSES_TO_LOCK_MIN   0
+#define SI2196_ATV_VSYNC_TRACKING_PROP_MIN_PULSES_TO_LOCK_MIN_PULSES_TO_LOCK_MAX  9
+
+#endif /* SI2196_ATV_VSYNC_TRACKING_PROP */
+
+/* SI2196 CRYSTAL_TRIM property definition */
+#define   SI2196_CRYSTAL_TRIM_PROP                                        0x0402
+
+#ifdef    SI2196_CRYSTAL_TRIM_PROP
+
+typedef struct { /* SI2196_CRYSTAL_TRIM_PROP_struct */
+      unsigned char   xo_cap;
+} si2196_crystal_trim_prop_struct;
+
+/* CRYSTAL_TRIM property, XO_CAP field definition (NO TITLE)*/
+#define  SI2196_CRYSTAL_TRIM_PROP_XO_CAP_LSB                 0
+#define  SI2196_CRYSTAL_TRIM_PROP_XO_CAP_MASK              0x0f
+#define  SI2196_CRYSTAL_TRIM_PROP_XO_CAP_DEFAULT        8
+#define SI2196_CRYSTAL_TRIM_PROP_XO_CAP_XO_CAP_MIN   0
+#define SI2196_CRYSTAL_TRIM_PROP_XO_CAP_XO_CAP_MAX  15
+
+#endif /* SI2196_CRYSTAL_TRIM_PROP */
+
+/* SI2196 DTV_AGC_SPEED property definition */
+#define   SI2196_DTV_AGC_SPEED_PROP 0x0708
+
+#ifdef    SI2196_DTV_AGC_SPEED_PROP
+
+typedef struct { /* SI2196_DTV_AGC_SPEED_PROP_struct */
+      unsigned char   agc_decim;
+      unsigned char   if_agc_speed;
+} si2196_dtv_agc_speed_prop_struct;
+
+/* DTV_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+#define  SI2196_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB            8
+#define  SI2196_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK         0x03
+#define  SI2196_DTV_AGC_SPEED_PROP_AGC_DECIM_DEFAULT   0
+#define SI2196_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF             0
+#define SI2196_DTV_AGC_SPEED_PROP_AGC_DECIM_2                  1
+#define SI2196_DTV_AGC_SPEED_PROP_AGC_DECIM_4                  2
+#define SI2196_DTV_AGC_SPEED_PROP_AGC_DECIM_8                  3
+
+/* DTV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define  SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB             0
+#define  SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK          0xff
+#define  SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO            0
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39                  39
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_54                  54
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_63                  63
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_89                  89
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_105                105
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_121                121
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_137                137
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_158                158
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_172                172
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_185                185
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_196                196
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_206                206
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_216                216
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_219                219
+#define SI2196_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_222                222
+
+#endif /* SI2196_DTV_AGC_SPEED_PROP */
+
+/* SI2196 DTV_AGC_FREEZE_INPUT property definition */
+#define   SI2196_DTV_AGC_FREEZE_INPUT_PROP 0x0711
+
+#ifdef    SI2196_DTV_AGC_FREEZE_INPUT_PROP
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_CODE 0x000711
+
+typedef struct { /* SI2196_DTV_AGC_FREEZE_INPUT_PROP_struct */
+      unsigned char   level;
+      unsigned char   pin;
+} SI2196_DTV_AGC_FREEZE_INPUT_PROP_struct;
+
+   /* DTV_AGC_FREEZE_INPUT property, LEVEL field definition (NO TITLE)*/
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB         0
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK        0x01
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_DEFAULT    0
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LOW   0
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_HIGH  1
+
+   /* DTV_AGC_FREEZE_INPUT property, PIN field definition (NO TITLE)*/
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB         1
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK        0x03
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_PIN_DEFAULT    0
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE   0
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO1  1
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO2  2
+#define SI2196_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO3  3
+
+#endif /* SI2196_DTV_AGC_FREEZE_INPUT_PROP */
+
+/* SI2196 DTV_CONFIG_IF_PORT property definition */
+#define   SI2196_DTV_CONFIG_IF_PORT_PROP                                    0x0702
+
+#ifdef    SI2196_DTV_CONFIG_IF_PORT_PROP
+
+typedef struct { /* SI2196_DTV_CONFIG_IF_PORT_PROP_struct */
+      unsigned char   dtv_agc_source;
+      unsigned char   dtv_out_type;
+} si2196_dtv_config_if_port_prop_struct;
+
+/* DTV_CONFIG_IF_PORT property, DTV_AGC_SOURCE field definition (NO TITLE)*/
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB                      8
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK                   0x07
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DEFAULT             0
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL            0
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DLIF_AGC_3DB    1
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DLIF_AGC_FULL  3
+
+/* DTV_CONFIG_IF_PORT property, DTV_OUT_TYPE field definition (NO TITLE)*/
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB                            0
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK                         0x0f
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_DEFAULT                   0
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1                        0
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF2                        1
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF1A               4
+#define SI2196_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF2A               5
+
+#endif /* SI2196_DTV_CONFIG_IF_PORT_PROP */
+
+/* SI2196 DTV_EXT_AGC property definition */
+#define   SI2196_DTV_EXT_AGC_PROP 0x0705
+
+#ifdef    SI2196_DTV_EXT_AGC_PROP
+
+typedef struct { /* SI2196_DTV_EXT_AGC_PROP_struct */
+      unsigned char   max_10mv;
+      unsigned char   min_10mv;
+} si2196_dtv_ext_agc_prop_struct;
+
+/* DTV_EXT_AGC property, MAX_10MV field definition (NO TITLE)*/
+#define SI2196_DTV_EXT_AGC_PROP_MAX_10MV_LSB                         8
+#define SI2196_DTV_EXT_AGC_PROP_MAX_10MV_MASK                      0xff
+#define SI2196_DTV_EXT_AGC_PROP_MAX_10MV_DEFAULT                250
+#define SI2196_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN      0
+#define SI2196_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX     255
+
+/* DTV_EXT_AGC property, MIN_10MV field definition (NO TITLE)*/
+#define SI2196_DTV_EXT_AGC_PROP_MIN_10MV_LSB                          0
+#define SI2196_DTV_EXT_AGC_PROP_MIN_10MV_MASK                       0xff
+#define SI2196_DTV_EXT_AGC_PROP_MIN_10MV_DEFAULT                 50
+#define SI2196_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN        0
+#define SI2196_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX       255
+
+#endif /* SI2196_DTV_EXT_AGC_PROP */
+/* SI2196 DTV_FILTER_SELECT property definition */
+#define   SI2196_DTV_FILTER_SELECT_PROP 0x070c
+
+#ifdef    SI2196_DTV_FILTER_SELECT_PROP
+#define SI2196_DTV_FILTER_SELECT_PROP_CODE 0x00070c
+
+
+typedef struct { /* SI2196_DTV_FILTER_SELECT_PROP_struct */
+    unsigned char   filter;
+} SI2196_DTV_FILTER_SELECT_PROP_struct;
+
+/* DTV_FILTER_SELECT property, FILTER field definition (NO TITLE)*/
+#define SI2196_DTV_FILTER_SELECT_PROP_FILTER_LSB         0
+#define SI2196_DTV_FILTER_SELECT_PROP_FILTER_MASK        0x03
+#define SI2196_DTV_FILTER_SELECT_PROP_FILTER_DEFAULT    0
+#define SI2196_DTV_FILTER_SELECT_PROP_FILTER_DEFAULT  0
+#define SI2196_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM1  1
+#define SI2196_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM2  2
+
+#endif /* SI2196_DTV_FILTER_SELECT_PROP */
+
+/* SI2196 DTV_IEN property definition */
+#define   SI2196_DTV_IEN_PROP 0x0701
+
+#ifdef    SI2196_DTV_IEN_PROP
+
+typedef struct { /* SI2196_DTV_IEN_PROP_struct */
+      unsigned char   chlien;
+} si2196_dtv_ien_prop_struct;
+
+/* DTV_IEN property, CHLIEN field definition (NO TITLE)*/
+#define SI2196_DTV_IEN_PROP_CHLIEN_LSB                 0
+#define SI2196_DTV_IEN_PROP_CHLIEN_MASK              0x01
+#define SI2196_DTV_IEN_PROP_CHLIEN_DEFAULT        0
+#define SI2196_DTV_IEN_PROP_CHLIEN_DISABLE          0
+#define SI2196_DTV_IEN_PROP_CHLIEN_ENABLE           1
+
+#endif /* SI2196_DTV_IEN_PROP */
+
+/* SI2196 DTV_INITIAL_AGC_SPEED property definition */
+#define   SI2196_DTV_INITIAL_AGC_SPEED_PROP 0x070d
+
+#ifdef    SI2196_DTV_INITIAL_AGC_SPEED_PROP
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_CODE 0x00070d
+
+typedef struct { /* SI2196_DTV_INITIAL_AGC_SPEED_PROP_struct */
+      unsigned char   agc_decim;
+      unsigned char   if_agc_speed;
+} SI2196_DTV_INITIAL_AGC_SPEED_PROP_struct;
+
+/* DTV_INITIAL_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_LSB         8
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_MASK        0x03
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_DEFAULT    0
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF  0
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_2    1
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_4    2
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_8    3
+
+/* DTV_INITIAL_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO  0
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_39    39
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_54    54
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_63    63
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_89    89
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_105   105
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_121   121
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_137   137
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_158   158
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_172   172
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_185   185
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_196   196
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_206   206
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_216   216
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_219   219
+#define SI2196_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_222   222
+
+#endif /* SI2196_DTV_INITIAL_AGC_SPEED_PROP */
+
+/* SI2196 DTV_INITIAL_AGC_SPEED_PERIOD property definition */
+#define   SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP 0x070e
+
+#ifdef    SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+#define SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE 0x00070e
+
+typedef struct { /* SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct */
+      unsigned int    period;
+} SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct;
+
+/* DTV_INITIAL_AGC_SPEED_PERIOD property, PERIOD field definition (NO TITLE)*/
+#define SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB         0
+#define SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK        0xffff
+#define SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_DEFAULT    0
+#define SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MIN  0
+#define SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MAX  65535
+
+#endif /* SI2196_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+
+/* SI2196 DTV_INTERNAL_ZIF property definition */
+#define  SI2196_DTV_INTERNAL_ZIF_PROP 0x0710
+
+#ifdef    SI2196_DTV_INTERNAL_ZIF_PROP
+#define SI2196_DTV_INTERNAL_ZIF_PROP_CODE 0x000710
+
+
+typedef struct { /* SI2196_DTV_INTERNAL_ZIF_PROP_struct */
+      unsigned char   atsc;
+      unsigned char   dtmb;
+      unsigned char   dvbc;
+      unsigned char   dvbt;
+      unsigned char   isdbc;
+      unsigned char   isdbt;
+      unsigned char   qam_us;
+} SI2196_DTV_INTERNAL_ZIF_PROP_struct;
+
+/* DTV_INTERNAL_ZIF property, ATSC field definition (NO TITLE)*/
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ATSC_LSB         0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ATSC_MASK        0x01
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ATSC_DEFAULT    0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ATSC_LIF  0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ATSC_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, DTMB field definition (NO TITLE)*/
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DTMB_LSB         6
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DTMB_MASK        0x01
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DTMB_DEFAULT    0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DTMB_LIF  0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DTMB_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, DVBC field definition (NO TITLE)*/
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBC_LSB         3
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBC_MASK        0x01
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBC_DEFAULT    0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBC_LIF  0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBC_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, DVBT field definition (NO TITLE)*/
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBT_LSB         2
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBT_MASK        0x01
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBT_DEFAULT    0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBT_LIF  0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_DVBT_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, ISDBC field definition (NO TITLE)*/
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBC_LSB         5
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBC_MASK        0x01
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBC_DEFAULT    0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBC_LIF  0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBC_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, ISDBT field definition (NO TITLE)*/
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBT_LSB         4
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBT_MASK        0x01
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBT_DEFAULT    0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBT_LIF  0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_ISDBT_ZIF  1
+
+/* DTV_INTERNAL_ZIF property, QAM_US field definition (NO TITLE)*/
+#define  SI2196_DTV_INTERNAL_ZIF_PROP_QAM_US_LSB         1
+#define  SI2196_DTV_INTERNAL_ZIF_PROP_QAM_US_MASK        0x01
+#define  SI2196_DTV_INTERNAL_ZIF_PROP_QAM_US_DEFAULT    0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_QAM_US_LIF  0
+#define SI2196_DTV_INTERNAL_ZIF_PROP_QAM_US_ZIF  1
+
+#endif /* SI2196_DTV_INTERNAL_ZIF_PROP */
+
+/* SI2196 DTV_INT_SENSE property definition */
+#define   SI2196_DTV_INT_SENSE_PROP 0x070a
+
+#ifdef    SI2196_DTV_INT_SENSE_PROP
+
+typedef struct { /* SI2196_DTV_INT_SENSE_PROP_struct */
+      unsigned char   chlnegen;
+      unsigned char   chlposen;
+} si2196_dtv_int_sense_prop_struct;
+
+/* DTV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+#define SI2196_DTV_INT_SENSE_PROP_CHLNEGEN_LSB             0
+#define SI2196_DTV_INT_SENSE_PROP_CHLNEGEN_MASK          0x01
+#define SI2196_DTV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+#define SI2196_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE      0
+#define SI2196_DTV_INT_SENSE_PROP_CHLNEGEN_ENABLE       1
+
+/* DTV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+#define SI2196_DTV_INT_SENSE_PROP_CHLPOSEN_LSB             8
+#define SI2196_DTV_INT_SENSE_PROP_CHLPOSEN_MASK          0x01
+#define SI2196_DTV_INT_SENSE_PROP_CHLPOSEN_DEFAULT    1
+#define SI2196_DTV_INT_SENSE_PROP_CHLPOSEN_DISABLE      0
+#define SI2196_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE       1
+
+#endif /* SI2196_DTV_INT_SENSE_PROP */
+
+/* SI2196 DTV_LIF_FREQ property definition */
+#define   SI2196_DTV_LIF_FREQ_PROP 0x0706
+
+#ifdef    SI2196_DTV_LIF_FREQ_PROP
+
+typedef struct { /* SI2196_DTV_LIF_FREQ_PROP_struct */
+      unsigned int    offset;
+} si2196_dtv_lif_freq_prop_struct;
+
+/* DTV_LIF_FREQ property, OFFSET field definition (NO TITLE)*/
+#define SI2196_DTV_LIF_FREQ_PROP_OFFSET_LSB                    0
+#define SI2196_DTV_LIF_FREQ_PROP_OFFSET_MASK                 0xffff
+#define SI2196_DTV_LIF_FREQ_PROP_OFFSET_DEFAULT           5000
+#define SI2196_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN      0
+#define SI2196_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX     7000
+
+#endif /* SI2196_DTV_LIF_FREQ_PROP */
+
+/* SI2196 DTV_LIF_OUT property definition */
+#define   SI2196_DTV_LIF_OUT_PROP 0x0707
+
+#ifdef    SI2196_DTV_LIF_OUT_PROP
+
+typedef struct { /* SI2196_DTV_LIF_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+} si2196_dtv_lif_out_prop_struct;
+
+/* DTV_LIF_OUT property, AMP field definition (NO TITLE)*/
+#define SI2196_DTV_LIF_OUT_PROP_AMP_LSB                 8
+#define SI2196_DTV_LIF_OUT_PROP_AMP_MASK              0xff
+#define SI2196_DTV_LIF_OUT_PROP_AMP_DEFAULT        27
+#define SI2196_DTV_LIF_OUT_PROP_AMP_AMP_MIN        0
+#define SI2196_DTV_LIF_OUT_PROP_AMP_AMP_MAX       255
+
+/* DTV_LIF_OUT property, OFFSET field definition (NO TITLE)*/
+#define SI2196_DTV_LIF_OUT_PROP_OFFSET_LSB                 0
+#define SI2196_DTV_LIF_OUT_PROP_OFFSET_MASK              0xff
+#define SI2196_DTV_LIF_OUT_PROP_OFFSET_DEFAULT        148
+#define SI2196_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MIN   0
+#define SI2196_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* SI2196_DTV_LIF_OUT_PROP */
+
+/* SI2196 DTV_MODE property definition */
+#define   SI2196_DTV_MODE_PROP 0x0703
+
+#ifdef    SI2196_DTV_MODE_PROP
+
+typedef struct { /* SI2196_DTV_MODE_PROP_struct */
+      unsigned char   bw;
+      unsigned char   invert_spectrum;
+      unsigned char   modulation;
+} si2196_dtv_mode_prop_struct;
+
+/* DTV_MODE property, BW field definition (NO TITLE)*/
+#define SI2196_DTV_MODE_PROP_BW_LSB                      0
+#define SI2196_DTV_MODE_PROP_BW_MASK                   0x0f
+#define SI2196_DTV_MODE_PROP_BW_DEFAULT             8
+#define SI2196_DTV_MODE_PROP_BW_BW_6MHZ             6
+#define SI2196_DTV_MODE_PROP_BW_BW_7MHZ             7
+#define SI2196_DTV_MODE_PROP_BW_BW_8MHZ             8
+
+/* DTV_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+#define SI2196_DTV_MODE_PROP_INVERT_SPECTRUM_LSB            8
+#define SI2196_DTV_MODE_PROP_INVERT_SPECTRUM_MASK         0x01
+#define SI2196_DTV_MODE_PROP_INVERT_SPECTRUM_DEFAULT   0
+#define SI2196_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL     0
+#define SI2196_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+/* DTV_MODE property, MODULATION field definition (NO TITLE)*/
+#define SI2196_DTV_MODE_PROP_MODULATION_LSB            4
+#define SI2196_DTV_MODE_PROP_MODULATION_MASK         0x0f
+#define SI2196_DTV_MODE_PROP_MODULATION_DEFAULT   2
+#define SI2196_DTV_MODE_PROP_MODULATION_ATSC           0
+#define SI2196_DTV_MODE_PROP_MODULATION_QAM_US      1
+#define SI2196_DTV_MODE_PROP_MODULATION_DVBT           2
+#define SI2196_DTV_MODE_PROP_MODULATION_DVBC           3
+#define SI2196_DTV_MODE_PROP_MODULATION_ISDBT          4
+#define SI2196_DTV_MODE_PROP_MODULATION_ISDBC          5
+#define SI2196_DTV_MODE_PROP_MODULATION_DTMB           6
+
+#endif /* SI2196_DTV_MODE_PROP */
+
+/* SI2196 DTV_RF_TOP property definition */
+#define SI2196_DTV_RF_TOP_PROP 0x0709
+
+#ifdef   SI2196_DTV_RF_TOP_PROP
+
+typedef struct { /* SI2196_DTV_RF_TOP_PROP_struct */
+      unsigned char   dtv_rf_top;
+} si2196_dtv_rf_top_prop_struct;
+
+/* DTV_RF_TOP property, DTV_RF_TOP field definition (NO TITLE)*/
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB            0
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK         0xff
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_DEFAULT   0
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO           0
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_0DB              6
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_M1DB           7
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_M2DB           8
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_M4DB          10
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_M5DB          11
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_M6DB          12
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_M7DB          13
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_M8DB          14
+#define SI2196_DTV_RF_TOP_PROP_DTV_RF_TOP_M9DB          15
+
+#endif /* SI2196_DTV_RF_TOP_PROP */
+
+/* SI2196 DTV_RSQ_RSSI_THRESHOLD property definition */
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP 0x0704
+
+#ifdef    SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP
+
+typedef struct { /* SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_struct */
+               char   hi;
+               char   lo;
+} si2196_dtv_rsq_rssi_threshold_prop_struct;
+
+/* DTV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB              8
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK           0xff
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT     0
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN          -128
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX        127
+
+/* DTV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB            0
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK         0xff
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT   -80
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN       -128
+#define SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX      127
+
+#endif /* SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP */
+
+/* SI2196 MASTER_IEN property definition */
+#define   SI2196_MASTER_IEN_PROP                                    0x0401
+
+#ifdef    SI2196_MASTER_IEN_PROP
+
+typedef struct { /* SI2196_MASTER_IEN_PROP_struct */
+      unsigned char   atvien;
+      unsigned char   ctsien;
+      unsigned char   dtvien;
+      unsigned char   errien;
+      unsigned char   sdien;
+      unsigned char   tunien;
+} si2196_master_ien_prop_struct;
+
+/* MASTER_IEN property, ATVIEN field definition (NO TITLE)*/
+#define SI2196_MASTER_IEN_PROP_ATVIEN_LSB            1
+#define SI2196_MASTER_IEN_PROP_ATVIEN_MASK         0x01
+#define SI2196_MASTER_IEN_PROP_ATVIEN_DEFAULT   0
+#define SI2196_MASTER_IEN_PROP_ATVIEN_OFF             0
+#define SI2196_MASTER_IEN_PROP_ATVIEN_ON               1
+
+/* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+#define  SI2196_MASTER_IEN_PROP_CTSIEN_LSB            7
+#define  SI2196_MASTER_IEN_PROP_CTSIEN_MASK         0x01
+#define  SI2196_MASTER_IEN_PROP_CTSIEN_DEFAULT   0
+#define SI2196_MASTER_IEN_PROP_CTSIEN_OFF             0
+#define SI2196_MASTER_IEN_PROP_CTSIEN_ON               1
+
+/* MASTER_IEN property, DTVIEN field definition (NO TITLE)*/
+#define  SI2196_MASTER_IEN_PROP_DTVIEN_LSB            2
+#define  SI2196_MASTER_IEN_PROP_DTVIEN_MASK         0x01
+#define  SI2196_MASTER_IEN_PROP_DTVIEN_DEFAULT   0
+#define SI2196_MASTER_IEN_PROP_DTVIEN_OFF             0
+#define SI2196_MASTER_IEN_PROP_DTVIEN_ON               1
+
+/* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+#define  SI2196_MASTER_IEN_PROP_ERRIEN_LSB             6
+#define  SI2196_MASTER_IEN_PROP_ERRIEN_MASK          0x01
+#define  SI2196_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+#define SI2196_MASTER_IEN_PROP_ERRIEN_OFF              0
+#define SI2196_MASTER_IEN_PROP_ERRIEN_ON                1
+
+/* MASTER_IEN property, SDIEN field definition (NO TITLE)*/
+#define  SI2196_MASTER_IEN_PROP_SDIEN_LSB         4
+#define  SI2196_MASTER_IEN_PROP_SDIEN_MASK        0x01
+#define  SI2196_MASTER_IEN_PROP_SDIEN_DEFAULT    0
+ #define SI2196_MASTER_IEN_PROP_SDIEN_OFF  0
+ #define SI2196_MASTER_IEN_PROP_SDIEN_ON   1
+
+/* MASTER_IEN property, TUNIEN field definition (NO TITLE)*/
+#define  SI2196_MASTER_IEN_PROP_TUNIEN_LSB             0
+#define  SI2196_MASTER_IEN_PROP_TUNIEN_MASK          0x01
+#define  SI2196_MASTER_IEN_PROP_TUNIEN_DEFAULT    0
+#define SI2196_MASTER_IEN_PROP_TUNIEN_OFF               0
+#define SI2196_MASTER_IEN_PROP_TUNIEN_ON                1
+
+#endif /* SI2196_MASTER_IEN_PROP */
+
+/* SI2196 TUNER_BLOCKED_VCO property definition */
+#define   SI2196_TUNER_BLOCKED_VCO_PROP                         0x0504
+
+#ifdef    SI2196_TUNER_BLOCKED_VCO_PROP
+
+typedef struct { /* SI2196_TUNER_BLOCKED_VCO_PROP_struct */
+               int    vco_code;
+} si2196_tuner_blocked_vco_prop_struct;
+
+/* TUNER_BLOCKED_VCO property, VCO_CODE field definition (NO TITLE)*/
+#define  SI2196_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB             0
+#define  SI2196_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK          0xffff
+#define  SI2196_TUNER_BLOCKED_VCO_PROP_VCO_CODE_DEFAULT    0x8000
+#endif /* SI2196_TUNER_BLOCKED_VCO_PROP */
+
+/* SI2196 TUNER_IEN property definition */
+#define   SI2196_TUNER_IEN_PROP                                     0x0501
+
+#ifdef    SI2196_TUNER_IEN_PROP
+
+typedef struct { /* SI2196_TUNER_IEN_PROP_struct */
+      unsigned char   rssihien;
+      unsigned char   rssilien;
+      unsigned char   tcien;
+} si2196_tuner_ien_prop_struct;
+
+/* TUNER_IEN property, RSSIHIEN field definition (NO TITLE)*/
+#define  SI2196_TUNER_IEN_PROP_RSSIHIEN_LSB             2
+#define  SI2196_TUNER_IEN_PROP_RSSIHIEN_MASK          0x01
+#define  SI2196_TUNER_IEN_PROP_RSSIHIEN_DEFAULT    0
+#define SI2196_TUNER_IEN_PROP_RSSIHIEN_DISABLE      0
+#define SI2196_TUNER_IEN_PROP_RSSIHIEN_ENABLE       1
+
+/* TUNER_IEN property, RSSILIEN field definition (NO TITLE)*/
+#define  SI2196_TUNER_IEN_PROP_RSSILIEN_LSB             1
+#define  SI2196_TUNER_IEN_PROP_RSSILIEN_MASK          0x01
+#define  SI2196_TUNER_IEN_PROP_RSSILIEN_DEFAULT    0
+#define SI2196_TUNER_IEN_PROP_RSSILIEN_DISABLE      0
+#define SI2196_TUNER_IEN_PROP_RSSILIEN_ENABLE       1
+
+/* TUNER_IEN property, TCIEN field definition (NO TITLE)*/
+#define  SI2196_TUNER_IEN_PROP_TCIEN_LSB                    0
+#define  SI2196_TUNER_IEN_PROP_TCIEN_MASK                 0x01
+#define  SI2196_TUNER_IEN_PROP_TCIEN_DEFAULT           0
+#define SI2196_TUNER_IEN_PROP_TCIEN_DISABLE             0
+#define SI2196_TUNER_IEN_PROP_TCIEN_ENABLE              1
+
+#endif /* SI2196_TUNER_IEN_PROP */
+
+/* SI2196 TUNER_INT_SENSE property definition */
+#define   SI2196_TUNER_INT_SENSE_PROP                          0x0505
+
+#ifdef    SI2196_TUNER_INT_SENSE_PROP
+
+typedef struct { /* SI2196_TUNER_INT_SENSE_PROP_struct */
+      unsigned char   rssihnegen;
+      unsigned char   rssihposen;
+      unsigned char   rssilnegen;
+      unsigned char   rssilposen;
+      unsigned char   tcnegen;
+      unsigned char   tcposen;
+} si2196_tuner_int_sense_prop_struct;
+
+/* TUNER_INT_SENSE property, RSSIHNEGEN field definition (NO TITLE)*/
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB             2
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK          0x01
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DEFAULT    0
+#define SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE      0
+#define SI2196_TUNER_INT_SENSE_PROP_RSSIHNEGEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, RSSIHPOSEN field definition (NO TITLE)*/
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB             10
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK          0x01
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DEFAULT    1
+#define SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DISABLE      0
+#define SI2196_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, RSSILNEGEN field definition (NO TITLE)*/
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB             1
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK          0x01
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_DEFAULT    0
+#define SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE      0
+#define SI2196_TUNER_INT_SENSE_PROP_RSSILNEGEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, RSSILPOSEN field definition (NO TITLE)*/
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB             9
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK          0x01
+#define  SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_DEFAULT    1
+#define SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_DISABLE      0
+#define SI2196_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE       1
+
+/* TUNER_INT_SENSE property, TCNEGEN field definition (NO TITLE)*/
+#define  SI2196_TUNER_INT_SENSE_PROP_TCNEGEN_LSB                   0
+#define  SI2196_TUNER_INT_SENSE_PROP_TCNEGEN_MASK               0x01
+#define  SI2196_TUNER_INT_SENSE_PROP_TCNEGEN_DEFAULT         0
+#define SI2196_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE           0
+#define SI2196_TUNER_INT_SENSE_PROP_TCNEGEN_ENABLE            1
+
+/* TUNER_INT_SENSE property, TCPOSEN field definition (NO TITLE)*/
+#define  SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_LSB                  8
+#define  SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_MASK               0x01
+#define  SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_DEFAULT         1
+#define SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_DISABLE           0
+#define SI2196_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE            1
+
+#endif /* SI2196_TUNER_INT_SENSE_PROP */
+
+/* SI2196 TUNER_LO_INJECTION property definition */
+#define   SI2196_TUNER_LO_INJECTION_PROP                                    0x0506
+
+#ifdef    SI2196_TUNER_LO_INJECTION_PROP
+
+typedef struct { /* SI2196_TUNER_LO_INJECTION_PROP_struct */
+      unsigned char   band_1;
+      unsigned char   band_2;
+      unsigned char   band_3;
+      unsigned char   band_4;
+      unsigned char   band_5;
+} si2196_tuner_lo_injection_prop_struct;
+
+/* TUNER_LO_INJECTION property, BAND_1 field definition (NO TITLE)*/
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_1_LSB              0
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_1_MASK           0x01
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_1_DEFAULT    1
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_1_LOW_SIDE   0
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_2 field definition (NO TITLE)*/
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_2_LSB              1
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_2_MASK           0x01
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_2_DEFAULT    0
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE   0
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_2_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_3 field definition (NO TITLE)*/
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_3_LSB              2
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_3_MASK           0x01
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_3_DEFAULT    0
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE   0
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_3_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_4 field definition (NO TITLE)*/
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_4_LSB              3
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_4_MASK          0x01
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_4_DEFAULT    0
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_4_LOW_SIDE   0
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_4_HIGH_SIDE  1
+
+/* TUNER_LO_INJECTION property, BAND_5 field definition (NO TITLE)*/
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_5_LSB             4
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_5_MASK          0x01
+#define  SI2196_TUNER_LO_INJECTION_PROP_BAND_5_DEFAULT    0
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_5_LOW_SIDE   0
+#define SI2196_TUNER_LO_INJECTION_PROP_BAND_5_HIGH_SIDE  1
+
+#endif /* SI2196_TUNER_LO_INJECTION_PROP */
+/* SI2196 SD_AFC_MAX property definition */
+
+#define   SI2196_SD_AFC_MAX_PROP 0x0d0d
+
+#ifdef    SI2196_SD_AFC_MAX_PROP
+  #define SI2196_SD_AFC_MAX_PROP_CODE 0x000d0d
+
+
+    typedef struct { /* SI2196_SD_AFC_MAX_PROP_struct */
+      unsigned char   max_afc;
+   } SI2196_SD_AFC_MAX_PROP_struct;
+
+   /* SD_AFC_MAX property, MAX_AFC field definition (NO TITLE)*/
+   #define  SI2196_SD_AFC_MAX_PROP_MAX_AFC_LSB         0
+   #define  SI2196_SD_AFC_MAX_PROP_MAX_AFC_MASK        0xff
+   #define  SI2196_SD_AFC_MAX_PROP_MAX_AFC_DEFAULT    150
+    #define SI2196_SD_AFC_MAX_PROP_MAX_AFC_MAX_AFC_MIN  0
+    #define SI2196_SD_AFC_MAX_PROP_MAX_AFC_MAX_AFC_MAX  150
+
+#endif /* SI2196_SD_AFC_MAX_PROP */
+
+/* SI2196 SD_AFC_MUTE property definition */
+#define   SI2196_SD_AFC_MUTE_PROP 0x0d0c
+
+#ifdef    SI2196_SD_AFC_MUTE_PROP
+  #define SI2196_SD_AFC_MUTE_PROP_CODE 0x000d0c
+
+
+    typedef struct { /* SI2196_SD_AFC_MUTE_PROP_struct */
+      unsigned char   mute_thresh;
+      unsigned char   unmute_thresh;
+   } SI2196_SD_AFC_MUTE_PROP_struct;
+
+   /* SD_AFC_MUTE property, MUTE_THRESH field definition (NO TITLE)*/
+   #define  SI2196_SD_AFC_MUTE_PROP_MUTE_THRESH_LSB         0
+   #define  SI2196_SD_AFC_MUTE_PROP_MUTE_THRESH_MASK        0xff
+   #define  SI2196_SD_AFC_MUTE_PROP_MUTE_THRESH_DEFAULT    150
+    #define SI2196_SD_AFC_MUTE_PROP_MUTE_THRESH_MUTE_THRESH_MIN  0
+    #define SI2196_SD_AFC_MUTE_PROP_MUTE_THRESH_MUTE_THRESH_MAX  255
+
+   /* SD_AFC_MUTE property, UNMUTE_THRESH field definition (NO TITLE)*/
+   #define  SI2196_SD_AFC_MUTE_PROP_UNMUTE_THRESH_LSB         8
+   #define  SI2196_SD_AFC_MUTE_PROP_UNMUTE_THRESH_MASK        0xff
+   #define  SI2196_SD_AFC_MUTE_PROP_UNMUTE_THRESH_DEFAULT    130
+    #define SI2196_SD_AFC_MUTE_PROP_UNMUTE_THRESH_UNMUTE_THRESH_MIN  0
+    #define SI2196_SD_AFC_MUTE_PROP_UNMUTE_THRESH_UNMUTE_THRESH_MAX  255
+
+#endif /* SI2196_SD_AFC_MUTE_PROP */
+
+/* SI2196 SD_AGC property definition */
+#define   SI2196_SD_AGC_PROP 0x0d1f
+
+#ifdef    SI2196_SD_AGC_PROP
+  #define SI2196_SD_AGC_PROP_CODE 0x000d1f
+
+
+    typedef struct { /* SI2196_SD_AGC_PROP_struct */
+      unsigned char   freeze;
+      unsigned char   gain;
+   } SI2196_SD_AGC_PROP_struct;
+
+   /* SD_AGC property, FREEZE field definition (NO TITLE)*/
+   #define  SI2196_SD_AGC_PROP_FREEZE_LSB         5
+   #define  SI2196_SD_AGC_PROP_FREEZE_MASK        0x01
+   #define  SI2196_SD_AGC_PROP_FREEZE_DEFAULT    0
+    #define SI2196_SD_AGC_PROP_FREEZE_NORMAL  0
+    #define SI2196_SD_AGC_PROP_FREEZE_FREEZE  1
+
+   /* SD_AGC property, GAIN field definition (NO TITLE)*/
+   #define  SI2196_SD_AGC_PROP_GAIN_LSB         0
+   #define  SI2196_SD_AGC_PROP_GAIN_MASK        0x1f
+   #define  SI2196_SD_AGC_PROP_GAIN_DEFAULT    16
+    #define SI2196_SD_AGC_PROP_GAIN_GAIN_MIN  0
+    #define SI2196_SD_AGC_PROP_GAIN_GAIN_MAX  31
+
+#endif /* SI2196_SD_AGC_PROP */
+
+/* SI2196 SD_ASD property definition */
+#define   SI2196_SD_ASD_PROP 0x0d03
+
+#ifdef    SI2196_SD_ASD_PROP
+  #define SI2196_SD_ASD_PROP_CODE 0x000d03
+
+
+    typedef struct { /* SI2196_SD_ASD_PROP_struct */
+      unsigned char   enable_a2_bg;
+      unsigned char   enable_a2_dk;
+      unsigned char   enable_a2_m;
+      unsigned char   enable_btsc;
+      unsigned char   enable_eiaj;
+      unsigned char   enable_nicam_bg;
+      unsigned char   enable_nicam_dk;
+      unsigned char   enable_nicam_i;
+      unsigned char   enable_nicam_l;
+      unsigned char   iterations;
+   } SI2196_SD_ASD_PROP_struct;
+
+   /* SD_ASD property, ENABLE_A2_BG field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ENABLE_A2_BG_LSB         11
+   #define  SI2196_SD_ASD_PROP_ENABLE_A2_BG_MASK        0x01
+   #define  SI2196_SD_ASD_PROP_ENABLE_A2_BG_DEFAULT    1
+    #define SI2196_SD_ASD_PROP_ENABLE_A2_BG_DISABLE  0
+    #define SI2196_SD_ASD_PROP_ENABLE_A2_BG_ENABLE   1
+
+   /* SD_ASD property, ENABLE_A2_DK field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ENABLE_A2_DK_LSB         10
+   #define  SI2196_SD_ASD_PROP_ENABLE_A2_DK_MASK        0x01
+   #define  SI2196_SD_ASD_PROP_ENABLE_A2_DK_DEFAULT    1
+    #define SI2196_SD_ASD_PROP_ENABLE_A2_DK_DISABLE  0
+    #define SI2196_SD_ASD_PROP_ENABLE_A2_DK_ENABLE   1
+
+   /* SD_ASD property, ENABLE_A2_M field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ENABLE_A2_M_LSB         9
+   #define  SI2196_SD_ASD_PROP_ENABLE_A2_M_MASK        0x01
+   #define  SI2196_SD_ASD_PROP_ENABLE_A2_M_DEFAULT    1
+    #define SI2196_SD_ASD_PROP_ENABLE_A2_M_DISABLE  0
+    #define SI2196_SD_ASD_PROP_ENABLE_A2_M_ENABLE   1
+
+   /* SD_ASD property, ENABLE_BTSC field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ENABLE_BTSC_LSB         13
+   #define  SI2196_SD_ASD_PROP_ENABLE_BTSC_MASK        0x01
+   #define  SI2196_SD_ASD_PROP_ENABLE_BTSC_DEFAULT    1
+    #define SI2196_SD_ASD_PROP_ENABLE_BTSC_DISABLE  0
+    #define SI2196_SD_ASD_PROP_ENABLE_BTSC_ENABLE   1
+
+   /* SD_ASD property, ENABLE_EIAJ field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ENABLE_EIAJ_LSB         12
+   #define  SI2196_SD_ASD_PROP_ENABLE_EIAJ_MASK        0x01
+   #define  SI2196_SD_ASD_PROP_ENABLE_EIAJ_DEFAULT    1
+    #define SI2196_SD_ASD_PROP_ENABLE_EIAJ_DISABLE  0
+    #define SI2196_SD_ASD_PROP_ENABLE_EIAJ_ENABLE   1
+
+   /* SD_ASD property, ENABLE_NICAM_BG field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_BG_LSB         8
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_BG_MASK        0x01
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_BG_DEFAULT    1
+    #define SI2196_SD_ASD_PROP_ENABLE_NICAM_BG_DISABLE  0
+    #define SI2196_SD_ASD_PROP_ENABLE_NICAM_BG_ENABLE   1
+
+   /* SD_ASD property, ENABLE_NICAM_DK field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_DK_LSB         6
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_DK_MASK        0x01
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_DK_DEFAULT    1
+    #define SI2196_SD_ASD_PROP_ENABLE_NICAM_DK_DISABLE  0
+    #define SI2196_SD_ASD_PROP_ENABLE_NICAM_DK_ENABLE   1
+
+   /* SD_ASD property, ENABLE_NICAM_I field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_I_LSB         7
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_I_MASK        0x01
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_I_DEFAULT    1
+    #define SI2196_SD_ASD_PROP_ENABLE_NICAM_I_DISABLE  0
+    #define SI2196_SD_ASD_PROP_ENABLE_NICAM_I_ENABLE   1
+
+   /* SD_ASD property, ENABLE_NICAM_L field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_L_LSB         5
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_L_MASK        0x01
+   #define  SI2196_SD_ASD_PROP_ENABLE_NICAM_L_DEFAULT    1
+    #define SI2196_SD_ASD_PROP_ENABLE_NICAM_L_DISABLE  0
+    #define SI2196_SD_ASD_PROP_ENABLE_NICAM_L_ENABLE   1
+
+   /* SD_ASD property, ITERATIONS field definition (NO TITLE)*/
+   #define  SI2196_SD_ASD_PROP_ITERATIONS_LSB         0
+   #define  SI2196_SD_ASD_PROP_ITERATIONS_MASK        0x1f
+   #define  SI2196_SD_ASD_PROP_ITERATIONS_DEFAULT    3
+    #define SI2196_SD_ASD_PROP_ITERATIONS_ITERATIONS_MIN  1
+    #define SI2196_SD_ASD_PROP_ITERATIONS_ITERATIONS_MAX  16
+
+#endif /* SI2196_SD_ASD_PROP */
+
+/* SI2196 SD_CARRIER_MUTE property definition */
+#define   SI2196_SD_CARRIER_MUTE_PROP 0x0d0b
+
+#ifdef    SI2196_SD_CARRIER_MUTE_PROP
+  #define SI2196_SD_CARRIER_MUTE_PROP_CODE 0x000d0b
+
+
+    typedef struct { /* SI2196_SD_CARRIER_MUTE_PROP_struct */
+      unsigned char   primary_thresh;
+      unsigned char   secondary_thresh;
+   } SI2196_SD_CARRIER_MUTE_PROP_struct;
+
+   /* SD_CARRIER_MUTE property, PRIMARY_THRESH field definition (NO TITLE)*/
+   #define  SI2196_SD_CARRIER_MUTE_PROP_PRIMARY_THRESH_LSB         0
+   #define  SI2196_SD_CARRIER_MUTE_PROP_PRIMARY_THRESH_MASK        0xff
+   #define  SI2196_SD_CARRIER_MUTE_PROP_PRIMARY_THRESH_DEFAULT    22
+    #define SI2196_SD_CARRIER_MUTE_PROP_PRIMARY_THRESH_PRIMARY_THRESH_MIN  0
+    #define SI2196_SD_CARRIER_MUTE_PROP_PRIMARY_THRESH_PRIMARY_THRESH_MAX  255
+
+   /* SD_CARRIER_MUTE property, SECONDARY_THRESH field definition (NO TITLE)*/
+   #define  SI2196_SD_CARRIER_MUTE_PROP_SECONDARY_THRESH_LSB         8
+   #define  SI2196_SD_CARRIER_MUTE_PROP_SECONDARY_THRESH_MASK        0xff
+   #define  SI2196_SD_CARRIER_MUTE_PROP_SECONDARY_THRESH_DEFAULT    26
+    #define SI2196_SD_CARRIER_MUTE_PROP_SECONDARY_THRESH_SECONDARY_THRESH_MIN  0
+    #define SI2196_SD_CARRIER_MUTE_PROP_SECONDARY_THRESH_SECONDARY_THRESH_MAX  255
+
+#endif /* SI2196_SD_CARRIER_MUTE_PROP */
+
+/* SI2196 SD_I2S property definition */
+#define   SI2196_SD_I2S_PROP 0x0d15
+
+#ifdef    SI2196_SD_I2S_PROP
+  #define SI2196_SD_I2S_PROP_CODE 0x000d15
+
+
+    typedef struct { /* SI2196_SD_I2S_PROP_struct */
+      unsigned char   alignment;
+      unsigned char   drive_strength;
+      unsigned char   lrclk_pol;
+      unsigned char   lrclk_rate;
+      unsigned char   num_bits;
+      unsigned char   sclk_rate;
+   } SI2196_SD_I2S_PROP_struct;
+
+   /* SD_I2S property, ALIGNMENT field definition (NO TITLE)*/
+   #define  SI2196_SD_I2S_PROP_ALIGNMENT_LSB         1
+   #define  SI2196_SD_I2S_PROP_ALIGNMENT_MASK        0x03
+   #define  SI2196_SD_I2S_PROP_ALIGNMENT_DEFAULT    0
+    #define SI2196_SD_I2S_PROP_ALIGNMENT_I2S    0
+    #define SI2196_SD_I2S_PROP_ALIGNMENT_LEFT   1
+    #define SI2196_SD_I2S_PROP_ALIGNMENT_RIGHT  2
+
+   /* SD_I2S property, DRIVE_STRENGTH field definition (NO TITLE)*/
+   #define  SI2196_SD_I2S_PROP_DRIVE_STRENGTH_LSB         11
+   #define  SI2196_SD_I2S_PROP_DRIVE_STRENGTH_MASK        0x0f
+   #define  SI2196_SD_I2S_PROP_DRIVE_STRENGTH_DEFAULT    1
+   /* SD_I2S property, LRCLK_POL field definition (NO TITLE)*/
+   #define  SI2196_SD_I2S_PROP_LRCLK_POL_LSB         0
+   #define  SI2196_SD_I2S_PROP_LRCLK_POL_MASK        0x01
+   #define  SI2196_SD_I2S_PROP_LRCLK_POL_DEFAULT    0
+    #define SI2196_SD_I2S_PROP_LRCLK_POL_LEFT_0_RIGHT_1  0
+    #define SI2196_SD_I2S_PROP_LRCLK_POL_LEFT_1_RIGHT_0  1
+
+   /* SD_I2S property, LRCLK_RATE field definition (NO TITLE)*/
+   #define  SI2196_SD_I2S_PROP_LRCLK_RATE_LSB         3
+   #define  SI2196_SD_I2S_PROP_LRCLK_RATE_MASK        0x03
+   #define  SI2196_SD_I2S_PROP_LRCLK_RATE_DEFAULT    0
+    #define SI2196_SD_I2S_PROP_LRCLK_RATE_48KHZ    0
+    #define SI2196_SD_I2S_PROP_LRCLK_RATE_44P1KHZ  1
+    #define SI2196_SD_I2S_PROP_LRCLK_RATE_32KHZ    2
+
+   /* SD_I2S property, NUM_BITS field definition (NO TITLE)*/
+   #define  SI2196_SD_I2S_PROP_NUM_BITS_LSB         5
+   #define  SI2196_SD_I2S_PROP_NUM_BITS_MASK        0x07
+   #define  SI2196_SD_I2S_PROP_NUM_BITS_DEFAULT    2
+    #define SI2196_SD_I2S_PROP_NUM_BITS_8   0
+    #define SI2196_SD_I2S_PROP_NUM_BITS_16  1
+    #define SI2196_SD_I2S_PROP_NUM_BITS_24  2
+    #define SI2196_SD_I2S_PROP_NUM_BITS_32  3
+
+   /* SD_I2S property, SCLK_RATE field definition (NO TITLE)*/
+   #define  SI2196_SD_I2S_PROP_SCLK_RATE_LSB         8
+   #define  SI2196_SD_I2S_PROP_SCLK_RATE_MASK        0x07
+   #define  SI2196_SD_I2S_PROP_SCLK_RATE_DEFAULT    3
+    #define SI2196_SD_I2S_PROP_SCLK_RATE_16X  0
+    #define SI2196_SD_I2S_PROP_SCLK_RATE_32X  1
+    #define SI2196_SD_I2S_PROP_SCLK_RATE_48X  2
+    #define SI2196_SD_I2S_PROP_SCLK_RATE_64X  3
+
+#endif /* SI2196_SD_I2S_PROP */
+
+/* SI2196 SD_IEN property definition */
+#define   SI2196_SD_IEN_PROP 0x0d01
+
+#ifdef    SI2196_SD_IEN_PROP
+  #define SI2196_SD_IEN_PROP_CODE 0x000d01
+
+
+    typedef struct { /* SI2196_SD_IEN_PROP_struct */
+      unsigned char   afcmien;
+      unsigned char   agcsien;
+      unsigned char   asdcien;
+      unsigned char   nicamien;
+      unsigned char   odmien;
+      unsigned char   pcmien;
+      unsigned char   scmien;
+      unsigned char   ssien;
+   } SI2196_SD_IEN_PROP_struct;
+
+   /* SD_IEN property, AFCMIEN field definition (NO TITLE)*/
+   #define  SI2196_SD_IEN_PROP_AFCMIEN_LSB         5
+   #define  SI2196_SD_IEN_PROP_AFCMIEN_MASK        0x01
+   #define  SI2196_SD_IEN_PROP_AFCMIEN_DEFAULT    0
+    #define SI2196_SD_IEN_PROP_AFCMIEN_DISABLE  0
+    #define SI2196_SD_IEN_PROP_AFCMIEN_ENABLE   1
+
+   /* SD_IEN property, AGCSIEN field definition (NO TITLE)*/
+   #define  SI2196_SD_IEN_PROP_AGCSIEN_LSB         7
+   #define  SI2196_SD_IEN_PROP_AGCSIEN_MASK        0x01
+   #define  SI2196_SD_IEN_PROP_AGCSIEN_DEFAULT    0
+    #define SI2196_SD_IEN_PROP_AGCSIEN_DISABLE  0
+    #define SI2196_SD_IEN_PROP_AGCSIEN_ENABLE   1
+
+   /* SD_IEN property, ASDCIEN field definition (NO TITLE)*/
+   #define  SI2196_SD_IEN_PROP_ASDCIEN_LSB         0
+   #define  SI2196_SD_IEN_PROP_ASDCIEN_MASK        0x01
+   #define  SI2196_SD_IEN_PROP_ASDCIEN_DEFAULT    0
+    #define SI2196_SD_IEN_PROP_ASDCIEN_DISABLE  0
+    #define SI2196_SD_IEN_PROP_ASDCIEN_ENABLE   1
+
+   /* SD_IEN property, NICAMIEN field definition (NO TITLE)*/
+   #define  SI2196_SD_IEN_PROP_NICAMIEN_LSB         1
+   #define  SI2196_SD_IEN_PROP_NICAMIEN_MASK        0x01
+   #define  SI2196_SD_IEN_PROP_NICAMIEN_DEFAULT    0
+    #define SI2196_SD_IEN_PROP_NICAMIEN_DISABLE  0
+    #define SI2196_SD_IEN_PROP_NICAMIEN_ENABLE   1
+
+   /* SD_IEN property, ODMIEN field definition (NO TITLE)*/
+   #define  SI2196_SD_IEN_PROP_ODMIEN_LSB         4
+   #define  SI2196_SD_IEN_PROP_ODMIEN_MASK        0x01
+   #define  SI2196_SD_IEN_PROP_ODMIEN_DEFAULT    0
+    #define SI2196_SD_IEN_PROP_ODMIEN_DISABLE  0
+    #define SI2196_SD_IEN_PROP_ODMIEN_ENABLE   1
+
+   /* SD_IEN property, PCMIEN field definition (NO TITLE)*/
+   #define  SI2196_SD_IEN_PROP_PCMIEN_LSB         2
+   #define  SI2196_SD_IEN_PROP_PCMIEN_MASK        0x01
+   #define  SI2196_SD_IEN_PROP_PCMIEN_DEFAULT    0
+    #define SI2196_SD_IEN_PROP_PCMIEN_DISABLE  0
+    #define SI2196_SD_IEN_PROP_PCMIEN_ENABLE   1
+
+   /* SD_IEN property, SCMIEN field definition (NO TITLE)*/
+   #define  SI2196_SD_IEN_PROP_SCMIEN_LSB         3
+   #define  SI2196_SD_IEN_PROP_SCMIEN_MASK        0x01
+   #define  SI2196_SD_IEN_PROP_SCMIEN_DEFAULT    0
+    #define SI2196_SD_IEN_PROP_SCMIEN_DISABLE  0
+    #define SI2196_SD_IEN_PROP_SCMIEN_ENABLE   1
+
+   /* SD_IEN property, SSIEN field definition (NO TITLE)*/
+   #define  SI2196_SD_IEN_PROP_SSIEN_LSB         6
+   #define  SI2196_SD_IEN_PROP_SSIEN_MASK        0x01
+   #define  SI2196_SD_IEN_PROP_SSIEN_DEFAULT    0
+    #define SI2196_SD_IEN_PROP_SSIEN_DISABLE  0
+    #define SI2196_SD_IEN_PROP_SSIEN_ENABLE   1
+
+#endif /* SI2196_SD_IEN_PROP */
+
+/* SI2196 SD_INT_SENSE property definition */
+#define   SI2196_SD_INT_SENSE_PROP 0x0d02
+
+#ifdef    SI2196_SD_INT_SENSE_PROP
+  #define SI2196_SD_INT_SENSE_PROP_CODE 0x000d02
+
+
+    typedef struct { /* SI2196_SD_INT_SENSE_PROP_struct */
+      unsigned char   afcmnegen;
+      unsigned char   afcmposen;
+      unsigned char   agcsnegen;
+      unsigned char   agcsposen;
+      unsigned char   asdcnegen;
+      unsigned char   asdcposen;
+      unsigned char   nicamnegen;
+      unsigned char   nicamposen;
+      unsigned char   odmnegen;
+      unsigned char   odmposen;
+      unsigned char   pcmnegen;
+      unsigned char   pcmposen;
+      unsigned char   scmnegen;
+      unsigned char   scmposen;
+   } SI2196_SD_INT_SENSE_PROP_struct;
+
+   /* SD_INT_SENSE property, AFCMNEGEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_AFCMNEGEN_LSB         5
+   #define  SI2196_SD_INT_SENSE_PROP_AFCMNEGEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_AFCMNEGEN_DEFAULT    0
+    #define SI2196_SD_INT_SENSE_PROP_AFCMNEGEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_AFCMNEGEN_ENABLE   1
+
+   /* SD_INT_SENSE property, AFCMPOSEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_AFCMPOSEN_LSB         13
+   #define  SI2196_SD_INT_SENSE_PROP_AFCMPOSEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_AFCMPOSEN_DEFAULT    1
+    #define SI2196_SD_INT_SENSE_PROP_AFCMPOSEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_AFCMPOSEN_ENABLE   1
+
+   /* SD_INT_SENSE property, AGCSNEGEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_AGCSNEGEN_LSB         7
+   #define  SI2196_SD_INT_SENSE_PROP_AGCSNEGEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_AGCSNEGEN_DEFAULT    0
+    #define SI2196_SD_INT_SENSE_PROP_AGCSNEGEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_AGCSNEGEN_ENABLE   1
+
+   /* SD_INT_SENSE property, AGCSPOSEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_AGCSPOSEN_LSB         15
+   #define  SI2196_SD_INT_SENSE_PROP_AGCSPOSEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_AGCSPOSEN_DEFAULT    1
+    #define SI2196_SD_INT_SENSE_PROP_AGCSPOSEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_AGCSPOSEN_ENABLE   1
+
+   /* SD_INT_SENSE property, ASDCNEGEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_ASDCNEGEN_LSB         0
+   #define  SI2196_SD_INT_SENSE_PROP_ASDCNEGEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_ASDCNEGEN_DEFAULT    0
+    #define SI2196_SD_INT_SENSE_PROP_ASDCNEGEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_ASDCNEGEN_ENABLE   1
+
+   /* SD_INT_SENSE property, ASDCPOSEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_ASDCPOSEN_LSB         8
+   #define  SI2196_SD_INT_SENSE_PROP_ASDCPOSEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_ASDCPOSEN_DEFAULT    1
+    #define SI2196_SD_INT_SENSE_PROP_ASDCPOSEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_ASDCPOSEN_ENABLE   1
+
+   /* SD_INT_SENSE property, NICAMNEGEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_NICAMNEGEN_LSB         1
+   #define  SI2196_SD_INT_SENSE_PROP_NICAMNEGEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_NICAMNEGEN_DEFAULT    0
+    #define SI2196_SD_INT_SENSE_PROP_NICAMNEGEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_NICAMNEGEN_ENABLE   1
+
+   /* SD_INT_SENSE property, NICAMPOSEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_NICAMPOSEN_LSB         9
+   #define  SI2196_SD_INT_SENSE_PROP_NICAMPOSEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_NICAMPOSEN_DEFAULT    1
+    #define SI2196_SD_INT_SENSE_PROP_NICAMPOSEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_NICAMPOSEN_ENABLE   1
+
+   /* SD_INT_SENSE property, ODMNEGEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_ODMNEGEN_LSB         4
+   #define  SI2196_SD_INT_SENSE_PROP_ODMNEGEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_ODMNEGEN_DEFAULT    0
+    #define SI2196_SD_INT_SENSE_PROP_ODMNEGEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_ODMNEGEN_ENABLE   1
+
+   /* SD_INT_SENSE property, ODMPOSEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_ODMPOSEN_LSB         12
+   #define  SI2196_SD_INT_SENSE_PROP_ODMPOSEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_ODMPOSEN_DEFAULT    1
+    #define SI2196_SD_INT_SENSE_PROP_ODMPOSEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_ODMPOSEN_ENABLE   1
+
+   /* SD_INT_SENSE property, PCMNEGEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_PCMNEGEN_LSB         2
+   #define  SI2196_SD_INT_SENSE_PROP_PCMNEGEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_PCMNEGEN_DEFAULT    0
+    #define SI2196_SD_INT_SENSE_PROP_PCMNEGEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_PCMNEGEN_ENABLE   1
+
+   /* SD_INT_SENSE property, PCMPOSEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_PCMPOSEN_LSB         10
+   #define  SI2196_SD_INT_SENSE_PROP_PCMPOSEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_PCMPOSEN_DEFAULT    1
+    #define SI2196_SD_INT_SENSE_PROP_PCMPOSEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_PCMPOSEN_ENABLE   1
+
+   /* SD_INT_SENSE property, SCMNEGEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_SCMNEGEN_LSB         3
+   #define  SI2196_SD_INT_SENSE_PROP_SCMNEGEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_SCMNEGEN_DEFAULT    0
+    #define SI2196_SD_INT_SENSE_PROP_SCMNEGEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_SCMNEGEN_ENABLE   1
+
+   /* SD_INT_SENSE property, SCMPOSEN field definition (NO TITLE)*/
+   #define  SI2196_SD_INT_SENSE_PROP_SCMPOSEN_LSB         11
+   #define  SI2196_SD_INT_SENSE_PROP_SCMPOSEN_MASK        0x01
+   #define  SI2196_SD_INT_SENSE_PROP_SCMPOSEN_DEFAULT    1
+    #define SI2196_SD_INT_SENSE_PROP_SCMPOSEN_DISABLE  0
+    #define SI2196_SD_INT_SENSE_PROP_SCMPOSEN_ENABLE   1
+
+#endif /* SI2196_SD_INT_SENSE_PROP */
+
+/* SI2196 SD_LANG_SELECT property definition */
+#define   SI2196_SD_LANG_SELECT_PROP 0x0d07
+
+#ifdef    SI2196_SD_LANG_SELECT_PROP
+  #define SI2196_SD_LANG_SELECT_PROP_CODE 0x000d07
+
+
+    typedef struct { /* SI2196_SD_LANG_SELECT_PROP_struct */
+      unsigned char   lang;
+   } SI2196_SD_LANG_SELECT_PROP_struct;
+
+   /* SD_LANG_SELECT property, LANG field definition (NO TITLE)*/
+   #define  SI2196_SD_LANG_SELECT_PROP_LANG_LSB         0
+   #define  SI2196_SD_LANG_SELECT_PROP_LANG_MASK        0x03
+   #define  SI2196_SD_LANG_SELECT_PROP_LANG_DEFAULT    0
+    #define SI2196_SD_LANG_SELECT_PROP_LANG_LANG_A     0
+    //the scendard sound carrier such as sap
+    #define SI2196_SD_LANG_SELECT_PROP_LANG_LANG_B     1
+    #define SI2196_SD_LANG_SELECT_PROP_LANG_DUAL_MONO  2
+
+#endif /* SI2196_SD_LANG_SELECT_PROP */
+
+/* SI2196 SD_NICAM property definition */
+#define   SI2196_SD_NICAM_PROP 0x0d08
+
+#ifdef    SI2196_SD_NICAM_PROP
+  #define SI2196_SD_NICAM_PROP_CODE 0x000d08
+
+
+    typedef struct { /* SI2196_SD_NICAM_PROP_struct */
+      unsigned char   force_rss;
+      unsigned int    num_frames;
+   } SI2196_SD_NICAM_PROP_struct;
+
+   /* SD_NICAM property, FORCE_RSS field definition (NO TITLE)*/
+   #define  SI2196_SD_NICAM_PROP_FORCE_RSS_LSB         10
+   #define  SI2196_SD_NICAM_PROP_FORCE_RSS_MASK        0x01
+   #define  SI2196_SD_NICAM_PROP_FORCE_RSS_DEFAULT    0
+    #define SI2196_SD_NICAM_PROP_FORCE_RSS_NORMAL  0
+    #define SI2196_SD_NICAM_PROP_FORCE_RSS_FORCE   1
+
+   /* SD_NICAM property, NUM_FRAMES field definition (NO TITLE)*/
+   #define  SI2196_SD_NICAM_PROP_NUM_FRAMES_LSB         0
+   #define  SI2196_SD_NICAM_PROP_NUM_FRAMES_MASK        0x3ff
+   #define  SI2196_SD_NICAM_PROP_NUM_FRAMES_DEFAULT    200
+    #define SI2196_SD_NICAM_PROP_NUM_FRAMES_NUM_FRAMES_MIN  0
+    #define SI2196_SD_NICAM_PROP_NUM_FRAMES_NUM_FRAMES_MAX  1023
+
+#endif /* SI2196_SD_NICAM_PROP */
+
+/* SI2196 SD_NICAM_FAILOVER_THRESH property definition */
+#define   SI2196_SD_NICAM_FAILOVER_THRESH_PROP 0x0d09
+
+#ifdef    SI2196_SD_NICAM_FAILOVER_THRESH_PROP
+  #define SI2196_SD_NICAM_FAILOVER_THRESH_PROP_CODE 0x000d09
+
+
+    typedef struct { /* SI2196_SD_NICAM_FAILOVER_THRESH_PROP_struct */
+      unsigned int    errors;
+   } SI2196_SD_NICAM_FAILOVER_THRESH_PROP_struct;
+
+   /* SD_NICAM_FAILOVER_THRESH property, ERRORS field definition (NO TITLE)*/
+   #define  SI2196_SD_NICAM_FAILOVER_THRESH_PROP_ERRORS_LSB         0
+   #define  SI2196_SD_NICAM_FAILOVER_THRESH_PROP_ERRORS_MASK        0xffff
+   #define  SI2196_SD_NICAM_FAILOVER_THRESH_PROP_ERRORS_DEFAULT    768
+    #define SI2196_SD_NICAM_FAILOVER_THRESH_PROP_ERRORS_ERRORS_MIN  0
+    #define SI2196_SD_NICAM_FAILOVER_THRESH_PROP_ERRORS_ERRORS_MAX  65535
+
+#endif /* SI2196_SD_NICAM_FAILOVER_THRESH_PROP */
+
+/* SI2196 SD_NICAM_RECOVER_THRESH property definition */
+#define   SI2196_SD_NICAM_RECOVER_THRESH_PROP 0x0d0a
+
+#ifdef    SI2196_SD_NICAM_RECOVER_THRESH_PROP
+  #define SI2196_SD_NICAM_RECOVER_THRESH_PROP_CODE 0x000d0a
+
+
+    typedef struct { /* SI2196_SD_NICAM_RECOVER_THRESH_PROP_struct */
+      unsigned int    errors;
+   } SI2196_SD_NICAM_RECOVER_THRESH_PROP_struct;
+
+   /* SD_NICAM_RECOVER_THRESH property, ERRORS field definition (NO TITLE)*/
+   #define  SI2196_SD_NICAM_RECOVER_THRESH_PROP_ERRORS_LSB         0
+   #define  SI2196_SD_NICAM_RECOVER_THRESH_PROP_ERRORS_MASK        0xffff
+   #define  SI2196_SD_NICAM_RECOVER_THRESH_PROP_ERRORS_DEFAULT    160
+    #define SI2196_SD_NICAM_RECOVER_THRESH_PROP_ERRORS_ERRORS_MIN  0
+    #define SI2196_SD_NICAM_RECOVER_THRESH_PROP_ERRORS_ERRORS_MAX  65535
+
+#endif /* SI2196_SD_NICAM_RECOVER_THRESH_PROP */
+
+/* SI2196 SD_OVER_DEV_MODE property definition */
+#define   SI2196_SD_OVER_DEV_MODE_PROP 0x0d06
+
+#ifdef    SI2196_SD_OVER_DEV_MODE_PROP
+  #define SI2196_SD_OVER_DEV_MODE_PROP_CODE 0x000d06
+
+
+    typedef struct { /* SI2196_SD_OVER_DEV_MODE_PROP_struct */
+      unsigned char   mode;
+   } SI2196_SD_OVER_DEV_MODE_PROP_struct;
+
+   /* SD_OVER_DEV_MODE property, MODE field definition (NO TITLE)*/
+   #define  SI2196_SD_OVER_DEV_MODE_PROP_MODE_LSB         0
+   #define  SI2196_SD_OVER_DEV_MODE_PROP_MODE_MASK        0x03
+   #define  SI2196_SD_OVER_DEV_MODE_PROP_MODE_DEFAULT    0
+    #define SI2196_SD_OVER_DEV_MODE_PROP_MODE_AUTODETECT  0
+    #define SI2196_SD_OVER_DEV_MODE_PROP_MODE_NORMAL      1
+    #define SI2196_SD_OVER_DEV_MODE_PROP_MODE_HIGH        2
+    #define SI2196_SD_OVER_DEV_MODE_PROP_MODE_VERY_HIGH   3
+
+#endif /* SI2196_SD_OVER_DEV_MODE_PROP */
+
+/* SI2196 SD_OVER_DEV_MUTE property definition */
+#define   SI2196_SD_OVER_DEV_MUTE_PROP 0x0d0e
+
+#ifdef    SI2196_SD_OVER_DEV_MUTE_PROP
+  #define SI2196_SD_OVER_DEV_MUTE_PROP_CODE 0x000d0e
+
+
+    typedef struct { /* SI2196_SD_OVER_DEV_MUTE_PROP_struct */
+      unsigned char   mute_thresh;
+      unsigned char   unmute_thresh;
+   } SI2196_SD_OVER_DEV_MUTE_PROP_struct;
+
+   /* SD_OVER_DEV_MUTE property, MUTE_THRESH field definition (NO TITLE)*/
+   #define  SI2196_SD_OVER_DEV_MUTE_PROP_MUTE_THRESH_LSB         0
+   #define  SI2196_SD_OVER_DEV_MUTE_PROP_MUTE_THRESH_MASK        0xff
+   #define  SI2196_SD_OVER_DEV_MUTE_PROP_MUTE_THRESH_DEFAULT    20
+    #define SI2196_SD_OVER_DEV_MUTE_PROP_MUTE_THRESH_MUTE_THRESH_MIN  0
+    #define SI2196_SD_OVER_DEV_MUTE_PROP_MUTE_THRESH_MUTE_THRESH_MAX  150
+
+   /* SD_OVER_DEV_MUTE property, UNMUTE_THRESH field definition (NO TITLE)*/
+   #define  SI2196_SD_OVER_DEV_MUTE_PROP_UNMUTE_THRESH_LSB         8
+   #define  SI2196_SD_OVER_DEV_MUTE_PROP_UNMUTE_THRESH_MASK        0xff
+   #define  SI2196_SD_OVER_DEV_MUTE_PROP_UNMUTE_THRESH_DEFAULT    18
+    #define SI2196_SD_OVER_DEV_MUTE_PROP_UNMUTE_THRESH_UNMUTE_THRESH_MIN  0
+    #define SI2196_SD_OVER_DEV_MUTE_PROP_UNMUTE_THRESH_UNMUTE_THRESH_MAX  150
+
+#endif /* SI2196_SD_OVER_DEV_MUTE_PROP */
+
+/* SI2196 SD_PILOT_LVL_CTRL property definition */
+#define   SI2196_SD_PILOT_LVL_CTRL_PROP 0x0d16
+
+#ifdef    SI2196_SD_PILOT_LVL_CTRL_PROP
+  #define SI2196_SD_PILOT_LVL_CTRL_PROP_CODE 0x000d16
+
+
+    typedef struct { /* SI2196_SD_PILOT_LVL_CTRL_PROP_struct */
+      unsigned char   acq_lvl;
+      unsigned char   lose_lvl;
+   } SI2196_SD_PILOT_LVL_CTRL_PROP_struct;
+
+   /* SD_PILOT_LVL_CTRL property, ACQ_LVL field definition (NO TITLE)*/
+   #define  SI2196_SD_PILOT_LVL_CTRL_PROP_ACQ_LVL_LSB         8
+   #define  SI2196_SD_PILOT_LVL_CTRL_PROP_ACQ_LVL_MASK        0xff
+   #define  SI2196_SD_PILOT_LVL_CTRL_PROP_ACQ_LVL_DEFAULT    53
+   /* SD_PILOT_LVL_CTRL property, LOSE_LVL field definition (NO TITLE)*/
+   #define  SI2196_SD_PILOT_LVL_CTRL_PROP_LOSE_LVL_LSB         0
+   #define  SI2196_SD_PILOT_LVL_CTRL_PROP_LOSE_LVL_MASK        0xff
+   #define  SI2196_SD_PILOT_LVL_CTRL_PROP_LOSE_LVL_DEFAULT    26
+#endif /* SI2196_SD_PILOT_LVL_CTRL_PROP */
+
+/* SI2196 SD_PORT_CONFIG property definition */
+#define   SI2196_SD_PORT_CONFIG_PROP 0x0d0f
+
+#ifdef    SI2196_SD_PORT_CONFIG_PROP
+  #define SI2196_SD_PORT_CONFIG_PROP_CODE 0x000d0f
+
+
+    typedef struct { /* SI2196_SD_PORT_CONFIG_PROP_struct */
+      unsigned char   balance_mode;
+      unsigned char   port;
+   } SI2196_SD_PORT_CONFIG_PROP_struct;
+
+   /* SD_PORT_CONFIG property, BALANCE_MODE field definition (NO TITLE)*/
+   #define  SI2196_SD_PORT_CONFIG_PROP_BALANCE_MODE_LSB         1
+   #define  SI2196_SD_PORT_CONFIG_PROP_BALANCE_MODE_MASK        0x01
+   #define  SI2196_SD_PORT_CONFIG_PROP_BALANCE_MODE_DEFAULT    0
+    #define SI2196_SD_PORT_CONFIG_PROP_BALANCE_MODE_BALANCE     0
+    #define SI2196_SD_PORT_CONFIG_PROP_BALANCE_MODE_LEFT_RIGHT  1
+
+   /* SD_PORT_CONFIG property, PORT field definition (NO TITLE)*/
+   #define  SI2196_SD_PORT_CONFIG_PROP_PORT_LSB         0
+   #define  SI2196_SD_PORT_CONFIG_PROP_PORT_MASK        0x01
+   #define  SI2196_SD_PORT_CONFIG_PROP_PORT_DEFAULT    0
+    #define SI2196_SD_PORT_CONFIG_PROP_PORT_I2S  0
+    #define SI2196_SD_PORT_CONFIG_PROP_PORT_DAC  1
+
+#endif /* SI2196_SD_PORT_CONFIG_PROP */
+
+/* SI2196 SD_PORT_MUTE property definition */
+#define   SI2196_SD_PORT_MUTE_PROP 0x0d10
+
+#ifdef    SI2196_SD_PORT_MUTE_PROP
+  #define SI2196_SD_PORT_MUTE_PROP_CODE 0x000d10
+
+
+    typedef struct { /* SI2196_SD_PORT_MUTE_PROP_struct */
+      unsigned char   mute;
+   } SI2196_SD_PORT_MUTE_PROP_struct;
+
+   /* SD_PORT_MUTE property, MUTE field definition (NO TITLE)*/
+   #define  SI2196_SD_PORT_MUTE_PROP_MUTE_LSB         0
+   #define  SI2196_SD_PORT_MUTE_PROP_MUTE_MASK        0x03
+   #define  SI2196_SD_PORT_MUTE_PROP_MUTE_DEFAULT    0
+    #define SI2196_SD_PORT_MUTE_PROP_MUTE_MUTE_NONE   0
+    #define SI2196_SD_PORT_MUTE_PROP_MUTE_MUTE_ALL    1
+    #define SI2196_SD_PORT_MUTE_PROP_MUTE_MUTE_LEFT   2
+    #define SI2196_SD_PORT_MUTE_PROP_MUTE_MUTE_RIGHT  3
+
+#endif /* SI2196_SD_PORT_MUTE_PROP */
+
+/* SI2196 SD_PORT_VOLUME_BALANCE property definition */
+#define   SI2196_SD_PORT_VOLUME_BALANCE_PROP 0x0d12
+
+#ifdef    SI2196_SD_PORT_VOLUME_BALANCE_PROP
+  #define SI2196_SD_PORT_VOLUME_BALANCE_PROP_CODE 0x000d12
+
+
+    typedef struct { /* SI2196_SD_PORT_VOLUME_BALANCE_PROP_struct */
+               int    balance;
+   } SI2196_SD_PORT_VOLUME_BALANCE_PROP_struct;
+
+   /* SD_PORT_VOLUME_BALANCE property, BALANCE field definition (NO TITLE)*/
+   #define  SI2196_SD_PORT_VOLUME_BALANCE_PROP_BALANCE_LSB         0
+   #define  SI2196_SD_PORT_VOLUME_BALANCE_PROP_BALANCE_MASK        0xffff
+   #define  SI2196_SD_PORT_VOLUME_BALANCE_PROP_BALANCE_DEFAULT    0
+    #define SI2196_SD_PORT_VOLUME_BALANCE_PROP_BALANCE_BALANCE_MIN  -100
+    #define SI2196_SD_PORT_VOLUME_BALANCE_PROP_BALANCE_BALANCE_MAX  100
+
+#endif /* SI2196_SD_PORT_VOLUME_BALANCE_PROP */
+
+/* SI2196 SD_PORT_VOLUME_LEFT property definition */
+#define   SI2196_SD_PORT_VOLUME_LEFT_PROP 0x0d13
+
+#ifdef    SI2196_SD_PORT_VOLUME_LEFT_PROP
+  #define SI2196_SD_PORT_VOLUME_LEFT_PROP_CODE 0x000d13
+
+
+    typedef struct { /* SI2196_SD_PORT_VOLUME_LEFT_PROP_struct */
+               int    volume;
+   } SI2196_SD_PORT_VOLUME_LEFT_PROP_struct;
+
+   /* SD_PORT_VOLUME_LEFT property, VOLUME field definition (NO TITLE)*/
+   #define  SI2196_SD_PORT_VOLUME_LEFT_PROP_VOLUME_LSB         0
+   #define  SI2196_SD_PORT_VOLUME_LEFT_PROP_VOLUME_MASK        0xffff
+   #define  SI2196_SD_PORT_VOLUME_LEFT_PROP_VOLUME_DEFAULT    0
+    #define SI2196_SD_PORT_VOLUME_LEFT_PROP_VOLUME_VOLUME_MIN  -231
+    #define SI2196_SD_PORT_VOLUME_LEFT_PROP_VOLUME_VOLUME_MAX  24
+
+#endif /* SI2196_SD_PORT_VOLUME_LEFT_PROP */
+
+/* SI2196 SD_PORT_VOLUME_MASTER property definition */
+#define   SI2196_SD_PORT_VOLUME_MASTER_PROP 0x0d11
+
+#ifdef    SI2196_SD_PORT_VOLUME_MASTER_PROP
+  #define SI2196_SD_PORT_VOLUME_MASTER_PROP_CODE 0x000d11
+
+
+    typedef struct { /* SI2196_SD_PORT_VOLUME_MASTER_PROP_struct */
+               int    volume;
+   } SI2196_SD_PORT_VOLUME_MASTER_PROP_struct;
+
+   /* SD_PORT_VOLUME_MASTER property, VOLUME field definition (NO TITLE)*/
+   #define  SI2196_SD_PORT_VOLUME_MASTER_PROP_VOLUME_LSB         0
+   #define  SI2196_SD_PORT_VOLUME_MASTER_PROP_VOLUME_MASK        0xffff
+   #define  SI2196_SD_PORT_VOLUME_MASTER_PROP_VOLUME_DEFAULT    0
+    #define SI2196_SD_PORT_VOLUME_MASTER_PROP_VOLUME_VOLUME_MIN  -231
+    #define SI2196_SD_PORT_VOLUME_MASTER_PROP_VOLUME_VOLUME_MAX  24
+
+#endif /* SI2196_SD_PORT_VOLUME_MASTER_PROP */
+
+/* SI2196 SD_PORT_VOLUME_RIGHT property definition */
+#define   SI2196_SD_PORT_VOLUME_RIGHT_PROP 0x0d14
+
+#ifdef    SI2196_SD_PORT_VOLUME_RIGHT_PROP
+  #define SI2196_SD_PORT_VOLUME_RIGHT_PROP_CODE 0x000d14
+
+
+    typedef struct { /* SI2196_SD_PORT_VOLUME_RIGHT_PROP_struct */
+               int    volume;
+   } SI2196_SD_PORT_VOLUME_RIGHT_PROP_struct;
+
+   /* SD_PORT_VOLUME_RIGHT property, VOLUME field definition (NO TITLE)*/
+   #define  SI2196_SD_PORT_VOLUME_RIGHT_PROP_VOLUME_LSB         0
+   #define  SI2196_SD_PORT_VOLUME_RIGHT_PROP_VOLUME_MASK        0xffff
+   #define  SI2196_SD_PORT_VOLUME_RIGHT_PROP_VOLUME_DEFAULT    0
+    #define SI2196_SD_PORT_VOLUME_RIGHT_PROP_VOLUME_VOLUME_MIN  -231
+    #define SI2196_SD_PORT_VOLUME_RIGHT_PROP_VOLUME_VOLUME_MAX  24
+
+#endif /* SI2196_SD_PORT_VOLUME_RIGHT_PROP */
+
+/* SI2196 SD_PRESCALER_AM property definition */
+#define   SI2196_SD_PRESCALER_AM_PROP 0x0d1b
+
+#ifdef    SI2196_SD_PRESCALER_AM_PROP
+  #define SI2196_SD_PRESCALER_AM_PROP_CODE 0x000d1b
+
+
+    typedef struct { /* SI2196_SD_PRESCALER_AM_PROP_struct */
+               char   gain;
+   } SI2196_SD_PRESCALER_AM_PROP_struct;
+
+   /* SD_PRESCALER_AM property, GAIN field definition (NO TITLE)*/
+   #define  SI2196_SD_PRESCALER_AM_PROP_GAIN_LSB         0
+   #define  SI2196_SD_PRESCALER_AM_PROP_GAIN_MASK        0xff
+   #define  SI2196_SD_PRESCALER_AM_PROP_GAIN_DEFAULT    -6
+    #define SI2196_SD_PRESCALER_AM_PROP_GAIN_GAIN_MIN  -127
+    #define SI2196_SD_PRESCALER_AM_PROP_GAIN_GAIN_MAX  96
+
+#endif /* SI2196_SD_PRESCALER_AM_PROP */
+
+/* SI2196 SD_PRESCALER_EIAJ property definition */
+#define   SI2196_SD_PRESCALER_EIAJ_PROP 0x0d1e
+
+#ifdef    SI2196_SD_PRESCALER_EIAJ_PROP
+  #define SI2196_SD_PRESCALER_EIAJ_PROP_CODE 0x000d1e
+
+
+    typedef struct { /* SI2196_SD_PRESCALER_EIAJ_PROP_struct */
+               char   gain;
+   } SI2196_SD_PRESCALER_EIAJ_PROP_struct;
+
+   /* SD_PRESCALER_EIAJ property, GAIN field definition (NO TITLE)*/
+   #define  SI2196_SD_PRESCALER_EIAJ_PROP_GAIN_LSB         0
+   #define  SI2196_SD_PRESCALER_EIAJ_PROP_GAIN_MASK        0xff
+   #define  SI2196_SD_PRESCALER_EIAJ_PROP_GAIN_DEFAULT    14
+    #define SI2196_SD_PRESCALER_EIAJ_PROP_GAIN_GAIN_MIN  -127
+    #define SI2196_SD_PRESCALER_EIAJ_PROP_GAIN_GAIN_MAX  96
+
+#endif /* SI2196_SD_PRESCALER_EIAJ_PROP */
+
+/* SI2196 SD_PRESCALER_FM property definition */
+#define   SI2196_SD_PRESCALER_FM_PROP 0x0d1a
+
+#ifdef    SI2196_SD_PRESCALER_FM_PROP
+  #define SI2196_SD_PRESCALER_FM_PROP_CODE 0x000d1a
+
+
+    typedef struct { /* SI2196_SD_PRESCALER_FM_PROP_struct */
+               char   gain;
+   } SI2196_SD_PRESCALER_FM_PROP_struct;
+
+   /* SD_PRESCALER_FM property, GAIN field definition (NO TITLE)*/
+   #define  SI2196_SD_PRESCALER_FM_PROP_GAIN_LSB         0
+   #define  SI2196_SD_PRESCALER_FM_PROP_GAIN_MASK        0xff
+   #define  SI2196_SD_PRESCALER_FM_PROP_GAIN_DEFAULT    2
+    #define SI2196_SD_PRESCALER_FM_PROP_GAIN_GAIN_MIN  -127
+    #define SI2196_SD_PRESCALER_FM_PROP_GAIN_GAIN_MAX  96
+
+#endif /* SI2196_SD_PRESCALER_FM_PROP */
+
+/* SI2196 SD_PRESCALER_NICAM property definition */
+#define   SI2196_SD_PRESCALER_NICAM_PROP 0x0d1c
+
+#ifdef    SI2196_SD_PRESCALER_NICAM_PROP
+  #define SI2196_SD_PRESCALER_NICAM_PROP_CODE 0x000d1c
+
+
+    typedef struct { /* SI2196_SD_PRESCALER_NICAM_PROP_struct */
+               char   gain;
+   } SI2196_SD_PRESCALER_NICAM_PROP_struct;
+
+   /* SD_PRESCALER_NICAM property, GAIN field definition (NO TITLE)*/
+   #define  SI2196_SD_PRESCALER_NICAM_PROP_GAIN_LSB         0
+   #define  SI2196_SD_PRESCALER_NICAM_PROP_GAIN_MASK        0xff
+   #define  SI2196_SD_PRESCALER_NICAM_PROP_GAIN_DEFAULT    -9
+    #define SI2196_SD_PRESCALER_NICAM_PROP_GAIN_GAIN_MIN  -127
+    #define SI2196_SD_PRESCALER_NICAM_PROP_GAIN_GAIN_MAX  96
+
+#endif /* SI2196_SD_PRESCALER_NICAM_PROP */
+
+/* SI2196 SD_PRESCALER_SAP property definition */
+#define   SI2196_SD_PRESCALER_SAP_PROP 0x0d1d
+
+#ifdef    SI2196_SD_PRESCALER_SAP_PROP
+  #define SI2196_SD_PRESCALER_SAP_PROP_CODE 0x000d1d
+
+
+    typedef struct { /* SI2196_SD_PRESCALER_SAP_PROP_struct */
+               char   gain;
+   } SI2196_SD_PRESCALER_SAP_PROP_struct;
+
+   /* SD_PRESCALER_SAP property, GAIN field definition (NO TITLE)*/
+   #define  SI2196_SD_PRESCALER_SAP_PROP_GAIN_LSB         0
+   #define  SI2196_SD_PRESCALER_SAP_PROP_GAIN_MASK        0xff
+   #define  SI2196_SD_PRESCALER_SAP_PROP_GAIN_DEFAULT    2
+    #define SI2196_SD_PRESCALER_SAP_PROP_GAIN_GAIN_MIN  -127
+    #define SI2196_SD_PRESCALER_SAP_PROP_GAIN_GAIN_MAX  96
+
+#endif /* SI2196_SD_PRESCALER_SAP_PROP */
+
+/* SI2196 SD_SOUND_MODE property definition */
+#define   SI2196_SD_SOUND_MODE_PROP 0x0d05
+
+#ifdef    SI2196_SD_SOUND_MODE_PROP
+  #define SI2196_SD_SOUND_MODE_PROP_CODE 0x000d05
+
+
+    typedef struct { /* SI2196_SD_SOUND_MODE_PROP_struct */
+      unsigned char   mode;
+   } SI2196_SD_SOUND_MODE_PROP_struct;
+
+   /* SD_SOUND_MODE property, MODE field definition (NO TITLE)*/
+   #define  SI2196_SD_SOUND_MODE_PROP_MODE_LSB         0
+   #define  SI2196_SD_SOUND_MODE_PROP_MODE_MASK        0x03
+   #define  SI2196_SD_SOUND_MODE_PROP_MODE_DEFAULT    0
+    #define SI2196_SD_SOUND_MODE_PROP_MODE_AUTODETECT  0
+    #define SI2196_SD_SOUND_MODE_PROP_MODE_MONO        1
+    #define SI2196_SD_SOUND_MODE_PROP_MODE_DUAL_MONO   2
+    #define SI2196_SD_SOUND_MODE_PROP_MODE_STEREO      3
+
+#endif /* SI2196_SD_SOUND_MODE_PROP */
+
+/* SI2196 SD_SOUND_SYSTEM property definition */
+#define   SI2196_SD_SOUND_SYSTEM_PROP 0x0d04
+
+#ifdef    SI2196_SD_SOUND_SYSTEM_PROP
+  #define SI2196_SD_SOUND_SYSTEM_PROP_CODE 0x000d04
+
+
+    typedef struct { /* SI2196_SD_SOUND_SYSTEM_PROP_struct */
+      unsigned char   system;
+   } SI2196_SD_SOUND_SYSTEM_PROP_struct;
+
+   /* SD_SOUND_SYSTEM property, SYSTEM field definition (NO TITLE)*/
+   #define  SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_LSB         0
+   #define  SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_MASK        0x0f
+   #define  SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_DEFAULT    15
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_A2_BG       0
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_A2_DK1      1
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_A2_DK2      2
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_A2_DK3      3
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_A2_M        4
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_NICAM_BG    5
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_NICAM_I     6
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_NICAM_DK    7
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_NICAM_L     8
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_EIAJ        9
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_BTSC        10
+    #define SI2196_SD_SOUND_SYSTEM_PROP_SYSTEM_AUTODETECT  15
+
+#endif /* SI2196_SD_SOUND_SYSTEM_PROP */
+
+/* SI2196 SD_STEREO_DM_ID_LVL_ACQ property definition */
+#define   SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP 0x0d20
+
+#ifdef    SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP
+  #define SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_CODE 0x000d20
+
+
+    typedef struct { /* SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_struct */
+      unsigned int    acq;
+   } SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_struct;
+
+   /* SD_STEREO_DM_ID_LVL_ACQ property, ACQ field definition (NO TITLE)*/
+   #define  SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_ACQ_LSB         0
+   #define  SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_ACQ_MASK        0xffff
+   #define  SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_ACQ_DEFAULT    1000
+    #define SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_ACQ_ACQ_MIN  0
+    #define SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_ACQ_ACQ_MAX  65535
+
+#endif /* SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP */
+
+/* SI2196 SD_STEREO_DM_ID_LVL_SHIFT property definition */
+#define   SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP 0x0d17
+
+#ifdef    SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP
+  #define SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_CODE 0x000d17
+
+
+    typedef struct { /* SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_struct */
+      unsigned char   acq_shift;
+      unsigned char   track_shift;
+   } SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_struct;
+
+   /* SD_STEREO_DM_ID_LVL_SHIFT property, ACQ_SHIFT field definition (NO TITLE)*/
+   #define  SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_ACQ_SHIFT_LSB         0
+   #define  SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_ACQ_SHIFT_MASK        0x0f
+   #define  SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_ACQ_SHIFT_DEFAULT    7
+    #define SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_ACQ_SHIFT_ACQ_SHIFT_MIN  0
+    #define SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_ACQ_SHIFT_ACQ_SHIFT_MAX  15
+
+   /* SD_STEREO_DM_ID_LVL_SHIFT property, TRACK_SHIFT field definition (NO TITLE)*/
+   #define  SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_TRACK_SHIFT_LSB         4
+   #define  SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_TRACK_SHIFT_MASK        0x0f
+   #define  SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_TRACK_SHIFT_DEFAULT    1
+    #define SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_TRACK_SHIFT_TRACK_SHIFT_MIN  0
+    #define SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_TRACK_SHIFT_TRACK_SHIFT_MAX  15
+
+#endif /* SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP */
+
+/* SI2196 SD_STEREO_DM_ID_LVL_TRACK property definition */
+#define   SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP 0x0d21
+
+#ifdef    SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP
+  #define SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_CODE 0x000d21
+
+
+    typedef struct { /* SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_struct */
+      unsigned int    track;
+   } SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_struct;
+
+   /* SD_STEREO_DM_ID_LVL_TRACK property, TRACK field definition (NO TITLE)*/
+   #define  SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_TRACK_LSB         0
+   #define  SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_TRACK_MASK        0xffff
+   #define  SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_TRACK_DEFAULT    500
+    #define SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_TRACK_TRACK_MIN  0
+    #define SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_TRACK_TRACK_MAX  65535
+
+#endif /* SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP */
+
+/* _properties_defines_insertion_point */
+
+/* _properties_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* PROPERTIES STRUCT                           */
+  /* This stores all property fields             */
+  /* --------------------------------------------*/
+  typedef struct {
+    #ifdef    SI2196_ATV_AFC_RANGE_PROP
+              si2196_atv_afc_range_prop_struct               atv_afc_range;
+    #endif /* SI2196_ATV_AFC_RANGE_PROP */
+    #ifdef    SI2196_ATV_AGC_SPEED_PROP
+              si2196_atv_agc_speed_prop_struct             atv_agc_speed;
+    #endif /* SI2196_ATV_AGC_SPEED_PROP */
+    #ifdef    SI2196_ATV_AUDIO_MODE_PROP
+              si2196_atv_audio_mode_prop_struct           atv_audio_mode;
+    #endif /* SI2196_ATV_AUDIO_MODE_PROP */
+    #ifdef    SI2196_ATV_CVBS_OUT_PROP
+              si2196_atv_cvbs_out_prop_struct                atv_cvbs_out;
+    #endif /* SI2196_ATV_CVBS_OUT_PROP */
+    #ifdef    SI2196_ATV_CVBS_OUT_FINE_PROP
+              si2196_atv_cvbs_out_fine_prop_struct        atv_cvbs_out_fine;
+    #endif /* SI2196_ATV_CVBS_OUT_FINE_PROP */
+    #ifdef    SI2196_ATV_IEN_PROP
+              si2196_atv_ien_prop_struct                         atv_ien;
+    #endif /* SI2196_ATV_IEN_PROP */
+    #ifdef    SI2196_ATV_INT_SENSE_PROP
+              si2196_atv_int_sense_prop_struct              atv_int_sense;
+    #endif /* SI2196_ATV_INT_SENSE_PROP */
+    #ifdef    SI2196_ATV_RF_TOP_PROP
+              si2196_atv_rf_top_prop_struct                    atv_rf_top;
+    #endif /* SI2196_ATV_RF_TOP_PROP */
+    #ifdef    SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP
+              si2196_atv_rsq_rssi_threshold_prop_struct  atv_rsq_rssi_threshold;
+    #endif /* SI2196_ATV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef    SI2196_ATV_RSQ_SNR_THRESHOLD_PROP
+              si2196_atv_rsq_snr_threshold_prop_struct   atv_rsq_snr_threshold;
+    #endif /* SI2196_ATV_RSQ_SNR_THRESHOLD_PROP */
+    #ifdef    SI2196_ATV_SOUND_AGC_LIMIT_PROP
+              si2196_atv_sound_agc_limit_prop_struct                    atv_sound_agc_limit;
+    #endif /* SI2196_ATV_SOUND_AGC_LIMIT_PROP */
+    #ifdef    SI2196_ATV_SOUND_AGC_SPEED_PROP
+              si2196_atv_sound_agc_speed_prop_struct       atv_sound_agc_speed;
+    #endif /* SI2196_ATV_SOUND_AGC_SPEED_PROP */
+    #ifdef    SI2196_ATV_VIDEO_EQUALIZER_PROP
+              si2196_atv_video_equalizer_prop_struct     atv_video_equalizer;
+    #endif /* SI2196_ATV_VIDEO_EQUALIZER_PROP */
+    #ifdef    SI2196_ATV_VIDEO_MODE_PROP
+              si2196_atv_video_mode_prop_struct           atv_video_mode;
+    #endif /* SI2196_ATV_VIDEO_MODE_PROP */
+    #ifdef    SI2196_ATV_VSNR_CAP_PROP
+              si2196_atv_vsnr_cap_prop_struct                atv_vsnr_cap;
+    #endif /* SI2196_ATV_VSNR_CAP_PROP */
+    #ifdef    SI2196_ATV_VSYNC_TRACKING_PROP
+              si2196_atv_vsync_tracking_prop_struct      atv_vsync_tracking;
+    #endif /* SI2196_ATV_VSYNC_TRACKING_PROP */
+    #ifdef    SI2196_CRYSTAL_TRIM_PROP
+              si2196_crystal_trim_prop_struct                  crystal_trim;
+    #endif /* SI2196_CRYSTAL_TRIM_PROP */
+    #ifdef    SI2196_SD_AFC_MAX_PROP
+              SI2196_SD_AFC_MAX_PROP_struct                    sd_afc_max;
+    #endif /* SI2196_SD_AFC_MAX_PROP */
+    #ifdef    SI2196_SD_AFC_MUTE_PROP
+              SI2196_SD_AFC_MUTE_PROP_struct                   sd_afc_mute;
+    #endif /* SI2196_SD_AFC_MUTE_PROP */
+    #ifdef    SI2196_SD_AGC_PROP
+              SI2196_SD_AGC_PROP_struct                        sd_agc;
+    #endif /* SI2196_SD_AGC_PROP */
+    #ifdef    SI2196_SD_ASD_PROP
+              SI2196_SD_ASD_PROP_struct                        sd_asd;
+    #endif /* SI2196_SD_ASD_PROP */
+    #ifdef    SI2196_SD_CARRIER_MUTE_PROP
+              SI2196_SD_CARRIER_MUTE_PROP_struct               sd_carrier_mute;
+    #endif /* SI2196_SD_CARRIER_MUTE_PROP */
+    #ifdef    SI2196_SD_I2S_PROP
+              SI2196_SD_I2S_PROP_struct                        sd_i2s;
+    #endif /* SI2196_SD_I2S_PROP */
+    #ifdef    SI2196_SD_IEN_PROP
+              SI2196_SD_IEN_PROP_struct                        sd_ien;
+    #endif /* SI2196_SD_IEN_PROP */
+    #ifdef    SI2196_SD_INT_SENSE_PROP
+              SI2196_SD_INT_SENSE_PROP_struct                  sd_int_sense;
+    #endif /* SI2196_SD_INT_SENSE_PROP */
+    #ifdef    SI2196_SD_LANG_SELECT_PROP
+              SI2196_SD_LANG_SELECT_PROP_struct                sd_lang_select;
+    #endif /* SI2196_SD_LANG_SELECT_PROP */
+    #ifdef    SI2196_SD_NICAM_PROP
+              SI2196_SD_NICAM_PROP_struct                      sd_nicam;
+    #endif /* SI2196_SD_NICAM_PROP */
+    #ifdef    SI2196_SD_NICAM_FAILOVER_THRESH_PROP
+              SI2196_SD_NICAM_FAILOVER_THRESH_PROP_struct      sd_nicam_failover_thresh;
+    #endif /* SI2196_SD_NICAM_FAILOVER_THRESH_PROP */
+    #ifdef    SI2196_SD_NICAM_RECOVER_THRESH_PROP
+              SI2196_SD_NICAM_RECOVER_THRESH_PROP_struct       sd_nicam_recover_thresh;
+    #endif /* SI2196_SD_NICAM_RECOVER_THRESH_PROP */
+    #ifdef    SI2196_SD_OVER_DEV_MODE_PROP
+              SI2196_SD_OVER_DEV_MODE_PROP_struct              sd_over_dev_mode;
+    #endif /* SI2196_SD_OVER_DEV_MODE_PROP */
+    #ifdef    SI2196_SD_OVER_DEV_MUTE_PROP
+              SI2196_SD_OVER_DEV_MUTE_PROP_struct              sd_over_dev_mute;
+    #endif /* SI2196_SD_OVER_DEV_MUTE_PROP */
+    #ifdef    SI2196_SD_PILOT_LVL_CTRL_PROP
+              SI2196_SD_PILOT_LVL_CTRL_PROP_struct             sd_pilot_lvl_ctrl;
+    #endif /* SI2196_SD_PILOT_LVL_CTRL_PROP */
+    #ifdef    SI2196_SD_PORT_CONFIG_PROP
+              SI2196_SD_PORT_CONFIG_PROP_struct                sd_port_config;
+    #endif /* SI2196_SD_PORT_CONFIG_PROP */
+    #ifdef    SI2196_SD_PORT_MUTE_PROP
+              SI2196_SD_PORT_MUTE_PROP_struct                  sd_port_mute;
+    #endif /* SI2196_SD_PORT_MUTE_PROP */
+    #ifdef    SI2196_SD_PORT_VOLUME_BALANCE_PROP
+              SI2196_SD_PORT_VOLUME_BALANCE_PROP_struct    sd_port_volume_balance;
+    #endif /* SI2196_SD_PORT_VOLUME_BALANCE_PROP */
+    #ifdef    SI2196_SD_PORT_VOLUME_LEFT_PROP
+              SI2196_SD_PORT_VOLUME_LEFT_PROP_struct           sd_port_volume_left;
+    #endif /* SI2196_SD_PORT_VOLUME_LEFT_PROP */
+    #ifdef    SI2196_SD_PORT_VOLUME_MASTER_PROP
+              SI2196_SD_PORT_VOLUME_MASTER_PROP_struct         sd_port_volume_master;
+    #endif /* SI2196_SD_PORT_VOLUME_MASTER_PROP */
+    #ifdef    SI2196_SD_PORT_VOLUME_RIGHT_PROP
+              SI2196_SD_PORT_VOLUME_RIGHT_PROP_struct          sd_port_volume_right;
+    #endif /* SI2196_SD_PORT_VOLUME_RIGHT_PROP */
+    #ifdef    SI2196_SD_PRESCALER_AM_PROP
+              SI2196_SD_PRESCALER_AM_PROP_struct               sd_prescaler_am;
+    #endif /* SI2196_SD_PRESCALER_AM_PROP */
+    #ifdef    SI2196_SD_PRESCALER_EIAJ_PROP
+              SI2196_SD_PRESCALER_EIAJ_PROP_struct             sd_prescaler_eiaj;
+    #endif /* SI2196_SD_PRESCALER_EIAJ_PROP */
+    #ifdef    SI2196_SD_PRESCALER_FM_PROP
+              SI2196_SD_PRESCALER_FM_PROP_struct               sd_prescaler_fm;
+    #endif /* SI2196_SD_PRESCALER_FM_PROP */
+    #ifdef    SI2196_SD_PRESCALER_NICAM_PROP
+              SI2196_SD_PRESCALER_NICAM_PROP_struct         sd_prescaler_nicam;
+    #endif /* SI2196_SD_PRESCALER_NICAM_PROP */
+    #ifdef    SI2196_SD_PRESCALER_SAP_PROP
+              SI2196_SD_PRESCALER_SAP_PROP_struct             sd_prescaler_sap;
+    #endif /* SI2196_SD_PRESCALER_SAP_PROP */
+    #ifdef    SI2196_SD_SOUND_MODE_PROP
+              SI2196_SD_SOUND_MODE_PROP_struct                   sd_sound_mode;
+    #endif /* SI2196_SD_SOUND_MODE_PROP */
+    #ifdef    SI2196_SD_SOUND_SYSTEM_PROP
+              SI2196_SD_SOUND_SYSTEM_PROP_struct               sd_sound_system;
+    #endif /* SI2196_SD_SOUND_SYSTEM_PROP */
+    #ifdef    SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP
+              SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_struct       sd_stereo_dm_id_lvl_acq;
+    #endif /* SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP */
+    #ifdef    SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP
+              SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_struct     sd_stereo_dm_id_lvl_shift;
+    #endif /* SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP */
+    #ifdef    SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP
+              SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_struct    sd_stereo_dm_id_lvl_track;
+    #endif/* SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP */
+    #ifdef    SI2196_DTV_AGC_SPEED_PROP
+              si2196_dtv_agc_speed_prop_struct            dtv_agc_speed;
+    #endif /* SI2196_DTV_AGC_SPEED_PROP */
+    #ifdef    SI2196_DTV_CONFIG_IF_PORT_PROP
+              si2196_dtv_config_if_port_prop_struct        dtv_config_if_port;
+    #endif /* SI2196_DTV_CONFIG_IF_PORT_PROP */
+    #ifdef    SI2196_DTV_EXT_AGC_PROP
+              si2196_dtv_ext_agc_prop_struct                 dtv_ext_agc;
+    #endif /* SI2196_DTV_EXT_AGC_PROP */
+    #ifdef    SI2196_DTV_IEN_PROP
+              si2196_dtv_ien_prop_struct                        dtv_ien;
+    #endif /* SI2196_DTV_IEN_PROP */
+    #ifdef    SI2196_DTV_INT_SENSE_PROP
+              si2196_dtv_int_sense_prop_struct              dtv_int_sense;
+    #endif /* SI2196_DTV_INT_SENSE_PROP */
+    #ifdef    SI2196_DTV_LIF_FREQ_PROP
+              si2196_dtv_lif_freq_prop_struct                   dtv_lif_freq;
+    #endif /* SI2196_DTV_LIF_FREQ_PROP */
+    #ifdef    SI2196_DTV_LIF_OUT_PROP
+              si2196_dtv_lif_out_prop_struct                    dtv_lif_out;
+    #endif /* SI2196_DTV_LIF_OUT_PROP */
+    #ifdef    SI2196_DTV_MODE_PROP
+              si2196_dtv_mode_prop_struct                     dtv_mode;
+    #endif /* SI2196_DTV_MODE_PROP */
+    #ifdef    SI2196_DTV_RF_TOP_PROP
+              si2196_dtv_rf_top_prop_struct                     dtv_rf_top;
+    #endif /* SI2196_DTV_RF_TOP_PROP */
+    #ifdef    SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP
+              si2196_dtv_rsq_rssi_threshold_prop_struct  dtv_rsq_rssi_threshold;
+    #endif /* SI2196_DTV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef    SI2196_MASTER_IEN_PROP
+              si2196_master_ien_prop_struct                    master_ien;
+    #endif /* SI2196_MASTER_IEN_PROP */
+    #ifdef    SI2196_TUNER_BLOCKED_VCO_PROP
+              si2196_tuner_blocked_vco_prop_struct       tuner_blocked_vco;
+    #endif /* SI2196_TUNER_BLOCKED_VCO_PROP */
+    #ifdef    SI2196_TUNER_IEN_PROP
+              si2196_tuner_ien_prop_struct                      tuner_ien;
+    #endif /* SI2196_TUNER_IEN_PROP */
+    #ifdef    SI2196_TUNER_INT_SENSE_PROP
+              si2196_tuner_int_sense_prop_struct            tuner_int_sense;
+    #endif /* SI2196_TUNER_INT_SENSE_PROP */
+    #ifdef    SI2196_TUNER_LO_INJECTION_PROP
+              si2196_tuner_lo_injection_prop_struct         tuner_lo_injection;
+    #endif /* SI2196_TUNER_LO_INJECTION_PROP */
+} si2196_propobj_t;
+typedef struct si2196_param_s {
+    int fre_offset;
+    unsigned char lang;
+    unsigned char sound_mode;
+    unsigned char sound_sys;
+    si2196_dtv_mode_prop_struct dtv_mode;
+    SI2196_SD_PORT_VOLUME_MASTER_PROP_struct m_volume;
+}si2196_param_t;
+/* _properties_struct_insertion_point */
+typedef struct si2196_device_s {
+    struct class *clsp;
+    struct i2c_client tuner_client;
+    si2196_cmdobj_t si_cmd;
+	 si2196_propobj_t     si_prop;
+    si2196_cmdreplyobj_t si_cmd_reply;
+    struct analog_parameters parm;
+    struct si2196_param_s sparm;
+}si2196_device_t;
+/*
+si2196_atv_afc_range_prop_struct               atv_afc_range;
+si2196_atv_agc_speed_prop_struct             atv_agc_speed;
+si2196_atv_audio_mode_prop_struct           atv_audio_mode;
+si2196_atv_cvbs_out_prop_struct                atv_cvbs_out;
+si2196_atv_cvbs_out_fine_prop_struct        atv_cvbs_out_fine;
+si2196_atv_ien_prop_struct                         atv_ien;
+si2196_atv_int_sense_prop_struct              atv_int_sense;
+si2196_atv_rf_top_prop_struct                    atv_rf_top;
+si2196_atv_rsq_rssi_threshold_prop_struct  atv_rsq_rssi_threshold;
+si2196_atv_rsq_snr_threshold_prop_struct   atv_rsq_snr_threshold;
+si2196_atv_sound_agc_limit_prop_struct                    atv_sound_agc_limit;
+si2196_atv_sound_agc_speed_prop_struct       atv_sound_agc_speed;
+si2196_atv_video_equalizer_prop_struct     atv_video_equalizer;
+si2196_atv_video_mode_prop_struct           atv_video_mode;
+si2196_atv_vsnr_cap_prop_struct                atv_vsnr_cap;
+si2196_atv_vsync_tracking_prop_struct      atv_vsync_tracking;
+si2196_crystal_trim_prop_struct                  crystal_trim;
+SI2196_SD_AFC_MAX_PROP_struct                    sd_afc_max;
+SI2196_SD_AFC_MUTE_PROP_struct                   sd_afc_mute;
+SI2196_SD_AGC_PROP_struct                        sd_agc;
+SI2196_SD_ASD_PROP_struct                        sd_asd;
+SI2196_SD_CARRIER_MUTE_PROP_struct               sd_carrier_mute;
+SI2196_SD_I2S_PROP_struct                        sd_i2s;
+SI2196_SD_IEN_PROP_struct                        sd_ien;
+SI2196_SD_INT_SENSE_PROP_struct                  sd_int_sense;
+SI2196_SD_LANG_SELECT_PROP_struct                sd_lang_select;
+SI2196_SD_NICAM_PROP_struct                      sd_nicam;
+SI2196_SD_NICAM_FAILOVER_THRESH_PROP_struct      sd_nicam_failover_thresh;
+SI2196_SD_NICAM_RECOVER_THRESH_PROP_struct       sd_nicam_recover_thresh;
+SI2196_SD_OVER_DEV_MODE_PROP_struct              sd_over_dev_mode;
+SI2196_SD_OVER_DEV_MUTE_PROP_struct              sd_over_dev_mute;
+SI2196_SD_PILOT_LVL_CTRL_PROP_struct             sd_pilot_lvl_ctrl;
+SI2196_SD_PORT_CONFIG_PROP_struct                sd_port_config;
+SI2196_SD_PORT_MUTE_PROP_struct                  sd_port_mute;
+SI2196_SD_PORT_VOLUME_BALANCE_PROP_struct    sd_port_volume_balance;
+SI2196_SD_PORT_VOLUME_LEFT_PROP_struct           sd_port_volume_left;
+SI2196_SD_PORT_VOLUME_MASTER_PROP_struct         sd_port_volume_master;
+SI2196_SD_PORT_VOLUME_RIGHT_PROP_struct          sd_port_volume_right;
+SI2196_SD_PRESCALER_AM_PROP_struct               sd_prescaler_am;
+SI2196_SD_PRESCALER_EIAJ_PROP_struct             sd_prescaler_eiaj;
+SI2196_SD_PRESCALER_FM_PROP_struct               sd_prescaler_fm;
+SI2196_SD_PRESCALER_NICAM_PROP_struct         sd_prescaler_nicam;
+SI2196_SD_PRESCALER_SAP_PROP_struct             sd_prescaler_sap;
+SI2196_SD_SOUND_MODE_PROP_struct                   sd_sound_mode;
+SI2196_SD_SOUND_SYSTEM_PROP_struct               sd_sound_system;
+SI2196_SD_STEREO_DM_ID_LVL_ACQ_PROP_struct       sd_stereo_dm_id_lvl_acq;
+SI2196_SD_STEREO_DM_ID_LVL_SHIFT_PROP_struct     sd_stereo_dm_id_lvl_shift;
+SI2196_SD_STEREO_DM_ID_LVL_TRACK_PROP_struct    sd_stereo_dm_id_lvl_track;
+si2196_dtv_agc_speed_prop_struct            dtv_agc_speed;
+si2196_dtv_config_if_port_prop_struct        dtv_config_if_port;
+si2196_dtv_ext_agc_prop_struct                 dtv_ext_agc;
+si2196_dtv_ien_prop_struct                        dtv_ien;
+si2196_dtv_int_sense_prop_struct              dtv_int_sense;
+si2196_dtv_lif_freq_prop_struct                   dtv_lif_freq;
+si2196_dtv_lif_out_prop_struct                    dtv_lif_out;
+si2196_dtv_mode_prop_struct                     dtv_mode;
+si2196_dtv_rf_top_prop_struct                     dtv_rf_top;
+si2196_dtv_rsq_rssi_threshold_prop_struct  dtv_rsq_rssi_threshold;
+si2196_master_ien_prop_struct                    master_ien;
+si2196_tuner_blocked_vco_prop_struct       tuner_blocked_vco;
+si2196_tuner_ien_prop_struct                      tuner_ien;
+si2196_tuner_int_sense_prop_struct            tuner_int_sense;
+si2196_tuner_lo_injection_prop_struct         tuner_lo_injection;
+
+*/
+
+int si2196_init(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp);
+//int si2196_powerupwithpatch(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp, si2196_common_reply_struct *common_reply);
+//int si2196_loadfirmware(struct i2c_client *si2196, unsigned char* firmwaretable, int lines, si2196_common_reply_struct *common_reply);
+//int si2196_startfirmware(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp, si2196_common_reply_struct *common_reply);
+int si2196_configure(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp);
+//int si2196_loadvideofilter(struct i2c_client *si2196, unsigned char* vidfilttable, int lines, si2196_common_reply_struct *common_reply);
+int si2196_tune(struct i2c_client *si2196, unsigned char mode, unsigned long freq, si2196_cmdreplyobj_t *rsp);
+int si2196_atvconfig(struct i2c_client *si2196, si2196_propobj_t *prop, si2196_cmdreplyobj_t *rsp);
+//int si2196_commonconfig(struct i2c_client *si2196, si2196_propobj_t *prop, si2196_cmdreplyobj_t *rsp);
+//int si2196_tunerconfig(struct i2c_client *si2196, si2196_propobj_t *prop, si2196_cmdreplyobj_t *rsp);
+//int si2196_setuptunerdefaults(si2196_propobj_t *prop);
+//int si2196_setupcommondefaults(si2196_propobj_t *prop);
+//int si2196_setupatvdefaults(si2196_propobj_t *prop);
+unsigned char si2196_get_property(struct i2c_client *si2196, unsigned char reserved, unsigned int  prop, si2196_cmdreplyobj_t *rsp);
+unsigned char si2196_set_property(struct i2c_client *si2196,  unsigned char reserved, unsigned int prop, unsigned int  data,  si2196_cmdreplyobj_t *rsp);
+unsigned char si2196_atv_status(struct i2c_client *si2196, unsigned char intack, si2196_cmdreplyobj_t *rsp);
+unsigned char si2196_tuner_status(struct i2c_client *si2196, unsigned char intack, si2196_cmdreplyobj_t *rsp);
+unsigned char si2196_power_down(struct i2c_client *si2196, si2196_cmdreplyobj_t *rsp);
+unsigned char si2196_fine_tune(struct i2c_client *si2196, unsigned char reserved,int offset_500hz, si2196_cmdreplyobj_t *rsp);
+unsigned char si2196_atv_restart(struct i2c_client *si2196, unsigned char   mode,  si2196_cmdreplyobj_t *rsp);
+unsigned char si2196_sendcommand(struct i2c_client *si2196, int cmd, si2196_cmdobj_t *c, si2196_cmdreplyobj_t *rsp);
+unsigned char si2196_adac_power_up(struct i2c_client *si2196, unsigned char duration, si2196_cmdreplyobj_t *rsp);
+unsigned char si2196_sd_status(struct i2c_client *si2196,si2196_cmdreplyobj_t *rsp, unsigned char   intack);
+#endif /* __SLI2196_FUN_H */
diff --git a/drivers/media/Kconfig b/drivers/media/Kconfig
old mode 100644
new mode 100755
index 8270388e2a0d..e3ce0ad0d9fa
--- a/drivers/media/Kconfig
+++ b/drivers/media/Kconfig
@@ -39,6 +39,7 @@ config MEDIA_ANALOG_TV_SUPPORT
 
 config MEDIA_DIGITAL_TV_SUPPORT
 	bool "Digital TV support"
+	default y
 	---help---
 	  Enable digital TV support.
 
diff --git a/drivers/media/dvb-core/Kconfig b/drivers/media/dvb-core/Kconfig
old mode 100644
new mode 100755
index fa7a2490ed5f..2940ded678db
--- a/drivers/media/dvb-core/Kconfig
+++ b/drivers/media/dvb-core/Kconfig
@@ -18,7 +18,7 @@ config DVB_MAX_ADAPTERS
 config DVB_DYNAMIC_MINORS
 	bool "Dynamic DVB minor allocation"
 	depends on DVB_CORE
-	default n
+	default y
 	help
 	  If you say Y here, the DVB subsystem will use dynamic minor
 	  allocation for any device that uses the DVB major number.
diff --git a/drivers/media/dvb-core/demux.h b/drivers/media/dvb-core/demux.h
old mode 100644
new mode 100755
index 833191bcd810..3127d90674b7
--- a/drivers/media/dvb-core/demux.h
+++ b/drivers/media/dvb-core/demux.h
@@ -30,7 +30,7 @@
 #include <linux/errno.h>
 #include <linux/list.h>
 #include <linux/time.h>
-#include <linux/dvb/dmx.h>
+#include <uapi/linux/dvb/dmx.h>
 
 /*--------------------------------------------------------------------------*/
 /* Common definitions */
@@ -83,6 +83,46 @@ enum dmx_success {
 #define TS_DEMUX        8   /* in case TS_PACKET is set, send the TS to
 			       the demux device, not to the dvr device */
 
+/* PES type for filters which write to built-in decoder */
+/* these should be kept identical to the types in dmx.h */
+
+typedef enum
+{  /* also send packets to decoder (if it exists) */
+	DMX_TS_PES_AUDIO0,
+	DMX_TS_PES_VIDEO0,
+	DMX_TS_PES_TELETEXT0,
+	DMX_TS_PES_SUBTITLE0,
+	DMX_TS_PES_PCR0,
+
+	DMX_TS_PES_AUDIO1,
+	DMX_TS_PES_VIDEO1,
+	DMX_TS_PES_TELETEXT1,
+	DMX_TS_PES_SUBTITLE1,
+	DMX_TS_PES_PCR1,
+
+	DMX_TS_PES_AUDIO2,
+	DMX_TS_PES_VIDEO2,
+	DMX_TS_PES_TELETEXT2,
+	DMX_TS_PES_SUBTITLE2,
+	DMX_TS_PES_PCR2,
+
+	DMX_TS_PES_AUDIO3,
+	DMX_TS_PES_VIDEO3,
+	DMX_TS_PES_TELETEXT3,
+	DMX_TS_PES_SUBTITLE3,
+	DMX_TS_PES_PCR3,
+
+	DMX_TS_PES_OTHER
+}dmx_ts_pes_t;
+
+
+#define DMX_TS_PES_AUDIO    DMX_TS_PES_AUDIO0
+#define DMX_TS_PES_VIDEO    DMX_TS_PES_VIDEO0
+#define DMX_TS_PES_TELETEXT DMX_TS_PES_TELETEXT0
+#define DMX_TS_PES_SUBTITLE DMX_TS_PES_SUBTITLE0
+#define DMX_TS_PES_PCR      DMX_TS_PES_PCR0
+
+
 struct dmx_ts_feed {
 	int is_filtering; /* Set to non-zero when filtering in progress */
 	struct dmx_demux *parent; /* Back-pointer */
diff --git a/drivers/media/dvb-core/dmxdev.h b/drivers/media/dvb-core/dmxdev.h
old mode 100644
new mode 100755
index 48c6cf92ab99..459502f69113
--- a/drivers/media/dvb-core/dmxdev.h
+++ b/drivers/media/dvb-core/dmxdev.h
@@ -34,7 +34,7 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 
-#include <linux/dvb/dmx.h>
+#include <uapi/linux/dvb/dmx.h>
 
 #include "dvbdev.h"
 #include "demux.h"
diff --git a/drivers/media/dvb-core/dvb_ca_en50221.h b/drivers/media/dvb-core/dvb_ca_en50221.h
old mode 100644
new mode 100755
index 7df2e141187a..a2d45d1b8586
--- a/drivers/media/dvb-core/dvb_ca_en50221.h
+++ b/drivers/media/dvb-core/dvb_ca_en50221.h
@@ -22,7 +22,7 @@
 #define _DVB_CA_EN50221_H_
 
 #include <linux/list.h>
-#include <linux/dvb/ca.h>
+#include <uapi/linux/dvb/ca.h>
 
 #include "dvbdev.h"
 
diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
old mode 100644
new mode 100755
index 1f925e856974..62d99291a121
--- a/drivers/media/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb-core/dvb_frontend.c
@@ -44,7 +44,7 @@
 
 #include "dvb_frontend.h"
 #include "dvbdev.h"
-#include <linux/dvb/version.h>
+#include <uapi/linux/dvb/version.h>
 
 static int dvb_frontend_debug;
 static int dvb_shutdown_timeout;
@@ -52,6 +52,8 @@ static int dvb_force_auto_inversion;
 static int dvb_override_tune_delay;
 static int dvb_powerdown_on_sleep = 1;
 static int dvb_mfe_wait_time = 5;
+static int dvb_afc_debug=0;
+static int disable_set_frotend_param=0;
 
 module_param_named(frontend_debug, dvb_frontend_debug, int, 0644);
 MODULE_PARM_DESC(frontend_debug, "Turn on/off frontend core debugging (default:off).");
@@ -65,6 +67,13 @@ module_param(dvb_powerdown_on_sleep, int, 0644);
 MODULE_PARM_DESC(dvb_powerdown_on_sleep, "0: do not power down, 1: turn LNB voltage off on sleep (default)");
 module_param(dvb_mfe_wait_time, int, 0644);
 MODULE_PARM_DESC(dvb_mfe_wait_time, "Wait up to <mfe_wait_time> seconds on open() for multi-frontend to become available (default:5 seconds)");
+module_param(dvb_afc_debug, int, 0644);
+MODULE_PARM_DESC( dvb_afc_debug,"vb_afc_debug \n");
+module_param(disable_set_frotend_param, int, 0644);
+MODULE_PARM_DESC( disable_set_frotend_param,"disable_set_frotend_param \n");
+
+#define dprintk if (dvb_frontend_debug) printk
+#define pr_afc  if(dvb_afc_debug)printk
 
 #define FESTATE_IDLE 1
 #define FESTATE_RETUNE 2
@@ -101,14 +110,22 @@ MODULE_PARM_DESC(dvb_mfe_wait_time, "Wait up to <mfe_wait_time> seconds on open(
 #define DVB_FE_DEVICE_REMOVED	2
 
 static DEFINE_MUTEX(frontend_mutex);
+extern unsigned int jiffies_to_msecs(const unsigned long j);
+int jiffiestime;
+//#define LOCK_TIMEOUT 2000
+static int LOCK_TIMEOUT = 2000;
 
 struct dvb_frontend_private {
 
 	/* thread/frontend values */
 	struct dvb_device *dvbdev;
+	struct dvb_frontend_parameters parameters_in;
 	struct dvb_frontend_parameters parameters_out;
 	struct dvb_fe_events events;
 	struct semaphore sem;
+	struct dvbsx_blindscan_events blindscan_events;
+	struct semaphore blindscan_sem;
+	bool in_blindscan;
 	struct list_head list_head;
 	wait_queue_head_t wait_queue;
 	struct task_struct *thread;
@@ -122,6 +139,12 @@ struct dvb_frontend_private {
 	int tone;
 	int voltage;
 
+	/*set_frontend ops async support*/
+	wait_queue_head_t setfrontendasync_wait_queue;
+	unsigned int setfrontendasync_wakeup;
+	unsigned int setfrontendasync_needwakeup;
+	unsigned int setfrontendasync_interruptwakeup;
+
 	/* swzigzag values */
 	unsigned int state;
 	unsigned int bending;
@@ -136,6 +159,7 @@ struct dvb_frontend_private {
 	int quality;
 	unsigned int check_wrapped;
 	enum dvbfe_search algo_status;
+	int user_delay;
 };
 
 static void dvb_frontend_wakeup(struct dvb_frontend *fe);
@@ -160,6 +184,7 @@ enum dvbv3_emulation_type {
 	DVBV3_QAM,
 	DVBV3_OFDM,
 	DVBV3_ATSC,
+	DVBV3_ANALOG
 };
 
 static enum dvbv3_emulation_type dvbv3_type(u32 delivery_system)
@@ -183,6 +208,8 @@ static enum dvbv3_emulation_type dvbv3_type(u32 delivery_system)
 	case SYS_ATSCMH:
 	case SYS_DVBC_ANNEX_B:
 		return DVBV3_ATSC;
+	case SYS_ANALOG:
+		return DVBV3_ANALOG;
 	case SYS_UNDEFINED:
 	case SYS_ISDBC:
 	case SYS_DVBH:
@@ -268,6 +295,92 @@ static int dvb_frontend_get_event(struct dvb_frontend *fe,
 	return 0;
 }
 
+static void dvbsx_blindscan_add_event(struct dvb_frontend *fe, struct dvbsx_blindscanevent *pbsevent)
+{
+	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+	struct dvbsx_blindscan_events *events = &fepriv->blindscan_events;
+	struct dvbsx_blindscanevent *e;
+	int wp;
+
+	dprintk ("%s\n", __func__);
+
+	if (mutex_lock_interruptible (&events->mtx))
+		return;
+
+	wp = (events->eventw + 1) % MAX_BLINDSCAN_EVENT;
+
+	if (wp == events->eventr) {
+		events->overflow = 1;
+		events->eventr = (events->eventr + 1) % MAX_BLINDSCAN_EVENT;
+	}
+
+	e = &events->events[events->eventw];
+
+	memcpy (e, pbsevent, sizeof (struct dvbsx_blindscanevent));
+
+	events->eventw = wp;
+
+	mutex_unlock(&events->mtx);
+
+	wake_up_interruptible (&events->wait_queue);
+}
+
+static int dvbsx_blindscan_get_event(struct dvb_frontend *fe,
+				struct dvbsx_blindscanevent *event , int flags)
+{
+	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+	struct dvbsx_blindscan_events *events = &fepriv->blindscan_events;
+
+	dprintk ("%s\n", __func__);
+
+	if (events->overflow) {
+		events->overflow = 0;
+		return -EOVERFLOW;
+	}
+
+	if (events->eventw == events->eventr) {
+		int ret;
+
+		if (flags & O_NONBLOCK)
+			return -EWOULDBLOCK;
+
+		up(&fepriv->blindscan_sem);
+
+		ret = wait_event_interruptible_timeout (events->wait_queue,
+												events->eventw != events->eventr, fe->ops.blindscan_ops.info.bspara.timeout * HZ);
+
+		if (down_interruptible (&fepriv->blindscan_sem))
+			return -ERESTARTSYS;
+
+		if (ret < 0)
+			return ret;
+	}
+
+	if (mutex_lock_interruptible (&events->mtx))
+		return -ERESTARTSYS;
+
+	memcpy (event, &events->events[events->eventr],
+		sizeof(struct dvbsx_blindscanevent));
+
+	events->eventr = (events->eventr + 1) % MAX_BLINDSCAN_EVENT;
+
+	mutex_unlock(&events->mtx);
+
+	return 0;
+}
+
+static int dvbsx_blindscan_event_callback(struct dvb_frontend *fe, struct dvbsx_blindscanevent *pbsevent)
+{
+	dprintk ("%s\n", __func__);
+
+	if((!fe) || (!pbsevent ))
+		return -1;
+
+	dvbsx_blindscan_add_event(fe, pbsevent);
+
+	return 0;
+}
+
 static void dvb_frontend_clear_events(struct dvb_frontend *fe)
 {
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
@@ -334,6 +447,7 @@ static int dvb_frontend_swzigzag_autotune(struct dvb_frontend *fe, int check_wra
 	int autoinversion;
 	int ready = 0;
 	int fe_set_err = 0;
+	int time=0;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;
 	int original_inversion = c->inversion;
@@ -412,8 +526,13 @@ static int dvb_frontend_swzigzag_autotune(struct dvb_frontend *fe, int check_wra
 	if (autoinversion)
 		c->inversion = fepriv->inversion;
 	tmp = *c;
-	if (fe->ops.set_frontend)
+	time=jiffies_to_msecs(jiffies)-jiffiestime;
+	dprintk("2---auto tune,time is %d\n",time);
+	if (fe->ops.set_frontend&&(time>=LOCK_TIMEOUT)){
 		fe_set_err = fe->ops.set_frontend(fe);
+		jiffiestime=jiffies_to_msecs(jiffies);
+		}
+	fepriv->parameters_out = fepriv->parameters_in;
 	*c = tmp;
 	if (fe_set_err < 0) {
 		fepriv->state = FESTATE_ERROR;
@@ -427,10 +546,27 @@ static int dvb_frontend_swzigzag_autotune(struct dvb_frontend *fe, int check_wra
 	return 0;
 }
 
+#if (defined CONFIG_AM_M6_DEMOD)
+extern u32 dvbc_get_status(void);
+extern unsigned long atsc_read_iqr_reg(void);
+
+#endif
+#if (defined CONFIG_AM_SI2176)
+int si2176_get_strength(void);
+#endif
+#if (defined CONFIG_AM_SI2177)
+int si2177_get_strength(void);
+#endif
+
+
 static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 {
 	fe_status_t s = 0;
 	int retval = 0;
+	int time=0;
+	int count=0;
+	int newcount=0;
+	int strength=0;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;
 
@@ -464,7 +600,10 @@ static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 	} else {
 		if (fe->ops.read_status)
 			fe->ops.read_status(fe, &s);
-		if (s != fepriv->status) {
+			time=jiffies_to_msecs(jiffies)-jiffiestime;
+		dprintk("1---read status,time is %d, s is %d,fepriv->status is %d\n",time,s,fepriv->status);
+		if (((s != fepriv->status)&&(time>=LOCK_TIMEOUT))||((s != fepriv->status)&&(s == (FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC)))) {
+			printk("1----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
 			dvb_frontend_add_event(fe, s);
 			fepriv->status = s;
 		}
@@ -482,6 +621,142 @@ static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 		}
 		return;
 	}
+//auto_mode qam   201306-rsj
+#if (defined CONFIG_AM_M6_DEMOD)
+//dvbc auto qam
+	if(c->modulation== QAM_AUTO){
+		while((dvbc_get_status()<=3)&&(count<=20)){
+			msleep(30);
+			if(count==20){
+				fe->ops.read_status(fe, &s);
+				printk("!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
+				dvb_frontend_add_event(fe, s);
+				fepriv->status = s;
+			}
+			count++;
+		}
+		count=0;
+		while((dvbc_get_status()>3)&&(dvbc_get_status()!=5)&&(count<5)){
+			if(count==0)
+				c->modulation=QAM_64;
+			else if(count==1)
+				c->modulation=QAM_256;
+			else if(count==2)
+				c->modulation=QAM_128;
+			else if(count==3)
+				c->modulation=QAM_16;
+			else
+				c->modulation=QAM_32;
+
+			if (fe->ops.set_qam_mode){
+				fe->ops.set_qam_mode(fe);
+			}
+			for(newcount;newcount<6;newcount++){
+				if(dvbc_get_status()==5)
+					break;
+				msleep(50);
+			}
+			newcount=0;
+			count++;
+			if(dvbc_get_status()==5){
+				if (fe->ops.read_status){
+					fe->ops.read_status(fe, &s);
+				}
+				if(((s != fepriv->status)&&(s == (FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC)))){
+					printk("!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
+					dvb_frontend_add_event(fe, s);
+					fepriv->status = s;
+					break;
+				}
+			}
+
+		}
+	}else if(c->modulation == QAM_AUTO){
+	//	fepriv->parameters_out = fepriv->parameters_in;
+		msleep(100);
+		#if (defined CONFIG_AM_SI2176)
+		strength=si2176_get_strength()-256;
+		if(strength<=(-85)){
+			s=32;
+			printk("5-strength is %d\n",strength);
+			if(s != fepriv->status){
+					printk("5----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
+					dvb_frontend_add_event(fe, s);
+					fepriv->status = s;
+					jiffiestime=jiffies_to_msecs(jiffies);
+				}
+			return;
+
+		}
+		#elif (defined CONFIG_AM_SI2177)
+		strength=si2177_get_strength()-256;
+		if(strength<=(-85)){
+			s=32;
+			printk("5-strength is %d\n",strength);
+			if(s != fepriv->status){
+					printk("5----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
+					dvb_frontend_add_event(fe, s);
+					fepriv->status = s;
+					jiffiestime=jiffies_to_msecs(jiffies);
+				}
+			return;
+
+		}
+		#endif
+		while(((atsc_read_iqr_reg()>>16)!=0x1f)&&(count<2)){
+			if(count==0){
+				if (fe->ops.set_frontend){
+			//	fe->ops.set_frontend(fe, &fepriv->parameters_in);
+				}
+			}
+	//			fepriv->parameters_in.u.vsb.modulation=QAM_256;
+			else if(count==1){
+				c->modulation=QAM_64;
+				if (fe->ops.set_qam_mode){
+					fe->ops.set_qam_mode(fe);
+				}
+			//	dprintk("fepriv->parameters_in.frequency is %d\n",fepriv->parameters_in.frequency);
+			}
+			for(newcount;newcount<10;newcount++){
+				if((atsc_read_iqr_reg()>>16)==0x1f)
+					break;
+				msleep(50);
+			}
+			newcount=0;
+			count++;
+		if((atsc_read_iqr_reg()>>16)==0x1f){
+				if (fe->ops.read_status){
+					fe->ops.read_status(fe, &s);
+				}
+				if(((s != fepriv->status)&&(s == (FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC)))){
+					printk("3----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
+					printk("fepriv->parameters_in.frequency is %d\n",fepriv->parameters_in.frequency);
+					dvb_frontend_add_event(fe, s);
+					fepriv->status = s;
+					jiffiestime=jiffies_to_msecs(jiffies);
+					return;
+				}
+			}
+			if(count==2&&((atsc_read_iqr_reg()>>16)!=0x1f)){
+				if (fe->ops.read_status){
+					fe->ops.read_status(fe, &s);
+				}
+				if(s != fepriv->status){
+					printk("2----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
+					printk("fepriv->parameters_in.frequency is %d\n",fepriv->parameters_in.frequency);
+					dvb_frontend_add_event(fe, s);
+					fepriv->status = s;
+					jiffiestime=jiffies_to_msecs(jiffies);
+					return;
+				}
+			}
+		}
+
+	}
+
+
+//
+#endif
 
 	/* if we are tuned already, check we're still locked */
 	if (fepriv->state & FESTATE_TUNED) {
@@ -526,6 +801,10 @@ static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 
 	/* fast zigzag. */
 	if ((fepriv->state & FESTATE_SEARCHING_FAST) || (fepriv->state & FESTATE_RETUNE)) {
+
+	  if(fepriv->state & FESTATE_SEARCHING_FAST)
+		fepriv->delay = fepriv->min_delay + HZ/5;/*if not lock signal ,then wait 25 jiffies*/
+	  else
 		fepriv->delay = fepriv->min_delay;
 
 		/* perform a tune */
@@ -599,11 +878,11 @@ static int dvb_frontend_thread(void *data)
 {
 	struct dvb_frontend *fe = data;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+	unsigned long timeout;
 	fe_status_t s;
 	enum dvbfe_algo algo;
 
-	bool re_tune = false;
-	bool semheld = false;
+	struct dvb_frontend_parameters *params;
 
 	dev_dbg(fe->dvb->device, "%s:\n", __func__);
 
@@ -620,15 +899,13 @@ static int dvb_frontend_thread(void *data)
 	while (1) {
 		up(&fepriv->sem);	    /* is locked when we enter the thread... */
 restart:
-		wait_event_interruptible_timeout(fepriv->wait_queue,
+		timeout = wait_event_interruptible_timeout(fepriv->wait_queue,
 			dvb_frontend_should_wakeup(fe) || kthread_should_stop()
 				|| freezing(current),
 			fepriv->delay);
 
 		if (kthread_should_stop() || dvb_frontend_is_exiting(fe)) {
 			/* got signal or quitting */
-			if (!down_interruptible(&fepriv->sem))
-				semheld = true;
 			fepriv->exit = DVB_FE_NORMAL_EXIT;
 			break;
 		}
@@ -656,15 +933,15 @@ restart:
 				dev_dbg(fe->dvb->device, "%s: Frontend ALGO = DVBFE_ALGO_HW\n", __func__);
 
 				if (fepriv->state & FESTATE_RETUNE) {
-					dev_dbg(fe->dvb->device, "%s: Retune requested, FESTATE_RETUNE\n", __func__);
-					re_tune = true;
+					dprintk("%s: Retune requested, FESTATE_RETUNE\n", __func__);
+					params = &fepriv->parameters_in;
 					fepriv->state = FESTATE_TUNED;
-				} else {
-					re_tune = false;
 				}
 
 				if (fe->ops.tune)
-					fe->ops.tune(fe, re_tune, fepriv->tune_mode_flags, &fepriv->delay, &s);
+					fe->ops.tune(fe, params, fepriv->tune_mode_flags, &fepriv->delay, &s);
+				if (params)
+					fepriv->parameters_out = *params;
 
 				if (s != fepriv->status && !(fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT)) {
 					dev_dbg(fe->dvb->device, "%s: state changed, adding current state\n", __func__);
@@ -688,7 +965,7 @@ restart:
 				 */
 				if (fepriv->algo_status & DVBFE_ALGO_SEARCH_AGAIN) {
 					if (fe->ops.search) {
-						fepriv->algo_status = fe->ops.search(fe);
+						fepriv->algo_status = fe->ops.search(fe,params);
 						/* We did do a search as was requested, the flags are
 						 * now unset as well and has the flags wrt to search.
 						 */
@@ -744,8 +1021,6 @@ restart:
 		fepriv->exit = DVB_FE_NO_EXIT;
 	mb();
 
-	if (semheld)
-		up(&fepriv->sem);
 	dvb_frontend_wakeup(fe);
 	return 0;
 }
@@ -976,6 +1251,125 @@ static int dvb_frontend_clear_cache(struct dvb_frontend *fe)
 	return 0;
 }
 
+static int dvb_frontend_asyncshouldwakeup(struct dvb_frontend *fe)
+{
+	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+
+	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_wakeup);
+
+	if (fepriv->setfrontendasync_wakeup) {
+		fepriv->setfrontendasync_wakeup = 0;
+		return 1;
+	}
+
+	return 0;
+}
+
+static void dvb_frontend_asyncwakeup(struct dvb_frontend *fe)
+{
+	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+
+	if(!fe){
+		return;
+	}
+
+	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
+		return;
+	}
+
+
+	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_needwakeup);
+
+	if(fepriv->setfrontendasync_needwakeup){
+		fepriv->setfrontendasync_wakeup = 1;
+		wake_up_interruptible(&fepriv->setfrontendasync_wait_queue);
+	}
+}
+
+static int dvb_frontend_asyncpreproc(struct dvb_frontend *fe)
+{
+	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+
+	if(!fe){
+		return -1;
+	}
+
+	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
+		return -1;
+	}
+
+	fepriv->setfrontendasync_needwakeup = 1;
+
+	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_needwakeup);
+
+	/*enable other frontend ops run*/
+	up(&fepriv->sem);
+
+	return 0;
+}
+
+static int dvb_frontend_asyncwait(struct dvb_frontend *fe, u32 ms_timeout)
+{
+	int ret = 0;
+	unsigned long wait_ret = 0;
+	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+
+	if(!fe){
+		return -1;
+	}
+
+	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
+		return -1;
+	}
+
+	wait_ret= wait_event_interruptible_timeout(fepriv->setfrontendasync_wait_queue,
+											dvb_frontend_asyncshouldwakeup(fe),
+											ms_timeout * HZ /1000);
+
+	dprintk ("%s:%d/%d\n", __func__, ms_timeout, wait_ret);
+
+	if(wait_ret > 0){
+		ret = 1;
+	}
+	else if(wait_ret == 0){
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int dvb_frontend_asyncpostproc(struct dvb_frontend *fe, int asyncwait_ret)
+{
+	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+
+	if(!fe){
+		return -1;
+	}
+
+	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
+		return -1;
+	}
+
+	if (down_interruptible (&fepriv->sem))
+		return -1;
+
+	fepriv->setfrontendasync_needwakeup = 0;
+
+	if(asyncwait_ret > 0){
+		fepriv->setfrontendasync_interruptwakeup = 1;
+	}
+	else if(asyncwait_ret == 0){
+		fepriv->setfrontendasync_interruptwakeup = 0;
+	}
+	else{
+		fepriv->setfrontendasync_interruptwakeup = 0;
+	}
+
+	dprintk ("%s:%d/%d\n", __func__, asyncwait_ret, fepriv->setfrontendasync_needwakeup);
+
+	return 0;
+}
+
 #define _DTV_CMD(n, s, b) \
 [n] = { \
 	.name = #n, \
@@ -1147,6 +1541,7 @@ static int dtv_property_cache_sync(struct dvb_frontend *fe,
 		c->transmission_mode = p->u.ofdm.transmission_mode;
 		c->guard_interval = p->u.ofdm.guard_interval;
 		c->hierarchy = p->u.ofdm.hierarchy_information;
+		c->ofdm_mode = p->u.ofdm.ofdm_mode;
 		break;
 	case DVBV3_ATSC:
 		dev_dbg(fe->dvb->device, "%s: Preparing ATSC req\n", __func__);
@@ -1158,6 +1553,13 @@ static int dtv_property_cache_sync(struct dvb_frontend *fe,
 		else
 			c->delivery_system = SYS_DVBC_ANNEX_B;
 		break;
+	case DVBV3_ANALOG:
+		c->analog.soundsys  = p->u.analog.soundsys;
+		c->analog.audmode   = p->u.analog.audmode;
+		c->analog.std       = p->u.analog.std;
+		c->analog.flag      = p->u.analog.flag;
+		c->analog.reserved  = p->u.analog.reserved;
+		break;
 	case DVBV3_UNKNOWN:
 		dev_err(fe->dvb->device,
 				"%s: doesn't know how to handle a DVBv3 call to delivery system %i\n",
@@ -1227,11 +1629,20 @@ static int dtv_property_legacy_params_sync(struct dvb_frontend *fe,
 		p->u.ofdm.transmission_mode = c->transmission_mode;
 		p->u.ofdm.guard_interval = c->guard_interval;
 		p->u.ofdm.hierarchy_information = c->hierarchy;
+		p->u.ofdm.ofdm_mode = c->ofdm_mode;
 		break;
 	case DVBV3_ATSC:
 		dev_dbg(fe->dvb->device, "%s: Preparing VSB req\n", __func__);
 		p->u.vsb.modulation = c->modulation;
 		break;
+	case DVBV3_ANALOG:
+		p->u.analog.soundsys = c->analog.soundsys;
+		p->u.analog.audmode  = c->analog.audmode;
+		p->u.analog.std      = c->analog.std;
+		p->u.analog.flag     = c->analog.flag;
+		p->u.analog.reserved = c->analog.reserved;
+		break;
+
 	}
 	return 0;
 }
@@ -1504,7 +1915,8 @@ static bool is_dvbv3_delsys(u32 delsys)
 	bool status;
 
 	status = (delsys == SYS_DVBT) || (delsys == SYS_DVBC_ANNEX_A) ||
-		 (delsys == SYS_DVBS) || (delsys == SYS_ATSC);
+		 (delsys == SYS_DVBS) || (delsys == SYS_ATSC) || (delsys == SYS_DTMB) ||
+		 (delsys == SYS_ISDBT)|| (delsys == SYS_ANALOG);
 
 	return status;
 }
@@ -1899,10 +2311,39 @@ static int dvb_frontend_ioctl(struct file *file,
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	int err = -EOPNOTSUPP;
+	int need_lock = 1;
+	int need_blindscan = 0;
 
 	dev_dbg(fe->dvb->device, "%s: (%d)\n", __func__, _IOC_NR(cmd));
-	if (down_interruptible(&fepriv->sem))
-		return -ERESTARTSYS;
+
+	if (fepriv->exit != DVB_FE_NO_EXIT)
+		return -ENODEV;
+
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY &&
+	    (_IOC_DIR(cmd) != _IOC_READ || cmd == FE_GET_EVENT ||
+	     cmd == FE_DISEQC_RECV_SLAVE_REPLY))
+		return -EPERM;
+
+	if (cmd==FE_READ_STATUS ||
+			cmd==FE_READ_BER ||
+			cmd==FE_READ_SIGNAL_STRENGTH ||
+			cmd==FE_READ_SNR ||
+			cmd==FE_READ_UNCORRECTED_BLOCKS ||
+			cmd==FE_GET_FRONTEND ||
+			cmd==FE_READ_AFC ||
+			cmd==FE_SET_BLINDSCAN ||
+			cmd==FE_GET_BLINDSCANEVENT ||
+			cmd==FE_SET_BLINDSCANCANCEl)
+		need_lock = 0;
+
+	if (cmd==FE_SET_BLINDSCAN ||
+			cmd==FE_GET_BLINDSCANEVENT ||
+			cmd==FE_SET_BLINDSCANCANCEl)
+		need_blindscan = 1;
+
+	if (need_lock)
+		if (down_interruptible(&fepriv->sem))
+			return -ERESTARTSYS;
 
 	if (fepriv->exit != DVB_FE_NO_EXIT) {
 		up(&fepriv->sem);
@@ -1916,6 +2357,14 @@ static int dvb_frontend_ioctl(struct file *file,
 		return -EPERM;
 	}
 
+	if (need_blindscan)
+		if (down_interruptible (&fepriv->blindscan_sem))
+			return -ERESTARTSYS;
+
+	if(cmd==FE_SET_FRONTEND ||
+			cmd==FE_SET_MODE)
+		dvb_frontend_asyncwakeup(fe);
+
 	if ((cmd == FE_SET_PROPERTY) || (cmd == FE_GET_PROPERTY))
 		err = dvb_frontend_ioctl_properties(file, cmd, parg);
 	else {
@@ -1923,7 +2372,12 @@ static int dvb_frontend_ioctl(struct file *file,
 		err = dvb_frontend_ioctl_legacy(file, cmd, parg);
 	}
 
-	up(&fepriv->sem);
+	if (need_blindscan)
+		up(&fepriv->blindscan_sem);
+
+	if (need_lock)
+		up(&fepriv->sem);
+
 	return err;
 }
 
@@ -2029,6 +2483,7 @@ out:
 
 static int dtv_set_frontend(struct dvb_frontend *fe)
 {
+	printk("dtv_set_frontend\n");
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct dvb_frontend_tune_settings fetunesettings;
@@ -2136,10 +2591,16 @@ static int dtv_set_frontend(struct dvb_frontend *fe)
 
 	/* Request the search algorithm to search */
 	fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
-
-	dvb_frontend_clear_events(fe);
-	dvb_frontend_add_event(fe, 0);
-	dvb_frontend_wakeup(fe);
+	if(c->delivery_system==SYS_ANALOG && (c->analog.flag & ANALOG_FLAG_ENABLE_AFC)){
+		dvb_frontend_add_event(fe, 0);
+		dvb_frontend_wakeup(fe);
+	}else if (fe->ops.set_frontend){
+		fe->ops.set_frontend(fe);
+		if(c->delivery_system!=SYS_ANALOG)
+			dvb_frontend_clear_events(fe);
+			dvb_frontend_add_event(fe, 0);
+			dvb_frontend_wakeup(fe);
+	}
 	fepriv->status = 0;
 
 	return 0;
@@ -2369,16 +2830,21 @@ static int dvb_frontend_ioctl_legacy(struct file *file,
 			err = fe->ops.enable_high_lnb_voltage(fe, (long) parg);
 		break;
 
-	case FE_SET_FRONTEND:
+	case FE_SET_FRONTEND: {
+		if(disable_set_frotend_param)
+		    break;
+		printk("FE_SET_FRONTEND\n");
 		err = dvbv3_set_delivery_system(fe);
 		if (err)
 			break;
-
 		err = dtv_property_cache_sync(fe, c, parg);
 		if (err)
 			break;
+		jiffiestime=jiffies_to_msecs(jiffies);
 		err = dtv_set_frontend(fe);
 		break;
+	}
+
 	case FE_GET_EVENT:
 		err = dvb_frontend_get_event (fe, parg, file->f_flags);
 		break;
@@ -2391,6 +2857,146 @@ static int dvb_frontend_ioctl_legacy(struct file *file,
 		fepriv->tune_mode_flags = (unsigned long) parg;
 		err = 0;
 		break;
+
+	case FE_SET_DELAY:
+		fepriv->user_delay = (int)parg;
+		err = 0;
+		break;
+
+	case FE_SET_MODE:
+		if(fe->ops.set_mode){
+			err = fe->ops.set_mode(fe, (int)parg);
+		if(err == 0){
+			switch((int)parg){
+			case FE_QPSK:
+				c->delivery_system = SYS_DVBS2;//DVBV3_QPSK;
+				break;
+			case FE_QAM:
+				c->delivery_system = SYS_DVBC_ANNEX_A;//DVBV3_QAM;
+				break;
+			case FE_OFDM:
+				c->delivery_system = SYS_DVBT;//DVBV3_OFDM;
+				break;
+			case FE_ATSC:
+				c->delivery_system = SYS_ATSC;//DVBV3_ATSC;
+				break;
+			case FE_ANALOG:
+				c->delivery_system = SYS_ANALOG;//DVBV3_ANALOG;
+				break;
+			case FE_DTMB:
+				c->delivery_system = SYS_DTMB;//DVBV3_OFDM;
+				break;
+			case FE_ISDBT:
+				c->delivery_system = SYS_ISDBT;//DVBV3_OFDM;
+			break;
+				}
+			}
+		}
+		break;
+
+	case FE_READ_TS:
+		if(fe->ops.read_ts){
+			err = fe->ops.read_ts(fe, (int*)parg);
+		}
+		break;
+
+    case FE_FINE_TUNE:
+       if(fe->ops.tuner_ops.fine_tune){
+            err = fe->ops.tuner_ops.fine_tune(fe, *((int*)parg));
+       }
+       break;
+    case FE_READ_TUNER_STATUS:
+       if(fe->ops.tuner_ops.get_tuner_status){
+            tuner_status_t parm_status = {0};
+            tuner_status_t *tmsp = parg;
+            err = fe->ops.tuner_ops.get_tuner_status(fe, &parm_status);
+            memcpy(tmsp,&parm_status,sizeof(tuner_status_t));
+       }
+       break;
+    case FE_READ_ANALOG_STATUS:
+       if(fe->ops.analog_ops.get_atv_status){
+            atv_status_t atv_stats = {0};
+            atv_status_t *tmap = parg;
+            err = fe->ops.analog_ops.get_atv_status(fe, &atv_stats);
+            memcpy(tmap,&atv_stats,sizeof(atv_status_t));
+       }
+       break;
+    case FE_READ_SD_STATUS:
+       if(fe->ops.analog_ops.get_sd_status){
+        sound_status_t sound_sts = {0};
+            err = fe->ops.analog_ops.get_sd_status(fe, &sound_sts);
+            memcpy(parg,&sound_sts,sizeof(sound_status_t));
+       }
+       break;
+    case FE_SET_PARAM_BOX:
+        if(fe->ops.tuner_ops.set_config){
+            tuner_param_t tuner_parm = {0};
+            memcpy(&tuner_parm, parg, sizeof(tuner_param_t));
+            err = fe->ops.tuner_ops.set_config(fe, &tuner_parm);
+            memcpy(parg,&tuner_parm, sizeof(tuner_param_t));
+        }
+        break;
+
+	case  FE_SET_BLINDSCAN:
+		memcpy (&(fe->ops.blindscan_ops.info.bspara), parg, sizeof (struct dvbsx_blindscanpara));
+
+		dprintk("FE_SET_BLINDSCAN %d %d %d %d %d %d %d\n",
+				fe->ops.blindscan_ops.info.bspara.minfrequency,
+				fe->ops.blindscan_ops.info.bspara.maxfrequency,
+				fe->ops.blindscan_ops.info.bspara.minSymbolRate,
+				fe->ops.blindscan_ops.info.bspara.maxSymbolRate,
+				fe->ops.blindscan_ops.info.bspara.frequencyRange,
+				fe->ops.blindscan_ops.info.bspara.frequencyStep,
+				fe->ops.blindscan_ops.info.bspara.timeout);
+
+		/*register*/
+		fe->ops.blindscan_ops.info.blindscan_callback = dvbsx_blindscan_event_callback;
+
+		fepriv->in_blindscan = true;
+
+		if (fe->ops.blindscan_ops.blindscan_scan)
+			err = fe->ops.blindscan_ops.blindscan_scan(fe, &(fe->ops.blindscan_ops.info.bspara));
+		break;
+
+	case  FE_GET_BLINDSCANEVENT:
+		{
+			struct dvbsx_blindscanevent *p_tmp_bsevent = NULL;
+
+			err = dvbsx_blindscan_get_event (fe, (struct dvbsx_blindscanevent*) parg, file->f_flags);
+
+			p_tmp_bsevent = (struct dvbsx_blindscanevent*) parg;
+
+			dprintk("FE_GET_BLINDSCANEVENT status:%d\n", p_tmp_bsevent->status);
+
+			if(p_tmp_bsevent->status == BLINDSCAN_UPDATESTARTFREQ)
+			{
+				dprintk("start freq %d\n", p_tmp_bsevent->u.m_uistartfreq_khz);
+			}
+			else if(p_tmp_bsevent->status == BLINDSCAN_UPDATEPROCESS)
+			{
+				dprintk("process %d\n", p_tmp_bsevent->u.m_uiprogress);
+			}
+			else if(p_tmp_bsevent->status == BLINDSCAN_UPDATERESULTFREQ)
+			{
+				dprintk("result freq %d symb %d\n", p_tmp_bsevent->u.parameters.frequency, p_tmp_bsevent->u.parameters.u.qpsk.symbol_rate);
+			}
+			break;
+		}
+
+	case  FE_SET_BLINDSCANCANCEl:
+		dprintk("FE_SET_BLINDSCANCANCEl\n");
+
+
+		if (fe->ops.blindscan_ops.blindscan_cancel)
+			err = fe->ops.blindscan_ops.blindscan_cancel(fe);
+
+		fepriv->in_blindscan = false;
+
+		/*unregister*/
+		fe->ops.blindscan_ops.info.blindscan_callback = NULL;
+
+		break;
+
 	}
 
 	return err;
@@ -2492,6 +3098,7 @@ static int dvb_frontend_open(struct inode *inode, struct file *file)
 
 		/*  empty event queue */
 		fepriv->events.eventr = fepriv->events.eventw = 0;
+		fepriv->blindscan_events.eventr = fepriv->blindscan_events.eventw = 0;
 	}
 
 	if (adapter->mfe_shared)
@@ -2583,6 +3190,25 @@ int dvb_frontend_resume(struct dvb_frontend *fe)
 }
 EXPORT_SYMBOL(dvb_frontend_resume);
 
+
+static ssize_t dvbc_lock_show(struct class *cls,struct class_attribute *attr,char *buf)
+{
+	return sprintf(buf, "dvbc_autoflags: %s\n", LOCK_TIMEOUT?"on":"off");
+}
+static ssize_t dvbc_lock_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
+{
+	int mode = simple_strtol(buf,0,16);
+	printk("autoflags is %d\n",mode);
+	LOCK_TIMEOUT= mode;
+	return count;
+
+}
+
+static CLASS_ATTR(lock_time,0644,dvbc_lock_show,dvbc_lock_store);
+
+struct class *tongfang_clsp;
+#define LOCK_DEVICE_NAME  "tongfang"
+
 int dvb_register_frontend(struct dvb_adapter* dvb,
 			  struct dvb_frontend* fe)
 {
@@ -2608,18 +3234,42 @@ int dvb_register_frontend(struct dvb_adapter* dvb,
 	fepriv = fe->frontend_priv;
 
 	sema_init(&fepriv->sem, 1);
+	sema_init(&fepriv->blindscan_sem, 1);
 	init_waitqueue_head (&fepriv->wait_queue);
 	init_waitqueue_head (&fepriv->events.wait_queue);
+	init_waitqueue_head (&fepriv->blindscan_events.wait_queue);
 	mutex_init(&fepriv->events.mtx);
+	mutex_init(&fepriv->blindscan_events.mtx);
 	fe->dvb = dvb;
 	fepriv->inversion = INVERSION_OFF;
 
+	init_waitqueue_head (&fepriv->setfrontendasync_wait_queue);
+	fepriv->setfrontendasync_wakeup = 0;
+	fepriv->setfrontendasync_needwakeup = 0;
+	fepriv->setfrontendasync_interruptwakeup = 0;
+
+	fe->ops.asyncinfo.set_frontend_asyncpreproc = dvb_frontend_asyncpreproc;
+	fe->ops.asyncinfo.set_frontend_asyncwait = dvb_frontend_asyncwait;
+	fe->ops.asyncinfo.set_frontend_asyncpostproc = dvb_frontend_asyncpostproc;
+
 	dev_info(fe->dvb->device,
 			"DVB: registering adapter %i frontend %i (%s)...\n",
 			fe->dvb->num, fe->id, fe->ops.info.name);
 
 	dvb_register_device (fe->dvb, &fepriv->dvbdev, &dvbdev_template,
 			     fe, DVB_DEVICE_FRONTEND);
+	int ret;
+	printk("For tongfang\n");
+	ret=0;
+	tongfang_clsp = class_create(THIS_MODULE,LOCK_DEVICE_NAME);
+	if(!tongfang_clsp)
+	{
+			 printk("[tongfang]%s:create class error.\n",__func__);
+			 return PTR_ERR(tongfang_clsp);
+	}
+	ret = class_create_file(tongfang_clsp, &class_attr_lock_time);
+	if(ret)
+		printk("[tongfang]%s create  class file error.\n",__func__);
 
 	/*
 	 * Initialize the cache to the proper values according with the
@@ -2649,6 +3299,8 @@ int dvb_unregister_frontend(struct dvb_frontend* fe)
 
 	mutex_lock(&frontend_mutex);
 	dvb_unregister_device (fepriv->dvbdev);
+	class_remove_file(tongfang_clsp, &class_attr_lock_time);
+	class_destroy(tongfang_clsp);
 
 	/* fe is invalid now */
 	kfree(fepriv);
@@ -2694,3 +3346,17 @@ void dvb_frontend_detach(struct dvb_frontend* fe)
 }
 #endif
 EXPORT_SYMBOL(dvb_frontend_detach);
+
+void dvb_frontend_retune(struct dvb_frontend *fe)
+{
+	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+
+	fepriv->state = FESTATE_RETUNE;
+
+	fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
+
+	dvb_frontend_wakeup(fe);
+	fepriv->status = 0;
+}
+EXPORT_SYMBOL(dvb_frontend_retune);
+
diff --git a/drivers/media/dvb-core/dvb_frontend.h b/drivers/media/dvb-core/dvb_frontend.h
old mode 100644
new mode 100755
index 371b6caf486c..ac48f21aa0a5
--- a/drivers/media/dvb-core/dvb_frontend.h
+++ b/drivers/media/dvb-core/dvb_frontend.h
@@ -38,7 +38,9 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 
-#include <linux/dvb/frontend.h>
+//#include <linux/dvb/frontend.h>
+#include <uapi/linux/dvb/frontend.h>
+
 
 #include "dvbdev.h"
 
@@ -52,6 +54,7 @@ struct dvb_frontend_tune_settings {
 	int min_delay_ms;
 	int step_size;
 	int max_drift;
+	struct dvb_frontend_parameters parameters;
 };
 
 struct dvb_frontend;
@@ -71,8 +74,12 @@ struct dvb_tuner_info {
 struct analog_parameters {
 	unsigned int frequency;
 	unsigned int mode;
+	unsigned int soundsys;//A2,BTSC/EIAJ/NICAM
 	unsigned int audmode;
-	u64 std;
+	unsigned int lock_range;
+	unsigned int leap_step;
+	v4l2_std_id std;
+	unsigned int reserved;
 };
 
 enum dvbfe_modcod {
@@ -207,7 +214,7 @@ struct dvb_tuner_ops {
 	int (*set_analog_params)(struct dvb_frontend *fe, struct analog_parameters *p);
 
 	/** This is support for demods like the mt352 - fills out the supplied buffer with what to write. */
-	int (*calc_regs)(struct dvb_frontend *fe, u8 *buf, int buf_len);
+	int (*calc_regs)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p, u8 *buf, int buf_len);
 
 	/** This is to allow setting tuner-specific configs */
 	int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
@@ -219,6 +226,7 @@ struct dvb_tuner_ops {
 #define TUNER_STATUS_LOCKED 1
 #define TUNER_STATUS_STEREO 2
 	int (*get_status)(struct dvb_frontend *fe, u32 *status);
+	int (*get_pll_status)(struct dvb_frontend *fe, u32 *status);
 	int (*get_rf_strength)(struct dvb_frontend *fe, u16 *strength);
 	int (*get_afc)(struct dvb_frontend *fe, s32 *afc);
 
@@ -233,6 +241,10 @@ struct dvb_tuner_ops {
 	 */
 	int (*set_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
 	int (*get_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
+    /*add function to get tuner status*/
+    int (*get_tuner_status)(struct dvb_frontend *fe, tuner_status_t *tuner_status);
+    /*add special fine tune function */
+    int (*fine_tune)(struct dvb_frontend *fe, int offset_khz);
 };
 
 struct analog_demod_info {
@@ -243,10 +255,13 @@ struct analog_demod_ops {
 
 	struct analog_demod_info info;
 
-	void (*set_params)(struct dvb_frontend *fe,
-			   struct analog_parameters *params);
-	int  (*has_signal)(struct dvb_frontend *fe, u16 *signal);
-	int  (*get_afc)(struct dvb_frontend *fe, s32 *afc);
+	void (*set_params)(struct dvb_frontend *fe);
+	int  (*has_signal)(struct dvb_frontend *fe);
+	int  (*is_stereo)(struct dvb_frontend *fe);
+	int  (*get_afc)(struct dvb_frontend *fe);
+        int  (*get_snr)(struct dvb_frontend *fe);
+	void (*get_status)(struct dvb_frontend *fe, void *status);
+	void (*get_pll_status)(struct dvb_frontend *fe, void *status);
 	void (*tuner_status)(struct dvb_frontend *fe);
 	void (*standby)(struct dvb_frontend *fe);
 	void (*release)(struct dvb_frontend *fe);
@@ -254,10 +269,37 @@ struct analog_demod_ops {
 
 	/** This is to allow setting tuner-specific configuration */
 	int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
+    /*add function to get atv_demod & stereo_demod status*/
+    int (*get_atv_status)(struct dvb_frontend *fe, atv_status_t *atv_status);
+    int (*get_sd_status)(struct dvb_frontend *fe, sound_status_t *sd_status);
 };
 
 struct dtv_frontend_properties;
 
+struct dvbsx_blindscan_info {
+	/* timeout of get blindscan event */
+	struct dvbsx_blindscanpara bspara;
+	int (*blindscan_callback)(struct dvb_frontend *fe, struct dvbsx_blindscanevent *pbsevent);
+};
+
+struct dvbsx_blindscan_ops {
+	struct dvbsx_blindscan_info info;
+
+	/*
+	 *  These are provided start and stop blindscan
+	 */
+	int (*blindscan_scan)(struct dvb_frontend* fe, struct dvbsx_blindscanpara *pbspara);
+	int (*blindscan_cancel)(struct dvb_frontend* fe);
+};
+
+struct dvb_frontend_asyncinfo {
+	int set_frontend_asyncenable;
+	int (*set_frontend_asyncpreproc)(struct dvb_frontend *fe);
+	/*return value = 1 interrupt, = 0 timeout,  = -1 error*/
+	int (*set_frontend_asyncwait)(struct dvb_frontend *fe, u32 timeout);
+	int (*set_frontend_asyncpostproc)(struct dvb_frontend *fe, int asyncwait_ret);
+};
+
 struct dvb_frontend_ops {
 
 	struct dvb_frontend_info info;
@@ -274,7 +316,7 @@ struct dvb_frontend_ops {
 
 	/* if this is set, it overrides the default swzigzag */
 	int (*tune)(struct dvb_frontend* fe,
-		    bool re_tune,
+		    struct dvb_frontend_parameters* params,
 		    unsigned int mode_flags,
 		    unsigned int *delay,
 		    fe_status_t *status);
@@ -282,16 +324,17 @@ struct dvb_frontend_ops {
 	enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend *fe);
 
 	/* these two are only used for the swzigzag code */
-	int (*set_frontend)(struct dvb_frontend *fe);
+	int (*set_frontend)(struct dvb_frontend* fe);
 	int (*get_tune_settings)(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* settings);
 
-	int (*get_frontend)(struct dvb_frontend *fe);
+	int (*get_frontend)(struct dvb_frontend* fe);
 
 	int (*read_status)(struct dvb_frontend* fe, fe_status_t* status);
 	int (*read_ber)(struct dvb_frontend* fe, u32* ber);
 	int (*read_signal_strength)(struct dvb_frontend* fe, u16* strength);
 	int (*read_snr)(struct dvb_frontend* fe, u16* snr);
 	int (*read_ucblocks)(struct dvb_frontend* fe, u32* ucblocks);
+	int (*set_qam_mode)(struct dvb_frontend* fe);
 
 	int (*diseqc_reset_overload)(struct dvb_frontend* fe);
 	int (*diseqc_send_master_cmd)(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd* cmd);
@@ -308,16 +351,23 @@ struct dvb_frontend_ops {
 	/* These callbacks are for devices that implement their own
 	 * tuning algorithms, rather than a simple swzigzag
 	 */
-	enum dvbfe_search (*search)(struct dvb_frontend *fe);
+	enum dvbfe_search (*search)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p);
+	int (*track)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p);
 
 	struct dvb_tuner_ops tuner_ops;
 	struct analog_demod_ops analog_ops;
 
 	int (*set_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
 	int (*get_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
+
+	struct dvbsx_blindscan_ops blindscan_ops;
+
+	int (*set_mode)(struct dvb_frontend* fe, fe_type_t type);
+	int (*read_ts)(struct dvb_frontend* fe, int *ts);
+
+	struct dvb_frontend_asyncinfo asyncinfo;
 };
 
-#ifdef __DVB_CORE__
 #define MAX_EVENT 8
 
 struct dvb_fe_events {
@@ -328,7 +378,17 @@ struct dvb_fe_events {
 	wait_queue_head_t	  wait_queue;
 	struct mutex		  mtx;
 };
-#endif
+
+#define MAX_BLINDSCAN_EVENT 32
+
+struct dvbsx_blindscan_events {
+	struct dvbsx_blindscanevent events[MAX_BLINDSCAN_EVENT];
+	int			  eventw;
+	int			  eventr;
+	int			  overflow;
+	wait_queue_head_t	  wait_queue;
+	struct mutex		  mtx;
+};
 
 struct dtv_frontend_properties {
 
@@ -353,6 +413,8 @@ struct dtv_frontend_properties {
 	fe_pilot_t		pilot;
 	fe_rolloff_t		rolloff;
 
+	fe_ofdm_mode_t      ofdm_mode;
+
 	fe_delivery_system_t	delivery_system;
 
 	enum fe_interleaving	interleaving;
@@ -374,6 +436,11 @@ struct dtv_frontend_properties {
 	/* Multistream specifics */
 	u32			stream_id;
 
+	u32         dvbt2_plp_id;
+
+	/* Analog specifics */
+	struct dvb_analog_parameters analog;
+	struct dvb_analog_parameters param;
 	/* ATSC-MH specifics */
 	u8			atscmh_fic_ver;
 	u8			atscmh_parade_id;
diff --git a/drivers/media/dvb-core/dvb_net.c b/drivers/media/dvb-core/dvb_net.c
old mode 100644
new mode 100755
index f91c80c0e9ec..50da98cd71cb
--- a/drivers/media/dvb-core/dvb_net.c
+++ b/drivers/media/dvb-core/dvb_net.c
@@ -58,7 +58,7 @@
 #include <linux/kernel.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
-#include <linux/dvb/net.h>
+#include <uapi/linux/dvb/net.h>
 #include <linux/uio.h>
 #include <asm/uaccess.h>
 #include <linux/crc32.h>
diff --git a/drivers/media/dvb-core/dvbdev.c b/drivers/media/dvb-core/dvbdev.c
old mode 100644
new mode 100755
index 401ef64f92c6..9fb109059c42
--- a/drivers/media/dvb-core/dvbdev.c
+++ b/drivers/media/dvb-core/dvbdev.c
@@ -47,7 +47,7 @@ static DEFINE_MUTEX(dvbdev_register_lock);
 
 static const char * const dnames[] = {
 	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
-	"net", "osd"
+	"net", "osd", "dsc"
 };
 
 #ifdef CONFIG_DVB_DYNAMIC_MINORS
diff --git a/drivers/media/dvb-core/dvbdev.h b/drivers/media/dvb-core/dvbdev.h
old mode 100644
new mode 100755
index 93a9470d3f0c..d2bee9cb227c
--- a/drivers/media/dvb-core/dvbdev.h
+++ b/drivers/media/dvb-core/dvbdev.h
@@ -47,6 +47,7 @@
 #define DVB_DEVICE_CA         6
 #define DVB_DEVICE_NET        7
 #define DVB_DEVICE_OSD        8
+#define DVB_DEVICE_DSC        9
 
 #define DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr) \
 	static short adapter_nr[] = \
diff --git a/include/linux/amlogic/amdsc.h b/include/linux/amlogic/amdsc.h
new file mode 100755
index 000000000000..4be8d984b61b
--- /dev/null
+++ b/include/linux/amlogic/amdsc.h
@@ -0,0 +1,40 @@
+/*
+ * AMLOGIC descrambler driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#ifndef _AMDSC_H
+#define _AMDSC_H
+
+#include <asm/types.h>
+
+typedef enum {
+	AM_DSC_EVEN_KEY,
+	AM_DSC_ODD_KEY
+} am_dsc_key_type_t;
+
+struct am_dsc_key {
+	am_dsc_key_type_t    type;
+	__u8                 key[8];
+};
+
+#define AMDSC_IOC_MAGIC  'D'
+
+#define AMDSC_IOC_SET_PID      _IO(AMDSC_IOC_MAGIC, 0x00)
+#define AMDSC_IOC_SET_KEY      _IOW(AMDSC_IOC_MAGIC, 0x01, struct am_dsc_key)
+
+#endif
+
diff --git a/include/uapi/linux/dvb/frontend.h b/include/uapi/linux/dvb/frontend.h
old mode 100644
new mode 100755
index c56d77c496a5..1f2ccd89094c
--- a/include/uapi/linux/dvb/frontend.h
+++ b/include/uapi/linux/dvb/frontend.h
@@ -27,14 +27,26 @@
 #define _DVBFRONTEND_H_
 
 #include <linux/types.h>
+#include <linux/videodev2.h>
 
 typedef enum fe_type {
 	FE_QPSK,
 	FE_QAM,
 	FE_OFDM,
-	FE_ATSC
+	FE_ATSC,
+	FE_ANALOG,
+	FE_DTMB,
+	FE_ISDBT
 } fe_type_t;
 
+typedef enum fe_layer {
+	Layer_A_B_C,
+	Layer_A,
+	Layer_B,
+	Layer_C,
+} fe_layer_t;
+
+
 
 typedef enum fe_caps {
 	FE_IS_STUPID			= 0,
@@ -70,6 +82,7 @@ typedef enum fe_caps {
 	FE_CAN_MUTE_TS			= 0x80000000  /* frontend can stop spurious TS data output */
 } fe_caps_t;
 
+#define FE_CAN_3_LAYER FE_CAN_MULTISTREAM
 
 struct dvb_frontend_info {
 	char       name[128];
@@ -106,7 +119,8 @@ struct dvb_diseqc_slave_reply {
 typedef enum fe_sec_voltage {
 	SEC_VOLTAGE_13,
 	SEC_VOLTAGE_18,
-	SEC_VOLTAGE_OFF
+	SEC_VOLTAGE_OFF,
+	SEC_VOLTAGE_ON     // for ISDBT antenna control
 } fe_sec_voltage_t;
 
 
@@ -135,14 +149,15 @@ typedef enum fe_sec_mini_cmd {
  */
 
 typedef enum fe_status {
-	FE_HAS_SIGNAL		= 0x01,
-	FE_HAS_CARRIER		= 0x02,
-	FE_HAS_VITERBI		= 0x04,
-	FE_HAS_SYNC		= 0x08,
-	FE_HAS_LOCK		= 0x10,
-	FE_TIMEDOUT		= 0x20,
-	FE_REINIT		= 0x40,
-} fe_status_t;
+	FE_HAS_SIGNAL	= 0x01,   /* found something above the noise level */
+	FE_HAS_CARRIER	= 0x02,   /* found a DVB signal  */
+	FE_HAS_VITERBI	= 0x04,   /* FEC is stable  */
+	FE_HAS_SYNC	= 0x08,   /* found sync bytes  */
+	FE_HAS_LOCK	= 0x10,   /* everything's working... */
+	FE_TIMEDOUT	= 0x20,   /* no lock within the last ~2 seconds */
+	FE_REINIT	= 0x40    /* frontend was reinitialized,  */
+} fe_status_t;			  /* application is recommended to reset */
+				  /* DiSEqC, tone and parameters */
 
 typedef enum fe_spectral_inversion {
 	INVERSION_OFF,
@@ -197,7 +212,7 @@ typedef enum fe_transmit_mode {
 	TRANSMISSION_MODE_C3780,
 } fe_transmit_mode_t;
 
-#if defined(__DVB_CORE__) || !defined (__KERNEL__)
+//#if defined(__DVB_CORE__) || !defined (__KERNEL__)
 typedef enum fe_bandwidth {
 	BANDWIDTH_8_MHZ,
 	BANDWIDTH_7_MHZ,
@@ -207,7 +222,7 @@ typedef enum fe_bandwidth {
 	BANDWIDTH_10_MHZ,
 	BANDWIDTH_1_712_MHZ,
 } fe_bandwidth_t;
-#endif
+//#endif
 
 typedef enum fe_guard_interval {
 	GUARD_INTERVAL_1_32,
@@ -239,7 +254,13 @@ enum fe_interleaving {
 	INTERLEAVING_720,
 };
 
-#if defined(__DVB_CORE__) || !defined (__KERNEL__)
+typedef enum fe_ofdm_mode
+{
+	OFDM_DVBT,
+	OFDM_DVBT2,
+}fe_ofdm_mode_t;
+
+//#if defined(__DVB_CORE__) || !defined (__KERNEL__)
 struct dvb_qpsk_parameters {
 	__u32		symbol_rate;  /* symbol rate in Symbols per second */
 	fe_code_rate_t	fec_inner;    /* forward error correction (see above) */
@@ -263,8 +284,19 @@ struct dvb_ofdm_parameters {
 	fe_transmit_mode_t  transmission_mode;
 	fe_guard_interval_t guard_interval;
 	fe_hierarchy_t      hierarchy_information;
+	fe_ofdm_mode_t ofdm_mode;
 };
 
+#define ANALOG_FLAG_ENABLE_AFC                 0X00000001
+#define  ANALOG_FLAG_MANUL_SCAN                0x00000011
+struct dvb_analog_parameters {
+	unsigned int         audmode; /*V4L2_TUNER_MODE_MONO,V4L2_TUNER_MODE_STEREO,V4L2_TUNER_MODE_LANG2,V4L2_TUNER_MODE_SAP,V4L2_TUNER_MODE_LANG1,V4L2_TUNER_MODE_LANG1_LANG2*/
+	unsigned int         soundsys;/*A2,BTSC,EIAJ,NICAM*/
+	v4l2_std_id           std;
+	unsigned int         flag;
+                unsigned int         afc_range;
+        unsigned int         reserved;
+};
 
 struct dvb_frontend_parameters {
 	__u32 frequency;     /* (absolute) frequency in Hz for QAM/OFDM/ATSC */
@@ -275,6 +307,7 @@ struct dvb_frontend_parameters {
 		struct dvb_qam_parameters  qam;
 		struct dvb_ofdm_parameters ofdm;
 		struct dvb_vsb_parameters vsb;
+		struct dvb_analog_parameters analog;
 	} u;
 };
 
@@ -282,7 +315,7 @@ struct dvb_frontend_event {
 	fe_status_t status;
 	struct dvb_frontend_parameters parameters;
 };
-#endif
+//#endif
 
 /* S2API Commands */
 #define DTV_UNDEFINED		0
@@ -345,6 +378,8 @@ struct dvb_frontend_event {
 
 #define DTV_ENUM_DELSYS		44
 
+#define DTV_DVBT2_PLP_ID    DTV_DVBT2_PLP_ID_LEGACY
+
 /* ATSC-MH */
 #define DTV_ATSCMH_FIC_VER		45
 #define DTV_ATSCMH_PARADE_ID		46
@@ -408,8 +443,9 @@ typedef enum fe_delivery_system {
 	SYS_CMMB,
 	SYS_DAB,
 	SYS_DVBT2,
+	SYS_ANALOG,
 	SYS_TURBO,
-	SYS_DVBC_ANNEX_C,
+	SYS_DVBC_ANNEX_C
 } fe_delivery_system_t;
 
 /* backward compatibility */
@@ -551,10 +587,85 @@ struct dtv_properties {
 	__u32 num;
 	struct dtv_property *props;
 };
+//for atv
+typedef struct tuner_status_s {
+	unsigned int frequency;
+	unsigned int rssi;
+	unsigned char mode;//dtv:0 or atv:1
+	unsigned char tuner_locked;//notlocked:0,locked:1
+	void 		 *ressrved;
+}tuner_status_t;
+
+typedef struct atv_status_s {
+	unsigned char atv_lock;//notlocked:0,locked 1
+	v4l2_std_id	  std;
+	unsigned int  audmode;
+			 int  snr;
+                         int  afc;
+	void     	  *resrvred;
+}atv_status_t;
+
+typedef struct sound_status_s {
+	unsigned short sound_sys;//A2DK/A2BG/NICAM BG/NICAM DK/BTSC/EIAJ
+	unsigned short sound_mode;//SETERO/DUAL/MONO/SAP
+	void     	       *resrvred;
+}sound_status_t;
+typedef enum tuner_param_cmd_e{
+	TUNER_CMD_AUDIO_MUTE = 0x0000,
+	TUNER_CMD_AUDIO_ON,// 0x0001,
+	TUNER_CMD_TUNER_POWER_ON,
+	TUNER_CMD_TUNER_POWER_DOWN,
+	TUNER_CMD_SET_VOLUME,
+	TUNER_CMD_SET_LEAP_SETP_SIZE,
+	TUNER_CMD_GET_MONO_MODE,
+	TUNER_CMD_SET_BEST_LOCK_RANGE,
+	TUNER_CMD_GET_BEST_LOCK_RANGE,
+	TUNER_CMD_SET_CVBS_AMP_OUT,
+	TUNER_CMD_GET_CVBS_AMP_OUT,
+	TUNER_CMD_NULL,
+}tuner_param_cmd_t;
+/*parameter for set param box*/
+typedef struct tuner_param_s {
+	tuner_param_cmd_t cmd;
+	unsigned int      parm;
+	unsigned int 	  resvred;
+}tuner_param_t;
 
 #define FE_SET_PROPERTY		   _IOW('o', 82, struct dtv_properties)
 #define FE_GET_PROPERTY		   _IOR('o', 83, struct dtv_properties)
 
+/* Satellite blind scan settings */
+struct dvbsx_blindscanpara {
+	__u32 minfrequency;			/* minimum tuner frequency in kHz */
+	__u32 maxfrequency;			/* maximum tuner frequency in kHz */
+	__u32 minSymbolRate;		/* minimum symbol rate in sym/sec */
+	__u32 maxSymbolRate;		/* maximum symbol rate in sym/sec */
+	__u32 frequencyRange;		/* search range in kHz. freq -/+freqRange will be searched */
+	__u32 frequencyStep;			/* tuner step frequency in kHz */
+	__s32 timeout;				/* blindscan event timeout*/
+};
+
+/* Satellite blind scan status */
+typedef enum dvbsx_blindscanstatus {
+	BLINDSCAN_NONEDO,
+	BLINDSCAN_UPDATESTARTFREQ,
+	BLINDSCAN_UPDATEPROCESS,
+	BLINDSCAN_UPDATERESULTFREQ
+} dvbsx_blindscanstatus_t;
+
+/* Satellite blind scan event */
+struct dvbsx_blindscanevent {
+	dvbsx_blindscanstatus_t status;
+	union {
+		__u16 m_uiprogress;							/* The percentage completion of the blind scan procedure. A value of 100 indicates that the blind scan is finished. */
+		__u32 m_uistartfreq_khz;					/* The start scan frequency in units of kHz. The minimum value depends on the tuner specification. */
+		struct dvb_frontend_parameters parameters;	/* Blind scan channel info. */
+	} u;
+};
+
+#define FE_SET_BLINDSCAN					_IOW('o', 84, struct dvbsx_blindscanpara)
+#define FE_GET_BLINDSCANEVENT		   		_IOR('o', 85, struct dvbsx_blindscanevent)
+#define FE_SET_BLINDSCANCANCEl				_IO('o', 86)
 
 /**
  * When set, this flag will disable any zigzagging or other "normal" tuning
@@ -590,4 +701,16 @@ struct dtv_properties {
 
 #define FE_DISHNETWORK_SEND_LEGACY_CMD _IO('o', 80) /* unsigned int */
 
+#define FE_SET_DELAY               _IO('o', 100)
+
+
+#define FE_SET_MODE                _IO('o', 90)
+#define FE_READ_AFC                _IOR('o', 91, __u32)
+#define FE_FINE_TUNE               _IOW('o', 92, __u32)
+#define FE_READ_TUNER_STATUS       _IOR('o', 93, tuner_status_t)
+#define FE_READ_ANALOG_STATUS      _IOR('o', 94, atv_status_t)
+#define FE_READ_SD_STATUS          _IOR('o', 95, sound_status_t)
+#define FE_READ_TS                 _IOR('o', 96, int)
+//set & get the tuner parameters only atv
+#define FE_SET_PARAM_BOX           _IOWR('o', 97, tuner_param_t)
 #endif /*_DVBFRONTEND_H_*/
-- 
2.19.0

