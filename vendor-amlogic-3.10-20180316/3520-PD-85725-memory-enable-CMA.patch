From c64d1137dc930668938a2df5f58d773c10f420dc Mon Sep 17 00:00:00 2001
From: "Chris.Sun" <qiuwei.sun@amlogic.com>
Date: Fri, 3 Jan 2014 15:28:57 +0800
Subject: [PATCH 3520/5965] PD #85725 memory: enable CMA

from amlogic-pd-85725-3, 18 commits are squashed.
---
 Documentation/devicetree/bindings/memory.txt  | 101 +++++
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |  16 +-
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |  15 +-
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |  15 +-
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |  15 +-
 arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd  |  24 +-
 arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd  |  13 +-
 arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd |  25 +-
 arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd |  12 +-
 arch/arm/boot/dts/amlogic/meson8_skt.dtd      |  16 +-
 arch/arm/configs/meson8_defconfig             |   5 +
 arch/arm/include/asm/dma-contiguous.h         |   1 -
 arch/arm/mach-meson8/board-meson8-common.c    |   1 +
 drivers/amlogic/amports/amstream.c            |  91 ++--
 drivers/amlogic/amports/encoder.c             |  59 ++-
 .../amports/m8/ucode/h264_4k2k/h264c_linux.h  |   2 +-
 .../m8/ucode/h264_4k2k/h264slice_linux.h      | 390 +++++++++---------
 drivers/amlogic/amports/vdec.c                |  37 +-
 drivers/amlogic/amports/vdec.h                |   3 +-
 drivers/amlogic/amports/vh264_4k2k.c          | 206 +++++----
 drivers/amlogic/camera/ar0543.c               |  11 +-
 drivers/amlogic/camera/ar0833.c               |  12 +-
 drivers/amlogic/camera/common/vm.c            |  86 +++-
 drivers/amlogic/camera/gc0307.c               |   9 +
 drivers/amlogic/camera/gc0308.c               |   9 +-
 drivers/amlogic/camera/gc0328.c               |   8 +
 drivers/amlogic/camera/gc0329.c               |   8 +
 drivers/amlogic/camera/gc2015.c               |   8 +
 drivers/amlogic/camera/gc2035.c               |  12 +
 drivers/amlogic/camera/gt2005.c               |   8 +
 drivers/amlogic/camera/hi2056.c               |   8 +
 drivers/amlogic/camera/hi253.c                |   8 +
 drivers/amlogic/camera/hi704.c                |   8 +
 drivers/amlogic/camera/hm2057.c               |  12 +
 drivers/amlogic/camera/nt99250.c              |   8 +
 drivers/amlogic/camera/nt99252.c              |   8 +
 drivers/amlogic/camera/nt99340.c              |   8 +
 drivers/amlogic/camera/ov2655.c               |   8 +
 drivers/amlogic/camera/ov3660.c               |   8 +
 drivers/amlogic/camera/ov5640.c               |  10 +
 drivers/amlogic/camera/ov5642.c               |   8 +
 drivers/amlogic/camera/ov5647.c               |   8 +
 drivers/amlogic/camera/ov7675.c               |   8 +
 drivers/amlogic/camera/sp0838.c               |  10 +-
 drivers/amlogic/camera/sp0a19.c               |   8 +
 drivers/amlogic/camera/sp2518.c               |   8 +
 drivers/amlogic/input/sensor/common.c         |   1 +
 drivers/base/dma-contiguous.c                 | 321 ++++++++++----
 drivers/staging/android/lowmemorykiller.c     |   5 +
 include/asm-generic/dma-contiguous.h          |   4 +-
 include/linux/amlogic/vmapi.h                 |   7 +
 include/linux/dma-contiguous.h                |  45 +-
 mm/page_alloc.c                               |   3 +-
 53 files changed, 1240 insertions(+), 500 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/memory.txt
 mode change 100644 => 100755 arch/arm/include/asm/dma-contiguous.h
 mode change 100644 => 100755 include/linux/dma-contiguous.h

diff --git a/Documentation/devicetree/bindings/memory.txt b/Documentation/devicetree/bindings/memory.txt
new file mode 100644
index 000000000000..42cac283ed72
--- /dev/null
+++ b/Documentation/devicetree/bindings/memory.txt
@@ -0,0 +1,101 @@
+* Memory binding
+
+The /memory node provides basic information about the address and size
+of the physical memory. This node is usually filled or updated by the
+bootloader, depending on the actual memory configuration of the given
+hardware.
+
+The memory layout is described by the folllowing node:
+
+memory {
+	reg =  <(baseaddr1) (size1)
+		(baseaddr2) (size2)
+		...
+		(baseaddrN) (sizeN)>;
+};
+
+baseaddrX:	the base address of the defined memory bank
+sizeX:		the size of the defined memory bank
+
+More than one memory bank can be defined.
+
+
+* Memory regions
+
+In /memory node one can create additional nodes describing particular
+memory regions, usually for the special usage by various device drivers.
+A good example are contiguous memory allocations or memory sharing with
+other operating system on the same hardware board. Those special memory
+regions might depend on the board configuration and devices used on the
+target system.
+
+Parameters for each memory region can be encoded into the device tree
+wit the following convention:
+
+(name): region@(base-address) {
+	reg = <(baseaddr) (size)>;
+	(linux,contiguous-region);
+	(linux,default-contiguous-region);
+};
+
+name:		an name given to the defined region.
+base-address:	the base address of the defined region.
+size:		the size of the memory region.
+linux,contiguous-region: property indicating that the defined memory
+		region is used for contiguous memory allocations,
+		Linux specific (optional)
+linux,default-contiguous-region: property indicating that the region
+		is the default region for all contiguous memory
+		allocations, Linux specific (optional)
+
+
+* Device nodes
+
+Once the regions in the /memory node are defined, they can be assigned
+to device some device nodes for their special use. The following
+properties are defined:
+
+linux,contiguous-region = <&phandle>;
+	This property indicates that the device driver should use the
+	memory region pointed by the given phandle.
+
+
+* Example:
+
+This example defines a memory consisting of 4 memory banks. 2 contiguous
+regions are defined for Linux kernel, one default of all device drivers
+(named contig_mem, placed at 0x72000000, 64MiB) and one dedicated to the
+framebuffer device (named display_mem, placed at 0x78000000, 16MiB). The
+display_mem region is then assigned to fb at 12300000 device for contiguous
+memory allocation with Linux kernel drivers.
+
+The reason for creating a separate region for framebuffer device is to
+match the framebuffer address of from configuration done by bootloader,
+so once Linux kernel drivers starts, no glitches on the displayed boot
+logo appears.
+
+/ {
+	/* ... */
+	memory {
+		reg =  <0x40000000 0x10000000
+			0x50000000 0x10000000
+			0x60000000 0x10000000
+			0x70000000 0x10000000>;
+
+		contig_mem: region at 72000000 {
+			linux,contiguous-region;
+			linux,default-contiguous-region;
+			reg = <0x72000000 0x4000000>;
+		};
+
+		display_mem: region at 78000000 {
+			linux,contiguous-region;
+			reg = <0x78000000 0x1000000>;
+		};
+	};
+
+	fb at 12300000 {
+		linux,contiguous-region = <&display_mem>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index fcedcb4aa437..6cc87881beff 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -80,6 +80,16 @@ void root_func(){
 		aml_reserved_end = <0x05000000>;/**reserved memory end */
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x40000000>;
+
+        #address-cells = <1>;
+        #size-cells = <1>;
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x02700000>;
+           linux,contiguous-region;
+        };
+
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -193,8 +203,7 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;//use for camera encoder,720P use 12M,1080P use 15M
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
@@ -255,8 +264,7 @@ void root_func(){
 		compatible = "amlogic,vm";
 		dev_name = "vm.0";
 		status = "okay";
-		reserve-memory = <0x01400000>;//camera is gc5647,the picture resolution is 2592x1944;but it need rotate funtion for MID and must be multiple for 64,so 2624X2624*3=20M
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index d075decf074e..68024ac0b985 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -80,6 +80,15 @@ void root_func(){
 		aml_reserved_end = <0x05000000>;/**reserved memory end */
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x80000000>;
+
+        #address-cells = <1>;
+        #size-cells = <1>;
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x02700000>;
+           linux,contiguous-region;
+        };
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -192,8 +201,7 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
@@ -268,8 +276,7 @@ void root_func(){
 		compatible = "amlogic,vm";
 		dev_name = "vm.0";
 		status = "okay";
-		reserve-memory = <0x01800000>;
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index 1e9821908a0f..b02567072ee9 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -80,6 +80,15 @@ void root_func(){
 		aml_reserved_end = <0x05000000>;/**reserved memory end */
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x20000000>;
+
+        #address-cells = <1>;
+        #size-cells = <1>;
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x02700000>;
+           linux,contiguous-region;
+        };
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -195,8 +204,7 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;//use for camera encoder,720P use 12M,1080P use 15M
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
@@ -257,8 +265,7 @@ void root_func(){
 		compatible = "amlogic,vm";
 		dev_name = "vm.0";
 		status = "okay";
-		reserve-memory = <0x0800000>;//camera is gc2035,the picture resolution is 1600x1200;but it need rotate funtion for MID and must be multiple for 64,so 1632*1632*3=8M
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index 01603c5b813b..75fa88d6cfc2 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -80,6 +80,15 @@ void root_func(){
 		aml_reserved_end = <0x05000000>;/**reserved memory end */
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x40000000>;
+
+        #address-cells = <1>;
+        #size-cells = <1>;
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x02700000>;
+           linux,contiguous-region;
+        };
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -194,8 +203,7 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
@@ -256,8 +264,7 @@ void root_func(){
 		compatible = "amlogic,vm";
 		dev_name = "vm.0";
 		status = "okay";
-		reserve-memory = <0x01800000>;
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
index b76a7dc79ec3..5f5cf1a8a0d4 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
@@ -76,11 +76,27 @@ void root_func(){
 //$$ L2 PROP_U32 = "aml_reserved_end"
 //$$ L2 PROP_U32 6 = "linux,usable-memory"
 	memory{
+		#address-cells = <1>;
+		#size-cells = <1>;
 		device_type = "memory";
 		aml_reserved_start = <0x06000000>; /**reserved memory start */
 		aml_reserved_end = <0x05000000>;/**reserved memory end */
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x40000000>;
+
+//$$ DEVICE="mem_4k2k_decoder"
+//$$ L3 PROP_U32 2 ="reg" 
+		mem_4k2k_decoder: region@1 {
+			region_name = "cma_4k2k";
+			linux,contiguous-region;
+			reg = <0x00000000 0x0c000000>;
+		};
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x00f00000>;
+           linux,contiguous-region;
+        };
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -164,8 +180,9 @@ void root_func(){
                 compatible = "amlogic,vdec";
                 dev_name = "vdec.0";
                 status = "okay";
-                reserve-memory = <0x10000000>;
-		reserve-iomap = "true";
+                reserve-memory = <0x04000000>;
+//		reserve-iomap = "true";
+		linux,contiguous-region = <&mem_4k2k_decoder>;
         };
 
 /// ***************************************************************************************
@@ -191,8 +208,7 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 	
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
index ab4651322b8d..8eb431c7918c 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
@@ -80,6 +80,16 @@ void root_func(){
 		aml_reserved_end = <0x05000000>;/**reserved memory end */
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x80000000>;
+
+        #address-cells = <1>;
+        #size-cells = <1>;
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x00f00000>;
+           linux,contiguous-region;
+        };
+
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -190,8 +200,7 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 	
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
index 59ae48e09527..a3783e3b3f6b 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
@@ -76,11 +76,28 @@ void root_func(){
 //$$ L2 PROP_U32 = "aml_reserved_end"
 //$$ L2 PROP_U32 6 = "linux,usable-memory"
 	memory{
+		#address-cells = <1>;
+		#size-cells = <1>;
 		device_type = "memory";
 		aml_reserved_start = <0x06000000>; /**reserved memory start */
 		aml_reserved_end = <0x05000000>;/**reserved memory end */
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x40000000>;
+
+//$$ DEVICE="mem_4k2k_decoder"
+//$$ L3 PROP_U32 2 ="reg" 
+		mem_4k2k_decoder: region@1 {
+			region_name = "cma_4k2k";
+			linux,contiguous-region;
+			reg = <0x00000000 0x0c000000>;
+		};
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x00f00000>;
+           linux,contiguous-region;
+        };
+
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -164,8 +181,9 @@ void root_func(){
                 compatible = "amlogic,vdec";
                 dev_name = "vdec.0";
                 status = "okay";
-                reserve-memory = <0x10000000>;
-		reserve-iomap = "true";
+                reserve-memory = <0x04000000>;
+//		reserve-iomap = "true";
+		linux,contiguous-region = <&mem_4k2k_decoder>;
         };
 
 /// ***************************************************************************************
@@ -191,8 +209,7 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 	
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
index 109310c0a6b7..74e2e560ed16 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
@@ -80,6 +80,15 @@ void root_func(){
 		aml_reserved_end = <0x05000000>;/**reserved memory end */
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x80000000>;
+
+        #address-cells = <1>;
+        #size-cells = <1>;
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x00f00000>;
+           linux,contiguous-region;
+        };
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -190,8 +199,7 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 	
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_skt.dtd b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
index e592ba23bf5b..a6565591ecfb 100755
--- a/arch/arm/boot/dts/amlogic/meson8_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
@@ -80,6 +80,15 @@ void root_func(){
 		aml_reserved_end = <0x05000000>;/**reserved memory end : dtb start for uboot*/
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x80000000>;
+
+        #address-cells = <1>;
+        #size-cells = <1>;
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x02700000>;
+           linux,contiguous-region;
+        };
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -190,8 +199,8 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;
-		reserve-iomap = "true";
+
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
@@ -261,8 +270,7 @@ void root_func(){
 		compatible = "amlogic,vm";
 		dev_name = "vm.0";
 		status = "okay";
-		reserve-memory = <0x01800000>;
-		reserve-iomap = "true";
+        linux,contiguous-region = <&cma_0>;
 	};
 
 /// ***************************************************************************************
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index 657b1abcceaf..7bf41fd06ded 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -351,3 +351,8 @@ CONFIG_SECURITY_NETWORK=y
 CONFIG_SECURITY_SELINUX=y
 CONFIG_CRC_T10DIF=y
 CONFIG_CRC7=y
+CONFIG_CMA=y
+CONFIG_CMA_SIZE_MBYTES=8
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
diff --git a/arch/arm/include/asm/dma-contiguous.h b/arch/arm/include/asm/dma-contiguous.h
old mode 100644
new mode 100755
index 3ed37b4d93da..63277bc1322f
--- a/arch/arm/include/asm/dma-contiguous.h
+++ b/arch/arm/include/asm/dma-contiguous.h
@@ -5,7 +5,6 @@
 #ifdef CONFIG_CMA
 
 #include <linux/types.h>
-#include <asm-generic/dma-contiguous.h>
 
 void dma_contiguous_early_fixup(phys_addr_t base, unsigned long size);
 
diff --git a/arch/arm/mach-meson8/board-meson8-common.c b/arch/arm/mach-meson8/board-meson8-common.c
index 4c9560650a0d..18819aeadfb7 100755
--- a/arch/arm/mach-meson8/board-meson8-common.c
+++ b/arch/arm/mach-meson8/board-meson8-common.c
@@ -45,6 +45,7 @@
 #include <linux/syscore_ops.h>
 #include <mach/am_regs.h>
 
+#include <linux/of_fdt.h>
 #include <linux/amlogic/vmapi.h>
 
 static void meson_map_board_io(void);
diff --git a/drivers/amlogic/amports/amstream.c b/drivers/amlogic/amports/amstream.c
index 31aec7591fdb..2df2b531df01 100755
--- a/drivers/amlogic/amports/amstream.c
+++ b/drivers/amlogic/amports/amstream.c
@@ -49,6 +49,7 @@
 #include <linux/mutex.h>
 #include <linux/poll.h>
 #include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
 #include <asm/uaccess.h>
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
@@ -107,45 +108,7 @@ void debug_file_write(const char __user *buf, size_t count)
 #define DEFAULT_VIDEO_BUFFER_SIZE       (1024*1024*3)
 #define DEFAULT_AUDIO_BUFFER_SIZE       (1024*768*2)
 #define DEFAULT_SUBTITLE_BUFFER_SIZE     (1024*256)
-#if 0
-static ulong vbuf_start;
-module_param(vbuf_start, ulong, 0644);
-MODULE_PARM_DESC(vbuf_start, "Amstreaming ports video buffer start address");
-
-static ulong vbuf_size;
-module_param(vbuf_size, ulong, 0644);
-MODULE_PARM_DESC(vbuf_size, "Amstreaming ports video buffer size");
 
-static ulong abuf_start;
-module_param(abuf_start, ulong, 0644);
-MODULE_PARM_DESC(abuf_start, "Amstreaming ports audio buffer start address");
-
-static ulong abuf_size;
-module_param(abuf_size, ulong, 0644);
-MODULE_PARM_DESC(abuf_size, "Amstreaming ports audio buffer size");
-#endif
-#if 0
-typedef struct stream_port_s {
-    /* driver info */
-    const char *name;
-    struct device *class_dev;
-    const struct file_operations *fops;
-
-    /* ports control */
-    s32 type;
-    s32 flag;
-
-    /* decoder info */
-    s32 vformat;
-    s32 aformat;
-    s32 achanl;
-    s32 asamprate;
-
-    /* parser info */
-    u32 vid;
-    u32 aid;
-} stream_port_t;
-#endif
 static int amstream_open
 (struct inode *inode, struct file *file);
 static int amstream_release
@@ -370,21 +333,26 @@ struct audio_info *get_audio_info(void) {
 }
 
 EXPORT_SYMBOL(get_audio_info);
+
 static void amstream_change_vbufsize(stream_port_t *port,struct stream_buf_s *pvbuf)
 {
-	if (pvbuf->type == BUF_TYPE_VIDEO){ 
-		if (port->vformat == VFORMAT_H264_4K2K){				
-			pvbuf->buf_size = pvbuf->default_buf_size;
-			printk(" amstream_change_vbufsize 4k2k bufsize[0x%x] defaultsize[0x%x]\n",bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size);
-		}else if((pvbuf->default_buf_size > MAX_STREAMBUFFER_SIZE)&& (port->vformat != VFORMAT_H264_4K2K)) {
-			pvbuf->buf_size = MAX_STREAMBUFFER_SIZE;
-			printk(" amstream_change_vbufsize MAX_STREAMBUFFER_SIZE-[0x%x] defaultsize-[0x%x] vformat-[%d]\n",bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size,port->vformat);
-		}else{
-		    printk(" amstream_change_vbufsize bufsize[0x%x] defaultbufsize [0x%x] \n",bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size);	
-		}
+    if (pvbuf->type == BUF_TYPE_VIDEO){ 
+        if (port->vformat == VFORMAT_H264_4K2K){				
+            pvbuf->buf_size = pvbuf->default_buf_size;
+
+            printk(" amstream_change_vbufsize 4k2k bufsize[0x%x] defaultsize[0x%x]\n",bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size);
+        }else if((pvbuf->default_buf_size > MAX_STREAMBUFFER_SIZE)&& (port->vformat != VFORMAT_H264_4K2K)) {
+            pvbuf->buf_size = MAX_STREAMBUFFER_SIZE;
+
+            printk(" amstream_change_vbufsize MAX_STREAMBUFFER_SIZE-[0x%x] defaultsize-[0x%x] vformat-[%d]\n",bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size,port->vformat);
+        } else {
+            printk(" amstream_change_vbufsize bufsize[0x%x] defaultbufsize [0x%x] \n",bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size);	
+        }
+
         reset_canuse_buferlevel(10000);
-	}
-	return;
+    }
+
+    return;
 }
 
 static  void video_port_release(stream_port_t *port, struct stream_buf_s * pbuf, int release_num)
@@ -412,7 +380,7 @@ static  int video_port_init(stream_port_t *port, struct stream_buf_s * pbuf)
         return -EPERM;
     }
 	
-	amstream_change_vbufsize(port,pbuf);
+    amstream_change_vbufsize(port,pbuf);
 
     r = stbuf_init(pbuf);
     if (r < 0) {
@@ -1315,8 +1283,8 @@ static long amstream_ioctl(struct file *file,
         	((PORT_TYPE_AUDIO | PORT_TYPE_VIDEO))) {	
         	r = -EINVAL;
         } else{
-			u64 pts;
-			memcpy(&pts,arg,sizeof(u64));
+            u64 pts;
+            memcpy(&pts,(void *)arg,sizeof(u64));
             if (this->type & PORT_TYPE_VIDEO) {
                 r = es_vpts_checkin_us64(&bufs[BUF_TYPE_VIDEO],pts);
             } else if (this->type & PORT_TYPE_AUDIO) {
@@ -1878,21 +1846,8 @@ static int  amstream_probe(struct platform_device *pdev)
 
         goto error2;
     }
-#if 0 ///changed for get resourse on vdec
-    vdec_set_resource(platform_get_resource(pdev, IORESOURCE_MEM, 0), (void *)&amstream_dec_info);
-///#else
-    res = &memobj;
-    r = find_reserve_block(pdev->dev.of_node->name,0);
-    if(r < 0){
-        printk("can not find %s%d reserve block\n",pdev->dev.of_node->name,0);
-	 r = -EFAULT;
-	 goto error2;
-    }
-    res->start = (phys_addr_t)get_reserve_block_addr(r);
-    res->end = res->start+ (phys_addr_t)get_reserve_block_size(r)-1;
-    res->flags = IORESOURCE_MEM;
-#endif	
-    vdec_set_resource(NULL, (void *)&amstream_dec_info);
+
+    vdec_set_decinfo(&amstream_dec_info);
 
     amstream_dev_class = class_create(THIS_MODULE, DEVICE_NAME);
 
diff --git a/drivers/amlogic/amports/encoder.c b/drivers/amlogic/amports/encoder.c
index afb7d8b84ba4..9d01c0141bb5 100755
--- a/drivers/amlogic/amports/encoder.c
+++ b/drivers/amlogic/amports/encoder.c
@@ -34,6 +34,7 @@
 #include <linux/poll.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
+#include <linux/dma-contiguous.h>
 
 #define ENC_CANVAS_OFFSET  AMVENC_CANVAS_INDEX
 
@@ -1309,6 +1310,10 @@ void amvenc_avc_stop(void)
 	avc_poweroff();
 	debug_level(1,"amvenc_avc_stop\n");
 }
+
+static struct platform_device *this_pdev;
+static struct page *venc_pages;
+
 static int amvenc_avc_open(struct inode *inode, struct file *file)
 {
     int r = 0;
@@ -1323,6 +1328,40 @@ static int amvenc_avc_open(struct inode *inode, struct file *file)
         amlog_level(LOG_LEVEL_ERROR, "amvenc_avc open busy.\n");
         return -EBUSY;
     }
+
+#ifdef CONFIG_CMA
+    venc_pages = dma_alloc_from_contiguous(&this_pdev->dev, (15 * SZ_1M) >> PAGE_SHIFT, 0);
+    if(venc_pages)
+    {
+        gAmvencbuff.buf_start = page_to_phys(venc_pages);
+        gAmvencbuff.buf_size = 15 * SZ_1M;
+        pr_info("%s: allocating phys %p, size %dk\n", __func__, gAmvencbuff.buf_start, gAmvencbuff.buf_size >> 10);
+    }
+    else
+    {
+        pr_err("CMA failed to allocate dma buffer for %s\n", this_pdev->name);
+        return -ENOMEM;
+    }
+
+    if(gAmvencbuff.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P].min_buffsize){
+        gAmvencbuff.cur_buf_lev = AMVENC_BUFFER_LEVEL_1080P;
+        gAmvencbuff.bufspec = (BuffInfo_t*)&amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P];
+    }else if(gAmvencbuff.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_720P].min_buffsize){
+        gAmvencbuff.cur_buf_lev = AMVENC_BUFFER_LEVEL_720P;
+        gAmvencbuff.bufspec= (BuffInfo_t*)&amvenc_buffspec[AMVENC_BUFFER_LEVEL_720P];
+    }else if(gAmvencbuff.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_480P].min_buffsize){
+        gAmvencbuff.cur_buf_lev = AMVENC_BUFFER_LEVEL_480P;
+        gAmvencbuff.bufspec= (BuffInfo_t*)&amvenc_buffspec[AMVENC_BUFFER_LEVEL_480P];
+    }else{
+        gAmvencbuff.buf_start = 0;
+        gAmvencbuff.buf_size = 0;
+        amlog_level(LOG_LEVEL_ERROR, "amvenc_avc memory resource too small, size is %d.\n",gAmvencbuff.buf_size);
+        return -EFAULT;
+    }
+    debug_level(1,"amvenc_avc  memory config sucess, buff size is 0x%x, level is %s\n",gAmvencbuff.buf_size,(gAmvencbuff.cur_buf_lev == 0)?"480P":(gAmvencbuff.cur_buf_lev == 1)?"720P":"1080P");
+
+#endif
+
     init_waitqueue_head(&avc_wait);
     atomic_set(&avc_ready, 0);
     tasklet_init(&encode_tasklet, encode_isr_tasklet, 0);
@@ -1340,6 +1379,15 @@ static int amvenc_avc_release(struct inode *inode, struct file *file)
     }
     if(encode_opened>0)
         encode_opened--;
+
+#ifdef CONFIG_CMA
+    if(venc_pages)
+    {
+        dma_release_from_contiguous(&this_pdev->dev, venc_pages, (15 * SZ_1M)>>PAGE_SHIFT); 
+        venc_pages = 0;
+    }
+#endif
+
     debug_level(1,"avc release\n");
     return 0;
 }
@@ -1578,11 +1626,8 @@ static int amvenc_avc_probe(struct platform_device *pdev)
 
     amlog_level(LOG_LEVEL_INFO, "amvenc_avc probe start.\n");
 
-#if 0
-    if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0))) {
-        amlog_level(LOG_LEVEL_ERROR, "amvenc_avc memory resource undefined.\n");
-        return -EFAULT;
-    }
+#ifdef CONFIG_CMA
+    this_pdev = pdev;
 #else
     mem = &memobj;
     idx = find_reserve_block(pdev->dev.of_node->name,0);
@@ -1592,7 +1637,6 @@ static int amvenc_avc_probe(struct platform_device *pdev)
     }
     mem->start = (phys_addr_t)get_reserve_block_addr(idx);
     mem->end = mem->start+ (phys_addr_t)get_reserve_block_size(idx)-1;
-#endif
     gAmvencbuff.buf_start = mem->start;
     gAmvencbuff.buf_size = mem->end - mem->start + 1;
 
@@ -1612,6 +1656,9 @@ static int amvenc_avc_probe(struct platform_device *pdev)
         return -EFAULT;
     }
     debug_level(1,"amvenc_avc  memory config sucess, buff size is 0x%x, level is %s\n",gAmvencbuff.buf_size,(gAmvencbuff.cur_buf_lev == 0)?"480P":(gAmvencbuff.cur_buf_lev == 1)?"720P":"1080P");
+
+#endif
+
     init_avc_device();
     amlog_level(LOG_LEVEL_INFO, "amvenc_avc probe end.\n");
     return 0;
diff --git a/drivers/amlogic/amports/m8/ucode/h264_4k2k/h264c_linux.h b/drivers/amlogic/amports/m8/ucode/h264_4k2k/h264c_linux.h
index 5044a39a956b..684db611b1bb 100755
--- a/drivers/amlogic/amports/m8/ucode/h264_4k2k/h264c_linux.h
+++ b/drivers/amlogic/amports/m8/ucode/h264_4k2k/h264c_linux.h
@@ -4,7 +4,7 @@ const u32 MicroCode[] __attribute__ ((aligned (8))) = {
 	0xc7ffd00,0xa60c141,0xc781b80,0x0800000,0xa608181,0xc7ffbc0,0xa6081c1,0xc7838c0,
 	0xc7ffb00,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
 	0xc781e40,0x0000000,0xcc00000,0x0400000,0xcb80003,0x0000000,0xcc00000,0x0400000,
-	0xc7a44c0,0x0000000,0xcc00000,0x0400000,0xcc00000,0x0400000,0xc7a4340,0x0000000,
+	0xc7a4440,0x0000000,0xcc00000,0x0400000,0xcc00000,0x0400000,0xc7a42c0,0x0000000,
 	0xc781ac0,0x0000000,0xcc00000,0x0400000,0x6800000,0x6800001,0x7400040,0xb2fc7c1,
 	0x4001041,0x7c01b80,0x7c01bc0,0x7c01c00,0x7c00c40,0x7c00c80,0x68002c0,0x7c00700,
 	0x7c006c0,0x6803fc0,0x7c01300,0x69fffc0,0x7c02140,0x7c00280,0x64c4000,0x64c4201,
diff --git a/drivers/amlogic/amports/m8/ucode/h264_4k2k/h264slice_linux.h b/drivers/amlogic/amports/m8/ucode/h264_4k2k/h264slice_linux.h
index 762054af6849..9d8bb1b88142 100755
--- a/drivers/amlogic/amports/m8/ucode/h264_4k2k/h264slice_linux.h
+++ b/drivers/amlogic/amports/m8/ucode/h264_4k2k/h264slice_linux.h
@@ -8,211 +8,211 @@ const u32 MicroCode[] __attribute__ ((aligned (8))) = {
 	0x6800016,0xc001300,0x0000000,0x6800008,0x60c2108,0xc001b40,0x0000000,0x80c0001,
 	0x8030504,0xc7ef2c0,0x0400000,0x6bfd98a,0x603040a,0x0400000,0x64c430a,0x580128a,
 	0xbaf980a,0x64c0008,0xbe3c048,0x0000000,0x0800000,0x6bffe8a,0x603040a,0xcc00000,
-	0x0400000,0xc780000,0xc780000,0xc780000,0x0000000,0xbef9008,0x0000000,0xc78c480,
+	0x0400000,0xc780000,0xc780000,0xc780000,0x0000000,0xbef9008,0x0000000,0xc78c400,
 	0x680000a,0xaa4c048,0xbeed208,0x683ffcb,0xaadc00b,0x44012cb,0x64e0f08,0x9003248,
 	0x9063288,0xb40324a,0x240a24a,0x400828a,0xba180ca,0xaedc0ca,0x80c3e00,0x64c3f08,
 	0x9002208,0xa6cc0c8,0xcb80024,0x0000000,0x649cd0a,0xa21a00a,0x67f290a,0xa21004a,
-	0x69fffca,0xc78be80,0x7c0214a,0x680000a,0x7802048,0xaa18008,0xaa0c011,0x0000000,
-	0x680004a,0xc78bc80,0x0000000,0x7800b08,0xaa14388,0x7801688,0xaa08088,0xc784b00,
-	0xc7880c0,0xaa08088,0xc783440,0xc787240,0x0000000,0x649c908,0x4001208,0x609c908,
+	0x69fffca,0xc78be00,0x7c0214a,0x680000a,0x7802048,0xaa18008,0xaa0c011,0x0000000,
+	0x680004a,0xc78bc00,0x0000000,0x7800b08,0xaa14388,0x7801688,0xaa08088,0xc784a80,
+	0xc788040,0xaa08088,0xc7833c0,0xc7871c0,0x0000000,0x649c908,0x4001208,0x609c908,
 	0x6800015,0x7c020d5,0x7c02115,0x7c02155,0x7c02195,0x7c021d5,0x6803fc8,0x7c02248,
 	0x6800008,0x7c02308,0x7c02388,0x7c023c8,0x7c02408,0x7c02448,0x7802588,0x4001208,
 	0x7c025c8,0x6800048,0x60e0c08,0x7c02788,0x7c02608,0x6800008,0x7c027c8,0x68003c8,
-	0x7c02648,0x6805c08,0x60c2108,0x80c2170,0x6800088,0x7c02708,0xc016980,0x0000000,
+	0x7c02648,0x6805c08,0x60c2108,0x80c2170,0x6800088,0x7c02708,0xc016b00,0x0000000,
 	0xcc00000,0x0000000,0x78027cb,0xa6fc00b,0x0000000,0x6a0002b,0x6c007ab,0x690002a,
-	0x649cd08,0xbe1a008,0x6c007aa,0x6a0002b,0x6c00eeb,0x680002a,0x6c00eea,0xc0169c0,
-	0x0000000,0xc016ec0,0x0000000,0x6900009,0x649cd08,0xbe12008,0x6c000c9,0x6800009,
-	0x6c00809,0x7801688,0x649ce0a,0x2009289,0x5c0c289,0x6819de4,0xaa18088,0x6800009,
-	0x6816764,0xaa0c148,0x6800049,0x6800089,0x7c02549,0x7801748,0x94c2248,0x60c0409,
-	0x7c0268a,0x6800008,0x7c02748,0x7800a8b,0x7800ac8,0xa630008,0x780174a,0xaa280ca,
-	0x54012cb,0x58012cb,0x6490708,0x9808088,0x98080c8,0x6090708,0x6495108,0x98083c8,
-	0x6095108,0x7c026cb,0x7800b08,0x944220a,0x7c00b08,0xa640388,0x68000ca,0x6495108,
-	0x940420a,0x9808648,0x6095108,0x6490708,0x9808448,0x6090708,0x6498e08,0x9808788,
-	0x6098e08,0x7801688,0xaa0c088,0x6818de4,0x6814f64,0xc00c340,0x0000000,0x7800d48,
-	0xa610008,0x7801a08,0xc780b00,0x60c0a08,0xfc07200,0x80c2940,0x7801a08,0x9808188,
-	0x98083c8,0x60c0a08,0x9c083c8,0x9808388,0xc00c500,0x60c0a08,0x7802549,0x64c0a08,
-	0x91c2208,0xa6f8008,0x780285b,0x6c0001b,0x680001c,0x6c0001c,0x680001d,0x6c0001d,
-	0x680001e,0x6c0001e,0x6bfffdf,0xa628009,0x7800b08,0x680030a,0xaa18388,0x7c0280a,
-	0x680018a,0x7c0280a,0xcc00000,0x60c0715,0xcc00000,0x680030a,0xaa18388,0x7c0280a,
-	0x680018a,0x7c0280a,0xcc00000,0x60c0715,0xcc00000,0x0000000,0xc00bc80,0x80c0600,
+	0x649cd08,0xbe1a008,0x6c007aa,0x6a0002b,0x6c00eeb,0x680002a,0x6c00eea,0xc016b40,
+	0x0000000,0xc017040,0x0000000,0x6900009,0x649cd08,0xbe12008,0x6c000c9,0x6800009,
+	0x6c00809,0x7801688,0x5c0c289,0x6819d64,0xaa18088,0x6800009,0x68166e4,0xaa0c148,
+	0x6800049,0x6800089,0x7c02549,0x7801748,0x94c2248,0x60c0409,0x7c0268a,0x6800008,
+	0x7c02748,0x7800a8b,0x7800ac8,0xa630008,0x780174a,0xaa280ca,0x54012cb,0x58012cb,
+	0x6490708,0x9808088,0x98080c8,0x6090708,0x6495108,0x98083c8,0x6095108,0x7c026cb,
+	0x7800b08,0x944220a,0x7c00b08,0xa640388,0x68000ca,0x6495108,0x940420a,0x9808648,
+	0x6095108,0x6490708,0x9808448,0x6090708,0x6498e08,0x9808788,0x6098e08,0x7801688,
+	0xaa0c088,0x6818d64,0x6814ee4,0xc00c340,0x0000000,0x7800d48,0xa610008,0x7801a08,
+	0xc780b00,0x60c0a08,0xfc07200,0x80c2940,0x7801a08,0x9808188,0x98083c8,0x60c0a08,
+	0x9c083c8,0x9808388,0xc00c500,0x60c0a08,0x7802549,0x64c0a08,0x91c2208,0xa6f8008,
 	0x780285b,0x6c0001b,0x680001c,0x6c0001c,0x680001d,0x6c0001d,0x680001e,0x6c0001e,
-	0x6bfffdf,0x7802549,0xa628009,0x7800b08,0x680030a,0xaa18388,0x7c0280a,0x680018a,
-	0x7c0280a,0xcc00000,0x60c0715,0xcc00000,0x680030a,0xaa18388,0x7c0280a,0x680018a,
-	0x7c0280a,0xcc00000,0x60c0715,0xcc00000,0x0000000,0x64c031b,0x64c031c,0x64c031d,
-	0x64c031e,0x64c271f,0xa224055,0x7802888,0x7c028c8,0x4000817,0x4000858,0x4000899,
-	0x40008da,0xc781400,0x60c0715,0x683ffc8,0x4401208,0xaa0c008,0x78027cb,0xa6f400b,
-	0x68000cb,0x7802908,0x95102c8,0x78020c8,0x97082c8,0x6031e0b,0xaa08008,0xc780b00,
-	0x80c0700,0x7802849,0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,0x6800009,
-	0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,0x6bfffca,0x60c0320,0x60c0321,
-	0x60c0322,0x60c0323,0x78028c9,0x961024a,0x60c2709,0x80c0701,0x7802849,0x6c00009,
-	0x60c0209,0x6800009,0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,0x6800009,
-	0x6c00009,0x60c0209,0x60c0317,0x60c0318,0x60c0319,0x60c031a,0x780288b,0x96102ca,
-	0x60c270b,0xc780580,0x60c0715,0x64c270a,0x921028a,0x60c0320,0x60c0321,0x60c0322,
-	0x60c0323,0x78028c9,0x961024a,0x60c2709,0x80c0701,0x64c270a,0x921028a,0x60c0317,
-	0x60c0318,0x60c0319,0x60c031a,0x7802889,0x961024a,0x60c2709,0x60c0715,0x6431e0a,
-	0xbefc04a,0x7802a08,0x4c30208,0xc780b40,0x60c2508,0x64c031b,0x64c031c,0x64c031d,
-	0x64c031e,0x64c271f,0x60c0715,0x921029f,0x78020c8,0xa638008,0x7802849,0x6c00009,
-	0x60c0209,0x6800009,0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,0x6800009,
-	0x6c00009,0x60c0209,0x6bfffca,0x60c0317,0x60c0318,0x60c0319,0x60c031a,0x7802889,
-	0x961024a,0x60c2709,0x7802a08,0x4c30208,0x60c2508,0x683ffca,0x78027cb,0xaa0c00b,
-	0xa6f800a,0x440128a,0x68000cb,0x780290a,0x95102ca,0x78020ca,0x97082ca,0x6031e0b,
-	0x7802a4c,0x7802648,0x7c02988,0x64c2308,0x9304248,0xa6f8009,0x90a1248,0x9024208,
-	0x9521209,0xaa0c00c,0x7c02648,0xc781640,0xaa6002c,0xa65c008,0xa62406c,0x64c200a,
-	0x91942ca,0xba4c20b,0x44022cb,0x959428b,0x60c060a,0xc7803c0,0x68000ac,0xa6240ac,
-	0x64c060a,0x91832ca,0xae2814b,0x40022cb,0x958328b,0x60c060a,0xc780180,0x68000ec,
-	0x900f2ca,0xae0c04b,0xc780080,0x680006c,0xaa64248,0x60c2508,0xaa64288,0xaa58348,
-	0xaa1c049,0xaa58388,0xa60c008,0xc7801c0,0x0000000,0x80c2605,0x80c2606,0x80c2602,
-	0x80c260f,0x80c2603,0x7802709,0xaa100c9,0x680008a,0xc782940,0x7c0270a,0x78027cc,
-	0xa6fc00c,0x0000000,0x7c02749,0xc7827c0,0x7c0270a,0x80c2602,0x80c260f,0x80c2603,
-	0x7802709,0xaa50089,0x68000ca,0x78020c9,0xaa0c009,0xc782540,0x7c0270a,0xaa08725,
-	0xbef4055,0x683ffcc,0x7802789,0x64e0c0a,0x901028a,0xb804289,0xaa0c00c,0xc7ffec0,
-	0x440130c,0x6800089,0x68000ca,0x680180c,0x60c210c,0x683ffcd,0xaa2c00d,0x64e110c,
-	0x910130c,0xa6f400c,0x440134d,0x64e110c,0x910130c,0xa6e400c,0x78027cc,0xa6dc00c,
-	0x0000000,0x7c02749,0xc781e00,0x7c0270a,0x6800008,0x7c02648,0x60c2508,0x6431e08,
-	0xbefc048,0x68fdfc8,0x6fcffc8,0x64e0407,0x2807207,0xc7ff140,0x60e0408,0x64c031b,
-	0x64c031c,0x64c271f,0xa228055,0x7802888,0x7c028c8,0x4000817,0x4000858,0x60c0715,
-	0x7802a08,0x4c30208,0xc781500,0x60c2508,0x78020c8,0xa658008,0x80c0700,0x7802849,
-	0x6c00009,0x60c0209,0x80c0200,0x6bfffca,0x60c0320,0x60c0321,0x78028cb,0x96102ca,
-	0x60c270b,0x80c0701,0x60c0209,0x80c0200,0x60c0317,0x60c0318,0x780288b,0x96102ca,
-	0x60c270b,0xc780480,0x60c0715,0x64c270a,0x921028a,0x60c0320,0x60c0321,0x78028c9,
-	0x961024a,0x60c2709,0x80c0701,0x64c270a,0x921028a,0x60c0317,0x60c0318,0x7802889,
-	0x961024a,0x60c2709,0x60c0715,0x7802a08,0x4c30208,0x60c2508,0x78027cb,0xa6fc00b,
-	0x68000cb,0x780290a,0x95102ca,0x78020ca,0x97082ca,0xc780840,0x6031e0b,0x64c031b,
-	0x64c031c,0x64c271f,0x60c0715,0x921029f,0x78020c8,0xa618008,0x7802849,0x6c00009,
-	0x60c0209,0x80c0200,0x6bfffca,0x60c0317,0x60c0318,0x7802889,0x961024a,0x60c2709,
-	0x7802a08,0x4c30208,0x60c2508,0x683ffca,0x440128a,0xaa0c00a,0x78027cb,0xa6f400b,
-	0x68000cb,0x780290a,0x95102ca,0x78020ca,0x97082ca,0x6031e0b,0x7802648,0x7c02988,
-	0x64c2308,0x9304248,0xa6f8009,0x9024208,0x7c02648,0xaa10288,0x60c2508,0x80c2602,
-	0x80c260f,0x80c2603,0x4c00208,0x9808208,0x60c2108,0x7802308,0xaa14008,0x6a01009,
-	0xaa0c048,0x6a22009,0x6a40009,0x6431e0a,0xbefc04a,0x6c00109,0x7800b0a,0xa66838a,
-	0xa264055,0x780298b,0xaa1c00b,0x780274b,0x0800000,0x780278a,0x400128a,0x7c0278a,
-	0x0400000,0xb61408b,0x0000000,0x80c2170,0xc780880,0x80c260e,0x683ffcb,0x44012cb,
-	0xaa0c00b,0x78027ca,0xa6f400a,0x780278a,0x440128a,0xc009680,0x7c0278a,0xc7805c0,
-	0x8030580,0x78027ca,0xa6fc00a,0x0000000,0x60e0509,0x7802749,0x680180a,0x9502289,
-	0x60c210a,0x80c260e,0x6800089,0x7c02348,0xba0c088,0x4001208,0x6800008,0x7c02308,
-	0x78020c8,0x7c02208,0x7802988,0x7c029c8,0x7c027c9,0x8030580,0x7802908,0xaa14725,
-	0x4001208,0x7802109,0xa20c049,0x0000000,0x7c02908,0x683ffc9,0x64c2308,0x9304208,
-	0xaa2c008,0x0000000,0x80c3e01,0x64c3f08,0x93e1208,0xaae4008,0xb6e0049,0x4401249,
-	0x6bfffc9,0xc7f5680,0x7c02a89,0x64c2b08,0x60c2b08,0x780224e,0xba13fce,0x6800009,
-	0xc7810c0,0x7c02249,0x6808009,0xba1070e,0x400028e,0x441c28a,0x680c009,0x54032ca,
-	0x200b28b,0x20092c9,0x740025f,0x4001249,0x921031b,0x740024c,0x4001249,0x740025b,
-	0x4001249,0x740025c,0x4001249,0x921031c,0x740024c,0x4001249,0x740025d,0x4001249,
-	0x921031d,0x740024c,0x4001249,0x740025e,0x4001249,0x921031e,0x740024c,0x7800a49,
-	0xac07949,0x78020cb,0xaa38725,0x400030b,0x780210b,0xc7802c0,0x942f2cc,0xa61000b,
-	0xaa14725,0x780210b,0xa20c04b,0xa6146ca,0x40012ce,0xb60c70e,0x680000b,0x680070b,
-	0x7c0224b,0xb012949,0xaa0800b,0xa64070b,0x780228b,0xa20c04b,0x6a0800c,0x6a0c00c,
-	0x649ce0b,0x200a2ea,0x78022cd,0x54092cd,0x200b28b,0x603510b,0x6803f0b,0x603520b,
-	0x603500c,0xc007340,0x0000000,0x7800b08,0xa610388,0x78020c8,0xc780e40,0x0000000,
-	0x4001208,0x7c020c8,0x7802149,0x4001249,0x7c02149,0x7800a49,0xb84a248,0x6800008,
-	0x7c020c8,0xc002c40,0x0000000,0x7802109,0xae0c049,0x4401249,0x6800009,0x649cd0a,
-	0xa21a00a,0x0000000,0x67f410a,0x954a289,0xc780140,0x63f410a,0x67f400a,0x954a289,
-	0x63f400a,0x7802109,0x4001249,0x78026ca,0xb404289,0x7c02109,0xc780c80,0x0000000,
-	0x680004a,0xc002240,0x0000000,0xc0655c0,0x0000000,0xaa3800a,0x649cd0a,0xa21e00a,
-	0x67f290a,0x83f4100,0x68000c9,0x97c2289,0xc7801c0,0x63f290a,0x83f4000,0x67f2a0a,
-	0x68000c9,0x97c2289,0x63f2a0a,0x8032100,0x809ca01,0xc7f33c0,0x6802ac3,0x7802109,
-	0xbe10049,0x4001209,0xc780580,0x7c02108,0x4401209,0x7c02108,0x78020c8,0x4001208,
-	0x7c020c8,0x7802149,0x4001249,0x7c02149,0x7800a49,0xb80b248,0x6800008,0x7c020c8,
-	0x7802109,0x4002249,0x78026ca,0xb805289,0x7c02109,0x6800008,0xc7ff480,0x7c02148,
-	0x64c3b08,0x920c208,0xb20ca08,0x680204b,0x7c02a4b,0x78020c8,0x9508548,0x780210a,
-	0x940854a,0x7800a4a,0xb01494a,0x6808009,0xa628725,0xc780a40,0x0000000,0x780210b,
-	0xa20c04b,0x50012cb,0x4001208,0x5401208,0xc780a40,0x940120b,0x4001208,0xa418288,
-	0x780224a,0x7802108,0xa27c048,0x400220a,0xc780380,0x6800008,0xaa7c725,0x780210b,
-	0xa2bc04b,0x40012c8,0xa4ed28b,0xc780680,0x6800008,0xaa14725,0x6800008,0x7802108,
-	0x5001208,0x4801208,0xb60c70a,0x6808009,0x680c009,0xc780400,0x0000000,0xa628048,
-	0x400220a,0x7802108,0xbe1c048,0x400220a,0xc7ffd80,0x6800048,0xaabc008,0x780224a,
-	0x400120a,0xba10708,0xb6ace08,0x680c009,0x441c208,0x5403288,0x200a20a,0x2009289,
-	0x700024a,0x7c0288a,0x4001249,0x700024a,0x4001249,0x7000257,0x96105ca,0x4001249,
-	0x7000258,0x4001249,0x700024a,0x961060a,0x4001249,0x7000259,0x4001249,0x700024a,
-	0x961064a,0x4001249,0x700025a,0x4001249,0x700024a,0x961068a,0x6bfda8a,0x603040a,
-	0xcc00000,0x0400000,0x78027c8,0xa6fc008,0x0000000,0x64c0008,0xa2f0048,0x64c3d08,
-	0x580a208,0xbef80c8,0x6a00008,0x60c3d08,0x64c3d08,0x580a208,0xbef80c8,0x0000000,
-	0xcc00000,0x0000000,0x7801688,0xaa0c188,0xcc00000,0x0000000,0x649cd08,0xa20e008,
-	0xc7800c0,0x67f4008,0x67f4108,0x93e1248,0xaae0009,0x9288248,0x7801a4a,0xa4f5289,
-	0x914a208,0x7802589,0xb60c689,0x6800049,0x6800109,0xb4ef248,0xc7ffc00,0x0000000,
-	0x7801608,0xaa18008,0x7801688,0xa614088,0x0000000,0x8098002,0x80980f0,0xc780a80,
-	0x80c2400,0x64c2208,0x9305248,0x93a22c8,0x9205288,0x92a2308,0x540230c,0x2c0b30b,
-	0x9105388,0x91a2308,0x540430c,0x2c0b30b,0x90053c8,0x90a2308,0x540630c,0x2c0b30b,
-	0x7801688,0xa63c188,0x80c2408,0x64c2208,0x480330b,0xaa340cc,0x0000000,0x480f2cb,
-	0x9305388,0x93a2308,0x540430c,0x2c0b30b,0x92053c8,0x92a2308,0x540630c,0x2c0b30b,
-	0xc780280,0x0000000,0x48032cb,0x9305288,0x93a2308,0x540230c,0x2c0b30b,0xc7800c0,
-	0x0000000,0xc780600,0x5418249,0x609b309,0x649b309,0x541828a,0x609b30a,0x649b30a,
-	0x541838e,0x609b30e,0x649b30e,0x54183cf,0x609b30f,0x649b30f,0x8098002,0x6bfffcc,
-	0x541030c,0x6bfffcd,0x2c0d30d,0x609820d,0x480330b,0xa6540cc,0x0000000,0xc7800c0,
-	0x0000000,0xc7806c0,0x5410309,0x581030c,0x5410349,0x2c0d30d,0x609810d,0x540430b,
-	0x609800c,0xa813289,0x0000000,0x541030a,0x581030c,0x541034a,0x2c0d30d,0x609820d,
-	0xc780300,0x0000000,0x5410309,0x581030c,0x541034a,0x2c0d30d,0x609810d,0x540430b,
-	0x4c0430c,0x609800c,0xc7800c0,0x0000000,0xc780380,0x480330b,0x541830c,0x2c0c24c,
-	0x483034b,0x541434d,0x2c0d38d,0xa80734c,0x0000000,0x541030e,0x581030c,0x541034f,
-	0x2c0d30d,0x609820d,0x7800b0c,0xa60c38c,0x6800725,0x5801965,0x6bfffcc,0x680001b,
-	0x7802857,0x6800018,0x680001c,0x6800019,0x680001d,0x680001a,0x680001e,0x4000817,
-	0x4000858,0x4000899,0x40008da,0x680800b,0x680070f,0x74002cc,0x40012cb,0x74002db,
-	0x40012cb,0x74002d7,0x40012cb,0x74002d8,0x40012cb,0x74002dc,0x40012cb,0x74002d9,
-	0x40012cb,0x74002dd,0x40012cb,0x74002da,0x40012cb,0x74002de,0xd07fbcf,0x40012cb,
-	0x7c0288c,0x7c028cc,0x961030c,0x80c0700,0x60c270c,0x96105db,0x60c0217,0x961061c,
-	0x780254f,0xaa1800f,0x60c0218,0x961065d,0x60c0219,0x961069e,0x60c021a,0x80c0701,
-	0x60c270c,0x60c0217,0xaa1000f,0x60c0218,0x60c0219,0x60c021a,0x7800a4f,0xb00894f,
-	0x649ce09,0x200826a,0x6035108,0x6803f08,0x6035208,0x6a08008,0x6035008,0x78020c8,
-	0xa60c008,0x6803fc8,0x7c02248,0x6800008,0x7c02908,0xac0b94f,0x7802248,0xb613fc8,
-	0xba0c708,0x441c208,0x7c02248,0x6435008,0x580f208,0xbef8048,0xcc00000,0x0000000,
-	0x6435008,0x580f208,0xbef8048,0x0000000,0x6435308,0x900c208,0xa6f8008,0x0000000,
-	0x649ce09,0x200826a,0x6035108,0x6803f08,0x6035208,0x6b0c008,0x6035008,0x5401225,
-	0xac0520f,0x6800088,0x7c02288,0xc7ff8c0,0x7c022c8,0x681000a,0x20092aa,0x649ce0a,
-	0x2009289,0x54012a5,0x200a94a,0x680008b,0x7c0228b,0x68000cb,0x6435008,0x580f208,
-	0xbef8048,0x6803f08,0x6035109,0x6035208,0x6a08008,0x6035008,0xac0328f,0xc7ff3c0,
-	0x7c022cb,0x6808008,0x2009209,0x200a94a,0xc7ffc80,0x40012cb,0x400134d,0x480f34d,
-	0x7c022cd,0x980c38c,0x780228d,0x54092cd,0x200ba8b,0x649ce0a,0x200b28b,0x400134d,
-	0x480f34d,0x7c0228d,0x643500d,0x580f34d,0xbef804d,0x0000000,0x643530d,0x900c34d,
-	0xa6f800d,0x0000000,0x603510b,0x6803f0b,0x603520b,0xc7fed80,0x603500c,0x780230c,
-	0xa60c00c,0x440120c,0x6800088,0xaa14008,0x6a01009,0xaa0c048,0x6a22009,0x6a40009,
-	0x6c00109,0x60e0509,0x7c02348,0x7802749,0x680180a,0x9502289,0x60c210a,0x80c260e,
-	0x680004a,0x7c0294a,0x78020c9,0x7c02209,0x7802989,0x7c029c9,0x6800089,0xcc00000,
-	0x7c027c9,0xcc00000,0x0400000,0x64e1226,0x91e19a6,0xbef0066,0x78027e6,0xaa480a6,
-	0xc782b40,0x6800027,0x6c04027,0x7802969,0x97c19e9,0x60e1227,0x7802127,0xa210067,
-	0x40005ab,0x6900016,0x2016ad6,0x649ce26,0x2016996,0x6800026,0x7c02766,0xc7824c0,
-	0x6800126,0x7802767,0xaa080a7,0xc7812c0,0x78025e8,0xaeb00a8,0x7802969,0xaa50725,
-	0x7802226,0x54069a6,0x7802128,0x5801a28,0xbe10068,0x40009eb,0x6900027,0x2027ae7,
-	0x649ce28,0x2027a27,0x20269e6,0x44409a6,0x60e1326,0xaa48029,0x40c05a6,0x6805c28,
-	0x60c2128,0xc780380,0x4040596,0x54059a6,0x7802128,0xbe10068,0x40009eb,0x6900027,
-	0x2027ae7,0x649ce28,0x2027a27,0x20269e6,0x44209a6,0x60e1326,0x40605a6,0x7802368,
-	0xaa14028,0x6a2c227,0xaa0c068,0x6a2c027,0x6a2c127,0xaa10029,0x6c04027,0x68003e6,
-	0x95069e6,0x97c19e9,0x60e1227,0x6800026,0x7c02766,0x6800126,0xc781cc0,0x7c027e6,
-	0x78023a7,0x78023e8,0x96109e8,0x7802828,0x2427a27,0x2427a27,0x7802969,0xaa0c029,
-	0x2427a27,0x2427a27,0x78026a6,0x54099a6,0x20269e6,0x54039e6,0x60e1327,0x7802368,
+	0x6bfffdf,0xa628009,0x7800b08,0x680030a,0xaa18388,0x7c0280a,0x680018a,0x7c0280a,
+	0xcc00000,0x60c0715,0xcc00000,0x680030a,0xaa18388,0x7c0280a,0x680018a,0x7c0280a,
+	0xcc00000,0x60c0715,0xcc00000,0x0000000,0xc00bc80,0x80c0600,0x780285b,0x6c0001b,
+	0x680001c,0x6c0001c,0x680001d,0x6c0001d,0x680001e,0x6c0001e,0x6bfffdf,0x7802549,
+	0xa628009,0x7800b08,0x680030a,0xaa18388,0x7c0280a,0x680018a,0x7c0280a,0xcc00000,
+	0x60c0715,0xcc00000,0x680030a,0xaa18388,0x7c0280a,0x680018a,0x7c0280a,0xcc00000,
+	0x60c0715,0xcc00000,0x0000000,0x64c031b,0x64c031c,0x64c031d,0x64c031e,0x64c271f,
+	0xa224055,0x7802888,0x7c028c8,0x4000817,0x4000858,0x4000899,0x40008da,0xc781400,
+	0x60c0715,0x683ffc8,0x4401208,0xaa0c008,0x78027cb,0xa6f400b,0x68000cb,0x7802908,
+	0x95102c8,0x78020c8,0x97082c8,0x6031e0b,0xaa08008,0xc780b00,0x80c0700,0x7802849,
+	0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,
+	0x6800009,0x6c00009,0x60c0209,0x6bfffca,0x60c0320,0x60c0321,0x60c0322,0x60c0323,
+	0x78028c9,0x961024a,0x60c2709,0x80c0701,0x7802849,0x6c00009,0x60c0209,0x6800009,
+	0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,
+	0x60c0317,0x60c0318,0x60c0319,0x60c031a,0x780288b,0x96102ca,0x60c270b,0xc780580,
+	0x60c0715,0x64c270a,0x921028a,0x60c0320,0x60c0321,0x60c0322,0x60c0323,0x78028c9,
+	0x961024a,0x60c2709,0x80c0701,0x64c270a,0x921028a,0x60c0317,0x60c0318,0x60c0319,
+	0x60c031a,0x7802889,0x961024a,0x60c2709,0x60c0715,0x6431e0a,0xbefc04a,0x7802a08,
+	0x4c30208,0xc780b40,0x60c2508,0x64c031b,0x64c031c,0x64c031d,0x64c031e,0x64c271f,
+	0x60c0715,0x921029f,0x78020c8,0xa638008,0x7802849,0x6c00009,0x60c0209,0x6800009,
+	0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,0x6800009,0x6c00009,0x60c0209,
+	0x6bfffca,0x60c0317,0x60c0318,0x60c0319,0x60c031a,0x7802889,0x961024a,0x60c2709,
+	0x7802a08,0x4c30208,0x60c2508,0x683ffca,0x78027cb,0xaa0c00b,0xa6f800a,0x440128a,
+	0x68000cb,0x780290a,0x95102ca,0x78020ca,0x97082ca,0x6031e0b,0x7802a4c,0x7802648,
+	0x7c02988,0x64c2308,0x9304248,0xa6f8009,0x90a1248,0x9024208,0x9521209,0xaa0c00c,
+	0x7c02648,0xc781640,0xaa6002c,0xa65c008,0xa62406c,0x64c200a,0x91942ca,0xba4c20b,
+	0x44022cb,0x959428b,0x60c060a,0xc7803c0,0x68000ac,0xa6240ac,0x64c060a,0x91832ca,
+	0xae2814b,0x40022cb,0x958328b,0x60c060a,0xc780180,0x68000ec,0x900f2ca,0xae0c04b,
+	0xc780080,0x680006c,0xaa64248,0x60c2508,0xaa64288,0xaa58348,0xaa1c049,0xaa58388,
+	0xa60c008,0xc7801c0,0x0000000,0x80c2605,0x80c2606,0x80c2602,0x80c260f,0x80c2603,
+	0x7802709,0xaa100c9,0x680008a,0xc782940,0x7c0270a,0x78027cc,0xa6fc00c,0x0000000,
+	0x7c02749,0xc7827c0,0x7c0270a,0x80c2602,0x80c260f,0x80c2603,0x7802709,0xaa50089,
+	0x68000ca,0x78020c9,0xaa0c009,0xc782540,0x7c0270a,0xaa08725,0xbef4055,0x683ffcc,
+	0x7802789,0x64e0c0a,0x901028a,0xb804289,0xaa0c00c,0xc7ffec0,0x440130c,0x6800089,
+	0x68000ca,0x680180c,0x60c210c,0x683ffcd,0xaa2c00d,0x64e110c,0x910130c,0xa6f400c,
+	0x440134d,0x64e110c,0x910130c,0xa6e400c,0x78027cc,0xa6dc00c,0x0000000,0x7c02749,
+	0xc781e00,0x7c0270a,0x6800008,0x7c02648,0x60c2508,0x6431e08,0xbefc048,0x68fdfc8,
+	0x6fcffc8,0x64e0407,0x2807207,0xc7ff140,0x60e0408,0x64c031b,0x64c031c,0x64c271f,
+	0xa228055,0x7802888,0x7c028c8,0x4000817,0x4000858,0x60c0715,0x7802a08,0x4c30208,
+	0xc781500,0x60c2508,0x78020c8,0xa658008,0x80c0700,0x7802849,0x6c00009,0x60c0209,
+	0x80c0200,0x6bfffca,0x60c0320,0x60c0321,0x78028cb,0x96102ca,0x60c270b,0x80c0701,
+	0x60c0209,0x80c0200,0x60c0317,0x60c0318,0x780288b,0x96102ca,0x60c270b,0xc780480,
+	0x60c0715,0x64c270a,0x921028a,0x60c0320,0x60c0321,0x78028c9,0x961024a,0x60c2709,
+	0x80c0701,0x64c270a,0x921028a,0x60c0317,0x60c0318,0x7802889,0x961024a,0x60c2709,
+	0x60c0715,0x7802a08,0x4c30208,0x60c2508,0x78027cb,0xa6fc00b,0x68000cb,0x780290a,
+	0x95102ca,0x78020ca,0x97082ca,0xc780840,0x6031e0b,0x64c031b,0x64c031c,0x64c271f,
+	0x60c0715,0x921029f,0x78020c8,0xa618008,0x7802849,0x6c00009,0x60c0209,0x80c0200,
+	0x6bfffca,0x60c0317,0x60c0318,0x7802889,0x961024a,0x60c2709,0x7802a08,0x4c30208,
+	0x60c2508,0x683ffca,0x440128a,0xaa0c00a,0x78027cb,0xa6f400b,0x68000cb,0x780290a,
+	0x95102ca,0x78020ca,0x97082ca,0x6031e0b,0x7802648,0x7c02988,0x64c2308,0x9304248,
+	0xa6f8009,0x9024208,0x7c02648,0xaa10288,0x60c2508,0x80c2602,0x80c260f,0x80c2603,
+	0x4c00208,0x9808208,0x60c2108,0x7802308,0xaa14008,0x6a01009,0xaa0c048,0x6a22009,
+	0x6a40009,0x6431e0a,0xbefc04a,0x6c00109,0x7800b0a,0xa66838a,0xa264055,0x780298b,
+	0xaa1c00b,0x780274b,0x0800000,0x780278a,0x400128a,0x7c0278a,0x0400000,0xb61408b,
+	0x0000000,0x80c2170,0xc780880,0x80c260e,0x683ffcb,0x44012cb,0xaa0c00b,0x78027ca,
+	0xa6f400a,0x780278a,0x440128a,0xc009680,0x7c0278a,0xc7805c0,0x8030580,0x78027ca,
+	0xa6fc00a,0x0000000,0x60e0509,0x7802749,0x680180a,0x9502289,0x60c210a,0x80c260e,
+	0x6800089,0x7c02348,0xba0c088,0x4001208,0x6800008,0x7c02308,0x78020c8,0x7c02208,
+	0x7802988,0x7c029c8,0x7c027c9,0x8030580,0x7802908,0xaa14725,0x4001208,0x7802109,
+	0xa20c049,0x0000000,0x7c02908,0x683ffc9,0x64c2308,0x9304208,0xaa2c008,0x0000000,
+	0x80c3e01,0x64c3f08,0x93e1208,0xaae4008,0xb6e0049,0x4401249,0x6bfffc9,0xc7f5700,
+	0x7c02a89,0x64c2b08,0x60c2b08,0x780224e,0xba13fce,0x6800009,0xc7810c0,0x7c02249,
+	0x6808009,0xba1070e,0x400028e,0x441c28a,0x680c009,0x54032ca,0x200b28b,0x20092c9,
+	0x740025f,0x4001249,0x921031b,0x740024c,0x4001249,0x740025b,0x4001249,0x740025c,
+	0x4001249,0x921031c,0x740024c,0x4001249,0x740025d,0x4001249,0x921031d,0x740024c,
+	0x4001249,0x740025e,0x4001249,0x921031e,0x740024c,0x7800a49,0xac07949,0x78020cb,
+	0xaa38725,0x400030b,0x780210b,0xc7802c0,0x942f2cc,0xa61000b,0xaa14725,0x780210b,
+	0xa20c04b,0xa6146ca,0x40012ce,0xb60c70e,0x680000b,0x680070b,0x7c0224b,0xb012949,
+	0xaa0800b,0xa64070b,0x780228b,0xa20c04b,0x6a0800c,0x6a0c00c,0x649ce0b,0x200a2ea,
+	0x78022cd,0x54092cd,0x200b28b,0x603510b,0x6803f0b,0x603520b,0x603500c,0xc007340,
+	0x0000000,0x7800b08,0xa610388,0x78020c8,0xc780e40,0x0000000,0x4001208,0x7c020c8,
+	0x7802149,0x4001249,0x7c02149,0x7800a49,0xb84a248,0x6800008,0x7c020c8,0xc002c40,
+	0x0000000,0x7802109,0xae0c049,0x4401249,0x6800009,0x649cd0a,0xa21a00a,0x0000000,
+	0x67f410a,0x954a289,0xc780140,0x63f410a,0x67f400a,0x954a289,0x63f400a,0x7802109,
+	0x4001249,0x78026ca,0xb404289,0x7c02109,0xc780c80,0x0000000,0x680004a,0xc002240,
+	0x0000000,0xc065640,0x0000000,0xaa3800a,0x649cd0a,0xa21e00a,0x67f290a,0x83f4100,
+	0x68000c9,0x97c2289,0xc7801c0,0x63f290a,0x83f4000,0x67f2a0a,0x68000c9,0x97c2289,
+	0x63f2a0a,0x8032100,0x809ca01,0xc7f3440,0x6802ac3,0x7802109,0xbe10049,0x4001209,
+	0xc780580,0x7c02108,0x4401209,0x7c02108,0x78020c8,0x4001208,0x7c020c8,0x7802149,
+	0x4001249,0x7c02149,0x7800a49,0xb80b248,0x6800008,0x7c020c8,0x7802109,0x4002249,
+	0x78026ca,0xb805289,0x7c02109,0x6800008,0xc7ff480,0x7c02148,0x64c3b08,0x920c208,
+	0xb20ca08,0x680204b,0x7c02a4b,0x78020c8,0x9508548,0x780210a,0x940854a,0x7800a4a,
+	0xb01494a,0x6808009,0xa628725,0xc780a40,0x0000000,0x780210b,0xa20c04b,0x50012cb,
+	0x4001208,0x5401208,0xc780a40,0x940120b,0x4001208,0xa418288,0x780224a,0x7802108,
+	0xa27c048,0x400220a,0xc780380,0x6800008,0xaa7c725,0x780210b,0xa2bc04b,0x40012c8,
+	0xa4ed28b,0xc780680,0x6800008,0xaa14725,0x6800008,0x7802108,0x5001208,0x4801208,
+	0xb60c70a,0x6808009,0x680c009,0xc780400,0x0000000,0xa628048,0x400220a,0x7802108,
+	0xbe1c048,0x400220a,0xc7ffd80,0x6800048,0xaabc008,0x780224a,0x400120a,0xba10708,
+	0xb6ace08,0x680c009,0x441c208,0x5403288,0x200a20a,0x2009289,0x700024a,0x7c0288a,
+	0x4001249,0x700024a,0x4001249,0x7000257,0x96105ca,0x4001249,0x7000258,0x4001249,
+	0x700024a,0x961060a,0x4001249,0x7000259,0x4001249,0x700024a,0x961064a,0x4001249,
+	0x700025a,0x4001249,0x700024a,0x961068a,0x6bfda8a,0x603040a,0xcc00000,0x0400000,
+	0x78027c8,0xa6fc008,0x0000000,0x64c0008,0xa2f0048,0x64c3d08,0x580a208,0xbef80c8,
+	0x6a00008,0x60c3d08,0x64c3d08,0x580a208,0xbef80c8,0x0000000,0xcc00000,0x0000000,
+	0x7801688,0xaa0c188,0xcc00000,0x0000000,0x649cd08,0xa20e008,0xc7800c0,0x67f4008,
+	0x67f4108,0x93e1248,0xaae0009,0x9288248,0x7801a4a,0xa4f5289,0x914a208,0x7802589,
+	0xb60c689,0x6800049,0x6800109,0xb4ef248,0xc7ffc00,0x0000000,0x7801608,0xaa18008,
+	0x7801688,0xa614088,0x0000000,0x8098002,0x80980f0,0xc780a80,0x80c2400,0x64c2208,
+	0x9305248,0x93a22c8,0x9205288,0x92a2308,0x540230c,0x2c0b30b,0x9105388,0x91a2308,
+	0x540430c,0x2c0b30b,0x90053c8,0x90a2308,0x540630c,0x2c0b30b,0x7801688,0xa63c188,
+	0x80c2408,0x64c2208,0x480330b,0xaa340cc,0x0000000,0x480f2cb,0x9305388,0x93a2308,
+	0x540430c,0x2c0b30b,0x92053c8,0x92a2308,0x540630c,0x2c0b30b,0xc780280,0x0000000,
+	0x48032cb,0x9305288,0x93a2308,0x540230c,0x2c0b30b,0xc7800c0,0x0000000,0xc780600,
+	0x5418249,0x609b309,0x649b309,0x541828a,0x609b30a,0x649b30a,0x541838e,0x609b30e,
+	0x649b30e,0x54183cf,0x609b30f,0x649b30f,0x8098002,0x6bfffcc,0x541030c,0x6bfffcd,
+	0x2c0d30d,0x609820d,0x480330b,0xa6540cc,0x0000000,0xc7800c0,0x0000000,0xc7806c0,
+	0x5410309,0x581030c,0x5410349,0x2c0d30d,0x609810d,0x540430b,0x609800c,0xa813289,
+	0x0000000,0x541030a,0x581030c,0x541034a,0x2c0d30d,0x609820d,0xc780300,0x0000000,
+	0x5410309,0x581030c,0x541034a,0x2c0d30d,0x609810d,0x540430b,0x4c0430c,0x609800c,
+	0xc7800c0,0x0000000,0xc780380,0x480330b,0x541830c,0x2c0c24c,0x483034b,0x541434d,
+	0x2c0d38d,0xa80734c,0x0000000,0x541030e,0x581030c,0x541034f,0x2c0d30d,0x609820d,
+	0x7800b0c,0xa60c38c,0x6800725,0x5801965,0x6bfffcc,0x680001b,0x7802857,0x6800018,
+	0x680001c,0x6800019,0x680001d,0x680001a,0x680001e,0x4000817,0x4000858,0x4000899,
+	0x40008da,0x680800b,0x680070f,0x74002cc,0x40012cb,0x74002db,0x40012cb,0x74002d7,
+	0x40012cb,0x74002d8,0x40012cb,0x74002dc,0x40012cb,0x74002d9,0x40012cb,0x74002dd,
+	0x40012cb,0x74002da,0x40012cb,0x74002de,0xd07fbcf,0x40012cb,0x7c0288c,0x7c028cc,
+	0x961030c,0x80c0700,0x60c270c,0x96105db,0x60c0217,0x961061c,0x780254f,0xaa1800f,
+	0x60c0218,0x961065d,0x60c0219,0x961069e,0x60c021a,0x80c0701,0x60c270c,0x60c0217,
+	0xaa1000f,0x60c0218,0x60c0219,0x60c021a,0x7800a4f,0xb00894f,0x649ce09,0x200826a,
+	0x6035108,0x6803f08,0x6035208,0x6a08008,0x6035008,0x78020c8,0xa60c008,0x6803fc8,
+	0x7c02248,0x6800008,0x7c02908,0xac0b94f,0x7802248,0xb613fc8,0xba0c708,0x441c208,
+	0x7c02248,0x6435008,0x580f208,0xbef8048,0xcc00000,0x0000000,0x6435008,0x580f208,
+	0xbef8048,0x0000000,0x6435308,0x900c208,0xa6f8008,0x0000000,0x649ce09,0x200826a,
+	0x6035108,0x6803f08,0x6035208,0x6b0c008,0x6035008,0x5401225,0xac0520f,0x6800088,
+	0x7c02288,0xc7ff8c0,0x7c022c8,0x681000a,0x20092aa,0x649ce0a,0x2009289,0x54012a5,
+	0x200a94a,0x680008b,0x7c0228b,0x68000cb,0x6435008,0x580f208,0xbef8048,0x6803f08,
+	0x6035109,0x6035208,0x6a08008,0x6035008,0xac0328f,0xc7ff3c0,0x7c022cb,0x6808008,
+	0x2009209,0x200a94a,0xc7ffc80,0x40012cb,0x400134d,0x480f34d,0x7c022cd,0x980c38c,
+	0x780228d,0x54092cd,0x200ba8b,0x649ce0a,0x200b28b,0x400134d,0x480f34d,0x7c0228d,
+	0x643500d,0x580f34d,0xbef804d,0x0000000,0x643530d,0x900c34d,0xa6f800d,0x0000000,
+	0x603510b,0x6803f0b,0x603520b,0xc7fed80,0x603500c,0x780230c,0xa60c00c,0x440120c,
+	0x6800088,0xaa14008,0x6a01009,0xaa0c048,0x6a22009,0x6a40009,0x6c00109,0x60e0509,
+	0x7c02348,0x7802749,0x680180a,0x9502289,0x60c210a,0x80c260e,0x680004a,0x7c0294a,
+	0x78020c9,0x7c02209,0x7802989,0x7c029c9,0x6800089,0xcc00000,0x7c027c9,0xcc00000,
+	0x0400000,0x64e1226,0x91e19a6,0xbef0066,0x78027e6,0xaa480a6,0xc782c40,0x6800027,
+	0x6c04027,0x7802969,0x97c19e9,0x60e1227,0x7802127,0xa210067,0x40005ab,0x6900016,
+	0x2016ad6,0x649ce26,0x2016996,0x6800026,0x7c02766,0xc7825c0,0x6800126,0x7802767,
+	0xaa080a7,0xc781340,0x78025e8,0xaeb00a8,0x7802969,0xaa50725,0x7802226,0x54069a6,
+	0x7802128,0x5801a28,0xbe10068,0x40009eb,0x6900027,0x2027ae7,0x649ce28,0x2027a27,
+	0x20269e6,0x44409a6,0x60e1326,0xaa48029,0x40c05a6,0x6805c28,0x60c2128,0xc780380,
+	0x4040596,0x54059a6,0x7802128,0xbe10068,0x40009eb,0x6900027,0x2027ae7,0x649ce28,
+	0x2027a27,0x20269e6,0x44209a6,0x60e1326,0x40605a6,0x7802368,0xaa14028,0x6a2c227,
+	0xaa0c068,0x6a2c027,0x6a2c127,0xaa10029,0x6c04027,0x68003e6,0x95069e6,0x97c19e9,
+	0x60e1227,0x6800026,0x7c02766,0x6800126,0xc781dc0,0x7c027e6,0x78023a7,0x78023e8,
+	0x96109e8,0x7802828,0x2427a27,0x2427a27,0x7802969,0xaa0c029,0x2427a27,0x2427a27,
+	0x78026a6,0x54099a6,0x20269e6,0x54039e6,0x649ce28,0x2027a27,0x60e1327,0x7802368,
 	0xaa34028,0x6a44227,0xaa2c068,0x6a44027,0xc780240,0x6a44127,0xa64c0e7,0x78027a6,
-	0x64e0c28,0x9010a28,0xb8e6a26,0xcc00000,0x0400000,0xaa10029,0x6c0c027,0x68005e6,
-	0x95069e6,0x97c19e9,0x60e1227,0x6800016,0x6800026,0x7c02766,0x6800166,0xc781280,
-	0x7c027e6,0x7802627,0xaa1c027,0x44019e7,0x7c02627,0x78025e7,0x44019e7,0xc780f00,
+	0x64e0c28,0x9010a28,0xb8e4a26,0xcc00000,0x0400000,0xaa10029,0x6c0c027,0x68005e6,
+	0x95069e6,0x97c19e9,0x60e1227,0x6800016,0x6800026,0x7c02766,0x6800166,0xc781300,
+	0x7c027e6,0x7802627,0xaa1c027,0x44019e7,0x7c02627,0x78025e7,0x44019e7,0xc780f80,
 	0x7c025e7,0x7802427,0x7c024a7,0x7802466,0x7c024e6,0x96109e6,0x78026a6,0x54099a6,
-	0x20269e6,0x7802828,0x2027a27,0x7c02427,0x92109e7,0x7c02467,0x54039e6,0x60e1327,
-	0x7802368,0xaa14028,0x6a16227,0xaa0c068,0x6a16027,0x6a16127,0x78029e8,0xaa30028,
-	0x78027a6,0x64e0c28,0x9010a28,0xb806a26,0x78024a8,0x7c02428,0x78024e8,0xc7fd880,
-	0x7c02468,0x40019a6,0x7c027a6,0x7c02527,0x6c00027,0x60e1227,0x6800066,0xc780680,
-	0x7c027e6,0xba58126,0x7802967,0xa608027,0xc7ff340,0x78027a7,0x40019e7,0x7c027a7,
-	0xaa0c126,0x6800027,0x80c2170,0xc780300,0x7c02967,0xa6d0066,0x78025e7,0xaa30027,
-	0x44019e7,0xb228067,0x7c025e7,0x7802726,0xaa0c0e6,0x0000000,0x80c2170,0x6800026,
-	0x7c027e6,0xcc00000,0x0400000,0xc780540,0x0000000,0xa610026,0x40005ab,0x6900016,
-	0x2016ad6,0x649ce28,0xc780ac0,0x2016a16,0xaa0c725,0x90a8996,0x90c7996,0x7800a68,
-	0xb825a26,0xa8f4a26,0x91c1996,0xa62c026,0x40005ab,0x6900016,0xc780200,0x2016ad6,
-	0x78023a7,0x78023e8,0xaa6c016,0x96109e8,0xc7ffc00,0x0000000,0x649ce28,0x2016a16,
-	0x78026a6,0x54099a6,0x7802828,0x2427a27,0x20269e6,0x54039e6,0x60e1327,0x7802526,
-	0x90049e6,0xaa14027,0x6a14226,0xaa0c127,0x6a14026,0x6a14126,0x6c08026,0x60e0d16,
-	0xaa0c725,0x4020596,0x4020596,0xc7ff380,0x60e1226,0x78026a6,0x54099a6,0x20269e6,
-	0x7802828,0x2027a27,0x7c023a7,0x92109e7,0x7c023e7,0x54039e6,0x60e1327,0x7802526,
-	0xa618016,0x9c261e6,0x60e1226,0x68000e6,0xc7fef40,0x7c027e6,0x6c08026,0x60e0d16,
-	0xaae8725,0x4020596,0xc7ffe00,0x4020596,0x64e120a,0x91e128a,0xbef804a,0x64e000a,
-	0x64e030b,0x64e0e0c,0x64e0c0d,0x680100e,0x609840e,0x8098400,0x680020e,0xd00000e,
-	0x0000000,0x60e000a,0x60e030b,0x60e0e0c,0xcc00000,0x60e0c0d,0xc000d00,0x0000000,
-	0x681010a,0x6c3474a,0x609070a,0x6490b0a,0x980a00a,0x980a0ca,0x6090b0a,0x9c0a00a,
-	0x9c0a0ca,0x6090b0a,0x649ce0b,0x200a2eb,0x609440a,0x690000a,0x200aaca,0x649ce0b,
-	0x200a2ca,0x609450a,0xcc00000,0x0000000,0xc000b40,0x0000000,0x8095007,0x8095000,
-	0x6800049,0x7800a4b,0x68002ca,0xb00328b,0x0000000,0x6800009,0x6498e0b,0x97c12c9,
-	0x6098e0b,0x6497f09,0x68000cb,0x970224b,0x6097f09,0x6820889,0x6c00209,0x6095109,
-	0x7800a4b,0xb20c2cb,0x680040b,0x6800c0b,0x6495109,0x970624b,0x9809649,0x6095109,
-	0xcc00000,0x0000000,0x683ffc9,0x649090a,0xa21004a,0xaa0c009,0xc7fff40,0x4401249,
-	0x6490b0a,0x980a00a,0x980a0ca,0x6090b0a,0x9c0a00a,0x9c0a0ca,0x6090b0a,0xcc00000,
-	0x0000000,0x683ffca,0x649530b,0x90012cb,0x649bb09,0x920c249,0x20092c9,0xaa10009,
-	0xaa0c00a,0xc7ffe40,0x440128a,0xcc00000,0x0000000,0x0000000,0x0000000,0x0000000,
-	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0x20269e6,0x7802828,0x2027a27,0x7c02427,0x92109e7,0x7c02467,0x54039e6,0x649ce28,
+	0x2027a27,0x60e1327,0x7802368,0xaa14028,0x6a16227,0xaa0c068,0x6a16027,0x6a16127,
+	0x78029e8,0xaa30028,0x78027a6,0x64e0c28,0x9010a28,0xb806a26,0x78024a8,0x7c02428,
+	0x78024e8,0xc7fd780,0x7c02468,0x40019a6,0x7c027a6,0x7c02527,0x6c00027,0x60e1227,
+	0x6800066,0xc780680,0x7c027e6,0xba58126,0x7802967,0xa608027,0xc7ff2c0,0x78027a7,
+	0x40019e7,0x7c027a7,0xaa0c126,0x6800027,0x80c2170,0xc780300,0x7c02967,0xa6d0066,
+	0x78025e7,0xaa30027,0x44019e7,0xb228067,0x7c025e7,0x7802726,0xaa0c0e6,0x0000000,
+	0x80c2170,0x6800026,0x7c027e6,0xcc00000,0x0400000,0xc780540,0x0000000,0xa610026,
+	0x40005ab,0x6900016,0x2016ad6,0x649ce28,0xc780b40,0x2016a16,0xaa0c725,0x90a8996,
+	0x90c7996,0x7800a68,0xb827a26,0xa8f4a26,0x91c1996,0xa62c026,0x40005ab,0x6900016,
+	0xc780200,0x2016ad6,0x78023a7,0x78023e8,0xaa74016,0x96109e8,0xc7ffc00,0x0000000,
+	0x649ce28,0x2016a16,0x78026a6,0x54099a6,0x7802828,0x2427a27,0x20269e6,0x54039e6,
+	0x649ce26,0x20279a7,0x60e1327,0x7802526,0x90049e6,0xaa14027,0x6a14226,0xaa0c127,
+	0x6a14026,0x6a14126,0x6c08026,0x60e0d16,0xaa0c725,0x4020596,0x4020596,0xc7ff300,
+	0x60e1226,0x78026a6,0x54099a6,0x20269e6,0x7802828,0x2027a27,0x7c023a7,0x92109e7,
+	0x7c023e7,0x54039e6,0x649ce26,0x20279a7,0x60e1327,0x7802526,0xa618016,0x9c261e6,
+	0x60e1226,0x68000e6,0xc7fee40,0x7c027e6,0x6c08026,0x60e0d16,0xaae8725,0x4020596,
+	0xc7ffe00,0x4020596,0x64e120a,0x91e128a,0xbef804a,0x64e000a,0x64e030b,0x64e0e0c,
+	0x64e0c0d,0x680100e,0x609840e,0x8098400,0x680020e,0xd00000e,0x0000000,0x60e000a,
+	0x60e030b,0x60e0e0c,0xcc00000,0x60e0c0d,0xc000d00,0x0000000,0x681010a,0x6c3474a,
+	0x609070a,0x6490b0a,0x980a00a,0x980a0ca,0x6090b0a,0x9c0a00a,0x9c0a0ca,0x6090b0a,
+	0x649ce0b,0x200a2eb,0x609440a,0x690000a,0x200aaca,0x649ce0b,0x200a2ca,0x609450a,
+	0xcc00000,0x0000000,0xc000b40,0x0000000,0x8095007,0x8095000,0x6800049,0x7800a4b,
+	0x68002ca,0xb00328b,0x0000000,0x6800009,0x6498e0b,0x97c12c9,0x6098e0b,0x6497f09,
+	0x68000cb,0x970224b,0x6097f09,0x6820889,0x6c00209,0x6095109,0x7800a4b,0xb20c2cb,
+	0x680040b,0x6800c0b,0x6495109,0x970624b,0x9809649,0x6095109,0xcc00000,0x0000000,
+	0x683ffc9,0x649090a,0xa21004a,0xaa0c009,0xc7fff40,0x4401249,0x6490b0a,0x980a00a,
+	0x980a0ca,0x6090b0a,0x9c0a00a,0x9c0a0ca,0x6090b0a,0xcc00000,0x0000000,0x683ffca,
+	0x649530b,0x90012cb,0x649bb09,0x920c249,0x20092c9,0xaa10009,0xaa0c00a,0xc7ffe40,
+	0x440128a,0xcc00000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
 	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
 	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
 	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
diff --git a/drivers/amlogic/amports/vdec.c b/drivers/amlogic/amports/vdec.c
index 21bf052bb1b3..eed071e04a6f 100755
--- a/drivers/amlogic/amports/vdec.c
+++ b/drivers/amlogic/amports/vdec.c
@@ -213,7 +213,12 @@ static struct resource amvdec_mem_resource[]  = {
         .start = 0,
         .end   = 0,
         .flags = 0,
-    }
+    },
+    [2] = {
+        .start = 0,
+        .end   = 0,
+        .flags = 0,
+    },
 };
 
 static const char *vdec_device_name[] = {
@@ -230,24 +235,25 @@ static const char *vdec_device_name[] = {
     "amvdec_h264_4k2k"
 };
 
-/*
-This function used for change the memory reasource on system run;
-It can used for system swap memory for codec and some othor use;
-We must call it at the amstream start for register a memory resource
-*/
-int vdec_set_resource(struct resource *s, void *param)
+void vdec_set_decinfo(void *p)
+{
+    amvdec_mem_resource[1].start = (resource_size_t)p;
+}
+
+int vdec_set_resource(struct resource *s, struct device *p)
 {
     if (inited_vcodec_num != 0) {
         printk("ERROR:We can't support the change resource at code running\n");
         return -1;
     }
+
     if(s){
         amvdec_mem_resource[0].start = s->start;
         amvdec_mem_resource[0].end = s->end;
         amvdec_mem_resource[0].flags = s->flags;
     }
-	if(param)
-        amvdec_mem_resource[1].start = (resource_size_t)param;
+
+    amvdec_mem_resource[2].start = (resource_size_t)p;
 
     return 0;
 }
@@ -585,17 +591,22 @@ static int  vdec_probe(struct platform_device *pdev)
     }
     res.start = (phys_addr_t)get_reserve_block_addr(r);
     res.end = res.start+ (phys_addr_t)get_reserve_block_size(r)-1;
-	printk("init vdec memsource %d->%d\n",res.start,res.end);
+
+    printk("init vdec memsource %d->%d\n",res.start,res.end);
     res.flags = IORESOURCE_MEM;
-    vdec_set_resource(&res,NULL);
+
+    vdec_set_resource(&res, &pdev->dev);
+
 #if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
     /* default to 250MHz */
     vdec_clock_hi_enable();
 #endif
     return 0;
+
 error:
-	class_unregister(&vdec_class);
-	return r;
+    class_unregister(&vdec_class);
+
+    return r;
 }
 
 static int  vdec_remove(struct platform_device *pdev)
diff --git a/drivers/amlogic/amports/vdec.h b/drivers/amlogic/amports/vdec.h
index 9435c219819c..89acc40d569b 100755
--- a/drivers/amlogic/amports/vdec.h
+++ b/drivers/amlogic/amports/vdec.h
@@ -23,7 +23,8 @@
 #define VDEC_H
 
 
-extern int vdec_set_resource(struct resource * s, void *param);
+extern void vdec_set_decinfo(void *p);
+extern int vdec_set_resource(struct resource *s, struct device *p);
 
 extern s32 vdec_init(vformat_t vf);
 extern s32 vdec_release(vformat_t vf);
diff --git a/drivers/amlogic/amports/vh264_4k2k.c b/drivers/amlogic/amports/vh264_4k2k.c
index 00af7e9d777d..1b9c3aef65ea 100755
--- a/drivers/amlogic/amports/vh264_4k2k.c
+++ b/drivers/amlogic/amports/vh264_4k2k.c
@@ -34,6 +34,7 @@
 #include <linux/amlogic/amports/vframe_provider.h>
 #include <linux/amlogic/amports/vframe_receiver.h>
 #include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
 
 #include <mach/am_regs.h>
 #include <mach/vpu.h>
@@ -97,8 +98,11 @@ extern u32 trickmode_i;
 static DEFINE_SPINLOCK(lock);
 static int fatal_error;
 
+static DEFINE_MUTEX(vh264_4k2k_mutex);
+
 static void (*probe_callback)(void) = NULL;
 static void (*remove_callback)(void) = NULL;
+static struct device *cma_dev;
 
 #define CBCR_MERGE
 
@@ -340,6 +344,7 @@ static const char *reg_name[] = {
 #define CMD_DEBUG                  10
 
 static unsigned work_space_adr, decoder_buffer_start, decoder_buffer_end;
+static unsigned reserved_buffer;
 
 #define DECODE_BUFFER_NUM_MAX    16
 #define DISPLAY_BUFFER_NUM       6
@@ -355,6 +360,9 @@ typedef struct {
     int y_canvas_index;
     int u_canvas_index;
     int v_canvas_index;
+
+    struct page *alloc_pages;
+    int alloc_count;
 } buffer_spec_t;
 
 static buffer_spec_t buffer_spec[DECODE_BUFFER_NUM_MAX+DISPLAY_BUFFER_NUM];
@@ -373,6 +381,8 @@ static DECLARE_KFIFO(recycle_q, vframe_t *, VF_POOL_SIZE);
 static s32 vfbuf_use[DECODE_BUFFER_NUM_MAX];
 static vframe_t vfpool[VF_POOL_SIZE];
 
+static struct work_struct alloc_work;
+
 static void set_frame_info(vframe_t *vf)
 {
     unsigned int ar;
@@ -452,17 +462,19 @@ static int vh264_4k2k_event_cb(int type, void *data, void *private_data)
     return 0;
 }
 
-long init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width, int mb_height, buffer_spec_t* buffer_spec)
+int init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width, int mb_height, buffer_spec_t* buffer_spec)
 {
-    int dpb_addr, addr;
+    unsigned long dpb_addr, addr;
     int i;
     int mb_total;
     int canvas_addr = ANC0_CANVAS_ADDR;
     int vdec2_canvas_addr = VDEC2_ANC0_CANVAS_ADDR;
     int index = AMVDEC_H264_4K2K_CANVAS_INDEX;
     u32 disp_addr = 0xffffffff;
+    bool use_alloc = false;
+    int alloc_count = 0;
 
-    dpb_addr = start_addr;
+    dpb_addr = start_addr + dpb_size;
 
     mb_total = mb_width * mb_height;
 
@@ -473,14 +485,37 @@ long init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width, in
         disp_addr = (cur_canvas.addr + 7) >> 3;
     }
 
+    mutex_lock(&vh264_4k2k_mutex);
+    
     for (i=0; i<dpb_number; i++) {
         WRITE_VREG(canvas_addr++, index | ((index+1)<<8) | ((index+2)<<16));
         WRITE_VREG(vdec2_canvas_addr++, index | ((index+1)<<8) | ((index+2)<<16));
 
-        if (((dpb_addr + 7) >> 3) == disp_addr) {
-            addr = start_addr + dpb_number * dpb_size;
+        if (((dpb_addr + (mb_total << 8) + (mb_total << 7)) >= decoder_buffer_end) && (!use_alloc)) {
+            printk("start alloc for %d/%d\n", i, dpb_number);
+            use_alloc = true;
+        }
+
+        if (use_alloc) {
+            buffer_spec[i].alloc_count = PAGE_ALIGN((mb_total << 8) + (mb_total << 7)) / PAGE_SIZE;
+            buffer_spec[i].alloc_pages = dma_alloc_from_contiguous(cma_dev, buffer_spec[i].alloc_count, 0);
+            alloc_count++;
+
+            if (!buffer_spec[i].alloc_pages) {
+                printk("264 4K2K decoder memory allocation failed %d.\n", i);
+                mutex_unlock(&vh264_4k2k_mutex);
+                return -1;
+            }
+
+            addr = page_to_phys(buffer_spec[i].alloc_pages);
+            dpb_addr = addr;
         } else {
             addr = dpb_addr;
+            dpb_addr += dpb_size;
+        }
+
+        if (((addr + 7) >> 3) == disp_addr) {
+            addr = start_addr;
         }
 
         buffer_spec[i].y_addr = addr;
@@ -497,7 +532,6 @@ long init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width, in
         buffer_spec[i].u_addr = addr;
         buffer_spec[i].u_canvas_index = index;
 
-
 #ifdef CBCR_MERGE
         canvas_config(index,
                   addr,
@@ -514,7 +548,6 @@ long init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width, in
         index++;
         addr += mb_total << 7;
 #else
-
         canvas_config(index,
                   addr,
                   mb_width << 3,
@@ -537,13 +570,13 @@ long init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width, in
         addr += mb_total << 6;
         index++;
 #endif
-        dpb_addr = dpb_addr + dpb_size;
-
-        if(dpb_addr >= decoder_buffer_end)
-            return -1;
     }
 
-    return dpb_addr;
+    mutex_unlock(&vh264_4k2k_mutex);
+
+    printk("H264 4k2k decoder canvas allocation successful, %d CMA blocks allocated\n", alloc_count);
+
+    return 0;
 }
 
 static int get_max_dec_frame_buf_size(int level_idc, int max_reference_frame_num, int mb_width, int mb_height)
@@ -617,79 +650,63 @@ static int get_max_dec_frame_buf_size(int level_idc, int max_reference_frame_num
     return size;
 }
 
-static irqreturn_t vh264_4k2k_isr(int irq, void *dev_id)
+static void do_alloc_work(struct work_struct *work)
 {
-    int drop_status, display_buff_id, display_POC, level_idc, max_reference_frame_num, mb_width, mb_height;
+    int level_idc, max_reference_frame_num, mb_width, mb_height;
     int dpb_size, ref_size;
     int dpb_start_addr, ref_start_addr, max_dec_frame_buffering, total_dec_frame_buffering;
-    unsigned stream_offset;
-    vframe_t *vf = NULL;
     int ret = READ_VREG(MAILBOX_COMMAND);
 
-    switch(ret & 0xff) {
-    case CMD_ALLOC_VIEW:
-        dpb_start_addr = decoder_buffer_start;
-        ret = READ_VREG(MAILBOX_DATA_0);
-        level_idc = (ret >> 24) & 0xff;
-        max_reference_frame_num = (ret >> 16) & 0xff;
-        mb_width = (ret >> 8) & 0xff;
-        if (mb_width == 0) {
-            mb_width = 256;
-        }
-        mb_height = (ret >> 0) & 0xff;
+    ref_start_addr = decoder_buffer_start;
+    ret = READ_VREG(MAILBOX_DATA_0);
+    level_idc = (ret >> 24) & 0xff;
+    max_reference_frame_num = (ret >> 16) & 0xff;
+    mb_width = (ret >> 8) & 0xff;
+    if (mb_width == 0) {
+        mb_width = 256;
+    }
+    mb_height = (ret >> 0) & 0xff;
 
-        max_dec_frame_buffering = get_max_dec_frame_buf_size(level_idc, max_reference_frame_num, mb_width, mb_height);
+    max_dec_frame_buffering = get_max_dec_frame_buf_size(level_idc, max_reference_frame_num, mb_width, mb_height);
 
-        total_dec_frame_buffering = max_dec_frame_buffering + DISPLAY_BUFFER_NUM;
+    total_dec_frame_buffering = max_dec_frame_buffering + DISPLAY_BUFFER_NUM;
 
-        if ((frame_width == 0) || (frame_height == 0)) {
-            frame_width = mb_width << 4;
-            frame_height = mb_height << 4;
-            frame_ar = frame_height * 0x100 / frame_width;
-        }
+    if ((frame_width == 0) || (frame_height == 0)) {
+        frame_width = mb_width << 4;
+        frame_height = mb_height << 4;
+        frame_ar = frame_height * 0x100 / frame_width;
+    }
 
-        mb_width = (mb_width+3) & 0xfffffffc;
-        mb_height = (mb_height+3) & 0xfffffffc;
-
-        dpb_size = mb_width * mb_height * 384;
-        ref_size = mb_width * mb_height * 96;
-        ref_start_addr = dpb_start_addr +
-                            (dpb_size * (total_dec_frame_buffering+1));
-
-        if (((ref_start_addr + ref_size * (max_reference_frame_num+1))) >= decoder_buffer_end) {
-            printk(" No enough memory for alloc buffer\n");
-            printk(" dpb_size = %d, total_dec_frame_buffering = %d, ref_start_addr = 0x%x\n",
-                       dpb_size, total_dec_frame_buffering, ref_start_addr);
-            printk("     ref_size = %d, max_reference_frame_num = %d, total = %d\n", 
-                       ref_size, max_reference_frame_num, ref_size * (max_reference_frame_num+1));
-            printk("     available memory resource 0x%x - 0x%x\n", ref_start_addr, decoder_buffer_end);
-            goto exit;
-        }
+    mb_width = (mb_width+3) & 0xfffffffc;
+    mb_height = (mb_height+3) & 0xfffffffc;
 
-printk("dpb_start_addr=0x%x, dpb_size=%d, total_dec_frame_buffering=%d, mb_width=%d, mb_height=%d\n",
+    dpb_size = mb_width * mb_height * 384;
+    ref_size = mb_width * mb_height * 96;
+    dpb_start_addr = ref_start_addr + (ref_size * (max_reference_frame_num+1)) * 2;
+    //dpb_start_addr = reserved_buffer + dpb_size;
+
+    printk("dpb_start_addr=0x%x, dpb_size=%d, total_dec_frame_buffering=%d, mb_width=%d, mb_height=%d\n",
         dpb_start_addr, dpb_size, total_dec_frame_buffering, mb_width, mb_height);
-        ret = init_canvas(dpb_start_addr, dpb_size,
-                              total_dec_frame_buffering, mb_width, mb_height, buffer_spec);
 
-        if (ret == -1) {
-             printk(" Un-expected memory alloc problem\n");
-             goto exit;
-        }
+    ret = init_canvas(dpb_start_addr, dpb_size,
+                          total_dec_frame_buffering, mb_width, mb_height, buffer_spec);
 
-        WRITE_VREG(REF_START_VIEW_0, video_domain_addr(ref_start_addr));
-        WRITE_VREG(VDEC2_REF_START_VIEW_0, video_domain_addr(ref_start_addr));
+    if (ret == -1) {
+         printk(" Un-expected memory alloc problem\n");
+         return;
+    }
 
-        WRITE_VREG(MAILBOX_DATA_0, (max_dec_frame_buffering << 8) | (total_dec_frame_buffering << 0));
-        WRITE_VREG(MAILBOX_DATA_1, ref_size);
-        WRITE_VREG(MAILBOX_COMMAND, CMD_FINISHED);
+    if (frame_width == 0)
+        frame_width = mb_width<<4;
+    if (frame_height == 0)
+        frame_height = mb_height<<4;
 
-        if (frame_width == 0)
-            frame_width = mb_width<<4;
-        if (frame_height == 0)
-            frame_height = mb_height<<4;
-        if (frame_height == 1088)
-            frame_height = 1080;
-printk("CMD_ALLOC_VIEW done\n");
+    WRITE_VREG(REF_START_VIEW_0, video_domain_addr(ref_start_addr));
+    WRITE_VREG(VDEC2_REF_START_VIEW_0, video_domain_addr(ref_start_addr));
+
+    WRITE_VREG(MAILBOX_DATA_0, (max_dec_frame_buffering << 8) | (total_dec_frame_buffering << 0));
+    WRITE_VREG(MAILBOX_DATA_1, ref_size);
+    WRITE_VREG(MAILBOX_COMMAND, CMD_FINISHED);
 
 /////////////// FAKE FIRST PIC
 #if 0
@@ -711,7 +728,18 @@ WRITE_VREG(DOS_SCRATCH1, 0x004c);
         
 /////////////// FAKE END   
 #endif
+}
 
+static irqreturn_t vh264_4k2k_isr(int irq, void *dev_id)
+{
+    int drop_status, display_buff_id, display_POC;
+    unsigned stream_offset;
+    vframe_t *vf = NULL;
+    int ret = READ_VREG(MAILBOX_COMMAND);
+
+    switch(ret & 0xff) {
+    case CMD_ALLOC_VIEW:
+        schedule_work(&alloc_work);
         break;
 
     case CMD_FRAME_DISPLAY:
@@ -810,7 +838,6 @@ printk("M->S,[%d] %s = 0x%x\n",ret, reg_name[ret], READ_VREG(MAILBOX_DATA_1));
         break;
     }
 
-exit:
     return IRQ_HANDLED;
 }
 
@@ -1169,7 +1196,9 @@ static void vh264_4k2k_local_init(void)
     frame_width = vh264_4k2k_amstream_dec_info.width;
     frame_height = vh264_4k2k_amstream_dec_info.height;
     frame_dur = (vh264_4k2k_amstream_dec_info.rate == 0) ? 3600 : vh264_4k2k_amstream_dec_info.rate;
-    frame_ar = frame_height * 0x100 / frame_width;
+    if (frame_width && frame_height) {
+        frame_ar = frame_height * 0x100 / frame_width;
+    }
     error_watchdog_count = 0;
 
     printk("H264_4K2K: decinfo: %dx%d rate=%d\n", frame_width, frame_height, frame_dur);
@@ -1192,11 +1221,16 @@ static void vh264_4k2k_local_init(void)
         kfifo_put(&newframe_q, &vf);
     }
 
+    reserved_buffer = 0;
+
+    INIT_WORK(&alloc_work, do_alloc_work);
+
     return;
 }
 
 static s32 vh264_4k2k_init(void)
 {
+    int i;
     void __iomem *p = ioremap_nocache(work_space_adr, DECODER_WORK_SPACE_SIZE);
 
     if (!p) {
@@ -1210,12 +1244,18 @@ static s32 vh264_4k2k_init(void)
 
     stat |= STAT_TIMER_INIT;
 
+    for (i=0; i<ARRAY_SIZE(buffer_spec); i++) {
+        buffer_spec[i].alloc_pages = NULL;
+        buffer_spec[i].alloc_count = 0;
+    }
+
     vh264_4k2k_local_init();
 
     amvdec_enable();
 
     if (amvdec_loadmc(vh264_4k2k_mc) < 0) {
         amvdec_disable();
+        iounmap(p);
         return -EBUSY;
     }
 
@@ -1224,6 +1264,7 @@ static s32 vh264_4k2k_init(void)
     if (amvdec2_loadmc(vh264_4k2k_mc) < 0) {
         amvdec_disable();
         amvdec2_disable();
+        iounmap(p);
         return -EBUSY;
     }
 
@@ -1289,6 +1330,8 @@ static s32 vh264_4k2k_init(void)
 
 static int vh264_4k2k_stop(void)
 {
+    int i;
+
     if (stat & STAT_VDEC_RUN) {
         amvdec_stop();
         amvdec2_stop();
@@ -1316,6 +1359,14 @@ static int vh264_4k2k_stop(void)
     amvdec_disable();
     amvdec2_disable();
 
+    for (i=0; i<ARRAY_SIZE(buffer_spec); i++) {
+        if (buffer_spec[i].alloc_pages) {
+            dma_release_from_contiguous(cma_dev, buffer_spec[i].alloc_pages, buffer_spec[i].alloc_count);
+            buffer_spec[i].alloc_pages = NULL;
+            buffer_spec[i].alloc_count = 0;
+        }
+    }
+
     return 0;
 }
 
@@ -1325,10 +1376,13 @@ static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 
     printk("amvdec_h264_4k2k probe start.\n");
 
+    mutex_lock(&vh264_4k2k_mutex);
+    
     fatal_error = 0;
 
     if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0))) {
         printk("\namvdec_h264_4k2k memory resource undefined.\n");
+        mutex_unlock(&vh264_4k2k_mutex);
         return -EFAULT;
     }
 
@@ -1339,6 +1393,8 @@ static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 
     memcpy(&vh264_4k2k_amstream_dec_info, (void *)mem[1].start, sizeof(vh264_4k2k_amstream_dec_info));
 
+    cma_dev = (struct device *)mem[2].start;
+printk("cma_dev = %p\n", cma_dev);
     vdec_poweron(VDEC_2);
 
     vdec_power_mode(1);
@@ -1346,6 +1402,7 @@ static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 
     if (vh264_4k2k_init() < 0) {
         printk("\namvdec_h264_4k2k init failed.\n");
+        mutex_unlock(&vh264_4k2k_mutex);
         return -ENODEV;
     }
 
@@ -1355,6 +1412,7 @@ static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
         probe_callback();
     }
 
+    mutex_unlock(&vh264_4k2k_mutex);
     return 0;
 }
 
@@ -1362,6 +1420,8 @@ static int amvdec_h264_4k2k_remove(struct platform_device *pdev)
 {
     printk("amvdec_h264_4k2k_remove\n");
 
+    mutex_lock(&vh264_4k2k_mutex);
+
     vh264_4k2k_stop();
 
     vdec_poweroff(VDEC_2);
@@ -1375,6 +1435,8 @@ static int amvdec_h264_4k2k_remove(struct platform_device *pdev)
         remove_callback();
     }
 
+    mutex_unlock(&vh264_4k2k_mutex);
+    
     return 0;
 }
 
diff --git a/drivers/amlogic/camera/ar0543.c b/drivers/amlogic/camera/ar0543.c
index 7cb2fb3ba0a3..d5bf5558b904 100755
--- a/drivers/amlogic/camera/ar0543.c
+++ b/drivers/amlogic/camera/ar0543.c
@@ -3372,7 +3372,13 @@ static int ar0543_open(struct file *file)
     resource_size_t mem_start = 0;
     unsigned int mem_size = 0;
     int retval = 0;
-
+#if CONFIG_CMA
+    retval = vm_init_buf(28*SZ_1M);
+    if(retval <0) {
+    	printk("error: no cma memory\n");
+        return -1;
+    }
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
     switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -3591,6 +3597,9 @@ static int ar0543_close(struct file *file)
     class_remove_file(cam_class,&class_attr_version_debug);
     class_destroy(cam_class);
     printk("close success\n");
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
     return 0;
 }
 
diff --git a/drivers/amlogic/camera/ar0833.c b/drivers/amlogic/camera/ar0833.c
index 5d209d640857..ce3cda733b0a 100755
--- a/drivers/amlogic/camera/ar0833.c
+++ b/drivers/amlogic/camera/ar0833.c
@@ -5441,7 +5441,13 @@ static int ar0833_open(struct file *file)
     resource_size_t mem_start = 0;
     unsigned int mem_size = 0;
     int retval = 0;
-
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0) {
+    	printk("error: no cma memory\n");
+        return -1;
+    }
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
     switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -5655,7 +5661,9 @@ static int ar0833_close(struct file *file)
     class_remove_file(cam_class,&class_attr_version_debug);
     class_destroy(cam_class);
     printk("close success\n");
-
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
     return 0;
 }
 
diff --git a/drivers/amlogic/camera/common/vm.c b/drivers/amlogic/camera/common/vm.c
index 12de0dcd0a9f..db4f29b9f94b 100755
--- a/drivers/amlogic/camera/common/vm.c
+++ b/drivers/amlogic/camera/common/vm.c
@@ -51,8 +51,7 @@
 
 #include <linux/sizes.h>
 #include <linux/dma-mapping.h>
-#include <linux/of_fdt.h>
-
+#include <linux/dma-contiguous.h>
 
 /*class property info.*/
 #include "vmcls.h"
@@ -1843,6 +1842,64 @@ int uninit_vm_device(void)
 }
 
 
+#ifdef CONFIG_CMA
+void set_vm_buf_info(resource_size_t start,unsigned int size);
+void unset_vm_buf_info();
+
+static size_t vm_buf_size;
+static struct page *vm_pages;
+
+int vm_init_buf(size_t size)
+{
+
+    if(size ==0)
+        return -1;
+
+    if(vm_pages && vm_buf_size != 0)
+    {
+        pr_warn("%s cma space already in use, phys %x size %dk\n", __func__, page_to_phys(vm_pages), size/1024);
+        dma_release_from_contiguous(&vm_device.pdev->dev, vm_pages, vm_buf_size/PAGE_SIZE); 
+    }
+
+    vm_pages = dma_alloc_from_contiguous(&vm_device.pdev->dev, size/PAGE_SIZE, 0);
+    if(vm_pages)
+    {
+        dma_addr_t phys;
+        phys = page_to_phys(vm_pages);
+        pr_info("%s: allocating phys %p, size %dk\n", __func__, phys, size/1024);
+        set_vm_buf_info(phys, size);
+        vm_buf_size = size;
+        return 0;
+    }
+    else
+    {
+        pr_err("CMA failed to allocate dma buffer\n");
+        return -ENOMEM;
+    }
+}
+
+EXPORT_SYMBOL(vm_init_buf);
+
+void vm_deinit_buf()
+{
+    if(0 == vm_buf_size)
+    {
+        pr_warn("vm buf size equals 0\n");
+        return;
+    }
+    unset_vm_buf_info();
+    if(vm_pages)
+    {
+        dma_release_from_contiguous(&vm_device.pdev->dev, vm_pages, vm_buf_size/PAGE_SIZE); 
+        vm_buf_size = 0;
+    }
+}
+
+EXPORT_SYMBOL(vm_deinit_buf);
+#endif
+
+
+
 /*******************************************************************
  *
  * interface for Linux driver
@@ -1854,12 +1911,11 @@ MODULE_AMLOG(AMLOG_DEFAULT_LEVEL, 0xff, LOG_LEVEL_DESC, LOG_MASK_DESC);
 /* for driver. */
 static int vm_driver_probe(struct platform_device *pdev)
 {
+#ifndef CONFIG_CMA
 	char* buf_start;
 	unsigned int buf_size;
 	struct resource *mem;
-    int idx;
 
-#if 0
 	if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0)))
 	{
 		buf_start = 0;
@@ -1868,25 +1924,12 @@ static int vm_driver_probe(struct platform_device *pdev)
 		buf_start = (char *)mem->start;
 		buf_size = mem->end - mem->start + 1;
 	}
-#else
-     idx = find_reserve_block(pdev->dev.of_node->name,0);
-     if(idx < 0){
-         buf_start = 0;
-         buf_size = 0;
-         amlog_level(LOG_LEVEL_HIGH, "vm memory resource undefined.\n");
-     }
-     else
-     {
-         buf_start = (char *)get_reserve_block_addr(idx);
-         buf_size = (unsigned int)get_reserve_block_size(idx);
-     }
-#endif 
-    vm_device.pdev = pdev;
+	set_vm_buf_info(mem->start,buf_size);
+#endif
 
-	set_vm_buf_info(buf_start,buf_size);
 
+	vm_device.pdev = pdev;
 	init_vm_device();
-
 	return 0;
 }
 
@@ -1907,7 +1950,6 @@ static const struct of_device_id amlogic_vm_dt_match[]={
 #define amlogic_vm_dt_match NULL
 #endif
 
-
 /* general interface for a linux driver .*/
 static struct platform_driver vm_drv = {
 	.probe  = vm_driver_probe,
@@ -1924,9 +1966,11 @@ vm_init_module(void)
 {
 	int err;
 
+
 	amlog_level(LOG_LEVEL_HIGH,"vm_init\n");
 	if ((err = platform_driver_register(&vm_drv))) {
 		printk(KERN_ERR "Failed to register vm driver (error=%d\n", err);
+		return err;
 	}
 
 	return err;
diff --git a/drivers/amlogic/camera/gc0307.c b/drivers/amlogic/camera/gc0307.c
index ce67391dbb39..63e7a7b0d5ab 100755
--- a/drivers/amlogic/camera/gc0307.c
+++ b/drivers/amlogic/camera/gc0307.c
@@ -2593,6 +2593,12 @@ static int gc0307_open(struct file *file)
 	int retval = 0;
 	gc0307_have_open=1;
 
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
+
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif	
@@ -2726,6 +2732,9 @@ static int gc0307_close(struct file *file)
 #endif	
 	wake_unlock(&(dev->wake_lock));
 
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 
 	return 0;
 }
diff --git a/drivers/amlogic/camera/gc0308.c b/drivers/amlogic/camera/gc0308.c
index 19e736c0e757..3bff2ab88152 100755
--- a/drivers/amlogic/camera/gc0308.c
+++ b/drivers/amlogic/camera/gc0308.c
@@ -2492,7 +2492,11 @@ static int gc0308_open(struct file *file)
 	struct gc0308_device *dev = video_drvdata(file);
 	struct gc0308_fh *fh = NULL;
 	int retval = 0;
-
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif	
@@ -2625,6 +2629,9 @@ static int gc0308_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/gc0328.c b/drivers/amlogic/camera/gc0328.c
index 84323a18f903..341df64cb157 100755
--- a/drivers/amlogic/camera/gc0328.c
+++ b/drivers/amlogic/camera/gc0328.c
@@ -2308,6 +2308,11 @@ static int gc0328_open(struct file *file)
 	struct gc0328_device *dev = video_drvdata(file);
 	struct gc0328_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	gc0328_have_open=1;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -2441,6 +2446,9 @@ static int gc0328_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/gc0329.c b/drivers/amlogic/camera/gc0329.c
index cdc74ee925bf..46ed17365545 100755
--- a/drivers/amlogic/camera/gc0329.c
+++ b/drivers/amlogic/camera/gc0329.c
@@ -2276,6 +2276,11 @@ static int gc0329_open(struct file *file)
 	struct gc0329_device *dev = video_drvdata(file);
 	struct gc0329_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2406,6 +2411,9 @@ static int gc0329_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/gc2015.c b/drivers/amlogic/camera/gc2015.c
index 6c0fafd0423a..2334111942ff 100755
--- a/drivers/amlogic/camera/gc2015.c
+++ b/drivers/amlogic/camera/gc2015.c
@@ -2588,6 +2588,11 @@ static int gc2015_open(struct file *file)
 	struct gc2015_device *dev = video_drvdata(file);
 	struct gc2015_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif	
@@ -2723,6 +2728,9 @@ static int gc2015_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/gc2035.c b/drivers/amlogic/camera/gc2035.c
index b21958b0e5b6..703f25678e78 100755
--- a/drivers/amlogic/camera/gc2035.c
+++ b/drivers/amlogic/camera/gc2035.c
@@ -3388,6 +3388,15 @@ static int gc2035_open(struct file *file)
         resource_size_t mem_start = 0;
         unsigned int mem_size = 0;
 
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+    {
+        pr_err("%s : Allocation from CMA failed\n", __func__);
+        return -1;
+    }
+#endif
+
 #ifdef MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif	
@@ -3523,6 +3532,9 @@ static int gc2035_close(struct file *file)
 #endif	
 	wake_unlock(&(dev->wake_lock));
 
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/gt2005.c b/drivers/amlogic/camera/gt2005.c
index 38783098e735..e549cd4d576f 100755
--- a/drivers/amlogic/camera/gt2005.c
+++ b/drivers/amlogic/camera/gt2005.c
@@ -2352,6 +2352,11 @@ static int gt2005_open(struct file *file)
 	struct gt2005_device *dev = video_drvdata(file);
 	struct gt2005_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2488,6 +2493,9 @@ static int gt2005_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/hi2056.c b/drivers/amlogic/camera/hi2056.c
index 666df6c4aae5..015d8d2109f5 100755
--- a/drivers/amlogic/camera/hi2056.c
+++ b/drivers/amlogic/camera/hi2056.c
@@ -2090,6 +2090,11 @@ static int hi2056_open(struct file *file)
 	struct hi2056_device *dev = video_drvdata(file);
 	struct hi2056_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 	switch_mod_gate_by_name("mipi", 1);
@@ -2226,6 +2231,9 @@ static int hi2056_close(struct file *file)
 	switch_mod_gate_by_name("mipi", 0);
 #endif
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/hi253.c b/drivers/amlogic/camera/hi253.c
index be4d807c11a3..008ded0ac7a4 100755
--- a/drivers/amlogic/camera/hi253.c
+++ b/drivers/amlogic/camera/hi253.c
@@ -2774,6 +2774,11 @@ static int hi253_open(struct file *file)
 	struct hi253_device *dev = video_drvdata(file);
 	struct hi253_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2904,6 +2909,9 @@ static int hi253_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/hi704.c b/drivers/amlogic/camera/hi704.c
index 149b95c5138b..4abc15980db2 100755
--- a/drivers/amlogic/camera/hi704.c
+++ b/drivers/amlogic/camera/hi704.c
@@ -2327,6 +2327,11 @@ static int HI704_open(struct file *file)
 	struct HI704_device *dev = video_drvdata(file);
 	struct HI704_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -2458,6 +2463,9 @@ static int HI704_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/hm2057.c b/drivers/amlogic/camera/hm2057.c
index 963c6e678200..6c1ef957c6df 100755
--- a/drivers/amlogic/camera/hm2057.c
+++ b/drivers/amlogic/camera/hm2057.c
@@ -2444,6 +2444,15 @@ static int hm2057_open(struct file *file)
 	struct hm2057_fh *fh = NULL;
 	int retval = 0;
 
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+    {
+        pr_err("%s : Allocation from CMA failed\n", __func__);
+        return -1;
+    }
+#endif
+
 #ifdef CONFIG_ARCH_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif	
@@ -2575,6 +2584,9 @@ static int hm2057_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/nt99250.c b/drivers/amlogic/camera/nt99250.c
index 4051e3ee7265..8a3ab202e5fd 100755
--- a/drivers/amlogic/camera/nt99250.c
+++ b/drivers/amlogic/camera/nt99250.c
@@ -2569,6 +2569,11 @@ static int nt99250_open(struct file *file)
 	struct nt99250_device *dev = video_drvdata(file);
 	struct nt99250_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2705,6 +2710,9 @@ static int nt99250_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/nt99252.c b/drivers/amlogic/camera/nt99252.c
index 0b4dd95731e3..9c2a4dfb3be4 100755
--- a/drivers/amlogic/camera/nt99252.c
+++ b/drivers/amlogic/camera/nt99252.c
@@ -1971,6 +1971,11 @@ static int nt99252_open(struct file *file)
 	struct nt99252_device *dev = video_drvdata(file);
 	struct nt99252_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2102,6 +2107,9 @@ static int nt99252_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/nt99340.c b/drivers/amlogic/camera/nt99340.c
index 6d5673db924c..cc499c15ac34 100755
--- a/drivers/amlogic/camera/nt99340.c
+++ b/drivers/amlogic/camera/nt99340.c
@@ -1958,6 +1958,11 @@ static int nt99340_open(struct file *file)
 	struct nt99340_device *dev = video_drvdata(file);
 	struct nt99340_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2089,6 +2094,9 @@ static int nt99340_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/ov2655.c b/drivers/amlogic/camera/ov2655.c
index a7e9cd044004..1817df43b79e 100755
--- a/drivers/amlogic/camera/ov2655.c
+++ b/drivers/amlogic/camera/ov2655.c
@@ -2478,6 +2478,11 @@ static int ov2655_open(struct file *file)
 	struct ov2655_device *dev = video_drvdata(file);
 	struct ov2655_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	ov2655_have_opened=1;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -2611,6 +2616,9 @@ static int ov2655_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/ov3660.c b/drivers/amlogic/camera/ov3660.c
index 9b7eaab89bfe..a18c77e5cd5c 100755
--- a/drivers/amlogic/camera/ov3660.c
+++ b/drivers/amlogic/camera/ov3660.c
@@ -2346,6 +2346,11 @@ static int ov3660_open(struct file *file)
 	struct ov3660_device *dev = video_drvdata(file);
 	struct ov3660_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2472,6 +2477,9 @@ static int ov3660_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/ov5640.c b/drivers/amlogic/camera/ov5640.c
index df6477fe8545..2327e838a161 100755
--- a/drivers/amlogic/camera/ov5640.c
+++ b/drivers/amlogic/camera/ov5640.c
@@ -4405,6 +4405,13 @@ static int ov5640_open(struct file *file)
 	int retval = 0;
 	//int reg_val;
 	//int i = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0) {
+    	printk("error: no cma memory\n");
+        return -1;
+    }
+#endif
 	mutex_lock(&firmware_mutex);
 	ov5640_have_opened=1;
 	mutex_unlock(&firmware_mutex);
@@ -4552,6 +4559,9 @@ static int ov5640_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/ov5642.c b/drivers/amlogic/camera/ov5642.c
index c55f7a7b25b5..e1c4138ffdbb 100755
--- a/drivers/amlogic/camera/ov5642.c
+++ b/drivers/amlogic/camera/ov5642.c
@@ -3167,6 +3167,11 @@ static int ov5642_open(struct file *file)
 	int retval = 0;
 	//int reg_val;
 	//int i = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	ov5642_have_opened=1;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -3301,6 +3306,9 @@ static int ov5642_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/ov5647.c b/drivers/amlogic/camera/ov5647.c
index 8423b1cea30b..6cd252643c61 100755
--- a/drivers/amlogic/camera/ov5647.c
+++ b/drivers/amlogic/camera/ov5647.c
@@ -4252,6 +4252,11 @@ static int ov5647_open(struct file *file)
     unsigned int mem_size = 0;
     int retval = 0;
     capture_proc = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(24*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
     switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -4481,6 +4486,9 @@ static int ov5647_close(struct file *file)
     class_remove_file(cam_class,&class_attr_version_debug);
     class_destroy(cam_class);
     printk("close success\n");
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
     return 0;
 }
 
diff --git a/drivers/amlogic/camera/ov7675.c b/drivers/amlogic/camera/ov7675.c
index 029255c7b3e2..743434d49376 100755
--- a/drivers/amlogic/camera/ov7675.c
+++ b/drivers/amlogic/camera/ov7675.c
@@ -1817,6 +1817,11 @@ static int ov7675_open(struct file *file)
 	struct ov7675_fh *fh = NULL;
 	int retval = 0;
 
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 	ov7675_have_opened=1;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
@@ -1947,6 +1952,9 @@ static int ov7675_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/sp0838.c b/drivers/amlogic/camera/sp0838.c
index e46f201026ac..d101f1e7a6ad 100755
--- a/drivers/amlogic/camera/sp0838.c
+++ b/drivers/amlogic/camera/sp0838.c
@@ -1927,6 +1927,11 @@ static int sp0838_open(struct file *file)
 	struct sp0838_device *dev = video_drvdata(file);
 	struct sp0838_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2055,7 +2060,10 @@ static int sp0838_close(struct file *file)
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
-	wake_unlock(&(dev->wake_lock));	
+	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/sp0a19.c b/drivers/amlogic/camera/sp0a19.c
index b767face6ab7..b365777c3330 100755
--- a/drivers/amlogic/camera/sp0a19.c
+++ b/drivers/amlogic/camera/sp0a19.c
@@ -2680,6 +2680,11 @@ static int sp0a19_open(struct file *file)
 	struct sp0a19_device *dev = video_drvdata(file);
 	struct sp0a19_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2809,6 +2814,9 @@ static int sp0a19_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
 	wake_unlock(&(dev->wake_lock));	
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/camera/sp2518.c b/drivers/amlogic/camera/sp2518.c
index 7b04be454626..83c1c981c53b 100755
--- a/drivers/amlogic/camera/sp2518.c
+++ b/drivers/amlogic/camera/sp2518.c
@@ -2456,6 +2456,11 @@ static int sp2518_open(struct file *file)
 	struct sp2518_device *dev = video_drvdata(file);
 	struct sp2518_fh *fh = NULL;
 	int retval = 0;
+#if CONFIG_CMA
+    retval = vm_init_buf(16*SZ_1M);
+    if(retval <0)
+        return -1;
+#endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif		
@@ -2587,6 +2592,9 @@ static int sp2518_close(struct file *file)
 	switch_mod_gate_by_name("ge2d", 0);
 #endif		
 	wake_unlock(&(dev->wake_lock));
+#ifdef CONFIG_CMA
+    vm_deinit_buf();
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/input/sensor/common.c b/drivers/amlogic/input/sensor/common.c
index 53261b83fbb8..c459c0050f55 100644
--- a/drivers/amlogic/input/sensor/common.c
+++ b/drivers/amlogic/input/sensor/common.c
@@ -173,6 +173,7 @@ int dt_sensor_setup_i2c_dev(struct device_node *node,  struct i2c_board_info *i2
             r = of_property_read_u32(node, "irq",&irq);
             if(r < 0 || irq <= 0)
             {
+                *gpio = -1; 
                 i2c_info->irq = 0;
             }
             else
diff --git a/drivers/base/dma-contiguous.c b/drivers/base/dma-contiguous.c
index 0ca54421ce97..74f26c910506 100644
--- a/drivers/base/dma-contiguous.c
+++ b/drivers/base/dma-contiguous.c
@@ -24,6 +24,9 @@
 
 #include <linux/memblock.h>
 #include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_platform.h>
 #include <linux/mm.h>
 #include <linux/mutex.h>
 #include <linux/page-isolation.h>
@@ -33,13 +36,52 @@
 #include <linux/mm_types.h>
 #include <linux/dma-contiguous.h>
 
+
+#define CMA_REGION_NAME_MAX 64
+
 struct cma {
 	unsigned long	base_pfn;
 	unsigned long	count;
 	unsigned long	*bitmap;
 };
 
-struct cma *dma_contiguous_default_area;
+static DEFINE_MUTEX(cma_mutex);
+
+struct cma *dma_contiguous_def_area;
+phys_addr_t dma_contiguous_def_base;
+
+static struct cma_area {
+	phys_addr_t base;
+	unsigned long size;
+	struct cma *cma;
+    char name[CMA_REGION_NAME_MAX];
+} cma_areas[MAX_CMA_AREAS] ;
+static unsigned cma_area_count ;
+
+
+static struct cma_map {
+	phys_addr_t base;
+	struct device *dev;
+} cma_maps[MAX_CMA_AREAS] ;
+static unsigned cma_map_count ;
+
+static struct cma *cma_get_area(phys_addr_t base)
+{
+	int i;
+	for (i = 0; i < cma_area_count; i++)
+		if (cma_areas[i].base == base)
+			return cma_areas[i].cma;
+	return NULL;
+}
+
+static struct cma *cma_get_area_by_name(const char *name)
+{
+	int i;
+	for (i = 0; i < cma_area_count; i++)
+		if (strncmp(cma_areas[i].name, name, strlen(name)) == 0)
+			return cma_areas[i].cma;
+	return NULL;
+}
 
 #ifdef CONFIG_CMA_SIZE_MBYTES
 #define CMA_SIZE_MBYTES CONFIG_CMA_SIZE_MBYTES
@@ -95,45 +137,6 @@ static inline __maybe_unused phys_addr_t cma_early_percent_memory(void)
 
 #endif
 
-/**
- * dma_contiguous_reserve() - reserve area for contiguous memory handling
- * @limit: End address of the reserved memory (optional, 0 for any).
- *
- * This function reserves memory from early allocator. It should be
- * called by arch specific code once the early allocator (memblock or bootmem)
- * has been activated and all other subsystems have already allocated/reserved
- * memory.
- */
-void __init dma_contiguous_reserve(phys_addr_t limit)
-{
-	phys_addr_t selected_size = 0;
-
-	pr_debug("%s(limit %08lx)\n", __func__, (unsigned long)limit);
-
-	if (size_cmdline != -1) {
-		selected_size = size_cmdline;
-	} else {
-#ifdef CONFIG_CMA_SIZE_SEL_MBYTES
-		selected_size = size_bytes;
-#elif defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)
-		selected_size = cma_early_percent_memory();
-#elif defined(CONFIG_CMA_SIZE_SEL_MIN)
-		selected_size = min(size_bytes, cma_early_percent_memory());
-#elif defined(CONFIG_CMA_SIZE_SEL_MAX)
-		selected_size = max(size_bytes, cma_early_percent_memory());
-#endif
-	}
-
-	if (selected_size) {
-		pr_debug("%s: reserving %ld MiB for global area\n", __func__,
-			 (unsigned long)selected_size / SZ_1M);
-
-		dma_declare_contiguous(NULL, selected_size, 0, limit);
-	}
-};
-
-static DEFINE_MUTEX(cma_mutex);
-
 static __init int cma_activate_area(unsigned long base_pfn, unsigned long count)
 {
 	unsigned long pfn = base_pfn;
@@ -190,55 +193,117 @@ no_mem:
 	return ERR_PTR(ret);
 }
 
-static struct cma_reserved {
-	phys_addr_t start;
-	unsigned long size;
-	struct device *dev;
-} cma_reserved[MAX_CMA_AREAS] __initdata;
-static unsigned cma_reserved_count __initdata;
+/*****************************************************************************/
 
-static int __init cma_init_reserved_areas(void)
+#ifdef CONFIG_OF
+int __init cma_fdt_scan(unsigned long node, const char *uname,
+				int depth, void *data)
 {
-	struct cma_reserved *r = cma_reserved;
-	unsigned i = cma_reserved_count;
-
-	pr_debug("%s()\n", __func__);
+    int ret;
+    char *p;
+    unsigned long l;
+	phys_addr_t base, size;
+	unsigned long len;
+	__be32 *prop;
+
+	if (strncmp(uname, "region@", 7) != 0 || depth != 2 ||
+	    !of_get_flat_dt_prop(node, "linux,contiguous-region", NULL))
+		return 0;
+
+	prop = of_get_flat_dt_prop(node, "reg", &len);
+	if (!prop || (len != 2 * sizeof(unsigned long)))
+		return 0;
+
+	base = be32_to_cpu(prop[0]);
+	size = be32_to_cpu(prop[1]);
+
+	pr_info("Found %s, memory base %lx, size %ld MiB\n", uname,
+		(unsigned long)base, (unsigned long)size / SZ_1M);
+	ret = dma_contiguous_reserve_area(size, &base, 0);
+    if(ret == 0)
+    {
+        p = of_get_flat_dt_prop(node, "region_name", &l);
+        if(p != 0 && l > 0)
+            strncpy(cma_areas[cma_area_count - 1].name, p, CMA_REGION_NAME_MAX); 
+    }
 
-	for (; i; --i, ++r) {
-		struct cma *cma;
-		cma = cma_create_area(PFN_DOWN(r->start),
-				      r->size >> PAGE_SHIFT);
-		if (!IS_ERR(cma))
-			dev_set_cma_area(r->dev, cma);
-	}
 	return 0;
 }
-core_initcall(cma_init_reserved_areas);
+#endif
 
 /**
- * dma_declare_contiguous() - reserve area for contiguous memory handling
- *			      for particular device
- * @dev:   Pointer to device structure.
- * @size:  Size of the reserved memory.
- * @base:  Start address of the reserved memory (optional, 0 for any).
+ * dma_contiguous_reserve() - reserve area for contiguous memory handling
+ * @limit: End address of the reserved memory (optional, 0 for any).
+ *
+ * This function reserves memory from early allocator. It should be
+ * called by arch specific code once the early allocator (memblock or bootmem)
+ * has been activated and all other subsystems have already allocated/reserved
+ * memory. It reserves contiguous areas for global, device independent
+ * allocations and (optionally) all areas defined in device tree structures.
+ */
+void __init dma_contiguous_reserve(phys_addr_t limit)
+{
+	phys_addr_t sel_size = 0;
+
+	pr_debug("%s(limit %08lx)\n", __func__, (unsigned long)limit);
+
+	if (size_cmdline != -1) {
+		sel_size = size_cmdline;
+	} else {
+#ifdef CONFIG_CMA_SIZE_SEL_MBYTES
+		sel_size = size_bytes;
+#elif defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)
+		sel_size = cma_early_percent_memory();
+#elif defined(CONFIG_CMA_SIZE_SEL_MIN)
+		sel_size = min(size_bytes, cma_early_percent_memory());
+#elif defined(CONFIG_CMA_SIZE_SEL_MAX)
+		sel_size = max(size_bytes, cma_early_percent_memory());
+#endif
+	}
+
+	if (sel_size) {
+		phys_addr_t base = 0;
+		pr_debug("%s: reserving %ld MiB for global area\n", __func__,
+			 (unsigned long)sel_size / SZ_1M);
+
+		if (dma_contiguous_reserve_area(sel_size, &base, limit) == 0)
+        {
+			dma_contiguous_def_base = base;
+            strcpy(cma_areas[cma_area_count - 1].name, "cma_global"); 
+        }
+	}
+#ifdef CONFIG_OF
+	of_scan_flat_dt(cma_fdt_scan, NULL);
+#endif
+};
+
+/**
+ * dma_contiguous_reserve_area() - reserve custom contiguous area
+ * @size: Size of the reserved area (in bytes),
+ * @base: Pointer to the base address of the reserved area, also used to return
+ * 	  base address of the actually reserved area, optional, use pointer to
+ *	  0 for any
  * @limit: End address of the reserved memory (optional, 0 for any).
  *
- * This function reserves memory for specified device. It should be
- * called by board specific code when early allocator (memblock or bootmem)
- * is still activate.
+ * This function reserves memory from early allocator. It should be
+ * called by arch specific code once the early allocator (memblock or bootmem)
+ * has been activated and all other subsystems have already allocated/reserved
+ * memory. This function allows to create custom reserved areas for specific
+ * devices.
  */
-int __init dma_declare_contiguous(struct device *dev, phys_addr_t size,
-				  phys_addr_t base, phys_addr_t limit)
+int __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t *res_base,
+				       phys_addr_t limit)
 {
-	struct cma_reserved *r = &cma_reserved[cma_reserved_count];
+	phys_addr_t base = *res_base;
 	phys_addr_t alignment;
+	int ret = 0;
 
 	pr_debug("%s(size %lx, base %08lx, limit %08lx)\n", __func__,
 		 (unsigned long)size, (unsigned long)base,
 		 (unsigned long)limit);
 
 	/* Sanity checks */
-	if (cma_reserved_count == ARRAY_SIZE(cma_reserved)) {
+	if (cma_area_count == ARRAY_SIZE(cma_areas)) {
 		pr_err("Not enough slots for CMA reserved regions!\n");
 		return -ENOSPC;
 	}
@@ -256,7 +321,7 @@ int __init dma_declare_contiguous(struct device *dev, phys_addr_t size,
 	if (base) {
 		if (memblock_is_region_reserved(base, size) ||
 		    memblock_reserve(base, size) < 0) {
-			base = -EBUSY;
+			ret = -EBUSY;
 			goto err;
 		}
 	} else {
@@ -266,7 +331,7 @@ int __init dma_declare_contiguous(struct device *dev, phys_addr_t size,
 		 */
 		phys_addr_t addr = __memblock_alloc_base(size, alignment, limit);
 		if (!addr) {
-			base = -ENOMEM;
+			ret = -ENOMEM;
 			goto err;
 		} else {
 			base = addr;
@@ -277,10 +342,11 @@ int __init dma_declare_contiguous(struct device *dev, phys_addr_t size,
 	 * Each reserved area must be initialised later, when more kernel
 	 * subsystems (like slab allocator) are available.
 	 */
-	r->start = base;
-	r->size = size;
-	r->dev = dev;
-	cma_reserved_count++;
+	cma_areas[cma_area_count].base = base;
+	cma_areas[cma_area_count].size = size;
+	cma_area_count++;
+	*res_base = base;
+
 	pr_info("CMA: reserved %ld MiB at %08lx\n", (unsigned long)size / SZ_1M,
 		(unsigned long)base);
 
@@ -289,9 +355,108 @@ int __init dma_declare_contiguous(struct device *dev, phys_addr_t size,
 	return 0;
 err:
 	pr_err("CMA: failed to reserve %ld MiB\n", (unsigned long)size / SZ_1M);
-	return base;
+	return ret;
+}
+
+/**
+ * dma_contiguous_add_device() - add device to custom contiguous reserved area
+ * @dev:   Pointer to device structure.
+ * @base: Pointer to the base address of the reserved area returned by
+ *        dma_contiguous_reserve_area() function, also used to return
+ *
+ * This function assigns the given device to the contiguous memory area
+ * reserved earlier by dma_contiguous_reserve_area() function.
+ */
+int __init dma_contiguous_add_device(struct device *dev, phys_addr_t base)
+{
+	if (cma_map_count == ARRAY_SIZE(cma_maps)) {
+		pr_err("Not enough slots for CMA reserved regions!\n");
+		return -ENOSPC;
+	}
+	cma_maps[cma_map_count].dev = dev;
+	cma_maps[cma_map_count].base = base;
+	cma_map_count++;
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static void cma_assign_device_from_dt(struct device *dev)
+{
+    int ret;
+    const char *name;
+	struct device_node *node;
+	struct cma *cma;
+	u32 value;
+
+	node = of_parse_phandle(dev->of_node, "linux,contiguous-region", 0);
+	if (!node)
+		return;
+	if (of_property_read_u32(node, "reg", &value) && !value)
+		return;
+	cma = cma_get_area(value);
+
+	if (cma)
+    {
+        pr_info("Assigned CMA region at %lx to %s device\n", (unsigned long)value, dev_name(dev));
+        dev_set_cma_area(dev, cma);
+        return;
+    }
+
+    ret = of_property_read_string(node, "region_name", &name);
+    if (ret == 0)
+    {
+        cma = cma_get_area_by_name(name);
+        if (!cma)
+            return;
+
+        pr_info("Assigned CMA region with name %s to %s device\n", name, dev_name(dev));
+        dev_set_cma_area(dev, cma);
+    }
+
+}
+
+static int cma_device_init_notifier_call(struct notifier_block *nb,
+					 unsigned long event, void *data)
+{
+	struct device *dev = data;
+	if (event == BUS_NOTIFY_ADD_DEVICE && dev->of_node)
+		cma_assign_device_from_dt(dev);
+	return NOTIFY_DONE;
 }
 
+static struct notifier_block cma_dev_init_nb = {
+	.notifier_call = cma_device_init_notifier_call,
+};
+#endif
+
+static int __init cma_init_reserved_areas(void)
+{
+	struct cma *cma;
+	int i;
+
+	for (i = 0; i < cma_area_count; i++) {
+		phys_addr_t base = PFN_DOWN(cma_areas[i].base);
+		unsigned int count = cma_areas[i].size >> PAGE_SHIFT;
+
+		cma = cma_create_area(base, count);
+		if (!IS_ERR(cma))
+			cma_areas[i].cma = cma;
+	}
+
+	dma_contiguous_def_area = cma_get_area(dma_contiguous_def_base);
+
+	for (i = 0; i < cma_map_count; i++) {
+		cma = cma_get_area(cma_maps[i].base);
+		dev_set_cma_area(cma_maps[i].dev, cma);
+	}
+
+#ifdef CONFIG_OF
+	bus_register_notifier(&platform_bus_type, &cma_dev_init_nb);
+#endif
+	return 0;
+}
+core_initcall(cma_init_reserved_areas);
+
 /**
  * dma_alloc_from_contiguous() - allocate pages from contiguous area
  * @dev:   Pointer to device for which the allocation is performed.
diff --git a/drivers/staging/android/lowmemorykiller.c b/drivers/staging/android/lowmemorykiller.c
index a56e0894f668..84ee8ddae9f2 100644
--- a/drivers/staging/android/lowmemorykiller.c
+++ b/drivers/staging/android/lowmemorykiller.c
@@ -78,6 +78,11 @@ static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
 	short selected_oom_score_adj;
 	int array_size = ARRAY_SIZE(lowmem_adj);
 	int other_free = global_page_state(NR_FREE_PAGES) - totalreserve_pages;
+
+    /* For request of unmovable pages, take no account of free CMA pages*/
+    if(IS_ENABLED(CONFIG_CMA) && (allocflags_to_migratetype(sc->gfp_mask) != MIGRATE_MOVABLE))
+        other_free -= global_page_state(NR_FREE_CMA_PAGES);
+
 	int other_file = global_page_state(NR_FILE_PAGES) -
 						global_page_state(NR_SHMEM);
 
diff --git a/include/asm-generic/dma-contiguous.h b/include/asm-generic/dma-contiguous.h
index 294b1e755ab2..9071ef11d083 100644
--- a/include/asm-generic/dma-contiguous.h
+++ b/include/asm-generic/dma-contiguous.h
@@ -11,15 +11,13 @@ static inline struct cma *dev_get_cma_area(struct device *dev)
 {
 	if (dev && dev->cma_area)
 		return dev->cma_area;
-	return dma_contiguous_default_area;
+	return dma_contiguous_def_area;
 }
 
 static inline void dev_set_cma_area(struct device *dev, struct cma *cma)
 {
 	if (dev)
 		dev->cma_area = cma;
-	if (!dev && !dma_contiguous_default_area)
-		dma_contiguous_default_area = cma;
 }
 
 #endif
diff --git a/include/linux/amlogic/vmapi.h b/include/linux/amlogic/vmapi.h
index 02da683ff9ae..c4a78d638498 100755
--- a/include/linux/amlogic/vmapi.h
+++ b/include/linux/amlogic/vmapi.h
@@ -17,4 +17,11 @@ typedef struct vm_output_para{
 
 int vm_fill_buffer(struct videobuf_buffer* vb , vm_output_para_t* para);
 
+#ifdef CONFIG_CMA
+
+int vm_init_buf(size_t size);
+void vm_deinit_buf(void);
+void vm_reserve_cma(void);
+#endif
+
 #endif /* VM_API_INCLUDE_ */
diff --git a/include/linux/dma-contiguous.h b/include/linux/dma-contiguous.h
old mode 100644
new mode 100755
index 01b5c84be828..3216448a5c10
--- a/include/linux/dma-contiguous.h
+++ b/include/linux/dma-contiguous.h
@@ -65,11 +65,50 @@ struct device;
  */
 #define MAX_CMA_AREAS	(1 + CONFIG_CMA_AREAS)
 
-extern struct cma *dma_contiguous_default_area;
+extern struct cma *dma_contiguous_def_area;
+
+static inline struct cma *dev_get_cma_area(struct device *dev)
+{
+        if (dev && dev->cma_area)
+                return dev->cma_area;
+        return dma_contiguous_def_area;
+}
+
+static inline void dev_set_cma_area(struct device *dev, struct cma *cma)
+{
+        if (dev)
+                dev->cma_area = cma;
+}
 
 void dma_contiguous_reserve(phys_addr_t addr_limit);
-int dma_declare_contiguous(struct device *dev, phys_addr_t size,
-			   phys_addr_t base, phys_addr_t limit);
+
+int dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t *res_base,
+				  phys_addr_t limit);
+
+int dma_contiguous_add_device(struct device *dev, phys_addr_t base);
+
+/**
+ * dma_declare_contiguous() - reserve area for contiguous memory handling
+ *			      for particular device
+ * @dev:   Pointer to device structure.
+ * @size:  Size of the reserved memory.
+ * @base:  Start address of the reserved memory (optional, 0 for any).
+ * @limit: End address of the reserved memory (optional, 0 for any).
+ *
+ * This function reserves memory for specified device. It should be
+ * called by board specific code when early allocator (memblock or bootmem)
+ * is still activate.
+ */
+
+static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
+					 phys_addr_t base, phys_addr_t limit)
+{
+	int ret;
+	ret = dma_contiguous_reserve_area(size, &base, limit);
+	if (ret == 0)
+		ret = dma_contiguous_add_device(dev, base);
+	return ret;
+}
 
 struct page *dma_alloc_from_contiguous(struct device *dev, int count,
 				       unsigned int order);
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index b21acf4a8212..1c8766699177 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -1337,7 +1337,8 @@ void free_hot_cold_page(struct page *page, int cold)
 	 * excessively into the page allocator
 	 */
 	if (migratetype >= MIGRATE_PCPTYPES) {
-		if (unlikely(is_migrate_isolate(migratetype))) {
+		if (unlikely(is_migrate_isolate(migratetype))
+            || unlikely(is_migrate_cma(migratetype))) {
 			free_one_page(zone, page, 0, migratetype);
 			goto out;
 		}
-- 
2.19.0

