From e146c275373a0d3ec0433e36912de8c895d21aac Mon Sep 17 00:00:00 2001
From: xu xing <xing.xu@amlogic.com>
Date: Thu, 6 Mar 2014 11:26:40 +0800
Subject: [PATCH 3596/5965] PD#87250:clean warning for kernel

commit 74c66196b4aadad3eb9fa8baacbd137cd3e448e1
Author: zhi.zhou <zhi.zhou@amlogic.com>
Date:   Fri Feb 21 18:52:58 2014 +0800

    PD#87250 amports:clean up compile warning.

    Conflicts:

    	drivers/amlogic/amports/video.c

commit d0ea55670567434c8ad605d6f43c49f5ef67a7fe
Author: chengshun.wang <chengshun.wang@amlogic.com>
Date:   Thu Feb 20 19:21:26 2014 +0800

    PD# 87250: [audio codec]: clean up compile warning

commit b96b241eb54dbe467e29fcf291c67ffb8df4ddcb
Author: zedong.xiong <zedong.xiong@amlogic.com>
Date:   Thu Feb 20 16:56:47 2014 +0800

    PD 87250:amaudio and audiodsp:clean up compile warning.

commit 1858fa064392d5d26642e90bb46afbdac7fc7041
Author: tao.zeng <tao.zeng@amlogic.com>
Date:   Thu Feb 20 09:56:09 2014 +0800

    PD #87250: Remove compile warning for PMU driver.

commit 8dc84c669195437b247a60cab62f83d48fb8c8c9
Author: shi.liu <shi.liu@amlogic.com>
Date:   Thu Feb 20 10:51:17 2014 +0800

    PD:#87250:cpufreq:  remove warning

commit 5dbc77c960c2f9b1ddf011272ff1d9e6b785201a
Author: xiaoyu.yuan <xiaoyu.yuan@droid05.amlogic.com>
Date:   Thu Feb 20 10:18:15 2014 +0800

    PD #87250 : remove config parse warning message

commit dc197355d9d24da2a2495f7595a3b30bacb30e07
Author: benlong.zhou <benlong.zhou@amlogic.com>
Date:   Wed Feb 19 20:12:04 2014 +0800

    efuse: modified CLK_GATE_ON warning

commit c57f4e7d19ccf24c1be584d1a493666b8eca6cb2
Author: wei.nie <wei.nie@amlogic.com>
Date:   Wed Feb 19 19:31:28 2014 +0800

    PD #87250:OSD&LOGO clean up compile warning

commit 5b423fb0267cd2070ef6e2db0611251a020efa94
Author: zhenfei.li <zhenfei.li@amlogic>
Date:   Wed Feb 19 18:59:14 2014 +0800

    PD #87250: rm warings of aml_rtc driver.

commit 516b0859499926e637ce362ae7d1ff7d71108397
Author: zhenfei.li <zhenfei.li@amlogic>
Date:   Wed Feb 19 18:42:07 2014 +0800

    PD #87250: remove the warnings of the cameras.
---
 .../arm/mach-meson8/include/mach/power_gate.h |  4 +-
 drivers/amlogic/amaudio/amaudio.c             |  4 +
 drivers/amlogic/amports/jpegdec.c             |  4 +-
 drivers/amlogic/amports/jpegenc.c             |  5 +-
 drivers/amlogic/amports/subtitle.c            |  6 +-
 drivers/amlogic/amports/tsdemux.c             |  2 +-
 drivers/amlogic/amports/tsync.c               |  2 +-
 drivers/amlogic/amports/vdec.h                |  2 +
 drivers/amlogic/amports/vmpeg4.c              |  1 -
 drivers/amlogic/amports/vreal.c               |  6 +-
 drivers/amlogic/audiodsp/audiodsp_module.c    | 22 ++---
 drivers/amlogic/audiodsp/dsp_control.c        |  4 +-
 drivers/amlogic/audiodsp/dsp_mailbox.c        |  2 +-
 drivers/amlogic/camera/ar0543.c               | 86 ++++++++----------
 drivers/amlogic/camera/ar0833.c               | 89 ++++++++++---------
 drivers/amlogic/camera/common/cam_prober.c    |  4 +-
 drivers/amlogic/camera/common/config_parser.c | 13 ++-
 drivers/amlogic/camera/common/config_parser.h | 16 ++--
 drivers/amlogic/camera/gc0307.c               |  2 +-
 drivers/amlogic/camera/gc0328.c               |  2 +-
 drivers/amlogic/camera/gc0329.c               |  2 +-
 drivers/amlogic/camera/gc2015.c               |  2 +-
 drivers/amlogic/camera/hi704.c                |  2 +-
 drivers/amlogic/camera/nt99250.c              |  2 +-
 drivers/amlogic/camera/nt99252.c              |  2 +-
 drivers/amlogic/camera/nt99340.c              |  2 +-
 drivers/amlogic/camera/ov2655.c               |  2 +-
 drivers/amlogic/camera/ov3660.c               |  2 +-
 drivers/amlogic/camera/ov5640.c               | 17 ++--
 drivers/amlogic/camera/ov5642.c               |  2 +-
 drivers/amlogic/camera/ov7675.c               |  2 +-
 drivers/amlogic/camera/sp0838.c               | 16 ++--
 drivers/amlogic/camera/sp2518.c               |  2 +-
 drivers/amlogic/cpufreq/meson-cpufreq.c       | 10 +--
 .../aml_logo/logo_display/logo_output.c       |  2 +-
 .../aml_logo/logo_display/output_dev_osd.c    |  8 ++
 .../display/aml_logo/logo_parse/bmp_parser.c  |  2 +-
 .../display/aml_logo/logo_parse/jpeg_parser.c |  6 +-
 drivers/amlogic/display/osd/osd_main.c        |  4 +-
 drivers/amlogic/display/osd/osd_rdma.c        | 16 ++--
 drivers/amlogic/display/osd_ext/osd_hw.c      |  4 +-
 drivers/amlogic/display/vout/tvconf.c         |  1 +
 drivers/amlogic/display/vout/tvconf.h         |  1 -
 drivers/amlogic/rtc/aml_rtc.c                 |  4 +-
 drivers/cpufreq/cpufreq.c                     |  2 +-
 drivers/cpufreq/cpufreq_governor.c            |  2 +-
 include/linux/amlogic/camera/aml_cam_info.h   |  8 +-
 include/linux/amlogic/logo/logo_dev_osd.h     |  6 --
 sound/soc/aml/m8/aml_audio_hw.c               |  3 +
 sound/soc/aml/m8/aml_audio_hw_pcm2bt.c        |  4 +-
 sound/soc/aml/m8/aml_i2s.c                    | 27 +++---
 sound/soc/aml/m8/aml_i2s.h                    |  4 +-
 sound/soc/aml/m8/aml_i2s_dai.c                | 17 ++--
 sound/soc/aml/m8/aml_pcm.c                    | 13 +--
 sound/soc/aml/m8/aml_pcm_dai.c                | 13 +--
 sound/soc/aml/m8/aml_spdif_dai.c              | 53 ++++++-----
 sound/soc/codecs/aml_m8_codec.c               |  3 +-
 sound/soc/codecs/rt5616.c                     | 24 ++---
 sound/soc/codecs/rt5616.h                     |  2 +-
 sound/soc/codecs/rt5631.c                     |  1 +
 sound/soc/codecs/wm8960.c                     | 11 ++-
 sound/usb/card.c                              | 21 ++---
 62 files changed, 314 insertions(+), 289 deletions(-)
 mode change 100644 => 100755 sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
 mode change 100644 => 100755 sound/soc/aml/m8/aml_i2s.h
 mode change 100644 => 100755 sound/soc/aml/m8/aml_pcm.c
 mode change 100644 => 100755 sound/soc/aml/m8/aml_pcm_dai.c

diff --git a/arch/arm/mach-meson8/include/mach/power_gate.h b/arch/arm/mach-meson8/include/mach/power_gate.h
index 8dcf9e248ca2..999b0bf4570f 100755
--- a/arch/arm/mach-meson8/include/mach/power_gate.h
+++ b/arch/arm/mach-meson8/include/mach/power_gate.h
@@ -31,7 +31,7 @@ extern spinlock_t gate_lock;
 
 #define CLK_GATE_ON(_MOD) \
 	do{                     \
-		int flags; \
+		unsigned long flags; \
 		spin_lock_irqsave(&gate_lock, flags); \
 		__CLK_GATE_ON(_MOD); \
 		spin_unlock_irqrestore(&gate_lock, flags); \
@@ -39,7 +39,7 @@ extern spinlock_t gate_lock;
 	
 #define CLK_GATE_OFF(_MOD) \
 	do{                     \
-		int flags; \
+		unsigned long flags; \
 		spin_lock_irqsave(&gate_lock, flags); \
 		__CLK_GATE_OFF(_MOD); \
 		spin_unlock_irqrestore(&gate_lock, flags); \
diff --git a/drivers/amlogic/amaudio/amaudio.c b/drivers/amlogic/amaudio/amaudio.c
index af229fe27cea..30a913258c6c 100755
--- a/drivers/amlogic/amaudio/amaudio.c
+++ b/drivers/amlogic/amaudio/amaudio.c
@@ -1855,6 +1855,8 @@ static ssize_t show_resample_type(struct class* class, struct class_attribute* a
          return sprintf(buf, "DW\n");
      }else if(resample_type_flag==2){//2-->up resample processing
          return sprintf(buf, "UP\n");
+     }else{                          //other-->invalid resample type flag
+         return sprintf(buf, "IR\n");
      }
 }
 
@@ -1942,6 +1944,8 @@ static ssize_t record_type_show(struct class* class, struct class_attribute* att
          return sprintf(buf, "spdif in mode \n");
      }else if(audioin_mode&I2SIN_SLAVE_MODE){//i2s in slave
          return sprintf(buf, "i2s in slave mode \n");
+     }else{
+         return sprintf(buf, "audioin_mode can't match mode\n");
      }
 }
 static struct class_attribute amaudio_attrs[]={
diff --git a/drivers/amlogic/amports/jpegdec.c b/drivers/amlogic/amports/jpegdec.c
index 99f8108f1a1e..4ae4b55fb92d 100755
--- a/drivers/amlogic/amports/jpegdec.c
+++ b/drivers/amlogic/amports/jpegdec.c
@@ -56,13 +56,13 @@
 #define JPEGDEC_OUTPUT_CANVAS_V JPEGDEC_CANVAS_INDEX+2
 
 #define JPEGDEC_OUTPUT_CANVAS \
-    ((JPEGDEC_OUTPUT_CANVAS_V << 16) | (JPEGDEC_OUTPUT_CANVAS_U << 8) | (JPEGDEC_OUTPUT_CANVAS_Y))
+    (((JPEGDEC_OUTPUT_CANVAS_V) << 16) | ((JPEGDEC_OUTPUT_CANVAS_U) << 8) | (JPEGDEC_OUTPUT_CANVAS_Y))
 
 #define PSCALE_CANVAS_Y JPEGDEC_CANVAS_INDEX+3
 #define PSCALE_CANVAS_U JPEGDEC_CANVAS_INDEX+4
 #define PSCALE_CANVAS_V JPEGDEC_CANVAS_INDEX+5
 #define PSCALE_CANVAS \
-    ((PSCALE_CANVAS_V << 16) | (PSCALE_CANVAS_U << 8) | (PSCALE_CANVAS_Y))
+    (((PSCALE_CANVAS_V) << 16) | ((PSCALE_CANVAS_U) << 8) | ((PSCALE_CANVAS_Y)))
 
 #define JPEG_DECODE_START       AV_SCRATCH_0
 #define JPEG_INFO               AV_SCRATCH_0
diff --git a/drivers/amlogic/amports/jpegenc.c b/drivers/amlogic/amports/jpegenc.c
index 185e465e50f4..34cbadd29b5d 100755
--- a/drivers/amlogic/amports/jpegenc.c
+++ b/drivers/amlogic/amports/jpegenc.c
@@ -1652,7 +1652,10 @@ static long jpegenc_ioctl(struct file *file,
                 void  __user* argp =(void __user*)arg;
                 gExternalQuantTablePtr = kmalloc(sizeof(unsigned short)*DCTSIZE2*2, GFP_KERNEL);
                 if(gExternalQuantTablePtr){
-                    copy_from_user(gExternalQuantTablePtr,argp,sizeof(unsigned short)*DCTSIZE2*2);
+                    if(copy_from_user(gExternalQuantTablePtr,argp,sizeof(unsigned short)*DCTSIZE2*2)){
+                        r=-1;
+                        break;
+                    }
                     external_quant_table_available = true;
                     r = 0;
                 }else{
diff --git a/drivers/amlogic/amports/subtitle.c b/drivers/amlogic/amports/subtitle.c
index 98ce8a65a4fa..0f70180bfd18 100755
--- a/drivers/amlogic/amports/subtitle.c
+++ b/drivers/amlogic/amports/subtitle.c
@@ -437,12 +437,12 @@ static struct class_attribute subtitle_class_attrs[] = {
 	__ATTR(reset, 	S_IRUGO | S_IWUSR, show_reset,  store_reset),
     __ATTR_NULL
 };
-
+/*
 static struct class subtitle_class = {
         .name = "subtitle",
         .class_attrs = subtitle_class_attrs,
     };
-
+*/
 /*********************************************************
  * /dev/amvideo APIs
  *********************************************************/
@@ -526,7 +526,7 @@ static long amsubtitle_ioctl(struct file *file,
                 break;
             case SUB_DATA_T_DATA: {
                     if (states->subtitle_info > 0) {
-						states->subtitle_info = subtitle_data[subtitle_write_pos].data;
+                        states->subtitle_info = (int)subtitle_data[subtitle_write_pos].data;
                     }
 				}
                 break;
diff --git a/drivers/amlogic/amports/tsdemux.c b/drivers/amlogic/amports/tsdemux.c
index 40dcce6d45d5..7797ec9c9490 100755
--- a/drivers/amlogic/amports/tsdemux.c
+++ b/drivers/amlogic/amports/tsdemux.c
@@ -641,7 +641,7 @@ static int limited_delay_check(struct file *file,
 			return 0;
 	}
     write_size = min(stbuf_space(vbuf), stbuf_space(abuf));
-    write_size = min(count, write_size);
+    write_size = min((int)count, write_size);
 	return write_size;
 }
 
diff --git a/drivers/amlogic/amports/tsync.c b/drivers/amlogic/amports/tsync.c
index a25f6798a4b1..815e6adff83b 100755
--- a/drivers/amlogic/amports/tsync.c
+++ b/drivers/amlogic/amports/tsync.c
@@ -1391,7 +1391,7 @@ static ssize_t show_last_checkin_apts(struct class *class,
                            struct class_attribute *attr,
                            char *buf)
 {
-  unsigned long last_apts;
+  unsigned int last_apts;
   last_apts = get_last_checkin_pts(PTS_TYPE_AUDIO);
   return sprintf(buf, "0x%x\n",last_apts);
 }
diff --git a/drivers/amlogic/amports/vdec.h b/drivers/amlogic/amports/vdec.h
index 89acc40d569b..270ac6e57144 100755
--- a/drivers/amlogic/amports/vdec.h
+++ b/drivers/amlogic/amports/vdec.h
@@ -21,6 +21,8 @@
 
 #ifndef VDEC_H
 #define VDEC_H
+#include <mach/am_regs.h>
+#include <linux/platform_device.h>
 
 
 extern void vdec_set_decinfo(void *p);
diff --git a/drivers/amlogic/amports/vmpeg4.c b/drivers/amlogic/amports/vmpeg4.c
index 62b4d944e76e..a09b03933935 100755
--- a/drivers/amlogic/amports/vmpeg4.c
+++ b/drivers/amlogic/amports/vmpeg4.c
@@ -773,7 +773,6 @@ static void vmpeg4_local_init(void)
 static s32 vmpeg4_init(void)
 {
     int trickmode_fffb = 0;
-    dma_addr_t buf_start_map;
 
     query_video_status(0, &trickmode_fffb);
 
diff --git a/drivers/amlogic/amports/vreal.c b/drivers/amlogic/amports/vreal.c
index 010b06e303ed..d6fb38d727c9 100755
--- a/drivers/amlogic/amports/vreal.c
+++ b/drivers/amlogic/amports/vreal.c
@@ -396,7 +396,7 @@ static int  vreal_vf_states(vframe_states_t *states, void* op_arg)
 
     return 0;
 }
-
+#if 0
 #ifdef CONFIG_POST_PROCESS_MANAGER
 static void vreal_ppmgr_reset(void)
 {
@@ -407,7 +407,7 @@ static void vreal_ppmgr_reset(void)
     printk("vrealdec: vf_ppmgr_reset\n");
 }
 #endif
-
+#endif 
 static void vreal_put_timer_func(unsigned long arg)
 {
     struct timer_list *timer = (struct timer_list *)arg;
@@ -697,9 +697,7 @@ static void load_block_data(unsigned int dest, unsigned int count)
 
 s32 vreal_init(void)
 {
-    int trickmode_fffb = 0;
     int r;
-    dma_addr_t buf_start_map;
 
     printk("vreal_init\n");
 
diff --git a/drivers/amlogic/audiodsp/audiodsp_module.c b/drivers/amlogic/audiodsp/audiodsp_module.c
index 13765db425e9..2e322a89c318 100755
--- a/drivers/amlogic/audiodsp/audiodsp_module.c
+++ b/drivers/amlogic/audiodsp/audiodsp_module.c
@@ -113,14 +113,14 @@ static audiodsp_pm_state_t pm_state;
 
 static void audiodsp_prevent_sleep(void)
 {
-    struct audiodsp_priv* priv = audiodsp_privdata();
+    /*struct audiodsp_priv* priv = */audiodsp_privdata();
     printk("audiodsp prevent sleep\n");
     //wake_lock(&priv->wakelock);
 }
 
 static void audiodsp_allow_sleep(void)
 {
-    struct audiodsp_priv *priv=audiodsp_privdata();
+    /*struct audiodsp_priv *priv=*/audiodsp_privdata();
     printk("audiodsp allow sleep\n");
     //wake_unlock(&priv->wakelock);
 }
@@ -220,7 +220,7 @@ static unsigned long audiodsp_drop_pcm(unsigned long size)
 {
 	struct audiodsp_priv *priv = audiodsp_privdata();
 	size_t len;
-	int count;
+	int count = 0;
 	unsigned long drop_bytes = size;
 
 	mutex_lock(&priv->stream_buffer_mutex);
@@ -707,7 +707,7 @@ static ssize_t codec_fatal_err_show(struct class* cla, struct class_attribute* a
 	
     return sprintf(buf, "%d\n", priv->decode_fatal_err);
 }
-static ssize_t codec_fatal_err_store(struct class* cla, struct class_attribute* attr, char* buf,
+static ssize_t codec_fatal_err_store(struct class* cla, struct class_attribute* attr, const char* buf,
 	                                       size_t count)
 {
      struct audiodsp_priv *priv = audiodsp_privdata();
@@ -746,7 +746,7 @@ static ssize_t dsp_working_status_show(struct class* cla, struct class_attribute
     pbuf += sprintf(pbuf, "\tdsp jeffies  0x%lx\n", DSP_RD(DSP_JIFFIES));
     pbuf += sprintf(pbuf, "\tdsp pcm wp  0x%lx\n", DSP_RD(DSP_DECODE_OUT_WD_ADDR));
     pbuf += sprintf(pbuf, "\tdsp pcm rp  0x%lx\n", DSP_RD(DSP_DECODE_OUT_RD_ADDR));
-		 pbuf += sprintf(pbuf, "\tdsp pcm buffer level  0x%lx\n", dsp_codec_get_bufer_data_len(priv));
+    pbuf += sprintf(pbuf, "\tdsp pcm buffer level  0x%x\n", dsp_codec_get_bufer_data_len(priv));
     pbuf += sprintf(pbuf, "\tdsp pcm buffered size  0x%lx\n", DSP_RD(DSP_BUFFERED_LEN));
     pbuf += sprintf(pbuf, "\tdsp es read offset  0x%lx\n", DSP_RD(DSP_AFIFO_RD_OFFSET1));
 
@@ -923,7 +923,7 @@ static ssize_t dts_dec_control_show(struct class*cla, struct class_attribute* at
 	char *dialnorm[] = {"disable","enable"};	
 	char *pbuf = buf;
 	pbuf += sprintf(pbuf, "\tdts  dmx mode : %s\n", dmxmode[(dts_dec_control>>DTS_DMX_MODE_BIT)&0x1]);
-	pbuf += sprintf(pbuf, "\tdts  drc scale : %d%\n", (dts_dec_control>>DTS_DRC_SCALE_BIT)&0xff);
+	pbuf += sprintf(pbuf, "\tdts  drc scale : %d\n", (dts_dec_control>>DTS_DRC_SCALE_BIT)&0xff);
 	pbuf += sprintf(pbuf, "\tdts  dial norm : %s\n", dialnorm[(dts_dec_control>>DTS_DIAL_NORM_BIT)&0x1]);
 	return (pbuf-buf);
 }
@@ -949,7 +949,7 @@ static ssize_t dts_dec_control_store(struct class* class, struct class_attribute
  	else if(strncmp(tmpbuf, "dtsdrcscale", 11)==0){
         val=simple_strtoul(buf+i+1, NULL, 16); 	
 		val = val&0xff;
-		printk("dts drc  scale set to %d%\n",val);
+		printk("dts drc  scale set to %d\n",val);
 		dts_dec_control = (dts_dec_control&(~(0xff<<DTS_DRC_SCALE_BIT)))|(val<<DTS_DRC_SCALE_BIT);
  	}
  	else if(strncmp(tmpbuf, "dtsdialnorm", 11)==0){
@@ -985,7 +985,7 @@ static ssize_t dsp_debug_store(struct class* class, struct class_attribute* attr
 static ssize_t skip_rawbytes_show(struct class*cla, struct class_attribute* attr, char* buf)
 {
   unsigned long bytes = DSP_RD(DSP_SKIP_BYTES);
-  return sprintf(buf, "%d\n", bytes);
+  return sprintf(buf, "%ld\n", bytes);
 }
 
 static ssize_t skip_rawbytes_store(struct class* class, struct class_attribute* attr,
@@ -993,7 +993,7 @@ static ssize_t skip_rawbytes_store(struct class* class, struct class_attribute*
 {
   unsigned long bytes = simple_strtoul(buf, NULL, 16);
   DSP_WD(DSP_SKIP_BYTES, bytes);
-  printk("audio stream SKIP when ablevel>0x%x\n", bytes);
+  printk("audio stream SKIP when ablevel>0x%lx\n", bytes);
   return count;
 }
 
@@ -1013,7 +1013,7 @@ static struct class_attribute audiodsp_attrs[]={
     __ATTR_RO(swap_buf_ptr),
     __ATTR_RO(dsp_working_status),
     __ATTR(digital_raw, S_IRUGO | S_IWUSR, digital_raw_show, digital_raw_store),
-     __ATTR(digital_codec, S_IRUGO | S_IWUSR, digital_codec_show, digital_codec_store),
+    __ATTR(digital_codec, S_IRUGO | S_IWUSR, digital_codec_show, digital_codec_store),
     __ATTR(dec_option, S_IRUGO | S_IWUSR, dec_option_show, dec_option_store),
     __ATTR(print_flag, S_IRUGO | S_IWUSR, print_flag_show, print_flag_store),
     __ATTR(ac3_drc_control, S_IRUGO | S_IWUSR, ac3_drc_control_show, ac3_drc_control_store),
@@ -1027,7 +1027,7 @@ static struct class_attribute audiodsp_attrs[]={
 #ifdef CONFIG_PM
 static int audiodsp_suspend(struct device* dev, pm_message_t state)
 {
-     struct audiodsp_priv *priv = audiodsp_privdata();
+    /* struct audiodsp_priv *priv = */audiodsp_privdata();
 #if 0	 
     if(wake_lock_active(&priv->wakelock)){
         return -1; // please stop dsp first
diff --git a/drivers/amlogic/audiodsp/dsp_control.c b/drivers/amlogic/audiodsp/dsp_control.c
index d6795e4b0f51..da95bd8a8b74 100755
--- a/drivers/amlogic/audiodsp/dsp_control.c
+++ b/drivers/amlogic/audiodsp/dsp_control.c
@@ -140,7 +140,7 @@ void reset_dsp( struct audiodsp_priv *priv)
     
     DSP_WD(DSP_CHIP_SUBID, subid);
 
-    printk("reset dsp : dec opt=%x, subid=%x\n", DSP_RD(DSP_DECODE_OPTION), DSP_RD(DSP_CHIP_SUBID));
+    printk("reset dsp : dec opt=%lx, subid=%lx\n", DSP_RD(DSP_DECODE_OPTION), DSP_RD(DSP_CHIP_SUBID));
     if(!priv->dsp_is_started){
         DSP_PRNT("dsp reset now\n");
         enable_dsp(1);
@@ -335,7 +335,7 @@ exit:
  	}
 int   dsp_check_status(struct audiodsp_priv *priv)
 {
-	unsigned dsp_halt_score = 0;
+	//unsigned dsp_halt_score = 0;
 	unsigned ablevel  = 0;
 	int  pcmlevel = 0; 
 	if(DSP_RD(DSP_STATUS) != DSP_STATUS_RUNING)
diff --git a/drivers/amlogic/audiodsp/dsp_mailbox.c b/drivers/amlogic/audiodsp/dsp_mailbox.c
index a8bff072cddd..7beaeeec9aa3 100755
--- a/drivers/amlogic/audiodsp/dsp_mailbox.c
+++ b/drivers/amlogic/audiodsp/dsp_mailbox.c
@@ -107,7 +107,7 @@ int get_mailbox_data(struct audiodsp_priv *priv,int num,struct mail_msg *msg)
 static irqreturn_t audiodsp_mailbox_irq(int irq, void *data)
 {
 	struct audiodsp_priv *priv=(struct audiodsp_priv *)data;
-	unsigned long status,fiq_mask;
+	unsigned long status/*,fiq_mask*/;
 	struct mail_msg msg;
 	int i = 0;
 	status=READ_VREG(MB1_REG);
diff --git a/drivers/amlogic/camera/ar0543.c b/drivers/amlogic/camera/ar0543.c
index d5bf5558b904..7da651bf6b07 100755
--- a/drivers/amlogic/camera/ar0543.c
+++ b/drivers/amlogic/camera/ar0543.c
@@ -107,29 +107,11 @@ static struct class *cam_class;
 static unsigned int g_ae_manual_exp;
 static unsigned int g_ae_manual_ag;
 static unsigned int g_ae_manual_vts;
-static unsigned int exp_mode;
-static unsigned int change_cnt;
 static unsigned int current_fmt;
 static unsigned int current_fr = 0;//50 hz
 static unsigned int aet_index;
 static unsigned int last_af_step = 0;
 
-#define HI2056_CAMERA_MODULE_NAME "mipi-hi2056"
-
-static struct am_csi2_camera_para ar0543_para = {
-    .name = HI2056_CAMERA_MODULE_NAME,
-    .output_pixel = 0,
-    .output_line = 0,
-    .active_pixel = 0,
-    .active_line = 0,
-    .frame_rate = 0,
-    .ui_val = 0,
-    .hs_freq = 0,
-    .clock_lane_mode = 0,
-    .mirror = 0,
-    .in_fmt = NULL,
-    .out_fmt = NULL,
-};
 static int i_index = -1;
 static int t_index = -1;
 static int dest_hactive = 640;
@@ -681,9 +663,9 @@ static cam_i2c_msg_t AR0543_init_script[] = {
 	{END_OF_SCRIPT, 0, 0},
 };
 #ifdef MIPI_INTERFACE
-static cam_i2c_msg_t AR0543_mipi_script[] = {
+/*static cam_i2c_msg_t AR0543_mipi_script[] = {
 	{END_OF_SCRIPT, 0, 0},
-};
+};*/
 #endif
 static cam_i2c_msg_t AR0543_preview_VGA_script[] = {
 	{END_OF_SCRIPT, 0, 0},
@@ -1510,7 +1492,7 @@ extern int aml_i2c_put_word(struct i2c_adapter *adapter,
 		unsigned short dev_addr, unsigned short addr, unsigned short data);
 
 void AR0543_manual_set_aet(unsigned int exp,unsigned int ag,unsigned int vts){
-	unsigned char exp_h = 0, exp_m = 0, exp_l = 0, ag_h = 0, ag_l = 0, vts_h = 0, vts_l = 0;
+	//unsigned char exp_h = 0, exp_m = 0, exp_l = 0, ag_h = 0, ag_l = 0, vts_h = 0, vts_l = 0;
 	struct i2c_adapter *adapter;
 	adapter = i2c_get_adapter(4);
 	
@@ -1572,19 +1554,19 @@ static bool AR0543_set_aet_new_step(void *priv,unsigned int new_step, bool exp_m
 }
 
 
-static bool AR0543_check_mains_freq(void){// when the fr change,we need to change the aet table
-    int detection; 
-    struct i2c_adapter *adapter;
+static bool AR0543_check_mains_freq(void *priv){// when the fr change,we need to change the aet table
+    //int detection; 
+    //struct i2c_adapter *adapter;
     return true;
 }
 
 bool AR0543_set_af_new_step(void *priv,unsigned int af_step){
     struct i2c_adapter *adapter;
     char buf[3];
+    unsigned int diff,vcm_data = 0,codes;
     if(af_step == last_af_step)
         return true;
     if(vcm_mod == 0){
-	unsigned int diff,vcm_data,codes;
 	diff = (af_step > last_af_step) ? af_step - last_af_step : last_af_step - af_step;
 	last_af_step = af_step;
 	if(diff < 256){
@@ -1613,9 +1595,14 @@ bool AR0543_set_af_new_step(void *priv,unsigned int af_step){
 
 void AR0543_set_new_format(void *priv,int width,int height,int fr){
     int index = 0;
+    camera_priv_data_t *camera_priv_data;
+    configure_t *configure;
+    
     current_fr = fr;
-    camera_priv_data_t *camera_priv_data = (camera_priv_data_t *)priv;
-    configure_t *configure = camera_priv_data->configure;
+    
+    camera_priv_data = (camera_priv_data_t *)priv;
+    configure = camera_priv_data->configure;
+    
     if(camera_priv_data == NULL)
     	return;
     printk("sum:%d,mode:%d,fr:%d\n",configure->aet.sum,ar0543_work_mode,fr);
@@ -1723,7 +1710,7 @@ static CLASS_ATTR(camera_debug, 0664, i2c_debug_show, i2c_debug_store);
 
 static void power_down_ar0543(struct ar0543_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	//i2c_put_byte(client,0x0104, 0x00);
 	//i2c_put_byte(client,0x0100, 0x00);
 }
@@ -1734,7 +1721,7 @@ static ssize_t vcm_manual_store(struct class *cls,struct class_attribute *attr,
 	char buff[3];
 	unsigned int af_step = 0;
 	unsigned int diff = 0;
-	int codes,vcm_data;
+	int codes,vcm_data = 0;
 	unsigned char byte_h, byte_l;
 	sscanf(buf,"%d",&af_step);
     if(af_step == last_af_step)
@@ -1954,7 +1941,7 @@ void AR0543_set_param_wb(struct ar0543_device *dev,enum  camera_wb_flip_e para)/
  *************************************************************************/
 void AR0543_set_param_exposure(struct ar0543_device *dev,enum camera_exposure_e para)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
     int value;
     if(para == EXPOSURE_0_STEP){
         dev->cam_para->cam_command = CAM_COMMAND_AE_ON;
@@ -2007,7 +1994,7 @@ static effect_pair_t effect_pair[] = {
     {SPECIAL_EFFECT_NEGATIVE,"CAM_EFFECT_ENC_COLORINV"}
 };
 
-void AR0543_set_param_effect(struct ar0543_device *dev,enum camera_effect_flip_e para)
+void AR0543_set_param_effect(struct ar0543_device *dev,enum camera_special_effect_e para)
 {
     int index = 0;
     int i = 0;
@@ -2062,9 +2049,9 @@ void AR0543_set_param_effect(struct ar0543_device *dev,enum camera_effect_flip_e
  *************************************************************************/
 void AR0543_set_night_mode(struct ar0543_device *dev,enum  camera_night_mode_flip_e enable)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
-    if (50) {
+    if (enable) {
         
     }
     else{
@@ -2073,9 +2060,9 @@ void AR0543_set_night_mode(struct ar0543_device *dev,enum  camera_night_mode_fli
 
 }   /* AR0543_NightMode */
 
-static void AR0543_set_param_banding(struct ar0543_device *dev,enum  camera_night_mode_flip_e banding)
+static void AR0543_set_param_banding(struct ar0543_device *dev, enum  camera_banding_flip_e banding)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
     switch(banding){
         case CAM_BANDING_60HZ:
             printk("set banding 60Hz\n");
@@ -2093,7 +2080,7 @@ static void AR0543_set_param_banding(struct ar0543_device *dev,enum  camera_nigh
 
 static int AR0543_AutoFocus(struct ar0543_device *dev, int focus_mode)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
     int ret = 0;
 
     switch (focus_mode) {
@@ -2155,6 +2142,7 @@ static int set_flip(struct ar0543_device *dev)
         printk("fail in setting sensor orientation \n");
         return -1;
     }
+    return 0;
 }
 
 
@@ -2231,6 +2219,9 @@ static resolution_param_t* get_resolution_param(struct ar0543_device *dev, int a
 }
 
 static char *res_size[]={
+	"144p",
+	"240p",
+	"288p",
 	"480p",
 	"720p",
 	"960p",
@@ -2241,7 +2232,7 @@ static char *res_size[]={
 static void set_resolution_param(struct ar0543_device *dev, resolution_param_t* res_param)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int rc = -1;
+	//int rc = -1;
 	int i=0;
 	unsigned char t = 1;//dev->cam_info.interface;
 	printk("%s, %d, interface =%d\n" , __func__, __LINE__, t);
@@ -2294,9 +2285,9 @@ static void set_resolution_param(struct ar0543_device *dev, resolution_param_t*
 static int set_focus_zone(struct ar0543_device *dev, int value)
 {
 	int xc, yc, tx, ty;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int retry_count = 10;
-	int ret = -1;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//int retry_count = 10;
+	//int ret = -1;
 	
 	xc = (value >> 16) & 0xffff;
 	yc = (value & 0xffff);
@@ -2361,7 +2352,7 @@ static int convert_canvas_index(unsigned int v4l2_format, unsigned int start_can
 static int ar0543_setting(struct ar0543_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	struct ar0543_fh *fh = to_fh(dev);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
@@ -2868,6 +2859,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	struct ar0543_fh *fh = priv;
 	struct videobuf_queue *q = &fh->vb_vidq;
 	struct ar0543_device *dev = fh->dev;
+	int ret;
 	resolution_param_t* res_param = NULL;
 
     f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN-1) ) & (~(CANVAS_WIDTH_ALIGN-1));
@@ -2875,7 +2867,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
             (f->fmt.pix.pixelformat==V4L2_PIX_FMT_YUV420)){
     	f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN*2-1) ) & (~(CANVAS_WIDTH_ALIGN*2-1));
     }
-	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
+	ret = vidioc_try_fmt_vid_cap(file, fh, f);
 	if (ret < 0)
 		return ret;
 	
@@ -2994,7 +2986,7 @@ static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
 }
 #endif
 #ifdef MIPI_INTERFACE
-static struct ar0543_fmt input_formats_vdin[] = 
+/*static struct ar0543_fmt input_formats_vdin[] = 
 {
     // vdin path format
     {
@@ -3012,7 +3004,7 @@ static struct ar0543_fmt input_formats_vdin[] =
         .fourcc   = V4L2_PIX_FMT_NV12,
         .depth    = 12,
     }
-};
+};*/
 #endif
 
 static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
@@ -3218,7 +3210,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
       return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *fh, v4l2_std_id norm)
 {
 	return 0;
 }
@@ -3277,7 +3269,7 @@ static int vidioc_g_ctrl(struct file *file, void *priv,
 {
 	struct ar0543_fh *fh = priv;
 	struct ar0543_device *dev = fh->dev;
-	int i, status;
+	int i; //status;
 	int ret = 0;
 
 	for (i = 0; i < ARRAY_SIZE(ar0543_qctrl); i++)
@@ -3711,7 +3703,7 @@ static ssize_t cam_info_store(struct device *dev,struct device_attribute *attr,c
 
 	struct ar0543_device *t;
 	unsigned char n=0;
-	unsigned char ret=0;
+	//unsigned char ret=0;
 	char *buf_orig, *ps, *token;
 	char *parm[3] = {NULL};
 	
diff --git a/drivers/amlogic/camera/ar0833.c b/drivers/amlogic/camera/ar0833.c
index ce3cda733b0a..50ba6f55029b 100755
--- a/drivers/amlogic/camera/ar0833.c
+++ b/drivers/amlogic/camera/ar0833.c
@@ -102,16 +102,16 @@ static struct class *cam_class;
 static unsigned int g_ae_manual_exp;
 static unsigned int g_ae_manual_ag;
 static unsigned int g_ae_manual_vts;
-static unsigned int exp_mode;
-static unsigned int change_cnt;
+//static unsigned int exp_mode;
+//static unsigned int change_cnt;
 static unsigned int current_fmt;
 static unsigned int current_fr = 0;//50 hz
-static unsigned int aet_index;
+//static unsigned int aet_index;
 static unsigned int last_af_step = 0;
 
 #define HI2056_CAMERA_MODULE_NAME "mipi-hi2056"
 
-static struct am_csi2_camera_para ar0833_para = {
+/*static struct am_csi2_camera_para ar0833_para = {
     .name = HI2056_CAMERA_MODULE_NAME,
     .output_pixel = 0,
     .output_line = 0,
@@ -124,7 +124,7 @@ static struct am_csi2_camera_para ar0833_para = {
     .mirror = 0,
     .in_fmt = NULL,
     .out_fmt = NULL,
-};
+};*/
 static int i_index = -1;
 static int t_index = -1;
 static int dest_hactive = 640;
@@ -676,9 +676,9 @@ static cam_i2c_msg_t AR0833_init_script[] = {
 	{END_OF_SCRIPT, 0, 0},
 };
 #ifdef MIPI_INTERFACE
-static cam_i2c_msg_t AR0833_mipi_script[] = {
+/*static cam_i2c_msg_t AR0833_mipi_script[] = {
 	{END_OF_SCRIPT, 0, 0},
-};
+};*/
 #endif
 static cam_i2c_msg_t AR0833_preview_VGA_script[] = {
 	{END_OF_SCRIPT, 0, 0},
@@ -2933,9 +2933,9 @@ static cam_i2c_msg_t AR0833_8M_script_mipi[] = {
 	{END_OF_SCRIPT, 0, 0},
 };
 
-static cam_i2c_msg_t AR0833_capture_6M_script[] = {
+/*static cam_i2c_msg_t AR0833_capture_6M_script[] = {
 	{END_OF_SCRIPT, 0, 0},
-};
+};*/
 
 static cam_i2c_msg_t AR0833_6M_script_mipi[] = {
 		{2, 0x301A, 0x0019}, 	// RESET_REGISTER
@@ -3625,7 +3625,7 @@ extern int aml_i2c_put_word(struct i2c_adapter *adapter,
 		unsigned short dev_addr, unsigned short addr, unsigned short data);
 
 void AR0833_manual_set_aet(unsigned int exp,unsigned int ag,unsigned int vts){
-	unsigned char exp_h = 0, exp_m = 0, exp_l = 0, ag_h = 0, ag_l = 0, vts_h = 0, vts_l = 0;
+	//unsigned char exp_h = 0, exp_m = 0, exp_l = 0, ag_h = 0, ag_l = 0, vts_h = 0, vts_l = 0;
 	struct i2c_adapter *adapter;
 	adapter = i2c_get_adapter(4);
 	
@@ -3686,14 +3686,14 @@ static bool AR0833_set_aet_new_step(void *priv, unsigned int new_step, bool exp_
 }
 
 
-static bool AR0833_check_mains_freq(void){// when the fr change,we need to change the aet table
-    int detection; 
-    struct i2c_adapter *adapter;
+static bool AR0833_check_mains_freq(void *priv){// when the fr change,we need to change the aet table
+    //int detection; 
+    //struct i2c_adapter *adapter;
     return true;
 }
 
-bool AR0833_set_af_new_step(unsigned int af_step){
-    struct i2c_adapter *adapter;
+bool AR0833_set_af_new_step(void *priv,unsigned int af_step){
+    //struct i2c_adapter *adapter;
     char buf[3];
     if(af_step == last_af_step)
         return true;
@@ -3724,9 +3724,13 @@ bool AR0833_set_af_new_step(unsigned int af_step){
 
 void AR0833_set_new_format(void *priv,int width,int height,int fr){
     int index = 0;
+    camera_priv_data_t *camera_priv_data;
+    configure_t *configure;
+    
     current_fr = fr;
-    camera_priv_data_t *camera_priv_data = (camera_priv_data_t *)priv;
-    configure_t *configure = camera_priv_data->configure;
+    camera_priv_data = (camera_priv_data_t *)priv;
+    configure = camera_priv_data->configure;
+    
     if(camera_priv_data == NULL)
     	return;
     printk("sum:%d,mode:%d,fr:%d\n",configure->aet.sum,ar0833_work_mode,fr);
@@ -3834,7 +3838,7 @@ static CLASS_ATTR(camera_debug, 0664, i2c_debug_show, i2c_debug_store);
 
 static void power_down_ar0833(struct ar0833_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	//i2c_put_byte(client,0x0104, 0x00);
 	//i2c_put_byte(client,0x0100, 0x00);
 }
@@ -3842,11 +3846,11 @@ static void power_down_ar0833(struct ar0833_device *dev)
 
 static ssize_t vcm_manual_store(struct class *cls,struct class_attribute *attr, const char* buf, size_t len)
 {
-	struct i2c_adapter *adapter;
+	//struct i2c_adapter *adapter;
 	char buff[3];
 	unsigned int af_step = 0;
 	unsigned int diff = 0;
-	int codes,vcm_data;
+	int codes,vcm_data = 0;
 	unsigned char byte_h, byte_l;
 	sscanf(buf,"%d",&af_step);
     if(af_step == last_af_step)
@@ -3875,11 +3879,11 @@ static ssize_t vcm_manual_store(struct class *cls,struct class_attribute *attr,
 static ssize_t vcm_manual_show(struct class *cls,struct class_attribute *attr, char* buf)
 {
 	size_t len = 0;
-	struct i2c_adapter *adapter;
-	unsigned int af;
+	//struct i2c_adapter *adapter;
+	//unsigned int af;
 	//adapter = i2c_get_adapter(4);
 	//af = my_i2c_get_word(adapter,0x0c);
-	printk("current vcm step :%x\n",af);
+	//printk("current vcm step :%x\n",af);
 	return len;
 }
 
@@ -4033,7 +4037,7 @@ void AR0833_set_param_wb(struct ar0833_device *dev,enum  camera_wb_flip_e para)/
  *************************************************************************/
 void AR0833_set_param_exposure(struct ar0833_device *dev,enum camera_exposure_e para)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
     int value;
     if(para == EXPOSURE_0_STEP){
         dev->cam_para->cam_command = CAM_COMMAND_AE_ON;
@@ -4086,7 +4090,7 @@ static effect_pair_t effect_pair[] = {
     {SPECIAL_EFFECT_NEGATIVE,"CAM_EFFECT_ENC_COLORINV"}
 };
 
-void AR0833_set_param_effect(struct ar0833_device *dev,enum camera_effect_flip_e para)
+void AR0833_set_param_effect(struct ar0833_device *dev,enum camera_special_effect_e para)
 {
     int index = 0;
     int i = 0;
@@ -4141,9 +4145,9 @@ void AR0833_set_param_effect(struct ar0833_device *dev,enum camera_effect_flip_e
  *************************************************************************/
 void AR0833_set_night_mode(struct ar0833_device *dev,enum  camera_night_mode_flip_e enable)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
-    if (50) {
+    if (enable) {
         
     }
     else{
@@ -4152,9 +4156,9 @@ void AR0833_set_night_mode(struct ar0833_device *dev,enum  camera_night_mode_fli
 
 }   /* AR0833_NightMode */
 
-static void AR0833_set_param_banding(struct ar0833_device *dev,enum  camera_night_mode_flip_e banding)
+static void AR0833_set_param_banding(struct ar0833_device *dev,enum  camera_banding_flip_e banding)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
     switch(banding){
         case CAM_BANDING_60HZ:
             printk("set banding 60Hz\n");
@@ -4172,7 +4176,7 @@ static void AR0833_set_param_banding(struct ar0833_device *dev,enum  camera_nigh
 
 static int AR0833_AutoFocus(struct ar0833_device *dev, int focus_mode)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
     int ret = 0;
 
     switch (focus_mode) {
@@ -4235,6 +4239,7 @@ static int set_flip(struct ar0833_device *dev)
         printk("fail in setting sensor orientation \n");
         return -1;
     }
+    return 0;
 }
 
 
@@ -4326,7 +4331,7 @@ static char *res_size[]={
 static void set_resolution_param(struct ar0833_device *dev, resolution_param_t* res_param)
 {
     struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-    int rc = -1;
+    //int rc = -1;
     int i=0;
     unsigned char t = dev->cam_info.interface;
     printk("%s, %d, interface =%d\n" , __func__, __LINE__, t);
@@ -4363,9 +4368,9 @@ static void set_resolution_param(struct ar0833_device *dev, resolution_param_t*
 static int set_focus_zone(struct ar0833_device *dev, int value)
 {
 	int xc, yc, tx, ty;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	int retry_count = 10;
-	int ret = -1;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//int retry_count = 10;
+	//int ret = -1;
 	
 	xc = (value >> 16) & 0xffff;
 	yc = (value & 0xffff);
@@ -4430,7 +4435,7 @@ static int convert_canvas_index(unsigned int v4l2_format, unsigned int start_can
 static int ar0833_setting(struct ar0833_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	struct ar0833_fh *fh = to_fh(dev);
 	switch(PROP_ID)  {
 	case V4L2_CID_BRIGHTNESS:
@@ -4939,13 +4944,14 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	struct videobuf_queue *q = &fh->vb_vidq;
 	struct ar0833_device *dev = fh->dev;
 	resolution_param_t* res_param = NULL;
+	int ret;
 
     f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN-1) ) & (~(CANVAS_WIDTH_ALIGN-1));
 	if ((f->fmt.pix.pixelformat==V4L2_PIX_FMT_YVU420) ||
             (f->fmt.pix.pixelformat==V4L2_PIX_FMT_YUV420)){
     	f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN*2-1) ) & (~(CANVAS_WIDTH_ALIGN*2-1));
     }
-	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
+	ret = vidioc_try_fmt_vid_cap(file, fh, f);
 	if (ret < 0)
 		return ret;
 	
@@ -5064,7 +5070,7 @@ static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
 }
 #endif
 #ifdef MIPI_INTERFACE
-static struct ar0833_fmt input_formats_vdin[] = 
+/*static struct ar0833_fmt input_formats_vdin[] = 
 {
     // vdin path format
     {
@@ -5082,7 +5088,7 @@ static struct ar0833_fmt input_formats_vdin[] =
         .fourcc   = V4L2_PIX_FMT_NV12,
         .depth    = 12,
     }
-};
+};*/
 #endif
 
 static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
@@ -5287,7 +5293,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
       return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *fh, v4l2_std_id norm)
 {
 	return 0;
 }
@@ -5346,7 +5352,8 @@ static int vidioc_g_ctrl(struct file *file, void *priv,
 {
 	struct ar0833_fh *fh = priv;
 	struct ar0833_device *dev = fh->dev;
-	int i, status;
+	int i;
+	//int status;
 	int ret = 0;
 
 	for (i = 0; i < ARRAY_SIZE(ar0833_qctrl); i++)
@@ -5775,7 +5782,7 @@ static ssize_t cam_info_store(struct device *dev,struct device_attribute *attr,c
 
 	struct ar0833_device *t;
 	unsigned char n=0;
-	unsigned char ret=0;
+	//unsigned char ret=0;
 	char *buf_orig, *ps, *token;
 	char *parm[3] = {NULL};
 	
diff --git a/drivers/amlogic/camera/common/cam_prober.c b/drivers/amlogic/camera/common/cam_prober.c
index 8201b5956b50..f02a9a062ebb 100755
--- a/drivers/amlogic/camera/common/cam_prober.c
+++ b/drivers/amlogic/camera/common/cam_prober.c
@@ -923,8 +923,8 @@ static int fill_csi_dev(struct device_node* p_node, aml_cam_info_t* cam_dev)
 {
 	const char* str;
 	int ret = 0;
-	aml_cam_dev_info_t* cam_info = NULL;
-	struct i2c_adapter *adapter;
+	//aml_cam_dev_info_t* cam_info = NULL;
+	//struct i2c_adapter *adapter;
 
 	ret = of_property_read_string(p_node, "clk_channel", &str);
 	if (ret) {
diff --git a/drivers/amlogic/camera/common/config_parser.c b/drivers/amlogic/camera/common/config_parser.c
index 37e8bfbabc1b..3578339539ce 100755
--- a/drivers/amlogic/camera/common/config_parser.c
+++ b/drivers/amlogic/camera/common/config_parser.c
@@ -53,7 +53,7 @@ Input	:	*config_file
 Output	:	file size
 function	:	open the firware file, and return total size
  ***********************************************************************************************/
-int camera_open_config(char *config_file)
+int camera_open_config(const char *config_file)
 {
     loff_t file_size;
     struct inode *inode = NULL;
@@ -480,7 +480,7 @@ int parse_effect(configure_t *cf,buffer_para_t *buf_para,int *remained,int *offs
 
 int parse_aet(configure_t *cf,buffer_para_t *buf_para,int *remained,int *offset){
     int sum,ret,check,i;
-    char *iter,*eter;
+    char *iter;
 
     iter = search_string(buf_para,offset,remained,"aet_start]","[aet]");
     if(iter == NULL){
@@ -925,7 +925,6 @@ int parse_wb_sensor(configure_t *cf,buffer_para_t *buf_para,int *remained,int *o
 
 
 int parse_version(configure_t *cf,buffer_para_t *buf_para,int *remained,int *offset){
-    int i;
     char *iter,*end;
     int len = 0;
 
@@ -1084,7 +1083,7 @@ int parse_peaking(configure_t *cf,buffer_para_t *buf_para,int *remained,int *off
      return 0;
 }
 
-int parse_config(char *path,configure_t *cf){
+int parse_config(const char *path,configure_t *cf){
     char *buffer,*iter;
     int file_size;
     int remained_size;
@@ -1598,7 +1597,7 @@ int update_fmt_para(int width,int height,cam_parameter_t *para,para_index_t *pin
 		if(i < cf->lens.sum)
 			pindex->lens_index = i;
 		else{
-			printk("width:%x,height:%x no match lens param\n");
+			printk("width:%x,height:%x no match lens param\n", width, height);
 			pindex->lens_index = 0;	
 		}
 		/** init lens **/
@@ -1622,7 +1621,7 @@ int update_fmt_para(int width,int height,cam_parameter_t *para,para_index_t *pin
 		if(i < cf->nr.sum)
 			pindex->nr_index = i;
 		else{
-			printk("width:%x,height:%x no match nr param\n");
+			printk("width:%x,height:%x no match nr param\n", width, height);
 			pindex->nr_index = 0;	
 		}
 			/** init nr **/
@@ -1646,7 +1645,7 @@ int update_fmt_para(int width,int height,cam_parameter_t *para,para_index_t *pin
 		if(i < cf->peaking.sum)
 			pindex->peaking_index = i;
 		else{
-			printk("width:%x,height:%x no match peaking param\n");
+			printk("width:%x,height:%x no match peaking param\n", width, height);
 			pindex->peaking_index = 0;	
 		}
 		    /** init sharp **/
diff --git a/drivers/amlogic/camera/common/config_parser.h b/drivers/amlogic/camera/common/config_parser.h
index d30dcb5ad428..7ac60f88b1fa 100755
--- a/drivers/amlogic/camera/common/config_parser.h
+++ b/drivers/amlogic/camera/common/config_parser.h
@@ -152,9 +152,9 @@ typedef struct{
 }lens_struct;
 
 typedef struct{
-	unsigned short gamma_r[GAMMA_MAX];
-	unsigned short gamma_g[GAMMA_MAX];
-	unsigned short gamma_b[GAMMA_MAX];
+	unsigned int gamma_r[GAMMA_MAX];
+	unsigned int gamma_g[GAMMA_MAX];
+	unsigned int gamma_b[GAMMA_MAX];
 }gamma_struct;
 
 typedef struct{
@@ -245,10 +245,10 @@ typedef struct{
 }effect_pair_t;
 
 typedef struct sensor_dg_s {
-    unsigned short r;
-    unsigned short g;
-    unsigned short b;
-    unsigned short dg_default;
+    unsigned int r;
+    unsigned int g;
+    unsigned int b;
+    unsigned int dg_default;
 }sensor_dg_t;
 
 typedef struct{
@@ -258,7 +258,7 @@ typedef struct{
 	configure_t *configure;
 }camera_priv_data_t;
 
-int parse_config(char *path,configure_t *cf);
+int parse_config(const char *path,configure_t *cf);
 int generate_para(cam_parameter_t *para,para_index_t pindex,configure_t *cf);
 void free_para(cam_parameter_t *para);
 int update_fmt_para(int width,int height,cam_parameter_t *para,para_index_t *pindex,configure_t *cf);
diff --git a/drivers/amlogic/camera/gc0307.c b/drivers/amlogic/camera/gc0307.c
index 63e7a7b0d5ab..a7b4351cc560 100755
--- a/drivers/amlogic/camera/gc0307.c
+++ b/drivers/amlogic/camera/gc0307.c
@@ -2487,7 +2487,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/gc0328.c b/drivers/amlogic/camera/gc0328.c
index 341df64cb157..5cf663761110 100755
--- a/drivers/amlogic/camera/gc0328.c
+++ b/drivers/amlogic/camera/gc0328.c
@@ -2204,7 +2204,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/gc0329.c b/drivers/amlogic/camera/gc0329.c
index 46ed17365545..85ae00966fd9 100755
--- a/drivers/amlogic/camera/gc0329.c
+++ b/drivers/amlogic/camera/gc0329.c
@@ -2172,7 +2172,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/gc2015.c b/drivers/amlogic/camera/gc2015.c
index 2334111942ff..830679cd7e26 100755
--- a/drivers/amlogic/camera/gc2015.c
+++ b/drivers/amlogic/camera/gc2015.c
@@ -2484,7 +2484,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/hi704.c b/drivers/amlogic/camera/hi704.c
index 4abc15980db2..c8f31fab381b 100755
--- a/drivers/amlogic/camera/hi704.c
+++ b/drivers/amlogic/camera/hi704.c
@@ -2223,7 +2223,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/nt99250.c b/drivers/amlogic/camera/nt99250.c
index 8a3ab202e5fd..cd3c60b60f70 100755
--- a/drivers/amlogic/camera/nt99250.c
+++ b/drivers/amlogic/camera/nt99250.c
@@ -2459,7 +2459,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/nt99252.c b/drivers/amlogic/camera/nt99252.c
index 9c2a4dfb3be4..0bb358889db0 100755
--- a/drivers/amlogic/camera/nt99252.c
+++ b/drivers/amlogic/camera/nt99252.c
@@ -1862,7 +1862,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/nt99340.c b/drivers/amlogic/camera/nt99340.c
index cc499c15ac34..06b6fc283afc 100755
--- a/drivers/amlogic/camera/nt99340.c
+++ b/drivers/amlogic/camera/nt99340.c
@@ -1855,7 +1855,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/ov2655.c b/drivers/amlogic/camera/ov2655.c
index 1817df43b79e..6374c7f6da56 100755
--- a/drivers/amlogic/camera/ov2655.c
+++ b/drivers/amlogic/camera/ov2655.c
@@ -2374,7 +2374,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/ov3660.c b/drivers/amlogic/camera/ov3660.c
index a18c77e5cd5c..64887c77de0a 100755
--- a/drivers/amlogic/camera/ov3660.c
+++ b/drivers/amlogic/camera/ov3660.c
@@ -2242,7 +2242,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/ov5640.c b/drivers/amlogic/camera/ov5640.c
index 2327e838a161..d986fb6e640c 100755
--- a/drivers/amlogic/camera/ov5640.c
+++ b/drivers/amlogic/camera/ov5640.c
@@ -2310,7 +2310,7 @@ static struct aml_camera_i2c_fig_s OV5640_preview_SVGA_script[] = { //SVGA: 800*
 };
 #endif
 
-static struct aml_camera_i2c_fig_s OV5640_preview_QVGA_script[] = {
+/*static struct aml_camera_i2c_fig_s OV5640_preview_QVGA_script[] = {
 	{0x3503, 0x00},
 	{0x3035, 0x11},
 	{0x3036, 0x46},
@@ -2356,7 +2356,7 @@ static struct aml_camera_i2c_fig_s OV5640_preview_QVGA_script[] = {
 	{0x3821, 0x07}, // #3 ck. origin: 0x01, 
 	{0x3031, 0x08},  
 	{0xffff, 0xff}
-};
+};*/
 
 static struct aml_camera_i2c_fig_s OV5640_capture_5M_script[] = {
 	#if 1
@@ -2408,7 +2408,7 @@ static struct aml_camera_i2c_fig_s OV5640_capture_5M_script[] = {
 	{0xffff, 0xff}
 };
 
-static struct aml_camera_i2c_fig_s OV5640_capture_3M_script[] = {
+/*static struct aml_camera_i2c_fig_s OV5640_capture_3M_script[] = {
 	{0x3035, 0x31},
 	{0x3036, 0x69},
 	{0x3c07, 0x07},
@@ -2460,9 +2460,9 @@ static struct aml_camera_i2c_fig_s OV5640_capture_3M_script[] = {
 	{0x5584, 0x10}, 
 	{0x5586, 0x15},
 	{0xffff, 0xff}
-};
+};*/
 
-static struct aml_camera_i2c_fig_s OV5640_capture_2M_script[] = {
+/*static struct aml_camera_i2c_fig_s OV5640_capture_2M_script[] = {
 	{0x3035, 0x31},
 	{0x3036, 0x69},
 	{0x3c07, 0x07},
@@ -2514,7 +2514,7 @@ static struct aml_camera_i2c_fig_s OV5640_capture_2M_script[] = {
 	{0x5584, 0x10}, 
 	{0x5586, 0x15},
 	{0xffff, 0xff}
-};
+};*/
 
 static resolution_param_t  prev_resolution_array[] = {
 	{
@@ -3987,6 +3987,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 	struct videobuf_queue *q = &fh->vb_vidq;
 	struct ov5640_device *dev = fh->dev;
 	resolution_param_t* res_param = NULL;
+	int ret;
 	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	//unsigned char gain = 0, exposurelow = 0, exposuremid = 0, exposurehigh = 0;
 	int cap_fps, pre_fps;
@@ -3996,7 +3997,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
             (f->fmt.pix.pixelformat==V4L2_PIX_FMT_YUV420)){
                 f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN*2-1) ) & (~(CANVAS_WIDTH_ALIGN*2-1));
         }
-	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
+	ret = vidioc_try_fmt_vid_cap(file, fh, f);
 	if (ret < 0)
     	return ret;
 
@@ -4237,7 +4238,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
         return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/ov5642.c b/drivers/amlogic/camera/ov5642.c
index e1c4138ffdbb..7ebf377301e2 100755
--- a/drivers/amlogic/camera/ov5642.c
+++ b/drivers/amlogic/camera/ov5642.c
@@ -2999,7 +2999,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/ov7675.c b/drivers/amlogic/camera/ov7675.c
index 743434d49376..0cdaf39262ae 100755
--- a/drivers/amlogic/camera/ov7675.c
+++ b/drivers/amlogic/camera/ov7675.c
@@ -1712,7 +1712,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/sp0838.c b/drivers/amlogic/camera/sp0838.c
index d101f1e7a6ad..fb422e13932f 100755
--- a/drivers/amlogic/camera/sp0838.c
+++ b/drivers/amlogic/camera/sp0838.c
@@ -483,10 +483,10 @@ struct sp0838_fh {
 	unsigned int		f_flags;
 };
 
-static inline struct sp0838_fh *to_fh(struct sp0838_device *dev)
+/*static inline struct sp0838_fh *to_fh(struct sp0838_device *dev)
 {
 	return container_of(dev, struct sp0838_fh, dev);
-}
+}*/
 
 static struct v4l2_frmsize_discrete sp0838_prev_resolution[3]= //should include 320x240 and 640x480, those two size are used for recording
 {
@@ -870,7 +870,7 @@ void set_SP0838_param_wb(struct sp0838_device *dev,enum  camera_wb_flip_e para)
 		//temp_reg=sp0a19_read_byte(0x22);
 		//buf[0]=0x22; //SP0A19 enable auto wb
 		buf[0]=0x32;
-		temp_reg=i2c_get_byte_add8(client,buf);
+		temp_reg=i2c_get_byte_add8(client,buf[0]);
 	
 		printk(" camera set_SP0A19_param_wb=%d. \n ",para);
 		switch (para)
@@ -1183,8 +1183,8 @@ unsigned char v4l_2_sp0838(int val)
 static int sp0838_setting(struct sp0838_device *dev,int PROP_ID,int value )
 {
 	int ret=0;
-	unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	//unsigned char cur_val;
+	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	switch(PROP_ID)  {
 	case V4L2_CID_DO_WHITE_BALANCE:
 		if(sp0838_qctrl[0].default_value!=value){
@@ -1250,11 +1250,11 @@ static int sp0838_setting(struct sp0838_device *dev,int PROP_ID,int value )
 
 }
 
-static void power_down_sp0838(struct sp0838_device *dev)
+/*static void power_down_sp0838(struct sp0838_device *dev)
 {
 
 
-}
+}*/
 
 /* ------------------------------------------------------------------
 	DMA and thread functions
@@ -1823,7 +1823,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/camera/sp2518.c b/drivers/amlogic/camera/sp2518.c
index 83c1c981c53b..f082dc82844b 100755
--- a/drivers/amlogic/camera/sp2518.c
+++ b/drivers/amlogic/camera/sp2518.c
@@ -2352,7 +2352,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsiz
 	return ret;
 }
 
-static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
 	return 0;
 }
diff --git a/drivers/amlogic/cpufreq/meson-cpufreq.c b/drivers/amlogic/cpufreq/meson-cpufreq.c
index 6d39dc720eaf..3990363e4dcf 100755
--- a/drivers/amlogic/cpufreq/meson-cpufreq.c
+++ b/drivers/amlogic/cpufreq/meson-cpufreq.c
@@ -234,7 +234,7 @@ unsigned int meson_cpufreq_get(unsigned int cpu)
 static int meson_cpufreq_init(struct cpufreq_policy *policy)
 {
     struct cpufreq_frequency_table *freq_table = NULL;
-    int result = 0, index = 0;
+    int index = 0;
 
     if (policy->cpu != 0)
         return -EINVAL;
@@ -324,6 +324,7 @@ static int meson_cpufreq_suspend(struct cpufreq_policy *policy)
 static int meson_cpufreq_resume(struct cpufreq_policy *policy)
 {
     unsigned cur;
+	int ret;
 
     printk("cpufreq resume sleep_freq=%dMhz\n", sleep_freq/1000);
 
@@ -333,7 +334,7 @@ static int meson_cpufreq_resume(struct cpufreq_policy *policy)
     cur = clk_get_rate(cpufreq.armclk) / 1000;
     if (policy->max > cur) {
         adjust_jiffies(policy->max, cur);
-        int ret = aml_dvfs_freq_change(AML_DVFS_ID_VCCK,
+		ret = aml_dvfs_freq_change(AML_DVFS_ID_VCCK,
                                        sleep_freq,
                                        policy->max,
                                        AML_DVFS_FREQ_POSTCHANGE);
@@ -364,8 +365,6 @@ static int __init meson_cpufreq_probe(struct platform_device *pdev)
 		int voltage_control = 0;
 
 #ifdef CONFIG_USE_OF
-		struct meson_cpufreq_config *cpufreq_info;
-		int ret,val=0;
 		const void *prop;
 
 		if (pdev->dev.of_node) {
@@ -388,9 +387,6 @@ static int __init meson_cpufreq_probe(struct platform_device *pdev)
     }
 
    return cpufreq_register_driver(&meson_cpufreq_driver);
-   err:
-		//kfree(vcck_opp_table);
-		return -1;
 }
 
 
diff --git a/drivers/amlogic/display/aml_logo/logo_display/logo_output.c b/drivers/amlogic/display/aml_logo/logo_display/logo_output.c
index 33fcbfec281b..bf16219a58cb 100755
--- a/drivers/amlogic/display/aml_logo/logo_display/logo_output.c
+++ b/drivers/amlogic/display/aml_logo/logo_display/logo_output.c
@@ -54,7 +54,7 @@ static  output_dev_list_t aml_output_dev[LOGO_DEV_MAX];
 			res = &memobj;
 			idx = find_reserve_block(platform_dev->dev.of_node->name,num);
 			if(idx < 0){
-				amlog_mask_level(LOG_LEVEL_HIGH,"can not find %s%d reserve block\n",platform_dev->dev.of_node->name,num);
+				amlog_mask_level(LOG_MASK_DEVICE, LOG_LEVEL_HIGH,"can not find %s %d reserve block\n",platform_dev->dev.of_node->name, num);
 				continue;
 			}
 			res->start = (phys_addr_t)get_reserve_block_addr(idx);
diff --git a/drivers/amlogic/display/aml_logo/logo_display/output_dev_osd.c b/drivers/amlogic/display/aml_logo/logo_display/output_dev_osd.c
index 132cd8e9c4d6..043cd2082f78 100755
--- a/drivers/amlogic/display/aml_logo/logo_display/output_dev_osd.c
+++ b/drivers/amlogic/display/aml_logo/logo_display/output_dev_osd.c
@@ -9,6 +9,12 @@
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/vout_notify.h>
 
+static int osd0_init(logo_object_t *plogo);
+static int osd1_init(logo_object_t *plogo);
+static int osd_enable_set(int  enable);
+static int osd_deinit(void);
+static int osd_transfer(logo_object_t *plogo);
+
 static  logo_output_dev_t   output_osd0={
 	.idx=LOGO_DEV_OSD0,
 	.hw_initialized=0,	
@@ -424,6 +430,7 @@ static int __init get_cvbs_mode(char *str)
 	cvbsmode_hdmionly = VMODE_480CVBS;
     }
     printk("kernel get cvbsmode form uboot is %s\n", str);
+    return 1;
 }
 __setup("cvbsmode=", get_cvbs_mode);
 
@@ -442,6 +449,7 @@ static int __init get_hdmi_mode(char *str)
 	hdmimode_hdmionly = VMODE_1080P;
    }
    printk("kernel get hdmimode form uboot is %s\n", str);
+   return 1;
 }
 __setup("hdmimode=", get_hdmi_mode);
 #endif
diff --git a/drivers/amlogic/display/aml_logo/logo_parse/bmp_parser.c b/drivers/amlogic/display/aml_logo/logo_parse/bmp_parser.c
index 9a71193c91c2..2b2b2202ae4c 100755
--- a/drivers/amlogic/display/aml_logo/logo_parse/bmp_parser.c
+++ b/drivers/amlogic/display/aml_logo/logo_parse/bmp_parser.c
@@ -53,7 +53,7 @@ static  int  bmp_decode(logo_object_t *plogo)
 	char	*in=plogo->para.mem_addr ;
 	char *out=plogo->parser->output_addr;
 	char *bmp_data;
-	int 	i, j;
+	int 	i;
 	bmp_header_t  *bmp_header=(bmp_header_t  *)plogo->parser->priv;
 	int bpp=plogo->parser->logo_pic_info.color_info/8 ;
 	int width=plogo->parser->logo_pic_info.width;
diff --git a/drivers/amlogic/display/aml_logo/logo_parse/jpeg_parser.c b/drivers/amlogic/display/aml_logo/logo_parse/jpeg_parser.c
index 25284e3ee763..1e7fbaf7b2cd 100755
--- a/drivers/amlogic/display/aml_logo/logo_parse/jpeg_parser.c
+++ b/drivers/amlogic/display/aml_logo/logo_parse/jpeg_parser.c
@@ -64,6 +64,8 @@ static inline u32 index2canvas(u32 index)
 
     return canvas_tab[index];
 }
+
+#if 0
 static irqreturn_t jpeglogo_isr(int irq, void *dev_id)
 {
 	u32 reg, index;
@@ -86,6 +88,8 @@ static irqreturn_t jpeglogo_isr(int irq, void *dev_id)
 
     return IRQ_HANDLED;
 }
+#endif
+
 static s32 parse_jpeg_info(u8 *dp,logo_object_t *plogo)
 {
 	int len = 0;
@@ -339,7 +343,7 @@ static inline void feed_vb(s32 s)
 static int hardware_init(logo_object_t *plogo,int logo_size)
 {
 	u32	*mc_addr_aligned = (u32 *)vmjpeg_mc;
-	int ret;
+	int ret = 0;
 	if(plogo->para.output_dev_type  <=LOGO_DEV_VID ) //now only support display on video layer.
 	{
 		if(plogo->para.output_dev_type < LOGO_DEV_VID)
diff --git a/drivers/amlogic/display/osd/osd_main.c b/drivers/amlogic/display/osd/osd_main.c
index f5b954cac2b7..23f22d780cb1 100755
--- a/drivers/amlogic/display/osd/osd_main.c
+++ b/drivers/amlogic/display/osd/osd_main.c
@@ -1515,6 +1515,9 @@ static struct resource memobj;
 static int 
 osd_probe(struct platform_device *pdev)
 {
+#ifdef CONFIG_AM_HDMI_ONLY
+	extern int read_hpd_gpio(void);
+#endif
 	int r;
 	int ret;
     struct fb_info *fbi=NULL;
@@ -1574,7 +1577,6 @@ osd_probe(struct platform_device *pdev)
 				}else{
 					DisableVideoLayer();
 					#ifdef CONFIG_AM_HDMI_ONLY
-						extern int read_hpd_gpio(void);
 						hpd_state = read_hpd_gpio();
 
 						cvbs_mode = get_current_cvbs_vmode();
diff --git a/drivers/amlogic/display/osd/osd_rdma.c b/drivers/amlogic/display/osd/osd_rdma.c
index 378a31b18214..0033a6975cd5 100755
--- a/drivers/amlogic/display/osd/osd_rdma.c
+++ b/drivers/amlogic/display/osd/osd_rdma.c
@@ -51,8 +51,6 @@ static int  osd_rdma_init(void);
 
 static int  update_table_item(u32 addr,u32 val)
 {
-	int i;
-
 	if(item_count > (MAX_TABLE_ITEM-1)) return -1;
 
 	//new comer,then add it .
@@ -163,14 +161,13 @@ static int start_osd_rdma(char channel)
 	data32 &= ~(1<<inc_bit);   // [    2] ctrl_cbus_addr_incr_1. 1=Incremental register access; 0=Non-incremental.
 
 	aml_write_reg32(P_RDMA_ACCESS_AUTO, data32);
+	return 1;
 }
 
 static int stop_rdma(char channel)
 {
 	char intr_bit=8*channel;
-	char rw_bit=4+channel;
-	char inc_bit=channel;
-	u32 data32;
+	u32 data32 = 0x0;
 
 	data32  = aml_read_reg32(P_RDMA_ACCESS_AUTO);
 	data32 &= ~(0x1 << intr_bit);   // [23: 16] interrupt inputs enable mask for auto-start 1: vsync int bit 0
@@ -188,10 +185,6 @@ EXPORT_SYMBOL(reset_rdma);
 
 int osd_rdma_enable(u32  enable)
 {
-	char intr_bit=8;
-	char rw_bit=5;
-	char inc_bit=1;
-	u32 data32;
 	if (!osd_rdma_init_flat){
 		osd_rdma_init();
 	}
@@ -206,16 +199,17 @@ int osd_rdma_enable(u32  enable)
 	}else{
 		stop_rdma(RDMA_CHANNEL_INDEX);
 	}
+	return 1;
 }
 EXPORT_SYMBOL(osd_rdma_enable);
 
 static int  osd_rdma_init(void)
 {
 	// alloc map table .
-	static u32* table_vaddr;
+	static ulong table_vaddr;
 	osd_rdma_init_flat = true;
 	table_vaddr= __get_free_pages(GFP_KERNEL, get_order(PAGE_SIZE));
-	if (NULL==table_vaddr) {
+	if (!table_vaddr) {
 		printk("%s: failed to alloc rmda_table\n", __func__);
 		return -1;
 	}
diff --git a/drivers/amlogic/display/osd_ext/osd_hw.c b/drivers/amlogic/display/osd_ext/osd_hw.c
index ed49e527ea3d..63e4abaa1d5d 100755
--- a/drivers/amlogic/display/osd_ext/osd_hw.c
+++ b/drivers/amlogic/display/osd_ext/osd_hw.c
@@ -1376,7 +1376,7 @@ static void osd1_update_enable(void)
 			aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
 		}
 	}else{
-		u32 video_enable;
+		u32 video_enable = 0;
 
 		video_enable |= aml_read_reg32(P_VPP2_MISC) & VPP_VD1_PREBLEND;
 		if (osd_ext_hw.enable[OSD1] == ENABLE) {
@@ -1414,7 +1414,7 @@ static void osd2_update_enable(void)
 			aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
 		}
 	}else{
-		u32 video_enable;
+		u32 video_enable = 0;
 
 		video_enable |= aml_read_reg32(P_VPP2_MISC) & VPP_VD1_PREBLEND;
 		if (osd_ext_hw.enable[OSD2] == ENABLE) {
diff --git a/drivers/amlogic/display/vout/tvconf.c b/drivers/amlogic/display/vout/tvconf.c
index e5e79c431f9b..316bb226927b 100755
--- a/drivers/amlogic/display/vout/tvconf.c
+++ b/drivers/amlogic/display/vout/tvconf.c
@@ -54,6 +54,7 @@
 #define PIN_MUX_REG_0	  0x202c
 #define P_PIN_MUX_REG_0  CBUS_REG_ADDR(PIN_MUX_REG_0)
 static    disp_module_info_t    *info;
+static void  parse_vdac_setting(char *para);
 
 SET_TV_CLASS_ATTR(vdac_setting,parse_vdac_setting)
 
diff --git a/drivers/amlogic/display/vout/tvconf.h b/drivers/amlogic/display/vout/tvconf.h
index cb91eee43f90..8e00d5388c1a 100755
--- a/drivers/amlogic/display/vout/tvconf.h
+++ b/drivers/amlogic/display/vout/tvconf.h
@@ -55,7 +55,6 @@ __ATTR(name, S_IRUGO|S_IWUSR, aml_TV_attr_##name##_show, aml_TV_attr_##name##_st
 **	function declare part 
 **
 ******************************************************************/
-static void  parse_vdac_setting(char *para);
 tvmode_t vmode_to_tvmode(vmode_t mod);
 
 #endif
diff --git a/drivers/amlogic/rtc/aml_rtc.c b/drivers/amlogic/rtc/aml_rtc.c
index 1fba79814533..ef0fd6f8523b 100755
--- a/drivers/amlogic/rtc/aml_rtc.c
+++ b/drivers/amlogic/rtc/aml_rtc.c
@@ -335,7 +335,7 @@ static unsigned int _ser_access_read_locked(unsigned long addr)
 	int s_nrdy_cnt = 0;
 	int rst_times = 0;
 	if (get_rtc_status())
-		return;
+		return 0;
 	while(rtc_comm_init()<0){
 		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- rtc_common_init fail\n");
 		if(s_nrdy_cnt>RESET_RETRY_TIMES) {
@@ -385,7 +385,7 @@ static void _ser_access_write_locked(unsigned long addr, unsigned long data)
 	rtc_send_addr_data(1,addr);
 	rtc_set_mode(1); //Write
 out:
-	return 0;
+	return;
 }
 
 static unsigned int ser_access_read(unsigned long addr)
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 55c76413a7c6..6db0d9dd41d6 100755
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -417,7 +417,7 @@ static ssize_t store_##file_name					\
 	if (ret)							\
 		return -EINVAL;						\
 									\
-	ret = sscanf(buf, "%u", &freq);			\
+	ret = sscanf(buf, "%lu", &freq);			\
 	if (ret != 1)							\
 		return -EINVAL;						\
 		\
diff --git a/drivers/cpufreq/cpufreq_governor.c b/drivers/cpufreq/cpufreq_governor.c
index 3f0c2ed2e10c..8264d19dd090 100755
--- a/drivers/cpufreq/cpufreq_governor.c
+++ b/drivers/cpufreq/cpufreq_governor.c
@@ -262,7 +262,7 @@ int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 	struct cs_dbs_tuners *cs_tuners = NULL;
 	struct hg_dbs_tuners *hg_tuners = NULL;
 	struct cpu_dbs_common_info *cpu_cdbs;
-	unsigned int sampling_rate, latency, ignore_nice, j, cpu = policy->cpu;
+	unsigned int sampling_rate = 100000, latency, ignore_nice = 0, j, cpu = policy->cpu;
 	unsigned int max_periods;
 	int io_busy = 0;
 	int rc, i;
diff --git a/include/linux/amlogic/camera/aml_cam_info.h b/include/linux/amlogic/camera/aml_cam_info.h
index 51900076320b..eee10f0e5544 100755
--- a/include/linux/amlogic/camera/aml_cam_info.h
+++ b/include/linux/amlogic/camera/aml_cam_info.h
@@ -61,7 +61,7 @@ typedef enum resolution_size {
 typedef int(*aml_cam_probe_fun_t)(struct i2c_adapter *);
 
 typedef struct {
-	char* name;
+	const char* name;
 	unsigned i2c_bus_num;
 	unsigned pwdn_act;
 	unsigned front_back; /* front is 0, back is 1 */
@@ -70,8 +70,8 @@ typedef struct {
 	unsigned flash;
 	unsigned auto_focus;
 	unsigned i2c_addr;
-	char* motor_driver;
-	char* resolution;
+	const char* motor_driver;
+	const char* resolution;
 	unsigned mclk;
 	unsigned flash_support;
 	unsigned flash_ctrl_level;
@@ -84,7 +84,7 @@ typedef struct {
 	gpio_t flash_ctrl_pin;
 	resolution_size_t max_cap_size;
 	tvin_color_fmt_t bayer_fmt;
-	char* config;
+	const char* config;
 }aml_cam_info_t;
 
 typedef struct aml_camera_i2c_fig_s{
diff --git a/include/linux/amlogic/logo/logo_dev_osd.h b/include/linux/amlogic/logo/logo_dev_osd.h
index 2316b0ba2fcb..2b78a697f81e 100755
--- a/include/linux/amlogic/logo/logo_dev_osd.h
+++ b/include/linux/amlogic/logo/logo_dev_osd.h
@@ -15,10 +15,4 @@ typedef  struct {
 }hdmi_only_info_t;
 #endif
 
-static int osd0_init(logo_object_t *plogo);
-static int osd1_init(logo_object_t *plogo);
-static  int  osd_enable_set(int  enable);
-static int osd_deinit(void);
-static  int  osd_transfer(logo_object_t *plogo);
-
 #endif
diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index 53f419405fac..050bf74d85cc 100755
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -1280,4 +1280,7 @@ unsigned audio_aiu_pg_enable(unsigned char enable)
         AUDIO_CLK_GATE_OFF(AIU_ICE958_AMCLK);   
         AUDIO_CLK_GATE_OFF(AIU_TOP_LEVEL);
 	}
+    return 0;
 }
+
+
diff --git a/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
old mode 100644
new mode 100755
index adfa4bda6574..af1dba0d328f
--- a/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
+++ b/sound/soc/aml/m8/aml_audio_hw_pcm2bt.c
@@ -137,9 +137,11 @@ unsigned int pcm_in_set_rd_ptr(unsigned int value)
 
 unsigned int pcm_in_wr_ptr(void)
 {
-	unsigned int writing = READ_MPEG_REG(AUDIN_FIFO1_PTR);
+	unsigned int writing = 0;    
     unsigned int written = 0;
     unsigned int value = 0;
+    
+    writing = READ_MPEG_REG(AUDIN_FIFO1_PTR);
 
     WRITE_MPEG_REG(AUDIN_FIFO1_PTR, 1);
 	written = READ_MPEG_REG(AUDIN_FIFO1_PTR);
diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
index 0ff65e43e7c8..4fa36bf5d176 100755
--- a/sound/soc/aml/m8/aml_i2s.c
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -37,7 +37,7 @@
 #define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-platform]" fmt,##args)
 #ifdef DEBUG_ALSA_PLATFRORM
 #define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-platform]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-platform] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#define ALSA_TRACE()     			printk("[aml-platform] enter func %s,line %d\n",__FUNCTION__,__LINE__)
 #else
 #define ALSA_DEBUG(fmt,args...) 
 #define ALSA_TRACE()   
@@ -64,8 +64,8 @@ unsigned int aml_iec958_playback_start_phy = 0;
 unsigned int aml_iec958_playback_size = 0;  // in bytes
 
 
-static int audio_type_info = -1;
-static int audio_sr_info = -1;
+//static int audio_type_info = -1;
+//static int audio_sr_info = -1;
 extern unsigned audioin_mode;
 
 static DEFINE_MUTEX(gate_mutex);
@@ -142,11 +142,12 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm,
 	int stream)
 {
-	ALSA_TRACE();
+	
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 
 	size_t size = 0;
+    ALSA_TRACE();
 	    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		    size = aml_i2s_hardware.buffer_bytes_max;
 		    buf->dev.type = SNDRV_DMA_TYPE_DEV;
@@ -243,11 +244,11 @@ static int aml_i2s_prepare(struct snd_pcm_substream *substream)
 static int aml_i2s_trigger(struct snd_pcm_substream *substream,
 	int cmd)
 {
-	ALSA_TRACE();
 	struct snd_pcm_runtime *rtd = substream->runtime;
 	struct aml_runtime_data *prtd = rtd->private_data;
 	audio_stream_t *s = &prtd->s;
 	int ret = 0;
+    ALSA_TRACE();
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -322,6 +323,7 @@ static snd_pcm_uframes_t aml_i2s_pointer(
 
 	return 0;
 }	
+#if USE_HRTIMER ==1
 static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer* timer)
 {
   struct aml_runtime_data* prtd =  container_of(timer, struct aml_runtime_data, hrtimer);
@@ -330,7 +332,7 @@ static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer* timer)
   struct snd_pcm_runtime* runtime= substream->runtime;
   
   unsigned int last_ptr, size;
-  unsigned long flag;
+  //unsigned long flag;
   //printk("------------->hrtimer start\n");
   if(s->active == 0){
     hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
@@ -369,7 +371,7 @@ static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer* timer)
   hrtimer_forward_now(timer, ns_to_ktime(HRTIMER_PERIOD));
   return HRTIMER_RESTART;
 }
-
+#endif
 static void aml_i2s_timer_callback(unsigned long data)
 {
     struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
@@ -441,11 +443,11 @@ static void aml_i2s_timer_callback(unsigned long data)
 static int num_clk_gate = 0;
 static int aml_i2s_open(struct snd_pcm_substream *substream)
 {
-	ALSA_TRACE();
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	audio_stream_t *s ;		
 	int ret = 0;
+    ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		snd_soc_set_runtime_hwparams(substream, &aml_i2s_hardware);
 	}else{
@@ -646,9 +648,8 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
 	}else{
 	  res = -EFAULT;
 	}
-
-	return res;
     }
+    return res;
 }
 
 
@@ -727,10 +728,10 @@ static int aml_i2s_copy(struct snd_pcm_substream *substream, int channel,
 int aml_i2s_silence(struct snd_pcm_substream *substream, int channel,
 		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
 {
-	ALSA_TRACE();
 		char* ppos;
 		int n;
 		struct snd_pcm_runtime *runtime = substream->runtime;
+        ALSA_TRACE();
 
 		n = frames_to_bytes(runtime, count);
 		ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
@@ -759,10 +760,10 @@ static u64 aml_i2s_dmamask = 0xffffffff;
 
 static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
 {
-	ALSA_TRACE();
 	int ret = 0;
        struct snd_soc_card *card = rtd->card;
        struct snd_pcm *pcm =rtd->pcm ;  
+    ALSA_TRACE();
 	if (!card->dev->dma_mask)
 		card->dev->dma_mask = &aml_i2s_dmamask;
 	if (!card->dev->coherent_dma_mask)
@@ -790,10 +791,10 @@ static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
 
 static void aml_i2s_free_dma_buffers(struct snd_pcm *pcm)
 {
-	ALSA_TRACE();
 	struct snd_pcm_substream *substream;
 	struct snd_dma_buffer *buf;
 	int stream;
+    ALSA_TRACE();
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
 		if (!substream)
diff --git a/sound/soc/aml/m8/aml_i2s.h b/sound/soc/aml/m8/aml_i2s.h
old mode 100644
new mode 100755
index e194fb8743d2..81ee2a691874
--- a/sound/soc/aml/m8/aml_i2s.h
+++ b/sound/soc/aml/m8/aml_i2s.h
@@ -43,7 +43,7 @@ typedef struct audio_tone_control {
     int tone_flag;
 }audio_tone_control_t;
 
-struct aml_pcm_dma_params{
+struct aml_i2s_dma_params{
 		char *name;			/* stream identifier */
 		struct snd_pcm_substream *substream;
 		void (*dma_intr_handler)(u32, struct snd_pcm_substream *);
@@ -60,7 +60,7 @@ enum {
  * Data types
 \*--------------------------------------------------------------------------*/
 struct aml_runtime_data {
-	struct aml_pcm_dma_params *params;
+	struct aml_i2s_dma_params *params;
 	dma_addr_t dma_buffer;		/* physical address of dma buffer */
 	dma_addr_t dma_buffer_end;	/* first address beyond DMA buffer */
 
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index f2aae71836f7..cd4167cdf92d 100755
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -35,7 +35,7 @@ static int i2s_pos_sync = 0;
 #define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-i2s-dai]" fmt,##args)
 #ifdef DEBUG_ALSA_SOC_DAI_SPDIF
 #define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-i2s-dai]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-i2s-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#define ALSA_TRACE()     			printk("[aml-i2s-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__)
 #else
 #define ALSA_DEBUG(fmt,args...) 
 #define ALSA_TRACE()   
@@ -48,7 +48,7 @@ for the case that only use our ALSA driver for PCM s/pdif output.
 static void  aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
 {
 
-		unsigned i2s_mode;
+		unsigned i2s_mode = AIU_I2S_MODE_PCM16;
 		switch(runtime->format){
 		case SNDRV_PCM_FORMAT_S32_LE:
 			i2s_mode = AIU_I2S_MODE_PCM32;
@@ -68,11 +68,11 @@ static void  aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
 static int aml_dai_i2s_startup(struct snd_pcm_substream *substream,
 					struct snd_soc_dai *dai)
 {	  	
-	ALSA_TRACE();
 	int ret = 0;
     	struct snd_pcm_runtime *runtime = substream->runtime;
     	struct aml_runtime_data *prtd = (struct aml_runtime_data *)runtime->private_data;
-	audio_stream_t *s;	
+	audio_stream_t *s;	
+    ALSA_TRACE();
 	if(prtd == NULL){
 		prtd = (struct aml_runtime_data *)kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
 		if (prtd == NULL) {
@@ -103,12 +103,12 @@ static void aml_dai_i2s_shutdown(struct snd_pcm_substream *substream,
 static int  set_clock = -1;
 static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 					struct snd_soc_dai *dai)
-{
-	ALSA_TRACE();
+{	
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd = runtime->private_data;
 	int  sample_rate = AUDIO_CLK_FREQ_48;
 	audio_stream_t *s = &prtd->s;	
+    ALSA_TRACE();
 	switch(runtime->rate){
 		case 192000:
 			sample_rate	=	AUDIO_CLK_FREQ_192;
@@ -182,8 +182,9 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 				struct snd_soc_dai *dai)
 {
-	ALSA_TRACE();
 	struct snd_pcm_runtime *rtd = substream->runtime;
+    int * ppp = NULL;
+    ALSA_TRACE();
 	switch (cmd) {
 		case SNDRV_PCM_TRIGGER_START:
 		case SNDRV_PCM_TRIGGER_RESUME:
@@ -194,7 +195,7 @@ static int aml_dai_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 				audio_out_i2s_enable(1);
 			}else{
 				audio_in_i2s_enable(1);
-				int * ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
+				ppp = (int*)(rtd->dma_area+rtd->dma_bytes*2-8);
 				ppp[0] = 0x78787878;
 				ppp[1] = 0x78787878;
 			}
diff --git a/sound/soc/aml/m8/aml_pcm.c b/sound/soc/aml/m8/aml_pcm.c
old mode 100644
new mode 100755
index 0d632f36a512..a32e02bd04fe
--- a/sound/soc/aml/m8/aml_pcm.c
+++ b/sound/soc/aml/m8/aml_pcm.c
@@ -338,11 +338,11 @@ static int aml_pcm2bt_prepare(struct snd_pcm_substream *substream)
 }
 
 static int aml_pcm2bt_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+{  
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
 	int ret = 0;
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
 
 	switch (cmd) {
     	case SNDRV_PCM_TRIGGER_START:
@@ -385,11 +385,11 @@ static snd_pcm_uframes_t aml_pcm2bt_pointer(struct snd_pcm_substream *substream)
 }
 
 static int aml_pcm2bt_open(struct snd_pcm_substream *substream)
-{
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+{ 
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd;
 	int ret;
+    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
 
 	snd_soc_set_runtime_hwparams(substream, &aml_pcm2bt_hardware);
 
@@ -571,11 +571,12 @@ static int aml_pcm2bt_preallocate_dma_buffer(struct snd_pcm *pcm,
 
 static int aml_pcm2bt_new(struct snd_soc_pcm_runtime *rtd)
 {
-    pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
+    //pcm_debug(KERN_DEBUG "enter %s\n", __FUNCTION__);
 	int ret = 0;
        struct snd_soc_card *card = rtd->card;
        struct snd_pcm *pcm =rtd->pcm ;  
-       struct snd_soc_dai *dai =rtd->cpu_dai ;  	   
+       struct snd_soc_dai *dai ;
+       dai = rtd->cpu_dai ;  	   
        pcm_debug("enter %s dai->name: %s dai->id: %d\n", __FUNCTION__, dai->name, dai->id);
     
 	if (!card->dev->dma_mask)
diff --git a/sound/soc/aml/m8/aml_pcm_dai.c b/sound/soc/aml/m8/aml_pcm_dai.c
old mode 100644
new mode 100755
index 875e5609abbc..8ddf901b2d3a
--- a/sound/soc/aml/m8/aml_pcm_dai.c
+++ b/sound/soc/aml/m8/aml_pcm_dai.c
@@ -32,7 +32,7 @@
 #define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-pcm-dai]" fmt,##args)
 #ifdef DEBUG_ALSA_SOC_DAI_SPDIF
 #define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-pcm-dai]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-pcm-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#define ALSA_TRACE()     			printk("[aml-pcm-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__)
 #else
 #define ALSA_DEBUG(fmt,args...) 
 #define ALSA_TRACE()   
@@ -59,13 +59,14 @@ static void aml_dai_pcm_shutdown(struct snd_pcm_substream *substream,
 static int aml_dai_pcm_prepare(struct snd_pcm_substream *substream,
 					struct snd_soc_dai *dai)
 {
-#ifdef AML_DAI_DEBUG
-	printk("***Entered %s:%s\n", __FILE__,__func__);
-#endif
 //#if 1
     struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_pcm_runtime_data *prtd = runtime->private_data;
-
+
+#ifdef AML_DAI_DEBUG
+        printk("***Entered %s:%s\n", __FILE__,__func__);
+#endif
+
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
         printk(KERN_DEBUG "%s playback stream buffer start: 0x%08x size: 0x%x\n", __FUNCTION__, prtd->buffer_start, prtd->buffer_size);
         pcm_out_set_buf(prtd->buffer_start, prtd->buffer_size);
@@ -86,7 +87,7 @@ static int aml_dai_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
 				struct snd_soc_dai *dai)
 {
 	ALSA_DEBUG();
-	struct snd_pcm_runtime *rtd = substream->runtime;
+	//struct snd_pcm_runtime *rtd = substream->runtime;
 	switch (cmd) {
 		case SNDRV_PCM_TRIGGER_START:
 		case SNDRV_PCM_TRIGGER_RESUME:
diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
index f4640691e347..3111e2285a7d 100755
--- a/sound/soc/aml/m8/aml_spdif_dai.c
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -33,7 +33,7 @@
 #define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-spdif-dai]" fmt,##args)
 #ifdef DEBUG_ALSA_SPDIF_DAI
 #define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-spdif-dai]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-spdif-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__);
+#define ALSA_TRACE()     			printk("[aml-spdif-dai] enter func %s,line %d\n",__FUNCTION__,__LINE__)
 #else
 #define ALSA_DEBUG(fmt,args...) 
 #define ALSA_TRACE()   
@@ -51,8 +51,11 @@ static int aml_dai_spdif_set_sysclk(struct snd_soc_dai *cpu_dai,
 static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 				struct snd_soc_dai *dai)
 {
-    	ALSA_TRACE();
+    	
 	struct snd_soc_pcm_runtime *rtd = NULL;
+
+    ALSA_TRACE();
+    
 	rtd = (struct snd_soc_pcm_runtime *)substream->private_data;
 	switch (cmd) {
 		case SNDRV_PCM_TRIGGER_START:
@@ -94,17 +97,19 @@ special call by the audiodsp,add these code,as there are three cases for 958 s/p
 static unsigned set_clock =  -1;
 static void aml_hw_iec958_init(struct snd_pcm_substream *substream)
 {
-	_aiu_958_raw_setting_t set;
-	_aiu_958_channel_status_t chstat;
-	struct snd_dma_buffer *buf = &substream->dma_buffer;	
-    	struct snd_pcm_runtime *runtime = substream->runtime;
+    _aiu_958_raw_setting_t set;
+    _aiu_958_channel_status_t chstat;
+    unsigned i2s_mode,iec958_mode;  
+    unsigned start,size;
+    int sample_rate;
+    struct snd_dma_buffer *buf = &substream->dma_buffer;    
+    struct snd_pcm_runtime *runtime = substream->runtime;
     if(buf==NULL && runtime==NULL){
         printk("buf/0x%x runtime/0x%x\n",(unsigned )buf,(unsigned )runtime);
         return;
     }
-	unsigned i2s_mode,iec958_mode;	
-	unsigned start,size;
-	int sample_rate;
+
+    i2s_mode = AIU_I2S_MODE_PCM16;
 	sample_rate = AUDIO_CLK_FREQ_48;
 	memset((void*)(&set), 0, sizeof(set));
 	memset((void*)(&chstat), 0, sizeof(chstat));
@@ -256,11 +261,13 @@ void	aml_alsa_hw_reprepare(void)
 static int aml_dai_spdif_startup(struct snd_pcm_substream *substream,
 					struct snd_soc_dai *dai)
 {	  	
-    	ALSA_TRACE();	
+    		
 	int ret = 0;
     	struct snd_pcm_runtime *runtime = substream->runtime;
     	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s;	
+	audio_stream_t *s;	
+
+    ALSA_TRACE();
 	if(!prtd){
 		prtd = (struct aml_runtime_data *)kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
 		if (prtd == NULL) {
@@ -287,10 +294,10 @@ out:
 static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
-    	ALSA_TRACE();	
+    		
     	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_dma_buffer *buf = &substream->dma_buffer;	
-		
+	//struct snd_dma_buffer *buf = &substream->dma_buffer;	
+		ALSA_TRACE();
 	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		memset((void*)runtime->dma_area,0,snd_pcm_lib_buffer_bytes(substream));
 
@@ -303,11 +310,13 @@ static void aml_dai_spdif_shutdown(struct snd_pcm_substream *substream,
 static int aml_dai_spdif_prepare(struct snd_pcm_substream *substream,
 					struct snd_soc_dai *dai)
 {
-      ALSA_TRACE();
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+      
+	//struct snd_soc_pcm_runtime *rtd = substream->private_data;
     	struct snd_pcm_runtime *runtime = substream->runtime;
-    	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;	
+    //	struct aml_runtime_data *prtd = runtime->private_data;
+	//audio_stream_t *s = &prtd->s;
+
+    ALSA_TRACE();
 	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 		if(playback_substream_handle != (unsigned)substream)
 			playback_substream_handle = (unsigned)substream;
@@ -330,10 +339,10 @@ static int aml_dai_spdif_hw_params(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *socdai)
 {
     	ALSA_TRACE();
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-    	struct snd_pcm_runtime *runtime = substream->runtime;
-    	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;
+//	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+    //	struct snd_pcm_runtime *runtime = substream->runtime;
+  //  	struct aml_runtime_data *prtd = runtime->private_data;
+	//audio_stream_t *s = &prtd->s;
 	return 0;
 }
 
diff --git a/sound/soc/codecs/aml_m8_codec.c b/sound/soc/codecs/aml_m8_codec.c
index dd3f415c4d10..fe85931ab696 100755
--- a/sound/soc/codecs/aml_m8_codec.c
+++ b/sound/soc/codecs/aml_m8_codec.c
@@ -809,9 +809,8 @@ static int aml_m8_codec_remove(struct platform_device *pdev)
 
 static void aml_m8_codec_shutdown(struct platform_device *pdev)
 {
-    printk(KERN_DEBUG "aml_m8_platform_shutdown\n");
     struct snd_soc_codec *codec = m8_codec;
-    
+    printk(KERN_DEBUG "aml_m8_platform_shutdown\n");
     if(codec){
         u16 mute_reg = snd_soc_read(codec, AMLM8_MUTE_2) & 0xfc;
 
diff --git a/sound/soc/codecs/rt5616.c b/sound/soc/codecs/rt5616.c
index bcb6b2b29221..d380f1589d3f 100755
--- a/sound/soc/codecs/rt5616.c
+++ b/sound/soc/codecs/rt5616.c
@@ -641,11 +641,10 @@ static const struct snd_kcontrol_new rt5616_lout_mix[] = {
 
 static int rt5616_adc_event(struct snd_soc_dapm_widget *w,
     struct snd_kcontrol *kcontrol, int event)
-{
-    printk(KERN_INFO"enter %s : event=0x%x\n",__func__,event);
+{ 
     struct snd_soc_codec *codec = w->codec;
-    unsigned int val, mask;
-    
+    //unsigned int val, mask;
+   printk(KERN_INFO"enter %s : event=0x%x\n",__func__,event); 
     switch (event) {
     case SND_SOC_DAPM_POST_PMU:
         msleep(20);   // mute po sound in record begin
@@ -807,9 +806,9 @@ static int rt5616_hp_event(struct snd_soc_dapm_widget *w,
 static int rt5616_lout_event(struct snd_soc_dapm_widget *w,
     struct snd_kcontrol *kcontrol, int event)
 {
-    printk(KERN_DEBUG"enter %s : event=0x%x \n",__func__,event);
     struct snd_soc_codec *codec = w->codec;
-    int ret;
+    //int ret;
+    printk(KERN_DEBUG"enter %s : event=0x%x \n",__func__,event);
     switch (event) {
     case SND_SOC_DAPM_POST_PMU:
         hp_amp_power(codec,1);
@@ -1161,8 +1160,8 @@ static const struct snd_soc_dapm_route rt5616_dapm_routes[] = {
 
 static int rt5616_codec_digital_mute(struct snd_soc_dai *dai, int mute)
 {
-    int ret;
-    unsigned int reg_value;
+   // int ret;
+   // unsigned int reg_value;
     struct snd_soc_codec *codec = dai->codec;
     
     if(mute){
@@ -1366,7 +1365,8 @@ static int rt5616_pll_calc(const unsigned int freq_in,
     int max_n = RT5616_PLL_N_MAX, max_m = RT5616_PLL_M_MAX;
     int k, n, m, red, n_t, m_t, in_t, out_t, red_t = abs(freq_out - freq_in);
     bool bypass = false;
-
+    m = 0;
+    n = 0;
     if (RT5616_PLL_INP_MAX < freq_in || RT5616_PLL_INP_MIN > freq_in)
         return -EINVAL;
 
@@ -1620,7 +1620,7 @@ static int rt5616_remove(struct snd_soc_codec *codec)
 }
 
 #ifdef CONFIG_PM
-static int rt5616_suspend(struct snd_soc_codec *codec, pm_message_t state)
+static int rt5616_suspend(struct snd_soc_codec *codec)
 {
     //amlogic_set_value(spk_gpio_mute, 0, "mute_spk");
     //spk_mute_num = 0;
@@ -1728,7 +1728,7 @@ static int rt5616_i2c_remove(struct i2c_client *i2c)
     return 0;
 }
 
-static int rt5616_i2c_shutdown(struct i2c_client *client)
+static void rt5616_i2c_shutdown(struct i2c_client *client)
 {
     struct rt5616_priv *rt5616 = i2c_get_clientdata(client);
     struct snd_soc_codec *codec = rt5616->codec;
@@ -1741,7 +1741,7 @@ static int rt5616_i2c_shutdown(struct i2c_client *client)
         rt5616_set_bias_level(codec, SND_SOC_BIAS_OFF);
     }
 
-    return 0;
+//    return 0;
 }
 
 struct i2c_driver rt5616_i2c_driver = {
diff --git a/sound/soc/codecs/rt5616.h b/sound/soc/codecs/rt5616.h
index cdd4e204604c..a8fca4dc3de9 100755
--- a/sound/soc/codecs/rt5616.h
+++ b/sound/soc/codecs/rt5616.h
@@ -849,7 +849,7 @@
 #define RT5616_CH2_R_SEL_SL5			(0x5 << 8)
 #define RT5616_CH2_R_SEL_SL6			(0x6 << 8)
 #define RT5616_CH2_R_SEL_SL7			(0x7 << 8)
-#define RT5616_CH2_L_SEL_MASK			(0x7 << 4)
+//#define RT5616_CH2_L_SEL_MASK			(0x7 << 4)
 #define RT5616_CH4_L_SEL_SFT			4
 #define RT5616_CH4_L_SEL_SL0			(0x0 << 4)
 #define RT5616_CH4_L_SEL_SL1			(0x1 << 4)
diff --git a/sound/soc/codecs/rt5631.c b/sound/soc/codecs/rt5631.c
index 7f85451521d4..aa8434cd226f 100755
--- a/sound/soc/codecs/rt5631.c
+++ b/sound/soc/codecs/rt5631.c
@@ -32,6 +32,7 @@
 
 #include "rt5631.h"
 
+#define EQ_FUNC 0
 struct rt5631_priv {
 	struct regmap *regmap;
 	int codec_version;
diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c
index bd936bb6e526..0c1a1a61fca4 100755
--- a/sound/soc/codecs/wm8960.c
+++ b/sound/soc/codecs/wm8960.c
@@ -170,6 +170,7 @@ static int outmixer_ev(struct snd_soc_dapm_widget *w,
     snd_soc_update_bits(codec, WM8960_POWER3, mask, mask);
     return 0;
 }
+#if 0
 static int classD_ev(struct snd_soc_dapm_widget *w,
     struct snd_kcontrol *kcontrol, int event)
 {
@@ -179,12 +180,13 @@ static int classD_ev(struct snd_soc_dapm_widget *w,
     snd_soc_update_bits(codec, WM8960_CLASSD1, mask, mask);
     return 0;
 }
+#endif
 
 static int dac_ev(struct snd_soc_dapm_widget *w,
     struct snd_kcontrol *kcontrol, int event)
 {
     struct snd_soc_codec *codec = w->codec;
-    static unsigned int lout1,rout1;
+    //static unsigned int lout1,rout1;
     unsigned int mask = 1<<w->shift;
     //printk(KERN_ERR "Amlogic <> %s(%d):name %s , event(%d)\n",__func__, __LINE__, w->name, event);
     snd_soc_update_bits(codec, WM8960_POWER2, mask, mask);
@@ -1020,7 +1022,7 @@ static struct snd_soc_dai_driver wm8960_dai = {
     .symmetric_rates = 1,
 };
 
-static int wm8960_suspend(struct snd_soc_codec *codec, pm_message_t state)
+static int wm8960_suspend(struct snd_soc_codec *codec)
 {
     struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
 
@@ -1030,7 +1032,8 @@ static int wm8960_suspend(struct snd_soc_codec *codec, pm_message_t state)
 
 static int wm8960_resume(struct snd_soc_codec *codec)
 {
-    struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
+    struct wm8960_priv *wm8960 = NULL;
+    wm8960 = snd_soc_codec_get_drvdata(codec);
 
     //wm8960->set_bias_level(codec, SND_SOC_BIAS_STANDBY);
     return 0;
@@ -1152,7 +1155,7 @@ static struct snd_soc_codec_driver soc_codec_dev_wm8960 = {
 static int wm8960_i2c_probe(struct i2c_client *i2c,
                       const struct i2c_device_id *id)
 {
-    struct wm8960_data *pdata = dev_get_platdata(&i2c->dev);
+   // struct wm8960_data *pdata = dev_get_platdata(&i2c->dev);
     struct wm8960_priv *wm8960;
     int ret;
 
diff --git a/sound/usb/card.c b/sound/usb/card.c
index c2c1ccbceb92..b97ed1acdf69 100755
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -344,16 +344,17 @@ static int usb_audio_source_info_Insert(u32 usbid, int num)
 {
     int i = 0, j=0;
     struct mutex usb_audio_mutex2;
-    struct usb_audio_source_config u1;
+    struct usb_audio_source_config *u1 = NULL;
+    
     mutex_init(&usb_audio_mutex2);
     mutex_lock(&usb_audio_mutex2);
     for(i = 1; i <= num; i++)
     {
         if(usbaudioinfo[i].usbid == usbid)
         {
-            u1.usbid = usbid;
-            u1.card = usbaudioinfo[i].card;
-            u1.device = usbaudioinfo[i].device;
+            u1->usbid = usbid;
+            u1->card = usbaudioinfo[i].card;
+            u1->device = usbaudioinfo[i].device;
             for(j = i; j < num; j++)
             {
                 usbaudioinfo[j].card = usbaudioinfo[j+1].card;
@@ -362,13 +363,13 @@ static int usb_audio_source_info_Insert(u32 usbid, int num)
             }
         }
     }
-    usbaudioinfo[num].usbid = u1.usbid;
-    usbaudioinfo[num].card = u1.card;
-    usbaudioinfo[num].device = u1.device;
+    usbaudioinfo[num].usbid = u1->usbid;
+    usbaudioinfo[num].card = u1->card;
+    usbaudioinfo[num].device = u1->device;
     
-    pstr->card = u1.card;
-    pstr->device = u1.device;
-    pstr->usbid = u1.usbid;
+    pstr->card = u1->card;
+    pstr->device = u1->device;
+    pstr->usbid = u1->usbid;
     mutex_unlock(&usb_audio_mutex2);
     return 0;
 }
-- 
2.19.0

