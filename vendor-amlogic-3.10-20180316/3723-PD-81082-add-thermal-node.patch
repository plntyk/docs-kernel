From 8676e7b0fd34c95369e551b890661cdc66aec5ab Mon Sep 17 00:00:00 2001
From: xu xing <xing.xu@amlogic.com>
Date: Thu, 13 Mar 2014 11:17:05 +0800
Subject: [PATCH 3723/5965] PD#81082:add thermal node

Squashed commit of the following:

commit 20602360f589a40aa8fee209317fff1ebc2fc7a7
Author: xu xing <xing.xu@amlogic.com>
Date:   Wed Mar 12 18:12:17 2014 +0800

    pd 81802:add thermal node in other dtd

commit 01dd216efde68e015fc9452c6c97043b496914b8
Author: xu xing <xing.xu@amlogic.com>
Date:   Wed Mar 12 18:10:58 2014 +0800

    pd 81802:dtd can control enable/disable cpu/gpu cooling driver

commit 12bca90303902138a50db2ae7249c45ba6113049
Author: xu xing <xing.xu@amlogic.com>
Date:   Wed Mar 12 16:53:08 2014 +0800

    81802 del previous add dlft

commit 356a1a1e254d95a77b7defcff20623eb13d5ff0b
Author: xu xing <xing.xu@amlogic.com>
Date:   Wed Mar 12 14:58:13 2014 +0800

    PD #81802:Remove thermal warning

commit e5441a25a44cd6c4ceac48c728f3162304812e6e
Author: xu xing <xing.xu@amlogic.com>
Date:   Tue Mar 11 14:19:55 2014 +0800

    PD #81802:set mode enabled as default

commit e51e8f11371278e7b17851cc23ffd8ba2280500a
Author: xu xing <xing.xu@amlogic.com>
Date:   Mon Mar 10 18:35:32 2014 +0800

    PD #81802:FIX GPU cooling driver and add get current max interface

commit 82c717cdcd5f2eb2c67a67fdb63089fdb8a53686
Author: xu xing <xing.xu@amlogic.com>
Date:   Sun Mar 9 14:08:39 2014 +0800

    PD 81802 : FIX CPU cooling state

commit 329d64cbdb17d206496ca89e2977d2872d3d1daf
Author: xu xing <xing.xu@amlogic.com>
Date:   Fri Mar 7 18:39:10 2014 +0800

    thermal:get cpu current state from cpufreq interface

commit b776655c7dbbd7f7c250967caf1627fd0494df35
Author: xu xing <xing.xu@amlogic.com>
Date:   Wed Mar 5 16:42:22 2014 +0800

    k100-1G:gpu cooling device

commit 554478157b3e7db8bddbc055f03c0da23bbe04a9
Author: xu xing <xing.xu@amlogic.com>
Date:   Thu Jan 2 16:19:28 2014 +0800

    PD #81802:Add gpu_cooling driver
---
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd  |   8 +-
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd  |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd  |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd  |   8 +-
 .../boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd |   8 +-
 .../boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd |   8 +-
 arch/arm/boot/dts/amlogic/meson8_skt.dtd      |   8 +-
 drivers/amlogic/input/saradc/saradc.c         |   2 +-
 drivers/amlogic/thermal/Kconfig               |   1 +
 drivers/amlogic/thermal/amlogic_thermal.c     | 148 ++++++++----
 drivers/thermal/Kconfig                       |  12 +
 drivers/thermal/Makefile                      |   3 +
 drivers/thermal/cpu_cooling.c                 |  16 +-
 drivers/thermal/gpu_cooling.c                 | 227 ++++++++++++++++++
 drivers/thermal/step_wise.c                   |  15 +-
 drivers/thermal/thermal_core.c                |   2 +-
 include/linux/amlogic/saradc.h                |   2 +-
 include/linux/cpufreq.h                       |   1 -
 include/linux/gpu_cooling.h                   |  93 +++++++
 25 files changed, 508 insertions(+), 118 deletions(-)
 mode change 100644 => 100755 drivers/thermal/cpu_cooling.c
 create mode 100755 drivers/thermal/gpu_cooling.c
 mode change 100644 => 100755 drivers/thermal/thermal_core.c
 mode change 100644 => 100755 include/linux/cpufreq.h
 create mode 100755 include/linux/gpu_cooling.h

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index 16b93ab20060..4820846b733e 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -1776,11 +1776,11 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index daea0295bdba..8bdedb9d20dd 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -1808,11 +1808,11 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
index 54f4a47b8149..c8f44b343e2c 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
@@ -1735,11 +1735,11 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index 235873f802f4..b0cf0182c578 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -1687,11 +1687,11 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<30 1200000 1200000 500 500
+			    70  800000 800000 400 400
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index 57652177c9f6..81e85e93e5c7 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -1704,11 +1704,11 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
index f5b467a3b9b4..f3a4448cd098 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
@@ -1702,11 +1702,11 @@ lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{	//k101
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
index e74f310a23c3..6be816fea5c6 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
@@ -963,11 +963,11 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
index 5594c2a1099e..99a8c706801e 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_v1.dtd
@@ -859,11 +859,11 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd
index d457848f9272..6d32a1f51b97 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd
@@ -850,11 +850,11 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
index 8a68698b7181..925bfb14febd 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
@@ -868,11 +868,11 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
index c8d173f3feeb..452ab9dbe654 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
@@ -858,11 +858,11 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd
index f135976a0004..c7086b9f7b09 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd
@@ -848,11 +848,11 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_skt.dtd b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
index a6565591ecfb..4a6732876771 100755
--- a/arch/arm/boot/dts/amlogic/meson8_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
@@ -1198,11 +1198,11 @@ void root_func(){
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<3>;
+		#thermal-cells=<5>;
 		dev_name = "aml_thermal";
-		trip_point=<50 1200000 1200000
-			    70  800000 800000
-			    110 0xffffffff 0xffffffff>;
+		trip_point=<40 1200000 1200000 500 500
+			    70  800000 800000 400 400 
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/drivers/amlogic/input/saradc/saradc.c b/drivers/amlogic/input/saradc/saradc.c
index 6965ef43a96b..bff694a833f3 100755
--- a/drivers/amlogic/input/saradc/saradc.c
+++ b/drivers/amlogic/input/saradc/saradc.c
@@ -417,7 +417,7 @@ static struct class saradc_class = {
     .class_attrs = saradc_class_attrs,
 };
 
-int get_cpu_temp()
+int get_cpu_temp(void)
 {
 #ifdef CONFIG_ARCH_MESON8
 	int ret=-1,tempa;
diff --git a/drivers/amlogic/thermal/Kconfig b/drivers/amlogic/thermal/Kconfig
index a1e25057d424..56ae499d2e8d 100644
--- a/drivers/amlogic/thermal/Kconfig
+++ b/drivers/amlogic/thermal/Kconfig
@@ -5,6 +5,7 @@ config AMLOGIC_THERMAL
     bool "amlogic thermal support"
     select THERMAL
     select CPU_THERMAL
+    select GPU_THERMAL
     default n
     help
       This is the Amlogic Thermal interface driver
diff --git a/drivers/amlogic/thermal/amlogic_thermal.c b/drivers/amlogic/thermal/amlogic_thermal.c
index 1d12cbe3a809..68ebfb0f9ac9 100755
--- a/drivers/amlogic/thermal/amlogic_thermal.c
+++ b/drivers/amlogic/thermal/amlogic_thermal.c
@@ -40,33 +40,40 @@
 #include <linux/amlogic/saradc.h>
 #include <plat/cpu.h>
 #include <linux/random.h>
+#include <linux/gpu_cooling.h>
 struct freq_trip_table {
 	unsigned int freq_state;
 };
 struct temp_trip{
 	unsigned int temperature;
-	unsigned int upper_freq;
-	unsigned int lower_freq;
-	int upper_level;
-	int lower_level;
-	
+	unsigned int cpu_upper_freq;
+	unsigned int cpu_lower_freq;
+	int cpu_upper_level;
+	int cpu_lower_level;
+	unsigned int gpu_upper_freq;
+	unsigned int gpu_lower_freq;
+	int gpu_upper_level;
+	int gpu_lower_level;	
 };
 #define TMP_TRIP_COUNT 4
 struct amlogic_thermal_platform_data {
-	char *name;
+	const char *name;
 	struct temp_trip tmp_trip[TMP_TRIP_COUNT];
 	unsigned int temp_trip_count;
 	unsigned int critical_temp;
 	unsigned int idle_interval;
 	struct thermal_zone_device *therm_dev;
-	struct thermal_cooling_device *cool_dev;
+	struct thermal_cooling_device *cpu_cool_dev;
+	struct thermal_cooling_device *gpu_cool_dev;
 	enum thermal_device_mode mode;
 	struct mutex lock;
 };
 struct temp_level{
 	unsigned int temperature;
-	int high_freq;
-	int low_freq;
+	int cpu_high_freq;
+	int cpu_low_freq;
+	int gpu_high_freq;
+	int gpu_low_freq;
 };
 
 /* CPU Zone information */
@@ -184,21 +191,61 @@ static int amlogic_bind(struct thermal_zone_device *thermal,
 {
 	int ret = 0, i;
 	struct  amlogic_thermal_platform_data *pdata= thermal->devdata;
-	if(cdev !=pdata->cool_dev){
-		ret = -EINVAL;
-		goto out;
+	int id;
+	char type[THERMAL_NAME_LENGTH];
+	if (!sscanf(cdev->type, "thermal-%7s-%d", type,&id))
+		return -EINVAL;
+	if(!strcmp(type,"cpufreq")){
+		/* Bind the thermal zone to the cpufreq cooling device */
+		for (i = 0; i < pdata->temp_trip_count; i++) {
+			if(pdata->tmp_trip[i].cpu_upper_level==THERMAL_CSTATE_INVALID)
+			{
+				printk("disable cpu cooling device by dtd\n");
+				ret = -EINVAL;
+				goto out;
+			}
+			if (thermal_zone_bind_cooling_device(thermal, i, cdev,
+								pdata->tmp_trip[i].cpu_upper_level,
+								pdata->tmp_trip[i].cpu_lower_level)) {
+				pr_err("error binding cdev inst %d\n", i);
+				ret = -EINVAL;
+				goto out;
+			}
+		}
+		pr_info("%s bind %s okay !\n",thermal->type,cdev->type);
 	}
-	/* Bind the thermal zone to the cpufreq cooling device */
-	for (i = 0; i < pdata->temp_trip_count; i++) {
-		if (thermal_zone_bind_cooling_device(thermal, i, cdev,
-							pdata->tmp_trip[i].upper_level,
-							pdata->tmp_trip[i].lower_level)) {
-			pr_err("error binding cdev inst %d\n", i);
-			ret = -EINVAL;
-			goto out;
+	
+	if(!strcmp(type,"gpufreq")){
+		struct gpufreq_cooling_device *gpufreq_dev=
+			(struct gpufreq_cooling_device *)cdev->devdata;
+		/* Bind the thermal zone to the cpufreq cooling device */
+		for (i = 0; i < pdata->temp_trip_count; i++) {
+			if(!gpufreq_dev->get_gpu_freq_level){
+				ret = -EINVAL;
+				pr_info("invalidate pointer %p\n",gpufreq_dev->get_gpu_freq_level);
+				goto out;
+			}
+			pdata->tmp_trip[i].gpu_lower_level=gpufreq_dev->get_gpu_freq_level(pdata->tmp_trip[i].gpu_upper_freq);
+			pdata->tmp_trip[i].gpu_upper_level=gpufreq_dev->get_gpu_freq_level(pdata->tmp_trip[i].gpu_lower_freq);
+			printk("pdata->tmp_trip[%d].gpu_lower_level=%d\n",i,pdata->tmp_trip[i].gpu_lower_level);
+			printk("pdata->tmp_trip[%d].gpu_upper_level=%d\n",i,pdata->tmp_trip[i].gpu_upper_level);
+			if(pdata->tmp_trip[i].gpu_lower_level==THERMAL_CSTATE_INVALID)
+			{
+				printk("disable gpu cooling device by dtd\n");
+				ret = -EINVAL;
+				goto out;
+			}
+			if (thermal_zone_bind_cooling_device(thermal, i, cdev,
+								pdata->tmp_trip[i].gpu_upper_level,
+								pdata->tmp_trip[i].gpu_lower_level)) {
+				pr_err("error binding cdev inst %d\n", i);
+				ret = -EINVAL;
+				goto out;
+			}
 		}
+		pr_info("%s bind %s okay !\n",thermal->type,cdev->type);
 	}
-	pr_info("%s bind %s okay !\n",thermal->type,cdev->type);
+	
 	return ret;
 out:
 	return ret;
@@ -212,10 +259,12 @@ static int amlogic_unbind(struct thermal_zone_device *thermal,
 	if(thermal && cdev){
 		struct  amlogic_thermal_platform_data *pdata= thermal->devdata;
 		for (i = 0; i < pdata->temp_trip_count; i++) {
+			pr_info("\n%s unbinding %s ",thermal->type,cdev->type);
 			if (thermal_zone_unbind_cooling_device(thermal, i, cdev)) {
-				pr_err("error binding cdev inst %d\n", i);
+				pr_err(" error  %d \n", i);
 				return -EINVAL;
 			}
+			pr_info(" okay\n");
 			return 0;
 		}
 	}else{
@@ -243,8 +292,8 @@ static int amlogic_get_temp(struct thermal_zone_device *thermal,
 	printk("========  temp=%d\n",aa);
 	*temp=aa;
 #else
-	*temp = get_cpu_temp();
-	printk("========  temp=%d\n",*temp);
+	*temp = (unsigned long)get_cpu_temp();
+	printk(KERN_DEBUG "========  temp=%ld\n",*temp);
 #endif
 	return 0;
 }
@@ -278,12 +327,13 @@ static int amlogic_register_thermal(struct amlogic_thermal_platform_data *pdata)
 	struct cpumask mask_val;
 
 	cpumask_set_cpu(0, &mask_val);
-	pdata->cool_dev= cpufreq_cooling_register(&mask_val);
-	if (IS_ERR(pdata->cool_dev)) {
+	pdata->cpu_cool_dev= cpufreq_cooling_register(&mask_val);
+	if (IS_ERR(pdata->cpu_cool_dev)) {
 		pr_err("Failed to register cpufreq cooling device\n");
 		ret = -EINVAL;
 		goto err_unregister;
 	}
+	//pdata->gpu_cool_dev=gpufreq_cooling_register();
 
 	pdata->therm_dev = thermal_zone_device_register(pdata->name,
 			pdata->temp_trip_count, 7, pdata, &amlogic_dev_ops, NULL, 0,
@@ -309,8 +359,8 @@ static void amlogic_unregister_thermal(struct amlogic_thermal_platform_data *pda
 {
 	if (pdata->therm_dev)
 		thermal_zone_device_unregister(pdata->therm_dev);
-	if (pdata->cool_dev)
-		cpufreq_cooling_unregister(pdata->cool_dev);
+	if (pdata->cpu_cool_dev)
+		cpufreq_cooling_unregister(pdata->cpu_cool_dev);
 
 	pr_info("amlogic: Kernel Thermal management unregistered\n");
 }
@@ -319,13 +369,17 @@ struct amlogic_thermal_platform_data Pdata={
 	.name="amlogic, theraml",
 	.tmp_trip[0]={
 		.temperature=50,
-		.upper_freq=1296000,
-		.lower_freq=912000,
+		.cpu_upper_freq=1296000,
+		.cpu_lower_freq=912000,
+		.gpu_upper_freq=5000,
+		.gpu_lower_freq=5000,
 	},
 	.tmp_trip[1]={
 		.temperature=100,
-		.upper_freq=816000,
-		.lower_freq=312000,
+		.cpu_upper_freq=816000,
+		.cpu_lower_freq=312000,
+		.gpu_upper_freq=4000,
+		.gpu_lower_freq=4000,
 	},
 	.tmp_trip[2]={
 		.temperature=110,
@@ -333,7 +387,7 @@ struct amlogic_thermal_platform_data Pdata={
 	.temp_trip_count=3,
 	.idle_interval=1000,
 	.therm_dev=NULL,
-	.cool_dev=NULL,
+	.cpu_cool_dev=NULL,
 };
 
 static  struct  amlogic_thermal_platform_data *amlogic_get_driver_data(
@@ -442,15 +496,18 @@ static struct amlogic_thermal_platform_data * amlogic_thermal_init_from_dts(stru
 		for (i = 0; i < pdata->temp_trip_count; i++) {
 			printk("temperature=%d on trip point=%d\n",tmp_level[i].temperature,i);
 			pdata->tmp_trip[i].temperature=tmp_level[i].temperature;
-			printk("fixing high_freq=%d to ",tmp_level[i].high_freq);
-			tmp_level[i].high_freq=fix_to_freq(tmp_level[i].high_freq,descend);
-			pdata->tmp_trip[i].lower_level=cpufreq_cooling_get_level(0,tmp_level[i].high_freq);
-			printk("%d at trip point %d,level=%d\n",tmp_level[i].high_freq,i,pdata->tmp_trip[i].lower_level);	
+			printk("fixing high_freq=%d to ",tmp_level[i].cpu_high_freq);
+			tmp_level[i].cpu_high_freq=fix_to_freq(tmp_level[i].cpu_high_freq,descend);
+			pdata->tmp_trip[i].cpu_lower_level=cpufreq_cooling_get_level(0,tmp_level[i].cpu_high_freq);
+			printk("%d at trip point %d,level=%d\n",tmp_level[i].cpu_high_freq,i,pdata->tmp_trip[i].cpu_lower_level);	
 			
-			printk("fixing low_freq=%d to ",tmp_level[i].low_freq);
-			tmp_level[i].low_freq=fix_to_freq(tmp_level[i].low_freq,descend);
-			pdata->tmp_trip[i].upper_level=cpufreq_cooling_get_level(0,tmp_level[i].low_freq);
-			printk("%d at trip point %d,level=%d\n",tmp_level[i].low_freq,i,pdata->tmp_trip[i].upper_level);	
+			printk("fixing low_freq=%d to ",tmp_level[i].cpu_low_freq);
+			tmp_level[i].cpu_low_freq=fix_to_freq(tmp_level[i].cpu_low_freq,descend);
+			pdata->tmp_trip[i].cpu_upper_level=cpufreq_cooling_get_level(0,tmp_level[i].cpu_low_freq);
+			printk("%d at trip point %d,level=%d\n",tmp_level[i].cpu_low_freq,i,pdata->tmp_trip[i].cpu_upper_level);
+			pdata->tmp_trip[i].gpu_lower_freq=tmp_level[i].gpu_low_freq;
+			pdata->tmp_trip[i].gpu_upper_freq=tmp_level[i].gpu_high_freq;
+			printk("gpu[%d].gpu_high_freq=%d,tmp_level[%d].gpu_high_freq=%d\n",i,tmp_level[i].gpu_high_freq,i,tmp_level[i].gpu_low_freq);
 		}
 		
 		ret= of_property_read_u32(pdev->dev.of_node, "idle_interval", &val);
@@ -466,6 +523,7 @@ static struct amlogic_thermal_platform_data * amlogic_thermal_init_from_dts(stru
 			goto err;
 		}
 		printk("pdata->name:%s\n",pdata->name);
+		pdata->mode=THERMAL_DEVICE_ENABLED;
 		if(tmp_level)
 			kfree(tmp_level);
 		return pdata;
@@ -487,10 +545,10 @@ static struct amlogic_thermal_platform_data * amlogic_thermal_initialize(struct
 		pdata=amlogic_get_driver_data(pdev);
 		// Get level
 		for (i = 0; i < pdata->temp_trip_count; i++) {
-			pdata->tmp_trip[i].upper_level=cpufreq_cooling_get_level(0,pdata->tmp_trip[i].lower_freq);
-			pdata->tmp_trip[i].lower_level=cpufreq_cooling_get_level(0,pdata->tmp_trip[i].upper_freq);
-			printk("pdata->tmp_trip[%d].upper_level=%d\n",i,pdata->tmp_trip[i].upper_level);
-			printk("pdata->tmp_trip[%d].lower_level=%d\n",i,pdata->tmp_trip[i].lower_level);
+			pdata->tmp_trip[i].cpu_upper_level=cpufreq_cooling_get_level(0,pdata->tmp_trip[i].cpu_lower_freq);
+			pdata->tmp_trip[i].cpu_lower_level=cpufreq_cooling_get_level(0,pdata->tmp_trip[i].cpu_upper_freq);
+			printk("pdata->tmp_trip[%d].cpu_upper_level=%d\n",i,pdata->tmp_trip[i].cpu_upper_level);
+			printk("pdata->tmp_trip[%d].cpu_lower_level=%d\n",i,pdata->tmp_trip[i].cpu_lower_level);
 		}
 	}
 	
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index 5e3c02554d99..e6f8727db2a7 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -79,6 +79,18 @@ config CPU_THERMAL
 
 	  If you want this support, you should say Y here.
 
+config GPU_THERMAL
+	bool "generic gpu cooling support"
+	depends on (MALI400 || MALI400_MODULE)
+	help
+	  This implements the generic gpu cooling mechanism through frequency
+	  reduction. An ACPI version of this already exists
+	  (drivers/acpi/processor_thermal.c).
+	  This will be useful for platforms using the generic thermal interface
+	  and not the ACPI interface.
+
+	  If you want this support, you should say Y here.
+
 config THERMAL_EMULATION
 	bool "Thermal emulation mode support"
 	help
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index c054d410ac3f..019f0971776a 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -13,6 +13,9 @@ thermal_sys-$(CONFIG_THERMAL_GOV_USER_SPACE)	+= user_space.o
 # cpufreq cooling
 thermal_sys-$(CONFIG_CPU_THERMAL)	+= cpu_cooling.o
 
+# cpufreq cooling
+thermal_sys-$(CONFIG_GPU_THERMAL)	+= gpu_cooling.o
+
 # platform thermal drivers
 obj-$(CONFIG_SPEAR_THERMAL)	+= spear_thermal.o
 obj-$(CONFIG_RCAR_THERMAL)	+= rcar_thermal.o
diff --git a/drivers/thermal/cpu_cooling.c b/drivers/thermal/cpu_cooling.c
old mode 100644
new mode 100755
index 2155a7056943..5dae03e22d7e
--- a/drivers/thermal/cpu_cooling.c
+++ b/drivers/thermal/cpu_cooling.c
@@ -276,10 +276,10 @@ static int cpufreq_apply_cooling(struct cpufreq_cooling_device *cpufreq_device,
 	struct cpumask *mask = &cpufreq_device->allowed_cpus;
 	unsigned int cpu = cpumask_any(mask);
 
-	printk("cpufreq_device->cpufreq_state=%d,cooling_state=%d\n",cpufreq_device->cpufreq_state,cooling_state);
+	printk(KERN_DEBUG "cpufreq_device->cpufreq_state=%d,cooling_state=%ld\n",cpufreq_device->cpufreq_state,cooling_state);
 	/* Check if the old cooling action is same as new cooling action */
-	if (cpufreq_device->cpufreq_state == cooling_state)
-		return 0;
+	//if (cpufreq_device->cpufreq_state == cooling_state)
+		//return 0;
 
 	clip_freq = get_cpu_frequency(cpu, cooling_state);
 	if (!clip_freq)
@@ -321,13 +321,13 @@ static int cpufreq_thermal_notifier(struct notifier_block *nb,
 		max_freq = notify_device->cpufreq_val;
 	else
 		return 0;
-	printk("policy->max=%d,max_freq=%d\n",policy->max,max_freq);
+	printk(KERN_DEBUG "policy->max=%d,max_freq=%ld\n",policy->max,max_freq);
 	/* Never exceed user_policy.max */
 	if (max_freq > policy->user_policy.max)
 		max_freq = policy->user_policy.max;
 	if (policy->max != max_freq)
 		cpufreq_verify_within_limits(policy, 0, max_freq);
-	printk("policy->max=%d\n",policy->max);
+	printk(KERN_DEBUG "policy->max=%d\n",policy->max);
 	return 0;
 }
 
@@ -375,10 +375,8 @@ static int cpufreq_get_max_state(struct thermal_cooling_device *cdev,
 static int cpufreq_get_cur_state(struct thermal_cooling_device *cdev,
 				 unsigned long *state)
 {
-	struct cpufreq_cooling_device *cpufreq_device = cdev->devdata;
-
-	*state = cpufreq_device->cpufreq_state;
-
+	*state=cpufreq_cooling_get_level(0,cpufreq_quick_get_max(0));
+	printk(KERN_DEBUG "*state=%ld\n",*state);
 	return 0;
 }
 
diff --git a/drivers/thermal/gpu_cooling.c b/drivers/thermal/gpu_cooling.c
new file mode 100755
index 000000000000..04f6cc4069a3
--- /dev/null
+++ b/drivers/thermal/gpu_cooling.c
@@ -0,0 +1,227 @@
+/*
+ *  linux/drivers/thermal/gpu_cooling.c
+ *
+ *  Copyright (C) 2012	Samsung Electronics Co., Ltd(http://www.samsung.com)
+ *  Copyright (C) 2012  Amit Daniel <amit.kachhap@linaro.org>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#include <linux/module.h>
+#include <linux/thermal.h>
+#include <linux/cpufreq.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/cpu.h>
+#include <linux/gpu_cooling.h>
+
+
+static DEFINE_IDR(gpufreq_idr);
+static DEFINE_MUTEX(cooling_gpufreq_lock);
+
+
+/* notify_table passes value to the gpuFREQ_ADJUST callback function. */
+#define NOTIFY_INVALID NULL
+
+/**
+ * get_idr - function to get a unique id.
+ * @idr: struct idr * handle used to create a id.
+ * @id: int * value generated by this function.
+ *
+ * This function will populate @id with an unique
+ * id, using the idr API.
+ *
+ * Return: 0 on success, an error code on failure.
+ */
+static int get_idr(struct idr *idr, int *id)
+{
+	int ret;
+
+	mutex_lock(&cooling_gpufreq_lock);
+	ret = idr_alloc(idr, NULL, 0, 0, GFP_KERNEL);
+	mutex_unlock(&cooling_gpufreq_lock);
+	if (unlikely(ret < 0))
+		return ret;
+	*id = ret;
+
+	return 0;
+}
+
+/**
+ * release_idr - function to free the unique id.
+ * @idr: struct idr * handle used for creating the id.
+ * @id: int value representing the unique id.
+ */
+static void release_idr(struct idr *idr, int id)
+{
+	mutex_lock(&cooling_gpufreq_lock);
+	idr_remove(idr, id);
+	mutex_unlock(&cooling_gpufreq_lock);
+}
+
+
+/* gpufreq cooling device callback functions are defined below */
+
+/**
+ * gpufreq_get_max_state - callback function to get the max cooling state.
+ * @cdev: thermal cooling device pointer.
+ * @state: fill this variable with the max cooling state.
+ *
+ * Callback for the thermal cooling device to return the gpufreq
+ * max cooling state.
+ *
+ * Return: 0 on success, an error code otherwise.
+ */
+static int gpufreq_get_max_state(struct thermal_cooling_device *cdev,
+				 unsigned long *state)
+{
+	struct gpufreq_cooling_device *gpufreq_device = cdev->devdata;
+	*state = (unsigned long)(gpufreq_device->get_gpu_max_level());
+	printk(KERN_DEBUG "default max state=%ld\n",*state);
+	return 0;
+}
+
+/**
+ * gpufreq_get_cur_state - callback function to get the current cooling state.
+ * @cdev: thermal cooling device pointer.
+ * @state: fill this variable with the current cooling state.
+ *
+ * Callback for the thermal cooling device to return the gpufreq
+ * current cooling state.
+ *
+ * Return: 0 on success, an error code otherwise.
+ */
+static int gpufreq_get_cur_state(struct thermal_cooling_device *cdev,
+				 unsigned long *state)
+{
+	struct gpufreq_cooling_device *gpufreq_device = cdev->devdata;
+	//*state = gpufreq_device->gpufreq_state;
+	*state = gpufreq_device->get_gpu_current_max_level();
+	printk(KERN_DEBUG "current max state=%ld\n",*state);
+	return 0;
+}
+
+/**
+ * gpufreq_set_cur_state - callback function to set the current cooling state.
+ * @cdev: thermal cooling device pointer.
+ * @state: set this variable to the current cooling state.
+ *
+ * Callback for the thermal cooling device to change the gpufreq
+ * current cooling state.
+ *
+ * Return: 0 on success, an error code otherwise.
+ */
+static int gpufreq_set_cur_state(struct thermal_cooling_device *cdev,
+				 unsigned long state)
+{
+	struct gpufreq_cooling_device *gpufreq_device = cdev->devdata;
+	unsigned long max_state;
+	int ret;
+	printk(KERN_DEBUG "state=%ld,gpufreq_device->gpufreq_state=%d\n",state,gpufreq_device->gpufreq_state);
+	//if (gpufreq_device->gpufreq_state == state)
+		//return 0;
+	gpufreq_device->gpufreq_state = state;
+	ret=gpufreq_get_max_state(cdev,&max_state);
+	state=max_state-1-state;
+	
+	printk(KERN_DEBUG "state=%ld,gpufreq_device->gpufreq_state=%d\n",state,gpufreq_device->gpufreq_state);
+	if(state>=0 && state<=max_state){
+		if (gpufreq_device->set_gpu_freq_idx)
+			gpufreq_device->set_gpu_freq_idx((unsigned int)state);
+	}
+	return 0;
+	
+	
+}
+
+/* Bind gpufreq callbacks to thermal cooling device ops */
+static struct thermal_cooling_device_ops const gpufreq_cooling_ops = {
+	.get_max_state = gpufreq_get_max_state,
+	.get_cur_state = gpufreq_get_cur_state,
+	.set_cur_state = gpufreq_set_cur_state,
+};
+
+
+/**
+ * gpufreq_cooling_register - function to create gpufreq cooling device.
+ * @clip_gpus: gpumask of gpus where the frequency constraints will happen.
+ *
+ * This interface function registers the gpufreq cooling device with the name
+ * "thermal-gpufreq-%x". This api can support multiple instances of gpufreq
+ * cooling devices.
+ *
+ * Return: a valid struct thermal_cooling_device pointer on success,
+ * on failure, it returns a corresponding ERR_PTR().
+ */
+struct gpufreq_cooling_device * gpufreq_cooling_alloc(void)
+{
+	struct gpufreq_cooling_device *gcdev;
+	gcdev=kzalloc(sizeof(struct gpufreq_cooling_device), GFP_KERNEL);
+	if (!gcdev)
+		return ERR_PTR(-ENOMEM);
+	memset(gcdev,0,sizeof(*gcdev));
+	return gcdev;
+}
+EXPORT_SYMBOL_GPL(gpufreq_cooling_alloc);
+int gpufreq_cooling_register(struct gpufreq_cooling_device *gpufreq_dev)
+{
+	struct thermal_cooling_device *cool_dev;
+	char dev_name[THERMAL_NAME_LENGTH];
+	int ret = 0;
+
+	ret = get_idr(&gpufreq_idr, &gpufreq_dev->id);
+	if (ret) {
+		kfree(gpufreq_dev);
+		return -EINVAL;
+	}
+
+	snprintf(dev_name, sizeof(dev_name), "thermal-gpufreq-%d",
+		 gpufreq_dev->id);
+
+	cool_dev = thermal_cooling_device_register(dev_name, gpufreq_dev,
+						   &gpufreq_cooling_ops);
+	if (!cool_dev) {
+		release_idr(&gpufreq_idr, gpufreq_dev->id);
+		kfree(gpufreq_dev);
+		return -EINVAL;
+	}
+	gpufreq_dev->cool_dev = cool_dev;
+	gpufreq_dev->gpufreq_state = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gpufreq_cooling_register);
+
+/**
+ * gpufreq_cooling_unregister - function to remove gpufreq cooling device.
+ * @cdev: thermal cooling device pointer.
+ *
+ * This interface function unregisters the "thermal-gpufreq-%x" cooling device.
+ */
+void gpufreq_cooling_unregister(struct thermal_cooling_device *cdev)
+{
+	struct gpufreq_cooling_device *gpufreq_dev;
+
+	if (!cdev)
+		return;
+
+	gpufreq_dev = cdev->devdata;
+
+	thermal_cooling_device_unregister(gpufreq_dev->cool_dev);
+	release_idr(&gpufreq_idr, gpufreq_dev->id);
+	kfree(gpufreq_dev);
+}
+EXPORT_SYMBOL_GPL(gpufreq_cooling_unregister);
diff --git a/drivers/thermal/step_wise.c b/drivers/thermal/step_wise.c
index 127ec6b0f567..db47fef97622 100755
--- a/drivers/thermal/step_wise.c
+++ b/drivers/thermal/step_wise.c
@@ -58,8 +58,8 @@ static unsigned long get_target_state(struct thermal_instance *instance,
 	 * Otherwise, we use the current state of the
 	 * cdev in use to determine the next_target.
 	 */
-	cdev->ops->get_cur_state(cdev, &cur_state);
-	next_target = instance->target;
+	cdev->ops->get_cur_state(cdev, (unsigned long *)&cur_state);
+	next_target = (int)instance->target;
 	
 	switch (trend) {
 	case THERMAL_TREND_RAISING:
@@ -94,16 +94,15 @@ static unsigned long get_target_state(struct thermal_instance *instance,
 	default:
 		break;
 	}
-#if 0
-	printk("instance:%s,trend=%d,throttle=%d,instace->target=%d,cur_state=%d,next_target=%d\n",
+
+	printk(KERN_DEBUG "instance:%s,trend=%d,throttle=%d,instace->target=%ld,cur_state=%d,next_target=%d\n",
 		instance->name,
 		trend,
 		throttle,
 		instance->target,
 		cur_state,
 		next_target);
-#endif
-	return next_target;
+	return (unsigned long)next_target;
 }
 
 static void update_passive_instance(struct thermal_zone_device *tz,
@@ -148,8 +147,8 @@ static void thermal_zone_trip_update(struct thermal_zone_device *tz, int trip)
 		old_target = instance->target;
 		instance->target = get_target_state(instance, trend, throttle);
 
-		if (old_target == instance->target)
-			continue;
+		//if (old_target == instance->target)
+			//continue;
 
 		/* Activate a passive thermal instance */
 		if (old_target == THERMAL_NO_TARGET &&
diff --git a/drivers/thermal/thermal_core.c b/drivers/thermal/thermal_core.c
old mode 100644
new mode 100755
index 54dd1dc70e24..417a8d20bb8e
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@ -1446,7 +1446,7 @@ void thermal_cdev_update(struct thermal_cooling_device *cdev)
 			continue;
 		if (instance->target > target)
 			target = instance->target;
-		printk("instance->target=%d,target=%d\n",instance->target,target);
+		printk(KERN_DEBUG "instance->target=%d,target=%d\n",instance->target,target);
 	}
 	mutex_unlock(&cdev->lock);
 	cdev->ops->set_cur_state(cdev, target);
diff --git a/include/linux/amlogic/saradc.h b/include/linux/amlogic/saradc.h
index 782eeeb3ad7e..33b9741c7fdc 100755
--- a/include/linux/amlogic/saradc.h
+++ b/include/linux/amlogic/saradc.h
@@ -36,5 +36,5 @@ enum {
 
 extern int get_adc_sample(int chan);
 extern int saradc_ts_service(int cmd);
-extern int  get_cpu_temp();
+extern int  get_cpu_temp(void);
 #endif
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
old mode 100644
new mode 100755
index 7157d55efa94..4c7a0527aeb7
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -100,7 +100,6 @@ struct cpufreq_policy {
 	unsigned int		last_cpu; /* cpu nr of previous CPU that managed
 					   * this policy */
 	struct cpufreq_cpuinfo	cpuinfo;/* see above */
-
 	unsigned int		min;    /* in kHz */
 	unsigned int		max;    /* in kHz */
 	unsigned int		dflt;    /* in kHz */
diff --git a/include/linux/gpu_cooling.h b/include/linux/gpu_cooling.h
new file mode 100755
index 000000000000..8e0655203962
--- /dev/null
+++ b/include/linux/gpu_cooling.h
@@ -0,0 +1,93 @@
+/*
+ *  linux/include/linux/gpu_cooling.h
+ *
+ *  Copyright (C) 2012	Samsung Electronics Co., Ltd(http://www.samsung.com)
+ *  Copyright (C) 2012  Amit Daniel <amit.kachhap@linaro.org>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef __gpu_COOLING_H__
+#define __gpu_COOLING_H__
+
+#include <linux/thermal.h>
+#include <linux/cpumask.h>
+
+#ifdef CONFIG_GPU_THERMAL
+
+/**
+ * gpufreq_cooling_register - function to create gpufreq cooling device.
+ * @clip_gpus: gpumask of gpus where the frequency constraints will happen
+ */
+ /**
+ * struct gpufreq_cooling_device - data for cooling device with gpufreq
+ * @id: unique integer value corresponding to each gpufreq_cooling_device
+ *	registered.
+ * @cool_dev: thermal_cooling_device pointer to keep track of the
+ *	registered cooling device.
+ * @gpufreq_state: integer value representing the current state of gpufreq
+ *	cooling	devices.
+ * @gpufreq_val: integer value representing the absolute value of the clipped
+ *	frequency.
+ * @allowed_gpus: all the gpus involved for this gpufreq_cooling_device.
+ *
+ * This structure is required for keeping information of each
+ * gpufreq_cooling_device registered. In order to prevent corruption of this a
+ * mutex lock cooling_gpufreq_lock is used.
+ */
+struct gpufreq_cooling_device {
+	int id;
+	struct thermal_cooling_device *cool_dev;
+	unsigned int gpufreq_state;
+	unsigned int gpufreq_val;
+	int (*get_gpu_freq_level)( int freq);
+	unsigned int (*get_gpu_max_level)(void);
+	unsigned int (*get_gpu_current_max_level)(void);
+	void (*set_gpu_freq_idx)(unsigned int idx);
+};
+int gpufreq_cooling_register(struct gpufreq_cooling_device *gpufreq_dev);
+struct gpufreq_cooling_device * gpufreq_cooling_alloc(void);
+
+/**
+ * gpufreq_cooling_unregister - function to remove gpufreq cooling device.
+ * @cdev: thermal cooling device pointer.
+ */
+void gpufreq_cooling_unregister(struct thermal_cooling_device *cdev);
+
+unsigned long gpufreq_cooling_get_level(unsigned int gpu, unsigned int freq);
+#else /* !CONFIG_GPU_THERMAL */
+struct gpufreq_cooling_device * gpufreq_cooling_alloc(){
+	return NULL;
+}
+
+int gpufreq_cooling_register(struct gpufreq_cooling_device *gpufreq_dev)
+{
+	return NULL;
+}
+static inline
+void gpufreq_cooling_unregister(struct thermal_cooling_device *cdev)
+{
+	return;
+}
+static inline
+unsigned long gpufreq_cooling_get_level(unsigned int gpu, unsigned int freq)
+{
+	return THERMAL_CSTATE_INVALID;
+}
+#endif	/* CONFIG_GPU_THERMAL */
+
+#endif /* __GPU_COOLING_H__ */
-- 
2.19.0

