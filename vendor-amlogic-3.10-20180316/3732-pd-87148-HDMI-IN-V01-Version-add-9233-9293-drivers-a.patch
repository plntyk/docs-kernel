From 9d8423892fc1bb4d83f9e44c3f0aa734ac974470 Mon Sep 17 00:00:00 2001
From: "lianghu.su" <lianghu.su@amlogic.com>
Date: Tue, 4 Mar 2014 10:30:09 +0800
Subject: [PATCH 3732/5965] pd[#87148]: HDMI IN V01 Version:add 9233/9293
 drivers, and video/audio drivers.

---
 .../dts/amlogic/meson8_k200a_2G_hdmiin.dtd    | 1550 +++++++++++
 .../dts/amlogic/meson8_k200b_2G_hdmiin.dtd    | 1551 +++++++++++
 arch/arm/configs/meson8_defconfig             |    3 +
 drivers/amlogic/Kconfig                       |    1 +
 drivers/amlogic/Makefile                      |    2 +
 drivers/amlogic/ext_hdmiin/Kconfig            |   17 +
 drivers/amlogic/ext_hdmiin/Makefile           |    6 +
 drivers/amlogic/ext_hdmiin/sii9233/Kconfig    |   10 +
 drivers/amlogic/ext_hdmiin/sii9233/Makefile   |   13 +
 .../ext_hdmiin/sii9233/__sii9233/CEC/CEC.c    |  354 +++
 .../ext_hdmiin/sii9233/__sii9233/CEC/CEC.h    |  295 ++
 .../ext_hdmiin/sii9233/__sii9233/CEC/Makefile |    5 +
 .../ext_hdmiin/sii9233/__sii9233/CEC/UCEC.c   |  722 +++++
 .../ext_hdmiin/sii9233/__sii9233/EDID.c       |  199 ++
 .../ext_hdmiin/sii9233/__sii9233/EDID.h       |   25 +
 .../ext_hdmiin/sii9233/__sii9233/HAL/Makefile |    5 +
 .../ext_hdmiin/sii9233/__sii9233/HAL/hal.h    |   58 +
 .../sii9233/__sii9233/HAL/hal_cp9223.c        |  239 ++
 .../sii9233/__sii9233/HAL/hal_cp9223.h        |  104 +
 .../sii9233/__sii9233/HAL/local_types.h       |   30 +
 .../ext_hdmiin/sii9233/__sii9233/Makefile     |   14 +
 .../ext_hdmiin/sii9233/__sii9233/amf.h        |  106 +
 .../ext_hdmiin/sii9233/__sii9233/config.h     |  197 ++
 .../ext_hdmiin/sii9233/__sii9233/infofrm.c    |  926 +++++++
 .../ext_hdmiin/sii9233/__sii9233/infofrm.h    |   79 +
 .../ext_hdmiin/sii9233/__sii9233/interrupt.c  |  692 +++++
 .../ext_hdmiin/sii9233/__sii9233/main.c       |  354 +++
 .../ext_hdmiin/sii9233/__sii9233/regio.c      |  177 ++
 .../ext_hdmiin/sii9233/__sii9233/registers.h  |  649 +++++
 .../ext_hdmiin/sii9233/__sii9233/spec_types.h |   99 +
 .../ext_hdmiin/sii9233/__sii9233/stdio.h      |    1 +
 .../ext_hdmiin/sii9233/__sii9233/string.h     |    1 +
 .../ext_hdmiin/sii9233/platform_interface.c   |  149 +
 .../ext_hdmiin/sii9233/platform_interface.h   |   16 +
 .../amlogic/ext_hdmiin/sii9233/sii9233_drv.c  |  858 ++++++
 .../amlogic/ext_hdmiin/sii9233/sii9233_drv.h  |   63 +
 .../ext_hdmiin/sii9233/sii9233_interface.c    |  265 ++
 .../ext_hdmiin/sii9233/sii9233_interface.h    |   51 +
 .../ext_hdmiin/sii9233/vdin_interface.c       |  458 ++++
 .../ext_hdmiin/sii9233/vdin_interface.h       |    7 +
 .../sii9293/application/si_common.h           |   81 +
 .../sii9293/application/sk_app_cbus.c         |  273 ++
 .../component/cbus/si_cbus_component.c        | 1258 +++++++++
 .../component/cbus/si_cbus_component.h        |  358 +++
 .../sii9293/component/cbus/si_cbus_enums.h    |  215 ++
 .../component/edid/si_edid_3d_internal.h      |   65 +
 .../sii9293/component/rx/si_rx_audio.c        |  535 ++++
 .../sii9293/component/rx/si_rx_audio.h        |   43 +
 .../sii9293/component/rx/si_rx_info.c         |  272 ++
 .../sii9293/component/rx/si_rx_info.h         |  120 +
 .../component/rx/si_rx_video_mode_detection.c | 1085 ++++++++
 .../component/rx/si_rx_video_mode_detection.h |   81 +
 .../component/video_tables/si_video_tables.c  |  177 ++
 .../component/video_tables/si_video_tables.h  |  139 +
 .../driver/board_drv/si_cs4384_registers.h    |   27 +
 .../sii9293/driver/board_drv/si_drv_board.c   |  162 ++
 .../sii9293/driver/board_drv/si_drv_board.h   |   72 +
 .../sii9293/driver/board_drv/si_drv_evita.c   |  171 ++
 .../sii9293/driver/board_drv/si_drv_evita.h   |   23 +
 .../sii9293/driver/cbus_drv/si_drv_cbus.c     |  854 ++++++
 .../sii9293/driver/cbus_drv/si_drv_cbus.h     |  328 +++
 .../sii9293/driver/cbus_drv/si_regs_mhl5293.h |  118 +
 .../sii9293/driver/cra_drv/si_cra.c           |  544 ++++
 .../sii9293/driver/cra_drv/si_cra.h           |   62 +
 .../sii9293/driver/cra_drv/si_cra_internal.h  |  107 +
 .../sii9293/driver/cra_drv/si_drv_cra_cfg.c   |   98 +
 .../sii9293/driver/cra_drv/si_drv_cra_cfg.h   |   86 +
 .../sii9293/driver/mhawb_drv/si_drv_hawb.c    |  162 ++
 .../sii9293/driver/mhawb_drv/si_drv_hawb.h    |   44 +
 .../sii9293/driver/mhawb_drv/si_drv_mhawb.c   | 1356 ++++++++++
 .../sii9293/driver/mhawb_drv/si_drv_mhawb.h   |  348 +++
 .../driver/mhawb_drv/si_mdt_inputdev.h        |  460 ++++
 .../sii9293/driver/rx_drv/si_drv_device.c     |  419 +++
 .../sii9293/driver/rx_drv/si_drv_device.h     |   84 +
 .../sii9293/driver/rx_drv/si_drv_rx.c         |  346 +++
 .../sii9293/driver/rx_drv/si_drv_rx.h         |   74 +
 .../sii9293/driver/rx_drv/si_drv_rx_cfg.h     |   59 +
 .../sii9293/driver/rx_drv/si_drv_rx_info.c    |   86 +
 .../sii9293/driver/rx_drv/si_drv_rx_info.h    |   47 +
 .../sii9293/driver/rx_drv/si_drv_rx_isr.c     |  576 ++++
 .../sii9293/driver/rx_drv/si_drv_rx_isr.h     |   23 +
 .../driver/rx_drv/si_sii5293_registers.h      |  704 +++++
 .../ext_hdmiin/sii9293/linux_driver/Kconfig   |   36 +
 .../ext_hdmiin/sii9293/linux_driver/Makefile  |   83 +
 .../sii9293/linux_driver/Module.symvers       |    2 +
 .../linux_driver/application/mhl_linuxdrv.h   |  181 ++
 .../application/mhl_linuxdrv_main.c           | 2403 +++++++++++++++++
 .../application/sii5293_interface.c           |  305 +++
 .../application/sii5293_interface.h           |   32 +
 .../linux_driver/application/vdin_interface.c |  461 ++++
 .../linux_driver/application/vdin_interface.h |    9 +
 .../include/osal/include/os_data.h            |   72 +
 .../include/osal/include/os_types.h           |  121 +
 .../linux_driver/include/osal/include/osal.h  |  222 ++
 .../include/osal/sii_common/sii_ids.h         |  113 +
 .../include/osal/sii_common/sii_inline.h      |   27 +
 .../sii9293/linux_driver/include/si_osdebug.h |   41 +
 .../linux_driver/include/si_platform.h        |   78 +
 .../kernel/drivers/hid/hid-input.c            |  964 +++++++
 .../kernel/drivers/hid/usbhid/hid-core.c      | 1517 +++++++++++
 .../linux_driver/platform/hal/sii_hal.h       |  658 +++++
 .../platform/hal/sii_hal_linux_gpio.c         |  430 +++
 .../platform/hal/sii_hal_linux_i2c.c          |  650 +++++
 .../platform/hal/sii_hal_linux_init.c         |  195 ++
 .../platform/hal/sii_hal_linux_isr.c          |  347 +++
 .../platform/hal/sii_hal_linux_timer.c        |   89 +
 .../linux_driver/platform/hal/sii_hal_priv.h  |  138 +
 .../linux_driver/platform/osal/si_osdebug.c   |   82 +
 .../platform/osal/sii_osal_linux_timer.c      |  345 +++
 drivers/amlogic/video_dev/Kconfig             |    3 +-
 drivers/amlogic/video_dev/amlvideo2.c         | 1781 ++++++++++--
 sound/soc/aml/m8/aml_audio_hw.c               |   28 +
 112 files changed, 33728 insertions(+), 178 deletions(-)
 create mode 100755 arch/arm/boot/dts/amlogic/meson8_k200a_2G_hdmiin.dtd
 create mode 100755 arch/arm/boot/dts/amlogic/meson8_k200b_2G_hdmiin.dtd
 create mode 100755 drivers/amlogic/ext_hdmiin/Kconfig
 create mode 100755 drivers/amlogic/ext_hdmiin/Makefile
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/Kconfig
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/Makefile
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/CEC.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/CEC.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/Makefile
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/UCEC.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/EDID.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/EDID.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/Makefile
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal_cp9223.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal_cp9223.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/local_types.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/Makefile
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/amf.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/config.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/infofrm.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/infofrm.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/interrupt.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/main.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/regio.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/registers.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/spec_types.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/stdio.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/__sii9233/string.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/platform_interface.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/platform_interface.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/sii9233_interface.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/sii9233_interface.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/vdin_interface.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9233/vdin_interface.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/application/si_common.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/application/sk_app_cbus.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_component.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_component.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_enums.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/edid/si_edid_3d_internal.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_audio.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_audio.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_info.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_info.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_video_mode_detection.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_video_mode_detection.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/video_tables/si_video_tables.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/component/video_tables/si_video_tables.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_cs4384_registers.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_board.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_board.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_evita.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_evita.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_drv_cbus.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_drv_cbus.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_regs_mhl5293.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra_internal.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_drv_cra_cfg.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_drv_cra_cfg.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_hawb.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_hawb.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_mhawb.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_mhawb.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_mdt_inputdev.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_device.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_device.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_cfg.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_info.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_info.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_isr.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_isr.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_sii5293_registers.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Kconfig
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Makefile
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Module.symvers
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/mhl_linuxdrv.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/mhl_linuxdrv_main.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/sii5293_interface.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/sii5293_interface.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/vdin_interface.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/vdin_interface.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/os_data.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/os_types.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/osal.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/sii_common/sii_ids.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/sii_common/sii_inline.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/si_osdebug.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/si_platform.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/kernel/drivers/hid/hid-input.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/kernel/drivers/hid/usbhid/hid-core.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_gpio.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_i2c.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_init.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_isr.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_timer.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_priv.h
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/osal/si_osdebug.c
 create mode 100755 drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/osal/sii_osal_linux_timer.c

diff --git a/arch/arm/boot/dts/amlogic/meson8_k200a_2G_hdmiin.dtd b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_hdmiin.dtd
new file mode 100755
index 000000000000..1da1e2c15392
--- /dev/null
+++ b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_hdmiin.dtd
@@ -0,0 +1,1550 @@
+/dts-v1/;
+/// ***************************************************************************************\n
+//$$ PROJECT="meson8"
+//$$ REMOVE 1
+void root_func(){
+//$$ ADD /{
+	compatible = "AMLOGIC,8726_M8";
+	model = "AMLOGIC";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	
+/// ***************************************************************************************
+///	-	CPU
+//$$ MODULE="CPU"
+    cpus {
+        #address-cells = <1>;
+        #size-cells = <0>;
+//$$ DEVICE="cpu0"
+        cpu@0 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x200>;
+        };
+//$$ DEVICE="cpu1"
+        cpu@1 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x1>;
+        };
+//$$ DEVICE="cpu2"
+        cpu@2 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x2>;
+        };
+//$$ DEVICE="cpu3"
+        cpu@3 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x3>;
+        };
+    };
+
+/// ***************************************************************************************
+///	-	Cache
+//$$ MODULE="Cache"
+//$$ DEVICE="cache"
+    cache-controller {
+          compatible = "arm,meson-pl310-cache";
+          reg = <0xc4200000 0x1000>;
+          arm,data-latency = <3 3 3>;
+          arm,tag-latency = <2 2 2>;
+          cache-unified;
+          cache-level = <2>;
+          aux-instruction_prefetch;
+          aux-data_prefetch;
+          aux-ns_lockdown;
+          aux-force_no_write_alloc;
+          aux-cache_replace_policy_round_robin;
+          aux-early_write_response;
+          aux-full_line_of_zero;
+          aux-ns_int_ctrl;
+          aux-share_override;
+          prefetch-double_line_fill;
+          prefetch-prefetch_drop;
+          prefetch-prefetch_offset = <7>;
+    };
+
+/// ***************************************************************************************
+///	-	Memory
+//$$ MODULE="Memory"
+//$$ DEVICE="memory"
+//$$ L2 PROP_U32 = "aml_reserved_start"
+//$$ L2 PROP_U32 = "aml_reserved_end"
+//$$ L2 PROP_U32 6 = "linux,usable-memory"
+	memory{
+		device_type = "memory";
+		aml_reserved_start = <0x06000000>; /**reserved memory start */
+		aml_reserved_end = <0x05000000>;/**reserved memory end */
+		phys_offset = <0x00000000>;
+		linux,total-memory = <0x80000000>;
+	};
+/// ***************************************************************************************
+///	-	GIC
+//$$ MODULE="GIC"
+//$$ DEVICE="gic"	
+	gic:interrupt-controller{
+        compatible = "arm,cortex-a9-gic";
+        reg = <0xc4301000 0x1000
+               0xc4300100 0x0100>;
+        interrupt-controller;
+        #interrupt-cells = <3>;
+        #address-cells = <0>;
+    };
+    
+/// ***************************************************************************************
+///	-	VPU
+//$$ MODULE="VPU"
+//$$ DEVICE="vpu"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "clk_level"
+    vpu{
+		compatible = "amlogic,vpu";
+		dev_name = "vpu";	
+		status = "ok";
+		clk_level = <7>;
+		/**    	0: 106.25M		1: 127.5M		2: 159.375M
+				3: 182.15M		4: 212.5M		5: 255M
+		    	6: 318.75M		7: 364.3M					 */
+	};
+	
+/// **************************************************************************************	
+/// -   DISP&MM-FB
+//$$ MODULE = "DISP&MM-FB"	
+//$$ DEVICE = "mesonfb"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+//$$ L2 PROP_U32 = "vmode"
+//$$ L2 PROP_U32 5 = "display_size_default"
+	mesonfb{
+		compatible = "amlogic,mesonfb";
+		dev_name = "mesonfb";
+		status = "okay";
+	   	reserve-memory = <0x01800000  0x00100000>;
+	   	reserve-iomap = "true";
+                vmode = <3>; /**0:VMODE_720P 1:VMODE_LCD  2:VMODE_LVDS_1080P 3:VMODE_1080P*/
+		scale_mode = <1>; /*0:default 1:new*/
+ 		display_size_default = <1920 1080 1920 3240 32>;
+	};
+	
+//$$ DEVICE="deinterlace"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+    	deinterlace{
+		compatible = "amlogic,deinterlace";
+		dev_name = "deinterlace";
+		status = "ok";
+		reserve-memory = <0x02300000>; 	 
+	};
+
+/// ***************************************************************************************
+///	-	DISP&MM-A/V stream
+//$$ MODULE = "DISP&MM-A/V stream"
+//$$ DEVICE="mesonstream"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+	mesonstream{
+		compatible = "amlogic,mesonstream";
+		dev_name = "mesonstream.0";
+		status = "okay";
+		reserve-memory = <0x02000000>;
+		reserve-iomap = "true";
+	};
+
+/// ***************************************************************************************
+///     -       DISP&MM-A/V stream
+//$$ MODULE = "DISP&MM-A/V video dec"
+//$$ DEVICE="vdec"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+        vdec{
+                compatible = "amlogic,vdec";
+                dev_name = "vdec.0";
+                status = "okay";
+                reserve-memory = <0x10000000>;
+                reserve-iomap = "true";
+        };
+        
+/// ***************************************************************************************
+///	-	DISP&MM-PostProcess
+//$$ MODULE="DISP&MM-PostProcess"
+//$$ DEVICE="ppmgr"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+    ppmgr{
+		compatible = "amlogic,ppmgr";
+		dev_name = "ppmgr";
+		status = "okay";
+		reserve-memory = <0x03000000>;
+	};
+
+/// ***************************************************************************************
+///	-	DISP&MM-AVC Video Encoder
+//$$ MODULE = "DISP&MM-AVC Video Encoder"
+//$$ DEVICE="amvenc_avc"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+    amvenc_avc{
+		compatible = "amlogic,amvenc_avc";
+		dev_name = "amvenc_avc.0";
+		status = "okay";
+		reserve-memory = <0x00f00000>;
+		reserve-iomap = "true";
+	};
+	
+/// ***************************************************************************************
+///	-	DISP&MM-BT656
+//$$ MODULE = "DISP&MM-BT656"
+//$$ DEVICE="amvdec_656in"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+//    amvdec_656in{
+//		compatible = "amlogic,amvdec_656in";
+//		dev_name = "amvdec_656in";
+//		status = "ok";
+//		reg = <0x1e400000 0x00100000>;
+//	};
+//	
+/// ***************************************************************************************
+///	-	DISP&MM-VDIN
+//$$ MODULE = "DISP&MM-VDIN"	
+//$$ DEVICE="vdin1"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+//$$ L2 PROP_U32 = "irq"
+//$$ L2 PROP_U32 = "vdin_id"
+    vdin1{
+        compatible = "amlogic,vdin";
+        dev_name = "vdin1";
+        status = "ok";
+        reserve-memory = <0x01000000>;
+	miracast_size = <1920 1080>;//1920x1080x2x4=17M
+	reserve-iomap = "true";
+        irq = <117>;
+        vdin_id = <1>;
+	};
+
+/// ***************************************************************************************
+/// -   RGB-VDIN
+//$$ MODULE = "RGB-VDIN"    
+//$$ DEVICE="vdin0"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reserve-memory"
+//$$ L2 PROP_U32 = "irq"
+//$$ L2 PROP_U32 = "vdin_id"
+    vdin0{
+        compatible = "amlogic,vdin";
+        dev_name = "vdin0";
+        status = "ok";
+        reserve-memory = <0x01000000>;
+        rgbin_size = <1920 1080>;//1920x1080x2x4=17M
+        reserve-iomap = "true";
+        irq = <115>;
+        vdin_id = <0>;
+    };
+
+/// ***************************************************************************************
+///	-	DISP&MM-AMLVIDEO2
+//$$ MODULE = "DISP&MM-AMLVIDEO2"
+//$$ DEVICE="amlvideo2"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+    amlvideo2{
+		compatible = "amlogic,amlvideo2";
+		dev_name = "amlvideo2.0";
+		status = "okay";
+		reserve-memory = <0x01000000>;
+		reserve-iomap = "true";
+	};
+
+/// ***************************************************************************************
+///	-	ION
+//$$ MODULE="ION"
+//$$ DEVICE="ion_dev"
+//$$ L2 PROP_STR = "status"
+    ion_dev{
+        compatible = "amlogic,ion_dev";
+        dev_name = "ion_dev";
+        status = "ok";
+        share-memory-name = "ppmgr0";
+        share-memory-offset = <0>;
+        share-memory-size = <0x03000000>;
+    };
+/// ***************************************************************************************
+///	-	DISP&MM-Vout
+//$$ MODULE = "DISP&MM-Vout"
+//$$ DEVICE = "mesonvout"
+//$$ L2 PROP_STR = "status"
+	mesonvout{
+		compatible = "amlogic,mesonvout";
+		dev_name = "mesonvout";
+		status = "okay";
+	};
+
+/// ***************************************************************************************
+///	-	RTC
+//$$ MODULE="RTC"
+//$$ DEVICE="Rtc"
+//$$ L2 PROP_STR = "status"
+    rtc{
+		compatible = "amlogic,aml_rtc";
+		status = "okay";
+	};
+
+/// ***************************************************************************************
+///	-	UART
+//$$ MODULE="UART"
+//$$ DEVICE="uart_ao"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L3 PROP_CHOICE "uart_ao_pin_match" = "pinctrl-0"
+	uart_ao{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_ao";
+		status = "okay";
+		dev_name = "uart_ao";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ao_uart_pins>;
+	};
+	
+//$$ DEVICE="uart_0"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L3 PROP_CHOICE "uart_0_pin_match" = "pinctrl-0"
+	uart_0{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_a";
+		status = "okay";
+		dev_name = "uart_0";
+    	pinctrl-names = "default";
+    	pinctrl-0 = <&a_uart_pins>;
+	};
+	
+//$$ DEVICE="uart_1"
+//$$ L2 PROP_STR = "status"
+	uart_1{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_b";
+		status = "disabled";
+		dev_name = "uart_1";
+	};
+	
+//$$ DEVICE="uart_2"
+//$$ L2 PROP_STR = "status"
+	uart_2{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_c";
+		status = "disabled";
+		dev_name = "uart_2";
+	};
+	
+//$$ DEVICE="uart_3"
+//$$ L2 PROP_STR = "status"	
+	uart_3{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_d";
+		status = "ok";
+		dev_name = "uart_3";
+	};
+
+/// ***************************************************************************************
+///	-	Bluetooth
+//$$ MODULE="Bluetooth"
+//$$ DEVICE="bt-dev"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "gpio_reset"
+    bt-dev{
+        compatible = "amlogic,bt-dev";
+        dev_name = "bt-dev";
+        status = "ok";
+        gpio_reset = "GPIOX_20";
+    };
+
+/// ***************************************************************************************
+///	-	WiFi
+//$$ MODULE="WiFi"
+//$$ DEVICE="aml_broadcm_wifi"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "interrupt_pin"
+//$$ L2 PROP_U32 = "irq_num"
+//$$ L2 PROP_STR = "irq_trigger_type"
+//$$ L2 PROP_STR = "power_on_pin"
+//$$ L2 PROP_STR = "clock_32k_pin"
+    wifi{
+		compatible = "amlogic,aml_broadcm_wifi";
+		dev_name = "aml_broadcm_wifi";
+		status = "okay";
+		interrupt_pin = "GPIOX_21";
+		irq_num = <4>;
+		irq_trigger_type = "GPIO_IRQ_HIGH";
+		power_on_pin = "GPIOAO_6";
+		power_on_pin2 = "GPIOX_11";
+		clock_32k_pin = "GPIOX_10";
+	};
+	
+//$$ DEVICE="wifi_power"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "power_gpio"
+	wifi_power{
+            compatible = "amlogic,wifi_power";
+            dev_name = "wifi_power";
+            status = "okay";
+            power_gpio = "GPIOAO_6";
+            power_gpio2 = "GPIOX_11";
+	}; 
+
+/// ***************************************************************************************
+///	-	MMC
+//$$ MODULE="MMC"
+//$$ DEVICE="aml_sdio"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L2 PROP_STR 7 = "pinctrl-names"
+//$$ L2 PROP_CHOICE "sdio_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "sdio_pin_1_match" = "pinctrl-1"
+//$$ L2 PROP_CHOICE "sdio_pin_2_match" = "pinctrl-2"
+//$$ L2 PROP_CHOICE "sdio_pin_3_match" = "pinctrl-3"
+//$$ L2 PROP_CHOICE "sdio_pin_4_match" = "pinctrl-4"
+//$$ L2 PROP_CHOICE "sdio_pin_5_match" = "pinctrl-5"
+//$$ L2 PROP_CHOICE "sdio_pin_6_match" = "pinctrl-6"
+sdio{
+        compatible = "amlogic,aml_sdio";
+        dev_name = "aml_sdio.0";
+        status = "okay";
+        reg = <0xc1108c20 0x20>;
+        pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "emmc_clk_cmd_pins", "emmc_all_pins", "sdio_clk_cmd_pins", "sdio_all_pins","sd_1bit_pins"; // "jtag_pin", "uartao_default";
+        pinctrl-0 = <&sd_clk_cmd_pins>;
+        pinctrl-1 = <&sd_all_pins>;
+        pinctrl-2 = <&emmc_clk_cmd_pins>;
+        pinctrl-3 = <&emmc_all_pins>;
+        pinctrl-4 = <&sdio_clk_cmd_pins>;
+        pinctrl-5 = <&sdio_all_pins>;
+        pinctrl-6 = <&sd_1bit_pins>;
+
+//$$ DEVICE="sd"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 3 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"
+//$$ L2 PROP_STR = "jtag_pin"
+//$$ L2 PROP_STR = "gpio_cd"
+//$$ L2 PROP_STR = "gpio_ro"
+//$$ L2 PROP_U32 = "irq_in"
+//$$ L2 PROP_U32 = "irq_out"
+//$$ L2 PROP_U32 = "card_type"
+        sd{
+            status = "okay";
+            port = <1>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sd";
+            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
+            f_min = <300000>;
+            f_max = <50000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            gpio_dat3 = "CARD_4";
+            jtag_pin = "CARD_0";
+            gpio_cd = "CARD_6";
+            gpio_ro = "GPIOZ_0";
+            irq_in = <3>;
+            irq_out = <5>;
+            card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+
+//$$ DEVICE="emmc"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 4 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "f_max_w"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"
+//$$ L2 PROP_U32 = "card_type"
+        emmc{
+            status = "ok";
+            port = <2>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "emmc";
+            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            gpio_dat3 = "BOOT_3";
+            card_type = <1>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+
+//$$ DEVICE="sdio"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 4 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_U32 = "card_type"    
+        sdio{
+            status = "ok";
+            port = <0>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sdio";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE";
+            f_min = <300000>;
+            f_max = <50000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            card_type = <3>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+    };
+
+/// ***************************************************************************************
+///	-	I2C
+//$$ MODULE="I2C"
+//$$ DEVICE="I2C_AO"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_AO_pin_match" = "pinctrl-0"	
+	i2c@c8100500{ /*I2C-AO*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-AO";
+		status = "ok";
+		reg = <0xc8100500 0x1d>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		device_id = <0>;
+		pinctrl-names="default";
+		pinctrl-0=<&ao_i2c_master>;
+	};
+
+//$$ DEVICE = "I2C_A"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+    i2c@c1108500{ /*I2C-A*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-A";
+		status = "ok";
+		reg = <0xc1108500 0x20>;
+		device_id = <1>;
+		pinctrl-names="default";
+//		pinctrl-0=<&a_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+	
+//$$ DEVICE="I2C_B"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_B_pin_match" = "pinctrl-0"	
+	i2c@c11087c0{ /*I2C-B*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-B";
+		status = "ok";
+		reg = <0xc11087c0 0x20>;
+		device_id = <2>;
+		pinctrl-names="default";
+		pinctrl-0=<&b_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+ 	};
+
+//$$ DEVICE="I2C_C"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2="reg"
+//$$ L3 PROP_STR = "pinctrl-names"	
+    i2c@c11087e0{ /*I2C-C*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-C";
+		status = "ok";
+		reg = <0xc11087e0 0x20>;
+		device_id = <3>;
+		pinctrl-names="default";
+//		pinctrl-0=<&c_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+//$$ DEVICE="I2C_D"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_D_pin_match" = "pinctrl-0"	
+	i2c@c1108d20{ /*I2C-D*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-D";
+		status = "ok";
+		reg = <0xc1108d20 0x20>;
+		device_id = <4>;
+		pinctrl-names="default";
+		pinctrl-0=<&d_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+/// ***************************************************************************************
+///	-	Power
+//$$ MODULE="Power"
+//$$ DEVICE="dvfs"
+//$$ L2 PROP_STR = "status"
+    dvfs {
+        compatible = "amlogic, amlogic-dvfs";                   /** fixed for driver, don't change       */
+        #address-cells = <1>;
+        #size-cells = <0>;
+        status = "ok";
+
+//$$ L2 PROP_U32 = "dvfs_id"
+//$$ L2 PROP_U32 = "table_count"
+//$$ L2 PROP_U32 16*3 = "dvfs_table"
+        vcck_dvfs {
+            dvfs_id     = <1>;                                  /** must be value of (1 << n)            */
+            table_count = <14>;                                 /** must be correct count for dvfs_table */
+            dvfs_table  = <
+            /* NOTE: frequent in this table must be ascending order */
+            /* frequent(Khz)    min_uV      max_uV                  */
+                  96000         825000      825000
+                 192000         825000      825000
+                 312000         825000      825000
+                 408000         825000      825000
+                 504000         825000      825000
+                 600000         850000      850000
+                 720000         850000      850000
+                 816000         875000      875000
+                1008000         925000      925000
+                1200000         975000      975000
+                1416000        1025000     1025000
+                1608000        1100000     1100000
+                1800000        1125000     1125000
+                1992000        1150000     1150000
+            >;
+        };
+    };
+
+//$$ DEVICE="arm_pmu"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 4*3 = "interrupts"
+    arm_pmu {
+        compatible = "arm,cortex-a9-pmu";
+        status = "ok";
+        interrupts = <0     137     0x04
+                      0     138     0x04
+                      0     153     0x04
+                      0     154     0x04>;
+    };
+
+    pmu {
+        compatible = "amlogic, aml_pmu_prober";                 /* fixed for pmu driver, don't change   */
+        #address-cells = <1>;
+        #size-cells = <0>;
+//$$ DEVICE = "Pmu_axp202"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_STR = "status"
+        axp202 { /* PMU for AXP */
+            compatible = "axp_mfd";                             /* for driver probe, must have          */
+            sub_type = "axp20_mfd";                             /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x34>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            ddr_voltage   = <1500000>;                          /** default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /** default voltage for AO, optional     */
+            status = "disable";                                 /** status of pmu, only one should be OK */
+        };
+//$$ DEVICE = "Pmu_aml1212"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_STR = "status"
+        aml1212{                                                /* PMU for AML1212, see comment above   */
+            compatible = "aml_pmu";                             /* for driver probe, must have          */
+            sub_type = "aml1212";                               /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x35>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            ddr_voltage   = <1500000>;                          /** default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /** default voltage for AO, optional     */
+            status = "disable";                                 /** status of pmu, only one should be OK */
+        };
+//$$ DEVICE = "Pmu_rn5t618"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_STR = "status"
+        rn5t618{                                                /* PMU for RN5T618, see comment above   */
+            compatible = "ricoh_pmu";                           /* for driver probe, must have          */
+            sub_type = "rn5t618";                               /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x32>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            ddr_voltage   = <1500000>;                          /** default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /** default voltage for AO, optional     */
+            status = "okay";                                    /** status of pmu, only one should be OK */
+        };
+    };
+
+/// ***************************************************************************************
+///	-	USB Controller
+//$$ MODULE="USB Controller"
+    usb_con {
+		lm-compatible = "logicmodule-bus";
+
+//$$ DEVICE="usb_b"
+//$$ L2 PROP_U32 = "lm-periph-id" 
+//$$ L2 PROP_STR = "clock-src"
+//$$ L2 PROP_U32 = "port-id"
+//$$ L2 PROP_U32 = "port-type"
+//$$ L2 PROP_U32 = "port-speed"
+//$$ L2 PROP_U32 = "port-config"
+//$$ L2 PROP_U32 = "port-dma"
+//$$ L2 PROP_U32 = "port-id-mode"
+//$$ L2 PROP_STR = "status"
+        	usb_b{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <1>; /** lm name */
+			clock-src = "usb1"; /** clock src */
+			port-id = <1>;   /** ref to mach/usb.h */
+			port-type = <1>;	/** 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /** 0: default, 1: high, 2: full */
+			port-config = <0>; /** 0: default */
+			port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <1>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+			status = "okay";
+		};
+		
+//$$ DEVICE="usb_a"
+//$$ L2 PROP_U32 = "lm-periph-id"
+//$$ L2 PROP_STR = "clock-src"
+//$$ L2 PROP_U32 = "port-id"
+//$$ L2 PROP_U32 = "port-type"
+//$$ L2 PROP_U32 = "port-speed"
+//$$ L2 PROP_U32 = "port-config"
+//$$ L2 PROP_U32 = "port-dma"
+//$$ L2 PROP_U32 = "port-id-mode"
+//$$ L2 PROP_STR = "gpio-vbus-power"
+//$$ L2 PROP_U32 = "gpio-work-mask"
+//$$ L2 PROP_STR = "status"
+		usb_a{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <0>; /** lm name */
+			clock-src = "usb0"; /** clock src */
+			port-id = <0>;  /** ref to mach/usb.h */
+			port-type = <0>;	/** 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /** 0: default, high, 1: full */
+			port-config = <0>; /** 0: default */
+			port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+			gpio-vbus-power = "GPIOZ_1";
+			gpio-work-mask	= <1>; /**0: work on pulldown,1:work on pullup*/
+			status = "okay";
+		};
+	};
+
+
+
+
+/// ***************************************************************************************
+///	-	Spi
+//$$ MODULE="Spi"
+//$$ DEVICE="spi"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "Spi_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_U32 = "nr-parts"
+//$$ L2 PROP_CHOICE "Spi_nr-part-0_match" = "nr-part-0"
+//$$ L2 PROP_CHOICE "Spi_nr-part-1_match" = "nr-part-1"
+    spi@cc000000{
+		compatible = "amlogic,apollo_spi_nor";
+		status = "ok";
+		reg = <0xcc000000 0x04000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&aml_spi_nor_pins>;
+
+		nr-parts = <2>;
+		nr-part-0 = <&bootloader>;
+		nr-part-1 = <&ubootenv>;
+
+//$$ MATCH "Spi_nr-part-0_match" = <&bootloader>
+//$$ L2 PROP_STR = "name"
+//$$ L2 PROP_U32 = "offset"
+//$$ L2 PROP_U32 = "size"
+		bootloader:bootloader{
+			name = "bootloader";
+			offset = <0>;
+			size = <0x60000>;
+		};
+
+//$$ MATCH "Spi_nr-part-1_match" = <&ubootenv>
+//$$ L2 PROP_STR = "name"
+//$$ L2 PROP_U32 = "offset"
+//$$ L2 PROP_U32 = "size"
+		ubootenv:ubootenv{
+			name = "ubootenv";
+		      offset = <0x100000>;
+		      size = <0x10000>;
+		};
+	};
+
+// ***************************************************************************************
+///	-	Nand
+//$$ MODULE="Nand"
+//$$ DEVICE="aml_nand"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L2 PROP_STR 2 = "pinctrl-names"
+//$$ L2 PROP_CHOICE 3 "Nand_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE 3 "Nand_pin_1_match" = "pinctrl-1"
+//$$ L3 PROP_STR ="plat-names"
+//$$ L2 PROP_U32 = "plat-num"
+//$$ L2 PROP_CHOICE "plat-part-0_match" = "plat-part-0"
+	nand{
+		compatible = "amlogic,aml_nand";
+		dev_name = "nand";
+		status = "ok";
+		reg = <0xd0048600 0x24>;
+		pinctrl-names = "nand_rb_mod","nand_norb_mod";
+		pinctrl-0 = <&nand_input_state &conf_nand_state &nand_base>;
+		pinctrl-1 = <&nand_input_state &conf_nand_state &nand_base>;
+		device_id = <0>;
+		plat-names = "nandnormal";
+		plat-num = <1>;
+		plat-part-0 = <&normal>;
+
+//$$ MATCH "plat-part-0_match" = <&normal>
+//$$ L2 PROP_STR 4 = "enable_pad"
+//$$ L2 PROP_STR = "busy_pad"
+		normal: normal{
+			enable_pad ="ce0","ce1","ce2","ce3";
+			busy_pad = "rb0";
+		};
+	};
+
+/// ***************************************************************************************
+///	-	Efuse
+//$$ MODULE="Efuse"
+//$$ DEVICE="efuse"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "plat-pos"
+//$$ L2 PROP_U32 = "plat-count"
+//$$ L2 PROP_U32 = "usid-min"
+//$$ L2 PROP_U32 = "usid-max"
+    efuse{
+		compatible = "amlogic,efuse";
+		dev_name = "efuse";
+		status = "okay";
+		plat-pos = <0 454>;
+		plat-count = <58>;
+		usid-min = <8>; /*reserved*/
+		usid-max = <31>; /*reserved*/
+	};
+	
+/// ***************************************************************************************
+///	-	Thermal
+//$$ MODULE="Thermal"
+//$$ DEVICE="thermal"
+//$$ L2 PROP_U32 3*3 = "trip_point"
+//$$ L2 PROP_U32 = "#thermal-cells"
+//$$ L2 PROP_U32 = "cpu_cali_a"
+//$$ L2 PROP_U32 = "idle_interval"
+	thermal{
+		compatible = "amlogic-thermal";
+		#thermal-cells=<3>;
+		dev_name = "aml_thermal";
+		trip_point=<50 1200000 1200000
+			    70  800000 800000
+			    110 0xffffffff 0xffffffff>;
+		cpu_cali_a=<0>;
+		idle_interval=<1000>;
+
+	};
+	
+/// ***************************************************************************************
+/// -   Audio
+//$$ MODULE="Audio"
+//$$ DEVICE="audio_i2s"
+//$$ L2 PROP_STR = "status"
+    audio_platform{
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_i2s_dai"
+//$$ L2 PROP_STR = "status"
+    audio_dai{
+        compatible = "amlogic,aml-i2s-dai";
+        dev_name = "aml-i2s-dai.0";
+        status = "okay";
+    };
+    audio_spdif_dai{
+        compatible = "amlogic,aml-spdif-dai";
+        dev_name = "aml-spdif-dai.0";
+        status = "okay";
+    };
+
+    audio_spdif_codec{
+        compatible = "amlogic,aml-spdif-codec";
+        dev_name = "spdif-dit.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_m8_audio"
+//$$ L2 PROP_STR = "status"
+    audio_m8_audio{
+        compatible = "amlogic,m8_audio_codec";
+        dev_name = "aml_m8_codec.0";
+        status = "okay";
+    };
+
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
+//$$ DEVICE="aml_m8_sound_card"
+//$$ L2 PROP_STR = "aml,sound_card"
+//$$ L2 PROP_STR = "aml,codec_dai"
+//$$ L2 PROP_STR 6*2 = "aml,audio-routing"
+//$$ L2 PROP_STR = "mute_gpio"
+//$$ L2 PROP_U32 5 = "hp_paraments"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "Audio_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_STR = "status"
+    aml_m8_sound_card{
+        compatible = "sound_card, aml_snd_m8";
+        aml,sound_card = "AML-M8AUDIO";
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
+            "Ext Spk","LINEOUTL",
+            "Ext Spk","LINEOUTR",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICBIAS","MAIN MIC",
+            "LINPUT1","MICBIAS";
+
+        mute_gpio = "GPIO_BSD_EN";
+        hp_paraments = <800 300 0 5 1>;
+        pinctrl-names = "aml_snd_m8";
+        pinctrl-0 = <&audio_pins>;
+        status = "okay";
+        
+    };
+
+/// ***************************************************************************************
+///	-	Input
+//$$ MODULE="Input"
+//$$ DEVICE="gpio_keypad"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "scan_period"
+//$$ L2 PROP_U32 = "key_num"
+//$$ L2 PROP_STR = "key_name"
+//$$ L2 PROP_U32 = "key_code"
+//$$ L2 PROP_STR = "key_pin"
+//$$ L2 PROP_U32 = "irq_keyup"
+//$$ L2 PROP_U32 = "irq_keydown"
+    gpio_keypad{
+		compatible = "amlogic,gpio_keypad";
+		status = "okay";
+		scan_period = <20>;
+		key_num = <1>;
+        key_name = "power";
+		key_code = <116>;
+		key_pin = "GPIOAO_3";
+        irq_keyup = <6>;
+        irq_keydown = <7>;
+	};
+//$$ DEVICE="saradc"
+//$$ L2 PROP_STR = "status"
+	saradc{
+		compatible = "amlogic,saradc";
+		status = "okay";
+	};
+	
+//$$ DEVICE="meson-remote"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "ao_baseaddr"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "remote_pin_0_match" = "pinctrl-0"
+    meson-remote{
+		compatible = "amlogic,aml_remote";
+		dev_name = "meson-remote";
+		status = "ok";
+		ao_baseaddr = <0xf3100480>;
+		pinctrl-names="default";
+		pinctrl-0=<&remote_pins>;
+	};
+	
+/// ***************************************************************************************
+///	-	Securitykey
+//$$ MODULE="Securitykey"
+//$$ DEVICE="securitykey"
+//$$ L2 PROP_STR = "status"
+    securitykey{
+		compatible = "amlogic,aml_keys";
+		status = "ok";
+	};
+
+/// ***************************************************************************************
+///	-	Unifykey
+//$$ MODULE="Unifykey"
+//$$ DEVICE="securitykey"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 ="unifykey-num"
+//$$ L2 PROP_CHOICE "Unifykey_0_match" = "unifykey-index-0"
+//$$ L2 PROP_CHOICE "Unifykey_1_match" = "unifykey-index-1"
+//$$ L2 PROP_CHOICE "Unifykey_2_match" = "unifykey-index-2"
+    	unifykey{
+		compatible = "amlogic,unifykey";
+		status = "ok";
+
+		/*efuse-version = <0>;*/ /*m6 efuse version 2,m3 efuse version 1, not config efuse version in default*/
+		unifykey-num = <3>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+
+
+//$$ MATCH "Unifykey_0_match" = <&keysn_0>
+//$$ L2 PROP_STR = "key-name"
+//$$ L2 PROP_STR = "key-device"
+//$$ L2 PROP_STR = "key-dataformat"
+//$$ L2 PROP_STR 3 = "key-permit"
+		keysn_0: key_0{
+			key-name = "usid";
+			key-device = "nandkey";
+			key-dataformat = "allascii";
+			key-permit = "read","write","del";
+		};
+		
+//$$ MATCH "Unifykey_1_match" = <&keysn_1>
+//$$ L2 PROP_STR = "key-name"
+//$$ L2 PROP_STR = "key-device"
+//$$ L2 PROP_STR = "key-dataformat"
+//$$ L2 PROP_STR 3 = "key-permit"
+		keysn_1:key_1{
+			key-name = "mac";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+		
+//$$ MATCH "Unifykey_2_match" = <&keysn_2>
+//$$ L2 PROP_STR = "key-name"
+//$$ L2 PROP_STR = "key-device"
+//$$ L2 PROP_STR = "key-dataformat"
+//$$ L2 PROP_STR 3 = "key-permit"
+		keysn_2:key_2{
+			key-name = "key2";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+	};
+	
+/// ***************************************************************************************
+///	-	HDMI
+//$$ MODULE="HDMI"
+//$$ DEVICE="amhdmitx"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_CHOICE "HDMI_vend-data_match" = "vend-data"
+//$$ L2 PROP_CHOICE "HDMI_pwr-ctrl_match" = "pwr-ctrl"
+    amhdmitx{
+		compatible = "amlogic,amhdmitx";
+		dev_name = "amhdmitx";
+		status = "ok";
+        vend-data = <&vend_data>;
+        pwr-ctrl = <&pwr_ctrl>;
+        
+//$$ MATCH "HDMI_vend-data_match" = <&vend_data>
+//$$ L2 PROP_STR = "vendor_name"
+//$$ L2 PROP_U32 = "vendor_id"
+//$$ L2 PROP_STR = "product_desc"
+//$$ L2 PROP_STR = "cec_osd_string"        
+        vend_data: vend_data{
+            vendor_name = "Amlogic";           /* Max Chars: 8     */
+            vendor_id = <0x000000>;                 /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+            product_desc = "M8 MBox SKTv1";        /* Max Chars: 16    */
+            cec_osd_string = "Amlogic MBox";        /* Max Chars: 14    */
+        };
+        
+//$$ MATCH "HDMI_pwr-ctrl_match" = <&pwr_ctrl>
+//$$ L2 PROP_STR = "pwr_5v_on"
+//$$ L2 PROP_STR = "pwr_5v_off"
+//$$ L2 PROP_STR = "pwr_3v3_on"
+//$$ L2 PROP_STR = "pwr_3v3_off"
+//$$ L2 PROP_STR = "pwr_hpll_vdd_on"
+//$$ L2 PROP_STR = "pwr_hpll_vdd_off"
+        pwr_ctrl: pwr_ctrl{
+            pwr_5v_on = "";
+            pwr_5v_off = "";
+            pwr_3v3_on = "";
+            pwr_3v3_off = "";
+            pwr_hpll_vdd_on = "";
+            pwr_hpll_vdd_off = "";
+        };
+	};
+
+/// ***************************************************************************************
+///    -       SII9293
+//$$ MODULE="sii9293"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_reset"
+//$$ L2 PROP_STR = "gpio_intr"
+   aml_sii9293{
+           compatible = "amlogic,sii9293";
+           i2c_bus = "i2c_bus_b";
+           gpio_reset = "GPIODV_28";
+           gpio_intr = "GPIODV_29";
+   };
+
+/// ***************************************************************************************
+///	-	SII9233
+//$$ MODULE="sii9233"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_reset"
+//$$ L2 PROP_STR = "gpio_intr"
+	aml_sii9233a{
+		compatible = "amlogic,sii9233";
+		i2c_bus = "i2c_bus_b";
+		gpio_reset = "GPIODV_28";
+		gpio_intr = "GPIODV_29";
+	};
+
+/// ***************************************************************************************
+///	-	PowerManager
+//$$ MODULE="PowerManager"
+//$$ DEVICE="amvenc_avc"
+//$$ L2 PROP_STR = "status"
+    aml_pm{
+		compatible = "amlogic,pm-m8";
+		dev_name = "aml_pm_m8";
+		status = "okay";
+	};
+
+/// ***************************************************************************************
+///	-	Cpufreq
+//$$ MODULE="Cpufreq"
+//$$ DEVICE="cpufreq-meson"
+//$$ L2 PROP_STR = "status"
+    cpufreq-meson{
+        compatible = "amlogic,cpufreq-meson";
+        status = "okay";
+    };
+
+    crypto_device{
+       compatible = "amlogic,crypto-device";
+       dev_name = "crypto_device";
+    };
+
+/// **************************************************************************************
+/// -   GPIO
+//$$ MODULE="GPIO"
+//$$ DEVICE="m8-gpio"
+	gpio:gpio{
+		compatible = "amlogic,m8-gpio";
+		dev_name = "gpio";
+		#gpio-cells=<2>;
+	};
+
+/// **************************************************************************************
+/// -   Pinmux
+//$$ MODULE="Pinmux"
+//$$ DEVICE="pinmux-m8"
+    pinmux{ 
+		compatible = "amlogic,pinmux-m8";
+		dev_name = "pinmux";
+		#pinmux-cells=<2>;    
+    
+//$$ MATCH "uart_ao_pin_match" = "&ao_uart_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+        ao_uart_pins:ao_uart{
+			amlogic,setmask=<10 0x1800>;
+			amlogic,pins="GPIOAO_0", "GPIOAO_1";
+		};
+		
+//$$ MATCH "uart_0_pin_match" = "&a_uart_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 4 = "amlogic,pins"
+		a_uart_pins:a_uart{
+			amlogic,setmask=<4 0x3c00>;
+			amlogic,pins="GPIOX_12", "GPIOX_13", "GPIOX_14", "GPIOX_15";
+		};
+		
+//$$ MATCH "Nand_pin_0_match" = "&nand_input_state"
+//$$ MATCH "Nand_pin_1_match" = "&nand_input_state"
+//$$ L2 PROP_STR 18 = "amlogic,pins"
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+		nand_input_state:nand_input{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_12","BOOT_13",
+						"BOOT_8","BOOT_9","BOOT_10","BOOT_11",
+						"BOOT_14","BOOT_15","BOOT_16","BOOT_17";
+			amlogic,enable-output=<1>;
+		};
+		
+//$$ MATCH "Nand_pin_0_match" = "&conf_nand_state"
+//$$ MATCH "Nand_pin_1_match" = "&conf_nand_state"
+//$$ L2 PROP_STR 9 = "amlogic,pins"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+		conf_nand_state: conf_nand{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_15";
+			amlogic,pullup=<0>;
+		};
+		
+//$$ MATCH "Nand_pin_0_match" = "&nand_base"
+//$$ MATCH "Nand_pin_1_match" = "&nand_base"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 17 = "amlogic,pins"
+		nand_base: nand{
+			amlogic,setmask=<2 0x7fe0000>;
+			amlogic,clrmask=<	5 0xe
+							6 0x3f000000
+							4 0x7c000000>;
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_8","BOOT_9",
+						"BOOT_10","BOOT_12","BOOT_13",
+						"BOOT_14","BOOT_15","BOOT_16","BOOT_17";
+		};
+		
+//$$ MATCH "Card_pin_0_match" = "&sdhc_b_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+		sdhc_b_pins:sdhc_b_pin{
+			amlogic,setmask=<2 0xfc00>;
+			amlogic,clrmask=<2 0xf0 8 0x600>;
+			amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+		};
+
+//$$ MATCH "Card_pin_1_match" = "&sdhc_c_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+		sdhc_c_pins:sdhc_c_pin{
+			amlogic,setmask=<6 0x3f000000>;
+			amlogic,clrmask=<4 0x6c000000 2 0x4c00000>;
+			amlogic,pins="BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+		};
+
+//$$ MATCH "Card_pin_2_match" = "&sdhc_a_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"		
+		sdhc_a_pins:sdhc_a_pin{
+			amlogic,setmask=<8 0x3f>;
+			amlogic,clrmask=<5 0x6c00 >;
+			amlogic,pins="GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+		};
+
+//$$ MATCH "sdio_pin_5_match" = "&sdio_all_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"	
+        sdio_all_pins:sdio_all_pins{
+            amlogic,setmask=<8 0x0000003f>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_4_match" = "&sdio_clk_cmd_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sdio_clk_cmd_pins:sdio_clk_cmd_pins{
+            amlogic,setmask=<8 0x00000003>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_8","GPIOX_9"; /** GPIOX_8:CLK, GPIOX_9:CMD */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+//$$ MATCH "sdio_pin_1_match" = "&sd_all_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sd_all_pins:sd_all_pins{
+            amlogic,setmask=<2 0x0000fc00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000063f        /*sdio a, UART*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_6_match" = "&sd_1bit_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sd_1bit_pins:sd_1bit_pins{
+            amlogic,setmask=<2 0x00008c00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_0_match" = "&sd_clk_cmd_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sd_clk_cmd_pins:sd_clk_cmd_pins{
+            amlogic,setmask=<2 0x00000c00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_2","CARD_3"; /** CARD_2:CLK, CARD_3:CMD */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_3_match" = "&emmc_all_pins"  
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"      
+        emmc_all_pins:emmc_all_pins{
+            amlogic,setmask=<6 0x3f000000>;         /*sdio c*/
+            amlogic,clrmask=<2 0x04c0fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000>;        /*sdhc c*/
+            amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_16","BOOT_17";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_2_match" = "&emmc_clk_cmd_pins" 
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        emmc_clk_cmd_pins:emmc_clk_cmd_pins{
+            amlogic,setmask=<6 0x03000000>;         /*bit[24-25] */
+            amlogic,clrmask=<2 0x04c0fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000>;        /*sdhc c*/
+            amlogic,pins = "BOOT_16","BOOT_17"; /** BOOT_16:CMD, BOOT_17:CLK */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+//$$ MATCH "I2C_AO_pin_match" = "&ao_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		ao_i2c_master:ao_i2c{
+			amlogic,setmask=<10 0x60>;
+			amlogic,clrmask=<10 0x1800006>;
+			amlogic,pins="GPIOAO_4","GPIOAO_5";
+		};
+		
+// MATCH "I2C_A_pin_match" = "&a_i2c_master"
+// L2 PROP_U32 2 = "amlogic,setmask"
+// L2 PROP_U32 2 = "amlogic,clrmask"
+// L2 PROP_STR 2 = "amlogic,pins"
+//		a_i2c_master:a_i2c{
+//			amlogic,setmask=<5 0xc0000000>;
+//			amlogic,clrmask=<9 0x58000 7 3000000>;
+//			amlogic,pins="GPIOZ_0","GPIOZ_1";
+
+//			amlogic,setmask=<5 0x300>;
+//			amlogic,clrmask=<6 0x900 8 11000>;
+//			amlogic,pins="GPIOZ_9","GPIOZ_10";
+
+//			amlogic,setmask=<5 0xc0>;
+//			amlogic,clrmask=<6 0xc0 8 0xc000>;
+//			amlogic,pins="GPIOZ_11","GPIOZ_12";
+//		};
+		
+//$$ MATCH "I2C_B_pin_match" = "&b_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		b_i2c_master:b_i2c{
+			amlogic,setmask=<5 0xc000000>;
+			amlogic,pins="GPIOZ_2","GPIOZ_3";
+		};
+
+// MATCH "I2C_C_pin_match" = "&c_i2c_master"
+// L2 PROP_U32 2 = "amlogic,setmask"
+// L2 PROP_U32 2 = "amlogic,clrmask"
+// L2 PROP_STR 2 = "amlogic,pins"		
+//		c_i2c_master:c_i2c{
+//			amlogic,setmask=<5 0x3000000>;
+//			amlogic,clrmask=<6 0xc000>;
+//			amlogic,pins="GPIOZ_4","GPIOZ_5";
+
+//			amlogic,setmask=<1 0xc000>;
+//			amlogic,clrmask=<1 0xc0400 3 0x6 9 0x300>;
+//			amlogic,pins="GPIOY_0","GPIOY_1";
+//		};
+
+//$$ MATCH "I2C_D_pin_match" = "&d_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		d_i2c_master:d_i2c{
+			amlogic,setmask=<4 0xc>;
+			amlogic,pins="GPIOH_7","GPIOH_8";
+		};
+
+//$$ MATCH "remote_pin_0_match" = "&remote_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR = "amlogic,pins"
+        	remote_pins:remote_pin{
+			amlogic,setmask=<10 0x1>;
+			amlogic,pins="GPIOAO_7";
+		};
+
+//$$ MATCH "Audio_pin_0_match" = "&audio_pins"
+//$$ L2 PROP_U32 4 = "amlogic,setmask"
+//$$ L2 PROP_U32 10 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"
+        audio_pins:audio_pin{
+            amlogic,setmask=<1 0x180
+                             1 0x75>;
+            amlogic,clrmask=<1 0x30000
+                             1 0x0a
+                             3 0x40389
+                             4 0x3c00000
+                             9 0xd>;
+            amlogic,pins = "GPIOY_2","GPIOY_3","GPIOY_4","GPIOY_5","GPIOY_6","GPIOY_7","GPIOY_8";
+        };
+
+//$$ MATCH "Spi_pin_0_match" = "&aml_spi_nor_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 4 = "amlogic,pins"
+		aml_spi_nor_pins: aml_spi_nor_pins{
+			amlogic,setmask=<5 0xf>;
+			amlogic,clrmask=<2 0x380000>;
+			amlogic,pins = "BOOT_11","BOOT_12","BOOT_13","BOOT_18";
+		};
+
+	};
+/// ***************************************************************************************
+///	-	Ethernet
+//$$ MODULE="Ethernet"
+//$$ DEVICE="meson-eth"
+//$$ L2 PROP_STR = "status"
+    meson-eth{
+		compatible = "amlogic,meson-eth";
+		dev_name = "meson-eth";
+		status = "okay";
+		ethbaseaddr = <0xfe0c0000>;
+		interruptnum = <40>;
+	};
+
+}; /* end of / */
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_hdmiin.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_hdmiin.dtd
new file mode 100755
index 000000000000..c91a536fa56c
--- /dev/null
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_hdmiin.dtd
@@ -0,0 +1,1551 @@
+/dts-v1/;
+/// ***************************************************************************************\n
+//$$ PROJECT="meson8"
+//$$ REMOVE 1
+void root_func(){
+//$$ ADD /{
+	compatible = "AMLOGIC,8726_M8";
+	model = "AMLOGIC";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	
+/// ***************************************************************************************
+///	-	CPU
+//$$ MODULE="CPU"
+    cpus {
+        #address-cells = <1>;
+        #size-cells = <0>;
+//$$ DEVICE="cpu0"
+        cpu@0 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x200>;
+        };
+//$$ DEVICE="cpu1"
+        cpu@1 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x1>;
+        };
+//$$ DEVICE="cpu2"
+        cpu@2 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x2>;
+        };
+//$$ DEVICE="cpu3"
+        cpu@3 {
+        	device_type = "cpu";
+        	compatible = "arm,cortex-a9";
+        	reg = <0x3>;
+        };
+    };
+
+/// ***************************************************************************************
+///	-	Cache
+//$$ MODULE="Cache"
+//$$ DEVICE="cache"
+    cache-controller {
+          compatible = "arm,meson-pl310-cache";
+          reg = <0xc4200000 0x1000>;
+          arm,data-latency = <3 3 3>;
+          arm,tag-latency = <2 2 2>;
+          cache-unified;
+          cache-level = <2>;
+          aux-instruction_prefetch;
+          aux-data_prefetch;
+          aux-ns_lockdown;
+          aux-force_no_write_alloc;
+          aux-cache_replace_policy_round_robin;
+          aux-early_write_response;
+          aux-full_line_of_zero;
+          aux-ns_int_ctrl;
+          aux-share_override;
+          prefetch-double_line_fill;
+          prefetch-prefetch_drop;
+          prefetch-prefetch_offset = <7>;
+    };
+
+/// ***************************************************************************************
+///	-	Memory
+//$$ MODULE="Memory"
+//$$ DEVICE="memory"
+//$$ L2 PROP_U32 = "aml_reserved_start"
+//$$ L2 PROP_U32 = "aml_reserved_end"
+//$$ L2 PROP_U32 6 = "linux,usable-memory"
+	memory{
+		device_type = "memory";
+		aml_reserved_start = <0x06000000>; /**reserved memory start */
+		aml_reserved_end = <0x05000000>;/**reserved memory end */
+		phys_offset = <0x00000000>;
+		linux,total-memory = <0x80000000>;
+	};
+/// ***************************************************************************************
+///	-	GIC
+//$$ MODULE="GIC"
+//$$ DEVICE="gic"	
+	gic:interrupt-controller{
+        compatible = "arm,cortex-a9-gic";
+        reg = <0xc4301000 0x1000
+               0xc4300100 0x0100>;
+        interrupt-controller;
+        #interrupt-cells = <3>;
+        #address-cells = <0>;
+    };
+    
+/// ***************************************************************************************
+///	-	VPU
+//$$ MODULE="VPU"
+//$$ DEVICE="vpu"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "clk_level"
+    vpu{
+		compatible = "amlogic,vpu";
+		dev_name = "vpu";	
+		status = "ok";
+		clk_level = <7>;
+		/**    	0: 106.25M		1: 127.5M		2: 159.375M
+				3: 182.15M		4: 212.5M		5: 255M
+		    	6: 318.75M		7: 364.3M					 */
+	};
+	
+/// **************************************************************************************	
+/// -   DISP&MM-FB
+//$$ MODULE = "DISP&MM-FB"	
+//$$ DEVICE = "mesonfb"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+//$$ L2 PROP_U32 = "vmode"
+//$$ L2 PROP_U32 5 = "display_size_default"
+	mesonfb{
+		compatible = "amlogic,mesonfb";
+		dev_name = "mesonfb";
+		status = "okay";
+	   	reserve-memory = <0x01800000  0x00100000>;
+	   	reserve-iomap = "true";
+                vmode = <3>; /**0:VMODE_720P 1:VMODE_LCD  2:VMODE_LVDS_1080P 3:VMODE_1080P*/
+		scale_mode = <1>; /*0:default 1:new*/
+ 		display_size_default = <1920 1080 1920 3240 32>;
+	};
+	
+//$$ DEVICE="deinterlace"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+    	deinterlace{
+		compatible = "amlogic,deinterlace";
+		dev_name = "deinterlace";
+		status = "ok";
+		reserve-memory = <0x02300000>; 	 
+	};
+
+/// ***************************************************************************************
+///	-	DISP&MM-A/V stream
+//$$ MODULE = "DISP&MM-A/V stream"
+//$$ DEVICE="mesonstream"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+	mesonstream{
+		compatible = "amlogic,mesonstream";
+		dev_name = "mesonstream.0";
+		status = "okay";
+		reserve-memory = <0x02000000>;
+		reserve-iomap = "true";
+	};
+
+/// ***************************************************************************************
+///     -       DISP&MM-A/V stream
+//$$ MODULE = "DISP&MM-A/V video dec"
+//$$ DEVICE="vdec"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 4 ="reg"
+        vdec{
+                compatible = "amlogic,vdec";
+                dev_name = "vdec.0";
+                status = "okay";
+                reserve-memory = <0x10000000>;
+                reserve-iomap = "true";
+        };
+
+/// ***************************************************************************************
+///	-	DISP&MM-PostProcess
+//$$ MODULE="DISP&MM-PostProcess"
+//$$ DEVICE="ppmgr"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+    ppmgr{
+		compatible = "amlogic,ppmgr";
+		dev_name = "ppmgr";
+		status = "okay";
+		reserve-memory = <0x03000000>;
+	};
+
+/// ***************************************************************************************
+///	-	DISP&MM-AVC Video Encoder
+//$$ MODULE = "DISP&MM-AVC Video Encoder"
+//$$ DEVICE="amvenc_avc"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+    amvenc_avc{
+		compatible = "amlogic,amvenc_avc";
+		dev_name = "amvenc_avc.0";
+		status = "okay";
+		reserve-memory = <0x00f00000>;
+		reserve-iomap = "true";
+	};
+	
+/// ***************************************************************************************
+///	-	DISP&MM-BT656
+//$$ MODULE = "DISP&MM-BT656"
+//$$ DEVICE="amvdec_656in"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+//    amvdec_656in{
+//		compatible = "amlogic,amvdec_656in";
+//		dev_name = "amvdec_656in";
+//		status = "ok";
+//		reg = <0x1e400000 0x00100000>;
+//	};
+//	
+/// ***************************************************************************************
+///	-	DISP&MM-VDIN
+//$$ MODULE = "DISP&MM-VDIN"	
+//$$ DEVICE="vdin1"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+//$$ L2 PROP_U32 = "irq"
+//$$ L2 PROP_U32 = "vdin_id"
+    vdin1{
+        compatible = "amlogic,vdin";
+        dev_name = "vdin1";
+        status = "ok";
+        reserve-memory = <0x01000000>;
+	miracast_size = <1920 1080>;//1920x1080x2x4=17M
+	reserve-iomap = "true";
+        irq = <117>;
+        vdin_id = <1>;
+	};
+
+/// ***************************************************************************************
+/// -   RGB-VDIN
+//$$ MODULE = "RGB-VDIN"    
+//$$ DEVICE="vdin0"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reserve-memory"
+//$$ L2 PROP_U32 = "irq"
+//$$ L2 PROP_U32 = "vdin_id"
+    vdin0{
+        compatible = "amlogic,vdin";
+        dev_name = "vdin0";
+        status = "ok";
+        reserve-memory = <0x01000000>;
+        rgbin_size = <1920 1080>;//1920x1080x2x4=17M
+        reserve-iomap = "true";
+        irq = <115>;
+        vdin_id = <0>;
+    };
+
+/// ***************************************************************************************
+///	-	DISP&MM-AMLVIDEO2
+//$$ MODULE = "DISP&MM-AMLVIDEO2"
+//$$ DEVICE="amlvideo2"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+    amlvideo2{
+		compatible = "amlogic,amlvideo2";
+		dev_name = "amlvideo2.0";
+		status = "okay";
+		reserve-memory = <0x01000000>;
+		reserve-iomap = "true";
+	};
+
+/// ***************************************************************************************
+///	-	ION
+//$$ MODULE="ION"
+//$$ DEVICE="ion_dev"
+//$$ L2 PROP_STR = "status"
+    ion_dev{
+        compatible = "amlogic,ion_dev";
+        dev_name = "ion_dev";
+        status = "ok";
+        share-memory-name = "ppmgr0";
+        share-memory-offset = <0>;
+        share-memory-size = <0x03000000>;
+    };
+/// ***************************************************************************************
+///	-	DISP&MM-Vout
+//$$ MODULE = "DISP&MM-Vout"
+//$$ DEVICE = "mesonvout"
+//$$ L2 PROP_STR = "status"
+	mesonvout{
+		compatible = "amlogic,mesonvout";
+		dev_name = "mesonvout";
+		status = "okay";
+	};
+
+/// ***************************************************************************************
+///	-	RTC
+//$$ MODULE="RTC"
+//$$ DEVICE="Rtc"
+//$$ L2 PROP_STR = "status"
+    rtc{
+		compatible = "amlogic,aml_rtc";
+		status = "okay";
+	};
+
+/// ***************************************************************************************
+///	-	UART
+//$$ MODULE="UART"
+//$$ DEVICE="uart_ao"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L3 PROP_CHOICE "uart_ao_pin_match" = "pinctrl-0"
+	uart_ao{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_ao";
+		status = "okay";
+		dev_name = "uart_ao";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ao_uart_pins>;
+	};
+	
+//$$ DEVICE="uart_0"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L3 PROP_CHOICE "uart_0_pin_match" = "pinctrl-0"
+	uart_0{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_a";
+		status = "okay";
+		dev_name = "uart_0";
+    	pinctrl-names = "default";
+    	pinctrl-0 = <&a_uart_pins>;
+	};
+	
+//$$ DEVICE="uart_1"
+//$$ L2 PROP_STR = "status"
+	uart_1{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_b";
+		status = "disabled";
+		dev_name = "uart_1";
+	};
+	
+//$$ DEVICE="uart_2"
+//$$ L2 PROP_STR = "status"
+	uart_2{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_c";
+		status = "disabled";
+		dev_name = "uart_2";
+	};
+	
+//$$ DEVICE="uart_3"
+//$$ L2 PROP_STR = "status"	
+	uart_3{
+		compatible = "amlogic,aml_uart";
+		port_name = "uart_d";
+		status = "ok";
+		dev_name = "uart_3";
+	};
+
+/// ***************************************************************************************
+///	-	Bluetooth
+//$$ MODULE="Bluetooth"
+//$$ DEVICE="bt-dev"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "gpio_reset"
+    bt-dev{
+        compatible = "amlogic,bt-dev";
+        dev_name = "bt-dev";
+        status = "ok";
+        gpio_reset = "GPIOX_20";
+    };
+
+/// ***************************************************************************************
+///	-	WiFi
+//$$ MODULE="WiFi"
+//$$ DEVICE="aml_broadcm_wifi"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "interrupt_pin"
+//$$ L2 PROP_U32 = "irq_num"
+//$$ L2 PROP_STR = "irq_trigger_type"
+//$$ L2 PROP_STR = "power_on_pin"
+//$$ L2 PROP_STR = "clock_32k_pin"
+    wifi{
+		compatible = "amlogic,aml_broadcm_wifi";
+		dev_name = "aml_broadcm_wifi";
+		status = "okay";
+		interrupt_pin = "GPIOX_21";
+		irq_num = <4>;
+		irq_trigger_type = "GPIO_IRQ_HIGH";
+		power_on_pin = "GPIOAO_6";
+		power_on_pin2 = "GPIOX_11";
+		clock_32k_pin = "GPIOX_10";
+	};
+	
+//$$ DEVICE="wifi_power"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "power_gpio"
+	wifi_power{
+            compatible = "amlogic,wifi_power";
+            dev_name = "wifi_power";
+            status = "okay";
+            power_gpio = "GPIOAO_6";
+            power_gpio2 = "GPIOX_11";
+	}; 
+
+/// ***************************************************************************************
+///	-	MMC
+//$$ MODULE="MMC"
+//$$ DEVICE="aml_sdio"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L2 PROP_STR 7 = "pinctrl-names"
+//$$ L2 PROP_CHOICE "sdio_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "sdio_pin_1_match" = "pinctrl-1"
+//$$ L2 PROP_CHOICE "sdio_pin_2_match" = "pinctrl-2"
+//$$ L2 PROP_CHOICE "sdio_pin_3_match" = "pinctrl-3"
+//$$ L2 PROP_CHOICE "sdio_pin_4_match" = "pinctrl-4"
+//$$ L2 PROP_CHOICE "sdio_pin_5_match" = "pinctrl-5"
+//$$ L2 PROP_CHOICE "sdio_pin_6_match" = "pinctrl-6"
+sdio{
+        compatible = "amlogic,aml_sdio";
+        dev_name = "aml_sdio.0";
+        status = "okay";
+        reg = <0xc1108c20 0x20>;
+        pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "emmc_clk_cmd_pins", "emmc_all_pins", "sdio_clk_cmd_pins", "sdio_all_pins","sd_1bit_pins"; // "jtag_pin", "uartao_default";
+        pinctrl-0 = <&sd_clk_cmd_pins>;
+        pinctrl-1 = <&sd_all_pins>;
+        pinctrl-2 = <&emmc_clk_cmd_pins>;
+        pinctrl-3 = <&emmc_all_pins>;
+        pinctrl-4 = <&sdio_clk_cmd_pins>;
+        pinctrl-5 = <&sdio_all_pins>;
+        pinctrl-6 = <&sd_1bit_pins>;
+
+//$$ DEVICE="sd"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 3 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"
+//$$ L2 PROP_STR = "jtag_pin"
+//$$ L2 PROP_STR = "gpio_cd"
+//$$ L2 PROP_STR = "gpio_ro"
+//$$ L2 PROP_U32 = "irq_in"
+//$$ L2 PROP_U32 = "irq_out"
+//$$ L2 PROP_U32 = "card_type"
+        sd{
+            status = "okay";
+            port = <1>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sd";
+            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
+            f_min = <300000>;
+            f_max = <50000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            gpio_dat3 = "CARD_4";
+            jtag_pin = "CARD_0";
+            gpio_cd = "CARD_6";
+            gpio_ro = "GPIOZ_0";
+            irq_in = <3>;
+            irq_out = <5>;
+            card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+
+//$$ DEVICE="emmc"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 4 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "f_max_w"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_STR = "gpio_dat3"
+//$$ L2 PROP_U32 = "card_type"
+        emmc{
+            status = "ok";
+            port = <2>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "emmc";
+            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+            f_min = <300000>;
+            f_max = <50000000>;
+            f_max_w = <50000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            gpio_dat3 = "BOOT_3";
+            card_type = <1>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+
+//$$ DEVICE="sdio"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 = "port"
+//$$ L2 PROP_STR = "pinname"
+//$$ L3 PROP_U32 = "ocr_avail"
+//$$ L2 PROP_STR 4 = "caps"
+//$$ L3 PROP_U32 = "f_min"
+//$$ L3 PROP_U32 = "f_max"
+//$$ L3 PROP_U32 = "max_req_size"
+//$$ L2 PROP_U32 = "card_type"    
+        sdio{
+            status = "ok";
+            port = <0>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+            pinname = "sdio";
+            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
+            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE";
+            f_min = <300000>;
+            f_max = <50000000>;
+            max_req_size = <0x20000>;          /**128KB*/
+            card_type = <3>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+        };
+    };
+
+/// ***************************************************************************************
+///	-	I2C
+//$$ MODULE="I2C"
+//$$ DEVICE="I2C_AO"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_AO_pin_match" = "pinctrl-0"	
+	i2c@c8100500{ /*I2C-AO*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-AO";
+		status = "ok";
+		reg = <0xc8100500 0x1d>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		device_id = <0>;
+		pinctrl-names="default";
+		pinctrl-0=<&ao_i2c_master>;
+	};
+
+//$$ DEVICE = "I2C_A"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+    i2c@c1108500{ /*I2C-A*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-A";
+		status = "ok";
+		reg = <0xc1108500 0x20>;
+		device_id = <1>;
+		pinctrl-names="default";
+//		pinctrl-0=<&a_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+	
+//$$ DEVICE="I2C_B"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_B_pin_match" = "pinctrl-0"	
+	i2c@c11087c0{ /*I2C-B*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-B";
+		status = "ok";
+		reg = <0xc11087c0 0x20>;
+		device_id = <2>;
+		pinctrl-names="default";
+		pinctrl-0=<&b_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+ 	};
+
+//$$ DEVICE="I2C_C"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2="reg"
+//$$ L3 PROP_STR = "pinctrl-names"	
+    i2c@c11087e0{ /*I2C-C*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-C";
+		status = "ok";
+		reg = <0xc11087e0 0x20>;
+		device_id = <3>;
+		pinctrl-names="default";
+//		pinctrl-0=<&c_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+//$$ DEVICE="I2C_D"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2="reg"
+//$$ L3 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "I2C_D_pin_match" = "pinctrl-0"	
+	i2c@c1108d20{ /*I2C-D*/
+		compatible = "amlogic,aml_i2c";
+		dev_name = "i2c-D";
+		status = "ok";
+		reg = <0xc1108d20 0x20>;
+		device_id = <4>;
+		pinctrl-names="default";
+		pinctrl-0=<&d_i2c_master>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+/// ***************************************************************************************
+///	-	Power
+//$$ MODULE="Power"
+//$$ DEVICE="dvfs"
+//$$ L2 PROP_STR = "status"
+    dvfs {
+        compatible = "amlogic, amlogic-dvfs";                   /** fixed for driver, don't change       */
+        #address-cells = <1>;
+        #size-cells = <0>;
+        status = "ok";
+
+//$$ L2 PROP_U32 = "dvfs_id"
+//$$ L2 PROP_U32 = "table_count"
+//$$ L2 PROP_U32 16*3 = "dvfs_table"
+        vcck_dvfs {
+            dvfs_id     = <1>;                                  /** must be value of (1 << n)            */
+            table_count = <14>;                                 /** must be correct count for dvfs_table */
+            dvfs_table  = <
+            /* NOTE: frequent in this table must be ascending order */
+            /* frequent(Khz)    min_uV      max_uV                  */
+                  96000         825000      825000
+                 192000         825000      825000
+                 312000         825000      825000
+                 408000         825000      825000
+                 504000         825000      825000
+                 600000         850000      850000
+                 720000         850000      850000
+                 816000         875000      875000
+                1008000         925000      925000
+                1200000         975000      975000
+                1416000        1025000     1025000
+                1608000        1100000     1100000
+                1800000        1125000     1125000
+                1992000        1150000     1150000
+            >;
+        };
+    };
+
+//$$ DEVICE="arm_pmu"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 4*3 = "interrupts"
+    arm_pmu {
+        compatible = "arm,cortex-a9-pmu";
+        status = "ok";
+        interrupts = <0     137     0x04
+                      0     138     0x04
+                      0     153     0x04
+                      0     154     0x04>;
+    };
+
+    pmu {
+        compatible = "amlogic, aml_pmu_prober";                 /* fixed for pmu driver, don't change   */
+        #address-cells = <1>;
+        #size-cells = <0>;
+//$$ DEVICE = "Pmu_axp202"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_STR = "status"
+        axp202 { /* PMU for AXP */
+            compatible = "axp_mfd";                             /* for driver probe, must have          */
+            sub_type = "axp20_mfd";                             /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x34>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            ddr_voltage   = <1500000>;                          /** default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /** default voltage for AO, optional     */
+            status = "disable";                                 /** status of pmu, only one should be OK */
+        };
+//$$ DEVICE = "Pmu_aml1212"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_STR = "status"
+        aml1212{                                                /* PMU for AML1212, see comment above   */
+            compatible = "aml_pmu";                             /* for driver probe, must have          */
+            sub_type = "aml1212";                               /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x35>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            ddr_voltage   = <1500000>;                          /** default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /** default voltage for AO, optional     */
+            status = "disable";                                 /** status of pmu, only one should be OK */
+        };
+//$$ DEVICE = "Pmu_rn5t618"
+//$$ L2 PROP_STR = "sub_type"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_U32 = "reg"
+//$$ L2 PROP_U32 = "soft_limit_to99"
+//$$ L2 PROP_U32 = "ddr_voltage"
+//$$ L2 PROP_U32 = "vddao_voltage"
+//$$ L2 PROP_STR = "status"
+        rn5t618{                                                /* PMU for RN5T618, see comment above   */
+            compatible = "ricoh_pmu";                           /* for driver probe, must have          */
+            sub_type = "rn5t618";                               /** sub type of pmu family, must have    */
+            i2c_bus = "i2c_bus_ao";                             /** attached i2c bus, must have          */
+            reg = <0x32>;                                       /** device i2c address, must have        */
+            soft_limit_to99 = <0>;                              /** optional                             */
+            ddr_voltage   = <1500000>;                          /** default voltage for DDR, optional    */
+            vddao_voltage = <1200000>;                          /** default voltage for AO, optional     */
+            status = "okay";                                    /** status of pmu, only one should be OK */
+        };
+    };
+
+/// ***************************************************************************************
+///	-	USB Controller
+//$$ MODULE="USB Controller"
+    usb_con {
+		lm-compatible = "logicmodule-bus";
+
+//$$ DEVICE="usb_b"
+//$$ L2 PROP_U32 = "lm-periph-id" 
+//$$ L2 PROP_STR = "clock-src"
+//$$ L2 PROP_U32 = "port-id"
+//$$ L2 PROP_U32 = "port-type"
+//$$ L2 PROP_U32 = "port-speed"
+//$$ L2 PROP_U32 = "port-config"
+//$$ L2 PROP_U32 = "port-dma"
+//$$ L2 PROP_U32 = "port-id-mode"
+//$$ L2 PROP_STR = "status"
+        	usb_b{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <1>; /** lm name */
+			clock-src = "usb1"; /** clock src */
+			port-id = <1>;   /** ref to mach/usb.h */
+			port-type = <1>;	/** 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /** 0: default, 1: high, 2: full */
+			port-config = <0>; /** 0: default */
+			port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <1>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+			status = "okay";
+		};
+		
+//$$ DEVICE="usb_a"
+//$$ L2 PROP_U32 = "lm-periph-id"
+//$$ L2 PROP_STR = "clock-src"
+//$$ L2 PROP_U32 = "port-id"
+//$$ L2 PROP_U32 = "port-type"
+//$$ L2 PROP_U32 = "port-speed"
+//$$ L2 PROP_U32 = "port-config"
+//$$ L2 PROP_U32 = "port-dma"
+//$$ L2 PROP_U32 = "port-id-mode"
+//$$ L2 PROP_STR = "gpio-vbus-power"
+//$$ L2 PROP_U32 = "gpio-work-mask"
+//$$ L2 PROP_STR = "status"
+		usb_a{
+			lm-compatible = "amlogic,usb";
+			lm-periph-id = <0>; /** lm name */
+			clock-src = "usb0"; /** clock src */
+			port-id = <0>;  /** ref to mach/usb.h */
+			port-type = <0>;	/** 0: otg, 1: host, 2: slave */
+			port-speed = <0>; /** 0: default, high, 1: full */
+			port-config = <0>; /** 0: default */
+			port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
+			port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
+			gpio-vbus-power = "GPIOZ_1";
+			gpio-work-mask	= <1>; /**0: work on pulldown,1:work on pullup*/
+			status = "okay";
+		};
+	};
+
+
+
+
+/// ***************************************************************************************
+///	-	Spi
+//$$ MODULE="Spi"
+//$$ DEVICE="spi"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "reg"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "Spi_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_U32 = "nr-parts"
+//$$ L2 PROP_CHOICE "Spi_nr-part-0_match" = "nr-part-0"
+//$$ L2 PROP_CHOICE "Spi_nr-part-1_match" = "nr-part-1"
+    spi@cc000000{
+		compatible = "amlogic,apollo_spi_nor";
+		status = "ok";
+		reg = <0xcc000000 0x04000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&aml_spi_nor_pins>;
+
+		nr-parts = <2>;
+		nr-part-0 = <&bootloader>;
+		nr-part-1 = <&ubootenv>;
+
+//$$ MATCH "Spi_nr-part-0_match" = <&bootloader>
+//$$ L2 PROP_STR = "name"
+//$$ L2 PROP_U32 = "offset"
+//$$ L2 PROP_U32 = "size"
+		bootloader:bootloader{
+			name = "bootloader";
+			offset = <0>;
+			size = <0x60000>;
+		};
+
+//$$ MATCH "Spi_nr-part-1_match" = <&ubootenv>
+//$$ L2 PROP_STR = "name"
+//$$ L2 PROP_U32 = "offset"
+//$$ L2 PROP_U32 = "size"
+		ubootenv:ubootenv{
+			name = "ubootenv";
+		      offset = <0x100000>;
+		      size = <0x10000>;
+		};
+	};
+
+// ***************************************************************************************
+///	-	Nand
+//$$ MODULE="Nand"
+//$$ DEVICE="aml_nand"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 2 ="reg"
+//$$ L2 PROP_STR 2 = "pinctrl-names"
+//$$ L2 PROP_CHOICE 3 "Nand_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE 3 "Nand_pin_1_match" = "pinctrl-1"
+//$$ L3 PROP_STR ="plat-names"
+//$$ L2 PROP_U32 = "plat-num"
+//$$ L2 PROP_CHOICE "plat-part-0_match" = "plat-part-0"
+	nand{
+		compatible = "amlogic,aml_nand";
+		dev_name = "nand";
+		status = "ok";
+		reg = <0xd0048600 0x24>;
+		pinctrl-names = "nand_rb_mod","nand_norb_mod";
+		pinctrl-0 = <&nand_input_state &conf_nand_state &nand_base>;
+		pinctrl-1 = <&nand_input_state &conf_nand_state &nand_base>;
+		device_id = <0>;
+		plat-names = "nandnormal";
+		plat-num = <1>;
+		plat-part-0 = <&normal>;
+
+//$$ MATCH "plat-part-0_match" = <&normal>
+//$$ L2 PROP_STR 4 = "enable_pad"
+//$$ L2 PROP_STR = "busy_pad"
+		normal: normal{
+			enable_pad ="ce0","ce1","ce2","ce3";
+			busy_pad = "rb0";
+		};
+	};
+
+/// ***************************************************************************************
+///	-	Efuse
+//$$ MODULE="Efuse"
+//$$ DEVICE="efuse"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 2 = "plat-pos"
+//$$ L2 PROP_U32 = "plat-count"
+//$$ L2 PROP_U32 = "usid-min"
+//$$ L2 PROP_U32 = "usid-max"
+    efuse{
+		compatible = "amlogic,efuse";
+		dev_name = "efuse";
+		status = "okay";
+		plat-pos = <0 454>;
+		plat-count = <58>;
+		usid-min = <8>; /*reserved*/
+		usid-max = <31>; /*reserved*/
+	};
+
+/// ***************************************************************************************
+///	-	Thermal
+//$$ MODULE="Thermal"
+//$$ DEVICE="thermal"
+//$$ L2 PROP_U32 3*3 = "trip_point"
+//$$ L2 PROP_U32 = "#thermal-cells"
+//$$ L2 PROP_U32 = "cpu_cali_a"
+//$$ L2 PROP_U32 = "idle_interval"
+	thermal{
+		compatible = "amlogic-thermal";
+		#thermal-cells=<3>;
+		dev_name = "aml_thermal";
+		trip_point=<50 1200000 1200000
+			    70  800000 800000
+			    110 0xffffffff 0xffffffff>;
+		cpu_cali_a=<0>;
+		idle_interval=<1000>;
+
+	};
+	
+/// ***************************************************************************************
+/// -   Audio
+//$$ MODULE="Audio"
+//$$ DEVICE="audio_i2s"
+//$$ L2 PROP_STR = "status"
+    audio_platform{
+        compatible = "amlogic,aml-i2s";
+        dev_name = "aml-i2s.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_i2s_dai"
+//$$ L2 PROP_STR = "status"
+    audio_dai{
+        compatible = "amlogic,aml-i2s-dai";
+        dev_name = "aml-i2s-dai.0";
+        status = "okay";
+    };
+    audio_spdif_dai{
+        compatible = "amlogic,aml-spdif-dai";
+        dev_name = "aml-spdif-dai.0";
+        status = "okay";
+    };
+
+    audio_spdif_codec{
+        compatible = "amlogic,aml-spdif-codec";
+        dev_name = "spdif-dit.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm2BT_codec"
+//$$ L2 PROP_STR = "status"
+    audio_pcm2BT_codec{
+        compatible = "amlogic,pcm2BT-codec";
+        dev_name = "pcm2bt.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm_dai"
+//$$ L2 PROP_STR = "status"
+    audio_pcm_dai{
+        compatible = "amlogic,aml-pcm-dai";
+        dev_name = "aml-pcm-dai.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_pcm"
+//$$ L2 PROP_STR = "status"
+    audio_pcm{
+        compatible = "amlogic,aml-pcm";
+        dev_name = "aml-pcm.0";
+        status = "okay";
+    };
+
+//$$ DEVICE="audio_m8_audio"
+//$$ L2 PROP_STR = "status"
+    audio_m8_audio{
+        compatible = "amlogic,m8_audio_codec";
+        dev_name = "aml_m8_codec.0";
+        status = "okay";
+    };
+
+    aml_audio_codec{
+        compatible = "amlogic,audio_codec";
+        rt5616:rt5616{
+            codec_name = "rt5616";
+            i2c_addr = <0x1B>;
+            i2c_bus = "i2c_bus_d";
+            id_reg = <0x00>;
+            id_val = <0x21>;
+            capless = <0>;
+            status = "okay";
+        };
+        rt5631:rt5631{
+            codec_name = "rt5631";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            id_reg = <0x00>;
+            id_val = <0x01>;
+            capless = <0>;
+            status = "disable";      
+        };  
+        wm8960:wm8960{
+            codec_name = "wm8960";
+            i2c_addr = <0x1A>;
+            i2c_bus = "i2c_bus_b";
+            capless = <1>;
+	    status = "disable";
+        };
+    };
+
+//$$ DEVICE="aml_m8_sound_card"
+//$$ L2 PROP_STR = "aml,sound_card"
+//$$ L2 PROP_STR = "aml,codec_dai"
+//$$ L2 PROP_STR 6*2 = "aml,audio-routing"
+//$$ L2 PROP_STR = "mute_gpio"
+//$$ L2 PROP_U32 5 = "hp_paraments"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "Audio_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_STR = "status"
+    aml_m8_sound_card{
+        compatible = "sound_card, aml_snd_m8";
+        aml,sound_card = "AML-M8AUDIO";
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
+        //aml,audio-codec = <&rt5616>;
+        aml,audio-routing-rt5616 = 
+            "Ext Spk","LOUTL",
+            "Ext Spk","LOUTR",
+            "HP","HPOL",
+            "HP","HPOR",
+            "micbias1","MAIN MIC",
+            "IN2P","micbias1";
+        aml,audio-routing-amlm8 = 
+            "Ext Spk","LINEOUTL",
+            "Ext Spk","LINEOUTR",
+            "HP","HP_L",
+            "HP","HP_R",
+            "MICBIAS","MAIN MIC",
+            "LINPUT1","MICBIAS";
+
+        mute_gpio = "GPIO_BSD_EN";
+        hp_paraments = <800 300 0 5 1>;
+        pinctrl-names = "aml_snd_m8";
+        pinctrl-0 = <&audio_pins>;
+        status = "okay";
+        
+    };
+
+/// ***************************************************************************************
+///	-	Input
+//$$ MODULE="Input"
+//$$ DEVICE="gpio_keypad"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "scan_period"
+//$$ L2 PROP_U32 = "key_num"
+//$$ L2 PROP_STR = "key_name"
+//$$ L2 PROP_U32 = "key_code"
+//$$ L2 PROP_STR = "key_pin"
+//$$ L2 PROP_U32 = "irq_keyup"
+//$$ L2 PROP_U32 = "irq_keydown"
+    gpio_keypad{
+		compatible = "amlogic,gpio_keypad";
+		status = "okay";
+		scan_period = <20>;
+		key_num = <1>;
+        key_name = "power";
+		key_code = <116>;
+		key_pin = "GPIOAO_3";
+        irq_keyup = <6>;
+        irq_keydown = <7>;
+	};
+//$$ DEVICE="saradc"
+//$$ L2 PROP_STR = "status"
+	saradc{
+		compatible = "amlogic,saradc";
+		status = "okay";
+	};
+	
+//$$ DEVICE="meson-remote"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "ao_baseaddr"
+//$$ L2 PROP_STR = "pinctrl-names"
+//$$ L2 PROP_CHOICE "remote_pin_0_match" = "pinctrl-0"
+    meson-remote{
+		compatible = "amlogic,aml_remote";
+		dev_name = "meson-remote";
+		status = "ok";
+		ao_baseaddr = <0xf3100480>;
+		pinctrl-names="default";
+		pinctrl-0=<&remote_pins>;
+	};
+	
+/// ***************************************************************************************
+///	-	Securitykey
+//$$ MODULE="Securitykey"
+//$$ DEVICE="securitykey"
+//$$ L2 PROP_STR = "status"
+    securitykey{
+		compatible = "amlogic,aml_keys";
+		status = "ok";
+	};
+
+/// ***************************************************************************************
+///	-	Unifykey
+//$$ MODULE="Unifykey"
+//$$ DEVICE="securitykey"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_U32 ="unifykey-num"
+//$$ L2 PROP_CHOICE "Unifykey_0_match" = "unifykey-index-0"
+//$$ L2 PROP_CHOICE "Unifykey_1_match" = "unifykey-index-1"
+//$$ L2 PROP_CHOICE "Unifykey_2_match" = "unifykey-index-2"
+    	unifykey{
+		compatible = "amlogic,unifykey";
+		status = "ok";
+
+		/*efuse-version = <0>;*/ /*m6 efuse version 2,m3 efuse version 1, not config efuse version in default*/
+		unifykey-num = <3>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+
+
+//$$ MATCH "Unifykey_0_match" = <&keysn_0>
+//$$ L2 PROP_STR = "key-name"
+//$$ L2 PROP_STR = "key-device"
+//$$ L2 PROP_STR = "key-dataformat"
+//$$ L2 PROP_STR 3 = "key-permit"
+		keysn_0: key_0{
+			key-name = "usid";
+			key-device = "nandkey";
+			key-dataformat = "allascii";
+			key-permit = "read","write","del";
+		};
+		
+//$$ MATCH "Unifykey_1_match" = <&keysn_1>
+//$$ L2 PROP_STR = "key-name"
+//$$ L2 PROP_STR = "key-device"
+//$$ L2 PROP_STR = "key-dataformat"
+//$$ L2 PROP_STR 3 = "key-permit"
+		keysn_1:key_1{
+			key-name = "mac";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+		
+//$$ MATCH "Unifykey_2_match" = <&keysn_2>
+//$$ L2 PROP_STR = "key-name"
+//$$ L2 PROP_STR = "key-device"
+//$$ L2 PROP_STR = "key-dataformat"
+//$$ L2 PROP_STR 3 = "key-permit"
+		keysn_2:key_2{
+			key-name = "key2";
+			key-device = "nandkey";
+			key-dataformat = "hexdata";
+			key-permit = "read","write","del";
+		};
+	};
+	
+/// ***************************************************************************************
+///	-	HDMI
+//$$ MODULE="HDMI"
+//$$ DEVICE="amhdmitx"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_CHOICE "HDMI_vend-data_match" = "vend-data"
+//$$ L2 PROP_CHOICE "HDMI_pwr-ctrl_match" = "pwr-ctrl"
+    amhdmitx{
+		compatible = "amlogic,amhdmitx";
+		dev_name = "amhdmitx";
+		status = "ok";
+        vend-data = <&vend_data>;
+        pwr-ctrl = <&pwr_ctrl>;
+        
+//$$ MATCH "HDMI_vend-data_match" = <&vend_data>
+//$$ L2 PROP_STR = "vendor_name"
+//$$ L2 PROP_U32 = "vendor_id"
+//$$ L2 PROP_STR = "product_desc"
+//$$ L2 PROP_STR = "cec_osd_string"        
+        vend_data: vend_data{
+            vendor_name = "Amlogic";           /* Max Chars: 8     */
+            vendor_id = <0x000000>;                 /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
+            product_desc = "M8 MBox SKTv1";        /* Max Chars: 16    */
+            cec_osd_string = "Amlogic MBox";        /* Max Chars: 14    */
+        };
+        
+//$$ MATCH "HDMI_pwr-ctrl_match" = <&pwr_ctrl>
+//$$ L2 PROP_STR = "pwr_5v_on"
+//$$ L2 PROP_STR = "pwr_5v_off"
+//$$ L2 PROP_STR = "pwr_3v3_on"
+//$$ L2 PROP_STR = "pwr_3v3_off"
+//$$ L2 PROP_STR = "pwr_hpll_vdd_on"
+//$$ L2 PROP_STR = "pwr_hpll_vdd_off"
+        pwr_ctrl: pwr_ctrl{
+            pwr_5v_on = "";
+            pwr_5v_off = "";
+            pwr_3v3_on = "";
+            pwr_3v3_off = "";
+            pwr_hpll_vdd_on = "";
+            pwr_hpll_vdd_off = "";
+        };
+	};
+
+/// ***************************************************************************************
+///    -       SII9293
+//$$ MODULE="sii9293"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_reset"
+//$$ L2 PROP_STR = "gpio_intr"
+   aml_sii9293{
+           compatible = "amlogic,sii9293";
+           i2c_bus = "i2c_bus_b";
+           gpio_reset = "GPIODV_28";
+           gpio_intr = "GPIODV_29";
+   };
+
+/// ***************************************************************************************
+///	-	SII9233
+//$$ MODULE="sii9233"
+//$$ L2 PROP_STR = "i2c_bus"
+//$$ L2 PROP_STR = "gpio_reset"
+//$$ L2 PROP_STR = "gpio_intr"
+	aml_sii9233a{
+		compatible = "amlogic,sii9233";
+		i2c_bus = "i2c_bus_b";
+		gpio_reset = "GPIODV_28";
+		gpio_intr = "GPIODV_29";
+	};
+
+/// ***************************************************************************************
+///	-	PowerManager
+//$$ MODULE="PowerManager"
+//$$ DEVICE="amvenc_avc"
+//$$ L2 PROP_STR = "status"
+    aml_pm{
+		compatible = "amlogic,pm-m8";
+		dev_name = "aml_pm_m8";
+		status = "okay";
+	};
+
+/// ***************************************************************************************
+///	-	Cpufreq
+//$$ MODULE="Cpufreq"
+//$$ DEVICE="cpufreq-meson"
+//$$ L2 PROP_STR = "status"
+    cpufreq-meson{
+        compatible = "amlogic,cpufreq-meson";
+        status = "okay";
+    };
+
+    crypto_device{
+       compatible = "amlogic,crypto-device";
+       dev_name = "crypto_device";
+    };
+
+/// **************************************************************************************
+/// -   GPIO
+//$$ MODULE="GPIO"
+//$$ DEVICE="m8-gpio"
+	gpio:gpio{
+		compatible = "amlogic,m8-gpio";
+		dev_name = "gpio";
+		#gpio-cells=<2>;
+	};
+
+/// **************************************************************************************
+/// -   Pinmux
+//$$ MODULE="Pinmux"
+//$$ DEVICE="pinmux-m8"
+    pinmux{ 
+		compatible = "amlogic,pinmux-m8";
+		dev_name = "pinmux";
+		#pinmux-cells=<2>;    
+    
+//$$ MATCH "uart_ao_pin_match" = "&ao_uart_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+        ao_uart_pins:ao_uart{
+			amlogic,setmask=<10 0x1800>;
+			amlogic,pins="GPIOAO_0", "GPIOAO_1";
+		};
+		
+//$$ MATCH "uart_0_pin_match" = "&a_uart_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 4 = "amlogic,pins"
+		a_uart_pins:a_uart{
+			amlogic,setmask=<4 0x3c00>;
+			amlogic,pins="GPIOX_12", "GPIOX_13", "GPIOX_14", "GPIOX_15";
+		};
+		
+//$$ MATCH "Nand_pin_0_match" = "&nand_input_state"
+//$$ MATCH "Nand_pin_1_match" = "&nand_input_state"
+//$$ L2 PROP_STR 18 = "amlogic,pins"
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+		nand_input_state:nand_input{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_12","BOOT_13",
+						"BOOT_8","BOOT_9","BOOT_10","BOOT_11",
+						"BOOT_14","BOOT_15","BOOT_16","BOOT_17";
+			amlogic,enable-output=<1>;
+		};
+		
+//$$ MATCH "Nand_pin_0_match" = "&conf_nand_state"
+//$$ MATCH "Nand_pin_1_match" = "&conf_nand_state"
+//$$ L2 PROP_STR 9 = "amlogic,pins"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+		conf_nand_state: conf_nand{
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_15";
+			amlogic,pullup=<0>;
+		};
+		
+//$$ MATCH "Nand_pin_0_match" = "&nand_base"
+//$$ MATCH "Nand_pin_1_match" = "&nand_base"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 17 = "amlogic,pins"
+		nand_base: nand{
+			amlogic,setmask=<2 0x7fe0000>;
+			amlogic,clrmask=<	5 0xe
+							6 0x3f000000
+							4 0x7c000000>;
+			amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_4",
+						"BOOT_5","BOOT_6","BOOT_7","BOOT_8","BOOT_9",
+						"BOOT_10","BOOT_12","BOOT_13",
+						"BOOT_14","BOOT_15","BOOT_16","BOOT_17";
+		};
+		
+//$$ MATCH "Card_pin_0_match" = "&sdhc_b_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+		sdhc_b_pins:sdhc_b_pin{
+			amlogic,setmask=<2 0xfc00>;
+			amlogic,clrmask=<2 0xf0 8 0x600>;
+			amlogic,pins="CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+		};
+
+//$$ MATCH "Card_pin_1_match" = "&sdhc_c_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+		sdhc_c_pins:sdhc_c_pin{
+			amlogic,setmask=<6 0x3f000000>;
+			amlogic,clrmask=<4 0x6c000000 2 0x4c00000>;
+			amlogic,pins="BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_10","BOOT_11";
+		};
+
+//$$ MATCH "Card_pin_2_match" = "&sdhc_a_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"		
+		sdhc_a_pins:sdhc_a_pin{
+			amlogic,setmask=<8 0x3f>;
+			amlogic,clrmask=<5 0x6c00 >;
+			amlogic,pins="GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+		};
+
+//$$ MATCH "sdio_pin_5_match" = "&sdio_all_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"	
+        sdio_all_pins:sdio_all_pins{
+            amlogic,setmask=<8 0x0000003f>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_0","GPIOX_1","GPIOX_2","GPIOX_3","GPIOX_8","GPIOX_9";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_4_match" = "&sdio_clk_cmd_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sdio_clk_cmd_pins:sdio_clk_cmd_pins{
+            amlogic,setmask=<8 0x00000003>;         /*sdio a*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                2 0x0000fc00        /*sdio b*/
+                                5 0x00006c00>;      /*sdhc a*/
+            amlogic,pins = "GPIOX_8","GPIOX_9"; /** GPIOX_8:CLK, GPIOX_9:CMD */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+//$$ MATCH "sdio_pin_1_match" = "&sd_all_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sd_all_pins:sd_all_pins{
+            amlogic,setmask=<2 0x0000fc00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000063f        /*sdio a, UART*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_6_match" = "&sd_1bit_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sd_1bit_pins:sd_1bit_pins{
+            amlogic,setmask=<2 0x00008c00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_0","CARD_1","CARD_2","CARD_3","CARD_4","CARD_5";
+            amlogic,enable-output=<1>; /* 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_0_match" = "&sd_clk_cmd_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        sd_clk_cmd_pins:sd_clk_cmd_pins{
+            amlogic,setmask=<2 0x00000c00>;         /*sdio b*/
+            amlogic,clrmask=<6 0x3f000000           /*sdio c*/
+                                8 0x0000003f        /*sdio a*/
+                                2 0x000000f0>;      /*sdhc b*/
+            amlogic,pins = "CARD_2","CARD_3"; /** CARD_2:CLK, CARD_3:CMD */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_3_match" = "&emmc_all_pins"  
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 6 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"      
+        emmc_all_pins:emmc_all_pins{
+            amlogic,setmask=<6 0x3f000000>;         /*sdio c*/
+            amlogic,clrmask=<2 0x04c0fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000>;        /*sdhc c*/
+            amlogic,pins = "BOOT_0","BOOT_1","BOOT_2","BOOT_3","BOOT_16","BOOT_17";
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+        
+//$$ MATCH "sdio_pin_2_match" = "&emmc_clk_cmd_pins" 
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 3*2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"	
+//$$ L2 PROP_U32 = "amlogic,enable-output"
+//$$ L2 PROP_U32 = "amlogic,pullup"
+//$$ L2 PROP_U32 = "amlogic,pullupen"
+        emmc_clk_cmd_pins:emmc_clk_cmd_pins{
+            amlogic,setmask=<6 0x03000000>;         /*bit[24-25] */
+            amlogic,clrmask=<2 0x04c0fc00           /*sdio b & nand*/
+                                8 0x0000003f        /*sdio a*/
+                                4 0x6c000000>;        /*sdhc c*/
+            amlogic,pins = "BOOT_16","BOOT_17"; /** BOOT_16:CMD, BOOT_17:CLK */
+            amlogic,enable-output=<1>; /** 0:output, 1:input */
+            amlogic,pullup=<1>;
+            amlogic,pullupen=<1>;
+        };
+
+//$$ MATCH "I2C_AO_pin_match" = "&ao_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		ao_i2c_master:ao_i2c{
+			amlogic,setmask=<10 0x60>;
+			amlogic,clrmask=<10 0x1800006>;
+			amlogic,pins="GPIOAO_4","GPIOAO_5";
+		};
+		
+// MATCH "I2C_A_pin_match" = "&a_i2c_master"
+// L2 PROP_U32 2 = "amlogic,setmask"
+// L2 PROP_U32 2 = "amlogic,clrmask"
+// L2 PROP_STR 2 = "amlogic,pins"
+//		a_i2c_master:a_i2c{
+//			amlogic,setmask=<5 0xc0000000>;
+//			amlogic,clrmask=<9 0x58000 7 3000000>;
+//			amlogic,pins="GPIOZ_0","GPIOZ_1";
+
+//			amlogic,setmask=<5 0x300>;
+//			amlogic,clrmask=<6 0x900 8 11000>;
+//			amlogic,pins="GPIOZ_9","GPIOZ_10";
+
+//			amlogic,setmask=<5 0xc0>;
+//			amlogic,clrmask=<6 0xc0 8 0xc000>;
+//			amlogic,pins="GPIOZ_11","GPIOZ_12";
+//		};
+		
+//$$ MATCH "I2C_B_pin_match" = "&b_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		b_i2c_master:b_i2c{
+			amlogic,setmask=<5 0xc000000>;
+			amlogic,pins="GPIOZ_2","GPIOZ_3";
+		};
+
+// MATCH "I2C_C_pin_match" = "&c_i2c_master"
+// L2 PROP_U32 2 = "amlogic,setmask"
+// L2 PROP_U32 2 = "amlogic,clrmask"
+// L2 PROP_STR 2 = "amlogic,pins"		
+//		c_i2c_master:c_i2c{
+//			amlogic,setmask=<5 0x3000000>;
+//			amlogic,clrmask=<6 0xc000>;
+//			amlogic,pins="GPIOZ_4","GPIOZ_5";
+
+//			amlogic,setmask=<1 0xc000>;
+//			amlogic,clrmask=<1 0xc0400 3 0x6 9 0x300>;
+//			amlogic,pins="GPIOY_0","GPIOY_1";
+//		};
+
+//$$ MATCH "I2C_D_pin_match" = "&d_i2c_master"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		d_i2c_master:d_i2c{
+			amlogic,setmask=<4 0xc>;
+			amlogic,pins="GPIOH_7","GPIOH_8";
+		};
+
+//$$ MATCH "remote_pin_0_match" = "&remote_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_STR = "amlogic,pins"
+        	remote_pins:remote_pin{
+			amlogic,setmask=<10 0x1>;
+			amlogic,pins="GPIOAO_7";
+		};
+
+//$$ MATCH "Audio_pin_0_match" = "&audio_pins"
+//$$ L2 PROP_U32 6 = "amlogic,setmask"
+//$$ L2 PROP_U32 10 = "amlogic,clrmask"
+//$$ L2 PROP_STR 10 = "amlogic,pins"
+        audio_pins:audio_pin{
+            amlogic,setmask=<1 0x180
+                             1 0x75
+                             10 0x78000000>;
+            amlogic,clrmask=<1 0x30000
+                             1 0x0a
+                             3 0x40389
+                             4 0x3c00000
+                             9 0xd>;
+            amlogic,pins = "GPIOY_2","GPIOY_3","GPIOY_4","GPIOY_5","GPIOY_6","GPIOY_7","GPIOY_8","GPIOAO_8","GPIOAO_9","GPIOAO_10","GPIOAO_11";
+        };
+
+//$$ MATCH "Spi_pin_0_match" = "&aml_spi_nor_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 4 = "amlogic,pins"
+		aml_spi_nor_pins: aml_spi_nor_pins{
+			amlogic,setmask=<5 0xf>;
+			amlogic,clrmask=<2 0x380000>;
+			amlogic,pins = "BOOT_11","BOOT_12","BOOT_13","BOOT_18";
+		};
+
+	};
+/// ***************************************************************************************
+///	-	Ethernet
+//$$ MODULE="Ethernet"
+//$$ DEVICE="meson-eth"
+//$$ L2 PROP_STR = "status"
+    meson-eth{
+		compatible = "amlogic,meson-eth";
+		dev_name = "meson-eth";
+		status = "okay";
+		ethbaseaddr = <0xfe0c0000>;
+		interruptnum = <40>;
+	};
+
+}; /* end of / */
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index 5e24b077cccd..553420919bfd 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -226,8 +226,11 @@ CONFIG_FB_OSD2_DEFAULT_HEIGHT_VIRTUAL=32
 CONFIG_AM_FB_EXT=y
 CONFIG_AM_LOGO=y
 CONFIG_AM_HDMI_ONLY=y
+CONFIG_TVIN=y
+CONFIG_TVIN_VDIN=y
 CONFIG_VIUIN=y
 CONFIG_TVIN_ISP=y
+CONFIG_AML_SII9233=y
 CONFIG_POST_PROCESS_MANAGER=y
 CONFIG_POST_PROCESS_MANAGER_PPSCALER=y
 CONFIG_VIDEO_AMLOGIC_CAPTURE=y
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index c80f7cc4cd5d..50c5f6955178 100755
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -68,6 +68,7 @@ source "drivers/amlogic/canvas/Kconfig"
 source "drivers/amlogic/display/Kconfig"
 source "drivers/amlogic/hdmi/Kconfig"
 isource "../hardware/tvin/Kconfig"
+source "drivers/amlogic/ext_hdmiin/Kconfig"
 source "drivers/amlogic/ppmgr/Kconfig"
 source "drivers/amlogic/camera/Kconfig"
 source "drivers/amlogic/video_dev/Kconfig"
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 5a67b03f04ec..4fa32b04a772 100755
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -72,6 +72,8 @@ ifneq ($(wildcard $(srctree)/../hardware/tvin),)
 	obj-$(CONFIG_TVIN) += ../../../hardware/tvin/
 endif
 
+obj-$(CONFIG_AML_EXT_HDMIIN) += ext_hdmiin/
+
 obj-y += thermal/
 
 
diff --git a/drivers/amlogic/ext_hdmiin/Kconfig b/drivers/amlogic/ext_hdmiin/Kconfig
new file mode 100755
index 000000000000..6f58d8eed209
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/Kconfig
@@ -0,0 +1,17 @@
+#
+# Amlogic external hdmi-in chips configuration
+#
+
+menuconfig AML_EXT_HDMIIN
+	bool "External hdmi-in chips support"
+	default y
+
+if AML_EXT_HDMIIN
+config AML_SII9233
+	bool "SiliconImage 9233 support"
+	depends on AML_EXT_HDMIIN
+	default n
+
+source "drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Kconfig"
+
+endif # AML_EXT_HDMIIN
diff --git a/drivers/amlogic/ext_hdmiin/Makefile b/drivers/amlogic/ext_hdmiin/Makefile
new file mode 100755
index 000000000000..82ff8af8f1c2
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/Makefile
@@ -0,0 +1,6 @@
+#
+# Amlogic external hdmi-in chips Makefile
+#
+
+obj-$(CONFIG_AML_SII9233) += sii9233/
+obj-$(CONFIG_AML_SII9293) += sii9293/linux_driver/
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/Kconfig b/drivers/amlogic/ext_hdmiin/sii9233/Kconfig
new file mode 100755
index 000000000000..acd8064f89ee
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/Kconfig
@@ -0,0 +1,10 @@
+#
+#Hdmirx SiI9233A Device Driver Configuration
+#
+
+config TVIN_SII9233A
+    tristate "Amlogic SII9233A device driver" 
+    default  y
+    help
+         Amlogic SII9233A device driver.
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/Makefile b/drivers/amlogic/ext_hdmiin/sii9233/Makefile
new file mode 100755
index 000000000000..1d2b8d6dbf21
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/Makefile
@@ -0,0 +1,13 @@
+obj-$(CONFIG_AML_SII9233)		+= sii9233.o
+
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/
+
+sii9233-objs := sii9233_drv.o platform_interface.o sii9233_interface.o vdin_interface.o
+
+obj-$(CONFIG_AML_SII9233)	+= __sii9233/
+
+#EXTRA_CFLAGS += -O2
+
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/CEC.c b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/CEC.c
new file mode 100755
index 000000000000..9e8bcb8b3c39
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/CEC.c
@@ -0,0 +1,354 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2006, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+#include <local_types.h>
+#include <config.h>
+#include <registers.h>
+#include <hal.h>
+#include <amf.h>
+#include <CEC.h>  
+
+
+
+#define CEC_TX_AUTO_CALC_ENABLED
+
+//
+// Target System Note:  Recalibration frequency is system dependent.
+//
+unsigned int cec_recal_timer = 0;
+
+uint8_t bCECTask = 0;
+uint8_t InitiatorAddress = 0x0F;
+uint8_t bFollowerAddress = 0x0f;
+uint8_t bTXState = eSiI_TXWaitCmd;
+uint8_t bCECDev = SII_CEC_TV;
+uint8_t bEnumType;
+
+
+
+
+//------------------------------------------------------------------------------
+// Function Name: SiI_918x_Start
+// Function Description: Intilize Stream Switch Device
+// CEC Software Connection #1
+//------------------------------------------------------------------------------
+//void SiI_918x_Start( void )
+void CEC_Init( void )
+{
+
+//  uint8_t cec_phyAddr[2];
+#if(CONF__CEC_ENABLE == ENABLE)
+
+
+    DEBUG_PRINT(("\nStream switch start\n"));
+  //CEC workaround for ES0
+    GPIO_ClearCecD();
+    RegisterModify(REG__CEC_CONFIG_CPI,BIT__CEC_PASS_THROUGH,CLEAR);
+    if((RegisterRead(DEV_REV_RX)& 0x0F)==VAL__REV_1_2) //if rev1.2 CEC by default reset
+		RegisterModify(REG__C0_SRST2, BIT__CEC_SRST, SET); //0 is reset, 1 is normal
+    else
+		RegisterBitToggle(REG__C0_SRST2,BIT__CEC_SRST);
+
+
+    RegisterWrite(REG__SLAVE_ADDR_EDID,CONF__I2C_SLAVE_PAGE_9);
+    RegisterWrite(REG__SLAVE_ADDR_CEC,CONF__I2C_SLAVE_PAGE_8);
+
+
+      // Set CEC device type = TV and logical address to capture.
+     InitiatorAddress = CEC_LOGADDR_UNREGORBC_MSG ;
+     if( CEC_CAPTURE_ID_Set( InitiatorAddress ) )
+          {
+              DEBUG_PRINT(("\n Cannot init CEC"));
+          }
+	
+	  //
+	  // 4. Initialize Event Descriptor
+	  //
+	  CEC_event_descriptor_clear();
+	
+	  // Enumirate as an TV
+	  bCECTask  = SiI_CEC_Enumiration;
+	  bEnumType = SiI_EnumTV;
+
+#endif  // #if(CONF__CEC_ENABLE == ENABLE)
+
+      //====================
+      // 5. Program EDID and set port specific address space.
+      //    Program (a) EDID and (b) Physical address
+      //====================
+
+      ProgramEDID();
+
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function Name: SiI_CEC_SetSnoop
+// Function Description: This mode is used to listen a specified CEC address
+//                       Device doesn't acknowledge specified address
+// Accepts: uint8_t bSnoopAddr bool_t qOn
+// Returns: uint8_t (reports about I2C errors)
+// Globals: none
+//------------------------------------------------------------------------------
+#ifdef NOT_USED_NOW
+uint8_t SiI_CEC_SetSnoop ( uint8_t bSnoopAddr, bool_t qOn )
+{
+    uint8_t error = FALSE;
+
+    if ( qOn )
+    {
+		RegisterModify(REG__CEC_DEBUG_3,BIT_SNOOP_EN, BIT_SNOOP_EN);  
+        bSnoopAddr <<= 4;
+    }
+    else {
+		RegisterModify(REG__CEC_DEBUG_3, BIT_SNOOP_EN, CLEAR);
+        bSnoopAddr = 0;
+    }
+	RegisterWriteBlock(REG__CEC_DEBUG_2, &bSnoopAddr, 1);
+
+    return error;
+
+}
+#endif
+
+#if(CONF__CEC_ENABLE == ENABLE)
+//------------------------------------------------------------------------------
+// Function Name: SiI_9185_CEC_CAPTURE_ID_Set
+// Function Description:
+//
+// Accepts: uint8_t bInitLA
+// Returns: error code
+// Globals: none
+
+// Affected Register(s): CEC_CAPTURE_ID
+// Document Reference  : CEC Promgramming Interface (CPI) Programmer's Reference
+// Warning: Only a single CEC device can be select with this interface even though
+//          the all 16 devices can be selected.
+//------------------------------------------------------------------------------
+//
+uint8_t CEC_CAPTURE_ID_Set( uint8_t logical_address )
+{
+    uint8_t error = FALSE;
+    uint8_t capture_address[2];
+    uint8_t capture_addr_sel = 0x01;
+
+    capture_address[0] = 0;
+    capture_address[1] = 0;
+    if( logical_address < 8 )
+    {
+        capture_addr_sel = capture_addr_sel << logical_address;
+        capture_address[0] = capture_addr_sel;
+    }
+    else
+    {
+        capture_addr_sel   = capture_addr_sel << ( logical_address - 8 );
+        capture_address[1] = capture_addr_sel;
+    }
+
+    // Set Capture Address
+        RegisterWriteBlock(REG__CEC_CAPTURE_ID0,capture_address,2);
+        RegisterWrite(REG__CEC_TX_INIT, logical_address);
+
+    return 0;
+
+}
+
+//------------------------------------------------------------------------------
+// Function Name: SiI_CEC_SendPing
+// Function Description: This command intiate sending a ping, and used for checking available
+//                       CEC devices
+//
+// Accepts: bCECLogAddr
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+void SiI_CEC_SendPing ( uint8_t bCECLogAddr )
+{
+
+    RegisterWrite( REG__CEC_TX_INIT, BIT_SEND_POLL | bCECLogAddr );
+
+}
+
+//------------------------------------------------------------------------------
+// Function Name: SiI_CEC_SetCommand
+// Function Description: This command sets data for CEC transmission
+//
+// Accepts: pSiI_CEC
+// Returns: 1 if error; 0 if no error.
+// Globals: none
+//------------------------------------------------------------------------------
+
+
+uint8_t SiI_CEC_SetCommand( SiI_CEC_t * pSiI_CEC )
+{
+  uint8_t error = FALSE;
+  uint8_t cec_int_status_reg[2];
+  uint8_t sw_retry_counter = 0 ;
+
+  // Clear Tx Buffer
+  RegisterModify(REG__CEC_DEBUG_3, BIT_FLUSH_TX_FIFO, BIT_FLUSH_TX_FIFO);
+
+  DEBUG_PRINT(("\n TX: HDR[0x%02X],OPC[0x%02X],OPR[0x%02X, %02X, %02X]", (int)pSiI_CEC->bDestOrRXHeader, (int)pSiI_CEC->bOpcode, (int)pSiI_CEC->bOperand[0], (int)pSiI_CEC->bOperand[1], (int)pSiI_CEC->bOperand[2])) ;
+
+  #ifdef   CEC_TX_AUTO_CALC_ENABLED
+  //
+  // Enable TX_AUTO_CALC
+  //
+  RegisterWrite(REG__CEC_TRANSMIT_DATA, BIT__TX_AUTO_CALC);
+
+  #endif// CEC_TX_AUTO_CALC_ENABLED
+  //
+  // Clear Tx-related buffers; write 1 to bits to be clear directly; writing 0 has no effect on the status bit
+  //
+  cec_int_status_reg[0] = 0x64 ; // Clear Tx Transmit Buffer Full Bit, Tx msg Sent Event Bit, and Tx FIFO Empty Event Bit
+  cec_int_status_reg[1] = 0x02 ; // Clear Tx Frame Retranmit Count Exceeded Bit.
+  RegisterWriteBlock(REG__CEC_INT_STATUS_0, cec_int_status_reg, 2);
+
+  // Write Source and Destination address
+  RegisterWrite(REG__CEC_TX_DEST,pSiI_CEC->bDestOrRXHeader);
+
+  // Send CEC Opcode AND up to 15 Operands
+ RegisterWriteBlock( REG__CEC_TX_COMMAND, &pSiI_CEC->bOpcode, pSiI_CEC->bCount + 1);
+
+
+  if( error )
+  {
+      DEBUG_PRINT(("\n SiI_CEC_SetCommand(): Fail to write CEC opcode and operands\n")) ;
+  }
+
+  #ifndef CEC_TX_AUTO_CALC_ENABLED
+  //
+  // Write Operand count and activate send
+  //
+      RegisterWrite(REG__CEC_TRANSMIT_DATA, BIT_TRANSMIT_CMD | pSiI_CEC->bCount );
+  #endif // CEC_TX_AUTO_CALC_ENABLED
+
+    return error;
+
+}//e.o. uint8_t SiI_CEC_SetCommand( SiI_CEC_t * pSiI_CEC )
+
+//------------------------------------------------------------------------------
+// Function Name: SiI_CEC_GetCommand
+// Function Description: This function gets data from CEC Reception
+//
+// Accepts: pSiI_CEC
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+uint8_t SiI_CEC_GetCommand( SiI_CEC_t * pSiI_CEC )
+{
+    uint8_t error = FALSE;
+    uint8_t bCount;
+
+    bCount = pSiI_CEC->bCount  & 0x0f; // extract uint8_t counter, ignore frame counter
+
+    if ( !(pSiI_CEC->bCount & BIT_MSG_ERROR) )
+        RegisterReadBlock(REG__CEC_RX_CMD_HEADER, &pSiI_CEC->bDestOrRXHeader , bCount + 2);
+    else
+        error = 1;
+
+    // Clear CLR_RX_FIFO_CUR;
+    // Clear current frame from Rx FIFO
+    RegisterModify(REG__CEC_RX_CONTROL, BIT_CLR_RX_FIFO_CUR, BIT_CLR_RX_FIFO_CUR );
+
+    // Check if more frame in Rx FIFO, if yes get uint8_t count of next frame.
+    pSiI_CEC->bRXNextCount = 0;
+
+    if( pSiI_CEC->bCount & 0xF0 )
+    {
+        pSiI_CEC->bRXNextCount = RegisterRead(REG__CEC_RX_COUNT);
+    }
+
+    return error;
+}
+
+
+//------------------------------------------------------------------------------
+// Function Name: SiI_CEC_IntProcessing
+// Function Description: This function is called on interrupt events
+//                       it makes interrut service
+// Accepts: SiI_CEC_Int_t * pInt
+// Returns: none
+// Globals: none
+//------------------------------------------------------------------------------
+uint8_t CEC_IntProcessing ( SiI_CEC_Int_t * pInt )
+{
+    uint8_t error = FALSE;
+    uint8_t cec_int_status_reg[2];
+
+    // Get Interrupts
+    pInt->bTXState   = 0;
+    pInt->bCECErrors = 0;
+    pInt->bRXState   = 0;
+
+    RegisterReadBlock(REG__CEC_INT_STATUS_0,cec_int_status_reg,2);
+
+
+    {
+        // Poll Interrupt
+        if( (cec_int_status_reg[0] & 0x7F) || cec_int_status_reg[1] )
+        {
+           DEBUG_PRINT(("\nA6A7Reg: %02X %02X", (int) cec_int_status_reg[0], (int) cec_int_status_reg[1]));
+            // Clear interrupts
+            if ( cec_int_status_reg[1] & BIT_FRAME_RETRANSM_OV )
+            {
+               DEBUG_PRINT(("\n!CEC_A7_TX_RETRY_EXCEEDED![%02X][%02X]",(int) cec_int_status_reg[0], (int) cec_int_status_reg[1]));
+                // flash TX otherwise after writing clear interrupt
+                // BIT_FRAME_RETRANSM_OV the TX command will be re-send
+               RegisterModify(REG__CEC_DEBUG_3,BIT_FLUSH_TX_FIFO, BIT_FLUSH_TX_FIFO);
+            }
+            //
+            // Clear set bits that are set
+            //
+            RegisterWriteBlock(REG__CEC_INT_STATUS_0,cec_int_status_reg,2);
+
+            DEBUG_PRINT(("\nA6A7Reg: %02X %02X", (int) cec_int_status_reg[0], (int) cec_int_status_reg[1]));
+
+            // RX Processing
+            if ( cec_int_status_reg[0] & BIT_RX_MSG_RECEIVED )
+            {
+                // Save number of frames in Rx Buffer
+                pInt->bRXState = RegisterRead(REG__CEC_RX_COUNT);
+            }
+
+            // RX Errors processing
+            if ( cec_int_status_reg[1] & BIT_SHORT_PULSE_DET )
+            {
+                pInt->bCECErrors |= eSiI_CEC_ShortPulse;
+            }
+
+            if ( cec_int_status_reg[1] & BIT_START_IRREGULAR )
+            {
+                pInt->bCECErrors |= eSiI_CEC_StartIrregular;
+            }
+
+            if ( cec_int_status_reg[1] & BIT_RX_FIFO_OVERRUN ) // fixed per Uematsu san
+            {
+                pInt->bCECErrors |= eSiI_CEC_RXOverFlow;
+            }
+
+            // TX Processing
+            if ( cec_int_status_reg[0] & BIT_TX_FIFO_EMPTY )     //0x04
+            {
+                pInt->bTXState = eSiI_TXWaitCmd;
+            }
+            if ( cec_int_status_reg[0] & BIT_TX_MESSAGE_SENT )   //0x20
+            {
+                pInt->bTXState = eSiI_TXSendAcked;
+            }
+            if ( cec_int_status_reg[1] & BIT_FRAME_RETRANSM_OV )   //0x02
+            {
+
+                pInt->bTXState = eSiI_TXFailedToSend;
+            }
+        }
+    }
+    return error;
+}
+
+#endif //#if(CONF__CEC_ENABLE == ENABLE)
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/CEC.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/CEC.h
new file mode 100755
index 000000000000..2afaa446bb51
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/CEC.h
@@ -0,0 +1,295 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2006, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+#include <local_types.h>
+#include <config.h>
+#include <registers.h>
+#include <hal.h>
+#include <amf.h>
+#include <stdio.h>
+
+#ifndef _CEC_H_
+#define _CEC_H_
+typedef enum
+{
+
+    SiI_CEC_API_Version = 0x00,
+    SiI_CEC_API_Revision = 0x00,
+    SiI_CEC_API_Build = 0x01
+
+} eSiI_CEC_VerInfo_t;
+
+#define ON 1    // Turn ON
+#define OFF 0   // Turn OFF
+#define SII_MAX_CMD_SIZE 16 // defnes number of operands
+
+typedef enum
+{
+    SiI_CEC_LogAddr_TV          = 0x00,
+    SiI_CEC_LogAddr_RecDev1     = 0x01,
+    SiI_CEC_LogAddr_RecDev2     = 0x02,
+    SiI_CEC_LogAddr_STB1        = 0x03,
+    SiI_CEC_LogAddr_DVD1        = 0x04,
+    SiI_CEC_LogAddr_AudSys      = 0x05,
+    SiI_CEC_LogAddr_STB2        = 0x06,
+    SiI_CEC_LogAddr_STB3        = 0x07,
+    SiI_CEC_LogAddr_DVD2        = 0x08,
+    SiI_CEC_LogAddr_RecDev3     = 0x09,
+    SiI_CEC_LogAddr_Res1        = 0x0A,
+    SiI_CEC_LogAddr_Res2        = 0x0B,
+    SiI_CEC_LogAddr_Res3        = 0x0C,
+    SiI_CEC_LogAddr_Res4        = 0x0D,
+    SiI_CEC_LogAddr_FreeUse     = 0x0E,
+    CEC_LOGADDR_UNREGORBC_MSG   = 0x0F
+
+} ecSiI_CEC_LogAddr_t;
+
+#define CEC_PA_EDID_CH0      0x1000
+#define CEC_PA_EDID_CH1      0x2000
+#define CEC_PA_EDID_CH2      0x3000
+#define CEC_PA_EDID_CH3      0x4000
+
+
+typedef enum {
+
+    eSiI_UseOldDest = 0xFF
+
+} eSiI_TXCmdMod_t;
+
+
+typedef struct
+{
+    uint8_t bCount;
+    uint8_t bRXNextCount;
+    uint8_t bDestOrRXHeader;
+    uint8_t bOpcode;
+    uint8_t bOperand[ SII_MAX_CMD_SIZE ];
+
+} SiI_CEC_t;
+
+typedef enum {
+    eSiI_CEC_ShortPulse = 0x80,
+    eSiI_CEC_StartIrregular = 0x40,
+    eSiI_CEC_RXOverFlow = 0x20,
+} eSiI_CECErrors_t;
+
+typedef enum {
+    eSiI_TXWaitCmd,
+    eSiI_TXSending,
+    eSiI_TXSendAcked,
+    eSiI_TXFailedToSend
+} eSiI_TXState;
+
+typedef struct {
+
+    uint8_t bRXState;
+    uint8_t bTXState;
+    uint8_t bCECErrors;
+
+} SiI_CEC_Int_t;
+
+//uint8_t SiI_9185_CEC_CAPTURE_ID_Set( uint8_t );
+uint8_t CEC_CAPTURE_ID_Set( uint8_t );
+void SiI_CEC_SendPing ( uint8_t );
+uint8_t SiI_CEC_SetCommand( SiI_CEC_t * );
+uint8_t SiI_CEC_GetCommand( SiI_CEC_t * );
+//uint8_t SiI_CEC_IntProcessing ( SiI_CEC_Int_t * );
+uint8_t CEC_IntProcessing ( SiI_CEC_Int_t * );
+
+void CEC_Init( void );
+
+
+// debug functions
+
+uint8_t SiI_CEC_SetSnoop ( uint8_t , bool_t );
+
+
+// CEC_A6_TX_MSG_SENT_EVENT
+
+#define CEC_A6_TX_MSG_SENT_EVENT 0x20
+
+// CEC_A7_TX_RETRY_EXCEEDED_EVENT
+
+#define CEC_A7_TX_RETRY_EXCEEDED_EVENT 0x02
+extern uint8_t CECCalibration ( void ) ;
+
+
+//=============================================================================
+// C E C   M e s s a g e   I n f o r m a t i o n   L o o k  u p  T a b l e
+//=============================================================================
+/* Request Opcode */
+#define RP (8)
+/* Reply Opcode   */
+#define RQ (4)
+/* Direct Addressing Mode    */
+#define DA (2)
+/* Broadcast Addressing Mode */
+#define BC (1)
+
+typedef enum
+{
+  CEC_REQST_DA_E = (RQ | DA),
+  CEC_REQST_BC_E = (RQ | BC),
+  CEC_REQST_BOTH_DA_BC = (RQ | BC | DA),
+  CEC_REPLY_DA_E = (RP|DA),
+  CEC_REPLY_BC_E = (RP|DA),
+  CEC_REPLY_BOTH_DA_BC = (RP|DA|BC),
+  CEC_BOTH_REQ_DA_REP_DA = (RP|RQ|DA),
+  CEC_BOTH_REQ_BC_REP_BC = (RP|RQ|BC),
+  CEC_BOTH_REQ_REP_BOTH_DA_BC =(RP|RQ|DA|BC)
+} CEC_RX_MSG_TYPE_ET;
+
+typedef void (*CEC_MSG_HANDLER)( SiI_CEC_t * SiI_CEC );
+
+typedef struct
+{
+  uint8_t                  opcode ;
+  uint8_t                  num_operand ;
+  CEC_RX_MSG_TYPE_ET  msg_type ;
+  CEC_MSG_HANDLER     opcode_handler ;
+} LUT_CEC_MSG_INFO;
+
+typedef enum
+{
+  STATE_ON      =0x00,
+  STATE_STBY    =0x01,
+  STATE_STBY2ON =0x02,
+  STATE_ON2STBY =0x03,
+} POWER_STATUS_ET;
+
+//
+//  Used to collect events that will be executed by the Event Handler.
+//  Used in an array for deeper buffering.
+//
+typedef struct
+{
+  uint8_t  cec_event_id ;
+  uint8_t  param[5] ;
+  SiI_CEC_t * SiI_CEC ;
+} EVENT_DESCRIPTOR;
+
+typedef struct
+{
+  uint8_t                  cec_event_id ;
+  CEC_MSG_HANDLER     cec_event_handler ;
+} LUT_CEC_EVENT_HANDLER;
+
+// ====================================================
+//
+// !!!!!!!Order is very important!!!!!! Don't Touch !!!
+// !!Must be kept consistent with CEC_RX_REPLY_LUT[] !!
+//
+// =====================================================
+typedef enum
+{
+  CEC_EVT_ONE_TOUCH_PLAY = 0x00,
+  CEC_EVT_POWER_ON,
+  CEC_EVT_POWER_OFF,
+  //CEC_EVT_IR_REMOTE_KEY_PRESSED,
+  //CEC_EVT_HDMI_PLUG_DETECT,
+  //CEC_EVT_MSG_RECEIVED,
+  //CEC_EVT_MSG_WAITING_TO_BE_SENT,
+  CEC_EVT_LAST_EVENT,
+
+} CEC_EVENT_HANDLER_ID_ET;
+
+typedef enum
+{
+  DSCRPTR_EMPTY,  // Descriptor is available for use.
+  DSCRPTR_BUSY,   // Descriptor is taken and is being filled/updated.
+  DSCRPTR_FULL,   // Descriptor is taken and is full/ready for use.
+} DESCRIPTOR_STATUS;
+
+//
+//  CEC Event Descriptor
+//  is used for a task to communicate to the System Event Handler
+//  to look out for a specific CEC Opcode from a specific
+//  source Logical Address of the next frame received.
+//  Once there is a match, the Event Handler specified i.e. cec_event_hdlr_id,
+//  is call with the cec_event_next_state as a parameter.
+//  cec_event_next_state tells where the
+//
+//
+typedef struct
+{
+  DESCRIPTOR_STATUS       dscrptr_status;     // Used to provide the status of the descriptor.
+  CEC_EVENT_HANDLER_ID_ET event_hdlr_id ;     // EVENT ID, must be registered in CEC_EVENT_HANDLER_ID_ET.
+  uint8_t                      event_next_state;   // Next State of handler
+  uint8_t                      trgt_opcode ;       // Targeted Opcode
+  uint8_t                      trgt_source_addr ;  // Targeted Source Logical Address
+} CEC_EVENT_DESCRIPTOR;
+
+//void SiI_918x_Event_Handler( void );
+void CEC_Event_Handler( void );
+
+void CEC_event_descriptor_clear() ;
+
+extern uint8_t bCECSlvAddr;
+
+//
+// CEC Software Connection #3: Target System to provide local I2C Read function.
+//                        I.E. Replace hlReaduint8_t_8BA() with Target System's with own function.
+//
+#define SiI_918x_RegRead(DEVICE, ADDR) hlReaduint8_t_8BA( DEVICE, ADDR )
+
+//
+// CEC Software Connection #4: Target System to provide local I2C Write function.
+//                        I.E. Replace hlWriteuint8_t_8BA() with Target System with own function.
+//
+#define SiI_918x_RegWrite(DEVICE, ADDR, DATA) hlWriteuint8_t_8BA( DEVICE, ADDR, DATA )
+
+
+//
+// CEC Software Connection #6: Target System to provide local I2C Read function.
+//                        I.E. Replace SiI_918x_RegReadModWrite() with Target System's with own Read-Modify-Write function.
+//
+#define SiI_918x_RegReadModWrite( DEVICE, ADDR, MASK, DATA ) siiReadModWriteuint8_t ( DEVICE, ADDR, MASK, DATA )
+
+
+// CEC Globals
+
+typedef enum {
+
+    SII_CEC_TV,
+    SII_CEC_DVD,
+    SII_CEC_STB,
+    SII_CEC_SW
+
+} CECDev_t;
+
+typedef enum {
+
+    SiI_EnumTV,
+    SiI_EnumDVD
+
+} SiI_EnumType;
+
+typedef enum {
+
+    SiI_CEC_Idle,
+    SiI_CEC_ReqPing,
+    SiI_CEC_ReqCmd1,
+    SiI_CEC_ReqCmd2,
+    SiI_CEC_ReqCmd3,
+    SiI_CEC_Enumiration
+
+} SiI_CECOp_t;
+
+extern uint8_t bCECTask;
+extern uint8_t InitiatorAddress;
+extern uint8_t bFollowerAddress;
+extern uint8_t bTXState;
+extern uint8_t bCECDev;
+extern uint8_t bEnumType;
+
+#define UCEC_ACTIVE     0x82
+#define UCEC_STANDBY    0x36
+
+#endif // _SII_CEC_H_
+
+
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/Makefile b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/Makefile
new file mode 100755
index 000000000000..73fc87019123
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_AML_SII9233)		+= CEC.o
+
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/UCEC.c b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/UCEC.c
new file mode 100755
index 000000000000..635cdeed6f3d
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/UCEC.c
@@ -0,0 +1,722 @@
+//------------------------------------------------------------------------------
+// Copyright  2002-2005, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+// Turn down the warning level for this C file to prevent the compiler 
+// from complaining about the unused parameters in the stub functions below
+#pragma WARNINGLEVEL (1)
+
+#include <local_types.h>
+#include <config.h>
+#include <registers.h>
+#include <hal.h>
+#include <amf.h>
+#include <CEC.h>
+
+#if(CONF__CEC_ENABLE == ENABLE)
+
+
+//  Enable rejection of self-broadcast messages.
+//
+#define CEC_RX_OWN_BRCST_MSG_FIX
+//
+//  Enable CEC port switching
+//
+#define SI_SUPPORT_CEC_AUTO_PORT_SWITCHING
+
+static void CEC_EVT_HDLR_one_touch_play( SiI_CEC_t * sii_cec )
+{
+    //printf("\n CEC_EVT_HDLR_one_touch_play") ;
+}
+
+static void CEC_EVT_HDLR_power_on( SiI_CEC_t * sii_cec )
+{
+    //printf("\n CEC_EVT_HDLR_power_on") ;
+}
+
+static void CEC_EVT_HDLR_power_off( SiI_CEC_t * sii_cec )
+{
+    //printf("\n CEC_EVT_HDLR_power_off") ;
+}
+
+ROM const LUT_CEC_EVENT_HANDLER CEC_RX_REPLY_LUT[] =
+{
+  /*
+   ========================= ==========================
+      Task-Event               ID Task-Event Handler
+   ========================= ==========================   */
+  { CEC_EVT_ONE_TOUCH_PLAY,   CEC_EVT_HDLR_one_touch_play },
+  { CEC_EVT_POWER_ON,         CEC_EVT_HDLR_power_on       },
+  { CEC_EVT_POWER_OFF,        CEC_EVT_HDLR_power_off      }
+};
+
+static POWER_STATUS_ET TV_state = STATE_STBY ;
+//
+// cec_event_dscrptr sure be guarded using a semaphor or by disabling
+// interrupt prior to changing it's content and enabling interrupts
+//
+//
+static CEC_EVENT_DESCRIPTOR cec_event_dscrptr ;
+
+
+ROM const uint8_t abEnumTblTV[3]  = { 2, SiI_CEC_LogAddr_TV,   SiI_CEC_LogAddr_FreeUse };
+ROM const uint8_t abEnumTblDVD[4] = { 3, SiI_CEC_LogAddr_DVD1, SiI_CEC_LogAddr_DVD2, SiI_CEC_LogAddr_FreeUse };
+//------------------------------------------------------------------------------
+// Function Name:
+// Function Description:
+//------------------------------------------------------------------------------
+void PrintLogAddr ( uint8_t bLogAddr ){
+
+    if ( bLogAddr <= CEC_LOGADDR_UNREGORBC_MSG )
+    {
+        printf (" [%X] ", (int) bLogAddr );
+        switch ( bLogAddr )
+        {
+            case SiI_CEC_LogAddr_TV:        printf("TV");           break;
+            case SiI_CEC_LogAddr_RecDev1:   printf("RecDev1");      break;
+            case SiI_CEC_LogAddr_RecDev2:   printf("RecDev2");      break;
+            case SiI_CEC_LogAddr_STB1:      printf("STB1");         break;
+            case SiI_CEC_LogAddr_DVD1:      printf("DVD1");         break;
+            case SiI_CEC_LogAddr_AudSys:    printf("AudSys");       break;
+            case SiI_CEC_LogAddr_STB2:      printf("STB2");         break;
+            case SiI_CEC_LogAddr_STB3:      printf("STB3");         break;
+            case SiI_CEC_LogAddr_DVD2:      printf("DVD2");         break;
+            case SiI_CEC_LogAddr_RecDev3:   printf("RecDev3");      break;
+            case SiI_CEC_LogAddr_Res1:      printf("Res1");         break;
+            case SiI_CEC_LogAddr_Res2:      printf("Res2");         break;
+            case SiI_CEC_LogAddr_Res3:      printf("Res3");         break;
+            case SiI_CEC_LogAddr_Res4:      printf("Res4");         break;
+            case SiI_CEC_LogAddr_FreeUse:   printf("FreeUse");      break;
+            case CEC_LOGADDR_UNREGORBC_MSG: printf("UnregOrBC_MSG");    break;
+        }
+    }
+}
+//------------------------------------------------------------------------------
+// Function Name: PrintCommand
+// Function Description:
+//------------------------------------------------------------------------------
+static void PrintCommand( SiI_CEC_t * SiI_CEC )
+{
+    uint8_t i;
+    printf ("\n [FROM][TO][OPCODE]{OPERANDS}: ");
+    PrintLogAddr( (SiI_CEC->bDestOrRXHeader & 0xF0) >> 4 );
+    PrintLogAddr( SiI_CEC->bDestOrRXHeader & 0x0F );
+    printf (" [%02X]", (int) SiI_CEC->bOpcode);
+    if ( SiI_CEC->bCount & 0x0F)
+    {
+        //printf("\n Operands: ");
+        for ( i = 0; i < ( SiI_CEC->bCount & 0x0F); i++ )
+            printf (" {%02X}", (int) SiI_CEC->bOperand[i]);
+    }
+    printf ("\n");
+}
+
+//
+//  Sets the
+//
+//
+#ifdef NOT_USED_NOW
+uint8_t CEC_event_descriptor_set( CEC_EVENT_DESCRIPTOR *p_new_event )
+{
+  //
+  // System Implementation Note:
+  // recommend semaphor be used to guard event descriptor.
+  //
+  cec_event_dscrptr.dscrptr_status    = DSCRPTR_BUSY ;
+  cec_event_dscrptr.event_hdlr_id     = p_new_event->event_hdlr_id ;
+  cec_event_dscrptr.event_next_state  = p_new_event->event_next_state ;
+  cec_event_dscrptr.trgt_opcode       = p_new_event->trgt_opcode ;
+  cec_event_dscrptr.trgt_source_addr  = p_new_event->trgt_source_addr ;
+  cec_event_dscrptr.dscrptr_status    = DSCRPTR_FULL ;
+  return 0 ;
+
+}//e.o. uint8_t CEC_event_descriptor_set( CEC_EVENT_DESCRIPTOR *p_cec_evt_dscrptr )
+#endif
+
+//
+// Clear the Event Descriptor regardless
+//
+void CEC_event_descriptor_clear()
+{
+  //System Implementation Note:
+  //recommend semaphor be used to guard event descriptor when being updated.
+  //
+  cec_event_dscrptr.dscrptr_status    = DSCRPTR_EMPTY ;
+
+}//e.o. uint8_t CEC_event_descriptor_set( CEC_EVENT_DESCRIPTOR *p_cec_evt_dscrptr )
+
+//
+// HDMI CEC Auto Port Switching Related Code
+//
+static void cecAutoPortSwitch( SiI_CEC_t * SiI_CEC )
+{
+    static uint8_t currentActiveSource=0, old_ActiveSource=0;
+    static uint8_t currentActiveLA=0, old_ActiveLA=0 ; // Logical Address (LA)
+    uint16_t physicalAddr ;
+
+    if( SiI_CEC->bOpcode == 0x82 )
+    {
+        // Save the old Active device info
+        old_ActiveSource = currentActiveSource ;
+        old_ActiveLA     = currentActiveLA     ;
+        currentActiveLA = (SiI_CEC->bDestOrRXHeader & 0xF0) >> 4 ;
+
+        physicalAddr = ((uint16_t)SiI_CEC->bOperand[0] << 8 ) | SiI_CEC->bOperand[1] ;
+        // Check initiator physical address
+        switch( physicalAddr )
+        {
+            case CEC_PA_EDID_CH0:
+                //printf("\n  Active Source => HDMI Port0\n");
+                // Switch to HDMI Port0
+                // update current active source
+                currentActiveSource = PORT_SELECT__PORT_0 ;
+                break;
+
+            case CEC_PA_EDID_CH1:
+                //printf("\n  Active Source => HDMI Port1\n");
+                // Switch to HDMI Port1
+                currentActiveSource = PORT_SELECT__PORT_1 ;
+                break;
+
+            case CEC_PA_EDID_CH2:
+                //printf("\n  Active Source => HDMI Port2\n");
+                // Switch to HDMI Port2
+                currentActiveSource = PORT_SELECT__PORT_2 ;
+                break;
+
+            case CEC_PA_EDID_CH3:
+                //printf("\n  Active Source => HDMI Port3\n");
+                // Switch to HDMI Port2
+                currentActiveSource = PORT_SELECT__PORT_3 ;
+                break;
+
+
+            default:
+                //printf("\n Unregistered Active Source whose PhysicalAddress=0x%X", physicalAddr) ;
+                currentActiveSource = PORT_SELECT__PORT_0 ;
+                //printf("\n  Active Source => HDMI Port2\n");
+        }
+        //
+        // Actuate the port switching to selected current active port.
+        //
+        if( currentActiveSource != old_ActiveSource )
+        {
+            SiI_CEC_t SiI_CEC;
+            // stop play at the current active logical address device
+            #define DECK_CONTROL 0x42              // Operand is Deck Control Mode
+            SiI_CEC.bOpcode     = DECK_CONTROL ;
+            SiI_CEC.bOperand[0] = 0x3 ;            // Stop
+            SiI_CEC.bCount      = 1;               //number of Operands
+            SiI_CEC.bDestOrRXHeader = 0x0 | ( old_ActiveLA&0xF ) ; //[initiator=0x00][follower=0x2]
+            SiI_CEC_SetCommand( &SiI_CEC );
+            //printf ("\n Sending DECK_CONTROL opcode \n");
+        }
+
+
+	 if(CurrentStatus.PortSelection !=  currentActiveSource)
+     {
+		 CurrentStatus.PortSelection =  currentActiveSource;
+	     SystemDataReset();
+	 }
+	}
+}
+
+static void CEC_HDLR_ff_Abort( SiI_CEC_t * sii_cec )
+{
+    SiI_CEC_t cec_frame;
+    //printf("\n <abort> rcvd; send out feature abort");
+    //
+    // Unsupported opcode; send f e a t u r e   a b o r t
+    //
+    cec_frame.bOpcode         = 0x00;
+    cec_frame.bDestOrRXHeader = (sii_cec->bDestOrRXHeader & 0xf0) >> 4 ;
+    cec_frame.bOperand[0]     = 0xff;
+    cec_frame.bOperand[1]     = 0;
+    cec_frame.bCount          = 2;
+    SiI_CEC_SetCommand( &cec_frame );
+}
+
+static void CEC_HDLR_00_FeatureAbort( SiI_CEC_t * sii_cec )
+{
+    //printf("\n CEC_HDLR_00_FeatureAbort") ;
+}
+
+static void CEC_HDLR_8f_giveDevicePowerStatus( SiI_CEC_t * sii_cec )
+{
+    // send reply indicating that power is on
+    // printf("\n CEC_HDLR_8f_giveDevicePowerStatus") ;
+
+}
+
+static void CEC_HDLR_90_reportPowerStatus( SiI_CEC_t * sii_cec )
+{
+    // Use power status info in FeatureFSM
+    //printf("\n CEC_HDLR_90_reportPowerStatus") ;
+
+}
+
+static void CEC_HDLR_82_ActiveSource( SiI_CEC_t * sii_cec )
+{
+    //printf("\n CEC_HDLR_82_ActiveSource ");
+    #ifdef SI_SUPPORT_CEC_AUTO_PORT_SWITCHING
+    cecAutoPortSwitch( sii_cec ) ;
+    #endif // SI_SUPPORT_CEC_AUTO_PORT_SWITCHING
+}
+
+static void CEC_HDLR_04_ImageViewOn( SiI_CEC_t * sii_cec )
+{
+    //printf("\n CEC_HDLR_04_ImageViewOn ");
+    TV_state = STATE_ON ;
+}
+
+static void CEC_HDLR_0d_TextViewOn( SiI_CEC_t * sii_cec )
+{
+    //printf("\n CEC_HDLR_0d_TextViewOn ");
+    TV_state = STATE_ON ;
+}
+
+static void CEC_HDLR_85_RequestActiveSource( SiI_CEC_t * sii_cec )
+{
+    //printf("\n CEC_HDLR_85_RequestActiveSource");
+}
+
+static void CEC_HDLR_36_Standby( SiI_CEC_t * sii_cec )
+{
+    //printf("\n CEC_HDLR_36_Standby");
+    TV_state = STATE_STBY ;
+}
+
+static void CEC_HDLR_83_GivePhysicalAddr( SiI_CEC_t * sii_cec )
+{
+    SiI_CEC_t cec_frame;
+    //printf("\n CEC_HDLR_83_GivePhysicalAddr");
+    //
+    // Transmit Physical Address: 0.0.0.0
+    //
+    cec_frame.bOpcode         = 0x84;
+    cec_frame.bDestOrRXHeader = 0x0F ;
+    cec_frame.bOperand[0]     = 0x00 ; // [Physical Address]
+    cec_frame.bOperand[1]     = 0x00 ; // [Physical Address]
+    cec_frame.bOperand[2]     = 0x00 ; // [Device Type] = 0 = TV
+    cec_frame.bCount          = 3 ;
+    SiI_CEC_SetCommand( &cec_frame ) ;
+}
+
+static void CEC_HDLR_91_GetMenuLanguage( SiI_CEC_t * SiI_CEC )
+{
+    SiI_CEC_t cec_frame;
+    //printf("\n 91op");
+
+    // Send Set Menu Language
+    cec_frame.bOpcode         = 0x32;
+    cec_frame.bDestOrRXHeader = 0x0F ;
+    //
+    // Target System Specific
+    // - Set own language own according to specific system.
+    //
+    cec_frame.bOperand[0]     = 0x01 ; // [language code see iso/fdis 639-2]
+    cec_frame.bOperand[1]     = 0x02 ; // [language code see iso/fdis 639-2]
+    cec_frame.bOperand[2]     = 0x03 ; // [language code see iso/fdis 639-2]
+    cec_frame.bCount          = 3 ;
+    SiI_CEC_SetCommand( &cec_frame ) ;
+}
+
+static void CEC_HDLR_32_SetMenuLanguage( SiI_CEC_t * SiI_CEC )
+{
+  // Message valid only if it's sent by a TV.
+  // Therefore don't not need to process as a TV even though
+  // it's TV is also a switch since it has two or more hdmi ports.
+  //
+  //printf("\n CEC_HDLR_32_SetMenuLanguage");
+}
+
+static void CEC_HDLR_84_ReportPhysicalAddr( SiI_CEC_t * SiI_CEC )
+{
+  // REPLY to Get Physical Address 0x83
+  // Process mostly likely thru CEC Task Handler (CTH).
+  //printf("\n CEC_HDLR_84_ReportPhysicalAddr");
+}
+
+static void CEC_HDLR_80_RoutingChange( SiI_CEC_t * SiI_CEC )
+{
+  //printf("\n 80");
+}
+
+static void CEC_HDLR_86_SetStreamPath( SiI_CEC_t * SiI_CEC )
+{
+  //printf("\n 86");
+}
+
+static void CEC_HDLR_81_RoutingInformation( SiI_CEC_t * SiI_CEC )
+{
+  //printf("\n 81");
+}
+
+ROM const LUT_CEC_MSG_INFO CEC_RX_MSG_LUT[] =
+{
+  /*
+   ====== ========  ===============         ==========================
+   opcode #operand   MessageType            Message/Opcode Handler
+   ====== ========  ===============         ==========================   */
+  {0x8f,    0,      CEC_REQST_DA_E,         CEC_HDLR_8f_giveDevicePowerStatus   }, // <Give Device Power Status>
+  {0x90,    1,      CEC_REPLY_DA_E,         CEC_HDLR_90_reportPowerStatus   }, // <Report Power Status>[Power Status]
+
+  {0xFF,    0,      CEC_REQST_DA_E,         CEC_HDLR_ff_Abort                   }, // <Abort>
+  {0x00,    2,      CEC_REPLY_DA_E,         CEC_HDLR_00_FeatureAbort            }, // <Feature Abort>[Feature Opcode][Abort Reason]
+
+  {0x85,    0,      CEC_REQST_BC_E,         CEC_HDLR_85_RequestActiveSource     }, // <Request Active Source>
+  {0x82,    1,      CEC_BOTH_REQ_BC_REP_BC, CEC_HDLR_82_ActiveSource            }, // <Active Source>[Physical Address]
+
+  {0x04,    0,      CEC_REQST_DA_E,         CEC_HDLR_04_ImageViewOn             }, // <Image View On>
+  {0x0d,    0,      CEC_REQST_DA_E,         CEC_HDLR_0d_TextViewOn              }, // <Text View On>
+
+  {0x36,    0,      CEC_REQST_BOTH_DA_BC,   CEC_HDLR_36_Standby                 }, // <Standby>
+
+  {0x91,    0,      CEC_REQST_DA_E,         CEC_HDLR_91_GetMenuLanguage         }, // <Get Menu Language>
+  {0x32,    1,      CEC_BOTH_REQ_BC_REP_BC, CEC_HDLR_32_SetMenuLanguage         }, // <Get Menu Language>
+
+  {0x80,    4,      CEC_REQST_BC_E,         CEC_HDLR_80_RoutingChange           }, // <Routing Change>
+  {0x86,    2,      CEC_REQST_BC_E,         CEC_HDLR_86_SetStreamPath           }, // <Set Stream Path>
+  {0x81,    2,      CEC_REQST_BC_E,         CEC_HDLR_81_RoutingInformation      }, // <Routing Information>
+
+  {0x83,    0,      CEC_REQST_DA_E,         CEC_HDLR_83_GivePhysicalAddr        }, // <Give Physical Address  >
+  {0x84,    3,      CEC_BOTH_REQ_BC_REP_BC, CEC_HDLR_84_ReportPhysicalAddr      }  // <Report Physical Address>
+};
+
+//
+// return 0 if msg is 0K
+// return 1 if msg is 1nva1id
+//
+static uint8_t s6_cec_msg_validate( SiI_CEC_t * sii_cec )
+{
+    uint8_t i=0 ;
+    SiI_CEC_t cec_frame;
+    uint8_t num_of_msg_entries = sizeof(CEC_RX_MSG_LUT)/sizeof(LUT_CEC_MSG_INFO);
+    //
+    // 1. Check if msg is supported
+    // 2. Check if msg meets operand requirements.  Min & Max[protocol extension].
+    //
+    for( i=0; i<num_of_msg_entries; i++ )
+    {
+        if( sii_cec->bOpcode == CEC_RX_MSG_LUT[i].opcode )
+        {
+            //2. check operand
+            if( (sii_cec->bCount & 0x0F) >= CEC_RX_MSG_LUT[i].num_operand )
+            {
+              //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+              // Enforce CEC broadcast and direct addressing requirements:
+              //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+              if( (( (sii_cec->bDestOrRXHeader & 0x0F) == 0x0F && CEC_RX_MSG_LUT[i].msg_type & (uint8_t)BC ) ||
+                   ( (sii_cec->bDestOrRXHeader & 0x0F) != 0x0F && CEC_RX_MSG_LUT[i].msg_type & (uint8_t)DA )   ) &&
+                  ( (sii_cec->bDestOrRXHeader & 0xF0) != 0xF0 ) // Filter invalid source address of 0xF //
+                  #ifdef CEC_RX_OWN_BRCST_MSG_FIX
+                  && (sii_cec->bDestOrRXHeader != 0x0F ) // Reject self-broadcast msgs;0x0F-Header-Broadcast Issue
+                  #endif // CEC_RX_OWN_BRCST_MSG_FIX
+                )
+              {
+                if( (sii_cec->bDestOrRXHeader & 0xF0) == 0xF0 )
+                {
+                  // Filter invalid source address of 0xF
+                  // CEC 12.2 Protocol General Rules
+                  // A follower shall ignore a message coming from address 15 (unregistered), unless:
+                  //   that message invokes a broadcast response (e.g. <Get Menu Language>), or,
+                  //   the message has been sent by a CEC Switch (a <Routing Change> or <Routing Information>
+                  //    message), or,
+                  //   the message is <standby>.
+                  if( sii_cec->bOpcode != 0x36 && sii_cec->bOpcode != 0x80 &&
+                      sii_cec->bOpcode != 0x81 && sii_cec->bOpcode == 0x91 &&
+                      sii_cec->bOpcode == 0x83 )
+                      {
+                        return 1;
+                      }
+                }
+
+                //
+                // !!!Merge Cec Task Handler (CTH) here!!!!
+                //
+                // <         Path One             >
+
+                //
+                // Got valid frame; call the assigned handler as described in the CEC Rx Message Look-up Table
+                //
+                // <         Path Two             >
+                (*(CEC_RX_MSG_LUT[i].opcode_handler))( sii_cec ) ;
+                return 0 ;
+              }
+              else
+              {
+                // Error; incorrect addressing mode; msg/frame ignored.
+                printf("\n AddressingModeError.MsgIgnored[%02x]", (int)CEC_RX_MSG_LUT[i].msg_type ) ;
+                return 0 ;
+              }
+            }
+            else
+            {
+                printf("\n!Error!TooFewOperand!%X,%X,%X", CEC_RX_MSG_LUT[i].opcode, sii_cec->bCount, CEC_RX_MSG_LUT[i].num_operand ) ;
+                return 1 ;
+            }
+        }
+
+    }//e.o. for( i=0; i<num_of_msg_entries; i++ )
+
+    //
+    // Do not reply to Broadcast msgs, otherwise send Feature Abort
+    // for all unsupported features.
+    //
+    if( (sii_cec->bDestOrRXHeader & 0x0F) != 0x0F
+      #ifdef CEC_RX_OWN_BRCST_MSG_FIX
+      && (sii_cec->bDestOrRXHeader != 0x0F ) // Workaround for 0x0F-Header-Broadcast Issue
+      #endif // CEC_RX_OWN_BRCST_MSG_FIX
+      )
+    {
+      //
+      // Unsupported opcode; send f e a t u r e   a b o r t
+      //
+      cec_frame.bOpcode = 0x00;
+      cec_frame.bDestOrRXHeader = (sii_cec->bDestOrRXHeader & 0xf0) >> 4 ;
+      cec_frame.bOperand[0] = sii_cec->bOpcode;
+      cec_frame.bOperand[1] = 0;
+      cec_frame.bCount = 2;
+      SiI_CEC_SetCommand( &cec_frame );
+      printf("\n!UnsupportedFeature!");
+    }
+    else
+    {
+      //
+      // Unsupported Broadcast Msg
+      //
+      printf("\n!UnsupportedBcMsg!");
+    }
+
+    return 1 ;
+
+}//e.o. static void s6_cec_msg_validate( SiI_CEC_t * SiI_CEC )
+
+
+//------------------------------------------------------------------------------
+// Function Name: ParsingReceivedData
+//
+// Function Description:
+// 1. CEC7.3 Frame Validation
+// 2. Protocol Extension
+// 3. CEC12.3 Feature Abort
+// 4. Amber Alert i.e. call to function specified by the handler that is expecting
+//    a reply from the specified device, LA, LogicalAddress.
+//------------------------------------------------------------------------------
+static void s6_ParsingRecevedData ( uint8_t bRXState )
+{
+    uint8_t bAuxData;
+    uint8_t i;
+    SiI_CEC_t SiI_CEC ;
+
+    //
+    // CEC_RX_COUNT Register:  RX_ERROR | CEC_RX_CMD_CNT | CEC_RX_uint8_t_CNT
+    // See CPI document for details.
+    //
+    bAuxData = bRXState & 0xF0;
+    if( bAuxData )
+    {
+        SiI_CEC.bCount = bRXState;
+        bAuxData >>=4;
+        printf ("\n %i frames in Rx Fifo ", (int) bAuxData );
+
+
+        for ( i = 0; i < bAuxData; i++ )
+        {
+            SiI_CEC_GetCommand( &SiI_CEC );
+
+            PrintCommand( &SiI_CEC );
+            // Check BC msg && init==0x00
+            // Validation Message
+            s6_cec_msg_validate( &SiI_CEC );
+
+            if ( SiI_CEC.bRXNextCount)
+                SiI_CEC.bCount = SiI_CEC.bRXNextCount;
+        }
+    }
+}
+//------------------------------------------------------------------------------
+// Function Name: GetEnumLTbl()
+// Function Description:  This function gets lodical adress from enumiration tables
+//------------------------------------------------------------------------------
+uint8_t GetEnumTbl ( uint8_t i )
+{
+    uint8_t bEnumTbl;
+
+    if( bEnumType == SiI_EnumTV )
+    {
+        bEnumTbl = abEnumTblTV[i];
+    }
+    else
+    {
+        bEnumTbl = abEnumTblDVD[i];
+    }
+
+    return bEnumTbl;
+}
+
+#endif //#if(CONF__CEC_ENABLE == ENABLE)
+//------------------------------------------------------------------------------
+// Function Name: userSWTtask
+// Function Description:
+// This is function handler event from the CEC RX buffer.
+// CEC Software Connection #5.
+//------------------------------------------------------------------------------
+//void SiI_918x_Event_Handler( void )
+void CEC_Event_Handler( void )
+{
+#if(CONF__CEC_ENABLE == ENABLE)
+    static uint8_t i = 0;
+    static uint8_t bNewTask = SiI_CEC_Idle;
+    SiI_CEC_Int_t CEC_Int;
+    SiI_CEC_t SiI_CEC ;
+
+    if( bNewTask != bCECTask )
+    {
+        bNewTask = bCECTask;
+        i = 0;
+    }
+
+    //
+    // Process CEC Events; at this point doesn't do much
+    //
+//    SiI_CEC_IntProcessing( &CEC_Int );
+        CEC_IntProcessing(&CEC_Int);
+
+    //===============================
+    // Begin: 8051 Platform Specific
+    //===============================
+    // Process CP981x Board Functions e.g. buttons, test functions
+    //
+    if( bCECTask == SiI_CEC_ReqPing )
+    {
+      //
+      // Test function 1: Ping Button Pressed
+      //
+      if( bTXState == eSiI_TXWaitCmd )
+      {
+          printf("\n %X", (int)i );
+          SiI_CEC_SendPing( i );
+
+          bTXState = eSiI_TXSending;
+      }
+      else if(bTXState == eSiI_TXSending )
+      {
+          if( CEC_Int.bTXState == eSiI_TXFailedToSend )
+          {
+              printf (" NoAck ");
+              PrintLogAddr(i);
+              i++;
+              bTXState = eSiI_TXWaitCmd;
+          }
+          if( CEC_Int.bTXState == eSiI_TXSendAcked ){
+              printf (" Ack "); PrintLogAddr(i);
+              i++;
+              bTXState = eSiI_TXWaitCmd;
+          }
+          if( i >= CEC_LOGADDR_UNREGORBC_MSG ){
+              bCECTask = SiI_CEC_Idle;
+              i = 0;
+          }
+      }
+    }
+    else if( (bCECTask == SiI_CEC_ReqCmd2) || (bCECTask == SiI_CEC_ReqCmd3) )
+    {
+      //
+      //  Test function 2: Send test message
+      //
+      if ( CEC_Int.bTXState == eSiI_TXFailedToSend )
+      {
+          printf (" NoAck ");
+          bTXState = eSiI_TXWaitCmd;
+          bCECTask = SiI_CEC_Idle;
+      }
+      if ( CEC_Int.bTXState == eSiI_TXSendAcked )
+      {
+          printf (" Ack ");
+          bTXState = eSiI_TXWaitCmd;
+          bCECTask = SiI_CEC_Idle;
+      }
+    }
+    else if ( bCECTask == SiI_CEC_Enumiration )
+    {
+      //
+      //  Test function 3:  Enumerate CEC device Logical Address
+      //  For TV 1st choice is Logical Address 0, but if 0 is taken
+      //  0x0E is tried.
+      //  a. Ping logical address 0. If no ACK received then 0 is
+      //     not taken and 0 is assigned to the device.
+      //  b. If 0 is taken, 0x0E is tried.  see abEnumTblTV[] also.
+      //  c. If 0 and 0x0E are taken, 0x0F is assigned.
+      //
+      if ( bTXState == eSiI_TXWaitCmd )
+      {
+          // a. Ping 0, 0x0E
+          SiI_CEC_SendPing ( GetEnumTbl(i + 1) );
+          printf ("\n ping %02X", (int) GetEnumTbl(i + 1));
+          bTXState = eSiI_TXSending;
+      }
+      else if (bTXState == eSiI_TXSending )
+      {
+
+          if ( CEC_Int.bTXState == eSiI_TXFailedToSend )
+          {
+            //
+            // b. No ACK received, i.e. address available: take it.
+            //
+            printf (" NoAck "); PrintLogAddr( GetEnumTbl(i + 1) );
+            InitiatorAddress = GetEnumTbl(i + 1);
+            //
+            // Set Capture address
+            //
+            CEC_CAPTURE_ID_Set( InitiatorAddress );
+            printf ("\n Intiator address is ");
+            PrintLogAddr ( InitiatorAddress );
+            //
+            // Restore Tx State to IDLE i.e. eSiI_TXWaitCmd, wait for new Tx command.
+            //
+            bTXState = eSiI_TXWaitCmd;
+            bCECTask = SiI_CEC_Idle;
+          }
+          else if ( CEC_Int.bTXState == eSiI_TXSendAcked )
+          {
+            //
+            // c. ACK received i.e. address taken; try the next choice or use 0x0F, CEC_LOGADDR_UNREGORBC_MSG.
+            //
+            printf (" Ack "); PrintLogAddr( GetEnumTbl( i + 1) );
+            if ( i >= GetEnumTbl( 0 ) )
+            {
+                i = 0;
+                bCECTask = SiI_CEC_Idle;
+                printf ("Assign log addr: UnregOrBC_MSG");
+                InitiatorAddress = CEC_LOGADDR_UNREGORBC_MSG;
+                CEC_CAPTURE_ID_Set( InitiatorAddress );
+            }
+            else
+                i++;
+            bTXState = eSiI_TXWaitCmd;
+          }
+      }
+    }//e.o. else if ( bCECTask == SiI_CEC_Enumiration )
+    //===============================
+    // End: 8051 Platform Specific
+    //===============================
+
+    //
+    // Check for incoming CEC frames in the Rx Fifo.
+    //
+    //
+    if( CEC_Int.bRXState )
+    {
+        s6_ParsingRecevedData( CEC_Int.bRXState );
+    }
+
+#endif	//#if(CONF__CEC_ENABLE == ENABLE)
+}//e.o. void SiI_918x_Event_Handler( void )
+
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/EDID.c b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/EDID.c
new file mode 100755
index 000000000000..0f5b93351ffe
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/EDID.c
@@ -0,0 +1,199 @@
+//------------------------------------------------------------------------------
+// Copyright  2002-2005, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+/***********************************************************************************/
+/* Module Name:  UEDIDTbl.c                                                        */
+/*                                                                                 */
+/* Module Description: Contains EDID table which will be copyed into Stream Switch */
+/*                     Channel 0                                                   */
+/***********************************************************************************/
+#include <local_types.h>
+#include <config.h>
+#include <hal.h>
+#include <registers.h>
+#include <amf.h>
+#include <EDID.h>
+#include <CEC.h>  
+
+
+//supports 24Hz, HBR, 1080P
+ROM const uint8_t abEDIDTabl [ 256 ] = {
+
+/*  00    01    02   03     04    05    06    07   08     09    0A    0B    0C    0D    0E   0F */
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x4D, 0x29, 0x23, 0x92, 0x01, 0x00, 0x00, 0x00,
+	0x00, 0x12, 0x01, 0x03, 0x80, 0x00, 0x00, 0x78, 0x0A, 0x0D, 0xC9, 0xA0, 0x57, 0x47, 0x98, 0x27,
+	0x12, 0x48, 0x4C, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
+	0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20,
+	0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x43,
+	0x50, 0x39, 0x32, 0x32, 0x33, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
+	0x00, 0x17, 0x78, 0x0F, 0x7E, 0x17, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x66,
+	
+	0x02, 0x03, 0x3D, 0x72, 0x55, 0x90, 0x04, 0x03, 0x02, 0x0E, 0x0F, 0x07, 0x23, 0x24, 0x05, 0x94,
+	0x13, 0x12, 0x11, 0x1D, 0x1E, 0xA0, 0xA1, 0xA2, 0x01, 0x1F, 0x35, 0x09, 0x7F, 0x07, 0x09, 0x7F,
+	0x07, 0x17, 0x07, 0x50, 0x3F, 0x06, 0xC0, 0x57, 0x06, 0x00, 0x5F, 0x7F, 0x01, 0x67, 0x1F, 0x00,
+	0x83, 0x4F, 0x00, 0x00, 0x68, 0x03, 0x0C, 0x00, 0x10, 0x00, 0xB8, 0x2D, 0x00, 0x8C, 0x0A, 0xD0,
+	0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x18, 0x8C,
+	0x0A, 0xD0, 0x90, 0x20, 0x40, 0x31, 0x20, 0x0C, 0x40, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
+	0x18, 0x01, 0x1D, 0x80, 0x18, 0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21,
+	0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E
+
+
+};
+
+
+
+
+ROM const uint8_t abEXTRATabl	 [ 32 ] = {
+0xAA, 0x55, 0x04, 0x0F, 0x0F, 0x00, 0x00, 0x00,      //0 -7
+0x00, 0x00, 0xB8, 0x00, 0x10, 0x00, 0x20, 0x00,      //8 - f
+0x30, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,      //10 - 17 
+0x00, 0x00, 0x00, 0x00, 0x7E, 0x6E, 0x5E, 0x4E	     //18 -1F										    
+};
+
+
+ROM const uint8_t abEXTRATabl9127 [ 32 ] = {
+0xAA, 0x55, 0x04, 0x0F, 0x0F, 0x00, 0x00, 0x00,      //0 -7
+0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x10, 0x00,      //8 - f
+0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      //10 - 17 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x6E, 0x00	     //18 -1F										    
+};
+
+ROM const uint8_t physicalAddr[4] = {(CEC_PA_EDID_CH0>>8)&0xFF, (CEC_PA_EDID_CH1>>8)&0xFF , (CEC_PA_EDID_CH2>>8)&0xFF , (CEC_PA_EDID_CH3>>8)&0xFF  };
+
+
+#if (PEBBLES_ES1_NVM == ENABLE)
+static void ProgramExtra()
+{
+	uint8_t i;
+
+//program  extra to NVM
+	 RegisterWrite(REG__EDID_FIFO_SEL,BIT__SEL_EXTRA); //enable extra
+	 RegisterWrite(REG__EDID_FIFO_ADDR,VAL__FIFO_ADDR_00); //address to start
+
+	if(0x27 == RegisterRead(REG__IDL_RX))
+		 for(i=0; i<=32; i++)
+		  {
+		     RegisterWrite(REG__EDID_FIFO_DATA,abEXTRATabl9127[i]);       
+		
+		  }	
+	else
+		 for(i=0; i<=32; i++)
+		  {
+		     RegisterWrite(REG__EDID_FIFO_DATA,abEXTRATabl[i]);       
+		
+		  }	
+			  		   
+	
+	  RegisterWrite(REG__NVM_COMMAND,VAL__PRG_EXTRA);  //prog extra
+	  while( (RegisterRead(REG__NVM_COMMAND_DONE)& BIT__NVM_COMMAND_DONE) == 0) //wait done
+	  ;
+	  
+}
+
+void ProgramEDID(void)
+{
+	uint16_t i;
+	
+	RegisterWrite(REG__EN_EDID,VAL__EN_EDID_NONE); //disable EDID DDC for all ports
+	//program EDID
+#if (PEBBLES_ES1_NVM_LOADED_CHECK == ENABLE)
+	if(RegisterRead(REG__NVM_STAT)==VAL__NVM_VALID)
+	{
+	   RegisterWrite(REG__EN_EDID,VAL__EN_EDID_ALL); //enable EDID DDC for all ports
+	   return;
+	 }
+	else
+
+#endif
+	
+    RegisterWrite(REG__EDID_FIFO_SEL,BIT__SEL_EDID0); //enable port 0
+    RegisterWrite(REG__EDID_FIFO_ADDR,VAL__FIFO_ADDR_00); //address to start
+
+
+	for(i=0; i<=255; i++)
+       RegisterWrite(REG__EDID_FIFO_DATA,abEDIDTabl[i]);	
+
+    RegisterWrite(REG__NVM_COMMAND,VAL__PRG_EDID);  //prog EDID
+    while( ((RegisterRead(REG__NVM_COMMAND_DONE)& BIT__NVM_COMMAND_DONE) == 0)) //wait done
+   	 ;				 
+	ProgramExtra();
+
+	//re - init with new EDID
+    RegisterWrite(REG__BSM_INIT,BIT__BSM_INIT);
+    while( (RegisterRead(REG__BSM_STAT)& BIT__BOOT_DONE )== 0) //wait done
+	  ;	
+    if((RegisterRead(REG__BSM_STAT)& BIT__BOOT_ERROR)!=0)
+		DEBUG_PRINT(("Re-Boot error! \n"));
+
+    RegisterWrite(REG__EN_EDID,VAL__EN_EDID_ALL); //enable EDID DDC for all ports
+
+}
+#else
+void ProgramEDID()
+{
+    uint16_t i; 
+	uint8_t k = 0;
+	uint8_t j = 0;
+    uint8_t cksum;
+	uint8_t firstPort=0x01;
+	uint8_t lastPort=0x08;
+
+	DEBUG_PRINT(("program SRAM! \n"));
+
+    RegisterWrite(REG__HP_CTRL,VAL__HP_PORT_NONE); //disable hotplug before changing
+
+	if(0x27 == RegisterRead(REG__IDL_RX))  //9127 has only 2 ports
+	{
+	   firstPort = 0x02;
+	   lastPort = 0x04;																	
+	}																				
+	
+    for( j=firstPort; j<=lastPort; j=j<<1 )
+    {
+
+        cksum=0;
+        RegisterWrite(REG__EDID_FIFO_SEL,j); //enable ports
+        RegisterWrite(REG__EDID_FIFO_ADDR,0x00); //address to start
+
+        for(i=0; i<255; i++)
+       {
+          if(i==CEC_PA_EDID_OFFSET)
+          {
+             // Program specific physical address
+             //
+             // Port0 1000
+             // Port1 2000
+             // Port2 3000
+             // Port3 4000
+
+
+             RegisterWrite( REG__EDID_FIFO_DATA, physicalAddr[k] );	//High uint8_t
+             cksum = cksum + (uint8_t)physicalAddr[k];	
+			
+             RegisterWrite( REG__EDID_FIFO_DATA, 0x00 );					//Low uint8_t
+             i = i+1 ;
+			 k = k+1;
+          }
+
+          else
+         {
+           RegisterWrite(REG__EDID_FIFO_DATA,abEDIDTabl[i]);
+           cksum = cksum + abEDIDTabl[i];
+          }
+       }
+
+       RegisterWrite(REG__EDID_FIFO_DATA,0-cksum);    //2nd block
+
+     }
+
+   RegisterWrite(REG__EN_EDID,VAL__EN_EDID_ALL); //enable ports
+   RegisterWrite(REG__HP_CTRL,VAL__HP_PORT_ALL); //enable hotplug
+}
+
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/EDID.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/EDID.h
new file mode 100755
index 000000000000..7877ef95cd8a
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/EDID.h
@@ -0,0 +1,25 @@
+//------------------------------------------------------------------------------
+// Copyright  2002-2005, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#ifndef UEDIDTBL
+#define UEDIDTBL
+
+#include <local_types.h>
+
+#define CEC_PA_EDID_OFFSET   0xB8   // for different EDID this value can be different
+
+
+
+extern ROM const uint8_t abEDIDTabl[256];
+extern ROM const uint8_t abEXTRATabl[32];
+
+void ProgramEDID(void);
+
+
+#endif
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/Makefile b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/Makefile
new file mode 100755
index 000000000000..fa0665cf3b18
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_AML_SII9233)		+= hal_cp9223.o
+
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal.h
new file mode 100755
index 000000000000..26f84cff22f4
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal.h
@@ -0,0 +1,58 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#ifndef __HAL_H__
+#define __HAL_H__
+
+
+
+//-------------------------------------------------------------------------------
+// Debug Include
+//-------------------------------------------------------------------------------
+#include <stdio.h>      //for printf and putchar
+#include <linux/kernel.h>
+
+
+//-------------------------------------------------------------------------------
+// Debug Print Macro 
+//   Note: DEBUG_PRINT Requires double parenthesis
+//   Example:  DEBUG_PRINT(("hello, world!\n"));
+//-------------------------------------------------------------------------------
+#if (CONF__DEBUG_PRINT == ENABLE)
+    #define DEBUG_PRINT(x)      printf x
+
+#else
+    #define DEBUG_PRINT(x)
+#endif
+
+
+
+//-------------------------------------------------------------------------------
+// Microprocessor HAL Function Prototypes
+//-------------------------------------------------------------------------------
+void UART_Init(void);
+
+void TIMER_Init(void);
+void TIMER_Set(uint8_t timer, uint16_t value);
+uint8_t TIMER_Expired(uint8_t timer);
+void TIMER_Wait(uint8_t index, uint16_t value);
+uint16_t TIMER_GetTickCounter( void );
+
+uint8_t GPIO_GetPins(uint8_t pinMask);
+void GPIO_SetPins(uint8_t pinMask);
+void GPIO_ClearPins(uint8_t pinMask);
+
+
+uint8_t I2C_ReadByte(uint8_t deviceID, uint8_t offset);
+void I2C_WriteByte(uint8_t deviceID, uint8_t offset, uint8_t value);
+uint8_t I2C_ReadBlock(uint8_t deviceID, uint8_t offset, uint8_t* buffer, uint16_t length);
+uint8_t I2C_WriteBlock(uint8_t deviceID, uint8_t offset, uint8_t* buffer, uint16_t length);
+
+
+
+#endif  // _HAL_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal_cp9223.c b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal_cp9223.c
new file mode 100755
index 000000000000..e8828bc5355b
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal_cp9223.c
@@ -0,0 +1,239 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#include <local_types.h>
+#include <config.h>
+#include <hal.h>
+
+
+
+//------------------------------------------------------------------------------
+// Local Defines for port switch value
+//------------------------------------------------------------------------------
+
+#define SWITCH_VALUE_PORT_0      0x07
+#define SWITCH_VALUE_PORT_1      0x06
+#define SWITCH_VALUE_PORT_2      0x05
+#define SWITCH_VALUE_PORT_3      0x04
+
+
+//------------------------------------------------------------------------------
+// Local Defines for APL control
+//------------------------------------------------------------------------------
+
+//I2C slave address
+#define APL_SLAVE_ADDR      0x64
+#define APL_CTRL_ADDR		0x08
+
+
+//------------------------------------------------------------------------------
+// Local Defines for Audio DAC control
+//------------------------------------------------------------------------------
+
+//I2C slave address
+#define ADAC_SLAVE_ADDR     0x24	 //changed from 0x26 to avoid conflict with Simon
+
+//register offsets
+#define ADAC_CTRL1_ADDR     0x00
+#define ADAC_CTRL2_ADDR     0x01
+#define ADAC_SPEED_PD_ADDR  0x02
+#define ADAC_CTRL3_ADDR     0x0A
+
+//power down control bits
+#define ADAC_POWER_DOWN        0x00
+#define ADAC_NORMAL_OPERATION  0x4F
+
+//dac operating modes
+#define ADAC_PCM_MODE       0x00
+#define ADAC_DSD_MODE       0x18
+
+//------------------------------------------------------------------------------
+// Function: HAL_Init
+// Description: Initialize HAL subsystem
+//------------------------------------------------------------------------------
+void HAL_Init(void)
+{
+    TIMER_Init();
+
+#if (CONF__DEBUG_PRINT == ENABLE) || (CONF__DEBUG_CMD_HANDLER == ENABLE)
+    UART_Init();
+#endif
+}
+
+#ifdef NOT_USED_NOW
+//------------------------------------------------------------------------------
+// Function: HAL_HardwareReset
+// Description: Give a hardware reset pulse to the chip
+//------------------------------------------------------------------------------
+void HAL_HardwareReset(void)
+{
+    GPIO_ClearPins(GPIO_PIN__HARDWARE_RESET);
+    TIMER_Wait(TIMER__DELAY, 2);
+
+    GPIO_SetPins(GPIO_PIN__HARDWARE_RESET);
+    TIMER_Wait(TIMER__DELAY, 5);
+
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: HAL_SetHotPlug
+// Description: Set hot plug for one port or clear hot plug for all ports
+//------------------------------------------------------------------------------
+void HAL_SetHotPlug(uint8_t portMask)
+{
+    switch (portMask)
+    {
+        case HOT_PLUG__PORT_NONE:
+#if 0
+		    I2C_WriteByte(ADAC_SLAVE_ADDR, ADAC_SPEED_PD_ADDR, ADAC_POWER_DOWN);
+#endif
+            break;
+        case HOT_PLUG__PORT_0:
+            break;
+        case HOT_PLUG__PORT_1:
+            break;
+    }
+}
+#endif
+
+
+
+#if (CONF__POLL_INTERRUPT_PIN == ENABLE)
+//------------------------------------------------------------------------------
+// Function: HAL_GetInterruptPinState
+// Description: Get current state of interrupt pin input
+//------------------------------------------------------------------------------
+uint8_t HAL_GetInterruptPinState(void)
+{
+    return (GPIO_GetPins(GPIO_PIN__RX_INTERRUPT));
+}
+#endif
+
+
+
+//------------------------------------------------------------------------------
+// Function: HAL_GetPortSelection
+// Description: Get current state of port select switch
+//              This read may not be stable, so it needs debounce routine below
+//------------------------------------------------------------------------------
+uint8_t HAL_GetPortSelection(void)
+{
+    uint8_t bPortSelection;
+	
+    bPortSelection = GPIO_GetPins(GPIO_PIN__PORT_SELECT_SWITCH_0 | GPIO_PIN__PORT_SELECT_SWITCH_1 |
+                                  GPIO_PIN__PORT_SELECT_SWITCH_2 );
+
+    return (bPortSelection);
+}
+
+
+//------------------------------------------------------------------------------
+// Function: HAL_GetPortSelectionDebounced
+// Description: Debounce read of port select switch - return debounced value
+//------------------------------------------------------------------------------
+uint8_t HAL_GetPortSelectionDebounced(void)
+{
+    static uint8_t bDebounceCount = CONF__SWITCH_DEBOUNCE_COUNT + 1;
+    static uint8_t bOldPortSelection = PORT_SELECT__NO_CHANGE;
+	static bool_t init = TRUE;
+
+    uint8_t bNewPortSelection;
+
+    bNewPortSelection = HAL_GetPortSelection();
+	if(init)
+	{
+	  bOldPortSelection = bNewPortSelection;
+	  init = FALSE;
+	  return (bNewPortSelection);
+	}
+    if(bNewPortSelection != bOldPortSelection)      //port change detected
+    {
+        bOldPortSelection = bNewPortSelection;
+        bDebounceCount = 0;
+    }
+    else if(bDebounceCount < CONF__SWITCH_DEBOUNCE_COUNT)        //keep counting while stable
+    {
+        bDebounceCount++;
+    }
+    else if(bDebounceCount == CONF__SWITCH_DEBOUNCE_COUNT)       //change confirmed
+    {
+        bDebounceCount = CONF__SWITCH_DEBOUNCE_COUNT + 1;
+        DEBUG_PRINT(("Port=0x%X\n", (int) bNewPortSelection));
+
+        return (bNewPortSelection);                 //return new port
+    }
+
+    return (PORT_SELECT__NO_CHANGE);                //indicate no change
+}
+
+
+//------------------------------------------------------------------------------
+// Function: HAL_PowerDownAudioDAC
+// Description: Send power down command to audio DAC
+//              Also mute the output by disableing output latch seperate from audio DAC
+//------------------------------------------------------------------------------
+void HAL_PowerDownAudioDAC(void)
+{
+#if 0
+    I2C_WriteByte(ADAC_SLAVE_ADDR, ADAC_SPEED_PD_ADDR, ADAC_POWER_DOWN);    
+    GPIO_SetPins(GPIO_PIN__AUDIO_DAC_MUTE);   //set mute pin (latch on 9135)
+#endif
+}
+
+
+//------------------------------------------------------------------------------
+// Function: HAL_WakeUpAudioDAC
+// Description: Send wake up command to audio DAC
+//              Also un-mute the output by enabling output latch seperate from audio DAC
+//------------------------------------------------------------------------------
+void HAL_WakeUpAudioDAC(void)
+{
+#if 0
+    I2C_WriteByte(ADAC_SLAVE_ADDR, ADAC_SPEED_PD_ADDR, ADAC_NORMAL_OPERATION);  
+    GPIO_ClearPins(GPIO_PIN__AUDIO_DAC_MUTE);  //clear mute pin (latch on 9135)
+#endif
+}
+
+
+//------------------------------------------------------------------------------
+// Function: HAL_SetAudioDACMode
+// Description: Send mode change command to audio DAC to select DSD or standard PCM mode
+//------------------------------------------------------------------------------
+void HAL_SetAudioDACMode(uint8_t dacMode)
+{
+#if 0
+    I2C_WriteByte(ADAC_SLAVE_ADDR, ADAC_SPEED_PD_ADDR, ADAC_POWER_DOWN);
+
+    if (dacMode)
+    {
+        I2C_WriteByte(ADAC_SLAVE_ADDR, ADAC_CTRL3_ADDR, ADAC_DSD_MODE);
+        DEBUG_PRINT(("dsd dac\n"));
+    }
+    else {
+        I2C_WriteByte(ADAC_SLAVE_ADDR, ADAC_CTRL3_ADDR, ADAC_PCM_MODE);
+        DEBUG_PRINT(("PCM dac\n"));
+    }
+#endif
+}
+
+//------------------------------------------------------------------------------
+// Function: HAL_VccEnable
+// Description: enable or disable the main +5V power from system
+//------------------------------------------------------------------------------
+ void HAL_VccEnable(uint8_t qON)
+ {
+ 	  if(qON)
+	  	  	GPIO_SetPins(GPIO_PIN__VCCEN);
+
+	  else
+	  		GPIO_ClearPins(GPIO_PIN__VCCEN);
+ }
+
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal_cp9223.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal_cp9223.h
new file mode 100755
index 000000000000..eaa0463fb376
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/hal_cp9223.h
@@ -0,0 +1,104 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#ifndef __HAL_CP9135_H__
+#define __HAL_CP9135_H__
+
+
+
+///-------------------------------------------------------------------------------
+// Hot Plug Control Mask Bits
+//-------------------------------------------------------------------------------
+#define HOT_PLUG__PORT_NONE     (0)
+#define HOT_PLUG__PORT_0        (1)
+#define HOT_PLUG__PORT_1        (2)
+#define HOT_PLUG__PORT_2        (3)
+#define HOT_PLUG__PORT_3        (4)
+
+
+//-------------------------------------------------------------------------------
+// Port Select Switch Mask Bits
+//-------------------------------------------------------------------------------
+#define PORT_SELECT__PORT_0     (0x07)	 //Pebbles starter ES0
+#define PORT_SELECT__PORT_1     (0x06)
+#define PORT_SELECT__PORT_2     (0x05)
+#define PORT_SELECT__PORT_3     (0x04)
+#define PORT_SELECT__PORT_7     (0x00)
+
+#define PORT_SELECT__NO_CHANGE  (0xFF)
+
+
+//-------------------------------------------------------------------------------
+// Audio Mux Settings
+//-------------------------------------------------------------------------------
+#define AUDIO_MUX__HDMI         		(0)
+#define AUDIO_MUX__DVI_ANALOG_PORT0   	(1)
+#define AUDIO_MUX__DVI_ANALOG_PORT1   	(2)
+
+
+//-------------------------------------------------------------------------------
+// GPIO Pin Definitions (8 pins max)
+//-------------------------------------------------------------------------------
+#define GPIO_PIN__PORT_SELECT_SWITCH_0     (1 << 0)
+#define GPIO_PIN__PORT_SELECT_SWITCH_1     (1 << 1)
+#define GPIO_PIN__PORT_SELECT_SWITCH_2     (1 << 2)
+#define GPIO_PIN__VCCEN					   (1 << 3)
+#define GPIO_PIN__AUDIO_DAC_MUTE      	   (1 << 4)
+#define GPIO_PIN__AUDIO_DAC_RESET     	   (1 << 5)
+#define GPIO_PIN__HARDWARE_RESET		   (1 << 6)
+#define GPIO_PIN__RX_INTERRUPT             (1 << 7)
+
+
+
+//-------------------------------------------------------------------------------
+// 8051 GPIO Default Pin Mappings
+//-------------------------------------------------------------------------------
+#define GPIO_PIN_MAP__PORT_SELECT_SWITCH_0  P0^2
+#define GPIO_PIN_MAP__PORT_SELECT_SWITCH_1  P0^3
+#define GPIO_PIN_MAP__PORT_SELECT_SWITCH_2  P0^4
+
+#define GPIO_PIN_MAP__COM_MODE				P0^0
+#define GPIO_PIN_MAP__VCCEN					P0^5
+
+#define GPIO_PIN_MAP__AUDIO_DAC_MUTE        P2^0
+#define GPIO_PIN_MAP__AUDIO_DAC_RESET       P2^6
+#define GPIO_PIN_MAP__HARDWARE_RESET        P0^1
+#define GPIO_PIN_MAP__RX_INTRRUPT           P3^2
+
+#define GPIO_PIN_MAP__CECD					P1^3
+
+//-------------------------------------------------------------------------------
+// 8051 SW I2C Pin Mappings
+//-------------------------------------------------------------------------------
+#define GPIO_PIN_MAP__I2C_SCL            P1^6
+#define GPIO_PIN_MAP__I2C_SDA            P1^7
+
+
+//-------------------------------------------------------------------------------
+// Board Support HAL Function Prototypes
+//-------------------------------------------------------------------------------
+void HAL_Init(void);
+void HAL_HardwareReset(void);
+void HAL_VccEnable(uint8_t qON);
+
+void HAL_SetHotPlug(uint8_t portMask);
+void HAL_SetAudioMux(uint8_t muxInput);
+
+uint8_t HAL_GetInterruptPinState(void);
+uint8_t HAL_GetPortSelection(void);
+uint8_t HAL_GetPortSelectionDebounced(void);
+
+void HAL_PowerDownAudioDAC(void);
+void HAL_WakeUpAudioDAC(void);
+void HAL_SetAudioDACMode(uint8_t dacModeDSD);
+
+void GPIO_ClearCecD(void);
+uint8_t GPIO_GetComMode(void);
+
+
+#endif  // __HAL_CP9135_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/local_types.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/local_types.h
new file mode 100755
index 000000000000..183e5837aadb
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/local_types.h
@@ -0,0 +1,30 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#ifndef __LOCAL_TYPES_H__
+#define __LOCAL_TYPES_H__
+
+#include <linux/kernel.h>
+
+
+//new alternetive unsigned type names
+//typedef unsigned char  uint8_t;
+//typedef unsigned short uint16_t;
+//typedef unsigned long  uint32_t;
+typedef unsigned char  bool_t;	/* this type can be used in structures */
+
+#define TRUE      1
+#define FALSE     0
+
+#define ROM
+#define IRAM	
+//#define ROM   code       // 8051 type of ROM memory
+//#define IRAM  idata      // 8051 type of RAM memory
+
+
+#endif  // __LOCAL_TYPES_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/Makefile b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/Makefile
new file mode 100755
index 000000000000..acf4d1a37405
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/Makefile
@@ -0,0 +1,14 @@
+obj-$(CONFIG_AML_SII9233)		+= __sii9233.o
+
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/HAL/
+EXTRA_CFLAGS += -Idrivers/amlogic/ext_hdmiin/sii9233/__sii9233/CEC/
+
+__sii9233-objs := EDID.o infofrm.o interrupt.o main.o regio.o
+
+obj-$(CONFIG_AML_SII9233)	+= CEC/
+obj-$(CONFIG_AML_SII9233)	+= HAL/
+
+#EXTRA_CFLAGS += -O2
+
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/amf.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/amf.h
new file mode 100755
index 000000000000..a3126fcada93
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/amf.h
@@ -0,0 +1,106 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#ifndef __AMF_H__
+#define __AMF_H__
+        
+
+
+//------------------------------------------------------------------------------
+// Constants
+//------------------------------------------------------------------------------
+
+// Audio states
+#define STATE_AUDIO__MUTED          0
+#define STATE_AUDIO__REQUEST_AUDIO  1
+#define STATE_AUDIO__AUDIO_READY    2
+#define STATE_AUDIO__ON             3
+
+// Video states
+#define STATE_VIDEO__MUTED          1
+#define STATE_VIDEO__UNMUTE			2
+#define STATE_VIDEO__ON             3
+#if (PEBBLES_VIDEO_STATUS_2ND_CHECK==ENABLE)
+#define STATE_VIDEO__CHECKED        4
+#endif
+
+
+//Audio modes
+#define AUDIO_MODE__PCM			0
+#define AUDIO_MODE__DSD			1	
+#define AUDIO_MODE__HBR			2
+#define AUDIO_MODE__NOT_INIT	0x0F
+// On, Off
+#define ON      1
+#define OFF     0
+
+// Set, Clear
+#define SET     0xFF
+#define CLEAR   0x00
+
+
+//------------------------------------------------------------------------------
+// Global Status Structure
+//------------------------------------------------------------------------------
+typedef struct {
+    uint8_t AudioState;
+    uint8_t ColorDepth;
+	uint8_t VideoState;
+	uint8_t AudioMode;   //101 added for handling HBR
+    uint8_t PortSelection;
+	uint8_t ResolutionChangeCount;	   //for zone workaround
+	uint8_t VideoStabilityCheckCount; //for ODCK disappear workaround
+} GlobalStatus_t; 
+
+
+
+//------------------------------------------------------------------------------
+// Global status variable
+//------------------------------------------------------------------------------
+extern GlobalStatus_t CurrentStatus;
+
+
+
+//------------------------------------------------------------------------------
+// Function Prototypes for mainline code
+//------------------------------------------------------------------------------
+void SystemDataReset(void);
+
+
+
+//------------------------------------------------------------------------------
+// Function Prototypes for interrupt handler routines
+//------------------------------------------------------------------------------
+void SetupInterruptMasks(void);
+void AudioUnmuteHandler(void);
+void TurnAudioMute (uint8_t qOn);
+void TurnVideoMute(uint8_t qOn);
+void TurnPowerDown(uint8_t qOn);
+void PollInterrupt(void);
+void ProgramEDID();
+uint8_t ResetVideoControl();
+#if (PEBBLES_VIDEO_STATUS_2ND_CHECK==ENABLE)
+uint8_t PclkCheck();
+#endif
+
+
+//------------------------------------------------------------------------------
+// Function Prototypes for register access routines
+//------------------------------------------------------------------------------
+uint8_t RegisterRead(uint16_t regAddr);
+void RegisterWrite(uint16_t regAddr, uint8_t value);
+void RegisterModify(uint16_t regAddr, uint8_t mask, uint8_t value);
+void RegisterBitToggle(uint16_t regAddr, uint8_t mask);
+
+void RegisterReadBlock(uint16_t regAddr, uint8_t* buffer, uint8_t length);
+void RegisterWriteBlock(uint16_t regAddr, uint8_t* buffer, uint8_t length);
+
+
+
+
+#endif  // __AMF_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/config.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/config.h
new file mode 100755
index 000000000000..1084a4f96523
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/config.h
@@ -0,0 +1,197 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#ifndef __CONFIG_H__
+#define __CONFIG_H__
+
+
+
+//------------------------------------------------------------------------------
+// Include HAL for target board
+//------------------------------------------------------------------------------
+#include <hal_cp9223.h>
+
+//------------------------------------------------------------------------------
+// NVRAM Configuration
+//------------------------------------------------------------------------------
+
+
+#define PEBBLES_ES1_STARTER_CONF                        (ENABLE)
+#define PEBBLES_ES1_NVM                                 (ENABLE)	//enable if chip is Not NVM programmed
+#define PEBBLES_ES1_NVM_LOADED_CHECK                    (DISABLE)	//enable if chip is already NVM programmed
+
+
+//------------------------------------------------------------------------------
+// ZONE Workaround
+//------------------------------------------------------------------------------
+
+#define PEBBLES_ES1_ZONE_WORKAROUND						(ENABLE) //ES1.1 auto zone detection issue
+#define PEBBLES_ES1_FF_WORKAROUND						(ENABLE) //ES1.1 FF part 
+#define PEBBLES_STARTER_NO_CLK_DIVIDER					(ENABLE) //for demo 480i with starter board
+#define PEBBLES_VIDEO_STATUS_2ND_CHECK					(ENABLE) //check pclk status again after video unmute
+#define VIDEO_UNMUTE_TIMEOUT							(400)	 //set video unmute timeout 400ms 
+#define VIDEO_STABLITY_CHECK_INTERVAL					(100)	 //set video stability check timeout 400ms 
+#define VIDEO_STABLITY_CHECK_TOTAL						(5000)   //multiple check within this time
+//------------------------------------------------------------------------------
+// Receiver Configuration
+//------------------------------------------------------------------------------
+
+// Register Slave Addresses
+#define CONF__I2C_SLAVE_PAGE_0          (0x60)
+#define CONF__I2C_SLAVE_PAGE_1          (0x68)
+#define CONF__I2C_SLAVE_PAGE_8          (0xC0)   //CEC
+#define CONF__I2C_SLAVE_PAGE_9          (0xE0)   //EDID
+#define CONF__I2C_SLAVE_PAGE_A          (0x64)   //xvYCC
+#define CONF__I2C_SLAVE_PAGE_C          (0xE6)   //CBUS
+
+
+
+//------------------------------------------------------------------------------
+// Video Output Configuration
+//------------------------------------------------------------------------------
+
+// Video Output Bus Formatting
+#define CONF__ODCK_INVERT               (DISABLE )
+#define CONF__VSYNC_INVERT              (DISABLE)
+#define CONF__HSYNC_INVERT              (DISABLE)
+#define CONF__OUTOUT_COLOR_DEPTH        (VAL__OUT_COLOR_DEPTH_8)
+#define CONF__OUTPUT_YCBCR        		(DISABLE)
+#define CONF__OUTPUT_SAMPL_422        	(DISABLE)
+#define CONF__OUTPUT_MUXYC				(DISABLE)	
+#define CONF__OUTPUT_EMBEDDED_SYNC		(DISABLE)	
+
+#define CONF__OUTPUT_VIDEO_FORMAT       (VAL__RGB)
+
+
+
+//------------------------------------------------------------------------------
+// Audio Output Configuration
+//------------------------------------------------------------------------------
+
+// PCM Audio Output Configuration
+#define CONF__PCM__MCLK                 (VAL__SWMCLK_256)
+#define CONF__PCM__I2S_CTRL1            (BIT__SCK)      //invert SCK, rest are defaults
+#define CONF__PCM__I2S_CTRL2__LAYOUT_0  (BIT__SD0)      //channel 0 only for layout 0
+#define CONF__PCM__I2S_CTRL2__LAYOUT_1  (BIT__SD0 | BIT__SD1 | BIT__SD2 | BIT__SD3)  //all channels for layout1
+
+// DSD Audio Output Configuration
+#define CONF__DSD__MCLK                 (VAL__SWMCLK_512)
+#define CONF__DSD__I2S_CTRL1            (BIT__SCK)      //invert SCK, rest are defaults
+#define CONF__DSD__I2S_CTRL2__LAYOUT_0  (BIT__SD0)      //channel 0 only for layout 0
+#define CONF__DSD__I2S_CTRL2__LAYOUT_1  (BIT__SD0 | BIT__SD1 | BIT__SD2)  //all 6 channels for layout1
+
+// HBR Audio Output Configuration
+#define CONF__HBR__MCLK                 (VAL__SWMCLK_128)
+#define CONF__HBR__I2S_CTRL1            (BIT__SCK)
+#define CONF__HBR__I2S_CTRL2            (BIT__SD0 | BIT__SD1 | BIT__SD2 | BIT__SD3)  //all channels - HBR requires layout1
+
+// Common Audio Configuration
+//$$ #define CONF__AUD_CTRL                  (BIT__MUTE_MODE | BIT__PSERR | BIT__PAERR | BIT__I2SMODE | BIT__SPEN)  //use soft mute - pass errors
+#define CONF__AUD_MUTE_MODE             (ENABLE) 
+#define CONF__AUD_MODE_EN				(BIT__HBR_ENABLE 	|	\
+										 BIT__DSD_ENABLE	|	\
+										 BIT__SPDIF_ENABLE	|	\
+										 BIT__HBR_ENABLE)
+
+
+#define CONF__AUD_CTRL                  (BIT__MUTE_MODE | BIT__PSERR | BIT__PAERR | BIT__I2SMODE | BIT__SPEN)  //use soft mute - pass errors
+
+
+//------------------------------------------------------------------------------
+// Other Chip Configuration
+//------------------------------------------------------------------------------
+
+// HDCP Error Threshold and Tolerance
+#define CONF__HDCPTHRESH                (0x0B40)      // recommended value
+#define CONF__HDCP_MAX_ERRORS           (30)
+
+// Termination Impedence
+#define CONF__TERMINATION_VALUE         (VAL__TERM_CNTL_45)
+
+// Misc Register Configuration
+#define CONF__AACR_CFG1_VALUE           (0x88)      // recommended value
+#define CONF__CTS_THRESH_VALUE             (4)      // recommended value
+
+#define CONF__SUPPORT_ALL_INFOFRAMES	(ENABLE)	// used for demonstration of repeater's configuratiom
+#define CONF__SUPPORT_3D				(ENABLE)	// used for support device in 3 Mode
+#define CONF__SUPPORT_REPEATER3D		(DISABLE)	// used for support device in 3 Mode
+#define CONF__VSYNC_OVERFLOW			(ENABLE)	// overlow for line counter 
+
+//------------------------------------------------------------------------------
+// Application Configuration
+//------------------------------------------------------------------------------
+
+// Timeout Values
+#define CONF__VIDEO_UNMUTE_DELAY        (100)       //delay before unmute video (mSec)
+#define CONF__POWERDOWN_DELAY           (3000)      //delay before power down (mSec)
+
+// Interrupt Polling Method
+#define CONF__POLL_INTERRUPT_PIN        (DISABLE)   //enable to poll GPIO pin instead of register
+
+// Debug Options
+#define CONF__DEBUG_PRINT               (DISABLE)    //print debug messages
+#define CONF__DEBUG_CMD_HANDLER         (DISABLE)    //run debug command handler
+
+
+
+//------------------------------------------------------------------------------
+// HAL Configuration
+//------------------------------------------------------------------------------
+
+// UART Timer 2 divider values for baud rate generator
+//   65518 = 19,200 baud with 11.0592 MHz crystal
+//   65503 = 19,200 baud with 20 MHz crystal
+#define CONF__UART_BAUD_DIVIDER   (65503)
+
+// Timer Configuration
+#define TIMER__VIDEO        0  //for video state machine
+#define TIMER__AUDIO        1  //for audio state machine
+#define TIMER__DELAY        2  //for general blocking delay calls
+#define TIMER__POLLING      3  //for main polling loop
+
+#ifdef TEST_VERSION
+#define CONF__TIMER_COUNT       5
+#define TIMER_TEST              4
+
+#else
+#define CONF__TIMER_COUNT   4
+#endif
+
+// Port Switch Debounce
+#define CONF__SWITCH_DEBOUNCE_COUNT  20
+
+
+
+//------------------------------------------------------------------------------
+// General Configuration Defines
+//------------------------------------------------------------------------------
+#define ENABLE      (0xFF)
+#define DISABLE     (0x00)
+
+
+
+//----------
+//CEC configuration
+//-----------
+
+#define CONF__CEC_ENABLE (DISABLE)
+
+
+//----------------------------------
+//ODCK output stop at limit feature
+//----------------------------------
+//
+#define CONF__ODCK_LIMITED (DISABLE)
+#define CONF__PCLK_MAX_CNT (0x74)	 //Max ODCK will not exceed 148MHz
+
+
+
+
+
+
+#endif  // _CONFIG_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/infofrm.c b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/infofrm.c
new file mode 100755
index 000000000000..98eeb7cc4010
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/infofrm.c
@@ -0,0 +1,926 @@
+/******************************************************************************
+ *
+ * Copyright 2008, Silicon Image, Inc.  All rights reserved.
+ * No part of this work may be reproduced, modified, distributed, transmitted,
+ * transcribed, or translated into any language or computer format, in any form
+ * or by any means without written permission of: Silicon Image, Inc., 1060
+ * East Arques Avenue, Sunnyvale, California 94085
+ *
+ *****************************************************************************/
+/**
+ * @file infofrm.c
+ *
+ * This is a description of the file.
+ *
+ * $Author: $Vladimir Grekhov
+ * $Rev: $
+ * $Date: $ 9-14-09
+ *
+ *****************************************************************************/
+
+/***** #include statements ***************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <local_types.h>
+#include "spec_types.h"
+#include "config.h"
+#include "registers.h"  /*  defines receiver's chip registers                       */
+#include "amf.h"        /*  defines accessor functions receiver's chip registers    */
+#include "hal.h"        /*  macro with printf                                       */
+#include "infofrm.h"
+
+#if (CONF__SUPPORT_3D == ENABLE)
+
+/***** local macro definitions ***********************************************/
+#define SPD_CAPTURE_TO          1250
+#define VSIF_LONG_CAPTURE_TO    1300
+#define ISRC1_CAPTURE_TO        500
+#define TWO_VIDFR_CAPTURE_TO    300//150//36
+#define SPD_ISRC1_CAPTURE_TO    500
+#define TIME_WO_ACP_IF          2000//600
+#define ACP_CAPTURE_200MS       600//200
+#define MAX_NUM_IF              3
+
+#define IFBUFF_SIZE 32
+
+#define SET_CLR_IF() (RegisterWrite( REG__INFM_CLR, 0x7F)) //clear verything
+#define SET_PACKET_INTR_MASK() (RegisterWrite( REG__INTR3_UNMASK, 0x0B))
+//0x0B =  BIT__NEW_AVI_INF|BIT__NEW_SPD_INF|BIT__NEW_MPEG_INF) 
+
+
+
+/***** local type definitions ************************************************/
+typedef uint16_t DevAddr_t;
+
+typedef struct _IfInsCtrl_t {
+    uint16_t    wTo;
+    uint8_t     bBuffType;
+    bool_t      fReceived;
+    bool_t      fFailed;
+} IfInsCtrl_t;
+
+typedef enum {
+    SelVsif
+    ,SelIsrc1
+    ,SelIsrc2
+    ,SelSpd
+    ,SelAcp
+    ,MaxNumIfSel
+} SelectIf_t;
+
+
+typedef struct _IfCtrl_t {
+
+    IfInsCtrl_t Ins[MaxNumIfSel];
+    uint8_t     abBuff[IFBUFF_SIZE];
+    uint8_t     abVsif[IF_VSIF_SIZE];
+    uint8_t     abAcp[IF_ACP_SIZE];
+    uint16_t    wNoAcpTotTime;
+    uint8_t     bDecodeTypeMpegBuffer;
+    uint8_t     bDecodeTypeSpdBuffer;
+    uint8_t     bVidModeId; /* Video Mode Id aquired from Avi */
+
+    bool_t      fAcpIntr;
+    bool_t      fSpdCaptured;
+    bool_t      fIsrc1Captured;
+    bool_t      fSpdDecodeIsrc2;
+    bool_t      fIntrOnEveryNewAvi;
+    bool_t      fIntrOnEveryNewAud;
+    bool_t      fIntrOnEveryNewGamut;
+    bool_t      fVsifIsPresent;
+    bool_t      fAcpIsPresent;
+    bool_t      fMpegBuff_IsrcNotFound;
+    /*
+        This state is important to track changes of mpeg info frame buffer.
+        When Vsif is received and Isrc capturing period is missed, when we go back
+        to receive Vsif, if data weren't changed we will not receive an Vsif
+        interrupt. Vsif wii receive Time Out and without acctionans applicable
+        to Vsif we should set Isrc captuting again.
+    */
+    bool_t      fDebug;
+}IfCtrl_t;
+
+typedef struct _IfFlafs_t {
+
+    uint8_t     bNewIfs;
+    uint8_t     bChangedIfs;
+    uint8_t     bStoppedIfs;
+
+}IfFlafs_t;
+
+/* info frames, check sum property */
+
+typedef enum {
+    IfWCheckSum         /*  generic info frame check sum (Avi, Aud, Spd, Vsif)  */
+    ,IfWGamutCheckSum   /*  info frame check sum of gamut packet                */
+    ,IfWOCheckSum       /*  info frame without check sum (Acp, Isrc1/2          */
+} eIfCheckSumProp_t;
+
+
+
+/***** local variable declarations *******************************************/
+/**
+ * @brief Typically this should do.
+ */
+const uint8_t IEEERegistrationId[] = { 0x03, 0x0C, 0x00 };
+
+static IfCtrl_t IfCtrl;
+
+
+/***** local function prototypes *********************************************/
+
+static uint8_t GetIfTypeFromUnreqBuffer ( void );
+static void SetDecodeIfBuffers ( const DevAddr_t DevAddr, const uint8_t bDecodeIfType );
+static void SetIfTo ( SelectIf_t eSelectIf, const uint16_t wTo );
+static bool_t GetIf( const uint8_t bIfType );
+static bool_t GetIntrAcpStatus ( void );
+static void SetIntrAcp ( const bool_t fEnable );
+static void SetIntrOnEveryNewIf ( const bool_t fEnable, const uint8_t bIfType );
+static void SetToIfBuff ( const uint8_t bIfType );
+static void print_tabl (    char const *pMesg,
+                            void const *pData,
+                            uint16_t wCnt,
+                            uint8_t bCol );
+static void AviParser ( uint8_t const *pPayload );
+static void VsifParser ( uint8_t const *pPayload );
+
+static bool_t ProcIf ( DevAddr_t DevAddr, const uint8_t bIfType, uint8_t bSize );
+/***** local functions *******************************************************/
+#if (CONF__SUPPORT_REPEATER3D == ENABLE)
+static uint8_t GetIfTypeFromUnreqBuffer ( void ){
+
+    return RegisterRead( REG__UNREQ_TYPE );
+}
+#endif
+static uint8_t GetMpegDecodeAddr ( void ){
+    return RegisterRead( REG__MPEG_DECODE);
+}
+/*****************************************************************************/
+/**
+ *  The description of the function print_tabl().
+ *
+ *  @param[in]  char const *pMesg   - label being print out
+ *  @param[in]  void const *pData   - data being print out
+ *  @param[in]  uint16_t    wCnt    - number bytes to be print out
+ *  @param[in]  uint8_t     bCol    - number collons to print
+ *
+ *  @return     none.
+ *  @retval     void
+ *
+ *****************************************************************************/
+static void print_tabl ( char const *pMesg, void const *pData, uint16_t wCnt, uint8_t bCol ){
+uint32_t i;
+uint8_t const *pbData;
+
+    pbData = (uint8_t *)pData;
+    DEBUG_PRINT (("\n%s", pMesg ));
+
+    if ( pbData != NULL ){
+        for ( i = 0; i < wCnt; i++ ){
+            if ( i%bCol == 0 ){
+                DEBUG_PRINT (( "\n0x%X: ", (uint32_t) &pbData[i]));
+            }
+            DEBUG_PRINT (( " 0x%02X", (uint16_t)pbData[i] ));
+        }
+        DEBUG_PRINT (( "\n"));
+    }
+    else {
+        DEBUG_PRINT (( "\nNULL pointer"));
+    }
+    DEBUG_PRINT (( "\n"));
+}
+
+static void print_mpegbuffer( void ){
+uint8_t abData[16];
+
+    RegisterReadBlock( REG__MPEG_TYPE, abData, 16 );
+    print_tabl ( "Mpeg_buf", abData, 16, 8 );
+
+}
+
+/*****************************************************************************/
+/**
+ *  The description of the function AviParser().
+ *  Displays parsed information
+ *  @param[in]  uint8_t const *pPaylaod   - Info frame paylaod
+ *
+ *  @return     none.
+ *  @retval     void
+ *
+ *****************************************************************************/
+static void AviParser ( uint8_t const *pPayload ){
+
+    DEBUG_PRINT (("Parsing Avi: \n "));
+    /* check for Video Id Code*/
+    IfCtrl.bVidModeId = (pPayload[IF_AVI_VIC_ADDR] & IF_AVI_VIC_SEL );
+    DEBUG_PRINT (("Vic: "));
+    switch (IfCtrl.bVidModeId){
+        case   0: DEBUG_PRINT (("Not valid ID"));
+                break;
+          default:                DEBUG_PRINT (( "%d", (uint16_t) IfCtrl.bVidModeId ));
+    }
+    DEBUG_PRINT ( ("\n Exten. Colorimetry Info: " ));
+    switch (pPayload[IF_AVI_EC_ADDR] & ExtnColorimSel){
+        case xvYCC601:      DEBUG_PRINT (("xvYCC601"));
+            break;
+        case xvYCC709:      DEBUG_PRINT (("xvYCC709"));
+            break;
+        case cYCC601:       DEBUG_PRINT (("cYCC601"));
+            break;
+        case AdobeYCC601:   DEBUG_PRINT (("AdobeYCC601"));
+            break;
+        case AdobeRGB:      DEBUG_PRINT (("AdobeRGB"));
+            break;
+        default:            DEBUG_PRINT (("Res"));
+    }
+    DEBUG_PRINT ( ("\n Cont Type: " ));
+    switch (pPayload[IF_AVI_CN_ADDR] & ContTypeSel ){
+        case Graphics:
+            if ( pPayload[IF_AVI_ITC_ADDR] & ITContSel ){
+                DEBUG_PRINT (("Graphics"));
+            }
+            else {
+                DEBUG_PRINT (("No Data"));
+            }
+            break;
+        case Photo:     DEBUG_PRINT (("Photo"));
+            break;
+        case Cinema:    DEBUG_PRINT (("Cinema"));
+            break;
+        case Game:      DEBUG_PRINT (("Game"));
+            break;
+    }
+}
+/*****************************************************************************/
+/**
+ *  The description of the function VsifParser().
+ *  Displays parsed information
+ *  @param[in]  uint8_t const *pPaylaod   - Info frame paylaod
+ *
+ *  @return     none.
+ *  @retval     void
+ *
+ *****************************************************************************/
+
+
+static void VsifParser ( uint8_t const *pPayload ){
+
+    DEBUG_PRINT (("Parsing Vsif: "));
+    /* Check IEEE Registreation Id */
+    if ( !memcmp ( &pPayload[IF_VSIF_IEEE_REGID_ADDR], IEEERegistrationId , sizeof(IEEERegistrationId) )){
+        /* Check Hdmi Format for 3D*/
+        if ( (pPayload[IF_VSIF_HDMI_FORMAT_ADDR] & IF_VSIF_HDMI_FORMAT_SEL) == IF_HDMI_FORMAT_3D ){
+            DEBUG_PRINT (("\nVsif 3D: "));
+            switch ( pPayload[IF_VSIF_3D_STRUCT_ADDR] >> IF_VSIF_3DSTRUCT_SEL ){
+                case FramePacking:      DEBUG_PRINT (("FramePacking"));
+                    break;
+                case FrameAlternative:  DEBUG_PRINT (("FrameAlternative"));
+                    break;
+                case LineAlternative:   DEBUG_PRINT (("LineAlternative"));
+                    break;
+                case SiedBySideFull:    DEBUG_PRINT (("SiedBySideFull"));
+                    break;
+                case LDepth:            DEBUG_PRINT (("LDepth"));
+                    break;
+                case LDepthGraphGraphDepth: DEBUG_PRINT (("LDepthGraphGraphDepth"));
+                    break;
+                case SideBySideHalf:        DEBUG_PRINT (("SideBySideHalf"));
+                    break;
+                default:                    DEBUG_PRINT (("Reserved")); //yma change to reserved
+            }
+		DEBUG_PRINT ((" \n"));			
+        }
+        else {
+            DEBUG_PRINT (("\nVsif not 3D"));
+        }
+    }
+    else {
+        DEBUG_PRINT (("\nVsif IEEE Reg. Id is not matched"));
+    }
+}
+
+/*****************************************************************************/
+/**
+ *      The description of the function SetDecodeIfBuffers ()
+ *
+ *  @param[in]  DevAddr Rx Chip leaner address
+ *  @param[in]  Rx Chip, decode info frame type
+ *
+ *  @return     none
+ *  @retval     void
+ *
+ *****************************************************************************/
+static void SetDecodeIfBuffers ( const DevAddr_t DevAddr, const uint8_t bDecodeIfType ){
+    RegisterWrite( DevAddr, bDecodeIfType );
+    if ( REG__MPEG_DECODE == DevAddr ){
+        IfCtrl.bDecodeTypeMpegBuffer = bDecodeIfType;
+    }
+    else {
+        IfCtrl.bDecodeTypeSpdBuffer = bDecodeIfType;
+    }
+}
+
+static void SetIfTo ( SelectIf_t eSelectIf, const uint16_t wTo ){
+    IfCtrl.Ins[eSelectIf].wTo = wTo;
+}
+
+/*****************************************************************************/
+/**
+ *  The description of the function SetToIfBuff().
+ *
+ *  @param[in] bIfType  InfoFrame type
+ *
+ *  @return             none
+ *  @retval             void
+ *
+ *****************************************************************************/
+ static void SetToIfBuff ( const uint8_t bIfType ){
+
+    switch( bIfType ){
+        case IF_AVI_ID:
+            break;
+        case IF_VSIF_ID:
+            SetDecodeIfBuffers ( REG__MPEG_DECODE,  IF_ISRC1_ID );
+            IfCtrl.Ins[ SelIsrc1 ].wTo = VSIF_LONG_CAPTURE_TO;
+             /* this time out is used with shared info frame buffer, so cannot set the same time */
+            IfCtrl.Ins[ SelVsif ].wTo = 0;
+            if ( !IfCtrl.fSpdDecodeIsrc2 ){
+                IfCtrl.Ins[ SelIsrc1 ].wTo = 0;
+            }
+            break;
+        case IF_ISRC1_ID:
+            if ( !IfCtrl.fSpdDecodeIsrc2 ){ /* mpeg buffer is used for Isrc1/Isrc2/Vsif */
+                IfCtrl.Ins[ SelIsrc2 ].wTo  = VSIF_LONG_CAPTURE_TO;
+                IfCtrl.Ins[ SelIsrc1 ].wTo  = 0;
+                IfCtrl.Ins[ SelVsif ].wTo   = 0;
+                SetDecodeIfBuffers ( REG__MPEG_DECODE,  IF_ISRC2_ID );
+            }
+            else { /* mpeg buffer is used for Isrc1 Vsif */
+                IfCtrl.Ins[ SelVsif ].wTo = TWO_VIDFR_CAPTURE_TO;
+                 /* this time out is used with shared info frame buffer, so cannot set the same time*/
+                IfCtrl.Ins[ SelIsrc1 ].wTo = 0;
+                print_mpegbuffer();
+                SetDecodeIfBuffers ( REG__MPEG_DECODE,  IF_VSIF_ID );
+                IfCtrl.fDebug = 1;
+            }
+            break;
+        case IF_ISRC2_ID:
+            if ( !IfCtrl.fSpdDecodeIsrc2 ){
+                IfCtrl.Ins[ SelVsif ].wTo = TWO_VIDFR_CAPTURE_TO;
+                IfCtrl.Ins[ SelIsrc1 ].wTo  = 0;
+                IfCtrl.Ins[ SelIsrc2 ].wTo = 0;
+                SetDecodeIfBuffers ( REG__MPEG_DECODE,  IF_VSIF_ID );
+            }
+            break;
+        case IF_SPD_ID:
+            IfCtrl.Ins[ SelIsrc2].wTo = 0;
+            SetDecodeIfBuffers ( REG__SPD_DECODE,  IF_ISRC2_ID );
+            break;
+        case IF_ACP_ID:
+            IfCtrl.wNoAcpTotTime    = TIME_WO_ACP_IF;
+            /* TODO disable Acp interrupt */
+            /* set time out*/
+            IfCtrl.Ins[ SelAcp].wTo = ACP_CAPTURE_200MS;
+            break;
+        default: 
+			;
+    }
+ }
+
+
+static bool_t GetIfRoll( DevAddr_t DevAddr, uint8_t *pbRetIfType ){
+uint8_t bSize;
+bool_t fValid = TRUE;
+
+    *pbRetIfType = RegisterRead( DevAddr );
+
+    switch ( *pbRetIfType ){
+        case IF_SPD_ID:
+                        bSize   =   IF_SPD_SIZE;
+                        break;
+        case IF_VSIF_ID:
+                        bSize   =   IF_VSIF_SIZE;
+                        break;
+        case IF_ISRC1_ID:
+        case IF_ISRC2_ID:
+                        bSize   =   IF_ISRC_SIZE;
+                        break;
+        default:
+            fValid = FALSE;
+    }
+    if ( fValid ){
+        fValid = ProcIf ( DevAddr, *pbRetIfType, bSize );
+    }
+
+    return fValid;
+}
+/*****************************************************************************/
+/**
+ *      The description of the function ProcIf()
+ *
+ *  @param[in]  DevAddr         - device address
+ *  @param[in]  bIfType         - info frame type
+ *  @param[in]  bSize           - size of infoframe
+ *
+ *  @return     bool_t
+ *  @retval     TRUE for a valid packet
+ *
+ *****************************************************************************/
+bool_t ProcIf ( DevAddr_t DevAddr, const uint8_t bIfType, uint8_t bSize ){
+bool_t fValid = FALSE;
+uint8_t i;
+uint8_t bAuxSize = 0;
+uint8_t CheckSum = 0;
+//uint8_t NumMissed;
+/*
+Checksum [1 byte] Checksum of infoframe. The checksum shall be calculated such that byte-sum
+of all three bytes of the Packet Header and all valid uint8_ts of the InfoFrame Packet contents
+(determined by InfoFrame Length), plus check sum itself, equals zero
+*/
+
+
+    if ( !(bIfType & 0x80) ){
+        RegisterReadBlock( DevAddr, IfCtrl.abBuff, bSize );
+        print_tabl ( "** IF Data", IfCtrl.abBuff, bSize, 8);
+    }
+    else {
+        RegisterReadBlock( DevAddr, IfCtrl.abBuff, IF_HEADER_SIZE );
+        if ( IfCtrl.abBuff[ IF_LENGTH_ADDR] <= bSize ){
+            bAuxSize = IfCtrl.abBuff[ IF_LENGTH_ADDR];
+            DevAddr += IF_HEADER_SIZE; /* first byte is check sum */
+            RegisterReadBlock( DevAddr, &IfCtrl.abBuff[IF_HEADER_SIZE], bSize + 1);
+            bAuxSize += (IF_HEADER_SIZE + 1); /* header excludes check sum which in counted by adding 1, payload if following of check sum */
+            if ( bIfType == IF_VSIF_ID ){
+                if ( !memcmp ( IfCtrl.abBuff, IfCtrl.abVsif, bAuxSize ) ){
+                    DEBUG_PRINT (( "\n** Same Vsif\n"));
+                }
+                else {
+                    print_tabl ( "** Got new Vsif", IfCtrl.abBuff, IfCtrl.abBuff[IF_LENGTH_ADDR], 8);
+                    memcpy ( IfCtrl.abVsif, IfCtrl.abBuff, bSize + IF_HEADER_SIZE );
+                    for ( i = 0; i < bAuxSize; i++ ){
+                        CheckSum += IfCtrl.abBuff[i];
+                    }
+                    DEBUG_PRINT (( "\n** IF 0x%2X Checksum: ", (uint16_t) bIfType));
+                    if ( !CheckSum ){ /* */
+                        DEBUG_PRINT (( "OK\n" ));
+                        VsifParser( &IfCtrl.abBuff[IF_PAYLOAD_ADDR] );
+                        fValid = TRUE;
+                    }
+                    else {
+                        DEBUG_PRINT (( "Failed\n" ));
+                    }
+                    IfCtrl.fVsifIsPresent = TRUE;
+                }
+            }
+            else if ( bIfType == IF_GMT_ID ){
+
+            }
+            else {
+                print_tabl ( "** IF Data", IfCtrl.abBuff, IfCtrl.abBuff[IF_LENGTH_ADDR], 8);
+                for ( i = 0; i < bAuxSize; i++ ){
+                    CheckSum += IfCtrl.abBuff[i];
+                }
+                DEBUG_PRINT (( "** IF 0x%2X Checksum: ", (uint16_t) bIfType));
+                if ( !CheckSum ){ /**/
+                    fValid = TRUE;
+					DEBUG_PRINT (( "OK\n" ));
+                    if ( bIfType == IF_AVI_ID ){
+                        AviParser( &IfCtrl.abBuff[IF_PAYLOAD_ADDR] );
+                    }                 
+                }
+                else {
+                    DEBUG_PRINT (( "Failed\n" ));
+                }
+            }
+        }
+        else {
+            DEBUG_PRINT (( "\n** GetIf: wrong parametr in info frame size\n"));
+        }
+    }
+
+    return fValid;
+}
+
+/*****************************************************************************/
+/**
+ *      The description of the function GetIf()
+ *
+ *  @param[in]  bIfType         - info frame type
+ *  @param[in]  bBufferType     - info frame buffer (Isrc can use a differnt buffer)
+ *
+ *  @return     bool_t
+ *  @retval     TRUE for a valid packet
+ *
+ *****************************************************************************/
+
+static bool_t GetIf( const uint8_t bIfType ){
+bool_t fValid = TRUE;
+DevAddr_t   DevAddr =   0;
+uint8_t     bSize   =   0;
+
+    switch ( bIfType ){
+
+        case IF_VSIF_ID:
+                        bSize   =   IF_VSIF_SIZE;
+                        DevAddr =   REG__MPEG_TYPE;
+                        break;
+        case IF_AVI_ID:
+                        bSize   =   IF_AVI_SIZE;
+                        DevAddr =   REG__AVI_TYPE;
+                        break;
+        case IF_AUD_ID:
+                        bSize   =   IF_AUD_SIZE;
+                        DevAddr =   REG__AUD_TYPE;
+                        break;
+        case IF_SPD_ID:
+                        bSize   =   IF_SPD_SIZE;
+                        DevAddr =   REG__SPD_TYPE;
+                        break;
+        case IF_GMT_ID:
+                        bSize   =   IF_GMT_SIZE;
+                        DevAddr =   REG__GMT_TYPE;
+                        break;
+        case IF_ACP_ID:
+                        bSize   =   IF_ACP_SIZE;
+                        DevAddr =   REG__ACP_TYPE;
+                        break;
+        default:
+                        DEBUG_PRINT (( "\n** GetIf: unsupported type\n"));
+                        fValid = FALSE;
+    }
+    if ( fValid ){
+        fValid = ProcIf ( DevAddr, bIfType, bSize );
+    }
+
+    return fValid;
+}
+
+/*****************************************************************************/
+/**
+ *      The description of the function GetIntrAcpStatus ()
+ *      This function checks status of Acp interrupt, it is used in polling manner
+ *
+ *  @param[in/out]  none
+ *
+ *  @return     bool_t
+ *  @retval     TRUE for a valid packet
+ *
+ *****************************************************************************/
+static bool_t GetIntrAcpStatus ( void ){
+bool_t fStatus = FALSE;
+
+    if ( RegisterRead( REG__INTR6) & BIT__NEW_ACP_PKT ){
+        RegisterWrite( REG__INTR6,  BIT__NEW_ACP_PKT );
+        fStatus = TRUE;
+    }
+    else {
+        fStatus = FALSE;
+    }
+    return fStatus;
+}
+/*****************************************************************************/
+/**
+ *      The description of the function SetIntrAcp ()
+ *      This function sets or clears Acp interrupt mode. When Acp packets
+ *      are received at required time frame check is done using Acp time out
+ *      by polling an interrupt status
+ *
+ *  @param[in]  fEnable - enab;es or disables Acp interrupts
+ *
+ *  @return     none
+ *  @retval     void
+ *
+ *****************************************************************************/
+static void SetIntrAcp ( const bool_t fEnable ){
+
+    if ( fEnable ){
+        IfCtrl.fAcpIntr = TRUE;
+        RegisterModify( REG__INTR6_UNMASK, BIT__NEW_ACP_PKT, BIT__NEW_ACP_PKT );
+    }
+    else {
+        IfCtrl.fAcpIntr = FALSE;
+        RegisterModify( REG__INTR6_UNMASK, BIT__NEW_ACP_PKT, 0 );
+    }
+
+}
+/*****************************************************************************/
+/**
+ *      The description of the function SetIntrOnEveryNewIf()
+ *      This function enables or disables interrupt on every new info frame packet
+ *
+ *  @param[in]  fEnable - Enables interrupt on every new info packet
+ *  @param[in]  bIfType - Type of info frame packet
+ *
+ *  @return     none
+ *  @retval     void
+ *
+ *****************************************************************************/
+static void SetIntrOnEveryNewIf ( const bool_t fEnable, const uint8_t bIfType ){
+uint8_t     bBitField;
+bool_t      fError = FALSE;
+
+    if ( bIfType == IF_AVI_ID ){
+        bBitField = BIT__NEW_AVI_CTRL_INF;
+    }
+    else if ( bIfType == IF_GMT_ID ){
+        bBitField = BIT__NEW_GMT_CTRL_INF;
+    }
+    else if ( bIfType == IF_AUD_ID ){
+        bBitField = BIT__NEW_AUD_CTRL_INF;
+    }
+    else if ( bIfType == IF_ACP_ID ){
+        bBitField = BIT__NEW_ACP_CTRL_INF;
+    }
+    else {
+        DEBUG_PRINT (( "\n** SetIntrOnNewIf: wrong parametr\n"));
+        fError = TRUE;
+    }
+    if ( !fError ){
+        if ( fEnable ){
+            RegisterModify( REG__INTR_IF_CTRL, bBitField, bBitField );
+        }
+        else {
+            RegisterModify( REG__INTR_IF_CTRL, bBitField, 0 );
+        }
+    }
+}
+
+ /***** public functions ******************************************************/
+
+
+/*****************************************************************************/
+/**
+ *  The description of the function HdmiInitIf(). This function intializes Info Frame
+ *  related registers and data structures. Function calls only once
+ *
+ *  @param[in,out]      none
+ *
+ *  @return             none
+ *  @retval             void
+ *
+ *****************************************************************************/
+
+void HdmiInitIf ( void ){
+
+
+    /* clears IfCtrl structure */
+    memset ( &IfCtrl, 0, sizeof (IfCtrl_t) );
+    SET_CLR_IF(); /* set clear info frame data when rx stops receiving info frames
+                    use for Mpeg (Isrc1/Isrc2/Vsif) buffer, Acp, Gdp*/
+
+/*******************************************************************************
+
+
+ACP     ACP
+            This buffer used for ACP
+            Started with Acp interrupt, whe Acp packet received, start polling
+            to exclude
+
+SPD SPD/ISRC2
+            After receiving first SPD packet usage configured on receiving ISRC2.
+            Also consider if SPD wasn't received in 1.25 sec,
+            automatically switch to ISRC2 mode
+
+MPEG ISRC1/VS
+            Check for VSIF every second. When new AVI is detected set 1 sec window for
+            VSIF.
+
+UNREQ
+            IRSC1/ISRC2 - receive
+            VSIF        - detect, use MPEG buffer
+
+*******************************************************************************/
+    /*
+        Set decode addreses: only ACP/SPD/MPEG buffers have programmable
+        decode addresses
+    */
+    SetDecodeIfBuffers ( REG__MPEG_DECODE,  IF_ISRC1_ID );
+    SetDecodeIfBuffers ( REG__SPD_DECODE,   IF_SPD_ID );
+    /*
+        Set info frame time outs: depending on requests after reaching time outs
+        will be changed functionality of particular info frame buffer
+    */
+    /*
+        After reaching SPD time out, this info frame buffer will be used for
+        other info frames as ISRC1/2
+    */
+
+    /*  Time out is set in ms    */
+    SetIfTo ( SelSpd,    SPD_CAPTURE_TO );
+    SetIfTo ( SelAcp,    0 );
+    SetIfTo ( SelVsif,   0 );
+    SetIfTo ( SelIsrc1,  ISRC1_CAPTURE_TO );
+    /*
+        SPD_BUFF:   [SPD][ISRC2 when SPD captured or time outed]
+        MPEG_BUFF:  [ISRC1][VSIF][ISRC2 if SPD_BUFF is SPD][ISRC1][VSIF]
+    */
+    IfCtrl.fAcpIntr = TRUE;		 
+	SET_PACKET_INTR_MASK();
+	
+
+//    IfInitIfTest();
+}
+
+/*****************************************************************************/
+/**
+ *  The description of the function HdmiProcIfTo().
+ *
+ *  @param[in] wToStep  Info Frame elapsed time from previous to call
+ *                      of this function ( measured in MS)
+ *
+ *  @return             none
+ *  @retval             void
+ *
+ *****************************************************************************/
+void HdmiProcIfTo ( uint16_t wToStep  ){
+SelectIf_t id;
+
+    if ( IfCtrl.fAcpIsPresent ){
+        IfCtrl.wNoAcpTotTime += wToStep;
+    }
+    for ( id = 0; id < MaxNumIfSel; id++ ){
+        if ( IfCtrl.Ins[id].wTo ){
+            if ( IfCtrl.Ins[id].wTo > wToStep ){
+                IfCtrl.Ins[id].wTo -= wToStep;
+            }
+            else {
+                IfCtrl.Ins[id].wTo = 0;
+            }
+            if ( !IfCtrl.Ins[id].wTo ) { /* serve time outs */
+                switch ( id ){
+                    case SelVsif:
+                                    if ( IfCtrl.fVsifIsPresent && (!IfCtrl.fMpegBuff_IsrcNotFound) ){
+                                        IfCtrl.fVsifIsPresent = FALSE;
+                                        memset ( IfCtrl.abVsif, 0, IF_VSIF_SIZE );
+                                        IfCtrl.fDebug = 0;
+                                        print_mpegbuffer();
+                                        DEBUG_PRINT (( "\n** TX stops sending Vsif %X", (uint16_t)GetMpegDecodeAddr() ));
+                                    }
+                                    if ( !IfCtrl.fSpdDecodeIsrc2 && IfCtrl.fIsrc1Captured  ){
+                                        SetDecodeIfBuffers ( REG__MPEG_DECODE,  IF_ISRC2_ID );
+                                        IfCtrl.Ins[SelIsrc2].wTo      = TWO_VIDFR_CAPTURE_TO;
+                                    }
+                                    else {
+                                        SetDecodeIfBuffers ( REG__MPEG_DECODE,  IF_ISRC1_ID );
+                                        IfCtrl.Ins[SelIsrc1].wTo      = ISRC1_CAPTURE_TO;
+                                    }
+                                    break;
+                    case SelIsrc1:
+                                    SetDecodeIfBuffers ( REG__MPEG_DECODE,  IF_VSIF_ID );
+                                    IfCtrl.Ins[SelVsif].wTo      = TWO_VIDFR_CAPTURE_TO;
+                                    IfCtrl.fMpegBuff_IsrcNotFound = TRUE;
+                                    break;
+                    case SelIsrc2:
+                                    if ( !IfCtrl.fSpdDecodeIsrc2 ){ /* this tell us that we share buffer with Vsif */
+                                        IfCtrl.fMpegBuff_IsrcNotFound = TRUE;
+                                        SetDecodeIfBuffers ( REG__MPEG_DECODE,  IF_ISRC1_ID );
+                                        IfCtrl.Ins[SelIsrc1].wTo      = ISRC1_CAPTURE_TO;
+                                    }
+                                    else {
+                                    /*  do nothing as only ISRC2 used for detection */
+                                    }
+                                    break;
+                    case SelSpd:
+                                    SetDecodeIfBuffers ( REG__SPD_DECODE,  IF_ISRC2_ID );
+                                    IfCtrl.fSpdDecodeIsrc2     = TRUE;
+                                    /* As no SPD for such a long time, allocate SPD_BUFF for ISRC2*/
+                                    break;
+                    case SelAcp:
+                                    if ( GetIntrAcpStatus ()){
+										IfCtrl.fAcpIsPresent = TRUE;
+										IfCtrl.wNoAcpTotTime = 0;                                        
+                                        IfCtrl.Ins[SelAcp].wTo = ACP_CAPTURE_200MS;
+                                    }
+                                    else {
+                                        if ( IfCtrl.wNoAcpTotTime >= TIME_WO_ACP_IF ){
+                                            DEBUG_PRINT ( ( "\n** TX stops sending Acp\n"));
+                                            IfCtrl.fAcpIsPresent = FALSE;
+                                            memset ( IfCtrl.abAcp, 0, IF_ACP_SIZE);
+                                            IfCtrl.fAcpIntr = TRUE;
+											SetIntrAcp ( IfCtrl.fAcpIntr );
+                                        }
+                                        else {
+                                            IfCtrl.Ins[SelAcp].wTo = ACP_CAPTURE_200MS;
+                                        }
+                                    }
+                                    break;
+                }
+            }
+        }
+    }
+}
+
+
+/*****************************************************************************/
+/**
+ *  The description of the function InterInfoFrmProc(). Processing info frame interrupts
+ *
+ *
+ *  @param[in] bNewInfoFrm  new info frames
+ *  @param[in] bNoInfoFrm   no info frames
+ *
+ *  @return             none
+ *  @retval             void
+ *
+ *****************************************************************************/
+ /*
+        SPD_BUFF:   [SPD][IFRC2 when SPD captured]
+        MPEG_BUFF:  [ISRC1][VSIF][ISRC2 if SPD_BUFF is SPD][ISRC1][VSIF]
+ */
+void InterInfoFrmProc ( uint8_t bNewInfoFrm, uint8_t bNoInfoFrm ){
+uint8_t bIfType;
+
+    if ( bNewInfoFrm ){
+        if ( bNewInfoFrm & BIT__NEW_AVI_INF ){
+            if ( IfCtrl.fIntrOnEveryNewAvi ){
+                /* set Avi interrupt on change */
+                IfCtrl.fIntrOnEveryNewAvi =  FALSE;
+                SetIntrOnEveryNewIf ( FALSE, IF_AVI_ID );
+            }
+            DEBUG_PRINT (("* Got Avi\n"));
+            SetToIfBuff ( IF_AVI_ID );
+            if ( GetIf ( IF_AVI_ID )){
+                DEBUG_PRINT ((" valid" ));
+            }
+        }
+        if ( bNewInfoFrm & BIT__VIRT_NEW_GDB_INF ){
+            if ( IfCtrl.fIntrOnEveryNewGamut ){
+                /* set Gamut interrupt on change */
+                IfCtrl.fIntrOnEveryNewGamut =  FALSE;
+                SetIntrOnEveryNewIf ( FALSE, IF_GMT_ID );
+            }
+            DEBUG_PRINT (( "\n* Got Gdb\n"));
+            /* TODO: add processing */
+        }
+        if ( bNewInfoFrm & BIT__NEW_MPEG_INF ){
+//            DEBUG_PRINT (( "\n* Got if in Mpeg buff: " );
+            /* this buffer is used for Vsif and Isrc1/2*/
+#if 0
+            if ( IfCtrl.bDecodeTypeMpegBuffer == IF_VSIF_ID ){
+                if ( GetIf( IF_VSIF_ID, IfCtrl.bDecodeTypeMpegBuffer ) ){
+                }
+            }
+            else if (   (IfCtrl.bDecodeTypeMpegBuffer == IF_ISRC1_ID) ||
+                (IfCtrl.bDecodeTypeMpegBuffer == IF_ISRC2_ID) ){
+            }
+#endif
+            IfCtrl.fMpegBuff_IsrcNotFound = FALSE;
+            if ( GetIfRoll( REG__MPEG_TYPE, &bIfType )){
+            }
+            SetToIfBuff ( bIfType );
+        }
+        if ( bNewInfoFrm & BIT__NEW_AUD_INF ){
+            if ( IfCtrl.fIntrOnEveryNewAud ){
+                /* set Aud interrupt on change */
+                IfCtrl.fIntrOnEveryNewAud =  FALSE;
+                SetIntrOnEveryNewIf ( FALSE, IF_AUD_ID );
+            }
+            DEBUG_PRINT ( ( "\n* Got Aud\n"));
+            SetToIfBuff ( IF_AUD_ID );
+        }
+        if ( bNewInfoFrm & BIT__VIRT_NEW_ACP_INF ){
+
+            DEBUG_PRINT (( "\n* Got Acp\n" ));
+            GetIf ( IF_ACP_ID );
+            SetToIfBuff ( IF_ACP_ID );
+			IfCtrl.fAcpIsPresent = TRUE;
+            if ( IfCtrl.fAcpIntr ){
+                /*  Disable Acp Interrupts until IfCtrl.fAcpIsPresent  */
+
+                IfCtrl.fAcpIntr = FALSE;
+				SetIntrAcp ( IfCtrl.fAcpIntr );
+                SetIntrOnEveryNewIf ( TRUE, IF_ACP_ID );
+            }
+        }
+        if ( bNewInfoFrm & BIT__NEW_SPD_INF ){
+            DEBUG_PRINT (( "\n* Got Spd buff: type %x\n", (uint16_t)IfCtrl.bDecodeTypeSpdBuffer ));
+            /* this buffer is used for Spd and Isrc2*/
+            if ( GetIfRoll( REG__SPD_TYPE, &bIfType )){
+            }
+            SetToIfBuff ( bIfType );
+        }
+    }
+    if ( bNoInfoFrm ){
+        if ( bNoInfoFrm & BIT__VIRT_NO_AVI_INF ){
+            DEBUG_PRINT (( "* Lost Avi\n" ));
+            /* set interrupt on every new Avi packet */
+            IfCtrl.fIntrOnEveryNewAvi = TRUE;
+            SetIntrOnEveryNewIf ( TRUE, IF_AVI_ID );
+        }
+        if ( bNoInfoFrm & BIT__NO_GDB_INF ){
+            DEBUG_PRINT (( "* Lost Gdb\n" ));
+            /* set interrupt on every new Gamut packet */
+            IfCtrl.fIntrOnEveryNewGamut = TRUE;
+            SetIntrOnEveryNewIf ( TRUE, IF_GMT_ID );
+        }
+        if ( bNoInfoFrm & BIT__NO_AUD_INF ){
+            DEBUG_PRINT (( "* Lost Aud\n" ));
+            /* set interrupt on every new Audio packet */
+            IfCtrl.fIntrOnEveryNewAud = TRUE;
+            SetIntrOnEveryNewIf ( TRUE, IF_AUD_ID );
+        }
+    }
+}
+
+#endif //#if (CONF__SUPPORT_3D == ENABLE)
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/infofrm.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/infofrm.h
new file mode 100755
index 000000000000..70165a377a5a
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/infofrm.h
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ * Copyright 2008, Silicon Image, Inc.  All rights reserved.  
+ * No part of this work may be reproduced, modified, distributed, transmitted,
+ * transcribed, or translated into any language or computer format, in any form
+ * or by any means without written permission of: Silicon Image, Inc., 1060
+ * East Arques Avenue, Sunnyvale, California 94085
+ * 
+ *****************************************************************************/
+/**
+ * @file infofrm.h
+ *
+ * This is a description of the file. 
+ *
+ * $Author: $Vladimir Grekhov
+ * $Rev: $
+ * $Date: $9-15-09
+ *
+ *****************************************************************************/
+
+#ifndef _INFOFRM_H
+#define _INFOFRM_H
+
+/***** macro definitions *****************************************************/
+
+/***** public type definitions ***********************************************/
+
+/***** public function prototypes ********************************************/
+
+/*****************************************************************************/
+/**
+ *  The description of the function HdmiInitIf(). This function intializes Info Frame 
+ *	related registers and data structures. Function should be called only once		
+ *
+ *  @param[in,out]      none
+ *
+ *  @return             none
+ *  @retval             void
+ *
+ *****************************************************************************/
+
+void HdmiInitIf ( void );
+
+/*****************************************************************************/
+/**
+ *  The description of the function HdmiProcIfTo(). This function handles info frame 
+ *	time outs		
+ *
+ *  @param[in] wToStep  Info Frame elapsed from previous to call ( measured in MS)
+ *
+ *  @return             none
+ *  @retval             void
+ *
+ *****************************************************************************/
+
+void HdmiProcIfTo ( uint16_t wToStep  );
+
+/*****************************************************************************/
+/**
+ *  The description of the function InterInfoFrmProc(). Processing info frame interrupts
+ *
+ *
+ *  @param[in] bNewInfoFrm  new info frames
+ *  @param[in] bNoAvi		no Avi info frames
+ *  @param[in] bNoInfoFrm	no info frames
+ *
+ *  @return             none
+ *  @retval             void
+ *
+ *****************************************************************************/
+
+void InterInfoFrmProc ( uint8_t bNewInfoFrm,
+					/*	uint8_t bNoAvi,*/
+						uint8_t bNoInfoFrm );
+
+#else /* _INFOFRM_H */
+
+
+#endif /* _INFOFRM_H */
\ No newline at end of file
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/interrupt.c b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/interrupt.c
new file mode 100755
index 000000000000..4ae6dc5e6e1a
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/interrupt.c
@@ -0,0 +1,692 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#include <local_types.h>
+#include <config.h>
+#include <hal.h>
+#include <registers.h>
+#include <amf.h>
+#if (CONF__SUPPORT_3D == ENABLE)	  
+#include "infofrm.h"
+#endif //#if (CONF__SUPPORT_3D == ENABLE)
+
+
+//------------------------------------------------------------------------------
+// Choose interrupt polling method
+//------------------------------------------------------------------------------
+
+//read interrupt register bit
+#define INTERRUPT_PENDING  ((RegisterRead(REG__INTR_STATE) & (BIT__INTR_GROUP0|BIT__INTR_GROUP1)) != 0)
+
+
+
+
+
+//------------------------------------------------------------------------------
+// Function: SetupInterruptMasks
+// Description: Configure interrupt mask registers.
+//              Any unmasked interrupt causes the hardware interrupt pin to be set when pendng.
+//------------------------------------------------------------------------------
+void SetupInterruptMasks(void)
+{
+    uint8_t abIntrMasks[8];
+
+    abIntrMasks[0] = 0;
+    abIntrMasks[1] = BIT__SCDT_CHG;
+    abIntrMasks[2] = 0;
+    abIntrMasks[3] = 0;
+    abIntrMasks[4] = BIT__VRCHG | BIT__HRCHG;
+    abIntrMasks[5] = BIT__NEW_ACP_PKT;  //check ACP type2 packet
+    abIntrMasks[6] = BIT__VIDEO_READY;
+    abIntrMasks[7] = BIT__NO_ACP_INF;
+
+
+#if (CONF__ODCK_LIMITED==ENABLE)
+    abIntrMasks[6] |= BIT__PCLK_STOP;
+#endif //(CONF__ODCK_LIMITED==ENABLE)
+
+    RegisterWriteBlock(REG__INTR1_UNMASK, &abIntrMasks[0], 4);
+    RegisterWriteBlock(REG__INTR5_UNMASK, &abIntrMasks[4], 2);
+    RegisterWriteBlock(REG__INTR7_UNMASK, &abIntrMasks[6], 2);
+
+}
+
+//------------------------------------------------------------------------------
+// Function: ResetZoneControl
+// Description:
+// Note: reset the zone
+//------------------------------------------------------------------------------
+
+#if(PEBBLES_ES1_ZONE_WORKAROUND == ENABLE)
+
+static void ResetZoneControl()
+{
+    {
+        RegisterWrite(REG__FACTORY_A87,0x03);
+        RegisterWrite(REG__FACTORY_A81,0x10);
+        RegisterWrite(REG__FACTORY_A88,0x40);
+        RegisterWrite(REG__FACTORY_A87,0x43);
+        RegisterWrite(REG__FACTORY_A81,0x18);
+        DEBUG_PRINT(("reset zone\n"));
+        CurrentStatus.AudioState = STATE_AUDIO__REQUEST_AUDIO;
+        CurrentStatus.VideoState = STATE_VIDEO__MUTED;
+    }
+
+}
+#if (PEBBLES_VIDEO_STATUS_2ND_CHECK==ENABLE)
+//------------------------------------------------------------------------------
+// Function: PclkCheck
+// Description:  check if the pclk stopped by reading the xpcnt register
+//------------------------------------------------------------------------------
+
+uint8_t PclkCheck(void)
+{
+    uint8_t xpcnt0_0;
+    uint8_t xpcnt1_0;
+    uint8_t xpcnt0_1;
+    uint8_t xpcnt1_1;
+    uint8_t wrongzone = 0;
+
+
+    if((RegisterRead(REG__STATE))&BIT__PCLK_STABLE) //pclk stable
+    {
+        xpcnt0_0 = RegisterRead(0x06E);
+        xpcnt1_0 = RegisterRead(0x06F);
+        RegisterWrite(0x069,0x80);      //change base
+
+//      DEBUG_PRINT(("full cnt=%02X %02X  ",(int)xpcnt0_0, (int)xpcnt1_0));
+        xpcnt0_1 = RegisterRead(0x06E);
+        xpcnt1_1 = RegisterRead(0x06F);
+//      DEBUG_PRINT(("half cnt=%02X %02X\n",(int)xpcnt0_1, (int)xpcnt1_1));
+
+        RegisterWrite(0x069,0xFF);
+
+		if((xpcnt0_0==xpcnt0_1)&&(xpcnt1_0 <= xpcnt1_1))  //if xpcnt changes
+            wrongzone=1;
+        else
+            return TRUE;
+    }
+    else
+    {
+        wrongzone=1;
+    }
+    if(wrongzone==1)
+    {
+        DEBUG_PRINT(("pclk stopped"));
+        TurnVideoMute(ON);
+        CurrentStatus.ColorDepth = 0;
+        RegisterModify(REG__TMDS_CCTRL2, MSK__DC_CTL, VAL__DC_CTL_8BPP_1X);
+    }
+
+    return FALSE;
+}
+#endif //#if (PEBBLES_VIDEO_STATUS_2ND_CHECK==ENABLE)
+//------------------------------------------------------------------------------
+// Function: ConfigureZone
+// Description:
+// Note: check pclk status to configure the zone
+//------------------------------------------------------------------------------
+
+static uint8_t ConfigureZone(void)
+{
+
+    if((RegisterRead(REG__STATE))&BIT__PCLK_STABLE) //pclk stable
+    {
+        return TRUE;
+    }
+    else
+    {
+        DEBUG_PRINT((" **** pclk not stable\n"));
+        ResetZoneControl();
+    }
+
+    return FALSE;
+}
+
+//------------------------------------------------------------------------------
+// Function: ResetVideoControl
+// Description:
+// Note: check pclk status to configure the zone
+//------------------------------------------------------------------------------
+uint8_t ResetVideoControl(void)
+{
+    if(RegisterRead(REG__HDMI_MUTE)&BIT__VIDM_STATUS)
+    {
+        DEBUG_PRINT(("reset video control\n"));
+        TurnVideoMute(ON);
+        CurrentStatus.ColorDepth = 0;
+        RegisterModify(REG__TMDS_CCTRL2, MSK__DC_CTL, VAL__DC_CTL_8BPP_1X);
+        ResetZoneControl();
+        return FALSE;
+    }
+    else //video unmute status OK
+    {
+        TurnVideoMute(OFF);
+        return TRUE;
+    }
+
+}
+#endif
+//------------------------------------------------------------------------------
+// Function: SetUpAudioOutput
+// Description: Setup registers for audio output formatting for each format (PCM, DSD, HBR)
+//              Each frmat has its own unique MCLK value.
+//              Only PCM and DSD support multi channel output.
+//
+// Notes: Compile time configuration is done using CONF__* defines in config.h
+//------------------------------------------------------------------------------
+static void SetUpAudioOutput(void)
+{
+    uint8_t bAudioStatus;
+
+
+    bAudioStatus = RegisterRead(REG__AUDP_STAT);
+
+    if (bAudioStatus & BIT__DSD_STATUS) //DSD Audio
+    {
+        if(CurrentStatus.AudioMode!=AUDIO_MODE__DSD)
+        {
+            CurrentStatus.AudioMode = AUDIO_MODE__DSD;
+
+            RegisterWrite(REG__I2S_CTRL1, CONF__DSD__I2S_CTRL1);
+
+            if (bAudioStatus & BIT__HDMI_LO) //layout = 1, enable multi channel
+                RegisterWrite(REG__I2S_CTRL2, CONF__DSD__I2S_CTRL2__LAYOUT_1 | BIT__MCLKEN);  //enable MCLK
+            else  //layout = 0, enable 2 channel only
+                RegisterWrite(REG__I2S_CTRL2, CONF__DSD__I2S_CTRL2__LAYOUT_0 | BIT__MCLKEN);  //enable MCLK
+            DEBUG_PRINT(("DSD aud\n"));
+
+        }
+    }
+    else if (bAudioStatus & BIT__HBRA_ON) //HBR Audio
+    {
+
+        CurrentStatus.AudioMode = AUDIO_MODE__HBR;
+
+        RegisterWrite(REG__I2S_CTRL1, CONF__HBR__I2S_CTRL1);
+        RegisterWrite(REG__I2S_CTRL2, CONF__HBR__I2S_CTRL2 | BIT__MCLKEN);  //enable MCLK
+        DEBUG_PRINT(("HBR aud\n"));
+
+
+
+    }
+    else
+    {
+        if(CurrentStatus.AudioMode!=AUDIO_MODE__PCM)
+        {
+            CurrentStatus.AudioMode = AUDIO_MODE__PCM;
+            RegisterWrite(REG__I2S_CTRL1, CONF__PCM__I2S_CTRL1);
+
+            if (bAudioStatus & BIT__HDMI_LO) //layout = 1, enable multi channel
+                RegisterWrite(REG__I2S_CTRL2, CONF__PCM__I2S_CTRL2__LAYOUT_1 | BIT__MCLKEN);  //enable MCLK
+            else  //layout = 0, enable 2 channel only
+                RegisterWrite(REG__I2S_CTRL2, CONF__PCM__I2S_CTRL2__LAYOUT_0 | BIT__MCLKEN);  //enable MCLK
+            DEBUG_PRINT(("PCM aud\n"));
+        }
+    }
+
+}
+//------------------------------------------------------------------------------
+// Function: AcpPacketHandler
+// Description: disable digital output for ACP type 2 and above
+//
+//------------------------------------------------------------------------------
+static void AcpPacketHandler(uint8_t qOn)
+{
+    //disable SPIDF when ACP type >=2 For simply test.
+    if((qOn)&&(RegisterRead(REG__ACP_BYTE2) > 1))
+    {
+        RegisterWrite(REG__AUD_CTRL, (CONF__AUD_CTRL&(~BIT__SPEN)));
+        DEBUG_PRINT(("ACP type > 1, digital output blocked\n"));
+    }
+    else
+        RegisterWrite(REG__AUD_CTRL, CONF__AUD_CTRL);
+}
+
+//------------------------------------------------------------------------------
+// Function: AudioUnmuteHandler
+// Description: State machine for performing audio unmute in firmware.
+//------------------------------------------------------------------------------
+void AudioUnmuteHandler(void)
+{
+    uint8_t bIntrStatus2;
+    uint8_t bIntrStatus4;
+
+    RegisterModify(REG__ECC_CTRL, BIT__CAPCNT, SET);        //clear the error cont
+    switch (CurrentStatus.AudioState)
+    {
+        case STATE_AUDIO__REQUEST_AUDIO:
+        {
+            bIntrStatus2 = RegisterRead(REG__INTR2);
+            bIntrStatus4 = RegisterRead(REG__INTR4);
+
+            if ((bIntrStatus2 & BIT__GOTAUD) && (bIntrStatus2 & BIT__GOTCTS))        //audio stable
+            {
+                if(bIntrStatus4 & MSK__CTS_ERROR)
+                    // reset ACR
+                    RegisterBitToggle(REG__SRST, BIT__ACRRST);
+                else
+                {
+                    // init ACR
+                    RegisterWrite(REG__ACR_CTRL1, BIT__ACR_INIT);
+
+                    DEBUG_PRINT(("aud rdy\n"));
+
+                    SetUpAudioOutput();
+                    CurrentStatus.AudioState = STATE_AUDIO__AUDIO_READY;
+                }
+            }
+
+
+                // clear all the audio interrupts
+                RegisterWrite(REG__INTR2, (BIT__GOTAUD    | BIT__GOTCTS));
+                RegisterWrite(REG__INTR4, (MSK__CTS_ERROR | MSK__FIFO_ERROR));
+
+                TIMER_Set(TIMER__AUDIO, 20);  // delay 20ms before request audio again
+
+        }
+        break;
+
+        case STATE_AUDIO__AUDIO_READY:
+        {
+            bIntrStatus4 = RegisterRead(REG__INTR4);
+            if(bIntrStatus4 & MSK__CTS_ERROR)
+                CurrentStatus.AudioState = STATE_AUDIO__REQUEST_AUDIO;
+
+            else if (!(bIntrStatus4 & MSK__FIFO_ERROR))      // no audio FIFO error
+            {
+                if ((CurrentStatus.VideoState == STATE_VIDEO__ON)
+                    ||(CurrentStatus.VideoState == STATE_VIDEO__CHECKED))
+                    //||ResetVideoControl())//video unmute status ok
+                {
+                    if(CurrentStatus.AudioMode==AUDIO_MODE__DSD)
+                        HAL_SetAudioDACMode(AUDIO_MODE__DSD);
+                    else
+                        HAL_SetAudioDACMode(AUDIO_MODE__PCM);
+
+                    RegisterWrite(REG__INTR5, MSK__AUDIO_INTR);// clear all audio interrupts
+                    CurrentStatus.AudioState = STATE_AUDIO__ON;
+                    TurnAudioMute(OFF);
+                }
+            }
+            else
+            {
+                // reset audio FIFO
+                RegisterBitToggle(REG__SRST, BIT__FIFORST);
+
+                // clear audio FIFO interrupts
+                RegisterWrite(REG__INTR4, MSK__FIFO_ERROR);
+
+                TIMER_Set(TIMER__AUDIO, 20);  // delay 20ms before ready audio again
+            }
+        }
+    }
+}
+
+
+
+
+
+//------------------------------------------------------------------------------
+// Function: ProcessScdtModeChange
+// Description: Process SYNC detect on and off changes
+//              This function is only called when the SCDT_CHG interrupt is set.
+//------------------------------------------------------------------------------
+extern void sii9233a_output_mode_trigger(unsigned int flag);
+
+static void ProcessScdtModeChange(void)
+{
+    uint8_t bStateReg;
+    static uint8_t current_scdt = 0;
+
+    bStateReg = RegisterRead(REG__STATE);  //read scdt off or on
+
+    if (bStateReg & BIT__SCDT) //SCDT on
+    {
+        //mute the audio if it is still on, it happens when SCDT off and on in a very short time
+        if(CurrentStatus.AudioState == STATE_AUDIO__ON)
+        {
+            TurnAudioMute(ON);
+            CurrentStatus.AudioState = STATE_AUDIO__MUTED;
+        }
+
+        CurrentStatus.ColorDepth = 0;
+        RegisterModify(REG__TMDS_CCTRL2, MSK__DC_CTL, VAL__DC_CTL_8BPP_1X);
+
+        CurrentStatus.ResolutionChangeCount = 0;
+        CurrentStatus.VideoStabilityCheckCount = 0;
+
+        CurrentStatus.AudioState = STATE_AUDIO__REQUEST_AUDIO;
+        RegisterModify(REG__ECC_CTRL, BIT__CAPCNT, SET);        //clear the error cont
+        CurrentStatus.VideoState = STATE_VIDEO__UNMUTE;
+        TIMER_Set(TIMER__VIDEO, VIDEO_UNMUTE_TIMEOUT);  // start the video timer
+
+		HdmiInitIf(); //yma add for 3D packet support
+        printk("sii9233a SCDT on!\n");
+        if( current_scdt == 0 )
+        {
+            sii9233a_output_mode_trigger(1);
+            current_scdt = 1;
+        }
+    }
+    else //SCDT off
+    {
+        TurnVideoMute(ON);
+        printk("sii9233a SCDT off!\n");
+        if( current_scdt == 1 )
+        {
+            sii9233a_output_mode_trigger(0);
+            current_scdt = 0;
+        }
+    }
+}
+
+//------------------------------------------------------------------------------
+// Function: ConfigureDeepColor
+// Description: Configure the deep color clock based on input video format.
+//              Change is made only when input color depth changes.
+//------------------------------------------------------------------------------
+
+static void ConfigureDeepColor(void)
+{
+    uint8_t abDcCtlVal1x[] = { VAL__DC_CTL_8BPP_1X, VAL__DC_CTL_10BPP_1X, VAL__DC_CTL_12BPP_1X, 0 };
+    uint8_t abDcCtlVal2x[] = { VAL__DC_CTL_8BPP_2X, VAL__DC_CTL_10BPP_2X, VAL__DC_CTL_12BPP_2X, 0 };
+    uint8_t bColorDepth;
+    uint8_t bDcCtlValue;
+    uint8_t vStatus;
+
+    bColorDepth = RegisterRead(REG__DC_STAT) & MSK__PIXEL_DEPTH;
+
+
+    if (bColorDepth != CurrentStatus.ColorDepth)
+    {
+        if(CurrentStatus.VideoState == STATE_VIDEO__ON)
+            vStatus = ON;
+        CurrentStatus.ColorDepth = bColorDepth;
+
+        if(vStatus == ON)
+            TurnVideoMute(ON);
+
+        //value is 2x if muxYC output is enabled
+        if (RegisterRead(REG__VID_AOF) & BIT__MUXYC)
+        {
+            bDcCtlValue = abDcCtlVal2x[ bColorDepth ];
+        }
+        else
+        {
+            bDcCtlValue = abDcCtlVal1x[ bColorDepth ];
+        }
+        RegisterModify(REG__TMDS_CCTRL2, MSK__DC_CTL, bDcCtlValue);
+        RegisterBitToggle(REG__SRST2, BIT__DCFIFO_RST);  //reset the deep color FIFO
+
+        DEBUG_PRINT(("DC stat=%02X ctl=%02X\n", (int)bColorDepth, (int)bDcCtlValue));
+
+        if(vStatus == ON)
+            TurnVideoMute(OFF);
+    }
+}
+
+
+
+
+
+//------------------------------------------------------------------------------
+// Function: TurnAudioMute
+// Description:
+// Note: ON is to mute, OFF is to unmute
+//------------------------------------------------------------------------------
+void TurnAudioMute (uint8_t qOn)
+{
+
+    if (qOn) //mute
+    {
+        //mute audio
+        RegisterModify(REG__HDMI_MUTE, BIT__AUDM, SET);
+
+        //AAC off
+        RegisterModify(REG__AEC_CTRL, BIT__AAC_EN, CLEAR);
+        RegisterModify(REG__INTR5_UNMASK, BIT__AACDONE, CLEAR);  //AAC intr off
+
+        //power down the audio DAC
+        HAL_PowerDownAudioDAC();
+
+        DEBUG_PRINT(("Audio off\n"));
+
+    }
+    else //unmute
+    {
+        //AAC on
+        RegisterModify(REG__INTR5_UNMASK, BIT__AACDONE, SET);   //AAC intr on
+        RegisterModify(REG__AEC_CTRL, (BIT__AAC_EN ), SET); //AAC enable
+
+        //unmute audio
+        RegisterModify(REG__HDMI_MUTE, BIT__AUDM, CLEAR);
+
+        //power up the audio DAC
+        if(CurrentStatus.AudioMode!=AUDIO_MODE__HBR)
+            HAL_WakeUpAudioDAC();
+
+        DEBUG_PRINT(("Audio on\n"));
+
+    }
+}
+
+
+
+
+
+
+//------------------------------------------------------------------------------
+// Function: TurnPowerDown
+// Description: Enter or exit powerdown mode
+// Note: ON is to powerdown, OFF is to wakeup
+//------------------------------------------------------------------------------
+void TurnPowerDown(uint8_t qOn)
+{
+    if (qOn) //powerDown
+    {
+        RegisterModify(REG__SYS_CTRL1, BIT__PD, CLEAR);
+    }
+    else  //wakeup
+    {
+        RegisterModify(REG__SYS_CTRL1, BIT__PD, SET);
+        DEBUG_PRINT(("wake up\n"));
+    }
+}
+
+
+
+
+#if (PEBBLES_ES1_FF_WORKAROUND == ENABLE)
+//------------------------------------------------------------------------------
+// Function: ProcessVhResolutionChange
+// Description: workaround for zone detection issue with FF part
+//------------------------------------------------------------------------------
+
+static uint8_t ProcessVhResolutionChange(void)
+{
+    if (CurrentStatus.ResolutionChangeCount++ == 10)
+        {
+            CurrentStatus.ResolutionChangeCount = 0;
+            DEBUG_PRINT((" **** VHreschng\n"));
+            if((RegisterRead(REG__FACTORY_A88)&0x0F)>=0x02) //not 1x zone
+            ResetZoneControl();
+            return TRUE;
+        }
+    return FALSE;
+}
+#endif
+
+#if (CONF__ODCK_LIMITED==ENABLE)
+//------------------------------------------------------------------------------
+// Function: ProcessOdckStop
+// Description: handles the ODCK (internally pclk) stop interrupt
+//------------------------------------------------------------------------------
+static void ProcessOdckStop(void)
+{
+     RegisterModify(REG__DRIVE_CNTL, MSK__ODCK_STRENGTH,CLEAR);  //clear the ODCK first
+     RegisterModify(REG__SYS_PSTOP,BIT__PSTOP_EN, CLEAR);        //disable PSTOP feature
+     RegisterModify(REG__INTR7,BIT__PCLK_STOP,SET);              //clear the interrupt
+
+}
+#endif //(CONF__ODCK_LIMITED==ENABLE)
+//------------------------------------------------------------------------------
+// Function: TurnVideoMute
+// Description: Enable or disable Video Mute
+// Note: ON is to mute, OFF is to unmute
+//------------------------------------------------------------------------------
+void TurnVideoMute(uint8_t qOn)
+{
+    if (qOn) //mute
+    {
+        RegisterModify(REG__HDMI_MUTE, BIT__VIDM, SET);
+        CurrentStatus.VideoState = STATE_VIDEO__MUTED;
+        DEBUG_PRINT(("Video off\n"));
+
+    }
+    else  //unmute
+    {
+#if(PEBBLES_ES1_ZONE_WORKAROUND == ENABLE)
+        if((RegisterRead(REG__STATE)& BIT__SCDT)            //check sync status
+            &&ConfigureZone())
+#endif
+        {
+#if (CONF__ODCK_LIMITED==ENABLE)
+     RegisterModify(REG__SYS_PSTOP,BIT__PSTOP_EN, SET);      //enable PSTOP feature
+     RegisterModify(REG__DRIVE_CNTL, MSK__ODCK_STRENGTH,SET);    //clear the ODCK first
+#endif// #if (CONF__ODCK_LIMITED==ENABLE)
+
+            RegisterModify(REG__HDMI_MUTE, BIT__VIDM, CLEAR);
+            CurrentStatus.VideoState = STATE_VIDEO__ON;
+            DEBUG_PRINT(("Video on\n"));
+#if (PEBBLES_VIDEO_STATUS_2ND_CHECK==ENABLE)
+            TIMER_Set(TIMER__VIDEO, VIDEO_STABLITY_CHECK_INTERVAL);  // start the video timer
+            CurrentStatus.VideoStabilityCheckCount = 0;
+#endif//#if (PEBBLES_VIDEO_STATUS_2ND_CHECK==ENABLE)
+
+        }
+
+    }
+}
+//------------------------------------------------------------------------------
+// Function: InterruptHandler
+// Description: Main interrupt handler called when HDMI interrupt is pending.
+//              All pending interrupts are cleared immediately.
+//              Each pending interrupt is then handled by calling the associated handler function.
+//------------------------------------------------------------------------------
+#define INTR3_NEW_INFOFR            2
+#define INTR3_NEW_INFOFR_SEL        0x1F
+
+#define INTR4_NO_AVI                3
+#define INTR4_NO_AVI_SEL            0x10
+
+#define INTR5_NEW_ACP               5
+#define INTR5_NEW_ACP_SEL           0x04
+
+#define INTR8_NEW_GMT_NO_INFOFR     7
+#define INTR8_NEW_GMT_SEL           0x80
+#define INTR8_NO_INFOFR_SEL         0x7E
+
+static void InterruptHandler(void)
+{
+    uint8_t abIntrStatus[8];
+    uint8_t bNewInfoFrm	= 0;
+    uint8_t bNoInfoFrm		= 0;
+
+    //read all interrupt registers
+    RegisterReadBlock(REG__INTR1, &abIntrStatus[0], 4);
+    RegisterReadBlock(REG__INTR5, &abIntrStatus[4], 2);
+
+    RegisterReadBlock(REG__INTR7, &abIntrStatus[6], 2);
+
+#if 0
+    DEBUG_PRINT(("i: %02X %02X %02X %02X %02X %02X %02X %02X\n",
+                (int)abIntrStatus[0],(int)abIntrStatus[1],(int)abIntrStatus[2],(int)abIntrStatus[3],
+                (int)abIntrStatus[4],(int)abIntrStatus[5],(int)abIntrStatus[6],(int)abIntrStatus[7]));
+#endif
+    //clear all pending interrupts
+    RegisterWriteBlock(REG__INTR1, &abIntrStatus[0], 4);
+    RegisterWriteBlock(REG__INTR5, &abIntrStatus[4], 2);
+    RegisterWriteBlock(REG__INTR7, &abIntrStatus[6], 2);
+
+#if (CONF__ODCK_LIMITED==ENABLE)
+    if (abIntrStatus[6] & BIT__PCLK_STOP)   //ODCK stopped
+    {
+        DEBUG_PRINT(("ODCK stopped\n"));
+        ProcessOdckStop();
+    }
+#endif //#if (CONF__ODCK_LIMITED==ENABLED)
+
+    // process pending interrupts
+    if (abIntrStatus[1] & BIT__SCDT_CHG)    //if SCDT change
+        ProcessScdtModeChange();
+
+    if (abIntrStatus[4] & BIT__AACDONE)    //if soft mute done
+    {
+        TurnAudioMute(ON);
+        CurrentStatus.AudioState = STATE_AUDIO__REQUEST_AUDIO;
+    }
+#if (CONF__VSYNC_OVERFLOW == ENABLE)
+    if (abIntrStatus[4] & BIT__HRCHG )       //if H res change
+#else
+    if (abIntrStatus[4] & (BIT__HRCHG|BIT__VRCHG))       //if H/V res change
+#endif
+    {
+#if (PEBBLES_ES1_FF_WORKAROUND == ENABLE)
+        if (!ProcessVhResolutionChange())
+#endif
+        ConfigureDeepColor();
+    }
+
+    if (abIntrStatus[5] & BIT__NEW_ACP_PKT)
+       AcpPacketHandler(ON);
+
+    if (abIntrStatus[6] & BIT__VIDEO_READY) //video ready for unmute
+    {
+        DEBUG_PRINT(("Video rdy\n"));
+        TurnVideoMute(OFF);
+    }
+
+    if (abIntrStatus[7] & BIT__NO_ACP_INF)  // no ACP pkt
+       AcpPacketHandler(OFF);
+
+#if (CONF__SUPPORT_3D == ENABLE)
+    /*****  Processing info frame interrupts    ***********************/
+    bNewInfoFrm = abIntrStatus[INTR3_NEW_INFOFR] & INTR3_NEW_INFOFR_SEL;
+    bNoInfoFrm = abIntrStatus[INTR8_NEW_GMT_NO_INFOFR] & INTR8_NO_INFOFR_SEL;
+    if( abIntrStatus[INTR4_NO_AVI] & INTR4_NO_AVI_SEL ){
+        bNoInfoFrm |= BIT__VIRT_NO_AVI_INF;
+    }
+    if ( abIntrStatus[INTR8_NEW_GMT_NO_INFOFR] & BIT__NEW_GDB_INF ){
+        bNewInfoFrm |= BIT__VIRT_NEW_GDB_INF;
+    }
+    if ( abIntrStatus[INTR5_NEW_ACP] & BIT__NEW_ACP_PKT ){
+        bNewInfoFrm |= BIT__VIRT_NEW_ACP_INF;
+    }
+    /*  Check if any of info frame interrupts has occured   */
+    if( bNewInfoFrm || bNoInfoFrm ){
+        InterInfoFrmProc ( bNewInfoFrm, bNoInfoFrm );
+    }
+#endif //#if (CONF__SUPPORT_3D == ENABLE)
+
+    /*****  End Processing info frame interrupts    ***********************/
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: PollInterrupt
+// Description: Poll for HDMI interrupt.
+//              This can be polling the interrupt pin on the processor,
+//              or polling the register over I2C.
+//------------------------------------------------------------------------------
+void PollInterrupt(void)
+{
+    if (INTERRUPT_PENDING)
+         InterruptHandler();
+}
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/main.c b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/main.c
new file mode 100755
index 000000000000..ef499370207b
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/main.c
@@ -0,0 +1,354 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <local_types.h>
+#include <config.h>
+#include <hal.h>
+//#include <debug_cmd.h>
+#include <registers.h>
+#include <amf.h>
+#include "infofrm.h"
+
+#include <CEC.h>
+
+
+//------------------------------------------------------------------------------
+// Global State Structure
+//------------------------------------------------------------------------------
+GlobalStatus_t CurrentStatus;
+
+
+
+//------------------------------------------------------------------------------
+// Function: AutoVideoSetup
+// Description: Setup registers for Auto Video Mode
+//
+// Notes: Compile time configuration is done using CONF__* defines in config.h
+//------------------------------------------------------------------------------
+static void AutoVideoSetup(void)
+{
+    
+	const uint8_t unmuteTimeConf[] = {0xFF,0x00,0x00,0xFF,0x00,0x00};
+	RegisterWriteBlock(REG__WAIT_CYCLE, &unmuteTimeConf[0],6);	//video unmute wait 
+
+    RegisterWrite(REG__VID_CTRL,  (BIT__IVS   & CONF__VSYNC_INVERT) |
+                                  (BIT__IHS   & CONF__HSYNC_INVERT) );  //set HSYNC,VSNC polarity
+    RegisterWrite(REG__RPI_AUTO_CONFIG, BIT__CHECKSUM_EN|BIT__V_UNMUTE_EN|BIT__HCDP_EN|BIT__TERM_EN);        //auto config
+    RegisterWrite(REG__SRST,      BIT__SWRST_AUTO);            //enable auto sw reset
+    RegisterWrite(REG__VID_AOF,   CONF__OUTPUT_VIDEO_FORMAT);  //set output video format
+    RegisterModify(REG__AEC_CTRL,  BIT__AVC_EN, SET);                //enable auto video configuration
+
+#if (CONF__ODCK_LIMITED == ENABLE)
+	RegisterModify(REG__SYS_PSTOP, MSK__PCLK_MAX, CONF__PCLK_MAX_CNT);
+#endif //(CONF__ODCK_LIMITED==ENABLE)
+
+
+#if (PEBBLES_ES1_ZONE_WORKAROUND == ENABLE)	
+	RegisterWrite(REG__AVC_EN2, BIT__AUTO_DC_CONF);			   //mask out auto configure deep color clock
+	RegisterWrite(REG__VIDA_XPCNT_EN, BIT__VIDA_XPCNT_EN);	   //en read xpcnt
+#endif //(PEBBLES_ES1_ZONE_WORKAROUND == ENABLE)	 
+
+#if (PEBBLES_STARTER_NO_CLK_DIVIDER == ENABLE)
+	RegisterModify(REG__AVC_EN2, BIT__AUTO_CLK_DIVIDER,SET);	  //msk out auto clk divider
+#endif //(PEBBLES_STARTER_NO_CLK_DIVIDER == ENABLE)
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: AutoAudioSetup
+// Description: Setup registers for Auto Audio Mode
+//------------------------------------------------------------------------------
+static void AutoAudioSetup(void)
+{
+    uint8_t abAecEnables[3];
+
+    RegisterModify(REG__ACR_CTRL3, MSK__CTS_THRESH, VAL__CTS_THRESH( CONF__CTS_THRESH_VALUE ));
+
+    abAecEnables[0] = (BIT__SYNC_DETECT        |
+                       BIT__CKDT_DETECT        |
+                       BIT__CABLE_UNPLUG       );
+    abAecEnables[1] = (BIT__HDMI_MODE_CHANGED  |
+                       BIT__CTS_REUSED         |
+                       BIT__AUDIO_FIFO_UNDERUN |
+                       BIT__AUDIO_FIFO_OVERRUN |
+                       BIT__FS_CHANGED         |
+                       BIT__H_RES_CHANGED      );
+#if (CONF__VSYNC_OVERFLOW != ENABLE)   
+    abAecEnables[2] = (BIT__V_RES_CHANGED      );
+#endif
+    RegisterWriteBlock(REG__AEC_EN1, abAecEnables, 3);
+	RegisterModify(REG__AEC_CTRL, BIT__CTRL_ACR_EN, SET);
+
+}
+
+
+//------------------------------------------------------------------------------
+// Function: ConfigureSelectedPort
+// Description: Setup new input port after port change
+//------------------------------------------------------------------------------
+static void ConfigureSelectedPort(void)
+{		  
+	
+    switch (CurrentStatus.PortSelection)
+    {
+        case PORT_SELECT__PORT_0:
+        {	
+            RegisterModify(REG__PORT_SWTCH2, MSK__PORT_EN,VAL__PORT0_EN);     //select port 0
+            RegisterWrite(REG__PORT_SWTCH, BIT__DDC0_EN);     //select DDC 0
+            HAL_VccEnable(ON);
+        }
+        break;
+
+        case PORT_SELECT__PORT_1:
+        {
+            RegisterModify(REG__PORT_SWTCH2, MSK__PORT_EN,VAL__PORT1_EN);     //select port 1
+			RegisterWrite(REG__PORT_SWTCH, BIT__DDC1_EN);     //select DDC 1
+            HAL_VccEnable(ON);
+        }
+        break;
+
+        case PORT_SELECT__PORT_2:
+        {
+            RegisterModify(REG__PORT_SWTCH2, MSK__PORT_EN,VAL__PORT2_EN);     //select port 2
+			RegisterWrite(REG__PORT_SWTCH, BIT__DDC2_EN);     //select DDC 2
+            HAL_VccEnable(ON);
+        }
+        break;
+
+        case PORT_SELECT__PORT_3:
+        {
+            RegisterModify(REG__PORT_SWTCH2, MSK__PORT_EN,VAL__PORT3_EN);     //select port 3
+			RegisterWrite(REG__PORT_SWTCH, BIT__DDC3_EN);     //select DDC 3
+            HAL_VccEnable(ON);
+        }
+        break;
+
+        case PORT_SELECT__PORT_7:
+        {
+            DEBUG_PRINT(("turn off 3V power! \n"));	   //power down
+            HAL_VccEnable(OFF);
+        }
+        break;
+    }	//end of switch
+
+}
+
+
+
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+// Function: SystemDataReset
+// Description: Re-initialize receiver state
+//------------------------------------------------------------------------------
+void SystemDataReset(void)
+{
+
+    TurnAudioMute(ON);
+    TurnVideoMute(ON);
+
+	CurrentStatus.ResolutionChangeCount = 0;
+    CurrentStatus.ColorDepth = 0;
+	CurrentStatus.AudioMode = AUDIO_MODE__NOT_INIT;
+    RegisterModify(REG__TMDS_CCTRL2, MSK__DC_CTL, VAL__DC_CTL_8BPP_1X);
+
+    ConfigureSelectedPort();
+
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: PollPortSwitch
+// Description:
+//------------------------------------------------------------------------------
+static void PollPortSwitch(void)
+{
+    uint8_t bNewPortSelection;
+
+    bNewPortSelection = HAL_GetPortSelectionDebounced();
+
+    if (bNewPortSelection != PORT_SELECT__NO_CHANGE)
+    {
+        if (CurrentStatus.PortSelection != bNewPortSelection)
+		{
+		    CurrentStatus.PortSelection = bNewPortSelection;
+			SystemDataReset();
+		}
+    }
+}
+
+
+//------------------------------------------------------------------------------
+// Function: InitializePortSwitch
+// Description:	called once in SystemInit() function
+//------------------------------------------------------------------------------
+
+static void InitializePortSwitch(void)
+{
+    CurrentStatus.PortSelection = PORT_SELECT__NO_CHANGE;
+	PollPortSwitch();
+
+}
+
+//------------------------------------------------------------------------------
+// Function: System_Init
+// Description: One time initialization at statup
+//------------------------------------------------------------------------------
+static void SystemInit(void)
+{
+	const uint8_t EQTable[] = {0x8A,0xAA,0x1A,0x2A};
+
+    while( (RegisterRead(REG__BSM_STAT)& BIT__BOOT_DONE )== 0) //wait done
+        DEBUG_PRINT(("BIT__BOOT_DONE = 0; \n"));
+
+    if((RegisterRead(REG__BSM_STAT)& BIT__BOOT_ERROR)!=0)
+        DEBUG_PRINT(("First Boot error! \n"));
+
+	RegisterModify(REG__HPD_HW_CTRL,MSK__INVALIDATE_ALL, SET);	//disable auto HPD conf at RESET
+	TurnAudioMute(ON);
+	TurnVideoMute(ON);
+
+#if(PEBBLES_ES1_STARTER_CONF==ENABLE)
+    RegisterWrite(REG__TERMCTRL2, VAL__45OHM); 			//1.term default value	
+
+    RegisterWrite(REG__FACTORY_A87,0x43);              //2.Set PLL mode to internal and set selcalrefg to F
+    RegisterWrite(REG__FACTORY_A81,0x18);              //Set PLL zone to auto and set Div20 to 1
+
+    RegisterWrite(REG__DRIVE_CNTL,0x64);               //3.change output strength,  
+
+    RegisterWrite(REG__FACTORY_ABB,0x04);              //4.desable DEC_CON
+
+    RegisterWriteBlock(REG__FACTORY_A92,&EQTable[0],4);//5.Repgrogram EQ table
+    RegisterWrite(REG__FACTORY_AB5,0x40);              //EnableEQ
+
+    RegisterWrite(REG__FACTORY_9E5, 0x02);             //6. DLL by pass
+	RegisterWrite(REG__FACTORY_A89,0x00);			   //7. configure the PLLbias 	
+	RegisterWrite(REG__FACTORY_00E,0x40);  			   //for ES1.1 conf only
+#endif
+			
+    CEC_Init();					  
+    //set recommended values
+    RegisterWrite(REG__AACR_CFG1, CONF__AACR_CFG1_VALUE);   //pll config #1
+    RegisterWrite(REG__CBUS_PAD_SC, VAL__SC_CONF);  		//CBUS slew rate 
+    RegisterWrite(REG__SRST,  BIT__SWRST_AUTO);             //enable auto sw reset
+	RegisterWrite(REG__INFM_CLR,BIT__CLR_GBD|BIT__CLR_ACP);	//clr GBD & ACP
+
+    RegisterWrite(REG__ECC_HDCP_THRES, CONF__HDCPTHRESH & 0xff);      //HDCP threshold low uint8_t
+    RegisterWrite(REG__ECC_HDCP_THRES+1, (CONF__HDCPTHRESH>>8) & 0xff);  //HDCP threshold high uint8_t
+    AutoVideoSetup();
+    AutoAudioSetup();    
+    SetupInterruptMasks();
+	InitializePortSwitch();
+    TurnPowerDown(OFF);	 						   	
+	RegisterModify(REG__HPD_HW_CTRL,MSK__INVALIDATE_ALL, CLEAR); //CLEAR disable auto HPD conf 
+
+	/* Inti Hdmi Info frame related chip registers and data */
+	HdmiInitIf ();
+}
+
+//------------------------------------------------------------------------------
+// Function: HdmiTask
+// Description: One time initialization at startup
+//------------------------------------------------------------------------------
+static void HdmiTask(void)
+{
+
+    if ((CurrentStatus.AudioState == STATE_AUDIO__REQUEST_AUDIO) ||
+        (CurrentStatus.AudioState == STATE_AUDIO__AUDIO_READY))
+    {
+        if (TIMER_Expired(TIMER__AUDIO))
+        {
+            AudioUnmuteHandler();
+        }
+    }
+
+    if (CurrentStatus.VideoState == STATE_VIDEO__UNMUTE)
+    {
+        if (TIMER_Expired(TIMER__VIDEO))
+        {
+			DEBUG_PRINT(("v time out\n"));
+			ResetVideoControl();
+        }
+    }
+#if (PEBBLES_VIDEO_STATUS_2ND_CHECK==ENABLE)
+	if (CurrentStatus.VideoState == STATE_VIDEO__ON)
+	{
+        if (TIMER_Expired(TIMER__VIDEO))
+        {
+			PclkCheck();
+        	TIMER_Set(TIMER__VIDEO, VIDEO_STABLITY_CHECK_INTERVAL);  // start the video timer 
+			CurrentStatus.VideoStabilityCheckCount++;
+
+        }
+		if (CurrentStatus.VideoStabilityCheckCount == VIDEO_STABLITY_CHECK_TOTAL/VIDEO_STABLITY_CHECK_INTERVAL)
+		{
+			DEBUG_PRINT(("V CHECK %d times\n",(int)CurrentStatus.VideoStabilityCheckCount));
+			CurrentStatus.VideoState = STATE_VIDEO__CHECKED;
+			CurrentStatus.VideoStabilityCheckCount = 0;
+		}					  										
+	}
+#endif //#if (PEBBLES_VIDEO_STATUS_2ND_CHECK==ENABLE)
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: main
+// Description: Main loop
+//------------------------------------------------------------------------------
+void sii9223a_main(void)
+{
+	uint16_t wOldTickCnt = 0;
+	uint16_t wNewTickCnt = 0;
+	uint16_t wTickDiff;
+
+//    HAL_Init();
+
+//    DEBUG_INIT();
+    DEBUG_PRINT(("AMF Pebble ES1_2 starter board version 2.3.0\n"));
+
+    SystemInit();
+
+    while (1)
+    {
+//        if ( (!DEBUG_PAUSE_FIRMWARE) && (!GPIO_GetComMode())  )
+//        if ( !GPIO_GetComMode() )
+        {
+            if (TIMER_Expired(TIMER__POLLING))
+            {
+                TIMER_Set(TIMER__POLLING, 20);       //poll every 20ms	   
+                PollPortSwitch();  
+                PollInterrupt();
+            }
+#if (CONF__CEC_ENABLE == ENABLE)
+			CEC_Event_Handler();
+#endif
+
+			HdmiTask();
+			wNewTickCnt = TIMER_GetTickCounter();
+			if ( wNewTickCnt > wOldTickCnt ){
+				wTickDiff = wNewTickCnt - wOldTickCnt;
+			}
+			else { /* counter wrapping */
+				wTickDiff = ( 0xFFFF - wOldTickCnt ) + wNewTickCnt;
+			}
+			wTickDiff >>= 1; /* scaling ticks to ms */
+			if ( wTickDiff > 36 ){
+				wOldTickCnt = wNewTickCnt;
+				HdmiProcIfTo( wTickDiff );
+			}
+        }
+        msleep(10);
+//        DEBUG_POLL();
+    }
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/regio.c b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/regio.c
new file mode 100755
index 000000000000..320190005e65
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/regio.c
@@ -0,0 +1,177 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#include <local_types.h>
+#include <config.h>
+#include <hal.h>
+
+
+//------------------------------------------------------------------------------
+// Function: DecodeRegisterAddress
+// Description: Generate I2C slave address and offset based on register address.
+//              Register address format is composed of 2 uint8_ts, Page Addres and Offset.
+//              Page Address uint8_t is mapped int I2C slave address.
+//              Offset is used as is.
+//------------------------------------------------------------------------------
+static void DecodeRegisterAddress(uint16_t regAddr, uint8_t* slaveID, uint8_t* offset)
+{
+    uint8_t page;
+    
+    page = (uint8_t) (regAddr >> 8);
+
+	switch (page)
+	{
+	    case (0):
+	        *slaveID = CONF__I2C_SLAVE_PAGE_0;
+			break;
+	    case (1):
+	        *slaveID = CONF__I2C_SLAVE_PAGE_1;
+			break;
+	    case (8):
+	        *slaveID = CONF__I2C_SLAVE_PAGE_8;
+			break;		   
+		case (9):
+	        *slaveID = CONF__I2C_SLAVE_PAGE_9;
+			break;
+		case (0x0A):
+	        *slaveID = CONF__I2C_SLAVE_PAGE_A;
+			break;
+		case (0x0C):
+	        *slaveID = CONF__I2C_SLAVE_PAGE_C;
+			break;
+
+
+	}
+    *offset = (uint8_t) (regAddr & 0xFF);
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: RegisterRead
+// Description: Read a one uint8_t register.
+//              The register address parameter is translated into an I2C slave address and offset.
+//              The I2C slave address and offset are used to perform an I2C read operation.
+//------------------------------------------------------------------------------
+uint8_t RegisterRead(uint16_t regAddr)
+{
+    uint8_t slaveID, offset;
+    uint8_t aByte;
+
+    DecodeRegisterAddress(regAddr, &slaveID, &offset);
+
+    aByte = I2C_ReadByte(slaveID, offset);
+
+    return (aByte);
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: RegisterWrite
+// Description: Write a one uint8_t register.
+//              The register address parameter is translated into an I2C slave address and offset.
+//              The I2C slave address and offset are used to perform an I2C write operation.
+//------------------------------------------------------------------------------
+void RegisterWrite(uint16_t regAddr, uint8_t value)
+{
+    uint8_t slaveID, offset;
+
+    DecodeRegisterAddress(regAddr, &slaveID, &offset);
+
+    I2C_WriteByte(slaveID, offset, value);
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: RegisterModify
+// Description: Modify a one uint8_t register under mask.
+//              The register address parameter is translated into an I2C slave address and offset.
+//              The I2C slave address and offset are used to perform I2C read and write operations.
+//
+//              All bits specified in the mask are set in the register according to the value specified.
+//              A mask of 0x00 does not change any bits.
+//              A mask of 0xFF is the same a writing a uint8_t - all bits are set to the value given.
+//              When only some buts in the mask are set, only those bits are changed to the values given.
+//------------------------------------------------------------------------------
+void RegisterModify(uint16_t regAddr, uint8_t mask, uint8_t value)
+{
+    uint8_t slaveID, offset;
+    uint8_t aByte;
+
+    DecodeRegisterAddress(regAddr, &slaveID, &offset);
+
+    aByte = I2C_ReadByte(slaveID, offset);
+
+    aByte &= (~mask);        //first clear all bits in mask
+    aByte |= (mask & value); //then set bits from value
+
+    I2C_WriteByte(slaveID, offset, aByte);
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: RegisterBitToggle
+// Description: Toggle a bit or bits in a register
+//              The register address parameter is translated into an I2C slave address and offset.
+//              The I2C slave address and offset are used to perform  I2C read and write operations.
+//
+//              All bits specified in the mask are first set and then cleared in the register.
+//              This is a common operation for toggling a bit manually.
+//------------------------------------------------------------------------------
+void RegisterBitToggle(uint16_t regAddr, uint8_t mask)
+{
+    uint8_t slaveID, offset;
+    uint8_t aByte;
+
+    DecodeRegisterAddress(regAddr, &slaveID, &offset);
+
+    aByte = I2C_ReadByte(slaveID, offset);
+
+    aByte |=  mask;  //first set the bits in mask
+    I2C_WriteByte(slaveID, offset, aByte);    //write register with bits set
+
+    aByte &= ~mask;  //then clear the bits in mask
+    I2C_WriteByte(slaveID, offset, aByte);  //write register with bits clear
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: RegisterReadBlock
+// Description: Read a block of registers starting with the specified register.
+//              The register address parameter is translated into an I2C slave address and offset.
+//              The block of data uint8_ts is read from the I2C slave address and offset.
+//------------------------------------------------------------------------------
+void RegisterReadBlock(uint16_t regAddr, uint8_t* buffer, uint8_t length)
+{
+    uint8_t slaveID, offset;
+
+    DecodeRegisterAddress(regAddr, &slaveID, &offset);
+
+    I2C_ReadBlock(slaveID, offset, buffer, length);
+}
+
+
+
+//------------------------------------------------------------------------------
+// Function: RegisterWriteBlock
+// Description: Write a block of registers starting with the specified register.
+//              The register address parameter is translated into an I2C slave address and offset.
+//              The block of data uint8_ts is written to the I2C slave address and offset.
+//------------------------------------------------------------------------------
+void RegisterWriteBlock(uint16_t regAddr, uint8_t* buffer, uint8_t length)
+{
+    uint8_t slaveID, offset;
+
+    DecodeRegisterAddress(regAddr, &slaveID, &offset);
+
+    I2C_WriteBlock(slaveID, offset, buffer, length);
+}
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/registers.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/registers.h
new file mode 100755
index 000000000000..4c7cf53deff1
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/registers.h
@@ -0,0 +1,649 @@
+//------------------------------------------------------------------------------
+// Copyright  2007, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1060 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+#ifndef __REGISTERS_H__
+#define __REGISTERS_H__
+
+
+
+//------------------------------------------------------------------------------
+// NOTE: Register addresses are 16 bit values with page and offset combined.
+//
+// Examples:  0x005 = page 0, offset 0x05
+//            0x1B6 = page 1, offset 0xB6
+//------------------------------------------------------------------------------
+
+
+
+//------------------------------------------------------------------------------
+// Registers in Page 0
+//------------------------------------------------------------------------------
+
+//SYS Device ID Low uint8_t Register
+#define REG__IDL_RX			0x02
+#define REG__IDH_RX			0X03
+//SYS Device Revision Register
+#define DEV_REV_RX			0x04
+#define VAL__REV_1_2		0x03
+
+// Software Reset Register
+#define REG__SRST           0x005
+#define BIT__SWRST_AUTO     0x10    // Auto SW Reset
+#define BIT__ACRRST         0x04
+#define BIT__AACRST         0x20
+#define BIT__HDCPRST        0x08
+#define BIT__FIFORST        0x02
+#define BIT__SWRST        	0x01
+
+
+// System Status Register
+#define REG__STATE          0x006
+#define BIT__PWR5V          0x08
+#define BIT__SCDT           0x01
+#define BIT__PCLK_STABLE	0x10
+#define BIT__PWD_STAT		0x20
+
+// Software Reset Register #2
+#define REG__SRST2              0x007
+#define BIT__DCFIFO_RST         0x80
+#define BIT__AUDIO_FIFO_AUTO    0x40
+
+// System Control Register #1
+#define REG__SYS_CTRL1      0x008
+#define BIT__OCKINV         0x02    // ODCK invert
+#define BIT__PD             0x01    // Power down mode
+
+
+// Port Switch Register
+#define REG__PORT_SWTCH      0x009
+//#define BIT__DDCDLY_EN      0x80
+#define BIT__DDC3_EN        0x80
+#define BIT__DDC2_EN        0x40
+#define BIT__DDC1_EN        0x20
+#define BIT__DDC0_EN        0x10
+#define VAL__DDC_DISABLED 0x00
+
+// Port Switch Register	2
+#define REG__PORT_SWTCH2      0x00A
+#define VAL__PORT3_EN         0x03
+#define VAL__PORT2_EN         0x02
+#define VAL__PORT1_EN         0x01
+#define VAL__PORT0_EN         0x00
+#define MSK__PORT_EN         0x03
+
+// System Software Reset 2 Register
+#define REG__C0_SRST2		0x00B
+#define BIT__CEC_SRST		0x40
+
+// System Pclk Stop Register
+#define REG__SYS_PSTOP		0x00F
+#define BIT__PSTOP_EN		0x01
+#define MSK__PCLK_MAX		0xFE
+
+//Hot plug Control Register
+#define REG__HP_CTRL      0x010
+#define VAL__HP_PORT0	  0x01
+#define VAL__HP_PORT1	  0x04
+#define VAL__HP_PORT2	  0x10
+#define VAL__HP_PORT3	  0x40
+#define VAL__HP_PORT_ALL  0x55
+#define VAL__HP_PORT_NONE 0x00
+
+//CEC configuration
+#define REG__CEC_CONFIG	  0x011
+#define VAL__CEC_PWR_ON	  0x20
+#define VAL__CEC_INTR_EN	  0x01
+
+
+//Programmable slave Address 4 mapping to page #A
+#define REG__SLAVE_ADDR_XVYCC      0x015
+#define REG__SLAVE_ADDR_EDID  0x019
+#define REG__SLAVE_ADDR_CEC	  0x018
+
+
+// HDCP Debug Register
+#define REG__HDCPCTRL       0x031
+#define BIT__CLEAR_RI       0x80
+
+// Video Input H Resolution
+#define REG__VID_H_RES1				0x03A
+#define REG__VID_H_RES2				0x03B
+#define MSK__VID_H_RES_BIT8_12		0x1F
+
+// Video Input V Resolution
+#define REG__VID_V_RES1				0x03C
+#define REG__VID_V_RES2				0x03D
+#define MSK__VID_V_RES_BIT8_10		0x07
+
+// Video Input DE PIXEL
+#define REG__VID_DE_PIXEL1			0x04E
+#define REG__VID_DE_PIXEL2			0x04F
+#define MSK__VID_DE_PIXEL_BIT8_11	0x0F
+
+// Video DE Lines
+#define REG__VID_DE_LINE1			0x050
+#define REG__VID_DE_LINE2			0x051
+#define MSK__VID_DE_LINE_BIT8_10	0x07
+
+// Video V Sync to Active Video Lines
+#define REG__VID_VS_AVT				0x052
+#define MSK__VID_VS_AVT_BIT0_5		0x3F
+
+// Video V Front Porch
+#define REG__VID_V_FP				0x053
+#define MSK__VID_V_FP_BIT0_5		0x3F
+
+// Video H Front Porch
+#define REG__VID_H_FP1				0x059
+#define REG__VID_H_FP2				0x05A
+#define MSK__VID_H_FP_BIT8_9		0x03
+
+// Video H Sync Width
+#define REG__VID_HS_WIDTH1			0x05B
+#define REG__VID_HS_WIDTH2			0x05C
+#define MSK__VID_HS_WIDTH_BIT8_9	0x03
+
+// Video Control Register
+#define REG__VID_CTRL       0x048
+#define BIT__IVS            0x80    // Invert VSYNC
+#define BIT__IHS            0x40    // Invert HSYNC
+
+// Video Mode #2 Register
+#define REG__VID_MODE2          0x049
+#define MSK__DITHER_MODE        0xC0    // Output color depth
+#define VAL__DITHER_8BITS       0x00    // 8 bit  color output
+#define VAL__DITHER_10BITS      0x40    // 10 bit color output
+#define VAL__DITHER_12BITS      0x80    // 12 bit color output
+#define BIT__EVENPOL            0x20    // EVNODD pin invert
+
+// Auto Output Format Register
+#define REG__VID_AOF                        0x05F
+#define VAL__RGB                            0x00    // RGB 4:4:4
+#define VAL__YC444                          0x80    // YCbCr 4:4:4
+#define VAL__YC422_8BIT                     0xC0    // YCbCr 4:2:2 8  bit
+#define VAL__YC422_10BIT                    0xC8    // YCbCr 4:2:2 10 bit
+#define VAL__YC422_MUX_8BIT                 0xE0    // YCbCr 4:2:2 8  bit multiplexed
+#define VAL__YC422_MUX_10BIT                0xE8    // YCbCr 4:2:2 10 bit multiplexed
+#define VAL__YC422_MUX_8BIT_EMBED_SYNC      0xF0    // YCbCr 4:2:2 8  bit multiplexed with embedded sync
+#define VAL__YC422_MUX_10BIT_EMBEDD_SYNC    0xF8    // YCbCr 4:2:2 10 bit multiplexed with embedded sync
+#define BIT__MUXYC                          0x20    // Set for any YC multiplexed mode
+
+// Deep Color Status Register
+#define REG__DC_STAT        0x061
+#define MSK__PIXEL_DEPTH    0x03
+#define VAL__DEPTH_8BPP     0x00
+#define VAL__DEPTH_10BPP    0x01
+#define VAL__DEPTH_12BPP    0x02
+
+//Video Channel PCLK Count Base Register
+#define REG__VIDA_XPCLK_BASE	0x0069
+
+//XCLK to PCLK update Register
+#define REG__VIDA_XPCNT_EN	0x006A
+#define BIT__VIDA_XPCNT_EN	0x01
+
+//Pixel Clock Timing Low Register
+#define REG__VIDA_XPCNT0	0x006E
+
+//Pixel Clock Timing High Register
+#define REG__VIDA_XPCNT1	0x006F
+#define MSK__VIDA_XPCNT1_BIT8_11	0x0F
+
+// Interrupt State Register
+#define REG__INTR_STATE     0x070
+#define BIT__INTR           0x01
+#define BIT__INTR_GROUP0	0x02
+#define BIT__INTR_GROUP1	0x04
+
+// Interrupt Status #1 Register
+#define REG__INTR1          0x071
+#define BIT__AUDIO_READY	0x04
+#define BIT__PWRSTAT_CHANGE 0x08
+
+// Interrupt Status #2 Register
+#define REG__INTR2          0x072
+#define BIT__HDMIMODE       0x80
+#define BIT__CKDT_CHG       0x10
+#define BIT__SCDT_CHG       0x08	 
+#define BIT__GOTAUD         0x02
+#define BIT__GOTCTS         0x04
+#define BIT__VCLK_CHG		0x01
+
+//////////////////////////////////////////
+// Interrupt Status #3 Register			//
+//////////////////////////////////////////
+#define REG__INTR3              0x073
+#define REG__INTR3_NEW_INFOFR   0x073
+/* bit defenitions */
+#define BIT__NEW_AVI_INF       	0x01
+#define BIT__NEW_SPD_INF       	0x02
+#define BIT__NEW_AUD_INF       	0x04
+#define BIT__NEW_MPEG_INF       0x08
+#define BIT__NEW_UNREQ_INF      0x10
+#define BIT__NEW_CP_INF       	0x80
+
+
+// Interrupt Status #4 Register
+#define REG__INTR4          0x074
+#define BIT__HDCPERR        0x40
+#define BIT__CTS_DROP       0x08
+#define BIT__CTS_REUSE      0x04
+#define BIT__FIFO_OVER      0x02
+#define BIT__FIFO_UNDER     0x01
+#define BIT__NO_AVI_INF    	0x10
+#define MSK__CTS_ERROR      (BIT__CTS_DROP  | BIT__CTS_REUSE)
+#define MSK__FIFO_ERROR     (BIT__FIFO_OVER | BIT__FIFO_UNDER)
+
+// Interrupt Unmask Registers
+#define REG__INTR1_UNMASK   0x075
+
+// Interrupt Unmask Registers
+#define REG__INTR3_UNMASK   0x077
+
+// Interrupt Info Frame Control
+
+#define REG__INTR_IF_CTRL	0x07A
+
+#define BIT__NEW_AVI_CTRL_INF	0x01
+#define BIT__NEW_AUD_CTRL_INF	0x04
+#define BIT__NEW_ACP_CTRL_INF	0x20
+#define BIT__NEW_GMT_CTRL_INF	0x40
+
+
+// Interrupt Status #5 Register
+#define REG__INTR5              0x07B
+#define BIT__FNCHG              0x80
+#define BIT__AACDONE            0x40
+#define BIT__AULERR             0x20
+#define BIT__VRCHG              0x10
+#define BIT__HRCHG              0x08
+#define BIT__FSCHG              0x01
+#define MSK__AUDIO_INTR         (BIT__FNCHG | BIT__AACDONE | BIT__AULERR | BIT__FSCHG)
+// Interrupt Status #6 Register
+#define REG__INTR6              0x07C
+#define BIT__CABLE_UNPLUG       0x01
+#define BIT__NEW_ACP_PKT		0x04
+
+// Interrupt Unmask Registers
+#define REG__INTR5_UNMASK       0x07D
+#define REG__INTR6_UNMASK       0x07E
+
+// TMDS Analog Control #2 Register
+#define REG__TMDS_CCTRL2        0x081
+#define BIT__OFFSET_COMP_EN		0x20
+#define MSK__DC_CTL             0x0F
+#define VAL__DC_CTL_8BPP_1X     0x00
+#define VAL__DC_CTL_8BPP_2X     0x02
+#define VAL__DC_CTL_10BPP_1X    0x04
+#define VAL__DC_CTL_12BPP_1X    0x05
+#define VAL__DC_CTL_10BPP_2X    0x06
+#define VAL__DC_CTL_12BPP_2X    0x07
+
+// TMDS Termination Control Register
+#define REG__TMDS_TERMCTRL              0x082
+//#define VAL__TERM_SEL1_NORMAL           0x00
+//#define VAL__TERM_SEL1_UNTERMINATED     0x60
+//#define VAL__TERM_SEL1_UNPLUGTERMINATED     0x40
+#define VAL__TERM_CNTL_60               0x00
+#define VAL__TERM_CNTL_55               0x04
+#define VAL__TERM_CNTL_50               0x08
+#define VAL__TERM_CNTL_45               0x0C
+#define VAL__TERM_CNTL_40               0x10
+//#define VAL__TERM_SEL0_NORMAL           0x00
+#define VAL__TERM_SEL0_UNTERMINATED     0x03
+//#define VAL__TERM_SEL0_UNPLUGTERMINATED     0x02
+
+
+// TMDS Termination Control Register
+#define REG__TMDS_TERMCTRL0              			0x082
+#define VAL__TERM_SEL0_NORMAL           			0xFC
+#define VAL__TERM_SEL1_NORMAL          			 	0xF3
+#define VAL__TERM_SEL2_NORMAL    				    0xCF
+#define VAL__TERM_SEL3_NORMAL           			0x3F
+#define VAL__TERM_SEL0_UNPLUGTERMINATED           	0xFE //1111 1110
+#define VAL__TERM_SEL1_UNPLUGTERMINATED           	0xFB //1111 1011
+#define VAL__TERM_SEL2_UNPLUGTERMINATED           	0xEF //1110 1111
+#define VAL__TERM_SEL3_UNPLUGTERMINATED           	0xBF //1011 1111
+#define VAL__TERM_ALL_UNTERMINATED           		0xFF
+
+
+//Termination Control Register #2
+#define REG__TERMCTRL2			0x083
+#define VAL__45OHM				0x60
+
+
+// ACR Configuration Registers
+#define REG__AACR_CFG1          0x088
+#define REG__AACR_CFG2          0x089
+
+// Interrupt Status #7 Register
+#define REG__INTR7              0x090
+#define BIT__VIDEO_READY       	0x20
+#define BIT__PCLK_STOP       	0x04
+
+//////////////////////////////////////////
+// Interrupt Status #8 Register			//
+//////////////////////////////////////////
+#define REG__INTR8              0x091
+#define REG__INTR8_NO_INFOFR    0x091
+/* bit defenitions */
+#define BIT__NO_SPD_INF       	0x02
+#define BIT__NO_AUD_INF       	0x04
+#define BIT__NO_MPEG_INF       	0x08
+#define BIT__NO_UNREQ_INF      	0x10
+#define BIT__NO_ACP_INF      	0x20
+#define BIT__NO_GDB_INF       	0x40
+#define BIT__NEW_GDB_INF       	0x80
+/* REG__INTR8_NO_INFOFR end bit defenitions */
+
+// Interrupt Unmask Registers
+#define REG__INTR7_UNMASK       0x092
+#define REG__INTR8_UNMASK       0x093
+
+#define REG__INFM_CLR          0x094
+#define BIT__CLR_MPEG		   0x08
+#define BIT__CLR_GBD		   0x40
+#define BIT__CLR_ACP		   0x20
+
+				 
+// Auto Audio Unmute Control 
+#define REG__AEC1_CTL		0x0B4
+#define BIT__ASC2_EN		0x01
+
+// Auto Exception Control
+#define REG__AEC_CTRL       0x0B5
+#define BIT__AAC_OE         0x20        // Let AAC Control Audio Output Enables
+#define BIT__AVC_EN         0x04        // Enable Auto Video Configuration (AVC)
+#define BIT__AAC_EN         0x01        // Enable Auto Audio Control (AAC)
+#define BIT__AAC_ALL        0x02        // Enable Auto Audio unmute (AAC_ALL)
+#define BIT__CTRL_ACR_EN    0x80
+
+// AEC Exception Enable Registers (3 uint8_ts total)
+#define REG__AEC_EN1                0x0B6
+#define BIT__CABLE_UNPLUG           0x01
+#define BIT__CKDT_DETECT            0x80   
+#define BIT__SYNC_DETECT            0x40
+
+#define BIT__HDMI_MODE_CHANGED      0x01
+#define BIT__AUDIO_FIFO_UNDERUN     0x02
+#define BIT__AUDIO_FIFO_OVERRUN     0x04
+#define BIT__CTS_REUSED             0x08   
+#define BIT__FS_CHANGED             0x10
+#define BIT__H_RES_CHANGED          0x80
+
+#define BIT__V_RES_CHANGED          0x01
+
+#define REG__AVC_EN2			    0x0BA
+#define BIT__AUTO_DC_CONF			0x80
+#define BIT__AUTO_CLK_DIVIDER		0x40
+
+#define REG__ECC_CTRL				0x0BB
+#define BIT__CAPCNT					0x01
+#define REG__ECC_HDCP_THRES			0x0C5
+
+
+//------------------------------------------------------------------------------
+// Registers in Page 1
+//------------------------------------------------------------------------------
+
+// ACR Control Register #1
+#define REG__ACR_CTRL1      0x100
+#define BIT__FS_SEL		    0x02  
+#define BIT__ACR_INIT       0x01
+
+// ACR Audio Frequency Register
+#define REG__FREQ_SVAL      0x102
+#define VAL__SWMCLK_128     0x00
+#define VAL__SWMCLK_256     0x50
+#define VAL__SWMCLK_384     0xA0
+#define VAL__SWMCLK_512     0xF0
+#define MSK__SWMCLK         0xF0  
+#define MSK__SWFS           0x0F
+
+#define VAL__FS_48K     	0x02
+#define VAL__FS_192K     	0x0E
+#define VAL__FS_768K     	0x09
+
+
+// ACR PLL Lock Value Registers
+#define REG__LKTHRESH1      0x114
+
+#define REG__TCLK_FS          0x117 
+#define MSK__TCLKFS           0x0F
+
+
+// ACR Control #3 Register
+#define REG__ACR_CTRL3          0x118
+#define MSK__CTS_THRESH			0xF0    
+#define VAL__CTS_THRESH(x)      ((x) << 3)  // CTS change threshold
+
+// Audio Output Formatting Registers
+#define REG__I2S_CTRL1          0x126
+#define BIT__SCK                0x40
+
+// Audio Out I2S Control Register #2
+#define REG__I2S_CTRL2          0x127
+#define BIT__SD3                0x80    // I2S output enables
+#define BIT__SD2                0x40
+#define BIT__SD1                0x20
+#define BIT__SD0                0x10
+#define BIT__MCLKEN             0x08    // MCLK enable
+
+// Audio Out Control Register
+#define REG__AUD_CTRL           0x129
+#define BIT__MUTE_MODE			0x20    // Soft mute enable
+#define BIT__PSERR		        0x10    // Pass S/PDIF error
+#define BIT__PAERR		        0x08    // Pass Audio error
+#define BIT__I2SMODE			0x04
+#define BIT__SPEN				0x01    // S/PDIF enable
+
+// Audio In S/PDIF Channel Status #4
+#define REG__AUD_CHST4			0X130
+#define BIT__AUD_FS				0x0F 	// AUD_FS, sampling frequency
+
+// HDMI Audio Status Register
+#define REG__AUDP_STAT          0x134
+#define BIT__HBRA_ON            0x40
+#define BIT__DSD_STATUS         0x20
+#define BIT__HDMI_LO            0x08  // Audio Layout - ignore unused MSB
+#define BIT__HDMI_DET           0x01
+
+// HDMI Mute Register
+#define REG__HDMI_MUTE          0x137
+#define BIT__VIDM_STATUS		0x40
+#define BIT__AUDM               0x02
+#define BIT__VIDM               0x01
+
+//System Power Down Register
+#define REG__CH0_PD_SYS			0x13F
+#define BIT__PD_XTAL		    0x01
+
+//////////////////////////////////////////
+// Avi info frame registers				//
+//////////////////////////////////////////
+#define REG__AVI_TYPE           0x140
+//////////////////////////////////////////
+// Sud info frame registers				//
+//////////////////////////////////////////
+#define REG__SPD_TYPE           0x160
+#define REG__SPD_DECODE         0x17F
+
+//////////////////////////////////////////
+// Aud info frame registers				//
+//////////////////////////////////////////
+#define REG__AUD_TYPE           0x180
+//////////////////////////////////////////
+// Mpeg info frame registers			//
+//////////////////////////////////////////
+#define REG__MPEG_TYPE           0x1A0
+#define REG__MPEG_DECODE         0x1BF
+//////////////////////////////////////////
+// Unreq info frame registers			//
+//////////////////////////////////////////
+#define REG__UNREQ_TYPE          0x1C0
+//////////////////////////////////////////
+// Acp info frame registers				//
+//////////////////////////////////////////
+#define REG__ACP_TYPE           0x1E0
+#define REG__ACP_DECODE         0x1FF
+
+//ACP0 Packet byte#2 Register
+#define REG__ACP_BYTE2			0x1E1
+//////////////////////////////////////////
+// Gamut info frame registers			//
+//////////////////////////////////////////
+#define REG__GMT_TYPE          0xA61
+
+//------------------------------------------------------------------------------
+// Registers in Page 8
+//------------------------------------------------------------------------------
+#define REG__CEC_DEBUG_2		0x886
+
+#define	REG__CEC_DEBUG_3		0x887
+#define BIT_SNOOP_EN            0x01
+#define BIT_FLUSH_TX_FIFO       0x80
+
+#define REG__CEC_TX_INIT		0x889
+#define BIT_SEND_POLL       	0x80
+
+#define REG__CEC_TX_DEST		0x889
+
+#define REG__CEC_CONFIG_CPI		0x88E
+#define BIT__CEC_PASS_THROUGH	0x10
+
+#define REG__CEC_TX_COMMAND		0x88F
+
+#define REG__CEC_TRANSMIT_DATA  0x89F
+#define	BIT__TX_AUTO_CALC		0x20
+
+#define REG__CEC_CAPTURE_ID0    0x8A2
+
+#define REG__CEC_INT_ENABLE_1	0x8A5
+
+// 0xA6 CPI Interrupt Status Register (R/W)
+#define REG__CEC_INT_STATUS_0   0x8A6
+#define BIT_CEC_LINE_STATE      0x80
+#define BIT_TX_MESSAGE_SENT     0x20
+#define BIT_TX_HOTPLUG          0x10
+#define BIT_POWER_STAT_CHANGE   0x08
+#define BIT_TX_FIFO_EMPTY       0x04
+#define BIT_RX_MSG_RECEIVED     0x02
+#define BIT_CMD_RECEIVED        0x01
+// 0xA7 CPI Interrupt Status Register (R/W)
+#define BIT_RX_FIFO_OVERRUN     0x08
+#define BIT_SHORT_PULSE_DET     0x04
+#define BIT_FRAME_RETRANSM_OV   0x02
+#define BIT_START_IRREGULAR     0x01
+
+#define REG__CEC_RX_CONTROL 0x8AC
+// CEC  CEC_RX_CONTROL bits
+#define BIT_CLR_RX_FIFO_CUR 0x01
+#define BIT_CLR_RX_FIFO_ALL 0x02
+
+#define REG__CEC_RX_COUNT   0x8AD
+#define BIT_MSG_ERROR       0x80
+
+
+#define REG__CEC_RX_CMD_HEADER		0x8AE
+//#define CEC_RX_OPCODE_ADDR  0xAF
+#define REG__CEC_RX_OPERAND_0 		0x8B0
+
+
+#define REG__CEC_RX_COUNT   	0x8AD
+
+
+#define REG__EN_EDID			0x901
+#define VAL__EN_EDID_NONE		0x00 
+#define VAL__EN_EDID_ALL		0x0F
+
+#define REG__EDID_FIFO_ADDR		0x902
+#define VAL__FIFO_ADDR_00		0x00
+
+#define REG__EDID_FIFO_DATA		0x903
+#define REG__EDID_FIFO_SEL		0x904
+#define BIT__SEL_EXTRA			0x10
+#define BIT__SEL_EDID0			0x01
+
+#define REG__NVM_COMMAND		0x905
+#define VAL__PRG_EXTRA			0x04
+#define VAL__PRG_EDID			0x03
+#define VAL__COPY_EXTRA			0x06
+
+#define REG__NVM_COMMAND_DONE	0x907
+#define BIT__NVM_COMMAND_DONE	0x01
+
+#define REG__BSM_INIT			0x908
+#define BIT__BSM_INIT			0x01
+
+#define REG__BSM_STAT			0x909
+#define	BIT__BOOT_DONE			0x04
+#define	BIT__BOOT_ERROR			0x03
+
+#define REG__NVM_STAT			0x910
+#define VAL__NVM_VALID			0x03
+
+#define REG__HPD_HW_CTRL		0x913
+#define MSK__INVALIDATE_ALL		0xF0
+
+#define REG__CECPA_ADDR			0x91A
+
+#define REG__RPI_AUTO_CONFIG	0x940
+#define BIT__CHECKSUM_EN		0x01
+#define BIT__V_UNMUTE_EN		0x02
+#define BIT__HCDP_EN			0x04
+#define BIT__TERM_EN			0x08
+
+#define REG__WAIT_CYCLE			0x941
+
+#define REG__CLKDETECT_STATUS	0x9D0
+#define BIT__CKDT_0				0x01
+#define BIT__CKDT_1				0x02
+#define BIT__CKDT_2				0x04
+#define BIT__CKDT_3				0x08
+
+#define REG__PWR5V_STATUS		0x9D1
+#define BIT__PWR5V_0			0x01
+#define BIT__PWR5V_1			0x02
+#define BIT__PWR5V_2			0x04
+#define BIT__PWR5V_3			0x08
+
+#define REG__CBUS_PAD_SC		0x9D4
+#define VAL__SC_CONF			0xFF
+
+#define REG__DRIVE_CNTL			0x9E9
+#define MSK__ODCK_STRENGTH		0x70
+#define VAL__ODCK_STRENGTH		0x60
+
+//------------------------------------------------------------------------------
+// Factory Configuration Registers 
+//------------------------------------------------------------------------------
+#define REG__FACTORY_00E		0x00E
+
+#define REG__FACTORY_9E5		0x9E5
+
+#define REG__FACTORY_A81		0xA81
+#define REG__FACTORY_A87		0xA87
+#define REG__FACTORY_A88		0xA88 
+#define REG__FACTORY_A89		0xA89
+#define REG__FACTORY_A92		0xA92 
+
+#define REG__FACTORY_AB5		0xAB5
+#define REG__FACTORY_ABB		0xABB
+
+
+//------------------------------------------------------------------------------
+// Virtual registers which are used to group info frame interrupts
+// for convenient processing
+//------------------------------------------------------------------------------
+#define BIT__VIRT_NO_AVI_INF	BIT__NEW_GDB_INF
+#define BIT__VIRT_NEW_ACP_INF	0x40
+#define BIT__VIRT_NEW_GDB_INF	BIT__NEW_GDB_INF
+
+
+
+#endif  // __REGISTERS_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/spec_types.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/spec_types.h
new file mode 100755
index 000000000000..850a12096756
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/spec_types.h
@@ -0,0 +1,99 @@
+#ifndef SPEC_TYPES
+#define SPEC_TYPES
+/*
+HDMI Info Frame packet ids
+*/
+/* InfoFrames Avi, Aud, Spd, Vsif
+	[InfoFrame type		]
+	[InfoFrame ver		]
+	[InfoFrame length	]
+	[Check sum			]
+*/
+#define IF_TYPE_ADDR		0x00
+#define IF_VER_ADDR			0x01
+#define IF_LENGTH_ADDR		0x02
+#define IF_CHECK_SUM_ADDR	0x03
+#define IF_PAYLOAD_ADDR		0x04
+#define IF_HEADER_SIZE		3
+
+#define IF_AVI_ID           0x82
+#define IF_AUD_ID           0x84
+#define IF_ACP_ID           0x04
+#define IF_SPD_ID           0x83
+#define IF_MPEG_ID          0x85
+#define IF_GMT_ID           0x0A
+/* Gamut format
+	[GDB_Length_H	]
+	[GDB_Length_L	]
+	[Check sum		]
+	[up to 24 uint8_ts	]
+*/
+
+#define IF_VSIF_ID          0x81
+#define IF_ISRC1_ID         0x05
+#define IF_ISRC2_ID         0x06
+
+#define IF_AVI_SIZE          13
+#define IF_AUD_SIZE          13
+#define IF_ACP_SIZE          6
+#define IF_SPD_SIZE          28
+#define IF_MPEG_SIZE         28
+#define IF_GMT_SIZE          28
+#define IF_VSIF_SIZE         24
+#define IF_ISRC_SIZE         19
+
+#define IF_VSIF_HDMI_FORMAT_SEL		0xE0
+#define IF_HDMI_FORMAT_3D			0x40
+#define IF_VSIF_3DSTRUCT_SEL		0X04  //YMA ADD
+
+#define IF_VSIF_IEEE_REGID_ADDR		0x00
+#define IF_VSIF_HDMI_FORMAT_ADDR	0x03
+#define IF_VSIF_3D_STRUCT_ADDR		0x04
+
+
+typedef enum {
+	  FramePacking				=	0
+	, FrameAlternative			=	1
+	, LineAlternative				=	2
+	, SiedBySideFull				=	3
+	, LDepth						=	4
+	, LDepthGraphGraphDepth	=	5	
+	, SideBySideHalf				=	8
+}_3DStructute_t;
+
+
+#define IF_AVI_EC_ADDR		0x02
+#define IF_AVI_ITC_ADDR		0x02
+#define IF_AVI_VIC_ADDR		0x03
+#define IF_AVI_CN_ADDR		0x04
+#define IF_AVI_VIC_SEL		0x7f
+
+
+typedef enum {
+	ExtnColorimSel	= 0x70	
+	, xvYCC601		= 0x00
+	, xvYCC709		= 0x10
+	, cYCC601
+	, AdobeYCC601
+	, AdobeRGB
+} ExtendColorimetry_t;
+
+typedef enum {
+	ITContSel		= 0x80	
+	, ContTypeSel	= 0x30	
+	, Graphics	= 0x00
+	, Photo		= 0x10
+	, Cinema
+	, Game
+
+} ContType_t;
+
+/* 3D Mandatory Video Id Modes */
+typedef enum _VidIdModes_t {
+	_3D_Vic1080p24	= 32,
+	_3D_Vic720p60	=  4,
+	_3D_Vic720p50	= 19
+} VidIdModes_t;
+
+
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/stdio.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/stdio.h
new file mode 100755
index 000000000000..d9efad2d0a9c
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/stdio.h
@@ -0,0 +1 @@
+// featal head file to compatible with sii9233a original driver.
\ No newline at end of file
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/string.h b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/string.h
new file mode 100755
index 000000000000..d9efad2d0a9c
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/__sii9233/string.h
@@ -0,0 +1 @@
+// featal head file to compatible with sii9233a original driver.
\ No newline at end of file
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/platform_interface.c b/drivers/amlogic/ext_hdmiin/sii9233/platform_interface.c
new file mode 100755
index 000000000000..524288bac99a
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/platform_interface.c
@@ -0,0 +1,149 @@
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include "sii9233_drv.h"
+#include <config.h>
+#include <hal_cp9223.h>
+
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// for timer
+#define SII9233A_TIMER_INTERVAL	1 // 1 jiffies for 10ms
+static struct timer_list sii9233a_timer;
+static uint16_t TimerArray[CONF__TIMER_COUNT];
+static uint16_t wTickCnt = 0;
+
+void TIMER_Set(uint8_t index, uint16_t value)
+{
+	if (index < CONF__TIMER_COUNT)
+    {
+        TimerArray[index] = value/10;
+    }
+
+	return ;
+}
+
+uint8_t TIMER_Expired(uint8_t index)
+{
+	if (index < CONF__TIMER_COUNT)
+    {
+        return (TimerArray[index] == 0);
+    }
+
+	return 0;
+}
+
+uint16_t TIMER_GetTickCounter( void )
+{
+	return wTickCnt;
+}
+
+static void sii9233a_timer_handler(unsigned long arg)
+{
+	int i = 0;
+
+	wTickCnt++;
+
+	for( i = 0; i < CONF__TIMER_COUNT; i++ )
+	{
+		if (TimerArray[ i ] > 0)
+        {
+            TimerArray[ i ]--;
+        }
+    }
+
+    mod_timer(&sii9233a_timer, jiffies + SII9233A_TIMER_INTERVAL);
+}
+
+void TIMER_Init(void)
+{
+	int i = 0;
+
+	for (i = 0; i < CONF__TIMER_COUNT; i++)
+    {
+        TimerArray[ i ] = 0;
+    }
+
+	init_timer(&sii9233a_timer);
+	sii9233a_timer.data = (ulong)0;
+	sii9233a_timer.function = sii9233a_timer_handler;
+	sii9233a_timer.expires = jiffies + SII9233A_TIMER_INTERVAL;
+	add_timer(&sii9233a_timer);
+
+	return ;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// for i2c
+
+uint8_t I2C_ReadByte(uint8_t deviceID, uint8_t offset)
+{
+	int ret = 0;
+	char buf[2] = {0,0};
+
+	buf[0] = offset;
+
+	ret = aml_sii9233a_i2c_read(deviceID, buf, 1, 1);
+	
+	return (uint8_t)buf[0];
+}
+
+void I2C_WriteByte(uint8_t deviceID, uint8_t offset, uint8_t value)
+{
+	int ret = 0;
+	char buf[2] = {0,0};
+
+	buf[0] = offset;
+	buf[1] = value;
+
+	ret = aml_sii9233a_i2c_write(deviceID, buf, 2);
+
+	return ;
+}
+
+uint8_t I2C_ReadBlock(uint8_t deviceID, uint8_t offset, uint8_t *buffer, uint16_t length)
+{
+	int ret = 0;
+
+	buffer[0] = offset;
+	ret = aml_sii9233a_i2c_read(deviceID, buffer, 1, length);
+	
+	return (uint8_t)ret;
+}
+
+uint8_t I2C_WriteBlock(uint8_t deviceID, uint8_t offset, uint8_t *buffer, uint16_t length)
+{
+	int ret = 0;
+	char *tmp = NULL;
+
+	tmp = (char*)kmalloc(length+1, GFP_KERNEL);
+
+	if( tmp == NULL )
+		return 1;
+
+	tmp[0] = offset;
+	memcpy(&tmp[1], buffer, length);
+
+	ret = aml_sii9233a_i2c_write(deviceID, tmp, length+1);
+
+	return (uint8_t)ret;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// fake functions for 9233a private driver
+uint8_t GPIO_GetPins(uint8_t pinMask)
+{
+	return 0;
+}
+
+void GPIO_SetPins(uint8_t pinMask)
+{
+	return ;
+}
+
+void GPIO_ClearPins(uint8_t pinMask)
+{
+	return ;
+}
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/platform_interface.h b/drivers/amlogic/ext_hdmiin/sii9233/platform_interface.h
new file mode 100755
index 000000000000..a9587d771f8b
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/platform_interface.h
@@ -0,0 +1,16 @@
+#ifndef __PLATFORM_INTERFACE_H__
+#define __PLATFORM_INTERFACE_H__
+
+// for timer function
+void TIMER_Init(void);
+void TIMER_Set(uint8_t index, uint16_t value);
+uint8_t TIMER_Expired(uint8_t index);
+
+// for i2c function
+uint8_t I2C_ReadByte(uint8_t deviceID, uint8_t offset);
+void I2C_WriteByte(uint8_t deviceID, uint8_t offset, uint8_t value);
+uint8_t I2C_ReadBlock(uint8_t deviceID, uint8_t offset, uint8_t *buffer, uint16_t length);
+uint8_t I2C_WriteBlock(uint8_t deviceID, uint8_t offset, uint8_t *buffer, uint16_t length);
+
+
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.c b/drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.c
new file mode 100755
index 000000000000..3ffd0e3cabab
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.c
@@ -0,0 +1,858 @@
+/*
+ * HDMI Receiver SiI9233A Driver
+ * Copyright (C) 2013 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <mach/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include "sii9233_drv.h"
+#include "vdin_interface.h"
+#include "sii9233_interface.h"
+
+
+extern int sii9233a_register_tvin_frontend(struct tvin_frontend_s *frontend);
+
+#define SII9233A_I2C_ADDR	0x60
+
+static sii9233a_info_t sii9233a_info;
+static struct task_struct *sii9233a_task;
+//static struct timer_list hdmirx_timer;
+static unsigned int sii_output_mode = 0xff;
+
+#define HDMIRX_PRINT_FUNC()  printk("HDMIRX_SiI9233A FUNC: %s [%d]\n", __FUNCTION__, __LINE__)
+
+#ifdef DEBUG
+#define pr_dbg(fmt, args...) printk(KERN_DEBUG "aml_sii9233a: " fmt, ## args)
+#else
+#define pr_dbg(fmt, args...)
+#endif
+#define pr_error(fmt, args...) printk(KERN_ERR "aml_sii9233a: " fmt, ## args)
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a i2c interface
+int aml_sii9233a_i2c_read(unsigned char dev_addr, char *buf, int addr_len, int data_len)
+{
+	int ret;
+	char reg_addr = buf[0];
+
+	struct i2c_msg msg[] =
+	{
+		{
+			.addr	= (dev_addr >> 1),
+			.flags	= 0,
+			.len	= addr_len,
+			.buf	= buf,
+		},
+		{
+			.addr	= (dev_addr >> 1),
+			.flags	= I2C_M_RD,
+			.len	= data_len,
+			.buf	= buf,
+		},
+	};
+
+	if( sii9233a_info.i2c_client == NULL )
+	{
+		printk("[%s] invalid i2c_client !\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = i2c_transfer(sii9233a_info.i2c_client->adapter, msg, 2);
+	if( ret < 0 )
+		pr_err("hdmirx i2c read error: %d, dev = 0x%x, reg = 0x%x\n",ret,dev_addr,reg_addr);
+
+	return ret;
+}
+
+int aml_sii9233a_i2c_write(unsigned char dev_addr, char *buf, int len)
+{
+	int ret = -1;
+	char reg_addr = buf[0], value = buf[1];
+	struct i2c_msg msg[] =
+	{
+		{
+			.addr	= (dev_addr >> 1),
+			.flags	= 0,
+			.len	= len,
+			.buf	= buf,
+		},
+	};
+
+
+	if( sii9233a_info.i2c_client == NULL )
+	{
+		printk("[%s] invalid i2c_client !\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = i2c_transfer(sii9233a_info.i2c_client->adapter, msg, 1);
+	if( ret < 0 )
+		pr_err("hdmirx i2c write error: %d, dev = 0x%x, reg = 0x%x, value = 0x%x!\n",ret,dev_addr,reg_addr,value);
+	
+	return ret;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+unsigned int sii9233a_get_output_mode(void)
+{
+	unsigned int h_active,h_total,v_active,v_total;
+	unsigned int mode = 0;
+
+	h_active = sii_get_h_active();
+	h_total = sii_get_h_total();
+	v_active = sii_get_v_active();
+	v_total = sii_get_v_total();
+
+	printk("[%s]: pixel = %d x %d ( %d x %d )\n", __FUNCTION__, h_active, v_active, h_total, v_total);
+
+	if( (h_total==2200) && (v_active==1080) )			mode = CEA_1080P60;// 1080p
+	else if( (h_total==2640) && (v_active==1080) )		mode = CEA_1080P50;// 1080p50
+	else if( (h_total==2200) && (v_active==540) )		mode = CEA_1080I60;// 1080i
+	else if( (h_total==2640) && (v_active==540) )		mode = CEA_1080I50;// 1080i50
+	else if( (h_total==1650) && (v_active==720) )		mode = CEA_720P60;// 720p
+	else if( (h_total==1980) && (v_active==720) )		mode = CEA_720P50;// 720p50
+	else if( (h_total==864) && (v_active==576) )		mode = CEA_576P50;// 576p
+	else if( (h_total==858) && (v_active==480) )		mode = CEA_480P60;// 480p
+	else if( (h_total==864) && (v_active==288) )		mode = CEA_576I50;// 576i
+	else if( (h_total==858) && (v_active==240) )		mode = CEA_480I60;// 480i
+
+	return mode;
+}
+
+static void sii9233a_start_vdin_mode(unsigned int mode)
+{
+	unsigned int height = 0, width = 0, frame_rate = 0, field_flag = 0;
+
+	printk("[%s], start with mode = %d\n", __FUNCTION__, mode);
+	switch(mode)
+	{
+		case CEA_480I60:
+			width = 1440;	height = 480;	frame_rate = 60;	field_flag = 1;		
+			break;
+		
+		case CEA_480P60:
+			width = 720;	height = 480;	frame_rate = 60;	field_flag = 0;		
+			break;
+		
+		case CEA_576I50:
+			width = 1440;	height = 576;	frame_rate = 50;	field_flag = 1;		
+			break;
+		
+		case CEA_576P50:
+			width = 720;	height = 576;	frame_rate = 50;	field_flag = 0;		
+			break;
+		
+		case CEA_720P50:
+			width = 1280;	height = 720;	frame_rate = 50;	field_flag = 0;		
+			break;
+		
+		case CEA_720P60:
+			width = 1280;	height = 720;	frame_rate = 60;	field_flag = 0;		
+			break;
+		
+		case CEA_1080I60:
+			width = 1920;	height = 1080;	frame_rate = 60;	field_flag = 1;		
+			break;
+		
+		case CEA_1080P60:
+			width = 1920;	height = 1080;	frame_rate = 60;	field_flag = 0;		
+			break;
+		
+		case CEA_1080I50:
+			width = 1920;	height = 1080;	frame_rate = 50;	field_flag = 1;		
+			break;
+		
+		case CEA_1080P50:
+			width = 1920;	height = 1080;	frame_rate = 50;	field_flag = 0;		
+			break;
+		
+		default:
+			printk("[%s], invalid video mode!\n",__FUNCTION__);
+			return ;
+	}
+
+	sii9233a_start_vdin(&sii9233a_info,width,height,frame_rate,field_flag);
+
+	return ;
+}
+
+void sii9233a_output_mode_trigger(unsigned int flag)
+{
+	unsigned int mode = 0xff;
+
+	sii9233a_info.signal_status = flag;
+	printk("[%s] set signal_status = %d\n", __FUNCTION__, sii9233a_info.signal_status);
+
+	if ( (sii9233a_info.user_cmd == 0) || (sii9233a_info.user_cmd == 0x4) || (sii9233a_info.user_cmd == 0xff) )
+		return;
+
+	if( (0 == flag) && ((sii9233a_info.user_cmd == 1) || (sii9233a_info.user_cmd == 3)) )
+	{
+		printk("[%s], lost signal, stop vdin!\n", __FUNCTION__);
+		sii_output_mode = 0xff;
+		sii9233a_stop_vdin(&sii9233a_info);
+		return ;
+	}
+
+	if( (1 == flag) && ((sii9233a_info.user_cmd == 2) || (sii9233a_info.user_cmd == 3)) )
+	{
+		msleep(500);
+		mode = sii9233a_get_output_mode();
+		if( mode != sii_output_mode )
+		{
+			printk("[%s], trigger new mode = %d, old mode = %d\n", __FUNCTION__, mode, sii_output_mode);
+			if (mode < CEA_MAX)
+			{
+				sii9233a_start_vdin_mode(mode);
+				sii_output_mode = mode;
+			}
+		}
+	}
+
+	return ;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static ssize_t sii9233a_debug_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", "command format:\n\t\tr device_address reg_address\
+												\n\t\trb device_address reg_address length\
+												\n\t\tdump device_address reg_start reg_end\
+												\n\t\tw device_address reg_address value !");
+}
+
+static ssize_t sii9233a_debug_store(struct class *class, struct class_attribute *attr,
+									const char *buf, size_t count)
+{
+	int argn;
+	char *p=NULL, *para=NULL, *argv[4] = {NULL,NULL,NULL,NULL};
+	unsigned char cmd=0, dev_addr = 0, reg_start = 0, reg_end = 0, length = 0, value = 0xff;
+	char i2c_buf[2] = {0,0};
+	int ret = 0;
+
+	p = kstrdup(buf, GFP_KERNEL);
+	for( argn=0; argn<4; argn++ )
+	{
+		para = strsep(&p, " ");
+		if( para == NULL )
+			break;
+		argv[argn] = para;
+	}
+
+//	printk("get para: %s %s %s %s!\n",argv[0],argv[1],argv[2],argv[3]);
+
+	if( !strcmp(argv[0], "r") )
+		cmd = 0;
+	else if( !strcmp(argv[0], "rb") )
+		cmd = 1; 
+	else if( !strcmp(argv[0], "dump") )
+		cmd = 2;
+	else if( !strcmp(argv[0], "w") )
+		cmd = 3;
+	else if( !strcmp(argv[0], "vinfo\n") )
+		cmd = 4;
+	else if( !strncmp(argv[0], "tt", strlen("tt")) )
+		cmd = 5;
+	else
+	{
+		printk("invalid cmd = %s\n", argv[0]);
+		return count;
+	}
+
+	printk(" cmd = %d - \"%s\"\n", cmd, argv[0]);
+	if( (argn<1) || ((cmd==0)&&argn!=3) || ((cmd==1)&&(argn!=4)) || ((cmd==2)&&(argn!=4)) )
+	{
+		printk("invalid command format!\n");
+		kfree(p);
+		return count;
+	}
+
+	if( cmd < 4 )
+		dev_addr = (unsigned char)simple_strtoul(argv[1],NULL,16);
+
+	if( cmd == 0 ) // read
+	{
+		reg_start = (unsigned char)simple_strtoul(argv[2],NULL,16);
+		printk("\nsii9233a debug read dev = 0x%x, reg = 0x%x\n",dev_addr, reg_start);
+		i2c_buf[0] = reg_start;
+
+		ret = aml_sii9233a_i2c_read(dev_addr, i2c_buf, 1, 1);
+		printk("sii9233a i2c read ret = %d, value = 0x%x\n",ret, i2c_buf[0]);
+
+	}
+	else if( cmd == 1 ) // read block
+	{
+		char *tmp = NULL;
+		int i = 0;
+
+		reg_start = (unsigned char)simple_strtoul(argv[2],NULL,16);
+		length = (unsigned char)simple_strtoul(argv[3],NULL,16);
+		printk("\nsii9233a debug read block dev = 0x%x, start = 0x%x, length = 0x%x\n",dev_addr, reg_start, length);
+
+		tmp = (char*)kmalloc(length, GFP_KERNEL);
+		if( tmp != NULL )
+		{
+			tmp[0] = reg_start;
+			ret = aml_sii9233a_i2c_read(dev_addr, tmp, 1, length);
+
+			for( i=0; i<length; i++ )
+			{
+				if( i%0x10 == 0 )
+					printk("%.2X:", i);
+				printk(" %.2X",tmp[i]);
+				if( (i+1)%0x10 == 0 )
+					printk("\n");
+			}
+			printk("\n");
+			kfree(tmp);
+		}
+	}
+	else if( cmd == 2 ) // dump
+	{
+		int i = 0;
+
+		reg_start = (unsigned char)simple_strtoul(argv[2],NULL,16);
+		reg_end = (unsigned char)simple_strtoul(argv[3],NULL,16);
+		printk("\nsii9233a debug dump dev = 0x%x, start = 0x%x, end = 0x%x\n",dev_addr, reg_start, reg_end);
+		
+		for( i=reg_start; i<=reg_end; i++ )
+		{
+			i2c_buf[0] = i;
+			ret = aml_sii9233a_i2c_read(dev_addr, i2c_buf, 1, 1);
+			if( i%0x10 == 0 )
+					printk("%.2X:", i);
+			printk(" %.2X",i2c_buf[0]);
+			if( (i+1)%0x10 == 0 )
+				printk("\n");
+		}
+		printk("\n");
+	}
+	else if( cmd == 3 ) // write
+	{
+		reg_start = (unsigned char)simple_strtoul(argv[2],NULL,16);
+		value = (unsigned char)simple_strtoul(argv[3],NULL,16); 
+		printk("\nsii9233a debug write dev = 0x%x, reg = 0x%x, value = 0x%x\n",dev_addr, reg_start, value);
+		i2c_buf[0] = reg_start;
+		i2c_buf[1] = value;
+
+		ret = aml_sii9233a_i2c_write(dev_addr, i2c_buf, 2);
+		printk("sii9233a i2c write ret = %d\n",ret);
+		ret = aml_sii9233a_i2c_read(dev_addr, i2c_buf, 1, 1);
+		printk("sii9233a i2c read back ret = %d, value = 0x%x\n",ret, i2c_buf[0]);
+	}
+	else if( cmd == 4 ) // get hdmi input video info
+	{
+		printk("begin dump hdmi-in video info:\n");
+		dump_input_video_info();
+	}
+	else if( cmd == 5 ) // tt, for loop test of 9293 i2c
+	{
+		unsigned int type = 255, count = 0, i = 0, v1 = 0, v2 = 0;
+		unsigned int err1 = 0, err2 = 0, sum = 0, sum_failed = 0;
+
+		type = (unsigned int )simple_strtoul(argv[1], NULL, 10);
+		count = (unsigned int)simple_strtoul(argv[2], NULL, 10);
+
+		printk("9233 i2c stability test: type = %d, count = %d\n", type, count);
+
+		if( type == 0 ) // 0x2/0x3 = 3392
+		{
+			unsigned int i = 0, v1 = 0, v2 = 0;
+			unsigned int err1 = 0, err2 = 0, sum_failed = 0;
+			for( i=0; i<count; i++ )
+			{
+				msleep(2);
+				v1 = sii_get_chip_id();
+				msleep(2);
+				v2 = sii_get_h_total();
+				
+				if( v1 != 0x9233 )
+				{
+					err1 ++;
+					printk("sii2ctest, ID failed: [%d], [%d] = 0x%x\n", i, err1, v1);
+				}
+				if( v2 != 0x672 )
+				{
+					err2 ++;
+					printk("sii2ctest, RES_H failed: [%d], [%d] = 0x%x\n", i, err2, v2);
+				}
+
+				printk("sii2ctest, [%d]: err1 = %d, v1 = 0x%x, err2 = %d v2 = 0x%x\n", i, err1, v1, err2, v2);
+			}
+		}
+	}
+
+	kfree(p);
+	return count;
+}
+
+static ssize_t sii9233a_reset_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t sii9233a_reset_store(struct class *class, struct class_attribute *attr,
+									const char *buf, size_t count)
+{
+	unsigned char value = 0;
+    char *endp;
+
+    value = (unsigned char)simple_strtoul(buf, &endp, 0);
+
+    if( value != 0 )
+    {
+    	sii_hardware_reset(&sii9233a_info);
+	}
+    
+    return count;
+}
+
+static ssize_t sii9233a_port_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	char port = 0xff;
+
+	port = sii_get_hdmi_port();
+
+	return sprintf(buf, "current sii9233a input port = %d\n", port);
+}
+
+static ssize_t sii9233a_port_store(struct class *class, struct class_attribute *attr,
+									const char *buf, size_t count)
+{
+	unsigned char port = 0;
+	char *endp;
+
+	port = (unsigned char)simple_strtoul(buf, &endp, 0);
+
+	if( port < 4 )
+	{
+		sii_set_hdmi_port(port);
+		printk("set sii9233a input port = %d\n",port);
+	}
+	return count;
+}
+static ssize_t sii9233a_enable_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "sii9233a tvin enable = %d\n", sii9233a_info.user_cmd);
+}
+static ssize_t sii9233a_enable_store(struct class *class, struct class_attribute *attr,
+									const char *buf, size_t count)
+{
+	int argn;
+	char *p=NULL, *para=NULL, *argv[5] = {NULL,NULL,NULL,NULL,NULL};
+	unsigned int mode = 0, enable=0, height = 0, width = 0, frame_rate = 0, field_flag = 0;
+	char *vmode[10] = {"480i\n","480p\n","576i\n","576p\n","720p50\n","720p\n","1080i\n","1080p\n","1080i50\n","1080p50\n"};
+	int i = 0;
+
+	p = kstrdup(buf, GFP_KERNEL);
+	for( argn=0; argn<4; argn++ )
+	{
+		para = strsep(&p, " ");
+		if( para == NULL )
+			break;
+		argv[argn] = para;
+	}
+
+//	printk("argn = %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\"\n", argn, argv[0], argv[1], argv[2], argv[3], argv[4] );
+	if( !strcmp(argv[0], "0\n") ) // disable
+		enable = 0;
+	else if( !strcmp(argv[0], "1\n") ) // enable, driver will trigger to vdin-stop
+		enable = 1;
+	else if( !strcmp(argv[0], "2\n") ) // enable, driver will trigger to vdin-start
+		enable = 2;
+	else if( !strcmp(argv[0], "3\n") ) // enable, driver will trigger to vdin-start/vdin-stop
+		enable = 3;
+	else if( !strcmp(argv[0], "4\n") ) // enable, driver will not trigger to vdin-start/vdin-stop
+		enable = 4;
+	else
+	{
+		for( i=0; i<10; i++ )
+		{
+			if( !strcmp(argv[0], vmode[i]) )
+			{
+				mode = i;
+				enable = 0xff;
+			}
+		}
+	}
+
+	sii9233a_info.user_cmd = enable;
+
+	if( (enable==1) && (argn!=5) && (argn!=1) )
+	{
+		printk("invalid parameters to enable cmd !\n");
+		return count;
+	}
+
+	if( (enable==0) && (sii9233a_info.vdin_started==1) )
+	{
+		sii9233a_stop_vdin(&sii9233a_info);
+		printk("sii9233a disable dvin !\n");
+	}
+	else if( ( (enable==1)||(enable==2)||(enable==3)||(enable==4) ) && (sii9233a_info.vdin_started==0) )
+	{
+		mode = sii9233a_get_output_mode();
+		sii9233a_start_vdin_mode(mode);
+		printk("sii9233a enable(0x%x) dvin !\n", enable);
+	}
+	else if( (enable==0xff) && (sii9233a_info.vdin_started==0) )
+	{
+		
+		switch(mode)
+		{
+			case 0: // 480i
+				mode = CEA_480I60;		break;
+			case 1: // 480p
+				mode = CEA_480P60;		break;
+			case 2: // 576i
+				mode = CEA_576I50;		break;
+			case 3: // 576p
+				mode = CEA_576P50;		break;
+			case 4: // 720p50
+				mode = CEA_720P50;		break;
+			case 5: // 720p60
+			default:
+				mode = CEA_720P60;		break;
+			case 6: // 1080i60
+				mode = CEA_1080I60;		break;
+			case 7: // 1080p60
+				mode = CEA_1080P60;		break;
+			case 8: // 1080i50
+				mode = CEA_1080I50;		break;
+			case 9: // 1080p50
+				mode = CEA_1080P50;		break;
+		}
+
+		sii9233a_start_vdin_mode(mode);
+		printk("sii9233a enable(0x%x) dvin !\n", enable);
+	}
+
+	return count;
+}
+
+static ssize_t sii9233a_input_mode_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	unsigned int mode = 0xff;
+	char hdmi_mode_str[16], mode_str[16] ;
+	unsigned char value;
+
+	value = sii_is_hdmi_mode();
+	memset(hdmi_mode_str, 0x00, 16);
+	memset(mode_str, 0x00, 8);
+
+	strcpy(hdmi_mode_str,(value==0)?"DVI:":"HDMI:");
+	mode = sii9233a_get_output_mode();
+
+	switch(mode)
+	{
+		case CEA_480I60:	strcpy(mode_str, "480i");		break;
+		case CEA_480P60:	strcpy(mode_str, "480p");		break;
+		case CEA_576I50:	strcpy(mode_str, "576i");		break;
+		case CEA_576P50:	strcpy(mode_str, "576p");		break;
+		case CEA_720P60:	strcpy(mode_str, "720p");		break;
+		case CEA_720P50:	strcpy(mode_str, "720p50hz");	break;
+		case CEA_1080I60:	strcpy(mode_str, "1080i");		break;
+		case CEA_1080I50:	strcpy(mode_str, "1080i50hz");	break;
+		case CEA_1080P60:	strcpy(mode_str, "1080p");		break;
+		case CEA_1080P50:	strcpy(mode_str, "1080p50hz");	break;
+		default:			strcpy(mode_str, "invalid");	break;
+	}
+
+	if( strcmp(mode_str, "invalid") != 0 )
+		strcat(hdmi_mode_str, mode_str);
+	else
+		strcpy(hdmi_mode_str, mode_str);
+	return sprintf(buf, "%s\n", hdmi_mode_str);
+}
+
+static ssize_t sii9233a_cable_status_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	sii9233a_info.cable_status = sii_get_pwr5v_status();
+	return sprintf(buf, "%d\n", sii9233a_info.cable_status);
+}
+
+static ssize_t sii9233a_signal_status_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", sii9233a_info.signal_status);
+}
+
+static ssize_t sii9233a_audio_sr_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	int audio_sr;
+	char *audio_sr_array[] =
+	{
+		"44.1 kHz",			// 0x0
+		"Not indicated",	// 0x1
+		"48 kHz",			// 0x2
+		"32 kHz",			// 0x3
+		"22.05 kHz",		// 0x4
+		"reserved",			// 0x5
+		"24 kHz",			// 0x6
+		"reserved",			// 0x7
+		"88.2 kHz",			// 0x8
+		"768 kHz (192*4)",	// 0x9
+		"96 kHz",			// 0xa
+		"reserved",			// 0xb
+		"176.4 kHz",		// 0xc
+		"reserved",			// 0xd
+		"192 kHz",			// 0xe
+		"reserved"			// 0xf
+	};
+
+	audio_sr = sii_get_audio_sampling_freq()&0xf;
+
+	return sprintf(buf, "%s\n", audio_sr_array[audio_sr]);
+}
+
+static struct class_attribute sii9233a_class_attrs[] =
+{
+	__ATTR(debug,			S_IRUGO|S_IWUSR,	sii9233a_debug_show,			sii9233a_debug_store),
+//	__ATTR(reset,			S_IRUGO|S_IWUSR,	sii9233a_reset_show,			sii9233a_reset_store),
+	__ATTR(port,			S_IRUGO|S_IWUSR,	sii9233a_port_show,				sii9233a_port_store),
+	__ATTR(enable,			S_IRUGO|S_IWUSR,	sii9233a_enable_show,			sii9233a_enable_store),
+	__ATTR(input_mode,		S_IRUGO,			sii9233a_input_mode_show,		NULL),
+	__ATTR(cable_status,	S_IRUGO,			sii9233a_cable_status_show,	NULL),
+	__ATTR(signal_status,	S_IRUGO,			sii9233a_signal_status_show,	NULL),
+	__ATTR(audio_sample_rate,	S_IRUGO,			sii9233a_audio_sr_show,	NULL),
+	__ATTR_NULL	
+};
+
+static struct class sii9233a_class =
+{
+	.name = SII9233A_DRV_NAME,
+	.class_attrs = sii9233a_class_attrs,	
+};
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#if 0
+static void hdmirx_timer_handler(unsigned long arg)
+{
+    mod_timer(&hdmirx_timer, jiffies + HZ);
+}
+
+static void hdmirx_timer_init(void)
+{
+	init_timer(&hdmirx_timer);
+	hdmirx_timer.data = (ulong)0;
+	hdmirx_timer.function = hdmirx_timer_handler;
+	hdmirx_timer.expires = jiffies + HZ;
+	add_timer(&hdmirx_timer);
+}
+#endif
+
+extern void TIMER_Init(void);
+extern void sii9223a_main(void);
+
+static int sii9233a_task_handler(void *data)
+{
+	TIMER_Init();
+	
+	sii_hardware_reset(&sii9233a_info);
+
+	//sii_set_hdmi_port(3);
+
+	while(1)
+	{
+		sii9223a_main();
+		msleep(100);
+	}
+
+	return 0;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifdef CONFIG_USE_OF
+static int sii9233a_get_of_data(struct device_node *pnode)
+{
+	struct device_node *hdmirx_node = pnode;
+	struct i2c_board_info board_info;
+	struct i2c_adapter *adapter;
+	unsigned int i2c_index;
+	
+	const char *str;
+	int ret = 0;
+
+	memset(&sii9233a_info, 0x0, sizeof(sii9233a_info_t));
+
+// for i2c bus
+	ret = of_property_read_string(hdmirx_node, "i2c_bus", &str);
+	if (ret) {
+		printk("[%s]: faild to get i2c_bus str!\n", __FUNCTION__);
+		return -1;
+	} else {
+		if (!strncmp(str, "i2c_bus_ao", 9))
+			i2c_index = AML_I2C_MASTER_AO;
+		else if (!strncmp(str, "i2c_bus_a", 9))
+			i2c_index = AML_I2C_MASTER_A;
+		else if (!strncmp(str, "i2c_bus_b", 9))
+			i2c_index = AML_I2C_MASTER_B;
+		else if (!strncmp(str, "i2c_bus_c", 9))
+			i2c_index = AML_I2C_MASTER_C;
+		else if (!strncmp(str, "i2c_bus_d", 9))
+			i2c_index = AML_I2C_MASTER_D;
+		else
+			return -1; 
+	}
+	
+	sii9233a_info.i2c_bus_index = i2c_index;
+
+// for gpio_reset
+	ret = of_property_read_string(hdmirx_node, "gpio_reset", &str);
+	if (ret) {
+		printk("[%s]: faild to get gpio_rst!\n", __FUNCTION__);
+		return -2;
+	}
+
+	ret = amlogic_gpio_name_map_num(str);
+	if (ret < 0)
+	{
+		printk("[%s]: faild to map gpio_rst !\n", __FUNCTION__);
+	}
+	else
+		sii9233a_info.gpio_reset = ret;
+
+// for irq
+#if 0
+	ret = of_property_read_string(hdmirx_node,"gpio_intr",&str);
+	if(ret)
+	{
+		printk("[%s]: failed to get INT!\n", __FUNCTION__);
+		return -3;
+	}
+
+	ret = amlogic_gpio_name_map_num(str);
+	if(ret < 0 )
+	{
+		printk("[%s]: failed to map gpio_intr!\n", __FUNCTION__);
+	}
+	else
+		sii9233a_info.gpio_intr = ret;
+#endif
+
+	memset(&board_info, 0x0, sizeof(board_info));
+	strncpy(board_info.type, SII9233A_DRV_NAME, I2C_NAME_SIZE);
+	adapter = i2c_get_adapter(i2c_index);
+	board_info.addr = SII9233A_I2C_ADDR;
+	board_info.platform_data = &sii9233a_info;
+
+	sii9233a_info.i2c_client = i2c_new_device(adapter, &board_info);
+
+	return 0;
+}
+#endif
+
+static int sii9233a_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	
+#ifdef CONFIG_USE_OF
+	sii9233a_get_of_data(pdev->dev.of_node);
+#else
+	hdmirx_pdata = pdev->dev.platform_data;
+	if( !hdmirx_pdata )
+	{
+		printk("[%s] failed to get platform data !\n", __FUNCTION__);
+		return -ENOENT;
+	}
+#endif
+
+	amlogic_gpio_request(sii9233a_info.gpio_reset, SII9233A_DRV_NAME);
+
+	ret = sii9233a_register_tvin_frontend(&(sii9233a_info.tvin_frontend));
+	if( ret < 0 )
+	{
+		printk("[%s] register tvin frontend failed ret = %d!\n", __FUNCTION__, ret);
+	}
+
+	sii9233a_task = kthread_run(sii9233a_task_handler, &sii9233a_info, "kthread_sii9233a");
+
+	ret = class_register(&sii9233a_class);
+	if (ret)
+	{
+		printk("[%s] failed to register class ret = %d!\n", __FUNCTION__, ret);
+	}
+
+	return ret;
+}
+
+static int sii9233a_remove(struct platform_device *pdev)
+{
+	return 0;	
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id sii9233a_dt_match[] = {
+	{
+		.compatible			= "amlogic,sii9233",
+	},
+	{},
+};
+#else
+#define sii9223a_dt_match	NULL
+#endif
+
+
+static struct platform_driver sii9233a_driver = {
+	.probe			= sii9233a_probe,
+	.remove			= sii9233a_remove,
+	.driver			= {
+						.name				= SII9233A_DRV_NAME,
+						.owner				= THIS_MODULE,
+						.of_match_table		= sii9233a_dt_match,
+					}	
+};
+static int __init sii9233a_drv_init(void)
+{
+	int ret = 0;
+
+    printk("[%s] Ver: %s\n", __FUNCTION__, SII9233A_DRV_VER);
+
+    if (platform_driver_register(&sii9233a_driver))
+    {
+        printk("[%s] failed to register drv!\n", __FUNCTION__);
+        return -ENODEV;
+    }
+
+    return 0;
+}
+
+static void __exit sii9233a_drv_exit(void)
+{
+    printk("[%s]\n", __FUNCTION__);
+    platform_driver_unregister(&sii9233a_driver);
+    class_unregister(&sii9233a_class);
+    
+    return ;
+}
+
+module_init(sii9233a_drv_init);
+module_exit(sii9233a_drv_exit);
+
+MODULE_DESCRIPTION("AML SiI9233A driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.h b/drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.h
new file mode 100755
index 000000000000..98416a0b030d
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.h
@@ -0,0 +1,63 @@
+#ifndef __HDMIRX_H__
+#define __HDMIRX_H__
+
+#include <linux/i2c.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
+#include "../../../../hardware/tvin/tvin_frontend.h"
+
+#define SII9233A_DRV_VER "2013Nov12"
+
+#define SII9233A_DRV_NAME "sii9233a"
+
+typedef struct
+{
+	unsigned int 		cur_height;
+	unsigned int 		cur_width;
+	unsigned int 		cur_frame_rate;
+	/* data */
+}vdin_info_t;
+
+typedef struct
+{
+	unsigned int		i2c_bus_index;
+	struct i2c_client	*i2c_client;
+	gpio_t				gpio_intr; // interrupt pin
+	gpio_t				gpio_reset; // hardware reset pin
+	tvin_frontend_t		tvin_frontend;
+	vdin_parm_t			vdin_parm;
+	unsigned int 		vdin_started;
+	unsigned int 		user_cmd;	// 0 to disable from user
+									// 1 to enable, driver will trigger to vdin-stop
+									// 2 to enable, driver will trigger to vdin-start
+									// 3 to enable, driver will trigger to vdin-start/vdin-stop
+									// 4 to enable, driver will not trigger to vdin-start/vdin-stop
+									// 0xff to enable, and driver will NOT trigger no signal-lost/vdin-stop, signal-get/vdin-start
+	unsigned int 		cable_status; // 1 for cable plug in, 0 for cable plgu out
+	unsigned int 		signal_status; // external hdmi cable is insert or not
+	vdin_info_t			vdin_info;
+}sii9233a_info_t;
+
+// according to the CEA-861-D
+typedef enum
+{
+	CEA_480P60	= 2,
+	CEA_720P60	= 4,
+	CEA_1080I60	= 5,
+	CEA_480I60	= 6,
+
+	CEA_1080P60	= 16,
+	CEA_576P50	= 17,
+	CEA_720P50	= 19,
+	CEA_1080I50	= 20,
+	CEA_576I50	= 21,
+
+	CEA_1080P50	= 31,
+
+	CEA_MAX = 60
+}SII9233_VIDEO_MODE;
+
+int aml_sii9233a_i2c_read(unsigned char dev_addr, char *buf, int addr_len, int data_len);
+int aml_sii9233a_i2c_write(unsigned char dev_addr, char *buf, int len);
+
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/sii9233_interface.c b/drivers/amlogic/ext_hdmiin/sii9233/sii9233_interface.c
new file mode 100755
index 000000000000..d13a85d0df7b
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/sii9233_interface.c
@@ -0,0 +1,265 @@
+
+#include <local_types.h>
+#include <amf.h>
+#include <registers.h>
+#include "sii9233_drv.h"
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/delay.h>
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a hardware power reset
+
+void sii_hardware_reset(sii9233a_info_t *info)
+{
+	amlogic_gpio_direction_output(info->gpio_reset, 0, SII9233A_DRV_NAME);
+    msleep(60);
+    amlogic_gpio_direction_output(info->gpio_reset, 1, SII9233A_DRV_NAME);
+}
+
+int sii_get_pwr5v_status(void)
+{
+	char pwr5v;
+
+	pwr5v = RegisterRead(REG__STATE)&BIT__PWR5V;
+
+	return (pwr5v==0)?0:1;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a input hdmi port
+
+char sii_get_hdmi_port(void)
+{
+	char port;
+
+	port = RegisterRead(REG__PORT_SWTCH2);
+
+	return (port&MSK__PORT_EN);
+}
+
+void sii_set_hdmi_port(char port)
+{
+	if( (port>=0) && (port<4) )
+	{
+		RegisterWrite(REG__PORT_SWTCH, (1<<(port+4)) );
+		RegisterModify(REG__PORT_SWTCH2, MSK__PORT_EN, port);
+	}
+
+	return ;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a output signal horizontal parameters
+
+int sii_get_h_active(void)
+{
+	unsigned char high,low;
+
+	high = RegisterRead(REG__VID_DE_PIXEL2)&MSK__VID_DE_PIXEL_BIT8_11;
+	low = RegisterRead(REG__VID_DE_PIXEL1);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_h_total(void)
+{
+	unsigned char high,low;
+
+	high = RegisterRead(REG__VID_H_RES2)&MSK__VID_H_RES_BIT8_12;
+	low = RegisterRead(REG__VID_H_RES1);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_hs_width(void)
+{
+	unsigned char high,low;
+
+	high = RegisterRead(REG__VID_HS_WIDTH2)&MSK__VID_HS_WIDTH_BIT8_9;
+	low = RegisterRead(REG__VID_HS_WIDTH1);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_hs_frontporch(void)
+{
+	unsigned char high,low;
+
+	high = RegisterRead(REG__VID_H_FP2)&MSK__VID_H_FP_BIT8_9;
+	low = RegisterRead(REG__VID_H_FP1);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_hs_backporch(void)
+{
+	int backporch = 0;
+
+	backporch = sii_get_h_total() - sii_get_h_active() - sii_get_hs_frontporch() - sii_get_hs_width();
+
+	return backporch;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a output signal vertical parameters
+
+int sii_get_v_active(void)
+{
+	unsigned char high,low;
+
+	high = RegisterRead(REG__VID_DE_LINE2)&MSK__VID_DE_LINE_BIT8_10;
+	low = RegisterRead(REG__VID_DE_LINE1);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_v_total(void)
+{
+	unsigned char high,low;
+
+	high = RegisterRead(REG__VID_V_RES2)&MSK__VID_V_RES_BIT8_10;
+	low = RegisterRead(REG__VID_V_RES1);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_vs_width(void)
+{
+	return 0;
+}
+
+int sii_get_vs_to_de(void)
+{
+	unsigned char low;
+
+	low = RegisterRead(REG__VID_VS_AVT)&MSK__VID_VS_AVT_BIT0_5;
+
+	return low;
+}
+
+int sii_get_vs_frontporch(void)
+{
+	unsigned char low;
+
+	low = RegisterRead(REG__VID_V_FP)&MSK__VID_V_FP_BIT0_5;
+
+	return low;
+}
+
+int sii_get_vs_backporch(void)
+{
+	return 0;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a video pixel clock
+#if 0
+// this 2 parameters seem not correct according to 9233 program guide document.
+
+int sii_get_video_pixel_clock(void)
+{
+	unsigned char high,low;
+
+	high = RegisterRead(REG__VIDA_XPCNT1)&MSK__VIDA_XPCNT1_BIT8_11;
+	low = RegisterRead(REG__VIDA_XPCNT0);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_frame_rate(void)
+{
+	unsigned int h_total, v_total, f_xtal = 27000000, clk;
+	unsigned int t_framerate;
+
+	h_total = sii_get_h_total();
+	v_total = sii_get_v_total();
+	clk = sii_get_video_pixel_clock();
+
+	t_framerate = h_total*clk*v_total/2048/f_xtal;
+
+	return (int)t_framerate;
+}
+#endif
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a utility
+void dump_input_video_info(void)
+{
+	int height,width,h_total,v_total;
+	int hs_fp,hs_width,hs_bp;
+	int vs_fp,vs_de;
+	//int clk,frame_rate;
+
+	height = sii_get_h_active();
+	width = sii_get_v_active();
+
+	h_total = sii_get_h_total();
+	v_total = sii_get_v_total();
+
+	hs_fp = sii_get_hs_frontporch();
+	hs_width = sii_get_hs_width();
+	hs_bp = sii_get_hs_backporch();
+
+	vs_fp = sii_get_vs_frontporch();
+	vs_de = sii_get_vs_to_de();
+	//clk = sii_get_video_pixel_clock();
+	//frame_rate = sii_get_frame_rate();
+
+	printk("sii9223a hdmi-in video info:\n\n\
+		height * width = %4d x %4d, ( %4d x %4d )\n\
+		h sync = %4d, %4d, %4d\n\
+		v sync = %4d,      %4d\n",
+		height,width,h_total,v_total,
+		hs_fp,hs_width,hs_bp,
+		vs_fp,vs_de);
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a output spdif status
+int sii_get_spdif_status(void)
+{
+	//todo
+	return 0;
+}
+
+int sii_is_hdmi_mode(void)
+{
+	unsigned char mode;
+
+	mode = RegisterRead(REG__AUDP_STAT)&BIT__HDMI_DET;
+	mode = (mode==0)?0:1;
+
+	return mode;
+}
+
+// audio sampling frequency:
+// 0x0 for 44.1 KHz
+// 0x1 for Not indicated
+// 0x2 for 48 KHz
+// 0x3 for 32 KHz
+// 0x4 for 22.05 KHz
+// 0x6 for 24 kHz
+// 0x8 for 88.2 kHz
+// 0x9 for 768 kHz (192*4)
+// 0xa for 96 kHz
+// 0xc for 176.4 kHz
+// 0xe for 192 kHz
+int sii_get_audio_sampling_freq(void)
+{
+	unsigned char freq;
+
+	freq = RegisterRead(REG__AUD_CHST4)&BIT__AUD_FS;
+
+	return freq;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a general status
+int sii_get_chip_id(void)
+{
+	unsigned char high, low;
+
+	high = RegisterRead(REG__IDH_RX);
+	low = RegisterRead(REG__IDL_RX);
+
+	return ( (high<<8) | low );
+}
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/sii9233_interface.h b/drivers/amlogic/ext_hdmiin/sii9233/sii9233_interface.h
new file mode 100755
index 000000000000..9cf356dd7514
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/sii9233_interface.h
@@ -0,0 +1,51 @@
+#ifndef __SII9233A_INTERFACE_H__
+#define __SII9233A_INTERFACE_H__
+
+#include "sii9233_drv.h"
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a hardware power reset
+
+void sii_hardware_reset(sii9233a_info_t *info);
+int sii_get_pwr5v_status(void);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a input hdmi port
+
+char sii_get_hdmi_port(void);
+void sii_set_hdmi_port(char port);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a output signal horizontal parameters
+
+int sii_get_h_active(void);
+int sii_get_h_total(void);
+int sii_get_hs_width(void);
+int sii_get_hs_frontporch(void);
+int sii_get_hs_backporch(void);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a output signal vertical parameters
+
+int sii_get_v_active(void);
+int sii_get_v_total(void);
+int sii_get_hs_width(void);
+int sii_get_vs_to_de(void);
+int sii_get_vs_frontporch(void);
+int sii_get_vs_backporch(void);
+int sii_get_video_pixel_clock(void);
+int sii_get_frame_rate(void);
+void dump_input_video_info(void);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a audio realated api
+
+int sii_is_hdmi_mode(void);
+int sii_get_audio_sampling_freq(void);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii9233a general status
+int sii_get_chip_id(void);
+
+#endif
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/vdin_interface.c b/drivers/amlogic/ext_hdmiin/sii9233/vdin_interface.c
new file mode 100755
index 000000000000..704a1072d244
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/vdin_interface.c
@@ -0,0 +1,458 @@
+
+#include <mach/am_regs.h>
+#include "sii9233_drv.h"
+#include "../../../../hardware/tvin/tvin_frontend.h"
+#include "sii9233_interface.h"
+
+extern int start_tvin_service(int no ,vdin_parm_t *para);
+extern int stop_tvin_service(int no);
+extern void set_invert_top_bot(bool invert_flag);
+
+static void enable_vdin_pinmux(void)
+{
+
+	// disable LCD pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_0, READ_CBUS_REG(PERIPHS_PIN_MUX_0) & 
+	 ( ~(1       | // LCD_R 2/3/4/5/6/7
+		(1 << 1)  | // LCD_R 0/1
+		(1 << 2)  | // LCD_G 2/3/4/5/6/7
+		(1 << 3)  | // LCD_G 0/1
+		(1 << 4)  | // LCD_B 2/3/4/5/6/7
+		(1 << 5)  | // LCD_B 0/1
+		(1 << 18) | // LCD_HS
+		(1 << 19)) )    // LCD_VS
+		);
+
+	// disable TCON pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_8, READ_CBUS_REG(PERIPHS_PIN_MUX_8) & 
+	 ( ~((1 << 19) | // TCON_VCOM
+		(1 << 20) | // TCON_CPH3
+		(1 << 21) | // TCON_CPH2
+		(1 << 22) | // TCON_CPH1
+		(1 << 23) | // TCON_STH1
+		(1 << 24) | // TCON_STV1
+		(1 << 25) | // TCON_CPV
+		(1 << 26) | // TCON_VCOM
+		(1 << 27) | // TCON_OEV
+		(1 << 28)) )   // TCON_OEH
+		);
+
+	// disable ENC pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_7, READ_CBUS_REG(PERIPHS_PIN_MUX_7) & 
+	 ( ~(1     | // ENC_0
+		(1 << 1)  | // ENC_1
+		(1 << 2)  | // ENC_2
+		(1 << 3)  | // ENC_3
+		(1 << 4)  | // ENC_4
+		(1 << 5)  | // ENC_5
+		(1 << 6)  | // ENC_6
+		(1 << 7)  | // ENC_7
+		(1 << 8)  | // ENC_8
+		(1 << 9)  | // ENC_9
+		(1 << 10) | // ENC_10
+		(1 << 11) | // ENC_11
+		(1 << 12) | // ENC_12
+		(1 << 13) | // ENC_13
+		(1 << 14) | // ENC_14
+		(1 << 15) | // ENC_15
+		(1 << 16) | // ENC_16(eNet_0)
+		(1 << 17)) )    // ENC_17(eNet_1)
+		);
+
+	// disable PWM pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_3, READ_CBUS_REG(PERIPHS_PIN_MUX_3) & 
+	 ( ~((1 << 24) | // PWM_C
+		(1 << 25) | // PWM_C
+		(1 << 26)))    // PWM_D
+		);
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_7, READ_CBUS_REG(PERIPHS_PIN_MUX_7) & 
+	 ( ~((1 << 26) | // PWM_VS
+		(1 << 27) | // PWM_VS
+		(1 << 28)))    // PWM_VS
+		);
+
+	// disable VGA pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_0, READ_CBUS_REG(PERIPHS_PIN_MUX_0) & 
+	 ( ~((1 << 20) | // VGA_HS
+		(1 << 21)))    // VGA_VS
+		);
+
+	// enable DVIN pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_0, READ_CBUS_REG(PERIPHS_PIN_MUX_0) | 
+	 ( (1 << 6)  | // DVIN R/G/B 0/1/2/3/4/5/6/7
+		(1 << 7)  | // DVIN_CLK
+		(1 << 8)  | // DVIN_HS
+		(1 << 9)  | // DVIN_VS
+		(1 << 10))    // DVIN_DE
+		);
+}
+
+static int sii9233a_tvin_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
+{
+	if(port == TVIN_PORT_DVIN0)
+		return 0;
+	else
+		return -1;
+}
+static int sii9233a_tvin_open(tvin_frontend_t *fe, enum tvin_port_e port)
+{
+	sii9233a_info_t *devp = container_of(fe,sii9233a_info_t,tvin_frontend);
+
+	/*copy the vdin_parm_s to local device parameter*/
+	if( !memcpy(&devp->vdin_parm,fe->private_data,sizeof(vdin_parm_t)) )
+	{
+		printk("[%s] copy vdin parm error.\n",__func__);
+	}
+
+	enable_vdin_pinmux();
+
+	WRITE_MPEG_REG_BITS(VDIN_ASFIFO_CTRL2, 0x39, 2, 6); 
+
+	return 0;
+}
+
+static void sii9233a_tvin_close(struct tvin_frontend_s *fe)
+{
+	return ;          
+}
+static void sii9233a_tvin_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
+{
+	return ;
+}
+static void sii9233a_tvin_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
+{
+	return ;      
+}
+static int sii9233a_tvin_isr(struct tvin_frontend_s *fe, unsigned int hcnt64)
+{
+	return 0;
+}
+
+static struct tvin_decoder_ops_s sii9233a_tvin_dec_ops = {
+				.support 		= sii9233a_tvin_support,
+				.open 			= sii9233a_tvin_open,
+				.close 			= sii9233a_tvin_close,
+				.start  		= sii9233a_tvin_start,
+				.stop  			= sii9233a_tvin_stop,
+				.decode_isr 	= sii9233a_tvin_isr, 
+};
+
+static void sii9233a_tvin_get_sig_propery(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop)
+{
+	sii9233a_info_t *devp = container_of(fe,sii9233a_info_t,tvin_frontend);
+
+	prop->color_format = TVIN_RGB444;
+	prop->dest_cfmt = TVIN_YUV422;
+	if( (devp->vdin_parm.h_active==1440) && 
+	  ((devp->vdin_parm.v_active==576)||(devp->vdin_parm.v_active==480)) )
+	  prop->decimation_ratio = 1;
+	else 
+	  prop->decimation_ratio = 0;
+
+	return ;
+}
+
+static struct tvin_state_machine_ops_s sii9233a_tvin_sm_ops = {
+		.get_sig_propery = sii9233a_tvin_get_sig_propery,
+};
+
+int sii9233a_register_tvin_frontend(struct tvin_frontend_s *frontend)
+{
+	int ret = 0;
+
+	ret = tvin_frontend_init(frontend, &sii9233a_tvin_dec_ops, &sii9233a_tvin_sm_ops, 0);
+	if( ret != 0 )
+	{
+		printk("[%s] init tvin frontend failed = %d\n", __FUNCTION__, ret);
+		return -1;
+	}
+
+	ret = tvin_reg_frontend(frontend);
+	if( ret != 0 )
+	{
+		printk("[%s] register tv in frontend failed = %d\n", __FUNCTION__, ret);
+		return -2;
+	}
+
+	return 0;
+}
+
+void sii9233a_config_dvin (unsigned long hs_pol_inv,             // Invert HS polarity, for HW regards HS active high.
+						unsigned long vs_pol_inv,             // Invert VS polarity, for HW regards VS active high.
+						unsigned long de_pol_inv,             // Invert DE polarity, for HW regards DE active high.
+						unsigned long field_pol_inv,          // Invert FIELD polarity, for HW regards odd field when high.
+						unsigned long ext_field_sel,          // FIELD source select:
+																		  // 1=Use external FIELD signal, ignore internal FIELD detection result;
+																		  // 0=Use internal FIELD detection result, ignore external input FIELD signal.
+						unsigned long de_mode,                // DE mode control:
+																		  // 0=Ignore input DE signal, use internal detection to to determine active pixel;
+																		  // 1=Rsrv;
+																		  // 2=During internal detected active region, if input DE goes low, replace input data with the last good data;
+																		  // 3=Active region is determined by input DE, no internal detection.
+						unsigned long data_comp_map,          // Map input data to form YCbCr.
+																		  // Use 0 if input is YCbCr;
+																		  // Use 1 if input is YCrCb;
+																		  // Use 2 if input is CbCrY;
+																		  // Use 3 if input is CbYCr;
+																		  // Use 4 if input is CrYCb;
+																		  // Use 5 if input is CrCbY;
+																		  // 6,7=Rsrv.
+						unsigned long mode_422to444,          // 422 to 444 conversion control:
+																		  // 0=No convertion; 1=Rsrv;
+																		  // 2=Convert 422 to 444, use previous C value;
+																		  // 3=Convert 422 to 444, use average C value.
+						unsigned long dvin_clk_inv,           // Invert dvin_clk_in for ease of data capture.
+						unsigned long vs_hs_tim_ctrl,         // Controls which edge of HS/VS (post polarity control) the active pixel/line is related:
+																		  // Bit 0: HS and active pixel relation.
+																		  //  0=Start of active pixel is counted from the rising edge of HS;
+																		  //  1=Start of active pixel is counted from the falling edge of HS;
+																		  // Bit 1: VS and active line relation.
+																		  //  0=Start of active line is counted from the rising edge of VS;
+																		  //  1=Start of active line is counted from the falling edge of VS.
+						unsigned long hs_lead_vs_odd_min,     // For internal FIELD detection:
+																		  // Minimum clock cycles allowed for HS active edge to lead before VS active edge in odd field. Failing it the field is even.
+						unsigned long hs_lead_vs_odd_max,     // For internal FIELD detection:
+																		  // Maximum clock cycles allowed for HS active edge to lead before VS active edge in odd field. Failing it the field is even.
+						unsigned long active_start_pix_fe,    // Number of clock cycles between HS active edge to first active pixel, in even field.
+						unsigned long active_start_pix_fo,    // Number of clock cycles between HS active edge to first active pixel, in odd field.
+						unsigned long active_start_line_fe,   // Number of clock cycles between VS active edge to first active line, in even field.
+						unsigned long active_start_line_fo,   // Number of clock cycles between VS active edge to first active line, in odd field.
+						unsigned long line_width,             // Number_of_pixels_per_line
+						unsigned long field_height)           // Number_of_lines_per_field
+{
+	unsigned long data32;
+
+//	printk("[%s] config pol_inv: hs = %d, vs = %d, de = %d, field = %d, clk = %d\n",__FUNCTION__, hs_pol_inv,vs_pol_inv,de_pol_inv,field_pol_inv,dvin_clk_inv);
+//	printk("[%s]: %lu %lu %lu %lu.\n",  __FUNCTION__, active_start_pix_fe, active_start_line_fe,  line_width, field_height);  
+	// Program reg DVIN_CTRL_STAT: disable DVIN
+	WRITE_MPEG_REG(DVIN_CTRL_STAT, 0);
+
+	// Program reg DVIN_FRONT_END_CTRL
+	data32 = 0;
+	data32 |= (hs_pol_inv       & 0x1)  << 0;
+	data32 |= (vs_pol_inv       & 0x1)  << 1;
+	data32 |= (de_pol_inv       & 0x1)  << 2;
+	data32 |= (field_pol_inv    & 0x1)  << 3;
+	data32 |= (ext_field_sel    & 0x1)  << 4;
+	data32 |= (de_mode          & 0x3)  << 5;
+	data32 |= (mode_422to444    & 0x3)  << 7;
+	data32 |= (dvin_clk_inv     & 0x1)  << 9;
+	data32 |= (vs_hs_tim_ctrl   & 0x3)  << 10;
+	WRITE_MPEG_REG(DVIN_FRONT_END_CTRL, data32);
+
+	// Program reg DVIN_HS_LEAD_VS_ODD
+	data32 = 0;
+	data32 |= (hs_lead_vs_odd_min & 0xfff) << 0;
+	data32 |= (hs_lead_vs_odd_max & 0xfff) << 16;
+	WRITE_MPEG_REG(DVIN_HS_LEAD_VS_ODD, data32);
+
+	// Program reg DVIN_ACTIVE_START_PIX
+	data32 = 0;
+	data32 |= (active_start_pix_fe & 0xfff) << 0;
+	data32 |= (active_start_pix_fo & 0xfff) << 16;
+	WRITE_MPEG_REG(DVIN_ACTIVE_START_PIX, data32);
+
+	// Program reg DVIN_ACTIVE_START_LINE
+	data32 = 0;
+	data32 |= (active_start_line_fe & 0xfff) << 0;
+	data32 |= (active_start_line_fo & 0xfff) << 16;
+	WRITE_MPEG_REG(DVIN_ACTIVE_START_LINE, data32);
+
+	// Program reg DVIN_DISPLAY_SIZE
+	data32 = 0;
+	data32 |= ((line_width-1)   & 0xfff) << 0;
+	data32 |= ((field_height-1) & 0xfff) << 16;
+	WRITE_MPEG_REG(DVIN_DISPLAY_SIZE, data32);
+
+	// Program reg DVIN_CTRL_STAT, and enable DVIN
+	data32 = 0;
+	data32 |= 1                     << 0;
+	data32 |= (data_comp_map & 0x7) << 1;
+	WRITE_MPEG_REG(DVIN_CTRL_STAT, data32);
+//    printk("[%s] end !\n", __FUNCTION__);
+} /* config_dvin */
+
+void sii9233a_stop_vdin(sii9233a_info_t *info)
+{
+	if( info->vdin_started == 0 )
+	  return ;
+
+	stop_tvin_service(0);
+	set_invert_top_bot(false);
+	info->vdin_started = 0;
+	printk("%s: stop vdin\n", __FUNCTION__);
+	return ;
+}
+
+void sii9233a_start_vdin(sii9233a_info_t *info, int width, int height, int frame_rate, int field_flag)
+{
+	vdin_parm_t para;
+
+	printk("[%s]-%.3d, width = %d, height = %d, frame_rate = %d, field_flag = %d\n",
+							__FUNCTION__, __LINE__, width,height,frame_rate,field_flag);
+
+	//    printk("[%s]-%.3d, info = 0x%x\n",__FUNCTION__, __LINE__, info);
+	if(info->vdin_started)
+	{
+		//printk("[%s]-%.3d, info->vdin_info = 0x%x\n",__FUNCTION__, __LINE__, &(info->vdin_info) );
+		if( (info->vdin_info.cur_width != width) || (info->vdin_info.cur_height != height) ||
+											(info->vdin_info.cur_frame_rate != frame_rate) )
+		{
+			stop_tvin_service(0);
+			info->vdin_started=0;
+			printk("%s: stop vdin\n", __func__);
+		}
+	}
+
+	if( (info->vdin_started==0) && (width>0) && (height>0) && (frame_rate>0) )
+	{
+		int start_pix, start_line_o, start_line_e, h_total, v_total;
+
+		info->vdin_info.cur_width = width;
+		info->vdin_info.cur_height = height;
+		info->vdin_info.cur_frame_rate = frame_rate;
+
+		if(field_flag && height <= 576 )
+		{
+			// for rgb 576i signal from 9233, it's 720/864, not 1440/1728
+			if( (width==1440)&&(height==576) )
+			{
+				start_pix = 138;
+				start_line_o = 22;
+				start_line_e = 23;
+				h_total = 1728;
+				v_total = 625;
+			}
+			// for rgb 480i signal from 9233, it's 720/858, not 1440/1716
+			else if( (width==1440)&&(height==480) )
+			{
+				start_pix = 114;
+				start_line_o = 18;
+				start_line_e = 19;
+				h_total = 1716;
+				v_total = 525;
+			}
+			sii9233a_config_dvin(1, //hs_pol_inv,          
+						1, //vs_pol_inv,          
+						0, //de_pol_inv,          
+						0, //field_pol_inv,       
+						0, //ext_field_sel,       
+						3, //de_mode,             
+						0, //data_comp_map,       
+						0, //mode_422to444,       
+						0, //dvin_clk_inv,        
+						0, //vs_hs_tim_ctrl,      
+						400, //hs_lead_vs_odd_min,  
+						1200, //hs_lead_vs_odd_max,  
+						start_pix,//sii_get_hs_backporch()*2,//0xdc, //active_start_pix_fe, 
+						start_pix,//sii_get_hs_backporch()*2,//0xdc, //active_start_pix_fo, 
+						start_line_e,//sii_get_vs_backporch(), //0x19, //active_start_line_fe,
+						start_line_o,//sii_get_vs_backporch(),//0x19, //active_start_line_fo,
+						h_total,//sii_get_h_total(), //0x672, //line_width,          
+						v_total//sii_get_v_total()*2 //0x2ee //field_height
+						);
+		}
+		else
+		{
+			sii9233a_config_dvin(height>576?0:1, //hs_pol_inv,          
+						height>576?0:1, //vs_pol_inv,          
+						0, //de_pol_inv,          
+						(field_flag && height>=540)?1:0, //field_pol_inv, set to 1 for 1080i
+						0, //ext_field_sel,       
+						3, //de_mode,             
+						0, //data_comp_map,       
+						0, //mode_422to444,       
+						0, //dvin_clk_inv,        
+						0, //vs_hs_tim_ctrl,      
+						0, //hs_lead_vs_odd_min,  
+						0, //hs_lead_vs_odd_max,  
+						sii_get_hs_backporch(),//0xdc, //active_start_pix_fe, 
+						sii_get_hs_backporch(),//0xdc, //active_start_pix_fo, 
+						sii_get_vs_backporch(), //0x19, //active_start_line_fe,
+						sii_get_vs_backporch(),//0x19, //active_start_line_fo,
+						sii_get_h_total(), //0x672, //line_width,          
+						sii_get_v_total() //0x2ee //field_height
+						);       
+		}        
+
+		memset( &para, 0, sizeof(para));
+		para.port  = TVIN_PORT_DVIN0;
+		para.frame_rate = frame_rate;
+		para.h_active = info->vdin_info.cur_width;
+		para.v_active = info->vdin_info.cur_height;
+		if(field_flag){
+			if(info->vdin_info.cur_width == 1920 &&  
+			  (info->vdin_info.cur_height == 1080 || info->vdin_info.cur_height == 540)){
+				if( frame_rate == 60 )
+					para.fmt = TVIN_SIG_FMT_HDMI_1920X1080I_60HZ;
+				else if( frame_rate == 50 )
+					para.fmt = TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_A;
+				para.v_active = 1080;
+			}
+		/*
+			else if( info->vdin_info.cur_width == 720 &&  (info->vdin_info.cur_height == 576 || info->vdin_info.cur_height == 288)){
+				 para.fmt = TVIN_SIG_FMT_HDMI_720X576I_50HZ;
+				 para.v_active = 576;
+				 set_invert_top_bot(true);
+			}
+		*/
+			else if(info->vdin_info.cur_width == 1440 &&  
+			  (info->vdin_info.cur_height == 576 || info->vdin_info.cur_height == 288)){
+				para.fmt = TVIN_SIG_FMT_HDMI_1440X576I_50HZ;
+				para.v_active = 576;
+				set_invert_top_bot(true);
+			}
+		/*
+			else if( info->vdin_info.cur_width == 720 &&  (info->vdin_info.cur_height == 480 || info->vdin_info.cur_height == 240)){
+				 para.fmt = TVIN_SIG_FMT_HDMI_720X480I_60HZ;
+				 para.v_active = 480;
+				 set_invert_top_bot(true);
+			}
+		*/
+			else if(info->vdin_info.cur_width == 1440  &&  
+			  (info->vdin_info.cur_height == 480 || info->vdin_info.cur_height == 240)){
+				para.fmt = TVIN_SIG_FMT_HDMI_1440X480I_60HZ;
+				para.v_active = 480;
+				set_invert_top_bot(true);
+			}
+			else{
+				para.fmt = TVIN_SIG_FMT_MAX+1;
+				set_invert_top_bot(true);
+			}
+			para.scan_mode = TVIN_SCAN_MODE_INTERLACED;	
+		}
+		else{
+			if(info->vdin_info.cur_width == 1920 &&  info->vdin_info.cur_height == 1080){
+				para.fmt = TVIN_SIG_FMT_HDMI_1920X1080P_60HZ;
+			}
+			else if(info->vdin_info.cur_width == 1280 &&  info->vdin_info.cur_height == 720){
+				para.fmt = TVIN_SIG_FMT_HDMI_1280X720P_60HZ;
+			}
+			else if((info->vdin_info.cur_width == 1440 || info->vdin_info.cur_width == 720) &&  info->vdin_info.cur_height == 576){
+				para.fmt = TVIN_SIG_FMT_HDMI_720X576P_50HZ;
+			}
+			else if((info->vdin_info.cur_width == 1440 || info->vdin_info.cur_width == 720) &&  info->vdin_info.cur_height == 480){
+				para.fmt = TVIN_SIG_FMT_HDMI_720X480P_60HZ;
+			}
+			else{
+				para.fmt = TVIN_SIG_FMT_MAX+1;
+			}
+			para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
+		}
+		para.hsync_phase = 1;
+		para.vsync_phase = 0;
+		//para.hs_bp = 0;
+		//para.vs_bp = 2;
+		para.cfmt = TVIN_RGB444;
+		para.dfmt = TVIN_YUV422;
+		para.reserved = 0; //skip_num
+
+		printk("[%s] begin start_tvin_service() !\n",__FUNCTION__);
+		start_tvin_service(0,&para);
+		info->vdin_started = 1;
+
+		//printk("%s: %dx%d %d %d/s\n", __func__, width, height, frame_rate, field_flag);
+	}
+
+	return ;
+}
diff --git a/drivers/amlogic/ext_hdmiin/sii9233/vdin_interface.h b/drivers/amlogic/ext_hdmiin/sii9233/vdin_interface.h
new file mode 100755
index 000000000000..54ac236cc52c
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9233/vdin_interface.h
@@ -0,0 +1,7 @@
+#ifndef __VDIN_INTERFACE_H__
+#define __VDIN_INTERFACE_H__
+
+void sii9233a_stop_vdin(sii9233a_info_t *info);
+void sii9233a_start_vdin(sii9233a_info_t *info, int width, int height, int frame_rate, int field_flag);
+
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/application/si_common.h b/drivers/amlogic/ext_hdmiin/sii9293/application/si_common.h
new file mode 100755
index 000000000000..e015123795a6
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/application/si_common.h
@@ -0,0 +1,81 @@
+//***************************************************************************
+//!file     si_common.h
+//!brief    Silicon Image common definitions header.
+//
+// No part of this work may be reproduced, modified, distributed, 
+// transmitted, transcribed, or translated into any language or computer 
+// format, in any form or by any means without written permission of 
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2008-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+#ifndef __SI_COMMON_H__
+#define __SI_COMMON_H__
+
+
+#if defined(__KERNEL__)
+#include <linux/types.h>
+#include <linux/string.h>
+#include "sii_hal.h"
+#include "si_osdebug.h"
+#include "mhl_linuxdrv.h"
+#else
+#include "string.h"
+#include "si_datatypes.h"
+#include "si_platform.h"
+#include "si_hal.h"
+#include "si_i2c.h"
+#include "si_eeprom.h"
+#include "si_debugger_hdmigear.h"
+#include "si_dbgprint.h"
+#include "si_osal_timer.h"
+#endif
+#include "si_rx_info.h"
+#include "si_sii5293_registers.h"
+#include "si_drv_rx_cfg.h"
+#include "si_drv_cbus.h"
+#include "si_cra.h"
+#include "si_drv_device.h"
+#include "si_video_tables.h"
+
+typedef enum
+{
+    SiiSYSTEM_NONE      = 0,
+    SiiSYSTEM_SINK,
+    SiiSYSTEM_SWITCH,
+    SiiSYSTEM_SOURCE,
+    SiiSYSTEM_REPEATER,
+} SiiSystemTypes_t;
+
+#define YES                         1
+#define NO                          0
+
+//------------------------------------------------------------------------------
+//  Basic system functions
+//------------------------------------------------------------------------------
+
+#define ELAPSED_TIMER               0xFF
+#define ELAPSED_TIMER1              0xFE
+#define TIMER_0                     0   // DO NOT USE - reserved for TimerWait()
+#define TIMER_1                     1
+#define TIMER_2                     2
+#define TIMER_3                     3
+#define TIMER_COUNT                 4
+#if 0
+uint8_t SiiTimerExpired( uint8_t timer );
+long    SiiTimerElapsed( uint8_t index );
+long    SiiTimerTotalElapsed ( void );
+void    SiiTimerWait( uint16_t m_sec );
+void    SiiTimerSet( uint8_t index, uint16_t m_sec );
+void    SiiTimerInit( void );
+#endif
+//------------------------------------------------------------------------------
+//  Miscellaneous Stuffs
+//--------------------------------------------------
+
+#define FPGA_BUILD_NEW		0	// 1 == FPGA, 0 == Silicon
+
+//#define SK_TX_EVITA				// enable this when there is Evita as TX on SK
+
+#endif  // __SI_COMMON_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/application/sk_app_cbus.c b/drivers/amlogic/ext_hdmiin/sii9293/application/sk_app_cbus.c
new file mode 100755
index 000000000000..2ff5754be210
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/application/sk_app_cbus.c
@@ -0,0 +1,273 @@
+//***************************************************************************
+//!file     sk_app_cbus.c
+//!brief    Wraps board and device functions for the CBUS component
+//          and the application
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2009-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+#include "si_common.h"
+
+#include "si_cbus_component.h"
+#include "si_drv_cbus.h"
+#include "si_drv_rx.h"
+
+
+/*****************************************************************************/
+/**
+ *  @brief		Process the passed RCP message.
+ *
+ *  @param[in]		rcpData		rcp data
+ *
+ *  @return	RCPK status code
+ *
+ *****************************************************************************/
+static uint8_t SkAppCbusProcessRcpMessage ( uint8_t rcpData )
+{
+    uint8_t rcpkStatus = MHL_MSC_MSG_RCP_NO_ERROR;
+
+    switch ( rcpData & 0x7F )
+    {
+		case MHL_RCP_CMD_MUTE:
+		case MHL_RCP_CMD_MUTE_FUNC:
+			DEBUG_PRINT( MSG_ALWAYS, "MUTE received\n", (int)rcpData );
+			break;
+		case MHL_RCP_CMD_UN_MUTE_FUNC:
+			DEBUG_PRINT( MSG_ALWAYS, "UN-MUTE received\n", (int)rcpData );
+			break;
+		case MHL_RCP_CMD_VOL_UP:
+			DEBUG_PRINT( MSG_ALWAYS, "VOL UP received\n", (int)rcpData );
+			break;
+		case MHL_RCP_CMD_VOL_DOWN:
+			DEBUG_PRINT( MSG_ALWAYS, "VOL DOWN received\n", (int)rcpData );
+			break;
+		default:
+			rcpkStatus = MHL_MSC_MSG_INEFFECTIVE_KEY_CODE;
+			break;
+	}
+
+	if ( rcpkStatus == MHL_MSC_MSG_INEFFECTIVE_KEY_CODE )
+	{
+		DEBUG_PRINT( MSG_DBG, ("KeyCode not effective!!\n" ));
+	}
+
+	return( rcpkStatus );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Process the passed RAP message.
+ *
+ *  @param[in]		rapData		rap data
+ *
+ *  @return	RAPK status code
+ *
+ *****************************************************************************/
+static uint8_t SkAppCbusProcessRapMessage ( uint8_t rapData )
+{
+    uint8_t rapkStatus = MHL_MSC_MSG_RAP_NO_ERROR;
+
+    switch ( rapData )
+    {
+	case MHL_RAP_CMD_POLL:
+		DEBUG_PRINT( MSG_DBG, "POLL received\n", (int)rapData );
+		break;
+	case MHL_RAP_CONTENT_ON:
+		DEBUG_PRINT( MSG_DBG, "Change TO CONTENT_ON STATE received\n", (int)rapData );
+    	SiiDrvRxMuteVideo(OFF);   // switch on
+    	RxAudio_ReStart();
+		break;
+	case MHL_RAP_CONTENT_OFF:
+		DEBUG_PRINT( MSG_DBG, "Change TO CONTENT_OFF STATE received\n", (int)rapData );
+    	SiiDrvRxMuteVideo(ON);   // switch off
+    	RxAudio_Stop();
+		break;
+	default:
+		rapkStatus = MHL_MSC_MSG_RAP_UNRECOGNIZED_ACT_CODE;
+        DEBUG_PRINT( MSG_DBG, ("Action Code not recognized !! \n" ));
+		break;
+    }
+
+    return( rapkStatus );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Process the passed UCP message.
+ *
+ *  @param[in]		ucpData		ucp data
+ *
+ *  @return	UCPK status code
+ *
+ *****************************************************************************/
+static uint8_t SkAppCbusProcessUcpMessage ( uint8_t ucpData )
+{
+    uint8_t ucpkStatus = MHL_MSC_MSG_UCP_NO_ERROR;
+	
+    ucpData = ucpData;
+
+    return( ucpkStatus );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		This is a notification API for Cbus connection change, prototype
+ *			is defined in si_cbus_component.h
+ *
+ *****************************************************************************/
+void SiiMhlRxConnNtfy(bool_t connected)
+{
+#if defined(__KERNEL__)
+    sysfs_notify(&devinfo->mhl->device->kobj, NULL, "connection_state");
+    send_sii5293_uevent(devinfo->mhl->device, MHL_EVENT, connected ? MHL_CONNECTED_EVENT : MHL_DISCONNECTED_EVENT, NULL);
+    SiiConnectionStateNotify(connected);
+#else
+    connected =connected;   // suppress warning
+#endif
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		This is a notification API for scratchpad bein written by peer
+ *
+ *****************************************************************************/
+void SiiMhlRxScratchpadWrittenNtfy()
+{
+	DEBUG_PRINT( MSG_DBG, "\nNotification to Application:: Scratchpad written!!\n" );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		RCP/RAP Received Notification
+ *
+ *  @param[in]		cmd			command
+ *  @param[in]		rcvdCode		received code
+ *
+ *****************************************************************************/
+void SiiMhlRxRcpRapRcvdNtfy( uint8_t cmd, uint8_t rcvdCode )
+{
+    uint8_t     status;
+#if defined(__KERNEL__)
+#define MAX_MHL_CHAR_REPORT_DATA_STRING_SIZE 20
+    extern int input_dev_rap;
+    extern int input_dev_rcp;
+    extern int input_dev_ucp;
+    char char_report_data_str[MAX_MHL_CHAR_REPORT_DATA_STRING_SIZE];
+    scnprintf(char_report_data_str,	MAX_MHL_CHAR_REPORT_DATA_STRING_SIZE, "0x%02X", rcvdCode);
+#endif
+    //DEBUG_PRINT( MSG_DBG, "\nApplication layer:: SiiMhlRxRcpRapRcvdNtfy() called !!\n" );
+    switch ( cmd )
+    {
+        case MHL_MSC_MSG_RCP:
+            DEBUG_PRINT( MSG_DBG, "RCP Key Code: 0x%02X\n", (int)rcvdCode );
+#if defined(__KERNEL__)
+            gDriverContext.rcp_in_keycode = rcvdCode;
+            sysfs_notify(&devinfo->mhl->device->kobj, "rcp", "in");
+            send_sii5293_uevent(devinfo->mhl->device, MHL_EVENT,
+				    MHL_RCP_RECEIVED_EVENT, char_report_data_str);
+// if rcp is setting for process by sysfs interface, break it. 
+            if (!input_dev_rcp)
+                break;
+#endif
+            status = SkAppCbusProcessRcpMessage( rcvdCode );
+            if ( status != MHL_MSC_MSG_RCP_NO_ERROR)
+            {
+                SiiMhlRxSendRcpe( status );
+            }
+            SiiMhlRxSendRcpk( rcvdCode );
+            break;
+
+        case MHL_MSC_MSG_RAP:
+            DEBUG_PRINT( MSG_DBG, "RAP Key Code: 0x%02X\n", (int)rcvdCode );
+#if defined(__KERNEL__)
+            gDriverContext.rap_in_keycode = rcvdCode;
+            sysfs_notify(&devinfo->mhl->device->kobj, "rap", "in");
+            send_sii5293_uevent(devinfo->mhl->device, MHL_EVENT,
+				    MHL_RAP_RECEIVED_EVENT, char_report_data_str);
+// if rap is setting for process by sysfs interface, break it. 
+            if (!input_dev_rap)
+                break;
+#endif
+            status = SkAppCbusProcessRapMessage( rcvdCode );
+            SiiMhlRxSendRapk( status );
+            break;
+        case MHL_MSC_MSG_UCP:
+            DEBUG_PRINT( MSG_DBG, "UCP Code Received is: 0x%02X\n", (int)rcvdCode );
+
+#if defined(__KERNEL__)
+            gDriverContext.ucp_in_keycode = rcvdCode;
+            sysfs_notify(&devinfo->mhl->device->kobj, "ucp", "in");
+            send_sii5293_uevent(devinfo->mhl->device, MHL_EVENT,
+				    MHL_UCP_RECEIVED_EVENT, char_report_data_str);
+// if ucp is setting for process by sysfs interface, break it. 
+            if (!input_dev_ucp)
+                break;
+#endif
+            status = SkAppCbusProcessUcpMessage( rcvdCode );
+            if ( status != MHL_MSC_MSG_UCP_NO_ERROR)
+            {
+                SiiMhlRxSendUcpe( status );
+            }
+            SiiMhlRxSendUcpk( rcvdCode );
+            break;
+
+        case MHL_MSC_MSG_RCPK:
+            DEBUG_PRINT( MSG_DBG, "RCPK Key Code: 0x%02X\n", (int)rcvdCode );
+#if defined(__KERNEL__)
+            if (gDriverContext.rcp_out_keycode == rcvdCode)
+            {
+                sysfs_notify(&devinfo->mhl->device->kobj, "rcp", "out_status");
+                send_sii5293_uevent(devinfo->mhl->device, MHL_EVENT,
+				        MHL_RCP_ACKED_EVENT, char_report_data_str);
+            }
+#endif
+            break;
+
+        case MHL_MSC_MSG_RCPE:
+            DEBUG_PRINT( MSG_DBG, "RCPE State Code: 0x%02X\n", (int)rcvdCode );
+#if defined(__KERNEL__)
+            gDriverContext.rcp_out_statecode = rcvdCode;
+            send_sii5293_uevent(devinfo->mhl->device, MHL_EVENT,
+			        MHL_RCP_ERROR_EVENT, char_report_data_str);
+#endif
+            break;
+        case MHL_MSC_MSG_RAPK:
+        	DEBUG_PRINT( MSG_DBG, "RAPK Error Code: 0x%02X\n", (int)rcvdCode );
+#if defined(__KERNEL__)
+            gDriverContext.rap_out_statecode = rcvdCode;
+            sysfs_notify(&devinfo->mhl->device->kobj, "rap", "out_status");
+            send_sii5293_uevent(devinfo->mhl->device, MHL_EVENT,
+			        MHL_RAP_ACKED_EVENT, char_report_data_str);
+#endif
+            break;
+
+        case MHL_MSC_MSG_UCPK:
+            DEBUG_PRINT( MSG_DBG, "UCPK Key Code: 0x%02X\n", (int)rcvdCode );
+#if defined(__KERNEL__)
+            if (gDriverContext.ucp_out_keycode == rcvdCode)
+            {
+                sysfs_notify(&devinfo->mhl->device->kobj, "ucp", "out_status");
+                send_sii5293_uevent(devinfo->mhl->device, MHL_EVENT,
+    			        MHL_UCP_ACKED_EVENT, char_report_data_str);
+            }
+#endif
+            break;
+        case MHL_MSC_MSG_UCPE:
+            DEBUG_PRINT( MSG_DBG, "UCPE State Code: 0x%02X\n", (int)rcvdCode );
+#if defined(__KERNEL__)
+            gDriverContext.ucp_out_statecode = rcvdCode;
+            send_sii5293_uevent(devinfo->mhl->device, MHL_EVENT,
+			        MHL_UCP_ERROR_EVENT, char_report_data_str);
+#endif
+            break;
+        default:
+        	DEBUG_PRINT( MSG_DBG, "\nApplication layer:: MSC_MSG sub-command not recognized!! Sending back MSGE code !!\n" );
+        	SiiMhlRxSendMsge(MHL_MSC_INVALID_SUBCMD);
+        	break;
+    }
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_component.c b/drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_component.c
new file mode 100755
index 000000000000..f3ccd31cb7e8
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_component.c
@@ -0,0 +1,1258 @@
+//***************************************************************************
+//!file     si_cbus_component.c
+//!brief    Silicon Image CBUS Component.
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2011-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+
+#include "si_common.h"
+#include "si_cbus_component.h"
+#include "si_drv_cbus.h"
+#include "si_drv_cra_cfg.h"
+#include "si_cra.h"
+#include "si_drv_rx.h"
+#ifdef MHAWB_SUPPORT
+#include "si_drv_hawb.h"
+#endif
+
+//------------------------------------------------------------------------------
+//  CBUS Component Instance Data
+//------------------------------------------------------------------------------
+
+#define CH_ACTIVE_INDEX     (pCbus->chState.activeIndex)
+#define CH_ACTIVE_BURST     (pCbus->chState.activeBurst)
+
+//------------------------------------------------------------------------------
+//  CBUS Component Instance Data
+//------------------------------------------------------------------------------
+
+CbusInstanceData_t cbusInstance;
+CbusInstanceData_t *pCbus = &cbusInstance;
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusRequestStatus
+// Description: Return the status of the message currently in process, if any.
+// Returns:     CBUS_REQ_IDLE, CBUS_REQ_PENDING, CBUS_REQ_SENT, or CBUS_REQ_RECEIVED
+//------------------------------------------------------------------------------
+
+uint8_t SiiCbusRequestStatus ()
+{
+    return( pCbus->chState.request[ CH_ACTIVE_INDEX ].reqStatus );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusChannelStatus
+// Description: Return the status of the current channel.
+// Parameters:  channel - CBUS channel to check
+// Returns:     CBUS_IDLE,
+//              CBUS_SENT,
+//              CBUS_XFR_DONE,
+//              CBUS_WAIT_RESPONSE,
+//              CBUS_RECEIVED
+//------------------------------------------------------------------------------
+
+uint8_t SiiCbusChannelStatus ()
+{
+    return( pCbus->chState.state );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusRequestSetIdle
+// Description: Set the active request to the specified state
+// Parameters:  newState - new CBus State
+//------------------------------------------------------------------------------
+
+void SiiCbusRequestSetIdle ( uint8_t newState )
+{
+    pCbus->chState.request[ CH_ACTIVE_INDEX ].reqStatus = newState;
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusRequestDataGet
+// Description: Return a copy of the currently active request structure
+// Parameters:  pCmdRequest
+// Returns:     none
+//------------------------------------------------------------------------------
+
+void SiiCbusRequestDataGet ( cbus_req_t *pCmdRequest )
+{
+
+    memcpy( pCmdRequest, &pCbus->chState.request[ CH_ACTIVE_INDEX ], sizeof( cbus_req_t ));
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxCbusConnected
+// Description: Return the CBUS channel connected status for this channel.
+// Returns:     true if connected.
+//              false if disconnected.
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxCbusConnected ()
+{
+    return( pCbus->chState.connected );
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusSendNextInQueue
+// Description: Starting at the current active index, send the next pending
+//              entry, if any
+//------------------------------------------------------------------------------
+
+static int_t CBusSendNextInQueue (void)
+{
+    int_t   result = SUCCESS;    
+
+    if (SiiCbusAbortStateGet())
+    {
+        return( SUCCESS );
+    }
+
+    if ( ( pCbus->chState.request[ CH_ACTIVE_INDEX].reqStatus != CBUS_REQ_PENDING ) )
+    {
+#ifdef MHAWB_SUPPORT
+        if (pCbus->chState.connected && (!pCbus->chState.burstWaitState))
+        {
+            if (pCbus->chState.remote_dcap[0x0A] & MHL_FEATURE_SP_SUPPORT)
+                SiiDrvHawbEnable(true); //There's no pending CBUS message need to send out, take HAWB ON
+        }
+#endif
+	    return( SUCCESS );
+    }
+
+#ifdef MHAWB_SUPPORT
+    if (SiiDrvHawbEnable(false))
+#endif
+    {
+        // Found a pending message, send it out
+        if ( SiiDrvInternalCBusWriteCommand( &pCbus->chState.request[ CH_ACTIVE_INDEX] ))
+        {
+            pCbus->chState.state = CBUS_SENT;
+            pCbus->chState.request[ CH_ACTIVE_INDEX].reqStatus = CBUS_REQ_SENT;
+        }
+        else
+        {
+            result = ERROR_WRITE_FAILED;
+        }
+    }
+    return( result );
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusProcessSubCommand
+// Description: Process a sub-command (RCP) or sub-command response (RCPK).
+//              Modifies channel state as necessary.
+// Returns:     SUCCESS or CBUS_SOFTWARE_ERRORS_t
+//              If SUCCESS, command data is returned in pCbus->chState.msgData[i]
+//------------------------------------------------------------------------------
+
+static uint8_t CBusProcessSubCommand (uint8_t* pData)
+{
+	uint8_t vsCmdData[2];
+
+	vsCmdData[0] = *pData++;
+	vsCmdData[1] = *pData;
+
+    // Save RCP message data in the channel receive structure to be returned
+    // to the upper level.
+    pCbus->chState.receive.arrived = true;
+    pCbus->chState.receive.command    = vsCmdData[0];
+    pCbus->chState.receive.offsetData = vsCmdData[1];
+
+    DEBUG_PRINT( MSG_DBG, "CBUS:: MSG_MSC CMD:  0x%02X  MSG_MSC Data: 0x%02X\n", (int)vsCmdData[0], (int)vsCmdData[1] );
+
+    return( SUCCESS );
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusResetToIdle
+// Description: Set the specified channel state to IDLE. Clears any messages that
+//              are in progress or queued.  Usually used if a channel connection
+//              changed or the channel heartbeat has been lost.
+//------------------------------------------------------------------------------
+
+static void CBusResetToIdle (void)
+{
+    SiiMhlRxInitialize();
+}
+
+
+bool_t SiiMhlRxIsQueueFull ( void )
+{
+    uint8_t   queueIndex;
+
+    for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
+    {
+        if ( pCbus->chState.request[ queueIndex].reqStatus == CBUS_REQ_IDLE )
+        {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool_t SiiMhlRxIsQueueEmpty ( void )
+{
+    uint8_t   queueIndex;
+
+    for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
+    {
+        if ( pCbus->chState.request[ queueIndex].reqStatus == CBUS_REQ_PENDING )
+        {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+void SiiMhlRxSetQueueEmpty( void )
+{
+    uint8_t   queueIndex;
+
+    for ( queueIndex = 0; queueIndex < CBUS_MAX_COMMAND_QUEUE; queueIndex++ )
+    {
+        pCbus->chState.request[ queueIndex].reqStatus = CBUS_REQ_IDLE;
+    }
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusWriteCommand
+// Description: Place a command in the CBUS message queue.  If queue was empty,
+//              send the new command immediately.
+//
+// Parameters:  pReq    - Pointer to a cbus_req_t structure containing the
+//                        command to write
+// Returns:     true    - successful queue/write
+//              false   - write and/or queue failed
+//------------------------------------------------------------------------------
+
+bool_t SiiCbusWriteCommand ( cbus_req_t *pReq  )
+{
+    uint8_t   queueIndex, i;
+    bool_t  success = false;
+
+    /* Copy the request to the queue.   */
+
+    if( SiiMhlRxCbusConnected() )
+    {
+        //In Abort state, discard any cbus command need to transmit. 
+        if (SiiCbusAbortStateGet() == false)
+        {
+    		//DEBUG_PRINT( MSG_DBG, "CBUS:: SiiCbusWriteCommand:: Channel State: %02X", (int)pCbus->chState[ channel].state );
+    		for ( i = 0; i < CBUS_MAX_COMMAND_QUEUE; i++ )
+    		{
+                queueIndex = (CH_ACTIVE_INDEX + i) % CBUS_MAX_COMMAND_QUEUE;
+    			if ( pCbus->chState.request[ queueIndex].reqStatus == CBUS_REQ_IDLE )
+    			{
+    				// Found an idle queue entry, copy the request and set to pending.
+
+    				memcpy( &pCbus->chState.request[ queueIndex], pReq, sizeof( cbus_req_t ));
+    				pCbus->chState.request[ queueIndex].reqStatus = CBUS_REQ_PENDING;
+                    pCbus->chState.request[ queueIndex].retry = 1;
+    				success = true;
+    				break;
+    			}
+    		}
+            if (i == CBUS_MAX_COMMAND_QUEUE)
+            {
+                DEBUG_PRINT(
+    				MSG_ERR,
+    				"CBUS:: Queue full - Request0: %02X Request1: %02X",
+    				(int)pCbus->chState.request[ 0].reqStatus,
+    				(int)pCbus->chState.request[ 1].reqStatus
+    				);
+            }
+        }
+#if 0
+		/* If successful at putting the request into the queue, decide  */
+		/* whether it can be sent now or later.                         */
+
+		if ( success )
+		{
+			switch ( pCbus->chState.state )
+			{
+				case CBUS_IDLE:
+				//case CBUS_RECEIVED:
+
+				//DEBUG_PRINT( MSG_DBG, "CBUS:: SiiCbusWriteCommand:: calling CBusSendNextInQueue!!" );
+				if (CBusSendNextInQueue() == SUCCESS )   // No command in progress, write new command immediately.
+				{
+					success = true;
+				}
+				break;
+
+				//case CBUS_WAIT_RESPONSE:
+				case CBUS_SENT:
+				case CBUS_XFR_DONE:
+
+					/* Another command is in progress, the Handler loop will    */
+					/* send the new command when the bus is free.               */
+					/*
+					DEBUG_PRINT( MSG_ERR, "CBUS:: ERROR!!! This msg should never happen, Channel State: %02X",
+							(int)pCbus->chState.state );
+					*/
+					break;
+
+				default:
+
+					/* Illegal values return to IDLE state.     */
+
+					DEBUG_PRINT( MSG_ERR, "CBUS:: Channel State: %02X (illegal)", (int)pCbus->chState.state );
+					pCbus->chState.state = CBUS_IDLE;
+					pCbus->chState.request[ queueIndex].reqStatus = CBUS_REQ_IDLE;
+					success = false;
+					break;
+			}
+		}
+#endif
+    }
+    else
+    {
+    	DEBUG_PRINT( MSG_DBG, "CBus is not connected yet! MHL command could not be sent!" );
+    }
+
+    return( success );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRAPCmd
+// Description: Send MSC_MSG (RCP) message to the specified CBUS channel (port)
+//
+// Parameters:  keyCode 	- RAP action code
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendRAPCmd ( uint8_t actCode )
+{
+    return SiiCbusSendMscMsgCmd(MHL_MSC_MSG_RAP, actCode);
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRCPCmd
+// Description: Send MSC_MSG (RCP) message to the specified CBUS channel (port)
+//
+// Parameters:  keyCode 	- RCP key code
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendRCPCmd ( uint8_t keyCode )
+{
+    return SiiCbusSendMscMsgCmd(MHL_MSC_MSG_RCP, keyCode);
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendUCPCmd
+// Description: Send MSC_MSG (UCP) message to the specified CBUS channel (port)
+//
+// Parameters:  keyCode 	- UCP key code
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendUCPCmd ( uint8_t keyCode )
+{
+    return SiiCbusSendMscMsgCmd(MHL_MSC_MSG_UCP, keyCode);
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusMscMsgSubCmdSend
+// Description: Send MSC_MSG (RCP) message to the specified CBUS channel (port)
+//
+// Parameters:  vsCommand   - MSC_MSG cmd (RCP, RCPK or RCPE)
+//              cmdData     - MSC_MSG data
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+bool_t SiiCbusSendMscMsgCmd ( uint8_t subCmd, uint8_t mscData )
+{
+    cbus_req_t req;
+
+    // Send MSC_MSG command (Vendor Specific command)
+
+    req.command = MHL_MSC_MSG;
+    req.msgData[0] = subCmd;
+    req.msgData[1] = mscData;
+    if (!(SiiCbusWriteCommand(&req)))
+    {
+        DEBUG_PRINT( MSG_ERR, "Couldn't send MHL_MSC_MSG to peer");
+        return false;
+    }
+
+    if (pCbus->chState.state == CBUS_IDLE)
+    {
+        CBusSendNextInQueue();     // No command in progress, write new command immediately.
+    }
+    return true;
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRcpk
+// Description: Send RCPK (ack) message
+//
+// Parameters:  keyCode
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxSendRcpk ( uint8_t keyCode)
+{
+
+    return( SiiCbusSendMscMsgCmd( MHL_MSC_MSG_RCPK, keyCode ));
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRcpe
+// Description: Send RCPE (error) message
+//
+// Parameters:  cmdStatus
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendRcpe ( uint8_t cmdStatus )
+    {
+    return( SiiCbusSendMscMsgCmd( MHL_MSC_MSG_RCPE, cmdStatus ));
+    }
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRapk
+// Description: Send RAPK (acknowledge) message to the specified CBUS channel
+//              and set the request status to idle.
+//
+// Parameters:  cmdStatus
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxSendRapk ( uint8_t cmdStatus )
+{
+
+    //SiiCbusRequestSetIdle( CBUS_REQ_IDLE );
+    return( SiiCbusSendMscMsgCmd( MHL_MSC_MSG_RAPK, cmdStatus ));
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendUcpk
+// Description: Send UCPK (ack) message
+//
+// Parameters:  keyCode
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxSendUcpk ( uint8_t keyCode)
+{
+    return( SiiCbusSendMscMsgCmd( MHL_MSC_MSG_UCPK, keyCode ));
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendUcpe
+// Description: Send UCPE (error) message
+//
+// Parameters:  cmdStatus
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendUcpe ( uint8_t cmdStatus )
+{
+    return( SiiCbusSendMscMsgCmd( MHL_MSC_MSG_UCPE, cmdStatus ));
+}
+
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendMsge
+// Description: Send MSGE msg back if the MSC command received is not recognized
+//
+// Returns:     true        - successful
+//              false       - failed
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxSendMsge (uint8_t opcode)
+{
+    //SiiCbusRequestSetIdle( CBUS_REQ_IDLE );
+    return( SiiCbusSendMscMsgCmd( MHL_MSC_MSG_E, opcode ));
+    }
+
+//------------------------------------------------------------------------------
+// Function:    SiMhlRxHpdSet
+// Description: Send MHL_SET_HPD to source
+// parameters:	setHpd - true/false
+//------------------------------------------------------------------------------
+bool_t SiMhlRxHpdSet (bool_t setHpd)
+    {
+	bool_t retValue = false;
+	if( setHpd )
+    {
+        if (SiiCbusSendMscCommand( MHL_SET_HPD ))
+        {
+		    retValue = SiiMhlRxPathEnable(true);
+        }
+    }
+
+	else
+    {
+        if (SiiMhlRxPathEnable(false))
+        {
+		    retValue = SiiCbusSendMscCommand( MHL_CLR_HPD );
+        }
+    }
+
+	return retValue;
+}
+
+//------------------------------------------------------------------------------
+// Function:    CBusCheckInterruptStatus
+// Description: If any interrupts on the specified channel are set, process them.
+// Returns:     SUCCESS or CBUS_SOFTWARE_ERRORS_t error code.
+//------------------------------------------------------------------------------
+static uint8_t CBusCheckInterruptStatus ( void )
+{
+    uint8_t result;
+    uint8_t busStatus;
+    uint8_t	temp;
+    uint8_t cbusData[2];
+
+    result = SUCCESS;
+
+    if ( SiiDrvCbusIntrFlagGet() )
+    {
+        //CBUS connction change
+        if ( SiiDrvCbusBusStatusGet( &busStatus ) )
+        {
+        	/* The connection change interrupt has been received.   */
+			pCbus->chState.connected = busStatus ? true : false;
+        	DEBUG_PRINT( MSG_DBG, "CBUS:: ----Connection Change---- %s \n", pCbus->chState.connected ? "Connected" : "Disconnected" );
+			if( pCbus->chState.connected )
+			{
+				SiiDrvCbusTermCtrl( true );
+                if ( SiiCbusSendDcapRdy())
+                {
+                    //set DCAP_CHG bit
+                    if(SiiMhlRxSendDcapChange())
+                    {
+                        // send set_hpd and set path_en bit too
+                        SiMhlRxHpdSet(true);
+                    }
+                }
+#if defined(__KERNEL__)
+                SiiOsTimerStart(pCbus->chState.dcapTimer, CBUS_DCAP_READY_TIMER);
+#else
+                pCbus->chState.dcapTimer = SiiTimerTotalElapsed();
+#endif
+			}
+			else
+			{
+				SiiDrvCbusTermCtrl( false );       
+				//set the cbus to idle
+				CBusResetToIdle();
+			}
+
+			SiiMhlRxConnNtfy(pCbus->chState.connected);
+        }
+
+        // Receive CBUS messages
+        if ( SiiDrvCbusVsDataGet( &cbusData[0] ) )
+        {
+            CBusProcessSubCommand( &cbusData[0] );
+        }
+
+        //Cbus message transfer done
+        if ( SiiDrvCbusCmdRetDataGet( &pCbus->chState.request[ CH_ACTIVE_INDEX ].retData[0] ) )
+        {
+            if (pCbus->chState.state == CBUS_SENT)
+                pCbus->chState.state = CBUS_XFR_DONE;
+        }
+
+        //Cbus Devcap ready
+        if (SiiDrvCbusDevCapReadyGet ())
+        {
+            if (!pCbus->chState.dcap_ready)
+            {
+                DEBUG_PRINT( MSG_DBG, "CBUS:: DCap Ready received!\n");
+#if defined(__KERNEL__)
+                SiiOsTimerStop(pCbus->chState.dcapTimer);
+#endif
+                pCbus->chState.dcap_ready = true;
+                // Read Dcap
+                SiiMhlRxReadDevCapReg(0x00);
+                pCbus->chState.dcap_ongoing = true;
+            }
+        }
+
+        if (SiiDrvCbusDevCapChangedGet ())
+        {
+            DEBUG_PRINT( MSG_DBG, "CBUS:: DCap Change received!\n");
+            if (pCbus->chState.dcap_ready)
+            {
+                // Read Dcap
+                if (!pCbus->chState.dcap_ongoing)
+                {
+                    SiiMhlRxReadDevCapReg(0x00);
+                    pCbus->chState.dcap_ongoing = true;
+                }
+            }
+        }
+
+    	// request received from peer to write into scratchpad
+    	if ( SiiDrvCbusReqWrtGet() )
+    	{
+    		DEBUG_PRINT( MSG_DBG, "Grant peer's request to write scratchpad\n");
+    		SiiCbusGrtWrt();
+	    }
+
+    	// scratchpad write notification received from peer
+    	if ( SiiDrvCbusScratchpadWrtnGet() )
+    	{
+    		// send it to app layer
+    		SiiMhlRxScratchpadWrittenNtfy();
+    	}
+
+    	// request to write into peer's scratchpad is granted
+    	if ( SiiDrvCbusGrtWrtGet() && pCbus->chState.burstWaitState )
+    	{
+    		DEBUG_PRINT( MSG_DBG, "Peer sent grant write\n");
+            SiiCbusWriteBurst();
+            //Recieve grt, stop burst timer.
+            pCbus->chState.burst [CH_ACTIVE_BURST].burstStatus = CBUS_BURST_IDLE;
+            pCbus->chState.burstWaitState = false;
+#if defined(__KERNEL__)
+            SiiOsTimerStop(pCbus->chState.burstTimer);
+#else
+            pCbus->chState.burstTimer = 0;
+#endif
+        }
+
+
+    	if ( SiiDrvCbus3DReqGet() )
+    	{
+            DEBUG_PRINT( MSG_DBG, "Peer request 3D infomation\n");
+            SiiDrvCbusBuild3DData();
+            SiiDrv3DWriteBurst();
+        }
+
+        if( SiiDrvCbusNackFromPeerGet() )
+        {
+            DEBUG_PRINT( MSG_ERR,( "NACK received from peer\n" ));
+            result |= ERROR_NACK_FROM_PEER;
+        }
+
+        if( SiiDrvCbusDdcAbortReasonGet( &temp ) )
+        {
+            DEBUG_PRINT( MSG_DBG, "CBUS DDC ABORT happened, reason: %02X\n", (int)temp );
+            if (temp & BIT_MSC_ABORT_BY_PEER)    //Abort by peer
+            {
+                result |= ERROR_CBUS_ABORT;
+            }
+            else if(temp)
+            {
+                result |= ERROR_CBUS_OTHER;
+            }
+        }
+
+
+        if ( SiiDrvCbusMscAbortReasonGet( &temp ) )
+        {
+            DEBUG_PRINT( MSG_DBG, "MSC CMD aborted, reason: %02X\n", (int)temp );
+            if (temp & BIT_MSC_ABORT_BY_PEER)    //Abort by peer
+            {
+                result |= ERROR_CBUS_ABORT;
+            }
+            if (temp & (BIT_MSC_MAX_RETRY|BIT_MSC_TIMEOUT))
+            {
+                result |= ERROR_CBUS_TIMEOUT;
+            }
+            if ((temp & ~(ERROR_CBUS_ABORT|BIT_MSC_MAX_RETRY|BIT_MSC_TIMEOUT)) != 0)
+            {
+                result |= ERROR_CBUS_ABORT_OTHER;
+            }
+        }
+
+        if ( SiiDrvCbusMscAbortResReasonGet( &temp ) )
+        {
+            DEBUG_PRINT( MSG_DBG, "MSC CMD aborted as Responder , reason: %02X\n", (int)temp );
+            if (temp & BIT_MSC_ABORT_BY_PEER)    //Abort by peer
+            {
+                result |= ERROR_CBUS_ABORT;;
+            }
+            else if(temp)
+            {
+                result |= ERROR_CBUS_OTHER;
+            }
+        }
+    }
+
+    SiiDrvCbusIntrFlagSet();
+    return( result );
+}
+
+static void CBusBurstNextInQueue (void)
+{
+    uint8_t i;
+    bool_t success = false;
+
+    //previous burst not done
+    if (pCbus->chState.burstWaitState)
+    {
+        return;
+    }
+
+    for (i = 0; i < CBUS_MAX_BURST_QUEUE; i++)
+    {
+        if (pCbus->chState.burst [i].burstStatus == CBUS_BURST_PENDING)
+        {
+            // found the pending burst, send it out.
+            success = true;
+            CH_ACTIVE_BURST = i;
+        }
+    }
+    if (success)
+    {
+    	// send REQ_WRT interrupt to peer
+    	if( !(SiiCbusReqWrt()) )
+    	{
+    		DEBUG_PRINT( MSG_ERR, "Couldn't send REQ_WRT to peer" );
+    	}
+        else
+        {
+            pCbus->chState.burstWaitState = true;
+#if defined(__KERNEL__)
+            SiiOsTimerStart(pCbus->chState.burstTimer, CBUS_BURST_WAIT_TIMER);
+#else
+            pCbus->chState.burstTimer = SiiTimerTotalElapsed();
+#endif
+        }
+    }
+}
+
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusWritePeersScratchpad
+// Description: sends MHL write burst cmd
+//------------------------------------------------------------------------------
+bool_t SiiCbusWritePeersScratchpad(uint8_t startOffset, uint8_t length, uint8_t* pMsgData)
+{
+    uint8_t i;
+    bool_t success = false;
+
+    /* Copy the request to the queue.   */
+
+    for ( i = 0; i < CBUS_MAX_BURST_QUEUE; i++ )
+    {
+        if ( pCbus->chState.burst[ i].burstStatus == CBUS_BURST_IDLE )
+        {
+            // Found an idle queue entry, copy the request and set to pending.
+            memcpy( &pCbus->chState.burst[ i].burstData, pMsgData, length);
+            pCbus->chState.burst[ i].offset = startOffset;
+            pCbus->chState.burst[ i].length = length;
+            pCbus->chState.burst[ i].burstStatus = CBUS_BURST_PENDING;
+            pCbus->chState.burst[ i].retry = 1;
+            success = true;
+            break;
+        }
+    }
+
+    /* If successful at putting the request into the queue, decide  */
+    /* whether it can be sent now or later.                         */
+
+    if ( success )
+    {
+        CBusBurstNextInQueue();
+    }else
+    {
+        DEBUG_PRINT( MSG_ERR, "CBUS:: Burst Queue full");
+    }
+    return success;
+}
+
+bool_t SiiCbusWriteBurst()
+{
+    cbus_req_t req;
+    bool_t success = false;
+
+    req.command = MHL_WRITE_BURST;
+    req.offsetData = pCbus->chState.burst [CH_ACTIVE_BURST].offset;
+    req.length = pCbus->chState.burst [CH_ACTIVE_BURST].length;
+
+    memcpy(req.msgData, pCbus->chState.burst [CH_ACTIVE_BURST].burstData, req.length);
+    if( !(SiiCbusWriteCommand(&req)) )
+    {
+    	DEBUG_PRINT( MSG_ERR, "Couldn't send Write Burst to peer" );
+    	return false;
+    }
+
+    // send DSCR_CHG interrupt to peer
+    if( !(SiiCbusSendDscrChange()) )
+    {
+    	DEBUG_PRINT( MSG_ERR, "Couldn't send DSCR_CHG to peer" );
+    	return false;
+    }
+    success = true;
+
+    return success;
+}
+
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxReadDevCapReg
+// Description: Read device capability register
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxReadDevCapReg(uint8_t regOffset)
+{
+	cbus_req_t 	req;
+	bool_t		success;
+
+    req.command = MHL_READ_DEVCAP;
+	req.offsetData = regOffset;
+
+	if( !(success = SiiCbusWriteCommand(&req)) )
+	{
+		DEBUG_PRINT( MSG_ERR, "Couldn't send MHL_READ_DEVCAP to peer" );
+	}
+
+	return success;
+}
+
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusSendMscCommand
+// Description: sends general MHL commands
+//------------------------------------------------------------------------------
+bool_t SiiCbusSendMscCommand(uint8_t cmd)
+{
+    cbus_req_t req;
+    bool_t success = true;
+
+    req.command = cmd;
+
+    switch (cmd)
+    {
+        case MHL_GET_STATE:
+        case MHL_GET_VENDOR_ID:
+        case MHL_SET_HPD:
+        case MHL_CLR_HPD:
+        case MHL_GET_SC1_ERRORCODE:
+        case MHL_GET_DDC_ERRORCODE:
+        case MHL_GET_MSC_ERRORCODE:
+        case MHL_GET_SC3_ERRORCODE:
+
+            if (!(success = SiiCbusWriteCommand(&req)))
+            {
+                DEBUG_PRINT( MSG_ERR, "Couldn't send cmd: %02X to peer", (int)cmd );
+                return false;
+            }
+
+            break;
+
+        default:
+            DEBUG_PRINT( MSG_ERR, "Invalid command %02X send request!!", (int)cmd );
+            success = false;
+    }
+    return success;
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusSetInt
+// Description: write peer's status registers
+//				regOffset - peer's register offset
+//				regBit - bit to be set
+//------------------------------------------------------------------------------
+bool_t SiiCbusSetInt ( uint8_t regOffset, uint8_t regBit )
+{
+	cbus_req_t req;
+
+	req.command = MHL_SET_INT;
+	req.offsetData = regOffset;
+	req.msgData[0] = regBit;
+
+	if( !(SiiCbusWriteCommand(&req)) )
+	{
+		DEBUG_PRINT( MSG_ERR, "Couldn't send MHL_SET_INT to peer" );
+		return false;
+	}
+	return true;
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiMhlRxSendEdidChange
+// Description: set edid_chg interrupt
+//------------------------------------------------------------------------------
+bool_t SiMhlRxSendEdidChange ()
+{
+	return ( SiiCbusSetInt(0x01, BIT1) );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendDcapChange
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendDcapChange  ()
+{
+	return ( SiiCbusSetInt(0x00, BIT0) );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiDscrChange
+//------------------------------------------------------------------------------
+bool_t SiiCbusSendDscrChange ()
+{
+	return ( SiiCbusSetInt(0x00, BIT1) );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiReqWrt
+//------------------------------------------------------------------------------
+bool_t SiiCbusReqWrt ()
+{
+	return ( SiiCbusSetInt(0x00, BIT2) );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiGrtWrt
+// Description:
+//------------------------------------------------------------------------------
+bool_t SiiCbusGrtWrt ()
+{
+	return ( SiiCbusSetInt(0x00, BIT3) );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusWriteStatus
+// Description: write peer's status registers
+// Parameters:  regOffset - peer's register offset
+//				value - value to be written
+//------------------------------------------------------------------------------
+bool_t SiiCbusWriteStatus ( uint8_t regOffset, uint8_t value )
+{
+    cbus_req_t req;
+
+    req.command = MHL_WRITE_STAT;
+    req.offsetData = regOffset;
+    req.msgData[0] = value;
+
+    if (!(SiiCbusWriteCommand(&req)))
+    {
+        DEBUG_PRINT( MSG_ERR, "Couldn't send MHL_WRITE_STAT to peer" );
+        return false;
+    }
+
+    return true;
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxPathEnable
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxPathEnable  (bool_t enable)
+{
+    if ( enable )
+    {
+        // enable PATH_EN bit on peer's appropriate status register (offset 0x31)
+        DEBUG_PRINT( MSG_STAT, "SiiMhlRxPathEnable:: Enable\n" );
+        return ( SiiCbusWriteStatus(0x01, BIT3) );
+    }
+    else
+    {
+        // disable PATH_EN bit on peer's appropriate status register (offset 0x31)
+        DEBUG_PRINT( MSG_STAT, "SiiMhlRxPathEnable:: Disable\n" );
+        return ( SiiCbusWriteStatus(0x01, 0) );
+    }
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiSendDcapRdy
+//------------------------------------------------------------------------------
+bool_t SiiCbusSendDcapRdy ()
+{
+	return ( SiiCbusWriteStatus(0x00, BIT0) );
+
+}
+
+
+#if defined(__KERNEL__)
+static void CbusAbort_Timer_Callback(void *pArg)
+{
+    DEBUG_PRINT(MSG_STAT, ("CBUS Abort timer expired.\n"));
+    SiiCbusAbortStateSet(false);
+
+    if (pCbus->chState.state == CBUS_IDLE)
+    {
+        CBusSendNextInQueue();     // No command in progress, write new command immediately.
+    }
+}
+
+static void CbusBurst_Timer_Callback(void *pArg)
+{
+    DEBUG_PRINT(MSG_STAT, ("CBUS Burst timer expired.\n"));
+    pCbus->chState.burstWaitState = false;
+    if (pCbus->chState.burst [CH_ACTIVE_BURST].retry)
+    {
+        pCbus->chState.burst [CH_ACTIVE_BURST].burstStatus = CBUS_BURST_PENDING;
+        pCbus->chState.burst [CH_ACTIVE_BURST].retry--;
+    }
+    else
+    {
+        pCbus->chState.burst [CH_ACTIVE_BURST].burstStatus = CBUS_BURST_IDLE;
+    }
+    CBusBurstNextInQueue();
+
+    if (pCbus->chState.state == CBUS_IDLE)
+    {
+        CBusSendNextInQueue();     // No command in progress, write new command immediately.
+    }
+}
+
+static void CbusDcap_Timer_Callback(void *pArg)
+{
+    if (pCbus->chState.connected && (!pCbus->chState.dcap_ready))
+    {
+        DEBUG_PRINT(MSG_ERR, ("CBUS Dcap ready timer expired.\n"));
+        pCbus->chState.dcap_ready = true;
+        // Read Dcap
+        SiiMhlRxReadDevCapReg(0x00);
+        pCbus->chState.dcap_ongoing = true;
+        if (pCbus->chState.state == CBUS_IDLE)
+        {
+            CBusSendNextInQueue();     // No command in progress, write new command immediately.
+        }
+    }
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusAbortTimerStart
+//------------------------------------------------------------------------------
+void SiiCbusAbortTimerStart (void)
+{
+#ifdef MHAWB_SUPPORT
+    SiiDrvHawbEnable(false);    //Disable HAWB when receive abort.
+#endif
+    SiiOsTimerStart(pCbus->chState.abortTimer, CBUS_ABORT_TIMER);
+    SiiCbusAbortStateSet(true);
+}
+#else
+
+/*****************************************************************************/
+/**
+ * @brief Check the cbus timers, if cbus need to be wait until timeout. 
+ *
+ * @note: 
+ *
+ *****************************************************************************/
+void SiiCbuschkTimers (void)
+{
+    if ( pCbus->chState.abortState && (SiiTimerTotalElapsed() - pCbus->chState.abortTimer >  CBUS_ABORT_TIMER) )
+    {
+        DEBUG_PRINT(MSG_ALWAYS, ("CBUS Abort timer expired.\n"));
+        pCbus->chState.abortState = false;
+    }
+    if ( pCbus->chState.burstWaitState && (SiiTimerTotalElapsed() - pCbus->chState.burstTimer >  CBUS_BURST_WAIT_TIMER) )
+    {
+        DEBUG_PRINT(MSG_ALWAYS, ("CBUS Burst timer expired.\n"));
+        pCbus->chState.burstWaitState = false;
+        if (pCbus->chState.burst [CH_ACTIVE_BURST].retry)
+        {
+            pCbus->chState.burst [CH_ACTIVE_BURST].burstStatus = CBUS_BURST_PENDING;
+            pCbus->chState.burst [CH_ACTIVE_BURST].retry--;
+        }
+        else
+        {
+            pCbus->chState.burst [CH_ACTIVE_BURST].burstStatus = CBUS_BURST_IDLE;
+        }
+    }
+    if (pCbus->chState.connected && (!pCbus->chState.dcap_ready) && (SiiTimerTotalElapsed() - pCbus->chState.dcapTimer >  CBUS_DCAP_READY_TIMER))
+    {        
+        DEBUG_PRINT(MSG_ERR, ("CBUS Dcap ready timer expired.\n"));
+        pCbus->chState.dcap_ready = true;
+        // Read Dcap
+        SiiMhlRxReadDevCapReg(0x00);
+        pCbus->chState.dcap_ongoing = true;
+    }
+    CBusBurstNextInQueue();
+
+    if (pCbus->chState.state == CBUS_IDLE)
+    {
+        CBusSendNextInQueue();     // No command in progress, write new command immediately.
+    }
+
+}
+#endif
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxIntrHandler
+// Description: Check the state of any current CBUS message on specified channel.
+//              Handle responses or failures and send any pending message if
+//              channel is IDLE.
+// Parameters:  channel - CBUS channel to check, must be in range, NOT 0xFF
+// Returns:     SUCCESS or one of CBUS_SOFTWARE_ERRORS_t
+//------------------------------------------------------------------------------
+
+uint8_t SiiMhlRxIntrHandler ()
+{
+    uint8_t result = SUCCESS;
+    bool_t retrycheck = false;
+    /* Check the channel interrupt status to see if anybody is  */
+    /* talking to us. If they are, talk back.                   */
+    result = CBusCheckInterruptStatus();
+
+    /* Don't bother with the rest if the heart is gone. */
+    if ( result != SUCCESS )
+    {
+        if (result & ERROR_CBUS_ABORT)
+        {
+            //Set abort timer
+#if defined(__KERNEL__)
+            SiiCbusAbortTimerStart();
+#else
+            pCbus->chState.abortTimer = SiiTimerTotalElapsed();
+#endif
+            SiiCbusAbortStateSet(true);
+            pCbus->chState.state = CBUS_IDLE;
+            SiiMhlRxSetQueueEmpty();
+        }
+        else if (result & ERROR_CBUS_ABORT_OTHER)
+        {
+            //send MSC error cannot retry
+            if (pCbus->chState.state == CBUS_SENT)
+            {
+                pCbus->chState.state = CBUS_IDLE;
+                pCbus->chState.request[ CH_ACTIVE_INDEX ].reqStatus = CBUS_REQ_IDLE;
+            }
+        }
+        else if (result & (ERROR_CBUS_TIMEOUT | ERROR_NACK_FROM_PEER))
+        {
+            //send MSC error, retry if possible
+            if (pCbus->chState.state == CBUS_SENT)
+            {
+                retrycheck = true;
+            }
+        }
+    }
+
+    // If there's some in the burst queue, send it out
+    CBusBurstNextInQueue();
+
+    // Check if there's any cbus message arrived
+    if (pCbus->chState.receive.arrived)
+    {
+        SiiMhlRxRcpRapRcvdNtfy(pCbus->chState.receive.command, pCbus->chState.receive.offsetData);
+        pCbus->chState.receive.arrived = false;
+    }
+
+    /* Update the channel state machine as necessary.   */
+    if ( pCbus->chState.state == CBUS_XFR_DONE )
+    {
+        pCbus->chState.state = CBUS_IDLE;
+
+        /* We may be waiting for a response message, but the    */
+        /* request queue is idle.                               */
+        if ( pCbus->chState.request[ CH_ACTIVE_INDEX ].command == MHL_READ_DEVCAP )
+        {
+            DEBUG_PRINT( MSG_DBG, "Response data Received, %02X\n", pCbus->chState.request[ CH_ACTIVE_INDEX ].retData[0] );
+            if (pCbus->chState.request[ CH_ACTIVE_INDEX ].offsetData < 15)
+                SiiMhlRxReadDevCapReg(pCbus->chState.request[ CH_ACTIVE_INDEX ].offsetData+1);
+            else
+                pCbus->chState.dcap_ongoing = false;
+            pCbus->chState.remote_dcap[pCbus->chState.request[ CH_ACTIVE_INDEX ].offsetData] = pCbus->chState.request[ CH_ACTIVE_INDEX ].retData[0];
+        }
+        if ( (pCbus->chState.request[ CH_ACTIVE_INDEX ].command == MHL_MSC_MSG )
+            && ((pCbus->chState.request[ CH_ACTIVE_INDEX ].msgData[0] == MHL_MSC_MSG_RCPE) ||
+            (pCbus->chState.request[ CH_ACTIVE_INDEX ].msgData[0] == MHL_MSC_MSG_UCPE)))
+        {
+            //Add a little delay after sending RCPE/UCPE
+            HalTimerWait(20);
+        }
+        pCbus->chState.request[ CH_ACTIVE_INDEX ].reqStatus = CBUS_REQ_IDLE;
+        CH_ACTIVE_INDEX = (CH_ACTIVE_INDEX + 1)% CBUS_MAX_COMMAND_QUEUE;
+    }
+#if 0
+    if (pCbus->chState.state == CBUS_SENT)
+    {
+        //From spec need Wait for TCMD_RECEIVER_TIMEOUT, at least 320ms
+        if (pCbus->chState.request[ CH_ACTIVE_INDEX ].reqStatus == CBUS_REQ_SENT)
+        {
+            if (SiiTimerTotalElapsed() - pCbus->chState.request[ CH_ACTIVE_INDEX ].reqTimer > CBUS_CMD_TIMEOUT)
+            {
+                //should never be here, when this timeout occured, there should be abort interrupt firstly.
+                retrycheck = true;
+            }
+        }
+        else
+        {
+            //should never be here
+            pCbus->chState.state = CBUS_IDLE;
+            result = ERROR_INVALID;
+            return result;
+        }
+    }
+#endif
+
+    if (retrycheck)
+    {
+        pCbus->chState.state = CBUS_IDLE;
+        if (pCbus->chState.request[ CH_ACTIVE_INDEX ].retry)
+        {
+            pCbus->chState.request[ CH_ACTIVE_INDEX ].reqStatus = CBUS_REQ_PENDING;
+            pCbus->chState.request[ CH_ACTIVE_INDEX ].retry--;
+        }
+        else
+        {
+            // retry failed, skip the current index, and move on. 
+            pCbus->chState.request[ CH_ACTIVE_INDEX ].reqStatus = CBUS_REQ_IDLE;
+            CH_ACTIVE_INDEX = (CH_ACTIVE_INDEX + 1)% CBUS_MAX_COMMAND_QUEUE;
+        }
+    }
+
+    if (pCbus->chState.state == CBUS_IDLE)
+    {
+        result = CBusSendNextInQueue();     // No command in progress, write new command immediately.
+    }
+
+    return( result );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxInitialize
+// Description: Attempts to initialize the CBUS. If register reads return 0xFF,
+//              it declares error in initialization.
+//              Initializes discovery enabling registers and anything needed in
+//              config register, interrupt masks.
+// Returns:     TRUE if no problem
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxInitialize ( void )
+{
+    memset( pCbus, 0, sizeof( CbusInstanceData_t ));
+#if defined(__KERNEL__)
+    SiiOsTimerCreate("Abt Timer", CbusAbort_Timer_Callback, NULL, &pCbus->chState.abortTimer);
+    SiiOsTimerCreate("Bst Timer", CbusBurst_Timer_Callback, NULL, &pCbus->chState.burstTimer);
+    SiiOsTimerCreate("Dcap Timer", CbusDcap_Timer_Callback, NULL, &pCbus->chState.dcapTimer);
+#endif
+    return( SiiDrvCbusInitialize() );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusAbortStateSet
+//------------------------------------------------------------------------------
+void SiiCbusAbortStateSet (bool_t value)
+{
+    pCbus->chState.abortState = value;
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusAbortStateGet
+//------------------------------------------------------------------------------
+bool_t SiiCbusAbortStateGet (void)
+{
+    return pCbus->chState.abortState;
+}
+
+
+uint8_t SiiCbusRemoteDcapGet(uint8_t offset)
+{
+    if (offset <= 0x10)
+        return pCbus->chState.remote_dcap[offset];
+    else return 0x00;
+}
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_component.h b/drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_component.h
new file mode 100755
index 000000000000..24aad226ebdb
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_component.h
@@ -0,0 +1,358 @@
+//***************************************************************************
+//!file     si_cbus_component.h
+//!brief    Silicon Image CBUS Component.
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2002-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+#ifndef __SI_CBUS_COMPONENT_H__
+#define __SI_CBUS_COMPONENT_H__
+
+#include "si_common.h"
+#include "si_cbus_enums.h"
+
+//------------------------------------------------------------------------------
+//  Manifest Constants
+//------------------------------------------------------------------------------
+
+#define     MHL_DEVCAP_SIZE                 16
+#define     MHL_INTERRUPT_SIZE              4
+#define     MHL_STATUS_SIZE                 4
+#define     MHL_SCRATCHPAD_SIZE             16
+#define     MHL_MAX_BUFFER_SIZE             MHL_SCRATCHPAD_SIZE // manually define highest number
+
+#define CBUS_MAX_COMMAND_QUEUE      6
+#define CBUS_MAX_BURST_QUEUE        6
+
+#define CBUS_BURST_WAIT_TIMER       1200        //This timer will be useless after enable HAWB
+#define CBUS_ABORT_TIMER			2000
+#define CBUS_DCAP_READY_TIMER       1000
+//------------------------------------------------------------------------------
+//  CBUS Component typedefs
+//------------------------------------------------------------------------------
+
+//
+// structure to hold command details from upper layer to CBUS module
+//
+typedef struct
+{
+    uint8_t retry;        		            // retry times
+    uint8_t reqStatus;                      // CBUS_IDLE, CBUS_PENDING
+    uint8_t command;                        // VS_CMD or RCP opcode
+    uint8_t offsetData;                     // Offset of register on CBUS or RCP data
+    uint8_t length;                         // Only applicable to write burst. ignored otherwise.
+    uint8_t msgData[MHL_MAX_BUFFER_SIZE];   // Pointer to message data area.
+    uint8_t retData[2];                     // Pointer to read back message data area.
+	uint8_t	*pdatabytes;					// pointer for write burst or read many bytes
+} cbus_req_t;
+
+typedef struct
+{
+    bool_t arrived;                         // CBUS message is arrived
+    uint8_t command;                        // VS_CMD or RCP opcode
+    uint8_t offsetData;                     // Offset of register on CBUS or RCP data
+} cbus_rev_t;
+
+typedef struct
+{
+    uint8_t retry;        		            // retry times
+    uint8_t burstStatus;
+    uint8_t offset;
+    uint8_t length;
+    uint8_t burstData[MHL_MAX_BUFFER_SIZE];
+} cbus_burst_t;
+
+typedef struct
+{
+    bool_t connected;      		// True if a connected MHL port
+    bool_t dcap_ready;          // device capability ready
+    bool_t dcap_ongoing;        // True if read dcap is on going
+    uint8_t remote_dcap[MHL_DEVCAP_SIZE];      // cached remote dcap registers
+    uint8_t state;          		// State of command execution for this channel
+    uint8_t activeIndex;    		// Active queue entry for req.
+    uint8_t activeBurst;
+#if defined(__KERNEL__)
+    SiiOsTimer_t abortTimer;
+    SiiOsTimer_t burstTimer;
+    SiiOsTimer_t dcapTimer;
+#else
+	clock_time_t	abortTimer;
+	clock_time_t	burstTimer;
+	clock_time_t	dcapTimer;
+#endif
+    bool_t abortState;
+    bool_t burstWaitState;
+    cbus_burst_t    burst[ CBUS_MAX_BURST_QUEUE ];
+    cbus_req_t      request[ CBUS_MAX_COMMAND_QUEUE ];
+    cbus_rev_t      receive;
+} cbusChannelState_t;
+
+
+
+typedef struct
+{
+    cbusChannelState_t  chState;
+} CbusInstanceData_t;
+
+
+//------------------------------------------------------------------------------
+//  Standard component functions
+//-------------------------------------------------------------
+bool_t      SiiMhlRxInitialize( void );
+
+//------------------------------------------------------------------------------
+//  Component Specific functions
+//------------------------------------------------------------------------------
+
+uint8_t     SiiMhlRxIntrHandler( void );
+
+uint8_t     SiiCbusRequestStatus( void );
+void        SiiCbusRequestSetIdle( uint8_t newState );
+
+bool_t      SiiMhlRxIsQueueFull ( void );
+bool_t      SiiMhlRxIsQueueEmpty ( void );
+
+uint8_t     SiiCbusChannelStatus(void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxCbusConnected
+// Description: Return the CBUS channel connected status for this channel.
+// Returns:     true if connected.
+//              false if disconnected.
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxCbusConnected(void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusRequestDataGet
+// Description: Return a copy of the currently active request structure
+// Parameters:  pCmdRequest
+// Returns:     none
+//------------------------------------------------------------------------------
+
+void        SiiCbusRequestDataGet( cbus_req_t *pCmdRequest );
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRAPCmd
+// Description: Send MSC_MSG (RCP) message to the specified CBUS channel (port)
+//
+// Parameters:  keyCode 	- RAP action code
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendRAPCmd ( uint8_t actCode );
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRCPCmd
+// Description: Send MSC_MSG (RCP) message to the specified CBUS channel (port)
+//
+// Parameters:  keyCode 	- RCP key code
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendRCPCmd ( uint8_t keyCode );
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendUCPCmd
+// Description: Send MSC_MSG (UCP) message to the specified CBUS channel (port)
+//
+// Parameters:  keyCode 	- UCP key code
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendUCPCmd ( uint8_t keyCode );
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusMscMsgSubCmdSend
+// Description: Send MSC_MSG (RCP) message to the specified CBUS channel (port)
+//
+// Parameters:  vsCommand   - MSC_MSG cmd (RCP, RCPK or RCPE)
+//              cmdData     - MSC_MSG data
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+bool_t SiiCbusSendMscMsgCmd ( uint8_t subCmd, uint8_t mscData );
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRcpk
+// Description: Send RCPK (ack) message
+//
+// Parameters:  keyCode
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxSendRcpk ( uint8_t keyCode);
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRcpe
+// Description: Send RCPE (error) message
+//
+// Parameters:  cmdStatus
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendRcpe ( uint8_t cmdStatus );
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendRapk
+// Description: Send RAPK (acknowledge) message to the specified CBUS channel
+//              and set the request status to idle.
+//
+// Parameters:  cmdStatus
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxSendRapk ( uint8_t cmdStatus );
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendUcpk
+// Description: Send UCPK (acknowledge) message to the specified CBUS channel
+//              and set the request status to idle.
+//
+// Parameters:  cmdStatus
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxSendUcpk ( uint8_t cmdStatus );
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendUcpe
+// Description: Send UCPE (error) message
+//
+// Parameters:  cmdStatus
+// Returns:     true        - successful queue/write
+//              false       - write and/or queue failed
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendUcpe ( uint8_t cmdStatus );
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendMsge
+// Description: Send MSGE msg back if the MSC command received is not recognized
+//
+// Returns:     true        - successful
+//              false       - failed
+//------------------------------------------------------------------------------
+
+bool_t SiiMhlRxSendMsge (uint8_t opcode);
+bool_t SiiCbusWriteCommand( cbus_req_t *pReq );
+bool_t SiiCbusWriteStatus ( uint8_t regOffset, uint8_t value );
+bool_t SiiCbusSetInt ( uint8_t regOffset, uint8_t regBit );
+bool_t SiiCbusWriteBurst(void);
+
+//------------------------------------------------------------------------------
+// Function:    SiMhlRxSendEdidChange
+//------------------------------------------------------------------------------
+bool_t SiMhlRxSendEdidChange (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiGrtWrt
+//------------------------------------------------------------------------------
+bool_t SiiCbusGrtWrt (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiReqWrt
+//------------------------------------------------------------------------------
+bool_t SiiCbusReqWrt (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxSendDcapChange
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxSendDcapChange (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDscrChange
+//------------------------------------------------------------------------------
+bool_t SiiCbusSendDscrChange (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiSendDcapRdy
+//------------------------------------------------------------------------------
+bool_t SiiCbusSendDcapRdy (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxPathEnable
+// Description: Check if the channel is an active channel
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxPathEnable  (bool_t enable);
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusSendMscCommand
+// Description: sends general MSC commands
+//------------------------------------------------------------------------------
+bool_t SiiCbusSendMscCommand(uint8_t cmd);
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxWrtPeersScratchpad
+// Description: sends MHL write burst cmd
+//------------------------------------------------------------------------------
+bool_t SiiCbusWritePeersScratchpad(uint8_t startOffset, uint8_t length, uint8_t* pMsgData);
+
+//------------------------------------------------------------------------------
+// Function:    SiiReadDevCapReg
+// Description: Read device capability register
+//------------------------------------------------------------------------------
+bool_t SiiMhlRxReadDevCapReg(uint8_t regOffset);
+
+//------------------------------------------------------------------------------
+// Function:    SiMhlRxHpdSet
+// Description: Send MHL_SET_HPD to source
+// parameters:	setHpd - true/false
+//------------------------------------------------------------------------------
+bool_t SiMhlRxHpdSet (bool_t setHpd);
+
+//------------------------------------------------------------------------------
+// Function:    SiMhlRxMscCmdRetDataNtfy
+// Description: Response data received from peer in response to an MSC command
+//------------------------------------------------------------------------------
+void SiMhlRxMscCmdRetDataNtfy (uint8_t mscData);
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxConnNtfy
+// Description: This is a notification API for Cbus connection change, prototype
+//				is defined in si_cbus_component.h
+//------------------------------------------------------------------------------
+void SiiMhlRxConnNtfy(bool_t connected);
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxScratchpadWrittenNtfy
+// Description: This is a notification API for scratchpad bein written by peer
+//------------------------------------------------------------------------------
+void SiiMhlRxScratchpadWrittenNtfy(void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiMhlRxRcpRapRcvdNtfy
+// Description: process RCP/RAP msg
+//------------------------------------------------------------------------------
+void SiiMhlRxRcpRapRcvdNtfy( uint8_t cmd, uint8_t rcvdCode);
+
+#if !defined(__KERNEL__)
+void SiiCbuschkTimers (void);
+#else
+//------------------------------------------------------------------------------
+// Function:    SiiCbusAbortTimerStart
+//------------------------------------------------------------------------------
+void SiiCbusAbortTimerStart (void);
+#endif
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusAbortStateSet
+//------------------------------------------------------------------------------
+void SiiCbusAbortStateSet (bool_t value);
+
+//------------------------------------------------------------------------------
+// Function:    SiiCbusAbortStateGet
+//------------------------------------------------------------------------------
+bool_t SiiCbusAbortStateGet (void);
+
+uint8_t SiiCbusRemoteDcapGet(uint8_t offset);
+
+#endif // __SI_CBUS_COMPONENT_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_enums.h b/drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_enums.h
new file mode 100755
index 000000000000..fce714215d11
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/cbus/si_cbus_enums.h
@@ -0,0 +1,215 @@
+//***************************************************************************
+//@file     si_cbus_enums.h
+//@brief    CBUS API Enums
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2010-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+#ifndef SI_CBUS_ENUMS_H_
+#define SI_CBUS_ENUMS_H_
+
+enum
+{
+	MHL_MSC_NO_ERROR			= 0x00, 	// no error
+	MHL_MSC_INVALID_SUBCMD		= 0X01,		// invalid sub command
+};
+
+enum
+{
+	MHL_MSC_MSG_E				= 0x02,
+    MHL_MSC_MSG_RCP             = 0x10,     // RCP sub-command
+    MHL_MSC_MSG_RCPK            = 0x11,     // RCP Acknowledge sub-command
+    MHL_MSC_MSG_RCPE            = 0x12,     // RCP Error sub-command
+    MHL_MSC_MSG_RAP             = 0x20,     // Mode Change Warning sub-command
+    MHL_MSC_MSG_RAPK            = 0x21,     // MCW Acknowledge sub-command
+    MHL_MSC_MSG_UCP             = 0x30,
+    MHL_MSC_MSG_UCPK            = 0x31,
+    MHL_MSC_MSG_UCPE            = 0x32,
+};
+
+// RCPK/RCPE sub commands
+enum
+{
+    MHL_MSC_MSG_RCP_NO_ERROR        	= 0x00,     // RCP No Error
+    MHL_MSC_MSG_INEFFECTIVE_KEY_CODE  	= 0x01,     // The key code in the RCP sub-command is not recognized
+    MHL_MSC_MSG_RESPONDER_BUSY          = 0x02,     // RCP Response busy
+};
+
+//RAPK sub commands
+enum
+{
+    MHL_MSC_MSG_RAP_NO_ERROR        		= 0x00,     // RAP No Error
+    MHL_MSC_MSG_RAP_UNRECOGNIZED_ACT_CODE  	= 0x01,
+    MHL_MSC_MSG_RAP_UNSUPPORTED_ACT_CODE  	= 0x02,
+    MHL_MSC_MSG_RAP_RESPONDER_BUSY   		= 0x03,
+};
+
+// UCPE sub commands
+enum
+{
+    MHL_MSC_MSG_UCP_NO_ERROR        	= 0x00,     // UCP No Error
+    MHL_MSC_MSG_UCP_INEFFECTIVE_KEY_CODE  	= 0x01,     // The key code in the UCP sub-command is not recognized
+};
+
+enum
+{
+    MHL_RCP_CMD_SELECT          = 0x00,
+	MHL_RCP_CMD_UP              = 0x01,
+    MHL_RCP_CMD_DOWN            = 0x02,
+	MHL_RCP_CMD_LEFT            = 0x03,
+    MHL_RCP_CMD_RIGHT           = 0x04,
+    MHL_RCP_CMD_RIGHT_UP        = 0x05,
+    MHL_RCP_CMD_RIGHT_DOWN      = 0x06,
+    MHL_RCP_CMD_LEFT_UP         = 0x07,
+    MHL_RCP_CMD_LEFT_DOWN       = 0x08,
+    MHL_RCP_CMD_ROOT_MENU       = 0x09,
+    MHL_RCP_CMD_SETUP_MENU      = 0x0A,
+    MHL_RCP_CMD_CONTENTS_MENU   = 0x0B,
+    MHL_RCP_CMD_FAVORITE_MENU   = 0x0C,
+    MHL_RCP_CMD_EXIT            = 0x0D,
+
+	//0x0E - 0x1F are reserved
+
+	MHL_RCP_CMD_NUM_0           = 0x20,
+    MHL_RCP_CMD_NUM_1           = 0x21,
+    MHL_RCP_CMD_NUM_2           = 0x22,
+    MHL_RCP_CMD_NUM_3           = 0x23,
+    MHL_RCP_CMD_NUM_4           = 0x24,
+    MHL_RCP_CMD_NUM_5           = 0x25,
+    MHL_RCP_CMD_NUM_6           = 0x26,
+    MHL_RCP_CMD_NUM_7           = 0x27,
+    MHL_RCP_CMD_NUM_8           = 0x28,
+    MHL_RCP_CMD_NUM_9           = 0x29,
+
+	MHL_RCP_CMD_DOT             = 0x2A,
+	MHL_RCP_CMD_ENTER           = 0x2B,
+	MHL_RCP_CMD_CLEAR           = 0x2C,
+
+	//0x2D - 0x2F are reserved
+
+    MHL_RCP_CMD_CH_UP           = 0x30,
+    MHL_RCP_CMD_CH_DOWN         = 0x31,
+    MHL_RCP_CMD_PRE_CH          = 0x32,
+    MHL_RCP_CMD_SOUND_SELECT    = 0x33,
+    MHL_RCP_CMD_INPUT_SELECT    = 0x34,
+    MHL_RCP_CMD_SHOW_INFO       = 0x35,
+    MHL_RCP_CMD_HELP            = 0x36,
+    MHL_RCP_CMD_PAGE_UP         = 0x37,
+    MHL_RCP_CMD_PAGE_DOWN       = 0x38,
+
+	//0x39 - 0x40 are reserved
+
+    MHL_RCP_CMD_VOL_UP	        = 0x41,
+    MHL_RCP_CMD_VOL_DOWN        = 0x42,
+    MHL_RCP_CMD_MUTE            = 0x43,
+    MHL_RCP_CMD_PLAY            = 0x44,
+    MHL_RCP_CMD_STOP            = 0x45,
+    MHL_RCP_CMD_PAUSE           = 0x46,
+    MHL_RCP_CMD_RECORD          = 0x47,
+    MHL_RCP_CMD_REWIND          = 0x48,
+    MHL_RCP_CMD_FAST_FWD        = 0x49,
+    MHL_RCP_CMD_EJECT           = 0x4A,
+    MHL_RCP_CMD_FWD             = 0x4B,
+    MHL_RCP_CMD_BKWD            = 0x4C,
+
+	//0x4D - 0x4F are reserved
+
+    MHL_RCP_CMD_ANGLE            = 0x50,
+    MHL_RCP_CMD_SUBPICTURE       = 0x51,
+
+	//0x52 - 0x5F are reserved
+
+    MHL_RCP_CMD_PLAY_FUNC       = 0x60,
+    MHL_RCP_CMD_PAUSE_PLAY_FUNC = 0x61,
+    MHL_RCP_CMD_RECORD_FUNC     = 0x62,
+    MHL_RCP_CMD_PAUSE_REC_FUNC  = 0x63,
+    MHL_RCP_CMD_STOP_FUNC       = 0x64,
+	MHL_RCP_CMD_MUTE_FUNC       = 0x65,
+    MHL_RCP_CMD_UN_MUTE_FUNC    = 0x66,
+    MHL_RCP_CMD_TUNE_FUNC       = 0x67,
+    MHL_RCP_CMD_MEDIA_FUNC      = 0x68,
+
+	//0x69 - 0x70 are reserved
+
+    MHL_RCP_CMD_F1              = 0x71,
+    MHL_RCP_CMD_F2              = 0x72,
+    MHL_RCP_CMD_F3              = 0x73,
+    MHL_RCP_CMD_F4              = 0x74,
+    MHL_RCP_CMD_F5              = 0x75,
+
+	//0x76 - 0x7D are reserved
+
+    MHL_RCP_CMD_VS              = 0x7E,
+    MHL_RCP_CMD_RSVD            = 0x7F,
+
+};
+
+enum
+{
+    MHL_RAP_CMD_POLL         	= 0x00,
+    MHL_RAP_CONTENT_ON		    = 0x10,
+    MHL_RAP_CONTENT_OFF			= 0x11,
+    MHL_RAP_CMD_END             = 0x12
+};
+
+enum
+{
+    MHL_ACK                     = 0x33,         // Command or Data byte acknowledge
+    MHL_NACK                    = 0x34,         // Command or Data byte not acknowledge
+    MHL_ABORT                   = 0x35,         // Transaction abort
+    MHL_WRITE_STAT              = 0x60 | 0x80,  // Write one status register strip top bit
+    MHL_SET_INT                 = 0x60,         // Write one interrupt register
+    MHL_READ_DEVCAP             = 0x61,         // Read one register
+    MHL_GET_STATE               = 0x62,         // Read CBUS revision level from follower
+    MHL_GET_VENDOR_ID           = 0x63,         // Read vendor ID value from follower.
+    MHL_SET_HPD                 = 0x64,         // Set Hot Plug Detect in follower
+    MHL_CLR_HPD                 = 0x65,         // Clear Hot Plug Detect in follower
+    MHL_MSC_MSG                 = 0x68,         // VS command to send RCP sub-commands
+    MHL_GET_SC1_ERRORCODE       = 0x69,         // Get Vendor-Specific command error code.
+    MHL_GET_DDC_ERRORCODE       = 0x6A,         // Get DDC channel command error code.
+    MHL_GET_MSC_ERRORCODE       = 0x6B,         // Get MSC command error code.
+    MHL_WRITE_BURST             = 0x6C,         // Write 1-16 bytes to responders scratchpad.
+    MHL_GET_SC3_ERRORCODE       = 0x6D,         // Get channel 3 command error code.
+};
+
+//
+// CBUS module reports these error types
+//
+typedef enum
+{
+    SUCCESS                 = 0x00,
+    ERROR_CBUS_ABORT        = 0x01,
+    ERROR_CBUS_TIMEOUT      = 0x02,
+    ERROR_WRITE_FAILED      = 0x04,
+    ERROR_NACK_FROM_PEER    = 0x08,
+    ERROR_CBUS_ABORT_OTHER  = 0x10,
+    ERROR_CBUS_OTHER        = 0x20,
+} CBUS_SOFTWARE_ERRORS_t;
+
+typedef enum
+{
+    CBUS_IDLE           = 0,    // BUS idle
+    CBUS_SENT,                  // Command sent
+    CBUS_XFR_DONE,              // Translation layer complete
+} CBUS_STATE_t;
+
+typedef enum
+{
+    CBUS_REQ_IDLE       = 0,
+    CBUS_REQ_PENDING,           // Request is waiting to be sent
+    CBUS_REQ_SENT,              // Request has been sent
+} CBUS_REQ_t;
+
+typedef enum
+{
+    CBUS_BURST_IDLE      = 0,    // idle
+    CBUS_BURST_PENDING,          // is waiting to be sent
+} CBUS_BURST_t;
+
+
+#endif /* SI_CBUS_ENUMS_H_ */
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/edid/si_edid_3d_internal.h b/drivers/amlogic/ext_hdmiin/sii9293/component/edid/si_edid_3d_internal.h
new file mode 100755
index 000000000000..88deb7a4d169
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/edid/si_edid_3d_internal.h
@@ -0,0 +1,65 @@
+//***************************************************************************
+//!file     si_edid_3d_internal.h
+//!brief    Silicon Image CEC Component.
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2002-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+#ifndef __SI_EDID_3D_INTERNAL_H__
+#define __SI_EDID_3D_INTERNAL_H__
+
+#include "si_common.h"
+
+//-------------------------------------------------------------------------------
+// typedefs, and manifest constants
+//-------------------------------------------------------------------------------
+
+#define HDMI_3D_SVD_STRUCTURE_LENGTH 16                     // maximum by HDMI 1.4 spec
+
+typedef struct svd 
+{
+    bit_fld_t   Vic     : 7;
+    bit_fld_t   Native  : 1;
+}svd_t, *p_svd_t;
+
+typedef union VIC3DFormat
+{
+    uint8_t        Data;
+    struct{
+        bit_fld_t FrameSequential:1;    //FS_SUPP
+        bit_fld_t TopBottom:1;          //TB_SUPP
+        bit_fld_t LeftRight:1;          //LR_SUPP      
+    }Fields;
+
+}VIC3DFormat_t;
+
+typedef struct Mandatory3dFmt
+{
+    svd_t VicCode;
+    VIC3DFormat_t vic3dFmt;
+}Mandatory3dFmt_t;
+
+#define Mandatory3dFmt_60       3
+#define Mandatory3dFmt_50       3
+
+// VIC in mandatory 3D formats
+
+#define VIC_1080P_24            32
+#define VIC_1080i_50            20
+#define VIC_1080i_60            5
+#define VIC_720P_50             19
+#define VIC_720P_60             4
+
+// MHL 3D formats
+
+#define FRAME_SEQUENTIAL  0x01
+#define TOP_BOTTOM        0x02
+#define LEFT_RIGHT        0x04
+
+#endif // __SI_EDID_3D_INTERNAL_H__
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_audio.c b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_audio.c
new file mode 100755
index 000000000000..9b56ed20e3be
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_audio.c
@@ -0,0 +1,535 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#include "si_rx_audio.h"
+#include "si_video_tables.h"
+#include "si_drv_rx_isr.h"
+#include "si_rx_info.h"
+#include "si_rx_video_mode_detection.h"
+#include "si_drv_rx_cfg.h"
+#include "si_cra.h"
+
+#include "si_common.h"
+
+#include "si_drv_rx.h"
+
+#include "si_drv_board.h"
+
+
+#define MAX_AUDIO_HANDLER_INVOCATION_TIME 100
+#define MIN_AUDIO_HANDLER_INVOCATION_TIME 10
+
+// Uncomment following defines for debugging
+//#define PRINT_AUDIO_ERRORS
+//#define PRINT_RX_CHST
+//#define PRINT_FS_CALCULATION
+
+#define BEGIN_ERROR_CHECK do
+#define PERFORM_ERROR_CHECK(a, err) {if(!(a)) {error = true; audio_vars.error|=err; break;}}
+#define END_ERROR_CHECK while(false);
+
+#define AUDIO_ERR__NO_AUDIO_PACKETS		0x01
+#define AUDIO_ERR__NO_CTS_PACKETS		0x02
+#define AUDIO_ERR__CTS_OUT_OF_RANGE		0x04
+#define AUDIO_ERR__CTS_IRREGULAR		0x08
+#define AUDIO_ERR__PLL_UNLOCKED			0x10
+#define AUDIO_ERR__FIFO_UNSTABLE		0x20
+
+
+// Audio Channel Status byte 1
+#define AUDIO_CHST1__ENCODED				0x02 // 0-PCM, 1- for other purposes
+
+// Audio Channel Status byte 4
+#define AUDIO_CHST4__FS_44					0x00 // Fs = 44.1 kHz
+#define AUDIO_CHST4__FS_UNKNOWN				0x01 //
+#define AUDIO_CHST4__FS_48					0x02 // Fs = 48 kHz
+#define AUDIO_CHST4__FS_32					0x03 // Fs = 32 kHz
+#define AUDIO_CHST4__FS_22					0x04 // Fs = 22.05 kHz
+#define AUDIO_CHST4__FS_24					0x06 // Fs = 24 kHz
+#define AUDIO_CHST4__FS_88					0x08 // Fs = 88.2 kHz
+#define AUDIO_CHST4__FS_768					0x09 // Fs = 768 kHz (HBR Audio 4x192kHz)
+#define AUDIO_CHST4__FS_96					0x0A // Fs = 96 kHz
+#define AUDIO_CHST4__FS_176					0x0C // Fs = 176.4 kHz
+#define AUDIO_CHST4__FS_192					0x0E // Fs = 192 kHz
+
+
+typedef struct
+{
+	uint8_t		ca; // Channel Allocation field from Audio Info Frame
+	uint8_t		fs; // sample frequency from the Audio Channel Status
+	uint8_t		error; // error bit mask
+	//bit_fld_t	status_received : 1; // true if channel status data is valid
+	bit_fld_t	audio_info_frame_received : 1; // true if audio info frame has been received
+	bit_fld_t	encoded : 1; // false for PCM, true for encoded streams
+	bit_fld_t	protected : 1; // true for audio with protected context and with ACP packet
+	//bit_fld_t	dsd_mode : 1; // true for DSD mode
+	//bit_fld_t	start_request : 1; // a flag to start audio processing
+	//bit_fld_t	exceptions_enabled : 1; // true if audio exceptions are on, false otherwise (shadow bit of 0x60.0xB5.0)
+	//bit_fld_t	hbr_mode : 1; // true for HBR Audio mode
+	//bit_fld_t	muted : 1; // set if Audio Mute pin is asserted by FW, cleared otherwise
+	bit_fld_t	new_countdown : 1; // a request for a new count down in RxAudioTimerHandler()
+	bit_fld_t	audio_is_on : 1; // static variable used in switch_audio()
+	bit_fld_t layout1 : 1; // true for layout 1; false for layout 0
+	time_ms_t	count_down; // a countdown timer
+	uint8_t		measured_fs_code; // calculated sample frequency in Channel Status's format
+	uint8_t		channel_status[5]; // first 5 bytes of audio status channel
+}
+rx_audio_vars_type;
+
+static rx_audio_vars_type audio_vars = {0};
+
+typedef struct
+{
+	uint8_t		code_value; // corresponding audio status Fs code
+	uint16_t	ref_Fs; // reference Fs frequency in 100 Hz units
+	uint16_t	min_Fs; // minimum Fs frequency in 100 Hz units
+	uint16_t	max_Fs; // maximum Fs frequency in 100 Hz units
+}
+audio_fs_search_t;
+
+#define AUDIO_FS_LIST_LENGTH 9
+static ROM const audio_fs_search_t audio_fs_list[AUDIO_FS_LIST_LENGTH+1] =
+{
+	{ AUDIO_CHST4__FS_22,		220,	200,	230  },
+	{ AUDIO_CHST4__FS_24,		240,	230,	280  },
+	{ AUDIO_CHST4__FS_32,		320,	280,	380  },
+	{ AUDIO_CHST4__FS_44,		441,	380,	460  },
+	{ AUDIO_CHST4__FS_48,		480,	460,	540  },
+	{ AUDIO_CHST4__FS_88,		882,	820,	921  },
+	{ AUDIO_CHST4__FS_96,		960,	921,	1100 },
+	{ AUDIO_CHST4__FS_176,		1764,	1600,	1792 },
+	{ AUDIO_CHST4__FS_192,		1920,	1792,	2500 },
+	{ AUDIO_CHST4__FS_UNKNOWN,	0,    	0,		0 }
+
+};
+
+#define AUDIO_CHANNEL_MASK_TABLE_LENGTH 32
+static ROM const uint8_t audio_channel_mask[AUDIO_CHANNEL_MASK_TABLE_LENGTH] =
+{
+	0x10, 0x30, 0x30, 0x30, 0x70, 0x70, 0x70, 0x70,
+	0x70, 0x70, 0x70, 0x70, 0xF0, 0xF0, 0xF0, 0xF0,
+	0xF0, 0xF0, 0xF0, 0xF0, 0xB0, 0xB0, 0xB0, 0xB0,
+	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
+};
+
+
+#define AEC_REG_BLOCK_SIZE 3
+
+/*
+ Audio exception on H Resolution Change may be disabled to improve
+ interoperability with some  incomplaint sources.
+ Audio exception on V Resolution Change may be  disabled in 3D or 4K2K video
+ mode since the chip generates false V Chng interrupts.
+ Since audio exception may be skipped due to it is disabled for one
+ of the reasons above, we need to make sure the audio is off manually.
+ In this table V Res Chng is enabled, but H Res Chng is disabled.
+ Once 3D or 4K2K mode is detected, V Res Cnhg will be disabled and
+ H Res Chng will be enabled.
+*/
+ROM const uint8_t default_aec_regs[AEC_REG_BLOCK_SIZE] = {0xC1, 0x07, 0x01};
+
+
+//-------------------------------------------------------------------------------------------------
+static uint8_t get_rx_audio_channel_mask(uint8_t ca)
+{
+	uint8_t audio_mask = 0x10; // default: stereo
+	if(ca < AUDIO_CHANNEL_MASK_TABLE_LENGTH)
+	{
+		audio_mask = audio_channel_mask[ca];
+	}
+	return audio_mask;
+}
+
+//-------------------------------------------------------------------------------------------------
+// returns true if SPDIF output should be disabled, false otherwise
+static bool_t is_spdif_out_prohibited(void)
+{
+	return 0 !=
+	(
+		audio_vars.protected || // protected audio
+		((!audio_vars.encoded) && audio_vars.ca) // PCM with more than 2 channels
+		|| !SiiSpdifEnableGet()
+	);
+}
+
+//-------------------------------------------------------------------------------------------------
+#ifdef PRINT_AUDIO_ERRORS
+static void print_audio_errors(void)
+{
+#if 0 // 1 to save some ROM space
+	DEBUG_PRINT(MSG_ERR, ("RX Audio Errors: %02X\n", (int) audio_vars[pipe].error));
+#else
+	DEBUG_PRINT(MSG_ERR, ("Rx Audio Errors: "));
+	if(audio_vars.error & AUDIO_ERR__NO_AUDIO_PACKETS)
+		DEBUG_PRINT(MSG_ERR, ("No Audio Packets "));
+	if(audio_vars.error & AUDIO_ERR__NO_CTS_PACKETS)
+		DEBUG_PRINT(MSG_ERR, ("No CTS Packets "));
+	if(audio_vars.error & AUDIO_ERR__CTS_OUT_OF_RANGE)
+		DEBUG_PRINT(MSG_ERR, ("CTS out of range "));
+	if(audio_vars.error & AUDIO_ERR__CTS_IRREGULAR)
+		DEBUG_PRINT(MSG_ERR, ("CTS is irregular "));
+	if(audio_vars.error & AUDIO_ERR__PLL_UNLOCKED)
+		DEBUG_PRINT(MSG_ERR, ("PLL unlocked "));
+	if(audio_vars.error & AUDIO_ERR__FIFO_UNSTABLE)
+		DEBUG_PRINT(MSG_ERR, ("FIFO unstable "));
+	DEBUG_PRINT(MSG_ERR, ("\n"));
+#endif
+}
+#endif // PRINT_AUDIO_ERRORS
+
+//-------------------------------------------------------------------------------------------------
+static uint32_t get_cts(void)
+{
+	uint16_t cts_l;
+	uint32_t cts_h;
+
+	cts_l = SiiRegReadWord(RX_A__CTS_HVAL1);
+	cts_h = SiiRegRead(RX_A__CTS_HVAL3);
+	return (cts_h << 16) | cts_l;
+}
+
+//-------------------------------------------------------------------------------------------------
+static uint32_t get_n(void)
+{
+	uint16_t n_l;
+	uint32_t n_h;
+
+	n_l = SiiRegReadWord(RX_A__N_HVAL1);
+	n_h = SiiRegRead(RX_A__N_HVAL3);
+	return (n_h << 16) | n_l;
+}
+
+//-------------------------------------------------------------------------------------------------
+// Get TMDS clock frequency of incoming video (in 100 Hz units).
+// Limitation: this function may return zero if it is called before video is detected.
+static uint32_t get_tclk_10kHz(void)
+{
+	uint32_t tmds_clk_10kHz = VMD_GetPixFreq10kHz();
+	// this is Pix Clock (not TMDS clock at that moment) in 100 Hz units
+
+	// convert pixel clock into TMDS clock
+#if 0 //Deep color is not supported in 5293
+	switch(SiiDrvRxInputColorDepthGet())
+	{
+		case SII_RX_VBUS_WIDTH_30: // DC 30 bit
+			tmds_clk_10kHz = tmds_clk_10kHz * 5 / 4; // *1.25
+		break;
+		case SII_RX_VBUS_WIDTH_36: // DC 36 bit
+			tmds_clk_10kHz = tmds_clk_10kHz * 3 / 2; // *1.5
+		break;
+		case SII_RX_VBUS_WIDTH_48: // DC 48 bit (reserved for the future)
+			tmds_clk_10kHz *= 2; // *2
+		break;
+	}
+#endif
+	return tmds_clk_10kHz;
+}
+
+//-------------------------------------------------------------------------------------------------
+static void set_mclk(void)
+{
+	rxCfgAudioMclk_t mclk = RX_CFG_256FS;   //the minimum MCLK for TDM is 256*fs, set MCLK as 256*fs always 
+
+	uint8_t fs_code_per_channel = AUDIO_CHST4__FS_UNKNOWN;
+
+	audio_vars.measured_fs_code = AUDIO_CHST4__FS_UNKNOWN;
+
+	{
+		// non-DSD mode
+
+		uint32_t cts = get_cts();
+		uint32_t n = get_n();
+
+		uint32_t tmds_clk_10kHz = get_tclk_10kHz();
+		// Note: tmds_clk_10kHz information may be not available
+		// if audio detection occurs before video detection;
+		// in this case tmds_clk_10kHz is 0
+
+		uint16_t fs_frequency_per_channel = 0;
+
+		if(tmds_clk_10kHz && cts)
+		{
+			uint8_t i;
+
+			// Calculate audio Fs in 100Hz units
+			uint16_t fs_calculated_100Hz = (tmds_clk_10kHz*n/cts)*100 /128;
+			// Note: the order of operations is optimized for the maximum precision.
+			// Overflow should not occur during the operations.
+			// tmds_clk_10kHz - assume maximum value 30,000 (15bit) for 300 MHz
+			// n - assume maximum value 192kHz*128/300=81000 (17bit)
+			// tmds_clk_10kHz*n should fit into 32 bits
+			// Maximum fs_calculated_100Hz is 192000/100=1920 fits into 16bit
+
+			// Find closest standard audio Fs.
+			for(i = 0; i < AUDIO_FS_LIST_LENGTH; i++)
+			{
+				if((fs_calculated_100Hz <= ( audio_fs_list[i].max_Fs))
+					&& (fs_calculated_100Hz > ( audio_fs_list[i].min_Fs) ))
+				{
+					// search if calculated Fs close to the Fs in the table
+					break;
+				}
+			}
+			fs_code_per_channel = audio_fs_list[i].code_value;
+			fs_frequency_per_channel = audio_fs_list[i].ref_Fs;
+		}
+
+		if(AUDIO_CHST4__FS_UNKNOWN == fs_code_per_channel)
+		{
+			DEBUG_PRINT(MSG_STAT, "RX Audio: Fs code = %02X\n", (int) (audio_vars.fs));
+		}
+		else
+		{
+//			DEBUG_PRINT(MSG_STAT, "RX Audio: Calculated Fs = %d kHz\n", (int) fs_frequency_per_channel/10);
+		}
+
+		audio_vars.measured_fs_code = fs_code_per_channel;
+	}
+
+	SiiRegWrite(RX_A__FREQ_SVAL, (mclk << 6) | (mclk << 4) | fs_code_per_channel);
+
+	if(fs_code_per_channel == AUDIO_CHST4__FS_UNKNOWN) 
+	{
+		//if DSD mode or calculated Fs invalid
+		SiiRegBitsSet(RX_A__ACR_CTRL1, RX_M__ACR_CTRL1__FS_SEL, OFF);
+	}
+	else
+	{
+		// use SW selected Fs
+		SiiRegBitsSet(RX_A__ACR_CTRL1, RX_M__ACR_CTRL1__FS_SEL, ON);
+	}
+}
+
+//-------------------------------------------------------------------------------------------------
+static void set_output(void)
+{
+	uint8_t out_mask =
+		RX_M__I2S_CTRL2__MCLK_EN   | // always enabled
+		RX_M__I2S_CTRL2__SD0_EN    | // at least one I2S (two DSD) channel
+		RX_M__I2S_CTRL2__MUTE_FLAT; // mute invalid packets
+
+	if(audio_vars.audio_info_frame_received)
+	{
+		if(!audio_vars.encoded)
+		{
+			out_mask |= get_rx_audio_channel_mask(audio_vars.ca);
+		}
+		// Encoded data can be whether through 1 I2S channel or through HBRA;
+		// it cannot be through multiple I2S channels in non-HBRA mode.
+	};
+	SiiRegWrite(RX_A__I2S_CTRL2, out_mask);
+
+	// Enable TDM as configured
+	SiiRegBitsSet(RX_A__TDM_CTRL1, RX_M__TDM_CTRL1__TDM_EN, SiiTdmEnableGet());
+
+	// enable SPDIF if allowed
+	SiiRegWrite(RX_A__AUDRX_CTRL,
+		RX_M__AUDRX_CTRL__PASS_SPDIF_ERR |
+		RX_M__AUDRX_CTRL__I2S_MODE |
+		RX_M__AUDRX_CTRL__HW_MUTE_EN |
+		(is_spdif_out_prohibited() ? 0 : RX_M__AUDRX_CTRL__SPDIF_EN));
+
+}
+
+//-------------------------------------------------------------------------------------------------
+static void update(void)
+{
+	{
+		set_output();
+		set_mclk(); // couldn't it make audio restart if MCLK changed?
+	}
+}
+
+//-------------------------------------------------------------------------------------------------
+void RxAudio_OnAudioInfoFrame(uint8_t *p_data, uint8_t length)
+{
+	if(p_data && (length>=5))
+	{
+		audio_vars.audio_info_frame_received = true;
+		audio_vars.ca = p_data[3];
+	}
+	else
+	{
+		audio_vars.audio_info_frame_received = false;
+	}
+
+	if(audio_vars.audio_info_frame_received)
+	{
+		// update() function has to be called
+		// since channel allocation (CA) field my be changed
+		update();
+	}
+}
+
+//-------------------------------------------------------------------------------------------------
+static void report_audio_format(void)
+{
+	SiiRxAudioFormat_t rxAudioFormat;
+
+	rxAudioFormat.audioLayout = audio_vars.layout1;
+	rxAudioFormat.audioEncoded = audio_vars.encoded;
+	rxAudioFormat.audioChannelAllocation = audio_vars.ca;
+	memcpy(rxAudioFormat.audioStatusChannel,
+		audio_vars.channel_status, SI_AUDIO_ST_CH_LEN);
+}
+
+//-------------------------------------------------------------------------------------------------
+void RxAudio_OnChannelStatusChange(void)
+{
+	SiiRegReadBlock(RX_A__CHST1, &audio_vars.channel_status[0], 3);
+
+	audio_vars.encoded = 
+		(0 != (audio_vars.channel_status[0] & AUDIO_CHST1__ENCODED));
+
+
+	SiiRegReadBlock(RX_A__CHST4, &audio_vars.channel_status[3], 2);
+
+	// Fs data read from RX_A__CHST4 may be not the actual value coming
+	// from HDMI input, but the Fs written into RX_A__FREQ_SVAL.
+	// To have real Fs value, get it from RX_A__PCLK_FS register
+	// and replace in the audio status channel byte 4.
+	audio_vars.channel_status[3] &= ~RX_M__CHST4__AUD_SAMPLE_F;
+	audio_vars.fs = SiiRegRead(RX_A__PCLK_FS) & RX_M__PCLK_FS__SPDIF_EXTRACRTED_FS; // HW measured Fs
+
+
+	if(AUDIO_CHST4__FS_UNKNOWN != audio_vars.measured_fs_code)
+	{
+		// replace with FW measured values
+		audio_vars.channel_status[3] |= audio_vars.measured_fs_code;
+	}
+	else
+	{
+		// replace with HW measured values
+		audio_vars.channel_status[3] |= audio_vars.fs;
+	}
+
+	// Note: DSD does not have Audio Status Channel, so all bytes in the Audio
+	// Status Channel registers are zeros.
+	// That should not cause problems because the DSD format is fixed.
+
+#ifdef PRINT_RX_CHST
+	DEBUG_PRINT(MSG_STAT, ("RX CHST %02X %02X %02X %02X %02X\n",
+		(int) audio_vars.channel_status[0],
+		(int) audio_vars.channel_status[1],
+		(int) audio_vars.channel_status[2],
+		(int) audio_vars.channel_status[3],
+		(int) audio_vars.channel_status[4]));
+#endif // PRINT_RX_CHST
+
+	audio_vars.layout1 =
+		(0 != (SiiRegRead(RX_A__AUDP_STAT) & RX_M__AUDP_STAT__LAYOUT));
+
+	//audio_vars.status_received = true;
+	report_audio_format();
+	update();
+}
+
+//-------------------------------------------------------------------------------------------------
+static void switch_audio(bool_t switch_on)
+{
+	if(switch_on)
+	{
+		if(!audio_vars.audio_is_on) // reduce extra log prints
+		{
+			DEBUG_PRINT(MSG_STAT, ("RX Audio: ON\n"));
+			audio_vars.audio_is_on = true;
+		}
+
+		SiiRegBitsSet(RX_A__AUDP_MUTE, RX_M__AUDP_MUTE__AUDIO_MUTE, OFF);
+	}
+	else
+	{
+		if(audio_vars.audio_is_on) // reduce extra log prints
+		{
+			DEBUG_PRINT(MSG_STAT, ("RX Audio: OFF\n"));
+			audio_vars.audio_is_on = false;
+		}
+		SiiRegBitsSet(RX_A__AUDP_MUTE, RX_M__AUDP_MUTE__AUDIO_MUTE, ON);
+
+		// disable I2S output, but keep MCLKenable, SPDIF is on with flat output
+		SiiRegWrite(RX_A__AUDRX_CTRL,
+					RX_M__AUDRX_CTRL__PASS_SPDIF_ERR |
+					RX_M__AUDRX_CTRL__I2S_MODE |
+					0);
+	}
+}
+
+//-------------------------------------------------------------------------------------------------
+void RxAudio_Start(void)
+{
+    RxInfo_ResetAudioInfoFrameData();
+    switch_audio(ON);
+}
+
+//-------------------------------------------------------------------------------------------------
+void RxAudio_Stop(void)
+{
+    switch_audio(OFF);
+}
+
+
+//-------------------------------------------------------------------------------------------------
+void RxAudio_ReStart(void)
+{
+	RxAudio_Stop();
+	RxAudio_Start();
+}
+
+//-------------------------------------------------------------------------------------------------
+// block SPDIF output depending on stream type by ACP
+void RxAudio_OnAcpPacketUpdate(acp_type_type acp_type)
+{
+	bool_t protected_audio = (acp_GeneralAudio != acp_type);
+	if(audio_vars.protected != protected_audio)
+	{
+		audio_vars.protected = protected_audio;
+		if(protected_audio)
+		{
+			DEBUG_PRINT(MSG_STAT, ("Protected Audio\n"));
+		}
+		else
+		{
+			DEBUG_PRINT(MSG_STAT, ("General Audio\n"));
+		}
+        }
+//	if((as_AudioOn == audio_vars.rx_audio_state) || (as_AudioReady== audio_vars.rx_audio_state))
+		SiiRegBitsSet
+		(
+			RX_A__AUDRX_CTRL,
+			RX_M__AUDRX_CTRL__SPDIF_EN,
+			!is_spdif_out_prohibited()
+		);
+}
+
+
+//-------------------------------------------------------------------------------------------------
+void RxAudio_Init(void)
+{
+	memset(&audio_vars, 0, sizeof(audio_vars));
+	audio_vars.fs = AUDIO_CHST4__FS_UNKNOWN; // means "not indicated", default values for 48kHz audio will be used
+
+	SiiRegWrite(RX_A__TDM_CTRL2, 0x01); // configure FS signal width to 1 clock cycle
+
+	// default audio settings (set to I2S)
+	SiiRegWrite(RX_A__I2S_CTRL1, RX_M__I2S_CTRL1__EDGE);
+
+	// Audio PLL setting
+	SiiRegWrite(RX_A__APLL_POLE, 0x88);
+	SiiRegWrite(RX_A__APLL_CLIP, 0x16);
+
+	// allow SPDIF clocking even if audio is not coming out
+	//SiiRegWrite(RX_A__AUDRX_CTRL, 0);
+	SiiRegWrite(RX_A__AUDRX_CTRL, RX_M__AUDRX_CTRL__I2S_MODE);
+
+	RxAudio_Start();
+}
+
+
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_audio.h b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_audio.h
new file mode 100755
index 000000000000..bf3c75218928
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_audio.h
@@ -0,0 +1,43 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#ifndef SIIRXAUDIO_H
+#define SIIRXAUDIO_H
+
+#include "si_rx_info.h"
+
+typedef enum
+{
+	RX_CFG_128FS = 0,
+	RX_CFG_256FS = 1,
+	RX_CFG_384FS = 2,
+	RX_CFG_512FS = 3,
+}
+rxCfgAudioMclk_t;
+
+#define SI_AUDIO_ST_CH_LEN 5
+typedef struct
+{
+	bit_fld_t         audioLayout  : 1;   //!< incoming HDMI audio layout (0 or 1)
+	bit_fld_t         audioEncoded : 1;   //!< true for encoded audio, false for PCM and DSD
+	uint8_t        audioChannelAllocation;//!< audio Channel Allocation (See CEA-861D)
+	uint8_t        audioStatusChannel[SI_AUDIO_ST_CH_LEN]; //!< first 5 bytes of Audio Status Channel
+}
+SiiRxAudioFormat_t;
+
+void RxAudio_OnAudioInfoFrame(uint8_t *p_data, uint8_t length);
+void RxAudio_OnChannelStatusChange(void);
+void RxAudio_Init(void);
+void RxAudio_Stop(void);
+void RxAudio_ReStart(void);
+ void RxAudio_OnAcpPacketUpdate(acp_type_type acp_type);
+
+#endif // SIIRXAUDIO_H
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_info.c b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_info.c
new file mode 100755
index 000000000000..374693acea74
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_info.c
@@ -0,0 +1,272 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#include "si_rx_info.h"
+#include "si_drv_rx_isr.h"
+#include "si_rx_audio.h"
+#include "si_rx_video_mode_detection.h"
+#include "si_drv_rx.h"
+#ifdef SK_TX_EVITA
+#include "si_drv_evita.h"
+#endif
+
+#define SPD_BUFFER_LENGTH				IF_MIN_SPD_LENGTH
+
+// -----------------------------------------------
+typedef struct
+{
+	bit_fld_t	AVI		: 1;
+	bit_fld_t	SPD		: 1;
+	bit_fld_t	Audio	: 1;
+	bit_fld_t	VSIF	: 1;
+	bit_fld_t	ISRC1	: 1;
+	bit_fld_t	ISRC2	: 1;
+	bit_fld_t	ACP		: 1;
+	bit_fld_t	GBD		: 1;
+}
+list_of_packets_type;
+
+// -----------------------------------------------
+typedef struct
+{
+	list_of_packets_type received_packets;
+	list_of_packets_type failed_packets;
+	acp_type_type acp_type;
+
+	uint8_t spd_buffer[SPD_BUFFER_LENGTH];
+}
+rx_info_type;
+
+// -----------------------------------------------
+static rx_info_type rx_info = {{0},};
+static uint8_t avi_data[AVI_LENGTH] = {0};
+static uint8_t avi_version = {0};
+
+// -----------------------------------------------
+bool_t is_check_sum_correct(uint8_t *p_data, uint8_t length)
+{
+	uint8_t i;
+	uint8_t check_sum = 0;
+	for (i = 0; i < length; i++, p_data++)
+		check_sum += *p_data;
+	return 0 == check_sum;
+}
+
+// -----------------------------------------------
+void on_spd_receiving(uint8_t packet[IF_BUFFER_LENGTH])
+{
+	uint8_t data_length = packet[IF_LENGTH_INDEX];
+
+	if( (data_length >= IF_MIN_SPD_LENGTH) && (data_length <= IF_MAX_SPD_LENGTH) &&
+		is_check_sum_correct(packet, data_length + IF_HEADER_LENGTH) )
+	{
+		// The packet looks valid.
+		rx_info.received_packets.SPD = true;
+
+		memcpy(rx_info.spd_buffer, packet, SPD_BUFFER_LENGTH);
+
+		DEBUG_PRINT(MSG_STAT, ("Got SPD\n"));
+	}
+	else
+	{
+		// The packet is invalid.
+		rx_info.failed_packets.SPD = true;
+	}
+
+}
+
+// -----------------------------------------------
+void on_vsif_receiving(uint8_t packet[IF_BUFFER_LENGTH])
+{
+	uint8_t data_length = packet[IF_LENGTH_INDEX];
+
+	// DEBUG_PRINT(MSG_STAT, ("on_vsif_receiving\n"));
+
+	// checksum and length verification
+	if( (data_length >= IF_MIN_VSIF_LENGTH) && (data_length <= IF_MAX_VSIF_LENGTH) &&
+		is_check_sum_correct(packet, data_length + IF_HEADER_LENGTH) )
+	{
+              bool_t packet_new = false;
+
+              // DEBUG_PRINT(MSG_STAT, ("valid vsif\n"));
+
+		rx_info.received_packets.VSIF = true;
+		switch(VMD_GetVsifPacketType(&packet[IF_HEADER_LENGTH], packet[IF_LENGTH_INDEX]))
+		{
+		case NEW_3D:
+		case NEW_EXTENDED_RESOLUTION:
+			packet_new = true;
+			DEBUG_PRINT(MSG_STAT, ("Got NEW 3D / Extended Resolution\n"));
+			// no break here
+		case OLD_3D:
+		case OLD_EXTENDED_RESOLUTION:
+
+			if(packet_new)
+			{
+				DEBUG_PRINT(MSG_STAT, ("Got NEW VSIF\n"));	
+				VMD_VsifProcessing(&packet[IF_HEADER_LENGTH], packet[IF_LENGTH_INDEX]);
+			}
+		}
+	}
+}
+
+
+// -----------------------------------------------
+void RxInfo_NoAviHandler(void)
+{
+	DEBUG_PRINT(MSG_STAT, ("RX: No AVI\n"));
+}
+
+// -----------------------------------------------
+void RxInfo_NoVsiHandler(void)
+{
+    DEBUG_PRINT(MSG_STAT, ("RX: No VSIF.\n"));
+    VMD_OnHdmiVsifPacketDiscontinuation();
+}
+
+// -----------------------------------------------
+void RxInfo_ResetData(void)
+{
+	memset(&rx_info, 0, sizeof(rx_info));
+
+	RxAVI_ResetData();
+	rx_info.acp_type = acp_GeneralAudio;
+
+	RxAudio_OnAcpPacketUpdate(rx_info.acp_type);
+
+	VMD_ResetInfoFrameData();
+}
+
+// -----------------------------------------------
+void RxInfo_ResetAudioInfoFrameData(void)
+{
+	RxAudio_OnAudioInfoFrame(NULL, 0);
+}
+
+void on_acp_receiving(uint8_t packet[IF_BUFFER_LENGTH])
+{
+	rx_info.received_packets.ACP = true;
+	rx_info.acp_type = (acp_type_type) packet[1];
+
+	RxAudio_OnAcpPacketUpdate(rx_info.acp_type);
+
+}
+
+void on_avi_receiving(uint8_t packet[IF_BUFFER_LENGTH])
+{
+	uint8_t data_length = packet[IF_LENGTH_INDEX];
+
+	if( (data_length >= IF_MIN_AVI_LENGTH) && (data_length <= IF_MAX_AVI_LENGTH) &&
+		is_check_sum_correct(packet, data_length + IF_HEADER_LENGTH) )
+	{
+		RxAVI_StoreData(packet);
+		VMD_OnAviPacketReceiving(RxAVI_GetVic());
+		SiiDrvRxVideoPathSet();
+
+#ifdef SK_TX_EVITA
+		SiiDrvEvitaAviIfUpdate();
+#endif
+		rx_info.received_packets.AVI = true;
+		DEBUG_PRINT(MSG_STAT, ("New AVI\n"));
+		//DEBUG_PRINT(MSG_STAT, ("%02X %02X %02X %02X %02X\n", (int) d[0], (int) d[1], (int) d[2], (int) d[3], (int) d[4]));
+	}
+	else
+	{
+		rx_info.failed_packets.AVI = true;
+	}
+}
+
+void on_aud_receiving(uint8_t packet[IF_BUFFER_LENGTH])
+{
+	uint8_t data_length = packet[IF_LENGTH_INDEX];
+
+	if( (data_length >= IF_MIN_AUDIO_LENGTH) && (data_length <= IF_MAX_AUDIO_LENGTH) &&
+		is_check_sum_correct(packet, data_length + IF_HEADER_LENGTH) )
+	{
+		rx_info.received_packets.Audio = true;
+#ifdef SK_TX_EVITA
+		SiiDrvEvitaAudioIfUpdate(packet);
+#endif
+		RxAudio_OnAudioInfoFrame(&packet[IF_HEADER_LENGTH], data_length);
+	}
+	else
+	{
+		rx_info.failed_packets.Audio = true;
+	}
+}
+
+uint8_t RxAVI_GetVic(void)
+{
+	return avi_data[3] & 0x7F;
+}
+
+uint8_t RxAVI_GetReplication(void)
+{
+	return avi_data[4] & 0x0F;
+}
+
+colorimetry_type RxAVI_GetColorimetry(void)
+{
+	colorimetry_type c = (colorimetry_type) ((avi_data[1] >> 6) & 0x03);
+	if(Colorimetry_Extended == c)
+	{
+		uint8_t ec = (avi_data[2] >> 4) & 0x07;
+		if(ec < 2)
+		{
+			c = Colorimetry_xv601 + (colorimetry_type) ec;
+		}
+		else
+		{
+			c = Colorimetry_NoInfo;
+		}
+	}
+	return c;
+}
+
+color_space_type RxAVI_GetColorSpace(void)
+{
+	return (color_space_type) ((avi_data[0] >> 5) & 0x03);
+}
+
+void RxAVI_StoreData(uint8_t *p_data)
+{
+	memcpy(avi_data, &p_data[IF_HEADER_LENGTH], AVI_LENGTH);
+
+	avi_version = p_data[1];
+	if(avi_version < 2)
+	{
+		avi_data[3] = 0; // VIC=0
+		avi_data[4] = 0; // Repetition
+	}
+}
+
+void RxAVI_ResetData(void)
+{
+	memset(&avi_data, 0, AVI_LENGTH);
+	avi_version = 0;
+}
+
+range_quantization_type RxAVI_GetRangeQuantization(void)
+{
+    range_quantization_type type;
+    if (ColorSpace_RGB == RxAVI_GetColorSpace())
+    {
+        type = (avi_data[2] & 0x0C) >> 2;
+        if (type > Range_Full)
+            type = Range_Default;
+    }
+    else
+    {
+        type = ((avi_data[4] & 0xC0) >> 6) + 1;
+        if (type > Range_Full)
+            type = Range_Limited;
+    }
+    return type;
+}
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_info.h b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_info.h
new file mode 100755
index 000000000000..0347b0c00fec
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_info.h
@@ -0,0 +1,120 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#ifndef __SI_RX_INFO_H__
+#define __SI_RX_INFO_H__
+
+#include "si_drv_rx_info.h"
+
+
+#define	IF_BUFFER_LENGTH 31
+
+#define	IF_HEADER_LENGTH		4
+#define	IF_TITLE_INDEX			0
+#define	IF_VERSION_INDEX		1
+#define	IF_LENGTH_INDEX		2
+#define	IF_CHECKSUM_INDEX		3
+#define	IF_DATA_INDEX			IF_HEADER_LENGTH
+
+#define	IF_MIN_AVI_LENGTH 13 // the 861C standard defines the length as 13
+#define	IF_MAX_AVI_LENGTH 15 // maximum allowed by the chip
+#define	IF_MIN_AUDIO_LENGTH 10 // the 861C standard defines the length as 10
+#define	IF_MAX_AUDIO_LENGTH 10 // maximum allowed by the chip
+#define	IF_MIN_MPEG_LENGTH 10 // the 861C standard defines the length as 10
+#define	IF_MAX_MPEG_LENGTH 27 // maximum allowed by the chip
+#define	IF_MIN_SPD_LENGTH 25 // the 861C standard defines the length as 25
+#define	IF_MAX_SPD_LENGTH 27 // maximum allowed by the chip
+#define	IF_MIN_VSIF_LENGTH 4 // minimum length by HDMI 1.4
+#define	IF_MAX_VSIF_LENGTH 27 // maximum allowed by the chip
+
+/**
+* @brief InfoFrame/InfoPacket codes
+*/
+typedef enum
+{
+	SII_IF_AVI   = 0x82, //!< AVI InfoFrame
+	SII_IF_SPD   = 0x83, //!< SPD InfoFrame
+	SII_IF_AUDIO = 0x84, //!< Audio InfoFrame
+	SII_IF_MPEG  = 0x85, //!< MPEG InfoFrame
+	SII_IF_ISRC1 = 0x05, //!< ISRC1 InfoPacket
+	SII_IF_ISRC2 = 0x06, //!< ISRC2 InfoPacket
+	SII_IF_ACP   = 0x04, //!< ACP InfoPacket
+	SII_IF_GC    = 0x03, //!< General Control InfoPacket
+	SII_IF_GBD   = 0x0A, //!< GBD InfoPacket
+	SII_IF_VSIF  = 0x81, //!< VSIF InfoFrame
+}
+SiiInfoFramePacket_t;
+
+typedef enum
+{
+	acp_GeneralAudio = 0,
+	acp_IEC60958 = 1,
+	acp_DvdAudio = 2,
+	acp_SuperAudioCD = 3
+}
+acp_type_type;
+
+#define AVI_LENGTH 5
+
+typedef enum
+{
+	ColorSpace_RGB = 0,
+	ColorSpace_YCbCr422,
+	ColorSpace_YCbCr444
+} color_space_type;
+
+typedef enum
+{
+	Colorimetry_NoInfo,
+	Colorimetry_ITU601,
+	Colorimetry_ITU709,
+	Colorimetry_Extended, // if extended, but unknown
+	Colorimetry_xv601 = 10,
+	Colorimetry_xv709,
+} colorimetry_type;
+
+typedef enum
+{
+	Range_Default = 0,  //For RGB, default means full range for IT formats, and limited range for CE formats
+	Range_Limited,
+	Range_Full,
+} range_quantization_type;
+
+void RxInfo_NoAviHandler(void);
+
+void RxInfo_NoVsiHandler(void);
+
+void RxInfo_ResetData(void);
+
+void RxInfo_ResetAudioInfoFrameData(void);
+
+bool_t is_check_sum_correct(uint8_t *p_data, uint8_t length);
+
+void on_spd_receiving(uint8_t packet[IF_BUFFER_LENGTH]);
+
+void on_vsif_receiving(uint8_t packet[IF_BUFFER_LENGTH]);
+
+void on_acp_receiving(uint8_t packet[IF_BUFFER_LENGTH]);
+
+void on_avi_receiving(uint8_t packet[IF_BUFFER_LENGTH]);
+
+void on_aud_receiving(uint8_t packet[IF_BUFFER_LENGTH]);
+
+uint8_t RxAVI_GetVic(void);
+uint8_t RxAVI_GetReplication(void);
+colorimetry_type RxAVI_GetColorimetry(void);
+color_space_type RxAVI_GetColorSpace(void);
+
+void RxAVI_StoreData(uint8_t *p_data);
+void RxAVI_ResetData(void);
+
+range_quantization_type RxAVI_GetRangeQuantization(void);
+#endif // __SI_RX_INFO_H__
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_video_mode_detection.c b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_video_mode_detection.c
new file mode 100755
index 000000000000..99f76775174d
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_video_mode_detection.c
@@ -0,0 +1,1085 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#include "si_rx_video_mode_detection.h"
+#include "si_video_tables.h"
+#include "si_drv_rx_info.h"
+
+#include "si_cra.h"
+
+#include "si_drv_rx.h"
+
+#include "si_drv_rx_isr.h"
+
+#define NMB_OF_SAMPLES_TO_AVERAGE 8
+
+#define	FPIX_TOLERANCE		200	// in 10 kHz units, i.e. 100 means +-1MHz
+#define	FPIX_TOLERANCE_RANGE		10	// in 1/x, i.e. 10 means 10%
+#define	PIXELS_TOLERANCE	30	// should be no more then 55 to distinguish all CEA861C modes
+#define	LINES_TOLERANCE		15	// should be no more then 29 to distinguish all CEA861C modes
+
+#define	H_FREQ_TOLERANCE	2	// H Freq tolerance in kHz, used for analog video detection
+
+#define	FH_TOLERANCE	1	// H freq in 1 kHz units, used for range check
+#define	FV_TOLERANCE	2	// V Freq in 1 Hz units, used for range check
+
+#define ABS_DIFF(A, B) ((A>B) ? (A-B) : (B-A))
+
+
+typedef struct
+{
+#if defined(__KERNEL__)
+    SiiOsTimer_t videoStableTimer;
+#else
+    uint32_t    videoStableTime;
+#endif
+    bool_t      bReadyforVMD;
+	uint8_t		video_index;
+	uint8_t		cea861_vic;
+	uint8_t		hdmi_vic;
+	uint8_t		hdmi_3d_structure;
+	uint8_t		hdmi_3d_ext_data;
+	uint16_t	pix_freq; // pixel frequency in 10kHz units
+	bit_fld_t	avi_received : 1;
+	bit_fld_t	hdmi_3d_vsif_received : 1;
+	bit_fld_t	hdmi_vic_received : 1;
+} vmd_state_t;
+
+static vmd_state_t vmd_data = {0};
+
+
+uint8_t VMD_GetVideoIndex(void)
+{
+	return vmd_data.video_index;
+}
+
+static uint8_t search_861_mode(sync_info_type *p_sync_info)
+{
+	int i;
+	uint8_t detected_video_idx = SI_VIDEO_MODE_NON_STD;
+	int16_t range;
+
+	enum
+	{
+		not_found = 0,
+		found_not_exact = 1,
+		found_exact = 2
+	}
+	search_result = not_found;
+
+	for(i=0; VideoModeTable[i].Vic4x3 || VideoModeTable[i].Vic16x9; i++)
+	{
+		const videoMode_t *p_video_table = &VideoModeTable[i];
+		bool_t interlaced = p_sync_info->Interlaced;
+		uint16_t total_V_lines_measured =
+			(interlaced ?
+			(p_sync_info->TotalLines * 2)
+			: p_sync_info->TotalLines);
+
+		// check progressive/interlaced
+		if(interlaced != p_video_table->Interlaced)
+			continue;
+
+		// check number of lines
+		if(ABS_DIFF(total_V_lines_measured, p_video_table->Total.V) > LINES_TOLERANCE)
+			continue;
+
+		// check number of clocks per line (it works for all possible replications)
+		if(ABS_DIFF(p_sync_info->ClocksPerLine, p_video_table->Total.H) > PIXELS_TOLERANCE)
+			continue;
+
+		// check Pixel Freq (in 10kHz units)
+//		if(ABS_DIFF(p_sync_info->PixelFreq, p_video_table->PixClk) > FPIX_TOLERANCE)  // tolerance based on fixed bandwidth
+                if (0 != ABS_DIFF(p_sync_info->PixelFreq, p_video_table->PixClk))  // tolerance based on dynamic bandwidth (fixed ratio)
+                {
+                    range = p_video_table->PixClk / ABS_DIFF(p_sync_info->PixelFreq, p_video_table->PixClk);
+
+                    if( (range) < FPIX_TOLERANCE_RANGE)    // per PLL range
+                        continue;
+                }
+
+#if 0        // enable it for mode search tuning
+                DEBUG_PRINT(MSG_STAT,
+                "Index in table: %d, interlaced: %d, range: %d",
+                (int) i, (int) interlaced, (int)range);
+
+                DEBUG_PRINT(MSG_STAT,
+                "Pixel Freq detected: %d, Pixel Freq in video table: %d",
+                (int) p_sync_info->PixelFreq, (int) p_video_table->PixClk);
+
+                DEBUG_PRINT(MSG_STAT,
+                "clock per lines detected: %d, lines detected: %d",
+                (int) p_sync_info->ClocksPerLine, (int) total_V_lines_measured);
+
+                DEBUG_PRINT(MSG_STAT,
+                "clock per lines in video table: %d, lines in video table: %d\n",
+                (int) p_video_table->Total.H, (int) p_video_table->Total.V);
+#endif
+
+		// if all previous tests passed, then we found at least one mode even polarity is mismatched
+		if(search_result == not_found)
+		{
+			search_result = found_not_exact;
+			detected_video_idx = i;
+		}
+
+		// check exact number of lines
+		if(ABS_DIFF(total_V_lines_measured, p_video_table->Total.V) > 1)
+			continue;
+
+		// check polarities
+		if(
+			(p_sync_info->HPol == p_video_table->HPol) &&
+			(p_sync_info->VPol == p_video_table->VPol)
+			)
+		{
+			// if all previous checks passed
+			search_result = found_exact;
+			detected_video_idx = i;
+			break;
+		}
+	}
+
+	switch(search_result)
+	{
+	case not_found:
+		break;
+	case found_exact:
+		break;
+	case found_not_exact:
+		DEBUG_PRINT(MSG_STAT, ("RX: Warning: not exact video mode found\n"));
+		break;
+	}
+
+	return detected_video_idx;
+}
+
+
+static void verify_cea861vic(uint8_t vid_idx)
+{
+#if (SI_USE_DEBUG_PRINT == ENABLE)
+
+	if(vmd_data.avi_received)
+	{
+		uint8_t vic = vmd_data.cea861_vic;
+
+		if(
+			(0 != vic) && // if AVI with VIC has been received
+			(SI_VIDEO_MODE_NON_STD != vid_idx) // if resolution has been measured
+			)
+		{
+			uint8_t table_idx = vid_idx & ~SI_VIDEO_MODE_3D_RESOLUTION_MASK;
+			bool_t vic_correct = false;
+
+			if(table_idx < (NMB_OF_CEA861_VIDEO_MODES + NMB_OF_HDMI_VIDEO_MODES))
+			{
+				// verify VIC
+				vic_correct =
+					(VideoModeTable[table_idx].Vic4x3 == vic) ||
+					(VideoModeTable[table_idx].Vic16x9 == vic);
+			}
+
+			if(!vic_correct)
+			{
+				DEBUG_PRINT(MSG_STAT,
+					"RX: Warning: AVI carries incorrect VIC=%d for resolution Idx=%d\n",
+					(int) vic, (int) vid_idx);
+			}
+
+		}
+	}
+#endif // SI_USE_DEBUG_PRINT
+}
+
+static bool_t is_video_in_range(sync_info_type *p_sync_info)
+{
+	bool_t test_passed = false;
+
+	if( (p_sync_info->ClocksPerLine < 100) || (p_sync_info->TotalLines < 100) )
+	{
+		// Also prevents from devision by 0 in h_freq and v_freq calculations.
+		DEBUG_PRINT(MSG_STAT,
+			"RX: Unsuitable Video: %d clocks per line, %d total lines\n",
+			(int) p_sync_info->ClocksPerLine, (int) p_sync_info->TotalLines);
+	}
+	else
+	{
+		uint16_t pix_freq = p_sync_info->PixelFreq; // in 10kHz units
+		uint8_t h_freq = ((uint32_t) (((uint32_t)p_sync_info->PixelFreq) * 10 + 5))
+			/ p_sync_info->ClocksPerLine; // in 1 kHz units
+		uint16_t v_freq = (((uint32_t) h_freq) * 1000 + 500)
+			/ p_sync_info->TotalLines; // in 1 Hz units
+
+		if(pix_freq <= (((uint16_t) VIDEO__MAX_PIX_CLK_10MHZ)
+			* 1000 + FPIX_TOLERANCE))
+		{
+			if(
+				(h_freq + FH_TOLERANCE >= VIDEO__MIN_H_KHZ) &&
+				(h_freq <= (VIDEO__MAX_H_KHZ + FH_TOLERANCE))
+				) // in 1 kHz units
+			{
+				if(
+					(v_freq + FV_TOLERANCE >= VIDEO__MIN_V_HZ) &&
+					(v_freq <= VIDEO__MAX_V_HZ + FV_TOLERANCE)
+					)
+				{
+					test_passed = true;
+				}
+			}
+		}
+
+		if(!test_passed)
+		{
+			DEBUG_PRINT(MSG_STAT,
+				"RX: Out Of Range: Fpix=%d0 kHz Fh=%d00 Hz Fv=%d Hz\n",
+				(int) pix_freq, (int) h_freq, (int) v_freq);
+		}
+	}
+
+	return test_passed;
+}
+
+static void print_861_resolution(void)
+{
+#if (SI_USE_DEBUG_PRINT == ENABLE)
+	uint8_t vid_idx = vmd_data.video_index;
+	uint8_t vic4x3 = VideoModeTable[vid_idx].Vic4x3;
+	uint8_t vic16x9 = VideoModeTable[vid_idx].Vic16x9;
+	DEBUG_PRINT(MSG_STAT, ("RX: Measured CEA861 mode: "));
+	if(vic4x3 && vic16x9)
+	{
+		DEBUG_PRINT(MSG_STAT, "VIC %d/%d", (int) vic4x3, (int) vic16x9);
+	}
+	else if(vic4x3)
+	{
+		DEBUG_PRINT(MSG_STAT, "VIC %d", (int) vic4x3);
+	}
+	else if(vic16x9)
+	{
+		DEBUG_PRINT(MSG_STAT, "VIC %d", (int) vic16x9);
+	}
+	else
+	{
+		DEBUG_PRINT(MSG_STAT, "Internal Error");
+	}
+	DEBUG_PRINT(MSG_STAT, ", Idx = %d, ", (int) vid_idx);
+	DEBUG_PRINT(MSG_STAT, "%d x %d %c @ %d Hz\n",
+		(int) VideoModeTable[vid_idx].Active.H,
+		(int) VideoModeTable[vid_idx].Active.V,
+		VideoModeTable[vid_idx].Interlaced ? 'I' : 'P',
+		(int) VideoModeTable[vid_idx].VFreq );
+#endif // SI_USE_DEBUG_PRINT
+}
+
+
+static void print_3D_resolution(void)
+{
+#if (SI_USE_DEBUG_PRINT == ENABLE)
+	vmd_state_t *p_vmd = &vmd_data;
+	DEBUG_PRINT
+	(
+		MSG_STAT,
+		
+			"RX: 3D resolution VIC=0x%02X 3d_struct=0x%02X ext_data=0x%02X\n",
+			(int) p_vmd->cea861_vic,
+			(int) p_vmd->hdmi_3d_structure,
+			(int) p_vmd->hdmi_3d_ext_data
+		
+	);
+#endif // SI_USE_DEBUG_PRINT
+}
+
+static void print_hdmi_vic_resolution(void)
+{
+#if (SI_USE_DEBUG_PRINT == ENABLE)
+	uint8_t vid_idx = vmd_data.video_index;
+	DEBUG_PRINT(MSG_STAT, "RX: HDMI VIC: %d, Idx = %d, %d x %d %c @ %d Hz\n",
+		(int) VideoModeTable[vid_idx].HdmiVic,
+		(int) vid_idx,
+		(int) VideoModeTable[vid_idx].Active.H,
+		(int) VideoModeTable[vid_idx].Active.V,
+		VideoModeTable[vid_idx].Interlaced ? 'I' : 'P',
+		(int) VideoModeTable[vid_idx].VFreq );
+#endif // SI_USE_DEBUG_PRINT
+}
+
+static void save_sync_info(sync_info_type *p_sync_info)
+{
+	SiiRxTiming_t rxTiming;
+
+	rxTiming.videoIndex = vmd_data.video_index,
+	rxTiming.clocksPerLine = p_sync_info->ClocksPerLine,
+	rxTiming.totalLines = p_sync_info->TotalLines,
+	rxTiming.pixelFreq = p_sync_info->PixelFreq,
+	rxTiming.interlaced = p_sync_info->Interlaced,
+	rxTiming.hPol = p_sync_info->HPol,
+	rxTiming.vPol = p_sync_info->VPol,
+	rxTiming.hdmi3dStructure = vmd_data.hdmi_3d_structure,
+	rxTiming.extra3dData = vmd_data.hdmi_3d_ext_data;
+
+	// Update RX timing info
+	SiiDrvRxTimingInfoSet(&rxTiming);
+}
+
+static void clear_sync_info(void)
+{
+	SiiRxTiming_t rxTiming;
+	memset(&rxTiming, 0, sizeof(rxTiming));
+	rxTiming.videoIndex = SI_VIDEO_MODE_NON_STD;
+
+    // Update RX timing info
+	SiiDrvRxTimingInfoSet(&rxTiming);
+}
+
+// 3D timing depends not only on the CEA-861D VIC code, but also on a parameter
+// called 3D_Structure. This function corrects the timing according to the parameter.
+static void correct_sync_info_according_to_3d_mode(sync_info_type *p_sync_info)
+{
+	switch(vmd_data.hdmi_3d_structure)
+	{
+	case 0:	// Frame packing: progressive/interlaced
+		if(p_sync_info->Interlaced)
+		{
+			// One frame contains even and odd images
+			// and even it is interlaced ia a scaler perspective,
+			// it appears as progressive format for HDMI chip HW.
+			p_sync_info->TotalLines *= 2;
+			p_sync_info->Interlaced = false;
+		}
+		// no break here
+	case 2:	// Line alternative: progressive only
+	case 4:	// L + depth: progressive only
+		// multiply lines x2; multiply clock x2
+		p_sync_info->TotalLines *= 2;
+		p_sync_info->PixelFreq *= 2;
+		break;
+
+	case 1:	// Field alternative: interlaced only
+		// multiply clock x2
+		p_sync_info->PixelFreq *= 2;
+		break;
+
+	case 3:	// Side-by-Side (Full): progressive/interlaced
+		// multiply pixel x2; multiply clock x2
+		p_sync_info->ClocksPerLine *= 2;
+		p_sync_info->PixelFreq *= 2;
+		break;
+
+	case 5:	// L + depth + graphics + graphics-depth: progressive only
+		// multiply lines x4; multiply clock x4
+		p_sync_info->TotalLines *= 4;
+		p_sync_info->PixelFreq *= 4;
+		break;
+
+	default: // 2D timing compatible: progressive/interlaced
+		break;
+	}
+}
+
+static uint8_t get_video_index_from_hdmi_vsif(void)
+{
+	uint8_t detected_video_index = SI_VIDEO_MODE_NON_STD;
+
+	if(vmd_data.hdmi_vic_received)
+	{
+		uint8_t hdmi_vic = vmd_data.hdmi_vic;
+		if((hdmi_vic > 0) && (hdmi_vic <= LAST_KNOWN_HDMI_VIC))
+		{
+			detected_video_index = hdmiVicToVideoTableIndex[hdmi_vic];
+		}
+	}
+	else if(vmd_data.avi_received && vmd_data.hdmi_3d_vsif_received)
+	{
+		uint8_t cea_vic = vmd_data.cea861_vic;
+		if((cea_vic > 0) && (cea_vic <= LAST_KNOWN_CEA_VIC))
+		{
+			detected_video_index =
+				ceaVicToVideoTableIndex[cea_vic] | SI_VIDEO_MODE_3D_RESOLUTION_MASK;
+		}
+	}
+	return detected_video_index;
+}
+
+// This function takes video timing based information from the video timing table
+// and fills p_sync_info structure with this timing information for vid_idx video index.
+// Returnstrue on success, false on failure.
+// Note: Repetition is not taken in account by this function because the function
+// is used for 3D and HDMI VIC (4K2K) formats which do not use repetition
+// by HDMI 1.4a specification. Moreover, HDMI 1.4a does not specify how exactly treat
+// the formats with repetition. The function might require modification in the future
+// if such support is required.
+static bool_t fill_sync_info_from_video_table(sync_info_type *p_sync_info, uint8_t vid_idx)
+{
+	bool_t success = false;
+
+	if(vid_idx < (NMB_OF_CEA861_VIDEO_MODES + NMB_OF_HDMI_VIDEO_MODES))
+	{
+		const videoMode_t *p_video_table = &VideoModeTable[vid_idx];
+		p_sync_info->Interlaced = p_video_table->Interlaced;
+		p_sync_info->ClocksPerLine = p_video_table->Total.H;
+		p_sync_info->TotalLines = p_video_table->Total.V;
+		p_sync_info->PixelFreq = p_video_table->PixClk;
+		p_sync_info->HPol = p_video_table->HPol;
+		p_sync_info->VPol = p_video_table->VPol;
+		if(p_sync_info->Interlaced)
+		{
+			p_sync_info->TotalLines /= 2;
+		}
+		success = true;
+	}
+	return success;
+}
+
+// Returns detected video format index; fills structure pointed by p_sync_info.
+static uint8_t detect_video_resolution(sync_info_type *p_sync_info)
+{
+	uint8_t detected_video_idx = get_video_index_from_hdmi_vsif();
+	bool_t bb;
+
+	if(SI_VIDEO_MODE_NON_STD == detected_video_idx)
+	{
+		SiiDrvRxGetSyncInfo(p_sync_info);
+
+		if(is_video_in_range(p_sync_info))
+		{
+			detected_video_idx = search_861_mode(p_sync_info);
+
+			if(SI_VIDEO_MODE_NON_STD != detected_video_idx)
+			{
+				// CEA861 mode found
+				// Verify if VIC matches the format.
+				// If it does not match, an error message will be printed.
+				// Measured format has higher priority than AVI's VIC.
+				verify_cea861vic(detected_video_idx);
+			}
+			else
+			{
+				// Input does not much to any known CEA861 mode or 3D format.
+				// It can be considered as a PC mode
+				// if such compilation option is enabled.
+#if (SI_ALLOW_PC_MODES == ENABLE)
+				// In other words, consider any non- CEA-861D or non-3D
+				// format as a PC resolution if video timing parameters
+				// are within allowed range.
+				detected_video_idx = SI_VIDEO_MODE_PC_OTHER;
+#endif // SI_ALLOW_PC_MODES
+			}
+		}
+	}
+	else if(detected_video_idx & SI_VIDEO_MODE_3D_RESOLUTION_MASK)
+	{
+		// 3D video
+		if(fill_sync_info_from_video_table(p_sync_info,
+			(detected_video_idx & ~SI_VIDEO_MODE_3D_RESOLUTION_MASK)))
+		{
+			correct_sync_info_according_to_3d_mode(p_sync_info);
+			if(!is_video_in_range(p_sync_info))
+			{
+				// Input video is out of range, do not use it.
+				detected_video_idx = SI_VIDEO_MODE_NON_STD;
+			}
+		}
+		else
+		{
+			detected_video_idx = SI_VIDEO_MODE_NON_STD;
+		}
+	}
+	else if((detected_video_idx >= NMB_OF_CEA861_VIDEO_MODES)
+		&& (detected_video_idx < (NMB_OF_CEA861_VIDEO_MODES + NMB_OF_HDMI_VIDEO_MODES)))
+	{
+		// HDMI VIC resolutions (e.g. 4K2K)
+		if(fill_sync_info_from_video_table(p_sync_info, detected_video_idx))
+		{
+			if(!is_video_in_range(p_sync_info))
+			{
+				// Input video is out of range, do not use it.
+				detected_video_idx = SI_VIDEO_MODE_NON_STD;
+			}
+		}
+		else
+		{
+			detected_video_idx = SI_VIDEO_MODE_NON_STD;
+		}
+	}
+	else
+	{
+		// internal error case, should never happen
+		DEBUG_PRINT(MSG_ERR, "RX: Internal detection error\n");
+	}
+
+	return detected_video_idx;
+}
+
+#if defined(__KERNEL__)
+void VMD_VideoStableNotify(uint8_t vid_idx )
+{
+    #define MAX_REPORT_DATA_STRING_SIZE 20
+    uint8_t vic4x3, vic16x9;
+    char str[MAX_REPORT_DATA_STRING_SIZE];
+    
+    if (SI_VIDEO_MODE_NON_STD == vid_idx)
+    {
+        scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "out of range");
+    }else if (SI_VIDEO_MODE_PC_OTHER == vid_idx)
+    {
+        scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "pc resolution");
+    }else
+    {
+        vid_idx &= 0x7f;
+        if (vid_idx >= NMB_OF_CEA861_VIDEO_MODES)
+        {
+            scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "HDMI VIC %d", VideoModeTable[vid_idx].HdmiVic);
+        }
+        else
+        {
+            vic4x3 = VideoModeTable[vid_idx].Vic4x3;
+            vic16x9 = VideoModeTable[vid_idx].Vic16x9;
+            if (vic4x3 && vic16x9)
+                scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "CEA VIC %d %d", vic4x3, vic16x9);
+            else if (vic4x3)
+                scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "CEA VIC %d", vic4x3);
+            else if (vic16x9)
+                scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "CEA VIC %d", vic16x9);
+            else
+                scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "%s", "null");
+        }
+    }
+    sysfs_notify(&devinfo->device->kobj, NULL, "input_video_mode");
+    send_sii5293_uevent(devinfo->device, DEVICE_EVENT, DEV_INPUT_VIDEO_MODE_EVENT, str);
+}
+#endif
+
+// returns true if video format is detected, false otherwise
+bool_t VMD_DetectVideoResolution(void)
+{
+	bool_t format_detected = true;
+	sync_info_type sync_info;
+	uint8_t vid_idx;
+
+    if (vmd_data.bReadyforVMD)
+    {
+    	vid_idx = detect_video_resolution(&sync_info);
+    	vmd_data.video_index = vid_idx;
+
+#if defined(__KERNEL__)
+        gDriverContext.input_video_mode = vid_idx;
+        VMD_VideoStableNotify(vid_idx);
+#endif
+    	if(SI_VIDEO_MODE_NON_STD == vid_idx)
+    	{
+    		format_detected = false;
+    	}
+    	else if(SI_VIDEO_MODE_PC_OTHER == vid_idx)
+    	{
+    		DEBUG_PRINT(MSG_STAT, "RX: PC resolution\n");
+    	}
+    	else if(vid_idx & SI_VIDEO_MODE_3D_RESOLUTION_MASK)
+    	{
+    		print_3D_resolution();
+    	}
+    	else if(vid_idx >= NMB_OF_CEA861_VIDEO_MODES)
+    	{
+    		print_hdmi_vic_resolution();
+    	}
+    	else
+    	{
+    		// CEA-861D resolutions
+    		print_861_resolution();
+    	}
+
+    	if(format_detected)
+    	{
+    		vmd_data.pix_freq = sync_info.PixelFreq;
+    		save_sync_info(&sync_info);
+    	}
+    	else
+    	{
+    		VMD_ResetTimingData();
+    	}
+    }else
+    {
+        // Video is not stable, no need to dectect resolution
+        return false;
+    }
+
+	return format_detected;
+}
+
+void VMD_OnAviPacketReceiving(uint8_t cea861vic)
+{
+	vmd_data.avi_received = true;
+	vmd_data.cea861_vic = cea861vic;
+
+	verify_cea861vic(vmd_data.video_index);
+
+	if(vmd_data.hdmi_3d_vsif_received)
+	{
+		// 3D video detected
+		VMD_DetectVideoResolution();
+	}
+}
+
+void VMD_VsifProcessing(uint8_t *p_packet, uint8_t length)
+{
+       // check IEEE OUI first
+
+       // Check if it is HDMI VSIF, HDMI IEEE OUI is 0x000C03
+       if ( 0x03 == p_packet[0] && 0x0C == p_packet[1] && 0x00 == p_packet[2]  )
+       {
+           VMD_HdmiVsifProcessing(p_packet, length);
+           DEBUG_PRINT(MSG_STAT, "RX: HDMI VSIF found!\n");
+       }
+       // Check if it is MHL VSIF, MHL IEEE OUI is 0x7CA61D
+       else if ( 0x1D == p_packet[0] && 0xA6 == p_packet[1] && 0x7C == p_packet[2] )
+       {
+           VMD_MhlVsifProcessing(p_packet, length);
+           DEBUG_PRINT(MSG_STAT, "RX: MHL VSIF found!\n");
+       }
+
+}
+
+void VMD_HdmiVsifProcessing(uint8_t *p_packet, uint8_t length)
+{
+	// p_packet should point to an HDMI VSIF packet.
+	// No other VSIF packets are supported by this function.
+
+	uint8_t hdmi_video_format = p_packet[3] >> 5;
+
+	switch(hdmi_video_format)
+	{
+	case 1:	// Extended resolution format
+		vmd_data.hdmi_vic = p_packet[4];
+		vmd_data.hdmi_vic_received = true;
+
+		// Reset 3D info
+		// (HDMI 1.4 spec does not allow HDMI VIC & 3D at the same time)
+		vmd_data.hdmi_3d_structure = 0;
+		vmd_data.hdmi_3d_ext_data = 0;
+		vmd_data.hdmi_3d_vsif_received = false;
+
+		// HDMI VIC (4K2K) video detected.
+		// RX Video State Machine has to be informed
+		// as video re-detection may be required.
+		VMD_DetectVideoResolution();
+		break;
+	case 2:	// 3D format
+		// Get 3D structure field.
+		// Timing from VideoModeTable[] has to be modified
+		// depending on the 3d_Structure field.
+		// Store it for further processing.
+		vmd_data.hdmi_3d_structure = p_packet[4] >> 4;
+
+              // Configure GPIO as indicator only for Frame Packing in HDMI
+              if ( 0 == vmd_data.hdmi_3d_structure )
+              {
+                  RX_ConfigureGpioAs3dFrameIndicator();
+              }
+
+		// Side-by-Side (Half) has at least one additional parameter,
+		// collect it.
+		vmd_data.hdmi_3d_ext_data =
+			(vmd_data.hdmi_3d_structure >= 8) && (length > 4) ?
+			(p_packet[5] >> 4) : // has 3D_Ext_Data field
+			0;
+		vmd_data.hdmi_3d_vsif_received = true;
+
+		// Reset HDMI VIC info
+		// (HDMI 1.4 spec does not allow HDMI VIC & 3D at the same time)
+		vmd_data.hdmi_vic = 0;
+		vmd_data.hdmi_vic_received = false;
+
+		if(vmd_data.avi_received)
+		{
+			// 3D video detected.
+			// RX Video State Machine has to be informed
+			// as video re-detection may be required.
+			VMD_DetectVideoResolution();
+		}
+		break;
+	}
+}
+
+void VMD_MhlVsifProcessing(uint8_t *p_packet, uint8_t length)
+{
+	// p_packet should point to an HDMI VSIF packet.
+	// No other VSIF packets are supported by this function.
+	uint8_t mhl_video_format = p_packet[3] & 0x03;       // get the MHL_VID_FMT field
+	uint8_t mhl_3d_format_type;                                     // to keep the MHL_3D_FMT_TYPE field
+	bool_t bValid3DVsif = false;
+
+       // Check whether 3D format present
+       if ( 0x01 != mhl_video_format || length < 4 )
+       {
+           return;
+       }
+
+       mhl_3d_format_type = ( p_packet[3] & 0x3F ) >> 2;     // get the MHL_3D_FMT_TYPE field
+       
+	switch(mhl_3d_format_type)
+	{
+            case 0:     // Frame Sequential 3D Video
+                bValid3DVsif = true;        	
+                vmd_data.hdmi_3d_structure = 0x00;   // Store it for further processing.
+                vmd_data.hdmi_3d_ext_data = 0x00;   // Reset to Zero
+
+                // Configure GPIO as indicator only for Frame Sequential in MHL
+                RX_ConfigureGpioAs3dFrameIndicator();
+                break;     
+
+            case 1:     // Top-Bottom 3D Video
+                bValid3DVsif = true;        	
+                vmd_data.hdmi_3d_structure = 0x06;   // Store it for further processing.
+                vmd_data.hdmi_3d_ext_data = 0x00;   // Reset to Zero
+                break;
+
+            case 2:     // Left-Right 3D Video
+                bValid3DVsif = true;      	
+                vmd_data.hdmi_3d_structure = 0x08;   // Store it for further processing.
+
+                // one additional parameter, set to the default value 0001
+                vmd_data.hdmi_3d_ext_data = 0x01;
+                break;
+
+            default:
+                break;
+	}
+
+       if ( bValid3DVsif )
+       {
+		vmd_data.hdmi_3d_vsif_received = true;
+
+		// Reset HDMI VIC info
+		// (HDMI 1.4 spec does not allow HDMI VIC & 3D at the same time)
+		vmd_data.hdmi_vic = 0;
+		vmd_data.hdmi_vic_received = false;
+
+		if(vmd_data.avi_received)
+		{
+			// 3D video detected.
+			// RX Video State Machine has to be informed
+			// as video re-detection may be required.
+			VMD_DetectVideoResolution();
+		}
+        }
+       
+}
+
+vsif_check_result_t VMD_GetVsifPacketType(uint8_t *p_packet, uint8_t length)
+{
+	vsif_check_result_t packet_analysis = NOT_HDMI_VSIF;
+
+	// DEBUG_PRINT(MSG_ALWAYS, ("VMD_GetVsifPacketType \n"));
+
+	// Check HDMI VSIF signature.
+	// HDMI IEEE Registration Identifier is 0x000C03 (least significant byte first).
+	if((0x03 == p_packet[0]) && (0x0C == p_packet[1]) && (0x00 == p_packet[2]))
+	{
+		// HDMI VSIF signature is found.
+		// Check HDMI format.
+		packet_analysis = VMD_GetHdmiVsifPacketType(p_packet, length);
+	}
+	// Check MHL VSIF signature.
+	// MHL IEEE Registration Identifier is 0x7CA61D (least significant byte first).
+       // Check if it is MHL VSIF, MHL IEEE OUI is 
+	else if((0x1D == p_packet[0]) && (0xA6 == p_packet[1]) && (0x7C == p_packet[2]))
+	{
+		// MHL VSIF signature is found.
+		// Check MHL format.
+		packet_analysis = VMD_GetMhlVsifPacketType(p_packet, length);
+	}
+	else
+	{
+		DEBUG_PRINT(MSG_ALWAYS, ("No valid signature recognized\n"));
+       }
+
+	return packet_analysis;
+}
+
+vsif_check_result_t VMD_GetHdmiVsifPacketType(uint8_t *p_packet, uint8_t length)
+{
+	vsif_check_result_t packet_analysis = NOT_HDMI_VSIF;
+
+	// Check HDMI VSIF signature.
+	// HDMI IEEE Registration Identifier is 0x000C03 (least significant byte first).
+	if((0x03 == p_packet[0]) && (0x0C == p_packet[1]) && (0x00 == p_packet[2]))
+	{
+		// HDMI VSIF signature is found.
+		// Check HDMI format.
+
+		uint8_t hdmi_video_format = p_packet[3] >> 5;
+
+		switch(hdmi_video_format)
+		{
+		case 1:
+			// HDMI VIC format (extended resolution format)
+			packet_analysis = NEW_EXTENDED_RESOLUTION;
+			if(
+				vmd_data.hdmi_vic_received &&
+				(vmd_data.hdmi_vic == p_packet[4])
+				)
+			{
+				// HDMI VIC has been received and the new packet
+				// caries the same HDMI VIC.
+				packet_analysis = OLD_EXTENDED_RESOLUTION;
+			}
+			break;
+		case 2:
+			// 3D format.
+			if(vmd_data.hdmi_3d_vsif_received)
+			{
+				packet_analysis = OLD_3D;
+				// may be modified by the next few lines.
+
+				// Check if new 3D structure field matches
+				// previously received packet.
+				if(vmd_data.hdmi_3d_structure != p_packet[4] >> 4)
+				{
+					// 3D_Structure is different; the packet is new 3D.
+					packet_analysis = NEW_3D;
+				}
+				// Side-by-Side (Half) has at least one additional parameter.
+				// Check if it matches to the previously received one.
+				if((8 == vmd_data.hdmi_3d_structure) && (length > 4))
+				{
+					// 3D_Ext_Data field
+					if(vmd_data.hdmi_3d_ext_data != (p_packet[5] >> 4))
+					{
+						// 3D_Structure is different; the packet is new 3D.
+						packet_analysis = NEW_3D;
+					}
+				}
+			}
+			else
+			{
+				// First 3D packet receiving.
+				packet_analysis = NEW_3D;
+			}
+			break;
+		}
+	}
+	return packet_analysis;
+}
+
+vsif_check_result_t VMD_GetMhlVsifPacketType(uint8_t *p_packet, uint8_t length)
+{
+	vsif_check_result_t packet_analysis = NOT_HDMI_VSIF;
+
+	// Check MHL VSIF signature.
+	// MHL IEEE Registration Identifier is 0x7CA61D (least significant byte first).
+	if((0x1D == p_packet[0]) && (0xA6 == p_packet[1]) && (0x7C == p_packet[2]))
+	{
+		// MHL VSIF signature is found.
+		// Check MHL format.
+
+        	uint8_t mhl_video_format = p_packet[3] & 0x03;       // get the MHL_VID_FMT field
+        	uint8_t mhl_3d_format_type;                                     // to keep the MHL_3D_FMT_TYPE field
+
+               // Check whether 3D format present
+               if ( 0x01 != mhl_video_format || length < 4 )
+               {
+                   return packet_analysis;
+               }
+
+               mhl_3d_format_type = ( p_packet[3] & 0x3F ) >> 2;     // get the MHL_3D_FMT_TYPE field
+
+        	// Check if new 3D structure field matches
+        	// previously received packet. Assume there is no change
+              packet_analysis = OLD_3D;
+        	switch(mhl_3d_format_type)
+        	{
+                    case 0:     // Frame Sequential 3D Video
+                        if ( 0x00 != vmd_data.hdmi_3d_structure || false == vmd_data.hdmi_3d_vsif_received )
+                        {
+                            packet_analysis = NEW_3D;
+                        }
+                        break;     
+
+                    case 1:     // Top-Bottom 3D Video
+                        if ( 0x06 != vmd_data.hdmi_3d_structure )
+                        {
+                            packet_analysis = NEW_3D;
+                        }
+                        break;
+
+                    case 2:     // Left-Right 3D Video
+                        if ( 0x08 != vmd_data.hdmi_3d_structure )
+                        {
+                            packet_analysis = NEW_3D;
+                        }
+                        // FD: no need to worry about this per MHL 2.0 spec, there is only one value 0001 for Left-Right 3D Video
+                        /*
+                        // One more parameter to check for Left-Right 3D Video
+                        else if ( 0x01 != vmd_data[pipe].hdmi_3d_ext_data )
+                        {
+                        }
+                        */
+                        break;
+
+                    default:
+                        DEBUG_PRINT(MSG_ALWAYS, ("Unrecognized MHL 3D format type.\n"));
+                        break;
+        	}
+	}
+
+	return packet_analysis;
+}
+
+void VMD_OnHdmiVsifPacketDiscontinuation(void)
+{
+	// Forget HDMI VSIF data
+	vmd_data.hdmi_vic = 0;
+	vmd_data.hdmi_vic_received = false;
+	vmd_data.hdmi_3d_structure = 0;
+	vmd_data.hdmi_3d_ext_data = 0;
+	vmd_data.hdmi_3d_vsif_received = false;
+
+	// Changing from 3D/4K2K to non-3D/4K2K in most cases causes pixel clock interruption
+	// that change RX state machine's state. In this case no other processing is required.
+	// However, some 3D to 2D formats have compatible timings and it is possible
+	// skipping such transaction. This function is called when HDMI VSIF packets
+	// are no longer comming. That event may happen on 3D to 2D change.
+	// The function starts format verification.
+	VMD_DetectVideoResolution();
+}
+
+// This function is called from RX interrupt service routine to
+// measure current resolution and compare it with the current one.
+// If the resolutions differ, the function return true.
+// Otherwise it returns false.
+// Since the function is used for timing verification and the measured timing
+// data is not valid in 3D/HDMI_VIC mode, it always returns false if 3D/HDMI_VIC is detected.
+// PC resolutions always return true.
+bool_t VMD_WasResolutionChanged(void)
+{
+	sync_info_type sync_info;
+	uint8_t measured_video_idx = detect_video_resolution(&sync_info);
+	bool_t resolution_changed = false;
+
+	if(measured_video_idx == SI_VIDEO_MODE_PC_OTHER)
+	{
+		// PC resolutions.
+		// Since we do not keep the timing information for PC resolutions,
+		// assume that the resolution change event is real.
+		// It is acceptable because in most cases the false resolution
+		// change ocures due to deep color mode changing
+		// and the deep color is rarely used with PC resolutions.
+		// In the worst case when PC resolution is used with deep color,
+		// returning true on false resolution change will only delay
+		// the video at the sink.
+		resolution_changed = true;
+	}
+	if(measured_video_idx < NMB_OF_CEA861_VIDEO_MODES)
+	{
+		// CEA-861D resolutions only
+		uint8_t current_video_idx = vmd_data.video_index;
+		resolution_changed = (current_video_idx != measured_video_idx);
+	}
+	return resolution_changed;
+}
+
+void VMD_ResetTimingData(void)
+{
+#if defined(__KERNEL__)
+    gDriverContext.input_video_mode = 0;
+#endif
+    vmd_data.bReadyforVMD = false;
+    vmd_data.video_index = SI_VIDEO_MODE_NON_STD;
+    vmd_data.pix_freq = 0;
+    clear_sync_info();
+}
+#if defined(__KERNEL__)
+static void VMD_Timer_Callback(void *pArg)
+{
+    DEBUG_PRINT(MSG_STAT, ("Video stable timer expired.\n"));
+	vmd_data.bReadyforVMD = true;
+    VMD_DetectVideoResolution();
+    SiiDrvRxMuteVideo(OFF);
+}
+#else
+void SiiRxFormatDetect(void)
+{
+    if (vmd_data.videoStableTime)
+    {
+        //Wait 100ms after sync detect to determine the video resolution.
+        if (SiiTimerTotalElapsed() - vmd_data.videoStableTime > VIDEO_STABLE_TIME)
+        {
+            vmd_data.videoStableTime = 0;
+            vmd_data.bReadyforVMD = true;
+            VMD_DetectVideoResolution();
+            SiiDrvRxMuteVideo(OFF);
+        }
+    }
+}
+#endif
+void VMD_Init(void)
+{
+	memset(&vmd_data, 0, sizeof(vmd_state_t));
+	VMD_ResetTimingData();
+#if defined(__KERNEL__)
+    SiiOsTimerCreate("Vid Timer", VMD_Timer_Callback, NULL, &vmd_data.videoStableTimer);
+#endif
+}
+
+void VMD_ResetInfoFrameData(void)
+{
+	vmd_data.avi_received = false;
+	vmd_data.hdmi_3d_vsif_received = false;
+	vmd_data.hdmi_vic_received = false;
+}
+
+// Returns detected pixel frequency in 10 kHz units if video is detected
+// or zero otherwise.
+uint16_t VMD_GetPixFreq10kHz(void)
+{
+	return vmd_data.pix_freq;
+}
+
+void SiiRxSetVideoStableTimer(void)
+{
+    bool_t bScdtState = false;
+    if ( SiiDrvVidStableGet(&bScdtState) )
+    {
+        VMD_ResetTimingData();
+
+#if defined(__KERNEL__)
+        if (bScdtState)
+        {
+            SiiOsTimerStart(vmd_data.videoStableTimer, VIDEO_STABLE_TIME);
+        }
+        else
+        {
+            SiiDrvSoftwareReset(RX_M__SRST__HDCP_RST);      //Do HDCP reset when there's no scdt
+            SiiOsTimerStop(vmd_data.videoStableTimer);
+        }
+#else
+        if (bScdtState)
+        {
+            vmd_data.videoStableTime = SiiTimerTotalElapsed();
+        }
+        else
+        {
+            SiiDrvSoftwareReset(RX_M__SRST__HDCP_RST);
+            vmd_data.videoStableTime = 0;
+        }
+#endif
+    }
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief		Configure GPIO as 3D Frame Indicator
+ *
+ *****************************************************************************/
+void RX_ConfigureGpioAs3dFrameIndicator(void)
+{
+    SiiRegWrite( GPIO_MODE, VAL_GPIO_0_3D_INDICATOR );
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_video_mode_detection.h b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_video_mode_detection.h
new file mode 100755
index 000000000000..141ca39b9297
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/rx/si_rx_video_mode_detection.h
@@ -0,0 +1,81 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+
+#ifndef SII_VIDEOMODEDETECTION_H
+#define SII_VIDEOMODEDETECTION_H
+
+#include "si_common.h"
+// VMD_GetVsifPacketType() return type
+typedef enum
+{
+	NOT_HDMI_VSIF,			// VSIF packet is not HDMI VSIF
+	NEW_EXTENDED_RESOLUTION, // VSIF packet carries Extended Resolution info: first detection
+	OLD_EXTENDED_RESOLUTION, // VSIF packet carries Extended Resolution info: no change
+	NEW_3D,					// VSIF packet with 3D info: first detection
+	OLD_3D					// VSIF packet with 3D info: no change from last time
+}
+vsif_check_result_t;
+
+
+typedef	struct
+{
+	uint16_t	ClocksPerLine; // number of pixel clocks per line
+	uint16_t	TotalLines; // number of lines
+	uint16_t 	PixelFreq; // pixel frequency in 10kHz units
+	bit_fld_t	Interlaced	: 1; // true for interlaced video
+	bit_fld_t	HPol		: 1; // true on negative polarity for horizontal pulses
+	bit_fld_t	VPol		: 1; // true on negative polarity for vertical pulses
+}
+sync_info_type;
+
+#define VIDEO_STABLE_TIME 200
+
+void VMD_ResetTimingData(void);
+
+void VMD_ResetInfoFrameData(void);
+
+uint8_t VMD_GetVideoIndex(void);
+
+// returns true if video format is detected, false otherwise
+bool_t VMD_DetectVideoResolution(void);
+
+bool_t VMD_WasResolutionChanged(void);
+
+void VMD_OnAviPacketReceiving(uint8_t cea861vic);
+
+void VMD_VsifProcessing(uint8_t *p_packet, uint8_t length);
+
+void VMD_HdmiVsifProcessing(uint8_t *p_packet, uint8_t length);
+
+void VMD_MhlVsifProcessing(uint8_t *p_packet, uint8_t length);
+
+vsif_check_result_t VMD_GetVsifPacketType(uint8_t *p_packet, uint8_t length);
+
+vsif_check_result_t VMD_GetHdmiVsifPacketType(uint8_t *p_packet, uint8_t length);
+
+vsif_check_result_t VMD_GetMhlVsifPacketType(uint8_t *p_packet, uint8_t length);
+
+void VMD_OnHdmiVsifPacketDiscontinuation(void);
+
+void VMD_Init(void);
+
+uint16_t VMD_GetPixFreq10kHz(void);
+
+void SiiRxSetVideoStableTimer(void);
+
+#if !defined(__KERNEL__)
+void SiiRxFormatDetect(void);
+#endif
+
+void RX_ConfigureGpioAs3dFrameIndicator(void);
+
+#endif //SII_VIDEOMODEDETECTION_H
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/video_tables/si_video_tables.c b/drivers/amlogic/ext_hdmiin/sii9293/component/video_tables/si_video_tables.c
new file mode 100755
index 000000000000..eaa39128f57f
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/video_tables/si_video_tables.c
@@ -0,0 +1,177 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#include "si_video_tables.h"
+
+
+// Note: maximum audio frequency for 8 channels is not exact: see PixClc=54MHz
+
+ROM const videoMode_t VideoModeTable[NMB_OF_VIDEO_MODES + 1] =
+{
+  //{VIC, HVIC {H/V active}, {H/V  total},{H/V blank),{HVSyncO}, {HVSyncW},Fh , Fv , Fpix, Pclk, I/P , HPol, VPol, syst, repetition                  ,audio},
+  // CEA-861D video modes
+	{1,0  , 0, {640 , 480 }, {800 , 525 }, {160, 45}, {16 , 10}, {96 , 2}, 31 , 60 , 25 ,  2518, PROG, NEG,  NEG,  0   , RP1                         ,  48},
+	// 1, 480p60
+	{2,3  , 0, {720 , 480 }, {858 , 525 }, {138, 45}, {16 ,  9}, {62 , 6}, 31 , 60 , 27 ,  2700, PROG, NEG,  NEG,  NTSC, RP1                         ,  48},
+	// 2, 720p60
+	{0,4  , 0, {1280, 720 }, {1650, 750 }, {370, 30}, {110,  5}, {40 , 5}, 45 , 60 , 74 ,  7425, PROG, POS,  POS,  NTSC, RP1                         , 192},
+	// 3, 1080i60
+	{0,5  , 0, {1920, 1080}, {2200, 1125}, {280, 22}, {88 ,  2}, {44 , 5}, 34 , 60 , 74 ,  7425, INTL, POS,  POS,  NTSC, RP1                         , 192},
+	// 4, 480i60
+	{6,7  , 0, {1440, 480 }, {1716, 525 }, {276, 22}, {38 ,  4}, {124, 3}, 16 , 60 , 27 ,  2700, INTL, NEG,  NEG,  NTSC,     RP2                     ,  48},
+	{8,9  , 0, {1440, 240 }, {1716, 262 }, {276, 22}, {38 ,  4}, {124, 3}, 16 , 60 , 27 ,  2700, PROG, NEG,  NEG,  NTSC,     RP2                     ,  48},
+	{8,9  , 0, {1440, 240 }, {1716, 263 }, {276, 23}, {38 ,  5}, {124, 3}, 16 , 60 , 27 ,  2700, PROG, NEG,  NEG,  NTSC,     RP2                     ,  48},
+	{10,11, 0, {2880, 480 }, {3432, 525 }, {552, 22}, {76 ,  4}, {248, 3}, 16 , 60 , 54 ,  5400, INTL, NEG,  NEG,  NTSC,         RP4|RP5|RP7|RP8|RP10,  96},
+	{12,13, 0, {2880, 240 }, {3432, 262 }, {552, 22}, {76 ,  4}, {248, 3}, 16 , 60 , 54 ,  5400, PROG, NEG,  NEG,  NTSC,         RP4|RP5|RP7|RP8|RP10,  96},
+	{12,13, 0, {2880, 240 }, {3432, 263 }, {552, 23}, {76 ,  5}, {248, 3}, 16 , 60 , 54 ,  5400, PROG, NEG,  NEG,  NTSC,         RP4|RP5|RP7|RP8|RP10,  96},
+	{14,15, 0, {1440, 480 }, {1716, 525 }, {276, 45}, {32 ,  9}, {124, 6}, 31 , 60 , 54 ,  5400, PROG, NEG,  NEG,  NTSC, RP1|RP2                     ,  96},
+	// 11, 1080p60
+	{0,16,  0, {1920, 1080}, {2200, 1125}, {280, 45}, {88 ,  4}, {44 , 5}, 67 , 60 , 148, 14850, PROG, POS,  POS,  NTSC, RP1                         , 192},
+	// 12, 576p50
+	{17,18, 0, {720 , 576 }, {864 , 625 }, {144, 49}, {12 ,  5}, {64 , 5}, 31 , 50 , 27 ,  2700, PROG, NEG,  NEG,  PAL , RP1                         ,  48},
+	// 13, 720p50
+	{0,19,  0, {1280, 720 }, {1980, 750 }, {700, 30}, {440,  5}, {40 , 5}, 38 , 50 , 74 ,  7425, PROG, POS,  POS,  PAL , RP1                         , 192},
+	// 14, 1080i50
+	{0,20,  0, {1920, 1080}, {2640, 1125}, {720, 22}, {528,  2}, {44 , 5}, 28 , 50 , 74 ,  7425, INTL, POS,  POS,  PAL , RP1                         , 192},
+	// 15, 576i50
+	{21,22, 0, {1440, 576 }, {1728, 625 }, {288, 24}, {24 ,  2}, {126, 3}, 16 , 50 , 27 ,  2700, INTL, NEG,  NEG,  PAL ,     RP2                     ,  48},
+	{23,24, 0, {1440, 288 }, {1728, 312 }, {288, 24}, {24 ,  2}, {126, 3}, 16 , 50 , 27 ,  2700, PROG, NEG,  NEG,  PAL ,     RP2                     ,  48},
+	{23,24, 0, {1440, 288 }, {1728, 313 }, {288, 25}, {24 ,  3}, {126, 3}, 16 , 49 , 27 ,  2700, PROG, NEG,  NEG,  PAL ,     RP2                     ,  48},
+	{23,24, 0, {1440, 288 }, {1728, 314 }, {288, 26}, {24 ,  4}, {126, 3}, 16 , 49 , 27 ,  2700, PROG, NEG,  NEG,  PAL ,     RP2                     ,  48},
+	{25,26, 0, {2880, 576 }, {3456, 625 }, {576, 24}, {48 ,  2}, {252, 3}, 16 , 50 , 54 ,  5400, INTL, NEG,  NEG,  PAL ,         RP4|RP5|RP7|RP8|RP10,  96},
+	{27,28, 0, {2880, 288 }, {3456, 312 }, {576, 24}, {48 ,  2}, {252, 3}, 16 , 50 , 54 ,  5400, PROG, NEG,  NEG,  PAL ,         RP4|RP5|RP7|RP8|RP10,  96},
+	{27,28, 0, {2880, 288 }, {3456, 313 }, {576, 25}, {48 ,  3}, {252, 3}, 16 , 49 , 54 ,  5400, PROG, NEG,  NEG,  PAL ,         RP4|RP5|RP7|RP8|RP10,  96},
+	{27,28, 0, {2880, 288 }, {3456, 314 }, {576, 26}, {48 ,  4}, {252, 3}, 16 , 49 , 54 ,  5400, PROG, NEG,  NEG,  PAL ,         RP4|RP5|RP7|RP8|RP10,  96},
+	{29,30, 0, {1440, 576 }, {1728, 625 }, {288, 49}, {24 ,  5}, {128, 5}, 31 , 50 , 54 ,  5400, PROG, NEG,  POS,  PAL , RP1|RP2                     ,  96}, // H-neg, V-pos
+	// 24, 1080p50
+	{0,31,  0, {1920, 1080}, {2640, 1125}, {720, 45}, {528,  4}, {44 , 5}, 56 , 50 , 148, 14850, PROG, POS,  POS,  0   , RP1                         , 192},
+	{0,32,  0, {1920, 1080}, {2750, 1125}, {830, 45}, {638,  4}, {44 , 5}, 27 , 24 , 74 ,  7425, PROG, POS,  POS,  0   , RP1                         , 192},
+	{0,33,  0, {1920, 1080}, {2640, 1125}, {720, 45}, {528,  4}, {44 , 5}, 28 , 25 , 74 ,  7425, PROG, POS,  POS,  0   , RP1                         , 192},
+	{0,34,  0, {1920, 1080}, {2200, 1125}, {280, 45}, {88 ,  4}, {44 , 5}, 34 , 30 , 74 ,  7425, PROG, POS,  POS,  0   , RP1                         , 192},
+	{35,36, 0, {2880, 480 }, {3432, 525 }, {552, 45}, {96 ,  9}, {248, 6}, 31 , 60 , 108, 10800, PROG, NEG,  NEG,  NTSC, RP1|RP2|RP4                 , 192},
+	{37,38, 0, {2880, 576 }, {3456, 625 }, {576, 49}, {48 ,  5}, {256, 5}, 31 , 50 , 108, 10800, PROG, NEG,  NEG,  PAL , RP1|RP2|RP4                 , 192},
+	{0,39,  0, {1920, 1080}, {2304, 1250}, {384, 85}, {32 , 23}, {168, 5}, 31 , 50 , 72 ,  7200, INTL, POS,  NEG,  PAL , RP1                         , 192}, // H-pos, V-neg, 1,2 blanks are same = 85
+	{0,40,  0, {1920, 1080}, {2640, 1125}, {720, 22}, {528,  2}, {44 , 5}, 56 , 100, 148, 14850, INTL, POS,  POS,  PAL , RP1                         , 192},
+	{0,41,  0, {1280, 720 }, {1980, 750 }, {700, 30}, {440,  5}, {40 , 5}, 75 , 100, 148, 14850, PROG, POS,  POS,  PAL , RP1                         , 192},
+	{42,43, 0, {720 , 576 }, {864 , 625 }, {144, 49}, {12 ,  5}, {64 , 5}, 63 , 100, 54 ,  5400, PROG, NEG,  NEG,  PAL , RP1                         ,  96},
+	{44,45, 0, {1440, 576 }, {1728, 625 }, {288, 24}, {24 ,  2}, {126, 3}, 31 , 100, 54 ,  5400, INTL, NEG,  NEG,  PAL ,     RP2                     ,  96},
+	{0,46,  0, {1920, 1080}, {2200, 1125}, {280, 22}, {88 ,  2}, {44 , 5}, 68 , 120, 148, 14850, INTL, POS,  POS,  NTSC, RP1                         , 192},
+	{0,47,  0, {1280, 720 }, {1650, 750 }, {370, 30}, {110,  5}, {40 , 5}, 90 , 120, 148, 14850, PROG, POS,  POS,  NTSC, RP1                         , 192},
+	{48,49, 0, {720 , 480 }, {858 , 525 }, {138, 45}, {16 ,  9}, {62 , 6}, 63 , 120, 54 ,  5400, PROG, NEG,  NEG,  NTSC, RP1                         ,  96},
+	{50,51, 0, {1440, 480 }, {1716, 525 }, {276, 22}, {38 ,  4}, {124, 3}, 32 , 120, 54 ,  5400, INTL, NEG,  NEG,  NTSC,     RP2                     ,  96},
+	{52,53, 0, {720 , 576 }, {864 , 625 }, {144, 49}, {12 ,  5}, {64 , 5}, 125, 200, 108, 10800, PROG, NEG,  NEG,  PAL , RP1                         , 192},
+	{54,55, 0, {1440, 576 }, {1728, 625 }, {288, 24}, {24 ,  2}, {126, 3}, 63 , 200, 108, 10800, INTL, NEG,  NEG,  PAL ,     RP2                     , 192},
+	{56,57, 0, {720 , 480 }, {858 , 525 }, {138, 45}, {16 ,  9}, {62 , 6}, 126, 240, 108, 10800, PROG, NEG,  NEG,  NTSC, RP1                         , 192},
+	{58,59, 0, {1440, 480 }, {1716, 525 }, {276, 22}, {38 ,  4}, {124, 3}, 63 , 240, 108, 10800, INTL, NEG,  NEG,  NTSC,     RP2                     , 192},
+
+    // CEA-861E video modes
+	{ 0,60, 0, {1280, 720 }, {3300, 750 }, {2020,30}, {1760, 5}, { 40, 5}, 79 , 24 , 59 ,  5940, PROG, POS,  POS,  0   , RP1                         , 192},
+	{ 0,61, 0, {1280, 720 }, {3960, 750 }, {2680,30}, {2420, 5}, { 40, 5}, 99 , 25 , 74 ,  7425, PROG, POS,  POS,  PAL , RP1                         , 192},
+	{ 0,62, 0, {1280, 720 }, {3300, 750 }, {2020,30}, {1760, 5}, { 40, 5}, 91 , 30 , 74 ,  7425, PROG, POS,  POS,  NTSC, RP1                         , 192},
+	{ 0,63, 0, {1920, 1080}, {2200, 1125}, {280, 45}, {  88, 4}, { 44, 5},264 , 120, 297, 29700, PROG, POS,  POS,  NTSC, RP1                         , 192},
+	{ 0,64, 0, {1920, 1080}, {2640, 1125}, {720, 45}, { 528, 4}, { 44, 5},264 , 100, 297, 29700, PROG, POS,  POS,  PAL , RP1                         , 192},
+
+	// HDMI 1.4a video modes
+    {0,0  , 1, {3840, 2160}, {4400, 2250}, {560, 90}, {176 , 8}, {88 ,10}, 132,  30, 297, 29700, PROG, POS,  POS,  NTSC, RP1                         ,  96},
+    {0,0  , 2, {3840, 2160}, {5280, 2250}, {1440,90}, {1056, 8}, {88 ,10}, 132,  25, 297, 29700, PROG, POS,  POS,  PAL , RP1                         , 192},
+    {0,0  , 3, {3840, 2160}, {5500, 2250}, {1660,90}, {1276, 8}, {88 ,10}, 132,  24, 297, 29700, PROG, POS,  POS,  0   , RP1                         , 192},
+    {0,0  , 4, {4096, 2160}, {5500, 2250}, {1404,90}, {1020, 8}, {88 ,10}, 132,  24, 297, 29700, PROG, POS,  POS,  0   , RP1                         , 192}, // SMPTE (cannot be distinguished from #3)
+
+    {0,0  , 0, {0   , 0   }, {0   , 0   }, {0  , 0 }, {0  ,  0}, {0  , 0}, 0  , 0  , 0  ,     0, 0   , 0  ,  0  ,  0   , 0                           ,   0}
+};
+
+// It is not clear from CEA861C, where it is said at one place that formats 10...13 and 25...28 could have
+// repetition factors 4,5,7,8,10, but at the table 12 on page 76 it is said that the
+// factor could be any in 1...10 range...
+
+
+
+ROM const uint8_t ceaVicToVideoTableIndex[LAST_KNOWN_CEA_VIC + 1] =
+{
+	NMB_OF_CEA861_VIDEO_MODES, //no VIC (dummy, to start real indexes from 1, but not from 0)
+	0,  //VIC=1
+	1,  //VIC=2
+	1,  //VIC=3
+	2,  //VIC=4
+	3,  //VIC=5
+	4,  //VIC=6
+	4,  //VIC=7
+	5,  //VIC=8  Possible indexes: 5,6
+	5,  //VIC=9  Possible indexes: 5,6
+	7,  //VIC=10
+	7,  //VIC=11
+	8,  //VIC=12 Possible indexes: 8,9
+	8,  //VIC=13 Possible indexes: 8,9
+	10, //VIC=14
+	10, //VIC=15
+	11, //VIC=16
+	12, //VIC=17
+	12, //VIC=18
+	13, //VIC=19
+	14, //VIC=20
+	15, //VIC=21
+	15, //VIC=22
+	16, //VIC=23 Possible indexes: 16,17,18
+	16, //VIC=24 Possible indexes: 16,17,18
+	19, //VIC=25
+	19, //VIC=26
+	20, //VIC=27 Possible indexes: 20,21,22
+	20, //VIC=28 Possible indexes: 20,21,22
+	23, //VIC=29
+	23, //VIC=30
+	24, //VIC=31
+	25, //VIC=32
+	26, //VIC=33
+	27, //VIC=34
+	28, //VIC=35
+	28, //VIC=36
+	29, //VIC=37
+	29, //VIC=38
+	30, //VIC=39
+	31, //VIC=40
+	32, //VIC=41
+	33, //VIC=42
+	33, //VIC=43
+	34, //VIC=44
+	34, //VIC=45
+	35, //VIC=46
+	36, //VIC=47
+	37, //VIC=48
+	37, //VIC=49
+	38, //VIC=50
+	38, //VIC=51
+	39, //VIC=52
+	39, //VIC=53
+	40, //VIC=54
+	40, //VIC=55
+	41, //VIC=56
+	41, //VIC=57
+	42, //VIC=58
+	42, //VIC=59
+	43, //VIC=60
+	44, //VIC=61
+	45, //VIC=62
+	46, //VIC=63
+	47, //VIC=64
+};
+
+
+ROM const uint8_t  hdmiVicToVideoTableIndex[LAST_KNOWN_HDMI_VIC + 1] =
+{
+    // Not a VIC (dummy, to start real indexes from 1, but not from 0)
+    NMB_OF_VIDEO_MODES,
+
+    NMB_OF_CEA861_VIDEO_MODES + 0,  // HDMI VIC=1
+    NMB_OF_CEA861_VIDEO_MODES + 1,  // HDMI VIC=2
+    NMB_OF_CEA861_VIDEO_MODES + 2,  // HDMI VIC=3
+    NMB_OF_CEA861_VIDEO_MODES + 3,  // HDMI VIC=4
+};
+
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/component/video_tables/si_video_tables.h b/drivers/amlogic/ext_hdmiin/sii9293/component/video_tables/si_video_tables.h
new file mode 100755
index 000000000000..7ae92cd9c6a0
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/component/video_tables/si_video_tables.h
@@ -0,0 +1,139 @@
+//************************************************************************************************
+//! @file   si_video_tables.h
+//! @brief  Definition of standard video modes
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2002-2013, Silicon Image, Inc.  All rights reserved.
+//************************************************************************************************/
+
+#ifndef SI_VIDEO_TABLES_H
+#define SI_VIDEO_TABLES_H
+
+#include "si_common.h"
+
+typedef struct
+{
+	uint16_t	H; // Number of horizontal pixels
+	uint16_t	V; // Number of vertical pixels
+
+} sizesPix_t;
+
+typedef struct
+{
+    uint8_t     Vic4x3;     // CEA VIC for 4:3 picture aspect rate, 0 if not available
+    uint8_t     Vic16x9;    // CEA VIC for 16:9 picture aspect rate, 0 if not available
+    uint8_t     HdmiVic;    // HDMI VIC for 16:9 picture aspect rate, 0 if not available
+    sizesPix_t  Active;     // Number of active pixels
+    sizesPix_t  Total;      // Total number of pixels
+    sizesPix_t  Blank;      // Number of blank pixels
+    sizesPix_t  SyncOffset; // Offset of sync pulse
+    sizesPix_t  SyncWidth;  // Width of sync pulse
+    uint16_t    HFreq;      // in kHz
+    uint8_t     VFreq;      // in Hz
+    uint16_t    PixFreq;    // in MHz
+    uint16_t    PixClk;     // in 10kHz units
+    bit_fld_t   Interlaced :1; // true for interlaced video
+    bit_fld_t   HPol :1;    // true on negative polarity for horizontal pulses
+    bit_fld_t   VPol :1;    // true on negative polarity for vertical pulses
+    bit_fld_t   NtscPal :2; // 60/120/240Hz (false) or 50/100/200Hz (true) TVs
+    uint8_t     Repetition; // Allowed video pixel repetition
+    uint8_t     MaxAudioSR8Ch; // maximum allowed audio sample rate for 8 channel audio in kHz
+
+} videoMode_t;
+
+#define NMB_OF_CEA861_VIDEO_MODES   48
+#define NMB_OF_HDMI_VIDEO_MODES     4
+#define NMB_OF_VIDEO_MODES          (NMB_OF_CEA861_VIDEO_MODES + NMB_OF_HDMI_VIDEO_MODES)
+
+// repetition factor
+#define	RP1		0x01	// x1 (no repetition)
+#define	RP2		0x02	// x2 (doubled)
+#define	RP4		0x04	// x4
+#define	RP5		0x08	// x5
+#define	RP7		0x10	// x7
+#define	RP8		0x20	// x8
+#define	RP10	0x40	// x10
+
+#define	PROG	0	// progressive scan
+#define INTL	1	// interlaced scan
+#define	POS		0	// positive pulse
+#define	NEG		1	// negative pulse
+
+#define NTSC	1	// NTSC system (60Hz)
+#define PAL		2	// PAL system (50Hz)
+
+#define SI_VIDEO_MODE_NON_STD ((uint8_t) (-1)) //!< Non-standard video format ID
+#define SI_VIDEO_MODE_PC_OTHER ((uint8_t)(-2))
+#define SI_VIDEO_MODE_3D_RESOLUTION_MASK 0x80
+
+
+extern ROM const videoMode_t VideoModeTable[NMB_OF_VIDEO_MODES + 1];
+
+#define LAST_KNOWN_HDMI_VIC 4
+extern ROM const uint8_t hdmiVicToVideoTableIndex[LAST_KNOWN_HDMI_VIC + 1];
+
+#define LAST_KNOWN_CEA_VIC	64
+extern ROM const uint8_t ceaVicToVideoTableIndex[LAST_KNOWN_CEA_VIC + 1];
+
+// indexes in ceaVicToVideoTableIndex[]
+typedef enum
+{
+	vm1_640x480p = 0,			//0
+	vm2_3_720x480p,				//1
+	vm4_1280x720p,				//2
+	vm5_1920x1080i,				//3
+	vm6_7_720_1440x480i,		//4
+	vm8_9_720_1440x240p_1,		//5
+	vm8_9_720_1440x240p_2,		//6
+	vm10_11_2880x480i,			//7
+	vm12_13_2880x240p_1,		//8
+	vm12_13_2880x240p_2,		//9
+	vm14_15_1440x480p,			//10
+	vm16_1920x1080p,			//11
+	vm17_18_720x576p,			//12
+	vm19_1280x720p,				//13
+	vm20_1920x1080i,			//14
+	vm21_22_720_1440x576i,		//15
+	vm23_24_720_1440x288p_1,	//16
+	vm23_24_720_1440x288p_2,	//17
+	vm23_24_720_1440x288p_3,	//18
+	vm25_26_2880x576i,			//19
+	vm27_28_2880x288p_1,		//20
+	vm27_28_2880x288p_2,		//21
+	vm27_28_2880x288p_3,		//22
+	vm29_30_1440x576p,			//23
+	vm31_1920x1080p,			//24
+	vm32_1920x1080p,			//25
+	vm33_1920x1080p,			//26
+	vm34_1920x1080p,			//27
+	vm35_36_2880x480p,			//28
+	vm37_38_2880x576p,			//29
+	vm39_1920x1080i_1250_total,	//30
+	vm40_1920x1080i,			//31
+	vm41_1280x720p,				//32
+	vm42_43_720x576p,			//33
+	vm44_45_720_1440x576i,		//34
+	vm46_1920x1080i,			//35
+	vm47_1280x720p,				//36
+	vm48_49_720x480p,			//37
+	vm50_51_720_1440x480i,		//38
+	vm52_53_720x576p,			//39
+	vm54_55_720_1440x576i,		//40
+	vm56_57_720x480p,			//41
+	vm58_59_720_1440x480i,		//42
+
+	vm60_12800x720p,			//43
+	vm61_12800x720p,			//44
+	vm62_12800x720p,			//45
+	vm63_19200x1080p,			//46
+	vm64_19200x1080p,			//47
+
+	vm_numVideoModes
+} videoFormatId_t;
+
+
+#endif // SI_VIDEO_TABLES_H
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_cs4384_registers.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_cs4384_registers.h
new file mode 100755
index 000000000000..820122c70f09
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_cs4384_registers.h
@@ -0,0 +1,27 @@
+//***************************************************************************
+//!file     si_cs4384_registers.h
+//!brief    4384 Device Register Manifest Constants.
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2007-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+#ifndef __SI_CS4384_REGISTERS_H__
+#define __SI_CS4384_REGISTERS_H__
+
+#include "si_drv_cra_cfg.h"
+
+//------------------------------------------------------------------------------
+// Registers in Page F      (0x30)
+//------------------------------------------------------------------------------
+
+#define CS_4384_CTRL1            (PP_PAGE_AUDIO | 0x02)
+#define CS_4384_CTRL2            (PP_PAGE_AUDIO | 0x03)
+#define CS_4384_CTRL3            (PP_PAGE_AUDIO | 0x05)
+
+#endif  // __SI_CS4384_REGISTERS_H__
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_board.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_board.c
new file mode 100755
index 000000000000..71a649f35374
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_board.c
@@ -0,0 +1,162 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#include "si_drv_board.h"
+#include "si_drv_cra_cfg.h"
+
+#if (FPGA_BUILD_NEW == 1)
+    // # define
+#else
+#if !defined(__KERNEL__)
+#include "si_starterkit.h"
+#endif
+#include "si_cs4384_registers.h"
+#endif
+
+bool_t bSpdif = false;
+bool_t bTdm = false;
+bool_t bExternalTxHdmi = false;
+
+
+/*****************************************************************************/
+/**
+ *  @brief		Board Initialization
+ *
+ *  @return	Status
+ *  @retval	true		Success
+ *  @retval	false		Failure
+ *
+ *****************************************************************************/
+ bool_t SiiDrvBoardInit(void)
+{
+    bool_t  success = true;
+
+
+    // Starter Kit Board
+    bool_t gpio_sw3_1 = false;
+    bool_t gpio_sw3_2 = false;
+    bool_t gpio_sw3_3 = false;
+    bool_t gpio_sw3_4 = false;
+
+    gpio_sw3_1 = !SiiGpioRead(GPIO_SW3_1);
+    gpio_sw3_2 = !SiiGpioRead(GPIO_SW3_2);
+    gpio_sw3_3 = !SiiGpioRead(GPIO_SW3_3);
+    gpio_sw3_4 = !SiiGpioRead(GPIO_SW3_4);
+
+    DEBUG_PRINT( MSG_ALWAYS, "GPIO SW3 BIT 1 (TDM-ON / I2S-OFF): %s\n", gpio_sw3_1 ? "On" : "Off" );
+    DEBUG_PRINT( MSG_ALWAYS, "GPIO SW3 BIT 2 (S/PDIF): %s\n", gpio_sw3_2 ? "On" : "Off" );
+    DEBUG_PRINT( MSG_ALWAYS, "GPIO SW3 BIT 3: %s\n", gpio_sw3_3 ? "On" : "Off" );
+    DEBUG_PRINT( MSG_ALWAYS, "GPIO SW3 BIT 4: %s\n", gpio_sw3_4 ? "On" : "Off" );
+
+    bSpdif = gpio_sw3_2;
+    bTdm = gpio_sw3_1;
+
+
+#if 0
+    if ( bSpdif )
+    {
+        // Pass through, no codec used, do nothing
+    }
+    else if (bTdm)
+    {
+        // Use codec for TDM 8 channels
+        SiiRegWrite( CS_4384_CTRL1, 0x80 );
+        SiiRegWrite( CS_4384_CTRL2, 0xc3 );
+        SiiRegWrite( CS_4384_CTRL3, 0x00 );
+    }
+    else
+    {
+        // Use codec for I2S 2 channels
+        SiiRegWrite( CS_4384_CTRL1, 0x80 );
+        SiiRegWrite( CS_4384_CTRL2, 0x13 );
+        SiiRegWrite( CS_4384_CTRL3, 0x00 );
+    }
+#endif
+
+    return( success );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Board LED Control
+ *  @param[in]      ledIndex	index to LED to be controlled
+ *  @param[in]      bOn		true to turn on LED; false to turn off
+ *
+ *****************************************************************************/
+void SiiLedControl(uint8_t ledIndex, bool_t bOn)
+{
+#if !defined(__KERNEL__)
+    SkPlatformStarterKitLedControl(ledIndex, bOn);
+#endif
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Board GPIO Control
+ *  @param[in]      gpioIndex		index to GPIO to be controlled
+ *  @param[in]      bOn			true to turn on; false to turn off
+ *
+ *****************************************************************************/
+void SiiGpioControl(uint8_t gpioIndex, bool_t bOn)
+{
+#if !defined(__KERNEL__)
+    SkPlatformStarterKitGpioControl(gpioIndex, bOn);
+#else
+    HalGpioSetPin(gpioIndex, bOn);
+#endif
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Board GPIO Read
+ *  @param[in]      gpioIndex		index to GPIO to be read
+ *
+ *  @return	Status
+ *  @retval	true		On
+ *  @retval	false		Off
+ *
+ *****************************************************************************/
+bool_t SiiGpioRead(uint8_t gpioIndex)
+{
+#if !defined(__KERNEL__)
+    return SkPlatformStarterKitGpioRead(gpioIndex);
+#else
+    return true;
+#endif
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Board SPDIF Switch Status
+ *
+ *  @return	Status
+ *  @retval	true		On
+ *  @retval	false		Off
+ *
+ *****************************************************************************/
+bool_t SiiSpdifEnableGet()
+{
+    //return bSpdif;
+    return true;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Board TDM Switch Status
+ *
+ *  @return	Status
+ *  @retval	true		On
+ *  @retval	false		Off
+ *
+ *****************************************************************************/
+bool_t SiiTdmEnableGet()
+{
+    return bTdm;
+}
\ No newline at end of file
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_board.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_board.h
new file mode 100755
index 000000000000..f06be6f54934
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_board.h
@@ -0,0 +1,72 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+
+#ifndef SII_DRV_BOARD_H
+#define SII_DRV_BOARD_H
+
+#include "si_common.h"
+
+#if !defined(__KERNEL__)
+#define GPIO_RST                            GPIO_ID_P0_1
+#endif
+#define GPIO_AUD_RST                        GPIO_ID_P0_2
+#define GPIO_SW3_5                          GPIO_ID_P0_4
+#define GPIO_SW3_6                          GPIO_ID_P0_5
+#define GPIO_SW3_7                          GPIO_ID_P0_6
+#define GPIO_SW3_8                          GPIO_ID_P0_7
+
+#define GPIO_SW3_1                          GPIO_SW3_8
+#define GPIO_SW3_2                          GPIO_SW3_7
+#define GPIO_SW3_3                          GPIO_SW3_6
+#define GPIO_SW3_4                          GPIO_SW3_5
+
+enum
+{
+    LED_ID_GREEN = 0x00,
+    LED_ID_AMBER = 0x01,
+    LED_ID_2 = 0x02,
+    LED_ID_3 = 0x03,
+};
+
+enum
+{
+    GPIO_ID_P0_0 = 0x00,
+    GPIO_ID_P0_1,
+    GPIO_ID_P0_2,
+    GPIO_ID_P0_3,
+    GPIO_ID_P0_4,
+    GPIO_ID_P0_5,
+    GPIO_ID_P0_6,
+    GPIO_ID_P0_7,
+
+    GPIO_ID_P2_0,
+    GPIO_ID_P2_1, 
+    GPIO_ID_P2_2,
+    GPIO_ID_P2_3, 
+    GPIO_ID_P2_4,
+    GPIO_ID_P2_5, 
+    GPIO_ID_P2_6,
+    GPIO_ID_P2_7, 
+};
+
+bool_t SiiDrvBoardInit(void);
+
+void SiiLedControl(uint8_t ledIndex, bool_t bOn);
+
+void SiiGpioControl(uint8_t gpioIndex, bool_t bOn);
+
+bool_t SiiGpioRead(uint8_t gpioIndex);
+
+bool_t SiiSpdifEnableGet(void);
+
+bool_t SiiTdmEnableGet(void);
+
+#endif // SII_DRV_BOARD_H
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_evita.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_evita.c
new file mode 100755
index 000000000000..9ceb358b70f7
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_evita.c
@@ -0,0 +1,171 @@
+//------------------------------------------------------------------------------
+// Project: 5293
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#include "si_drv_cra_cfg.h"
+#include "si_drv_evita.h"
+#include "si_drv_rx.h"
+#include "si_rx_info.h"
+
+bool_t SiiDrvEvitaInit(void)
+{
+    // Evita chip Configuration
+    // HDMI Mode
+    bool_t  success = true;
+    SiiRegWrite(PP_PAGE_3 | 0x48, 0x00); //color space setting
+    SiiRegWrite(PP_PAGE_3 | 0x49, 0x00); //output color space YCbCr
+    SiiRegWrite(PP_PAGE_3 | 0x4A, 0x00); //video mode converter
+
+    SiiRegWrite(PP_PAGE_4 | 0x3C, 0x00); //bring out of core iso mode	
+    SiiRegWrite(PP_PAGE_3 | 0x08, 0x35); //power up chip
+    SiiRegWrite(PP_PAGE_3 | 0x0F, 0x00); //Diaable HDCP
+    SiiRegWrite(PP_PAGE_3 | 0x0D, 0x02); //Audio Mute
+
+    SiiRegWrite(PP_PAGE_4 | 0x02, 0x01); //MCLK =256*Fs
+    SiiRegWrite(PP_PAGE_4 | 0x03, 0x00); //Set N value [7:0] bit
+    SiiRegWrite(PP_PAGE_4 | 0x04, 0x18); //Set N value  [15:8] bit
+    SiiRegWrite(PP_PAGE_4 | 0x05, 0x00); //Set N value [19:16] bit
+
+    SiiRegWrite(PP_PAGE_4 | 0x21, 0x02); //set 48khz Fs
+    SiiRegWrite(PP_PAGE_4 | 0x22, 0x0B); //set 24-bit bus width
+    SiiRegWrite(PP_PAGE_4 | 0x23, 0x10);
+    SiiRegWrite(PP_PAGE_4 | 0x24, 0x0B); //set 24-bit I2S bus width
+    SiiRegWrite(PP_PAGE_4 | 0x1D, 0x40); //set I2S bus format
+    SiiRegWrite(PP_PAGE_4 | 0x14, 0xF1); //Enable 8-ch I2S input 
+    SiiRegWrite(PP_PAGE_4 | 0x1C, 0xE4); //Assign the SD0,1,2,3 FIFO
+    SiiRegWrite(PP_PAGE_4 | 0x2F, 0x03); //enable hdmi mode	
+
+    SiiRegWrite(PP_PAGE_3 | 0x0D, 0x00); //Disable Audio Mute
+
+    SiiRegWrite(PP_PAGE_4 | 0xDF, 0x10); //Clear AVMUT flag
+    SiiRegWrite(PP_PAGE_4 | 0x3E, 0x33); //Enable the ,AVI,AUD infoFrame Packet each frame
+    SiiRegWrite(PP_PAGE_4 | 0x3F, 0x0C); //Enable the ,General CTL infoFrame Packet each frame
+    SiiRegWrite(PP_PAGE_3 | 0x0F, 0x01); //Enable HDCP
+
+    SiiRegWrite(PP_PAGE_3 | 0xC7, 0x00); //Enter HW TPI mode
+    SiiRegWrite(PP_PAGE_3 | 0x1A, 0x01); //Turn TMDS on
+
+    return success;
+}
+
+
+void SiiDrvEvitaAviIfUpdate(void)
+{
+	uint8_t i, checksum;
+    VideoPath_t inVideoPath = SiiDrvRxGetOutVideoPath();
+    color_space_type csType;
+    uint8_t ifData[17];
+    bool_t YcMuxFlag = false;
+
+    if (inVideoPath == PATH__RGB)
+    {
+        csType = ColorSpace_RGB;
+    }
+    else if (inVideoPath == PATH__YCbCr444)
+    {
+        csType = ColorSpace_YCbCr444;
+    }
+    else
+    {
+        csType = ColorSpace_YCbCr422;
+    }
+
+    ifData[0] = 0x82;       //type
+    ifData[1] = 0x02;       //version
+    ifData[2] = 0x0D;       //length
+    ifData[3] = 0x00;       //checksum
+    ifData[4] = csType << 5; 
+    ifData[5] = 0x08;       //colorimetry;
+    if (csType == ColorSpace_RGB)
+    {
+        ifData[6] = 0x08;       // 0x08: full range, 0x04: limited range, only for RGB
+    }
+    else
+    {
+        ifData[6] = 0;
+    }
+    ifData[7] = RxAVI_GetVic();
+    ifData[8] = 0x00;       //0x00: limited range, 0x40: full range, only for YCbCr
+
+    if (RxAVI_GetReplication())
+    {
+        switch (inVideoPath)
+        {
+            case PATH__YCbCr422_MUX8B_SYNC:
+            case PATH__YCbCr422_MUX10B_SYNC:
+            case PATH__YCbCr422_MUX8B:
+            case PATH__YCbCr422_MUX10B:
+                YcMuxFlag = true;
+                ifData[8] |= 0x01;  //Set repetition in the infoframe
+                break;
+            default:
+                break;
+    }
+    }
+
+    ifData[9] = 0x00;
+    ifData[10] = 0x00; 
+    ifData[11] = 0x00;
+    ifData[12] = 0x00; 
+    ifData[13] = 0x00;
+    ifData[14] = 0x00;
+    ifData[15] = 0x00; 
+    ifData[16] = 0x00;
+
+    checksum = 0x00;
+    for (i = 0; i < 17; i++)
+    {
+        checksum += ifData[i];
+    }
+    ifData[3] = 0x100 - checksum;
+	// Fill AVI InfoFrame in TPI mode
+	for (i = 0; i < 14; i++)
+ 	{
+ 		SiiRegWrite(PP_PAGE_3  | (0x0C + i), ifData[i+3]);
+//		DEBUG_PRINT(MSG_ALWAYS, ("Configure Evita AVI InfoFrame byte %2X to %2X\n", (int)i, (int)(*pPacket[i+IF_HEADER_LENGTH-1])));
+ 	}
+
+	// Check whether trigger is already active
+	if ( 0x19 >= 0x0C + i )
+	{
+		SiiRegWrite(PP_PAGE_3  | 0x19, 0x00);
+		DEBUG_PRINT(MSG_ALWAYS, ("Configure Evita AVI InfoFrame, force trigger here\n"));
+	}
+
+    // This bit will reset when overwrite infoframe
+    if (YcMuxFlag)
+    {
+        SiiRegModify(PP_PAGE_3 | 0x60, BIT5, SET_BITS); //Enable YC de MUX
+    }
+}
+
+void SiiDrvEvitaAudioIfUpdate(uint8_t *pPacket)
+{
+	uint8_t i = 0;
+	uint8_t data_length = pPacket[IF_LENGTH_INDEX];
+
+
+        SiiRegWrite(PP_PAGE_3  | 0xBF, 0xD2);
+
+	// Fill AUDIO InfoFrame in TPI mode
+	for (i = 0; i < IF_MAX_AUDIO_LENGTH+1 && i < data_length+1; i++)
+ 	{
+ 		SiiRegWrite(PP_PAGE_3  | (0xC0 + i), pPacket[i]);
+//		DEBUG_PRINT(MSG_ALWAYS, ("Configure Evita AUDIO InfoFrame byte %2X to %2X\n", (int)i, (int)(*pPacket[i+IF_HEADER_LENGTH-1])));
+ 	}
+
+	// Check whether trigger is already active
+	if ( 0xCD >= 0xC0 + i )
+	{
+		SiiRegWrite(PP_PAGE_3  | 0xCD, 0x00);
+		DEBUG_PRINT(MSG_ALWAYS, ("Configure Evita ADUIO InfoFrame, force trigger here\n"));
+	}
+
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_evita.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_evita.h
new file mode 100755
index 000000000000..02083d3f5004
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/board_drv/si_drv_evita.h
@@ -0,0 +1,23 @@
+//------------------------------------------------------------------------------
+// Project: 5293
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+
+#ifndef SII_DRV_EVITA_H
+#define SII_DRV_EVITA_H
+
+#include "si_common.h"
+
+bool_t SiiDrvEvitaInit(void);
+
+void SiiDrvEvitaAviIfUpdate(void);
+
+void SiiDrvEvitaAudioIfUpdate(uint8_t *pPacket);
+
+#endif // SII_DRV_EVITA_H
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_drv_cbus.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_drv_cbus.c
new file mode 100755
index 000000000000..eb96f2984946
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_drv_cbus.c
@@ -0,0 +1,854 @@
+/******************************************************************************/
+//!file     si_drv_cbus.c
+//!brief    SiI5293 CBUS Driver.
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2007-2013, Silicon Image, Inc.  All rights reserved.
+/******************************************************************************/
+
+#include "si_common.h"
+#include "si_drv_cbus.h"
+#include "si_cbus_enums.h"
+#include "si_drv_device.h"
+#include "si_drv_board.h"
+
+#include "si_edid_3d_internal.h"
+
+
+#ifdef MHAWB_SUPPORT
+#include "../mhawb_drv/si_drv_mhawb.h"
+#include "../mhawb_drv/si_drv_hawb.h"
+#endif
+
+#define HDMI_3D_SVD_SUPPORT                                  // comment this out if the sink doesn't support 3D
+#define HDMI_SVD_STRUCTURE_LENGTH_EDID      17  // number of VIC entries in EDID (should be updated per application)
+
+ROM Mandatory3dFmt_t Mandatory_60[Mandatory3dFmt_60] = { {{VIC_1080P_24, 0}, {FRAME_SEQUENTIAL|TOP_BOTTOM}}, 
+                                                         {{VIC_720P_60, 0} , {FRAME_SEQUENTIAL|TOP_BOTTOM}},
+                                                         {{VIC_1080i_60, 0}, {LEFT_RIGHT}}
+                                                         };
+
+ROM Mandatory3dFmt_t Mandatory_50[Mandatory3dFmt_50] = { {{VIC_1080P_24, 0}, {FRAME_SEQUENTIAL|TOP_BOTTOM}}, 
+                                                         {{VIC_720P_50, 0},  {FRAME_SEQUENTIAL|TOP_BOTTOM}},
+                                                         {{VIC_1080i_50, 0}, {LEFT_RIGHT}}
+                                                         };
+
+
+VIC3DFormat_t VIC3DFormats[HDMI_3D_SVD_STRUCTURE_LENGTH] = {{0},};
+
+CbusDrvInstanceData_t cbusDrvInstance;
+CbusDrvInstanceData_t *pDrvCbus = &cbusDrvInstance;
+
+static uint16_t cbusInitCbusRegsList [] =
+{
+    REG_CBUS_DEVICE_CAP_0,        MHL_DEV_STATE,
+    REG_CBUS_DEVICE_CAP_1,        MHL_MHL_VERSION,
+    REG_CBUS_DEVICE_CAP_2,        MHL_DEV_CAT,
+    REG_CBUS_DEVICE_CAP_3,        MHL_ADOPTER_ID_H,
+    REG_CBUS_DEVICE_CAP_4,        MHL_ADOPTER_ID_L,
+    REG_CBUS_DEVICE_CAP_5,        MHL_VID_LINK_MODE,
+    REG_CBUS_DEVICE_CAP_6,        MHL_AUD_LINK_MODE,
+    REG_CBUS_DEVICE_CAP_7,        MHL_VIDEO_TYPE,
+    REG_CBUS_DEVICE_CAP_8,        MHL_LOG_DEV_MAP,
+    REG_CBUS_DEVICE_CAP_9,        MHL_BANDWIDTH,
+    REG_CBUS_DEVICE_CAP_A,        MHL_FEATURE_FLAG,
+    REG_CBUS_DEVICE_CAP_B,        MHL_DEVICE_ID_H,
+    REG_CBUS_DEVICE_CAP_C,        MHL_DEVICE_ID_L,
+    REG_CBUS_DEVICE_CAP_D,        MHL_SCRATCHPAD_SIZE,
+    REG_CBUS_DEVICE_CAP_E,        MHL_INT_STAT_SIZE,
+    REG_CBUS_DEVICE_CAP_F,        MHL_RESERVED,
+    REG_CBUS_LNK_CNTL_8,               0x14,
+};
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns the CBus register value
+ *
+ *  @param[in]        regAddr        register address, channel
+ *
+ *  @return    register value
+ *
+ *****************************************************************************/
+uint8_t  SiiDrvCbusDevCapsRegisterGet ( uint16_t offset )
+{
+    uint8_t value;
+
+    value = SiiRegRead( REG_CBUS_DEVICE_CAP_0 + offset );
+    return ( value );
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns interrupt flag
+ *
+ *  @return    interrupt flag
+ *
+ *****************************************************************************/
+ bool_t  SiiDrvCbusIntrFlagGet()
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_INT )
+    {
+        return( true );
+    }
+    return( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        reset interrupt flags
+ *
+ *****************************************************************************/
+ void  SiiDrvCbusIntrFlagSet()
+{
+    // Do not clear SiiCBUS_MHL_CONNECTION_CHG, since it will be processed out of cbus handler.
+    if (pDrvCbus->statusFlags & SiiCBUS_MHL_CONNECTION_CHG)
+        pDrvCbus->statusFlags = SiiCBUS_MHL_CONNECTION_CHG;
+    else
+        pDrvCbus->statusFlags = 0;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns the last MSC Abort reason received by the CBUS ISR.
+ *
+ *  @param[in]        pData        pointer to return data buffer (1 byte).
+ *
+ *  @return    MSC Abort reason data
+ *  @retval    true        a new MSC Abort reason data is available
+ *  @retval    false        a new MSC Abort reason data is not available
+ *
+ *****************************************************************************/
+ bool_t  SiiDrvCbusNackFromPeerGet ()
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_NACK_RECEIVED_FM_PEER )
+    {
+        pDrvCbus->statusFlags &= ~SiiCBUS_NACK_RECEIVED_FM_PEER;
+        return( true );
+    }
+    return( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns if the peer's device capability values are changed
+ *
+ *  @return    peer's device capability values are changed or not
+ *  @retval    true        peer's device capability values are changed
+ *  @retval    false        peer's device capability values are not changed
+ *
+ *****************************************************************************/
+ bool_t  SiiDrvCbusDevCapChangedGet ()
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_DCAP_CHG_RECEIVED_FM_PEER )
+    {
+        pDrvCbus->statusFlags &= ~SiiCBUS_DCAP_CHG_RECEIVED_FM_PEER;
+        return( true );
+    }
+    return( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns if the peer has written the scratchpad
+ *
+ *  @return    peer has written the scratchpad or not
+ *  @retval    true        peer has written the scratchpad
+ *  @retval    false        peer has not written the scratchpad
+ *
+ *****************************************************************************/
+ bool_t  SiiDrvCbusScratchpadWrtnGet ()
+{
+    if (pDrvCbus->statusFlags & SiiCBUS_SCRATCHPAD_WRITTEN_BY_PEER)
+    {
+        pDrvCbus->statusFlags &= ~SiiCBUS_SCRATCHPAD_WRITTEN_BY_PEER;
+        return (true);
+    }
+    return (false);
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns if the peer is requesting for scratchpad write permission
+ *
+ *  @return    peer is requesting for scratchpad write permission or not
+ *  @retval    true        peer is requesting for scratchpad write permission
+ *  @retval    false        peer is not requesting for scratchpad write permission
+ *
+ *****************************************************************************/
+bool_t  SiiDrvCbusReqWrtGet ()
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_REQ_WRT_RECEIVED_FM_PEER )
+    {
+        pDrvCbus->statusFlags &= ~SiiCBUS_REQ_WRT_RECEIVED_FM_PEER;
+        return( true );
+    }
+    return( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns if the peer has granted scratchpad write permission
+ *
+ *  @return    peer has granted scratchpad write permission or not
+ *  @retval    true        peer has granted scratchpad write permission
+ *  @retval    false        peer has not granted scratchpad write permission
+ *
+ *****************************************************************************/
+ bool_t  SiiDrvCbusGrtWrtGet ()
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_GRT_WRT_RECEIVED_FM_PEER )
+    {
+        pDrvCbus->statusFlags &= ~SiiCBUS_GRT_WRT_RECEIVED_FM_PEER;
+        return( true );
+    }
+    return( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Send out the 3D Write Burst infomation
+ *
+ *  @return    true if adding to the cubs que successfully
+ *
+ *****************************************************************************/
+bool_t SiiDrv3DWriteBurst()
+{
+    Mhl2VideoFormatData_t *pvideoFormatData = pDrvCbus->videoFormatData;
+    // no need to check SpSupport since mhl source always support scatchpad from spec.
+    while (BURST_ID(pvideoFormatData->burstId) == burstId_3D_VIC ||  BURST_ID(pvideoFormatData->burstId) == burstId_3D_DTD)
+    {
+        if (!SiiCbusWritePeersScratchpad(0x00, 16, (uint8_t *)pvideoFormatData))
+        {
+            return ~SUCCESS;
+        }
+        pvideoFormatData++;
+    }
+    
+    return SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns if the peer requesting for 3D infomation
+ *
+ *  @return    peer has requested 3D infomation or not
+ *  @retval    true        peer has requested 3D infomation
+ *  @retval    false        peer has not requested 3D infomation
+ *
+ *****************************************************************************/
+ bool_t  SiiDrvCbus3DReqGet ()
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_3D_REQ_RECEIVED_FM_PEER )
+    {
+        pDrvCbus->statusFlags &= ~SiiCBUS_3D_REQ_RECEIVED_FM_PEER;
+        return( true );
+    }
+    return( false );
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief        Build 3D Data Per EDID
+ *
+ *****************************************************************************/
+static void SiiDrvBuild3DDataPerEdid(void)
+{
+    // TODO: Please update data here per EDID in actual application. Currently, default 3D formats are added
+
+    // 02 / 03 / 04 / 05 / 06 here are indexes of corresponding VICs in EDID's Video Data Block
+
+    // 02 - 1080I50
+    VIC3DFormats[2].Fields.FrameSequential = 0;
+    VIC3DFormats[2].Fields.TopBottom = 0;
+    VIC3DFormats[2].Fields.LeftRight = 1;
+
+    // 03 -  1080I60
+    VIC3DFormats[3].Fields.FrameSequential = 0;
+    VIC3DFormats[3].Fields.TopBottom = 0;
+    VIC3DFormats[3].Fields.LeftRight = 1;
+
+    // 04 -  720P50
+    VIC3DFormats[4].Fields.FrameSequential = 1;
+    VIC3DFormats[4].Fields.TopBottom = 1;
+    VIC3DFormats[4].Fields.LeftRight = 0;
+
+    // 05 -  720P60
+    VIC3DFormats[5].Fields.FrameSequential = 1;
+    VIC3DFormats[5].Fields.TopBottom = 1;
+    VIC3DFormats[5].Fields.LeftRight = 0;
+
+    // 06 -  1080P24
+    VIC3DFormats[6].Fields.FrameSequential = 1;
+    VIC3DFormats[6].Fields.TopBottom = 1;
+    VIC3DFormats[6].Fields.LeftRight = 0;
+
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Build 3D Data for sending
+ *
+ *****************************************************************************/
+void SiiDrvCbusBuild3DData(void)
+{
+    uint8_t i = 0;
+    uint8_t j = 0;
+    uint8_t k = 0;
+    uint8_t * ptr;
+    uint8_t checksum;
+    uint8_t length = HDMI_3D_SVD_STRUCTURE_LENGTH;
+    uint8_t EdidVicCnt = HDMI_SVD_STRUCTURE_LENGTH_EDID;
+    
+    memset(pDrvCbus->videoFormatData, 0x00, sizeof(pDrvCbus->videoFormatData));
+
+    pDrvCbus->videoFormatData[0].burstId.low = burstId_3D_DTD;
+    pDrvCbus->videoFormatData[0].totalEntries = 0;
+    pDrvCbus->videoFormatData[0].sequenceIndex = 1;
+    pDrvCbus->videoFormatData[0].numEntriesThisBurst = 0;
+
+#ifdef HDMI_3D_SVD_SUPPORT
+    {
+        SiiDrvBuild3DDataPerEdid();
+
+        if ( EdidVicCnt < HDMI_3D_SVD_STRUCTURE_LENGTH)
+        {
+            length = EdidVicCnt;
+        }
+        j = 1;
+        for(i=0; i < length; i++)
+        {
+            pDrvCbus->videoFormatData[j].burstId.low = burstId_3D_VIC;
+            pDrvCbus->videoFormatData[j].totalEntries = length;
+            pDrvCbus->videoFormatData[j].sequenceIndex = j;
+            k = pDrvCbus->videoFormatData[j].numEntriesThisBurst++;
+            pDrvCbus->videoFormatData[j].videoDescriptors[k].FrameSequential = VIC3DFormats[i].Fields.FrameSequential;
+            pDrvCbus->videoFormatData[j].videoDescriptors[k].TopBottom = VIC3DFormats[i].Fields.TopBottom;
+            pDrvCbus->videoFormatData[j].videoDescriptors[k].LeftRight = VIC3DFormats[i].Fields.LeftRight;
+            if (4 == k)
+                j++;
+        }
+    }
+#else
+    {
+        pDrvCbus->videoFormatData[1].burstId.low = burstId_3D_VIC;
+        pDrvCbus->videoFormatData[1].totalEntries = 0;
+        pDrvCbus->videoFormatData[1].sequenceIndex = 1;
+        pDrvCbus->videoFormatData[1].numEntriesThisBurst = 0;
+    }
+#endif
+
+    //Build checksunm
+    for (i = 0; i < MaxVideoEntry; i++)
+    {
+        ptr = (uint8_t *)&pDrvCbus->videoFormatData[i];
+        checksum = 0;
+        for (j = 0; j < sizeof(Mhl2VideoFormatData_t); j++)
+        {
+            checksum += *(ptr+j);
+        }
+        pDrvCbus->videoFormatData[i].checkSum = (0-checksum);
+    }
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns the last VS cmd and data bytes retrieved by the CBUS ISR.
+ *
+ *  @param[in]        pData        pointer to return data buffer (2 bytes).
+ *
+ *  @return    pData[0] - VS_CMD value
+ *  @return    pData[1] - VS_DATA value
+ *  @return    Status
+ *  @retval    true        Data is available
+ *  @retval    false        Data is not available
+ *
+ *****************************************************************************/
+bool_t SiiDrvCbusVsDataGet ( uint8_t *pData )
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_MSC_MSG_RCVD )
+    {
+        *pData++ = pDrvCbus->vsCmd;
+        *pData = pDrvCbus->vsData;
+        pDrvCbus->statusFlags &= ~SiiCBUS_MSC_MSG_RCVD;
+        return( true );
+    }
+    return ( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns if the peer's device capability values are ready
+ *
+ *  @return    peer's device capability values are ready or not
+ *  @retval    true        peer's device capability values are ready
+ *  @retval    false        peer's device capability values are not ready
+ *
+ *****************************************************************************/
+bool_t  SiiDrvCbusDevCapReadyGet ()
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_DCAP_RDY_RECEIVED_FM_PEER )
+    {
+        pDrvCbus->statusFlags &= ~SiiCBUS_DCAP_RDY_RECEIVED_FM_PEER;
+        return( true );
+    }
+    return( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns if the peer has sent PATH_EN
+ *
+ *  @return    peer has sent PATH_EN or not
+ *  @retval    true        peer has sent PATH_EN
+ *  @retval    false        peer has not sent PATH_EN
+ *
+ *****************************************************************************/
+bool_t  SiiDrvPathEnableGet ()
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_PATH_EN_RECEIVED_FM_PEER )
+    {
+        pDrvCbus->statusFlags &= ~SiiCBUS_PATH_EN_RECEIVED_FM_PEER;
+        return( true );
+    }
+    return( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        return response from peer
+ *
+ *  @param[in]        pData        pointer to return data buffer (2 bytes).
+ *
+ *  @return    Status
+ *  @retval    true        Data is available
+ *  @retval    false        Data is not available
+ *
+ *****************************************************************************/
+bool_t  SiiDrvCbusCmdRetDataGet ( uint8_t *pData )
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_MSC_CMD_DONE )
+    {
+        *pData++ = pDrvCbus->msgData0;
+        *pData = pDrvCbus->msgData1;
+        pDrvCbus->statusFlags &= ~SiiCBUS_MSC_CMD_DONE;
+        return( true );
+    }
+     return ( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns the last Bus Status data retrieved by the CBUS ISR.
+ *
+ *  @param[in]        pData        pointer to return data buffer (1 bytes).
+ *
+ *  @return    Status
+ *  @retval    true        Data is available
+ *  @retval    false        Data is not available
+ *
+ *****************************************************************************/
+bool_t  SiiDrvCbusBusStatusGet ( uint8_t *pData )
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_CBUS_CONNECTION_CHG )
+    {
+        *pData = pDrvCbus->busConnected;
+        pDrvCbus->statusFlags &= ~SiiCBUS_CBUS_CONNECTION_CHG;
+        return( true );
+    }
+    return ( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns the last Bus Status data retrieved by the CBUS ISR.
+ *
+ *  @param[in]        pData        pointer to return data buffer (1 bytes).
+ *
+ *  @return    Status
+ *  @retval    true        Data is available
+ *  @retval    false        Data is not available
+ *
+ *****************************************************************************/
+bool_t  SiiDrvCbusMhlStatusGet ( uint8_t *pData )
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_MHL_CONNECTION_CHG )
+    {
+        *pData = pDrvCbus->mhlConnected;
+        pDrvCbus->statusFlags &= ~SiiCBUS_MHL_CONNECTION_CHG;
+        return( true );
+    }
+    return ( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns the last DDC Abort reason received by the CBUS ISR.
+ *
+ *  @param[in]        pData        pointer to return data buffer (1 bytes).
+ *
+ *  @return    Status
+ *  @retval    true        Data is available
+ *  @retval    false        Data is not available
+ *
+ *****************************************************************************/
+bool_t  SiiDrvCbusDdcAbortReasonGet ( uint8_t *pData )
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_DDC_ABORT )
+    {
+        *pData = pDrvCbus->ddcAbortReason;
+        pDrvCbus->statusFlags &= ~SiiCBUS_DDC_ABORT;
+        return( true );
+    }
+    return ( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns the last MSC Abort reason received by the CBUS ISR.
+ *
+ *  @param[in]        pData        pointer to return data buffer (1 bytes).
+ *
+ *  @return    Status
+ *  @retval    true        Data is available
+ *  @retval    false        Data is not available
+ *
+ *****************************************************************************/
+bool_t  SiiDrvCbusMscAbortReasonGet ( uint8_t *pData )
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_MSC_ABORT )
+    {
+        *pData = pDrvCbus->mscAbortReason;
+        pDrvCbus->statusFlags &= ~SiiCBUS_MSC_ABORT;
+        return( true );
+    }
+    return ( false );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Returns the last MSC Abort reason received by the CBUS ISR.
+ *
+ *  @param[in]        pData        pointer to return data buffer (1 bytes).
+ *
+ *  @return    Status
+ *  @retval    true        Data is available
+ *  @retval    false        Data is not available
+ *
+ *****************************************************************************/
+bool_t  SiiDrvCbusMscAbortResReasonGet ( uint8_t *pData )
+{
+    if ( pDrvCbus->statusFlags & SiiCBUS_MSC_ABORT_RES )
+	{
+    	*pData = pDrvCbus->mscAbortResReason;
+		pDrvCbus->statusFlags &= ~SiiCBUS_MSC_ABORT_RES;
+		return( true );
+	}
+    return ( false );
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief        Wrapper to call SiiDrvSwitchDeviceRXTermControl()
+ *
+ *  @param[in]        terminate        terminate cbus or not
+ *
+ *****************************************************************************/
+void  SiiDrvCbusTermCtrl ( bool_t terminate )
+{
+    SiiDrvSwitchDeviceRXTermControl(terminate ? SiiTERM_MHL : SiiTERM_DISABLE );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Write the specified Sideband Channel command to the CBUS.
+ *                   Command can be a MSC_MSG command (RCP/MCW/RAP), or another command 
+ *                   such as READ_DEVCAP, GET_VENDOR_ID, SET_HPD, CLR_HPD, etc.
+ *
+ *  @param[in]        pReq        Pointer to a cbus_req_t structure containing the
+ *                                 command to write
+ *
+ *  @return    a cbus_req_t structure containing the
+ *             command to write
+ *  @retval    true        successful write
+ *  @retval    false        write failed
+ *
+ *****************************************************************************/
+ bool_t SiiDrvInternalCBusWriteCommand ( cbus_req_t *pReq  )
+{
+    uint8_t i, startbit;
+    bool_t  success = true;
+
+    DEBUG_PRINT(
+        MSG_DBG, "CBUS:: Send MSC cmd %02X, %02X, %02X\n",
+        (int)pReq->command, (int)pReq->offsetData, (int)pReq->msgData[0]
+        );
+
+    /****************************************************************************************/
+    /* Setup for the command - write appropriate registers and determine the correct        */
+    /*                         start bit.                                                   */
+    /****************************************************************************************/
+
+    // Set the offset and outgoing data byte right away
+    SiiRegWrite( REG_CBUS_PRI_ADDR_CMD, pReq->offsetData);   // set offset
+    SiiRegWrite( REG_CBUS_PRI_WR_DATA_1ST, pReq->msgData[0] );
+
+    startbit = 0x00;
+    switch ( pReq->command )
+    {
+        case MHL_SET_INT:   // Set one interrupt register = 0x60
+            SiiRegWrite( REG_CBUS_PRI_ADDR_CMD, pReq->offsetData + 0x20 );   // set offset
+            startbit = MSC_START_BIT_SET_INT_WRITE_STAT;
+            break;
+
+        case MHL_WRITE_STAT:    // Write one status register = 0x60 | 0x80
+            SiiRegWrite( REG_CBUS_PRI_ADDR_CMD, pReq->offsetData + 0x30 );   // set offset
+            startbit = MSC_START_BIT_SET_INT_WRITE_STAT;
+            break;
+
+        case MHL_READ_DEVCAP:
+            startbit = MSC_START_BIT_READ_DEV_CAP_REG;
+            break;
+
+        case MHL_GET_STATE:
+        case MHL_GET_VENDOR_ID:
+        case MHL_SET_HPD:
+        case MHL_CLR_HPD:
+        case MHL_GET_SC1_ERRORCODE:      // 0x69 - Get channel 1 command error code
+        case MHL_GET_DDC_ERRORCODE:      // 0x6A - Get DDC channel command error code.
+        case MHL_GET_MSC_ERRORCODE:      // 0x6B - Get MSC command error code.
+        case MHL_GET_SC3_ERRORCODE:      // 0x6D - Get channel 3 command error code.
+            SiiRegWrite( REG_CBUS_PRI_ADDR_CMD, pReq->command );
+            startbit = MSC_START_BIT_MSC_CMD;
+            break;
+
+        case MHL_MSC_MSG:
+            SiiRegWrite( REG_CBUS_PRI_WR_DATA_2ND, pReq->msgData[1] );
+            SiiRegWrite( REG_CBUS_PRI_ADDR_CMD, pReq->command );
+            DEBUG_PRINT( MSG_DBG, "CBUS:: MSG_MSC CMD:    0x%02X\n", (int)pReq->command );
+            DEBUG_PRINT( MSG_DBG, "CBUS:: MSG_MSC Data 0: 0x%02X\n", (int)pReq->msgData[0] );
+            DEBUG_PRINT( MSG_DBG, "CBUS:: MSG_MSC Data 1: 0x%02X\n", (int)pReq->msgData[1] );
+            startbit = MSC_START_BIT_MSC_MSG_CMD;
+            break;
+
+        case MHL_WRITE_BURST:
+            SiiRegWrite( REG_CBUS_PRI_ADDR_CMD, pReq->offsetData + 0x40);
+            SiiRegWrite( REG_MSC_WRITE_BURST_LEN, pReq->length - 1);
+
+            // Now copy all bytes from array to local scratchpad
+
+            for ( i = 0; i < pReq->length; i++ )
+            {
+                SiiRegWrite( REG_CBUS_SCRATCHPAD_0 + i, pReq->msgData[i] );
+            }
+            startbit = MSC_START_BIT_WRITE_BURST;
+            break;
+
+        default:
+            success = false;
+            break;
+    }
+
+    /****************************************************************************************/
+    /* Trigger the CBUS command transfer using the determined start bit.                    */
+    /****************************************************************************************/
+
+    if ( success )
+    {
+        SiiRegWrite( REG_CBUS_PRI_START, startbit );
+    }
+
+    return( success );
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief        Check CBUS registers for a CBUS event
+ *
+ *****************************************************************************/
+bool_t SiiDrvCbusProcessInterrupts()
+{
+    uint8_t intStatus0, intStatus1, intStatusTemp;
+
+    // Read CBUS interrupt status. Return if nothing happening on the interrupt front
+    intStatus0 = SiiRegRead( REG_CBUS_INTR_0 );
+    intStatus1 = SiiRegRead( REG_CBUS_INTR_1 );
+
+    // mask out the interrupts that we don't care about
+    intStatus1 &= ~(BIT_HEARTBEAT_TIMEOUT | BIT_SET_CAP_ID_RSVD | BIT_CBUS_PKT_RCVD | BIT_CEC_ABORT);
+
+    if(!(intStatus0 || intStatus1))
+        return false;
+    // clear the interrupts
+    SiiRegWrite( REG_CBUS_INTR_0, intStatus0 );
+    SiiRegWrite( REG_CBUS_INTR_1, intStatus1 );
+    DEBUG_PRINT( MSG_DBG, "CBUS:: INTR_0:: %02X -- INTR_1:: %02X\n", (int)intStatus0, (int)intStatus1);
+
+    // An interrupt occurred, save the status.
+    pDrvCbus->statusFlags |= SiiCBUS_INT ;
+
+    if( intStatus0 )
+    {
+        if ( intStatus0 & BIT_MSC_CMD_DONE_WITH_NACK )
+        {
+            pDrvCbus->statusFlags |= SiiCBUS_NACK_RECEIVED_FM_PEER;
+        }
+
+        if ( intStatus0 & BIT_MSC_SET_INT_RCVD )
+        {
+            intStatusTemp = SiiRegRead( REG_CBUS_SET_INT_0 );
+            if( intStatusTemp & BIT0 )
+            {
+                pDrvCbus->statusFlags |= SiiCBUS_DCAP_CHG_RECEIVED_FM_PEER;
+            }
+            if ( intStatusTemp & BIT1 )
+            {
+                pDrvCbus->statusFlags |= SiiCBUS_SCRATCHPAD_WRITTEN_BY_PEER;
+            }
+            if( intStatusTemp & BIT2 )
+            {
+                pDrvCbus->statusFlags |= SiiCBUS_REQ_WRT_RECEIVED_FM_PEER;
+            }
+            if( intStatusTemp & BIT3 )
+            {
+                pDrvCbus->statusFlags |= SiiCBUS_GRT_WRT_RECEIVED_FM_PEER;
+            }
+            if( intStatusTemp & BIT4 )
+            {
+                pDrvCbus->statusFlags |= SiiCBUS_3D_REQ_RECEIVED_FM_PEER;
+            }
+            SiiRegWrite( REG_CBUS_SET_INT_0, intStatusTemp );   // Clear received interrupts
+        }
+
+        // This step is redundant as we do get DSCR_CHG interrupt up there
+        if ( intStatus0 & BIT_MSC_WRITE_BURST_RCVD )
+        {
+            pDrvCbus->statusFlags |= SiiCBUS_SCRATCHPAD_WRITTEN_BY_PEER;
+        }
+
+        // Get any VS or MSC data received
+        if ( intStatus0 & BIT_MSC_MSG_RCVD )
+        {
+            pDrvCbus->statusFlags |= SiiCBUS_MSC_MSG_RCVD;
+            pDrvCbus->vsCmd  = SiiRegRead( REG_CBUS_PRI_VS_CMD );
+            pDrvCbus->vsData = SiiRegRead( REG_CBUS_PRI_VS_DATA );
+        }
+
+        if ( intStatus0 & BIT_MSC_WRITE_STAT_RCVD )
+        {
+            // see if device capability values are changed
+            intStatusTemp = SiiRegRead( REG_CBUS_WRITE_STAT_0 );
+            if( intStatusTemp & BIT0 )
+            {
+                pDrvCbus->statusFlags |= SiiCBUS_DCAP_RDY_RECEIVED_FM_PEER;
+            }
+
+            intStatusTemp = SiiRegRead( REG_CBUS_WRITE_STAT_1 );
+            if( intStatusTemp & BIT3 )
+            {
+                pDrvCbus->statusFlags |= SiiCBUS_PATH_EN_RECEIVED_FM_PEER;
+            }
+        }
+
+        if ( intStatus0 & BIT_MSC_CMD_DONE )
+        {
+            pDrvCbus->statusFlags |= SiiCBUS_MSC_CMD_DONE;
+            pDrvCbus->msgData0  = SiiRegRead( REG_CBUS_PRI_RD_DATA_1ST );
+            pDrvCbus->msgData1  = SiiRegRead( REG_CBUS_PRI_RD_DATA_2ND );
+        }
+
+        // CBUS connection status has changed
+        if ( intStatus0 & BIT_CONNECT_CHG )
+        {
+            pDrvCbus->statusFlags |= SiiCBUS_CBUS_CONNECTION_CHG;
+            pDrvCbus->busConnected = SiiRegRead( REG_CBUS_BUS_STATUS ) & BIT_BUS_CONNECTED;
+        }
+    }
+
+    if(intStatus1)
+    {
+        if ( intStatus1 & BIT_DDC_ABORT )
+        {
+            pDrvCbus->ddcAbortReason = SiiRegRead( REG_DDC_ABORT_REASON );
+            pDrvCbus->statusFlags |= SiiCBUS_DDC_ABORT;
+            SiiRegWrite( REG_DDC_ABORT_REASON, pDrvCbus->ddcAbortReason );
+        }
+
+        // MSC_ABORT happened as Responder
+        if ( intStatus1 & BIT_MSC_ABORT_RES )
+        {
+            pDrvCbus->mscAbortResReason = SiiRegRead( REG_MSC_ABORT_RES_REASON );
+            pDrvCbus->statusFlags |= SiiCBUS_MSC_ABORT_RES;
+            SiiRegWrite( REG_MSC_ABORT_RES_REASON, pDrvCbus->mscAbortResReason );
+        }
+
+        // MSC_ABORT happened at this device itself
+        if ( intStatus1 & BIT_MSC_ABORT )
+        {
+            pDrvCbus->mscAbortReason = SiiRegRead( REG_MSC_ABORT_REASON );
+            pDrvCbus->statusFlags |= SiiCBUS_MSC_ABORT;
+            SiiRegWrite( REG_MSC_ABORT_REASON, pDrvCbus->mscAbortReason );
+        }
+
+        // MHL connection status has changed
+        if ( intStatus1 & BIT_MHL_CONNECT_CHG )
+        {
+            pDrvCbus->statusFlags |= SiiCBUS_MHL_CONNECTION_CHG;
+            pDrvCbus->mhlConnected =  SiiRegRead( REG_CBUS_BUS_STATUS ) & BIT_MHL_CONNECTED;
+        }
+    }
+
+    return true;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief        Initialize the CBUS hardware for the current instance.
+ *
+ *  @return    Status
+ *  @retval    true        Success
+ *  @retval    false        Failure
+ *
+ *  @note: Requires that SiiDrvCbusInstanceSet() is called prior to this call
+ * 
+ *****************************************************************************/
+ bool_t SiiDrvCbusInitialize ( void )
+{
+    uint_t  index;
+
+    SiiRegModify(RX_A__SWRST2, RX_M__SWRST2__CBUS_SRST, SET_BITS);
+    SiiRegModify(RX_A__SWRST2, RX_M__SWRST2__CBUS_SRST, CLEAR_BITS);
+
+    memset( pDrvCbus, 0, sizeof( CbusDrvInstanceData_t ));
+
+    // Setup local DEVCAP registers for read by the peer
+    for ( index = 0; index < (sizeof( cbusInitCbusRegsList) / 2); index += 2 )
+    {
+        SiiRegWrite( cbusInitCbusRegsList[ index], cbusInitCbusRegsList[ index + 1] );
+    }
+
+    // Audio link mode update by switch status
+    if ( SiiSpdifEnableGet() || !SiiTdmEnableGet() )
+    {
+        SiiRegWrite(REG_CBUS_DEVICE_CAP_6, MHL_AUD_LINK_MODE_2CH);
+    }
+    
+    // Enable the VS commands, all interrupts, and clear legacy
+    SiiRegWrite( REG_CBUS_INTR_0_MASK, 0xFF );      // Enable desired interrupts
+    SiiRegWrite( REG_CBUS_INTR_1_MASK, 0xCC );      // Enable desired interrupts
+    SiiRegWrite( RX_CBUS_CH_RST_CTRL, 0x00 );       // MHL: Tri-state CBUS
+
+#ifdef MHAWB_SUPPORT
+    SiiDrvHawbEnable(false);
+#endif
+    return( true );
+}
+
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_drv_cbus.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_drv_cbus.h
new file mode 100755
index 000000000000..f1c338d15b9d
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_drv_cbus.h
@@ -0,0 +1,328 @@
+/******************************************************************************/
+//!file     si_drv_cbus.h
+//!brief    CBUS Driver functions
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2007-2013, Silicon Image, Inc.  All rights reserved.
+/******************************************************************************/
+
+#ifndef __SI_DRV_CBUS_H__
+#define __SI_DRV_CBUS_H__
+
+
+#include "si_common.h"
+#include "si_cbus_component.h"
+
+//------------------------------------------------------------------------------
+// Driver enums
+//------------------------------------------------------------------------------
+
+typedef enum
+{
+    SiiCBUS_INT                     		= 0x0001,   // A CBUS interrupt has occurred
+    SiiCBUS_NACK_RECEIVED_FM_PEER 			= 0x0002,	// Peer sent a NACK
+    SiiCBUS_DCAP_RDY_RECEIVED_FM_PEER		= 0x0004,   // DCAP_RDY received
+    SiiCBUS_PATH_EN_RECEIVED_FM_PEER		= 0x0008,   // PATH_EN received
+    SiiCBUS_DCAP_CHG_RECEIVED_FM_PEER		= 0x0010,   // DCAP_CHG received
+    SiiCBUS_SCRATCHPAD_WRITTEN_BY_PEER		= 0x0020,   // DSCR_CHG received.peer writes into scrAtchpad
+    SiiCBUS_REQ_WRT_RECEIVED_FM_PEER		= 0x0040,   // REQ_WRT received
+    SiiCBUS_GRT_WRT_RECEIVED_FM_PEER		= 0x0080,   // GRT_WRT received
+
+    SiiCBUS_3D_REQ_RECEIVED_FM_PEER         = 0x0100,   // 3D_REQ received
+    SiiCBUS_DDC_ABORT						= 0x0200,   // DDC_ABORT
+    SiiCBUS_MSC_ABORT_RES                   = 0x0400,   // DDC_ABORT
+    SiiCBUS_MSC_ABORT                       = 0x0800,   // DDC_ABORT
+
+    SiiCBUS_MSC_MSG_RCVD					= 0x1000,	// MSC_MSG received
+    SiiCBUS_MSC_CMD_DONE					= 0x2000,	// MSC_MSG received
+    SiiCBUS_CBUS_CONNECTION_CHG				= 0x4000,	// MSC_MSG received
+    SiiCBUS_MHL_CONNECTION_CHG				= 0x8000,	// MHL cable connected
+
+} SiiDrvCbusStatus_t;
+
+//------------------------------------------------------------------------------
+// CBUS Driver Manifest Constants
+//------------------------------------------------------------------------------
+
+// Version that this chip supports
+#define MHL_VER_MAJOR       (0x01 << 4) // bits 4..7
+#define MHL_VER_MINOR       0x00        // bits 0..3
+#define MHL_VERSION      	(MHL_VER_MAJOR | MHL_VER_MINOR)
+
+#define CBUS_VER_MAJOR      (0x01 << 4) // bits 4..7
+#define CBUS_VER_MINOR      0x00        // bits 0..3
+#define MHL_CBUS_VERSION                (CBUS_VER_MAJOR | CBUS_VER_MINOR)
+
+#define MHL_DEV_CAT_POW_DF                  0x11
+
+#define MHL_DEV_CAT_SOURCE                  0x00
+#define MHL_DEV_CAT_SINGLE_INPUT_SINK       0x01
+#define MHL_DEV_CAT_MULTIPLE_INPUT_SINK     0x02
+#define MHL_DEV_CAT_UNPOWERED_DONGLE        0x03
+#define MHL_DEV_CAT_SELF_POWERED_DONGLE     0x04
+#define MHL_DEV_CAT_HDCP_REPEATER           0x05
+#define MHL_DEV_CAT_OTHER                   0x06
+
+#define MHL_POWER_SUPPLY_CAPACITY       	16      // 160 mA current
+#define MHL_POWER_SUPPLY_PROVIDED       	16      // 160mA 0r 0 for Wolverine.
+#define MHL_VIDEO_LINK_MODE_SUPORT      	1       // Bit 0 = Supports RGB 4:4:4
+#define MHL_AUDIO_LINK_MODE_SUPORT      	1       // Bit 0 = 2-Channel
+#define MHL_HDCP_STATUS                 	0       // Bits set dynamically
+
+// initialize MHL registers with the correct values
+#define MHL_DEV_STATE						0x00
+#define MHL_MHL_VERSION						0x20
+#define MHL_DEV_CAT							0x31    //changed from 0x11 for sink 900ma output support
+#define MHL_ADOPTER_ID_H					0x01
+#define MHL_ADOPTER_ID_L					0x42
+#define MHL_VID_LINK_MODE					0x3F
+#define MHL_AUD_LINK_MODE					0x03
+#define MHL_VIDEO_TYPE						0x8F
+#define MHL_LOG_DEV_MAP						0x41
+#define MHL_BANDWIDTH						0x0F
+#define MHL_FEATURE_FLAG					0x1F // changed from 0x07 to support UCP
+	#define MHL_FEATURE_SP_SUPPORT			0x04
+#define MHL_DEVICE_ID_H						0x52
+#define MHL_DEVICE_ID_L						0x93
+#define MHL_SCRATCH_PAD_SIZE				0x10
+#define MHL_INT_STAT_SIZE					0x33
+#define MHL_RESERVED						0x00
+
+// MHL_AUD_LINK_MODE : 0x06
+#define MHL_AUD_LINK_MODE_2CH                     0x01
+#define MHL_AUD_LINK_MODE_8CH                     0x02
+
+#define MHL_DEV_SUPPORTS_DISPLAY_OUTPUT    	(0x01 << 0)
+#define MHL_DEV_SUPPORTS_VIDEO_OUTPUT    	(0x01 << 1)
+#define MHL_DEV_SUPPORTS_AUDIO_OUTPUT      	(0x01 << 2)
+#define MHL_DEV_SUPPORTS_MEDIA_HANDLING     (0x01 << 3)
+#define MHL_DEV_SUPPORTS_TUNER     			(0x01 << 4)
+#define MHL_DEV_SUPPORTS_RECORDING         	(0x01 << 5)
+#define MHL_DEV_SUPPORTS_SPEAKERS           (0x01 << 6)
+#define MHL_DEV_SUPPORTS_GUI            	(0x01 << 7)
+
+#define     MHL_BANDWIDTH_LIMIT             22      // 225 MHz
+
+typedef enum
+{
+     burstId_3D_VIC = 0x0010
+    ,burstId_3D_DTD = 0x0011
+}BurstId_e;
+typedef struct _Mhl2HighLow_t
+{
+    uint8_t high;
+    uint8_t low;
+}Mhl2HighLow_t,*PMhl2HighLow_t;
+#define BURST_ID(bid) (BurstId_e)((((uint16_t)bid.high)<<8)|((uint16_t)bid.low))
+
+// see MHL2.0 spec section 5.9.1.2
+typedef struct _Mhl2VideoDescriptor_t
+{
+    uint8_t reservedHigh;
+    unsigned char FrameSequential:1;    //FS_SUPP
+    unsigned char TopBottom:1;          //TB_SUPP
+    unsigned char LeftRight:1;          //LR_SUPP
+    unsigned char reservedLow:5;
+}Mhl2VideoDescriptor_t,*PMhl2VideoDescriptor_t;
+
+typedef struct _Mhl2VideoFormatData_t
+{
+    Mhl2HighLow_t burstId;
+    uint8_t checkSum;
+    uint8_t totalEntries;
+    uint8_t sequenceIndex;
+    uint8_t numEntriesThisBurst;
+    Mhl2VideoDescriptor_t videoDescriptors[5];
+}Mhl2VideoFormatData_t,*PMhl2VideoFormatData_t;
+
+#define MaxVideoEntry   5
+
+typedef struct
+{
+    uint16_t    statusFlags;
+
+    // CBUS transfer values read at last interrupt for each specific channel
+    uint8_t     busConnected;
+    uint8_t     mhlConnected;	
+    uint8_t     vsCmd;
+    uint8_t     vsData;
+    uint8_t     msgData0;
+    uint8_t     msgData1;
+    uint8_t     cecAbortReason;
+    uint8_t     ddcAbortReason;
+    uint8_t     mscAbortResReason;
+    uint8_t     mscAbortReason;
+
+    Mhl2VideoFormatData_t videoFormatData[MaxVideoEntry];
+}	CbusDrvInstanceData_t;
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusIntrFlagGet
+// Description: Returns interrupt flag
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusIntrFlagGet(void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusIntrFlagSet
+// Description: reset interrupt flags
+//------------------------------------------------------------------------------
+void  SiiDrvCbusIntrFlagSet(void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusNackFromPeerGet
+// Description: checks if peer sent a NACK
+// Parameters:  channel - CBus channel
+// Returns:     true if peer sent a NACK, false if not.
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusNackFromPeerGet(void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusDevCapChangedGet
+// Description: Returns if the peer's device capability values are changed
+// Parameters:  pData - pointer to return data buffer (1 byte).
+// Returns:     true/false
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusDevCapChangedGet(void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusScratchpadWrtnGet
+// Description: Returns if the peer has written the scratchpad
+// Returns:     true/false
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusScratchpadWrtnGet (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusReqWrtGet
+// Description: Returns if the peer is requesting for scratchpad write permission
+// Returns:     true/false
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusReqWrtGet (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusGrtWrtGet
+// Description: Returns if the peer is requesting for scratchpad write permission
+// Returns:     true/false
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusGrtWrtGet (void);
+bool_t  SiiDrvCbus3DReqGet(void);
+void SiiDrvCbusBuild3DData(void);
+bool_t SiiDrv3DWriteBurst(void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusVsDataGet
+// Description: Returns the last VS cmd and data bytes retrieved by the CBUS ISR.
+// Parameters:  pData - pointer to return data buffer (2 bytes).
+// Returns:     true if a new VS data was available, false if not.
+//              pData[0] - VS_CMD value
+//              pData[1] - VS_DATA value
+//------------------------------------------------------------------------------
+bool_t SiiDrvCbusVsDataGet( uint8_t *pData );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusDevCapReadyGet
+// Description: Returns if the peer's device capability values are ready
+// Parameters:  pData - pointer to return data buffer (1 byte).
+// Returns:     true/false
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusDevCapReadyGet (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvPathEnableGet
+// Description: Returns if the peer has sent PATH_EN
+// Returns:     true/false
+//------------------------------------------------------------------------------
+bool_t  SiiDrvPathEnableGet (void);
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusCmdRetDataGet
+// Description: Clears the register to receive fresh response data back
+// Parameters:  pData - pointer to return data buffer (2 bytes).
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusCmdRetDataGet( uint8_t *pData );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusBusStatusGet
+// Description: Returns the last Bus Status data retrieved by the CBUS ISR.
+// Parameters:  pData - pointer to return data buffer (1 byte).
+// Returns:     true if new bus status data is available, false if not.
+//              pData - Destination for bus status data.
+//------------------------------------------------------------------------------
+bool_t SiiDrvCbusBusStatusGet( uint8_t *pData );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusMhlStatusGet
+// Description: Returns the last Bus Status data retrieved by the CBUS ISR.
+// Parameters:  pData - pointer to return data buffer (1 byte).
+// Returns:     true/false
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusMhlStatusGet ( uint8_t *pData );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusDdcAbortReasonGet
+// Description: Returns the last DDC Abort reason received by the CBUS ISR.
+// Parameters:  pData - pointer to return data buffer (1 byte).
+// Returns:     true if a new DDC Abort reason data was available, false if not.
+//              pData - Destination for DDC Abort reason data.
+//------------------------------------------------------------------------------
+bool_t        SiiDrvCbusDdcAbortReasonGet( uint8_t *pData );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusMscAbortReasonGet
+// Description: Returns the last MSC Abort reason received by the CBUS ISR.
+// Parameters:  pData - pointer to return data buffer (1 byte).
+// Returns:     true if a new MSC Abort reason data was available, false if not.
+//              pData - Destination for MSC Abort reason data.
+//------------------------------------------------------------------------------
+bool_t        SiiDrvCbusMscAbortReasonGet( uint8_t *pData );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusMscAbortFmPeerReasonGet
+// Description: Returns the last MSC Abort reason received by the CBUS ISR.
+// Parameters:  pData - pointer to return data buffer (1 byte).
+// Returns:     pData - Destination for MSC Abort reason data.
+//------------------------------------------------------------------------------
+bool_t  SiiDrvCbusMscAbortResReasonGet ( uint8_t *pData );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvInternalCBusWriteCommand
+// Description: Write the specified Sideband Channel command to the CBUS.
+//              Command can be a MSC_MSG command (RCP/MCW/RAP), or another command
+//              such as READ_DEVCAP, GET_VENDOR_ID, SET_HPD, CLR_HPD, etc.
+//
+// Parameters:  channel - CBUS channel to write
+//              pReq    - Pointer to a cbus_req_t structure containing the
+//                        command to write
+// Returns:     TRUE    - successful write
+//              FALSE   - write failed
+//------------------------------------------------------------------------------
+
+bool_t      SiiDrvInternalCBusWriteCommand( cbus_req_t *pReq );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusInitialize
+// Description: Attempts to initialize the CBUS. If register reads return 0xFF,
+//              it declares error in initialization.
+//              Initializes discovery enabling registers and anything needed in
+//              config register, interrupt masks.
+// Returns:     TRUE if no problem
+//------------------------------------------------------------------------------
+
+bool_t SiiDrvCbusInitialize( void );
+
+void        SiiDrvCbusTermCtrl ( bool_t terminate );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvCbusDevCapsRegisterGet
+// Description: Returns the CBus register value
+// Parameters:  regAddr - register address
+// Returns:     register value
+//------------------------------------------------------------------------------
+uint8_t     SiiDrvCbusDevCapsRegisterGet( uint16_t regAddr );
+
+bool_t        SiiDrvCbusProcessInterrupts(void);
+
+#endif      // __SI_DRV_CBUS_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_regs_mhl5293.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_regs_mhl5293.h
new file mode 100755
index 000000000000..5bf9a25e6e52
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/cbus_drv/si_regs_mhl5293.h
@@ -0,0 +1,118 @@
+//***************************************************************************
+//!file     si_regs_mhl5293.h
+//!brief    SiI5293 Device Register Manifest Constants.
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2007-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+#ifndef __SI_5293REGS_MHL_H__
+#define __SI_5293REGS_MHL_H__
+
+#include "si_drv_cra_cfg.h"
+
+//------------------------------------------------------------------------------
+// Registers in Page 12  (0xE6)
+//------------------------------------------------------------------------------
+
+#define REG_CBUS_DEVICE_CAP_0           (CBUS_PAGE | 0x00)
+#define REG_CBUS_DEVICE_CAP_1           (CBUS_PAGE | 0x01)
+#define REG_CBUS_DEVICE_CAP_2           (CBUS_PAGE | 0x02)
+#define REG_CBUS_DEVICE_CAP_3           (CBUS_PAGE | 0x03)
+#define REG_CBUS_DEVICE_CAP_4           (CBUS_PAGE | 0x04)
+#define REG_CBUS_DEVICE_CAP_5           (CBUS_PAGE | 0x05)
+#define REG_CBUS_DEVICE_CAP_6           (CBUS_PAGE | 0x06)
+#define REG_CBUS_DEVICE_CAP_7           (CBUS_PAGE | 0x07)
+#define REG_CBUS_DEVICE_CAP_8           (CBUS_PAGE | 0x08)
+#define REG_CBUS_DEVICE_CAP_9           (CBUS_PAGE | 0x09)
+#define REG_CBUS_DEVICE_CAP_A           (CBUS_PAGE | 0x0A)
+#define REG_CBUS_DEVICE_CAP_B           (CBUS_PAGE | 0x0B)
+#define REG_CBUS_DEVICE_CAP_C           (CBUS_PAGE | 0x0C)
+#define REG_CBUS_DEVICE_CAP_D           (CBUS_PAGE | 0x0D)
+#define REG_CBUS_DEVICE_CAP_E           (CBUS_PAGE | 0x0E)
+#define REG_CBUS_DEVICE_CAP_F           (CBUS_PAGE | 0x0F)
+
+#define REG_CBUS_SET_INT_0              (CBUS_PAGE | 0x20)
+#define REG_CBUS_SET_INT_1              (CBUS_PAGE | 0x21)
+#define REG_CBUS_SET_INT_2              (CBUS_PAGE | 0x22)
+#define REG_CBUS_SET_INT_3              (CBUS_PAGE | 0x23)
+
+#define REG_CBUS_WRITE_STAT_0           (CBUS_PAGE | 0x30)
+#define REG_CBUS_WRITE_STAT_1           (CBUS_PAGE | 0x31)
+#define REG_CBUS_WRITE_STAT_2           (CBUS_PAGE | 0x32)
+#define REG_CBUS_WRITE_STAT_3           (CBUS_PAGE | 0x33)
+
+#define REG_CBUS_SCRATCHPAD_0           (CBUS_PAGE | 0x60)
+
+#define REG_CBUS_SET_INT_0_MASK         (CBUS_PAGE | 0x80)
+#define REG_CBUS_SET_INT_1_MASK         (CBUS_PAGE | 0x81)
+#define REG_CBUS_SET_INT_2_MASK         (CBUS_PAGE | 0x82)
+#define REG_CBUS_SET_INT_3_MASK         (CBUS_PAGE | 0x83)
+
+#define REG_CBUS_BUS_STATUS             (CBUS_PAGE | 0x91)
+#define BIT_BUS_CONNECTED                   0x01
+#define BIT_MHL_CONNECTED                   0x10
+
+#define REG_CBUS_INTR_0            (CBUS_PAGE | 0x92)
+#define BIT_CONNECT_CHG                     0x01
+#define BIT_MSC_CMD_DONE                    0x02    	// ACK packet received
+#define BIT_HPD_RCVD                     	0x04    	// HPD received
+#define BIT_MSC_WRITE_STAT_RCVD             0x08    	// WRITE_STAT received
+#define BIT_MSC_MSG_RCVD                    0x10    	// MSC_MSG received
+#define BIT_MSC_WRITE_BURST_RCVD            0x20    	// WRITE_BURST received
+#define BIT_MSC_SET_INT_RCVD                0x40    	// SET_INT received
+#define	BIT_MSC_CMD_DONE_WITH_NACK          0x80		// NACK received from peer
+
+#define REG_CBUS_INTR_0_MASK       (CBUS_PAGE | 0x93)
+
+#define REG_CBUS_INTR_1            (CBUS_PAGE | 0x94)
+#define BIT_HEARTBEAT_TIMEOUT               0x01    	// Heartbeat max attempts failed
+#define BIT_CEC_ABORT                       0x02    	// peer aborted CEC command at translation layer
+#define BIT_DDC_ABORT                       0x04    	// peer aborted DDC command at translation layer
+#define BIT_MSC_ABORT_RES                   0x08    	// peer aborted MSC command at translation layer
+#define BIT_SET_CAP_ID_RSVD					0x10		// SET_CAP_ID received from peer
+#define BIT_CBUS_PKT_RCVD					0x20		// a valid CBus pkt has been received from peer
+#define BIT_MSC_ABORT               		0x40    	// this device aborted MSC command at translation layer
+#define BIT_MHL_CONNECT_CHG               		0x80    	// MHL cable connect status change
+
+#define REG_CBUS_INTR_1_MASK       (CBUS_PAGE | 0x95)
+
+#define REG_CEC_ABORT_REASON            (CBUS_PAGE | 0x96)
+#define REG_DDC_ABORT_REASON            (CBUS_PAGE | 0x98)
+#define REG_MSC_ABORT_REASON    		(CBUS_PAGE | 0x9A)
+#define BIT_MSC_MAX_RETRY                   0x01
+#define BIT_MSC_PROTOCOL_ERROR              0x02
+#define BIT_MSC_TIMEOUT                     0x04
+#define BIT_MSC_BAD_OPCODE                  0x08
+#define BIT_MSC_ABORT_BY_PEER               0x80
+
+#define REG_MSC_ABORT_RES_REASON        (CBUS_PAGE | 0x9C)
+
+#define REG_CBUS_LNK_CNTL_8             (CBUS_PAGE | 0xA7)
+
+#define REG_CBUS_PRI_START              (CBUS_PAGE | 0xB8)
+#define MSC_START_BIT_MSC_CMD               (0x01 << 0)
+#define MSC_START_BIT_MSC_MSG_CMD           (0x01 << 1)
+#define MSC_START_BIT_READ_DEV_CAP_REG      (0x01 << 2)
+#define MSC_START_BIT_SET_INT_WRITE_STAT    (0x01 << 3)
+#define MSC_START_BIT_WRITE_BURST           (0x01 << 4)
+
+#define REG_CBUS_PRI_ADDR_CMD           (CBUS_PAGE | 0xB9)
+#define REG_CBUS_PRI_WR_DATA_1ST        (CBUS_PAGE | 0xBA)
+#define REG_CBUS_PRI_WR_DATA_2ND        (CBUS_PAGE | 0xBB)
+#define REG_CBUS_PRI_RD_DATA_1ST        (CBUS_PAGE | 0xBC)
+#define REG_CBUS_PRI_RD_DATA_2ND        (CBUS_PAGE | 0xBD)
+
+#define REG_CBUS_PRI_VS_CMD             (CBUS_PAGE | 0xBF)
+#define REG_CBUS_PRI_VS_DATA            (CBUS_PAGE | 0xC0)
+#define REG_MSC_WRITE_BURST_LEN         (CBUS_PAGE | 0xC6)       // only for WRITE_BURST
+
+#define REG_CBUS_DISC_PWIDTH_MIN        (CBUS_PAGE | 0xE3)  //0x9EE=0x4E
+#define REG_CBUS_DISC_PWIDTH_MAX        (CBUS_PAGE | 0xE4)  //0x9EF=0xC0.
+
+#endif  // __SI_5293REGS_MHL_H__
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra.c
new file mode 100755
index 000000000000..cd05ca7eb362
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra.c
@@ -0,0 +1,544 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+
+//***************************************************************************
+//!file     si_cra.c
+//!brief    Silicon Image Device register I/O support.
+//***************************************************************************/
+
+#include "si_common.h"
+#include "si_cra.h"
+#include "si_drv_cra_cfg.h"
+#include "si_cra_internal.h"
+#if !defined(__KERNEL__)
+#include "si_i2c.h"
+#endif
+
+static uint8_t      l_pageInstance[SII_CRA_DEVICE_PAGE_COUNT] = {0};
+extern pageConfig_t g_addrDescriptor[SII_CRA_MAX_DEVICE_INSTANCES][SII_CRA_DEVICE_PAGE_COUNT];
+extern SiiReg_t     g_siiRegPageBaseReassign [];
+extern SiiReg_t     g_siiRegPageBaseRegs[SII_CRA_DEVICE_PAGE_COUNT];
+
+CraInstanceData_t craInstance =
+{
+    0,                          // structVersion
+    0,                          // instanceIndex
+    SII_SUCCESS,                // lastResultCode
+    0,                          // statusFlags
+};
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+
+#if defined(__KERNEL__)
+
+// Translate SiiPlatformStatus_t return codes into SiiResultCodes_t status codes.
+static SiiResultCodes_t TranslatePlatformStatus(SiiPlatformStatus_t platformStatus)
+{
+	switch(platformStatus)
+	{
+		case PLATFORM_SUCCESS:
+			return SII_SUCCESS;
+
+		case PLATFORM_FAIL:
+			return SII_ERR_FAIL;
+
+		case PLATFORM_INVALID_PARAMETER:
+			return SII_ERR_INVALID_PARAMETER;
+
+		case PLATFORM_I2C_READ_FAIL:
+		case PLATFORM_I2C_WRITE_FAIL:
+		default:
+			return SII_ERR_FAIL;
+	}
+}
+
+SiiResultCodes_t CraReadBlockI2c (deviceBusTypes_t busIndex, uint8_t deviceId, uint8_t regAddr, uint8_t *pBuffer, uint16_t count )
+{
+	SiiI2cMsg_t			msgs[2];
+	SiiPlatformStatus_t	platformStatus;
+    SiiResultCodes_t	status = SII_ERR_FAIL;
+    int retryTimes = 3;
+
+    msgs[0].addr = deviceId;
+    msgs[0].cmdFlags = 0;
+    msgs[0].len = 1;
+    msgs[0].pBuf = &regAddr;
+
+    msgs[1].addr = deviceId;
+    msgs[1].cmdFlags = SII_MI2C_RD;
+    msgs[1].len = count;
+    msgs[1].pBuf = pBuffer;
+
+    do
+    {
+        platformStatus = SiiMasterI2cTransfer(busIndex, msgs, 2);
+        if (!platformStatus)
+            break;
+    }while(retryTimes--);
+
+    if(platformStatus)
+    {
+        memset(pBuffer,0xFF,count);
+    }
+
+	status = TranslatePlatformStatus(platformStatus);
+    return( status );
+}
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+
+SiiResultCodes_t CraWriteBlockI2c (deviceBusTypes_t busIndex, uint8_t deviceId, uint8_t regAddr, const uint8_t *pBuffer, uint16_t count )
+{
+	SiiI2cMsg_t			msgs[2];
+	SiiPlatformStatus_t	platformStatus;
+    SiiResultCodes_t	status = SII_ERR_FAIL;
+
+
+    msgs[0].addr = deviceId;
+    msgs[0].cmdFlags = SII_MI2C_APPEND_NEXT_MSG;
+    msgs[0].len = 1;
+    msgs[0].pBuf = &regAddr;
+
+    msgs[1].addr = 0;
+    msgs[1].cmdFlags = 0;
+    msgs[1].len = count;
+    msgs[1].pBuf = (uint8_t*)pBuffer;	// cast gets rid of const warning
+
+	platformStatus = SiiMasterI2cTransfer(busIndex, msgs, 2);
+
+	status = TranslatePlatformStatus(platformStatus);
+
+    return( status );
+}
+
+#else
+
+static SiiResultCodes_t CraReadBlockI2c (int_t busIndex, uint8_t deviceId, uint8_t regAddr, uint8_t *pBuffer, uint16_t count )
+{
+    SiiResultCodes_t status = SII_ERR_FAIL;
+
+    do {
+        // Send the register address and stop bit
+        if ( I2cSendStart( busIndex, deviceId, &regAddr, 1, FALSE ) != PLATFORM_SUCCESS )
+        {
+            break;
+        }
+        // Receive the requested number of data bytes
+        if ( I2cReceiveStart( busIndex, deviceId, pBuffer, count, TRUE ) != PLATFORM_SUCCESS )
+        {
+            break;
+        }
+
+        status = SII_SUCCESS;
+    } while (0);
+
+    return( status );
+}
+
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+
+static SiiResultCodes_t CraWriteBlockI2c ( int_t busIndex, uint8_t deviceId, uint8_t regAddr, const uint8_t *pBuffer, uint16_t count )
+{
+    SiiResultCodes_t status = SII_ERR_FAIL;
+
+    do {
+        // Send the register address but don't send stop
+        if ( I2cSendStart( busIndex, deviceId, &regAddr, 1, FALSE ) != PLATFORM_SUCCESS )
+        {
+            break;
+        }
+        // Send the remainder of the data, if necessary
+        if ( I2cSendContinue( busIndex, pBuffer, count, TRUE ) != PLATFORM_SUCCESS )
+        {
+            break;
+        }
+        status = SII_SUCCESS;
+    } while (0);
+
+    return( status );
+}
+#endif //_KERNEL_
+
+//------------------------------------------------------------------------------
+// Function:    SiiCraInitialize
+// Description: Initialize the CRA page instance array and perform any register
+//              page base address reassignments required.
+// Parameters:  none
+// Returns:     None
+//------------------------------------------------------------------------------
+
+bool_t SiiCraInitialize ( void )
+{
+    uint8_t i, index;
+    craInstance.lastResultCode = RESULT_CRA_SUCCESS;
+
+    for (i = 0; i < SII_CRA_DEVICE_PAGE_COUNT; i++)
+    {
+        l_pageInstance[i] = 0;
+    }
+
+    // Perform any register page base address reassignments
+    i = 0;
+    while ( g_siiRegPageBaseReassign[ i] != 0xFFFF )
+    {
+        index = g_siiRegPageBaseReassign[ i] >> 8;
+        if (( index < SII_CRA_DEVICE_PAGE_COUNT ) && ( g_siiRegPageBaseRegs[ index] != 0xFF))
+        {
+            // The page base registers allow reassignment of the
+            // I2C device ID for almost all device register pages.
+            SiiRegWrite( g_siiRegPageBaseRegs[ index], g_siiRegPageBaseReassign[ index] & 0x00FF );
+        }
+        else
+        {
+            craInstance.lastResultCode = SII_ERR_INVALID_PARAMETER;
+            break;
+        }
+        i++;
+    }
+
+    return( craInstance.lastResultCode == RESULT_CRA_SUCCESS );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiCraGetLastResult
+// Description: Returns the result of the last call to a CRA driver function.
+// Parameters:  none.
+// Returns:     Returns the result of the last call to a CRA driver function
+//------------------------------------------------------------------------------
+
+SiiResultCodes_t SiiCraGetLastResult ( void )
+{
+    return( craInstance.lastResultCode );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiRegInstanceSet
+// Description: Sets the instance for subsequent register accesses.  The register
+//              access functions use this value as an instance index of the multi-
+//              dimensional virtual address lookup table.
+// Parameters:  newInstance - new value for instance axis of virtual address table.
+// Returns:     None
+//------------------------------------------------------------------------------
+
+bool_t SiiRegInstanceSet ( SiiReg_t virtualAddress, uint8_t newInstance )
+{
+    uint8_t va = virtualAddress >> 8;
+
+    craInstance.lastResultCode = RESULT_CRA_SUCCESS;
+    if (( va < SII_CRA_DEVICE_PAGE_COUNT) && ( newInstance < SII_CRA_MAX_DEVICE_INSTANCES ))
+    {
+        l_pageInstance[ va ] = newInstance;
+        return( TRUE );
+    }
+
+    craInstance.lastResultCode = SII_ERR_INVALID_PARAMETER;
+    return( FALSE );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiRegReadBlock
+// Description: Reads a block of data from sequential registers.
+// Parameters:  regAddr - Sixteen bit register address, including device page.
+// Returns:     None
+//
+// NOTE:        This function relies on the auto-increment model used by
+//              Silicon Image devices.  Because of this, if a FIFO register
+//              is encountered before the end of the requested count, the
+//              data remaining from the count is read from the FIFO, NOT
+//              from subsequent registers.
+//------------------------------------------------------------------------------
+
+void SiiRegReadBlock ( SiiReg_t virtualAddr, uint8_t *pBuffer, uint16_t count )
+{
+    uint8_t             regOffset = (uint8_t)virtualAddr;
+    pageConfig_t        *pPage;
+    SiiResultCodes_t    status = SII_ERR_FAIL;
+    virtualAddr >>= 8;
+    pPage = &g_addrDescriptor[l_pageInstance[virtualAddr]][virtualAddr];
+    switch ( pPage->busType )
+    {
+        case DEV_I2C_0:
+            status = CraReadBlockI2c( DEV_I2C_0, (uint8_t)pPage->address, regOffset, pBuffer, count );
+            break;
+        case DEV_I2C_2:
+            status = CraReadBlockI2c( DEV_I2C_2, (uint8_t)pPage->address, regOffset, pBuffer, count );
+            break;
+        case DEV_I2C_0_OFFSET:
+            status = CraReadBlockI2c( DEV_I2C_0, (uint8_t)pPage->address, regOffset + (uint8_t)(pPage->address >> 8), pBuffer, count );
+            break;
+        case DEV_I2C_2_OFFSET:
+            status = CraReadBlockI2c( DEV_I2C_2, (uint8_t)pPage->address, regOffset + (uint8_t)(pPage->address >> 8), pBuffer, count );
+            break;
+
+        default:
+            break;
+    }
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiRegRead
+// Description: Read a one byte register.
+//              The register address parameter is translated into an I2C slave
+//              address and offset. The I2C slave address and offset are used
+//              to perform an I2C read operation.
+//------------------------------------------------------------------------------
+
+uint8_t SiiRegRead ( SiiReg_t virtualAddr )
+{
+    uint8_t             value = 0xFF;
+    uint8_t             regOffset = (uint8_t)virtualAddr;
+    pageConfig_t        *pPage;
+    SiiResultCodes_t    status = SII_ERR_FAIL;
+
+    virtualAddr >>= 8;
+    pPage = &g_addrDescriptor[l_pageInstance[virtualAddr]][virtualAddr];
+
+    switch ( pPage->busType )
+    {
+        case DEV_I2C_0:
+            status = CraReadBlockI2c( DEV_I2C_0, (uint8_t)pPage->address, regOffset, &value, 1 );
+            break;
+        case DEV_I2C_2:
+            status = CraReadBlockI2c( DEV_I2C_2, (uint8_t)pPage->address, regOffset, &value, 1 );
+            break;
+        case DEV_I2C_0_OFFSET:
+            status = CraReadBlockI2c( DEV_I2C_0, (uint8_t)pPage->address, regOffset + (uint8_t)(pPage->address >> 8), &value, 1 );
+            break;
+        case DEV_I2C_2_OFFSET:
+            status = CraReadBlockI2c( DEV_I2C_2, (uint8_t)pPage->address, regOffset + (uint8_t)(pPage->address >> 8), &value, 1 );
+            break;
+
+        default:
+            break;
+    }
+    return( value );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiRegWriteBlock
+// Description: Writes a block of data to sequential registers.
+// Parameters:  regAddr - Sixteen bit register address, including device page.
+// Returns:     None
+//
+// NOTE:        This function relies on the auto-increment model used by
+//              Silicon Image devices.  Because of this, if a FIFO register
+//              is encountered before the end of the requested count, the
+//              data remaining from the count is read from the FIFO, NOT
+//              from subsequent registers.
+//------------------------------------------------------------------------------
+
+void SiiRegWriteBlock ( SiiReg_t virtualAddr, const uint8_t *pBuffer, uint16_t count )
+{
+    uint8_t             regOffset = (uint8_t)virtualAddr;
+    pageConfig_t        *pPage;
+    SiiResultCodes_t    status = SII_ERR_FAIL;
+
+    virtualAddr >>= 8;
+    pPage = &g_addrDescriptor[l_pageInstance[virtualAddr]][virtualAddr];
+
+    switch ( pPage->busType )
+    {
+        case DEV_I2C_0:
+            status = CraWriteBlockI2c( DEV_I2C_0, (uint8_t)pPage->address, regOffset, pBuffer, count );
+            break;
+        case DEV_I2C_2:
+            status = CraWriteBlockI2c( DEV_I2C_2, (uint8_t)pPage->address, regOffset, pBuffer, count );
+            break;
+        case DEV_I2C_0_OFFSET:
+            status = CraWriteBlockI2c( DEV_I2C_0, (uint8_t)pPage->address, regOffset + (uint8_t)(pPage->address >> 8), pBuffer, count );
+            break;
+        case DEV_I2C_2_OFFSET:
+            status = CraWriteBlockI2c( DEV_I2C_2, (uint8_t)pPage->address, regOffset + (uint8_t)(pPage->address >> 8), pBuffer, count );
+            break;
+
+        default:
+            break;
+    }
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Read a value of word from the specified register
+ *
+ *  @param[in]		reg_addr		register address
+ *
+ *  @return	Word read from the specified register
+ *
+ *****************************************************************************/
+uint16_t SiiRegReadWord(SiiReg_t reg_addr)
+{
+	uint8_t buffer[2];
+	SiiRegReadBlock(reg_addr, buffer, 2);
+	return buffer[0] | (((uint16_t) buffer[1]) << 8);
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief		Write a value of word into the specified register
+ *
+ *  @param[in]		reg_addr		register address
+ *  @param[in]		value		value to write to register
+ *
+ *****************************************************************************/
+void SiiRegWriteWord(SiiReg_t reg_addr, uint16_t value)
+{
+	uint8_t buffer[2];
+	buffer[0] = (uint8_t) value;
+	buffer[1] = (uint8_t) (value >> 8);
+	SiiRegWriteBlock(reg_addr, buffer, 2);
+}
+
+
+//------------------------------------------------------------------------------
+// Function:    SiiRegWrite
+// Description: Write a one byte register.
+//              The register address parameter is translated into an I2C slave
+//              address and offset. The I2C slave address and offset are used
+//              to perform an I2C write operation.
+//------------------------------------------------------------------------------
+
+void SiiRegWrite ( SiiReg_t virtualAddr, uint8_t value )
+{
+    uint8_t             regOffset = (uint8_t)virtualAddr;
+    pageConfig_t        *pPage;
+
+    SiiResultCodes_t    status = SII_ERR_FAIL;
+    virtualAddr >>= 8;
+    pPage = &g_addrDescriptor[l_pageInstance[virtualAddr]][virtualAddr];
+
+    switch ( pPage->busType )
+    {
+        case DEV_I2C_0:
+            status = CraWriteBlockI2c( DEV_I2C_0, (uint8_t)pPage->address, regOffset, &value, 1 );
+            break;
+        case DEV_I2C_2:
+            status = CraWriteBlockI2c( DEV_I2C_2, (uint8_t)pPage->address, regOffset, &value, 1 );
+            break;
+        case DEV_I2C_0_OFFSET:
+            status = CraWriteBlockI2c( DEV_I2C_0, (uint8_t)pPage->address, regOffset + (uint8_t)(pPage->address >> 8), &value, 1 );
+            break;
+        case DEV_I2C_2_OFFSET:
+            status = CraWriteBlockI2c( DEV_I2C_2, (uint8_t)pPage->address, regOffset + (uint8_t)(pPage->address >> 8), &value, 1 );
+            break;
+
+        default:
+            break;
+    }
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiRegModify
+// Description: Reads the register, performs an AND function on the data using
+//              the mask parameter, and an OR function on the data using the
+//              value ANDed with the mask. The result is then written to the
+//              device register specified in the regAddr parameter.
+// Parameters:  regAddr - Sixteen bit register address, including device page.
+//              mask    - Eight bit mask
+//              value   - Eight bit data to be written, combined with mask.
+// Returns:     None
+//------------------------------------------------------------------------------
+
+void SiiRegModify ( SiiReg_t virtualAddr, uint8_t mask, uint8_t value)
+{
+    uint8_t aByte;
+
+    aByte = SiiRegRead( virtualAddr );
+    aByte &= (~mask);                       // first clear all bits in mask
+    aByte |= (mask & value);                // then set bits from value
+    SiiRegWrite( virtualAddr, aByte );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiRegBitsSet
+// Description: Reads the register, sets the passed bits, and writes the
+//              result back to the register.  All other bits are left untouched
+// Parameters:  regAddr - Sixteen bit register address, including device page.
+//              bits   - bit data to be written
+// Returns:     None
+//------------------------------------------------------------------------------
+
+void SiiRegBitsSet ( SiiReg_t virtualAddr, uint8_t bitMask, bool_t setBits )
+{
+    uint8_t aByte;
+
+    aByte = SiiRegRead( virtualAddr );
+    aByte = (setBits) ? (aByte | bitMask) : (aByte & ~bitMask);
+    SiiRegWrite( virtualAddr, aByte );
+}
+
+//------------------------------------------------------------------------------
+// Function:    SiiRegBitsSetNew
+// Description: Reads the register, sets or clears the specified bits, and
+//              writes the result back to the register ONLY if it would change
+//              the current register contents.
+// Parameters:  regAddr - Sixteen bit register address, including device page.
+//              bits   - bit data to be written
+//              setBits- TRUE == set, FALSE == clear
+// Returns:     None
+//------------------------------------------------------------------------------
+
+void SiiRegBitsSetNew ( SiiReg_t virtualAddr, uint8_t bitMask, bool_t setBits )
+{
+    uint8_t newByte, oldByte;
+
+    oldByte = SiiRegRead( virtualAddr );
+    newByte = (setBits) ? (oldByte | bitMask) : (oldByte & ~bitMask);
+    if ( oldByte != newByte )
+    {
+        SiiRegWrite( virtualAddr, newByte );
+    }
+}
+#if 0
+//------------------------------------------------------------------------------
+// Function:    SiiRegEdidReadBlock
+// Description: Reads a block of data from EDID record over DDC link.
+// Parameters:  segmentAddr - EDID segment address (16 bit), including device page;
+//              offsetAddr  - Sixteen bit register address, including device page.
+// Returns:     success flag
+//
+//------------------------------------------------------------------------------
+
+void SiiRegEdidReadBlock ( SiiReg_t segmentAddr, SiiReg_t virtualAddr, uint8_t *pBuffer, uint16_t count )
+{
+    uint8_t             regOffset = (uint8_t)virtualAddr;
+    pageConfig_t        *pPage;
+
+    SiiResultCodes_t    status = SII_ERR_FAIL;
+
+    if ((segmentAddr & 0xFF) != 0)  // Default segment #0 index should not be sent explicitly
+    {
+        regOffset = (uint8_t)segmentAddr;
+        segmentAddr >>= 8;
+        pPage = &g_addrDescriptor[l_pageInstance[segmentAddr]][segmentAddr];
+        // Write the segment number to the EDID device ID, but don't send the stop
+        I2cSendStart( pPage->busType, pPage->address, &regOffset, 1, FALSE );
+    }
+
+    // Read the actual EDID data
+    regOffset = (uint8_t)virtualAddr;
+    virtualAddr >>= 8;
+    pPage = &g_addrDescriptor[l_pageInstance[virtualAddr]][virtualAddr];
+
+    status = CraReadBlockI2c( pPage->busType, pPage->address, regOffset, pBuffer, count );
+
+}
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra.h
new file mode 100755
index 000000000000..12f2e8dc78ad
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra.h
@@ -0,0 +1,62 @@
+//***************************************************************************
+//!file     si_cra.h
+//!brief    Silicon Image Device register I/O support.
+//***************************************************************************/
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+
+
+#ifndef __SI_CRA_H__
+#define __SI_CRA_H__
+
+#include "si_common.h"
+#include "si_drv_cra_cfg.h"
+
+typedef uint16_t    SiiReg_t;
+
+// Standard result codes are in the range of 0 - 4095
+typedef enum _SiiResultCodes_t
+{
+    SII_SUCCESS      = 0,            // Success.
+    SII_ERR_FAIL,                   // General failure.
+    SII_ERR_INVALID_PARAMETER,      //
+    SII_ERR_IN_USE,                  // Module already initialized.
+    SII_ERR_NOT_AVAIL,               // Allocation of resources failed.
+} SiiResultCodes_t;
+
+#if defined(__KERNEL__)
+SiiResultCodes_t CraReadBlockI2c (deviceBusTypes_t busIndex, uint8_t deviceId, uint8_t regAddr, uint8_t *pBuffer, uint16_t count );
+SiiResultCodes_t CraWriteBlockI2c (deviceBusTypes_t busIndex, uint8_t deviceId, uint8_t regAddr, const uint8_t *pBuffer, uint16_t count );
+#endif
+bool_t SiiCraInitialize( void );
+SiiResultCodes_t SiiCraGetLastResult( void );
+bool_t SiiRegInstanceSet( SiiReg_t virtualAddress, uint8_t newInstance );
+
+void    SiiRegReadBlock ( SiiReg_t virtualAddr, uint8_t *pBuffer, uint16_t count );
+uint8_t SiiRegRead ( SiiReg_t virtualAddr );
+void    SiiRegWriteBlock ( SiiReg_t virtualAddr, const uint8_t *pBuffer, uint16_t count );
+void    SiiRegWrite ( SiiReg_t virtualAddr, uint8_t value );
+uint16_t SiiRegReadWord(SiiReg_t reg_addr);
+void SiiRegWriteWord(SiiReg_t reg_addr, uint16_t value);
+void    SiiRegModify ( SiiReg_t virtualAddr, uint8_t mask, uint8_t value);
+void    SiiRegBitsSet ( SiiReg_t virtualAddr, uint8_t bitMask, bool_t setBits );
+void    SiiRegBitsSetNew ( SiiReg_t virtualAddr, uint8_t bitMask, bool_t setBits );
+
+// Special purpose
+void    SiiRegEdidReadBlock ( SiiReg_t segmentAddr, SiiReg_t virtualAddr, uint8_t *pBuffer, uint16_t count );
+
+#endif  // __SI_CRA_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra_internal.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra_internal.h
new file mode 100755
index 000000000000..9ea0767bdd64
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_cra_internal.h
@@ -0,0 +1,107 @@
+//***************************************************************************
+//!file     si_drv_cra_internal.h
+//!brief    Silicon Image CRA internal driver functions.
+//***************************************************************************/
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+
+#ifndef __SI_CRA_DRV_INTERNAL_H__
+#define __SI_CRA_DRV_INTERNAL_H__
+
+//-------------------------------------------------------------------------------
+// CRA Enums and manifest constants
+//-------------------------------------------------------------------------------
+
+typedef enum _SiiDrvCraError_t
+{
+    RESULT_CRA_SUCCESS,             // Success result code
+    RESULT_CRA_FAIL,                // General Failure result code
+    RESULT_CRA_INVALID_PARAMETER,   // One or more invalid parameters
+} SiiDrvCraError_t;
+
+//------------------------------------------------------------------------------
+//  CRA Driver Instance Data
+//------------------------------------------------------------------------------
+
+typedef struct _CraInstanceData_t
+{
+    int                 structVersion;
+    int                 instanceIndex;
+    SiiDrvCraError_t    lastResultCode;     // Contains the result of the last API function called
+    uint16_t            statusFlags;
+}	CraInstanceData_t;
+
+extern CraInstanceData_t craInstance;
+
+#ifdef __KERNEL__
+
+/**
+ * Status return values returned by platform specific CRA layer support functions.
+ */
+typedef enum _SiiPlatformStatus_t
+{
+    PLATFORM_SUCCESS,
+    PLATFORM_FAIL,              // General fail
+    PLATFORM_INVALID_PARAMETER,
+    PLATFORM_I2C_READ_FAIL,
+    PLATFORM_I2C_WRITE_FAIL,
+    PLATFORM_MMIO_READ_FAIL,
+    PLATFORM_MMIO_WRITE_FAIL,
+} SiiPlatformStatus_t;
+
+
+
+typedef struct
+{
+	uint16_t addr;							/**< slave address */
+	uint16_t cmdFlags;						/**< flags defining message actions */
+#define SII_MI2C_TEN	0x0010				/**< set for ten bit chip address; cleared
+ 	 	 	 	 	 	 	 	 	 	 	 	 otherwise */
+#define SII_MI2C_RD		0x0001				/**< set for read data operation; cleared for
+ 	 	 	 	 	 	 	 	 	 	 	 	 write operations */
+#define SII_MI2C_APPEND_NEXT_MSG	0x0002	/**< append the buffer from the next message to
+												 this message */
+	uint16_t len;							/**< buffer length */
+	uint8_t *pBuf;							/**< pointer to input (for write operations)
+	 	 	 	 	 	 	 	 	 			 or output (for read operations) buffer */
+} SiiI2cMsg_t;
+
+#define MAX_I2C_TRANSFER	255		/* Maximum # of bytes in a single I2c transfer */
+#define MAX_I2C_MESSAGES	3		/* Maximum # of I2c message segments supported
+									   by SiiMasterI2cTransfer					   */
+
+/*****************************************************************************/
+/**
+ * @brief CRA platform interface function called to perform I2C bus transfers.
+ *
+ * This function is called by the Common Register Access (CRA) driver when it
+ * needs to perform a transfer to/from register(s) that are accessed over an
+ * I2C bus.  The function executes msgNum messages (I2C sub-transactions).
+ * Each message is an I2C transaction starting with a start condition.  The
+ * stop condition is sent only after the last message is executed.
+ *
+ *  @param[in]		busIndex		Selects the physical I2C bus to be used.
+ *  								Can be ignored if only one I2C bus in system.
+ *  @param[in]		pMsgs			Array of I2C messages to be sent..
+ *  @param[in]		msgNum			Value to write to register.
+ *
+ *****************************************************************************/
+SiiPlatformStatus_t SiiMasterI2cTransfer(deviceBusTypes_t busIndex,
+										 SiiI2cMsg_t *pMsgs, uint8_t msgNum);
+#endif
+
+#endif // __SI_CRA_DRV_INTERNAL_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_drv_cra_cfg.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_drv_cra_cfg.c
new file mode 100755
index 000000000000..8c0f0540e988
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_drv_cra_cfg.c
@@ -0,0 +1,98 @@
+//***************************************************************************
+//!file     si_drv_cra_cfg.c
+//!brief    Silicon Image 5293 Starter Kit Firmware CRA configuration data.
+//
+// No part of this work may be reproduced, modified, distributed, 
+// transmitted, transcribed, or translated into any language or computer 
+// format, in any form or by any means without written permission of 
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2008-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+#include "si_cra.h"
+#include "si_drv_cra_cfg.h"
+
+
+// Index to this array is the virtual page number in the MSB of the REG_xxx address values
+// Indexed with siiRegPageIndex_t value shifted right 8 bits
+// DEV_PAGE values must correspond to the order specified in the SiiRegPageIndex_t enum list
+pageConfig_t    g_addrDescriptor[SII_CRA_MAX_DEVICE_INSTANCES][SII_CRA_DEVICE_PAGE_COUNT] =
+{
+#if (FPGA_BUILD_NEW == 1)
+
+    // Instance 0
+    {
+    { DEV_I2C_2,        DEV_PAGE_PP_0   },    // System Control and Status
+    { DEV_I2C_2,        DEV_PAGE_PP_1   },    // MHL
+    { DEV_I2C_2,        DEV_PAGE_PP_2   },    // System Control and Status
+    { DEV_I2C_2,        DEV_PAGE_PP_3   },    // not used
+    { DEV_I2C_2,        DEV_PAGE_PP_4   },    // not used
+    { DEV_I2C_2,        DEV_PAGE_PP_5   },    // not used
+    { DEV_I2C_2,        DEV_PAGE_PP_6   },    // not used
+    { DEV_I2C_2,        DEV_PAGE_PP_7   },    // not used
+    { DEV_I2C_2,        DEV_PAGE_PP_8   },    // CPI
+    { DEV_I2C_2,        DEV_PAGE_PP_9   },    // Video RGB2xvYCC Reg and rvs control / VSI control and status
+    { DEV_I2C_2,        DEV_PAGE_PP_A   },    // not used
+    { DEV_I2C_2,        DEV_PAGE_PP_B   },    // not used
+    { DEV_I2C_2,        DEV_PAGE_PP_C   },    // CBUS
+    { DEV_I2C_2,        DEV_PAGE_HEAC   },    // HEAC
+    { DEV_I2C_2,        DEV_PAGE_OSD    },    // OSD
+    { DEV_I2C_2_OFFSET,   0x0000 + DEV_PAGE_AUDIO },    // Audio Extraction instance 1
+    }
+	
+#else
+
+    // Instance 0
+    {
+    { DEV_I2C_0,        DEV_PAGE_PP_0   },    // System Control and Status
+    { DEV_I2C_0,        DEV_PAGE_PP_1   },    // MHL
+    { DEV_I2C_0,        DEV_PAGE_PP_2   },    // System Control and Status
+    { DEV_I2C_0,        DEV_PAGE_PP_3   },    // not used
+    { DEV_I2C_0,        DEV_PAGE_PP_4   },    // not used
+    { DEV_I2C_0,        DEV_PAGE_PP_5   },    // not used
+    { DEV_I2C_0,        DEV_PAGE_PP_6   },    // not used
+    { DEV_I2C_0,        DEV_PAGE_PP_7   },    // not used
+    { DEV_I2C_0,        DEV_PAGE_PP_8   },    // CPI
+    { DEV_I2C_0,        DEV_PAGE_PP_9   },    // Video RGB2xvYCC Reg and rvs control / VSI control and status
+    { DEV_I2C_0,        DEV_PAGE_PP_A   },    // not used
+    { DEV_I2C_0,        DEV_PAGE_PP_B   },    // not used
+    { DEV_I2C_0,        DEV_PAGE_PP_C   },    // CBUS
+    { DEV_I2C_0,        DEV_PAGE_HEAC   },    // HEAC
+    { DEV_I2C_0,        DEV_PAGE_OSD    },    // OSD
+    { DEV_I2C_0_OFFSET,   0x0000 + DEV_PAGE_AUDIO },    // Audio Extraction instance 1
+    }
+
+#endif
+};
+
+// Register addresses for re-assigning page base addresses
+// These registers specify the I2C address that the SI device will
+// respond to for the specific control register page
+SiiReg_t g_siiRegPageBaseRegs [SII_CRA_DEVICE_PAGE_COUNT] =
+{
+    PP_PAGE | 0xFF,     // Device Base  - Cannot be reassigned
+    PP_PAGE | 0xFF,     // Unused       - Cannot be reassigned
+    PP_PAGE | 0x11,     // RX TMDS
+    PP_PAGE | 0x44,     // IPV
+    PP_PAGE | 0x12,     // RX TMDS
+    PP_PAGE | 0x13,     // PA Pages 5,6,7 have special mapping requirements
+    PP_PAGE | 0x13,     // PA
+    PP_PAGE | 0x13,     // PA
+    PP_PAGE | 0x18,     // CPI
+    PP_PAGE | 0x19,     // NVRAM/GPIO
+    PP_PAGE | 0x15,     // RX TMDS
+    PP_PAGE | 0x14,     // TX TMDS
+    PP_PAGE | 0x17,     // CBUS
+    PP_PAGE | 0x16,     // HEAC
+    PP_PAGE | 0x42,     // OSD
+    PP_PAGE | 0x43,     // Audio extraction
+};
+
+// TODO:OEM - Add entries to reassign register page base addresses if needed
+SiiReg_t g_siiRegPageBaseReassign [] =
+{
+//        PP_PAGE_3 | 0xFC,       // Example of changing default page 3 device ID (0xFA) to 0xFC
+
+        0xFFFF      // End of reassignment list
+};
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_drv_cra_cfg.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_drv_cra_cfg.h
new file mode 100755
index 000000000000..12ed138176d4
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/cra_drv/si_drv_cra_cfg.h
@@ -0,0 +1,86 @@
+//***************************************************************************
+//!file     si_drv_cra_cfg.h
+//!brief    Silicon Image Device CRA configuration data.
+//
+// No part of this work may be reproduced, modified, distributed, 
+// transmitted, transcribed, or translated into any language or computer 
+// format, in any form or by any means without written permission of 
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2008-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+#ifndef __SI_DRV_CRA_CFG_H__
+#define __SI_DRV_CRA_CFG_H__
+
+typedef enum _deviceBusTypes_t
+{
+    // The following four should remain together because they are used
+    // as bus indices for the CraWriteBlockI2c and CraReadBlockI2c functions
+    DEV_I2C_0,          // Main I2C bus
+    DEV_I2C_1,          // Separate I2C bus
+    DEV_I2C_2,          // Separate I2C bus
+    DEV_I2C_3,          // Separate I2C bus
+    DEV_I2C_0_OFFSET,     // Main I2C bus with register offset
+    DEV_I2C_2_OFFSET,     // Separate I2C bus with register offset
+    
+    DEV_DDC_0,          // DDC bus for TX 0
+    DEV_DDC_1,          // DDC bus for TX 1
+
+    DEV_PARALLEL,       // Parallel interface
+} deviceBusTypes_t;
+
+// Actual I2C page addresses for the various devices
+// TODO:OEM - If a device ID has been reassigned, update it here AND in
+//            the g_siiRegPageBaseReassign[] array
+typedef enum _devicePageIds_t
+{
+    DEV_PAGE_PP_0       = (0x64),
+    DEV_PAGE_PP_1       = (0xD0),
+    DEV_PAGE_PP_2       = (0x68),
+    DEV_PAGE_PP_3       = (0x76),
+    DEV_PAGE_PP_4       = (0x7E),
+    DEV_PAGE_PP_5       = (0x50),
+    DEV_PAGE_PP_6       = (0x52),
+    DEV_PAGE_PP_7       = (0x54),
+    DEV_PAGE_PP_8       = (0x80),
+    DEV_PAGE_PP_9       = (0xE0),
+    DEV_PAGE_PP_A       = (0x64),
+    DEV_PAGE_PP_B       = (0x90),
+    DEV_PAGE_PP_C       = (0xC0),
+    DEV_PAGE_HEAC       = (0xD0),
+    DEV_PAGE_OSD         = (0xF0),
+    DEV_PAGE_AUDIO     = (0x30),
+} devicePageIds_t;
+
+// Index into pageConfig_t array (shifted left by 8)
+typedef enum _SiiRegPageIndex_t
+{
+    PP_PAGE               = 0x0000,   // System Control and Status
+    PP_PAGE_1           = 0x0100,   // MHL Registers
+    PP_PAGE_2           = 0x0200,   // System Control and Status
+    PP_PAGE_3           = 0x0300,   // Evita
+    PP_PAGE_4           = 0x0400,   // Evita
+    PP_PAGE_5           = 0x0500,   // not used
+    PP_PAGE_6           = 0x0600,   // not used
+    PP_PAGE_7           = 0x0700,   // not used
+    CPI_PAGE              = 0x0800,   // CEC bus interface registers for Rx
+    PP_PAGE_9           = 0x0900,   // Video RGB2xvYCC Reg and rvs control / VSI control and status
+    PP_PAGE_A           = 0x0A00,   // not used
+    PP_PAGE_B           = 0x0B00,   // not used
+    CBUS_PAGE           = 0x0C00,   // CBUS Registers
+    PP_PAGE_HEAC     = 0x0D00,   // not used
+    PP_PAGE_OSD       = 0x0E00,   // not used
+    PP_PAGE_AUDIO   = 0x0F00,   // not used
+} SiiRegPageIndex_t;
+
+#define SII_CRA_MAX_DEVICE_INSTANCES   1  // Maximum size of instance dimension of address descriptor array
+#define SII_CRA_DEVICE_PAGE_COUNT       16  // Number of entries in pageConfig_t array
+
+typedef struct pageConfig
+{
+    deviceBusTypes_t    busType;    // I2C, Parallel
+    char               address;             // I2C DEV ID, parallel mem offset
+} pageConfig_t;
+
+#endif  // __SI_DRV_CRA_CFG_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_hawb.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_hawb.c
new file mode 100755
index 000000000000..70d9016a7ddc
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_hawb.c
@@ -0,0 +1,162 @@
+/******************************************************************************/
+//!file     si_drv_hawb.c
+//!brief    SiI5293 HAWB Control  Driver.
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2007-2013, Silicon Image, Inc.  All rights reserved.
+/******************************************************************************/
+
+#include "si_drv_cbus.h"
+#include "si_cbus_enums.h"
+#include "si_drv_board.h"
+#include "si_drv_hawb.h"
+#include "si_edid_3d_internal.h"
+#include "si_drv_mhawb.h"
+
+
+/*****************************************************************************/
+/**
+ *  @brief		Initialize HAWB mask registers
+ *              Note: HAWB masks may be cleared after XFIFO write.
+ *                    Need forced recovery as SWWA.
+ *
+ *****************************************************************************/
+void SiiDrvHawbInitMask(void)
+{
+    SiiRegWrite( REG_HAWB_INTR_MASK, 0x0C );
+    SiiRegWrite( REG_HAWB_ERROR_INTR_MASK, 0xE7 );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Initialize HAWB
+ *
+ *****************************************************************************/
+void SiiDrvHawbInit(void)
+{
+    //xyu: this function is not used in current code
+    // SiiRegWrite( REG_HAWB_INTR, 0xFF );            // [0x8C]; Clear the interrupt bits
+    SiiRegWrite( REG_HAWB_RCV_TIMEOUT, 0x3F );     // RSM Timeout // 0x02
+    SiiRegWrite( REG_HAWB_XMIT_TIMEOUT, 0x3F );    // XSM Timeout // 0x02
+    SiiRegWrite( REG_HAWB_XMIT_CTRL, 0x00 );
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Send out the 3D Write Burst infomation using HAWB
+ *
+ *  @param[in]         enableRx		true - enable rx, false - disable rx
+ *
+ *  @return[out]        bool_t             true - success, false - current state is takeover, cannot change now
+ *
+ *****************************************************************************/
+bool_t SiiDrvHawbEnable(bool_t enableTx )
+{  
+    //since there's no work to do; don't waste time with I2C
+    if (enableTx == false)
+    {
+         if (g_mhawb.state == MHAWB_STATE_DISABLED || g_mhawb.state == MHAWB_STATE_UNINITIALIZED)
+         {
+            return true;
+         }
+         else if (g_mhawb.state == MHAWB_STATE_TAKEOVER)
+         {
+            return false;
+         }
+    }
+    else if (enableTx == true)
+    {
+        if (g_mhawb.state == MHAWB_STATE_TAKEOVER)
+        {
+            return false;
+        }
+        else if (g_mhawb.state != MHAWB_STATE_DISABLED)
+        {
+            return true;
+        }
+    }
+
+    DEBUG_PRINT( MSG_ALWAYS, "[HAWB] %s TX\n", enableTx ? "Enable" : "Disable" );
+
+    //SiiRegWrite( REG_HAWB_INTR, BIT_HAWB_FW_TAKEOVER);  //Clear Fake TAKEOVER interrupt
+    SiiRegBitsSet( REG_HAWB_XMIT_CTRL, BIT_HAWB_XMIT_EN, enableTx );    // [0x88][7] = 1 to enable MDT TX
+
+    if (enableTx == false)
+    {
+        SiiRegWrite( REG_HAWB_INTR_MASK, BIT_HAWB_FW_TAKEOVER);
+        SiiRegWrite( REG_HAWB_ERROR_INTR_MASK, 0x00);
+        g_mhawb.state = MHAWB_STATE_TAKEOVER;
+        return false;
+    }else
+    {
+        g_mhawb.state = MHAWB_STATE_INIT;
+        mhawb_do_work();
+        return true;
+    }
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief		Process Hardware Assistant Write Burst interrupts
+ *
+ *****************************************************************************/
+void SiiDrvHawbProcessInterrupts(void)
+{
+    uint8_t intStatus, intStatusError;
+
+    intStatus = SiiRegRead( REG_HAWB_INTR );
+    SiiRegWrite( REG_HAWB_INTR, intStatus );
+
+    intStatusError = SiiRegRead( REG_HAWB_ERROR_INTR );
+    SiiRegWrite( REG_HAWB_ERROR_INTR, intStatusError );
+
+    if ( intStatus & BIT_HAWB_XFIFO_EMPTY )
+    {
+#ifndef __KERNEL__
+        hawb3DXfifoEmptyFlag = true;
+#endif
+        DEBUG_PRINT( MSG_ALWAYS, "[HAWB] Got INTR: XFIFO Empty!\n" );
+    }
+
+    if ( intStatus & BIT_HAWB_FW_TAKEOVER )
+    {
+        if (g_mhawb.state == MHAWB_STATE_TAKEOVER)
+        {
+            DEBUG_PRINT( MSG_ALWAYS, "[HAWB] Got INTR: FW TakeOver!\n" );
+            g_mhawb.state = MHAWB_STATE_DISABLED;
+        }
+    }
+
+    // Error notifications for application
+    if ( intStatusError & BIT_HAWB_RTIMEOUT )
+    {
+        DEBUG_PRINT( MSG_ALWAYS, "[HAWB] ERROR: RX TimeOut!\n" );
+    }
+
+    if ( intStatusError & BIT_HAWB_RSM_ERROR )
+    {
+        DEBUG_PRINT( MSG_ALWAYS, "[HAWB] ERROR: RX state machine error!\n" );
+    }
+
+    if ( intStatusError & BIT_HAWB_XTIMEOUT )
+    {
+        DEBUG_PRINT( MSG_ALWAYS, "[HAWB] ERROR: TX TimeOut!\n" );
+    }
+
+    if ( intStatusError & (BIT_HAWB_XSM_RCVD_ABORTPKT | BIT_HAWB_RSM_RCVD_ABORTPKT) )
+    {
+        SiiCbusAbortTimerStart();
+        DEBUG_PRINT( MSG_ALWAYS, "[HAWB] ERROR: RX/TX state machine received abort packet!\n" );
+    }
+
+    if ( intStatusError & BIT_HAWB_XSM_ERROR )
+    {
+        DEBUG_PRINT( MSG_ALWAYS, "[HAWB] ERROR: TX state machine error!\n" );
+    }
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_hawb.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_hawb.h
new file mode 100755
index 000000000000..cbab62914227
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_hawb.h
@@ -0,0 +1,44 @@
+/******************************************************************************/
+//!file     si_drv_hawb.h
+//!brief    SiI5293 HAWB Control Driver.
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2007-2013, Silicon Image, Inc.  All rights reserved.
+/******************************************************************************/
+
+
+#ifndef __SI_DRV_HAWB_H__
+#define __SI_DRV_HAWB_H__
+
+#define REG_HAWB_RCV_TIMEOUT            (CBUS_PAGE | 0x84)
+#define REG_HAWB_XMIT_TIMEOUT           (CBUS_PAGE | 0x85)
+#define REG_HAWB_CTRL                   (CBUS_PAGE | 0x86)
+#define BIT_HAWB_RCV_EN                     0x80
+#define BIT_HAWB_WRITE_BURST_DISABLE	    0x04
+#define REG_HAWB_XMIT_CTRL              (CBUS_PAGE | 0x88)
+#define BIT_HAWB_XMIT_EN                    0x80
+#define REG_HAWB_XFIFO_DATA             (CBUS_PAGE | 0x89)
+#define REG_HAWB_XFIFO_STATUS           (CBUS_PAGE | 0x8B)
+#define REG_HAWB_INTR                   (CBUS_PAGE | 0x8C)
+#define BIT_HAWB_FW_TAKEOVER                0x04
+#define BIT_HAWB_XFIFO_EMPTY                0x08
+#define REG_HAWB_INTR_MASK              (CBUS_PAGE | 0x8D)
+#define REG_HAWB_ERROR_INTR             (CBUS_PAGE | 0x8E)
+#define BIT_HAWB_RTIMEOUT                   0x01        // Receive time-out status
+#define BIT_HAWB_RSM_RCVD_ABORTPKT          0x02        // Receive state machine received abort packet status
+#define BIT_HAWB_RSM_ERROR                  0x04        // Receive state machine error status
+#define BIT_HAWB_XTIMEOUT                   0x20        // Transmit time-out status
+#define BIT_HAWB_XSM_RCVD_ABORTPKT          0x40        // Transmit state machine received abort packet status
+#define BIT_HAWB_XSM_ERROR                  0x80        // Transmit state machine error status
+#define REG_HAWB_ERROR_INTR_MASK        (CBUS_PAGE | 0x8F)
+
+
+void SiiDrvHawbInit(void);
+bool_t SiiDrvHawbEnable( bool_t enableTx);
+void SiiDrvHawbProcessInterrupts(void);
+
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_mhawb.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_mhawb.c
new file mode 100755
index 000000000000..4ee1082937f4
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_mhawb.c
@@ -0,0 +1,1356 @@
+//******************************************************************************
+//!file     si_drv_mhawb.c
+//!brief    SiI5293 CBUS Driver Extension
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2012, Silicon Image, Inc.  All rights reserved.
+//*****************************************************************************/
+
+#ifndef __KERNEL__
+#include "si_drv_internal.h"
+#endif
+
+#include "si_drv_mhawb.h"
+#include "../../application/si_common.h"
+
+#ifdef __KERNEL__
+#include "si_drv_hawb.h"
+#include "si_cbus_enums.h"
+#include "si_mdt_inputdev.h"
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include "si_cbus_component.h"
+#include "si_regs_mhl5293.h"
+#include "sii_hal.h"
+#endif
+
+//#define FLOOD_TEST
+#ifdef  MHAWB_SUPPORT
+DEFINE_SEMAPHORE(g_api_lock);
+struct mhawb_t MHAWB_MEMORY g_mhawb = {
+	MHAWB_STATE_UNINITIALIZED,				//state
+	0,							//start_time
+	0,							//max_packet_length
+	{0,0},							//peer_adopter_id
+	MHAWB_XFIFO_EMPTY_LEVELS_MAX,				//empty_levels
+	#if (MHAWB_ACCEL_SETTING == MHAWB_RUNTIME)
+	MHAWB_ACCEL_SETTING,					//flags_accelerations
+	#endif
+};
+
+static  struct workqueue_struct 	*mdt_hid_bridge_wq = NULL;	
+        struct work_struct		mhawb_work;
+static void   delayed_mhawb_do_work_func(struct work_struct *p);
+
+#define FIELD_FIRST_BYTE_OFFEST	0
+#define FIELD_HEADER_SUM				1
+
+uint8_t MHAWB_CODE_MEMORY offsets_and_header_lengths[4][2] = {
+	//length must include 2 byte adopter id,  1 byte length, and # of MDT bytes
+	{MHAWB_ACCEL_NONE_LEVEL_BYTE_OFFSET_FOR_FIRST_BYTE, 		MHAWB_ACCEL_NONE_LEVEL_BYTE_LENGHT_HEADER_SUM},
+	//length must include 2 byte adopter id and # of MDT bytes
+  {MHAWB_ACCEL_LENGTH_LEVEL_BYTE_OFFSET_FOR_FIRST_BYTE,			MHAWB_ACCEL_LENGTH_LEVEL_BYTE_LENGHT_HEADER_SUM},
+	//length must include 1 byte length  and # of MDT bytes
+	{MHAWB_ACCEL_ADOPTERID_LEVEL_BYTE_OFFSET_FOR_FIRST_BYTE,	MHAWB_ACCEL_ADOPTERID_LEVEL_BYTE_LENGHT_HEADER_SUM},
+	//length must be # of MDT bytes
+	{MHAWB_ACCEL_ALL_BYTE_OFFSET_FOR_FIRST_BYTE,			MHAWB_ACCEL_ALL_LEVEL_BYTE_LENGHT_HEADER_SUM}	
+};
+
+uint8_t MHAWB_CODE_MEMORY clear_tx_fifo[3] = { 
+	MHAWB_GEN_2_WRITE_BURST_XFIFO_EMPTY,
+	MHAWB_REG_GEN_2_WRITE_BURST_INTR_MASK_VALUE,
+	0xE0};
+
+uint8_t	cached_state = 0xff;
+uint8_t	cached_intr  = 0xff;
+
+union mhawb_circular_level_buffer_t MHAWB_MEMORY *next_tx;
+union mhawb_circular_level_buffer_t MHAWB_MEMORY *next_rx;
+
+extern uint8_t (*mdt_burst_value_update)(struct hid_usage *, __s32);
+extern uint8_t (*mdt_burst_sync_and_send)(void);
+
+//2013-05-22 - support timeouts
+#ifndef __KERNEL__
+bool_t is_expired(clock_time_t ms_start, clock_time_t ms_timeout) {
+	
+	clock_time_t ms_now = SiiTimerTotalElapsed();
+	clock_time_t ms_elapsed;
+	
+	if (ms_now >= ms_start)
+		ms_elapsed = ms_now - ms_start;
+	else
+		ms_elapsed = (0xffffffff - ms_start) + ms_now;
+	
+	if (ms_elapsed > ms_timeout)
+		return true;
+	else
+		return false;
+}
+#endif
+
+void print_intr_status(void) {
+#if 0
+	if(SiiRegRead(REG_INTR_STATE_2)) {
+			printk(KERN_ERR "INTR2 %02X\n",SiiRegRead(REG_INTR_STATE_2));
+			//SiiRegWrite(REG_INTR_STATE_2, SiiRegRead(REG_INTR_STATE_2));
+	}
+
+	if(SiiRegRead(MHAWB_REG_INTR_STATE)) {
+			printk(KERN_ERR "INTR1 %02X\n",SiiRegRead(MHAWB_REG_INTR_STATE));
+			//SiiRegWrite(MHAWB_REG_INTR_STATE, SiiRegRead( MHAWB_REG_INTR_STATE ));
+	}
+
+	if(SiiRegRead(MHAWB_CBUS_DDC_ABORT)) {
+			printk(KERN_ERR "DDC %02X\n",SiiRegRead(MHAWB_CBUS_DDC_ABORT));
+			//SiiRegWrite(MHAWB_CBUS_DDC_ABORT, SiiRegRead( MHAWB_CBUS_DDC_ABORT ));
+	}
+
+	if(SiiRegRead(REG_CBUS_SET_INT_0 )) {
+			printk(KERN_ERR "SI0 %02X\n",SiiRegRead(REG_CBUS_SET_INT_0 ));
+			//SiiRegWrite(REG_CBUS_SET_INT_0 , SiiRegRead( REG_CBUS_SET_INT_0  ));
+	}
+	if(SiiRegRead(REG_CBUS_SET_INT_1 )) {
+			printk(KERN_ERR "SI1 %02X\n",SiiRegRead(REG_CBUS_SET_INT_1 ));
+			//SiiRegWrite(REG_CBUS_SET_INT_1 , SiiRegRead( REG_CBUS_SET_INT_1  ));
+	}
+	if(SiiRegRead(REG_CBUS_SET_INT_2 )) {
+			printk(KERN_ERR "SI2 %02X\n",SiiRegRead(REG_CBUS_SET_INT_2 ));
+			//SiiRegWrite(REG_CBUS_SET_INT_2 , SiiRegRead( REG_CBUS_SET_INT_2  ));
+	}
+	if(SiiRegRead(REG_CBUS_SET_INT_3 )) {
+			printk(KERN_ERR "SI3 %02X\n",SiiRegRead(REG_CBUS_SET_INT_3 ));
+			SiiRegWrite(REG_CBUS_SET_INT_3 , SiiRegRead( REG_CBUS_SET_INT_3  ));
+	}
+
+	if(SiiRegRead(REG_CBUS_WRITE_STAT_0 )) {
+			printk(KERN_ERR "WS0 %02X\n",SiiRegRead(REG_CBUS_WRITE_STAT_0  ));
+			//SiiRegWrite(REG_CBUS_WRITE_STAT_0  , SiiRegRead( REG_CBUS_WRITE_STAT_0   ));
+			//SiiRegWrite(REG_CBUS_WRITE_STAT_0  , 0);
+	}
+	if(SiiRegRead(REG_CBUS_WRITE_STAT_1 )) {
+			printk(KERN_ERR "WS1 %02X\n",SiiRegRead(REG_CBUS_WRITE_STAT_1  ));
+			//SiiRegWrite(REG_CBUS_WRITE_STAT_1  , SiiRegRead( REG_CBUS_WRITE_STAT_1   ));
+			//SiiRegWrite(REG_CBUS_WRITE_STAT_1  , 0);
+	}
+	if(SiiRegRead(REG_CBUS_WRITE_STAT_2 )) {
+			printk(KERN_ERR "WS2 %02X\n",SiiRegRead(REG_CBUS_WRITE_STAT_2  ));
+			//SiiRegWrite(REG_CBUS_WRITE_STAT_2  , SiiRegRead( REG_CBUS_WRITE_STAT_2   ));
+			//SiiRegWrite(REG_CBUS_WRITE_STAT_2  , 0);
+	}
+	if(SiiRegRead(REG_CBUS_WRITE_STAT_3 )) {
+			printk(KERN_ERR "WS3 %02X\n",SiiRegRead(REG_CBUS_WRITE_STAT_3  ));
+			//SiiRegWrite(REG_CBUS_WRITE_STAT_3  , SiiRegRead( REG_CBUS_WRITE_STAT_3   ));
+			//SiiRegWrite(REG_CBUS_WRITE_STAT_3  , 0);
+	}
+
+
+	if ((int)SiiRegRead(RX_A__INTR1  ) & (int)SiiRegRead( RX_A__INTR1_MASK))
+		printk(KERN_ERR "I1 %02X %02X", (int)SiiRegRead( RX_A__INTR1  ), (int)SiiRegRead( RX_A__INTR1_MASK ));
+	if ((int)SiiRegRead(RX_A__INTR2  ) & (int)SiiRegRead( RX_A__INTR2_MASK))
+		printk(KERN_ERR "I2 %02X %02X", (int)SiiRegRead( RX_A__INTR2  ), (int)SiiRegRead( RX_A__INTR2_MASK ));
+	if ((int)SiiRegRead(RX_A__INTR3  ) & (int)SiiRegRead( RX_A__INTR3_MASK))
+		printk(KERN_ERR "I3 %02X %02X", (int)SiiRegRead( RX_A__INTR3  ), (int)SiiRegRead( RX_A__INTR3_MASK ));
+	if ((int)SiiRegRead(RX_A__INTR4  ) & (int)SiiRegRead( RX_A__INTR4_MASK))
+		printk(KERN_ERR "I4 %02X %02X", (int)SiiRegRead( RX_A__INTR4  ), (int)SiiRegRead( RX_A__INTR4_MASK ));
+	if ((int)SiiRegRead(RX_A__INTR5  ) & (int)SiiRegRead( RX_A__INTR5_MASK))
+		printk(KERN_ERR "I5 %02X %02X", (int)SiiRegRead( RX_A__INTR5  ), (int)SiiRegRead( RX_A__INTR5_MASK ));
+	if ((int)SiiRegRead(RX_A__INTR6  ) & (int)SiiRegRead( RX_A__INTR6_MASK))
+		printk(KERN_ERR "I6 %02X %02X", (int)SiiRegRead( RX_A__INTR6  ), (int)SiiRegRead( RX_A__INTR6_MASK ));
+	if ((int)SiiRegRead(RX_A__INTR7  ) & (int)SiiRegRead( RX_A__INTR7_MASK))
+		printk(KERN_ERR "I7 %02X %02X", (int)SiiRegRead( RX_A__INTR7  ), (int)SiiRegRead( RX_A__INTR7_MASK ));
+	if ((int)SiiRegRead(RX_A__INTR8  ) & (int)SiiRegRead( RX_A__INTR8_MASK))
+		printk(KERN_ERR "I8 %02X %02X", (int)SiiRegRead( RX_A__INTR8  ), (int)SiiRegRead( RX_A__INTR8_MASK ));
+	if ((int)SiiRegRead( MHAWB_INT_STATUS_CBUS1  ) & (int)SiiRegRead( MHAWB_INT_STATUS_CBUS1 + 1  ))
+		printk(KERN_ERR "CBUS1 %02X %02X", (int)SiiRegRead( MHAWB_INT_STATUS_CBUS1  ), (int)SiiRegRead( MHAWB_INT_STATUS_CBUS1 + 1  ));
+	if ((int)SiiRegRead( MHAWB_INT_STATUS_CBUS2  ) & (int)SiiRegRead( MHAWB_INT_STATUS_CBUS2 + 1  ))
+		printk(KERN_ERR "CBUS2 %02X %02X", (int)SiiRegRead( MHAWB_INT_STATUS_CBUS2  ), (int)SiiRegRead( MHAWB_INT_STATUS_CBUS2 + 1  ));
+
+	if ((int)SiiRegRead( MHAWB_REG_GEN_2_WRITE_BURST_INTR  ) & (int)SiiRegRead(MHAWB_REG_GEN_2_WRITE_BURST_INTR + 1  ))
+		printk(KERN_ERR "WBI %02X %02X", (int)SiiRegRead( MHAWB_REG_GEN_2_WRITE_BURST_INTR ),
+							 (int)SiiRegRead( MHAWB_REG_GEN_2_WRITE_BURST_INTR + 1  ));
+
+	if ((int)SiiRegRead( MHAWB_REG_GEN_2_WRITE_BURST_ERROR_INTR  ) & (int)SiiRegRead(MHAWB_REG_GEN_2_WRITE_BURST_ERROR_INTR + 1  ))
+		printk(KERN_ERR "WBE %02X %02X", (int)SiiRegRead( MHAWB_REG_GEN_2_WRITE_BURST_ERROR_INTR ),
+							 (int)SiiRegRead( MHAWB_REG_GEN_2_WRITE_BURST_ERROR_INTR + 1  ));
+
+	if ((int)I2C_ReadByte(0x72, 0x3D) & I2C_ReadByte(0x72, 0x3C) )
+		printk(KERN_ERR "3D %02X %02X", (int)I2C_ReadByte(0x72, 0x3D),
+							 (int)I2C_ReadByte(0x72, 0x3C));
+
+	if ((int)I2C_ReadByte(0xC0, 0x9A) & I2C_ReadByte(0xC0, 0x9A) )
+		printk(KERN_ERR "XFR %02X %02X", (int)I2C_ReadByte(0xC0, 0x9A),
+							 (int)I2C_ReadByte(0xC0, 0x9A));
+
+	if ((int)I2C_ReadByte(0xC0, 0x9C) & I2C_ReadByte(0xC0, 0x9C) )
+		printk(KERN_ERR "XFR %02X %02X", (int)I2C_ReadByte(0xC0, 0x9C),
+							 (int)I2C_ReadByte(0xC0, 0x9C));
+
+
+	if ((int)I2C_ReadByte(0xC0, 0x98) & I2C_ReadByte(0xC0, 0x98) )
+		printk(KERN_ERR "DDC %02X %02X", (int)I2C_ReadByte(0xC0, 0x98),
+							 (int)I2C_ReadByte(0xC0, 0x98));
+
+	if ((int)I2C_ReadByte(0xC0, 0x9C) & I2C_ReadByte(0xC0, 0x9C) )
+		printk(KERN_ERR "XFR %02X %02X", (int)I2C_ReadByte(0xC0, 0x9C),
+							 (int)I2C_ReadByte(0xC0, 0x9C));
+
+	if (SiiRegRead( MHAWB_WRITE_BURST_DATA_LEN) !=  g_mhawb.max_packet_length)
+		printk(KERN_ERR "LEN %02X", (int)SiiRegRead( MHAWB_WRITE_BURST_DATA_LEN));
+
+#endif
+}
+#if 0
+static void MHAWB_XFIFO_Timer_Callback(void *pArg)
+{
+	printk(KERN_ERR "MHAWB XFIFO EMPTY timer expired.\n");
+	if (g_mhawb.state == MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY_AS_PROXY) {
+		//since MHAWB interrupts haven't occured; task other driver code to clear INTR
+		SiiDrvHawbProcessInterrupts();		
+		if  (g_mhawb.empty_levels == MHAWB_XFIFO_EMPTY_LEVELS_MAX) {
+			//can't wait any longer; reset MHAWB  with full FIFO
+			g_mhawb.state	   = MHAWB_STATE_RESET;
+		} else {
+			//reset timer to wait for interrupt
+			SiiOsTimerStart(g_mhawb.timer_xfifoempty, MHAWB_TIMEOUT_FOR_XFIFO_EMPTY);
+		}
+	} else if (g_mhawb.state >= MHAWB_STATE_INIT)   //xyu: do not set to to reset if MHAWB is disabled
+	{
+		g_mhawb.state = MHAWB_STATE_RESET;
+	}
+
+	//2013-07-16 --
+	//    if RESET pending, cycle the state machine to clear it.
+	if (g_mhawb.state == MHAWB_STATE_RESET) {
+		//SiiOsTimerStop(g_mhawb.timer_xfifoempty);
+		if (!g_mhawb.hid_event_received) {
+			printk(KERN_ERR "############ clear reset ############\n");
+			g_mhawb.hid_event_received = 1;
+			wake_up_interruptible(&g_mhawb.wait);
+		}
+	}
+
+}
+#endif
+uint8_t mdt_burst_value_update_local(struct hid_usage *usage, __s32 value) {
+
+	struct mhawb_fifo_level_data_t *hid_event = &g_mhawb.hid_event;
+	struct mdt_burst_01_t *mdt_burst 	  = (struct mdt_burst_01_t *)hid_event->adopter_id;
+	union mdt_event_t     *mdt_packet	  = &mdt_burst->events[0];
+	uint8_t		       mdt_packet_type;
+
+	//printk(KERN_ERR "mdt_s\t%x\t%x\t%x\t%x",(int)hid_event->length,
+	//					(int)mdt_packet->event_keyboard.header.isHID,
+	//				 	(int)mdt_packet->event_mouse.header.isKeyboard,
+	//				 	(int)mdt_packet->event_mouse.header.isNotMouse);
+
+	if (g_mhawb.state < MHAWB_STATE_WAIT_FOR_DATA) {
+		//printk(KERN_ERR "                 - mhawb_not_ready ------------");
+		return MHAWB_SENDAPI_ERROR_UNKNOWNMHLERROR;
+	}
+
+	if (down_trylock(&g_api_lock)) {
+		printk(KERN_ERR " mdt_burst_value_update failed to lock");
+		//up(&g_mhawb_lock);
+		return 0;
+	}
+
+	if (g_mhawb.next_rx_level->fields.level.length != 0) {	
+		printk(KERN_ERR "-#-#-#-#-#-# mhawb_local_fifo_full #-#-#-#-#-#-\n");	
+		up(&g_api_lock);
+		return MHAWB_SENDAPI_ERROR_UNKNOWNMHLERROR;
+	}
+
+
+	if (hid_event->length >= MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA) {
+		//printk(KERN_ERR "packet exceeds allowed length\n");	
+		up(&g_api_lock);
+		return MHAWB_UPDATEAPI_ERROR_EXCEEDSRANGE;
+	}
+        switch (usage->type) {
+		case EV_KEY:
+			if (usage->code & BTN_MOUSE)
+				mdt_packet_type = DEV_TYPE_MOUSE;
+			else if (usage->code & BTN_MISC)
+				mdt_packet_type = DEV_TYPE_GAME;
+			else
+				mdt_packet_type = DEV_TYPE_KEYBOARD;
+			// add directional pad
+			break;
+		case EV_REL:
+			mdt_packet_type = DEV_TYPE_MOUSE;
+			break;
+		case EV_ABS:			
+			mdt_packet_type = DEV_TYPE_TOUCH;
+			break;
+		default:
+			up(&g_api_lock);
+			return MHAWB_UPDATEAPI_ERROR_UNSUPPORTEDFIELD;
+	};
+
+
+	switch (mdt_packet_type) {
+		case DEV_TYPE_KEYBOARD:
+			if ((hid_event->length == 0) &&
+				(!mdt_packet->event_keyboard.header.isHID)) {
+				hid_event->length = MDT_BYTE_LENGTH_HEADER;
+				mdt_packet->event_keyboard.header.isHID 		= 1;
+				mdt_packet->event_keyboard.header.isKeyboard		= 1;
+				//mdt_packet->event_cursor.header.touch.isNotMouse	= 0;
+			} else if ((hid_event->length == MDT_BYTE_LENGTH_MAX_PACKET) &&
+				(!mdt_burst->events[1].event_keyboard.header.isHID)) {
+				mdt_packet	 = &mdt_burst->events[1];
+				hid_event->length = (MDT_BYTE_LENGTH_HEADER + MDT_BYTE_LENGTH_MAX_PACKET);
+				mdt_packet->event_keyboard.header.isHID 		= 1;
+				mdt_packet->event_keyboard.header.isKeyboard		= 1;
+				//mdt_packet->event_cursor.header.touch.isNotMouse	= 0;
+			} else if (hid_event->length > MDT_BYTE_LENGTH_MAX_PACKET)
+				mdt_packet	 = &mdt_burst->events[1];
+
+			printk(KERN_ERR "mdt_k\t%x\t%x\t%x\t%x",(int)hid_event->length,
+								(int)mdt_packet->event_keyboard.header.isHID,
+							 	(int)mdt_packet->event_keyboard.header.isKeyboard,
+							 	(int)mdt_packet->event_mouse.header.isNotMouse);
+
+
+			//  current MDT packet in BURST is already a keyboard packet
+			if  ((mdt_packet->header.isKeyboard == 1) &&				
+				(mdt_packet->event_cursor.header.touch.isNotMouse == 0)) {
+
+				if (mdt_packet	== &mdt_burst->events[0]) {
+					if (hid_event->length > MDT_BYTE_LENGTH_KEYBOARD) {
+						hid_event->length = MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA + 1;
+						up(&g_api_lock);
+						return MHAWB_UPDATEAPI_ERROR_EXCEEDSRANGE;
+					}
+				} else {
+					if (hid_event->length > (MDT_BYTE_LENGTH_KEYBOARD + MDT_BYTE_LENGTH_MAX_PACKET)) {
+						hid_event->length = MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA + 1;
+						up(&g_api_lock);
+						return MHAWB_UPDATEAPI_ERROR_EXCEEDSRANGE;
+					}
+				}				
+
+				// room for more key codes in the packet
+				if (value) {
+					*((uint8_t *)mdt_burst->events + hid_event->length) = (uint8_t)usage->code;
+					hid_event->length++;
+				}
+
+			//  current packet already written but, isn't keyboard and
+			// 	current packet is the first packet and
+			//	second packet uninitialized
+			} else if (hid_event->length < MDT_BYTE_LENGTH_MAX_PACKET) {
+
+				mdt_packet	 = &mdt_burst->events[1];
+				hid_event->length = (MDT_BYTE_LENGTH_HEADER + MDT_BYTE_LENGTH_MAX_PACKET);
+				mdt_packet->event_keyboard.header.isHID 		= 1;
+				mdt_packet->event_keyboard.header.isKeyboard		= 1;
+
+				// room for more key codes in the packet
+				if (value) {
+					*((uint8_t *)mdt_burst->events + hid_event->length) = (uint8_t)usage->code;
+					hid_event->length++;
+				}
+			} else {
+				hid_event->length = MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA + 1;
+				up(&g_api_lock);
+				return MHAWB_UPDATEAPI_ERROR_EXCEEDSRANGE;
+			}
+
+			break;
+		case DEV_TYPE_MOUSE:
+			if ((hid_event->length == 0) &&
+				(!mdt_packet->event_keyboard.header.isHID)) {
+				hid_event->length = MDT_BYTE_LENGTH_HEADER;
+				mdt_packet->event_mouse.header.isHID 			= 1;
+				//mdt_packet->event_mouse.header.isKeyboard		= 0;
+				//mdt_packet->event_mouse.header.touch.isNotMouse 	= 0;
+			} else if ((hid_event->length == MDT_BYTE_LENGTH_MAX_PACKET) &&
+				(!mdt_burst->events[1].event_keyboard.header.isHID)) {
+				mdt_packet	 = &mdt_burst->events[1];
+				hid_event->length = (MDT_BYTE_LENGTH_HEADER + MDT_BYTE_LENGTH_MAX_PACKET);
+				mdt_packet->event_mouse.header.isHID 			= 1;
+				//mdt_packet->event_mouse.header.isKeyboard		= 0;
+				//mdt_packet->event_mouse.header.touch.isNotMouse 	= 0;
+			} else if (hid_event->length > MDT_BYTE_LENGTH_MAX_PACKET) {
+				mdt_packet	 = &mdt_burst->events[1];
+			}
+
+			//printk(KERN_ERR "mdt_m\t%x\t%x\t%x\t%x",(int)hid_event->length,
+			//					(int)mdt_packet->event_keyboard.header.isHID,
+			//				 	(int)mdt_packet->event_mouse.header.isKeyboard,
+			//				 	(int)mdt_packet->event_mouse.header.isNotMouse);
+
+			//  current MDT packet in BURST is already a mouse packet
+			if  ((mdt_packet->event_mouse.header.isKeyboard == 0) && 
+				(mdt_packet->event_mouse.header.isNotMouse == 0)) {
+
+				if (mdt_packet	== &mdt_burst->events[0]) {
+					if (hid_event->length > MDT_BYTE_LENGTH_MOUSE) {
+
+						mdt_packet	  = &mdt_burst->events[1];
+						hid_event->length = (MDT_BYTE_LENGTH_HEADER + MDT_BYTE_LENGTH_MAX_PACKET);
+						mdt_packet->event_mouse.header.isHID			= 1;
+						//mdt_packet->event_mouse.header.isKeyboard		= 0;
+						//mdt_packet->event_mouse.header.touch.isNotMouse 	= 0;
+					}
+				} else {
+					if (hid_event->length >= (MDT_BYTE_LENGTH_HEADER + MDT_BYTE_LENGTH_MOUSE + MDT_BYTE_LENGTH_MAX_PACKET)) {
+						hid_event->length = MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA + 1;
+						up(&g_api_lock);
+						return MHAWB_UPDATEAPI_ERROR_EXCEEDSRANGE;
+					}
+				}
+
+				if (usage->code < REL_MAX)	//since BTN is in header, only increment REL change
+					hid_event->length++;
+
+				switch (usage->code) {
+					case BTN_LEFT:
+						if (value)
+							mdt_packet->event_mouse.header.button |= MDT_BUTTON_LEFT;
+						else
+							mdt_packet->event_mouse.header.button &= ~MDT_BUTTON_LEFT;
+						break;
+					case BTN_MIDDLE:
+						if (value)
+							mdt_packet->event_mouse.header.button |= MDT_BUTTON_MIDDLE;
+						else
+							mdt_packet->event_mouse.header.button &= ~MDT_BUTTON_MIDDLE;
+						break;
+					case BTN_RIGHT:
+						if (value)
+							mdt_packet->event_mouse.header.button |= MDT_BUTTON_RIGHT;
+						else
+							mdt_packet->event_mouse.header.button &= ~MDT_BUTTON_RIGHT;
+						break;
+					case REL_X:	mdt_packet->event_mouse.body.XYZ.x_byteLen = (uint8_t)value;
+						break;
+					case REL_Y:	mdt_packet->event_mouse.body.XYZ.y_byteLen = (uint8_t)value;
+						break;
+					case REL_WHEEL:
+					case REL_Z:	mdt_packet->event_mouse.body.XYZ.z_byteLen = (uint8_t)value;
+						break;
+					default: 
+						up(&g_api_lock);
+						return MHAWB_UPDATEAPI_ERROR_UNSUPPORTEDFIELD;
+				}
+
+			//  current packet already written but, isn't keyboard and
+			// 	current packet is the first packet and
+			//	second packet uninitialized
+			} else if (hid_event->length < MDT_BYTE_LENGTH_MAX_PACKET) {
+
+				mdt_packet	 = &mdt_burst->events[1];
+				hid_event->length = (MDT_BYTE_LENGTH_HEADER + MDT_BYTE_LENGTH_MAX_PACKET);
+				mdt_packet->event_mouse.header.isHID			= 1;
+				//mdt_packet->event_mouse.header.isKeyboard		= 0;
+				//mdt_packet->event_mouse.header.touch.isNotMouse 	= 0;
+				
+				if (usage->code < REL_MAX)	//since BTN is in header, only increment REL change
+					hid_event->length++;
+
+				switch (usage->code) {
+					case BTN_LEFT:
+						if (value)
+							mdt_packet->event_mouse.header.button |= MDT_BUTTON_LEFT;
+						else
+							mdt_packet->event_mouse.header.button &= ~MDT_BUTTON_LEFT;
+						break;
+					case BTN_MIDDLE:
+						if (value)
+							mdt_packet->event_mouse.header.button |= MDT_BUTTON_MIDDLE;
+						else
+							mdt_packet->event_mouse.header.button &= ~MDT_BUTTON_MIDDLE;
+						break;
+					case BTN_RIGHT:
+						if (value)
+							mdt_packet->event_mouse.header.button |= MDT_BUTTON_RIGHT;
+						else
+							mdt_packet->event_mouse.header.button &= ~MDT_BUTTON_RIGHT;
+						break;
+					case REL_X:	mdt_packet->event_mouse.body.XYZ.x_byteLen = (uint8_t)value;
+						break;
+					case REL_Y:	mdt_packet->event_mouse.body.XYZ.y_byteLen = (uint8_t)value;
+						break;
+					case REL_WHEEL:
+					case REL_Z:	mdt_packet->event_mouse.body.XYZ.z_byteLen = (uint8_t)value;
+						break;
+					default: 
+						up(&g_api_lock);
+						return MHAWB_UPDATEAPI_ERROR_UNSUPPORTEDFIELD;
+				}
+			} else {
+				hid_event->length = MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA + 1;
+				up(&g_api_lock);
+				return MHAWB_UPDATEAPI_ERROR_EXCEEDSRANGE;
+			}
+			break;
+		case EV_ABS:
+			break;
+		default:
+			up(&g_api_lock);
+			return MHAWB_UPDATEAPI_ERROR_UNSUPPORTEDFIELD;
+	};	
+
+	//printk(KERN_ERR "mdt_e\t%x\t%x\t%x\t%x",(int)hid_event->length,
+	//					(int)mdt_packet->event_keyboard.header.isHID,
+	//				 	(int)mdt_packet->event_mouse.header.isKeyboard,
+	//				 	(int)mdt_packet->event_mouse.header.isNotMouse);
+
+	
+	up(&g_api_lock);	
+	return MHAWB_UPDATEAPI_SUCCESS;
+			
+}
+//EXPORT_SYMBOL(mdt_burst_value_update);
+
+uint8_t enqueue_packet(union mdt_event_t *packet_payload, uint8_t *packet_length) {
+	
+	//int i;
+
+	//mhawb_init is a prerequisite
+	if (g_mhawb.state == MHAWB_STATE_UNINITIALIZED) {
+		printk(KERN_ERR "                 - mhawb_uninitialized ############\n");
+		return MHAWB_EVENT_HANDLER_FAILED;
+	}
+#if 0
+	if (g_mhawb.state == MHAWB_STATE_DISABLED || g_mhawb.state == MHAWB_STATE_TAKEOVER) {
+		printk(KERN_ERR "############ mhawb disabled ############\n");
+	
+		//2013-07-16 ---
+		//
+		//DISABLE should trigger initialization instead of reset
+		//
+		// g_mhawb.state = MHAWB_STATE_RESET;
+		// xyu: MHAWB will be enable by main CBUS handler, do not change state here
+		//g_mhawb.state = MHAWB_STATE_INIT;
+		if (!g_mhawb.hid_event_received) {
+			printk(KERN_ERR "############ activate delay ############\n");
+			g_mhawb.hid_event_received = 1;
+			wake_up_interruptible(&g_mhawb.wait);
+		}
+		return MHAWB_EVENT_HANDLER_FAILED;
+	}
+#endif
+	//printk(KERN_ERR "------------ mhawb_a ------------\n");
+
+	if (g_mhawb.state < MHAWB_STATE_WAIT_FOR_DATA)	{		//init, disable, or reset
+		//printk(KERN_ERR "                 - mhawb_error_state ############\n");
+#if 0
+		memset(packet_payload->bytes, 0, *packet_length);
+		*packet_length = 0;
+		if (!g_mhawb.hid_event_received) {
+			g_mhawb.hid_event_received = 1;
+			wake_up_interruptible(&g_mhawb.wait);
+		}
+#endif
+		return MHAWB_EVENT_HANDLER_FAILED;
+	}
+	
+	//printk(KERN_ERR "------------ mhawb_b ------------\n");
+
+	// LOCAL buffer is full; DROP PACKET
+	if (g_mhawb.next_rx_level->fields.level.length != 0) {	
+		printk(KERN_ERR "                 - mhawb_local_fifo_full ############\n");
+		#ifndef FLOOD_TEST
+		memset(packet_payload->bytes, 0, *packet_length);		
+		*packet_length = 0;
+		#endif
+		
+		//2013-07-16 --
+		//	no need to force delayed work; wait for interrupt or timeout
+		//g_mhawb.hid_event_received = 1;
+	
+		// something's wrong; MHAWB state machine should have caught this problem
+		//if (g_mhawb.state != MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY) {
+		//	printk(KERN_ERR "############ mhawb_unexpected_state %d ############\n", g_mhawb.state);
+			//g_mhawb.state = MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY;
+			//SiiOsTimerStart(g_mhawb.timer_xfifoempty, MHAWB_TIMEOUT_FOR_XFIFO_EMPTY);
+		//}
+
+		//2013-07-30-MIK; why is this needed here ????
+
+		//2013-07-30, need delayed work if possible
+		//if (!g_mhawb.hid_event_received) {
+		//	g_mhawb.hid_event_received = 1;
+		//	wake_up_interruptible(&g_mhawb.wait);
+		//}
+
+		//2013-07-16 --
+		//	no need to force delayed work; wait for interrupt or timeout
+		//wake_up_interruptible(&g_mhawb.wait);
+		return MHAWB_SYNCAPI_ERROR_PRIORPENDING;
+	}
+
+	//field error; reset
+	if (*packet_length == (MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA + 1)) {
+		printk(KERN_ERR "                 - mhawb_packet_error ############\n");
+		#ifndef FLOOD_TEST
+		memset(packet_payload->bytes, 0, *packet_length);
+		*packet_length = 0;
+		#endif
+		if (!g_mhawb.hid_event_received){
+			g_mhawb.hid_event_received = 1;
+			wake_up_interruptible(&g_mhawb.wait);
+		}
+		return MHAWB_SYNCAPI_ERROR_INVALIDDATA;
+	}
+
+	//printk(KERN_ERR "                 - mhawb_c ------------\n");
+
+	if (*packet_length == 0) {				// nothing to sync
+		printk(KERN_ERR "                 - mhawb_empty_packet ############\n");
+		#ifndef FLOOD_TEST
+		memset(packet_payload->bytes, 0, *packet_length);
+		*packet_length = 0;
+		#endif
+		if (!g_mhawb.hid_event_received){
+			g_mhawb.hid_event_received = 1;
+			wake_up_interruptible(&g_mhawb.wait);
+		}
+		return MHAWB_SYNCAPI_ERROR_INVALIDDATA;
+	}
+
+	//printk(KERN_ERR "                 - mhawb_d ------------\n");
+
+	memcpy(g_mhawb.next_rx_level->fields.level.burst_bytes, packet_payload->bytes, *packet_length);
+
+	//printk(KERN_ERR "                 - mhawb_e ------------\n");
+
+	//for (i=0; i<=*packet_length; i++) {
+	//	printk( KERN_ERR "mhawb byte %x=%x",i, g_mhawb.next_rx_level->fields.level.burst_bytes[i]);
+	//}
+
+	//This length also serves as flag to trigger MDT
+	g_mhawb.next_rx_level->fields.level.length = *packet_length;
+										
+	//It would be easy to copy the length at the head of the data to
+	//   simplify future processing but, the future code might be 
+	//	 confusing to someone that missed the detail here.
+	g_mhawb.next_rx_level = g_mhawb.next_rx_level->fields.next;
+
+	//printk(KERN_ERR "                 - mhawb_f ------------\n");
+	
+	
+	#ifndef FLOOD_TEST		
+	memset(packet_payload->bytes, 0, (*packet_length));
+	*packet_length = 0;
+	#endif
+
+	//i = queue_work(mdt_hid_bridge_wq, &mhawb_work);
+	if (!g_mhawb.hid_event_received){
+		g_mhawb.hid_event_received = 1;
+		wake_up_interruptible(&g_mhawb.wait);
+	}
+	return MHAWB_SYNCAPI_SUCCESS;
+}
+
+void update_position(uint16_t *origin, int16_t delta) {
+
+	if (delta < 0) {
+		delta *= -1;
+		if (delta > *origin)
+			*origin = 0;
+		else
+			*origin -= delta;
+	} else {
+		*origin += delta;
+		if (*origin > XY_MAX)
+			*origin = XY_MAX;
+	}	
+}
+
+uint8_t mdt_burst_simulate_touch(struct mdt_cursor_mouse_t *mousePacket) {
+
+	int ret;
+	struct mdt_cursor_other_t	mdt_touch;
+
+	//printk(KERN_ERR "mouse pkt x:%x y:%x btn:%x"	,(int)(mousePacket->body.XYZ.x_byteLen)
+	//						,(int)(mousePacket->body.XYZ.y_byteLen)
+	//
+	//						,(int)(mousePacket->header.button));
+
+	//1. There's just no reason to lock here. The data is read out of a global into a local
+	//2. The call to this function is already syncrhonized by API lock
+	//if (mousePacket->header.button == 0)
+	//	down(&g_mhawb_lock);
+	//elseif (down_trylock(&g_mhawb_lock)) {
+	//	return 0;
+	//}
+
+	update_position(&g_mhawb.touch_x, mousePacket->body.XYZ.x_byteLen);
+	update_position(&g_mhawb.touch_y, mousePacket->body.XYZ.y_byteLen);
+
+	//printk(KERN_ERR "              x: %02x y: %02x", (int)g_mhawb.touch_x, (int)g_mhawb.touch_y);
+
+	mdt_touch.header.touch.isHID 		= 1;
+	mdt_touch.header.touch.isPortB		= 0;
+	mdt_touch.header.touch.isKeyboard	= 0;
+	mdt_touch.header.touch.isNotLast	= 0;
+	mdt_touch.header.touch.isNotMouse	= 1;
+	// MDT limits support to the first 4 contacts
+	mdt_touch.header.touch.contactID	= 1;
+	mdt_touch.header.touch.isTouched	= (mousePacket->header.button != 0);
+
+	memcpy(mdt_touch.body.touchXYZ.xy_wordLen[MDT_TOUCH_X], &g_mhawb.touch_x, 2);
+	memcpy(mdt_touch.body.touchXYZ.xy_wordLen[MDT_TOUCH_Y], &g_mhawb.touch_y, 2);
+	//mdt_touch.body.touchXYZ.xy_wordLen[MDT_TOUCH_X][MDT_TOUCH_X_LOW]	= (g_mhawb.touch_x & 0xff);
+	//mdt_touch.body.touchXYZ.xy_wordLen[MDT_TOUCH_X][MDT_TOUCH_X_HIGH]	= (g_mhawb.touch_x >> 8) & 0xff;
+	//mdt_touch.body.touchXYZ.xy_wordLen[MDT_TOUCH_Y][MDT_TOUCH_Y_LOW]	= (g_mhawb.touch_y & 0xff);
+	//mdt_touch.body.touchXYZ.xy_wordLen[MDT_TOUCH_Y][MDT_TOUCH_Y_HIGH]	= (g_mhawb.touch_y >> 8) & 0xff;
+
+	//up(&g_mhawb_lock);
+
+	// this is short call; actual work done by a seperate MDT thread
+	
+	ret = mdt_burst_send_touch(&mdt_touch);
+	#ifdef FLOOD_TEST
+	ret = mdt_burst_send_touch(&mdt_touch);
+	ret = mdt_burst_send_touch(&mdt_touch);
+	ret = mdt_burst_send_touch(&mdt_touch);
+	#endif
+	if ((ret & MDT_SYNC_ERROR_FLAG_MASK) == MDT_SYNC_ERROR_FLAG) {
+		pr_info("[TSP4MDT] ERROR %02x\n", ret);
+		return (((ret & MDT_SYNC_ERROR_VALUE_MASK) - MDT_SYNC_ERROR_OFFSET) | MDT_SEND_ERROR_FLAG);
+	} else
+		return MHAWB_SENDAPI_SUCCESS;
+
+		
+		
+
+	return ret;
+}
+
+
+//#define SIMULATE_TOUCH
+uint8_t mdt_burst_sync_and_send_local(void) {
+
+	uint8_t ret;	
+
+	if (down_trylock(&g_api_lock)) {
+		printk(KERN_ERR " mdt_burst_sync_and_send_local failed to lock");
+		return 0;
+	}
+
+#ifdef SIMULATE_TOUCH
+	ret = mdt_burst_simulate_touch((struct mdt_cursor_mouse_t *)g_mhawb.hid_event.burst_bytes);	
+	g_mhawb.hid_event.length = 0;
+	up(&g_api_lock);
+	return ret;
+#else
+	
+	//printk(KERN_ERR "mouse pkt x:%x y:%x btn:%x"	,((struct mdt_cursor_mouse_t *)(g_mhawb.hid_event.burst_bytes))->body.XYZ.x_byteLen
+	//						,((struct mdt_cursor_mouse_t *)(g_mhawb.hid_event.burst_bytes))->body.XYZ.y_byteLen
+	//
+    #ifdef FLOOD_TEST
+    	g_mhawb.hid_event.length = MDT_MOUSE_PACKET_LENGTH + 1;
+    	enqueue_packet((union mdt_event_t*)g_mhawb.hid_event.burst_bytes, &g_mhawb.hid_event.length);
+    	enqueue_packet((union mdt_event_t*)g_mhawb.hid_event.burst_bytes, &g_mhawb.hid_event.length);
+    #endif
+	ret = enqueue_packet((union mdt_event_t*)g_mhawb.hid_event.burst_bytes, &g_mhawb.hid_event.length);
+	up(&g_api_lock);
+	return ret;
+#endif
+}
+//EXPORT_SYMBOL(mdt_burst_sync_and_send);
+
+uint8_t mdt_burst_send_mouse(struct mdt_cursor_mouse_t *mousePacket) {
+
+	uint8_t length = MDT_MOUSE_PACKET_LENGTH + 1;
+	uint8_t ret;
+	//
+	// Don't overwrite a pending packet. Rather than over write a prior packet, drop the new packet.
+	//    It may be preferable to drop earlier packets. For now, drop the new one.
+	if ((mousePacket->header.isNotMouse) 	||
+		 (mousePacket->header.isKeyboard)	||
+		!(mousePacket->header.isHID))
+		return MHAWB_SENDAPI_ERROR_INVALIDTOUCHDATA;
+
+	ret = enqueue_packet((union mdt_event_t*)mousePacket, &length);
+
+	if ((ret & MDT_SYNC_ERROR_FLAG_MASK) == MDT_SYNC_ERROR_FLAG)
+		return ((ret & MDT_SYNC_ERROR_VALUE_MASK) - MDT_SYNC_ERROR_OFFSET);
+	else
+		return MHAWB_SENDAPI_SUCCESS;
+}
+EXPORT_SYMBOL(mdt_burst_send_mouse);
+
+uint8_t mdt_burst_send_touch(struct mdt_cursor_other_t *touchPacket) {
+
+	uint8_t length = MDT_TOUCH_PACKET_LENGTH + 1;
+	uint8_t ret;
+	
+	//		
+	// Qualify packet
+	//					
+	if (!(touchPacket->header.touch.isNotMouse) 	||
+		 (touchPacket->header.touch.isKeyboard)	||
+		!(touchPacket->header.touch.isHID)	||
+		 (touchPacket->body.touchXYZ.xy_wordLen[MDT_TOUCH_X][MDT_TOUCH_X_HIGH] > 0x07) || // must be <= 1920
+		 (touchPacket->body.touchXYZ.xy_wordLen[MDT_TOUCH_Y][MDT_TOUCH_Y_HIGH] > 0x07))   // must be <= 1920
+	{
+		printk(KERN_ERR "ERROR. Poorly formatted packet.\n");
+		if (!touchPacket->header.touch.isHID)
+				printk(KERN_ERR "   isHID incorrectly set to 0\n");
+		if (!touchPacket->header.touch.isNotMouse)
+				printk(KERN_ERR "   isNotMouse incorrectly set to 0\n");
+		if (touchPacket->header.touch.isKeyboard)
+				printk(KERN_ERR "   isKeyboard incorrectly set to 1\n");
+		if (touchPacket->body.touchXYZ.xy_wordLen[MDT_TOUCH_X][MDT_TOUCH_X_HIGH] > 0x07)
+				printk(KERN_ERR "   x coordinate greater than 1920\n");
+		if (touchPacket->body.touchXYZ.xy_wordLen[MDT_TOUCH_Y][MDT_TOUCH_Y_HIGH] > 0x07)
+				printk(KERN_ERR "   y coordinate greater than 1920\n");
+		return MHAWB_SENDAPI_ERROR_INVALIDTOUCHDATA;
+	}
+
+	ret = enqueue_packet((union mdt_event_t*)touchPacket, &length);
+
+
+	if ((ret & MDT_SYNC_ERROR_FLAG_MASK) == MDT_SYNC_ERROR_FLAG)
+		return (((ret & MDT_SYNC_ERROR_VALUE_MASK) - MDT_SYNC_ERROR_OFFSET) | MDT_SEND_ERROR_FLAG);
+
+	else
+		return MHAWB_SENDAPI_SUCCESS;
+}
+EXPORT_SYMBOL(mdt_burst_send_touch);
+
+
+static void delayed_mhawb_do_work_func(struct work_struct *p) {
+	
+	//printk(KERN_ERR "                 - mhawb_delayed_func ------\n");
+
+	if (wait_event_interruptible(g_mhawb.wait,
+		((g_mhawb.hid_event_received == 1)
+		//2013-06-16 -- this will create unnecessary work load 
+		/*||
+		 (g_mhawb.empty_levels != MHAWB_XFIFO_EMPTY_LEVELS_MAX)*/))) {
+		printk(KERN_ERR "              ++ mhawb_wait_failed -------\n");
+		queue_work(mdt_hid_bridge_wq, &mhawb_work);
+		return;
+	}
+
+	//printk(KERN_ERR "MHAWB_+ s%x l%x l%x s%x x%x\n", (int)g_mhawb.state, (int)g_mhawb.empty_levels,
+	//					(int)g_mhawb.hid_event.length, (int)SiiCbusRequestStatus(),
+	//					(int)SiiMhlRxCbusConnected());
+	//xyu: only do following work when mdt_burst_sync_and_send is available
+	if (mdt_burst_sync_and_send)
+	{
+    	//print_intr_status();
+
+    	//printk(KERN_ERR "------------ mhawb_delayed_start -----\n");	
+    	if (HalAcquireIsrLock() == HAL_RET_SUCCESS) {
+    		//printk(KERN_ERR "------------ mhawb_delayed_cont -----\n");
+    		// 2013-07-16 --
+    		//	this while loop means that register will be polled once for expediency
+    		while (mhawb_do_work() == MHAWB_EVENT_HANDLER_WAITING);
+    		//only clear do_work request from API client if work is done
+    		g_mhawb.hid_event_received = 0;
+    		//printk(KERN_ERR "------------ mhawb_delayed_end -------\n");
+    		HalReleaseIsrLock();
+    	}
+    	queue_work(mdt_hid_bridge_wq, &mhawb_work);
+	}
+}
+
+enum mhawb_return_e mhawb_init( void ) {
+
+	// activate MDT state machine here
+	if (g_mhawb.state == MHAWB_STATE_UNINITIALIZED) {
+		g_mhawb.state = MHAWB_STATE_DISABLED;
+		
+//	        SiiOsTimerCreate("MHAWB XFIFO    Timeout", MHAWB_XFIFO_Timer_Callback,   NULL, &g_mhawb.timer_xfifoempty);
+
+		g_mhawb.hid_event_received = 0;
+		mdt_hid_bridge_wq = create_singlethread_workqueue("mdt_hid_bridge_work");
+
+		if (mdt_hid_bridge_wq == NULL) {
+			printk(KERN_ERR "FAILURE: mhawb_workqueue_create");
+			return MHAWB_SYNCAPI_ERROR_UNKNOWNERROR;
+		}
+
+		INIT_WORK(&mhawb_work, delayed_mhawb_do_work_func);
+		init_waitqueue_head(&g_mhawb.wait);
+
+		queue_work(mdt_hid_bridge_wq, &mhawb_work);
+
+        mdt_burst_value_update = mdt_burst_value_update_local;
+        mdt_burst_sync_and_send = mdt_burst_sync_and_send_local;
+
+		printk(KERN_ERR "                 - SUCCESS mhawb_init ------------\n");
+		return MHAWB_SYNCAPI_SUCCESS;
+	} else {
+		printk(KERN_ERR "                 - FAILURE mhawb_invalid ------------");
+		return MHAWB_SYNCAPI_ERROR_INVALIDDATA;
+	}
+
+}
+
+enum mhawb_return_e mhawb_destroy( void )
+{
+    if (mdt_burst_sync_and_send)
+    {
+        mdt_burst_value_update = NULL;
+        mdt_burst_sync_and_send = NULL;
+
+        // wake_up work queue and let it finish its work
+        g_mhawb.hid_event_received = 1;
+        wake_up_interruptible(&g_mhawb.wait);
+
+        flush_workqueue(mdt_hid_bridge_wq);
+        destroy_workqueue(mdt_hid_bridge_wq);
+        mdt_hid_bridge_wq = NULL;
+    }
+    return MHAWB_EVENT_HANDLER_SUCCESS;
+}
+
+enum mhawb_return_e mhawb_do_isr_work( void ) {
+
+    
+    SiiRegWrite(MHAWB_REG_GEN_2_WRITE_BURST_INTR, MHAWB_GEN_2_WRITE_BURST_XFIFO_FULL);
+    if (is_interrupt_asserted())
+    {
+	    uint8_t	err;
+        err = SiiRegRead( MHAWB_REG_GEN_2_WRITE_BURST_ERROR_INTR );
+        if (err)
+        {
+            printk(KERN_ERR "MHAWB ERROR. %02x\n", (int)err);
+            if (err & (MHAWB_GEN_2_WRITE_BURST_XSM_RCVD_ABORTPKT | MHAWB_GEN_2_WRITE_BURST_RSM_RCVD_ABORTPKT))
+            {
+                //g_mhawb.state = MHAWB_STATE_RESET;
+                SiiCbusAbortTimerStart();
+            }
+            else if (err & (MHAWB_GEN_2_WRITE_BURST_XSM_ERROR | MHAWB_GEN_2_WRITE_BURST_RSM_ERROR))
+            {
+                g_mhawb.state = MHAWB_STATE_RESET;
+            }
+			SiiRegWrite( MHAWB_REG_GEN_2_WRITE_BURST_ERROR_INTR, err);
+        }
+
+        if (is_interrupt_asserted())
+        {
+            // There's interrupts other than MDT, let man isr handler to run the remain tasks.
+            return MHAWB_EVENT_HANDLER_FAILED;
+        }
+    }
+    else
+    {
+        printk(KERN_ERR "                MHAWB_XFIFO FULL\n");
+        // XFIFO is full, drop the current content to let XFIFO full assert again.
+        SiiRegBitsSet(MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL, MHAWB_GEN_2_WRITE_BURST_XFIFO_CLR_CUR, 1);
+    }
+    return MHAWB_EVENT_HANDLER_SUCCESS;
+}
+
+enum mhawb_return_e mhawb_do_work( void ) {
+		
+	enum mhawb_return_e	ret    = MHAWB_EVENT_HANDLER_SUCCESS;
+	
+	//This assignment is temporary. INTR status not needed in every state.
+	uint8_t	volatile g_intr = is_interrupt_asserted();
+	uint8_t	reg_val;
+	uint8_t	level_index;			
+	uint8_t	MHAWB_MEMORY	*buffer_start;
+	uint8_t	buffer_length;
+
+	union mhawb_circular_level_buffer_t	MHAWB_MEMORY *current_level;
+
+	//mhawb_init is a prerequisite
+	if (g_mhawb.state == MHAWB_STATE_UNINITIALIZED) {
+		printk(KERN_ERR "                 - mhawb_uninitialized ------------\n");
+		mhawb_init();
+		return MHAWB_EVENT_HANDLER_FAILED;
+	}
+
+	if (g_mhawb.state == MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY_AS_PROXY)
+		return 	MHAWB_EVENT_HANDLER_FAILED;
+
+#if 0   //xyu: Disable & Enable HAWB has been moved to CBUS main loop
+	// Emergency override. Other parts of firmware doing HAWB work. Disable MDT.
+	#ifdef __KERNEL__
+	if ((SiiCbusRequestStatus() == CBUS_REQ_PENDING) ||
+	#else
+	if ((( hawb3DXmitCurrentIndex != 0 ) && ( g_mhawb.state != MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY_AS_PROXY)) ||
+	#endif
+		 ( !SiiMhlRxCbusConnected() ) || 
+		 ( g_mhawb.state == MHAWB_STATE_DISABLED )){		
+		
+		if (g_mhawb.state != MHAWB_STATE_DISABLED) {
+			#ifndef __KERNEL__
+			hawb3DXfifoEmptyFlag = true;
+			#endif
+			SiiDrvHawbInit();
+			SiiDrvHawbEnable(false);	
+			SiiOsTimerStop(g_mhawb.timer_xfifoempty);		
+			g_mhawb.state = MHAWB_STATE_DISABLED;
+		} 
+		#ifdef __KERNEL__
+			else {
+				if ((SiiCbusRequestStatus() == CBUS_REQ_PENDING) &&
+					(SiiMhlRxCbusConnected())) {
+					SiiOsTimerStop(g_mhawb.timer_xfifoempty);
+					g_mhawb.state = MHAWB_STATE_INIT;
+				}
+			}
+		#endif
+
+		//printk(KERN_ERR "MHAWB_! i:%x s:%x lev:%x len:%x stat:%x cn:%x\n", (int)g_intr, (int)g_mhawb.state, (int)g_mhawb.empty_levels,
+		//				(int)g_mhawb.hid_event.length, (int)SiiCbusRequestStatus(),
+		//				(int)SiiMhlRxCbusConnected());
+		return MHAWB_EVENT_HANDLER_FAILED;
+	} 
+#endif	
+//	printk(KERN_ERR "              MHAWB_S t:%x i:%x s:%x lev:%x len:%x stat:%x cn:%x\n", (int)g_mhawb.timer_running, (int)g_intr, (int)g_mhawb.state, 
+//						(int)g_mhawb.empty_levels,
+//						(int)g_mhawb.hid_event.length, (int)SiiCbusRequestStatus(),
+//						(int)SiiMhlRxCbusConnected());
+
+	// Polled part of the state machine supports initiation of init and tranmission.
+	switch (g_mhawb.state) {		
+		case MHAWB_STATE_INIT:
+		case MHAWB_STATE_RESET:
+			if (SiiCbusAbortStateGet())
+			{
+				//xyu: do not do remain work if in abort state.
+				ret = MHAWB_EVENT_HANDLER_FAILED;
+				break;
+			}
+
+//			if (g_mhawb.state != MHAWB_STATE_INIT)
+//				g_mhawb.state	= MHAWB_STATE_WAIT_FOR_DATA;
+
+			memset(&g_mhawb.circular_buffer, 0, sizeof(g_mhawb.circular_buffer));
+			
+			//less code to initialize 4 elements than write a loop
+			g_mhawb.circular_buffer[0].fields.next = &g_mhawb.circular_buffer[1];
+			g_mhawb.circular_buffer[1].fields.next = &g_mhawb.circular_buffer[2];
+			g_mhawb.circular_buffer[2].fields.next = &g_mhawb.circular_buffer[3];
+			g_mhawb.circular_buffer[3].fields.next = &g_mhawb.circular_buffer[0];
+		
+			g_mhawb.next_rx_level = &g_mhawb.circular_buffer[0];
+		
+			for (level_index = 0; level_index < MHAWB_XFIFO_EMPTY_LEVELS_MAX; level_index++)
+				g_mhawb.circular_buffer[level_index].fields.level.length = 0;
+
+			g_mhawb.peer_adopter_id[0] = SiiCbusRemoteDcapGet(0x03);
+			g_mhawb.peer_adopter_id[1] = SiiCbusRemoteDcapGet(0x04);
+									
+			//g_mhawb.empty_levels = MHAWB_XFIFO_EMPTY_LEVELS_MAX;
+			
+			current_level = g_mhawb.next_rx_level;
+			for ( g_mhawb.next_tx_level = current_level->fields.next;
+						(g_mhawb.next_tx_level != current_level) && (g_mhawb.next_tx_level->fields.level.length == 0);
+						g_mhawb.next_tx_level = g_mhawb.next_tx_level->fields.next);
+
+            //xyu: Disable & Enable HAWB has been moved to CBUS main loop
+			//SiiDrvHawbInit();
+			//This call will generate an interrupt. Isr must be locked prior to this call!
+			//SiiDrvHawbEnable(true);
+
+			SiiRegBitsSet(MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL, 	MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL_VALUE, 1);
+
+			#if ((MHAWB_ACCEL_SETTING == MHAWB_ACCEL_LENGTH) || (MHAWB_ACCEL_SETTING == MHAWB_ACCEL_ADOTPER_ID_AND_LENGTH))
+			SiiRegBitsSet(MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL, 	MHAWB_GEN_2_WRITE_BURST_XMIT_FIXED_LENGTH, 1);
+			#endif
+
+			#if ((MHAWB_ACCEL_SETTING == MHAWB_ACCEL_ADOPTER_ID) || (MHAWB_ACCEL_SETTING == MHAWB_ACCEL_ADOTPER_ID_AND_LENGTH))	
+			//SiiRegWriteBlock(MHAWB_GEN_2_WRITE_BURST_PEER_ADPT_ID_LBYTE,
+			//		g_mhawb.peer_adopter_id, MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID);
+			SiiRegWrite(MHAWB_GEN_2_WRITE_BURST_PEER_ADPT_ID_LBYTE, g_mhawb.peer_adopter_id[1]);
+			SiiRegWrite(MHAWB_GEN_2_WRITE_BURST_PEER_ADPT_ID_HBYTE, g_mhawb.peer_adopter_id[0]);
+			SiiRegBitsSet(MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL, 	MHAWB_GEN_2_WRITE_BURST_XMIT_FIXED_ADOPTER_ID,	1);
+			#endif
+		
+			SiiRegBitsSet(MHAWB_REG_GEN_2_WRITE_BURST_XFIFO_STATUS, MHAWB_GEN_2_WRITE_BURST_XMIT_PRE_HS_EN,1);
+			SiiRegWrite(MHAWB_REG_GEN_2_WRITE_BURST_INTR_MASK,	MHAWB_REG_GEN_2_WRITE_BURST_INTR_MASK_VALUE);
+			SiiRegWrite(MHAWB_GEN_2_WRITE_BURST_ERROR_INTR_MASK,	MHAWB_GEN_2_WRITE_BURST_ERROR_INTR_MASK_VALUE);
+			
+			//printk(KERN_ERR "CBUS CTRL %02X\n", (int)SiiRegRead( MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL  ));
+
+			// Workaround. This is a hack. Timeout doesn't behavior as expected.
+			// Set timer for about 50 ms
+			SiiRegWrite(MHAWB_REG_GEN_2_WRITE_BURST_XMIT_TIMEOUT, 01);
+		
+			//2013-07-16 --
+			//	reset was found to be without reset. let try more
+			//Reset TX
+			//xyu: In my test, toggle enable bit is not needed.
+			//SiiRegBitsSet(MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL, 	MHAWB_GEN_2_WRITE_BURST_XMIT_EN, 0);
+			//SiiRegBitsSet(MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL, 	MHAWB_GEN_2_WRITE_BURST_XMIT_EN, 1);
+			
+			//2013-07-16 --
+			//	reset was found to be without reset. let try more
+			//Reset HAWB
+			 SiiRegBitsSet(REG_HAWB_CTRL, 				BIT_HAWB_WRITE_BURST_DISABLE, 	 1);
+			 SiiRegBitsSet(REG_HAWB_CTRL, 				BIT_HAWB_WRITE_BURST_DISABLE, 	 0);  
+
+			SiiRegWrite(MHAWB_REG_GEN_2_WRITE_BURST_INTR, MHAWB_GEN_2_WRITE_BURST_XFIFO_FULL);
+			//printk(KERN_ERR "CBUS CTRL %02X\n", (int)SiiRegRead( MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL  ));
+
+			// clear IDLE interrupt signalling HAWB is ready
+			//xyu: this interrupt is not take care in the main CBUS handler
+			//SiiRegWrite(MHAWB_REG_GEN_2_WRITE_BURST_INTR, 		MHAWB_GEN_2_WRITE_BURST_SM_IDLE);
+			
+			//SiiOsTimerStop(g_mhawb.timer_xfifoempty);
+	
+			// Support MDT activation while HAWB interrupts are pending.
+			g_mhawb.hid_event.length = 0;
+			memset(g_mhawb.hid_event.burst_bytes, 0, sizeof(struct mhawb_fifo_level_data_t));
+			
+			//2013-07-16
+			//     -- interrupt will only occur during initialization
+			// in an interrupt oriented driver this interrupt occurs first.
+			g_mhawb.state	= MHAWB_STATE_WAIT_FOR_DATA;
+			//2013-07-16
+			//     --
+			// no rush on this first transition; can wait indefinitely since XFIFO_EMPTY
+			//  	also allow receipt of new data
+			//SiiOsTimerStart(g_mhawb.timer_xfifoempty, MHAWB_TIMEOUT_FOR_XFIFO_EMPTY);
+			//ret 		= MHAWB_EVENT_HANDLER_WAITING;
+			
+			//2013-07-16
+			//    clear pending updates
+			//g_mhawb.hid_event_received = 0;
+
+			g_mhawb.touch_x	= (XY_MAX/2); g_mhawb.touch_y = (XY_MAX/2); 
+
+			break;			
+		case MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY_AS_PROXY:
+			// This is the entry point from 3D code.
+			
+			// This is a temproary state to handle interrupts missed by other parts of the firmware.
+			// Once the state machine exists this state, it will not return here.
+			
+			// After the remaining interrupt is handled the state machine will go through RESET.
+			//
+			{
+				//2013-05-22 - support timeouts
+				//In case the PROXY state was triggered without reset, reset the timer here.
+				
+				//Use timeouts to allow MDT prioritization in polling implementation.
+				//Timer is started and will be considered in particular states 
+				//	relative to the wait allowed for that state.
+				#ifdef __KERNEL__
+				//SiiOsTimerStart(g_mhawb.timer_xfifoempty, MHAWB_TIMEOUT_FOR_XFIFO_EMPTY);
+				#else
+				if (g_mhawb.start_time == 0)
+					g_mhawb.start_time = SiiTimerTotalElapsed();
+				#endif
+			}
+		case MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY:
+			// The work done in this state depends on INT status 
+			g_intr = is_interrupt_asserted();						
+		
+			// 
+			// - 130715 - FIFO EMPTY check and supporting code removed -
+			//				
+			// if FIFO is already empty, the state machine is in the wrong state
+			// since XFIFO_EMPTY support receipt of new data, don't worry about occurance
+			//	since it will clear once new data arrives.
+
+		
+			if (g_intr) {
+				// rather than check interrupt bit, check for a change in
+				// the number of free levels								
+				reg_val = SiiRegRead(MHAWB_REG_GEN_2_WRITE_BURST_XFIFO_STATUS);
+				reg_val = reg_val >> MHAWB_GEN_2_WRITE_BURST_XFIFO_LEVEL_AVAIL_LSB;
+				
+				// Predictive interrupt handling looks for an expected condition.				
+				// 	if the FIFO is now empty, clear related interrupt interrupt
+				if (reg_val == MHAWB_XFIFO_EMPTY_LEVELS_MAX) {
+					SiiRegWrite(MHAWB_REG_GEN_2_WRITE_BURST_INTR, 
+						MHAWB_GEN_2_WRITE_BURST_XFIFO_EMPTY /*|
+							MHAWB_GEN_2_WRITE_BURST_SM_IDLE*/ );
+					
+					if (g_mhawb.state == MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY_AS_PROXY)
+						g_mhawb.state	= MHAWB_STATE_INIT;	
+					else 
+						g_mhawb.state	= MHAWB_STATE_WAIT_FOR_DATA;
+
+					//2013-05-22 - support timeouts
+					//Use timeouts to allow MDT prioritization in polling implementation.
+					//Timer is started and will be considered in particular states 
+					//	relative to the wait allowed for that state.
+					//printk(KERN_ERR "MHAWB XFIFO timer stop.\n");
+					//SiiOsTimerStop(g_mhawb.timer_xfifoempty);
+
+					// Because this implementation does't currently support a circular buffer
+					//		the pointer shall only be reset if data isn't pending.
+					//    This mean that buffer may be exhausted while memory is free.
+					g_mhawb.empty_levels		= MHAWB_XFIFO_EMPTY_LEVELS_MAX;
+
+					// if FIFO isn't empty, interrupt may reflect an error condition
+				} else {
+					//2013-05-22 - support timeouts
+					
+					//if this wasn't an error, we're here for some unrelated reason
+					//   and should allow MDT to continue running until timeout
+
+					//2013-07-29, xyu: Timeout is not effect here since ISR lock,
+					//There's interrupt but not expected, do not wait anymore.
+					//ret = MHAWB_EVENT_HANDLER_WAITING;
+				}
+				break;
+			}else
+			{
+				//2013-07-29, xyu: There's no interrupt, continue waiting for fifo empty or timeout.
+				// Timeout is currently not work due to ISR lock, need to fix it.
+				ret = MHAWB_EVENT_HANDLER_WAITING;
+			}
+
+			// if an interrupt isn't currently pending and there's room in the FIFO,
+			//   	 allow receipt of more data but, continue to prioritize receipt
+			//  	 of XFIFO EMPTY INTR
+
+		case MHAWB_STATE_WAIT_FOR_DATA:
+			//MHAWB_SUPPORT_USE_REFERENCE differs from the alternative because it only
+			//	allows FIFO writes when FIFO is empty.
+		
+			// exit if nothing is to be sent, exit
+			//if (g_mhawb.next_tx_level->fields.level.length == 0) {
+			//	break;
+			//}
+
+			// if FIFO full, FOR loop below with exit due to empty_levels
+			
+			// If FIFO is empty, copy pending levels into FIFO
+			//
+			// To demonstrate use of various optimizations, the following code appropriately sets
+			//    the buffer header and identifies the offest.
+			//
+			// In a production system, only one optimization configuration needs to be supported
+			//			
+			// Empty_levels should never be greater than MHAWB_XFIFO_EMPTY_LEVELS_MAX. If this happens
+			//		counter overflowed. Remove condition in future code reduction efforts.					
+			//g_mhawb.state					= MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY;		
+			
+			//as code reduction can replace current_level with g_mhawb.next_tx_level
+			for( current_level = g_mhawb.next_tx_level; 
+					 ((current_level->fields.level.length != 0) && (!is_interrupt_asserted()));
+					 current_level = current_level->fields.next) {
+							
+				//g_mhawb.empty_levels--;
+
+				#if (MHAWB_ACCEL_SETTING == MHAWB_RUNTIME)
+						 
+				buffer_start 	= (current_level->raw_bytes + 
+						offsets_and_header_lengths[g_mhawb.flags_accelerations][FIELD_FIRST_BYTE_OFFEST]);
+				buffer_length 	= (current_level->fields.level.length +
+						offsets_and_header_lengths[g_mhawb.flags_accelerations][FIELD_HEADER_SUM]);
+						 
+				switch(g_mhawb.flags_accelerations) {
+					case MHAWB_ACCEL_LENGTH:						
+						memcpy(buffer_start,g_mhawb.peer_adopter_id, FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID);
+					case MHAWB_ACCEL_ADOTPER_ID_AND_LENGTH:
+						//length is ensured to be less than FIELD_BYTE_MAX_LENGTH_FOR_DATA
+						// 	in si_debugger_hdmigear.c
+						if (g_mhawb.max_packet_length < buffer_length) {
+							g_mhawb.max_packet_length = buffer_length;
+							SiiRegWrite( WRITE_BURST_DATA_LEN, g_mhawb.max_packet_length);
+						}
+						break;
+					case MHAWB_ACCEL_ADOPTER_ID:
+						*buffer_start = buffer_length;
+						break;
+					case MHAWB_ACCEL_NOTHING:
+					default:					
+						*buffer_start = buffer_length;
+						memcpy((buffer_start + MHAWB_ACCEL_NONE_LEVEL_BYTE_OFFSET_FOR_ADOPTERID), 
+							g_mhawb.peer_adopter_id, FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID);
+						break;					
+				}
+				#else
+				buffer_start 	= (current_level->raw_bytes + 
+						offsets_and_header_lengths[MHAWB_ACCEL_SETTING][FIELD_FIRST_BYTE_OFFEST]);
+				buffer_length 	= (current_level->fields.level.length +
+						offsets_and_header_lengths[MHAWB_ACCEL_SETTING][FIELD_HEADER_SUM]);				
+				
+				#if (MHAWB_ACCEL_SETTING == MHAWB_ACCEL_LENGTH)
+						memcpy(buffer_start,g_mhawb.peer_adopter_id, FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID);
+						//length is ensured to be less than FIELD_BYTE_MAX_LENGTH_FOR_DATA
+						// 	in si_debugger_hdmigear.c
+						if (g_mhawb.max_packet_length < buffer_length) {
+							g_mhawb.max_packet_length = buffer_length;
+							SiiRegWrite( MHAWB_WRITE_BURST_DATA_LEN, g_mhawb.max_packet_length);
+						}
+
+				#elif (MHAWB_ACCEL_SETTING == MHAWB_ACCEL_ADOTPER_ID_AND_LENGTH)
+						//length is ensured to be less than FIELD_BYTE_MAX_LENGTH_FOR_DATA
+						// 	in si_debugger_hdmigear.c
+						if (g_mhawb.max_packet_length < buffer_length) {
+							g_mhawb.max_packet_length = buffer_length;
+							SiiRegWrite( MHAWB_WRITE_BURST_DATA_LEN, g_mhawb.max_packet_length);
+						}
+
+				#elif	(MHAWB_ACCEL_SETTING == MHAWB_ACCEL_ADOPTER_ID)
+						*buffer_start = buffer_length;
+
+				#elif	(MHAWB_ACCEL_SETTING == MHAWB_ACCEL_NOTHING)
+						*buffer_start = buffer_length;
+						memcpy((buffer_start + MHAWB_ACCEL_NONE_LEVEL_BYTE_OFFSET_FOR_ADOPTERID), 
+						g_mhawb.peer_adopter_id, FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID);
+
+				#endif
+				#endif
+				//TODO - decide if length should be increase here by when to accomodate wrapper	
+
+				//2013-07-30-bug in the i2c driver requires that this lenght be increased by 1
+				SiiRegWriteBlock(MHAWB_GEN_2_WRITE_BURST_XFIFO_DATA , buffer_start, buffer_length);
+				//DEBUG_PRINT( MSG_ALWAYS, "WRITEN %x %x\n",(int)buffer_start[0], (int)buffer_length);
+
+				// Since hardware FIFO is never cleared, might as well free up buffer now.
+				// This is especially important now to avoid sending the same data twice.
+				current_level->fields.level.length = 0;
+						
+				#if (MHAWB_ACCEL_SETTING == MHAWB_ACCEL_ADOTPER_ID_AND_LENGTH)
+				//Workaround. Mask is cleared for larger packet sizes. Not a problem for a 4 byte packet.
+				//Need to cache this to avoid frequent writes
+				if (buffer_length > 4)
+					SiiRegWrite(MHAWB_REG_GEN_2_WRITE_BURST_INTR_MASK, 			
+							MHAWB_REG_GEN_2_WRITE_BURST_INTR_MASK_VALUE);
+				#endif						
+			}
+			
+			g_mhawb.next_tx_level = current_level;
+#if 0
+			// to accept new data while waiting for XFIFO_EMPTY, 
+			//	setup for XFIFO_EMPTY only when explicitely waiting for data
+			if(g_mhawb.state == MHAWB_STATE_WAIT_FOR_DATA) {						
+				//exit and come back again immediately for  further handling
+				g_mhawb.state = MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY;
+
+				//2013-07-16 --
+				//	now that this code is syncrhonized with ISR, don't delay ISR
+				//ret 	      = MHAWB_EVENT_HANDLER_WAITING;
+			
+				//initiate empty interrupt timeout
+				//printk(KERN_ERR "MHAWB XFIFO timer start.\n");
+				SiiOsTimerStart(g_mhawb.timer_xfifoempty, MHAWB_TIMEOUT_FOR_XFIFO_EMPTY);
+			}
+#endif
+			break;
+			//DEBUG_PRINT( MSG_ALWAYS, "M2 %x %x %x\n",(int)g_mhawb.state,(int)g_intr, (int)g_mhawb.empty_levels);			
+
+		// the following 3 should never happen
+		case MHAWB_STATE_UNINITIALIZED:
+		case MHAWB_STATE_DISABLED:
+		case MHAWB_STATE_TAKEOVER:
+		default:
+			return MHAWB_EVENT_HANDLER_FAILED;
+	}
+//	printk(KERN_ERR "              MHAWB_E t:%x i:%x s:%x lev:%x len:%x stat:%x cn:%x end:%x\n", (int)g_mhawb.timer_running, (int) g_intr, (int)g_mhawb.state, 
+//						(int)g_mhawb.empty_levels,
+//						(int)g_mhawb.hid_event.length, (int)SiiCbusRequestStatus(),
+//						(int)SiiMhlRxCbusConnected(), (int) ret);
+
+	//print_intr_status();
+	
+	return ret;
+}
+
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_mhawb.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_mhawb.h
new file mode 100755
index 000000000000..ffd93bc87891
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_drv_mhawb.h
@@ -0,0 +1,348 @@
+//******************************************************************************
+//!file     si_drv_mhawb.h
+//!brief    SiI5293 MDT Driver
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2012, Silicon Image, Inc.  All rights reserved.
+//*****************************************************************************/
+
+#ifndef __SI_DRV_MHAWB_H__
+#define __SI_DRV_MHAWB_H__
+
+#define		MHAWB_SUPPORT				1
+
+#ifdef MHAWB_SUPPORT
+
+//#include "../../application/sk_application.h"
+//#include "../cra_drv/si_drv_cra_cfg.h"
+#include "si_mdt_inputdev.h"
+#ifdef __KERNEL__
+#include "si_common.h"
+#include "si_platform.h"
+#include <linux/gpio.h>
+#include <linux/wakelock.h>
+#else
+#include "AT89C51XD2.h"
+#endif
+/*
+ * PUBLIC CONSTANTS
+ */
+
+#define 	MHAWB_SUPPORT_USE_REFERENCE
+#define		MHAWB_WORKAROUND_FOR_INCOMPLETE_5293_FIRMWARE
+#define		MHAWB_WORKAROUND_FOR_5293_BUG
+
+//For C51, to simplify data transfer out of UART buffer into the MDT module
+// 	use "data" or "idata" memory for MDT global variables.
+//
+//Don't know if this memory type must be used for performance reasons or if
+//  this memory type must be used to allow copy from data used by ISR. Experimentally,
+//  found that xdata memory will cause 8051 to corrupt MHAWB data at higher event rates.
+#ifdef __KERNEL__
+#define 	MHAWB_MEMORY
+#define 	MHAWB_CODE_MEMORY
+#else
+#define 	MHAWB_MEMORY 						data
+#define 	MHAWB_CODE_MEMORY					code
+#define		MCP5293_INT_PIN						INT0
+#endif
+
+
+//Allow compile or runtime configuration and selection of MDT HAWB.
+#define 	MHAWB_ACCEL_NOTHING			0//up to 17 byte I2C block writes to FIFO; least optimized
+#define 	MHAWB_ACCEL_LENGTH			1//up to 16 byte I2C block writes to FIFO
+#define 	MHAWB_ACCEL_ADOPTER_ID			2//up to 15 byte I2C block writes to FIFO
+#define 	MHAWB_ACCEL_ADOTPER_ID_AND_LENGTH	3//up to 14 byte I2C block writes to FIFO
+#define 	MHAWB_RUNTIME				4//configurable at runtime 
+
+//Set MDT_ACCEL_SETTING to one of the above 5 choices above
+#define 	MHAWB_ACCEL_SETTING														MHAWB_ACCEL_ADOTPER_ID_AND_LENGTH
+
+/*
+ * PUBLIC CONSTANTS FOR MDT_ACCEL_SETTING
+ */
+
+#define 	MHAWB_LEVEL_BYTE_MAX_OFFSET_FOR_LENGTH			0
+#define 	MHAWB_LEVEL_BYTE_MAX_OFFSET_FOR_ADOPTERID		1
+#define		MHAWB_LEVEL_BYTE_MAX_OFFEST_FOR_DATA			3
+
+#define 	MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_LENGTH			1
+#define		MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID		2
+#define		MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA			14
+#define		MHAWB_FIELD_BYTE_MAX_LENGTH_SUM				MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_LENGTH 		\
+									+ MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID \
+									+ MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA
+
+#define 	MHAWB_ACCEL_NONE_LEVEL_BYTE_OFFSET_FOR_LENGTH		MHAWB_LEVEL_BYTE_MAX_OFFSET_FOR_LENGTH
+#define 	MHAWB_ACCEL_NONE_LEVEL_BYTE_OFFSET_FOR_ADOPTERID  	MHAWB_LEVEL_BYTE_MAX_OFFSET_FOR_ADOPTERID
+#define		MHAWB_ACCEL_NONE_LEVEL_BYTE_OFFEST_FOR_DATA		MHAWB_LEVEL_BYTE_MAX_OFFEST_FOR_DATA
+#define 	MHAWB_ACCEL_NONE_FIELD_BYTE_LENGTH_FOR_LENGTH		MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_LENGTH
+#define		MHAWB_ACCEL_NONE_FIELD_BYTE_LENGTH_FOR_ADOPTERID	MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID
+#define		MHAWB_ACCEL_NONE_FIELD_BYTE_LENGTH_FOR_DATA		MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA
+
+#define 	MHAWB_ACCEL_NONE_LEVEL_BYTE_OFFSET_FOR_FIRST_BYTE	MHAWB_ACCEL_NONE_LEVEL_BYTE_OFFSET_FOR_LENGTH
+#define 	MHAWB_ACCEL_NONE_LEVEL_BYTE_LENGHT_HEADER_SUM		MHAWB_ACCEL_NONE_FIELD_BYTE_LENGTH_FOR_LENGTH \
+									+ MHAWB_ACCEL_NONE_FIELD_BYTE_LENGTH_FOR_ADOPTERID
+#define 	MHAWB_ACCEL_NONE_LEVEL_BYTE_LENGHT_SUM			MHAWB_ACCEL_NONE_FIELD_BYTE_LENGTH_FOR_LENGTH \
+									+ MHAWB_ACCEL_NONE_FIELD_BYTE_LENGTH_FOR_ADOPTERID \
+									+ MHAWB_ACCEL_NONE_FIELD_BYTE_LENGTH_FOR_DATA
+
+#define 	MHAWB_ACCEL_LENGTH_LEVEL_BYTE_OFFSET_FOR_ADOPTERID	MHAWB_LEVEL_BYTE_MAX_OFFSET_FOR_ADOPTERID
+#define		MHAWB_ACCEL_LENGTH_LEVEL_BYTE_OFFEST_FOR_DATA		MHAWB_LEVEL_BYTE_MAX_OFFEST_FOR_DATA
+#define 	MHAWB_ACCEL_LENGTH_FIELD_BYTE_LENGTH_FOR_LENGTH		0
+#define		MHAWB_ACCEL_LENGTH_FIELD_BYTE_LENGTH_FOR_ADOPTERID	MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID
+#define		MHAWB_ACCEL_LENGTH_FIELD_BYTE_LENGTH_FOR_DATA		MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA
+#define 	MHAWB_ACCEL_LENGTH_LEVEL_BYTE_OFFSET_FOR_FIRST_BYTE	MHAWB_ACCEL_LENGTH_LEVEL_BYTE_OFFSET_FOR_ADOPTERID
+#define 	MHAWB_ACCEL_LENGTH_LEVEL_BYTE_LENGHT_HEADER_SUM		MHAWB_ACCEL_LENGTH_FIELD_BYTE_LENGTH_FOR_LENGTH \
+									+ MHAWB_ACCEL_LENGTH_FIELD_BYTE_LENGTH_FOR_ADOPTERID
+#define 	MHAWB_ACCEL_LENGTH_LEVEL_BYTE_LENGHT_SUM		MHAWB_ACCEL_LENGTH_FIELD_BYTE_LENGTH_FOR_LENGTH \
+									+ MHAWB_ACCEL_LENGTH_FIELD_BYTE_LENGTH_FOR_ADOPTERID \
+									+ MHAWB_ACCEL_LENGTH_FIELD_BYTE_LENGTH_FOR_DATA
+
+#define 	MHAWB_ACCEL_ADOPTERID_LEVEL_BYTE_OFFSET_FOR_LENGTH	2
+#define		MHAWB_ACCEL_ADOPTERID_LEVEL_BYTE_OFFEST_FOR_DATA	MHAWB_LEVEL_BYTE_MAX_OFFEST_FOR_DATA
+#define 	MHAWB_ACCEL_ADOPTERID_FIELD_BYTE_LENGTH_FOR_LENGTH	MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_LENGTH
+#define		MHAWB_ACCEL_ADOPTERID_FIELD_BYTE_LENGTH_FOR_ADOPTERID	0
+#define		MHAWB_ACCEL_ADOPTERID_FIELD_BYTE_LENGTH_FOR_DATA	MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA
+#define 	MHAWB_ACCEL_ADOPTERID_LEVEL_BYTE_OFFSET_FOR_FIRST_BYTE	MHAWB_ACCEL_ADOPTERID_LEVEL_BYTE_OFFSET_FOR_LENGTH
+#define 	MHAWB_ACCEL_ADOPTERID_LEVEL_BYTE_LENGHT_HEADER_SUM	MHAWB_ACCEL_ADOPTERID_FIELD_BYTE_LENGTH_FOR_LENGTH \
+									+ MHAWB_ACCEL_ADOPTERID_FIELD_BYTE_LENGTH_FOR_ADOPTERID
+#define 	MHAWB_ACCEL_ADOPTERID_LEVEL_BYTE_LENGHT_SUM		MHAWB_ACCEL_ADOPTERID_FIELD_BYTE_LENGTH_FOR_LENGTH \
+									+ MHAWB_ACCEL_ADOPTERID_FIELD_BYTE_LENGTH_FOR_ADOPTERID \
+									+ MHAWB_ACCEL_ADOPTERID_FIELD_BYTE_LENGTH_FOR_DATA
+
+#define		MHAWB_ACCEL_ALL_LEVEL_BYTE_OFFEST_FOR_DATA		MHAWB_LEVEL_BYTE_MAX_OFFEST_FOR_DATA
+#define 	MHAWB_ACCEL_ALL_FIELD_BYTE_LENGTH_FOR_LENGTH		0
+#define		MHAWB_ACCEL_ALL_FIELD_BYTE_LENGTH_FOR_ADOPTERID		0
+#define		MHAWB_ACCEL_ALL_FIELD_BYTE_LENGTH_FOR_DATA		MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_DATA
+#define 	MHAWB_ACCEL_ALL_BYTE_OFFSET_FOR_FIRST_BYTE		MHAWB_ACCEL_ALL_LEVEL_BYTE_OFFEST_FOR_DATA
+#define 	MHAWB_ACCEL_ALL_LEVEL_BYTE_LENGHT_HEADER_SUM		MHAWB_ACCEL_ALL_FIELD_BYTE_LENGTH_FOR_LENGTH \
+									+ MHAWB_ACCEL_ALL_FIELD_BYTE_LENGTH_FOR_ADOPTERID
+#define 	MHAWB_ACCEL_ALL_LEVEL_BYTE_LENGHT_SUM			MHAWB_ACCEL_ALL_FIELD_BYTE_LENGTH_FOR_LENGTH \
+									+ MHAWB_ACCEL_ALL_FIELD_BYTE_LENGTH_FOR_ADOPTERID \
+									+ MHAWB_ACCEL_ALL_FIELD_BYTE_LENGTH_FOR_DATA
+
+#define 	MHAWB_BYTE_LENGTH_NULL					0
+
+/*
+ * PUBLIC CONSTANTS FOR MDT PROTOCOL
+ *
+ * The SiI5293 reference firmware acts like a UART to I2C bridge.
+ * This code does not decode or encode MDT.
+ * As part of code reduction, this brige function requires minor data manipulation.
+ *
+ * MDT protocol support may be found inside the SiIMon SiI5293 plug-in. 
+ */
+
+#define		MDT_BYTE_LENGTH_MOUSE					3
+#define		MDT_BYTE_LENGTH_TOUCH					4
+#define		MDT_BYTE_LENGTH_KEYBOARD				6
+#define		MDT_BYTE_LENGTH_HEADER					1
+#define		MDT_BYTE_LENGTH_MIN_PACKET				MDT_BYTE_LENGTH_HEADER \
+									+ MDT_BYTE_LENGTH_MOUSE
+
+#define		MDT_BYTE_LENGTH_MAX_PACKET				MDT_BYTE_LENGTH_HEADER \
+									+ MDT_BYTE_LENGTH_KEYBOARD
+
+#define 	SIIMON_DATA_BURST_START_OFFSET				2
+
+
+/*
+ * PUBLIC CONSTANTS AND TYPE FOR SII5293 REGISTERS
+ *
+ * Duplicates exist. See "CP5293 PLATFORM" above for detail.
+ * Prefix added.		 See "CP5293 PLATFORM" above for detail.
+ */
+
+#define		MHAWB_PP_PAGE						PP_PAGE
+#define		MHAWB_CBUS_PAGE						CBUS_PAGE
+
+#define		MHAWB_XFIFO_EMPTY_LEVELS_MAX				4
+
+#define 	MHAWB_REG_INTR_STATE					( MHAWB_PP_PAGE | 0x70 )
+#define 	MHAWB_INTR						( 1 << 0 )
+
+#define 	MHAWB_WRITE_BURST_DATA_LEN				( MHAWB_CBUS_PAGE | 0xC6 )
+
+#define		MHAWB_GEN_2_WRITE_BURST_PEER_ADPT_ID_LBYTE		( MHAWB_CBUS_PAGE | 0xB6 )
+#define		MHAWB_GEN_2_WRITE_BURST_PEER_ADPT_ID_HBYTE		( MHAWB_CBUS_PAGE | 0xB7 )
+
+#define		MHAWB_REG_GEN_2_WRITE_BURST_XMIT_TIMEOUT 		( MHAWB_CBUS_PAGE | 0x85 )
+
+
+#define 	MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL			( MHAWB_CBUS_PAGE | 0x88 )
+
+#define 	MHAWB_GEN_2_WRITE_BURST_XMIT_EN				( 1 << 7 )
+#define 	MHAWB_GEN_2_WRITE_BURST_XMIT_CMD_MERGE_EN		( 1 << 6 )
+#define 	MHAWB_GEN_2_WRITE_BURST_XMIT_FIXED_LENGTH 		( 1 << 5 )
+#define 	MHAWB_GEN_2_WRITE_BURST_XMIT_FIXED_ADOPTER_ID 		( 1 << 4 )
+#define 	MHAWB_GEN_2_WRITE_BURST_XIMT_SINGLE_RUN_EN 		( 1 << 3 )
+#define 	MHAWB_GEN_2_WRITE_BURST_CLR_ABORT_WAIT			( 1 << 2 )
+#define		MHAWB_GEN_2_WRITE_BURST_XFIFO_CLR_ALL 			( 1 << 1 )
+#define		MHAWB_GEN_2_WRITE_BURST_XFIFO_CLR_CUR		 	( 1 << 0 )
+
+#define 	MHAWB_REG_GEN_2_WRITE_BURST_XMIT_CTRL_VALUE		( MHAWB_GEN_2_WRITE_BURST_XMIT_CMD_MERGE_EN | \
+									MHAWB_GEN_2_WRITE_BURST_XMIT_FIXED_LENGTH | \
+									MHAWB_GEN_2_WRITE_BURST_XMIT_FIXED_ADOPTER_ID | \
+									MHAWB_GEN_2_WRITE_BURST_XFIFO_CLR_ALL | \
+									MHAWB_GEN_2_WRITE_BURST_CLR_ABORT_WAIT) 
+
+#define 	MHAWB_GEN_2_WRITE_BURST_XFIFO_DATA_OFFSET		0x89
+#define 	MHAWB_GEN_2_WRITE_BURST_XFIFO_DATA			( MHAWB_CBUS_PAGE | \
+									MHAWB_GEN_2_WRITE_BURST_XFIFO_DATA_OFFSET )
+#define		MHAWB_REG_GEN_2_WRITE_BURST_INTR			( MHAWB_CBUS_PAGE | 0x8C )
+#define 	MHAWB_REG_GEN_2_WRITE_BURST_INTR_MASK			( MHAWB_CBUS_PAGE | 0x8D )
+
+#define 	MHAWB_GEN_2_WRITE_BURST_XFIFO_EMPTY			( 1 << 3 )
+#define 	MHAWB_GEN_2_WRITE_BURST_SM_IDLE				( 1 << 2 )
+#define 	MHAWB_GEN_2_WRITE_BURST_XFIFO_FULL 			( 1 << 1 )
+#define		MHAWB_GEN_2_WRITE_BURST_RFIFO_RDY 			( 1 << 0 )
+
+#define 	MHAWB_REG_GEN_2_WRITE_BURST_XFIFO_STATUS		(CBUS_PAGE | 0x8B)
+#define		MHAWB_GEN_2_WRITE_BURST_XFIFO_LEVEL_AVAIL_LSB	5
+#define 	MHAWB_GEN_2_WRITE_BURST_XMIT_PRE_HS_EN 			0x10
+
+#define 	MHAWB_REG_GEN_2_WRITE_BURST_ERROR_INTR			( MHAWB_CBUS_PAGE | 0x8E )
+#define 	MHAWB_GEN_2_WRITE_BURST_ERROR_INTR_MASK			( MHAWB_CBUS_PAGE | 0x8F )
+#define		MHAWB_GEN_2_WRITE_BURST_XSM_ERROR			( 1 << 7 )
+#define		MHAWB_GEN_2_WRITE_BURST_XSM_RCVD_ABORTPKT		( 1 << 6 )
+#define		MHAWB_GEN_2_WRITE_BURST_XTIMEOUT			( 1 << 5 )
+#define		MHAWB_GEN_2_WRITE_BURST_RSM_ERROR			( 1 << 2 )
+#define 	MHAWB_GEN_2_WRITE_BURST_RSM_RCVD_ABORTPKT		( 1 << 1 )
+#define		MHAWB_GEN_2_WRITE_BURST_RTIMEOUT			( 1 << 0 )
+#define 	MHAWB_GEN_2_WRITE_BURST_ERROR_INTR_MASK_VALUE		( MHAWB_GEN_2_WRITE_BURST_XSM_ERROR |\
+									MHAWB_GEN_2_WRITE_BURST_XSM_RCVD_ABORTPKT )
+
+// To start, support HAWB Tx; HAWB Rx not implemented here
+#define		MHAWB_REG_GEN_2_WRITE_BURST_INTR_MASK_VALUE	 	MHAWB_GEN_2_WRITE_BURST_XFIFO_FULL
+									//( MHAWB_GEN_2_WRITE_BURST_XFIFO_EMPTY |
+									//MHAWB_GEN_2_WRITE_BURST_SM_IDLE )
+
+#define 	MHAWB_INT_STATUS_CBUS1 					( MHAWB_CBUS_PAGE | 0x92 )
+#define 	MHAWB_MSC_MSG_DONE_WITH_NACK				( 1 << 7 )
+#define		MHAWB_SET_INT_RCVD					( 1 << 6 )
+#define		MHAWB_WRITE_BURST_RCVD					( 1 << 5 )
+#define		MHAWB_MSC_MSG_RCVD					( 1 << 4 )
+#define		MHAWB_WRITE_STAT_RCVD					( 1 << 3 )
+#define		MHAWB_MSC_CMD_DONE					( 1 << 1 )
+#define		MHAWB_CONNECT_CHANGE					( 1 << 0 )
+
+#define 	MHAWB_INT_STATUS_CBUS2 					(CBUS_PAGE | 0x94)
+#define 	MHAWB_MSC_CMD_ABORT					( 1 << 6 )
+#define		MHAWB_MSC_ABORT_RCVD					( 1 << 3 )
+#define		MHAWB_DDC_ABORT						( 1 << 2 )
+
+#define 	MHAWB_CBUS_XFR_ABORT 					(CBUS_PAGE | 0x9A)
+#define 	MHAWB_PEER_ABORT					( 1 << 7 )
+#define 	MHAWB_XFR_UNDEF_CMD					( 1 << 3 )
+#define		MHAWB_XFR_TIMEOUT					( 1 << 2 )
+#define		MHAWB_XFR_PROTO_ERR 					( 1 << 1 )
+#define		MHAWB_XFR_MAX_FAIL					( 1 << 0 )
+
+#define 	MHAWB_CBUS_DDC_ABORT					(CBUS_PAGE | 0x98)		
+
+
+// TIMER TIMEOUTS
+#define	  MHAWB_TIMEOUT_FOR_XFIFO_EMPTY					100
+#define	  MHAWB_TIMEOUT_FOR_NEW_DATA					100
+#define   MHAWB_WAIT_FOR_XFIFOEMPTY_TIMEOUT				7770
+#define   MHAWB_WAIT_FOR_NEWDATA_TIMEOUT				7771
+
+// Structure reflects the HAWB FIFO LEVEL
+//
+struct mhawb_fifo_level_data_t {
+	uint8_t								length;
+	uint8_t								adopter_id[MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID];
+	uint8_t								burst_bytes[MDT_BYTE_LENGTH_MAX_PACKET * 2];
+};
+
+/*
+ * PUBLIC CONSTANTS AND TYPES FOR MHAWB IMPLEMENTATION
+ */
+
+enum 	mhawb_state_e {	  
+	MHAWB_STATE_UNINITIALIZED
+	, MHAWB_STATE_TAKEOVER				//during disable HAWB process
+	, MHAWB_STATE_DISABLED				//state machine does nothign
+	, MHAWB_STATE_INIT				//ENTRY POINT... intializes global variables
+	, MHAWB_STATE_RESET				//resets global variables and HAWB registers
+	, MHAWB_STATE_WAIT_FOR_DATA			//variable polling state; waits for mhawb_circular_buffer changes
+	, MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY		//MCP5293_INT_PIN polling state; waits for interrupt				
+	, MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY_AS_PROXY	//ENTRY POINT... workarounds to CP5293 FW + MHAWB_STATE_WAIT_FOR_XFIFO_EMPTY
+};
+
+enum 	mhawb_return_e {				  
+	MHAWB_EVENT_HANDLER_FAILED  = ( 1 << 0)		//let all firmware run
+	, MHAWB_EVENT_HANDLER_SUCCESS = ( 1 << 1)	//let polling parts of firmware run
+	, MHAWB_EVENT_HANDLER_WAITING = ( 1 << 2)	//return to MHAWB after SiIMon handler runs
+};
+
+struct mhawb_level_data {
+	struct mhawb_fifo_level_data_t		level;
+	union mhawb_circular_level_buffer_t	MHAWB_MEMORY		*next;
+};
+
+union mhawb_circular_level_buffer_t {
+		struct mhawb_level_data		fields;					
+		uint8_t				raw_bytes[sizeof(struct mhawb_level_data)];
+};
+
+
+// consider moving these varables into CBUS or app
+
+struct mhawb_t {
+	enum mhawb_state_e			state;
+
+	#ifdef __KERNEL__
+        SiiOsTimer_t				timer_xfifoempty;
+	#else
+	clock_time_t 				start_time;
+	#endif
+
+	uint8_t					max_packet_length;
+	uint8_t peer_adopter_id[MHAWB_FIELD_BYTE_MAX_LENGTH_FOR_ADOPTERID];									
+	uint8_t					empty_levels;
+#if (MHAWB_ACCEL_SETTING == MHAWB_RUNTIME)
+	uint8_t					flags_accelerations;
+#endif
+	wait_queue_head_t 			wait;
+	struct semaphore 			sem;
+	uint8_t					hid_event_received;
+	struct  mhawb_fifo_level_data_t		hid_event;		//temp variable
+
+	union	mhawb_circular_level_buffer_t	MHAWB_MEMORY 	*next_rx_level;
+	union	mhawb_circular_level_buffer_t	MHAWB_MEMORY 	*next_tx_level;
+	union 	mhawb_circular_level_buffer_t			circular_buffer[MHAWB_XFIFO_EMPTY_LEVELS_MAX];
+
+	uint16_t				touch_x;
+	uint16_t				touch_y;
+};
+
+/*
+ * GLOBAL VARIABLE DEFINED BY THIS MODULE
+ */
+
+extern struct mhawb_t MHAWB_MEMORY g_mhawb;
+
+/*
+ * GLOBAL VARIABLES DEFINED IN FIRMWARE
+ */
+
+#ifndef __KERNEL__
+extern bool_t					hawb3DXfifoEmptyFlag;
+extern uint8_t					hawb3DXmitCurrentIndex;
+#endif
+
+/*
+ * PUBLIC FUNCTIONS VARIABLES DEFINED IN FIRMWARE
+ */
+enum mhawb_return_e mhawb_do_work ( void );
+enum mhawb_return_e mhawb_do_isr_work(void);
+enum mhawb_return_e mhawb_init ( void );
+enum mhawb_return_e mhawb_destroy( void );
+#endif
+#endif // __SI_DRV_MHAWB_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_mdt_inputdev.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_mdt_inputdev.h
new file mode 100755
index 000000000000..9a9cb8874649
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/mhawb_drv/si_mdt_inputdev.h
@@ -0,0 +1,460 @@
+
+
+
+
+
+
+
+
+
+/*
+ Silicon Image Driver Extension
+
+ Copyright (C) 2012 Silicon Image Inc.
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation version 2.
+
+ This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ kind, whether express or implied; without even the implied warranty
+ of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ PURPOSE.  See the
+ GNU General Public License for more details.
+*/
+//!file     si_mdt_inputdev.h
+//!brief    Silicon Image implementation of MDT function.
+//
+//***************************************************************************/
+
+#ifndef _SI_MDT_INPUTDEV_H_
+#define _SI_MDT_INPUTDEV_H_
+
+
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/hid.h>
+
+#define MDT_SUPPORT
+#define WRITE_BURST_ISR
+#define ICS_GTi9100
+
+#define MDT_TOUCH_TIMEOUT_ENABLE	1
+#define MDT_TOUCH_TIMEOUT_DISABLE	0
+
+#define MDT_MAX_TOUCH_CONTACTS		4
+#define MDT_HID_INPUT_REPORT		7
+#define KEYBOARD			2
+#define MOUSE 				1
+#define WAITING_FOR_HEADER		0
+#define RECEIVING_PAYLOAD		1
+#define RECEIVED			4
+#define MEDIA_DATA_TUNNEL_SUPPORT
+
+#define MDT_DPAD_UP			0x01
+#define MDT_DPAD_RIGHT			0x02
+#define MDT_DPAD_DOWN			0x04
+#define MDT_DPAD_LEFT			0x08
+	
+#define MDT_GAMEXYRZ_X			0
+#define MDT_GAMEXYRZ_Y			1
+#define MDT_GAMEXYRZ_Z			2
+#define MDT_GAMEXYRZ_Rz			3
+
+#define MDT_HID_DPAD_000_DEGREES	0
+#define MDT_HID_DPAD_045_DEGREES	1
+#define MDT_HID_DPAD_090_DEGREES	2
+#define MDT_HID_DPAD_135_DEGREES	3
+#define MDT_HID_DPAD_180_DEGREES	4
+#define MDT_HID_DPAD_225_DEGREES	5
+#define MDT_HID_DPAD_270_DEGREES	6
+#define MDT_HID_DPAD_315_DEGREES	7
+#define MDT_HID_DPAD_IDLE		8
+
+#define MDT_DPAD_CENTER			0x80
+#define MDT_DPAD_ERROR_ALLOWANCE	5			// Ignore DPAD value variance of 5 from center
+#define MDT_DPAD_NORMALIZE_RANGE_TO_5	24			// 0x80 / 5 = 25; 24 is close enough
+
+#define MDT_OTHER_BUTTONS_4		0x08
+#define MDT_OTHER_BUTTONS_5		0x10
+
+#define TS_TOUCHED			1			//additional macros for PhoenixBlade support
+#define KEY_PRESSED			1
+#define KEY_RELEASED			0
+
+#define MDT_BUTTON_LEFT			1
+#define MDT_BUTTON_RIGHT		2
+#define MDT_BUTTON_MIDDLE		4
+
+#define MDT_ERROR			0xFF
+
+#define MDT_TOUCH_X			0
+#define MDT_TOUCH_Y			1
+
+#define BYTE_LOW			0
+#define BYTE_HIGH			1
+
+#define MDT_TOUCH_X_LOW			BYTE_LOW
+#define MDT_TOUCH_X_HIGH		BYTE_HIGH
+#define MDT_TOUCH_Y_LOW			BYTE_LOW
+#define MDT_TOUCH_Y_HIGH		BYTE_HIGH
+
+//2012-12-12 updating MDT definition & Korvus firmware.
+//    Now X and Y relay within 0..1920. Corner definitions must be updated.
+#define XY_MAX				1920
+#define X_CORNER_RIGHT_LOWER		1860	//relative to physical coordinates with 0,0 in top-left
+#define Y_CORNER_RIGHT_LOWER		1860	//relative to physical coordinates with 0,0 in top-left
+
+#if 	defined(ICS_GTi9100)
+#define X_MAX				800	//	touch.deviceType = touchscreen
+#define Y_MAX				760	//	touch.orientationAware = 0
+#define SCALE_X_RAW			XY_MAX	//	devices.internal = 0
+#define SCALE_X_SCREEN			500	// These values were experimentally selected based on	
+#define SCALE_Y_RAW			XY_MAX	//	MDT sending 1920 x 1920
+#define SCALE_Y_SCREEN			500	// 	scaling SCREEN/RAW min=0; max=X_MAX
+#define SINGLE_TOUCH			0
+#define X_SHIFT				0
+#define Y_SHIFT				0
+#define SWAP_LEFTRIGHT			0
+#define SWAP_UPDOWN			0
+#define SWAP_XY				0
+#define CORNER_BUTTON			0
+#define ICS_BAR				0
+#define KERNEL_2_6_38_AND_LATER
+
+#endif
+#ifdef __KERNEL__
+	typedef struct input_dev	 	si_input_dev;
+	
+	#define si_input_report_key(x,y,z)	input_report_key(x, y, z)
+	#define si_input_report_rel(x,y,z)	input_report_rel(x, y, z)		
+	#define si_input_sync(x)     		input_sync(x);
+	#define si_input_allocate_device()	input_allocate_device()
+	#define si_set_bit(x,y)			set_bit(x,y)
+
+	#define SI_MDT_DEBUG_PRINT(string,args...)		printk(KERN_ERR string,##args)
+#else
+	typedef unsigned char si_input_dev;
+
+	#include "..\..\platform\api\si_osdebug.h"
+	
+	#define SI_MDT_DEBUG_PRINT(x)		CBUS_DEBUG_PRINT(x)
+
+	#define si_input_report_key(x,y,z)	SI_MDT_DEBUG_PRINT(("MDTkeyboard  event %02x %02x\n",(int)y,(int)z))
+	#define si_input_report_rel(x,y,z)	SI_MDT_DEBUG_PRINT(("MDTnon-mouse event %02x %02x\n",(int)y,(int)z))
+	#define si_input_sync(x)		SI_MDT_DEBUG_PRINT(("Submit HID event\n"))
+	#define si_input_allocate_device()	0
+	#define si_set_bit(x,y)			SI_MDT_DEBUG_PRINT(("MDTkeyboard config %02x\n", (int)y))
+
+	unsigned char *memscan(unsigned char *str_a, unsigned char key, unsigned char length);
+
+	#define ENOMEM 0x1
+	#define EV_REP 0x2
+#endif
+
+#define mdt_event_header		\
+	unsigned char				isNotLast:1;	\
+	unsigned char				isKeyboard:1;	\
+	unsigned char				isPortB:1; 	\
+	unsigned char          			isHID  :1;		
+
+#define mdt_rawevent_header		\
+	unsigned char				isRW:1;		\
+	unsigned char				isRequest:1;	\
+	unsigned char				isPriority:1; 	\
+	unsigned char          		isHID:1;		
+
+
+#define mdt_cursor_suffix		\
+	unsigned char				reserved:1;	\
+	unsigned char				isGame:1;
+
+
+struct mdt_mouse_XYZ_t{
+    signed char      		        x_byteLen;
+    signed char      		        y_byteLen;
+    signed char      		        z_byteLen;
+    unsigned char        		      	reserved[3];
+};
+
+struct mdt_mouse_XYZ_VS_t{
+	unsigned char          	    	xyz_byteLen[3];
+	struct {
+		unsigned char          	byte_8bit[2];
+		unsigned char        	   	byte_6bit:6;
+		mdt_cursor_suffix	// common, 2 bit suffix
+	} vendor_specific;
+};
+
+struct mdt_touch_XYZ_t{
+    unsigned char				xy_wordLen[2][2];
+	struct {
+		unsigned char			byte_8bit;
+		unsigned char			byte_6bit:6;
+		mdt_cursor_suffix	// common, 2 bit suffix
+	} vendor_specific;    
+};
+
+struct mdt_game_XYZRz_t{
+	unsigned char      		        xyzRz_byteLen[4];
+	unsigned char      		        buttons_ex;
+	unsigned char      		        dPad:4;
+	unsigned char      		        deviceID:2;
+	mdt_cursor_suffix	   	// common, 2 bit suffix
+};
+
+struct mdt_suffix{
+	unsigned char				other_data[5];
+	unsigned char	        	   	other_data_bits:6;
+	mdt_cursor_suffix	   	// common, 2 bit suffix
+};
+
+
+struct mdt_non_mouse_cursorheader_t{
+	unsigned char          		isTouched:1;
+	unsigned char				contactID:2;
+	unsigned char				isNotMouse:1;
+	mdt_event_header		// common, 4 bit header nibble
+};
+
+struct mdt_mouse_cursorheader_t {    
+	unsigned char          		button:3;
+	unsigned char				isNotMouse:1;
+	mdt_event_header		// common, 4 bit header	nibble
+} ;
+
+
+struct mdt_cursor_mouse_t{	  	// 4 bytes or 7 bytes in length
+  	struct mdt_mouse_cursorheader_t	header;		//use when (!IsNotMouse)
+	union {
+	 	struct mdt_mouse_XYZ_t	  XYZ;		//use when (!IsNotLast) 
+		struct mdt_mouse_XYZ_VS_t XYZ_VS;	//use when (!IsNotMouse) && (IsNotLast)
+		unsigned char		raw[6];
+	} body;
+};
+
+struct mdt_cursor_other_t{		// 4 bytes or 7 bytes in length			 
+	union {
+	  	struct mdt_non_mouse_cursorheader_t 	touch;  //use when (IsNotMouse)
+		struct mdt_mouse_cursorheader_t		game;
+		unsigned char				raw;
+	} header;
+	union {
+		struct mdt_touch_XYZ_t			touchXYZ;	//use when (IsNotMouse) && (!IsGame)
+		struct mdt_game_XYZRz_t			gameXYZRz;	//use wehn (IsNotMouse) && (IsGame)
+		struct mdt_suffix			suffix;
+		unsigned char 				raw[6];
+	} body;
+};
+
+struct mdt_keyboard_header_t{
+  	unsigned char	   			modifier_keys :3;
+	unsigned char	   			reserved:1;			//set to 0
+	mdt_event_header
+};
+
+struct mdt_raw_with_header {
+  	unsigned char	   			ls_nibble :4;
+	mdt_rawevent_header
+};
+
+struct mdt_keyboard_event_t{          	//4 bytes or 7 bytes in length
+	struct mdt_keyboard_header_t	header;	// to avoid wasting space, all bit fields must be in the same struct
+	union {
+		struct {
+       			unsigned char		keycodes_firstThree[3];
+       			unsigned char		reserved [3];
+     		} truncated;
+		unsigned char			keycodes_all[6];
+	} body;
+};
+
+struct mdt_header_first {	       	//2012-05-10 - add RAW packet structure
+	unsigned char	   			ls_nibble :4;
+	mdt_event_header
+	unsigned char				other_data_suffix[7];
+};
+
+union mdt_event_t{			// 4 bytes 7 bytes in length
+	struct mdt_cursor_mouse_t	event_mouse;
+	struct mdt_cursor_other_t	event_cursor;
+	struct mdt_keyboard_event_t  	event_keyboard;
+	struct mdt_header_first		header;
+	unsigned char			bytes[7];
+};
+
+struct mdt_burst_01_t{	     		// 6, 9, 13, or 16 bytes
+	unsigned char          		ADOPTER_ID[2];
+	union mdt_event_t		events[2];
+};
+
+
+// -------------------------------------------------------------------------------
+// INPUT device instance definition
+
+#define INPUT_DISABLED				0
+#define INPUT_WAITING_FOR_REGISTRATION		1
+#define INPUT_ACTIVE				2
+
+#define DEV_TYPE_MOUSE 				0
+#define DEV_TYPE_KEYBOARD			1
+#define DEV_TYPE_TOUCH				2
+#define DEV_TYPE_GAME				3
+#define DEV_TYPE_COUNT				4
+
+
+#define MDT_TOUCH_INACTIVE			1
+#define MDT_TOUCH_ACTIVE			2
+
+#define MDT_VERSION				1
+#define M_CHAR					'M'
+#define D_CHAR					'D'
+#define T_CHAR					'T'
+
+#define NOTICE_DEV_PLUG				'R'
+#define NOTICE_DEV_UNPLUG			'U'
+#define RESPONSE_ACK				'A'	
+#define RESPONSE_NACK				'N'
+
+#define PARSE_FAILURE				4
+#define PARSE_HP_ERROR				2
+#define PARSE_HID_ERROR				1
+#define PARSE_HID_OK				0
+
+#define MDT_VERSION_1				1
+
+#define REGISTRATION_SUCCESS			0
+#define REGISTRATION_ERROR			1
+
+struct gamepad_history_t {
+	unsigned int			abs_x;
+	unsigned int			abs_y;
+	int				x_delta;
+	int				y_delta;
+	unsigned char 			dpad_event;
+	unsigned char			other_buttons;	
+};
+
+struct mdt_touch_history_t{
+	unsigned int			abs_x;		//Cached coordinate values for multi-touch HIDs
+	unsigned int			abs_y;		//	the array is limited to 3 members since MDT packet
+	unsigned char			isTouched;	//	structure only has 2 bits to ID the contact
+	unsigned char			wasIsTouched;
+	unsigned char			state;
+	unsigned int			time_of_last_contact;	//2013-04-25... offer release timeout
+};
+
+struct si_mdt_inputdevs_t {
+	struct device	   	 	*g_mdt_dev;			// Debug variables
+	struct class 	    		*g_mdt_class;
+
+	struct workqueue_struct 	*mdt_joystick_wq;
+	struct delayed_work 		repeat_for_gamepad;
+
+	struct workqueue_struct 	*mdt_touchscreen_wq;
+	struct delayed_work 		timeout_for_touchscreen;
+	unsigned char			touchscreen_timer_on;
+
+	unsigned char			prior_mouse_buttons;
+	struct gamepad_history_t	prior_game_event;	
+	struct mdt_touch_history_t	prior_touch_events[MDT_MAX_TOUCH_CONTACTS];	
+	unsigned char			prior_touch_button;
+#ifdef  PHOENIX_BLADE
+	unsigned char 			touch_debounce_counter;
+	enum phoenix_blade_demo_state_e	phoenix_blade_state;
+	struct mdt_touch_history_t	prior_native_touch;
+	struct mdt_double_touch_t	double_touch;	
+	struct mdt_simulated_buttons_t	simulated;
+#endif
+	unsigned char 			is_dev_registered[DEV_TYPE_COUNT];// Instance tracking variables
+	unsigned char			keycodes_old[MDT_HID_INPUT_REPORT];	// Prior HID input report
+	unsigned char			keycodes_new[MDT_HID_INPUT_REPORT]; // Current HID input report
+	unsigned char			*key_map;	
+
+	//user overrides
+	unsigned int			x_max, x_screen, x_raw, x_shift;
+	unsigned int			y_max, y_screen, y_raw, y_shift;
+	unsigned int			swap_xy, swap_updown, swap_leftright;
+
+#ifdef MHL_BT_HID_DEMO
+	unsigned char			is_ctrl_modifier;
+#endif
+
+	//note: Unsuccesfully tried to use an array of pointers for si_input_dev. This didn't work.
+	si_input_dev			*dev_touchscreen;
+	si_input_dev			*dev_keyboard;			// Input devices are event generating interfaces in 
+	si_input_dev 			*dev_mouse;			//    the Linux input subsystem. Such devices
+									//    are typically located under /dev/input/<xyz>
+} ;									//    Linux file system. These devices can be read but,
+									//    cannot be written. When read, the data retrieved
+
+#define MDT_DISCOVERY_SIZE		4
+#define MDT_DISCOVERY_DISABLE		1
+
+#define MDT_MIN_PACKET_LENGTH		4
+#define MDT_KEYBOARD_PACKET_TAIL_LENGTH	3
+#define MDT_KEYBOARD_PACKET_LENGTH	(MDT_MIN_PACKET_LENGTH + MDT_KEYBOARD_PACKET_TAIL_LENGTH)
+#define MDT_TOUCH_PACKET_LENGTH		5
+#define MDT_MOUSE_PACKET_LENGTH		MDT_MIN_PACKET_LENGTH
+#define MDT_MAX_PACKET_LENGTH		MDT_KEYBOARD_PACKET_LENGTH
+
+        
+#define MDT_SYNC_ERROR_OFFSET		8
+#define MDT_SYNC_ERROR_FLAG_MASK	0xF0
+#define MDT_SYNC_ERROR_VALUE_MASK	0x0F
+#define MDT_SEND_ERROR_FLAG		0x80
+#define MDT_SYNC_ERROR_FLAG		0
+
+
+#define MDT_EVENT_HANDLED		1
+
+									//    will reflect event time, source, & value.
+unsigned char  	mdt_input_init(void);
+void	 	mdt_input_deregister(void);
+uint8_t		mdt_deregister_device(unsigned char mdt_device_type, unsigned char isReset);
+uint8_t		mdt_register_device(unsigned char mdt_device_type);
+void		mdt_generate_event_keyboard(struct mdt_keyboard_event_t *keyboardPacket);
+void		mdt_generate_event_mouse(struct mdt_cursor_mouse_t *mousePacket);
+void 	 	mdt_generate_event_gamepad(struct mdt_cursor_other_t *gamePacket);
+unsigned char	mdt_generate_event_touchscreen(struct mdt_cursor_other_t *touchPacket, 
+			unsigned char submitEvent, unsigned char isOnTouchTimeout);
+unsigned char	mdt_generate_event_mouse_from_nativetouch(struct mdt_touch_history_t *touch_event);
+void		mdt_reset_touch(void);
+
+#ifdef MHL_BT_HID_DEMO
+unsigned char   mhl_bt_hid_demo_key_to_touch(unsigned char scancode, unsigned char value);
+#endif
+
+enum 	mhawb_sendapireturn_e {
+	MHAWB_SENDAPI_SUCCESS			= 0
+	, MHAWB_SENDAPI_ERROR_FIFOFULL		= 0x80
+	, MHAWB_SENDAPI_ERROR_INVALIDTOUCHDATA	= 0x81
+	, MHAWB_SENDAPI_ERROR_WRITEBURSTFAILURE	= 0x82
+	, MHAWB_SENDAPI_ERROR_UNKNOWNMHLERROR	= 0x83
+};
+
+enum 	mhawb_updateapireturn_e {
+	MHAWB_UPDATEAPI_SUCCESS			= 0
+	, MHAWB_UPDATEAPI_ERROR_EXCEEDSRANGE	= 0x84
+	, MHAWB_UPDATEAPI_ERROR_UNSUPPORTEDFIELD= 0x85
+};
+
+enum 	mhawb_syncapireturn_e {
+	MHAWB_SYNCAPI_SUCCESS			= 0x00
+	, MHAWB_SYNCAPI_SUCCESS_MDTMOUSE_SENT	= 0x10
+	, MHAWB_SYNCAPI_SUCCESS_MDTKEYBOARD_SENT= 0x20
+	, MHAWB_SYNCAPI_SUCCESS_MDTTOUCH_SENT	= 0x40
+	, MHAWB_SYNCAPI_SUCCESS_MDTGAME_SENT	= 0x80
+	, MHAWB_SYNCAPI_ERROR_PRIORPENDING	= 0x08
+	, MHAWB_SYNCAPI_ERROR_INVALIDDATA	= 0x09
+	, MHAWB_SYNCAPI_ERROR_WRITEBURSTFAILURE	= 0x0A
+	, MHAWB_SYNCAPI_ERROR_UNKNOWNERROR	= 0x0B
+};
+
+
+uint8_t mdt_burst_send_touch(struct mdt_cursor_other_t *touchPacket);
+//uint8_t mdt_burst_value_update(struct hid_usage *usage, __s32 value);
+//uint8_t mdt_burst_sync_and_send(void);
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_device.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_device.c
new file mode 100755
index 000000000000..53a151868faf
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_device.c
@@ -0,0 +1,419 @@
+/******************************************************************************
+ *
+ * Copyright (c) 2002-2013, Silicon Image, Inc.  All rights reserved.
+ * No part of this work may be reproduced, modified, distributed, transmitted,
+ * transcribed, or translated into any language or computer format, in any form
+ * or by any means without written permission of: Silicon Image, Inc.,
+ * 1140 East Arques Avenue, Sunnyvale, California 94085
+ *
+ *****************************************************************************/
+/**
+ * @file si_drv_sii5293.c
+ *
+ * @brief 5293 driver.
+ * @brief Driver layer internal file
+ *
+ *****************************************************************************/
+
+#include "si_platform.h"        // Interface to board environment
+#include "si_drv_device.h"
+#include "si_drv_cbus.h"
+
+#include "si_sii5293_registers.h"
+#if defined(INC_CEC)  
+#include "si_cec_config.h"
+#include "si_drv_cpi_internal.h"
+#endif
+#include "si_drv_cra_cfg.h"
+#include "si_drv_rx.h"
+#include "si_drv_rx_isr.h"
+#include "si_drv_board.h"
+#ifdef SK_TX_EVITA
+#include "si_drv_evita.h"
+#endif
+
+#ifdef MHAWB_SUPPORT
+#include "si_drv_mhawb.h"
+#include "si_drv_hawb.h"
+#endif
+
+#define HW_RESET_PERIOD		10	// 10 ms.
+#define HW_RESET_DELAY       100
+SiiPortType_t g_portType = SiiPortType_HDMI;
+
+/*****************************************************************************/
+/**
+ *  @brief Reset the 5293 chip by toggle the reset pin at 5293
+ *
+ *  @param[in]      hwResetPeriod       The delay time during the low level.
+ *  @param[in]      hwResetDelay        The delay time after reset hw.
+ *
+ *****************************************************************************/
+void SiiHwReset(uint16_t hwResetPeriod,uint16_t hwResetDelay)
+{
+	// Toggle RX reset pin
+	SiiGpioControl(GPIO_RST, false);
+	HalTimerWait(hwResetPeriod);
+    SiiGpioControl(GPIO_RST, true);
+
+	// then wait per spec
+	HalTimerWait(hwResetDelay);
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief  Set the port type of the specific Rx port.
+ *
+ *  @param[in]      portIndex       - SiiPORT_x     - Rx port (0-1).
+ *                                  - SiiPORT_ALL   - SiiPORT_ALL       - All ports are acted on simultaneously.
+ *  @param[in]      portType        true - enable, false - disable
+ *
+ *  @return     void
+ *
+ * @note: The 'portIndex' parameter value 0xFF should not be used unless
+ *        all ports are HDMI1.3/a (not MHL or CDC)
+ *
+ *****************************************************************************/
+void SiiDrvSwitchPortType(SiiPortType_t portType)
+{
+    static uint8_t peq_val_HDMI[8] = {0xC6, 0XF5, 0XF4, 0XE4, 0XD4, 0XA4, 0X94, 0X25};
+    static uint8_t peq_val_MHL[8] = {0x26, 0X10, 0X24, 0X11, 0X12, 0X22, 0X1A, 0X25};
+    if (portType == SiiPortType_HDMI)
+    {
+        SiiRegWriteBlock(REG_PEQ_VAL0, peq_val_HDMI, 8);
+    }else
+    {
+        SiiRegWriteBlock(REG_PEQ_VAL0, peq_val_MHL, 8);
+    }
+    g_portType = portType;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief This function disables the device or places the device in
+ *         software reset if it does not power up in a disabled state.
+ *         It may be used to initialize registers that require a value
+ *         different from the power-up state and are common to one or
+ *         more of the other component modules.
+ *
+ *  @return     State
+ *  @retval     true if the configuration was successful
+ *  @retval     false if some failure occurred
+ *
+ * @note: This function leaves the device in a disabled state until the
+ *        SiiDrvDeviceRelease function is called.
+ *
+ *****************************************************************************/
+bool_t SiiDrvDeviceInitialize ( void )
+{
+    bool_t  success = false;
+    uint16_t deviceID;
+    uint8_t revison;
+
+#if defined(__KERNEL__)
+    gDriverContext.chip_revision = 0xFF;
+#endif
+
+    SiiHwReset(HW_RESET_PERIOD, HW_RESET_DELAY);
+    for ( ;; )
+    {
+        SiiDrvSoftwareReset(RX_M__SRST__SRST);
+
+        deviceID = SiiRegRead( REG_DEV_IDH_RX );
+        deviceID = ( deviceID << 8) | SiiRegRead( REG_DEV_IDL_RX );
+
+        revison = SiiRegRead( REG_DEV_REV );
+#if defined(__KERNEL__)
+        gDriverContext.chip_revision = revison;
+#endif
+        if ( 0x5293 == deviceID )
+        {
+            DEBUG_PRINT( MSG_ALWAYS, "Device ID: %04X\n", (int)deviceID );
+            DEBUG_PRINT( MSG_ALWAYS, "Device Revision: %02X\n", (int)revison );
+        }
+        else
+        {
+            //DEBUG_PRINT( MSG_ALWAYS, "\n Device Id check failed!\n" );
+            //break;
+        }  
+
+#ifdef SK_TX_EVITA
+        if ( !SiiDrvEvitaInit())
+        {
+            DEBUG_PRINT( MSG_ALWAYS, "\n SiiDrvEvitaInitialize failed!\n" );
+            break;
+        }
+#endif             
+        if ( !SiiMhlRxInitialize()) 
+        {
+            DEBUG_PRINT( MSG_ALWAYS, "\n SkAppDeviceInitCbus failed!\n" );
+            break;
+        }
+        
+        if ( !SiiDrvRxInitialize()) 
+        {
+            DEBUG_PRINT( MSG_ALWAYS, "\n SkAppDeviceInitRx failed!\n" );
+            break;
+        }
+
+#ifdef MHAWB_SUPPORT
+        mhawb_init();
+#endif
+
+        SiiDrvSwitchPortType(SiiPortType_HDMI);
+        success = true;
+        break;
+    }
+
+    return( success );
+}
+
+void SiiDrvDeviceRelease ( void )
+{
+    DEBUG_PRINT( MSG_ALWAYS, "SiI5293 may continue to output video. Driver features and APIs will not work.\n" );
+#ifdef MHAWB_SUPPORT
+    mhawb_destroy();
+#endif
+}
+
+/*****************************************************************************/
+/**
+ *  @brief  Enable or disable RX termination for the selected port(s)
+ *
+ *  @param[in]      portIndex       - 0-1:  Switch port to control
+ *                                  - 0xFF: Apply to all ports.
+ *  @param[in]      enableVal       The bit pattern to be used to enable
+ *                                  or disable termination
+ *                                      0x00 - Enable for HDMI mode
+ *                                      0x55 - Enable for MHL mode
+ *                                      0xFF - Disable
+ *
+ *  @return     void
+ *
+ * @note: The 'enableVal' parameter for this function is NOT boolean as
+ *        it is for the companion si_DeviceXXXcontrol functions.
+ *        The 'portIndex' parameter value 0xFF should not be used unless
+ *        all ports are HDMI1.3/a (not MHL or CDC)
+ *
+ *****************************************************************************/
+void SiiDrvSwitchDeviceRXTermControl ( uint8_t enableVal )
+{
+    SiiRegModify( REG_RX_CTRL5, MSK_TERM, enableVal );
+}
+
+SiiPortType_t SiiDrvGetPortType(void)
+{
+    return g_portType;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief  Enable or disable HDCP access for the selected port(s)
+ *
+ *  @param[in]      portIndex           - 0:  Switch port to control.
+ *                                      - 0xFF: Apply to all ports.
+ *  @param[in]      enableHDCP          - true: to enable
+ *                                      - false: to disable
+ *
+ *  @return     void
+ *
+ * @note: The 'portIndex' parameter value 0xFF should not be used unless
+ *        all ports are HDMI1.3/a (not MHL or CDC)
+ *
+ *****************************************************************************/
+void SiiDrvSwitchDeviceHdcpDdcControl ( bool_t enableHDCP )
+{
+    uint8_t enableVal, enableMask;
+
+    enableVal = enableHDCP ? SET_BITS : CLEAR_BITS;
+
+    // only one port in 5293, no need to check portIndex
+    enableMask = RX_M__SYS_SWTCH__RX0_EN | RX_M__SYS_SWTCH__DDC0_EN | RX_M__SYS_SWTCH__DDC_DEL_EN;
+
+    SiiRegModify( RX_A__SYS_SWTCH, enableMask, enableVal );  
+}
+
+
+
+/*****************************************************************************/
+/**
+ *  @brief Enable or disable HPD for the selected port(s)
+ *
+ *  @param[in]      portIndex       - 0-4:  Switch port to control
+ *                                  - 0xFF: Apply to all ports.
+ *  @param[in]      enableHDCP      - true: to enable
+ *                                  - false: to disable
+ *  @param[in]      mode            - true:  to tristate the HPD
+ *                                  - false: to clear hpd
+ *
+ *  @return     void
+ *
+ * @note: The 'portIndex' parameter value 0xFF should not be used unless
+ *        all ports are HDMI1.3/a (not MHL or CDC)
+ *
+ *****************************************************************************/
+void SiiDrvSwitchDeviceHpdControl ( bool_t enableHPD, uint8_t mode)
+{
+    uint8_t enableVal;
+
+    if (mode)
+        enableVal = enableHPD ? VAL_HP_PORT_MHL : CLEAR_BITS;
+    else
+        enableVal = enableHPD ?  VAL_HP_PORT_ALL_HI : CLEAR_BITS;
+    SiiRegModify( REG_HP_CTRL, VAL_HP_PORT0_MASK, enableVal );
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief        Check connectivity of HDMI/MHL calbe.
+ *            Update internal status of the cable.
+ *             Update register settings for HDMI/MHL connectivity.
+ *
+ *****************************************************************************/
+void SiiSwitchConnectionCheck(void)
+{
+    bool_t cableStatus = false;
+    uint8_t mhlStatus = 0;
+
+    // Check MHL cable in/out
+    if ( SiiDrvCbusMhlStatusGet ( &mhlStatus ) )
+    {
+        // MHL cable out
+        if ( 0 == mhlStatus )
+        {
+#if defined(__KERNEL__)
+            gDriverContext.mhl_cable_state = false;
+#endif
+            SiiDrvSwitchPortType(SiiPortType_HDMI);
+            SiiLedControl(LED_ID_2, false);
+            SiiLedControl(LED_ID_3, false);
+            DEBUG_PRINT( MSG_ALWAYS, "Cable connection change: MHL cable out\n" );
+        }
+        else
+        {
+            // MHL cable in
+#if defined(__KERNEL__)
+            gDriverContext.mhl_cable_state = true;
+#endif
+            SiiDrvSwitchPortType(SiiPortType_MHL);
+            SiiDrvSwitchDeviceHpdControl( true, true );  // HPD tri-state
+            SiiDrvSwitchDeviceRXTermControl( SiiTERM_DISABLE );
+            SiiLedControl(LED_ID_2, true);
+            SiiLedControl(LED_ID_3, false);
+            DEBUG_PRINT( MSG_ALWAYS, "Cable connection change: MHL cable in\n" );
+        }
+    }
+
+    if ( SiiDrvCableStatusGet ( &cableStatus ) )
+    {
+        if (cableStatus)
+        {
+#if defined(__KERNEL__)
+            gDriverContext.pwr5v_state = true;
+#endif
+            SiiDrvSwitchDeviceHdcpDdcControl( true );
+            if (SiiDrvGetPortType() == SiiPortType_HDMI)
+            {
+                SiiDrvSwitchDeviceRXTermControl( SiiTERM_HDMI );
+                SiiDrvSwitchDeviceHpdControl( true, false );             //  HPD on
+                SiiLedControl(LED_ID_2, false);
+                SiiLedControl(LED_ID_3, true);
+            }
+            DEBUG_PRINT( MSG_ALWAYS, "Cable connection change: cable in\n" );
+        }
+        else
+        {
+#if defined(__KERNEL__)
+            gDriverContext.pwr5v_state = false;
+            gDriverContext.mhl_cable_state = false;
+            SiiConnectionStateNotify(false);
+#endif
+            SiiDrvSwitchPortType(SiiPortType_HDMI);
+            SiiDrvSwitchDeviceHpdControl( false, false );                //HPD low
+            SiiDrvSwitchDeviceRXTermControl( SiiTERM_DISABLE );
+            SiiDrvSwitchDeviceHdcpDdcControl( false );
+            SiiLedControl(LED_ID_2, false);
+            SiiLedControl(LED_ID_3, false);
+            DEBUG_PRINT( MSG_ALWAYS, "Cable connection change: cable out\n" );
+        } 
+    }
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief Monitors 5293 interrupts and calls an interrupt processor
+ *         function in the applicable driver if an interrupt is encountered.
+ *
+ *  @return     State
+ *  @retval     true if device interrupts occurs
+ *  @retval     false if no interrupts
+ *
+ * @note: This function is not designed to be called directly from a physical
+ *        interrupt handler unless provisions have been made to avoid conflict
+ *        with normal level I2C accesses.
+ *        It is intended to be called from normal level by monitoring a flag
+ *        set by the physical handler.
+ *
+ *****************************************************************************/
+void SiiDrvDeviceManageInterrupts (void)
+{
+    uint8_t         intStatus2;
+
+#if defined(__KERNEL__)
+    //DEBUG_PRINT(MSG_STAT, ("-------------------SiiMhlTxDeviceIsr start -----------------\n"));
+    while(is_interrupt_asserted())   // check interrupt assert bit
+#else
+    if (SiiRegRead(RX_A__INTR_STATE) & RX_M__INTR_STATE)
+#endif
+    {
+#ifdef MHAWB_SUPPORT
+        if (g_mhawb.state >= MHAWB_STATE_INIT)
+        {
+            if (mhawb_do_isr_work() == MHAWB_EVENT_HANDLER_SUCCESS)
+                return;
+        }
+#endif
+        // Determine the pending interrupts and service them with driver calls
+        // Each function will call its appropriate callback function if a status
+        // change is detected that needs upper level attention.
+
+        // Get the register interrupt info
+        intStatus2 = SiiRegRead( REG_INTR_STATE_2 );
+
+        if(intStatus2 & BIT_RX_INTR)
+        {
+            DEBUG_PRINT(MSG_DBG, ("RX Interrupt\n"));
+            SiiRxInterruptHandler();
+            SiiRxSetVideoStableTimer();
+        }
+        if(intStatus2 & BIT_CBUS_INTR)
+        {
+            DEBUG_PRINT(MSG_DBG, ("CBUS Interrupt\n"));
+#ifdef MHAWB_SUPPORT
+            if (g_mhawb.state == MHAWB_STATE_TAKEOVER || g_mhawb.state == MHAWB_STATE_DISABLED)
+            {
+                SiiDrvHawbProcessInterrupts();
+            }
+#endif
+            SiiDrvCbusProcessInterrupts();
+            SiiMhlRxIntrHandler();
+        }
+#if defined(INC_CEC)        
+        if(intStatus2 & BIT_CEC_INTR)
+        {
+            DrvCpiProcessInterrupts();
+            DEBUG_PRINT(MSG_DBG, ("CEC Interrupt\n"));
+        }
+#endif
+        
+        SiiSwitchConnectionCheck();
+
+    }
+#if defined(__KERNEL__)
+    //DEBUG_PRINT(MSG_STAT, ("-------------------SiiMhlTxDeviceIsr end -------------------\n"));
+#endif
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_device.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_device.h
new file mode 100755
index 000000000000..b3baa36dd137
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_device.h
@@ -0,0 +1,84 @@
+//***************************************************************************
+//!file     si_drv_device.h
+//!brief    5293 driver header.
+//!brief    Component layer file
+//!brief    Application layer file
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2010-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+#ifndef __SI_DRV_DEVICE_H__
+#define __SI_DRV_DEVICE_H__
+#include "si_common.h"
+
+
+enum
+{
+    SiiTERM_HDMI                = 0xC8,     // Enable for HDMI mode
+    SiiTERM_MHL                 = 0x49,     // Enable for MHL mode
+    SiiTERM_DISABLE             = 0x4B,     // Disable
+};
+
+typedef enum _SiiPortType_t
+{
+    SiiPortType_HDMI = 0,               // Port is in HDMI mode
+    SiiPortType_MHL,                // Port is in MHL mode
+} SiiPortType_t;
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvDeviceInitialize
+// Description: This function disables the device or places the device in
+//              software reset if it does not power up in a disabled state.
+//              It may be used to initialize registers that require a value
+//              different from the power-up state and are common to one or
+//              more of the other component modules.
+// Parameters:  none
+// Returns:     It returns true if the initialization is successful, or false
+//              if some failure occurred.
+//
+// Note:        The function leaves the device in disabled state until the
+//              SiiDeviceRelease function is called.
+//------------------------------------------------------------------------------
+
+bool_t SiiDrvDeviceInitialize( void );
+
+void SiiDrvDeviceRelease ( void );
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvDeviceManageInterrupts
+// Description: Monitors 5293 interrupts and calls an interrupt process
+//              function in the applicable driver.
+// NOTE:    This function is not designed to be called directly from a physical
+//          interrupt handler unless provisions have been made to avoid conflict
+//          with normal level I2C accesses.
+//          It is intended to be called from normal level by monitoring a flag
+//          set by the physical handler.
+//------------------------------------------------------------------------------
+
+void SiiDrvDeviceManageInterrupts(void);
+
+
+//------------------------------------------------------------------------------
+// Function:    SiiDrvSwitchDeviceRXTermControl
+// Description: Enable or disable RX termination for the selected port(s)
+// Parameters:  portIndex   - 0-4:  Switch port to control
+//                          - 0xFF: Apply to all ports.
+//              enableVal   - The bit pattern to be used to enable or disable
+//                            termination
+//                          0x00 - Enable for HDMI mode
+//                          0x55 - Enable for MHL mode
+//                          0xFF - Disable
+//
+// Note:        The 'enableVal' parameter for this function is NOT boolean as
+//              it is for the companion si_DeviceXXXcontrol functions.
+// Note:        The 'portIndex' parameter value 0xFF should not be used unless
+//              all ports are HDMI1.3/a (not MHL or CDC)
+//------------------------------------------------------------------------------
+void SiiDrvSwitchDeviceRXTermControl ( uint8_t enableVal );
+
+
+#endif // __SI_DRV_DEVICE_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx.c
new file mode 100755
index 000000000000..a35fe4da4461
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx.c
@@ -0,0 +1,346 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+
+#include "si_cra.h"
+#include "si_sii5293_registers.h"
+
+#include "si_drv_rx.h"
+#include "si_drv_rx_info.h"
+#include "si_rx_audio.h"
+#include "si_rx_info.h"
+#include "si_drv_rx_isr.h"
+#include "si_drv_device.h"
+
+#include "si_video_tables.h"
+
+
+#define RX_CTS_THRESHOLD 0x50 // bits 3...6
+#define	SII_SCALED_XCLK 4096000UL // (2000 * 2048)
+
+const uint8_t default_sval_regs[4] = {0x0F, 0x20, 0x00, 0x00};
+static SiiRxTiming_t rxTimingInfo;
+static SiiRxTiming_t *pRxTimingInfo = &rxTimingInfo;
+
+
+void SiiDrvRxTimingInfoSet(SiiRxTiming_t *pNewRxTimingInfo)
+{
+	memcpy( pRxTimingInfo, pNewRxTimingInfo, sizeof(SiiRxTiming_t) );
+}
+
+SiiRxTiming_t *SiiDrvRxTimingInfoGet(void)
+{
+	return pRxTimingInfo;
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief		Return RX Pixel Replicate
+ *
+ *  @return	RX RX Pixel Replicate
+ *
+ *****************************************************************************/
+uint8_t SiiDrvRxGetPixelReplicate()
+{
+	uint8_t pix_repl = (SiiRegRead(RX_A__SYS_CTRL1) & RX_M__SYS_CTRL1__ICLK) >> 4;
+	return pix_repl;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Return RX Video Status
+ *
+ *  @return	RX RX Video Status
+ *
+ *****************************************************************************/
+uint8_t SiiDrvRxGetVideoStatus()
+{
+	uint8_t vid_stat_reg = SiiRegRead(RX_A__VID_STAT);
+	return vid_stat_reg;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Return RX Pixel Frequency in 10kHz units
+ *
+ *  @return	RX RX Pixel Frequency
+ *
+ *****************************************************************************/
+uint16_t SiiDrvRxGetPixelFreq(void)
+{
+	uint16_t xcnt = 0;
+	uint32_t pixel_freq = SII_SCALED_XCLK;
+	
+	xcnt = SiiRegReadWord(RX_A__VID_XPCNT0);
+	xcnt &=  0x0FFF;
+	  
+	if (0 == xcnt)
+	{
+        pixel_freq = 65535;
+	}
+    else
+    {
+	    pixel_freq /= xcnt;
+    }
+
+	if(pixel_freq > 65535)
+		pixel_freq = 65535;
+	
+	return (uint16_t) pixel_freq;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Return RX Sync Information
+ *
+ *  @param[in]		p_sync_info		pointer to return data buffer for sync information
+ *
+ *****************************************************************************/
+void SiiDrvRxGetSyncInfo(sync_info_type *p_sync_info)
+{
+	uint8_t d[4];
+
+	uint8_t pix_repl = SiiDrvRxGetPixelReplicate();
+	// it is more reliable to read it from HW then from a shadow register because the register could
+	// be sometimes reset to default value.
+
+	uint8_t vid_stat_reg = SiiDrvRxGetVideoStatus();
+
+	SiiRegReadBlock(RX_A__H_RESL, d, 4);
+
+	p_sync_info->ClocksPerLine = d[0] | (d[1] << 8);
+	p_sync_info->TotalLines = d[2] | (d[3] << 8);
+	p_sync_info->ClocksPerLine *= pix_repl + 1;
+	p_sync_info->PixelFreq = SiiDrvRxGetPixelFreq();
+	p_sync_info->Interlaced = (vid_stat_reg & RX_M__VID_STAT__INTERLACE) ? INTL : PROG;
+	p_sync_info->HPol = (vid_stat_reg & RX_M__VID_STAT__HSYNC_POL) ? POS : NEG;
+	p_sync_info->VPol = (vid_stat_reg & RX_M__VID_STAT__VSYNC_POL) ? POS : NEG;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Return Status of Sync Detection
+ *
+ *  @return	Status
+ *  @retval	true		Sync is detected
+ *  @retval	false		Sync is not detected
+ *
+ *****************************************************************************/
+bool_t SiiDrvRxIsSyncDetected(void)
+{
+	return 0 != (SiiRegRead(RX_A__STATE) & RX_M__STATE__SCDT);
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Return Status of HDMI Mode
+ *
+ *  @return	Status
+ *  @retval	true		HDMI is detected
+ *  @retval	false		HDMI is not detected
+ *
+ *****************************************************************************/
+bool_t SiiDrvRxHdmiModeGet(void)
+{
+	// NOTE: this function checks HDMI_MODE_ENABLED but not HDMI_MODE_DETECTED bit
+	return 0 != (SiiRegRead( RX_A__AUDP_STAT) & RX_M__AUDP_STAT__HDMI_MODE_ENABLED);
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Switch Video Mute
+ *
+ *  @param[in]		switch_on		true to switch on; false to switch off
+ *
+ *****************************************************************************/
+void SiiDrvRxMuteVideo(uint8_t switch_on)
+{
+	SiiRegBitsSet(RX_A__AUDP_MUTE, RX_M__AUDP_MUTE__VIDEO_MUTE, switch_on);
+}
+
+VideoPath_t SiiDrvRxGetOutVideoPath(void)
+{
+#if defined(__KERNEL__)
+    extern int output_format;
+    if (output_format >= 0 && output_format < PATH__MAXVALUE)
+        return output_format;
+    else
+#endif
+        return PATH__RGB;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		RX Initialization
+ *
+ *  @param[in]		inputIndex			input index
+ *  @param[in]		startInStandbyMode	true to start in standby mode; not if false
+ *
+ *  @return	Status
+ *  @retval	true		Success
+ *  @retval	false		Failure
+ *
+ *****************************************************************************/
+bool_t SiiDrvRxInitialize(void)
+{
+    bool_t success = true;
+    VideoPath_t outVideoPath;
+    uint8_t value;
+
+    SiiRegBitsSet( RX_A__SWRST2, RX_M__SWRST2__AUDIO_FIFO_AUTO, true );
+    SiiRegWrite( REG_RX_CTRL1, 0x3F );
+    SiiRegWrite( RX_A__VSI_CTRL1, 0x0C);
+    SiiRegWrite(RX_A__ACR_CTRL3, RX_CTS_THRESHOLD | RX_M__ACR_CTRL3__MCLK_LOOPBACK);
+
+    // init threshold for PLL unlock interrupt
+    SiiRegWriteBlock(RX_A__LK_WIN_SVAL, default_sval_regs, sizeof(default_sval_regs));
+
+    // set Video bus width and Video data edge
+    SiiRegModify(RX_A__SYS_CTRL1, RX_M__SYS_CTRL1__EDGE,
+    	 ((SI_INVERT_RX_OUT_PIX_CLOCK_BY_DEFAULT == ENABLE) ? RX_M__SYS_CTRL1__EDGE : 0) );
+
+    // AudioVideo Mute ON
+    SiiRegWrite(RX_A__AUDP_MUTE, RX_M__AUDP_MUTE__VIDEO_MUTE | RX_M__AUDP_MUTE__AUDIO_MUTE);
+
+    // set BCH threshold and reset BCH counter
+    SiiRegWrite(RX_A__BCH_THRES, 0x02);
+    // Capture and clear BCH T4 errors.
+    SiiRegWrite(RX_A__ECC_CTRL, RX_M__ECC_CTRL__CAPTURE_CNT);
+
+    outVideoPath = SiiDrvRxGetOutVideoPath();
+
+    switch (outVideoPath)
+    {
+        case PATH__RGB:
+            value = 0x00;
+            break;
+        case PATH__YCbCr444:
+            value = 0x80;
+            break;
+        case PATH__YCbCr422_16B:
+            value = 0xC0;
+            break;
+        case PATH__YCbCr422_20B:
+            value = 0xC8;
+            break;
+        case PATH__YCbCr422_16B_SYNC:
+        case PATH__YCbCr422_MUX8B_SYNC:
+            //AVC will do YCMUX only when input repetition is 2 or 4.
+            //If input repetition is 1, YCMUX block will disable automatically
+            value = 0xF0;
+            break;
+        case PATH__YCbCr422_20B_SYNC:
+        case PATH__YCbCr422_MUX10B_SYNC:
+            value = 0xF8;
+            break;
+        case PATH__YCbCr422_MUX8B:
+            value = 0xE0;
+            break;
+        case PATH__YCbCr422_MUX10B:
+            value = 0xE8;
+            break;
+        default:
+            value = 0x00;
+            break;
+    }
+    SiiRegWrite(RX_A__VID_AOF, value);
+    //enable AVC, default output is RGB, could be change via reigster RX_A__VID_AOF.
+    SiiRegWrite(RX_A__AEC_CTRL, RX_M__AEC_CTRL__AVC_EN);
+
+    SiiRegWrite(REG_COMB_CTRL, 0x8C);
+    SiiRegWrite(REG_DPLL_CFG3, 0x40);
+    SiiRegWrite(REG_DPLL_BW_CFG2, 0x00);
+
+    RxIsr_Init();
+
+    RxAudio_Init();
+
+    VMD_Init();
+
+    // set HDCP Error Threshold
+    SiiRegWriteWord(RX_A__ECC0_HDCP_THRES, RX_C__ECC0_HDCP_THRES_VALUE);
+
+    SiiRegModify( RX_A__SYS_CTRL1, RX_M__SYS_CTRL1__PDALL, SET_BITS);   //Power on device
+
+    return success;
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		RX Software Reset
+ *
+ *  @param[in]		reset_mask		reset mask
+ *
+ *****************************************************************************/
+void SiiDrvSoftwareReset(uint8_t reset_mask)
+{
+	uint8_t reg_val = SiiRegRead(RX_A__SRST);
+
+	SiiRegWrite(RX_A__SRST, reg_val | reset_mask);
+	SiiRegWrite(RX_A__SRST, reg_val & (~reset_mask));
+
+    // Clear 5v plug-out interrupts if any
+    SiiRegWrite(RX_A__INTR6, RX_M__INTR6__CABLE_UNPLUG);
+
+    // Clear 5v plug-in interrupt if any
+    SiiRegWrite(RX_A__INTR8, RX_M__INTR8__CABLE_IN);
+}
+
+#define AVC_RANGE_FIX
+void SiiDrvRxVideoPathSet(void)
+{
+#ifdef AVC_RANGE_FIX
+    VideoPath_t outVideoPath = SiiDrvRxGetOutVideoPath();
+    if ((ColorSpace_RGB == RxAVI_GetColorSpace()) && (PATH__RGB == outVideoPath) && (SiiRegRead(RX_A__VID_BLANK1) == 0x10))
+    {
+        // AVC will change the Blank level automatically, we can use it to know if input is limited range or not
+        // if input is RGB and limited range, Output is YCbCr, need to convert to RGB full range, but AVC does not do this. 
+        SiiRegWrite(RX_A__AVC_EN1, RX_M__AVC_EN1__YCbCr2RGB_RANGE);
+        SiiRegModify(RX_A__VID_MODE2, RX_M__VID_MODE2__YCBCR_2_RGB_RANGE_EN, SET_BITS);
+
+        // Also enable dither when doing color space range expansion
+        SiiRegWrite(RX_A__AVC_EN2, RX_M__AVC_EN2__DITHER);
+        SiiRegModify(RX_A__VID_MODE, RX_M__VID_MODE__DITHER, SET_BITS);
+    }
+    else if ((ColorSpace_RGB != RxAVI_GetColorSpace()) && (Range_Full == RxAVI_GetRangeQuantization()))
+    {        
+        // Change the Black level, AVC setting is not correct here.
+        SiiRegWrite(RX_A__AVC_EN1, CLEAR_BITS);
+        SiiRegWrite(RX_A__AVC_EN2, RX_M__AVC_EN2__BLANK_DATA);
+        SiiRegWrite(RX_A__VID_BLANK1, (ColorSpace_YCbCr422 == RxAVI_GetColorSpace()) ? 0x00 : 0x80);
+        SiiRegWrite(RX_A__VID_BLANK2, 0x00);
+        SiiRegWrite(RX_A__VID_BLANK3, 0x80);
+        if ( PATH__RGB != outVideoPath)
+        {
+            // if input is YCbCr and full range, output is YCbCr, need to convert to limited range, but AVC does not do this. 
+            SiiRegModify(RX_A__AVC_EN1, RX_M__AVC_EN1__RGB2YCbCr_RANGE, SET_BITS);
+            SiiRegModify(RX_A__VID_MODE, RX_M__VID_MODE__RGB_2_YCBCR_RANGE, SET_BITS);
+
+            if (outVideoPath == PATH__YCbCr444 || outVideoPath == PATH__YCbCr422_16B
+                || outVideoPath == PATH__YCbCr422_16B_SYNC || outVideoPath == PATH__YCbCr422_MUX8B
+                || outVideoPath == PATH__YCbCr422_MUX8B_SYNC)
+            {
+                // YCbCr 422 10 bit, do not need to do dither
+                // Also enable dither when doing color space range compression
+                SiiRegModify(RX_A__AVC_EN2, RX_M__AVC_EN2__DITHER, SET_BITS);
+                SiiRegModify(RX_A__VID_MODE, RX_M__VID_MODE__DITHER, SET_BITS);
+            }
+        }
+    }
+    else
+    {
+        SiiRegWrite(RX_A__AVC_EN1, CLEAR_BITS);
+        SiiRegWrite(RX_A__AVC_EN2, CLEAR_BITS);
+    }
+#endif
+}
+
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx.h
new file mode 100755
index 000000000000..67b5a81f291b
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx.h
@@ -0,0 +1,74 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+
+#ifndef SII_DRV_RX_H
+#define SII_DRV_RX_H
+
+#include "si_rx_video_mode_detection.h"
+#include "si_rx_audio.h"
+
+typedef struct
+{
+    uint8_t     videoIndex;         //!< see the table
+    uint16_t    pixelFreq;          //!< Pixel frequency in 10kHz units
+//    uint8_t     vertFreq;          //!< Vertical frame rate in Hz
+    uint16_t    clocksPerLine;      //!< Number of clocks per line
+    uint16_t    totalLines;         //!< Total number of lines per frame
+    bit_fld_t      interlaced : 1;  //!< true for interlaced, false for progressive
+    bit_fld_t      hPol       : 1;  //!< true for negative H Pulse, false for positive
+    bit_fld_t      vPol       : 1;  //!< true for negative V Pulse, false for positive
+    uint8_t     hdmi3dStructure;    //!< HDMI 3D_Structure according to HDMI spec.
+    uint8_t     extra3dData;        //!< HDMI 3D_Detail according to HDMI spec.
+}
+SiiRxTiming_t;
+
+typedef enum
+{
+	PATH__RGB,					// RGB, single edge clock
+	PATH__YCbCr444,				// YCbCr 4:4:4, single edge clock 
+	PATH__YCbCr422_16B,			// YCbCr 4:2:2, single edge clock, Y is separate, Cb and Cr multiplexed, 16 bit bus
+	PATH__YCbCr422_20B,			// YCbCr 4:2:2, single edge clock, Y is separate, Cb and Cr multiplexed, 20 bit bus
+	PATH__YCbCr422_16B_SYNC,	// YCbCr 4:2:2, single edge clock, Y is separate, Cb and Cr multiplexed, 16 bit bus, embedded sync output
+	PATH__YCbCr422_20B_SYNC,	// YCbCr 4:2:2, single edge clock, Y is separate, Cb and Cr multiplexed, 20 bit bus, embedded sync output
+	PATH__YCbCr422_MUX8B,		// YCbCr 4:2:2, single edge at 2x clock, Y multiplexed with Cb and Cr, 8 bit bus
+	PATH__YCbCr422_MUX10B,		// YCbCr 4:2:2, single edge at 2x clock, Y multiplexed with Cb and Cr, 10 bit bus 
+	PATH__YCbCr422_MUX8B_SYNC,	// YCbCr 4:2:2, single edge at 2x clock, Y multiplexed with Cb and Cr, 8 bit bus, embedded sync output
+	PATH__YCbCr422_MUX10B_SYNC,	// YCbCr 4:2:2, single edge at 2x clock, Y multiplexed with Cb and Cr, 10 bit bus , embedded sync output
+	PATH__MAXVALUE,
+} VideoPath_t;
+
+VideoPath_t SiiDrvRxGetOutVideoPath(void);
+
+void SiiDrvRxTimingInfoSet(SiiRxTiming_t *pNewRxTimingInfo);
+ 
+SiiRxTiming_t *SiiDrvRxTimingInfoGet(void);
+
+uint8_t SiiDrvRxGetPixelReplicate(void);
+
+uint8_t SiiDrvRxGetVideoStatus(void);
+	
+uint16_t SiiDrvRxGetPixelFreq(void);
+
+void SiiDrvRxGetSyncInfo(sync_info_type *p_sync_info);
+
+bool_t SiiDrvRxIsSyncDetected(void);
+
+bool_t SiiDrvRxHdmiModeGet(void);
+
+void SiiDrvRxMuteVideo(uint8_t switch_on);
+
+void SiiDrvSoftwareReset(uint8_t reset_mask);
+
+bool_t SiiDrvRxInitialize(void);
+
+void SiiDrvRxVideoPathSet(void);
+#endif // SII_DRV_RX_H
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_cfg.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_cfg.h
new file mode 100755
index 000000000000..028259b6a959
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_cfg.h
@@ -0,0 +1,59 @@
+/******************************************************************************
+*
+* Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+*
+* No part of this work may be reproduced, modified, distributed, transmitted,
+* transcribed, or translated into any language or computer format, in any form
+* or by any means without written permission of: Silicon Image, Inc.,
+* 1140 East Arques Avenue, Sunnyvale, California 94085
+*
+*****************************************************************************/
+/**
+* @file si_rx_cfg.h
+*
+* HDMI Receiver Configuration Manager
+*
+*****************************************************************************/
+
+#ifndef __SI_DRV_RX_CFG_H__
+#define __SI_DRV_RX_CFG_H__
+
+#include "si_common.h"
+
+#define SI_USE_DEBUG_PRINT ENABLE // enable or disable log print (aka DEBUG_PRINT())
+
+#define SI_INVERT_RX_OUT_PIX_CLOCK_BY_DEFAULT DISABLE
+//	RX output clock:
+//	DISABLE C Normal output clock (setup and hold to rising edge)
+//	ENABLE C Invert the output clock (setup and hold to falling edge)
+
+#define SI_ALLOW_PC_MODES ENABLE
+// ENABLE- allows PC resolutions to be used.
+// DISABLE- prohibits resolutions that are not CEA-861 or 3D.
+// If the repeater is designed to use DE (Data Enable) signal
+// at RX and TX, then it is safe to enable this option.
+// If DE line is not provided then it is still possible to use PC resolutions
+// but RP_M__BOARD_OPTIONS1__DIRECT_VIDEO option of RTPI has to be
+// disabled and assistance from the host microcontroller is required
+// to fill RTPI registers 0x80...0x8F.
+
+#define SI_ALLOW_300_MHZ_RESOLUTIONS DISABLE
+// ENABLE- allow 300 MHz resolutions by default configuration.
+// DISABLE- prohibit 300MHz resolutions by default settings.
+// Note: if configuration EEPROM is used,
+// the default frequency limits in EDID may be overwitten.
+
+//range limits to satisfy all 861D video modes
+#define VIDEO__MIN_V_HZ			(22)
+#define VIDEO__MAX_V_HZ			(243)
+#define VIDEO__MIN_H_KHZ			(14)
+#if (SI_ALLOW_300_MHZ_RESOLUTIONS == ENABLE)
+#  define VIDEO__MAX_H_KHZ			(134)
+#  define VIDEO__MAX_PIX_CLK_10MHZ	(30) // to support 300 MHz resolutions
+#else // SI_ALLOW_300_MHZ_RESOLUTIONS
+#  define VIDEO__MAX_H_KHZ			(129)
+#  define VIDEO__MAX_PIX_CLK_10MHZ	(17) // to support more PC modes
+#endif // SI_ALLOW_300_MHZ_RESOLUTIONS
+
+
+#endif // __SI_DRV_RX_CFG_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_info.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_info.c
new file mode 100755
index 000000000000..f431e2a5498a
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_info.c
@@ -0,0 +1,86 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+
+#include "si_rx_info.h"
+#include "si_drv_rx_isr.h"
+#include "si_cra.h"
+
+#include "si_sii5293_registers.h"
+
+
+/*****************************************************************************/
+/**
+ *  @brief		Process One InfoFrame Packet
+ *
+ *  @param[in]		packet_address		packet address
+ *
+ *****************************************************************************/
+static void process_one_packet(uint16_t packet_address)
+{
+	uint8_t d[IF_BUFFER_LENGTH];
+
+	uint8_t packet_title = SiiRegRead(packet_address);
+
+	switch(packet_title)
+	{
+	case SII_IF_AVI:
+		SiiRegReadBlock(packet_address, d, IF_MAX_AVI_LENGTH + IF_HEADER_LENGTH);
+		on_avi_receiving(d);
+		break;
+	case SII_IF_AUDIO:
+		SiiRegReadBlock(packet_address, d, IF_MAX_AUDIO_LENGTH + IF_HEADER_LENGTH);
+		on_aud_receiving(d);
+		break;
+	case SII_IF_SPD:
+		SiiRegReadBlock(packet_address, d, IF_MAX_SPD_LENGTH + IF_HEADER_LENGTH);
+		on_spd_receiving(d);
+		break;
+	case SII_IF_ACP:
+		SiiRegReadBlock(packet_address, d, IF_BUFFER_LENGTH);
+		on_acp_receiving(d);
+		break;
+	case SII_IF_VSIF:
+		SiiRegReadBlock(packet_address, d, IF_BUFFER_LENGTH);
+//		DEBUG_PRINT(MSG_ALWAYS, ("Got VSIF in process_one_packet\n"));
+		on_vsif_receiving(d);
+		break;
+	}
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Handler for InfoFrame Interrupts
+ *
+ *  @param[in]		info_frame_interrupts		InfoFrame Interrupts
+ *
+ *****************************************************************************/
+void RxInfo_InterruptHandler(uint8_t info_type)
+{
+    switch(info_type)
+    {
+        case INFO_AVI:
+            process_one_packet(RX_A__AVI_TYPE);
+            break;
+        case INFO_AUD:
+            process_one_packet(RX_A__AUD_TYPE);
+            break;
+        case INFO_ACP:
+            process_one_packet(RX_A__ACP_BYTE1);
+            break;
+        case INFO_VSI:
+            process_one_packet(RX_A__VSI_TYPE);
+            break;
+        default:
+            break;
+            
+    }
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_info.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_info.h
new file mode 100755
index 000000000000..1ab50f571d6c
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_info.h
@@ -0,0 +1,47 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#ifndef __SI_DRV_RX_INFO_H__
+#define __SI_DRV_RX_INFO_H__
+
+#include "si_common.h"
+
+// muting during HDCP authentication
+//#define RX_OUT_AV_MUTE_M__HDCP_RX				BIT0
+
+// Propagation of incoming AV Mute packet from upstream to downstream
+#define RX_OUT_AV_MUTE_M__INP_AV_MUTE_CAME		BIT1
+
+// mute due to RX chip is not ready
+#define RX_OUT_AV_MUTE_M__RX_IS_NOT_READY		BIT2
+
+// mute because of no AVI packet coming and therefore input color space is unknown
+#define RX_OUT_AV_MUTE_M__NO_AVI				BIT4
+
+// mute due to an HDCP error
+#define RX_OUT_AV_MUTE_M__RX_HDCP_ERROR			BIT7
+
+enum
+{
+    INFO_AVI = 0x00,
+    INFO_SPD,
+    INFO_AUD,
+    INFO_MPEG,
+    INFO_UNREC,
+    INFO_ACP,
+    INFO_VSI, 
+};
+
+
+
+void RxInfo_InterruptHandler(uint8_t info_type);
+
+#endif // __SI_DRV_RX_INFO_H__
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_isr.c b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_isr.c
new file mode 100755
index 000000000000..20e43580a95d
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_isr.c
@@ -0,0 +1,576 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#include "si_common.h"
+#include "si_drv_rx_isr.h"
+#include "si_rx_video_mode_detection.h"
+#include "si_rx_info.h"
+#include "si_rx_audio.h"
+
+#include "si_cra.h"
+
+#include "si_drv_rx.h"
+
+#include "si_sii5293_registers.h"
+
+#define HDCP_FAIL_THRESHOLD_1ST			4
+#define HDCP_FAIL_THRESHOLD_CONTINUED	100
+
+#define NMB_OF_RX_INTERRUPTS	8
+#define INT1	0
+#define INT2	1
+#define INT3	2
+#define INT4	3
+#define INT5	4
+#define INT6	5
+#define INT7	6
+#define INT8	7
+
+typedef struct
+{
+	//bit_fld_t check_hdcp_on_vsync;
+	uint8_t hdcp_fail_cntr;
+	uint8_t shadow_interrupt_mask[NMB_OF_RX_INTERRUPTS];
+    bool_t bVidStableChgEvent;
+    bool_t bScdtState;
+    bool_t bCableChgEvent;
+    bool_t bCableState;
+}
+rx_isr_type;
+
+static rx_isr_type rx_isr = {0};
+
+
+ROM const uint8_t default_interrupt_masks[NMB_OF_RX_INTERRUPTS] =
+{
+	// Interrupt 1
+	//RX_M__INTR1__ACR_HW_CTS_CHANGED |
+	//RX_M__INTR1__ACR_HW_N_CHANGED |
+	//RX_M__INTR1__ACR_PACKET_ERROR |
+	//RX_M__INTR1__ACR_PLL_UNLOCKED |
+	//RX_M__INTR1__AUD_FIFO_ERROR |
+	//RX_M__INTR1__ECC_ERROR |
+	//RX_M__INTR1__AUTH_START |
+	RX_M__INTR1__AUTH_DONE |
+	0,
+
+	// Interrupt 2
+	RX_M__INTR2__HDMI_MODE |
+	RX_M__INTR2__VSYNC |
+	//RX_M__INTR2__SOFTW_INTR |
+	RX_M__INTR2__CLOCK_DETECT | // enabled to clear an AAC exception
+	RX_M__INTR2__SCDT |
+	//RX_M__INTR2__GOT_CTS_PACKET |
+	//RX_M__INTR2__GOT_AUDIO_PKT |
+	RX_M__INTR2__VID_CLK_CHANGED |
+	0,
+
+	// Interrupt 3
+	//RX_M__INTR3__NEW_CP_PACKET | // for Deep Color (called on every packet, not on the packet change)
+	//RX_M__INTR3__CP_SET_MUTE |    // cannot use since continues coming when AVMUTE
+	//RX_M__INTR3__PARITY_ERR |
+    //RX_M__INTR3__NEW_MPEG_PACKET |
+    RX_M__INTR3__NEW_AUD_PACKET |
+	//RX_M__INTR3__NEW_SP_PACKET | 
+	RX_M__INTR3__NEW_AVI_PACKET|
+	0,
+
+	// Interrupt 4
+	RX_M__INTR4__HDCP |
+	//RX_M__INTR4__T4 |
+	RX_M__INTR4__NO_AVI |
+	//RX_M__INTR4__CTS_OVERRUN |
+	//RX_M__INTR4__CTS_UNDERRUN |
+	//RX_M__INTR4__FIFO_OVERUN |
+	//RX_M__INTR4__FIFO_UNDERUN |
+	0,
+
+	// Interrupt 5
+	//RX_M__INTR5__FN_CHANGED |
+	//RX_M__INTR5__AAC_DONE |
+	//RX_M__INTR5__AUDIO_LINK_EROR |
+	//RX_M__INTR5__V_RES_CHANGE |   //There should vid_clk change when resolution change, 
+	//RX_M__INTR5__H_RES_CHANGE |
+	//RX_M__INTR5__POLARITY_CHANGE |
+	//RX_M__INTR5__INTERLACED_CHANGED |
+	RX_M__INTR5__AUDIO_FS_CHANGED |
+	0,
+
+	// Interrupt 6
+	//RX_M__INTR6__DC_ERROR | // this interrupt is enabled to just clear-up the error flag
+	//RX_M__INTR6__AUD_FLAT |
+	// RX_M__INTR6__CHST_READY | // cannot use this interrupt because it is triggered on every CHST receiving even nothing changes
+	//RX_M__INTR6__DSD_MUTE_PATTERN_DETECT |
+ 	RX_M__INTR6__NEW_ACP_PACKET |
+	RX_M__INTR6__CABLE_UNPLUG | // enabled to clear an AAC exception
+	0,
+
+	// Interrupt 7
+	RX_M__INTR7__NO_VSI_PACKET |
+	RX_M__INTR7__NEW_VSI_PACKET |
+	//RX_M__INTR7__POWER_CHANGE |
+	//RX_M__INTR7__CEC_FIFO_FULL |
+	//RX_M__INTR7__VIDEO_CLK_CHANGED |
+	//RX_M__INTR7__PCLK_STOPPED |
+	//RX_M__INTR7__NO_DEEP_COLOR_PKT |
+	//RX_M__INTR7__PCLK_STABLE_CHANGED |
+	0,
+
+	// Interrupt 8
+	RX_M__INTR8__CABLE_IN |
+	0
+};
+
+/*****************************************************************************/
+/**
+ *  @brief		Interrupt Service Routine Initialization
+ *
+ *****************************************************************************/
+void RxIsr_Init(void)
+{
+	rx_isr.hdcp_fail_cntr = 0;
+	//rx_isr.check_hdcp_on_vsync = false;
+	memcpy(rx_isr.shadow_interrupt_mask, default_interrupt_masks, NMB_OF_RX_INTERRUPTS);
+
+	SiiRegWriteBlock(RX_A__INTR1_MASK, &rx_isr.shadow_interrupt_mask[INT1], 4);
+	SiiRegWriteBlock(RX_A__INTR5_MASK, &rx_isr.shadow_interrupt_mask[INT5], 2);
+	SiiRegWriteBlock(RX_A__INTR7_MASK, &rx_isr.shadow_interrupt_mask[INT7], 2);
+}
+
+
+#if 0
+/*****************************************************************************/
+/**
+ *  @brief		Switch HDCP Interrupts Handler
+ *
+ *  @param[in]		switch_on		true to switch on; false to switch off
+ *
+ *****************************************************************************/
+void RxIsr_SwitchRxHdcpInterrupts(bool_t switch_on)
+{
+	if(switch_on)
+	{
+		rx_isr.shadow_interrupt_mask[INT1] |= (RX_M__INTR1__AUTH_START | RX_M__INTR1__AUTH_DONE);
+
+		SiiRegWrite(RX_A__INTR1, RX_M__INTR1__AUTH_START | RX_M__INTR1__AUTH_DONE); // interrupt reset
+	}
+	else
+	{
+		rx_isr.shadow_interrupt_mask[INT1] &= ~RX_M__INTR1__AUTH_START;
+		rx_isr.shadow_interrupt_mask[INT1] |= RX_M__INTR1__AUTH_DONE;
+	}
+	SiiRegWrite(RX_A__INTR1_MASK, rx_isr.shadow_interrupt_mask[INT1]); // set mask
+
+	if(!switch_on) // just in case: reset interrupt if they were set
+	{
+		SiiRegWrite(RX_A__INTR1, RX_M__INTR1__AUTH_START | RX_M__INTR1__AUTH_DONE);
+	}
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Switch No AVI InfoFrame Interrupts Handler
+ *
+ *  @param[in]		switch_on		true to switch on; false to switch off
+ *
+ *****************************************************************************/
+static void switch_NoAVI_interrupt(bool_t switch_on)
+{
+	uint8_t pipe = SiiDrvRxInstanceGet();
+	uint8_t mask4 = rx_isr[pipe].shadow_interrupt_mask[INT4];
+	if(switch_on)
+	{
+		SiiRegWrite(RX_A__INTR4, RX_M__INTR4__NO_AVI); // clear No AVI interrupt if it was raised
+		rx_isr[pipe].shadow_interrupt_mask[INT4] |= RX_M__INTR4_MASK__NO_AVI;
+	}
+	else
+	{
+		rx_isr[pipe].shadow_interrupt_mask[INT4] &= ~RX_M__INTR4_MASK__NO_AVI;
+	}
+	if(mask4 != rx_isr[pipe].shadow_interrupt_mask[INT4])
+		SiiRegWrite(RX_A__INTR4_MASK, rx_isr[pipe].shadow_interrupt_mask[INT4]);
+
+	// If NO AVI interrupt is ON, look for NEW AVI only.
+	// If NO AVI interrupt is OFF, look for ANY AVI.
+	RxIsr_SwitchReceiveInfoFrameOnEveryPacket(INFO_AVI, !switch_on);
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Switch No VSI InfoFrame Interrupts Handler
+ *
+ *  @param[in]		switch_on		true to switch on; false to switch off
+ *
+ *****************************************************************************/
+static void switch_NoVSI_interrupt(bool_t switch_on)
+{
+	uint8_t pipe = SiiDrvRxInstanceGet();
+	uint8_t mask7 = rx_isr[pipe].shadow_interrupt_mask[INT7];
+	if(switch_on)
+	{
+		SiiRegWrite(RX_A__INTR7, RX_M__INTR7__NO_VSI_PACKET); // clear No AVI interrupt if it was raised
+		rx_isr[pipe].shadow_interrupt_mask[INT7] |= RX_M__INTR7_MASK__NO_VSI_PACKET;
+	}
+	else
+	{
+		rx_isr[pipe].shadow_interrupt_mask[INT7] &= ~RX_M__INTR7_MASK__NO_VSI_PACKET;
+	}
+	if(mask7!= rx_isr[pipe].shadow_interrupt_mask[INT7])
+		SiiRegWrite(RX_A__INTR7_MASK, rx_isr[pipe].shadow_interrupt_mask[INT7]);
+
+	// If NO AVI interrupt is ON, look for NEW AVI only.
+	// If NO AVI interrupt is OFF, look for ANY AVI.
+	RxIsr_SwitchReceiveInfoFrameOnEveryPacket(INFO_VSI, !switch_on);
+}
+
+
+/*****************************************************************************/
+/**
+ *  @brief		Switch Receive Audio InfoFrame On Every Packet Interrupts Handler
+ *
+ *  @param[in]		switch_on		true to switch on; false to switch off
+ *
+ *****************************************************************************/
+void RxIsr_SwitchReceiveInfoFrameOnEveryPacket(uint8_t info_type, bool_t switch_on)
+{
+    switch(info_type)
+    {
+        case INFO_AVI:
+            SiiRegBitsSet(RX_A__INT_IF_CTRL, RX_M__INT_IF_CTRL__NEW_AVI, switch_on);
+            SiiRegWrite(RX_A__INTR3, RX_M__INTR3__NEW_AVI_PACKET); // reset the interrupt
+            break;
+        case INFO_AUD:
+            SiiRegBitsSet(RX_A__INT_IF_CTRL, RX_M__INT_IF_CTRL__NEW_AUD, switch_on);
+            SiiRegWrite(RX_A__INTR3, RX_M__INTR3__NEW_AUD_PACKET); // reset the interrupt
+            break;
+        case INFO_ACP:
+            SiiRegBitsSet(RX_A__INT_IF_CTRL, RX_M__INT_IF_CTRL__NEW_ACP, switch_on);
+            SiiRegWrite(RX_A__INTR6, RX_M__INTR6__NEW_ACP_PACKET); // reset the interrupt
+            break;
+        case INFO_VSI:
+            SiiRegBitsSet(RX_A__INT_IF_CTRL, RX_M__INT_IF_CTRL__NEW_VSI, switch_on);
+            SiiRegWrite(RX_A__INTR7, RX_M__INTR7__NEW_VSI_PACKET); // reset the interrupt
+            break;
+        default:
+            break;
+            
+    }
+    
+}
+#endif
+
+/*****************************************************************************/
+/**
+ *  @brief		Interrupt Handler for HDMI / DVI Transition
+ *
+ *****************************************************************************/
+static void RxIsr_HdmiDviTransition(void)
+{
+	if(SiiDrvRxHdmiModeGet())
+	{
+		// Clear BCH counter and the interrupt associated with it.
+		// It'll help avoiding a false HDCP Error interrupt caused by pre-HDMI
+		// counter content.
+		// Capture and clear BCH T4 errors.
+		SiiRegWrite(RX_A__ECC_CTRL, RX_M__ECC_CTRL__CAPTURE_CNT);
+		SiiRegWrite(RX_A__INTR4, RX_M__INTR4__HDCP); // reset the HDCP BCH error interrupt
+
+		DEBUG_PRINT(MSG_STAT, ("RX: HDMI\n"));
+		RxAudio_ReStart();
+	}
+	else
+	{
+		DEBUG_PRINT(MSG_STAT, ("RX: DVI\n"));
+		// forget all HDMI settings
+		RxInfo_ResetData();
+		RxAudio_Stop();
+	}
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Switch HDCP Failure Check with Vertical Sync Rate
+ *
+ *  @param[in]		switch_on		true to switch on; false to switch off
+ *
+ *****************************************************************************/
+static void switch_hdcp_failure_check_with_v_sync_rate(bool_t switch_on)
+{
+	if(switch_on)
+	{
+		rx_isr.hdcp_fail_cntr = 1;
+		//rx_isr.check_hdcp_on_vsync = true; // don't clear HDCP Failure Int if this bit is set
+		rx_isr.shadow_interrupt_mask[INT2] |= RX_M__INTR2__VSYNC;
+		rx_isr.shadow_interrupt_mask[INT4] &= ~RX_M__INTR4__HDCP;
+	}
+	else
+	{
+		rx_isr.hdcp_fail_cntr = 0;
+		//rx_isr.check_hdcp_on_vsync = false;
+		rx_isr.shadow_interrupt_mask[INT2] &= ~RX_M__INTR2__VSYNC;
+		rx_isr.shadow_interrupt_mask[INT4] |= RX_M__INTR4__HDCP;
+	}
+	SiiRegWrite(RX_A__INTR2_MASK, rx_isr.shadow_interrupt_mask[INT2]);
+	SiiRegWrite(RX_A__INTR4_MASK, rx_isr.shadow_interrupt_mask[INT4]);
+
+	// Clear BCH counter.
+	// The counter accomulates BCH errors and  if it is not cleared it can cause an HDCP failure interrupt
+	// Capture and clear BCH T4 errors.
+	SiiRegWrite(RX_A__ECC_CTRL, RX_M__ECC_CTRL__CAPTURE_CNT);
+
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		Handler for HDCP Error
+ *
+ *****************************************************************************/
+static void hdcp_error_handler(bool_t v_sync_mode)
+{
+	if(v_sync_mode)
+	{
+		if(0 == SiiRegReadWord(RX_A__HDCP_ERR))
+		{
+			// Recovered- return to normal checking mode
+			DEBUG_PRINT(MSG_STAT, ( "RX: BCH recovered ***\n"));
+			switch_hdcp_failure_check_with_v_sync_rate(OFF);
+		}
+		else
+		{
+			// Another failure
+			rx_isr.hdcp_fail_cntr++;
+			if(HDCP_FAIL_THRESHOLD_1ST == rx_isr.hdcp_fail_cntr)
+			{
+				DEBUG_PRINT(MSG_STAT, ( "RX: Cont. BCH Error ***\n"));
+
+				// Reset Ri to notify an upstream device about the failure.
+				// In most cases Ri is already mismatched if we see BCH errors,
+				// but there is one rare case when the reseting can help.
+				// It is when Ri and Ri' are matched all the time but Ri and Ri'
+				// switching happens not synchronously causing a snow
+				// screen flashing every 2 seconds. It may happen with
+				// some old incomplaint sources or sinks (especially DVI).
+				SiiRegWrite(RX_A__HDCP_DEBUG, RX_M__HDCP_DEBUG__CLEAR_RI);
+
+				// Clear BCH counter.
+				// The counter accumulates BCH errors and
+				// if it is not cleared it can cause an HDCP failure interrupt.
+				// Capture and clear BCH T4 errors.
+				SiiRegWrite(RX_A__ECC_CTRL, RX_M__ECC_CTRL__CAPTURE_CNT);
+
+
+				// repeat HPD cycle if HDCP is not recovered
+				// in some time
+				rx_isr.hdcp_fail_cntr = HDCP_FAIL_THRESHOLD_1ST - HDCP_FAIL_THRESHOLD_CONTINUED;
+			}
+		}
+	}
+	else
+	{
+		switch_hdcp_failure_check_with_v_sync_rate(ON);
+		DEBUG_PRINT(MSG_STAT, ( "RX: 1st BCH Error ***\n"));
+	}
+}
+
+/*****************************************************************************/
+/**
+ *  @brief		ISR Interrupt Handler
+ *
+ *  @param[in]
+ *
+ *  @return	ISR interrupt service time
+ *  @retval
+ *
+ *****************************************************************************/
+extern void sii5293_output_mode_trigger(unsigned int flag);
+
+void SiiRxInterruptHandler(void)
+{
+	static uint8_t current_scdt = 0;
+
+    uint8_t interrupts[NMB_OF_RX_INTERRUPTS];
+   
+    //DEBUG_PRINT(MSG_STAT, ("RX Interrupt detected!\n"));
+    // get interrupt requests
+    SiiRegReadBlock(RX_A__INTR1, &interrupts[INT1], 4);
+    SiiRegReadBlock(RX_A__INTR5, &interrupts[INT5], 2);
+    SiiRegReadBlock(RX_A__INTR7, &interrupts[INT7], 2);
+
+    // do not touch interrupts which are masked out
+    interrupts[INT1] &= rx_isr.shadow_interrupt_mask[INT1];
+    interrupts[INT2] &= rx_isr.shadow_interrupt_mask[INT2];
+    interrupts[INT3] &= rx_isr.shadow_interrupt_mask[INT3];
+    interrupts[INT4] &= rx_isr.shadow_interrupt_mask[INT4];
+    interrupts[INT5] &= rx_isr.shadow_interrupt_mask[INT5];
+    interrupts[INT6] &= rx_isr.shadow_interrupt_mask[INT6];
+    interrupts[INT7] &= rx_isr.shadow_interrupt_mask[INT7];
+    interrupts[INT8] &= rx_isr.shadow_interrupt_mask[INT8];
+
+    // Cable plug-in / plug-out interrupts are handled elsewhere
+    //interrupts[INT6] &= ~RX_M__INTR6__CABLE_UNPLUG;
+    //interrupts[INT8] &= ~RX_M__INTR8__CABLE_IN;
+
+    // clear interrupt requests
+    SiiRegWriteBlock(RX_A__INTR1, &interrupts[INT1], 4);
+    SiiRegWriteBlock(RX_A__INTR5, &interrupts[INT5], 2);
+    SiiRegWriteBlock(RX_A__INTR7, &interrupts[INT7], 2);
+
+    if(interrupts[INT1] & RX_M__INTR1__AUTH_DONE)
+    {
+        DEBUG_PRINT(MSG_STAT, ("RX: Authentication done!\n"));
+        switch_hdcp_failure_check_with_v_sync_rate(OFF);
+    }
+
+    if(interrupts[INT2] & RX_M__INTR2__VID_CLK_CHANGED)
+    {
+        rx_isr.bVidStableChgEvent = true;
+        DEBUG_PRINT(MSG_STAT, ("RX: video clock change\n"));
+    }
+
+    if(interrupts[INT2] & RX_M__INTR2__SCDT)
+    {
+        switch_hdcp_failure_check_with_v_sync_rate(OFF);
+        SiiDrvRxMuteVideo(ON);
+        rx_isr.bVidStableChgEvent = true;
+        if(SiiDrvRxIsSyncDetected())
+        {
+            rx_isr.bScdtState = true;
+#if defined(__KERNEL__)
+            SiiConnectionStateNotify(true);
+#endif  
+            // SCDT detection for vdin utility.
+	        if( current_scdt == 0 )
+	        {
+	            sii5293_output_mode_trigger(1);
+	            current_scdt = 1;
+	        }
+        }
+        else
+        {
+            rx_isr.bScdtState = false;
+            SiiDrvSoftwareReset(RX_M__SRST__SRST);
+            VMD_ResetTimingData();
+            DEBUG_PRINT(MSG_STAT, ("RX: IDLE!\n"));
+
+            // SCDT detection for vdin utility.
+	        if( current_scdt == 1 )
+	        {
+	            sii5293_output_mode_trigger(0);
+	            current_scdt = 0;
+	        }
+        }
+
+    }
+
+    if(interrupts[INT2] & RX_M__INTR2__HDMI_MODE)
+    {
+        DEBUG_PRINT(MSG_STAT, ("RX: HDMI mode change!\n"));
+        RxIsr_HdmiDviTransition();
+    }
+
+    if(interrupts[INT2] & RX_M__INTR2__VSYNC)
+    {
+        hdcp_error_handler(true);
+    }
+
+    if(interrupts[INT4] & RX_M__INTR4__HDCP)
+    {
+        hdcp_error_handler(false);
+    }
+
+    if((interrupts[INT5] & RX_M__INTR5__AUDIO_FS_CHANGED) || (interrupts[INT6] & RX_M__INTR6__CHST_READY))
+    {
+        // Note: RX_M__INTR6__CHST_READY interrupt may be disabled
+        //DEBUG_PRINT(MSG_STAT, ("RX: New Audio Fs\n"));
+        RxAudio_OnChannelStatusChange();
+    }
+    if(interrupts[INT4] & RX_M__INTR4__NO_AVI)
+    {
+        RxInfo_NoAviHandler();
+        rx_isr.bVidStableChgEvent = true;
+    }
+
+    if(interrupts[INT3] & RX_M__INTR3__NEW_AVI_PACKET)
+    {
+        RxInfo_InterruptHandler(INFO_AVI);
+        rx_isr.bVidStableChgEvent = true;
+    }
+
+    if(interrupts[INT7] & RX_M__INTR7__NO_VSI_PACKET)
+    {
+        // Clear also vsif_received flag (indicating any VSIF packet detection).
+        // If there is any other VSIF packet, the flag will be set again shortly.
+        RxInfo_NoVsiHandler();
+    }
+
+    if(interrupts[INT7] & RX_M__INTR7__NEW_VSI_PACKET)
+    {
+        RxInfo_InterruptHandler(INFO_VSI);
+    }
+
+    if(interrupts[INT3] & RX_M__INTR3__NEW_AUD_PACKET)
+    {
+        RxInfo_InterruptHandler(INFO_AUD);
+    }
+
+    if(interrupts[INT6] & RX_M__INTR6__NEW_ACP_PACKET)
+    {
+        RxInfo_InterruptHandler(INFO_AUD);
+    }
+    if (interrupts[INT6] & RX_M__INTR6__CABLE_UNPLUG)
+    {
+        if (SiiRegRead(RX_A__INTR6) & RX_M__INTR6__CABLE_UNPLUG)
+        {
+            rx_isr.bCableChgEvent = true;
+            rx_isr.bCableState = false;
+            rx_isr.shadow_interrupt_mask[INT6] &= ~RX_M__INTR6__CABLE_UNPLUG;       // Disable 5v plug-out interrup
+            rx_isr.shadow_interrupt_mask[INT8] |= RX_M__INTR8__CABLE_IN;            // Enable 5v plug-in interrupt
+            SiiRegWrite(RX_A__INTR6_MASK, rx_isr.shadow_interrupt_mask[INT6]);
+            SiiRegWrite(RX_A__INTR8_MASK, rx_isr.shadow_interrupt_mask[INT8]);
+            
+        }
+            
+    }
+    if (interrupts[INT8] & RX_M__INTR8__CABLE_IN)
+    {
+        if (SiiRegRead(RX_A__INTR8) & RX_M__INTR8__CABLE_IN)
+        {
+            rx_isr.bCableChgEvent = true;
+            rx_isr.bCableState = true;
+            rx_isr.shadow_interrupt_mask[INT6] |= RX_M__INTR6__CABLE_UNPLUG;        // Enable 5v plug-out interrup
+            rx_isr.shadow_interrupt_mask[INT8] &= ~RX_M__INTR8__CABLE_IN;           // Disable 5v plug-in interrupt
+            SiiRegWrite(RX_A__INTR6_MASK, rx_isr.shadow_interrupt_mask[INT6]);
+            SiiRegWrite(RX_A__INTR8_MASK, rx_isr.shadow_interrupt_mask[INT8]);
+        }
+    }
+}
+
+bool_t SiiDrvCableStatusGet ( bool_t *pData )
+{
+    if (rx_isr.bCableChgEvent)
+    {
+        rx_isr.bCableChgEvent = false;
+        *pData = rx_isr.bCableState;
+        return true;
+    }
+    return false;
+}
+
+bool_t SiiDrvVidStableGet ( bool_t *pData )
+{
+    if (rx_isr.bVidStableChgEvent)
+    {
+        rx_isr.bVidStableChgEvent = false;
+        *pData = rx_isr.bScdtState;
+        return true;
+    }
+    return false;
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_isr.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_isr.h
new file mode 100755
index 000000000000..a31eda0ba2ea
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_drv_rx_isr.h
@@ -0,0 +1,23 @@
+//------------------------------------------------------------------------------
+// Project: HDMI Repeater
+// Copyright (C) 2002-2013, Silicon Image, Inc.  All rights reserved.
+//
+// No part of this work may be reproduced, modified, distributed, transmitted,
+// transcribed, or translated into any language or computer format, in any form
+// or by any means without written permission of: Silicon Image, Inc.,
+// 1140 East Arques Avenue, Sunnyvale, California 94085
+//------------------------------------------------------------------------------
+
+#ifndef SI_DRV_RX_ISR_H
+#define SI_DRV_RX_ISR_H
+
+
+void RxIsr_Init(void);
+
+void SiiRxInterruptHandler(void);
+
+bool_t SiiDrvCableStatusGet ( bool_t *pData );
+
+bool_t SiiDrvVidStableGet ( bool_t *pData );
+
+#endif // SI_DRV_RX_ISR_H
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_sii5293_registers.h b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_sii5293_registers.h
new file mode 100755
index 000000000000..ec3ce529a8a6
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/driver/rx_drv/si_sii5293_registers.h
@@ -0,0 +1,704 @@
+//***************************************************************************
+//!file     si_sii5293_registers.h
+//!brief    5293 Device Register Manifest Constants.
+//
+// No part of this work may be reproduced, modified, distributed,
+// transmitted, transcribed, or translated into any language or computer
+// format, in any form or by any means without written permission of
+// Silicon Image, Inc., 1140 East Arques Avenue, Sunnyvale, California 94085
+//
+// Copyright 2007-2013, Silicon Image, Inc.  All rights reserved.
+//***************************************************************************/
+
+#ifndef __SI_SII5293_REGISTERS_H__
+#define __SI_SII5293_REGISTERS_H__
+
+#include "si_drv_cra_cfg.h"
+#include "si_regs_mhl5293.h"
+
+//------------------------------------------------------------------------------
+// Registers in Page 0  (0xB0/0xB2)
+//------------------------------------------------------------------------------
+
+#define REG_DEV_IDL_RX              (PP_PAGE | 0x02)
+#define REG_DEV_IDH_RX              (PP_PAGE | 0x03)
+#define REG_DEV_REV                 (PP_PAGE | 0x04)
+
+#define RX_A__SRST                  (PP_PAGE | 0x05)
+#define RX_M__SRST__ACR_RST_AUTO		0x40
+#define RX_M__SRST__AAC_RST				0x20
+#define RX_M__SRST__SRST_AUTO			0x10
+#define RX_M__SRST__HDCP_RST			0x08
+#define RX_M__SRST__ACR_RST				0x04
+#define RX_M__SRST__FIFO_RST			0x02
+#define RX_M__SRST__SRST				0x01
+
+#define RX_A__STATE				    (PP_PAGE | 0x06)
+#define RX_M__STATE__PCLK_STABLE		0x10
+#define RX_M__STATE__PWR5V				0x08
+#define RX_M__STATE__VSYNC				0x04
+#define RX_M__STATE__CKDT				0x02
+#define RX_M__STATE__SCDT				0x01
+
+#define RX_A__SWRST2			    (PP_PAGE | 0x07)
+#define RX_M__SWRST2__AUDIO_FIFO_AUTO	0x40
+#define RX_M__SWRST2__CEC_SRST          0x04
+#define RX_M__SWRST2__CBUS_SRST         0x02
+
+#define RX_A__SYS_CTRL1			    (PP_PAGE | 0x08)
+#define RX_M__SYS_CTRL1__OCLKDIV		0xC0
+#define RX_M__SYS_CTRL1__ICLK			0x30
+#define RX_M__SYS_CTRL1__BSEL			0x04
+#define RX_M__SYS_CTRL1__EDGE			0x02
+#define RX_M__SYS_CTRL1__PDALL			0x01
+
+#define RX_A__SYS_SWTCH			    (PP_PAGE | 0x09)
+#define RX_M__SYS_SWTCH__RX0_EN         0x01
+#define RX_M__SYS_SWTCH__DDC0_EN         0x10
+#define RX_M__SYS_SWTCH__DDC_DEL_EN		0x80
+
+#define REG_HP_CTRL                 (PP_PAGE | 0x0B)
+#define VAL_HP_PORT0_MASK               0x03
+#define VAL_HP_PORT_ALL_HI              0x55
+#define VAL_HP_PORT_ALL_LO              0x00
+#define VAL_HP_PORT_MHL                 0x22
+
+#define RX_A__HDCP_DEBUG		0x031
+#define RX_M__HDCP_DEBUG__CLEAR_RI		0x80
+
+#define RX_A__HDCP_STAT			0x032
+#define RX_M__HDCP_STAT__DECRIPTING		0x20
+#define RX_M__HDCP_STAT__AUTHENTICATED	0x10
+
+// Video Registers --------------------------------------------------------------------------------
+
+#define RX_A__H_RESL			0x03A // [7:0]
+#define RX_A__H_RESH			0x03B // [12:8]
+
+#define RX_A__V_RESL			0x03C // [7:0]
+#define RX_A__V_RESH			0x03D // [10:8]
+
+#define RX_A__VID_CTRL			0x048
+#define RX_M__VID_CTRL__INVERT_VSYNC			0x80
+#define RX_M__VID_CTRL__INVERT_HSYNC			0x40
+#define RX_M__VID_CTRL__YCBCR_2_RGB_MODE		0x04
+#define RX_M__VID_CTRL__EXT_BIT_MODE			0x02
+#define RX_M__VID_CTRL__RGB_2_YCBCR_MODE		0x01
+
+#define RX_A__VID_MODE2			0x049
+#define RX_M__VID_MODE2__EVEN_ODD_POL			0x20
+#define RX_M__VID_MODE2__YCBCR_2_RGB_RANGE_EN	0x08
+#define RX_M__VID_MODE2__YCBCR_2_RGB_EN			0x04
+#define RX_M__VID_MODE2__CLIP_INPUTS_YC			0x02
+#define RX_M__VID_MODE2__RANGE_CLIP				0x01
+
+#define RX_A__VID_MODE			0x04A
+#define RX_M__VID_MODE__SYNC_CODES_EN			0x80
+#define RX_M__VID_MODE__MUX_YC					0x40
+#define RX_M__VID_MODE__DITHER					0x20
+#define RX_M__VID_MODE__RGB_2_YCBCR_RANGE		0x10
+#define RX_M__VID_MODE__RGB_2_YCBCR_EN			0x08
+#define RX_M__VID_MODE__UPSMPL					0x04
+#define RX_M__VID_MODE__DOWSMPL					0x02
+
+#define RX_A__VID_BLANK1		0x04B // Blank Data[7:0]
+#define RX_A__VID_BLANK2		0x04C // Blank Data[15:8]
+#define RX_A__VID_BLANK3		0x04D // Blank Data[23:16]
+
+#define RX_A__DE_PIX1			0x04E // Number of pixels per DE; bits [7:0]
+#define RX_A__DE_PIX2			0x04F // Number of pixels per DE; bits [11:8]
+
+#define RX_A__DE_LINE1			0x050 // Number of DE per frame/field; bits [7:0]
+#define RX_A__DE_LINE2			0x051 // Number of pixels per DE[10:8]
+
+#define RX_A__VTAVL				0x052 // Vsync to Active Video Lines
+
+#define RX_A__VID_VFP			0x053 // Video Front Porch
+
+#define RX_A__VID_F2BPM			0x054 // Field to Back Porch
+
+#define RX_A__VID_STAT			0x055
+#define RX_M__VID_STAT__INTERLACE		0x04
+#define RX_M__VID_STAT__VSYNC_POL		0x02
+#define RX_M__VID_STAT__HSYNC_POL		0x01
+
+#define RX_A__VID_CH_MAP		0x056
+#define RX_M__VID_CH_MAP__CHANNEL_MAP	0x07
+
+#define RX_VID_CTRL2			0x057
+#define RX_M__VID_CTRL2__HJITTER_EN		0x01
+
+#define RX_A__VID_HFP			0x059 // Horizontal Front Porch
+
+#define RX_A__VID_HAW1			0x05B // Hsync Active Width; bits [7:0]
+#define RX_A__VID_HAW2			0x05C // Hsync Active Width
+
+#define RX_A__VID_AOF			0x05F
+
+#define RX_A_VIDA_XPCLK_BASE	0x69
+#define RX_A_VIDA_XPCLK_EN		0x6A
+#define RX_M_VIDA_XPCLK_EN__EN			0x01
+
+#define RX_A__VID_XPCNT0		0x06E // # of xclk per 2048 Video clk, low byte
+#define RX_A__VID_XPCNT1		0x06F // # of xclk per 2048 Video clk, high byte
+
+
+// Interrupts Registers ---------------------------------------------------------------------------
+#define RX_A__INTR_STATE		0x070
+#define RX_M__INTR_STATE				0x01
+
+#define RX_A__INTR1				0x071
+#define RX_M__INTR1__ACR_HW_CTS_CHANGED	0x80
+#define RX_M__INTR1__ACR_HW_N_CHANGED	0x40
+#define RX_M__INTR1__ACR_PACKET_ERROR	0x20
+#define RX_M__INTR1__ACR_PLL_UNLOCKED	0x10
+#define RX_M__INTR1__AUTH_START			0x02
+#define RX_M__INTR1__AUTH_DONE			0x01
+
+#define RX_A__INTR2				0x072
+#define RX_M__INTR2__HDMI_MODE			0x80
+#define RX_M__INTR2__VSYNC				0x40
+#define RX_M__INTR2__SOFTW_INTR			0x20
+#define RX_M__INTR2__CLOCK_DETECT		0x10
+#define RX_M__INTR2__SCDT				0x08
+#define RX_M__INTR2__GOT_CTS_PACKET		0x04
+#define RX_M__INTR2__GOT_AUDIO_PKT		0x02
+#define RX_M__INTR2__VID_CLK_CHANGED	0x01
+
+#define RX_A__INTR3				0x073
+#define RX_M__INTR3__NEW_CP_PACKET		0x80
+#define RX_M__INTR3__CP_SET_MUTE		0x40
+#define RX_M__INTR3__PARITY_ERR			0x20
+#define RX_M__INTR3__NEW_UNREC_PACKET	0x10
+#define RX_M__INTR3__NEW_MPEG_PACKET	0x08
+#define RX_M__INTR3__NEW_AUD_PACKET		0x04
+#define RX_M__INTR3__NEW_SP_PACKET		0x02
+#define RX_M__INTR3__NEW_AVI_PACKET		0x01
+
+#define RX_A__INTR4				0x074
+#define RX_M__INTR4__HDCP				0x40
+#define RX_M__INTR4__T4					0x20
+#define RX_M__INTR4__NO_AVI				0x10
+#define RX_M__INTR4__CTS_OVERRUN		0x08
+#define RX_M__INTR4__CTS_UNDERRUN		0x04
+#define RX_M__INTR4__FIFO_OVERUN		0x02
+#define RX_M__INTR4__FIFO_UNDERUN		0x01
+
+#define RX_A__INTR1_MASK		0x075
+
+#define RX_A__INTR2_MASK		0x076
+
+#define RX_A__INTR3_MASK		0x077
+
+#define RX_A__INTR4_MASK		0x078
+
+#define RX_A__INT_CTRL			0x079
+#define RX_M__INT_CTRL__SOFT_INTR				0x08
+#define RX_M__INT_CTRL__OPEN_DRAIN				0x04
+#define RX_M__INT_CTRL__POLARITY				0x02
+
+#define RX_A__INT_IF_CTRL		0x07A
+#define RX_M__INT_IF_CTRL__NEW_VSI				0x40
+#define RX_M__INT_IF_CTRL__NEW_ACP				0x20
+#define RX_M__INT_IF_CTRL__NEW_UNREC			0x10
+#define RX_M__INT_IF_CTRL__NEW_MPEG				0x08
+#define RX_M__INT_IF_CTRL__NEW_AUD				0x04
+#define RX_M__INT_IF_CTRL__NEW_SPD				0x02
+#define RX_M__INT_IF_CTRL__NEW_AVI				0x01
+
+#define RX_A__INTR5				0x07B
+#define RX_M__INTR5__FN_CHANGED					0x80
+#define RX_M__INTR5__AAC_DONE					0x40
+#define RX_M__INTR5__AUDIO_LINK_EROR			0x20
+#define RX_M__INTR5__V_RES_CHANGE				0x10
+#define RX_M__INTR5__H_RES_CHANGE				0x08
+#define RX_M__INTR5__POLARITY_CHANGE			0x04
+#define RX_M__INTR5__INTERLACED_CHANGED			0x02
+#define RX_M__INTR5__AUDIO_FS_CHANGED			0x01
+
+#define RX_A__INTR6				0x07C
+#define RX_M__INTR6__DC_ERROR					0x80
+#define RX_M__INTR6__AUD_FLAT					0x40
+#define RX_M__INTR6__CHST_READY					0x20
+#define RX_M__INTR6__NEW_ACP_PACKET				0x04
+#define RX_M__INTR6__CABLE_UNPLUG				0x01
+
+#define RX_A__INTR5_MASK		0x07D
+
+#define RX_A__INTR6_MASK		0x07E
+
+// ACR Registers ---part1--------------------------------------------------------------------------
+#define RX_A__APLL_POLE			0x088 // the rest of settings starts from 0x200 address
+#define RX_A__APLL_CLIP			0x089 // the rest of settings starts from 0x200 address
+
+// Interrupts Registers (continued) ---------------------------------------------------------------
+
+#define RX_A__INTR7				0x090
+#define RX_M__INTR7__NO_VSI_PACKET				0x80
+#define RX_M__INTR7__NEW_VSI_PACKET				0x40
+#define RX_M__INTR7__PCLK_STOPPED				0x04
+#define RX_M__INTR7__PCLK_STABLE_CHANGED		0x01
+
+#define RX_A__INTR8				0x091
+#define RX_M__INTR8__CABLE_IN					0x02
+
+#define RX_A__INTR7_MASK		0x092
+
+#define RX_A__INTR8_MASK		0x093
+
+
+#define REG_INTR_STATE_2    		    (PP_PAGE | 0x94)
+#define BIT_CEC_INTR                        BIT0
+#define BIT_CBUS_INTR                       BIT1
+#define BIT_RX_INTR                         BIT2
+
+
+// Auto Exception Control -------------------------------------------------------------------------
+#define RX_A__AEC_CTRL			0x0B5
+#define RX_M__AEC_CTRL__AAC_OUT_OFF_EN			0x20
+#define RX_M__AEC_CTRL__AVC_EN					0x04
+#define RX_M__AEC_CTRL__AAC_EN					0x01
+
+#define RX_A__AEC_EN1			0x0B6
+#define RX_M__AEC_EN1__CABLE_UNPLUG				0x01
+#define RX_M__AEC_EN1__PLL_UNLOCKED				0x02
+#define RX_M__AEC_EN1__ACR_N_CHANGED			0x04
+#define RX_M__AEC_EN1__ACR_CTS_CHANGED			0x08
+#define RX_M__AEC_EN1__VIDEO_CLOCK_CHANGED		0x10
+#define RX_M__AEC_EN1__INFOFRAME_CP_MUTE_SET	0x20
+#define RX_M__AEC_EN1__SYNC_DETECT				0x40
+#define RX_M__AEC_EN1__CLOCK_DETECT				0x80
+
+#define RX_A__AEC_EN2			0x0B7
+#define RX_M__AEC_EN2__HDMI_MODE				0x01
+#define RX_M__AEC_EN2__AUDIO_FIFO_UNDERUN		0x02
+#define RX_M__AEC_EN2__AUDIO_FIFO_OVERUN		0x04
+#define RX_M__AEC_EN2__CTS_REUSED				0x08
+#define RX_M__AEC_EN2__CHANGE_OF_THE_FS			0x10
+#define RX_M__AEC_EN2__CHANGE_OF_INTERLACED		0x20
+#define RX_M__AEC_EN2__POLARITY_CHANGE			0x40
+#define RX_M__AEC_EN2__H_RESOLUTION_CHANGE		0x80
+
+#define RX_A__AEC_EN3			0x0B8
+#define RX_M__AEC_EN3__V_RESOLUTION_CHANGED		0x01
+#define RX_M__AEC_EN3__LINK_ERROR				0x02
+#define RX_M__AEC_EN3__FN_CLK_CHANGED			0x04
+
+#define RX_A__AVC_EN1			0x0B9
+#define RX_M__AVC_EN1__RGB2YCbCr_CFG			0x01
+#define RX_M__AVC_EN1__RGB2YCbCr_MODE			0x02
+#define RX_M__AVC_EN1__RGB2YCbCr_RANGE			0x04
+#define RX_M__AVC_EN1__YCbCr2RGB_CFG			0x08
+#define RX_M__AVC_EN1__YCbCr2RGB_MODE			0x10
+#define RX_M__AVC_EN1__YCbCr2RGB_RANGE			0x20
+#define RX_M__AVC_EN1__UP_SAMPLER_CFG			0x40
+#define RX_M__AVC_EN1__DOWN_SAMPLER_CFG			0x80
+
+#define RX_A__AVC_EN2			0x0BA
+#define RX_M__AVC_EN2__EXT_BIT					0x01
+#define RX_M__AVC_EN2__DITHER					0x02
+#define RX_M__AVC_EN2__YC_MUX					0x04
+#define RX_M__AVC_EN2__SYNC_CODES				0x08
+#define RX_M__AVC_EN2__BLANK_DATA				0x10
+#define RX_M__AVC_EN2__PIXEL_REPLICATION		0x20
+#define RX_M__AVC_EN2__ODCK_DIV					0x40
+// ECC Registers ----------------------------------------------------------------------------------
+#define RX_A__ECC_CTRL			0x0BB
+#define RX_M__ECC_CTRL__CAPTURE_CNT		0x01
+
+#define RX_A__BCH_THRES			0x0BC
+
+#define RX_A__T4_THRES			0x0BD
+#define RX_M__T4_THRES					0x7F
+
+#define RX_A__T4_UNC_THRES		0x0BE
+#define RX_M__T4_UNC_THRES				0x7F
+
+#define RX_A__ECC0_HDCP_THRES	0x0C5 // bits 0...7
+#define RX_A__ECC0_HDCP_THRES2	0x0C6 // bits 8...15
+#define RX_C__ECC0_HDCP_THRES_VALUE		0x0B40 // recommended value
+
+#define	RX_A__HDCP_ERR			0x0CD
+
+//------------------------------------------------------------------------------
+// Registers in Page 1      (0xD0)
+//------------------------------------------------------------------------------
+
+#define GPIO_MODE					(PP_PAGE_1 | 0x06)
+#define VAL_GPIO_0_3D_INDICATOR                  0x01
+
+#define REG_COMB_CTRL               (PP_PAGE_1 | 0x0B)
+#define REG_DPLL_CFG3               (PP_PAGE_1 | 0x13)
+#define REG_PEQ_VAL0                (PP_PAGE_1 | 0x17)
+
+#define REG_RX_CTRL1                (PP_PAGE_1 | 0x6C)
+
+#define REG_RX_CTRL5                (PP_PAGE_1 | 0x70)
+#define VAL_TERM_ON                     0x00
+#define VAL_TERM_MHL                    0x01
+#define VAL_TERM_SURGE                  0x02
+#define VAL_TERM_OFF                    0x03
+#define MSK_TERM                        (0x03 | 0x80)
+
+#define REG_DPLL_BW_CFG2            (PP_PAGE_1 | 0x8A)
+
+#define RX_CBUS_CH_RST_CTRL           	(PP_PAGE_1 | 0xE5)
+#define BIT_TRI_STATE_EN                    BIT7
+
+#define REG_CBUS_HPD_OEN_CTRL		(PP_PAGE_1 | 0xEA)  // used for ES_0_0 ONLY
+#define REG_CBUS_HPD_PE_CTRL		(PP_PAGE_1 | 0xEB)  // used for ES_0_0 ONLY
+#define REG_CBUS_HPD_PU_CTRL		(PP_PAGE_1 | 0xEC)  // used for ES_0_0 ONLY
+#define REG_CBUS_HPD_OVRT_CTRL	(PP_PAGE_1 | 0xED)  // used for ES_0_0 ONLY
+
+// ACR Registers ---part2--------------------------------------------------------------------------
+#define RX_A__ACR_CTRL1			0x200
+#define RX_M__ACR_CTRL1__CTS_DROP_AUTO	0x80
+#define RX_M__ACR_CTRL1__POST_SEL		0x40
+#define RX_M__ACR_CTRL1__UPLL_SEL		0x20
+#define RX_M__ACR_CTRL1__CTS_SEL		0x10
+#define RX_M__ACR_CTRL1__N_SEL			0x08
+#define RX_M__ACR_CTRL1__CTS_REUSE_AUTO	0x04
+#define RX_M__ACR_CTRL1__FS_SEL			0x02
+#define RX_M__ACR_CTRL1__ACR_INIT		0x01
+
+#define RX_A__FREQ_SVAL			0x202
+#define RX_M__FREQ_SVAL__SW_MASTER_CLK_IN_FREQ	0xC0
+#define RX_M__FREQ_SVAL__SW_MASTER_CLK_OUT_FREQ	0x30
+#define RX_M__FREQ_SVAL__SW_AUDIO_SAMPLING_FREQ	0x0F
+
+#define RX_A__N_SVAL1			0x203 // [7:0]
+#define RX_A__N_SVAL2			0x204 // [15:8]
+#define RX_A__N_SVAL3			0x205 // [19:16]
+
+#define RX_A__N_HVAL1			0x206 // [7:0]
+#define RX_A__N_HVAL2			0x207 // [15:8]
+#define RX_A__N_HVAL3			0x208 // [19:16]
+
+#define RX_A__CTS_SVAL1			0x209 // [7:0]
+#define RX_A__CTS_SVAL2			0x20A // [15:8]
+#define RX_A__CTS_SVAL3			0x20B // [19:16]
+
+#define RX_A__CTS_HVAL1			0x20C // [7:0]
+#define RX_A__CTS_HVAL2			0x20D // [15:8]
+#define RX_A__CTS_HVAL3			0x20E // [19:16]
+
+#define RX_A__UPLL_SVAL			0x20F // [6:0]
+#define RX_A__UPLL_HVAL			0x210 // [6:0]
+
+#define RX_A__POST_SVAL			0x211 // [5:0]
+#define RX_A__POST_HVAL			0x212 // [5:0]
+
+#define RX_A__LK_WIN_SVAL		0x213
+#define RX_M__LK_WIN_SVAL__WINDOW_DIVIDER	0x1E
+#define RX_M__LK_WIN_SVAL__EXACT			0x01
+
+#define RX_A__LK_THRS_SVAL1		0x214 // PLL Locked Stability Threshold[7:0]
+#define RX_A__LK_THRS_SVAL2		0x215 // PLL Locked Stability Threshold[15:8]
+#define RX_A__LK_THRS_SVAL3		0x216 // PLL Locked Stability Threshold[19:16]
+
+#define RX_A__PCLK_FS			0x217
+#define RX_M__PCLK_FS__FS_FILTER			0x10
+#define RX_M__PCLK_FS__SPDIF_EXTRACRTED_FS	0x0F
+
+#define RX_A__ACR_CTRL3			0x218
+#define RX_M__ACR_CTRL3__CTS_THRESHOLD	0x78
+#define RX_M__ACR_CTRL3__MCLK_LOOPBACK	0x04
+#define RX_M__ACR_CTRL3__LOG_WIN_EN		0x02
+#define RX_M__ACR_CTRL3__POST_DIV2_EN	0x01
+
+// Audio Out Registers ----------------------------------------------------------------------------
+
+#define RX_A__TDM_CTRL1			0x223
+#define RX_M__TDM_CTRL1__TDM_EN			0x01
+
+#define RX_A__TDM_CTRL2			0x224
+
+#define RX_A__I2S_CTRL1			0x226
+#define RX_M__I2S_CTRL1__INVALID_EN		0x80
+#define RX_M__I2S_CTRL1__EDGE			0x40
+#define RX_M__I2S_CTRL1__SIZE			0x20
+#define RX_M__I2S_CTRL1__MSB			0x10
+#define RX_M__I2S_CTRL1__WS				0x08
+#define RX_M__I2S_CTRL1__JUSTIFY		0x04
+#define RX_M__I2S_CTRL1__DATA_DIR		0x02
+#define RX_M__I2S_CTRL1__1ST_BIT		0x01
+
+#define RX_A__I2S_CTRL2			0x227
+#define RX_M__I2S_CTRL2__SD3_EN			0x80
+#define RX_M__I2S_CTRL2__SD2_EN			0x40
+#define RX_M__I2S_CTRL2__SD1_EN			0x20
+#define RX_M__I2S_CTRL2__SD0_EN			0x10
+#define RX_M__I2S_CTRL2__MCLK_EN		0x08
+#define RX_M__I2S_CTRL2__MUTE_FLAT		0x04
+#define RX_M__I2S_CTRL2__PCM			0x01
+
+#define RX_A__I2S_MAP			0x228
+#define RX_M__I2S_MAP__SD3_MAP			0xC0
+#define RX_M__I2S_MAP__SD2_MAP			0x30
+#define RX_M__I2S_MAP__SD1_MAP			0x0C
+#define RX_M__I2S_MAP__SD0_MAP			0x03
+
+#define RX_A__AUDRX_CTRL		0x229
+#define RX_M__AUDRX_CTRL__I2S_LENGTH_OVERWRITE	0x80
+#define RX_M__AUDRX_CTRL__HW_MUTE_EN			0x20
+#define RX_M__AUDRX_CTRL__PASS_SPDIF_ERR		0x10
+#define RX_M__AUDRX_CTRL__PASS_AUDIO_ERR		0x08
+#define RX_M__AUDRX_CTRL__I2S_MODE				0x04
+#define RX_M__AUDRX_CTRL__SPDIF_MODE			0x02
+#define RX_M__AUDRX_CTRL__SPDIF_EN				0x01
+
+#define RX_A__CHST1				0x22A
+#define RX_A__CHST2				0x22B
+#define RX_A__CHST3				0x22C
+
+#define RX_A__SW_OW				0x22E
+#define RX_M__SW_OW__SWAP_CH3			0x80
+#define RX_M__SW_OW__SWAP_CH2			0x40
+#define RX_M__SW_OW__SWAP_CH1			0x20
+#define RX_M__SW_OW__SWAP_CH0			0x10
+#define RX_M__SW_OW__OW_BIT2			0x04
+#define RX_M__SW_OW__OW_EN				0x01
+
+#define RX_A__OW_15_8			0x22F // overwrite for bits 15-8
+
+#define RX_A__CHST4				0x230
+#define RX_M__CHST4__AUD_ACCURACY		0x30
+#define RX_M__CHST4__AUD_SAMPLE_F		0x0F
+
+#define RX_A__CHST5				0x231
+#define RX_M__CHST5__AUD_LENGTH			0x0E
+#define RX_M__CHST5__AUD_LENGTH_MAX		0x01
+
+#define RX_A__AUDO_MUTE			0x232
+#define RX_M__AUDO_MUTE__REG_I2S_LENGTH	0xF0 // overwrite for bits 32-35
+#define RX_M__AUDO_MUTE__CH3_MUTE		0x08
+#define RX_M__AUDO_MUTE__CH2_MUTE		0x04
+#define RX_M__AUDO_MUTE__CH1_MUTE		0x02
+#define RX_M__AUDO_MUTE__CH0_MUTE		0x01
+
+
+// Audio Path Registers ---------------------------------------------------------------------------
+#define RX_A__AUDP_STAT			0x234
+#define RX_M__AUDP_STAT__LAYOUT				0x08 // 1 bit
+#define RX_M__AUDP_STAT__MUTE_STATUS		0x04
+#define RX_M__AUDP_STAT__HDMI_MODE_ENABLED	0x02
+#define RX_M__AUDP_STAT__HDMI_MODE_DETECTED	0x01
+
+#define RX_A__CRIT1				0x235
+
+#define RX_A__AUDP_MUTE			0x237
+#define RX_M__AUDP_MUTE__MUTE_OUT_POLARITY	0x04
+#define RX_M__AUDP_MUTE__AUDIO_MUTE			0x02
+#define RX_M__AUDP_MUTE__VIDEO_MUTE			0x01
+
+// FIFO read write ptr difference
+#define RX_A__AUDP_FIFO			0x239
+#define RX_M__AUDP_FIFO					0x7F
+
+// System Power Down Registers --------------------------------------------------------------------
+#define RX_A__PD_TOT			0x23C
+#define RX_M__PD_TOT					0x01
+
+#define RX_A__PD_SYS2			0x23E
+#define RX_M__PD_SYS2__PD_PCLK			0x80
+#define RX_M__PD_SYS2__PD_MCLK			0x40
+#define RX_M__PD_SYS2__PD_Q				0x04
+#define RX_M__PD_SYS2__PD_VHDE			0x02
+#define RX_M__PD_SYS2__PD_ODCK			0x01
+
+#define RX_A__PD_SYS			0x23F
+#define RX_M__PD_SYS__PD_AO				0x80
+#define RX_M__PD_SYS__PD_VO				0x40
+#define RX_M__PD_SYS__PD_APLL			0x20
+#define RX_M__PD_SYS__PD_12CH			0x08
+#define RX_M__PD_SYS__PD_FULL			0x04
+#define RX_M__PD_SYS__PDOSC				0x02
+#define RX_M__PD_SYS__PD_XTAL			0x01
+
+// AVI InfoFrame ----------------------------------------------------------------------------------
+#define RX_A__AVI_TYPE			0x240
+#define RX_A__AVI_VERS			0x241
+#define RX_A__AVI_LENGTH		0x242
+#define RX_A__AVI_CHSUM			0x243
+#define RX_A__AVI_DBYTE1		0x244
+#define RX_A__AVI_DBYTE2		0x245
+#define RX_A__AVI_DBYTE3		0x246
+#define RX_A__AVI_DBYTE4		0x247
+#define RX_A__AVI_DBYTE5		0x248
+#define RX_A__AVI_DBYTE6		0x249
+#define RX_A__AVI_DBYTE7		0x24A
+#define RX_A__AVI_DBYTE8		0x24B
+#define RX_A__AVI_DBYTE9		0x24C
+#define RX_A__AVI_DBYTE10		0x24D
+#define RX_A__AVI_DBYTE11		0x24E
+#define RX_A__AVI_DBYTE12		0x24F
+#define RX_A__AVI_DBYTE13		0x250
+#define RX_A__AVI_DBYTE14		0x251
+#define RX_A__AVI_DBYTE15		0x252
+
+// Source Product Desription (SPD) Info Frame -----------------------------------------------------
+#define RX_A__SPD_TYPE			0x260
+#define RX_A__SPD_VERS			0x261
+#define RX_A__SPD_LENGTH		0x262
+#define RX_A__SPD_CHSUM			0x263
+#define RX_A__SPD_DBYTE1		0x264
+#define RX_A__SPD_DBYTE2		0x265
+#define RX_A__SPD_DBYTE3		0x266
+#define RX_A__SPD_DBYTE4		0x267
+#define RX_A__SPD_DBYTE5		0x268
+#define RX_A__SPD_DBYTE6		0x269
+#define RX_A__SPD_DBYTE7		0x26A
+#define RX_A__SPD_DBYTE8		0x26B
+#define RX_A__SPD_DBYTE9		0x26C
+#define RX_A__SPD_DBYTE10		0x26D
+#define RX_A__SPD_DBYTE11		0x26E
+#define RX_A__SPD_DBYTE12		0x26F
+#define RX_A__SPD_DBYTE13		0x270
+#define RX_A__SPD_DBYTE14		0x271
+#define RX_A__SPD_DBYTE15		0x272
+#define RX_A__SPD_DBYTE16		0x273
+#define RX_A__SPD_DBYTE17		0x274
+#define RX_A__SPD_DBYTE18		0x275
+#define RX_A__SPD_DBYTE19		0x276
+#define RX_A__SPD_DBYTE20		0x277
+#define RX_A__SPD_DBYTE21		0x278
+#define RX_A__SPD_DBYTE22		0x279
+#define RX_A__SPD_DBYTE23		0x27A
+#define RX_A__SPD_DBYTE24		0x27B
+#define RX_A__SPD_DBYTE25		0x27C
+#define RX_A__SPD_DBYTE26		0x27D
+#define RX_A__SPD_DBYTE27		0x27E
+
+// SPD Packet decode address
+#define RX_A__SPD_DEC			0x27F
+
+// Audio (AUD) InfoFrame --------------------------------------------------------------------------
+#define RX_A__AUD_TYPE			0x280
+#define RX_A__AUD_VERS			0x281
+#define RX_A__AUD_LENGTH		0x282
+#define RX_A__AUD_CHSUM			0x283
+#define RX_A__AUD_DBYTE1		0x284
+#define RX_A__AUD_DBYTE2		0x285
+#define RX_A__AUD_DBYTE3		0x286
+#define RX_A__AUD_DBYTE4		0x287
+#define RX_A__AUD_DBYTE5		0x288
+#define RX_A__AUD_DBYTE6		0x289
+#define RX_A__AUD_DBYTE7		0x28A
+#define RX_A__AUD_DBYTE8		0x28B
+#define RX_A__AUD_DBYTE9		0x28C
+#define RX_A__AUD_DBYTE10		0x28D
+
+// MPEG InfoFrame ---------------------------------------------------------------------------------
+#define RX_A__MPEG_TYPE			0x2A0
+#define RX_A__MPEG_VERS			0x2A1
+#define RX_A__MPEG_LENGTH		0x2A2
+#define RX_A__MPEG_CHSUM		0x2A3
+#define RX_A__MPEG_DBYTE1		0x2A4
+#define RX_A__MPEG_DBYTE2		0x2A5
+#define RX_A__MPEG_DBYTE3		0x2A6
+#define RX_A__MPEG_DBYTE4		0x2A7
+#define RX_A__MPEG_DBYTE5		0x2A8
+#define RX_A__MPEG_DBYTE6		0x2A9
+#define RX_A__MPEG_DBYTE7		0x2AA
+#define RX_A__MPEG_DBYTE8		0x2AB
+#define RX_A__MPEG_DBYTE9		0x2AC
+#define RX_A__MPEG_DBYTE10		0x2AD
+#define RX_A__MPEG_DBYTE11		0x2AE
+#define RX_A__MPEG_DBYTE12		0x2AF
+#define RX_A__MPEG_DBYTE13		0x2B0
+#define RX_A__MPEG_DBYTE14		0x2B1
+#define RX_A__MPEG_DBYTE15		0x2B2
+#define RX_A__MPEG_DBYTE16		0x2B3
+#define RX_A__MPEG_DBYTE17		0x2B4
+#define RX_A__MPEG_DBYTE18		0x2B5
+#define RX_A__MPEG_DBYTE19		0x2B6
+#define RX_A__MPEG_DBYTE20		0x2B7
+#define RX_A__MPEG_DBYTE21		0x2B8
+#define RX_A__MPEG_DBYTE22		0x2B9
+#define RX_A__MPEG_DBYTE23		0x2BA
+#define RX_A__MPEG_DBYTE24		0x2BB
+#define RX_A__MPEG_DBYTE25		0x2BC
+#define RX_A__MPEG_DBYTE26		0x2BD
+#define RX_A__MPEG_DBYTE27		0x2BE
+
+// MPEG Packet decode address
+#define RX_A__MPEG_DEC			0x2BF
+
+// Unrecognized Packet ----------------------------------------------------------------------------
+#define RX_A__UNREC_BYTE1		0x2C0
+#define RX_A__UNREC_BYTE2		0x2C1
+#define RX_A__UNREC_BYTE3		0x2C2
+#define RX_A__UNREC_BYTE4		0x2C3
+#define RX_A__UNREC_BYTE5		0x2C4
+#define RX_A__UNREC_BYTE6		0x2C5
+#define RX_A__UNREC_BYTE7		0x2C6
+#define RX_A__UNREC_BYTE8		0x2C7
+#define RX_A__UNREC_BYTE9		0x2C8
+#define RX_A__UNREC_BYTE10		0x2C9
+#define RX_A__UNREC_BYTE11		0x2CA
+#define RX_A__UNREC_BYTE12		0x2CB
+#define RX_A__UNREC_BYTE13		0x2CC
+#define RX_A__UNREC_BYTE14		0x2CD
+#define RX_A__UNREC_BYTE15		0x2CE
+#define RX_A__UNREC_BYTE16		0x2CF
+#define RX_A__UNREC_BYTE17		0x2D0
+#define RX_A__UNREC_BYTE18		0x2D1
+#define RX_A__UNREC_BYTE19		0x2D2
+#define RX_A__UNREC_BYTE20		0x2D3
+#define RX_A__UNREC_BYTE21		0x2D4
+#define RX_A__UNREC_BYTE22		0x2D5
+#define RX_A__UNREC_BYTE23		0x2D6
+#define RX_A__UNREC_BYTE24		0x2D7
+#define RX_A__UNREC_BYTE25		0x2D8
+#define RX_A__UNREC_BYTE26		0x2D9
+#define RX_A__UNREC_BYTE27		0x2DA
+#define RX_A__UNREC_BYTE28		0x2DB
+#define RX_A__UNREC_BYTE29		0x2DC
+#define RX_A__UNREC_BYTE30		0x2DD
+#define RX_A__UNREC_BYTE31		0x2DE
+
+// ACP Packet -------------------------------------------------------------------------------------
+#define RX_A__ACP_BYTE1			0x2E0
+#define RX_A__ACP_BYTE2			0x2E1
+#define RX_A__ACP_BYTE3			0x2E2
+#define RX_A__ACP_BYTE4			0x2E3
+#define RX_A__ACP_BYTE5			0x2E4
+#define RX_A__ACP_BYTE6			0x2E5
+#define RX_A__ACP_BYTE7			0x2E6
+#define RX_A__ACP_BYTE8			0x2E7
+#define RX_A__ACP_BYTE9			0x2E8
+#define RX_A__ACP_BYTE10		0x2E9
+#define RX_A__ACP_BYTE11		0x2EA
+#define RX_A__ACP_BYTE12		0x2EB
+#define RX_A__ACP_BYTE13		0x2EC
+#define RX_A__ACP_BYTE14		0x2ED
+#define RX_A__ACP_BYTE15		0x2EE
+#define RX_A__ACP_BYTE16		0x2EF
+#define RX_A__ACP_BYTE17		0x2F0
+#define RX_A__ACP_BYTE18		0x2F1
+#define RX_A__ACP_BYTE19		0x2F2
+#define RX_A__ACP_BYTE20		0x2F3
+#define RX_A__ACP_BYTE21		0x2F4
+#define RX_A__ACP_BYTE22		0x2F5
+#define RX_A__ACP_BYTE23		0x2F6
+#define RX_A__ACP_BYTE24		0x2F7
+#define RX_A__ACP_BYTE25		0x2F8
+#define RX_A__ACP_BYTE26		0x2F9
+#define RX_A__ACP_BYTE27		0x2FA
+#define RX_A__ACP_BYTE28		0x2FB
+#define RX_A__ACP_BYTE29		0x2FC
+#define RX_A__ACP_BYTE30		0x2FD
+#define RX_A__ACP_BYTE31		0x2FE
+
+// ACP Packet decode address
+#define RX_A__ACP_DEC	 		0x2FF
+
+//VSI InfoFrame ----------------------------------------------------------------------------------
+#define RX_A__VSI_CTRL1			0x930
+#define RX_A__VSI_TYPE			0x950
+#define RX_A__VSI_VERS			0x951
+#define RX_A__VSI_LENGTH		0x952
+#define RX_A__VSI_CHSUM			0x953
+#define RX_A__VSI_DBYTE1		0x954
+
+#endif  // __SI_SII5293_REGISTERS_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Kconfig b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Kconfig
new file mode 100755
index 000000000000..75766581b749
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Kconfig
@@ -0,0 +1,36 @@
+#
+#Hdmirx SiI9293 Device Driver Configuration
+#
+
+menuconfig AML_SII9293
+	bool "Amlogic SII9293 device driver" 
+    default  n
+    help
+         Amlogic SII9293 device driver.
+
+if AML_SII9293
+
+config MHAWB_SUPPORT
+	bool
+	prompt "MHL Media Data Tunneling Support"
+	default n
+	---help---
+	  This option controls whether or not Silicon Image MHL transmitter
+	  drivers include support for Media Data Tunneling (MDT).  MDT
+	  support enables HID events generated by HID devices attached to
+	  an MDT capable MHL sink to be passed over the MHL connection
+	  to the system.
+
+config DEBUG_DRIVER
+	bool
+	prompt "Enable debug messages in kernel"
+	default n
+
+config SII5293_RX
+	bool 
+	prompt "Silicon Image 9293 HDMI to MHL Rx"	
+	depends on I2C
+	default y
+
+endif
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Makefile b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Makefile
new file mode 100755
index 000000000000..d72b638a52da
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Makefile
@@ -0,0 +1,83 @@
+#
+# Makefile for the Silicon Image 835x MHL TX device driver
+#
+
+#TARGET = RGB
+
+
+DRIVER_NAME := sii5293drv
+
+
+ccflags-y := -I$(src)/include
+ccflags-y += -I$(src)/platform/hal
+
+ccflags-y += -I$(src)/../application
+#ccflags-y += -I$(src)/../application/app_cec
+#ccflags-y += -I$(src)/../component/
+ccflags-y += -I$(src)/../component/cbus
+#ccflags-y += -I$(src)/../component/cec_manager
+ccflags-y += -I$(src)/../component/edid
+ccflags-y += -I$(src)/../component/rx
+ccflags-y += -I$(src)/../component/video_tables
+#ccflags-y += -I$(src)/../driver
+ccflags-y += -I$(src)/../driver/board_drv
+ccflags-y += -I$(src)/../driver/cbus_drv
+#ccflags-y += -I$(src)/../driver/cpi_drv
+ccflags-y += -I$(src)/../driver/cra_drv
+ccflags-y += -I$(src)/../driver/rx_drv
+ccflags-y += -I$(src)/application
+
+ifneq ($(CONFIG_MHAWB_SUPPORT),)
+ccflags-y += -I$(src)/../driver/mhawb_drv
+ccflags-y += -DMHAWB_SUPPORT
+endif
+ccflags-y += -DMAKE_5293_DRIVER
+
+ccflags-$(CONFIG_DEBUG_DRIVER) += -DDEBUG
+
+ccflags-$(CONFIG_CEC_DRIVER) += -DINC_CEC
+
+obj-$(CONFIG_SII5293_RX) += $(DRIVER_NAME).o
+
+#----------------- App layer --------------------------------------
+$(DRIVER_NAME)-objs  += application/mhl_linuxdrv_main.o
+$(DRIVER_NAME)-objs  += application/sii5293_interface.o
+$(DRIVER_NAME)-objs  += application/vdin_interface.o
+$(DRIVER_NAME)-objs  += ../application/sk_app_cbus.o
+#$(DRIVER_NAME)-objs  += ../application/app_cec/sk_app_cec.o
+#----------------- Component layer --------------------------------
+$(DRIVER_NAME)-objs  += ../component/cbus/si_cbus_component.o
+#$(DRIVER_NAME)-objs  += ../component/cec_manager/si_cec_component.o
+#$(DRIVER_NAME)-objs  += ../component/cec_manager/si_cec_controller.o
+#$(DRIVER_NAME)-objs  += ../component/cec_manager/si_cec_rx.o
+#$(DRIVER_NAME)-objs  += ../component/cec_manager/si_cec_timer.o
+#$(DRIVER_NAME)-objs  += ../component/cec_manager/si_cec_tx.o
+$(DRIVER_NAME)-objs  += ../component/rx/si_rx_audio.o
+$(DRIVER_NAME)-objs  += ../component/rx/si_rx_info.o
+$(DRIVER_NAME)-objs  += ../component/rx/si_rx_video_mode_detection.o
+$(DRIVER_NAME)-objs  += ../component/video_tables/si_video_tables.o
+#----------------- Driver layer --------------------------------
+$(DRIVER_NAME)-objs  += ../driver/board_drv/si_drv_board.o
+$(DRIVER_NAME)-objs  += ../driver/board_drv/si_drv_evita.o
+$(DRIVER_NAME)-objs  += ../driver/cbus_drv/si_drv_cbus.o
+#$(DRIVER_NAME)-objs  += ../driver/cpi_drv/si_drv_cpi.o
+$(DRIVER_NAME)-objs  += ../driver/cra_drv/si_cra.o
+$(DRIVER_NAME)-objs  += ../driver/cra_drv/si_drv_cra_cfg.o
+$(DRIVER_NAME)-objs  += ../driver/rx_drv/si_drv_rx.o
+$(DRIVER_NAME)-objs  += ../driver/rx_drv/si_drv_rx_info.o
+$(DRIVER_NAME)-objs  += ../driver/rx_drv/si_drv_rx_isr.o
+$(DRIVER_NAME)-objs  += ../driver/rx_drv/si_drv_device.o
+#----------------- Platform layer ---------------------------------
+$(DRIVER_NAME)-objs  += platform/osal/sii_osal_linux_timer.o
+$(DRIVER_NAME)-objs  += platform/osal/si_osdebug.o
+$(DRIVER_NAME)-objs  += platform/hal/sii_hal_linux_init.o
+$(DRIVER_NAME)-objs  += platform/hal/sii_hal_linux_i2c.o
+$(DRIVER_NAME)-objs  += platform/hal/sii_hal_linux_isr.o
+$(DRIVER_NAME)-objs  += platform/hal/sii_hal_linux_timer.o
+$(DRIVER_NAME)-objs  += platform/hal/sii_hal_linux_gpio.o
+
+ifneq ($(CONFIG_MHAWB_SUPPORT),)
+$(DRIVER_NAME)-objs  += ../driver/mhawb_drv/si_drv_hawb.o
+$(DRIVER_NAME)-objs  += ../driver/mhawb_drv/si_drv_mhawb.o
+endif
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Module.symvers b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Module.symvers
new file mode 100755
index 000000000000..d2c4abce676b
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/Module.symvers
@@ -0,0 +1,2 @@
+0xb5765808	mdt_burst_send_touch	/mnt/hgfs/cp529x_Auto-Storm/5293/branches/linux_driver/linux_driver/sii5293drv	EXPORT_SYMBOL
+0xbf483fc6	mdt_burst_send_mouse	/mnt/hgfs/cp529x_Auto-Storm/5293/branches/linux_driver/linux_driver/sii5293drv	EXPORT_SYMBOL
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/mhl_linuxdrv.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/mhl_linuxdrv.h
new file mode 100755
index 000000000000..c34378c64daa
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/mhl_linuxdrv.h
@@ -0,0 +1,181 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+/**
+ * @file mhl_driver.h
+ *
+ * @brief Main header file of the MHL Tx driver.
+ *
+ * $Author: Dave Canfield
+ * $Rev: $
+ * $Date: Jan 20, 2011
+ *
+ *****************************************************************************/
+
+
+#if !defined(MHL_DRIVER_H)
+#define MHL_DRIVER_H
+
+#include <linux/amlogic/tvin/tvin_v4l2.h>
+#include "../../../../../../../../../hardware/tvin/tvin_frontend.h"
+
+#include "sii_hal.h"
+#include <linux/device.h>
+#include <mach/gpio.h>
+
+
+
+
+#ifdef __cplusplus 
+extern "C" { 
+#endif  /* _defined (__cplusplus) */
+
+/***** macro definitions *****************************************************/
+#if defined(MAKE_5293_DRIVER)
+
+#define MHL_DRIVER_NAME "sii5293drv"
+#define MHL_DEVICE_NAME "sii-5293"
+//#define CLASS_NAME	"video"
+#define CLASS_NAME  "sii9293"
+#define DEVNAME		"sii5293"
+#define MHL_DEVNAME	"mhl"
+
+#define NUMBER_OF_DEVS	2
+
+#define DEVICE_EVENT	"DEVICE_EVENT"
+#define MHL_EVENT		"MHL_EVENT"
+
+/* Device events */
+#define DEV_CONNECTION_CHANGE_EVENT "connection_change"
+#define DEV_INPUT_VIDEO_MODE_EVENT "input_video_stable"
+
+/* MHL events */
+#define MHL_CONNECTED_EVENT	"connected"
+#define MHL_DISCONNECTED_EVENT	"disconnected"
+#define MHL_RAP_RECEIVED_EVENT	"received_rap"
+#define MHL_RAP_ACKED_EVENT	"received_rapk"
+#define MHL_RCP_RECEIVED_EVENT	"received_rcp"
+#define MHL_RCP_ACKED_EVENT	"received_rcpk"
+#define MHL_RCP_ERROR_EVENT	"received_rcpe"
+#define MHL_UCP_RECEIVED_EVENT	"received_ucp"
+#define MHL_UCP_ACKED_EVENT	"received_ucpk"
+#define MHL_UCP_ERROR_EVENT	"received_ucpe"
+
+#else   
+
+#error "Need to add name and description strings for new drivers here!"
+
+#endif
+
+
+#define MHL_DRIVER_MINOR_MAX   1
+
+
+/***** public type definitions ***********************************************/
+
+typedef enum
+{
+    MHL_CONN = 1,   //default value is 0, so that when comes the notify first time will always effective.
+    HDMI_CONN,
+    NO_CONN,
+} SourceConnection_t;
+
+typedef struct {
+    uint8_t chip_revision;      // chip revision
+    bool_t  pwr5v_state;        // power 5v state
+    bool_t  mhl_cable_state;    // mhl cable state
+    SourceConnection_t connection_state;
+    uint8_t input_video_mode;       // last determined video mode
+    uint8_t debug_i2c_address;
+    uint8_t debug_i2c_offset;
+    uint8_t debug_i2c_xfer_length;
+    uint8_t devcap_remote_offset;   // last Device Capability register 
+    uint8_t devcap_local_offset;    // last Device Capability register
+    uint8_t rap_in_keycode;         // last RAP key code received.
+    uint8_t rap_out_keycode;        // last RAP key code transmitted.
+    uint8_t rap_out_statecode;      // last RAP state code transmitted
+    uint8_t rcp_in_keycode;         // last RCP key code received.
+    uint8_t rcp_out_keycode;        // last RCP key code transmitted.
+    uint8_t rcp_out_statecode;      // last RCP state code transmitted
+    uint8_t ucp_in_keycode;         // last UCP key code received.
+    uint8_t ucp_out_keycode;        // last UCP key code transmitted.
+    uint8_t ucp_out_statecode;      // last UCP state code transmitted
+} MHL_DRIVER_CONTEXT_T, *PMHL_DRIVER_CONTEXT_T;
+
+struct mhl_device_info {
+	dev_t devnum;
+	struct cdev *cdev;
+	struct device *device;
+
+};
+
+typedef struct
+{
+    /* data */
+    unsigned int    i2c_bus_index;
+    gpio_t          gpio_reset;
+    gpio_t          gpio_intr;
+}sii5293_config;
+
+struct device_info {
+	dev_t devnum;
+	struct cdev *cdev;
+	struct device *device;
+	struct class *dev_class;
+
+	struct mhl_device_info *mhl;
+    sii5293_config config;
+
+	uint8_t my_rap_input_device;
+	uint8_t my_rcp_input_device;
+	uint8_t my_ucp_input_device;
+};
+
+typedef struct
+{
+	unsigned int 		cur_height;
+	unsigned int 		cur_width;
+	unsigned int 		cur_frame_rate;
+	/* data */
+}vdin_info_t;
+
+typedef struct
+{
+	tvin_frontend_t tvin_frontend;
+	vdin_parm_t	vdin_parm;
+	vdin_info_t		vdin_info;
+	unsigned int	vdin_started;
+}sii5293_vdin;
+
+/***** global variables ********************************************/
+
+extern MHL_DRIVER_CONTEXT_T gDriverContext;
+extern struct device_info *devinfo;
+
+/***** public function prototypes ********************************************/
+/**
+ * \defgroup driver_public_api Driver Public API
+ * @{
+ */
+int send_sii5293_uevent(struct device *device, const char *event_cat,
+			const char *event_type, const char *event_data);
+
+void SiiConnectionStateNotify(bool_t connect);
+
+#ifdef __cplusplus
+}
+#endif  /* _defined (__cplusplus) */
+
+#endif /* _defined (MHL_DRIVER_H) */
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/mhl_linuxdrv_main.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/mhl_linuxdrv_main.c
new file mode 100755
index 000000000000..b2966be20ac7
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/mhl_linuxdrv_main.c
@@ -0,0 +1,2403 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+
+/**
+ * @file mhl_driver_main.c
+ *
+ * @brief Main entry point of the Linux driver for Silicon Image MHL transmitters.
+ *
+ * $Author: Tiger Qin
+ * $Rev: $
+ * $Date: Aug. 20, 2011
+ *
+ *****************************************************************************/
+
+/***** #include statements ***************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include "mhl_linuxdrv.h"
+#include "osal/include/osal.h"
+#include "si_common.h"
+#include <linux/of.h>
+#include <linux/i2c-aml.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/platform_device.h>
+
+#include <linux/amlogic/tvin/tvin_v4l2.h>
+#include "../../../../../../../../../hardware/tvin/tvin_frontend.h"
+
+#include "vdin_interface.h"
+#include "sii5293_interface.h"
+
+
+
+
+/***** local macro definitions ***********************************************/
+
+/***** local variable declarations *******************************************/
+/***** global variable declarations *******************************************/
+
+MHL_DRIVER_CONTEXT_T gDriverContext = {0};
+struct device_info *devinfo = NULL;
+
+/* Module parameters that can be provided on insmod */
+int debug_level = 0;
+module_param(debug_level, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug_level, "debug level (default: 0)");
+
+int output_format = 0;	/* Set device output format */
+module_param(output_format, int, S_IRUGO);
+MODULE_PARM_DESC(output_format, "Output format(default: 0-RGB)");
+
+int input_dev_rap = 1;	/* RAP Input Device */
+module_param(input_dev_rap, int, S_IRUGO);
+MODULE_PARM_DESC(input_dev_rap, "RAP Input Device (default: 1)");
+
+int input_dev_rcp = 1;	/* RCP Input Device */
+module_param(input_dev_rcp, int, S_IRUGO);
+MODULE_PARM_DESC(input_dev_rcp, "RCP Input Device (default: 1)");
+
+int input_dev_ucp = 1;	/* UCP Input Device */
+module_param(input_dev_ucp, int, S_IRUGO);
+MODULE_PARM_DESC(input_dev_ucp, "UCP Input Device (default: 1)");
+
+
+
+const char strVersion[] = "CP5293-v0.90.01";
+
+static char BUILT_TIME[64];
+
+/*****************************************************************************
+ *  @brief Start the MHL transmitter device
+ *
+ *  This function is called during driver startup to initialize control of the
+ *  MHL transmitter device by the driver.
+ *
+ *  @return     0 if successful, negative error code otherwise
+ *
+ *****************************************************************************/
+int32_t StartMhlTxDevice(void)
+{
+	halReturn_t		halStatus;
+	SiiOsStatus_t	osalStatus;
+
+    pr_info("sii5293, Starting %s\n", MHL_DEVICE_NAME);
+
+    // Initialize the OS Abstraction Layer (OSAL) support.
+    osalStatus = SiiOsInit(0);
+    if (osalStatus != SII_OS_STATUS_SUCCESS)
+    {
+    	SII_DEBUG_PRINT(MSG_ERR,"Initialization of OSAL failed, error code: %d\n",osalStatus);
+    	return -EIO;
+    }
+
+    halStatus = HalInit();
+    if (halStatus != HAL_RET_SUCCESS)
+    {
+    	SII_DEBUG_PRINT(MSG_ERR,"Initialization of HAL failed, error code: %d\n",halStatus);
+    	SiiOsTerm();
+    	return -EIO;
+    }
+
+    halStatus = HalOpenI2cDevice(MHL_DEVICE_NAME, MHL_DRIVER_NAME);
+    if (halStatus != HAL_RET_SUCCESS)
+    {
+    	SII_DEBUG_PRINT(MSG_ERR,"Opening of I2c device %s failed, error code: %d\n",
+    			MHL_DEVICE_NAME, halStatus);
+    	HalTerm();
+    	SiiOsTerm();
+    	return -EIO;
+    }
+
+	HalAcquireIsrLock();
+    /* Initialize the 5293 & power up. */
+    //SiiMhlTxInitialize(&DebugSW);
+    SiiDrvDeviceInitialize();
+
+    HalReleaseIsrLock();
+
+    halStatus = HalInstallIrqHandler(SiiDrvDeviceManageInterrupts);
+    if (halStatus != HAL_RET_SUCCESS)
+    {
+    	SII_DEBUG_PRINT(MSG_ERR,"Initialization of HAL interrupt support failed, error code: %d\n",
+    			halStatus);
+    	HalCloseI2cDevice();
+    	HalTerm();
+    	SiiOsTerm();
+    	return -EIO;
+    }
+	printk("sii5293 [%s] end!\n", __FUNCTION__);
+
+    return 0;
+}
+
+
+
+/**
+ * @brief Stop the MHL transmitter device
+ * This function shuts down control of the transmitter device so that
+ * the driver can exit
+ * 
+ * 
+ * @return 0 if successful, negative error code otherwise
+ * 
+ * @param void
+ * 
+ */
+int32_t StopMhlTxDevice(void)
+{
+	halReturn_t		halStatus;
+
+	pr_info("sii5293, Stopping %s\n", MHL_DEVICE_NAME);
+
+    HalAcquireIsrLock();
+	HalRemoveIrqHandler();
+
+    SiiDrvDeviceRelease();
+    HalReleaseIsrLock();
+
+	halStatus = HalCloseI2cDevice();
+    if (halStatus != HAL_RET_SUCCESS)
+    {
+    	SII_DEBUG_PRINT(MSG_ERR,
+    			"Closing of I2c device failed, error code: %d\n",halStatus);
+    	return -EIO;
+    }
+
+	halStatus = HalTerm();
+    if (halStatus != HAL_RET_SUCCESS)
+    {
+    	SII_DEBUG_PRINT(MSG_ERR,
+    			"Termination of HAL failed, error code: %d\n",halStatus);
+    	return -EIO;
+    }
+
+	SiiOsTerm();
+	return 0;
+}
+
+/***** public functions ******************************************************/
+
+
+#define MAX_EVENT_STRING_LEN 512
+
+
+/* MHL device initialization and release */
+int mhl_dev_add(struct device_info *dev_info)
+{
+	int retval = 0;
+
+	if (NULL == dev_info) {
+		pr_info("sii5293, Invalid devinfo pointer\n");
+		retval = -EFAULT;
+		goto failed;
+	}
+	dev_info->mhl = kzalloc(sizeof(*dev_info->mhl), GFP_KERNEL);
+	if (NULL == dev_info->mhl) {
+		pr_info("sii5293, Out of memory\n");
+		retval = -ENOMEM;
+		goto failed;
+	}
+
+	dev_info->mhl->devnum = MKDEV(MAJOR(dev_info->devnum), 2);
+
+	dev_info->mhl->cdev = cdev_alloc();
+	dev_info->mhl->cdev->owner = THIS_MODULE;
+	retval = cdev_add(dev_info->mhl->cdev, dev_info->mhl->devnum, 1);
+	if (retval) {
+		goto failed;
+	}
+
+	return 0;
+
+failed:
+	return retval;
+}
+
+/*
+ *  MHL Attributes
+ */
+static ssize_t get_connection_state(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int retval;
+	if (SiiMhlRxCbusConnected()) {
+		retval = scnprintf(buf, PAGE_SIZE, "%s", "connected");
+	} else {
+		retval = scnprintf(buf, PAGE_SIZE, "%s", "not connected");
+	}
+	return retval;
+}
+
+
+/*
+ * Declare the sysfs entries for MHL Attributes.
+ * These macros create instances of:
+ *   dev_attr_connection_state
+ */
+static DEVICE_ATTR(connection_state, S_IRUGO, get_connection_state, NULL);
+
+static struct attribute *mhl_attrs[] = {
+	&dev_attr_connection_state.attr,
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+static struct attribute_group mhl_attr_group = {
+	.attrs = mhl_attrs,
+};
+
+
+/*
+ *  MHL Devcap Group Attributes
+ */
+static ssize_t get_mhl_devcap_local(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    int retval = 0;
+
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        retval = -ERESTARTSYS;
+        goto done;
+    }
+
+    retval = scnprintf(buf, PAGE_SIZE, "0x%02X", SiiRegRead(REG_CBUS_DEVICE_CAP_0 + gDriverContext.devcap_local_offset) );
+
+	HalReleaseIsrLock();
+
+done:
+    return retval;
+}
+
+static ssize_t set_mhl_devcap_local(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t retval = count;
+	unsigned long value = 0;
+	int rv = 0;
+
+	rv = strict_strtoul(buf, 0, &value);
+	if (rv) {
+		pr_info("sii5293, Invalid MHL Local Device Capability Value %s", buf);
+		retval = rv;
+		goto done;
+	}
+
+	if (0xFF < value) {
+		pr_info("sii5293, Invalid MHL Local Device Capability Value %lu\n", value);
+		retval = -EINVAL;
+		goto done;
+	}
+
+
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        retval = -ERESTARTSYS;
+        goto done;
+    }
+    SiiRegWrite(REG_CBUS_DEVICE_CAP_0+gDriverContext.devcap_local_offset, value);
+    
+	HalReleaseIsrLock();
+done:
+	return retval;
+}
+
+static ssize_t get_mhl_devcap_local_offset(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "0x%02X", gDriverContext.devcap_local_offset);
+}
+
+static ssize_t set_mhl_devcap_local_offset(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t retval = count;
+	int rv = 0;
+	unsigned long offset = 0;
+
+	rv = strict_strtoul(buf, 0, &offset);
+	if (rv) {
+		pr_info("sii5293, Invalid MHL Local Device Capability Offset %s", buf);
+		retval = rv;
+		goto done;
+	}
+
+	if (0x0F < offset) {
+		pr_info("sii5293, Invalid MHL Local Device Capability Offset %lu\n", offset);
+		retval = -EINVAL;
+		goto done;
+	}
+
+	gDriverContext.devcap_local_offset = offset;
+
+done:
+	return retval;
+}
+
+static ssize_t get_mhl_devcap_remote(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int retval = 0;
+
+	if (!SiiMhlRxCbusConnected()) {
+		pr_info("sii5293, MHL Remote Device Capabilities not available in cbus not connected.\n");
+		retval = -ENODEV;
+		goto done;
+	}
+
+	retval = scnprintf(buf, PAGE_SIZE, "0x%02X", SiiCbusRemoteDcapGet(gDriverContext.devcap_remote_offset));
+
+done:
+	return retval;
+}
+
+static ssize_t get_mhl_devcap_remote_offset(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "0x%02X", gDriverContext.devcap_remote_offset);
+}
+
+static ssize_t set_mhl_devcap_remote_offset(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t retval = count;
+	int rv = 0;
+	unsigned long offset = 0;
+
+	rv = strict_strtoul(buf, 0, &offset);
+	if (rv) {
+		pr_info("sii5293, Invalid MHL Remote Device Capability Offset %s", buf);
+		retval = rv;
+		goto done;
+	}
+
+	if (0x0F < offset) {
+		pr_info("sii5293, Invalid MHL Remote Device Capability Offset %lu\n", offset);
+		retval = -EINVAL;
+		goto done;
+	}
+
+	gDriverContext.devcap_remote_offset = offset;
+
+done:
+	return retval;
+}
+
+
+/*
+ * Declare the sysfs entries forMHL Devcap Group Attributes.
+ */
+static struct device_attribute dev_attr_devcap_local =
+	__ATTR(local, S_IRUGO | S_IWUGO,
+		get_mhl_devcap_local,
+		set_mhl_devcap_local);
+static struct device_attribute dev_attr_devcap_local_offset =
+	__ATTR(local_offset, S_IRUGO | S_IWUGO,
+		get_mhl_devcap_local_offset,
+		set_mhl_devcap_local_offset);
+static struct device_attribute dev_attr_devcap_remote =
+	__ATTR(remote, S_IRUGO, get_mhl_devcap_remote, NULL);
+static struct device_attribute dev_attr_devcap_remote_offset =
+	__ATTR(remote_offset, S_IRUGO | S_IWUGO,
+		get_mhl_devcap_remote_offset,
+		set_mhl_devcap_remote_offset);
+
+static struct attribute *mhl_devcap_attrs[] = {
+	&dev_attr_devcap_local.attr,
+	&dev_attr_devcap_local_offset.attr,
+	&dev_attr_devcap_remote.attr,
+	&dev_attr_devcap_remote_offset.attr,
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+static struct attribute_group mhl_devcap_attr_group = {
+	.name = __stringify(devcap),
+	.attrs = mhl_devcap_attrs,
+};
+
+/*
+ * MHL RAP Group Attributes
+ */
+static ssize_t get_mhl_rap_in(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    return scnprintf(buf,PAGE_SIZE,"0x%02X",gDriverContext.rap_in_keycode);
+}
+
+static ssize_t set_mhl_rap_in_status(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long param;
+    ssize_t status = count;
+
+	if (!SiiMhlRxCbusConnected()) {
+		pr_info("sii5293, Command not available in cbus not connected.\n");
+		return -ENODEV;
+	}
+    
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+    param = simple_strtoul(buf, NULL, 0);
+    switch(param)
+    {
+        case 0x00:
+        case 0x03:
+            SiiMhlRxSendRapk(param);
+            break;
+        default:
+            DEBUG_PRINT( MSG_ERR, "Invalid parameter %s received\n", buf);
+            status = -EINVAL;
+    }
+	HalReleaseIsrLock();
+	return status;
+}
+
+static ssize_t get_mhl_rap_out(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    return scnprintf(buf,PAGE_SIZE,"0x%02X",gDriverContext.rap_out_keycode);
+}
+
+static ssize_t set_mhl_rap_out(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long param;
+    ssize_t status = count;
+
+	if (!SiiMhlRxCbusConnected()) {
+		pr_info("sii5293, Command not available in cbus not connected.\n");
+		return -ENODEV;
+	}
+    
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+    param = simple_strtoul(buf, NULL, 0);
+    switch(param)
+    {
+        case MHL_RAP_CMD_POLL:
+        case MHL_RAP_CONTENT_ON:
+        case MHL_RAP_CONTENT_OFF:
+            SiiMhlRxSendRAPCmd(param);
+            gDriverContext.rap_out_keycode = param;
+            gDriverContext.rap_out_statecode = MHL_MSC_MSG_RAP_NO_ERROR;
+            break;
+        default:
+            DEBUG_PRINT( MSG_ERR, "Invalid parameter %s received\n", buf);
+            status = -EINVAL;
+    }
+	HalReleaseIsrLock();
+	return status;
+}
+
+static ssize_t get_mhl_rap_out_status(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    return scnprintf(buf,PAGE_SIZE,"0x%02X",gDriverContext.rap_out_statecode);
+}
+
+static ssize_t get_mhl_rap_input_dev(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf,PAGE_SIZE,"%d",input_dev_rap);
+}
+
+static ssize_t set_mhl_rap_input_dev(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int status;
+    unsigned long param;
+
+	/* Assume success */
+    status = count;
+    param = simple_strtoul(buf, NULL, 0);
+    switch(param)
+    {
+        case 0:
+        case 1:
+            input_dev_rap = param;
+            break;
+        default:
+            DEBUG_PRINT( MSG_ERR, "Invalid parameter %s received\n", buf);
+            status = -EINVAL;
+    }
+	return status;
+}
+
+/*
+ * Declare the sysfs entries for MHL RAP Group Attributes.
+ */
+static struct device_attribute dev_attr_rap_in =
+	__ATTR(in, S_IRUGO, get_mhl_rap_in, NULL);
+static struct device_attribute dev_attr_rap_in_status =
+	__ATTR(in_status, S_IWUGO, NULL, set_mhl_rap_in_status);
+static struct device_attribute dev_attr_rap_out =
+	__ATTR(out, S_IRUGO | S_IWUGO,
+		get_mhl_rap_out,
+		set_mhl_rap_out);
+static struct device_attribute dev_attr_rap_out_status =
+	__ATTR(out_status, S_IRUGO, get_mhl_rap_out_status, NULL);
+static struct device_attribute dev_attr_rap_input_dev =
+	__ATTR(input_dev, S_IRUGO | S_IWUGO,
+		get_mhl_rap_input_dev,
+		set_mhl_rap_input_dev);
+
+static struct attribute *mhl_rap_attrs[] = {
+	&dev_attr_rap_in.attr,
+	&dev_attr_rap_in_status.attr,
+	&dev_attr_rap_out.attr,
+	&dev_attr_rap_out_status.attr,
+	&dev_attr_rap_input_dev.attr,
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+static struct attribute_group mhl_rap_attr_group = {
+	.name = __stringify(rap),
+	.attrs = mhl_rap_attrs,
+};
+
+
+/*
+ * MHL RCP Group Attributes
+ */
+static ssize_t get_mhl_rcp_in(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    return scnprintf(buf,PAGE_SIZE,"0x%02X",gDriverContext.rcp_in_keycode);
+}
+
+static ssize_t set_mhl_rcp_in_status(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long param;
+    ssize_t status = count;
+
+	if (!SiiMhlRxCbusConnected()) {
+		pr_info("sii5293, Command not available in cbus not connected.\n");
+		return -ENODEV;
+	}
+    
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+    param = simple_strtoul(buf, NULL, 0);
+    switch(param)
+    {
+        case 0x00:
+            SiiMhlRxSendRcpk(gDriverContext.rcp_in_keycode);
+            break;
+        case 0x01:
+        case 0x02:
+            SiiMhlRxSendRcpe(param);
+            SiiMhlRxSendRcpk(gDriverContext.rcp_in_keycode);
+            break;
+        default:
+            DEBUG_PRINT( MSG_ERR, "Invalid parameter %s received\n", buf);
+            status = -EINVAL;
+    }
+	HalReleaseIsrLock();
+	return status;
+}
+
+static ssize_t get_mhl_rcp_out(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    return scnprintf(buf,PAGE_SIZE,"0x%02X",gDriverContext.rcp_out_keycode);
+}
+
+static ssize_t set_mhl_rcp_out(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long param;
+    ssize_t status = count;
+
+	if (!SiiMhlRxCbusConnected()) {
+		pr_info("sii5293, Command not available in cbus not connected.\n");
+		return -ENODEV;
+	}
+    
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+    param = simple_strtoul(buf, NULL, 0);
+    if (param > 0xFF)
+    {
+        DEBUG_PRINT( MSG_ERR, "Invalid parameter %s received\n", buf);
+        status = -EINVAL;
+    }else
+    {
+        SiiMhlRxSendRCPCmd(param);
+        gDriverContext.rcp_out_keycode = param;
+        gDriverContext.rcp_out_statecode = MHL_MSC_MSG_RCP_NO_ERROR;
+    }
+	HalReleaseIsrLock();
+	return status;
+}
+
+static ssize_t get_mhl_rcp_out_status(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    return scnprintf(buf,PAGE_SIZE,"0x%02X",gDriverContext.rcp_out_statecode);
+}
+
+static ssize_t get_mhl_rcp_input_dev(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf,PAGE_SIZE,"%d",input_dev_rcp);
+}
+
+static ssize_t set_mhl_rcp_input_dev(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int status;
+    unsigned long param;
+
+	/* Assume success */
+    status = count;
+    param = simple_strtoul(buf, NULL, 0);
+    switch(param)
+    {
+        case 0:
+        case 1:
+            input_dev_rcp = param;
+            break;
+        default:
+            DEBUG_PRINT( MSG_ERR, "Invalid parameter %s received\n", buf);
+            status = -EINVAL;
+    }
+	return status;
+}
+
+/*
+ * Declare the sysfs entries for MHL RCP Group Attributes.
+ */
+static struct device_attribute dev_attr_rcp_in =
+	__ATTR(in, S_IRUGO, get_mhl_rcp_in, NULL);
+static struct device_attribute dev_attr_rcp_in_status =
+	__ATTR(in_status, S_IWUGO, NULL, set_mhl_rcp_in_status);
+static struct device_attribute dev_attr_rcp_out =
+	__ATTR(out, S_IRUGO | S_IWUGO,
+		get_mhl_rcp_out,
+		set_mhl_rcp_out);
+static struct device_attribute dev_attr_rcp_out_status =
+	__ATTR(out_status, S_IRUGO, get_mhl_rcp_out_status, NULL);
+static struct device_attribute dev_attr_rcp_input_dev =
+	__ATTR(input_dev, S_IRUGO | S_IWUGO,
+		get_mhl_rcp_input_dev,
+		set_mhl_rcp_input_dev);
+
+static struct attribute *mhl_rcp_attrs[] = {
+	&dev_attr_rcp_in.attr,
+	&dev_attr_rcp_in_status.attr,
+	&dev_attr_rcp_out.attr,
+	&dev_attr_rcp_out_status.attr,
+	&dev_attr_rcp_input_dev.attr,
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+static struct attribute_group mhl_rcp_attr_group = {
+	.name = __stringify(rcp),
+	.attrs = mhl_rcp_attrs,
+};
+
+
+/*
+ * MHL UCP Group Attributes
+ */
+static ssize_t get_mhl_ucp_in(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    return scnprintf(buf,PAGE_SIZE,"0x%02X",gDriverContext.ucp_in_keycode);
+}
+
+static ssize_t set_mhl_ucp_in_status(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long param;
+    ssize_t status = count;
+
+	if (!SiiMhlRxCbusConnected()) {
+		pr_info("sii5293, Command not available in cbus not connected.\n");
+		return -ENODEV;
+	}
+    
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+    param = simple_strtoul(buf, NULL, 0);
+    switch(param)
+    {
+        case 0x00:
+            SiiMhlRxSendUcpk(gDriverContext.ucp_in_keycode);
+            break;
+        case 0x01:
+            SiiMhlRxSendUcpe(param);
+            SiiMhlRxSendUcpk(gDriverContext.ucp_in_keycode);
+            break;
+        default:
+            DEBUG_PRINT( MSG_ERR, "Invalid parameter %s received\n", buf);
+            status = -EINVAL;
+    }
+	HalReleaseIsrLock();
+	return status;
+}
+
+static ssize_t get_mhl_ucp_out(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    return scnprintf(buf,PAGE_SIZE,"0x%02X",gDriverContext.ucp_out_keycode);
+}
+
+static ssize_t set_mhl_ucp_out(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long param;
+    ssize_t status = count;
+
+	if (!SiiMhlRxCbusConnected()) {
+		pr_info("sii5293, Command not available in cbus not connected.\n");
+		return -ENODEV;
+	}
+    
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+    param = simple_strtoul(buf, NULL, 0);
+    if (param > 0xFF)
+    {
+        DEBUG_PRINT( MSG_ERR, "Invalid parameter %s received\n", buf);
+        status = -EINVAL;
+    }else
+    {
+        SiiMhlRxSendUCPCmd(param);
+        gDriverContext.ucp_out_keycode = param;
+        gDriverContext.ucp_out_statecode = MHL_MSC_MSG_UCP_NO_ERROR;
+    }
+	HalReleaseIsrLock();
+	return status;
+}
+
+static ssize_t get_mhl_ucp_out_status(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    return scnprintf(buf,PAGE_SIZE,"0x%02X",gDriverContext.ucp_out_statecode);
+}
+
+static ssize_t get_mhl_ucp_input_dev(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf,PAGE_SIZE,"%d",input_dev_ucp);
+}
+
+static ssize_t set_mhl_ucp_input_dev(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int status;
+    unsigned long param;
+
+	/* Assume success */
+    status = count;
+    param = simple_strtoul(buf, NULL, 0);
+    switch(param)
+    {
+        case 0:
+        case 1:
+            input_dev_ucp = param;
+            break;
+        default:
+            DEBUG_PRINT( MSG_ERR, "Invalid parameter %s received\n", buf);
+            status = -EINVAL;
+    }
+	return status;
+}
+
+/*
+ * Declare the sysfs entries for MHL UCP Group Attributes.
+ */
+static struct device_attribute dev_attr_ucp_in =
+	__ATTR(in, S_IRUGO, get_mhl_ucp_in, NULL);
+static struct device_attribute dev_attr_ucp_in_status =
+	__ATTR(in_status, S_IWUGO, NULL, set_mhl_ucp_in_status);
+static struct device_attribute dev_attr_ucp_out =
+	__ATTR(out, S_IRUGO | S_IWUGO,
+		get_mhl_ucp_out,
+		set_mhl_ucp_out);
+static struct device_attribute dev_attr_ucp_out_status =
+	__ATTR(out_status, S_IRUGO, get_mhl_ucp_out_status, NULL);
+static struct device_attribute dev_attr_ucp_input_dev =
+	__ATTR(input_dev, S_IRUGO | S_IWUGO,
+		get_mhl_ucp_input_dev,
+		set_mhl_ucp_input_dev);
+
+static struct attribute *mhl_ucp_attrs[] = {
+	&dev_attr_ucp_in.attr,
+	&dev_attr_ucp_in_status.attr,
+	&dev_attr_ucp_out.attr,
+	&dev_attr_ucp_out_status.attr,
+	&dev_attr_ucp_input_dev.attr,
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+static struct attribute_group mhl_ucp_attr_group = {
+	.name = __stringify(ucp),
+	.attrs = mhl_ucp_attrs,
+};
+
+
+int mhl_dev_init(struct device_info *dev_info)
+{
+	int retval = 0;
+
+	if ((NULL == dev_info) || (NULL == dev_info->mhl)) {
+		pr_info("sii5293, Invalid devinfo pointer\n");
+		retval = -EFAULT;
+		goto failed;
+	}
+
+    dev_info->dev_class->dev_attrs = NULL;
+	dev_info->mhl->device = device_create(dev_info->dev_class, dev_info->device,
+				dev_info->mhl->devnum, NULL, MHL_DEVNAME);
+	if (IS_ERR(dev_info->mhl->device)) {
+		retval = PTR_ERR(dev_info->mhl->device);
+		goto failed;
+	}
+
+	retval = sysfs_create_group(&dev_info->mhl->device->kobj, &mhl_attr_group);
+	if (retval < 0) {
+		pr_info("sii5293, failed to create MHL attribute group - continuing without\n");
+	}
+
+	retval = sysfs_create_group(&dev_info->mhl->device->kobj, &mhl_devcap_attr_group);
+	if (retval < 0) {
+		pr_info("sii5293, failed to create MHL devcap attribute group - continuing without\n");
+	}
+
+	retval = sysfs_create_group(&dev_info->mhl->device->kobj, &mhl_rap_attr_group);
+	if (retval < 0) {
+		pr_info("sii5293, failed to create MHL rap attribute group - continuing without\n");
+	}
+
+	retval = sysfs_create_group(&dev_info->mhl->device->kobj, &mhl_rcp_attr_group);
+	if (retval < 0) {
+		pr_info("sii5293, failed to create MHL rcp attribute group - continuing without\n");
+	}
+
+	retval = sysfs_create_group(&dev_info->mhl->device->kobj, &mhl_ucp_attr_group);
+	if (retval < 0) {
+		pr_info("sii5293, failed to create MHL ucp attribute group - continuing without\n");
+	}
+
+	return 0;
+
+failed:
+	return retval;
+}
+
+void mhl_dev_exit(struct device_info *dev_info)
+{
+	if ((NULL == dev_info) || (NULL == dev_info->mhl)) {
+		pr_info("sii5293, Invalid devinfo pointer\n");
+		return;
+	}
+
+	sysfs_remove_group(&dev_info->mhl->device->kobj, &mhl_attr_group);
+	sysfs_remove_group(&dev_info->mhl->device->kobj, &mhl_devcap_attr_group);
+	sysfs_remove_group(&dev_info->mhl->device->kobj, &mhl_rap_attr_group);
+	sysfs_remove_group(&dev_info->mhl->device->kobj, &mhl_rcp_attr_group);
+	sysfs_remove_group(&dev_info->mhl->device->kobj, &mhl_ucp_attr_group);
+
+	device_unregister(dev_info->mhl->device);
+	device_destroy(dev_info->dev_class, dev_info->mhl->devnum);
+}
+
+
+/*
+ * Sii5293 Attributes
+ */
+static ssize_t get_chip_version(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    if (gDriverContext.chip_revision == 0xFF)
+        return scnprintf(buf, PAGE_SIZE, "%s", "");
+    else
+        return scnprintf(buf, PAGE_SIZE, "%d", gDriverContext.chip_revision);
+}
+
+static ssize_t get_input_video_mode(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    uint8_t vic4x3, vic16x9;
+    if (0 == gDriverContext.input_video_mode)
+    {
+        return scnprintf(buf, PAGE_SIZE, "not stable");
+    }
+    else if (SI_VIDEO_MODE_NON_STD == gDriverContext.input_video_mode)
+    {
+        return scnprintf(buf, PAGE_SIZE, "out of range");
+    }
+    else if (SI_VIDEO_MODE_PC_OTHER == gDriverContext.input_video_mode)
+    {
+        return scnprintf(buf, PAGE_SIZE, "pc resolution");
+    }
+    else
+    {
+        gDriverContext.input_video_mode &= 0x7f;
+        if (gDriverContext.input_video_mode >= NMB_OF_CEA861_VIDEO_MODES)
+        {
+            return scnprintf(buf, PAGE_SIZE, "HDMI VIC %d", VideoModeTable[gDriverContext.input_video_mode].HdmiVic);
+        }
+        else
+        {
+            vic4x3 = VideoModeTable[gDriverContext.input_video_mode].Vic4x3;
+            vic16x9 = VideoModeTable[gDriverContext.input_video_mode].Vic16x9;
+            if (vic4x3 && vic16x9)
+                return scnprintf(buf, PAGE_SIZE, "CEA VIC %d %d", vic4x3, vic16x9);
+            else if (vic4x3)
+                return scnprintf(buf, PAGE_SIZE, "CEA VIC %d", vic4x3);
+            else if (vic16x9)
+                return scnprintf(buf, PAGE_SIZE, "CEA VIC %d", vic16x9);
+            else
+                return scnprintf(buf, PAGE_SIZE, "%s", "");
+        }
+    }
+}
+
+static ssize_t get_device_connection_state(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+    ssize_t status = 0;
+    switch(gDriverContext.connection_state)
+    {
+        case MHL_CONN:
+            status = scnprintf(buf, PAGE_SIZE, "%s", "mhl source connected");
+            break;
+        case HDMI_CONN:
+            status = scnprintf(buf, PAGE_SIZE, "%s", "hdmi source connected");
+            break;
+        case NO_CONN:
+            status = scnprintf(buf, PAGE_SIZE, "%s", "no source connected");
+            break;
+        default:
+            status = scnprintf(buf, PAGE_SIZE, "%s", "");
+            break;
+    }
+    return status;
+}
+
+static ssize_t get_debug_level(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%d", debug_level);
+}
+
+static ssize_t set_debug_level(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t retval = count;
+	int rv = 0;
+	long new_debug_level = 0;
+
+	rv = strict_strtol(buf, 0, &new_debug_level);
+	if (rv) {
+		pr_info("sii5293, Invalid Debug Level input: %s", buf);
+		retval = rv;
+		goto done;
+	}
+
+	if (new_debug_level < -1 || new_debug_level > 2) {
+		printk("Invalid Debug Level input: %d\n", (int)new_debug_level);
+		retval = -EINVAL;
+		goto done;
+	}
+
+	debug_level = (int)new_debug_level;
+
+done:
+	return retval;
+}
+
+
+/*
+ * Declare the sysfs entries for Sii5293 Attributes.
+ * These macros create instances of:
+ *   dev_attr_chip_version
+ *   dev_attr_input_video_mode
+ *   dev_attr_device_connection_state
+ *   dev_attr_debug_level
+ */
+static DEVICE_ATTR(chip_version, S_IRUGO, get_chip_version, NULL);
+static DEVICE_ATTR(input_video_mode, S_IRUGO, get_input_video_mode, NULL);
+static DEVICE_ATTR(device_connection_state, S_IRUGO, get_device_connection_state, NULL);
+static DEVICE_ATTR(debug_level, S_IRUGO | S_IWUGO, get_debug_level, set_debug_level);
+
+static struct attribute *sii5293_attrs[] = {
+    &dev_attr_chip_version.attr,
+    &dev_attr_input_video_mode.attr,
+    &dev_attr_device_connection_state.attr,
+    &dev_attr_debug_level.attr,
+    NULL,	/* need to NULL terminate the list of attributes */
+};
+
+static struct attribute_group sii5293_attr_group = {
+	.attrs = sii5293_attrs,
+};
+
+#ifdef DEBUG
+
+static ssize_t get_pwr5v_state(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    if (gDriverContext.pwr5v_state)
+        return scnprintf(buf, PAGE_SIZE, "%s", "in");
+    else
+        return scnprintf(buf, PAGE_SIZE, "%s", "out");
+}
+
+static ssize_t get_mhl_cable_state(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+    if (gDriverContext.mhl_cable_state)
+        return scnprintf(buf, PAGE_SIZE, "%s", "in");
+    else
+        return scnprintf(buf, PAGE_SIZE, "%s", "out");
+}
+
+static ssize_t get_rx_term_state(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+    int		status = 0;
+
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+
+    status = scnprintf(buf, PAGE_SIZE, "%d", SiiRegRead(REG_RX_CTRL5)&0x03 );
+
+    HalReleaseIsrLock();
+    return status;
+}
+
+static ssize_t set_rx_term_state(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+    int status = 0;
+    long new_term = 0;
+
+    status = strict_strtol(buf, 0, &new_term);
+    if (status) {
+        pr_info("sii5293, Invalid Debug Level input: %s", buf);
+        return status;
+    }
+
+    if (new_term < 0 || new_term > 3) {
+        pr_info("sii5293, Invalid Debug Level input: %d", (int)new_term);
+        return -EINVAL;
+    }
+
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+
+    SiiRegModify(REG_RX_CTRL5, 0x03, new_term);
+
+    HalReleaseIsrLock();
+    return count;
+}
+
+static ssize_t get_hdcp_state(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+	int		status = 0;
+
+	if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+	{
+		return -ERESTARTSYS;
+	}
+
+    status = scnprintf(buf, PAGE_SIZE, "%s", SiiRegRead(RX_A__HDCP_STAT)&RX_M__HDCP_STAT__AUTHENTICATED ? "authenticated":"not authenticated" );
+
+	HalReleaseIsrLock();
+	return status;
+}
+
+static ssize_t get_hpd_state(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+    int		status = 0;
+    uint8_t regVal;
+
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+
+    regVal = SiiRegRead(REG_HP_CTRL)&0x03;
+
+    HalReleaseIsrLock();
+
+    if ( regVal == 2)
+    {
+        if (SiiMhlRxCbusConnected())
+        {
+            status = scnprintf(buf, PAGE_SIZE, "%s", "high");
+        }else
+        {
+            status = scnprintf(buf, PAGE_SIZE, "%s", "low");
+        }
+    }
+    else if (regVal == 0)
+    {
+        status = scnprintf(buf, PAGE_SIZE, "%s", "low");
+    }
+    else if (regVal == 1)
+    {
+        status = scnprintf(buf, PAGE_SIZE, "%s", "high");
+    }
+    else
+    {
+        status = scnprintf(buf, PAGE_SIZE, "%s", "");
+    }
+
+    return status;
+}
+
+static ssize_t set_hpd_state(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+    int status = 0;
+    long new_hpd = 0;
+
+    status = strict_strtol(buf, 0, &new_hpd);
+    if (status) {
+        pr_info("sii5293, Invalid Debug Level input: %s", buf);
+        return status;
+    }
+
+    if (new_hpd < 0 || new_hpd > 2) {
+        pr_info("sii5293, Invalid Debug Level input: %d", (int)new_hpd);
+        return -EINVAL;
+    }
+
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+
+    SiiRegModify(REG_HP_CTRL, 0x03, new_hpd);
+
+    HalReleaseIsrLock();
+    return count;
+}
+
+
+#define MAX_DEBUG_TRANSFER_SIZE 16
+static ssize_t get_debug_register(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+    uint8_t					data[MAX_DEBUG_TRANSFER_SIZE];
+    uint8_t					idx, j;
+    int						status = -EINVAL;
+
+    DEBUG_PRINT(MSG_DBG, "called\n");
+
+    if (gDriverContext.debug_i2c_address == 0)
+        gDriverContext.debug_i2c_address = DEV_PAGE_PP_0;
+
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+
+    status = scnprintf(buf, PAGE_SIZE, "address:0x%02X offset:0x%02X " \
+					   "length:0x%02X data:",
+						gDriverContext.debug_i2c_address,
+						gDriverContext.debug_i2c_offset,
+						gDriverContext.debug_i2c_xfer_length);
+    if (gDriverContext.debug_i2c_xfer_length == 0)
+    {
+        for (j=0;j<16;j++)
+        {
+            if (0 != CraReadBlockI2c( DEV_I2C_0, gDriverContext.debug_i2c_address, 16*j, data, 16))
+                    return -EINVAL;
+            status += scnprintf(&buf[status], PAGE_SIZE, "\n");
+            for (idx = 0; idx < 16; idx++)
+            {
+                status += scnprintf(&buf[status], PAGE_SIZE, "0x%02X ",
+                data[idx]);
+            }
+        }
+    }else
+    {
+        if (0 != CraReadBlockI2c( DEV_I2C_0, gDriverContext.debug_i2c_address, gDriverContext.debug_i2c_offset, data, gDriverContext.debug_i2c_xfer_length))
+                return -EINVAL;
+        for (idx = 0; idx < gDriverContext.debug_i2c_xfer_length; idx++) {
+            status += scnprintf(&buf[status], PAGE_SIZE, "0x%02X ",
+            data[idx]);
+	    }
+    }
+
+    HalReleaseIsrLock();
+
+    return status;
+}
+
+static ssize_t set_debug_register(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	static char *white_space = "' ', '\t'";
+	unsigned long	address = 0x100;		/* initialize with invalid values */
+	unsigned long	offset = 0x100;
+	unsigned long	length = 0x100;
+	unsigned long	value;
+	uint8_t				data[MAX_DEBUG_TRANSFER_SIZE];
+	uint8_t				idx;
+	char			*str;
+	char			*endptr;
+	int				status = -EINVAL;
+
+	DEBUG_PRINT(MSG_DBG, "received string: ""%s""\n", buf);
+
+	/*
+	 * Parse the input string and extract the scratch pad register selection
+	 * parameters
+	 */
+	str = strstr(buf, "address=");
+	if (str != NULL) {
+		address = simple_strtoul(str + 8, NULL, 0);
+		if (address > 0xFF) {
+			DEBUG_PRINT(MSG_ERR, "Invalid page address: 0x%02lX" \
+					"specified\n", address);
+			goto err_exit;
+		}
+	} else {
+		DEBUG_PRINT(MSG_ERR, "Invalid string format, can't "\
+				"find ""address"" parameter\n");
+		goto err_exit;
+	}
+
+	str = strstr(buf, "offset=");
+	if (str != NULL) {
+		offset = simple_strtoul(str + 7, NULL, 0);
+		if (offset > 0xFF) {
+			DEBUG_PRINT(MSG_ERR, "Invalid page offset: 0x%02lX" \
+					"specified\n", offset);
+			goto err_exit;
+		}
+	} else {
+		DEBUG_PRINT(MSG_ERR, "Invalid string format, can't "\
+				"find ""offset"" value\n");
+		goto err_exit;
+	}
+
+	str = strstr(buf, "length=");
+	if (str != NULL) {
+		length = simple_strtoul(str + 7, NULL, 0);
+		if (length > MAX_DEBUG_TRANSFER_SIZE) {
+			DEBUG_PRINT(MSG_ERR, "Transfer size 0x%02lX is too "\
+					"large\n", length);
+			goto err_exit;
+		}
+	} else {
+		DEBUG_PRINT(MSG_ERR, "Invalid string format, can't "\
+				"find ""length"" value\n");
+		goto err_exit;
+	}
+
+	str = strstr(buf, "data=");
+	if (str != NULL) {
+
+		str += 5;
+		endptr = str;
+		for(idx = 0; idx < length; idx++) {
+			endptr += strspn(endptr, white_space);
+			str = endptr;
+			if (*str == 0) {
+				DEBUG_PRINT(MSG_ERR, "Too few data values provided\n");
+				goto err_exit;
+			}
+
+			value = simple_strtoul(str, &endptr, 0);
+
+			if (value > 0xFF) {
+				DEBUG_PRINT(MSG_ERR, "Invalid register data "\
+						"value detected\n");
+				goto err_exit;
+			}
+
+			data[idx] = value;
+		}
+		
+
+	} else {
+		idx = 0;
+	}
+
+	if ((offset + length) > 0x100) {
+		DEBUG_PRINT(MSG_ERR
+			, "Invalid offset/length combination entered 0x%02X/0x%02X"
+			, offset, length);
+		goto err_exit;
+	}
+
+	gDriverContext.debug_i2c_address = address;
+	gDriverContext.debug_i2c_offset = offset;
+	gDriverContext.debug_i2c_xfer_length = length;
+
+	if (idx == 0) {
+		DEBUG_PRINT(MSG_ERR, "No data specified, storing address "\
+				 "offset and length for subsequent debug read\n");
+		goto err_exit;
+	}
+
+    if(HalAcquireIsrLock() != HAL_RET_SUCCESS)
+    {
+        return -ERESTARTSYS;
+    }
+
+    status =  CraWriteBlockI2c( DEV_I2C_0, address, offset, data, length);
+
+	if (status == 0)
+		status = count;
+
+	HalReleaseIsrLock();
+
+err_exit:
+	return status;
+}
+
+
+static DEVICE_ATTR(hpd_state, S_IRUGO, get_hpd_state, set_hpd_state);
+static DEVICE_ATTR(hdcp_state, S_IRUGO, get_hdcp_state, NULL);
+static DEVICE_ATTR(pwr5v_state, S_IRUGO, get_pwr5v_state, NULL);
+static DEVICE_ATTR(mhl_cable_state, S_IRUGO, get_mhl_cable_state, NULL);
+static DEVICE_ATTR(rx_term_state, S_IRUGO, get_rx_term_state, set_rx_term_state);
+static DEVICE_ATTR(register, S_IRUGO | S_IWUGO, get_debug_register, set_debug_register);
+
+static struct attribute *sii5293_debug_attrs[] = {
+    &dev_attr_pwr5v_state.attr,
+    &dev_attr_mhl_cable_state.attr,
+    &dev_attr_rx_term_state.attr,
+    &dev_attr_hpd_state.attr,
+    &dev_attr_hdcp_state.attr,
+    &dev_attr_register.attr,
+    NULL,	/* need to NULL terminate the list of attributes */
+};
+
+static struct attribute_group sii5293_debug_attr_group = {
+	.name = __stringify(debug),
+	.attrs = sii5293_debug_attrs,
+};
+#endif
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// according to the <<CEA-861-D>>
+typedef enum
+{
+	CEA_480P60	= 2,
+	CEA_720P60	= 4,
+	CEA_1080I60	= 5,
+	CEA_480I60	= 6,
+
+	CEA_1080P60	= 16,
+	CEA_576P50	= 17,
+	CEA_720P50	= 19,
+	CEA_1080I50	= 20,
+	CEA_576I50	= 21,
+
+	CEA_1080P50	= 31,
+
+	CEA_MAX = 60
+}SII5293_VIDEO_MODE;
+
+static unsigned int vdin_state = 0;
+sii5293_vdin sii5293_vdin_info;
+
+void dump_input_video_info(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode;
+
+	if (0 == index)
+    {
+        printk("sii5293 input video not stable!\n");
+    }
+    else if (SI_VIDEO_MODE_NON_STD == index)
+    {
+        printk("sii5293 input video out of range!\n");
+    }
+    else if (SI_VIDEO_MODE_PC_OTHER == index)
+    {
+        printk("sii5293 input pc resolution!\n");
+    }
+    else
+    {
+    	index = gDriverContext.input_video_mode & 0x7f;
+    	if( index >= NMB_OF_CEA861_VIDEO_MODES )
+    		printk("sii5293 input video index = %d\n", index);
+    	else
+    	{
+			int height,width,h_total,v_total;
+			int hs_fp,hs_width,hs_bp;
+			int vs_fp,vs_width,vs_bp;
+			int clk,h_freq,v_freq,interlaced;
+
+			height = sii_get_h_active();
+			width = sii_get_v_active();
+
+			h_total = sii_get_h_total();
+			v_total = sii_get_v_total();
+
+			hs_fp = sii_get_hs_frontporch();
+			hs_width = sii_get_hs_width();
+			hs_bp = sii_get_hs_backporch();
+
+			vs_fp = sii_get_vs_frontporch();
+			vs_width = sii_get_vs_width();
+			vs_bp = sii_get_vs_backporch();
+			clk = sii_get_pixel_clock();
+			h_freq = sii_get_h_freq();
+			v_freq = sii_get_v_freq();
+			interlaced = sii_get_interlaced();
+
+			printk("sii5293 hdmi-in video info:\n\n\
+	height * width = %4d x %4d, ( %4d x %4d )\n\
+	h sync = %4d, %4d, %4d\n\
+	v sync = %4d, %4d, %4d\n\
+	pixel_clk = %9d, h_freq = %5d, v_freq = %2d\n\
+	interlaced = %d\n",
+				height,width,h_total,v_total,
+				hs_fp,hs_width,hs_bp,
+				vs_fp,vs_width,vs_bp,
+				clk,h_freq,v_freq,interlaced
+				);
+		}
+	}
+}
+
+unsigned int sii5293_get_output_mode(void)
+{
+	unsigned int h_active,h_total,v_active,v_total;
+	unsigned int mode = 0;
+
+	if( (gDriverContext.input_video_mode == 0) || (gDriverContext.input_video_mode >= NMB_OF_CEA861_VIDEO_MODES) )
+		return mode;
+
+	switch( gDriverContext.input_video_mode & 0x7f )
+	{
+		case 11:		mode = CEA_1080P60;		break;
+		case 24:		mode = CEA_1080P50;		break;
+		case  3:		mode = CEA_1080I60;		break;
+		case 14:		mode = CEA_1080I50;		break;
+		case  2:		mode = CEA_720P60;		break;
+		case 13:		mode = CEA_720P50;		break;
+		case 12:		mode = CEA_576P50;		break;
+		case  1:		mode = CEA_480P60;		break;
+		case 15:		mode = CEA_576I50;		break;
+		case  4:		mode = CEA_480I60;		break;
+	}
+
+	return mode;
+}
+
+static void sii5293_start_vdin_mode(unsigned int mode)
+{
+	unsigned int height = 0, width = 0, frame_rate = 0, field_flag = 0;
+
+	printk("[%s], start with mode = %d\n", __FUNCTION__, mode);
+	switch(mode)
+	{
+		case CEA_480I60:
+			width = 1440;	height = 480;	frame_rate = 60;	field_flag = 1;		
+			break;
+		
+		case CEA_480P60:
+			width = 720;	height = 480;	frame_rate = 60;	field_flag = 0;		
+			break;
+		
+		case CEA_576I50:
+			width = 1440;	height = 576;	frame_rate = 50;	field_flag = 1;		
+			break;
+		
+		case CEA_576P50:
+			width = 720;	height = 576;	frame_rate = 50;	field_flag = 0;		
+			break;
+		
+		case CEA_720P50:
+			width = 1280;	height = 720;	frame_rate = 50;	field_flag = 0;		
+			break;
+		
+		case CEA_720P60:
+			width = 1280;	height = 720;	frame_rate = 60;	field_flag = 0;		
+			break;
+		
+		case CEA_1080I60:
+			width = 1920;	height = 1080;	frame_rate = 60;	field_flag = 1;		
+			break;
+		
+		case CEA_1080P60:
+			width = 1920;	height = 1080;	frame_rate = 60;	field_flag = 0;		
+			break;
+		
+		case CEA_1080I50:
+			width = 1920;	height = 1080;	frame_rate = 50;	field_flag = 1;		
+			break;
+		
+		case CEA_1080P50:
+			width = 1920;	height = 1080;	frame_rate = 50;	field_flag = 0;		
+			break;
+		
+		default:
+			printk("[%s], invalid video mode!\n",__FUNCTION__);
+			return ;
+	}
+
+	sii5293_start_vdin(&sii5293_vdin_info,width,height,frame_rate,field_flag);
+
+	return ;
+}
+
+static unsigned int sii_output_mode = 0xff;
+void sii5293_output_mode_trigger(unsigned int flag)
+{
+	unsigned int mode = 0xff;
+	
+	printk("sii5293 SCDT trigger flag = %d\n", flag);
+	if( flag == 0 ) // sii5293 SCDT off
+		return ;
+
+	// if vdin is not started, then don't trigger automatically.
+	if( sii5293_vdin_info.vdin_started != 1 )
+		return ;
+
+	msleep(500);
+	mode = sii5293_get_output_mode();
+	if( mode != sii_output_mode )
+	{
+		printk("[%s], trigger new mode = %d, old mode = %d\n", __FUNCTION__, mode, sii_output_mode);
+		if( mode < CEA_MAX )
+		{
+			sii5293_start_vdin_mode(mode);
+			sii_output_mode = mode;
+		}
+	}
+
+	return ;
+}
+
+static ssize_t vdin_enable_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "sii5293 vdin eanble = %d\n", sii5293_vdin_info.vdin_started);
+}
+
+static ssize_t vdin_enable_store(struct class *class, struct class_attribute *attr,
+									const char *buf, size_t count)
+{
+	int argn;
+	char *p=NULL, *para=NULL, *argv[5] = {NULL,NULL,NULL,NULL,NULL};
+	unsigned int mode = 0, enable=0, height = 0, width = 0, frame_rate = 0, field_flag = 0;
+	char *vmode[10] = {"480i\n","480p\n","576i\n","576p\n","720p50\n","720p\n","1080i\n","1080p\n","1080i50\n","1080p50\n"};
+	int i = 0;
+
+	p = kstrdup(buf, GFP_KERNEL);
+	for( argn=0; argn<4; argn++ )
+	{
+		para = strsep(&p, " ");
+		if( para == NULL )
+			break;
+		argv[argn] = para;
+	}
+
+//	printk("argn = %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\"\n", argn, argv[0], argv[1], argv[2], argv[3], argv[4] );
+	if( !strcmp(argv[0], "0\n") )
+		enable = 0;
+	else if( !strcmp(argv[0], "1\n") )
+		enable = 1;
+	else
+	{
+		for( i=0; i<10; i++ )
+		{
+			if( !strcmp(argv[0], vmode[i]) )
+			{
+				mode = i;
+				enable = 2;
+			}
+		}
+	}
+
+	if( (enable==1) && (argn!=5) && (argn!=1) )
+	{
+		printk("invalid parameters to enable cmd !\n");
+		return count;
+	}
+
+	if( (enable==0) && (sii5293_vdin_info.vdin_started==1) )
+	{
+		sii5293_stop_vdin(&sii5293_vdin_info);
+		printk("sii5293 disable dvin !\n");
+	}
+	else if( (enable==1) && (sii5293_vdin_info.vdin_started==0) )
+	{
+		mode = sii5293_get_output_mode();
+		sii5293_start_vdin_mode(mode);
+		printk("sii5293 enable(1) dvin !\n");
+	}
+	else if( (enable==2) && (sii5293_vdin_info.vdin_started==0) )
+	{
+		
+		switch(mode)
+		{
+			case 0: // 480i
+				mode = CEA_480I60;		break;
+			case 1: // 480p
+				mode = CEA_480P60;		break;
+			case 2: // 576i
+				mode = CEA_576I50;		break;
+			case 3: // 576p
+				mode = CEA_576P50;		break;
+			case 4: // 720p50
+				mode = CEA_720P50;		break;
+			case 5: // 720p60
+			default:
+				mode = CEA_720P60;		break;
+			case 6: // 1080i60
+				mode = CEA_1080I60; 	break;
+			case 7: // 1080p60
+				mode = CEA_1080P60; 	break;
+			case 8: // 1080i50
+				mode = CEA_1080I50; 	break;
+			case 9: // 1080p50
+				mode = CEA_1080P50; 	break;
+		}
+
+		sii5293_start_vdin_mode(mode);
+		printk("sii5293 enable(2) dvin !\n");
+	}
+
+	return count;
+
+}
+
+static ssize_t debug_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "r reg_addr / w reg_addr value / dump reg_start reg_end\n\
+		reg_addr = page_addr|reg_offset\n");
+}
+
+static int sii9293_test_get_id(void)
+{
+	unsigned char high,low;
+
+	high = SiiRegRead(REG_DEV_IDH_RX);
+	low = SiiRegRead(REG_DEV_IDL_RX);
+
+	return ( (high<<8) | low );
+}
+#define MSK__VID_H_RES_BIT8_12		0x1F
+static int sii9293_test_get_h_total(void)
+{
+	unsigned char high,low;
+
+	high = SiiRegRead(RX_A__H_RESH)&MSK__VID_H_RES_BIT8_12;
+	low = SiiRegRead(RX_A__H_RESL);
+
+	return ( (high<<8) | low );
+}
+
+static ssize_t debug_store(struct class *class, struct class_attribute *attr,
+									const char *buf, size_t count)
+{
+	int argn;
+	char *p=NULL, *para=NULL, *argv[4] = {NULL,NULL,NULL,NULL};
+	unsigned int cmd=0, reg_start = 0, reg_end = 0, length = 0, value = 0xff;
+	char i2c_buf[2] = {0,0};
+	int ret = 0;
+
+	p = kstrdup(buf, GFP_KERNEL);
+	for( argn=0; argn<4; argn++ )
+	{
+		para = strsep(&p, " ");
+		if( para == NULL )
+			break;
+		argv[argn] = para;
+	}
+
+//	printk("get para: %s %s %s %s!\n",argv[0],argv[1],argv[2],argv[3]);
+
+	if( !strcmp(argv[0], "r") )
+		cmd = 0;
+	else if( !strcmp(argv[0], "dump") )
+		cmd = 1;
+	else if( !strcmp(argv[0], "w") )
+		cmd = 2;
+	else if( !strncmp(argv[0], "vinfo", strlen("vinfo")) )
+		cmd = 3;
+	else if( !strncmp(argv[0], "tt", strlen("tt")) )
+	{
+		cmd = 4;
+	}
+	else
+	{
+		printk("invalid cmd = %s\n", argv[0]);
+		return count;
+	}
+
+	
+	printk(" cmd = %d - \"%s\"\n", cmd, argv[0]);
+	if( (argn<1) || ((cmd==0)&&argn!=2) || ((cmd==1)&&(argn!=3)) || ((cmd==2)&&(argn!=3)) )
+	{
+		printk("invalid command format!\n");
+		kfree(p);
+		return count;
+	}
+
+	if( cmd == 0 ) // read
+	{
+		reg_start = (unsigned int)simple_strtoul(argv[1],NULL,16);
+		value = SiiRegRead(reg_start);
+		printk("\nsii5293 read reg[0x%x] = 0x%x\n", reg_start, value);
+
+	}
+	else if( cmd == 1 ) // dump
+	{
+		unsigned int i = 0;
+
+		reg_start 	= (unsigned int)simple_strtoul(argv[1],NULL,16);
+		reg_end 	= (unsigned int)simple_strtoul(argv[2],NULL,16);
+		printk("sii5293 dump reg, [ 0x%x, 0x%x] :\n", reg_start, reg_end);
+		
+		for( i=reg_start; i<=reg_end; i++ )
+		{
+			value = SiiRegRead(i);
+			if( i%0x10 == 0 )
+					printk("%.2X:", i);
+			printk(" %.2X",value);
+			if( (i+1)%0x10 == 0 )
+				printk("\n");
+		}
+		printk("\n");
+	}
+	else if( cmd == 2 ) // write
+	{
+		reg_start 	= (unsigned int)simple_strtoul(argv[1],NULL,16);
+		value 		= (unsigned int)simple_strtoul(argv[2],NULL,16); 
+
+		SiiRegWrite(reg_start, value);
+		printk("sii5293 write reg[0x%x] = 0x%x\n", reg_start, value);
+		value = SiiRegRead(reg_start);
+		printk("hdmirx i2c read back reg[0x%x] = 0x%x\n", reg_start, value);
+	}
+	else if( cmd == 3 ) // vinfo
+	{
+		printk("\nbegin dump hdmi-in video info:\n");
+		dump_input_video_info();
+	}
+	else if( cmd == 4 ) // tt, for loop test of 9293 i2c
+	{
+		unsigned int type = 255, count = 0, i = 0, v1 = 0, v2 = 0;
+		unsigned int err1 = 0, err2 = 0, sum = 0, sum_failed = 0;
+
+		type = (unsigned int )simple_strtoul(argv[1], NULL, 10);
+		count = (unsigned int)simple_strtoul(argv[2], NULL, 10);
+
+		printk("9293 i2c stability test: type = %d, count = %d\n", type, count);
+
+		if( type == 0 ) // 0x2/0x3 = 9392
+		{
+			unsigned int i = 0, v1 = 0, v2 = 0;
+			unsigned int err1 = 0, err2 = 0, sum_failed = 0;
+			for( i=0; i<count; i++ )
+			{
+				msleep(2);
+				v1 = sii9293_test_get_id();
+				msleep(2);
+				v2 = sii9293_test_get_h_total();
+				
+				if( v1 != 0x9293 )
+				{
+					err1 ++;
+					printk("sii2ctest, ID failed: [%d], [%d] = 0x%x\n", i, err1, v1);
+				}
+				if( v2 != 0x672 )
+				{
+					err2 ++;
+					printk("sii2ctest, RES_H failed: [%d], [%d] = 0x%x\n", i, err2, v2);
+				}
+
+				printk("sii2ctest, [%d]: err1 = %d, v1 = 0x%x, err2 = %d v2 = 0x%x\n", i, err1, v1, err2, v2);
+			}
+		}
+		else
+			printk("sii2ctest invalid type!\n");
+	}
+
+	kfree(p);
+	return count;
+}
+
+static ssize_t sii5293_input_mode_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	unsigned int mode = 0xff;
+	char hdmi_mode_str[16], mode_str[16] ;
+	unsigned char value;
+
+	value = SiiRegRead(RX_A__AUDP_STAT)&RX_M__AUDP_STAT__HDMI_MODE_ENABLED;
+
+	memset(hdmi_mode_str, 0x00, 16);
+	memset(mode_str, 0x00, 8);
+
+	strcpy(hdmi_mode_str,(value==0)?"DVI:":"HDMI:");
+
+	mode = sii5293_get_output_mode();
+
+	switch(mode)
+	{
+		case CEA_480I60:	strcpy(mode_str, "480i");		break;
+		case CEA_480P60:	strcpy(mode_str, "480p");		break;
+		case CEA_576I50:	strcpy(mode_str, "576i");		break;
+		case CEA_576P50:	strcpy(mode_str, "576p");		break;
+		case CEA_720P60:	strcpy(mode_str, "720p");		break;
+		case CEA_720P50:	strcpy(mode_str, "720p50hz");	break;
+		case CEA_1080I60:	strcpy(mode_str, "1080i");		break;
+		case CEA_1080I50:	strcpy(mode_str, "1080i50hz");	break;
+		case CEA_1080P60:	strcpy(mode_str, "1080p");		break;
+		case CEA_1080P50:	strcpy(mode_str, "1080p50hz");	break;
+		default:			strcpy(mode_str, "invalid");	break;
+	}
+
+	if( strcmp(mode_str, "invalid") != 0 )
+		strcat(hdmi_mode_str, mode_str);
+	else
+		strcpy(hdmi_mode_str, mode_str);
+	return sprintf(buf, "%s\n", hdmi_mode_str);
+}
+
+static void dump_dvin_pinmux(void)
+{
+	printk(" dvin pinmux config:\n\
+				LCD:	%d%d%d%d%d%d%d%d\n\
+				TCON:	%d%d%d%d%d%d%d%d%d%d\n\
+				ENC:	%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d\n\
+				UART:	%d%d%d%d\n\
+				PWM:	%d%d%d%d%d%d\n\
+				VGA:	%d%d\n\
+				DVIN:	%d%d%d%d%d\n",
+				READ_CBUS_REG(PERIPHS_PIN_MUX_0)&1 ,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>1)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>2)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>3)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>4)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>5)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>18)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>19)&1,
+
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>19)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>20)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>21)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>22)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>23)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>24)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>25)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>26)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>27)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_8)>>28)&1,
+
+				READ_CBUS_REG(PERIPHS_PIN_MUX_7)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>1)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>2)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>3)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>4)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>5)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>6)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>7)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>8)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>9)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>10)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>11)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>12)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>13)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>14)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>15)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>16)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>17)&1,
+
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_6)>>20)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_6)>>21)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_6)>>22)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_6)>>23)&1,
+
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_3)>>24)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_3)>>25)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_3)>>26)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>26)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>27)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_7)>>28)&1,
+
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>20)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>21)&1,
+
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>6)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>7)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>8)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>9)&1,
+				(READ_CBUS_REG(PERIPHS_PIN_MUX_0)>>10)&1
+				);
+}
+
+static ssize_t pinmux_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	dump_dvin_pinmux();
+	return sprintf(buf, "dump pinmux end !!! \n");
+}
+
+extern void enable_vdin_pinmux(void);
+static ssize_t pinmux_store(struct class *class, struct class_attribute *attr,
+									const char *buf, size_t count)
+{
+	unsigned char enable = 0;
+
+	enable = (unsigned char)simple_strtoul(buf, NULL, 0);
+
+	enable_vdin_pinmux();
+
+	printk("enable vdin pinmux GPIODV_0 ~ GPIODV_29 !\n");
+
+	return count;
+}
+
+static CLASS_ATTR(vdin_enable, S_IRUGO | S_IWUGO, vdin_enable_show, vdin_enable_store);
+static CLASS_ATTR(debug, S_IRUGO | S_IWUGO, debug_show, debug_store);
+//static CLASS_ATTR(pinmux, S_IRUGO | S_IWUGO, pinmux_show, pinmux_store);
+static CLASS_ATTR(input_mode, S_IRUGO, sii5293_input_mode_show, NULL);
+
+static int aml_sii5293_create_attrs(struct class *cls)
+{
+	int ret = 0;
+
+	if( cls == NULL )
+		return 1;
+
+	ret = class_create_file(cls, &class_attr_vdin_enable);	
+	ret |= class_create_file(cls, &class_attr_debug);
+//	ret |= class_create_file(cls, &class_attr_pinmux);
+	ret |= class_create_file(cls, &class_attr_input_mode);
+
+	return ret;
+}
+
+static void aml_sii5293_remove_attrs(struct class *cls)
+{
+	if( cls == NULL )
+		return ;
+
+	class_remove_file(cls, &class_attr_vdin_enable);	
+	class_remove_file(cls, &class_attr_debug);
+//	class_remove_file(cls, &class_attr_pinmux);
+	class_remove_file(cls, &class_attr_input_mode);
+
+	return ;
+}
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii5293 platform-driver
+
+#ifdef CONFIG_USE_OF
+static int sii5293_get_of_data(struct device_node *pnode)
+{
+	struct device_node *sii5293_node = pnode;
+//	struct i2c_board_info board_info;
+//	struct i2c_adapter *adapter;
+	unsigned int i2c_index;
+	
+	const char *str;
+	int ret = 0;
+
+// for i2c bus
+	ret = of_property_read_string(sii5293_node, "i2c_bus", &str);
+	if (ret)
+	{
+		printk("[%s]: faild to get i2c_bus str!\n", __FUNCTION__);
+		return -1;
+	}
+	else
+	{
+		if (!strncmp(str, "i2c_bus_ao", 9))
+			i2c_index = AML_I2C_MASTER_AO;
+		else if (!strncmp(str, "i2c_bus_a", 9))
+			i2c_index = AML_I2C_MASTER_A;
+		else if (!strncmp(str, "i2c_bus_b", 9))
+			i2c_index = AML_I2C_MASTER_B;
+		else if (!strncmp(str, "i2c_bus_c", 9))
+			i2c_index = AML_I2C_MASTER_C;
+		else if (!strncmp(str, "i2c_bus_d", 9))
+			i2c_index = AML_I2C_MASTER_D;
+		else
+			return -1; 
+	}
+	
+	devinfo->config.i2c_bus_index = i2c_index;
+
+// for gpio_reset
+	ret = of_property_read_string(sii5293_node, "gpio_reset", &str);
+	if (ret)
+	{
+		printk("[%s]: faild to get gpio_rst!\n", __FUNCTION__);
+		return -2;
+	}
+
+	ret = amlogic_gpio_name_map_num(str);
+	if (ret < 0)
+	{
+		printk("[%s]: faild to map gpio_rst !\n", __FUNCTION__);
+	}
+	else
+		devinfo->config.gpio_reset = ret;
+
+// for irq
+	ret = of_property_read_string(sii5293_node,"gpio_intr",&str);
+	if(ret)
+	{
+		printk("[%s]: failed to get INT!\n", __FUNCTION__);
+		return -3;
+	}
+
+	ret = amlogic_gpio_name_map_num(str);
+	if(ret < 0 )
+	{
+		printk("[%s]: failed to map gpio_intr!\n", __FUNCTION__);
+	}
+	else
+		devinfo->config.gpio_intr = ret;
+
+#if 0
+	memset(&board_info, 0x0, sizeof(board_info));
+	strncpy(board_info.type, HDMIRX_SII9233A_NAME, I2C_NAME_SIZE);
+	adapter = i2c_get_adapter(i2c_index);
+	board_info.addr = SII9233A_I2C_ADDR;
+	board_info.platform_data = &hdmirx_info;
+
+	hdmirx_info.i2c_client = i2c_new_device(adapter, &board_info);
+	printk("[%s] new i2c device i2c_client = 0x%x\n",hdmirx_info.i2c_client);
+#endif
+	printk("sii5293 get i2c_idx = %d, gpio_reset = %d, gpio_irq = %d\n", 
+		devinfo->config.i2c_bus_index, devinfo->config.gpio_reset, devinfo->config.gpio_intr);
+	return 0;
+}
+#endif
+
+static int sii5293_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	devinfo->config.i2c_bus_index = 0xff;
+	devinfo->config.gpio_reset = 0;
+	devinfo->config.gpio_intr = 0;
+
+#ifdef CONFIG_USE_OF
+	sii5293_get_of_data(pdev->dev.of_node);
+#endif
+
+	//amlogic_gpio_request(hdmirx_info.gpio_reset, HDMIRX_SII9233A_NAME);
+
+	ret = sii5293_register_tvin_frontend(&(sii5293_vdin_info.tvin_frontend));
+	if( ret < 0 )
+	{
+		printk("[%s] register tvin frontend failed !\n", __FUNCTION__);
+	}
+
+	return ret;
+}
+
+static int sii5293_remove(struct platform_device *pdev)
+{
+	return 0;	
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id sii5293_dt_match[] = {
+	{
+		.compatible			= "amlogic,sii9293",
+	},
+};
+#endif
+
+static struct platform_driver sii5293_driver = 
+{
+	.probe		= sii5293_probe,
+	.remove 	= sii5293_remove,
+	.driver 	= {
+					.name 				= MHL_DEVICE_NAME,
+					.owner				= THIS_MODULE,
+#ifdef CONFIG_USE_OF
+					.of_match_table 	= sii5293_dt_match, 
+#endif
+					}
+};
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*
+* modelue init interface 
+*/
+static int __init SiiMhlInit(void)
+{
+    int32_t	ret = -1;
+	pr_info("sii5293, %s driver starting!\n", MHL_DRIVER_NAME);
+    sprintf(BUILT_TIME,"Build: %s", __TIME__"-"__DATE__);
+    pr_info("sii5293, Version: %s, %s \n",strVersion,BUILT_TIME);
+    /* register chrdev */
+    pr_info("sii5293, register_chrdev %s\n", DEVNAME);
+
+    devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);
+    if (NULL == devinfo)
+    {
+        pr_info("sii5293, Out of memory!\n");
+        return ret;
+    }
+    devinfo->mhl = NULL;
+
+    ret = alloc_chrdev_region(&devinfo->devnum,
+                        0, NUMBER_OF_DEVS,
+                        DEVNAME);
+    if (ret) {
+    	pr_info("sii5293, register_chrdev %s failed, error code: %d\n",
+    					MHL_DRIVER_NAME, ret);
+        goto free_devinfo;
+    }
+
+    devinfo->cdev = cdev_alloc();
+    devinfo->cdev->owner = THIS_MODULE;
+    ret = cdev_add(devinfo->cdev, devinfo->devnum, MHL_DRIVER_MINOR_MAX);
+    if (ret) {
+    	pr_info("sii5293, cdev_add %s failed %d\n", MHL_DRIVER_NAME, ret);
+        goto free_chrdev;
+    }
+
+    ret = mhl_dev_add(devinfo);
+    if (ret) {
+        goto free_cdev;
+    }
+
+    devinfo->dev_class = class_create(THIS_MODULE, CLASS_NAME);
+    if (IS_ERR(devinfo->dev_class)) {
+    	pr_info("sii5293, class_create failed %d\n", ret);
+        ret = PTR_ERR(devinfo->dev_class);
+        goto free_mhl_cdev;
+    }
+
+    //devinfo->dev_class->dev_attrs = driver_attribs;
+
+    devinfo->device  = device_create(devinfo->dev_class, NULL,
+    									 devinfo->devnum,  NULL,
+    									 "%s", DEVNAME);
+    if (IS_ERR(devinfo->device)) {
+    	pr_info("sii5293, class_device_create failed %s %d\n", DEVNAME, ret);
+        ret = PTR_ERR(devinfo->device);
+        goto free_class;
+    }
+
+    // add sii5293 platform-driver to get dt resources.
+    ret = platform_driver_register(&sii5293_driver);
+	if (ret)
+	{
+        pr_info("sii5293, failed to register sii5293 module\n");
+        goto free_class;
+    }
+
+
+    ret = sysfs_create_group(&devinfo->device->kobj, &sii5293_attr_group);
+    if (ret) {
+        pr_info("sii5293, failed to create root attribute group - continuing without\n");
+        goto free_dev;
+    }
+
+#ifdef DEBUG
+    ret = sysfs_create_group(&devinfo->device->kobj, &sii5293_debug_attr_group);
+    if (ret) {
+        pr_info("sii5293, failed to create debug attribute group - continuing without\n");
+        goto free_dev;
+    }
+#endif
+
+	ret = aml_sii5293_create_attrs(devinfo->dev_class);
+	if(ret)
+	{
+		pr_info("sii5293, [%s] failed(%d) to create aml sii5293 attrs!\n", __FUNCTION__, ret);
+		goto free_dev;
+	}
+
+
+    ret = mhl_dev_init(devinfo);
+    if (ret) {
+        goto free_dev;
+    }
+
+    ret = StartMhlTxDevice();
+    if(ret == 0) {
+        printk(KERN_NOTICE"sii5293 mhldrv initialized successfully !\n");
+    	return 0;
+    } else {
+    	// Transmitter startup failed so fail the driver load.
+    	printk(KERN_NOTICE"sii5293 mhldrv initialized failed !\n");
+    	mhl_dev_exit(devinfo);
+    }
+
+free_dev:
+    if (devinfo->device)
+    {
+    	aml_sii5293_remove_attrs(devinfo->dev_class);
+#ifdef DEBUG
+        sysfs_remove_group(&devinfo->device->kobj, &sii5293_debug_attr_group);
+#endif
+        sysfs_remove_group(&devinfo->device->kobj, &sii5293_attr_group);
+        device_unregister(devinfo->device);
+        devinfo->device = NULL;
+    }
+    device_destroy(devinfo->dev_class, devinfo->devnum);
+
+free_class:
+	class_destroy(devinfo->dev_class);
+
+free_mhl_cdev:
+    cdev_del(devinfo->mhl->cdev);
+
+free_cdev:
+	cdev_del(devinfo->cdev);
+
+free_chrdev:
+	unregister_chrdev_region(devinfo->devnum, MHL_DRIVER_MINOR_MAX);
+
+free_devinfo:
+    if (devinfo)
+    {
+        if (devinfo->mhl)
+            kfree(devinfo->mhl);
+        kfree(devinfo);
+    }
+    devinfo = NULL;
+    printk("sii5293 [%s] something wrong !\n", __FUNCTION__);
+	return ret;
+}
+/*
+* modelue remove interface 
+*/
+static void __exit SiiMhlExit(void)
+{
+	pr_info("sii5293, %s driver exiting!\n", MHL_DRIVER_NAME);
+	StopMhlTxDevice();
+    mhl_dev_exit(devinfo);
+    if (devinfo->device)
+    {
+    	aml_sii5293_remove_attrs(devinfo->dev_class);
+#ifdef DEBUG
+        sysfs_remove_group(&devinfo->device->kobj, &sii5293_debug_attr_group);
+#endif
+        sysfs_remove_group(&devinfo->device->kobj, &sii5293_attr_group);
+        device_unregister(devinfo->device);
+        devinfo->device = NULL;
+    }
+	device_destroy(devinfo->dev_class, devinfo->devnum);
+    class_destroy(devinfo->dev_class);
+    cdev_del(devinfo->cdev);
+    unregister_chrdev_region(devinfo->devnum, MHL_DRIVER_MINOR_MAX);
+    if (devinfo)
+    {
+        if (devinfo->mhl)
+            kfree(devinfo->mhl);
+        kfree(devinfo);
+    }
+    devinfo = NULL;
+	pr_info("sii5293, %s driver successfully exited!\n", MHL_DRIVER_NAME);
+}
+
+module_init(SiiMhlInit);
+module_exit(SiiMhlExit);
+
+int send_sii5293_uevent(struct device *device, const char *event_cat,
+			const char *event_type, const char *event_data)
+{
+	int retval = 0;
+	char event_string[MAX_EVENT_STRING_LEN];
+	char *envp[] = {event_string, NULL};
+
+	if ((NULL == event_cat) || (NULL == event_type)) 
+	{
+		pr_info("sii5293, Invalid parameters\n");
+		retval = -EINVAL;
+        return retval;
+	}
+
+
+	scnprintf(event_string, MAX_EVENT_STRING_LEN-1,
+		"%s={\"event\":\"%s\",\"data\":%s}",
+		event_cat, event_type, (NULL != event_data) ? event_data : "null");
+
+
+	kobject_uevent_env(&device->kobj, KOBJ_CHANGE, envp);
+
+	return retval;
+}
+
+
+void SiiConnectionStateNotify(bool_t connect)
+{
+    #define MAX_REPORT_DATA_STRING_SIZE 20
+    SourceConnection_t new_state;
+    char str[MAX_REPORT_DATA_STRING_SIZE];
+
+    if (connect)
+    {
+        if (SiiMhlRxCbusConnected())
+        {
+            new_state = MHL_CONN;
+            scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "mhl source connected");
+        }else
+        {
+            new_state = HDMI_CONN;
+            scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "hdmi source connected");
+        }
+    }else
+    {
+        new_state = NO_CONN;
+        scnprintf(str,	MAX_REPORT_DATA_STRING_SIZE, "no source connected");
+    }
+
+    if (new_state != gDriverContext.connection_state)
+    {
+        gDriverContext.connection_state = new_state;
+        sysfs_notify(&devinfo->device->kobj, NULL, "device_connection_state");
+        send_sii5293_uevent(devinfo->device, DEVICE_EVENT, DEV_CONNECTION_CHANGE_EVENT, str);
+    }
+}
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Silicon Image <http://www.siliconimage.com>");
+MODULE_DESCRIPTION("Silicon Image MHL/HDMI Receiver driver");
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/sii5293_interface.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/sii5293_interface.c
new file mode 100755
index 000000000000..15482aac3666
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/sii5293_interface.c
@@ -0,0 +1,305 @@
+
+#include "mhl_linuxdrv.h"
+#include "../../driver/cra_drv/si_cra.h"
+
+#define GET_VIDEO_INFO_FROM_TABLE
+
+#ifndef GET_VIDEO_INFO_FROM_TABLE
+
+#endif
+
+
+#ifdef GET_VIDEO_INFO_FROM_TABLE
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii5293 output signal horizontal parameters
+
+int sii_get_h_active(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].Active.H;
+}
+
+int sii_get_h_total(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].Total.H;
+}
+
+int sii_get_hs_width(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].SyncWidth.H;
+}
+
+int sii_get_hs_frontporch(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].SyncOffset.H;
+}
+
+int sii_get_hs_backporch(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].Blank.H - VideoModeTable[index].SyncOffset.H - VideoModeTable[index].SyncWidth.H;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii5293 output signal vertical parameters
+
+int sii_get_v_active(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].Active.V;
+}
+
+int sii_get_v_total(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].Total.V;
+}
+
+int sii_get_vs_width(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].SyncWidth.V;
+}
+
+int sii_get_vs_frontporch(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].SyncOffset.V;
+}
+
+int sii_get_vs_backporch(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].Blank.V - VideoModeTable[index].SyncOffset.V - VideoModeTable[index].SyncWidth.V;
+}
+
+int sii_get_vs_to_de(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].Blank.V - VideoModeTable[index].SyncOffset.V;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii5293 output signal clock parameters
+
+int sii_get_pixel_clock(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].PixClk*10000;
+}
+
+int sii_get_h_freq(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].HFreq*1000;
+}
+
+int sii_get_v_freq(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].VFreq;
+}
+
+int sii_get_interlaced(void)
+{
+	unsigned char index = 0;
+
+	index = gDriverContext.input_video_mode & 0x7f;
+	if ( (index==0) || (index>=NMB_OF_CEA861_VIDEO_MODES) )
+		return -1;
+
+	return VideoModeTable[index].Interlaced;
+}
+
+#else
+// !!! read h/v/sync info from 5293 registers, but the value seems not stable.
+
+// offset definitions for registers.
+#define MSK__VID_DE_PIXEL_BIT8_11	0x0F
+#define MSK__VID_H_RES_BIT8_12		0x1F
+#define MSK__VID_HS_WIDTH_BIT8_9	0x03
+#define RX_A__VID_HFP2 				0x05a
+#define MSK__VID_H_FP_BIT8_9		0x03
+#define MSK__VID_DE_LINE_BIT8_10	0x07
+#define MSK__VID_V_RES_BIT8_10		0x07
+#define MSK__VID_VS_AVT_BIT0_5		0x3F
+#define MSK__VID_V_FP_BIT0_5		0x3F
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii5293 output signal horizontal parameters
+
+int sii_get_h_active(void)
+{
+	unsigned char high,low;
+
+	high = SiiRegRead(RX_A__DE_PIX2)&MSK__VID_DE_PIXEL_BIT8_11;
+	low = SiiRegRead(RX_A__DE_PIX1);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_h_total(void)
+{
+	unsigned char high,low;
+
+	high = SiiRegRead(RX_A__H_RESH)&MSK__VID_H_RES_BIT8_12;
+	low = SiiRegRead(RX_A__H_RESL);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_hs_width(void)
+{
+	unsigned char high,low;
+
+	high = SiiRegRead(RX_A__VID_HAW2)&MSK__VID_HS_WIDTH_BIT8_9;
+	low = SiiRegRead(RX_A__VID_HAW1);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_hs_frontporch(void)
+{
+	unsigned char high,low;
+
+	high = SiiRegRead(RX_A__VID_HFP2)&MSK__VID_H_FP_BIT8_9;
+	low = SiiRegRead(RX_A__VID_HFP);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_hs_backporch(void)
+{
+	int backporch = 0;
+
+	backporch = sii_get_h_total() - sii_get_h_active() - sii_get_hs_frontporch() - sii_get_hs_width();
+
+	return backporch;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii5293 output signal vertical parameters
+
+int sii_get_v_active(void)
+{
+	unsigned char high,low;
+
+	high = SiiRegRead(RX_A__DE_LINE2)&MSK__VID_DE_LINE_BIT8_10;
+	low = SiiRegRead(RX_A__DE_LINE1);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_v_total(void)
+{
+	unsigned char high,low;
+
+	high = SiiRegRead(RX_A__V_RESH)&MSK__VID_V_RES_BIT8_10;
+	low = SiiRegRead(RX_A__V_RESL);
+
+	return ( (high<<8) | low );
+}
+
+int sii_get_vs_width(void)
+{
+	return 0;
+}
+
+int sii_get_vs_frontporch(void)
+{
+	unsigned char low;
+
+	low = SiiRegRead(RX_A__VID_VFP)&MSK__VID_V_FP_BIT0_5;
+
+	return low;
+}
+
+int sii_get_vs_backporch(void)
+{
+	return 0;
+}
+
+int sii_get_vs_to_de(void)
+{
+	unsigned char low;
+
+	low = SiiRegRead(RX_A__VTAVL)&MSK__VID_VS_AVT_BIT0_5;
+
+	return low;
+}
+
+#endif
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/sii5293_interface.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/sii5293_interface.h
new file mode 100755
index 000000000000..f61bcd4a8e7c
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/sii5293_interface.h
@@ -0,0 +1,32 @@
+#ifndef __SII5293_INTERFACE_H__
+#define __SII5293_INTERFACE_H__
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii5293 output signal horizontal parameters
+
+int sii_get_h_active(void);
+int sii_get_h_total(void);
+int sii_get_hs_width(void);
+int sii_get_hs_frontporch(void);
+int sii_get_hs_backporch(void);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii5293 output signal vertical parameters
+
+int sii_get_v_active(void);
+int sii_get_v_total(void);
+int sii_get_vs_width(void);
+int sii_get_vs_frontporch(void);
+int sii_get_vs_backporch(void);
+int sii_get_vs_to_de(void);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+// sii5293 output signal clock parameters
+
+int sii_get_pixel_clock(void);
+int sii_get_h_freq(void);
+int sii_get_v_freq(void);
+int sii_get_interlaced(void);
+
+#endif
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/vdin_interface.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/vdin_interface.c
new file mode 100755
index 000000000000..94b08fb44349
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/vdin_interface.c
@@ -0,0 +1,461 @@
+
+#include <mach/am_regs.h>
+#include <linux/amlogic/tvin/tvin_v4l2.h>
+#include "../../../../../../../../../hardware/tvin/tvin_frontend.h"
+#include "mhl_linuxdrv.h"
+#include "../../driver/cra_drv/si_cra.h"
+#include "sii5293_interface.h"
+
+extern int start_tvin_service(int no ,vdin_parm_t *para);
+extern int stop_tvin_service(int no);
+extern void set_invert_top_bot(bool invert_flag);
+
+void enable_vdin_pinmux(void)
+{
+
+	// disable LCD pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_0, READ_CBUS_REG(PERIPHS_PIN_MUX_0) & 
+	 ( ~(1       | // LCD_R 2/3/4/5/6/7
+		(1 << 1)  | // LCD_R 0/1
+		(1 << 2)  | // LCD_G 2/3/4/5/6/7
+		(1 << 3)  | // LCD_G 0/1
+		(1 << 4)  | // LCD_B 2/3/4/5/6/7
+		(1 << 5)  | // LCD_B 0/1
+		(1 << 18) | // LCD_HS
+		(1 << 19)) )    // LCD_VS
+		);
+
+	// disable TCON pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_8, READ_CBUS_REG(PERIPHS_PIN_MUX_8) & 
+	 ( ~((1 << 19) | // TCON_VCOM
+		(1 << 20) | // TCON_CPH3
+		(1 << 21) | // TCON_CPH2
+		(1 << 22) | // TCON_CPH1
+		(1 << 23) | // TCON_STH1
+		(1 << 24) | // TCON_STV1
+		(1 << 25) | // TCON_CPV
+		(1 << 26) | // TCON_VCOM
+		(1 << 27) | // TCON_OEV
+		(1 << 28)) )   // TCON_OEH
+		);
+
+	// disable ENC pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_7, READ_CBUS_REG(PERIPHS_PIN_MUX_7) & 
+	 ( ~(1     | // ENC_0
+		(1 << 1)  | // ENC_1
+		(1 << 2)  | // ENC_2
+		(1 << 3)  | // ENC_3
+		(1 << 4)  | // ENC_4
+		(1 << 5)  | // ENC_5
+		(1 << 6)  | // ENC_6
+		(1 << 7)  | // ENC_7
+		(1 << 8)  | // ENC_8
+		(1 << 9)  | // ENC_9
+		(1 << 10) | // ENC_10
+		(1 << 11) | // ENC_11
+		(1 << 12) | // ENC_12
+		(1 << 13) | // ENC_13
+		(1 << 14) | // ENC_14
+		(1 << 15) | // ENC_15
+		(1 << 16) | // ENC_16(eNet_0)
+		(1 << 17)) )    // ENC_17(eNet_1)
+		);
+
+	// disable PWM pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_3, READ_CBUS_REG(PERIPHS_PIN_MUX_3) & 
+	 ( ~((1 << 24) | // PWM_C
+		(1 << 25) | // PWM_C
+		(1 << 26)))    // PWM_D
+		);
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_7, READ_CBUS_REG(PERIPHS_PIN_MUX_7) & 
+	 ( ~((1 << 26) | // PWM_VS
+		(1 << 27) | // PWM_VS
+		(1 << 28)))    // PWM_VS
+		);
+
+	// disable VGA pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_0, READ_CBUS_REG(PERIPHS_PIN_MUX_0) & 
+	 ( ~((1 << 20) | // VGA_HS
+		(1 << 21)))    // VGA_VS
+		);
+
+	// enable DVIN pinmux
+	WRITE_CBUS_REG(PERIPHS_PIN_MUX_0, READ_CBUS_REG(PERIPHS_PIN_MUX_0) | 
+	 ( (1 << 6)  | // DVIN R/G/B 0/1/2/3/4/5/6/7
+		(1 << 7)  | // DVIN_CLK
+		(1 << 8)  | // DVIN_HS
+		(1 << 9)  | // DVIN_VS
+		(1 << 10))    // DVIN_DE
+		);
+}
+
+static int sii5293_tvin_support(struct tvin_frontend_s *fe, enum tvin_port_e port)
+{
+	if(port == TVIN_PORT_DVIN0)
+		return 0;
+	else
+		return -1;
+}
+static int sii5293_tvin_open(tvin_frontend_t *fe, enum tvin_port_e port)
+{
+	sii5293_vdin *devp = container_of(fe,sii5293_vdin,tvin_frontend);
+
+	/*copy the vdin_parm_s to local device parameter*/
+	if( !memcpy(&devp->vdin_parm,fe->private_data,sizeof(vdin_parm_t)) )
+	{
+		printk("[%s] copy vdin parm error.\n",__func__);
+	}
+
+	enable_vdin_pinmux();
+
+	WRITE_MPEG_REG_BITS(VDIN_ASFIFO_CTRL2, 0x39, 2, 6); 
+
+	return 0;
+}
+
+static void sii5293_tvin_close(struct tvin_frontend_s *fe)
+{
+	return ;          
+}
+static void sii5293_tvin_start(struct tvin_frontend_s *fe, enum tvin_sig_fmt_e fmt)
+{
+	return ;
+}
+static void sii5293_tvin_stop(struct tvin_frontend_s *fe, enum tvin_port_e port)
+{
+	return ;      
+}
+static int sii5293_tvin_isr(struct tvin_frontend_s *fe, unsigned int hcnt64)
+{
+	return 0;
+}
+
+static struct tvin_decoder_ops_s sii5293_tvin_dec_ops = {
+				.support 		= sii5293_tvin_support,
+				.open 			= sii5293_tvin_open,
+				.close 			= sii5293_tvin_close,
+				.start  		= sii5293_tvin_start,
+				.stop  			= sii5293_tvin_stop,
+				.decode_isr 	= sii5293_tvin_isr, 
+};
+
+static void sii5293_tvin_get_sig_propery(struct tvin_frontend_s *fe, struct tvin_sig_property_s *prop)
+{
+	sii5293_vdin *devp = container_of(fe,sii5293_vdin,tvin_frontend);
+
+	prop->color_format = TVIN_RGB444;
+	prop->dest_cfmt = TVIN_YUV422;
+	if( (devp->vdin_parm.h_active==1440) && 
+	  ((devp->vdin_parm.v_active==576)||(devp->vdin_parm.v_active==480)) )
+	  prop->decimation_ratio = 1;
+	else 
+	  prop->decimation_ratio = 0;
+
+	return ;
+}
+
+static struct tvin_state_machine_ops_s sii5293_tvin_sm_ops = {
+		.get_sig_propery = sii5293_tvin_get_sig_propery,
+};
+
+int sii5293_register_tvin_frontend(struct tvin_frontend_s *frontend)
+{
+	int ret = 0;
+
+	ret = tvin_frontend_init(frontend, &sii5293_tvin_dec_ops, &sii5293_tvin_sm_ops, 0);
+	if( ret != 0 )
+	{
+		printk("[%s] init tvin frontend failed = %d\n", __FUNCTION__, ret);
+		return -1;
+	}
+
+	ret = tvin_reg_frontend(frontend);
+	if( ret != 0 )
+	{
+		printk("[%s] register tv in frontend failed = %d\n", __FUNCTION__, ret);
+		return -2;
+	}
+
+	return 0;
+}
+
+void sii5293_config_dvin (unsigned long hs_pol_inv,             // Invert HS polarity, for HW regards HS active high.
+						unsigned long vs_pol_inv,             // Invert VS polarity, for HW regards VS active high.
+						unsigned long de_pol_inv,             // Invert DE polarity, for HW regards DE active high.
+						unsigned long field_pol_inv,          // Invert FIELD polarity, for HW regards odd field when high.
+						unsigned long ext_field_sel,          // FIELD source select:
+																		  // 1=Use external FIELD signal, ignore internal FIELD detection result;
+																		  // 0=Use internal FIELD detection result, ignore external input FIELD signal.
+						unsigned long de_mode,                // DE mode control:
+																		  // 0=Ignore input DE signal, use internal detection to to determine active pixel;
+																		  // 1=Rsrv;
+																		  // 2=During internal detected active region, if input DE goes low, replace input data with the last good data;
+																		  // 3=Active region is determined by input DE, no internal detection.
+						unsigned long data_comp_map,          // Map input data to form YCbCr.
+																		  // Use 0 if input is YCbCr;
+																		  // Use 1 if input is YCrCb;
+																		  // Use 2 if input is CbCrY;
+																		  // Use 3 if input is CbYCr;
+																		  // Use 4 if input is CrYCb;
+																		  // Use 5 if input is CrCbY;
+																		  // 6,7=Rsrv.
+						unsigned long mode_422to444,          // 422 to 444 conversion control:
+																		  // 0=No convertion; 1=Rsrv;
+																		  // 2=Convert 422 to 444, use previous C value;
+																		  // 3=Convert 422 to 444, use average C value.
+						unsigned long dvin_clk_inv,           // Invert dvin_clk_in for ease of data capture.
+						unsigned long vs_hs_tim_ctrl,         // Controls which edge of HS/VS (post polarity control) the active pixel/line is related:
+																		  // Bit 0: HS and active pixel relation.
+																		  //  0=Start of active pixel is counted from the rising edge of HS;
+																		  //  1=Start of active pixel is counted from the falling edge of HS;
+																		  // Bit 1: VS and active line relation.
+																		  //  0=Start of active line is counted from the rising edge of VS;
+																		  //  1=Start of active line is counted from the falling edge of VS.
+						unsigned long hs_lead_vs_odd_min,     // For internal FIELD detection:
+																		  // Minimum clock cycles allowed for HS active edge to lead before VS active edge in odd field. Failing it the field is even.
+						unsigned long hs_lead_vs_odd_max,     // For internal FIELD detection:
+																		  // Maximum clock cycles allowed for HS active edge to lead before VS active edge in odd field. Failing it the field is even.
+						unsigned long active_start_pix_fe,    // Number of clock cycles between HS active edge to first active pixel, in even field.
+						unsigned long active_start_pix_fo,    // Number of clock cycles between HS active edge to first active pixel, in odd field.
+						unsigned long active_start_line_fe,   // Number of clock cycles between VS active edge to first active line, in even field.
+						unsigned long active_start_line_fo,   // Number of clock cycles between VS active edge to first active line, in odd field.
+						unsigned long line_width,             // Number_of_pixels_per_line
+						unsigned long field_height)           // Number_of_lines_per_field
+{
+	unsigned long data32;
+
+//	printk("[%s] config pol_inv: hs = %d, vs = %d, de = %d, field = %d, clk = %d\n",__FUNCTION__, hs_pol_inv,vs_pol_inv,de_pol_inv,field_pol_inv,dvin_clk_inv);
+//	printk("[%s]: %lu %lu %lu %lu.\n",  __FUNCTION__, active_start_pix_fe, active_start_line_fe,  line_width, field_height);  
+	// Program reg DVIN_CTRL_STAT: disable DVIN
+	WRITE_MPEG_REG(DVIN_CTRL_STAT, 0);
+
+	// Program reg DVIN_FRONT_END_CTRL
+	data32 = 0;
+	data32 |= (hs_pol_inv       & 0x1)  << 0;
+	data32 |= (vs_pol_inv       & 0x1)  << 1;
+	data32 |= (de_pol_inv       & 0x1)  << 2;
+	data32 |= (field_pol_inv    & 0x1)  << 3;
+	data32 |= (ext_field_sel    & 0x1)  << 4;
+	data32 |= (de_mode          & 0x3)  << 5;
+	data32 |= (mode_422to444    & 0x3)  << 7;
+	data32 |= (dvin_clk_inv     & 0x1)  << 9;
+	data32 |= (vs_hs_tim_ctrl   & 0x3)  << 10;
+	WRITE_MPEG_REG(DVIN_FRONT_END_CTRL, data32);
+
+	// Program reg DVIN_HS_LEAD_VS_ODD
+	data32 = 0;
+	data32 |= (hs_lead_vs_odd_min & 0xfff) << 0;
+	data32 |= (hs_lead_vs_odd_max & 0xfff) << 16;
+	WRITE_MPEG_REG(DVIN_HS_LEAD_VS_ODD, data32);
+
+	// Program reg DVIN_ACTIVE_START_PIX
+	data32 = 0;
+	data32 |= (active_start_pix_fe & 0xfff) << 0;
+	data32 |= (active_start_pix_fo & 0xfff) << 16;
+	WRITE_MPEG_REG(DVIN_ACTIVE_START_PIX, data32);
+
+	// Program reg DVIN_ACTIVE_START_LINE
+	data32 = 0;
+	data32 |= (active_start_line_fe & 0xfff) << 0;
+	data32 |= (active_start_line_fo & 0xfff) << 16;
+	WRITE_MPEG_REG(DVIN_ACTIVE_START_LINE, data32);
+
+	// Program reg DVIN_DISPLAY_SIZE
+	data32 = 0;
+	data32 |= ((line_width-1)   & 0xfff) << 0;
+	data32 |= ((field_height-1) & 0xfff) << 16;
+	WRITE_MPEG_REG(DVIN_DISPLAY_SIZE, data32);
+
+	// Program reg DVIN_CTRL_STAT, and enable DVIN
+	data32 = 0;
+	data32 |= 1                     << 0;
+	data32 |= (data_comp_map & 0x7) << 1;
+	WRITE_MPEG_REG(DVIN_CTRL_STAT, data32);
+//    printk("[%s] end !\n", __FUNCTION__);
+} /* config_dvin */
+
+void sii5293_stop_vdin(sii5293_vdin *info)
+{
+	if( info->vdin_started == 0 )
+	  return ;
+
+	stop_tvin_service(0);
+	set_invert_top_bot(false);
+	info->vdin_started = 0;
+	printk("%s: stop vdin\n", __FUNCTION__);
+	return ;
+}
+
+void sii5293_start_vdin(sii5293_vdin *info, int width, int height, int frame_rate, int field_flag)
+{
+	vdin_parm_t para;
+
+	printk("[%s]-%.3d, width = %d, height = %d, frame_rate = %d, field_flag = %d\n",
+							__FUNCTION__, __LINE__, width,height,frame_rate,field_flag);
+
+	//    printk("[%s]-%.3d, info = 0x%x\n",__FUNCTION__, __LINE__, info);
+	if(info->vdin_started)
+	{
+		//printk("[%s]-%.3d, info->vdin_info = 0x%x\n",__FUNCTION__, __LINE__, &(info->vdin_info) );
+		if( (info->vdin_info.cur_width != width) || (info->vdin_info.cur_height != height) ||
+											(info->vdin_info.cur_frame_rate != frame_rate) )
+		{
+			stop_tvin_service(0);
+			info->vdin_started=0;
+			printk("%s: stop vdin\n", __func__);
+		}
+	}
+
+	if( (info->vdin_started==0) && (width>0) && (height>0) && (frame_rate>0) )
+	{
+		int start_pix=138, start_line_o=22, start_line_e=23, h_total=1728, v_total=625;
+
+		info->vdin_info.cur_width = width;
+		info->vdin_info.cur_height = height;
+		info->vdin_info.cur_frame_rate = frame_rate;
+
+		if(field_flag && height <= 576 )
+		{
+			// for rgb 576i signal from 9233, it's 720/864, not 1440/1728
+			if( (width==1440)&&(height==576) )
+			{
+				start_pix = 138;
+				start_line_o = 22;
+				start_line_e = 23;
+				h_total = 1728;
+				v_total = 625;
+			}
+			// for rgb 480i signal from 9233, it's 720/858, not 1440/1716
+			else if( (width==1440)&&(height==480) )
+			{
+				start_pix = 114;
+				start_line_o = 18;
+				start_line_e = 19;
+				h_total = 1716;
+				v_total = 525;
+			}
+			sii5293_config_dvin(1, //hs_pol_inv,          
+						1, //vs_pol_inv,          
+						0, //de_pol_inv,          
+						0, //field_pol_inv,       
+						0, //ext_field_sel,       
+						3, //de_mode,             
+						0, //data_comp_map,       
+						0, //mode_422to444,       
+						0, //dvin_clk_inv,        
+						0, //vs_hs_tim_ctrl,      
+						400, //hs_lead_vs_odd_min,  
+						1200, //hs_lead_vs_odd_max,  
+						start_pix,//sii_get_hs_backporch()*2,//0xdc, //active_start_pix_fe, 
+						start_pix,//sii_get_hs_backporch()*2,//0xdc, //active_start_pix_fo, 
+						start_line_e,//sii_get_vs_backporch(), //0x19, //active_start_line_fe,
+						start_line_o,//sii_get_vs_backporch(),//0x19, //active_start_line_fo,
+						h_total,//sii_get_h_total(), //0x672, //line_width,          
+						v_total//sii_get_v_total()*2 //0x2ee //field_height
+						);
+		}
+		else
+		{
+			sii5293_config_dvin(height>576?0:1, //hs_pol_inv,          
+						height>576?0:1, //vs_pol_inv,          
+						0, //de_pol_inv,          
+						(field_flag && height>=540)?1:0, //field_pol_inv, set to 1 for 1080i
+						0, //ext_field_sel,       
+						3, //de_mode,             
+						0, //data_comp_map,       
+						0, //mode_422to444,       
+						0, //dvin_clk_inv,        
+						0, //vs_hs_tim_ctrl,      
+						0, //hs_lead_vs_odd_min,  
+						0, //hs_lead_vs_odd_max,  
+						sii_get_hs_backporch(),//0xdc, //active_start_pix_fe, 
+						sii_get_hs_backporch(),//0xdc, //active_start_pix_fo, 
+						sii_get_vs_backporch(), //0x19, //active_start_line_fe,
+						sii_get_vs_backporch(),//0x19, //active_start_line_fo,
+						sii_get_h_total(), //0x672, //line_width,          
+						sii_get_v_total() //0x2ee //field_height
+						);       
+		}        
+
+		memset( &para, 0, sizeof(para));
+		para.port  = TVIN_PORT_DVIN0;
+		para.frame_rate = frame_rate;
+		para.h_active = info->vdin_info.cur_width;
+		para.v_active = info->vdin_info.cur_height;
+		if(field_flag){
+			if(info->vdin_info.cur_width == 1920 &&  
+			  (info->vdin_info.cur_height == 1080 || info->vdin_info.cur_height == 540)){
+				if( frame_rate == 60 )
+					para.fmt = TVIN_SIG_FMT_HDMI_1920X1080I_60HZ;
+				else if( frame_rate == 50 )
+					para.fmt = TVIN_SIG_FMT_HDMI_1920X1080I_50HZ_A;
+				para.v_active = 1080;
+			}
+		/*
+			else if( info->vdin_info.cur_width == 720 &&  (info->vdin_info.cur_height == 576 || info->vdin_info.cur_height == 288)){
+				 para.fmt = TVIN_SIG_FMT_HDMI_720X576I_50HZ;
+				 para.v_active = 576;
+				 set_invert_top_bot(true);
+			}
+		*/
+			else if(info->vdin_info.cur_width == 1440 &&  
+			  (info->vdin_info.cur_height == 576 || info->vdin_info.cur_height == 288)){
+				para.fmt = TVIN_SIG_FMT_HDMI_1440X576I_50HZ;
+				para.v_active = 576;
+				set_invert_top_bot(true);
+			}
+		/*
+			else if( info->vdin_info.cur_width == 720 &&  (info->vdin_info.cur_height == 480 || info->vdin_info.cur_height == 240)){
+				 para.fmt = TVIN_SIG_FMT_HDMI_720X480I_60HZ;
+				 para.v_active = 480;
+				 set_invert_top_bot(true);
+			}
+		*/
+			else if(info->vdin_info.cur_width == 1440  &&  
+			  (info->vdin_info.cur_height == 480 || info->vdin_info.cur_height == 240)){
+				para.fmt = TVIN_SIG_FMT_HDMI_1440X480I_60HZ;
+				para.v_active = 480;
+				set_invert_top_bot(true);
+			}
+			else{
+				para.fmt = TVIN_SIG_FMT_MAX+1;
+				set_invert_top_bot(true);
+			}
+			para.scan_mode = TVIN_SCAN_MODE_INTERLACED;	
+		}
+		else{
+			if(info->vdin_info.cur_width == 1920 &&  info->vdin_info.cur_height == 1080){
+				para.fmt = TVIN_SIG_FMT_HDMI_1920X1080P_60HZ;
+			}
+			else if(info->vdin_info.cur_width == 1280 &&  info->vdin_info.cur_height == 720){
+				para.fmt = TVIN_SIG_FMT_HDMI_1280X720P_60HZ;
+			}
+			else if((info->vdin_info.cur_width == 1440 || info->vdin_info.cur_width == 720) &&  info->vdin_info.cur_height == 576){
+				para.fmt = TVIN_SIG_FMT_HDMI_720X576P_50HZ;
+			}
+			else if((info->vdin_info.cur_width == 1440 || info->vdin_info.cur_width == 720) &&  info->vdin_info.cur_height == 480){
+				para.fmt = TVIN_SIG_FMT_HDMI_720X480P_60HZ;
+			}
+			else{
+				para.fmt = TVIN_SIG_FMT_MAX+1;
+			}
+			para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
+		}
+		para.hsync_phase = 1;
+		para.vsync_phase = 0;
+		//para.hs_bp = 0;
+		//para.vs_bp = 2;
+		para.cfmt = TVIN_RGB444;
+		para.dfmt = TVIN_YUV422;
+		para.reserved = 0; //skip_num
+
+		printk("[%s] begin start_tvin_service() !\n",__FUNCTION__);
+		start_tvin_service(0,&para);
+		info->vdin_started = 1;
+
+		//printk("%s: %dx%d %d %d/s\n", __func__, width, height, frame_rate, field_flag);
+	}
+
+	return ;
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/vdin_interface.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/vdin_interface.h
new file mode 100755
index 000000000000..a3a3d97fbb64
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/vdin_interface.h
@@ -0,0 +1,9 @@
+#ifndef __VDIN_INTERFACE_H__
+#define __VDIN_INTERFACE_H__
+
+int sii5293_register_tvin_frontend(struct tvin_frontend_s *frontend);
+
+void sii5293_stop_vdin(sii5293_vdin *info);
+void sii5293_start_vdin(sii5293_vdin *info, int width, int height, int frame_rate, int field_flag);
+
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/os_data.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/os_data.h
new file mode 100755
index 000000000000..11c9c4cc3031
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/os_data.h
@@ -0,0 +1,72 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+/**
+ * @file os_data.h
+ *
+ * OSAL data types (public)
+ *
+ * Don't use source control directives!
+ * Don't use source control directives!
+ * Don't use source control directives!
+ *
+ *****************************************************************************/
+
+#ifndef _OS_DATA_H
+#define _OS_DATA_H
+
+#ifdef PLATFORM3
+#error This file is not designed for use on the specified platform.
+#endif
+
+#if !defined(__KERNEL__)
+#include <sys/time.h>
+#include <bits/local_lim.h>
+#include <pthread.h>
+#else
+#include <linux/time.h>
+#endif
+
+
+#define OS_API_NAME_SIZE    16                      /* users can specify OSAL names up to specified size in APIs */
+#define OS_PRIV_NAME_SIZE   (OS_API_NAME_SIZE + 16) /* OSAL might internally append suffixes to names. Hence,
+                                                     * a bigger size is used to check the size limitations */
+
+#define OS_NAME_SIZE        (OS_PRIV_NAME_SIZE + 16) /* actual size of name-array */
+
+
+#define SII_OS_STACK_SIZE_MIN    PTHREAD_STACK_MIN   /* stack size during task creation */
+/* Forward declaration to help compilation */
+struct _SiiOsTaskInfo_t;
+#define OS_CURRENT_TASK    ((struct _SiiOsTaskInfo_t *) 0)
+
+
+/* The typedef below is used ONLY to abstract the pointer object in public APIs */
+typedef struct _SiiOsSemInfo_t * SiiOsSemaphore_t;
+
+/* the typedef below is used ONLY to abstract the pointer object in public APIs */
+typedef struct _SiiOsQueueInfo_t * SiiOsQueue_t;
+
+/* The typedef below is used ONLY to abstract the pointer object in public APIs */
+typedef struct _SiiOsTaskInfo_t * SiiOsTask_t;
+
+
+typedef struct
+{
+    struct timeval theTime;
+} SiiOsTime_t;
+
+typedef struct _SiiOsTimerInfo_t * SiiOsTimer_t;
+
+#endif /* _OS_DATA_H */
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/os_types.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/os_types.h
new file mode 100755
index 000000000000..a2d5a2d12a74
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/os_types.h
@@ -0,0 +1,121 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+/**
+ * @file os_types.h
+ *
+ * Data type definitions for the OSAL layer (internal)
+ *
+ * Don't use source control directives!
+ * Don't use source control directives!
+ * Don't use source control directives!
+ *
+ *****************************************************************************/
+
+#ifndef _OS_TYPES_H
+#define _OS_TYPES_H
+
+#if !defined(__KERNEL__)
+#include <sys/time.h>
+/*lint -save -e104 -e19*/
+#include <sys/uio.h>
+/*lint -restore*/
+
+#include "osal/sii_common/sii_types.h"
+#endif
+
+#include "osal/sii_common/sii_ids.h"
+#include "osal/sii_common/sii_inline.h"
+
+
+#define OS_NO_WAIT          0
+#define OS_INFINITE_WAIT    -1
+#define OS_MAX_TIMEOUT      (1000*60*60*24) /* 24 hours expressed in milliseconds. This can be increased depending on OS support */
+
+typedef struct timeval SiiOsTimeVal_t;
+typedef struct iovec SiiOsIoVec_t;
+typedef uint32_t SiiOsIpAddr_t;
+
+/** @brief return status codes */
+typedef enum
+{
+    /* Success */
+    SII_OS_STATUS_SUCCESS                = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_SUCCESS),             /** success */
+
+    /* Warnings */
+    SII_OS_STATUS_WARN_PENDING           = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_WARN_PENDING),        /** operation pending */
+    SII_OS_STATUS_WARN_BREAK             = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_WARN_BREAK),          /** operation has been interrupted */
+    SII_OS_STATUS_WARN_INCOMPLETE        = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_WARN_INCOMPLETE),     /** operation only partially completed */
+
+    /* Errors */
+    SII_OS_STATUS_ERR_INVALID_HANDLE     = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_INVALID_HANDLE),  /** invalid handle */
+    SII_OS_STATUS_ERR_INVALID_PARAM      = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_INVALID_PARAM),   /** invalid parameter */
+    SII_OS_STATUS_ERR_INVALID_OP         = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_INVALID_OP),      /** invalid operation */
+    SII_OS_STATUS_ERR_NOT_AVAIL          = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_NOT_AVAIL),       /** requested resource not available */
+    SII_OS_STATUS_ERR_IN_USE             = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_IN_USE),          /** requested resource is in use */
+    SII_OS_STATUS_ERR_TIMEOUT            = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_TIMEOUT),         /** timeout expired */
+    SII_OS_STATUS_ERR_FAILED             = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_FAILED),          /** general failure */
+    SII_OS_STATUS_ERR_NOT_IMPLEMENTED    = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_NOT_IMPLEMENTED), /** function not implemented (NOTE: for use in pre-production releases ONLY) */
+
+    SII_OS_STATUS_ERR_SEM_COUNT_EXCEEDED = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_CUSTOM1),         /** semaphore-give was called more times than the specific max count of the semaphore */
+    SII_OS_STATUS_ERR_QUEUE_EMPTY        = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_CUSTOM2),         /** message queue empty */
+    SII_OS_STATUS_ERR_QUEUE_FULL         = SII_STATUS_SET_GROUP(SII_GROUP_OSAL, SII_STATUS_ERR_CUSTOM3),         /** message queue full */
+    SII_OS_STATUS_LAST
+} SiiOsStatus_t;
+
+static SII_INLINE const char * SiiOsStatusString(const SiiOsStatus_t status)
+{
+    switch (status)
+    {
+        case SII_OS_STATUS_SUCCESS:
+            return "Success";
+
+        case SII_OS_STATUS_WARN_PENDING:
+            return "Warning-Operation Pending";
+        case SII_OS_STATUS_WARN_BREAK:
+            return "Warning-Break";
+        case SII_OS_STATUS_WARN_INCOMPLETE:
+            return "Warning-Operation Incomplete";
+
+        case SII_OS_STATUS_ERR_INVALID_HANDLE:
+            return "Error-Invalid Handle";
+        case SII_OS_STATUS_ERR_INVALID_PARAM:
+            return "Error-Invalid Parameter";
+        case SII_OS_STATUS_ERR_INVALID_OP:
+            return "Error-Invalid Operation";
+        case SII_OS_STATUS_ERR_NOT_AVAIL:
+            return "Error-Resource Not Available";
+        case SII_OS_STATUS_ERR_IN_USE:
+            return "Error-Resource In Use";
+        case SII_OS_STATUS_ERR_TIMEOUT:
+            return "Error-Timeout Expired";
+        case SII_OS_STATUS_ERR_FAILED:
+            return "Error-General Failure";
+        case SII_OS_STATUS_ERR_NOT_IMPLEMENTED:
+            return "Error-Not Implemented";
+        case SII_OS_STATUS_ERR_SEM_COUNT_EXCEEDED:
+            return "Error-Semaphore Count Exceeded";
+        case SII_OS_STATUS_ERR_QUEUE_EMPTY:
+            return "Error-Queue Empty";
+		case SII_OS_STATUS_ERR_QUEUE_FULL:
+			return "Error-Queue Full";	
+
+        default:
+            return "UNKNOWN";
+    }
+}
+
+
+#endif /* _OS_TYPES_H */
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/osal.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/osal.h
new file mode 100755
index 000000000000..aed6fc062650
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/include/osal.h
@@ -0,0 +1,222 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+/**
+ * @file osal.h
+ *
+ * Complete public API of the OSAL layer
+ *
+ * Don't use source control directives!
+ * Don't use source control directives!
+ * Don't use source control directives!
+ *
+ *****************************************************************************/
+
+#ifndef _OSAL_H
+#define _OSAL_H
+
+/* TODO: check necessity of inclusion for KAL layer implementation */
+
+#if !defined(__KERNEL__)
+#include <os_compiler.h>
+#include <os_linux.h>
+#include "os_data.h"
+#include <os_socket.h>
+#include <os_file.h>
+#include <os_string.h>
+#if !defined(DO_NOT_USE_DMLS)
+#include <os_dmls.h>
+#endif
+
+#else
+typedef bool bool_t;
+
+#include "osal/include/os_types.h"
+#include "osal/include/os_data.h"
+#endif
+
+
+
+/************************************************************************//**
+*
+* @brief Initialize the OSAL (public API)
+*
+* @return status code
+* @retval SII_OS_STATUS_SUCCESS no error
+* @retval SII_OS_STATUS_ERR_FAILED any kind of error
+*
+* @note Cannot be used from ISR.
+*
+******************************************************************************/
+SiiOsStatus_t SiiOsInit(uint32_t maxChannels);
+
+
+/************************************************************************//**
+*
+* @brief Cleanup the OSAL (public API)
+*
+* @return status code
+* @retval SII_OS_STATUS_SUCCESS no error
+* @retval SII_OS_STATUS_ERR_FAILED any kind of error
+*
+* @note Cannot be used from ISR.
+*
+******************************************************************************/
+SiiOsStatus_t SiiOsTerm(void);
+
+
+
+/*----------------------------------------------------------------------------------------*/
+/* Timer APIs */
+
+
+/************************************************************************//**
+*
+* @brief Create an OSAL timer (public API)
+*
+* @param[in]     pName           Name of the timer (16 characters at most)
+* @param[in]     pTimerFunction  Function to run when the timer fires.
+* @param[in]     pTimerArg       Parameter passed to timer function
+* @param[in]     timerStartFlag  true: adds timer to system queue immediately.@n
+*                                false: timer must be explicitly added to
+*                                       system queue using
+*                                       @ref SiiOsTimerSchedule().
+* @param[in]     timeMsec        Timeout interval in milliseconds for firing
+*                                either one-shot or periodic timer.
+*                                The time value is relative, i.e., it is the
+*                                delta from the current time.
+*                                This parameter is valid only if timerStartFlag = true.
+* @param[in]     periodicFlag    true: periodic timer,@n
+*                                false: one-shot timer
+* @param[out]    pRetTimerId     The created timer identifier
+*
+* @return status code
+* @retval SII_OS_STATUS_SUCCESS no error
+* @retval SII_OS_STATUS_ERR_INVALID_PARAM invalid parameter
+* @retval SII_OS_STATUS_ERR_NOT_AVAIL insufficient memory
+* @retval SII_OS_STATUS_ERR_FAILED any other kind of error
+*
+* @note Cannot be used from ISR.
+* @note The name of the timer is mandatory.
+*
+******************************************************************************/
+SiiOsStatus_t SiiOsTimerCreate
+(
+    const char *pName,
+    void (*pTimerFunction)(void *pArg),
+    void *pTimerArg,
+    SiiOsTimer_t *pRetTimerId
+);
+
+
+/************************************************************************//**
+*
+* @brief Delete an OSAL timer (public API)
+*
+* @param[in]    timerId        the timer identifier
+*
+* @return status code
+* @retval SII_OS_STATUS_SUCCESS no error
+* @retval SII_OS_STATUS_ERR_INVALID_PARAM invalid parameter
+* @retval SII_OS_STATUS_ERR_FAILED any other kind of error
+*
+* @note Cannot be used from ISR.
+* @note Can be called from a non-OSAL thread
+* @note Firing (or expiry) of a timer simply removes it from the system queue;
+*       the timer still needs to be explicitly deleted. However, timer deletion
+*       automatically removes it from system queue (if the timer hasn't fired, yet).
+*
+******************************************************************************/
+SiiOsStatus_t SiiOsTimerDelete(SiiOsTimer_t *pTimerId);
+
+SiiOsStatus_t  SiiOsTimerStart(SiiOsTimer_t timerId, uint32_t time_msec);
+SiiOsStatus_t  SiiOsTimerStop(SiiOsTimer_t timerId);
+
+
+/*----------------------------------------------------------------------------------------*/
+/* Memory APIs */
+
+
+/************************************************************************//**
+*
+* @brief Allocate a contiguous block of memory (public API)
+*
+* @param[in]   pName  name of the block (currently unused)
+* @param[in]   size   size in bytes
+* @param[in]   flags  SII_OS_MEMORY_SHARED: memory will be shared across a
+*                     user-kernel interface.@n
+*                     SII_OS_MEMORY_CONTIGUOUS: memory needs to be physically
+*                     contiguous.@n
+*                     Irrespective of this flag, the memory will always be
+*                     virtually contiguous.
+*
+* @return pointer to allocated block
+* @retval NULL out of memory or other failure
+*
+* @note Cannot be used from ISR.
+* @note The block may currently not exceed 4 GiB.
+*
+******************************************************************************/
+void * SiiOsAlloc
+(
+    const char *pName,
+    size_t size,
+    uint32_t flags
+);
+
+
+/************************************************************************//**
+*
+* @brief Allocate and clear a contiguous block of memory (public API)
+*
+* @param[in]   pName  name of the block (currently unused)
+* @param[in]   size   size in bytes
+* @param[in]   flags  SII_OS_MEMORY_SHARED: memory will be shared across a
+*                     user-kernel interface.@n
+*                     SII_OS_MEMORY_CONTIGUOUS: memory needs to be physically
+*                     contiguous.@n
+*                     Irrespective of this flag, the memory will always be
+*                     virtually contiguous.
+*
+* @return pointer to allocated block
+* @retval NULL out of memory or other failure
+*
+* @note Identical to @ref SiiOsAlloc(), but additionally initializes the
+*       allocated memory to zero
+* @note Cannot be used from ISR.
+* @note The block may currently not exceed 4 GiB.
+*
+******************************************************************************/
+void * SiiOsCalloc
+(
+    const char *pName,
+    size_t size,
+    uint32_t flags
+);
+
+
+/************************************************************************//**
+*
+* @brief Free a previously allocated block of memory (public API)
+*
+* @param[in]   pAddr  address of the block
+*
+* @note Cannot be used from ISR.
+*
+******************************************************************************/
+void SiiOsFree(void *pAddr);
+
+
+
+#endif /* _OSAL_H */
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/sii_common/sii_ids.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/sii_common/sii_ids.h
new file mode 100755
index 000000000000..1bba3a37fc82
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/sii_common/sii_ids.h
@@ -0,0 +1,113 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+/**
+ * @file sii_ids.h
+ *
+ * This file defines global identifiers and macros
+ *
+ * Don't use source control directives!
+ * Don't use source control directives!
+ * Don't use source control directives!
+ *
+ *****************************************************************************/
+#ifndef _SII_IDS_H
+#define _SII_IDS_H
+
+/* Globally unique identifiers for related groups (libraries, layers, etc.) */
+#define SII_GROUP_GENERAL  0x00
+#define SII_GROUP_OSAL     0x01
+#define SII_GROUP_NCL      0x02
+#define SII_GROUP_APP      0x03
+
+/* Macros for defining and testing status values */
+#define SII_STATUS_GROUP_MASK     0x00FF0000
+#define SII_STATUS_GROUP_SHIFT    16
+#define SII_STATUS_LEVEL_MASK     0x0000FF00
+#define SII_STATUS_LEVEL_SHIFT    8
+#define SII_STATUS_VALUE_MASK     0x000000FF
+#define SII_STATUS_VALUE_SHIFT    0
+
+#define SII_STATUS_LEVEL_SUCCESS  0x00
+#define SII_STATUS_LEVEL_WARNING  0x01
+#define SII_STATUS_LEVEL_ERROR    0x02
+
+#define SII_STATUS_VALUE(group, level, value)                           \
+    ((((group) << SII_STATUS_GROUP_SHIFT) & SII_STATUS_GROUP_MASK) |    \
+     (((level) << SII_STATUS_LEVEL_SHIFT) & SII_STATUS_LEVEL_MASK) |    \
+     (((value) << SII_STATUS_VALUE_SHIFT) & SII_STATUS_VALUE_MASK))
+
+#define SII_STATUS_SET_GROUP(group, value)                          \
+    (((value) & ~(SII_STATUS_GROUP_MASK)) |                         \
+     (((group) << SII_STATUS_GROUP_SHIFT) & SII_STATUS_GROUP_MASK))
+
+#define SII_STATUS_GET_GROUP(value)                                 \
+    (((value) & SII_STATUS_GROUP_MASK) >> SII_STATUS_GROUP_SHIFT)
+
+#define SII_STATUS_GET_LEVEL(value)                                 \
+    (((value) & SII_STATUS_LEVEL_MASK) >> SII_STATUS_LEVEL_SHIFT)
+
+
+#define SII_STATUS_ISERROR(status)                                      \
+    (((SII_STATUS_GET_LEVEL(status)) == SII_STATUS_LEVEL_ERROR) ? true : false )
+#define SII_STATUS_ISWARNING(status)                                    \
+    (((SII_STATUS_GET_LEVEL(status)) == SII_STATUS_LEVEL_WARNING) ? true : false )
+
+
+/** @brief general return status values */
+typedef enum
+{
+    /* Success */
+    SII_STATUS_SUCCESS                = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_SUCCESS, 0x00),    /** success */
+    SII_STATUS_SUCCESS_LAST,
+
+    /* Warnings */
+    SII_STATUS_WARN_PENDING           = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_WARNING, 0x01),   /** operation pending */
+    SII_STATUS_WARN_BREAK             = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_WARNING, 0x02),   /** operation has been interrupted */
+    SII_STATUS_WARN_INCOMPLETE        = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_WARNING, 0x03),   /** operation only partially completed */
+
+    /* Custom warning values (to be redefined with meaningful names in other groups) */
+    SII_STATUS_WARN_CUSTOM1           = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_WARNING, 0x81),   /** custom1 */
+    SII_STATUS_WARN_CUSTOM2           = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_WARNING, 0x82),   /** custom2 */
+    SII_STATUS_WARN_CUSTOM3           = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_WARNING, 0x83),   /** custom3 */
+    SII_STATUS_WARN_CUSTOM4           = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_WARNING, 0x84),   /** custom4 */
+    SII_STATUS_WARN_CUSTOM5           = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_WARNING, 0x85),   /** custom5 */
+    SII_STATUS_WARN_LAST,
+
+    /* Errors */
+    SII_STATUS_ERR_INVALID_HANDLE     = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x00),  /** invalid handle */
+    SII_STATUS_ERR_INVALID_PARAM      = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x01),  /** invalid parameter */
+    SII_STATUS_ERR_INVALID_OP         = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x02),  /** invalid operation */
+    SII_STATUS_ERR_NOT_AVAIL          = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x03),  /** resource not available */
+    SII_STATUS_ERR_IN_USE             = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x04),  /** resource is in use */
+    SII_STATUS_ERR_TIMEOUT            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x05),  /** timeout expired */
+    SII_STATUS_ERR_FAILED             = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x07),  /** general failure */
+
+    SII_STATUS_ERR_NOT_IMPLEMENTED    = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x41),  /** function not implemented (NOTE: for use in pre-production releases ONLY) */
+
+    /* Custom error values (to be redefined with meaningful names in other groups) */
+    SII_STATUS_ERR_CUSTOM1            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x81),  /** custom1 */
+    SII_STATUS_ERR_CUSTOM2            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x82),  /** custom2 */
+    SII_STATUS_ERR_CUSTOM3            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x83),  /** custom3 */
+    SII_STATUS_ERR_CUSTOM4            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x84),  /** custom4 */
+    SII_STATUS_ERR_CUSTOM5            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x85),  /** custom5 */
+    SII_STATUS_ERR_CUSTOM6            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x86),  /** custom6 */
+    SII_STATUS_ERR_CUSTOM7            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x87),  /** custom7 */
+    SII_STATUS_ERR_CUSTOM8            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x88),  /** custom8 */
+    SII_STATUS_ERR_CUSTOM9            = SII_STATUS_VALUE(SII_GROUP_GENERAL, SII_STATUS_LEVEL_ERROR, 0x89),  /** custom9 */
+    SII_STATUS_ERR_LAST
+} SiiStatus_t;
+
+
+#endif /* _SII_IDS_H */
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/sii_common/sii_inline.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/sii_common/sii_inline.h
new file mode 100755
index 000000000000..db1baf3ca8bb
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/osal/sii_common/sii_inline.h
@@ -0,0 +1,27 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+#ifdef WIN32
+#define SII_INLINE _inline
+#else
+#ifndef SII_INLINE
+#  if defined(__GNUC__)
+#    define SII_INLINE __inline__
+#  else
+#    define SII_INLINE inline
+#  endif /* __GNUC__ */
+#endif /* SII_INLINE */
+#endif /* WIN32 */
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/si_osdebug.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/si_osdebug.h
new file mode 100755
index 000000000000..d587ef8387ca
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/si_osdebug.h
@@ -0,0 +1,41 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+#ifndef __SI_OSDEBUG_H__
+#define __SI_OSDEBUG_H__
+
+
+void SiiOsDebugPrint(const char *pFileName, uint32_t iLineNum, uint8_t printFlags, const char *pszFormat, ...);
+
+#define SII_DEBUG_CONFIG_NO_FILE_LINE
+#ifdef SII_DEBUG_CONFIG_NO_FILE_LINE //(
+#define SII_DEBUG_PRINT(printFlags,...) SiiOsDebugPrint(NULL,0,printFlags,__VA_ARGS__)
+#define DEBUG_PRINT(printFlags,...) SiiOsDebugPrint(NULL,0,printFlags,__VA_ARGS__)
+#else //)(
+#define SII_DEBUG_PRINT(printFlags,...) SiiOsDebugPrint(__FILE__,__LINE__,printFlags,__VA_ARGS__)
+#define DEBUG_PRINT(printFlags,...) SiiOsDebugPrint(__FILE__,__LINE__,printFlags,__VA_ARGS__)
+#endif //)
+
+#define SII_PRINT_FULL(printFlags,...) SiiOsDebugPrint(__FILE__,__LINE__,printFlags,__VA_ARGS__)
+#define SII_PRINT(printFlags,...) SiiOsDebugPrint(NULL,0,printFlags,__VA_ARGS__)
+
+#define MSG_ALWAYS              0x00
+#define MSG_ERR                 0x00
+#define MSG_STAT                0x01
+#define MSG_DBG                 0x02
+#define MSG_PRINT_ALL           0xFF
+
+#endif // #ifndef __SI_OSDEBUG_H__
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/si_platform.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/si_platform.h
new file mode 100755
index 000000000000..b2810fe9a57e
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/include/si_platform.h
@@ -0,0 +1,78 @@
+/*
+ * SiI8332/8336 MHL Transmitter driver
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+/*
+ *****************************************************************************
+ * @file  si_platform.h
+ *
+ * @brief Implementation of the Foo API.
+ *
+ *****************************************************************************
+*/
+
+
+#ifndef __SI_PLATFORM_H__
+#define __SI_PLATFORM_H__
+#include <linux/types.h>
+#include "osal/include/osal.h"
+/* C99 defined data types.  */
+
+#define PLACE_IN_DATA_SEG
+#define PLACE_IN_CODE_SEG
+
+#define ROM     /* Nothing */
+#define XDATA   /* Nothing */
+
+
+typedef char BOOL;
+
+#define LOW                     0
+#define HIGH                    1
+
+//------------------------------------------------------------------------------
+// Configuration defines used by hal_config.h
+//------------------------------------------------------------------------------
+
+#ifndef BIT0
+#define BIT0                    0x01
+#define BIT1                    0x02
+#define BIT2                    0x04
+#define BIT3                    0x08
+#define BIT4                    0x10
+#define BIT5                    0x20
+#define BIT6                    0x40
+#define BIT7                    0x80
+#endif
+
+// Why two sets of BIT defines?  Because one type is used in SII code and the other
+// kind is stadard for Linux.  We need to cover both type or change to the Linux
+// standard everywhere.
+#ifndef BIT_0
+#define BIT_0                    0x01
+#define BIT_1                    0x02
+#define BIT_2                    0x04
+#define BIT_3                    0x08
+#define BIT_4                    0x10
+#define BIT_5                    0x20
+#define BIT_6                    0x40
+#define BIT_7                    0x80
+#endif
+
+#define SET_BITS    0xFF
+#define CLEAR_BITS  0x00
+
+#endif  // __SI_PLATFORM_H__
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/kernel/drivers/hid/hid-input.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/kernel/drivers/hid/hid-input.c
new file mode 100755
index 000000000000..69bc6a11d328
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/kernel/drivers/hid/hid-input.c
@@ -0,0 +1,964 @@
+/*
+ *  Copyright (c) 2000-2001 Vojtech Pavlik
+ *  Copyright (c) 2006-2010 Jiri Kosina
+ *
+ *  HID to Linux Input mapping
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+
+#include <linux/hid.h>
+#include <linux/hid-debug.h>
+
+#define unk	KEY_UNKNOWN
+
+#define MDT_SUPPORT
+#if defined(MDT_SUPPORT)
+// function point "mdt_burst_value_update" is initialize as NULL, will be updated after Silicon Image driver loaded.
+uint8_t (*mdt_burst_value_update) (struct hid_usage *usage, __s32 value) = NULL;
+EXPORT_SYMBOL(mdt_burst_value_update);
+#endif
+
+static const unsigned char hid_keyboard[256] = {
+	  0,  0,  0,  0, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38,
+	 50, 49, 24, 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44,  2,  3,
+	  4,  5,  6,  7,  8,  9, 10, 11, 28,  1, 14, 15, 57, 12, 13, 26,
+	 27, 43, 43, 39, 40, 41, 51, 52, 53, 58, 59, 60, 61, 62, 63, 64,
+	 65, 66, 67, 68, 87, 88, 99, 70,119,110,102,104,111,107,109,106,
+	105,108,103, 69, 98, 55, 74, 78, 96, 79, 80, 81, 75, 76, 77, 71,
+	 72, 73, 82, 83, 86,127,116,117,183,184,185,186,187,188,189,190,
+	191,192,193,194,134,138,130,132,128,129,131,137,133,135,136,113,
+	115,114,unk,unk,unk,121,unk, 89, 93,124, 92, 94, 95,unk,unk,unk,
+	122,123, 90, 91, 85,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,179,180,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,unk,
+	 29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113,
+	150,158,159,128,136,177,178,176,142,152,173,140,unk,unk,unk,unk
+};
+
+static const struct {
+	__s32 x;
+	__s32 y;
+}  hid_hat_to_axis[] = {{ 0, 0}, { 0,-1}, { 1,-1}, { 1, 0}, { 1, 1}, { 0, 1}, {-1, 1}, {-1, 0}, {-1,-1}};
+
+#define map_abs(c)	hid_map_usage(hidinput, usage, &bit, &max, EV_ABS, (c))
+#define map_rel(c)	hid_map_usage(hidinput, usage, &bit, &max, EV_REL, (c))
+#define map_key(c)	hid_map_usage(hidinput, usage, &bit, &max, EV_KEY, (c))
+#define map_led(c)	hid_map_usage(hidinput, usage, &bit, &max, EV_LED, (c))
+
+#define map_abs_clear(c)	hid_map_usage_clear(hidinput, usage, &bit, \
+		&max, EV_ABS, (c))
+#define map_key_clear(c)	hid_map_usage_clear(hidinput, usage, &bit, \
+		&max, EV_KEY, (c))
+
+static bool match_scancode(struct hid_usage *usage,
+			   unsigned int cur_idx, unsigned int scancode)
+{
+	return (usage->hid & (HID_USAGE_PAGE | HID_USAGE)) == scancode;
+}
+
+static bool match_keycode(struct hid_usage *usage,
+			  unsigned int cur_idx, unsigned int keycode)
+{
+	/*
+	 * We should exclude unmapped usages when doing lookup by keycode.
+	 */
+	return (usage->type == EV_KEY && usage->code == keycode);
+}
+
+static bool match_index(struct hid_usage *usage,
+			unsigned int cur_idx, unsigned int idx)
+{
+	return cur_idx == idx;
+}
+
+typedef bool (*hid_usage_cmp_t)(struct hid_usage *usage,
+				unsigned int cur_idx, unsigned int val);
+
+static struct hid_usage *hidinput_find_key(struct hid_device *hid,
+					   hid_usage_cmp_t match,
+					   unsigned int value,
+					   unsigned int *usage_idx)
+{
+	unsigned int i, j, k, cur_idx = 0;
+	struct hid_report *report;
+	struct hid_usage *usage;
+
+	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
+		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
+			for (i = 0; i < report->maxfield; i++) {
+				for (j = 0; j < report->field[i]->maxusage; j++) {
+					usage = report->field[i]->usage + j;
+					if (usage->type == EV_KEY || usage->type == 0) {
+						if (match(usage, cur_idx, value)) {
+							if (usage_idx)
+								*usage_idx = cur_idx;
+							return usage;
+						}
+						cur_idx++;
+					}
+				}
+			}
+		}
+	}
+	return NULL;
+}
+
+static struct hid_usage *hidinput_locate_usage(struct hid_device *hid,
+					const struct input_keymap_entry *ke,
+					unsigned int *index)
+{
+	struct hid_usage *usage;
+	unsigned int scancode;
+
+	if (ke->flags & INPUT_KEYMAP_BY_INDEX)
+		usage = hidinput_find_key(hid, match_index, ke->index, index);
+	else if (input_scancode_to_scalar(ke, &scancode) == 0)
+		usage = hidinput_find_key(hid, match_scancode, scancode, index);
+	else
+		usage = NULL;
+
+	return usage;
+}
+
+static int hidinput_getkeycode(struct input_dev *dev,
+			       struct input_keymap_entry *ke)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct hid_usage *usage;
+	unsigned int scancode, index;
+
+	usage = hidinput_locate_usage(hid, ke, &index);
+	if (usage) {
+		ke->keycode = usage->type == EV_KEY ?
+				usage->code : KEY_RESERVED;
+		ke->index = index;
+		scancode = usage->hid & (HID_USAGE_PAGE | HID_USAGE);
+		ke->len = sizeof(scancode);
+		memcpy(ke->scancode, &scancode, sizeof(scancode));
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int hidinput_setkeycode(struct input_dev *dev,
+			       const struct input_keymap_entry *ke,
+			       unsigned int *old_keycode)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct hid_usage *usage;
+
+	usage = hidinput_locate_usage(hid, ke, NULL);
+	if (usage) {
+		*old_keycode = usage->type == EV_KEY ?
+				usage->code : KEY_RESERVED;
+		usage->code = ke->keycode;
+
+		clear_bit(*old_keycode, dev->keybit);
+		set_bit(usage->code, dev->keybit);
+		dbg_hid("Assigned keycode %d to HID usage code %x\n",
+			usage->code, usage->hid);
+
+		/*
+		 * Set the keybit for the old keycode if the old keycode is used
+		 * by another key
+		 */
+		if (hidinput_find_key(hid, match_keycode, *old_keycode, NULL))
+			set_bit(*old_keycode, dev->keybit);
+
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+
+/**
+ * hidinput_calc_abs_res - calculate an absolute axis resolution
+ * @field: the HID report field to calculate resolution for
+ * @code: axis code
+ *
+ * The formula is:
+ *                         (logical_maximum - logical_minimum)
+ * resolution = ----------------------------------------------------------
+ *              (physical_maximum - physical_minimum) * 10 ^ unit_exponent
+ *
+ * as seen in the HID specification v1.11 6.2.2.7 Global Items.
+ *
+ * Only exponent 1 length units are processed. Centimeters and inches are
+ * converted to millimeters. Degrees are converted to radians.
+ */
+static __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
+{
+	__s32 unit_exponent = field->unit_exponent;
+	__s32 logical_extents = field->logical_maximum -
+					field->logical_minimum;
+	__s32 physical_extents = field->physical_maximum -
+					field->physical_minimum;
+	__s32 prev;
+
+	/* Check if the extents are sane */
+	if (logical_extents <= 0 || physical_extents <= 0)
+		return 0;
+
+	/*
+	 * Verify and convert units.
+	 * See HID specification v1.11 6.2.2.7 Global Items for unit decoding
+	 */
+	if (code == ABS_X || code == ABS_Y || code == ABS_Z) {
+		if (field->unit == 0x11) {		/* If centimeters */
+			/* Convert to millimeters */
+			unit_exponent += 1;
+		} else if (field->unit == 0x13) {	/* If inches */
+			/* Convert to millimeters */
+			prev = physical_extents;
+			physical_extents *= 254;
+			if (physical_extents < prev)
+				return 0;
+			unit_exponent -= 1;
+		} else {
+			return 0;
+		}
+	} else if (code == ABS_RX || code == ABS_RY || code == ABS_RZ) {
+		if (field->unit == 0x14) {		/* If degrees */
+			/* Convert to radians */
+			prev = logical_extents;
+			logical_extents *= 573;
+			if (logical_extents < prev)
+				return 0;
+			unit_exponent += 1;
+		} else if (field->unit != 0x12) {	/* If not radians */
+			return 0;
+		}
+	} else {
+		return 0;
+	}
+
+	/* Apply negative unit exponent */
+	for (; unit_exponent < 0; unit_exponent++) {
+		prev = logical_extents;
+		logical_extents *= 10;
+		if (logical_extents < prev)
+			return 0;
+	}
+	/* Apply positive unit exponent */
+	for (; unit_exponent > 0; unit_exponent--) {
+		prev = physical_extents;
+		physical_extents *= 10;
+		if (physical_extents < prev)
+			return 0;
+	}
+
+	/* Calculate resolution */
+	return logical_extents / physical_extents;
+}
+
+static void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,
+				     struct hid_usage *usage)
+{
+	struct input_dev *input = hidinput->input;
+	struct hid_device *device = input_get_drvdata(input);
+	int max = 0, code;
+	unsigned long *bit = NULL;
+
+	field->hidinput = hidinput;
+
+	if (field->flags & HID_MAIN_ITEM_CONSTANT)
+		goto ignore;
+
+	/* only LED usages are supported in output fields */
+	if (field->report_type == HID_OUTPUT_REPORT &&
+			(usage->hid & HID_USAGE_PAGE) != HID_UP_LED) {
+		goto ignore;
+	}
+
+	if (device->driver->input_mapping) {
+		int ret = device->driver->input_mapping(device, hidinput, field,
+				usage, &bit, &max);
+		if (ret > 0)
+			goto mapped;
+		if (ret < 0)
+			goto ignore;
+	}
+
+	switch (usage->hid & HID_USAGE_PAGE) {
+	case HID_UP_UNDEFINED:
+		goto ignore;
+
+	case HID_UP_KEYBOARD:
+		set_bit(EV_REP, input->evbit);
+
+		if ((usage->hid & HID_USAGE) < 256) {
+			if (!hid_keyboard[usage->hid & HID_USAGE]) goto ignore;
+			map_key_clear(hid_keyboard[usage->hid & HID_USAGE]);
+		} else
+			map_key(KEY_UNKNOWN);
+
+		break;
+
+	case HID_UP_BUTTON:
+		code = ((usage->hid - 1) & HID_USAGE);
+
+		switch (field->application) {
+		case HID_GD_MOUSE:
+		case HID_GD_POINTER:  code += 0x110; break;
+		case HID_GD_JOYSTICK:
+				if (code <= 0xf)
+					code += BTN_JOYSTICK;
+				else
+					code += BTN_TRIGGER_HAPPY;
+				break;
+		case HID_GD_GAMEPAD:  code += 0x130; break;
+		default:
+			switch (field->physical) {
+			case HID_GD_MOUSE:
+			case HID_GD_POINTER:  code += 0x110; break;
+			case HID_GD_JOYSTICK: code += 0x120; break;
+			case HID_GD_GAMEPAD:  code += 0x130; break;
+			default:              code += 0x100;
+			}
+		}
+
+		map_key(code);
+		break;
+
+	case HID_UP_SIMULATION:
+		switch (usage->hid & 0xffff) {
+		case 0xba: map_abs(ABS_RUDDER);   break;
+		case 0xbb: map_abs(ABS_THROTTLE); break;
+		case 0xc4: map_abs(ABS_GAS);      break;
+		case 0xc5: map_abs(ABS_BRAKE);    break;
+		case 0xc8: map_abs(ABS_WHEEL);    break;
+		default:   goto ignore;
+		}
+		break;
+
+	case HID_UP_GENDESK:
+		if ((usage->hid & 0xf0) == 0x80) {	/* SystemControl */
+			switch (usage->hid & 0xf) {
+			case 0x1: map_key_clear(KEY_POWER);  break;
+			case 0x2: map_key_clear(KEY_SLEEP);  break;
+			case 0x3: map_key_clear(KEY_WAKEUP); break;
+			default: goto unknown;
+			}
+			break;
+		}
+
+		if ((usage->hid & 0xf0) == 0x90) {	/* D-pad */
+			switch (usage->hid) {
+			case HID_GD_UP:	   usage->hat_dir = 1; break;
+			case HID_GD_DOWN:  usage->hat_dir = 5; break;
+			case HID_GD_RIGHT: usage->hat_dir = 3; break;
+			case HID_GD_LEFT:  usage->hat_dir = 7; break;
+			default: goto unknown;
+			}
+			if (field->dpad) {
+				map_abs(field->dpad);
+				goto ignore;
+			}
+			map_abs(ABS_HAT0X);
+			break;
+		}
+
+		switch (usage->hid) {
+		/* These usage IDs map directly to the usage codes. */
+		case HID_GD_X: case HID_GD_Y: case HID_GD_Z:
+		case HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:
+		case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
+			if (field->flags & HID_MAIN_ITEM_RELATIVE)
+				map_rel(usage->hid & 0xf);
+			else
+				map_abs(usage->hid & 0xf);
+			break;
+
+		case HID_GD_HATSWITCH:
+			usage->hat_min = field->logical_minimum;
+			usage->hat_max = field->logical_maximum;
+			map_abs(ABS_HAT0X);
+			break;
+
+		case HID_GD_START:	map_key_clear(BTN_START);	break;
+		case HID_GD_SELECT:	map_key_clear(BTN_SELECT);	break;
+
+		default: goto unknown;
+		}
+
+		break;
+
+	case HID_UP_LED:
+		switch (usage->hid & 0xffff) {		      /* HID-Value:                   */
+		case 0x01:  map_led (LED_NUML);     break;    /*   "Num Lock"                 */
+		case 0x02:  map_led (LED_CAPSL);    break;    /*   "Caps Lock"                */
+		case 0x03:  map_led (LED_SCROLLL);  break;    /*   "Scroll Lock"              */
+		case 0x04:  map_led (LED_COMPOSE);  break;    /*   "Compose"                  */
+		case 0x05:  map_led (LED_KANA);     break;    /*   "Kana"                     */
+		case 0x27:  map_led (LED_SLEEP);    break;    /*   "Stand-By"                 */
+		case 0x4c:  map_led (LED_SUSPEND);  break;    /*   "System Suspend"           */
+		case 0x09:  map_led (LED_MUTE);     break;    /*   "Mute"                     */
+		case 0x4b:  map_led (LED_MISC);     break;    /*   "Generic Indicator"        */
+		case 0x19:  map_led (LED_MAIL);     break;    /*   "Message Waiting"          */
+		case 0x4d:  map_led (LED_CHARGING); break;    /*   "External Power Connected" */
+
+		default: goto ignore;
+		}
+		break;
+
+	case HID_UP_DIGITIZER:
+		switch (usage->hid & 0xff) {
+		case 0x00: /* Undefined */
+			goto ignore;
+
+		case 0x30: /* TipPressure */
+			if (!test_bit(BTN_TOUCH, input->keybit)) {
+				device->quirks |= HID_QUIRK_NOTOUCH;
+				set_bit(EV_KEY, input->evbit);
+				set_bit(BTN_TOUCH, input->keybit);
+			}
+			map_abs_clear(ABS_PRESSURE);
+			break;
+
+		case 0x32: /* InRange */
+			switch (field->physical & 0xff) {
+			case 0x21: map_key(BTN_TOOL_MOUSE); break;
+			case 0x22: map_key(BTN_TOOL_FINGER); break;
+			default: map_key(BTN_TOOL_PEN); break;
+			}
+			break;
+
+		case 0x3c: /* Invert */
+			map_key_clear(BTN_TOOL_RUBBER);
+			break;
+
+		case 0x33: /* Touch */
+		case 0x42: /* TipSwitch */
+		case 0x43: /* TipSwitch2 */
+			device->quirks &= ~HID_QUIRK_NOTOUCH;
+			map_key_clear(BTN_TOUCH);
+			break;
+
+		case 0x44: /* BarrelSwitch */
+			map_key_clear(BTN_STYLUS);
+			break;
+
+		case 0x46: /* TabletPick */
+			map_key_clear(BTN_STYLUS2);
+			break;
+
+		default:  goto unknown;
+		}
+		break;
+
+	case HID_UP_CONSUMER:	/* USB HUT v1.1, pages 56-62 */
+		switch (usage->hid & HID_USAGE) {
+		case 0x000: goto ignore;
+		case 0x034: map_key_clear(KEY_SLEEP);		break;
+		case 0x036: map_key_clear(BTN_MISC);		break;
+
+		case 0x040: map_key_clear(KEY_MENU);		break;
+		case 0x045: map_key_clear(KEY_RADIO);		break;
+
+		case 0x083: map_key_clear(KEY_LAST);		break;
+		case 0x088: map_key_clear(KEY_PC);		break;
+		case 0x089: map_key_clear(KEY_TV);		break;
+		case 0x08a: map_key_clear(KEY_WWW);		break;
+		case 0x08b: map_key_clear(KEY_DVD);		break;
+		case 0x08c: map_key_clear(KEY_PHONE);		break;
+		case 0x08d: map_key_clear(KEY_PROGRAM);		break;
+		case 0x08e: map_key_clear(KEY_VIDEOPHONE);	break;
+		case 0x08f: map_key_clear(KEY_GAMES);		break;
+		case 0x090: map_key_clear(KEY_MEMO);		break;
+		case 0x091: map_key_clear(KEY_CD);		break;
+		case 0x092: map_key_clear(KEY_VCR);		break;
+		case 0x093: map_key_clear(KEY_TUNER);		break;
+		case 0x094: map_key_clear(KEY_EXIT);		break;
+		case 0x095: map_key_clear(KEY_HELP);		break;
+		case 0x096: map_key_clear(KEY_TAPE);		break;
+		case 0x097: map_key_clear(KEY_TV2);		break;
+		case 0x098: map_key_clear(KEY_SAT);		break;
+		case 0x09a: map_key_clear(KEY_PVR);		break;
+
+		case 0x09c: map_key_clear(KEY_CHANNELUP);	break;
+		case 0x09d: map_key_clear(KEY_CHANNELDOWN);	break;
+		case 0x0a0: map_key_clear(KEY_VCR2);		break;
+
+		case 0x0b0: map_key_clear(KEY_PLAY);		break;
+		case 0x0b1: map_key_clear(KEY_PAUSE);		break;
+		case 0x0b2: map_key_clear(KEY_RECORD);		break;
+		case 0x0b3: map_key_clear(KEY_FASTFORWARD);	break;
+		case 0x0b4: map_key_clear(KEY_REWIND);		break;
+		case 0x0b5: map_key_clear(KEY_NEXTSONG);	break;
+		case 0x0b6: map_key_clear(KEY_PREVIOUSSONG);	break;
+		case 0x0b7: map_key_clear(KEY_STOPCD);		break;
+		case 0x0b8: map_key_clear(KEY_EJECTCD);		break;
+		case 0x0bc: map_key_clear(KEY_MEDIA_REPEAT);	break;
+
+		case 0x0cd: map_key_clear(KEY_PLAYPAUSE);	break;
+		case 0x0e0: map_abs_clear(ABS_VOLUME);		break;
+		case 0x0e2: map_key_clear(KEY_MUTE);		break;
+		case 0x0e5: map_key_clear(KEY_BASSBOOST);	break;
+		case 0x0e9: map_key_clear(KEY_VOLUMEUP);	break;
+		case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
+
+		case 0x182: map_key_clear(KEY_BOOKMARKS);	break;
+		case 0x183: map_key_clear(KEY_CONFIG);		break;
+		case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;
+		case 0x185: map_key_clear(KEY_EDITOR);		break;
+		case 0x186: map_key_clear(KEY_SPREADSHEET);	break;
+		case 0x187: map_key_clear(KEY_GRAPHICSEDITOR);	break;
+		case 0x188: map_key_clear(KEY_PRESENTATION);	break;
+		case 0x189: map_key_clear(KEY_DATABASE);	break;
+		case 0x18a: map_key_clear(KEY_MAIL);		break;
+		case 0x18b: map_key_clear(KEY_NEWS);		break;
+		case 0x18c: map_key_clear(KEY_VOICEMAIL);	break;
+		case 0x18d: map_key_clear(KEY_ADDRESSBOOK);	break;
+		case 0x18e: map_key_clear(KEY_CALENDAR);	break;
+		case 0x191: map_key_clear(KEY_FINANCE);		break;
+		case 0x192: map_key_clear(KEY_CALC);		break;
+		case 0x194: map_key_clear(KEY_FILE);		break;
+		case 0x196: map_key_clear(KEY_WWW);		break;
+		case 0x199: map_key_clear(KEY_CHAT);		break;
+		case 0x19c: map_key_clear(KEY_LOGOFF);		break;
+		case 0x19e: map_key_clear(KEY_COFFEE);		break;
+		case 0x1a6: map_key_clear(KEY_HELP);		break;
+		case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
+		case 0x1ab: map_key_clear(KEY_SPELLCHECK);	break;
+		case 0x1b6: map_key_clear(KEY_MEDIA);		break;
+		case 0x1b7: map_key_clear(KEY_SOUND);		break;
+		case 0x1bc: map_key_clear(KEY_MESSENGER);	break;
+		case 0x1bd: map_key_clear(KEY_INFO);		break;
+		case 0x201: map_key_clear(KEY_NEW);		break;
+		case 0x202: map_key_clear(KEY_OPEN);		break;
+		case 0x203: map_key_clear(KEY_CLOSE);		break;
+		case 0x204: map_key_clear(KEY_EXIT);		break;
+		case 0x207: map_key_clear(KEY_SAVE);		break;
+		case 0x208: map_key_clear(KEY_PRINT);		break;
+		case 0x209: map_key_clear(KEY_PROPS);		break;
+		case 0x21a: map_key_clear(KEY_UNDO);		break;
+		case 0x21b: map_key_clear(KEY_COPY);		break;
+		case 0x21c: map_key_clear(KEY_CUT);		break;
+		case 0x21d: map_key_clear(KEY_PASTE);		break;
+		case 0x21f: map_key_clear(KEY_FIND);		break;
+		case 0x221: map_key_clear(KEY_SEARCH);		break;
+		case 0x222: map_key_clear(KEY_GOTO);		break;
+		case 0x223: map_key_clear(KEY_HOMEPAGE);	break;
+		case 0x224: map_key_clear(KEY_BACK);		break;
+		case 0x225: map_key_clear(KEY_FORWARD);		break;
+		case 0x226: map_key_clear(KEY_STOP);		break;
+		case 0x227: map_key_clear(KEY_REFRESH);		break;
+		case 0x22a: map_key_clear(KEY_BOOKMARKS);	break;
+		case 0x22d: map_key_clear(KEY_ZOOMIN);		break;
+		case 0x22e: map_key_clear(KEY_ZOOMOUT);		break;
+		case 0x22f: map_key_clear(KEY_ZOOMRESET);	break;
+		case 0x233: map_key_clear(KEY_SCROLLUP);	break;
+		case 0x234: map_key_clear(KEY_SCROLLDOWN);	break;
+		case 0x238: map_rel(REL_HWHEEL);		break;
+		case 0x25f: map_key_clear(KEY_CANCEL);		break;
+		case 0x279: map_key_clear(KEY_REDO);		break;
+
+		case 0x289: map_key_clear(KEY_REPLY);		break;
+		case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
+		case 0x28c: map_key_clear(KEY_SEND);		break;
+
+		default:    goto ignore;
+		}
+		break;
+
+	case HID_UP_HPVENDOR:	/* Reported on a Dutch layout HP5308 */
+		set_bit(EV_REP, input->evbit);
+		switch (usage->hid & HID_USAGE) {
+		case 0x021: map_key_clear(KEY_PRINT);           break;
+		case 0x070: map_key_clear(KEY_HP);		break;
+		case 0x071: map_key_clear(KEY_CAMERA);		break;
+		case 0x072: map_key_clear(KEY_SOUND);		break;
+		case 0x073: map_key_clear(KEY_QUESTION);	break;
+		case 0x080: map_key_clear(KEY_EMAIL);		break;
+		case 0x081: map_key_clear(KEY_CHAT);		break;
+		case 0x082: map_key_clear(KEY_SEARCH);		break;
+		case 0x083: map_key_clear(KEY_CONNECT);	        break;
+		case 0x084: map_key_clear(KEY_FINANCE);		break;
+		case 0x085: map_key_clear(KEY_SPORT);		break;
+		case 0x086: map_key_clear(KEY_SHOP);	        break;
+		default:    goto ignore;
+		}
+		break;
+
+	case HID_UP_MSVENDOR:
+		goto ignore;
+
+	case HID_UP_CUSTOM: /* Reported on Logitech and Apple USB keyboards */
+		set_bit(EV_REP, input->evbit);
+		goto ignore;
+
+	case HID_UP_LOGIVENDOR:
+		goto ignore;
+
+	case HID_UP_PID:
+		switch (usage->hid & HID_USAGE) {
+		case 0xa4: map_key_clear(BTN_DEAD);	break;
+		default: goto ignore;
+		}
+		break;
+
+	default:
+	unknown:
+		if (field->report_size == 1) {
+			if (field->report->type == HID_OUTPUT_REPORT) {
+				map_led(LED_MISC);
+				break;
+			}
+			map_key(BTN_MISC);
+			break;
+		}
+		if (field->flags & HID_MAIN_ITEM_RELATIVE) {
+			map_rel(REL_MISC);
+			break;
+		}
+		map_abs(ABS_MISC);
+		break;
+	}
+
+mapped:
+	if (device->driver->input_mapped && device->driver->input_mapped(device,
+				hidinput, field, usage, &bit, &max) < 0)
+		goto ignore;
+
+	set_bit(usage->type, input->evbit);
+
+	while (usage->code <= max && test_and_set_bit(usage->code, bit))
+		usage->code = find_next_zero_bit(bit, max + 1, usage->code);
+
+	if (usage->code > max)
+		goto ignore;
+
+
+	if (usage->type == EV_ABS) {
+
+		int a = field->logical_minimum;
+		int b = field->logical_maximum;
+
+		if ((device->quirks & HID_QUIRK_BADPAD) && (usage->code == ABS_X || usage->code == ABS_Y)) {
+			a = field->logical_minimum = 0;
+			b = field->logical_maximum = 255;
+		}
+
+		if (field->application == HID_GD_GAMEPAD || field->application == HID_GD_JOYSTICK)
+			input_set_abs_params(input, usage->code, a, b, (b - a) >> 8, (b - a) >> 4);
+		else	input_set_abs_params(input, usage->code, a, b, 0, 0);
+
+		input_abs_set_res(input, usage->code,
+				  hidinput_calc_abs_res(field, usage->code));
+
+		/* use a larger default input buffer for MT devices */
+		if (usage->code == ABS_MT_POSITION_X && input->hint_events_per_packet == 0)
+			input_set_events_per_packet(input, 60);
+	}
+
+	if (usage->type == EV_ABS &&
+	    (usage->hat_min < usage->hat_max || usage->hat_dir)) {
+		int i;
+		for (i = usage->code; i < usage->code + 2 && i <= max; i++) {
+			input_set_abs_params(input, i, -1, 1, 0, 0);
+			set_bit(i, input->absbit);
+		}
+		if (usage->hat_dir && !field->dpad)
+			field->dpad = usage->code;
+	}
+
+	/* for those devices which produce Consumer volume usage as relative,
+	 * we emulate pressing volumeup/volumedown appropriate number of times
+	 * in hidinput_hid_event()
+	 */
+	if ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&
+			(usage->code == ABS_VOLUME)) {
+		set_bit(KEY_VOLUMEUP, input->keybit);
+		set_bit(KEY_VOLUMEDOWN, input->keybit);
+	}
+
+	if (usage->type == EV_KEY) {
+		set_bit(EV_MSC, input->evbit);
+		set_bit(MSC_SCAN, input->mscbit);
+	}
+
+ignore:
+	return;
+
+}
+
+void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value)
+{
+	struct input_dev *input;
+	unsigned *quirks = &hid->quirks;
+
+	#ifdef MDT_SUPPORT
+	int ret;
+	#endif
+	
+	if (!field->hidinput)
+		return;
+
+	input = field->hidinput->input;
+
+	if (!usage->type)
+		return;
+
+	if (usage->hat_min < usage->hat_max || usage->hat_dir) {
+		int hat_dir = usage->hat_dir;
+		if (!hat_dir)
+			hat_dir = (value - usage->hat_min) * 8 / (usage->hat_max - usage->hat_min + 1) + 1;
+		if (hat_dir < 0 || hat_dir > 8) hat_dir = 0;
+		input_event(input, usage->type, usage->code    , hid_hat_to_axis[hat_dir].x);
+		input_event(input, usage->type, usage->code + 1, hid_hat_to_axis[hat_dir].y);
+		return;
+	}
+
+	if (usage->hid == (HID_UP_DIGITIZER | 0x003c)) { /* Invert */
+		*quirks = value ? (*quirks | HID_QUIRK_INVERT) : (*quirks & ~HID_QUIRK_INVERT);
+		return;
+	}
+
+	if (usage->hid == (HID_UP_DIGITIZER | 0x0032)) { /* InRange */
+		if (value) {
+			input_event(input, usage->type, (*quirks & HID_QUIRK_INVERT) ? BTN_TOOL_RUBBER : usage->code, 1);
+			return;
+		}
+		input_event(input, usage->type, usage->code, 0);
+		input_event(input, usage->type, BTN_TOOL_RUBBER, 0);
+		return;
+	}
+
+	if (usage->hid == (HID_UP_DIGITIZER | 0x0030) && (*quirks & HID_QUIRK_NOTOUCH)) { /* Pressure */
+		int a = field->logical_minimum;
+		int b = field->logical_maximum;
+		input_event(input, EV_KEY, BTN_TOUCH, value > a + ((b - a) >> 3));
+	}
+
+	if (usage->hid == (HID_UP_PID | 0x83UL)) { /* Simultaneous Effects Max */
+		dbg_hid("Maximum Effects - %d\n",value);
+		return;
+	}
+
+	if (usage->hid == (HID_UP_PID | 0x7fUL)) {
+		dbg_hid("PID Pool Report\n");
+		return;
+	}
+
+	if ((usage->type == EV_KEY) && (usage->code == 0)) /* Key 0 is "unassigned", not KEY_UNKNOWN */
+		return;
+
+	if ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&
+			(usage->code == ABS_VOLUME)) {
+		int count = abs(value);
+		int direction = value > 0 ? KEY_VOLUMEUP : KEY_VOLUMEDOWN;
+		int i;
+
+		for (i = 0; i < count; i++) {
+			input_event(input, EV_KEY, direction, 1);
+			input_sync(input);
+			input_event(input, EV_KEY, direction, 0);
+			input_sync(input);
+		}
+		return;
+	}
+
+	/* report the usage code as scancode if the key status has changed */
+	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
+		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
+
+	#if defined(MDT_SUPPORT)
+	//printk(KERN_ERR "mhawb\tu%x\tt%x\tu%x\tv%x", (int)usage->hid, (int)usage->type, (int)usage->code, (int)value); 
+	//printk(KERN_ERR "mdt_update status: %x",(int)mdt_burst_value_update(usage,value));
+	if (mdt_burst_value_update)
+	{
+		ret = mdt_burst_value_update(usage,value);
+		//if (ret) printk(KERN_ERR "mdt_update error: %x\n", ret);
+	}
+	#endif
+
+	input_event(input, usage->type, usage->code, value);
+
+	if ((field->flags & HID_MAIN_ITEM_RELATIVE) && (usage->type == EV_KEY))
+		input_event(input, usage->type, usage->code, 0);
+}
+
+void hidinput_report_event(struct hid_device *hid, struct hid_report *report)
+{
+	struct hid_input *hidinput;
+
+	if (hid->quirks & HID_QUIRK_NO_INPUT_SYNC)
+		return;
+
+	list_for_each_entry(hidinput, &hid->inputs, list)
+		input_sync(hidinput->input);
+}
+EXPORT_SYMBOL_GPL(hidinput_report_event);
+
+int hidinput_find_field(struct hid_device *hid, unsigned int type, unsigned int code, struct hid_field **field)
+{
+	struct hid_report *report;
+	int i, j;
+
+	list_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {
+		for (i = 0; i < report->maxfield; i++) {
+			*field = report->field[i];
+			for (j = 0; j < (*field)->maxusage; j++)
+				if ((*field)->usage[j].type == type && (*field)->usage[j].code == code)
+					return j;
+		}
+	}
+	return -1;
+}
+EXPORT_SYMBOL_GPL(hidinput_find_field);
+
+static int hidinput_open(struct input_dev *dev)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+
+	return hid->ll_driver->open(hid);
+}
+
+static void hidinput_close(struct input_dev *dev)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+
+	hid->ll_driver->close(hid);
+}
+
+/*
+ * Register the input device; print a message.
+ * Configure the input layer interface
+ * Read all reports and initialize the absolute field values.
+ */
+
+int hidinput_connect(struct hid_device *hid, unsigned int force)
+{
+	struct hid_report *report;
+	struct hid_input *hidinput = NULL;
+	struct input_dev *input_dev;
+	int i, j, k;
+	int max_report_type = HID_OUTPUT_REPORT;
+
+	INIT_LIST_HEAD(&hid->inputs);
+
+	if (!force) {
+		for (i = 0; i < hid->maxcollection; i++) {
+			struct hid_collection *col = &hid->collection[i];
+			if (col->type == HID_COLLECTION_APPLICATION ||
+					col->type == HID_COLLECTION_PHYSICAL)
+				if (IS_INPUT_APPLICATION(col->usage))
+					break;
+		}
+
+		if (i == hid->maxcollection)
+			return -1;
+	}
+
+	if (hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
+		max_report_type = HID_INPUT_REPORT;
+
+	for (k = HID_INPUT_REPORT; k <= max_report_type; k++)
+		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
+
+			if (!report->maxfield)
+				continue;
+
+			if (!hidinput) {
+				hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);
+				input_dev = input_allocate_device();
+				if (!hidinput || !input_dev) {
+					kfree(hidinput);
+					input_free_device(input_dev);
+					err_hid("Out of memory during hid input probe");
+					goto out_unwind;
+				}
+
+				input_set_drvdata(input_dev, hid);
+				input_dev->event =
+					hid->ll_driver->hidinput_input_event;
+				input_dev->open = hidinput_open;
+				input_dev->close = hidinput_close;
+				input_dev->setkeycode_new = hidinput_setkeycode;
+				input_dev->getkeycode_new = hidinput_getkeycode;
+
+				input_dev->name = hid->name;
+				input_dev->phys = hid->phys;
+				input_dev->uniq = hid->uniq;
+				input_dev->id.bustype = hid->bus;
+				input_dev->id.vendor  = hid->vendor;
+				input_dev->id.product = hid->product;
+				input_dev->id.version = hid->version;
+				input_dev->dev.parent = hid->dev.parent;
+				hidinput->input = input_dev;
+				list_add_tail(&hidinput->list, &hid->inputs);
+			}
+
+			for (i = 0; i < report->maxfield; i++)
+				for (j = 0; j < report->field[i]->maxusage; j++)
+					hidinput_configure_usage(hidinput, report->field[i],
+								 report->field[i]->usage + j);
+
+			if (hid->quirks & HID_QUIRK_MULTI_INPUT) {
+				/* This will leave hidinput NULL, so that it
+				 * allocates another one if we have more inputs on
+				 * the same interface. Some devices (e.g. Happ's
+				 * UGCI) cram a lot of unrelated inputs into the
+				 * same interface. */
+				hidinput->report = report;
+				if (input_register_device(hidinput->input))
+					goto out_cleanup;
+				hidinput = NULL;
+			}
+		}
+
+	if (hidinput && input_register_device(hidinput->input))
+		goto out_cleanup;
+
+	return 0;
+
+out_cleanup:
+	input_free_device(hidinput->input);
+	kfree(hidinput);
+out_unwind:
+	/* unwind the ones we already registered */
+	hidinput_disconnect(hid);
+
+	return -1;
+}
+EXPORT_SYMBOL_GPL(hidinput_connect);
+
+void hidinput_disconnect(struct hid_device *hid)
+{
+	struct hid_input *hidinput, *next;
+
+	list_for_each_entry_safe(hidinput, next, &hid->inputs, list) {
+		list_del(&hidinput->list);
+		input_unregister_device(hidinput->input);
+		kfree(hidinput);
+	}
+}
+EXPORT_SYMBOL_GPL(hidinput_disconnect);
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/kernel/drivers/hid/usbhid/hid-core.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/kernel/drivers/hid/usbhid/hid-core.c
new file mode 100755
index 000000000000..3a4315605489
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/kernel/drivers/hid/usbhid/hid-core.c
@@ -0,0 +1,1517 @@
+/*
+ *  USB HID support for Linux
+ *
+ *  Copyright (c) 1999 Andreas Gal
+ *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
+ *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
+ *  Copyright (c) 2007-2008 Oliver Neukum
+ *  Copyright (c) 2006-2010 Jiri Kosina
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <asm/unaligned.h>
+#include <asm/byteorder.h>
+#include <linux/input.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+
+#include <linux/usb.h>
+
+#include <linux/hid.h>
+#include <linux/hiddev.h>
+#include <linux/hid-debug.h>
+#include <linux/hidraw.h>
+#include "usbhid.h"
+
+#define MDT_SUPPORT
+#if defined(MDT_SUPPORT)
+// function point "mdt_burst_sync_and_send" is initialize as NULL, will be updated after Silicon Image driver loaded.
+uint8_t (*mdt_burst_sync_and_send)(void) = NULL;
+EXPORT_SYMBOL(mdt_burst_sync_and_send);
+#endif
+
+/*
+ * Version Information
+ */
+
+#define DRIVER_DESC "USB HID core driver"
+#define DRIVER_LICENSE "GPL"
+
+/*
+ * Module parameters.
+ */
+
+static unsigned int hid_mousepoll_interval;
+module_param_named(mousepoll, hid_mousepoll_interval, uint, 0644);
+MODULE_PARM_DESC(mousepoll, "Polling interval of mice");
+
+static unsigned int ignoreled;
+module_param_named(ignoreled, ignoreled, uint, 0644);
+MODULE_PARM_DESC(ignoreled, "Autosuspend with active leds");
+
+/* Quirks specified at module load time */
+static char *quirks_param[MAX_USBHID_BOOT_QUIRKS] = { [ 0 ... (MAX_USBHID_BOOT_QUIRKS - 1) ] = NULL };
+module_param_array_named(quirks, quirks_param, charp, NULL, 0444);
+MODULE_PARM_DESC(quirks, "Add/modify USB HID quirks by specifying "
+		" quirks=vendorID:productID:quirks"
+		" where vendorID, productID, and quirks are all in"
+		" 0x-prefixed hex");
+/*
+ * Input submission and I/O error handler.
+ */
+static DEFINE_MUTEX(hid_open_mut);
+static struct workqueue_struct *resumption_waker;
+
+static void hid_io_error(struct hid_device *hid);
+static int hid_submit_out(struct hid_device *hid);
+static int hid_submit_ctrl(struct hid_device *hid);
+static void hid_cancel_delayed_stuff(struct usbhid_device *usbhid);
+
+/* Start up the input URB */
+static int hid_start_in(struct hid_device *hid)
+{
+	unsigned long flags;
+	int rc = 0;
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	spin_lock_irqsave(&usbhid->lock, flags);
+	if (hid->open > 0 &&
+			!test_bit(HID_DISCONNECTED, &usbhid->iofl) &&
+			!test_bit(HID_REPORTED_IDLE, &usbhid->iofl) &&
+			!test_and_set_bit(HID_IN_RUNNING, &usbhid->iofl)) {
+		rc = usb_submit_urb(usbhid->urbin, GFP_ATOMIC);
+		if (rc != 0)
+			clear_bit(HID_IN_RUNNING, &usbhid->iofl);
+	}
+	spin_unlock_irqrestore(&usbhid->lock, flags);
+	return rc;
+}
+
+/* I/O retry timer routine */
+static void hid_retry_timeout(unsigned long _hid)
+{
+	struct hid_device *hid = (struct hid_device *) _hid;
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	dev_dbg(&usbhid->intf->dev, "retrying intr urb\n");
+	if (hid_start_in(hid))
+		hid_io_error(hid);
+}
+
+/* Workqueue routine to reset the device or clear a halt */
+static void hid_reset(struct work_struct *work)
+{
+	struct usbhid_device *usbhid =
+		container_of(work, struct usbhid_device, reset_work);
+	struct hid_device *hid = usbhid->hid;
+	int rc = 0;
+
+	if (test_bit(HID_CLEAR_HALT, &usbhid->iofl)) {
+		dev_dbg(&usbhid->intf->dev, "clear halt\n");
+		rc = usb_clear_halt(hid_to_usb_dev(hid), usbhid->urbin->pipe);
+		clear_bit(HID_CLEAR_HALT, &usbhid->iofl);
+		hid_start_in(hid);
+	}
+
+	else if (test_bit(HID_RESET_PENDING, &usbhid->iofl)) {
+		dev_dbg(&usbhid->intf->dev, "resetting device\n");
+		rc = usb_lock_device_for_reset(hid_to_usb_dev(hid), usbhid->intf);
+		if (rc == 0) {
+			rc = usb_reset_device(hid_to_usb_dev(hid));
+			usb_unlock_device(hid_to_usb_dev(hid));
+		}
+		clear_bit(HID_RESET_PENDING, &usbhid->iofl);
+	}
+
+	switch (rc) {
+	case 0:
+		if (!test_bit(HID_IN_RUNNING, &usbhid->iofl))
+			hid_io_error(hid);
+		break;
+	default:
+		err_hid("can't reset device, %s-%s/input%d, status %d",
+				hid_to_usb_dev(hid)->bus->bus_name,
+				hid_to_usb_dev(hid)->devpath,
+				usbhid->ifnum, rc);
+		/* FALLTHROUGH */
+	case -EHOSTUNREACH:
+	case -ENODEV:
+	case -EINTR:
+		break;
+	}
+}
+
+/* Main I/O error handler */
+static void hid_io_error(struct hid_device *hid)
+{
+	unsigned long flags;
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	spin_lock_irqsave(&usbhid->lock, flags);
+
+	/* Stop when disconnected */
+	if (test_bit(HID_DISCONNECTED, &usbhid->iofl))
+		goto done;
+
+	/* If it has been a while since the last error, we'll assume
+	 * this a brand new error and reset the retry timeout. */
+	if (time_after(jiffies, usbhid->stop_retry + HZ/2))
+		usbhid->retry_delay = 0;
+
+	/* When an error occurs, retry at increasing intervals */
+	if (usbhid->retry_delay == 0) {
+		usbhid->retry_delay = 13;	/* Then 26, 52, 104, 104, ... */
+		usbhid->stop_retry = jiffies + msecs_to_jiffies(1000);
+	} else if (usbhid->retry_delay < 100)
+		usbhid->retry_delay *= 2;
+
+	if (time_after(jiffies, usbhid->stop_retry)) {
+
+		/* Retries failed, so do a port reset */
+		if (!test_and_set_bit(HID_RESET_PENDING, &usbhid->iofl)) {
+			schedule_work(&usbhid->reset_work);
+			goto done;
+		}
+	}
+
+	mod_timer(&usbhid->io_retry,
+			jiffies + msecs_to_jiffies(usbhid->retry_delay));
+done:
+	spin_unlock_irqrestore(&usbhid->lock, flags);
+}
+
+static void usbhid_mark_busy(struct usbhid_device *usbhid)
+{
+	struct usb_interface *intf = usbhid->intf;
+
+	usb_mark_last_busy(interface_to_usbdev(intf));
+}
+
+static int usbhid_restart_out_queue(struct usbhid_device *usbhid)
+{
+	struct hid_device *hid = usb_get_intfdata(usbhid->intf);
+	int kicked;
+
+	if (!hid)
+		return 0;
+
+	if ((kicked = (usbhid->outhead != usbhid->outtail))) {
+		dbg("Kicking head %d tail %d", usbhid->outhead, usbhid->outtail);
+		if (hid_submit_out(hid)) {
+			clear_bit(HID_OUT_RUNNING, &usbhid->iofl);
+			wake_up(&usbhid->wait);
+		}
+	}
+	return kicked;
+}
+
+static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
+{
+	struct hid_device *hid = usb_get_intfdata(usbhid->intf);
+	int kicked;
+
+	WARN_ON(hid == NULL);
+	if (!hid)
+		return 0;
+
+	if ((kicked = (usbhid->ctrlhead != usbhid->ctrltail))) {
+		dbg("Kicking head %d tail %d", usbhid->ctrlhead, usbhid->ctrltail);
+		if (hid_submit_ctrl(hid)) {
+			clear_bit(HID_CTRL_RUNNING, &usbhid->iofl);
+			wake_up(&usbhid->wait);
+		}
+	}
+	return kicked;
+}
+
+/*
+ * Input interrupt completion handler.
+ */
+
+static void hid_irq_in(struct urb *urb)
+{
+	struct hid_device	*hid = urb->context;
+	struct usbhid_device 	*usbhid = hid->driver_data;
+	int			status;
+
+	switch (urb->status) {
+	case 0:			/* success */
+		usbhid_mark_busy(usbhid);
+		usbhid->retry_delay = 0;
+		hid_input_report(urb->context, HID_INPUT_REPORT,
+				 urb->transfer_buffer,
+				 urb->actual_length, 1);
+		/*
+		 * autosuspend refused while keys are pressed
+		 * because most keyboards don't wake up when
+		 * a key is released
+		 */
+		if (hid_check_keys_pressed(hid))
+			set_bit(HID_KEYS_PRESSED, &usbhid->iofl);
+		else
+			clear_bit(HID_KEYS_PRESSED, &usbhid->iofl);
+		#if defined(MDT_SUPPORT)
+		if (mdt_burst_sync_and_send)
+			mdt_burst_sync_and_send();		
+		#endif
+		break;
+	case -EPIPE:		/* stall */
+		usbhid_mark_busy(usbhid);
+		clear_bit(HID_IN_RUNNING, &usbhid->iofl);
+		set_bit(HID_CLEAR_HALT, &usbhid->iofl);
+		schedule_work(&usbhid->reset_work);
+		return;
+	case -ECONNRESET:	/* unlink */
+	case -ENOENT:
+	case -ESHUTDOWN:	/* unplug */
+		clear_bit(HID_IN_RUNNING, &usbhid->iofl);
+		return;
+	case -EILSEQ:		/* protocol error or unplug */
+	case -EPROTO:		/* protocol error or unplug */
+	case -ETIME:		/* protocol error or unplug */
+	case -ETIMEDOUT:	/* Should never happen, but... */
+		usbhid_mark_busy(usbhid);
+		clear_bit(HID_IN_RUNNING, &usbhid->iofl);
+		hid_io_error(hid);
+		return;
+	default:		/* error */
+		dev_warn(&urb->dev->dev, "input irq status %d  "
+				"received\n", urb->status);
+	}
+
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status) {
+		clear_bit(HID_IN_RUNNING, &usbhid->iofl);
+		if (status != -EPERM) {
+			err_hid("can't resubmit intr, %s-%s/input%d, status %d",
+					hid_to_usb_dev(hid)->bus->bus_name,
+					hid_to_usb_dev(hid)->devpath,
+					usbhid->ifnum, status);
+			hid_io_error(hid);
+		}
+	}}
+
+static int hid_submit_out(struct hid_device *hid)
+{
+	struct hid_report *report;
+	char *raw_report;
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	report = usbhid->out[usbhid->outtail].report;
+	raw_report = usbhid->out[usbhid->outtail].raw_report;
+
+	if (!test_bit(HID_REPORTED_IDLE, &usbhid->iofl)) {
+		usbhid->urbout->transfer_buffer_length = ((report->size - 1) >> 3) + 1 + (report->id > 0);
+		usbhid->urbout->dev = hid_to_usb_dev(hid);
+		memcpy(usbhid->outbuf, raw_report, usbhid->urbout->transfer_buffer_length);
+		kfree(raw_report);
+
+		dbg_hid("submitting out urb\n");
+
+		if (usb_submit_urb(usbhid->urbout, GFP_ATOMIC)) {
+			err_hid("usb_submit_urb(out) failed");
+			return -1;
+		}
+		usbhid->last_out = jiffies;
+	} else {
+		/*
+		 * queue work to wake up the device.
+		 * as the work queue is freezeable, this is safe
+		 * with respect to STD and STR
+		 */
+		queue_work(resumption_waker, &usbhid->restart_work);
+	}
+
+	return 0;
+}
+
+static int hid_submit_ctrl(struct hid_device *hid)
+{
+	struct hid_report *report;
+	unsigned char dir;
+	char *raw_report;
+	int len;
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	report = usbhid->ctrl[usbhid->ctrltail].report;
+	raw_report = usbhid->ctrl[usbhid->ctrltail].raw_report;
+	dir = usbhid->ctrl[usbhid->ctrltail].dir;
+
+	if (!test_bit(HID_REPORTED_IDLE, &usbhid->iofl)) {
+		len = ((report->size - 1) >> 3) + 1 + (report->id > 0);
+		if (dir == USB_DIR_OUT) {
+			usbhid->urbctrl->pipe = usb_sndctrlpipe(hid_to_usb_dev(hid), 0);
+			usbhid->urbctrl->transfer_buffer_length = len;
+			memcpy(usbhid->ctrlbuf, raw_report, len);
+			kfree(raw_report);
+		} else {
+			int maxpacket, padlen;
+
+			usbhid->urbctrl->pipe = usb_rcvctrlpipe(hid_to_usb_dev(hid), 0);
+			maxpacket = usb_maxpacket(hid_to_usb_dev(hid), usbhid->urbctrl->pipe, 0);
+			if (maxpacket > 0) {
+				padlen = DIV_ROUND_UP(len, maxpacket);
+				padlen *= maxpacket;
+				if (padlen > usbhid->bufsize)
+					padlen = usbhid->bufsize;
+			} else
+				padlen = 0;
+			usbhid->urbctrl->transfer_buffer_length = padlen;
+		}
+		usbhid->urbctrl->dev = hid_to_usb_dev(hid);
+
+		usbhid->cr->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE | dir;
+		usbhid->cr->bRequest = (dir == USB_DIR_OUT) ? HID_REQ_SET_REPORT : HID_REQ_GET_REPORT;
+		usbhid->cr->wValue = cpu_to_le16(((report->type + 1) << 8) | report->id);
+		usbhid->cr->wIndex = cpu_to_le16(usbhid->ifnum);
+		usbhid->cr->wLength = cpu_to_le16(len);
+
+		dbg_hid("submitting ctrl urb: %s wValue=0x%04x wIndex=0x%04x wLength=%u\n",
+			usbhid->cr->bRequest == HID_REQ_SET_REPORT ? "Set_Report" : "Get_Report",
+			usbhid->cr->wValue, usbhid->cr->wIndex, usbhid->cr->wLength);
+
+		if (usb_submit_urb(usbhid->urbctrl, GFP_ATOMIC)) {
+			err_hid("usb_submit_urb(ctrl) failed");
+			return -1;
+		}
+		usbhid->last_ctrl = jiffies;
+	} else {
+		/*
+		 * queue work to wake up the device.
+		 * as the work queue is freezeable, this is safe
+		 * with respect to STD and STR
+		 */
+		queue_work(resumption_waker, &usbhid->restart_work);
+	}
+
+	return 0;
+}
+
+/*
+ * Output interrupt completion handler.
+ */
+
+static void hid_irq_out(struct urb *urb)
+{
+	struct hid_device *hid = urb->context;
+	struct usbhid_device *usbhid = hid->driver_data;
+	unsigned long flags;
+	int unplug = 0;
+
+	switch (urb->status) {
+	case 0:			/* success */
+		break;
+	case -ESHUTDOWN:	/* unplug */
+		unplug = 1;
+	case -EILSEQ:		/* protocol error or unplug */
+	case -EPROTO:		/* protocol error or unplug */
+	case -ECONNRESET:	/* unlink */
+	case -ENOENT:
+		break;
+	default:		/* error */
+		dev_warn(&urb->dev->dev, "output irq status %d "
+				"received\n", urb->status);
+	}
+
+	spin_lock_irqsave(&usbhid->lock, flags);
+
+	if (unplug)
+		usbhid->outtail = usbhid->outhead;
+	else
+		usbhid->outtail = (usbhid->outtail + 1) & (HID_OUTPUT_FIFO_SIZE - 1);
+
+	if (usbhid->outhead != usbhid->outtail) {
+		if (hid_submit_out(hid)) {
+			clear_bit(HID_OUT_RUNNING, &usbhid->iofl);
+			wake_up(&usbhid->wait);
+		}
+		spin_unlock_irqrestore(&usbhid->lock, flags);
+		return;
+	}
+
+	clear_bit(HID_OUT_RUNNING, &usbhid->iofl);
+	spin_unlock_irqrestore(&usbhid->lock, flags);
+	wake_up(&usbhid->wait);
+}
+
+/*
+ * Control pipe completion handler.
+ */
+
+static void hid_ctrl(struct urb *urb)
+{
+	struct hid_device *hid = urb->context;
+	struct usbhid_device *usbhid = hid->driver_data;
+	int unplug = 0, status = urb->status;
+
+	spin_lock(&usbhid->lock);
+
+	switch (status) {
+	case 0:			/* success */
+		if (usbhid->ctrl[usbhid->ctrltail].dir == USB_DIR_IN)
+			hid_input_report(urb->context,
+				usbhid->ctrl[usbhid->ctrltail].report->type,
+				urb->transfer_buffer, urb->actual_length, 0);
+		break;
+	case -ESHUTDOWN:	/* unplug */
+		unplug = 1;
+	case -EILSEQ:		/* protocol error or unplug */
+	case -EPROTO:		/* protocol error or unplug */
+	case -ECONNRESET:	/* unlink */
+	case -ENOENT:
+	case -EPIPE:		/* report not available */
+		break;
+	default:		/* error */
+		dev_warn(&urb->dev->dev, "ctrl urb status %d "
+				"received\n", status);
+	}
+
+	if (unplug)
+		usbhid->ctrltail = usbhid->ctrlhead;
+	else
+		usbhid->ctrltail = (usbhid->ctrltail + 1) & (HID_CONTROL_FIFO_SIZE - 1);
+
+	if (usbhid->ctrlhead != usbhid->ctrltail) {
+		if (hid_submit_ctrl(hid)) {
+			clear_bit(HID_CTRL_RUNNING, &usbhid->iofl);
+			wake_up(&usbhid->wait);
+		}
+		spin_unlock(&usbhid->lock);
+		return;
+	}
+
+	clear_bit(HID_CTRL_RUNNING, &usbhid->iofl);
+	spin_unlock(&usbhid->lock);
+	wake_up(&usbhid->wait);
+}
+
+static void __usbhid_submit_report(struct hid_device *hid, struct hid_report *report,
+				   unsigned char dir)
+{
+	int head;
+	struct usbhid_device *usbhid = hid->driver_data;
+	int len = ((report->size - 1) >> 3) + 1 + (report->id > 0);
+
+	if ((hid->quirks & HID_QUIRK_NOGET) && dir == USB_DIR_IN)
+		return;
+
+	if (usbhid->urbout && dir == USB_DIR_OUT && report->type == HID_OUTPUT_REPORT) {
+		if ((head = (usbhid->outhead + 1) & (HID_OUTPUT_FIFO_SIZE - 1)) == usbhid->outtail) {
+			dev_warn(&hid->dev, "output queue full\n");
+			return;
+		}
+
+		usbhid->out[usbhid->outhead].raw_report = kmalloc(len, GFP_ATOMIC);
+		if (!usbhid->out[usbhid->outhead].raw_report) {
+			dev_warn(&hid->dev, "output queueing failed\n");
+			return;
+		}
+		hid_output_report(report, usbhid->out[usbhid->outhead].raw_report);
+		usbhid->out[usbhid->outhead].report = report;
+		usbhid->outhead = head;
+
+		if (!test_and_set_bit(HID_OUT_RUNNING, &usbhid->iofl)) {
+			if (hid_submit_out(hid))
+				clear_bit(HID_OUT_RUNNING, &usbhid->iofl);
+		} else {
+			/*
+			 * the queue is known to run
+			 * but an earlier request may be stuck
+			 * we may need to time out
+			 * no race because this is called under
+			 * spinlock
+			 */
+			if (time_after(jiffies, usbhid->last_out + HZ * 5))
+				usb_unlink_urb(usbhid->urbout);
+		}
+		return;
+	}
+
+	if ((head = (usbhid->ctrlhead + 1) & (HID_CONTROL_FIFO_SIZE - 1)) == usbhid->ctrltail) {
+		dev_warn(&hid->dev, "control queue full\n");
+		return;
+	}
+
+	if (dir == USB_DIR_OUT) {
+		usbhid->ctrl[usbhid->ctrlhead].raw_report = kmalloc(len, GFP_ATOMIC);
+		if (!usbhid->ctrl[usbhid->ctrlhead].raw_report) {
+			dev_warn(&hid->dev, "control queueing failed\n");
+			return;
+		}
+		hid_output_report(report, usbhid->ctrl[usbhid->ctrlhead].raw_report);
+	}
+	usbhid->ctrl[usbhid->ctrlhead].report = report;
+	usbhid->ctrl[usbhid->ctrlhead].dir = dir;
+	usbhid->ctrlhead = head;
+
+	if (!test_and_set_bit(HID_CTRL_RUNNING, &usbhid->iofl)) {
+		if (hid_submit_ctrl(hid))
+			clear_bit(HID_CTRL_RUNNING, &usbhid->iofl);
+	} else {
+		/*
+		 * the queue is known to run
+		 * but an earlier request may be stuck
+		 * we may need to time out
+		 * no race because this is called under
+		 * spinlock
+		 */
+		if (time_after(jiffies, usbhid->last_ctrl + HZ * 5))
+			usb_unlink_urb(usbhid->urbctrl);
+	}
+}
+
+void usbhid_submit_report(struct hid_device *hid, struct hid_report *report, unsigned char dir)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&usbhid->lock, flags);
+	__usbhid_submit_report(hid, report, dir);
+	spin_unlock_irqrestore(&usbhid->lock, flags);
+}
+EXPORT_SYMBOL_GPL(usbhid_submit_report);
+
+static int usb_hidinput_input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct usbhid_device *usbhid = hid->driver_data;
+	struct hid_field *field;
+	unsigned long flags;
+	int offset;
+
+	//MHAWB_SUPPORT
+	printk(KERN_ERR "usb_hid t:%x c:%x v:%x", (int)type, (int)code, (int)value); 
+
+	if (type == EV_FF)
+		return input_ff_event(dev, type, code, value);
+
+	if (type != EV_LED)
+		return -1;
+
+	if ((offset = hidinput_find_field(hid, type, code, &field)) == -1) {
+		dev_warn(&dev->dev, "event field not found\n");
+		return -1;
+	}
+
+	hid_set_field(field, offset, value);
+	if (value) {
+		spin_lock_irqsave(&usbhid->lock, flags);
+		usbhid->ledcount++;
+		spin_unlock_irqrestore(&usbhid->lock, flags);
+	} else {
+		spin_lock_irqsave(&usbhid->lock, flags);
+		usbhid->ledcount--;
+		spin_unlock_irqrestore(&usbhid->lock, flags);
+	}
+	usbhid_submit_report(hid, field->report, USB_DIR_OUT);
+
+	return 0;
+}
+
+int usbhid_wait_io(struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	if (!wait_event_timeout(usbhid->wait,
+				(!test_bit(HID_CTRL_RUNNING, &usbhid->iofl) &&
+				!test_bit(HID_OUT_RUNNING, &usbhid->iofl)),
+					10*HZ)) {
+		dbg_hid("timeout waiting for ctrl or out queue to clear\n");
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usbhid_wait_io);
+
+static int hid_set_idle(struct usb_device *dev, int ifnum, int report, int idle)
+{
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+		HID_REQ_SET_IDLE, USB_TYPE_CLASS | USB_RECIP_INTERFACE, (idle << 8) | report,
+		ifnum, NULL, 0, USB_CTRL_SET_TIMEOUT);
+}
+
+static int hid_get_class_descriptor(struct usb_device *dev, int ifnum,
+		unsigned char type, void *buf, int size)
+{
+	int result, retries = 4;
+
+	memset(buf, 0, size);
+
+	do {
+		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+				USB_REQ_GET_DESCRIPTOR, USB_RECIP_INTERFACE | USB_DIR_IN,
+				(type << 8), ifnum, buf, size, USB_CTRL_GET_TIMEOUT);
+		retries--;
+	} while (result < size && retries);
+	return result;
+}
+
+int usbhid_open(struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+	int res;
+
+	mutex_lock(&hid_open_mut);
+	if (!hid->open++) {
+		res = usb_autopm_get_interface(usbhid->intf);
+		/* the device must be awake to reliable request remote wakeup */
+		if (res < 0) {
+			hid->open--;
+			mutex_unlock(&hid_open_mut);
+			return -EIO;
+		}
+		usbhid->intf->needs_remote_wakeup = 1;
+		if (hid_start_in(hid))
+			hid_io_error(hid);
+ 
+		usb_autopm_put_interface(usbhid->intf);
+	}
+	mutex_unlock(&hid_open_mut);
+	return 0;
+}
+
+void usbhid_close(struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	mutex_lock(&hid_open_mut);
+
+	/* protecting hid->open to make sure we don't restart
+	 * data acquistion due to a resumption we no longer
+	 * care about
+	 */
+	spin_lock_irq(&usbhid->lock);
+	if (!--hid->open) {
+		spin_unlock_irq(&usbhid->lock);
+		hid_cancel_delayed_stuff(usbhid);
+		usb_kill_urb(usbhid->urbin);
+		usbhid->intf->needs_remote_wakeup = 0;
+	} else {
+		spin_unlock_irq(&usbhid->lock);
+	}
+	mutex_unlock(&hid_open_mut);
+}
+
+/*
+ * Initialize all reports
+ */
+
+void usbhid_init_reports(struct hid_device *hid)
+{
+	struct hid_report *report;
+	struct usbhid_device *usbhid = hid->driver_data;
+	int err, ret;
+
+	list_for_each_entry(report, &hid->report_enum[HID_INPUT_REPORT].report_list, list)
+		usbhid_submit_report(hid, report, USB_DIR_IN);
+
+	list_for_each_entry(report, &hid->report_enum[HID_FEATURE_REPORT].report_list, list)
+		usbhid_submit_report(hid, report, USB_DIR_IN);
+
+	err = 0;
+	ret = usbhid_wait_io(hid);
+	while (ret) {
+		err |= ret;
+		if (test_bit(HID_CTRL_RUNNING, &usbhid->iofl))
+			usb_kill_urb(usbhid->urbctrl);
+		if (test_bit(HID_OUT_RUNNING, &usbhid->iofl))
+			usb_kill_urb(usbhid->urbout);
+		ret = usbhid_wait_io(hid);
+	}
+
+	if (err)
+		dev_warn(&hid->dev, "timeout initializing reports\n");
+}
+
+/*
+ * Reset LEDs which BIOS might have left on. For now, just NumLock (0x01).
+ */
+static int hid_find_field_early(struct hid_device *hid, unsigned int page,
+    unsigned int hid_code, struct hid_field **pfield)
+{
+	struct hid_report *report;
+	struct hid_field *field;
+	struct hid_usage *usage;
+	int i, j;
+
+	list_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {
+		for (i = 0; i < report->maxfield; i++) {
+			field = report->field[i];
+			for (j = 0; j < field->maxusage; j++) {
+				usage = &field->usage[j];
+				if ((usage->hid & HID_USAGE_PAGE) == page &&
+				    (usage->hid & 0xFFFF) == hid_code) {
+					*pfield = field;
+					return j;
+				}
+			}
+		}
+	}
+	return -1;
+}
+
+void usbhid_set_leds(struct hid_device *hid)
+{
+	struct hid_field *field;
+	int offset;
+
+	if ((offset = hid_find_field_early(hid, HID_UP_LED, 0x01, &field)) != -1) {
+		hid_set_field(field, offset, 0);
+		usbhid_submit_report(hid, field->report, USB_DIR_OUT);
+	}
+}
+EXPORT_SYMBOL_GPL(usbhid_set_leds);
+
+/*
+ * Traverse the supplied list of reports and find the longest
+ */
+static void hid_find_max_report(struct hid_device *hid, unsigned int type,
+		unsigned int *max)
+{
+	struct hid_report *report;
+	unsigned int size;
+
+	list_for_each_entry(report, &hid->report_enum[type].report_list, list) {
+		size = ((report->size - 1) >> 3) + 1 + hid->report_enum[type].numbered;
+		if (*max < size)
+			*max = size;
+	}
+}
+
+static int hid_alloc_buffers(struct usb_device *dev, struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	usbhid->inbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,
+			&usbhid->inbuf_dma);
+	usbhid->outbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,
+			&usbhid->outbuf_dma);
+	usbhid->cr = kmalloc(sizeof(*usbhid->cr), GFP_KERNEL);
+	usbhid->ctrlbuf = usb_alloc_coherent(dev, usbhid->bufsize, GFP_KERNEL,
+			&usbhid->ctrlbuf_dma);
+	if (!usbhid->inbuf || !usbhid->outbuf || !usbhid->cr ||
+			!usbhid->ctrlbuf)
+		return -1;
+
+	return 0;
+}
+
+static int usbhid_output_raw_report(struct hid_device *hid, __u8 *buf, size_t count,
+		unsigned char report_type)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+	struct usb_device *dev = hid_to_usb_dev(hid);
+	struct usb_interface *intf = usbhid->intf;
+	struct usb_host_interface *interface = intf->cur_altsetting;
+	int ret;
+
+	if (usbhid->urbout && report_type != HID_FEATURE_REPORT) {
+		int actual_length;
+		int skipped_report_id = 0;
+
+		if (buf[0] == 0x0) {
+			/* Don't send the Report ID */
+			buf++;
+			count--;
+			skipped_report_id = 1;
+		}
+		ret = usb_interrupt_msg(dev, usbhid->urbout->pipe,
+			buf, count, &actual_length,
+			USB_CTRL_SET_TIMEOUT);
+		/* return the number of bytes transferred */
+		if (ret == 0) {
+			ret = actual_length;
+			/* count also the report id */
+			if (skipped_report_id)
+				ret++;
+		}
+	} else {
+		int skipped_report_id = 0;
+		int report_id = buf[0];
+		if (buf[0] == 0x0) {
+			/* Don't send the Report ID */
+			buf++;
+			count--;
+			skipped_report_id = 1;
+		}
+		ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			HID_REQ_SET_REPORT,
+			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
+			((report_type + 1) << 8) | report_id,
+			interface->desc.bInterfaceNumber, buf, count,
+			USB_CTRL_SET_TIMEOUT);
+		/* count also the report id, if this was a numbered report. */
+		if (ret > 0 && skipped_report_id)
+			ret++;
+	}
+
+	return ret;
+}
+
+static void usbhid_restart_queues(struct usbhid_device *usbhid)
+{
+	if (usbhid->urbout)
+		usbhid_restart_out_queue(usbhid);
+	usbhid_restart_ctrl_queue(usbhid);
+}
+
+static void __usbhid_restart_queues(struct work_struct *work)
+{
+	struct usbhid_device *usbhid =
+		container_of(work, struct usbhid_device, restart_work);
+	int r;
+
+	r = usb_autopm_get_interface(usbhid->intf);
+	if (r < 0)
+		return;
+	usb_autopm_put_interface(usbhid->intf);
+}
+
+static void hid_free_buffers(struct usb_device *dev, struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	usb_free_coherent(dev, usbhid->bufsize, usbhid->inbuf, usbhid->inbuf_dma);
+	usb_free_coherent(dev, usbhid->bufsize, usbhid->outbuf, usbhid->outbuf_dma);
+	kfree(usbhid->cr);
+	usb_free_coherent(dev, usbhid->bufsize, usbhid->ctrlbuf, usbhid->ctrlbuf_dma);
+}
+
+static int usbhid_parse(struct hid_device *hid)
+{
+	struct usb_interface *intf = to_usb_interface(hid->dev.parent);
+	struct usb_host_interface *interface = intf->cur_altsetting;
+	struct usb_device *dev = interface_to_usbdev (intf);
+	struct hid_descriptor *hdesc;
+	u32 quirks = 0;
+	unsigned int rsize = 0;
+	char *rdesc;
+	int ret, n;
+
+	quirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),
+			le16_to_cpu(dev->descriptor.idProduct));
+
+	if (quirks & HID_QUIRK_IGNORE)
+		return -ENODEV;
+
+	/* Many keyboards and mice don't like to be polled for reports,
+	 * so we will always set the HID_QUIRK_NOGET flag for them. */
+	if (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {
+		if (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||
+			interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)
+				quirks |= HID_QUIRK_NOGET;
+	}
+
+	if (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&
+	    (!interface->desc.bNumEndpoints ||
+	     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {
+		dbg_hid("class descriptor not present\n");
+		return -ENODEV;
+	}
+
+	hid->version = le16_to_cpu(hdesc->bcdHID);
+	hid->country = hdesc->bCountryCode;
+
+	for (n = 0; n < hdesc->bNumDescriptors; n++)
+		if (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)
+			rsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);
+
+	if (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {
+		dbg_hid("weird size of report descriptor (%u)\n", rsize);
+		return -EINVAL;
+	}
+
+	if (!(rdesc = kmalloc(rsize, GFP_KERNEL))) {
+		dbg_hid("couldn't allocate rdesc memory\n");
+		return -ENOMEM;
+	}
+
+	hid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);
+
+	ret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,
+			HID_DT_REPORT, rdesc, rsize);
+	if (ret < 0) {
+		dbg_hid("reading report descriptor failed\n");
+		kfree(rdesc);
+		goto err;
+	}
+
+	ret = hid_parse_report(hid, rdesc, rsize);
+	kfree(rdesc);
+	if (ret) {
+		dbg_hid("parsing report descriptor failed\n");
+		goto err;
+	}
+
+	hid->quirks |= quirks;
+
+	return 0;
+err:
+	return ret;
+}
+
+static int usbhid_start(struct hid_device *hid)
+{
+	struct usb_interface *intf = to_usb_interface(hid->dev.parent);
+	struct usb_host_interface *interface = intf->cur_altsetting;
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usbhid_device *usbhid = hid->driver_data;
+	unsigned int n, insize = 0;
+	int ret;
+
+	clear_bit(HID_DISCONNECTED, &usbhid->iofl);
+
+	usbhid->bufsize = HID_MIN_BUFFER_SIZE;
+	hid_find_max_report(hid, HID_INPUT_REPORT, &usbhid->bufsize);
+	hid_find_max_report(hid, HID_OUTPUT_REPORT, &usbhid->bufsize);
+	hid_find_max_report(hid, HID_FEATURE_REPORT, &usbhid->bufsize);
+
+	if (usbhid->bufsize > HID_MAX_BUFFER_SIZE)
+		usbhid->bufsize = HID_MAX_BUFFER_SIZE;
+
+	hid_find_max_report(hid, HID_INPUT_REPORT, &insize);
+
+	if (insize > HID_MAX_BUFFER_SIZE)
+		insize = HID_MAX_BUFFER_SIZE;
+
+	if (hid_alloc_buffers(dev, hid)) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	for (n = 0; n < interface->desc.bNumEndpoints; n++) {
+		struct usb_endpoint_descriptor *endpoint;
+		int pipe;
+		int interval;
+
+		endpoint = &interface->endpoint[n].desc;
+		if (!usb_endpoint_xfer_int(endpoint))
+			continue;
+
+		interval = endpoint->bInterval;
+
+		/* Some vendors give fullspeed interval on highspeed devides */
+		if (hid->quirks & HID_QUIRK_FULLSPEED_INTERVAL &&
+		    dev->speed == USB_SPEED_HIGH) {
+			interval = fls(endpoint->bInterval*8);
+			printk(KERN_INFO "%s: Fixing fullspeed to highspeed interval: %d -> %d\n",
+			       hid->name, endpoint->bInterval, interval);
+		}
+
+		/* Change the polling interval of mice. */
+		if (hid->collection->usage == HID_GD_MOUSE && hid_mousepoll_interval > 0)
+			interval = hid_mousepoll_interval;
+
+		ret = -ENOMEM;
+		if (usb_endpoint_dir_in(endpoint)) {
+			if (usbhid->urbin)
+				continue;
+			if (!(usbhid->urbin = usb_alloc_urb(0, GFP_KERNEL)))
+				goto fail;
+			pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);
+			usb_fill_int_urb(usbhid->urbin, dev, pipe, usbhid->inbuf, insize,
+					 hid_irq_in, hid, interval);
+			usbhid->urbin->transfer_dma = usbhid->inbuf_dma;
+			usbhid->urbin->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+		} else {
+			if (usbhid->urbout)
+				continue;
+			if (!(usbhid->urbout = usb_alloc_urb(0, GFP_KERNEL)))
+				goto fail;
+			pipe = usb_sndintpipe(dev, endpoint->bEndpointAddress);
+			usb_fill_int_urb(usbhid->urbout, dev, pipe, usbhid->outbuf, 0,
+					 hid_irq_out, hid, interval);
+			usbhid->urbout->transfer_dma = usbhid->outbuf_dma;
+			usbhid->urbout->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+		}
+	}
+
+	usbhid->urbctrl = usb_alloc_urb(0, GFP_KERNEL);
+	if (!usbhid->urbctrl) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	usb_fill_control_urb(usbhid->urbctrl, dev, 0, (void *) usbhid->cr,
+			     usbhid->ctrlbuf, 1, hid_ctrl, hid);
+	usbhid->urbctrl->transfer_dma = usbhid->ctrlbuf_dma;
+	usbhid->urbctrl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	if (!(hid->quirks & HID_QUIRK_NO_INIT_REPORTS))
+		usbhid_init_reports(hid);
+
+	set_bit(HID_STARTED, &usbhid->iofl);
+
+	/* Some keyboards don't work until their LEDs have been set.
+	 * Since BIOSes do set the LEDs, it must be safe for any device
+	 * that supports the keyboard boot protocol.
+	 * In addition, enable remote wakeup by default for all keyboard
+	 * devices supporting the boot protocol.
+	 */
+	if (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT &&
+			interface->desc.bInterfaceProtocol ==
+				USB_INTERFACE_PROTOCOL_KEYBOARD) {
+		usbhid_set_leds(hid);
+		device_set_wakeup_enable(&dev->dev, 1);
+	}
+	return 0;
+
+fail:
+	usb_free_urb(usbhid->urbin);
+	usb_free_urb(usbhid->urbout);
+	usb_free_urb(usbhid->urbctrl);
+	usbhid->urbin = NULL;
+	usbhid->urbout = NULL;
+	usbhid->urbctrl = NULL;
+	hid_free_buffers(dev, hid);
+	return ret;
+}
+
+static void usbhid_stop(struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	if (WARN_ON(!usbhid))
+		return;
+
+	clear_bit(HID_STARTED, &usbhid->iofl);
+	spin_lock_irq(&usbhid->lock);	/* Sync with error handler */
+	set_bit(HID_DISCONNECTED, &usbhid->iofl);
+	spin_unlock_irq(&usbhid->lock);
+	usb_kill_urb(usbhid->urbin);
+	usb_kill_urb(usbhid->urbout);
+	usb_kill_urb(usbhid->urbctrl);
+
+	hid_cancel_delayed_stuff(usbhid);
+
+	hid->claimed = 0;
+
+	usb_free_urb(usbhid->urbin);
+	usb_free_urb(usbhid->urbctrl);
+	usb_free_urb(usbhid->urbout);
+	usbhid->urbin = NULL; /* don't mess up next start */
+	usbhid->urbctrl = NULL;
+	usbhid->urbout = NULL;
+
+	hid_free_buffers(hid_to_usb_dev(hid), hid);
+}
+
+static int usbhid_power(struct hid_device *hid, int lvl)
+{
+	int r = 0;
+
+	switch (lvl) {
+	case PM_HINT_FULLON:
+		r = usbhid_get_power(hid);
+		break;
+	case PM_HINT_NORMAL:
+		usbhid_put_power(hid);
+		break;
+	}
+	return r;
+}
+
+static struct hid_ll_driver usb_hid_driver = {
+	.parse = usbhid_parse,
+	.start = usbhid_start,
+	.stop = usbhid_stop,
+	.open = usbhid_open,
+	.close = usbhid_close,
+	.power = usbhid_power,
+	.hidinput_input_event = usb_hidinput_input_event,
+};
+
+static int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_host_interface *interface = intf->cur_altsetting;
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usbhid_device *usbhid;
+	struct hid_device *hid;
+	unsigned int n, has_in = 0;
+	size_t len;
+	int ret;
+
+	dbg_hid("HID probe called for ifnum %d\n",
+			intf->altsetting->desc.bInterfaceNumber);
+
+	for (n = 0; n < interface->desc.bNumEndpoints; n++)
+		if (usb_endpoint_is_int_in(&interface->endpoint[n].desc))
+			has_in++;
+	if (!has_in) {
+		dev_err(&intf->dev, "couldn't find an input interrupt "
+				"endpoint\n");
+		return -ENODEV;
+	}
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid))
+		return PTR_ERR(hid);
+
+	usb_set_intfdata(intf, hid);
+	hid->ll_driver = &usb_hid_driver;
+	hid->hid_output_raw_report = usbhid_output_raw_report;
+	hid->ff_init = hid_pidff_init;
+#ifdef CONFIG_USB_HIDDEV
+	hid->hiddev_connect = hiddev_connect;
+	hid->hiddev_disconnect = hiddev_disconnect;
+	hid->hiddev_hid_event = hiddev_hid_event;
+	hid->hiddev_report_event = hiddev_report_event;
+#endif
+	hid->dev.parent = &intf->dev;
+	hid->bus = BUS_USB;
+	hid->vendor = le16_to_cpu(dev->descriptor.idVendor);
+	hid->product = le16_to_cpu(dev->descriptor.idProduct);
+	hid->name[0] = 0;
+	hid->quirks = usbhid_lookup_quirk(hid->vendor, hid->product);
+	if (intf->cur_altsetting->desc.bInterfaceProtocol ==
+			USB_INTERFACE_PROTOCOL_MOUSE)
+		hid->type = HID_TYPE_USBMOUSE;
+
+	if (dev->manufacturer)
+		strlcpy(hid->name, dev->manufacturer, sizeof(hid->name));
+
+	if (dev->product) {
+		if (dev->manufacturer)
+			strlcat(hid->name, " ", sizeof(hid->name));
+		strlcat(hid->name, dev->product, sizeof(hid->name));
+	}
+
+	if (!strlen(hid->name))
+		snprintf(hid->name, sizeof(hid->name), "HID %04x:%04x",
+			 le16_to_cpu(dev->descriptor.idVendor),
+			 le16_to_cpu(dev->descriptor.idProduct));
+
+	usb_make_path(dev, hid->phys, sizeof(hid->phys));
+	strlcat(hid->phys, "/input", sizeof(hid->phys));
+	len = strlen(hid->phys);
+	if (len < sizeof(hid->phys) - 1)
+		snprintf(hid->phys + len, sizeof(hid->phys) - len,
+			 "%d", intf->altsetting[0].desc.bInterfaceNumber);
+
+	if (usb_string(dev, dev->descriptor.iSerialNumber, hid->uniq, 64) <= 0)
+		hid->uniq[0] = 0;
+
+	usbhid = kzalloc(sizeof(*usbhid), GFP_KERNEL);
+	if (usbhid == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	hid->driver_data = usbhid;
+	usbhid->hid = hid;
+	usbhid->intf = intf;
+	usbhid->ifnum = interface->desc.bInterfaceNumber;
+
+	init_waitqueue_head(&usbhid->wait);
+	INIT_WORK(&usbhid->reset_work, hid_reset);
+	INIT_WORK(&usbhid->restart_work, __usbhid_restart_queues);
+	setup_timer(&usbhid->io_retry, hid_retry_timeout, (unsigned long) hid);
+	spin_lock_init(&usbhid->lock);
+
+	ret = hid_add_device(hid);
+	if (ret) {
+		if (ret != -ENODEV)
+			dev_err(&intf->dev, "can't add hid device: %d\n", ret);
+		goto err_free;
+	}
+
+	return 0;
+err_free:
+	kfree(usbhid);
+err:
+	hid_destroy_device(hid);
+	return ret;
+}
+
+static void usbhid_disconnect(struct usb_interface *intf)
+{
+	struct hid_device *hid = usb_get_intfdata(intf);
+	struct usbhid_device *usbhid;
+
+	if (WARN_ON(!hid))
+		return;
+
+	usbhid = hid->driver_data;
+	hid_destroy_device(hid);
+	kfree(usbhid);
+}
+
+static void hid_cancel_delayed_stuff(struct usbhid_device *usbhid)
+{
+	del_timer_sync(&usbhid->io_retry);
+	cancel_work_sync(&usbhid->restart_work);
+	cancel_work_sync(&usbhid->reset_work);
+}
+
+static void hid_cease_io(struct usbhid_device *usbhid)
+{
+	del_timer(&usbhid->io_retry);
+	usb_kill_urb(usbhid->urbin);
+	usb_kill_urb(usbhid->urbctrl);
+	usb_kill_urb(usbhid->urbout);
+}
+
+/* Treat USB reset pretty much the same as suspend/resume */
+static int hid_pre_reset(struct usb_interface *intf)
+{
+	struct hid_device *hid = usb_get_intfdata(intf);
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	spin_lock_irq(&usbhid->lock);
+	set_bit(HID_RESET_PENDING, &usbhid->iofl);
+	spin_unlock_irq(&usbhid->lock);
+	cancel_work_sync(&usbhid->restart_work);
+	hid_cease_io(usbhid);
+
+	return 0;
+}
+
+/* Same routine used for post_reset and reset_resume */
+static int hid_post_reset(struct usb_interface *intf)
+{
+	struct usb_device *dev = interface_to_usbdev (intf);
+	struct hid_device *hid = usb_get_intfdata(intf);
+	struct usbhid_device *usbhid = hid->driver_data;
+	int status;
+
+	spin_lock_irq(&usbhid->lock);
+	clear_bit(HID_RESET_PENDING, &usbhid->iofl);
+	spin_unlock_irq(&usbhid->lock);
+	hid_set_idle(dev, intf->cur_altsetting->desc.bInterfaceNumber, 0, 0);
+	status = hid_start_in(hid);
+	if (status < 0)
+		hid_io_error(hid);
+	usbhid_restart_queues(usbhid);
+
+	return 0;
+}
+
+int usbhid_get_power(struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	return usb_autopm_get_interface(usbhid->intf);
+}
+
+void usbhid_put_power(struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+
+	usb_autopm_put_interface(usbhid->intf);
+}
+
+
+#ifdef CONFIG_PM
+static int hid_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct hid_device *hid = usb_get_intfdata(intf);
+	struct usbhid_device *usbhid = hid->driver_data;
+	int status;
+
+	if (message.event & PM_EVENT_AUTO) {
+		spin_lock_irq(&usbhid->lock);	/* Sync with error handler */
+		if (!test_bit(HID_RESET_PENDING, &usbhid->iofl)
+		    && !test_bit(HID_CLEAR_HALT, &usbhid->iofl)
+		    && !test_bit(HID_OUT_RUNNING, &usbhid->iofl)
+		    && !test_bit(HID_CTRL_RUNNING, &usbhid->iofl)
+		    && !test_bit(HID_KEYS_PRESSED, &usbhid->iofl)
+		    && (!usbhid->ledcount || ignoreled))
+		{
+			set_bit(HID_REPORTED_IDLE, &usbhid->iofl);
+			spin_unlock_irq(&usbhid->lock);
+			if (hid->driver && hid->driver->suspend) {
+				status = hid->driver->suspend(hid, message);
+				if (status < 0)
+					return status;
+			}
+		} else {
+			usbhid_mark_busy(usbhid);
+			spin_unlock_irq(&usbhid->lock);
+			return -EBUSY;
+		}
+
+	} else {
+		if (hid->driver && hid->driver->suspend) {
+			status = hid->driver->suspend(hid, message);
+			if (status < 0)
+				return status;
+		}
+		spin_lock_irq(&usbhid->lock);
+		set_bit(HID_REPORTED_IDLE, &usbhid->iofl);
+		spin_unlock_irq(&usbhid->lock);
+		if (usbhid_wait_io(hid) < 0)
+			return -EIO;
+	}
+
+	if (!ignoreled && (message.event & PM_EVENT_AUTO)) {
+		spin_lock_irq(&usbhid->lock);
+		if (test_bit(HID_LED_ON, &usbhid->iofl)) {
+			spin_unlock_irq(&usbhid->lock);
+			usbhid_mark_busy(usbhid);
+			return -EBUSY;
+		}
+		spin_unlock_irq(&usbhid->lock);
+	}
+
+	hid_cancel_delayed_stuff(usbhid);
+	hid_cease_io(usbhid);
+
+	if ((message.event & PM_EVENT_AUTO) &&
+			test_bit(HID_KEYS_PRESSED, &usbhid->iofl)) {
+		/* lost race against keypresses */
+		status = hid_start_in(hid);
+		if (status < 0)
+			hid_io_error(hid);
+		usbhid_mark_busy(usbhid);
+		return -EBUSY;
+	}
+	dev_dbg(&intf->dev, "suspend\n");
+	return 0;
+}
+
+static int hid_resume(struct usb_interface *intf)
+{
+	struct hid_device *hid = usb_get_intfdata (intf);
+	struct usbhid_device *usbhid = hid->driver_data;
+	int status;
+
+	if (!test_bit(HID_STARTED, &usbhid->iofl))
+		return 0;
+
+	clear_bit(HID_REPORTED_IDLE, &usbhid->iofl);
+	usbhid_mark_busy(usbhid);
+
+	if (test_bit(HID_CLEAR_HALT, &usbhid->iofl) ||
+	    test_bit(HID_RESET_PENDING, &usbhid->iofl))
+		schedule_work(&usbhid->reset_work);
+	usbhid->retry_delay = 0;
+	status = hid_start_in(hid);
+	if (status < 0)
+		hid_io_error(hid);
+	usbhid_restart_queues(usbhid);
+
+	if (status >= 0 && hid->driver && hid->driver->resume) {
+		int ret = hid->driver->resume(hid);
+		if (ret < 0)
+			status = ret;
+	}
+	dev_dbg(&intf->dev, "resume status %d\n", status);
+	return 0;
+}
+
+static int hid_reset_resume(struct usb_interface *intf)
+{
+	struct hid_device *hid = usb_get_intfdata(intf);
+	struct usbhid_device *usbhid = hid->driver_data;
+	int status;
+
+	clear_bit(HID_REPORTED_IDLE, &usbhid->iofl);
+	status = hid_post_reset(intf);
+	if (status >= 0 && hid->driver && hid->driver->reset_resume) {
+		int ret = hid->driver->reset_resume(hid);
+		if (ret < 0)
+			status = ret;
+	}
+	return status;
+}
+
+#endif /* CONFIG_PM */
+
+static const struct usb_device_id hid_usb_ids[] = {
+	{ .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,
+		.bInterfaceClass = USB_INTERFACE_CLASS_HID },
+	{ }						/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, hid_usb_ids);
+
+static struct usb_driver hid_driver = {
+	.name =		"usbhid",
+	.probe =	usbhid_probe,
+	.disconnect =	usbhid_disconnect,
+#ifdef CONFIG_PM
+	.suspend =	hid_suspend,
+	.resume =	hid_resume,
+	.reset_resume =	hid_reset_resume,
+#endif
+	.pre_reset =	hid_pre_reset,
+	.post_reset =	hid_post_reset,
+	.id_table =	hid_usb_ids,
+	.supports_autosuspend = 1,
+};
+
+static const struct hid_device_id hid_usb_table[] = {
+	{ HID_USB_DEVICE(HID_ANY_ID, HID_ANY_ID) },
+	{ }
+};
+
+struct usb_interface *usbhid_find_interface(int minor)
+{
+	return usb_find_interface(&hid_driver, minor);
+}
+
+static struct hid_driver hid_usb_driver = {
+	.name = "generic-usb",
+	.id_table = hid_usb_table,
+};
+
+static int __init hid_init(void)
+{
+	int retval = -ENOMEM;
+
+	resumption_waker = create_freezeable_workqueue("usbhid_resumer");
+	if (!resumption_waker)
+		goto no_queue;
+	retval = hid_register_driver(&hid_usb_driver);
+	if (retval)
+		goto hid_register_fail;
+	retval = usbhid_quirks_init(quirks_param);
+	if (retval)
+		goto usbhid_quirks_init_fail;
+	retval = usb_register(&hid_driver);
+	if (retval)
+		goto usb_register_fail;
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
+
+	return 0;
+usb_register_fail:
+	usbhid_quirks_exit();
+usbhid_quirks_init_fail:
+	hid_unregister_driver(&hid_usb_driver);
+hid_register_fail:
+	destroy_workqueue(resumption_waker);
+no_queue:
+	return retval;
+}
+
+static void __exit hid_exit(void)
+{
+	usb_deregister(&hid_driver);
+	usbhid_quirks_exit();
+	hid_unregister_driver(&hid_usb_driver);
+	destroy_workqueue(resumption_waker);
+}
+
+module_init(hid_init);
+module_exit(hid_exit);
+
+MODULE_AUTHOR("Andreas Gal");
+MODULE_AUTHOR("Vojtech Pavlik");
+MODULE_AUTHOR("Jiri Kosina");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE(DRIVER_LICENSE);
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal.h
new file mode 100755
index 000000000000..ab1d0057d94c
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal.h
@@ -0,0 +1,658 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+
+/**
+ * @file sii_hal.h
+ *
+ * @brief Defines the hardware / OS abstraction layer API used by Silicon
+ *        Image MHL drivers.
+ *
+ * $Author: Dave Canfield
+ * $Rev: $
+ * $Date: Jan. 24, 2011
+ *
+ *****************************************************************************/
+
+#if !defined(SII_HAL_H)
+#define SII_HAL_H
+
+#include <linux/kernel.h>
+#include "osal/include/osal.h"
+#include "si_osdebug.h"
+
+#ifdef __cplusplus 
+extern "C" { 
+#endif  /* _defined (__cplusplus) */
+
+#ifndef	FALSE
+#define	FALSE	false
+#endif
+
+#ifndef	TRUE
+#define	TRUE	true
+#endif
+
+#define ENABLE      (1)
+#define DISABLE     (0)
+
+#define ON  true
+#define OFF false
+
+#define SET_BITS    0xFF
+#define CLEAR_BITS  0x00
+
+#ifndef	BIT_0
+#define	BIT_0	(1 << 0)
+#define	BIT_1	(1 << 1)
+#define	BIT_2	(1 << 2)
+#define	BIT_3	(1 << 3)
+#define	BIT_4	(1 << 4)
+#define	BIT_5	(1 << 5)
+#define	BIT_6	(1 << 6)
+#define	BIT_7	(1 << 7)
+#endif
+
+#ifndef	BIT0
+#define	BIT0	BIT_0
+#define	BIT1	BIT_1
+#define	BIT2	BIT_2
+#define	BIT3	BIT_3
+#define	BIT4	BIT_4
+#define	BIT5	BIT_5
+#define	BIT6	BIT_6
+#define	BIT7	BIT_7
+#endif
+
+typedef char            int_t;    // Eight-bit processor only
+typedef unsigned char   uint_t;   // Eight-bit processor only
+typedef unsigned char   bit_fld_t;
+typedef unsigned long   clock_time_t;   // The clock type used for returning system ticks (1ms).
+typedef unsigned short  time_ms_t;      // Time in milliseconds
+
+/***** public type definitions ***********************************************/
+
+/**
+ * @defgroup sii_hal_api Hardware Abstraction Layer (HAL) API
+ * @{
+ */
+
+/**
+ *  Signature of interrupt handler function used by the driver layer code.
+ */
+typedef void (*fwIrqHandler_t)(void);
+typedef uint8_t (*fnCheckDevice)(uint8_t dev);
+
+#if defined(ROM)
+#undef	ROM
+#endif
+
+#define	ROM /*nothing*/
+
+/** @brief Define signature of timer callback function used by
+ * HalRequestTimerCallback().
+ */
+typedef void (*timerCallbackHandler_t)(void *);
+
+
+/** Status return value type for HAL module functions.*/
+typedef enum
+{
+    HAL_RET_SUCCESS,			/**< The operation was successfully completed */
+    HAL_RET_FAILURE,			/**< Generic error */
+    HAL_RET_PARAMETER_ERROR,	/**< Invalid parameter passed to a HAL function */
+    HAL_RET_NO_DEVICE,			/**< Indicates that the specified hardware device was not found */
+    HAL_RET_DEVICE_NOT_OPEN,	/**< The specified device is not open for use */
+    HAL_RET_NOT_INITIALIZED,	/**< HAL abstraction layer module has not been initialized*/
+    HAL_RET_OUT_OF_RESOURCES,	/**< Needed resources (memory/hardware) were not available. */
+    HAL_RET_TIMEOUT,			/**< The requested operation timed out */
+    HAL_RET_ALREADY_INITIALIZED /**< HalInit called more than once */
+} halReturn_t;
+
+
+
+/** @brief GPIO pin state definitions taken from the firmware's GPIO header file */
+#define settingMode3X				0
+#define settingMode1X				1
+#define settingMode9290				0
+#define settingMode938x				1
+#define GPIO_PIN_SW5_P4_ENABLED		0
+#define GPIO_PIN_SW5_P4_DISABLED	1
+
+#define		INT_ACTIVE_HIGH					1
+#define		INT_ACTIVE_LOW					0
+#define		INT_ACTIVE_DEFAULT				INT_ACTIVE_LOW					
+#define		INT_IS_ASSERTED					INT_ACTIVE_DEFAULT
+#define		GPIO_INT_PIN					94 // gpiodv_29
+
+typedef enum 
+{
+    GPIO_136 =0x00,
+    GPIO_140,
+    GPIO_INT,
+    GPIO_RST,
+    GPIO_INVALID=0xFF
+}GpioIndex_t;
+
+/***** public function prototypes ********************************************/
+
+
+/*****************************************************************************/
+/**
+ * @brief Initialize the HAL layer module.
+ *
+ *  This function provides the HAL module the opportunity to perform any
+ *  needed initialization and must be called BEFORE any other HAL functions.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				HAL initialization successful
+ *  @retval HAL_RET_ALREADY_INITIALIZED	HAL already initialized
+ *  @retval HAL_RET_FAILURE				An error occurred during initialization
+ *
+ *****************************************************************************/
+halReturn_t HalInit(void);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Terminate access to the hardware abstraction layer.
+ *
+ *  This function must be called when access to the hardware abstraction layer
+ *  support is no longer required, for example when the driver using the services
+ *  of the HAL is being stopped or unloaded. Resources acquired during HalInit
+ *  will be released and any subsequent attempts to call any other HAL function
+ *  (except for HalInit) will result in an HAL_RET_NOT_INITIALIZED error.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				HAL terminated successfully
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (HalInit not called)
+ *
+ *****************************************************************************/
+halReturn_t HalTerm(void);
+
+
+/*****************************************************************************/
+/**
+ * @brief Request access to the specified I2c device.
+ * 
+ *  MHL transmitters are I2c devices which must be successfully opened using
+ *  this function before attempting to use any of the HAL I2c or SMBUS
+ *  communication functions.
+ *
+ *  @param[in]		DeviceName		Name of the I2C device to be opened.
+ *  @param[in]		DriverName		Name of the driver opening the I2C device.
+ *
+ *  @return	status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				MHL transmitter successfully opened
+ *	@retval	HAL_RET_PARAMETER_ERROR		DeviceName too long
+ *	@retval	HAL_RET_NO_DEVICE			DeviceName does not exist
+ *
+ *****************************************************************************/
+halReturn_t HalOpenI2cDevice(char const *DeviceName, char const *DriverName);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Terminate access to an MHL transmitter device.
+ * 
+ *  Called when access to the previously opened I2c device is no longer needed.
+ *  Causes any resources used to communicate with the device to be released.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				MHL transmitter successfully closed
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (need to call HalInit)
+ *  @retval	HAL_RET_DEVICE_NOT_OPEN		MHL transmitter device not currently open
+ *
+ *****************************************************************************/
+halReturn_t HalCloseI2cDevice(void);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Read a byte from an I2c device using SMBus protocol.
+ * 
+ *  Reads a byte from the previously opend I2c device using
+ *  the SMBus Byte Data protocol.
+ *
+ *  @param[in]		command				SMBus command value to send.
+ *  @param[out]		pRetByteRead		Pointer to where the byte read is returned.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				Read successful
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (need to call HalInit)
+ *  @retval	HAL_RET_DEVICE_NOT_OPEN		MHL transmitter device not currently open
+ *  @retval HAL_RET_FAILURE				The SMBus transaction failed.
+ *
+ *****************************************************************************/
+halReturn_t HalSmbusReadByteData(uint8_t command, uint8_t *pRetByteRead);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Write a byte to an I2c device using SMBus protocol.
+ * 
+ *  Writes a byte to the previously opened I2c device using
+ *  the SMBus Byte Data protocol.
+ *
+ *  @param[in]		command				SMBus command value to send.
+ *  @param[in]		writeByte			Byte value to write to I2c device.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				Write successful
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (need to call HalInit)
+ *  @retval	HAL_RET_DEVICE_NOT_OPEN		MHL transmitter device not currently open
+ *  @retval HAL_RET_FAILURE				The SMBus transaction failed.
+ *
+ *****************************************************************************/
+halReturn_t HalSmbusWriteByteData(uint8_t command, uint8_t writeByte);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Read a word from an I2c device using SMBus protocol.
+ * 
+ *  Reads a word from the previously opened I2c device using
+ *  the SMBus Word Data protocol.
+ *
+ *  @param[in]		command				SMBus command value to send.
+ *  @param[out]		pRetWordRead		Pointer to where the word read is returned.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				Read successful
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (need to call HalInit)
+ *  @retval	HAL_RET_DEVICE_NOT_OPEN		MHL transmitter device not currently open
+ *  @retval HAL_RET_FAILURE				The SMBus transaction failed.
+ *
+ *****************************************************************************/
+halReturn_t HalSmbusReadWordData(uint8_t command, uint16_t *pRetWordRead);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Write a word to an I2c device using SMBus protocol.
+ * 
+ *  Writes a word to the previously opened I2c device using
+ *  the SMBus Word Data protocol.
+ *
+ *  @param[in]		command				SMBus command value to send.
+ *  @param[in]		wordData			Word value to write to I2c device.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				Write successful
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (need to call HalInit)
+ *  @retval	HAL_RET_DEVICE_NOT_OPEN		MHL transmitter device not currently open
+ *  @retval HAL_RET_FAILURE				The SMBus transaction failed.
+ *
+ *****************************************************************************/
+halReturn_t HalSmbusWriteWordData(uint8_t command, uint16_t wordData);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Read a series of bytes from an I2c device using SMBus protocol.
+ * 
+ *  Uses the SMbus Block Data protocol to read up to 32 bytes from the
+ *  previously opened I2c device.
+ *
+ *  @param[out]		command				SMBus command value to send.
+ *  @param[out]		buffer				Buffer where data read will be returned.
+ *  @param[in,out]	bufferLen			On input specifies the length of buffer,
+ *  									on return contains number of bytes read.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				Read successful
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (need to call HalInit)
+ *  @retval	HAL_RET_DEVICE_NOT_OPEN		MHL transmitter device not currently open
+ *  @retval HAL_RET_PARAMETER_ERROR		Transfer length too large
+ *  @retval HAL_RET_FAILURE				The SMBus transaction failed.
+ *
+ *****************************************************************************/
+halReturn_t HalSmbusReadBlock(uint8_t command, uint8_t *buffer, uint8_t *bufferLen);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Write a series of bytes to an I2c device using SMBus protocol.
+ * 
+ *  Uses the SMbus Block Data protocol to write up to 32 bytes to the
+ *  previously opened I2c device.
+ *
+ *  @param[in]		command				SMBus command value to send.
+ *  @param[in]		buffer				Buffer containing data to be sent.
+ *  @param[in]		bufferLen			Specifies the length of buffer,
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				Write successful
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (need to call HalInit)
+ *  @retval	HAL_RET_DEVICE_NOT_OPEN		MHL transmitter device not currently open
+ *  @retval HAL_RET_PARAMETER_ERROR		Transfer length too large
+ *  @retval HAL_RET_FAILURE				The SMBus transaction failed.
+ *
+ *****************************************************************************/
+halReturn_t HalSmbusWriteBlock(uint8_t command, uint8_t const *blockData,
+								 uint8_t length);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Write a series of bytes to an I2c device.
+ * 
+ *  This function can write up to 255 bytes to the specified device since it
+ *  does not use the SMBus protocol to perform the transfer.  Also the specified
+ *  i2cAddr does not have to reference an address within the MHL transmitter,
+ *  but the I2c device does need to reside on the same I2c bus as the MHL
+ *  transmitter.
+ *
+ *  @param[in]		i2cAddr				I2c address to write to.
+ *  @param[in]		length				Specifies the length of buffer.
+ *  @param[in]		buffer				Buffer containing data to be sent.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				Write successful
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (need to call HalInit)
+ *  @retval	HAL_RET_DEVICE_NOT_OPEN		MHL transmitter device not currently open
+ *  @retval HAL_RET_FAILURE				The SMBus transaction failed.
+ *
+ *****************************************************************************/
+halReturn_t HalI2cMasterWrite(uint8_t i2cAddr, uint8_t length,
+								uint8_t *buffer);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Read a series of bytes from an I2c device.
+ * 
+ *  This function can write up to 255 bytes to the specified device since it
+ *  does not use the SMBus protocol to perform the transfer.  Also the specified
+ *  i2cAddr does not have to reference an address within the MHL transmitter,
+ *  but the I2c device does need to reside on the same I2c bus as the MHL
+ *  transmitter.
+ *
+ *  @param[in]		i2cAddr				I2c address to write to.
+ *  @param[in]		length				Specifies the length of buffer.
+ *  @param[in]		buffer				Buffer where data read will be returned.
+ *
+ *  @return         status (success or error code)
+ *  @retval	HAL_RET_SUCCESS				Read successful
+ *  @retval HAL_RET_NOT_INITIALIZED		HAL not initialized (need to call HalInit)
+ *  @retval	HAL_RET_DEVICE_NOT_OPEN		MHL transmitter device not currently open
+ *  @retval HAL_RET_PARAMETER_ERROR		Transfer length too large
+ *  @retval HAL_RET_FAILURE				The SMBus transaction failed.
+ *
+ *****************************************************************************/
+halReturn_t HalI2cMasterRead(uint8_t i2cAddr, uint8_t length,
+								uint8_t *buffer);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Read a single byte from a register within an I2c device.
+ *
+ * This function performs an I2c SMB read transfer of a single byte.  The
+ * function assumes that the device address specified is one of the addresses
+ * used by the MHL transmitter.  Trying to use this function to read from any
+ * other I2c device will not work.  Additionally, HalOpenI2cDevice must have
+ * been called before calling this function.
+ *
+ *  @param[in]		deviceID		I2c device address.
+ *  @param[in]		offset			Offset of the I2c register to be read.
+ *
+ *  @return         Byte value read or 0xFF in case of error
+ *
+ *****************************************************************************/
+uint8_t I2C_ReadByte(uint8_t deviceID, uint8_t offset);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Write a single byte to a register within an I2c device.
+ *
+ * This function performs an I2c SMB write transfer of a single byte.  The
+ * function assumes that the device address specified is one of the addresses
+ * used by the MHL transmitter.  Trying to use this function to write to any
+ * other I2c device will not work.  Additionally, HalOpenI2cDevice must have
+ * been called before calling this function.
+ *
+ *  @param[in]		deviceID		I2c device address.
+ *  @param[in]		offset			Offset of the I2c register to be written.
+ *  @param[in]		value			Value to write to register.
+ *
+ *  @return         Nothing.
+ *
+ *****************************************************************************/
+uint8_t I2C_WriteByte(uint8_t deviceID, uint8_t offset, uint8_t value);
+
+
+uint8_t I2C_ReadBlock(uint8_t deviceID, uint8_t offset,uint8_t *buf, uint8_t len);
+/*****************************************************************************/
+/**
+ * @brief Install IRQ handler.
+ *
+ *  This function enables the handling of interrupts from the MHL transmitter.
+ *  The transmitter device must have been successfully opened before attempting
+ *  to enable interrupts.
+ *
+ *  @param[in]		irqHandler	Firmware function to call when an interrupt
+ *  							is received.
+ *
+ *  @return         status (success or error code)
+ *  @retval			HAL_RET_SUCCESS - Interrupt handler successfully installed.
+ *  @retval			HAL_RET_PARAMETER_ERROR - irqHandler parameter is NULL.
+ *  @retval			HAL_RET_DEVICE_NOT_OPEN - MHL transmitter device not opened.
+ *  @retval			HAL_RET_FAILURE - Platform didn't assign an interrupt number
+ *  				or there was an error while attempting to install the handler.
+ *
+ *****************************************************************************/
+halReturn_t HalInstallIrqHandler(fwIrqHandler_t irqHandler);
+
+void HalEnableIrq(uint8_t bEnable);
+/*****************************************************************************/
+/**
+ * @brief Remove IRQ handler.
+ *
+ *  This function un-installs the MHL transmitter device interrupt handler
+ *  installed by HalInstallIrqHandler.
+ *
+ *  @return         status (success or error code)
+ *  @retval			HAL_RET_SUCCESS - Interrupt handler successfully removed.
+ *  @retval			HAL_RET_DEVICE_NOT_OPEN - MHL transmitter device not opened.
+ *  @retval			HAL_RET_FAILURE - Interrupt handler was never installed.
+ *
+ *****************************************************************************/
+halReturn_t HalRemoveIrqHandler(void);
+
+
+/*****************************************************************************/
+/**
+ * @brief Interrupt Pin asserted suppport
+ *
+ *  This function is responsible for return if there's interrupt asserted or not
+ * 
+ *
+ * @return        ture if there's interrupt assserted
+ *
+ *****************************************************************************/
+bool_t is_interrupt_asserted( void );
+
+/*****************************************************************************/
+/**
+ * @brief install CheckDeviceCB
+ *CB function is used to check devic when IRQ handler 
+ *
+ *****************************************************************************/
+halReturn_t HalInstallCheckDeviceCB(fnCheckDevice fn);
+
+
+void    HalTimerInit( void );
+uint32_t HalTimerSysTicks (void);
+/*****************************************************************************/
+/**
+ * @brief Set a timer counter.
+ *
+ * This function can be called to set either one of the count down timers or
+ * one of the elapsed timers.  If index specifies one of the elapsed timers
+ * the timer's count is initialized to zero and the m_sec parameter is used
+ * to set the granularity at which it counts up.  If index specifies one of
+ * the count down timers the m_sec parameter is used to set the initial count
+ * of the timer.
+ *
+ *  @param[in]	index	Indicates which timer counter to set.
+ *  @param[in]	m_sec	Timer counter value to set in milliseconds.
+ *
+ *  @return 	Nothing.
+ *
+ *****************************************************************************/
+void HalTimerSet ( uint8_t index, uint16_t m_sec );
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Wait for the specified number of milliseconds to elapse.
+ *
+ *  @param[in]	m_sec	The number of milliseconds to delay.
+ *
+ * @note: This function may put the calling process to sleep and therefore
+ * must not be called from an interrupt context.
+ *
+ *****************************************************************************/
+void HalTimerWait ( uint16_t m_sec );
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Check if the specified timer has expired.
+ *
+ * This function checks to see if the specified timer has expired yet.  The
+ * timerIndex should specify one of the count down timers and not one of the
+ * elapsed timers.
+ *
+ *  @param[in]	timerIndex	Indicates which timer counter to check.
+ *
+ *  @return 	Non-zero if the timer has expired.
+ *
+ *****************************************************************************/
+uint8_t HalTimerExpired (uint8_t timerIndex);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Read the current value of one of the elapsed timer counters.
+ *
+ * The elapsed timers unlike the other timers count up at a msec. granularity
+ * specified when they are started.  This function returns the current value
+ * of the specified elapsed timer.  The timer count returned needs to be
+ * multiplied by the granularity specified when the timer was set in order
+ * to calculate the elapsed time.
+ *
+ *  @param[in]	elapsedTimerIndex	Indicates which elapsed timer counter
+ *  								to check.
+ *
+ *  @return 	The current value of the timer, or zero if an invalid timer
+ *  			index is specified.
+ *
+ *****************************************************************************/
+uint16_t HalTimerElapsed(uint8_t elapsedTimerIndex);
+
+/*****************************************************************************/
+/**
+ * @brief Platform specific function to set the output pin to control the MHL
+ * 		  transmitter device.
+ *
+ *****************************************************************************/
+halReturn_t HalGpioSetPin(GpioIndex_t gpio,int value);
+
+/*****************************************************************************/
+/**
+ * @brief Platform specific function to get the input pin value of the MHL
+ * 		  transmitter device.
+ *
+ *****************************************************************************/
+halReturn_t HalGpioGetPin(GpioIndex_t gpio,int * value);
+
+/*****************************************************************************/
+/**
+ * @brief get IRQ number from given GPIO index
+ *
+ * 
+ *  @param[in]	gpio		     gpio index
+ *  @param[in]	irqNumber		 irq number pointer.
+ *
+ * @return        status (success or error code)
+ * @retval	HAL_RET_SUCCESS			Pin set to requested value
+ * @retval	HAL_RET_NOT_INITIALIZED	HAL not initialized (HalInit not called)
+ *
+ *****************************************************************************/
+halReturn_t HalGetGpioIrqNumber(GpioIndex_t gpio, unsigned int * irqNumber);
+
+
+halReturn_t HalEnableI2C(int bEnable) ;
+
+/*****************************************************************************/
+/**
+ * @brief Acquire the lock that prevents races with the interrupt handler.
+ *
+ * This lock is acquired by the interrupt handler before calling into the driver
+ * layer.  All calls into the MHL Tx or driver layer code also must first
+ * acquire this lock to prevent race conditions with other threads of execution
+ * that need to execute within these driver layers.
+ *
+ * @return        status (success or error code)
+ * @retval	HAL_RET_SUCCESS			Pin set to requested value
+ * @retval	HAL_RET_NOT_INITIALIZED	HAL not initialized (HalInit not called)
+ * @retval	HAL_RET_FAILURE			Lock acquisition failed
+ *
+ *****************************************************************************/
+halReturn_t HalAcquireIsrLock(void);
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Release the lock that prevents races with the interrupt handler.
+ *
+ * This function releases the lock acquired by HalAcquireIsrLock().
+ *
+ * @return        status (success or error code)
+ * @retval	HAL_RET_SUCCESS			Pin set to requested value
+ * @retval	HAL_RET_NOT_INITIALIZED	HAL not initialized (HalInit not called)
+ *
+ *****************************************************************************/
+halReturn_t HalReleaseIsrLock(void);
+
+/**
+ * @}
+ * end sii_hal_api group
+ */
+
+#ifdef __cplusplus
+}
+#endif  /* _defined (__cplusplus) */
+
+#endif /* _defined (SII_HAL_H) */
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_gpio.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_gpio.c
new file mode 100755
index 000000000000..32473b663401
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_gpio.c
@@ -0,0 +1,430 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+
+/**
+ * @file sii_hal_linux_gpio.c
+ *
+ * @brief Linux implementation of GPIO pin support needed by Silicon Image
+ *        MHL devices.
+ *
+ * $Author: Tiger qin
+ * $Rev: $
+ * $Date: June. 9, 2011
+ *
+ *****************************************************************************/
+
+#define SII_HAL_LINUX_GPIO_C
+
+/***** #include statements ***************************************************/
+#include "sii_hal.h"
+#include "sii_hal_priv.h"
+#include "mhl_linuxdrv.h"
+#include <linux/ioport.h>
+#include <asm/io.h>
+/***** local macro definitions ***********************************************/
+
+
+/***** local type definitions ************************************************/
+
+
+/***** local variable declarations *******************************************/
+
+
+/***** local function prototypes *********************************************/
+
+
+/***** global variable declarations *******************************************/
+/***** local functions *******************************************************/
+typedef enum 
+{
+    DIRECTION_IN =0,
+    DIRECTION_OUT,
+}GPIODirection_t;
+
+typedef struct tagGPIOInfo
+{
+    GpioIndex_t index;
+    int gpio_number;
+    char gpio_descripion[40];
+    GPIODirection_t gpio_direction;
+    int init_value;
+}GPIOInfo_t;
+
+#define GPIO_ITEM(a,b,c,d) \
+{.index = (a),\
+ .gpio_number = (b), \
+ .gpio_descripion = (#a), \
+ .gpio_direction = (c), \
+ .init_value = (d),  } 
+
+
+static GPIOInfo_t GPIO_List[]=
+{
+//    GPIO_ITEM(GPIO_136,             136,DIRECTION_OUT,0),   //configure GPIO 135 134 as input at trainner board
+//    GPIO_ITEM(GPIO_140,             140,DIRECTION_OUT,1),   //configure GPIO 138 139 as output at trainner board
+//    GPIO_ITEM(GPIO_INT,             94,DIRECTION_IN,0),
+    GPIO_ITEM(GPIO_RST,             93,DIRECTION_OUT,1),//init high
+};
+
+static GPIOInfo_t  * GetGPIOInfo(int gpio)
+{
+    int i;
+    for(i =0; i< ARRAY_SIZE(GPIO_List);i++)
+    {
+        if(gpio == GPIO_List[i].index)
+        {
+            return &GPIO_List[i];
+        }
+    }
+    return NULL;
+}
+
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ */
+
+#define IEN     (1 << 8)
+
+#define IDIS    (0 << 8)
+#define PTU     (1 << 4)
+#define PTD     (0 << 4)
+#define EN      (1 << 3)
+#define DIS     (0 << 3)
+
+#define M0      0
+#define M1      1
+#define M2      2
+#define M3      3
+#define M4      4
+#define M5      5
+#define M6      6
+#define M7      7
+
+#define IO_PHY_ADDRESS  0x48000000
+#define PAD_CONF_OFFSET  0x2030
+
+/*****************************************************************************/
+/**
+ * @brief set GPIO Pin MUX, it is also can be done in kernel ,
+ * we put it here , make it sure that all pin mux is configured crrectly; 
+ * *
+ *****************************************************************************/
+#if 0 // pinmux need not be configed here in aml platform. by Jets, Nov/25/2013
+static void HalSetPinMux(void)
+{
+#define PADCONF_SDMMC2_CLK_OFFSET			0x128   //GPIO130 OFFSET
+    int i;
+    unsigned short x,old;
+    void * base = NULL;
+    base = ioremap(IO_PHY_ADDRESS, 
+                          0x10000);
+
+    if (base == NULL)
+    {
+        SII_DEBUG_PRINT(MSG_ERR,"IO Mapping failed\n");
+        return ;
+    } 
+    else
+    {
+        SII_DEBUG_PRINT(MSG_STAT,"iobase = 0x%x\n",base);
+    }
+
+    for(i = 0 ;i<10;i++) //GPIO130 ~~ GPIO139
+    {
+        old = ioread16(base + PAD_CONF_OFFSET + PADCONF_SDMMC2_CLK_OFFSET + i*2);
+
+        switch(i)
+        {
+        case 5: 
+                x = (IEN | EN | PTU | M4 );break; 
+
+
+        default:               
+                x = (M4 | IDIS);break;
+        }
+
+        iowrite16(x,base + PAD_CONF_OFFSET + PADCONF_SDMMC2_CLK_OFFSET + i*2);
+
+//        SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"GPIO%d {0x%x}:0x%x => 0x%x ;\n",130+ i,(int)(base + 0x2030 + 0x128 + i*2),old,x);
+    }
+
+    iounmap(base);
+}
+#endif
+
+/*****************************************************************************/
+/**
+ * @brief when SilMon is open , disable ARM I2C R/W; 
+ * configure I2C pin to output mode when I2c disable ; 
+ * *
+ *****************************************************************************/
+#if 0 // this api is not used. by jets, Nov/23/2013
+halReturn_t HalEnableI2C(int bEnable )
+{
+#define PADCONF_I2C2_SCL_OFFSET			0x18e
+#define PADCONF_I2C2_SDA_OFFSET			0x190
+
+    unsigned short x,old;
+    void * base = NULL;
+    base = ioremap(IO_PHY_ADDRESS, 
+                          0x10000);
+
+    if (base == NULL)
+    {
+        SII_DEBUG_PRINT(MSG_ERR,"IO Mapping failed\n");
+        return HAL_RET_FAILURE;
+    } 
+
+    old = ioread16(base + PAD_CONF_OFFSET + PADCONF_I2C2_SCL_OFFSET);
+
+    if(bEnable)
+    {
+        x = (IEN  | PTU | EN  | M0 );
+    }
+    else
+    {
+        x = (EN | PTD | M4 | IDIS);
+    }
+
+    iowrite16(x,base + PAD_CONF_OFFSET + PADCONF_I2C2_SCL_OFFSET);
+//    SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"GPIO%d {0x%x}:0x%x => 0x%x ;\n",168,pinconf,old,x);
+
+    old = ioread16(base + PAD_CONF_OFFSET + PADCONF_I2C2_SDA_OFFSET);
+
+    if(bEnable)
+    {
+        x = (IEN | M0 );
+    }
+    else
+    {
+        x = (EN | PTD | M4 | IDIS);
+    }
+
+    iowrite16(x,base + PAD_CONF_OFFSET + PADCONF_I2C2_SDA_OFFSET);
+//    SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"GPIO%d {0x%x}:0x%x => 0x%x ;\n",183,pinconf,old,x);
+    iounmap(base);
+   	return HAL_RET_SUCCESS;
+}
+#endif
+
+// get gpio configuration from device tree.
+static void aml_get_gpio(void)
+{
+	// for gpio reset
+	GPIO_List[0].gpio_number = devinfo->config.gpio_reset;
+
+	return ;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Configure platform GPIOs needed by the MHL device.
+ *
+ *****************************************************************************/
+halReturn_t HalGpioInit(void)
+{
+	int status;
+    int i ,j;
+
+#if 0 // pinmux need not be configed here in aml platform. by Jets, Nov/25/2013
+    HalSetPinMux();
+#endif
+
+	aml_get_gpio();
+
+    for(i =0; i< ARRAY_SIZE(GPIO_List);i++)
+    {
+    	/* Request  GPIO . */
+        status = gpio_request(GPIO_List[i].gpio_number, GPIO_List[i].gpio_descripion);
+    	if (status < 0 && status != -EBUSY)
+    	{
+    		SII_DEBUG_PRINT(MSG_ERR,"HalInit gpio_request for GPIO %d (H/W Reset) failed, status: %d\n", GPIO_List[i].gpio_number, status);
+            for(j = 0; j < i;j++)
+            {
+                gpio_free(GPIO_List[j].gpio_number);
+            }
+            return HAL_RET_FAILURE;
+    	}
+
+        if(GPIO_List[i].gpio_direction == DIRECTION_OUT)
+        {
+            status = gpio_direction_output(GPIO_List[i].gpio_number, GPIO_List[i].init_value);
+        }
+        else
+        {
+            status = gpio_direction_input(GPIO_List[i].gpio_number);
+        }
+
+    	if (status < 0)
+    	{
+            SII_DEBUG_PRINT(MSG_ERR,"HalInit gpio_direction_output for GPIO %d (H/W Reset) failed, status: %d\n", GPIO_List[i].gpio_number, status);
+            for(j = 0; j <= i;j++)
+            {
+                gpio_free(GPIO_List[j].gpio_number);
+            }
+    		return HAL_RET_FAILURE;
+    	}
+//        SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"initialize %s successfully\n",GPIO_List[i].gpio_descripion);
+    }
+
+
+
+   	return HAL_RET_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Release GPIO pins needed by the MHL device.
+ *
+ *****************************************************************************/
+halReturn_t HalGpioTerm(void)
+{
+	halReturn_t 	halRet;
+    int index;
+	halRet = HalInitCheck();
+	if(halRet != HAL_RET_SUCCESS)
+	{
+		return halRet;
+	}
+
+    for(index = 0; index < ARRAY_SIZE(GPIO_List);index++)
+    {
+        gpio_free(GPIO_List[index].gpio_number);
+    }
+
+	return HAL_RET_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Platform specific function to set the output pin to control the MHL
+ * 		  transmitter device.
+ *
+ *****************************************************************************/
+halReturn_t HalGpioSetPin(GpioIndex_t gpio,int value)
+{
+	halReturn_t 	halRet;
+    GPIOInfo_t      *pGpioInfo;
+	halRet = HalInitCheck();
+	if(halRet != HAL_RET_SUCCESS)
+	{
+		return halRet;
+	}
+    pGpioInfo = GetGPIOInfo(gpio);
+    if(!pGpioInfo)
+    {
+        SII_DEBUG_PRINT(MSG_ERR,"%d is NOT right gpio_index!\n",(int)gpio);
+        return HAL_RET_FAILURE;
+    }
+    if(pGpioInfo->gpio_direction != DIRECTION_OUT)
+    {
+        SII_DEBUG_PRINT(MSG_ERR,"gpio(%d) is NOT ouput gpio!\n",pGpioInfo->gpio_number);
+        return HAL_RET_FAILURE;
+    }
+
+	gpio_set_value(pGpioInfo->gpio_number, value ? 1 : 0);
+
+
+    if(value)
+    {
+       SII_DEBUG_PRINT(MSG_STAT,">> %s to HIGH <<\n",pGpioInfo->gpio_descripion);
+    }
+    else
+    {
+       SII_DEBUG_PRINT(MSG_STAT,">> %s to LOW <<\n",pGpioInfo->gpio_descripion);
+    }
+
+	return HAL_RET_SUCCESS;
+}
+
+
+/*****************************************************************************/
+/**
+ * @brief Platform specific function to get the input pin value of the MHL
+ * 		  transmitter device.
+ *
+ *****************************************************************************/
+halReturn_t HalGpioGetPin(GpioIndex_t gpio,int * value)
+{
+	halReturn_t 	halRet;
+    GPIOInfo_t      *pGpioInfo;
+
+	halRet = HalInitCheck();
+	if(halRet != HAL_RET_SUCCESS)
+	{
+		return halRet;
+	}
+
+    pGpioInfo = GetGPIOInfo(gpio);
+    if(!pGpioInfo)
+    {
+        SII_DEBUG_PRINT(MSG_ERR,"%d is NOT right gpio_index!\n",(int)gpio);
+        return HAL_RET_FAILURE;
+    }
+    if(pGpioInfo->gpio_direction != DIRECTION_IN)
+    {
+        SII_DEBUG_PRINT(MSG_ERR,"gpio(%d) is NOT input gpio!\n",pGpioInfo->gpio_number);
+        return HAL_RET_FAILURE;
+    }
+
+	*value = gpio_get_value(pGpioInfo->gpio_number);
+	return HAL_RET_SUCCESS;
+}
+/*****************************************************************************/
+/**
+ * @brief HalGetGpioIrqNumber
+ * request one irq number FROM GPIO 
+ *
+ *****************************************************************************/
+#if 0 // this api is not used. by jets, Nov/23/2013
+halReturn_t HalGetGpioIrqNumber(GpioIndex_t gpio, unsigned int * irqNumber)
+{
+	halReturn_t 	halRet;
+    GPIOInfo_t      *pGpioInfo;
+
+	halRet = HalInitCheck();
+	if(halRet != HAL_RET_SUCCESS)
+	{
+		return halRet;
+	}
+
+    pGpioInfo = GetGPIOInfo(gpio);
+    if(!pGpioInfo)
+    {
+        SII_DEBUG_PRINT(MSG_ERR,"%d is NOT right gpio_index!\n",(int)gpio);
+        return HAL_RET_FAILURE;
+    }
+
+    *irqNumber = gpio_to_irq(pGpioInfo->gpio_number);
+
+	if(*irqNumber >=0)
+    {
+//        SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"%s(%d)-->IRQ(%d) \n",pGpioInfo->gpio_descripion,pGpioInfo->gpio_number,*irqNumber);
+        return HAL_RET_SUCCESS;
+
+    }
+
+    return HAL_RET_FAILURE;
+}
+#endif
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_i2c.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_i2c.c
new file mode 100755
index 000000000000..0aadc93ef80a
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_i2c.c
@@ -0,0 +1,650 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+
+/**
+ * @file sii_hal_linux_i2c.c
+ *
+ * @brief Linux implementation of I2c access functions required by Silicon Image
+ *        MHL devices.
+ *
+ * $Author: Tiger Qin
+ * $Rev: $
+ * $Date: Aug. 24, 2011
+ *
+ *****************************************************************************/
+
+#define SII_HAL_LINUX_I2C_C
+
+/***** #include statements ***************************************************/
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include "sii_hal.h"
+#include "sii_hal_priv.h"
+#include "si_platform.h"
+#include "si_drv_cra_cfg.h"
+#include "si_cra_internal.h"
+#include "mhl_linuxdrv.h"
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <mach/irqs.h>
+
+/***** local macro definitions ***********************************************/
+
+
+/***** local type definitions ************************************************/
+
+
+/***** local variable declarations *******************************************/
+struct i2c_dev_info {
+	uint8_t				dev_addr;
+	struct i2c_client	*client;
+};
+
+#define I2C_DEV_INFO(addr) \
+	{.dev_addr = addr >> 1, .client = NULL}
+
+static struct i2c_dev_info device_addresses[] = {
+	I2C_DEV_INFO(DEV_PAGE_PP_0),
+	I2C_DEV_INFO(DEV_PAGE_PP_1),
+	I2C_DEV_INFO(DEV_PAGE_PP_2),
+	I2C_DEV_INFO(DEV_PAGE_PP_9),
+	I2C_DEV_INFO(DEV_PAGE_PP_C),
+	I2C_DEV_INFO(DEV_PAGE_PP_3),    //For evita usage
+	I2C_DEV_INFO(DEV_PAGE_PP_4),    //For evita usage
+};
+
+/***** local function prototypes *********************************************/
+
+static int32_t MhlI2cProbe(struct i2c_client *client, const struct i2c_device_id *id);
+static int32_t MhlI2cRemove(struct i2c_client *client);
+
+
+/***** global variable declarations *******************************************/
+
+
+/***** local functions *******************************************************/
+
+/**
+ *  @brief Standard Linux probe callback.
+ *  
+ *  Probe is called if the I2C device name passed to HalOpenI2cDevice matches
+ *  the name of an I2C device on the system.
+ *  
+ *  All we need to do is store the passed in i2c_client* needed when performing
+ *  I2C bus transactions with the device.
+ *
+ *  @param[in]      client     		Pointer to i2c client structure of the matching
+ *  								I2C device.
+ *  @param[in]      i2c_device_id	Index within MhlI2cIdTable of the matching
+ *  								I2C device.
+ *
+ *  @return     Always returns zero to indicate success.
+ *
+ *****************************************************************************/
+static int32_t MhlI2cProbe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	//gMhlDevice.pI2cClient = client;
+    return 0;
+}
+
+
+/**
+ *  @brief Standard Linux remove callback.
+ *  
+ *  Remove would be called if the I2C device were removed from the system (very unlikley).
+ *  
+ *  All we need to do is clear our copy of the i2c_client pointer to indicate we no longer
+ *  have an I2C device to work with.
+ *
+ *  @param[in]	client	Pointer to the client structure representing the I2C device that
+ *  					was removed.
+ *
+ *  @return     Always returns zero to indicate success.
+ *
+ *****************************************************************************/
+static int32_t MhlI2cRemove(struct i2c_client *client)
+{
+	//gMhlDevice.pI2cClient = NULL;
+    return 0;
+}
+
+
+/***** public functions ******************************************************/
+
+
+/*****************************************************************************/
+/**
+ *  @brief Check if I2c access is allowed.
+ *
+ *****************************************************************************/
+halReturn_t I2cAccessCheck(void)
+{
+	halReturn_t		retStatus;
+
+	retStatus = HalInitCheck();
+	if (retStatus != HAL_RET_SUCCESS)
+	{
+		return retStatus;
+	}
+
+	if(gMhlDevice.pI2cClient == NULL)
+	{
+		pr_info("I2C device not currently open\n");
+		retStatus = HAL_RET_DEVICE_NOT_OPEN;
+	}
+	return retStatus;
+}
+
+static struct i2c_board_info si_5293_i2c_boardinfo[] = {
+	{
+	   	I2C_BOARD_INFO(MHL_DEVICE_NAME, (DEV_PAGE_PP_0 >> 1)),
+     	.flags = I2C_CLIENT_WAKE,
+		.irq = INT_GPIO_0,
+	}
+};
+
+
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Request access to the specified I2c device.
+ * 
+ * @param DeviceName, the name  must be same as which is registered in your kernel code; 
+ * we use probe I2C mode , so  
+ *  
+ * @param DriverName, iceman driver name
+ * 
+ * @return
+ * 
+ */
+halReturn_t HalOpenI2cDevice(char const *DeviceName, char const *DriverName)
+{
+    int idx;
+	int ret = -EFAULT;
+	halReturn_t		retStatus;
+    int32_t 		retVal;
+
+	retStatus = HalInitCheck();
+	if (retStatus != HAL_RET_SUCCESS)
+	{
+		return retStatus;
+	}
+
+    retVal = strnlen(DeviceName, I2C_NAME_SIZE);
+    if (retVal >= I2C_NAME_SIZE)
+    {
+    	pr_info("I2c device name too long!\n");
+    	return HAL_RET_PARAMETER_ERROR;
+    }
+
+
+    memcpy(gMhlI2cIdTable[0].name, DeviceName, retVal);
+    gMhlI2cIdTable[0].name[retVal] = 0;
+    gMhlI2cIdTable[0].driver_data = 0;
+
+    gMhlDevice.driver.driver.name = DriverName;
+    gMhlDevice.driver.id_table = gMhlI2cIdTable;
+    gMhlDevice.driver.probe = MhlI2cProbe;
+    gMhlDevice.driver.remove = MhlI2cRemove;
+#if 0    
+    retVal = i2c_add_driver(&gMhlDevice.driver);
+    if (retVal != 0)
+    {
+    	pr_info("I2C driver add failed\n");
+        retStatus = HAL_RET_FAILURE;
+    }
+    else
+    {
+    	if (gMhlDevice.pI2cClient == NULL)
+        {
+            i2c_del_driver(&gMhlDevice.driver);
+            pr_info("I2C driver add failed\n");
+            retStatus = HAL_RET_NO_DEVICE;
+        }
+    	else
+    	{
+    		retStatus = HAL_RET_SUCCESS;
+    	}
+    }
+    return retStatus;
+#endif
+
+    /* "Hotplug" the MHL device onto the 2nd I2C bus */
+    gMhlDevice.pI2cAdapter = i2c_get_adapter(devinfo->config.i2c_bus_index);
+	if (gMhlDevice.pI2cAdapter == NULL) {
+		pr_err ("%s() failed to get i2c adapter\n", __func__);
+		goto done;
+	}
+
+	for (idx = 0; idx < ARRAY_SIZE(device_addresses); idx++) {
+		if (idx ==0 ) {
+			gMhlDevice.pI2cClient = i2c_new_device(gMhlDevice.pI2cAdapter, &si_5293_i2c_boardinfo[idx]);
+			device_addresses[idx].client = gMhlDevice.pI2cClient;
+		} else {
+			device_addresses[idx].client = i2c_new_dummy(gMhlDevice.pI2cAdapter,
+											device_addresses[idx].dev_addr);
+		}
+		if (device_addresses[idx].client == NULL){
+			goto err_exit;
+		}
+	}
+
+	ret = i2c_add_driver(&gMhlDevice.driver);
+	if (ret < 0) {
+		pr_err("[ERROR] %s():%d failed !\n", __func__, __LINE__);
+        retStatus = HAL_RET_FAILURE;
+		goto err_exit;
+	}
+
+	goto done;
+
+err_exit:
+	for (idx = 0; idx < ARRAY_SIZE(device_addresses); idx++) {
+		if (device_addresses[idx].client != NULL)
+			i2c_unregister_device(device_addresses[idx].client);
+	}
+
+done:
+	return retStatus;
+
+}
+
+/*****************************************************************************/
+/**
+ * @brief Terminate access to the specified I2c device.
+ *
+ *****************************************************************************/
+halReturn_t HalCloseI2cDevice(void)
+{
+	halReturn_t		retStatus;
+	int	idx;
+
+	retStatus = HalInitCheck();
+	if (retStatus != HAL_RET_SUCCESS)
+	{
+		return retStatus;
+	}
+
+	if(gMhlDevice.pI2cClient == NULL)
+	{
+		pr_info("I2C device not currently open\n");
+        retStatus = HAL_RET_DEVICE_NOT_OPEN;
+	}
+	else
+	{
+		i2c_del_driver(&gMhlDevice.driver);
+		gMhlDevice.pI2cClient = NULL;
+        for (idx = 0; idx < ARRAY_SIZE(device_addresses); idx++) {
+            if (device_addresses[idx].client != NULL){
+                i2c_unregister_device(device_addresses[idx].client);
+            }
+        }
+		retStatus = HAL_RET_SUCCESS;
+	}
+	return retStatus;
+}
+#if 0
+/*****************************************************************************/
+/**
+ * @brief Read a single byte from a register within an I2c device.
+ *
+ *****************************************************************************/
+uint8_t I2C_ReadByte(uint8_t deviceID, uint8_t offset)
+{
+	uint8_t					accessI2cAddr;
+//	uint8_t					addrOffset;
+	union i2c_smbus_data	data;
+	int32_t					status;
+
+
+	if (I2cAccessCheck() != HAL_RET_SUCCESS)
+	{
+		/* Driver expects failed I2C reads to return 0xFF */
+		return 0xFF;
+	}
+
+    accessI2cAddr = deviceID>>1;  
+    status = i2c_smbus_xfer(gMhlDevice.pI2cClient->adapter, accessI2cAddr,
+    						0, I2C_SMBUS_READ, offset, I2C_SMBUS_BYTE_DATA,
+    						&data);
+	if (status < 0)
+	{
+        if(deviceID != 0xfc)//void much message
+        {
+            pr_info("I2C_ReadByte(0x%02x, 0x%02x), i2c_transfer error: %d\n",
+                            deviceID, offset, status);
+        }
+		data.byte = 0xFF;
+	}
+
+	return data.byte;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Write a single byte to a register within an I2c device.
+ *
+ *****************************************************************************/
+void I2C_WriteByte(uint8_t deviceID, uint8_t offset, uint8_t value)
+{
+	uint8_t					accessI2cAddr;
+	union i2c_smbus_data	data;
+	int32_t					status;
+
+	if (I2cAccessCheck() != HAL_RET_SUCCESS)
+	{
+		return;
+	}
+    accessI2cAddr = deviceID>>1;
+	data.byte = value;
+
+    status = i2c_smbus_xfer(gMhlDevice.pI2cClient->adapter, accessI2cAddr,
+    						0, I2C_SMBUS_WRITE, offset, I2C_SMBUS_BYTE_DATA,
+    						&data);
+	if (status < 0)
+	{
+		pr_info("I2C_WriteByte(0x%02x, 0x%02x, 0x%02x), i2c_transfer error: %d\n",
+						deviceID, offset, value, status);
+	}
+}
+
+/*****************************************************************************/
+/**
+ * @brief Read some bytes from a register within an I2c device.
+ *
+ *****************************************************************************/
+uint8_t I2C_ReadBlock(uint8_t deviceID, uint8_t offset,uint8_t *buf, uint8_t len)
+{
+    int i;
+	uint8_t					accessI2cAddr;
+	union i2c_smbus_data	data;
+	int32_t					status;
+
+
+	if (I2cAccessCheck() != HAL_RET_SUCCESS)
+	{
+		/* Driver expects failed I2C reads to return 0xFF */
+		return 0x00;
+	}
+
+    accessI2cAddr = deviceID>>1; 
+    memset(buf,0xff,len);
+
+    for(i = 0 ;i < len;i++)
+    {
+        status = i2c_smbus_xfer(gMhlDevice.pI2cClient->adapter, accessI2cAddr,
+        						0, I2C_SMBUS_READ, offset + i, I2C_SMBUS_BYTE_DATA,
+        						&data);
+    	if (status < 0)
+    	{
+            return 0;//if  error , return 
+    	}
+
+        *buf = data.byte;
+        buf++;
+    }
+    return len;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Write some bytes to a register within an I2c device.
+ *
+ *****************************************************************************/
+void I2C_WriteBlock(uint8_t deviceID, uint8_t offset, uint8_t *buf, uint8_t len)
+{
+    int i;
+	uint8_t					accessI2cAddr;
+	union i2c_smbus_data	data;
+	int32_t					status;
+
+
+	if (I2cAccessCheck() != HAL_RET_SUCCESS)
+	{
+		/* Driver expects failed I2C reads to return 0xFF */
+		return ;
+	}
+
+    accessI2cAddr = deviceID>>1; 
+
+    for(i = 0 ;i < len;i++)
+    {
+        data.byte = *buf;
+        status = i2c_smbus_xfer(gMhlDevice.pI2cClient->adapter, accessI2cAddr,
+        						0, I2C_SMBUS_WRITE, offset + i, I2C_SMBUS_BYTE_DATA,
+        						&data);
+    	if (status < 0)
+    	{
+            return ;
+    	}
+        buf++;
+    }
+    return ;
+}
+#endif
+/*****************************************************************************/
+/**
+ * @brief Read some bytes from a register within an I2c device.
+ *
+ *****************************************************************************/
+uint8_t I2C_ReadBlock(uint8_t deviceID, uint8_t offset,uint8_t *buf, uint8_t len)
+{
+	SiiI2cMsg_t			msgs[2];
+	SiiPlatformStatus_t	platformStatus = PLATFORM_SUCCESS;
+    int retryTimes = 3;
+    msgs[0].addr = deviceID;
+    msgs[0].cmdFlags = 0;
+    msgs[0].len = 1;
+    msgs[0].pBuf = &offset;
+
+    msgs[1].addr = deviceID;
+    msgs[1].cmdFlags = SII_MI2C_RD;
+    msgs[1].len = len;
+    msgs[1].pBuf = buf;
+
+    do
+    {
+        platformStatus = SiiMasterI2cTransfer(0, msgs, 2);
+        if (!platformStatus)
+            break;
+    }while(retryTimes--);
+	platformStatus = SiiMasterI2cTransfer(0, msgs, 2);
+    if(platformStatus)
+    {
+        memset(buf,0xFF,len);
+    }
+    return( platformStatus );
+}
+
+
+/*****************************************************************************/
+/**
+ * @brief Write some bytes to a register within an I2c device.
+ *
+ *****************************************************************************/
+uint8_t I2C_WriteBlock(uint8_t deviceID, uint8_t offset, uint8_t *buf, uint8_t len)
+{
+	SiiI2cMsg_t			msgs[2];
+	SiiPlatformStatus_t	platformStatus = PLATFORM_SUCCESS;
+
+    msgs[0].addr = deviceID;
+    msgs[0].cmdFlags = SII_MI2C_APPEND_NEXT_MSG;
+    msgs[0].len = 1;
+    msgs[0].pBuf = &offset;
+
+    msgs[1].addr = 0;
+    msgs[1].cmdFlags = 0;
+    msgs[1].len = len;
+    msgs[1].pBuf = (uint8_t*)buf;	// cast gets rid of const warning
+
+	platformStatus = SiiMasterI2cTransfer(0, msgs, 2);
+    return( platformStatus );
+}
+
+/*****************************************************************************/
+/**
+ * @brief Write a single byte to a register within an I2c device.
+ *
+ *****************************************************************************/
+uint8_t I2C_WriteByte(uint8_t deviceID, uint8_t offset, uint8_t value)
+{
+    return I2C_WriteBlock(deviceID, offset, &value,1);
+
+}
+
+/*****************************************************************************/
+/**
+ * @brief Read a single byte from a register within an I2c device.
+ *
+ *****************************************************************************/
+uint8_t I2C_ReadByte(uint8_t deviceID, uint8_t offset)
+{
+    uint8_t val;
+    I2C_ReadBlock(deviceID, offset,&val,  1);
+    return val;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Linux implementation of CRA driver platform interface function
+ * 		  SiiMasterI2cTransfer.
+ *
+ *****************************************************************************/
+SiiPlatformStatus_t SiiMasterI2cTransfer(deviceBusTypes_t busIndex,
+										 SiiI2cMsg_t *pMsgs, uint8_t msgNum)
+{
+	uint8_t				idx;
+	uint8_t				msgCount = 0;
+    struct i2c_msg		i2cMsg[MAX_I2C_MESSAGES];
+	uint8_t				*pBuffer = NULL;
+    SiiPlatformStatus_t	siiStatus = PLATFORM_FAIL;
+    int					i2cStatus;
+
+
+    do {
+    	if (I2cAccessCheck() != HAL_RET_SUCCESS)
+    	{
+    		break;
+    	}
+
+    	if(busIndex != DEV_I2C_0)
+    	{
+        	SII_DEBUG_PRINT(MSG_ERR,
+        			"SiiMasterI2cTransfer error: implementation supports" \
+        			"only one I2C bus\n");
+    		break;
+    	}
+
+    	if(msgNum > MAX_I2C_MESSAGES)
+    	{
+        	SII_DEBUG_PRINT(MSG_ERR,
+        			"SiiMasterI2cTransfer error: implementation supports" \
+        			"only %d message segments\n", MAX_I2C_MESSAGES);
+    		break;
+    	}
+
+    	// Function parameter checks passed, assume at this point that the
+    	// function will complete successfully.
+    	siiStatus = PLATFORM_SUCCESS;
+
+    	for(idx=0; idx < msgNum; idx++) {
+    		i2cMsg[idx].addr	= pMsgs[idx].addr >> 1;
+    		i2cMsg[idx].buf		= pMsgs[idx].pBuf;
+    		i2cMsg[idx].len		= pMsgs[idx].len;
+    		i2cMsg[idx].flags	= (pMsgs[idx].cmdFlags & SII_MI2C_RD) ? I2C_M_RD : 0;
+    		if(pMsgs[idx].cmdFlags & SII_MI2C_TEN) {
+    			pMsgs[idx].cmdFlags |= I2C_M_TEN;
+    		}
+    		if(pMsgs[idx].cmdFlags & SII_MI2C_APPEND_NEXT_MSG) {
+    			// Caller is asking that we append the buffer from the next
+    			// message to this one.  We will do this IF there is a next
+    			// message AND the direction of the two messages is the same
+    			// AND we haven't already appended a message.
+
+    			siiStatus = PLATFORM_INVALID_PARAMETER;
+    			if(idx+1 < msgNum && pBuffer == NULL) {
+    				if(!((pMsgs[idx].cmdFlags ^ pMsgs[idx+1].cmdFlags) & SII_MI2C_RD)) {
+
+    					i2cMsg[idx].len += pMsgs[idx+1].len;
+
+    				    pBuffer = kmalloc(i2cMsg[idx].len, GFP_KERNEL);
+    				    if(pBuffer == NULL) {
+    				    	siiStatus = PLATFORM_FAIL;
+    				    	break;
+    				    }
+
+    				    i2cMsg[idx].buf = pBuffer;
+    				    memmove(pBuffer, pMsgs[idx].pBuf, pMsgs[idx].len);
+    				    memmove(&pBuffer[pMsgs[idx].len], pMsgs[idx+1].pBuf, pMsgs[idx+1].len);
+
+    				    idx += 1;
+    				    siiStatus = PLATFORM_SUCCESS;
+    				}
+    			}
+    		}
+    		msgCount++;
+    	}
+
+    	if(siiStatus != PLATFORM_SUCCESS) {
+        	SII_DEBUG_PRINT(MSG_ERR,
+        			"SiiMasterI2cTransfer failed, returning error: %d\n", siiStatus);
+
+    		if(pBuffer != NULL) {
+        		kfree(pBuffer);
+        	}
+
+    		return siiStatus;
+    	}
+
+    	i2cStatus = i2c_transfer(gMhlDevice.pI2cClient->adapter, i2cMsg, msgCount);
+
+    	if(pBuffer != NULL) {
+    		kfree(pBuffer);
+    	}
+
+    	if(i2cStatus < msgCount)
+    	{
+    		// All the messages were not transferred, some sort of error occurred.
+    		// Try to return the most appropriate error code to the caller.
+    		if (i2cStatus < 0)
+    		{
+    	    	SII_DEBUG_PRINT(MSG_ERR,
+    	    			"SiiMasterI2cTransfer, i2c_transfer error: %d  " \
+    	    			"deviceId: 0x%02x regOffset: 0x%02x\n",
+    	    			i2cStatus, pMsgs->addr, *pMsgs->pBuf);
+    			siiStatus = PLATFORM_FAIL;
+    		}
+    		else
+    		{
+    			// One or more messages transferred so error probably occurred on the
+    			// first unsent message.  Look to see if the message was a read or write
+    			// and set the appropriate return code.
+    			if(pMsgs[i2cStatus].cmdFlags & SII_MI2C_RD)
+    			{
+    				siiStatus = PLATFORM_I2C_READ_FAIL;
+    			}
+    			else
+    			{
+    				siiStatus = PLATFORM_I2C_WRITE_FAIL;
+    			}
+    		}
+    	}
+
+	} while(0);
+
+	return siiStatus;
+}
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_init.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_init.c
new file mode 100755
index 000000000000..820a0b2fe88b
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_init.c
@@ -0,0 +1,195 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+/**
+ * @file sii_hal_linux_init.c
+ *
+ * @brief Initializes the Hardware Abstraction Layer (HAL) used by Silicon Image
+ * 		  MHL Linux drivers.
+ *
+ * $Author: Dave Canfield
+ * $Rev: $
+ * $Date: Jan. 24, 2011
+ *
+ *****************************************************************************/
+
+#define SII_HAL_LINUX_INIT_C
+
+/***** #include statements ***************************************************/
+#include <linux/i2c.h>
+#include "sii_hal.h"
+#include "sii_hal_priv.h"
+
+/***** local macro definitions ***********************************************/
+
+
+/***** local type definitions ************************************************/
+
+
+/***** local variable declarations *******************************************/
+
+
+/***** local function prototypes *********************************************/
+
+
+/***** global variable declarations *******************************************/
+
+bool gHalInitedFlag = false;
+
+/* @brief table used to hold device names of supported MHL devices */
+struct i2c_device_id gMhlI2cIdTable[2];
+
+/** @brief Semaphore used to prevent driver access from user mode from
+ * colliding with the threaded interrupt handler */
+//DECLARE_MUTEX(gIsrLock);
+DEFINE_SEMAPHORE(gIsrLock); //2.6.39 use this style ,tiger qin 
+mhlDeviceContext_t gMhlDevice;
+
+
+
+
+/***** local functions *******************************************************/
+
+/***** public functions ******************************************************/
+
+
+/*****************************************************************************/
+/**
+ *  @brief Check if Hal has been properly initialized.
+ *
+ *****************************************************************************/
+halReturn_t HalInitCheck(void)
+{
+	if (!(gHalInitedFlag))
+	{
+		SII_DEBUG_PRINT(MSG_ERR,"Error: Hal layer not currently initialize!\n");
+		return HAL_RET_NOT_INITIALIZED;
+	}
+
+	return HAL_RET_SUCCESS;
+}
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Initialize the HAL layer module.
+ *
+ *****************************************************************************/
+halReturn_t HalInit(void)
+{
+	halReturn_t	status;
+
+	if (gHalInitedFlag)
+	{
+		SII_DEBUG_PRINT(MSG_ERR,"Error: Hal layer already inited!\n");
+		return HAL_RET_ALREADY_INITIALIZED;
+	}
+
+	gMhlDevice.driver.driver.name = NULL;
+	gMhlDevice.driver.id_table = NULL;
+	gMhlDevice.driver.probe = NULL;
+	gMhlDevice.driver.remove = NULL;
+
+	gMhlDevice.pI2cClient = NULL;
+
+	gMhlDevice.irqHandler = NULL;
+//	init_MUTEX(&gIsrLock);
+
+//	HalTimerInit();
+
+	status = HalGpioInit();
+	if(status != HAL_RET_SUCCESS)
+	{
+		return status;
+	}
+
+	gHalInitedFlag = true;
+
+	return HAL_RET_SUCCESS;
+}
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Terminate access to the hardware abstraction layer.
+ *
+ *****************************************************************************/
+halReturn_t HalTerm(void)
+{
+	halReturn_t		retStatus;
+
+
+	retStatus = HalInitCheck();
+	if (retStatus != HAL_RET_SUCCESS)
+	{
+		return retStatus;
+	}
+
+//	HalTimerTerm();
+	HalGpioTerm();
+
+	gHalInitedFlag = false;
+
+	return retStatus;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Acquire the lock that prevents races with the interrupt handler.
+ *
+ *****************************************************************************/
+halReturn_t HalAcquireIsrLock()
+{
+	halReturn_t		retStatus;
+	int				status;
+
+	retStatus = HalInitCheck();
+	if (retStatus != HAL_RET_SUCCESS)
+	{
+		return retStatus;
+	}
+
+	status = down_interruptible(&gIsrLock);
+	if (status != 0)
+	{
+		SII_DEBUG_PRINT(MSG_ERR,"HalAcquireIsrLock failed to acquire lock\n");
+		return HAL_RET_FAILURE;
+	}
+
+	return HAL_RET_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Release the lock that prevents races with the interrupt handler.
+ *
+ *****************************************************************************/
+halReturn_t HalReleaseIsrLock()
+{
+	halReturn_t		retStatus;
+
+	retStatus = HalInitCheck();
+	if (retStatus != HAL_RET_SUCCESS)
+	{
+		return retStatus;
+	}
+
+	up(&gIsrLock);
+
+	return retStatus;
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_isr.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_isr.c
new file mode 100755
index 000000000000..bebce2966fb2
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_isr.c
@@ -0,0 +1,347 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+/**
+ * @file sii_hal_linux_isr.c
+ *
+ * @brief Linux implementation of interrupt support used by Silicon Image
+ *        MHL devices.
+ *
+ * $Author: Tiger Qin 
+ * $Rev: $
+ * $Date: Aug. 31, 2011
+ *
+ *****************************************************************************/
+
+#define SII_HAL_LINUX_ISR_C
+
+/***** #include statements ***************************************************/
+#include "sii_hal.h"
+#include "sii_hal_priv.h"
+//#include "si_drvisrconfig.h"
+#include "mhl_linuxdrv.h"
+
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <mach/irqs.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+
+/***** local macro definitions ***********************************************/
+
+/***** local type definitions ************************************************/
+
+/***** local variable declarations *******************************************/
+
+/***** local function prototypes *********************************************/
+
+/***** global variable declarations *******************************************/
+
+
+/***** local functions *******************************************************/
+
+/*****************************************************************************/
+/*
+ *  @brief Interrupt handler for MHL transmitter interrupts.
+ *
+ *  @param[in]		irq		The number of the asserted IRQ line that caused
+ *  						this handler to be called.
+ *  @param[in]		data	Data pointer passed when the interrupt was enabled,
+ *  						which in this case is a pointer to the
+ *  						MhlDeviceContext of the I2c device.
+ *
+ *  @return     Always returns IRQ_HANDLED.
+ *
+ *****************************************************************************/
+static irqreturn_t HalThreadedIrqHandler(int irq, void *data)
+{
+	pMhlDeviceContext	pMhlDevContext = (pMhlDeviceContext)data;
+
+//	SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"HalThreadedIrqHandler called\n");
+	if (HalAcquireIsrLock() == HAL_RET_SUCCESS)
+    {
+/*
+        if(pMhlDevContext->CheckDevice &&!pMhlDevContext->CheckDevice(0))//mhl device check;
+        {
+            SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"mhl device errror\n");
+            HalReleaseIsrLock();
+            return IRQ_HANDLED;
+        }
+*/
+        if(pMhlDevContext->irqHandler)
+        {
+            (pMhlDevContext->irqHandler)();
+        }
+		HalReleaseIsrLock();
+	}
+    else
+    {
+        SII_DEBUG_PRINT(MSG_ERR,"------------- irq missing! -------------\n");
+    }
+
+	return IRQ_HANDLED;
+}
+
+/***** public functions ******************************************************/
+
+extern int amlogic_gpio_to_irq(unsigned int  pin,const char *owner,unsigned int flag);
+
+extern int amlogic_gpio_request(unsigned int  pin,const char *label);
+extern int amlogic_gpio_direction_input(unsigned int pin,const char *owner);
+extern int amlogic_gpio_to_irq(unsigned int  pin,const char *owner,unsigned int flag);
+// get gpio configuration from device tree.
+static void aml_config_gpio_irq(void)
+{
+	int ret = 0;
+	unsigned int gpio_irq;
+
+	gpio_irq = devinfo->config.gpio_intr;
+	ret = amlogic_gpio_request(gpio_irq, gMhlI2cIdTable[0].name);
+	ret |= amlogic_gpio_direction_input(gpio_irq, gMhlI2cIdTable[0].name);
+	ret |= amlogic_gpio_to_irq(gpio_irq, gMhlI2cIdTable[0].name, AML_GPIO_IRQ(gMhlDevice.pI2cClient->irq-INT_GPIO_0,FILTER_NUM7,GPIO_IRQ_LOW));
+	printk("sii5293 config gpio_irq, irq = %d, ret = %d\n",gMhlDevice.pI2cClient->irq, ret);
+
+	return ;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Install IRQ handler.
+ *
+ *****************************************************************************/
+halReturn_t HalInstallIrqHandler(fwIrqHandler_t irqHandler)
+{
+	int				retStatus;
+	halReturn_t 	halRet;
+
+	if(irqHandler == NULL)
+	{
+		SII_DEBUG_PRINT(MSG_ERR,"HalInstallIrqHandler: irqHandler cannot be NULL!\n");
+		return HAL_RET_PARAMETER_ERROR;
+	}
+
+	halRet = I2cAccessCheck();
+	if (halRet != HAL_RET_SUCCESS)
+	{
+		return halRet;
+	}
+
+	if(gMhlDevice.pI2cClient->irq == 0)
+	{
+		SII_DEBUG_PRINT(MSG_ERR,"HalInstallIrqHandler: No IRQ assigned to I2C device!\n");
+		return HAL_RET_FAILURE;
+	}
+
+	gMhlDevice.irqHandler = irqHandler;
+
+	aml_config_gpio_irq();
+
+	retStatus = request_threaded_irq(gMhlDevice.pI2cClient->irq, NULL,
+									 HalThreadedIrqHandler,
+									 IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+									 gMhlI2cIdTable[0].name,
+									 &gMhlDevice);
+
+	if(retStatus != 0)
+	{
+		SII_DEBUG_PRINT(MSG_ERR,"sii5293 HalInstallIrqHandler: request_threaded_irq failed, status: %d\n",
+				retStatus);
+		gMhlDevice.irqHandler = NULL;
+		return HAL_RET_FAILURE;
+	}
+
+	return HAL_RET_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+ * @brief Remove IRQ handler.
+ *
+ *****************************************************************************/
+halReturn_t HalRemoveIrqHandler(void)
+{
+	halReturn_t 	halRet;
+
+	halRet = I2cAccessCheck();
+	if (halRet != HAL_RET_SUCCESS)
+	{
+		return halRet;
+	}
+
+	if(gMhlDevice.irqHandler == NULL)
+	{
+		SII_DEBUG_PRINT(MSG_ERR,"HalRemoveIrqHandler: no irqHandler installed!\n");
+		return HAL_RET_FAILURE;
+	}
+
+	free_irq(gMhlDevice.pI2cClient->irq, &gMhlDevice);
+
+	gMhlDevice.irqHandler = NULL;
+
+	return HAL_RET_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+ * @brief ON/OFF TX chip IRQ , just be used for debugging interface;
+ *
+ *****************************************************************************/
+void HalEnableIrq(uint8_t bEnable)
+{
+    if(bEnable)
+    {
+        enable_irq(gMhlDevice.pI2cClient->irq);
+    }
+    else
+    {
+        disable_irq(gMhlDevice.pI2cClient->irq);
+    }
+}
+
+bool_t is_interrupt_asserted( void )
+{
+	return (amlogic_get_value(devinfo->config.gpio_intr, gMhlI2cIdTable[0].name) == INT_IS_ASSERTED );
+    //return (gpio_get_value(GPIO_INT_PIN) == INT_IS_ASSERTED);	
+}
+
+#if 0
+/*****************************************************************************/
+/**
+ * @brief SilMon IRQ handler,
+ *
+ *****************************************************************************/
+static irqreturn_t HalSilMonRequestIrqHandler(int irq, void *data)
+{
+	pMhlDeviceContext	pMhlDevContext = (pMhlDeviceContext)data;
+
+    int gpio_value;
+	unsigned long		flags;
+//  SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"------------- HalSilMonRequestIrqHandler irq coming! -------------\n");
+    spin_lock_irqsave(&pMhlDevContext->SilMonRequestIRQ_Lock, flags);
+
+    if(HalGpioGetPin(GPIO_REQ_IN,&gpio_value)<0)
+    {
+        SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"HalSilMonRequestIrqHandler GPIO(%d) get error\n",gpio_value);
+        spin_unlock_irqrestore(&pMhlDevContext->SilMonRequestIRQ_Lock, flags);
+        return IRQ_HANDLED;
+    }
+
+    /*
+    the following is for void wrongly invoke irq, it may be caused by EMI when plug in/out MHL cable;
+    */
+    if((gMhlDevice.SilMonControlReleased&& gpio_value)
+       ||(!gMhlDevice.SilMonControlReleased&&!gpio_value))
+    {
+        SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"HalSilMonRequestIrqHandler, wrong IRQ coming, please check you board\n");
+        spin_unlock_irqrestore(&pMhlDevContext->SilMonRequestIRQ_Lock, flags);
+        return IRQ_HANDLED;
+    }
+
+    if(gpio_value)
+    {
+        HalGpioSetPin(GPIO_GNT,1);
+        HalEnableI2C(true);
+        enable_irq(pMhlDevContext->pI2cClient->irq);
+        SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"release SiliMon control\n");
+        gMhlDevice.SilMonControlReleased = true;
+    }
+    else
+    {
+        disable_irq(pMhlDevContext->pI2cClient->irq);       
+        HalEnableI2C(false);
+        HalGpioSetPin(GPIO_GNT,0);
+        SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"under SiliMon control \n");
+        gMhlDevice.SilMonControlReleased = false;
+    }
+
+    spin_unlock_irqrestore(&pMhlDevContext->SilMonRequestIRQ_Lock, flags);
+
+	return IRQ_HANDLED;
+}
+/*****************************************************************************/
+/**
+ * @brief Install  silmon request IRQ handler.
+ *
+ *****************************************************************************/
+halReturn_t HalInstallSilMonRequestIrqHandler(void)
+{
+	int				retStatus;
+	halReturn_t 	halRet;
+
+	halRet = I2cAccessCheck();
+	if (halRet != HAL_RET_SUCCESS)
+	{
+		return halRet;
+	}
+
+    halRet = HalGetGpioIrqNumber(GPIO_REQ_IN, &gMhlDevice.SilMonRequestIRQ);
+    if(halRet!= HAL_RET_SUCCESS)
+    {
+        return halRet;
+    }   
+
+    spin_lock_init(&gMhlDevice.SilMonRequestIRQ_Lock);
+    gMhlDevice.SilMonControlReleased  = true;
+
+	retStatus = request_threaded_irq(gMhlDevice.SilMonRequestIRQ, NULL,
+									 HalSilMonRequestIrqHandler,
+									 IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+									 gMhlI2cIdTable[0].name,
+									 &gMhlDevice);
+	if(retStatus != 0)
+	{
+		SII_DEBUG_PRINT(SII_OSAL_DEBUG_TRACE,"HalInstallIrqHandler: request_threaded_irq failed, status: %d\n",
+				retStatus);
+		return HAL_RET_FAILURE;
+	}
+
+	return HAL_RET_SUCCESS;
+}
+/*****************************************************************************/
+/**
+ * @brief Remove SilMonRequest IRQ handler.
+ *
+ *****************************************************************************/
+halReturn_t HalRemoveSilMonRequestIrqHandler(void)
+{
+	halReturn_t 	halRet;
+
+	halRet = I2cAccessCheck();
+	if (halRet != HAL_RET_SUCCESS)
+	{
+		return halRet;
+	}
+
+	free_irq(gMhlDevice.SilMonRequestIRQ, &gMhlDevice);
+
+	return HAL_RET_SUCCESS;
+}
+#endif
+/*****************************************************************************/
+/**
+ * @brief check device before IRQ handling, it fixed the issue taht in some case when chip error,
+ *the program can NOT exit since in IRQ dead loop; 
+ *
+ *****************************************************************************/
+halReturn_t HalInstallCheckDeviceCB(fnCheckDevice fn)
+{
+    gMhlDevice.CheckDevice = fn;
+	return HAL_RET_SUCCESS;
+}
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_timer.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_timer.c
new file mode 100755
index 000000000000..bd5457390189
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_linux_timer.c
@@ -0,0 +1,89 @@
+/**
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+
+/**
+ * @file sii_hal_linux_timer.c
+ *
+ * @brief Linux implementation of timer support used by Silicon Image
+ *        MHL devices.
+ *
+ * $Author: Dave Canfield
+ * $Rev: $
+ * $Date: Feb. 4, 2011
+ */
+
+/***** #include statements ***************************************************/
+#include "si_common.h"
+#include "sii_hal_priv.h"
+#include <linux/jiffies.h>
+
+uint32_t g_timerCounters[ TIMER_COUNT ];
+
+/*****************************************************************************/
+/**
+ * @brief Wait for the specified number of milliseconds to elapse.
+ *
+ *****************************************************************************/
+void HalTimerWait(uint16_t m_sec)
+{
+	unsigned long	time_usec = m_sec * 1000;
+
+	usleep_range(time_usec, time_usec);
+}
+
+void    HalTimerInit( void )
+{
+    uint8_t i;
+
+    //initializer timer counters in array
+
+    for ( i = 0; i < TIMER_COUNT; i++ )
+    {
+        g_timerCounters[i] = 0;
+    }
+}
+void    HalTimerSet( uint8_t index, uint16_t m_sec )
+{
+    switch ( index )
+    {
+        case TIMER_0:
+        case TIMER_1:
+        case TIMER_2:
+        case TIMER_3:
+            g_timerCounters[index] = jiffies + m_sec * HZ / 1000;
+            break;
+    }
+}
+
+#if 0
+uint8_t HalTimerExpired( uint8_t timer )
+{
+    if ( timer < TIMER_COUNT )
+    {
+        return time_after(jiffies, g_timerCounters[timer]);
+    }
+    return false;
+}
+uint16_t HalTimerElapsed( uint8_t timer )
+{
+    //Not implemented since no user use this function
+    return 0;
+}
+uint32_t HalTimerSysTicks (void)
+{
+    return (get_jiffies_64()*1000/ HZ);
+}
+#endif
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_priv.h b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_priv.h
new file mode 100755
index 000000000000..aacd2bd08253
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/hal/sii_hal_priv.h
@@ -0,0 +1,138 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+
+/**
+ * @file sii_hal.h
+ *
+ * @brief Defines the hardware / OS abstraction layer API used by Silicon
+ *        Image MHL drivers.
+ *
+ * $Author: Dave Canfield
+ * $Rev: $
+ * $Date: Jan. 24, 2011
+ *
+ *****************************************************************************/
+
+#if !defined(SII_HAL_PRIV_H)
+#define SII_HAL_PRIV_H
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/semaphore.h>
+#include <linux/kthread.h>
+#include <linux/spinlock.h>
+
+#ifdef __cplusplus 
+extern "C" { 
+#endif  /* _defined (__cplusplus) */
+
+/***** macro definitions *****************************************************/
+#ifdef MAKE_5293_DRIVER
+#define BASE_I2C_ADDR   0x64
+#endif
+
+/***** public type definitions ***********************************************/
+/** Type used internally within the HAL to encapsulate the state of the
+ * MHL TX device. */
+typedef struct  {
+	struct	i2c_driver	driver;
+	struct	i2c_adapter *pI2cAdapter; 
+	struct	i2c_client	*pI2cClient;
+	fwIrqHandler_t		irqHandler;
+    unsigned int        SilMonRequestIRQ;
+	spinlock_t          SilMonRequestIRQ_Lock;
+    unsigned int        SilMonControlReleased;
+    fnCheckDevice       CheckDevice;
+} mhlDeviceContext_t, *pMhlDeviceContext;
+
+
+
+/***** global variables used internally by HAL ********************************************/
+
+/** @brief If true, HAL has been initialized. */
+extern bool gHalInitedFlag;
+
+extern struct i2c_device_id gMhlI2cIdTable[2];
+
+/** @brief Maintain state info of the MHL TX device */
+extern mhlDeviceContext_t gMhlDevice;
+
+
+
+/***** public function prototypes ********************************************/
+
+
+/*****************************************************************************/
+/*
+ *  @brief Check if HAL access is allowed.
+ *
+ *  Various HAL functions call this function to make sure the HAL has been
+ *  properly initialized.
+ *
+ *  @return         HAL_RET_SUCCESS if the HAL has been initialized,
+ *  				otherwise returns HAL_RET_NOT_INITIALIZED.
+ *
+ *****************************************************************************/
+halReturn_t HalInitCheck(void);
+
+
+
+/*****************************************************************************/
+/*
+ *  @brief Check if I2c access is allowed.
+ *
+ *  If the Hal layer has been inited and the I2c device has been successfully
+ *  opened, success is returned, otherwise an approprite HAL error code is
+ *  returned.
+ *
+ *  @return         status (success or error code)
+ *
+ *****************************************************************************/
+halReturn_t I2cAccessCheck(void);
+
+
+/*****************************************************************************/
+/*
+ * @brief Initialize HAL GPIO support
+ *
+ *  This function is responsible for acquiring and configuring GPIO pins
+ *  needed by the driver.
+ *
+ *  @return         status (success or error code)
+ *
+ *****************************************************************************/
+halReturn_t HalGpioInit(void);
+
+
+/*****************************************************************************/
+/**
+ * @brief Terminate HAL GPIO support.
+ *
+ *  This function is responsible for releasing any GPIO pin resources
+ *  acquired by HalGpioInit
+ *
+ * @return         Success status if GPIO support was previously initialized,
+ * 				   error status otherwise.
+ *****************************************************************************/
+halReturn_t HalGpioTerm(void);
+
+#ifdef __cplusplus
+}
+#endif  /* _defined (__cplusplus) */
+
+#endif /* _defined (SII_HAL_PRIV_H) */
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/osal/si_osdebug.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/osal/si_osdebug.c
new file mode 100755
index 000000000000..3ebaae6d4de5
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/osal/si_osdebug.c
@@ -0,0 +1,82 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+//#include "si_c99support.h"
+//#include "si_memsegsupport.h"
+#include "si_common.h"
+#include "si_osdebug.h"
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#define MAX_DEBUG_MSG_SIZE	512
+
+void SiiOsDebugPrint(const char *pszFileName, uint32_t iLineNum, uint8_t printFlags, const char *pszFormat, ...)
+{
+	uint8_t		*pBuf = NULL;
+	uint8_t		*pBufOffset;
+	int			remainingBufLen = MAX_DEBUG_MSG_SIZE;
+	int			len;
+	va_list		ap;
+    extern int debug_level;
+
+    if (( printFlags & 0xFF ) > debug_level )
+    {
+        return;
+    }
+    //if (SiiOsDebugChannelIsEnabled( channel ))
+    {
+	    pBuf = kmalloc(remainingBufLen, GFP_KERNEL);
+	    if(pBuf == NULL)
+	    	return;
+	    pBufOffset = pBuf;
+
+        if(pszFileName != NULL)
+        {
+        	// only print the file name, not the full path.
+        	const char *pc;
+
+            for(pc = &pszFileName[strlen(pszFileName)];pc  >= pszFileName;--pc)
+            {
+                if ('\\' == *pc)
+                {
+                    ++pc;
+                    break;
+                }
+                if ('/' ==*pc)
+                {
+                    ++pc;
+                    break;
+                }
+            }
+            len = scnprintf(pBufOffset, remainingBufLen, "%s:%d ",pc,(int)iLineNum);
+            if(len < 0) {
+            	kfree(pBuf);
+            	return;
+            }
+
+            remainingBufLen -= len;
+            pBufOffset += len;
+        }
+
+        va_start(ap,pszFormat);
+        vsnprintf(pBufOffset, remainingBufLen, pszFormat, ap);
+        va_end(ap);
+
+    	printk(pBuf);
+		kfree(pBuf);
+    }
+}
+
diff --git a/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/osal/sii_osal_linux_timer.c b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/osal/sii_osal_linux_timer.c
new file mode 100755
index 000000000000..4f224faf77d3
--- /dev/null
+++ b/drivers/amlogic/ext_hdmiin/sii9293/linux_driver/platform/osal/sii_osal_linux_timer.c
@@ -0,0 +1,345 @@
+/*
+ * SiIxxxx <Firmware or Driver>
+ *
+ * Copyright (C) 2011 Silicon Image Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE.  See the GNU General Public License for more details.
+*/
+/**
+ * @file sii_osal_linux_timer.c
+ *
+ * @brief This file provides the Linux implementation of the timer support
+ *           defined by the Silicon Image Operating System Abstraction Layer (OSAL)
+ *           specification.
+ *
+ * $Author: Dave Canfield
+ * $Rev: $
+ * $Date: March. 16, 2011
+ *
+ *****************************************************************************/
+
+#define SII_OSAL_LINUX_TIMER_C
+
+/***** #include statements ***************************************************/
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/slab.h>
+#include "sii_hal.h"
+//#include "sii_hal_priv.h"
+#include "osal/include/osal.h"
+
+/***** local macro definitions ***********************************************/
+
+/** Convert a value specified in milliseconds to nanoseconds */
+#define MSEC_TO_NSEC(x)        (x * 1000000UL)
+
+
+#define MAX_TIMER_NAME_LEN        64
+
+
+/***** local type definitions ************************************************/
+
+/* Define structure used to maintain list of outstanding timer objects. */
+typedef struct _SiiOsTimerInfo_t {
+    struct    list_head         listEntry;
+    struct    work_struct       workItem;
+    uint8_t                     flags;
+    char                        timerName[MAX_TIMER_NAME_LEN];
+    struct hrtimer              hrTimer;
+    timerCallbackHandler_t      callbackHandler;
+    void                        *callbackParam;
+    uint32_t                    timeMsec;
+    bool                        bPeriodic;
+} timerObject_t;
+
+// timerObject_t flag field definitions
+#define TIMER_OBJ_FLAG_WORK_IP    0x01    // timer's work item callback is in process
+#define TIMER_OBJ_FLAG_DEL_REQ    0x02    // a request is pending to delete this timer
+
+
+/***** local variable declarations *******************************************/
+
+static struct list_head            timerList;
+static struct workqueue_struct        *timerWorkQueue;
+
+
+
+/***** local function prototypes *********************************************/
+
+
+/***** global variable declarations *******************************************/
+
+
+/***** local functions *******************************************************/
+
+
+/*****************************************************************************/
+/*
+ *  @brief This function is the unit of work that has been placed on the
+ *         work queue when a timer expires.
+ *
+ *  @param[in]    work    Pointer to the workItem field of the timerObject_t
+ *                      that is responsible for this function being called.
+ *
+ *  @return     Nothing
+ *
+ *****************************************************************************/
+static void WorkHandler(struct work_struct *work)
+{
+    timerObject_t        *pTimerObj = container_of(work, timerObject_t, workItem);
+
+
+    pTimerObj->flags |= TIMER_OBJ_FLAG_WORK_IP;
+
+    if (HalAcquireIsrLock() == HAL_RET_SUCCESS) {
+        if(pTimerObj->callbackHandler)
+            (pTimerObj->callbackHandler)(pTimerObj->callbackParam);
+        HalReleaseIsrLock();
+    }
+
+    pTimerObj->flags &= ~TIMER_OBJ_FLAG_WORK_IP;
+
+    if(pTimerObj->flags & TIMER_OBJ_FLAG_DEL_REQ)
+    {
+        // Deletion of this timer was requested during the execution of
+        // the callback handler so go ahead and delete it now.
+        kfree(pTimerObj);
+    }
+}
+
+
+
+/*****************************************************************************/
+/*
+ *  @brief Timer callback handler.
+ *
+ *  @param[in]    timer    Pointer to the timer structure responsible for this
+ *                      function being called.
+ *
+ *  @return     Returns HRTIMER_RESTART if the timer is periodic or
+ *              HRTIMER_NORESTART if the timer is not periodic.
+ *
+ *****************************************************************************/
+static enum hrtimer_restart TimerHandler(struct hrtimer *timer)
+{
+    SiiOsTimer_t pTimerObj = container_of(timer, timerObject_t, hrTimer);
+
+    queue_work(timerWorkQueue, &pTimerObj->workItem);
+
+    return HRTIMER_NORESTART;
+}
+
+
+
+/***** public functions ******************************************************/
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Initialize OSAL timer support.
+ *
+ *****************************************************************************/
+SiiOsStatus_t SiiOsInit(uint32_t maxChannels)
+{
+    // Initialize list head used to track allocated timer objects.
+    INIT_LIST_HEAD(&timerList);
+
+    timerWorkQueue = create_workqueue("Sii_timer_work");
+
+    if(timerWorkQueue == NULL)
+    {
+        return SII_OS_STATUS_ERR_NOT_AVAIL;
+    }
+
+    return SII_OS_STATUS_SUCCESS;
+}
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Terminate OSAL timer support.
+ *
+ *****************************************************************************/
+SiiOsStatus_t SiiOsTerm(void)
+{
+    SiiOsTimer_t timerObj;
+    int         status;
+
+    // Make sure all outstanding timer objects are canceled and the
+    // memory allocated for them is freed.
+    while(!list_empty(&timerList)) {
+
+        timerObj = list_first_entry(&timerList, timerObject_t, listEntry);
+        status = hrtimer_try_to_cancel(&timerObj->hrTimer);
+        if(status >= 0)
+        {
+            list_del(&timerObj->listEntry);
+            kfree(timerObj);
+        }
+    }
+
+    flush_workqueue(timerWorkQueue);
+    destroy_workqueue(timerWorkQueue);
+    timerWorkQueue = NULL;
+
+    return SII_OS_STATUS_SUCCESS;
+}
+
+
+bool_t SiiOsTimerValidCheck(SiiOsTimer_t timerId)
+{
+    SiiOsTimer_t timer;
+
+    list_for_each_entry(timer, &timerList, listEntry)
+    {
+        if(timer == timerId)
+        {
+            break;
+        }
+    }
+    
+    if(timer != timerId)
+    {
+        SII_DEBUG_PRINT(MSG_ERR,"Invalid timerId %p received\n",
+                        timerId);
+        return false;
+    }
+    return true;
+}
+
+
+/*****************************************************************************/
+/**
+ * @brief Allocate a new OSAL timer object.
+ *
+ *****************************************************************************/
+SiiOsStatus_t SiiOsTimerCreate(const char *pName, void(*pTimerFunction)(void *pArg),
+                                 void *pTimerArg,
+                                 SiiOsTimer_t *pTimerId)
+{
+    SiiOsTimer_t timerObj;
+    SiiOsStatus_t        status = SII_OS_STATUS_SUCCESS;
+
+
+    if(pTimerFunction == NULL)
+    {
+        return SII_OS_STATUS_ERR_INVALID_PARAM;
+    }
+
+    timerObj = kmalloc(sizeof(timerObject_t), GFP_KERNEL);
+    if(timerObj == NULL)
+    {
+        return SII_OS_STATUS_ERR_NOT_AVAIL;
+    }
+
+    strncpy(timerObj->timerName, pName, MAX_TIMER_NAME_LEN-1);
+    timerObj->timerName[MAX_TIMER_NAME_LEN-1] = 0;
+
+    timerObj->callbackHandler = pTimerFunction;
+    timerObj->callbackParam = pTimerArg;
+    timerObj->flags = 0;
+
+    INIT_WORK(&timerObj->workItem, WorkHandler);
+
+    list_add(&timerObj->listEntry, &timerList);
+
+    hrtimer_init(&timerObj->hrTimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    timerObj->hrTimer.function = TimerHandler;
+
+    *pTimerId = timerObj;
+    return status;
+}
+
+
+
+/*****************************************************************************/
+/**
+ * @brief Delete a previously allocated OSAL timer object.
+ *
+ *****************************************************************************/
+SiiOsStatus_t SiiOsTimerDelete(SiiOsTimer_t *pTimerId)
+{
+    SiiOsTimer_t timer;
+
+    if (SiiOsTimerValidCheck(*pTimerId))
+    {
+        timer = *pTimerId;
+        list_del(&timer->listEntry);
+
+        hrtimer_cancel(&timer->hrTimer);
+
+        if(timer->flags & TIMER_OBJ_FLAG_WORK_IP)
+        {
+            // Request to delete timer object came from within the timer's
+            // callback handler.  If we were to proceed with the timer deletion
+            // we would deadlock at cancel_work_sync().  So instead just flag
+            // that the user wants the timer deleted.  Later when the timer
+            // callback completes the timer's work handler will complete the
+            // process of deleting this timer.
+            timer->flags |= TIMER_OBJ_FLAG_DEL_REQ;
+        }
+        else
+        {
+            cancel_work_sync(&timer->workItem);
+            kfree(timer);
+            *pTimerId = NULL;
+        }
+    }
+    else
+    {
+        return SII_OS_STATUS_ERR_INVALID_PARAM;
+    }
+
+    return SII_OS_STATUS_SUCCESS;
+}
+
+
+SiiOsStatus_t  SiiOsTimerStart(SiiOsTimer_t timerId, uint32_t time_msec)
+{
+    SiiOsTimer_t  timer;
+    ktime_t timer_period;
+
+    if (SiiOsTimerValidCheck(timerId))
+    {
+        long secs=0;
+        timer = timerId;
+
+        secs=time_msec/1000;
+        time_msec %= 1000;
+        timer_period = ktime_set(secs, MSEC_TO_NSEC(time_msec));
+        hrtimer_start(&timer->hrTimer, timer_period, HRTIMER_MODE_REL);
+    }
+    else
+    {
+        return SII_OS_STATUS_ERR_INVALID_PARAM;
+    }
+
+    return SII_OS_STATUS_SUCCESS;
+}
+
+SiiOsStatus_t  SiiOsTimerStop(SiiOsTimer_t timerId)
+{
+    SiiOsTimer_t  timer;
+
+    if (SiiOsTimerValidCheck(timerId))
+    {
+        timer = timerId;
+        hrtimer_cancel(&timer->hrTimer);
+    }
+    else
+    {
+        return SII_OS_STATUS_ERR_INVALID_PARAM;
+    }
+
+    return SII_OS_STATUS_SUCCESS;
+}
+
diff --git a/drivers/amlogic/video_dev/Kconfig b/drivers/amlogic/video_dev/Kconfig
index 54e05015fffe..bdae1486c11c 100755
--- a/drivers/amlogic/video_dev/Kconfig
+++ b/drivers/amlogic/video_dev/Kconfig
@@ -12,7 +12,8 @@ config V4L_AMLOGIC_VIDEO
 config V4L_AMLOGIC_VIDEO2
 	tristate "Amlogic v4l video2 device support"
 	select VIDEO_DEV
-	select VIDEO_V4L2
+	select VIDEOBUF_GEN
+	select VIDEO_V4L2_COMMON
 	select VIDEOBUF_RESOURCE
 	select AM_GE2D
     	default n
diff --git a/drivers/amlogic/video_dev/amlvideo2.c b/drivers/amlogic/video_dev/amlvideo2.c
index 5118828cb165..552c6cc323a5 100755
--- a/drivers/amlogic/video_dev/amlvideo2.c
+++ b/drivers/amlogic/video_dev/amlvideo2.c
@@ -37,6 +37,7 @@
 #include <linux/amlogic/amports/vframe.h>
 #include <linux/amlogic/amports/vframe_provider.h>
 #include <linux/amlogic/amports/vframe_receiver.h>
+#include "common/vfp-queue.h"
 #include <linux/amlogic/ge2d/ge2d.h>
 #include <linux/amlogic/amports/timestamp.h>
 #include <linux/kernel.h>
@@ -80,6 +81,7 @@
 #define RECEIVER_NAME1 "amlvideo2_1"
 #else
 #define RECEIVER_NAME "amlvideo2"
+#define DEVICE_NAME   "amlvideo2"
 #endif
 
 #define VM_RES0_CANVAS_INDEX AMLVIDEO2_RES_CANVAS
@@ -108,6 +110,11 @@ static unsigned debug=0;
 //module_param(debug, uint, 0644);
 //MODULE_PARM_DESC(debug, "activates debug info");
 
+#define AMLVIDEO2_POOL_SIZE 4
+static vfq_t q_ready;
+void vf_inqueue(struct vframe_s *vf, const char *receiver);
+struct vframe_s *amlvideo2_pool_ready[AMLVIDEO2_POOL_SIZE+1];
+
 struct timeval thread_ts1;
 struct timeval thread_ts2;
 static int frameInv_adjust = 0;
@@ -122,7 +129,7 @@ MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
 
 static struct v4l2_fract amlvideo2_frmintervals_active = {
 	.numerator = 1,
-	.denominator = DEF_FRAMERATE,
+	.denominator = 30,
 };
 
 static struct vdin_v4l2_ops_s vops;
@@ -176,12 +183,20 @@ static struct v4l2_frmivalenum amlvideo2_frmivalenum[]={
 
 typedef enum{
 	AML_PROVIDE_NONE  = 0,
-	AML_PROVIDE_VDIN0  = 1,
-	AML_PROVIDE_VDIN1  = 2,
-	AML_PROVIDE_DECODE  = 3,
-	AML_PROVIDE_MAX  = 4
+	AML_PROVIDE_MIRROCAST_VDIN0  = 1,
+	AML_PROVIDE_MIRROCAST_VDIN1  = 2,
+	AML_PROVIDE_HDMIIN_VDIN0  = 3,
+	AML_PROVIDE_HDMIIN_VDIN1  = 4,
+	AML_PROVIDE_DECODE  = 5,
+	AML_PROVIDE_MAX  = 6
 }aml_provider_type;
 
+typedef enum{
+	AML_RECEIVER_NONE  = 0,
+	AML_RECEIVER_PPMGR,
+	AML_RECEIVER_MAX,
+}aml_receiver_type;
+
 struct amlvideo2_fmt {
 	char  *name;
 	u32   fourcc;          /* v4l2 format id */
@@ -299,6 +314,7 @@ struct amlvideo2_device{
 	int node_num;
 };
 
+struct amlvideo2_fh;
 struct amlvideo2_node {
 
 	spinlock_t                 slock;
@@ -318,10 +334,14 @@ struct amlvideo2_node {
 
 	struct videobuf_res_privdata res;
 	struct vframe_receiver_s recv;
-	//struct vframe_provider_s * provider;
-	//aml_provider_type p_type;
+	struct vframe_receiver_s *sub_recv;
+	struct vframe_provider_s *provider;
+	aml_provider_type p_type;
+	aml_receiver_type r_type;
 	int provide_ready;
-	
+
+	struct amlvideo2_fh *fh;
+	unsigned int input;			//0:mirrocast; 1:hdmiin
 	ge2d_context_t *context;
 };
 
@@ -373,8 +393,6 @@ int get_amlvideo2_canvas_index(struct amlvideo2_output* output, int start_canvas
 	unsigned buf = (unsigned)output->vbuf;
 	int width = output->width;
 	int height = output->height;
-	if(height==1080)
-		height = 1088;
 
 	switch(v4l2_format){
 	case V4L2_PIX_FMT_RGB565X:
@@ -499,89 +517,1224 @@ static int get_input_format(vframe_t* vf)
 		}else if(vf->type &VIDTYPE_INTERLACE_TOP){
 			format =  GE2D_FORMAT_M24_YUV420|(GE2D_FORMAT_M24_YUV420T & (3<<3));
 		}else{
-			format =  GE2D_FORMAT_M24_YUV420;
+			format =  GE2D_FORMAT_M24_YUV420;
+		}
+	}
+	if(print_ifmt == 1){
+		printk("vf->type=%x, format=%x, w*h=%dx%d, canvas0=%x, canvas1=%x\n",
+                        vf->type, format, vf->width, vf->height, vf->canvas0Addr, vf->canvas1Addr);
+
+                printk("vf->type=%x, VIDTYPE_INTERLACE_BOTTOM=%x, VIDTYPE_INTERLACE_TOP=%x\n",
+                vf->type, VIDTYPE_INTERLACE_BOTTOM, VIDTYPE_INTERLACE_TOP);
+		print_ifmt = 0;
+	}
+	return format;
+}
+
+static int get_interlace_input_format(vframe_t* vf, struct amlvideo2_output* output)
+{
+	int format= GE2D_FORMAT_M24_NV21;
+	if(vf->type&VIDTYPE_VIU_422){
+                format =  GE2D_FORMAT_S16_YUV422;
+                if(vf->height >= output->height<<2){
+			format =  GE2D_FORMAT_S16_YUV422|(GE2D_FORMAT_S16_YUV422T & (3<<3));
+                }
+	}else if(vf->type&VIDTYPE_VIU_NV21){
+                format =  GE2D_FORMAT_M24_NV21;
+                if(vf->height >= output->height<<2){
+			format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21T & (3<<3));
+                }
+	} else{
+                format =  GE2D_FORMAT_M24_YUV420;
+                if(vf->height >= output->height<<2){
+			format =  GE2D_FORMAT_M24_YUV420|(GE2D_FORMAT_M24_YUV420T & (3<<3));
+                }
+	}
+	if(print_ifmt == 1){
+		printk("vf->type=%x, format=%x, w*h=%dx%d, canvas0=%x, canvas1=%x\n",
+                        vf->type, format, vf->width, vf->height, vf->canvas0Addr, vf->canvas1Addr);
+		print_ifmt = 0;
+	}
+	return format;
+}
+
+static inline int get_top_input_format(vframe_t* vf)
+{
+	int format= GE2D_FORMAT_M24_NV21;
+	if(vf->type&VIDTYPE_VIU_422){
+                format =  GE2D_FORMAT_S16_YUV422|(GE2D_FORMAT_S16_YUV422T & (3<<3));
+	}else if(vf->type&VIDTYPE_VIU_NV21){
+                format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21T & (3<<3));
+	} else{
+                format =  GE2D_FORMAT_M24_YUV420|(GE2D_FORMAT_M24_YUV420T & (3<<3));
+	}
+	if(print_ifmt == 1){
+		printk("vf->type=%x, format=%x, w*h=%dx%d, canvas0=%x, canvas1=%x\n",
+                        vf->type, format, vf->width, vf->height, vf->canvas0Addr, vf->canvas1Addr);
+		print_ifmt = 0;
+	}
+	return format;
+}
+
+static inline int get_bottom_input_format(vframe_t* vf)
+{
+	int format= GE2D_FORMAT_M24_NV21;
+	if(vf->type&VIDTYPE_VIU_422){
+                format =  GE2D_FORMAT_S16_YUV422|(GE2D_FORMAT_S16_YUV422B & (3<<3));
+	}else if(vf->type&VIDTYPE_VIU_NV21){
+                format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21B & (3<<3));
+	} else{
+                format =  GE2D_FORMAT_M24_YUV420|(GE2D_FMT_M24_YUV420B & (3<<3));
+        }
+
+	if(print_ifmt == 1){
+		printk("vf->type=%x, format=%x, w*h=%dx%d, canvas0=%x, canvas1=%x\n",
+                        vf->type, format, vf->width, vf->height, vf->canvas0Addr, vf->canvas1Addr);
+		print_ifmt = 0;
+	}
+	return format;
+}
+
+static unsigned int print_ofmt=0;
+module_param(print_ofmt, uint, 0644);
+MODULE_PARM_DESC(print_ofmt, "print output format\n");
+
+static int get_output_format(int v4l2_format)
+{
+	int format = GE2D_FORMAT_S24_YUV444;
+	switch(v4l2_format){
+		case V4L2_PIX_FMT_RGB565X:
+			format = GE2D_FORMAT_S16_RGB_565;
+			break;
+		case V4L2_PIX_FMT_YUV444:
+			format = GE2D_FORMAT_S24_YUV444;
+			break;
+		case V4L2_PIX_FMT_VYUY:
+			format = GE2D_FORMAT_S16_YUV422;
+			break;
+		case V4L2_PIX_FMT_BGR24:
+			format = GE2D_FORMAT_S24_RGB ;
+			break;
+		case V4L2_PIX_FMT_RGB24:
+			format = GE2D_FORMAT_S24_BGR; 
+			break;
+		case V4L2_PIX_FMT_NV12:
+			format = GE2D_FORMAT_M24_NV12;
+			break;
+		case V4L2_PIX_FMT_NV21:
+			format = GE2D_FORMAT_M24_NV21;
+			break;
+		case V4L2_PIX_FMT_YUV420:
+		case V4L2_PIX_FMT_YVU420:
+			format = GE2D_FORMAT_S8_Y;
+			break;
+		default:
+			break;            
+	}   
+	if(print_ofmt == 1){
+            printk("outputformat, v4l2_format=%x, format=%x\n",
+                    v4l2_format, format);
+            print_ofmt = 0;
+	}
+	return format;
+}
+
+static void output_axis_adjust(int src_w, int src_h, int* dst_w, int* dst_h, int angle)
+{
+    int w = 0, h = 0,disp_w = 0, disp_h =0;
+    disp_w = *dst_w;
+    disp_h = *dst_h;
+    if (angle %180 !=0) {
+        h = min((int)src_w, disp_h);
+        w = src_h * h / src_w;
+        if(w > disp_w ){
+            h = (h * disp_w)/w ;
+            w = disp_w;
+        }
+    }else{
+        if ((src_w < disp_w) && (src_h < disp_h)) {
+            w = src_w;
+            h = src_h;
+        } else if ((src_w * disp_h) > (disp_w * src_h)) {
+            w = disp_w;
+            h = disp_w * src_h / src_w;
+        } else {
+            h = disp_h;
+            w = disp_h * src_w / src_h;
+        }
+    }
+    *dst_w = w;
+    *dst_h = h;
+}
+
+int amlvideo2_ge2d_interlace_two_canvasAddr_process(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config, struct amlvideo2_output* output)
+{
+	int src_top ,src_left ,src_width, src_height;
+	int dst_top ,dst_left ,dst_width, dst_height;
+	canvas_t cs0,cs1,cs2,cd;
+	int current_mirror = 0;
+	int cur_angle = 0;
+	int output_canvas  = vf->canvas0Addr;
+
+        //============================
+        //      top field
+        //============================
+	src_top = 0;
+	src_left = 0;
+	src_width = vf->width;
+	src_height = vf->height/2;
+
+	dst_top = 0;
+	dst_left = 0;
+	dst_width = output->width;
+	dst_height = output->height;
+
+	current_mirror = 0;
+	cur_angle = output->angle;
+	if(current_mirror == 1)
+		cur_angle = (360 - cur_angle%360);
+	else
+		cur_angle = cur_angle%360;
+
+	if(src_width<src_height)
+		cur_angle = (cur_angle+90)%360;
+
+       output_axis_adjust(src_width,src_height,&dst_width,&dst_height,cur_angle);
+	dst_top = (output->height-dst_height)/2;
+	dst_left = (output->width-dst_width)/2;
+	dst_top = dst_top&0xfffffffe;
+	dst_left = dst_left&0xfffffffe;
+	/* data operating. */
+
+	memset(ge2d_config,0,sizeof(config_para_ex_t));
+	if((dst_left!=output->frame->x)||(dst_top!=output->frame->y)
+	  ||(dst_width!=output->frame->w)||(dst_height!=output->frame->h)){
+		ge2d_config->alu_const_color= 0;//0x000000ff;
+		ge2d_config->bitmask_en  = 0;
+		ge2d_config->src1_gb_alpha = 0;//0xff;
+		ge2d_config->dst_xy_swap = 0;
+
+		canvas_read(output_canvas&0xff,&cd);
+		ge2d_config->src_planes[0].addr = cd.addr;
+		ge2d_config->src_planes[0].w = cd.width;
+		ge2d_config->src_planes[0].h = cd.height;
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+
+		ge2d_config->src_key.key_enable = 0;
+		ge2d_config->src_key.key_mask = 0;
+		ge2d_config->src_key.key_mode = 0;
+
+		ge2d_config->src_para.canvas_index=output_canvas;
+		ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+		ge2d_config->src_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;;
+		ge2d_config->src_para.fill_color_en = 0;
+		ge2d_config->src_para.fill_mode = 0;
+		ge2d_config->src_para.x_rev = 0;
+		ge2d_config->src_para.y_rev = 0;
+		ge2d_config->src_para.color = 0;
+		ge2d_config->src_para.top = 0;
+		ge2d_config->src_para.left = 0;
+		ge2d_config->src_para.width = output->width;
+		ge2d_config->src_para.height = output->height;
+
+		ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+		ge2d_config->dst_para.canvas_index=output_canvas;
+		ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+		ge2d_config->dst_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;;
+		ge2d_config->dst_para.fill_color_en = 0;
+		ge2d_config->dst_para.fill_mode = 0;
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 0;
+		ge2d_config->dst_para.color = 0;
+		ge2d_config->dst_para.top = 0;
+		ge2d_config->dst_para.left = 0;
+		ge2d_config->dst_para.width = output->width;
+		ge2d_config->dst_para.height = output->height;
+
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -2;
+		}
+		fillrect(context, 0, 0, output->width, output->height, (ge2d_config->dst_para.format&GE2D_FORMAT_YUV)?0x008080ff:0);
+		output->frame->x = dst_left;
+		output->frame->y = dst_top;
+		output->frame->w = dst_width;
+		output->frame->h = dst_height;
+		memset(ge2d_config,0,sizeof(config_para_ex_t));
+	}
+	ge2d_config->alu_const_color= 0;//0x000000ff;
+	ge2d_config->bitmask_en  = 0;
+	ge2d_config->src1_gb_alpha = 0;//0xff;
+	ge2d_config->dst_xy_swap = 0;
+
+	canvas_read(vf->canvas0Addr&0xff,&cs0);
+	canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+	canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+	ge2d_config->src_planes[0].addr = cs0.addr;
+	ge2d_config->src_planes[0].w = cs0.width;
+	ge2d_config->src_planes[0].h = cs0.height;
+	ge2d_config->src_planes[1].addr = cs1.addr;
+	ge2d_config->src_planes[1].w = cs1.width;
+	ge2d_config->src_planes[1].h = cs1.height;
+	ge2d_config->src_planes[2].addr = cs2.addr;
+	ge2d_config->src_planes[2].w = cs2.width;
+	ge2d_config->src_planes[2].h = cs2.height;
+	canvas_read(output_canvas&0xff,&cd);
+	ge2d_config->dst_planes[0].addr = cd.addr;
+	ge2d_config->dst_planes[0].w = cd.width;
+	ge2d_config->dst_planes[0].h = cd.height;
+	ge2d_config->src_key.key_enable = 0;
+	ge2d_config->src_key.key_mask = 0;
+	ge2d_config->src_key.key_mode = 0;
+	ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+	ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->src_para.format = get_input_format(vf);
+	ge2d_config->src_para.fill_color_en = 0;
+	ge2d_config->src_para.fill_mode = 0;
+	ge2d_config->src_para.x_rev = 0;
+	ge2d_config->src_para.y_rev = 0;
+	ge2d_config->src_para.color = 0xffffffff;
+	ge2d_config->src_para.top = 0;
+	ge2d_config->src_para.left = 0;
+	ge2d_config->src_para.width = vf->width;
+	ge2d_config->src_para.height = vf->height;
+	/* printk("vf_width is %d , vf_height is %d \n",vf->width ,vf->height); */
+	ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.canvas_index = output_canvas&0xff;
+
+	if((output->v4l2_format!= V4L2_PIX_FMT_YUV420)
+		&& (output->v4l2_format != V4L2_PIX_FMT_YVU420))
+		ge2d_config->dst_para.canvas_index = output_canvas;
+
+	ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;     
+	ge2d_config->dst_para.fill_color_en = 0;
+	ge2d_config->dst_para.fill_mode = 0;
+	ge2d_config->dst_para.x_rev = 0;
+	ge2d_config->dst_para.y_rev = 0;
+	ge2d_config->dst_para.color = 0;
+	ge2d_config->dst_para.top = 0;
+	ge2d_config->dst_para.left = 0;
+	ge2d_config->dst_para.width = output->width;
+	ge2d_config->dst_para.height = output->height;
+
+	if(current_mirror==1){
+		ge2d_config->dst_para.x_rev = 1;
+		ge2d_config->dst_para.y_rev = 0;
+	}else if(current_mirror==2){
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 1;
+	}else{
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 0;
+	}
+
+	if(cur_angle==90){
+		ge2d_config->dst_xy_swap = 1;
+		ge2d_config->dst_para.x_rev ^= 1;
+	}else if(cur_angle==180){
+		ge2d_config->dst_para.x_rev ^= 1;
+		ge2d_config->dst_para.y_rev ^= 1;
+	}else if(cur_angle==270){
+		ge2d_config->dst_xy_swap = 1;
+		ge2d_config->dst_para.y_rev ^= 1;
+	}
+
+	if(ge2d_context_config_ex(context,ge2d_config)<0) {
+		printk("++ge2d configing error.\n");
+		return -1;
+	}
+	stretchblt_noalpha(context,src_left ,src_top ,src_width, src_height,output->frame->x,output->frame->y,output->frame->w,output->frame->h);
+
+	/* for cr of  yuv420p or yuv420sp. */
+	if((output->v4l2_format==V4L2_PIX_FMT_YUV420)
+		||(output->v4l2_format==V4L2_PIX_FMT_YVU420)){
+		/* for cb. */
+		canvas_read((output_canvas>>8)&0xff,&cd);
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+		ge2d_config->dst_para.canvas_index=(output_canvas>>8)&0xff;
+		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
+		ge2d_config->dst_para.width = output->width/2;
+		ge2d_config->dst_para.height = output->height/2;
+		ge2d_config->dst_xy_swap = 0;
+
+		if(current_mirror==1){
+			ge2d_config->dst_para.x_rev = 1;
+			ge2d_config->dst_para.y_rev = 0;
+		}else if(current_mirror==2){
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 1;
+		}else{
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 0;
+		}
+
+		if(cur_angle==90){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.x_rev ^= 1;
+		}else if(cur_angle==180){
+			ge2d_config->dst_para.x_rev ^= 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}else if(cur_angle==270){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}
+	
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -1;
+		}
+		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+			output->frame->x/2,output->frame->y/2,output->frame->w/2,output->frame->h/2);
+	} 
+	/* for cb of yuv420p or yuv420sp. */
+	if(output->v4l2_format==V4L2_PIX_FMT_YUV420||
+		output->v4l2_format==V4L2_PIX_FMT_YVU420) {
+		canvas_read((output_canvas>>16)&0xff,&cd);
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+		ge2d_config->dst_para.canvas_index=(output_canvas>>16)&0xff;
+		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CR|GE2D_LITTLE_ENDIAN;
+		ge2d_config->dst_para.width = output->width/2;
+		ge2d_config->dst_para.height = output->height/2;
+		ge2d_config->dst_xy_swap = 0;
+
+		if(current_mirror==1){
+			ge2d_config->dst_para.x_rev = 1;
+			ge2d_config->dst_para.y_rev = 0;
+		}else if(current_mirror==2){
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 1;
+		}else{
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 0;
+		}
+
+		if(cur_angle==90){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.x_rev ^= 1;
+		}else if(cur_angle==180){
+			ge2d_config->dst_para.x_rev ^= 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}else if(cur_angle==270){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}
+
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -1;
+		}
+		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+			output->frame->x/2,output->frame->y/2,output->frame->w/2,output->frame->h/2);
+	}
+
+     //============================
+    //      bottom field
+    //============================
+	output_canvas  = vf->canvas1Addr;
+	src_top = 0;
+	src_left = 0;
+	src_width = vf->width;
+	src_height = vf->height/2;
+
+	dst_top = 0;
+	dst_left = 0;
+	dst_width = output->width;
+	dst_height = output->height;
+
+	current_mirror = 0;
+	cur_angle = output->angle;
+	if(current_mirror == 1)
+		cur_angle = (360 - cur_angle%360);
+	else
+		cur_angle = cur_angle%360;
+
+	if(src_width<src_height)
+		cur_angle = (cur_angle+90)%360;
+
+       output_axis_adjust(src_width,src_height,&dst_width,&dst_height,cur_angle);
+	dst_top = (output->height-dst_height)/2;
+	dst_left = (output->width-dst_width)/2;
+	dst_top = dst_top&0xfffffffe;
+	dst_left = dst_left&0xfffffffe;
+	/* data operating. */
+
+	memset(ge2d_config,0,sizeof(config_para_ex_t));
+	if((dst_left!=output->frame->x)||(dst_top!=output->frame->y)
+	  ||(dst_width!=output->frame->w)||(dst_height!=output->frame->h)){
+		ge2d_config->alu_const_color= 0;//0x000000ff;
+		ge2d_config->bitmask_en  = 0;
+		ge2d_config->src1_gb_alpha = 0;//0xff;
+		ge2d_config->dst_xy_swap = 0;
+
+		canvas_read(output_canvas&0xff,&cd);
+		ge2d_config->src_planes[0].addr = cd.addr;
+		ge2d_config->src_planes[0].w = cd.width;
+		ge2d_config->src_planes[0].h = cd.height;
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+
+		ge2d_config->src_key.key_enable = 0;
+		ge2d_config->src_key.key_mask = 0;
+		ge2d_config->src_key.key_mode = 0;
+
+		ge2d_config->src_para.canvas_index=output_canvas;
+		ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+		ge2d_config->src_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;;
+		ge2d_config->src_para.fill_color_en = 0;
+		ge2d_config->src_para.fill_mode = 0;
+		ge2d_config->src_para.x_rev = 0;
+		ge2d_config->src_para.y_rev = 0;
+		ge2d_config->src_para.color = 0;
+		ge2d_config->src_para.top = 0;
+		ge2d_config->src_para.left = 0;
+		ge2d_config->src_para.width = output->width;
+		ge2d_config->src_para.height = output->height;
+
+		ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+		ge2d_config->dst_para.canvas_index=output_canvas;
+		ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+		ge2d_config->dst_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;;
+		ge2d_config->dst_para.fill_color_en = 0;
+		ge2d_config->dst_para.fill_mode = 0;
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 0;
+		ge2d_config->dst_para.color = 0;
+		ge2d_config->dst_para.top = 0;
+		ge2d_config->dst_para.left = 0;
+		ge2d_config->dst_para.width = output->width;
+		ge2d_config->dst_para.height = output->height;
+
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -2;
+		}
+		fillrect(context, 0, 0, output->width, output->height, (ge2d_config->dst_para.format&GE2D_FORMAT_YUV)?0x008080ff:0);
+		output->frame->x = dst_left;
+		output->frame->y = dst_top;
+		output->frame->w = dst_width;
+		output->frame->h = dst_height;
+		memset(ge2d_config,0,sizeof(config_para_ex_t));
+	}
+	ge2d_config->alu_const_color= 0;//0x000000ff;
+	ge2d_config->bitmask_en  = 0;
+	ge2d_config->src1_gb_alpha = 0;//0xff;
+	ge2d_config->dst_xy_swap = 0;
+
+	canvas_read(vf->canvas1Addr&0xff,&cs0);
+	canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
+	canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
+	ge2d_config->src_planes[0].addr = cs0.addr;
+	ge2d_config->src_planes[0].w = cs0.width;
+	ge2d_config->src_planes[0].h = cs0.height;
+	ge2d_config->src_planes[1].addr = cs1.addr;
+	ge2d_config->src_planes[1].w = cs1.width;
+	ge2d_config->src_planes[1].h = cs1.height;
+	ge2d_config->src_planes[2].addr = cs2.addr;
+	ge2d_config->src_planes[2].w = cs2.width;
+	ge2d_config->src_planes[2].h = cs2.height;
+	canvas_read(output_canvas&0xff,&cd);
+	ge2d_config->dst_planes[0].addr = cd.addr;
+	ge2d_config->dst_planes[0].w = cd.width;
+	ge2d_config->dst_planes[0].h = cd.height;
+	ge2d_config->src_key.key_enable = 0;
+	ge2d_config->src_key.key_mask = 0;
+	ge2d_config->src_key.key_mode = 0;
+	ge2d_config->src_para.canvas_index=vf->canvas1Addr;
+	ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->src_para.format = get_input_format(vf);
+	ge2d_config->src_para.fill_color_en = 0;
+	ge2d_config->src_para.fill_mode = 0;
+	ge2d_config->src_para.x_rev = 0;
+	ge2d_config->src_para.y_rev = 0;
+	ge2d_config->src_para.color = 0xffffffff;
+	ge2d_config->src_para.top = 0;
+	ge2d_config->src_para.left = 0;
+	ge2d_config->src_para.width = vf->width;
+	ge2d_config->src_para.height = vf->height;
+	/* printk("vf_width is %d , vf_height is %d \n",vf->width ,vf->height); */
+	ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.canvas_index = output_canvas&0xff;
+
+	if((output->v4l2_format!= V4L2_PIX_FMT_YUV420)
+		&& (output->v4l2_format != V4L2_PIX_FMT_YVU420))
+		ge2d_config->dst_para.canvas_index = output_canvas;
+
+	ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;     
+	ge2d_config->dst_para.fill_color_en = 0;
+	ge2d_config->dst_para.fill_mode = 0;
+	ge2d_config->dst_para.x_rev = 0;
+	ge2d_config->dst_para.y_rev = 0;
+	ge2d_config->dst_para.color = 0;
+	ge2d_config->dst_para.top = 0;
+	ge2d_config->dst_para.left = 0;
+	ge2d_config->dst_para.width = output->width;
+	ge2d_config->dst_para.height = output->height;
+
+	if(current_mirror==1){
+		ge2d_config->dst_para.x_rev = 1;
+		ge2d_config->dst_para.y_rev = 0;
+	}else if(current_mirror==2){
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 1;
+	}else{
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 0;
+	}
+
+	if(cur_angle==90){
+		ge2d_config->dst_xy_swap = 1;
+		ge2d_config->dst_para.x_rev ^= 1;
+	}else if(cur_angle==180){
+		ge2d_config->dst_para.x_rev ^= 1;
+		ge2d_config->dst_para.y_rev ^= 1;
+	}else if(cur_angle==270){
+		ge2d_config->dst_xy_swap = 1;
+		ge2d_config->dst_para.y_rev ^= 1;
+	}
+
+	if(ge2d_context_config_ex(context,ge2d_config)<0) {
+		printk("++ge2d configing error.\n");
+		return -1;
+	}
+	stretchblt_noalpha(context,src_left ,src_top ,src_width, src_height,output->frame->x,output->frame->y,output->frame->w,output->frame->h);
+
+	/* for cr of  yuv420p or yuv420sp. */
+	if((output->v4l2_format==V4L2_PIX_FMT_YUV420)
+		||(output->v4l2_format==V4L2_PIX_FMT_YVU420)){
+		/* for cb. */
+		canvas_read((output_canvas>>8)&0xff,&cd);
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+		ge2d_config->dst_para.canvas_index=(output_canvas>>8)&0xff;
+		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
+		ge2d_config->dst_para.width = output->width/2;
+		ge2d_config->dst_para.height = output->height/2;
+		ge2d_config->dst_xy_swap = 0;
+
+		if(current_mirror==1){
+			ge2d_config->dst_para.x_rev = 1;
+			ge2d_config->dst_para.y_rev = 0;
+		}else if(current_mirror==2){
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 1;
+		}else{
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 0;
+		}
+
+		if(cur_angle==90){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.x_rev ^= 1;
+		}else if(cur_angle==180){
+			ge2d_config->dst_para.x_rev ^= 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}else if(cur_angle==270){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}
+	
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -1;
+		}
+		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+			output->frame->x/2,output->frame->y/2,output->frame->w/2,output->frame->h/2);
+	} 
+	/* for cb of yuv420p or yuv420sp. */
+	if(output->v4l2_format==V4L2_PIX_FMT_YUV420||
+		output->v4l2_format==V4L2_PIX_FMT_YVU420) {
+		canvas_read((output_canvas>>16)&0xff,&cd);
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+		ge2d_config->dst_para.canvas_index=(output_canvas>>16)&0xff;
+		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CR|GE2D_LITTLE_ENDIAN;
+		ge2d_config->dst_para.width = output->width/2;
+		ge2d_config->dst_para.height = output->height/2;
+		ge2d_config->dst_xy_swap = 0;
+
+		if(current_mirror==1){
+			ge2d_config->dst_para.x_rev = 1;
+			ge2d_config->dst_para.y_rev = 0;
+		}else if(current_mirror==2){
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 1;
+		}else{
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 0;
+		}
+
+		if(cur_angle==90){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.x_rev ^= 1;
+		}else if(cur_angle==180){
+			ge2d_config->dst_para.x_rev ^= 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}else if(cur_angle==270){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}
+
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -1;
+		}
+		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+			output->frame->x/2,output->frame->y/2,output->frame->w/2,output->frame->h/2);
+	}
+	
+	
+	return output_canvas;
+}
+
+int amlvideo2_ge2d_interlace_vdindata_process(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config, struct amlvideo2_output* output)
+{
+	int src_top ,src_left ,src_width, src_height;
+	int dst_top ,dst_left ,dst_width, dst_height;
+	canvas_t cs0,cs1,cs2,cd;
+	int current_mirror = 0;
+	int cur_angle = 0;
+	int output_canvas  = output->canvas_id;
+
+	src_top = 0;
+	src_left = 0;
+	src_width = vf->width;
+	src_height = vf->height;
+
+	dst_top = 0;
+	dst_left = 0;
+	dst_width = output->width;
+	dst_height = output->height;
+
+	current_mirror = 0;
+	cur_angle = output->angle;
+	if(current_mirror == 1)
+		cur_angle = (360 - cur_angle%360);
+	else
+		cur_angle = cur_angle%360;
+
+	if(src_width<src_height)
+		cur_angle = (cur_angle+90)%360;
+
+       output_axis_adjust(src_width,src_height,&dst_width,&dst_height,cur_angle);
+	dst_top = (output->height-dst_height)/2;
+	dst_left = (output->width-dst_width)/2;
+	dst_top = dst_top&0xfffffffe;
+	dst_left = dst_left&0xfffffffe;
+	/* data operating. */
+
+	memset(ge2d_config,0,sizeof(config_para_ex_t));
+	if((dst_left!=output->frame->x)||(dst_top!=output->frame->y)
+	  ||(dst_width!=output->frame->w)||(dst_height!=output->frame->h)){
+		ge2d_config->alu_const_color= 0;//0x000000ff;
+		ge2d_config->bitmask_en  = 0;
+		ge2d_config->src1_gb_alpha = 0;//0xff;
+		ge2d_config->dst_xy_swap = 0;
+
+		canvas_read(output_canvas&0xff,&cd);
+		ge2d_config->src_planes[0].addr = cd.addr;
+		ge2d_config->src_planes[0].w = cd.width;
+		ge2d_config->src_planes[0].h = cd.height;
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+
+		ge2d_config->src_key.key_enable = 0;
+		ge2d_config->src_key.key_mask = 0;
+		ge2d_config->src_key.key_mode = 0;
+
+		ge2d_config->src_para.canvas_index=output_canvas;
+		ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+		ge2d_config->src_para.format = get_interlace_input_format(vf, output)|GE2D_LITTLE_ENDIAN;
+		ge2d_config->src_para.format = get_interlace_input_format(vf, output);
+		ge2d_config->src_para.fill_color_en = 0;
+		ge2d_config->src_para.fill_mode = 0;
+		ge2d_config->src_para.x_rev = 0;
+		ge2d_config->src_para.y_rev = 0;
+		ge2d_config->src_para.color = 0;
+		ge2d_config->src_para.top = 0;
+		ge2d_config->src_para.left = 0;
+		ge2d_config->src_para.width = output->width;
+		ge2d_config->src_para.height = output->height;
+
+		ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+		ge2d_config->dst_para.canvas_index=output_canvas;
+		ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+		ge2d_config->dst_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;;
+		ge2d_config->dst_para.fill_color_en = 0;
+		ge2d_config->dst_para.fill_mode = 0;
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 0;
+		ge2d_config->dst_para.color = 0;
+		ge2d_config->dst_para.top = 0;
+		ge2d_config->dst_para.left = 0;
+		ge2d_config->dst_para.width = output->width;
+		ge2d_config->dst_para.height = output->height;
+
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -2;
+		}
+		fillrect(context, 0, 0, output->width, output->height, (ge2d_config->dst_para.format&GE2D_FORMAT_YUV)?0x008080ff:0);
+		output->frame->x = dst_left;
+		output->frame->y = dst_top;
+		output->frame->w = dst_width;
+		output->frame->h = dst_height;
+		memset(ge2d_config,0,sizeof(config_para_ex_t));
+	}
+	src_height = vf->height/2;
+	ge2d_config->alu_const_color= 0;//0x000000ff;
+	ge2d_config->bitmask_en  = 0;
+	ge2d_config->src1_gb_alpha = 0;//0xff;
+	ge2d_config->dst_xy_swap = 0;
+
+	canvas_read(vf->canvas0Addr&0xff,&cs0);
+	canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+	canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+	ge2d_config->src_planes[0].addr = cs0.addr;
+	ge2d_config->src_planes[0].w = cs0.width;
+	ge2d_config->src_planes[0].h = cs0.height;
+	ge2d_config->src_planes[1].addr = cs1.addr;
+	ge2d_config->src_planes[1].w = cs1.width;
+	ge2d_config->src_planes[1].h = cs1.height;
+	ge2d_config->src_planes[2].addr = cs2.addr;
+	ge2d_config->src_planes[2].w = cs2.width;
+	ge2d_config->src_planes[2].h = cs2.height;
+	canvas_read(output_canvas&0xff,&cd);
+	ge2d_config->dst_planes[0].addr = cd.addr;
+	ge2d_config->dst_planes[0].w = cd.width;
+	ge2d_config->dst_planes[0].h = cd.height;
+	ge2d_config->src_key.key_enable = 0;
+	ge2d_config->src_key.key_mask = 0;
+	ge2d_config->src_key.key_mode = 0;
+	ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+	ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->src_para.format = get_interlace_input_format(vf, output);
+	ge2d_config->src_para.fill_color_en = 0;
+	ge2d_config->src_para.fill_mode = 0;
+	ge2d_config->src_para.x_rev = 0;
+	ge2d_config->src_para.y_rev = 0;
+	ge2d_config->src_para.color = 0xffffffff;
+	ge2d_config->src_para.top = 0;
+	ge2d_config->src_para.left = 0;
+	ge2d_config->src_para.width = vf->width;
+	ge2d_config->src_para.height = src_height;
+	/* printk("vf_width is %d , vf_height is %d \n",vf->width ,vf->height); */
+	ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.canvas_index = output_canvas&0xff;
+
+	if((output->v4l2_format!= V4L2_PIX_FMT_YUV420)
+		&& (output->v4l2_format != V4L2_PIX_FMT_YVU420))
+		ge2d_config->dst_para.canvas_index = output_canvas;
+
+	ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;     
+	ge2d_config->dst_para.fill_color_en = 0;
+	ge2d_config->dst_para.fill_mode = 0;
+	ge2d_config->dst_para.x_rev = 0;
+	ge2d_config->dst_para.y_rev = 0;
+	ge2d_config->dst_para.color = 0;
+	ge2d_config->dst_para.top = 0;
+	ge2d_config->dst_para.left = 0;
+	ge2d_config->dst_para.width = output->width;
+	ge2d_config->dst_para.height = output->height;
+
+	if(current_mirror==1){
+		ge2d_config->dst_para.x_rev = 1;
+		ge2d_config->dst_para.y_rev = 0;
+	}else if(current_mirror==2){
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 1;
+	}else{
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 0;
+	}
+
+	if(cur_angle==90){
+		ge2d_config->dst_xy_swap = 1;
+		ge2d_config->dst_para.x_rev ^= 1;
+	}else if(cur_angle==180){
+		ge2d_config->dst_para.x_rev ^= 1;
+		ge2d_config->dst_para.y_rev ^= 1;
+	}else if(cur_angle==270){
+		ge2d_config->dst_xy_swap = 1;
+		ge2d_config->dst_para.y_rev ^= 1;
+	}
+
+	if(ge2d_context_config_ex(context,ge2d_config)<0) {
+		printk("++ge2d configing error.\n");
+		return -1;
+	}
+	stretchblt_noalpha(context,src_left ,src_top ,src_width, src_height,output->frame->x,output->frame->y,output->frame->w,output->frame->h);
+
+	/* for cr of  yuv420p or yuv420sp. */
+	if((output->v4l2_format==V4L2_PIX_FMT_YUV420)
+		||(output->v4l2_format==V4L2_PIX_FMT_YVU420)){
+		/* for cb. */
+		canvas_read((output_canvas>>8)&0xff,&cd);
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+		ge2d_config->dst_para.canvas_index=(output_canvas>>8)&0xff;
+		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
+		ge2d_config->dst_para.width = output->width/2;
+		ge2d_config->dst_para.height = output->height/2;
+		ge2d_config->dst_xy_swap = 0;
+
+		if(current_mirror==1){
+			ge2d_config->dst_para.x_rev = 1;
+			ge2d_config->dst_para.y_rev = 0;
+		}else if(current_mirror==2){
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 1;
+		}else{
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 0;
+		}
+
+		if(cur_angle==90){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.x_rev ^= 1;
+		}else if(cur_angle==180){
+			ge2d_config->dst_para.x_rev ^= 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}else if(cur_angle==270){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}
+	
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -1;
+		}
+		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+			output->frame->x/2,output->frame->y/2,output->frame->w/2,output->frame->h/2);
+	} 
+	/* for cb of yuv420p or yuv420sp. */
+	if(output->v4l2_format==V4L2_PIX_FMT_YUV420||
+		output->v4l2_format==V4L2_PIX_FMT_YVU420) {
+		canvas_read((output_canvas>>16)&0xff,&cd);
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+		ge2d_config->dst_para.canvas_index=(output_canvas>>16)&0xff;
+		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CR|GE2D_LITTLE_ENDIAN;
+		ge2d_config->dst_para.width = output->width/2;
+		ge2d_config->dst_para.height = output->height/2;
+		ge2d_config->dst_xy_swap = 0;
+
+		if(current_mirror==1){
+			ge2d_config->dst_para.x_rev = 1;
+			ge2d_config->dst_para.y_rev = 0;
+		}else if(current_mirror==2){
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 1;
+		}else{
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 0;
+		}
+
+		if(cur_angle==90){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.x_rev ^= 1;
+		}else if(cur_angle==180){
+			ge2d_config->dst_para.x_rev ^= 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}else if(cur_angle==270){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}
+
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -1;
+		}
+		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+			output->frame->x/2,output->frame->y/2,output->frame->w/2,output->frame->h/2);
+	}
+	return output_canvas;
+}
+
+int amlvideo2_ge2d_interlace_one_canvasAddr_process(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config, struct amlvideo2_output* output)
+{
+	int src_top ,src_left ,src_width, src_height;
+	int dst_top ,dst_left ,dst_width, dst_height;
+	canvas_t cs0,cs1,cs2,cd;
+	int current_mirror = 0;
+	int cur_angle = 0;
+	int output_canvas  = output->canvas_id;
+
+	src_top = 0;
+	src_left = 0;
+	src_width = vf->width;
+	src_height = vf->height/2;
+
+	dst_top = 0;
+	dst_left = 0;
+	dst_width = output->width;
+	dst_height = output->height;
+
+	current_mirror = 0;
+	cur_angle = output->angle;
+	if(current_mirror == 1)
+		cur_angle = (360 - cur_angle%360);
+	else
+		cur_angle = cur_angle%360;
+
+	if(src_width<src_height)
+		cur_angle = (cur_angle+90)%360;
+
+       output_axis_adjust(src_width,src_height,&dst_width,&dst_height,cur_angle);
+	dst_top = (output->height-dst_height)/2;
+	dst_left = (output->width-dst_width)/2;
+	dst_top = dst_top&0xfffffffe;
+	dst_left = dst_left&0xfffffffe;
+	/* data operating. */
+
+	memset(ge2d_config,0,sizeof(config_para_ex_t));
+	if((dst_left!=output->frame->x)||(dst_top!=output->frame->y)
+	  ||(dst_width!=output->frame->w)||(dst_height!=output->frame->h)){
+		ge2d_config->alu_const_color= 0;//0x000000ff;
+		ge2d_config->bitmask_en  = 0;
+		ge2d_config->src1_gb_alpha = 0;//0xff;
+		ge2d_config->dst_xy_swap = 0;
+
+		canvas_read(output_canvas&0xff,&cd);
+		ge2d_config->src_planes[0].addr = cd.addr;
+		ge2d_config->src_planes[0].w = cd.width;
+		ge2d_config->src_planes[0].h = cd.height;
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+
+		ge2d_config->src_key.key_enable = 0;
+		ge2d_config->src_key.key_mask = 0;
+		ge2d_config->src_key.key_mode = 0;
+
+		ge2d_config->src_para.canvas_index=output_canvas;
+		ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+		ge2d_config->src_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;;
+		ge2d_config->src_para.fill_color_en = 0;
+		ge2d_config->src_para.fill_mode = 0;
+		ge2d_config->src_para.x_rev = 0;
+		ge2d_config->src_para.y_rev = 0;
+		ge2d_config->src_para.color = 0;
+		ge2d_config->src_para.top = 0;
+		ge2d_config->src_para.left = 0;
+		ge2d_config->src_para.width = output->width;
+		ge2d_config->src_para.height = output->height;
+
+		ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+		ge2d_config->dst_para.canvas_index=output_canvas;
+		ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+		ge2d_config->dst_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;;
+		ge2d_config->dst_para.fill_color_en = 0;
+		ge2d_config->dst_para.fill_mode = 0;
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 0;
+		ge2d_config->dst_para.color = 0;
+		ge2d_config->dst_para.top = 0;
+		ge2d_config->dst_para.left = 0;
+		ge2d_config->dst_para.width = output->width;
+		ge2d_config->dst_para.height = output->height;
+
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -2;
+		}
+		fillrect(context, 0, 0, output->width, output->height, (ge2d_config->dst_para.format&GE2D_FORMAT_YUV)?0x008080ff:0);
+		output->frame->x = dst_left;
+		output->frame->y = dst_top;
+		output->frame->w = dst_width;
+		output->frame->h = dst_height;
+		memset(ge2d_config,0,sizeof(config_para_ex_t));
+	}
+	ge2d_config->alu_const_color= 0;//0x000000ff;
+	ge2d_config->bitmask_en  = 0;
+	ge2d_config->src1_gb_alpha = 0;//0xff;
+	ge2d_config->dst_xy_swap = 0;
+
+	canvas_read(vf->canvas0Addr&0xff,&cs0);
+	canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+	canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+	ge2d_config->src_planes[0].addr = cs0.addr;
+	ge2d_config->src_planes[0].w = cs0.width;
+	ge2d_config->src_planes[0].h = cs0.height;
+	ge2d_config->src_planes[1].addr = cs1.addr;
+	ge2d_config->src_planes[1].w = cs1.width;
+	ge2d_config->src_planes[1].h = cs1.height;
+	ge2d_config->src_planes[2].addr = cs2.addr;
+	ge2d_config->src_planes[2].w = cs2.width;
+	ge2d_config->src_planes[2].h = cs2.height;
+	canvas_read(output_canvas&0xff,&cd);
+	ge2d_config->dst_planes[0].addr = cd.addr;
+	ge2d_config->dst_planes[0].w = cd.width;
+	ge2d_config->dst_planes[0].h = cd.height;
+	ge2d_config->src_key.key_enable = 0;
+	ge2d_config->src_key.key_mask = 0;
+	ge2d_config->src_key.key_mode = 0;
+	ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+	ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->src_para.format = get_input_format(vf);
+	ge2d_config->src_para.fill_color_en = 0;
+	ge2d_config->src_para.fill_mode = 0;
+	ge2d_config->src_para.x_rev = 0;
+	ge2d_config->src_para.y_rev = 0;
+	ge2d_config->src_para.color = 0xffffffff;
+	ge2d_config->src_para.top = 0;
+	ge2d_config->src_para.left = 0;
+	ge2d_config->src_para.width = vf->width;
+	ge2d_config->src_para.height = vf->height;
+	/* printk("vf_width is %d , vf_height is %d \n",vf->width ,vf->height); */
+	ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.canvas_index = output_canvas&0xff;
+
+	if((output->v4l2_format!= V4L2_PIX_FMT_YUV420)
+		&& (output->v4l2_format != V4L2_PIX_FMT_YVU420))
+		ge2d_config->dst_para.canvas_index = output_canvas;
+
+	ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->dst_para.format = get_output_format(output->v4l2_format)|GE2D_LITTLE_ENDIAN;     
+	ge2d_config->dst_para.fill_color_en = 0;
+	ge2d_config->dst_para.fill_mode = 0;
+	ge2d_config->dst_para.x_rev = 0;
+	ge2d_config->dst_para.y_rev = 0;
+	ge2d_config->dst_para.color = 0;
+	ge2d_config->dst_para.top = 0;
+	ge2d_config->dst_para.left = 0;
+	ge2d_config->dst_para.width = output->width;
+	ge2d_config->dst_para.height = output->height;
+
+	if(current_mirror==1){
+		ge2d_config->dst_para.x_rev = 1;
+		ge2d_config->dst_para.y_rev = 0;
+	}else if(current_mirror==2){
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 1;
+	}else{
+		ge2d_config->dst_para.x_rev = 0;
+		ge2d_config->dst_para.y_rev = 0;
+	}
+
+	if(cur_angle==90){
+		ge2d_config->dst_xy_swap = 1;
+		ge2d_config->dst_para.x_rev ^= 1;
+	}else if(cur_angle==180){
+		ge2d_config->dst_para.x_rev ^= 1;
+		ge2d_config->dst_para.y_rev ^= 1;
+	}else if(cur_angle==270){
+		ge2d_config->dst_xy_swap = 1;
+		ge2d_config->dst_para.y_rev ^= 1;
+	}
+
+	if(ge2d_context_config_ex(context,ge2d_config)<0) {
+		printk("++ge2d configing error.\n");
+		return -1;
+	}
+	stretchblt_noalpha(context,src_left ,src_top ,src_width, src_height,output->frame->x,output->frame->y,output->frame->w,output->frame->h);
+
+	/* for cr of  yuv420p or yuv420sp. */
+	if((output->v4l2_format==V4L2_PIX_FMT_YUV420)
+		||(output->v4l2_format==V4L2_PIX_FMT_YVU420)){
+		/* for cb. */
+		canvas_read((output_canvas>>8)&0xff,&cd);
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+		ge2d_config->dst_para.canvas_index=(output_canvas>>8)&0xff;
+		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
+		ge2d_config->dst_para.width = output->width/2;
+		ge2d_config->dst_para.height = output->height/2;
+		ge2d_config->dst_xy_swap = 0;
+
+		if(current_mirror==1){
+			ge2d_config->dst_para.x_rev = 1;
+			ge2d_config->dst_para.y_rev = 0;
+		}else if(current_mirror==2){
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 1;
+		}else{
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 0;
+		}
+
+		if(cur_angle==90){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.x_rev ^= 1;
+		}else if(cur_angle==180){
+			ge2d_config->dst_para.x_rev ^= 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}else if(cur_angle==270){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}
+	
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -1;
+		}
+		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+			output->frame->x/2,output->frame->y/2,output->frame->w/2,output->frame->h/2);
+	} 
+	/* for cb of yuv420p or yuv420sp. */
+	if(output->v4l2_format==V4L2_PIX_FMT_YUV420||
+		output->v4l2_format==V4L2_PIX_FMT_YVU420) {
+		canvas_read((output_canvas>>16)&0xff,&cd);
+		ge2d_config->dst_planes[0].addr = cd.addr;
+		ge2d_config->dst_planes[0].w = cd.width;
+		ge2d_config->dst_planes[0].h = cd.height;
+		ge2d_config->dst_para.canvas_index=(output_canvas>>16)&0xff;
+		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CR|GE2D_LITTLE_ENDIAN;
+		ge2d_config->dst_para.width = output->width/2;
+		ge2d_config->dst_para.height = output->height/2;
+		ge2d_config->dst_xy_swap = 0;
+
+		if(current_mirror==1){
+			ge2d_config->dst_para.x_rev = 1;
+			ge2d_config->dst_para.y_rev = 0;
+		}else if(current_mirror==2){
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 1;
+		}else{
+			ge2d_config->dst_para.x_rev = 0;
+			ge2d_config->dst_para.y_rev = 0;
 		}
-	}
-	if(print_ifmt == 1){
-		printk("vf->type=%x, format=%x\n", vf->type, format);
-		print_ifmt = 0;
-	}
-	return format;
-}
 
-static unsigned int print_ofmt=0;
-module_param(print_ofmt, uint, 0644);
-MODULE_PARM_DESC(print_ofmt, "print output format\n");
+		if(cur_angle==90){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.x_rev ^= 1;
+		}else if(cur_angle==180){
+			ge2d_config->dst_para.x_rev ^= 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}else if(cur_angle==270){
+			ge2d_config->dst_xy_swap = 1;
+			ge2d_config->dst_para.y_rev ^= 1;
+		}
 
-static int get_output_format(int v4l2_format)
-{
-	int format = GE2D_FORMAT_S24_YUV444;
-	switch(v4l2_format){
-		case V4L2_PIX_FMT_RGB565X:
-			format = GE2D_FORMAT_S16_RGB_565;
-			break;
-		case V4L2_PIX_FMT_YUV444:
-			format = GE2D_FORMAT_S24_YUV444;
-			break;
-		case V4L2_PIX_FMT_VYUY:
-			format = GE2D_FORMAT_S16_YUV422;
-			break;
-		case V4L2_PIX_FMT_BGR24:
-			format = GE2D_FORMAT_S24_RGB ;
-			break;
-		case V4L2_PIX_FMT_RGB24:
-			format = GE2D_FORMAT_S24_BGR; 
-			break;
-		case V4L2_PIX_FMT_NV12:
-			format = GE2D_FORMAT_M24_NV12;
-			break;
-		case V4L2_PIX_FMT_NV21:
-			format = GE2D_FORMAT_M24_NV21;
-			break;
-		case V4L2_PIX_FMT_YUV420:
-		case V4L2_PIX_FMT_YVU420:
-			format = GE2D_FORMAT_S8_Y;
-			break;
-		default:
-			break;            
-	}   
-	if(print_ofmt == 1){
-            printk("outputformat, v4l2_format=%x, format=%x\n",
-                    v4l2_format, format);
-            print_ofmt = 0;
+		if(ge2d_context_config_ex(context,ge2d_config)<0) {
+			printk("++ge2d configing error.\n");
+			return -1;
+		}
+		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+			output->frame->x/2,output->frame->y/2,output->frame->w/2,output->frame->h/2);
 	}
-	return format;
-}
-
-static void output_axis_adjust(int src_w, int src_h, int* dst_w, int* dst_h, int angle)
-{
-    int w = 0, h = 0,disp_w = 0, disp_h =0;
-    disp_w = *dst_w;
-    disp_h = *dst_h;
-    if (angle %180 !=0) {
-        h = min((int)src_w, disp_h);
-        w = src_h * h / src_w;
-        if(w > disp_w ){
-            h = (h * disp_w)/w ;
-            w = disp_w;
-        }
-    }else{
-        if ((src_w < disp_w) && (src_h < disp_h)) {
-            w = src_w;
-            h = src_h;
-        } else if ((src_w * disp_h) > (disp_w * src_h)) {
-            w = disp_w;
-            h = disp_w * src_h / src_w;
-        } else {
-            h = disp_h;
-            w = disp_h * src_w / src_h;
-        }
-    }
-    *dst_w = w;
-    *dst_h = h;
+	return output_canvas;
 }
 
-
 int amlvideo2_ge2d_pre_process(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config, struct amlvideo2_output* output)
 {
 	int src_top ,src_left ,src_width, src_height;
@@ -924,9 +2077,22 @@ static int amlvideo2_fillbuff(struct amlvideo2_fh *fh, struct amlvideo2_node_buf
 			break;
 	}
 	src_canvas = vf->canvas0Addr;
-
-	if(ge2d_proc)
-		src_canvas = amlvideo2_ge2d_pre_process(vf,node->context,&ge2d_config,&output); 
+        if(ge2d_proc){
+                if( (vf->type &VIDTYPE_INTERLACE_BOTTOM) || (vf->type &VIDTYPE_INTERLACE_TOP)){
+                        if(vf->canvas0Addr == vf->canvas1Addr){
+                                if( (AML_PROVIDE_MIRROCAST_VDIN1 == node->p_type) || (AML_PROVIDE_MIRROCAST_VDIN0 == node->p_type) ) {
+                                        src_canvas = amlvideo2_ge2d_interlace_vdindata_process(vf,node->context,&ge2d_config,&output);
+                                }else{
+                                        src_canvas = amlvideo2_ge2d_interlace_one_canvasAddr_process(vf,node->context,&ge2d_config,&output);
+                                }
+
+                        }else{
+                                src_canvas = amlvideo2_ge2d_interlace_two_canvasAddr_process(vf,node->context,&ge2d_config,&output);
+                        }
+                }else{
+                        src_canvas = amlvideo2_ge2d_pre_process(vf,node->context,&ge2d_config,&output); 
+                }
+        }
 
 	if ((sw_proc)&&(src_canvas>0))
 		amlvideo2_sw_post_process(src_canvas ,(unsigned)vbuf);
@@ -954,16 +2120,22 @@ static void amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 
 	dprintk(node->vid_dev, 1, "Thread tick\n");
 
-
-	if(!fh->is_streamed_on){
-		dprintk(node->vid_dev, 1, "dev doesn't stream on\n");
-		return ;
-	}
-
 	if(!node->provide_ready){
 		dprintk(node->vid_dev, 1, "provide is not ready\n");
 		return ;
-	}
+        }
+        if( (AML_RECEIVER_NONE != node->r_type) && vfq_full( &q_ready) ){
+                return;
+        }
+
+	if(!fh->is_streamed_on){
+                dprintk(node->vid_dev, 1, "dev doesn't stream on\n");
+                if( vf_peek(node->recv.name)){
+                        vf = vf_get(node->recv.name);
+                        vf_inqueue(vf, node->recv.name);
+                }
+                return ;
+        }
 
 	spin_lock_irqsave(&node->slock, flags);
 	if (list_empty(&dma_q->active)){
@@ -998,7 +2170,7 @@ static void amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 		  //||(active_duration  > (int)fh->frm_save_time_us)
 			if(vf){
 				if(tmp_vf != NULL ){
-					vf_put(tmp_vf,node->recv.name);
+					vf_inqueue(tmp_vf,node->recv.name);
 				}
 				tmp_vf = NULL;
 			}else if(tmp_vf){
@@ -1010,7 +2182,7 @@ static void amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 		}else{
 			if(vf){
 				if(tmp_vf != NULL){
-					vf_put(tmp_vf,node->recv.name);
+					vf_inqueue(tmp_vf,node->recv.name);
 				}
 				tmp_vf = vf;
 			}
@@ -1033,7 +2205,7 @@ static void amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 	spin_unlock_irqrestore(&node->slock, flags);
 	amlvideo2_fillbuff(fh, buf,vf);
 
-	vf_put(vf,node->recv.name);
+	vf_inqueue(vf,node->recv.name);
 	dprintk(node->vid_dev, 1, "filled buffer %p\n", buf);
 
 	if (waitqueue_active(&buf->vb.done)){
@@ -1128,57 +2300,122 @@ static void amlvideo2_stop_thread(struct amlvideo2_node_dmaqueue  *dma_q)
 	}
 }
 
-aml_provider_type get_provider_type(const char* name)
+aml_provider_type get_provider_type(const char* name, int input)
 {
 	aml_provider_type type = AML_PROVIDE_NONE;
 	if(!name)
 		return type;
-	if(strcasecmp(name,"vdin0")){
-		type = AML_PROVIDE_VDIN0;
-	}else if(strcasecmp(name,"vdin1")){
-		type = AML_PROVIDE_VDIN1;
-	}else if(strncasecmp(name,"decode",7)){
+	if( 0 == strncasecmp(name,"vdin0", 5)){
+		if(0 == input)
+			type = AML_PROVIDE_MIRROCAST_VDIN0;
+		else
+			type = AML_PROVIDE_HDMIIN_VDIN0;
+	}else if( 0 == strncasecmp(name,"vdin1", 5)){
+		if(1 == input)
+			type = AML_PROVIDE_MIRROCAST_VDIN1;
+		else
+			type = AML_PROVIDE_HDMIIN_VDIN1;
+	}else if(0 == strncasecmp(name,"decoder",7)){
 		type = AML_PROVIDE_DECODE;
+	}else{
+		type = AML_PROVIDE_MAX;
 	}
 	return type;	
 }
 
-static int video_receiver_event_fun(int type, void* data, void* private_data)
+aml_provider_type get_sub_receiver_type(const char* name)
 {
-	struct amlvideo2_node  *node  = (struct amlvideo2_node  *)private_data;
-	struct amlvideo2_fh * fh = (struct amlvideo2_fh *)container_of(node, struct amlvideo2_fh, node);
+	aml_provider_type type = AML_RECEIVER_NONE;
+	if(!name)
+		return type;
+	if(0 == strncasecmp(name,"ppmgr",5)){
+		type = AML_RECEIVER_PPMGR;
+                printk("type is ppmgr");
+	}else{
+                type = AML_RECEIVER_MAX;
+                printk("type is not certain\n");
+        }
+	return type;	
+}
+/* ------------------------------------------------------------------
+ *           provider operations
+ *-----------------------------------------------------------------*/
+static vframe_t *amlvideo2_vf_peek(void *op_arg)
+{
+        return vfq_peek(&q_ready);
+}
 
-	switch(type) {
-		case VFRAME_EVENT_PROVIDER_VFRAME_READY:
-			node->provide_ready = 1;
-			break;
-		case VFRAME_EVENT_PROVIDER_QUREY_STATE:
-			if(fh->is_streamed_on){
-				return RECEIVER_ACTIVE ;		
-			}else{
-				return RECEIVER_INACTIVE;
-			}
-			break;   
-		case VFRAME_EVENT_PROVIDER_START:
-			break;
-		case VFRAME_EVENT_PROVIDER_UNREG: 
-			node->provide_ready = 0;
-			break;
-		case VFRAME_EVENT_PROVIDER_LIGHT_UNREG:
-			break;
-		case VFRAME_EVENT_PROVIDER_RESET:
-			break;
-		default:
-			break;
-	}    		
-	return 0;
+static vframe_t *amlvideo2_vf_get(void *op_arg)
+{
+        return vfq_pop(&q_ready);
 }
 
-static const struct vframe_receiver_op_s video_vf_receiver =
+static void amlvideo2_vf_put(vframe_t *vf, void *op_arg)
+{
+        vf_put(vf, DEVICE_NAME);
+}
+
+static int amlvideo2_event_cb(int type, void *data, void *private_data)
+{
+        if (type & VFRAME_EVENT_RECEIVER_PUT) {
+              //printk("video put, avail=%d\n", vfq_level(&q_ready) );
+        }else if (type & VFRAME_EVENT_RECEIVER_GET) {
+              //printk("video get, avail=%d\n", vfq_level(&q_ready) );
+        }else if(type & VFRAME_EVENT_RECEIVER_FRAME_WAIT){
+              // up(&thread_sem);
+              printk("receiver is waiting\n");
+        }else if(type & VFRAME_EVENT_RECEIVER_FRAME_WAIT){
+                printk("frame wait\n");
+        }
+
+        return 0;
+}
+
+static int amlvideo2_vf_states(vframe_states_t *states, void *op_arg)
+{
+        //unsigned long flags;
+        //spin_lock_irqsave(&lock, flags);
+
+        states->vf_pool_size    = AMLVIDEO2_POOL_SIZE;
+        states->buf_recycle_num = 0;
+        states->buf_free_num    =  AMLVIDEO2_POOL_SIZE - vfq_level(&q_ready);
+        states->buf_avail_num   = vfq_level(&q_ready);
+
+        //spin_unlock_irqrestore(&lock, flags);
+
+        return 0;
+}
+
+static const struct vframe_operations_s amlvideo2_vf_provider =
 {
-    .event_cb = video_receiver_event_fun
+        .peek      = amlvideo2_vf_peek,
+        .get       = amlvideo2_vf_get,
+        .put       = amlvideo2_vf_put,
+        .event_cb  = amlvideo2_event_cb,
+        .vf_states = amlvideo2_vf_states,
 };
 
+static struct vframe_provider_s amlvideo2_vf_prov;
+
+/* ------------------------------------------------------------------
+   queue operations
+   ------------------------------------------------------------------*/
+
+void vf_inqueue(struct vframe_s *vf, const char *receiver)
+{
+
+	struct vframe_receiver_s *vfp;
+
+	vfp = vf_get_receiver(DEVICE_NAME);
+        if(NULL == vfp){
+                vf_put(vf, receiver);
+                return ;
+        }
+
+        vfq_push( &q_ready, vf);
+        vf_notify_receiver(DEVICE_NAME,VFRAME_EVENT_PROVIDER_VFRAME_READY,NULL);
+}
+
 /* ------------------------------------------------------------------
 	Videobuf operations
    ------------------------------------------------------------------*/
@@ -1188,11 +2425,7 @@ buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
 	struct videobuf_res_privdata* res = (struct videobuf_res_privdata*)vq->priv_data;
 	struct amlvideo2_fh  *fh = (struct amlvideo2_fh  *)res->priv;
 	struct amlvideo2_node  *node  = fh->node;
-	//int bytes = fh->fmt->depth >> 3 ;
-	int height = fh->height;
-	if(height==1080)
-		height = 1088;
-	*size = (fh->width*height*fh->fmt->depth)>>3;  
+	*size = (fh->width * fh->height * fh->fmt->depth)>>3;	
 	if (0 == *count)
 		*count = 32;
 
@@ -1514,6 +2747,7 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 {
 	int ret;
 	struct amlvideo2_fh  *fh  = priv;
+	struct amlvideo2_node *node = fh->node;
 	vdin_parm_t para;
 	const vinfo_t *vinfo;
 
@@ -1521,39 +2755,83 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	if ((fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) || (i != fh->type))
 		return -EINVAL;
 	ret = videobuf_streamon(&fh->vb_vidq);
+	printk("%s, videobuf_streamon() ret: %d\n", __func__, ret);
+	printk("%s, node->input: %d, node->r_type: %d, node->p_type: %d\n", __func__, node->input, node->r_type, node->p_type);
 	if(ret == 0){
 		if(1){
-			memset( &para, 0, sizeof( para ));
-			para.port  = TVIN_PORT_VIU;
-			para.fmt = TVIN_SIG_FMT_MAX;
-			para.frame_rate = 60;//175
-			para.h_active = vinfo->width;//fh->width;
-			para.v_active = vinfo->height;//fh->height;
-			para.hsync_phase = 0;//0x1
-			para.vsync_phase  = 1;//0x1
-			para.hs_bp = 0;
-			para.vs_bp = 0;
-			para.dfmt = TVIN_NV21;//TVIN_YUV422;
-			para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-			int dst_w = fh->width, dst_h = fh->height;
-			if(vinfo->width<vinfo->height){
-				dst_w = fh->height;
-				dst_h = fh->width;
-				output_axis_adjust(vinfo->height,vinfo->width, (int *)&dst_h,(int *)&dst_w,0);
-			}else{
-				output_axis_adjust(vinfo->width,vinfo->height, (int *)&dst_w,(int *)&dst_h,0);	
-			}
-			para.dest_hactive = dst_w;
-			para.dest_vactive = dst_h;
-			printk("amlvideo2--vidioc_streamon: para.h_active: %d, para.v_active: %d, para.dest_hactive: %d, para.dest_vactive: %d, fh->width: %d, fh->height: %d \n",para.h_active,para.v_active, para.dest_hactive, para.dest_vactive,fh->width,fh->height);
+
 			//start_tvin_service((fh->node->vid== 0)?0:1,&para);
 			//start_tvin_service(1,&para);
-			vops.start_tvin_service(1,&para);
+			if(node->input == 0) {			//	0:mirrocast
+				if(AML_RECEIVER_NONE == node->r_type){
+                	if( AML_PROVIDE_MIRROCAST_VDIN0 == node->p_type){
+
+			                 memset( &para, 0, sizeof( para ));
+											 para.port  = TVIN_PORT_VIU;
+											 para.fmt = TVIN_SIG_FMT_MAX;
+											 para.frame_rate = 60;//175
+	                     if(AML_RECEIVER_NONE == node->r_type){
+	                               para.h_active = vinfo->width;//fh->width;
+	                               para.v_active = vinfo->height;//fh->height;
+	                     }
+											 para.hsync_phase = 0;//0x1
+											 para.vsync_phase  = 1;//0x1
+											 para.hs_bp = 0;
+											 para.vs_bp = 0;
+											 para.dfmt = TVIN_NV21;//TVIN_YUV422;
+											 para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
+											 int dst_w = fh->width, dst_h = fh->height;
+											 if(vinfo->width<vinfo->height){
+												 dst_w = fh->height;
+												 dst_h = fh->width;
+												 output_axis_adjust(vinfo->height,vinfo->width, (int *)&dst_h,(int *)&dst_w,0);
+											 }else{
+												 output_axis_adjust(vinfo->width,vinfo->height, (int *)&dst_w,(int *)&dst_h,0);	
+											 }
+											 para.dest_hactive = dst_w;
+											 para.dest_vactive = dst_h;
+											 printk("amlvideo2--vidioc_streamon: para.h_active: %d, para.v_active: %d"
+	                     								          "para.dest_hactive: %d, para.dest_vactive: %d, fh->width: %d, fh->height: %d \n",
+	                              								 para.h_active,para.v_active, para.dest_hactive, para.dest_vactive,fh->width,fh->height);
+	
+                      	vops.start_tvin_service(0,&para);
+                    }else if( AML_PROVIDE_MIRROCAST_VDIN1 == node->p_type){
+			                 memset( &para, 0, sizeof( para ));
+											 para.port  = TVIN_PORT_VIU;
+											 para.fmt = TVIN_SIG_FMT_MAX;
+											 para.frame_rate = 60;//175
+	                     if(AML_RECEIVER_NONE == node->r_type){
+	                               para.h_active = vinfo->width;//fh->width;
+	                               para.v_active = vinfo->height;//fh->height;
+	                     }
+											 para.hsync_phase = 0;//0x1
+											 para.vsync_phase  = 1;//0x1
+											 para.hs_bp = 0;
+											 para.vs_bp = 0;
+											 para.dfmt = TVIN_NV21;//TVIN_YUV422;
+											 para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
+											 int dst_w = fh->width, dst_h = fh->height;
+											 if(vinfo->width<vinfo->height){
+												 dst_w = fh->height;
+												 dst_h = fh->width;
+												 output_axis_adjust(vinfo->height,vinfo->width, (int *)&dst_h,(int *)&dst_w,0);
+											 }else{
+												 output_axis_adjust(vinfo->width,vinfo->height, (int *)&dst_w,(int *)&dst_h,0);	
+											 }
+											 para.dest_hactive = dst_w;
+											 para.dest_vactive = dst_h;
+											 printk("amlvideo2--vidioc_streamon: para.h_active: %d, para.v_active: %d"
+	                     								          "para.dest_hactive: %d, para.dest_vactive: %d, fh->width: %d, fh->height: %d \n",
+	                              								 para.h_active,para.v_active, para.dest_hactive, para.dest_vactive,fh->width,fh->height);
+                        vops.start_tvin_service(1,&para);
+                    }
+                }
+			}
 		}
 #if 0
-		if((fh->node->p_type == AML_PROVIDE_VDIN0)||(fh->node->p_type == AML_PROVIDE_VDIN1)){
+		if((fh->node->p_type == AML_PROVIDE_MIRROCAST_VDIN0)||(fh->node->p_type == AML_PROVIDE_MIRROCAST_VDIN1)){
 			memset( &para, 0, sizeof( para ));
-        		//para.port  = (fh->node->p_type == AML_PROVIDE_VDIN0)?TVIN_PORT_CAMERA:TVIN_PORT_VIU;
+        		//para.port  = (fh->node->p_type == AML_PROVIDE_MIRROCAST_VDIN0)?TVIN_PORT_CAMERA:TVIN_PORT_VIU;
         		para.port  = TVIN_PORT_VIU;
         		para.fmt = TVIN_SIG_FMT_MAX;
 			para.frame_rate = 60;//175
@@ -1588,14 +2866,21 @@ static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
 {
 	int ret;
 	struct amlvideo2_fh  *fh  = priv;
+	struct amlvideo2_node *node = fh->node;
 
 	if ((fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) || (i != fh->type))
 		return -EINVAL;
 	ret = videobuf_streamoff(&fh->vb_vidq);
 	if(ret == 0){
-		//stop_tvin_service((fh->node->vid== 0)?0:1);
-		//stop_tvin_service(1);
-		vops.stop_tvin_service(1);
+		if(0 == node->input){
+            if(AML_RECEIVER_NONE == node->r_type){
+                if( AML_PROVIDE_MIRROCAST_VDIN0 == node->p_type){
+                    vops.stop_tvin_service(0);
+                }else if( AML_PROVIDE_MIRROCAST_VDIN1 == node->p_type){
+                    vops.stop_tvin_service(1);
+                }
+            }
+        }
 		fh->is_streamed_on = 0;
 	}
 	return ret;
@@ -1696,6 +2981,26 @@ static int vidioc_queryctrl(struct file *file, void *priv,
 	return -EINVAL;
 }
 
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+    struct amlvideo2_fh *fh = priv;
+    struct amlvideo2_node *node = fh->node;
+
+    *i = node->input;
+    return (0);
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+    struct amlvideo2_fh *fh = priv;
+    struct amlvideo2_node *node = fh->node;
+
+    node->input = i;
+    printk("current input:%d\n", node->input);
+    return (0);
+}
+
 static int vidioc_g_ctrl(struct file *file, void *priv,
 			 struct v4l2_control *ctrl)
 {
@@ -1754,7 +3059,7 @@ static int amlvideo2_open(struct file *file)
 		mutex_unlock(&node->mutex);
 		return -ENODEV;
 	}
-	node->p_type = get_provider_type(node->provider->name);
+	node->p_type = get_provider_type(node->provider->name, node->input);
 	if((node->p_type == AML_PROVIDE_NONE)||(node->p_type>=AML_PROVIDE_MAX)){
 		node->users--;
 		node->provider = NULL;
@@ -1763,7 +3068,7 @@ static int amlvideo2_open(struct file *file)
 	}
 #endif
 
-	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+	fh = node->fh;
 	if (NULL == fh) {
 		node->users--;
 		//node->provider  = NULL;
@@ -1771,9 +3076,35 @@ static int amlvideo2_open(struct file *file)
 		return -ENOMEM;
 	}
 	mutex_unlock(&node->mutex);
+	node->input = 0;    //default input is miracast
+        node->sub_recv = vf_get_receiver(DEVICE_NAME);
+        if(node->sub_recv){
+                printk("node->sub_recv->name=%s\n", node->sub_recv->name);
+                node->provider = vf_get_provider(DEVICE_NAME);
+                if(NULL == node->provider){
+                        printk("node->provider=%p", node->provider);
+                        node->p_type = AML_PROVIDE_MAX;
+                }else{
+                        printk("node->provider=%p", node->provider);
+                        node->p_type =  get_provider_type(node->provider->name, node->input);
+                }
+                printk("node->r_type=%d\n", node->r_type);
+                node->r_type = get_sub_receiver_type(node->sub_recv->name);
+        }else{
+                printk("as an end receiver\n");
+                node->p_type = AML_PROVIDE_MIRROCAST_VDIN1;
+                node->provider = vf_get_provider(DEVICE_NAME);
+                if (NULL == node->provider) {
+                    node->p_type = AML_PROVIDE_MIRROCAST_VDIN1;
+                } else {
+                    printk("node->provider = %p\n", node->provider);
+                    node->p_type = get_provider_type(node->provider->name, node->input);
+                }
+                node->r_type = AML_RECEIVER_NONE;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif
+        }
 
 	file->private_data = fh;
 	fh->node      = node;
@@ -1790,9 +3121,12 @@ static int amlvideo2_open(struct file *file)
 					NULL, &node->slock, fh->type, V4L2_FIELD_INTERLACED,
 					sizeof(struct amlvideo2_node_buffer), (void*)res, NULL);
 
+    if( AML_RECEIVER_NONE == node->r_type){
+    	amlvideo2_start_thread(fh);
+    }
 	v4l2_vdin_ops_init(&vops);
 	fh->frm_save_time_us = 1000000/DEF_FRAMERATE;
-	amlvideo2_start_thread(fh);
+
 	return 0;
 }
 
@@ -1827,17 +3161,21 @@ static int amlvideo2_close(struct file *file)
 {
 	struct amlvideo2_fh *fh = file->private_data;
 	struct amlvideo2_node *node       = fh->node;
-	amlvideo2_stop_thread(&node->vidq);
+    if(AML_RECEIVER_NONE == node->r_type){
+		amlvideo2_stop_thread(&node->vidq);
+    }
 	videobuf_stop(&fh->vb_vidq);
 	videobuf_mmap_free(&fh->vb_vidq);
-	kfree(fh);
+
 	mutex_lock(&node->mutex);
+    if(AML_RECEIVER_NONE == node->r_type){
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 0);
 #endif	
+	}
 	node->users--;
 	amlvideo2_frmintervals_active.numerator = 1;
-	amlvideo2_frmintervals_active.denominator = DEF_FRAMERATE;
+	amlvideo2_frmintervals_active.denominator = 30;
 	//node->provider = NULL;
 	mutex_unlock(&node->mutex);
 	return 0;
@@ -1892,6 +3230,8 @@ static const struct v4l2_ioctl_ops amlvideo2_ioctl_ops = {
 	.vidioc_streamoff     = vidioc_streamoff,
 	.vidioc_enum_framesizes = vidioc_enum_framesizes,
     .vidioc_enum_frameintervals =vidioc_enum_frameintervals,
+    .vidioc_s_input       = vidioc_s_input,
+    .vidioc_g_input       = vidioc_g_input,
 #ifdef CONFIG_VIDEO_V4L1_COMPAT
 	.vidiocgmbuf          = vidiocgmbuf,
 #endif
@@ -1907,6 +3247,83 @@ static struct video_device amlvideo2_template = {
 	.current_norm         = V4L2_STD_NTSC_M,
 };
 
+static int amlvideo2_receiver_event_fun(int type, void* data, void* private_data)
+{
+	struct amlvideo2_node  *node  = (struct amlvideo2_node  *)private_data;
+	struct amlvideo2_fh *fh = node->fh;//(struct amlvideo2_fh *)container_of(node, struct amlvideo2_fh, node);
+
+	switch(type) {
+		case VFRAME_EVENT_PROVIDER_VFRAME_READY:
+			node->provide_ready = 1;
+			break;
+		case VFRAME_EVENT_PROVIDER_QUREY_STATE:
+                        if(vfq_level(&q_ready)){
+				return RECEIVER_ACTIVE ;		
+                        }else{
+				return RECEIVER_INACTIVE;
+                        }
+			break;   
+		case VFRAME_EVENT_PROVIDER_START:
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+                        switch_mod_gate_by_name("ge2d", 1);
+#endif
+                        node->sub_recv = vf_get_receiver(DEVICE_NAME);
+                        printk("sub recv=%p\n", node->sub_recv);
+                        if(node->sub_recv){
+                                printk("node->provider->name=%s\n", node->sub_recv->name);
+                                node->r_type = get_sub_receiver_type(node->sub_recv->name);
+                                printk("r_type=%d\n", node->r_type);
+
+                                node->provider = vf_get_provider(DEVICE_NAME);
+                                printk("provider=%p\n", node->provider);
+                                if(node->provider){
+                                        printk("provider=%s\n", node->provider->name);
+                                        node->p_type =  get_provider_type(node->provider->name, node->input);
+                                }
+
+                                fh->node     = node;
+
+                                vf_reg_provider(&amlvideo2_vf_prov);
+                                vf_notify_receiver(DEVICE_NAME,VFRAME_EVENT_PROVIDER_START,NULL);
+                                vfq_init(&q_ready, AMLVIDEO2_POOL_SIZE+1, &amlvideo2_pool_ready[0]);
+
+                                printk("start thread\n");
+
+                                printk("test, test node=%p, fh=%p\n", node, fh);
+                                amlvideo2_start_thread(fh);
+                        }
+
+			break;
+		case VFRAME_EVENT_PROVIDER_UNREG: 
+			node->provide_ready = 0;
+                        printk("r_type=%d,p_type=%d\n", node->r_type, node->p_type);
+                        if( AML_RECEIVER_NONE != node->r_type){
+                                amlvideo2_stop_thread(&node->vidq);
+                                printk("%s,%dstop thread\n", __func__, __LINE__);
+                        }
+
+                        printk("unreg amlvideo2\n");
+                        vf_unreg_provider(&amlvideo2_vf_prov);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+                        switch_mod_gate_by_name("ge2d", 0);
+#endif
+			break;
+		case VFRAME_EVENT_PROVIDER_LIGHT_UNREG:
+                        printk("provider light unreg\n");
+			break;
+		case VFRAME_EVENT_PROVIDER_RESET:
+                        printk("provider reset\n");
+			break;
+		default:
+			break;
+	}
+	return 0;
+}
+
+static const struct vframe_receiver_op_s video_vf_receiver =
+{
+    .event_cb = amlvideo2_receiver_event_fun
+};
 /* -----------------------------------------------------------------
 	Initialization and module stuff
    ------------------------------------------------------------------*/
@@ -1923,6 +3340,8 @@ static int amlvideo2_release_node(struct amlvideo2_device *vid_dev)
 			vf_unreg_receiver(&vid_dev->node[i]->recv);
 			if(vid_dev->node[i]->context)
 				destroy_ge2d_work_queue(vid_dev->node[i]->context);
+            kfree(vid_dev->node[i]->fh);
+			vid_dev->node[i]->fh = NULL;
 			kfree(vid_dev->node[i]);
 			vid_dev->node[i] = NULL;
 		}
@@ -1937,6 +3356,7 @@ static int amlvideo2_create_node(struct platform_device *pdev)
 	int ret = 0, i = 0, j = 0;
 	struct video_device *vfd = NULL;
 	struct amlvideo2_node* vid_node = NULL;
+    struct amlvideo2_fh *fh = NULL;
 	struct resource *res = NULL;
 	struct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);
 	struct amlvideo2_device *vid_dev = container_of(v4l2_dev,
@@ -2003,7 +3423,13 @@ static int amlvideo2_create_node(struct platform_device *pdev)
 			break;
 		}
 
-		video_set_drvdata(vfd, vid_node);
+                fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+                if ( !fh ) {
+                        break;
+                }
+
+                vid_node->fh = fh;
+                video_set_drvdata(vfd, vid_node);
 
 		/* Set all controls to their default value. */
 		for (j = 0; j < ARRAY_SIZE(amlvideo2_node_qctrl); j++)
@@ -2020,6 +3446,7 @@ static int amlvideo2_create_node(struct platform_device *pdev)
 		vf_receiver_init(&vid_node->recv, RECEIVER_NAME, &video_vf_receiver, (void*)vid_node);
 #endif
        	vf_reg_receiver(&vid_node->recv);
+        vf_provider_init(&amlvideo2_vf_prov, DEVICE_NAME ,&amlvideo2_vf_provider, NULL);
 		vid_dev->node[i] = vid_node;
 		v4l2_info(&vid_dev->v4l2_dev, "V4L2 device registered as %s\n",
 		  	video_device_node_name(vfd));
@@ -2032,7 +3459,7 @@ static int amlvideo2_create_node(struct platform_device *pdev)
 	return ret;
 }
 
-static int amlvideo2_driver_probe(struct platform_device *pdev)
+static int __init amlvideo2_driver_probe(struct platform_device *pdev)
 {
 	int ret = 0;
 	struct amlvideo2_device *dev = NULL;
diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index 050bf74d85cc..19b9bcb9a047 100755
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -304,6 +304,30 @@ static void i2sin_fifo0_set_buf(u32 addr, u32 size,u32 i2s_mode,u32 i2s_sync)
 				  );
 
 }
+
+static void spdifin_reg_set(void)
+{
+	struct clk* clk_src = clk_get_sys("clk81", NULL);  // get clk81 clk_rate
+	u32 clk_rate = clk_get_rate(clk_src);
+	u32 spdif_clk_time = 54;   // 54us
+	u32 spdif_mode_14bit = ((clk_rate /500000 +1 )>>1)* spdif_clk_time; // the reg spdif_mode(0x2800)last 14 bit
+	
+	printk(KERN_INFO"spdifin_reg_set: clk_rate=%d\n", clk_rate);
+	u32 period_data = (clk_rate/64000 + 1 ) >> 1 ;   // sysclk/32(bit)/2(ch)/2(bmc)
+	
+	u32 period_32k = (period_data + (1<<4)) >> 5;     // 32k min period
+	u32 period_44k = (period_data / 22 + 1) >> 1;   // 44k min period
+	u32 period_48k = (period_data / 24 + 1) >> 1;   // 48k min period
+	u32 period_96k = (period_data / 48 + 1) >> 1;   // 96k min period
+	u32 period_192k = (period_data / 96 + 1) >> 1;  // 192k min period
+	
+		
+	WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)&0x7fffc000|(spdif_mode_14bit<<0));
+	WRITE_MPEG_REG(AUDIN_SPDIF_FS_CLK_RLTN, (period_32k<<0)|(period_44k<<6)|(period_48k<<12) 
+											|(period_96k<<18)|(period_192k<<24));  //Spdif_fs_clk_rltn
+	
+}
+
 static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 {
 	WRITE_MPEG_REG(AUDIN_SPDIF_MODE, READ_MPEG_REG(AUDIN_SPDIF_MODE)&0x7fffffff);
@@ -324,6 +348,10 @@ static void spdifin_fifo1_set_buf(u32 addr, u32 size)
 			                                	//|(1<<19)	//hold 0 enable
 								|(0<<AUDIN_FIFO1_UG)	// hold0 to aififo
 				  );
+
+	// according clk81 to set reg spdif_mode(0x2800) the last 14 bit and reg Spdif_fs_clk_rltn(0x2801)
+	spdifin_reg_set();
+
 	WRITE_MPEG_REG(AUDIN_FIFO1_CTRL1,0xc);
 }
 void audio_in_i2s_set_buf(u32 addr, u32 size,u32 i2s_mode, u32 i2s_sync)
-- 
2.19.0

