From 40fc17c87b990d8a34b5eda242418e1613522412 Mon Sep 17 00:00:00 2001
From: "tao.zeng" <tao.zeng@amlogic.com>
Date: Tue, 25 Mar 2014 13:43:00 +0800
Subject: [PATCH 3809/5965] PD #81802: update new thermal parameters for M8
 project

---
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |   9 +-
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |   9 +-
 arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd  |   9 +-
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |   9 +-
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |   9 +-
 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd  |   9 +-
 arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd  |   9 +-
 .../boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd |   9 +-
 arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd |   9 +-
 arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd |   9 +-
 .../boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd |   9 +-
 arch/arm/boot/dts/amlogic/meson8_skt.dtd      |   9 +-
 drivers/amlogic/thermal/Kconfig               |   2 +
 drivers/amlogic/thermal/amlogic_thermal.c     |  93 ++++++-
 drivers/cpufreq/cpufreq_hotplug.c             |  23 +-
 drivers/thermal/Kconfig                       |  19 ++
 drivers/thermal/Makefile                      |   8 +-
 drivers/thermal/cpucore_cooling.c             | 224 +++++++++++++++++
 drivers/thermal/gpucore_cooling.c             | 228 ++++++++++++++++++
 include/linux/cpucore_cooling.h               |  65 +++++
 include/linux/cpufreq.h                       |  38 +++
 include/linux/gpucore_cooling.h               |  70 ++++++
 22 files changed, 816 insertions(+), 62 deletions(-)
 create mode 100755 drivers/thermal/cpucore_cooling.c
 create mode 100755 drivers/thermal/gpucore_cooling.c
 create mode 100755 include/linux/cpucore_cooling.h
 create mode 100755 include/linux/gpucore_cooling.h

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index 4820846b733e..17fb28d98c87 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -1776,11 +1776,12 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index 8bdedb9d20dd..4818a0cd9589 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -1808,11 +1808,12 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
index c8f44b343e2c..1e96de733623 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
@@ -1735,11 +1735,12 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index b0cf0182c578..7edbdfed761f 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -1687,11 +1687,12 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<30 1200000 1200000 500 500
-			    70  800000 800000 400 400
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index 96c99ebcf427..ae14645dba61 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -1713,11 +1713,12 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
index a541cf213815..bb551a5f4fbb 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
@@ -1755,11 +1755,12 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
index 6be816fea5c6..02aae50c37d1 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200_1G.dtd
@@ -963,11 +963,12 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd
index 6d32a1f51b97..ad40fcde40d0 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd
@@ -850,11 +850,12 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
index 2b414eefcd7f..49195fb47378 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_1G.dtd
@@ -868,11 +868,12 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
index 1b24d74a1c80..735aec426c92 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G.dtd
@@ -858,11 +858,12 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd
index c7086b9f7b09..bdc1f4a1bd4a 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd
@@ -848,11 +848,12 @@ sdio{
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/arch/arm/boot/dts/amlogic/meson8_skt.dtd b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
index 4a6732876771..48c31b86fe58 100755
--- a/arch/arm/boot/dts/amlogic/meson8_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
@@ -1198,11 +1198,12 @@ void root_func(){
 //$$ L2 PROP_U32 = "idle_interval"
 	thermal{
 		compatible = "amlogic-thermal";
-		#thermal-cells=<5>;
+		#thermal-cells=<7>;
 		dev_name = "aml_thermal";
-		trip_point=<40 1200000 1200000 500 500
-			    70  800000 800000 400 400 
-			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
+		trip_point=<60 1608001 1608001 511 511 2 3
+			    70 1200001 1200001 435 435 2 3
+			    80  800001 800001  328 328 1 1
+			    110 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff 0xffffffff>;
 		cpu_cali_a=<0>;
 		idle_interval=<1000>;
 
diff --git a/drivers/amlogic/thermal/Kconfig b/drivers/amlogic/thermal/Kconfig
index 56ae499d2e8d..dd51de659879 100644
--- a/drivers/amlogic/thermal/Kconfig
+++ b/drivers/amlogic/thermal/Kconfig
@@ -6,6 +6,8 @@ config AMLOGIC_THERMAL
     select THERMAL
     select CPU_THERMAL
     select GPU_THERMAL
+    select CPUCORE_THERMAL
+    select GPUCORE_THERMAL
     default n
     help
       This is the Amlogic Thermal interface driver
diff --git a/drivers/amlogic/thermal/amlogic_thermal.c b/drivers/amlogic/thermal/amlogic_thermal.c
index 24677e0659a1..f5d8f4bfe2a2 100755
--- a/drivers/amlogic/thermal/amlogic_thermal.c
+++ b/drivers/amlogic/thermal/amlogic_thermal.c
@@ -41,6 +41,9 @@
 #include <plat/cpu.h>
 #include <linux/random.h>
 #include <linux/gpu_cooling.h>
+#include <linux/cpucore_cooling.h>
+#include <linux/gpucore_cooling.h>
+
 struct freq_trip_table {
 	unsigned int freq_state;
 };
@@ -53,7 +56,11 @@ struct temp_trip{
 	unsigned int gpu_upper_freq;
 	unsigned int gpu_lower_freq;
 	int gpu_upper_level;
-	int gpu_lower_level;	
+	int gpu_lower_level;
+	int cpu_core_num;
+	int cpu_core_upper;
+	int gpu_core_num;
+	int gpu_core_upper;
 };
 
 struct amlogic_thermal_platform_data {
@@ -65,6 +72,7 @@ struct amlogic_thermal_platform_data {
 	struct thermal_zone_device *therm_dev;
 	struct thermal_cooling_device *cpu_cool_dev;
 	struct thermal_cooling_device *gpu_cool_dev;
+	struct thermal_cooling_device *cpucore_cool_dev;
 	enum thermal_device_mode mode;
 	struct mutex lock;
 };
@@ -74,6 +82,8 @@ struct temp_level{
 	int cpu_low_freq;
 	int gpu_high_freq;
 	int gpu_low_freq;
+	int cpu_core_num;
+	int gpu_core_num;
 };
 
 /* CPU Zone information */
@@ -129,17 +139,12 @@ static int amlogic_set_mode(struct thermal_zone_device *thermal,
 static int amlogic_get_trip_type(struct thermal_zone_device *thermal, int trip,
 				 enum thermal_trip_type *type)
 {
-	switch (GET_ZONE(trip)) {
-	case MONITOR_ZONE:
-	case WARN_ZONE:
+	if(trip < thermal->trips-1)
 		*type = THERMAL_TRIP_ACTIVE;
-		break;
-	case PANIC_ZONE:
+	else if(trip == thermal->trips-1)
 		*type = THERMAL_TRIP_CRITICAL;
-		break;
-	default:
+	else 
 		return -EINVAL;
-	}
 	return 0;
 }
 
@@ -179,7 +184,7 @@ static int amlogic_get_crit_temp(struct thermal_zone_device *thermal,
 {
 	int ret;
 	/* Panic zone */
-	ret =amlogic_get_trip_temp(thermal, GET_TRIP(PANIC_ZONE), temp);
+	ret =amlogic_get_trip_temp(thermal, thermal->trips-1, temp);
 	
 	return ret;
 }
@@ -245,7 +250,61 @@ static int amlogic_bind(struct thermal_zone_device *thermal,
 		}
 		pr_info("%s bind %s okay !\n",thermal->type,cdev->type);
 	}
-	
+
+	if(!strcmp(type,"cpucore")){
+		/* Bind the thermal zone to the cpufreq cooling device */
+		struct cpucore_cooling_device *cpucore_dev=
+			(struct cpucore_cooling_device *)cdev->devdata;
+		for (i = 0; i < pdata->temp_trip_count; i++) {
+			if(pdata->tmp_trip[0].cpu_core_num==THERMAL_CSTATE_INVALID)
+			{
+				printk("disable cpu cooling device by dtd\n");
+				ret = -EINVAL;
+				goto out;
+			}
+			if(pdata->tmp_trip[i].cpu_core_num !=-1)
+				pdata->tmp_trip[i].cpu_core_upper=cpucore_dev->max_cpu_core_num-pdata->tmp_trip[i].cpu_core_num;
+			else
+				pdata->tmp_trip[i].cpu_core_upper=pdata->tmp_trip[i].cpu_core_num;
+			printk("tmp_trip[%d].cpu_core_upper=%d\n",i,pdata->tmp_trip[i].cpu_core_upper);
+			if (thermal_zone_bind_cooling_device(thermal, i, cdev,
+								pdata->tmp_trip[i].cpu_core_upper,
+								pdata->tmp_trip[i].cpu_core_upper)) {
+				pr_err("error binding cdev inst %d\n", i);
+				ret = -EINVAL;
+				goto out;
+			}
+		}
+		pr_info("%s bind %s okay !\n",thermal->type,cdev->type);
+	}
+
+	if(!strcmp(type,"gpucore")){
+		/* Bind the thermal zone to the cpufreq cooling device */
+		struct gpucore_cooling_device *gpucore_dev=
+			(struct gpucore_cooling_device *)cdev->devdata;
+		for (i = 0; i < pdata->temp_trip_count; i++) {
+			if(pdata->tmp_trip[0].cpu_core_num==THERMAL_CSTATE_INVALID)
+			{
+				printk("disable cpu cooling device by dtd\n");
+				ret = -EINVAL;
+				goto out;
+			}
+			if(pdata->tmp_trip[i].gpu_core_num != -1)
+				pdata->tmp_trip[i].gpu_core_upper=gpucore_dev->max_gpu_core_num-pdata->tmp_trip[i].gpu_core_num;
+			else
+				pdata->tmp_trip[i].gpu_core_upper=pdata->tmp_trip[i].gpu_core_num;
+			
+			printk("tmp_trip[%d].gpu_core_upper=%d\n",i,pdata->tmp_trip[i].gpu_core_upper);
+			if (thermal_zone_bind_cooling_device(thermal, i, cdev,
+								pdata->tmp_trip[i].gpu_core_upper,
+								pdata->tmp_trip[i].gpu_core_upper)) {
+				pr_err("error binding cdev inst %d\n", i);
+				ret = -EINVAL;
+				goto out;
+			}
+		}
+		pr_info("%s bind %s okay !\n",thermal->type,cdev->type);
+	}
 	return ret;
 out:
 	return ret;
@@ -333,7 +392,12 @@ static int amlogic_register_thermal(struct amlogic_thermal_platform_data *pdata)
 		ret = -EINVAL;
 		goto err_unregister;
 	}
-	//pdata->gpu_cool_dev=gpufreq_cooling_register();
+	pdata->cpucore_cool_dev = cpucore_cooling_register();
+	if (IS_ERR(pdata->cpucore_cool_dev)) {
+		pr_err("Failed to register cpufreq cooling device\n");
+		ret = -EINVAL;
+		goto err_unregister;
+	}
 
 	pdata->therm_dev = thermal_zone_device_register(pdata->name,
 			pdata->temp_trip_count, 7, pdata, &amlogic_dev_ops, NULL, 0,
@@ -493,6 +557,11 @@ static struct amlogic_thermal_platform_data * amlogic_thermal_init_from_dts(stru
 			pdata->tmp_trip[i].gpu_lower_freq=tmp_level[i].gpu_low_freq;
 			pdata->tmp_trip[i].gpu_upper_freq=tmp_level[i].gpu_high_freq;
 			printk("gpu[%d].gpu_high_freq=%d,tmp_level[%d].gpu_high_freq=%d\n",i,tmp_level[i].gpu_high_freq,i,tmp_level[i].gpu_low_freq);
+
+			pdata->tmp_trip[i].cpu_core_num=tmp_level[i].cpu_core_num;
+			printk("cpu[%d] core num==%d\n",i,pdata->tmp_trip[i].cpu_core_num);
+			pdata->tmp_trip[i].gpu_core_num=tmp_level[i].gpu_core_num;
+			printk("gpu[%d] core num==%d\n",i,pdata->tmp_trip[i].gpu_core_num);
 		}
 		
 		ret= of_property_read_u32(pdev->dev.of_node, "idle_interval", &val);
diff --git a/drivers/cpufreq/cpufreq_hotplug.c b/drivers/cpufreq/cpufreq_hotplug.c
index c747f928afd3..9ad85e42abd8 100755
--- a/drivers/cpufreq/cpufreq_hotplug.c
+++ b/drivers/cpufreq/cpufreq_hotplug.c
@@ -36,6 +36,8 @@
 #include <linux/sched/rt.h>
 #include <linux/notifier.h>
 #include "cpufreq_governor.h"
+unsigned int max_cpu_num=NR_CPUS;
+unsigned int last_max_cpu_num=NR_CPUS;
 
 /* greater than 80% avg load across online CPUs increases frequency */
 #define DEFAULT_UP_FREQ_MIN_LOAD			(80)
@@ -539,6 +541,24 @@ wait_next_event:
 	}
 	return 1;
 }
+void cpufreq_set_max_cpu_num(unsigned int cpu_num)
+{
+	if(cpu_num>=NR_CPUS){
+		max_cpu_num=NR_CPUS;
+	}else{
+		if(cpu_num>last_max_cpu_num)
+			max_cpu_num=cpu_num;
+		else{
+			max_cpu_num=cpu_num;
+			if(cpu_num>=num_online_cpus())
+				return ;
+			cpu_hotplug_flag = CPU_HOTPLUG_UNPLUG;
+			wake_up_process(cpu_hotplug_task);
+		}
+	}
+	last_max_cpu_num=max_cpu_num;
+	return ;
+}
 static int __ref cpu_hotplug_thread(void *data)
 {
 	int i, j,target_cpu = 1;
@@ -570,7 +590,7 @@ static int __ref cpu_hotplug_thread(void *data)
 		if(*hotplug_flag == CPU_HOTPLUG_PLUG){
 			*hotplug_flag = CPU_HOTPLUG_NONE;
 			j = 0;
-			for(i = 0; i < NR_CPUS; i++){
+			for(i = 0; i < max_cpu_num; i++){
 				if(cpu_online(i))
 					continue;
 				j++;
@@ -610,6 +630,7 @@ wait_next_hotplug:
 	}
 	return 1;
 }
+
 static void hg_check_cpu(int cpu, unsigned int max_load)
 {
 	/* largest CPU load in terms of frequency */
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index e6f8727db2a7..45aa509a985f 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -79,6 +79,15 @@ config CPU_THERMAL
 
 	  If you want this support, you should say Y here.
 
+config CPUCORE_THERMAL
+	bool "generic cpu core cooling support"
+	help
+	  This implements the generic cpu cooling mechanism through reduce cpu core numbers.
+	  This will be useful for platforms using the generic thermal interface
+	  and not the ACPI interface.
+
+	  If you want this support, you should say Y here.
+
 config GPU_THERMAL
 	bool "generic gpu cooling support"
 	depends on (MALI400 || MALI400_MODULE)
@@ -91,6 +100,16 @@ config GPU_THERMAL
 
 	  If you want this support, you should say Y here.
 
+config GPUCORE_THERMAL
+	bool "generic gpu core cooling support"
+	depends on (MALI400 || MALI400_MODULE)
+	help
+	  This implements the generic cpu cooling mechanism through reduce cpu core numbers.
+	  This will be useful for platforms using the generic thermal interface
+	  and not the ACPI interface.
+
+	  If you want this support, you should say Y here.
+
 config THERMAL_EMULATION
 	bool "Thermal emulation mode support"
 	help
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index 019f0971776a..48ec47fb2d37 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -13,9 +13,15 @@ thermal_sys-$(CONFIG_THERMAL_GOV_USER_SPACE)	+= user_space.o
 # cpufreq cooling
 thermal_sys-$(CONFIG_CPU_THERMAL)	+= cpu_cooling.o
 
-# cpufreq cooling
+# cpu core num cooling
+thermal_sys-$(CONFIG_CPUCORE_THERMAL)	+= cpucore_cooling.o
+
+# gpufreq cooling
 thermal_sys-$(CONFIG_GPU_THERMAL)	+= gpu_cooling.o
 
+# gpu core num cooling
+thermal_sys-$(CONFIG_GPUCORE_THERMAL)	+= gpucore_cooling.o
+
 # platform thermal drivers
 obj-$(CONFIG_SPEAR_THERMAL)	+= spear_thermal.o
 obj-$(CONFIG_RCAR_THERMAL)	+= rcar_thermal.o
diff --git a/drivers/thermal/cpucore_cooling.c b/drivers/thermal/cpucore_cooling.c
new file mode 100755
index 000000000000..c0fab873069a
--- /dev/null
+++ b/drivers/thermal/cpucore_cooling.c
@@ -0,0 +1,224 @@
+/*
+ *  linux/drivers/thermal/cpu_cooling.c
+ *
+ *  Copyright (C) 2012	Samsung Electronics Co., Ltd(http://www.samsung.com)
+ *  Copyright (C) 2012  Amit Daniel <amit.kachhap@linaro.org>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#include <linux/module.h>
+#include <linux/thermal.h>
+#include <linux/cpufreq.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/cpu.h>
+#include <linux/cpucore_cooling.h>
+
+/**
+ * struct cpucore_cooling_device - data for cooling device with cpucore
+ * @id: unique integer value corresponding to each cpucore_cooling_device
+ *	registered.
+ * @cool_dev: thermal_cooling_device pointer to keep track of the
+ *	registered cooling device.
+ * @cpucore_state: integer value representing the current state of cpucore
+ *	cooling	devices.
+ * @cpucore_val: integer value representing the absolute value of the clipped
+ *	frequency.
+ * @allowed_cpus: all the cpus involved for this cpucore_cooling_device.
+ *
+ * This structure is required for keeping information of each
+ * cpucore_cooling_device registered. In order to prevent corruption of this a
+ * mutex lock cooling_cpucore_lock is used.
+ */
+
+static DEFINE_IDR(cpucore_idr);
+static DEFINE_MUTEX(cooling_cpucore_lock);
+
+/* notify_table passes value to the cpucore_ADJUST callback function. */
+#define NOTIFY_INVALID NULL
+
+/**
+ * get_idr - function to get a unique id.
+ * @idr: struct idr * handle used to create a id.
+ * @id: int * value generated by this function.
+ *
+ * This function will populate @id with an unique
+ * id, using the idr API.
+ *
+ * Return: 0 on success, an error code on failure.
+ */
+static int get_idr(struct idr *idr, int *id)
+{
+	int ret;
+
+	mutex_lock(&cooling_cpucore_lock);
+	ret = idr_alloc(idr, NULL, 0, 0, GFP_KERNEL);
+	mutex_unlock(&cooling_cpucore_lock);
+	if (unlikely(ret < 0))
+		return ret;
+	*id = ret;
+
+	return 0;
+}
+
+/**
+ * release_idr - function to free the unique id.
+ * @idr: struct idr * handle used for creating the id.
+ * @id: int value representing the unique id.
+ */
+static void release_idr(struct idr *idr, int id)
+{
+	mutex_lock(&cooling_cpucore_lock);
+	idr_remove(idr, id);
+	mutex_unlock(&cooling_cpucore_lock);
+}
+
+/* cpucore cooling device callback functions are defined below */
+
+/**
+ * cpucore_get_max_state - callback function to get the max cooling state.
+ * @cdev: thermal cooling device pointer.
+ * @state: fill this variable with the max cooling state.
+ *
+ * Callback for the thermal cooling device to return the cpucore
+ * max cooling state.
+ *
+ * Return: 0 on success, an error code otherwise.
+ */
+static int cpucore_get_max_state(struct thermal_cooling_device *cdev,
+				 unsigned long *state)
+{
+	struct cpucore_cooling_device *cpucore_device = cdev->devdata;
+	*state=cpucore_device->max_cpu_core_num;
+	printk(KERN_DEBUG "max cpu core=%d\n",*state);
+	return 0;
+}
+
+/**
+ * cpucore_get_cur_state - callback function to get the current cooling state.
+ * @cdev: thermal cooling device pointer.
+ * @state: fill this variable with the current cooling state.
+ *
+ * Callback for the thermal cooling device to return the cpucore
+ * current cooling state.
+ *
+ * Return: 0 on success, an error code otherwise.
+ */
+static int cpucore_get_cur_state(struct thermal_cooling_device *cdev,
+				 unsigned long *state)
+{
+	struct cpucore_cooling_device *cpucore_device = cdev->devdata;
+	*state=cpucore_device->cpucore_state;
+	printk(KERN_DEBUG "current state=%d\n",*state);
+	return 0;
+}
+
+/**
+ * cpucore_set_cur_state - callback function to set the current cooling state.
+ * @cdev: thermal cooling device pointer.
+ * @state: set this variable to the current cooling state.
+ *
+ * Callback for the thermal cooling device to change the cpucore
+ * current cooling state.
+ *
+ * Return: 0 on success, an error code otherwise.
+ */
+static int cpucore_set_cur_state(struct thermal_cooling_device *cdev,
+				 unsigned long state)
+{
+	struct cpucore_cooling_device *cpucore_device = cdev->devdata;
+	int set_max_num;
+	cpucore_device->cpucore_state=state;
+	set_max_num=cpucore_device->max_cpu_core_num-state;
+	printk(KERN_DEBUG "need set max cpu num=%d,state=%d\n",set_max_num,state);
+	cpufreq_set_max_cpu_num(set_max_num);
+	return 0;
+}
+
+/* Bind cpucore callbacks to thermal cooling device ops */
+static struct thermal_cooling_device_ops const cpucore_cooling_ops = {
+	.get_max_state = cpucore_get_max_state,
+	.get_cur_state = cpucore_get_cur_state,
+	.set_cur_state = cpucore_set_cur_state,
+};
+
+/**
+ * cpucore_cooling_register - function to create cpucore cooling device.
+ * @clip_cpus: cpumask of cpus where the frequency constraints will happen.
+ *
+ * This interface function registers the cpucore cooling device with the name
+ * "thermal-cpucore-%x". This api can support multiple instances of cpucore
+ * cooling devices.
+ *
+ * Return: a valid struct thermal_cooling_device pointer on success,
+ * on failure, it returns a corresponding ERR_PTR().
+ */
+struct thermal_cooling_device *
+cpucore_cooling_register(void)
+{
+	struct thermal_cooling_device *cool_dev;
+	struct cpucore_cooling_device *cpucore_dev = NULL;
+	char dev_name[THERMAL_NAME_LENGTH];
+	int ret = 0;
+	cpucore_dev = kzalloc(sizeof(struct cpucore_cooling_device),
+			      GFP_KERNEL);
+	if (!cpucore_dev)
+		return ERR_PTR(-ENOMEM);
+
+	ret = get_idr(&cpucore_idr, &cpucore_dev->id);
+	if (ret) {
+		kfree(cpucore_dev);
+		return ERR_PTR(-EINVAL);
+	}
+
+	snprintf(dev_name, sizeof(dev_name), "thermal-cpucore-%d",
+		 cpucore_dev->id);
+
+	cool_dev = thermal_cooling_device_register(dev_name, cpucore_dev,
+						   &cpucore_cooling_ops);
+	if (!cool_dev) {
+		release_idr(&cpucore_idr, cpucore_dev->id);
+		kfree(cpucore_dev);
+		return ERR_PTR(-EINVAL);
+	}
+	cpucore_dev->cool_dev = cool_dev;
+	cpucore_dev->cpucore_state = 0;
+	cpucore_dev->max_cpu_core_num=num_present_cpus();
+	return cool_dev;
+}
+EXPORT_SYMBOL_GPL(cpucore_cooling_register);
+
+/**
+ * cpucore_cooling_unregister - function to remove cpucore cooling device.
+ * @cdev: thermal cooling device pointer.
+ *
+ * This interface function unregisters the "thermal-cpucore-%x" cooling device.
+ */
+void cpucore_cooling_unregister(struct thermal_cooling_device *cdev)
+{
+	struct cpucore_cooling_device *cpucore_dev;
+
+	if (!cdev)
+		return;
+
+	cpucore_dev = cdev->devdata;
+
+	thermal_cooling_device_unregister(cpucore_dev->cool_dev);
+	release_idr(&cpucore_idr, cpucore_dev->id);
+	kfree(cpucore_dev);
+}
+EXPORT_SYMBOL_GPL(cpucore_cooling_unregister);
diff --git a/drivers/thermal/gpucore_cooling.c b/drivers/thermal/gpucore_cooling.c
new file mode 100755
index 000000000000..f893429c80a2
--- /dev/null
+++ b/drivers/thermal/gpucore_cooling.c
@@ -0,0 +1,228 @@
+/*
+ *  linux/drivers/thermal/cpu_cooling.c
+ *
+ *  Copyright (C) 2012	Samsung Electronics Co., Ltd(http://www.samsung.com)
+ *  Copyright (C) 2012  Amit Daniel <amit.kachhap@linaro.org>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#include <linux/module.h>
+#include <linux/thermal.h>
+#include <linux/cpufreq.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/cpu.h>
+#include <linux/gpucore_cooling.h>
+
+/**
+ * struct gpucore_cooling_device - data for cooling device with gpucore
+ * @id: unique integer value corresponding to each gpucore_cooling_device
+ *	registered.
+ * @cool_dev: thermal_cooling_device pointer to keep track of the
+ *	registered cooling device.
+ * @gpucore_state: integer value representing the current state of gpucore
+ *	cooling	devices.
+ * @gpucore_val: integer value representing the absolute value of the clipped
+ *	frequency.
+ * @allowed_cpus: all the cpus involved for this gpucore_cooling_device.
+ *
+ * This structure is required for keeping information of each
+ * gpucore_cooling_device registered. In order to prevent corruption of this a
+ * mutex lock cooling_gpucore_lock is used.
+ */
+
+static DEFINE_IDR(gpucore_idr);
+static DEFINE_MUTEX(cooling_gpucore_lock);
+
+/* notify_table passes value to the gpucore_ADJUST callback function. */
+#define NOTIFY_INVALID NULL
+
+/**
+ * get_idr - function to get a unique id.
+ * @idr: struct idr * handle used to create a id.
+ * @id: int * value generated by this function.
+ *
+ * This function will populate @id with an unique
+ * id, using the idr API.
+ *
+ * Return: 0 on success, an error code on failure.
+ */
+static int get_idr(struct idr *idr, int *id)
+{
+	int ret;
+
+	mutex_lock(&cooling_gpucore_lock);
+	ret = idr_alloc(idr, NULL, 0, 0, GFP_KERNEL);
+	mutex_unlock(&cooling_gpucore_lock);
+	if (unlikely(ret < 0))
+		return ret;
+	*id = ret;
+
+	return 0;
+}
+
+/**
+ * release_idr - function to free the unique id.
+ * @idr: struct idr * handle used for creating the id.
+ * @id: int value representing the unique id.
+ */
+static void release_idr(struct idr *idr, int id)
+{
+	mutex_lock(&cooling_gpucore_lock);
+	idr_remove(idr, id);
+	mutex_unlock(&cooling_gpucore_lock);
+}
+
+/* gpucore cooling device callback functions are defined below */
+
+/**
+ * gpucore_get_max_state - callback function to get the max cooling state.
+ * @cdev: thermal cooling device pointer.
+ * @state: fill this variable with the max cooling state.
+ *
+ * Callback for the thermal cooling device to return the gpucore
+ * max cooling state.
+ *
+ * Return: 0 on success, an error code otherwise.
+ */
+static int gpucore_get_max_state(struct thermal_cooling_device *cdev,
+				 unsigned long *state)
+{
+	struct gpucore_cooling_device *gpucore_device = cdev->devdata;
+	*state=gpucore_device->max_gpu_core_num;
+	printk( "max Gpu core=%d\n",*state);
+	return 0;
+}
+
+/**
+ * gpucore_get_cur_state - callback function to get the current cooling state.
+ * @cdev: thermal cooling device pointer.
+ * @state: fill this variable with the current cooling state.
+ *
+ * Callback for the thermal cooling device to return the gpucore
+ * current cooling state.
+ *
+ * Return: 0 on success, an error code otherwise.
+ */
+static int gpucore_get_cur_state(struct thermal_cooling_device *cdev,
+				 unsigned long *state)
+{
+	struct gpucore_cooling_device *gpucore_device = cdev->devdata;
+	*state=gpucore_device->gpucore_state;
+	printk(KERN_DEBUG "current state=%d\n",*state);
+	return 0;
+}
+
+/**
+ * gpucore_set_cur_state - callback function to set the current cooling state.
+ * @cdev: thermal cooling device pointer.
+ * @state: set this variable to the current cooling state.
+ *
+ * Callback for the thermal cooling device to change the gpucore
+ * current cooling state.
+ *
+ * Return: 0 on success, an error code otherwise.
+ */
+static int gpucore_set_cur_state(struct thermal_cooling_device *cdev,
+				 unsigned long state)
+{
+	struct gpucore_cooling_device *gpucore_device = cdev->devdata;
+	int set_max_num;
+	gpucore_device->gpucore_state=state;
+	set_max_num=gpucore_device->max_gpu_core_num-state;
+	gpucore_device->set_max_pp_num((unsigned int)set_max_num);
+	printk(KERN_DEBUG "need set max cpu num=%d,state=%d\n",set_max_num,state);
+	return 0;
+}
+
+/* Bind gpucore callbacks to thermal cooling device ops */
+static struct thermal_cooling_device_ops const gpucore_cooling_ops = {
+	.get_max_state = gpucore_get_max_state,
+	.get_cur_state = gpucore_get_cur_state,
+	.set_cur_state = gpucore_set_cur_state,
+};
+
+/**
+ * gpucore_cooling_register - function to create gpucore cooling device.
+ * @clip_cpus: cpumask of cpus where the frequency constraints will happen.
+ *
+ * This interface function registers the gpucore cooling device with the name
+ * "thermal-gpucore-%x". This api can support multiple instances of gpucore
+ * cooling devices.
+ *
+ * Return: a valid struct thermal_cooling_device pointer on success,
+ * on failure, it returns a corresponding ERR_PTR().
+ */
+ struct gpucore_cooling_device * gpucore_cooling_alloc(void)
+{
+	struct gpucore_cooling_device *gcdev;
+	gcdev=kzalloc(sizeof(struct gpucore_cooling_device), GFP_KERNEL);
+	if (!gcdev)
+		return ERR_PTR(-ENOMEM);
+	memset(gcdev,0,sizeof(*gcdev));
+	return gcdev;
+}
+EXPORT_SYMBOL_GPL(gpucore_cooling_alloc);
+
+struct thermal_cooling_device *
+gpucore_cooling_register(struct gpucore_cooling_device *gpucore_dev)
+{
+	struct thermal_cooling_device *cool_dev;
+	char dev_name[THERMAL_NAME_LENGTH];
+	int ret = 0;
+	ret = get_idr(&gpucore_idr, &gpucore_dev->id);
+	if (ret) {
+		kfree(gpucore_dev);
+		return ERR_PTR(-EINVAL);
+	}
+
+	snprintf(dev_name, sizeof(dev_name), "thermal-gpucore-%d",
+		 gpucore_dev->id);
+
+	cool_dev = thermal_cooling_device_register(dev_name, gpucore_dev,
+						   &gpucore_cooling_ops);
+	if (!cool_dev) {
+		release_idr(&gpucore_idr, gpucore_dev->id);
+		kfree(gpucore_dev);
+		return ERR_PTR(-EINVAL);
+	}
+	gpucore_dev->cool_dev = cool_dev;
+	gpucore_dev->gpucore_state = 0;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gpucore_cooling_register);
+
+/**
+ * gpucore_cooling_unregister - function to remove gpucore cooling device.
+ * @cdev: thermal cooling device pointer.
+ *
+ * This interface function unregisters the "thermal-gpucore-%x" cooling device.
+ */
+void gpucore_cooling_unregister(struct thermal_cooling_device *cdev)
+{
+	struct gpucore_cooling_device *gpucore_dev;
+
+	if (!cdev)
+		return;
+
+	gpucore_dev = cdev->devdata;
+
+	thermal_cooling_device_unregister(gpucore_dev->cool_dev);
+	release_idr(&gpucore_idr, gpucore_dev->id);
+	kfree(gpucore_dev);
+}
+EXPORT_SYMBOL_GPL(gpucore_cooling_unregister);
diff --git a/include/linux/cpucore_cooling.h b/include/linux/cpucore_cooling.h
new file mode 100755
index 000000000000..0a9e461d6615
--- /dev/null
+++ b/include/linux/cpucore_cooling.h
@@ -0,0 +1,65 @@
+/*
+ *  linux/include/linux/cpu_cooling.h
+ *
+ *  Copyright (C) 2012	Samsung Electronics Co., Ltd(http://www.samsung.com)
+ *  Copyright (C) 2012  Amit Daniel <amit.kachhap@linaro.org>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef __CPUCORE_COOLING_H__
+#define __CPUCORE_COOLING_H__
+
+#include <linux/thermal.h>
+#include <linux/cpumask.h>
+struct cpucore_cooling_device {
+	int id;
+	struct thermal_cooling_device *cool_dev;
+	unsigned int cpucore_state;
+	unsigned int cpucore_val;
+	int max_cpu_core_num;
+};
+
+#ifdef CONFIG_CPUCORE_THERMAL
+
+/**
+ * cpucore_cooling_register - function to create cpucore cooling device.
+ * @clip_cpus: cpumask of cpus where the frequency constraints will happen
+ */
+struct thermal_cooling_device * cpucore_cooling_register(void);
+
+/**
+ * cpucore_cooling_unregister - function to remove cpucore cooling device.
+ * @cdev: thermal cooling device pointer.
+ */
+void cpucore_cooling_unregister(struct thermal_cooling_device *cdev);
+
+
+#else /* !CONFIG_CPU_THERMAL */
+static inline struct thermal_cooling_device *
+cpucore_cooling_register(void)
+{
+	return NULL;
+}
+static inline
+void cpucore_cooling_unregister(struct thermal_cooling_device *cdev)
+{
+	return;
+}
+#endif	/* CONFIG_CPU_THERMAL */
+
+#endif /* __CPU_COOLING_H__ */
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 4c7a0527aeb7..a04fc14079dc 100755
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -439,4 +439,42 @@ void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
+#ifdef CONFIG_CPU_FREQ_GOV_HOTPLUG
+void cpufreq_set_max_cpu_num(unsigned int cpu_num);
+#else
+unsigned int max_cpu_num=NR_CPUS;
+unsigned int last_max_cpu_num=max_cpu_num;
+static inline void cpu_up_num(unsigned int num)
+{
+	for(i = 0; i < num; i++){
+		if(cpu_online(i))
+			continue;
+		cpu_up(i);
+		cpumask_set_cpu(i, tsk_cpus_allowed(NULL_task));
+	}
+}
+
+static inline void cpufreq_set_max_cpu_num(unsigned int cpu_num)
+{
+	int i=0
+	if(cpu_num>=NR_CPUS)
+	{
+		cpu_up_num(NR_CPUS);
+	}else
+	{
+		if(cpu_num>last_max_cpu_num){
+			cpu_up_num(cpu_num);
+		}else{
+			for(i=NR_CPUS-1;i>=cpu_num;i--)
+			{
+				if(!cpu_active(i))
+					continue;
+				cpu_down(i);
+			}
+		}
+		
+	}
+	
+}
+#endif
 #endif /* _LINUX_CPUFREQ_H */
diff --git a/include/linux/gpucore_cooling.h b/include/linux/gpucore_cooling.h
new file mode 100755
index 000000000000..1fbc61225280
--- /dev/null
+++ b/include/linux/gpucore_cooling.h
@@ -0,0 +1,70 @@
+/*
+ *  linux/include/linux/cpu_cooling.h
+ *
+ *  Copyright (C) 2012	Samsung Electronics Co., Ltd(http://www.samsung.com)
+ *  Copyright (C) 2012  Amit Daniel <amit.kachhap@linaro.org>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef __GPUCORE_COOLING_H__
+#define __GPUCORE_COOLING_H__
+
+#include <linux/thermal.h>
+#include <linux/cpumask.h>
+struct gpucore_cooling_device {
+	int id;
+	struct thermal_cooling_device *cool_dev;
+	unsigned int gpucore_state;
+	unsigned int gpucore_val;
+	 int max_gpu_core_num;
+	unsigned int (*set_max_pp_num)(unsigned int);
+};
+
+#ifdef CONFIG_GPUCORE_THERMAL
+
+/**
+ * gpucore_cooling_register - function to create gpucore cooling device.
+ * @clip_cpus: cpumask of cpus where the frequency constraints will happen
+ */
+struct thermal_cooling_device * gpucore_cooling_register(struct gpucore_cooling_device *);
+
+/**
+ * gpucore_cooling_unregister - function to remove gpucore cooling device.
+ * @cdev: thermal cooling device pointer.
+ */
+void gpucore_cooling_unregister(struct thermal_cooling_device *cdev);
+struct gpucore_cooling_device * gpucore_cooling_alloc(void);
+
+#else /* !CONFIG_CPU_THERMAL */
+struct gpucore_cooling_device * gpucore_cooling_alloc(){
+	return NULL;
+}
+
+static inline struct thermal_cooling_device *
+gpucore_cooling_register(struct gpucore_cooling_device *)
+{
+	return NULL;
+}
+static inline
+void gpucore_cooling_unregister(struct thermal_cooling_device *cdev)
+{
+	return;
+}
+#endif	/* CONFIG_CPU_THERMAL */
+
+#endif /* __CPU_COOLING_H__ */
-- 
2.19.0

