From 8b6b4ee05fc1e4325b076b1d9a7524e41fdc4b65 Mon Sep 17 00:00:00 2001
From: "zhe.wang" <zhe.wang@amlogic.com>
Date: Mon, 31 Mar 2014 18:57:11 +0800
Subject: [PATCH 3844/5965] PD #89278: add codec 5711 control interface in dtd
 file for M6TVD and fixed amaudio2 compile error on M8

---
 arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd |  47 ++++
 drivers/amlogic/amaudio/amaudio.c           |   1 -
 drivers/amlogic/amaudio2/amaudio2.c         |   2 +-
 drivers/amlogic/amaudio2/amaudio2.h         |   7 +-
 include/sound/tas57xx.h                     |  26 +-
 sound/soc/aml/m6/aml_audio_codec_probe.c    | 272 +++++++++++++++++---
 sound/soc/aml/m6/aml_audio_codec_probe.h    |   6 +-
 sound/soc/aml/m6/aml_pcm.c                  |  24 +-
 sound/soc/aml/m8/aml_i2s.c                  |  84 +++---
 sound/soc/codecs/tas5711.c                  | 188 +++++++++-----
 10 files changed, 494 insertions(+), 163 deletions(-)
 mode change 100644 => 100755 include/sound/tas57xx.h
 mode change 100644 => 100755 sound/soc/aml/m6/aml_audio_codec_probe.c
 mode change 100644 => 100755 sound/soc/aml/m6/aml_audio_codec_probe.h
 mode change 100644 => 100755 sound/soc/codecs/tas5711.c

diff --git a/arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd b/arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd
index 167a2655f99b..fa422b30595f 100755
--- a/arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6tvd_ref.dtd
@@ -468,6 +468,53 @@
 			codec_name = "tas5711";
 			i2c_addr = <0x1B>;
 			i2c_bus = "i2c_bus_a";
+			master_vol = <0x25>;
+			eq_name = "table","wall";
+			eq_table = /bits/ 8 <
+				0x00 0x7E 0x95 0xFF 0x0F 0x02 0xD4 0x01 0x00 0x7E 0x95 0xFF 0x00 0xFD 0x27 0xFF 0x0F 0x82 0xD0 0x01 /*0x29---ch1_bq[0]*/
+				0x00 0x7F 0x83 0xD8 0x0F 0x02 0xC3 0x92 0x00 0x7D 0xDB 0x4F 0x00 0xFD 0x3C 0x6E 0x0F 0x82 0xA0 0xD8 /*0x2A---ch1_bq[1]*/
+				0x00 0x82 0xCE 0x97 0x0F 0x4C 0x87 0x81 0x00 0x5F 0x69 0x2D 0x00 0xB3 0x78 0x7F 0x0F 0x9D 0xC8 0x3B /*0x2B---ch1_bq[2]*/
+				0x00 0x83 0x6B 0x4A 0x0F 0x7A 0x3D 0xA6 0x00 0x58 0x4D 0xED 0x00 0x85 0xC2 0x5A 0x0F 0xA4 0x46 0xC9 /*0x2C---ch1_bq[3]*/
+				0x00 0x83 0x6B 0x4A 0x0F 0xAB 0xEA 0x5C 0x00 0x58 0x4D 0xED 0x00 0x54 0x15 0xA4 0x0F 0xA4 0x46 0xC9 /*0x2D---ch1_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2E---ch1_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x2F---ch1_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x58---ch1_bq[7]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x59---ch1_bq[8]*/
+				0x00 0x7E 0x95 0xFF 0x0F 0x02 0xD4 0x01 0x00 0x7E 0x95 0xFF 0x00 0xFD 0x27 0xFF 0x0F 0x82 0xD0 0x01 /*0x30---ch2_bq[0]*/
+				0x00 0x7F 0x83 0xD8 0x0F 0x02 0xC3 0x92 0x00 0x7D 0xDB 0x4F 0x00 0xFD 0x3C 0x6E 0x0F 0x82 0xA0 0xD8 /*0x31---ch2_bq[1]*/
+				0x00 0x82 0xCE 0x97 0x0F 0x4C 0x87 0x81 0x00 0x5F 0x69 0x2D 0x00 0xB3 0x78 0x7F 0x0F 0x9D 0xC8 0x3B /*0x32---ch2_bq[2]*/
+				0x00 0x83 0x6B 0x4A 0x0F 0x7A 0x3D 0xA6 0x00 0x58 0x4D 0xED 0x00 0x85 0xC2 0x5A 0x0F 0xA4 0x46 0xC9 /*0x33---ch2_bq[3]*/
+				0x00 0x83 0x6B 0x4A 0x0F 0xAB 0xEA 0x5C 0x00 0x58 0x4D 0xED 0x00 0x54 0x15 0xA4 0x0F 0xA4 0x46 0xC9 /*0x34---ch2_bq[4]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x35---ch2_bq[5]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x36---ch2_bq[6]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x5C---ch2_bq[7]*/
+				0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 /*0x5D---ch2_bq[8]*/
+			>;
+			sub_bq_table = /bits/ 8 <
+				0x00 0x00 0x03 0x8A 0x00 0x00 0x07 0x14 0x00 0x00 0x03 0x8A 0x00 0xFC 0x35 0x5D 0x0F 0x83 0xBC 0x79 /*0x5A*/
+				0x00 0x00 0x03 0x8A 0x00 0x00 0x07 0x14 0x00 0x00 0x03 0x8A 0x00 0xFC 0x35 0x5D 0x0F 0x83 0xBC 0x79 /*0x5B*/
+			>;
+			drc1_tko_table = /bits/ 8 <
+				0xFD 0xA2 0x14 0x90 /*0x40---drc1_t*/
+				0x0F 0x81 0x47 0xAF /*0x41---drc1_k*/
+				0x00 0x08 0x42 0x10 /*0x42---drc1_o*/
+			>;
+			drc1_table = /bits/ 8 <
+				0x00 0x05 0x39 0x47 0x00 0x7A 0xC6 0xB8 /*0x3A---drc1_ae*/
+				0x00 0x05 0x39 0x47 0x00 0x7A 0xC6 0xB8 /*0x3B---drc1_aa*/
+				0x00 0x00 0x00 0xF9 0x00 0x7F 0xFF 0x06 /*0x3C---drc1_ad*/
+			>;
+			drc2_tko_table = /bits/ 8 <
+				0xFD 0xCC 0x99 0xDB /*0x43---drc1_t*/
+				0x0F 0x84 0x44 0x44 /*0x44---drc1_k*/
+				0x00 0x08 0x42 0x10 /*0x45---drc1_o*/
+			>;
+			drc2_table = /bits/ 8 <
+				0x00 0x05 0x39 0x47 0x00 0x7A 0xC6 0xB8 /*0x3D---drc1_ae*/
+				0x00 0x05 0x39 0x47 0x00 0x7A 0xC6 0xB8 /*0x3E---drc1_aa*/
+				0x00 0x00 0x00 0xF9 0x00 0x7F 0xFF 0x06 /*0x3F---drc1_ad*/
+			>;
+			input_mux_reg_buf = /bits/ 8 <0x00 0x10 0x77 0x72>;/*reg d0 d1 d2 d3*/
 			status = "okay";
 		};
 
diff --git a/drivers/amlogic/amaudio/amaudio.c b/drivers/amlogic/amaudio/amaudio.c
index db6104b9c043..77c972dec1dc 100755
--- a/drivers/amlogic/amaudio/amaudio.c
+++ b/drivers/amlogic/amaudio/amaudio.c
@@ -72,7 +72,6 @@ extern int audio_in_buf_ready;
 
 extern unsigned int aml_i2s_playback_start_addr;
 extern unsigned int aml_i2s_capture_start_addr;
-extern unsigned int aml_i2s_capture_start_phy;
 extern unsigned int aml_i2s_capture_buf_size;
 
 static dev_t amaudio_devno;
diff --git a/drivers/amlogic/amaudio2/amaudio2.c b/drivers/amlogic/amaudio2/amaudio2.c
index f8916941943f..f471e5c1501b 100755
--- a/drivers/amlogic/amaudio2/amaudio2.c
+++ b/drivers/amlogic/amaudio2/amaudio2.c
@@ -125,7 +125,7 @@ static int amaudio_open(struct inode *inode, struct file *file)
   	}
 	
   	amaudio->hw.addr = (char*)aml_i2s_playback_start_addr;
-  	amaudio->hw.paddr = aml_pcm_playback_phy_start_addr;
+  	amaudio->hw.paddr = aml_i2s_playback_phy_start_addr;
   	amaudio->hw.size = get_i2s_out_size();
   	amaudio->hw.rd = get_i2s_out_ptr();
 		
diff --git a/drivers/amlogic/amaudio2/amaudio2.h b/drivers/amlogic/amaudio2/amaudio2.h
index 74fd163e2e7d..004c9042e04e 100755
--- a/drivers/amlogic/amaudio2/amaudio2.h
+++ b/drivers/amlogic/amaudio2/amaudio2.h
@@ -49,11 +49,8 @@ static long amaudio_ioctl(struct file *file, unsigned int cmd, unsigned long arg
 static long amaudio_utils_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
                   
 extern unsigned int aml_i2s_playback_start_addr;	
-extern unsigned int aml_i2s_playback_end_addr;
-extern unsigned int aml_pcm_playback_phy_start_addr;
-extern unsigned int aml_pcm_playback_phy_end_addr;
-
-                      
+extern unsigned int aml_i2s_playback_phy_start_addr;
+                    
 #define AMAUDIO_IOC_MAGIC  'A'                      
 
 #define AMAUDIO_IOC_GET_SIZE			_IOW(AMAUDIO_IOC_MAGIC, 0x00, int)       
diff --git a/include/sound/tas57xx.h b/include/sound/tas57xx.h
old mode 100644
new mode 100755
index 4a4e569552ec..5f634021f839
--- a/include/sound/tas57xx.h
+++ b/include/sound/tas57xx.h
@@ -5,26 +5,26 @@
 #define TAS57XX_EQ_BQS 9
 #define TAS57XX_EQ_CHNLS 2
 #define TAS57XX_EQ_BYTES (TAS57XX_EQ_REGS * TAS57XX_EQ_BQS * TAS57XX_EQ_CHNLS)
-
+#define NAME_SIZE 12
 struct tas57xx_reg_cfg {
     const char *reg_data;
 };
 
 struct tas5711_eq_cfg {
-	const char *name;
-	const char *regs;
+	char name[NAME_SIZE];
+	char *regs;
 	int reg_bytes;
 };
 
 struct tas5711_platform_data {
     int (*init_func)(void);
-    int (*early_suspend_func)();
-    int (*suspend_func)();
-    int (*resume_func)();
-    int (*late_resume_func)();
+    int (*early_suspend_func)(void);
+    int (*suspend_func)(void);
+    int (*resume_func)(void);
+    int (*late_resume_func)(void);
     char *custom_init_value_table;
     int init_value_table_len;
-    struct tas57xx_reg_cfg *init_regs;
+    char *init_regs;
     int num_init_regs;
     char *custom_drc1_table;
     int custom_drc1_table_len;
@@ -38,7 +38,7 @@ struct tas5711_platform_data {
     struct tas5711_eq_cfg *eq_cfgs;
     char *custom_sub_bq_table;
     int custom_sub_bq_table_len;
-    char custom_master_vol;
+    unsigned int custom_master_vol;
 
     int enable_ch1_drc;
     int enable_ch2_drc;
@@ -54,10 +54,10 @@ struct tas5707_eq_cfg {
 
 struct tas5707_platform_data {
     int (*init_func)(void);
-    int (*early_suspend_func)();
-    int (*suspend_func)();
-    int (*resume_func)();
-    int (*late_resume_func)();
+    int (*early_suspend_func)(void);
+    int (*suspend_func)(void);
+    int (*resume_func)(void);
+    int (*late_resume_func)(void);
     char *custom_init_value_table;
     int init_value_table_len;
     struct tas57xx_reg_cfg *init_regs;
diff --git a/sound/soc/aml/m6/aml_audio_codec_probe.c b/sound/soc/aml/m6/aml_audio_codec_probe.c
old mode 100644
new mode 100755
index 0296a3b564f7..e7f82f5e6875
--- a/sound/soc/aml/m6/aml_audio_codec_probe.c
+++ b/sound/soc/aml/m6/aml_audio_codec_probe.c
@@ -13,15 +13,14 @@
 #include <linux/module.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
-#include <linux/of.h>
 #include <linux/slab.h>
 #include <linux/pinctrl/consumer.h>
 #include <mach/am_regs.h>
 #include <linux/delay.h>
 #include <mach/gpio.h>
-#include <linux/amlogic/aml_audio_codec_probe.h>
 #include <linux/amlogic/aml_gpio_consumer.h>
-
+#include <sound/tas57xx.h>
+#include "aml_audio_codec_probe.h"
 
 
 extern struct i2c_client * i2c_new_device(struct i2c_adapter *adap,
@@ -29,11 +28,6 @@ extern struct i2c_client * i2c_new_device(struct i2c_adapter *adap,
 
 
 static struct platform_device* audio_codec_pdev = NULL;
-
-bool is_rt5631;
-bool is_wm8960;
-bool is_rt5616;
-
 static int regist_codec_info(struct device_node* p_node, aml_audio_codec_info_t* audio_codec_dev)
 {
     int ret = 0;
@@ -45,15 +39,7 @@ static int regist_codec_info(struct device_node* p_node, aml_audio_codec_info_t*
     if(ret){
         printk("%s:this audio codec is disabled!\n",audio_codec_dev->name);
     }
-    if(!strcmp(audio_codec_dev->name, "rt5631") && !strcmp(audio_codec_dev->status,"okay")){
-        is_rt5631 = true;
-    }else if(strcmp(audio_codec_dev->name, "wm8960") && strcmp(audio_codec_dev->status,"okay")){
-        is_wm8960 = true;
-    }else if(strcmp(audio_codec_dev->name, "rt5616") && strcmp(audio_codec_dev->status,"okay")){
-        is_rt5616 = true;
-    }
 
-    printk("*********is_rt5631=%d,is_wm8960=%d,is_rt5616=%d*\n",is_rt5631,is_wm8960,is_rt5616);
     return 0;
 }
 
@@ -125,19 +111,230 @@ err_out:
     return ret;
 }
 
+#ifdef CONFIG_SND_AML_M6TV_AUDIO_CODEC
+static struct codec_probe_priv prob_priv;
+struct codec_probe_priv{
+	int num_eq;
+	struct tas5711_eq_cfg *eq_configs;
+	char *sub_bq_table;
+	char *drc1_table;
+	char *drc1_tko_table;
+};
+
+static int of_get_eq_pdata(struct tas5711_platform_data *pdata, struct device_node* p_node)
+{
+	int i, ret = 0, length = 0;
+	const char *str = NULL;
+	char *regs = NULL;
+
+	prob_priv.num_eq = of_property_count_strings(p_node,"eq_name");
+	if(prob_priv.num_eq <= 0){
+		printk("no of eq_name config\n");
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	pdata->num_eq_cfgs = prob_priv.num_eq;
+
+	prob_priv.eq_configs = kzalloc(prob_priv.num_eq * sizeof(struct tas5711_eq_cfg), GFP_KERNEL);
+
+	for(i = 0; i < prob_priv.num_eq; i++){
+		ret = of_property_read_string_index(p_node, "eq_name", i , &str);
+
+		if(of_find_property(p_node, "eq_table", &length) == NULL){
+			printk("%s fail to get of eq_table\n", __func__);
+			goto exit1;
+		}
+
+		regs = kzalloc(length * sizeof(char *), GFP_KERNEL);
+		if (!regs) {
+			printk("ERROR, NO enough mem for eq_table!\n");
+			return -ENOMEM;
+		}
+
+		ret = of_property_read_u8_array(p_node, "eq_table", regs, length);
+
+		strncpy(prob_priv.eq_configs[i].name, str, NAME_SIZE);
+		prob_priv.eq_configs[i].regs = regs;
+	}
+
+	pdata->eq_cfgs = prob_priv.eq_configs;
+
+	return 0;
+exit1:
+	kfree(prob_priv.eq_configs);
+exit:
+	return ret;
+}
+static void *alloc_and_get_data_array(struct device_node *p_node, char *str, int *lenp)
+{
+	int ret = 0, length = 0;
+	char *p = NULL;
+
+	if(of_find_property(p_node, str, &length) == NULL){
+		printk("DT of %s not found!\n", str);
+		goto exit;
+	}
+	printk("prop=%s,length=%d\n",str,length);
+	p = kzalloc(length * sizeof(char *), GFP_KERNEL);
+	if (p == NULL) {
+		printk("ERROR, NO enough mem for %s!\n", str);
+		length = 0;
+		goto exit;
+	}
+
+	ret = of_property_read_u8_array(p_node, str, p, length);
+	if (ret) {
+	printk("no of property %s!\n", str);
+		kfree(p);
+		p = NULL;
+		goto exit;
+	}
+
+	*lenp = length;
+
+exit:
+	return p;
+}
+
+static int of_get_subwoofer_pdata(struct tas5711_platform_data *pdata, struct device_node *p_node)
+{
+	int length = 0;
+	char *pd = NULL;
+
+	pd = alloc_and_get_data_array(p_node, "sub_bq_table", &length);
 
+	if(pd == NULL){
+		return -1;
+	}
+
+	pdata->custom_sub_bq_table_len = length;
+	pdata->custom_sub_bq_table = pd;
+
+	return 0;
+}
+
+static int of_get_drc_pdata(struct tas5711_platform_data *pdata, struct device_node* p_node)
+{
+	int length = 0;
+	char *pd = NULL;
+
+	//get drc1 table
+	pd = alloc_and_get_data_array(p_node, "drc1_table", &length);
+	if(pd == NULL){
+		return -1;
+	}
+	pdata->custom_drc1_table_len = length;
+	pdata->custom_drc1_table = pd;
+
+	//get drc1 tko table
+	length = 0;
+	pd = NULL;
+
+	pd = alloc_and_get_data_array(p_node, "drc1_tko_table", &length);
+	if(pd == NULL){
+		return -1;
+	}
+	pdata->custom_drc1_tko_table_len = length;
+	pdata->custom_drc1_tko_table = pd;
+	pdata->enable_ch1_drc = 1;
+
+	//get drc2 table
+	length = 0;
+	pd = NULL;
+	pd = alloc_and_get_data_array(p_node, "drc2_table", &length);
+	if(pd == NULL){
+		return -1;
+	}
+	pdata->custom_drc2_table_len = length;
+	pdata->custom_drc2_table = pd;
+
+	//get drc2 tko table
+	length = 0;
+	pd = NULL;
+	pd = alloc_and_get_data_array(p_node, "drc2_tko_table", &length);
+	if(pd == NULL){
+		return -1;
+	}
+	pdata->custom_drc2_tko_table_len = length;
+	pdata->custom_drc2_tko_table = pd;
+	pdata->enable_ch2_drc = 1;
+
+	return 0;
+}
+
+static int of_get_init_pdata(struct tas5711_platform_data *pdata, struct device_node* p_node)
+{
+	int length = 0;
+	char *pd = NULL;
+
+	pd = alloc_and_get_data_array(p_node, "input_mux_reg_buf", &length);
+	if(pd == NULL){
+		printk("%s : can't get input_mux_reg_buf \n", __func__);
+		return -1;
+	}
+
+	/*Now only support 0x20 input mux init*/
+	pdata->num_init_regs = length;
+	pdata->init_regs = pd;
+
+	if(of_property_read_u32(p_node,"master_vol", &pdata->custom_master_vol)){
+		printk("%s fail to get master volume\n", __func__);
+		return -1;
+	}
+
+	return 0;
+
+}
+static int codec_get_of_pdata(struct tas5711_platform_data *pdata, struct device_node* p_node)
+{
+	int ret = 0;
+
+	ret = of_get_eq_pdata(pdata, p_node);
+	if(ret){
+		printk("no platform codec EQ config found\n");
+	}
+
+	ret = of_get_subwoofer_pdata(pdata, p_node);
+	if(ret){
+		printk("no platform codec subwoofer config found\n");
+	}
+
+	ret = of_get_drc_pdata(pdata, p_node);
+	if(ret){
+		printk("no platform codec drc config found\n");
+	}
+
+	ret = of_get_init_pdata(pdata, p_node);
+	if(ret){
+		printk("no platform codec init config found\n");
+	}
+
+	return ret;
+}
+#endif
 static int aml_audio_codec_probe(struct platform_device *pdev)
 {
-    struct device_node* audio_codec_node = pdev->dev.of_node;
-    struct device_node* child;
-    struct i2c_board_info board_info;
-    struct i2c_adapter *adapter;
-    aml_audio_codec_info_t temp_audio_codec;
-    audio_codec_pdev = pdev;
-    is_rt5631 = false;
-    is_wm8960 = false;
-    is_rt5616 = false;
-    for_each_child_of_node(audio_codec_node, child) {
+	struct device_node* audio_codec_node = pdev->dev.of_node;
+	struct device_node* child;
+	struct i2c_board_info board_info;
+	struct i2c_adapter *adapter;
+	aml_audio_codec_info_t temp_audio_codec;
+#ifdef CONFIG_SND_AML_M6TV_AUDIO_CODEC
+	struct tas5711_platform_data *pdata;
+	struct i2c_client *client;
+
+	pdata = kzalloc(sizeof(struct tas5711_platform_data), GFP_KERNEL);
+	if (!pdata) {
+		printk("ERROR, NO enough mem for tas5711_platform_data!\n");
+		return -ENOMEM;
+    }
+#endif
+	memset(&board_info, 0, sizeof(board_info));
+
+	audio_codec_pdev = pdev;
+
+	for_each_child_of_node(audio_codec_node, child) {
 
         memset(&temp_audio_codec, 0, sizeof(aml_audio_codec_info_t));
         regist_codec_info(child,&temp_audio_codec);
@@ -145,11 +342,15 @@ static int aml_audio_codec_probe(struct platform_device *pdev)
             continue;
         }
         memset(&board_info, 0, sizeof(board_info));
-        strncpy(board_info.type, temp_audio_codec.name, I2C_NAME_SIZE);
+		strncpy(board_info.type, temp_audio_codec.name, I2C_NAME_SIZE);
         adapter = i2c_get_adapter(temp_audio_codec.i2c_bus_type);
         board_info.addr = temp_audio_codec.i2c_addr;
         board_info.platform_data = &temp_audio_codec;
-        i2c_new_device(adapter, &board_info);
+        client = i2c_new_device(adapter, &board_info);
+#ifdef CONFIG_SND_AML_M6TV_AUDIO_CODEC
+	codec_get_of_pdata(pdata, child);
+	client->dev.platform_data = pdata;
+#endif
     }
     return 0;
 }
@@ -157,9 +358,18 @@ static int aml_audio_codec_probe(struct platform_device *pdev)
 
 static int aml_audio_codec_remove(struct platform_device *pdev)
 {
-    is_rt5631 = false;
-    is_wm8960 = false;
-    is_rt5616 = false;
+	int i;
+
+	for(i = 0; i < prob_priv.num_eq; i++){
+		if(prob_priv.eq_configs[i].regs)
+			kfree(prob_priv.eq_configs[i].regs);
+	}
+
+	if(prob_priv.eq_configs)
+		kfree(prob_priv.eq_configs);
+
+	if(prob_priv.sub_bq_table)
+		kfree(prob_priv.sub_bq_table);
 
     return 0;
 }
diff --git a/sound/soc/aml/m6/aml_audio_codec_probe.h b/sound/soc/aml/m6/aml_audio_codec_probe.h
old mode 100644
new mode 100755
index 19dabdce1e3f..5d64aff174f2
--- a/sound/soc/aml/m6/aml_audio_codec_probe.h
+++ b/sound/soc/aml/m6/aml_audio_codec_probe.h
@@ -2,6 +2,7 @@
 #define __AML_AUDIO_CODEC_DEV__
 #include <linux/list.h>
 #include <linux/i2c.h>
+#include <linux/of.h>
 
 #define AML_I2C_BUS_AO 0
 #define AML_I2C_BUS_A 1
@@ -9,15 +10,16 @@
 #define AML_I2C_BUS_C 3
 #define AML_I2C_BUS_D 4
 
-#define NAME_SIZE 32
+//#define NAME_SIZE 32
 
 typedef int(*aml_audio_codec_probe_fun_t)(struct i2c_adapter *);
 
 typedef struct {
 	const char* name;
 	const char* status;
+	struct device_node* p_node;
 	unsigned i2c_bus_type;
-	unsigned short i2c_addr;
+	unsigned i2c_addr;
 	unsigned id_reg;
 	unsigned id_val;
     unsigned capless;
diff --git a/sound/soc/aml/m6/aml_pcm.c b/sound/soc/aml/m6/aml_pcm.c
index 3f4d701b9a7a..42be52727621 100755
--- a/sound/soc/aml/m6/aml_pcm.c
+++ b/sound/soc/aml/m6/aml_pcm.c
@@ -61,18 +61,18 @@ extern unsigned IEC958_mode_codec;
 
 unsigned int aml_i2s_playback_start_addr = 0;
 unsigned int aml_i2s_capture_start_addr  = 0;
-
 unsigned int aml_pcm_playback_end_addr = 0;
 unsigned int aml_pcm_capture_end_addr = 0;
 
-unsigned int aml_i2s_capture_start_phy = 0;
-unsigned int aml_i2s_capture_buf_size = 0;
+unsigned int aml_i2s_playback_phy_start_addr = 0;
+unsigned int aml_i2s_capture_phy_start_addr = 0;
 unsigned int aml_pcm_playback_phy_start_addr = 0;
 unsigned int aml_pcm_capture_phy_start_addr  = 0;
 unsigned int aml_pcm_playback_phy_end_addr = 0;
 unsigned int aml_pcm_capture_phy_end_addr = 0;
-unsigned int aml_pcm_playback_off = 0;
+
 unsigned int aml_i2s_playback_enable = 1;
+unsigned int aml_i2s_capture_buf_size = 0;
 
 unsigned int aml_iec958_playback_start_addr = 0;
 unsigned int aml_iec958_playback_start_phy = 0;
@@ -104,12 +104,10 @@ static int codec_power_switch(struct snd_pcm_substream *substream, unsigned int
 
 EXPORT_SYMBOL(aml_i2s_playback_start_addr);
 EXPORT_SYMBOL(aml_i2s_capture_start_addr);
-EXPORT_SYMBOL(aml_pcm_playback_off);
 EXPORT_SYMBOL(aml_i2s_playback_enable);
-EXPORT_SYMBOL(aml_pcm_playback_phy_start_addr);
-EXPORT_SYMBOL(aml_pcm_playback_phy_end_addr);
-EXPORT_SYMBOL(aml_pcm_capture_phy_start_addr);
-EXPORT_SYMBOL(aml_pcm_capture_phy_end_addr);
+EXPORT_SYMBOL(aml_i2s_capture_buf_size);
+EXPORT_SYMBOL(aml_i2s_playback_phy_start_addr);
+EXPORT_SYMBOL(aml_i2s_capture_phy_start_addr);
 
 static void aml_codec_power_switch_queue(struct work_struct* work)
 {
@@ -285,8 +283,9 @@ static int aml_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
             aml_i2s_playback_start_addr = (unsigned int)buf->area;
 		    aml_pcm_playback_end_addr = (unsigned int)buf->area + size;
 
-		aml_pcm_playback_phy_start_addr = buf->addr;
-		aml_pcm_playback_phy_end_addr = buf->addr+size;
+			aml_pcm_playback_phy_start_addr = buf->addr;
+			aml_pcm_playback_phy_end_addr = buf->addr+size;
+			aml_i2s_playback_phy_start_addr = aml_pcm_playback_phy_start_addr;
 
         /* alloc iec958 buffer */
         aml_iec958_playback_start_addr = (unsigned int)dma_alloc_coherent(pcm->card->dev, size*4,
@@ -312,10 +311,11 @@ static int aml_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
 
             aml_i2s_capture_start_addr = (unsigned int)buf->area;
 		    aml_pcm_capture_end_addr = (unsigned int)buf->area+size;
-		    aml_i2s_capture_start_phy = buf->addr;
 		    aml_i2s_capture_buf_size = size;
 		    aml_pcm_capture_phy_start_addr = buf->addr;
 		    aml_pcm_capture_phy_end_addr = buf->addr+size;
+			aml_i2s_capture_phy_start_addr = aml_pcm_capture_phy_start_addr;
+
 	    }
 
 	    if (!buf->area)
diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
index a25d74a3f614..8e439e5e786d 100755
--- a/sound/soc/aml/m8/aml_i2s.c
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -36,27 +36,25 @@
 
 #define ALSA_PRINT(fmt,args...)	printk(KERN_INFO "[aml-platform]" fmt,##args)
 #ifdef DEBUG_ALSA_PLATFRORM
-#define ALSA_DEBUG(fmt,args...) 	printk(KERN_INFO "[aml-platform]" fmt,##args)
-#define ALSA_TRACE()     			printk("[aml-platform] enter func %s,line %d\n",__FUNCTION__,__LINE__)
+#define ALSA_DEBUG(fmt,args...) printk(KERN_INFO "[aml-platform]" fmt,##args)
+#define ALSA_TRACE()     	printk("[aml-platform] enter func %s,line %d\n",__FUNCTION__,__LINE__)
 #else
-#define ALSA_DEBUG(fmt,args...) 
-#define ALSA_TRACE()   
+#define ALSA_DEBUG(fmt,args...)
+#define ALSA_TRACE()
 #endif
 
 
 unsigned int aml_i2s_playback_start_addr = 0;
 unsigned int aml_i2s_capture_start_addr  = 0;
-
 unsigned int aml_i2s_playback_end_addr = 0;
 unsigned int aml_i2s_capture_end_addr = 0;
 
-unsigned int aml_i2s_capture_start_phy = 0;
-unsigned int aml_i2s_capture_buf_size = 0;
 unsigned int aml_i2s_playback_phy_start_addr = 0;
 unsigned int aml_i2s_capture_phy_start_addr  = 0;
 unsigned int aml_i2s_playback_phy_end_addr = 0;
 unsigned int aml_i2s_capture_phy_end_addr = 0;
-unsigned int aml_i2s_playback_off = 0;
+
+unsigned int aml_i2s_capture_buf_size = 0;
 unsigned int aml_i2s_playback_enable = 1;
 
 unsigned int aml_iec958_playback_start_addr = 0;
@@ -73,12 +71,10 @@ static unsigned audio_gate_status = 0;
 
 EXPORT_SYMBOL(aml_i2s_playback_start_addr);
 EXPORT_SYMBOL(aml_i2s_capture_start_addr);
-EXPORT_SYMBOL(aml_i2s_playback_off);
+EXPORT_SYMBOL(aml_i2s_capture_buf_size);
 EXPORT_SYMBOL(aml_i2s_playback_enable);
 EXPORT_SYMBOL(aml_i2s_playback_phy_start_addr);
-EXPORT_SYMBOL(aml_i2s_playback_phy_end_addr);
 EXPORT_SYMBOL(aml_i2s_capture_phy_start_addr);
-EXPORT_SYMBOL(aml_i2s_capture_phy_end_addr);
 
 
 /*--------------------------------------------------------------------------*\
@@ -146,7 +142,7 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm,
 	int stream)
 {
-	
+
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 
@@ -165,6 +161,12 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm,
 		    (void *) buf->area,
 		    (void *) buf->addr,
 		    size);
+
+			aml_i2s_playback_start_addr = (unsigned int)buf->area;
+			aml_i2s_playback_end_addr = (unsigned int)buf->area + size;
+			aml_i2s_playback_phy_start_addr = buf->addr;
+			aml_i2s_playback_phy_end_addr = buf->addr+size;
+
         }else{
 
 		size = aml_i2s_capture.buffer_bytes_max;
@@ -180,9 +182,14 @@ static int aml_i2s_preallocate_dma_buffer(struct snd_pcm *pcm,
 		    size);
 	    }
 
+		aml_i2s_capture_start_addr = (unsigned int)buf->area;
+		aml_i2s_capture_end_addr = (unsigned int)buf->area + size;
+		aml_i2s_capture_phy_start_addr = buf->addr;
+		aml_i2s_capture_phy_end_addr = buf->addr+size;
+
 	    if (!buf->area)
 		    return -ENOMEM;
-    
+
 	    buf->bytes = size;
 	    return 0;
 
@@ -257,11 +264,11 @@ static int aml_i2s_trigger(struct snd_pcm_substream *substream,
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:		
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 
 #if USE_HRTIMER == 0
 	  del_timer_sync(&prtd->timer);
-#endif      
+#endif
 	  spin_lock(&s->lock);
 #if USE_HRTIMER == 0
 	  prtd->timer.expires = jiffies + 1;
@@ -320,13 +327,13 @@ static snd_pcm_uframes_t aml_i2s_pointer(
 		if(s->device_type == AML_AUDIO_I2SIN)
 			ptr = audio_in_i2s_wr_ptr();
 		else
-			ptr = audio_in_spdif_wr_ptr();				
+			ptr = audio_in_spdif_wr_ptr();
 			addr = ptr - s->I2S_addr;
 			return bytes_to_frames(runtime, addr)/2;
 	}
 
 	return 0;
-}	
+}
 #if USE_HRTIMER ==1
 static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer* timer)
 {
@@ -334,7 +341,7 @@ static enum hrtimer_restart aml_i2s_hrtimer_callback(struct hrtimer* timer)
   audio_stream_t* s = &prtd->s;
   struct snd_pcm_substream* substream = prtd->substream;
   struct snd_pcm_runtime* runtime= substream->runtime;
-  
+
   unsigned int last_ptr, size;
   //unsigned long flag;
   //printk("------------->hrtimer start\n");
@@ -392,7 +399,7 @@ static void aml_i2s_timer_callback(unsigned long data)
 			if(s->device_type == AML_AUDIO_I2SOUT)
 				last_ptr = read_i2s_rd_ptr();
 			else
-				last_ptr = read_iec958_rd_ptr();							
+				last_ptr = read_iec958_rd_ptr();
 						if (last_ptr < s->last_ptr) {
 				        size = runtime->dma_bytes + last_ptr - (s->last_ptr);
 				    } else {
@@ -417,10 +424,10 @@ static void aml_i2s_timer_callback(unsigned long data)
 		if(s->active == 1)
 		{
 			spin_lock(&s->lock);
-			if(s->device_type == AML_AUDIO_I2SIN)			
+			if(s->device_type == AML_AUDIO_I2SIN)
 				last_ptr = audio_in_i2s_wr_ptr() ;
 			else
-				last_ptr = audio_in_spdif_wr_ptr();				
+				last_ptr = audio_in_spdif_wr_ptr();
 			if (last_ptr < s->last_ptr) {
 				size = runtime->dma_bytes + (last_ptr - (s->last_ptr))/2;
 			} else {
@@ -449,7 +456,7 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s ;		
+	audio_stream_t *s ;
 	int ret = 0;
     ALSA_TRACE();
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
@@ -485,14 +492,14 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 		runtime->private_data = prtd;
 	}
 //	WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 1,14, 1);
-#if USE_HRTIMER == 0    
+#if USE_HRTIMER == 0
 	prtd->timer.function = &aml_i2s_timer_callback;
 	prtd->timer.data = (unsigned long)substream;
 	init_timer(&prtd->timer);
 #else
     hrtimer_init(&prtd->hrtimer,CLOCK_MONOTONIC, HRTIMER_MODE_REL);
     prtd->hrtimer.function = aml_i2s_hrtimer_callback;
-    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL); 
+    hrtimer_start(&prtd->hrtimer, ns_to_ktime(HRTIMER_PERIOD), HRTIMER_MODE_REL);
 
 
     printk("hrtimer inited..\n");
@@ -507,11 +514,11 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
     	if(audio_gate_status == 0){
     		audio_aiu_pg_enable(1);
     		ALSA_DEBUG("aml_pcm_open  device type %x \n", s->device_type);
-    		
+
     	}
     }
 	audio_gate_status  |= s->device_type;
-	mutex_unlock(&gate_mutex);		
+	mutex_unlock(&gate_mutex);
  out:
 	return ret;
 }
@@ -519,17 +526,17 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 static int aml_i2s_close(struct snd_pcm_substream *substream)
 {
 	struct aml_runtime_data *prtd = substream->runtime->private_data;
-	audio_stream_t *s = &prtd->s;	
+	audio_stream_t *s = &prtd->s;
 	ALSA_TRACE();
 	mutex_lock(&gate_mutex);
-	audio_gate_status  &= ~s->device_type;	
+	audio_gate_status  &= ~s->device_type;
 	if(audio_gate_status == 0){
-		ALSA_DEBUG("aml_pcm_close  device type %x \n", s->device_type);		
+		ALSA_DEBUG("aml_pcm_close  device type %x \n", s->device_type);
 		//audio_aiu_pg_enable(0);
 	}
-	mutex_unlock(&gate_mutex);		
+	mutex_unlock(&gate_mutex);
 //	if(s->device_type == AML_AUDIO_SPDIFOUT)
-//		WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);			
+//		WRITE_MPEG_REG_BITS( HHI_MPLL_CNTL8, 0,14, 1);
 #if USE_HRTIMER == 0
 	del_timer_sync(&prtd->timer);
 #else
@@ -605,7 +612,7 @@ static int aml_i2s_copy_playback(struct snd_pcm_runtime *runtime, int channel,
         if(pos % align){
           printk("audio data unaligned: pos=%d, n=%d, align=%d\n", (int)pos, n, align);
         }
-		
+
 		if(runtime->channels == 8){
 			int32_t *lf, *cf, *rf, *ls, *rs, *lef, *sbl, *sbr;
 			lf  = to;
@@ -668,9 +675,9 @@ static int aml_i2s_copy_capture(struct snd_pcm_runtime *runtime, int channel,
     int i = 0, j = 0;
     unsigned int t1, t2;
 	struct aml_runtime_data *prtd = runtime->private_data;
-	audio_stream_t *s = &prtd->s;	   
+	audio_stream_t *s = &prtd->s;
     char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos)*2;
-    unsigned char r_shift = 8;	
+    unsigned char r_shift = 8;
 	if(s->device_type == AML_AUDIO_SPDIFIN) //spdif in
     {
     	r_shift = 12;
@@ -766,7 +773,7 @@ static int aml_i2s_new(struct snd_soc_pcm_runtime *rtd)
 {
 	int ret = 0;
        struct snd_soc_card *card = rtd->card;
-       struct snd_pcm *pcm =rtd->pcm ;  
+       struct snd_pcm *pcm =rtd->pcm ;
     ALSA_TRACE();
 	if (!card->dev->dma_mask)
 		card->dev->dma_mask = &aml_i2s_dmamask;
@@ -810,6 +817,11 @@ static void aml_i2s_free_dma_buffers(struct snd_pcm *pcm)
 		dma_free_coherent(pcm->card->dev, buf->bytes,
 				  buf->area, buf->addr);
 		buf->area = NULL;
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+			aml_i2s_playback_start_addr = NULL;
+		}else{
+			aml_i2s_capture_start_addr = NULL;
+		}
 	}
 }
 
@@ -1093,7 +1105,7 @@ EXPORT_SYMBOL_GPL(aml_soc_platform);
 
 static int aml_soc_platform_probe(struct platform_device *pdev)
 {
-    ALSA_TRACE();	
+    ALSA_TRACE();
 	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
 }
 
diff --git a/sound/soc/codecs/tas5711.c b/sound/soc/codecs/tas5711.c
old mode 100644
new mode 100755
index a4f00851155f..fab4e8d47adf
--- a/sound/soc/codecs/tas5711.c
+++ b/sound/soc/codecs/tas5711.c
@@ -43,54 +43,52 @@ static const u8 tas5711_regs[DDX_NUM_BYTE_REG] = {
 	0x00, 0x30, 0x0F, 0x82, 0x02,
 };
 
-static u8 TAS5711_subwoofer_table[2][21]={
+static u8 TAS5711_subwoofer_table[2][20]={
 	//0x5A   150Hz-lowpass
-	{0x5A,
-	 0x00,0x00,0x03,0x1D,
+	{0x00,0x00,0x03,0x1D,
 	 0x00,0x00,0x06,0x3A,
 	 0x00,0x00,0x03,0x1D,
 	 0x00,0xFC,0x72,0x05,
 	 0x0F,0x83,0x81,0x85},
 	//0x5B   150HZ-10dB
-	{0x5B,
-	 0x00,0x81,0x50,0x89,
+	{0x00,0x81,0x50,0x89,
 	 0x0F,0x03,0x68,0x8C,
 	 0x00,0x7B,0x6A,0x2F,
 	 0x00,0xFC,0xA3,0x83,
 	 0x0F,0x83,0x51,0x56}
 };
-static u8 TAS5711_drc1_table[3][9]={
+static u8 TAS5711_drc1_table[3][8]={
 	//0x3A   drc1_ae
-	{0x3A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
 	//0x3B   drc1_aa
-	{0x3B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
 	//0x3C   drc1_ad
-	{0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
 };
-static u8 tas5711_drc1_tko_table[3][5]={
+static u8 tas5711_drc1_tko_table[3][4]={
 	//0x40   drc1_t
-	{0x40,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00},
 	//0x41   drc1_k
-	{0x41,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00},
 	//0x42   drc1_o
-	{0x42,0x00,0x00,0x00,0x00}
+	{0x00,0x00,0x00,0x00}
 };
 
-static u8 TAS5711_drc2_table[3][9]={
+static u8 TAS5711_drc2_table[3][8]={
 	//0x3D   drc2_ae
-	{0x3D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
 	//0x3E   drc2_aa
-	{0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
 	//0x3F   drc2_ad
-	{0x3D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
 };
-static u8 tas5711_drc2_tko_table[3][5]={
+static u8 tas5711_drc2_tko_table[3][4]={
 	//0x43   drc2_t
-	{0x43,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00},
 	//0x44   drc2_k
-	{0x44,0x00,0x00,0x00,0x00},
+	{0x00,0x00,0x00,0x00},
 	//0x45   drc2_o
-	{0x45,0x00,0x00,0x00,0x00}
+	{0x00,0x00,0x00,0x00}
 };
 
 /* codec private data */
@@ -144,7 +142,7 @@ static int tas5711_set_dai_fmt(struct snd_soc_dai *codec_dai,
 				  unsigned int fmt)
 {
 	//struct snd_soc_codec *codec = codec_dai->codec;
-	CODEC_DEBUG("~~~~%s\n", __func__);
+	CODEC_DEBUG("%s\n", __func__);
 
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
@@ -181,7 +179,7 @@ static int tas5711_hw_params(struct snd_pcm_substream *substream,
 	//struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	//struct snd_soc_codec *codec = rtd->codec;
 	unsigned int rate;
-	CODEC_DEBUG("~~~~%s\n", __func__);
+	CODEC_DEBUG("%s\n", __func__);
 
 	rate = params_rate(params);
 	pr_debug("rate: %u\n", rate);
@@ -260,11 +258,15 @@ static int tas5711_set_master_vol(struct snd_soc_codec *codec)
 
 	//using user BSP defined master vol config;
 	if(pdata && pdata->custom_master_vol) {
-		CODEC_DEBUG("tas5711_set_master_vol::using BSP defined master vol config\n");
+		CODEC_DEBUG("tas5711_set_master_vol::%d\n", pdata->custom_master_vol);
 		snd_soc_write(codec, DDX_MASTER_VOLUME, pdata->custom_master_vol);
 	}
-	else
-		snd_soc_write(codec, DDX_MASTER_VOLUME, 0x00);
+	else{
+		CODEC_DEBUG("%s failed:pdata = %x,pdata->custom_master_vol = %d\n",
+			__func__,pdata,pdata->custom_master_vol);
+		snd_soc_write(codec, DDX_MASTER_VOLUME, 0x30);
+	}
+
 	return 0;
 }
 static int tas5711_set_subwoofer(struct snd_soc_codec *codec)
@@ -279,10 +281,16 @@ static int tas5711_set_subwoofer(struct snd_soc_codec *codec)
 		CODEC_DEBUG("tas5711_set_subwoofer::using BSP defined subwoofer config\n");
 		for(i = 0;i < 2;i++)
 			for(j = 0;j < 20;j++)
-				TAS5711_subwoofer_table[i][j+1] = p[i*20 + j];
+				TAS5711_subwoofer_table[i][j] = p[i*20 + j];
+
+	}else{
+		CODEC_DEBUG("tas5711_set_subwoofer fail, pdata = %x, pdata->custom_sub_bq_table = %d\n",
+		pdata,pdata->custom_sub_bq_table);
+		return -1;
 	}
-	snd_soc_bulk_write_raw(codec, DDX_SUBCHANNEL_BQ_0, TAS5711_subwoofer_table[0], 21);
-	snd_soc_bulk_write_raw(codec, DDX_SUBCHANNEL_BQ_1, TAS5711_subwoofer_table[1], 21);
+
+	snd_soc_bulk_write_raw(codec, DDX_SUBCHANNEL_BQ_0, TAS5711_subwoofer_table[0], 20);
+	snd_soc_bulk_write_raw(codec, DDX_SUBCHANNEL_BQ_1, TAS5711_subwoofer_table[1], 20);
 	return 0;
 }
 //tas5711 DRC for channel L/R
@@ -298,18 +306,29 @@ static int tas5711_set_drc1(struct snd_soc_codec *codec)
 		CODEC_DEBUG("tas5711_set_drc1::using BSP defined drc1 config\n");
 		for(i = 0;i < 3;i++){
 			for(j = 0;j < 8;j++)
-				TAS5711_drc1_table[i][j+1] = p[i*8 + j];
-			snd_soc_bulk_write_raw(codec, DDX_DRC1_AE+i, TAS5711_drc1_table[i], 9);
+				TAS5711_drc1_table[i][j] = p[i*8 + j];
+
+			snd_soc_bulk_write_raw(codec, DDX_DRC1_AE+i, TAS5711_drc1_table[i], 8);
 		}
+	}else{
+		CODEC_DEBUG("tas5711_set_drc1 fail, pdata = %x, pdata->custom_drc1_table = %d\n",
+		pdata,pdata->custom_drc1_table);
+		return -1;
 	}
+
 	if(pdata && pdata->custom_drc1_tko_table && pdata->custom_drc1_tko_table_len == 12){
 		p = pdata->custom_drc1_tko_table;
 		CODEC_DEBUG("tas5711_set_drc1::using BSP defined drc1 TKO config\n");
 		for(i = 0;i < 3;i++){
 			for(j = 0;j < 4;j++)
-				tas5711_drc1_tko_table[i][j+1]= p[i*4 + j];
-			snd_soc_bulk_write_raw(codec, DDX_DRC1_T+i, tas5711_drc1_tko_table[i], 5);
+				tas5711_drc1_tko_table[i][j]= p[i*4 + j];
+
+			snd_soc_bulk_write_raw(codec, DDX_DRC1_T+i, tas5711_drc1_tko_table[i], 4);
 		}
+	}else{
+		CODEC_DEBUG("tas5711_set_drc1 fail, pdata = %x, pdata->custom_drc1_tko_table = %d\n",
+		pdata,pdata->custom_drc1_tko_table);
+		return -1;
 	}
 	return 0;
 }
@@ -326,19 +345,31 @@ static int tas5711_set_drc2(struct snd_soc_codec *codec)
 		CODEC_DEBUG("tas5711_set_drc2::using BSP defined drc2 config\n");
 		for(i = 0;i < 3;i++){
 			for(j = 0;j < 8;j++)
-				TAS5711_drc2_table[i][j+1] = p[i*8 + j];
-			snd_soc_bulk_write_raw(codec, DDX_DRC2_AE+i, TAS5711_drc2_table[i], 9);
+				TAS5711_drc2_table[i][j] = p[i*8 + j];
+
+			snd_soc_bulk_write_raw(codec, DDX_DRC2_AE+i, TAS5711_drc2_table[i], 8);
 		}
+	}else{
+		CODEC_DEBUG("tas5711_set_drc2 fail, pdata = %x, pdata->custom_drc2_table = %d\n",
+		pdata,pdata->custom_drc2_table);
+		return -1;
 	}
+
 	if(pdata && pdata->custom_drc2_tko_table && pdata->custom_drc2_tko_table_len == 12){
 		p = pdata->custom_drc2_tko_table;
 		CODEC_DEBUG("tas5711_set_drc2::using BSP defined drc2 TKO config\n");
 		for(i = 0;i < 3;i++){
 			for(j = 0;j < 4;j++)
-				tas5711_drc2_tko_table[i][j+1] = p[i*4 + j];
-			snd_soc_bulk_write_raw(codec, DDX_DRC2_T+i, tas5711_drc2_tko_table[i], 5);
+				tas5711_drc2_tko_table[i][j] = p[i*4 + j];
+
+			snd_soc_bulk_write_raw(codec, DDX_DRC2_T+i, tas5711_drc2_tko_table[i], 4);
 		}
+	}else{
+		CODEC_DEBUG("tas5711_set_drc2 fail, pdata = %x, pdata->custom_drc2_tko_table = %d\n",
+		pdata,pdata->custom_drc2_tko_table);
+		return -1;
 	}
+
 	return 0;
 }
 
@@ -346,7 +377,7 @@ static int tas5711_set_drc(struct snd_soc_codec *codec)
 {
 	struct tas5711_platform_data *pdata = dev_get_platdata(codec->dev);
 	char drc_mask = 0;
-	u8 tas5711_drc_ctl_table[] = {0x46,0x00,0x00,0x00,0x00};
+	u8 tas5711_drc_ctl_table[] = {0x00,0x00,0x00,0x00};
 	if(pdata && pdata->enable_ch1_drc){
 		drc_mask |= 0x01;
 		tas5711_set_drc1(codec);
@@ -355,8 +386,8 @@ static int tas5711_set_drc(struct snd_soc_codec *codec)
 		drc_mask |= 0x02;
 		tas5711_set_drc2(codec);
 	}
-	tas5711_drc_ctl_table[4] = drc_mask;
-	snd_soc_bulk_write_raw(codec, DDX_DRC_CTL, tas5711_drc_ctl_table, 5);
+	tas5711_drc_ctl_table[3] = drc_mask;
+	snd_soc_bulk_write_raw(codec, DDX_DRC_CTL, tas5711_drc_ctl_table, 4);
 	return 0;
 }
 
@@ -368,10 +399,16 @@ static int tas5711_set_eq_biquad(struct snd_soc_codec *codec)
 	u8 tas5711_bq_table[21];
 	struct tas5711_priv *tas5711 = snd_soc_codec_get_drvdata(codec);
 	struct tas5711_platform_data *pdata = tas5711->pdata;
-	struct tas5711_eq_cfg *cfg = pdata->eq_cfgs;
+	struct tas5711_eq_cfg *cfg;
+
+	if(!pdata)
+		return 0;
+
+	if(!(cfg = pdata->eq_cfgs))
+		return 0;
 
-	CODEC_DEBUG("tas5711_set_eq_biquad::using \
-		BSP defined EQ biquad config::%s\n", cfg[tas5711->eq_cfg].name);
+	CODEC_DEBUG("tas5711_set_eq_biquad::using BSP defined EQ biquad config::%s\n",
+										cfg[tas5711->eq_cfg].name);
 	p = cfg[tas5711->eq_cfg].regs;
 
 	for(i = 0;i < 2;i++){
@@ -380,13 +417,12 @@ static int tas5711_set_eq_biquad(struct snd_soc_codec *codec)
 				addr = (DDX_CH1_BQ_0 + i*7 + j);
 			else
 				addr = (DDX_CH1_BQ_7 + i*4 + j - 7);
-			tas5711_bq_table[0] = addr;
 			for(k = 0;k < 20;k++){
-				tas5711_bq_table[k+1]= p[i*9*20 + j*20 + k];
-				printk(KERN_DEBUG "[%d]=%#x\n",k,tas5711_bq_table[k+1]);
+				tas5711_bq_table[k]= p[i*9*20 + j*20 + k];
+				printk(KERN_DEBUG "[%d]=%#x\n",k,tas5711_bq_table[k]);
 			}
 			printk(KERN_DEBUG "\n");
-			snd_soc_bulk_write_raw(codec, addr, tas5711_bq_table, 21);
+			snd_soc_bulk_write_raw(codec, addr, tas5711_bq_table, 20);
 		}
 	}
 	return 0;
@@ -418,12 +454,13 @@ static int tas5711_get_eq_enum(struct snd_kcontrol *kcontrol,
 
 	return 0;
 }
+
 static int tas5711_set_eq(struct snd_soc_codec *codec)
 {
 	int i = 0, ret = 0;
 	struct tas5711_priv *tas5711 = snd_soc_codec_get_drvdata(codec);
 	struct tas5711_platform_data *pdata = tas5711->pdata;
-	u8 tas5711_eq_ctl_table[] = {0x50,0x00,0x00,0x00,0x80};
+	u8 tas5711_eq_ctl_table[] = {0x00,0x00,0x00,0x80};
 	struct tas5711_eq_cfg *cfg = pdata->eq_cfgs;
 
 	if(!pdata)
@@ -434,7 +471,7 @@ static int tas5711_set_eq(struct snd_soc_codec *codec)
 			SOC_ENUM_EXT("EQ Mode", tas5711->eq_conf_enum,
 					tas5711_get_eq_enum, tas5711_put_eq_enum);
 
-		tas5711->eq_conf_texts = kmalloc(sizeof(char *) * pdata->num_eq_cfgs, GFP_KERNEL);
+		tas5711->eq_conf_texts = kzalloc(sizeof(char *) * pdata->num_eq_cfgs, GFP_KERNEL);
 		if(!tas5711->eq_conf_texts){
 			dev_err(codec->dev,
 				"Fail to allocate %d EQ config tests\n",
@@ -455,9 +492,33 @@ static int tas5711_set_eq(struct snd_soc_codec *codec)
 
 	tas5711_set_eq_biquad(codec);
 
-	tas5711_eq_ctl_table[4] &= 0x7F;
+	tas5711_eq_ctl_table[3] &= 0x7F;
 	snd_soc_bulk_write_raw(codec, DDX_BANKSWITCH_AND_EQCTL,
-						tas5711_eq_ctl_table, 5);
+						tas5711_eq_ctl_table, 4);
+	return 0;
+}
+
+static int tas5711_customer_init(struct snd_soc_codec *codec)
+{
+    int i = 0;
+	char data[4];
+    struct tas5711_platform_data *pdata = dev_get_platdata(codec->dev);
+
+	if (pdata && pdata->init_regs) {
+		if(pdata->num_init_regs != 4){
+			printk("Error: num_init_regs = %d\n", pdata->num_init_regs);
+			return -1;
+		}
+		for (i = 0; i < pdata->num_init_regs; i++) {
+			data[i] = pdata->init_regs[i];
+		}
+	}else{
+		printk("%s fail: pdata = %x, pdata->init_regs = %d\n",
+					__func__,pdata,pdata->init_regs);
+		return -1;
+	}
+
+	snd_soc_bulk_write_raw(codec, data[0], data, 4);
 	return 0;
 }
 
@@ -488,7 +549,7 @@ static int init_reg_write(struct snd_soc_codec *codec, unsigned int reg, const v
     unsigned char data_buf[64] = { 0 };
     struct tas5711_platform_data *pdata = dev_get_platdata(codec->dev);
     struct tas57xx_reg_cfg *reg_cfgs = NULL;
-printk("5711 %s\n", __func__);
+	printk("5711 %s\n", __func__);
     tmp_index = getRegConfigDataIndex(codec, reg);
     if (tmp_index < 0) {
         if (len == 2) {
@@ -532,10 +593,10 @@ static int init_snd_soc_write(struct snd_soc_codec *codec, unsigned int reg, uns
 static int tas5711_init(struct snd_soc_codec *codec)
 {
 	int ret = 0;
-	unsigned char burst_data[][5]= {
-		{DDX_INPUT_MUX,0x00,0x01,0x77,0x72},
-		{DDX_CH4_SOURCE_SELECT,0x00,0x00,0x42,0x03},
-		{DDX_PWM_MUX,0x01,0x01,0x32,0x45},
+	unsigned char burst_data[][4]= {
+		{0x00,0x01,0x77,0x72},
+		{0x00,0x00,0x42,0x03},
+		{0x01,0x01,0x32,0x45},
 	};
 	struct tas5711_priv *tas5711 = snd_soc_codec_get_drvdata(codec);
 	struct tas5711_platform_data *pdata = tas5711->pdata;
@@ -553,9 +614,9 @@ static int tas5711_init(struct snd_soc_codec *codec)
 */
 	snd_soc_write(codec, DDX_BKND_ERR, 0x02);
 
-	snd_soc_bulk_write_raw(codec, DDX_INPUT_MUX, burst_data[0], 5);
-	snd_soc_bulk_write_raw(codec, DDX_CH4_SOURCE_SELECT, burst_data[1], 5);
-	snd_soc_bulk_write_raw(codec, DDX_PWM_MUX, burst_data[2], 5);
+	snd_soc_bulk_write_raw(codec, DDX_INPUT_MUX, burst_data[0], 4);
+	snd_soc_bulk_write_raw(codec, DDX_CH4_SOURCE_SELECT, burst_data[1], 4);
+	snd_soc_bulk_write_raw(codec, DDX_PWM_MUX, burst_data[2], 4);
 
 	//subwoofer
 	if((ret = tas5711_set_subwoofer(codec)) < 0)
@@ -564,8 +625,11 @@ static int tas5711_init(struct snd_soc_codec *codec)
 	if((ret = tas5711_set_drc(codec)) < 0)
 		CODEC_DEBUG("fail to set tas5711 drc\n");
 	//eq
-	//if((ret = tas5711_set_eq(codec)) < 0)
-	//	CODEC_DEBUG("fail to set tas5711 eq\n");
+	if((ret = tas5711_set_eq(codec)) < 0)
+		CODEC_DEBUG("fail to set tas5711 eq\n");
+	//init
+	if((ret = tas5711_customer_init(codec)) < 0)
+		CODEC_DEBUG("fail to set tas5711 customer init\n");
 
 	snd_soc_write(codec, DDX_VOLUME_CONFIG, 0xD1);
 	snd_soc_write(codec, DDX_SYS_CTL_2, 0x84);
@@ -614,7 +678,7 @@ static int tas5711_probe(struct snd_soc_codec *codec)
 
 static int tas5711_remove(struct snd_soc_codec *codec)
 {
-	CODEC_DEBUG("~~~~~~~~~~~~%s", __func__);
+	CODEC_DEBUG("%s \n", __func__);
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
     unregister_early_suspend(&early_suspend);
-- 
2.19.0

