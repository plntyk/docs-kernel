From 630d181f79716a73ad75fc01ddfe41c0b0514f17 Mon Sep 17 00:00:00 2001
From: "baoqi.wang" <baoqi.wang@amlogic.com>
Date: Mon, 24 Mar 2014 19:53:45 +0800
Subject: [PATCH 3868/5965] PD#89289 Migration of phy driver to the
 driver/amlogic/ethernet directory

Conflicts:

	arch/arm/configs/meson8_defconfig
---
 arch/arm/configs/meson8_defconfig          |   8 +-
 drivers/amlogic/ethernet/Kconfig           |   1 +
 drivers/amlogic/ethernet/Makefile          |   2 +-
 drivers/amlogic/ethernet/phy/Kconfig       |  36 ++
 drivers/amlogic/ethernet/phy/Makefile      |   7 +
 drivers/amlogic/ethernet/phy/am_internal.c | 315 ++++++++++++
 drivers/amlogic/ethernet/phy/am_ip101.c    | 346 +++++++++++++
 drivers/amlogic/ethernet/phy/am_micrel.c   | 538 +++++++++++++++++++++
 drivers/amlogic/ethernet/phy/am_smsc8720.c | 272 +++++++++++
 9 files changed, 1522 insertions(+), 3 deletions(-)
 create mode 100755 drivers/amlogic/ethernet/phy/Kconfig
 create mode 100755 drivers/amlogic/ethernet/phy/Makefile
 create mode 100755 drivers/amlogic/ethernet/phy/am_internal.c
 create mode 100644 drivers/amlogic/ethernet/phy/am_ip101.c
 create mode 100755 drivers/amlogic/ethernet/phy/am_micrel.c
 create mode 100644 drivers/amlogic/ethernet/phy/am_smsc8720.c

diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index 781f23f1e657..52a4edd90fba 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -203,6 +203,10 @@ CONFIG_AML_NEXT_GEN_NAND=y
 CONFIG_AML_NAND_KEY=y
 # CONFIG_AM_NAND is not set
 CONFIG_AM_ETHERNET=y
+CONFIG_AML_IP101_PHY=y
+CONFIG_AML_PHY=y
+CONFIG_AML_KSZ8091=y
+CONFIG_AML_LAN8720=y
 CONFIG_AM_WIFI=y
 CONFIG_AM_WIFI_SD_MMC=y
 CONFIG_AM_WIFI_USB=y
@@ -266,9 +270,9 @@ CONFIG_BLK_DEV_SR=y
 CONFIG_SCSI_MULTI_LUN=y
 CONFIG_NETDEVICES=y
 CONFIG_TUN=y
-CONFIG_SMSC_PHY=y
-CONFIG_ICPLUS_PHY=y
 CONFIG_MICREL_PHY=y
+#CONFIG_SMSC_PHY=y
+#CONFIG_ICPLUS_PHY=y
 CONFIG_PPP=y
 CONFIG_PPP_BSDCOMP=y
 CONFIG_PPP_DEFLATE=y
diff --git a/drivers/amlogic/ethernet/Kconfig b/drivers/amlogic/ethernet/Kconfig
index de1291243631..48500fcb568c 100755
--- a/drivers/amlogic/ethernet/Kconfig
+++ b/drivers/amlogic/ethernet/Kconfig
@@ -8,6 +8,7 @@ config AM_ETHERNET
 	select  NET
 	help
 		Depends on NET
+source "drivers/amlogic/ethernet/phy/Kconfig"
 	
 config AM_ETHERNET_DEBUG_LEVEL
 	int "Amloigc Ethetnet support"
diff --git a/drivers/amlogic/ethernet/Makefile b/drivers/amlogic/ethernet/Makefile
index f854e5ce7f18..6b981e1fa1fc 100755
--- a/drivers/amlogic/ethernet/Makefile
+++ b/drivers/amlogic/ethernet/Makefile
@@ -3,4 +3,4 @@
 #
 
 obj-$(CONFIG_AM_ETHERNET) += am_net8218.o
-
+obj-$(CONFIG_AM_ETHERNET) += phy/
diff --git a/drivers/amlogic/ethernet/phy/Kconfig b/drivers/amlogic/ethernet/phy/Kconfig
new file mode 100755
index 000000000000..ce899cdc3815
--- /dev/null
+++ b/drivers/amlogic/ethernet/phy/Kconfig
@@ -0,0 +1,36 @@
+#
+# PHY Layer Configuration
+#
+
+menuconfig PHYLIB
+	tristate "PHY Device support and infrastructure"
+	depends on NETDEVICES
+	help
+	  Ethernet controllers are usually attached to PHY
+	  devices.  This option provides infrastructure for
+	  managing PHY devices.
+
+if PHYLIB
+comment "MII PHY device drivers"
+config AML_PHY
+	tristate "Drivers for AMLOGIC PHY"
+	---help---
+	  Currently has a driver for the AMLOGIC INTERNAL PHY
+
+config AML_LAN8720
+	tristate "Drivers for SMSC LAN8720 PHYs"
+	---help---
+	  Currently supports the LAN83C185, LAN8187 and LAN8700 PHYs
+
+config AML_IP101_PHY
+	tristate "Drivers for ICPlus IP101GR PHYs"
+	---help---
+	  Currently supports the IP175C and IP1001 PHYs.
+
+config AML_KSZ8091
+	tristate "Driver for Micrel KSZ8091 PHYs"
+	---help---
+	  Supports the KSZ9021, VSC8201, KS8001 PHYs.
+
+endif # PHYLIB
+
diff --git a/drivers/amlogic/ethernet/phy/Makefile b/drivers/amlogic/ethernet/phy/Makefile
new file mode 100755
index 000000000000..5db8c30c4727
--- /dev/null
+++ b/drivers/amlogic/ethernet/phy/Makefile
@@ -0,0 +1,7 @@
+# Makefile for AMLOGIC PHY drivers
+
+
+obj-$(CONFIG_AML_IP101_PHY)	+= am_ip101.o
+obj-$(CONFIG_AML_PHY)		+= am_internal.o
+obj-$(CONFIG_AML_KSZ8091)	+= am_micrel.o
+obj-$(CONFIG_AML_LAN8720)	+= am_smsc8720.o
diff --git a/drivers/amlogic/ethernet/phy/am_internal.c b/drivers/amlogic/ethernet/phy/am_internal.c
new file mode 100755
index 000000000000..06b5ac9f393c
--- /dev/null
+++ b/drivers/amlogic/ethernet/phy/am_internal.c
@@ -0,0 +1,315 @@
+/*
+ * am_internal.c
+ *
+ * Driver for AMLOGIC PHY
+ *
+ * Author: Baoqi wang
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Support added for Amlogic Internal Phy by baoqi.wang@amlogic.com
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+#include <linux/netdevice.h>
+
+#define  SMI_ADDR_TSTCNTL     20
+#define  SMI_ADDR_TSTREAD1    21
+#define  SMI_ADDR_TSTREAD2    22
+#define  SMI_ADDR_TSTWRITE    23
+
+#define  WR_ADDR_A1CFG        0x12
+#define  WR_ADDR_A2CFG        0x13
+#define  WR_ADDR_A3CFG        0x14
+#define  WR_ADDR_A4CFG        0x15
+#define  WR_ADDR_A5CFG        0x16
+#define  WR_ADDR_A6CFG        0x17
+#define  WR_ADDR_A7CFG        0x18
+#define  WR_ADDR_A8CFG        0x1a
+#define  WR_ADDR_A9CFG        0x1b
+#define  WR_ADDR_A10CFG       0x1c
+#define  WR_ADDR_A11CFG       0x1d
+
+#define  RD_ADDR_A3CFG        (0x14 << 5)
+#define  RD_ADDR_A4CFG        (0x15 << 5)
+#define  RD_ADDR_A5CFG        (0x16 << 5)
+#define  RD_ADDR_A6CFG        (0x17 << 5)
+
+#define  TSTCNTL_RD           ((1 << 15) | (1 << 10))
+#define  TSTCNTL_WR           ((1 << 14) | (1 << 10))
+
+#define MII_INTERNAL_ISF 29 /* Interrupt Source Flags */
+#define MII_INTERNAL_IM  30 /* Interrupt Mask */
+#define MII_INTERNAL_CTRL_STATUS 17 /* Mode/Status Register */
+#define MII_INTERNAL_SPECIAL_MODES 18 /* Special Modes Register */
+
+#define MII_INTERNAL_ISF_INT1 (1<<1) /* Auto-Negotiation Page Received */
+#define MII_INTERNAL_ISF_INT2 (1<<2) /* Parallel Detection Fault */
+#define MII_INTERNAL_ISF_INT3 (1<<3) /* Auto-Negotiation LP Ack */
+#define MII_INTERNAL_ISF_INT4 (1<<4) /* Link Down */
+#define MII_INTERNAL_ISF_INT5 (1<<5) /* Remote Fault Detected */
+#define MII_INTERNAL_ISF_INT6 (1<<6) /* Auto-Negotiation complete */
+#define MII_INTERNAL_ISF_INT7 (1<<7) /* ENERGYON */
+
+#define MII_INTERNAL_ISF_INT_ALL (0x0e)
+
+#define MII_INTERNAL_ISF_INT_PHYLIB_EVENTS \
+	(MII_INTERNAL_ISF_INT6 | MII_INTERNAL_ISF_INT4 | \
+	 MII_INTERNAL_ISF_INT7)
+
+#define MII_INTERNAL_EDPWRDOWN (1 << 13) /* EDPWRDOWN */
+#define MII_INTERNAL_ENERGYON  (1 << 1)  /* ENERGYON */
+
+#define MII_INTERNAL_MODE_MASK      0xE0
+#define MII_INTERNAL_MODE_POWERDOWN 0xC0 /* Power Down mode */
+#define MII_INTERNAL_MODE_ALL       0xE0 /* All capable mode */
+static void initTSTMODE(struct phy_device *phydev)
+{
+	phy_write(phydev, SMI_ADDR_TSTCNTL, 0x0400);
+	phy_write(phydev, SMI_ADDR_TSTCNTL, 0x0000);
+	phy_write(phydev, SMI_ADDR_TSTCNTL, 0x0400);
+
+}
+
+static void closeTSTMODE(struct phy_device *phydev)
+{
+	phy_write(phydev, SMI_ADDR_TSTCNTL, 0x0000);
+
+}
+
+
+static void init_internal_phy(struct phy_device *phydev)
+{
+	initTSTMODE(phydev);
+	// write tstcntl addr val
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x1354);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR);//write addr 0
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x3e01);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A2CFG);//write addr 0x13
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x8900);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A3CFG);//write addr 0x14
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x3412);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A4CFG);//write addr 0x15
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x2636);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A5CFG);//write addr 0x16
+	phy_write(phydev,SMI_ADDR_TSTWRITE,3);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A7CFG);//write addr 0x18
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x108);
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A9CFG);//write addr 0x1b
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0xda00);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A11CFG);//write addr 0x1d
+	closeTSTMODE(phydev);
+}
+
+
+void init_internal_phy_10B(struct phy_device *phydev)
+{
+
+	initTSTMODE(phydev);
+	// write tstcntl addr val
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x0000);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR);//write addr 0
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x3e01);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A2CFG);//write addr 0x13
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x8900);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A3CFG);//write addr 0x14
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x3412);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A4CFG);//write addr 0x15
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x2236);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A5CFG);//write addr 0x16
+	phy_write(phydev,SMI_ADDR_TSTWRITE,3);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A7CFG);//write addr 0x18
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x108);//write val by chandle (2)
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A9CFG);//write addr 0x1b
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0xda06);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A11CFG);//write addr 0x1d
+	closeTSTMODE(phydev);
+}
+
+void init_internal_phy_100B(struct phy_device *phydev)
+{
+
+	initTSTMODE(phydev);
+	// write tstcntl addr val
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x9354);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|0x00);//write addr 0x00
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x3e00);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A2CFG);//write addr 0x13
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x8900);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A3CFG);//write addr 0x14
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x3412);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A4CFG);//write addr 0x15
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0xa406);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A5CFG);//write addr 0x16
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x0003);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A7CFG);//write addr 0x18
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0x00a6);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A9CFG);//write addr 0x1b
+	phy_write(phydev,SMI_ADDR_TSTWRITE,0xda06);//write val
+	phy_write(phydev,SMI_ADDR_TSTCNTL,TSTCNTL_WR|WR_ADDR_A11CFG);//write addr 0x1d
+	closeTSTMODE(phydev);
+}
+
+static int amlogic_phy_config_intr(struct phy_device *phydev)
+{
+	int rc = phy_write (phydev, MII_INTERNAL_IM,
+			((PHY_INTERRUPT_ENABLED == phydev->interrupts)
+			 ? MII_INTERNAL_ISF_INT_PHYLIB_EVENTS
+			 : 0));
+
+	return rc < 0 ? rc : 0;
+}
+
+static int amlogic_phy_ack_interrupt(struct phy_device *phydev)
+{
+	int rc = phy_read (phydev, MII_INTERNAL_ISF);
+
+	return rc < 0 ? rc : 0;
+}
+
+static int amlogic_phy_config_init(struct phy_device *phydev)
+{
+	int rc = phy_read(phydev, MII_INTERNAL_SPECIAL_MODES);
+	if (rc < 0)
+		return rc;
+	init_internal_phy(phydev);
+	/* If the AML PHY is in power down mode, then set it
+	 * in all capable mode before using it.
+	 */
+	if ((rc & MII_INTERNAL_MODE_MASK) == MII_INTERNAL_MODE_POWERDOWN) {
+		int timeout = 50000;
+
+		/* set "all capable" mode and reset the phy */
+		rc |= MII_INTERNAL_MODE_ALL;
+		phy_write(phydev, MII_INTERNAL_SPECIAL_MODES, rc);
+		phy_write(phydev, MII_BMCR, BMCR_RESET);
+
+		/* wait end of reset (max 500 ms) */
+		do {
+			udelay(10);
+			if (timeout-- == 0)
+				return -1;
+			rc = phy_read(phydev, MII_BMCR);
+		} while (rc & BMCR_RESET);
+	}
+	/*
+	   rc = phy_read(phydev, MII_INTERNAL_CTRL_STATUS);
+	   if (rc < 0)
+	   return rc;
+
+	// Enable energy detect mode for this AML Transceivers 
+	rc = phy_write(phydev, MII_INTERNAL_CTRL_STATUS,
+	rc | MII_INTERNAL_EDPWRDOWN);
+	if (rc < 0)
+	return rc;
+	 */
+	return amlogic_phy_ack_interrupt (phydev);
+}
+
+/*
+ * This workaround will manually toggle the PHY on/off upon calls to read_status
+ * in order to generate link test pulses if the link is down.  If a link partner
+ * is present, it will respond to the pulses, which will cause the ENERGYON bit
+ * to be set and will cause the EDPD mode to be exited.
+ */
+static int internal_read_status(struct phy_device *phydev)
+{
+	int err = genphy_read_status(phydev);
+	if(phydev->speed == SPEED_10){
+		init_internal_phy_10B(phydev);
+	}
+	if(phydev->speed == SPEED_100){
+		init_internal_phy_100B(phydev);
+	}
+	if (!phydev->link) {
+		/* Disable EDPD to wake up PHY */
+		int rc = phy_read(phydev, MII_INTERNAL_CTRL_STATUS);
+		if (rc < 0)
+			return rc;
+
+		rc = phy_write(phydev, MII_INTERNAL_CTRL_STATUS,
+				rc & ~MII_INTERNAL_EDPWRDOWN);
+		if (rc < 0)
+			return rc;
+
+		/* Sleep 64 ms to allow ~5 link test pulses to be sent */
+		msleep(64);
+
+		/* Re-enable EDPD */
+		rc = phy_read(phydev, MII_INTERNAL_CTRL_STATUS);
+		if (rc < 0)
+			return rc;
+
+		rc = phy_write(phydev, MII_INTERNAL_CTRL_STATUS,
+				rc | MII_INTERNAL_EDPWRDOWN);
+		if (rc < 0)
+			return rc;
+	}
+
+	return err;
+}
+
+
+int amlogic_phy_config_aneg(struct phy_device *phydev){
+
+	genphy_config_aneg(phydev);
+}
+static struct phy_driver amlogic_phy_driver[] = {
+	{
+		.phy_id		= 0x79898963,
+		.phy_id_mask	= 0xffffffff,
+		.name		= "AMLOGIC internal phy",
+
+		.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
+				| SUPPORTED_Asym_Pause),
+		.flags		= PHY_HAS_INTERRUPT | PHY_HAS_MAGICANEG,
+
+		/* basic functions */
+		.config_aneg	= &amlogic_phy_config_aneg,
+		.read_status	= &internal_read_status,
+		.config_init	= &amlogic_phy_config_init,
+
+		/* IRQ related */
+		.ack_interrupt	= &amlogic_phy_ack_interrupt,
+		.config_intr	= &amlogic_phy_config_intr,
+
+		.suspend	= genphy_suspend,
+		.resume		= genphy_resume,
+
+		.driver		= { .owner = THIS_MODULE, }
+	} };
+
+static int __init amlogic_init(void)
+{
+	return phy_drivers_register(amlogic_phy_driver,
+			ARRAY_SIZE(amlogic_phy_driver));
+}
+
+static void __exit amlogic_exit(void)
+{
+	return phy_drivers_unregister(amlogic_phy_driver,
+			ARRAY_SIZE(amlogic_phy_driver));
+}
+
+MODULE_DESCRIPTION("Amlogic PHY driver");
+MODULE_AUTHOR("Baoqi wang");
+MODULE_LICENSE("GPL");
+
+module_init(amlogic_init);
+module_exit(amlogic_exit);
+
+static struct mdio_device_id __maybe_unused amlogic_tbl[] = {
+	{ 0x79898963, 0xffffffff },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(mdio, amlogic_tbl);
diff --git a/drivers/amlogic/ethernet/phy/am_ip101.c b/drivers/amlogic/ethernet/phy/am_ip101.c
new file mode 100644
index 000000000000..1ccfebb0bf3c
--- /dev/null
+++ b/drivers/amlogic/ethernet/phy/am_ip101.c
@@ -0,0 +1,346 @@
+/*
+ * Driver for ICPlus PHYs
+ *
+ * Copyright (c) 2007 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ * Support ip101GR by baoqi.wang@amlogic.com
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+MODULE_DESCRIPTION("ICPlus IP175C/IP101A/IP101G/IC1001 PHY drivers");
+MODULE_AUTHOR("Michael Barkowski");
+MODULE_LICENSE("GPL");
+
+/* IP101A/G - IP1001 */
+#define IP10XX_SPEC_CTRL_STATUS		16	/* Spec. Control Register */
+#define IP1001_RXPHASE_SEL		(1<<0)	/* Add delay on RX_CLK */
+#define IP1001_TXPHASE_SEL		(1<<1)	/* Add delay on TX_CLK */
+#define IP1001_SPEC_CTRL_STATUS_2	20	/* IP1001 Spec. Control Reg 2 */
+#define IP1001_APS_ON			11	/* IP1001 APS Mode  bit */
+#define IP101A_G_APS_ON			2	/* IP101A/G APS Mode bit */
+#define IP101A_G_IRQ_CONF_STATUS	0x11	/* Conf Info IRQ & Status Reg */
+#define	IP101A_G_IRQ_PIN_USED		(1<<15) /* INTR pin used */
+#define	IP101A_G_IRQ_DEFAULT		IP101A_G_IRQ_PIN_USED
+
+#define IP101G_PAGE_SEL			0x14
+#define IP101G_PAGE_16			0x10
+#define IP101G_SPEC_CTRL_STATUS		0x10
+#define IP101G_ANALOG_OFF		0x0001
+#define IP101G_MMD_CTRL			0x0d
+#define IP101G_MMD_DATA			0x0e
+#define IP101G_DIO_PIN_DCR			0x1a
+#define OFF 1
+#define ON  0
+static void off_analog(struct phy_device *phydev, int off)
+{
+	int ana;
+
+	phy_write(phydev, IP101G_PAGE_SEL, IP101G_PAGE_16);
+	ana = phy_read(phydev, IP101G_SPEC_CTRL_STATUS);
+	if (off)
+		phy_write(phydev, IP101G_SPEC_CTRL_STATUS, (ana | IP101G_ANALOG_OFF));
+	else
+		phy_write(phydev, IP101G_SPEC_CTRL_STATUS, (ana & ~IP101G_ANALOG_OFF));
+}
+static int ip175c_config_init(struct phy_device *phydev)
+{
+	int err, i;
+	static int full_reset_performed = 0;
+	if (full_reset_performed == 0) {
+
+		/* master reset */
+		err = mdiobus_write(phydev->bus, 30, 0, 0x175c);
+		if (err < 0)
+			return err;
+
+		/* ensure no bus delays overlap reset period */
+		err = mdiobus_read(phydev->bus, 30, 0);
+
+		/* data sheet specifies reset period is 2 msec */
+		mdelay(2);
+
+		/* enable IP175C mode */
+		err = mdiobus_write(phydev->bus, 29, 31, 0x175c);
+		if (err < 0)
+			return err;
+
+		/* Set MII0 speed and duplex (in PHY mode) */
+		err = mdiobus_write(phydev->bus, 29, 22, 0x420);
+		if (err < 0)
+			return err;
+
+		/* reset switch ports */
+		for (i = 0; i < 5; i++) {
+			err = mdiobus_write(phydev->bus, i,
+					    MII_BMCR, BMCR_RESET);
+			if (err < 0)
+				return err;
+		}
+
+		for (i = 0; i < 5; i++)
+			err = mdiobus_read(phydev->bus, i, MII_BMCR);
+
+		mdelay(2);
+
+		full_reset_performed = 1;
+	}
+
+	if (phydev->addr != 4) {
+		phydev->state = PHY_RUNNING;
+		phydev->speed = SPEED_100;
+		phydev->duplex = DUPLEX_FULL;
+		phydev->link = 1;
+		netif_carrier_on(phydev->attached_dev);
+	}
+
+	return 0;
+}
+
+static int ip1xx_reset(struct phy_device *phydev)
+{
+	int bmcr;
+
+	/* Software Reset PHY */
+	bmcr = phy_read(phydev, MII_BMCR);
+	if (bmcr < 0)
+		return bmcr;
+	bmcr |= BMCR_RESET;
+	bmcr = phy_write(phydev, MII_BMCR, bmcr);
+	if (bmcr < 0)
+		return bmcr;
+
+	do {
+		bmcr = phy_read(phydev, MII_BMCR);
+		if (bmcr < 0)
+			return bmcr;
+	} while (bmcr & BMCR_RESET);
+
+	return 0;
+}
+
+static int ip101gr_reset(struct phy_device *phydev)
+{
+	int bmcr;
+
+	/* Software Reset PHY */
+	bmcr = phy_read(phydev, MII_BMCR);
+	if (bmcr < 0)
+		return bmcr;
+	bmcr |= BMCR_RESET;
+	bmcr = phy_write(phydev, MII_BMCR, bmcr);
+	if (bmcr < 0)
+		return bmcr;
+
+	do {
+		bmcr = phy_read(phydev, MII_BMCR);
+		if (bmcr < 0)
+			return bmcr;
+	} while (bmcr & BMCR_RESET);
+
+	phy_write(phydev, IP101G_MMD_CTRL, 0x7);
+
+	phy_write(phydev, IP101G_MMD_DATA, 0x3c);
+
+	phy_write(phydev, IP101G_MMD_CTRL, 0x4007);
+
+	phy_write(phydev, IP101G_MMD_DATA, 0x0);
+
+	phy_write(phydev, IP101G_DIO_PIN_DCR, 0x2252);
+	return 0;
+}
+
+static int ip1001_config_init(struct phy_device *phydev)
+{
+	int c;
+
+	c = ip1xx_reset(phydev);
+	if (c < 0)
+		return c;
+
+	/* Enable Auto Power Saving mode */
+	c = phy_read(phydev, IP1001_SPEC_CTRL_STATUS_2);
+	if (c < 0)
+		return c;
+	c |= IP1001_APS_ON;
+	c = phy_write(phydev, IP1001_SPEC_CTRL_STATUS_2, c);
+	if (c < 0)
+		return c;
+
+	if ((phydev->interface == PHY_INTERFACE_MODE_RGMII) ||
+	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) ||
+	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) ||
+	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)) {
+
+		c = phy_read(phydev, IP10XX_SPEC_CTRL_STATUS);
+		if (c < 0)
+			return c;
+
+		c &= ~(IP1001_RXPHASE_SEL | IP1001_TXPHASE_SEL);
+
+		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)
+			c |= (IP1001_RXPHASE_SEL | IP1001_TXPHASE_SEL);
+		else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)
+			c |= IP1001_RXPHASE_SEL;
+		else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)
+			c |= IP1001_TXPHASE_SEL;
+
+		c = phy_write(phydev, IP10XX_SPEC_CTRL_STATUS, c);
+		if (c < 0)
+			return c;
+	}
+
+	return 0;
+}
+
+static int ip101a_g_config_init(struct phy_device *phydev)
+{
+	int c;
+
+	c = ip101gr_reset(phydev);
+	if (c < 0)
+		return c;
+
+	/* INTR pin used: speed/link/duplex will cause an interrupt */
+	c = phy_write(phydev, IP101A_G_IRQ_CONF_STATUS, IP101A_G_IRQ_DEFAULT);
+	if (c < 0)
+		return c;
+
+	/* Enable Auto Power Saving mode */
+	c = phy_read(phydev, IP10XX_SPEC_CTRL_STATUS);
+	c |= IP101A_G_APS_ON;
+
+	return phy_write(phydev, IP10XX_SPEC_CTRL_STATUS, c);
+}
+
+static int ip175c_read_status(struct phy_device *phydev)
+{
+	if (phydev->addr == 4) /* WAN port */
+		genphy_read_status(phydev);
+	else
+		/* Don't need to read status for switch ports */
+		phydev->irq = PHY_IGNORE_INTERRUPT;
+
+	return 0;
+}
+
+static int ip175c_config_aneg(struct phy_device *phydev)
+{
+	if (phydev->addr == 4) /* WAN port */
+		genphy_config_aneg(phydev);
+
+	return 0;
+}
+
+static int ip101a_g_ack_interrupt(struct phy_device *phydev)
+{
+	int err = phy_read(phydev, IP101A_G_IRQ_CONF_STATUS);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+static int ip101a_g_genphy_suspend(struct phy_device *phydev)
+{
+	printk("**************ip101 sd*****************\n");
+	int value;
+	off_analog(phydev, OFF);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, (value | BMCR_PDOWN));
+	return 0;
+}
+static int ip101a_g_genphy_resume(struct phy_device *phydev)
+{
+	printk("**************ip101 re*****************\n");
+	int value;
+	off_analog(phydev, ON);
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, (value & ~BMCR_PDOWN));
+	return 0;
+
+}
+static struct phy_driver icplus_driver[] = {
+{
+	.phy_id		= 0x02430d80,
+	.name		= "ICPlus IP175C",
+	.phy_id_mask	= 0x0ffffff0,
+	.features	= PHY_BASIC_FEATURES,
+	.config_init	= &ip175c_config_init,
+	.config_aneg	= &ip175c_config_aneg,
+	.read_status	= &ip175c_read_status,
+	.suspend	= genphy_suspend,
+	.resume		= genphy_resume,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= 0x02430d90,
+	.name		= "ICPlus IP1001",
+	.phy_id_mask	= 0x0ffffff0,
+	.features	= PHY_GBIT_FEATURES | SUPPORTED_Pause |
+			  SUPPORTED_Asym_Pause,
+	.config_init	= &ip1001_config_init,
+	.config_aneg	= &genphy_config_aneg,
+	.read_status	= &genphy_read_status,
+	.suspend	= genphy_suspend,
+	.resume		= genphy_resume,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= 0x02430c54,
+	.name		= "ICPlus IP101A/G",
+	.phy_id_mask	= 0x0ffffff0,
+	.features	= PHY_BASIC_FEATURES | SUPPORTED_Pause |
+			  SUPPORTED_Asym_Pause,
+	.flags		= PHY_HAS_INTERRUPT,
+	.ack_interrupt	= ip101a_g_ack_interrupt,
+	.config_init	= &ip101a_g_config_init,
+	.config_aneg	= &genphy_config_aneg,
+	.read_status	= &genphy_read_status,
+	.suspend	= &ip101a_g_genphy_suspend,
+	.resume		= &ip101a_g_genphy_resume,
+	.driver		= { .owner = THIS_MODULE,},
+} };
+
+static int __init icplus_init(void)
+{
+	return phy_drivers_register(icplus_driver,
+		ARRAY_SIZE(icplus_driver));
+}
+
+static void __exit icplus_exit(void)
+{
+	phy_drivers_unregister(icplus_driver,
+		ARRAY_SIZE(icplus_driver));
+}
+
+module_init(icplus_init);
+module_exit(icplus_exit);
+
+static struct mdio_device_id __maybe_unused icplus_tbl[] = {
+	{ 0x02430d80, 0x0ffffff0 },
+	{ 0x02430d90, 0x0ffffff0 },
+	{ 0x02430c54, 0x0ffffff0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(mdio, icplus_tbl);
diff --git a/drivers/amlogic/ethernet/phy/am_micrel.c b/drivers/amlogic/ethernet/phy/am_micrel.c
new file mode 100755
index 000000000000..51b91c4a2916
--- /dev/null
+++ b/drivers/amlogic/ethernet/phy/am_micrel.c
@@ -0,0 +1,538 @@
+/*
+ * drivers/net/phy/micrel.c
+ *
+ * Driver for Micrel PHYs
+ *
+ * Author: David J. Choi
+ *
+ * Copyright (c) 2010-2013 Micrel, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Support : Micrel Phys:
+ *		Giga phys: ksz9021, ksz9031
+ *		100/10 Phys : ksz8001, ksz8721, ksz8737, ksz8041
+ *			   ksz8021, ksz8031, ksz8051,
+ *			   ksz8081, ksz8091,
+ *			   ksz8061,
+ *		Switch : ksz8873, ksz886x
+ * Support : KSZ8091 wol by baoqi.wang@amlogic.com
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/phy.h>
+#include <linux/micrel_phy.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+/* Operation Mode Strap Override */
+#define MII_KSZPHY_OMSO				0x16
+#define KSZPHY_OMSO_B_CAST_OFF			(1 << 9)
+#define KSZPHY_OMSO_RMII_OVERRIDE		(1 << 1)
+#define KSZPHY_OMSO_MII_OVERRIDE		(1 << 0)
+
+/* general Interrupt control/status reg in vendor specific block. */
+#define MII_KSZPHY_INTCS			0x1B
+#define	KSZPHY_INTCS_JABBER			(1 << 15)
+#define	KSZPHY_INTCS_RECEIVE_ERR		(1 << 14)
+#define	KSZPHY_INTCS_PAGE_RECEIVE		(1 << 13)
+#define	KSZPHY_INTCS_PARELLEL			(1 << 12)
+#define	KSZPHY_INTCS_LINK_PARTNER_ACK		(1 << 11)
+#define	KSZPHY_INTCS_LINK_DOWN			(1 << 10)
+#define	KSZPHY_INTCS_REMOTE_FAULT		(1 << 9)
+#define	KSZPHY_INTCS_LINK_UP			(1 << 8)
+#define	KSZPHY_INTCS_ALL			(KSZPHY_INTCS_LINK_UP |\
+						KSZPHY_INTCS_LINK_DOWN)
+
+/* general PHY control reg in vendor specific block. */
+#define	MII_KSZPHY_CTRL			0x1F
+/* bitmap of PHY register to set interrupt mode */
+#define KSZPHY_CTRL_INT_ACTIVE_HIGH		(1 << 9)
+#define KSZ9021_CTRL_INT_ACTIVE_HIGH		(1 << 14)
+#define KS8737_CTRL_INT_ACTIVE_HIGH		(1 << 14)
+#define KSZ8051_RMII_50MHZ_CLK			(1 << 7)
+
+static int ksz_config_flags(struct phy_device *phydev)
+{
+	int regval;
+
+	if (phydev->dev_flags & MICREL_PHY_50MHZ_CLK) {
+		regval = phy_read(phydev, MII_KSZPHY_CTRL);
+		regval |= KSZ8051_RMII_50MHZ_CLK;
+		return phy_write(phydev, MII_KSZPHY_CTRL, regval);
+	}
+	return 0;
+}
+
+static int kszphy_ack_interrupt(struct phy_device *phydev)
+{
+	/* bit[7..0] int status, which is a read and clear register. */
+	int rc;
+
+	rc = phy_read(phydev, MII_KSZPHY_INTCS);
+
+	return (rc < 0) ? rc : 0;
+}
+
+static int kszphy_set_interrupt(struct phy_device *phydev)
+{
+	int temp;
+	temp = (PHY_INTERRUPT_ENABLED == phydev->interrupts) ?
+		KSZPHY_INTCS_ALL : 0;
+	return phy_write(phydev, MII_KSZPHY_INTCS, temp);
+}
+
+static int kszphy_config_intr(struct phy_device *phydev)
+{
+	int temp, rc;
+
+	/* set the interrupt pin active low */
+	temp = phy_read(phydev, MII_KSZPHY_CTRL);
+	temp &= ~KSZPHY_CTRL_INT_ACTIVE_HIGH;
+	phy_write(phydev, MII_KSZPHY_CTRL, temp);
+	rc = kszphy_set_interrupt(phydev);
+	return rc < 0 ? rc : 0;
+}
+
+static int ksz9021_config_intr(struct phy_device *phydev)
+{
+	int temp, rc;
+
+	/* set the interrupt pin active low */
+	temp = phy_read(phydev, MII_KSZPHY_CTRL);
+	temp &= ~KSZ9021_CTRL_INT_ACTIVE_HIGH;
+	phy_write(phydev, MII_KSZPHY_CTRL, temp);
+	rc = kszphy_set_interrupt(phydev);
+	return rc < 0 ? rc : 0;
+}
+
+static int ks8737_config_intr(struct phy_device *phydev)
+{
+	int temp, rc;
+
+	/* set the interrupt pin active low */
+	temp = phy_read(phydev, MII_KSZPHY_CTRL);
+	temp &= ~KS8737_CTRL_INT_ACTIVE_HIGH;
+	phy_write(phydev, MII_KSZPHY_CTRL, temp);
+	rc = kszphy_set_interrupt(phydev);
+	return rc < 0 ? rc : 0;
+}
+
+static int kszphy_config_init(struct phy_device *phydev)
+{
+	int temp;
+	temp = phy_read(phydev, 0x16);
+	//phy_write(phydev, 0x16, ((temp|(1 << 1)) & ~(0x8020)));
+	phy_write(phydev, 0x16, 0x2);
+	temp = phy_read(phydev, 0x1f);// link speed 1f bit5 4 = 01
+	phy_write(phydev, 0x1f, (temp | 1 << 4));
+	return 0;
+}
+
+static int ksz8021_config_init(struct phy_device *phydev)
+{
+	int rc;
+	const u16 val = KSZPHY_OMSO_B_CAST_OFF | KSZPHY_OMSO_RMII_OVERRIDE;
+	phy_write(phydev, MII_KSZPHY_OMSO, val);
+	rc = ksz_config_flags(phydev);
+	return rc < 0 ? rc : 0;
+}
+
+static int ks8051_config_init(struct phy_device *phydev)
+{
+	int rc;
+
+	rc = ksz_config_flags(phydev);
+	return rc < 0 ? rc : 0;
+}
+
+#define KSZ8873MLL_GLOBAL_CONTROL_4	0x06
+#define KSZ8873MLL_GLOBAL_CONTROL_4_DUPLEX	(1 << 6)
+#define KSZ8873MLL_GLOBAL_CONTROL_4_SPEED	(1 << 4)
+int ksz8873mll_read_status(struct phy_device *phydev)
+{
+	int regval;
+
+	/* dummy read */
+	regval = phy_read(phydev, KSZ8873MLL_GLOBAL_CONTROL_4);
+
+	regval = phy_read(phydev, KSZ8873MLL_GLOBAL_CONTROL_4);
+
+	if (regval & KSZ8873MLL_GLOBAL_CONTROL_4_DUPLEX)
+		phydev->duplex = DUPLEX_HALF;
+	else
+		phydev->duplex = DUPLEX_FULL;
+
+	if (regval & KSZ8873MLL_GLOBAL_CONTROL_4_SPEED)
+		phydev->speed = SPEED_10;
+	else
+		phydev->speed = SPEED_100;
+
+	phydev->link = 1;
+	phydev->pause = phydev->asym_pause = 0;
+
+	return 0;
+}
+
+static int ksz8873mll_config_aneg(struct phy_device *phydev)
+{
+	return 0;
+}
+static int ksz8091_suspend(struct phy_device *phydev)
+{
+	int value;
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, (value | BMCR_PDOWN));
+	return 0;
+}
+
+
+static int KSZ8091_resume(struct phy_device *phydev)
+{
+	int value;
+	int i;
+	value = phy_read(phydev, MII_BMCR);
+	phy_write(phydev, MII_BMCR, (value & ~BMCR_PDOWN));
+		/* Software Reset 2 time PHY  */
+	for(i = 0; i < 2; i++)
+	{
+		value = phy_read(phydev, MII_BMCR);
+		value |= BMCR_RESET;
+		value = phy_write(phydev, MII_BMCR, value);
+	do {
+		value = phy_read(phydev, MII_BMCR);
+		if (value < 0)
+			return value;
+	} while (value & BMCR_RESET);
+	}
+	return 0;
+}
+
+
+#define KSZ8091_MMD_CTRL			       0x0d
+#define KSZ8091_MMD_REG_DATA			0x0e
+#define KSZ8091_WOL_C			              0x00
+#define KSZ8091_WOL_CPT0M0			0x01
+#define KSZ8091_WOL_CPT0M1			0x02
+#define KSZ8091_WOL_CPT0M2			0x03
+#define KSZ8091_WOL_CPT0M3			0x04
+#define KSZ8091_WOL_CPT0E0			0x05
+#define KSZ8091_WOL_CPT0E1			0x06
+#define KSZ8091_WOL_CPT0M3			0x04
+#define KSZ8091_WOL_CPT0M3			0x04
+#define KSZ8091_WOL_MACDA0			0x19
+#define KSZ8091_WOL_MACDA1			0x1a
+#define KSZ8091_WOL_MACDA2			0x1b
+#define KSZ8091_WOL_OMSO                         0x16
+
+static void ksz8091_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
+{
+	int err;
+	wol->supported = WAKE_MAGIC;
+	wol->wolopts = 0;
+		// write addr 1f reg 0 bit6 0  disable Magic
+	err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x1F);
+	err = phy_write(phydev, KSZ8091_MMD_REG_DATA, KSZ8091_WOL_C);// select reg 0
+	err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x801f); //read
+	if (phy_read(phydev,KSZ8091_MMD_REG_DATA ) & ( 1<<6))
+		wol->wolopts |= WAKE_MAGIC;
+}
+
+
+static int ksz8091_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
+{
+	int err, oldpage, temp;
+
+	oldpage = phy_read(phydev, KSZ8091_MMD_CTRL);
+/*
+Magic-packet detection is enabled by writing a 1 to MMD address 1Fh,register 0h, bit [6]
+ The MAC address (for the local MAC device) is written to and stored in MMD address 1Fh, registers 19h -1Bh
+The KSZ8091MNX/RNB does not generate the magic packet. The magic packet must be provided by the external system.
+*/
+	printk("wol->wolopts = %d\nWAKE_MAGIC = %d\n",wol->wolopts,WAKE_MAGIC);
+	int i = 0;
+	if (wol->wolopts & WAKE_MAGIC) {
+	temp =  phy_read(phydev, KSZ8091_WOL_OMSO);
+
+	phy_write(phydev, KSZ8091_WOL_OMSO,temp| 1<<15);
+		/* Explicitly switch to page 0x1F, just to be sure */
+	printk("wol->wolopts = %d\nWAKE_MAGIC = %d\n",wol->wolopts,WAKE_MAGIC);
+	for(i =0;i< 6;i++){
+		printk("phydev->attached_dev->dev_addr[%d] = %x \n ",i,phydev->attached_dev->dev_addr[i]);
+	}
+
+		/* Store the device address for the magic packet */
+	/***************************************KSZ8091_WOL_MACDA2************************************************************/
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x1F);
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA, KSZ8091_WOL_MACDA2);
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x401f); //write
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA, (phydev->attached_dev->dev_addr[5] ) << 8 |(phydev->attached_dev->dev_addr[4]));
+		if (err < 0)
+			return err;
+	/***************************************KSZ8091_WOL_MACDA1*********************************************/
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x1F);
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA, KSZ8091_WOL_MACDA1);
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x401f); //write
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA, (phydev->attached_dev->dev_addr[3] ) << 8 | (phydev->attached_dev->dev_addr[2]));
+		if (err < 0)
+			return err;
+	/***************************************KSZ8091_WOL_MACDA0*****************************************************/
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x1F);
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA, KSZ8091_WOL_MACDA0);// select reg 0
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x401f); //write
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA, (phydev->attached_dev->dev_addr[1] ) << 8 |(phydev->attached_dev->dev_addr[0]));
+		if (err < 0)
+			return err;
+	/**************************************************MACEND***************************************************/
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x1F);
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA, KSZ8091_WOL_C);// select reg 0
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x401f); //write
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA, 1<<6| 1<<14); //link down enable
+		if (err < 0)
+			return err;
+		/* Clear WOL status and enable magic packet matching */
+	} else {
+		// write addr 1f reg 0 bit6 0  disable Magic
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x1F);
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA, KSZ8091_WOL_C);// select reg 0
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_CTRL, 0x401f); //write
+		if (err < 0)
+			return err;
+		err = phy_write(phydev, KSZ8091_MMD_REG_DATA,  ~(1<<6)); //link down enable
+		if (err < 0)
+			return err;
+	temp =  phy_read(phydev, KSZ8091_WOL_OMSO);
+
+	phy_write(phydev, KSZ8091_WOL_OMSO,temp|~( 1<<15));
+	}
+
+
+	return 0;
+}
+static struct phy_driver ksphy_driver[] = {
+{
+	.phy_id		= PHY_ID_KS8737,
+	.phy_id_mask	= 0x00fffff0,
+	.name		= "Micrel KS8737",
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= ks8737_config_intr,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= PHY_ID_KSZ8021,
+	.phy_id_mask	= 0x00ffffff,
+	.name		= "Micrel KSZ8021 or KSZ8031",
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause |
+			   SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= ksz8021_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= kszphy_config_intr,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= PHY_ID_KSZ8031,
+	.phy_id_mask	= 0x00ffffff,
+	.name		= "Micrel KSZ8031",
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause |
+			   SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= ksz8021_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= kszphy_config_intr,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= PHY_ID_KSZ8041,
+	.phy_id_mask	= 0x00fffff0,
+	.name		= "Micrel KSZ8041",
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
+				| SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= kszphy_config_intr,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= PHY_ID_KSZ8051,
+	.phy_id_mask	= 0x00fffff0,
+	.name		= "Micrel KSZ8051",
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
+				| SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= ks8051_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= kszphy_config_intr,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= PHY_ID_KSZ8001,
+	.name		= "Micrel KSZ8001 or KS8721",
+	.phy_id_mask	= 0x00ffffff,
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= kszphy_config_intr,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= PHY_ID_KSZ8081,
+	.name		= "Micrel KSZ8081 or KSZ8091",
+	.phy_id_mask	= 0x00fffff0,
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= kszphy_config_intr,
+	.suspend   	= ksz8091_suspend,
+	.resume		= KSZ8091_resume,
+	.set_wol        = ksz8091_set_wol,
+	.get_wol         = ksz8091_get_wol,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= PHY_ID_KSZ8061,
+	.name		= "Micrel KSZ8061",
+	.phy_id_mask	= 0x00fffff0,
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= kszphy_config_intr,
+	.driver		= { .owner = THIS_MODULE,},
+}, {
+	.phy_id		= PHY_ID_KSZ9021,
+	.phy_id_mask	= 0x000ffffe,
+	.name		= "Micrel KSZ9021 Gigabit PHY",
+	.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= ksz9021_config_intr,
+	.driver		= { .owner = THIS_MODULE, },
+}, {
+	.phy_id		= PHY_ID_KSZ9031,
+	.phy_id_mask	= 0x00fffff0,
+	.name		= "Micrel KSZ9031 Gigabit PHY",
+	.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause
+				| SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= kszphy_ack_interrupt,
+	.config_intr	= ksz9021_config_intr,
+	.driver		= { .owner = THIS_MODULE, },
+}, {
+	.phy_id		= PHY_ID_KSZ8873MLL,
+	.phy_id_mask	= 0x00fffff0,
+	.name		= "Micrel KSZ8873MLL Switch",
+	.features	= (SUPPORTED_Pause | SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_MAGICANEG,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= ksz8873mll_config_aneg,
+	.read_status	= ksz8873mll_read_status,
+	.driver		= { .owner = THIS_MODULE, },
+}, {
+	.phy_id		= PHY_ID_KSZ886X,
+	.phy_id_mask	= 0x00fffff0,
+	.name		= "Micrel KSZ886X Switch",
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
+	.flags		= PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT,
+	.config_init	= kszphy_config_init,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.driver		= { .owner = THIS_MODULE, },
+} };
+
+static int __init ksphy_init(void)
+{
+	return phy_drivers_register(ksphy_driver,
+		ARRAY_SIZE(ksphy_driver));
+}
+
+static void __exit ksphy_exit(void)
+{
+	phy_drivers_unregister(ksphy_driver,
+		ARRAY_SIZE(ksphy_driver));
+}
+
+module_init(ksphy_init);
+module_exit(ksphy_exit);
+
+MODULE_DESCRIPTION("Micrel PHY driver");
+MODULE_AUTHOR("David J. Choi");
+MODULE_LICENSE("GPL");
+
+static struct mdio_device_id __maybe_unused micrel_tbl[] = {
+	{ PHY_ID_KSZ9021, 0x000ffffe },
+	{ PHY_ID_KSZ9031, 0x00fffff0 },
+	{ PHY_ID_KSZ8001, 0x00ffffff },
+	{ PHY_ID_KS8737, 0x00fffff0 },
+	{ PHY_ID_KSZ8021, 0x00ffffff },
+	{ PHY_ID_KSZ8031, 0x00ffffff },
+	{ PHY_ID_KSZ8041, 0x00fffff0 },
+	{ PHY_ID_KSZ8051, 0x00fffff0 },
+	{ PHY_ID_KSZ8061, 0x00fffff0 },
+	{ PHY_ID_KSZ8081, 0x00fffff0 },
+	{ PHY_ID_KSZ8873MLL, 0x00fffff0 },
+	{ PHY_ID_KSZ886X, 0x00fffff0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(mdio, micrel_tbl);
diff --git a/drivers/amlogic/ethernet/phy/am_smsc8720.c b/drivers/amlogic/ethernet/phy/am_smsc8720.c
new file mode 100644
index 000000000000..11f34813e23f
--- /dev/null
+++ b/drivers/amlogic/ethernet/phy/am_smsc8720.c
@@ -0,0 +1,272 @@
+/*
+ * drivers/net/phy/smsc.c
+ *
+ * Driver for SMSC PHYs
+ *
+ * Author: Herbert Valerio Riedel
+ *
+ * Copyright (c) 2006 Herbert Valerio Riedel <hvr@gnu.org>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Support added for SMSC LAN8187 and LAN8700 by steve.glendinning@shawell.net
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+#include <linux/netdevice.h>
+#include <linux/smscphy.h>
+
+static int smsc_phy_config_intr(struct phy_device *phydev)
+{
+	int rc = phy_write (phydev, MII_LAN83C185_IM,
+			((PHY_INTERRUPT_ENABLED == phydev->interrupts)
+			? MII_LAN83C185_ISF_INT_PHYLIB_EVENTS
+			: 0));
+
+	return rc < 0 ? rc : 0;
+}
+
+static int smsc_phy_ack_interrupt(struct phy_device *phydev)
+{
+	int rc = phy_read (phydev, MII_LAN83C185_ISF);
+
+	return rc < 0 ? rc : 0;
+}
+
+static int smsc_phy_config_init(struct phy_device *phydev)
+{
+	int rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);
+	if (rc < 0)
+		return rc;
+
+	/* If the SMSC PHY is in power down mode, then set it
+	 * in all capable mode before using it.
+	 */
+	if ((rc & MII_LAN83C185_MODE_MASK) == MII_LAN83C185_MODE_POWERDOWN) {
+		int timeout = 50000;
+
+		/* set "all capable" mode and reset the phy */
+		rc |= MII_LAN83C185_MODE_ALL;
+		phy_write(phydev, MII_LAN83C185_SPECIAL_MODES, rc);
+		phy_write(phydev, MII_BMCR, BMCR_RESET);
+
+		/* wait end of reset (max 500 ms) */
+		do {
+			udelay(10);
+			if (timeout-- == 0)
+				return -1;
+			rc = phy_read(phydev, MII_BMCR);
+		} while (rc & BMCR_RESET);
+	}
+
+	rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
+	if (rc < 0)
+		return rc;
+
+	/* Enable energy detect mode for this SMSC Transceivers */
+	rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
+		       rc | MII_LAN83C185_EDPWRDOWN);
+	if (rc < 0)
+		return rc;
+
+	return smsc_phy_ack_interrupt (phydev);
+}
+
+static int lan911x_config_init(struct phy_device *phydev)
+{
+	return smsc_phy_ack_interrupt(phydev);
+}
+
+/*
+ * The LAN8710/LAN8720 requires a minimum of 2 link pulses within 64ms of each
+ * other in order to set the ENERGYON bit and exit EDPD mode.  If a link partner
+ * does send the pulses within this interval, the PHY will remained powered
+ * down.
+ *
+ * This workaround will manually toggle the PHY on/off upon calls to read_status
+ * in order to generate link test pulses if the link is down.  If a link partner
+ * is present, it will respond to the pulses, which will cause the ENERGYON bit
+ * to be set and will cause the EDPD mode to be exited.
+ */
+static int lan87xx_read_status(struct phy_device *phydev)
+{
+	int err = genphy_read_status(phydev);
+
+	if (!phydev->link) {
+		/* Disable EDPD to wake up PHY */
+		int rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
+		if (rc < 0)
+			return rc;
+
+		rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
+			       rc & ~MII_LAN83C185_EDPWRDOWN);
+		if (rc < 0)
+			return rc;
+
+		/* Sleep 64 ms to allow ~5 link test pulses to be sent */
+		msleep(64);
+
+		/* Re-enable EDPD */
+		rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
+		if (rc < 0)
+			return rc;
+
+		rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
+			       rc | MII_LAN83C185_EDPWRDOWN);
+		if (rc < 0)
+			return rc;
+	}
+
+	return err;
+}
+
+static struct phy_driver smsc_phy_driver[] = {
+{
+	.phy_id		= 0x0007c0a0, /* OUI=0x00800f, Model#=0x0a */
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "SMSC LAN83C185",
+
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
+				| SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_INTERRUPT | PHY_HAS_MAGICANEG,
+
+	/* basic functions */
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.config_init	= smsc_phy_config_init,
+
+	/* IRQ related */
+	.ack_interrupt	= smsc_phy_ack_interrupt,
+	.config_intr	= smsc_phy_config_intr,
+
+	.suspend	= genphy_suspend,
+	.resume		= genphy_resume,
+
+	.driver		= { .owner = THIS_MODULE, }
+}, {
+	.phy_id		= 0x0007c0b0, /* OUI=0x00800f, Model#=0x0b */
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "SMSC LAN8187",
+
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
+				| SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_INTERRUPT | PHY_HAS_MAGICANEG,
+
+	/* basic functions */
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.config_init	= smsc_phy_config_init,
+
+	/* IRQ related */
+	.ack_interrupt	= smsc_phy_ack_interrupt,
+	.config_intr	= smsc_phy_config_intr,
+
+	.suspend	= genphy_suspend,
+	.resume		= genphy_resume,
+
+	.driver		= { .owner = THIS_MODULE, }
+}, {
+	.phy_id		= 0x0007c0c0, /* OUI=0x00800f, Model#=0x0c */
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "SMSC LAN8700",
+
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
+				| SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_INTERRUPT | PHY_HAS_MAGICANEG,
+
+	/* basic functions */
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.config_init	= smsc_phy_config_init,
+
+	/* IRQ related */
+	.ack_interrupt	= smsc_phy_ack_interrupt,
+	.config_intr	= smsc_phy_config_intr,
+
+	.suspend	= genphy_suspend,
+	.resume		= genphy_resume,
+
+	.driver		= { .owner = THIS_MODULE, }
+}, {
+	.phy_id		= 0x0007c0d0, /* OUI=0x00800f, Model#=0x0d */
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "SMSC LAN911x Internal PHY",
+
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
+				| SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_INTERRUPT | PHY_HAS_MAGICANEG,
+
+	/* basic functions */
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.config_init	= lan911x_config_init,
+
+	/* IRQ related */
+	.ack_interrupt	= smsc_phy_ack_interrupt,
+	.config_intr	= smsc_phy_config_intr,
+
+	.suspend	= genphy_suspend,
+	.resume		= genphy_resume,
+
+	.driver		= { .owner = THIS_MODULE, }
+}, {
+	.phy_id		= 0x0007c0f0, /* OUI=0x00800f, Model#=0x0f */
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "SMSC LAN8710/LAN8720",
+
+	.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause
+				| SUPPORTED_Asym_Pause),
+	.flags		= PHY_HAS_INTERRUPT | PHY_HAS_MAGICANEG,
+
+	/* basic functions */
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= lan87xx_read_status,
+	.config_init	= smsc_phy_config_init,
+
+	/* IRQ related */
+	.ack_interrupt	= smsc_phy_ack_interrupt,
+	.config_intr	= smsc_phy_config_intr,
+
+	.suspend	= genphy_suspend,
+	.resume		= genphy_resume,
+
+	.driver		= { .owner = THIS_MODULE, }
+} };
+
+static int __init smsc_init(void)
+{
+	return phy_drivers_register(smsc_phy_driver,
+		ARRAY_SIZE(smsc_phy_driver));
+}
+
+static void __exit smsc_exit(void)
+{
+	return phy_drivers_unregister(smsc_phy_driver,
+		ARRAY_SIZE(smsc_phy_driver));
+}
+
+MODULE_DESCRIPTION("SMSC PHY driver");
+MODULE_AUTHOR("Herbert Valerio Riedel");
+MODULE_LICENSE("GPL");
+
+module_init(smsc_init);
+module_exit(smsc_exit);
+
+static struct mdio_device_id __maybe_unused smsc_tbl[] = {
+	{ 0x0007c0a0, 0xfffffff0 },
+	{ 0x0007c0b0, 0xfffffff0 },
+	{ 0x0007c0c0, 0xfffffff0 },
+	{ 0x0007c0d0, 0xfffffff0 },
+	{ 0x0007c0f0, 0xfffffff0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(mdio, smsc_tbl);
-- 
2.19.0

