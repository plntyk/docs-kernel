From 044890cb87f94069ba53238fefeddc0054dbc72d Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Thu, 27 Mar 2014 10:30:22 +0800
Subject: [PATCH 3873/5965] PD#88515: optimize lcd mipi driver & extern driver

---
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |   57 +-
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |   57 +-
 arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd  |   82 +-
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |   64 +-
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |   83 +-
 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd  |   89 +-
 drivers/amlogic/display/vout/aml_lcd.dtd      |   88 +-
 drivers/amlogic/display/vout/edp_drv.c        |   21 +-
 drivers/amlogic/display/vout/edp_drv.h        |    1 +
 .../amlogic/display/vout/lcd_extern/Makefile  |    5 +-
 .../amlogic/display/vout/lcd_extern/aml.dtd   |   64 +-
 .../display/vout/lcd_extern/i2c_tc101.c       |  321 +++
 .../display/vout/lcd_extern/lcd_extern.c      |  243 +-
 .../display/vout/lcd_extern/mipi_LD070WX4.c   |  155 ++
 .../display/vout/lcd_extern/mipi_N070ICN.c    |  315 +++
 .../display/vout/lcd_extern/spi_LD070WS2.c    |  275 ++
 .../amlogic/display/vout/lcd_extern/tc101.c   |  211 --
 drivers/amlogic/display/vout/lcdoutc.c        | 2436 +++++++++--------
 drivers/amlogic/display/vout/mipi_dsi_util.c  | 2081 ++++++--------
 drivers/amlogic/display/vout/mipi_dsi_util.h  |  121 +-
 include/linux/amlogic/vout/aml_lcd_extern.h   |   41 +-
 include/linux/amlogic/vout/lcdoutc.h          |   60 +-
 22 files changed, 3812 insertions(+), 3058 deletions(-)
 create mode 100755 drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c
 create mode 100755 drivers/amlogic/display/vout/lcd_extern/mipi_LD070WX4.c
 create mode 100755 drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c
 create mode 100755 drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c
 delete mode 100755 drivers/amlogic/display/vout/lcd_extern/tc101.c

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index d86d4228fc97..3db3a84f04d3 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -1112,8 +1112,8 @@ sdio{
 //		period=<948 1140>;		/** horizontal period(htotal), vertical period(vtotal) */
 
 //		clock_hz_pol=<64843200 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-//		hsync_width_backporch=<64 56>;	/** hsync_width, hsync_backporch(include hsync_width) */
-//		vsync_width_backporch=<50 30>;	/** vsync_width, vsync_backporch(include vsync_width) */
+//		hsync_width_backporch=<64 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
+//		vsync_width_backporch=<50 80>;	/** vsync_width, vsync_backporch(include vsync_width) */
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 //        dsi_lane_num=<4>;/** mipi dsi data lane number */
@@ -1199,23 +1199,50 @@ sdio{
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 //	};
 
-//$$ DEVICE="lcd_extern"
+//******************************************************************************
+//lcd extern
+//Notice: only one dev support
+//******************************************************************************
+//$$ DEVICE = "lcd_extern_i2c_tc101"
 //$$ L2 PROP_STR = "status"
-	lcd_extern{
-		compatible = "amlogic,lcd_extern";
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_STR = "i2c_bus"
+	lcd_extern_i2c_tc101{
+		compatible = "amlogic,lcd_i2c_tc101";
+		dev_name ="lcd_i2c_tc101";
 		status = "disabled";
 
-//$$ DEVICE = "lcd_extern_tc101"
-//$$ L2 PROP_STR = "i2c_bus"
-//$$ L2 PROP_U32 = "reg"
+		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		i2c_address = <0x7e>; /** i2c address */
+		i2c_bus = "i2c_bus_a";
+	};
+
+//$$ DEVICE = "lcd_extern_spi_LD070WS2"
 //$$ L2 PROP_STR = "status"
-		lcd_extern_tc101{
-			dev_name ="lcd_tc101";
-			type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi */
-			address = <0x7e>;
-			i2c_bus = "i2c_bus_a";
-			status = "disabled";
-		};
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_U32 = "gpio_spi_cs"
+//$$ L2 PROP_U32 = "gpio_spi_clk"
+//$$ L2 PROP_U32 = "gpio_spi_data"
+	lcd_extern_spi_LD070WS2{
+		compatible = "amlogic,lcd_spi_LD070WS2";
+		dev_name ="lcd_spi_LD070WS2";
+		status = "disabled";
+
+		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		gpio_spi_cs="GPIODV_1";
+		gpio_spi_clk="GPIODV_16";
+		gpio_spi_data="GPIODV_17";
+	};
+
+//$$ DEVICE = "lcd_extern_mipi_LD070WX4"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_LD070WX4{
+		compatible = "amlogic,lcd_mipi_LD070WX4";
+		dev_name ="lcd_mipi_LD070WX4";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
 	};
 
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index 4aecf92b1b49..6682277fa656 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -1122,8 +1122,8 @@ sdio{
 //		period=<948 1140>;		/** horizontal period(htotal), vertical period(vtotal) */
 
 //		clock_hz_pol=<64843200 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-//		hsync_width_backporch=<64 56>;	/** hsync_width, hsync_backporch(include hsync_width) */
-//		vsync_width_backporch=<50 30>;	/** vsync_width, vsync_backporch(include vsync_width) */
+//		hsync_width_backporch=<64 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
+//		vsync_width_backporch=<50 80>;	/** vsync_width, vsync_backporch(include vsync_width) */
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 //        dsi_lane_num=<4>;/** mipi dsi data lane number */
@@ -1209,23 +1209,50 @@ sdio{
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 //	};
 
-//$$ DEVICE="lcd_extern"
+//******************************************************************************
+//lcd extern
+//Notice: only one dev support
+//******************************************************************************
+//$$ DEVICE = "lcd_extern_i2c_tc101"
 //$$ L2 PROP_STR = "status"
-	lcd_extern{
-		compatible = "amlogic,lcd_extern";
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_STR = "i2c_bus"
+	lcd_extern_i2c_tc101{
+		compatible = "amlogic,lcd_i2c_tc101";
+		dev_name ="lcd_i2c_tc101";
 		status = "disabled";
 
-//$$ DEVICE = "lcd_extern_tc101"
-//$$ L2 PROP_STR = "i2c_bus"
-//$$ L2 PROP_U32 = "reg"
+		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		i2c_address = <0x7e>; /** i2c address */
+		i2c_bus = "i2c_bus_a";
+	};
+
+//$$ DEVICE = "lcd_extern_spi_LD070WS2"
 //$$ L2 PROP_STR = "status"
-		lcd_extern_tc101{
-			dev_name ="lcd_tc101";
-			type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi */
-			address = <0x7e>;
-			i2c_bus = "i2c_bus_a";
-			status = "disabled";
-		};
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_U32 = "gpio_spi_cs"
+//$$ L2 PROP_U32 = "gpio_spi_clk"
+//$$ L2 PROP_U32 = "gpio_spi_data"
+	lcd_extern_spi_LD070WS2{
+		compatible = "amlogic,lcd_spi_LD070WS2";
+		dev_name ="lcd_spi_LD070WS2";
+		status = "disabled";
+
+		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		gpio_spi_cs="GPIODV_1";
+		gpio_spi_clk="GPIODV_16";
+		gpio_spi_data="GPIODV_17";
+	};
+
+//$$ DEVICE = "lcd_extern_mipi_LD070WX4"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_LD070WX4{
+		compatible = "amlogic,lcd_mipi_LD070WX4";
+		dev_name ="lcd_mipi_LD070WX4";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
 	};
 
 /// ***************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
index add5b1395d07..3e26c5773e92 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
@@ -1090,9 +1090,9 @@ sdio{
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
-//$$ L2 PROP_U32 = "dsi_transfer_mode"
-//$$ L2 PROP_U32 18 = "dsi_power_on_cmd"
+//$$ L2 PROP_U32 = "dsi_operation_mode"
 //$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
+//$$ L2 PROP_U32 2 = "dsi_on_off_init"
 //lcd_LD070WX4:lcd_LD070WX4{
 //		model_name="LD070WX4";	/** lcd model name */
 //		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1110,21 +1110,11 @@ sdio{
 
 //        dsi_lane_num=<4>;/** mipi dsi data lane number */
 //        dsi_bit_rate_min_max=<400 500>;/** range of mipi dsi data lane bit rate(unit: MHz) */
-//        dsi_transfer_mode=<0>;/** mipi dsi transfer mode: (0=command mode, 1=video mode) */
-//        dsi_power_on_cmd =< 0x01  0x0
-//                            0xFF  0x20
-//                            0xAE  0x0B 
-//                            0xEE  0xEA 
-//                            0xEF  0x5F 
-//                            0xF2  0x68 
-//                            0xEE  0x0 
-//                            0xEF  0x0 
-//                            0xFF  0xFF
-//                          >;/** special power on command, 2 data is a pair(reg, value), if the first valu is 0xff, second value is delay time(unit: ms), ending flag is 0xff,0xff.*/
+//        dsi_operation_mode=<0>;/** mipi dsi init operation mode: (0=video mode, 1=command mode), default is 1 */
 //        dsi_sleep_out_display_on_delay=<200 100>; /** mipi dsi basic delay: (unit: ms) */
+//        dsi_on_off_init=<1 0>; /** dsi init command when display on and display off (0=disable, 1=enable) */
 //	};
 
-
 //$$ MATCH "lcd_model_config_match" = <&lcd_CLAP070NJ02>
 //$$ L2 PROP_STR = "model_name"
 //$$ L2 PROP_STR = "interface"
@@ -1215,45 +1205,77 @@ sdio{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
 //	lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{
 //		model_name="CLAA101FP05XG";	/** lcd model name */
 //		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
 //		active_area=<216 135>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
-//		lcd_bits_option=<8 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+//		lcd_bits_option=<8 0>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 
 //		resolution=<1920 1200>;	/** horizontal resolution, vertical resolution */
 //		period=<2080 1235>;		/** horizontal period(htotal), vertical period(vtotal) */
 
 //		clock_hz_pol=<154128000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-//		hsync_width_backporch=<32 80>;	/** hsync_width, hsync_backporch(include hsync_width) */
+//		hsync_width_backporch=<32 112>;	/** hsync_width, hsync_backporch(include hsync_width) */
 //		vsync_width_backporch=<6 26>;	/** vsync_width, vsync_backporch(include vsync_width) */
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 //        dsi_lane_num=<4>;/** mipi dsi data lane number */
+//        dsi_transfer_ctrl=<1>;/** auto stop clk lane in LP mode : (0=disable, 1=enable), default is 0 */
 //        dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
 //        pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
+//        dsi_sleep_out_display_on_delay=<100 100>; /** mipi dsi basic delay: (unit: ms) */
 //	};
 
-//$$ DEVICE="lcd_extern"
+//******************************************************************************
+//lcd extern
+//Notice: only one dev support
+//******************************************************************************
+//$$ DEVICE = "lcd_extern_i2c_tc101"
 //$$ L2 PROP_STR = "status"
-	lcd_extern{
-		compatible = "amlogic,lcd_extern";
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_STR = "i2c_bus"
+	lcd_extern_i2c_tc101{
+		compatible = "amlogic,lcd_i2c_tc101";
+		dev_name ="lcd_i2c_tc101";
 		status = "disabled";
 
-//$$ DEVICE = "lcd_extern_tc101"
-//$$ L2 PROP_STR = "i2c_bus"
-//$$ L2 PROP_U32 = "reg"
+		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		i2c_address = <0x7e>; /** i2c address */
+		i2c_bus = "i2c_bus_a";
+	};
+
+//$$ DEVICE = "lcd_extern_spi_LD070WS2"
 //$$ L2 PROP_STR = "status"
-		lcd_extern_tc101{
-			dev_name ="lcd_tc101";
-			type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi */
-			address = <0x7e>;
-			i2c_bus = "i2c_bus_a";
-			status = "disabled";
-		};
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_U32 = "gpio_spi_cs"
+//$$ L2 PROP_U32 = "gpio_spi_clk"
+//$$ L2 PROP_U32 = "gpio_spi_data"
+	lcd_extern_spi_LD070WS2{
+		compatible = "amlogic,lcd_spi_LD070WS2";
+		dev_name ="lcd_spi_LD070WS2";
+		status = "disabled";
+
+		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		gpio_spi_cs="GPIODV_1";
+		gpio_spi_clk="GPIODV_16";
+		gpio_spi_data="GPIODV_17";
+	};
+
+//$$ DEVICE = "lcd_extern_mipi_LD070WX4"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_LD070WX4{
+		compatible = "amlogic,lcd_mipi_LD070WX4";
+		dev_name ="lcd_mipi_LD070WX4";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
 	};
+
 /// ***************************************************************************************
 ///     -       Sensors
 //$$ MODULE="Sensors"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index cf66b026f9db..e1540a18e432 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -1167,45 +1167,77 @@ sdio{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
 //	lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{
 //		model_name="CLAA101FP05XG";	/** lcd model name */
 //		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
 //		active_area=<216 135>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
-//		lcd_bits_option=<8 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+//		lcd_bits_option=<8 0>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 
 //		resolution=<1920 1200>;	/** horizontal resolution, vertical resolution */
 //		period=<2080 1235>;		/** horizontal period(htotal), vertical period(vtotal) */
 
 //		clock_hz_pol=<154128000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-//		hsync_width_backporch=<32 80>;	/** hsync_width, hsync_backporch(include hsync_width) */
+//		hsync_width_backporch=<32 112>;	/** hsync_width, hsync_backporch(include hsync_width) */
 //		vsync_width_backporch=<6 26>;	/** vsync_width, vsync_backporch(include vsync_width) */
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 //        dsi_lane_num=<4>;/** mipi dsi data lane number */
+//        dsi_transfer_ctrl=<1>;/** auto stop clk lane in LP mode : (0=disable, 1=enable), default is 0 */
 //        dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
 //        pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
+//        dsi_sleep_out_display_on_delay=<100 100>; /** mipi dsi basic delay: (unit: ms) */
 //	};
 
-//$$ DEVICE="lcd_extern"
+//******************************************************************************
+//lcd extern
+//Notice: only one dev support
+//******************************************************************************
+//$$ DEVICE = "lcd_extern_i2c_tc101"
 //$$ L2 PROP_STR = "status"
-	lcd_extern{
-		compatible = "amlogic,lcd_extern";
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_STR = "i2c_bus"
+	lcd_extern_i2c_tc101{
+		compatible = "amlogic,lcd_i2c_tc101";
+		dev_name ="lcd_i2c_tc101";
 		status = "disabled";
 
-//$$ DEVICE = "lcd_extern_tc101"
-//$$ L2 PROP_STR = "i2c_bus"
-//$$ L2 PROP_U32 = "reg"
+		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		i2c_address = <0x7e>; /** i2c address */
+		i2c_bus = "i2c_bus_a";
+	};
+
+//$$ DEVICE = "lcd_extern_spi_LD070WS2"
 //$$ L2 PROP_STR = "status"
-		lcd_extern_tc101{
-			dev_name ="lcd_tc101";
-			type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi */
-			address = <0x7e>;
-			i2c_bus = "i2c_bus_a";
-			status = "disabled";
-		};
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_U32 = "gpio_spi_cs"
+//$$ L2 PROP_U32 = "gpio_spi_clk"
+//$$ L2 PROP_U32 = "gpio_spi_data"
+	lcd_extern_spi_LD070WS2{
+		compatible = "amlogic,lcd_spi_LD070WS2";
+		dev_name ="lcd_spi_LD070WS2";
+		status = "disabled";
+
+		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		gpio_spi_cs="GPIODV_1";
+		gpio_spi_clk="GPIODV_16";
+		gpio_spi_data="GPIODV_17";
 	};
+
+//$$ DEVICE = "lcd_extern_mipi_LD070WX4"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_LD070WX4{
+		compatible = "amlogic,lcd_mipi_LD070WX4";
+		dev_name ="lcd_mipi_LD070WX4";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+	};
+
 /// ***************************************************************************************
 ///     -       Sensors
 //$$ MODULE="Sensors"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index 36da5b62be90..8abba24f1a03 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -1147,9 +1147,9 @@ sdio{
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
-//$$ L2 PROP_U32 2 = "dsi_transfer_mode"
-//$$ L2 PROP_U32 2 = "dsi_power_on_cmd"
+//$$ L2 PROP_U32 = "dsi_operation_mode"
 //$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
+//$$ L2 PROP_U32 2 = "dsi_on_off_init"
 lcd_LD070WX4:lcd_LD070WX4{
 		model_name="LD070WX4";	/** lcd model name */
 		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1167,18 +1167,9 @@ lcd_LD070WX4:lcd_LD070WX4{
 		
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
 		dsi_bit_rate_min_max=<400 500>;/** range of mipi dsi data lane bit rate(unit: MHz) */
-		dsi_transfer_mode=<0>;/** mipi dsi transfer mode: (0=command mode, 1=video mode) */
-		dsi_power_on_cmd =<  0x01  0x0
-										 0xFF  0x20     
-										 0xAE  0x0B 
-										 0xEE  0xEA 
-										 0xEF  0x5F 
-										 0xF2  0x68 
-										 0xEE  0x0 
-										 0xEF  0x0 
-										 0xFF  0xFF
-           				>;/** special power on command, 2 data is a pair(reg, value), if the first valu is 0xff, second value is delay time(unit: ms), ending flag is 0xff,0xff.*/
-   dsi_sleep_out_display_on_delay=<200 100>; /** mipi dsi basic delay: (unit: ms) */
+		dsi_operation_mode=<0>;/** mipi dsi init operation mode: (0=video mode, 1=command mode), default is 1 */
+		dsi_sleep_out_display_on_delay=<200 100>; /** mipi dsi basic delay: (unit: ms) */
+		dsi_on_off_init=<1 0>; /** dsi init command when display on and display off (0=disable, 1=enable) */
 	};
 
 
@@ -1272,45 +1263,77 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
 	lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{
 		model_name="CLAA101FP05XG";	/** lcd model name */
 		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
 		active_area=<216 135>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
-		lcd_bits_option=<8 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+		lcd_bits_option=<8 0>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 
 		resolution=<1920 1200>;	/** horizontal resolution, vertical resolution */
 		period=<2080 1235>;		/** horizontal period(htotal), vertical period(vtotal) */
 
 		clock_hz_pol=<154128000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-		hsync_width_backporch=<32 80>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		hsync_width_backporch=<32 112>;	/** hsync_width, hsync_backporch(include hsync_width) */
 		vsync_width_backporch=<6 26>;	/** vsync_width, vsync_backporch(include vsync_width) */
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
+        dsi_transfer_ctrl=<1>;/** auto stop clk lane in LP mode : (0=disable, 1=enable), default is 0 */
         dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
         pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
+        dsi_sleep_out_display_on_delay=<100 100>; /** mipi dsi basic delay: (unit: ms) */
 	};
 
-//$$ DEVICE="lcd_extern"
+//******************************************************************************
+//lcd extern
+//Notice: only one dev support
+//******************************************************************************
+//$$ DEVICE = "lcd_extern_i2c_tc101"
 //$$ L2 PROP_STR = "status"
-	lcd_extern{
-		compatible = "amlogic,lcd_extern";
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_STR = "i2c_bus"
+	lcd_extern_i2c_tc101{
+		compatible = "amlogic,lcd_i2c_tc101";
+		dev_name ="lcd_i2c_tc101";
 		status = "disabled";
 
-//$$ DEVICE = "lcd_extern_tc101"
-//$$ L2 PROP_STR = "i2c_bus"
-//$$ L2 PROP_U32 = "reg"
+		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		i2c_address = <0x7e>; /** i2c address */
+		i2c_bus = "i2c_bus_a";
+	};
+
+//$$ DEVICE = "lcd_extern_spi_LD070WS2"
 //$$ L2 PROP_STR = "status"
-		lcd_extern_tc101{
-			dev_name ="lcd_tc101";
-			type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi */
-			address = <0x7e>;
-			i2c_bus = "i2c_bus_a";
-			status = "disabled";
-		};
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_U32 = "gpio_spi_cs"
+//$$ L2 PROP_U32 = "gpio_spi_clk"
+//$$ L2 PROP_U32 = "gpio_spi_data"
+	lcd_extern_spi_LD070WS2{
+		compatible = "amlogic,lcd_spi_LD070WS2";
+		dev_name ="lcd_spi_LD070WS2";
+		status = "disabled";
+
+		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		gpio_spi_cs="GPIODV_1";
+		gpio_spi_clk="GPIODV_16";
+		gpio_spi_data="GPIODV_17";
+	};
+
+//$$ DEVICE = "lcd_extern_mipi_LD070WX4"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_LD070WX4{
+		compatible = "amlogic,lcd_mipi_LD070WX4";
+		dev_name ="lcd_mipi_LD070WX4";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
 	};
+
 /// ***************************************************************************************
 ///     -       Sensors
 //$$ MODULE="Sensors"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
index 983d3b3f706e..73ff6e5e2dc7 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
@@ -1110,9 +1110,9 @@ sdio{
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
-//$$ L2 PROP_U32 = "dsi_transfer_mode"
-//$$ L2 PROP_U32 18 = "dsi_power_on_cmd"
+//$$ L2 PROP_U32 = "dsi_operation_mode"
 //$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
+//$$ L2 PROP_U32 2 = "dsi_on_off_init"
 lcd_LD070WX4:lcd_LD070WX4{
 		model_name="LD070WX4";	/** lcd model name */
 		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1127,21 +1127,12 @@ lcd_LD070WX4:lcd_LD070WX4{
 		vsync_width_backporch=<2 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 		vsync_horizontal_phase=<1 4>; /** adj_sign(0=positive, 1=negative), adj_value. default is <0 0> */
-
-        dsi_lane_num=<4>;/** mipi dsi data lane number */
-        dsi_bit_rate_min_max=<400 500>;/** range of mipi dsi data lane bit rate(unit: MHz) */
-        dsi_transfer_mode=<0>;/** mipi dsi transfer mode: (0=command mode, 1=video mode) */
-        dsi_power_on_cmd =< 0x01  0x0
-                            0xFF  0x20
-                            0xAE  0x0B 
-                            0xEE  0xEA 
-                            0xEF  0x5F 
-                            0xF2  0x68 
-                            0xEE  0x0 
-                            0xEF  0x0 
-                            0xFF  0xFF
-                          >;/** special power on command, 2 data is a pair(reg, value), if the first valu is 0xff, second value is delay time(unit: ms), ending flag is 0xff,0xff.*/
-        dsi_sleep_out_display_on_delay=<200 100>; /** mipi dsi basic delay: (unit: ms) */
+		
+		dsi_lane_num=<4>;/** mipi dsi data lane number */
+		dsi_bit_rate_min_max=<400 500>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_operation_mode=<0>;/** mipi dsi init operation mode: (0=video mode, 1=command mode), default is 1 */
+		dsi_sleep_out_display_on_delay=<200 100>; /** mipi dsi basic delay: (unit: ms) */
+		dsi_on_off_init=<1 0>; /** dsi init command when display on and display off (0=disable, 1=enable) */
 	};
 
 
@@ -1235,45 +1226,77 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
 	lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{
 		model_name="CLAA101FP05XG";	/** lcd model name */
 		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
 		active_area=<216 135>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
-		lcd_bits_option=<8 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+		lcd_bits_option=<8 0>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 
 		resolution=<1920 1200>;	/** horizontal resolution, vertical resolution */
 		period=<2080 1235>;		/** horizontal period(htotal), vertical period(vtotal) */
 
 		clock_hz_pol=<154128000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-		hsync_width_backporch=<32 80>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		hsync_width_backporch=<32 112>;	/** hsync_width, hsync_backporch(include hsync_width) */
 		vsync_width_backporch=<6 26>;	/** vsync_width, vsync_backporch(include vsync_width) */
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
+        dsi_transfer_ctrl=<1>;/** auto stop clk lane in LP mode : (0=disable, 1=enable), default is 0 */
         dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
         pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
+        dsi_sleep_out_display_on_delay=<100 100>; /** mipi dsi basic delay: (unit: ms) */
 	};
 
-//$$ DEVICE="lcd_extern"
+//******************************************************************************
+//lcd extern
+//Notice: only one dev support
+//******************************************************************************
+//$$ DEVICE = "lcd_extern_i2c_tc101"
 //$$ L2 PROP_STR = "status"
-	lcd_extern{
-		compatible = "amlogic,lcd_extern";
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_STR = "i2c_bus"
+	lcd_extern_i2c_tc101{
+		compatible = "amlogic,lcd_i2c_tc101";
+		dev_name ="lcd_i2c_tc101";
 		status = "disabled";
 
-//$$ DEVICE = "lcd_extern_tc101"
-//$$ L2 PROP_STR = "i2c_bus"
-//$$ L2 PROP_U32 = "reg"
+		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		i2c_address = <0x7e>; /** i2c address */
+		i2c_bus = "i2c_bus_a";
+	};
+
+//$$ DEVICE = "lcd_extern_spi_LD070WS2"
 //$$ L2 PROP_STR = "status"
-		lcd_extern_tc101{
-			dev_name ="lcd_tc101";
-			type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi */
-			address = <0x7e>;
-			i2c_bus = "i2c_bus_a";
-			status = "disabled";
-		};
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_U32 = "gpio_spi_cs"
+//$$ L2 PROP_U32 = "gpio_spi_clk"
+//$$ L2 PROP_U32 = "gpio_spi_data"
+	lcd_extern_spi_LD070WS2{
+		compatible = "amlogic,lcd_spi_LD070WS2";
+		dev_name ="lcd_spi_LD070WS2";
+		status = "disabled";
+
+		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		gpio_spi_cs="GPIODV_1";
+		gpio_spi_clk="GPIODV_16";
+		gpio_spi_data="GPIODV_17";
 	};
+
+//$$ DEVICE = "lcd_extern_mipi_LD070WX4"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_LD070WX4{
+		compatible = "amlogic,lcd_mipi_LD070WX4";
+		dev_name ="lcd_mipi_LD070WX4";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+	};
+
 /// ***************************************************************************************
 ///     -       Sensors
 //$$ MODULE="Sensors"
diff --git a/drivers/amlogic/display/vout/aml_lcd.dtd b/drivers/amlogic/display/vout/aml_lcd.dtd
index 01a2ced79531..63f7e74c8f22 100755
--- a/drivers/amlogic/display/vout/aml_lcd.dtd
+++ b/drivers/amlogic/display/vout/aml_lcd.dtd
@@ -234,6 +234,7 @@
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
+//$$ L2 PROP_U32 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
@@ -241,17 +242,18 @@
         model_name="CLAA101FP05XG";	/** lcd model name */
         interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
         active_area=<216 135>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
-        lcd_bits_option=<8 1>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+        lcd_bits_option=<8 0>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
 
         resolution=<1920 1200>;	/** horizontal resolution, vertical resolution */
         period=<2080 1235>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<154128000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<32 80>;	/** hsync_width, hsync_backporch(include hsync_width) */
+        hsync_width_backporch=<32 112>;	/** hsync_width, hsync_backporch(include hsync_width) */
         vsync_width_backporch=<6 26>;	/** vsync_width, vsync_backporch(include vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
+        dsi_transfer_ctrl=<1>;/** auto stop clk lane in LP mode : (0=disable, 1=enable), default is 0 */
         dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
         pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
         dsi_sleep_out_display_on_delay=<100 100>; /** mipi dsi basic delay: (unit: ms) */
@@ -271,9 +273,9 @@
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
-//$$ L2 PROP_U32 = "dsi_transfer_mode"
-//$$ L2 PROP_U32 18 = "dsi_power_on_cmd"
+//$$ L2 PROP_U32 = "dsi_operation_mode"
 //$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
+//$$ L2 PROP_U32 2 = "dsi_on_off_init"
     lcd_LD070WX4:lcd_LD070WX4{
         model_name="LD070WX4";	/** lcd model name */
         interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -291,18 +293,47 @@
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
         dsi_bit_rate_min_max=<400 500>;/** range of mipi dsi data lane bit rate(unit: MHz) */
-        dsi_transfer_mode=<0>;/** mipi dsi transfer mode: (0=command mode, 1=video mode), default is 1 */
-        dsi_power_on_cmd =<0x01  0x0
-                        0xFF  0x20
-                        0xAE  0x0B
-                        0xEE  0xEA
-                        0xEF  0x5F
-                        0xF2  0x68
-                        0xEE  0x0
-                        0xEF  0x0
-                        0xFF  0xFF
-                        >;/** special power on command, 2 data is a pair(reg, value). if the first valu is 0xff, second value is delay time(unit: ms). ending flag is 0xff,0xff.*/
+        dsi_operation_mode=<0>;/** mipi dsi init operation mode: (0=video mode, 1=command mode), default is 1 */
         dsi_sleep_out_display_on_delay=<200 100>; /** mipi dsi basic delay: (unit: ms) */
+        dsi_on_off_init=<1 0>; /** dsi init command when display on and display off (0=disable, 1=enable) */
+    };
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_N070ICN>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "vsync_horizontal_phase"
+//$$ L2 PROP_U32 = "dsi_lane_num"
+//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_operation_mode"
+//$$ L2 PROP_U32 2 = "dsi_sleep_out_display_on_delay"
+//$$ L2 PROP_U32 2 = "dsi_on_off_init"
+    lcd_N070ICN:lcd_N070ICN{
+        model_name="N070ICN";	/** lcd model name */
+        interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
+        active_area=<94 151>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+        lcd_bits_option=<8 0>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+        resolution=<800 1280>;	/** horizontal resolution, vertical resolution */
+        period=<864 1315>;		/** horizontal period(htotal), vertical period(vtotal) */
+
+        clock_hz_pol=<56800000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+        hsync_width_backporch=<4 48>;	/** hsync_width, hsync_backporch(include hsync_width) */
+        vsync_width_backporch=<3 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+        vsync_horizontal_phase=<1 4>; /** adj_sign(0=positive, 1=negative), adj_value. default is <0 0> */
+
+        dsi_lane_num=<4>;/** mipi dsi data lane number */
+        dsi_bit_rate_min_max=<400 500>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+        dsi_sleep_out_display_on_delay=<30 30>; /** mipi dsi basic delay: (unit: ms) */
+        dsi_on_off_init=<1 0>; /** dsi init command when display on and display off (0=disable, 1=enable) */
     };
 
 //******************************************************************************
@@ -503,7 +534,7 @@
 //$$ L2 PROP_U32 2 = "clock_hz_pol"
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
-//$$ L2 PROP_U32 2 = "pol_hsync_vsync"	
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
     lcd_TM081JFH01:lcd_TM081JFH01{
         model_name="TM081JFH01";	/** lcd model name */
         interface="lvds";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -597,6 +628,31 @@
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
+//$$ MATCH "lcd_model_config_match" = <&lcd_LD070WS2>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+    lcd_LD070WS2:lcd_LD070WS2{
+        model_name="LD070WS2";	/** lcd model name */
+        interface="lvds";		/** lcd_interface(mipi, lvds, edp, ttl) */
+        active_area=<154 90>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+        lcd_bits_option=<8 0>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+        resolution=<1024 600>;	/** horizontal resolution, vertical resolution */
+        period=<1344 635>;		/** horizontal period(htotal), vertical period(vtotal) */
+
+        clock_hz_pol=<51200000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+        hsync_width_backporch=<10 170>;	/** hsync_width, hsync_backporch(include hsync_width) */
+        vsync_width_backporch=<2 25>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+    };
 //******************************************************************************
 //ttl
 //******************************************************************************
diff --git a/drivers/amlogic/display/vout/edp_drv.c b/drivers/amlogic/display/vout/edp_drv.c
index 5ea3b8aa1835..35710c75d337 100755
--- a/drivers/amlogic/display/vout/edp_drv.c
+++ b/drivers/amlogic/display/vout/edp_drv.c
@@ -1819,12 +1819,18 @@ int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_Video_Mode_t *vm)
 
 int dplpm_link_off(void)
 {
-	int status = 0;
-	unsigned char aux_data;
-	
-	DBG_PRINT("..... Power down sink link .....\n");
-	aux_data = 2;	//power down mode
-	//status = trdp_AUXWrite(EDP_DPCD_SET_POWER, 1, &aux_data);
+    int status = 0;
+    unsigned char aux_data;
+
+    DBG_PRINT("..... Power down sink link .....\n");
+    aux_data = 2;	//power down mode
+    //status = trdp_AUXWrite(EDP_DPCD_SET_POWER, 1, &aux_data);
+
+    return status;
+}
+
+void dplpm_off(void)
+{
 	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
 	mdelay(10);
 	dplpm_main_stream_enable(0);
@@ -1832,12 +1838,11 @@ int dplpm_link_off(void)
 	WRITE_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE, 0);	//disable the transmitter
 	WRITE_DPTX_REG(EDP_TX_PHY_RESET, 0xf);	//reset the PHY
 	WRITE_DPTX_REG(EDP_TX_PHY_POWER_DOWN, 0xf);	//need to set
-	WRITE_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE, 0);	//disable the transmitter
+
 	//mdelay(100);
 	WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 0, 11, 1);
 	WRITE_LCD_CBUS_REG_BITS(RESET4_REGISTER, 1, 11, 1);
 	WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 1, 11, 1);
-	return status;
 }
 
 //***********************************************//
diff --git a/drivers/amlogic/display/vout/edp_drv.h b/drivers/amlogic/display/vout/edp_drv.h
index 9111e0ba2e7c..0b8f960180be 100755
--- a/drivers/amlogic/display/vout/edp_drv.h
+++ b/drivers/amlogic/display/vout/edp_drv.h
@@ -247,6 +247,7 @@ typedef struct {
 
 extern int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_Video_Mode_t *vm);
 extern int dplpm_link_off(void);
+extern void dplpm_off(void);
 extern void edp_probe(void);
 extern void edp_remove(void);
 
diff --git a/drivers/amlogic/display/vout/lcd_extern/Makefile b/drivers/amlogic/display/vout/lcd_extern/Makefile
index c4d1f48d969e..5de0d91c85dd 100755
--- a/drivers/amlogic/display/vout/lcd_extern/Makefile
+++ b/drivers/amlogic/display/vout/lcd_extern/Makefile
@@ -1,4 +1,7 @@
 
 obj-$(CONFIG_AML_LCD_EXTERN)	+= lcd_extern.o
-obj-$(CONFIG_AML_LCD_EXTERN)	+= tc101.o
+obj-$(CONFIG_AML_LCD_EXTERN)	+= i2c_tc101.o
+obj-$(CONFIG_AML_LCD_EXTERN)	+= mipi_LD070WX4.o
+obj-$(CONFIG_AML_LCD_EXTERN)	+= mipi_N070ICN.o
+obj-$(CONFIG_AML_LCD_EXTERN)	+= spi_LD070WS2.o
 
diff --git a/drivers/amlogic/display/vout/lcd_extern/aml.dtd b/drivers/amlogic/display/vout/lcd_extern/aml.dtd
index 5f207a1a0b23..a7b817bfa566 100755
--- a/drivers/amlogic/display/vout/lcd_extern/aml.dtd
+++ b/drivers/amlogic/display/vout/lcd_extern/aml.dtd
@@ -1,21 +1,59 @@
 #ifdef CONFIG_AML_LCD_EXTERN
-//$$ DEVICE="lcd_extern"
+//******************************************************************************
+//lcd extern
+//Notice: only one dev support
+//******************************************************************************
+//$$ DEVICE = "lcd_extern_i2c_tc101"
 //$$ L2 PROP_STR = "status"
-	lcd_extern{
-		compatible = "amlogic,lcd_extern";
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_STR = "i2c_bus"
+	lcd_extern_i2c_tc101{
+		compatible = "amlogic,lcd_i2c_tc101";
+		dev_name ="lcd_i2c_tc101";
 		status = "disabled";
 
-//$$ DEVICE = "lcd_extern_tc101"
-//$$ L2 PROP_STR = "i2c_bus"
-//$$ L2 PROP_U32 = "reg"
+		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		i2c_address = <0x7e>; /** i2c address */
+		i2c_bus = "i2c_bus_a";
+	};
+
+//$$ DEVICE = "lcd_extern_spi_LD070WS2"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_U32 = "gpio_spi_cs"
+//$$ L2 PROP_U32 = "gpio_spi_clk"
+//$$ L2 PROP_U32 = "gpio_spi_data"
+	lcd_extern_spi_LD070WS2{
+		compatible = "amlogic,lcd_spi_LD070WS2";
+		dev_name ="lcd_spi_LD070WS2";
+		status = "disabled";
+
+		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		gpio_spi_cs="GPIODV_1";
+		gpio_spi_clk="GPIODV_16";
+		gpio_spi_data="GPIODV_17";
+	};
+
+//$$ DEVICE = "lcd_extern_mipi_LD070WX4"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_LD070WX4{
+		compatible = "amlogic,lcd_mipi_LD070WX4";
+		dev_name ="lcd_mipi_LD070WX4";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+	};
+
+//$$ DEVICE = "lcd_extern_mipi_N070ICN"
 //$$ L2 PROP_STR = "status"
-		lcd_extern_tc101{
-			dev_name ="lcd_tc101";
-			type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi */
-			address = <0x7e>;
-			i2c_bus = "i2c_bus_a";
-			status = "disabled";
-		};
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_N070ICN{
+		compatible = "amlogic,lcd_mipi_N070ICN";
+		dev_name ="lcd_mipi_N070ICN";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
 	};
 
 #endif
diff --git a/drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c b/drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c
new file mode 100755
index 000000000000..e09b04b7e671
--- /dev/null
+++ b/drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c
@@ -0,0 +1,321 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * I2C 
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h> 
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+
+static struct lcd_extern_config_t *lcd_ext_config = NULL;
+
+static struct i2c_client *aml_tc101_i2c_client;
+
+//#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+#define LCD_EXTERN_NAME			"lcd_i2c_tc101"
+
+static unsigned char i2c_init_table[][3] = {
+    //{0xff, 0xff, 20},//delay mark(20ms)
+    {0xf8, 0x30, 0xb2},
+    {0xf8, 0x33, 0xc2},
+    {0xf8, 0x31, 0xf0},
+    {0xf8, 0x40, 0x80},
+    {0xf8, 0x81, 0xec},
+    {0xff, 0xff, 0xff},//end mark
+};
+
+static int aml_i2c_write(struct i2c_client *i2client,unsigned char *buff, unsigned len)
+{
+    int res = 0;
+    struct i2c_msg msg[] = {
+        {
+        .addr = i2client->addr,
+        .flags = 0,
+        .len = len,
+        .buf = buff,
+        }
+    };
+    
+    res = i2c_transfer(i2client->adapter, msg, 1);
+    if (res < 0) {
+        printk("%s: i2c transfer failed [addr 0x%02x]\n", __FUNCTION__, i2client->addr);
+    }
+    
+    return res;
+}
+
+static int aml_i2c_read(struct i2c_client *i2client,unsigned char *buff, unsigned len)
+{
+    int res = 0;
+    struct i2c_msg msgs[] = {
+        {
+            .addr = i2client->addr,
+            .flags = 0,
+            .len = 1,
+            .buf = buff,
+        },
+        {
+            .addr = i2client->addr,
+            .flags = I2C_M_RD,
+            .len = len,
+            .buf = buff,
+        }
+    };
+    res = i2c_transfer(i2client->adapter, msgs, 2);
+    if (res < 0) {
+        printk("%s: i2c transfer failed [addr 0x%02x]\n", __FUNCTION__, i2client->addr);
+    }
+
+    return res;
+}
+
+static int i2c_reg_read(unsigned char reg, unsigned char *buf)
+{
+    int ret=0;
+
+    return ret;
+}
+
+static int i2c_reg_write(unsigned char reg, unsigned char value)
+{
+    int ret=0;
+
+    return ret;
+}
+
+static int lcd_extern_i2c_init(void)
+{
+    unsigned char tData[4];
+    int i=0, ending_flag=0;
+    int ret=0;
+
+    while (ending_flag == 0) {
+        if ((i2c_init_table[i][0] == 0xff) && (i2c_init_table[i][1] == 0xff)) {    //special mark
+            if (i2c_init_table[i][2] == 0xff) { //ending flag
+                ending_flag = 1;
+            }
+            else { //delay flag
+                mdelay(i2c_init_table[i][2]);
+            }
+        }
+        else {
+            tData[0]=i2c_init_table[i][0];
+            tData[1]=i2c_init_table[i][1];
+            tData[2]=i2c_init_table[i][2];
+            aml_i2c_write(aml_tc101_i2c_client, tData, 3);
+        }
+        i++;
+    }
+    printk("%s\n", __FUNCTION__);
+    return ret;
+}
+
+static int lcd_extern_i2c_remove(void)
+{
+    int ret=0;
+
+    return ret;
+}
+
+static int lcd_extern_driver_update(void)
+{
+    struct aml_lcd_extern_driver_t* lcd_ext;
+
+    lcd_ext = aml_lcd_extern_get_driver();
+    if (lcd_ext) {
+        lcd_ext->type      = lcd_ext_config->type;
+        lcd_ext->name      = lcd_ext_config->name;
+        lcd_ext->reg_read  = i2c_reg_read;
+        lcd_ext->reg_write = i2c_reg_write;
+        lcd_ext->power_on  = lcd_extern_i2c_init;
+        lcd_ext->power_off = lcd_extern_i2c_remove;
+    }
+    else {
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_config->name);
+    }
+
+    return 0;
+}
+
+static int aml_tc101_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        printk("[error] %s: functionality check failed\n", __FUNCTION__);
+        return -ENODEV;
+    }
+    else {
+        aml_tc101_i2c_client = client;
+        lcd_extern_driver_update();
+    }
+
+    printk("%s OK\n", __FUNCTION__);
+    return 0;
+}
+
+static int aml_tc101_i2c_remove(struct i2c_client *client)
+{
+    return 0;
+}
+
+static const struct i2c_device_id aml_tc101_i2c_id[] = {
+    {LCD_EXTERN_NAME, 0},
+    { }
+};
+// MODULE_DEVICE_TABLE(i2c, aml_tc101_id);
+
+static struct i2c_driver aml_tc101_i2c_driver = {
+    .probe    = aml_tc101_i2c_probe,
+    .remove   = aml_tc101_i2c_remove,
+    .id_table = aml_tc101_i2c_id,
+    .driver = {
+        .name = LCD_EXTERN_NAME,
+        .owner =THIS_MODULE,
+    },
+};
+
+static int aml_tc101_probe(struct platform_device *pdev)
+{
+    struct i2c_board_info i2c_info;
+    struct i2c_adapter *adapter;
+    struct i2c_client *i2c_client;
+    int i = 0;
+    int ret = 0;
+
+    if (lcd_extern_driver_check()) {
+        return -1;
+    }
+    if (lcd_ext_config == NULL)
+        lcd_ext_config = kzalloc(sizeof(*lcd_ext_config), GFP_KERNEL);
+    if (lcd_ext_config == NULL) {
+        printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
+        return -1;
+    }
+
+    pdev->dev.platform_data = lcd_ext_config;
+
+    if (get_lcd_extern_dt_data(pdev->dev.of_node, lcd_ext_config) != 0) {
+        printk("[error] %s probe: failed to get dt data\n", LCD_EXTERN_NAME);
+        goto lcd_extern_probe_failed;
+    }
+
+    memset(&i2c_info, 0, sizeof(i2c_info));
+
+    adapter = i2c_get_adapter(lcd_ext_config->i2c_bus);
+    if (!adapter) {
+        printk("[error] %sfailed to get i2c adapter\n", LCD_EXTERN_NAME);
+        goto lcd_extern_probe_failed;
+    }
+
+    strncpy(i2c_info.type, lcd_ext_config->name, I2C_NAME_SIZE);
+    i2c_info.addr = lcd_ext_config->i2c_addr;
+    i2c_info.platform_data = lcd_ext_config;
+    i2c_info.flags=0;
+    if(i2c_info.addr>0x7f)
+        i2c_info.flags=0x10;
+    i2c_client = i2c_new_device(adapter, &i2c_info);
+    if (!i2c_client) {
+        printk("[error] %s :failed to new i2c device\n", LCD_EXTERN_NAME);
+        goto lcd_extern_probe_failed;
+    }
+    else{
+        DBG_PRINT("[error] %s: new i2c device succeed\n",((struct lcd_extern_data_t *)(i2c_client->dev.platform_data))->name);
+    }
+
+    if (!aml_tc101_i2c_client) {
+        ret = i2c_add_driver(&aml_tc101_i2c_driver);
+        if (ret) {
+            printk("[error] %s probe: add i2c_driver failed\n" LCD_EXTERN_NAME);
+            goto lcd_extern_probe_failed;
+        }
+    }
+
+    printk("%s ok\n", __FUNCTION__);
+    return ret;
+
+lcd_extern_probe_failed:
+    if (lcd_ext_config)
+        kfree(lcd_ext_config);
+    return -1;
+}
+
+static int aml_tc101_remove(struct platform_device *pdev)
+{
+    if (pdev->dev.platform_data)
+        kfree (pdev->dev.platform_data);
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_tc101_dt_match[]={
+    {
+        .compatible = "amlogic,lcd_i2c_tc101",
+    },
+    {},
+};
+#else
+#define aml_tc101_dt_match NULL
+#endif
+
+static struct platform_driver aml_tc101_driver = {
+    .probe  = aml_tc101_probe,
+    .remove = aml_tc101_remove,
+    .driver = {
+        .name  = LCD_EXTERN_NAME,
+        .owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+        .of_match_table = aml_tc101_dt_match,
+#endif
+    },
+};
+
+static int __init aml_tc101_init(void)
+{
+    int ret;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    ret = platform_driver_register(&aml_tc101_driver);
+    if (ret) {
+        printk("[error] %s failed to register lcd extern driver module\n", __FUNCTION__);
+        return -ENODEV;
+    }
+    return ret;
+}
+
+static void __exit aml_tc101_exit(void)
+{
+    platform_driver_unregister(&aml_tc101_driver);
+}
+
+//late_initcall(aml_tc101_init);
+module_init(aml_tc101_init);
+module_exit(aml_tc101_exit);
+
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("LCD Extern driver for TC101");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/vout/lcd_extern/lcd_extern.c b/drivers/amlogic/display/vout/lcd_extern/lcd_extern.c
index b30060320f8e..5c94626666cb 100755
--- a/drivers/amlogic/display/vout/lcd_extern/lcd_extern.c
+++ b/drivers/amlogic/display/vout/lcd_extern/lcd_extern.c
@@ -11,7 +11,6 @@
 #include <mach/am_regs.h>
 #include <mach/gpio.h>
 #include <linux/amlogic/vout/aml_lcd_extern.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
 
 //#define LCD_EXT_DEBUG_INFO
 #ifdef LCD_EXT_DEBUG_INFO
@@ -20,48 +19,66 @@
 #define DBG_PRINT(...)
 #endif
 
-struct aml_lcd_extern_driver_t lcd_ext_driver;
+static struct aml_lcd_extern_driver_t lcd_ext_driver = {
+	.type = LCD_EXTERN_MAX,
+	.name = NULL,
+	.reg_read = NULL,
+	.reg_write = NULL,
+	.power_on = NULL,
+	.power_off = NULL,
+	.init_on_cmd_8 = NULL,
+	.init_off_cmd_8 = NULL,
+};
 
 struct aml_lcd_extern_driver_t* aml_lcd_extern_get_driver(void)
 {
-	return &lcd_ext_driver;
+    return &lcd_ext_driver;
 }
 
-static int get_lcd_extern_dt_data(struct device_node* of_node, struct lcd_extern_data_t *pdata)
+int lcd_extern_driver_check(void)
+{
+	struct aml_lcd_extern_driver_t* lcd_ext;
+
+	lcd_ext = aml_lcd_extern_get_driver();
+	if (lcd_ext) {
+		if (lcd_ext->type < LCD_EXTERN_MAX) {
+			printk("[warning]: lcd_extern has already exist (%s)\n", lcd_ext->name);
+			return -1;
+		}
+	}
+	else {
+		printk("get lcd_extern_driver failed\n");
+	}
+	
+	return 0;
+}
+
+int get_lcd_extern_dt_data(struct device_node* of_node, struct lcd_extern_config_t *pdata)
 {
 	int err;
+	int val;
 	const char *str;
 	
-	err = of_property_read_string(of_node, "dev_name", (const char **)&pdata->name);
+	err = of_property_read_string(of_node, "dev_name", &pdata->name);
 	if (err) {
 		pdata->name = "aml_lcd_extern";
-		printk("warning: get dev_name failed, set dev_name aml_lcd_extern\n");
+		printk("warning: get dev_name failed\n");
 	}
+	
 	err = of_property_read_u32(of_node, "type", &pdata->type);
 	if (err) {
 		pdata->type = LCD_EXTERN_MAX;
 		printk("warning: get type failed, exit\n");
 		return -1;
 	}
-	err = of_property_read_string(of_node, "status", &str);
-	if (err) {
-		printk("%s warning: get status failed, default disable\n", pdata->name);
-		pdata->status = 0;
-	}
-	else {
-		if ((strncmp(str, "ok", 2) == 0) || (strncmp(str, "enable", 6) == 0))
-			pdata->status = 1;
-		else
-			pdata->status = 0;
-	}
 	switch (pdata->type) {
 		case LCD_EXTERN_I2C:
-			err = of_property_read_u32(of_node,"address",&pdata->addr);
+			err = of_property_read_u32(of_node,"i2c_address",&pdata->i2c_addr);
 			if (err) {
-				printk("%s warning: get i2c address failed\n", pdata->name);
-				pdata->addr = 0;
+				printk("%s warning: get i2c_address failed\n", pdata->name);
+				pdata->i2c_addr = 0;
 			}
-			DBG_PRINT("%s: address=0x%02x\n", pdata->name, pdata->addr);
+			DBG_PRINT("%s: i2c_address=0x%02x\n", pdata->name, pdata->i2c_addr);
 		  
 			err = of_property_read_string(of_node, "i2c_bus", &str);
 			if (err) {
@@ -85,135 +102,69 @@ static int get_lcd_extern_dt_data(struct device_node* of_node, struct lcd_extern
 			DBG_PRINT("%s: i2c_bus=%s[%d]\n", pdata->name, str, pdata->i2c_bus);
 			break;
 		case LCD_EXTERN_SPI:
-			break;
-		default:
-			break;
-	}
-	
-	return 0;
-}
-
-static int lcd_extern_probe(struct platform_device *pdev)
-{
-	struct device_node* child;
-	struct i2c_board_info i2c_info;
-	struct i2c_adapter *adapter;
-	struct i2c_client *i2c_client;
-	int i = 0;
-	struct lcd_extern_data_t *pdata = NULL;
-	
-	if (!pdata)
-		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
-	if (!pdata)	{
-		printk("failed to alloc data\n");
-		goto lcd_extern_probe_failed;
-	}
-	
-	pdev->dev.platform_data = pdata;
-	
-	for_each_child_of_node(pdev->dev.of_node, child) {
-		if (get_lcd_extern_dt_data(child, pdata) != 0) {
-			printk("failed to get dt data\n");
-			goto lcd_extern_probe_failed;
-		}
-		if (pdata->status == 1) {
-			switch (pdata->type) {
-				case LCD_EXTERN_I2C:
-					memset(&i2c_info, 0, sizeof(i2c_info));
-					
-					adapter = i2c_get_adapter(pdata->i2c_bus);
-					if (!adapter) {
-						printk("warningfailed to get i2c adapter\n");
-						goto lcd_extern_probe_failed;
+			err = of_property_read_string(of_node,"gpio_spi_cs", &str);
+			if (err) {
+				printk("%s warning: get spi gpio_spi_cs failed\n", pdata->name);
+				pdata->spi_cs = -1;
+			}
+			else {
+			    val = amlogic_gpio_name_map_num(str);
+				if (val > 0) {
+					err = lcd_extern_gpio_request(val);
+					if (err) {
+					  printk("faild to alloc spi_cs gpio (%s)!\n", str);
 					}
-					
-					strncpy(i2c_info.type, pdata->name, I2C_NAME_SIZE);
-					i2c_info.addr = pdata->addr;
-					i2c_info.platform_data = pdata;
-					i2c_info.flags=0;
-					if(i2c_info.addr>0x7f)
-						i2c_info.flags=0x10;
-					i2c_client = i2c_new_device(adapter, &i2c_info);
-					if (!i2c_client) {
-						printk("%s :failed to new i2c device\n", pdata->name);
-						goto lcd_extern_probe_failed;
+					pdata->spi_cs = val;
+					DBG_PRINT("spi_cs gpio = %s(%d)\n", str, pdata->spi_cs);
+				}
+				else {
+					pdata->spi_cs = -1;
+				}
+			}
+			err = of_property_read_string(of_node,"gpio_spi_clk", &str);
+			if (err) {
+				printk("%s warning: get spi gpio_spi_clk failed\n", pdata->name);
+				pdata->spi_clk = -1;
+			}
+			else {
+			    val = amlogic_gpio_name_map_num(str);
+				if (val > 0) {
+					err = lcd_extern_gpio_request(val);
+					if (err) {
+					  printk("faild to alloc spi_clk gpio (%s)!\n", str);
 					}
-					else{
-						DBG_PRINT("%s: new i2c device succeed\n",((struct lcd_extern_data_t *)(i2c_client->dev.platform_data))->name);
+					pdata->spi_clk = val;
+					DBG_PRINT("spi_clk gpio = %s(%d)\n", str, pdata->spi_clk);
+				}
+				else {
+					pdata->spi_clk = -1;
+				}
+			}
+			err = of_property_read_string(of_node,"gpio_spi_data", &str);
+			if (err) {
+				printk("%s warning: get spi gpio_spi_data failed\n", pdata->name);
+				pdata->spi_data = -1;
+			}
+			else {
+			    val = amlogic_gpio_name_map_num(str);
+				if (val > 0) {
+					err = lcd_extern_gpio_request(val);
+					if (err) {
+					  printk("faild to alloc spi_data gpio (%s)!\n", str);
 					}
-					
-					lcd_ext_driver.type = LCD_EXTERN_I2C;
-					break;
-				case LCD_EXTERN_SPI:
-					lcd_ext_driver.type = LCD_EXTERN_SPI;
-					break;
-				default:
-					break;
+					pdata->spi_data = val;
+					DBG_PRINT("spi_data gpio = %s(%d)\n", str, pdata->spi_data);
+				}
+				else {
+					pdata->spi_data = -1;
+				}
 			}
-			goto lcd_extern_probe_successful;	//only 1 driver allowed
-		}
-		i++;
+			break;
+		case LCD_EXTERN_MIPI:
+			break;
+		default:
+			break;
 	}
-
-lcd_extern_probe_successful:
-	printk("%s ok\n", __FUNCTION__);
-	return 0;
 	
-lcd_extern_probe_failed:
-	if (pdata)
-		kfree(pdata);
-	return -1;
-}
-
-static int lcd_extern_remove(struct platform_device *pdev)
-{
-	if (pdev->dev.platform_data)
-	 	kfree (pdev->dev.platform_data);
-    return 0;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id aml_lcd_extern_dt_match[]={
-	{	
-		.compatible = "amlogic,lcd_extern",
-	},
-	{},
-};
-#else
-#define aml_lcd_extern_dt_match NULL
-#endif
-
-static struct platform_driver aml_lcd_extern_driver = {
-	.probe		= lcd_extern_probe,
-	.remove		= lcd_extern_remove,
-	.driver		= {
-		.name	= "aml_lcd_extern",
-		.owner	= THIS_MODULE,
-#ifdef CONFIG_USE_OF
-		.of_match_table = aml_lcd_extern_dt_match,
-#endif
-	},
-};
-
-static int __init lcd_extern_init(void)
-{
-	int ret;
-	printk("%s\n", __FUNCTION__);
-	ret = platform_driver_register(&aml_lcd_extern_driver);
-	if (ret) {
-		printk("failed to register lcd extern driver module\n");
-		return -ENODEV;
-	}
-	return ret;
-}
-
-static void __exit lcd_extern_exit(void)
-{
-	platform_driver_unregister(&aml_lcd_extern_driver);
+	return 0;
 }
-
-module_init(lcd_extern_init);
-module_exit(lcd_extern_exit);
-
-MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("Amlogic LCD External bridge driver");
\ No newline at end of file
diff --git a/drivers/amlogic/display/vout/lcd_extern/mipi_LD070WX4.c b/drivers/amlogic/display/vout/lcd_extern/mipi_LD070WX4.c
new file mode 100755
index 000000000000..86b1c603c6e7
--- /dev/null
+++ b/drivers/amlogic/display/vout/lcd_extern/mipi_LD070WX4.c
@@ -0,0 +1,155 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * MIPI 
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h> 
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+
+static struct lcd_extern_config_t *lcd_ext_config = NULL;
+
+//#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+#define LCD_EXTERN_NAME			"lcd_mipi_LD070WX4"
+
+static unsigned char mipi_init_table[] = {
+    2,0x01,0x0,
+    0xff,0x20,//mdelay flag
+    2,0xAE,0x0B,
+    2,0xEE,0xEA,
+    2,0xEF,0x5F,
+    2,0xF2,0x68,
+    2,0xEE,0x0,
+    2,0xEF,0x0,
+    0xff,0xff,//ending flag
+};
+
+static int lcd_extern_driver_update(void)
+{
+    struct aml_lcd_extern_driver_t* lcd_ext;
+
+    lcd_ext = aml_lcd_extern_get_driver();
+    if (lcd_ext) {
+        lcd_ext->type       = lcd_ext_config->type;
+        lcd_ext->name       = lcd_ext_config->name;
+        lcd_ext->init_on_cmd_8 = &mipi_init_table[0];
+    }
+    else {
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_config->name);
+    }
+
+    return 0;
+}
+
+static int aml_LD070WX4_probe(struct platform_device *pdev)
+{
+    int i = 0;
+
+    if (lcd_extern_driver_check()) {
+        return -1;
+    }
+    if (lcd_ext_config == NULL)
+        lcd_ext_config = kzalloc(sizeof(*lcd_ext_config), GFP_KERNEL);
+    if (lcd_ext_config == NULL) {
+        printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
+        return -1;
+    }
+
+    pdev->dev.platform_data = lcd_ext_config;
+
+    if (get_lcd_extern_dt_data(pdev->dev.of_node, lcd_ext_config) != 0) {
+        printk("[error] %s probe: failed to get dt data\n", LCD_EXTERN_NAME);
+        goto lcd_extern_probe_failed;
+    }
+    lcd_extern_driver_update();
+
+    printk("%s probe ok\n", LCD_EXTERN_NAME);
+    return 0;
+
+lcd_extern_probe_failed:
+    if (lcd_ext_config)
+        kfree(lcd_ext_config);
+    return -1;
+}
+
+static int aml_LD070WX4_remove(struct platform_device *pdev)
+{
+    if (pdev->dev.platform_data)
+        kfree (pdev->dev.platform_data);
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_LD070WX4_dt_match[]={
+    {
+        .compatible = "amlogic,lcd_mipi_LD070WX4",
+    },
+    {},
+};
+#else
+#define aml_LD070WX4_dt_match NULL
+#endif
+
+static struct platform_driver aml_LD070WX4_driver = {
+    .probe  = aml_LD070WX4_probe,
+    .remove = aml_LD070WX4_remove,
+    .driver = {
+        .name  = LCD_EXTERN_NAME,
+        .owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+        .of_match_table = aml_LD070WX4_dt_match,
+#endif
+    },
+};
+
+static int __init aml_LD070WX4_init(void)
+{
+    int ret;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    ret = platform_driver_register(&aml_LD070WX4_driver);
+    if (ret) {
+        printk("[error] %s failed to register lcd extern driver module\n", __FUNCTION__);
+        return -ENODEV;
+    }
+
+    return ret;
+}
+
+static void __exit aml_LD070WX4_exit(void)
+{
+    platform_driver_unregister(&aml_LD070WX4_driver);
+}
+
+//late_initcall(aml_LD070WX4_init);
+module_init(aml_LD070WX4_init);
+module_exit(aml_LD070WX4_exit);
+
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("LCD Extern driver for LD070WX4");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c b/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c
new file mode 100755
index 000000000000..0308340ec2d8
--- /dev/null
+++ b/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c
@@ -0,0 +1,315 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * MIPI 
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h> 
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+
+static struct lcd_extern_config_t *lcd_ext_config = NULL;
+
+//#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+#define LCD_EXTERN_NAME			"lcd_mipi_N070ICN"
+
+static unsigned char mipi_init_table[] = {
+    5,0xFF,0xAA,0x55,0xA5,0x80, //========== Internal setting ==========
+
+    3,0x6F,0x11,0x00, //MIPI related Timing Setting
+    3,0xF7,0x20,0x00,
+
+    2,0x6F,0x06,      //Improve ESD option
+    2,0xF7,0xA0,
+    2,0x6F,0x19,
+    2,0xF7,0x12,
+
+    2,0x6F,0x08,     //Vcom floating
+    2,0xFA,0x40,
+    2,0x6F,0x11,
+    2,0xF3,0x01,
+
+    6,0xF0,0x55,0xAA,0x52,0x08,0x00, //========== page0 relative ==========
+
+    3,0xB1,0x68,0x01, //Set WXGA resolution
+
+    2,0xB6,0x08,      //Set source output hold time
+
+    2,0x6F,0x02,      //EQ control function
+    2,0xB8,0x08,
+
+    3,0xBB,0x54,0x44, //Set bias current for GOP and SOP
+
+    3,0xBC,0x05,0x05, //Inversion setting
+
+    2,0xC7,0x01,      //zigzag setting
+
+    6,0xBD,0x02,0xB0,0x0C,0x0A,0x00, //DSP Timing Settings update for BIST
+
+    6,0xF0,0x55,0xAA,0x52,0x08,0x01, //========== page1 relative ==========
+
+    3,0xB0,0x05,0x05,                // Setting AVDD, AVEE clamp
+    3,0xB1,0x05,0x05,
+
+    3,0xBC,0x3A,0x01,                // VGMP, VGMN, VGSP, VGSN setting
+    3,0xBD,0x3E,0x01,
+
+    2,0xCA,0x00,                    // gate signal control
+
+    2,0xC0,0x04,                    // power IC control
+
+    2,0xBE,0x80,      //vcom    -1.88V
+
+    3,0xB3,0x28,0x28, // Setting VGH=15V, VGL=-11V
+    3,0xB4,0x12,0x12,
+
+    3,0xB9,0x34,0x34, // power control for VGH, VGL
+    3,0xBA,0x24,0x24,
+
+    6,0xF0,0x55,0xAA,0x52,0x08,0x02, //========== page2 relative ==========
+
+    2,0xEE,0x02,                     //Gamma control register control
+    5,0xEF,0x09,0x06,0x15,0x18,      //Gradient Control for Gamma Voltage
+
+
+    17,0xB0,0x00,0x00,0x00,0x9D,0x00,0xAE,0x00,0xC1,0x00,0xD6,0x00,0xE9,0x01,0x09,0x01,0x3E,
+    17,0xB1,0x01,0x64,0x01,0xA5,0x01,0xDC,0x02,0x2F,0x02,0x64,0x02,0x65,0x02,0x92,0x02,0xBA,
+    17,0xB2,0x02,0xD1,0x02,0xFB,0x03,0x19,0x03,0x46,0x03,0x61,0x03,0x90,0x03,0xA8,0x03,0xCF,
+    5,0xB3,0x03,0xE8,0x03,0xFF,
+
+    7,0xBC,0x00,0x00,0x00,0x08,0x00,0x18, //========== GOA relative ==========
+    2,0x6F,0x06,                          //PAGE6 : GOUT Mapping, VGLO select
+    7,0xBC,0x00,0x27,0x00,0x32,0x00,0x49,
+    2,0x6F,0x0C,
+    5,0xBC,0x00,0x5C,0x00,0x83,
+    7,0xBD,0x00,0xAF,0x00,0xF3,0x01,0x2A, ////////////////////////////
+    2,0x6F,0x06,
+    7,0xBD,0x01,0x84,0x01,0xCA,0x01,0xCD,
+    2,0x6F,0x0C,
+    5,0xBD,0x02,0x0E,0x02,0x65,
+    7,0xBE,0x02,0x98,0x02,0xD4,0x03,0x00,
+    2,0x6F,0x06,
+    7,0xBE,0x03,0x37,0x03,0x5F,0x03,0x8D,
+    2,0x6F,0x0C,
+    5,0xBE,0x03,0xA4,0x03,0xBF,
+    5,0xBF,0x03,0xE8,0x03,0xFF,
+
+    6,0xF0,0x55,0xAA,0x52,0x08,0x06,
+    3,0xB0,0x00,0x17,
+    3,0xB1,0x16,0x15,
+    3,0xB2,0x14,0x13,
+    3,0xB3,0x12,0x11,
+    3,0xB4,0x10,0x2D,
+    3,0xB5,0x01,0x08,
+    3,0xB6,0x09,0x31,
+    3,0xB7,0x31,0x31,
+    3,0xB8,0x31,0x31,
+    3,0xB9,0x31,0x31,
+    3,0xBA,0x31,0x31,
+    3,0xBB,0x31,0x31,
+    3,0xBC,0x31,0x31,
+    3,0xBD,0x31,0x09,
+    3,0xBE,0x08,0x01,
+    3,0xBF,0x2D,0x10,
+    3,0xC0,0x11,0x12,
+    3,0xC1,0x13,0x14,
+    3,0xC2,0x15,0x16,
+    3,0xC3,0x17,0x00,
+    3,0xE5,0x31,0x31,
+    3,0xC4,0x00,0x17,
+    3,0xC5,0x16,0x15,
+    3,0xC6,0x14,0x13,
+    3,0xC7,0x12,0x11,
+    3,0xC8,0x10,0x2D,
+    3,0xC9,0x01,0x08,
+    3,0xCA,0x09,0x31,
+    3,0xCB,0x31,0x31,
+    3,0xCC,0x31,0x31,
+    3,0xCD,0x31,0x31,
+    3,0xCE,0x31,0x31,
+    3,0xCF,0x31,0x31,
+    3,0xD0,0x31,0x31,
+    3,0xD1,0x31,0x09,
+    3,0xD2,0x08,0x01,
+    3,0xD3,0x2D,0x10,
+    3,0xD4,0x11,0x12,
+    3,0xD5,0x13,0x14,
+    3,0xD6,0x15,0x16,
+    3,0xD7,0x17,0x00,
+    3,0xE6,0x31,0x31,
+    6,0xD8,0x00,0x00,0x00,0x00,0x00, //VGL level select;
+    6,0xD9,0x00,0x00,0x00,0x00,0x00,
+    2,0xE7,0x00,
+
+    6,0xF0,0x55,0xAA,0x52,0x08,0x03, //gate timing control
+    3,0xB0,0x20,0x00,
+    3,0xB1,0x20,0x00,
+    6,0xB2,0x05,0x00,0x68,0x00,0x00,
+    6,0xB6,0x05,0x00,0x68,0x00,0x00,
+    6,0xBA,0x53,0x00,0x68,0x00,0x00,
+    6,0xBB,0x53,0x00,0x68,0x00,0x00,
+    2,0xC4,0x40,
+
+    3,0xB0,0x01,0x01, //gate CLK EQ
+    3,0xB1,0x01,0x01, //gate STV EQ
+
+    6,0xF0,0x55,0xAA,0x52,0x08,0x05,
+    3,0xB0,0x17,0x06,
+    2,0xB8,0x00,
+    6,0xBD,0x03,0x01,0x01,0x00,0x01,
+    3,0xB1,0x17,0x06,
+    3,0xB9,0x00,0x01,
+    3,0xB2,0x17,0x06,
+    3,0xBA,0x00,0x01,
+    3,0xB3,0x17,0x06,
+    3,0xBB,0x0A,0x00,
+    3,0xB4,0x17,0x06,
+    3,0xB5,0x17,0x06,
+    3,0xB6,0x14,0x03,
+    3,0xB7,0x00,0x00,
+    3,0xBC,0x02,0x01,
+    2,0xC0,0x05,
+    2,0xC4,0xA5,
+    3,0xC8,0x03,0x30,
+    3,0xC9,0x03,0x51,
+    6,0xD1,0x03,0x00,0x00,0x00,0x10,
+    6,0xD2,0x03,0x00,0x00,0x00,0x10,
+    2,0xE5,0x02,
+    2,0xE6,0x02,
+    2,0xE7,0x02,
+    2,0xE9,0x02,
+    2,0xED,0x33,
+
+    2,0x6F,0x11, //reload setting
+    2,0xF3,0x01,
+    0xff,0xff,   //ending flag
+};
+
+static int lcd_extern_driver_update(void)
+{
+    struct aml_lcd_extern_driver_t* lcd_ext;
+
+    lcd_ext = aml_lcd_extern_get_driver();
+    if (lcd_ext) {
+        lcd_ext->type       = lcd_ext_config->type;
+        lcd_ext->name       = lcd_ext_config->name;
+        lcd_ext->init_on_cmd_8 = &mipi_init_table[0];
+    }
+    else {
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_config->name);
+    }
+
+    return 0;
+}
+
+static int aml_N070ICN_probe(struct platform_device *pdev)
+{
+    int i = 0;
+
+    if (lcd_extern_driver_check()) {
+        return -1;
+    }
+    if (lcd_ext_config == NULL)
+        lcd_ext_config = kzalloc(sizeof(*lcd_ext_config), GFP_KERNEL);
+    if (lcd_ext_config == NULL) {
+        printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
+        return -1;
+    }
+
+    pdev->dev.platform_data = lcd_ext_config;
+
+    if (get_lcd_extern_dt_data(pdev->dev.of_node, lcd_ext_config) != 0) {
+        printk("[error] %s probe: failed to get dt data\n", LCD_EXTERN_NAME);
+        goto lcd_extern_probe_failed;
+    }
+    lcd_extern_driver_update();
+
+    printk("%s probe ok\n", LCD_EXTERN_NAME);
+    return 0;
+
+lcd_extern_probe_failed:
+    if (lcd_ext_config)
+        kfree(lcd_ext_config);
+    return -1;
+}
+
+static int aml_N070ICN_remove(struct platform_device *pdev)
+{
+    if (pdev->dev.platform_data)
+        kfree (pdev->dev.platform_data);
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_N070ICN_dt_match[]={
+    {
+        .compatible = "amlogic,lcd_mipi_N070ICN",
+    },
+    {},
+};
+#else
+#define aml_N070ICN_dt_match NULL
+#endif
+
+static struct platform_driver aml_N070ICN_driver = {
+    .probe  = aml_N070ICN_probe,
+    .remove = aml_N070ICN_remove,
+    .driver = {
+        .name  = LCD_EXTERN_NAME,
+        .owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+        .of_match_table = aml_N070ICN_dt_match,
+#endif
+    },
+};
+
+static int __init aml_N070ICN_init(void)
+{
+    int ret;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    ret = platform_driver_register(&aml_N070ICN_driver);
+    if (ret) {
+        printk("[error] %s failed to register lcd extern driver module\n", __FUNCTION__);
+        return -ENODEV;
+    }
+
+    return ret;
+}
+
+static void __exit aml_N070ICN_exit(void)
+{
+    platform_driver_unregister(&aml_N070ICN_driver);
+}
+
+//late_initcall(aml_N070ICN_init);
+module_init(aml_N070ICN_init);
+module_exit(aml_N070ICN_exit);
+
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("LCD Extern driver for N070ICN");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c b/drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c
new file mode 100755
index 000000000000..e5bf64e38081
--- /dev/null
+++ b/drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c
@@ -0,0 +1,275 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * SPI 
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h> 
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+
+static struct lcd_extern_config_t *lcd_ext_config = NULL;
+
+//#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+#define LCD_EXTERN_NAME			"lcd_spi_LD070WS2"
+
+#define SPI_DELAY		30 //unit: us
+
+static unsigned char spi_init_table[][2] = {
+    {0x00,0x21},  //reset
+    {0x00,0xa5},  //standby
+    {0x01,0x30},  //enable FRC/Dither
+    {0x02,0x40},  //enable normally black
+    {0x0e,0x5f},  //enable test mode1
+    {0x0f,0xa4},  //enable test mode2
+    {0x0d,0x00},  //enable SDRRS, enlarge OE width
+    {0x02,0x43},  //adjust charge sharing time
+    {0x0a,0x28},  //trigger bias reduction
+    {0x10,0x41},  //adopt 2 line/1 dot
+    {0xff,50},    //delay 50ms
+    {0x00,0xad},  //display on
+    {0xff,0xff},  //ending flag
+};
+
+static unsigned char spi_off_table[][2] = {
+    {0x00,0xa5},  //standby
+    {0xff,0xff},
+};
+
+static void set_lcd_csb(unsigned v)
+{
+    lcd_extern_gpio_direction_output(lcd_ext_config->spi_cs, v);
+    udelay(SPI_DELAY);
+}
+
+static void set_lcd_scl(unsigned v)
+{
+    lcd_extern_gpio_direction_output(lcd_ext_config->spi_clk, v);
+    udelay(SPI_DELAY);
+}
+    
+static void set_lcd_sda(unsigned v)
+{
+    lcd_extern_gpio_direction_output(lcd_ext_config->spi_data, v);
+    udelay(SPI_DELAY);
+}
+
+static void spi_gpio_init(void)
+{
+    set_lcd_csb(1);
+    set_lcd_scl(1);
+    set_lcd_sda(1);
+}
+
+static void spi_gpio_off(void)
+{
+    set_lcd_sda(0);
+    set_lcd_scl(0);
+    set_lcd_csb(0);
+}
+
+static void spi_write_8(unsigned char addr, unsigned char data)
+{
+    int i;
+    unsigned int sdata;
+
+    sdata = (unsigned int)(addr & 0x3f);
+    sdata <<= 10;
+    sdata |= (data & 0xff);
+    sdata &= ~(1<<9); //write flag
+
+    set_lcd_csb(1);
+    set_lcd_scl(1);
+    set_lcd_sda(1);
+
+    set_lcd_csb(0);
+    for (i = 0; i < 16; i++) {
+        set_lcd_scl(0);
+        if (sdata & 0x8000)
+            set_lcd_sda(1);
+        else
+            set_lcd_sda(0);
+        sdata <<= 1;
+        set_lcd_scl(1);
+    }
+
+    set_lcd_csb(1);
+    set_lcd_scl(1);
+    set_lcd_sda(1);
+    udelay(SPI_DELAY);
+}
+
+static void lcd_extern_spi_init(void)
+{
+    int ending_flag = 0;
+    int i=0;
+
+    spi_gpio_init();
+
+    while(ending_flag == 0) {
+        if (spi_init_table[i][0] == 0xff) {
+            if (spi_init_table[i][1] == 0xff)
+                ending_flag = 1;
+            else
+                mdelay(spi_init_table[i][1]);
+        }
+        else {
+            spi_write_8(spi_init_table[i][0], spi_init_table[i][1]);
+        }
+        i++;
+    }
+    printk("%s\n", __FUNCTION__);
+}
+
+static void lcd_extern_spi_off(void)
+{
+    int ending_flag = 0;
+    int i=0;
+
+    spi_gpio_init();
+
+    while(ending_flag == 0) {
+        if (spi_off_table[i][0] == 0xff) {
+            if (spi_off_table[i][1] == 0xff)
+                ending_flag = 1;
+            else
+                mdelay(spi_off_table[i][1]);
+        }
+        else {
+            spi_write_8(spi_off_table[i][0], spi_off_table[i][1]);
+        }
+        i++;
+    }
+    printk("%s\n", __FUNCTION__);
+    mdelay(10);
+    spi_gpio_off();
+}
+
+static int lcd_extern_driver_update(void)
+{
+    struct aml_lcd_extern_driver_t* lcd_ext;
+
+    lcd_ext = aml_lcd_extern_get_driver();
+    if (lcd_ext) {
+        lcd_ext->type       = lcd_ext_config->type;
+        lcd_ext->name       = lcd_ext_config->name;
+        lcd_ext->power_on   = lcd_extern_spi_init;
+        lcd_ext->power_off  = lcd_extern_spi_off;
+    }
+    else {
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_config->name);
+    }
+
+    return 0;
+}
+
+static int aml_LD070WS2_probe(struct platform_device *pdev)
+{
+    int i = 0;
+
+    if (lcd_extern_driver_check()) {
+        return -1;
+    }
+    if (lcd_ext_config == NULL)
+        lcd_ext_config = kzalloc(sizeof(*lcd_ext_config), GFP_KERNEL);
+    if (lcd_ext_config == NULL) {
+        printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
+        return -1;
+    }
+
+    pdev->dev.platform_data = lcd_ext_config;
+
+    if (get_lcd_extern_dt_data(pdev->dev.of_node, lcd_ext_config) != 0) {
+        printk("[error] %s probe: failed to get dt data\n", LCD_EXTERN_NAME);
+        goto lcd_extern_probe_failed;
+    }
+    lcd_extern_driver_update();
+
+    printk("%s probe ok\n", LCD_EXTERN_NAME);
+    return 0;
+
+lcd_extern_probe_failed:
+    if (lcd_ext_config)
+        kfree(lcd_ext_config);
+    return -1;
+}
+
+static int aml_LD070WS2_remove(struct platform_device *pdev)
+{
+    if (pdev->dev.platform_data)
+        kfree (pdev->dev.platform_data);
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_LD070WS2_dt_match[]={
+    {
+        .compatible = "amlogic,lcd_spi_LD070WS2",
+    },
+    {},
+};
+#else
+#define aml_LD070WS2_dt_match NULL
+#endif
+
+static struct platform_driver aml_LD070WS2_driver = {
+    .probe  = aml_LD070WS2_probe,
+    .remove = aml_LD070WS2_remove,
+    .driver = {
+        .name  = LCD_EXTERN_NAME,
+        .owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+        .of_match_table = aml_LD070WS2_dt_match,
+#endif
+    },
+};
+
+static int __init aml_LD070WS2_init(void)
+{
+    int ret;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    ret = platform_driver_register(&aml_LD070WS2_driver);
+    if (ret) {
+        printk("[error] %s failed to register lcd extern driver module\n", __FUNCTION__);
+        return -ENODEV;
+    }
+    return ret;
+}
+
+static void __exit aml_LD070WS2_exit(void)
+{
+    platform_driver_unregister(&aml_LD070WS2_driver);
+}
+
+//late_initcall(aml_LD070WS2_init);
+module_init(aml_LD070WS2_init);
+module_exit(aml_LD070WS2_exit);
+
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("LCD Extern driver for LD070WS2");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/vout/lcd_extern/tc101.c b/drivers/amlogic/display/vout/lcd_extern/tc101.c
deleted file mode 100755
index 9ef5c608c8c9..000000000000
--- a/drivers/amlogic/display/vout/lcd_extern/tc101.c
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * AMLOGIC lcd external driver.
- *
- * Communication protocol:
- * I2C 
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/jiffies.h> 
-#include <linux/i2c.h>
-#include <linux/i2c-aml.h>
-#include <linux/miscdevice.h>
-#include <linux/mutex.h>
-#include <linux/mm.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/delay.h>
-#include <linux/sysctl.h>
-#include <asm/uaccess.h>
-#include <mach/pinmux.h>
-#include <mach/gpio.h>
-#include <linux/platform_device.h>
-#include <linux/amlogic/vout/aml_lcd_extern.h>
-
-static struct i2c_client *aml_tc101_client;
-extern struct aml_lcd_extern_driver_t lcd_ext_driver;
-
-#define LCD_EXTERN_NAME			"lcd_tc101"
-
-static unsigned char tc101_init_table[][3] = {
-	//{0xff, 0xff, 20},//delay mark(20ms)
-	{0xf8, 0x30, 0xb2},
-	{0xf8, 0x33, 0xc2},
-	{0xf8, 0x31, 0xf0},
-	{0xf8, 0x40, 0x80},
-	{0xf8, 0x81, 0xec},
-	{0xff, 0xff, 0xff},//end mark
-};
-
-static int aml_lcd_i2c_write(struct i2c_client *i2client,unsigned char *buff, unsigned len)
-{
-    int res = 0;
-    struct i2c_msg msg[] = {
-        {
-        .addr = i2client->addr,
-        .flags = 0,
-        .len = len,
-        .buf = buff,
-        }
-    };
-	
-    res = i2c_transfer(i2client->adapter, msg, 1);
-    if (res < 0) {
-        printk("%s: i2c transfer failed [addr 0x%02x]\n", __FUNCTION__, i2client->addr);
-    }
-    
-    return res;
-}
-
-static int aml_lcd_i2c_read(struct i2c_client *i2client,unsigned char *buff, unsigned len)
-{
-    int res = 0;
-    struct i2c_msg msgs[] = {
-        {
-            .addr = i2client->addr,
-            .flags = 0,
-            .len = 1,
-            .buf = buff,
-        },
-        {
-            .addr = i2client->addr,
-            .flags = I2C_M_RD,
-            .len = len,
-            .buf = buff,
-        }
-    };
-    res = i2c_transfer(i2client->adapter, msgs, 2);
-    if (res < 0) {
-        printk("%s: i2c transfer failed [addr 0x%02x]\n", __FUNCTION__, i2client->addr);
-    }
-
-    return res;
-}
-
-static int tc101_reg_read(unsigned char reg, unsigned char *buf)
-{
-	int ret=0;
-
-	return ret;
-}
-
-static int tc101_reg_write(unsigned char reg, unsigned char value)
-{
-	int ret=0;
-	
-	return ret;
-}
-
-static int tc101_init(void)
-{
-	unsigned char tData[4];
-	int i=0, end_mark=0;
-	int ret=0;
-	
-	while (end_mark == 0) {
-		if ((tc101_init_table[i][0] == 0xff) && (tc101_init_table[i][1] == 0xff)) {	//special mark
-			if (tc101_init_table[i][2] == 0xff) {	//end mark
-				end_mark = 1;
-			}
-			else {	//delay mark
-				mdelay(tc101_init_table[i][2]);
-			}
-		}
-		else {
-			tData[0]=tc101_init_table[i][0];
-			tData[1]=tc101_init_table[i][1];
-			tData[2]=tc101_init_table[i][2];
-			aml_lcd_i2c_write(aml_tc101_client, tData, 3);
-		}
-		i++;
-	}
-	printk("%s\n", __FUNCTION__);
-	return ret;
-}
-
-static int tc101_remove(void)
-{
-	int ret=0;
-	
-	return ret;
-}
-
-static int aml_lcd_extern_driver_update(struct aml_lcd_extern_driver_t* lcd_ext)
-{
-	lcd_ext->name = LCD_EXTERN_NAME;
-	lcd_ext->reg_read = tc101_reg_read;
-	lcd_ext->reg_write = tc101_reg_write;
-	lcd_ext->power_on = tc101_init;
-	lcd_ext->power_off = tc101_remove;
-	
-	return 0;
-}
-
-static int aml_tc101_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	int ret;
-	
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		printk("%s: functionality check failed\n", __FUNCTION__);
-		return -ENODEV;
-	} else {
-		aml_tc101_client = client;
-		aml_lcd_extern_driver_update(&lcd_ext_driver);
-	}
-
-	printk("%s OK\n", __FUNCTION__);
-
-	return 0;
-}
-
-static int aml_tc101_remove(struct i2c_client *client)
-{
-	return 0;
-}
-
-static const struct i2c_device_id aml_tc101_id[] = {
-	{LCD_EXTERN_NAME, 0},
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, aml_tc101_id);
-
-static struct i2c_driver aml_tc101_driver = {
-	.probe    = aml_tc101_probe,
-	.remove   = aml_tc101_remove,
-	.id_table = aml_tc101_id,
-	.driver = {
-		.name = LCD_EXTERN_NAME,
-		.owner =THIS_MODULE,
-	},
-};
-
-static int __init aml_tc101_init(void)
-{
-	int ret = 0;
-	//printk("%s\n", __FUNCTION__);
-
-	ret = i2c_add_driver(&aml_tc101_driver);
-	if (ret) {
-		printk("failed to register aml_tc101_driver\n");
-		return -ENODEV;
-	}
-
-	return ret;
-}
-
-static void __exit aml_tc101_exit(void)
-{
-	i2c_del_driver(&aml_tc101_driver);
-}
-
-//late_initcall(aml_tc101_init);
-module_init(aml_tc101_init);
-module_exit(aml_tc101_exit);
-
-MODULE_AUTHOR("AMLOGIC");
-MODULE_DESCRIPTION("LCD Extern driver for TC101");
-MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index 4d5aee154827..88411e631b1f 100755
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -68,16 +68,15 @@
 
 #define VPP_OUT_SATURATE	(1 << 0)
 
+#define PANEL_NAME		"panel"
+
 #define FIQ_VSYNC
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 #define DRV_TYPE "c6"
 #else
 #define DRV_TYPE "c8"
 #endif
-
-#define PANEL_NAME		"panel"
-#define DRIVER_DATE		"20140212"
-#define DRIVER_VER		"310"
+#define DRIVER_DATE		"20140325"
 
 //#define LCD_DEBUG_INFO
 #ifdef LCD_DEBUG_INFO
@@ -87,6 +86,7 @@
 #endif
 
 unsigned int vpp2_sel = 0; /*0,vpp; 1, vpp2 */
+unsigned int lcd_status_flag = 1;
 
 typedef struct {
 	Lcd_Config_t *pConf;
@@ -109,16 +109,23 @@ int bl_status = 1;
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 static DSI_Config_t lcd_mipi_config = {
-	//to do
+    .lane_num = 4,
+    .bit_rate_min = 0,
+    .bit_rate_max = 0,
+    .transfer_ctrl = 0,
+    .init_on_flag = 0,
+    .init_off_flag = 0,
+    .sleep_out_delay = 10,
+    .display_on_delay = 10,
 };
 
 static EDP_Config_t lcd_edp_config = {
 	.link_user = 0,
-	.link_rate = VAL_EDP_TX_LINK_BW_SET_270,
+	.link_rate = 1,
 	.lane_count = 4,
 	.link_adaptive = 0,
-	.vswing = VAL_EDP_TX_PHY_VSWING_0,
-	.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_0,
+	.vswing = 0,
+	.preemphasis = 0,
 };
 #endif
 
@@ -134,43 +141,58 @@ static TTL_Config_t lcd_ttl_config = {
 	.bit_swap = 0,
 };
 
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
+static MLVDS_Config_t lcd_mlvds_config = {
+    .mlvds_insert_start = 0x45,
+    .total_line_clk = 1448,
+    .test_dual_gate = 1,
+    .test_pair_num = 6,
+    .scan_function = 1,
+    .phase_select = 1,
+    .TL080_phase =3,
+};
+#endif
+
 static Lcd_Config_t lcd_config = {
-	.lcd_timing = {
-		.lcd_clk = 40000000,
-		.clk_ctrl = (1<<CLK_CTRL_AUTO) | (1<<CLK_CTRL_VCLK_SEL) | (7<<CLK_CTRL_XD),
-		.video_on_pixel = 80,
-		.video_on_line = 32,
-		.hvsync_valid = 0,
-		.de_valid = 1,
-		.pol_cntl_addr = (0 << LCD_CPH1_POL) |(0 << LCD_HS_POL) | (0 << LCD_VS_POL),
-		.inv_cnt_addr = (0 << LCD_INV_EN) | (0 << LCD_INV_CNT),
-		.tcon_misc_sel_addr = (1 << LCD_STV1_SEL) | (1 << LCD_STV2_SEL),
-	},
-	.lcd_effect = {
-		.gamma_cntl_port = (1 << LCD_GAMMA_EN),
-		.rgb_base_addr = 0xf0,
-		.rgb_coeff_addr = 0x74a,
-		.dith_user = 0,
-		.vadj_brightness = 0x0,
-		.vadj_contrast = 0x80,
-		.vadj_saturation = 0x100,
-		.gamma_revert = 0,
-		.gamma_r_coeff = 100,
-		.gamma_g_coeff = 100,
-		.gamma_b_coeff = 100,
-	},
-	.lcd_control = {
+    .lcd_timing = {
+        .lcd_clk = 40000000,
+        .clk_ctrl = (1<<CLK_CTRL_AUTO) | (1<<CLK_CTRL_VCLK_SEL) | (7<<CLK_CTRL_XD),
+        .video_on_pixel = 120,
+        .video_on_line = 32,
+        .hvsync_valid = 1,
+        .de_valid = 1,
+        .pol_cntl_addr = (0 << LCD_CPH1_POL) |(0 << LCD_HS_POL) | (0 << LCD_VS_POL),
+        .inv_cnt_addr = (0 << LCD_INV_EN) | (0 << LCD_INV_CNT),
+        .tcon_misc_sel_addr = (1 << LCD_STV1_SEL) | (1 << LCD_STV2_SEL),
+    },
+    .lcd_effect = {
+        .gamma_cntl_port = (1 << LCD_GAMMA_EN),
+        .rgb_base_addr = 0xf0,
+        .rgb_coeff_addr = 0x74a,
+        .dith_user = 0,
+        .vadj_brightness = 0x0,
+        .vadj_contrast = 0x80,
+        .vadj_saturation = 0x100,
+        .gamma_revert = 0,
+        .gamma_r_coeff = 100,
+        .gamma_g_coeff = 100,
+        .gamma_b_coeff = 100,
+    },
+    .lcd_control = {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		.mipi_config = &lcd_mipi_config,
-		.edp_config = &lcd_edp_config,
+        .mipi_config = &lcd_mipi_config,
+        .edp_config = &lcd_edp_config,
 #endif
-		.lvds_config = &lcd_lvds_config,
-		.ttl_config = &lcd_ttl_config,
-	},
-	.lcd_power_ctrl = {
-		.power_on_step = 0,
-		.power_off_step = 0,
-	}
+        .lvds_config = &lcd_lvds_config,
+        .ttl_config = &lcd_ttl_config,
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
+        .mlvds_config = &lcd_mlvds_config,
+#endif
+    },
+    .lcd_power_ctrl = {
+        .power_on_step = 0,
+        .power_off_step = 0,
+    }
 };
 
 static void lcd_setup_gamma_table(Lcd_Config_t *pConf, unsigned int rgb_flag)
@@ -241,10 +263,40 @@ static void lcd_ports_ctrl_lvds(Bool_t status)
 		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
 #endif
 	}
+
 	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
 }
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+static void lcd_ports_ctrl_mipi(Bool_t status)
+{
+    if (status) {
+        switch (pDev->pConf->lcd_control.mipi_config->lane_num) {
+            case 1:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x11, 11, 5);
+                break;
+            case 2:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x19, 11, 5);
+                break;
+            case 3:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1d, 11, 5);
+                break;
+            case 4:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);
+                break;
+            default:
+                break;
+        }
+    }
+    else {
+        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
+        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
+        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
+    }
+
+    DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
 static void lcd_ports_ctrl_edp(Bool_t status)
 {
 	if (status) {
@@ -285,7 +337,7 @@ static void lcd_ports_ctrl_ttl(Bool_t status)
 	if (pDev->pConf->lcd_basic.lcd_bits == 6) {
 			if (pDev->pConf->lcd_timing.de_valid == 0) {
 				s = pinctrl_lookup_state(pDev->p, "ttl_6bit_hvsync_on");
-			}	
+			}
 			else if (pDev->pConf->lcd_timing.hvsync_valid == 0) {
 				s = pinctrl_lookup_state(pDev->p, "ttl_6bit_de_on");
 			}
@@ -293,7 +345,7 @@ static void lcd_ports_ctrl_ttl(Bool_t status)
 				s = pinctrl_lookup_state(pDev->p, "ttl_6bit_hvsync_de_on");	//select pinmux
 			}
 		}
-		else {	
+		else {
 			if (pDev->pConf->lcd_timing.de_valid == 0) {
 				s = pinctrl_lookup_state(pDev->p, "ttl_8bit_hvsync_on");
 			}	
@@ -337,42 +389,43 @@ static void lcd_ports_ctrl_ttl(Bool_t status)
 			return;
 		}
 	}
+
 	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
 }
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 static void lcd_ports_ctrl_mlvds(Bool_t status)
 {
-	//to do
+	return;
 }
 #endif
 
 static void lcd_ports_ctrl(Bool_t status)
-{	
-	switch(pDev->pConf->lcd_basic.lcd_type) {
+{
+    switch(pDev->pConf->lcd_basic.lcd_type) {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-                        lcd_ports_ctrl_mipi( pDev->pConf, status);
-			break;
-		case LCD_DIGITAL_EDP:
-			lcd_ports_ctrl_edp(status);
-			break;
+        case LCD_DIGITAL_MIPI:
+            lcd_ports_ctrl_mipi(status);
+            break;
+        case LCD_DIGITAL_EDP:
+            lcd_ports_ctrl_edp(status);
+            break;
 #endif
-		case LCD_DIGITAL_LVDS:
-			lcd_ports_ctrl_lvds(status);
-			break;		
-		case LCD_DIGITAL_TTL:
-			lcd_ports_ctrl_ttl(status);
-			break;
+        case LCD_DIGITAL_LVDS:
+            lcd_ports_ctrl_lvds(status);
+            break;
+        case LCD_DIGITAL_TTL:
+            lcd_ports_ctrl_ttl(status);
+            break;
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
-			lcd_ports_ctrl_mlvds(status);
-			break;
+        case LCD_DIGITAL_MINILVDS:
+            lcd_ports_ctrl_mlvds(status);
+            break;
 #endif
-		default:
-			printk("Invalid LCD type.\n");
-			break;
-	}
+        default:
+            printk("Invalid LCD type.\n");
+            break;
+    }
 }
 
 static void backlight_power_ctrl(Bool_t status)
@@ -391,9 +444,47 @@ static void backlight_power_ctrl(Bool_t status)
 	bl_status = status;
 }
 
-static void lcd_power_ctrl(Bool_t status)
+static int set_control_edp(Lcd_Config_t *pConf);
+static int lcd_power_ctrl_video(Bool_t status) //for special interface
+{
+    int ret = 0;
+
+    if (status) {
+        switch(pDev->pConf->lcd_basic.lcd_type) {
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+            case LCD_DIGITAL_MIPI:
+                mipi_dsi_link_on(pDev->pConf);
+                break;
+            case LCD_DIGITAL_EDP:
+                ret = set_control_edp(pDev->pConf);
+                break;
+#endif
+            default:
+                break;
+        }
+    }
+    else {
+        switch(pDev->pConf->lcd_basic.lcd_type) {
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+            case LCD_DIGITAL_MIPI:
+                mipi_dsi_link_off(pDev->pConf);  //link off command
+                break;
+            case LCD_DIGITAL_EDP:
+                ret = dplpm_link_off();  //link off command
+                break;
+#endif
+            default:
+                break;
+        }
+    }
+    DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+    return ret;
+}
+
+static int lcd_power_ctrl(Bool_t status)
 {
 	int i;
+	int ret = 0;
 #ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
 	struct aml_pmu_driver *pmu_driver;
 #endif
@@ -443,9 +534,10 @@ static void lcd_power_ctrl(Bool_t status)
 						printk("no lcd_extern driver\n");
 					}
 					else {
-						if (lcd_extern_driver->power_on)
+						if (lcd_extern_driver->power_on) {
 							lcd_extern_driver->power_on();
-						DBG_PRINT("%s power on\n", lcd_extern_driver->name);
+							printk("%s power on init\n", lcd_extern_driver->name);
+						}
 					}
 #endif
 					break;
@@ -456,9 +548,11 @@ static void lcd_power_ctrl(Bool_t status)
 			if (pDev->pConf->lcd_power_ctrl.power_on_config[i].delay > 0)
 				lcd_mdelay(pDev->pConf->lcd_power_ctrl.power_on_config[i].delay);
 		}
+		ret = lcd_power_ctrl_video(ON);
 	}
 	else {
 		lcd_mdelay(30);
+		ret = lcd_power_ctrl_video(OFF);
 		for (i=0; i<pDev->pConf->lcd_power_ctrl.power_off_step; i++) {
 			DBG_PRINT("%s %s step %d\n", __FUNCTION__, (status ? "ON" : "OFF"), i+1);
 			switch (pDev->pConf->lcd_power_ctrl.power_off_config[i].type) {
@@ -499,9 +593,10 @@ static void lcd_power_ctrl(Bool_t status)
 						printk("no lcd_extern driver\n");
 					}
 					else {
-						if (lcd_extern_driver->power_off)
+						if (lcd_extern_driver->power_off) {
 							lcd_extern_driver->power_off();
-						DBG_PRINT("%s power on\n", lcd_extern_driver->name);
+							printk("%s power off init\n", lcd_extern_driver->name);
+						}
 					}
 #endif
 					break;
@@ -513,7 +608,9 @@ static void lcd_power_ctrl(Bool_t status)
 				lcd_mdelay(pDev->pConf->lcd_power_ctrl.power_off_config[i].delay);
 		}
 	}
+
 	printk("%s(): %s finished.\n", __FUNCTION__, (status ? "ON" : "OFF"));
+	return ret;
 }
 #endif
 
@@ -1319,115 +1416,77 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
 {
     unsigned pll_reg, div_reg, clk_reg;
     int vclk_sel, xd;
-	int lcd_type, ss_level;
-	unsigned pll_div_post = 0, phy_clk_div2 = 0;
+    int lcd_type, ss_level;
+    unsigned pll_div_post = 0, phy_clk_div2 = 0;
 
-	DBG_PRINT("%s\n", __FUNCTION__);
-	
-	pll_reg = pConf->lcd_timing.pll_ctrl;
-	div_reg = pConf->lcd_timing.div_ctrl;
-	clk_reg = pConf->lcd_timing.clk_ctrl;
-	ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
-	vclk_sel = (clk_reg >> CLK_CTRL_VCLK_SEL) & 0x1;
-	xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
+    DBG_PRINT("%s\n", __FUNCTION__);
 
-	lcd_type = pConf->lcd_basic.lcd_type;
-	switch(lcd_type){
+    pll_reg = pConf->lcd_timing.pll_ctrl;
+    div_reg = pConf->lcd_timing.div_ctrl;
+    clk_reg = pConf->lcd_timing.clk_ctrl;
+    ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
+    vclk_sel = (clk_reg >> CLK_CTRL_VCLK_SEL) & 0x1;
+    xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
+
+    lcd_type = pConf->lcd_basic.lcd_type;
+
+    switch(lcd_type){
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-			break;
-		case LCD_DIGITAL_EDP:
-			xd = 1;
-			break;
+        case LCD_DIGITAL_MIPI:
+            break;
+        case LCD_DIGITAL_EDP:
+            xd = 1;
+            break;
 #endif
-		case LCD_DIGITAL_LVDS:
-			xd = 1;
-			pll_div_post = 7;
-			phy_clk_div2 = 0;
-			div_reg = (div_reg | (1 << 8) | (1 << 11) | ((pll_div_post-1) << 12) | (phy_clk_div2 << 10));
-			break;
-		case LCD_DIGITAL_TTL:
-			break;
-		default:
-			break;
-	}
-	
-	DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
+        case LCD_DIGITAL_LVDS:
+            xd = 1;
+            pll_div_post = 7;
+            phy_clk_div2 = 0;
+            div_reg = (div_reg | (1 << DIV_CTRL_POST_SEL) | (1 << DIV_CTRL_LVDS_CLK_EN) | ((pll_div_post-1) << DIV_CTRL_DIV_POST) | (phy_clk_div2 << DIV_CTRL_PHY_CLK_DIV2));
+            break;
+        case LCD_DIGITAL_TTL:
+            break;
+        default:
+            break;
+    }
+    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
+
+    DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
     vclk_set_lcd(lcd_type, vclk_sel, pll_reg, div_reg, clk_reg);
-	set_lcd_spread_spectrum(ss_level);
-	
-	switch(lcd_type){
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-			WRITE_LCD_REG(MIPI_DSI_TOP_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0x7<<4))   |
-							  (1  << 4)               |
-							  (1  << 5)               |
-							  (0  << 6));
-			WRITE_CBUS_REG( HHI_DSI_LVDS_EDP_CNTL0, 0x0);                                          // Select DSI as the output for u_dsi_lvds_edp_top
-			WRITE_LCD_REG( MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) | 0xf) );     // Release mipi_dsi_host's reset
-			WRITE_LCD_REG( MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) & 0xfffffff0) );     // Release mipi_dsi_host's reset
-			WRITE_LCD_REG( MIPI_DSI_TOP_CLK_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CLK_CNTL) | 0x3) );            // Enable dwc mipi_dsi_host's clock                   
-			break;
-		case LCD_DIGITAL_EDP:
-			break;
-#endif
-		case LCD_DIGITAL_LVDS:
-			clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
-			//    lvds_gen_cntl       <= {10'h0,      // [15:4] unused
-			//                            2'h1,       // [5:4] divide by 7 in the PHY
-			//                            1'b0,       // [3] fifo_en
-			//                            1'b0,       // [2] wr_bist_gate
-			//                            2'b00};     // [1:0] fifo_wr mode
-			//FIFO_CLK_SEL = 1; // div7
-			WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 4, 2);	//lvds fifo clk div 7
-
-			WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 0, 15, 1);	// lvds div reset
-			udelay(5);
-			WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 15, 1);	// Release lvds div reset
-			break;
-		case LCD_DIGITAL_TTL:
-			break;
-		default:
-			break;
-	}
-}
+    set_lcd_spread_spectrum(ss_level);
 
+    switch(lcd_type){
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-void set_pll_mipi(Lcd_Config_t *pConf)
-{
-	unsigned pll_reg, div_reg, clk_reg, xd;
-	int vclk_sel;
-	int lcd_type, ss_level;
-
-	//DSI_Config_t *cfg = pConf->lcd_control.mipi_config;
-
-	// Configure VS/HS/DE polarity before mipi_dsi_host.pixclk starts,
-	WRITE_LCD_REG(MIPI_DSI_TOP_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0x7<<4))   |
-					  (1  << 4)               |
-					  (1  << 5)               |
-					  (0  << 6));
-
-	pll_reg = pConf->lcd_timing.pll_ctrl;
-	div_reg = pConf->lcd_timing.div_ctrl;
-	clk_reg = pConf->lcd_timing.clk_ctrl;
-	ss_level = ((clk_reg >> CLK_CTRL_SS) & 0xf);
-	vclk_sel = (clk_reg >> CLK_CTRL_VCLK_SEL) & 0x1;
-	xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
-
-	lcd_type = pConf->lcd_basic.lcd_type;
-
-	DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
-	vclk_set_lcd(lcd_type, vclk_sel, pll_reg, div_reg, clk_reg);
-	set_lcd_spread_spectrum(ss_level);
-
-	//startup_mipi_dsi_host()
-	WRITE_CBUS_REG( HHI_DSI_LVDS_EDP_CNTL0, 0x0);                                          // Select DSI as the output for u_dsi_lvds_edp_top
-	WRITE_LCD_REG( MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) | 0xf) );     // Release mipi_dsi_host's reset
-	WRITE_LCD_REG( MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) & 0xfffffff0) );     // Release mipi_dsi_host's reset
-	WRITE_LCD_REG( MIPI_DSI_TOP_CLK_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CLK_CNTL) | 0x3) );            // Enable dwc mipi_dsi_host's clock
-
-}
+        case LCD_DIGITAL_MIPI:
+            WRITE_LCD_REG(MIPI_DSI_TOP_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0x7<<4)) | (1 << 4) | (1 << 5) | (0 << 6));
+            //WRITE_LCD_CBUS_REG( HHI_DSI_LVDS_EDP_CNTL0, 0x0);                                          // Select DSI as the output for u_dsi_lvds_edp_top
+            WRITE_LCD_REG(MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) | 0xf) );     // Release mipi_dsi_host's reset
+            WRITE_LCD_REG(MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) & 0xfffffff0) );     // Release mipi_dsi_host's reset
+            WRITE_LCD_REG(MIPI_DSI_TOP_CLK_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CLK_CNTL) | 0x3) );            // Enable dwc mipi_dsi_host's clock 
+            break;
+        case LCD_DIGITAL_EDP:
+            break;
 #endif
+        case LCD_DIGITAL_LVDS:
+            clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
+            //    lvds_gen_cntl       <= {10'h0,      // [15:4] unused
+            //                            2'h1,       // [5:4] divide by 7 in the PHY
+            //                            1'b0,       // [3] fifo_en
+            //                            1'b0,       // [2] wr_bist_gate
+            //                            2'b00};     // [1:0] fifo_wr mode
+            //FIFO_CLK_SEL = 1; // div7
+            WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 4, 2);	//lvds fifo clk div 7
+
+            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 0, 15, 1);	// lvds div reset
+            udelay(5);
+            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 15, 1);	// Release lvds div reset
+            break;
+        case LCD_DIGITAL_TTL:
+            break;
+        default:
+            break;
+    }
+}
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 static void set_pll_mlvds(Lcd_Config_t *pConf)
@@ -1703,7 +1762,7 @@ static void set_venc_lcd(Lcd_Config_t *pConf)
 	lcd_type = pConf->lcd_basic.lcd_type;
 	
 	DBG_PRINT("%s\n",__FUNCTION__);
-	
+
 	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
 #ifdef CONFIG_AM_TV_OUTPUT2
 	if	(vpp2_sel) {
@@ -1740,8 +1799,7 @@ static void set_venc_lcd(Lcd_Config_t *pConf)
 
 	WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
 
-	// enable encl
-	WRITE_LCD_REG(ENCL_VIDEO_EN,			1);
+	WRITE_LCD_REG(ENCL_VIDEO_EN,			1);	// enable encl
 }
 
 static void set_control_lvds(Lcd_Config_t *pConf)
@@ -1750,7 +1808,7 @@ static void set_control_lvds(Lcd_Config_t *pConf)
 	unsigned data32;
 	
 	DBG_PRINT("%s\n", __FUNCTION__);
-	
+
 	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1); // disable lvds fifo
 	
     data32 = (0x00 << LVDS_blank_data_r) |
@@ -1802,6 +1860,11 @@ static void set_control_lvds(Lcd_Config_t *pConf)
 }
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+static void set_control_mipi(Lcd_Config_t *pConf)
+{
+    set_mipi_dsi_control(pConf);
+}
+
 //**************************************************//
 // for edp link maintain control
 //**************************************************//
@@ -1811,7 +1874,15 @@ unsigned edp_clk_config_update(unsigned char link_rate)
 {
 	unsigned bit_rate;
 	
-	pDev->pConf->lcd_control.edp_config->link_rate = link_rate;
+	switch (link_rate) {
+		case VAL_EDP_TX_LINK_BW_SET_162:
+			pDev->pConf->lcd_control.edp_config->link_rate = 0;
+			break;
+		case VAL_EDP_TX_LINK_BW_SET_270:
+		default:
+			pDev->pConf->lcd_control.edp_config->link_rate = 1;
+			break;
+	}
 	generate_clk_parameter(pDev->pConf);
 	lcd_sync_duration(pDev->pConf);
 	
@@ -1832,88 +1903,179 @@ unsigned edp_clk_config_update(unsigned char link_rate)
 
 void edp_phy_config_update(unsigned char vswing_tx, unsigned char preemp_tx)
 {
-	unsigned vswing_ctrl, preemphasis_ctrl;
-	
-	switch (vswing_tx) {
-		case VAL_EDP_TX_PHY_VSWING_0:	//0.4V
-			vswing_ctrl = 0x8018;	//0x8038;
-			break;
-		case VAL_EDP_TX_PHY_VSWING_1:	//0.6V
-			vswing_ctrl = 0x8088;
-			break;
-		case VAL_EDP_TX_PHY_VSWING_2:	//0.8V
-			vswing_ctrl = 0x80c8;
-			break;
-		case VAL_EDP_TX_PHY_VSWING_3:	//1.2V
-			vswing_ctrl = 0x80f8;
-			break;
-		default:
-			vswing_ctrl = 0x80f8;
-			break;
-	}
-	
-	switch (preemp_tx) {
-		case VAL_EDP_TX_PHY_PREEMPHASIS_0:	//0db
-		case VAL_EDP_TX_PHY_PREEMPHASIS_1:	//3.5db
-		case VAL_EDP_TX_PHY_PREEMPHASIS_2:	//6db
-		case VAL_EDP_TX_PHY_PREEMPHASIS_3:	//9.5db
-		default:
-			preemphasis_ctrl = 0x0;	//to do
-			break;
-	}
-	
-	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, vswing_ctrl);
-	printk("edp link adaptive: vswing=0x%02x, preemphasis=0x%02x\n", vswing_tx, preemp_tx);
+    unsigned vswing_ctrl, preemphasis_ctrl;
+
+    switch (vswing_tx) {
+        case 0:	//0.4V
+            vswing_ctrl = 0x8018;	//0x8038;
+            break;
+        case 1:	//0.6V
+            vswing_ctrl = 0x8088;
+            break;
+        case 2:	//0.8V
+            vswing_ctrl = 0x80c8;
+            break;
+        case 3:	//1.2V
+            vswing_ctrl = 0x80f8;
+            break;
+        default:
+            vswing_ctrl = 0x80f8;
+            break;
+    }
+
+    switch (preemp_tx) {
+        case 0:	//0db
+        case 1:	//3.5db
+        case 2:	//6db
+        case 3:	//9.5db
+        default:
+            preemphasis_ctrl = 0x0;	//to do
+            break;
+    }
+
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, vswing_ctrl);
+    printk("edp link adaptive: vswing=0x%02x, preemphasis=0x%02x\n", vswing_tx, preemp_tx);
 }
 //**************************************************//
 
 static int set_control_edp(Lcd_Config_t *pConf)
 {
-	int ret = 0;
-	EDP_Video_Mode_t  vm;
-	EDP_Link_Config_t link_config;
-	
-	DBG_PRINT("%s\n", __FUNCTION__);
-	//edp link config
-	link_config.max_lane_count = 4;
-	link_config.max_link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-	link_config.link_rate = pConf->lcd_control.edp_config->link_rate;
-	link_config.lane_count = pConf->lcd_control.edp_config->lane_count;
-	link_config.ss_level =((((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_SS) & 0xf) > 0 ? 1 : 0);
-	link_config.link_adaptive = pConf->lcd_control.edp_config->link_adaptive;
-	link_config.vswing = pConf->lcd_control.edp_config->vswing;
-	link_config.preemphasis = pConf->lcd_control.edp_config->preemphasis;
-	link_config.bit_rate = pConf->lcd_control.edp_config->bit_rate;
-	
-	//edp main stream attribute
-	vm.h_active = pConf->lcd_basic.h_active;
-	vm.v_active = pConf->lcd_basic.v_active;
-	vm.h_period = pConf->lcd_basic.h_period;
-	vm.v_period = pConf->lcd_basic.v_period;
-	vm.clk = pConf->lcd_timing.lcd_clk;
-	vm.hsync_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1;
-	vm.hsync_width = pConf->lcd_timing.hsync_width;
-	vm.hsync_bp = pConf->lcd_timing.hsync_bp;
-	vm.vsync_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1;
-	vm.vsync_width = pConf->lcd_timing.vsync_width;
-	vm.vsync_bp = pConf->lcd_timing.vsync_bp;
-	vm.de_hstart = pConf->lcd_timing.de_hstart;
-	vm.de_vstart = pConf->lcd_timing.de_vstart;
-	vm.ppc = 1;							//pixels per clock cycle
-	vm.cformat = 0;						//color format(0=RGB, 1=4:2:2, 2=Y only)
-	vm.bpc = pConf->lcd_basic.lcd_bits;	//bits per color
-	
-	//edp link maintain
-	ret = dplpm_link_policy_maker(&link_config, &vm);
-
-	//save feedback config by edp link maintain
-	pConf->lcd_control.edp_config->link_rate = link_config.link_rate;
-	pConf->lcd_control.edp_config->lane_count = link_config.lane_count;
-	pConf->lcd_control.edp_config->vswing = link_config.vswing;
-	pConf->lcd_control.edp_config->preemphasis = link_config.preemphasis;
-	pConf->lcd_control.edp_config->bit_rate = link_config.bit_rate;
-	
-	return ret;
+    int ret = 0;
+    EDP_Video_Mode_t  vm;
+    EDP_Link_Config_t link_config;
+
+    DBG_PRINT("%s\n", __FUNCTION__);
+    //edp link config
+    link_config.max_lane_count = 4;
+    link_config.max_link_rate = VAL_EDP_TX_LINK_BW_SET_270;
+    //link_config.link_rate = pConf->lcd_control.edp_config->link_rate;
+    link_config.lane_count = pConf->lcd_control.edp_config->lane_count;
+    link_config.ss_level =((((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_SS) & 0xf) > 0 ? 1 : 0);
+    link_config.link_adaptive = pConf->lcd_control.edp_config->link_adaptive;
+    //link_config.vswing = pConf->lcd_control.edp_config->vswing;
+    //link_config.preemphasis = pConf->lcd_control.edp_config->preemphasis;
+    link_config.bit_rate = pConf->lcd_control.edp_config->bit_rate;
+
+    switch (pConf->lcd_control.edp_config->link_rate) {
+        case 0:
+            link_config.link_rate = VAL_EDP_TX_LINK_BW_SET_162;
+            break;
+        case 1:
+            link_config.link_rate = VAL_EDP_TX_LINK_BW_SET_270;
+            break;
+        default:
+            link_config.link_rate = VAL_EDP_TX_LINK_BW_SET_270;
+            break;
+    }
+    switch (pConf->lcd_control.edp_config->vswing) {
+        case 0:
+            link_config.vswing = VAL_EDP_TX_PHY_VSWING_0;
+            break;
+        case 1:
+            link_config.vswing = VAL_EDP_TX_PHY_VSWING_1;
+            break;
+        case 2:
+            link_config.vswing = VAL_EDP_TX_PHY_VSWING_2;
+            break;
+        case 3:
+            link_config.vswing = VAL_EDP_TX_PHY_VSWING_3;
+            break;
+        default:
+            link_config.vswing = VAL_EDP_TX_PHY_VSWING_0;
+            break;
+    }
+    switch (pConf->lcd_control.edp_config->preemphasis) {
+        case 0:
+            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_0;
+            break;
+        case 1:
+            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_1;
+            break;
+        case 2:
+            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_2;
+            break;
+        case 3:
+            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_3;
+            break;
+        default:
+            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_0;
+            break;
+    }
+
+    //edp main stream attribute
+    vm.h_active = pConf->lcd_basic.h_active;
+    vm.v_active = pConf->lcd_basic.v_active;
+    vm.h_period = pConf->lcd_basic.h_period;
+    vm.v_period = pConf->lcd_basic.v_period;
+    vm.clk = pConf->lcd_timing.lcd_clk;
+    vm.hsync_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1;
+    vm.hsync_width = pConf->lcd_timing.hsync_width;
+    vm.hsync_bp = pConf->lcd_timing.hsync_bp;
+    vm.vsync_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1;
+    vm.vsync_width = pConf->lcd_timing.vsync_width;
+    vm.vsync_bp = pConf->lcd_timing.vsync_bp;
+    vm.de_hstart = pConf->lcd_timing.de_hstart;
+    vm.de_vstart = pConf->lcd_timing.de_vstart;
+    vm.ppc = 1;							//pixels per clock cycle
+    vm.cformat = 0;						//color format(0=RGB, 1=4:2:2, 2=Y only)
+    vm.bpc = pConf->lcd_basic.lcd_bits;	//bits per color
+
+    //edp link maintain
+    ret = dplpm_link_policy_maker(&link_config, &vm);
+
+    //save feedback config by edp link maintain
+    //pConf->lcd_control.edp_config->link_rate = link_config.link_rate;
+    pConf->lcd_control.edp_config->lane_count = link_config.lane_count;
+    //pConf->lcd_control.edp_config->vswing = link_config.vswing;
+    //pConf->lcd_control.edp_config->preemphasis = link_config.preemphasis;
+    pConf->lcd_control.edp_config->bit_rate = link_config.bit_rate;
+    switch (link_config.link_rate) {
+        case VAL_EDP_TX_LINK_BW_SET_162:
+            pConf->lcd_control.edp_config->link_rate = 0;
+            break;
+        case VAL_EDP_TX_LINK_BW_SET_270:
+            pConf->lcd_control.edp_config->link_rate = 1;
+            break;
+        default:
+            pConf->lcd_control.edp_config->link_rate = 1;
+            break; 
+    }
+    switch (link_config.vswing) {
+        case VAL_EDP_TX_PHY_VSWING_0:
+            pConf->lcd_control.edp_config->vswing = 0;
+            break;
+        case VAL_EDP_TX_PHY_VSWING_1:
+            pConf->lcd_control.edp_config->vswing = 1;
+            break;
+        case VAL_EDP_TX_PHY_VSWING_2:
+            pConf->lcd_control.edp_config->vswing = 2;
+            break;
+        case VAL_EDP_TX_PHY_VSWING_3:
+            pConf->lcd_control.edp_config->vswing = 3;
+            break;
+        default:
+            pConf->lcd_control.edp_config->vswing = 0;
+            break;
+    }
+    switch (link_config.preemphasis) {
+        case VAL_EDP_TX_PHY_PREEMPHASIS_0:
+            pConf->lcd_control.edp_config->preemphasis = 0;
+            break;
+        case VAL_EDP_TX_PHY_PREEMPHASIS_1:
+            pConf->lcd_control.edp_config->preemphasis = 1;
+            break;
+        case VAL_EDP_TX_PHY_PREEMPHASIS_2:
+            pConf->lcd_control.edp_config->preemphasis = 2;
+            break;
+        case VAL_EDP_TX_PHY_PREEMPHASIS_3:
+            pConf->lcd_control.edp_config->preemphasis = 3;
+            break;
+        default:
+            pConf->lcd_control.edp_config->preemphasis = 0;
+            break;
+    }
+
+    return ret;
 }
 #endif
 
@@ -1924,7 +2086,7 @@ static void set_control_ttl(Lcd_Config_t *pConf)
 	rb_port_swap = (unsigned)(pConf->lcd_control.ttl_config->rb_swap);
 	rgb_bit_swap = (unsigned)(pConf->lcd_control.ttl_config->bit_swap);
 	
-	WRITE_LCD_REG(DUAL_PORT_CNTL_ADDR, (rb_port_swap << LCD_RGB_SWP) | (rgb_bit_swap << LCD_BIT_SWP));
+	WRITE_LCD_REG(L_DUAL_PORT_CNTL_ADDR, (rb_port_swap << LCD_RGB_SWP) | (rgb_bit_swap << LCD_BIT_SWP));
 }
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
@@ -2088,32 +2250,41 @@ static void init_phy_lvds(Lcd_Config_t *pConf)
 }
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+static void init_phy_mipi(Lcd_Config_t *pConf)
+{
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x8);//DIF_REF_CTL0
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, (0x3e << 16) | (0xa5b8 << 0));//DIF_REF_CTL2:31-16bit, DIF_REF_CTL1:15-0bit
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, (0x26e0 << 16) | (0x459 << 0));//DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit
+}
+
 static void init_phy_edp(Lcd_Config_t *pConf)
 {
-	unsigned swing_ctrl;
-	DBG_PRINT("%s\n", __FUNCTION__);
-	
-	switch (pConf->lcd_control.edp_config->vswing) {
-		case VAL_EDP_TX_PHY_VSWING_0:	//0.4V
-			swing_ctrl = 0x8018;
-			break;
-		case VAL_EDP_TX_PHY_VSWING_1:	//0.6V
-			swing_ctrl = 0x8088;
-			break;
-		case VAL_EDP_TX_PHY_VSWING_2:	//0.8V
-			swing_ctrl = 0x80c8;
-			break;
-		case VAL_EDP_TX_PHY_VSWING_3:	//1.2V
-			swing_ctrl = 0x80f8;
-			break;
-		default:
-			swing_ctrl = 0x8018;
-			break;
-	}
-	
-	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, swing_ctrl);//[7:4]swing b:800mv, step 50mv
-	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, ((0x6 << 16) | (0xf5d7 << 0)));
-	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, ((0xc2b2 << 16) | (0x600 << 0)));//0xd2b0fe00);
+    unsigned swing_ctrl;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    switch (pConf->lcd_control.edp_config->vswing) {
+        case 0:	//0.4V
+            swing_ctrl = 0x8018;
+            break;
+        case 1:	//0.6V
+            swing_ctrl = 0x8088;
+            break;
+        case 2:	//0.8V
+            swing_ctrl = 0x80c8;
+            break;
+        case 3:	//1.2V
+            swing_ctrl = 0x80f8;
+            break;
+        default:
+            swing_ctrl = 0x8018;
+            break;
+    }
+
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, swing_ctrl);//[7:4]swing b:800mv, step 50mv
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, ((0x6 << 16) | (0xf5d7 << 0)));
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, ((0xc2b2 << 16) | (0x600 << 0)));//0xd2b0fe00);
 }
 #endif
 
@@ -2148,9 +2319,18 @@ static void init_dphy(Lcd_Config_t *pConf)
 	}
 }
 
-static unsigned error_abs(unsigned num1, unsigned num2)
+static void set_video_adjust(Lcd_Config_t *pConf)
 {
-	if (num1 >= num2)
+	DBG_PRINT("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x.\n", pConf->lcd_effect.vadj_brightness, pConf->lcd_effect.vadj_contrast, pConf->lcd_effect.vadj_saturation);
+	WRITE_LCD_REG(VPP_VADJ2_Y, (pConf->lcd_effect.vadj_brightness << 8) | (pConf->lcd_effect.vadj_contrast << 0));
+	WRITE_LCD_REG(VPP_VADJ2_MA_MB, (pConf->lcd_effect.vadj_saturation << 16));
+	WRITE_LCD_REG(VPP_VADJ2_MC_MD, (pConf->lcd_effect.vadj_saturation << 0));
+	WRITE_LCD_REG(VPP_VADJ_CTRL, 0xf);	//enable video adjust
+}
+
+static unsigned error_abs(unsigned num1, unsigned num2)
+{
+	if (num1 >= num2)
 		return num1 - num2;
 	else
 		return num2 - num1;
@@ -2158,336 +2338,325 @@ static unsigned error_abs(unsigned num1, unsigned num2)
 
 static void generate_clk_parameter(Lcd_Config_t *pConf)
 {
-	unsigned pll_n = 0, pll_m = 0, pll_od = 0, pll_frac = 0, pll_level = 0;
-	unsigned edp_phy_div0 = 0, edp_phy_div1 = 0, vid_div_pre = 0;
-	unsigned crt_xd = 0;
-
-	unsigned m, n, od, div_pre, div_post, xd;
-	unsigned od_sel, pre_div_sel;
-	unsigned div_pre_sel_max, crt_xd_max;
-	unsigned f_ref, pll_vco, fout_pll, div_pre_out, div_post_out, final_freq, iflogic_vid_clk_in_max;
-	unsigned min_error = MAX_ERROR;
-	unsigned error = MAX_ERROR;
-	unsigned clk_num = 0;
-	unsigned tmp;
+    unsigned pll_n = 0, pll_m = 0, pll_od = 0, pll_frac = 0, pll_level = 0;
+    unsigned edp_phy_div0 = 0, edp_phy_div1 = 0, vid_div_pre = 0;
+    unsigned crt_xd = 0;
+
+    unsigned m, n, od, div_pre, div_post, xd;
+    unsigned od_sel, pre_div_sel;
+    unsigned div_pre_sel_max, crt_xd_max;
+    unsigned f_ref, pll_vco, fout_pll, div_pre_out, div_post_out, final_freq, iflogic_vid_clk_in_max;
+    unsigned min_error = MAX_ERROR;
+    unsigned error = MAX_ERROR;
+    unsigned clk_num = 0;
+    unsigned tmp;
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-	unsigned od_fb=0, edp_div0, edp_div1;
-	unsigned edp_div0_sel, edp_div1_sel;
-	unsigned edp_tx_phy_out;
-	unsigned int dsi_clk_div=0, dsi_clk_max=0, dsi_clk_min=0;
+    unsigned od_fb=0, edp_div0, edp_div1;
+    unsigned edp_div0_sel, edp_div1_sel;
+    unsigned edp_tx_phy_out;
+    unsigned int dsi_bit_rate_min=0, dsi_bit_rate_max=0;
 #endif
-	unsigned fin = FIN_FREQ;
-	unsigned fout = pConf->lcd_timing.lcd_clk;
-	
-	if (fout >= 200) {//clk
-		fout = fout / 1000;  //kHz
-	}
-	else {//frame_rate
-		fout = (fout * pConf->lcd_basic.h_period * pConf->lcd_basic.v_period) / 1000;	//kHz
-	}
-	
-	edp_phy_div0 = 0;
-	edp_phy_div1 = 0;
-	switch (pConf->lcd_basic.lcd_type) {
+    unsigned fin = FIN_FREQ;
+    unsigned fout = pConf->lcd_timing.lcd_clk;
+
+    if (fout >= 200) {//clk
+        fout = fout / 1000;  //kHz
+    }
+    else {//frame_rate
+        fout = (fout * pConf->lcd_basic.h_period * pConf->lcd_basic.v_period) / 1000;	//kHz
+    }
+
+    switch (pConf->lcd_basic.lcd_type) {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-			div_pre_sel_max = DIV_PRE_SEL_MAX;
-			div_post = 1;
-			crt_xd_max = 16;
-			dsi_clk_min = pConf->lcd_control.mipi_config->dsi_clk_min;
-			dsi_clk_max = pConf->lcd_control.mipi_config->dsi_clk_max;
-			dsi_clk_div=pConf->lcd_control.mipi_config->dsi_clk_div;
-			iflogic_vid_clk_in_max = MIPI_MAX_VID_CLK_IN;
-			break;
-		case LCD_DIGITAL_EDP:
-			div_pre_sel_max = 1;
-			div_post = 1;
-			crt_xd_max = 1;
-			iflogic_vid_clk_in_max = EDP_MAX_VID_CLK_IN;
-			min_error = 30 * 1000;
-			break;
+        case LCD_DIGITAL_MIPI:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = 16;
+            dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
+            dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
+            iflogic_vid_clk_in_max = MIPI_MAX_VID_CLK_IN;
+            break;
+        case LCD_DIGITAL_EDP:
+            div_pre_sel_max = 1;
+            div_post = 1;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = EDP_MAX_VID_CLK_IN;
+            min_error = 30 * 1000;
+            break;
 #endif
-		case LCD_DIGITAL_LVDS:
-			div_pre_sel_max = DIV_PRE_SEL_MAX;
-			div_post = 7;
-			crt_xd_max = 1;
-			iflogic_vid_clk_in_max = LVDS_MAX_VID_CLK_IN;
-			break;		
-		case LCD_DIGITAL_TTL:
-			div_pre_sel_max = DIV_PRE_SEL_MAX;
-			div_post = 1;
-			crt_xd_max = CRT_VID_DIV_MAX;
-			iflogic_vid_clk_in_max = TTL_MAX_VID_CLK_IN;
-			break;
+        case LCD_DIGITAL_LVDS:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 7;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = LVDS_MAX_VID_CLK_IN;
+            break;
+        case LCD_DIGITAL_TTL:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = CRT_VID_DIV_MAX;
+            iflogic_vid_clk_in_max = TTL_MAX_VID_CLK_IN;
+            break;
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
-			div_pre_sel_max = DIV_PRE_SEL_MAX;
-			div_post = 6;
-			crt_xd_max = 1;
-			iflogic_vid_clk_in_max = MLVDS_MAX_VID_CLK_IN;
-			break;
+        case LCD_DIGITAL_MINILVDS:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 6;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = MLVDS_MAX_VID_CLK_IN;
+            break;
 #endif
-		default:
-			div_pre_sel_max = DIV_PRE_SEL_MAX;
-			div_post = 1;
-			crt_xd_max = 1;
-			iflogic_vid_clk_in_max = LCD_VENC_MAX_CLK_IN;
-			break;
-	}
-	
-	switch (pConf->lcd_basic.lcd_type) {
+        default:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = LCD_VENC_MAX_CLK_IN;
+            break;
+    }
+
+    switch (pConf->lcd_basic.lcd_type) {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-                        if (fout < LCD_VENC_MAX_CLK_IN) {
-                                for (xd = 1; xd <= crt_xd_max; xd++) {
-                                        div_post_out = fout * xd;
-                                        DBG_PRINT("div_post_out=%d, xd=%d, fout=%d\n",div_post_out, xd, fout);
-                                        if (div_post_out <= CRT_VID_MAX_CLK_IN) {
-                                                div_pre_out = div_post_out * div_post;
-                                                if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
-                                                        for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
-                                                                div_pre = div_pre_table[pre_div_sel];
-                                                                fout_pll = div_pre_out * div_pre;
-                                                                DBG_PRINT("pre_div_sel=%d, div_pre=%d, fout_pll=%d\n", pre_div_sel, div_pre, fout_pll);
-
-                                                                if ((fout_pll <= dsi_clk_div*dsi_clk_max*1000) &&
-                                                                                (fout_pll >= dsi_clk_div*dsi_clk_min*1000)){
-                                                                        for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
-                                                                                od = od_table[od_sel - 1];
-                                                                                pll_vco = fout_pll * od;
-                                                                                DBG_PRINT("od_sel=%d, od=%d, pll_vco=%d\n", od_sel, od, pll_vco);
-                                                                                if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
-                                                                                        if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
-                                                                                                od_fb = 1;
-                                                                                                pll_level = 3;
-                                                                                        }
-                                                                                        else if ((pll_vco >= 1700000) && (pll_vco < 2500000)) {
-                                                                                                od_fb = 1;
-                                                                                                pll_level = 2;
-                                                                                        }
-                                                                                        else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
-                                                                                                od_fb = 0;
-                                                                                                pll_level = 1;
-                                                                                        }
-                                                                                        n = 1;
-                                                                                        m = pll_vco / (fin * (od_fb + 1));
-                                                                                        pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
-
-                                                                                        pll_m = m;
-                                                                                        pll_n = n;
-                                                                                        pll_od = od_sel - 1;
-                                                                                        vid_div_pre = pre_div_sel;
-                                                                                        crt_xd = xd;
-
-                                                                                        clk_num = 1;
-                                                                                        DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, edp_phy_div0=0x%x, edp_phy_div1=0x%x,"
-                                                                                                        "vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
-                                                                                                        pll_m, pll_n, pll_od, edp_phy_div0, edp_phy_div1,
-                                                                                                        vid_div_pre, crt_xd, pll_frac, pll_level);
-                                                                                }
-                                                                                if (clk_num > 0)
-                                                                                        break;
-                                                                        }
-                                                                }
-                                                                if (clk_num > 0)
-                                                                        break;
-                                                        }
-                                                }
+        case LCD_DIGITAL_MIPI:
+            if (fout < LCD_VENC_MAX_CLK_IN) {
+                for (xd = 1; xd <= crt_xd_max; xd++) {
+                    div_post_out = fout * xd;
+                    DBG_PRINT("div_post_out=%d, xd=%d, fout=%d\n",div_post_out, xd, fout);
+                    if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                        div_pre_out = div_post_out * div_post;
+                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                            for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                                div_pre = div_pre_table[pre_div_sel];
+                                fout_pll = div_pre_out * div_pre;
+                                DBG_PRINT("pre_div_sel=%d, div_pre=%d, fout_pll=%d\n", pre_div_sel, div_pre, fout_pll);
+                                if ((fout_pll <= dsi_bit_rate_max) && (fout_pll >= dsi_bit_rate_min)){
+                                    for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
+                                        od = od_table[od_sel - 1];
+                                        pll_vco = fout_pll * od;
+                                        DBG_PRINT("od_sel=%d, od=%d, pll_vco=%d\n", od_sel, od, pll_vco);
+                                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
+                                            if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
+                                                od_fb = 1;
+                                                pll_level = 3;
+                                            }
+                                            else if ((pll_vco >= 1700000) && (pll_vco < 2500000)) {
+                                                od_fb = 1;
+                                                pll_level = 2;
+                                            }
+                                            else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
+                                                od_fb = 0;
+                                                pll_level = 1;
+                                            }
+                                            n = 1;
+                                            m = pll_vco / (fin * (od_fb + 1));
+                                            pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
+                                            pll_m = m;
+                                            pll_n = n;
+                                            pll_od = od_sel - 1;
+                                            vid_div_pre = pre_div_sel;
+                                            crt_xd = xd;
+                                            clk_num = 1;
+                                            DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
+                                                       pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
                                         }
                                         if (clk_num > 0)
-                                                break;
+                                            break;
+                                    }
                                 }
+                                if (clk_num > 0)
+                                    break;
+                            }
                         }
-			break;
-		case LCD_DIGITAL_EDP:
-			switch (pConf->lcd_control.edp_config->link_rate) {
-				case VAL_EDP_TX_LINK_BW_SET_162:
-					n = 1;
-					m = 67;
-					od_sel = 0;
-					pll_level = 1;
-					pll_frac = 0x800;
-					fout_pll = 1620000;
-					break;
-				case VAL_EDP_TX_LINK_BW_SET_270:
-				default:
-					n = 1;
-					m = 56;
-					od_sel = 0;
-					pll_level = 3;
-					pll_frac = 0x400;
-					fout_pll = 2700000;
-					break;
-			}
-			pll_m = m;
-			pll_n = n;
-			pll_od = od_sel;
-			
-			for(edp_div1_sel=0; edp_div1_sel<EDP_DIV1_SEL_MAX; edp_div1_sel++) {
-				edp_div1 = edp_div1_table[edp_div1_sel];
-				for (edp_div0_sel=0; edp_div0_sel<EDP_DIV0_SEL_MAX; edp_div0_sel++) {
-					edp_div0 = edp_div0_table[edp_div0_sel];
-					edp_tx_phy_out = fout_pll / (edp_div0 * edp_div1);
-					if (edp_tx_phy_out <= DIV_PRE_MAX_CLK_IN)	{
-						for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
-							div_pre = div_pre_table[pre_div_sel];
-							div_pre_out = edp_tx_phy_out / div_pre;
-							if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
-								div_post_out = div_pre_out / div_post;
-								if (div_post_out <= CRT_VID_MAX_CLK_IN) {
-									for (xd = 1; xd <= crt_xd_max; xd++) {
-										final_freq = div_post_out / xd;
-										if (final_freq < LCD_VENC_MAX_CLK_IN) {
-											if (final_freq < iflogic_vid_clk_in_max) {
-												if (final_freq <= fout) {
-													error = fout - final_freq;
-													if (error < min_error) {
-														min_error = error;
-														edp_phy_div0 = edp_div0_sel;
-														edp_phy_div1 = edp_div1_sel;
-														vid_div_pre = pre_div_sel;
-														crt_xd = xd;
-														clk_num++;
-													}
-												}
-											}
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-			break;
+                    }
+                    if (clk_num > 0)
+                        break;
+                }
+            }
+            break;
+        case LCD_DIGITAL_EDP:
+            switch (pConf->lcd_control.edp_config->link_rate) {
+                case 0:
+                    n = 1;
+                    m = 67;
+                    od_sel = 0;
+                    pll_level = 1;
+                    pll_frac = 0x800;
+                    fout_pll = 1620000;
+                    break;
+                case 1:
+                default:
+                    n = 1;
+                    m = 56;
+                    od_sel = 0;
+                    pll_level = 3;
+                    pll_frac = 0x400;
+                    fout_pll = 2700000;
+                    break;
+            }
+            pll_m = m;
+            pll_n = n;
+            pll_od = od_sel;
+
+            for(edp_div1_sel=0; edp_div1_sel<EDP_DIV1_SEL_MAX; edp_div1_sel++) {
+                edp_div1 = edp_div1_table[edp_div1_sel];
+                for (edp_div0_sel=0; edp_div0_sel<EDP_DIV0_SEL_MAX; edp_div0_sel++) {
+                    edp_div0 = edp_div0_table[edp_div0_sel];
+                    edp_tx_phy_out = fout_pll / (edp_div0 * edp_div1);
+                    if (edp_tx_phy_out <= DIV_PRE_MAX_CLK_IN) {
+                        for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                            div_pre = div_pre_table[pre_div_sel];
+                            div_pre_out = edp_tx_phy_out / div_pre;
+                            if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                                div_post_out = div_pre_out / div_post;
+                                if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                                    for (xd = 1; xd <= crt_xd_max; xd++) {
+                                        final_freq = div_post_out / xd;
+                                        if (final_freq < LCD_VENC_MAX_CLK_IN) {
+                                            if (final_freq < iflogic_vid_clk_in_max) {
+                                                if (final_freq <= fout) {
+                                                    error = fout - final_freq;
+                                                    if (error < min_error) {
+                                                        min_error = error;
+                                                        edp_phy_div0 = edp_div0_sel;
+                                                        edp_phy_div1 = edp_div1_sel;
+                                                        vid_div_pre = pre_div_sel;
+                                                        crt_xd = xd;
+                                                        clk_num++;
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            break;
 #endif
-		case LCD_DIGITAL_LVDS:
-		case LCD_DIGITAL_TTL:
+        case LCD_DIGITAL_LVDS:
+        case LCD_DIGITAL_TTL:
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-			for (n = PLL_N_MIN; n <= PLL_N_MAX; n++) {
-				f_ref = fin / n;
-				if ((f_ref >= PLL_FREF_MIN) && (f_ref <= PLL_FREF_MAX))	{
-					for (m = PLL_M_MIN; m <= PLL_M_MAX; m++) {
-						pll_vco = f_ref * m;
-						if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
-							for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
-								od = od_table[od_sel - 1];
-								fout_pll = pll_vco / od;
-								if (fout_pll <= DIV_PRE_MAX_CLK_IN)	{
-									for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
-										div_pre = div_pre_table[pre_div_sel];
-										div_pre_out = fout_pll / div_pre;
-										if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
-											div_post_out = div_pre_out / div_post;
-											if (div_post_out <= CRT_VID_MAX_CLK_IN) {
-												for (xd = 1; xd <= crt_xd_max; xd++) {
-													final_freq = div_post_out / xd;
-													if (final_freq < LCD_VENC_MAX_CLK_IN) {
-														if (final_freq < iflogic_vid_clk_in_max) {
-															error = error_abs(final_freq, fout);
-															if (error < min_error) {
-																min_error = error;
-																pll_m = m;
-																pll_n = n;
-																pll_od = od_sel - 1;
-																vid_div_pre = pre_div_sel;
-																crt_xd = xd;
-																clk_num++;
-															}
-														}
-													}
-												}
-											}
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
+            for (n = PLL_N_MIN; n <= PLL_N_MAX; n++) {
+                f_ref = fin / n;
+                if ((f_ref >= PLL_FREF_MIN) && (f_ref <= PLL_FREF_MAX))    {
+                    for (m = PLL_M_MIN; m <= PLL_M_MAX; m++) {
+                        pll_vco = f_ref * m;
+                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
+                            for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
+                                od = od_table[od_sel - 1];
+                                fout_pll = pll_vco / od;
+                            if (fout_pll <= DIV_PRE_MAX_CLK_IN) {
+                                    for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                                        div_pre = div_pre_table[pre_div_sel];
+                                        div_pre_out = fout_pll / div_pre;
+                                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                                            div_post_out = div_pre_out / div_post;
+                                            if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                                                for (xd = 1; xd <= crt_xd_max; xd++) {
+                                                    final_freq = div_post_out / xd;
+                                                    if (final_freq < LCD_VENC_MAX_CLK_IN) {
+                                                        if (final_freq < iflogic_vid_clk_in_max) {
+                                                            error = error_abs(final_freq, fout);
+                                                            if (error < min_error) {
+                                                                min_error = error;
+                                                                pll_m = m;
+                                                                pll_n = n;
+                                                                pll_od = od_sel - 1;
+                                                                vid_div_pre = pre_div_sel;
+                                                                crt_xd = xd;
+                                                                clk_num++;
+                                                            }
+                                                        }
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
 #elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-			if (fout < LCD_VENC_MAX_CLK_IN) {
-				for (xd = 1; xd <= crt_xd_max; xd++) {
-					div_post_out = fout * xd;
-					if (div_post_out <= CRT_VID_MAX_CLK_IN) {
-						div_pre_out = div_post_out * div_post;
-						if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
-							for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
-								div_pre = div_pre_table[pre_div_sel];
-								fout_pll = div_pre_out * div_pre;
-								if (fout_pll <= DIV_PRE_MAX_CLK_IN)	{
-									for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
-										od = od_table[od_sel - 1];
-										pll_vco = fout_pll * od;
-										if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
-											if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
-												od_fb = 1;
-												pll_level = 3;
-											}
-											else if ((pll_vco >= 1700000) && (pll_vco < 2500000)) {
-												od_fb = 1;
-												pll_level = 2;
-											}
-											else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
-												od_fb = 0;
-												pll_level = 1;
-											}
-											n = 1;
-											m = pll_vco / (fin * (od_fb + 1));
-											pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
-											
-											pll_m = m;
-											pll_n = n;
-											pll_od = od_sel - 1;
-											edp_phy_div0 = edp_div0_sel;
-											edp_phy_div1 = edp_div1_sel;
-											vid_div_pre = pre_div_sel;
-											crt_xd = xd;
-											
-											clk_num = 1;
-										}
-										if (clk_num > 0)
-											break;
-									}
-								}
-								if (clk_num > 0)
-									break;
-							}
-						}
-					}
-					if (clk_num > 0)
-						break;
-				}
-			}
+            if (fout < LCD_VENC_MAX_CLK_IN) {
+                for (xd = 1; xd <= crt_xd_max; xd++) {
+                    div_post_out = fout * xd;
+                    if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                        div_pre_out = div_post_out * div_post;
+                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                            for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                                div_pre = div_pre_table[pre_div_sel];
+                                fout_pll = div_pre_out * div_pre;
+                                if (fout_pll <= DIV_PRE_MAX_CLK_IN) {
+                                    for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
+                                        od = od_table[od_sel - 1];
+                                        pll_vco = fout_pll * od;
+                                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
+                                            if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
+                                                od_fb = 1;
+                                                pll_level = 3;
+                                            }
+                                            else if ((pll_vco >= 1700000) && (pll_vco < 2500000)) {
+                                                od_fb = 1;
+                                                pll_level = 2;
+                                            }
+                                            else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
+                                                od_fb = 0;
+                                                pll_level = 1;
+                                            }
+                                            n = 1;
+                                            m = pll_vco / (fin * (od_fb + 1));
+                                            pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
+
+                                            pll_m = m;
+                                            pll_n = n;
+                                            pll_od = od_sel - 1;
+                                            vid_div_pre = pre_div_sel;
+                                            crt_xd = xd;
+
+                                            clk_num = 1;
+                                        }
+                                        if (clk_num > 0)
+                                            break;
+                                    }
+                                }
+                                if (clk_num > 0)
+                                    break;
+                            }
+                        }
+                    }
+                    if (clk_num > 0)
+                        break;
+                }
+            }
 #endif
-			break;
-		default:
-			break;
-	}
-	if (clk_num > 0) {
-		pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
-		pConf->lcd_timing.div_ctrl = 0x18803 | (edp_phy_div1 << DIV_CTRL_EDP_DIV1) | (edp_phy_div0 << DIV_CTRL_EDP_DIV0) | (vid_div_pre << DIV_CTRL_DIV_PRE);
-		tmp = (pConf->lcd_timing.clk_ctrl & ~((0xf << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
-		pConf->lcd_timing.clk_ctrl = (tmp | ((crt_xd << CLK_CTRL_XD) | (pll_level << CLK_CTRL_LEVEL) | (pll_frac << CLK_CTRL_FRAC)));
-	}
-	else {
+            break;
+        default:
+            break;
+    }
+    if (clk_num > 0) {
+        pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
+        pConf->lcd_timing.div_ctrl = 0x18803 | (edp_phy_div1 << DIV_CTRL_EDP_DIV1) | (edp_phy_div0 << DIV_CTRL_EDP_DIV0) | (vid_div_pre << DIV_CTRL_DIV_PRE);
+        tmp = (pConf->lcd_timing.clk_ctrl & ~((0xf << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
+        pConf->lcd_timing.clk_ctrl = (tmp | ((crt_xd << CLK_CTRL_XD) | (pll_level << CLK_CTRL_LEVEL) | (pll_frac << CLK_CTRL_FRAC)));
+    }
+    else {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (32 << PLL_CTRL_M);
-		pConf->lcd_timing.div_ctrl = 0x18803;
+        pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (32 << PLL_CTRL_M);
+        pConf->lcd_timing.div_ctrl = 0x18803;
 #elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (50 << PLL_CTRL_M);
-		pConf->lcd_timing.div_ctrl = 0x18803 | (0 << DIV_CTRL_EDP_DIV1) | (0 << DIV_CTRL_EDP_DIV0) | (1 << DIV_CTRL_DIV_PRE);
+        pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (50 << PLL_CTRL_M);
+        pConf->lcd_timing.div_ctrl = 0x18803 | (0 << DIV_CTRL_EDP_DIV1) | (0 << DIV_CTRL_EDP_DIV0) | (1 << DIV_CTRL_DIV_PRE);
 #endif
-		pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
-		printk("Out of clock range, reset to default setting!\n");
-	}
+        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+        printk("Out of clock range, reset to default setting!\n");
+    }
 }
 
 static void lcd_sync_duration(Lcd_Config_t *pConf)
 {
 	unsigned m, n, od, od_fb, frac, edp_div0, edp_div1, pre_div, xd, post_div;
-	unsigned h_period, v_period, sync_duration;	
+	unsigned h_period, v_period, sync_duration;
 	unsigned lcd_clk;
 
 	m = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_M) & 0x1ff;
@@ -2516,8 +2685,6 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 	switch(pConf->lcd_basic.lcd_type) {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_MIPI:
-			edp_div0 = 0;
-			edp_div1 = 0;
 			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
 			post_div = 1;
 			break;
@@ -2533,8 +2700,6 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 			post_div = 7;
 			break;
 		case LCD_DIGITAL_TTL:
-			edp_div0 = 0;
-			edp_div1 = 0;
 			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
 			post_div = 1;
 			break;
@@ -2560,7 +2725,7 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 	
 	pConf->lcd_timing.sync_duration_num = sync_duration;
 	pConf->lcd_timing.sync_duration_den = 10;
-	printk("lcd_clk=%u.%uMHz, frame_rate=%u.%uHz.\n\n",
+	printk("lcd_clk=%u.%03uMHz, frame_rate=%u.%uHz.\n\n",
                 (lcd_clk / 1000000), ((lcd_clk / 1000) % 1000), (sync_duration / pConf->lcd_timing.sync_duration_den), ((sync_duration * 10 / pConf->lcd_timing.sync_duration_den) % 10));
 }
 
@@ -2581,7 +2746,7 @@ static void lcd_tcon_config(Lcd_Config_t *pConf)
 #endif
 		case LCD_DIGITAL_LVDS:
 			h_delay = LVDS_DELAY;
-			break;		
+			break;
 		case LCD_DIGITAL_TTL:
 			h_delay = TTL_DELAY;
 			break;
@@ -2675,167 +2840,154 @@ static void lcd_tcon_config(Lcd_Config_t *pConf)
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 static void select_edp_link_config(Lcd_Config_t *pConf)
 {
-	unsigned bit_rate;
-	unsigned lane_cap;
-	
-	bit_rate = (pConf->lcd_timing.lcd_clk / 1000) * pConf->lcd_basic.lcd_bits * 3 / 1000;	//Mbps
-	pConf->lcd_control.edp_config->bit_rate = bit_rate;
-	
-	if (pConf->lcd_control.edp_config->link_user == 0) {
-		if (bit_rate < EDP_TX_LINK_CAPACITY_162 * 1) {
-			pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_162;
-			pConf->lcd_control.edp_config->lane_count = 1;
-		}
-		else if (bit_rate < EDP_TX_LINK_CAPACITY_270 * 1) {
-			pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-			pConf->lcd_control.edp_config->lane_count = 1;
-		}
-		else if (bit_rate < EDP_TX_LINK_CAPACITY_162 * 2) {
-			pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_162;
-			pConf->lcd_control.edp_config->lane_count = 2;
-		}
-		else if (bit_rate < EDP_TX_LINK_CAPACITY_270 * 2) {
-			pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-			pConf->lcd_control.edp_config->lane_count = 2;
-		}
-		else if (bit_rate < EDP_TX_LINK_CAPACITY_162 * 4) {
-			pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_162;
-			pConf->lcd_control.edp_config->lane_count = 4;
-		}
-		else if (bit_rate < EDP_TX_LINK_CAPACITY_270 * 4) {
-			pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-			pConf->lcd_control.edp_config->lane_count = 4;
-		}
-		else {
-			printk("Error: bit rate is out edp of support, should reduce frame rate(pixel clock)\n");
-			pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-			pConf->lcd_control.edp_config->lane_count = 4;
-		}
-	}
-	else {
-		switch (pConf->lcd_control.edp_config->link_rate) {
-			case VAL_EDP_TX_LINK_BW_SET_162:
-			case 0:
-				pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_162;
-				break;
-			case VAL_EDP_TX_LINK_BW_SET_270:
-			case 1:
-				pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-				break;
-			default:
-				pConf->lcd_control.edp_config->link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-				break;
-		}
-		
-		lane_cap = (pConf->lcd_control.edp_config->link_rate == VAL_EDP_TX_LINK_BW_SET_162) ? EDP_TX_LINK_CAPACITY_162 : EDP_TX_LINK_CAPACITY_270;
-		while ((bit_rate > (lane_cap * pConf->lcd_control.edp_config->lane_count)) && (pConf->lcd_control.edp_config->lane_count < 4)) {
-			switch (pConf->lcd_control.edp_config->lane_count) {
-				case 1:
-					pConf->lcd_control.edp_config->lane_count = 2;
-					break;
-				case 2:
-					pConf->lcd_control.edp_config->lane_count = 4;
-					break;
-				default:
-					break;
-			}
-		}
-		if (bit_rate > (lane_cap * pConf->lcd_control.edp_config->lane_count))
-			printk("Error: bit rate is out edp of support, should reduce frame rate(pixel clock)\n");
-	}
+    unsigned bit_rate;
+    unsigned lane_cap;
+
+    bit_rate = (pConf->lcd_timing.lcd_clk / 1000) * pConf->lcd_basic.lcd_bits * 3 / 1000;    //Mbps
+    pConf->lcd_control.edp_config->bit_rate = bit_rate;
+
+    if (pConf->lcd_control.edp_config->link_user == 0) {
+        if (bit_rate < EDP_TX_LINK_CAPACITY_162 * 1) {
+            pConf->lcd_control.edp_config->link_rate = 0;
+            pConf->lcd_control.edp_config->lane_count = 1;
+        }
+        else if (bit_rate < EDP_TX_LINK_CAPACITY_270 * 1) {
+            pConf->lcd_control.edp_config->link_rate = 1;
+            pConf->lcd_control.edp_config->lane_count = 1;
+        }
+        else if (bit_rate < EDP_TX_LINK_CAPACITY_162 * 2) {
+            pConf->lcd_control.edp_config->link_rate = 0;
+            pConf->lcd_control.edp_config->lane_count = 2;
+        }
+        else if (bit_rate < EDP_TX_LINK_CAPACITY_270 * 2) {
+            pConf->lcd_control.edp_config->link_rate = 1;
+            pConf->lcd_control.edp_config->lane_count = 2;
+        }
+        else if (bit_rate < EDP_TX_LINK_CAPACITY_162 * 4) {
+            pConf->lcd_control.edp_config->link_rate = 0;
+            pConf->lcd_control.edp_config->lane_count = 4;
+        }
+        else if (bit_rate < EDP_TX_LINK_CAPACITY_270 * 4) {
+            pConf->lcd_control.edp_config->link_rate = 1;
+            pConf->lcd_control.edp_config->lane_count = 4;
+        }
+        else {
+            printk("Error: bit rate is out edp of support, should reduce frame rate(pixel clock)\n");
+            pConf->lcd_control.edp_config->link_rate = 1;
+            pConf->lcd_control.edp_config->lane_count = 4;
+        }
+    }
+    else {
+        lane_cap = (pConf->lcd_control.edp_config->link_rate == 0) ? EDP_TX_LINK_CAPACITY_162 : EDP_TX_LINK_CAPACITY_270;
+        while ((bit_rate > (lane_cap * pConf->lcd_control.edp_config->lane_count)) && (pConf->lcd_control.edp_config->lane_count < 4)) {
+            switch (pConf->lcd_control.edp_config->lane_count) {
+                case 1:
+                    pConf->lcd_control.edp_config->lane_count = 2;
+                    break;
+                case 2:
+                    pConf->lcd_control.edp_config->lane_count = 4;
+                    break;
+                default:
+                    break;
+            }
+        }
+        if (bit_rate > (lane_cap * pConf->lcd_control.edp_config->lane_count))
+            printk("Error: bit rate is out edp of support, should reduce frame rate(pixel clock)\n");
+    }
 }
 #endif
 
-static void lcd_control_config(Lcd_Config_t *pConf)
+static void lcd_control_config_pre(Lcd_Config_t *pConf) //before generate_clk_parameter
 {
+    unsigned char ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
+    unsigned int bit_rate;
+
+    ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
+
+    switch (pConf->lcd_basic.lcd_type) {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-	DSI_Config_t *cfg = pDev->pConf->lcd_control.mipi_config;
-#endif
-	
-	switch (pConf->lcd_basic.lcd_type) {
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-				if(pDev->pConf->lcd_basic.lcd_bits==6){
-							cfg->dpi_color_type  = 4;
-							cfg->venc_color_type = 2;
-					}else{
-							cfg->dpi_color_type  = 5;
-							cfg->venc_color_type = 1;
-					}
-				cfg->dsi_clk_div  =1;
-				cfg->dpi_chroma_subsamp = 0;
-				cfg->lane_num=cfg->lane_num-1;
-				if((pDev->pConf->lcd_basic.h_period !=240)&&(pDev->pConf->lcd_basic.h_period !=768)&&(pDev->pConf->lcd_basic.h_period !=1920)&&(pDev->pConf->lcd_basic.h_period !=2560))
-        		cfg->venc_fmt=TV_ENC_LCD1280x720;
-        else
-        		cfg->venc_fmt=TV_ENC_LCD768x1024p;
-			break;
-		case LCD_DIGITAL_EDP:
-			select_edp_link_config(pConf);
-			if (pConf->lcd_control.edp_config->link_adaptive == 1) {
-				pConf->lcd_control.edp_config->vswing = VAL_EDP_TX_PHY_VSWING_0;
-				pConf->lcd_control.edp_config->preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_0;
-			}
-			else {
-				switch (pConf->lcd_control.edp_config->vswing) {
-					case 0:
-						pConf->lcd_control.edp_config->vswing = VAL_EDP_TX_PHY_VSWING_0;
-						break;
-					case 1:
-						pConf->lcd_control.edp_config->vswing = VAL_EDP_TX_PHY_VSWING_1;
-						break;
-					case 2:
-						pConf->lcd_control.edp_config->vswing = VAL_EDP_TX_PHY_VSWING_2;
-						break;
-					case 3:
-						pConf->lcd_control.edp_config->vswing = VAL_EDP_TX_PHY_VSWING_3;
-						break;
-					default:
-						pConf->lcd_control.edp_config->vswing = VAL_EDP_TX_PHY_VSWING_0;
-						break;
-				}
-				switch (pConf->lcd_control.edp_config->preemphasis) {
-					case 0:
-						pConf->lcd_control.edp_config->preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_0;
-						break;
-					case 1:
-						pConf->lcd_control.edp_config->preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_1;
-						break;
-					case 2:
-						pConf->lcd_control.edp_config->preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_2;
-						break;
-					case 3:
-						pConf->lcd_control.edp_config->preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_3;
-						break;
-					default:
-						pConf->lcd_control.edp_config->preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_0;
-						break;
-				}
-			}
-			break;
+        case LCD_DIGITAL_MIPI:
+            ss_level = ((ss_level > 0) ? 1 : 0);
+            if (pConf->lcd_control.mipi_config->bit_rate_max == 0) {
+                bit_rate = ((pConf->lcd_timing.lcd_clk / 1000) * 3 * 8) / pConf->lcd_control.mipi_config->lane_num;
+                pConf->lcd_control.mipi_config->bit_rate_min = bit_rate;
+                pConf->lcd_control.mipi_config->bit_rate_max = bit_rate + (pConf->lcd_timing.lcd_clk / 1000) + 10000;
+                printk("mipi dsi bit_rate min=%dMHz, max=%dMHz\n", (pConf->lcd_control.mipi_config->bit_rate_min / 1000), (pConf->lcd_control.mipi_config->bit_rate_max / 1000));
+            }
+            if (pConf->lcd_control.mipi_config->bit_rate_max > MIPI_PHY_MAX_CLK_IN) {
+                pConf->lcd_control.mipi_config->bit_rate_max = MIPI_PHY_MAX_CLK_IN;
+                printk("mipi dsi bit_rate_max is out of support, adjust to %dMHz\n", (MIPI_PHY_MAX_CLK_IN / 1000));
+            }
+            break;
+        case LCD_DIGITAL_EDP:
+            ss_level = ((ss_level > 0) ? 1 : 0);
+            select_edp_link_config(pConf);
+            if (pConf->lcd_control.edp_config->link_adaptive == 1) {
+                pConf->lcd_control.edp_config->vswing = 0;
+                pConf->lcd_control.edp_config->preemphasis = 0;
+            }
+            printk("edp vswing=0x%x, preem=0x%x\n", pConf->lcd_control.edp_config->vswing, pConf->lcd_control.edp_config->preemphasis);
+            break;
 #endif
-		case LCD_DIGITAL_LVDS:
-			if (pConf->lcd_control.lvds_config->lvds_repack_user == 0) {
-				if (pConf->lcd_basic.lcd_bits == 6)
-					pConf->lcd_control.lvds_config->lvds_repack = 0;
-				else
-					pConf->lcd_control.lvds_config->lvds_repack = 1;
-			}
-			break;
+        case LCD_DIGITAL_LVDS:
+            if (pConf->lcd_control.lvds_config->lvds_repack_user == 0) {
+                if (pConf->lcd_basic.lcd_bits == 6)
+                    pConf->lcd_control.lvds_config->lvds_repack = 0;
+                else
+                    pConf->lcd_control.lvds_config->lvds_repack = 1;
+            }
+            break;
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
-			break;
+        case LCD_DIGITAL_MINILVDS:
+            break;
 #endif
-		default:
-			break;
-	}
+        default:
+            break;
+    }
+    pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_SS)) | (ss_level << CLK_CTRL_SS));
+}
+
+static void lcd_control_config_post(Lcd_Config_t *pConf) //before generate_clk_parameter
+{
+    unsigned pre_div, post_div, xd;
+    unsigned pclk, lanebyteclk;
+
+    switch (pConf->lcd_basic.lcd_type) {
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+        case LCD_DIGITAL_MIPI:
+            post_div = 1;//(((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_DIV_POST) & 0x7) + 1;
+            pre_div = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_DIV_PRE) & 0x7;
+            pre_div = div_pre_table[pre_div];
+            xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+
+            pclk = pConf->lcd_timing.lcd_clk;
+            pConf->lcd_control.mipi_config->bit_rate = pclk * pre_div * post_div * xd;
+
+            if (pConf->lcd_control.mipi_config->factor_numerator == 0) {
+                pclk = pConf->lcd_timing.lcd_clk;
+                lanebyteclk = pConf->lcd_control.mipi_config->bit_rate / 8;
+                DBG_PRINT("pixel_clk = %d.%03dMHz, bit_rate = %d.%03dMHz, lanebyteclk = %d.%03dMHz\n", (pclk / 1000000), ((pclk / 1000) % 1000), 
+                        (pConf->lcd_control.mipi_config->bit_rate / 1000000), ((pConf->lcd_control.mipi_config->bit_rate / 1000) % 1000), (lanebyteclk / 1000000), ((lanebyteclk / 1000) % 1000));
+
+                pConf->lcd_control.mipi_config->factor_denominator = lanebyteclk/1000;
+                pConf->lcd_control.mipi_config->factor_numerator = pclk/1000;
+                //cfg->factor_denominator = 10;
+            }
+            DBG_PRINT("d=%d, n=%d, factor=%d.%02d\n", pConf->lcd_control.mipi_config->factor_denominator, pConf->lcd_control.mipi_config->factor_numerator, 
+                    (pConf->lcd_control.mipi_config->factor_denominator/pConf->lcd_control.mipi_config->factor_numerator), 
+                    ((pConf->lcd_control.mipi_config->factor_denominator % pConf->lcd_control.mipi_config->factor_numerator) * 100 / pConf->lcd_control.mipi_config->factor_numerator));
+            break;
+        case LCD_DIGITAL_EDP:
+            break;
+#endif
+        default:
+            break;
+    }
 }
 
 static void lcd_config_init(Lcd_Config_t *pConf)
 {
-	unsigned char ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
-	
-	lcd_control_config(pConf);//must before generate_clk_parameter, otherwise the clk parameter will not update base on the edp_link_rate
+	lcd_control_config_pre(pConf);//must before generate_clk_parameter, otherwise the clk parameter will not update base on the edp_link_rate
 	
 	if (pConf->lcd_timing.clk_ctrl & (1 << CLK_CTRL_AUTO)) {
 		printk("\nAuto generate clock parameters.\n");
@@ -2846,30 +2998,11 @@ static void lcd_config_init(Lcd_Config_t *pConf)
 		printk("\nCustome clock parameters.\n");
 		printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
 	}
-	ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
-	switch(pConf->lcd_basic.lcd_type) {
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-		case LCD_DIGITAL_EDP:
-			ss_level = ((ss_level > 0) ? 1 : 0);
-			break;
-#endif
-		default:
-			break;
-	}
-	pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_SS)) | (ss_level << CLK_CTRL_SS));
 	
 	lcd_sync_duration(pConf);
 	lcd_tcon_config(pConf);
-}
 
-static void set_video_adjust(Lcd_Config_t *pConf)
-{
-	DBG_PRINT("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x.\n", pConf->lcd_effect.vadj_brightness, pConf->lcd_effect.vadj_contrast, pConf->lcd_effect.vadj_saturation);
-	WRITE_LCD_REG(VPP_VADJ2_Y, (pConf->lcd_effect.vadj_brightness << 8) | (pConf->lcd_effect.vadj_contrast << 0));
-	WRITE_LCD_REG(VPP_VADJ2_MA_MB, (pConf->lcd_effect.vadj_saturation << 16));
-	WRITE_LCD_REG(VPP_VADJ2_MC_MD, (pConf->lcd_effect.vadj_saturation << 0));
-	WRITE_LCD_REG(VPP_VADJ_CTRL, 0xf);	//enable video adjust
+	lcd_control_config_post(pConf);
 }
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
@@ -2908,156 +3041,125 @@ static void switch_lcd_gates(unsigned int state)
 
 static void _init_lcd_driver(Lcd_Config_t *pConf)	//before power on lcd
 { 
-	int lcd_type = pConf->lcd_basic.lcd_type;
-	unsigned char ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
-	
-	printk("lcd driver version: %s@%s%s\n\n", DRIVER_DATE, DRIVER_VER, DRV_TYPE);
+    int lcd_type = pConf->lcd_basic.lcd_type;
+    unsigned char ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
+
+    printk("lcd driver version: %s%s\n\n", DRIVER_DATE, DRV_TYPE);
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	switch_lcd_gates(lcd_type);
+    switch_lcd_gates(lcd_type);
 #elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-	switch_vpu_mem_pd_vmod(pDev->lcd_info.mode, VPU_MEM_POWER_ON);
-	//switch_lcd_gates(ON);
-	switch_lcd_mod_gate(ON);
+    switch_vpu_mem_pd_vmod(pDev->lcd_info.mode, VPU_MEM_POWER_ON);
+    //switch_lcd_gates(ON);
+    switch_lcd_mod_gate(ON);
 #endif
-	
-	printk("Init LCD mode: %s(%u) %ubit, %ux%u@%u.%uHz, ss_level=%u(%s)\n", lcd_type_table[lcd_type], lcd_type, pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10), ss_level, lcd_ss_level_table[ss_level]);
 
-	switch(lcd_type){
+    printk("Init LCD mode: %s(%u) %ubit, %ux%u@%u.%uHz, ss_level=%u(%s)\n", lcd_type_table[lcd_type], lcd_type, pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10), ss_level, lcd_ss_level_table[ss_level]);
+
+    switch(lcd_type){
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-			set_pll_lcd(pConf);
-			init_dphy(pConf); //analog
-			set_venc_lcd(pConf);
-			set_tcon_lcd(pConf);
-			set_control_mipi(pConf); //2step
-			break;
-		case LCD_DIGITAL_EDP:
-			set_pll_lcd(pConf);
-			set_venc_lcd(pConf);
-			set_tcon_lcd(pConf);
-			init_dphy(pConf);
-			break;
+        case LCD_DIGITAL_MIPI:
+            set_pll_lcd(pConf);
+            set_venc_lcd(pConf);
+            set_tcon_lcd(pConf);
+            set_control_mipi(pConf);
+            init_dphy(pConf);
+            break;
+        case LCD_DIGITAL_EDP:
+            set_pll_lcd(pConf);
+            set_venc_lcd(pConf);
+            set_tcon_lcd(pConf);
+            init_dphy(pConf);
+            break;
 #endif
-		case LCD_DIGITAL_LVDS:
-			set_pll_lcd(pConf);
-			set_venc_lcd(pConf);
-			set_tcon_lcd(pConf);
-			set_control_lvds(pConf);
-			init_dphy(pConf);
-			break;
-		case LCD_DIGITAL_TTL:
-			set_pll_lcd(pConf);
+        case LCD_DIGITAL_LVDS:
+            set_pll_lcd(pConf);
+            set_venc_lcd(pConf);
+            set_tcon_lcd(pConf);
+            set_control_lvds(pConf);
+            init_dphy(pConf);
+            break;
+        case LCD_DIGITAL_TTL:
+            set_pll_lcd(pConf);
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-			set_venc_ttl(pConf);
+            set_venc_ttl(pConf);
 #elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-			set_venc_lcd(pConf);
+            set_venc_lcd(pConf);
 #endif
-			set_tcon_ttl(pConf);
-			set_control_ttl(pConf);
-			break;
+            set_tcon_ttl(pConf);
+            set_control_ttl(pConf);
+            break;
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
-			set_pll_mlvds(pConf);
-			set_venc_mlvds(pConf);
-			set_tcon_mlvds(pConf);
-			set_control_mlvds(pConf);
-			init_dphy(pConf);
-			break;
+        case LCD_DIGITAL_MINILVDS:
+            set_pll_mlvds(pConf);
+            set_venc_mlvds(pConf);
+            set_tcon_mlvds(pConf);
+            set_control_mlvds(pConf);
+            init_dphy(pConf);
+            break;
 #endif
-		default:
-			printk("Invalid LCD type.\n");
-			break;
-	}
-	set_video_adjust(pConf);
-	printk("%s finished.\n", __FUNCTION__);
+        default:
+            printk("Invalid LCD type.\n");
+            break;
+    }
+    set_video_adjust(pConf);
+    printk("%s finished.\n", __FUNCTION__);
 }
 
-static int _init_lcd_driver_post(Lcd_Config_t *pConf)	//after power on lcd
+static void _disable_lcd_driver(Lcd_Config_t *pConf)	//after power off lcd
 {
-	int ret = 0;
-	
-	switch(pConf->lcd_basic.lcd_type){
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-			break;
-		case LCD_DIGITAL_EDP:
-			ret = set_control_edp(pConf);
-			break;
-#endif
-		case LCD_DIGITAL_LVDS:
-		case LCD_DIGITAL_TTL:
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
-#endif
-		default:
-			break;
-	}
-	printk("%s finished.\n", __FUNCTION__);
-	
-	return ret;
-}
+    int vclk_sel;
 
-static void _disable_lcd_driver_pre(Lcd_Config_t *pConf)	//before power off lcd
-{
-	switch(pConf->lcd_basic.lcd_type){
+    switch(pConf->lcd_basic.lcd_type){
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-			//to do
-			break;		
-		case LCD_DIGITAL_EDP:
-			dplpm_link_off();
-			break;
+        case LCD_DIGITAL_MIPI:
+            mipi_dsi_off();
+            break;
+        case LCD_DIGITAL_EDP:
+            dplpm_off();
+            break;
 #endif
-		case LCD_DIGITAL_LVDS:
-		case LCD_DIGITAL_TTL:
+        case LCD_DIGITAL_LVDS:
+        case LCD_DIGITAL_TTL:
+        case LCD_DIGITAL_MINILVDS:
+        default:
+            break;
+    }
+
+    vclk_sel = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_VCLK_SEL) & 0x1;
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 11, 1);	//close lvds phy clk gate: 0x104c[11]
+    WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
+
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
+    WRITE_LCD_REG(ENCT_VIDEO_EN, 0);	//disable enct
 #endif
-		default:
-			break;
-	}
-	
-	printk("%s finished.\n", __FUNCTION__);
-}
+    WRITE_LCD_REG(ENCL_VIDEO_EN, 0);	//disable encl
 
-static void _disable_lcd_driver(Lcd_Config_t *pConf)	//after power off lcd
-{
-	int vclk_sel;
+    if (vclk_sel)
+        WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 0, 5);	//close vclk2 gate: 0x104b[4:0]
+    else
+        WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 0, 0, 5);		//close vclk1 gate: 0x105f[4:0]
 
-	vclk_sel = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_VCLK_SEL) & 0x1;
-	
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 11, 1);	//close lvds phy clk gate: 0x104c[11]
-	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 16, 1);	//close vid2_pll gate: 0x104c[16]
 
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)	
-	WRITE_LCD_REG(ENCT_VIDEO_EN, 0);	//disable enct
-#endif
-	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);	//disable encl
-	
-	if (vclk_sel)
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 0, 5);	//close vclk2 gate: 0x104b[4:0]
-	else
-		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 0, 0, 5);	//close vclk1 gate: 0x105f[4:0]
-	
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 16, 1);	//close vid2_pll gate: 0x104c[16]
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-	WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 0, 23, 3);	//disable pll_out mux
+    WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 0, 23, 3);	//disable pll_out mux
 #endif
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_PLL_CNTL, 1, 30, 1);		//power down vid2_pll: 0x1047[30]
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_PLL_CNTL, 1, 30, 1);		//power down vid2_pll: 0x1047[30]
 #elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-	WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0, 30, 1);		//disable vid2_pll: 0x10e0[30]
+    WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0, 30, 1);		//disable vid2_pll: 0x10e0[30]
 #endif
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	switch_mod_gate_by_name("tcon", 0);
-	switch_mod_gate_by_name("lvds", 0);
+    switch_mod_gate_by_name("tcon", 0);
+    switch_mod_gate_by_name("lvds", 0);
 #elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-	//switch_lcd_gates(OFF);
-	switch_lcd_mod_gate(OFF);
-	switch_vpu_mem_pd_vmod(pDev->lcd_info.mode, VPU_MEM_POWER_DOWN);
-#endif	
-	printk("disable lcd display driver.\n");
+    //switch_lcd_gates(OFF);
+    switch_lcd_mod_gate(OFF);
+    switch_vpu_mem_pd_vmod(pDev->lcd_info.mode, VPU_MEM_POWER_DOWN);
+#endif
+    printk("disable lcd display driver.\n");
 }
 
 static inline void _enable_vsync_interrupt(void)
@@ -3087,42 +3189,37 @@ static DEFINE_MUTEX(lcd_init_mutex);
 static void _lcd_module_enable(void)
 {
 	int ret = 0;
-	
+
 	mutex_lock(&lcd_init_mutex);
-	
 	BUG_ON(pDev==NULL);
+
 	_init_lcd_driver(pDev->pConf);
-	lcd_power_ctrl(ON);
-	ret = _init_lcd_driver_post(pDev->pConf);
+	ret = lcd_power_ctrl(ON);
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
 		if (ret > 0) {
-			_disable_lcd_driver_pre(pDev->pConf);
 			lcd_power_ctrl(OFF);
 			_disable_lcd_driver(pDev->pConf);
 			mdelay(30);
 			_init_lcd_driver(pDev->pConf);
 			lcd_power_ctrl(ON);
-			_init_lcd_driver_post(pDev->pConf);
 		}
 	}
 #endif
 	data_status = ON;
 	_enable_vsync_interrupt();
-
+	lcd_status_flag = 1;
 	mutex_unlock(&lcd_init_mutex);
 }
 
 static void _lcd_module_disable(void)
 {
 	mutex_lock(&lcd_init_mutex);
-	
+	lcd_status_flag = 0;
 	BUG_ON(pDev==NULL);
 	data_status = OFF;
-	_disable_lcd_driver_pre(pDev->pConf);
 	lcd_power_ctrl(OFF);
 	_disable_lcd_driver(pDev->pConf);
-	
 	mutex_unlock(&lcd_init_mutex);
 }
 
@@ -3297,7 +3394,6 @@ static void _lcd_init(Lcd_Config_t *pConf)
 static int lcd_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
  {
 	printk("[%s]: %lu\n", __FUNCTION__, state);
-	
 	_disable_backlight();
 	_lcd_module_disable();
 
@@ -3592,8 +3688,11 @@ static Lcd_Basic_t temp_lcd_basic;
 static Lcd_Timing_t temp_lcd_timing;
 static unsigned short temp_dith_user, temp_dith_ctrl;
 static unsigned int temp_vadj_brightness, temp_vadj_contrast, temp_vadj_saturation;
+static int temp_ttl_rb_swap, temp_ttl_bit_swap;
 static int temp_lvds_repack, temp_pn_swap, temp_lvds_vswing;
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+static unsigned char temp_dsi_lane_num;
+static unsigned temp_dsi_bit_rate_min, temp_dsi_bit_rate_max, temp_factor_denominator, temp_factor_numerator;
 static unsigned char temp_edp_link_rate, temp_edp_lane_count, temp_edp_vswing, temp_edp_preemphasis;
 #endif
 static unsigned short last_h_active, last_v_active;
@@ -3612,22 +3711,21 @@ static const char * lcd_usage_str =
 "    <xx_pol>   : 0=negative, 1=positive\n"
 "    <xx_valid> : 0=disable, 1=enable\n"
 "\n"
-"    echo swap <rb_swap> <bit_swap> > debug ; write ttl RGB swap config\n"
+"    echo ttl <rb_swap> <bit_swap> > debug ; write ttl RGB swap config\n"
 "    echo lvds <vswing_level> <lvds_repack> <pn_swap> > debug ; write lvds config\n"
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-"    echo edp <link_rate> <lane_count> > debug ; write edp config\n"
-"    echo mreg <register> > debug ; read mipi register\n"
-"    echo mfactor <denominator> <numerator>  > debug ; write factor to config hline hsa hbp\n"
-"    echo mdsi <bit_rate_min> <bit_rate_max> > debug ; config dsi bit_rate_min dsi_bit_rate_max\n"
+"    echo edp <link_rate> <lane_count> <vswing_level> > debug ; write edp config\n"
+"    echo mdsi <bit_rate_min> <bit_rate_max> <factor> > debug ; write mipi-dsi config\n"
 #endif
 "\n"
 "data format:\n"
 "    <xx_swap>      : 0=normal, 1=swap\n"
-"    <vswing_level> : support 5 levels such as 0,1,2,3,4. Default is 1\n"
+"    <vswing_level> : lvds support 5 levels (0,1,2,3,4. Default=1). edp support level 0,1,2,3.\n"
 "    <lvds_repack>  : 0=JEIDA mode, 1=VESA mode\n"
 "    <pn_swap>      : 0=normal, 1=swap lvds p/n channels\n"
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 "    <link_rate>    : 0=1.62G, 1=2.7G\n"
+"    <bit_rate_xxx> : unit in MHz\n"
 #endif
 "\n"
 "    echo offset <h_sign> <h_offset> <v_sign> <v_offset> > debug ; write ttl display offset\n"
@@ -3656,66 +3754,87 @@ static ssize_t lcd_debug_help(struct class *class, struct class_attribute *attr,
 }
 
 static void read_current_lcd_config(Lcd_Config_t *pConf)
-{	
-	unsigned lcd_clk;
-	int h_adj, v_adj;
-	unsigned char vswing_level;
-	
-	lcd_clk = (pConf->lcd_timing.lcd_clk / 1000);
-	h_adj = ((pConf->lcd_timing.h_offset >> 31) & 1);
-	v_adj = ((pConf->lcd_timing.v_offset >> 31) & 1);
-	
-	printk("lcd driver version: %s@%s%s\n\n", DRIVER_DATE, DRIVER_VER, DRV_TYPE);
-	printk("LCD mode: %s %ubit, %ux%u@%u.%uHz\n", lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10));
-	printk("lcd_clk	%u.%uMHz\nss_level	%d\nclk_pol	%d\n\n", lcd_clk / 1000, lcd_clk % 1000, (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf, (pConf->lcd_timing.pol_cntl_addr >> LCD_CPH1_POL) & 1);
-	
-	printk("h_period	%d\nv_period	%d\n", pConf->lcd_basic.h_period, pConf->lcd_basic.v_period);
-	printk("hs_width	%d\nhs_backporch	%d\nhs_pol		%d\n", pConf->lcd_timing.hsync_width, pConf->lcd_timing.hsync_bp, (pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1);
-	printk("vs_width	%d\nvs_backporch	%d\nvs_pol		%d\n", pConf->lcd_timing.vsync_width, pConf->lcd_timing.vsync_bp, (pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1);
-	printk("hvsync_valid	%d\nde_valid	%d\n", pConf->lcd_timing.hvsync_valid, pConf->lcd_timing.de_valid);
-	printk("h_offset	%s%d\nv_offset	%s%d\n\n", (h_adj ? "-" : ""), (pConf->lcd_timing.h_offset & 0xffff), (v_adj ? "-" : ""), (pConf->lcd_timing.v_offset & 0xffff));
-	
-	switch (pConf->lcd_basic.lcd_type) {
-		case LCD_DIGITAL_TTL:
-			printk("rb_swap	%u\nbit_swap	%u\n", pConf->lcd_control.ttl_config->rb_swap, pConf->lcd_control.ttl_config->bit_swap);
-			break;
-		case LCD_DIGITAL_LVDS:
-			printk("vswing_level	%u\nlvds_repack	%u\npn_swap	%u\n", pConf->lcd_control.lvds_config->lvds_vswing, pConf->lcd_control.lvds_config->lvds_repack, pConf->lcd_control.lvds_config->pn_swap);
-			break;
+{
+    unsigned lcd_clk;
+    int h_adj, v_adj;
+
+    lcd_clk = (pConf->lcd_timing.lcd_clk / 1000);
+    h_adj = ((pConf->lcd_timing.h_offset >> 31) & 1);
+    v_adj = ((pConf->lcd_timing.v_offset >> 31) & 1);
+
+    printk("lcd driver version: %s%s\n\n", DRIVER_DATE, DRV_TYPE);
+    printk("LCD mode: %s %ubit, %ux%u@%u.%uHz\n"
+           "lcd_clk           %u.%03uMHz\n"
+           "ss_level          %d\n"
+           "clk_pol           %d\n\n",
+           lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10),
+           (lcd_clk / 1000), (lcd_clk % 1000), ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf), ((pConf->lcd_timing.pol_cntl_addr >> LCD_CPH1_POL) & 1));
+
+    printk("h_period          %d\n"
+           "v_period          %d\n"
+           "hs_width          %d\n"
+           "hs_backporch      %d\n"
+           "hs_pol            %d\n"
+           "vs_width          %d\n"
+           "vs_backporch      %d\n"
+           "vs_pol            %d\n"
+           "vs_h_phase        %s%d\n"
+           "hvsync_valid      %d\n"
+           "de_valid          %d\n"
+           "h_offset          %s%d\n"
+           "v_offset          %s%d\n\n",
+           pConf->lcd_basic.h_period, pConf->lcd_basic.v_period,
+           pConf->lcd_timing.hsync_width, pConf->lcd_timing.hsync_bp, ((pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1),
+           pConf->lcd_timing.vsync_width, pConf->lcd_timing.vsync_bp, ((pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1),
+           (((pConf->lcd_timing.vsync_h_phase >> 31) & 1) ? "-":""), (pConf->lcd_timing.vsync_h_phase & 0xffff), pConf->lcd_timing.hvsync_valid, pConf->lcd_timing.de_valid,
+           (h_adj ? "-" : ""), (pConf->lcd_timing.h_offset & 0xffff), (v_adj ? "-" : ""), (pConf->lcd_timing.v_offset & 0xffff));
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_TTL:
+            printk("rb_swap           %u\n"
+                   "bit_swap          %u\n\n",
+                   pConf->lcd_control.ttl_config->rb_swap, pConf->lcd_control.ttl_config->bit_swap);
+            break;
+        case LCD_DIGITAL_LVDS:
+            printk("vswing_level      %u\n"
+                   "lvds_repack       %u\n"
+                   "pn_swap           %u\n\n",
+                   pConf->lcd_control.lvds_config->lvds_vswing, pConf->lcd_control.lvds_config->lvds_repack, pConf->lcd_control.lvds_config->pn_swap);
+            break;
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		case LCD_DIGITAL_MIPI:
-            //to do
-			break;
-		case LCD_DIGITAL_EDP:
-			printk("link_rate	%s\nlane_count	%u\n", (pConf->lcd_control.edp_config->link_rate == VAL_EDP_TX_LINK_BW_SET_162) ? "1.62G" : "2.7G", pConf->lcd_control.edp_config->lane_count);
-			switch (pConf->lcd_control.edp_config->vswing) {
-				case VAL_EDP_TX_PHY_VSWING_0:
-					vswing_level = 0;
-					break;
-				case VAL_EDP_TX_PHY_VSWING_1:
-					vswing_level = 1;
-					break;
-				case VAL_EDP_TX_PHY_VSWING_2:
-					vswing_level = 2;
-					break;
-				case VAL_EDP_TX_PHY_VSWING_3:
-					vswing_level = 3;
-					break;
-				default:
-					vswing_level = 0;
-					break;
-			}
-			printk("link_adaptive	%u\nvswing		%u\n", pConf->lcd_control.edp_config->link_adaptive, vswing_level);
-			break;
+        case LCD_DIGITAL_MIPI:
+            printk("dsi_lane_num      %u\n"
+                   "dsi_bit_rate      %u.%03uMHz\n"
+                   "operation_mode    %u(%s)\n"
+                   "transfer_ctrl     %u\n\n",
+                   pDev->pConf->lcd_control.mipi_config->lane_num,
+                   (pDev->pConf->lcd_control.mipi_config->bit_rate / 1000000), ((pDev->pConf->lcd_control.mipi_config->bit_rate % 1000000) / 1000),
+                   pDev->pConf->lcd_control.mipi_config->operation_mode, ((pDev->pConf->lcd_control.mipi_config->operation_mode) ? "COMMAND" : "VIDEO"),
+                   pDev->pConf->lcd_control.mipi_config->transfer_ctrl);
+            break;
+        case LCD_DIGITAL_EDP:
+            printk("link_rate         %s\n"
+                   "lane_count        %u\n"
+                   "link_adaptive     %u\n"
+                   "vswing            %u\n\n",
+                   ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G" : "2.7G"), pConf->lcd_control.edp_config->lane_count,
+                   pConf->lcd_control.edp_config->link_adaptive, pConf->lcd_control.edp_config->vswing);
+            break;
 #endif
-		default:
-			break;
-	}
-	
-	if (pConf->lcd_effect.dith_user)
-		printk("dither_user_ctrl	0x%x\n", pConf->lcd_effect.dith_cntl_addr);
-	
-	printk("video_on_pixel	%d\nvideo_on_line	%d\n\n", pConf->lcd_timing.video_on_pixel, pConf->lcd_timing.video_on_line);
+        default:
+            break;
+    }
+
+    if (pConf->lcd_effect.dith_user)
+        printk("dither_ctrl       0x%x\n", pConf->lcd_effect.dith_cntl_addr);
+
+    printk("pll_ctrl          0x%08x\n"
+           "div_ctrl          0x%08x\n"
+           "clk_ctrl          0x%08x\n"
+           "video_on_pixel    %d\n"
+           "video_on_line     %d\n\n", 
+           pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl,
+           pConf->lcd_timing.video_on_pixel, pConf->lcd_timing.video_on_line);
 }
 
 static void scale_framebuffer(void)
@@ -3768,17 +3887,38 @@ static void save_lcd_config(Lcd_Config_t *pConf)
 	temp_lcd_timing.v_offset = pConf->lcd_timing.v_offset;
 	temp_lcd_timing.pol_cntl_addr = pConf->lcd_timing.pol_cntl_addr;
 	
-	temp_lvds_repack = pConf->lcd_control.lvds_config->lvds_repack;
-	temp_pn_swap = pConf->lcd_control.lvds_config->pn_swap;
-	
-	temp_lvds_vswing = pConf->lcd_control.lvds_config->lvds_vswing;
-	
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)	
-	temp_edp_link_rate = pConf->lcd_control.edp_config->link_rate;
-	temp_edp_lane_count = pConf->lcd_control.edp_config->lane_count;
-	temp_edp_vswing = pConf->lcd_control.edp_config->vswing;
-	temp_edp_preemphasis = pConf->lcd_control.edp_config->preemphasis;
+	switch (pConf->lcd_basic.lcd_type) {
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+		case LCD_DIGITAL_MIPI:
+			temp_dsi_lane_num = pConf->lcd_control.mipi_config->lane_num;
+			temp_dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
+			temp_dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
+			temp_factor_denominator = pConf->lcd_control.mipi_config->factor_denominator;
+			temp_factor_numerator = pConf->lcd_control.mipi_config->factor_numerator;
+			break;
+		case LCD_DIGITAL_EDP:
+			temp_edp_link_rate = pConf->lcd_control.edp_config->link_rate;
+			temp_edp_lane_count = pConf->lcd_control.edp_config->lane_count;
+			temp_edp_vswing = pConf->lcd_control.edp_config->vswing;
+			temp_edp_preemphasis = pConf->lcd_control.edp_config->preemphasis;
+			break;
 #endif
+		case LCD_DIGITAL_LVDS:
+			temp_lvds_repack = pConf->lcd_control.lvds_config->lvds_repack;
+			temp_pn_swap = pConf->lcd_control.lvds_config->pn_swap;
+			temp_lvds_vswing = pConf->lcd_control.lvds_config->lvds_vswing;
+			break;
+		case LCD_DIGITAL_TTL:
+			temp_ttl_rb_swap = pConf->lcd_control.ttl_config->rb_swap;
+			temp_ttl_bit_swap = pConf->lcd_control.ttl_config->bit_swap;
+			break;
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+		case LCD_DIGITAL_MINILVDS:
+			break;
+#endif
+		default:
+			break;
+	}
 	
 	temp_dith_user = pConf->lcd_effect.dith_user;
 	temp_dith_ctrl = pConf->lcd_effect.dith_cntl_addr;
@@ -3822,24 +3962,45 @@ static void reset_lcd_config(Lcd_Config_t *pConf)
 	pConf->lcd_timing.v_offset = temp_lcd_timing.v_offset;
 	pConf->lcd_timing.pol_cntl_addr = temp_lcd_timing.pol_cntl_addr;
 	
-	pConf->lcd_control.lvds_config->lvds_repack = temp_lvds_repack;
-	pConf->lcd_control.lvds_config->pn_swap = temp_pn_swap;
-
-	pConf->lcd_control.lvds_config->lvds_vswing = temp_lvds_vswing;
-	
 	pConf->lcd_effect.dith_user = temp_dith_user;
 	pConf->lcd_effect.dith_cntl_addr = temp_dith_ctrl;
 	pConf->lcd_effect.vadj_brightness = temp_vadj_brightness;
 	pConf->lcd_effect.vadj_contrast = temp_vadj_contrast;
 	pConf->lcd_effect.vadj_saturation = temp_vadj_saturation;
 	
+	switch (pConf->lcd_basic.lcd_type) {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-	//restore edp link config, for they are translate from user value to reg value
-	pConf->lcd_control.edp_config->link_rate = temp_edp_link_rate;
-	pConf->lcd_control.edp_config->lane_count = temp_edp_lane_count;
-	pConf->lcd_control.edp_config->vswing = temp_edp_vswing;
-	pConf->lcd_control.edp_config->preemphasis = temp_edp_preemphasis;
+		case LCD_DIGITAL_MIPI:
+			pConf->lcd_control.mipi_config->lane_num = temp_dsi_lane_num;
+			pConf->lcd_control.mipi_config->bit_rate_min = temp_dsi_bit_rate_min;
+			pConf->lcd_control.mipi_config->bit_rate_max = temp_dsi_bit_rate_max;
+			pConf->lcd_control.mipi_config->factor_denominator = temp_factor_denominator;
+			pConf->lcd_control.mipi_config->factor_numerator = temp_factor_numerator;
+			break;
+		case LCD_DIGITAL_EDP:
+			//restore edp link config, for they are translate from user value to reg value
+			pConf->lcd_control.edp_config->link_rate = temp_edp_link_rate;
+			pConf->lcd_control.edp_config->lane_count = temp_edp_lane_count;
+			pConf->lcd_control.edp_config->vswing = temp_edp_vswing;
+			pConf->lcd_control.edp_config->preemphasis = temp_edp_preemphasis;
+			break;
 #endif
+		case LCD_DIGITAL_LVDS:
+			pConf->lcd_control.lvds_config->lvds_repack = temp_lvds_repack;
+			pConf->lcd_control.lvds_config->pn_swap = temp_pn_swap;
+			pConf->lcd_control.lvds_config->lvds_vswing = temp_lvds_vswing;
+			break;
+		case LCD_DIGITAL_TTL:
+			pConf->lcd_control.ttl_config->rb_swap = temp_ttl_rb_swap;
+			pConf->lcd_control.ttl_config->bit_swap = temp_ttl_bit_swap;
+			break;
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+		case LCD_DIGITAL_MINILVDS:
+			break;
+#endif
+		default:
+			break;
+	}
 	
 	lcd_config_init(pDev->pConf);
 	_lcd_module_enable();
@@ -3870,7 +4031,7 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 	unsigned t[6];
 	unsigned venc_video_mode, venc_test_base;
 	
-	switch (buf[0])	{
+	switch (buf[0]) {
 		case 'b':	//write basic config
 			t[0] = 1024;
 			t[1] = 768;
@@ -3884,7 +4045,7 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 			printk("h_active=%d, v_active=%d, h_period=%d, v_period=%d\n", t[0], t[1], t[2], t[3]);
 			break;
 		case 't':
-			if (buf[1] == 'y') {
+			if (buf[1] == 'y') {//type
 				t[0] = 1;
 				t[1] = 6;
 				ret = sscanf(buf, "type %d %d", &t[0], &t[1]);
@@ -3892,10 +4053,10 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 				pDev->pConf->lcd_basic.lcd_bits = t[1];
 				printk("lcd_type: %s, lcd_bits: %d\n", lcd_type_table[t[0]], t[1]);
 			}
-			else if (buf[1] == 'e') {
+			else if (buf[1] == 'e') {//test
 				t[0] = 0;
 				ret = sscanf(buf, "test %d", &t[0]);
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)				
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 				if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
 					venc_video_mode = ENCT_VIDEO_MODE_ADV;
 					venc_test_base = ENCT_TST_EN;
@@ -3938,6 +4099,14 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 						break;
 				}
 			}
+			else if (buf[1] == 't') {//ttl
+				t[0] = 0;
+				t[1] = 0;
+				ret = sscanf(buf, "ttl %d %d", &t[0], &t[1]);
+				pDev->pConf->lcd_control.ttl_config->rb_swap = t[0];
+				pDev->pConf->lcd_control.ttl_config->bit_swap = t[1];
+				printk("ttl rb_swap: %s, bit_swap: %s\n", ((t[0] == 0) ? "disable" : "enable"), ((t[1] == 0) ? "disable" : "enable"));
+			}
 			break;
 		case 'c':
 			t[0] = 40000000;
@@ -3949,60 +4118,40 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 			pDev->pConf->lcd_timing.pol_cntl_addr = ((pDev->pConf->lcd_timing.pol_cntl_addr & ~(1 << LCD_CPH1_POL)) | (t[2] << LCD_CPH1_POL));
 			printk("lcd_clk=%dHz, ss_level=%d, clk_pol=%s\n", t[0], t[1], ((t[2] == 0) ? "negative" : "positive"));
 			break;
-		case 's':
-			if (buf[1] == 'y') {	//sync
-				t[0] = 10;
-				t[1] = 60;
-				t[2] = 0;
-				t[3] = 3;
-				t[4] = 20;
-				t[5] = 0;
-				ret = sscanf(buf, "sync %d %d %d %d %d %d", &t[0], &t[1], &t[2], &t[3], &t[4], &t[5]);
-				pDev->pConf->lcd_timing.hsync_width = t[0];
-				pDev->pConf->lcd_timing.hsync_bp = t[1];
-				pDev->pConf->lcd_timing.vsync_width = t[3];
-				pDev->pConf->lcd_timing.vsync_bp = t[4];
-				pDev->pConf->lcd_timing.pol_cntl_addr = ((pDev->pConf->lcd_timing.pol_cntl_addr & ~((1 << LCD_HS_POL) | (1 << LCD_VS_POL))) | ((t[2] << LCD_HS_POL) | (t[5] << LCD_VS_POL)));
-				printk("hs_width=%d, hs_bp=%d, hs_pol=%s, vs_width=%d, vs_bp=%d, vs_pol=%s\n", t[0], t[1], ((t[2] == 0) ? "negative" : "positive"), t[3], t[4], ((t[5] == 0) ? "negative" : "positive"));
-			}
-			else {	//swap
-				t[0] = 0;
-				t[1] = 0;
-				ret = sscanf(buf, "swap %d %d", &t[0], &t[1]);
-				pDev->pConf->lcd_control.ttl_config->rb_swap = t[0];
-				pDev->pConf->lcd_control.ttl_config->bit_swap = t[1];
-				printk("rb_swap: %s, bit_swap: %s\n", ((t[0] == 0) ? "disable" : "enable"), ((t[1] == 0) ? "disable" : "enable"));
-			}			
+		case 's'://sync
+			t[0] = 10;
+			t[1] = 60;
+			t[2] = 0;
+			t[3] = 3;
+			t[4] = 20;
+			t[5] = 0;
+			ret = sscanf(buf, "sync %d %d %d %d %d %d", &t[0], &t[1], &t[2], &t[3], &t[4], &t[5]);
+			pDev->pConf->lcd_timing.hsync_width = t[0];
+			pDev->pConf->lcd_timing.hsync_bp = t[1];
+			pDev->pConf->lcd_timing.vsync_width = t[3];
+			pDev->pConf->lcd_timing.vsync_bp = t[4];
+			pDev->pConf->lcd_timing.pol_cntl_addr = ((pDev->pConf->lcd_timing.pol_cntl_addr & ~((1 << LCD_HS_POL) | (1 << LCD_VS_POL))) | ((t[2] << LCD_HS_POL) | (t[5] << LCD_VS_POL)));
+			printk("hs_width=%d, hs_bp=%d, hs_pol=%s, vs_width=%d, vs_bp=%d, vs_pol=%s\n", t[0], t[1], ((t[2] == 0) ? "negative" : "positive"), t[3], t[4], ((t[5] == 0) ? "negative" : "positive"));
 			break;
 		case 'v':
-			if (buf[1] == 'a') {	//valid
-				if (buf[2] == 'l') {	//valid
-					t[0] = 0;
-					t[1] = 0;
-					t[2] = 1;
-					ret = sscanf(buf, "valid %d %d", &t[0], &t[1]);
-					pDev->pConf->lcd_timing.hvsync_valid = t[0];
-					pDev->pConf->lcd_timing.de_valid = t[1];
-					printk("hvsync: %s, de: %s\n", ((t[0] == 0) ? "disable" : "enable"), ((t[1] == 0) ? "disable" : "enable"));
-				}
-				else if (buf[2] == 'd') {	//vadj
-					t[0] = 0x0;
-					t[1] = 0x80;
-					t[2] = 0x100;
-					ret = sscanf(buf, "vadj %d %d %d", &t[0], &t[1], &t[2]);
-					pDev->pConf->lcd_effect.vadj_brightness = t[0];
-					pDev->pConf->lcd_effect.vadj_contrast = t[1];
-					pDev->pConf->lcd_effect.vadj_saturation = t[2];
-					printk("video adjust: brightness=0x%x, contrast=0x%x, stauration=0x%x\n", t[0], t[1], t[2]);
-				}
+			if (buf[2] == 'l') {	//valid
+				t[0] = 0;
+				t[1] = 0;
+				t[2] = 1;
+				ret = sscanf(buf, "valid %d %d", &t[0], &t[1]);
+				pDev->pConf->lcd_timing.hvsync_valid = t[0];
+				pDev->pConf->lcd_timing.de_valid = t[1];
+				printk("hvsync: %s, de: %s\n", ((t[0] == 0) ? "disable" : "enable"), ((t[1] == 0) ? "disable" : "enable"));
 			}
-			else if (buf[1] == 'i')  {	//video
-				t[0] = 80;
-				t[1] = 32;
-				ret = sscanf(buf, "video %d %d", &t[0], &t[1]);
-				pDev->pConf->lcd_timing.video_on_pixel = t[0];
-				pDev->pConf->lcd_timing.video_on_line = t[1];
-				printk("video_on_pixel=%d, video_on_line=%d\n", t[0], t[1]);
+			else if (buf[2] == 'd') {	//vadj
+				t[0] = 0x0;
+				t[1] = 0x80;
+				t[2] = 0x100;
+				ret = sscanf(buf, "vadj %d %d %d", &t[0], &t[1], &t[2]);
+				pDev->pConf->lcd_effect.vadj_brightness = t[0];
+				pDev->pConf->lcd_effect.vadj_contrast = t[1];
+				pDev->pConf->lcd_effect.vadj_saturation = t[2];
+				printk("video adjust: brightness=0x%x, contrast=0x%x, stauration=0x%x\n", t[0], t[1], t[2]);
 			}
 			break;
 		case 'o':
@@ -4027,23 +4176,16 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 			break;
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         case 'm':	//write mipi config
-            if (buf[1] == 'r'){
-                ret = sscanf(buf, "mreg %x ", &t[0]);
-                printk("mipi_reg 0x%04x=0x%08x\n",t[0],READ_DSI_REG(t[0]));
-            }
-            else if (buf[1] == 'f'){
-                ret = sscanf(buf, "mfactor %d %d", &t[0], &t[1]);
-                pDev->pConf->lcd_control.mipi_config->numerator=t[0];
-                pDev->pConf->lcd_control.mipi_config->denominator=t[1];
-                dsi_probe(pDev->pConf);
-            }
-            else if (buf[1] == 'd'){
-                ret = sscanf(buf, "mdsi %d %d", &t[0],&t[1]);
-                pDev->pConf->lcd_control.mipi_config->dsi_clk_min = t[0];
-                pDev->pConf->lcd_control.mipi_config->dsi_clk_max = t[1];
-                lcd_config_init(pDev->pConf);
-                printk("dsi bit_rate min=%dMHz, max=%dMHz\n",pDev->pConf->lcd_control.mipi_config->dsi_clk_min,pDev->pConf->lcd_control.mipi_config->dsi_clk_max);
-            }
+            t[0] = 0;
+            t[1] = 0;
+            t[2] = 0;
+            ret = sscanf(buf, "mdsi %d %d %d", &t[0],&t[1],&t[2]);
+            pDev->pConf->lcd_control.mipi_config->bit_rate_min = t[0]*1000;
+            pDev->pConf->lcd_control.mipi_config->bit_rate_max = t[1]*1000;
+            pDev->pConf->lcd_control.mipi_config->factor_numerator=t[2];
+            pDev->pConf->lcd_control.mipi_config->factor_denominator=10;
+            lcd_config_init(pDev->pConf);
+            printk("dsi bit_rate min=%dMHz, max=%dMHz, factor=%d",t[0], t[1], pDev->pConf->lcd_control.mipi_config->factor_numerator=t[2]);
             break;
 #endif
 		case 'd':
@@ -4095,7 +4237,8 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 			else if (buf[1] == 'd') {
 				t[0] = 1;
 				t[1] = 4;
-				ret = sscanf(buf, "edp %u %u", &t[0], &t[1]);
+				t[2] = 0;
+				ret = sscanf(buf, "edp %u %u %u", &t[0], &t[1], &t[2]);
 				if (t[0] == 0)
 					pDev->pConf->lcd_control.edp_config->link_rate = 0;
 				else
@@ -4109,7 +4252,8 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 						pDev->pConf->lcd_control.edp_config->lane_count = 4;
 						break;
 				}
-				printk("set edp link_rate = %sGbps, lane_count = %u\n", ((pDev->pConf->lcd_control.edp_config->link_rate == 0) ? "1.62" : "2.70"), pDev->pConf->lcd_control.edp_config->lane_count);
+				pDev->pConf->lcd_control.edp_config->vswing = t[2];
+				printk("set edp link_rate = %sGbps, lane_count = %u, vswing_level = %u\n", ((pDev->pConf->lcd_control.edp_config->link_rate == 0) ? "1.62" : "2.70"), pDev->pConf->lcd_control.edp_config->lane_count, pDev->pConf->lcd_control.edp_config->vswing);
 			}
 #endif
 			break;
@@ -4124,9 +4268,52 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 	//return 0;
 }
 
+static ssize_t lcd_status_read(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "read lcd status: %s\n", (lcd_status_flag ? "ON":"OFF"));
+}
+
+static ssize_t lcd_status_write(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned temp;
+
+	temp = 1;
+	ret = sscanf(buf, "%d", &temp);
+	if (temp) {
+		if (lcd_status_flag == 0) {
+			mutex_lock(&lcd_vout_mutex);
+			_lcd_module_enable();
+			_enable_backlight();
+			mutex_unlock(&lcd_vout_mutex);
+		}
+		else {
+			printk("lcd has already ON\n");
+		}
+	}
+	else {
+		if (lcd_status_flag == 1) {
+			mutex_lock(&lcd_vout_mutex);
+			_disable_backlight();
+			_lcd_module_disable();
+			mutex_unlock(&lcd_vout_mutex);
+		}
+		else {
+			printk("lcd has already OFF\n");
+		}
+	}
+
+	if (ret != 1 || ret !=2)
+		return -EINVAL;
+
+	return count;
+	//return 0;
+}
+
 static struct class_attribute lcd_debug_class_attrs[] = {
 	__ATTR(debug,  S_IRUGO | S_IWUSR, lcd_debug_help, lcd_debug),
 	__ATTR(help,  S_IRUGO | S_IWUSR, lcd_debug_help, NULL),
+	__ATTR(status,  S_IRUGO | S_IWUSR, lcd_status_read, lcd_status_write),
     __ATTR_NULL
 };
 
@@ -4136,7 +4323,6 @@ static struct class aml_lcd_debug_class = {
 };
 //****************************
 
-#ifdef CONFIG_USE_OF
 static int amlogic_pmu_gpio_name_map_num(const char *name)
 {
 	int index;
@@ -4148,12 +4334,14 @@ static int amlogic_pmu_gpio_name_map_num(const char *name)
 	return index;
 }
 
+#ifdef CONFIG_USE_OF
 static inline int _get_lcd_model_timing(struct platform_device *pdev)
 {
 	int ret=0;
 	const char *str;
 	unsigned int val;
-	unsigned int lcd_para[5];
+	unsigned int lcd_para[20];
+	int i;
 	struct device_node *lcd_model_node;
 	phandle fhandle;
 	
@@ -4251,80 +4439,89 @@ static inline int _get_lcd_model_timing(struct platform_device *pdev)
 		}
 		DBG_PRINT("pol hsync = %u, vsync = %u\n", (pDev->pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1, (pDev->pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1);
 		ret = of_property_read_u32_array(lcd_model_node,"vsync_horizontal_phase",&lcd_para[0], 2);
-    if(ret){
+		if(ret){
 			printk("faild to get vsync_horizontal_phase\n");
 			pDev->pConf->lcd_timing.vsync_h_phase = 0;
-        } else {
-            pDev->pConf->lcd_timing.vsync_h_phase  = ((lcd_para[1] << 0) | ((lcd_para[0] & 0xffff) << 31));
-        }
+		} else {
+			pDev->pConf->lcd_timing.vsync_h_phase = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
+		}
 		if (lcd_para[0] == 0)
 			DBG_PRINT("vsync_horizontal_phase= %d\n", lcd_para[1]);
 		else
 			DBG_PRINT("vsync_horizontal_phase= -%d\n", lcd_para[1]);
-/////////////////////////////////////
+
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-		if (LCD_DIGITAL_MIPI == pDev->pConf->lcd_basic.lcd_type) {
-
-        DSI_Config_t *cfg = pDev->pConf->lcd_control.mipi_config;
-        ret = of_property_read_u32_array(lcd_model_node,"dsi_lane_num",&lcd_para[0], 1);
-        if(ret){
-                printk("faild to get lane num\n");
-                cfg->lane_num = 4;
-        } else {
-                cfg->lane_num = lcd_para[0];
-        }
-        DBG_PRINT("dsi_lane_num= %d\n",  cfg->lane_num);
- 				ret = of_property_read_u32_array(lcd_model_node,"dsi_bit_rate_min_max",&lcd_para[0], 2);
-        if(ret){
-        					printk("faild to get dsi_bit_rate_min_max\n");
-        					cfg->dsi_clk_min  = 900;
-        					cfg->dsi_clk_max  = 1000;
-        		} 
-        else {
-        					cfg->dsi_clk_min  = lcd_para[0];
-        					cfg->dsi_clk_max  = lcd_para[1];
-				    }
-				DBG_PRINT("dsi_bit_rate_min_max_div= %d %d\n", cfg->dsi_clk_min,cfg->dsi_clk_max);
-				cfg->denominator = 10;
-        ret = of_property_read_u32_array(lcd_model_node,"pclk_lanebyteclk_factor",&lcd_para[0], 1);
-        if(ret){
+        if (LCD_DIGITAL_MIPI == pDev->pConf->lcd_basic.lcd_type) {
+            ret = of_property_read_u32(lcd_model_node,"dsi_lane_num",&val);
+            if(ret){
+                printk("faild to get dsi_lane_num\n");
+                pDev->pConf->lcd_control.mipi_config->lane_num = 4;
+            }
+            else {
+                pDev->pConf->lcd_control.mipi_config->lane_num = (unsigned char)val;
+            }
+            DBG_PRINT("dsi_lane_num= %d\n",  pDev->pConf->lcd_control.mipi_config->lane_num);
+            ret = of_property_read_u32_array(lcd_model_node,"dsi_bit_rate_min_max",&lcd_para[0], 2);
+            if(ret){
+                printk("faild to get dsi_bit_rate_min_max\n");
+                lcd_para[0] = 0;
+                lcd_para[1] = 0;
+            }
+            pDev->pConf->lcd_control.mipi_config->bit_rate_min = lcd_para[0]*1000;
+            pDev->pConf->lcd_control.mipi_config->bit_rate_max = lcd_para[1]*1000;
+            DBG_PRINT("dsi_bit_rate_min= %dMHz max=%dMHz\n", lcd_para[0], lcd_para[1]);
+            ret = of_property_read_u32(lcd_model_node,"pclk_lanebyteclk_factor",&val);
+            if(ret){
                 printk("faild to get pclk_lanebyteclk_factor\n");
-                cfg->numerator  = 0; //calculator
-        } else {
-                cfg->numerator  = lcd_para[0]; //calculator
-        }
-        DBG_PRINT("denominator= %d, numerator=%d\n",  cfg->denominator, cfg->numerator);
-        ret = of_property_read_u32_array(lcd_model_node,"dsi_transfer_mode",&lcd_para[0], 1);
-        if(ret){
-                printk("faild to get dsi_transfer_mode\n");
-                cfg->trans_mode  = 1; //calculator
-        } else {
-                cfg->trans_mode  = lcd_para[0]; //calculator
-        }
-        DBG_PRINT("trans_mode= %d\n",  cfg->trans_mode);
-        ret = of_property_read_u32_array(lcd_model_node,"dsi_power_on_cmd",&cfg->mipi_init[0], 20);
-        if(ret){
-                printk("faild to get dsi_power_on_cmd\n");
-                cfg->mipi_init_flag  = 0; 
-        } else {
-                cfg->mipi_init_flag  = 1;
-                }
-        DBG_PRINT("mipi_init_reg= %d\n",  cfg->mipi_init_flag);
-        ret = of_property_read_u32_array(lcd_model_node,"dsi_sleep_out_display_on_delay",&lcd_para[0], 2);
-        if(ret){
+                pDev->pConf->lcd_control.mipi_config->factor_numerator = 0;
+            }
+            else {
+                pDev->pConf->lcd_control.mipi_config->factor_numerator = val;
+            }
+            pDev->pConf->lcd_control.mipi_config->factor_denominator = 10;
+            DBG_PRINT("pclk_lanebyteclk factor= %d\n", pDev->pConf->lcd_control.mipi_config->factor_numerator);
+            ret = of_property_read_u32(lcd_model_node,"dsi_operation_mode",&val);
+            if(ret){
+                printk("faild to get dsi_operation_mode\n");
+                pDev->pConf->lcd_control.mipi_config->operation_mode = OPERATION_COMMAND_MODE;
+            }
+            else {
+                pDev->pConf->lcd_control.mipi_config->operation_mode = (unsigned char)val;
+            }
+            DBG_PRINT("dsi_operation_mode = %s(%d)\n", (pDev->pConf->lcd_control.mipi_config->operation_mode ? "command":"video"), pDev->pConf->lcd_control.mipi_config->operation_mode);
+            ret = of_property_read_u32(lcd_model_node,"dsi_transfer_ctrl",&val);
+            if(ret){
+                printk("faild to get dsi_transfer_ctrl\n");
+                pDev->pConf->lcd_control.mipi_config->transfer_ctrl = 0;
+            }
+            else {
+                pDev->pConf->lcd_control.mipi_config->transfer_ctrl = (unsigned char)val;
+            }
+            DBG_PRINT("dsi_transfer_ctrl = %d\n", pDev->pConf->lcd_control.mipi_config->transfer_ctrl);
+            ret = of_property_read_u32_array(lcd_model_node,"dsi_on_off_init",&lcd_para[0], 2);
+            if(ret){
+                printk("faild to get dsi_on_off_init\n");
+                pDev->pConf->lcd_control.mipi_config->init_on_flag =0; 
+                pDev->pConf->lcd_control.mipi_config->init_off_flag =0;
+            } else {
+                pDev->pConf->lcd_control.mipi_config->init_on_flag =(unsigned char)(lcd_para[0]); 
+                pDev->pConf->lcd_control.mipi_config->init_off_flag =(unsigned char)(lcd_para[1]);
+            }
+            DBG_PRINT("dsi_on_init= %d, dsi_off_init=%d\n",  pDev->pConf->lcd_control.mipi_config->init_on_flag, pDev->pConf->lcd_control.mipi_config->init_off_flag);
+            ret = of_property_read_u32_array(lcd_model_node,"dsi_sleep_out_display_on_delay",&lcd_para[0], 2);
+            if(ret){
                 printk("faild to get dsi_sleep_out_display_on_delay\n");
-                cfg->sleep_out_delay  =100; 
-                cfg->display_on_delay  =100;
-        } else {
-                cfg->sleep_out_delay  =lcd_para[0]; 
-                cfg->display_on_delay  =lcd_para[1];
+                pDev->pConf->lcd_control.mipi_config->sleep_out_delay =10; 
+                pDev->pConf->lcd_control.mipi_config->display_on_delay =10;
+            } else {
+                pDev->pConf->lcd_control.mipi_config->sleep_out_delay =lcd_para[0]; 
+                pDev->pConf->lcd_control.mipi_config->display_on_delay =lcd_para[1];
+            }
+            DBG_PRINT("sleep_out_delay= %d, display_on_delay=%d\n",  pDev->pConf->lcd_control.mipi_config->sleep_out_delay, pDev->pConf->lcd_control.mipi_config->display_on_delay);
         }
-        DBG_PRINT("sleep_out_delay= %d, display_on_delay=%d\n",  cfg->sleep_out_delay,cfg->display_on_delay);
-     }
 #endif
-/////////////////////////////////////
-   }
-	return ret;
+    }
+    return ret;
 }
 
 static inline int _get_lcd_default_config(struct platform_device *pdev)
@@ -4816,11 +5013,10 @@ static int lcd_probe(struct platform_device *pdev)
 {
     struct aml_lcd_platform *pdata;  
 	int ret = 0;
-	//spin_lock_init(&lcd_init_lock);
 	spin_lock_init(&gamma_write_lock);
 	spin_lock_init(&lcd_clk_lock);
 	
-	printk("lcd driver version: %s@%s%s\n\n", DRIVER_DATE, DRIVER_VER, DRV_TYPE);
+	printk("lcd driver version: %s%s\n\n", DRIVER_DATE, DRV_TYPE);
 	
 #ifdef 	CONFIG_USE_OF
 	pdata = lcd_get_driver_data(pdev);
@@ -4840,6 +5036,7 @@ static int lcd_probe(struct platform_device *pdev)
 	_get_lcd_default_config(pdev);
 	_get_lcd_power_config(pdev);
 #endif
+	save_lcd_config(pDev->pConf);
 	lcd_config_init(pDev->pConf);
     _lcd_init(pDev->pConf);
 	
@@ -4849,7 +5046,6 @@ static int lcd_probe(struct platform_device *pdev)
 		printk("notifier register lcd_reboot_notifier fail!\n");
 	}	
 	
-	save_lcd_config(pDev->pConf);
 	ret = class_register(&aml_lcd_debug_class);
 	if(ret){
 		printk("class register aml_lcd_debug_class fail!\n");
diff --git a/drivers/amlogic/display/vout/mipi_dsi_util.c b/drivers/amlogic/display/vout/mipi_dsi_util.c
index f76498382adb..641bf3c92239 100755
--- a/drivers/amlogic/display/vout/mipi_dsi_util.c
+++ b/drivers/amlogic/display/vout/mipi_dsi_util.c
@@ -1,6 +1,8 @@
 #include <linux/types.h>
 #include <mach/cpu.h>
 #include <plat/cpu.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
 #include <linux/amlogic/vout/lcdoutc.h>
 #include <linux/kernel.h>
@@ -8,10 +10,12 @@
 #include <mach/mipi_dsi_reg.h>
 #include <linux/amlogic/vout/lcd_reg.h>
 
-//#include <asm/arch/io.h>
 #include <mach/io.h>
 #include <plat/io.h>
 #include <linux/delay.h>
+#ifdef CONFIG_AML_LCD_EXTERN
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#endif
 
 //#define PRINT_DEBUG_INFO
 #ifdef PRINT_DEBUG_INFO
@@ -20,681 +24,214 @@
 #define DPRINT(...)
 #endif
 
-#ifndef VPP_OUT_SATURATE
-#define VPP_OUT_SATURATE            (1 << 0)
-#endif
-
-extern unsigned int vpp2_sel; /*0,vpp; 1, vpp2 */
-static unsigned int exp2_tbl[]={1,2,4,8};
-#ifndef FIN_FREQ
-#define FIN_FREQ        (24 * 1000)
-#endif
+//===============================================================================
+// Define MIPI DSI Default config
+//===============================================================================
+#define MIPI_DSI_VIRTUAL_CHAN_ID        0                       // Range [0,3]
+#define MIPI_DSI_CMD_TRANS_TYPE         DCS_TRANS_LP            // Define DSI command transfer type: high speed or low power
+#define MIPI_DSI_DCS_ACK_TYPE           MIPI_DSI_DCS_NO_ACK     // Define if DSI command need ack: req_ack or no_ack
+#define MIPI_DSI_VIDEO_MODE_TYPE        BURST_MODE              // Applicable only to video mode. Define picture data transfer method: non-burst sync pulse; non-burst sync event; or burst.
+#define MIPI_DSI_TEAR_SWITCH            MIPI_DCS_DISABLE_TEAR
+//===============================================================================
 
-void init_mipi_dsi_phy(Lcd_Config_t *p)
-{
-        unsigned int div;
-        DSI_Config_t *cfg= p->lcd_control.mipi_config;
-
-        div = cfg->dsi_clk_div;
-
-        switch (div){
-                case 1:
-                        div = 0;
-                        break;
-                case 2:
-                        div = 2;
-                        break;
-                case 4:
-                        div = 3;
-                        break;
-                default:
-                        printk("error,valid divider is 2, 4, 8\n");
-                        break;
-        }
+static DSI_Config_t *dsi_config;
 
-        // enable phy clock.
-        //supose the VID2 PLL clock is locked and stable.
-        WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1);          //enable DSI top clock.
-        WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1 |          //enable the DSI PLL clock .
-                        (1 << 7 )  |   //enable pll clock which connected to  DDR clock path
-                        (1 << 8 )  |   //enable the clock divider counter
-                        (0 << 9 )  |   //enable the divider clock out
-                        (div << 10 ) |   //select the clock freq /2.
-                        (0 << 12));    //enable the byte clock generateion.
-
-        WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1 |          //enable DSI top clock.
-                        (1 << 7 )  |   //enable pll clock which connected to  DDR clock path
-                        (1 << 8 )  |   //enable the clock divider counter
-                        (1 << 9 )  |   //enable the divider clock out
-                        (div << 10 ) |   //select the clock freq /2.
-                        (0 << 12));    //enable the byte clock generateion.
-
-        WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1 |          //enable DSI top clock.
-                        (1 << 7 )  |   //enable pll clock which connected to  DDR clock path
-                        (1 << 8 )  |   //enable the clock divider counter
-                        (1 << 9 )  |   //enable the divider clock out
-                        (div << 10 ) |   //select the clock freq /2.
-                        (1 << 12));    //enable the byte clock generateion.
-
-        WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL,  1, 31, 1);
-        WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL,  0, 31, 1);
-
-        WRITE_DSI_REG(MIPI_DSI_CLK_TIM,  0x05210f08);//0x03211c08
-        WRITE_DSI_REG(MIPI_DSI_CLK_TIM1, 0x8);//??
-        WRITE_DSI_REG(MIPI_DSI_HS_TIM, 0x060f090d);//0x050f090d
-        WRITE_DSI_REG(MIPI_DSI_LP_TIM, 0x4a370e0e);
-        WRITE_DSI_REG(MIPI_DSI_ANA_UP_TIM, 0x0100); //?? //some number to reduce sim time.
-        WRITE_DSI_REG(MIPI_DSI_INIT_TIM, 0x00d4); //0xe20   //30d4 -> d4 to reduce sim time.
-        WRITE_DSI_REG(MIPI_DSI_WAKEUP_TIM, 0x48); //0x8d40  //1E848-> 48 to reduct sim time.
-        WRITE_DSI_REG(MIPI_DSI_LPOK_TIM,  0x7C);   //wait for the LP analog ready.
-        WRITE_DSI_REG(MIPI_DSI_ULPS_CHECK,  0x927C);   //1/3 of the tWAKEUP.
-        WRITE_DSI_REG(MIPI_DSI_LP_WCHDOG,  0x1000);   // phy TURN watch dog.
-        WRITE_DSI_REG(MIPI_DSI_TURN_WCHDOG,  0x1000);   // phy ESC command watch dog.
-
-        // Powerup the analog circuit.
-        WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0);
-}
+#define RETRY_CNT       2000
+#define WARNNING_CNT    100
 
-void powerup_mipi_dsi_dphy()
+static inline void print_mipi_cmd_status(int cnt)
 {
-        // Power up DSI
-        WRITE_LCD_REG( MIPI_DSI_DWC_PWR_UP_OS, 1);
-
-        // Setup Parameters of DPHY
-        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TST_CTRL1_OS, 0x00010044);                            // testcode
-        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x2);
-        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x0);
-        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TST_CTRL1_OS, 0x00000074);                            // testwrite
-        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x2);
-        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x0);
-
-        // Power up D-PHY
-        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_RSTZ_OS, 0xf);
+    if (cnt <= WARNNING_CNT) {
+        printk("cmd error: status=0x%04x, int0=0x%06x, int1=0x%06x\n", READ_LCD_REG(MIPI_DSI_DWC_CMD_PKT_STATUS_OS), READ_LCD_REG(MIPI_DSI_DWC_INT_ST0_OS), READ_LCD_REG(MIPI_DSI_DWC_INT_ST1_OS));
+    }
 }
 
-void powerdown_mipi_dsi_dphy()
-{
-        // Power down DSI
-        WRITE_LCD_REG( MIPI_DSI_DWC_PWR_UP_OS, 0);
-
-        // Power down D-PHY, do not have to close dphy
-        // WRITE_LCD_REG( MIPI_DSI_DWC_PHY_RSTZ_OS, (READ_LCD_REG( MIPI_DSI_DWC_PHY_RSTZ_OS ) & 0xc));
-        // WRITE_LCD_REG( MIPI_DSI_DWC_PHY_RSTZ_OS, 0xc);
+static void print_info(DSI_Config_t *cfg)
+{
+    printk("================================================\n");
+    printk("MIPI DSI Config\n");
+    printk(" Lane Num:              %d\n", cfg->lane_num);
+    printk(" Bit Rate min:          %dMHz\n", (cfg->bit_rate_min / 1000));
+    printk(" Bit Rate max:          %dMHz\n", (cfg->bit_rate_max / 1000));
+    printk(" Bit Rate:              %d.%03dMHz\n", (cfg->bit_rate / 1000000), (cfg->bit_rate % 1000000) / 1000);
+    printk(" Pclk lanebyte factor:  %d\n", ((cfg->factor_numerator * 100 / cfg->factor_denominator) + 5) / 10);
+    printk(" Operation mode:        %s\n", (cfg->operation_mode == OPERATION_COMMAND_MODE) ? "COMMAND":"VIDEO");
+    printk(" Transfer control:      %d\n", cfg->transfer_ctrl);
+    if(cfg->video_mode_type == NON_BURST_SYNC_PULSE) {
+        printk(" Video mode type:       NON_BURST_SYNC_PULSE\n");
+    }
+    else if(cfg->video_mode_type == NON_BURST_SYNC_EVENT) {
+        printk(" Video mode type:       NON_BURST_SYNC_EVENT\n");
+    }
+    else if(cfg->video_mode_type == BURST_MODE) {
+        printk(" Video mode type:       BURST_MODE\n");
+    }
+
+    printk(" Venc format:           %d\n", cfg->venc_fmt);
+
+    switch(cfg->dpi_data_format) {
+        case COLOR_16BIT_CFG_1  :
+            printk(" Data Format:           COLOR_16BIT_CFG_1\n");
+            break;
+        case COLOR_16BIT_CFG_2  :
+            printk(" Data Format:           COLOR_16BIT_CFG_2\n");
+            break;
+        case COLOR_16BIT_CFG_3  :
+            printk(" Data Format:           COLOR_16BIT_CFG_3\n");
+            break;
+        case COLOR_18BIT_CFG_1  :
+            printk(" Data Format:           COLOR_18BIT_CFG_1\n");
+            break;
+        case COLOR_18BIT_CFG_2  :
+            printk(" Data Format:           COLOR_18BIT_CFG_2\n");
+            break;
+        case COLOR_24BIT        :
+            printk(" Data Format:           COLOR_24BIT\n");
+            break;
+        case COLOR_20BIT_LOOSE  :
+            printk(" Data Format:           COLOR_20BIT_LOOSE\n");
+            break;
+        case COLOR_24_BIT_YCBCR :
+            printk(" Data Format:           COLOR_24BIT_YCBCR\n");
+            break;
+        case COLOR_16BIT_YCBCR  :
+            printk(" Data Format:           COLOR_16BIT_YCBCR\n");
+            break;
+        case COLOR_30BIT        :
+            printk(" Data Format:           COLOR_30BIT\n");
+            break;
+        case COLOR_36BIT        :
+            printk(" Data Format:           COLOR_36BIT\n");
+            break;
+        case COLOR_12BIT        :
+            printk(" Data Format:           COLOR_12BIT\n");
+            break;
+        case COLOR_RGB_111      :
+            printk(" Data Format:           COLOR_RGB_111\n");
+            break;
+        case COLOR_RGB_332      :
+            printk(" Data Format:           COLOR_RGB332\n");
+            break;
+        case COLOR_RGB_444      :
+            printk(" Data Format:           COLOR_RGB444\n");
+            break;
+        default            :
+            printk(" Error: un-support Data Format, Please Check\n");
+            break;
+    }
+    //printk(" POLARITY:              HIGH ACTIVE\n");
+    printk(" Enable CRC/ECC/BTA\n");
+    printk("================================================\n");
 }
 
 // -----------------------------------------------------------------------------
 //                     Function: check_phy_st
-// Check the status of the dphy: phylock and stopstateclklane
+// Check the status of the dphy: phylock and stopstateclklane, to decide if the DPHY is ready
 // -----------------------------------------------------------------------------
-void check_phy_st()
-{
-        // Check the phylock/stopstateclklane to decide if the DPHY is ready
-        while((( READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS ) >> BIT_PHY_LOCK) & 0x1) == 0){
-                delay_us(6);
-        }
-        while((( READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS ) >> BIT_PHY_STOPSTATECLKLANE) & 0x1) == 0){
-                DPRINT(" Waiting STOP STATE LANE\n");
-                delay_us(6);
-        }
+static void check_phy_status(void)
+{
+    while((( READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS ) >> BIT_PHY_LOCK) & 0x1) == 0){
+        udelay(6);
+    }
+    while((( READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS ) >> BIT_PHY_STOPSTATECLKLANE) & 0x1) == 0){
+        DPRINT(" Waiting STOP STATE LANE\n");
+        udelay(6);
+    }
 }
 
 // -----------------------------------------------------------------------------
 //                     Function: set_mipi_dcs
 // Configure relative registers in command mode
 // -----------------------------------------------------------------------------
-extern void set_mipi_dcs(int trans_type,                                       // 0: high speed, 1: low power
-                int req_ack,                                          // 1: request ack, 0: do not need ack
-                int tear_en                                           // 1: enable tear ack, 0: disable tear ack
-                )
-{
-        WRITE_LCD_REG( MIPI_DSI_DWC_CMD_MODE_CFG_OS, (trans_type << BIT_MAX_RD_PKT_SIZE) | (trans_type << BIT_DCS_LW_TX)    |
-                        (trans_type << BIT_DCS_SR_0P_TX)    | (trans_type << BIT_DCS_SW_1P_TX) |
-                        (trans_type << BIT_DCS_SW_0P_TX)    | (trans_type << BIT_GEN_LW_TX)    |
-                        (trans_type << BIT_GEN_SR_2P_TX)    | (trans_type << BIT_GEN_SR_1P_TX) |
-                        (trans_type << BIT_GEN_SR_0P_TX)    | (trans_type << BIT_GEN_SW_2P_TX) |
-                        (trans_type << BIT_GEN_SW_1P_TX)    | (trans_type << BIT_GEN_SW_0P_TX) |
-                        (req_ack    << BIT_ACK_RQST_EN)     | (tear_en    << BIT_TEAR_FX_EN)  );
-
-        if(tear_en == MIPI_DCS_ENABLE_TEAR) {
-                // Enable Tear Interrupt if tear_en is valid
-                WRITE_LCD_REG( MIPI_DSI_TOP_INTR_CNTL_STAT, (READ_LCD_REG(MIPI_DSI_TOP_INTR_CNTL_STAT) | (0x1<<BIT_EDPITE_INT_EN)) );
-                // Enable Measure Vsync
-                WRITE_LCD_REG( MIPI_DSI_TOP_MEAS_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_MEAS_CNTL) | (0x1<<BIT_VSYNC_MEAS_EN
-                                                | (0x1<<BIT_TE_MEAS_EN))) );
-        }
+static void set_mipi_dcs(int trans_type,        // 0: high speed, 1: low power
+                         int req_ack,           // 1: request ack, 0: do not need ack
+                         int tear_en)           // 1: enable tear ack, 0: disable tear ack
+{
+    WRITE_LCD_REG( MIPI_DSI_DWC_CMD_MODE_CFG_OS, (trans_type << BIT_MAX_RD_PKT_SIZE) | (trans_type << BIT_DCS_LW_TX)    |
+                    (trans_type << BIT_DCS_SR_0P_TX)    | (trans_type << BIT_DCS_SW_1P_TX) |
+                    (trans_type << BIT_DCS_SW_0P_TX)    | (trans_type << BIT_GEN_LW_TX)    |
+                    (trans_type << BIT_GEN_SR_2P_TX)    | (trans_type << BIT_GEN_SR_1P_TX) |
+                    (trans_type << BIT_GEN_SR_0P_TX)    | (trans_type << BIT_GEN_SW_2P_TX) |
+                    (trans_type << BIT_GEN_SW_1P_TX)    | (trans_type << BIT_GEN_SW_0P_TX) |
+                    (req_ack    << BIT_ACK_RQST_EN)     | (tear_en    << BIT_TEAR_FX_EN)  );
+
+    if (tear_en == MIPI_DCS_ENABLE_TEAR) {
+        // Enable Tear Interrupt if tear_en is valid
+        WRITE_LCD_REG( MIPI_DSI_TOP_INTR_CNTL_STAT, (READ_LCD_REG(MIPI_DSI_TOP_INTR_CNTL_STAT) | (0x1<<BIT_EDPITE_INT_EN)) );
+        // Enable Measure Vsync
+        WRITE_LCD_REG( MIPI_DSI_TOP_MEAS_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_MEAS_CNTL) | (0x1<<BIT_VSYNC_MEAS_EN | (0x1<<BIT_TE_MEAS_EN))));
+    }
 }
 // -----------------------------------------------------------------------------
 //                     Function: set_mipi_int
 // Configure relative registers for mipi interrupt
 // -----------------------------------------------------------------------------
-extern void set_mipi_int()
+static void set_mipi_int(void)
 {
-        WRITE_LCD_REG( MIPI_DSI_DWC_INT_MSK0_OS, 0);
-        WRITE_LCD_REG( MIPI_DSI_DWC_INT_MSK1_OS, 0);
-}
-
-// ----------------------------------------------------------------------------
-//                     Function: set_mipi_dsi_host
-// Configure the mipi dsi host according the trans type
-// ----------------------------------------------------------------------------
-void set_mipi_dsi_host_to_command_mode(int lane_num,                                           // lane number, from 1 to 4
-                int vcid,                                               // virtual id
-                int venc_color_code,                                    // VENC output data width
-                int color_code,                                         // color code
-                int chroma_subsample,                                   // chroma_subsample for YUV422 or YUV420 only
-                int trans_mode,                                         // video mode/command mode
-                tv_enc_lcd_type_t output_type,                          // video type, such as 1080x720
-                int vid_mode_type,                                      // video mode : burst/non_burst
-                int check_phy_status,                                   // enable/disable phy lock check, disable for multiple pic test
-                Lcd_Config_t *p)
-{
-        int real_lane_num = lane_num+1;
-        int pic_width, pic_height;
-        int num_of_chunk;
-        int pixel_per_chunk = 4;
-        int byte_per_chunk;
-        int totol_bytes_per_chunk;
-        int chunk_overhead;
-        int vid_null_size;
-
-        pic_width  = p->lcd_basic.h_active;
-        pic_height = p->lcd_basic.v_active;
-        totol_bytes_per_chunk = real_lane_num*pixel_per_chunk* 3 / 4;
-
-        // one lene has 8 bytes for 4 pixels
-        // according to DSI spec line50
-        switch(color_code) {
-                case COLOR_24_BIT_YCBCR :
-                case COLOR_24BIT        :
-                        byte_per_chunk = 18;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-                        // byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-                        break;
-                case COLOR_20BIT_LOOSE  :
-                case COLOR_18BIT_CFG_2  :
-                        byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-                        break;
-                case COLOR_16BIT_YCBCR :
-                case COLOR_16BIT_CFG_1 :
-                case COLOR_16BIT_CFG_2 :
-                case COLOR_16BIT_CFG_3 :
-                        byte_per_chunk =  8;                                             // at least 3 lanes(8+6=14): 3*8-14=10>6
-                        break;
-                case COLOR_30BIT :
-                        byte_per_chunk = 15;                                             // at least 4 lanes(15+6=21): 4*8-21=11>6
-                        break;
-                case COLOR_36BIT :
-                        byte_per_chunk = 18;                                             // at least 4 leans(18+6=24): 4*8-24=8>6
-                        break;
-                case COLOR_12BIT :
-                        byte_per_chunk =  6;                                             // at least 3 leans(6+6=12): 3*8-12=12>6
-                        break;
-                case COLOR_18BIT_CFG_1 :
-                        byte_per_chunk =  9;                                             // at least 23lanes(9+6=15): 3*8-15=9>6
-                        break;
-                case COLOR_RGB_111 :
-                case COLOR_RGB_332 :
-                case COLOR_RGB_444 :
-                        break;
-                default :
-                        DPRINT(" Error: Unsupport Color Format So Far, Please Add More\n");
-                        break;
-        }    /*switch(color_code)*/
-        num_of_chunk = pic_width/pixel_per_chunk;
-        chunk_overhead = totol_bytes_per_chunk-(byte_per_chunk+6);                 // byte_per_chunk+6=valid_payload
-
-        // -----------------------------------------------------
-        // Standard Configuration for Video Mode Transfer
-        // -----------------------------------------------------
-        // 1,    Configure Lane number and phy stop wait time
-        if ((output_type != TV_ENC_LCD240x160_dsi) &&
-                        (output_type != TV_ENC_LCD1920x1200p) &&
-                        (output_type != TV_ENC_LCD2560x1600) &&
-                        (output_type != TV_ENC_LCD768x1024p)) {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_IF_CFG_OS, (0x28 << BIT_PHY_STOP_WAIT_TIME) | (lane_num << BIT_N_LANES));
-        } else {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_IF_CFG_OS, (1 << BIT_PHY_STOP_WAIT_TIME) | (lane_num << BIT_N_LANES));
-        }
-
-        // 2.1,  Configure Virtual channel settings
-        WRITE_LCD_REG( MIPI_DSI_DWC_DPI_VCID_OS, vcid );
-        // 2.2,  Configure Color format
-        WRITE_LCD_REG( MIPI_DSI_DWC_DPI_COLOR_CODING_OS, ((color_code == COLOR_18BIT_CFG_2 ? 1 : 0) << BIT_LOOSELY18_EN) |
-                        (color_code << BIT_DPI_COLOR_CODING) );
-        // 2.2.1 Configure Set color format for DPI register
-        WRITE_LCD_REG( MIPI_DSI_TOP_CNTL, ((READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0xf<<BIT_DPI_COLOR_MODE) & ~(0x7<<BIT_IN_COLOR_MODE) & ~(0x3<<BIT_CHROMA_SUBSAMPLE)) |
-                                (color_code         << BIT_DPI_COLOR_MODE)  |
-                                (venc_color_code    << BIT_IN_COLOR_MODE)   |
-                                (chroma_subsample   << BIT_CHROMA_SUBSAMPLE)) );
-        // 2.3   Configure Signal polarity
-        WRITE_LCD_REG( MIPI_DSI_DWC_DPI_CFG_POL_OS, (0x0 << BIT_COLORM_ACTIVE_LOW) |
-                        (0x0 << BIT_SHUTD_ACTIVE_LOW)  |
-                        (0x0 << BIT_HSYNC_ACTIVE_LOW)  |
-                        (0x0 << BIT_VSYNC_ACTIVE_LOW)  |
-                        (0x0 << BIT_DATAEN_ACTIVE_LOW));
-
-        // -----------------------------------------------------
-        // Finish Configuration
-        // -----------------------------------------------------
-
-
-        // Inner clock divider settings
-        WRITE_LCD_REG( MIPI_DSI_DWC_CLKMGR_CFG_OS, (0x1 << BIT_TO_CLK_DIV) |
-                        (0x1e << BIT_TX_ESC_CLK_DIV) );
-        // Packet header settings
-        WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
-                        (1 << BIT_ECC_RX_EN) |
-                        (0 << BIT_BTA_EN) |
-                        (0 << BIT_EOTP_RX_EN) |
-                        (0 << BIT_EOTP_TX_EN) );
-        // transfer mode setting: video/command mode
-        WRITE_LCD_REG( MIPI_DSI_DWC_MODE_CFG_OS, trans_mode );
-
-        // Phy Timer
-        // WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x036e0000);
-        // WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x03370000);
-        if ((output_type != TV_ENC_LCD240x160_dsi) &&
-                        (output_type != TV_ENC_LCD1920x1200p) &&
-                        (output_type != TV_ENC_LCD2560x1600) &&
-                        (output_type != TV_ENC_LCD768x1024p)) {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x03320000);
-        } else {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x090f0000);
-        }
-
-        // Configure DPHY Parameters
-        if ((output_type != TV_ENC_LCD240x160_dsi) &&
-                        (output_type != TV_ENC_LCD1920x1200p) &&
-                        (output_type != TV_ENC_LCD2560x1600) &&
-                        (output_type != TV_ENC_LCD768x1024p)) {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS, 0x870025);
-        } else {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS, 0x260017);
-        }
-
-
-}
-// ----------------------------------------------------------------------------
-//                     Function: set_mipi_dsi_host
-// Configure the mipi dsi host according the trans type
-// ----------------------------------------------------------------------------
-void set_mipi_dsi_host_to_video_mode(int lane_num,                                           // lane number, from 1 to 4
-                int vcid,                                               // virtual id
-                int venc_color_code,                                    // VENC output data width
-                int color_code,                                         // color code
-                int chroma_subsample,                                   // chroma_subsample for YUV422 or YUV420 only
-                int trans_mode,                                         // video mode/command mode
-                tv_enc_lcd_type_t output_type,                          // video type, such as 1080x720
-                int vid_mode_type,                                      // video mode : burst/non_burst
-                int check_phy_status,                                   // enable/disable phy lock check, disable for multiple pic test
-                Lcd_Config_t *p)
-
-{
-        int real_lane_num = lane_num+1;
-        int pic_width, pic_height;
-        int num_of_chunk;
-        int pixel_per_chunk = 4;
-        int byte_per_chunk;
-        int totol_bytes_per_chunk;
-        int chunk_overhead;
-        int vid_null_size;
-
-        pic_width  = p->lcd_basic.h_active;
-        pic_height = p->lcd_basic.v_active;
-        totol_bytes_per_chunk = real_lane_num*pixel_per_chunk*3/4;
-
-        // one lene has 8 bytes for 4 pixels
-        // according to DSI spec line50
-        switch(color_code) {
-                case COLOR_24_BIT_YCBCR :
-                case COLOR_24BIT        :
-                        byte_per_chunk = 18;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-                        // byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-                        break;
-                case COLOR_20BIT_LOOSE  :
-                case COLOR_18BIT_CFG_2  :
-                        byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-                        break;
-                case COLOR_16BIT_YCBCR :
-                case COLOR_16BIT_CFG_1 :
-                case COLOR_16BIT_CFG_2 :
-                case COLOR_16BIT_CFG_3 :
-                        byte_per_chunk =  8;                                             // at least 3 lanes(8+6=14): 3*8-14=10>6
-                        break;
-                case COLOR_30BIT :
-                        byte_per_chunk = 15;                                             // at least 4 lanes(15+6=21): 4*8-21=11>6
-                        break;
-                case COLOR_36BIT :
-                        byte_per_chunk = 18;                                             // at least 4 leans(18+6=24): 4*8-24=8>6
-                        break;
-                case COLOR_12BIT :
-                        byte_per_chunk =  6;                                             // at least 3 leans(6+6=12): 3*8-12=12>6
-                        break;
-                case COLOR_18BIT_CFG_1 :
-                        byte_per_chunk =  9;                                             // at least 23lanes(9+6=15): 3*8-15=9>6
-                        break;
-                case COLOR_RGB_111 :
-                case COLOR_RGB_332 :
-                case COLOR_RGB_444 :
-                        break;
-                default :
-                        DPRINT(" Error: Unsupport Color Format So Far, Please Add More\n");
-                        break;
-        }    /*switch(color_code)*/
-        num_of_chunk = pic_width/pixel_per_chunk;
-        chunk_overhead = totol_bytes_per_chunk-(byte_per_chunk+6);                 // byte_per_chunk+6=valid_payload
-
-        if(trans_mode == TRANS_VIDEO_MODE && vid_mode_type != BURST_MODE) {
-                if(chunk_overhead >= 6) {                                              // if room for null_vid's head(4)+crc(2)
-                        vid_null_size = chunk_overhead-6;                                  // chunk_overhead-null_vid's head(4)+crc(2) = null_vid's payload
-                } else {
-                        DPRINT(" No room for null, chunk_overhead is %d\n", chunk_overhead);
-                }
-        }
-        // -----------------------------------------------------
-        // Standard Configuration for Video Mode Transfer
-        // -----------------------------------------------------
-        // 1,    Configure Lane number and phy stop wait time
-        if ((output_type != TV_ENC_LCD240x160_dsi) &&
-                        (output_type != TV_ENC_LCD1920x1200p) &&
-                        (output_type != TV_ENC_LCD2560x1600) &&
-                        (output_type != TV_ENC_LCD768x1024p)) {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_IF_CFG_OS, (0x28 << BIT_PHY_STOP_WAIT_TIME) | (lane_num << BIT_N_LANES));
-        } else {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_IF_CFG_OS, (1 << BIT_PHY_STOP_WAIT_TIME) | (lane_num << BIT_N_LANES));
-        }
-
-        // 2.1,  Configure Virtual channel settings
-        WRITE_LCD_REG( MIPI_DSI_DWC_DPI_VCID_OS, vcid );
-        // 2.2,  Configure Color format
-        WRITE_LCD_REG( MIPI_DSI_DWC_DPI_COLOR_CODING_OS, ((color_code == COLOR_18BIT_CFG_2 ? 1 : 0) << BIT_LOOSELY18_EN) |
-                        (color_code << BIT_DPI_COLOR_CODING) );
-        // 2.2.1 Configure Set color format for DPI register
-        WRITE_LCD_REG( MIPI_DSI_TOP_CNTL, ((READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0xf<<BIT_DPI_COLOR_MODE) & ~(0x7<<BIT_IN_COLOR_MODE) & ~(0x3<<BIT_CHROMA_SUBSAMPLE)) |
-                                (color_code         << BIT_DPI_COLOR_MODE)  |
-                                (venc_color_code    << BIT_IN_COLOR_MODE)   |
-                                (chroma_subsample   << BIT_CHROMA_SUBSAMPLE)) );
-        // 2.3   Configure Signal polarity
-        WRITE_LCD_REG( MIPI_DSI_DWC_DPI_CFG_POL_OS, (0x0 << BIT_COLORM_ACTIVE_LOW) |
-                        (0x0 << BIT_SHUTD_ACTIVE_LOW)  |
-                        (0x0 << BIT_HSYNC_ACTIVE_LOW)  |
-                        (0x0 << BIT_VSYNC_ACTIVE_LOW)  |
-                        (0x0 << BIT_DATAEN_ACTIVE_LOW));
-
-        // 3.1   Configure Low power and video mode type settings
-        WRITE_LCD_REG( MIPI_DSI_DWC_VID_MODE_CFG_OS, (1 << BIT_LP_HFP_EN)  |                  // enalbe lp
-                        (1 << BIT_LP_HBP_EN)  |                  // enalbe lp
-                        (1 << BIT_LP_VCAT_EN) |                  // enalbe lp
-                        (1 << BIT_LP_VFP_EN)  |                  // enalbe lp
-                        (1 << BIT_LP_VBP_EN)  |                  // enalbe lp
-                        (1 << BIT_LP_VSA_EN)  |                  // enalbe lp
-                        (1 << BIT_FRAME_BTA_ACK_EN) |            // enable BTA after one frame, TODO, need check
-                        (vid_mode_type << BIT_VID_MODE_TYPE) );  // burst/non burst
-
-
-        // 3.2   Configure video packet size settings
-        if( vid_mode_type == BURST_MODE ) {                                        // burst mode
-                WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, pic_width);                          // should be one line in pixels, such as 480/240...
-        }
-        else if(vid_mode_type == NON_BURST_SYNC_PULSE ||
-                        vid_mode_type == NON_BURST_SYNC_EVENT) {                           // non-burst mode
-                WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, pixel_per_chunk);                    // in unit of pixels, (pclk period/byte clk period)*num_of_lane should be integer
-                // in our system, 16/8*num_of_lane is integer, so 6 pixel should be enough for 24bpp
-                // Worst case: (16/8)*8(pixel)*1(lane) >= 6(pkt head+crc)+3(max 24bpp)
-        }
-
-        // 3.3   Configure number of chunks and null packet size for one line
-        if( vid_mode_type == BURST_MODE ) {                                        // burst mode
-                WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, 0);
-                WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, 0);
-        }
-        else {                                                                     // non burst mode
-                WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, num_of_chunk);                     // HACT/VID_PKT_SIZE
-                WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, vid_null_size);                     // video null size
-                DPRINT(" ============== NON_BURST SETTINGS =============\n");
-                DPRINT(" pixel_per_chunk       = %d\n", pixel_per_chunk);
-                DPRINT(" num_of_chunk          = %d\n", num_of_chunk);
-                DPRINT(" totol_bytes_per_chunk = %d\n", totol_bytes_per_chunk);
-                DPRINT(" byte_per_chunk        = %d\n", byte_per_chunk);
-                DPRINT(" chunk_overhead        = %d\n", chunk_overhead);
-                DPRINT(" vid_null_size         = %d\n", vid_null_size);
-                DPRINT(" ===============================================\n");
-        }
-
-        // 4     Configure the video relative parameters according to the output type
-        //         include horizontal timing and vertical line
-        config_video_para(output_type, color_code, p);
-
-        // -----------------------------------------------------
-        // Finish Configuration
-        // -----------------------------------------------------
-
-
-        // Inner clock divider settings
-        WRITE_LCD_REG( MIPI_DSI_DWC_CLKMGR_CFG_OS, (0x1 << BIT_TO_CLK_DIV) |
-                        (0x1e << BIT_TX_ESC_CLK_DIV) );
-        // Packet header settings
-        WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
-                        (1 << BIT_ECC_RX_EN) |
-                        (0 << BIT_BTA_EN) |
-                        (0 << BIT_EOTP_RX_EN) |
-                        (0 << BIT_EOTP_TX_EN) );
-        // transfer mode setting: video/command mode
-        WRITE_LCD_REG( MIPI_DSI_DWC_MODE_CFG_OS, trans_mode );
-
-        // Phy Timer
-        if ((output_type != TV_ENC_LCD240x160_dsi) &&
-                        (output_type != TV_ENC_LCD1920x1200p) &&
-                        (output_type != TV_ENC_LCD2560x1600) &&
-                        (output_type != TV_ENC_LCD768x1024p)) {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x03320000);
-        } else {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x090f0000);
-        }
-
-        // Configure DPHY Parameters
-        if ((output_type != TV_ENC_LCD240x160_dsi) &&
-                        (output_type != TV_ENC_LCD1920x1200p) &&
-                        (output_type != TV_ENC_LCD2560x1600) &&
-                        (output_type != TV_ENC_LCD768x1024p)) {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS, 0x870025);
-        } else {
-                WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS, 0x260017);
-        }
-
-}
-
-void startup_transfer_cmd()
-{
-        // Startup transfer
-        WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_AUTOCLKLANE_CTRL) |
-                        (0x1 << BIT_TXREQUESTCLKHS));
-}
-void startup_transfer_video()
-{
-        WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_TXREQUESTCLKHS));
-}
-
-void print_info(int lane_num,                                           // lane number, from 1 to 4
-                int vcid,                                               // virtual id
-                int venc_color_code,                                    // VENC output data width
-                int color_code,                                         // color code
-                int chroma_subsample,                                   // chroma_subsample for YUV422 or YUV420 only
-                int trans_mode,                                         // video mode/command mode
-                tv_enc_lcd_type_t output_type,                          // video type, such as 1080x720
-                int vid_mode_type,                                      // video mode : burst/non_burst
-                int check_phy_status                                   // enable/disable phy lock check, disable for multiple pic test
-               )
-{
-        // Information display
-        DPRINT(" ================================================\n");
-        if(trans_mode == TRANS_COMMAND_MODE) {
-                DPRINT(" CONFIG FOR COMMAND MODE\n");
-        }
-        else if(trans_mode == TRANS_VIDEO_MODE) {
-                DPRINT(" CONFIG FOR VIDEO MODE\n");
-        }
-
-        if(vid_mode_type == NON_BURST_SYNC_PULSE) {
-                DPRINT(" VIDEO MODE TYPE is 'NON_BURST_SYNC_PULSE'\n");
-        }
-        else if(vid_mode_type == NON_BURST_SYNC_EVENT) {
-                DPRINT(" VIDEO MODE TYPE is 'NON_BURST_SYNC_EVENT'\n");
-        }
-        else if(vid_mode_type == BURST_MODE) {
-                DPRINT(" VIDEO MODE TYPE is 'BURST_MODE'\n");
-        }
-
-        switch(color_code) {
-                case COLOR_16BIT_CFG_1  :
-                        DPRINT(" COLOR CODING is 'COLOR_16BIT_CFG_1'\n");
-                        break;
-                case COLOR_16BIT_CFG_2  :
-                        DPRINT(" COLOR CODING is 'COLOR_16BIT_CFG_2'\n");
-                        break;
-                case COLOR_16BIT_CFG_3  :
-                        DPRINT(" COLOR CODING is 'COLOR_16BIT_CFG_3'\n");
-                        break;
-                case COLOR_18BIT_CFG_1  :
-                        DPRINT(" COLOR CODING is 'COLOR_18BIT_CFG_1'\n");
-                        break;
-                case COLOR_18BIT_CFG_2  :
-                        DPRINT(" COLOR CODING is 'COLOR_18BIT_CFG_2'\n");
-                        break;
-                case COLOR_24BIT        :
-                        DPRINT(" COLOR CODING is 'COLOR_24BIT'\n");
-                        break;
-                case COLOR_20BIT_LOOSE  :
-                        DPRINT(" COLOR CODING is 'COLOR_20BIT_LOOSE'\n");
-                        break;
-                case COLOR_24_BIT_YCBCR :
-                        DPRINT(" COLOR CODING is 'COLOR_24BIT_YCBCR'\n");
-                        break;
-                case COLOR_16BIT_YCBCR  :
-                        DPRINT(" COLOR CODING is 'COLOR_16BIT_YCBCR'\n");
-                        break;
-                case COLOR_30BIT        :
-                        DPRINT(" COLOR CODING is 'COLOR_30BIT'\n");
-                        break;
-                case COLOR_36BIT        :
-                        DPRINT(" COLOR CODING is 'COLOR_36BIT'\n");
-                        break;
-                case COLOR_12BIT        :
-                        DPRINT(" COLOR CODING is 'COLOR_12BIT'\n");
-                        break;
-                case COLOR_RGB_111      :
-                        DPRINT(" COLOR CODING is 'COLOR_RGB_111'\n");
-                        break;
-                case COLOR_RGB_332      :
-                        DPRINT(" COLOR CODING is 'COLOR_RGB332'\n");
-                        break;
-                case COLOR_RGB_444      :
-                        DPRINT(" COLOR CODING is 'COLOR_RGB444'\n");
-                        break;
-                default            :
-                        DPRINT(" Error: Unsupport Color Format, Please Check\n");
-                        break;
-        }
-        DPRINT(" POLARITY is HIGH ACTIVE\n");
-        DPRINT(" ENABLE CRC/ECC/BTA\n");
-        DPRINT(" ================================================\n");
-
-}
-
-// -----------------------------------------------------------------------------
-//                     Function: delay_us
-// Delay by N us.
-// -----------------------------------------------------------------------------
-inline void delay_us (int us)
-{
-        udelay(us);
-} /* delay_us */
-
-// -----------------------------------------------------------------------------
-//                     Function: config_video_para
-// -----------------------------------------------------------------------------
-void config_video_para(tv_enc_lcd_type_t output_type,
-                unsigned int      color_code,
-                Lcd_Config_t *pConf)
-{
-
-        DSI_Config_t    *cfg= pConf->lcd_control.mipi_config;
-
-        DPRINT(" ============= VIDEO TIMING SETTING =============\n");
-        DPRINT(" HLINE        = %d\n", cfg->hline);
-        DPRINT(" HSA          = %d\n", cfg->hsa);
-        DPRINT(" HBP          = %d\n", cfg->hbp);
-        DPRINT(" VBP          = %d\n", cfg->vbp);
-        DPRINT(" VFP          = %d\n", cfg->vfp);
-        DPRINT(" VACT         = %d\n", cfg->vact);
-        DPRINT(" ================================================\n");
-        WRITE_LCD_REG( MIPI_DSI_DWC_VID_HLINE_TIME_OS,    cfg->hline);
-        WRITE_LCD_REG( MIPI_DSI_DWC_VID_HSA_TIME_OS,      cfg->hsa);
-        WRITE_LCD_REG( MIPI_DSI_DWC_VID_HBP_TIME_OS,      cfg->hbp);
-        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VSA_LINES_OS,     cfg->vsa);
-        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VBP_LINES_OS,     cfg->vbp);
-        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VFP_LINES_OS,     cfg->vfp);
-        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VACTIVE_LINES_OS, cfg->vact);
-
+    WRITE_LCD_REG( MIPI_DSI_DWC_INT_MSK0_OS, 0);
+    WRITE_LCD_REG( MIPI_DSI_DWC_INT_MSK1_OS, 0);
 }
 
 // ----------------------------------------------------------------------------
 // Function: wait_bta_ack
 // Poll to check if the BTA ack is finished
 // ----------------------------------------------------------------------------
-extern void wait_bta_ack()
+static void wait_bta_ack(void)
 {
-        unsigned int phy_status;
+    unsigned int phy_status;
 
-        // Check if phydirection is RX
-        do{
-                phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
-        } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x0);
-
-        // Check if phydirection is return to TX
-        do{
-                phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
-        } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x1);
+    // Check if phydirection is RX
+    do {
+        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+    } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x0);
 
+    // Check if phydirection is return to TX
+    do {
+        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+    } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x1);
 }
 
 // ----------------------------------------------------------------------------
 // Function: wait_cmd_fifo_empty
 // Poll to check if the generic command fifo is empty
 // ----------------------------------------------------------------------------
-extern void wait_cmd_fifo_empty(void)
+static void wait_cmd_fifo_empty(void)
 {
-        unsigned int cmd_status;
-				unsigned int i= 10000;
-        do {
-        				i--;
-        				udelay(10);
-                cmd_status = READ_LCD_REG( MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
-        } while((((cmd_status >> BIT_GEN_CMD_EMPTY) & 0x1) != 0x1)&&i!=0);
+    unsigned int cmd_status;
+    int i= RETRY_CNT;
+
+    do {
+        i--;
+        print_mipi_cmd_status(i);
+        cmd_status = READ_LCD_REG(MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
+    } while((((cmd_status >> BIT_GEN_CMD_EMPTY) & 0x1) != 0x1) && (i!=0));
 }
 
 // ----------------------------------------------------------------------------
 // Function: wait_for_generic_read_response
 // Wait for generic read response
 // ----------------------------------------------------------------------------
-extern unsigned int wait_for_generic_read_response()
+static unsigned int wait_for_generic_read_response(void)
 {
-        unsigned int timeout, phy_status, data_out;
+    unsigned int timeout, phy_status, data_out;
 
+    phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+    for(timeout=0; timeout<50; timeout++) {
+        if(((phy_status & 0x40)>> BIT_PHY_RXULPSESC0LANE) == 0x0)
+            break;
         phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
-        for(timeout=0; timeout<50; timeout++) {
-                if(((phy_status & 0x40)>> BIT_PHY_RXULPSESC0LANE) == 0x0)    { break; }
-                phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
-                delay_us(1);
-        }
+        udelay(1);
+    }
+    phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+    for(timeout=0; timeout<50; timeout++) {
+        if(((phy_status & 0x40)>> BIT_PHY_RXULPSESC0LANE) == 0x1)
+            break;
         phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
-        for(timeout=0; timeout<50; timeout++) {
-                if(((phy_status & 0x40)>> BIT_PHY_RXULPSESC0LANE) == 0x1)    { break; }
-                phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
-                delay_us(1);
-        }
+        udelay(1);
+    }
 
-        data_out = READ_LCD_REG( MIPI_DSI_DWC_GEN_PLD_DATA_OS );
-        return data_out;
+    data_out = READ_LCD_REG( MIPI_DSI_DWC_GEN_PLD_DATA_OS );
+    return data_out;
 }
 
 // ----------------------------------------------------------------------------
@@ -702,33 +239,33 @@ extern unsigned int wait_for_generic_read_response()
 // Generic interface write, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS and
 // MIPI_DSI_DWC_GEN_HDR_OS, MIPI_DSI_DWC_GEN_VCID_OS
 // ----------------------------------------------------------------------------
-extern unsigned int generic_if_wr(unsigned int address, unsigned int data_in)
+static unsigned int generic_if_wr(unsigned int address, unsigned int data_in)
 {
-        if(address != MIPI_DSI_DWC_GEN_HDR_OS && address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
-                DPRINT(" Error Address : %h\n", address);
-        }
+    if(address != MIPI_DSI_DWC_GEN_HDR_OS && address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
+        DPRINT(" Error Address : 0x%x\n", address);
+    }
 
-        DPRINT("MIPI_DSI_UTIL.C address is %x, data_in is %x\n", address, data_in);
-        WRITE_LCD_REG(address, data_in);
+    DPRINT("address 0x%x = 0x%08x\n", address, data_in);
+    WRITE_LCD_REG(address, data_in);
 
-        return 1;
+    return 0;
 }
 
 // ----------------------------------------------------------------------------
 //                           Function: generic_if_rd
 // Generic interface read, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS
 // ----------------------------------------------------------------------------
-extern unsigned int generic_if_rd(unsigned int address)
+static unsigned int generic_if_rd(unsigned int address)
 {
-        unsigned int data_out;
+    unsigned int data_out;
 
-        if(address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
-                DPRINT(" Error Address : %h\n", address);
-        }
+    if(address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
+        DPRINT(" Error Address : %x\n", address);
+    }
 
-        data_out = READ_DSI_REG( address );
+    data_out = READ_DSI_REG(address);
 
-        return data_out;
+    return data_out;
 }
 
 // ----------------------------------------------------------------------------
@@ -738,21 +275,21 @@ extern unsigned int generic_if_rd(unsigned int address)
 //                        DCS_EXIT_SLEEP_MODE/DCS_SET_DISPLAY_OFF/DCS_SET_DISPLAY_ON
 //                        DCS_SET_TEAR_OFF/DCS_SOFT_RESET/DCS_NOP
 // ----------------------------------------------------------------------------
-extern void DCS_write_short_packet_0_para(unsigned int data_type,
-                unsigned int vc_id,
-                unsigned int dcs_command,
-                unsigned int req_ack)
-{
-        generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((0x0 << BIT_GEN_WC_MSBYTE) |
-                                (dcs_command << BIT_GEN_WC_LSBYTE) |
-                                (vc_id << BIT_GEN_VC)              |
-                                (data_type << BIT_GEN_DT)));
-        if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
-                wait_bta_ack();
-        }
-        else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
-                wait_cmd_fifo_empty();
-        }
+static void DCS_write_short_packet_0_para(unsigned int data_type,
+                                          unsigned int vc_id,
+                                          unsigned int dcs_command,
+                                          unsigned int req_ack)
+{
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((0x0 << BIT_GEN_WC_MSBYTE) |
+                            (dcs_command << BIT_GEN_WC_LSBYTE) |
+                            (vc_id << BIT_GEN_VC)              |
+                            (data_type << BIT_GEN_DT)));
+    if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+        wait_bta_ack();
+    }
+    else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
+        wait_cmd_fifo_empty();
+    }
 }
 
 // ----------------------------------------------------------------------------
@@ -761,24 +298,24 @@ extern void DCS_write_short_packet_0_para(unsigned int data_type,
 // Supported DCS Command: DCS_SET_ADDRESS_MODE/DCS_SET_GAMMA_CURVE/
 //                        DCS_SET_PIXEL_FORMAT/DCS_SET_TEAR_ON
 // ----------------------------------------------------------------------------
-extern void DCS_write_short_packet_1_para(unsigned int data_type,
-                unsigned int vc_id,
-                unsigned int dcs_command,
-                unsigned int para,
-                unsigned int req_ack)
-{
-        // DPRINT(" para is %x, dcs_command is %x\n", para, dcs_command);
-        // DPRINT(" vc_id %x, data_type is %x\n", vc_id, data_type);
-        generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((para << BIT_GEN_WC_MSBYTE)        |
-                                (dcs_command << BIT_GEN_WC_LSBYTE) |
-                                (vc_id << BIT_GEN_VC)              |
-                                (data_type << BIT_GEN_DT)));
-        if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
-                wait_bta_ack();
-        }
-        else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
-                wait_cmd_fifo_empty();
-        }
+static void DCS_write_short_packet_1_para(unsigned int data_type,
+                                          unsigned int vc_id,
+                                          unsigned int dcs_command,
+                                          unsigned int para,
+                                          unsigned int req_ack)
+{
+    // DPRINT(" para is %x, dcs_command is %x\n", para, dcs_command);
+    // DPRINT(" vc_id %x, data_type is %x\n", vc_id, data_type);
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((para << BIT_GEN_WC_MSBYTE)        |
+                            (dcs_command << BIT_GEN_WC_LSBYTE) |
+                            (vc_id << BIT_GEN_VC)              |
+                            (data_type << BIT_GEN_DT)));
+    if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+        wait_bta_ack();
+    }
+    else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
+        wait_cmd_fifo_empty();
+    }
 }
 
 // ----------------------------------------------------------------------------
@@ -787,22 +324,22 @@ extern void DCS_write_short_packet_1_para(unsigned int data_type,
 // Supported DCS Command: DCS_SET_ADDRESS_MODE/DCS_SET_GAMMA_CURVE/
 //                        DCS_SET_PIXEL_FORMAT/DCS_SET_TEAR_ON
 // ----------------------------------------------------------------------------
-extern unsigned int DCS_read_packet_no_para(unsigned int data_type,
-                unsigned int vc_id,
-                unsigned int dcs_command)
+static unsigned int DCS_read_packet_no_para(unsigned int data_type,
+                                            unsigned int vc_id,
+                                            unsigned int dcs_command)
 {
-        unsigned read_data;
+    unsigned read_data;
 
-        // DPRINT(" para is %x, dcs_command is %x\n", para, dcs_command);
-        // DPRINT(" vc_id %x, data_type is %x\n", vc_id, data_type);
-        generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((0x0 << BIT_GEN_WC_MSBYTE)         |
-                                (dcs_command << BIT_GEN_WC_LSBYTE) |
-                                (vc_id << BIT_GEN_VC)              |
-                                (data_type << BIT_GEN_DT)));
+    // DPRINT(" para is %x, dcs_command is %x\n", para, dcs_command);
+    // DPRINT(" vc_id %x, data_type is %x\n", vc_id, data_type);
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((0x0 << BIT_GEN_WC_MSBYTE)         |
+                            (dcs_command << BIT_GEN_WC_LSBYTE) |
+                            (vc_id << BIT_GEN_VC)              |
+                            (data_type << BIT_GEN_DT)));
 
-        read_data = wait_for_generic_read_response();
+    read_data = wait_for_generic_read_response();
 
-        return read_data;
+    return read_data;
 }
 
 // ----------------------------------------------------------------------------
@@ -811,628 +348,674 @@ extern unsigned int DCS_read_packet_no_para(unsigned int data_type,
 // Supported DCS Command: DCS_SET_COLUMN_ADDRESS/DCS_SET_PAGE_ADDRESS
 //                        DCS_WRITE_MEMORY_START/DCS_WRITE_MEMORY_CONTINUE
 // ----------------------------------------------------------------------------
-extern void DCS_long_write_packet(unsigned int data_type,                      // DSI data type, such as DCS Long Write Packet
-                unsigned int vc_id,                          // Virtual Channel ID
-                unsigned int dcs_command,                    // DCS Command, such as set_column_address/set_page_address
-                unsigned char* payload,                      // Payload(including dcs_cmd+payload)
-                unsigned int pld_size,                       // Payload size, from LSB to MSB, include dcs_cmd+payload
-                unsigned int req_ack                         // if need check ack for bta
-                )
-{
-        unsigned int payload_data, header_data;
-        unsigned int cmd_status;
-        unsigned int i;
-
-        // Write Payload Register First
-        for(i=0; i<pld_size; i++) {
-                if(i%4 == 0)    { payload_data = 0; }
-                payload_data = payload_data | (payload[i] << 8*(i%4));
-
-                if(i%4 == 3 || i == pld_size-1) {                                      // when last byte
-                        // Check the pld fifo status before write to it, do not need check every word
-                        if(i == pld_size/3 || i == pld_size/2) {
-                                do {
-                                        cmd_status = READ_LCD_REG( MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
-                                } while(((cmd_status >> BIT_GEN_PLD_W_FULL) & 0x1) == 0x1);
-                        }
-                        if(dcs_command == DCS_WRITE_MEMORY_CONTINUE) {
-                                WRITE_LCD_REG( MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);               // Use direct memory write to save time when in WRITE_MEMORY_CONTINUE
-                                // (*(MIPI_DSI_DWC_GEN_PLD_DATA_OS|0xc1100000)) = payload_data;
-                                // *(volatile unsigned long *)((0xc1100000)|((MIPI_DSI_DWC_GEN_PLD_DATA_OS)<<2))=payload_data;
-                        }
-                        else {
-                                generic_if_wr(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
-                        }
-                }
-        }
+static void DCS_long_write_packet(unsigned int data_type,    // DSI data type, such as DCS Long Write Packet
+                                  unsigned int vc_id,        // Virtual Channel ID
+                                  unsigned int dcs_command,  // DCS Command, such as set_column_address/set_page_address
+                                  unsigned char* payload,    // Payload(including dcs_cmd+payload)
+                                  unsigned int pld_size,     // Payload size, from LSB to MSB, include dcs_cmd+payload
+                                  unsigned int req_ack)      // if need check ack for bta
+{
+    unsigned int payload_data=0, header_data;
+    unsigned int cmd_status;
+    unsigned int i;
+    int j;
+
+    // Write Payload Register First
+    for(i=0; i<pld_size; i++) {
+        if(i%4 == 0)    { payload_data = 0; }
+        payload_data = payload_data | (payload[i] << 8*(i%4));
+
+        if(i%4 == 3 || i == pld_size-1) {                                      // when last byte
+            // Check the pld fifo status before write to it, do not need check every word
+            if(i == pld_size/3 || i == pld_size/2) {
+                j = RETRY_CNT;
+                do {
+                    j--;
+                    print_mipi_cmd_status(j);
+                    cmd_status = READ_LCD_REG( MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
+                } while((((cmd_status >> BIT_GEN_PLD_W_FULL) & 0x1) == 0x1) && (j>0));
+            }
+            if(dcs_command == DCS_WRITE_MEMORY_CONTINUE) {
+                WRITE_LCD_REG( MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);               // Use direct memory write to save time when in WRITE_MEMORY_CONTINUE
+                // (*(MIPI_DSI_DWC_GEN_PLD_DATA_OS|0xc1100000)) = payload_data;
+                // *(volatile unsigned long *)((0xc1100000)|((MIPI_DSI_DWC_GEN_PLD_DATA_OS)<<2))=payload_data;
+            }
+            else {
+                generic_if_wr(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
+            }
+        }
+    }
+
+    // Check cmd fifo status before write to it
+    j = RETRY_CNT;
+    do {
+        j--;
+        print_mipi_cmd_status(j);
+        cmd_status = READ_LCD_REG( MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
+    } while((((cmd_status >> BIT_GEN_CMD_FULL) & 0x1) == 0x1) && (j>0));
+    // Write Header Register
+    header_data = (((((pld_size) & 0xff00) >> 8) << BIT_GEN_WC_MSBYTE) |
+                    (((pld_size) & 0x00ff) << BIT_GEN_WC_LSBYTE)        |
+                    (vc_id << BIT_GEN_VC)                               |
+                    (data_type << BIT_GEN_DT));
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, header_data);
+
+    // Check BTA ACK
+    if (req_ack == MIPI_DSI_DCS_REQ_ACK) {
+        wait_bta_ack();
+    }
+    else if (req_ack == MIPI_DSI_DCS_NO_ACK) {
+        wait_cmd_fifo_empty();
+    }
+}
 
-        // Check cmd fifo status before write to it
-        do {
-                cmd_status = READ_LCD_REG( MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
-        } while(((cmd_status >> BIT_GEN_CMD_FULL) & 0x1) == 0x1);
-        // Write Header Register
-        header_data = (((((pld_size) & 0xff00) >> 8) << BIT_GEN_WC_MSBYTE) |
-                        (((pld_size) & 0x00ff) << BIT_GEN_WC_LSBYTE)        |
-                        (vc_id << BIT_GEN_VC)                               |
-                        (data_type << BIT_GEN_DT));
-        generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, header_data);
-
-        // Check BTA ACK
-        if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
-                wait_bta_ack();
-        }
-        else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
-                wait_cmd_fifo_empty();
-        }
+static void dsi_phy_init(unsigned char lane_num)
+{
+    // enable phy clock.
+    WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1);          //enable DSI top clock.
+    WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1 |          //enable the DSI PLL clock .
+                    (1 << 7 )  |   //enable pll clock which connected to  DDR clock path
+                    (1 << 8 )  |   //enable the clock divider counter
+                    (0 << 9 )  |   //enable the divider clock out
+                    (0 << 10 ) |   //clock divider. 1: freq/4, 0: freq/2
+                    (0 << 11 ) |   //1: select the mipi DDRCLKHS from clock divider, 0: from PLL clock
+                    (0 << 12));    //enable the byte clock generateion.
+
+    WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1 |          //enable DSI top clock.
+                    (1 << 7 )  |   //enable pll clock which connected to  DDR clock path
+                    (1 << 8 )  |   //enable the clock divider counter
+                    (1 << 9 )  |   //enable the divider clock out
+                    (0 << 10 ) |   //clock divider. 1: freq/4, 0: freq/2
+                    (0 << 11 ) |   //1: select the mipi DDRCLKHS from clock divider, 0: from PLL clock
+                    (0 << 12));    //enable the byte clock generateion.
+
+    WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1 |          //enable DSI top clock.
+                    (1 << 7 )  |   //enable pll clock which connected to  DDR clock path
+                    (1 << 8 )  |   //enable the clock divider counter
+                    (1 << 9 )  |   //enable the divider clock out
+                    (0 << 10 ) |   //clock divider. 1: freq/4, 0: freq/2
+                    (0 << 11 ) |   //1: select the mipi DDRCLKHS from clock divider, 0: from PLL clock
+                    (1 << 12));    //enable the byte clock generateion.
+
+    WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL,  1, 31, 1);
+    WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL,  0, 31, 1);
+
+    WRITE_DSI_REG(MIPI_DSI_CLK_TIM,  0x05210f08);//0x03211c08
+    WRITE_DSI_REG(MIPI_DSI_CLK_TIM1, 0x8);//??
+    WRITE_DSI_REG(MIPI_DSI_HS_TIM, 0x060f090d);//0x050f090d
+    WRITE_DSI_REG(MIPI_DSI_LP_TIM, 0x4a370e0e);
+    WRITE_DSI_REG(MIPI_DSI_ANA_UP_TIM, 0x0100); //?? //some number to reduce sim time.
+    WRITE_DSI_REG(MIPI_DSI_INIT_TIM, 0x00d4); //0xe20   //30d4 -> d4 to reduce sim time.
+    WRITE_DSI_REG(MIPI_DSI_WAKEUP_TIM, 0x48); //0x8d40  //1E848-> 48 to reduct sim time.
+    WRITE_DSI_REG(MIPI_DSI_LPOK_TIM,  0x7C);   //wait for the LP analog ready.
+    WRITE_DSI_REG(MIPI_DSI_ULPS_CHECK,  0x927C);   //1/3 of the tWAKEUP.
+    WRITE_DSI_REG(MIPI_DSI_LP_WCHDOG,  0x1000);   // phy TURN watch dog.
+    WRITE_DSI_REG(MIPI_DSI_TURN_WCHDOG,  0x1000);   // phy ESC command watch dog.
+
+    // Powerup the analog circuit.
+    switch (lane_num) {
+        case 1:
+            WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0x0e);
+            break;
+        case 2:
+            WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0x0c);
+            break;
+        case 3:
+            WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0x08);
+            break;
+        case 4:
+        default:
+            WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0);
+            break;
+    }
 }
 
-#if 0
-void set_pll_mipi(Lcd_Config_t *p)
+static void dsi_phy_config(Lcd_Config_t *pConf)
 {
-        int pll_lock;
-        int wait_loop = 100;
-
-        Lcd_Control_Config_t *pConf = &p->lcd_control;
-
-        pConf->mipi_config->venc_color_type = 2;
-        pConf->mipi_config->dpi_color_type  = 4;
+    DPRINT("%s\n", __func__);
+    //Digital
+    // Power up DSI
+    WRITE_LCD_REG(MIPI_DSI_DWC_PWR_UP_OS, 1);
 
-        pConf->mipi_config->trans_mode = 1;
-        pConf->mipi_config->venc_fmt = TV_ENC_LCD768x1024p;
-        pConf->mipi_config->lane_num = 3;
-        pConf->mipi_config->dpi_chroma_subsamp = 0;
+    // Setup Parameters of DPHY
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL1_OS, 0x00010044);                            // testcode
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x2);
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x0);
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL1_OS, 0x00000074);                            // testwrite
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x2);
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x0);
 
+    // Power up D-PHY
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_RSTZ_OS, 0xf);
 
-	// Configure VS/HS/DE polarity before mipi_dsi_host.pixclk starts,
-	WRITE_LCD_REG(MIPI_DSI_TOP_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0x7<<4))   |
-                          (1  << 4)               |
-                          (1  << 5)               |
-                          (0  << 6));
+    //Analog
+    dsi_phy_init(pConf->lcd_control.mipi_config->lane_num);
 
-         WRITE_CBUS_REG(HHI_VID_PLL_CNTL5,  0x00012286);
-         WRITE_CBUS_REG(HHI_VID2_PLL_CNTL2, 0x0431aa1e);
-         WRITE_CBUS_REG(HHI_VID2_PLL_CNTL3, 0xca45b023);
-         WRITE_CBUS_REG(HHI_VID2_PLL_CNTL4, 0xd4000d67);
-
-         WRITE_CBUS_REG(HHI_VID2_PLL_CNTL5, 0x00700111);
-         WRITE_CBUS_REG(HHI_VID2_PLL_CNTL,  0x61000230);
-         WRITE_CBUS_REG(HHI_VID2_PLL_CNTL,  0x41000230);
+    // Check the phylock/stopstateclklane to decide if the DPHY is ready
+    check_phy_status();
 
-	do{
-		udelay(100);
-		pll_lock = (READ_CBUS_REG(HHI_VID2_PLL_CNTL) >> 31) & 0x1;
-		if (wait_loop < 20){
-			DPRINT("vid2_pll_locked=%u, wait_lock_loop=%d\n", pll_lock, (100 - wait_loop + 1));
-                }
-		wait_loop--;
-	}while((pll_lock == 0) && (wait_loop > 0));
-
-        WRITE_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL1, READ_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL1) & ~(1<<4)); //0x10d2
-        //WRITE_CBUS_REG(HHI_VID_DIVIDER_CNTL, 0x0001d923); //0x1066
-        WRITE_CBUS_REG(HHI_VIID_DIVIDER_CNTL, 0x0001d923); //0x104c
-        WRITE_CBUS_REG( HHI_VID2_PLL_CNTL5, READ_CBUS_REG(HHI_VID2_PLL_CNTL5)  | //0x10e4
-                         (1 << 23)               |   // Enable MIPI DSI PHY clock
-                         (1 << 24));                 // Enable LVDS clock for ENCL pixel clock
-
-        //WRITE_CBUS_REG( HHI_VID_CLK_CNTL, READ_CBUS_REG(HHI_VID_CLK_CNTL) |  (1 << 19) | (1 << 0));   //enable clk_div0, 0x105f
-        //WRITE_CBUS_REG( HHI_VID_CLK_CNTL, READ_CBUS_REG(HHI_VID_CLK_CNTL) |  (1 << 20) | (1 << 0));   //enable clk_div1, 0x105f
-
-        WRITE_CBUS_REG_BITS( HHI_VIID_CLK_CNTL, 4, 16, 3);//enable vid pll input, 0x104b
-	WRITE_CBUS_REG_BITS( HHI_VIID_CLK_CNTL, 1, 19, 1);	//vclk2_en0
-        //WRITE_CBUS_REG_BITS( HHI_VID_CLK_DIV,   0, 0, 8 ); //0x1059
-        //WRITE_CBUS_REG_BITS( HHI_VID_CLK_CNTL, 1, 0, 1);   //0x105f
-        //
-        WRITE_CBUS_REG_BITS( HHI_VIID_CLK_DIV, 0, 0, 4);//0x104a[0:4], N=0, bypass
-        WRITE_CBUS_REG_BITS( HHI_VIID_CLK_CNTL, 1, 0, 1);// 0x104b[0]=1 v2 clk div en
-        WRITE_CBUS_REG_BITS( HHI_VIID_CLK_DIV, 1, 19, 1);//0x104a[19], enable
-
-	WRITE_CBUS_REG_BITS( HHI_VIID_CLK_CNTL, 1, 15, 1);	//vclk2 reset
-	WRITE_CBUS_REG_BITS( HHI_VIID_CLK_CNTL, 0, 15, 1);	//vclk2 reset
-
-        WRITE_CBUS_REG_BITS( HHI_VIID_CLK_DIV,  8, 12, 4);//0x104a[12:15] v2_clk_div1
-        DPRINT("%s, %d\n", __func__, __LINE__);
-
-        //DPRINT("pll output stably, vid2 pll clk = %d", clk_util_clk_msr(6));
-        //DPRINT("pll output stably, cts_encl_clk = %d", clk_util_clk_msr(9));
-
-        //startup_mipi_dsi_host()
-        WRITE_CBUS_REG( HHI_DSI_LVDS_EDP_CNTL0, 0x0);                                          // Select DSI as the output for u_dsi_lvds_edp_top
-        WRITE_LCD_REG( MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) | 0xf) );     // Release mipi_dsi_host's reset
-        WRITE_LCD_REG( MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) & 0xfffffff0) );     // Release mipi_dsi_host's reset
-        WRITE_LCD_REG( MIPI_DSI_TOP_CLK_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CLK_CNTL) | 0x3) );            // Enable dwc mipi_dsi_host's clock
+    // Trigger a sync active for esc_clk
+    WRITE_DSI_REG(MIPI_DSI_PHY_CTRL, READ_DSI_REG(MIPI_DSI_PHY_CTRL) | (1 << 1));
+}
 
+static void dsi_video_config(Lcd_Config_t *pConf)
+{
+    DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
+
+    DPRINT(" ============= VIDEO TIMING SETTING =============\n");
+    DPRINT(" HLINE        = %d\n", cfg->hline);
+    DPRINT(" HSA          = %d\n", cfg->hsa);
+    DPRINT(" HBP          = %d\n", cfg->hbp);
+    DPRINT(" VSA          = %d\n", cfg->vsa);
+    DPRINT(" VBP          = %d\n", cfg->vbp);
+    DPRINT(" VFP          = %d\n", cfg->vfp);
+    DPRINT(" VACT         = %d\n", cfg->vact);
+    DPRINT(" ================================================\n");
+
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HLINE_TIME_OS,    cfg->hline);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HSA_TIME_OS,      cfg->hsa);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HBP_TIME_OS,      cfg->hbp);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VSA_LINES_OS,     cfg->vsa);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VBP_LINES_OS,     cfg->vbp);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VFP_LINES_OS,     cfg->vfp);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VACTIVE_LINES_OS, cfg->vact);
 }
-#endif
 
-void set_venc_mipi(Lcd_Config_t *pConf)
+static void startup_transfer_cmd(void)
 {
-        DPRINT("%s\n",__FUNCTION__);
-
-        WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
-#ifdef CONFIG_AM_TV_OUTPUT2
-        if	(vpp2_sel) {
-                WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2, 2);	//viu2 select encl
-                WRITE_LCD_REG(VPU_VIU_VENC_MUX_CTRL, (READ_LCD_REG(VPU_VIU_VENC_MUX_CTRL)&(~(0x3<<2)))|(0x0<<2)); //viu2 select encl
-        }
-        else {
-                WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0x88, 4, 8);//Select encl clock to VDIN, Enable VIU of ENC_l domain to VDIN
-                WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);//viu1 select encl
-        }
-#else
-        WRITE_LCD_REG(VPU_VIU_VENC_MUX_CTRL, (0<<0) | (0<<2));	// viu1 & viu2 select encl
-#endif
-
-        WRITE_LCD_REG(ENCL_VIDEO_MODE,		0);
-        WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV,	0x0008);	// Sampling rate: 1
+    // Startup transfer
+    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_AUTOCLKLANE_CTRL) | (0x1 << BIT_TXREQUESTCLKHS));
+}
+static void startup_transfer_video(void)
+{
+    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_TXREQUESTCLKHS));
+}
 
-        WRITE_LCD_REG(ENCL_VIDEO_FILT_CTRL,	0x1000);	// bypass filter
+static void set_mipi_dsi_host(int lane_num,                      // lane number, from 1 to 4
+                              int vcid,                          // virtual id
+                              int venc_data_width,               // VENC output data width
+                              int dpi_data_format,               // dpi data format
+                              int chroma_subsample,              // chroma_subsample for YUV422 or YUV420 only
+                              int operation_mode,                // video mode/command mode
+                              tv_enc_lcd_type_t output_type,     // video type, such as 1080x720
+                              int vid_mode_type,                 // video mode : burst/non_burst
+                              int check_phy_status,              // enable/disable phy lock check, disable for multiple pic test
+                              Lcd_Config_t *p)
+{
+    int real_lane_num = lane_num+1;
+    int num_of_chunk;
+    int pixel_per_chunk = 4;
+    int byte_per_chunk=0;
+    int totol_bytes_per_chunk;
+    int chunk_overhead;
+    int vid_null_size=0;
+
+    totol_bytes_per_chunk = real_lane_num*pixel_per_chunk*3/4;
+
+    // one lene has 8 bytes for 4 pixels
+    // according to DSI spec line50
+    switch(dpi_data_format) {
+        case COLOR_24_BIT_YCBCR :
+        case COLOR_24BIT        :
+            byte_per_chunk = 18;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
+            // byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
+            break;
+        case COLOR_20BIT_LOOSE  :
+        case COLOR_18BIT_CFG_2  :
+            byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
+            break;
+        case COLOR_16BIT_YCBCR :
+        case COLOR_16BIT_CFG_1 :
+        case COLOR_16BIT_CFG_2 :
+        case COLOR_16BIT_CFG_3 :
+            byte_per_chunk =  8;                                             // at least 3 lanes(8+6=14): 3*8-14=10>6
+            break;
+        case COLOR_30BIT :
+            byte_per_chunk = 15;                                             // at least 4 lanes(15+6=21): 4*8-21=11>6
+            break;
+        case COLOR_36BIT :
+            byte_per_chunk = 18;                                             // at least 4 leans(18+6=24): 4*8-24=8>6
+            break;
+        case COLOR_12BIT :
+            byte_per_chunk =  6;                                             // at least 3 leans(6+6=12): 3*8-12=12>6
+            break;
+        case COLOR_18BIT_CFG_1 :
+            byte_per_chunk =  9;                                             // at least 23lanes(9+6=15): 3*8-15=9>6
+            break;
+        case COLOR_RGB_111 :
+        case COLOR_RGB_332 :
+        case COLOR_RGB_444 :
+            break;
+        default :
+            DPRINT(" Error: un-support data Format So Far, Please Add More\n");
+            break;
+    }    /*switch(dpi_data_format)*/
+    num_of_chunk = p->lcd_basic.h_active / pixel_per_chunk;
+    chunk_overhead = totol_bytes_per_chunk-(byte_per_chunk+6);                 // byte_per_chunk+6=valid_payload
+
+    if(operation_mode == OPERATION_VIDEO_MODE && vid_mode_type != BURST_MODE) {
+        if(chunk_overhead >= 6) {                                              // if room for null_vid's head(4)+crc(2)
+            vid_null_size = chunk_overhead-6;                                  // chunk_overhead-null_vid's head(4)+crc(2) = null_vid's payload
+        } else {
+            DPRINT(" No room for null, chunk_overhead is %d\n", chunk_overhead);
+        }
+    }
+    // -----------------------------------------------------
+    // Standard Configuration for Video Mode Operation
+    // -----------------------------------------------------
+    // 1,    Configure Lane number and phy stop wait time
+    if ((output_type != TV_ENC_LCD240x160_dsi) && (output_type != TV_ENC_LCD1920x1200p) &&
+        (output_type != TV_ENC_LCD2560x1600) && (output_type != TV_ENC_LCD768x1024p)) {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_IF_CFG_OS, (0x28 << BIT_PHY_STOP_WAIT_TIME) | (lane_num << BIT_N_LANES));
+    } else {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_IF_CFG_OS, (1 << BIT_PHY_STOP_WAIT_TIME) | (lane_num << BIT_N_LANES));
+    }
+
+    // 2.1,  Configure Virtual channel settings
+    WRITE_LCD_REG( MIPI_DSI_DWC_DPI_VCID_OS, vcid );
+    // 2.2,  Configure Color format
+    WRITE_LCD_REG( MIPI_DSI_DWC_DPI_COLOR_CODING_OS, (((dpi_data_format == COLOR_18BIT_CFG_2) ? 1 : 0) << BIT_LOOSELY18_EN) | (dpi_data_format << BIT_DPI_COLOR_CODING) );
+    // 2.2.1 Configure Set color format for DPI register
+    WRITE_LCD_REG( MIPI_DSI_TOP_CNTL, ((READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0xf<<BIT_DPI_COLOR_MODE) & ~(0x7<<BIT_IN_COLOR_MODE) & ~(0x3<<BIT_CHROMA_SUBSAMPLE)) |
+                                (dpi_data_format    << BIT_DPI_COLOR_MODE)  |
+                                (venc_data_width    << BIT_IN_COLOR_MODE)   |
+                                (chroma_subsample   << BIT_CHROMA_SUBSAMPLE)) );
+    // 2.3   Configure Signal polarity
+    WRITE_LCD_REG( MIPI_DSI_DWC_DPI_CFG_POL_OS, (0x0 << BIT_COLORM_ACTIVE_LOW) |
+                        (0x0 << BIT_SHUTD_ACTIVE_LOW)  |
+                        (0x0 << BIT_HSYNC_ACTIVE_LOW)  |
+                        (0x0 << BIT_VSYNC_ACTIVE_LOW)  |
+                        (0x0 << BIT_DATAEN_ACTIVE_LOW));
 
-        WRITE_LCD_REG(ENCL_VIDEO_MAX_PXCNT,	pConf->lcd_basic.h_period - 1);
-        WRITE_LCD_REG(ENCL_VIDEO_MAX_LNCNT,	pConf->lcd_basic.v_period - 1);
+    if (operation_mode == OPERATION_VIDEO_MODE) {
+        // 3.1   Configure Low power and video mode type settings
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_MODE_CFG_OS, (1 << BIT_LP_HFP_EN)  |                  // enalbe lp
+                        (1 << BIT_LP_HBP_EN)  |                  // enalbe lp
+                        (1 << BIT_LP_VCAT_EN) |                  // enalbe lp
+                        (1 << BIT_LP_VFP_EN)  |                  // enalbe lp
+                        (1 << BIT_LP_VBP_EN)  |                  // enalbe lp
+                        (1 << BIT_LP_VSA_EN)  |                  // enalbe lp
+                        (1 << BIT_FRAME_BTA_ACK_EN) |            // enable BTA after one frame, TODO, need check
+                        //(1 << BIT_LP_CMD_EN) |                   // enable the command transmission only in lp mode    //evoke add for test
+                        (vid_mode_type << BIT_VID_MODE_TYPE) );  // burst/non burst
 
-        WRITE_LCD_REG(ENCL_VIDEO_HAVON_BEGIN,	pConf->lcd_timing.video_on_pixel);
-        WRITE_LCD_REG(ENCL_VIDEO_HAVON_END,	pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
-        WRITE_LCD_REG(ENCL_VIDEO_VAVON_BLINE,	pConf->lcd_timing.video_on_line);
-        WRITE_LCD_REG(ENCL_VIDEO_VAVON_ELINE,	pConf->lcd_basic.v_active - 1  + pConf->lcd_timing.video_on_line);
+        // 3.2   Configure video packet size settings
+        if( vid_mode_type == BURST_MODE ) {                                        // burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, p->lcd_basic.h_active);                          // should be one line in pixels, such as 480/240...
+        }
+        else if(vid_mode_type == NON_BURST_SYNC_PULSE || vid_mode_type == NON_BURST_SYNC_EVENT) {                           // non-burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, pixel_per_chunk);                    // in unit of pixels, (pclk period/byte clk period)*num_of_lane should be integer
+            // in our system, 16/8*num_of_lane is integer, so 6 pixel should be enough for 24bpp
+            // Worst case: (16/8)*8(pixel)*1(lane) >= 6(pkt head+crc)+3(max 24bpp)
+        }
 
-	WRITE_LCD_REG(ENCL_VIDEO_HSO_BEGIN,	pConf->lcd_timing.video_on_pixel - pConf->lcd_timing.hsync_width - pConf->lcd_timing.hsync_bp +3 -1);
-	WRITE_LCD_REG(ENCL_VIDEO_HSO_END,	pConf->lcd_timing.video_on_pixel - pConf->lcd_timing.hsync_bp +3 -1);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_BEGIN,	pConf->lcd_timing.video_on_pixel - pConf->lcd_timing.hsync_width - pConf->lcd_timing.hsync_bp +3 -1);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_END,	pConf->lcd_timing.video_on_pixel - pConf->lcd_timing.hsync_width - pConf->lcd_timing.hsync_bp +3 -1);
+        // 3.3   Configure number of chunks and null packet size for one line
+        if( vid_mode_type == BURST_MODE ) {                                        // burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, 0);
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, 0);
+        }
+        else {                                                                     // non burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, num_of_chunk);                     // HACT/VID_PKT_SIZE
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, vid_null_size);                     // video null size
+            DPRINT(" ============== NON_BURST SETTINGS =============\n");
+            DPRINT(" pixel_per_chunk       = %d\n", pixel_per_chunk);
+            DPRINT(" num_of_chunk          = %d\n", num_of_chunk);
+            DPRINT(" totol_bytes_per_chunk = %d\n", totol_bytes_per_chunk);
+            DPRINT(" byte_per_chunk        = %d\n", byte_per_chunk);
+            DPRINT(" chunk_overhead        = %d\n", chunk_overhead);
+            DPRINT(" vid_null_size         = %d\n", vid_null_size);
+            DPRINT(" ===============================================\n");
+        }
 
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE,	pConf->lcd_timing.video_on_line  - pConf->lcd_timing.vsync_width - pConf->lcd_timing.vsync_bp);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,	pConf->lcd_timing.video_on_line  - pConf->lcd_timing.vsync_bp);
+        // 4     Configure the video relative parameters according to the output type
+        //         include horizontal timing and vertical line
+        dsi_video_config(p);
+    }  /* operation_mode == OPERATION_VIDEO_MODE */
 
-        WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
+    // -----------------------------------------------------
+    // Finish Configuration
+    // -----------------------------------------------------
 
-        // enable encl
-        WRITE_LCD_REG(ENCL_VIDEO_EN,			1);
+    // Inner clock divider settings
+    WRITE_LCD_REG( MIPI_DSI_DWC_CLKMGR_CFG_OS, (0x1 << BIT_TO_CLK_DIV) | (0x1e << BIT_TX_ESC_CLK_DIV) );
+    // Packet header settings
+    WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
+                        (1 << BIT_ECC_RX_EN) |
+                        (0 << BIT_BTA_EN) |
+                        (0 << BIT_EOTP_RX_EN) |
+                        (0 << BIT_EOTP_TX_EN) );
+    // operation mode setting: video/command mode
+    WRITE_LCD_REG( MIPI_DSI_DWC_MODE_CFG_OS, operation_mode );
+
+    // Phy Timer
+    if ((output_type != TV_ENC_LCD240x160_dsi) &&
+                    (output_type != TV_ENC_LCD1920x1200p) &&
+                    (output_type != TV_ENC_LCD2560x1600) &&
+                    (output_type != TV_ENC_LCD768x1024p)) {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x03320000);
+    } else {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x090f0000);
+    }
+
+    // Configure DPHY Parameters
+    if ((output_type != TV_ENC_LCD240x160_dsi) &&
+                    (output_type != TV_ENC_LCD1920x1200p) &&
+                    (output_type != TV_ENC_LCD2560x1600) &&
+                    (output_type != TV_ENC_LCD768x1024p)) {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS, 0x870025);
+    } else {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS, 0x260017);
+    }
 }
 
-
-void set_control_mipi(Lcd_Config_t *p)
-{
-        unsigned int        mipi_dsi_dpi_color_type;
-        unsigned int        mipi_dsi_venc_color_type;
-        tv_enc_lcd_type_t   venc_format;
-        unsigned char       lane_num;
-        unsigned char       chroma_subsamp;
-
-        unsigned int        data32;
-        unsigned int        is_rgb;
-        unsigned int        dith10_en, dith8_en, dith5_en;
-        unsigned char       trans_mode;
-  //      unsigned char       refresh_rate; //available only for 2560x1600
-
-	//set VPU clk
-        //WRITE_CBUS_REG(HHI_VPU_CLK_CNTL, 0x303); //vid pll clock, N = 0, enable //moved to vpu.c, default config by dts
-	//WRITE_CBUS_REG(HHI_VPU_CLK_CNTL, 0x303);
-        //WRITE_CBUS_REG_BITS(HHI_VPU_MEM_PD_REG1, 0, 22, 2);
-
-        Lcd_Control_Config_t *pConf = &p->lcd_control;
-        trans_mode  = pConf->mipi_config->trans_mode;
-        venc_format = pConf->mipi_config->venc_fmt;
-        mipi_dsi_venc_color_type= pConf->mipi_config->venc_color_type;
-        mipi_dsi_dpi_color_type = pConf->mipi_config->dpi_color_type;
-        lane_num                = pConf->mipi_config->lane_num;
-        chroma_subsamp          = pConf->mipi_config->dpi_chroma_subsamp;
- //       refresh_rate            = pConf->mipi_config->refresh_rate;
-
-        DPRINT("%s, %d\n", __func__, __LINE__);
-        print_info(lane_num,                        // Lane number
-                        MIPI_DSI_VIRTUAL_CHAN_ID,                            // Virtual channel id
-                        mipi_dsi_venc_color_type,                            // MIPI dsi venc color type
-                        mipi_dsi_dpi_color_type,                             // MIPI dsi dpi color type
-                        chroma_subsamp,                                      // Chroma sub sample for YUV 422 or 420, even or odd
-                        trans_mode,                                          // DSI transfer mode, video or command
-                        venc_format,                                         // Venc resolution format, eg, 240x160
-                        MIPI_DSI_TRANS_VIDEO_MODE,                          //?????? // Video transfer mode, burst or non-burst
-                        1);                                                   // If check the phy status, need check when first pic
-
-
-
-        DPRINT("[TEST.C] Set mipi_dsi_host and mipi_dphy\n");
-        set_mipi_dcs(1,                                  //0: high speed, 1: low power
-                     0, //MIPI_DSI_DCS_ACK_TYPE,                                    // if need bta ack check
-                     MIPI_DSI_TEAR_SWITCH                                      // enable tear ack
-                     );
-
-        DPRINT("%s, %d\n", __func__, __LINE__);
-        set_mipi_dsi_host_to_command_mode(lane_num,                        // Lane number
-                        MIPI_DSI_VIRTUAL_CHAN_ID,                            // Virtual channel id
-                        mipi_dsi_venc_color_type,                            // MIPI dsi venc color type
-                        mipi_dsi_dpi_color_type,                             // MIPI dsi dpi color type
-                        chroma_subsamp,                                      // Chroma sub sample for YUV 422 or 420, even or odd
-                        trans_mode,                                          // DSI transfer mode, video or command
-                        venc_format,                                         // Venc resolution format, eg, 240x160
-                        MIPI_DSI_TRANS_VIDEO_MODE,                          //?????? // Video transfer mode, burst or non-burst
-                        1,                                                   // If check the phy status, need check when first pic
-                        p);
-}
-void powerdown_mipi_analog()
-{
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);//DIF_REF_CTL0
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x6 << 16);//DIF_REF_CTL2:31-16bit, DIF_REF_CTL1:15-0bit
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x20<< 16);//DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit
-}
-void powerup_mipi_analog()
+static void mipi_dsi_config(Lcd_Config_t *pConf)
 {
-    WRITE_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x8);//DIF_REF_CTL0
-    WRITE_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x3E << 16 |0xA5B8);//DIF_REF_CTL2:31-16bit, DIF_REF_CTL1:15-0bit
-    WRITE_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3,  0x26E0 << 16 |0xFC59);//DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit
-}
+    unsigned int        dpi_data_format;
+    unsigned int        venc_data_width;
+    tv_enc_lcd_type_t   venc_format;
+    unsigned char       lane_num;
+    unsigned char       operation_mode, video_mode_type;
 
-void init_phy_mipi(Lcd_Config_t *pConf)
-{
-    //powerup_mipi_analog();
-    DPRINT("%s, %d\n", __func__, __LINE__);
-    mdelay( 10 );
-    // Power up MIPI_DSI/DPHY, startup must be ahead of init
-    powerup_mipi_dsi_dphy();
+    operation_mode  = pConf->lcd_control.mipi_config->operation_mode;
+    video_mode_type = pConf->lcd_control.mipi_config->video_mode_type;
+    venc_format     = pConf->lcd_control.mipi_config->venc_fmt;
+    venc_data_width = pConf->lcd_control.mipi_config->venc_data_width;
+    dpi_data_format = pConf->lcd_control.mipi_config->dpi_data_format;
+    lane_num        = pConf->lcd_control.mipi_config->lane_num - 1;
 
-    init_mipi_dsi_phy(pConf);
+    DPRINT("%s, %d\n", __func__, __LINE__);
+#ifdef PRINT_DEBUG_INFO
+    print_info(pConf->lcd_control.mipi_config);
+#endif
 
-    // Check the phylock/stopstateclklane to decide if the DPHY is ready
-    check_phy_st();
+    DPRINT("Set mipi_dsi_host\n");
+    set_mipi_dcs(MIPI_DSI_CMD_TRANS_TYPE,            //0: high speed, 1: low power
+                 MIPI_DSI_DCS_ACK_TYPE,              // if need bta ack check
+                 MIPI_DSI_TEAR_SWITCH);                // enable tear ack
 
-    // Trigger a sync active for esc_clk
-    WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  READ_DSI_REG(MIPI_DSI_PHY_CTRL) | (1 << 1));
+    DPRINT("%s, %d\n", __func__, __LINE__);
+    set_mipi_dsi_host(lane_num,                        // Lane number
+                      MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
+                      venc_data_width,                 // MIPI dsi venc data bit width
+                      dpi_data_format,                 // MIPI dsi dpi data format
+                      0,                               // Chroma sub sample, only for YUV 422 or 420, even or odd
+                      operation_mode,                  // DSI operation mode, video or command
+                      venc_format,                     // Venc resolution format, eg, 240x160
+                      video_mode_type,                 // Video mode, burst or non-burst
+                      1,                               // If check the phy status, need check when first pic
+                      pConf);
 }
 
-void set_tcon_mipi(Lcd_Config_t *p)
-{
-        unsigned int width;
-        unsigned int height;
-        int lcd_type;
-        unsigned char lane_num;
-
-        unsigned int        dith10_en, dith8_en, dith5_en;
-        unsigned int        mipi_dsi_dpi_color_type;
-        unsigned int        mipi_dsi_venc_color_type;
-        unsigned int        is_rgb;
-        unsigned int        data32;
-        Lcd_Control_Config_t *pConf = &p->lcd_control;
-
-        width                   = p->lcd_basic.h_active;
-        height                  = p->lcd_basic.v_active;
-        lcd_type                = p->lcd_basic.lcd_type;
-        mipi_dsi_dpi_color_type = pConf->mipi_config->dpi_color_type;
-        mipi_dsi_venc_color_type= pConf->mipi_config->venc_color_type;
-        lane_num                = pConf->mipi_config->lane_num;
-
-
-	Lcd_Timing_t *tcon_adr = &(p->lcd_timing);
-
-	DPRINT("%s.\n", __FUNCTION__);
-
-	WRITE_LCD_REG(L_RGB_BASE_ADDR,   p->lcd_effect.rgb_base_addr);
-	WRITE_LCD_REG(L_RGB_COEFF_ADDR,  p->lcd_effect.rgb_coeff_addr);
-
-        is_rgb  = 1;    // RGB
-
-        // Report error if VENC output width is configured to be < DPI data width
-        //check_mipi_dsi_color_config (mipi_dsi_venc_color_type, mipi_dsi_dpi_color_type);
-
-        switch (mipi_dsi_venc_color_type) {
-                case MIPI_DSI_VENC_COLOR_24B    :
-                        dith10_en = 1; dith8_en = 0; dith5_en = 0;
-                        break;
-                case MIPI_DSI_VENC_COLOR_18B    :
-                        dith10_en = 1; dith8_en = 1; dith5_en = 0;
-                        break;
-                case MIPI_DSI_VENC_COLOR_16B    :
-                        dith10_en = 1; dith8_en = 1; dith5_en = 1;
-                        break;
-                default :   // case MIPI_DSI_VENC_COLOR_30B :
-                        dith10_en = 0; dith8_en = 0; dith5_en = 0;
-                        break;
-        }   /* switch (mipi_dsi_venc_color_type) */
-
-        data32  = 0;
-        //data32 |= (1        << 1);  // [1]  Set to 1 to bypass gain control ??????
-        data32 |= (is_rgb   << 0);  // [0]  cfg_video_rgbin_zblk: 0=use blank data for YUV; 1=use blank data for RGB.
-        WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL, data32);
-
-        data32  = 0;
-        data32 |= (dith5_en << 13); // [   13] dith_r5
-        data32 |= (0        << 12); // [   12] dith_g5
-        data32 |= (dith5_en << 11); // [   11] dith_b5
-        data32 |= (dith10_en<< 10); // [   10] dith10_en
-        data32 |= (dith8_en << 9);  // [    9] dith8_en
-        data32 |= (0        << 8);  // [    8] dith_md: use default setting
-        data32 |= (0        << 4);  // [ 7: 4] dith8_cntl: use default setting
-        data32 |= (0        << 0);  // [ 3: 0] dith10_cntl: use default setting
-        WRITE_LCD_REG(L_DITH_CNTL_ADDR, data32);
-
-	WRITE_LCD_REG(VPP_MISC, READ_LCD_REG(VPP_MISC) & ~(VPP_OUT_SATURATE));
-}
+void mipi_dsi_link_on(Lcd_Config_t *pConf)
+{
+    int vcid = MIPI_DSI_VIRTUAL_CHAN_ID;
+    int req_ack = MIPI_DSI_DCS_ACK_TYPE;
+    unsigned int        dpi_data_format;
+    unsigned int        venc_data_width;
+    tv_enc_lcd_type_t   venc_format;
+    unsigned char       lane_num;
+    unsigned char       operation_mode, video_mode_type;
+    int i=0, j=0, ending_flag=0;
+#ifdef CONFIG_AML_LCD_EXTERN
+    struct aml_lcd_extern_driver_t *lcd_extern_driver;
+#endif
 
-void lcd_ports_ctrl_mipi(Lcd_Config_t *p, Bool_t status)
-{
-        int vcid = MIPI_DSI_VIRTUAL_CHAN_ID;
-        int req_ack = 0;
-        unsigned int        mipi_dsi_dpi_color_type;
-        unsigned int        mipi_dsi_venc_color_type;
-        tv_enc_lcd_type_t   venc_format;
-        unsigned char       lane_num;
-        unsigned char       chroma_subsamp;
+    printk("%s\n", __FUNCTION__);
+    operation_mode  = OPERATION_VIDEO_MODE;//pConf->lcd_control.mipi_config->operation_mode;
+    video_mode_type = pConf->lcd_control.mipi_config->video_mode_type;
+    venc_format     = pConf->lcd_control.mipi_config->venc_fmt;
+    venc_data_width = pConf->lcd_control.mipi_config->venc_data_width;
+    dpi_data_format = pConf->lcd_control.mipi_config->dpi_data_format;
+    lane_num        = pConf->lcd_control.mipi_config->lane_num - 1;
 
-        unsigned int        data32;
-        unsigned int        is_rgb;
-        unsigned int        dith10_en, dith8_en, dith5_en;
-        unsigned char       trans_mode;
-				int i=0, ending_flag=0;
+    if(pConf->lcd_control.mipi_config->transfer_ctrl == 0)
+        startup_transfer_video();
+    else
+        startup_transfer_cmd();
 
-        if(OFF == status){
+    if (pConf->lcd_control.mipi_config->init_on_flag ==1) {
+#ifdef CONFIG_AML_LCD_EXTERN
+        lcd_extern_driver = aml_lcd_extern_get_driver();
+        if (lcd_extern_driver == NULL) {
+            printk("no lcd_extern driver\n");
+        }
+        else {
+            if (lcd_extern_driver->init_on_cmd_8) {
+                while(ending_flag == 0) {
+                    if(lcd_extern_driver->init_on_cmd_8[i]==0xff) {
+                        j = 2;
+                        if(lcd_extern_driver->init_on_cmd_8[i+1]==0xff)
+                            ending_flag = 1;
+                        else
+                            mdelay(lcd_extern_driver->init_on_cmd_8[i+1]);
+                    }
+                    else {
+                        j = lcd_extern_driver->init_on_cmd_8[i];
+                        if (j == 1) {//no parameter
+                            DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0, vcid, lcd_extern_driver->init_on_cmd_8[i+1], req_ack);
+                        }
+                        else if (j == 2) {//1 parameter
+                            DCS_write_short_packet_1_para(DT_DCS_SHORT_WR_1, vcid, lcd_extern_driver->init_on_cmd_8[i+1], lcd_extern_driver->init_on_cmd_8[i+2], req_ack);
+                        }
+                        else {//long write
+                            DCS_long_write_packet(DT_DCS_LONG_WR, vcid, lcd_extern_driver->init_on_cmd_8[i+1], &lcd_extern_driver->init_on_cmd_8[i+1], j, req_ack);
+                        }
+                        j++;
+                    }
+                    i += j;
+                }
+                printk("%s power on init\n", lcd_extern_driver->name);
+            }
+        }
+#endif
+    }
+
+    DPRINT("send sleep out\n");
+    DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0, vcid, DCS_EXIT_SLEEP_MODE, req_ack);
+    mdelay(pConf->lcd_control.mipi_config->sleep_out_delay);
+
+    DPRINT("send display on\n");
+    DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0, vcid, DCS_SET_DISPLAY_ON, req_ack);
+    mdelay(pConf->lcd_control.mipi_config->display_on_delay);
+
+    if (operation_mode != pConf->lcd_control.mipi_config->operation_mode) {
+        set_mipi_dsi_host(lane_num,                        // Lane number
+                      MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
+                      venc_data_width,                 // MIPI dsi venc RGB data bit width
+                      dpi_data_format,                 // MIPI dsi dpi data format
+                      0,                               // Chroma sub sample, only for YUV 422 or 420, even or odd
+                      operation_mode,                  // DSI operation mode, video or command
+                      venc_format,                     // Venc resolution format, eg, 240x160
+                      video_mode_type,                 // Video mode, burst or non-burst
+                      1,                               // If check the phy status, need check when first pic
+                      pConf);
+    }
+}
 
-                DPRINT("send display off\n");
-                DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0,                       // DSI Data Type
-                                vcid,                                    // Virtual ID
-                                DCS_SET_DISPLAY_OFF,                      // DCS Command Type
-                                req_ack);                                // If need wait ack
-                DPRINT("DCS_SET_DISPLAY_OFF Test Passed\n");
-                mdelay(10);
+void mipi_dsi_link_off(Lcd_Config_t *pConf)
+{
+    int vcid = MIPI_DSI_VIRTUAL_CHAN_ID;
+    int req_ack = 0;
+    int i=0, j=0, ending_flag=0;
+#ifdef CONFIG_AML_LCD_EXTERN
+    struct aml_lcd_extern_driver_t *lcd_extern_driver;
+#endif
 
+    printk("%s\n", __FUNCTION__);
+    DPRINT("send display off\n");
+    DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0, vcid, DCS_SET_DISPLAY_OFF, req_ack);
+    mdelay(10);
 
-                DPRINT("send exit sleep mode\n");
-                DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0,                       // DSI Data Type
-                                vcid,                                    // Virtual ID
-                                DCS_ENTER_SLEEP_MODE,                     // DCS Command Type
-                                req_ack);                                // If need wait ack
+    DPRINT("send enter sleep mode\n");
+    DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0, vcid, DCS_ENTER_SLEEP_MODE, req_ack);
+    mdelay(20);
 
-                mdelay(20);
+    if (pConf->lcd_control.mipi_config->init_off_flag ==1) {
+#ifdef CONFIG_AML_LCD_EXTERN
+        lcd_extern_driver = aml_lcd_extern_get_driver();
+        if (lcd_extern_driver == NULL) {
+            printk("no lcd_extern driver\n");
+        }
+        else {
+            if (lcd_extern_driver->init_off_cmd_8) {
+                while(ending_flag == 0) {
+                    if(lcd_extern_driver->init_off_cmd_8[i]==0xff) {
+                        j = 2;
+                        if(lcd_extern_driver->init_off_cmd_8[i+1]==0xff)
+                            ending_flag = 1;
+                        else
+                            mdelay(lcd_extern_driver->init_off_cmd_8[i+1]);
+                    }
+                    else {
+                        j = lcd_extern_driver->init_off_cmd_8[i];
+                        if (j == 1) {//no parameter
+                            DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0, vcid, lcd_extern_driver->init_off_cmd_8[i+1], req_ack);
+                        }
+                        else if (j == 2) {//1 parameter
+                            DCS_write_short_packet_1_para(DT_DCS_SHORT_WR_1, vcid, lcd_extern_driver->init_off_cmd_8[i+1], lcd_extern_driver->init_off_cmd_8[i+2], req_ack);
+                        }
+                        else {//long write
+                            DCS_long_write_packet(DT_DCS_LONG_WR, vcid, lcd_extern_driver->init_off_cmd_8[i+1], &lcd_extern_driver->init_off_cmd_8[i+1], j, req_ack);
+                        }
+                        j++;
+                    }
+                    i += j;
+                }
+                printk("%s power off init\n", lcd_extern_driver->name);
+            }
+        }
+#endif
+    }
+}
 
-                DPRINT("poweroff dsi analog\n");
+void set_mipi_dsi_control(Lcd_Config_t *pConf)
+{
+    DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
 
-                powerdown_mipi_analog();
+    cfg->video_mode_type = MIPI_DSI_VIDEO_MODE_TYPE;
+    if(pConf->lcd_basic.lcd_bits == 6){
+        cfg->dpi_data_format = COLOR_18BIT_CFG_2;
+        cfg->venc_data_width = MIPI_DSI_VENC_COLOR_18B;
+    }else{
+        cfg->dpi_data_format  = COLOR_24BIT;
+        cfg->venc_data_width = MIPI_DSI_VENC_COLOR_24B;
+    }
 
-                DPRINT("poweroff dsi digital\n");
+    if((pConf->lcd_basic.h_active !=240)&&(pConf->lcd_basic.h_active !=768)&&(pConf->lcd_basic.h_active !=1920)&&(pConf->lcd_basic.h_active !=2560))
+        cfg->venc_fmt=TV_ENC_LCD1280x720;
+    else
+        cfg->venc_fmt=TV_ENC_LCD768x1024p;
 
-                powerdown_mipi_dsi_dphy();
-                DPRINT("MIPI_DSI_PHY_CTRL=%x\n", READ_DSI_REG(MIPI_DSI_PHY_CTRL)); //read
-                WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL, 0, 7, 1);
+    if (cfg->factor_numerator == 0) {
+        pConf->lcd_control.mipi_config->factor_denominator = pConf->lcd_control.mipi_config->bit_rate / 8 / 1000;
+        pConf->lcd_control.mipi_config->factor_numerator = pConf->lcd_timing.lcd_clk / 1000;
+    }
+    cfg->hline =(pConf->lcd_basic.h_period * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;  // Rounded. Applicable for Period(pixclk)/Period(bytelaneclk)=9/16
+    cfg->hsa =(pConf->lcd_timing.hsync_width * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
+    cfg->hbp =((pConf->lcd_timing.hsync_bp-pConf->lcd_timing.hsync_width) * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
 
-                return ;
-        }
+    cfg->vsa = pConf->lcd_timing.vsync_width;
+    cfg->vbp = pConf->lcd_timing.vsync_bp - pConf->lcd_timing.vsync_width;
+    cfg->vfp = pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp - pConf->lcd_basic.v_active;
+    cfg->vact = pConf->lcd_basic.v_active;
 
-        Lcd_Control_Config_t *pConf = &p->lcd_control;
-        trans_mode  = pConf->mipi_config->trans_mode;
-        venc_format = pConf->mipi_config->venc_fmt;
-        mipi_dsi_venc_color_type= pConf->mipi_config->venc_color_type;
-        mipi_dsi_dpi_color_type = pConf->mipi_config->dpi_color_type;
-        lane_num                = pConf->mipi_config->lane_num;
-        chroma_subsamp          = pConf->mipi_config->dpi_chroma_subsamp;
-        
-				powerup_mipi_analog();
-        startup_transfer_video();
-        
-				if (pConf->mipi_config->mipi_init_flag ==1) {        	
-        	while(ending_flag == 0) {
-						if(pConf->mipi_config->mipi_init[i]==0xff) {
-							if(pConf->mipi_config->mipi_init[i+1]==0xff)
-								ending_flag = 1;
-							else
-								mdelay(pConf->mipi_config->mipi_init[i+1]);
-						}
-						else {
-							DCS_write_short_packet_1_para(DT_DCS_SHORT_WR_1,vcid,pConf->mipi_config->mipi_init[i], pConf->mipi_config->mipi_init[i+1],req_ack);
-						}
-						i += 2;
-        	}
-        }
-        
-        DPRINT("send exit sleep mode\n");
-        DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0,                       // DSI Data Type
-                        vcid,                                    // Virtual ID
-                        DCS_EXIT_SLEEP_MODE,                     // DCS Command Type
-                        req_ack);                                // If need wait ack
-
-        mdelay(pConf->mipi_config->sleep_out_delay);
-
-        DPRINT("send display on\n");
-        DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0,                       // DSI Data Type
-                        vcid,                                    // Virtual ID
-                        DCS_SET_DISPLAY_ON,                      // DCS Command Type
-                        req_ack);                                // If need wait ack
-        DPRINT("DCS_SET_DISPLAY_ON Test Passed\n");
-        mdelay(pConf->mipi_config->display_on_delay);
-
-        trans_mode = TRANS_VIDEO_MODE;
-        set_mipi_dsi_host_to_video_mode(lane_num,                        // Lane number
-                        MIPI_DSI_VIRTUAL_CHAN_ID,                            // Virtual channel id
-                        mipi_dsi_venc_color_type,                            // MIPI dsi venc color type
-                        mipi_dsi_dpi_color_type,                             // MIPI dsi dpi color type
-                        chroma_subsamp,                                      // Chroma sub sample for YUV 422 or 420, even or odd
-                        trans_mode,                                          // DSI transfer mode, video or command
-                        venc_format,                                         // Venc resolution format, eg, 240x160
-                        MIPI_DSI_TRANS_VIDEO_MODE,                          //?????? // Video transfer mode, burst or non-burst
-                        1,                                                   // If check the phy status, need check when first pic
-                        p);
+    dsi_phy_config(pConf);
 
+    mipi_dsi_config(pConf);
 }
 
-void dsi_probe( Lcd_Config_t *pConf)
+void mipi_dsi_off(void)
 {
+    DPRINT("poweroff dsi digital\n");
+    // Power down DSI
+    WRITE_LCD_REG(MIPI_DSI_DWC_PWR_UP_OS, 0);
 
-	unsigned pre_div, xd, post_div;
-        unsigned lcd_clk;
-        unsigned pclk;
-        unsigned lanebyteclk;
-        unsigned int div;
-        DSI_Config_t    *cfg= pConf->lcd_control.mipi_config;
-        Lcd_Timing_t    *t = &pConf->lcd_timing;
-        Lcd_Basic_t     *basic = &pConf->lcd_basic;
-
-        if (0 == cfg->numerator){
-                div = cfg->dsi_clk_div;
-                post_div = 1;
-
-                pre_div = ((t->div_ctrl) >> DIV_CTRL_DIV_PRE) & 0x7;
-                pre_div = div_pre_table[pre_div];
-                xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
-
-                lcd_clk = t->lcd_clk * pre_div * post_div * xd;
-
-                lanebyteclk = lcd_clk/div;
-                lanebyteclk = lanebyteclk / 8;
-                lanebyteclk = lanebyteclk/1000;
-                DPRINT("pll out clk=%d Hz, lanebyteclk/1000=%d kHz\n", lcd_clk, lanebyteclk);
-
-                pclk = pConf->lcd_timing.lcd_clk/1000;
-                DPRINT("pixel clk=%d kHz\n", pclk);
-                cfg->denominator = lanebyteclk/1000;
-                cfg->numerator = pclk/1000;
-                DPRINT("d=%d, n=%d, d/n=%d\n",
-                        cfg->denominator, cfg->numerator, cfg->denominator/cfg->numerator);
-        }
-
-				cfg->hline =(basic->h_period*cfg->denominator + cfg->numerator - 1) / cfg->numerator;  // Rounded. Applicable for Period(pixclk)/Period(bytelaneclk)=9/16
-        cfg->hsa   =(t->hsync_width*cfg->denominator + cfg->numerator - 1) / cfg->numerator;
-        cfg->hbp   =((t->hsync_bp-t->hsync_width) * cfg->denominator + cfg->numerator - 1) / cfg->numerator;
+    // Power down D-PHY, do not have to close dphy
+    // WRITE_LCD_REG(MIPI_DSI_DWC_PHY_RSTZ_OS, (READ_LCD_REG( MIPI_DSI_DWC_PHY_RSTZ_OS ) & 0xc));
+    // WRITE_LCD_REG(MIPI_DSI_DWC_PHY_RSTZ_OS, 0xc);
 
-        cfg->vsa   = t->vsync_width;
-        cfg->vbp   = t->vsync_bp -t->vsync_width;
-        cfg->vfp   = basic->v_period  - t->vsync_bp-basic->v_active;
-        cfg->vact  = basic->v_active;
+    WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0x1f);
+    DPRINT("MIPI_DSI_PHY_CTRL=0x%x\n", READ_DSI_REG(MIPI_DSI_PHY_CTRL)); //read
+    WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL, 0, 7, 1);
 }
-#if 0
-int do_dsi(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
-{
-	int i, init_flag=0,dev, ret = 0;
-	uint64_t addr;
-	loff_t off=0, size=0;
-	char *cmd, *s, *area;
-	char	str[128];
-        Lcd_Config_t *pConf = pDev->pConf;
-
-        unsigned int data_type;
-        unsigned int vc_id;
-        unsigned int dcs_command;
-        unsigned int req_ack;
-
-	if (argc < 2){
-	        DPRINT( "1.init\n"
-                        "2.pll\n"
-                        "3.ctrl\n"
-                        "4.tcon\n"
-                        "5.venc\n"
-                        "6.phy\n"
-                        " dsi cmdpkt dcs_command vc_id req_ack\n"
-                        " dsi gen dcs_command vc_id\n"
-                        "\nall\n");
-
-		return 1;
-        }
-
-	cmd = argv[1];
-
-	if (strcmp(cmd, "init") == 0){
-                lcd_probe();
-                DPRINT("init\n");
-                DPRINT("MIPI_DSI_DWC_PWR_UP_OS=0x%x, P_MIPI_DSI_DWC_PWR_UP_OS=0x%x\n",
-                                MIPI_DSI_DWC_PWR_UP_OS, P_MIPI_DSI_DWC_PWR_UP_OS);
-        }else if(strcmp(cmd, "pll") == 0){
-                set_pll_mipi(pConf); //1step
 
-        }else if(strcmp(cmd, "ctrl") == 0){
-                set_control_mipi(pConf);//2step
+//***********************************************//
+static const char * dsi_usage_str =
+{"Usage:\n"
+"    echo read <addr> <reg_count> > debug ; read dsi phy reg value\n"
+"    echo write <addr> <value> > debug ; write dsi phy reg with value\n"
+"    echo info > debug ; print dsi config information\n"
+};
 
-        }else if(strcmp(cmd, "tcon") == 0){
-                set_tcon_mipi(pConf); //3step
+static ssize_t dsi_debug_help(struct class *class, struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", dsi_usage_str);
+}
 
-        }else if(strcmp(cmd, "venc") == 0){
-                set_venc_lcd(pConf); //4step
+static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+    unsigned int ret;
+    unsigned t[3];
+    unsigned num = 0;
+    int i;
+
+    switch (buf[0]) {
+        case 'r':	//read
+            num = 1;
+            ret = sscanf(buf, "read %x %u", &t[0], &num);
+            printk("read dsi phy reg:\n");
+            for (i=0; i<num; i++) {
+                printk("  0x%04x = 0x%08x\n", t[0]+i, READ_DSI_REG(t[0]+i));
+            }
+            break;
+        case 'w':	//write
+            ret = sscanf(buf, "write %x %x", &t[0], &t[1]);
+            WRITE_DSI_REG(t[0], t[1]);
+            printk("write dsi phy reg 0x%04x = 0x%08x, readback 0x%08x\n", t[0], t[1], READ_DSI_REG(t[0]));
+            break;
+        case 'i':
+            if (dsi_config)
+                print_info(dsi_config);
+            break;
+        default:
+            printk("wrong format of dsi debug command.\n");
+            break;
+    }
+
+    if (ret != 1 || ret !=2)
+        return -EINVAL;
+    
+    return count;
+    //return 0;
+}
 
-        }else if(strcmp(cmd, "phy") == 0){
-		init_dphy(pConf);
+static struct class_attribute dsi_debug_class_attrs[] = {
+    __ATTR(debug, S_IRUGO | S_IWUSR, dsi_debug_help, dsi_debug),
+    __ATTR(help, S_IRUGO | S_IWUSR, dsi_debug_help, NULL),
+    __ATTR_NULL
+};
 
-        }else if(strcmp(cmd, "gen") == 0){
-		if (argc < 3){
-                        DPRINT(" para count =%d\n", argc);
-                        DPRINT(" dsi gen dcs_command vc_id\n");
-                }
-		dcs_command = (ulong)simple_strtoul(argv[2], NULL, 16);
-		vc_id = (ulong)simple_strtoul(argv[3], NULL, 16);
-                data_type = DT_DCS_SHORT_WR_0;// DSI Data Type
+static struct class aml_dsi_debug_class = {
+    .name = "dsi",
+    .class_attrs = dsi_debug_class_attrs,
+};
+//*********************************************************//
 
-                DPRINT("dcs_command=%x, vc_id=%d, data_type=DT_DCS_SHORT_WR_0\n", dcs_command, vc_id);
-
-                generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((0x0 << BIT_GEN_WC_MSBYTE) |
-                                (dcs_command << BIT_GEN_WC_LSBYTE) |
-                                (vc_id << BIT_GEN_VC)              |
-                                (data_type << BIT_GEN_DT)));
+void dsi_probe(Lcd_Config_t *pConf)
+{
+    int ret;
 
-        }else if(strcmp(cmd, "ack") == 0){
-                wait_bta_ack();
+    dsi_config = pConf->lcd_control.mipi_config;
+    ret = class_register(&aml_dsi_debug_class);
+    if(ret){
+        DPRINT("class register aml_dsi_debug_class fail!\n");
+    }
+}
 
-        }else if(strcmp(cmd, "noack") == 0){
-                wait_cmd_fifo_empty();
+void dsi_remove(void)
+{
 
-        }else if(strcmp(cmd, "cmdpkt") == 0){
-		if (argc < 3){
-                        DPRINT(" para count =%d\n", argc);
-                        DPRINT(" dsi cmdpkt dcs_command vc_id req_ack\n");
-                }
-		dcs_command = (ulong)simple_strtoul(argv[2], NULL, 16);
-		vc_id = (ulong)simple_strtoul(argv[3], NULL, 16);
-		req_ack = (ulong)simple_strtoul(argv[4], NULL, 16);
-
-                DPRINT("dcs_command=%x, vc_id=%d req_ack=%d\n", dcs_command, vc_id, req_ack);
-
-                DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0,                       // DSI Data Type
-                                  vc_id,                                    // Virtual ID
-                                  dcs_command,                     // DCS Command Type
-                                  req_ack);                                // If need wait ack
-
-        }else if(strcmp(cmd, "poweron") == 0){
-	        lcd_power_ctrl(ON);
-
-        }else if(strcmp(cmd, "display") == 0){
-
-                dcs_command = (ulong)simple_strtoul(argv[2], NULL, 16);
-                vc_id = (ulong)simple_strtoul(argv[3], NULL, 16);
-                req_ack = 0;
-                DPRINT("STIMULUS_MIPI_DSI_DCS_PKT_TYPE | DCS_CMD_CODE_SET_DISPLAY_ON\n");
-                DCS_write_short_packet_0_para(DT_DCS_SHORT_WR_0,                       // DSI Data Type
-                                vc_id,                                    // Virtual ID
-                                DCS_SET_DISPLAY_ON,                      // DCS Command Type
-                                req_ack);                                // If need wait ack
-                DPRINT("DCS_SET_DISPLAY_ON Test Passed\n");
-
-        }else if(strcmp(cmd, "go") == 0){
-
-            set_mipi_dsi_host_to_video_mode(3,                // Lane number
-                                MIPI_DSI_VIRTUAL_CHAN_ID,     // Virtual channel id
-                                2,                            // MIPI dsi venc color type
-                                3,                             // MIPI dsi dpi color type
-                                0,//chroma_subsamp,                                      // Chroma sub sample for YUV 422 or 420, even or odd
-                                TRANS_VIDEO_MODE,               // DSI transfer mode, video or command
-                                TV_ENC_LCD768x1024p,            // Venc resolution format, eg, 240x160
-                                MIPI_DSI_TRANS_VIDEO_MODE,                          //?????? // Video transfer mode, burst or non-burst
-                                1,                                                   // If check the phy status, need check when first pic
-                                60);
-
-        }else if(strcmp(cmd, "all") == 0){
-		set_pll_mipi(pConf); //1step
-                set_control_mipi(pConf);//2step
-                set_tcon_mipi(pConf); //3step
-                set_venc_lcd(pConf); //4step
-                init_dphy(pConf);
-
-        }else{
-		DPRINT("cmd %s not support\n", cmd);
-	}
-
-        DPRINT("cmd=%s,exit\n", cmd);
-        return 0;
 }
-U_BOOT_CMD(
-		dsi, 7, 1, do_dsi,
-		"enforce eth speed",
-		"dsi init       - \n"
-		"dsi host       - \n"
-	  );
-//****************************************
-#endif
 
 #endif
+
diff --git a/drivers/amlogic/display/vout/mipi_dsi_util.h b/drivers/amlogic/display/vout/mipi_dsi_util.h
index ec511a9cf572..fa0197b02b8c 100755
--- a/drivers/amlogic/display/vout/mipi_dsi_util.h
+++ b/drivers/amlogic/display/vout/mipi_dsi_util.h
@@ -1,21 +1,13 @@
 #ifndef MIPI_DSI_UTIL_H
 #define MIPI_DSI_UTIL_H
 
-//#include <asm/arch/register.h>
 #include <mach/register.h>
 #include <mach/cpu.h>
 #include <linux/amlogic/vout/lcdoutc.h>
-//#include <asm/arch/lcdoutc.h>
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 #include <mach/mipi_dsi_reg.h>
 
-//#define PRINT_DEBUG_INFO
-#ifdef PRINT_DEBUG_INFO
-#define DPRINT(...)		printk(__VA_ARGS__)
-#else
-#define DPRINT(...)
-#endif
 // --------------------------------------------------------
 // MIPI DSI Data Type/ MIPI DCS Command Type Definitions
 // --------------------------------------------------------
@@ -309,9 +301,9 @@ typedef enum {DT_VSS                 = 0x01,
 #define BIT_ACK_ERR_1               1
 #define BIT_ACK_ERR_0               0
 
-// Transfer mode parameters
-#define TRANS_VIDEO_MODE            0
-#define TRANS_COMMAND_MODE          1
+// Operation mode parameters
+#define OPERATION_VIDEO_MODE        0
+#define OPERATION_COMMAND_MODE      1
 
 // Command transfer type in command mode
 #define DCS_TRANS_HS                0
@@ -561,81 +553,6 @@ typedef enum tv_enc_lcd_type_e{
         TV_ENC_LCD768x1024p = 26,
         TV_ENC_LCD_TYPE_MAX
 } tv_enc_lcd_type_t;   /* tv encoder output format */
-/*
-int set_lcd_clk(unsigned int display_w, unsigned int display_h,
-                unsigned int color_code, unsigned int lane_num,
-                unsigned int refresh_rate);
-                */
-void init_mipi_dsi_phy(Lcd_Config_t *pConf);
-
-extern void start_mipi_dsi_host(void);                                             // close the default reset
-
-extern void powerup_mipi_dsi_dphy(void);                                           // power up mipi_dsi and dphy
-extern void powerdown_mipi_dsi_dphy(void);                                         // power down mipi_dsi and dphy
-
-extern void set_mipi_int(void);                                                    // configure mipi interrupt registers
-extern void set_mipi_dcs(int trans_type,                                       // 0: high speed, 1: low power
-                int ack_req,                                          // 1: request ack, 0: do not need ack
-                int tear_en                                           // 1: enable tear ack, 0: disable tear ack
-                );                                                     // configure command mode relative registers
-
-extern void set_mipi_edpi(unsigned int edpi_allowed_cmd_size,                  // allowed command size for edpi
-                unsigned int vcid,                                   // virtual id for DBI
-                unsigned short start_col,                            // start column address
-                unsigned short end_col,                              // end column address
-                unsigned short start_page,                           // start page address
-                unsigned short end_page,                             // end page address
-                unsigned int pixel2byte,                             // pixel-to-byte format
-                unsigned int req_ack,                                // if need check ack for bta
-                unsigned int color_code                              // color code
-                );
-
-extern void check_phy_st(void);                                                    // Check the status of the dphy: phylock and stopstateclklane
-
-extern void delay_us(int us);
-extern void config_video_para(tv_enc_lcd_type_t output_type,
-                unsigned int    color_code,                   // Configure video parameter such HFP/HSA/HBP/HACT...
-                Lcd_Config_t    *pConf);
-
-extern void wait_bta_ack(void);                                                    // wait ack from bta
-extern void wait_cmd_fifo_empty(void);                                             // wait generic fifo empty
-extern unsigned int wait_for_generic_read_response(void);                          // wait read response
-
-extern unsigned int generic_if_wr(unsigned int address, unsigned int data_in); // Generic Interface Write
-extern unsigned int generic_if_rd(unsigned int address);                       // Generic Interface Read
-
-extern void DCS_write_short_packet_0_para(unsigned int data_type,              // DSI data type, such as DCS Short Write Packet 1 Parameter
-                unsigned int vc_id,                  // Virtual Channel ID
-                unsigned int dcs_command,            // DCS Command, such as enter_idle_mode
-                unsigned int req_ack                 // request ack for bta
-                );
-
-extern void DCS_write_short_packet_1_para(unsigned int data_type,              // DSI data type, such as DCS Short Write Packet 1 Parameter
-                unsigned int vc_id,                  // Virtual Channel ID
-                unsigned int dcs_command,            // DCS Command, such as set_address_mode
-                unsigned int para,                   // Parameter
-                unsigned int req_ack                 // request ack for bta
-                );
-
-extern unsigned int  DCS_read_packet_no_para(unsigned int data_type,           // DSI data type, such as DCS Read Packet no Parameter
-                unsigned int vc_id,               // Virtual Channel ID
-                unsigned int dcs_command          // DCS Command, such as get_address_mode
-                );
-
-extern void DCS_long_write_packet(unsigned int data_type,                      // DSI data type, such as DCS Long Write Packet
-                unsigned int vc_id,                          // Virtual Channel ID
-                unsigned int dcs_command,                    // DCS Command, such as set_column_address/set_page_address
-                unsigned char* payload,                       // Payload include: dcs_command+payload
-                unsigned int pld_size,                       // Payload size, from LSB to MSB
-                unsigned int req_ack                         // if need check ack for bta
-                );
-
-
-extern void check_mipi_dsi_color_config (unsigned int venc_color_type, unsigned int dpi_color_type);
-
-void startup_mipi_dsi_host(void);
-
-extern void auo_panel_init(void);
 
 // DCS COMMAND LIST
 #define DCS_CMD_CODE_ENTER_IDLE_MODE      0x0
@@ -652,32 +569,12 @@ extern void auo_panel_init(void);
 #define DCS_CMD_CODE_SET_TEAR_OFF         0xb 
 #define DCS_CMD_CODE_SOFT_RESET           0xc
 
-void set_pll_mipi(Lcd_Config_t *p);
-
-void set_venc_mipi(Lcd_Config_t *pConf);
-
-void set_control_mipi(Lcd_Config_t *p);
-
-void init_phy_mipi(Lcd_Config_t *pConf);
-
-void set_tcon_mipi(Lcd_Config_t *p);
-
-void lcd_ports_ctrl_mipi(Lcd_Config_t *p, Bool_t status);
-
-void dsi_probe(Lcd_Config_t *pConf);
+extern void mipi_dsi_link_on(Lcd_Config_t *pConf);
+extern void mipi_dsi_link_off(Lcd_Config_t *pConf);
+extern void set_mipi_dsi_control(Lcd_Config_t *pConf);
+extern void mipi_dsi_off(void);
+extern void dsi_probe(Lcd_Config_t *pConf);
+extern void dsi_remove(void);
 
-//****************************************************************************************************/
-//      from test_prm.h
-//****************************************************************************************************/
-#define MIPI_DSI_VIRTUAL_CHAN_ID        0                       // Range [0,3]
-/////pConf->dsi_cfg->trans_mode;
-#define MIPI_DSI_TRANS_MODE             TRANS_VIDEO_MODE        // Define DSI communication mode: video mode or command_mode.
-#define MIPI_DSI_CMD_TRANS_TYPE         DCS_TRANS_HS            // Define DSI command transfer type: high speed or low power
-#define MIPI_DSI_DCS_ACK_TYPE           MIPI_DSI_DCS_REQ_ACK    // Define if DSI command need ack: req_ack or no_ack
-#define MIPI_DSI_TRANS_VIDEO_MODE       BURST_MODE              // Applicable only to video mode. Define picture data transfer method: non-burst sync pulse; non-burst sync event; or burst.
-#define MIPI_DSI_TEAR_SWITCH            MIPI_DCS_DISABLE_TEAR
-//****************************************************************************************************/
-//      from test_prm.h
-//****************************************************************************************************/
 #endif
 #endif
diff --git a/include/linux/amlogic/vout/aml_lcd_extern.h b/include/linux/amlogic/vout/aml_lcd_extern.h
index d86569d5d776..d66aa7c295bd 100755
--- a/include/linux/amlogic/vout/aml_lcd_extern.h
+++ b/include/linux/amlogic/vout/aml_lcd_extern.h
@@ -2,34 +2,53 @@
 #ifndef __AMLOGIC_LCD_EXTERN_H_
 #define __AMLOGIC_LCD_EXTERN_H_
 
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/pinctrl/consumer.h>
+
 typedef enum {
 	LCD_EXTERN_I2C = 0,
 	LCD_EXTERN_SPI,
+	LCD_EXTERN_MIPI,
 	LCD_EXTERN_MAX,
 } Lcd_Extern_Type_t;
 
+//global API
 struct aml_lcd_extern_driver_t {
 	char *name;
 	Lcd_Extern_Type_t type;
-	int  (*reg_read)  (unsigned char reg, unsigned char *buf);
-    int  (*reg_write) (unsigned char reg, unsigned char value);
-	int  (*power_on)(void);
-	int  (*power_off)(void);
-	// void  (*fun1_no_para)(void);
-	// void  (*fun2_no_para)(void);
-	// void  (*fun1_para)(unsigned para);
-	// void  (*fun2_para)(unsigned para); 
+	int (*reg_read)  (unsigned char reg, unsigned char *buf);
+	int (*reg_write) (unsigned char reg, unsigned char value);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	unsigned char *init_on_cmd_8;
+	unsigned char *init_off_cmd_8;
+	//unsigned short *init_on_cmd_16;
+	//unsigned short *init_off_cmd_16;
 };
 
-struct lcd_extern_data_t {
+struct lcd_extern_config_t {
 	char *name;
 	Lcd_Extern_Type_t type;
 	int status;
-	int  i2c_bus;
-	int  addr;
+	int i2c_addr;
+	int i2c_bus;
+	int spi_cs;
+	int spi_clk;
+	int spi_data;
 };
 
+#define LCD_EXTERN_DRIVER		"lcd_extern"
+
+#define lcd_extern_gpio_request(gpio) 				amlogic_gpio_request(gpio, LCD_EXTERN_DRIVER)
+#define lcd_extern_gpio_free(gpio) 					amlogic_gpio_free(gpio, LCD_EXTERN_DRIVER)
+#define lcd_extern_gpio_direction_input(gpio) 		amlogic_gpio_direction_input(gpio, LCD_EXTERN_DRIVER)
+#define lcd_extern_gpio_direction_output(gpio, val) amlogic_gpio_direction_output(gpio, val, LCD_EXTERN_DRIVER)
+#define lcd_extern_gpio_get_value(gpio) 			amlogic_get_value(gpio, LCD_EXTERN_DRIVER)
+#define lcd_extern_gpio_set_value(gpio,val) 		amlogic_set_value(gpio, val, LCD_EXTERN_DRIVER)
+
 extern struct aml_lcd_extern_driver_t* aml_lcd_extern_get_driver(void);
+extern int lcd_extern_driver_check(void);
+extern int get_lcd_extern_dt_data(struct device_node* of_node, struct lcd_extern_config_t *pdata);
 
 #endif
 
diff --git a/include/linux/amlogic/vout/lcdoutc.h b/include/linux/amlogic/vout/lcdoutc.h
index 70aa169a7b27..a2e3fec2052c 100755
--- a/include/linux/amlogic/vout/lcdoutc.h
+++ b/include/linux/amlogic/vout/lcdoutc.h
@@ -154,8 +154,8 @@
 	#define DIV_CTRL_POST_SEL		8	//[9:8]
 	#define DIV_CTRL_DIV_PRE		4	//[6:4]
 
-	#define CLK_TEST_FLAG			31
-	#define CLK_CTRL_AUTO			30
+	#define CLK_CTRL_AUTO			31
+	#define CLK_TEST_FLAG			30
 	#define CLK_CTRL_FRAC			16	//[27:16]
 	#define CLK_CTRL_LEVEL			12	//[13:12]
 	//#define CLK_CTRL_PLL_SEL		10
@@ -198,7 +198,7 @@
 	#define MIPI_PHY_MAX_CLK_IN		(1000 * 1000)
 	#define DIV_PRE_MAX_CLK_IN		(1500 * 1000)
 	#define DIV_POST_MAX_CLK_IN		(1000 * 1000)
-	#define CRT_VID_MAX_CLK_IN		(600 * 1000)
+	#define CRT_VID_MAX_CLK_IN		(1300 * 1000)
 	#define LCD_VENC_MAX_CLK_IN		(333 * 1000)
 #endif
 	/* lcd interface video clk */
@@ -431,35 +431,31 @@ typedef struct {
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 typedef struct DSI_Config_s{
-        unsigned int    dsi_clk_div;
-        unsigned int    dsi_clk_max;
-        unsigned int    dsi_clk_min; //2^32 = 4294967296 = 4.2G
-        unsigned int    denominator; //
-        unsigned int    numerator;//default 10000
-				unsigned int    mipi_init_flag;
-        unsigned int    hline;
-        unsigned int    hsa;
-        unsigned int    hbp;
-        unsigned int    vsa;
-        unsigned int    vbp;
-        unsigned int    vfp;
-        unsigned int    vact;
-
-        unsigned int    venc_color_type;
-        unsigned int    dpi_color_type;
-        unsigned char   dpi_chroma_subsamp;
-        unsigned int    venc_fmt;
-        unsigned char   lane_num;
-        unsigned char   trans_mode;
-
-        unsigned char   trans_type;    //such ad hs or lp
-        unsigned char   ack_type;      //if need bta ack check
-        unsigned char   tear_switch;
-
-        unsigned char   is_rgb;        //whether dpi color type is rgb
-        unsigned char   mipi_init[20];
-        unsigned int 		sleep_out_delay;
-        unsigned int 		display_on_delay;
+    unsigned char lane_num;
+    unsigned int bit_rate_max;
+    unsigned int bit_rate_min;
+    unsigned int bit_rate;
+    unsigned int factor_denominator;
+    unsigned int factor_numerator;
+    unsigned int hline;
+    unsigned int hsa;
+    unsigned int hbp;
+    unsigned int vsa;
+    unsigned int vbp;
+    unsigned int vfp;
+    unsigned int vact;
+
+    unsigned int venc_data_width;
+    unsigned int dpi_data_format;
+    unsigned int venc_fmt;
+    unsigned char operation_mode;  //mipi-dsi operation mode: video, command
+    unsigned char transfer_ctrl;  //LP mode auto stop clk lane
+    unsigned char video_mode_type;  //burst, non-burst(sync pulse, sync event)
+
+    unsigned char init_on_flag;
+    unsigned char init_off_flag;
+    unsigned int sleep_out_delay;
+    unsigned int display_on_delay;
 }DSI_Config_t;
 
 typedef struct {
-- 
2.19.0

