From f0ea6f4cb2bf28f8338045d29ed58b22e23f44a0 Mon Sep 17 00:00:00 2001
From: Jerry Cao <jerry.cao@amlogic.com>
Date: Thu, 1 May 2014 10:56:54 -0700
Subject: [PATCH 3981/5965] [TrustZone] meson6 TrustZone support

This is a squash commit of the following changes to enable TrustZone support
for meson6:

    * Enable suspend with TrustZone

      9e127e8bb154de3882642dc31a0f49dd5aaa1d43

    * Fix CPU1 hotplug failure

      d8f48ad6267353516ecc1985b0eec442606149f6

    * meson6 TrustZone support

      23f0412c3a778356d21452621b373c58f571292c
      8120e378b3e0f351448868aac41b7857611d5aaf
---
 arch/arm/configs/meson6_tee_defconfig         | 380 ++++++++++++++++++
 arch/arm/mach-meson6/Kconfig                  |   6 +
 arch/arm/mach-meson6/Makefile                 |   6 +
 arch/arm/mach-meson6/clock.c                  |  66 ++-
 arch/arm/mach-meson6/hotplug.c                |  12 +
 .../mach-meson6/include/mach/meson-secure.h   | 120 ++++++
 arch/arm/mach-meson6/meson-secure.c           | 184 +++++++++
 arch/arm/mach-meson6/meson-smc.S              | 150 +++++++
 arch/arm/mach-meson6/pm.c                     |  17 +
 arch/arm/mach-meson6/power_suspend.c          |  20 +
 arch/arm/mach-meson6/smp.c                    |  18 +-
 drivers/amlogic/input/keyboard/key_input.c    |  34 +-
 drivers/amlogic/rtc/aml_rtc.c                 |   6 +
 13 files changed, 993 insertions(+), 26 deletions(-)
 create mode 100755 arch/arm/configs/meson6_tee_defconfig
 mode change 100644 => 100755 arch/arm/mach-meson6/hotplug.c
 create mode 100755 arch/arm/mach-meson6/include/mach/meson-secure.h
 create mode 100755 arch/arm/mach-meson6/meson-secure.c
 create mode 100755 arch/arm/mach-meson6/meson-smc.S
 mode change 100644 => 100755 arch/arm/mach-meson6/smp.c

diff --git a/arch/arm/configs/meson6_tee_defconfig b/arch/arm/configs/meson6_tee_defconfig
new file mode 100755
index 000000000000..9c4678391977
--- /dev/null
+++ b/arch/arm/configs/meson6_tee_defconfig
@@ -0,0 +1,380 @@
+CONFIG_KERNEL_LZMA=y
+CONFIG_SYSVIPC=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=n
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_ARCH_MESON6=y
+CONFIG_MESON_SUSPEND=y
+CONFIG_MESON_LEGACY_REGISTER_API=y
+CONFIG_ARM_ERRATA_751472=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=2
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_AMLOGIC_MESON_CPUFREQ=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+CONFIG_WAKELOCK=y
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_INET_ESP=y
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_NF_NAT_IPV4=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_NF_NAT_IPV6=y
+CONFIG_IP6_NF_TARGET_MASQUERADE=y
+CONFIG_IP6_NF_TARGET_NPT=y
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+CONFIG_VSYNC_RDMA=y
+CONFIG_AM_VIDEO=y
+CONFIG_AM_TV_OUTPUT2=y
+CONFIG_FB_AM=y
+CONFIG_FB_OSD2_CURSOR=y
+CONFIG_FB_OSD2_DEFAULT_WIDTH=32
+CONFIG_FB_OSD2_DEFAULT_HEIGHT=32
+CONFIG_FB_OSD2_DEFAULT_WIDTH_VIRTUAL=32
+CONFIG_FB_OSD2_DEFAULT_HEIGHT_VIRTUAL=32
+CONFIG_AM_FB_EXT=y
+CONFIG_AM_GE2D=y
+CONFIG_AM_LOGO=y
+CONFIG_PHONET=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+CONFIG_EARLY_INIT=y
+CONFIG_I2C_AML=y
+CONFIG_SARADC_AM=y
+CONFIG_AM_REMOTE=y
+# CONFIG_MESON_NEW_INPUT_REMOTE is not set
+CONFIG_ADC_KEYPADS_AM=y
+CONFIG_KEY_INPUT_CUSTOM_AM=y
+CONFIG_MESON_INPUT_TOUCHSCREEN=y
+CONFIG_FOCALTECH_CAPACITIVE_TOUCHSCREEN=y
+CONFIG_GOODIX_GT81XX_CAPACITIVE_TOUCHSCREEN=y
+CONFIG_GSLX680_CAPACITIVE_TOUCHSCREEN=y
+CONFIG_GOODIX_GT9XX_CAPACITIVE_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_CT36X=y
+CONFIG_EFUSE=y
+CONFIG_AMLOGIC_USB=y
+CONFIG_MMC_AML=y
+CONFIG_AMLOGIC_SPI_NOR=y
+CONFIG_AML_NAND_KEY=y
+CONFIG_SECURITYKEY=y
+# CONFIG_AML_NFTL is not set
+CONFIG_AML_NEXT_GEN_NAND=y
+CONFIG_AM_NAND=n
+CONFIG_AML_NFTL_NEW=m
+CONFIG_AM_ETHERNET=y
+CONFIG_AML_IP101_PHY=y
+#CONFIG_AML_PHY=y
+CONFIG_AML_KSZ8091=y
+CONFIG_AML_LAN8720=y
+CONFIG_AM_WIFI=y
+CONFIG_AM_WIFI_SD_MMC=y
+CONFIG_AM_WIFI_USB=y
+CONFIG_SDIO_DHD_CDC_WIFI_40181_MODULE=m
+CONFIG_BCMDHD_POWER_OFF_IN_SUSPEND=y
+CONFIG_WIRELESS=y
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_MAC80211_HAS_RC=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+CONFIG_RTL8188EU=m
+CONFIG_RTL8192CU=m
+# CONFIG_CRYPTO_AML_HW_CRYPRO is not set
+# CONFIG_CRYPTO_DEVICE_DRIVER is not set
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_PROC_DEVICETREE=y
+CONFIG_OF_SELFTEST=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_TUN=y
+CONFIG_PHYLIB=y
+#CONFIG_SMSC_PHY=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+# CONFIG_WLAN is not set
+CONFIG_USB_USBNET=y
+CONFIG_DEINTERLACE=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SND_AML_SOC=y
+CONFIG_SND_AML_M6_SOC=y
+CONFIG_SND_AML_M_DUMMY_CODEC=y
+CONFIG_SND_AML_M6_WM8960=y
+CONFIG_SND_AML_M6_RT5631=y
+CONFIG_UHID=y
+CONFIG_USB=y
+CONFIG_USB_ACM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DWC_OTG=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_MMC_DEBUG=y
+CONFIG_UIO=y
+CONFIG_UIO_PDRV=y
+CONFIG_UIO_PDRV_GENIRQ=y
+CONFIG_STAGING=y
+CONFIG_ZSMALLOC=y
+CONFIG_ZRAM=y
+CONFIG_ZRAM_DEBUG=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_INTF_ALARM_DEV=y
+CONFIG_SYNC=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_EXT4_DEBUG=y
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
+CONFIG_FUSE_FS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_CRAMFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_READABLE_ASM=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_SECTION_MISMATCH=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_INFO=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_SECURITY_SELINUX=y
+# CONFIG_FTRACE is not set
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC7=y
+CONFIG_AVERAGE=y
+CONFIG_AMLOGIC_BOARD_HAS_PMU=y
+CONFIG_AW_AXP=y
+CONFIG_AW_AXP20=y
+CONFIG_AML_PMU=y
+CONFIG_AML1212=y
+CONFIG_RICOH_PMU=y
+CONFIG_RN5T618=y
+CONFIG_SENSOR_DEVICES=y
+CONFIG_GRAVITY_BMA250=y
+CONFIG_GRAVITY_BMA222=y
+CONFIG_GRAVITY_MMA7660=y
+CONFIG_GRAVITY_LIS3DH=y
+CONFIG_GRAVITY_MMA8452=y
+CONFIG_GRAVITY_MC32X0=y
+CONFIG_GRAVITY_DMARD06=y
+CONFIG_GRAVITY_MMA865X=y
+CONFIG_GRAVITY_STK8312=y
+CONFIG_GRAVITY_LSM303D=y
+CONFIG_GRAVITY_DMARD10=y
+CONFIG_GRAVITY_KXTJ9=y
+CONFIG_GRAVITY_MM3A310=y
+CONFIG_GRAVITY_MXC622X=y
+CONFIG_LIGHT_CM36283=y
+CONFIG_LIGHT_CM3232=y
+CONFIG_LIGHT_CM3217=y
+CONFIG_LIGHT_LTR501=y
+CONFIG_LIGHT_EPL6814=y
+CONFIG_LIGHT_STK220X=y
+CONFIG_LIGHT_LTR558=y
+CONFIG_LIGHT_ISL29023=y
+CONFIG_POST_PROCESS_MANAGER=y
+CONFIG_POST_PROCESS_MANAGER_PPSCALER=y
+CONFIG_AML_AUDIO_DSP=y
+CONFIG_AMAUDIO=y
+CONFIG_BT_DEVICE=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_TVIN=y
+CONFIG_TVIN_VDIN=y
+# CONFIG_TVIN_CSI is not set
+CONFIG_VIDEO_AMLOGIC_CAPTURE=y
+CONFIG_AMLOGIC_CAPTURE_FRAME_ROTATE=y
+CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0308=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_GC0328=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_GC2035=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_GT2005=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_OV5640=y
+CONFIG_VIDEO_AMLOGIC_CAPTURE_HI253=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_V4L_AMLOGIC_VIDEO=y
+CONFIG_V4L_AMLOGIC_VIDEO2=y
+CONFIG_AMLOGIC_IONVIDEO=y
+CONFIG_PREEMPT=y
+CONFIG_AML_DVFS=y
+CONFIG_MESON_CS_DCDC_REGULATOR=y
+CONFIG_AML_PMU_ALGORITHM_SUPPORT=m
+CONFIG_AM_HDMI_ONLY=y
+CONFIG_PM_RUNTIME=y
+CONFIG_MESON_TRUSTZONE=y
diff --git a/arch/arm/mach-meson6/Kconfig b/arch/arm/mach-meson6/Kconfig
index 5dc8f71cda9e..417ef6f69f91 100644
--- a/arch/arm/mach-meson6/Kconfig
+++ b/arch/arm/mach-meson6/Kconfig
@@ -90,6 +90,12 @@ config MESON_SUSPEND_FIRMWARE_BASE
         depends on MESON_SUSPEND
         help
           The base address of 1MB of memory reserved for suspend firmware.
+
+config MESON_TRUSTZONE
+	bool "Enable ARM Trustzone secure extension"
+	default n
+	help
+		Enable ARM Trustzone secure extension
 		
 endif # ARCH_MESON36
 
diff --git a/arch/arm/mach-meson6/Makefile b/arch/arm/mach-meson6/Makefile
index 5c84b118b621..6456ea2ee4c5 100644
--- a/arch/arm/mach-meson6/Makefile
+++ b/arch/arm/mach-meson6/Makefile
@@ -42,3 +42,9 @@ obj-$(CONFIG_CPU_IDLE) += cpuidle.o
 
 obj-$(CONFIG_AML_HDMI_TX) +=  hdmi_tx_hw/
 
+# ARM Trustzone
+obj-$(CONFIG_MESON_TRUSTZONE) += meson-smc.o meson-secure.o
+ifeq ($(CONFIG_MESON_TRUSTZONE),y)
+plus_sec                      := $(call as-instr,.arch_extension sec,+sec)
+AFLAGS_meson-smc.o            := -Wa,-march=armv7-a$(plus_sec)
+endif
diff --git a/arch/arm/mach-meson6/clock.c b/arch/arm/mach-meson6/clock.c
index d70485125575..740a4cfc6741 100755
--- a/arch/arm/mach-meson6/clock.c
+++ b/arch/arm/mach-meson6/clock.c
@@ -43,6 +43,10 @@
 #include <mach/clk_set.h>
 //#include <mach/power_gate.h>
 
+#ifdef CONFIG_MESON_TRUSTZONE
+#include <mach/meson-secure.h>
+#endif
+
 static DEFINE_SPINLOCK(mali_clk_lock);
 static DEFINE_SPINLOCK(clockfw_lock);
 static DEFINE_MUTEX(clock_ops_lock);
@@ -1260,12 +1264,55 @@ struct clk_change_info{
 #define MESON_CPU_SLEEP		1
 #define MESON_CPU_WAKEUP	2
 
+inline uint32_t meson_get_cpu_ctrl_reg(void)
+{
+	uint32_t ret = 0;
+
+	spin_lock(&clockfw_lock);
+#ifdef CONFIG_MESON_TRUSTZONE
+	ret = meson_read_corectrl();
+#else
+	ret = aml_read_reg32(MESON_CPU_CONTROL_REG);
+#endif
+	spin_unlock(&clockfw_lock);
+
+	return ret;
+}
+
+
 void meson_set_cpu_ctrl_reg(int value)
 {
 	spin_lock(&clockfw_lock);
+#ifdef CONFIG_MESON_TRUSTZONE
+	meson_modify_corectrl(value);
+#else
 	aml_write_reg32(MESON_CPU_CONTROL_REG, value);
+#endif
 	spin_unlock(&clockfw_lock);
 }
+
+inline uint32_t meson_get_cpu_status_reg(int cpu)
+{
+    uint32_t ret;
+
+#ifdef CONFIG_MESON_TRUSTZONE
+	ret = meson_read_corestatus(cpu);
+#else
+	ret = aml_read_reg32(MESON_CPU_STATUS_REG(cpu));
+#endif
+
+    return ret;
+}
+
+inline void meson_set_cpu_status_reg(int cpu, int value)
+{
+#ifdef CONFIG_MESON_TRUSTZONE
+	meson_modify_corestatus(cpu, value);
+#else
+	aml_write_reg32(MESON_CPU_STATUS_REG(cpu), value);
+#endif
+}
+
 #if 0
 static unsigned long cpu_sleep_max_count = 0;
 static unsigned long cpu_wait_max_count = 0;
@@ -1282,8 +1329,7 @@ static inline unsigned long meson_smp_wait_others(unsigned status)
 	do {
 		__asm__ __volatile__ ("wfe" : : : "memory");
 		for_each_online_cpu(cpu) {
-
-			if (cpu != my && MESON_CPU_STATUS(cpu) == status) {
+			if (cpu != my && meson_get_cpu_status_reg(cpu) == status) {
 				count++;
 				mask &= ~(1 << cpu);
 			}
@@ -1298,7 +1344,7 @@ static inline void meson_smp_init_transaction(void)
 {
     int cpu;
 
-    aml_write_reg32(MESON_CPU_CONTROL_REG, 0);
+    meson_set_cpu_ctrl_reg(0);
 
     for_each_online_cpu(cpu) {
         aml_write_reg32(MESON_CPU_STATUS_REG(cpu), 0);
@@ -1312,18 +1358,18 @@ static void smp_a9_clk_change(struct clk_change_info * info)
     unsigned long count = 0;
     if (cpu != info->cpu) {
         unsigned long flags;
-        MESON_CPU_SET_STATUS(MESON_CPU_SLEEP);
+        meson_set_cpu_status_reg(cpu, MESON_CPU_SLEEP);
         pr_debug("CPU%u: Hey CPU %d, I am going to sleep\n", cpu, info->cpu);
         smp_wmb();
-	dsb_sev();
-	local_irq_save(flags);
-        while ((aml_read_reg32(MESON_CPU_CONTROL_REG) & (1 << cpu)) == 0) {
+        dsb_sev();
+        local_irq_save(flags);
+        while ((meson_get_cpu_ctrl_reg() & (1 << cpu)) == 0) {
 		count++;
 
             __asm__ __volatile__ ("wfe" : : : "memory");
         }
         local_irq_restore(flags);
-        MESON_CPU_SET_STATUS(MESON_CPU_WAKEUP);
+        meson_set_cpu_status_reg(cpu, MESON_CPU_WAKEUP);
 
         if (count > cpu_sleep_max_count) cpu_sleep_max_count = count;
 
@@ -1342,7 +1388,7 @@ static void smp_a9_clk_change(struct clk_change_info * info)
         pr_debug("CPU%u: All other CPU in sleep (%lu %lu)\n", cpu, count, cpu_wait_max_count);
 
         info->err = _clk_set_rate_cpu(info->clk, info->rate, 0);
-        aml_write_reg32(MESON_CPU_CONTROL_REG, 0xf);
+        meson_set_cpu_ctrl_reg(0xf);
         smp_wmb();
         dsb_sev();
     }
@@ -1386,7 +1432,7 @@ static int clk_set_rate_a9(struct clk *clk, unsigned long rate)
 	}		
 #ifdef CONFIG_SMP
 #if USE_ON_EACH_CPU
-	if (aml_read_reg32(MESON_CPU_CONTROL_REG)) {
+	if (meson_get_cpu_ctrl_reg()) {
 #else
 	if (num_online_cpus()>1) {
 #endif
diff --git a/arch/arm/mach-meson6/hotplug.c b/arch/arm/mach-meson6/hotplug.c
old mode 100644
new mode 100755
index c31188d4d9f1..203b2328f0c4
--- a/arch/arm/mach-meson6/hotplug.c
+++ b/arch/arm/mach-meson6/hotplug.c
@@ -14,6 +14,9 @@
 #include <asm/cacheflush.h>
 #include <asm/mach-types.h>
 #include "common.h"
+#ifdef CONFIG_MESON_TRUSTZONE
+#include <mach/meson-secure.h>
+#endif
 int meson_cpu_kill(unsigned int cpu)
 {
 	return 1;
@@ -32,6 +35,14 @@ void meson_cpu_die(unsigned int cpu)
 	dsb();
 	dmb();
 
+#ifdef CONFIG_MESON_TRUSTZONE
+	meson_smc1(TRUSTZONE_MON_CORE_OFF, 1);
+#ifdef CONFIG_MESON6_SMP_HOTPLUG
+extern  void v7_invalidate_dcache_all(void);
+		v7_invalidate_dcache_all();
+#endif
+
+#else
 	for (;;) {
 		/*
 		 * Execute WFI
@@ -58,6 +69,7 @@ void meson_cpu_die(unsigned int cpu)
 		}
 		pr_debug("CPU%u: spurious wakeup call\n", cpu);
 	}
+#endif
 }
 
 int meson_cpu_disable(unsigned int cpu)
diff --git a/arch/arm/mach-meson6/include/mach/meson-secure.h b/arch/arm/mach-meson6/include/mach/meson-secure.h
new file mode 100755
index 000000000000..7219339a1928
--- /dev/null
+++ b/arch/arm/mach-meson6/include/mach/meson-secure.h
@@ -0,0 +1,120 @@
+/*
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Secure Definition
+ *
+ * Copyright (C) 2013 Amlogic, Inc.
+ *
+ * Author: Platform-SH@amlogic.com
+ *
+ */
+
+#ifndef MESON_ARCH_MESON_SECURE_H
+#define MESON_ARCH_MESON_SECURE_H
+
+/* Meson Secure Monitor/HAL APIs */
+#define CALL_TRUSTZONE_API                      0x1
+#define CALL_TRUSTZONE_MON                      0x4
+#define CALL_TRUSTZONE_HAL_API                  0x5
+
+/* Secure Monitor mode APIs */
+#define TRUSTZONE_MON_TYPE_MASK                 0xF00
+#define TRUSTZONE_MON_FUNC_MASK                 0x0FF
+#define TRUSTZONE_MON_L2X0                      0x100
+#define TRUSTZONE_MON_L2X0_CTRL_INDEX           0x101
+#define TRUSTZONE_MON_L2X0_AUXCTRL_INDEX        0x102
+#define TRUSTZONE_MON_L2X0_PREFETCH_INDEX       0x103
+#define TRUSTZONE_MON_L2X0_TAGLATENCY_INDEX     0x104
+#define TRUSTZONE_MON_L2X0_DATALATENCY_INDEX    0x105
+#define TRUSTZONE_MON_L2X0_FILTERSTART_INDEX    0x106
+#define TRUSTZONE_MON_L2X0_FILTEREND_INDEX      0x107
+#define TRUSTZONE_MON_L2X0_DEBUG_INDEX          0x108
+#define TRUSTZONE_MON_L2X0_POWER_INDEX          0x109
+
+#define TRUSTZONE_MON_CORE                      0x200
+#define TRUSTZONE_MON_CORE_RD_CTRL_INDEX        0x201
+#define TRUSTZONE_MON_CORE_WR_CTRL_INDEX        0x202
+#define TRUSTZONE_MON_CORE_RD_STATUS0_INDEX     0x203
+#define TRUSTZONE_MON_CORE_WR_STATUS0_INDEX     0x204
+#define TRUSTZONE_MON_CORE_RD_STATUS1_INDEX     0x205
+#define TRUSTZONE_MON_CORE_WR_STATUS1_INDEX     0x206
+#define TRUSTZONE_MON_CORE_BOOTADDR_INDEX       0x207
+#define TRUSTZONE_MON_CORE_DDR_INDEX            0x208
+#define TRUSTZONE_MON_CORE_RD_SOC_REV1          0x209
+#define TRUSTZONE_MON_CORE_RD_SOC_REV2          0x20A
+#define TRUSTZONE_MON_CORE_OFF 			0x20B
+
+#define TRUSTZONE_MON_SUSPNED_FIRMWARE          0x300
+#define TRUSTZONE_MON_SAVE_CPU_GIC              0x400
+
+#define TRUSTZONE_MON_RTC                       0x500
+#define TRUSTZONE_MON_RTC_RD_REG_INDEX          0x501
+#define TRUSTZONE_MON_RTC_WR_REG_INDEX          0x502
+
+/* Secure HAL APIs*/
+#define TRUSTZONE_HAL_API_EFUSE                 0x100
+#define TRUSTZONE_HAL_API_STORAGE               0x200
+#define TRUSTZONE_HAL_API_MEMCONFIG             0x300
+
+#define MESON_TRUSTZONE_MEM_START               0x85100000
+#define MESON_TRUSTZONE_MEM_SIZE                0x04000000
+
+
+#ifndef __ASSEMBLER__
+extern void meson_smc1(u32 fn, u32 arg);
+extern int meson_smc_hal_api(u32 cmdidx, u32 arg);
+extern int meson_smc2(u32 arg);
+extern int meson_smc3(u32 arg1, u32 arg2);
+extern u32 meson_read_corectrl(void);
+extern u32 meson_modify_corectrl(u32 arg);
+extern u32 meson_read_corestatus(u32 cpu);
+extern u32 meson_modify_corestatus(u32 cpu, u32 arg);
+extern void meson_auxcoreboot_addr(u32 arg);
+extern void meson_suspend_firmware(void);
+extern uint32_t meson_secure_reg_read(uint32_t addr);
+extern uint32_t meson_secure_reg_write(uint32_t addr, uint32_t val);
+extern u32 meson_read_socrev1(void);
+extern u32 meson_read_socrev2(void);
+extern uint32_t meson_secure_mem_size(void);
+extern uint32_t meson_secure_mem_end(void);
+
+// efuse HAL_API arg
+struct efuse_hal_api_arg{
+	unsigned int cmd;		// R/W
+	unsigned int offset;
+	unsigned int size;
+	unsigned int buffer_phy;
+	unsigned int retcnt_phy;	
+};
+#define EFUSE_HAL_API_READ	0
+#define EFUSE_HAL_API_WRITE 1
+extern int meson_trustzone_efuse(struct efuse_hal_api_arg* arg);
+
+
+//memconfig HAL_API arg
+struct memconfig{
+	unsigned char name[64];
+	unsigned int start_phy_addr;
+	unsigned int end_phy_addr;
+};
+struct memconfig_hal_api_arg{
+	unsigned int memconfigbuf_phy_addr;
+	unsigned int memconfigbuf_count;
+};
+#define MEMCONFIG_NUM	2
+extern int meson_trustzone_memconfig(void);
+extern unsigned int meson_trustzone_getmemsecure_size(void);
+extern int meson_trustzone_getmemconfig(unsigned char* name, unsigned int* startphyaddr, unsigned int* endphyaddr);
+
+#endif
+
+
+#endif
diff --git a/arch/arm/mach-meson6/meson-secure.c b/arch/arm/mach-meson6/meson-secure.c
new file mode 100755
index 000000000000..3ea6dc27568d
--- /dev/null
+++ b/arch/arm/mach-meson6/meson-secure.c
@@ -0,0 +1,184 @@
+/*
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Meson secure APIs.
+ *
+ * Copyright (C) 2013 Amlogic, Inc.
+ *
+ * Author: Platform-SH@amlogic.com
+ *         Platform-BJ@amlogic.com
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <plat/io.h>
+#include <plat/regops.h>
+#include <linux/printk.h>
+#include <linux/string.h>
+#include <asm/cacheflush.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <linux/dma-mapping.h>
+#include <mach/io.h>
+
+#include <mach/meson-secure.h>
+#include <linux/sched.h>
+
+#define MESON_SECURE_DEBUG 0
+#if MESON_SECURE_DEBUG
+#define TZDBG(fmt, args...) printk("meson-secure: " fmt, ## args);
+#else
+#define TZDBG(fmt, args...)
+#endif
+
+/*
+int meson_secure_memblock(unsigned startaddr, unsigned endaddr, struct secure_memblock_ctrl* pctrl)
+{
+	int ret;
+	struct secure_memblock_info memblock_info;
+
+	if(!pctrl)
+		return -1;
+	if(((startaddr & 0xffff) != 0) || ((endaddr&0xffff)!=0xffff)){
+		printk("secure memory block must be 16 bits align!\n");
+		return -1;
+	}
+
+	memblock_info.startaddr = startaddr;
+	memblock_info.endaddr = endaddr;
+	memcpy(&(memblock_info.memblock_ctrl), pctrl, sizeof(memblock_info.memblock_ctrl));
+	__cpuc_flush_dcache_area((void*)&memblock_info, sizeof(memblock_info));
+	outer_clean_range(__pa(&memblock_info), __pa(&memblock_info+1));
+
+	ret = meson_smc_internal_api(INTERNAL_API_MEMBLOCK_CONFIG, __pa(&memblock_info));
+	return ret;
+}
+*/
+
+struct memconfig memsecure[MEMCONFIG_NUM] = {0};
+int meson_trustzone_memconfig(void)
+{
+	int ret;
+	struct memconfig_hal_api_arg arg;
+	arg.memconfigbuf_phy_addr = __pa(memsecure);
+	arg.memconfigbuf_count = MEMCONFIG_NUM;
+
+	__cpuc_flush_dcache_area(memsecure, sizeof(memsecure));
+	outer_clean_range(__pa(memsecure), (__pa(memsecure + MEMCONFIG_NUM)));
+	__cpuc_flush_dcache_area(&arg, sizeof(arg));
+	outer_clean_range(__pa(&arg), __pa(((struct memconfig_hal_api_arg*)&arg)) + 1);
+
+	ret = meson_smc_hal_api(TRUSTZONE_HAL_API_MEMCONFIG, __pa(&arg));
+
+	outer_inv_range(__pa(&arg), __pa(((struct memconfig_hal_api_arg*)&arg)) + 1);
+	dmac_unmap_area(&arg, sizeof(arg), DMA_FROM_DEVICE);
+	outer_inv_range(__pa(memsecure), __pa(memsecure + MEMCONFIG_NUM));
+	dmac_unmap_area(memsecure, sizeof(memsecure), DMA_FROM_DEVICE);
+
+	return ret;
+}
+
+unsigned int meson_trustzone_getmemsecure_size(void)
+{
+	unsigned int size = 0;
+	int i;
+	for (i = 0; i < MEMCONFIG_NUM; i++) {
+		if ((memsecure[i].start_phy_addr != 0) && (memsecure[i].end_phy_addr != 0)) {
+			size += memsecure[i].end_phy_addr - memsecure[i].start_phy_addr + 1;
+		}
+	}
+	return size;
+}
+
+int meson_trustzone_getmemconfig(unsigned char* name, unsigned int* startphyaddr, unsigned int* endphyaddr)
+{
+	unsigned int i;
+	for (i = 0; i < MEMCONFIG_NUM; i++) {
+		if (strcmp(name, memsecure[i].name) == 0) {
+			break;
+		}
+	}
+	if (i == MEMCONFIG_NUM) {
+		return -1;
+	}
+	if ((memsecure[i].start_phy_addr == 0) || (memsecure[i].end_phy_addr == 0)) {
+		return -1;
+	}
+
+	*startphyaddr = memsecure[i].start_phy_addr;
+	*endphyaddr = memsecure[i].end_phy_addr;
+	return 0;
+}
+
+int meson_trustzone_efuse(struct efuse_hal_api_arg* arg)
+{
+	int ret;
+	if (!arg) {
+		return -1;
+	}
+	set_cpus_allowed_ptr(current, cpumask_of(0));
+	__cpuc_flush_dcache_area(__va(arg->buffer_phy), arg->size);
+	outer_clean_range((arg->buffer_phy), (arg->buffer_phy + arg->size));
+
+	__cpuc_flush_dcache_area(__va(arg->retcnt_phy), sizeof(unsigned int));
+	outer_clean_range(arg->retcnt_phy, (arg->retcnt_phy + sizeof(unsigned int)));
+
+	__cpuc_flush_dcache_area((void*)arg, sizeof(struct efuse_hal_api_arg));
+	outer_clean_range(__pa(arg), __pa(arg + 1));
+
+	ret = meson_smc_hal_api(TRUSTZONE_HAL_API_EFUSE, __pa(arg));
+
+	if (arg->cmd == EFUSE_HAL_API_READ) {
+		outer_inv_range((arg->buffer_phy), (arg->buffer_phy + arg->size));
+		dmac_unmap_area(__va(arg->buffer_phy), arg->size, DMA_FROM_DEVICE);
+	}
+	outer_inv_range((arg->retcnt_phy), (arg->retcnt_phy + sizeof(unsigned int)));
+	dmac_unmap_area(__va(arg->buffer_phy), arg->size, DMA_FROM_DEVICE);
+
+	return ret;
+}
+
+uint32_t meson_secure_reg_read(uint32_t addr)
+{
+	uint32_t ret;
+	uint32_t paddr;
+	int offset;
+
+	offset = IO_SECBUS_PHY_BASE - IO_SECBUS_BASE;
+	paddr = addr + offset;
+	ret = meson_smc2(paddr);
+
+	return ret;
+}
+
+uint32_t meson_secure_reg_write(uint32_t addr, uint32_t val)
+{
+	uint32_t ret;
+	uint32_t paddr;
+	int offset;
+
+	offset = IO_SECBUS_PHY_BASE - IO_SECBUS_BASE;
+	paddr = addr + offset;
+	ret = meson_smc3(paddr, val);
+
+	return ret;
+}
+
+uint32_t meson_secure_mem_size(void)
+{
+	return MESON_TRUSTZONE_MEM_SIZE;
+}
+
+uint32_t meson_secure_mem_end(void)
+{
+	return (MESON_TRUSTZONE_MEM_START + MESON_TRUSTZONE_MEM_SIZE);
+}
diff --git a/arch/arm/mach-meson6/meson-smc.S b/arch/arm/mach-meson6/meson-smc.S
new file mode 100755
index 000000000000..82e6806ff82b
--- /dev/null
+++ b/arch/arm/mach-meson6/meson-smc.S
@@ -0,0 +1,150 @@
+/*
+ * Meson secure APIs file.
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software,you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Secure Definition
+ *
+ * Copyright (C) 2013 Amlogic, Inc.
+ *
+ * Author: Platform-BJ@amlogic.com
+ *
+ */
+
+#include <linux/linkage.h>
+#include <mach/meson-secure.h>
+
+/*
+ * This is common routine to manage secure monitor API
+ * used to modify the PL310 secure registers.
+ * 'r1' contains the value to be modified and 'r0' contains
+ * the monitor API number. It uses few CPU registers
+ * internally and hence they need be backed up including
+ * link register "lr".
+ * Function signature : void meson_smc1(u32 fn, u32 arg)
+ */
+
+ENTRY(meson_smc1)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r1
+    mov r1, r0
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_smc1)
+
+ENTRY(meson_smc_hal_api)
+	stmfd sp!, {r3-r12, lr}	
+	mov r2, r1
+	mov r1, r0
+	ldr r0, =CALL_TRUSTZONE_HAL_API
+	dsb
+	smc #0
+	ldmfd sp!, {r3-r12, pc}
+ENDPROC(meson_smc_hal_api)
+
+ENTRY(meson_smc2)
+    stmfd sp!, {r2-r12, lr}
+    mov r1, r0
+    ldr r0, =0x2
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_smc2)
+
+ENTRY(meson_smc3)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r1
+    mov r1, r0
+    ldr r0, =0x3
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_smc3)
+
+ENTRY(meson_read_corectrl)
+    stmfd sp!, {r2-r12, lr}
+    ldr r1, =TRUSTZONE_MON_CORE_RD_CTRL_INDEX
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_read_corectrl)
+
+ENTRY(meson_modify_corectrl)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r0
+    ldr r1, =TRUSTZONE_MON_CORE_WR_CTRL_INDEX
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_modify_corectrl)
+
+ENTRY(meson_read_corestatus)
+    stmfd sp!, {r2-r12, lr}
+    ldr r1, =TRUSTZONE_MON_CORE_RD_STATUS0_INDEX
+    add r1, r1, r0, lsl #1
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_read_corestatus)
+
+ENTRY(meson_modify_corestatus)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r1
+    ldr r1, =TRUSTZONE_MON_CORE_WR_STATUS0_INDEX
+    add r1, r1, r0, lsl #1
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_modify_corestatus)
+
+ENTRY(meson_auxcoreboot_addr)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r0
+    ldr r1, =TRUSTZONE_MON_CORE_BOOTADDR_INDEX
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_auxcoreboot_addr)
+
+ENTRY(meson_suspend_firmware)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r0
+    ldr r1, =TRUSTZONE_MON_SUSPNED_FIRMWARE
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_suspend_firmware)
+
+ENTRY(meson_read_socrev1)
+    stmfd sp!, {r2-r12, lr}    
+    ldr r1, =TRUSTZONE_MON_CORE_RD_SOC_REV1
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_read_socrev1)
+
+ENTRY(meson_read_socrev2)
+    stmfd sp!, {r2-r12, lr}    
+    ldr r1, =TRUSTZONE_MON_CORE_RD_SOC_REV2
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_read_socrev2)
diff --git a/arch/arm/mach-meson6/pm.c b/arch/arm/mach-meson6/pm.c
index ae6c3b9cc089..2c08ec1757e7 100755
--- a/arch/arm/mach-meson6/pm.c
+++ b/arch/arm/mach-meson6/pm.c
@@ -47,6 +47,12 @@ static struct early_suspend early_suspend;
 static int early_suspend_flag = 0;
 #endif
 
+#ifdef CONFIG_MESON_TRUSTZONE
+#include <mach/meson-secure.h>
+#define WR_RTC(addr, data)         meson_secure_reg_write((P_##addr), data)
+#define RD_RTC(addr)               meson_secure_reg_read(P_##addr)
+#endif
+
 #define ON  1
 #define OFF 0
 
@@ -913,6 +919,16 @@ static void meson_pm_suspend(void)
         WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0x12345678);
     }
     // clear RTC interrupt
+#ifdef CONFIG_MESON_TRUSTZONE
+	WR_RTC(AO_RTC_ADDR1, RD_RTC(AO_RTC_ADDR1)|(0xf000));
+	printk(KERN_INFO "RTCADD3=0x%x\n",RD_RTC(AO_RTC_ADDR3));
+	if(RD_RTC(AO_RTC_ADDR3)|(1<<29))
+	{
+		WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3)&(~(1<<29)));
+		udelay(1000);
+	}
+	printk(KERN_INFO "RTCADD3=0x%x\n",RD_RTC(AO_RTC_ADDR3));
+#else
     *(volatile unsigned *)(P_AO_RTC_ADDR1)=(*(volatile unsigned *)(P_AO_RTC_ADDR1))|(0xf000);
 	printk(KERN_INFO "RTCADD3=0x%x\n",*(volatile unsigned *)(P_AO_RTC_ADDR3));
 	if((*(volatile unsigned *)(P_AO_RTC_ADDR3))|(1<<29))
@@ -921,6 +937,7 @@ static void meson_pm_suspend(void)
 		udelay(1000);
 	}
 	printk(KERN_INFO "RTCADD3=0x%x\n",*(volatile unsigned *)P_AO_RTC_ADDR3);
+#endif
 
     if (pdata->set_vccx2) {
         pdata->set_vccx2(ON);
diff --git a/arch/arm/mach-meson6/power_suspend.c b/arch/arm/mach-meson6/power_suspend.c
index 00cb721cb46a..ab7f88c3f6d3 100755
--- a/arch/arm/mach-meson6/power_suspend.c
+++ b/arch/arm/mach-meson6/power_suspend.c
@@ -67,7 +67,26 @@ void reset_watchdog(void)
 #endif /* CONFIG_HARDWARE_WATCHDOG */
 #endif
 
+#ifdef CONFIG_MESON_TRUSTZONE
+#include <mach/meson-secure.h>
+#endif
 
+#ifdef CONFIG_MESON_TRUSTZONE
+int meson_power_suspend(void)
+{
+	static int test_flag = 0;
+	unsigned addr;
+	unsigned p_addr;
+	void (*pwrtest_entry)(unsigned,unsigned,unsigned,unsigned);
+
+	addr = 0x9FF04400;//entry.s start
+	p_addr = (unsigned)__phys_to_virt(addr);
+	meson_suspend_firmware();
+	printk("back to normal OS.\n");
+
+	return 0;
+}
+#else
 int meson_power_suspend(void)
 {
 	static int test_flag = 0;
@@ -95,3 +114,4 @@ int meson_power_suspend(void)
 #endif
 	return 0;
 }
+#endif
diff --git a/arch/arm/mach-meson6/smp.c b/arch/arm/mach-meson6/smp.c
old mode 100644
new mode 100755
index a5f3b9969c1e..870bd3c2e37c
--- a/arch/arm/mach-meson6/smp.c
+++ b/arch/arm/mach-meson6/smp.c
@@ -25,6 +25,9 @@
 #include <asm/mach-types.h>
 #include  "common.h"
 
+#ifdef CONFIG_MESON_TRUSTZONE
+#include <mach/meson-secure.h>
+#endif
 
 static DEFINE_SPINLOCK(boot_lock);
 
@@ -77,11 +80,14 @@ static void __init wakeup_secondary(unsigned int cpu)
 	* on secondary core once out of WFE
 	* A barrier is added to ensure that write buffer is drained
 	*/
+#ifdef CONFIG_MESON_TRUSTZONE
+	meson_auxcoreboot_addr((const uint32_t)virt_to_phys(meson_secondary_startup));
+	meson_set_cpu_ctrl_reg((1 << cpu) | 1);
+#else
 	aml_write_reg32((uint32_t)(IO_AHB_BASE + 0x1ff84),
 	    (const uint32_t)virt_to_phys(meson_secondary_startup));
-
-	//aml_write_reg32(IO_AHB_BASE + 0x1ff80, (1 << cpu) | 1);
 	meson_set_cpu_ctrl_reg((1 << cpu) | 1);
+#endif
 
 	smp_wmb();
 	/*
@@ -89,7 +95,7 @@ static void __init wakeup_secondary(unsigned int cpu)
 	 * Drain the outstanding writes to memory
 	 */
 	 mb();
-#ifndef CONFIG_MESON6_SMP_HOTPLUG
+#if (!defined(CONFIG_MESON6_SMP_HOTPLUG)) || defined(CONFIG_MESON_TRUSTZONE)
 	dsb_sev();
 #else
 	gic_raise_softirq(cpumask_of(cpu), 0);
@@ -99,7 +105,9 @@ static void __init wakeup_secondary(unsigned int cpu)
 int __cpuinit meson_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	unsigned long timeout;
+#ifndef CONFIG_MESON_TRUSTZONE
 	wakeup_secondary(1);
+#endif
 	/*
 	* Set synchronisation state between this boot processor
 	* and the secondary one
@@ -112,7 +120,9 @@ int __cpuinit meson_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * that it has been released by resetting pen_release.
 	 */
 	write_pen_release(cpu_logical_map(cpu));
-
+#ifdef CONFIG_MESON_TRUSTZONE
+	wakeup_secondary(1);
+#endif
 	//smp_send_reschedule(cpu);
 
 	timeout = jiffies + (1 * HZ);
diff --git a/drivers/amlogic/input/keyboard/key_input.c b/drivers/amlogic/input/keyboard/key_input.c
index 67e568451442..ab89c46c9094 100755
--- a/drivers/amlogic/input/keyboard/key_input.c
+++ b/drivers/amlogic/input/keyboard/key_input.c
@@ -66,6 +66,16 @@
 #include <plat/io.h>
 #endif
 
+#if (defined(CONFIG_MESON_TRUSTZONE) && defined(CONFIG_ARCH_MESON6))
+#include <mach/meson-secure.h>
+#define AML_RTC_READ(addr)  meson_secure_reg_read(addr)
+#define AML_RTC_WRITE(addr, data) meson_secure_reg_write(addr, data)
+#else
+#define AML_RTC_READ(addr) aml_read_reg32(addr)
+#define AML_RTC_WRITE(addr, data) aml_write_reg32(addr, data)
+#endif
+
+
 //#define AML_KEYINPUT_DBG
 #define AML_KEYINPUT_INTR     0
 #define AML_KEYINPUT_POLLING   2
@@ -219,12 +229,12 @@ extern int aml_rtc_alarm_status(void);
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 static irqreturn_t am_key_interrupt(int irq, void *dev)
 {
-    int newval = (aml_read_reg32(P_AO_RTC_ADDR1)>>2)&1;
+    int newval = (AML_RTC_READ(P_AO_RTC_ADDR1)>>2)&1;
     if (KeyInput->status != newval) {
         KeyInput->status = newval;
         tasklet_schedule(&ki_tasklet);
     }
-    aml_write_reg32(P_AO_RTC_ADDR1, (aml_read_reg32(P_AO_RTC_ADDR1) | (0x0000f000)));
+    AML_RTC_WRITE(P_AO_RTC_ADDR1, (AML_RTC_READ(P_AO_RTC_ADDR1) | (0x0000f000)));
     return IRQ_HANDLED;
 }
 
@@ -239,7 +249,7 @@ static irqreturn_t am_key_interrupt(int irq, void *dev)
      */
 #ifdef CONFIG_AML_RTC
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	if(((aml_read_reg32(P_AO_RTC_ADDR1)>>2)&3) == 0)
+	if(((AML_RTC_READ(P_AO_RTC_ADDR1)>>2)&3) == 0)
 	{
 		alarm = 1;
 	}
@@ -253,20 +263,20 @@ static irqreturn_t am_key_interrupt(int irq, void *dev)
 
 #ifdef CONFIG_MESON_SUSPEND
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-    KeyInput->status = (aml_read_reg32(P_AO_RTC_ADDR1)>>2)&1;
+    KeyInput->status = (AML_RTC_READ(P_AO_RTC_ADDR1)>>2)&1;
     if (READ_AOBUS_REG(AO_RTI_STATUS_REG2)== 0x1234abcd) {
         WRITE_AOBUS_REG(AO_RTI_STATUS_REG2,0);
         if (alarm == 0) {
-            if (((aml_read_reg32(P_AO_RTC_ADDR1)>>2)&1) == 1) {
+            if (((AML_RTC_READ(P_AO_RTC_ADDR1)>>2)&1) == 1) {
                 KeyInput->status = 0;
-                printk(KERN_INFO "Force key down: %x\n",aml_read_reg32(P_AO_RTC_ADDR1));
-                aml_write_reg32(P_AO_RTC_ADDR1, (aml_read_reg32(P_AO_RTC_ADDR1) | (0x0000c000)));
+                printk(KERN_INFO "Force key down: %x\n",AML_RTC_READ(P_AO_RTC_ADDR1));
+                AML_RTC_WRITE(P_AO_RTC_ADDR1, (AML_RTC_READ(P_AO_RTC_ADDR1) | (0x0000c000)));
                 keyinput_tasklet(0);
                 return IRQ_HANDLED;
             }
         }
     }
-    aml_write_reg32(P_AO_RTC_ADDR1, (aml_read_reg32(P_AO_RTC_ADDR1) | (0x0000c000)));
+    AML_RTC_WRITE(P_AO_RTC_ADDR1, (AML_RTC_READ(P_AO_RTC_ADDR1) | (0x0000c000)));
 #else
     KeyInput->status = (READ_AOBUS_REG(AO_RTC_ADDR1)>>2)&1;
     if (READ_AOBUS_REG(AO_RTI_STATUS_REG2)== 0x1234abcd) {
@@ -296,7 +306,7 @@ static irqreturn_t am_key_interrupt(int irq, void *dev)
         }
         else {
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
- 			KeyInput->status = (aml_read_reg32(P_AO_RTC_ADDR1)>>2)&1;
+ 			KeyInput->status = (AML_RTC_READ(P_AO_RTC_ADDR1)>>2)&1;
 #else        	
             KeyInput->status = (READ_AOBUS_REG(AO_RTC_ADDR1)>>2)&1;
 #endif            
@@ -304,7 +314,7 @@ static irqreturn_t am_key_interrupt(int irq, void *dev)
         }
     }
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	aml_write_reg32(P_AO_RTC_ADDR1, (aml_read_reg32(P_AO_RTC_ADDR1) | (0x0000c000)));
+	AML_RTC_WRITE(P_AO_RTC_ADDR1, (AML_RTC_READ(P_AO_RTC_ADDR1) | (0x0000c000)));
 #else    
     WRITE_AOBUS_REG(AO_RTC_ADDR1, (READ_AOBUS_REG(AO_RTC_ADDR1) | (0x0000c000)));
 #endif    
@@ -454,7 +464,7 @@ static int key_input_probe(struct platform_device *pdev)
             goto CATCH_ERR;
         }
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-		aml_write_reg32(P_AO_RTC_ADDR0, (aml_read_reg32(P_AO_RTC_ADDR0) | (0x0000f000)));
+		AML_RTC_WRITE(P_AO_RTC_ADDR0, (AML_RTC_READ(P_AO_RTC_ADDR0) | (0x0000f000)));
 #else        
         WRITE_AOBUS_REG(AO_RTC_ADDR0, (READ_AOBUS_REG(AO_RTC_ADDR0) | (0x0000c000)));
 #endif        
@@ -552,7 +562,7 @@ static int key_input_resume(struct platform_device *dev)
         input_sync(KeyInput->input);
         input_report_key(KeyInput->input, KeyInput->pdata->key_code_list[0], 1);
         input_sync(KeyInput->input);
-		//aml_write_reg32(P_AO_RTC_ADDR0, (aml_read_reg32(P_AO_RTC_ADDR0) | (0x0000f000)));
+		//AML_RTC_WRITE(P_AO_RTC_ADDR0, (AML_RTC_READ(P_AO_RTC_ADDR0) | (0x0000f000)));
 		#ifdef CONFIG_SCREEN_ON_EARLY
 		power_key_pressed = 1;
 		#endif		
diff --git a/drivers/amlogic/rtc/aml_rtc.c b/drivers/amlogic/rtc/aml_rtc.c
index ef0fd6f8523b..b6254ace0cd7 100755
--- a/drivers/amlogic/rtc/aml_rtc.c
+++ b/drivers/amlogic/rtc/aml_rtc.c
@@ -49,8 +49,14 @@ int c_dbg_lvl = 0;
 #define RESET_RETRY_TIMES           	3
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#if (defined(CONFIG_MESON_TRUSTZONE) && defined(CONFIG_ARCH_MESON6))
+#include <mach/meson-secure.h>
+#define WR_RTC(addr, data)         meson_secure_reg_write(P_##addr, data)
+#define RD_RTC(addr)               meson_secure_reg_read(P_##addr)	
+#else
 #define WR_RTC(addr, data)         aml_write_reg32(P_##addr, data)
 #define RD_RTC(addr)               aml_read_reg32(P_##addr)	
+#endif
 #else
 #define WR_RTC(addr, data)         WRITE_AOBUS_REG(addr, data)
 #define RD_RTC(addr)                   READ_AOBUS_REG(addr)
-- 
2.19.0

