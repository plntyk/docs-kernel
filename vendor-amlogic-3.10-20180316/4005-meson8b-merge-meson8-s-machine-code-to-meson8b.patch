From b8df0bae7c88d420121f6466bfc1285ac8aae907 Mon Sep 17 00:00:00 2001
From: Victor Wan <victor.wan@amlogic.com>
Date: Tue, 6 May 2014 18:48:50 +0800
Subject: [PATCH 4005/5965] meson8b: merge meson8's machine code to meson8b

---
 arch/arm/mach-meson8b/Makefile                |   7 +
 arch/arm/mach-meson8b/clock.c                 |  83 +-
 .../mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c  |   1 +
 arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c |  19 +-
 arch/arm/mach-meson8b/include/mach/am_regs.h  |   5 +-
 arch/arm/mach-meson8b/include/mach/audio.h    |  40 +
 arch/arm/mach-meson8b/include/mach/bt656.h    |  50 ++
 .../mach-meson8b/include/mach/c_stb_define.h  | 815 ++++++++++++++++++
 .../mach-meson8b/include/mach/meson-secure.h  | 119 +++
 arch/arm/mach-meson8b/include/mach/misc.h     | 143 ---
 arch/arm/mach-meson8b/include/mach/mod_gate.h |   3 +-
 .../mach-meson8b/include/mach/power_gate.h    |   4 +-
 arch/arm/mach-meson8b/include/mach/sd.h       |  19 +-
 arch/arm/mach-meson8b/include/mach/tvregs.h   |  34 -
 arch/arm/mach-meson8b/include/mach/vpp.h      |  17 +
 arch/arm/mach-meson8b/meson-secure.c          | 192 +++++
 arch/arm/mach-meson8b/meson-smc.S             | 151 ++++
 arch/arm/mach-meson8b/pm.c                    |  26 +-
 arch/arm/mach-meson8b/power_gate.c            |  31 +-
 arch/arm/mach-meson8b/smp.c                   |   2 +
 arch/arm/mach-meson8b/time.c                  |   2 +-
 arch/arm/mach-meson8b/vpu.c                   |   2 +-
 22 files changed, 1534 insertions(+), 231 deletions(-)
 mode change 100644 => 100755 arch/arm/mach-meson8b/Makefile
 mode change 100644 => 100755 arch/arm/mach-meson8b/clock.c
 mode change 100644 => 100755 arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
 mode change 100644 => 100755 arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c
 mode change 100644 => 100755 arch/arm/mach-meson8b/include/mach/am_regs.h
 create mode 100755 arch/arm/mach-meson8b/include/mach/audio.h
 create mode 100755 arch/arm/mach-meson8b/include/mach/bt656.h
 create mode 100755 arch/arm/mach-meson8b/include/mach/c_stb_define.h
 create mode 100755 arch/arm/mach-meson8b/include/mach/meson-secure.h
 delete mode 100644 arch/arm/mach-meson8b/include/mach/misc.h
 mode change 100644 => 100755 arch/arm/mach-meson8b/include/mach/mod_gate.h
 mode change 100644 => 100755 arch/arm/mach-meson8b/include/mach/power_gate.h
 mode change 100644 => 100755 arch/arm/mach-meson8b/include/mach/sd.h
 mode change 100644 => 100755 arch/arm/mach-meson8b/include/mach/tvregs.h
 create mode 100755 arch/arm/mach-meson8b/include/mach/vpp.h
 create mode 100755 arch/arm/mach-meson8b/meson-secure.c
 create mode 100755 arch/arm/mach-meson8b/meson-smc.S
 mode change 100644 => 100755 arch/arm/mach-meson8b/pm.c
 mode change 100644 => 100755 arch/arm/mach-meson8b/power_gate.c
 mode change 100644 => 100755 arch/arm/mach-meson8b/smp.c
 mode change 100644 => 100755 arch/arm/mach-meson8b/vpu.c

diff --git a/arch/arm/mach-meson8b/Makefile b/arch/arm/mach-meson8b/Makefile
old mode 100644
new mode 100755
index 4551418f1e08..b332e101f7b7
--- a/arch/arm/mach-meson8b/Makefile
+++ b/arch/arm/mach-meson8b/Makefile
@@ -41,3 +41,10 @@ obj-$(CONFIG_MESON_SUSPEND) += power_suspend.o
 
 obj-$(CONFIG_AML_HDMI_TX) +=  hdmi_tx_hw/
 
+# ARM Trustzone
+obj-$(CONFIG_MESON_TRUSTZONE) += meson-smc.o meson-secure.o
+ifeq ($(CONFIG_MESON_TRUSTZONE),y)
+plus_sec                      := $(call as-instr,.arch_extension sec,+sec)
+AFLAGS_meson-smc.o            := -Wa,-march=armv7-a$(plus_sec)
+endif
+
diff --git a/arch/arm/mach-meson8b/clock.c b/arch/arm/mach-meson8b/clock.c
old mode 100644
new mode 100755
index 03a90fe391c4..3aff27a62b5e
--- a/arch/arm/mach-meson8b/clock.c
+++ b/arch/arm/mach-meson8b/clock.c
@@ -1,7 +1,7 @@
 /*
  * arch/arm/mach-meson8b/clock.c
  *
- * Copyright (C) 2011-2012 Amlogic, Inc.
+ * Copyright (C) 2011-2014 Amlogic, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -44,6 +44,15 @@
 //#include <mach/hardware.h>
 //#include <mach/clk_set.h>
 //#include <mach/power_gate.h>
+
+#ifdef CONFIG_MESON_TRUSTZONE
+#include <mach/meson-secure.h>
+#endif
+
+#include <linux/delay.h>
+extern struct arm_delay_ops arm_delay_ops;
+
+
 static DEFINE_SPINLOCK(clockfw_lock);
 static DEFINE_MUTEX(clock_ops_lock);
 
@@ -78,13 +87,13 @@ typedef union latency_data {
 static unsigned sys_pll_settings[][3] = {
                 {   24, 0x40020238, 0x01063546 }, /* fvco 1344, / 4, /14 */
                 {   48, 0x40020240, 0x01033546 }, /* fvco 1536, / 4, / 8 */
-                {   72, 0x40020248, 0x01023546 }, /* fvco 1728, / 4, / 6 */
+                {   72, 0x40020248, 0x03023546 }, /* fvco 1728, / 4, / 6 */
                 {   96, 0x40020240, 0x01013546 }, /* fvco 1536, / 4, / 4 */
                 {  120, 0x40020250, 0x03013546 }, /* fvco 1920, / 4, / 4 */
                 {  144, 0x40020260, 0x03013546 }, /* fvco 2304, / 4, / 4 */
                 {  168, 0x40010238, 0x01013546 }, /* fvco 1344, / 2, / 4 */
                 {  192, 0x40010240, 0x01013546 }, /* fvco 1536, / 2, / 4 */
-                {  216, 0x40010248, 0x01013546 }, /* fvco 1728, / 2, / 4 */
+                {  216, 0x40010248, 0x03013546 }, /* fvco 1728, / 2, / 4 */
                 {  240, 0x40010250, 0x03013546 }, /* fvco 1920, / 2, / 4 */
                 {  264, 0x40010258, 0x03013546 }, /* fvco 2112, / 2, / 4 */
                 {  288, 0x40010260, 0x03013546 }, /* fvco 2304, / 2, / 4 */
@@ -93,8 +102,8 @@ static unsigned sys_pll_settings[][3] = {
                 {  360, 0x4002023C, 0x01003546 }, /* fvco 1440, / 4, / 1 */
                 {  384, 0x40020240, 0x01003546 }, /* fvco 1536, / 4, / 1 */
                 {  408, 0x40020244, 0x01003546 }, /* fvco 1632, / 4, / 1 */
-                {  432, 0x40020248, 0x01003546 }, /* fvco 1728, / 4, / 1 */
-                {  456, 0x4002024C, 0x01003546 }, /* fvco 1824, / 4, / 1 */
+                {  432, 0x40020248, 0x03003546 }, /* fvco 1728, / 4, / 1 */
+                {  456, 0x4002024C, 0x03003546 }, /* fvco 1824, / 4, / 1 */
                 {  480, 0x40020250, 0x03003546 }, /* fvco 1920, / 4, / 1 */
                 {  504, 0x40020254, 0x03003546 }, /* fvco 2016, / 4, / 1 */
                 {  528, 0x40020258, 0x03003546 }, /* fvco 2112, / 4, / 1 */
@@ -111,10 +120,10 @@ static unsigned sys_pll_settings[][3] = {
                 {  792, 0x40010242, 0x01003546 }, /* fvco 1584, / 2, / 1 */
                 {  816, 0x40010244, 0x01003546 }, /* fvco 1632, / 2, / 1 */
                 {  840, 0x40010246, 0x01003546 }, /* fvco 1680, / 2, / 1 */
-                {  864, 0x40010248, 0x01003546 }, /* fvco 1728, / 2, / 1 */
-                {  888, 0x4001024A, 0x01003546 }, /* fvco 1776, / 2, / 1 */
-                {  912, 0x4001024C, 0x01003546 }, /* fvco 1824, / 2, / 1 */
-                {  936, 0x4001024E, 0x01003546 }, /* fvco 1872, / 2, / 1 */
+                {  864, 0x40010248, 0x03003546 }, /* fvco 1728, / 2, / 1 */
+                {  888, 0x4001024A, 0x03003546 }, /* fvco 1776, / 2, / 1 */
+                {  912, 0x4001024C, 0x03003546 }, /* fvco 1824, / 2, / 1 */
+                {  936, 0x4001024E, 0x03003546 }, /* fvco 1872, / 2, / 1 */
                 {  960, 0x40010250, 0x03003546 }, /* fvco 1920, / 2, / 1 */
                 {  984, 0x40010252, 0x03003546 }, /* fvco 1968, / 2, / 1 */
                 { 1008, 0x40010254, 0x03003546 }, /* fvco 2016, / 2, / 1 */
@@ -766,7 +775,10 @@ static unsigned long clk_get_rate_a9(struct clk * clkdev)
 static inline void udelay_scaled(unsigned long usecs, unsigned int oldMHz,
                                  unsigned int newMHz)
 {
-	udelay(usecs * newMHz / oldMHz);
+	if(arm_delay_ops.ticks_per_jiffy)
+		udelay(usecs);
+	else
+		udelay(usecs * newMHz / oldMHz);
 }
 
 /**
@@ -874,14 +886,31 @@ void meson_set_cpu_power_ctrl(uint32_t cpu,int is_power_on)
 void meson_set_cpu_ctrl_reg(int cpu,int is_on)
 {
 	spin_lock(&clockfw_lock);
+
+#ifdef CONFIG_MESON_TRUSTZONE
+	uint32_t value = 0;
+	value = meson_read_corectrl();
+	value = value & ~(1U << cpu) | (is_on << cpu);
+	value |= 1;
+	meson_modify_corectrl(value);
+#else
 	aml_set_reg32_bits(MESON_CPU_CONTROL_REG,is_on,cpu,1);
 	aml_set_reg32_bits(MESON_CPU_CONTROL_REG,1,0,1);
+#endif
+
 	spin_unlock(&clockfw_lock);
 }
+
 void meson_set_cpu_ctrl_addr(uint32_t cpu, const uint32_t addr)
 {
 	spin_lock(&clockfw_lock);
+
+#ifdef CONFIG_MESON_TRUSTZONE
+	meson_auxcoreboot_addr(cpu, addr);
+#else
 	aml_write_reg32((MESON_CPU1_CONTROL_ADDR_REG + ((cpu-1) << 2)), addr);
+#endif
+
 	spin_unlock(&clockfw_lock);	
 }
 
@@ -911,7 +940,11 @@ static inline void meson_smp_init_transaction(void)
 {
     int cpu;
 
+#ifdef CONFIG_MESON_TRUSTZONE
+	meson_modify_corectrl(0);
+#else
     aml_write_reg32(MESON_CPU_CONTROL_REG, 0);
+#endif
 
     for_each_online_cpu(cpu) {
         aml_write_reg32(MESON_CPU_STATUS_REG(cpu), 0);
@@ -1092,7 +1125,7 @@ static int __init a9_clk_min(char *str)
 early_param("a9_clk_min", a9_clk_min);
 static int set_sys_pll(struct clk *clk,  unsigned long dst)
 {
-	int idx,loop,scale_mhz;
+	int idx,loop = 0;
 	static int only_once = 0;
 	unsigned int curr_cntl = aml_read_reg32(P_HHI_SYS_PLL_CNTL);
 	unsigned int cpu_clk_cntl = 0;
@@ -1131,19 +1164,12 @@ SETPLL:
 
 		aml_write_reg32(P_HHI_SYS_PLL_CNTL,  cpu_clk_cntl);
 
-		if (clk->old_rate <= dst) 
-			/* when increasing frequency, lpj has already been adjusted */
-			scale_mhz = dst / 1000000;// 
-		else
-			/* when decreasing frequency, lpj has not yet been adjusted */
-			scale_mhz = clk->rate / 1000000;
+		udelay_scaled(100, dst / 1000000, 24 /*clk_get_rate_xtal*/);
 
-		loop=0;
 		cntl = aml_read_reg32(P_HHI_SYS_PLL_CNTL);
-		while((cntl & (1<<31)) == 0){
-			udelay_scaled(100, dst / 1000000, 24 /*clk_get_rate_xtal*/);
-			cntl = aml_read_reg32(P_HHI_SYS_PLL_CNTL);
-			if(loop++ > 10000){
+		if((cntl & (1<<31)) == 0){
+			if(loop++ >= 10){
+				loop = 0;
 				printk(KERN_ERR"CPU freq: %ld MHz, syspll (%x) can't lock: \n",dst/1000000,cntl);
 				printk(KERN_ERR"  [10c0..10c4]%08x, %08x, %08x, %08x, %08x: [10a5]%08x, [10c7]%08x \n",
 					aml_read_reg32(P_HHI_SYS_PLL_CNTL),
@@ -1162,10 +1188,11 @@ SETPLL:
 				}else{
 					latency.b.afc_dsel_bp_in = !latency.b.afc_dsel_bp_in;
 					printk(KERN_ERR"  INV afc_dsel_bp_in, new latency=%08x\n",latency.d32);
+					sys_pll_settings[idx][2] = latency.d32;/*write back afc_dsel_bp_in bit.*/
 				}
 				printk(KERN_ERR"  Try again!\n");
-				goto SETPLL;
 			}
+			goto SETPLL;
 		};
 
 	}else {
@@ -1637,7 +1664,7 @@ static ssize_t freq_limit_show(struct class *cla, struct class_attribute *attr,
 
 
 static struct class_attribute freq_limit_class_attrs[] = {
-	__ATTR(limit, S_IRWXU, freq_limit_show, freq_limit_store),
+	__ATTR(limit, S_IRUGO|S_IWUSR|S_IWGRP, freq_limit_show, freq_limit_store),
 	__ATTR_NULL,
 };
 
@@ -1708,14 +1735,14 @@ static int __init meson_clock_init(void)
     // Add clk usb0
     CLK_DEFINE(usb0,xtal,4,NULL,clk_msr_get,clk_enable_usb,clk_disable_usb,"usb0");
     meson_clk_register(&clk_usb0,&clk_xtal);
-    clk_usb0.clk_gate_reg_adr = P_USB_ADDR0;
-    clk_usb0.clk_gate_reg_mask = (1<<0);
+    //clk_usb0.clk_gate_reg_adr = P_USB_ADDR0;
+    //clk_usb0.clk_gate_reg_mask = (1<<0);
     
     // Add clk usb1
     CLK_DEFINE(usb1,xtal,5,NULL,clk_msr_get,clk_enable_usb,clk_disable_usb,"usb1");
     meson_clk_register(&clk_usb1,&clk_xtal);
-    clk_usb1.clk_gate_reg_adr = P_USB_ADDR8;
-    clk_usb1.clk_gate_reg_mask = (1<<0);
+    //clk_usb1.clk_gate_reg_adr = P_USB_ADDR8;
+    //clk_usb1.clk_gate_reg_mask = (1<<0);
 #endif
 		
 	{
diff --git a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
old mode 100644
new mode 100755
index d67fb6544028..46694609089a
--- a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
+++ b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
@@ -317,6 +317,7 @@ void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag){
         aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT10_8, (time_set >> 8) & 0x7);
         if(flag)
             hdmi_print(INF, CEC "write 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+        break;
         //7 bit
 	case 7:
         if(flag)
diff --git a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c
old mode 100644
new mode 100755
index 7617b9f38982..cde8b4b803d3
--- a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c
+++ b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c
@@ -1133,6 +1133,8 @@ void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
 
     aml_write_reg32(P_HHI_HDMI_AFC_CNTL, aml_read_reg32(P_HHI_HDMI_AFC_CNTL) | 0x3);
 
+    hdmi_wr_reg(TX_HDCP_MODE, 0x40);
+
     vic = hdmitx_device->HWOp.GetState(hdmitx_device, STAT_VIDEO_VIC, 0);
     if(vic != HDMI_Unkown) {
         hdmi_print(IMP, SYS "ALREADY init VIC = %d\n", vic);
@@ -1689,7 +1691,7 @@ static void hdmi_audio_init(unsigned char spdif_flag)
     tmp_add_data  = tx_i2s_8_channel ? 0xff : 0x03;
     hdmi_wr_reg(TX_AUDIO_SAMPLE, tmp_add_data); // Channel valid for up to 8 channels, 1 bit per channel.
 
-    hdmi_wr_reg(TX_AUDIO_PACK, 0x01); // Enable audio sample packets
+    hdmi_wr_reg(TX_AUDIO_PACK, 0x00); // Enable audio sample packets
 
     // Set N = 4096 (N is not measured, N must be configured so as to be a reference to clock_meter)
     hdmi_wr_reg(TX_SYS1_ACR_N_0, 0x00); // N[7:0]
@@ -2063,6 +2065,10 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
     
     hdmi_print(INF, AUD "audio channel num is %d\n", hdmitx_device->cur_audio_param.channel_num);
 
+    hdmi_wr_reg(TX_PACKET_CONTROL_2, hdmi_rd_reg(TX_PACKET_CONTROL_2) & (~(1<<3)));
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x30);     // reset audio master & sample
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00);
+
     if(!hdmi_audio_off_flag){
         hdmi_audio_init(i2s_to_spdif_flag);
     }
@@ -2229,7 +2235,7 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
     hdmi_wr_reg(TX_SYS1_ACR_N_0, (audio_N_para&0xff)); // N[7:0]
     hdmi_wr_reg(TX_SYS1_ACR_N_1, (audio_N_para>>8)&0xff); // N[15:8]
     hdmi_wr_reg(TX_SYS1_ACR_N_2, (audio_N_tolerance<<4)|((audio_N_para>>16)&0xf)); // N[19:16]
-    hdmi_wr_reg(TX_AUDIO_CONTROL,   hdmi_rd_reg(TX_AUDIO_CONTROL)|0x1); 
+    hdmi_wr_reg(TX_AUDIO_CONTROL,   hdmi_rd_reg(TX_AUDIO_CONTROL)|0x1);
 
     hdmi_wr_reg(TX_SYS0_ACR_CTS_0, 0);      //audio_CTS & 0xff);
     hdmi_wr_reg(TX_SYS0_ACR_CTS_1, 0);      //(audio_CTS>>8) & 0xff);
@@ -2423,7 +2429,7 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
         }
         if(argv == HDMITX_LATE_RESUME) {
             aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 1, 30, 1);
-            hdmi_phy_wakeup();
+            //hdmi_phy_wakeup();  	// no need
         }
         return 0;
     }
@@ -2896,6 +2902,7 @@ static int hdmitx_cntl_config(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigne
             hdmi_set_reg_bits(TX_TMDS_MODE, 0x3, 6, 2);
         }
         if(argv == DVI_MODE) {
+            hdmi_set_reg_bits(TX_VIDEO_DTV_OPTION_L, 0x0, 6, 2);
             hdmi_set_reg_bits(TX_TMDS_MODE, 0x2, 6, 2);
         }
         break;
@@ -2905,9 +2912,11 @@ static int hdmitx_cntl_config(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigne
     case CONF_AUDIO_MUTE_OP:
         if(argv == AUDIO_MUTE) {
             hdmi_wr_reg(TX_AUDIO_PACK, 0x00); // disable audio sample packets
+            //hdmi_wr_reg(TX_PACKET_CONTROL_2, hdmi_rd_reg(TX_PACKET_CONTROL_2) | (1<<3));
         }
-        if(argv == AUDIO_UNMUTE) {
-            hdmi_wr_reg(TX_AUDIO_PACK, 0x01); // disable audio sample packets
+        if((argv == AUDIO_UNMUTE) && (hdmitx_device->tx_aud_cfg != 0)) {
+            hdmi_wr_reg(TX_AUDIO_PACK, 0x01);
+            //hdmitx_device->audio_param_update_flag = 1;
         }
         break;
     case CONF_VIDEO_BLANK_OP:
diff --git a/arch/arm/mach-meson8b/include/mach/am_regs.h b/arch/arm/mach-meson8b/include/mach/am_regs.h
old mode 100644
new mode 100755
index 7c13eba9caba..61db433712bf
--- a/arch/arm/mach-meson8b/include/mach/am_regs.h
+++ b/arch/arm/mach-meson8b/include/mach/am_regs.h
@@ -12,6 +12,7 @@
 #include "register.h"
 #include "cpu.h"
 #include "canvas.h"
-#include "misc.h"
-
+#include "audio.h"
+#include "bt656.h"
+#include "vpp.h"
 #endif /* AM_REGS_H_ */
diff --git a/arch/arm/mach-meson8b/include/mach/audio.h b/arch/arm/mach-meson8b/include/mach/audio.h
new file mode 100755
index 000000000000..392e0a0be93f
--- /dev/null
+++ b/arch/arm/mach-meson8b/include/mach/audio.h
@@ -0,0 +1,40 @@
+#ifndef __MACH_MESON_AUDIO_REGS_H
+#define __MACH_MESON_AUDIO_REGS_H
+
+#define I2SIN_DIR       0    // I2S CLK and LRCLK direction. 0 : input 1 : output.
+#define I2SIN_CLK_SEL    1    // I2S clk selection : 0 : from pad input. 1 : from AIU.
+#define I2SIN_LRCLK_SEL 2
+#define I2SIN_POS_SYNC  3
+#define I2SIN_LRCLK_SKEW 4    // 6:4
+#define I2SIN_LRCLK_INVT 7
+#define I2SIN_SIZE       8    //9:8 : 0 16 bit. 1 : 18 bits 2 : 20 bits 3 : 24bits.
+#define I2SIN_CHAN_EN   10    //13:10. 
+#define I2SIN_EN        15
+
+#define AUDIN_FIFO0_EN       0
+#define AUDIN_FIFO0_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
+         
+#define AUDIN_FIFO0_DIN_SEL  3
+            // 0     spdifIN
+            // 1     i2Sin
+            // 2     PCMIN
+            // 3     HDMI in
+            // 4     DEMODULATOR IN
+#define AUDIN_FIFO0_ENDIAN   8    //10:8   data endian control.
+#define AUDIN_FIFO0_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
+#define AUDIN_FIFO0_UG       15    // urgent request enable.
+
+#define AUDIN_FIFO1_EN       0
+#define AUDIN_FIFO1_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
+         
+#define AUDIN_FIFO1_DIN_SEL  3
+            // 0     spdifIN
+            // 1     i2Sin
+            // 2     PCMIN
+            // 3     HDMI in
+            // 4     DEMODULATOR IN
+#define AUDIN_FIFO1_ENDIAN   8    //10:8   data endian control.
+#define AUDIN_FIFO1_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
+#define AUDIN_FIFO1_UG       15    // urgent request enable.
+
+#endif
diff --git a/arch/arm/mach-meson8b/include/mach/bt656.h b/arch/arm/mach-meson8b/include/mach/bt656.h
new file mode 100755
index 000000000000..596ed6f625fb
--- /dev/null
+++ b/arch/arm/mach-meson8b/include/mach/bt656.h
@@ -0,0 +1,50 @@
+#ifndef __MACH_MESON_BT656_REGS_H
+#define __MACH_MESON_BT656_REGS_H
+
+/*BT656 MACRO */
+//#define BT_CTRL 0x2240 	///../ucode/register.h
+#define BT_SYSCLOCK_RESET    30      //Sync fifo soft  reset_n at system clock domain.     Level reset. 0 = reset. 1 : normal mode.
+#define BT_656CLOCK_RESET    29      //Sync fifo soft reset_n at bt656 clock domain.   Level reset.  0 = reset.  1 : normal mode.
+//    #define BT_VSYNC_SEL              25      //25:26 VDIN VS selection.   00 :  SOF.  01: EOF.   10: vbi start point.  11 : vbi end point.
+//    #define BT_HSYNC_SEL              23      //24:23 VDIN HS selection.  00 : EAV.  01: SAV.    10:  EOL.  11: SOL
+#define BT_CAMERA_MODE        22      // Camera_mode
+#define BT_CLOCK_ENABLE        7	// 1: enable bt656 clock. 0: disable bt656 clock.
+
+//#define BT_PORT_CTRL 0x2249 	///../ucode/register.h
+//    #define BT_VSYNC_MODE      23  //1: use  vsync  as the VBI start point. 0: use the regular vref.
+//    #define BT_HSYNC_MODE      22  //1: use hsync as the active video start point.  0. Use regular sav and eav. 
+#define BT_SOFT_RESET           31	// Soft reset
+//    #define BT_JPEG_START           30
+//    #define BT_JPEG_IGNORE_BYTES    18	//20:18
+//    #define BT_JPEG_IGNORE_LAST     17
+#define BT_UPDATE_ST_SEL        16
+#define BT_COLOR_REPEAT         15
+//    #define BT_VIDEO_MODE           13	// 14:13
+#define BT_AUTO_FMT             12
+#define BT_PROG_MODE            11
+//    #define BT_JPEG_MODE            10
+#define BT_XCLK27_EN_BIT        9	// 1 : xclk27 is input.     0 : xclk27 is output.
+#define BT_FID_EN_BIT           8	// 1 : enable use FID port.
+#define BT_CLK27_SEL_BIT        7	// 1 : external xclk27      0 : internal clk27.
+//    #define BT_CLK27_PHASE_BIT      6	// 1 : no inverted          0 : inverted.
+//    #define BT_ACE_MODE_BIT         5	// 1 : auto cover error by hardware.
+#define BT_SLICE_MODE_BIT       4	// 1 : no ancillay flag     0 : with ancillay flag.
+#define BT_FMT_MODE_BIT         3	// 1 : ntsc                 0 : pal.
+#define BT_REF_MODE_BIT         2	// 1 : from bit stream.     0 : from ports.
+#define BT_MODE_BIT             1	// 1 : BT656 model          0 : SAA7118 mode.
+#define BT_EN_BIT               0	// 1 : enable.
+#define BT_VSYNC_PHASE      0
+#define BT_HSYNC_PHASE      1
+//    #define BT_VSYNC_PULSE      2
+//    #define BT_HSYNC_PULSE      3
+//    #define BT_FID_PHASE        4
+#define BT_FID_HSVS         5
+#define BT_IDQ_EN           6
+#define BT_IDQ_PHASE        7
+#define BT_D8B              8
+//    #define BT_10BTO8B          9
+#define BT_FID_DELAY       10	//12:10
+#define BT_VSYNC_DELAY     13	//
+#define BT_HSYNC_DELAY     16
+
+#endif
diff --git a/arch/arm/mach-meson8b/include/mach/c_stb_define.h b/arch/arm/mach-meson8b/include/mach/c_stb_define.h
new file mode 100755
index 000000000000..f8bb3131b1db
--- /dev/null
+++ b/arch/arm/mach-meson8b/include/mach/c_stb_define.h
@@ -0,0 +1,815 @@
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+//
+// ./create_stb_define_for_C_code.pl
+//
+// and was applied to the file
+//
+// ./stb_define.h
+//
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+//
+#ifdef C_STB_DEFINE_H
+#else
+#define C_STB_DEFINE_H
+
+//========================================================================
+//  STB Registers Start
+//========================================================================
+// -----------------------------------------------
+#define STB_CBUS_BASE           0x1600
+// -----------------------------------------------
+// There are two instantiations under one CBUS slave.  Each CBUS slave can support
+// 256 registers.  Each demux is allocated 128 registers so set the offset in
+// the middle
+// Copy this define but don't add a base address
+#define DEMUX_1_OFFSET         0x00
+#define DEMUX_2_OFFSET         0x50
+#define DEMUX_3_OFFSET         0xa0
+//========================================================================
+//  STB TOP Registers                   (8'hf0 - 8'hf7)
+//========================================================================
+// bit 22 -- invert fec_error for S2P1
+// bit 21 -- invert fec_data for S2P1
+// bit 20 -- invert fec_sync for S2P1
+// bit 19 -- invert fec_valid for S2P1
+// bit 18 -- invert fec_clk for S2P1
+// bit 17:16 -- fec_s_sel for S2P1  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
+// Bit 15 -- enable_des_pl_clk
+// Bit 14:13 -- reserved
+// Bit 12:10 -- ts_out_select, 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File
+// bit 9:8 -- des_i_sel 00 -- select demux0 as des input, 01 -- select_demux1, 10 -- select_demux2, 11 - reserved
+// bit 7 -- enable_des_pl
+// bit 6 -- invert fec_error for S2P0
+// bit 5 -- invert fec_data for S2P0
+// bit 4 -- invert fec_sync for S2P0
+// bit 3 -- invert fec_valid for S2P0
+// bit 2 -- invert fec_clk for S2P0
+// bit 1:0 -- fec_s_sel for S2P0  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
+//#define STB_TOP_CONFIG          (STB_CBUS_BASE + 0xf0) // 0x16f0
+/*----------- bit define -----------*/
+#define INVERT_S2P1_FEC_ERROR       22
+#define INVERT_S2P1_FEC_DATA        21
+#define INVERT_S2P1_FEC_SYNC        20
+#define INVERT_S2P1_FEC_VALID       19
+#define INVERT_S2P1_FEC_CLK         18
+#define S2P1_FEC_SERIAL_SEL         16
+#define ENABLE_DES_PL_CLK           15
+#define TS_OUTPUT_SOURCE            10
+#define DES_INPUT_SEL               8
+#define ENABLE_DES_PL               7
+#define INVERT_S2P0_FEC_ERROR       6
+#define INVERT_S2P0_FEC_DATA        5
+#define INVERT_S2P0_FEC_SYNC        4
+#define INVERT_S2P0_FEC_VALID       3
+#define INVERT_S2P0_FEC_CLK         2
+#define S2P0_FEC_SERIAL_SEL         0
+
+// 15:8 -- TS_package_length_sub_1 (default : 187)
+//  7:0 -- fec_sync_byte (default : 0x47)
+//#define TS_TOP_CONFIG           (STB_CBUS_BASE + 0xf1) // 0x16f1
+/*----------- bit define -----------*/
+#define TS_PACKAGE_LENGTH_SUB_1     8
+#define FEC_DEFAULT_SYNC_BYTE       0
+
+// Bit 23:16 -- file_m2ts_skip_bytes
+// Bit 15:8 -- des_out_dly
+// Bit 7:6 -- transport_scrambling_control_odd // should be 3
+// Bit 5 -- ts_hiu_enable
+// Bit 4:0 -- fec_clk_div
+//#define TS_FILE_CONFIG          (STB_CBUS_BASE + 0xf2) // 0x16f2
+/*----------- bit define -----------*/
+#define FILE_M2TS_SKIP_BYTES        16
+#define DES_OUT_DLY                 8
+#define TRANSPORT_SCRAMBLING_CONTROL_ODD 6
+#define TS_HIU_ENABLE               5
+#define FEC_FILE_CLK_DIV            0
+
+// Bit 13:8 -- des ts pl state   -- Read Only
+// Bit 3:0 PID index to 8 PID to get key-set
+// auto increse after TS_PL_PID_DATA read/write
+//#define TS_PL_PID_INDEX         (STB_CBUS_BASE + 0xf3) // 0x16f3
+/*----------- bit define -----------*/
+#define DES_TS_PL_STATE             8
+
+// Bit 13 -- PID match disble
+// Bit 12:0 -- PID
+//#define TS_PL_PID_DATA          (STB_CBUS_BASE + 0xf4) // 0x16f4
+/*----------- bit define -----------*/
+#define PID_MATCH_DISABLE_HIGH       29
+#define PID_MATCH_HIGH               16
+#define PID_MATCH_DISABLE_LOW        13
+#define PID_MATCH_LOW                0
+
+//#define COMM_DESC_KEY0          (STB_CBUS_BASE + 0xf5) // 0x16f5 // Common descrambler key (key bits[63:32])
+//#define COMM_DESC_KEY1          (STB_CBUS_BASE + 0xf6) // 0x16f6 // Common descrambler key (key bits[31:0])
+//#define COMM_DESC_KEY_RW        (STB_CBUS_BASE + 0xf7) // 0x16f7 // bits[3:0] point to the address to write the key {COMM_DESC_KEY1, COMM_DESC_KEY0}
+// Writing this register writes the key to RAM
+
+//========================================================================
+//  Multiple STB Registers                  (8'h00 - 8'h45)
+//========================================================================
+// STB registers are 8'h0x
+// Bit 15:0 -- version number : 0x0002  (v0.01)
+//#define STB_VERSION             (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x00)  // 0x1600 // read only
+//#define STB_VERSION_2           (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x00)  // 0x1650 // read only
+//#define STB_VERSION_3           (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x00)  // 0x16a0 // read only
+
+//#define STB_TEST_REG            (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x01)  // 0x1601
+//#define STB_TEST_REG_2          (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x01)  // 0x1651
+//#define STB_TEST_REG_3          (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x01)  // 0x16a1
+
+// Bit 15 -- fec_core_select 1 - select descramble output
+// Bit 14:12 -  fec_select 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File
+// Bit 11 -- FEC_CLK
+// Bit 10 -- SOP
+// Bit 9 -- D_VALID
+// Bit 8 -- D_FAIL
+// Bit 7:0 -- D_DATA 7:0
+//#define FEC_INPUT_CONTROL       (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x02)  // 0x1602
+//#define FEC_INPUT_CONTROL_2     (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x02)  // 0x1652
+//#define FEC_INPUT_CONTROL_3     (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x02)  // 0x16a2
+/*----------- bit define -----------*/
+#define FEC_CORE_SEL               15
+#define FEC_SEL                    12
+#define FEC_INPUT_FEC_CLK          11
+#define FEC_INPUT_SOP              10
+#define FEC_INPUT_D_VALID           9
+#define FEC_INPUT_D_FAIL            8
+
+//#define FEC_INPUT_DATA          (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x03)  // 0x1603 // read only
+//#define FEC_INPUT_DATA_2        (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x03)  // 0x1653 // read only
+//#define FEC_INPUT_DATA_3        (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x03)  // 0x16a3 // read only
+
+// bit 31 -- enable_free_clk_fec_data_valid
+// bit 30 -- enable_free_clk_stb_reg
+// bit 29:21 -- reserved
+// bit 20 (bit 4) -- Bypass use recoder path
+// bit 19 (bit 3) -- clear_PID_continuity_counter_valid
+// bit 18 (bit 2) -- Disable Splicing
+// bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES
+// bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES
+// Bit 15 - do not trust section length
+// Bit 14 - om cmd push even zero
+// Bit 13 - reserved
+// Bit 12 - SUB, OTHER PES interrupt at beginning of PES
+// Bit 11 - discard_av_package -- for ts_recorder use only
+// Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter
+// Bit 9 - ts_recorder_enable
+// Bit 8 - (table_id == 0xff) means section_end
+// Bit 7 - do not send uncomplete section
+// Bit 6 - do not discard duplicate package
+// Bit 5 - search SOP when trasport_error_indicator
+// Bit 4 - stb demux enable
+// Bit 3 - do not reset state machine on SOP
+// Bit 2 - search SOP when error happened ( when ignore_fail_n_sop, will have this case)
+// Bit 1 - do not use SOP input ( check FEC sync byte instead )
+// Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)
+//#define DEMUX_CONTROL           (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x04)  // 0x1604
+//#define DEMUX_CONTROL_2         (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x04)  // 0x1654
+//#define DEMUX_CONTROL_3         (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x04)  // 0x16a4
+/*----------- bit define -----------*/
+#define ENABLE_FREE_CLK_FEC_DATA_VALID          31
+#define ENABLE_FREE_CLK_STB_REG                 30
+#define BYPASS_USE_RECODER_PATH                 20
+#define CLEAR_PID_CONTINUITY_COUNTER_VALID      19
+#define DISABLE_SPLICING                        18
+#define INSERT_AUDIO_PES_STRONG_SYNC            17
+#define INSERT_VIDEO_PES_STRONG_SYNC            16
+#define SECTION_LENGTH_UNTRUSTY                 15
+#define OM_CMD_PUSH_EVEN_ZERO                   14
+#define OTHER_INT_AT_PES_BEGINING               12
+#define DISCARD_AV_PACKAGE                      11
+#define TS_RECORDER_SELECT                      10
+#define TS_RECORDER_ENABLE                      9
+#define SECTION_END_WITH_TABLE_ID               8
+#define SEND_COMPLETE_SECTION_ONLY              7
+#define KEEP_DUPLICATE_PACKAGE                  6
+#define SEACH_SOP_ON_TRANSPORT_ERROR            5
+#define STB_DEMUX_ENABLE                        4
+#define NO_RESET_ON_SOP                         3
+#define SEARCH_SOP_ON_ERROR                     2
+#define NOT_USE_OF_SOP_INPUT                    1
+#define IGNORE_NONSOP_FEC_ERROR                 0
+
+// bit 15:8 demux package length - 1 ( default : 187 )
+// bit 7:0 default is 0x47
+//#define FEC_SYNC_BYTE           (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x05)  // 0x1605
+//#define FEC_SYNC_BYTE_2         (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x05)  // 0x1655
+//#define FEC_SYNC_BYTE_3         (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x05)  // 0x16a5
+
+/******************************************************************************************************
+FM Memory Usage :
+0-15 (32 PID filter target) ---- 15:13-PID type 12:0-PID target or force data
+(force data : 1 will mask corespoding bit, 0 will disable this PID filter channel)
+advanced setting -- bit 7:0
+                    bit 7 -- PID bit 12:11 compare result force
+                    bit 6 -- PID bit 10:9 compare result force
+                    bit 5 -- PID bit 8:7 compare result force
+                    bit 4 -- PID bit 6:5 compare result force
+                    bit 3 -- PID bit 4:3 compare result force
+                    bit 2 -- PID bit 2 compare result force
+                    bit 1 -- PID bit 1 compare result force
+                    bit 0 -- PID bit 0 compare result force
+16-255(15x32 Section filter target)
+For first byte : Table_ID
+---- 15-Mask High 4-bits
+     14-Mask Low 4-bits
+     13-disable_PID_check
+     12:8-PIDindex
+     7:0-section target (always EQ)
+For rest of bytes :
+---- 15-Mask 14-EQ/NE 13-disable_PID_check 12:8-PIDindex 7:0-section target (or force data)
+advanced setting -- bit 7:0 force compare result
+******************************************************************************************************/
+/*----------- bit define -----------*/
+#define PID_TYPE                                13
+#define PID_TARGET                              0
+
+#define SECTION_FIRSTBYTE_MASKHIGH              15
+#define SECTION_FIRSTBYTE_MASKLOW               14
+#define SECTION_FIRSTBYTE_DISABLE_PID_CHECK     13
+#define SECTION_FIRSTBYTE_PID_INDEX             8
+#define SECTION_TARGET                          0
+
+#define SECTION_RESTBYTE_MASK                   15
+#define SECTION_RESTBYTE_MASK_EQ                14
+#define SECTION_RESTBYTE_DISABLE_PID_CHECK      13
+#define SECTION_RESTBYTE_PID_INDEX              8
+
+// bit 31:16 -- filter memory write data hi[31:16]
+// bit 15:0 -- filter memory write data low [15:0]
+//#define FM_WR_DATA              (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x06)  // 0x1606
+//#define FM_WR_DATA_2            (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x06)  // 0x1656
+//#define FM_WR_DATA_3            (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x06)  // 0x16a6
+/*----------- bit define -----------*/
+#define FM_WR_DATA_HI                           16
+
+// bit 31:24 -- advanced setting hi
+// bit 23:16 -- advanced setting low
+// bit 15 -- filter memory write data request
+// bit 7:0 -- filter memory write addr
+//#define FM_WR_ADDR              (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x07)  // 0x1607
+//#define FM_WR_ADDR_2            (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x07)  // 0x1657
+//#define FM_WR_ADDR_3            (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x07)  // 0x16a7
+/*----------- bit define -----------*/
+#define FM_ADVANCED_SETTING_HI                  24
+#define FM_ADVANCED_SETTING_LO                  16
+#define FM_WR_DATA_REQUEST                      15
+
+// bit 13:8 demux state  -- read only
+// bit 7:4 -- maxnum section filter compare address
+// bit 3:0 -- maxnum PID filter compare address
+//#define MAX_FM_COMP_ADDR        (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x08)  // 0x1608
+//#define MAX_FM_COMP_ADDR_2      (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x08)  // 0x1658
+//#define MAX_FM_COMP_ADDR_3      (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x08)  // 0x16a8
+/*----------- bit define -----------*/
+#define DEMUX_STATE                             8
+#define MAX_FM_SECTION_FILTER_COMP_ADDR         4
+
+// bit 15 - transport_error_indicator
+// bit 14 - payload_unit_start_indicator
+// bit 13 - transport_priority
+// bit 12:0 - PID
+//#define TS_HEAD_0               (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x09)  // 0x1609
+//#define TS_HEAD_0_2             (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x09)  // 0x1659
+//#define TS_HEAD_0_3             (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x09)  // 0x16a9
+/*----------- bit define -----------*/
+#define TRANSPORT_ERROR_INDICATOR               15
+#define PAYLOAD_UNIT_START_INDICATOR            14
+#define TRANSPORT_PRIORITY                      13
+
+// bit 7:6 transport_scrambling_control
+// bit 5:4 adaptation_field_control
+// bit 3:0 continuity_counter
+//#define TS_HEAD_1               (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0a)  // 0x160a
+//#define TS_HEAD_1_2             (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0a)  // 0x165a
+//#define TS_HEAD_1_3             (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0a)  // 0x16aa
+/*----------- bit define -----------*/
+#define TRANSPORT_SCRAMBLING_CONTROL            6
+#define ADAPTATION_FIELD_CONTROL                4
+
+// bit 15:12 -- om_cmd_count (read only)
+// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
+// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
+// bit   5:3 -- type_stb_om_w_rd (read only)
+// bit     2 -- unit_start_stb_om_w_rd (read only)
+// bit     1 -- om_cmd_overflow (read only)
+// bit     0 -- om_cmd_pending (read)
+// bit     0 -- om_cmd_read_finished (write)
+//#define OM_CMD_STATUS           (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0b)  // 0x160b
+//#define OM_CMD_STATUS_2         (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0b)  // 0x165b
+//#define OM_CMD_STATUS_3         (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0b)  // 0x16ab
+/*----------- bit define -----------*/
+#define OM_CMD_COUNT                            12
+#define OM_OVERFLOW_COUNT                       9
+#define OM_OVERWRITE_COUNT                      6
+#define TYPE_STB_OM_W_RD                        3
+#define UNIT_START_STB_OM_W_RD                  2
+#define OM_CMD_OVERFLOW                         1
+
+// bit 15:9 -- count_stb_om_w_rd  (read only)
+// bit 8:0 -- start_stb_om_wa_rd (read only)
+//#define OM_CMD_DATA             (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0c)  // 0x160c
+//#define OM_CMD_DATA_2           (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0c)  // 0x165c
+//#define OM_CMD_DATA_3           (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0c)  // 0x16ac
+/*----------- bit define -----------*/
+#define COUNT_STB_OM_W_RD                       9
+
+// bit 11:0 -- offset for section data
+//#define OM_CMD_DATA2            (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0d)  // 0x160d
+//#define OM_CMD_DATA2_2          (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0d)  // 0x165d
+//#define OM_CMD_DATA2_3          (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0d)  // 0x16ad
+
+// bit 31:16 -- base address for section buffer group 0 (*0x400 to get real address)
+// bit 15:0 -- base address for section buffer group 1 (*0x400 to get real address)
+//#define SEC_BUFF_01_START       (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0e)  // 0x160e
+//#define SEC_BUFF_01_START_2     (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0e)  // 0x165e
+//#define SEC_BUFF_01_START_3     (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0e)  // 0x16ae
+/*----------- bit define -----------*/
+#define SEC_BUFF_0_BASE_ADDR                    16
+
+// bit 31:16 -- base address for section buffer group 2 (*0x400 to get real address)
+// bit 15:0 -- base address for section buffer group 3 (*0x400 to get real address)
+//#define SEC_BUFF_23_START       (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0f)  // 0x160f
+//#define SEC_BUFF_23_START_2     (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0f)  // 0x165f
+//#define SEC_BUFF_23_START_3     (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0f)  // 0x16af
+/*----------- bit define -----------*/
+#define SEC_BUFF_2_BASE_ADDR                    16
+
+// bit 15:12 -- section buffer size for group 3
+// bit 11:8 -- section buffer size for group 2
+// bit 7:4 -- section buffer size for group 1
+// bit 3:0 -- section buffer size for group 0 (bit used,  for example, 10 means 1K)
+//#define SEC_BUFF_SIZE           (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x10)  // 0x1610
+//#define SEC_BUFF_SIZE_2         (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x10)  // 0x1660
+//#define SEC_BUFF_SIZE_3         (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x10)  // 0x16b0
+/*----------- bit define -----------*/
+#define SEC_BUFF_3_SIZE                        12
+#define SEC_BUFF_2_SIZE                         8
+#define SEC_BUFF_1_SIZE                         4
+
+// section buffer busy status for buff 31:0 ( Read Only )
+//#define SEC_BUFF_BUSY           (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x11)  // 0x1611
+//#define SEC_BUFF_BUSY_2         (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x11)  // 0x1661
+//#define SEC_BUFF_BUSY_3         (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x11)  // 0x16b1
+
+// section buffer write status for buff 31:0 -- Read
+// clear buffer status ( buff READY and BUSY ) -- write
+//#define SEC_BUFF_READY          (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x12)  // 0x1612
+//#define SEC_BUFF_READY_2        (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x12)  // 0x1662
+//#define SEC_BUFF_READY_3        (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x12)  // 0x16b2
+
+// bit 15 -- section_reset_busy (Read Only)
+// bit 14 -- output_section_buffer_valid
+// bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only
+// bit 4:0 -- SEC_BUFFER_INDEX   RW
+//#define SEC_BUFF_NUMBER         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x13)  // 0x1613
+//#define SEC_BUFF_NUMBER_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x13)  // 0x1663
+//#define SEC_BUFF_NUMBER_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x13)  // 0x16b3
+/*----------- bit define -----------*/
+#define SECTION_RESET_BUSY                      15
+#define OUTPUT_SECTION_BUFFER_VALID             14
+#define INDEXED_SEC_BUFF_NUMBER                 8
+
+// bit 9:5 -- BYPASS PID number
+// bit 4:0 -- PCR PID number
+//#define ASSIGN_PID_NUMBER       (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x14)  // 0x1614
+//#define ASSIGN_PID_NUMBER_2     (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x14)  // 0x1664
+//#define ASSIGN_PID_NUMBER_3     (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x14)  // 0x16b4
+/*----------- bit define -----------*/
+#define BYPASS_PID_NUMBER                       5
+
+// bit 15:0 -- stream_id filter bit enable
+// bit 7:0 -- stream_id filter target
+//#define VIDEO_STREAM_ID         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x15)  // 0x1615
+//#define VIDEO_STREAM_ID_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x15)  // 0x1665
+//#define VIDEO_STREAM_ID_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x15)  // 0x16b5
+
+//#define AUDIO_STREAM_ID         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x16)  // 0x1616
+//#define AUDIO_STREAM_ID_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x16)  // 0x1666
+//#define AUDIO_STREAM_ID_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x16)  // 0x16b6
+
+//#define SUB_STREAM_ID           (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x17)  // 0x1617
+//#define SUB_STREAM_ID_2         (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x17)  // 0x1667
+//#define SUB_STREAM_ID_3         (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x17)  // 0x16b7
+
+//#define OTHER_STREAM_ID         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x18)  // 0x1618
+//#define OTHER_STREAM_ID_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x18)  // 0x1668
+//#define OTHER_STREAM_ID_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x18)  // 0x16b8
+
+// bit 12 -- PCR_EN
+// bit 11:0 -- PCR90K_DIV
+//#define PCR90K_CTL              (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x19)  // 0x1619
+//#define PCR90K_CTL_2            (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x19)  // 0x1669
+//#define PCR90K_CTL_3            (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x19)  // 0x16b9
+/*----------- bit define -----------*/
+#define PCR_EN                     12
+
+// bit 15:0 -- PCR[31:0] R/W
+//#define PCR_DEMUX               (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1a)  // 0x161a
+//#define PCR_DEMUX_2             (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1a)  // 0x166a
+//#define PCR_DEMUX_3             (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1a)  // 0x16ba
+
+// bit 15:0 -- VPTS[31:0] R/W
+//#define VIDEO_PTS_DEMUX         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1b)  // 0x161b
+//#define VIDEO_PTS_DEMUX_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1b)  // 0x166b
+//#define VIDEO_PTS_DEMUX_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1b)  // 0x16bb
+
+// bit 15:0 -- VDTS[31:0] R/W
+//#define VIDEO_DTS_DEMUX         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1c)  // 0x161c
+//#define VIDEO_DTS_DEMUX_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1c)  // 0x166c
+//#define VIDEO_DTS_DEMUX_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1c)  // 0x16bc
+
+// bit 15:0 -- APTS[31:0] R/W
+//#define AUDIO_PTS_DEMUX         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1d)  // 0x161d
+//#define AUDIO_PTS_DEMUX_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1d)  // 0x166d
+//#define AUDIO_PTS_DEMUX_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1d)  // 0x16bd
+
+// bit 15:0 -- SPTS[31:0] R/W
+//#define SUB_PTS_DEMUX           (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1e)  // 0x161e
+//#define SUB_PTS_DEMUX_2         (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1e)  // 0x166e
+//#define SUB_PTS_DEMUX_3         (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1e)  // 0x16be
+
+// read -- status, write 1 clear status
+// bit 15 -- SUB_PTS[32]
+// bit 14 -- AUDIO_PTS[32]
+// bit 13 -- VIDEO_DTS[32]
+// bit 12 -- VIDEO_PTS[32]
+// bit 3 -- sub_pts_ready
+// bit 2 -- audio_pts_ready
+// bit 1 -- video_dts_ready
+// bit 0 -- video_pts_ready
+//#define STB_PTS_DTS_STATUS      (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1f)  // 0x161f
+//#define STB_PTS_DTS_STATUS_2    (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1f)  // 0x166f
+//#define STB_PTS_DTS_STATUS_3    (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1f)  // 0x16bf
+/*----------- bit define -----------*/
+#define SUB_PTS_BIT32              15
+#define AUDIO_PTS_BIT32            14
+#define VIDEO_DTS_BIT32            13
+#define VIDEO_PTS_BIT32            12
+#define SUB_PTS_READY              3
+#define AUDIO_PTS_READY            2
+#define VIDEO_DTS_READY            1
+#define VIDEO_PTS_READY            0
+
+// bit 3:0 --
+//  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0]
+//  1 -- stream_id[7:0], pes_header_bytes_left[7:0]
+//  2 -- pes_package_bytes_left[15:0]
+//  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]
+//#define STB_DEBUG_INDEX         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x20)  // 0x1620
+//#define STB_DEBUG_INDEX_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x20)  // 0x1670
+//#define STB_DEBUG_INDEX_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x20)  // 0x16c0
+
+// read only
+//#define STB_DEBUG_DATA_OUT      (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x21)  // 0x1621
+//#define STB_DEBUG_DATA_OUT_2    (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x21)  // 0x1671
+//#define STB_DEBUG_DATA_OUT_3    (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x21)  // 0x16c1
+
+// default : 0x807f
+// bit 15:9  -- MAX OM DMA COUNT  (default: 0x40)
+// bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)
+#define STB_OM_CTL              (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x22)  // 0x1622
+#define STB_OM_CTL_2            (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x22)  // 0x1672
+#define STB_OM_CTL_3            (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x22)  // 0x16c2
+/*----------- bit define -----------*/
+#define MAX_OM_DMA_COUNT           9
+#define LAST_OM_ADDR               0
+
+// 15:0  WRITE 1 CLEAR to clear interrupt source
+// 9 -- splicing_point
+// 8 -- other_PES_int
+// 7 -- sub_PES_int
+// 6 -- discontinuity
+// 5 -- duplicated_pack_found
+// 4 -- New PDTS ready
+// 3 -- om_cmd_buffer ready for access
+// 2 -- section buffer ready
+// 1 -- transport_error_indicator
+// 0 -- TS ERROR PIN
+//#define STB_INT_STATUS          (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x23)  // 0x1623
+//#define STB_INT_STATUS_2        (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x23)  // 0x1673
+//#define STB_INT_STATUS_3        (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x23)  // 0x16c3
+/*----------- bit define -----------*/
+#define PCR_READY                  11
+#define AUDIO_SPLICING_POINT       10
+#define VIDEO_SPLICING_POINT       9
+#define OTHER_PES_READY            8
+#define SUB_PES_READY              7
+#define DIS_CONTINUITY_PACKET      6
+#define DUPLICATED_PACKET          5
+#define NEW_PDTS_READY             4
+#define OM_CMD_READ_PENDING        3
+#define SECTION_BUFFER_READY       2
+#define TS_ERROR_PACKAGE           1
+#define TS_ERROR_PIN               0
+
+// When Bit 31 - 1 write will indicate all type use sepertate endian (Write Only)
+// When Bit 31 - 0 write will indicate all type else use Bit 8:6
+// Bit 23:21 - demux om write endian control for OTHER_PES_PACKET
+// Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET
+// Bit 17:15 - demux om write endian control for SUB_PACKET
+// Bit 14:12 - demux om write endian control for AUDIO_PACKET
+// Bit 11:9  - demux om write endian control for VIDEO_PACKET
+// Bit 8:6 - demux om write endian control for else
+// Bit 5:3 - demux om write endian control for bypass
+// Bit 2:0 - demux om write endian control for section
+//#define DEMUX_ENDIAN            (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x24)  // 0x1624
+//#define DEMUX_ENDIAN_2          (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x24)  // 0x1674
+//#define DEMUX_ENDIAN_3          (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x24)  // 0x16c4
+/*----------- bit define -----------*/
+#define SEPERATE_ENDIAN            31
+#define OTHER_PES_ENDIAN           21
+#define SCR_ENDIAN                 18
+#define SUB_ENDIAN                 15
+#define AUDIO_ENDIAN               12
+#define VIDEO_ENDIAN               9
+#define OTHER_ENDIAN               6
+#define BYPASS_ENDIAN              3
+#define SECTION_ENDIAN             0
+
+// Bit 7 -- use hi_bsf interface
+//#define TS_HIU_CTL              (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x25)  // 0x1625
+//#define TS_HIU_CTL_2            (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x25)  // 0x1675
+//#define TS_HIU_CTL_3            (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x25)  // 0x16c5
+/*----------- bit define -----------*/
+#define LAST_BURST_THRESHOLD       8
+#define USE_HI_BSF_INTERFACE       7
+
+// bit 15:0 -- base address for section buffer start (*0x10000 to get real base)
+//#define SEC_BUFF_BASE           (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x26)  // 0x1626
+//#define SEC_BUFF_BASE_2         (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x26)  // 0x1676
+//#define SEC_BUFF_BASE_3         (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x26)  // 0x16c6
+
+// bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN
+// bit 10 -- mask bit for SUB_AHB_DMA_EN
+// bit 9 -- mask bit for BYPASS_AHB_DMA_EN
+// bit 8 -- mask bit for SECTION_AHB_DMA_EN
+// bit 7 -- mask bit for recoder stream
+// bit 6:0 -- mask bit for each type
+//#define DEMUX_MEM_REQ_EN        (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x27)  // 0x1627
+//#define DEMUX_MEM_REQ_EN_2      (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x27)  // 0x1677
+//#define DEMUX_MEM_REQ_EN_3      (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x27)  // 0x16c7
+/*----------- bit define -----------*/
+#define OTHER_PES_AHB_DMA_EN       11
+#define SUB_AHB_DMA_EN             10
+#define BYPASS_AHB_DMA_EN          9
+#define SECTION_AHB_DMA_EN         8
+#define RECORDER_STREAM            7
+#define OTHER_PES_PACKET           6
+#define SCR_ONLY_PACKET            5
+#define BYPASS_PACKET              4
+#define SECTION_PACKET             3
+#define SUB_PACKET                 2
+#define AUDIO_PACKET               1
+#define VIDEO_PACKET               0
+
+// bit 31:0 -- vb_wr_ptr for video PDTS
+//#define VIDEO_PDTS_WR_PTR       (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x28)  // 0x1628
+//#define VIDEO_PDTS_WR_PTR_2     (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x28)  // 0x1678
+//#define VIDEO_PDTS_WR_PTR_3     (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x28)  // 0x16c8
+
+// bit 31:0 -- ab_wr_ptr for audio PDTS
+//#define AUDIO_PDTS_WR_PTR       (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x29)  // 0x1629
+//#define AUDIO_PDTS_WR_PTR_2     (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x29)  // 0x1679
+//#define AUDIO_PDTS_WR_PTR_3     (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x29)  // 0x16c9
+
+// bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)
+//#define SUB_WR_PTR              (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2a)  // 0x162a
+//#define SUB_WR_PTR_2            (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2a)  // 0x167a
+//#define SUB_WR_PTR_3            (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2a)  // 0x16ca
+
+// bit 19:0 -- SB_START (sb_start << 12 == byte address);
+//#define SB_START                (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2b)  // 0x162b
+//#define SB_START_2              (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2b)  // 0x167b
+//#define SB_START_3              (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2b)  // 0x16cb
+
+// bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun)
+//#define SB_LAST_ADDR            (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2c)  // 0x162c
+//#define SB_LAST_ADDR_2          (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2c)  // 0x167c
+//#define SB_LAST_ADDR_3          (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2c)  // 0x16cc
+
+// bit 31:0 -- sb_wr_ptr for sub PES
+//#define SB_PES_WRITE_PTR        (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2d)  // 0x162d
+//#define SB_PES_WRITE_PTR_2      (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2d)  // 0x167d
+//#define SB_PES_WRITE_PTR_3      (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2d)  // 0x16cd
+
+// bit 31:16 -- ob_wr_ptr for other PES
+// bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)
+//#define OTHER_WR_PTR            (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2e)  // 0x162e
+//#define OTHER_WR_PTR_2          (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2e)  // 0x167e
+//#define OTHER_WR_PTR_3          (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2e)  // 0x16ce
+
+// bit 19:0 -- OB_START (ob_start << 12 == byte address);
+//#define OB_START                (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2f)  // 0x162f
+//#define OB_START_2              (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2f)  // 0x167f
+//#define OB_START_3              (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2f)  // 0x16cf
+
+// bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun)
+//#define OB_LAST_ADDR            (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x30)  // 0x1630
+//#define OB_LAST_ADDR_2          (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x30)  // 0x1680
+//#define OB_LAST_ADDR_3          (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x30)  // 0x16d0
+
+// bit 31:0 -- ob_wr_ptr for sub PES
+//#define OB_PES_WRITE_PTR        (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x31)  // 0x1631
+//#define OB_PES_WRITE_PTR_2      (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x31)  // 0x1681
+//#define OB_PES_WRITE_PTR_3      (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x31)  // 0x16d1
+
+// 15:0  DEMUX interrupt MASK
+// 11 -- PCR_READY
+// 10 -- audio_splicing_point
+// 9 -- video_splicing_point
+// 8 -- other_PES_int
+// 7 -- sub_PES_int
+// 6 -- discontinuity
+// 5 -- duplicated_pack_found
+// 4 -- New PDTS ready
+// 3 -- om_cmd_buffer ready for access
+// 2 -- section buffer ready
+// 1 -- transport_error_indicator
+// 0 -- TS ERROR PIN
+//#define STB_INT_MASK            (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x32)  // 0x1632
+//#define STB_INT_MASK_2          (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x32)  // 0x1682
+//#define STB_INT_MASK_3          (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x32)  // 0x16d2
+
+// 31:16 VIDEO PID filter data
+//15 -- splicing VIDEO PID change enable
+//14:10 -- VIDEO PID FILTER ADDRESS
+// 9 -- PES splicing active (Read Only)
+// 8 -- splicing active (Read Only)
+// 7:0  splicing countdown (Read Only)
+//#define VIDEO_SPLICING_CTL      (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x33)  // 0x1633
+//#define VIDEO_SPLICING_CTL_2    (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x33)  // 0x1683
+//#define VIDEO_SPLICING_CTL_3    (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x33)  // 0x16d3
+/*----------- bit define -----------*/
+#define VIDEO_PID_FILTER_DATA      16
+#define VIDEO_SPLICING_PID_CHANGE_ENABLE       15
+#define VIDEO_PID_FILTER_ADDRESS   10
+#define VIDEO_PES_SPLICING_ACTIVE  9
+#define VIDEO_SPLICING_ACTIVE      8
+
+
+// 31:16 AUDIO PID filter data
+//15 -- splicing AUDIO PID change enable
+//14:10 -- AUDIO PID FILTER ADDRESS
+// 9 -- PES splicing active (Read Only)
+// 8 -- splicing active (Read Only)
+// 7:0  splicing countdown (Read Only)
+//#define AUDIO_SPLICING_CTL      (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x34)  // 0x1634
+//#define AUDIO_SPLICING_CTL_2    (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x34)  // 0x1684
+//#define AUDIO_SPLICING_CTL_3    (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x34)  // 0x16d4
+/*----------- bit define -----------*/
+#define AUDIO_PID_FILTER_DATA      16
+#define AUDIO_SPLICING_PID_CHANGE_ENABLE       15
+#define AUDIO_PID_FILTER_ADDRESS   10
+#define AUDIO_PES_SPLICING_ACTIVE  9
+#define AUDIO_SPLICING_ACTIVE      8
+
+// 23:16 M2TS_SKIP_BYTES
+// 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)
+// 7:0  PACKAGE BYTE COUNT (Read Only)
+//#define TS_PACKAGE_BYTE_COUNT   (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x35)  // 0x1635
+//#define TS_PACKAGE_BYTE_COUNT_2 (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x35)  // 0x1685
+//#define TS_PACKAGE_BYTE_COUNT_3 (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x35)  // 0x16d5
+/*----------- bit define -----------*/
+#define M2TS_SKIP_BYTES            16
+#define LAST_TS_PACKAGE_BYTE_COUNT 8
+
+// 15:0 2 bytes strong sync add to PES
+//#define PES_STRONG_SYNC         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x36)  // 0x1636
+//#define PES_STRONG_SYNC_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x36)  // 0x1686
+//#define PES_STRONG_SYNC_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x36)  // 0x16d6
+
+// bit 15 -- stb_om_ren
+// bit 14:11 -- reserved
+// bit  10:0 -- OM_DATA_RD_ADDR
+//#define OM_DATA_RD_ADDR         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x37)  // 0x1637
+//#define OM_DATA_RD_ADDR_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x37)  // 0x1687
+//#define OM_DATA_RD_ADDR_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x37)  // 0x16d7
+/*----------- bit define -----------*/
+#define STB_OM_REN                 15
+
+// bit 15:0 -- OM_DATA_RD
+//#define OM_DATA_RD              (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x38)  // 0x1638
+//#define OM_DATA_RD_2            (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x38)  // 0x1688
+//#define OM_DATA_RD_3            (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x38)  // 0x16d8
+
+// AUTO STOP SETTING for 32 channels
+// 4-bits per channel
+// when write
+// bit 3 -- set section active
+// bit 2:0 -- auto stop after count (0 means never stop)
+// when read
+// bit 3 -- current active status (1 - active, 0 - stopped )
+// bit 2:0 -- count down to auto stop
+// section 31:24
+//#define SECTION_AUTO_STOP_3     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x39)  // 0x1639
+//#define SECTION_AUTO_STOP_3_2   (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x39)  // 0x1689
+//#define SECTION_AUTO_STOP_3_3   (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x39)  // 0x16d9
+// section 23:16
+//#define SECTION_AUTO_STOP_2     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3a)  // 0x163a
+//#define SECTION_AUTO_STOP_2_2   (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3a)  // 0x168a
+//#define SECTION_AUTO_STOP_2_3   (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3a)  // 0x16da
+// section 15:8
+//#define SECTION_AUTO_STOP_1     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3b)  // 0x163b
+//#define SECTION_AUTO_STOP_1_2   (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3b)  // 0x168b
+//#define SECTION_AUTO_STOP_1_3   (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3b)  // 0x16db
+// section 7:0
+//#define SECTION_AUTO_STOP_0     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3c)  // 0x163c
+//#define SECTION_AUTO_STOP_0_2   (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3c)  // 0x168c
+//#define SECTION_AUTO_STOP_0_3   (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3c)  // 0x16dc
+
+// bit 31:0 reset channel status - each bit reset each channel
+// read -- 32 channel status
+//#define DEMUX_CHANNEL_RESET     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3d)  // 0x163d
+//#define DEMUX_CHANNEL_RESET_2   (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3d)  // 0x168d
+//#define DEMUX_CHANNEL_RESET_3   (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3d)  // 0x16dd
+
+//#define DEMUX_SCRAMBLING_STATE     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3e)  // 0x163e
+//#define DEMUX_SCRAMBLING_STATE_2   (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3e)  // 0x168e
+//#define DEMUX_SCRAMBLING_STATE_3   (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3e)  // 0x16de
+
+//#define DEMUX_CHANNEL_ACTIVITY     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3f)  // 0x163f
+//#define DEMUX_CHANNEL_ACTIVITY_2   (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3f)  // 0x168f
+//#define DEMUX_CHANNEL_ACTIVITY_3   (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3f)  // 0x16df
+
+// bit 4 -- video_stamp_use_dts
+// bit 3 -- audio_stamp_sync_1_en
+// bit 2 -- audio_stamp_insert_en
+// bit 1 -- video_stamp_sync_1_en
+// bit 0 -- video_stamp_insert_en
+//#define DEMUX_STAMP_CTL         (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x40)  // 0x1640
+//#define DEMUX_STAMP_CTL_2       (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x40)  // 0x1690
+//#define DEMUX_STAMP_CTL_3       (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x40)  // 0x16e0
+
+//#define DEMUX_VIDEO_STAMP_SYNC_0   (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x41)  // 0x1641
+//#define DEMUX_VIDEO_STAMP_SYNC_0_2 (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x41)  // 0x1691
+//#define DEMUX_VIDEO_STAMP_SYNC_0_3 (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x41)  // 0x16e1
+
+//#define DEMUX_VIDEO_STAMP_SYNC_1   (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x42)  // 0x1642
+//#define DEMUX_VIDEO_STAMP_SYNC_1_2 (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x42)  // 0x1692
+//#define DEMUX_VIDEO_STAMP_SYNC_1_3 (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x42)  // 0x16e2
+
+//#define DEMUX_AUDIO_STAMP_SYNC_0   (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x43)  // 0x1643
+//#define DEMUX_AUDIO_STAMP_SYNC_0_2 (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x43)  // 0x1693
+//#define DEMUX_AUDIO_STAMP_SYNC_0_3 (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x43)  // 0x16e3
+
+//#define DEMUX_AUDIO_STAMP_SYNC_1   (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x44)  // 0x1644
+//#define DEMUX_AUDIO_STAMP_SYNC_1_2 (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x44)  // 0x1694
+//#define DEMUX_AUDIO_STAMP_SYNC_1_3 (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x44)  // 0x16e4
+
+// Write : Bit[4:0] secter filter number for reset
+// Read  : select according to output_section_buffer_valid :
+//         per bit per section buffer valid status
+//         or section_buffer_ignore
+//#define DEMUX_SECTION_RESET     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x45)  // 0x1645
+//#define DEMUX_SECTION_RESET_2   (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x45)  // 0x1695
+//#define DEMUX_SECTION_RESET_3   (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x45)  // 0x16e5
+
+//========================================================================
+//  STB Registers End
+//========================================================================
+// ----------------------------
+// ASYNC FIFO (4)
+// ----------------------------
+//#define ASYNC_FIFO_REG0                            0x2310
+//#define ASYNC_FIFO_REG1                            0x2311
+    #define ASYNC_FIFO_FLUSH_STATUS     31
+    #define ASYNC_FIFO_ERR              30
+    #define ASYNC_FIFO_FIFO_EMPTY       29
+    #define ASYNC_FIFO_TO_HIU           24
+    #define ASYNC_FIFO_FLUSH            23
+    #define ASYNC_FIFO_RESET            22
+    #define ASYNC_FIFO_WRAP_EN          21
+    #define ASYNC_FIFO_FLUSH_EN         20
+    #define ASYNC_FIFO_RESIDUAL_MSB     19
+    #define ASYNC_FIFO_RESIDUAL_LSB     15
+    #define ASYNC_FIFO_FLUSH_CNT_MSB    14
+    #define ASYNC_FIFO_FLUSH_CNT_LSB    0
+//#define ASYNC_FIFO_REG2                            0x2312
+    #define ASYNC_FIFO_FIFO_FULL        26
+    #define ASYNC_FIFO_FILL_STATUS      25
+    #define ASYNC_FIFO_SOURCE_MSB       24
+    #define ASYNC_FIFO_SOURCE_LSB       23
+    #define ASYNC_FIFO_ENDIAN_MSB       22
+    #define ASYNC_FIFO_ENDIAN_LSB       21
+    #define ASYNC_FIFO_FILL_EN          20
+    #define ASYNC_FIFO_FILL_CNT_MSB     19
+    #define ASYNC_FIFO_FILL_CNT_LSB     0
+//#define ASYNC_FIFO_REG3                            0x2313
+    #define ASYNC_FLUSH_SIZE_IRQ_MSB    15
+    #define ASYNC_FLUSH_SIZE_IRQ_LSB    0
+// ----------------------------
+// ASYNC FIFO (4)
+// ----------------------------
+//#define ASYNC_FIFO2_REG0                           0x2314
+//#define ASYNC_FIFO2_REG1                           0x2315
+//#define ASYNC_FIFO2_REG2                           0x2316
+//#define ASYNC_FIFO2_REG3                           0x2317
+
+#define RESET_DEMUXSTB      (1<<1)
+
+#endif // C_STB_DEFINE_H
+
diff --git a/arch/arm/mach-meson8b/include/mach/meson-secure.h b/arch/arm/mach-meson8b/include/mach/meson-secure.h
new file mode 100755
index 000000000000..eace291edc14
--- /dev/null
+++ b/arch/arm/mach-meson8b/include/mach/meson-secure.h
@@ -0,0 +1,119 @@
+/*
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Secure Definition
+ *
+ * Copyright (C) 2013 Amlogic, Inc.
+ *
+ * Author: Platform-SH@amlogic.com
+ *
+ */
+
+#ifndef MESON_ARCH_MESON_SECURE_H
+#define MESON_ARCH_MESON_SECURE_H
+
+/* Meson Secure Monitor/HAL APIs */
+#define CALL_TRUSTZONE_API                      0x1
+#define CALL_TRUSTZONE_MON                      0x4
+#define CALL_TRUSTZONE_HAL_API                  0x5
+
+/* Secure Monitor mode APIs */
+#define TRUSTZONE_MON_TYPE_MASK                 0xF00
+#define TRUSTZONE_MON_FUNC_MASK                 0x0FF
+#define TRUSTZONE_MON_L2X0                      0x100
+#define TRUSTZONE_MON_L2X0_CTRL_INDEX           0x101
+#define TRUSTZONE_MON_L2X0_AUXCTRL_INDEX        0x102
+#define TRUSTZONE_MON_L2X0_PREFETCH_INDEX       0x103
+#define TRUSTZONE_MON_L2X0_TAGLATENCY_INDEX     0x104
+#define TRUSTZONE_MON_L2X0_DATALATENCY_INDEX    0x105
+#define TRUSTZONE_MON_L2X0_FILTERSTART_INDEX    0x106
+#define TRUSTZONE_MON_L2X0_FILTEREND_INDEX      0x107
+#define TRUSTZONE_MON_L2X0_DEBUG_INDEX          0x108
+#define TRUSTZONE_MON_L2X0_POWER_INDEX          0x109
+
+#define TRUSTZONE_MON_CORE                      0x200
+#define TRUSTZONE_MON_CORE_RD_CTRL_INDEX        0x201
+#define TRUSTZONE_MON_CORE_WR_CTRL_INDEX        0x202
+#define TRUSTZONE_MON_CORE_RD_STATUS0_INDEX     0x203
+#define TRUSTZONE_MON_CORE_WR_STATUS0_INDEX     0x204
+#define TRUSTZONE_MON_CORE_RD_STATUS1_INDEX     0x205
+#define TRUSTZONE_MON_CORE_WR_STATUS1_INDEX     0x206
+#define TRUSTZONE_MON_CORE_BOOTADDR_INDEX       0x207
+#define TRUSTZONE_MON_CORE_DDR_INDEX            0x208
+#define TRUSTZONE_MON_CORE_RD_SOC_REV1          0x209
+#define TRUSTZONE_MON_CORE_RD_SOC_REV2          0x20A
+
+#define TRUSTZONE_MON_SUSPNED_FIRMWARE          0x300
+#define TRUSTZONE_MON_SAVE_CPU_GIC              0x400
+
+#define TRUSTZONE_MON_RTC                       0x500
+#define TRUSTZONE_MON_RTC_RD_REG_INDEX          0x501
+#define TRUSTZONE_MON_RTC_WR_REG_INDEX          0x502
+
+/* Secure HAL APIs*/
+#define TRUSTZONE_HAL_API_EFUSE                 0x100
+#define TRUSTZONE_HAL_API_STORAGE               0x200
+#define TRUSTZONE_HAL_API_MEMCONFIG             0x300
+
+#define MESON_TRUSTZONE_MEM_START               0x06100000
+#define MESON_TRUSTZONE_MEM_SIZE                0x04000000
+
+
+#ifndef __ASSEMBLER__
+extern void meson_smc1(u32 fn, u32 arg);
+extern int meson_smc_hal_api(u32 cmdidx, u32 arg);
+extern int meson_smc2(u32 arg);
+extern int meson_smc3(u32 arg1, u32 arg2);
+extern u32 meson_read_corectrl(void);
+extern u32 meson_modify_corectrl(u32 arg);
+extern u32 meson_read_corestatus(u32 cpu);
+extern u32 meson_modify_corestatus(u32 cpu, u32 arg);
+extern void meson_auxcoreboot_addr(u32 arg1, u32 arg2);
+extern void meson_suspend_firmware(void);
+extern uint32_t meson_secure_reg_read(uint32_t addr);
+extern uint32_t meson_secure_reg_write(uint32_t addr, uint32_t val);
+extern u32 meson_read_socrev1(void);
+extern u32 meson_read_socrev2(void);
+extern uint32_t meson_secure_mem_size(void);
+extern uint32_t meson_secure_mem_end(void);
+
+// efuse HAL_API arg
+struct efuse_hal_api_arg{
+	unsigned int cmd;		// R/W
+	unsigned int offset;
+	unsigned int size;
+	unsigned int buffer_phy;
+	unsigned int retcnt_phy;	
+};
+#define EFUSE_HAL_API_READ	0
+#define EFUSE_HAL_API_WRITE 1
+extern int meson_trustzone_efuse(struct efuse_hal_api_arg* arg);
+
+
+//memconfig HAL_API arg
+struct memconfig{
+	unsigned char name[64];
+	unsigned int start_phy_addr;
+	unsigned int end_phy_addr;
+};
+struct memconfig_hal_api_arg{
+	unsigned int memconfigbuf_phy_addr;
+	unsigned int memconfigbuf_count;
+};
+#define MEMCONFIG_NUM	2
+extern int meson_trustzone_memconfig(void);
+extern unsigned int meson_trustzone_getmemsecure_size(void);
+extern int meson_trustzone_getmemconfig(unsigned char* name, unsigned int* startphyaddr, unsigned int* endphyaddr);
+
+#endif
+
+
+#endif
diff --git a/arch/arm/mach-meson8b/include/mach/misc.h b/arch/arm/mach-meson8b/include/mach/misc.h
deleted file mode 100644
index 483abff2f1fd..000000000000
--- a/arch/arm/mach-meson8b/include/mach/misc.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- *
- *
- *  Copyright (C) 2010 AMLOGIC, INC.
- *
- * License terms: GNU General Public License (GPL) version 2
- * Basic register address definitions in physical memory and
- * some block defintions for core devices like the timer.
- * copy from linux kernel
- */
-
-/*
- * Temp solution file for M6 define
-*/
-#ifndef __MACH_MESSON_FIRM_REGS_H
-#define __MACH_MESSON_FIRM_REGS_H
-
-#define IO_CBUS_BASE2  0xc1100000
-
-#define NAND_CMD  ((0xc1108600-IO_CBUS_BASE2)>>2)
-#define NAND_CFG  ((0xc1108604-IO_CBUS_BASE2)>>2)
-#define NAND_DADR ((0xc1108608-IO_CBUS_BASE2)>>2)
-#define NAND_IADR ((0xc110860c-IO_CBUS_BASE2)>>2)
-#define NAND_BUF  ((0xc1108610-IO_CBUS_BASE2)>>2)
-#define NAND_INFO ((0xc1108614-IO_CBUS_BASE2)>>2)
-#define NAND_DC   ((0xc1108618-IO_CBUS_BASE2)>>2)
-#define NAND_ADR  ((0xc110861c-IO_CBUS_BASE2)>>2)
-#define NAND_DL   ((0xc1108620-IO_CBUS_BASE2)>>2)
-#define NAND_DH   ((0xc1108624-IO_CBUS_BASE2)>>2)
-#define NAND_CADR ((0xc1108628-IO_CBUS_BASE2)>>2)
-#define NAND_SADR ((0xc110862c-IO_CBUS_BASE2)>>2)
-
-#define P_NAND_CMD                                CBUS_REG_ADDR(NAND_CMD)
-#define P_NAND_CFG                                CBUS_REG_ADDR(NAND_CFG)
-#define P_NAND_DADR                               CBUS_REG_ADDR(NAND_DADR)
-#define P_NAND_IADR                               CBUS_REG_ADDR(NAND_IADR)
-#define P_NAND_BUF                                CBUS_REG_ADDR(NAND_BUF)
-#define P_NAND_INFO                               CBUS_REG_ADDR(NAND_INFO)
-#define P_NAND_DC                                 CBUS_REG_ADDR(NAND_DC)
-#define P_NAND_ADR                                CBUS_REG_ADDR(NAND_ADR)
-#define P_NAND_DL                                 CBUS_REG_ADDR(NAND_DL)
-#define P_NAND_DH                                 CBUS_REG_ADDR(NAND_DH)
-#define P_NAND_CADR                               CBUS_REG_ADDR(NAND_CADR)
-#define P_NAND_SADR                               CBUS_REG_ADDR(NAND_SADR)
-
-#define VPP_OSD2_PREBLEND           (1 << 17)
-#define VPP_OSD1_PREBLEND           (1 << 16)
-#define VPP_VD2_PREBLEND            (1 << 15)
-#define VPP_VD1_PREBLEND            (1 << 14)
-#define VPP_OSD2_POSTBLEND          (1 << 13)
-#define VPP_OSD1_POSTBLEND          (1 << 12)
-#define VPP_VD2_POSTBLEND           (1 << 11)
-#define VPP_VD1_POSTBLEND           (1 << 10)
-#define VPP_POSTBLEND_EN			(1 << 7)
-#define VPP_PRE_FG_OSD2             (1 << 5)
-#define VPP_PREBLEND_EN             (1 << 6)
-#define VPP_POST_FG_OSD2            (1 << 4)
-
-#define I2SIN_DIR       0    // I2S CLK and LRCLK direction. 0 : input 1 : output.
-#define I2SIN_CLK_SEL    1    // I2S clk selection : 0 : from pad input. 1 : from AIU.
-#define I2SIN_LRCLK_SEL 2
-#define I2SIN_POS_SYNC  3
-#define I2SIN_LRCLK_SKEW 4    // 6:4
-#define I2SIN_LRCLK_INVT 7
-#define I2SIN_SIZE       8    //9:8 : 0 16 bit. 1 : 18 bits 2 : 20 bits 3 : 24bits.
-#define I2SIN_CHAN_EN   10    //13:10. 
-#define I2SIN_EN        15
-
-#define AUDIN_FIFO0_EN       0
-#define AUDIN_FIFO0_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
-         
-#define AUDIN_FIFO0_DIN_SEL  3
-            // 0     spdifIN
-            // 1     i2Sin
-            // 2     PCMIN
-            // 3     HDMI in
-            // 4     DEMODULATOR IN
-#define AUDIN_FIFO0_ENDIAN   8    //10:8   data endian control.
-#define AUDIN_FIFO0_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
-#define AUDIN_FIFO0_UG       15    // urgent request enable.
-
-#define AUDIN_FIFO1_EN       0
-#define AUDIN_FIFO1_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
-         
-#define AUDIN_FIFO1_DIN_SEL  3
-            // 0     spdifIN
-            // 1     i2Sin
-            // 2     PCMIN
-            // 3     HDMI in
-            // 4     DEMODULATOR IN
-#define AUDIN_FIFO1_ENDIAN   8    //10:8   data endian control.
-#define AUDIN_FIFO1_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
-#define AUDIN_FIFO1_UG       15    // urgent request enable.
-
-/*BT656 MACRO */
-//#define BT_CTRL 0x2240 	///../ucode/register.h
-#define BT_SYSCLOCK_RESET    30      //Sync fifo soft  reset_n at system clock domain.     Level reset. 0 = reset. 1 : normal mode.
-#define BT_656CLOCK_RESET    29      //Sync fifo soft reset_n at bt656 clock domain.   Level reset.  0 = reset.  1 : normal mode.
-//    #define BT_VSYNC_SEL              25      //25:26 VDIN VS selection.   00 :  SOF.  01: EOF.   10: vbi start point.  11 : vbi end point.
-//    #define BT_HSYNC_SEL              23      //24:23 VDIN HS selection.  00 : EAV.  01: SAV.    10:  EOL.  11: SOL
-#define BT_CAMERA_MODE        22      // Camera_mode
-#define BT_CLOCK_ENABLE        7	// 1: enable bt656 clock. 0: disable bt656 clock.
-
-//#define BT_PORT_CTRL 0x2249 	///../ucode/register.h
-//    #define BT_VSYNC_MODE      23  //1: use  vsync  as the VBI start point. 0: use the regular vref.
-//    #define BT_HSYNC_MODE      22  //1: use hsync as the active video start point.  0. Use regular sav and eav. 
-#define BT_SOFT_RESET           31	// Soft reset
-//    #define BT_JPEG_START           30
-//    #define BT_JPEG_IGNORE_BYTES    18	//20:18
-//    #define BT_JPEG_IGNORE_LAST     17
-#define BT_UPDATE_ST_SEL        16
-#define BT_COLOR_REPEAT         15
-//    #define BT_VIDEO_MODE           13	// 14:13
-#define BT_AUTO_FMT             12
-#define BT_PROG_MODE            11
-//    #define BT_JPEG_MODE            10
-#define BT_XCLK27_EN_BIT        9	// 1 : xclk27 is input.     0 : xclk27 is output.
-#define BT_FID_EN_BIT           8	// 1 : enable use FID port.
-#define BT_CLK27_SEL_BIT        7	// 1 : external xclk27      0 : internal clk27.
-//    #define BT_CLK27_PHASE_BIT      6	// 1 : no inverted          0 : inverted.
-//    #define BT_ACE_MODE_BIT         5	// 1 : auto cover error by hardware.
-#define BT_SLICE_MODE_BIT       4	// 1 : no ancillay flag     0 : with ancillay flag.
-#define BT_FMT_MODE_BIT         3	// 1 : ntsc                 0 : pal.
-#define BT_REF_MODE_BIT         2	// 1 : from bit stream.     0 : from ports.
-#define BT_MODE_BIT             1	// 1 : BT656 model          0 : SAA7118 mode.
-#define BT_EN_BIT               0	// 1 : enable.
-#define BT_VSYNC_PHASE      0
-#define BT_HSYNC_PHASE      1
-//    #define BT_VSYNC_PULSE      2
-//    #define BT_HSYNC_PULSE      3
-//    #define BT_FID_PHASE        4
-#define BT_FID_HSVS         5
-#define BT_IDQ_EN           6
-#define BT_IDQ_PHASE        7
-#define BT_D8B              8
-//    #define BT_10BTO8B          9
-#define BT_FID_DELAY       10	//12:10
-#define BT_VSYNC_DELAY     13	//
-#define BT_HSYNC_DELAY     16
-
-
-
-#endif
diff --git a/arch/arm/mach-meson8b/include/mach/mod_gate.h b/arch/arm/mach-meson8b/include/mach/mod_gate.h
old mode 100644
new mode 100755
index 9a338986714c..990e8e3680ae
--- a/arch/arm/mach-meson8b/include/mach/mod_gate.h
+++ b/arch/arm/mach-meson8b/include/mach/mod_gate.h
@@ -9,7 +9,8 @@ typedef enum {
     MOD_HDMI,
     MOD_VENC,
     MOD_TCON,
-    MOD_LVDS,
+    //MOD_LVDS,
+    MOD_LCD,
     MOD_SPI,
     MOD_UART0,
     MOD_UART1,
diff --git a/arch/arm/mach-meson8b/include/mach/power_gate.h b/arch/arm/mach-meson8b/include/mach/power_gate.h
old mode 100644
new mode 100755
index 8dcf9e248ca2..999b0bf4570f
--- a/arch/arm/mach-meson8b/include/mach/power_gate.h
+++ b/arch/arm/mach-meson8b/include/mach/power_gate.h
@@ -31,7 +31,7 @@ extern spinlock_t gate_lock;
 
 #define CLK_GATE_ON(_MOD) \
 	do{                     \
-		int flags; \
+		unsigned long flags; \
 		spin_lock_irqsave(&gate_lock, flags); \
 		__CLK_GATE_ON(_MOD); \
 		spin_unlock_irqrestore(&gate_lock, flags); \
@@ -39,7 +39,7 @@ extern spinlock_t gate_lock;
 	
 #define CLK_GATE_OFF(_MOD) \
 	do{                     \
-		int flags; \
+		unsigned long flags; \
 		spin_lock_irqsave(&gate_lock, flags); \
 		__CLK_GATE_OFF(_MOD); \
 		spin_unlock_irqrestore(&gate_lock, flags); \
diff --git a/arch/arm/mach-meson8b/include/mach/sd.h b/arch/arm/mach-meson8b/include/mach/sd.h
old mode 100644
new mode 100755
index c2f893591974..5ad591571b04
--- a/arch/arm/mach-meson8b/include/mach/sd.h
+++ b/arch/arm/mach-meson8b/include/mach/sd.h
@@ -70,6 +70,7 @@ struct amlsd_platform {
 	unsigned int clkc_w;
 	unsigned int ctrl;
 	unsigned int clock;
+	unsigned int tune_phase;            /* store tuning result */
 	unsigned char signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
 
 	unsigned int low_burst;
@@ -87,6 +88,7 @@ struct amlsd_platform {
 
     int is_sduart;
     bool is_in;
+    bool is_tuned;                      /* if card has been tuning */
 
     /* we used this flag to filter some unnecessary cmd before initialized flow */
     bool is_fir_init; // has been initialized for the first time
@@ -634,21 +636,36 @@ extern struct mmc_host *sdio_host;
 		printk("[%s] " fmt, __FUNCTION__, ##args);	\
 }while(0)
 
-
 #define print_dbg(fmt, args...) do{\
 	printk("[%s]\033[0;40;35m " fmt "\033[0m", __FUNCTION__, ##args);  \
 }while(0)
 
+//for external codec status, if using external codec, jtag should not be set. 
+extern int ext_codec;
 
+#ifndef CONFIG_MESON_TRUSTZONE
 // P_AO_SECURE_REG1 is "Secure Register 1" in <M8-Secure-AHB-Registers.doc>
 #define aml_jtag_gpioao() do{\
     aml_clr_reg32_mask(P_AO_SECURE_REG1, ((1<<5) | (1<<9))); \
+    if(!ext_codec)\
+        aml_set_reg32_mask(P_AO_SECURE_REG1, ((1<<8) | (1<<1))); \
 }while(0)
 
 #define aml_jtag_sd() do{\
     aml_clr_reg32_mask(P_AO_SECURE_REG1, ((1<<8) | (1<<1))); \
     aml_set_reg32_mask(P_AO_SECURE_REG1, ((1<<5) | (1<<9))); \
 }while(0)
+#else
+/* Secure REG can only be accessed in Secure World if TrustZone enabled.*/
+#include <mach/meson-secure.h>
+#define aml_jtag_gpioao() do {\
+	meson_secure_reg_write(P_AO_SECURE_REG1, meson_secure_reg_read(P_AO_SECURE_REG1) & (~((1<<5) | (1<<9)))); \
+} while(0)
+#define aml_jtag_sd() do {\
+	meson_secure_reg_write(P_AO_SECURE_REG1, meson_secure_reg_read(P_AO_SECURE_REG1) & (~(1<<8) | (1<<1))); \
+	meson_secure_reg_write(P_AO_SECURE_REG1, meson_secure_reg_read(P_AO_SECURE_REG1) | ((1<<5) | (1<<9))); \
+} while(0)
+#endif /* CONFIG_MESON_TRUSTZONE */
 
 #define aml_uart_pinctrl() do {\
     \
diff --git a/arch/arm/mach-meson8b/include/mach/tvregs.h b/arch/arm/mach-meson8b/include/mach/tvregs.h
old mode 100644
new mode 100755
index 207676f9c0a4..6b6feaee676a
--- a/arch/arm/mach-meson8b/include/mach/tvregs.h
+++ b/arch/arm/mach-meson8b/include/mach/tvregs.h
@@ -60,8 +60,6 @@ static const  reg_t tvreg_vclk_hd[]={
 };
 
 static const  reg_t tvregs_720p[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,          0xff,  },
 
     {P_HHI_VID_CLK_CNTL,           0x0,},
@@ -129,8 +127,6 @@ static const  reg_t tvregs_720p[] = {
 };
 
 static const  reg_t tvregs_720p_50hz[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,          0xff,  },
     {P_HHI_VID_CLK_CNTL,           0x0,},
     {P_HHI_VID_PLL_CNTL2,          0x814d3928},
@@ -218,8 +214,6 @@ static const  reg_t tvregs_720p_50hz[] = {
 };
 
 static const reg_t tvregs_480i[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,            0xff,  },
 
     {P_HHI_VID_CLK_CNTL,           0x0,       },
@@ -340,8 +334,6 @@ static const reg_t tvregs_480cvbs[] = {
     {P_ENCI_DACSEL_1,                0x11   },
     {P_ENCP_VIDEO_EN,                0,     },
     {P_ENCI_VIDEO_EN,                1,     },
-    {P_HHI_VDAC_CNTL0,               0x650001   },
-    {P_HHI_VDAC_CNTL1,               0x1        },
     {P_ENCI_VIDEO_SAT,               0x7        },
     {P_VENC_VDAC_DAC0_FILT_CTRL0,    0x1        },
     {P_VENC_VDAC_DAC0_FILT_CTRL1,    0xfc48     },
@@ -350,8 +342,6 @@ static const reg_t tvregs_480cvbs[] = {
 };
 
 static const reg_t tvregs_480p[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,          0xff,  },
     {P_HHI_VID_CLK_CNTL,           0x0,       },
     {P_HHI_VID_PLL_CNTL,           0x2001042d,},
@@ -421,8 +411,6 @@ static const reg_t tvregs_480p[] = {
 };
 
 static const reg_t tvregs_576i[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,               0xff,      },
 
     {P_HHI_VID_CLK_CNTL,           0x0,       },
@@ -543,8 +531,6 @@ static const reg_t tvregs_576cvbs[] = {
     {P_ENCI_DACSEL_1,                   0x11       },
     {P_ENCP_VIDEO_EN,                   0,         },
     {P_ENCI_VIDEO_EN,                   1,         },
-    {P_HHI_VDAC_CNTL0,                  0x650001   },
-    {P_HHI_VDAC_CNTL1,                  0x1        },
     {P_ENCI_VIDEO_SAT,                  0x7        },
     {P_VENC_VDAC_DAC0_FILT_CTRL0,       0x1        },
     {P_VENC_VDAC_DAC0_FILT_CTRL1,       0xfc48     },
@@ -553,8 +539,6 @@ static const reg_t tvregs_576cvbs[] = {
 };
 
 static const reg_t tvregs_576p[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,          0xff,      },
     {P_HHI_VID_CLK_CNTL,           0x0,       },
     {P_HHI_VID_PLL_CNTL,           0x2001042d,},
@@ -624,8 +608,6 @@ static const reg_t tvregs_576p[] = {
 };
 
 static const reg_t tvregs_1080i[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,          0xff,  },
 //	{VCLK_HD},
     {P_HHI_VID_CLK_CNTL,           0x0,},
@@ -691,8 +673,6 @@ static const reg_t tvregs_1080i[] = {
 };
 
 static const reg_t tvregs_1080i_50hz[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,          0xff,  },
 //	{VCLK_HD},
     {P_HHI_VID_CLK_CNTL,           0x0,},
@@ -780,8 +760,6 @@ static const reg_t tvregs_1080i_50hz[] = {
 };
 
 static const reg_t tvregs_1080p[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,          0xff,  },
 
     {P_HHI_VID_CLK_CNTL,           0x0,},
@@ -843,8 +821,6 @@ static const reg_t tvregs_1080p[] = {
 };
 
 static const reg_t tvregs_1080p_50hz[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,          0xff,  },
     {P_HHI_VID_CLK_CNTL,           0x0,},
     {P_HHI_VID_PLL_CNTL2,          0x814d3928},
@@ -933,8 +909,6 @@ static const reg_t tvregs_1080p_50hz[] = {
 };
 
 static const reg_t tvregs_1080p_24hz[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_VENC_VDAC_SETTING,          0xff,  },
     {P_HHI_VID_CLK_CNTL,           0x0,},
     {P_HHI_VID_PLL_CNTL2,          0x814d3928},
@@ -1023,8 +997,6 @@ static const reg_t tvregs_1080p_24hz[] = {
 };
 
 static const reg_t tvregs_4k2k_30hz[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
     {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
     {P_ENCP_VIDEO_YFP1_HTIME,       140},
@@ -1058,8 +1030,6 @@ static const reg_t tvregs_4k2k_30hz[] = {
 };
 
 static const reg_t tvregs_4k2k_25hz[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
     {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
     {P_ENCP_VIDEO_YFP1_HTIME,       140},
@@ -1093,8 +1063,6 @@ static const reg_t tvregs_4k2k_25hz[] = {
 };
 
 static const reg_t tvregs_4k2k_24hz[] = {
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
     {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
     {P_ENCP_VIDEO_YFP1_HTIME,       140},
@@ -1129,8 +1097,6 @@ static const reg_t tvregs_4k2k_24hz[] = {
 };
 
 static const reg_t tvregs_4k2k_smpte[] = {      //24hz
-    {P_HHI_VDAC_CNTL0,               0x0   },
-    {P_HHI_VDAC_CNTL1,               0x8   },
     {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
     {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
     {P_ENCP_VIDEO_YFP1_HTIME,       140},
diff --git a/arch/arm/mach-meson8b/include/mach/vpp.h b/arch/arm/mach-meson8b/include/mach/vpp.h
new file mode 100755
index 000000000000..93482df13582
--- /dev/null
+++ b/arch/arm/mach-meson8b/include/mach/vpp.h
@@ -0,0 +1,17 @@
+#ifndef __MACH_MESSON_VPP_REGS_H
+#define __MACH_MESSON_VPP_REGS_H
+
+#define VPP_OSD2_PREBLEND           (1 << 17)
+#define VPP_OSD1_PREBLEND           (1 << 16)
+#define VPP_VD2_PREBLEND            (1 << 15)
+#define VPP_VD1_PREBLEND            (1 << 14)
+#define VPP_OSD2_POSTBLEND          (1 << 13)
+#define VPP_OSD1_POSTBLEND          (1 << 12)
+#define VPP_VD2_POSTBLEND           (1 << 11)
+#define VPP_VD1_POSTBLEND           (1 << 10)
+#define VPP_POSTBLEND_EN			(1 << 7)
+#define VPP_PRE_FG_OSD2             (1 << 5)
+#define VPP_PREBLEND_EN             (1 << 6)
+#define VPP_POST_FG_OSD2            (1 << 4)
+
+#endif
diff --git a/arch/arm/mach-meson8b/meson-secure.c b/arch/arm/mach-meson8b/meson-secure.c
new file mode 100755
index 000000000000..23687aca94ca
--- /dev/null
+++ b/arch/arm/mach-meson8b/meson-secure.c
@@ -0,0 +1,192 @@
+/*
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Meson secure APIs.
+ *
+ * Copyright (C) 2013 Amlogic, Inc.
+ *
+ * Author: Platform-SH@amlogic.com
+ *         Platform-BJ@amlogic.com
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <plat/io.h>
+#include <plat/regops.h>
+#include <linux/printk.h>
+#include <linux/string.h>
+#include <asm/cacheflush.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <linux/dma-mapping.h>
+#include <mach/io.h>
+
+#ifdef CONFIG_MESON_TRUSTZONE
+#include <mach/meson-secure.h>
+#endif
+#include <linux/sched.h>
+
+#define MESON_SECURE_DEBUG 0
+#ifdef MESON_SECURE_DEBUG
+#define TZDBG(fmt, args...) printk("meson-secure: " fmt, ## args);
+#else
+#define TZDBG(fmt, args...)
+#endif
+
+/*
+int meson_secure_memblock(unsigned startaddr, unsigned endaddr, struct secure_memblock_ctrl* pctrl)
+{
+	int ret;
+	struct secure_memblock_info memblock_info;
+
+	if(!pctrl)
+		return -1;
+	if(((startaddr & 0xffff) != 0) || ((endaddr&0xffff)!=0xffff)){
+		printk("secure memory block must be 16 bits align!\n");
+		return -1;
+	}
+
+	memblock_info.startaddr = startaddr;
+	memblock_info.endaddr = endaddr;
+	memcpy(&(memblock_info.memblock_ctrl), pctrl, sizeof(memblock_info.memblock_ctrl));
+	__cpuc_flush_dcache_area((void*)&memblock_info, sizeof(memblock_info));
+	outer_clean_range(__pa(&memblock_info), __pa(&memblock_info+1));
+
+	ret = meson_smc_internal_api(INTERNAL_API_MEMBLOCK_CONFIG, __pa(&memblock_info));
+	return ret;
+}
+*/
+
+struct memconfig memsecure[MEMCONFIG_NUM] = {0};
+int meson_trustzone_memconfig(void)
+{
+	int ret;
+	struct memconfig_hal_api_arg arg;
+
+	arg.memconfigbuf_phy_addr = __pa(memsecure);
+	arg.memconfigbuf_count = MEMCONFIG_NUM;
+
+	__cpuc_flush_dcache_area(memsecure, sizeof(memsecure));
+	outer_clean_range(__pa(memsecure), (__pa(memsecure + MEMCONFIG_NUM)));
+	__cpuc_flush_dcache_area(&arg, sizeof(arg));
+	outer_clean_range(__pa(&arg), __pa(((struct memconfig_hal_api_arg*)&arg)) + 1);
+
+	ret = meson_smc_hal_api(TRUSTZONE_HAL_API_MEMCONFIG, __pa(&arg));
+
+	outer_inv_range(__pa(&arg), __pa(((struct memconfig_hal_api_arg*)&arg)) + 1);
+	dmac_unmap_area(&arg, sizeof(arg), DMA_FROM_DEVICE);
+	outer_inv_range(__pa(memsecure), __pa(memsecure + MEMCONFIG_NUM));
+	dmac_unmap_area(memsecure, sizeof(memsecure), DMA_FROM_DEVICE);
+
+	return ret;
+}
+
+unsigned int meson_trustzone_getmemsecure_size(void)
+{
+	unsigned int size = 0;
+	int i;
+	for (i = 0; i < MEMCONFIG_NUM; i++) {
+		if ((memsecure[i].start_phy_addr != 0) && (memsecure[i].end_phy_addr != 0)) {
+			size += memsecure[i].end_phy_addr - memsecure[i].start_phy_addr + 1;
+		}
+	}
+	return size;
+}
+
+int meson_trustzone_getmemconfig(unsigned char* name, unsigned int* startphyaddr, unsigned int* endphyaddr)
+{
+	unsigned int i;
+	for (i = 0; i < MEMCONFIG_NUM; i++) {
+		if (strcmp(name, memsecure[i].name) == 0) {
+			break;
+		}
+	}
+	if (i == MEMCONFIG_NUM) {
+		return -1;
+	}
+	if ((memsecure[i].start_phy_addr == 0) || (memsecure[i].end_phy_addr == 0)) {
+		return -1;
+	}
+
+	*startphyaddr = memsecure[i].start_phy_addr;
+	*endphyaddr = memsecure[i].end_phy_addr;
+	return 0;
+}
+
+int meson_trustzone_efuse(struct efuse_hal_api_arg* arg)
+{
+	int ret;
+	if (!arg) {
+		return -1;
+	}
+	set_cpus_allowed_ptr(current, cpumask_of(0));
+	__cpuc_flush_dcache_area(__va(arg->buffer_phy), arg->size);
+	outer_clean_range((arg->buffer_phy), (arg->buffer_phy + arg->size));
+
+	__cpuc_flush_dcache_area(__va(arg->retcnt_phy), sizeof(unsigned int));
+	outer_clean_range(arg->retcnt_phy, (arg->retcnt_phy + sizeof(unsigned int)));
+
+	__cpuc_flush_dcache_area((void*)arg, sizeof(struct efuse_hal_api_arg));
+	outer_clean_range(__pa(arg), __pa(arg + 1));
+
+	ret = meson_smc_hal_api(TRUSTZONE_HAL_API_EFUSE, __pa(arg));
+
+	if (arg->cmd == EFUSE_HAL_API_READ) {
+		outer_inv_range((arg->buffer_phy), (arg->buffer_phy + arg->size));
+		dmac_unmap_area(__va(arg->buffer_phy), arg->size, DMA_FROM_DEVICE);
+	}
+	outer_inv_range((arg->retcnt_phy), (arg->retcnt_phy + sizeof(unsigned int)));
+	dmac_unmap_area(__va(arg->buffer_phy), arg->size, DMA_FROM_DEVICE);
+	set_cpus_allowed_ptr(current, cpu_all_mask);
+
+	return ret;
+}
+
+uint32_t meson_secure_reg_read(uint32_t addr)
+{
+	uint32_t ret;
+	uint32_t paddr;
+	int offset;
+
+	offset = IO_SECBUS_PHY_BASE - IO_SECBUS_BASE;
+	paddr = addr + offset;
+	ret = meson_smc2(paddr);
+	TZDBG("read [0x%x]=%x\n", paddr, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(meson_secure_reg_read);
+
+uint32_t meson_secure_reg_write(uint32_t addr, uint32_t val)
+{
+	uint32_t ret;
+	uint32_t paddr;
+	int offset;
+
+	offset = IO_SECBUS_PHY_BASE - IO_SECBUS_BASE;
+	paddr = addr + offset;
+	ret = meson_smc3(paddr, val);
+	TZDBG("write [0x%x 0x%x]=%x\n", paddr, val, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(meson_secure_reg_write);
+
+uint32_t meson_secure_mem_size(void)
+{
+	return MESON_TRUSTZONE_MEM_SIZE;
+}
+
+uint32_t meson_secure_mem_end(void)
+{
+	return (MESON_TRUSTZONE_MEM_START + MESON_TRUSTZONE_MEM_SIZE);
+}
diff --git a/arch/arm/mach-meson8b/meson-smc.S b/arch/arm/mach-meson8b/meson-smc.S
new file mode 100755
index 000000000000..03d9c26a5b06
--- /dev/null
+++ b/arch/arm/mach-meson8b/meson-smc.S
@@ -0,0 +1,151 @@
+/*
+ * Meson secure APIs file.
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *  Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software,you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Secure Definition
+ *
+ * Copyright (C) 2013 Amlogic, Inc.
+ *
+ * Author: Platform-BJ@amlogic.com
+ *
+ */
+
+#include <linux/linkage.h>
+#include <mach/meson-secure.h>
+
+/*
+ * This is common routine to manage secure monitor API
+ * used to modify the PL310 secure registers.
+ * 'r1' contains the value to be modified and 'r0' contains
+ * the monitor API number. It uses few CPU registers
+ * internally and hence they need be backed up including
+ * link register "lr".
+ * Function signature : void meson_smc1(u32 fn, u32 arg)
+ */
+
+ENTRY(meson_smc1)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r1
+    mov r1, r0
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_smc1)
+
+ENTRY(meson_smc_hal_api)
+	stmfd sp!, {r3-r12, lr}	
+	mov r2, r1
+	mov r1, r0
+	ldr r0, =CALL_TRUSTZONE_HAL_API
+	dsb
+	smc #0
+	ldmfd sp!, {r3-r12, pc}
+ENDPROC(meson_smc_hal_api)
+
+ENTRY(meson_smc2)
+    stmfd sp!, {r2-r12, lr}
+    mov r1, r0
+    ldr r0, =0x2
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_smc2)
+
+ENTRY(meson_smc3)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r1
+    mov r1, r0
+    ldr r0, =0x3
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_smc3)
+
+ENTRY(meson_read_corectrl)
+    stmfd sp!, {r2-r12, lr}
+    ldr r1, =TRUSTZONE_MON_CORE_RD_CTRL_INDEX
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_read_corectrl)
+
+ENTRY(meson_modify_corectrl)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r0
+    ldr r1, =TRUSTZONE_MON_CORE_WR_CTRL_INDEX
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_modify_corectrl)
+
+ENTRY(meson_read_corestatus)
+    stmfd sp!, {r2-r12, lr}
+    ldr r1, =TRUSTZONE_MON_CORE_RD_STATUS0_INDEX
+    add r1, r1, r0, lsl #1
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_read_corestatus)
+
+ENTRY(meson_modify_corestatus)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r1
+    ldr r1, =TRUSTZONE_MON_CORE_WR_STATUS0_INDEX
+    add r1, r1, r0, lsl #1
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_modify_corestatus)
+
+ENTRY(meson_auxcoreboot_addr)
+    stmfd sp!, {r2-r12, lr}
+    mov r3, r1
+    mov r2, r0
+    ldr r1, =TRUSTZONE_MON_CORE_BOOTADDR_INDEX
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_auxcoreboot_addr)
+
+ENTRY(meson_suspend_firmware)
+    stmfd sp!, {r2-r12, lr}
+    mov r2, r0
+    ldr r1, =TRUSTZONE_MON_SUSPNED_FIRMWARE
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_suspend_firmware)
+
+ENTRY(meson_read_socrev1)
+    stmfd sp!, {r2-r12, lr}    
+    ldr r1, =TRUSTZONE_MON_CORE_RD_SOC_REV1
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_read_socrev1)
+
+ENTRY(meson_read_socrev2)
+    stmfd sp!, {r2-r12, lr}    
+    ldr r1, =TRUSTZONE_MON_CORE_RD_SOC_REV2
+    ldr r0, =CALL_TRUSTZONE_MON
+    dsb
+    smc #0
+    ldmfd sp!, {r2-r12, pc}
+ENDPROC(meson_read_socrev2)
\ No newline at end of file
diff --git a/arch/arm/mach-meson8b/pm.c b/arch/arm/mach-meson8b/pm.c
old mode 100644
new mode 100755
index e9bf62ae02cf..7f693d6f0ce4
--- a/arch/arm/mach-meson8b/pm.c
+++ b/arch/arm/mach-meson8b/pm.c
@@ -30,7 +30,10 @@
 #include <mach/clock.h>
 #include <plat/regops.h>
 #include <plat/io.h>
-
+#include <plat/wakeup.h>
+#ifdef CONFIG_MESON_TRUSTZONE
+#include <mach/meson-secure.h>
+#endif
 
 #ifdef CONFIG_SUSPEND_WATCHDOG
 #include <mach/watchdog.h>
@@ -76,6 +79,8 @@ static void wait_uart_empty(void)
 		udelay(100);
 	}while((aml_read_reg32(P_AO_UART_STATUS) & (1<<22)) == 0);	
 }
+struct clk* clk81;
+struct clk* clkxtal;
 
 void clk_switch(int flag)
 {
@@ -86,8 +91,7 @@ void clk_switch(int flag)
 		for (i = clk_count - 1; i >= 0; i--) {
 			if (clks[i].clk_flag) {
 				if (clks[i].clk_addr == P_HHI_MPEG_CLK_CNTL) {
-					struct clk* sys_clk = clk_get_sys("clk81", NULL);
-					uart_rate_clk = clk_get_rate(sys_clk);
+					uart_rate_clk = clk_get_rate(clk81);
 					wait_uart_empty();
 					aml_set_reg32_mask(clks[i].clk_addr,(1<<7));//gate on pll
 					udelay(10);
@@ -103,8 +107,7 @@ void clk_switch(int flag)
 	        for (i = 0; i < clk_count; i++) {
 	 		if (clks[i].clk_addr == P_HHI_MPEG_CLK_CNTL) {
 				if (aml_read_reg32(clks[i].clk_addr) & (1 << 8)) {
-					struct clk* sys_clk = clk_get_sys("xtal", NULL);
-					uart_rate_clk = clk_get_rate(sys_clk);
+					uart_rate_clk = clk_get_rate(clkxtal);
 					clks[i].clk_flag  = 1;
 					wait_uart_empty();
 					aml_clr_reg32_mask(clks[i].clk_addr, (1 << 8)); // gate off from pll
@@ -270,10 +273,14 @@ static void meson_pm_suspend(void)
 	if(det_pwr_key())//get pwr key and wakeup im
 	{
 		clr_pwr_key();
-		WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0x1234abcd);
+		WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, FLAG_WAKEUP_PWRKEY);
 	}else{
 #ifdef CONFIG_MESON_SUSPEND
+#ifdef CONFIG_MESON_TRUSTZONE
+		meson_suspend_firmware();
+#else
 		meson_power_suspend();
+#endif
 #else
 #if 0
 		//k101 power key
@@ -283,16 +290,14 @@ static void meson_pm_suspend(void)
 			udelay(1000);
 		}while((aml_read_reg32(P_AO_GPIO_I)&(1<<3)));
 #endif
-		WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0x1234abcd);
 #endif
 	}
 	aml_set_reg32_mask(P_HHI_SYS_PLL_CNTL, (1 << 30)); //enable sys pll
 	printk(KERN_INFO "... wake up\n");
-	WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0x1234abcd);
 #if 1
 	if (aml_read_reg32(P_AO_RTC_ADDR1) & (1<<12)) {
 	// Woke from alarm, not power button. Set flag to inform key_input driver.
-		WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0x12345678);
+		WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, FLAG_WAKEUP_ALARM);
 	}
 	// clear RTC interrupt
 	aml_write_reg32((P_AO_RTC_ADDR1),aml_read_reg32(P_AO_RTC_ADDR1)|(0xf000));
@@ -388,6 +393,9 @@ static int __init meson_pm_probe(struct platform_device *pdev)
 		return -ENOENT;
 	}
 	suspend_set_ops(&meson_pm_ops);
+	
+	clk81 = clk_get_sys("clk81", NULL);
+	clkxtal = clk_get_sys("xtal", NULL);
 	printk(KERN_INFO "meson_pm_probe done !\n");
 	return 0;
 }
diff --git a/arch/arm/mach-meson8b/power_gate.c b/arch/arm/mach-meson8b/power_gate.c
old mode 100644
new mode 100755
index 113752e9c77e..92d432e7b7f8
--- a/arch/arm/mach-meson8b/power_gate.c
+++ b/arch/arm/mach-meson8b/power_gate.c
@@ -62,8 +62,8 @@ static mod_record_t mod_records[MOD_MAX_NUM + 1] = {
 		.dc_en = 0,
 		.no_share = 1,
 	},{
-		.name = "lvds",
-		.type = MOD_LVDS,
+		.name = "lcd",
+		.type = MOD_LCD,
 		.ref = 0,
 		.flag = 1,
 		.dc_en = 0,
@@ -306,11 +306,15 @@ static int _switch_gate(mod_type_t type, int flag)
 			__CLK_GATE_OFF(VCLK2_ENCT);
 		}
 		break;
-	case MOD_LVDS:
-		PRINT_INFO("turn %s lvds module\n", flag?"on":"off");
+	case MOD_LCD:
+		PRINT_INFO("turn %s lcd module\n", flag?"on":"off");
 		if (flag) {
 			__CLK_GATE_ON(VCLK2_ENCL);
+			__CLK_GATE_ON(VCLK2_VENCL);
+			__CLK_GATE_ON(EDP_CLK);
 		} else {
+			__CLK_GATE_OFF(EDP_CLK);
+			__CLK_GATE_OFF(VCLK2_VENCL);
 			__CLK_GATE_OFF(VCLK2_ENCL);
 		}
 		break;
@@ -556,6 +560,25 @@ void switch_mod_gate_by_name(const char* mod_name, int flag)
 }
 EXPORT_SYMBOL(switch_mod_gate_by_name);
 
+void switch_lcd_mod_gate(int flag)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&gate_lock, flags);
+	PRINT_INFO("turn %s lcd module\n", flag?"on":"off");
+	if (flag) {
+		__CLK_GATE_ON(VCLK2_ENCL);
+		__CLK_GATE_ON(VCLK2_VENCL);
+		__CLK_GATE_ON(EDP_CLK);
+	} else {
+		__CLK_GATE_OFF(EDP_CLK);
+		__CLK_GATE_OFF(VCLK2_VENCL);
+		__CLK_GATE_OFF(VCLK2_ENCL);
+	}
+	spin_unlock_irqrestore(&gate_lock, flags);
+}
+EXPORT_SYMBOL(switch_lcd_mod_gate);
+
 void power_gate_init(void)
 {
 	GATE_INIT(DDR);
diff --git a/arch/arm/mach-meson8b/smp.c b/arch/arm/mach-meson8b/smp.c
old mode 100644
new mode 100755
index befeff2d65bf..3d23fbc988fc
--- a/arch/arm/mach-meson8b/smp.c
+++ b/arch/arm/mach-meson8b/smp.c
@@ -130,8 +130,10 @@ int __cpuinit meson_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	printk("write pen_release: %d\n",cpu_logical_map(cpu));
 	write_pen_release(cpu_logical_map(cpu));
 
+#ifndef CONFIG_MESON_TRUSTZONE
 	check_and_rewrite_cpu_entry();
 	meson_set_cpu_power_ctrl(cpu, 1);
+#endif
 	meson_secondary_set(cpu);
 	dsb_sev();
 
diff --git a/arch/arm/mach-meson8b/time.c b/arch/arm/mach-meson8b/time.c
index ac9df96243a8..639b99b8e945 100755
--- a/arch/arm/mach-meson8b/time.c
+++ b/arch/arm/mach-meson8b/time.c
@@ -1,7 +1,7 @@
 /*
  * arch/arm/mach-meson8b/time.c
  *
- * Copyright (C) 2013 Amlogic, Inc.
+ * Copyright (C) 2014 Amlogic, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/arch/arm/mach-meson8b/vpu.c b/arch/arm/mach-meson8b/vpu.c
old mode 100644
new mode 100755
index f177a75dc921..c8adf4e713cd
--- a/arch/arm/mach-meson8b/vpu.c
+++ b/arch/arm/mach-meson8b/vpu.c
@@ -503,7 +503,7 @@ void switch_vpu_mem_pd_vmod(unsigned int vmod, int flag)
 	else {
 		printk("switch_vpu_mem_pd: unsupport vpu mod\n");
 	}
-	printk("switch_vpu_mem_pd: %s %s\n", vpu_mod_table[vpu_mod - VPU_MOD_START], ((flag > 0) ? "OFF" : "ON"));
+	//printk("switch_vpu_mem_pd: %s %s\n", vpu_mod_table[vpu_mod - VPU_MOD_START], ((flag > 0) ? "OFF" : "ON"));
 	spin_unlock_irqrestore(&vpu_mem_lock, flags);
 }
 //***********************************************//
-- 
2.19.0

