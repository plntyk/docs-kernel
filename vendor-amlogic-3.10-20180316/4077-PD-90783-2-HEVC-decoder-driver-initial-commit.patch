From 4f6122229d2d6cc5f0edec97aa9f2652d5476cff Mon Sep 17 00:00:00 2001
From: Rain Zhang-CA <rainzhang@wonton.(none)>
Date: Fri, 2 May 2014 17:21:54 -0700
Subject: [PATCH 4077/5965] PD #90783-2 HEVC decoder driver initial commit.

---
 drivers/amlogic/amports/Kconfig               |    8 +
 drivers/amlogic/amports/Makefile              |    4 +
 drivers/amlogic/amports/amstream.c            |    2 +-
 drivers/amlogic/amports/amvdec.h              |    2 +-
 drivers/amlogic/amports/m8/ucode/Makefile     |    1 +
 .../amlogic/amports/m8/ucode/h265/Makefile    |    2 +
 .../amlogic/amports/m8/ucode/h265/vh265_mc.c  |  523 +++
 drivers/amlogic/amports/vdec.c                |    5 +-
 drivers/amlogic/amports/vh265.c               | 3035 +++++++++++++++++
 drivers/amlogic/amports/vh265.h               |   31 +
 drivers/amlogic/amports/vh265_mc.h            |   27 +
 11 files changed, 3636 insertions(+), 4 deletions(-)
 create mode 100755 drivers/amlogic/amports/m8/ucode/h265/Makefile
 create mode 100755 drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c
 create mode 100755 drivers/amlogic/amports/vh265.c
 create mode 100755 drivers/amlogic/amports/vh265.h
 create mode 100755 drivers/amlogic/amports/vh265_mc.h

diff --git a/drivers/amlogic/amports/Kconfig b/drivers/amlogic/amports/Kconfig
index 71358dc099b8..1a11be349856 100755
--- a/drivers/amlogic/amports/Kconfig
+++ b/drivers/amlogic/amports/Kconfig
@@ -93,6 +93,14 @@ config AM_VDEC_H264_4K2K
         help
           Driver for h264 4Kx2K video decoder.
 
+config AM_VDEC_H265
+        tristate "Amlogic H265 Video Decoder"
+        default y
+
+        select AM_PTSSERVER
+        help
+          Driver for h265 video decoder.
+
 config AM_VDEC_MJPEG
 	tristate "Amlogic Motion JPEG Video Decoder"
 	default y
diff --git a/drivers/amlogic/amports/Makefile b/drivers/amlogic/amports/Makefile
index f831978b8685..85711eba45a2 100755
--- a/drivers/amlogic/amports/Makefile
+++ b/drivers/amlogic/amports/Makefile
@@ -85,6 +85,10 @@ obj-$(CONFIG_AM_VDEC_H264_4K2K) += amvdec_h264_4k2k.o
 amvdec_h264_4k2k-objs := vh264_4k2k.o
 amvdec_h264_4k2k-y    := vh264_4k2k.o
 
+obj-$(CONFIG_AM_VDEC_H265) += amvdec_h265.o
+amvdec_h265-objs := vh265.o
+amvdec_h265-y    := vh265.o
+
 obj-$(CONFIG_AM_VDEC_MJPEG) += amvdec_mjpeg.o
 amvdec_mjpeg-objs := vmjpeg.o
 amvdec_mjpeg-y    := vmjpeg.o
diff --git a/drivers/amlogic/amports/amstream.c b/drivers/amlogic/amports/amstream.c
index 35b96dcbb432..8596669ab443 100755
--- a/drivers/amlogic/amports/amstream.c
+++ b/drivers/amlogic/amports/amstream.c
@@ -63,8 +63,8 @@
 #include "vdec.h"
 #include "adec.h"
 #include "rmparser.h"
-#include "amports_priv.h"
 #include "amvideocap_priv.h"
+#include "amports_priv.h"
 #include <linux/firmware.h>
 
 #include <linux/of.h>
diff --git a/drivers/amlogic/amports/amvdec.h b/drivers/amlogic/amports/amvdec.h
index f72af123eead..b875a2ef363f 100755
--- a/drivers/amlogic/amports/amvdec.h
+++ b/drivers/amlogic/amports/amvdec.h
@@ -48,7 +48,7 @@ extern  s32 amhevc_loadmc(const u32 *p);
 extern void amhevc_start(void);
 extern void amhevc_stop(void);
 extern void amhevc_enable(void);
-extern void amvdec_disable(void);
+extern void amhevc_disable(void);
 #endif
 
 #if HAS_HDEC
diff --git a/drivers/amlogic/amports/m8/ucode/Makefile b/drivers/amlogic/amports/m8/ucode/Makefile
index 667730920d72..12bf5bf04b25 100755
--- a/drivers/amlogic/amports/m8/ucode/Makefile
+++ b/drivers/amlogic/amports/m8/ucode/Makefile
@@ -3,6 +3,7 @@ obj-$(CONFIG_AM_VDEC_MPEG12) += mpeg12/
 obj-$(CONFIG_AM_VDEC_MPEG4) += mpeg4/
 obj-$(CONFIG_AM_VDEC_VC1) += vc1/
 obj-$(CONFIG_AM_VDEC_H264) += h264/
+obj-$(CONFIG_AM_VDEC_H265) += h265/
 obj-$(CONFIG_AM_VDEC_H264MVC) += h264mvc/
 obj-$(CONFIG_AM_VDEC_MJPEG) += mjpeg/
 obj-$(CONFIG_AM_VDEC_REAL) += real/
diff --git a/drivers/amlogic/amports/m8/ucode/h265/Makefile b/drivers/amlogic/amports/m8/ucode/h265/Makefile
new file mode 100755
index 000000000000..2be4cae4aae5
--- /dev/null
+++ b/drivers/amlogic/amports/m8/ucode/h265/Makefile
@@ -0,0 +1,2 @@
+
+obj-y				+= vh265_mc.o
diff --git a/drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c b/drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c
new file mode 100755
index 000000000000..891124484cce
--- /dev/null
+++ b/drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c
@@ -0,0 +1,523 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#include <linux/types.h>
+
+const u32 vh265_mc[] __attribute__((aligned(8))) = {
+0x06810001,0x06800000,0x0d000001,0x07400040,0x0c000900,0x00000000,
+0x06bffe40,0x07c00000,0x06030400,0x00400000,0x0800c0ff,0x0c02dbc0,
+0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+0x00000000,0x00000000,0x00000000,0x0c7ffd80,0x00000000,0x00000000,
+0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+0x00000000,0x00000000,0x0c7a2000,0x00000000,0x0c79c100,0x06412108,
+0x0c780480,0x00000000,0x0cc00000,0x00400000,0x0800c000,0x08002515,
+0x08002608,0x06bfbb80,0x06ffbfc0,0x06070500,0x06070600,0x06070700,
+0x06803fc0,0x07c00140,0x07c00780,0x07c01480,0x0cc00000,0x00000000,
+0x06bfff88,0x06030408,0x00400000,0x0640c008,0x0a6181c8,0x00000000,
+0x0c02aec0,0x00000000,0x0c79b580,0x0800c0ff,0x0aa0c048,0x0c781e00,
+0x00000000,0x06410108,0x09021208,0x0a6f8008,0x00000000,0x0640c808,
+0x06013408,0x08013503,0x06413508,0x090e1208,0x0a6f8008,0x00000000,
+0x08013500,0x06410c08,0x08010e90,0x09326208,0x0aa0c808,0x0c79b040,
+0x0800c0fe,0x06410c08,0x08010e90,0x09384288,0x09223248,0x07c00189,
+0x09201248,0x07c001c9,0x08010e90,0x07800148,0x0a805288,0x07c0010a,
+0x0aa0ffc8,0x0c023ac0,0x05407308,0x0780010a,0x07c0014a,0x06410c08,
+0x08010e88,0x09305248,0x07c00209,0x06410c08,0x08010e90,0x09210248,
+0x07c00249,0x06410c08,0x08010e90,0x09210248,0x07c00289,0x06410c08,
+0x08010e84,0x08010e90,0x08010e90,0x08010e8c,0x06410c08,0x08010e88,
+0x09308248,0x07c002c9,0x0780018b,0x0aa3800b,0x00000000,0x06410c0a,
+0x08010e90,0x0aa2800b,0x093e124a,0x0aa08009,0x0c780000,0x093c124a,
+0x0aa08009,0x0c780000,0x0540228a,0x0c7ffe00,0x044012cb,0x06410c08,
+0x08010e81,0x093e1248,0x0780018b,0x0ae000cb,0x0a60c009,0x0680000a,
+0x0780018a,0x0ac0a2ca,0x00000000,0x0c01a140,0x0400c24a,0x0c01a0c0,
+0x0401024a,0x0c01a040,0x0401424a,0x0c7ffe00,0x0400128a,0x08010e86,
+0x06806008,0x06010e08,0x06410f08,0x0befc0c8,0x09118208,0x0aa08008,
+0x0c780000,0x06410c08,0x08010e81,0x093e1248,0x0aa40009,0x08010e90,
+0x08010e90,0x08010e90,0x08010e90,0x06410c08,0x08010e81,0x093e1248,
+0x0aa0c009,0x0c019a40,0x06800049,0x0c0199c0,0x06800049,0x0aa0c008,
+0x0c780000,0x00000000,0x08010e81,0x0c799740,0x0800c0ff,0x0aa0c088,
+0x0c78a380,0x00000000,0x06410c08,0x08010e90,0x09326208,0x0aa0c848,
+0x0c799500,0x0800c0fe,0x06410c08,0x08010e88,0x09384288,0x09323248,
+0x07c00609,0x09301248,0x07c00649,0x07800148,0x0a808288,0x07c0010a,
+0x0c022000,0x05407308,0x0780010a,0x07c0014a,0x0c022b80,0x0540730a,
+0x06410c08,0x08010e88,0x09305248,0x07c00689,0x06410c08,0x08010e90,
+0x09210248,0x07c006c9,0x06410c08,0x08010e90,0x09210248,0x07c00709,
+0x06410c08,0x08010e84,0x08010e90,0x08010e90,0x08010e8c,0x06410c08,
+0x08010e88,0x09308248,0x07c00749,0x0780060b,0x0aa3800b,0x00000000,
+0x06410c0a,0x08010e90,0x0aa2800b,0x093e124a,0x0aa08009,0x0c780000,
+0x093c124a,0x0aa08009,0x0c780000,0x0540228a,0x0c7ffe00,0x044012cb,
+0x0c018880,0x06800049,0x07800789,0x0a805209,0x07c00108,0x0aa0ffc9,
+0x0c021a40,0x05407309,0x07800108,0x07c00788,0x0c018600,0x068007c9,
+0x0c018580,0x06800809,0x0c018500,0x06800849,0x07800808,0x07800849,
+0x09610209,0x06012308,0x06410c08,0x08010e81,0x093e1248,0x0aa24009,
+0x0c018280,0x06800049,0x0c018200,0x06800049,0x0c018180,0x06800049,
+0x0c018100,0x06800049,0x0c018080,0x06800889,0x0c018000,0x068008c9,
+0x0c017f80,0x06800909,0x06410c08,0x08010e81,0x093e1248,0x0780060b,
+0x0ae000cb,0x0a60c009,0x0680000a,0x0780060a,0x0ac0a2ca,0x00000000,
+0x0c017c80,0x0402524a,0x0c017c00,0x0402924a,0x0c017b80,0x0402d24a,
+0x0c7ffe00,0x0400128a,0x0c017a80,0x06800c49,0x07800c49,0x07c00cc9,
+0x0c017980,0x06800c89,0x07800c49,0x07800c88,0x02009209,0x07c00d09,
+0x07800d08,0x0a6300c8,0x07800809,0x0403f249,0x05806249,0x07c00dc9,
+0x07800849,0x0403f249,0x05806249,0x07c00e09,0x08040640,0x0c780900,
+0x06820e20,0x0a630088,0x07800809,0x0401f249,0x05805249,0x07c00dc9,
+0x07800849,0x0401f249,0x05805249,0x07c00e09,0x08040620,0x0c780600,
+0x068213a0,0x0a630048,0x07800809,0x0400f249,0x05804249,0x07c00dc9,
+0x07800849,0x0400f249,0x05804249,0x07c00e09,0x08040610,0x0c780300,
+0x06821be0,0x07800809,0x04007249,0x05803249,0x07c00dc9,0x07800849,
+0x04007249,0x05803249,0x07c00e09,0x08040608,0x06822720,0x07800dc8,
+0x07800e09,0x0e000248,0x00000000,0x00000000,0x06800009,0x0f000200,
+0x04401208,0x0aa10008,0x05801208,0x0c7fff80,0x04001249,0x07c01409,
+0x07800809,0x0780084a,0x0960f24a,0x06040209,0x07800dc9,0x07800e0a,
+0x0960c24a,0x06040309,0x08040400,0x0c0166c0,0x06800049,0x07800049,
+0x07c00d49,0x0c0165c0,0x06800089,0x07800049,0x07800088,0x02009209,
+0x07c00d89,0x0c016440,0x06800e89,0x0c0163c0,0x06800ec9,0x06410c08,
+0x08010e81,0x093e1248,0x0aa38009,0x07c00f09,0x06410c08,0x08010e81,
+0x093e1248,0x0aa0c009,0x0c0016c0,0x00000000,0x07800788,0x0aa0c008,
+0x068f000c,0x069f000c,0x0c020c00,0x00000000,0x06410c08,0x08010e83,
+0x093e1248,0x07c00f49,0x093c1248,0x07c00f89,0x093a1248,0x0aa58009,
+0x06800009,0x06410c08,0x08010e88,0x09384248,0x04001249,0x07c01009,
+0x09304248,0x04001249,0x07c01049,0x0c015ac0,0x06801089,0x0c015a40,
+0x068010c9,0x07801089,0x02008248,0x07c010c8,0x06410c08,0x08010e81,
+0x093e1248,0x07c01109,0x06800049,0x07c00fc9,0x0c015780,0x06801149,
+0x0680000e,0x0780114f,0x044013cf,0x0aa1000f,0x058013cf,0x0c7fff80,
+0x0400138e,0x07c0118e,0x0780114f,0x0680000e,0x0b4143ce,0x00000000,
+0x0480f20e,0x05404208,0x0680800d,0x0200d20d,0x0c002580,0x00000000,
+0x0480f20e,0x0aa1c3c8,0x00000000,0x0400120e,0x0b4043c8,0x00000000,
+0x0c780100,0x00000000,0x0c004600,0x00000000,0x0c7ffb80,0x0400138e,
+0x06410c08,0x08010e81,0x093e1248,0x07c011c9,0x0aa10009,0x0c014e40,
+0x06801209,0x0a600008,0x06410c08,0x08010e83,0x093e1248,0x07c01249,
+0x093c1248,0x07c01289,0x093a1248,0x0aa0c009,0x0c004a80,0x00000000,
+0x08010e81,0x0c7949c0,0x0800c0ff,0x068c8408,0x06c41508,0x06070508,
+0x06070608,0x06070708,0x0680000b,0x0680000a,0x06410c08,0x08010e81,
+0x093e1248,0x0aa08009,0x0c780f00,0x0c014740,0x06800049,0x0aa140cb,
+0x0400e3ca,0x0ba0c0ca,0x0680038f,0x068003cf,0x0a60c00b,0x0c780180,
+0x0647050d,0x0a60c04b,0x0c7800c0,0x0647060d,0x0647070d,0x0aa38008,
+0x0400038f,0x0aa300cb,0x0680000e,0x0240f20a,0x0aa2410f,0x0920438d,
+0x0aa1c0cf,0x0918438d,0x0aa1408f,0x0910438d,0x0aa0c04f,0x0908438d,
+0x0900438d,0x0a61c0cb,0x0a60c00a,0x0c7800c0,0x0970434e,0x0978434e,
+0x0c780ec0,0x0607070d,0x0aa1c00a,0x0aa2004a,0x0aa2408a,0x0aa280ca,
+0x0aa2c10a,0x0c7802c0,0x0968434e,0x0c780240,0x0940434e,0x0c7801c0,
+0x0948434e,0x0c780140,0x0950434e,0x0c7800c0,0x0958434e,0x0960434e,
+0x0aa1000b,0x0aa1404b,0x0c7809c0,0x0607070d,0x0c780940,0x0607050d,
+0x0c7808c0,0x0607060d,0x0ba2c08b,0x0680020c,0x0c0139c0,0x06800049,
+0x04008308,0x0aa0c08b,0x0680f808,0x0680f988,0x02008288,0x06070208,
+0x0607040c,0x0aa1c00b,0x0680e008,0x0aa1404b,0x06800008,0x0aa0c08b,
+0x06806008,0x0680c008,0x0680040e,0x0aa1000b,0x0540424a,0x0680100e,
+0x0540624a,0x02008248,0x06070208,0x0680004d,0x0c0133c0,0x06800049,
+0x0200c20c,0x048ff30c,0x0607040c,0x0b8fb38d,0x0400134d,0x0ba0c0cb,
+0x06800149,0x06800049,0x0b40324a,0x0c7fe6c0,0x0400128a,0x0b60c0cb,
+0x0c7fe5c0,0x040012cb,0x0cc00000,0x00000000,0x0aa1400e,0x06800009,
+0x06410c08,0x08010e81,0x093e1248,0x0a608009,0x0c781540,0x07801149,
+0x0a40624e,0x0440144e,0x0c012b00,0x06800049,0x0c002500,0x02411211,
+0x0480f451,0x05404451,0x06808008,0x02011211,0x06800010,0x06800012,
+0x06410c08,0x08010e81,0x093e1288,0x0c0127c0,0x06800049,0x0aa1000a,
+0x040014c8,0x06800009,0x024134c9,0x0b60c412,0x06a0000b,0x0700044b,
+0x04001451,0x04001492,0x0200c2d3,0x091e12cb,0x0900e30c,0x06410c08,
+0x08010e81,0x093e1288,0x095c130a,0x0a62000a,0x06410c08,0x08010e81,
+0x093e1288,0x0a61000a,0x0a62400b,0x0c7ffb80,0x00000000,0x0740034c,
+0x0400134d,0x04001410,0x0a60c00b,0x0c7ffa00,0x00000000,0x0b60c410,
+0x06a00008,0x07400348,0x0ae08050,0x0c780780,0x0440134d,0x07000351,
+0x0900e451,0x091a1491,0x06900013,0x0aa0c012,0x02012453,0x02412453,
+0x0680004c,0x0b41240c,0x0241130d,0x07000451,0x0900e451,0x091a12d1,
+0x06900013,0x0aa0c00b,0x0200b453,0x0240b453,0x0b4072d2,0x0241130d,
+0x0400048b,0x0700044b,0x07000353,0x0740034b,0x07400453,0x0c7ffc00,
+0x0400130c,0x0c7ff8c0,0x04401410,0x0cc00000,0x00000000,0x0c0116c0,
+0x06800049,0x0c011640,0x06800089,0x06800010,0x0680000a,0x0680000b,
+0x0780004c,0x0b41130b,0x0c011480,0x068000c9,0x0240a20a,0x0440128a,
+0x06410c08,0x08010e81,0x093e1248,0x0900e20a,0x095c1209,0x07400348,
+0x0400134d,0x04001410,0x0bacc410,0x040012cb,0x0cc00000,0x00000000,
+0x0680000a,0x0680000b,0x0780008c,0x0b41130b,0x0c010f80,0x068000c9,
+0x0200a20a,0x0400128a,0x06410c08,0x08010e81,0x093e1248,0x0900e20a,
+0x095c1209,0x07400348,0x0400134d,0x04001410,0x0bacc410,0x040012cb,
+0x0cc00000,0x00000000,0x06a00008,0x07400348,0x0cc00000,0x00000000,
+0x0580424e,0x07c01449,0x05409249,0x0640c208,0x02008248,0x06035108,
+0x06808008,0x06035208,0x06a08008,0x06035008,0x06435008,0x0580f208,
+0x0bef8048,0x00000000,0x06435308,0x0900c208,0x0a6f8008,0x00000000,
+0x0cc00000,0x00000000,0x05804251,0x07801448,0x0a80e209,0x07c01449,
+0x05409249,0x0640c208,0x02008248,0x06035108,0x06808008,0x06035208,
+0x06b08008,0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,
+0x0cc00000,0x00000000,0x06410c08,0x08010e81,0x093e1248,0x0aa1c009,
+0x00000000,0x06410c08,0x08010e88,0x09301248,0x07c012c9,0x0aa03fc9,
+0x06410c08,0x08010e81,0x093e1248,0x0aa08009,0x0c780000,0x06410c08,
+0x08010e81,0x093e1248,0x0aa08009,0x0c780000,0x06410c08,0x08010e81,
+0x093e1248,0x0aa08009,0x0c780000,0x06410c08,0x08010e81,0x093e1248,
+0x093c1248,0x093a1248,0x09381248,0x0aa24009,0x0c00f900,0x06801309,
+0x0c00f880,0x06801349,0x0c00f800,0x06801389,0x0c00f780,0x068013c9,
+0x06410c08,0x08010e81,0x093e1248,0x0aa08009,0x0c780000,0x06410c08,
+0x08010e81,0x093e1248,0x0aa08009,0x0c780000,0x0cc00000,0x00000000,
+0x0aa0c0c8,0x0c782ec0,0x00000000,0x06410c08,0x08010e90,0x09326208,
+0x0aa0c888,0x0c78f140,0x0800c0fe,0x0c00f1c0,0x06800049,0x07801489,
+0x0a805209,0x07c00108,0x0aa0ffc9,0x0c019440,0x05407309,0x07800108,
+0x07c01488,0x0c00ef40,0x068014c9,0x0780078a,0x0a808288,0x07c00108,
+0x0c018140,0x0540730a,0x0780010a,0x07c0078a,0x0c018bc0,0x0540730a,
+0x06410c08,0x08010e87,0x093e1248,0x07c01509,0x093c1248,0x07c01549,
+0x09363248,0x07c01589,0x09341248,0x07c015c9,0x09321248,0x07c01609,
+0x0c00e980,0x06801649,0x04001208,0x07c01648,0x0c00e880,0x06801689,
+0x04001208,0x07c01688,0x0c00e940,0x068016c9,0x0401a208,0x07c016c8,
+0x06410c08,0x08010e83,0x093e1248,0x07c01709,0x093c1248,0x07c01749,
+0x093a1248,0x07c01789,0x0aa10009,0x06800008,0x0c00e400,0x068017c9,
+0x07c017c8,0x0c00e500,0x06801809,0x0c00e480,0x06801849,0x06410c08,
+0x08010e86,0x093e1248,0x07c01889,0x093c1248,0x07c018c9,0x093a1248,
+0x07c01909,0x09381248,0x07c01949,0x09361248,0x07c01989,0x09341248,
+0x07c01cc9,0x0aa0c009,0x0c0141c0,0x00000000,0x06800048,0x07c01c88,
+0x07801988,0x0a608008,0x0c780a80,0x0c00dcc0,0x06801a09,0x07800dc8,
+0x07c01a88,0x0c00dbc0,0x06801a49,0x07800e08,0x07c01b88,0x06410c08,
+0x08010e81,0x093e1248,0x07c019c9,0x0aa14009,0x0c014600,0x00000000,
+0x0c780580,0x00000000,0x07801a0b,0x0ae0010b,0x0680000a,0x0b4072ca,
+0x0c00d780,0x0406a24a,0x04001208,0x07400248,0x0c7ffec0,0x0400128a,
+0x07801a4b,0x0ae0010b,0x0680000a,0x0b4072ca,0x0c00d500,0x0406e24a,
+0x04001208,0x07400248,0x0c7ffec0,0x0400128a,0x06410c08,0x08010e81,
+0x093e1248,0x07c01c89,0x06410c08,0x08010e82,0x093e1248,0x07c01d09,
+0x093c1248,0x0a618009,0x07c01d49,0x07c01d89,0x07c01dc9,0x0c780340,
+0x07c01e09,0x06410c08,0x08010e82,0x093e1248,0x07c01d49,0x093c1248,
+0x0a618009,0x07c01d89,0x0c00cfc0,0x06801dc9,0x0c00cf40,0x06801e09,
+0x06410c08,0x08010e81,0x093e1248,0x0a628009,0x07800f08,0x0aa28008,
+0x078014c8,0x0aa0c008,0x068f000c,0x069f000c,0x0c0189c0,0x00000000,
+0x0c7800c0,0x0c077f80,0x00000000,0x06410c08,0x08010e81,0x093e1248,
+0x07c01e49,0x0c00c840,0x06801e89,0x04002208,0x07c01e88,0x06410c08,
+0x08010e81,0x093e1248,0x07c01ec9,0x08010e81,0x0c019000,0x00000000,
+0x0c78c480,0x0800c0ff,0x0aa0c108,0x0c786b40,0x00000000,0x06410c08,
+0x08010e90,0x09326208,0x0b210548,0x07c01f08,0x0c78c200,0x0800c0fe,
+0x06410c08,0x08010e81,0x093e1248,0x07c01f49,0x07801f08,0x0ba1c408,
+0x06800009,0x0ae14548,0x06800009,0x06410c08,0x08010e81,0x093e1248,
+0x07c01f89,0x0c00bf40,0x06800049,0x07801489,0x0a808248,0x07c00108,
+0x0c016200,0x05407309,0x07800108,0x07c01488,0x0c017440,0x05407308,
+0x078014c8,0x07800789,0x0a808248,0x07c00108,0x0c014ec0,0x05407309,
+0x07800109,0x07c00789,0x0c015940,0x05407309,0x07801f48,0x06800009,
+0x0aa10008,0x07c02009,0x0c780440,0x07c01fc9,0x07801508,0x0aa14008,
+0x06800009,0x06410c08,0x08010e81,0x093e1248,0x07c02009,0x07801409,
+0x06410c08,0x0680080a,0x0240a24a,0x098091c9,0x06010e09,0x03808288,
+0x07c01fc8,0x07802008,0x0aa0c008,0x0c784a40,0x00000000,0x0c01b640,
+0x00000000,0x07801588,0x0aa0c008,0x098081c8,0x06010e08,0x0c00b240,
+0x06802049,0x07801548,0x0aa14008,0x06800049,0x06410c08,0x08010e81,
+0x093e1248,0x07c02089,0x07801f09,0x0aa084c9,0x0a610509,0x06800008,
+0x0c781600,0x07c020c8,0x06410c08,0x07800909,0x04004249,0x0680080a,
+0x0240a24a,0x098091c9,0x06010e09,0x03808288,0x07c020c8,0x06410c08,
+0x08010e81,0x093e1248,0x0a614009,0x0680400d,0x0c077d80,0x0780114e,
+0x0c780600,0x07801189,0x06410c08,0x068007ca,0x0240a24a,0x098091c9,
+0x06010e09,0x03808288,0x05801208,0x07c02108,0x0c07a280,0x04000448,
+0x0480f211,0x05404208,0x06808009,0x02009209,0x0680400d,0x06800008,
+0x0700024a,0x0740034a,0x0400134d,0x04001208,0x0baf0408,0x04001249,
+0x078011c8,0x0a608008,0x0c7808c0,0x0780120a,0x0aa1400a,0x0680000b,
+0x0c00a300,0x06800049,0x040002c8,0x0c00a240,0x06800049,0x0200c20b,
+0x0aa6400c,0x0ac052cc,0x07801208,0x0ba50048,0x0c780000,0x00000000,
+0x06410c08,0x07800909,0x04004249,0x0680080a,0x0240a24a,0x098091c9,
+0x06010e09,0x03808288,0x06410c08,0x08010e81,0x093e1248,0x06410c08,
+0x08010e81,0x093e1248,0x0aa0c009,0x0c009c40,0x06800049,0x0c7ffa40,
+0x0440130c,0x0c0196c0,0x00000000,0x07801248,0x0aa14008,0x06800009,
+0x06410c08,0x08010e81,0x093e1248,0x07c02149,0x07800f88,0x0a610008,
+0x07c02188,0x0c780200,0x07c021c8,0x06410c08,0x08010e82,0x093e1248,
+0x07c02189,0x093c1248,0x07c021c9,0x0780204b,0x0a60c08b,0x0c781700,
+0x00000000,0x0641170a,0x06410c08,0x08010e81,0x093e1248,0x0a628009,
+0x07801649,0x09546289,0x07c02209,0x0a60c00b,0x06800009,0x07801689,
+0x09606289,0x0c7803c0,0x07c02249,0x0c0091c0,0x06802209,0x07802209,
+0x04001249,0x09546289,0x07c02209,0x0aa1c04b,0x0c009000,0x06802249,
+0x07802249,0x04001249,0x09606289,0x07c02249,0x0601170a,0x06800009,
+0x07c02989,0x07801e49,0x0aa14009,0x07802949,0x0b20c049,0x0c0192c0,
+0x00000000,0x0a61400b,0x06800009,0x06410c08,0x08010e81,0x093e1248,
+0x0641170a,0x096c1289,0x0601170a,0x07c02289,0x07801609,0x0aa14009,
+0x06800009,0x06410c08,0x08010e81,0x093e1248,0x07c022c9,0x06411008,
+0x09581209,0x06011008,0x07802149,0x0aa48009,0x0a61400b,0x06800049,
+0x06410c08,0x08010e81,0x093e1248,0x07c02309,0x0aa1808b,0x0aa0c009,
+0x06802249,0x06802209,0x07000249,0x0ae10049,0x06800009,0x0c780100,
+0x07c02349,0x0c008340,0x06802349,0x0aa0c04b,0x078018c9,0x07801909,
+0x06047b09,0x08047c00,0x0aa10009,0x08047d00,0x0c006ac0,0x00000000,
+0x0c008080,0x06802389,0x06800149,0x02409209,0x06411708,0x096e3209,
+0x06011708,0x0c008080,0x068023c9,0x078016c8,0x079023c9,0x02008248,
+0x07c02408,0x07802049,0x09446248,0x078021c8,0x09501248,0x07802188,
+0x09521248,0x07800cc8,0x09542248,0x07800d08,0x09582248,0x07800d48,
+0x095c2248,0x07800d88,0x09602248,0x07801808,0x09647248,0x07801848,
+0x09727248,0x06011109,0x06411009,0x09809389,0x06011009,0x07801888,
+0x0aa3c008,0x0c007900,0x06802449,0x0c007880,0x06802489,0x06411109,
+0x07801808,0x0780244a,0x02008288,0x09647248,0x07801848,0x0780248a,
+0x02008288,0x09727248,0x06011109,0x07801d48,0x0aa14008,0x06800009,
+0x06410c08,0x08010e81,0x093e1248,0x07c024c9,0x0a620009,0x07801d89,
+0x07c02509,0x07801dc9,0x07c02549,0x07801e09,0x0c7802c0,0x07c02589,
+0x06410c08,0x08010e81,0x093e1248,0x0a618009,0x07c02509,0x0c007080,
+0x06802549,0x0c007000,0x06802589,0x07801d08,0x0aa34008,0x06800009,
+0x07802188,0x0a61c008,0x078021c8,0x0a614008,0x07802508,0x0aa0c008,
+0x0c780140,0x06800009,0x06410c08,0x08010e81,0x093e1248,0x07c025c9,
+0x07801988,0x0a610008,0x07801cc8,0x0a608008,0x0c780440,0x0c0068c0,
+0x06802609,0x0780260b,0x0aa3400b,0x0c0067c0,0x06800049,0x04001308,
+0x0680080a,0x0240a30a,0x0980c1cc,0x06410c08,0x06010e0c,0x03808288,
+0x07c00048,0x0aef004b,0x044012cb,0x07801ec8,0x0aa20008,0x0c006440,
+0x06800049,0x0aa14008,0x00000000,0x08010e88,0x0c7fff40,0x04401208,
+0x0640ce09,0x0a274089,0x06420408,0x0a2fc048,0x00000000,0x06020408,
+0x0be3c049,0x06800008,0x09808508,0x09808588,0x06000408,0x06800008,
+0x06000408,0x06450008,0x09808008,0x06050008,0x06440008,0x09808008,
+0x06040008,0x09c08008,0x06040008,0x0a21c049,0x06460108,0x0a216008,
+0x00000000,0x06460408,0x0a2fc048,0x00000000,0x06460408,0x06060408,
+0x0800c008,0x08007401,0x0c013080,0x00000000,0x0c785900,0x00000000,
+0x0aa0c148,0x0c7841c0,0x00000000,0x08010e81,0x06812008,0x06010e08,
+0x00000000,0x08010e00,0x07802008,0x0a60c008,0x06800008,0x07c02648,
+0x07801f48,0x0aa58008,0x06800008,0x07c02888,0x07c028c8,0x07c00e48,
+0x07c02688,0x07c026c8,0x07c02708,0x07c02748,0x07801989,0x0aa0c009,
+0x07800dc8,0x07801a88,0x07c02788,0x07c02808,0x0aa0c009,0x07800e08,
+0x07801b88,0x07c027c8,0x07c02848,0x0c7801c0,0x068001df,0x07801fc8,
+0x07800e49,0x0a803248,0x0aa08009,0x0c780000,0x07802008,0x0a61c008,
+0x00000000,0x068001df,0x07802889,0x078028c8,0x09508248,0x07c02a09,
+0x07802889,0x0a614049,0x07801cc9,0x0aa0c009,0x00000000,0x0981f15f,
+0x07802889,0x078028c8,0x0958c248,0x0978425f,0x06011609,0x0c000500,
+0x00000000,0x07801f49,0x0a60c009,0x07800e48,0x0aa24008,0x07800e48,
+0x09808788,0x098087c8,0x06012408,0x0640d608,0x0aa14008,0x04401208,
+0x0600d608,0x0c784640,0x0800c0ff,0x06a00008,0x06011408,0x0c786a40,
+0x00000000,0x07802789,0x07c029c9,0x078028c9,0x0780274a,0x0a40b289,
+0x0680000c,0x0780288b,0x0780270a,0x0a40728b,0x0680000c,0x0a614009,
+0x0680008c,0x0a60c00a,0x0680008c,0x068000cc,0x07802008,0x09441308,
+0x06460109,0x094a324c,0x06060109,0x06420109,0x0944324c,0x07802048,
+0x09402248,0x07800d08,0x04003208,0x09604248,0x07800cc8,0x04003208,
+0x09684248,0x06020109,0x07800808,0x07800849,0x09610209,0x06020508,
+0x07802708,0x07802749,0x09610209,0x06020708,0x06060708,0x07802808,
+0x07802849,0x09610209,0x06020808,0x06060808,0x07800dc8,0x04401208,
+0x07800e09,0x04401249,0x09610209,0x06020608,0x06800048,0x0541f208,
+0x06020408,0x06450a08,0x09005208,0x0a6f8008,0x06800008,0x07801989,
+0x0a60c009,0x06f00008,0x06d00008,0x06050a08,0x07802708,0x07802749,
+0x0960a209,0x07801989,0x097e1209,0x06050608,0x0780280a,0x07802849,
+0x0960a289,0x0605070a,0x09c087c8,0x0780288a,0x078028c9,0x0960a289,
+0x0a403288,0x00000000,0x098087c8,0x06050808,0x078028c9,0x0780274a,
+0x0a404289,0x07802889,0x0780270a,0x0a802289,0x0c780740,0x0640c908,
+0x0e000248,0x0640ca0a,0x00000000,0x0f000240,0x0200a24a,0x0606110a,
+0x0606150a,0x0606140a,0x04020208,0x078028c9,0x0e000248,0x0640cc0a,
+0x0640cb0c,0x0f000340,0x07802688,0x0e000308,0x0200b34a,0x0402028b,
+0x00000000,0x0f000240,0x0200a24a,0x0606120a,0x0606160a,0x02409309,
+0x0200b24b,0x0606130b,0x0606170b,0x06460408,0x06060408,0x06800048,
+0x0541f208,0x06060408,0x07801988,0x06040508,0x07802808,0x07802849,
+0x09610209,0x06040308,0x07802708,0x07802749,0x09610209,0x06040408,
+0x07802008,0x0a638008,0x06804808,0x06043008,0x06443108,0x0900a248,
+0x0a6f0009,0x091e5248,0x0a6e8009,0x00000000,0x06440008,0x09808008,
+0x06040008,0x09c08008,0x06040008,0x08040701,0x07802008,0x0aa4c008,
+0x07802888,0x0a614008,0x07801cc9,0x0aa0c009,0x0c008780,0x00000000,
+0x06411009,0x091c1249,0x0a6f8009,0x00000000,0x06411009,0x098093c9,
+0x06011009,0x06411009,0x091e1249,0x0a6f8009,0x0cc00000,0x00000000,
+0x06411009,0x091c1249,0x0a6f8009,0x00000000,0x07800dc9,0x0ae0c049,
+0x0c008000,0x00000000,0x06411009,0x098093c9,0x06011009,0x08011c00,
+0x08011e00,0x06411009,0x091e1249,0x0a6f8009,0x0cc00000,0x00000000,
+0x0a60fc08,0x00000000,0x08010e90,0x0c7815c0,0x0800c0ff,0x078007cb,
+0x0c001600,0x06800049,0x06047e08,0x0aa1000b,0x0c0016c0,0x06800049,
+0x06047f08,0x08048000,0x0c0002c0,0x0780220a,0x06047c0c,0x0780204a,
+0x0a61400a,0x08048020,0x0c000140,0x0780224a,0x06047d0c,0x0cc00000,
+0x00000000,0x0400034a,0x06410c0e,0x0980d1cd,0x06010e0d,0x0680000c,
+0x0400034a,0x0aa1c00d,0x093e13ce,0x0580130c,0x097e130f,0x0540138e,
+0x0c7ffec0,0x0440134d,0x0680040d,0x0240d28d,0x0380c34c,0x0aa4000b,
+0x0400034a,0x06410c0e,0x0980d1cd,0x06010e0d,0x0400034a,0x0aa1c00d,
+0x093e13ce,0x0580130c,0x097e130f,0x0540138e,0x0c7ffec0,0x0440134d,
+0x0680040d,0x0240d28d,0x0380c34c,0x0400034c,0x0ae0c00a,0x0cc00000,
+0x00000000,0x0680000e,0x0680000f,0x0900140d,0x0aa1c010,0x0c000900,
+0x06800049,0x09408388,0x0c000840,0x06800049,0x094083c8,0x0920140d,
+0x0aa34010,0x0c000700,0x06800049,0x09508388,0x0c000640,0x06800049,
+0x0950a3c8,0x0c000580,0x06800049,0x09608388,0x0c0004c0,0x06800049,
+0x0964a3c8,0x0604810e,0x0604810f,0x0580134d,0x0c7ff880,0x0440128a,
+0x00800000,0x07800008,0x0c7e4400,0x06030408,0x06806008,0x06010e08,
+0x06410f08,0x0befc0c8,0x09118208,0x0cc00000,0x07400248,0x0680e008,
+0x06010e08,0x06410f08,0x0befc0c8,0x09118208,0x0cc00000,0x07400248,
+0x06bfff89,0x06030409,0x00400000,0x0be0c108,0x0c7ffa80,0x00000000,
+0x08012104,0x07800dc9,0x0ae0c049,0x06411c22,0x04000862,0x0a26891f,
+0x06011c21,0x0a21481f,0x0c005e80,0x00000000,0x0a25411f,0x09c1f15f,
+0x07801cc9,0x0aa48009,0x08011e00,0x0be42022,0x06a907c9,0x06012b09,
+0x00000000,0x00000000,0x06412b09,0x0c005dc0,0x00000000,0x06411009,
+0x098093c9,0x06011009,0x06411009,0x091e1249,0x0a6f8009,0x0c780800,
+0x00000000,0x0a27a022,0x06a907c9,0x06012b09,0x00000000,0x00000000,
+0x06412b09,0x0c010200,0x00000000,0x06411609,0x093e1249,0x0aa48009,
+0x06800008,0x07c02648,0x06411109,0x07802408,0x09446248,0x06011109,
+0x06411009,0x09809389,0x06011009,0x06411e08,0x0be1e008,0x068001df,
+0x0c07a7c0,0x0978479f,0x06420409,0x0c780100,0x06020409,0x0c7feb40,
+0x0800c0ff,0x0601161e,0x08013e00,0x06413f08,0x06413f08,0x06413f08,
+0x06413f08,0x06413f08,0x06413f08,0x06413f08,0x06413f08,0x06413f08,
+0x06413f08,0x06413e08,0x0640d508,0x0a608008,0x0c780a80,0x04401208,
+0x0600d508,0x06410108,0x09021208,0x0a6f8008,0x00000000,0x0640c708,
+0x06013408,0x08013503,0x06413508,0x090e1208,0x0a6f8008,0x00000000,
+0x08013500,0x0640c808,0x06013408,0x08013501,0x06413508,0x090e1208,
+0x0a6f8008,0x00000000,0x08013500,0x06800408,0x06410c09,0x08010e90,
+0x09210249,0x07c0ffc9,0x0aef0048,0x04401208,0x06410108,0x09021208,
+0x0a6f8008,0x00000000,0x0640c708,0x06013408,0x08013501,0x06413508,
+0x090e1208,0x0a6f8008,0x00000000,0x08013500,0x07800e48,0x09808788,
+0x098087c8,0x06012408,0x06a00008,0x06011408,0x07801988,0x0aa0c008,
+0x0c00ed40,0x00000000,0x09c1f09f,0x07800e48,0x04001208,0x07c00e48,
+0x07802648,0x04001208,0x07c02648,0x0a21409f,0x07802809,0x0b803248,
+0x00000000,0x09c1f05f,0x07802888,0x0a618048,0x04001208,0x07801cc9,
+0x0aa0c009,0x00000000,0x0981f15f,0x07802789,0x0b815248,0x07c02888,
+0x07802708,0x07c02888,0x0981f09f,0x07800e48,0x07800dc9,0x02008248,
+0x07802809,0x02408248,0x07c00e48,0x078028c8,0x04001208,0x078027c9,
+0x0b807248,0x07c028c8,0x07801988,0x0aa0c008,0x0c7806c0,0x00000000,
+0x0981f0df,0x078028c8,0x04001208,0x078027c9,0x0b80f248,0x07802888,
+0x04001208,0x07802789,0x0b80b248,0x07800dc9,0x0b807248,0x078028c8,
+0x04001208,0x07800e09,0x0b803248,0x0c7800c0,0x09c1f11f,0x0981f11f,
+0x0981f0df,0x0780289e,0x078028c8,0x0958c788,0x0978479f,0x0cb80020,
+0x00000000,0x06800048,0x07c02008,0x07802688,0x07801a0c,0x0b41a308,
+0x06801a89,0x02009209,0x0700024a,0x0780270b,0x0200b28b,0x07c0270b,
+0x07c0288b,0x0780274b,0x07c028cb,0x04001208,0x0b808308,0x07c02688,
+0x07800dc9,0x07c02789,0x0780270a,0x02409289,0x0c780ac0,0x07c02809,
+0x04001249,0x0700024a,0x07c0280a,0x0780278b,0x0200b28b,0x0c780900,
+0x07c0278b,0x078026c8,0x07801a4c,0x0b802308,0x0c7ff600,0x06800008,
+0x07c02688,0x07c02888,0x07c02708,0x07801a89,0x07c02809,0x07c02789,
+0x078026c8,0x06801b89,0x02009209,0x0700024a,0x0780274b,0x0200b28b,
+0x07c0274b,0x07c028cb,0x04001208,0x0b808308,0x07c026c8,0x07800e09,
+0x07c027c9,0x0780274a,0x02409289,0x0c780200,0x07c02849,0x04001249,
+0x0700024a,0x07c0284a,0x078027cb,0x0200b28b,0x07c027cb,0x07802748,
+0x07800dc9,0x0e000248,0x00000000,0x00000000,0x07802709,0x0f000200,
+0x02008248,0x07c00e48,0x0c7fe780,0x04c177df,0x07802889,0x0780270a,
+0x0400228a,0x0b407289,0x04402209,0x0440128a,0x07802788,0x0b403289,
+0x04401208,0x04401208,0x0680c009,0x02009209,0x07400262,0x0a21009f,
+0x06800021,0x0c7fb340,0x00000000,0x07802888,0x0680c009,0x02009209,
+0x0c7fb200,0x07000261,0x07802889,0x0780270a,0x0400228a,0x0b407289,
+0x04402209,0x0440128a,0x07802788,0x0b403289,0x04401208,0x04401208,
+0x0680c009,0x05801288,0x02009289,0x0700024a,0x0a20c048,0x0c7800c0,
+0x094082a2,0x095102a2,0x0740024a,0x0a21009f,0x06800021,0x0c7fac40,
+0x00000000,0x07802888,0x0680c009,0x05801288,0x02009289,0x0700024a,
+0x0a20c048,0x0911084a,0x0900884a,0x0c7fa9c0,0x00000000,0x07802889,
+0x0780270a,0x0400228a,0x0b407289,0x04402209,0x0440128a,0x07802788,
+0x0b403289,0x04401208,0x04401208,0x0680c009,0x05802288,0x02009289,
+0x0700024a,0x09002208,0x0a60c008,0x0c780240,0x095842a2,0x0a60c048,
+0x0c780180,0x095042a2,0x0a60c088,0x0c7800c0,0x094842a2,0x094042a2,
+0x0740024a,0x0a21009f,0x06800021,0x0c7fa240,0x00000000,0x07802888,
+0x0680c009,0x05802288,0x02009289,0x0700024a,0x09002208,0x0aa1c008,
+0x0918484a,0x0aa14048,0x0910484a,0x0aa0c088,0x0908484a,0x0900484a,
+0x0c7f9e80,0x00000000,0x0c780080,0x06800021,0x0c7f9d80,0x00000000,
+0x06412107,0x090c11c7,0x0a6f8007,0x0c7de0c0,0x00000000,0x06804009,
+0x06012d09,0x06800f8a,0x08012e00,0x00000000,0x0d07ff8a,0x00000000,
+0x0cc00000,0x00000000,0x06804009,0x06012c09,0x06809009,0x06012d09,
+0x06800f8a,0x06412e09,0x0d07ffca,0x06012e09,0x0cc00000,0x00000000,
+0x07800e49,0x0a60c009,0x0cc00000,0x00000000,0x06809009,0x06012c09,
+0x06804009,0x06012d09,0x06800f8a,0x06412e09,0x0d07ffca,0x06012e09,
+0x06411109,0x07802408,0x09446248,0x06011109,0x0cc00000,0x00000000,
+0x07800dc8,0x07801a09,0x0a608009,0x0c780880,0x0aa18049,0x0aa20089,
+0x0aa640c9,0x0a608109,0x0c7806c0,0x0c780000,0x05801288,0x0c780680,
+0x07c01a8a,0x05802288,0x0540124a,0x02009289,0x0b0fe209,0x0400128a,
+0x0440224a,0x07c01a89,0x05401289,0x0400128a,0x0540124a,0x02009289,
+0x05401208,0x0b003209,0x07801a89,0x0440128a,0x0240a24a,0x0c780200,
+0x07c01aca,0x0c000b40,0x06801a8c,0x0c780100,0x00000000,0x0c000dc0,
+0x06801a8c,0x07800e08,0x07801a49,0x0a608009,0x0c780880,0x0aa18049,
+0x0aa20089,0x0aa640c9,0x0a608109,0x0c7806c0,0x0c780000,0x05801288,
+0x0c780680,0x07c01b8a,0x05802288,0x0540124a,0x02009289,0x0b0fe209,
+0x0400128a,0x0440224a,0x07c01b89,0x05401289,0x0400128a,0x0540124a,
+0x02009289,0x05401208,0x0b003209,0x07801b89,0x0440128a,0x0240a24a,
+0x0c780200,0x07c01bca,0x0c000200,0x06801b8c,0x0cc00000,0x00000000,
+0x0c000480,0x06801b8c,0x0cc00000,0x00000000,0x05802348,0x0740030d,
+0x05801248,0x0240a349,0x0400130c,0x0740030a,0x054012c8,0x0200b20b,
+0x058022cb,0x0240a24b,0x0400130c,0x0740030a,0x0cc00000,0x00000000,
+0x05803288,0x0540224a,0x02009289,0x0b0fe209,0x0400128a,0x0440224a,
+0x07400309,0x054012c8,0x04000349,0x0540224a,0x02009289,0x0b0fe2c9,
+0x0400128a,0x0440224a,0x0240a349,0x0400130c,0x0740030a,0x054012c8,
+0x0200b20b,0x04000349,0x0540224a,0x02009289,0x0b0fe2c9,0x0400128a,
+0x0440224a,0x0240a349,0x0400130c,0x0740030a,0x054022c8,0x04000349,
+0x0540224a,0x02009289,0x0b0fe2c9,0x0400128a,0x0440224a,0x0240a349,
+0x0400130c,0x0740030a,0x0cc00000,0x00000000,0x0640c308,0x02008308,
+0x06035108,0x06800808,0x06035208,0x06800149,0x0680c00a,0x0700024b,
+0x0740028b,0x0b6105c9,0x04001249,0x0c7fff00,0x0400128a,0x06a0c008,
+0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,0x06435308,
+0x0900c208,0x0a6f8008,0x00000000,0x0cc00000,0x00000000,0x0640c408,
+0x02008308,0x06035108,0x06801008,0x06035208,0x06800609,0x0680c00a,
+0x0700024b,0x0740028b,0x0b611449,0x04001249,0x0c7fff00,0x0400128a,
+0x06a0c008,0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,
+0x06435308,0x0900c208,0x0a6f8008,0x00000000,0x0cc00000,0x00000000,
+0x0640c308,0x02008308,0x06035108,0x06800808,0x06035208,0x06b0c008,
+0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,0x06800149,
+0x0680c00a,0x0700028b,0x0740024b,0x0b6105c9,0x04001249,0x0c7fff00,
+0x0400128a,0x0cc00000,0x00000000,0x0640c408,0x02008308,0x06035108,
+0x06801008,0x06035208,0x06b0c008,0x06035008,0x06435008,0x0580f208,
+0x0bef8048,0x00000000,0x06800609,0x0680c00a,0x0700028b,0x0740024b,
+0x0b611449,0x04001249,0x0c7fff00,0x0400128a,0x0cc00000,0x00000000,
+0x0640c508,0x02008308,0x06035108,0x06800c08,0x06035208,0x06801489,
+0x0680c00a,0x0700024b,0x0740028b,0x0b611ec9,0x04001249,0x0c7fff00,
+0x0400128a,0x06a0c008,0x06035008,0x06435008,0x0580f208,0x0bef8048,
+0x00000000,0x06435308,0x0900c208,0x0a6f8008,0x00000000,0x07800f08,
+0x0aa20008,0x0540330c,0x078014c8,0x0aa0c008,0x06800008,0x06900008,
+0x0c000100,0x0200c20c,0x0cc00000,0x00000000,0x0680000d,0x08070300,
+0x0680c00b,0x0680000a,0x06470408,0x06470409,0x09508209,0x074002c8,
+0x040012cb,0x0baeffca,0x0400128a,0x0aa3800d,0x00000000,0x06470508,
+0x07c0fe88,0x09210208,0x07c0fec8,0x06470608,0x07c0ff08,0x09210208,
+0x07c0ff48,0x06470708,0x07c0ff88,0x09210208,0x07c0ffc8,0x0640cd08,
+0x02008308,0x0540924d,0x02008248,0x06035108,0x06804008,0x06035208,
+0x06a0c008,0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,
+0x0ba0c04d,0x0cc00000,0x00000000,0x0c7ff640,0x0400134d,0x0640c508,
+0x02008308,0x06035108,0x06800c08,0x06035208,0x06b0c008,0x06035008,
+0x06435008,0x0580f208,0x0bef8048,0x00000000,0x06801489,0x0680c00a,
+0x0700028b,0x0740024b,0x0b611ec9,0x04001249,0x0c7fff00,0x0400128a,
+0x0c000e00,0x00000000,0x07800f08,0x0aa20008,0x0540330c,0x078014c8,
+0x0aa0c008,0x06800008,0x06900008,0x0c000100,0x0200c20c,0x0cc00000,
+0x00000000,0x0680000d,0x08070200,0x0640cd08,0x02008308,0x0540924d,
+0x02008248,0x06035108,0x06804008,0x06035208,0x06b0c008,0x06035008,
+0x06435008,0x0580f208,0x0bef8048,0x00000000,0x0680c00b,0x0680000a,
+0x070002c8,0x040012cb,0x06070408,0x09108248,0x06070409,0x0baeffca,
+0x0400128a,0x0aa3800d,0x00000000,0x0780fe88,0x0780fec9,0x09610209,
+0x06070508,0x0780ff08,0x0780ff49,0x09610209,0x06070608,0x0780ff88,
+0x0780ffc9,0x09610209,0x06070708,0x0ba0c04d,0x0cc00000,0x00000000,
+0x0c7ff640,0x0400134d,0x078015c8,0x07801749,0x09421209,0x07801709,
+0x09441209,0x07801949,0x09461209,0x07800ec9,0x09483209,0x07800e89,
+0x094e3209,0x07800f49,0x09741209,0x07801789,0x09761209,0x07800d09,
+0x078017ca,0x02409289,0x09782209,0x06011708,0x06412508,0x07800fc9,
+0x09401209,0x07801089,0x09482209,0x078010c9,0x094c2209,0x07801009,
+0x09504209,0x07801049,0x09584209,0x06012508,0x06470108,0x07800f09,
+0x09401209,0x09421209,0x09441209,0x07800d09,0x09482209,0x06070108,
+0x06440808,0x07801289,0x09401209,0x07801709,0x09421209,0x06040808,
+0x0cc00000,0x00000000,0x0c002dc0,0x00000000,0x07802208,0x07c04408,
+0x07802248,0x07c04448,0x07802048,0x07c04488,0x07802148,0x07c044c8,
+0x07802008,0x07c04508,0x07801fc8,0x07c04548,0x07800808,0x07c045c8,
+0x07800848,0x07c04608,0x07800c48,0x07c04648,0x07800c88,0x07c04688,
+0x07800908,0x07c046c8,0x078020c8,0x07c04708,0x07802308,0x07c04748,
+0x07802348,0x07c04788,0x07801e88,0x07c047c8,0x07802388,0x07c04808,
+0x07800a48,0x07c04848,0x07802988,0x07c04888,0x07801988,0x078019c9,
+0x05401249,0x02c08248,0x07c048c8,0x07801a08,0x07c04908,0x07801a48,
+0x07c04948,0x07801a88,0x07c04988,0x07801ac8,0x07c049c8,0x07801b08,
+0x07c04a08,0x07801b48,0x07c04a48,0x07801b88,0x07c04a88,0x07801bc8,
+0x07c04ac8,0x07801c08,0x07c04b08,0x07801c48,0x07c04b48,0x07801dc8,
+0x07c04bc8,0x07801e08,0x07c04c08,0x07802548,0x07c04c48,0x07802588,
+0x07c04c88,0x07801808,0x07c04cc8,0x07801848,0x07c04d08,0x07801f48,
+0x07c04d48,0x06800009,0x07801108,0x0a20c048,0x07800fc8,0x09809009,
+0x0a20c048,0x07801c88,0x09809049,0x0a20c048,0x07801d08,0x09809089,
+0x0a20c048,0x07801d48,0x098090c9,0x0a20c048,0x07801d88,0x09809109,
+0x0a20c048,0x078024c8,0x09809149,0x0a20c048,0x07802508,0x09809189,
+0x0a20c048,0x07802188,0x098091c9,0x0a20c048,0x078021c8,0x09809209,
+0x0a20c048,0x078025c8,0x09809249,0x0a20c048,0x00000000,0x09809289,
+0x07c04b89,0x0680500a,0x06802a48,0x07000209,0x07400289,0x0400128a,
+0x0baf7208,0x04001208,0x0800cf00,0x06800009,0x06804008,0x02008248,
+0x07000208,0x09808408,0x0600cf08,0x00000000,0x0640cf08,0x0a6fc008,
+0x0b60dfc9,0x0c7ffdc0,0x04001249,0x0cc00000,0x00000000,0x0800cf00,
+0x0800c0ff,0x06800009,0x0680ffca,0x07000248,0x09808408,0x0600cf08,
+0x00000000,0x0640cf08,0x0a6fc008,0x0b403289,0x0c7ffe40,0x04001249,
+0x0cc00000,0x00000000,0x0680000a,0x0680000b,0x06804008,0x07000209,
+0x0580f209,0x0be20048,0x0580e209,0x0a20c048,0x0400128a,0x040012cb,
+0x06804008,0x0bae040a,0x02008288,0x07c0294b,0x0cc00000,0x00000000,
+0x06800009,0x07c02949,0x068003ca,0x068043c8,0x07400209,0x0440128a,
+0x0aef800a,0x04401208,0x06a00009,0x07400209,0x0cc00000,0x00000000,
+0x06800048,0x07c02308,0x07c02148,0x0cc00000,0x00000000,0x0680580a,
+0x06801f08,0x07000209,0x07400289,0x0400128a,0x0baf6608,0x04001208,
+0x0cc00000,0x00000000,0x06802a4d,0x06410c08,0x08010e81,0x093e1248,
+0x0aa10009,0x07c02989,0x0c0003c0,0x0780220c,0x0a62c00b,0x00000000,
+0x06410c08,0x08010e81,0x093e1248,0x0aa18009,0x07802989,0x09809049,
+0x07c02989,0x0c000100,0x0780224c,0x0cc00000,0x00000000,0x07802948,
+0x0b21c088,0x06800049,0x0b214108,0x06800089,0x0b20c208,0x068000c9,
+0x06800109,0x0680080a,0x0240a24a,0x098091c9,0x06410c08,0x06010e09,
+0x03808288,0x07400348,0x0400134d,0x0aeec04c,0x0440130c,0x0cc00000,
+0x00000000,0x06460409,0x09001289,0x0aaf800a,0x00000000,0x0cc00000,
+0x00000000,0x07802888,0x0680d009,0x02009209,0x0700024d,0x078028c8,
+0x0680ee09,0x02009209,0x0700024e,0x0680000f,0x0ac0338d,0x06ee000f,
+0x06ea000f,0x06050a0f,0x07802888,0x0b615e08,0x0680d009,0x02009209,
+0x07802a0d,0x0740024d,0x078028c8,0x0b615108,0x0680ee09,0x02009209,
+0x07802a0e,0x0740024e,0x0cc00000,0x00000000,0x0640c023,0x0a6fffe3,
+0x00000000,0x06410b23,0x098230a3,0x06010b23,0x06412123,0x0a2fc063,
+0x00000000,0x06410c23,0x092039a3,0x07c04da6,0x093269a3,0x07c04de6,
+0x06410d23,0x06410b23,0x0a6308a6,0x00000000,0x06411423,0x090188e3,
+0x0640ce24,0x0a610023,0x0be0c064,0x05801924,0x0a610024,0x06440123,
+0x0a2fc063,0x00000000,0x08012101,0x0aa24826,0x06800065,0x0aa1c866,
+0x068000a5,0x0aa148a6,0x068000e5,0x0b20c566,0x06800125,0x06803c25,
+0x0600c025,0x08030504,0x0c7ff600,0x00000000,0x00000000,0x00000000,
+0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+};
\ No newline at end of file
diff --git a/drivers/amlogic/amports/vdec.c b/drivers/amlogic/amports/vdec.c
index 857bb3f7c373..efa7f706aad2 100755
--- a/drivers/amlogic/amports/vdec.c
+++ b/drivers/amlogic/amports/vdec.c
@@ -346,7 +346,7 @@ bit8: vdec.gate
 static int inited_vcodec_num = 0;
 static int clock_level;
 static unsigned int debug_trace_num = 16*20;
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TVD
+#if HAS_VDEC2
 static int clock_level2;
 #endif
 static struct platform_device *vdec_device = NULL;
@@ -827,8 +827,9 @@ static ssize_t dump_trace_show(struct class *class, struct class_attribute *attr
 {
 	int i;
 	char *pbuf = buf;
-	u32 pc,oldpc=0;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
 	unsigned long flags;
+#endif
 	u16 *trace_buf=kmalloc(debug_trace_num*2,GFP_KERNEL);
 	if(!trace_buf){
 		pbuf += sprintf(pbuf, "No Memory bug\n");
diff --git a/drivers/amlogic/amports/vh265.c b/drivers/amlogic/amports/vh265.c
new file mode 100755
index 000000000000..e3dc8f03913e
--- /dev/null
+++ b/drivers/amlogic/amports/vh265.c
@@ -0,0 +1,3035 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/vformat.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+
+#include <mach/am_regs.h>
+#include <mach/vpu.h>
+#include "vdec_reg.h"
+
+#include "vdec.h"
+#include "amvdec.h"
+#include "vh265_mc.h"
+
+#define DRIVER_NAME "amvdec_h265"
+#define MODULE_NAME "amvdec_h265"
+
+#define PUT_INTERVAL        (HZ/100)
+#define ERROR_LOCAL_RESET_COUNT   100
+#define ERROR_SYSTEM_RESET_COUNT   200
+
+#define STAT_TIMER_INIT     0x01
+#define STAT_MC_LOAD        0x02
+#define STAT_ISR_REG        0x04
+#define STAT_VF_HOOK        0x08
+#define STAT_TIMER_ARM      0x10
+#define STAT_VDEC_RUN       0x20
+
+static int  vh265_vf_states(vframe_states_t *states, void*);
+static vframe_t *vh265_vf_peek(void*);
+static vframe_t *vh265_vf_get(void*);
+static void vh265_vf_put(vframe_t *, void*);
+static int vh265_event_cb(int type, void *data, void *private_data);
+
+static void vh265_prot_init(void);
+static void vh265_local_init(void);
+static void vh265_put_timer_func(unsigned long arg);
+
+static const char vh265_dec_id[] = "vh265-dev";
+
+#define PROVIDER_NAME   "decoder.h265"
+
+static const struct vframe_operations_s vh265_vf_provider = {
+    .peek      = vh265_vf_peek,
+    .get       = vh265_vf_get,
+    .put       = vh265_vf_put,
+    .event_cb  = vh265_event_cb,
+    .vf_states = vh265_vf_states,
+};
+static struct vframe_provider_s vh265_vf_prov;
+
+static u32 frame_width, frame_height, frame_dur, frame_ar;
+static struct timer_list recycle_timer;
+static u32 stat;
+static u32 error_watchdog_count;
+
+#define H265_DEBUG_POC          1
+#define H265_DEBUG_BUFMGR       2
+#define H265_DEBUG_UCODE        4
+#define H265_DEBUG_REG          8
+#define H265_DEBUG_DIS_ERROR_PROC       0x10000
+#define H265_DEBUG_DIS_SYS_ERROR_PROC   0x20000
+
+static u32 debug_decode_idx_start = 0;
+static u32 debug_decode_idx_end = 0;
+static u32 debug = 0;
+
+#define DEBUG_REG
+#ifdef DEBUG_REG
+void WRITE_VREG_DBG(unsigned adr, unsigned val)
+{
+    if(debug&H265_DEBUG_REG)
+        printk("%s(%x, %x)\n", __func__, adr, val); 
+    WRITE_VREG(adr, val);   
+}    
+#undef WRITE_VREG
+#define WRITE_VREG WRITE_VREG_DBG
+#endif
+#ifdef DEBUG_PTS
+static unsigned long pts_missed, pts_hit;
+#endif
+
+static struct dec_sysinfo vh265_amstream_dec_info;
+extern u32 trickmode_i;
+
+static DEFINE_SPINLOCK(lock);
+static int fatal_error;
+
+static DEFINE_MUTEX(vh265_mutex);
+
+static struct device *cma_dev;
+
+static int  prepare_display_buf(int index, int stream_offset);
+
+/**************************************************
+
+h265 buffer management include
+
+***************************************************/
+#define HEVC_MPRED_MV_WR_START_ADDR   HEVC_MPRED_MV_WPTR
+#define HEVC_MPRED_MV_RD_START_ADDR   HEVC_MPRED_MV_RPTR
+#define HEVCD_IPP_AXIIF_CONFIG                     0x340b
+
+
+enum NalUnitType
+{
+  NAL_UNIT_CODED_SLICE_TRAIL_N = 0,   // 0
+  NAL_UNIT_CODED_SLICE_TRAIL_R,   // 1
+  
+  NAL_UNIT_CODED_SLICE_TSA_N,     // 2
+  NAL_UNIT_CODED_SLICE_TLA,       // 3   // Current name in the spec: TSA_R
+  
+  NAL_UNIT_CODED_SLICE_STSA_N,    // 4
+  NAL_UNIT_CODED_SLICE_STSA_R,    // 5
+
+  NAL_UNIT_CODED_SLICE_RADL_N,    // 6
+  NAL_UNIT_CODED_SLICE_DLP,       // 7 // Current name in the spec: RADL_R
+  
+  NAL_UNIT_CODED_SLICE_RASL_N,    // 8
+  NAL_UNIT_CODED_SLICE_TFD,       // 9 // Current name in the spec: RASL_R
+
+  NAL_UNIT_RESERVED_10,
+  NAL_UNIT_RESERVED_11,
+  NAL_UNIT_RESERVED_12,
+  NAL_UNIT_RESERVED_13,
+  NAL_UNIT_RESERVED_14,
+  NAL_UNIT_RESERVED_15,
+
+  NAL_UNIT_CODED_SLICE_BLA,       // 16   // Current name in the spec: BLA_W_LP
+  NAL_UNIT_CODED_SLICE_BLANT,     // 17   // Current name in the spec: BLA_W_DLP
+  NAL_UNIT_CODED_SLICE_BLA_N_LP,  // 18
+  NAL_UNIT_CODED_SLICE_IDR,       // 19  // Current name in the spec: IDR_W_DLP
+  NAL_UNIT_CODED_SLICE_IDR_N_LP,  // 20
+  NAL_UNIT_CODED_SLICE_CRA,       // 21
+  NAL_UNIT_RESERVED_22,
+  NAL_UNIT_RESERVED_23,
+
+  NAL_UNIT_RESERVED_24,
+  NAL_UNIT_RESERVED_25,
+  NAL_UNIT_RESERVED_26,
+  NAL_UNIT_RESERVED_27,
+  NAL_UNIT_RESERVED_28,
+  NAL_UNIT_RESERVED_29,
+  NAL_UNIT_RESERVED_30,
+  NAL_UNIT_RESERVED_31,
+
+  NAL_UNIT_VPS,                   // 32
+  NAL_UNIT_SPS,                   // 33
+  NAL_UNIT_PPS,                   // 34
+  NAL_UNIT_ACCESS_UNIT_DELIMITER, // 35
+  NAL_UNIT_EOS,                   // 36
+  NAL_UNIT_EOB,                   // 37
+  NAL_UNIT_FILLER_DATA,           // 38
+  NAL_UNIT_SEI,                   // 39 Prefix SEI
+  NAL_UNIT_SEI_SUFFIX,            // 40 Suffix SEI
+  NAL_UNIT_RESERVED_41,
+  NAL_UNIT_RESERVED_42,
+  NAL_UNIT_RESERVED_43,
+  NAL_UNIT_RESERVED_44,
+  NAL_UNIT_RESERVED_45,
+  NAL_UNIT_RESERVED_46,
+  NAL_UNIT_RESERVED_47,
+  NAL_UNIT_UNSPECIFIED_48,
+  NAL_UNIT_UNSPECIFIED_49,
+  NAL_UNIT_UNSPECIFIED_50,
+  NAL_UNIT_UNSPECIFIED_51,
+  NAL_UNIT_UNSPECIFIED_52,
+  NAL_UNIT_UNSPECIFIED_53,
+  NAL_UNIT_UNSPECIFIED_54,
+  NAL_UNIT_UNSPECIFIED_55,
+  NAL_UNIT_UNSPECIFIED_56,
+  NAL_UNIT_UNSPECIFIED_57,
+  NAL_UNIT_UNSPECIFIED_58,
+  NAL_UNIT_UNSPECIFIED_59,
+  NAL_UNIT_UNSPECIFIED_60,
+  NAL_UNIT_UNSPECIFIED_61,
+  NAL_UNIT_UNSPECIFIED_62,
+  NAL_UNIT_UNSPECIFIED_63,
+  NAL_UNIT_INVALID,
+};
+
+static int forbidden_zero_bit;
+static int m_nalUnitType;
+static int m_reservedZero6Bits;
+static int m_temporalId;
+
+//---------------------------------------------------
+// Amrisc Software Interrupt 
+//---------------------------------------------------
+#define AMRISC_STREAM_EMPTY_REQ 0x01
+#define AMRISC_PARSER_REQ       0x02
+#define AMRISC_MAIN_REQ         0x04
+
+//---------------------------------------------------
+// HEVC_DEC_STATUS define
+//---------------------------------------------------
+#define HEVC_DEC_IDLE                        0
+#define HEVC_NAL_UNIT_VPS                    1
+#define HEVC_NAL_UNIT_SPS                    2
+#define HEVC_NAL_UNIT_PPS                    3
+#define HEVC_NAL_UNIT_CODED_SLICE_SEGMENT    4
+#define HEVC_CODED_SLICE_SEGMENT_DAT         5
+#define HEVC_DUMP_LMEM				7
+#define HEVC_SLICE_SEGMENT_DONE  		8
+
+#define HEVC_DISCARD_NAL         0xf0
+#define HEVC_ACTION_ERROR        0xfe
+#define HEVC_ACTION_DONE         0xff
+
+
+
+//---------------------------------------------------
+// Include "parser_cmd.h"
+//---------------------------------------------------
+#define PARSER_CMD_SKIP_CFG_0 0x0000090b
+
+#define PARSER_CMD_SKIP_CFG_1 0x1b14140f
+
+#define PARSER_CMD_SKIP_CFG_2 0x001b1910
+
+#define PARSER_CMD_NUMBER 37
+
+static unsigned short parser_cmd[PARSER_CMD_NUMBER] = {
+0x0401,
+0x8401,
+0x0800,
+0x0402,
+0x9002,
+0x1423,
+0x8CC3,
+0x1423,
+0x8804,
+0x9825,
+0x0800,
+0x04FE,
+0x8406,
+0x8411,
+0x1800,
+0x8408,
+0x8409,
+0x8C2A,
+0x9C2B,
+0x1C00,
+0x840F,
+0x8407,
+0x8000,
+0x8408,
+0x2000,
+0xA800,
+0x8410,
+0x04DE,
+0x840C,
+0x840D,
+0xAC00,
+0xA000,
+0x08C0,
+0x08E0,
+0xA40E,
+0xFC00,
+0x7C00
+};
+
+/**************************************************
+
+h265 buffer management
+
+***************************************************/
+//#define BUFFER_MGR_ONLY
+//#define CONFIG_HEVC_CLK_FORCED_ON
+//#define ENABLE_SWAP_TEST
+#define   MCRCC_ENABLE
+#define MEM_MAP_MODE 2  // 0:linear 1:32x32 2:64x32 ; m8baby test1902
+#define INVALID_POC 0x80000000
+
+
+#define HEVC_DEC_STATUS_REG       HEVC_ASSIST_SCRATCH_0
+#define HEVC_WORK_SPACE_REG       HEVC_ASSIST_SCRATCH_1
+#define HEVC_SHORT_TERM_RPS       HEVC_ASSIST_SCRATCH_2
+#define HEVC_VPS_BUFFER           HEVC_ASSIST_SCRATCH_3
+#define HEVC_SPS_BUFFER           HEVC_ASSIST_SCRATCH_4
+#define HEVC_PPS_BUFFER           HEVC_ASSIST_SCRATCH_5
+#define HEVC_SAO_UP               HEVC_ASSIST_SCRATCH_6
+#define HEVC_STREAM_SWAP_BUFFER   HEVC_ASSIST_SCRATCH_7
+#define HEVC_STREAM_SWAP_BUFFER2  HEVC_ASSIST_SCRATCH_8
+#define HEVC_sao_mem_unit         HEVC_ASSIST_SCRATCH_9
+#define HEVC_SAO_ABV              HEVC_ASSIST_SCRATCH_A
+#define HEVC_sao_vb_size          HEVC_ASSIST_SCRATCH_B
+#define HEVC_SAO_VB               HEVC_ASSIST_SCRATCH_C
+#define HEVC_SCALELUT             HEVC_ASSIST_SCRATCH_D
+#define HEVC_WAIT_FLAG	          HEVC_ASSIST_SCRATCH_E
+#define RPM_CMD_REG               HEVC_ASSIST_SCRATCH_F
+#define HEVC_STREAM_SWAP_TEST     HEVC_ASSIST_SCRATCH_L
+#define HEVC_DECODE_PIC_BEGIN_REG HEVC_ASSIST_SCRATCH_M
+#define HEVC_DECODE_PIC_NUM_REG   HEVC_ASSIST_SCRATCH_N
+
+#define MAX_INT 0x7FFFFFFF
+
+#define RPM_BEGIN                                              0x100
+#define modification_list_cur                                  0x140
+#define RPM_END                                                0x180
+
+#define RPS_USED_BIT  		14
+//MISC_FLAG0
+#define PCM_LOOP_FILTER_DISABLED_FLAG_BIT		0
+#define PCM_ENABLE_FLAG_BIT				1
+#define LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT	2
+#define PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT	3
+#define DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT	4
+#define PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT		5
+#define DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT		6
+#define SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT	7
+#define SLICE_SAO_LUMA_FLAG_BIT				8
+#define SLICE_SAO_CHROMA_FLAG_BIT			9
+#define SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT 10
+
+typedef union PARAM_{
+    struct{
+        unsigned short data[RPM_END-RPM_BEGIN];
+    }l;
+    struct{ 
+        /* from ucode lmem, do not change this struct */
+        unsigned short CUR_RPS[0x10];                             
+        unsigned short num_ref_idx_l0_active;                 
+        unsigned short num_ref_idx_l1_active;                 
+        unsigned short slice_type;                            
+        unsigned short slice_temporal_mvp_enable_flag;        
+        unsigned short dependent_slice_segment_flag;          
+        unsigned short slice_segment_address;                 
+        unsigned short num_title_rows_minus1;                 
+        unsigned short pic_width_in_luma_samples;             
+        unsigned short pic_height_in_luma_samples;            
+        unsigned short log2_min_coding_block_size_minus3;     
+        unsigned short log2_diff_max_min_coding_block_size;   
+        unsigned short log2_max_pic_order_cnt_lsb_minus4;     
+        unsigned short POClsb;                                
+        unsigned short collocated_from_l0_flag;               
+        unsigned short collocated_ref_idx;                    
+        unsigned short log2_parallel_merge_level;             
+        unsigned short five_minus_max_num_merge_cand;         
+        unsigned short sps_num_reorder_pics_0;                
+        unsigned short modification_flag;                     
+        unsigned short tiles_enabled_flag;                    
+        unsigned short num_tile_columns_minus1;               
+        unsigned short num_tile_rows_minus1;                  
+        unsigned short tile_width[4];                          
+        unsigned short tile_height[4];                         
+        unsigned short misc_flag0;                            
+        unsigned short pps_beta_offset_div2;                  
+        unsigned short pps_tc_offset_div2;                    
+        unsigned short slice_beta_offset_div2;                
+        unsigned short slice_tc_offset_div2;                  
+        unsigned short pps_cb_qp_offset;                      
+        unsigned short pps_cr_qp_offset;                      
+        unsigned short first_slice_segment_in_pic_flag;       
+        unsigned short m_temporalId;                          
+        unsigned short m_nalUnitType;  
+        unsigned short reserved[8];
+        unsigned short modification_list[0x20];                      
+    }p;
+}param_t;
+
+
+typedef struct
+{
+    u32 buf_start;
+    u32 buf_size;
+    u32 buf_end;
+} buff_t;
+
+typedef struct
+{
+    u32 max_width;
+    u32 max_height;
+    u32 start_adr;
+    u32 end_adr;
+    buff_t ipp;
+    buff_t sao_abv;
+    buff_t sao_vb;
+    buff_t short_term_rps;
+    buff_t vps;
+    buff_t sps;
+    buff_t pps;
+    buff_t sao_up;
+    buff_t swap_buf;
+    buff_t swap_buf2;
+    buff_t scalelut;
+    buff_t dblk_para;
+    buff_t dblk_data;
+    buff_t mpred_above;
+    buff_t mpred_mv;
+} BuffInfo_t;
+#define WORK_BUF_SPEC_NUM 2
+static BuffInfo_t amvh265_workbuff_spec[WORK_BUF_SPEC_NUM]={
+    { //8M bytes
+        .max_width = 1920,
+        .max_height = 1088,
+        .ipp = {
+            // IPP work space calculation : 4096 * (Y+CbCr+Flags) = 12k, round to 16k
+            .buf_size = 0x4000,
+        },
+        .sao_abv = {
+            .buf_size = 0x30000,
+        },
+        .sao_vb = {
+            .buf_size = 0x30000,
+        },
+        .short_term_rps = {
+            // SHORT_TERM_RPS - Max 64 set, 16 entry every set, total 64x16x2 = 2048 bytes (0x800)
+            .buf_size = 0x800,
+        },
+        .vps = {
+            // VPS STORE AREA - Max 16 VPS, each has 0x80 bytes, total 0x0800 bytes
+            .buf_size = 0x800,
+        },
+        .sps = {
+            // SPS STORE AREA - Max 16 SPS, each has 0x80 bytes, total 0x0800 bytes
+            .buf_size = 0x800,
+        },
+        .pps = {
+            // PPS STORE AREA - Max 64 PPS, each has 0x80 bytes, total 0x2000 bytes
+            .buf_size = 0x2000,
+        },
+        .sao_up = {
+            // SAO UP STORE AREA - Max 640(10240/16) LCU, each has 16 bytes total 0x2800 bytes
+            .buf_size = 0x2800,
+        },
+        .swap_buf = {
+            // 256cyclex64bit = 2K bytes 0x800 (only 144 cycles valid)
+            .buf_size = 0x800,
+        },
+        .swap_buf2 = {
+            .buf_size = 0x800,
+        },
+        .scalelut = {
+            // support up to 32 SCALELUT 1024x32 = 32Kbytes (0x8000)
+            .buf_size = 0x8000,
+        },
+        .dblk_para = {
+            // DBLK -> Max 256(4096/16) LCU, each para 512bytes(total:0x20000), data 1024bytes(total:0x40000)
+            .buf_size = 0x20000,
+        },
+        .dblk_data = {
+            .buf_size = 0x40000,
+        },
+        .mpred_above = {
+            .buf_size = 0x8000,
+        },
+        .mpred_mv = {
+           .buf_size = 0x40000*16, //1080p, 0x40000 per buffer
+        },
+    },
+    { 
+        .max_width = 4096,
+        .max_height = 2048,
+        .ipp = {
+            // IPP work space calculation : 4096 * (Y+CbCr+Flags) = 12k, round to 16k
+            .buf_size = 0x4000,
+        },
+        .sao_abv = {
+            .buf_size = 0x30000,
+        },
+        .sao_vb = {
+            .buf_size = 0x30000,
+        },
+        .short_term_rps = {
+            // SHORT_TERM_RPS - Max 64 set, 16 entry every set, total 64x16x2 = 2048 bytes (0x800)
+            .buf_size = 0x800,
+        },
+        .vps = {
+            // VPS STORE AREA - Max 16 VPS, each has 0x80 bytes, total 0x0800 bytes
+            .buf_size = 0x800,
+        },
+        .sps = {
+            // SPS STORE AREA - Max 16 SPS, each has 0x80 bytes, total 0x0800 bytes
+            .buf_size = 0x800,
+        },
+        .pps = {
+            // PPS STORE AREA - Max 64 PPS, each has 0x80 bytes, total 0x2000 bytes
+            .buf_size = 0x2000,
+        },
+        .sao_up = {
+            // SAO UP STORE AREA - Max 640(10240/16) LCU, each has 16 bytes total 0x2800 bytes
+            .buf_size = 0x2800,
+        },
+        .swap_buf = {
+            // 256cyclex64bit = 2K bytes 0x800 (only 144 cycles valid)
+            .buf_size = 0x800,
+        },
+        .swap_buf2 = {
+            .buf_size = 0x800,
+        },
+        .scalelut = {
+            // support up to 32 SCALELUT 1024x32 = 32Kbytes (0x8000)
+            .buf_size = 0x8000,
+        },
+        .dblk_para = {
+            // DBLK -> Max 256(4096/16) LCU, each para 512bytes(total:0x20000), data 1024bytes(total:0x40000)
+            .buf_size = 0x20000,
+        },
+        .dblk_data = {
+            .buf_size = 0x40000,
+        },
+        .mpred_above = {
+            .buf_size = 0x8000,
+        },
+        .mpred_mv = {
+           .buf_size = 0x100000*16, //4k2k , 0x100000 per buffer
+        },
+    }
+};
+
+static void init_buff_spec(BuffInfo_t* buf_spec)
+{
+    buf_spec->ipp.buf_start = buf_spec->start_adr;
+    buf_spec->sao_abv.buf_start = buf_spec->ipp.buf_start + buf_spec->ipp.buf_size;
+
+    buf_spec->sao_vb.buf_start   = buf_spec->sao_abv.buf_start + buf_spec->sao_abv.buf_size;
+    buf_spec->short_term_rps.buf_start    = buf_spec->sao_vb.buf_start + buf_spec->sao_vb.buf_size;
+    buf_spec->vps.buf_start     = buf_spec->short_term_rps.buf_start + buf_spec->short_term_rps.buf_size;
+    buf_spec->sps.buf_start     = buf_spec->vps.buf_start + buf_spec->vps.buf_size;
+    buf_spec->pps.buf_start     = buf_spec->sps.buf_start + buf_spec->sps.buf_size;
+    buf_spec->sao_up.buf_start  = buf_spec->pps.buf_start + buf_spec->pps.buf_size;
+    buf_spec->swap_buf.buf_start= buf_spec->sao_up.buf_start + buf_spec->sao_up.buf_size;
+    buf_spec->swap_buf2.buf_start  = buf_spec->swap_buf.buf_start + buf_spec->swap_buf.buf_size;
+    buf_spec->scalelut.buf_start= buf_spec->swap_buf2.buf_start + buf_spec->swap_buf2.buf_size;
+    buf_spec->dblk_para.buf_start = buf_spec->scalelut.buf_start + buf_spec->scalelut.buf_size;
+    buf_spec->dblk_data.buf_start = buf_spec->dblk_para.buf_start + buf_spec->dblk_para.buf_size;
+    buf_spec->mpred_above.buf_start = buf_spec->dblk_data.buf_start + buf_spec->dblk_data.buf_size;
+    buf_spec->mpred_mv.buf_start    = buf_spec->mpred_above.buf_start + buf_spec->mpred_above.buf_size;
+
+    buf_spec->end_adr = buf_spec->mpred_mv.buf_start + buf_spec->mpred_mv.buf_size;
+    printk("%s workspace (%x %x) size = %x\n", __func__,buf_spec->start_adr, buf_spec->end_adr, buf_spec->end_adr-buf_spec->start_adr);
+    
+}
+
+
+enum SliceType
+{
+  B_SLICE,
+  P_SLICE,
+  I_SLICE
+};
+
+#define MAX_REF_PIC_NUM 16
+#define MAX_SLICE_NUM 1024
+typedef struct PIC_{
+	struct PIC_ * next;
+        int index;
+	int POC;
+	int decode_idx;
+	int slice_type;
+	int RefNum_L0;
+	int RefNum_L1;
+	int num_reorder_pic;
+        int stream_offset;
+	unsigned char referenced;
+	unsigned char output_mark;
+	unsigned char recon_mark;
+	unsigned char output_ready;
+	/**/
+	int slice_idx;
+	int m_aiRefPOCList0[MAX_SLICE_NUM][16];
+	int m_aiRefPOCList1[MAX_SLICE_NUM][16];
+	/*buffer*/
+	unsigned long mpred_mv_wr_start_addr;
+	unsigned long mc_y_adr;
+	unsigned long mc_u_v_adr;
+	int mc_canvas_y;
+	int mc_canvas_u_v;
+}PIC_t;
+static PIC_t m_PIC[MAX_REF_PIC_NUM ];
+
+
+typedef struct hevc_state_{
+    BuffInfo_t* work_space_buf;
+    buff_t* mc_buf;
+    
+    unsigned int pic_list_init_flag;
+    
+    PIC_t* free_pic_list;
+    PIC_t* decode_pic_list;
+
+    int     pic_w           ;
+    int     pic_h           ;
+    int     lcu_x_num;
+    int     lcu_y_num;
+    int     lcu_total;
+    int     lcu_size        ;
+    int     lcu_size_log2   ;
+
+    int num_tile_col;
+    int num_tile_row;
+    int tile_enabled;
+    int     tile_x;
+    int     tile_y;
+    int     tile_y_x;
+    int     tile_start_lcu_x;
+    int     tile_start_lcu_y; 
+    int     tile_width_lcu  ;
+    int     tile_height_lcu ; 
+
+    int     slice_type      ;
+    int     slice_addr;
+    int     slice_segment_addr;
+
+    unsigned short misc_flag0;
+    int     m_temporalId;
+    int     m_nalUnitType;
+    int     TMVPFlag        ;
+    int     isNextSliceSegment;
+    int     LDCFlag         ;
+    int     m_pocRandomAccess;
+    int     plevel          ;
+    int     MaxNumMergeCand ;
+
+    int     new_pic;
+    int     new_tile;
+    int     curr_POC        ;
+    int     iPrevPOC;
+    int     iPrevTid0POC;
+    int     list_no;
+    int     RefNum_L0       ;
+    int     RefNum_L1       ;
+    int     ColFromL0Flag   ;
+    int     LongTerm_Curr   ;
+    int     LongTerm_Col    ;
+    int     Col_POC         ;
+    int     LongTerm_Ref    ;
+    
+    
+    PIC_t* cur_pic;
+    PIC_t* col_pic;
+    int skip_flag;
+    int decode_idx;
+    unsigned char wait_buf;
+    unsigned char error_flag;
+}hevc_stru_t;
+
+
+static void hevc_init_stru(hevc_stru_t* hevc, BuffInfo_t* buf_spec_i, buff_t* mc_buf_i)
+{
+    int i;
+    hevc->work_space_buf = buf_spec_i;
+    hevc->mc_buf = mc_buf_i;
+
+    hevc->curr_POC = INVALID_POC;
+    hevc->free_pic_list = NULL;
+    hevc->decode_pic_list = NULL;
+
+    hevc->pic_list_init_flag = 0;
+    hevc->decode_idx = 0;
+    hevc->new_pic=0;
+    hevc->new_tile=0;
+    hevc->iPrevPOC=0;
+    hevc->list_no=0;
+    //int m_uiMaxCUWidth = 1<<7;
+    //int m_uiMaxCUHeight = 1<<7;
+    hevc->m_pocRandomAccess = MAX_INT;
+    hevc->tile_enabled = 0;
+    hevc->tile_x = 0;
+    hevc->tile_y = 0;
+    hevc->iPrevTid0POC = 0;
+    hevc->slice_addr = 0;
+    hevc->slice_segment_addr = 0;
+    hevc->skip_flag = 0;
+    hevc->misc_flag0 = 0;
+        
+    hevc->cur_pic = NULL;
+    hevc->col_pic = NULL;
+    hevc->wait_buf = 0;
+    hevc->error_flag = 0;
+    
+    for(i=0; i<MAX_REF_PIC_NUM; i++){
+        m_PIC[i].index = -1;
+    }
+}    
+
+static void dump_lmem(void)
+{
+	int i;
+	unsigned int data32;
+
+        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_DUMP_LMEM);
+        // Interrupt Amrisc to excute 
+        WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+	printk("\ndump_lmem:");
+	for(i=0; i<0x400; i++){
+		do{
+			data32 = READ_VREG(RPM_CMD_REG);
+			//printk("%x\n", data32);
+		}while((data32&0x10000)==0);	
+            	printk("%04x ", data32&0xffff);
+            	if(((i+1)&0xf)==0)
+                	printk("\n");
+		WRITE_VREG(RPM_CMD_REG, 0);		
+	}
+
+}
+
+static void get_rpm_param(param_t* params)
+{
+	int i;
+	unsigned int data32;
+	for(i=0; i<128; i++){
+		do{
+			data32 = READ_VREG(RPM_CMD_REG);
+			//printk("%x\n", data32);
+		}while((data32&0x10000)==0);	
+		params->l.data[i] = data32&0xffff;
+		//printk("%x\n", data32);
+		WRITE_VREG(RPM_CMD_REG, 0);		
+	}
+}
+
+
+static void in_q(PIC_t** list_head, PIC_t* pic)
+{
+	PIC_t* list_tail = *list_head;	
+	pic->next = NULL;
+	if(*list_head == NULL){
+		*list_head = pic;	
+	}
+	else{
+		while(list_tail->next){
+			list_tail = list_tail->next;		
+		}
+		list_tail->next = pic;
+	}
+}
+
+static PIC_t* out_q(PIC_t** list_head)
+{
+	PIC_t* pic = *list_head;
+	if(pic){
+		*list_head = pic->next;
+	}
+	return pic;
+}
+
+static PIC_t* get_pic_by_POC(hevc_stru_t* hevc, int POC)
+{
+	PIC_t* pic = hevc->decode_pic_list;
+	PIC_t* ret_pic = NULL;
+	while(pic){
+		if(pic->POC==POC){
+			if(ret_pic==NULL){
+				ret_pic = pic;		
+			}
+			else{
+				if(pic->decode_idx > ret_pic->decode_idx)
+					ret_pic = pic;			
+			}
+		}
+		pic = pic->next;
+	}
+	return ret_pic;
+}
+
+static PIC_t* get_ref_pic_by_POC(hevc_stru_t* hevc, int POC)
+{
+	PIC_t* pic = hevc->decode_pic_list;
+	while(pic){
+		if((pic->POC==POC)&&(pic->referenced))
+			break;
+		pic = pic->next;
+	}
+	if(pic==NULL){
+		printk("Wrong, POC of %d is not in referenced list\n", POC);		
+		pic = hevc->decode_pic_list;
+		while(pic){
+			if(pic->POC==POC)
+				break;
+			pic = pic->next;
+		}
+	}
+	return pic;
+}
+
+static PIC_t* get_pic_by_IDX(hevc_stru_t* hevc, int idx)
+{
+	int i = 0;
+	PIC_t* pic = hevc->decode_pic_list;
+	while(pic){
+		if(i==idx)
+			break;
+		pic = pic->next;
+		i++;
+	}
+	return pic;
+}
+
+static int init_buf_spec(hevc_stru_t* hevc);
+
+static void init_pic_list(hevc_stru_t* hevc)
+{
+	int i;
+  int pic_width = hevc->pic_w;
+  int pic_height = hevc->pic_h;
+  int lcu_size_log2 = hevc->lcu_size_log2;
+	int lcu_size = 1<<lcu_size_log2;
+        int pic_width_lcu  = ( pic_width %lcu_size  ) ? pic_width /lcu_size  + 1 : pic_width /lcu_size; 
+        int pic_height_lcu = ( pic_height %lcu_size ) ? pic_height/lcu_size + 1 : pic_height/lcu_size; 
+        int lcu_total       =pic_width_lcu*pic_height_lcu;
+	//int MV_MEM_UNIT=lcu_size_log2==6 ? 0x100 : lcu_size_log2==5 ? 0x40 : 0x10;
+	int MV_MEM_UNIT=lcu_size_log2==6 ? 0x200 : lcu_size_log2==5 ? 0x80 : 0x20;
+	int mc_buffer_size_u_v = lcu_total*lcu_size*lcu_size/2;
+	int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16;
+	int mpred_mv_end = hevc->work_space_buf->mpred_mv.buf_start + hevc->work_space_buf->mpred_mv.buf_size;
+	int mc_buffer_end = hevc->mc_buf->buf_start + hevc->mc_buf->buf_size;
+	if(mc_buffer_size_u_v&0xffff){ //64k alignment
+		mc_buffer_size_u_v_h+=1;
+	}
+
+	printk("[Buffer Management] init_pic_list (%d %d):\n", hevc->pic_w, hevc->pic_h);	
+
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x0);
+	for(i=0; i<MAX_REF_PIC_NUM; i++){
+		if(((i+1)*(mc_buffer_size_u_v_h<<16)*3) > hevc->mc_buf->buf_size){
+                      printk("%s maximum buf size is used\n", __func__);
+                      break;
+                }
+
+                m_PIC[i].index = i;
+		m_PIC[i].mpred_mv_wr_start_addr = hevc->work_space_buf->mpred_mv.buf_start + ((i * lcu_total)*MV_MEM_UNIT);
+		
+		m_PIC[i].mc_y_adr = hevc->mc_buf->buf_start + i*(mc_buffer_size_u_v_h<<16)*3;
+		m_PIC[i].mc_u_v_adr = m_PIC[i].mc_y_adr + ((mc_buffer_size_u_v_h<<16)<<1);
+		m_PIC[i].mc_canvas_y = (i<<1);
+		m_PIC[i].mc_canvas_u_v = (i<<1)+1;
+
+		if(((m_PIC[i].mc_y_adr+((mc_buffer_size_u_v_h<<16)*3)) > mc_buffer_end)||
+			((m_PIC[i].mpred_mv_wr_start_addr+(lcu_total*MV_MEM_UNIT)) > mpred_mv_end)){
+	    printk("Max mc buffer or mpred_mv buffer is used\n");		
+			break;
+		}
+		in_q(&hevc->free_pic_list, &m_PIC[i]);
+
+
+		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, m_PIC[i].mc_y_adr|(m_PIC[i].mc_canvas_y<<8)|0x1);
+		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, m_PIC[i].mc_u_v_adr|(m_PIC[i].mc_canvas_u_v<<8)|0x1);
+
+    if(debug&H265_DEBUG_BUFMGR){
+        printk("Buffer %d: canv_y %x  canv_u_v %x mc_y_adr %lx mc_u_v_adr %lx mpred_mv_wr_start_addr %lx\n", i, m_PIC[i].mc_canvas_y,m_PIC[i].mc_canvas_u_v,m_PIC[i].mc_y_adr, m_PIC[i].mc_u_v_adr, m_PIC[i].mpred_mv_wr_start_addr);
+    }
+	}
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x1);
+
+
+    // Zero out canvas registers in IPP -- avoid simulation X
+	    WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 1);
+		for(i=0; i<32; i++){
+				WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
+        }
+
+}
+
+static void dump_pic_list(hevc_stru_t* hevc)
+{
+	PIC_t* pic = hevc->decode_pic_list;
+	while(pic){
+		printk("index %d decode_idx:%d,	POC:%d,	referenced:%d,	num_reorder_pic:%d, output_mark:%d, output_ready:%d, mv_wr_start %lx\n", pic->index, pic->decode_idx, pic->POC, pic->referenced, pic->num_reorder_pic, pic->output_mark, pic->output_ready, pic->mpred_mv_wr_start_addr);
+		pic = pic->next;
+	}
+}
+
+static PIC_t* output_pic(hevc_stru_t* hevc, unsigned char flush_flag)
+{
+	int num_pic_not_yet_display = 0;
+	PIC_t* pic = hevc->decode_pic_list;
+	PIC_t* pic_display = NULL;
+	while(pic){
+		if(pic->output_mark){
+			num_pic_not_yet_display++;
+		}
+		pic = pic->next;
+	}
+
+	pic = hevc->decode_pic_list;
+	while(pic){
+		if(pic->output_mark){
+			if(pic_display){
+				if(pic->POC < pic_display->POC){
+					pic_display = pic;
+				}
+			}
+			else{
+				pic_display = pic;			
+			}
+		}
+		pic = pic->next;
+	}
+	if(pic_display){
+		if((num_pic_not_yet_display > pic_display->num_reorder_pic)||flush_flag){
+			pic_display->output_mark = 0;
+			pic_display->recon_mark = 0;
+			pic_display->output_ready = 1;
+		}
+		else{
+			pic_display = NULL;		
+		}
+	}
+	return pic_display;
+}
+
+static int config_mc_buffer(hevc_stru_t* hevc, PIC_t* cur_pic)
+{
+	int i;	
+	PIC_t* pic;
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("config_mc_buffer entered .....\n");
+	if(cur_pic->slice_type != 2){ //P and B pic
+	    WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 1);
+		for(i=0; i<cur_pic->RefNum_L0; i++){
+			pic = get_ref_pic_by_POC(hevc, cur_pic->m_aiRefPOCList0[cur_pic->slice_idx][i]);
+			if(pic){
+				WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, (pic->mc_canvas_u_v<<16)|(pic->mc_canvas_u_v<<8)|pic->mc_canvas_y);
+        if(debug&H265_DEBUG_BUFMGR) 
+            printk("refid %x mc_canvas_u_v %x mc_canvas_y %x\n", i,pic->mc_canvas_u_v,pic->mc_canvas_y);
+			}
+			else{
+				printk("Error %s, %dth poc (%d) of RPS is not in the pic list0\n", __func__, i, cur_pic->m_aiRefPOCList0[cur_pic->slice_idx][i]);
+				return -1;
+				//dump_lmem();
+			}
+		}
+	}
+	if(cur_pic->slice_type == 0){ //B pic
+        if(debug&H265_DEBUG_BUFMGR) 
+            printk("config_mc_buffer RefNum_L1\n");
+	    WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (16 << 8) | (0<<1) | 1);
+		for(i=0; i<cur_pic->RefNum_L1; i++){
+			pic = get_ref_pic_by_POC(hevc, cur_pic->m_aiRefPOCList1[cur_pic->slice_idx][i]);
+			if(pic){
+				WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, (pic->mc_canvas_u_v<<16)|(pic->mc_canvas_u_v<<8)|pic->mc_canvas_y);
+                if(debug&H265_DEBUG_BUFMGR){
+                    printk("refid %x mc_canvas_u_v %x mc_canvas_y %x\n", i,pic->mc_canvas_u_v,pic->mc_canvas_y);
+                }
+			}
+			else{
+				printk("Error %s, %dth poc (%d) of RPS is not in the pic list1\n", __func__, i, cur_pic->m_aiRefPOCList1[cur_pic->slice_idx][i]);
+				return -1;
+				//dump_lmem();
+			}
+		}
+	}
+	return 0;
+}
+
+static void apply_ref_pic_set(hevc_stru_t* hevc, int cur_poc, param_t* params)
+{
+	int i;
+	int poc_tmp;
+	PIC_t* pic = hevc->decode_pic_list;
+	unsigned char is_referenced;
+	//printk("%s cur_poc %d\n", __func__, cur_poc);	
+	while(pic){
+		if((pic->referenced == 0 || pic->POC == cur_poc)){
+			pic = pic->next;
+			continue;
+		}
+		is_referenced = 0;
+		for(i=0; i<16; i++){
+			int delt;
+			if(params->p.CUR_RPS[i]&0x8000)
+				break;		
+			delt = params->p.CUR_RPS[i]&((1<<(RPS_USED_BIT-1))-1);
+			if(params->p.CUR_RPS[i]&(1<<(RPS_USED_BIT-1))){
+				poc_tmp = cur_poc - ((1<<(RPS_USED_BIT-1))-delt) ;
+			}
+			else{
+				poc_tmp = cur_poc + delt;
+			}
+			if(poc_tmp == pic->POC){
+				is_referenced = 1;
+				//printk("i is %d\n", i);
+				break;
+			}
+		}
+		if(is_referenced == 0){
+			pic->referenced = 0;
+			//printk("set poc %d reference to 0\n", pic->POC);
+		}
+		pic = pic->next;
+	}
+
+}
+
+static void set_ref_pic_list(PIC_t* pic,  param_t* params)
+{
+	int i, rIdx;
+	int num_neg = 0;
+	int num_pos = 0;
+	int total_num;
+	int num_ref_idx_l0_active = params->p.num_ref_idx_l0_active;
+	int num_ref_idx_l1_active = params->p.num_ref_idx_l1_active;
+	int RefPicSetStCurr0[16];
+	int RefPicSetStCurr1[16];
+	for(i=0;i<16;i++){
+		RefPicSetStCurr0[i]=0; RefPicSetStCurr1[i]=0;
+		pic->m_aiRefPOCList0[pic->slice_idx][i] = 0;
+		pic->m_aiRefPOCList1[pic->slice_idx][i] = 0;
+	}
+	for(i=0; i<16; i++){
+		if(params->p.CUR_RPS[i]&0x8000)
+			break;		
+		if((params->p.CUR_RPS[i]>>RPS_USED_BIT)&1){
+			int delt = params->p.CUR_RPS[i]&((1<<(RPS_USED_BIT-1))-1);
+			if((params->p.CUR_RPS[i]>>(RPS_USED_BIT-1))&1){
+				RefPicSetStCurr0[num_neg]=pic->POC - ((1<<(RPS_USED_BIT-1))-delt) ;
+				//printk("RefPicSetStCurr0 %x %x %x\n", RefPicSetStCurr0[num_neg], pic->POC, (0x800-(params[i]&0x7ff)));
+				num_neg++;
+			}
+			else{
+				RefPicSetStCurr1[num_pos]=pic->POC + delt;
+				//printk("RefPicSetStCurr1 %d\n", RefPicSetStCurr1[num_pos]);
+				num_pos++;
+			}
+		}	
+	}
+	total_num = num_neg + num_pos;
+	if(debug&H265_DEBUG_POC){
+	    printk("%s: curpoc %d total %d num_neg %d num_list0 %d num_list1 %d\n", __func__,
+		        pic->POC, total_num, num_neg,num_ref_idx_l0_active, num_ref_idx_l1_active);
+	}
+	
+	if(total_num>0){
+		if(params->p.modification_flag&0x1){
+			if(debug&H265_DEBUG_BUFMGR) 
+			    printk("ref0 POC (modification):");
+			for(rIdx=0; rIdx<num_ref_idx_l0_active; rIdx++){
+				int cIdx = params->p.modification_list[rIdx];
+				pic->m_aiRefPOCList0[pic->slice_idx][rIdx] = cIdx>=num_neg?RefPicSetStCurr1[cIdx-num_neg]:RefPicSetStCurr0[cIdx];	
+				if(debug&H265_DEBUG_BUFMGR) 
+				    printk("%d ", pic->m_aiRefPOCList0[pic->slice_idx][rIdx]);
+			}
+		}
+		else{
+			if(debug&H265_DEBUG_BUFMGR) 
+			    printk("ref0 POC:");
+			for(rIdx=0; rIdx<num_ref_idx_l0_active; rIdx++){
+				int cIdx = rIdx % total_num;		
+				pic->m_aiRefPOCList0[pic->slice_idx][rIdx] = cIdx>=num_neg?RefPicSetStCurr1[cIdx-num_neg]:RefPicSetStCurr0[cIdx];	
+				if(debug&H265_DEBUG_BUFMGR) 
+				    printk("%d ", pic->m_aiRefPOCList0[pic->slice_idx][rIdx]);
+			}
+		}
+		if(debug&H265_DEBUG_BUFMGR) 
+		    printk("\n");
+		if(params->p.slice_type == B_SLICE){
+			if(params->p.modification_flag&0x2){
+				if(debug&H265_DEBUG_BUFMGR) 
+				    printk("ref1 POC (modification):");
+				for(rIdx=0; rIdx<num_ref_idx_l1_active; rIdx++){
+					int cIdx;
+					if(params->p.modification_flag&0x1){
+					    cIdx = params->p.modification_list[num_ref_idx_l0_active+rIdx];
+					}
+					else{
+				            cIdx = params->p.modification_list[rIdx];
+					}
+					pic->m_aiRefPOCList1[pic->slice_idx][rIdx] = cIdx>=num_pos?RefPicSetStCurr0[cIdx-num_pos]:RefPicSetStCurr1[cIdx];
+					if(debug&H265_DEBUG_BUFMGR) 
+					    printk("%d ", pic->m_aiRefPOCList1[pic->slice_idx][rIdx]);
+				}
+			}
+			else{
+				if(debug&H265_DEBUG_BUFMGR) 
+				    printk("ref1 POC:");
+				for(rIdx=0; rIdx<num_ref_idx_l1_active; rIdx++){
+					int cIdx = rIdx % total_num;		
+					pic->m_aiRefPOCList1[pic->slice_idx][rIdx] = cIdx>=num_pos?RefPicSetStCurr0[cIdx-num_pos]:RefPicSetStCurr1[cIdx];
+					if(debug&H265_DEBUG_BUFMGR) 
+					    printk("%d ", pic->m_aiRefPOCList1[pic->slice_idx][rIdx]);
+				}
+			}
+			if(debug&H265_DEBUG_BUFMGR) 
+			    printk("\n");
+		}
+	}
+	/*set m_PIC */
+	pic->slice_type = (params->p.slice_type == I_SLICE ) ? 2 :
+                                (params->p.slice_type == P_SLICE ) ? 1 :
+                                (params->p.slice_type == B_SLICE ) ? 0 : 3;
+	pic->RefNum_L0 = num_ref_idx_l0_active;
+	pic->RefNum_L1 = num_ref_idx_l1_active;
+}
+
+#define MAX_TILE_COL_NUM	5
+#define MAX_TILE_ROW_NUM	5
+typedef struct{
+	int width;
+	int height;
+	int start_cu_x;
+	int start_cu_y;
+	
+	unsigned long sao_vb_start_addr;
+	unsigned long sao_abv_start_addr;
+}tile_t;
+tile_t m_tile[MAX_TILE_ROW_NUM][MAX_TILE_COL_NUM];
+
+static void update_tile_info(hevc_stru_t* hevc,  int pic_width_cu, int pic_height_cu, int sao_mem_unit, param_t* params)
+{
+	int i,j;	
+	int start_cu_x, start_cu_y;
+    int sao_vb_size = (sao_mem_unit+(2<<4))*pic_height_cu;
+    int sao_abv_size = sao_mem_unit*pic_width_cu;
+
+	hevc->tile_enabled = params->p.tiles_enabled_flag&1;
+	if(params->p.tiles_enabled_flag&1){
+		hevc->num_tile_col = params->p.num_tile_columns_minus1 + 1;
+		hevc->num_tile_row = params->p.num_tile_rows_minus1 + 1;
+		if(debug&H265_DEBUG_BUFMGR){
+		    printk("%s pic_w_cu %d pic_h_cu %d tile_enabled num_tile_col %d num_tile_row %d:\n", __func__, pic_width_cu, pic_height_cu, hevc->num_tile_col, hevc->num_tile_row);
+		}
+
+
+		if(params->p.tiles_enabled_flag&2){ //uniform flag
+			int w = pic_width_cu/hevc->num_tile_col;
+			int h = pic_height_cu/hevc->num_tile_row;
+			start_cu_y = 0;			
+			for(i=0; i<hevc->num_tile_row; i++){
+				start_cu_x = 0;
+				for(j=0; j<hevc->num_tile_col; j++){
+					if(j == (hevc->num_tile_col-1))
+						m_tile[i][j].width = pic_width_cu - start_cu_x;
+					else			
+						m_tile[i][j].width = w;
+					if(i == (hevc->num_tile_row-1))
+						m_tile[i][j].height = pic_height_cu - start_cu_y;
+					else			
+						m_tile[i][j].height = h;
+					m_tile[i][j].start_cu_x = start_cu_x;
+					m_tile[i][j].start_cu_y = start_cu_y;
+					m_tile[i][j].sao_vb_start_addr = hevc->work_space_buf->sao_vb.buf_start + j*sao_vb_size ;
+					m_tile[i][j].sao_abv_start_addr = hevc->work_space_buf->sao_abv.buf_start + i*sao_abv_size ;
+					if(debug&H265_DEBUG_BUFMGR){
+					    printk("{y=%d, x=%d w %d h %d start_x %d start_y %d sao_vb_start 0x%lx sao_abv_start 0x%lx}\n", 
+						    i,j,m_tile[i][j].width,m_tile[i][j].height, m_tile[i][j].start_cu_x, m_tile[i][j].start_cu_y,m_tile[i][j].sao_vb_start_addr, m_tile[i][j].sao_abv_start_addr);
+					}
+					start_cu_x += m_tile[i][j].width;
+					
+				}
+				start_cu_y += m_tile[i][0].height;
+			}			
+		}
+		else{
+			start_cu_y = 0;			
+			for(i=0; i<hevc->num_tile_row; i++){
+				start_cu_x = 0;
+				for(j=0; j<hevc->num_tile_col; j++){
+					if(j == (hevc->num_tile_col-1))
+						m_tile[i][j].width = pic_width_cu - start_cu_x;
+					else			
+						m_tile[i][j].width = params->p.tile_width[j];
+					if(i == (hevc->num_tile_row-1))
+						m_tile[i][j].height = pic_height_cu - start_cu_y;
+					else			
+						m_tile[i][j].height = params->p.tile_height[i];
+					m_tile[i][j].start_cu_x = start_cu_x;
+					m_tile[i][j].start_cu_y = start_cu_y;
+					m_tile[i][j].sao_vb_start_addr = hevc->work_space_buf->sao_vb.buf_start + j*sao_vb_size ;
+					m_tile[i][j].sao_abv_start_addr = hevc->work_space_buf->sao_abv.buf_start + i*sao_abv_size ;
+					if(debug&H265_DEBUG_BUFMGR){
+					    printk("{y=%d, x=%d w %d h %d start_x %d start_y %d sao_vb_start 0x%lx sao_abv_start 0x%lx}\n", 
+						    i,j,m_tile[i][j].width,m_tile[i][j].height, m_tile[i][j].start_cu_x, m_tile[i][j].start_cu_y,m_tile[i][j].sao_vb_start_addr, m_tile[i][j].sao_abv_start_addr);
+				  }
+					start_cu_x += m_tile[i][j].width;
+				}
+				start_cu_y += m_tile[i][0].height;
+			}			
+		}
+	}
+	else{
+		hevc->num_tile_col = 1;
+		hevc->num_tile_row = 1;
+		m_tile[0][0].width = pic_width_cu;
+		m_tile[0][0].height = pic_height_cu;
+		m_tile[0][0].start_cu_x = 0;
+		m_tile[0][0].start_cu_y = 0;
+		m_tile[0][0].sao_vb_start_addr = hevc->work_space_buf->sao_vb.buf_start;
+		m_tile[0][0].sao_abv_start_addr = hevc->work_space_buf->sao_abv.buf_start;
+	}
+}
+
+static int get_tile_index(hevc_stru_t* hevc, int cu_adr, int pic_width_lcu)
+{
+	int cu_x = cu_adr%pic_width_lcu;
+	int cu_y = cu_adr/pic_width_lcu;
+	int tile_x = 0;
+	int tile_y = 0;
+	int i;
+	if(hevc->tile_enabled){	
+		for(i=0;i<hevc->num_tile_col;i++){	
+			if(cu_x>=m_tile[0][i].start_cu_x){
+				tile_x = i;		
+			}
+			else{
+				break;
+			}
+		}
+		for(i=0;i<hevc->num_tile_row;i++){	
+			if(cu_y>=m_tile[i][0].start_cu_y){
+				tile_y = i;		
+			}
+			else{
+				break;
+			}
+		}
+	}
+	return (tile_x)|(tile_y<<8);
+}
+
+static void print_scratch_error(int error_num)
+{
+  printk(" ERROR : HEVC_ASSIST_SCRATCH_TEST Error : %d\n", error_num);
+}
+
+static void hevc_config_work_space_hw(hevc_stru_t* hevc)
+{
+    BuffInfo_t* buf_spec = hevc->work_space_buf;
+    
+    printk("%s %x %x %x %x %x %x %x %x %x %x %x %x\n", __func__,
+			buf_spec->ipp.buf_start,
+			buf_spec->start_adr,
+			buf_spec->short_term_rps.buf_start,
+			buf_spec->vps.buf_start,
+			buf_spec->sps.buf_start,
+                        buf_spec->pps.buf_start,
+                        buf_spec->sao_up.buf_start,
+                        buf_spec->swap_buf.buf_start,
+			buf_spec->swap_buf2.buf_start,
+			buf_spec->scalelut.buf_start,
+			buf_spec->dblk_para.buf_start,
+			buf_spec->dblk_data.buf_start);
+    WRITE_VREG(HEVCD_IPP_LINEBUFF_BASE,buf_spec->ipp.buf_start);
+    WRITE_VREG(HEVC_WORK_SPACE_REG, buf_spec->start_adr);
+    WRITE_VREG(HEVC_SHORT_TERM_RPS, buf_spec->short_term_rps.buf_start);
+    WRITE_VREG(HEVC_VPS_BUFFER, buf_spec->vps.buf_start);
+    WRITE_VREG(HEVC_SPS_BUFFER, buf_spec->sps.buf_start);
+    WRITE_VREG(HEVC_PPS_BUFFER, buf_spec->pps.buf_start);
+    WRITE_VREG(HEVC_SAO_UP, buf_spec->sao_up.buf_start);
+    WRITE_VREG(HEVC_STREAM_SWAP_BUFFER, buf_spec->swap_buf.buf_start);
+    WRITE_VREG(HEVC_STREAM_SWAP_BUFFER2, buf_spec->swap_buf2.buf_start);
+    WRITE_VREG(HEVC_SCALELUT, buf_spec->scalelut.buf_start);
+
+    WRITE_VREG(HEVC_DBLK_CFG4, buf_spec->dblk_para.buf_start); // cfg_p_addr
+    WRITE_VREG(HEVC_DBLK_CFG5, buf_spec->dblk_data.buf_start); // cfg_d_addr
+    
+}    
+
+static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
+{
+    unsigned int data32;
+    int i;
+
+#if 1
+// m8baby test1902
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Test Parser Register Read/Write\n");
+    data32 = READ_VREG(HEVC_PARSER_VERSION);
+    if(data32 != 0x00010001) { print_scratch_error(25); return; } 
+    WRITE_VREG(HEVC_PARSER_VERSION, 0x5a5a55aa);
+    data32 = READ_VREG(HEVC_PARSER_VERSION);
+    if(data32 != 0x5a5a55aa) { print_scratch_error(26); return; } 
+
+#if 0
+    // test Parser Reset
+    WRITE_VREG(DOS_SW_RESET3, 
+      (1<<14) | // reset iqit to start mem init again 
+      (1<<3)    // reset_whole parser
+      );
+    WRITE_VREG(DOS_SW_RESET3, 0);      // clear reset_whole parser
+    data32 = READ_VREG(HEVC_PARSER_VERSION);
+    if(data32 != 0x00010001) { 
+        printk("Test Parser Fatal Error\n"); 
+        while(1){};
+    }
+#endif
+
+    WRITE_VREG(DOS_SW_RESET3, 
+      (1<<14)  // reset iqit to start mem init again 
+      );
+    CLEAR_VREG_MASK(HEVC_CABAC_CONTROL, 1);
+    CLEAR_VREG_MASK(HEVC_PARSER_CORE_CONTROL, 1);
+
+#endif
+
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Enable BitStream Fetch\n");
+    data32 = READ_VREG(HEVC_STREAM_CONTROL);
+    data32 = data32 | 
+             (1 << 0) // stream_fetch_enable
+             ;
+    WRITE_VREG(HEVC_STREAM_CONTROL, data32);
+
+    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+    if(data32 != 0x00000100) { print_scratch_error(29); return; } 
+    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+    if(data32 != 0x00000300) { print_scratch_error(30); return; } 
+    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x12345678);
+    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x9abcdef0);
+    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+    if(data32 != 0x12345678) { print_scratch_error(31); return; } 
+    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+    if(data32 != 0x9abcdef0) { print_scratch_error(32); return; } 
+    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x00000100);
+    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
+
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Enable HEVC Parser Interrupt\n");
+    data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
+    data32 = data32 | 
+             (1 << 24) |  // stream_buffer_empty_int_amrisc_enable
+             (1 << 22) |  // stream_fifo_empty_int_amrisc_enable
+             (1 << 7) |  // dec_done_int_cpu_enable
+             (1 << 4) |  // startcode_found_int_cpu_enable
+             (0 << 3) |  // startcode_found_int_amrisc_enable
+             (1 << 0)    // parser_int_enable
+             ;
+    WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
+
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Enable HEVC Parser Shift\n");
+
+    data32 = READ_VREG(HEVC_SHIFT_STATUS);
+    data32 = data32 | 
+             (1 << 1) |  // emulation_check_on
+             (1 << 0)    // startcode_check_on
+             ;
+    WRITE_VREG(HEVC_SHIFT_STATUS, data32);
+
+    WRITE_VREG(HEVC_SHIFT_CONTROL, 
+              (3 << 6) | // sft_valid_wr_position
+              (2 << 4) | // emulate_code_length_sub_1
+              (2 << 1) | // start_code_length_sub_1
+              (1 << 0)   // stream_shift_enable
+            );
+
+    WRITE_VREG(HEVC_CABAC_CONTROL, 
+              (1 << 0)   // cabac_enable
+            );
+
+    WRITE_VREG(HEVC_PARSER_CORE_CONTROL, 
+              (1 << 0)   // hevc_parser_core_clk_en
+            );
+
+
+    WRITE_VREG(HEVC_DEC_STATUS_REG, 0);
+
+    // Initial IQIT_SCALELUT memory -- just to avoid X in simulation
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Initial IQIT_SCALELUT memory -- just to avoid X in simulation...\n");
+    WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0); // cfg_p_addr
+    for(i=0; i<1024; i++) WRITE_VREG(HEVC_IQIT_SCALELUT_DATA, 0);
+
+
+#ifdef ENABLE_SWAP_TEST
+    WRITE_VREG(HEVC_STREAM_SWAP_TEST, 100);
+#else
+    WRITE_VREG(HEVC_STREAM_SWAP_TEST, 0);
+#endif
+
+    WRITE_VREG(HEVC_DECODE_PIC_BEGIN_REG, decode_pic_begin);
+    WRITE_VREG(HEVC_DECODE_PIC_NUM_REG, decode_pic_num);
+
+    // Send parser_cmd
+    printk("[test.c] SEND Parser Command ...\n");
+    WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1<<16) | (0<<0));
+    for(i=0; i<PARSER_CMD_NUMBER; i++){
+      WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
+    }
+
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);
+
+    WRITE_VREG(HEVC_PARSER_IF_CONTROL, 
+            //  (1 << 8) | // sao_sw_pred_enable
+              (1 << 5) | // parser_sao_if_en
+              (1 << 2) | // parser_mpred_if_en
+              (1 << 0) // parser_scaler_if_en
+            );
+
+    // Changed to Start MPRED in microcode
+    /*
+    printk("[test.c] Start MPRED\n");
+    WRITE_VREG(HEVC_MPRED_INT_STATUS,
+            (1<<31)
+        ); 
+    */
+
+    printk("[test.c] Reset IPP\n");
+    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
+              (0 << 1) | // enable ipp
+              (1 << 0)   // software reset ipp and mpp
+            );
+    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
+              (1 << 1) | // enable ipp
+              (0 << 0)   // software reset ipp and mpp
+            );
+}
+
+static void decoder_hw_reset(void)
+{
+    int i;
+    unsigned int data32;
+    int decode_pic_begin = 0;
+    int decode_pic_num=0xffffffff;
+    WRITE_VREG(DOS_SW_RESET3, 
+      (1<<14)  // reset iqit to start mem init again 
+      );
+    CLEAR_VREG_MASK(HEVC_CABAC_CONTROL, 1);
+    CLEAR_VREG_MASK(HEVC_PARSER_CORE_CONTROL, 1);
+
+
+    data32 = READ_VREG(HEVC_STREAM_CONTROL);
+    data32 = data32 | 
+             (1 << 0) // stream_fetch_enable
+             ;
+    WRITE_VREG(HEVC_STREAM_CONTROL, data32);
+
+    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+    if(data32 != 0x00000100) { print_scratch_error(29); return; } 
+    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+    if(data32 != 0x00000300) { print_scratch_error(30); return; } 
+    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x12345678);
+    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x9abcdef0);
+    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+    if(data32 != 0x12345678) { print_scratch_error(31); return; } 
+    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+    if(data32 != 0x9abcdef0) { print_scratch_error(32); return; } 
+    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x00000100);
+    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
+
+    data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
+    data32 = data32 | 
+             (1 << 24) |  // stream_buffer_empty_int_amrisc_enable
+             (1 << 22) |  // stream_fifo_empty_int_amrisc_enable
+             (1 << 7) |  // dec_done_int_cpu_enable
+             (1 << 4) |  // startcode_found_int_cpu_enable
+             (0 << 3) |  // startcode_found_int_amrisc_enable
+             (1 << 0)    // parser_int_enable
+             ;
+    WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
+
+    data32 = READ_VREG(HEVC_SHIFT_STATUS);
+    data32 = data32 | 
+             (1 << 1) |  // emulation_check_on
+             (1 << 0)    // startcode_check_on
+             ;
+    WRITE_VREG(HEVC_SHIFT_STATUS, data32);
+
+    WRITE_VREG(HEVC_SHIFT_CONTROL, 
+              (3 << 6) | // sft_valid_wr_position
+              (2 << 4) | // emulate_code_length_sub_1
+              (2 << 1) | // start_code_length_sub_1
+              (1 << 0)   // stream_shift_enable
+            );
+
+    WRITE_VREG(HEVC_CABAC_CONTROL, 
+              (1 << 0)   // cabac_enable
+            );
+
+    WRITE_VREG(HEVC_PARSER_CORE_CONTROL, 
+              (1 << 0)   // hevc_parser_core_clk_en
+            );
+
+
+    WRITE_VREG(HEVC_DEC_STATUS_REG, 0);
+
+    // Initial IQIT_SCALELUT memory -- just to avoid X in simulation
+    WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0); // cfg_p_addr
+    for(i=0; i<1024; i++) WRITE_VREG(HEVC_IQIT_SCALELUT_DATA, 0);
+
+
+#ifdef ENABLE_SWAP_TEST
+    WRITE_VREG(HEVC_STREAM_SWAP_TEST, 100);
+#else
+    WRITE_VREG(HEVC_STREAM_SWAP_TEST, 0);
+#endif
+
+    WRITE_VREG(HEVC_DECODE_PIC_BEGIN_REG, decode_pic_begin);
+    WRITE_VREG(HEVC_DECODE_PIC_NUM_REG, decode_pic_num);
+
+    // Send parser_cmd
+    WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1<<16) | (0<<0));
+    for(i=0; i<PARSER_CMD_NUMBER; i++){
+      WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
+    }
+
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);
+
+    WRITE_VREG(HEVC_PARSER_IF_CONTROL, 
+            //  (1 << 8) | // sao_sw_pred_enable
+              (1 << 5) | // parser_sao_if_en
+              (1 << 2) | // parser_mpred_if_en
+              (1 << 0) // parser_scaler_if_en
+            );
+
+    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
+              (0 << 1) | // enable ipp
+              (1 << 0)   // software reset ipp and mpp
+            );
+    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
+              (1 << 1) | // enable ipp
+              (0 << 0)   // software reset ipp and mpp
+            );
+}
+
+#ifdef CONFIG_HEVC_CLK_FORCED_ON
+static void config_hevc_clk_forced_on ()
+{
+    unsigned int rdata32;
+    // IQIT
+    rdata32 = READ_VREG(HEVC_IQIT_CLK_RST_CTRL);
+    WRITE_VREG(HEVC_IQIT_CLK_RST_CTRL, rdata32 | (0x1<<2));
+
+    // DBLK
+    rdata32 = READ_VREG(HEVC_DBLK_CFG0);
+    WRITE_VREG(HEVC_DBLK_CFG0, rdata32 | (0x1<<2));
+
+    // SAO
+    rdata32 = READ_VREG(HEVC_SAO_CTRL1);
+    WRITE_VREG(HEVC_SAO_CTRL1, rdata32 | (0x1<<2));
+
+    // MPRED
+    rdata32 = READ_VREG(HEVC_MPRED_CTRL1);
+    WRITE_VREG(HEVC_MPRED_CTRL1, rdata32 | (0x1<<24));
+
+    // PARSER
+    rdata32 = READ_VREG(HEVC_STREAM_CONTROL);
+    WRITE_VREG(HEVC_STREAM_CONTROL, rdata32 | (0x1<<15));
+    rdata32 = READ_VREG(HEVC_SHIFT_CONTROL);
+    WRITE_VREG(HEVC_SHIFT_CONTROL, rdata32 | (0x1<<15));
+    rdata32 = READ_VREG(HEVC_CABAC_CONTROL);
+    WRITE_VREG(HEVC_CABAC_CONTROL, rdata32 | (0x1<<13));
+    rdata32 = READ_VREG(HEVC_PARSER_CORE_CONTROL);
+    WRITE_VREG(HEVC_PARSER_CORE_CONTROL, rdata32 | (0x1<<15));
+    rdata32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
+    WRITE_VREG(HEVC_PARSER_INT_CONTROL, rdata32 | (0x1<<15));
+    rdata32 = READ_VREG(HEVC_PARSER_IF_CONTROL);
+    WRITE_VREG(HEVC_PARSER_IF_CONTROL, rdata32 | (0x3<<5) | (0x3<<2) | (0x3<<0));
+
+    // IPP
+    rdata32 = READ_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG);
+    WRITE_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG, rdata32 | 0xffffffff);
+
+    // MCRCC
+    rdata32 = READ_VREG(HEVCD_MCRCC_CTL1);
+    WRITE_VREG(HEVCD_MCRCC_CTL1, rdata32 | (0x1<<3));
+}
+#endif
+
+#ifdef MCRCC_ENABLE
+static void  config_mcrcc_axi_hw (int slice_type)
+{
+    unsigned int rdata32;
+    unsigned int rdata32_2;
+
+    WRITE_VREG(HEVCD_MCRCC_CTL1, 0x2); // reset mcrcc
+    
+    if ( slice_type  == 2 ) { // I-PIC
+        WRITE_VREG(HEVCD_MCRCC_CTL1, 0x0); // remove reset -- disables clock 
+        return;
+    }
+
+    if ( slice_type == 0 ) {  // B-PIC
+        // Programme canvas0 
+        WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 0);
+        rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+        rdata32 = rdata32 & 0xffff;
+        rdata32 = rdata32 | ( rdata32 << 16);
+        WRITE_VREG(HEVCD_MCRCC_CTL2, rdata32);
+   
+        // Programme canvas1 
+        WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (16 << 8) | (1<<1) | 0);
+        rdata32_2 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+        rdata32_2 = rdata32_2 & 0xffff;
+        rdata32_2 = rdata32_2 | ( rdata32_2 << 16);
+        if( rdata32 == rdata32_2 ) {
+            rdata32_2 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+            rdata32_2 = rdata32_2 & 0xffff;
+            rdata32_2 = rdata32_2 | ( rdata32_2 << 16);
+        }
+        WRITE_VREG(HEVCD_MCRCC_CTL3, rdata32_2);
+    } else { // P-PIC 
+        WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (1<<1) | 0);
+        rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+        rdata32 = rdata32 & 0xffff;
+        rdata32 = rdata32 | ( rdata32 << 16);
+        WRITE_VREG(HEVCD_MCRCC_CTL2, rdata32);
+   
+        // Programme canvas1 
+        rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+        rdata32 = rdata32 & 0xffff;
+        rdata32 = rdata32 | ( rdata32 << 16);
+        WRITE_VREG(HEVCD_MCRCC_CTL3, rdata32);
+    }
+
+    WRITE_VREG(HEVCD_MCRCC_CTL1, 0xff0); // enable mcrcc progressive-mode 
+    return;
+}
+#endif
+
+
+static void  config_title_hw(hevc_stru_t* hevc, int sao_vb_size, int sao_mem_unit)
+{
+	WRITE_VREG(HEVC_sao_mem_unit, sao_mem_unit);
+	WRITE_VREG(HEVC_SAO_ABV, hevc->work_space_buf->sao_abv.buf_start);
+	WRITE_VREG(HEVC_sao_vb_size, sao_vb_size);
+	WRITE_VREG(HEVC_SAO_VB, hevc->work_space_buf->sao_vb.buf_start);
+}
+
+static void config_mpred_hw(hevc_stru_t* hevc)
+{
+    int i;
+    unsigned int data32;
+    PIC_t* cur_pic = hevc->cur_pic;
+    PIC_t* col_pic = hevc->col_pic;
+    int     AMVP_MAX_NUM_CANDS_MEM=3;
+    int     AMVP_MAX_NUM_CANDS=2;
+    int     NUM_CHROMA_MODE=5;
+    int     DM_CHROMA_IDX=36;
+    int     above_ptr_ctrl =0;
+    int     buffer_linear =1;
+    int     cu_size_log2 =3;
+
+    int     mpred_mv_rd_start_addr ;
+    int     mpred_curr_lcu_x;
+    int     mpred_curr_lcu_y;
+    int     mpred_above_buf_start ;
+    int     mpred_mv_rd_ptr ;
+    int     mpred_mv_rd_ptr_p1 ;
+    int     mpred_mv_rd_end_addr;
+    int     MV_MEM_UNIT;
+    int     mpred_mv_wr_ptr ;
+    int     *ref_poc_L0, *ref_poc_L1;
+
+    int     above_en;
+    int     mv_wr_en;
+    int     mv_rd_en;
+    int     col_isIntra;
+    if(hevc->slice_type!=2)
+    {
+        above_en=1;
+        mv_wr_en=1;
+        mv_rd_en=1;
+        col_isIntra=0;
+    }
+    else 
+    {
+        above_en=1;
+        mv_wr_en=1;
+        mv_rd_en=0;
+        col_isIntra=0;
+    }
+
+    mpred_mv_rd_start_addr=col_pic->mpred_mv_wr_start_addr;
+    data32 = READ_VREG(HEVC_MPRED_CURR_LCU);
+    mpred_curr_lcu_x   =data32 & 0xffff;
+    mpred_curr_lcu_y   =(data32>>16) & 0xffff;
+    
+    MV_MEM_UNIT=hevc->lcu_size_log2==6 ? 0x200 : hevc->lcu_size_log2==5 ? 0x80 : 0x20;
+    mpred_mv_rd_ptr = mpred_mv_rd_start_addr  + (hevc->slice_addr*MV_MEM_UNIT);
+    
+    mpred_mv_rd_ptr_p1  =mpred_mv_rd_ptr+MV_MEM_UNIT;
+    mpred_mv_rd_end_addr=mpred_mv_rd_start_addr + ((hevc->lcu_x_num*hevc->lcu_y_num)*MV_MEM_UNIT);
+    
+    mpred_above_buf_start = hevc->work_space_buf->mpred_above.buf_start;
+    
+    mpred_mv_wr_ptr = cur_pic->mpred_mv_wr_start_addr  + (hevc->slice_addr*MV_MEM_UNIT);
+    
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("cur pic index %d  col pic index %d\n", cur_pic->index, col_pic->index);
+    
+    WRITE_VREG(HEVC_MPRED_MV_WR_START_ADDR,cur_pic->mpred_mv_wr_start_addr);
+    WRITE_VREG(HEVC_MPRED_MV_RD_START_ADDR,mpred_mv_rd_start_addr);
+    
+    data32 = ((hevc->lcu_x_num - hevc->tile_width_lcu)*MV_MEM_UNIT);
+    WRITE_VREG(HEVC_MPRED_MV_WR_ROW_JUMP,data32);
+    WRITE_VREG(HEVC_MPRED_MV_RD_ROW_JUMP,data32);
+    
+    data32 = READ_VREG(HEVC_MPRED_CTRL0);
+    data32  =   ( 
+        hevc->slice_type | 
+        hevc->new_pic<<2 |
+        hevc->new_tile<<3|
+        hevc->isNextSliceSegment<<4|
+        hevc->TMVPFlag<<5|
+        hevc->LDCFlag<<6|
+        hevc->ColFromL0Flag<<7|
+        above_ptr_ctrl<<8 |  
+        above_en<<9|
+        mv_wr_en<<10|
+        mv_rd_en<<11|
+        col_isIntra<<12|
+        buffer_linear<<13|
+        hevc->LongTerm_Curr<<14|
+        hevc->LongTerm_Col<<15|
+        hevc->lcu_size_log2<<16|
+        cu_size_log2<<20|
+        hevc->plevel<<24 
+        );
+    WRITE_VREG(HEVC_MPRED_CTRL0,data32);
+    
+    data32 = READ_VREG(HEVC_MPRED_CTRL1);
+    data32  =   ( 
+#if 0
+//no set in m8baby test1902
+       (data32 & (0x1<<24)) |  // Don't override clk_forced_on , 
+#endif       
+        hevc->MaxNumMergeCand | 
+        AMVP_MAX_NUM_CANDS<<4 |
+        AMVP_MAX_NUM_CANDS_MEM<<8|
+        NUM_CHROMA_MODE<<12|
+        DM_CHROMA_IDX<<16
+        );
+    WRITE_VREG(HEVC_MPRED_CTRL1,data32);
+    
+    data32  =   (
+          hevc->pic_w|
+          hevc->pic_h<<16   
+          );
+    WRITE_VREG(HEVC_MPRED_PIC_SIZE,data32);
+    
+    data32  =   (
+          (hevc->lcu_x_num-1)   |
+          (hevc->lcu_y_num-1)<<16
+          );
+    WRITE_VREG(HEVC_MPRED_PIC_SIZE_LCU,data32);
+    
+    data32  =   (
+          hevc->tile_start_lcu_x   |
+          hevc->tile_start_lcu_y<<16
+          );
+    WRITE_VREG(HEVC_MPRED_TILE_START,data32);
+    
+    data32  =   (
+          hevc->tile_width_lcu   |
+          hevc->tile_height_lcu<<16
+          );
+    WRITE_VREG(HEVC_MPRED_TILE_SIZE_LCU,data32);
+    
+    data32  =   (
+          hevc->RefNum_L0   |
+          hevc->RefNum_L1<<8|
+          0
+          //col_RefNum_L0<<16|
+          //col_RefNum_L1<<24
+          );
+    WRITE_VREG(HEVC_MPRED_REF_NUM,data32);
+    
+    data32  =   (
+          hevc->LongTerm_Ref   
+          );
+    WRITE_VREG(HEVC_MPRED_LT_REF,data32);
+    
+    
+    data32=0;
+    for(i=0;i<hevc->RefNum_L0;i++)data32=data32|(1<<i);
+    WRITE_VREG(HEVC_MPRED_REF_EN_L0,data32);
+    
+    data32=0;
+    for(i=0;i<hevc->RefNum_L1;i++)data32=data32|(1<<i);
+    WRITE_VREG(HEVC_MPRED_REF_EN_L1,data32);
+    
+    
+    WRITE_VREG(HEVC_MPRED_CUR_POC,hevc->curr_POC);
+    WRITE_VREG(HEVC_MPRED_COL_POC,hevc->Col_POC);
+    
+    //below MPRED Ref_POC_xx_Lx registers must follow Ref_POC_xx_L0 -> Ref_POC_xx_L1 in pair write order!!!
+    ref_poc_L0      = &(cur_pic->m_aiRefPOCList0[cur_pic->slice_idx][0]);
+    ref_poc_L1      = &(cur_pic->m_aiRefPOCList1[cur_pic->slice_idx][0]);
+
+    WRITE_VREG(HEVC_MPRED_L0_REF00_POC,ref_poc_L0[0]);
+    WRITE_VREG(HEVC_MPRED_L1_REF00_POC,ref_poc_L1[0]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF01_POC,ref_poc_L0[1]);
+    WRITE_VREG(HEVC_MPRED_L1_REF01_POC,ref_poc_L1[1]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF02_POC,ref_poc_L0[2]);
+    WRITE_VREG(HEVC_MPRED_L1_REF02_POC,ref_poc_L1[2]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF03_POC,ref_poc_L0[3]);
+    WRITE_VREG(HEVC_MPRED_L1_REF03_POC,ref_poc_L1[3]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF04_POC,ref_poc_L0[4]);
+    WRITE_VREG(HEVC_MPRED_L1_REF04_POC,ref_poc_L1[4]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF05_POC,ref_poc_L0[5]);
+    WRITE_VREG(HEVC_MPRED_L1_REF05_POC,ref_poc_L1[5]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF06_POC,ref_poc_L0[6]);
+    WRITE_VREG(HEVC_MPRED_L1_REF06_POC,ref_poc_L1[6]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF07_POC,ref_poc_L0[7]);
+    WRITE_VREG(HEVC_MPRED_L1_REF07_POC,ref_poc_L1[7]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF08_POC,ref_poc_L0[8]);
+    WRITE_VREG(HEVC_MPRED_L1_REF08_POC,ref_poc_L1[8]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF09_POC,ref_poc_L0[9]);
+    WRITE_VREG(HEVC_MPRED_L1_REF09_POC,ref_poc_L1[9]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF10_POC,ref_poc_L0[10]);
+    WRITE_VREG(HEVC_MPRED_L1_REF10_POC,ref_poc_L1[10]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF11_POC,ref_poc_L0[11]);
+    WRITE_VREG(HEVC_MPRED_L1_REF11_POC,ref_poc_L1[11]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF12_POC,ref_poc_L0[12]);
+    WRITE_VREG(HEVC_MPRED_L1_REF12_POC,ref_poc_L1[12]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF13_POC,ref_poc_L0[13]);
+    WRITE_VREG(HEVC_MPRED_L1_REF13_POC,ref_poc_L1[13]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF14_POC,ref_poc_L0[14]);
+    WRITE_VREG(HEVC_MPRED_L1_REF14_POC,ref_poc_L1[14]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF15_POC,ref_poc_L0[15]);
+    WRITE_VREG(HEVC_MPRED_L1_REF15_POC,ref_poc_L1[15]);
+    
+    
+    if(hevc->new_pic)
+    {
+        WRITE_VREG(HEVC_MPRED_ABV_START_ADDR,mpred_above_buf_start);
+        WRITE_VREG(HEVC_MPRED_MV_WPTR,mpred_mv_wr_ptr);
+        //WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_ptr);
+        WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_start_addr);
+    }
+    else if(!hevc->isNextSliceSegment)
+    {
+        //WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_ptr_p1);
+        WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_ptr);
+    }
+    
+    WRITE_VREG(HEVC_MPRED_MV_RD_END_ADDR,mpred_mv_rd_end_addr);
+}
+
+static void config_sao_hw(hevc_stru_t* hevc, param_t* params)
+{
+    unsigned int data32, data32_2;
+    int misc_flag0 = hevc->misc_flag0; 
+    int slice_deblocking_filter_disabled_flag = 0;
+               
+    int mc_buffer_size_u_v = hevc->lcu_total*hevc->lcu_size*hevc->lcu_size/2;
+    int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16;
+    PIC_t* cur_pic = hevc->cur_pic;
+            
+    data32 = READ_VREG(HEVC_SAO_CTRL0);	
+    data32 &= (~0xf);
+    data32 |= hevc->lcu_size_log2;
+    WRITE_VREG(HEVC_SAO_CTRL0, data32);
+
+    data32  =   (
+            hevc->pic_w|
+            hevc->pic_h<<16   
+            );
+    WRITE_VREG(HEVC_SAO_PIC_SIZE , data32);
+
+    data32  =   (
+            (hevc->lcu_x_num-1)   |
+            (hevc->lcu_y_num-1)<<16
+            );
+    WRITE_VREG(HEVC_SAO_PIC_SIZE_LCU , data32);
+    
+    if(hevc->new_pic) WRITE_VREG(HEVC_SAO_Y_START_ADDR,0xffffffff);
+    data32 = cur_pic->mc_y_adr;
+    WRITE_VREG(HEVC_SAO_Y_START_ADDR,data32);
+    
+    data32 = (mc_buffer_size_u_v_h<<16)<<1;
+    //printk("data32 = %x, mc_buffer_size_u_v_h = %x, lcu_total = %x, lcu_size = %x\n", data32, mc_buffer_size_u_v_h, lcu_total, lcu_size);
+    WRITE_VREG(HEVC_SAO_Y_LENGTH ,data32);
+
+    data32 = cur_pic->mc_u_v_adr;
+    WRITE_VREG(HEVC_SAO_C_START_ADDR,data32);
+
+    data32 = (mc_buffer_size_u_v_h<<16);
+    WRITE_VREG(HEVC_SAO_C_LENGTH  ,data32);
+
+    /* multi tile to do... */
+    data32 = cur_pic->mc_y_adr;
+    WRITE_VREG(HEVC_SAO_Y_WPTR ,data32);
+
+    data32 = cur_pic->mc_u_v_adr;
+    WRITE_VREG(HEVC_SAO_C_WPTR ,data32);
+    
+    // DBLK CONFIG HERE
+    if(hevc->new_pic){
+        data32  =   (
+            hevc->pic_w|
+            hevc->pic_h<<16   
+        );
+        WRITE_VREG( HEVC_DBLK_CFG2, data32);
+        
+        if((misc_flag0>>PCM_ENABLE_FLAG_BIT)&0x1)
+            data32 = ((misc_flag0>>PCM_LOOP_FILTER_DISABLED_FLAG_BIT)&0x1)<<3;
+        else data32 = 0;
+        data32 |= (((params->p.pps_cb_qp_offset&0x1f)<<4)|((params->p.pps_cr_qp_offset&0x1f)<<9));
+        data32 |= (hevc->lcu_size==64)?0:((hevc->lcu_size==32)?1:2);
+        
+        WRITE_VREG( HEVC_DBLK_CFG1, data32);
+    }
+
+#if 1
+// m8baby test1902
+   data32 = READ_VREG( HEVC_SAO_CTRL1);
+	data32 &= (~0x3000);
+	data32 |= (MEM_MAP_MODE << 12); // [13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32
+    data32 &= (~0xff0);
+    //data32 |= 0x670;  // Big-Endian per 64-bit
+    data32 |= 0x880;  // Big-Endian per 64-bit
+    WRITE_VREG( HEVC_SAO_CTRL1, data32);
+
+    data32 = READ_VREG( HEVCD_IPP_AXIIF_CONFIG);
+	data32 &= (~0x30);
+	data32 |= (MEM_MAP_MODE << 4); // [5:4]    -- address_format 00:linear 01:32x32 10:64x32
+	data32 &= (~0xF);
+    data32 |= 0x8;    // Big-Endian per 64-bit
+    WRITE_VREG( HEVCD_IPP_AXIIF_CONFIG, data32);
+#else
+    data32 = READ_VREG( HEVC_SAO_CTRL1);
+    data32 &= (~0x3000);
+    data32 |= (MEM_MAP_MODE << 12); // [13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32
+    WRITE_VREG( HEVC_SAO_CTRL1, data32);
+    
+    data32 = READ_VREG( HEVCD_IPP_AXIIF_CONFIG);
+    data32 &= (~0x30);
+    data32 |= (MEM_MAP_MODE << 4); // [5:4]    -- address_format 00:linear 01:32x32 10:64x32
+    WRITE_VREG( HEVCD_IPP_AXIIF_CONFIG, data32);
+#endif    
+    data32 = 0;	
+    data32_2 = READ_VREG( HEVC_SAO_CTRL0);
+    data32_2 &= (~0x300);
+    //slice_deblocking_filter_disabled_flag = 0; //ucode has handle it , so read it from ucode directly
+    //printk("\nconfig dblk HEVC_DBLK_CFG9: misc_flag0 %x tile_enabled %x; data32 is:", misc_flag0, tile_enabled);
+    if(hevc->tile_enabled) {
+        data32 |= ((misc_flag0>>LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT)&0x1)<<0;
+        data32_2 |= ((misc_flag0>>LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT)&0x1)<<8;
+    }
+    slice_deblocking_filter_disabled_flag =	(misc_flag0>>SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1;	//ucode has handle it , so read it from ucode directly
+    if((misc_flag0&(1<<DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT))
+        &&(misc_flag0&(1<<DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT))){
+        //slice_deblocking_filter_disabled_flag =	(misc_flag0>>SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1;	//ucode has handle it , so read it from ucode directly
+        data32 |= slice_deblocking_filter_disabled_flag<<2;
+        if(debug&H265_DEBUG_BUFMGR) printk("(1,%x)", data32);
+        if(!slice_deblocking_filter_disabled_flag){
+            data32 |= (params->p.slice_beta_offset_div2&0xf)<<3;
+            data32 |= (params->p.slice_tc_offset_div2&0xf)<<7;
+            if(debug&H265_DEBUG_BUFMGR) printk("(2,%x)", data32);
+        }
+    }
+    else{
+        data32 |= ((misc_flag0>>PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1)<<2;
+        if(debug&H265_DEBUG_BUFMGR) printk("(3,%x)", data32);
+        if(((misc_flag0>>PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1)==0){
+            data32 |= (params->p.pps_beta_offset_div2&0xf)<<3;
+            data32 |= (params->p.pps_tc_offset_div2&0xf)<<7;
+            if(debug&H265_DEBUG_BUFMGR) printk("(4,%x)", data32);
+        }
+    }
+    if((misc_flag0&(1<<PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT))&&
+       ((misc_flag0&(1<<SLICE_SAO_LUMA_FLAG_BIT))||(misc_flag0&(1<<SLICE_SAO_CHROMA_FLAG_BIT))||(!slice_deblocking_filter_disabled_flag))) {
+        data32 |= ((misc_flag0>>SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<1;
+        data32_2 |= ((misc_flag0>>SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<9;
+        if(debug&H265_DEBUG_BUFMGR) printk("(5,%x)\n", data32);
+    }
+    else{
+        data32 |= ((misc_flag0>>PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<1;
+        data32_2 |= ((misc_flag0>>PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<9;
+        if(debug&H265_DEBUG_BUFMGR) printk("(6,%x)\n", data32);
+    }
+    WRITE_VREG( HEVC_DBLK_CFG9, data32);
+    WRITE_VREG( HEVC_SAO_CTRL0, data32_2);
+}                
+
+static unsigned int log2i (unsigned int val) {
+    unsigned int ret = -1;
+    while (val != 0) {
+        val >>= 1;
+        ret++;
+    }
+    return ret;
+}
+
+static PIC_t* get_new_pic(hevc_stru_t* hevc, param_t* rpm_param)
+{
+    PIC_t* new_pic;
+    PIC_t* pic;
+    new_pic = out_q(&hevc->free_pic_list);
+    if(new_pic == NULL){
+        /* recycle un-used pic */
+        int ii = 0;
+      
+        while(1){
+            pic = get_pic_by_IDX(hevc, ii++);
+            if(pic == NULL)
+                break;
+            if(pic->output_mark == 0 && pic->referenced == 0
+                    && pic->output_ready == 0
+                ){
+                if(new_pic){
+                    if(pic->POC < new_pic->POC)
+                        new_pic = pic;
+                }
+                else{
+                    new_pic = pic;
+                }
+            }
+        }
+        if(new_pic == NULL){
+            //printk("Error: Buffer management, no free buffer\n");
+            //dump_pic_list(hevc);
+            //hevc->wait_buf = 1;
+            return NULL;
+        }
+    }
+    else{
+        in_q(&hevc->decode_pic_list, new_pic);
+    }
+    new_pic->decode_idx = hevc->decode_idx;
+    new_pic->slice_idx = 0;
+    new_pic->referenced = 1;
+    new_pic->output_mark = 0;
+    new_pic->recon_mark = 0;
+    //new_pic->output_ready = 0;
+    new_pic->num_reorder_pic = rpm_param->p.sps_num_reorder_pics_0;
+    new_pic->POC = hevc->curr_POC;
+    //dump_pic_list(hevc);
+    return new_pic;
+}
+
+
+static int hevc_slice_segment_header_process(hevc_stru_t* hevc, param_t* rpm_param)
+{
+    int i;
+    int     lcu_x_num_div;
+    int     lcu_y_num_div;
+    int     Col_ref         ;
+    if(hevc->wait_buf == 0){
+        hevc->m_temporalId = rpm_param->p.m_temporalId;
+        hevc->m_nalUnitType = rpm_param->p.m_nalUnitType;
+        if(hevc->m_nalUnitType == NAL_UNIT_EOS){ 
+            hevc->m_pocRandomAccess = MAX_INT; //add to fix RAP_B_Bossen_1
+        }
+        hevc->misc_flag0 = rpm_param->p.misc_flag0;
+        if(rpm_param->p.first_slice_segment_in_pic_flag==0){
+            hevc->slice_segment_addr = rpm_param->p.slice_segment_address;
+            if(!rpm_param->p.dependent_slice_segment_flag){
+                hevc->slice_addr = hevc->slice_segment_addr;
+            }
+        }
+        else{
+            hevc->slice_segment_addr = 0;
+            hevc->slice_addr = 0;
+        }
+    
+        hevc->iPrevPOC = hevc->curr_POC;
+        hevc->slice_type =      (rpm_param->p.slice_type == I_SLICE ) ? 2 :
+                          (rpm_param->p.slice_type == P_SLICE ) ? 1 :
+                          (rpm_param->p.slice_type == B_SLICE ) ? 0 : 3;
+        //hevc->curr_predFlag_L0=(hevc->slice_type==2) ? 0:1;
+        //hevc->curr_predFlag_L1=(hevc->slice_type==0) ? 1:0;
+        hevc->TMVPFlag	= rpm_param->p.slice_temporal_mvp_enable_flag;
+        hevc->isNextSliceSegment=rpm_param->p.dependent_slice_segment_flag?1:0;
+        
+        hevc->pic_w           =rpm_param->p.pic_width_in_luma_samples;
+        hevc->pic_h           =rpm_param->p.pic_height_in_luma_samples;
+        hevc->lcu_size        = 1<<(rpm_param->p.log2_min_coding_block_size_minus3+3+rpm_param->p.log2_diff_max_min_coding_block_size);
+        hevc->lcu_size_log2   =log2i(hevc->lcu_size);
+        lcu_x_num_div   =(hevc->pic_w/ hevc->lcu_size);
+        lcu_y_num_div   =(hevc->pic_h/ hevc->lcu_size);
+        hevc->lcu_x_num       =((hevc->pic_w% hevc->lcu_size) == 0) ? lcu_x_num_div : lcu_x_num_div+1;
+        hevc->lcu_y_num       =((hevc->pic_h% hevc->lcu_size) == 0) ? lcu_y_num_div : lcu_y_num_div+1;
+        hevc->lcu_total       =hevc->lcu_x_num*hevc->lcu_y_num;
+    
+    
+        if(hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP){
+            hevc->curr_POC = 0;
+            if((hevc->m_temporalId - 1) == 0){
+                hevc->iPrevTid0POC = hevc->curr_POC;
+            }
+        }
+        else{
+            int iMaxPOClsb = 1<<(rpm_param->p.log2_max_pic_order_cnt_lsb_minus4+4);
+            int iPrevPOClsb = hevc->iPrevTid0POC%iMaxPOClsb;
+            int iPrevPOCmsb = hevc->iPrevTid0POC-iPrevPOClsb;
+            int iPOCmsb;
+            
+            int iPOClsb = rpm_param->p.POClsb;
+            if( ( iPOClsb  <  iPrevPOClsb ) && ( ( iPrevPOClsb - iPOClsb )  >=  ( iMaxPOClsb / 2 ) ) )
+            {
+                iPOCmsb = iPrevPOCmsb + iMaxPOClsb;
+            }
+            else if( (iPOClsb  >  iPrevPOClsb )  && ( (iPOClsb - iPrevPOClsb )  >  ( iMaxPOClsb / 2 ) ) ) 
+            {
+                iPOCmsb = iPrevPOCmsb - iMaxPOClsb;
+            }
+            else
+            {
+                iPOCmsb = iPrevPOCmsb;
+            }
+            if(debug&H265_DEBUG_BUFMGR){
+                printk("iPrePOC  %d iMaxPOClsb %d iPOCmsb %d iPOClsb %d\n", hevc->iPrevTid0POC, iMaxPOClsb, iPOCmsb, iPOClsb);
+            }
+            if ( hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA
+                || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLANT
+                || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA_N_LP )
+            {
+                // For BLA picture types, POCmsb is set to 0.
+                iPOCmsb = 0;
+            }
+            hevc->curr_POC  =  (iPOCmsb+iPOClsb);
+            if((hevc->m_temporalId - 1) == 0){
+                hevc->iPrevTid0POC = hevc->curr_POC;
+            }
+            else{
+                if(debug&H265_DEBUG_BUFMGR){
+                    printk("m_temporalID is %d\n", hevc->m_temporalId); 		
+                }
+            }
+        }
+        hevc->RefNum_L0       =rpm_param->p.num_ref_idx_l0_active;
+        hevc->RefNum_L1       =rpm_param->p.num_ref_idx_l1_active;
+        
+        //if(curr_POC==0x10) dump_lmem();
+        
+        /* skip RASL pictures after CRA/BLA pictures */
+        if(hevc->m_pocRandomAccess == MAX_INT){ //first picture
+            if (   hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_CRA || 
+                hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLANT || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA_N_LP )
+            {
+                hevc->m_pocRandomAccess = hevc->curr_POC;
+            }
+            else{
+                hevc->m_pocRandomAccess = - MAX_INT;
+            }
+        }
+        else if (hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLANT || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA_N_LP )
+        {
+            hevc->m_pocRandomAccess = hevc->curr_POC;
+        }
+        else if((hevc->curr_POC<hevc->m_pocRandomAccess)&&(hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_RASL_N || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_TFD)){ //skip
+            printk("RASL picture with POC %d < %d (RandomAccess point POC), skip it\n", hevc->curr_POC, hevc->m_pocRandomAccess);
+            return 1;
+        }
+    
+        WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)|0x2);            
+        hevc->skip_flag = 0;
+        /**/
+        
+        //	if((iPrevPOC != curr_POC)){
+        if(rpm_param->p.slice_segment_address == 0){
+            PIC_t* pic;
+            hevc->new_pic=1;
+            /**/
+            if(hevc->pic_list_init_flag == 0){
+                init_pic_list(hevc);
+                init_buf_spec(hevc);
+                hevc->pic_list_init_flag = 1;
+            }
+            
+            /* prev pic */
+            if(hevc->curr_POC!=0){
+                PIC_t* pic_display;
+                pic = get_pic_by_POC(hevc, hevc->iPrevPOC);
+                if(pic){
+                    pic->output_mark = 1;
+                    pic->recon_mark = 1;
+                }
+                do{			
+                    pic_display = output_pic(hevc, 0);
+    
+                    if(pic_display){
+                        prepare_display_buf(pic_display->index, pic_display->stream_offset);
+                    }
+                    if(pic_display){
+                        if(debug&H265_DEBUG_POC){
+                            if(hevc->cur_pic->decode_idx > debug_decode_idx_start && hevc->cur_pic->decode_idx < debug_decode_idx_end)
+                                dump_pic_list(hevc);
+                            printk("[Buffer Management] Display: POC %d, decoding index %d\n", pic_display->POC, pic_display->decode_idx);
+                        }
+                    }
+                }while(pic_display);
+            }
+            else if(hevc->iPrevPOC!=0){ /* flush */
+                PIC_t* pic_display;
+                if(debug&H265_DEBUG_BUFMGR){
+                    printk("[Buffer Management] current pic is IDR, clear referenced flag of all buffers\n");
+                }
+                if(debug&H265_DEBUG_POC){
+                    dump_pic_list(hevc);
+                }
+                pic = get_pic_by_POC(hevc, hevc->iPrevPOC);
+                if(pic){
+                    pic->output_mark = 1;
+                    pic->recon_mark = 1;
+                }
+                do{			
+                    pic_display = output_pic(hevc, 1);
+    
+                    if(pic_display){
+                        pic_display->referenced = 0;
+                        prepare_display_buf(pic_display->index, pic_display->stream_offset);
+                    }
+                    if(pic_display){
+                        if(debug&H265_DEBUG_POC){
+                            if(hevc->cur_pic->decode_idx > debug_decode_idx_start && hevc->cur_pic->decode_idx < debug_decode_idx_end)
+                                dump_pic_list(hevc);
+                            printk("[Buffer Management] Display: POC %d, decoding index %d\n", pic_display->POC, pic_display->decode_idx);
+                        }
+                    }
+                }while(pic_display);
+            }
+            
+            apply_ref_pic_set(hevc, hevc->curr_POC, rpm_param); //update referenced of old pictures (cur_pic->referenced is 1 and not updated)
+            /* new pic */
+            hevc->cur_pic = get_new_pic(hevc, rpm_param);
+            if(hevc->cur_pic == NULL){
+                if(debug&H265_DEBUG_BUFMGR){
+                    dump_pic_list(hevc);
+                }
+                hevc->wait_buf = 1;
+                return -1;
+            }            
+        }
+        else{
+            hevc->cur_pic->slice_idx++;
+            hevc->new_pic =0;
+        }
+    }
+    else{
+        //wait_buf == 1
+        hevc->cur_pic = get_new_pic(hevc, rpm_param);
+        if(hevc->cur_pic == NULL){
+            return -1;
+        }
+        hevc->wait_buf = 0;            
+    }
+        
+    if(hevc->new_pic){
+        int sao_mem_unit = ((hevc->lcu_size/8)*2 + 4 )<<4;
+        int pic_height_cu = (hevc->pic_h+hevc->lcu_size-1)/hevc->lcu_size;
+        int pic_width_cu = (hevc->pic_w+hevc->lcu_size-1)/hevc->lcu_size;
+		    int sao_vb_size = (sao_mem_unit+(2<<4))*pic_height_cu;
+		    //int sao_abv_size = sao_mem_unit*pic_width_cu;
+        
+        hevc->decode_idx++;
+        if(debug&H265_DEBUG_BUFMGR){
+            printk("%s decode index %d\n", __func__, hevc->decode_idx);
+        }
+        update_tile_info(hevc, pic_width_cu , pic_height_cu , sao_mem_unit, rpm_param);
+
+        config_title_hw(hevc, sao_vb_size, sao_mem_unit);
+    }
+    
+    if(hevc->iPrevPOC != hevc->curr_POC){
+        hevc->new_tile = 1;
+        hevc->tile_x = 0;
+        hevc->tile_y = 0;
+        hevc->tile_y_x = 0;
+        if(debug&H265_DEBUG_BUFMGR){
+            printk("new_tile (new_pic) tile_x=%d, tile_y=%d\n", hevc->tile_x, hevc->tile_y);
+        }
+    }
+    else if(hevc->tile_enabled){
+        if(debug&H265_DEBUG_BUFMGR){
+            printk("slice_segment_address is %d\n", rpm_param->p.slice_segment_address);
+        }
+        hevc->tile_y_x = get_tile_index(hevc, rpm_param->p.slice_segment_address, (hevc->pic_w+hevc->lcu_size-1)/hevc->lcu_size);
+        if(hevc->tile_y_x != (hevc->tile_x|(hevc->tile_y<<8))){
+            hevc->new_tile = 1;
+            hevc->tile_x = hevc->tile_y_x&0xff;
+            hevc->tile_y = (hevc->tile_y_x>>8)&0xff;
+            if(debug&H265_DEBUG_BUFMGR){
+                printk("new_tile segment_adr %d tile_x=%d, tile_y=%d\n", rpm_param->p.slice_segment_address, hevc->tile_x, hevc->tile_y);
+            }
+        }
+        else{
+            hevc->new_tile = 0;
+        }	
+    }
+    else{
+        hevc->new_tile = 0;
+    }
+    
+    if(hevc->new_tile){
+        hevc->tile_start_lcu_x = m_tile[hevc->tile_y][hevc->tile_x].start_cu_x;
+        hevc->tile_start_lcu_y = m_tile[hevc->tile_y][hevc->tile_x].start_cu_y;
+        hevc->tile_width_lcu  = m_tile[hevc->tile_y][hevc->tile_x].width;
+        hevc->tile_height_lcu = m_tile[hevc->tile_y][hevc->tile_x].height;
+    }
+    
+    set_ref_pic_list(hevc->cur_pic, rpm_param);
+    
+    
+    Col_ref=rpm_param->p.collocated_ref_idx;
+    
+    hevc->LDCFlag = 0;        
+    if(rpm_param->p.slice_type != I_SLICE){
+        hevc->LDCFlag = 1;
+        for(i=0; (i<hevc->RefNum_L0) && hevc->LDCFlag; i++){
+            if(hevc->cur_pic->m_aiRefPOCList0[hevc->cur_pic->slice_idx][i]>hevc->curr_POC){
+                hevc->LDCFlag = 0;			
+            }
+        }
+        if(rpm_param->p.slice_type == B_SLICE){
+            for(i=0; (i<hevc->RefNum_L1) && hevc->LDCFlag; i++){
+                if(hevc->cur_pic->m_aiRefPOCList1[hevc->cur_pic->slice_idx][i]>hevc->curr_POC){
+                    hevc->LDCFlag = 0;			
+                }
+            }
+        }
+    }
+    
+    hevc->ColFromL0Flag   =rpm_param->p.collocated_from_l0_flag;
+    
+    hevc->plevel          = rpm_param->p.log2_parallel_merge_level; //rpm_param->p.log2_parallel_merge_level>=2?rpm_param->p.log2_parallel_merge_level-2:0;
+    hevc->MaxNumMergeCand = 5 - rpm_param->p.five_minus_max_num_merge_cand;
+    
+    hevc->LongTerm_Curr   =0; /* to do ... */
+    hevc->LongTerm_Col    =0; /* to do ... */
+    
+    hevc->list_no = 0;	
+    if(rpm_param->p.slice_type == B_SLICE ){
+        hevc->list_no = 1-hevc->ColFromL0Flag;	
+    }
+    if(hevc->list_no==0){
+        if(Col_ref<hevc->RefNum_L0)
+            hevc->Col_POC = hevc->cur_pic->m_aiRefPOCList0[hevc->cur_pic->slice_idx][Col_ref];			
+        else
+            hevc->Col_POC = INVALID_POC;
+    }
+    else{
+        if(Col_ref<hevc->RefNum_L1)
+            hevc->Col_POC = hevc->cur_pic->m_aiRefPOCList1[hevc->cur_pic->slice_idx][Col_ref];			
+        else
+            hevc->Col_POC = INVALID_POC;
+    }
+    
+    hevc->LongTerm_Ref    = 0; /* to do ... */
+
+    if(hevc->slice_type!=2)
+    {
+        if(hevc->Col_POC != INVALID_POC){
+            hevc->col_pic = get_ref_pic_by_POC(hevc, hevc->Col_POC);
+            if(hevc->col_pic == NULL){
+                printk("WRONG, fail to get the picture of Col_POC\n");
+                return 2;
+            }
+        }
+        else{
+            hevc->col_pic = hevc->cur_pic;
+        }
+    }//
+    if(hevc->col_pic == NULL) hevc->col_pic = hevc->cur_pic;     
+
+#ifdef BUFFER_MGR_ONLY
+    return 0xf;
+#endif
+    
+    if(config_mc_buffer(hevc, hevc->cur_pic)<0){
+        return 3;    
+    }
+#ifdef MCRCC_ENABLE
+    config_mcrcc_axi_hw(hevc->cur_pic->slice_type);
+#endif
+    config_mpred_hw(hevc);
+
+    config_sao_hw(hevc, rpm_param);
+    return 0;
+}    
+
+/**************************************************
+
+h265 buffer management end
+
+***************************************************/
+static buff_t mc_buf_spec;
+
+static hevc_stru_t gHevc;
+    
+static param_t  rpm_param;
+
+static void hevc_local_init(void)
+{
+    BuffInfo_t* cur_buf_info;
+    if (frame_width <= 1920 &&  frame_height <= 1088) {
+        cur_buf_info = &amvh265_workbuff_spec[0]; //1080p work space
+    }
+    else{
+        cur_buf_info = &amvh265_workbuff_spec[1]; //4k2k work space
+    }
+ 
+    init_buff_spec(cur_buf_info);
+
+    mc_buf_spec.buf_start = (cur_buf_info->end_adr + 0xffff)&(~0xffff);
+    mc_buf_spec.buf_size  = (mc_buf_spec.buf_end - mc_buf_spec.buf_start);
+    
+    hevc_init_stru(&gHevc, cur_buf_info, &mc_buf_spec);
+}
+
+/********************************************
+ *  Mailbox command
+ ********************************************/
+#define CMD_FINISHED               0
+#define CMD_ALLOC_VIEW             1
+#define CMD_FRAME_DISPLAY          3
+#define CMD_DEBUG                  10
+
+static unsigned reserved_buffer;
+
+#define DECODE_BUFFER_NUM_MAX    32
+#define DISPLAY_BUFFER_NUM       6
+
+#define video_domain_addr(adr) (adr&0x7fffffff)
+#define DECODER_WORK_SPACE_SIZE 0x800000
+
+typedef struct {
+    unsigned int y_addr;
+    unsigned int uv_addr;
+
+    int y_canvas_index;
+    int uv_canvas_index;
+} buffer_spec_t;
+
+static buffer_spec_t buffer_spec[DECODE_BUFFER_NUM_MAX+DISPLAY_BUFFER_NUM];
+
+#define spec2canvas(x)  \
+    (((x)->uv_canvas_index << 16) | \
+     ((x)->uv_canvas_index << 8)  | \
+     ((x)->y_canvas_index << 0))
+
+#define VF_POOL_SIZE        32
+
+static DECLARE_KFIFO(newframe_q, vframe_t *, VF_POOL_SIZE);
+static DECLARE_KFIFO(display_q, vframe_t *, VF_POOL_SIZE);
+
+static s32 vfbuf_use[DECODE_BUFFER_NUM_MAX];
+static vframe_t vfpool[VF_POOL_SIZE];
+
+static int init_buf_spec(hevc_stru_t* hevc)
+{
+    int i;
+    int canvas_width = (hevc->pic_w + 63) / 64 * 64;
+    int canvas_height = hevc->pic_h;
+	  for(i=0; i<MAX_REF_PIC_NUM; i++){ 
+	      if(m_PIC[i].index == -1){
+	          break;
+	      }
+        buffer_spec[i].y_addr = m_PIC[i].mc_y_adr;
+        buffer_spec[i].uv_addr = m_PIC[i].mc_u_v_adr;
+
+        buffer_spec[i].y_canvas_index = 128 + i * 2;
+        buffer_spec[i].uv_canvas_index = 128 + i * 2 + 1;
+
+        canvas_config(128 + i * 2, buffer_spec[i].y_addr, canvas_width, canvas_height,
+                      CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_64X32);
+        canvas_config(128 + i * 2 + 1, buffer_spec[i].uv_addr, canvas_width, canvas_height>>1,
+                      CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_64X32);
+    }
+    if(frame_width == 0 || frame_height == 0){
+        frame_width = hevc->pic_w;
+        frame_height = hevc->pic_h;   
+    }
+
+    return 0;
+}
+
+static void set_frame_info(vframe_t *vf)
+{
+    unsigned int ar;
+
+    vf->width = frame_width;
+    vf->height = frame_height;
+    vf->duration = frame_dur;
+    vf->duration_pulldown = 0;
+    vf->pts = 0;
+    ar = min(frame_ar, (u32)DISP_RATIO_ASPECT_RATIO_MAX);
+    vf->ratio_control = (ar << DISP_RATIO_ASPECT_RATIO_BIT);
+
+    return;
+}
+
+static int vh265_vf_states(vframe_states_t *states, void* op_arg)
+{
+    unsigned long flags;
+    spin_lock_irqsave(&lock, flags);
+
+    states->vf_pool_size = VF_POOL_SIZE;
+    states->buf_free_num = kfifo_len(&newframe_q);
+    states->buf_avail_num = kfifo_len(&display_q);
+
+    spin_unlock_irqrestore(&lock, flags);
+    return 0;
+}
+
+static vframe_t *vh265_vf_peek(void* op_arg)
+{
+    vframe_t *vf;
+
+    if (kfifo_peek(&display_q, &vf)) {
+        return vf;
+    }
+
+    return NULL;
+}
+
+static vframe_t *vh265_vf_get(void* op_arg)
+{
+    vframe_t *vf;
+
+    if (kfifo_get(&display_q, &vf)) {
+        return vf;
+    }
+
+    return NULL;
+}
+
+static void vh265_vf_put(vframe_t *vf, void* op_arg)
+{
+    m_PIC[vf->index].output_ready = 0;
+    kfifo_put(&newframe_q, (const vframe_t **)&vf);
+    if(gHevc.wait_buf!=0){
+        WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
+    }
+}
+
+static int vh265_event_cb(int type, void *data, void *private_data)
+{
+    if(type & VFRAME_EVENT_RECEIVER_RESET){
+        unsigned long flags;
+        amhevc_stop();
+#ifndef CONFIG_POST_PROCESS_MANAGER
+        vf_light_unreg_provider(&vh265_vf_prov);
+#endif
+        spin_lock_irqsave(&lock, flags);
+        vh265_local_init();
+        vh265_prot_init();
+        spin_unlock_irqrestore(&lock, flags);
+#ifndef CONFIG_POST_PROCESS_MANAGER
+        vf_reg_provider(&vh265_vf_prov);
+#endif
+        amhevc_start();
+    }
+
+    return 0;
+}
+
+static int prepare_display_buf(int display_buff_id, int stream_offset)
+{
+    vframe_t *vf = NULL;
+    if (kfifo_get(&newframe_q, &vf) == 0) {
+        printk("fatal error, no available buffer slot.");
+        return -1;
+    }
+    
+    if (vf) {
+        /*
+        vfbuf_use[display_buff_id]++;
+         */
+        if (pts_lookup_offset(PTS_TYPE_VIDEO, stream_offset, &vf->pts, 0) != 0) {
+            vf->pts = 0;
+        }
+        vf->index = display_buff_id;
+        vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
+        vf->type |= VIDTYPE_VIU_NV21;
+        vf->canvas0Addr = vf->canvas1Addr = spec2canvas(&buffer_spec[display_buff_id]);
+        set_frame_info(vf);
+
+        kfifo_put(&display_q, (const vframe_t **)&vf);
+
+        vf_notify_receiver(PROVIDER_NAME,VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+    }
+
+    return 0;
+}
+
+static irqreturn_t vh265_isr(int irq, void *dev_id)
+{
+    int ret;
+    int i;
+
+    hevc_stru_t* hevc = &gHevc;
+    unsigned int dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
+
+    if(debug&H265_DEBUG_BUFMGR){
+        printk("265 isr dec status = %d\n", dec_status);
+    }
+    if(hevc->error_flag){
+        //reset
+        amhevc_stop();
+        decoder_hw_reset();
+        WRITE_VREG(HEVC_WAIT_FLAG, 1);
+        /* clear mailbox interrupt */
+        WRITE_VREG(HEVC_ASSIST_MBOX1_CLR_REG, 1);
+        /* enable mailbox interrupt */
+        WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 1);
+        /* disable PSCALE for hardware sharing */
+        WRITE_VREG(HEVC_PSCALE_CTRL, 0);
+        amhevc_start();
+
+        //skip, search next start code
+        WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)&(~0x2));            
+        hevc->skip_flag = 1;
+        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+        // Interrupt Amrisc to excute 
+        WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+
+        printk("%s: error handle\n", __func__);
+        hevc->error_flag = 0;
+    }
+    else if(dec_status == HEVC_SLICE_SEGMENT_DONE){
+        if(hevc->wait_buf == 0){
+            get_rpm_param(&rpm_param);      
+            if(debug&H265_DEBUG_UCODE){
+                printk("rpm_param:\n");
+                for(i=0; i<0x80; i++){
+                    printk("%04x ", rpm_param.l.data[i]);
+                    if(((i+1)&0xf)==0)
+                        printk("\n");
+                } 
+            }
+        }    
+        ret = hevc_slice_segment_header_process(hevc, &rpm_param);
+        if(ret<0){
+
+        }
+        else if(ret == 0){
+            if ((hevc->new_pic) && (hevc->cur_pic)) {
+                hevc->cur_pic->stream_offset = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+            }
+
+            WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_CODED_SLICE_SEGMENT_DAT);
+            // Interrupt Amrisc to excute 
+            WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+        }
+        else{
+            //skip, search next start code
+            WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)&(~0x2));            
+            hevc->skip_flag = 1;
+            WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+            // Interrupt Amrisc to excute 
+            WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+        }
+        
+    }
+
+    return IRQ_HANDLED;
+}
+
+static void vh265_put_timer_func(unsigned long arg)
+{
+    struct timer_list *timer = (struct timer_list *)arg;
+    unsigned char empty_flag;
+
+    receviver_start_e state = RECEIVER_INACTIVE;
+    if (vf_get_receiver(PROVIDER_NAME)) {
+        state = vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_QUREY_STATE, NULL);
+        if ((state == RECEIVER_STATE_NULL)||(state == RECEIVER_STATE_NONE)){
+            state = RECEIVER_INACTIVE;
+        }
+    } else {
+        state = RECEIVER_INACTIVE;
+    }
+
+    empty_flag = (READ_VREG(HEVC_PARSER_INT_STATUS)>>6)&0x1;
+    // error watchdog
+    if ((empty_flag == 0) && // decoder has input
+        (state == RECEIVER_INACTIVE) &&                       // receiver has no buffer to recycle
+        (kfifo_is_empty(&display_q))                        // no buffer in display queue
+        ) {                        // no buffer to recycle
+        error_watchdog_count++;
+        if (error_watchdog_count == ERROR_LOCAL_RESET_COUNT) {    
+            if((debug&H265_DEBUG_DIS_ERROR_PROC)==0){
+                printk("H265 decoder error local reset.\n");
+                gHevc.error_flag = 1;
+                WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
+            }
+        }
+        else if (error_watchdog_count == ERROR_SYSTEM_RESET_COUNT) {    // and it lasts for a while
+            if((debug&H265_DEBUG_DIS_SYS_ERROR_PROC)==0){
+                printk("H265 decoder fatal error watchdog.\n");
+                fatal_error = 0x10;
+            }
+            else{
+                error_watchdog_count = 0;
+            }
+        }
+    }
+    else{
+        error_watchdog_count = 0;
+    }
+
+    timer->expires = jiffies + PUT_INTERVAL;
+
+    add_timer(timer);
+}
+
+int vh265_dec_status(struct vdec_status *vstatus)
+{
+    vstatus->width = frame_width;
+    vstatus->height = frame_height;
+    if (frame_dur != 0) {
+        vstatus->fps = 96000 / frame_dur;
+    } else {
+        vstatus->fps = -1;
+    }
+    vstatus->error_count = 0;
+    vstatus->status = stat | (fatal_error << 16);
+    return 0;
+}
+
+#if 0
+static void H265_DECODE_INIT(void)
+{
+    //enable hevc clocks
+    WRITE_VREG(DOS_GCLK_EN3, 0xffffffff);
+    //****************************************************************************
+    //                 Power ON HEVC
+    //****************************************************************************
+    // Powerup HEVC
+    WRITE_VREG(P_AO_RTI_GEN_PWR_SLEEP0, READ_VREG(P_AO_RTI_GEN_PWR_SLEEP0) & (~(0x3<<6))); // [7:6] HEVC
+    WRITE_VREG( DOS_MEM_PD_HEVC, 0x0);
+    WRITE_VREG(DOS_SW_RESET3, READ_VREG(DOS_SW_RESET3)|(0x3ffff<<2));
+    WRITE_VREG(DOS_SW_RESET3, READ_VREG(DOS_SW_RESET3)&(~(0x3ffff<<2)));
+    // remove isolations
+    WRITE_VREG(AO_RTI_GEN_PWR_ISO0, READ_VREG(AO_RTI_GEN_PWR_ISO0) & (~(0x3<<10))); // [11:10] HEVC
+
+}
+#endif
+
+static void vh265_prot_init(void)
+{
+//    H265_DECODE_INIT();
+    
+    hevc_config_work_space_hw(&gHevc);
+    
+    hevc_init_decoder_hw(0, 0xffffffff);
+
+    WRITE_VREG(HEVC_WAIT_FLAG, 1);
+
+    //WRITE_VREG(P_HEVC_MPSR, 1);
+
+    /* clear mailbox interrupt */
+    WRITE_VREG(HEVC_ASSIST_MBOX1_CLR_REG, 1);
+
+    /* enable mailbox interrupt */
+    WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 1);
+
+    /* disable PSCALE for hardware sharing */
+    WRITE_VREG(HEVC_PSCALE_CTRL, 0);
+
+
+}
+
+static void vh265_local_init(void)
+{
+    int i;
+
+#ifdef DEBUG_PTS
+    pts_missed = 0;
+    pts_hit = 0;
+#endif
+
+    frame_width = vh265_amstream_dec_info.width;
+    frame_height = vh265_amstream_dec_info.height;
+    frame_dur = (vh265_amstream_dec_info.rate == 0) ? 3600 : vh265_amstream_dec_info.rate;
+    if (frame_width && frame_height) {
+        frame_ar = frame_height * 0x100 / frame_width;
+    }
+    error_watchdog_count = 0;
+
+    printk("h265: decinfo: %dx%d rate=%d\n", frame_width, frame_height, frame_dur);
+
+    if(frame_dur == 0){
+        frame_dur = 96000/24;
+    }
+
+    INIT_KFIFO(display_q);
+    INIT_KFIFO(newframe_q);
+
+    for (i=0; i<DECODE_BUFFER_NUM_MAX; i++) {
+        vfbuf_use[i] = 0;
+    }
+
+    for (i=0; i<VF_POOL_SIZE; i++) {
+        const vframe_t *vf = &vfpool[i];
+        vfpool[i].index = -1;
+        kfifo_put(&newframe_q, &vf);
+    }
+
+    reserved_buffer = 0;
+
+    hevc_local_init();
+
+    return;
+}
+
+static s32 vh265_init(void)
+{
+    init_timer(&recycle_timer);
+
+    stat |= STAT_TIMER_INIT;
+
+    vh265_local_init();
+
+    amhevc_enable();
+
+    if (amhevc_loadmc(vh265_mc) < 0) {
+        amhevc_disable();
+        return -EBUSY;
+    }
+
+    stat |= STAT_MC_LOAD;
+
+    /* enable AMRISC side protocol */
+    vh265_prot_init();
+
+    if (request_irq(INT_VDEC, vh265_isr,
+                    IRQF_SHARED, "vh265-irq", (void *)vh265_dec_id)) {
+        printk("vh265 irq register error.\n");
+        amhevc_disable();
+        return -ENOENT;
+    }
+
+    stat |= STAT_ISR_REG;
+
+    vf_provider_init(&vh265_vf_prov, PROVIDER_NAME, &vh265_vf_provider, NULL);
+    vf_reg_provider(&vh265_vf_prov);
+    vf_notify_receiver(PROVIDER_NAME,VFRAME_EVENT_PROVIDER_START,NULL);
+
+    stat |= STAT_VF_HOOK;
+
+    recycle_timer.data = (ulong) & recycle_timer;
+    recycle_timer.function = vh265_put_timer_func;
+    recycle_timer.expires = jiffies + PUT_INTERVAL;
+
+    add_timer(&recycle_timer);
+
+    stat |= STAT_TIMER_ARM;
+
+    amhevc_start();
+
+    stat |= STAT_VDEC_RUN;
+
+    set_vdec_func(&vh265_dec_status);
+
+    //printk("%d, vh265_init, RP=0x%x\n", __LINE__, READ_VREG(HEVC_STREAM_RD_PTR));
+
+    return 0;
+}
+
+static int vh265_stop(void)
+{
+    if (stat & STAT_VDEC_RUN) {
+        amhevc_stop();
+        stat &= ~STAT_VDEC_RUN;
+    }
+
+    if (stat & STAT_ISR_REG) {
+        WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
+        free_irq(INT_VDEC, (void *)vh265_dec_id);
+        stat &= ~STAT_ISR_REG;
+    }
+
+    if (stat & STAT_TIMER_ARM) {
+        del_timer_sync(&recycle_timer);
+        stat &= ~STAT_TIMER_ARM;
+    }
+
+    if (stat & STAT_VF_HOOK) {
+        vf_unreg_provider(&vh265_vf_prov);
+        stat &= ~STAT_VF_HOOK;
+    }
+
+    amhevc_disable();
+
+    return 0;
+}
+
+static int amvdec_h265_probe(struct platform_device *pdev)
+{
+    struct resource *mem;
+    int i;
+
+    printk("amvdec_h265 probe start.\n");
+
+    mutex_lock(&vh265_mutex);
+    
+    fatal_error = 0;
+
+    if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0))) {
+        printk("\namvdec_h265 memory resource undefined.\n");
+        mutex_unlock(&vh265_mutex);
+        return -EFAULT;
+    }
+
+    mc_buf_spec.buf_end = mem->end + 1;
+    for(i=0;i<WORK_BUF_SPEC_NUM;i++){
+        amvh265_workbuff_spec[i].start_adr = mem->start;
+    }
+
+    printk("H.265 decoder mem resource 0x%x -- 0x%x\n", mem->start, mem->end + 1);
+
+    if (mem[1].start != 0) {
+        memcpy(&vh265_amstream_dec_info, (void *)mem[1].start, sizeof(vh265_amstream_dec_info));
+    } else {
+        vh265_amstream_dec_info.width = 0;
+        vh265_amstream_dec_info.height = 0;
+        vh265_amstream_dec_info.rate = 30;
+    }
+
+    cma_dev = (struct device *)mem[2].start;
+
+    if (vh265_init() < 0) {
+        printk("\namvdec_h265 init failed.\n");
+        mutex_unlock(&vh265_mutex);
+        return -ENODEV;
+    }
+
+    request_vpu_clk_vmod(360000000, VPU_VIU_VD1);
+
+    mutex_unlock(&vh265_mutex);
+    return 0;
+}
+
+static int amvdec_h265_remove(struct platform_device *pdev)
+{
+    printk("amvdec_h265_remove\n");
+
+    mutex_lock(&vh265_mutex);
+
+    vh265_stop();
+
+#ifdef DEBUG_PTS
+    printk("pts missed %ld, pts hit %ld, duration %d\n",
+           pts_missed, pts_hit, frame_dur);
+#endif
+
+    mutex_unlock(&vh265_mutex);
+    
+    return 0;
+}
+
+/****************************************/
+
+static struct platform_driver amvdec_h265_driver = {
+    .probe   = amvdec_h265_probe,
+    .remove  = amvdec_h265_remove,
+#ifdef CONFIG_PM
+    .suspend = amvdec_suspend,
+    .resume  = amvdec_resume,
+#endif
+    .driver  = {
+        .name = DRIVER_NAME,
+    }
+};
+
+static struct codec_profile_t amvdec_h265_profile = {
+    .name = "hevc",
+    .profile = ""
+};
+
+static int __init amvdec_h265_driver_init_module(void)
+{
+    printk("amvdec_h265 module init\n");
+
+    if (platform_driver_register(&amvdec_h265_driver)) {
+        printk("failed to register amvdec_h265 driver\n");
+        return -ENODEV;
+    }
+
+    vcodec_profile_register(&amvdec_h265_profile);
+
+    return 0;
+}
+
+static void __exit amvdec_h265_driver_remove_module(void)
+{
+    printk("amvdec_h265 module remove.\n");
+
+    platform_driver_unregister(&amvdec_h265_driver);
+}
+
+/****************************************/
+
+module_param(stat, uint, 0664);
+MODULE_PARM_DESC(stat, "\n amvdec_h265 stat \n");
+
+module_param(debug, uint, 0664);
+MODULE_PARM_DESC(debug, "\n amvdec_h265 debug \n");
+
+module_init(amvdec_h265_driver_init_module);
+module_exit(amvdec_h265_driver_remove_module);
+
+MODULE_DESCRIPTION("AMLOGIC h265 Video Decoder Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tim Yao <tim.yao@amlogic.com>");
+
+
diff --git a/drivers/amlogic/amports/vh265.h b/drivers/amlogic/amports/vh265.h
new file mode 100755
index 000000000000..9d4c205d282e
--- /dev/null
+++ b/drivers/amlogic/amports/vh265.h
@@ -0,0 +1,31 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Chen Zhang <chen.zhang@amlogic.com>
+ *
+ */
+
+#ifndef VH265_H
+#define VH265_H
+
+
+extern s32 vh265_init(void);
+
+extern s32 vh265_release(void);
+
+#endif /* VMPEG4_H */
+
diff --git a/drivers/amlogic/amports/vh265_mc.h b/drivers/amlogic/amports/vh265_mc.h
new file mode 100755
index 000000000000..75e9f94fa7fb
--- /dev/null
+++ b/drivers/amlogic/amports/vh265_mc.h
@@ -0,0 +1,27 @@
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef VH265MVC_MC_H
+#define VH265MVC_MC_H
+
+extern const u32 vh265_mc[0x1000];
+
+#endif
-- 
2.19.0

