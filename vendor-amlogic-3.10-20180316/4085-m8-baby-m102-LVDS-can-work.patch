From aa3b57c5def099c74e438eb64f54232d96c0c1c4 Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Wed, 14 May 2014 15:01:36 +0800
Subject: [PATCH 4085/5965] m8 baby m102:LVDS can work

---
 arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd | 687 ++++++++++++------
 drivers/amlogic/display/vout/edp_drv.c        |   2 +-
 drivers/amlogic/display/vout/edp_drv.h        |   2 +-
 drivers/amlogic/display/vout/lcdoutc.c        | 517 ++++++-------
 include/linux/amlogic/vout/lcdoutc.h          |  15 +-
 5 files changed, 682 insertions(+), 541 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
index 8059a4a5709d..8b431670033d 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
@@ -77,9 +77,18 @@ void root_func(){
 	memory{
 		device_type = "memory";
 		aml_reserved_start = <0x06000000>; /**reserved memory start */
-		aml_reserved_end = <0x05000000>;/**reserved memory end : dtb start for uboot*/
+		aml_reserved_end = <0x05000000>;/**reserved memory end */
 		phys_offset = <0x00000000>;
 		linux,total-memory = <0x40000000>;
+
+        #address-cells = <1>;
+        #size-cells = <1>;
+
+        cma_0:region@0 {
+           region_name = "cma_0";
+           reg = <0 0x02700000>;
+           linux,contiguous-region;
+        };
 	};
 /// ***************************************************************************************
 ///	-	GIC
@@ -104,7 +113,7 @@ void root_func(){
 		compatible = "amlogic,vpu";
 		dev_name = "vpu";	
 		status = "ok";
-		clk_level = <7>;
+		clk_level = <4>;
 		/**    	0: 106.25M		1: 127.5M		2: 159.375M
 				3: 182.15M		4: 212.5M		5: 255M
 		    	6: 318.75M		7: 364.3M					 */
@@ -122,10 +131,10 @@ void root_func(){
 		compatible = "amlogic,mesonfb";
 		dev_name = "mesonfb";
 		status = "okay";
-	   	reserve-memory = <0x01000000  0x00100000>;
+        reserve-memory = <0x0900000  0x00100000>;//9M+1M=10M
 	   	reserve-iomap = "true";
-        vmode = <3>; /**0:VMODE_720P 1:VMODE_LCD  2:VMODE_LVDS_1080P 3:VMODE_1080P*/
- 		display_size_default = <1920 1080 1920 2160 32>;
+        vmode = <1>; /**0:VMODE_720P 1:VMODE_LCD  2:VMODE_LVDS_1080P 3:VMODE_1080P*/
+        display_size_default = <768 1024 768 3072 32>;//1024x768x4x3==0x0900000,9MB
 	};
 
 //$$ DEVICE="deinterlace"
@@ -134,9 +143,8 @@ void root_func(){
     deinterlace{
 		compatible = "amlogic,deinterlace";
 		dev_name = "deinterlace";
-		status = "ok";
-		reserve-memory = <0x02300000>; 	 
-
+		status = "disable";
+		reserve-memory = <0x0800000>; //8x1920x1088x3/2=8M
 	};
 
 /// ***************************************************************************************
@@ -149,7 +157,7 @@ void root_func(){
 		compatible = "amlogic,mesonstream";
 		dev_name = "mesonstream.0";
 		status = "okay";
-		reserve-memory = <0x02000000>;
+		reserve-memory = <0x00a00000>;//10M,you can use 8M if memory isn't enough
 		reserve-iomap = "true";
 	};
 
@@ -163,8 +171,8 @@ void root_func(){
                 compatible = "amlogic,vdec";
                 dev_name = "vdec.0";
                 status = "okay";
-                reserve-memory = <0x10000000>;
-                reserve-iomap = "true";
+                reserve-memory = <0x02000000>;//32M
+		reserve-iomap = "true";
         };
 
 /// ***************************************************************************************
@@ -177,7 +185,8 @@ void root_func(){
 		compatible = "amlogic,ppmgr";
 		dev_name = "ppmgr";
 		status = "okay";
-		reserve-memory = <0x03000000>;
+		reserve-memory = <0x01000000>;//16M
+		reserve-iomap = "true";
 	};
 
 /// ***************************************************************************************
@@ -190,23 +199,9 @@ void root_func(){
 		compatible = "amlogic,amvenc_avc";
 		dev_name = "amvenc_avc.0";
 		status = "okay";
-		reserve-memory = <0x00f00000>;
+        linux,contiguous-region = <&cma_0>;
 		reserve-iomap = "true";
 	};
-
-/// ***************************************************************************************
-///	-	DISP&MM-BT656
-//$$ MODULE = "DISP&MM-BT656"
-//$$ DEVICE="amvdec_656in"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 2 = "reg"
-//    amvdec_656in{
-//		compatible = "amlogic,amvdec_656in";
-//		dev_name = "amvdec_656in";
-//		status = "ok";
-//		reg = <0x1a600000 0x00100000>;
-//	};
-//	
 /// ***************************************************************************************
 ///	-	DISP&MM-VDIN
 //$$ MODULE = "DISP&MM-VDIN"
@@ -215,28 +210,30 @@ void root_func(){
 //$$ L2 PROP_U32 2 = "reg"
 //$$ L2 PROP_U32 = "irq"
 //$$ L2 PROP_U32 = "vdin_id"
-    vdin0{
-        compatible = "amlogic,vdin";
-        dev_name = "vdin0";
-        status = "ok";
-	 reserve-memory = <0x04000000>;
-        irq = <115>;
-        vdin_id = <0>;
-	};
+//    vdin0{
+//       compatible = "amlogic,vdin";
+//        dev_name = "vdin0";
+//        status = "ok";
+//	 reserve-memory = <0x04000000>;
+//        irq = <115>;
+//        vdin_id = <0>;
+//	};
 	
 //$$ DEVICE="vdin1"
 //$$ L2 PROP_STR = "status"
 //$$ L2 PROP_U32 2 = "reg"
 //$$ L2 PROP_U32 = "irq"
 //$$ L2 PROP_U32 = "vdin_id"
-    vdin1{
-        compatible = "amlogic,vdin";
-        dev_name = "vdin1";
-        status = "ok";
-	 reserve-memory = <0x04000000>;
-        irq = <117>;
-        vdin_id = <1>;
-	};
+//    vdin1{
+//        compatible = "amlogic,vdin";
+//       dev_name = "vdin1";
+//        status = "ok";
+//        reserve-memory = <0x01000000>;
+//	  miracast_size = <1920 1080>;//1920x1080x2x4=17M
+//	  reserve-iomap = "true";
+//        irq = <117>;
+//        vdin_id = <1>;
+//	};
 
 /// ***************************************************************************************
 ///	-	DISP&MM-AMLVIDEO2
@@ -244,26 +241,26 @@ void root_func(){
 //$$ DEVICE="amlvideo2"
 //$$ L2 PROP_STR = "status"
 //$$ L3 PROP_U32 2 ="reg"
-    amlvideo2{
-		compatible = "amlogic,amlvideo2";
-		dev_name = "amlvideo2.0";
-		status = "okay";
-		reserve-memory = <0x01800000>;
-		reserve-iomap = "true";
-	};
+//    amlvideo2{
+//		compatible = "amlogic,amlvideo2";
+//		dev_name = "amlvideo2.0";
+//		status = "okay";
+//		reserve-memory = <0x01800000>;
+//		reserve-iomap = "true";
+//	};
 
 /// ***************************************************************************************
 ///	-	DISP&MM-Video Input Manager
 //$$ MODULE = "DISP&MM-Video Input Manager"
 //$$ DEVICE="vm"
 //$$ L2 PROP_STR = "status"
-    vm{
-		compatible = "amlogic,vm";
-		dev_name = "vm.0";
-		status = "okay";
-		reserve-memory = <0x01800000>;
-		reserve-iomap = "true";
-	};
+//    vm{
+//		compatible = "amlogic,vm";
+//		dev_name = "vm.0";
+//		status = "okay";
+//		reserve-memory = <0x01800000>;
+//		reserve-iomap = "true";
+//	};
 
 /// ***************************************************************************************
 ///	-	ION
@@ -276,7 +273,7 @@ void root_func(){
         status = "ok";
         share-memory-name = "ppmgr0";
         share-memory-offset = <0>;
-        share-memory-size = <0x03000000>;
+        share-memory-size = <0x01000000>;//ion_dev use same buffer with ppmgr0
     };
 /// ***************************************************************************************
 ///	-	DISP&MM-Vout
@@ -429,19 +426,20 @@ void root_func(){
 //$$ L3 PROP_U32 = "max_req_size"
 //$$ L2 PROP_STR = "gpio_dat3"
 //$$ L2 PROP_U32 = "card_type"
-        emmc{
-            status = "ok";
-            port = <2>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
-            pinname = "emmc";
-            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
-            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
-            f_min = <300000>;
-            f_max = <50000000>;
-            f_max_w = <50000000>;
-            max_req_size = <0x20000>;          /**128KB*/
-            gpio_dat3 = "BOOT_3";
-            card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
-        };
+//        emmc{
+//            status = "ok";
+//            port = <2>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
+//            pinname = "emmc";
+//            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
+//            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
+//            f_min = <300000>;
+//            f_max = <50000000>;
+//            f_max_w = <50000000>;
+//            max_req_size = <0x20000>;          /**128KB*/
+//            gpio_dat3 = "BOOT_3";
+//            card_type = <1>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
+//        };
+
     };
 
 /// ***************************************************************************************
@@ -557,7 +555,7 @@ void root_func(){
 //$$ L2 PROP_U32 16*3 = "dvfs_table"
         vcck_dvfs {
             dvfs_id     = <1>;                                  /** must be value of (1 << n)            */
-            table_count = <14>;                                 /** must be correct count for dvfs_table */
+            table_count = <12>;                                 /** must be correct count for dvfs_table */
             dvfs_table  = <
             /* NOTE: frequent in this table must be ascending order */
             /* frequent(Khz)    min_uV      max_uV                  */
@@ -573,8 +571,6 @@ void root_func(){
                 1200000        1025000     1025000
                 1416000        1075000     1075000
                 1608000        1150000     1150000
-                1800000        1175000     1175000
-                1992000        1200000     1200000
             >;
         };
     };
@@ -839,13 +835,275 @@ void root_func(){
 			port-config = <0>; /** 0: default */
 			port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
 			port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
-//			gpio-vbus-power = "GPIOZ_1";
+			gpio-vbus-power = "PMU";
 			gpio-work-mask	= <1>; /**0: work on pulldown,1:work on pullup*/
 			status = "okay";
 		};
 	};
 
+/// ***************************************************************************************
+///	-	LCD
+//$$ MODULE="LCD"
+//$$ DEVICE="backlight"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_CHOICE "Bl_pin_0_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "Bl_pin_1_match" = "pinctrl-1"
+//$$ L2 PROP_U32 2= "bl_level_default_uboot_kernel"
+//$$ L2 PROP_U32 2= "bl_level_middle_mapping"
+//$$ L2 PROP_U32 2= "bl_level_max_min"
+//$$ L2 PROP_U32 = "bl_power_on_delay"
+//$$ L2 PROP_U32 = "bl_ctrl_method"
+//$$ L2 PROP_STR = "bl_gpio_port"
+//$$ L2 PROP_U32 2 = "bl_gpio_dim_max_min"
+//$$ L2 PROP_STR 2 = "bl_pwm_port_gpio_used"
+//$$ L2 PROP_U32 = "bl_pwm_freq"
+//$$ L2 PROP_U32 2 = "bl_pwm_duty_max_min"
+//$$ L2 PROP_U32 = "bl_pwm_combo_high_low_level_switch"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_high_port_method"
+//$$ L2 PROP_STR 2 = "bl_pwm_combo_low_port_method"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_high_freq_duty_max_min"
+//$$ L2 PROP_U32 3 = "bl_pwm_combo_low_freq_duty_max_min"
+    backlight{
+		compatible = "amlogic,backlight";
+		dev_name = "backlight";
+		status = "okay";
+		pinctrl-names = "default","pwm_combo";
+		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm_default pinmux */
+		pinctrl-1 = <&lcd_backlight_combo_pins>;	/** pwm_combo pinmux */
+		
+		bl_level_default_uboot_kernel=<10 102>;	/** default brightness level for uboot & kernel */
+		bl_level_middle_mapping=<128 102>;	/** brightness middle level mapping to a new level*/
+		bl_level_max_min=<255 10>;	/** brightness level max & min, must match the rootfs setting*/
+		
+		/* backlight power ctrl */
+		bl_power_on_delay=<200>; /** delay time before backlight power on(unit: ms) */
+		bl_ctrl_method=<4>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive, 3=pwm_combo. 4=extern. decided by hardware design) */
+		
+		bl_gpio_port="GPIODV_28";	/** backlight control gpio port */
+		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
+		bl_pwm_port_gpio_used="PWM_C","1";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
+		bl_pwm_freq=<300000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
+		bl_pwm_duty_max_min=<90 30>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
+		
+		/** backlight pwm_combo control: low_duty_max is always active for level_high, and high_duty_min is always active for level_low */
+		bl_pwm_combo_high_low_level_switch=<220>;	/** backlight pwm_combo control switch level */
+		bl_pwm_combo_high_port_method="PWM_C","1";	/** backlight pwm_combo high port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_low_port_method="PWM_D","2";	/** backlight pwm_combo low port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
+		bl_pwm_combo_high_freq_duty_max_min=<300000 96 89>;	/** backlight pwm_combo level_high port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
+		bl_pwm_combo_low_freq_duty_max_min=<10000 100 10>;	/** backlight pwm_combo level_low port frequency(unit: Hz), duty_max, duty_min : (unit: %, positive logic) */
+	};
+
+//******************************************************************************
+//bl extern
+//Notice: only one dev support
+//******************************************************************************
+//$$ DEVICE = "bl_extern_pmu_aml1218"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR 2 = "gpio_enable"
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_U32 2 = "dim_max_min"
+	bl_extern_pmu_aml1218{
+		compatible = "amlogic,bl_pmu_aml1218";
+		dev_name ="bl_pmu_aml1218";
+		status = "okay"; /** "disabled" or "okay" */
+
+		gpio_enable = "GPIODV_28"; /** "n" for none */
+		type = <2>;	/** bl_extern_driver type: 0=i2c, 1=spi, 2=other */
+		dim_max_min = <0x1 0x1b>;
+	};
+
+//******************************************************************************
+	lcd{
+		compatible = "amlogic,lcd";
+		dev_name = "lcd";
+		status = "okay";
+		pinctrl-names = "ttl_6bit_hvsync_de_on","ttl_6bit_hvsync_on","ttl_6bit_de_on","ttl_8bit_hvsync_de_on","ttl_8bit_hvsync_on","ttl_8bit_de_on",
+						"ttl_6bit_hvsync_de_off","ttl_8bit_hvsync_de_off";
+		pinctrl-0 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
+		pinctrl-1 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_off>;
+		pinctrl-2 = <&lcd_ttl_rgb_6bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_on>;
+		pinctrl-3 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_on>;
+		pinctrl-4 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_on &lcd_ttl_de_pins_off>;
+		pinctrl-5 = <&lcd_ttl_rgb_8bit_pins_on &lcd_ttl_clk_pins_on &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_on>;
+		pinctrl-6 = <&lcd_ttl_rgb_6bit_pins_off &lcd_ttl_clk_pins_off &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_off>;
+		pinctrl-7 = <&lcd_ttl_rgb_8bit_pins_off &lcd_ttl_clk_pins_off &lcd_ttl_hvsync_pins_off &lcd_ttl_de_pins_off>;
+		
+		lcd_model_name ="lcd_IVO785H4026172";	/** lcd model name for uboot driver */
+		lcd_model_config = <&lcd_IVO785H4026172>;	/** choose panel model config */
+		lcd_bits_user=<6>;	/** user defined lcd bits(6 or 8, decided by hardware design; only valid when lcd_bits_option=1) */
+		
+		/* below configs are decided by hardware design, you can modify them if needed. */
+		ttl_rb_bit_swap=<0 0>;	/** ttl rb_swap, bit_swap : (0=normal, 1=swap) */
+		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap(0=normal, 1=swap) */
+		
+		/* recommend settings, you can modify them if needed. */
+		valid_hvsync_de=<1 1>;	/** hvsync_signal_valid, DE_signal_valid : (0=disable signal, 1=enable signal) */
+		hsign_hoffset_vsign_voffset=<0 0 0 0>;	/** hsign, hoffset, vsign, voffset :("sign-offset" is a pair. sign: 0=positive, 1=negative) */
+		
+		dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
+		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
+		
+		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
+		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
+		gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
+				32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 
+				64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 
+				96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 
+				128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 
+				160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 
+				192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 
+				224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255>;
+		
+		/* default settings, don't modify them unless there is display problem */
+		clock_spread_spectrum=<0>;	/** ss_level(0=disable, 1=0.5%, 2=1%, 3=1.5%, 4=2%) */
+		clock_auto_generation=<1>;	/** clk_auto_generation(0=use customer clock parameters, as clk_pll_div_clk_ctrl defined, 1=auto generate clock parameters by lcd_clock) */
+		clk_pll_div_clk_ctrl=<0x20445 0x18803 0x02ee1101>;	/** pll_ctrl, div_ctrl, clk_ctrl : (only valid when clk_auto_generation=0) */
+		lvds_vswing=<1>;	/** lvds_vswing_level(default level=1, support level 0,1,2,3,4) */
+		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
+		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
+
+		//lcd power ctrl	//support up to 15 steps for each sequence
+		power_on_uboot="n","n","n";	/** only for uboot, ahead of lcd_power_on, no need config delay */
+		power_on_step_1="cpu","GPIODV_29","0";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_step_2="signal","n","n";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_on_delay=<100 10>;	/** power on delay after each step */
+		power_off_step_1="signal";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_step_2="cpu","GPIODV_29","0";	/** gpio_type(support 3 types: cpu, pmu, signal), gpio_name(upper-case, valid when gpio_type is cpu or pmu), gpio_value(0=output_low, 1=output_high, 2=input. valid when gpio_type is cpu or pmu) */
+		power_off_delay=<20 1000>;	/** power off delay after each step */
+		power_off_uboot="n","n","n";	/** only for uboot, at the end of lcd_power_off, no need config delay */
+	};
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_IVO785H4026172>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+	lcd_IVO785H4026172:lcd_IVO785H4026172{
+		model_name="IVO785H4026172";	/** lcd model name */
+		interface="lvds";			/** lcd_interface(mipi, lvds, ttl) */
+		active_area=<120 160>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 0>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+		
+		resolution=<768 1024>;	/** horizontal resolution, vertical resolution */
+		period=<928 1065>;		/** horizontal period(htotal), vertical period(vtotal) */
+		
+		clock_hz_pol=<59300000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<10 80>;	/** hsync_width, hsync_backporch(include hsync_width) */
+		vsync_width_backporch=<2 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+	};
+
+//******************************************************************************
+///     -       Sensors
+//$$ MODULE="Sensors"
+//$$ DEVICE="sensor"
+//$$ L2 PROP_STR = "status"
+    sensor{
+		compatible = "amlogic,aml_sensor";
+		status = "okay";
+
+//$$ DEVICE="mc32x0"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "address"
+//$$ L2 PROP_STR = "i2c_bus"
+        mc32x0{
+            dev_name = "mc32x0";
+            status = "okay";
+            address = <0x4c>;
+            i2c_bus = "i2c_bus_b";
+            acc_dir = <0x0010>;
+        };
+//$$ DEVICE="mma7660"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "address"
+//$$ L2 PROP_STR = "i2c_bus"
+//        mma7660{
+//            dev_name = "mma7660";
+//            status = "okay";
+//            address = <0x4c>;
+//            i2c_bus = "i2c_bus_b";
+//       };
+
+
+	};
+
+
 
+/// ***************************************************************************************
+///	-	Touch
+//$$ MODULE="Touch"
+//$$ DEVICE = "touch"
+//$$ L2 PROP_STR = "status"
+    touch{
+        compatible = "amlogic,aml_touch";
+        status = "okay";
+        #address-cells = <1>;
+        #size-cells = <0>;
+	
+//$$ DEVICE = "touch_ft5x06"
+//$$ L2 PROP_STR = "status"
+//$$ L3 PROP_STR = "i2c_bus"
+//$$ L3 PROP_U32 ="reg"
+//$$ L3 PROP_U32 ="ic_type"
+//$$ L3 PROP_U32 ="irq"
+//$$ L3 PROP_STR = "gpio_interrupt"
+//$$ L3 PROP_STR = "gpio_reset"
+//$$ L3 PROP_U32 ="xres"
+//$$ L3 PROP_U32 ="yres"
+//$$ L3 PROP_U32 ="pol"
+//$$ L3 PROP_STR = "fw_file"
+				touch_ft5x06:ft5x06{
+					touch_name = "ft5x06";
+					
+					i2c_bus = "i2c_bus_a";
+					reg = <0x38>;
+					ic_type = <0>;
+					irq = <0>;
+					gpio_interrupt = "GPIOA_16";
+					gpio_reset = "GPIOC_3";
+					xres = <1024>;
+					yres = <600>;
+					pol = <0x1>;
+					fw_file = "/etc/touch/ft5x06.fw";
+				};
+//$$ DEVICE = "touch_gslx680"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR = "touch_name"
+//$$ L3 PROP_STR = "i2c_bus"
+//$$ L3 PROP_U32 ="ic_type"
+//$$ L3 PROP_U32 ="irq"
+//$$ L3 PROP_U32 ="irq_edge"
+//$$ L3 PROP_STR = "gpio_interrupt"
+//$$ L3 PROP_STR = "gpio_reset"
+//$$ L3 PROP_U32 ="xres"
+//$$ L3 PROP_U32 ="yres"
+//$$ L3 PROP_U32 ="pol"
+//$$ L3 PROP_U32 ="max_num"
+//$$ L3 PROP_STR = "fw_file"
+				touch_gslx680:gslx680{
+					touch_name = "gslx680";
+					i2c_bus = "i2c_bus_a";
+					status = "okay";
+					reg = <0x40>;
+					ic_type = <0>;
+					irq = <1>;
+					irq_edge = "GPIO_IRQ_RISING";
+					gpio_interrupt = "GPIOA_16";
+					gpio_reset = "GPIOC_3";
+					xres = <1024>;
+					yres = <600>;
+					pol = <0x4>;
+					max_num = <5>;
+					fw_file = "/etc/touch/gslx680.fw";
+				};
+   };
 
 
 /// ***************************************************************************************
@@ -960,7 +1218,7 @@ void root_func(){
     aml_m8_sound_card{
         compatible = "sound_card, aml_snd_m8";
         aml,sound_card = "AML-M8AUDIO";
-        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi";
+        aml,codec_dai = "AML-M8","rt5616-aif1","rt5631-hifi","wm8960-hifi","pmu3-hifi";
         //aml,codec_name = "aml_m8_codec.0","rt5616.4-001b";
         //aml,audio-codec = <&rt5616>;
         aml,audio-routing-rt5616 = 
@@ -977,8 +1235,19 @@ void root_func(){
             "HP","HP_R",
             "MICBIAS","MAIN MIC",
             "LINPUT1","MICBIAS";
+        aml,audio-routing-amlpmu3 = 
+            "Ext Spk","LINEOUTL1",
+            "Ext Spk","LINEOUTR1",
+            "HP","HP_L",
+            "HP","HP_R",
+            "Mic Bias1","MAIN MIC",
+            "LINEINLP","Mic Bias1";
+        sleep_time = <130>;
         mute_gpio = "GPIO_BSD_EN";
-        //mute_inv;
+        I2S_MCLK = "GPIOAO_8";
+        I2S_SCLK = "GPIOAO_9";
+        I2S_LRCLK = "GPIOAO_10";
+        I2S_ODAT = "GPIOAO_11";
         hp_paraments = <800 300 0 5 1>;
         pinctrl-names = "aml_snd_m8";
         pinctrl-0 = <&audio_pins>;
@@ -1002,38 +1271,8 @@ void root_func(){
 		pinctrl-0 = <&aml_cam_gpio_pins> ;
 		pinctrl-1 = <&aml_cam_csi_pins> ;
 
-///	-	ar0543
-//$$ DEVICE="ar0543"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "front_back"
-//$$ L2 PROP_STR = "i2c_bus"
-//$$ L2 PROP_STR = "gpio_pwdn"
-//$$ L2 PROP_STR = "gpio_rst"
-//$$ L2 PROP_U32 = "mirror_flip"
-//$$ L2 PROP_U32 = "vertical_flip"
-//$$ L2 PROP_STR = "config_path"
-//$$ L2 PROP_U32 = "mclk"
-//$$ L2 PROP_STR = "bt_path"
-//$$ L2 PROP_STR = "interface"
-//$$ L2 PROP_STR = "clk_channel"
-		cam_0{
-			cam_name = "ar0543";
-			front_back = <0>;
-			i2c_bus = "i2c_bus_d";
-			gpio_pwdn = "GPIOH_6";
-			gpio_rst = "GPIOH_4";
-			mirror_flip = <0>;
-			vertical_flip = <0>;
-			config_path = "/system/etc/camera_isp_cfg/ar0543_skt";
-			mclk = <12000>;
-			bt_path = "csi";
-			interface = "mipi";
-			clk_channel = "a";
-			status = "okay";
-		};
-
-///	-	ov5647
-//$$ DEVICE="ov5647"
+///	-	gc2035
+//$$ DEVICE="gc2035"
 //$$ L2 PROP_STR = "status"
 //$$ L2 PROP_U32 = "front_back"
 //$$ L2 PROP_STR = "i2c_bus"
@@ -1042,20 +1281,15 @@ void root_func(){
 //$$ L2 PROP_U32 = "mirror_flip"
 //$$ L2 PROP_U32 = "vertical_flip"
 //$$ L2 PROP_STR = "bt_path"
-//$$ L2 PROP_STR = "interface"
-//$$ L2 PROP_STR = "clk_channel"
-		cam_1{
-			cam_name = "ov5647";
-			front_back = <0>;
+        	cam_0{
+			cam_name = "gc2035";
+			front_back = <1>;
 			i2c_bus = "i2c_bus_d";
 			gpio_pwdn = "GPIOH_5";
 			gpio_rst = "GPIOH_4";
-			mirror_flip = <0>;
+			mirror_flip = <1>;
 			vertical_flip = <0>;	
-			config_path = "/system/etc/camera_isp_cfg/ov5647_cw0767";
-			bt_path = "csi";
-			interface = "mipi";
-			clk_channel = "b";
+			bt_path = "gpio";
 			status = "okay";
 		};
 		
@@ -1117,71 +1351,28 @@ void root_func(){
     adc_keypad{
 		compatible = "amlogic,adc_keypad";
 		status = "okay";
-		key_name = "menu", "vol-","vol+", "esc", "home";
-		key_num = <5>;
-		key_code = <139 114 115 1 102>;
-		key_chan = <0 0 0 0 0>;
-		key_val = <0 143 271 393 468>; //voltage=0/252/478/692/824mV, val=voltage/1800mV*1023
-		key_tolerance = <40 40 40 40 40>;
-	};
-
-//$$ DEVICE="meson-remote"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "ao_baseaddr"
-//$$ L2 PROP_STR = "pinctrl-names"
-//$$ L2 PROP_CHOICE "remote_pin_0_match" = "pinctrl-0"
-    meson-remote{
-		compatible = "amlogic,aml_remote";
-		dev_name = "meson-remote";
-		status = "ok";
-		ao_baseaddr = <0xf3100480>;
-		pinctrl-names="default";
-		pinctrl-0=<&remote_pins>;
+		key_name = "vol-","vol+";
+		key_num = <2>;
+		key_code = <114 115>;
+		key_chan = <0 0>;
+		key_val = <144 267>;
+		key_tolerance = <40 40>;
 	};
 
 /// ***************************************************************************************
-///	-	Spi
-//$$ MODULE="Spi"
-//$$ DEVICE="spi"
+///	-	WiFi
+//$$ MODULE="WiFi"
+//$$ DEVICE="wifi_power"
 //$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 2 = "reg"
-//$$ L2 PROP_STR = "pinctrl-names"
-//$$ L2 PROP_CHOICE "Spi_pin_0_match" = "pinctrl-0"
-//$$ L2 PROP_U32 = "nr-parts"
-//$$ L2 PROP_CHOICE "Spi_nr-part-0_match" = "nr-part-0"
-//$$ L2 PROP_CHOICE "Spi_nr-part-1_match" = "nr-part-1"
-    spi@cc000000{
-		compatible = "amlogic,apollo_spi_nor";
-		status = "ok";
-		reg = <0xcc000000 0x04000000>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&aml_spi_nor_pins>;
-
-		nr-parts = <2>;
-		nr-part-0 = <&bootloader>;
-		nr-part-1 = <&ubootenv>;
-
-//$$ MATCH "Spi_nr-part-0_match" = <&bootloader>
-//$$ L2 PROP_STR = "name"
-//$$ L2 PROP_U32 = "offset"
-//$$ L2 PROP_U32 = "size"
-		bootloader:bootloader{
-			name = "bootloader";
-			offset = <0>;
-			size = <0x60000>;
-		};
-
-//$$ MATCH "Spi_nr-part-1_match" = <&ubootenv>
-//$$ L2 PROP_STR = "name"
-//$$ L2 PROP_U32 = "offset"
-//$$ L2 PROP_U32 = "size"
-		ubootenv:ubootenv{
-			name = "ubootenv";
-		      offset = <0x100000>;
-		      size = <0x10000>;
-		};
-	};
-	
+//$$ L2 PROP_STR = "power_gpio"
+	wifi_power{
+            compatible = "amlogic,wifi_power";
+            dev_name = "wifi_power";
+            status = "okay";
+            power_gpio = "GPIOAO_6";
+            power_gpio2 = "GPIOX_11";
+	};  
+    
 /// ***************************************************************************************
 ///	-	Nand
 //$$ MODULE="Nand"
@@ -1323,49 +1514,7 @@ void root_func(){
 		};
 	};
 
-/// ***************************************************************************************
-///	-	HDMI
-//$$ MODULE="HDMI"
-//$$ DEVICE="amhdmitx"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_CHOICE "HDMI_vend-data_match" = "vend-data"
-//$$ L2 PROP_CHOICE "HDMI_pwr-ctrl_match" = "pwr-ctrl"
-    amhdmitx{
-		compatible = "amlogic,amhdmitx";
-		dev_name = "amhdmitx";
-		status = "ok";
-        vend-data = <&vend_data>;
-        pwr-ctrl = <&pwr_ctrl>;
-        
-//$$ MATCH "HDMI_vend-data_match" = <&vend_data>
-//$$ L2 PROP_STR = "vendor_name"
-//$$ L2 PROP_U32 = "vendor_id"
-//$$ L2 PROP_STR = "product_desc"
-//$$ L2 PROP_STR = "cec_osd_string"        
-        vend_data: vend_data{
-            vendor_name = "Amlogic";           /* Max Chars: 8     */
-            vendor_id = <0x000000>;                 /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
-            product_desc = "M8 MBox SKTv1";        /* Max Chars: 16    */
-            cec_osd_string = "Amlogic MBox";        /* Max Chars: 14    */
-        };
-        
-//$$ MATCH "HDMI_pwr-ctrl_match" = <&pwr_ctrl>
-//$$ L2 PROP_STR = "pwr_5v_on"
-//$$ L2 PROP_STR = "pwr_5v_off"
-//$$ L2 PROP_STR = "pwr_3v3_on"
-//$$ L2 PROP_STR = "pwr_3v3_off"
-//$$ L2 PROP_STR = "pwr_hpll_vdd_on"
-//$$ L2 PROP_STR = "pwr_hpll_vdd_off"
-        pwr_ctrl: pwr_ctrl{
-            pwr_5v_on = "";
-            pwr_5v_off = "";
-            pwr_3v3_on = "";
-            pwr_3v3_off = "";
-            pwr_hpll_vdd_on = "";
-            pwr_hpll_vdd_off = "";
-        };
-	};
-
+	
 /// ***************************************************************************************
 ///	-	PowerManager
 //$$ MODULE="PowerManager"
@@ -1376,6 +1525,7 @@ void root_func(){
 		dev_name = "aml_pm_m8";
 		status = "okay";
 	};
+	
 
 /// ***************************************************************************************
 ///	-	Cpufreq
@@ -1685,14 +1835,10 @@ void root_func(){
 //$$ L2 PROP_U32 10 = "amlogic,clrmask"
 //$$ L2 PROP_STR 6 = "amlogic,pins"
         audio_pins:audio_pin{
-            amlogic,setmask=<1 0x80
-                             1 0x75>;
-            amlogic,clrmask=<1 0x10000
-                             1 0x0a
-                             3 0x389
-                             4 0x3c00000
-                             9 0xd>;
-            amlogic,pins = "GPIOY_3","GPIOY_4","GPIOY_5","GPIOY_6","GPIOY_7","GPIOY_8";
+            amlogic,setmask=<10 0x78000000
+                              1 0x2000>;   // I2s_in
+            amlogic,clrmask=<10 0x80018000>;
+            amlogic,pins = "GPIOAO_8","GPIOAO_9","GPIOAO_10","GPIOAO_11","GPIOAO_6";
         };
 
 //$$ MATCH "Spi_pin_0_match" = "&aml_spi_nor_pins"
@@ -1705,5 +1851,84 @@ void root_func(){
 			amlogic,pins = "BOOT_11","BOOT_12","BOOT_13","BOOT_18";
 		};
 	};
+	
+//$$ MATCH "Bl_pin_0_match" = "&lcd_backlight_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 4 = "amlogic,clrmask"
+//$$ L2 PROP_STR = "amlogic,pins"
+		lcd_backlight_pins:lcd_backlight{
+			amlogic,setmask=<3 0x01000000>;
+			amlogic,clrmask=<0 0x00000048 7 0x10000200>;
+			amlogic,pins = "GPIODV_9";
+		};
+		
+//$$ MATCH "Bl_pin_1_match" = "&lcd_backlight_combo_pins"
+//$$ L2 PROP_U32 2 = "amlogic,setmask"
+//$$ L2 PROP_U32 6 = "amlogic,clrmask"
+//$$ L2 PROP_STR 2 = "amlogic,pins"
+		lcd_backlight_combo_pins:lcd_backlight_combo{
+			amlogic,setmask=<3 0x05000000>;
+			amlogic,clrmask=<0 0x48 7 0x18000200 9 0x08000000>;
+			amlogic,pins = "GPIODV_9","GPIODV_28";
+		};
+		
+		lcd_ttl_hvsync_pins_on:lcd_ttl_hvsync_on{
+			amlogic,setmask=<1 0x00000011>;
+			amlogic,clrmask=<1 0x04800000 5 0x08000000 8 0x00000800 9 0x00002000>;
+			amlogic,pins = "GPIOH_0","GPIOH_3";
+		};
+		lcd_ttl_hvsync_pins_off:lcd_ttl_hvsync_off{
+			amlogic,clrmask=<1 0x04800011 5 0x08000000 8 0x00000800 9 0x00002000>;
+			amlogic,pins = "GPIOH_0","GPIOH_3";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_de_pins_on:lcd_ttl_de_on{
+			amlogic,setmask=<1 0x00000002>;
+			amlogic,clrmask=<1 0x01000000>;
+			amlogic,pins = "GPIOH_2";
+		};
+		lcd_ttl_de_pins_off:lcd_ttl_de_off{
+			amlogic,clrmask=<1 0x01000002>;
+			amlogic,pins = "GPIOH_2";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_clk_pins_on:lcd_ttl_clk_on{
+			amlogic,setmask=<1 0x00000004>;
+			amlogic,clrmask=<1 0x02000008 8 0x00001000>;
+			amlogic,pins = "GPIOH_1";
+		};
+		lcd_ttl_clk_pins_off:lcd_ttl_clk_off{
+			amlogic,clrmask=<1 0x0200000c 8 0x00001000>;
+			amlogic,pins = "GPIOH_1";
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_rgb_8bit_pins_on:lcd_ttl_rgb_8bit_on{
+			amlogic,setmask=<0 0x03c00000 8 0x00070000>;
+			amlogic,clrmask=<4 0x0000000e 5 0x07000000 6 0x0000ff7f 7 0x00f00000 9 0x00001c00>;
+			amlogic,pins = "GPIOH_4","GPIOH_5","DIF_TTL_4_N","DIF_TTL_4_P","DIF_TTL_3_N","DIF_TTL_3_P","DIF_TTL_2_N","DIF_TTL_2_P",		//R0~R7
+						"GPIOH_6","GPIOH_7","DIF_TTL_1_N","DIF_TTL_1_P","DIF_TTL_0_N","DIF_TTL_0_P","HDMI_TTL_CK_N","HDMI_TTL_CK_P",	//G0~G7
+						"GPIOH_8","GPIOH_9","HDMI_TTL_2_N","HDMI_TTL_2_P","HDMI_TTL_1_N","HDMI_TTL_1_P","HDMI_TTL_0_N","HDMI_TTL_0_P";	//B0~B7
+		};
+		lcd_ttl_rgb_8bit_pins_off:lcd_ttl_rgb_8bit_off{
+			amlogic,clrmask=<0 0x03c00000 4 0x0000000e 5 0x07000000 6 0x0000ff7f 7 0x00f00000 8 0x00070000 9 0x00001c00>;
+			amlogic,pins = "GPIOH_4","GPIOH_5","DIF_TTL_4_N","DIF_TTL_4_P","DIF_TTL_3_N","DIF_TTL_3_P","DIF_TTL_2_N","DIF_TTL_2_P",		//R0~R7
+						"GPIOH_6","GPIOH_7","DIF_TTL_1_N","DIF_TTL_1_P","DIF_TTL_0_N","DIF_TTL_0_P","HDMI_TTL_CK_N","HDMI_TTL_CK_P",	//G0~G7
+						"GPIOH_8","GPIOH_9","HDMI_TTL_2_N","HDMI_TTL_2_P","HDMI_TTL_1_N","HDMI_TTL_1_P","HDMI_TTL_0_N","HDMI_TTL_0_P";	//B0~B7
+			amlogic,enable-output=<1>;
+		};
+		lcd_ttl_rgb_6bit_pins_on:lcd_ttl_rgb_6bit_on{
+			amlogic,setmask=<0 0x03c00000>;
+			amlogic,clrmask=<6 0x0000077f 7 0x00c00000>;
+			amlogic,pins = "DIF_TTL_4_N","DIF_TTL_4_P","DIF_TTL_3_N","DIF_TTL_3_P","DIF_TTL_2_N","DIF_TTL_2_P",		//R2~R7
+						"DIF_TTL_1_N","DIF_TTL_1_P","DIF_TTL_0_N","DIF_TTL_0_P","HDMI_TTL_CK_N","HDMI_TTL_CK_P",	//G2~G7
+						"HDMI_TTL_2_N","HDMI_TTL_2_P","HDMI_TTL_1_N","HDMI_TTL_1_P","HDMI_TTL_0_N","HDMI_TTL_0_P";	//B2~B7
+		};
+		lcd_ttl_rgb_6bit_pins_off:lcd_ttl_rgb_6bit_off{
+			amlogic,clrmask=<0 0x03c00000 6 0x0000077f 7 0x00c00000>;
+			amlogic,pins = "DIF_TTL_4_N","DIF_TTL_4_P","DIF_TTL_3_N","DIF_TTL_3_P","DIF_TTL_2_N","DIF_TTL_2_P",		//R2~R7
+						"DIF_TTL_1_N","DIF_TTL_1_P","DIF_TTL_0_N","DIF_TTL_0_P","HDMI_TTL_CK_N","HDMI_TTL_CK_P",	//G2~G7
+						"HDMI_TTL_2_N","HDMI_TTL_2_P","HDMI_TTL_1_N","HDMI_TTL_1_P","HDMI_TTL_0_N","HDMI_TTL_0_P";	//B2~B7
+			amlogic,enable-output=<1>;
+		};
 
 }; /* end of / */
diff --git a/drivers/amlogic/display/vout/edp_drv.c b/drivers/amlogic/display/vout/edp_drv.c
index 69642fc0313a..c7fb8d89e7ee 100755
--- a/drivers/amlogic/display/vout/edp_drv.c
+++ b/drivers/amlogic/display/vout/edp_drv.c
@@ -15,7 +15,7 @@
 #include <linux/delay.h>
 #include <mach/am_regs.h>
 #include <linux/amlogic/vout/lcd_reg.h>
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 #include <mach/edp_tx_reg.h>
 #include "edp_drv.h"
 
diff --git a/drivers/amlogic/display/vout/edp_drv.h b/drivers/amlogic/display/vout/edp_drv.h
index d4cf75833e98..b285542e91d9 100755
--- a/drivers/amlogic/display/vout/edp_drv.h
+++ b/drivers/amlogic/display/vout/edp_drv.h
@@ -174,7 +174,7 @@
 #define VAL_EDP_TX_OPERATION_FAILED				0x00FF
 #define VAL_EDP_TX_OPERATION_SUCCESS			0x0000
 //********************************************************//
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 typedef enum {
 	EDP_HPD_STATE_DISCONNECTED = 0,
 	EDP_HPD_STATE_CONNECTED,
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index 272366db5baf..3aee27988299 100755
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -56,9 +56,11 @@
 #include <mach/mlvds_regs.h>
 #endif
 #if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
-#include "edp_drv.h"
 #include "mipi_dsi_util.h"
 #endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#include "edp_drv.h"
+#endif
 #include <linux/amlogic/vout/aml_lcd_extern.h>
 #ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
 #include <linux/amlogic/aml_pmu_common.h>
@@ -71,10 +73,12 @@
 #define FIQ_VSYNC
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 #define DRV_TYPE "c6"
-#else
+#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 #define DRV_TYPE "c8"
+#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
+#define DRV_TYPE "c8b"
 #endif
-#define DRIVER_DATE		"20140429"
+#define DRIVER_DATE		"20140512"
 
 #define LCD_DEBUG_INFO
 #ifdef LCD_DEBUG_INFO
@@ -114,7 +118,8 @@ static DSI_Config_t lcd_mipi_config = {
     .dsi_init_off = NULL,
     .lcd_extern_init = 0,
 };
-
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 static EDP_Config_t lcd_edp_config = {
 	.link_user = 0,
 	.link_rate = 1,
@@ -177,6 +182,8 @@ static Lcd_Config_t lcd_config = {
     .lcd_control = {
 #if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
         .mipi_config = &lcd_mipi_config,
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         .edp_config = &lcd_edp_config,
 #endif
         .lvds_config = &lcd_lvds_config,
@@ -234,21 +241,20 @@ static void lcd_ports_ctrl_lvds(Bool_t status)
 {
 	if (status) {
 		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1);	//enable lvds fifo
-		if (pDev->pConf->lcd_basic.lcd_bits == 6)
-			{
+		if (pDev->pConf->lcd_basic.lcd_bits == 6) {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 			WRITE_LCD_REG_BITS(LVDS_PHY_CNTL4, 0x27, 0, 7);	//enable LVDS 3 channels
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 			WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1e, 11, 5);	//enable LVDS phy 3 channels
 #endif
-			}
-		else{
+		}
+		else {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 			WRITE_LCD_REG_BITS(LVDS_PHY_CNTL4, 0x2f, 0, 7);	//enable LVDS 4 channels
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 			WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);	//enable LVDS phy 4 channels
 #endif
-			}
+		}
 	}
 	else {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
@@ -256,7 +262,7 @@ static void lcd_ports_ctrl_lvds(Bool_t status)
 		WRITE_LCD_REG_BITS(LVDS_PHY_CNTL5, 0, 11, 1);	//shutdown lvds phy
 		WRITE_LCD_REG_BITS(LVDS_PHY_CNTL4, 0, 0, 7);	//disable LVDS 4 channels
 		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
 		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
 		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
@@ -295,7 +301,9 @@ static void lcd_ports_ctrl_mipi(Bool_t status)
 
     DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
 }
+#endif
 
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 static void lcd_ports_ctrl_edp(Bool_t status)
 {
 	if (status) {
@@ -321,69 +329,6 @@ static void lcd_ports_ctrl_edp(Bool_t status)
 	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
 }
 #endif
-static unsigned pinmux_data_set[][2]={
-    {PERIPHS_PIN_MUX_0,0x03c00000},//RGB[7:2]
-};
-static unsigned pinmux_data_clr[][2]={
-    {PERIPHS_PIN_MUX_6,0x0000077f},//RGB[7:2]
-    {PERIPHS_PIN_MUX_4,0x0000000e},//RGB[1:0]
-    {PERIPHS_PIN_MUX_5,0x07000000},//RGB[1:0]
-    {PERIPHS_PIN_MUX_6,0x0000f800},//RGB[1:0]
-    {PERIPHS_PIN_MUX_7,0x00300000},//RGB[1:0]
-    {PERIPHS_PIN_MUX_9,0x00001c00},//RGB[1:0]
-};
-static unsigned pinmux_data_set_table[][3]={
-    {0,0xf},  //6bit index
-    {0,1,0xf},//8bit index
-};
-static unsigned pinmux_data_clr_table[][7]={
-    {0,0xf},          //6bit index
-    {0,1,2,3,4,5,0xf},//8bit index
-};
-
-static unsigned pinmux_tcon_set[][2]={
-    {PERIPHS_PIN_MUX_1,0x00000004},//clk
-    {PERIPHS_PIN_MUX_1,0x00000002},//DE
-    {PERIPHS_PIN_MUX_1,0x00000011},//sync
-};
-static unsigned pinmux_tcon_clr[][2]={
-    {PERIPHS_PIN_MUX_1,0x02000008},//clk
-    {PERIPHS_PIN_MUX_8,0x00001000},//clk
-    {PERIPHS_PIN_MUX_1,0x01000000},//DE
-    {PERIPHS_PIN_MUX_1,0x04800000},//sync
-    {PERIPHS_PIN_MUX_5,0x08000000},//sync
-    {PERIPHS_PIN_MUX_8,0x00000800},//sync
-    {PERIPHS_PIN_MUX_9,0x00020000},//sync
-};
-static unsigned pinmux_tcon_set_table[][4]={
-    {0,1,0xf},  //DE index
-    {0,2,0xf},  //Sync index
-    {0,1,2,0xf},//DE+Sync index
-};
-static unsigned pinmux_tcon_clr_table[][8]={
-    {0,1,2,0xf},        //DE index
-    {0,1,3,4,5,6,0xf},  //Sync index
-    {0,1,2,3,4,5,6,0xf},//DE+Sync index
-};
-
-static unsigned gpio_data_set[][2]={
-    {PREG_PAD_GPIO4_EN_N, 0x3ffff000},//RGB[7:2]
-    {PREG_PAD_GPIO3_EN_N, 0x1f800000},//RGB[1:0]
-};
-static unsigned gpio_tcon_set[][2]={
-    {PREG_PAD_GPIO3_EN_N, 0x00100000},//clk
-    {PREG_PAD_GPIO3_EN_N, 0x00200000},//DE
-    {PREG_PAD_GPIO3_EN_N, 0x00480000},//Sync
-};
-static unsigned gpio_data_set_table[][3]={
-    {0,0xf},  //6bit index
-    {0,1,0xf},//8bit index
-};
-static unsigned gpio_tcon_set_table[][4]={
-    {0,1,0xf},  //DE index
-    {0,2,0xf},  //Sync index
-    {0,1,2,0xf},//DE+Sync index
-};
 
 static void lcd_ports_ctrl_ttl(Bool_t status)
 {
@@ -451,134 +396,6 @@ static void lcd_ports_ctrl_ttl(Bool_t status)
 			return;
 		}
 	}
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-	unsigned *pin_tcon_set, *pin_data_set;
-	unsigned *pin_tcon_clr, *pin_data_clr;
-	unsigned *gpio_tcon, *gpio_data;
-	unsigned pin_reg;
-	int i;
-	
-	//tcon pin
-	if ((pDev->pConf->lcd_timing.de_valid == 1) && (pDev->pConf->lcd_timing.hvsync_valid == 0)) {
-		pin_tcon_set = &pinmux_tcon_set_table[0][0];
-		pin_tcon_clr = &pinmux_tcon_clr_table[0][0];
-		gpio_tcon = &gpio_tcon_set_table[0][0];
-	}
-	else if ((pDev->pConf->lcd_timing.de_valid == 0) && (pDev->pConf->lcd_timing.hvsync_valid == 1)) {
-		pin_tcon_set = &pinmux_tcon_set_table[1][0];
-		pin_tcon_clr = &pinmux_tcon_clr_table[1][0];
-		gpio_tcon = &gpio_tcon_set_table[1][0];
-	}
-	else {
-		pin_tcon_set = &pinmux_tcon_set_table[2][0];
-		pin_tcon_clr = &pinmux_tcon_clr_table[2][0];
-		gpio_tcon = &gpio_tcon_set_table[2][0];
-	}
-	//RGB data pin
-	
-	if (pDev->pConf->lcd_basic.lcd_bits == 8) {
-		pin_data_set = &pinmux_data_set_table[0][0];
-		pin_data_clr = &pinmux_data_clr_table[0][0];
-		gpio_data = &gpio_data_set_table[0][0];
-	}
-	else 
-	{
-		pin_data_set = &pinmux_data_set_table[1][0];
-		pin_data_clr = &pinmux_data_clr_table[1][0];
-		gpio_data = &gpio_data_set_table[1][0];
-	}
-	if (status) {
-		i = 0;
-		while (i < 0xf) {//pinmux_tcon_set
-			if (pin_tcon_set[i] == 0xf) {
-				break;
-			}
-			else {
-				pin_reg = pinmux_tcon_set[pin_tcon_set[i]][0];
-				WRITE_LCD_CBUS_REG(pin_reg, (READ_LCD_CBUS_REG(pin_reg) | pinmux_tcon_set[pin_tcon_set[i]][1]));
-				i++;
-			}
-		}
-		i = 0;
-		while (i < 0xf) {//pinmux_tcon_clr
-			if (pin_tcon_clr[i] == 0xf) {
-				break;
-			}
-			else {
-				pin_reg = pinmux_tcon_clr[pin_tcon_clr[i]][0];
-				WRITE_LCD_CBUS_REG(pin_reg, (READ_LCD_CBUS_REG(pin_reg) & ~(pinmux_tcon_clr[pin_tcon_clr[i]][1])));
-				i++;
-			}
-		}
-		i = 0;
-		while (i < 0xf) {//pinmux_data_set
-			if (pin_data_set[i] == 0xf) {
-				break;
-			}
-			else {
-				pin_reg = pinmux_data_set[pin_data_set[i]][0];
-				WRITE_LCD_CBUS_REG(pin_reg, (READ_LCD_CBUS_REG(pin_reg) | pinmux_data_set[pin_data_set[i]][1]));
-				i++;
-			}
-		}
-		i = 0;
-		while (i < 0xf) {//pinmux_data_clr
-			if (pin_data_clr[i] == 0xf) {
-				break;
-			}
-			else {
-				pin_reg = pinmux_data_clr[pin_data_clr[i]][0];
-				WRITE_LCD_CBUS_REG(pin_reg, (READ_LCD_CBUS_REG(pin_reg) & ~(pinmux_data_clr[pin_data_clr[i]][1])));
-				i++;
-			}
-		}
- 	}else {
-		i = 0;
-		while (i < 0xf) {//pinmux_data_set
-			if (pin_data_set[i] == 0xf) {
-				break;
-			}
-			else {
-				pin_reg = pinmux_data_set[pin_data_set[i]][0];
-				WRITE_LCD_CBUS_REG(pin_reg, (READ_LCD_CBUS_REG(pin_reg) & ~(pinmux_data_set[pin_data_set[i]][1])));
-				i++;
-			}
-		}
-		i = 0;
-		while (i < 0xf) {//pinmux_tcon_set
-			if (pin_tcon_set[i] == 0xf) {
-				break;
-			}
-			else {
-				pin_reg = pinmux_tcon_set[pin_tcon_set[i]][0];
-				WRITE_LCD_CBUS_REG(pin_reg, (READ_LCD_CBUS_REG(pin_reg) & ~(pinmux_tcon_set[pin_tcon_set[i]][1])));
-				i++;
-			}
-		}
-		i = 0;
-		while (i < 0xf) {//gpio_data_set
-			if (gpio_data[i] == 0xf) {
-				break;
-			}
-			else {
-				pin_reg = gpio_data_set[gpio_data[i]][0];
-				WRITE_LCD_CBUS_REG(pin_reg, (READ_LCD_CBUS_REG(pin_reg) | (gpio_data_set[gpio_data[i]][1])));
-				i++;
-			}
-		}
-		i = 0;
-		while (i < 0xf) {//gpio_tcon_set
-			if (gpio_tcon[i] == 0xf) {
-				break;
-			}
-			else {
-				pin_reg = gpio_tcon_set[gpio_tcon[i]][0];
-				WRITE_LCD_CBUS_REG(pin_reg, (READ_LCD_CBUS_REG(pin_reg) | (gpio_tcon_set[gpio_tcon[i]][1])));
-				i++;
-			}
-		}
- 	}
-#endif
 	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
 }
 
@@ -596,6 +413,8 @@ static void lcd_ports_ctrl(Bool_t status)
         case LCD_DIGITAL_MIPI:
             lcd_ports_ctrl_mipi(status);
             break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         case LCD_DIGITAL_EDP:
             lcd_ports_ctrl_edp(status);
             break;
@@ -635,7 +454,8 @@ static void backlight_power_ctrl(Bool_t status)
 
 static void set_control_mipi(Lcd_Config_t *pConf);
 static int set_control_edp(Lcd_Config_t *pConf);
-static int lcd_power_ctrl_video(Bool_t status) //for special interface
+//for special interface
+static int lcd_power_ctrl_video(Bool_t status)
 {
     int ret = 0;
 
@@ -645,6 +465,8 @@ static int lcd_power_ctrl_video(Bool_t status) //for special interface
             case LCD_DIGITAL_MIPI:
                 set_control_mipi(pDev->pConf);
                 break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
             case LCD_DIGITAL_EDP:
                 ret = set_control_edp(pDev->pConf);
                 break;
@@ -659,6 +481,8 @@ static int lcd_power_ctrl_video(Bool_t status) //for special interface
             case LCD_DIGITAL_MIPI:
                 mipi_dsi_link_off(pDev->pConf);  //link off command
                 break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
             case LCD_DIGITAL_EDP:
                 ret = dplpm_link_off();  //link off command
                 break;
@@ -859,7 +683,7 @@ static void write_tcon_double(MLVDS_Tcon_Config_t *mlvds_tcon)
             WRITE_LCD_REG(MTCON0_2ND_HE_ADDR, hend_2);
             WRITE_LCD_REG(MTCON0_2ND_VS_ADDR, vstart_2);
             WRITE_LCD_REG(MTCON0_2ND_VE_ADDR, vend_2);
-			WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STH1_SEL, 1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STH1_SEL, 1);
             break;
         case 1 :
             WRITE_LCD_REG(MTCON1_1ST_HS_ADDR, hstart_1);
@@ -870,7 +694,7 @@ static void write_tcon_double(MLVDS_Tcon_Config_t *mlvds_tcon)
             WRITE_LCD_REG(MTCON1_2ND_HE_ADDR, hend_2);
             WRITE_LCD_REG(MTCON1_2ND_VS_ADDR, vstart_2);
             WRITE_LCD_REG(MTCON1_2ND_VE_ADDR, vend_2);
-			WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_CPV1_SEL, 1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_CPV1_SEL, 1);
             break;
         case 2 :
             WRITE_LCD_REG(MTCON2_1ST_HS_ADDR, hstart_1);
@@ -881,7 +705,7 @@ static void write_tcon_double(MLVDS_Tcon_Config_t *mlvds_tcon)
             WRITE_LCD_REG(MTCON2_2ND_HE_ADDR, hend_2);
             WRITE_LCD_REG(MTCON2_2ND_VS_ADDR, vstart_2);
             WRITE_LCD_REG(MTCON2_2ND_VE_ADDR, vend_2);
-			WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STV1_SEL, 1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STV1_SEL, 1);
             break;
         case 3 :
             WRITE_LCD_REG(MTCON3_1ST_HS_ADDR, hstart_1);
@@ -892,35 +716,35 @@ static void write_tcon_double(MLVDS_Tcon_Config_t *mlvds_tcon)
             WRITE_LCD_REG(MTCON3_2ND_HE_ADDR, hend_2);
             WRITE_LCD_REG(MTCON3_2ND_VS_ADDR, vstart_2);
             WRITE_LCD_REG(MTCON3_2ND_VE_ADDR, vend_2);
-			WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEV1_SEL, 1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEV1_SEL, 1);
             break;
         case 4 :
             WRITE_LCD_REG(MTCON4_1ST_HS_ADDR, hstart_1);
             WRITE_LCD_REG(MTCON4_1ST_HE_ADDR, hend_1);
             WRITE_LCD_REG(MTCON4_1ST_VS_ADDR, vstart_1);
             WRITE_LCD_REG(MTCON4_1ST_VE_ADDR, vend_1);
-			WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STH2_SEL, 1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STH2_SEL, 1);
             break;
         case 5 :
             WRITE_LCD_REG(MTCON5_1ST_HS_ADDR, hstart_1);
             WRITE_LCD_REG(MTCON5_1ST_HE_ADDR, hend_1);
             WRITE_LCD_REG(MTCON5_1ST_VS_ADDR, vstart_1);
             WRITE_LCD_REG(MTCON5_1ST_VE_ADDR, vend_1);
-			WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_CPV2_SEL, 1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_CPV2_SEL, 1);
             break;
         case 6 :
             WRITE_LCD_REG(MTCON6_1ST_HS_ADDR, hstart_1);
             WRITE_LCD_REG(MTCON6_1ST_HE_ADDR, hend_1);
             WRITE_LCD_REG(MTCON6_1ST_VS_ADDR, vstart_1);
             WRITE_LCD_REG(MTCON6_1ST_VE_ADDR, vend_1);
-			WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEH_SEL, 1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEH_SEL, 1);
             break;
         case 7 :
             WRITE_LCD_REG(MTCON7_1ST_HS_ADDR, hstart_1);
             WRITE_LCD_REG(MTCON7_1ST_HE_ADDR, hend_1);
             WRITE_LCD_REG(MTCON7_1ST_VS_ADDR, vstart_1);
             WRITE_LCD_REG(MTCON7_1ST_VE_ADDR, vend_1);
-			WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEV3_SEL, 1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEV3_SEL, 1);
             break;
         default:
             break;
@@ -1058,7 +882,7 @@ static void set_tcon_ttl(Lcd_Config_t *pConf)
 	else
 		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
 }
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)||(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 static void set_tcon_ttl(Lcd_Config_t *pConf)
 {
 	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
@@ -1363,20 +1187,21 @@ static void vclk_set_lcd(int lcd_type, int vclk_sel, unsigned long pll_reg, unsi
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 	pll_level = 0;
 	pll_frac = 0;
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)|| (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 	pll_level = (clk_ctrl_reg >> CLK_CTRL_LEVEL) & 0x7;
 	pll_frac = (clk_ctrl_reg >> CLK_CTRL_FRAC) & 0xfff;
 	ss_level = (clk_ctrl_reg >> CLK_CTRL_SS) & 0xf;
 	pll_reg |= (1 << PLL_CTRL_EN);
 #endif
+	
 	if(vclk_sel)
 		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 19, 1);	//disable vclk2_en 
 	else
 		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 0, 19, 2);	//disable vclk1_en1,en0
 	udelay(2);
 
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
-	WRITE_LCD_CBUS_REG(HHI_EDP_TX_PHY_CNTL0, (1 << 16));	//reset edp tx phy	
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+	WRITE_LCD_CBUS_REG(HHI_EDP_TX_PHY_CNTL0, (1 << 16));	//reset edp tx phy
 #endif
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
@@ -1449,6 +1274,7 @@ static void vclk_set_lcd(int lcd_type, int vclk_sel, unsigned long pll_reg, unsi
 	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL5, (0x00700001 | (od_fb << 8)));	//[8] od_fb
 	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL, pll_reg | (1 << PLL_CTRL_RST));
 	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL, pll_reg);
+	
 	do{
 		udelay(50);
 		pll_lock = (READ_LCD_CBUS_REG(HHI_VID2_PLL_CNTL) >> PLL_CTRL_LOCK) & 0x1;
@@ -1466,13 +1292,69 @@ static void vclk_set_lcd(int lcd_type, int vclk_sel, unsigned long pll_reg, unsi
 	if (wait_loop == 0)
 		printk("[error]: vid2_pll lock failed\n");
 #elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-		do{
+	if (pll_frac == 0)
+		pll_ctrl2 = 0x59c88000;
+	else
+		pll_ctrl2 = (0x59c8c000 | pll_frac);
+	
+	pll_ctrl4 = (0x00238100 & ~((1<<9) | (0xf<<4) | (0xf<<0)));
+	switch (ss_level) {
+		case 1:	//0.5%
+			pll_ctrl4 |= ((1<<9) | (2<<4) | (1<<0));
+			break;
+		case 2:	//1%
+			pll_ctrl4 |= ((1<<9) | (1<<4) | (1<<0));
+			break;
+		case 3:	//1.5%
+			pll_ctrl4 |= ((1<<9) | (8<<4) | (1<<0));
+			break;
+		case 4: //2%
+			pll_ctrl4 |= ((1<<9) | (0<<4) | (1<<0));
+			break;
+		case 0:
+		default:
+			ss_level = 0;
+			break;
+	}
+	
+	switch (pll_level) {
+		case 1: //<=1.7G
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca49b022;
+			od_fb = 0;
+			break;
+		case 2: //1.7G~2.0G
+			pll_ctrl2 |= (1<<13);//special adjust
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca493822;
+			od_fb = 1;
+			break;
+		case 3: //2.0G~2.5G
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca493822;
+			od_fb = 1;
+			break;
+		case 4: //>=2.5G
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xce49c022;
+			od_fb = 1;
+			break;
+		default:
+			pll_ctrl3 = 0xca7e3823;
+			od_fb = 0;
+			break;
+	}
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL2, 1, 16, 1);//enable ext LDO
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL2, pll_ctrl2);
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL3, pll_ctrl3);
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL4, (pll_ctrl4 | (od_fb << 24))); //[24] od_fb
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL5, 0x00012385);
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL, pll_reg | (1 << PLL_CTRL_RST));
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL, pll_reg);
+	
+	do{
 		udelay(50);
-		pll_lock = (READ_LCD_CBUS_REG(HHI_VID_PLL_CNTL) >> 31) & 0x1;
+		pll_lock = (READ_LCD_CBUS_REG(HHI_VID_PLL_CNTL) >> PLL_CTRL_LOCK) & 0x1;
 		if (wait_loop == 100) {
 			if (pll_level == 2) {
 				//change setting if can't lock
-				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL2, 1, 18, 1);
+				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL2, 1, 12, 1);
 				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 1, PLL_CTRL_RST, 1);
 				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, PLL_CTRL_RST, 1);
 				printk("change setting for vid pll stability\n");
@@ -1481,17 +1363,10 @@ static void vclk_set_lcd(int lcd_type, int vclk_sel, unsigned long pll_reg, unsi
 		wait_loop--;
 	}while((pll_lock == 0) && (wait_loop > 0));
 	if (wait_loop == 0)
-		printk("[error]: vid_pll lock failed\n");	
-	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL5, 1, 16, 1);//enable bandgap
-	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL2, 0x69c88000);
-    WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL3, 0xca563823);
-    WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL4, (0x23b100|(od_fb<<24)));
-    WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL5, 0x00012385);
-    WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL2, 0x430a800);       // internal LDO share with HPLL & VIID PLL
-	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL, pll_reg);		
+		printk("[error]: vid_pll lock failed\n");
 #endif
 
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	//select logic & encl clock
 	switch (lcd_type) {
 		case LCD_DIGITAL_MIPI:
@@ -1512,11 +1387,7 @@ static void vclk_set_lcd(int lcd_type, int vclk_sel, unsigned long pll_reg, unsi
 		case LCD_DIGITAL_LVDS:
 		case LCD_DIGITAL_TTL:
 		default:
-		#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 			WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 2, 23, 3);	//pll_out mux to vid2_pll
-		#elif(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-			WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL5, 2, 23, 3);	//pll_out mux to vid2_pll
-		#endif
 			WRITE_LCD_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 0, 4, 1);
 			break;
 	}
@@ -1563,7 +1434,7 @@ static void vclk_set_lcd(int lcd_type, int vclk_sel, unsigned long pll_reg, unsi
 		else
 			WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 0, 12, 4); // [23:20] encl_clk_sel, select v1_clk_div1
 	}
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)||(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8))
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 	if (vclk_sel) {
 		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 8, 12, 4); // [15:12] encl_clk_sel, select vclk2_div1
 		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 1, 16, 2); // release vclk2_div_reset and enable vclk2_div
@@ -1589,6 +1460,10 @@ static void vclk_set_lcd(int lcd_type, int vclk_sel, unsigned long pll_reg, unsi
 	}
 	udelay(5);
 	
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 1, 3, 1);	//enable encl clk gate //new add for M8b
+#endif
+	
 	spin_unlock_irqrestore(&lcd_clk_lock, flags);
 }
 
@@ -1607,7 +1482,7 @@ static void clk_util_lvds_set_clk_div(unsigned long divn_sel, unsigned long divn
 	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, divn_sel, 7, 2);
 	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, div2_en, 9, 1);
 	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, ((divn_tcnt-1)&0x7), 4, 3);
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 	// ---------------------------------------------
     // Configure the LVDS PHY
     // ---------------------------------------------
@@ -1650,6 +1525,8 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
 #if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
         case LCD_DIGITAL_MIPI:
             break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         case LCD_DIGITAL_EDP:
             xd = 1;
             break;
@@ -1680,8 +1557,6 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
             WRITE_LCD_REG(MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) & 0xfffffff0) );     // Release mipi_dsi_host's reset
             WRITE_LCD_REG(MIPI_DSI_TOP_CLK_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CLK_CNTL) | 0x3) );            // Enable dwc mipi_dsi_host's clock 
             break;
-        case LCD_DIGITAL_EDP:
-            break;
 #endif
         case LCD_DIGITAL_LVDS:
             clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
@@ -2080,7 +1955,9 @@ static void set_control_mipi(Lcd_Config_t *pConf)
 {
     set_mipi_dsi_control(pConf);
 }
+#endif
 
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 //**************************************************//
 // for edp link maintain control
 //**************************************************//
@@ -2431,7 +2308,7 @@ static void init_phy_lvds(Lcd_Config_t *pConf)
     WRITE_LCD_REG(LVDS_PHY_CNTL6,0xcccc);
     WRITE_LCD_REG(LVDS_PHY_CNTL7,0xcccc);
     WRITE_LCD_REG(LVDS_PHY_CNTL8,0xcccc);
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 	WRITE_LCD_REG(LVDS_SER_EN, 0xfff);	//Enable the serializers
 
     WRITE_LCD_REG(LVDS_PHY_CNTL0, 0xffff);
@@ -2474,7 +2351,9 @@ static void init_phy_mipi(Lcd_Config_t *pConf)
     WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, (0x3e << 16) | (0xa5b8 << 0));//DIF_REF_CTL2:31-16bit, DIF_REF_CTL1:15-0bit
     WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, (0x26e0 << 16) | (0x459 << 0));//DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit
 }
+#endif
 
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 static void init_phy_edp(Lcd_Config_t *pConf)
 {
     unsigned swing_ctrl;
@@ -2514,6 +2393,8 @@ static void init_dphy(Lcd_Config_t *pConf)
 			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
 			init_phy_mipi(pConf);
 			break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_EDP:
 			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
 			init_phy_edp(pConf);
@@ -2592,6 +2473,8 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
             dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
             iflogic_vid_clk_in_max = MIPI_MAX_VID_CLK_IN;
             break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         case LCD_DIGITAL_EDP:
             div_pre_sel_max = 1;
             div_post = 1;
@@ -2690,6 +2573,8 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
                 }
             }
             break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         case LCD_DIGITAL_EDP:
             switch (pConf->lcd_control.edp_config->link_rate) {
                 case 0:
@@ -2797,7 +2682,7 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
                     }
                 }
             }
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
             if (fout < LCD_VENC_MAX_CLK_IN) {
                 for (xd = 1; xd <= crt_xd_max; xd++) {
                     div_post_out = fout * xd;
@@ -2840,7 +2725,7 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
                                             pll_od = od_sel - 1;
                                             vid_div_pre = pre_div_sel;
                                             crt_xd = xd;
-											DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
+                                            DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
                                                        pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
                                             clk_num = 1;
                                         }
@@ -2863,11 +2748,7 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
             break;
     }
     if (clk_num > 0) {
-    	#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)||(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8))
-       		pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
-       	#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-       		pConf->lcd_timing.pll_ctrl = (pll_od << 16) | (pll_n << 10) | (pll_m << 0);
-       	#endif
+        pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
         pConf->lcd_timing.div_ctrl = 0x18803 | (edp_phy_div1 << DIV_CTRL_EDP_DIV1) | (edp_phy_div0 << DIV_CTRL_EDP_DIV0) | (vid_div_pre << DIV_CTRL_DIV_PRE);
         tmp = (pConf->lcd_timing.clk_ctrl & ~((0xf << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
         pConf->lcd_timing.clk_ctrl = (tmp | ((crt_xd << CLK_CTRL_XD) | (pll_level << CLK_CTRL_LEVEL) | (pll_frac << CLK_CTRL_FRAC)));
@@ -2876,16 +2757,11 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
         pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (32 << PLL_CTRL_M);
         pConf->lcd_timing.div_ctrl = 0x18803;
-        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
         pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (50 << PLL_CTRL_M);
         pConf->lcd_timing.div_ctrl = 0x18803 | (0 << DIV_CTRL_EDP_DIV1) | (0 << DIV_CTRL_EDP_DIV0) | (1 << DIV_CTRL_DIV_PRE);
+#endif
         pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-		pConf->lcd_timing.pll_ctrl =0x30438;
-		pConf->lcd_timing.div_ctrl =0x18833;
-        pConf->lcd_timing.clk_ctrl =0x8eee1101; 
-#endif        
         printk("Out of clock range, reset to default setting!\n");
     }
 }
@@ -2903,7 +2779,7 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 	frac = 0;
 	od_fb = 0;
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 	frac = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_FRAC) & 0xfff;
 	od_fb = ((((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_LEVEL) & 0x7) > 1) ? 1 : 0;
 
@@ -2922,6 +2798,8 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
 			post_div = 1;
 			break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_EDP:
 			edp_div0 = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_EDP_DIV0) & 0xf;
 			edp_div1 = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_EDP_DIV1) & 0x7;
@@ -2974,6 +2852,8 @@ static void lcd_tcon_config(Lcd_Config_t *pConf)
 		case LCD_DIGITAL_MIPI:
 			h_delay = MIPI_DELAY;
 			break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_EDP:
 			h_delay = EDP_DELAY;
 			break;
@@ -3071,7 +2951,7 @@ static void lcd_tcon_config(Lcd_Config_t *pConf)
 	DBG_PRINT("oeh_hs_addr=%d, oeh_he_addr=%d, oeh_vs_addr=%d, oeh_ve_addr=%d\n", pConf->lcd_timing.oeh_hs_addr, pConf->lcd_timing.oeh_he_addr, pConf->lcd_timing.oeh_vs_addr, pConf->lcd_timing.oeh_ve_addr);
 }
 
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 static void select_edp_link_config(Lcd_Config_t *pConf)
 {
     unsigned bit_rate;
@@ -3131,7 +3011,7 @@ static void select_edp_link_config(Lcd_Config_t *pConf)
 }
 #endif
 
-static void lcd_control_config_pre(Lcd_Config_t *pConf) //before generate_clk_parameter
+static void lcd_control_config_pre(Lcd_Config_t *pConf)
 {
     unsigned vclk_sel, ss_level;
 
@@ -3144,6 +3024,8 @@ static void lcd_control_config_pre(Lcd_Config_t *pConf) //before generate_clk_pa
             ss_level = ((ss_level > 0) ? 1 : 0);
             set_mipi_dsi_control_config(pConf);
             break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         case LCD_DIGITAL_EDP:
             ss_level = ((ss_level > 0) ? 1 : 0);
             select_edp_link_config(pConf);
@@ -3163,11 +3045,15 @@ static void lcd_control_config_pre(Lcd_Config_t *pConf) //before generate_clk_pa
                     pConf->lcd_control.lvds_config->lvds_repack = 1;
             }
             break;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-        case LCD_DIGITAL_MINILVDS:
+        case LCD_DIGITAL_TTL:
             ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
-            break;
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
+            if (pConf->lcd_basic.lcd_bits != 6) {
+                pConf->lcd_basic.lcd_bits = 6;
+                printk("lcd change to 6bit for ttl support!\n");
+            }
 #endif
+            break;
         default:
             ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
             break;
@@ -3176,15 +3062,14 @@ static void lcd_control_config_pre(Lcd_Config_t *pConf) //before generate_clk_pa
     pConf->lcd_timing.clk_ctrl |= ((vclk_sel << CLK_CTRL_VCLK_SEL) | (ss_level << CLK_CTRL_SS));
 }
 
-static void lcd_control_config_post(Lcd_Config_t *pConf) //after generate_clk_parameter
+//for special interface config after clk setting
+static void lcd_control_config_post(Lcd_Config_t *pConf)
 {
     switch (pConf->lcd_basic.lcd_type) {
 #if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
         case LCD_DIGITAL_MIPI:
             set_mipi_dsi_control_config_post(pConf);
             break;
-        case LCD_DIGITAL_EDP:
-            break;
 #endif
         default:
             break;
@@ -3228,7 +3113,7 @@ static void switch_lcd_gates(Lcd_Type_t lcd_type)
 			break;
 	}
 }
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 static void switch_lcd_gates(unsigned int state)
 {
 	if (state > 0) {
@@ -3245,23 +3130,21 @@ static void switch_lcd_gates(unsigned int state)
 }
 #endif
 
-static void _init_lcd_driver(Lcd_Config_t *pConf)	//before power on lcd
-{ 
+static void _init_lcd_driver(Lcd_Config_t *pConf)
+{
     int lcd_type = pConf->lcd_basic.lcd_type;
     unsigned char ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
 
     printk("lcd driver version: %s%s\n\n", DRIVER_DATE, DRV_TYPE);
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
     switch_lcd_gates(lcd_type);
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
     switch_vpu_mem_pd_vmod(pDev->lcd_info.mode, VPU_MEM_POWER_ON);
     //switch_lcd_gates(ON);
     switch_lcd_mod_gate(ON);
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)   
-	printk("don't control vpu\n");
 #endif
 
-    printk("Init LCD mode: %s(%u) %ubit, %ux%u@%u.%uHz, ss_level=%u(%s)\n", lcd_type_table[lcd_type], lcd_type, pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10), ss_level, lcd_ss_level_table[ss_level]);
+    printk("Init LCD mode: %s, %s(%u) %ubit, %ux%u@%u.%uHz, ss_level=%u(%s)\n", pConf->lcd_basic.model_name, lcd_type_table[lcd_type], lcd_type, pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10), ss_level, lcd_ss_level_table[ss_level]);
 
     switch(lcd_type){
 #if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
@@ -3271,6 +3154,8 @@ static void _init_lcd_driver(Lcd_Config_t *pConf)	//before power on lcd
             set_tcon_lcd(pConf);
             init_dphy(pConf);
             break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         case LCD_DIGITAL_EDP:
             set_pll_lcd(pConf);
             set_venc_lcd(pConf);
@@ -3289,7 +3174,7 @@ static void _init_lcd_driver(Lcd_Config_t *pConf)	//before power on lcd
             set_pll_lcd(pConf);
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
             set_venc_ttl(pConf);
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
             set_venc_lcd(pConf);
 #endif
             set_tcon_ttl(pConf);
@@ -3312,7 +3197,7 @@ static void _init_lcd_driver(Lcd_Config_t *pConf)	//before power on lcd
     printk("%s finished.\n", __FUNCTION__);
 }
 
-static void _disable_lcd_driver(Lcd_Config_t *pConf)	//after power off lcd
+static void _disable_lcd_driver(Lcd_Config_t *pConf)
 {
     int vclk_sel;
 
@@ -3321,6 +3206,8 @@ static void _disable_lcd_driver(Lcd_Config_t *pConf)	//after power off lcd
         case LCD_DIGITAL_MIPI:
             mipi_dsi_off();
             break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         case LCD_DIGITAL_EDP:
             dplpm_off();
             break;
@@ -3349,19 +3236,21 @@ static void _disable_lcd_driver(Lcd_Config_t *pConf)	//after power off lcd
 
     WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 16, 1);	//close vid2_pll gate: 0x104c[16]
 
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
     WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 0, 23, 3);	//disable pll_out mux
 #endif
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
     WRITE_LCD_CBUS_REG_BITS(HHI_VIID_PLL_CNTL, 1, 30, 1);		//power down vid2_pll: 0x1047[30]
 #elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
     WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0, 30, 1);		//disable vid2_pll: 0x10e0[30]
+#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
+    WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, 30, 1);		//disable vid_pll: 0x10c8[30]
 #endif
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
     switch_mod_gate_by_name("tcon", 0);
     switch_mod_gate_by_name("lvds", 0);
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
     //switch_lcd_gates(OFF);
     switch_lcd_mod_gate(OFF);
     switch_vpu_mem_pd_vmod(pDev->lcd_info.mode, VPU_MEM_POWER_DOWN);
@@ -3371,18 +3260,18 @@ static void _disable_lcd_driver(Lcd_Config_t *pConf)	//after power off lcd
 
 static inline void _enable_vsync_interrupt(void)
 {
-//#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-//	if ((READ_LCD_REG(ENCT_VIDEO_EN) & 1) || (READ_LCD_REG(ENCL_VIDEO_EN) & 1)) {
-//#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-//	if (READ_LCD_REG(ENCL_VIDEO_EN) & 1) {
-//#endif
-//		WRITE_LCD_REG(VENC_INTCTRL, 0x200);
-//	}
-//	else{
-//		WRITE_LCD_REG(VENC_INTCTRL, 0x2);
-//	}
-//}
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
+	if ((READ_LCD_REG(ENCT_VIDEO_EN) & 1) || (READ_LCD_REG(ENCL_VIDEO_EN) & 1)) {
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+	if (READ_LCD_REG(ENCL_VIDEO_EN) & 1) {
+#endif
+		WRITE_LCD_REG(VENC_INTCTRL, 0x200);
+	}
+	else{
+		WRITE_LCD_REG(VENC_INTCTRL, 0x2);
+	}
 }
+
 void _enable_backlight(void)
 {
 	backlight_power_ctrl(ON);
@@ -3402,7 +3291,7 @@ static void _lcd_module_enable(void)
 
 	_init_lcd_driver(pDev->pConf);
 	ret = lcd_power_ctrl(ON);
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
 		if (ret > 0) {
 			lcd_power_ctrl(OFF);
@@ -3425,18 +3314,19 @@ static void _lcd_module_disable(void)
 	lcd_status_flag = 0;
 	BUG_ON(pDev==NULL);
 	data_status = OFF;
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)||	(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8))
 	lcd_power_ctrl(OFF);
 	_disable_lcd_driver(pDev->pConf);
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-	;
-#endif
 	mutex_unlock(&lcd_init_mutex);
 }
 
 static const vinfo_t *lcd_get_current_info(void)
 {
-    return &pDev->lcd_info;
+    if (pDev == NULL) {
+        printk("[error] no lcd device exist!\n");
+        return NULL;
+    }
+    else 
+        return &pDev->lcd_info;
 }
 
 static DEFINE_MUTEX(lcd_vout_mutex);
@@ -3693,7 +3583,7 @@ static void write_gamma_table(void)
         set_gamma_table_lcd(pDev->pConf->lcd_effect.GammaTableB, LCD_H_SEL_B, pDev->pConf->lcd_effect.gamma_b_coeff);
         WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 1, 1, 1);
     }
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 	WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 0, 1, 1);
 	set_gamma_table_lcd(pDev->pConf->lcd_effect.GammaTableR, LCD_H_SEL_R, pDev->pConf->lcd_effect.gamma_r_coeff);
 	set_gamma_table_lcd(pDev->pConf->lcd_effect.GammaTableG, LCD_H_SEL_G, pDev->pConf->lcd_effect.gamma_g_coeff);
@@ -3836,7 +3726,7 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
             for (j=0; j<256; j++) {
                 pDev->pConf->lcd_effect.GammaTableR[j] = i<<2;
             }
-			set_gamma_coeff(100, 0, 0);
+            set_gamma_coeff(100, 0, 0);
             printk("with R fixed value %u finished.\n", i);
         }
         else if (buf[1] == 'g') {
@@ -3906,6 +3796,8 @@ static int temp_lvds_repack, temp_pn_swap, temp_lvds_vswing;
 #if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 static unsigned char temp_dsi_lane_num;
 static unsigned temp_dsi_bit_rate_min, temp_dsi_bit_rate_max, temp_factor_denominator, temp_factor_numerator;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 static unsigned char temp_edp_link_rate, temp_edp_lane_count, temp_edp_vswing, temp_edp_preemphasis;
 #endif
 static unsigned short last_h_active, last_v_active;
@@ -3927,9 +3819,11 @@ static const char * lcd_usage_str =
 "    echo ttl <rb_swap> <bit_swap> > debug ; write ttl RGB swap config\n"
 "    echo lvds <vswing_level> <lvds_repack> <pn_swap> > debug ; write lvds config\n"
 #if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
-"    echo edp <link_rate> <lane_count> <vswing_level> > debug ; write edp config\n"
 "    echo mdsi <bit_rate_min> <bit_rate_max> <factor> > debug ; write mipi-dsi config\n"
 #endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+"    echo edp <link_rate> <lane_count> <vswing_level> > debug ; write edp config\n"
+#endif
 "\n"
 "data format:\n"
 "    <xx_swap>      : 0=normal, 1=swap\n"
@@ -3937,9 +3831,11 @@ static const char * lcd_usage_str =
 "    <lvds_repack>  : 0=JEIDA mode, 1=VESA mode\n"
 "    <pn_swap>      : 0=normal, 1=swap lvds p/n channels\n"
 #if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
-"    <link_rate>    : 0=1.62G, 1=2.7G\n"
 "    <bit_rate_xxx> : unit in MHz\n"
 #endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+"    <link_rate>    : 0=1.62G, 1=2.7G\n"
+#endif
 "\n"
 "    echo offset <h_sign> <h_offset> <v_sign> <v_offset> > debug ; write ttl display offset\n"
 "    echo dither <dither_user> <dither_ctrl> > debug ; write user dither ctrl config\n"
@@ -3976,11 +3872,12 @@ static void read_current_lcd_config(Lcd_Config_t *pConf)
     v_adj = ((pConf->lcd_timing.v_offset >> 31) & 1);
 
     printk("lcd driver version: %s%s\n\n", DRIVER_DATE, DRV_TYPE);
-    printk("LCD mode: %s %ubit, %ux%u@%u.%uHz\n"
+    printk("LCD mode: %s, %s %ubit, %ux%u@%u.%uHz\n"
            "lcd_clk           %u.%03uMHz\n"
            "ss_level          %d\n"
            "clk_pol           %d\n\n",
-           lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10),
+           pConf->lcd_basic.model_name, lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active,
+           (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10),
            (lcd_clk / 1000), (lcd_clk % 1000), ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf), ((pConf->lcd_timing.pol_cntl_addr >> LCD_CPH1_POL) & 1));
 
     printk("h_period          %d\n"
@@ -4026,6 +3923,8 @@ static void read_current_lcd_config(Lcd_Config_t *pConf)
                    ((pDev->pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1), (((pDev->pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1) ? "COMMAND" : "VIDEO"),
                    ((pDev->pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_CLK) & 1), ((pDev->pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_SWITCH) & 3));
             break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
         case LCD_DIGITAL_EDP:
             printk("link_rate         %s\n"
                    "lane_count        %u\n"
@@ -4110,6 +4009,8 @@ static void save_lcd_config(Lcd_Config_t *pConf)
 			temp_factor_denominator = pConf->lcd_control.mipi_config->factor_denominator;
 			temp_factor_numerator = pConf->lcd_control.mipi_config->factor_numerator;
 			break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_EDP:
 			temp_edp_link_rate = pConf->lcd_control.edp_config->link_rate;
 			temp_edp_lane_count = pConf->lcd_control.edp_config->lane_count;
@@ -4126,7 +4027,7 @@ static void save_lcd_config(Lcd_Config_t *pConf)
 			temp_ttl_rb_swap = pConf->lcd_control.ttl_config->rb_swap;
 			temp_ttl_bit_swap = pConf->lcd_control.ttl_config->bit_swap;
 			break;
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 		case LCD_DIGITAL_MINILVDS:
 			break;
 #endif
@@ -4192,6 +4093,8 @@ static void reset_lcd_config(Lcd_Config_t *pConf)
 			pConf->lcd_control.mipi_config->factor_denominator = temp_factor_denominator;
 			pConf->lcd_control.mipi_config->factor_numerator = temp_factor_numerator;
 			break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_EDP:
 			//restore edp link config, for they are translate from user value to reg value
 			pConf->lcd_control.edp_config->link_rate = temp_edp_link_rate;
@@ -4209,7 +4112,7 @@ static void reset_lcd_config(Lcd_Config_t *pConf)
 			pConf->lcd_control.ttl_config->rb_swap = temp_ttl_rb_swap;
 			pConf->lcd_control.ttl_config->bit_swap = temp_ttl_bit_swap;
 			break;
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 		case LCD_DIGITAL_MINILVDS:
 			break;
 #endif
@@ -4280,7 +4183,7 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 					venc_video_mode = ENCL_VIDEO_MODE_ADV;
 					venc_test_base = ENCL_TST_EN;
 				}
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
+#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 				venc_video_mode = ENCL_VIDEO_MODE_ADV;
 				venc_test_base = ENCL_TST_EN;
 #endif				
@@ -4449,7 +4352,7 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 				lcd_power_ctrl(ON);
 				_enable_backlight();
 			}
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 			else if (buf[1] == 'd') {
 				t[0] = 1;
 				t[1] = 4;
@@ -4566,9 +4469,11 @@ static inline int _get_lcd_model_timing(struct platform_device *pdev)
 		lcd_model_node = of_find_node_by_phandle(fhandle);
 		ret = of_property_read_string(lcd_model_node,"model_name", &str);
 		if(ret) {
+			pDev->pConf->lcd_basic.model_name = "none";
 			printk("lcd: faild to get lcd_model_name!\n");
 		}
 		else {
+			pDev->pConf->lcd_basic.model_name = str;
 			printk("load lcd model in dtb: %s\n", str);
 		}
 		ret = of_property_read_string(lcd_model_node, "interface", &str);
@@ -5015,7 +4920,7 @@ static inline int _get_lcd_default_config(struct platform_device *pdev)
 				DBG_PRINT("lvds_repack_user = %u, lvds_repack = %u\n", pDev->pConf->lcd_control.lvds_config->lvds_repack_user, pDev->pConf->lcd_control.lvds_config->lvds_repack);
 			}
 		}
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		ret = of_property_read_u32_array(pdev->dev.of_node,"edp_user_link_rate_lane_count",&lcd_para[0], 3);
 		if(ret){
 			pDev->pConf->lcd_control.edp_config->link_user = 0;
@@ -5173,7 +5078,7 @@ static inline int _get_lcd_power_config(struct platform_device *pdev)
 			else if ((strcasecmp(str, "null") == 0) || ((strcasecmp(str, "n") == 0))) {
 				break;
 			}
-			else {	
+			else {
 				DBG_PRINT("%s 0: %s\n", propname, str);
 				for(index = 0; index < LCD_POWER_TYPE_MAX; index++) {
 					if(!strcasecmp(str, lcd_power_type_table[index]))
@@ -5186,7 +5091,7 @@ static inline int _get_lcd_power_config(struct platform_device *pdev)
 					if (ret) {
 						printk("faild to get %s index 1\n", propname);
 					}
-					else {					
+					else {
 						if (pDev->pConf->lcd_power_ctrl.power_off_config[i].type == LCD_POWER_TYPE_CPU) {
 							val = amlogic_gpio_name_map_num(str);
 							pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio = val;
@@ -5199,7 +5104,7 @@ static inline int _get_lcd_power_config(struct platform_device *pdev)
 					if (ret) {
 						printk("faild to get %s index 2\n", propname);
 					}
-					else {					
+					else {
 						if ((strcasecmp(str, "output_low") == 0) || (strcasecmp(str, "0") == 0)) {
 							pDev->pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_OUTPUT_LOW;
 						}
@@ -5329,18 +5234,22 @@ static int lcd_probe(struct platform_device *pdev)
 		printk("class register aml_gamma_class fail!\n");
 	}
 #endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+
 	switch (pDev->pConf->lcd_basic.lcd_type) {
+#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 		case LCD_DIGITAL_MIPI :
 			dsi_probe(pDev->pConf);
 			break;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 		case LCD_DIGITAL_EDP :
 			edp_probe();
 			break;
+#endif
 		default:
 			break;
     }
-#endif
+
 	printk("LCD probe ok\n");
 
 	return 0;
diff --git a/include/linux/amlogic/vout/lcdoutc.h b/include/linux/amlogic/vout/lcdoutc.h
index a69801d41dfd..53b1aec4af21 100755
--- a/include/linux/amlogic/vout/lcdoutc.h
+++ b/include/linux/amlogic/vout/lcdoutc.h
@@ -139,10 +139,14 @@
 	#define PLL_CTRL_PD				30
 	#define PLL_CTRL_OD				16	//[17:16]
 	#define PLL_CTRL_N				9	//[13:9]
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
+#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	#define PLL_CTRL_EN				30
 	#define PLL_CTRL_OD				9	//[10:9]
 	#define PLL_CTRL_N				24	//[28:24]
+#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
+	#define PLL_CTRL_EN				30
+	#define PLL_CTRL_OD				16	//[17:16]
+	#define PLL_CTRL_N				10	//[14:10]
 #endif
 	#define PLL_CTRL_M				0	//[8:0]
 
@@ -256,7 +260,7 @@ static const char* lcd_power_type_table[]={
 	"pmu",
 	"signal",
 	"init",
-	"null"
+	"null",
 };
 
 static const char* lcd_power_pmu_gpio_table[]={
@@ -265,7 +269,7 @@ static const char* lcd_power_pmu_gpio_table[]={
 	"GPIO2",
 	"GPIO3",
 	"GPIO4",
-	"null"
+	"null",
 }; 
 
 typedef enum
@@ -464,7 +468,8 @@ typedef struct DSI_Config_s{
     unsigned char *dsi_init_off;
     unsigned char lcd_extern_init;
 }DSI_Config_t;
-
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 typedef struct {
 	unsigned char link_user;
 	unsigned char lane_count;
@@ -491,6 +496,8 @@ typedef struct {
 typedef struct {
 #if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
 	DSI_Config_t *mipi_config;
+#endif
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	EDP_Config_t *edp_config;
 #endif
 	LVDS_Config_t *lvds_config;
-- 
2.19.0

