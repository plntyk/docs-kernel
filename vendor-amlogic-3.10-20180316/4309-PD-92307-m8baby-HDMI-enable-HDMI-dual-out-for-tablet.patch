From 4c08fa7a7835a541d4f1fdc75489714ab2c756f6 Mon Sep 17 00:00:00 2001
From: "wei.nie" <wei.nie@amlogic.com>
Date: Mon, 9 Jun 2014 14:00:16 +0800
Subject: [PATCH 4309/5965] PD#92307:m8baby:HDMI:enable HDMI dual out for
 tablet project

Squashed commit of the following:

commit ac309a43348dd3b426783888651e37ac05b4037e
Author: wei.nie <wei.nie@amlogic.com>
Date:   Fri Jun 6 19:11:22 2014 +0800

    PD#92307:fix clk_gate problem

commit e2ed85d766291c604fb7ca6994fdfaa55c4831c5
Author: wei.nie <wei.nie@amlogic.com>
Date:   Fri Jun 6 13:39:18 2014 +0800

    PD#92307:Fix hdmi 480p can't display and clk_gate problem fix

commit 93114389d2b44cbeedd30b555edbbb5cfdf344c6
Author: wei.nie <wei.nie@amlogic.com>
Date:   Tue Jun 3 09:38:25 2014 +0800

    PD#92307:Fix M8baby only hdmi output
---
 arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd |   6 +-
 .../arm/mach-meson8/include/mach/power_gate.h |   2 +-
 arch/arm/mach-meson8/power_gate.c             |   2 +-
 .../mach-meson8b/include/mach/power_gate.h    |   4 +-
 arch/arm/mach-meson8b/power_gate.c            |   2 +-
 drivers/amlogic/display/osd/Makefile          |   2 +-
 drivers/amlogic/display/osd/osd_clone.c       | 206 +++++++++++++++++
 drivers/amlogic/display/osd/osd_clone.h       |  55 +++++
 drivers/amlogic/display/osd/osd_dev.c         |  25 +++
 drivers/amlogic/display/osd/osd_hw.c          | 133 ++++++++++-
 drivers/amlogic/display/osd/osd_hw_def.h      |   4 +-
 drivers/amlogic/display/osd/osd_main.c        | 208 ++++++++++++------
 drivers/amlogic/display/osd_ext/osd_clone.c   |  73 +++---
 drivers/amlogic/display/osd_ext/osd_clone.h   |  24 +-
 drivers/amlogic/display/osd_ext/osd_hw.c      |  32 +--
 drivers/amlogic/display/vout/tvoutc.c         |   3 +-
 drivers/amlogic/display/vout2/nulldisp.c      |   2 +-
 drivers/amlogic/display/vout2/tvconf2.c       |  19 +-
 drivers/amlogic/display/vout2/tvoutc2.c       |   2 +-
 drivers/amlogic/display/vout2/vout2_serve.c   |   5 +
 include/linux/amlogic/osd/osd_dev.h           |   5 +
 include/linux/amlogic/osd/osd_hw.h            |   5 +
 22 files changed, 665 insertions(+), 154 deletions(-)
 create mode 100755 drivers/amlogic/display/osd/osd_clone.c
 create mode 100755 drivers/amlogic/display/osd/osd_clone.h

diff --git a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
index 53937420df69..994b56db93c2 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
@@ -130,11 +130,12 @@ void root_func(){
 		compatible = "amlogic,mesonfb";
 		dev_name = "mesonfb";
 		status = "okay";
-        reserve-memory = <0x0900000  0x00100000>;//9M+1M=10M
+        reserve-memory = <0x0900000  0x0b00000>;//9M+1M=10M
 	   	reserve-iomap = "true";
         vmode = <1>; /**0:VMODE_720P 1:VMODE_LCD  2:VMODE_LVDS_1080P 3:VMODE_1080P*/
         display_size_default = <768 1024 768 3072 32>;//1024x768x4x3==0x0900000,9MB
 	};
+
 //$$ DEVICE = "mesonfb-ext"
 //$$ L2 PROP_STR = "status"
 //$$ L3 PROP_U32 4 ="reg"
@@ -145,8 +146,7 @@ void root_func(){
 		status = "ok";
 		need-memory = <0>; /*0:no need,1:need*/
 	   	reserve-iomap = "true";
-        display_size_default = <768 1024 768 3072 32>;//1024x768x4x3==0x0900000 < 0x01000000
-	 
+        display_size_default = <768 1024 768 3072 32>;//768x1024x4x3==0x0900000 < 0x01000000
 	};
 
 /// ***************************************************************************************
diff --git a/arch/arm/mach-meson8/include/mach/power_gate.h b/arch/arm/mach-meson8/include/mach/power_gate.h
index 999b0bf4570f..45dfceb02f77 100755
--- a/arch/arm/mach-meson8/include/mach/power_gate.h
+++ b/arch/arm/mach-meson8/include/mach/power_gate.h
@@ -852,7 +852,7 @@ extern spinlock_t gate_lock;
 #define GCLK_MASK_AO_REGS      (1<<3)
 
 #define GCLK_IDX_MAX 132
-extern unsigned char GCLK_ref[GCLK_IDX_MAX];
+extern short GCLK_ref[GCLK_IDX_MAX];
 
 #define REGISTER_CLK(_MOD) \
 static struct clk CLK_##_MOD = {            \
diff --git a/arch/arm/mach-meson8/power_gate.c b/arch/arm/mach-meson8/power_gate.c
index 92d432e7b7f8..958cbfa8534c 100755
--- a/arch/arm/mach-meson8/power_gate.c
+++ b/arch/arm/mach-meson8/power_gate.c
@@ -8,7 +8,7 @@
 #include <linux/err.h>
 #include <linux/hardirq.h>
 
-unsigned char GCLK_ref[GCLK_IDX_MAX];
+short GCLK_ref[GCLK_IDX_MAX];
 EXPORT_SYMBOL(GCLK_ref);
 
 //#define PRINT_DEBUG_INFO
diff --git a/arch/arm/mach-meson8b/include/mach/power_gate.h b/arch/arm/mach-meson8b/include/mach/power_gate.h
index f13f7de5bac1..eff430d5cfd5 100755
--- a/arch/arm/mach-meson8b/include/mach/power_gate.h
+++ b/arch/arm/mach-meson8b/include/mach/power_gate.h
@@ -17,7 +17,7 @@
 
 #define __CLK_GATE_OFF(_MOD) \
 	do{                             \
-		if(--GCLK_ref[GCLK_IDX_##_MOD] <= 0){ \
+		if(GCLK_ref[GCLK_IDX_##_MOD] <= 0){ \
 			if (0) printk(KERN_INFO "gate off %s %x, %x\n", GCLK_NAME_##_MOD, GCLK_REG_##_MOD, GCLK_MASK_##_MOD); \
 			CLEAR_CBUS_REG_MASK(GCLK_REG_##_MOD, GCLK_MASK_##_MOD); \
 			GCLK_ref[GCLK_IDX_##_MOD] = 0; \
@@ -854,7 +854,7 @@ extern spinlock_t gate_lock;
 #define GCLK_MASK_AO_REGS      (1<<3)
 
 #define GCLK_IDX_MAX 132
-extern unsigned char GCLK_ref[GCLK_IDX_MAX];
+extern short GCLK_ref[GCLK_IDX_MAX];
 
 #define REGISTER_CLK(_MOD) \
 static struct clk CLK_##_MOD = {            \
diff --git a/arch/arm/mach-meson8b/power_gate.c b/arch/arm/mach-meson8b/power_gate.c
index 530aeb8aa376..90530e7c35a3 100755
--- a/arch/arm/mach-meson8b/power_gate.c
+++ b/arch/arm/mach-meson8b/power_gate.c
@@ -8,7 +8,7 @@
 #include <linux/err.h>
 #include <linux/hardirq.h>
 
-unsigned char GCLK_ref[GCLK_IDX_MAX];
+short GCLK_ref[GCLK_IDX_MAX];
 EXPORT_SYMBOL(GCLK_ref);
 
 //#define PRINT_DEBUG_INFO
diff --git a/drivers/amlogic/display/osd/Makefile b/drivers/amlogic/display/osd/Makefile
index ed133e721b1d..9c1fec04683f 100755
--- a/drivers/amlogic/display/osd/Makefile
+++ b/drivers/amlogic/display/osd/Makefile
@@ -5,7 +5,7 @@
 
 obj-$(CONFIG_FB_AM) += fb.o 
 
-fb-objs =  osd_hw.o osd_main.o osd_dev.o  osd_antiflicker.o
+fb-objs =  osd_hw.o osd_main.o osd_dev.o  osd_antiflicker.o osd_clone.o
 
 ifeq ($(CONFIG_ARCH_MESON8),y)
 fb-objs += osd_prot.o
diff --git a/drivers/amlogic/display/osd/osd_clone.c b/drivers/amlogic/display/osd/osd_clone.c
new file mode 100755
index 000000000000..c1d9fb821ee0
--- /dev/null
+++ b/drivers/amlogic/display/osd/osd_clone.c
@@ -0,0 +1,206 @@
+/*
+ * Amlogic Ethernet Driver
+ *
+ * Copyright (C) 2012 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author: Platform-BJ@amlogic.com
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/ge2d/ge2d_main.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/sched.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/vout/vinfo.h>
+
+#include <mach/am_regs.h>
+#include <mach/mod_gate.h>
+
+#include "osd_clone.h"
+
+#ifdef OSD_GE2D_CLONE_SUPPORT
+typedef struct {
+	bool inited;
+	int angle;
+	int buffer_number;
+	u32 osd1_yres;
+	u32 osd2_yres;
+	config_para_ex_t ge2d_config;
+	ge2d_context_t *ge2d_context;
+} osd_clone_t;
+
+static DEFINE_MUTEX(osd_clone_mutex);
+static osd_clone_t s_osd_clone;
+
+static void osd_clone_process(void)
+{
+	canvas_t cs, cd;
+	u32 x0 = 0;
+	u32 y0 = 0;
+	u32 y1 = 0;
+	unsigned char x_rev = 0;
+	unsigned char y_rev = 0;
+	unsigned char xy_swap = 0;
+	config_para_ex_t *ge2d_config = &s_osd_clone.ge2d_config;
+	ge2d_context_t *context = s_osd_clone.ge2d_context;
+
+	canvas_read(OSD1_CANVAS_INDEX, &cs);
+	canvas_read(OSD2_CANVAS_INDEX, &cd);
+
+	y0 = s_osd_clone.osd1_yres*s_osd_clone.buffer_number;
+	y1 = s_osd_clone.osd2_yres*s_osd_clone.buffer_number;
+
+	if (s_osd_clone.angle == 1) {
+		xy_swap = 1;
+		x_rev = 1;
+	} else if (s_osd_clone.angle == 2) {
+		x_rev = 1;
+		y_rev = 1;
+	} else if (s_osd_clone.angle == 3) {
+		xy_swap = 1;
+		y_rev = 1;
+	}
+
+	memset(ge2d_config, 0, sizeof(config_para_ex_t));
+	ge2d_config->alu_const_color = 0;
+	ge2d_config->bitmask_en = 0;
+	ge2d_config->src1_gb_alpha = 0;
+	ge2d_config->dst_xy_swap = 0;
+
+	ge2d_config->src_planes[0].addr = cs.addr;
+	ge2d_config->src_planes[0].w = cs.width/4;
+	ge2d_config->src_planes[0].h = cs.height;
+
+	ge2d_config->dst_planes[0].addr = cd.addr;
+	ge2d_config->dst_planes[0].w = cd.width/4;
+	ge2d_config->dst_planes[0].h = cd.height;
+
+	ge2d_config->src_para.canvas_index = OSD1_CANVAS_INDEX;
+	ge2d_config->src_para.mem_type = CANVAS_OSD0;
+	ge2d_config->dst_para.format = GE2D_FORMAT_S32_ABGR;
+	ge2d_config->src_para.fill_color_en = 0;
+	ge2d_config->src_para.fill_mode = 0;
+	ge2d_config->src_para.x_rev = 0;
+	ge2d_config->src_para.y_rev = 0;
+	ge2d_config->src_para.color = 0xffffffff;
+	ge2d_config->src_para.top = 0;
+	ge2d_config->src_para.left = 0;
+	ge2d_config->src_para.width = cs.width/4;
+	ge2d_config->src_para.height = cs.height;
+
+	ge2d_config->dst_para.canvas_index = OSD2_CANVAS_INDEX;
+	ge2d_config->dst_para.mem_type = CANVAS_OSD1;
+	ge2d_config->dst_para.format = GE2D_FORMAT_S32_ABGR;
+	ge2d_config->dst_para.top = 0;
+	ge2d_config->dst_para.left = 0;
+	ge2d_config->dst_para.width = cd.width/4;
+	ge2d_config->dst_para.height = cd.height;
+	ge2d_config->dst_para.fill_color_en = 0;
+	ge2d_config->dst_para.fill_mode = 0;
+	ge2d_config->dst_para.color = 0;
+	ge2d_config->dst_para.x_rev = x_rev;
+	ge2d_config->dst_para.y_rev = y_rev;
+	ge2d_config->dst_xy_swap = xy_swap;
+
+	if (ge2d_context_config_ex(context, ge2d_config) < 0) {
+		printk("++ osd clone ge2d config error.\n");
+		return;
+	}
+	stretchblt(context, x0, y0, cs.width/4, s_osd_clone.osd1_yres, x0, y1, cd.width/4, s_osd_clone.osd2_yres);
+}
+
+void osd_clone_update_pan(int buffer_number)
+{
+	if (!s_osd_clone.inited)
+		return;
+
+	mutex_lock(&osd_clone_mutex);
+	s_osd_clone.buffer_number = buffer_number;
+	mutex_unlock(&osd_clone_mutex);
+	osd_clone_process();
+}
+
+void osd_clone_set_virtual_yres(u32 osd1_yres, u32 osd2_yres)
+{
+	mutex_lock(&osd_clone_mutex);
+	s_osd_clone.osd1_yres = osd1_yres;
+	s_osd_clone.osd2_yres = osd2_yres;
+	mutex_unlock(&osd_clone_mutex);
+}
+
+void osd_clone_get_virtual_yres(u32 *osd2_yres)
+{
+	mutex_lock(&osd_clone_mutex);
+	*osd2_yres = s_osd_clone.osd2_yres;
+	mutex_unlock(&osd_clone_mutex);
+}
+
+void osd_clone_set_angle(int angle)
+{
+	mutex_lock(&osd_clone_mutex);
+	s_osd_clone.angle = angle;
+	mutex_unlock(&osd_clone_mutex);
+}
+
+int osd_clone_task_start(void)
+{
+	if (s_osd_clone.inited) {
+		printk("osd_clone_task already started.\n");
+		return 0;
+	}
+
+	printk("osd_clone_task start.\n");
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	switch_mod_gate_by_name("ge2d", 1);
+#endif
+	if (s_osd_clone.ge2d_context == NULL)
+		s_osd_clone.ge2d_context = create_ge2d_work_queue();
+
+	memset(&s_osd_clone.ge2d_config, 0, sizeof(config_para_ex_t));
+	s_osd_clone.inited = true;
+
+	return 1;
+}
+
+void osd_clone_task_stop(void)
+{
+	if (!s_osd_clone.inited) {
+		printk("osd_clone_task already stopped.\n");
+		return;
+	}
+
+	printk("osd_clone_task stop.\n");
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	switch_mod_gate_by_name("ge2d", 0);
+#endif
+	if (s_osd_clone.ge2d_context) {
+		destroy_ge2d_work_queue(s_osd_clone.ge2d_context);
+		s_osd_clone.ge2d_context = NULL;
+	}
+	s_osd_clone.inited = false;
+}
+#endif
diff --git a/drivers/amlogic/display/osd/osd_clone.h b/drivers/amlogic/display/osd/osd_clone.h
new file mode 100755
index 000000000000..8281c2b1e886
--- /dev/null
+++ b/drivers/amlogic/display/osd/osd_clone.h
@@ -0,0 +1,55 @@
+/*
+ * Amlogic OSD Driver
+ *
+ * Copyright (C) 2012 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author: Platform-BJ@amlogic.com
+ *
+ */
+
+#ifndef _OSD_CLONE_H_
+#define _OSD_CLONE_H_
+
+#ifdef CONFIG_AM_GE2D
+#define OSD_GE2D_CLONE_SUPPORT 1
+#endif
+
+#ifdef OSD_GE2D_CLONE_SUPPORT
+extern void osd_clone_set_virtual_yres(u32 osd1_yres, u32 osd2_yres);
+extern void osd_clone_get_virtual_yres(u32 *osd2_yres);
+extern void osd_clone_set_angle(int angle);
+extern void osd_clone_update_pan(int buffer_number);
+extern int osd_clone_task_start(void);
+extern void osd_clone_task_stop(void);
+#else
+static inline void osd_clone_set_virtual_yres(u32 osd1_yres, u32 osd2_yres) {}
+static inline void osd_clone_get_virtual_yres(u32 *osd2_yres) {}
+static inline void osd_clone_set_angle(int angle) {}
+static inline void osd_clone_update_pan(int buffer_number) {}
+static inline int osd_clone_task_start(void)
+{
+	printk("++ osd_clone depends on GE2D module!\n");
+	return 0;
+}
+static inline void osd_clone_task_stop(void)
+{
+	printk("-- osd_clone depends on GE2D module!\n");
+	return;
+}
+#endif
+
+#endif
diff --git a/drivers/amlogic/display/osd/osd_dev.c b/drivers/amlogic/display/osd/osd_dev.c
index 1468a28cdec6..f0e657fa6d9e 100755
--- a/drivers/amlogic/display/osd/osd_dev.c
+++ b/drivers/amlogic/display/osd/osd_dev.c
@@ -259,6 +259,31 @@ void osddev_set_osd_antiflicker(u32 index, u32 vmode, u32 yres)
         osd_set_osd_antiflicker_hw(index, vmode, yres);
 }
 
+void osddev_get_osd_angle(u32 index, u32 *angle)
+{
+        osd_get_osd_angle_hw(index, angle);
+}
+
+void osddev_set_osd_angle(u32 index, u32 angle, u32  virtual_osd1_yres, u32 virtual_osd2_yres)
+{
+        osd_set_osd_angle_hw(index, angle, virtual_osd1_yres, virtual_osd2_yres);
+}
+
+void osddev_get_osd_clone(u32 index, u32 *clone)
+{
+        osd_get_osd_clone_hw(index, clone);
+}
+
+void osddev_set_osd_clone(u32 index, u32 clone)
+{
+        osd_set_osd_clone_hw(index, clone);
+}
+
+void osddev_set_osd_update_pan(u32 index)
+{
+        osd_set_osd_update_pan_hw(index);
+}
+
 void osddev_get_osd_rotate_angle(u32 index, u32 *angle)
 {
         osd_get_osd_rotate_angle_hw(index, angle);
diff --git a/drivers/amlogic/display/osd/osd_hw.c b/drivers/amlogic/display/osd/osd_hw.c
index a97147c79e56..c5318739a1f3 100755
--- a/drivers/amlogic/display/osd/osd_hw.c
+++ b/drivers/amlogic/display/osd/osd_hw.c
@@ -40,6 +40,7 @@
 #include "osd_hw_def.h"
 #include "osd_prot.h"
 #include "osd_antiflicker.h"
+#include "osd_clone.h"
 
 #ifdef CONFIG_AML_VSYNC_FIQ_ENABLE
 #define  FIQ_VSYNC
@@ -58,6 +59,7 @@ static bool osd_vf_need_update = false;
 #ifdef CONFIG_AM_FB_EXT
 extern void osd_ext_clone_pan(u32 index);
 #endif
+extern void osd_clone_pan(u32 index, u32 yoffset, int debug_flag);
 
 static struct vframe_provider_s osd_vf_prov;
 static int  g_vf_visual_width;
@@ -739,6 +741,11 @@ void osd_setup(struct osd_ctl_s *osd_ctl,
 	if(osd_hw.antiflicker_mode){
 		osd_antiflicker_update_pan(yoffset, yres);
 	}
+
+	if(osd_hw.clone){
+		osd_clone_pan(index, yoffset, 0);
+	}
+
 #ifdef CONFIG_AM_FB_EXT
 	osd_ext_clone_pan(index);
 #endif
@@ -1267,6 +1274,107 @@ void osd_get_osd_antiflicker_hw(u32 index, u32 *on_off)
 	*on_off = osd_hw.antiflicker_mode;
 }
 
+void osd_clone_pan(u32 index, u32 yoffset, int debug_flag)
+{
+	s32 offset = 0;
+	u32 index_buffer = 0;
+	s32 osd0_buffer_number = 0;
+	s32 height_osd1 = 0;
+
+	if(yoffset != 0){
+		index_buffer = osd_hw.fb_gem[index].height/yoffset;
+		if ( index_buffer == 3){
+			osd0_buffer_number = 1;
+		}else if (index_buffer == 1){
+			osd0_buffer_number = 2;
+		}
+	}else{
+		osd0_buffer_number = 0;
+	}
+
+	osd_clone_get_virtual_yres(&height_osd1);
+	if (osd_hw.clone) {
+		offset = osd0_buffer_number*height_osd1;
+
+		osd_hw.pandata[OSD2].y_start = offset;
+		osd_hw.pandata[OSD2].y_end = offset+height_osd1-1;
+		if (osd_hw.angle[OSD2]) {
+			if(debug_flag){
+				printk("++ osd_clone_pan start when enable clone\n");
+			}
+			osd_clone_update_pan(osd0_buffer_number);
+		}
+		add_to_update_list(OSD2, DISP_GEOMETRY);
+		osd_wait_vsync_hw();
+	}
+}
+
+void osd_set_osd_angle_hw(u32 index, u32 angle, u32  virtual_osd1_yres, u32 virtual_osd2_yres)
+{
+#ifndef OSD_GE2D_CLONE_SUPPORT
+	printk("++ osd_clone depends on GE2D module!\n");
+	return;
+#endif
+
+	if(angle > 4) {
+		printk("++ invalid angle: %d\n", angle);
+		return;
+	}
+
+	printk("++ virtual_osd1_yres is %d, virtual_osd2_yres is %d!\n", virtual_osd1_yres, virtual_osd2_yres);
+	osd_clone_set_virtual_yres(virtual_osd1_yres, virtual_osd2_yres);
+	if (osd_hw.clone == 0) {
+		printk("++ set osd[%d]->angle: %d->%d\n", index, osd_hw.angle[index], angle);
+		osd_clone_set_angle(angle);
+		osd_hw.angle[index] = angle;
+	} else if (!((osd_hw.angle[index] == 0) || (angle == 0))) {
+		printk("++ set osd[%d]->angle: %d->%d\n", index, osd_hw.angle[index], angle);
+		osd_clone_set_angle(angle);
+		osd_hw.angle[index] = angle;
+		osd_clone_pan(index, osd_hw.pandata[OSD1].y_start, 1);
+	}
+}
+
+void osd_get_osd_angle_hw(u32 index, u32 *angle)
+{
+	*angle = osd_hw.angle[index];
+}
+
+void osd_set_osd_clone_hw(u32 index, u32 clone)
+{
+	int ret = -1;
+
+	printk("++ set osd[%d]->clone: %d->%d\n", index, osd_hw.clone, clone);
+	osd_hw.clone = clone;
+
+	if (osd_hw.clone) {
+		if (osd_hw.angle[index]) {
+			osd_hw.color_info[index] = osd_hw.color_info[OSD1];
+			ret = osd_clone_task_start();
+			if(ret){
+				osd_clone_pan(index, osd_hw.pandata[OSD1].y_start, 1);
+			}else{
+				printk("++ start clone error\n");
+			}
+		}
+	} else {
+		if (osd_hw.angle[index]) {
+			osd_clone_task_stop();
+		}
+	}
+	add_to_update_list(index, OSD_COLOR_MODE);
+}
+
+void osd_set_osd_update_pan_hw(u32 index)
+{
+	osd_clone_pan(index, osd_hw.pandata[OSD1].y_start, 1);
+}
+
+void osd_get_osd_clone_hw(u32 index, u32 *clone)
+{
+	*clone = osd_hw.clone;
+}
+
 void osd_set_osd_reverse_hw(u32 index, u32 reverse)
 {
 	osd_hw.osd_reverse[index] = reverse;
@@ -1803,8 +1911,14 @@ static   void  osd2_update_enable(void)
         spin_lock_irqsave(&osd_onoff_lock, flags);
         if (osd_hw.enable[OSD2] == ENABLE){
             // osd1 and osd2 share the only one freescale, so set  VPP_OSD1_POSTBLEND here.
-            aml_set_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-            aml_set_reg32_mask(P_VPP_MISC,VPP_POSTBLEND_EN);
+            if(osd_hw.free_scale_enable[OSD2]){
+                aml_set_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
+                aml_set_reg32_mask(P_VPP_MISC,VPP_POSTBLEND_EN);
+            }else{
+                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
+                aml_set_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
+                aml_set_reg32_mask(P_VPP_MISC,VPP_POSTBLEND_EN);
+            }
         }else{
             if (osd_hw.enable[OSD1] == ENABLE){
                 aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
@@ -2348,6 +2462,15 @@ static   void  osd2_update_disp_geometry(void)
 				| ((osd_hw.scaledata[OSD2].y_end  + osd_hw.pandata[OSD2].y_start) & 0x1fff) << 16 ;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2,data32);
 #endif
+	} else if (osd_hw.free_scale_enable[OSD2]
+				&& (osd_hw.free_scale_data[OSD2].x_end > 0)
+				&& (osd_hw.free_scale_data[OSD2].y_end > 0)) {
+			/* enable osd free scale */
+			data32 = (osd_hw.free_scale_data[OSD2].x_start & 0x1fff) | (osd_hw.free_scale_data[OSD2].x_end & 0x1fff) << 16;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+			data32 = ((osd_hw.free_scale_data[OSD2].y_start + osd_hw.pandata[OSD2].y_start) & 0x1fff)
+					| ((osd_hw.free_scale_data[OSD2].y_end  + osd_hw.pandata[OSD2].y_start) & 0x1fff) << 16 ;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
 	} else {
 		data32=(osd_hw.pandata[OSD2].x_start & 0x1fff) | (osd_hw.pandata[OSD2].x_end & 0x1fff) << 16;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1,data32);
@@ -2483,11 +2606,15 @@ void osd_init_hw(u32  logo_loaded)
 	osd_hw.free_scale[OSD1].hfs_enable=0;
 	osd_hw.free_scale[OSD2].vfs_enable=0;
 	osd_hw.free_scale[OSD2].vfs_enable=0;
-	osd_hw.free_scale_mode[OSD1] = osd_hw.free_scale_mode[OSD2] = 0;
 	osd_hw.osd_reverse[OSD1] = osd_hw.osd_reverse[OSD2] = 0;
 	osd_hw.rotation_pandata[OSD1].x_start = osd_hw.rotation_pandata[OSD1].y_start = 0;
 	osd_hw.rotation_pandata[OSD2].x_start = osd_hw.rotation_pandata[OSD2].y_start = 0;
 	osd_hw.antiflicker_mode = 0;
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	osd_hw.free_scale_mode[OSD1] = osd_hw.free_scale_mode[OSD2] = 1;
+#else
+	osd_hw.free_scale_mode[OSD1] = osd_hw.free_scale_mode[OSD2] = 0;
+#endif
 
 	memset(osd_hw.rotate,0,sizeof(osd_rotate_t));
 
diff --git a/drivers/amlogic/display/osd/osd_hw_def.h b/drivers/amlogic/display/osd/osd_hw_def.h
index 0a41e865030f..f80b06ef68e0 100755
--- a/drivers/amlogic/display/osd/osd_hw_def.h
+++ b/drivers/amlogic/display/osd/osd_hw_def.h
@@ -146,7 +146,9 @@ typedef  struct {
 	u32			field_out_en;
 	u32			scale_workaround;
 	u32			fb_for_4k2k;
-	u32         antiflicker_mode;
+	u32         		antiflicker_mode;
+	u32			angle[HW_OSD_COUNT];
+	u32			clone;
 }hw_para_t;
 
 /************************************************************************
diff --git a/drivers/amlogic/display/osd/osd_main.c b/drivers/amlogic/display/osd/osd_main.c
index ab2fb7745a14..041c44e31c71 100755
--- a/drivers/amlogic/display/osd/osd_main.c
+++ b/drivers/amlogic/display/osd/osd_main.c
@@ -96,7 +96,7 @@ _find_color_format(struct fb_var_screeninfo * var)
 		lower_margin=COLOR_INDEX_24_6666_A;
 		break;		
 		case 3:
-		upper_margin=COLOR_INDEX_32_ARGB;
+		upper_margin=COLOR_INDEX_32_ABGR;
 		lower_margin=COLOR_INDEX_32_BGRA;
 		break;
 		case 4:
@@ -151,14 +151,14 @@ osd_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 
 	fix = &info->fix;
 	
-	color_format_pt=_find_color_format(var);	
+	color_format_pt=_find_color_format(var);
 	if (color_format_pt == NULL || color_format_pt->color_index==0)
 	{
 		return -EFAULT ;
 	}
 	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"select color format :index%d,bpp %d\r\n",color_format_pt->color_index, \
 												color_format_pt->bpp) ;
-	fbdev->color=color_format_pt ;
+	fbdev->color=color_format_pt;
 	var->red.offset = color_format_pt->red_offset;
 	var->red.length = color_format_pt->red_length;
 	var->red.msb_right= color_format_pt->red_msb_right ;
@@ -186,19 +186,18 @@ osd_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"no enough memory for %d*%d*%d\r\n",var->xres,var->yres,var->bits_per_pixel);
 		return  -ENOMEM;
 	}
-    	if (var->xres_virtual < var->xres)
-        var->xres_virtual = var->xres;
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
 
-    	if (var->yres_virtual < var->yres)
-        var->yres_virtual = var->yres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
 
     	var->left_margin = var->right_margin = var->upper_margin = var->lower_margin = 0;
     
-
 	if (var->xres + var->xoffset > var->xres_virtual)
-	var->xoffset = var->xres_virtual - var->xres;
+		var->xoffset = var->xres_virtual - var->xres;
 	if (var->yres + var->yoffset > var->yres_virtual)
-	var->yoffset = var->yres_virtual - var->yres;
+		var->yoffset = var->yres_virtual - var->yres;
     
     	return 0;
 }
@@ -1314,6 +1313,63 @@ static ssize_t store_antiflicker(struct device *device, struct device_attribute
 	return count;
 }
 
+static ssize_t show_ver_angle(struct device *device, struct device_attribute *attr,
+                        char *buf)
+{
+	unsigned int osd_angle = 0;
+	struct fb_info *fb_info = dev_get_drvdata(device);
+
+	osddev_get_osd_angle(fb_info->node, &osd_angle);
+	return snprintf(buf, PAGE_SIZE, "osd_angle:[%d]\n", osd_angle);
+}
+
+static ssize_t store_ver_angle(struct device *device, struct device_attribute *attr,
+                         const char *buf, size_t count)
+{
+	unsigned int osd_angle = 0;
+	struct fb_info *fb_info = dev_get_drvdata(device);
+
+	osd_angle = simple_strtoul(buf, NULL, 0);
+
+	memset((char*)fb_info->screen_base, 0x80, fb_info->screen_size);
+	osddev_set_osd_angle(fb_info->node, osd_angle, mydef_var[OSD1].yres, fb_info->var.yres);
+
+	return count;
+}
+
+static ssize_t show_ver_clone(struct device *device, struct device_attribute *attr,
+                        char *buf)
+{
+	unsigned int osd_clone = 0;
+	struct fb_info *fb_info = dev_get_drvdata(device);
+
+	osddev_get_osd_clone(fb_info->node, &osd_clone);
+	return snprintf(buf, PAGE_SIZE, "osd_clone:[%s]\n", osd_clone?"ON":"OFF");
+}
+
+static ssize_t store_ver_clone(struct device *device, struct device_attribute *attr,
+                         const char *buf, size_t count)
+{
+	unsigned int osd_clone = 0;
+	struct fb_info *fb_info = dev_get_drvdata(device);
+
+	osd_clone = simple_strtoul(buf, NULL, 0);
+
+	osddev_set_osd_clone(fb_info->node, osd_clone);
+
+	return count;
+}
+
+static ssize_t store_ver_update_pan(struct device *device, struct device_attribute *attr,
+                         const char *buf, size_t count)
+{
+	struct fb_info *fb_info = dev_get_drvdata(device);
+
+	osddev_set_osd_update_pan(fb_info->node);
+
+	return count;
+}
+
 static inline  int str2lower(char *str)
 {
 	while(*str != '\0')
@@ -1447,6 +1503,9 @@ static struct device_attribute osd_attrs[] = {
 	__ATTR(osd_reverse, S_IRUGO|S_IWUSR, show_osd_reverse, store_osd_reverse),
 	__ATTR(prot_state, S_IRUGO|S_IWUSR, show_prot_state, NULL),
 	__ATTR(osd_antiflicker, S_IRUGO|S_IWUSR, show_antiflicker, store_antiflicker),
+	__ATTR(ver_angle, S_IRUGO|S_IWUSR, show_ver_angle, store_ver_angle),
+	__ATTR(ver_clone, S_IRUGO|S_IWUSR, show_ver_clone, store_ver_clone),
+	__ATTR(ver_update_pan, S_IRUGO|S_IWUSR, NULL, store_ver_update_pan),
 };		
 
 #ifdef  CONFIG_PM
@@ -1549,7 +1608,6 @@ osd_probe(struct platform_device *pdev)
 			if(init_logo_obj->para.output_dev_type==LOGO_DEV_VID)
 			init_logo_obj=NULL; //if logo device on video layer ,
 		}					 //we cant use it .
-		
 	}
 #endif
 
@@ -1566,43 +1624,47 @@ osd_probe(struct platform_device *pdev)
 		}
 		osddev_4k2k_fb_mode(prop_idx);
 	}
-   	if (NULL==init_logo_obj )
-    	{
+
+	if (NULL==init_logo_obj )
+	{
     		prop = of_get_property(pdev->dev.of_node, "vmode", NULL);
-			if(prop)
+		if(prop){
 			prop_idx = of_read_ulong(prop,1);
-			if(prop_idx == 3){
-				if(get_current_mode_state() == VMODE_SETTED){
-					amlog_level(LOG_LEVEL_HIGH,"vmode has setted in aml logo module\r\n");
-				}else{
-					DisableVideoLayer();
-					#ifdef CONFIG_AM_HDMI_ONLY
-						hpd_state = read_hpd_gpio();
-
-						cvbs_mode = get_current_cvbs_vmode();
-						current_mode = get_current_hdmi_vmode();
-						if (hpd_state == 0)
-							set_current_vmode(cvbs_mode);
-						else
-							set_current_vmode(current_mode);
-					#else
-						current_mode = get_resolution_vmode();
+		}
+
+		if(prop_idx == 3){
+			if(get_current_mode_state() == VMODE_SETTED){
+				amlog_level(LOG_LEVEL_HIGH,"vmode has setted in aml logo module\r\n");
+			}else{
+				DisableVideoLayer();
+				#ifdef CONFIG_AM_HDMI_ONLY
+					hpd_state = read_hpd_gpio();
+					cvbs_mode = get_current_cvbs_vmode();
+					current_mode = get_current_hdmi_vmode();
+
+					if (hpd_state == 0)
+						set_current_vmode(cvbs_mode);
+					else
 						set_current_vmode(current_mode);
-					#endif
-				}
-			}
-			else if(prop_idx == 1){
-				current_mode = VMODE_LCD;
-				set_current_vmode(VMODE_LCD);
+				#else
+					current_mode = get_resolution_vmode();
+					set_current_vmode(current_mode);
+				#endif
 			}
-			else if(prop_idx == 2){
-				current_mode = VMODE_LVDS_1080P;
-				set_current_vmode(VMODE_LVDS_1080P);
-			}
-			osddev_init();
+		}
+		else if(prop_idx == 1){
+			current_mode = VMODE_LCD;
+			set_current_vmode(VMODE_LCD);
+		}
+		else if(prop_idx == 2){
+			current_mode = VMODE_LVDS_1080P;
+			set_current_vmode(VMODE_LVDS_1080P);
+		}
+		osddev_init();
     	}
 	vinfo = get_current_vinfo();
-    printk("%s, vinfo:%p\n", __func__, vinfo);
+	printk("%s, vinfo:%p\n", __func__, vinfo);
+
     	for (index=0;index<OSD_COUNT;index++)
     	{
 #if 0
@@ -1633,12 +1695,11 @@ osd_probe(struct platform_device *pdev)
 		mem->end = mem->start+ (phys_addr_t)get_reserve_block_size(ret)-1;
 #endif
 		fbi = framebuffer_alloc(sizeof(struct myfb_dev), &pdev->dev);
-    		if(!fbi)
-    		{
-        		r = -ENOMEM;
-        		goto failed1;
-    		}
-	
+		if(!fbi){
+			r = -ENOMEM;
+			goto failed1;
+		}
+
 		fbdev = (struct myfb_dev *)fbi->par;
 		fbdev->fb_info = fbi;
 		fbdev->dev = pdev;
@@ -1656,18 +1717,20 @@ osd_probe(struct platform_device *pdev)
 		if (!fbdev->fb_mem_vaddr)
 		{
 			amlog_level(LOG_LEVEL_HIGH,"failed to ioremap framebuffer\n");
-        		r = -ENOMEM;
-        		goto failed1;
+			r = -ENOMEM;
+			goto failed1;
 		}
 	
 		//clear framebuffer memory
 		amlog_level(LOG_LEVEL_HIGH,"Frame buffer memory assigned at phy:0x%08x, vir:0x%p, size=%dK\n",
 	    	fbdev->fb_mem_paddr, fbdev->fb_mem_vaddr, fbdev->fb_len >> 10);
-        printk("%s, mydef_var:%p, vinfo:%p\n", __func__, mydef_var, vinfo);
-                mydef_var[index].width=vinfo->screen_real_width;
-                mydef_var[index].height=vinfo->screen_real_height;
-		if(init_logo_obj && index==logo_osd_index ) //adjust default var info
+		printk("%s, mydef_var:%p, vinfo:%p\n", __func__, mydef_var, vinfo);
+
+		mydef_var[index].width=vinfo->screen_real_width;
+		mydef_var[index].height=vinfo->screen_real_height;
+		if( init_logo_obj && index==logo_osd_index ) //adjust default var info
 		{
+			printk("don't find to display_size_default from mesonfb-dts\n");
 			int  bpp=init_logo_obj->dev->output_dev.osd.color_depth;//bytes per pixel
 			mydef_var[index].xres=init_logo_obj->dev->vinfo->width;
 			mydef_var[index].yres=init_logo_obj->dev->vinfo->height;	
@@ -1676,8 +1739,7 @@ osd_probe(struct platform_device *pdev)
 			mydef_var[index].bits_per_pixel=bpp;
 			
 			amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\r\n",mydef_var[index].bits_per_pixel);
-			if(mydef_var[index].bits_per_pixel>32)
-			{
+			if(mydef_var[index].bits_per_pixel>32){
 				mydef_var[index].bits_per_pixel=32;
 			}
 		} else {
@@ -1711,13 +1773,12 @@ osd_probe(struct platform_device *pdev)
 				prop_idx = of_read_ulong(prop,1);
 
 			rotation = prop_idx;
-
 		}
 		_fbdev_set_default(fbdev,index);
 		if(NULL==fbdev->color)
 		{
 			r = -ENOENT;
-        		goto failed1;
+			goto failed1;
 		}
 
 		Bpp=(fbdev->color->color_index >8?(fbdev->color->color_index>16?(fbdev->color->color_index>24?4:3):2):1);
@@ -1726,14 +1787,14 @@ osd_probe(struct platform_device *pdev)
 		fix->smem_len = fbdev->fb_len;
 		if (fb_alloc_cmap(&fbi->cmap, 16, 0) != 0) {
 			amlog_level(LOG_LEVEL_HIGH,"unable to allocate color map memory\n");
-      		r = -ENOMEM;
-        	goto failed2;
+			r = -ENOMEM;
+			goto failed2;
     		}
 
 		if (!(fbi->pseudo_palette = kmalloc(sizeof(u32) * 16, GFP_KERNEL))) {
 			amlog_level(LOG_LEVEL_HIGH,"unable to allocate pseudo palette memory\n");
-        	r = -ENOMEM;
-        	goto failed2;
+			r = -ENOMEM;
+			goto failed2;
 		}
 		memset(fbi->pseudo_palette, 0, sizeof(u32) * 16);
 
@@ -1747,6 +1808,7 @@ osd_probe(struct platform_device *pdev)
 		{
 			osddev_set(fbdev);
 		}
+
 		if(index == OSD0 && (rotation == 90 || rotation == 270)){
 			osddev_set(fbdev);
 		}
@@ -1756,21 +1818,23 @@ osd_probe(struct platform_device *pdev)
    	}	
 
 	index=0;
-
 #ifdef CONFIG_HAS_EARLYSUSPEND
-    early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING;
-    early_suspend.suspend = osd_early_suspend;
-    early_suspend.resume = osd_late_resume;
-    register_early_suspend(&early_suspend);
+	early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING;
+	early_suspend.suspend = osd_early_suspend;
+	early_suspend.resume = osd_late_resume;
+	register_early_suspend(&early_suspend);
 #endif
 	if (rotation == 90 || rotation == 270){
 		osddev_set_prot_canvas(0, 0,0,var_screeninfo[0]-1,var_screeninfo[1]-1);
-		if(rotation == 90)
-		osddev_set_osd_rotate_angle(0, 1);
-		else
-		osddev_set_osd_rotate_angle(0, 2);
-		osddev_set_osd_rotate_on(0, 1);
+		if(rotation == 90){
+			osddev_set_osd_rotate_angle(0, 1);
+		}
+		else{
+			osddev_set_osd_rotate_angle(0, 2);
+			osddev_set_osd_rotate_on(0, 1);
+		}
 	}
+
 	if (osd_info.index == DEV_ALL){
 		osddev_set_osd_reverse(0, osd_info.osd_reverse);
 		osddev_set_osd_reverse(1, osd_info.osd_reverse);
diff --git a/drivers/amlogic/display/osd_ext/osd_clone.c b/drivers/amlogic/display/osd_ext/osd_clone.c
index 8928a2dbcd48..6b495479d5ff 100755
--- a/drivers/amlogic/display/osd_ext/osd_clone.c
+++ b/drivers/amlogic/display/osd_ext/osd_clone.c
@@ -42,17 +42,17 @@
 
 #include "osd_clone.h"
 
-#ifdef OSD_GE2D_CLONE_SUPPORT
+#ifdef OSD_EXT_GE2D_CLONE_SUPPORT
 typedef struct {
 	bool inited;
 	int angle;
 	int pan;
 	config_para_ex_t ge2d_config;
 	ge2d_context_t *ge2d_context;
-} osd_clone_t;
+} osd_ext_clone_t;
 
-static DEFINE_MUTEX(osd_clone_mutex);
-static osd_clone_t s_osd_clone;
+static DEFINE_MUTEX(osd_ext_clone_mutex);
+static osd_ext_clone_t s_osd_ext_clone;
 
 
 static void osd_clone_process(void)
@@ -64,24 +64,24 @@ static void osd_clone_process(void)
 	unsigned char x_rev = 0;
 	unsigned char y_rev = 0;
 	unsigned char xy_swap = 0;
-	config_para_ex_t *ge2d_config = &s_osd_clone.ge2d_config;
-	ge2d_context_t *context = s_osd_clone.ge2d_context;
+	config_para_ex_t *ge2d_config = &s_osd_ext_clone.ge2d_config;
+	ge2d_context_t *context = s_osd_ext_clone.ge2d_context;
 
 	canvas_read(OSD1_CANVAS_INDEX, &cs);
 	canvas_read(OSD3_CANVAS_INDEX, &cd);
 
-	if (s_osd_clone.pan == 1) {
+	if (s_osd_ext_clone.pan == 1) {
 		y0 = cs.height/2;
 		y1 = cd.height/2;
 	}
 
-	if (s_osd_clone.angle == 1) {
+	if (s_osd_ext_clone.angle == 1) {
 		xy_swap = 1;
 		x_rev = 1;
-	} else if (s_osd_clone.angle == 2) {
+	} else if (s_osd_ext_clone.angle == 2) {
 		x_rev = 1;
 		y_rev = 1;
-	} else if (s_osd_clone.angle == 3) {
+	} else if (s_osd_ext_clone.angle == 3) {
 		xy_swap = 1;
 		y_rev = 1;
 	}
@@ -135,56 +135,59 @@ static void osd_clone_process(void)
 	stretchblt(context, x0, y0, cs.width/4, cs.height/2, x0, y1, cd.width/4, cd.height/2);
 }
 
-void osd_clone_update_pan(int pan)
+void osd_ext_clone_update_pan(int pan)
 {
-	if (!s_osd_clone.inited)
+	if (!s_osd_ext_clone.inited)
 		return;
 
-	mutex_lock(&osd_clone_mutex);
-	s_osd_clone.pan = pan;
-	mutex_unlock(&osd_clone_mutex);
+	mutex_lock(&osd_ext_clone_mutex);
+	s_osd_ext_clone.pan = pan;
+	mutex_unlock(&osd_ext_clone_mutex);
 	osd_clone_process();
 }
 
-void osd_clone_set_angle(int angle)
+void osd_ext_clone_set_angle(int angle)
 {
-	mutex_lock(&osd_clone_mutex);
-	s_osd_clone.angle = angle;
-	mutex_unlock(&osd_clone_mutex);
+	mutex_lock(&osd_ext_clone_mutex);
+	s_osd_ext_clone.angle = angle;
+	mutex_unlock(&osd_ext_clone_mutex);
 }
 
-int osd_clone_task_start(void)
+int osd_ext_clone_task_start(void)
 {
-	if (s_osd_clone.inited) {
-		printk("osd_clone_task already started.\n");
+	if (s_osd_ext_clone.inited) {
+		printk("osd_ext_clone_task already started.\n");
 		return 0;
 	}
 
-	printk("osd_clone_task start.\n");
+	printk("osd_ext_clone_task start.\n");
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	switch_mod_gate_by_name("ge2d", 1);
 #endif
-	if (s_osd_clone.ge2d_context == NULL)
-		s_osd_clone.ge2d_context = create_ge2d_work_queue();
+	if (s_osd_ext_clone.ge2d_context == NULL)
+		s_osd_ext_clone.ge2d_context = create_ge2d_work_queue();
 
-	memset(&s_osd_clone.ge2d_config, 0, sizeof(config_para_ex_t));
-	s_osd_clone.inited = true;
+	memset(&s_osd_ext_clone.ge2d_config, 0, sizeof(config_para_ex_t));
+	s_osd_ext_clone.inited = true;
 
 	return 0;
 }
 
-void osd_clone_task_stop(void)
+void osd_ext_clone_task_stop(void)
 {
-	if (!s_osd_clone.inited) {
-		printk("osd_clone_task already stopped.\n");
+	if (!s_osd_ext_clone.inited) {
+		printk("osd_ext_clone_task already stopped.\n");
 		return;
 	}
 
-	printk("osd_clone_task stop.\n");
-	if (s_osd_clone.ge2d_context) {
-		destroy_ge2d_work_queue(s_osd_clone.ge2d_context);
-		s_osd_clone.ge2d_context = NULL;
+	printk("osd_ext_clone_task stop.\n");
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	switch_mod_gate_by_name("ge2d", 0);
+#endif
+	if (s_osd_ext_clone.ge2d_context) {
+		destroy_ge2d_work_queue(s_osd_ext_clone.ge2d_context);
+		s_osd_ext_clone.ge2d_context = NULL;
 	}
-	s_osd_clone.inited = false;
+	s_osd_ext_clone.inited = false;
 }
 #endif
diff --git a/drivers/amlogic/display/osd_ext/osd_clone.h b/drivers/amlogic/display/osd_ext/osd_clone.h
index 5d121e902b01..10d72931ddbd 100755
--- a/drivers/amlogic/display/osd_ext/osd_clone.h
+++ b/drivers/amlogic/display/osd_ext/osd_clone.h
@@ -25,25 +25,25 @@
 #define _OSD_CLONE_H_
 
 #ifdef CONFIG_AM_GE2D
-#define OSD_GE2D_CLONE_SUPPORT 1
+#define OSD_EXT_GE2D_CLONE_SUPPORT 1
 #endif
 
-#ifdef OSD_GE2D_CLONE_SUPPORT
-extern void osd_clone_set_angle(int angle);
-extern void osd_clone_update_pan(int pan);
-extern int osd_clone_task_start(void);
-extern void osd_clone_task_stop(void);
+#ifdef OSD_EXT_GE2D_CLONE_SUPPORT
+extern void osd_ext_clone_set_angle(int angle);
+extern void osd_ext_clone_update_pan(int pan);
+extern int osd_ext_clone_task_start(void);
+extern void osd_ext_clone_task_stop(void);
 #else
-static inline void osd_clone_set_angle(int angle) {}
-static inline void osd_clone_update_pan(int pan) {}
-static inline int osd_clone_task_start(void)
+static inline void osd_ext_clone_set_angle(int angle) {}
+static inline void osd_ext_clone_update_pan(int pan) {}
+static inline int osd_ext_clone_task_start(void)
 {
-	printk("++ osd_clone depends on GE2D module!\n");
+	printk("++ osd_ext_clone depends on GE2D module!\n");
 	return 0;
 }
-static inline void osd_clone_task_stop(void)
+static inline void osd_ext_clone_task_stop(void)
 {
-	printk("-- osd_clone depends on GE2D module!\n");
+	printk("-- osd_ext_clone depends on GE2D module!\n");
 	return;
 }
 #endif
diff --git a/drivers/amlogic/display/osd_ext/osd_hw.c b/drivers/amlogic/display/osd_ext/osd_hw.c
index 63e4abaa1d5d..d09077af59e7 100755
--- a/drivers/amlogic/display/osd_ext/osd_hw.c
+++ b/drivers/amlogic/display/osd_ext/osd_hw.c
@@ -251,7 +251,7 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 	unsigned int scan_line_number = 0;
 	unsigned char output_type=0;
 	u32 data32 = 0;
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
 	if (osd_ext_hw.rotate[OSD1].on_off > 0 && osd_ext_hw.rotate[OSD1].angle > 0){
 		data32 = ((osd_ext_hw.rotation_pandata[OSD1].y_start + osd_ext_hw.pandata[OSD1].y_start) & 0x1fff)
 				| ((osd_ext_hw.rotation_pandata[OSD1].y_end  + osd_ext_hw.pandata[OSD1].y_start) & 0x1fff) << 16 ;
@@ -936,7 +936,7 @@ void osd_ext_get_osd_ext_rotate_angle_hw(u32 index,u32 *angle)
 
 void osd_ext_set_osd_ext_rotate_on_hw(u32 index, u32 on_off)
 {
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
 	static dispdata_t save_disp_data={0,0,0,0};
 	static dispdata_t save_disp_data2={0,0,0,0};
 	osd_ext_hw.rotate[index].on_off = on_off;
@@ -1370,10 +1370,10 @@ static void osd1_update_enable(void)
 {
 	if (osd_ext_hw.free_scale_mode[OSD1]){
 		if (osd_ext_hw.enable[OSD1] == ENABLE){
-			aml_set_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-			aml_set_reg32_mask(P_VPP_MISC,VPP_POSTBLEND_EN);
+			aml_set_reg32_mask(P_VPP2_MISC,VPP_OSD1_POSTBLEND);
+			aml_set_reg32_mask(P_VPP2_MISC,VPP_POSTBLEND_EN);
 		}else{
-			aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
+			aml_clr_reg32_mask(P_VPP2_MISC,VPP_OSD1_POSTBLEND);
 		}
 	}else{
 		u32 video_enable = 0;
@@ -1408,10 +1408,10 @@ static void osd2_update_enable(void)
 {
 	if (osd_ext_hw.free_scale_mode[OSD2]){
 		if (osd_ext_hw.enable[OSD1] == ENABLE){
-			aml_set_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
-			aml_set_reg32_mask(P_VPP_MISC,VPP_POSTBLEND_EN);
+			aml_set_reg32_mask(P_VPP2_MISC,VPP_OSD2_POSTBLEND);
+			aml_set_reg32_mask(P_VPP2_MISC,VPP_POSTBLEND_EN);
 		}else{
-			aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
+			aml_clr_reg32_mask(P_VPP2_MISC,VPP_OSD2_POSTBLEND);
 		}
 	}else{
 		u32 video_enable = 0;
@@ -1485,7 +1485,7 @@ static void osd1_update_disp_osd_rotate(void)
 	y_end = osd_ext_hw.rotation_pandata[OSD1].y_end;
 	y_len_m1 = y_end-y_start;
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
 	osd_ext_set_prot(
                 x_rev,
                 y_rev,
@@ -1558,7 +1558,7 @@ static void osd2_update_disp_osd_rotate(void)
 	y_end = osd_ext_hw.rotation_pandata[OSD2].y_end;
 	y_len_m1 = y_end-y_start;
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
 	osd_ext_set_prot(
                 x_rev,
                 y_rev,
@@ -2188,7 +2188,7 @@ void osd_ext_clone_pan(u32 index)
 		osd_ext_hw.pandata[index].y_start += offset;
 		osd_ext_hw.pandata[index].y_end += offset;
 		if (osd_ext_hw.angle[index]) {
-			osd_clone_update_pan(osd_ext_hw.pandata[index].y_start ? 1: 0);
+			osd_ext_clone_update_pan(osd_ext_hw.pandata[index].y_start ? 1: 0);
 		}
 		add_to_update_list(index, DISP_GEOMETRY);
 		osd_ext_wait_vsync_hw();
@@ -2203,7 +2203,7 @@ void osd_ext_get_angle_hw(u32 index, u32 * angle)
 
 void osd_ext_set_angle_hw(u32 index, u32 angle)
 {
-#ifndef OSD_GE2D_CLONE_SUPPORT
+#ifndef OSD_EXT_GE2D_CLONE_SUPPORT
 	printk("++ osd_clone depends on GE2D module!\n");
 	return;
 #endif
@@ -2215,11 +2215,11 @@ void osd_ext_set_angle_hw(u32 index, u32 angle)
 
 	if (osd_ext_hw.clone[index] == 0) {
 		printk("++ set osd_ext[%d]->angle: %d->%d\n", index, osd_ext_hw.angle[index], angle);
-		osd_clone_set_angle(angle);
+		osd_ext_clone_set_angle(angle);
 		osd_ext_hw.angle[index] = angle;
 	} else if (!((osd_ext_hw.angle[index] == 0) || (angle == 0))) {
 		printk("++ set osd_ext[%d]->angle: %d->%d\n", index, osd_ext_hw.angle[index], angle);
-		osd_clone_set_angle(angle);
+		osd_ext_clone_set_angle(angle);
 		osd_ext_hw.angle[index] = angle;
 		osd_ext_clone_pan(index);
 	}
@@ -2242,7 +2242,7 @@ void osd_ext_set_clone_hw(u32 index, u32 clone)
 	if (osd_ext_hw.clone[index]) {
 		if (osd_ext_hw.angle[index]) {
 			osd_ext_hw.color_info[index] = osd_hw.color_info[index];
-			osd_clone_task_start();
+			osd_ext_clone_task_start();
 		} else {
 			color_info[index] = osd_ext_hw.color_info[index];
 			osd_ext_hw.color_info[index] = osd_hw.color_info[index];
@@ -2251,7 +2251,7 @@ void osd_ext_set_clone_hw(u32 index, u32 clone)
 		}
 	} else {
 		if (osd_ext_hw.angle[index]) {
-			osd_clone_task_stop();
+			osd_ext_clone_task_stop();
 		} else {
 			color_info[index] = osd_ext_hw.color_info[index];
 			canvas_update_addr(osd_ext_hw.fb_gem[index].canvas_idx, osd_ext_hw.fb_gem[index].addr);
diff --git a/drivers/amlogic/display/vout/tvoutc.c b/drivers/amlogic/display/vout/tvoutc.c
index a6698e0e6bda..0f22ec6ebf0f 100755
--- a/drivers/amlogic/display/vout/tvoutc.c
+++ b/drivers/amlogic/display/vout/tvoutc.c
@@ -384,11 +384,12 @@ int tvoutc_setmode(tvmode_t mode)
         setreg(s++);
     printk("%s[%d]\n", __func__, __LINE__);
 
-    if(mode >= TVMODE_VGA || mode <= TVMODE_SXGA){
+    if(mode >= TVMODE_VGA && mode <= TVMODE_SXGA){
         aml_write_reg32(P_PERIPHS_PIN_MUX_0,aml_read_reg32(P_PERIPHS_PIN_MUX_0)|(3<<20));
     }else{
 	aml_write_reg32(P_PERIPHS_PIN_MUX_0,aml_read_reg32(P_PERIPHS_PIN_MUX_0)&(~(3<<20)));
     }
+
     set_tvmode_misc(mode);
 #ifdef CONFIG_ARCH_MESON1
 	tvoutc_setclk(mode);
diff --git a/drivers/amlogic/display/vout2/nulldisp.c b/drivers/amlogic/display/vout2/nulldisp.c
index af04ec83a674..bee3b24b9b12 100755
--- a/drivers/amlogic/display/vout2/nulldisp.c
+++ b/drivers/amlogic/display/vout2/nulldisp.c
@@ -120,7 +120,7 @@ static int __init nulldisp_init(void)
 
 static void __exit nulldisp_exit(void)
 {
-    vout_unregister_server(&nulldisp_vout_server);
+    vout2_unregister_server(&nulldisp_vout_server);
 }
 
 //module_init(nulldisp_init);
diff --git a/drivers/amlogic/display/vout2/tvconf2.c b/drivers/amlogic/display/vout2/tvconf2.c
index 0d921b8c2fbd..95cc03b5cdb2 100755
--- a/drivers/amlogic/display/vout2/tvconf2.c
+++ b/drivers/amlogic/display/vout2/tvconf2.c
@@ -46,7 +46,10 @@
 #include "vout_log.h"
 #include <linux/amlogic/amlog.h>
 #include <mach/power_gate.h>
-
+#include <mach/cpu.h>
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#include <mach/vpu.h>
+#endif
 
 
 static    disp_module_info_t    *info;
@@ -244,12 +247,15 @@ static const vinfo_t *tv_get_current_info(void)
 
 static int tv_set_current_vmode(vmode_t mod)
 {
-	if ((mod&VMODE_MODE_BIT_MASK)> VMODE_1080P_50HZ )
+	if ((mod&VMODE_MODE_BIT_MASK)> VMODE_1080P_50HZ)
 		return -EINVAL;
 
 	info->vinfo = &tv_info[mod];
 	if(mod&VMODE_LOGO_BIT_MASK)  return 0;
-
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	switch_vpu_mem_pd_vmod(info->vinfo->mode, VPU_MEM_POWER_ON);
+	request_vpu_clk_vmod(info->vinfo->video_clk, info->vinfo->mode);
+#endif
 	tvoutc_setmode2(vmode_tvmode_tab[mod]);
 	//change_vdac_setting2(get_current_vdac_setting(),mod);
 	return 0;
@@ -279,6 +285,13 @@ static int tv_vmode_is_supported(vmode_t mode)
 }
 static int tv_module_disable(vmode_t cur_vmod)
 {
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	if (info->vinfo) {
+		release_vpu_clk_vmod(info->vinfo->mode);
+		switch_vpu_mem_pd_vmod(info->vinfo->mode, VPU_MEM_POWER_DOWN);
+	}
+#endif
+
 	video_dac_disable();
 	return 0;
 }
diff --git a/drivers/amlogic/display/vout2/tvoutc2.c b/drivers/amlogic/display/vout2/tvoutc2.c
index a97c315a4989..e740d62217dd 100755
--- a/drivers/amlogic/display/vout2/tvoutc2.c
+++ b/drivers/amlogic/display/vout2/tvoutc2.c
@@ -31,7 +31,7 @@
 #include <linux/amlogic/vout/vinfo.h>
 #include "tvoutc.h"
 #include <linux/clk.h>
-
+#include <mach/mod_gate.h>
 
 
 static u32 curr_vdac_setting=DEFAULT_VDAC_SEQUENCE;
diff --git a/drivers/amlogic/display/vout2/vout2_serve.c b/drivers/amlogic/display/vout2/vout2_serve.c
index 404cbbdd0222..cca47b5a1920 100755
--- a/drivers/amlogic/display/vout2/vout2_serve.c
+++ b/drivers/amlogic/display/vout2/vout2_serve.c
@@ -172,6 +172,7 @@ static const char *venc_mux_help = {
 	"venc_mux:\n"
 	"    0. single display, viu1->panel, viu2->null\n"
 	"    2. dual display, viu1->hdmi, viu2->panel\n"
+	"    4. single display, viu1->null, viu2->hdmi\n"
 	"    8. dual display, viu1->panel, viu2->hdmi\n"
 };
 
@@ -195,6 +196,10 @@ static ssize_t venc_mux_store(struct class *class, struct class_attribute *attr,
 		mux_type = mux |(s_venc_mux<<2);
 		aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, mux_type, 0, 4);
 		break;
+	case 0x4:
+		mux_type = (0x2<<2);
+		aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, mux_type, 0, 4);
+		break;
 	case 0x8:
 		mux_type = (0x2<<2) |s_venc_mux;
 		aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, mux_type, 0, 4);
diff --git a/include/linux/amlogic/osd/osd_dev.h b/include/linux/amlogic/osd/osd_dev.h
index 4cebf35a71d6..a740c17298af 100755
--- a/include/linux/amlogic/osd/osd_dev.h
+++ b/include/linux/amlogic/osd/osd_dev.h
@@ -104,6 +104,11 @@ extern void osddev_get_osd_rotate_on(u32 index, u32 *on_off);
 extern void osddev_set_osd_rotate_on(u32 index, u32 on_off);
 extern void osddev_get_osd_antiflicker(u32 index, u32 *on_off);
 extern void osddev_set_osd_antiflicker(u32 index, u32 vmode, u32 yres);
+extern void osddev_get_osd_angle(u32 index, u32 *angle);
+extern void osddev_set_osd_angle(u32 index, u32 angle, u32  virtual_osd1_yres, u32 virtual_osd2_yres);
+extern void osddev_get_osd_clone(u32 index, u32 *clone);
+extern void osddev_set_osd_clone(u32 index, u32 clone);
+extern void osddev_set_osd_update_pan(u32 index);
 extern void osddev_get_osd_rotate_angle(u32 index, u32 *angle);
 extern void osddev_set_osd_rotate_angle(u32 index, u32 angle);
 extern void osddev_get_prot_canvas(u32 index, s32 *x_start, s32 *y_start, s32 *x_end, s32 *y_end);
diff --git a/include/linux/amlogic/osd/osd_hw.h b/include/linux/amlogic/osd/osd_hw.h
index bbfb6d7b991a..d7a6a3662cef 100755
--- a/include/linux/amlogic/osd/osd_hw.h
+++ b/include/linux/amlogic/osd/osd_hw.h
@@ -106,6 +106,11 @@ extern void osd_set_osd_rotate_on_hw(u32 index, u32 on_off);
 extern void osd_get_osd_rotate_on_hw(u32 index, u32 *on_off);
 extern void osd_set_osd_antiflicker_hw(u32 index, u32 vmode, u32 yres);
 extern void osd_get_osd_antiflicker_hw(u32 index, u32 *on_off);
+extern void osd_get_osd_angle_hw(u32 index, u32 *angle);
+extern void osd_set_osd_angle_hw(u32 index, u32 angle, u32  virtual_osd1_yres, u32 virtual_osd2_yres);
+extern void osd_get_osd_clone_hw(u32 index, u32 *clone);
+extern void osd_set_osd_clone_hw(u32 index, u32 clone);
+extern void osd_set_osd_update_pan_hw(u32 index);
 extern void osd_set_osd_rotate_angle_hw(u32 index, u32 angle);
 extern void osd_get_osd_rotate_angle_hw(u32 index, u32 *angle);
 extern void osd_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start, s32 *x_end, s32 *y_end);
-- 
2.19.0

