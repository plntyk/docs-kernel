From 15106bd24841925ae9c4af0121aa396ccf17d7e6 Mon Sep 17 00:00:00 2001
From: "chunhai.guo" <chunhai.guo@amlogic.com>
Date: Mon, 9 Jun 2014 11:25:52 +0800
Subject: [PATCH 4349/5965] PD#92925: MMC driver stablity improvement. This
 patch fix bug 92026/92130/91654, and add some error handler functions: 1. Fix
 timer and IRQ conflict issue causing crash bug; 2. Fix sdio resan causing
 crash bug; 3. Enable software flush rx fifo mode for sdhc; 4. Add error
 handle function to avoid random error causing FS error issue. 5. shorten the
 time of hot-plug operation for card. 6. Only enabel hotplug for sd to cause
 emmc/sdcard. 7. Fix timeout hotplug sd issue bug

---
 arch/arm/mach-meson8/include/mach/sd.h  |  12 +-
 arch/arm/mach-meson8b/include/mach/sd.h |  12 +-
 drivers/amlogic/mmc/aml_sdhc_m8.c       | 313 ++++++++++++++++++++----
 drivers/amlogic/mmc/aml_sdio.c          | 208 +++++++++++++++-
 drivers/amlogic/mmc/amlsd.c             |  11 +-
 drivers/mmc/card/block.c                |   2 +-
 drivers/mmc/core/core.c                 |   3 +
 drivers/mmc/core/sdio.c                 |   1 +
 include/linux/mmc/host.h                |   1 +
 9 files changed, 500 insertions(+), 63 deletions(-)

diff --git a/arch/arm/mach-meson8/include/mach/sd.h b/arch/arm/mach-meson8/include/mach/sd.h
index 594f25c1f265..bf69f3664839 100755
--- a/arch/arm/mach-meson8/include/mach/sd.h
+++ b/arch/arm/mach-meson8/include/mach/sd.h
@@ -13,6 +13,13 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
+#define     AML_ERROR_RETRY_COUNTER         5
+#define     AML_TIMEOUT_RETRY_COUNTER       2
+
+#define AML_SDHC_MAGIC			 "amlsdhc"
+#define AML_SDIO_MAGIC			 "amlsdio"
+
+
 enum aml_mmc_waitfor {
 	XFER_INIT,              /* 0 */
 	XFER_START,				/* 1 */
@@ -156,6 +163,8 @@ struct amlsd_host {
 	struct delayed_work	timeout;
 	// struct early_suspend amlsd_early_suspend;
 
+    struct class            debug;
+    
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
@@ -184,6 +193,7 @@ struct amlsd_host {
 	// unsigned int		ccnt, dcnt;
 
 	int     status; // host status: xx_error/ok
+	int init_flag;
 
     char    *msg_buf;
 #define MESSAGE_BUF_SIZE            512
@@ -205,10 +215,10 @@ struct amlsd_host {
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
-    u32         time_req_sta; // request start time
 
     u32         reg_buf[16];
 #endif
+    u32         time_req_sta; // request start time
     
     struct pinctrl  *pinctrl;
     char        pinctrl_name[30];
diff --git a/arch/arm/mach-meson8b/include/mach/sd.h b/arch/arm/mach-meson8b/include/mach/sd.h
index d8b1cf29c695..f7c8d8fa75c4 100755
--- a/arch/arm/mach-meson8b/include/mach/sd.h
+++ b/arch/arm/mach-meson8b/include/mach/sd.h
@@ -13,6 +13,13 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
+#define     AML_ERROR_RETRY_COUNTER         5
+#define     AML_TIMEOUT_RETRY_COUNTER       2
+
+#define AML_SDHC_MAGIC			 "amlsdhc"
+#define AML_SDIO_MAGIC			 "amlsdio"
+
+
 enum aml_mmc_waitfor {
 	XFER_INIT,              /* 0 */
 	XFER_START,				/* 1 */
@@ -156,6 +163,8 @@ struct amlsd_host {
 	struct delayed_work	timeout;
 	// struct early_suspend amlsd_early_suspend;
 
+    struct class            debug;
+    
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
@@ -184,6 +193,7 @@ struct amlsd_host {
 	// unsigned int		ccnt, dcnt;
 
 	int     status; // host status: xx_error/ok
+	int init_flag;
 
     char    *msg_buf;
 #define MESSAGE_BUF_SIZE            512
@@ -205,10 +215,10 @@ struct amlsd_host {
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
-    u32         time_req_sta; // request start time
 
     u32         reg_buf[16];
 #endif
+    u32         time_req_sta; // request start time
     
     struct pinctrl  *pinctrl;
     char        pinctrl_name[30];
diff --git a/drivers/amlogic/mmc/aml_sdhc_m8.c b/drivers/amlogic/mmc/aml_sdhc_m8.c
index 4f5047cba1d2..274e4628057c 100755
--- a/drivers/amlogic/mmc/aml_sdhc_m8.c
+++ b/drivers/amlogic/mmc/aml_sdhc_m8.c
@@ -41,6 +41,11 @@ unsigned int cmd25_cnt=0;
 unsigned int fifo_empty_cnt=0;
 unsigned int fifo_full_cnt=0;
 unsigned int timeout_cnt=0;
+static unsigned int sdhc_error_flag = 0;
+static unsigned int sdhc_debug_flag = 0;
+static int sdhc_err_bak;
+
+void aml_sdhc_send_stop(struct amlsd_host* host);
 
 static void aml_sdhc_clk_switch (struct amlsd_platform* pdata, int clk_div, int clk_src_sel);
 static int aml_sdhc_status (struct amlsd_host* host);
@@ -75,6 +80,43 @@ static const u8 tuning_blk_pattern_8bit[] = {
 	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
 };
 
+static void sdhc_debug_status(struct amlsd_host* host)
+{
+    switch (sdhc_debug_flag)
+    {
+        case 1:
+            host->status = HOST_TX_FIFO_EMPTY;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;
+        case 2:
+            host->status = HOST_RX_FIFO_FULL;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;  
+        case 3:
+            host->status = HOST_RSP_CRC_ERR;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;  
+        case 4:
+            host->status = HOST_DAT_CRC_ERR;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;              
+        case 5:
+            host->status = HOST_DAT_TIMEOUT_ERR;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;   
+        case 6:
+            host->status = HOST_RSP_TIMEOUT_ERR;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break; 
+                                    
+        default:            
+            break;
+    }
+    
+    //only enable once for debug
+    sdhc_debug_flag = 0;
+}
+
 struct aml_tuning_data {
 	const u8 *blk_pattern;
 	unsigned int blksz;
@@ -440,6 +482,7 @@ static void aml_sdhc_reg_init(struct amlsd_host* host)
     pdma->txfifo_th = 49; // means 49
     pdma->rd_burst = 15; // means 8
     pdma->rxfifo_th = 8; // means 8
+    pdma->rxfifo_manual_flush = 1; // bit[29]=1, bit[30]=0
     // pdma->rd_burst = 3;
     // pdma->wr_burst = 3;
     // pdma->rxfifo_th = 7;
@@ -456,7 +499,7 @@ static void aml_sdhc_reg_init(struct amlsd_host* host)
     venhc = readl(host->base+SDHC_ENHC);
     enhc->rxfifo_th = 60;
     enhc->dma_rd_resp = 0;
-    enhc->dma_wr_resp = 1;
+    enhc->dma_wr_resp = 0; // 1;
     enhc->sdio_irq_period = 12;
     enhc->rx_timeout = 255;
     writel(venhc, host->base + SDHC_ENHC);
@@ -478,17 +521,18 @@ int aml_sdhc_wait_ready(struct amlsd_host* host, u32 timeout)
     for(i=0; i< timeout; i++){
         vstat = readl(host->base + SDHC_STAT);
         stat = (struct sdhc_stat*)&vstat;
+
         esta = readl(host->base + SDHC_ESTA);
-        if(!stat->cmd_busy && (!((esta << 11) & 7)))
+        if(!stat->cmd_busy && (!((esta >> 11) & 7)))
         //if(!stat->cmd_busy)
             return 0;
         udelay(1);
     }
 
     sdhc_err("SDHC_STAT=%#x, sdhc controller is busy.\n", vstat);
-    aml_sdhc_print_reg(host);
+    //aml_sdhc_print_reg(host);
     aml_sdhc_host_reset(host);
-    WARN_ON(1);
+    //WARN_ON(1);
     return -1;
 }
 
@@ -691,7 +735,6 @@ void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
         //send.r1b = 1;
         //sdhc_err("cmd %d set r1b\n", mrq->cmd->opcode);
     //}
-    
 
     if(mrq->data){
         if(((mrq->cmd->opcode == SD_IO_RW_DIRECT) || (mrq->cmd->opcode == SD_IO_RW_EXTENDED))
@@ -745,7 +788,10 @@ void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
          * wait dma done interrupt(int[11]), don't need care about
          * dat0 busy or not.
          */
-        ictl.dma_done = 1;
+        if(mrq->data->flags & MMC_DATA_WRITE)
+            ictl.dma_done = 1; // for hardware automatical flush
+        else
+            ictl.data_xfer_ok = 1; // for software flush
     }else
         ictl.resp_ok = 1;
 
@@ -997,8 +1043,15 @@ static void aml_sdhc_timeout(struct work_struct *work)
     // u32 vista = readl(host->base + SDHC_ISTA);
     // struct sdhc_ista* ista = (struct sdhc_ista*)&vista;
     struct mmc_request* mrq;
+    struct amlsd_platform* pdata = mmc_priv(host->mmc);
+    
     unsigned long flags;
 
+	struct timeval ts_current;
+	unsigned long time_start_cnt = READ_CBUS_REG(ISA_TIMERE);
+	
+    time_start_cnt = (time_start_cnt - host->time_req_sta) / 1000;
+	
     BUG_ON(!host->mrq || !host->mrq->cmd);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
@@ -1010,33 +1063,48 @@ static void aml_sdhc_timeout(struct work_struct *work)
 
     if ((host->xfer_step == XFER_IRQ_TASKLET_DATA) 
             || (host->xfer_step == XFER_IRQ_TASKLET_CMD)) {
-        schedule_delayed_work(&host->timeout, 10);
+        schedule_delayed_work(&host->timeout, 50);
+        host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);
         
         timeout_cnt++;
-        if (timeout_cnt > 100)
+        if (timeout_cnt > 30)
             goto timeout_handle;
 
         spin_unlock_irqrestore(&host->mrq_lock, flags);
 
-        sdhc_err("%s: cmd%d, ISR have been run, xfer_step=%d\n",
-                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step);
+        sdhc_err("%s: cmd%d, ISR have been run, xfer_step=%d, time_start_cnt=%dmS, timeout_cnt=%d\n",
+                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step, time_start_cnt, timeout_cnt);
         return;
     }
 timeout_handle:
     timeout_cnt = 0;
 
     mrq = host->mrq;
-    spin_unlock_irqrestore(&host->mrq_lock, flags);
-
-    aml_sdhc_status(host);
-
-    spin_lock_irqsave(&host->mrq_lock, flags);
     host->xfer_step_prev = host->xfer_step;
     host->xfer_step = XFER_TIMER_TIMEOUT;
     mrq->cmd->error = -ETIMEDOUT;
+
+    if(aml_card_type_sd(pdata)){
+        sdhc_error_flag |= (1<<30);
+        host->mrq->cmd->retries = 0;        
+    }else if((sdhc_error_flag & (1<<3) == 0)  && (mrq->data != NULL)
+            && pdata->is_in){  //set cmd retry cnt when first error.
+        sdhc_error_flag |= (1<<3);
+        mrq->cmd->retries = AML_TIMEOUT_RETRY_COUNTER; 
+    }   
+
+    if(sdhc_error_flag && (mrq->cmd->retries == 0)){
+        sdhc_error_flag |= (1<<30);
+        sdhc_err("Command retried failed\n");
+    }
+        
     spin_unlock_irqrestore(&host->mrq_lock, flags);
 
+    aml_sdhc_status(host);
+
     aml_sdhc_read_response(host->mmc, mrq->cmd);
+    sdhc_err("time_start_cnt:%d\n", time_start_cnt);
+
     aml_sdhc_print_err(host);
 
     /*read response, if error, set -EILSEQ, then retry in aml_sdhc_request_done*/
@@ -1089,8 +1157,24 @@ timeout_handle:
 // req_done:
     aml_sdhc_host_reset(host);
     /*write 1 clear irq status reg*/
-    // writel(vista, host->base+SDHC_ISTA);
-    aml_sdhc_request_done(host->mmc, mrq);
+    //writel(vista, host->base+SDHC_ISTA);
+ 
+    //do not send stop for sdio wifi case 
+    if(host->mrq->stop && (!aml_card_type_sd(pdata)) && !host->cmd_is_stop){
+    //if((host->mrq->cmd->opcode != SD_IO_RW_DIRECT) && (host->mrq->cmd->opcode != SD_IO_RW_EXTENDED) 
+   //         && (!mmc_card_removed(pdata->mmc->card)) && (!mrq->data)){
+        spin_lock_irqsave(&host->mrq_lock, flags);
+        aml_sdhc_send_stop(host);                
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        schedule_delayed_work(&host->timeout, 1);
+    }
+    else{
+        if (host->cmd_is_stop)
+            host->cmd_is_stop = 0;
+
+        aml_sdhc_request_done(host->mmc, mrq);
+    }          
+      
     return ;
 }
 
@@ -1124,9 +1208,11 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if (aml_check_unsupport_cmd(mmc, mrq))
         return;
 
-    if(!pdata->is_in){
+    //only for SDCARD
+    if(!pdata->is_in || (!host->init_flag && aml_card_type_sd(pdata))){
         spin_lock_irqsave(&host->mrq_lock, flags);
         mrq->cmd->error = -ENOMEDIUM;
+        mrq->cmd->retries = 0;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         mmc_request_done(mmc, mrq);
         return;
@@ -1159,9 +1245,16 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
         fifo_empty_cnt = 0;
         fifo_full_cnt = 0;
         timeout_cnt = 0;
+        host->init_flag = 1;
     }
+    
     if (mrq->cmd->opcode == 25)
         cmd25_cnt++;
+       
+    //clear error flag if last command retried failed here    
+    if(sdhc_error_flag & (1<<30)){
+        sdhc_error_flag = 0;
+    }
 
     /*setup reg  especially for cmd with transfering data*/
     if(mrq->data) {
@@ -1190,6 +1283,7 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
     else
         timeout = 500;//mod_timer(&host->timeout_tlist,
                 //jiffies + 500/*10*nsecs_to_jiffies(mrq->data->timeout_ns)*/); // 5s
+             
     schedule_delayed_work(&host->timeout, timeout);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
@@ -1202,13 +1296,14 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
     host->xfer_step = XFER_START;
     host->opcode = mrq->cmd->opcode;
     host->arg = mrq->cmd->arg;
+    host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);
 
     /*setup reg for all cmd*/
     aml_sdhc_start_cmd(pdata, mrq);
     host->xfer_step = XFER_AFTER_START;
     spin_unlock_irqrestore(&host->mrq_lock, flags);
 }
-
+    
 static int aml_sdhc_status (struct amlsd_host* host)
 {
     int ret = -1; // error
@@ -1254,6 +1349,11 @@ static int aml_sdhc_status (struct amlsd_host* host)
             ret = 0; // ok
             goto _status_exit;
         }
+        if(ista->data_xfer_ok){
+            host->status = HOST_TASKLET_DATA;
+            ret = 0; // ok
+            goto _status_exit;
+        }
         if(ista->resp_ok_noclear){
             host->status = HOST_TASKLET_CMD;
             ret = 0; // ok
@@ -1262,6 +1362,10 @@ static int aml_sdhc_status (struct amlsd_host* host)
     }
     ret = 0; // ok
 _status_exit:
+    
+    //for debug
+    //sdhc_debug_status(host);
+
     spin_unlock_irqrestore(&host->mrq_lock, flags);
     return ret;
 }
@@ -1278,7 +1382,14 @@ static irqreturn_t aml_sdhc_irq(int irq, void *dev_id)
     u32 victl = readl(host->base + SDHC_ICTL);
     u32 vista = readl(host->base + SDHC_ISTA);
 
+    //if(sdhc_debug_flag == 9){
+    //    sdhc_err("FORCE ignore IRQ here\n");
+    //    sdhc_debug_flag = 0;
+    //    return IRQ_HANDLED;
+    //}
+        
     spin_lock_irqsave(&host->mrq_lock, flags);
+       
     mrq = host->mrq;
     mmc = host->mmc;
     pdata = mmc_priv(mmc);
@@ -1384,17 +1495,16 @@ struct mmc_request aml_sdhc_stop = {
     .cmd = &aml_sdhc_cmd,
 };
 
-int err_bak;
 void aml_sdhc_send_stop(struct amlsd_host* host)
 {
     struct amlsd_platform * pdata = mmc_priv(host->mmc);
     unsigned long flags;
 
     // sdhc_err("before cmd12\n");
-    
+   
     /*Already in mrq_lock*/
     spin_lock_irqsave(&host->mrq_lock, flags);
-    err_bak = host->mrq->cmd->error;
+    sdhc_err_bak = host->mrq->cmd->error;
     host->mrq->cmd->error = 0;
     host->cmd_is_stop = 1;
     spin_unlock_irqrestore(&host->mrq_lock, flags);
@@ -1412,23 +1522,25 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
     unsigned long flags;
     u32 vstat, status;
     struct sdhc_stat* stat = (struct sdhc_stat*)&vstat;
-    struct amlsd_platform* pdata;
+    struct amlsd_platform* pdata = mmc_priv(host->mmc);
     int cnt=0;
+    u32 esta = readl(host->base + SDHC_ESTA);
+    u32 vpdma = readl(host->base+SDHC_PDMA);   
+    struct sdhc_pdma* pdma = (struct sdhc_pdma*)&vpdma;
 
     spin_lock_irqsave(&host->mrq_lock, flags);
-    if ((host->xfer_step != XFER_IRQ_OCCUR) && (host->xfer_step != XFER_IRQ_TASKLET_BUSY)) {
-        sdhc_err("host->xfer_step=%d\n", host->xfer_step);
-    }
-
-    // if(host->xfer_step == XFER_TIMER_TIMEOUT){
-        // sdhc_err("Timeout Return\n");
-        // return IRQ_HANDLED;
-    // }
-
     mrq = host->mrq;
     xfer_step = host->xfer_step;
     status = host->status;
     
+    if ((xfer_step == XFER_FINISHED) || (xfer_step == XFER_TIMER_TIMEOUT)) {
+        sdhc_err("Warning: xfer_step=%d, host->status=%d\n", xfer_step, status);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        return IRQ_HANDLED;
+    }
+
+    WARN_ON((host->xfer_step != XFER_IRQ_OCCUR) && (host->xfer_step != XFER_IRQ_TASKLET_BUSY));
+
     if(!mrq){
         sdhc_err("!mrq xfer_step %d\n", xfer_step);
         if(xfer_step == XFER_FINISHED ||
@@ -1436,14 +1548,15 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
             spin_unlock_irqrestore(&host->mrq_lock, flags);
             return IRQ_HANDLED;
         }
-        BUG();
+        //BUG();
+        aml_sdhc_print_err(host);
     }
     if(host->cmd_is_stop){
         int delay = 1;
         if (mrq->cmd->error)
             sdhc_err("cmd12 error %d\n", mrq->cmd->error);
         host->cmd_is_stop = 0;
-        mrq->cmd->error = err_bak;
+        mrq->cmd->error = sdhc_err_bak;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         msleep(delay);
         sdhc_err("delay %dms\n", delay);
@@ -1456,12 +1569,28 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
 
     switch (status) {
         case HOST_TASKLET_DATA:
+            sdhc_error_flag = 0;
             BUG_ON(!mrq->data);
             cancel_delayed_work(&host->timeout);
 
             xfer_bytes = mrq->data->blksz*mrq->data->blocks;
             /* copy buffer from dma to data->sg in read cmd*/
             if(host->mrq->data->flags & MMC_DATA_READ){
+                int i;
+                for(i=0; i< STAT_POLL_TIMEOUT; i++){
+                    esta = readl(host->base + SDHC_ESTA);
+                    esta = readl(host->base + SDHC_ESTA); // read twice, we just focus on the second result
+                    if (((esta >> 11) & 7) == 0) // REGC_ESTA[13:11]=0? then OK
+                        break;
+                    else if (i == 0)
+                        sdhc_err("SDHC_ESTA=%#x", esta);
+                }
+                if (i == STAT_POLL_TIMEOUT) // error
+                    sdhc_err("Warning: DMA state is wrong! SDHC_ESTA=%#x", esta);
+
+                pdma->rxfifo_manual_flush |= 0x02; // bit[30]
+                writel(vpdma, host->base+SDHC_PDMA);
+
                 aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len, host->bn_buf,
                             xfer_bytes, 0);
                 sdhc_dbg(AMLSD_DBG_RD_DATA, "R Cmd%d, arg %#x, size=%d\n",
@@ -1488,12 +1617,14 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
             mrq->data->bytes_xfered = xfer_bytes;
             host->xfer_step = XFER_TASKLET_DATA;
             spin_unlock_irqrestore(&host->mrq_lock, flags);
+            //do not check device ready status here
             aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
             aml_sdhc_read_response(host->mmc, mrq->cmd);
             // aml_sdhc_clear_fifo(host);
             aml_sdhc_request_done(host->mmc, mrq);
             break;
         case HOST_TASKLET_CMD:
+            sdhc_error_flag = 0;
             if(!host->mrq->data){
                 cancel_delayed_work(&host->timeout);
                 spin_lock_irqsave(&host->mrq_lock, flags);
@@ -1508,17 +1639,47 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
             }
             break;
         case HOST_TX_FIFO_EMPTY:
+        case HOST_RX_FIFO_FULL:   
+        case HOST_RSP_TIMEOUT_ERR:
+        case HOST_DAT_TIMEOUT_ERR:                                 
             cancel_delayed_work(&host->timeout);
             aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
             aml_sdhc_read_response(host->mmc, host->mrq->cmd);
             aml_sdhc_print_err(host);
             aml_sdhc_host_reset(host);
             writel(SDHC_ISTA_W1C_ALL, host->base+SDHC_ISTA);
-            aml_sdhc_send_stop(host);
-            break;
-        case HOST_RX_FIFO_FULL:
-            aml_sdhc_not_timeout_err_handler(host);
+            spin_lock_irqsave(&host->mrq_lock, flags);
+            if(sdhc_error_flag == 0){  //set cmd retry cnt when first error.
+                sdhc_error_flag |= (1<<0);
+                if(mrq->data == NULL){
+                    mrq->cmd->retries = 0;
+                }
+                else if((status == HOST_RSP_TIMEOUT_ERR) || (status == HOST_DAT_TIMEOUT_ERR)){
+                    mrq->cmd->retries = AML_TIMEOUT_RETRY_COUNTER; 
+                }
+                else{
+                    mrq->cmd->retries = AML_ERROR_RETRY_COUNTER;                     
+                }
+            } 
+            if(sdhc_error_flag && (mrq->cmd->retries == 0)){
+                sdhc_error_flag |= (1<<30);
+                //sdhc_err("Command retried failed\n");
+            }    
+            spin_unlock_irqrestore(&host->mrq_lock, flags);
+                          
+            //do not send stop for sdio wifi case 
+            if(host->mrq->stop && pdata->is_in){
+            //if((host->mrq->cmd->opcode != SD_IO_RW_DIRECT) && (host->mrq->cmd->opcode != SD_IO_RW_EXTENDED) 
+           //         && (!mmc_card_removed(pdata->mmc->card)) && (!mrq->data)){
+                aml_sdhc_send_stop(host);                
+            }
+            else{
+                aml_sdhc_request_done(host->mmc, mrq);
+            }
             break;
+        //case HOST_RX_FIFO_FULL:
+        //    aml_sdhc_not_timeout_err_handler(host);
+        //    break;
         case HOST_RSP_CRC_ERR:
         case HOST_DAT_CRC_ERR:
             pdata = mmc_priv(host->mmc);
@@ -1532,25 +1693,37 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
                     if(cnt >= (ARRAY_SIZE(clock) - 1))
                         break;
                 }
+                spin_lock_irqsave(&host->mrq_lock, flags);
+
                 host->mmc->ios.clock = clock[cnt]; 
                 aml_sdhc_set_clk_rate(host->mmc,host->mmc->ios.clock);
 
-                spin_lock_irqsave(&host->mrq_lock, flags);
                 pdata->need_retuning = true; // retuing will be done in the next request
                 mrq->cmd->retries = (ARRAY_SIZE(clock) - 1) - cnt;
-                spin_unlock_irqrestore(&host->mrq_lock, flags);
             }
+            else{
+                spin_lock_irqsave(&host->mrq_lock, flags);
+
+                if(sdhc_error_flag == 0){  //set cmd retry cnt when first error.
+                    sdhc_error_flag |= (1<<1);
+                    mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
+                }                 
+            } 
+            if(sdhc_error_flag && (mrq->cmd->retries == 0)){
+                sdhc_error_flag |= (1<<30);
+                //sdhc_err("Command retried failed\n");
+            }       
+            spin_unlock_irqrestore(&host->mrq_lock, flags);
+    
             aml_sdhc_not_timeout_err_handler(host);
             break;
-        case HOST_RSP_TIMEOUT_ERR:
-        case HOST_DAT_TIMEOUT_ERR:
-            aml_sdhc_com_err_handler(host);
-            break;
+
         default:
             sdhc_err("BUG xfer_step=%d, host->status=%d\n", xfer_step, status);
-            BUG();
+            aml_sdhc_print_err(host);
+            //BUG();
     }
-
+    
     return IRQ_HANDLED;
 }
 
@@ -1917,6 +2090,40 @@ static const struct mmc_host_ops aml_sdhc_ops = {
 /*for multi host claim host*/
 static struct mmc_claim aml_sdhc_claim;
 
+static ssize_t sdhc_debug_func(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
+    
+    sscanf(buf, "%x", &sdhc_debug_flag);    
+    printk("sdhc_debug_flag: %d\n", sdhc_debug_flag);
+
+    return count;
+}
+            
+static ssize_t show_sdhc_debug(struct class *class,
+                    struct class_attribute *attr,	char *buf)
+{
+    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
+    
+    printk("sdhc_debug_flag: %d\n", sdhc_debug_flag);
+    
+    printk("1 : Force sdhc HOST_TX_FIFO_EMPTY error \n");
+    printk("2 : Force sdhc HOST_RX_FIFO_FULL error \n");
+    printk("3 : Force sdhc HOST_RSP_CRC_ERR error \n");
+    printk("4 : Force sdhc HOST_DAT_CRC_ERR error \n");
+    printk("5 : Force sdhc HOST_DAT_TIMEOUT_ERR error \n");
+    printk("6 : Force sdhc HOST_RSP_TIMEOUT_ERR error \n");
+
+    printk("9 : Force sdhc irq timeout error \n");
+    
+    return 0;
+}
+
+static struct class_attribute sdhc_class_attrs[] = {
+    __ATTR(debug,  S_IRUGO | S_IWUSR , show_sdhc_debug, sdhc_debug_func),
+    __ATTR_NULL
+};
+
 static struct amlsd_host* aml_sdhc_init_host(void)
 {
     struct amlsd_host *host;
@@ -1948,6 +2155,8 @@ static struct amlsd_host* aml_sdhc_init_host(void)
 
     INIT_LIST_HEAD(&host->sibling);
     
+    host->init_flag = 1;
+    
     host->version = AML_MMC_VERSION;
     host->storage_flag = storage_flag;
     host->pinctrl = NULL;
@@ -1967,6 +2176,12 @@ static struct amlsd_host* aml_sdhc_init_host(void)
     sdhc_err("CONFIG_AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW is on!\n");
 #endif
 
+	host->debug.name = kzalloc(strlen((const char*)AML_SDHC_MAGIC)+1, GFP_KERNEL);
+	strcpy(host->debug.name, (char*)AML_SDHC_MAGIC);
+	host->debug.class_attrs = sdhc_class_attrs;
+	if(class_register(&host->debug))
+		printk(" class register nand_class fail!\n");
+		
     return host;
 }
 
@@ -2050,6 +2265,12 @@ static int aml_sdhc_probe(struct platform_device *pdev)
         mmc->max_current_180 = 300; // 300 mA in 1.8V
         mmc->max_current_330 = 300; // 300 mA in 3.3V
 
+        if (aml_card_type_sdio(pdata)) { // if sdio_wifi
+            mmc->host_rescan_disable = true;
+        } else {
+            mmc->host_rescan_disable = false;
+        }
+
         if(pdata->port_init)
             pdata->port_init(pdata);
 
diff --git a/drivers/amlogic/mmc/aml_sdio.c b/drivers/amlogic/mmc/aml_sdio.c
index d30cc0ac2bbc..75a92dee0a93 100755
--- a/drivers/amlogic/mmc/aml_sdio.c
+++ b/drivers/amlogic/mmc/aml_sdio.c
@@ -43,6 +43,34 @@ int SDIO_IRQ_SUPPORT = 0;
 static int aml_sdio_timeout_cmd(struct amlsd_host *host);
 void aml_sdio_send_stop(struct amlsd_host* host);
 
+static unsigned int sdio_error_flag = 0;
+static unsigned int sdio_debug_flag = 0;
+static unsigned int sdio_err_bak;
+
+void sdio_debug_irqstatus(struct sdio_status_irq* irqs, struct cmd_send* send)
+{    
+    switch (sdio_debug_flag)
+    {
+        case 1:
+            irqs->sdio_response_crc7_ok = 0;
+            send->response_do_not_have_crc7 = 0;
+            
+            sdhc_err("Force sdio cmd response crc error here\n");
+            break;
+        case 2:
+            irqs->sdio_data_read_crc16_ok = 0;
+            irqs->sdio_data_write_crc16_ok = 0;
+            sdhc_err("Force sdio data crc here\n");
+            break;  
+                                    
+        default:            
+            break;
+    }
+    
+    //only enable once for debug
+    sdio_debug_flag = 0;
+}
+
 static void aml_sdio_soft_reset(struct amlsd_host* host)
 {
     struct sdio_irq_config irqc={0};
@@ -413,11 +441,16 @@ static void aml_sdio_timeout(struct work_struct *work)
     u32 virqc;
     struct sdio_irq_config* irqc;
     unsigned long flags;
-#ifdef      CONFIG_MMC_AML_DEBUG
+//#ifdef      CONFIG_MMC_AML_DEBUG
     struct amlsd_platform * pdata = mmc_priv(host->mmc);
-#endif
+//#endif
 	static int timeout_cmd_cnt = 0;
 
+	struct timeval ts_current;
+	unsigned long time_start_cnt = READ_CBUS_REG(ISA_TIMERE);
+	
+    
+    time_start_cnt = (time_start_cnt - host->time_req_sta) / 1000;
 
 //	if(host->mmc->caps & MMC_CAP_SDIO_IRQ){
 	if(SDIO_IRQ_SUPPORT)
@@ -447,13 +480,15 @@ static void aml_sdio_timeout(struct work_struct *work)
             || (host->xfer_step == XFER_IRQ_OCCUR)){    // isr have been run
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         //mod_timer(&host->timeout_tlist, jiffies + 10);
-        schedule_delayed_work(&host->timeout, 10);
+        schedule_delayed_work(&host->timeout, 50);
+        host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);    
         
         if(irqs->sdio_cmd_int) {
             timeout_cnt++;
-            if (timeout_cnt > 10)
+            if (timeout_cnt > 30)
                 goto timeout_handle;
-            sdio_err("%s: irq have been occured\n", mmc_hostname(host->mmc));
+            sdhc_err("%s: cmd%d, ISR have been run, xfer_step=%d, time_start_cnt=%dmS, timeout_cnt=%d\n",
+                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step, time_start_cnt, timeout_cnt);        
         }
         else
             sdio_err("%s: isr have been run\n",  mmc_hostname(host->mmc));
@@ -476,10 +511,27 @@ timeout_handle:
     writel(virqc, host->base + SDIO_IRQC);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
+    
+    //do not retry for sdcard
+    if(aml_card_type_sd(pdata)){
+        sdio_error_flag |= (1<<30);
+        host->mrq->cmd->retries = 0;
+    }else if((sdio_error_flag & (1<<3) == 0) && (host->mrq->data != NULL) 
+            && pdata->is_in ){  //set cmd retry cnt when first error.
+        sdio_error_flag |= (1<<3);
+        host->mrq->cmd->retries = AML_TIMEOUT_RETRY_COUNTER; 
+    }   
+    
+    //here clear error flags after error retried
+    if(sdio_error_flag && (host->mrq->cmd->retries == 0)){
+        sdio_error_flag |= (1<<30);
+    } 
+    
     host->xfer_step = XFER_TIMEDOUT;
     host->mrq->cmd->error = -ETIMEDOUT;
     spin_unlock_irqrestore(&host->mrq_lock, flags);
     
+    sdio_err("time_start_cnt:%d\n", time_start_cnt);
     aml_sdio_print_err(host, "Timeout error");
     // if (pdata->port == MESON_SDIO_PORT_A) {
         // sdio_err("power_on_pin=%d\n",
@@ -497,10 +549,25 @@ timeout_handle:
     aml_dbg_verify_pull_up(pdata);
     aml_sdio_print_reg(host);
     // aml_dbg_print_pinmux();
-#endif
+#endif 
 
-    /*request done*/
-    aml_sdio_request_done(host->mmc, host->mrq);
+    if(host->mrq->stop && (!aml_card_type_sd(pdata)) && !host->cmd_is_stop){
+        // sdio_err("Send stop cmd before timeout retry..\n");
+        spin_lock_irqsave(&host->mrq_lock, flags);
+        aml_sdio_send_stop(host);                
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        schedule_delayed_work(&host->timeout, 1);
+    }
+    else{
+            /*request done*/
+        // sdio_err("Just stop without retry..\n");
+
+        if (host->cmd_is_stop)
+            host->cmd_is_stop = 0;
+
+        aml_sdio_request_done(host->mmc, host->mrq);
+    }
+            
 
     // spin_lock_irqsave(&host->mrq_lock, flags);
     // WARN_ON(!host->mrq->cmd);
@@ -530,7 +597,6 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
     enum aml_mmc_waitfor    xfer_step;
 
     spin_lock_irqsave(&host->mrq_lock, flags);
-
 	
     if((virqs >> sdio_cmd_busy_bit) & 0x1) 
     {      
@@ -543,12 +609,19 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
     mrq = host->mrq;
     xfer_step = host->xfer_step;
 	
+	// sdio_debug_irqstatus(irqs, send);
+	
     if(!mrq->data){
         if(irqs->sdio_response_crc7_ok || send->response_do_not_have_crc7)
             mrq->cmd->error = 0;
         else {
             mrq->cmd->error = -EILSEQ;
+            if(sdio_error_flag == 0){  //set cmd retry cnt when first error.
+                sdio_error_flag |= (1<<0);
+                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
+            }    
             aml_sdio_print_err(host, "cmd crc7 error");
+            
         }
        spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdio_request_done(host->mmc, mrq);
@@ -557,7 +630,12 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
             mrq->cmd->error = 0;
         else {
             mrq->cmd->error = -EILSEQ;
+            if(sdio_error_flag == 0){  //set cmd retry cnt when first error.
+                sdio_error_flag |= (1<<0);
+                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
+            }                
             aml_sdio_print_err(host, "data crc16 error");
+            
         }
         mrq->data->bytes_xfered = mrq->data->blksz*mrq->data->blocks;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
@@ -570,6 +648,12 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
                 host->bn_buf[2], host->bn_buf[3]);
         }
         spin_lock_irqsave(&host->mrq_lock, flags);
+
+        if((mrq->cmd->error == 0) 
+            || (sdio_error_flag && (mrq->cmd->retries == 0))){
+            sdio_error_flag = 0;
+        }
+                
         if(mrq->stop){
             aml_sdio_send_stop(host);
             spin_unlock_irqrestore(&host->mrq_lock, flags);
@@ -607,9 +691,18 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if (aml_check_unsupport_cmd(mmc, mrq))
         return;
 
-    if(!pdata->is_in){
+    //only for SDCARD hotplag
+    if(!pdata->is_in || (!host->init_flag && aml_card_type_sd(pdata))){
+        spin_lock_irqsave(&host->mrq_lock, flags);
         mrq->cmd->error = -ENOMEDIUM;
+        mrq->cmd->retries = 0;
+        host->mrq = NULL;
+        host->xfer_step = XFER_FINISHED;        
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        
+        //aml_sdio_request_done(mmc, mrq);
         mmc_request_done(mmc, mrq);
+
         return;
     }
 
@@ -620,10 +713,14 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     host->req_cnt++;
 #endif
 
+    if (mrq->cmd->opcode == 0) {
+        host->init_flag = 1;
+    }
+
     sdio_dbg(AMLSD_DBG_REQ ,"%s: starting CMD%u arg %08x flags %08x\n",
         mmc_hostname(mmc), mrq->cmd->opcode,
         mrq->cmd->arg, mrq->cmd->flags);
-
+    
     if(mrq->data) {
         /*Copy data to dma buffer for write request*/
         aml_sdio_prepare_dma(host, mrq);
@@ -654,6 +751,7 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
         timeout = 500;//mod_timer(&host->timeout_tlist,
                 //jiffies + 500/*10*nsecs_to_jiffies(mrq->data->timeout_ns)*/); // 5s
 //	if(mmc->caps & MMC_CAP_SDIO_IRQ){
+
 	if(SDIO_IRQ_SUPPORT){
 		schedule_delayed_work(&host->timeout, timeout/20); 
 	}else{
@@ -666,11 +764,17 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if(host->xfer_step != XFER_FINISHED && host->xfer_step != XFER_INIT)
         sdio_err("host->xfer_step %d\n", host->xfer_step);
 
+    //clear error flag if last command retried failed here    
+    if(sdio_error_flag & (1<<30)){
+        sdio_error_flag = 0;
+    }
+    
     host->mrq = mrq;
     host->mmc = mmc;
     host->xfer_step = XFER_START;
     host->opcode = mrq->cmd->opcode;
     host->arg = mrq->cmd->arg;
+    host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);    
 
     // if(mrq->data){
         // sdio_dbg(AMLSD_DBG_REQ ,"%s: blksz %d blocks %d flags %08x "
@@ -699,6 +803,8 @@ void aml_sdio_send_stop(struct amlsd_host* host)
 {
     /*Already in mrq_lock*/
     host->cmd_is_stop = 1;
+    sdio_err_bak = host->mrq->cmd->error;
+    host->mrq->cmd->error = 0;
     aml_sdio_start_cmd(host->mmc, &aml_sdio_stop);
 }
 
@@ -714,6 +820,12 @@ static irqreturn_t aml_sdio_irq(int irq, void *dev_id)
     struct mmc_request* mrq;
     unsigned long flags;
 
+    //if(sdio_debug_flag == 9){
+    //    sdio_err("FORCE ignore IRQ here\n");
+    //    sdio_debug_flag = 0;
+    //    return IRQ_HANDLED;
+    //}
+    
     spin_lock_irqsave(&host->mrq_lock, flags);
     mrq = host->mrq;
    // if(!mrq){
@@ -760,6 +872,7 @@ static irqreturn_t aml_sdio_irq(int irq, void *dev_id)
     return IRQ_HANDLED;
 }
 
+
 irqreturn_t aml_sdio_irq_thread(int irq, void *data)
 {
     struct amlsd_host* host = (void*)data;
@@ -780,6 +893,13 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
     spin_lock_irqsave(&host->mrq_lock, flags);
     mrq = host->mrq;
     xfer_step = host->xfer_step;
+
+    if ((xfer_step == XFER_FINISHED) || (xfer_step == XFER_TIMER_TIMEOUT)) {
+        sdhc_err("Warning: xfer_step=%d\n", xfer_step);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        return IRQ_HANDLED;
+    }
+
     if(!mrq){
         sdio_err("CMD%u, arg %08x, mrq NULL xfer_step %d\n", host->opcode, host->arg, xfer_step);
         if(xfer_step == XFER_FINISHED ||
@@ -794,6 +914,7 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
     }
     if(host->cmd_is_stop){
         host->cmd_is_stop = 0;
+        mrq->cmd->error = sdio_err_bak;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdio_request_done(host->mmc, mrq);
         return IRQ_HANDLED;
@@ -806,9 +927,19 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             spin_unlock_irqrestore(&host->mrq_lock, flags);
         } else {
             mrq->cmd->error = -EILSEQ;
+            if(sdio_error_flag == 0){  //set cmd retry cnt when first error.
+                sdio_error_flag |= (1<<0);
+                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
+            }            
             spin_unlock_irqrestore(&host->mrq_lock, flags);
             aml_sdio_print_err(host, "cmd crc7 error");
         }
+        spin_lock_irqsave(&host->mrq_lock, flags);
+        if((mrq->cmd->error == 0) || (sdio_error_flag && (mrq->cmd->retries == 0))){
+            sdio_error_flag = 0;
+        } 
+                
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdio_request_done(host->mmc, mrq);
     }else{
         if(irqs->sdio_data_read_crc16_ok||irqs->sdio_data_write_crc16_ok) {
@@ -816,10 +947,21 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             spin_unlock_irqrestore(&host->mrq_lock, flags);
         } else {
             mrq->cmd->error = -EILSEQ;
+            if(sdio_error_flag == 0){  //set cmd retry cnt when first error.
+                sdio_error_flag |= (1<<0);
+                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
+            }
             spin_unlock_irqrestore(&host->mrq_lock, flags);
             aml_sdio_print_err(host, "data crc16 error");
         }
+		spin_lock_irqsave(&host->mrq_lock, flags);
         mrq->data->bytes_xfered = mrq->data->blksz*mrq->data->blocks;
+       
+        if((mrq->cmd->error == 0) || (sdio_error_flag && (mrq->cmd->retries == 0))){
+            sdio_error_flag = 0;
+        } 
+               
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
         if(mrq->data->flags & MMC_DATA_READ){
             aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len,
                 host->bn_buf, mrq->data->blksz*mrq->data->blocks, 0);
@@ -838,6 +980,7 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             aml_sdio_request_done(host->mmc, mrq);
         }
     }
+    
     return IRQ_HANDLED;
 }
 
@@ -1066,6 +1209,34 @@ static const struct mmc_host_ops aml_sdio_ops = {
     .get_ro = aml_sdio_get_ro,
 };
 
+static ssize_t sdio_debug_func(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
+    
+    sscanf(buf, "%x", &sdio_debug_flag);    
+    printk("sdio_debug_flag: %d\n", sdio_debug_flag);
+
+    return count;
+}
+
+static ssize_t show_sdio_debug(struct class *class,
+                    struct class_attribute *attr,	char *buf)
+{
+    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
+    
+    printk("sdio_debug_flag: %d\n", sdio_debug_flag);
+    printk("1 : Force sdio cmd crc error \n");
+    printk("2 : Force sdio data crc error \n");
+    printk("9 : Force sdio irq timeout error \n");
+
+    return 0;
+}
+
+static struct class_attribute sdio_class_attrs[] = {
+    __ATTR(debug,  S_IRUGO | S_IWUSR , show_sdio_debug, sdio_debug_func),
+    __ATTR_NULL
+};
+
 static struct amlsd_host* aml_sdio_init_host(void)
 {
     struct amlsd_host *host;
@@ -1098,11 +1269,20 @@ static struct amlsd_host* aml_sdio_init_host(void)
     host->version = AML_MMC_VERSION;
     host->storage_flag = storage_flag;
     host->pinctrl = NULL;
+    
+    host->init_flag = 1;
 
 #ifdef      CONFIG_MMC_AML_DEBUG
     host->req_cnt = 0;
     sdio_err("CONFIG_MMC_AML_DEBUG is on!\n");
 #endif
+
+	host->debug.name = kzalloc(strlen((const char*)AML_SDIO_MAGIC)+1, GFP_KERNEL);
+	strcpy(host->debug.name, (char*)AML_SDIO_MAGIC);
+	host->debug.class_attrs = sdio_class_attrs;
+	if(class_register(&host->debug))
+		printk(" class register nand_class fail!\n");
+		
     return host;
 }
 
@@ -1193,6 +1373,12 @@ static int aml_sdio_probe(struct platform_device *pdev)
         mmc->f_min = pdata->f_min;
         mmc->f_max = pdata->f_max;
 
+        if (aml_card_type_sdio(pdata)) { // if sdio_wifi
+            mmc->host_rescan_disable = true;
+        } else {
+            mmc->host_rescan_disable = false;
+        }
+
         if(pdata->port_init)
             pdata->port_init(pdata);
 
diff --git a/drivers/amlogic/mmc/amlsd.c b/drivers/amlogic/mmc/amlsd.c
index 1c6340d0ab8d..13bd26a95def 100755
--- a/drivers/amlogic/mmc/amlsd.c
+++ b/drivers/amlogic/mmc/amlsd.c
@@ -1152,10 +1152,15 @@ irqreturn_t aml_irq_cd_thread(int irq, void *data)
 {
 	struct amlsd_platform *pdata = (struct amlsd_platform*)data;
 
-    mdelay(500);
+    mdelay(20);
     aml_sd_uart_detect(pdata);
-
-    mmc_detect_change(pdata->mmc, msecs_to_jiffies(500));
+    
+    if((pdata->is_in == 0) && aml_card_type_sd(pdata)) {
+        pdata->host->init_flag = 0;
+    }
+        
+    //mdelay(500);
+    mmc_detect_change(pdata->mmc, msecs_to_jiffies(200));
 
 	return IRQ_HANDLED;
 }
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 951a20b5f28f..7ddd9e1833cb 100755
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -1400,7 +1400,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 		brq->data.flags |= MMC_DATA_READ;
 	} else {
 		brq->cmd.opcode = writecmd;
-		brq->cmd.retries = 5; // for eMMC debug
+		//brq->cmd.retries = 5; // for eMMC debug
 		brq->data.flags |= MMC_DATA_WRITE;
 	}
 
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ea916f9abd4c..fde96dc1e835 100755
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2398,6 +2398,9 @@ void mmc_rescan(struct work_struct *work)
 	int i;
 	bool extend_wakelock = false;
 
+	if (host->host_rescan_disable)
+		return;
+
 	if (host->rescan_disable)
 		return;
 
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 847abe6fc154..963b0e729b62 100755
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1315,6 +1315,7 @@ static void sdio_rescan (struct mmc_host *host)
     int ret;
 
     host->rescan_entered = 0;
+	host->host_rescan_disable = false;
     mmc_detect_change(host, 0); // start the delayed_work
     ret = flush_work(&(host->detect.work)); // wait for the delayed_work to finish
     if (!ret) {
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f49198343184..e6de3709b802 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -334,6 +334,7 @@ struct mmc_host {
 
 	int			rescan_disable;	/* disable card detection */
 	int			rescan_entered;	/* used with nonremovable devices */
+	bool		host_rescan_disable;	/* disable card detection */
 
 	struct mmc_card		*card;		/* device attached to this host */
 
-- 
2.19.0

