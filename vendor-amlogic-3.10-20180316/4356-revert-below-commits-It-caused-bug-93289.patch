From a93ee42bf183f6037de0a6bebcb027e5478826d3 Mon Sep 17 00:00:00 2001
From: "tao.dong" <tao.dong@amlogic.com>
Date: Tue, 17 Jun 2014 17:27:56 +0800
Subject: [PATCH 4356/5965] revert below commits:It caused bug:93289: Revert
 "PD#92925:fix compile error for m6/m6tv" This reverts commit
 47537ff198b35702ee6f3beb9f6cfff0eaa5ad6c. Revert "PD#92925: MMC driver
 stablity improvement." This reverts commit
 15106bd24841925ae9c4af0121aa396ccf17d7e6.

---
 arch/arm/mach-meson6/include/mach/sd.h    |  59 +---
 arch/arm/mach-meson6tv/include/mach/sd.h  |  69 ++---
 arch/arm/mach-meson6tvd/include/mach/sd.h |  60 +----
 arch/arm/mach-meson8/include/mach/sd.h    |  12 +-
 arch/arm/mach-meson8b/include/mach/sd.h   |  12 +-
 drivers/amlogic/mmc/aml_sdhc_m8.c         | 313 ++++------------------
 drivers/amlogic/mmc/aml_sdio.c            | 208 +-------------
 drivers/amlogic/mmc/amlsd.c               |  11 +-
 drivers/mmc/card/block.c                  |   2 +-
 drivers/mmc/core/core.c                   |   3 -
 drivers/mmc/core/sdio.c                   |   1 -
 include/linux/mmc/host.h                  |   1 -
 12 files changed, 101 insertions(+), 650 deletions(-)

diff --git a/arch/arm/mach-meson6/include/mach/sd.h b/arch/arm/mach-meson6/include/mach/sd.h
index f68ccb03e648..149e04e6d514 100755
--- a/arch/arm/mach-meson6/include/mach/sd.h
+++ b/arch/arm/mach-meson6/include/mach/sd.h
@@ -13,11 +13,6 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
-#define     AML_ERROR_RETRY_COUNTER         5
-#define     AML_TIMEOUT_RETRY_COUNTER       2
-
-#define AML_SDHC_MAGIC			 "amlsdhc"
-#define AML_SDIO_MAGIC			 "amlsdio"
 enum aml_mmc_waitfor {
 	XFER_INIT,
 	XFER_START,				/* 1 */
@@ -38,19 +33,6 @@ enum aml_mmc_waitfor {
 	XFER_AFTER_START,		/* 16 */
 };
 
-enum aml_host_status { /* Host controller status */
-	HOST_INVALID = 0,       /* 0, invalid value used for initialization */
-	HOST_RX_FIFO_FULL = 1,  /* 1, start with 1 */
-	HOST_TX_FIFO_EMPTY,	    /* 2 */
-	HOST_RSP_CRC_ERR,	    /* 3 */
-	HOST_DAT_CRC_ERR,	    /* 4 */
-	HOST_RSP_TIMEOUT_ERR,   /* 5 */
-	HOST_DAT_TIMEOUT_ERR,   /* 6 */
-    HOST_ERR_END,	        /* 7, end of errors */
-	HOST_TASKLET_CMD,	    /* 8 */
-	HOST_TASKLET_DATA,	    /* 9 */
-};
-
 struct amlsd_host;
 struct amlsd_platform {
 	struct amlsd_host* host;
@@ -74,13 +56,9 @@ struct amlsd_platform {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int clkc;
-	unsigned int clk2;
 	unsigned int clkc_w;
 	unsigned int ctrl;
 	unsigned int clock;
-	unsigned int tune_phase;            /* store tuning result */
-	unsigned char signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
-
 	unsigned int low_burst;
 	unsigned int irq_in;
 	unsigned int irq_in_edge;
@@ -95,9 +73,6 @@ struct amlsd_platform {
     unsigned int jtag_pin;
     int is_sduart;
     bool is_in;
-    bool is_tuned;                      /* if card has been tuning */
-    bool need_retuning;
-	struct delayed_work	retuning;
 
     /* we used this flag to filter some unnecessary cmd before initialized flow */
     bool is_fir_init; // has been initialized for the first time
@@ -155,22 +130,21 @@ struct amlsd_host {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int f_min;
-	// struct tasklet_struct cmd_tlet;
-	// struct tasklet_struct data_tlet;
-	// struct tasklet_struct busy_tlet;
-	// struct tasklet_struct to_tlet;
+	struct tasklet_struct cmd_tlet;
+	struct tasklet_struct data_tlet;
+	struct tasklet_struct busy_tlet;
+	struct tasklet_struct to_tlet;
     // struct timer_list timeout_tlist;
 	struct delayed_work	timeout;
-	// struct early_suspend amlsd_early_suspend;
+	struct early_suspend amlsd_early_suspend;
 
-    struct class            debug;
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
-	// unsigned int clkc_w;
-	// unsigned int pdma;
-	// unsigned int pdma_s;
-	// unsigned int pdma_low;
+	unsigned int clkc_w;
+	unsigned int pdma;
+	unsigned int pdma_s;
+	unsigned int pdma_low;
 	unsigned int misc;
 	unsigned int ictl;
 	unsigned int ista;
@@ -183,19 +157,12 @@ struct amlsd_host {
 	spinlock_t	mrq_lock;
 	int			cmd_is_stop;
 	enum aml_mmc_waitfor	xfer_step;
-	enum aml_mmc_waitfor	xfer_step_prev;
 
 	int			bus_width;
 	int     port;
 	int     locked;
-    bool    is_gated;
-	// unsigned int		ccnt, dcnt;
-
-	int     status; // host status: xx_error/ok
-	int init_flag;
-
-    char    *msg_buf;
-#define MESSAGE_BUF_SIZE            512
+	char		*status;
+	unsigned int		ccnt, dcnt;
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debug_root;
@@ -209,15 +176,12 @@ struct amlsd_host {
 
     u32			opcode; // add by gch for debug
 	u32			arg; // add by gch for debug
-    u32         cmd25_cnt;
     
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
     u32         time_req_sta; // request start time
-    u32         reg_buf[16];
 #endif
-    u32         time_req_sta; // request start time
     
     struct pinctrl *pinctrl;
     char pinctrl_name[30];
@@ -584,7 +548,6 @@ struct sdhc_clk2{
 	u32 reserved:8; /*[31:24] reserved*/
 };
 
-#define SDHC_CLOCK_SRC_OSC              0 // 24MHz
 #define SDHC_CLOCK_SRC_FCLK_DIV4        1
 #define SDHC_CLOCK_SRC_FCLK_DIV3        2
 #define SDHC_CLOCK_SRC_FCLK_DIV5        3
diff --git a/arch/arm/mach-meson6tv/include/mach/sd.h b/arch/arm/mach-meson6tv/include/mach/sd.h
index 180f827cd85b..4ea85a3d44f7 100755
--- a/arch/arm/mach-meson6tv/include/mach/sd.h
+++ b/arch/arm/mach-meson6tv/include/mach/sd.h
@@ -13,11 +13,6 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
-#define     AML_ERROR_RETRY_COUNTER         5
-#define     AML_TIMEOUT_RETRY_COUNTER       2
-
-#define AML_SDHC_MAGIC			 "amlsdhc"
-#define AML_SDIO_MAGIC			 "amlsdio"
 enum aml_mmc_waitfor {
 	XFER_INIT,
 	XFER_START,				/* 1 */
@@ -38,18 +33,6 @@ enum aml_mmc_waitfor {
 	XFER_AFTER_START,		/* 16 */
 };
 
-enum aml_host_status { /* Host controller status */
-	HOST_INVALID = 0,       /* 0, invalid value used for initialization */
-	HOST_RX_FIFO_FULL = 1,  /* 1, start with 1 */
-	HOST_TX_FIFO_EMPTY,	    /* 2 */
-	HOST_RSP_CRC_ERR,	    /* 3 */
-	HOST_DAT_CRC_ERR,	    /* 4 */
-	HOST_RSP_TIMEOUT_ERR,   /* 5 */
-	HOST_DAT_TIMEOUT_ERR,   /* 6 */
-    HOST_ERR_END,	        /* 7, end of errors */
-	HOST_TASKLET_CMD,	    /* 8 */
-	HOST_TASKLET_DATA,	    /* 9 */
-};
 struct amlsd_host;
 struct amlsd_platform {
 	struct amlsd_host* host;
@@ -73,12 +56,9 @@ struct amlsd_platform {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int clkc;
-	unsigned int clk2;
 	unsigned int clkc_w;
 	unsigned int ctrl;
 	unsigned int clock;
-	unsigned int tune_phase;            /* store tuning result */
-	unsigned char signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
 	unsigned int low_burst;
 	unsigned int irq_in;
 	unsigned int irq_in_edge;
@@ -93,9 +73,6 @@ struct amlsd_platform {
     unsigned int jtag_pin;
     int is_sduart;
     bool is_in;
-    bool is_tuned;                      /* if card has been tuning */
-    bool need_retuning;
-	struct delayed_work	retuning;
 
     /* we used this flag to filter some unnecessary cmd before initialized flow */
     bool is_fir_init; // has been initialized for the first time
@@ -153,23 +130,21 @@ struct amlsd_host {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int f_min;
-	// struct tasklet_struct cmd_tlet;
-	// struct tasklet_struct data_tlet;
-	// struct tasklet_struct busy_tlet;
-	// struct tasklet_struct to_tlet;
+	struct tasklet_struct cmd_tlet;
+	struct tasklet_struct data_tlet;
+	struct tasklet_struct busy_tlet;
+	struct tasklet_struct to_tlet;
     // struct timer_list timeout_tlist;
 	struct delayed_work	timeout;
-	// struct early_suspend amlsd_early_suspend;
+	struct early_suspend amlsd_early_suspend;
 
-    struct class            debug;
-    
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
-	// unsigned int clkc_w;
-	// unsigned int pdma;
-	// unsigned int pdma_s;
-	// unsigned int pdma_low;
+	unsigned int clkc_w;
+	unsigned int pdma;
+	unsigned int pdma_s;
+	unsigned int pdma_low;
 	unsigned int misc;
 	unsigned int ictl;
 	unsigned int ista;
@@ -182,19 +157,12 @@ struct amlsd_host {
 	spinlock_t	mrq_lock;
 	int			cmd_is_stop;
 	enum aml_mmc_waitfor	xfer_step;
-	enum aml_mmc_waitfor	xfer_step_prev;
 
 	int			bus_width;
 	int     port;
 	int     locked;
-    bool    is_gated;
-	// unsigned int		ccnt, dcnt;
-
-	int     status; // host status: xx_error/ok
-	int init_flag;
-
-    char    *msg_buf;
-#define MESSAGE_BUF_SIZE            512
+	char		*status;
+	unsigned int		ccnt, dcnt;
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debug_root;
@@ -208,17 +176,14 @@ struct amlsd_host {
 
     u32			opcode; // add by gch for debug
 	u32			arg; // add by gch for debug
-    u32         cmd25_cnt;
-    
+
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
-
-    u32         reg_buf[16];
-#endif
     u32         time_req_sta; // request start time
-    
-    struct pinctrl  *pinctrl;
+#endif
+
+    struct pinctrl *pinctrl;
     char pinctrl_name[30];
 
     int storage_flag; // used for judging if there is a tsd/emmc
@@ -583,7 +548,6 @@ struct sdhc_clk2{
 	u32 reserved:8; /*[31:24] reserved*/
 };
 
-#define SDHC_CLOCK_SRC_OSC              0 // 24MHz
 #define SDHC_CLOCK_SRC_FCLK_DIV4        1
 #define SDHC_CLOCK_SRC_FCLK_DIV3        2
 #define SDHC_CLOCK_SRC_FCLK_DIV5        3
@@ -648,9 +612,6 @@ extern struct mmc_host *sdio_host;
 		printk("[%s] " fmt, __FUNCTION__, ##args);	\
 }while(0)
 
-#define print_dbg(fmt, args...) do{\
-	printk("[%s]\033[0;40;35m " fmt "\033[0m", __FUNCTION__, ##args);  \
-}while(0)
 // P_AO_SECURE_REG1 is "Secure Register 1" in <M8-Secure-AHB-Registers.doc>
 #define aml_jtag_gpioao() do{\
     writel(0x102, (u32 *)P_AO_SECURE_REG1); \
diff --git a/arch/arm/mach-meson6tvd/include/mach/sd.h b/arch/arm/mach-meson6tvd/include/mach/sd.h
index 5b3c2e5a9ed8..4ea85a3d44f7 100755
--- a/arch/arm/mach-meson6tvd/include/mach/sd.h
+++ b/arch/arm/mach-meson6tvd/include/mach/sd.h
@@ -13,11 +13,6 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
-#define     AML_ERROR_RETRY_COUNTER         5
-#define     AML_TIMEOUT_RETRY_COUNTER       2
-
-#define AML_SDHC_MAGIC			 "amlsdhc"
-#define AML_SDIO_MAGIC			 "amlsdio"
 enum aml_mmc_waitfor {
 	XFER_INIT,
 	XFER_START,				/* 1 */
@@ -38,18 +33,6 @@ enum aml_mmc_waitfor {
 	XFER_AFTER_START,		/* 16 */
 };
 
-enum aml_host_status { /* Host controller status */
-	HOST_INVALID = 0,       /* 0, invalid value used for initialization */
-	HOST_RX_FIFO_FULL = 1,  /* 1, start with 1 */
-	HOST_TX_FIFO_EMPTY,	    /* 2 */
-	HOST_RSP_CRC_ERR,	    /* 3 */
-	HOST_DAT_CRC_ERR,	    /* 4 */
-	HOST_RSP_TIMEOUT_ERR,   /* 5 */
-	HOST_DAT_TIMEOUT_ERR,   /* 6 */
-    HOST_ERR_END,	        /* 7, end of errors */
-	HOST_TASKLET_CMD,	    /* 8 */
-	HOST_TASKLET_DATA,	    /* 9 */
-};
 struct amlsd_host;
 struct amlsd_platform {
 	struct amlsd_host* host;
@@ -73,13 +56,9 @@ struct amlsd_platform {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int clkc;
-	unsigned int clk2;
 	unsigned int clkc_w;
 	unsigned int ctrl;
 	unsigned int clock;
-	unsigned int tune_phase;            /* store tuning result */
-	unsigned char signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
-
 	unsigned int low_burst;
 	unsigned int irq_in;
 	unsigned int irq_in_edge;
@@ -94,9 +73,6 @@ struct amlsd_platform {
     unsigned int jtag_pin;
     int is_sduart;
     bool is_in;
-    bool is_tuned;                      /* if card has been tuning */
-    bool need_retuning;
-	struct delayed_work	retuning;
 
     /* we used this flag to filter some unnecessary cmd before initialized flow */
     bool is_fir_init; // has been initialized for the first time
@@ -154,22 +130,21 @@ struct amlsd_host {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int f_min;
-	// struct tasklet_struct cmd_tlet;
-	// struct tasklet_struct data_tlet;
-	// struct tasklet_struct busy_tlet;
-	// struct tasklet_struct to_tlet;
+	struct tasklet_struct cmd_tlet;
+	struct tasklet_struct data_tlet;
+	struct tasklet_struct busy_tlet;
+	struct tasklet_struct to_tlet;
     // struct timer_list timeout_tlist;
 	struct delayed_work	timeout;
-	// struct early_suspend amlsd_early_suspend;
+	struct early_suspend amlsd_early_suspend;
 
-    struct class            debug;
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
-	// unsigned int clkc_w;
-	// unsigned int pdma;
-	// unsigned int pdma_s;
-	// unsigned int pdma_low;
+	unsigned int clkc_w;
+	unsigned int pdma;
+	unsigned int pdma_s;
+	unsigned int pdma_low;
 	unsigned int misc;
 	unsigned int ictl;
 	unsigned int ista;
@@ -182,19 +157,12 @@ struct amlsd_host {
 	spinlock_t	mrq_lock;
 	int			cmd_is_stop;
 	enum aml_mmc_waitfor	xfer_step;
-	enum aml_mmc_waitfor	xfer_step_prev;
 
 	int			bus_width;
 	int     port;
 	int     locked;
-    bool    is_gated;
-	// unsigned int		ccnt, dcnt;
-
-	int     status; // host status: xx_error/ok
-	int init_flag;
-
-    char    *msg_buf;
-#define MESSAGE_BUF_SIZE            512
+	char		*status;
+	unsigned int		ccnt, dcnt;
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debug_root;
@@ -208,16 +176,13 @@ struct amlsd_host {
 
     u32			opcode; // add by gch for debug
 	u32			arg; // add by gch for debug
-    u32         cmd25_cnt;
 
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
     u32         time_req_sta; // request start time
-    u32         reg_buf[16];
 #endif
-    u32         time_req_sta; // request start time
-    
+
     struct pinctrl *pinctrl;
     char pinctrl_name[30];
 
@@ -583,7 +548,6 @@ struct sdhc_clk2{
 	u32 reserved:8; /*[31:24] reserved*/
 };
 
-#define SDHC_CLOCK_SRC_OSC              0 // 24MHz
 #define SDHC_CLOCK_SRC_FCLK_DIV4        1
 #define SDHC_CLOCK_SRC_FCLK_DIV3        2
 #define SDHC_CLOCK_SRC_FCLK_DIV5        3
diff --git a/arch/arm/mach-meson8/include/mach/sd.h b/arch/arm/mach-meson8/include/mach/sd.h
index bf69f3664839..594f25c1f265 100755
--- a/arch/arm/mach-meson8/include/mach/sd.h
+++ b/arch/arm/mach-meson8/include/mach/sd.h
@@ -13,13 +13,6 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
-#define     AML_ERROR_RETRY_COUNTER         5
-#define     AML_TIMEOUT_RETRY_COUNTER       2
-
-#define AML_SDHC_MAGIC			 "amlsdhc"
-#define AML_SDIO_MAGIC			 "amlsdio"
-
-
 enum aml_mmc_waitfor {
 	XFER_INIT,              /* 0 */
 	XFER_START,				/* 1 */
@@ -163,8 +156,6 @@ struct amlsd_host {
 	struct delayed_work	timeout;
 	// struct early_suspend amlsd_early_suspend;
 
-    struct class            debug;
-    
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
@@ -193,7 +184,6 @@ struct amlsd_host {
 	// unsigned int		ccnt, dcnt;
 
 	int     status; // host status: xx_error/ok
-	int init_flag;
 
     char    *msg_buf;
 #define MESSAGE_BUF_SIZE            512
@@ -215,10 +205,10 @@ struct amlsd_host {
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
+    u32         time_req_sta; // request start time
 
     u32         reg_buf[16];
 #endif
-    u32         time_req_sta; // request start time
     
     struct pinctrl  *pinctrl;
     char        pinctrl_name[30];
diff --git a/arch/arm/mach-meson8b/include/mach/sd.h b/arch/arm/mach-meson8b/include/mach/sd.h
index f7c8d8fa75c4..d8b1cf29c695 100755
--- a/arch/arm/mach-meson8b/include/mach/sd.h
+++ b/arch/arm/mach-meson8b/include/mach/sd.h
@@ -13,13 +13,6 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
-#define     AML_ERROR_RETRY_COUNTER         5
-#define     AML_TIMEOUT_RETRY_COUNTER       2
-
-#define AML_SDHC_MAGIC			 "amlsdhc"
-#define AML_SDIO_MAGIC			 "amlsdio"
-
-
 enum aml_mmc_waitfor {
 	XFER_INIT,              /* 0 */
 	XFER_START,				/* 1 */
@@ -163,8 +156,6 @@ struct amlsd_host {
 	struct delayed_work	timeout;
 	// struct early_suspend amlsd_early_suspend;
 
-    struct class            debug;
-    
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
@@ -193,7 +184,6 @@ struct amlsd_host {
 	// unsigned int		ccnt, dcnt;
 
 	int     status; // host status: xx_error/ok
-	int init_flag;
 
     char    *msg_buf;
 #define MESSAGE_BUF_SIZE            512
@@ -215,10 +205,10 @@ struct amlsd_host {
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
+    u32         time_req_sta; // request start time
 
     u32         reg_buf[16];
 #endif
-    u32         time_req_sta; // request start time
     
     struct pinctrl  *pinctrl;
     char        pinctrl_name[30];
diff --git a/drivers/amlogic/mmc/aml_sdhc_m8.c b/drivers/amlogic/mmc/aml_sdhc_m8.c
index 8f2124eef1f8..4f5047cba1d2 100755
--- a/drivers/amlogic/mmc/aml_sdhc_m8.c
+++ b/drivers/amlogic/mmc/aml_sdhc_m8.c
@@ -41,11 +41,6 @@ unsigned int cmd25_cnt=0;
 unsigned int fifo_empty_cnt=0;
 unsigned int fifo_full_cnt=0;
 unsigned int timeout_cnt=0;
-static unsigned int sdhc_error_flag = 0;
-static unsigned int sdhc_debug_flag = 0;
-static int sdhc_err_bak;
-
-void aml_sdhc_send_stop(struct amlsd_host* host);
 
 static void aml_sdhc_clk_switch (struct amlsd_platform* pdata, int clk_div, int clk_src_sel);
 static int aml_sdhc_status (struct amlsd_host* host);
@@ -80,43 +75,6 @@ static const u8 tuning_blk_pattern_8bit[] = {
 	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
 };
 
-static void sdhc_debug_status(struct amlsd_host* host)
-{
-    switch (sdhc_debug_flag)
-    {
-        case 1:
-            host->status = HOST_TX_FIFO_EMPTY;
-            sdhc_err("Force host->status:%d here\n", host->status);
-            break;
-        case 2:
-            host->status = HOST_RX_FIFO_FULL;
-            sdhc_err("Force host->status:%d here\n", host->status);
-            break;  
-        case 3:
-            host->status = HOST_RSP_CRC_ERR;
-            sdhc_err("Force host->status:%d here\n", host->status);
-            break;  
-        case 4:
-            host->status = HOST_DAT_CRC_ERR;
-            sdhc_err("Force host->status:%d here\n", host->status);
-            break;              
-        case 5:
-            host->status = HOST_DAT_TIMEOUT_ERR;
-            sdhc_err("Force host->status:%d here\n", host->status);
-            break;   
-        case 6:
-            host->status = HOST_RSP_TIMEOUT_ERR;
-            sdhc_err("Force host->status:%d here\n", host->status);
-            break; 
-                                    
-        default:            
-            break;
-    }
-    
-    //only enable once for debug
-    sdhc_debug_flag = 0;
-}
-
 struct aml_tuning_data {
 	const u8 *blk_pattern;
 	unsigned int blksz;
@@ -482,7 +440,6 @@ static void aml_sdhc_reg_init(struct amlsd_host* host)
     pdma->txfifo_th = 49; // means 49
     pdma->rd_burst = 15; // means 8
     pdma->rxfifo_th = 8; // means 8
-    pdma->rxfifo_manual_flush = 1; // bit[29]=1, bit[30]=0
     // pdma->rd_burst = 3;
     // pdma->wr_burst = 3;
     // pdma->rxfifo_th = 7;
@@ -499,7 +456,7 @@ static void aml_sdhc_reg_init(struct amlsd_host* host)
     venhc = readl(host->base+SDHC_ENHC);
     enhc->rxfifo_th = 60;
     enhc->dma_rd_resp = 0;
-    enhc->dma_wr_resp = 0; // 1;
+    enhc->dma_wr_resp = 1;
     enhc->sdio_irq_period = 12;
     enhc->rx_timeout = 255;
     writel(venhc, host->base + SDHC_ENHC);
@@ -521,18 +478,17 @@ int aml_sdhc_wait_ready(struct amlsd_host* host, u32 timeout)
     for(i=0; i< timeout; i++){
         vstat = readl(host->base + SDHC_STAT);
         stat = (struct sdhc_stat*)&vstat;
-
         esta = readl(host->base + SDHC_ESTA);
-        if(!stat->cmd_busy && (!((esta >> 11) & 7)))
+        if(!stat->cmd_busy && (!((esta << 11) & 7)))
         //if(!stat->cmd_busy)
             return 0;
         udelay(1);
     }
 
     sdhc_err("SDHC_STAT=%#x, sdhc controller is busy.\n", vstat);
-    //aml_sdhc_print_reg(host);
+    aml_sdhc_print_reg(host);
     aml_sdhc_host_reset(host);
-    //WARN_ON(1);
+    WARN_ON(1);
     return -1;
 }
 
@@ -735,6 +691,7 @@ void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
         //send.r1b = 1;
         //sdhc_err("cmd %d set r1b\n", mrq->cmd->opcode);
     //}
+    
 
     if(mrq->data){
         if(((mrq->cmd->opcode == SD_IO_RW_DIRECT) || (mrq->cmd->opcode == SD_IO_RW_EXTENDED))
@@ -788,10 +745,7 @@ void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
          * wait dma done interrupt(int[11]), don't need care about
          * dat0 busy or not.
          */
-        if(mrq->data->flags & MMC_DATA_WRITE)
-            ictl.dma_done = 1; // for hardware automatical flush
-        else
-            ictl.data_xfer_ok = 1; // for software flush
+        ictl.dma_done = 1;
     }else
         ictl.resp_ok = 1;
 
@@ -1043,15 +997,8 @@ static void aml_sdhc_timeout(struct work_struct *work)
     // u32 vista = readl(host->base + SDHC_ISTA);
     // struct sdhc_ista* ista = (struct sdhc_ista*)&vista;
     struct mmc_request* mrq;
-    struct amlsd_platform* pdata = mmc_priv(host->mmc);
-    
     unsigned long flags;
 
-	struct timeval ts_current;
-	unsigned long time_start_cnt = READ_CBUS_REG(ISA_TIMERE);
-	
-    time_start_cnt = (time_start_cnt - host->time_req_sta) / 1000;
-	
     BUG_ON(!host->mrq || !host->mrq->cmd);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
@@ -1063,48 +1010,33 @@ static void aml_sdhc_timeout(struct work_struct *work)
 
     if ((host->xfer_step == XFER_IRQ_TASKLET_DATA) 
             || (host->xfer_step == XFER_IRQ_TASKLET_CMD)) {
-        schedule_delayed_work(&host->timeout, 50);
-        host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);
+        schedule_delayed_work(&host->timeout, 10);
         
         timeout_cnt++;
-        if (timeout_cnt > 30)
+        if (timeout_cnt > 100)
             goto timeout_handle;
 
         spin_unlock_irqrestore(&host->mrq_lock, flags);
 
-        sdhc_err("%s: cmd%d, ISR have been run, xfer_step=%d, time_start_cnt=%dmS, timeout_cnt=%d\n",
-                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step, time_start_cnt, timeout_cnt);
+        sdhc_err("%s: cmd%d, ISR have been run, xfer_step=%d\n",
+                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step);
         return;
     }
 timeout_handle:
     timeout_cnt = 0;
 
     mrq = host->mrq;
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
+
+    aml_sdhc_status(host);
+
+    spin_lock_irqsave(&host->mrq_lock, flags);
     host->xfer_step_prev = host->xfer_step;
     host->xfer_step = XFER_TIMER_TIMEOUT;
     mrq->cmd->error = -ETIMEDOUT;
-
-    if(aml_card_type_sd(pdata)){
-        sdhc_error_flag |= (1<<30);
-        host->mrq->cmd->retries = 0;        
-    }else if((sdhc_error_flag & (1<<3) == 0)  && (mrq->data != NULL)
-            && pdata->is_in){  //set cmd retry cnt when first error.
-        sdhc_error_flag |= (1<<3);
-        mrq->cmd->retries = AML_TIMEOUT_RETRY_COUNTER; 
-    }   
-
-    if(sdhc_error_flag && (mrq->cmd->retries == 0)){
-        sdhc_error_flag |= (1<<30);
-        sdhc_err("Command retried failed\n");
-    }
-        
     spin_unlock_irqrestore(&host->mrq_lock, flags);
 
-    aml_sdhc_status(host);
-
     aml_sdhc_read_response(host->mmc, mrq->cmd);
-    sdhc_err("time_start_cnt:%d\n", time_start_cnt);
-
     aml_sdhc_print_err(host);
 
     /*read response, if error, set -EILSEQ, then retry in aml_sdhc_request_done*/
@@ -1157,24 +1089,8 @@ timeout_handle:
 // req_done:
     aml_sdhc_host_reset(host);
     /*write 1 clear irq status reg*/
-    //writel(vista, host->base+SDHC_ISTA);
- 
-    //do not send stop for sdio wifi case 
-    if(host->mrq->stop && (!aml_card_type_sd(pdata)) && !host->cmd_is_stop){
-    //if((host->mrq->cmd->opcode != SD_IO_RW_DIRECT) && (host->mrq->cmd->opcode != SD_IO_RW_EXTENDED) 
-   //         && (!mmc_card_removed(pdata->mmc->card)) && (!mrq->data)){
-        //spin_lock_irqsave(&host->mrq_lock, flags);
-        aml_sdhc_send_stop(host);                
-        //spin_unlock_irqrestore(&host->mrq_lock, flags);
-        schedule_delayed_work(&host->timeout, 1);
-    }
-    else{
-        if (host->cmd_is_stop)
-            host->cmd_is_stop = 0;
-
-        aml_sdhc_request_done(host->mmc, mrq);
-    }          
-      
+    // writel(vista, host->base+SDHC_ISTA);
+    aml_sdhc_request_done(host->mmc, mrq);
     return ;
 }
 
@@ -1208,11 +1124,9 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if (aml_check_unsupport_cmd(mmc, mrq))
         return;
 
-    //only for SDCARD
-    if(!pdata->is_in || (!host->init_flag && aml_card_type_sd(pdata))){
+    if(!pdata->is_in){
         spin_lock_irqsave(&host->mrq_lock, flags);
         mrq->cmd->error = -ENOMEDIUM;
-        mrq->cmd->retries = 0;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         mmc_request_done(mmc, mrq);
         return;
@@ -1245,16 +1159,9 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
         fifo_empty_cnt = 0;
         fifo_full_cnt = 0;
         timeout_cnt = 0;
-        host->init_flag = 1;
     }
-    
     if (mrq->cmd->opcode == 25)
         cmd25_cnt++;
-       
-    //clear error flag if last command retried failed here    
-    if(sdhc_error_flag & (1<<30)){
-        sdhc_error_flag = 0;
-    }
 
     /*setup reg  especially for cmd with transfering data*/
     if(mrq->data) {
@@ -1283,7 +1190,6 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
     else
         timeout = 500;//mod_timer(&host->timeout_tlist,
                 //jiffies + 500/*10*nsecs_to_jiffies(mrq->data->timeout_ns)*/); // 5s
-             
     schedule_delayed_work(&host->timeout, timeout);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
@@ -1296,14 +1202,13 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
     host->xfer_step = XFER_START;
     host->opcode = mrq->cmd->opcode;
     host->arg = mrq->cmd->arg;
-    host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);
 
     /*setup reg for all cmd*/
     aml_sdhc_start_cmd(pdata, mrq);
     host->xfer_step = XFER_AFTER_START;
     spin_unlock_irqrestore(&host->mrq_lock, flags);
 }
-    
+
 static int aml_sdhc_status (struct amlsd_host* host)
 {
     int ret = -1; // error
@@ -1349,11 +1254,6 @@ static int aml_sdhc_status (struct amlsd_host* host)
             ret = 0; // ok
             goto _status_exit;
         }
-        if(ista->data_xfer_ok){
-            host->status = HOST_TASKLET_DATA;
-            ret = 0; // ok
-            goto _status_exit;
-        }
         if(ista->resp_ok_noclear){
             host->status = HOST_TASKLET_CMD;
             ret = 0; // ok
@@ -1362,10 +1262,6 @@ static int aml_sdhc_status (struct amlsd_host* host)
     }
     ret = 0; // ok
 _status_exit:
-    
-    //for debug
-    //sdhc_debug_status(host);
-
     spin_unlock_irqrestore(&host->mrq_lock, flags);
     return ret;
 }
@@ -1382,14 +1278,7 @@ static irqreturn_t aml_sdhc_irq(int irq, void *dev_id)
     u32 victl = readl(host->base + SDHC_ICTL);
     u32 vista = readl(host->base + SDHC_ISTA);
 
-    //if(sdhc_debug_flag == 9){
-    //    sdhc_err("FORCE ignore IRQ here\n");
-    //    sdhc_debug_flag = 0;
-    //    return IRQ_HANDLED;
-    //}
-        
     spin_lock_irqsave(&host->mrq_lock, flags);
-       
     mrq = host->mrq;
     mmc = host->mmc;
     pdata = mmc_priv(mmc);
@@ -1495,16 +1384,17 @@ struct mmc_request aml_sdhc_stop = {
     .cmd = &aml_sdhc_cmd,
 };
 
+int err_bak;
 void aml_sdhc_send_stop(struct amlsd_host* host)
 {
     struct amlsd_platform * pdata = mmc_priv(host->mmc);
     unsigned long flags;
 
     // sdhc_err("before cmd12\n");
-   
+    
     /*Already in mrq_lock*/
     spin_lock_irqsave(&host->mrq_lock, flags);
-    sdhc_err_bak = host->mrq->cmd->error;
+    err_bak = host->mrq->cmd->error;
     host->mrq->cmd->error = 0;
     host->cmd_is_stop = 1;
     spin_unlock_irqrestore(&host->mrq_lock, flags);
@@ -1522,25 +1412,23 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
     unsigned long flags;
     u32 vstat, status;
     struct sdhc_stat* stat = (struct sdhc_stat*)&vstat;
-    struct amlsd_platform* pdata = mmc_priv(host->mmc);
+    struct amlsd_platform* pdata;
     int cnt=0;
-    u32 esta = readl(host->base + SDHC_ESTA);
-    u32 vpdma = readl(host->base+SDHC_PDMA);   
-    struct sdhc_pdma* pdma = (struct sdhc_pdma*)&vpdma;
 
     spin_lock_irqsave(&host->mrq_lock, flags);
+    if ((host->xfer_step != XFER_IRQ_OCCUR) && (host->xfer_step != XFER_IRQ_TASKLET_BUSY)) {
+        sdhc_err("host->xfer_step=%d\n", host->xfer_step);
+    }
+
+    // if(host->xfer_step == XFER_TIMER_TIMEOUT){
+        // sdhc_err("Timeout Return\n");
+        // return IRQ_HANDLED;
+    // }
+
     mrq = host->mrq;
     xfer_step = host->xfer_step;
     status = host->status;
     
-    if ((xfer_step == XFER_FINISHED) || (xfer_step == XFER_TIMER_TIMEOUT)) {
-        sdhc_err("Warning: xfer_step=%d, host->status=%d\n", xfer_step, status);
-        spin_unlock_irqrestore(&host->mrq_lock, flags);
-        return IRQ_HANDLED;
-    }
-
-    WARN_ON((host->xfer_step != XFER_IRQ_OCCUR) && (host->xfer_step != XFER_IRQ_TASKLET_BUSY));
-
     if(!mrq){
         sdhc_err("!mrq xfer_step %d\n", xfer_step);
         if(xfer_step == XFER_FINISHED ||
@@ -1548,15 +1436,14 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
             spin_unlock_irqrestore(&host->mrq_lock, flags);
             return IRQ_HANDLED;
         }
-        //BUG();
-        aml_sdhc_print_err(host);
+        BUG();
     }
     if(host->cmd_is_stop){
         int delay = 1;
         if (mrq->cmd->error)
             sdhc_err("cmd12 error %d\n", mrq->cmd->error);
         host->cmd_is_stop = 0;
-        mrq->cmd->error = sdhc_err_bak;
+        mrq->cmd->error = err_bak;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         msleep(delay);
         sdhc_err("delay %dms\n", delay);
@@ -1569,28 +1456,12 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
 
     switch (status) {
         case HOST_TASKLET_DATA:
-            sdhc_error_flag = 0;
             BUG_ON(!mrq->data);
             cancel_delayed_work(&host->timeout);
 
             xfer_bytes = mrq->data->blksz*mrq->data->blocks;
             /* copy buffer from dma to data->sg in read cmd*/
             if(host->mrq->data->flags & MMC_DATA_READ){
-                int i;
-                for(i=0; i< STAT_POLL_TIMEOUT; i++){
-                    esta = readl(host->base + SDHC_ESTA);
-                    esta = readl(host->base + SDHC_ESTA); // read twice, we just focus on the second result
-                    if (((esta >> 11) & 7) == 0) // REGC_ESTA[13:11]=0? then OK
-                        break;
-                    else if (i == 0)
-                        sdhc_err("SDHC_ESTA=%#x", esta);
-                }
-                if (i == STAT_POLL_TIMEOUT) // error
-                    sdhc_err("Warning: DMA state is wrong! SDHC_ESTA=%#x", esta);
-
-                pdma->rxfifo_manual_flush |= 0x02; // bit[30]
-                writel(vpdma, host->base+SDHC_PDMA);
-
                 aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len, host->bn_buf,
                             xfer_bytes, 0);
                 sdhc_dbg(AMLSD_DBG_RD_DATA, "R Cmd%d, arg %#x, size=%d\n",
@@ -1617,14 +1488,12 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
             mrq->data->bytes_xfered = xfer_bytes;
             host->xfer_step = XFER_TASKLET_DATA;
             spin_unlock_irqrestore(&host->mrq_lock, flags);
-            //do not check device ready status here
             aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
             aml_sdhc_read_response(host->mmc, mrq->cmd);
             // aml_sdhc_clear_fifo(host);
             aml_sdhc_request_done(host->mmc, mrq);
             break;
         case HOST_TASKLET_CMD:
-            sdhc_error_flag = 0;
             if(!host->mrq->data){
                 cancel_delayed_work(&host->timeout);
                 spin_lock_irqsave(&host->mrq_lock, flags);
@@ -1639,47 +1508,17 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
             }
             break;
         case HOST_TX_FIFO_EMPTY:
-        case HOST_RX_FIFO_FULL:   
-        case HOST_RSP_TIMEOUT_ERR:
-        case HOST_DAT_TIMEOUT_ERR:                                 
             cancel_delayed_work(&host->timeout);
             aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
             aml_sdhc_read_response(host->mmc, host->mrq->cmd);
             aml_sdhc_print_err(host);
             aml_sdhc_host_reset(host);
             writel(SDHC_ISTA_W1C_ALL, host->base+SDHC_ISTA);
-            spin_lock_irqsave(&host->mrq_lock, flags);
-            if(sdhc_error_flag == 0){  //set cmd retry cnt when first error.
-                sdhc_error_flag |= (1<<0);
-                if(mrq->data == NULL){
-                    mrq->cmd->retries = 0;
-                }
-                else if((status == HOST_RSP_TIMEOUT_ERR) || (status == HOST_DAT_TIMEOUT_ERR)){
-                    mrq->cmd->retries = AML_TIMEOUT_RETRY_COUNTER; 
-                }
-                else{
-                    mrq->cmd->retries = AML_ERROR_RETRY_COUNTER;                     
-                }
-            } 
-            if(sdhc_error_flag && (mrq->cmd->retries == 0)){
-                sdhc_error_flag |= (1<<30);
-                //sdhc_err("Command retried failed\n");
-            }    
-            spin_unlock_irqrestore(&host->mrq_lock, flags);
-                          
-            //do not send stop for sdio wifi case 
-            if(host->mrq->stop && pdata->is_in){
-            //if((host->mrq->cmd->opcode != SD_IO_RW_DIRECT) && (host->mrq->cmd->opcode != SD_IO_RW_EXTENDED) 
-           //         && (!mmc_card_removed(pdata->mmc->card)) && (!mrq->data)){
-                aml_sdhc_send_stop(host);                
-            }
-            else{
-                aml_sdhc_request_done(host->mmc, mrq);
-            }
+            aml_sdhc_send_stop(host);
+            break;
+        case HOST_RX_FIFO_FULL:
+            aml_sdhc_not_timeout_err_handler(host);
             break;
-        //case HOST_RX_FIFO_FULL:
-        //    aml_sdhc_not_timeout_err_handler(host);
-        //    break;
         case HOST_RSP_CRC_ERR:
         case HOST_DAT_CRC_ERR:
             pdata = mmc_priv(host->mmc);
@@ -1693,37 +1532,25 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
                     if(cnt >= (ARRAY_SIZE(clock) - 1))
                         break;
                 }
-                spin_lock_irqsave(&host->mrq_lock, flags);
-
                 host->mmc->ios.clock = clock[cnt]; 
                 aml_sdhc_set_clk_rate(host->mmc,host->mmc->ios.clock);
 
+                spin_lock_irqsave(&host->mrq_lock, flags);
                 pdata->need_retuning = true; // retuing will be done in the next request
                 mrq->cmd->retries = (ARRAY_SIZE(clock) - 1) - cnt;
+                spin_unlock_irqrestore(&host->mrq_lock, flags);
             }
-            else{
-                spin_lock_irqsave(&host->mrq_lock, flags);
-
-                if(sdhc_error_flag == 0){  //set cmd retry cnt when first error.
-                    sdhc_error_flag |= (1<<1);
-                    mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
-                }                 
-            } 
-            if(sdhc_error_flag && (mrq->cmd->retries == 0)){
-                sdhc_error_flag |= (1<<30);
-                //sdhc_err("Command retried failed\n");
-            }       
-            spin_unlock_irqrestore(&host->mrq_lock, flags);
-    
             aml_sdhc_not_timeout_err_handler(host);
             break;
-
+        case HOST_RSP_TIMEOUT_ERR:
+        case HOST_DAT_TIMEOUT_ERR:
+            aml_sdhc_com_err_handler(host);
+            break;
         default:
             sdhc_err("BUG xfer_step=%d, host->status=%d\n", xfer_step, status);
-            aml_sdhc_print_err(host);
-            //BUG();
+            BUG();
     }
-    
+
     return IRQ_HANDLED;
 }
 
@@ -2090,40 +1917,6 @@ static const struct mmc_host_ops aml_sdhc_ops = {
 /*for multi host claim host*/
 static struct mmc_claim aml_sdhc_claim;
 
-static ssize_t sdhc_debug_func(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
-{
-    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
-    
-    sscanf(buf, "%x", &sdhc_debug_flag);    
-    printk("sdhc_debug_flag: %d\n", sdhc_debug_flag);
-
-    return count;
-}
-            
-static ssize_t show_sdhc_debug(struct class *class,
-                    struct class_attribute *attr,	char *buf)
-{
-    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
-    
-    printk("sdhc_debug_flag: %d\n", sdhc_debug_flag);
-    
-    printk("1 : Force sdhc HOST_TX_FIFO_EMPTY error \n");
-    printk("2 : Force sdhc HOST_RX_FIFO_FULL error \n");
-    printk("3 : Force sdhc HOST_RSP_CRC_ERR error \n");
-    printk("4 : Force sdhc HOST_DAT_CRC_ERR error \n");
-    printk("5 : Force sdhc HOST_DAT_TIMEOUT_ERR error \n");
-    printk("6 : Force sdhc HOST_RSP_TIMEOUT_ERR error \n");
-
-    printk("9 : Force sdhc irq timeout error \n");
-    
-    return 0;
-}
-
-static struct class_attribute sdhc_class_attrs[] = {
-    __ATTR(debug,  S_IRUGO | S_IWUSR , show_sdhc_debug, sdhc_debug_func),
-    __ATTR_NULL
-};
-
 static struct amlsd_host* aml_sdhc_init_host(void)
 {
     struct amlsd_host *host;
@@ -2155,8 +1948,6 @@ static struct amlsd_host* aml_sdhc_init_host(void)
 
     INIT_LIST_HEAD(&host->sibling);
     
-    host->init_flag = 1;
-    
     host->version = AML_MMC_VERSION;
     host->storage_flag = storage_flag;
     host->pinctrl = NULL;
@@ -2176,12 +1967,6 @@ static struct amlsd_host* aml_sdhc_init_host(void)
     sdhc_err("CONFIG_AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW is on!\n");
 #endif
 
-	host->debug.name = kzalloc(strlen((const char*)AML_SDHC_MAGIC)+1, GFP_KERNEL);
-	strcpy(host->debug.name, (char*)AML_SDHC_MAGIC);
-	host->debug.class_attrs = sdhc_class_attrs;
-	if(class_register(&host->debug))
-		printk(" class register nand_class fail!\n");
-		
     return host;
 }
 
@@ -2265,12 +2050,6 @@ static int aml_sdhc_probe(struct platform_device *pdev)
         mmc->max_current_180 = 300; // 300 mA in 1.8V
         mmc->max_current_330 = 300; // 300 mA in 3.3V
 
-        if (aml_card_type_sdio(pdata)) { // if sdio_wifi
-            mmc->host_rescan_disable = true;
-        } else {
-            mmc->host_rescan_disable = false;
-        }
-
         if(pdata->port_init)
             pdata->port_init(pdata);
 
diff --git a/drivers/amlogic/mmc/aml_sdio.c b/drivers/amlogic/mmc/aml_sdio.c
index 75a92dee0a93..d30cc0ac2bbc 100755
--- a/drivers/amlogic/mmc/aml_sdio.c
+++ b/drivers/amlogic/mmc/aml_sdio.c
@@ -43,34 +43,6 @@ int SDIO_IRQ_SUPPORT = 0;
 static int aml_sdio_timeout_cmd(struct amlsd_host *host);
 void aml_sdio_send_stop(struct amlsd_host* host);
 
-static unsigned int sdio_error_flag = 0;
-static unsigned int sdio_debug_flag = 0;
-static unsigned int sdio_err_bak;
-
-void sdio_debug_irqstatus(struct sdio_status_irq* irqs, struct cmd_send* send)
-{    
-    switch (sdio_debug_flag)
-    {
-        case 1:
-            irqs->sdio_response_crc7_ok = 0;
-            send->response_do_not_have_crc7 = 0;
-            
-            sdhc_err("Force sdio cmd response crc error here\n");
-            break;
-        case 2:
-            irqs->sdio_data_read_crc16_ok = 0;
-            irqs->sdio_data_write_crc16_ok = 0;
-            sdhc_err("Force sdio data crc here\n");
-            break;  
-                                    
-        default:            
-            break;
-    }
-    
-    //only enable once for debug
-    sdio_debug_flag = 0;
-}
-
 static void aml_sdio_soft_reset(struct amlsd_host* host)
 {
     struct sdio_irq_config irqc={0};
@@ -441,16 +413,11 @@ static void aml_sdio_timeout(struct work_struct *work)
     u32 virqc;
     struct sdio_irq_config* irqc;
     unsigned long flags;
-//#ifdef      CONFIG_MMC_AML_DEBUG
+#ifdef      CONFIG_MMC_AML_DEBUG
     struct amlsd_platform * pdata = mmc_priv(host->mmc);
-//#endif
+#endif
 	static int timeout_cmd_cnt = 0;
 
-	struct timeval ts_current;
-	unsigned long time_start_cnt = READ_CBUS_REG(ISA_TIMERE);
-	
-    
-    time_start_cnt = (time_start_cnt - host->time_req_sta) / 1000;
 
 //	if(host->mmc->caps & MMC_CAP_SDIO_IRQ){
 	if(SDIO_IRQ_SUPPORT)
@@ -480,15 +447,13 @@ static void aml_sdio_timeout(struct work_struct *work)
             || (host->xfer_step == XFER_IRQ_OCCUR)){    // isr have been run
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         //mod_timer(&host->timeout_tlist, jiffies + 10);
-        schedule_delayed_work(&host->timeout, 50);
-        host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);    
+        schedule_delayed_work(&host->timeout, 10);
         
         if(irqs->sdio_cmd_int) {
             timeout_cnt++;
-            if (timeout_cnt > 30)
+            if (timeout_cnt > 10)
                 goto timeout_handle;
-            sdhc_err("%s: cmd%d, ISR have been run, xfer_step=%d, time_start_cnt=%dmS, timeout_cnt=%d\n",
-                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step, time_start_cnt, timeout_cnt);        
+            sdio_err("%s: irq have been occured\n", mmc_hostname(host->mmc));
         }
         else
             sdio_err("%s: isr have been run\n",  mmc_hostname(host->mmc));
@@ -511,27 +476,10 @@ timeout_handle:
     writel(virqc, host->base + SDIO_IRQC);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
-    
-    //do not retry for sdcard
-    if(aml_card_type_sd(pdata)){
-        sdio_error_flag |= (1<<30);
-        host->mrq->cmd->retries = 0;
-    }else if((sdio_error_flag & (1<<3) == 0) && (host->mrq->data != NULL) 
-            && pdata->is_in ){  //set cmd retry cnt when first error.
-        sdio_error_flag |= (1<<3);
-        host->mrq->cmd->retries = AML_TIMEOUT_RETRY_COUNTER; 
-    }   
-    
-    //here clear error flags after error retried
-    if(sdio_error_flag && (host->mrq->cmd->retries == 0)){
-        sdio_error_flag |= (1<<30);
-    } 
-    
     host->xfer_step = XFER_TIMEDOUT;
     host->mrq->cmd->error = -ETIMEDOUT;
     spin_unlock_irqrestore(&host->mrq_lock, flags);
     
-    sdio_err("time_start_cnt:%d\n", time_start_cnt);
     aml_sdio_print_err(host, "Timeout error");
     // if (pdata->port == MESON_SDIO_PORT_A) {
         // sdio_err("power_on_pin=%d\n",
@@ -549,25 +497,10 @@ timeout_handle:
     aml_dbg_verify_pull_up(pdata);
     aml_sdio_print_reg(host);
     // aml_dbg_print_pinmux();
-#endif 
-
-    if(host->mrq->stop && (!aml_card_type_sd(pdata)) && !host->cmd_is_stop){
-        // sdio_err("Send stop cmd before timeout retry..\n");
-        spin_lock_irqsave(&host->mrq_lock, flags);
-        aml_sdio_send_stop(host);                
-        spin_unlock_irqrestore(&host->mrq_lock, flags);
-        schedule_delayed_work(&host->timeout, 1);
-    }
-    else{
-            /*request done*/
-        // sdio_err("Just stop without retry..\n");
-
-        if (host->cmd_is_stop)
-            host->cmd_is_stop = 0;
+#endif
 
-        aml_sdio_request_done(host->mmc, host->mrq);
-    }
-            
+    /*request done*/
+    aml_sdio_request_done(host->mmc, host->mrq);
 
     // spin_lock_irqsave(&host->mrq_lock, flags);
     // WARN_ON(!host->mrq->cmd);
@@ -597,6 +530,7 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
     enum aml_mmc_waitfor    xfer_step;
 
     spin_lock_irqsave(&host->mrq_lock, flags);
+
 	
     if((virqs >> sdio_cmd_busy_bit) & 0x1) 
     {      
@@ -609,19 +543,12 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
     mrq = host->mrq;
     xfer_step = host->xfer_step;
 	
-	// sdio_debug_irqstatus(irqs, send);
-	
     if(!mrq->data){
         if(irqs->sdio_response_crc7_ok || send->response_do_not_have_crc7)
             mrq->cmd->error = 0;
         else {
             mrq->cmd->error = -EILSEQ;
-            if(sdio_error_flag == 0){  //set cmd retry cnt when first error.
-                sdio_error_flag |= (1<<0);
-                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
-            }    
             aml_sdio_print_err(host, "cmd crc7 error");
-            
         }
        spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdio_request_done(host->mmc, mrq);
@@ -630,12 +557,7 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
             mrq->cmd->error = 0;
         else {
             mrq->cmd->error = -EILSEQ;
-            if(sdio_error_flag == 0){  //set cmd retry cnt when first error.
-                sdio_error_flag |= (1<<0);
-                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
-            }                
             aml_sdio_print_err(host, "data crc16 error");
-            
         }
         mrq->data->bytes_xfered = mrq->data->blksz*mrq->data->blocks;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
@@ -648,12 +570,6 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
                 host->bn_buf[2], host->bn_buf[3]);
         }
         spin_lock_irqsave(&host->mrq_lock, flags);
-
-        if((mrq->cmd->error == 0) 
-            || (sdio_error_flag && (mrq->cmd->retries == 0))){
-            sdio_error_flag = 0;
-        }
-                
         if(mrq->stop){
             aml_sdio_send_stop(host);
             spin_unlock_irqrestore(&host->mrq_lock, flags);
@@ -691,18 +607,9 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if (aml_check_unsupport_cmd(mmc, mrq))
         return;
 
-    //only for SDCARD hotplag
-    if(!pdata->is_in || (!host->init_flag && aml_card_type_sd(pdata))){
-        spin_lock_irqsave(&host->mrq_lock, flags);
+    if(!pdata->is_in){
         mrq->cmd->error = -ENOMEDIUM;
-        mrq->cmd->retries = 0;
-        host->mrq = NULL;
-        host->xfer_step = XFER_FINISHED;        
-        spin_unlock_irqrestore(&host->mrq_lock, flags);
-        
-        //aml_sdio_request_done(mmc, mrq);
         mmc_request_done(mmc, mrq);
-
         return;
     }
 
@@ -713,14 +620,10 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     host->req_cnt++;
 #endif
 
-    if (mrq->cmd->opcode == 0) {
-        host->init_flag = 1;
-    }
-
     sdio_dbg(AMLSD_DBG_REQ ,"%s: starting CMD%u arg %08x flags %08x\n",
         mmc_hostname(mmc), mrq->cmd->opcode,
         mrq->cmd->arg, mrq->cmd->flags);
-    
+
     if(mrq->data) {
         /*Copy data to dma buffer for write request*/
         aml_sdio_prepare_dma(host, mrq);
@@ -751,7 +654,6 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
         timeout = 500;//mod_timer(&host->timeout_tlist,
                 //jiffies + 500/*10*nsecs_to_jiffies(mrq->data->timeout_ns)*/); // 5s
 //	if(mmc->caps & MMC_CAP_SDIO_IRQ){
-
 	if(SDIO_IRQ_SUPPORT){
 		schedule_delayed_work(&host->timeout, timeout/20); 
 	}else{
@@ -764,17 +666,11 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if(host->xfer_step != XFER_FINISHED && host->xfer_step != XFER_INIT)
         sdio_err("host->xfer_step %d\n", host->xfer_step);
 
-    //clear error flag if last command retried failed here    
-    if(sdio_error_flag & (1<<30)){
-        sdio_error_flag = 0;
-    }
-    
     host->mrq = mrq;
     host->mmc = mmc;
     host->xfer_step = XFER_START;
     host->opcode = mrq->cmd->opcode;
     host->arg = mrq->cmd->arg;
-    host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);    
 
     // if(mrq->data){
         // sdio_dbg(AMLSD_DBG_REQ ,"%s: blksz %d blocks %d flags %08x "
@@ -803,8 +699,6 @@ void aml_sdio_send_stop(struct amlsd_host* host)
 {
     /*Already in mrq_lock*/
     host->cmd_is_stop = 1;
-    sdio_err_bak = host->mrq->cmd->error;
-    host->mrq->cmd->error = 0;
     aml_sdio_start_cmd(host->mmc, &aml_sdio_stop);
 }
 
@@ -820,12 +714,6 @@ static irqreturn_t aml_sdio_irq(int irq, void *dev_id)
     struct mmc_request* mrq;
     unsigned long flags;
 
-    //if(sdio_debug_flag == 9){
-    //    sdio_err("FORCE ignore IRQ here\n");
-    //    sdio_debug_flag = 0;
-    //    return IRQ_HANDLED;
-    //}
-    
     spin_lock_irqsave(&host->mrq_lock, flags);
     mrq = host->mrq;
    // if(!mrq){
@@ -872,7 +760,6 @@ static irqreturn_t aml_sdio_irq(int irq, void *dev_id)
     return IRQ_HANDLED;
 }
 
-
 irqreturn_t aml_sdio_irq_thread(int irq, void *data)
 {
     struct amlsd_host* host = (void*)data;
@@ -893,13 +780,6 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
     spin_lock_irqsave(&host->mrq_lock, flags);
     mrq = host->mrq;
     xfer_step = host->xfer_step;
-
-    if ((xfer_step == XFER_FINISHED) || (xfer_step == XFER_TIMER_TIMEOUT)) {
-        sdhc_err("Warning: xfer_step=%d\n", xfer_step);
-        spin_unlock_irqrestore(&host->mrq_lock, flags);
-        return IRQ_HANDLED;
-    }
-
     if(!mrq){
         sdio_err("CMD%u, arg %08x, mrq NULL xfer_step %d\n", host->opcode, host->arg, xfer_step);
         if(xfer_step == XFER_FINISHED ||
@@ -914,7 +794,6 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
     }
     if(host->cmd_is_stop){
         host->cmd_is_stop = 0;
-        mrq->cmd->error = sdio_err_bak;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdio_request_done(host->mmc, mrq);
         return IRQ_HANDLED;
@@ -927,19 +806,9 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             spin_unlock_irqrestore(&host->mrq_lock, flags);
         } else {
             mrq->cmd->error = -EILSEQ;
-            if(sdio_error_flag == 0){  //set cmd retry cnt when first error.
-                sdio_error_flag |= (1<<0);
-                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
-            }            
             spin_unlock_irqrestore(&host->mrq_lock, flags);
             aml_sdio_print_err(host, "cmd crc7 error");
         }
-        spin_lock_irqsave(&host->mrq_lock, flags);
-        if((mrq->cmd->error == 0) || (sdio_error_flag && (mrq->cmd->retries == 0))){
-            sdio_error_flag = 0;
-        } 
-                
-        spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdio_request_done(host->mmc, mrq);
     }else{
         if(irqs->sdio_data_read_crc16_ok||irqs->sdio_data_write_crc16_ok) {
@@ -947,21 +816,10 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             spin_unlock_irqrestore(&host->mrq_lock, flags);
         } else {
             mrq->cmd->error = -EILSEQ;
-            if(sdio_error_flag == 0){  //set cmd retry cnt when first error.
-                sdio_error_flag |= (1<<0);
-                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
-            }
             spin_unlock_irqrestore(&host->mrq_lock, flags);
             aml_sdio_print_err(host, "data crc16 error");
         }
-		spin_lock_irqsave(&host->mrq_lock, flags);
         mrq->data->bytes_xfered = mrq->data->blksz*mrq->data->blocks;
-       
-        if((mrq->cmd->error == 0) || (sdio_error_flag && (mrq->cmd->retries == 0))){
-            sdio_error_flag = 0;
-        } 
-               
-        spin_unlock_irqrestore(&host->mrq_lock, flags);
         if(mrq->data->flags & MMC_DATA_READ){
             aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len,
                 host->bn_buf, mrq->data->blksz*mrq->data->blocks, 0);
@@ -980,7 +838,6 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             aml_sdio_request_done(host->mmc, mrq);
         }
     }
-    
     return IRQ_HANDLED;
 }
 
@@ -1209,34 +1066,6 @@ static const struct mmc_host_ops aml_sdio_ops = {
     .get_ro = aml_sdio_get_ro,
 };
 
-static ssize_t sdio_debug_func(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
-{
-    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
-    
-    sscanf(buf, "%x", &sdio_debug_flag);    
-    printk("sdio_debug_flag: %d\n", sdio_debug_flag);
-
-    return count;
-}
-
-static ssize_t show_sdio_debug(struct class *class,
-                    struct class_attribute *attr,	char *buf)
-{
-    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
-    
-    printk("sdio_debug_flag: %d\n", sdio_debug_flag);
-    printk("1 : Force sdio cmd crc error \n");
-    printk("2 : Force sdio data crc error \n");
-    printk("9 : Force sdio irq timeout error \n");
-
-    return 0;
-}
-
-static struct class_attribute sdio_class_attrs[] = {
-    __ATTR(debug,  S_IRUGO | S_IWUSR , show_sdio_debug, sdio_debug_func),
-    __ATTR_NULL
-};
-
 static struct amlsd_host* aml_sdio_init_host(void)
 {
     struct amlsd_host *host;
@@ -1269,20 +1098,11 @@ static struct amlsd_host* aml_sdio_init_host(void)
     host->version = AML_MMC_VERSION;
     host->storage_flag = storage_flag;
     host->pinctrl = NULL;
-    
-    host->init_flag = 1;
 
 #ifdef      CONFIG_MMC_AML_DEBUG
     host->req_cnt = 0;
     sdio_err("CONFIG_MMC_AML_DEBUG is on!\n");
 #endif
-
-	host->debug.name = kzalloc(strlen((const char*)AML_SDIO_MAGIC)+1, GFP_KERNEL);
-	strcpy(host->debug.name, (char*)AML_SDIO_MAGIC);
-	host->debug.class_attrs = sdio_class_attrs;
-	if(class_register(&host->debug))
-		printk(" class register nand_class fail!\n");
-		
     return host;
 }
 
@@ -1373,12 +1193,6 @@ static int aml_sdio_probe(struct platform_device *pdev)
         mmc->f_min = pdata->f_min;
         mmc->f_max = pdata->f_max;
 
-        if (aml_card_type_sdio(pdata)) { // if sdio_wifi
-            mmc->host_rescan_disable = true;
-        } else {
-            mmc->host_rescan_disable = false;
-        }
-
         if(pdata->port_init)
             pdata->port_init(pdata);
 
diff --git a/drivers/amlogic/mmc/amlsd.c b/drivers/amlogic/mmc/amlsd.c
index 13bd26a95def..1c6340d0ab8d 100755
--- a/drivers/amlogic/mmc/amlsd.c
+++ b/drivers/amlogic/mmc/amlsd.c
@@ -1152,15 +1152,10 @@ irqreturn_t aml_irq_cd_thread(int irq, void *data)
 {
 	struct amlsd_platform *pdata = (struct amlsd_platform*)data;
 
-    mdelay(20);
+    mdelay(500);
     aml_sd_uart_detect(pdata);
-    
-    if((pdata->is_in == 0) && aml_card_type_sd(pdata)) {
-        pdata->host->init_flag = 0;
-    }
-        
-    //mdelay(500);
-    mmc_detect_change(pdata->mmc, msecs_to_jiffies(200));
+
+    mmc_detect_change(pdata->mmc, msecs_to_jiffies(500));
 
 	return IRQ_HANDLED;
 }
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 7ddd9e1833cb..951a20b5f28f 100755
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -1400,7 +1400,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 		brq->data.flags |= MMC_DATA_READ;
 	} else {
 		brq->cmd.opcode = writecmd;
-		//brq->cmd.retries = 5; // for eMMC debug
+		brq->cmd.retries = 5; // for eMMC debug
 		brq->data.flags |= MMC_DATA_WRITE;
 	}
 
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index fde96dc1e835..ea916f9abd4c 100755
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2398,9 +2398,6 @@ void mmc_rescan(struct work_struct *work)
 	int i;
 	bool extend_wakelock = false;
 
-	if (host->host_rescan_disable)
-		return;
-
 	if (host->rescan_disable)
 		return;
 
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 963b0e729b62..847abe6fc154 100755
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1315,7 +1315,6 @@ static void sdio_rescan (struct mmc_host *host)
     int ret;
 
     host->rescan_entered = 0;
-	host->host_rescan_disable = false;
     mmc_detect_change(host, 0); // start the delayed_work
     ret = flush_work(&(host->detect.work)); // wait for the delayed_work to finish
     if (!ret) {
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index e6de3709b802..f49198343184 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -334,7 +334,6 @@ struct mmc_host {
 
 	int			rescan_disable;	/* disable card detection */
 	int			rescan_entered;	/* used with nonremovable devices */
-	bool		host_rescan_disable;	/* disable card detection */
 
 	struct mmc_card		*card;		/* device attached to this host */
 
-- 
2.19.0

