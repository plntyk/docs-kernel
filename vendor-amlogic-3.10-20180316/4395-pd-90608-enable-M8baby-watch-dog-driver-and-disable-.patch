From 274bc5e84e0ab7d21515056773b6277b1129afeb Mon Sep 17 00:00:00 2001
From: xu xing <xing.xu@amlogic.com>
Date: Thu, 26 Jun 2014 20:19:26 +0800
Subject: [PATCH 4395/5965] pd #90608:enable M8baby watch dog driver,and
 disable default.     if you want to enable it,just open dtd file and change
 watch dog     node'property -- status="okay"

Squashed commit of the following:

commit 3f9ee6661a2baaa0e7f27a813054e807aad419f6
Author: xu xing <xing.xu@amlogic.com>
Date:   Thu Jun 26 19:47:45 2014 +0800

    pd #90608:enable M8baby watch dog driver,and disable default.
    if you want to enable it,just open dtd file and change watch dog
    node'property -- status="okay"

commit 16c228272985681b538579a52cc58aeceb647f7e
Author: xu xing <xing.xu@amlogic.com>
Date:   Fri Jun 20 16:41:14 2014 +0800

    PD #90608:add watch dog driver use kernel watch dog interface.
---
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |  11 +-
 arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd |  10 +
 arch/arm/configs/meson8_defconfig             |  11 +-
 arch/arm/mach-meson6/include/mach/watchdog.h  |  35 ++
 .../arm/mach-meson6tv/include/mach/watchdog.h |  35 ++
 .../mach-meson6tvd/include/mach/watchdog.h    |  35 ++
 arch/arm/mach-meson8/include/mach/watchdog.h  |  35 ++
 arch/arm/mach-meson8/power_suspend.c          |  19 +-
 arch/arm/mach-meson8b/include/mach/watchdog.h |  35 ++
 drivers/amlogic/Kconfig                       |   1 -
 drivers/amlogic/Makefile                      |   3 +-
 drivers/amlogic/boot_monitor/Kconfig          |  10 -
 drivers/amlogic/boot_monitor/Makefile         |   5 -
 drivers/amlogic/boot_monitor/boot_monitor.c   | 283 ----------
 drivers/amlogic/watchdog/Kconfig              |  22 +-
 drivers/amlogic/watchdog/Makefile             |   3 +-
 drivers/amlogic/watchdog/aml_wdt.c            | 318 +++++++++++
 drivers/amlogic/watchdog/aml_wdt.h            |  54 ++
 drivers/amlogic/watchdog/aml_wdt_tv.c         | 493 ------------------
 include/linux/amlogic/aml_wdt.h               |  69 +++
 20 files changed, 663 insertions(+), 824 deletions(-)
 create mode 100644 arch/arm/mach-meson6/include/mach/watchdog.h
 create mode 100644 arch/arm/mach-meson6tv/include/mach/watchdog.h
 create mode 100644 arch/arm/mach-meson6tvd/include/mach/watchdog.h
 create mode 100644 arch/arm/mach-meson8/include/mach/watchdog.h
 create mode 100644 arch/arm/mach-meson8b/include/mach/watchdog.h
 delete mode 100755 drivers/amlogic/boot_monitor/Kconfig
 delete mode 100755 drivers/amlogic/boot_monitor/Makefile
 delete mode 100755 drivers/amlogic/boot_monitor/boot_monitor.c
 create mode 100644 drivers/amlogic/watchdog/aml_wdt.c
 create mode 100644 drivers/amlogic/watchdog/aml_wdt.h
 delete mode 100755 drivers/amlogic/watchdog/aml_wdt_tv.c
 create mode 100644 include/linux/amlogic/aml_wdt.h

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index d5290b3c4632..e28879041fc1 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -2097,7 +2097,16 @@ sdio{
         compatible = "amlogic,cpufreq-meson";
         status = "okay";
     };
-
+	amlogic-watchdog{
+	compatible = "amlogic,aml-wdt";
+	status = "disable";
+	default_timeout=<10>;
+	reset_watchdog_method=<1>;//0:sysfs,1:kernel
+	reset_watchdog_time=<2>;
+	shutdown_timeout=<10>;
+	firmware_timeout=<6>;
+	suspend_timeout=<6>;
+	};
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
index ff364ee27242..e9d6093cd8c9 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
@@ -1830,6 +1830,16 @@ void root_func(){
         status = "okay";
     };
 
+	amlogic-watchdog{
+		compatible = "amlogic,aml-wdt";
+		status = "disable";
+		default_timeout=<10>;
+		reset_watchdog_method=<1>;//0:sysfs,1:kernel
+		reset_watchdog_time=<2>;
+		shutdown_timeout=<10>;
+		firmware_timeout=<6>;
+		suspend_timeout=<6>;
+	};
 //    crypto_device{
 //       compatible = "amlogic,crypto-device";
 //       dev_name = "crypto_device";
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index 5cbc8f4cc738..3274709d97d3 100755
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -39,8 +39,8 @@ CONFIG_PACKET_DIAG=y
 CONFIG_UNIX=y
 CONFIG_UNIX_DIAG=y
 CONFIG_NET_KEY=y
-CONFIG_IP_MULTICAST=y
 CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
 CONFIG_IP_ADVANCED_ROUTER=y
 CONFIG_IP_MULTIPLE_TABLES=y
 CONFIG_INET_ESP=y
@@ -148,7 +148,6 @@ CONFIG_BT_BNEP=y
 CONFIG_BT_BNEP_MC_FILTER=y
 CONFIG_BT_BNEP_PROTO_FILTER=y
 CONFIG_BT_HIDP=y
-CONFIG_BT_RTKBTUSB=y
 CONFIG_BT_HCIUART=y
 CONFIG_BT_HCIUART_H4=y
 CONFIG_CFG80211=y
@@ -179,8 +178,8 @@ CONFIG_GRAVITY_MMA865X=y
 CONFIG_GRAVITY_LSM303D=y
 CONFIG_GRAVITY_DMARD10=y
 CONFIG_GRAVITY_KXTJ9=y
-CONFIG_GRAVITY_STK8312=y
 CONFIG_GRAVITY_STK8313=y
+CONFIG_GRAVITY_STK8312=y
 CONFIG_GRAVITY_MM3A310=y
 CONFIG_GRAVITY_MXC622X=y
 CONFIG_GRAVITY_MXC6255XC=y
@@ -219,8 +218,8 @@ CONFIG_SDIO_DHD_CDC_WIFI_40181_MODULE=m
 CONFIG_BCMDHD_POWER_OFF_IN_SUSPEND=y
 CONFIG_RTL8188EU=m
 CONFIG_RTL8188EU_MP=m
-CONFIG_RTL8723AU=m
 CONFIG_BT_DEVICE=y
+CONFIG_BT_RTKBTUSB=y
 CONFIG_VSYNC_RDMA=y
 CONFIG_AM_VIDEO=y
 CONFIG_AM_ENCODER=y
@@ -354,6 +353,10 @@ CONFIG_PRINTK_TIME=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_READABLE_ASM=y
 CONFIG_DEBUG_FS=y
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC=y
 CONFIG_SCHEDSTATS=y
 CONFIG_TIMER_STATS=y
 CONFIG_DEBUG_INFO=y
diff --git a/arch/arm/mach-meson6/include/mach/watchdog.h b/arch/arm/mach-meson6/include/mach/watchdog.h
new file mode 100644
index 000000000000..755247aec017
--- /dev/null
+++ b/arch/arm/mach-meson6/include/mach/watchdog.h
@@ -0,0 +1,35 @@
+/*
+ *  arch/arm/mach-meson/include/mach/system.h
+ *
+ *  Copyright (C) 2010 AMLOGIC, INC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_WATCHDOG_H
+#define __ASM_ARCH_WATCHDOG_H
+
+#include <linux/io.h>
+#include <plat/io.h>
+#include <mach/hardware.h>
+#include <mach/register.h>
+
+#define WATCHDOG_ENABLE_BIT  22
+#define WATCHDOG_COUNT_MASK ((1<<WATCHDOG_ENABLE_BIT)-1)
+#define WDT_ONE_SECOND 100000
+
+#define MAX_TIMEOUT (WATCHDOG_COUNT_MASK/100000)
+#define MIN_TIMEOUT 1
+
+#endif
diff --git a/arch/arm/mach-meson6tv/include/mach/watchdog.h b/arch/arm/mach-meson6tv/include/mach/watchdog.h
new file mode 100644
index 000000000000..755247aec017
--- /dev/null
+++ b/arch/arm/mach-meson6tv/include/mach/watchdog.h
@@ -0,0 +1,35 @@
+/*
+ *  arch/arm/mach-meson/include/mach/system.h
+ *
+ *  Copyright (C) 2010 AMLOGIC, INC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_WATCHDOG_H
+#define __ASM_ARCH_WATCHDOG_H
+
+#include <linux/io.h>
+#include <plat/io.h>
+#include <mach/hardware.h>
+#include <mach/register.h>
+
+#define WATCHDOG_ENABLE_BIT  22
+#define WATCHDOG_COUNT_MASK ((1<<WATCHDOG_ENABLE_BIT)-1)
+#define WDT_ONE_SECOND 100000
+
+#define MAX_TIMEOUT (WATCHDOG_COUNT_MASK/100000)
+#define MIN_TIMEOUT 1
+
+#endif
diff --git a/arch/arm/mach-meson6tvd/include/mach/watchdog.h b/arch/arm/mach-meson6tvd/include/mach/watchdog.h
new file mode 100644
index 000000000000..755247aec017
--- /dev/null
+++ b/arch/arm/mach-meson6tvd/include/mach/watchdog.h
@@ -0,0 +1,35 @@
+/*
+ *  arch/arm/mach-meson/include/mach/system.h
+ *
+ *  Copyright (C) 2010 AMLOGIC, INC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_WATCHDOG_H
+#define __ASM_ARCH_WATCHDOG_H
+
+#include <linux/io.h>
+#include <plat/io.h>
+#include <mach/hardware.h>
+#include <mach/register.h>
+
+#define WATCHDOG_ENABLE_BIT  22
+#define WATCHDOG_COUNT_MASK ((1<<WATCHDOG_ENABLE_BIT)-1)
+#define WDT_ONE_SECOND 100000
+
+#define MAX_TIMEOUT (WATCHDOG_COUNT_MASK/100000)
+#define MIN_TIMEOUT 1
+
+#endif
diff --git a/arch/arm/mach-meson8/include/mach/watchdog.h b/arch/arm/mach-meson8/include/mach/watchdog.h
new file mode 100644
index 000000000000..755247aec017
--- /dev/null
+++ b/arch/arm/mach-meson8/include/mach/watchdog.h
@@ -0,0 +1,35 @@
+/*
+ *  arch/arm/mach-meson/include/mach/system.h
+ *
+ *  Copyright (C) 2010 AMLOGIC, INC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_WATCHDOG_H
+#define __ASM_ARCH_WATCHDOG_H
+
+#include <linux/io.h>
+#include <plat/io.h>
+#include <mach/hardware.h>
+#include <mach/register.h>
+
+#define WATCHDOG_ENABLE_BIT  22
+#define WATCHDOG_COUNT_MASK ((1<<WATCHDOG_ENABLE_BIT)-1)
+#define WDT_ONE_SECOND 100000
+
+#define MAX_TIMEOUT (WATCHDOG_COUNT_MASK/100000)
+#define MIN_TIMEOUT 1
+
+#endif
diff --git a/arch/arm/mach-meson8/power_suspend.c b/arch/arm/mach-meson8/power_suspend.c
index 274f23e23c2e..294c121af1af 100755
--- a/arch/arm/mach-meson8/power_suspend.c
+++ b/arch/arm/mach-meson8/power_suspend.c
@@ -38,7 +38,7 @@
 #ifdef CONFIG_SUSPEND_WATCHDOG
 #include <mach/watchdog.h>
 #endif /* CONFIG_SUSPEND_WATCHDOG */
-
+#include <linux/amlogic/aml_wdt.h>
 //appf functions
 #define APPF_INITIALIZE             0
 #define APPF_POWER_DOWN_CPU         1
@@ -114,13 +114,18 @@ int meson_power_suspend(void)
 		printk("initial appf\n");
 		pwrtest_entry(APPF_INITIALIZE,0,0,IO_PL310_BASE & 0xffff0000);
 	}
-#ifdef CONFIG_SUSPEND_WATCHDOG
-	DISABLE_SUSPEND_WATCHDOG;
-#endif
+	if(AML_WDT_ENABLED){
+		disable_watchdog();
+		if(awdtv)
+			enable_watchdog(awdtv->firmware_timeout*awdtv->one_second);
+	}
+
 	printk("power down cpu --\n");
 	pwrtest_entry(APPF_POWER_DOWN_CPU,0,0,APPF_SAVE_PMU|APPF_SAVE_VFP|APPF_SAVE_L2 |( IO_PL310_BASE & 0xffff0000));
-#ifdef CONFIG_SUSPEND_WATCHDOG
-	ENABLE_SUSPEND_WATCHDOG;
-#endif
+	if(AML_WDT_ENABLED){
+		disable_watchdog();
+		if(awdtv)
+			enable_watchdog(awdtv->suspend_timeout*awdtv->one_second);
+	}
 	return 0;
 }
diff --git a/arch/arm/mach-meson8b/include/mach/watchdog.h b/arch/arm/mach-meson8b/include/mach/watchdog.h
new file mode 100644
index 000000000000..dc172605934d
--- /dev/null
+++ b/arch/arm/mach-meson8b/include/mach/watchdog.h
@@ -0,0 +1,35 @@
+/*
+ *  arch/arm/mach-meson/include/mach/system.h
+ *
+ *  Copyright (C) 2010 AMLOGIC, INC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_WATCHDOG_H
+#define __ASM_ARCH_WATCHDOG_H
+
+#include <linux/io.h>
+#include <plat/io.h>
+#include <mach/hardware.h>
+#include <mach/register.h>
+
+#define WATCHDOG_ENABLE_BIT  19
+#define WATCHDOG_COUNT_MASK ((1<<16)-1)
+#define WDT_ONE_SECOND 7812 
+
+#define MAX_TIMEOUT (WATCHDOG_COUNT_MASK/WDT_ONE_SECOND)
+#define MIN_TIMEOUT 1
+
+#endif
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index a19c46dbf8e7..67219ed74141 100755
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -23,7 +23,6 @@ source "drivers/amlogic/securitykeys/Kconfig"
 source "drivers/amlogic/keymanage/Kconfig"
 source "drivers/amlogic/efuse/Kconfig"
 source "drivers/amlogic/smartcard/Kconfig"
-source "drivers/amlogic/boot_monitor/Kconfig"
 source "drivers/amlogic/thermal/Kconfig"
 source "drivers/amlogic/watchdog/Kconfig"
 
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 3f27adecc839..c8a3931b8168 100755
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -22,6 +22,7 @@ obj-$(CONFIG_DEINTERLACE) += deinterlace/
 
 ##### Basic drivers#####
 
+obj-y += watchdog/
 obj-y += secure/
 obj-y += securitykeys/
 obj-y += keymanage/
@@ -80,9 +81,7 @@ obj-$(CONFIG_AML_EXT_HDMIIN) += ext_hdmiin/
 
 obj-y += thermal/
 
-obj-$(CONFIG_BOOT_MONITOR) += boot_monitor/
 
-#obj-$(CONFIG_AML_WATCHDOG) += aml_watchdog/
 #####Sound system is later init in kernel default..######################
 obj-$(CONFIG_AMAUDIO) += amaudio/
 obj-$(CONFIG_AMAUDIO2) += amaudio2/
diff --git a/drivers/amlogic/boot_monitor/Kconfig b/drivers/amlogic/boot_monitor/Kconfig
deleted file mode 100755
index 2f036878d35b..000000000000
--- a/drivers/amlogic/boot_monitor/Kconfig
+++ /dev/null
@@ -1,10 +0,0 @@
-
-menu "Amlogic BOOT MONITOR SYSFS"
-
-config BOOT_MONITOR
-	bool "BOOT MONITOR SYSFS"
-	default n
-	---help---
-	  This module adds support for boot monitor sysfs.
-
-endmenu
diff --git a/drivers/amlogic/boot_monitor/Makefile b/drivers/amlogic/boot_monitor/Makefile
deleted file mode 100755
index 16b41a25c336..000000000000
--- a/drivers/amlogic/boot_monitor/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-#
-# Makefile for the Amlogic BOOT MONITOR SYSFS.
-#
-
-obj-$(CONFIG_BOOT_MONITOR)	+= boot_monitor.o
diff --git a/drivers/amlogic/boot_monitor/boot_monitor.c b/drivers/amlogic/boot_monitor/boot_monitor.c
deleted file mode 100755
index 19e4cdeb68ad..000000000000
--- a/drivers/amlogic/boot_monitor/boot_monitor.c
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * Amlogic BOOT MONITOR SYSFS(M6)
- *
- * Copyright (C) 2010 Amlogic Corporation
- *
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
- 
-#include <linux/platform_device.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/err.h>
-
-#include <mach/am_regs.h>
-#include <linux/reboot.h>
-#include <linux/fs.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend early_suspend;
-#endif
-#include <linux/workqueue.h>
-#include <uapi/linux/reboot.h>
-#include <linux/notifier.h>
-
-static struct delayed_work boot_queue;
-static struct notifier_block bm_reboot_nb;
-
-#define WATCHDOG_ENABLE_BIT 22
-static struct platform_device *pdev;
-static int boot_timer_state;
-/* Sysfs Files */
-
-static struct timer_list boot_timer;
-static struct timer_list boot_timer2;
-void boot_timer_func(unsigned long arg);
-void boot_timer2_func(unsigned long arg);
-
-#define BOOT_TIMER_INTERVAL     (HZ*4)
-#define BOOT_TIMER2_INTERVAL    (HZ*600)
-
-static void disable_watchdog(void)
-{
-    printk(KERN_INFO "** disable watchdog\n");
-    aml_write_reg32(P_WATCHDOG_RESET, 0);
-    aml_clr_reg32_mask(P_WATCHDOG_TC,(1 << WATCHDOG_ENABLE_BIT));
-}
-static void enable_watchdog(void)
-{
-	printk(KERN_INFO "** enable watchdog\n");
-    aml_write_reg32(P_WATCHDOG_RESET, 0);
-    aml_write_reg32(P_WATCHDOG_TC, 1 << WATCHDOG_ENABLE_BIT |( 0x186a0*9));//about 9sec
-}
-static void reset_watchdog(void)
-{
-	printk(KERN_INFO "** reset watchdog\n");
-    aml_write_reg32(P_WATCHDOG_RESET, 0);	
-}
-static void reboot_watchdog(void)
-{
-	printk(KERN_INFO "** watchdog reboot\n");
-    aml_write_reg32(P_WATCHDOG_RESET, 0);
-    aml_write_reg32(P_WATCHDOG_TC, 1 << WATCHDOG_ENABLE_BIT | 100);
-}
-
-void boot_timer_func(unsigned long arg)
-{
-    printk("boot_timer_func: <%s>\n", "timer expires, reset watchdog"); 
-    reset_watchdog();
-    mod_timer(&boot_timer, jiffies + BOOT_TIMER_INTERVAL); 
-}
-
-void boot_timer2_func(unsigned long arg)
-{
-    printk("boot_timer2_func: <%s>\n", "timer expires, reboot"); 
-    reboot_watchdog();
-}
-
-static ssize_t boot_timer_set(struct class *cla,struct class_attribute *attr,const char *buf, size_t count)
-{    
-    bool enable = (strncmp(buf, "1", 1) == 0);   
-       
-    if (enable) {
-        printk("boot_timer_set: <%s>,boot_timer_state=%d\n", "start!",boot_timer_state);        
-        if(boot_timer_state == 1)
-            return count;
-
-        init_timer(&boot_timer);
-        boot_timer.data = (ulong) & boot_timer;
-        boot_timer.function = boot_timer_func;
-        boot_timer.expires = jiffies + BOOT_TIMER_INTERVAL;
-        add_timer(&boot_timer); 
-        
-        enable_watchdog();
-        aml_write_reg32(P_AO_RTI_STATUS_REG1, MESON_NORMAL_BOOT);
-        
-        printk("boot_timer2_set: <%s>\n", "start!");
-        init_timer(&boot_timer2);
-        boot_timer2.data = (ulong) & boot_timer2;
-        boot_timer2.function = boot_timer2_func;
-        boot_timer2.expires = jiffies + BOOT_TIMER2_INTERVAL;
-        add_timer(&boot_timer2);         
-        
-    } else {
-        printk("boot_timer_set: <%s>,boot_timer_state = %d\n", "stop!",boot_timer_state);   
-        if(boot_timer_state == 0)
-            return count;     
-                    
-        //del_timer_sync(&boot_timer);
-        
-        printk("disable boot timer2\n");   
-        del_timer_sync(&boot_timer2);
-        //disable_watchdog();
-    }
-    return count;
-}
-    
-static struct class_attribute boot_monitor_class_attrs[] = {
-    __ATTR(boot_timer,
-           S_IRUGO | S_IWUSR,
-           NULL,
-           boot_timer_set),
-    __ATTR_NULL
-};
-
-static struct class boot_monitor_class = {    
-	.name = "boot_monitor",    
-	.class_attrs = boot_monitor_class_attrs,
-
-};
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void meson_system_early_suspend(struct early_suspend *h)
-{	
-	aml_write_reg32(P_WATCHDOG_RESET, 0);
-    	aml_write_reg32(P_WATCHDOG_TC, 1 << WATCHDOG_ENABLE_BIT | (0x186a0*18));//about 18sec
-	return ;
-}
-
-static void meson_system_late_resume(struct early_suspend *h)
-{
-	enable_watchdog();
-	return;
-}
-#endif
-
-static void boot_moniter_work(struct work_struct *work)
-{
-	reset_watchdog();
-	mod_delayed_work(system_freezable_wq, &boot_queue,
-				 round_jiffies(msecs_to_jiffies(1000)));
-}
-static int bm_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
-{ 
-	printk("cacel delay work and reset watch dog\n");
-	cancel_delayed_work(&boot_queue);     
-	aml_write_reg32(P_AO_RTI_STATUS_REG1, MESON_CHARGING_REBOOT);       
-	aml_write_reg32(P_WATCHDOG_RESET, 0);       
-	aml_write_reg32(P_WATCHDOG_TC, 1 << WATCHDOG_ENABLE_BIT | (0x186a0*18));//about 18sec    
-	return NOTIFY_DONE;
-}
-
-/* Device model stuff */
-static int boot_monitor_probe(struct platform_device *dev)
-{
-	int ret;
-	printk(KERN_INFO "boot_monitor: device successfully initialized.\n");
-#if 0
-    init_timer(&boot_timer);
-    boot_timer.data = (ulong) & boot_timer;
-    boot_timer.function = boot_timer_func;
-    boot_timer.expires = jiffies + BOOT_TIMER_INTERVAL;
-    add_timer(&boot_timer); 
-    printk("sandy test  boot_monitor \n");
-#endif
-	INIT_DELAYED_WORK(&boot_queue, boot_moniter_work);
-	boot_moniter_work(NULL);
-    enable_watchdog();
-    aml_write_reg32(P_AO_RTI_STATUS_REG1, MESON_NORMAL_BOOT);
-        init_timer(&boot_timer2);
-        boot_timer2.data = (ulong) & boot_timer2;
-        boot_timer2.function = boot_timer2_func;
-        boot_timer2.expires = jiffies + BOOT_TIMER2_INTERVAL;
-        add_timer(&boot_timer2);         
-
-    boot_timer_state = 1;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
-	early_suspend.suspend = meson_system_early_suspend;
-	early_suspend.resume = meson_system_late_resume;
-	register_early_suspend(&early_suspend);
-#endif
-	bm_reboot_nb.notifier_call = bm_reboot_notifier;
-	bm_reboot_nb.priority=0x7fffffff;
-	 ret = register_reboot_notifier(&bm_reboot_nb);
-	if (ret) {
-		printk("notifier register bm_reboot_notifier fail!\n");
-	}
-	
-	return 0;
-}
-int boot_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	disable_watchdog();
-	return 0;
-}
-
-int boot_resume(struct platform_device *pdev)
-{
-	
-	printk(KERN_INFO "** resume watchdog\n");
-	aml_write_reg32(P_WATCHDOG_RESET, 0);
-	aml_write_reg32(P_WATCHDOG_TC, 1 << WATCHDOG_ENABLE_BIT |( 0x186a0*18));//about 18sec
-	return 0;
-}
-
-static struct platform_driver boot_monitor_driver = {
-	.probe = boot_monitor_probe,
-	.driver	= {
-		.name = "boot_monitor",
-		.owner = THIS_MODULE,
-	},
-	.suspend=boot_suspend,
-	.resume=boot_resume,
-};
-
-/* Module stuff */
-static int __init boot_monitor_init(void)
-{
-	int ret;
-
-	ret = platform_driver_register(&boot_monitor_driver);
-	if (ret)
-		goto out;
-
-	pdev = platform_device_register_simple("boot_monitor", -1, NULL, 0);
-	if (IS_ERR(pdev)) {
-		ret = PTR_ERR(pdev);
-		goto out_driver;
-	}
-
-	ret = class_register(&boot_monitor_class);
-	if (ret)
-		goto out_device;
-
-	printk(KERN_INFO "boot_monitor: driver successfully loaded.\n");
-	return 0;
-
-out_device:
-	platform_device_unregister(pdev);
-out_driver:
-	platform_driver_unregister(&boot_monitor_driver);
-out:
-	printk(KERN_WARNING "boot_monitor: driver init failed (ret=%d)!\n", ret);
-	return ret;
-}
-
-static void __exit boot_monitor_exit(void)
-{
-	class_unregister(&boot_monitor_class);
-	platform_device_unregister(pdev);
-	platform_driver_unregister(&boot_monitor_driver);	
-
-	printk(KERN_INFO "boot_monitor: driver unloaded.\n");
-}
-
-core_initcall(boot_monitor_init);
-module_exit(boot_monitor_exit);
-
-MODULE_DESCRIPTION("Amlogic BOOT MONITOR SYSFS");
-MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/watchdog/Kconfig b/drivers/amlogic/watchdog/Kconfig
index 28d7592d22ec..9343bceab554 100755
--- a/drivers/amlogic/watchdog/Kconfig
+++ b/drivers/amlogic/watchdog/Kconfig
@@ -2,22 +2,12 @@
 # watchdog configuration
 #
 
-menuconfig AML_WATCHDOG
-	bool "Watchdog Support"
-	default n
 
-if AML_WATCHDOG
-
-#config AML_WDT
-#	bool "Amlogic Watchdog"
-#	default n
-#	help
-#	  This module works as watch dog for platform.
-
-config AML_WDT_TV
-	bool "Amlogic TV Watchdog"
-	default n
+config AML_WDT
+	bool "Amlogic Watchdog driver"
+	select WATCHDOG
+	select WATCHDOG_CORE
+	default y
 	help
-	  Amlogic tv watchdog timer embedded in chip.
+	  say y to enable Amlogic watchdog driver.
 
-endif
diff --git a/drivers/amlogic/watchdog/Makefile b/drivers/amlogic/watchdog/Makefile
index 24eb9f882193..700cdc39e88a 100755
--- a/drivers/amlogic/watchdog/Makefile
+++ b/drivers/amlogic/watchdog/Makefile
@@ -2,6 +2,5 @@
 # Makefile for MHL
 #
 
-#obj-$(CONFIG_AML_WDT)		+= aml_wdt.o
-obj-$(CONFIG_AML_WDT_TV)	+= aml_wdt_tv.o
+obj-$(CONFIG_AML_WDT)		+= aml_wdt.o
 
diff --git a/drivers/amlogic/watchdog/aml_wdt.c b/drivers/amlogic/watchdog/aml_wdt.c
new file mode 100644
index 000000000000..d4dd0bfa9adc
--- /dev/null
+++ b/drivers/amlogic/watchdog/aml_wdt.c
@@ -0,0 +1,318 @@
+/*
+ * Amlogic Watchdog Timer Driver for Meson Chip
+ *
+ * Author: Bobby Yang <bo.yang@amlogic.com>
+ *
+ * Copyright (C) 2011 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/watchdog.h>
+#include <linux/of.h>
+#include <linux/amlogic/aml_wdt.h>
+#include <uapi/linux/reboot.h>
+#include <linux/notifier.h>
+#include <linux/suspend.h>
+#include <linux/reboot.h>
+
+struct aml_wdt_dev *awdtv=NULL;
+
+static unsigned int read_watchdog_time(void)
+{
+	printk(KERN_INFO "** read watchdog time\n");
+	return aml_read_reg32(P_WATCHDOG_TC)&((1 << WATCHDOG_ENABLE_BIT)-1);	
+}
+
+static int aml_wdt_start(struct watchdog_device *wdog)
+{
+	struct aml_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+	mutex_lock(&wdev->lock);
+	if(wdog->timeout==0xffffffff)
+		enable_watchdog(wdev->default_timeout * wdev->one_second);
+	else
+		enable_watchdog(wdog->timeout* wdev->one_second);
+	mutex_unlock(&wdev->lock);
+#if 0
+	if(wdev->boot_queue)
+		cancel_delayed_work(&wdev->boot_queue);
+#endif
+	return 0;
+}
+
+static int aml_wdt_stop(struct watchdog_device *wdog)
+{
+	struct aml_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+	mutex_lock(&wdev->lock);
+	disable_watchdog();
+	mutex_unlock(&wdev->lock);
+	return 0;
+}
+
+static int aml_wdt_ping(struct watchdog_device *wdog)
+{
+	struct aml_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+	mutex_lock(&wdev->lock);
+	reset_watchdog();
+	mutex_unlock(&wdev->lock);
+
+	return 0;
+}
+
+static int aml_wdt_set_timeout(struct watchdog_device *wdog,
+				unsigned int timeout)
+{
+	struct aml_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+
+	mutex_lock(&wdev->lock);
+	wdog->timeout = timeout;
+	wdev->timeout = timeout;
+	mutex_unlock(&wdev->lock);
+
+	return 0;
+}
+unsigned int aml_wdt_get_timeleft(struct watchdog_device *wdog)
+{
+	struct aml_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+	unsigned int timeleft;
+	mutex_lock(&wdev->lock);
+	timeleft=read_watchdog_time();
+	mutex_unlock(&wdev->lock);
+	return timeleft/wdev->one_second;
+}
+
+static void boot_moniter_work(struct work_struct *work)
+{
+	struct aml_wdt_dev *wdev=container_of(work,struct aml_wdt_dev,boot_queue.work);
+	reset_watchdog();
+	mod_delayed_work(system_freezable_wq, &wdev->boot_queue,
+				 round_jiffies(msecs_to_jiffies(wdev->reset_watchdog_time*1000)));
+}
+
+static const struct watchdog_info aml_wdt_info = {
+	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	.identity = "aml Watchdog",
+};
+
+static const struct watchdog_ops aml_wdt_ops = {
+	.owner		= THIS_MODULE,
+	.start		= aml_wdt_start,
+	.stop		= aml_wdt_stop,
+	.ping		= aml_wdt_ping,
+	.set_timeout	= aml_wdt_set_timeout,
+	.get_timeleft   = aml_wdt_get_timeleft,
+};
+void aml_init_pdata(struct aml_wdt_dev *wdev)
+{
+	int ret;
+	ret=of_property_read_u32(wdev->dev->of_node, "default_timeout", &wdev->default_timeout);
+	if(ret){
+		dev_err(wdev->dev, "dt probe default_timeout failed: %d using default value\n", ret);
+		wdev->default_timeout=5;
+	}
+	ret=of_property_read_u32(wdev->dev->of_node, "reset_watchdog_method", &wdev->reset_watchdog_method);
+	if(ret){
+		dev_err(wdev->dev, "dt probe reset_watchdog_method failed: %d using default value\n", ret);
+		wdev->reset_watchdog_method=1;
+	}
+	ret=of_property_read_u32(wdev->dev->of_node, "reset_watchdog_time", &wdev->reset_watchdog_time);
+	if(ret){
+		dev_err(wdev->dev, "dt probe reset_watchdog_time failed: %d using default value\n", ret);
+		wdev->reset_watchdog_time=2;
+	}
+	
+	ret=of_property_read_u32(wdev->dev->of_node, "shutdown_timeout", &wdev->shutdown_timeout);
+	if(ret){
+		dev_err(wdev->dev, "dt probe shutdown_timeout failed: %d using default value\n", ret);
+		wdev->shutdown_timeout=10;
+	}
+	
+	ret=of_property_read_u32(wdev->dev->of_node, "firmware_timeout", &wdev->firmware_timeout);
+	if(ret){
+		dev_err(wdev->dev, "dt probe firmware_timeout failed: %d using default value\n", ret);
+		wdev->firmware_timeout=6;
+	}
+	
+	ret=of_property_read_u32(wdev->dev->of_node, "suspend_timeout", &wdev->suspend_timeout);
+	if(ret){
+		dev_err(wdev->dev, "dt probe suspend_timeout failed: %d using default value\n", ret);
+		wdev->suspend_timeout=6;
+	}
+	
+	wdev->one_second=WDT_ONE_SECOND;
+	wdev->max_timeout=MAX_TIMEOUT;
+	wdev->min_timeout=MIN_TIMEOUT;
+	
+	printk("one-secod=%d,min_timeout=%d,max_timeout=%d,default_timeout=%d,reset_watchdog_method=%d,reset_watchdog_time=%d,shutdown_timeout=%d,firmware_timeout=%d,suspend_timeout=%d\n",
+		wdev->one_second,wdev->min_timeout,wdev->max_timeout,
+		wdev->default_timeout,wdev->reset_watchdog_method,
+		wdev->reset_watchdog_time,wdev->shutdown_timeout,
+		wdev->firmware_timeout,wdev->suspend_timeout);
+
+	return;
+}
+static int aml_wtd_pm_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+	
+	if (event == PM_SUSPEND_PREPARE) {
+		printk("set watch dog suspend timeout %d seconds\n",awdtv->suspend_timeout);
+		enable_watchdog(awdtv->suspend_timeout*awdtv->one_second);
+	} 
+	if (event == PM_POST_SUSPEND){
+		printk("resume watch dog finish\n");
+		if(awdtv->timeout==0xffffffff)
+			enable_watchdog(awdtv->default_timeout * awdtv->one_second);
+		else
+			enable_watchdog(awdtv->timeout* awdtv->one_second);
+	}
+	return NOTIFY_OK;
+}
+static int aml_wtd_reboot_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+	if (event == SYS_POWER_OFF) {
+		printk("set watch dog shut down timeout %d seconds\n",awdtv->suspend_timeout);
+		enable_watchdog(awdtv->shutdown_timeout*awdtv->one_second);
+		aml_write_reg32(P_AO_RTI_STATUS_REG1, MESON_CHARGING_REBOOT);
+	} 
+	return NOTIFY_OK;
+}
+
+
+static struct notifier_block aml_wdt_pm_notifier = {
+	.notifier_call = aml_wtd_pm_notify,
+};
+static struct notifier_block aml_wdt_reboot_notifier = {
+	.notifier_call = aml_wtd_reboot_notify,
+};
+
+static int aml_wdt_probe(struct platform_device *pdev)
+{
+	struct watchdog_device *aml_wdt;
+	struct aml_wdt_dev *wdev;
+	int ret;
+	aml_wdt = devm_kzalloc(&pdev->dev, sizeof(*aml_wdt), GFP_KERNEL);
+	if (!aml_wdt)
+		return -ENOMEM;
+
+	wdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);
+	if (!wdev)
+		return -ENOMEM;
+	wdev->dev		= &pdev->dev;
+	mutex_init(&wdev->lock);
+	aml_init_pdata(wdev);
+
+	aml_wdt->info	      = &aml_wdt_info;
+	aml_wdt->ops	      = &aml_wdt_ops;
+	aml_wdt->min_timeout = wdev->min_timeout;
+	aml_wdt->max_timeout = wdev->max_timeout;
+	aml_wdt->timeout=0xffffffff;
+	wdev->timeout=0xffffffff;
+
+	watchdog_set_drvdata(aml_wdt, wdev);
+	platform_set_drvdata(pdev, aml_wdt);
+	if(wdev->reset_watchdog_method==1)
+	{
+		
+		INIT_DELAYED_WORK(&wdev->boot_queue, boot_moniter_work);
+		mod_delayed_work(system_freezable_wq, &wdev->boot_queue,
+					 round_jiffies(msecs_to_jiffies(wdev->reset_watchdog_time*1000)));
+		enable_watchdog(wdev->default_timeout * wdev->one_second);
+		printk("creat work queue for watch dog\n");
+	}
+	ret = watchdog_register_device(aml_wdt);
+	if (ret) 
+		return ret;
+	awdtv=wdev;
+	register_pm_notifier(&aml_wdt_pm_notifier);
+	register_reboot_notifier(&aml_wdt_reboot_notifier);
+	pr_info("AML Watchdog Timer probed done \n");
+
+	return 0;
+}
+
+static void aml_wdt_shutdown(struct platform_device *pdev)
+{
+	struct watchdog_device *wdog = platform_get_drvdata(pdev);
+	struct aml_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+	if(wdev->reset_watchdog_method==1)
+		cancel_delayed_work(&wdev->boot_queue);
+	reset_watchdog();
+}
+
+static int aml_wdt_remove(struct platform_device *pdev)
+{
+	struct watchdog_device *wdog = platform_get_drvdata(pdev);
+	aml_wdt_stop(wdog);
+	return 0;
+}
+
+#ifdef	CONFIG_PM
+static int aml_wdt_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct watchdog_device *wdog = platform_get_drvdata(pdev);
+	reset_watchdog();
+	return 0;
+}
+
+static int aml_wdt_resume(struct platform_device *pdev)
+{
+	struct watchdog_device *wdog = platform_get_drvdata(pdev);
+	struct aml_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+	reset_watchdog();
+	return 0;
+}
+
+#else
+#define	aml_wdt_suspend	NULL
+#define	aml_wdt_resume		NULL
+#endif
+
+static const struct of_device_id aml_wdt_of_match[] = {
+	{ .compatible = "amlogic,aml-wdt", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, aml_wdt_of_match);
+
+static struct platform_driver aml_wdt_driver = {
+	.probe		= aml_wdt_probe,
+	.remove		= aml_wdt_remove,
+	.shutdown	= aml_wdt_shutdown,
+	.suspend	= aml_wdt_suspend,
+	.resume		= aml_wdt_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "aml_wdt",
+		.of_match_table = aml_wdt_of_match,
+	},
+};
+static int __init aml_wdt_driver_init(void) 
+{
+	printk("%s,%d\n",__func__,__LINE__);
+	disable_watchdog();
+	return platform_driver_register(&(aml_wdt_driver)); 
+} 
+module_init(aml_wdt_driver_init); 
+static void __exit aml_wdt_driver_exit(void) 
+{ 
+	platform_driver_unregister(&(aml_wdt_driver) ); 
+} 
+module_exit(aml_wdt_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:aml_wdt");
+
+
diff --git a/drivers/amlogic/watchdog/aml_wdt.h b/drivers/amlogic/watchdog/aml_wdt.h
new file mode 100644
index 000000000000..09b774cf75b9
--- /dev/null
+++ b/drivers/amlogic/watchdog/aml_wdt.h
@@ -0,0 +1,54 @@
+/*
+ *  linux/drivers/char/watchdog/omap_wdt.h
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *      OMAP Watchdog timer register definitions
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _OMAP_WATCHDOG_H
+#define _OMAP_WATCHDOG_H
+
+#define OMAP_WATCHDOG_REV		(0x00)
+#define OMAP_WATCHDOG_SYS_CONFIG	(0x10)
+#define OMAP_WATCHDOG_STATUS		(0x14)
+#define OMAP_WATCHDOG_CNTRL		(0x24)
+#define OMAP_WATCHDOG_CRR		(0x28)
+#define OMAP_WATCHDOG_LDR		(0x2c)
+#define OMAP_WATCHDOG_TGR		(0x30)
+#define OMAP_WATCHDOG_WPS		(0x34)
+#define OMAP_WATCHDOG_SPR		(0x48)
+
+/* Using the prescaler, the OMAP watchdog could go for many
+ * months before firing.  These limits work without scaling,
+ * with the 60 second default assumed by most tools and docs.
+ */
+#define TIMER_MARGIN_MAX	(24 * 60 * 60)	/* 1 day */
+#define TIMER_MARGIN_DEFAULT	60	/* 60 secs */
+#define TIMER_MARGIN_MIN	1
+
+#define PTV			0	/* prescale */
+#define GET_WLDR_VAL(secs)	(0xffffffff - ((secs) * (32768/(1<<PTV))) + 1)
+
+#endif				/* _OMAP_WATCHDOG_H */
diff --git a/drivers/amlogic/watchdog/aml_wdt_tv.c b/drivers/amlogic/watchdog/aml_wdt_tv.c
deleted file mode 100755
index f8333ae38780..000000000000
--- a/drivers/amlogic/watchdog/aml_wdt_tv.c
+++ /dev/null
@@ -1,493 +0,0 @@
-/*
- * Amlogic Watchdog Timer Driver for Meson Chip
- *
- * Author: Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2011 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/moduleparam.h>
-#include <linux/timer.h>
-#include <mach/am_regs.h>
-
-#ifndef WATCHDOG_ENABLE_BIT
-#define WATCHDOG_ENABLE_BIT     (22)
-#endif
-
-#define AML_WDT_PING_TIMEOUT        1   /* 1 seconds  */
-#define AML_WDT_STARTUP_TIMEOUT     30  /* 30 seconds */
-#define AML_WDT_USER_PET_TIMEOUT    45  /* 45 seconds */
-
-#define AML_WDT_DEV_NAME        "aml_wdt"
-
-/* watchdog timer hardware routines */
-static void aml_wdt_settimeout(unsigned int timeout);
-static unsigned int aml_wdt_gettimeout(void);
-static void aml_wdt_set_enable(bool enalbe);
-static bool aml_wdt_get_enable(void);
-static void aml_wdt_keepalive(void);
-
-/* internal timer service routine */
-static void aml_wdt_timer_ping(unsigned long data);
-
-/* internal timer && timerout */
-static struct timer_list ping_timer;
-static int ping_timeout = AML_WDT_PING_TIMEOUT;
-static bool ping_enable = true;
-static bool reset_enable = true;
-
-/*
- * user space will set this value to indicate still alive.
- * the default value indicate that the user space has not startup.
- */
-static unsigned int user_pet = 1;
-static unsigned int user_pet_old = 0;
-static unsigned int user_pet_timeout = AML_WDT_USER_PET_TIMEOUT;
-static unsigned int user_pet_timer_count_max = (AML_WDT_USER_PET_TIMEOUT/AML_WDT_PING_TIMEOUT) + 1;
-static unsigned int user_pet_timer_count = 0;
-
-static unsigned int user_pet_debug = 0; /* print user_pet and  user_pet_old when aml_wdt_timer_ping is called */
-static unsigned int user_pet_reset_enable = 1; /* reset when software watchdog is triggered */
-
-/*
- * set watchdog timer timeout.
- * the watchdog timer issues a chip reset when the watchdog timer timeout.
- * @timeout watchdog reset timeout in second
- * @todo timeout limits supported.
- */
-static inline void aml_wdt_settimeout(unsigned int timeout)
-{
-	unsigned int enable = READ_CBUS_REG_BITS(WATCHDOG_TC, WATCHDOG_ENABLE_BIT, 1);
-	WRITE_CBUS_REG(WATCHDOG_RESET, 0);
-	WRITE_CBUS_REG(WATCHDOG_TC, (enable << WATCHDOG_ENABLE_BIT) | (0x186a0 * timeout));
-}
-
-/*
- * return watchdog timer timeout in second.
- */
-static inline unsigned int aml_wdt_gettimeout(void)
-{
-	return (READ_CBUS_REG_BITS(WATCHDOG_TC, 0, 22) / 0x186a0);
-}
-
-/*
- * enable/disable the watchdog reset
- */
-static inline void aml_wdt_set_enable(bool enable)
-{
-	/* NOTES: if we only write the enalbe bit, the other bits of the register
-	* will be reset to zero, so we must save the other bits value before we
-	* write the enable bit.
-	*/
-	unsigned int timeout = READ_CBUS_REG_BITS(WATCHDOG_TC, 0, 22);
-	reset_enable = enable;
-
-	/* fix reboot by robin.zhu */
-	if (enable) {
-		aml_write_reg32(P_AO_RTI_STATUS_REG0, 0);
-	}
-
-	WRITE_CBUS_REG(WATCHDOG_RESET, 0);
-	WRITE_CBUS_REG(WATCHDOG_TC, ((enable ? 1 : 0) << WATCHDOG_ENABLE_BIT) | timeout);
-}
-
-/*
- * get the watchdog reset status
- */
-static inline bool aml_wdt_get_enable(void)
-{
-	return (READ_CBUS_REG_BITS(WATCHDOG_TC, WATCHDOG_ENABLE_BIT, 1) ? true : false);
-}
-
-static void aml_wdt_hw_init(bool enable, unsigned int timeout)
-{
-	unsigned int val = 0;
-	enable = aml_wdt_get_enable();
-
-	/* fix reboot by robin.zhu */
-	if (enable) {
-		aml_write_reg32(P_AO_RTI_STATUS_REG0, 0);
-	}
-
-	val = (enable ? 1 : 0) << WATCHDOG_ENABLE_BIT;
-	timeout = READ_CBUS_REG_BITS(WATCHDOG_TC, 0, 22);
-	if ((timeout/0x186a0) < AML_WDT_STARTUP_TIMEOUT)
-	timeout = 0x186a0 * AML_WDT_STARTUP_TIMEOUT;
-	val |= timeout;
-	WRITE_CBUS_REG(WATCHDOG_RESET, 0);
-	WRITE_CBUS_REG(WATCHDOG_TC, val);
-}
-
-/*
- * writing with any value will reset the internal counter
- * of the watchdog timer to zero.
- * this will be used to pet the watchdog.
- */
-static inline void aml_wdt_keepalive(void)
-{
-	WRITE_CBUS_REG(WATCHDOG_RESET, 0);
-}
-
-
-static ssize_t aml_wdt_timeout_show(struct device *dev,
-                                    struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%u seconds\n", aml_wdt_gettimeout());
-}
-
-static ssize_t aml_wdt_timeout_store(struct device *dev,
-                                     struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int val = simple_strtoul(buf, NULL, 10);
-	aml_wdt_settimeout(val);
-	return count;
-}
-
-static DEVICE_ATTR(wdt_timeout, S_IRUGO | S_IWUGO, aml_wdt_timeout_show, aml_wdt_timeout_store);
-
-static ssize_t aml_wdt_reset_enable_show(struct device *dev,
-        struct device_attribute *attr, char *buf)
-{
-	int len = 0;
-	bool en = aml_wdt_get_enable();
-	len += sprintf(buf + len, "hardware: %s\n", (en ? "enable" : "disable"));
-	len += sprintf(buf + len, "driver:   %s\n", (reset_enable ? "enable" : "disable"));
-	return len;
-}
-
-static ssize_t aml_wdt_reset_enable_store(struct device *dev,
-        struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int val = simple_strtoul(buf, NULL, 10);
-	reset_enable = val ? true : false;
-	/* 0:false other: true */
-	aml_wdt_set_enable(reset_enable);
-	return count;
-}
-
-static DEVICE_ATTR(reset_enable, S_IRUGO | S_IWUGO, aml_wdt_reset_enable_show, aml_wdt_reset_enable_store);
-
-static ssize_t aml_wdt_ping_timeout_show(struct device *dev,
-        struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%u seconds\n", ping_timeout);
-}
-
-static ssize_t aml_wdt_ping_timeout_store(struct device *dev,
-        struct device_attribute *attr, const char *buf, size_t count)
-{
-	int val = simple_strtoul(buf, NULL, 10);
-	if (val > 0)
-		ping_timeout = val;
-	else
-		ping_timeout = 1;
-	user_pet_timer_count_max = user_pet_timeout/ping_timeout + 1;
-	return count;
-}
-
-static DEVICE_ATTR(ping_timeout, S_IRUGO | S_IWUGO, aml_wdt_ping_timeout_show, aml_wdt_ping_timeout_store);
-
-
-static ssize_t aml_wdt_ping_enable_show(struct device *dev,
-                                        struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%s\n", (ping_enable ? "enable" : "disable"));
-}
-
-static ssize_t aml_wdt_ping_enable_store(struct device *dev,
-        struct device_attribute *attr, const char *buf, size_t count)
-{
-	int val = simple_strtol(buf, NULL, 10);
-	/* 0:disable other:enable */
-	ping_enable = !!val;
-	if (!ping_enable)
-		del_timer(&ping_timer);
-	else
-		mod_timer(&ping_timer, jiffies + (ping_timeout * HZ));
-	return count;
-}
-
-static DEVICE_ATTR(ping_enable, S_IRUGO | S_IWUGO, aml_wdt_ping_enable_show, aml_wdt_ping_enable_store);
-
-static ssize_t aml_wdt_user_pet_timeout_show(struct device *dev,
-        struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%u seconds\n", user_pet_timeout);
-}
-
-static ssize_t aml_wdt_user_pet_timeout_store(struct device *dev,
-        struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int val = simple_strtoul(buf, NULL, 10);
-	user_pet_timeout = val;
-	if (ping_timeout)
-		user_pet_timer_count_max = user_pet_timeout/ping_timeout + 1;
-	return count;
-}
-
-static DEVICE_ATTR(user_pet_timeout, S_IRUGO | S_IWUGO, aml_wdt_user_pet_timeout_show, aml_wdt_user_pet_timeout_store);
-
-/*
- * if user_pet_count is not 0 and does not chagned in 10s,
- * stop pet, and the watchdog timer will reset.
- */
-static void aml_wdt_timer_ping(unsigned long data)
-{
-	if (user_pet) {
-		if(user_pet_debug != 0) {
-			pr_info("%s, user_pet:%u user_pet_old:%u user_pet_timer_count:%u\n", __func__,
-			user_pet, user_pet_old, user_pet_timer_count);
-		}
-
-		if (user_pet_old != user_pet) {
-			user_pet_old = user_pet;
-			user_pet_timer_count = 0;
-		} else
-			user_pet_timer_count++;
-
-		if (user_pet_timer_count < user_pet_timer_count_max) {
-			aml_wdt_keepalive();
-			mod_timer(&ping_timer, jiffies + (ping_timeout * HZ));
-		} else {
-			/* fixed */
-			aml_write_reg32(P_AO_RTI_STATUS_REG0, 0);
-			aml_write_reg32(P_AO_RTI_STATUS_REG1, 0x8765a5a);
-
-			if(user_pet_reset_enable == 0) {
-				user_pet_timer_count = 0;
-				aml_wdt_keepalive();
-			}
-			pr_info("\n*****SOFTWARE WATCHDOG IS Triggered*********************************\n");
-			pr_info("%s, user_pet:%u user_pet_old:%u user_pet_timer_count:%u\n", __func__,
-			user_pet, user_pet_old, user_pet_timer_count);
-			pr_info("*****SOFTWARE WATCHDOG IS Triggered*********************************\n");
-			if(user_pet_reset_enable == 0) {
-				mod_timer(&ping_timer, jiffies + (ping_timeout * HZ));
-			}
-		}
-	} else {
-		aml_wdt_keepalive();
-		mod_timer(&ping_timer, jiffies + (ping_timeout * HZ));
-	}
-}
-
-static int aml_wdt_open(struct inode *inode, struct file *file)
-{
-	/* @todo */
-	return 0;
-}
-
-static int aml_wdt_release(struct inode *inode, struct file *file)
-{
-	/* @todo */
-	return 0;
-}
-
-static long aml_wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	/* @todo */
-	return 0;
-}
-
-static const struct file_operations aml_wdt_fops = {
-	.owner          = THIS_MODULE,
-	.open           = aml_wdt_open,
-	.release        = aml_wdt_release,
-	.unlocked_ioctl     = aml_wdt_ioctl,
-};
-
-static struct miscdevice aml_wdt_miscdev = {
-	.minor = WATCHDOG_MINOR,
-	.name = "watchdog",
-	.fops = &aml_wdt_fops,
-};
-
-static int aml_wdt_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	if (aml_wdt_miscdev.parent)
-		return -EBUSY;
-	aml_wdt_miscdev.parent = &pdev->dev;
-
-	/*
-	* initialize the internal timer.
-	* keeping watchdog timer alive will be done in that internal timer.
-	*/
-	setup_timer(&ping_timer, aml_wdt_timer_ping, 0);
-	if (ping_enable)
-		mod_timer(&ping_timer, jiffies + (ping_timeout * HZ));
-
-	/* register misc device */
-	ret = misc_register(&aml_wdt_miscdev);
-	if (ret) {
-		pr_err("%s, failed to register misc device\n", __func__);
-		goto fail_misc_register;
-	}
-
-	/* create device sysfs */
-	ret = device_create_file(&pdev->dev, &dev_attr_wdt_timeout);
-	ret = device_create_file(&pdev->dev, &dev_attr_reset_enable);
-	if (ret)
-		goto fail_device_create_file1;
-	ret = device_create_file(&pdev->dev, &dev_attr_ping_enable);
-	if (ret)
-		goto fail_device_create_file2;
-	ret = device_create_file(&pdev->dev, &dev_attr_user_pet_timeout);
-	if (ret)
-		goto fail_device_create_file3;
-	ret = device_create_file(&pdev->dev, &dev_attr_ping_timeout);
-
-	user_pet_timer_count_max = user_pet_timeout/ping_timeout + 1;
-
-	/* init && start watchdog timer*/
-	aml_wdt_hw_init(true, AML_WDT_STARTUP_TIMEOUT);
-
-	pr_info("%s, driver probe ok\n", __func__);
-
-	return 0;
-
-fail_device_create_file3:
-	device_remove_file(&pdev->dev, &dev_attr_ping_enable);
-fail_device_create_file2:
-	device_remove_file(&pdev->dev, &dev_attr_reset_enable);
-fail_device_create_file1:
-	misc_deregister(&aml_wdt_miscdev);
-fail_misc_register:
-	del_timer(&ping_timer);
-	return ret;
-}
-
-static int aml_wdt_remove(struct platform_device *pdev)
-{
-	/* stop watchdog timer */
-	aml_wdt_set_enable(false);
-	device_remove_file(&pdev->dev, &dev_attr_user_pet_timeout);
-	device_remove_file(&pdev->dev, &dev_attr_ping_enable);
-	device_remove_file(&pdev->dev, &dev_attr_reset_enable);
-	misc_deregister(&aml_wdt_miscdev);
-	del_timer(&ping_timer);
-	pr_info("%s, driver remove ok\n", __func__);
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static unsigned int reg_wdt_ctrl_saved = 0;
-
-static int aml_wdt_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	reg_wdt_ctrl_saved = READ_CBUS_REG(WATCHDOG_TC);
-	aml_wdt_set_enable(false);
-	aml_wdt_keepalive(); /* i think it is no usage */
-	del_timer(&ping_timer);
-	user_pet = 0;
-	user_pet_timer_count = 0;
-	return 0;
-}
-
-static int aml_wdt_resume(struct platform_device *pdev)
-{
-	if (ping_enable)
-		mod_timer(&ping_timer, jiffies + (ping_timeout * HZ));
-	WRITE_CBUS_REG(WATCHDOG_RESET, 0);
-	WRITE_CBUS_REG(WATCHDOG_TC, reg_wdt_ctrl_saved);
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id aml_wdt_match[] = {
-	{
-		.compatible = "amlogic,aml_wdt_tv",
-	},
-	{},
-};
-#endif
-
-static struct platform_driver aml_wdt_driver = {
-	.driver = {
-		.name = "aml_wdt",
-		.owner  = THIS_MODULE,
-#ifdef CONFIG_USE_OF
-		.of_match_table = aml_wdt_match,
-#endif
-	},
-	.probe = aml_wdt_probe,
-	.remove = aml_wdt_remove,
-#ifdef CONFIG_PM
-	.suspend = aml_wdt_suspend,
-	.resume = aml_wdt_resume,
-#endif
-};
-
-static int __init aml_wdt_init(void)
-{
-	pr_info("%s, register platform driver...\n", __func__);
-	return platform_driver_register(&aml_wdt_driver);
-}
-
-static void __exit aml_wdt_exit(void)
-{
-	platform_driver_unregister(&aml_wdt_driver);
-	pr_info("%s, platform driver unregistered ok\n", __func__);
-}
-
-static int __init aml_wdt_reset_enable_setup (char *str)
-{
-	unsigned int val;
-	val = simple_strtoul(str, NULL, 10);
-	reset_enable = val ? true : false;
-	return 1;
-}
-
-
-__setup ("wdt_reset_en=", aml_wdt_reset_enable_setup);
-
-
-static int __init aml_wdt_ping_enable_setup (char *str)
-{
-	unsigned int val;
-	val = simple_strtoul(str, NULL, 10);
-	ping_enable = val ? true : false;
-	return 1;
-}
-
-
-__setup ("wdt_ping_en=", aml_wdt_ping_enable_setup);
-
-
-module_init(aml_wdt_init);
-module_exit(aml_wdt_exit);
-
-module_param(user_pet, uint, S_IRUGO | S_IWUSR | S_IWGRP);
-MODULE_PARM_DESC(user_pet, "user space pet entry");
-
-module_param(user_pet_timer_count, uint, S_IRUGO | S_IWUSR | S_IWGRP);
-MODULE_PARM_DESC(user_pet_timer_count, "user space pet count");
-
-module_param(user_pet_timer_count_max, uint, S_IRUGO | S_IWUSR | S_IWGRP);
-MODULE_PARM_DESC(user_pet_timer_count_max, "user space pet max count");
-
-module_param(user_pet_debug, uint, S_IRUGO | S_IWUSR | S_IWGRP);
-MODULE_PARM_DESC(user_pet_debug, "user_pet_debug");
-
-module_param(user_pet_reset_enable, uint, S_IRUGO | S_IWUSR | S_IWGRP);
-MODULE_PARM_DESC(user_pet_reset_enable, "user_pet_reset_enable");
-
-
-MODULE_AUTHOR("Bobby Yang <bo.yang@amlogic.com>");
-MODULE_DESCRIPTION("Driver for watchdog timer");
-MODULE_LICENSE("GPL");
-
diff --git a/include/linux/amlogic/aml_wdt.h b/include/linux/amlogic/aml_wdt.h
new file mode 100644
index 000000000000..08c12ab4f707
--- /dev/null
+++ b/include/linux/amlogic/aml_wdt.h
@@ -0,0 +1,69 @@
+/*
+ *  linux/drivers/char/watchdog/omap_wdt.h
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *      OMAP Watchdog timer register definitions
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AML_WATCHDOG_H
+#define _AML_WATCHDOG_H
+#include <mach/watchdog.h>
+#include <mach/am_regs.h>
+struct aml_wdt_dev {
+	unsigned int min_timeout,max_timeout,default_timeout,reset_watchdog_time,shutdown_timeout;
+	unsigned int firmware_timeout,suspend_timeout,timeout;
+	unsigned int one_second;
+	struct device *dev;
+	struct mutex	lock;
+	unsigned int reset_watchdog_method;
+	struct delayed_work boot_queue;
+};
+
+#define AML_WDT_ENABLED (aml_read_reg32(P_WATCHDOG_TC)&(1 << WATCHDOG_ENABLE_BIT))
+static inline void disable_watchdog(void)
+{
+	printk(KERN_INFO "** disable watchdog\n");
+	aml_write_reg32(P_WATCHDOG_RESET, 0);
+	aml_clr_reg32_mask(P_WATCHDOG_TC,(1 << WATCHDOG_ENABLE_BIT));
+}
+static inline void enable_watchdog(unsigned int timeout)
+{
+	printk(KERN_INFO "** enable watchdog\n");
+	aml_write_reg32(P_WATCHDOG_RESET, 0);
+	aml_write_reg32(P_WATCHDOG_TC, 1 << WATCHDOG_ENABLE_BIT |(timeout|WATCHDOG_COUNT_MASK));
+}
+static inline void reset_watchdog(void)
+{
+	printk(KERN_DEBUG"** reset watchdog\n");
+	aml_write_reg32(P_WATCHDOG_RESET, 0);	
+}
+#ifdef CONFIG_AML_WDT
+extern struct aml_wdt_dev *awdtv;
+#else
+struct aml_wdt_dev *awdtv=NULL;
+#endif
+
+
+#endif				/* _OMAP_WATCHDOG_H */
-- 
2.19.0

