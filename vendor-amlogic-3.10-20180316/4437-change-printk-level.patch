From be974fa0c9ce077c979e531f3dc7b18b4d8a5c99 Mon Sep 17 00:00:00 2001
From: Lawrence Mok <lawrence.mok@amlogic.com>
Date: Thu, 3 Jul 2014 13:45:08 -0700
Subject: [PATCH 4437/5965] change printk level

use KERN_ERR for errors only

with bootargs+=quiet, this change saves ~131ms in kernel boot time
aml_dvfs_init saves ~78ms (78 to 0 ms)
rn5t618 saves ~19ms (53 to 33 ms)
---
 arch/arm/mach-meson8/time.c                  |   2 +-
 drivers/amlogic/i2c/aml_i2c.c                |  16 +--
 drivers/amlogic/power/aml_dvfs/aml_dvfs.c    |   4 +-
 drivers/amlogic/power/aml_pmu/aml1212-sply.c | 100 +++++++++----------
 drivers/amlogic/power/aml_pmu/aml1216-sply.c |  64 ++++++------
 drivers/amlogic/power/aml_pmu/aml1218-sply.c |  76 +++++++-------
 drivers/amlogic/power/ricoh/ricoh_pmu.c      |   2 +-
 drivers/amlogic/power/ricoh/rn5t618-sply.c   |  83 +++++++--------
 drivers/amlogic/rtc/aml_rtc.c                |   1 -
 include/linux/amlogic/aml_pmu.h              |  18 +++-
 include/linux/amlogic/ricoh_pmu.h            |   6 +-
 11 files changed, 194 insertions(+), 178 deletions(-)

diff --git a/arch/arm/mach-meson8/time.c b/arch/arm/mach-meson8/time.c
index 91f0923b776e..508f9b5476f7 100755
--- a/arch/arm/mach-meson8/time.c
+++ b/arch/arm/mach-meson8/time.c
@@ -432,7 +432,7 @@ static void __init meson_timer_setup(struct clock_event_device *evt, struct meso
     		|(TIMER_RESOLUTION_1us << clk->bit_resolution)) );
     aml_write_reg32(clk->reg, 9999);
     meson_timer_init_device(&clk->clockevent);
-    printk(KERN_ERR"Global timer: %s (%p) initialized\n",clk->clockevent.name,clk);
+    printk(KERN_DEBUG "Global timer: %s (%p) initialized\n",clk->clockevent.name,clk);
 
     clk->irq.dev_id=&clk->clockevent;
     clk->clockevent.private = (void *)clk;
diff --git a/drivers/amlogic/i2c/aml_i2c.c b/drivers/amlogic/i2c/aml_i2c.c
index 8df5bb46df7d..2d12d56bb537 100755
--- a/drivers/amlogic/i2c/aml_i2c.c
+++ b/drivers/amlogic/i2c/aml_i2c.c
@@ -1007,7 +1007,7 @@ static int aml_i2c_probe(struct platform_device *pdev)
 	resource_size_t *res_start;
 	struct aml_i2c *i2c = kzalloc(sizeof(struct aml_i2c), GFP_KERNEL);
 
-	printk("%s : %s\n", __FILE__, __FUNCTION__);
+	//printk(KERN_DEBUG "%s : %s\n", __FILE__, __FUNCTION__);
 
 	if (!pdev->dev.of_node) {
 			dev_err(&pdev->dev, "no platform data\n");
@@ -1062,7 +1062,7 @@ static int aml_i2c_probe(struct platform_device *pdev)
 	plat = (struct aml_i2c_platform*)aml_i2c_property;
 
 	ret=of_property_read_string(pdev->dev.of_node,"pinctrl-names",&plat->master_state_name);
-	printk("plat->state_name:%s\n",plat->master_state_name);
+	printk(KERN_DEBUG "plat->state_name:%s\n",plat->master_state_name);
 	
   i2c->ops = &aml_i2c_m1_ops;
   i2c->dev=&pdev->dev;
@@ -1074,11 +1074,11 @@ static int aml_i2c_probe(struct platform_device *pdev)
   BUG_ON(!i2c->master_regs);
   BUG_ON(!plat);
 	aml_i2c_set_platform_data(i2c, plat);
-	printk("master_no = %d, maseter_regs=%p\n", i2c->master_no, i2c->master_regs);
+	printk(KERN_DEBUG "master_no = %d, master_regs=%p\n", i2c->master_no, i2c->master_regs);
 	
 	i2c->p=devm_pinctrl_get_select(i2c->dev,i2c->master_state_name);
 	if(IS_ERR(i2c->p)){
-		printk("set i2c pinmux error\n");
+		printk(KERN_ERR "set i2c pinmux error\n");
 		i2c->p=NULL;
 	}
 
@@ -1129,7 +1129,7 @@ static int aml_i2c_probe(struct platform_device *pdev)
     if (i2c->mode == I2C_TIMER_POLLING_MODE) {
       hrtimer_init(&i2c->aml_i2c_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
       i2c->aml_i2c_hrtimer.function = aml_i2c_hrtimer_notify;
-       printk("master %d work in timer polling mode\n", device_id);
+       printk(KERN_DEBUG "master %d work in timer polling mode\n", device_id);
     }
     else if (i2c->mode == I2C_INTERRUPT_MODE) {
       ret = request_irq(i2c->irq, aml_i2c_complete_isr, IRQF_DISABLED, "aml_i2c", i2c);
@@ -1138,7 +1138,7 @@ static int aml_i2c_probe(struct platform_device *pdev)
         i2c->mode = I2C_DELAY_MODE;
       }
       else {
-        printk("master %d work in interrupt mode(irq=%d)\n", device_id, i2c->irq);
+        printk(KERN_DEBUG "master %d work in interrupt mode(irq=%d)\n", device_id, i2c->irq);
       }
     }
     /*setup class*/
@@ -1249,14 +1249,14 @@ static struct platform_driver aml_i2c_driver = {
 static int __init aml_i2c_init(void)
 {
     int ret;
-    printk(KERN_ERR"%s : %s\n", __FILE__, __FUNCTION__);
+    //printk(KERN_INFO "%s : %s\n", __FILE__, __FUNCTION__);
     ret = platform_driver_register(&aml_i2c_driver);
     return ret;
 }
 
 static void __exit aml_i2c_exit(void)
 {
-    printk(KERN_ERR"%s : %s\n", __FILE__, __FUNCTION__);
+    //printk(KERN_INFO "%s : %s\n", __FILE__, __FUNCTION__);
     platform_driver_unregister(&aml_i2c_driver);
 }
 
diff --git a/drivers/amlogic/power/aml_dvfs/aml_dvfs.c b/drivers/amlogic/power/aml_dvfs/aml_dvfs.c
index af53a73f9b21..6515b42fc9e4 100755
--- a/drivers/amlogic/power/aml_dvfs/aml_dvfs.c
+++ b/drivers/amlogic/power/aml_dvfs/aml_dvfs.c
@@ -13,10 +13,10 @@
 #include <linux/sched.h>
 
 #define DVFS_DBG(format, args...) \
-    if (1) printk(KERN_ERR "[DVFS]"format, ##args)
+    if (1) printk(KERN_DEBUG "[DVFS]"format, ##args)
 
 #define DVFS_WARN(format, args...) \
-    if (1) printk(KERN_DEBUG"[DVFS]"format, ##args)
+    if (1) printk(KERN_DEBUG "[DVFS]"format, ##args)
 
 #define DEBUG_DVFS      0
 
diff --git a/drivers/amlogic/power/aml_pmu/aml1212-sply.c b/drivers/amlogic/power/aml_pmu/aml1212-sply.c
index 87894f24c207..720396601f39 100755
--- a/drivers/amlogic/power/aml_pmu/aml1212-sply.c
+++ b/drivers/amlogic/power/aml_pmu/aml1212-sply.c
@@ -54,7 +54,7 @@ static struct wake_lock aml1212_lock;
 #define MAX_BUF         100
 #define CHECK_DRIVER()      \
     if (!g_aml1212_client) {    \
-        AML_PMU_DBG("driver is not ready right now, wait...\n");   \
+        AML_PMU_INFO("driver is not ready right now, wait...\n");   \
         dump_stack();       \
         return -ENODEV;     \
     }
@@ -104,7 +104,7 @@ int aml_pmu_write(int add, uint8_t val)
     buf[2] = val & 0xff;
     ret = i2c_transfer(pdev->adapter, msg, 1);
     if (ret < 0) {
-        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        AML_PMU_ERR("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
         return ret;
     }
     return 0;
@@ -134,7 +134,7 @@ int aml_pmu_write16(int add, uint16_t val)
     buf[3] = (val >> 8) & 0xff;
     ret = i2c_transfer(pdev->adapter, msg, 1);
     if (ret < 0) {
-        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        AML_PMU_ERR("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
         return ret;
     }
     return 0;
@@ -163,7 +163,7 @@ int aml_pmu_writes(int add, uint8_t *buff, int len)
     memcpy(buf + 2, buff, len > MAX_BUF ? MAX_BUF : len);
     ret = i2c_transfer(pdev->adapter, msg, 1);
     if (ret < 0) {
-        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        AML_PMU_ERR("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
         return ret;
     }
     return 0;
@@ -197,7 +197,7 @@ int aml_pmu_read(int add, uint8_t *val)
     buf[1] = (add >> 8) & 0x0f;
     ret = i2c_transfer(pdev->adapter, msg, 2);
     if (ret < 0) {
-        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        AML_PMU_ERR("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
         return ret;
     }
     return 0;
@@ -231,7 +231,7 @@ int aml_pmu_read16(int add, uint16_t *val)
     buf[1] = (add >> 8) & 0x0f;
     ret = i2c_transfer(pdev->adapter, msg, 2);
     if (ret < 0) {
-        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        AML_PMU_ERR("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
         return ret;
     }
     return 0;
@@ -265,7 +265,7 @@ int aml_pmu_reads(int add, uint8_t *buff, int len)
     buf[1] = (add >> 8) & 0x0f;
     ret = i2c_transfer(pdev->adapter, msg, 2);
     if (ret < 0) {
-        AML_PMU_DBG("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
+        AML_PMU_ERR("%s: i2c transfer failed, ret:%d\n", __FUNCTION__, ret);
         return ret;
     }
     return 0;
@@ -306,7 +306,7 @@ int aml_pmu_set_gpio(int pin, int val)
     uint32_t data;
 
     if (pin <= 0 || pin > 4 || val > 1 || val < 0) {
-        AML_PMU_DBG("ERROR, invalid input value, pin = %d, val= %d\n", pin, val);
+        AML_PMU_ERR("ERROR, invalid input value, pin = %d, val= %d\n", pin, val);
         return -EINVAL;
     }
     data = (1 << (pin + 11));
@@ -324,7 +324,7 @@ int aml_pmu_get_gpio(int pin, int *val)
     uint8_t data;
 
     if (pin <= 0 || pin > 4 || !val) { 
-        AML_PMU_DBG("ERROR, invalid input value, pin = %d, val= %p\n", pin, val);
+        AML_PMU_ERR("ERROR, invalid input value, pin = %d, val= %p\n", pin, val);
         return -EINVAL;
     }
     ret = aml_pmu_read(AML1212_GPIO_INPUT_STATUS, &data);
@@ -534,10 +534,10 @@ void aml_pmu_poweroff(void)
     if (pmu_version == 0x03) {
         aml_pmu_set_bits(0x004a, 0x00, 0x08);                   // close clock of charger for REVD
     }
-    AML_PMU_DBG("software goto OFF state\n");
+    AML_PMU_INFO("software goto OFF state\n");
     mdelay(10);
     aml_pmu_write(AML1212_GEN_CNTL1, buf);    
-    AML_PMU_DBG("power off PMU failed\n");
+    AML_PMU_ERR("power off PMU failed\n");
     while (1) {
             
     }
@@ -814,7 +814,7 @@ int aml_pmu_set_usb_current_limit(int curr, int bc_mode)
     if (bc_mode > 0) {
        g1212_supply->usb_connect_type = bc_mode;
     }
-    AML_PMU_DBG("usb connet mode:%d, current limit to:%dmA\n", bc_mode, curr);
+    AML_PMU_INFO("usb connet mode:%d, current limit to:%dmA\n", bc_mode, curr);
     switch (curr) {
     case 0:
         val |= 0x30;                                    // disable limit
@@ -833,7 +833,7 @@ int aml_pmu_set_usb_current_limit(int curr, int bc_mode)
         break;
 
     default:
-        AML_PMU_DBG("%s, wrong usb current limit:%d\n", __func__, curr);
+        AML_PMU_ERR("%s, wrong usb current limit:%d\n", __func__, curr);
         return -1; 
     }
     return aml_pmu_write(AML1212_CHG_CTRL3, val);
@@ -867,7 +867,7 @@ int aml_pmu_set_charge_current(int chg_cur)
         break;
 
     default:
-        AML_PMU_DBG("%s, Wrong charge current:%d\n", __func__, chg_cur);
+        AML_PMU_ERR("%s, Wrong charge current:%d\n", __func__, chg_cur);
         return -1;
     }
     aml_pmu_write(AML1212_CHG_CTRL4, val);
@@ -882,7 +882,7 @@ int aml_pmu_set_charge_voltage(int voltage)
     uint8_t tmp;
     
     if (voltage > 4400000 || voltage < 4050000) {
-        AML_PMU_DBG("%s,Wrong charge voltage:%d\n", __func__, voltage);
+        AML_PMU_ERR("%s,Wrong charge voltage:%d\n", __func__, voltage);
         return -1;
     }
     tmp = ((voltage - 4050000) / 50000) & 0x07;
@@ -910,7 +910,7 @@ int aml_pmu_set_charge_end_rate(int rate)
         break;
 
     default:
-        AML_PMU_DBG("%s, Wrong charge end rate:%d\n", __func__, rate);
+        AML_PMU_ERR("%s, Wrong charge end rate:%d\n", __func__, rate);
         return -1;
     }
     aml_pmu_write(AML1212_CHG_CTRL4, val);
@@ -927,7 +927,7 @@ int aml_pmu_set_adc_freq(int freq)
     int32_t time_bit;
 
     if (freq > 1000 || freq < 10) {
-        AML_PMU_DBG("%s, Wrong adc freq:%d\n", __func__, freq);    
+        AML_PMU_ERR("%s, Wrong adc freq:%d\n", __func__, freq);    
         return -1;
     }
     time = 1000 / freq;
@@ -955,7 +955,7 @@ int aml_pmu_set_precharge_time(int minute)
     uint8_t val;
 
     if (minute > 80 || minute < 30) {
-        AML_PMU_DBG("%s, Wrong pre-charge time:%d\n", __func__, minute);
+        AML_PMU_ERR("%s, Wrong pre-charge time:%d\n", __func__, minute);
         return -1;
     }
     aml_pmu_read(AML1212_CHG_CTRL3, &val);
@@ -974,7 +974,7 @@ int aml_pmu_set_precharge_time(int minute)
         break;
     
     default:
-        AML_PMU_DBG("%s, Wrong pre-charge time:%d\n", __func__, minute);
+        AML_PMU_ERR("%s, Wrong pre-charge time:%d\n", __func__, minute);
         return -1;
     }
     aml_pmu_write(AML1212_CHG_CTRL3, val);
@@ -988,7 +988,7 @@ int aml_pmu_set_fastcharge_time(int minute)
     uint8_t val;
 
     if (minute < 360 || minute > 720) {
-        AML_PMU_DBG("%s, Wrong fast-charge time:%d\n", __func__, minute);
+        AML_PMU_ERR("%s, Wrong fast-charge time:%d\n", __func__, minute);
         return -1;
     }
     aml_pmu_read(AML1212_CHG_CTRL3, &val);
@@ -1007,7 +1007,7 @@ int aml_pmu_set_fastcharge_time(int minute)
         break;
 
     default:
-        AML_PMU_DBG("%s, Wrong pre-charge time:%d\n", __func__, minute);
+        AML_PMU_ERR("%s, Wrong pre-charge time:%d\n", __func__, minute);
         return -1;
     }
     aml_pmu_write(AML1212_CHG_CTRL3, val);
@@ -1041,7 +1041,7 @@ int aml_pmu_set_usb_voltage_limit(int voltage)
     uint8_t val;
 
     if (voltage > 4600 || voltage < 4300) {
-        AML_PMU_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);    
+        AML_PMU_ERR("%s, Wrong usb voltage limit:%d\n", __func__, voltage);    
     }
     aml_pmu_read(AML1212_CHG_CTRL4, &val);
     val &= ~(0xc0);
@@ -1063,7 +1063,7 @@ int aml_pmu_set_usb_voltage_limit(int voltage)
         break;
     
     default:
-        AML_PMU_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);
+        AML_PMU_ERR("%s, Wrong usb voltage limit:%d\n", __func__, voltage);
         return -1;
     }
     aml_pmu_write(AML1212_CHG_CTRL4, val);
@@ -1130,7 +1130,7 @@ static ssize_t aml_pmu_reg_base_store(struct device *dev, struct device_attribut
 {
     int tmp = simple_strtoul(buf, NULL, 16);
     if (tmp > 255) {
-        AML_PMU_DBG("Invalid input value\n");
+        AML_PMU_ERR("Invalid input value\n");
         return -1;
     }
     aml_pmu_regs_base = tmp;
@@ -1149,7 +1149,7 @@ static ssize_t aml_pmu_reg_store(struct device *dev, struct device_attribute *at
 {
     uint8_t data = simple_strtoul(buf, NULL, 16);
     if (data > 255) {
-        AML_PMU_DBG("Invalid input value\n");
+        AML_PMU_ERR("Invalid input value\n");
         return -1;
     }
     aml_pmu_write(aml_pmu_regs_base, data);
@@ -1160,7 +1160,7 @@ static ssize_t aml_pmu_reg_16bit_show(struct device *dev, struct device_attribut
 {
     uint16_t data;
     if (aml_pmu_regs_base & 1){
-        AML_PMU_DBG("Invalid reg base value\n");
+        AML_PMU_ERR("Invalid reg base value\n");
         return -1;
     }
     aml_pmu_read16(aml_pmu_regs_base, &data);
@@ -1171,11 +1171,11 @@ static ssize_t aml_pmu_reg_16bit_store(struct device *dev, struct device_attribu
 {
     uint16_t data = simple_strtoul(buf, NULL, 16);
     if (data > 0xffff) {
-        AML_PMU_DBG("Invalid input value\n");
+        AML_PMU_ERR("Invalid input value\n");
         return -1;
     }
     if (aml_pmu_regs_base & 1){
-        AML_PMU_DBG("Invalid reg base value\n");
+        AML_PMU_ERR("Invalid reg base value\n");
         return -1;
     }
     aml_pmu_write16(aml_pmu_regs_base, data);
@@ -1194,10 +1194,10 @@ static ssize_t aml_pmu_vddao_store(struct device *dev, struct device_attribute *
 {
     uint32_t data = simple_strtoul(buf, NULL, 10);
     if (data > 2000 || data < 740) {
-        AML_PMU_DBG("Invalid input value = %d\n", data);
+        AML_PMU_ERR("Invalid input value = %d\n", data);
         return -1;
     }
-    AML_PMU_DBG("Set VDD_AO to %4d mV\n", data);
+    AML_PMU_INFO("Set VDD_AO to %4d mV\n", data);
     aml_pmu_set_voltage(AML_PMU_DCDC1, data);
     return count; 
 }
@@ -1241,10 +1241,10 @@ static ssize_t charge_timeout_store(struct device *dev, struct device_attribute
 { 
     uint32_t data = simple_strtoul(buf, NULL, 10);
     if (data > 720 || data < 360) {
-        AML_PMU_DBG("Invalid input value = %d\n", data);
+        AML_PMU_ERR("Invalid input value = %d\n", data);
         return -1;
     }
-    AML_PMU_DBG("Set charge timeout to %4d minutes\n", data);
+    AML_PMU_INFO("Set charge timeout to %4d minutes\n", data);
     aml_pmu_set_fastcharge_time(data); 
     return count; 
 }
@@ -1284,7 +1284,7 @@ succeed:
 #ifdef CONFIG_AMLOGIC_USB
 int aml1212_otg_change(struct notifier_block *nb, unsigned long value, void *pdata)
 {
-    AML_PMU_DBG("%s, val:%ld\n", __func__, value);
+    AML_PMU_INFO("%s, val:%ld\n", __func__, value);
     if (value) {        // open OTG
         if (aml1212_init->vbus_dcin_short_connect) {
             aml_pmu_set_dcin(0);                                            // Disable DCIN
@@ -1302,7 +1302,7 @@ int aml1212_otg_change(struct notifier_block *nb, unsigned long value, void *pda
 int aml1212_usb_charger(struct notifier_block *nb, unsigned long value, void *pdata)
 {
     if (!g1212_supply) {
-        AML_PMU_DBG("%s, driver is not ready, do it later\n", __func__);
+        AML_PMU_INFO("%s, driver is not ready, do it later\n", __func__);
         aml1212_late_job.flag  = 1;
         aml1212_late_job.value = value;
         return 0;
@@ -1376,7 +1376,7 @@ static int aml1212_update_status(struct aml_charger *charger)
     charger->fault = ((buff[0] <<  0) | (buff[1] <<  8) |
                       (buff[2] << 16) | (buff[3] << 24));
     if ((!(buff[3] & 0x02)) && !chg_gat_bat_lv) {                       // according David Wang
-        AML_PMU_DBG("CHG_GAT_BAT_LV is 0, limit usb current to 500mA\n");
+        AML_PMU_INFO("CHG_GAT_BAT_LV is 0, limit usb current to 500mA\n");
         aml_pmu_set_usb_current_limit(500, supply->usb_connect_type); 
         chg_gat_bat_lv = 1;
     } else if (buff[3] & 0x02 && chg_gat_bat_lv) {
@@ -1384,15 +1384,15 @@ static int aml1212_update_status(struct aml_charger *charger)
         if (supply->usb_connect_type == USB_BC_MODE_DCP || 
             supply->usb_connect_type == USB_BC_MODE_CDP) {              // reset to 900 when enough current supply
             aml_pmu_set_usb_current_limit(900, supply->usb_connect_type);    
-            AML_PMU_DBG("CHG_GAT_BAT_LV is 1, limit usb current to 900mA\n");
+            AML_PMU_INFO("CHG_GAT_BAT_LV is 1, limit usb current to 900mA\n");
         }
     }
     if (buff[1] & 0x40) {                                               // charge timeout detect
-        AML_PMU_DBG("Charge timeout deteceted\n");
+        AML_PMU_INFO("Charge timeout detected\n");
         if ((aml1212_init->charge_timeout_retry) &&
             (aml1212_init->charge_timeout_retry > re_charge_cnt)) {
             re_charge_cnt++;
-            AML_PMU_DBG("reset charger due to charge timeout occured, ocv :%d, retry:%d\n", 
+            AML_PMU_INFO("reset charger due to charge timeout occured, ocv :%d, retry:%d\n", 
                         charger->ocv, re_charge_cnt);
             aml_pmu_set_fastcharge_time(360);                           // only retry charge 6 hours, for safe problem
             aml_pmu_set_charge_enable(0);
@@ -1533,12 +1533,12 @@ static ssize_t report_delay_store(struct device *dev, struct device_attribute *a
     uint32_t tmp = simple_strtoul(buf, NULL, 10); 
 
     if (tmp > 200) {
-        AML_PMU_DBG("input too large, failed to set report_delay\n");    
+        AML_PMU_ERR("input too large, failed to set report_delay\n");    
     }    
     if (api && api->pmu_set_report_delay) {
         api->pmu_set_report_delay(tmp);
     } else {
-        AML_PMU_DBG("API not found\n");
+        AML_PMU_ERR("API not found\n");
     }
     return count;
 }
@@ -1580,7 +1580,7 @@ static void aml_pmu_charging_monitor(struct work_struct *work)
 
     if (charger->ocv > 5000) {
         // SAR ADC error, only occur when battery voltage is very low
-        AML_PMU_DBG(">> SAR ADC error, ocv:%d, vbat:%d, ibat:%d\n", 
+        AML_PMU_ERR(">> SAR ADC error, ocv:%d, vbat:%d, ibat:%d\n", 
                     charger->ocv, charger->vbat, charger->ibat);
         charger->rest_vol = 0;
     }
@@ -1592,7 +1592,7 @@ static void aml_pmu_charging_monitor(struct work_struct *work)
         aml_pmu_read(AML1212_SP_CHARGER_STATUS3, v);
         if (!(v[0] & 0x08)) {
             check_charge_flag = 1;
-            AML_PMU_DBG("CHG_END_DET = 0 find, close charger for 1 second\n");
+            AML_PMU_INFO("CHG_END_DET = 0 find, close charger for 1 second\n");
             aml_pmu_set_charge_enable(0);
             msleep(1000);
             aml_pmu_set_charge_enable(1);
@@ -1602,7 +1602,7 @@ static void aml_pmu_charging_monitor(struct work_struct *work)
     }
 
     if((charger->rest_vol - pre_rest_cap) || (pre_chg_status != charger->ext_valid) || charger->resume){
-        AML_PMU_DBG("battery vol change: %d->%d \n", pre_rest_cap, charger->rest_vol);
+        AML_PMU_INFO("battery vol change: %d->%d \n", pre_rest_cap, charger->rest_vol);
         if (unlikely(charger->resume)) {
             charger->resume = 0;
         }
@@ -1610,7 +1610,7 @@ static void aml_pmu_charging_monitor(struct work_struct *work)
     #ifdef CONFIG_HAS_EARLYSUSPEND
         if (in_early_suspend && (pre_chg_status != charger->ext_valid)) {
             wake_lock(&aml1212_lock);
-            AML_PMU_DBG("%s, usb power status changed in early suspend, wake up now\n", __func__);
+            AML_PMU_INFO("%s, usb power status changed in early suspend, wake up now\n", __func__);
             input_report_key(aml_pmu_power_key, KEY_POWER, 1);                        // assume power key pressed 
             input_sync(aml_pmu_power_key);
         }
@@ -1670,7 +1670,7 @@ static void aml_pmu_irq_work_func(struct work_struct *work)
                 irq_status[3], irq_status[4], irq_status[5]);
     aml_pmu_writes(AML1212_IRQ_STATUS_CLR_0, irq_status, sizeof(irq_status));       // clear IRQ status
     if (irq_status[5] & 0x08) {
-        AML_PMU_DBG("Over Temperature is occured, shutdown system\n");
+        AML_PMU_ERR("Over Temperature is occured, shutdown system\n");
         aml_pmu_poweroff();
     }
     enable_irq(supply->irq);
@@ -1683,11 +1683,11 @@ static void check_pmu_version(void)
     uint8_t val;
 
     aml_pmu_read(0x007e, &val);
-    AML_PMU_DBG("OTP VERSION: 0x%02x\n", val);
+    AML_PMU_INFO("OTP VERSION: 0x%02x\n", val);
     aml_pmu_read(0x007f, &val);
-    AML_PMU_DBG("PMU VERSION: 0x%02x\n", val);
+    AML_PMU_INFO("PMU VERSION: 0x%02x\n", val);
     if (val > 0x03 || val == 0x00) {
-        AML_PMU_DBG("#### ERROR: unknow pmu version:0x%02x ####\n", val);    
+        AML_PMU_ERR("#### ERROR: unknow pmu version:0x%02x ####\n", val);    
     } else {
         pmu_version = val;
     }
@@ -1786,7 +1786,7 @@ static int aml_pmu_battery_probe(struct platform_device *pdev)
 
     aml_pwr_key_work = create_singlethread_workqueue("aml_pwr_key");
     if (!aml_pwr_key_work) {
-        AML_PMU_DBG("%s, create workqueue failed\n", __func__);
+        AML_PMU_ERR("%s, create workqueue failed\n", __func__);
         return -ENOMEM;    
     }
     INIT_DELAYED_WORK(&pwr_key_work, pwr_key_work_func);
@@ -1919,7 +1919,7 @@ static int aml_pmu_battery_probe(struct platform_device *pdev)
     pmu_reboot_nb.notifier_call = aml_pmu_reboot_notifier;
     ret = register_reboot_notifier(&pmu_reboot_nb);
     if (ret) {
-        AML_PMU_DBG("%s, register reboot notifier failed, ret:%d\n", __func__, ret);
+        AML_PMU_ERR("%s, register reboot notifier failed, ret:%d\n", __func__, ret);
     }
 #endif
 	AML_PMU_DBG("call %s exit, ret:%d", __func__, ret);
diff --git a/drivers/amlogic/power/aml_pmu/aml1216-sply.c b/drivers/amlogic/power/aml_pmu/aml1216-sply.c
index bc6e83963eec..aa9551bfc182 100755
--- a/drivers/amlogic/power/aml_pmu/aml1216-sply.c
+++ b/drivers/amlogic/power/aml_pmu/aml1216-sply.c
@@ -42,7 +42,7 @@
 
 #define CHECK_DRIVER()      \
     if (!g_aml1216_supply) {        \
-        AML1216_DBG("driver is not ready right now, wait...\n");   \
+        AML1216_INFO("driver is not ready right now, wait...\n");   \
         dump_stack();       \
         return -ENODEV;     \
     }
@@ -169,7 +169,7 @@ int aml1216_set_dcin(int enable)
     if (!enable) {
         val |= 0x01;
     }
-    AML1216_DBG("%s:%s\n", __func__, enable ? "enable" : "disable");
+    AML1216_INFO("%s:%s\n", __func__, enable ? "enable" : "disable");
 
     return aml1216_set_bits(0x002a, val, 0x01);
 }
@@ -196,7 +196,7 @@ int aml1216_set_gpio(int pin, int val)
     uint32_t data;
 
     if (pin <= 0 || pin > 4 || val > 1 || val < 0) {
-        AML1216_DBG("ERROR, invalid input value, pin = %d, val= %d\n", pin, val);
+        AML1216_ERR("ERROR, invalid input value, pin = %d, val= %d\n", pin, val);
         return -EINVAL;
     }
     data = (1 << (pin + 11));
@@ -216,7 +216,7 @@ int aml1216_get_gpio(int gpio, int *val)
     uint8_t data;
 
     if (gpio <= 0 || gpio> 4 || !val) { 
-        AML1216_DBG("ERROR, invalid input value, gpio = %d, val= %p\n", gpio, val);
+        AML1216_ERR("ERROR, invalid input value, gpio = %d, val= %p\n", gpio, val);
         return -EINVAL;
     }
     ret = aml1216_read(AML1216_GPIO_INPUT_STATUS, &data);
@@ -242,13 +242,13 @@ void aml1216_power_off()
     aml1216_set_gpio(1, 1);
     aml1216_set_gpio(2, 1);
     aml1216_set_gpio(3, 1);
-    AML1216_DBG("software goto OFF state\n");
+    AML1216_INFO("software goto OFF state\n");
     mdelay(10);
     aml1216_write(AML1216_GEN_CNTL1, buf);    
     udelay(1000);
     while (1) {
         msleep(1000);
-        AML1216_DBG("%s, error\n", __func__);
+        AML1216_ERR("%s, error\n", __func__);
     }
 }
 EXPORT_SYMBOL_GPL(aml1216_power_off);
@@ -257,7 +257,7 @@ int aml1216_set_usb_current_limit(int limit)
 {
     int val;
     if ((limit < 100 || limit > 1600) && (limit != -1)) {
-       AML1216_DBG("%s, wrong usb current limit:%d\n", __func__, limit); 
+       AML1216_ERR("%s, wrong usb current limit:%d\n", __func__, limit); 
        return -1;
     }
     if (limit == -1) {                                       // -1 means not limit, so set limit to max
@@ -266,7 +266,7 @@ int aml1216_set_usb_current_limit(int limit)
     val = (limit-100)/ 100;
     val ^= 0x04;                                            // bit 2 is reverse bit
     
-    AML1216_DBG("%s, set usb current limit to %d, bit:%02x\n", __func__, limit, val);
+    AML1216_INFO("%s, set usb current limit to %d, bit:%02x\n", __func__, limit, val);
     return aml1216_set_bits(0x002D, val, 0x0f);
     
 }
@@ -277,7 +277,7 @@ int aml1216_set_usb_voltage_limit(int voltage)
     uint8_t val;
 
     if (voltage > 4600 || voltage < 4300) {
-        AML1216_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);    
+        AML1216_ERR("%s, Wrong usb voltage limit:%d\n", __func__, voltage);    
     }
     aml1216_read(AML1216_CHG_CTRL5, &val);
     val &= ~(0xc0);
@@ -299,7 +299,7 @@ int aml1216_set_usb_voltage_limit(int voltage)
         break;
     
     default:
-        AML1216_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);
+        AML1216_ERR("%s, Wrong usb voltage limit:%d\n", __func__, voltage);
         return -1;
     }
     aml1216_write(AML1216_CHG_CTRL5, val);
@@ -375,7 +375,7 @@ int aml1216_set_charging_current(int curr)
     int rem;
 
     if (curr > 2100 * 1000 || curr < 0) {
-        AML1216_DBG("%s, wrong input of charge current:%d\n", __func__, curr);
+        AML1216_ERR("%s, wrong input of charge current:%d\n", __func__, curr);
         return -1;
     }
     if (curr > 100) {                        // input is uA
@@ -396,7 +396,7 @@ int aml1216_set_charging_current(int curr)
         idx_to += 1;    
     }
     aml1216_read(0x012b, (unsigned char *)&val);
-    AML1216_DBG("%s to %dmA, idx_to:%x, idx_cur:%x\n", __func__, idx_to * 150 + 300, idx_to, val);
+    AML1216_INFO("%s to %dmA, idx_to:%x, idx_cur:%x\n", __func__, idx_to * 150 + 300, idx_to, val);
     idx_cur = val & 0x0f;
 
     while (idx_cur != idx_to) {
@@ -420,7 +420,7 @@ int aml1216_set_trickle_time(int minutes)
     int bits;
 
     if (minutes < 30 && minutes > 80) {
-        AML1216_DBG("%s, invalid trickle time:%d\n", __func__, minutes);
+        AML1216_ERR("%s, invalid trickle time:%d\n", __func__, minutes);
         return -EINVAL;
     }
     switch (minutes) {
@@ -428,7 +428,7 @@ int aml1216_set_trickle_time(int minutes)
     case 50:     bits = 0x08;     break;
     case 80:     bits = 0x0c;     break;
     default:
-        AML1216_DBG("%s, unsupported trickle value:%d\n", __func__, minutes);
+        AML1216_ERR("%s, unsupported trickle value:%d\n", __func__, minutes);
         return -EINVAL;
     }
     return aml1216_set_bits(0x012A, bits, 0x0c);
@@ -439,7 +439,7 @@ int aml1216_set_rapid_time(int minutes)
     int bits;
 
     if (minutes > 360 || minutes < 720) {
-        AML1216_DBG("%s, invalid rapid time:%d\n", __func__, minutes);
+        AML1216_ERR("%s, invalid rapid time:%d\n", __func__, minutes);
         return -EINVAL;
     }
     switch (minutes) {
@@ -447,7 +447,7 @@ int aml1216_set_rapid_time(int minutes)
     case 540:     bits = 0x08;     break;
     case 720:     bits = 0x0c;     break;
     default:
-        AML1216_DBG("%s, unsupported rapid value:%d\n", __func__, minutes);
+        AML1216_ERR("%s, unsupported rapid value:%d\n", __func__, minutes);
         return -EINVAL;
     }
     return aml1216_set_bits(0x0129, bits, 0x0c);
@@ -459,7 +459,7 @@ int aml1216_set_full_charge_voltage(int voltage)
     uint8_t tmp;
     
     if (voltage > 4400000 || voltage < 4050000) {
-        AML1216_DBG("%s,Wrong charge voltage:%d\n", __func__, voltage);
+        AML1216_ERR("%s,Wrong charge voltage:%d\n", __func__, voltage);
         return -1;
     }
     tmp = ((voltage - 4050000) / 50000);
@@ -487,7 +487,7 @@ int aml1216_set_charge_end_rate(int rate)
         break;
 
     default:
-        AML1216_DBG("%s, Wrong charge end rate:%d\n", __func__, rate);
+        AML1216_ERR("%s, Wrong charge end rate:%d\n", __func__, rate);
         return -1;
     }
     aml1216_write(AML1216_CHG_CTRL6, val);
@@ -516,7 +516,7 @@ static int aml1216_get_coulomber(struct aml_charger *charger)
 
     ret = aml1216_reads(0x0152, buf, 4);
     if (ret) {
-        AML1216_DBG("%s, failed: %d\n", __func__, __LINE__);
+        AML1216_ERR("%s, failed: %d\n", __func__, __LINE__);
         return ret;
     }
 
@@ -542,7 +542,7 @@ static int aml1216_get_coulomber(struct aml_charger *charger)
 
     ret = aml1216_reads(0x0158, buf, 4);
     if (ret) {
-        AML1216_DBG("%s, failed: %d\n", __func__, __LINE__);
+        AML1216_ERR("%s, failed: %d\n", __func__, __LINE__);
         return ret;
     }
     discharge_result = (buf[0] <<  0) |
@@ -665,7 +665,7 @@ static void aml1216_battery_check_health(struct aml1216_supply       *supply,
 
     if (status == 0x30) {
         // TODO: add other check method?
-        AML1216_DBG("%s, battery error detect\n", __func__);
+        AML1216_ERR("%s, battery error detect\n", __func__);
         val->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
     } else {
         val->intval = POWER_SUPPLY_HEALTH_GOOD;
@@ -884,7 +884,7 @@ static void aml1216_otg_work_fun(struct work_struct *work)
     if (aml1216_otg_value == -1) {
         return ;    
     }
-    AML1216_DBG("%s, OTG value:%d, is_short:%d\n", __func__, aml1216_otg_value, g_aml1216_init->vbus_dcin_short_connect);
+    AML1216_INFO("%s, OTG value:%d, is_short:%d\n", __func__, aml1216_otg_value, g_aml1216_init->vbus_dcin_short_connect);
     if (aml1216_otg_value) {
         if (g_aml1216_init->vbus_dcin_short_connect) {
             aml1216_set_dcin(0);                            // cut off dcin for single usb port device
@@ -907,7 +907,7 @@ static void aml1216_otg_work_fun(struct work_struct *work)
 int aml1216_otg_change(struct notifier_block *nb, unsigned long value, void *pdata)
 {
     if (!g_aml1216_supply) {
-        AML1216_DBG("%s, driver is not ready, do it later\n", __func__);
+        AML1216_INFO("%s, driver is not ready, do it later\n", __func__);
         aml1216_otg_job.flag  = 1;
         aml1216_otg_job.value = value;
         return 0;
@@ -920,7 +920,7 @@ int aml1216_otg_change(struct notifier_block *nb, unsigned long value, void *pda
 int aml1216_usb_charger(struct notifier_block *nb, unsigned long value, void *pdata)
 {
     if (!g_aml1216_supply) {
-        AML1216_DBG("%s, driver is not ready, do it later\n", __func__);
+        AML1216_INFO("%s, driver is not ready, do it later\n", __func__);
         aml1216_charger_job.flag  = 1;
         aml1216_charger_job.value = value;
         return 0;
@@ -1238,13 +1238,13 @@ static ssize_t report_delay_store(struct device *dev, struct device_attribute *a
     uint32_t tmp = simple_strtoul(buf, NULL, 10);
 
     if (tmp > 200) {
-        AML1216_DBG("input too large, failed to set report_delay\n");
+        AML1216_ERR("input too large, failed to set report_delay\n");
         return count;
     }
     if (api && api->pmu_set_report_delay) {
         api->pmu_set_report_delay(tmp);
     } else {
-        AML1216_DBG("API not found\n");
+        AML1216_ERR("API not found\n");
     }
     return count;
 }
@@ -1339,7 +1339,7 @@ static int aml1216_update_state(struct aml_charger *charger)
 
     ocv_voltage = charger->ocv;
     if (val & 0x40) {
-        AML1216_DBG("%s, charge timeout, val:0x%02x, reset charger now\n", __func__, val);
+        AML1216_INFO("%s, charge timeout, val:0x%02x, reset charger now\n", __func__, val);
         aml1216_set_charge_enable(0);
         msleep(1000);
         aml1216_set_charge_enable(1);               
@@ -1402,7 +1402,7 @@ static void aml1216_charging_monitor(struct work_struct *work)
         charger->charge_status == CHARGER_DISCHARGING) {
         over_discharge_cnt++;
         if (over_discharge_cnt >= 5) {
-            AML1216_DBG("%s, battery is over-discharge now, force system power off\n", __func__);
+            AML1216_ERR("%s, battery is over-discharge now, force system power off\n", __func__);
             power_protection = 1;
         }
     } else {
@@ -1414,7 +1414,7 @@ static void aml1216_charging_monitor(struct work_struct *work)
         (pre_chg_status != charger->charge_status) ||
         charger->resume                            ||
         power_protection) {
-        AML1216_DBG("battery vol change: %d->%d vsys:%d\n", pre_rest_cap, charger->rest_vol, aml1216_get_vsys_voltage());
+        AML1216_INFO("battery vol change: %d->%d vsys:%d\n", pre_rest_cap, charger->rest_vol, aml1216_get_vsys_voltage());
         if (unlikely(charger->resume)) {
             charger->resume = 0;                                        // MUST clear this flag
         }
@@ -1422,7 +1422,7 @@ static void aml1216_charging_monitor(struct work_struct *work)
     #ifdef CONFIG_HAS_EARLYSUSPEND
         if (in_early_suspend && (pre_pwr_status != charger->ext_valid)) {
             wake_lock(&aml1216_lock);
-            AML_PMU_DBG("%s, usb power status changed in early suspend, wake up now\n", __func__);
+            AML_PMU_INFO("%s, usb power status changed in early suspend, wake up now\n", __func__);
             input_report_key(aml1216_power_key, KEY_POWER, 1);          // assume power key pressed 
             input_sync(aml1216_power_key);
         }
@@ -1506,7 +1506,7 @@ static int aml1216_battery_probe(struct platform_device *pdev)
 
     g_aml1216_init = pdev->dev.platform_data;
     if (g_aml1216_init == NULL) {
-        AML1216_DBG("%s, NO platform data\n", __func__);
+        AML1216_ERR("%s, NO platform data\n", __func__);
         return -EINVAL;
     }
     aml1216_power_key = input_allocate_device();
@@ -1578,7 +1578,7 @@ static int aml1216_battery_probe(struct platform_device *pdev)
         supply->battery_info->use_for_apm        = 1;
         supply->battery_info->name               = aml1216_battery->pmu_battery_name;
     } else {
-        AML1216_DBG(" NO BATTERY_PARAMETERS FOUND\n");
+        AML1216_ERR(" NO BATTERY_PARAMETERS FOUND\n");
     }
 
     charger->soft_limit_to99     = g_aml1216_init->soft_limit_to99;
diff --git a/drivers/amlogic/power/aml_pmu/aml1218-sply.c b/drivers/amlogic/power/aml_pmu/aml1218-sply.c
index ae6931dd424c..ffc6062d8575 100755
--- a/drivers/amlogic/power/aml_pmu/aml1218-sply.c
+++ b/drivers/amlogic/power/aml_pmu/aml1218-sply.c
@@ -42,7 +42,7 @@
 
 #define CHECK_DRIVER()      \
     if (!g_aml1218_supply) {        \
-        AML1218_DBG("driver is not ready right now, wait...\n");   \
+        AML1218_INFO("driver is not ready right now, wait...\n");   \
         dump_stack();       \
         return -ENODEV;     \
     }
@@ -169,7 +169,7 @@ int aml1218_set_dcin(int enable)
     if (!enable) {
         val |= 0x01;
     }
-    AML1218_DBG("%s:%s\n", __func__, enable ? "enable" : "disable");
+    AML1218_INFO("%s:%s\n", __func__, enable ? "enable" : "disable");
 
     return aml1218_set_bits(0x002a, val, 0x01);
 }
@@ -196,7 +196,7 @@ int aml1218_set_gpio(int pin, int val)
     uint32_t data;
 
     if (pin <= 0 || pin > 4 || val > 1 || val < 0) {
-        AML1218_DBG("ERROR, invalid input value, pin = %d, val= %d\n", pin, val);
+        AML1218_ERR("ERROR, invalid input value, pin = %d, val= %d\n", pin, val);
         return -EINVAL;
     }
     data = (1 << (pin + 11));
@@ -216,7 +216,7 @@ int aml1218_get_gpio(int gpio, int *val)
     uint8_t data;
 
     if (gpio <= 0 || gpio> 4 || !val) { 
-        AML1218_DBG("ERROR, invalid input value, gpio = %d, val= %p\n", gpio, val);
+        AML1218_ERR("ERROR, invalid input value, gpio = %d, val= %p\n", gpio, val);
         return -EINVAL;
     }
     ret = aml1218_read(AML1218_GPIO_INPUT_STATUS, &data);
@@ -242,13 +242,13 @@ void aml1218_power_off()
     aml1218_set_gpio(1, 1);
     aml1218_set_gpio(2, 1);
     aml1218_set_gpio(3, 1);
-    AML1218_DBG("software goto OFF state\n");
+    AML1218_INFO("software goto OFF state\n");
     mdelay(10);
     aml1218_write(AML1218_GEN_CNTL1, buf);    
     udelay(1000);
     while (1) {
         msleep(1000);
-        AML1218_DBG("%s, error\n", __func__);
+        AML1218_ERR("%s, error\n", __func__);
     }
 }
 EXPORT_SYMBOL_GPL(aml1218_power_off);
@@ -257,7 +257,7 @@ int aml1218_set_usb_current_limit(int limit)
 {
     int val;
     if ((limit < 100 || limit > 1600) && (limit != -1)) {
-       AML1218_DBG("%s, wrong usb current limit:%d\n", __func__, limit); 
+       AML1218_ERR("%s, wrong usb current limit:%d\n", __func__, limit); 
        return -1;
     }
     if (limit == -1) {                                       // -1 means not limit, so set limit to max
@@ -266,7 +266,7 @@ int aml1218_set_usb_current_limit(int limit)
     val = (limit-100)/ 100;
     val ^= 0x04;                                            // bit 2 is reverse bit
     
-    AML1218_DBG("%s, set usb current limit to %d, bit:%02x\n", __func__, limit, val);
+    AML1218_INFO("%s, set usb current limit to %d, bit:%02x\n", __func__, limit, val);
     return aml1218_set_bits(0x002D, val, 0x0f);
     
 }
@@ -277,7 +277,7 @@ int aml1218_set_usb_voltage_limit(int voltage)
     uint8_t val;
 
     if (voltage > 4600 || voltage < 4300) {
-        AML1218_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);    
+        AML1218_ERR("%s, Wrong usb voltage limit:%d\n", __func__, voltage);    
     }
     aml1218_read(AML1218_CHG_CTRL5, &val);
     val &= ~(0xc0);
@@ -299,7 +299,7 @@ int aml1218_set_usb_voltage_limit(int voltage)
         break;
     
     default:
-        AML1218_DBG("%s, Wrong usb voltage limit:%d\n", __func__, voltage);
+        AML1218_ERR("%s, Wrong usb voltage limit:%d\n", __func__, voltage);
         return -1;
     }
     aml1218_write(AML1218_CHG_CTRL5, val);
@@ -383,7 +383,7 @@ int aml1218_set_charging_current(int curr)
     int rem;
 
     if (curr > 2100 * 1000 || curr < 0) {
-        AML1218_DBG("%s, wrong input of charge current:%d\n", __func__, curr);
+        AML1218_ERR("%s, wrong input of charge current:%d\n", __func__, curr);
         return -1;
     }
     if (curr > 100) {                        // input is uA
@@ -403,7 +403,7 @@ int aml1218_set_charging_current(int curr)
         idx_to += 1;    
     }
     aml1218_read(0x012b, (unsigned char *)&val);
-    AML1218_DBG("%s to %dmA, idx_to:%x, idx_cur:%x\n", __func__, idx_to * 150 + 300, idx_to, val);
+    AML1218_INFO("%s to %dmA, idx_to:%x, idx_cur:%x\n", __func__, idx_to * 150 + 300, idx_to, val);
     idx_cur = val & 0x0f;
 
     while (idx_cur != idx_to) {
@@ -427,7 +427,7 @@ int aml1218_set_trickle_time(int minutes)
     int bits;
 
     if (minutes < 30 && minutes > 80) {
-        AML1218_DBG("%s, invalid trickle time:%d\n", __func__, minutes);
+        AML1218_ERR("%s, invalid trickle time:%d\n", __func__, minutes);
         return -EINVAL;
     }
     switch (minutes) {
@@ -435,7 +435,7 @@ int aml1218_set_trickle_time(int minutes)
     case 50:     bits = 0x08;     break;
     case 80:     bits = 0x0c;     break;
     default:
-        AML1218_DBG("%s, unsupported trickle value:%d\n", __func__, minutes);
+        AML1218_ERR("%s, unsupported trickle value:%d\n", __func__, minutes);
         return -EINVAL;
     }
     return aml1218_set_bits(0x012A, bits, 0x0c);
@@ -446,7 +446,7 @@ int aml1218_set_rapid_time(int minutes)
     int bits;
 
     if (minutes > 360 || minutes < 720) {
-        AML1218_DBG("%s, invalid rapid time:%d\n", __func__, minutes);
+        AML1218_ERR("%s, invalid rapid time:%d\n", __func__, minutes);
         return -EINVAL;
     }
     switch (minutes) {
@@ -454,7 +454,7 @@ int aml1218_set_rapid_time(int minutes)
     case 540:     bits = 0x08;     break;
     case 720:     bits = 0x0c;     break;
     default:
-        AML1218_DBG("%s, unsupported rapid value:%d\n", __func__, minutes);
+        AML1218_ERR("%s, unsupported rapid value:%d\n", __func__, minutes);
         return -EINVAL;
     }
     return aml1218_set_bits(0x0129, bits, 0x0c);
@@ -466,7 +466,7 @@ int aml1218_set_full_charge_voltage(int voltage)
     uint8_t tmp;
     
     if (voltage > 4400000 || voltage < 4050000) {
-        AML1218_DBG("%s,Wrong charge voltage:%d\n", __func__, voltage);
+        AML1218_ERR("%s,Wrong charge voltage:%d\n", __func__, voltage);
         return -1;
     }
     tmp = ((voltage - 4050000) / 50000);
@@ -494,7 +494,7 @@ int aml1218_set_charge_end_rate(int rate)
         break;
 
     default:
-        AML1218_DBG("%s, Wrong charge end rate:%d\n", __func__, rate);
+        AML1218_ERR("%s, Wrong charge end rate:%d\n", __func__, rate);
         return -1;
     }
     aml1218_write(AML1218_CHG_CTRL6, val);
@@ -523,7 +523,7 @@ static int aml1218_get_coulomber(struct aml_charger *charger)
 
     ret = aml1218_reads(0x0152, buf, 4);
     if (ret) {
-        AML1218_DBG("%s, failed: %d\n", __func__, __LINE__);
+        AML1218_ERR("%s, failed: %d\n", __func__, __LINE__);
         return ret;
     }
 
@@ -549,7 +549,7 @@ static int aml1218_get_coulomber(struct aml_charger *charger)
 
     ret = aml1218_reads(0x0158, buf, 4);
     if (ret) {
-        AML1218_DBG("%s, failed: %d\n", __func__, __LINE__);
+        AML1218_ERR("%s, failed: %d\n", __func__, __LINE__);
         return ret;
     }
     discharge_result = (buf[0] <<  0) |
@@ -673,7 +673,7 @@ static void aml1218_battery_check_health(struct aml1218_supply       *supply,
 
     if (status == 0x30) {
         // TODO: add other check method?
-        AML1218_DBG("%s, battery error detect\n", __func__);
+        AML1218_ERR("%s, battery error detect\n", __func__);
         val->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
     } else {
         val->intval = POWER_SUPPLY_HEALTH_GOOD;
@@ -892,7 +892,7 @@ static void aml1218_otg_work_fun(struct work_struct *work)
     if (aml1218_otg_value == -1) {
         return ;    
     }
-    AML1218_DBG("%s, OTG value:%d, is_short:%d\n", __func__, aml1218_otg_value, g_aml1218_init->vbus_dcin_short_connect);
+    AML1218_INFO("%s, OTG value:%d, is_short:%d\n", __func__, aml1218_otg_value, g_aml1218_init->vbus_dcin_short_connect);
     if (aml1218_otg_value) {
         if (g_aml1218_init->vbus_dcin_short_connect) {
             aml1218_set_dcin(0);                            // cut off dcin for single usb port device
@@ -915,7 +915,7 @@ static void aml1218_otg_work_fun(struct work_struct *work)
 int aml1218_otg_change(struct notifier_block *nb, unsigned long value, void *pdata)
 {
     if (!g_aml1218_supply) {
-        AML1218_DBG("%s, driver is not ready, do it later\n", __func__);
+        AML1218_INFO("%s, driver is not ready, do it later\n", __func__);
         aml1218_otg_job.flag  = 1;
         aml1218_otg_job.value = value;
         return 0;
@@ -928,7 +928,7 @@ int aml1218_otg_change(struct notifier_block *nb, unsigned long value, void *pda
 int aml1218_usb_charger(struct notifier_block *nb, unsigned long value, void *pdata)
 {
     if (!g_aml1218_supply) {
-        AML1218_DBG("%s, driver is not ready, do it later\n", __func__);
+        AML1218_INFO("%s, driver is not ready, do it later\n", __func__);
         aml1218_charger_job.flag  = 1;
         aml1218_charger_job.value = value;
         return 0;
@@ -1141,14 +1141,14 @@ int aml1218_dump_all_register(char *buf)
                             17, 18, 19, 20, 21, 22, 23, 24, 34, 35, 36, 37};
 
     if (!buf) {
-        printk("[AML1218] DUMP ALL REGISTERS:\n");
+        printk(KERN_DEBUG "[AML1218] DUMP ALL REGISTERS:\n");
         for (i = 0; i < ARRAY_SIZE(addr_table); i++) {
             aml1218_reads(addr_table[i] * 16, val, 16);
-            printk("0x%03x - %03x: ", addr_table[i] * 16, addr_table[i] * 16 + 15);
-            printk("%02x %02x %02x %02x ",   val[0],  val[1],  val[2],  val[3]);
-            printk("%02x %02x %02x %02x   ", val[4],  val[5],  val[6],  val[7]);
-            printk("%02x %02x %02x %02x ",   val[8],  val[9],  val[10], val[11]);
-            printk("%02x %02x %02x %02x\n",  val[12], val[13], val[14], val[15]);
+            printk(KERN_DEBUG "0x%03x - %03x: ", addr_table[i] * 16, addr_table[i] * 16 + 15);
+            printk(KERN_DEBUG "%02x %02x %02x %02x ",   val[0],  val[1],  val[2],  val[3]);
+            printk(KERN_DEBUG "%02x %02x %02x %02x   ", val[4],  val[5],  val[6],  val[7]);
+            printk(KERN_DEBUG "%02x %02x %02x %02x ",   val[8],  val[9],  val[10], val[11]);
+            printk(KERN_DEBUG "%02x %02x %02x %02x\n",  val[12], val[13], val[14], val[15]);
         }
         return 0;
     }
@@ -1248,13 +1248,13 @@ static ssize_t report_delay_store(struct device *dev, struct device_attribute *a
     uint32_t tmp = simple_strtoul(buf, NULL, 10);
 
     if (tmp > 200) {
-        AML1218_DBG("input too large, failed to set report_delay\n");
+        AML1218_ERR("input too large, failed to set report_delay\n");
         return count;
     }
     if (api && api->pmu_set_report_delay) {
         api->pmu_set_report_delay(tmp);
     } else {
-        AML1218_DBG("API not found\n");
+        AML1218_ERR("API not found\n");
     }
     return count;
 }
@@ -1344,7 +1344,7 @@ static int aml1218_update_state(struct aml_charger *charger)
 
     ocv_voltage = charger->ocv;
     if (chg_status & 0x00004000) {
-        AML1218_DBG("%s, charge timeout happen, status:0x%08x, reset charger now\n", __func__, chg_status);
+        AML1218_INFO("%s, charge timeout happen, status:0x%08x, reset charger now\n", __func__, chg_status);
         aml1218_set_charge_enable(0);
         msleep(1000);
         aml1218_set_charge_enable(1);
@@ -1408,7 +1408,7 @@ static void aml1218_charging_monitor(struct work_struct *work)
         charger->charge_status == CHARGER_DISCHARGING) {
         over_discharge_cnt++;
         if (over_discharge_cnt >= 5) {
-            AML1218_DBG("%s, battery is over-discharge now, force system power off\n", __func__);
+            AML1218_ERR("%s, battery is over-discharge now, force system power off\n", __func__);
             power_protection = 1;
         }
     } else {
@@ -1420,7 +1420,7 @@ static void aml1218_charging_monitor(struct work_struct *work)
         (pre_chg_status != charger->charge_status) ||
         charger->resume                            ||
         power_protection) {
-        AML1218_DBG("battery vol change: %d->%d, vsys:%d\n", pre_rest_cap, charger->rest_vol, aml1218_get_vsys_voltage());
+        AML1218_INFO("battery vol change: %d->%d, vsys:%d\n", pre_rest_cap, charger->rest_vol, aml1218_get_vsys_voltage());
         if (unlikely(charger->resume)) {
             charger->resume = 0;                                        // MUST clear this flag
         }
@@ -1508,11 +1508,11 @@ static int aml1218_battery_probe(struct platform_device *pdev)
     int      ret;
     uint32_t tmp2;
 
-	AML1218_DBG("---> PMU driver version:v0.91_B\n");
+	AML1218_INFO("---> PMU driver version:v0.91_B\n");
 	AML1218_DBG("call %s in", __func__);
     g_aml1218_init = pdev->dev.platform_data;
     if (g_aml1218_init == NULL) {
-        AML1218_DBG("%s, NO platform data\n", __func__);
+        AML1218_ERR("%s, NO platform data\n", __func__);
         return -EINVAL;
     }
     aml1218_power_key = input_allocate_device();
@@ -1584,7 +1584,7 @@ static int aml1218_battery_probe(struct platform_device *pdev)
         supply->battery_info->use_for_apm        = 1;
         supply->battery_info->name               = aml1218_battery->pmu_battery_name;
     } else {
-        AML1218_DBG(" NO BATTERY_PARAMETERS FOUND\n");
+        AML1218_ERR(" NO BATTERY_PARAMETERS FOUND\n");
     }
 
     charger->soft_limit_to99     = g_aml1218_init->soft_limit_to99;
diff --git a/drivers/amlogic/power/ricoh/ricoh_pmu.c b/drivers/amlogic/power/ricoh/ricoh_pmu.c
index 0f5673982fd7..e8dd3736f138 100755
--- a/drivers/amlogic/power/ricoh/ricoh_pmu.c
+++ b/drivers/amlogic/power/ricoh/ricoh_pmu.c
@@ -295,7 +295,7 @@ static int ricoh_pmu_probe(struct i2c_client *client,
     pdev->dev.parent        = &client->dev;
     pdev->dev.platform_data =  init_data; 
     ret = platform_device_add(pdev);
-    RICOH_DBG("%s, %d\n", __func__, __LINE__);
+    printk(KERN_DEBUG "%s, %d\n", __func__, __LINE__);
     if (ret) {
         printk(">> %s, add platform device failed\n", __func__);
         platform_device_del(pdev);
diff --git a/drivers/amlogic/power/ricoh/rn5t618-sply.c b/drivers/amlogic/power/ricoh/rn5t618-sply.c
index 3338a4a65df9..a209640d3abb 100755
--- a/drivers/amlogic/power/ricoh/rn5t618-sply.c
+++ b/drivers/amlogic/power/ricoh/rn5t618-sply.c
@@ -44,7 +44,7 @@
 
 #define CHECK_DRIVER()      \
     if (!g_rn5t618_supply) {        \
-        RICOH_DBG("driver is not ready right now, wait...\n");   \
+        RICOH_INFO("driver is not ready right now, wait...\n");   \
         dump_stack();       \
         return -ENODEV;     \
     }
@@ -177,7 +177,7 @@ int rn5t618_set_gpio(int gpio, int output)
 {
     int val = output ? 1 : 0;
     if (gpio < 0 || gpio > 3) {
-        RICOH_DBG("%s, wrong input of GPIO:%d\n", __func__, gpio);
+        RICOH_ERR("%s, wrong input of GPIO:%d\n", __func__, gpio);
         return -1;
     }
     RICOH_DBG("%s, gpio:%d, output:%d\n", __func__, gpio, output);
@@ -191,7 +191,7 @@ int rn5t618_get_gpio(int gpio, int *val)
 {
     int value;
     if (gpio < 0 || gpio > 3) {
-        RICOH_DBG("%s, wrong input of GPIO:%d\n", __func__, gpio);
+        RICOH_ERR("%s, wrong input of GPIO:%d\n", __func__, gpio);
         return -1;
     }
     rn5t618_read(0x0097, (uint8_t *)&value);                    // read status
@@ -210,13 +210,13 @@ void rn5t618_power_off()
     msleep(100);
     rn5t618_set_bits(0x00EF, 0x00, 0x10);                       // disable coulomb counter
     rn5t618_set_bits(0x00E0, 0x00, 0x01);                       // disable fuel gauge
-    RICOH_DBG("%s, send power off command\n", __func__);
+    RICOH_INFO("%s, send power off command\n", __func__);
     rn5t618_set_bits(0x000f, 0x00, 0x01);                       // do not re-power-on system
     rn5t618_set_bits(0x000E, 0x01, 0x01);                       // software power off PMU
     udelay(1000);
     while (1) {
         msleep(1000);
-        RICOH_DBG("%s, error\n", __func__);
+        RICOH_ERR("%s, error\n", __func__);
     }
 }
 EXPORT_SYMBOL_GPL(rn5t618_power_off);
@@ -225,7 +225,7 @@ int rn5t618_set_usb_current_limit(int limit)
 {
     int val;
     if ((limit < 100 || limit > 1500) && limit != -1){
-        RICOH_DBG("%s, wrong usb current limit:%d\n", __func__, limit);
+        RICOH_ERR("%s, wrong usb current limit:%d\n", __func__, limit);
         return -1;
     }
     if (limit == -1) {                                          // -1 means not limit
@@ -234,7 +234,7 @@ int rn5t618_set_usb_current_limit(int limit)
     } else {
         val = (limit / 100) - 1;
     }
-    RICOH_DBG("%s, set usb current limit to %d mA\n", __func__, limit);
+    RICOH_INFO("%s, set usb current limit to %d mA\n", __func__, limit);
     return rn5t618_set_bits(0x00B7, val, 0x1f);
 }
 EXPORT_SYMBOL_GPL(rn5t618_set_usb_current_limit);
@@ -243,7 +243,7 @@ int rn5t618_set_dcin_current_limit(int limit)
 {
     int val;
     if (limit < 100 || limit > 2500) {
-        RICOH_DBG("%s, wrong usb current limit:%d\n", __func__, limit);
+        RICOH_ERR("%s, wrong usb current limit:%d\n", __func__, limit);
         return -1;
     }
     val = (limit / 100) - 1;
@@ -257,7 +257,7 @@ int rn5t618_set_usb_voltage_limit(int voltage)
     int bits;
 
     if (voltage < 4100 || voltage > 4400) {
-        RICOH_DBG("%s, invalid input voltage:%d\n", __func__, voltage);
+        RICOH_ERR("%s, invalid input voltage:%d\n", __func__, voltage);
         return -EINVAL;
     }
     bits = ((voltage - 4100) / 100) << 2;
@@ -278,7 +278,7 @@ int rn5t618_set_charge_current(int curr)
     int bits;
 
     if (curr < 0 || curr > 1800000) {
-        RICOH_DBG("%s, invalid charge current:%d\n", __func__, curr);
+        RICOH_ERR("%s, invalid charge current:%d\n", __func__, curr);
         return -EINVAL;
     }
     if (curr > 100) {                           // input is uA
@@ -300,7 +300,7 @@ int rn5t618_set_trickle_time(int minutes)
     int bits;
 
     if (minutes != 40 && minutes != 80) {
-        RICOH_DBG("%s, invalid trickle time:%d\n", __func__, minutes);
+        RICOH_ERR("%s, invalid trickle time:%d\n", __func__, minutes);
         return -EINVAL;
     }
     bits = (minutes == 40) ? 0x00 : 0x10;
@@ -312,7 +312,7 @@ int rn5t618_set_long_press_time(int ms)
     int bits;
 
     if (ms < 1000 || ms > 12000) {
-        RICOH_DBG("%s, invalid long press time:%d\n", __func__, ms);
+        RICOH_ERR("%s, invalid long press time:%d\n", __func__, ms);
         return -EINVAL;
     }
     switch(ms) {
@@ -333,7 +333,7 @@ int rn5t618_set_rapid_time(int minutes)
     int bits;
 
     if (minutes > 300 || minutes < 120) {
-        RICOH_DBG("%s, invalid rapid charge time:%d\n", __func__, minutes);    
+        RICOH_ERR("%s, invalid rapid charge time:%d\n", __func__, minutes);    
         return -EINVAL;
     }
     bits = (minutes - 120) / 60;
@@ -345,7 +345,7 @@ int rn5t618_set_full_charge_voltage(int voltage)
     int bits;
 
     if (voltage > 4350 * 1000 || voltage < 4050 * 1000) {
-        RICOH_DBG("%s, invalid target charge voltage:%d\n", __func__, voltage);
+        RICOH_ERR("%s, invalid target charge voltage:%d\n", __func__, voltage);
         return -EINVAL;
     }
     if (voltage == 4350000) {
@@ -361,7 +361,7 @@ int rn5t618_set_charge_end_current(int curr)
     int bits;
 
     if (curr < 50000 || curr > 200000) {
-        RICOH_DBG("%s, invalid charge end current:%d\n", __func__, curr);
+        RICOH_ERR("%s, invalid charge end current:%d\n", __func__, curr);
     }
     bits = (curr / 50000 - 1) << 6;
     return rn5t618_set_bits(0x00B8, bits, 0xc0);
@@ -372,7 +372,7 @@ int rn5t618_set_recharge_voltage(int voltage)
     int bits;
 
     if (voltage < 3850 || voltage > 4100) {
-        RICOH_DBG("%s, invalid recharge volatage:%d\n", __func__, voltage);
+        RICOH_ERR("%s, invalid recharge volatage:%d\n", __func__, voltage);
         return -EINVAL;
     }
     if (voltage == 4100) {
@@ -390,7 +390,7 @@ int rn5t618_get_coulomber_counter(void)
 
     result = rn5t618_reads(0x00F0, val, 3);
     if (result) {
-        RICOH_DBG("%s, failed: %d\n", __func__, __LINE__);
+        RICOH_ERR("%s, failed: %d\n", __func__, __LINE__);
         return result;
     }
 
@@ -435,6 +435,7 @@ int rn5t618_get_saved_coulomb(void)
         RICOH_DBG("no saved coulomb counter\n");    
         return -1;
     }
+    return 0;
 }
 
 static int rn5t618_get_coulomber(struct aml_charger *charger)
@@ -444,7 +445,7 @@ static int rn5t618_get_coulomber(struct aml_charger *charger)
 
     result = rn5t618_reads(0x00F3, val, 4);
     if (result) {
-        RICOH_DBG("%s, failed: %d\n", __func__, __LINE__);
+        RICOH_ERR("%s, failed: %d\n", __func__, __LINE__);
         return result;
     }
 
@@ -586,21 +587,21 @@ static void rn5t618_battery_check_health(struct rn5t618_supply       *supply,
 
     if ((status == RN5T618_DIE_ERROR) || 
         (status == RN5T618_DIE_SHUTDOWN)) {
-        RICOH_DBG("%s, BATTERY DEAD, fault:0x%x\n", __func__, status);
+        RICOH_ERR("%s, BATTERY DEAD, fault:0x%x\n", __func__, status);
         val->intval = POWER_SUPPLY_HEALTH_DEAD;
     } else if (status == RN5T618_BATTERY_TEMPERATURE_ERROR) {
-        RICOH_DBG("%s, BATTERY OVERHEAT, fault:0x%x, temperature:%d\n", 
+        RICOH_ERR("%s, BATTERY OVERHEAT, fault:0x%x, temperature:%d\n", 
                   __func__, status, rn5t618_get_battery_temperature());
         val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
     } else if ((status == RN5T618_CHARGE_OVER_VOLTAGE) || 
                (status == RN5T618_BATTERY_OVER_VOLTAGE)) {
-        RICOH_DBG("%s, BATTERY OVERVOLTAGE, fault:0x%x, voltage:%d\n",
+        RICOH_ERR("%s, BATTERY OVERVOLTAGE, fault:0x%x, voltage:%d\n",
                   __func__, status, rn5t618_get_battery_voltage());
         val->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
     } else if ((status == RN5T618_BATTERY_ERROR) ||
                (status == RN5T618_NO_BATTERY   ) ||
                (status == RN5T618_NO_BATTERY2  )) {
-        RICOH_DBG("%s, BATTERY UNSPEC FAILURE, fault:0x%x\n", __func__, status);
+        RICOH_ERR("%s, BATTERY UNSPEC FAILURE, fault:0x%x\n", __func__, status);
         val->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;    
     } else {
         val->intval = POWER_SUPPLY_HEALTH_GOOD;
@@ -832,13 +833,13 @@ int rn5t618_otg_change(struct notifier_block *nb, unsigned long value, void *pda
 {
     uint8_t val;
     if (!g_rn5t618_supply) {
-        RICOH_DBG("%s, driver is not ready, do it later\n", __func__);
+        RICOH_INFO("%s, driver is not ready, do it later\n", __func__);
         rn5t618_otg_job.flag  = 1;
         rn5t618_otg_job.value = value;
         return 0;
     }
     rn5t618_otg_value = value;
-    RICOH_DBG("%s, value:%d, is_short:%d\n", __func__, rn5t618_otg_value, g_rn5t618_init->vbus_dcin_short_connect);
+    RICOH_INFO("%s, value:%d, is_short:%d\n", __func__, rn5t618_otg_value, g_rn5t618_init->vbus_dcin_short_connect);
     if (rn5t618_otg_value) {
         rn5t618_read(0xB3, &val);
         if (g_rn5t618_init->vbus_dcin_short_connect) {
@@ -875,7 +876,7 @@ int rn5t618_otg_change(struct notifier_block *nb, unsigned long value, void *pda
 int rn5t618_usb_charger(struct notifier_block *nb, unsigned long value, void *pdata)
 {
     if (!g_rn5t618_supply) {
-        RICOH_DBG("%s, driver is not ready, do it later\n", __func__);
+        RICOH_INFO("%s, driver is not ready, do it later\n", __func__);
         rn5t618_charger_job.flag  = 1;
         rn5t618_charger_job.value = value;
         return 0;
@@ -992,7 +993,7 @@ static ssize_t aml_pmu_vddao_store(struct device *dev, struct device_attribute *
     uint32_t data = simple_strtoul(buf, NULL, 10);
 
     if (data > 3500 || data < 600) {
-        RICOH_DBG("Invalid input value = %d\n", data);
+        RICOH_ERR("Invalid input value = %d\n", data);
         return -1;
     }
     RICOH_DBG("Set VDD_AO to %4d mV\n", data);
@@ -1037,7 +1038,7 @@ static ssize_t charge_timeout_store(struct device *dev, struct device_attribute
 { 
     uint32_t data = simple_strtoul(buf, NULL, 10);
     if (data > 300 || data < 120) {
-        RICOH_DBG("Invalid input value = %d\n", data);
+        RICOH_ERR("Invalid input value = %d\n", data);
         return -1;
     }
     RICOH_DBG("Set charge timeout to %4d minutes\n", data);
@@ -1052,14 +1053,14 @@ int rn5t618_dump_all_register(char *buf)
     int     size = 0;
 
     if (!buf) {
-        printk("[RN5T618] DUMP ALL REGISTERS:\n");
+        printk(KERN_DEBUG "[RN5T618] DUMP ALL REGISTERS:\n");
         for (i = 0; i < 16; i++) {
             rn5t618_reads(i*16, val, 16);
-            printk("0x%02x - %02x: ", i * 16, i * 16 + 15);
-            printk("%02x %02x %02x %02x ",   val[0],  val[1],  val[2],  val[3]);
-            printk("%02x %02x %02x %02x   ", val[4],  val[5],  val[6],  val[7]);
-            printk("%02x %02x %02x %02x ",   val[8],  val[9],  val[10], val[11]);
-            printk("%02x %02x %02x %02x\n",  val[12], val[13], val[14], val[15]);
+            printk(KERN_DEBUG "0x%02x - %02x: ", i * 16, i * 16 + 15);
+            printk(KERN_DEBUG "%02x %02x %02x %02x ",   val[0],  val[1],  val[2],  val[3]);
+            printk(KERN_DEBUG "%02x %02x %02x %02x   ", val[4],  val[5],  val[6],  val[7]);
+            printk(KERN_DEBUG "%02x %02x %02x %02x ",   val[8],  val[9],  val[10], val[11]);
+            printk(KERN_DEBUG "%02x %02x %02x %02x\n",  val[12], val[13], val[14], val[15]);
         }
         return 0;
     }
@@ -1158,13 +1159,13 @@ static ssize_t report_delay_store(struct device *dev, struct device_attribute *a
     uint32_t tmp = simple_strtoul(buf, NULL, 10); 
 
     if (tmp > 200) {
-        RICOH_DBG("input too large, failed to set report_delay\n");
+        RICOH_ERR("input too large, failed to set report_delay\n");
         return count;
     }    
     if (api && api->pmu_set_report_delay) {
         api->pmu_set_report_delay(tmp);
     } else {
-        RICOH_DBG("API not found\n");
+        RICOH_ERR("API not found\n");
     }    
     return count;
 }
@@ -1272,7 +1273,7 @@ static int rn5t618_update_state(struct aml_charger *charger)
     }
     rn5t618_read(0x00C5, buff);
     if (buff[0] & 0x20) {
-        RICOH_DBG("charge time out, reset charger\n");
+        RICOH_INFO("charge time out, reset charger\n");
         rn5t618_set_bits(0x00C5, 0x00, 0x20);                           // clear flag
         rn5t618_set_bits(0x00B3, 0x00, 0x03);                           // disable charger
         msleep(100);
@@ -1412,7 +1413,7 @@ static void rn5t618_charging_monitor(struct work_struct *work)
         charger->charge_status == CHARGER_DISCHARGING) {
         over_discharge_cnt++;
         if (over_discharge_cnt >= 5) {
-            RICOH_DBG("%s, battery is over-discharge now, force system power off\n", __func__);
+            RICOH_ERR("%s, battery is over-discharge now, force system power off\n", __func__);
             power_protection = 1;
         }
     } else {
@@ -1424,7 +1425,7 @@ static void rn5t618_charging_monitor(struct work_struct *work)
         (pre_chg_status != charger->charge_status) ||
         charger->resume                            ||
         power_protection) {
-        RICOH_DBG("battery vol change: %d->%d \n", pre_rest_cap, charger->rest_vol);
+        RICOH_INFO("battery vol change: %d->%d \n", pre_rest_cap, charger->rest_vol);
         if (unlikely(charger->resume)) {
             charger->resume = 0;
         }
@@ -1528,7 +1529,7 @@ static int rn5t618_battery_probe(struct platform_device *pdev)
 	RICOH_DBG("call %s in", __func__);
     g_rn5t618_init = pdev->dev.platform_data;
     if (g_rn5t618_init == NULL) {
-        RICOH_DBG("%s, NO platform data\n", __func__);
+        RICOH_ERR("%s, NO platform data\n", __func__);
         return -EINVAL;
     }
     rn5t618_power_key = input_allocate_device();
@@ -1604,7 +1605,7 @@ static int rn5t618_battery_probe(struct platform_device *pdev)
         supply->battery_info->use_for_apm        = 1;
         supply->battery_info->name               = rn5t618_battery->pmu_battery_name;
     } else {
-        RICOH_DBG(" NO BATTERY_PARAMETERS FOUND\n");
+        RICOH_ERR(" NO BATTERY_PARAMETERS FOUND\n");
     }
 
     charger->soft_limit_to99     = g_rn5t618_init->soft_limit_to99;
@@ -1630,7 +1631,7 @@ static int rn5t618_battery_probe(struct platform_device *pdev)
                           RN5T618_IRQ_NAME,
                           supply); 
         if (ret) {
-            RICOH_DBG("request irq failed, ret:%d, irq:%d\n", ret, supply->irq);    
+            RICOH_ERR("request irq failed, ret:%d, irq:%d\n", ret, supply->irq);    
         }
     }
 
diff --git a/drivers/amlogic/rtc/aml_rtc.c b/drivers/amlogic/rtc/aml_rtc.c
index afc186826932..0829610b80ab 100755
--- a/drivers/amlogic/rtc/aml_rtc.c
+++ b/drivers/amlogic/rtc/aml_rtc.c
@@ -905,7 +905,6 @@ static int  __init aml_rtc_init(void)
 	static_register_write(0x3c0a);
 #endif
 	RTC_DBG(RTC_DBG_VAL, "aml_rtc --aml_rtc_init\n");
-	printk(KERN_ERR"%s...\n",__func__);
 	return platform_driver_register(&aml_rtc_driver);
 }
 
diff --git a/include/linux/amlogic/aml_pmu.h b/include/linux/amlogic/aml_pmu.h
index e08a5f6facb6..8edc67923b81 100755
--- a/include/linux/amlogic/aml_pmu.h
+++ b/include/linux/amlogic/aml_pmu.h
@@ -12,7 +12,11 @@
  * debug message control
  */
 #define AML_PMU_DBG(format,args...)                 \
-    if (1) printk(KERN_ERR "[AML_PMU]"format,##args) 
+    if (1) printk(KERN_DEBUG "[AML_PMU]"format,##args)
+#define AML_PMU_INFO(format,args...)                 \
+    if (1) printk(KERN_WARNING "[AML_PMU]"format,##args)
+#define AML_PMU_ERR(format,args...)                 \
+    if (1) printk(KERN_ERR "[AML_PMU]"format,##args)
 
 #define AML_PMU_CHG_ATTR(_name)                     \
 {                                                   \
@@ -220,7 +224,11 @@ extern int aml1212_otg_change(struct notifier_block *nb, unsigned long value, vo
 #define AML1216_CHARGER_NONE                3 
 
 #define AML1216_DBG(format,args...)                 \
-    if (1) printk(KERN_ERR "[AML1216]"format,##args)  
+    if (1) printk(KERN_DEBUG "[AML1216]"format,##args)
+#define AML1216_INFO(format,args...)                 \
+    if (1) printk(KERN_WARNING "[AML1216]"format,##args)
+#define AML1216_ERR(format,args...)                 \
+    if (1) printk(KERN_ERR "[AML1216]"format,##args)
 #define ABS(x)                  ((x) >0 ? (x) : -(x))
 
 #define AML_ATTR(_name)                           \
@@ -352,7 +360,11 @@ extern int aml1216_usb_charger(struct notifier_block *nb, unsigned long value, v
 #define AML1218_CHARGER_NONE                3 
 
 #define AML1218_DBG(format,args...)                 \
-    if (1) printk(KERN_ERR "[AML1218]"format,##args)  
+    if (1) printk(KERN_DEBUG "[AML1218]"format,##args)
+#define AML1218_INFO(format,args...)                 \
+    if (1) printk(KERN_WARNING "[AML1218]"format,##args)
+#define AML1218_ERR(format,args...)                 \
+    if (1) printk(KERN_ERR "[AML1218]"format,##args)
 #define ABS(x)                  ((x) >0 ? (x) : -(x))
 
 #define AML_ATTR(_name)                           \
diff --git a/include/linux/amlogic/ricoh_pmu.h b/include/linux/amlogic/ricoh_pmu.h
index 16def63afb90..ca94aac8dde5 100755
--- a/include/linux/amlogic/ricoh_pmu.h
+++ b/include/linux/amlogic/ricoh_pmu.h
@@ -17,7 +17,11 @@
 #define RN5T618_WORK_CYCLE                  2000
 
 #define RICOH_DBG(format,args...)                 \
-    if (1) printk(KERN_ERR "[RN5T618]"format,##args)  
+    if (1) printk(KERN_DEBUG "[RN5T618]"format,##args)
+#define RICOH_INFO(format,args...)                 \
+    if (1) printk(KERN_WARNING "[RN5T618]"format,##args)
+#define RICOH_ERR(format,args...)                 \
+    if (1) printk(KERN_ERR "[RN5T618]"format,##args)
 #define ABS(x)                  ((x) >0 ? (x) : -(x))
 
 /*
-- 
2.19.0

