From 74fec6747f90e1f7f6e492f76ed9138487e6404e Mon Sep 17 00:00:00 2001
From: "benjamin.zhao" <benjamin.zhao@amlogic.com>
Date: Wed, 2 Jul 2014 19:01:58 +0800
Subject: [PATCH 4523/5965] PD#92925: 1,sdhc rx fifo value improve to avoid rx
 fifo full error           2,Fix sdio wifi error and improve error handle     
      3,fix rx full error issue and sdio wifi back to auto-flush fifo mode

---
 arch/arm/mach-meson6/include/mach/sd.h    |  59 ++-
 arch/arm/mach-meson6tv/include/mach/sd.h  |  69 +++-
 arch/arm/mach-meson6tvd/include/mach/sd.h |  60 ++-
 arch/arm/mach-meson8/include/mach/sd.h    |  12 +-
 arch/arm/mach-meson8b/include/mach/sd.h   |  12 +-
 drivers/amlogic/mmc/aml_sdhc_m8.c         | 455 ++++++++++++++++++----
 drivers/amlogic/mmc/aml_sdio.c            | 199 +++++++++-
 drivers/amlogic/mmc/amlsd.c               |  11 +-
 drivers/amlogic/mmc/amlsd.h               |   4 +-
 drivers/mmc/card/block.c                  |   2 +-
 drivers/mmc/core/core.c                   |   3 +
 drivers/mmc/core/sdio.c                   |   1 +
 include/linux/mmc/host.h                  |   1 +
 13 files changed, 744 insertions(+), 144 deletions(-)

diff --git a/arch/arm/mach-meson6/include/mach/sd.h b/arch/arm/mach-meson6/include/mach/sd.h
index 2f0f9f18a8ae..78436178fc0e 100644
--- a/arch/arm/mach-meson6/include/mach/sd.h
+++ b/arch/arm/mach-meson6/include/mach/sd.h
@@ -13,6 +13,11 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
+#define     AML_ERROR_RETRY_COUNTER         5
+#define     AML_TIMEOUT_RETRY_COUNTER       2
+
+#define AML_SDHC_MAGIC			 "amlsdhc"
+#define AML_SDIO_MAGIC			 "amlsdio"
 enum aml_mmc_waitfor {
 	XFER_INIT,
 	XFER_START,				/* 1 */
@@ -33,6 +38,19 @@ enum aml_mmc_waitfor {
 	XFER_AFTER_START,		/* 16 */
 };
 
+enum aml_host_status { /* Host controller status */
+	HOST_INVALID = 0,       /* 0, invalid value used for initialization */
+	HOST_RX_FIFO_FULL = 1,  /* 1, start with 1 */
+	HOST_TX_FIFO_EMPTY,	    /* 2 */
+	HOST_RSP_CRC_ERR,	    /* 3 */
+	HOST_DAT_CRC_ERR,	    /* 4 */
+	HOST_RSP_TIMEOUT_ERR,   /* 5 */
+	HOST_DAT_TIMEOUT_ERR,   /* 6 */
+    HOST_ERR_END,	        /* 7, end of errors */
+	HOST_TASKLET_CMD,	    /* 8 */
+	HOST_TASKLET_DATA,	    /* 9 */
+};
+
 struct amlsd_host;
 struct amlsd_platform {
 	struct amlsd_host* host;
@@ -56,9 +74,13 @@ struct amlsd_platform {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int clkc;
+	unsigned int clk2;
 	unsigned int clkc_w;
 	unsigned int ctrl;
 	unsigned int clock;
+	unsigned int tune_phase;            /* store tuning result */
+	unsigned char signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
+
 	unsigned int low_burst;
 	unsigned int irq_in;
 	unsigned int irq_in_edge;
@@ -74,6 +96,9 @@ struct amlsd_platform {
     unsigned int jtag_pin;
     int is_sduart;
     bool is_in;
+    bool is_tuned;                      /* if card has been tuning */
+    bool need_retuning;
+	struct delayed_work	retuning;
 
     /* we used this flag to filter some unnecessary cmd before initialized flow */
     bool is_fir_init; // has been initialized for the first time
@@ -131,21 +156,22 @@ struct amlsd_host {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int f_min;
-	struct tasklet_struct cmd_tlet;
-	struct tasklet_struct data_tlet;
-	struct tasklet_struct busy_tlet;
-	struct tasklet_struct to_tlet;
+	// struct tasklet_struct cmd_tlet;
+	// struct tasklet_struct data_tlet;
+	// struct tasklet_struct busy_tlet;
+	// struct tasklet_struct to_tlet;
     // struct timer_list timeout_tlist;
 	struct delayed_work	timeout;
-	struct early_suspend amlsd_early_suspend;
+	// struct early_suspend amlsd_early_suspend;
 
+    struct class            debug;
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
-	unsigned int clkc_w;
-	unsigned int pdma;
-	unsigned int pdma_s;
-	unsigned int pdma_low;
+	// unsigned int clkc_w;
+	// unsigned int pdma;
+	// unsigned int pdma_s;
+	// unsigned int pdma_low;
 	unsigned int misc;
 	unsigned int ictl;
 	unsigned int ista;
@@ -158,12 +184,19 @@ struct amlsd_host {
 	spinlock_t	mrq_lock;
 	int			cmd_is_stop;
 	enum aml_mmc_waitfor	xfer_step;
+	enum aml_mmc_waitfor	xfer_step_prev;
 
 	int			bus_width;
 	int     port;
 	int     locked;
-	char		*status;
-	unsigned int		ccnt, dcnt;
+    bool    is_gated;
+	// unsigned int		ccnt, dcnt;
+
+	int     status; // host status: xx_error/ok
+	int init_flag;
+
+    char    *msg_buf;
+#define MESSAGE_BUF_SIZE            512
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debug_root;
@@ -177,12 +210,15 @@ struct amlsd_host {
 
     u32			opcode; // add by gch for debug
 	u32			arg; // add by gch for debug
+    u32         cmd25_cnt;
     
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
     u32         time_req_sta; // request start time
+    u32         reg_buf[16];
 #endif
+    u32         time_req_sta; // request start time
     
     struct pinctrl *pinctrl;
     char pinctrl_name[30];
@@ -549,6 +585,7 @@ struct sdhc_clk2{
 	u32 reserved:8; /*[31:24] reserved*/
 };
 
+#define SDHC_CLOCK_SRC_OSC              0 // 24MHz
 #define SDHC_CLOCK_SRC_FCLK_DIV4        1
 #define SDHC_CLOCK_SRC_FCLK_DIV3        2
 #define SDHC_CLOCK_SRC_FCLK_DIV5        3
diff --git a/arch/arm/mach-meson6tv/include/mach/sd.h b/arch/arm/mach-meson6tv/include/mach/sd.h
index 2902de409751..3fc8d8a21221 100644
--- a/arch/arm/mach-meson6tv/include/mach/sd.h
+++ b/arch/arm/mach-meson6tv/include/mach/sd.h
@@ -13,6 +13,11 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
+#define     AML_ERROR_RETRY_COUNTER         5
+#define     AML_TIMEOUT_RETRY_COUNTER       2
+
+#define AML_SDHC_MAGIC			 "amlsdhc"
+#define AML_SDIO_MAGIC			 "amlsdio"
 enum aml_mmc_waitfor {
 	XFER_INIT,
 	XFER_START,				/* 1 */
@@ -33,6 +38,18 @@ enum aml_mmc_waitfor {
 	XFER_AFTER_START,		/* 16 */
 };
 
+enum aml_host_status { /* Host controller status */
+	HOST_INVALID = 0,       /* 0, invalid value used for initialization */
+	HOST_RX_FIFO_FULL = 1,  /* 1, start with 1 */
+	HOST_TX_FIFO_EMPTY,	    /* 2 */
+	HOST_RSP_CRC_ERR,	    /* 3 */
+	HOST_DAT_CRC_ERR,	    /* 4 */
+	HOST_RSP_TIMEOUT_ERR,   /* 5 */
+	HOST_DAT_TIMEOUT_ERR,   /* 6 */
+    HOST_ERR_END,	        /* 7, end of errors */
+	HOST_TASKLET_CMD,	    /* 8 */
+	HOST_TASKLET_DATA,	    /* 9 */
+};
 struct amlsd_host;
 struct amlsd_platform {
 	struct amlsd_host* host;
@@ -56,9 +73,12 @@ struct amlsd_platform {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int clkc;
+	unsigned int clk2;
 	unsigned int clkc_w;
 	unsigned int ctrl;
 	unsigned int clock;
+	unsigned int tune_phase;            /* store tuning result */
+	unsigned char signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
 	unsigned int low_burst;
 	unsigned int irq_in;
 	unsigned int irq_in_edge;
@@ -74,6 +94,9 @@ struct amlsd_platform {
     unsigned int jtag_pin;
     int is_sduart;
     bool is_in;
+    bool is_tuned;                      /* if card has been tuning */
+    bool need_retuning;
+	struct delayed_work	retuning;
 
     /* we used this flag to filter some unnecessary cmd before initialized flow */
     bool is_fir_init; // has been initialized for the first time
@@ -131,21 +154,23 @@ struct amlsd_host {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int f_min;
-	struct tasklet_struct cmd_tlet;
-	struct tasklet_struct data_tlet;
-	struct tasklet_struct busy_tlet;
-	struct tasklet_struct to_tlet;
+	// struct tasklet_struct cmd_tlet;
+	// struct tasklet_struct data_tlet;
+	// struct tasklet_struct busy_tlet;
+	// struct tasklet_struct to_tlet;
     // struct timer_list timeout_tlist;
 	struct delayed_work	timeout;
-	struct early_suspend amlsd_early_suspend;
+	// struct early_suspend amlsd_early_suspend;
 
+    struct class            debug;
+    
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
-	unsigned int clkc_w;
-	unsigned int pdma;
-	unsigned int pdma_s;
-	unsigned int pdma_low;
+	// unsigned int clkc_w;
+	// unsigned int pdma;
+	// unsigned int pdma_s;
+	// unsigned int pdma_low;
 	unsigned int misc;
 	unsigned int ictl;
 	unsigned int ista;
@@ -158,12 +183,19 @@ struct amlsd_host {
 	spinlock_t	mrq_lock;
 	int			cmd_is_stop;
 	enum aml_mmc_waitfor	xfer_step;
+	enum aml_mmc_waitfor	xfer_step_prev;
 
 	int			bus_width;
 	int     port;
 	int     locked;
-	char		*status;
-	unsigned int		ccnt, dcnt;
+    bool    is_gated;
+	// unsigned int		ccnt, dcnt;
+
+	int     status; // host status: xx_error/ok
+	int init_flag;
+
+    char    *msg_buf;
+#define MESSAGE_BUF_SIZE            512
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debug_root;
@@ -177,14 +209,17 @@ struct amlsd_host {
 
     u32			opcode; // add by gch for debug
 	u32			arg; // add by gch for debug
-
+    u32         cmd25_cnt;
+    
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
-    u32         time_req_sta; // request start time
-#endif
 
-    struct pinctrl *pinctrl;
+    u32         reg_buf[16];
+#endif
+    u32         time_req_sta; // request start time
+    
+    struct pinctrl  *pinctrl;
     char pinctrl_name[30];
 
     int storage_flag; // used for judging if there is a tsd/emmc
@@ -549,6 +584,7 @@ struct sdhc_clk2{
 	u32 reserved:8; /*[31:24] reserved*/
 };
 
+#define SDHC_CLOCK_SRC_OSC              0 // 24MHz
 #define SDHC_CLOCK_SRC_FCLK_DIV4        1
 #define SDHC_CLOCK_SRC_FCLK_DIV3        2
 #define SDHC_CLOCK_SRC_FCLK_DIV5        3
@@ -613,6 +649,9 @@ extern struct mmc_host *sdio_host;
 		printk("[%s] " fmt, __FUNCTION__, ##args);	\
 }while(0)
 
+#define print_dbg(fmt, args...) do{\
+	printk("[%s]\033[0;40;35m " fmt "\033[0m", __FUNCTION__, ##args);  \
+}while(0)
 // P_AO_SECURE_REG1 is "Secure Register 1" in <M8-Secure-AHB-Registers.doc>
 #define aml_jtag_gpioao() do{\
     writel(0x102, (u32 *)P_AO_SECURE_REG1); \
diff --git a/arch/arm/mach-meson6tvd/include/mach/sd.h b/arch/arm/mach-meson6tvd/include/mach/sd.h
index 2902de409751..3f070c417ad7 100644
--- a/arch/arm/mach-meson6tvd/include/mach/sd.h
+++ b/arch/arm/mach-meson6tvd/include/mach/sd.h
@@ -13,6 +13,11 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
+#define     AML_ERROR_RETRY_COUNTER         5
+#define     AML_TIMEOUT_RETRY_COUNTER       2
+
+#define AML_SDHC_MAGIC			 "amlsdhc"
+#define AML_SDIO_MAGIC			 "amlsdio"
 enum aml_mmc_waitfor {
 	XFER_INIT,
 	XFER_START,				/* 1 */
@@ -33,6 +38,18 @@ enum aml_mmc_waitfor {
 	XFER_AFTER_START,		/* 16 */
 };
 
+enum aml_host_status { /* Host controller status */
+	HOST_INVALID = 0,       /* 0, invalid value used for initialization */
+	HOST_RX_FIFO_FULL = 1,  /* 1, start with 1 */
+	HOST_TX_FIFO_EMPTY,	    /* 2 */
+	HOST_RSP_CRC_ERR,	    /* 3 */
+	HOST_DAT_CRC_ERR,	    /* 4 */
+	HOST_RSP_TIMEOUT_ERR,   /* 5 */
+	HOST_DAT_TIMEOUT_ERR,   /* 6 */
+    HOST_ERR_END,	        /* 7, end of errors */
+	HOST_TASKLET_CMD,	    /* 8 */
+	HOST_TASKLET_DATA,	    /* 9 */
+};
 struct amlsd_host;
 struct amlsd_platform {
 	struct amlsd_host* host;
@@ -56,9 +73,13 @@ struct amlsd_platform {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int clkc;
+	unsigned int clk2;
 	unsigned int clkc_w;
 	unsigned int ctrl;
 	unsigned int clock;
+	unsigned int tune_phase;            /* store tuning result */
+	unsigned char signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
+
 	unsigned int low_burst;
 	unsigned int irq_in;
 	unsigned int irq_in_edge;
@@ -74,6 +95,9 @@ struct amlsd_platform {
     unsigned int jtag_pin;
     int is_sduart;
     bool is_in;
+    bool is_tuned;                      /* if card has been tuning */
+    bool need_retuning;
+	struct delayed_work	retuning;
 
     /* we used this flag to filter some unnecessary cmd before initialized flow */
     bool is_fir_init; // has been initialized for the first time
@@ -131,21 +155,22 @@ struct amlsd_host {
 	unsigned int f_max;
 	unsigned int f_max_w;
 	unsigned int f_min;
-	struct tasklet_struct cmd_tlet;
-	struct tasklet_struct data_tlet;
-	struct tasklet_struct busy_tlet;
-	struct tasklet_struct to_tlet;
+	// struct tasklet_struct cmd_tlet;
+	// struct tasklet_struct data_tlet;
+	// struct tasklet_struct busy_tlet;
+	// struct tasklet_struct to_tlet;
     // struct timer_list timeout_tlist;
 	struct delayed_work	timeout;
-	struct early_suspend amlsd_early_suspend;
+	// struct early_suspend amlsd_early_suspend;
 
+    struct class            debug;
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
-	unsigned int clkc_w;
-	unsigned int pdma;
-	unsigned int pdma_s;
-	unsigned int pdma_low;
+	// unsigned int clkc_w;
+	// unsigned int pdma;
+	// unsigned int pdma_s;
+	// unsigned int pdma_low;
 	unsigned int misc;
 	unsigned int ictl;
 	unsigned int ista;
@@ -158,12 +183,19 @@ struct amlsd_host {
 	spinlock_t	mrq_lock;
 	int			cmd_is_stop;
 	enum aml_mmc_waitfor	xfer_step;
+	enum aml_mmc_waitfor	xfer_step_prev;
 
 	int			bus_width;
 	int     port;
 	int     locked;
-	char		*status;
-	unsigned int		ccnt, dcnt;
+    bool    is_gated;
+	// unsigned int		ccnt, dcnt;
+
+	int     status; // host status: xx_error/ok
+	int init_flag;
+
+    char    *msg_buf;
+#define MESSAGE_BUF_SIZE            512
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debug_root;
@@ -177,13 +209,16 @@ struct amlsd_host {
 
     u32			opcode; // add by gch for debug
 	u32			arg; // add by gch for debug
+    u32         cmd25_cnt;
 
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
     u32         time_req_sta; // request start time
+    u32         reg_buf[16];
 #endif
-
+    u32         time_req_sta; // request start time
+    
     struct pinctrl *pinctrl;
     char pinctrl_name[30];
 
@@ -549,6 +584,7 @@ struct sdhc_clk2{
 	u32 reserved:8; /*[31:24] reserved*/
 };
 
+#define SDHC_CLOCK_SRC_OSC              0 // 24MHz
 #define SDHC_CLOCK_SRC_FCLK_DIV4        1
 #define SDHC_CLOCK_SRC_FCLK_DIV3        2
 #define SDHC_CLOCK_SRC_FCLK_DIV5        3
diff --git a/arch/arm/mach-meson8/include/mach/sd.h b/arch/arm/mach-meson8/include/mach/sd.h
index 481dbb5cbf63..9c9c97c53da9 100644
--- a/arch/arm/mach-meson8/include/mach/sd.h
+++ b/arch/arm/mach-meson8/include/mach/sd.h
@@ -13,6 +13,13 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
+#define     AML_ERROR_RETRY_COUNTER         10
+#define     AML_TIMEOUT_RETRY_COUNTER       2
+
+#define AML_SDHC_MAGIC			 "amlsdhc"
+#define AML_SDIO_MAGIC			 "amlsdio"
+
+
 enum aml_mmc_waitfor {
 	XFER_INIT,              /* 0 */
 	XFER_START,				/* 1 */
@@ -157,6 +164,8 @@ struct amlsd_host {
 	struct delayed_work	timeout;
 	// struct early_suspend amlsd_early_suspend;
 
+    struct class            debug;
+    
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
@@ -185,6 +194,7 @@ struct amlsd_host {
 	// unsigned int		ccnt, dcnt;
 
 	int     status; // host status: xx_error/ok
+	int init_flag;
 
     char    *msg_buf;
 #define MESSAGE_BUF_SIZE            512
@@ -206,10 +216,10 @@ struct amlsd_host {
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
-    u32         time_req_sta; // request start time
 
     u32         reg_buf[16];
 #endif
+    u32         time_req_sta; // request start time
     
     struct pinctrl  *pinctrl;
     char        pinctrl_name[30];
diff --git a/arch/arm/mach-meson8b/include/mach/sd.h b/arch/arm/mach-meson8b/include/mach/sd.h
index 7f4620ee1868..38fdd08ecfb3 100644
--- a/arch/arm/mach-meson8b/include/mach/sd.h
+++ b/arch/arm/mach-meson8b/include/mach/sd.h
@@ -13,6 +13,13 @@
 #include <linux/mmc/host.h>
 #include <linux/earlysuspend.h>
 
+#define     AML_ERROR_RETRY_COUNTER         10
+#define     AML_TIMEOUT_RETRY_COUNTER       2
+
+#define AML_SDHC_MAGIC			 "amlsdhc"
+#define AML_SDIO_MAGIC			 "amlsdio"
+
+
 enum aml_mmc_waitfor {
 	XFER_INIT,              /* 0 */
 	XFER_START,				/* 1 */
@@ -157,6 +164,8 @@ struct amlsd_host {
 	struct delayed_work	timeout;
 	// struct early_suspend amlsd_early_suspend;
 
+    struct class            debug;
+    
 	unsigned int send;
 	unsigned int ctrl;
 	unsigned int clkc;
@@ -185,6 +194,7 @@ struct amlsd_host {
 	// unsigned int		ccnt, dcnt;
 
 	int     status; // host status: xx_error/ok
+	int init_flag;
 
     char    *msg_buf;
 #define MESSAGE_BUF_SIZE            512
@@ -206,10 +216,10 @@ struct amlsd_host {
 #ifdef      CONFIG_MMC_AML_DEBUG
     u32         req_cnt;
     u32         trans_size;
-    u32         time_req_sta; // request start time
 
     u32         reg_buf[16];
 #endif
+    u32         time_req_sta; // request start time
     
     struct pinctrl  *pinctrl;
     char        pinctrl_name[30];
diff --git a/drivers/amlogic/mmc/aml_sdhc_m8.c b/drivers/amlogic/mmc/aml_sdhc_m8.c
index 792146140bc9..00ce5fd7e8b2 100755
--- a/drivers/amlogic/mmc/aml_sdhc_m8.c
+++ b/drivers/amlogic/mmc/aml_sdhc_m8.c
@@ -32,6 +32,7 @@
 #include <mach/mod_gate.h>
 #include "amlsd.h"
 
+//#define DMC_URGENT_PERIPH
 unsigned int rx_clk_phase_set=1;
 unsigned int sd_clk_phase_set=1;
 unsigned int rx_endian=7;
@@ -41,6 +42,11 @@ unsigned int cmd25_cnt=0;
 unsigned int fifo_empty_cnt=0;
 unsigned int fifo_full_cnt=0;
 unsigned int timeout_cnt=0;
+static unsigned int sdhc_error_flag = 0;
+static unsigned int sdhc_debug_flag = 0;
+static int sdhc_err_bak;
+
+void aml_sdhc_send_stop(struct amlsd_host* host);
 
 static void aml_sdhc_clk_switch (struct amlsd_platform* pdata, int clk_div, int clk_src_sel);
 static int aml_sdhc_status (struct amlsd_host* host);
@@ -75,6 +81,43 @@ static const u8 tuning_blk_pattern_8bit[] = {
 	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
 };
 
+static void sdhc_debug_status(struct amlsd_host* host)
+{
+    switch (sdhc_debug_flag)
+    {
+        case 1:
+            host->status = HOST_TX_FIFO_EMPTY;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;
+        case 2:
+            host->status = HOST_RX_FIFO_FULL;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;  
+        case 3:
+            host->status = HOST_RSP_CRC_ERR;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;  
+        case 4:
+            host->status = HOST_DAT_CRC_ERR;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;              
+        case 5:
+            host->status = HOST_DAT_TIMEOUT_ERR;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break;   
+        case 6:
+            host->status = HOST_RSP_TIMEOUT_ERR;
+            sdhc_err("Force host->status:%d here\n", host->status);
+            break; 
+                                    
+        default:            
+            break;
+    }
+    
+    //only enable once for debug
+    sdhc_debug_flag = 0;
+}
+
 struct aml_tuning_data {
 	const u8 *blk_pattern;
 	unsigned int blksz;
@@ -416,11 +459,25 @@ static void aml_sdhc_reg_init(struct amlsd_host* host)
     u32 venhc;
     struct sdhc_enhc *enhc = (struct sdhc_enhc *)&venhc;
     // u32 val;
-
+#ifdef DMC_URGENT_PERIPH    
+    u32 dmc_ctl;
+#endif
     switch_mod_gate_by_type(MOD_SDHC, 1);
     // print_dbg("HHI_GCLK_MPEG0=%#x\n", READ_CBUS_REG(HHI_GCLK_MPEG0));
 
     aml_sdhc_host_reset(host);
+    
+#if DMC_URGENT_PERIPH
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) 
+    dmc_ctl = readl(P_MMC_QOS11_CTRL0);
+    dmc_ctl |= (1<<26);
+    writel(dmc_ctl, P_MMC_QOS11_CTRL0);
+#elif(MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8B)    
+    dmc_ctl = readl(P_DMC_AM7_CHAN_CTRL);
+    dmc_ctl |= (1<<18);
+    writel(dmc_ctl, P_DMC_AM7_CHAN_CTRL);
+#endif
+#endif
 
     ctrl.rx_period = 0xf;//0x08; // 0xf;
     ctrl.rx_timeout = 0x7f;//0x40; // 0x7f;
@@ -436,18 +493,12 @@ static void aml_sdhc_reg_init(struct amlsd_host* host)
 
     pdma->dma_mode = 0;
     pdma->dma_urgent = 1;
-#if (defined CONFIG_ARCH_MESON8M2)
-    pdma->wr_burst = 7;
-#else
-    pdma->wr_burst = 3; // means 4
-#endif
+
+    pdma->wr_burst = 7;//3; // means 4
     pdma->txfifo_th = 49; // means 49
     pdma->rd_burst = 15; // means 8
-#if (defined CONFIG_ARCH_MESON8M2)
-    pdma->rxfifo_th = 7;
-#else
-    pdma->rxfifo_th = 8; // means 8
-#endif
+    pdma->rxfifo_th = 7; // means 8
+    //pdma->rxfifo_manual_flush = 1; // bit[29]=1, bit[30]=0
     // pdma->rd_burst = 3;
     // pdma->wr_burst = 3;
     // pdma->rxfifo_th = 7;
@@ -466,6 +517,7 @@ static void aml_sdhc_reg_init(struct amlsd_host* host)
     writel(*(u32*)&misc, host->base + SDHC_MISC);
 
     venhc = readl(host->base+SDHC_ENHC);
+    
 #if (defined CONFIG_ARCH_MESON8M2)
     enhc->rxfifo_th = 64;
     enhc->sdio_irq_period = 12;
@@ -474,7 +526,7 @@ static void aml_sdhc_reg_init(struct amlsd_host* host)
     enhc->chk_wrrsp = 0;
     enhc->wrrsp_mode = 1;
 #else
-    enhc->rxfifo_th = 60;
+    enhc->rxfifo_th = 63;
     enhc->dma_rd_resp = 0;
     enhc->dma_wr_resp = 1;
     enhc->sdio_irq_period = 12;
@@ -499,17 +551,18 @@ int aml_sdhc_wait_ready(struct amlsd_host* host, u32 timeout)
     for(i=0; i< timeout; i++){
         vstat = readl(host->base + SDHC_STAT);
         stat = (struct sdhc_stat*)&vstat;
+
         esta = readl(host->base + SDHC_ESTA);
-        if(!stat->cmd_busy && (!((esta << 11) & 7)))
+        if(!stat->cmd_busy && (!((esta >> 11) & 7)))
         //if(!stat->cmd_busy)
             return 0;
         udelay(1);
     }
 
     sdhc_err("SDHC_STAT=%#x, sdhc controller is busy.\n", vstat);
-    aml_sdhc_print_reg(host);
+    //aml_sdhc_print_reg(host);
     aml_sdhc_host_reset(host);
-    WARN_ON(1);
+    //WARN_ON(1);
     return -1;
 }
 
@@ -576,6 +629,8 @@ void aml_sdhc_set_pdma(struct amlsd_platform* pdata, struct mmc_request* mrq)
     struct amlsd_host* host = pdata->host;
     u32 vpdma = readl(host->base+SDHC_PDMA);
     struct sdhc_pdma* pdma = (struct sdhc_pdma*)&vpdma;
+    u32 venhc = readl(host->base+SDHC_ENHC);
+    //struct sdhc_enhc *enhc = (struct sdhc_enhc *)&venhc;
 
     BUG_ON(!mrq->data);
 #if 1
@@ -588,13 +643,24 @@ void aml_sdhc_set_pdma(struct amlsd_platform* pdata, struct mmc_request* mrq)
         writel(*(u32*)pdma, host->base+SDHC_PDMA);
         pdma->txfifo_fill = 1;
     }
-    // else{
-        // pdma->txfifo_fill = 0;
-        // pdma->rxfifo_manual_flush = 2; // ???? this can be deleted. try
-        // pdma->dma_urgent = 1;
-        // pdma->rd_burst = 7; // means 8
-        // pdma->rxfifo_th = 8; // means 8
-    // }
+	else{
+	    if(aml_card_type_sdio(pdata)){
+	        pdma->rxfifo_manual_flush = 0; 
+	        //enhc->dma_wr_resp = 1;
+	    }
+	    else{
+	        pdma->rxfifo_manual_flush = 1; 
+	        //enhc->dma_wr_resp = 0;
+	    }
+#if 0	    
+		if(mrq->data->blocks > 1){
+		    pdma->wr_burst = 7;
+		}else{
+		    pdma->wr_burst = 3;
+		}
+#endif		
+		//writel(venhc, host->base + SDHC_ENHC);
+	}
 
 #else
     if(mrq->data->flags & MMC_DATA_WRITE){
@@ -712,7 +778,6 @@ void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
         //send.r1b = 1;
         //sdhc_err("cmd %d set r1b\n", mrq->cmd->opcode);
     //}
-    
 
     if(mrq->data){
         if(((mrq->cmd->opcode == SD_IO_RW_DIRECT) || (mrq->cmd->opcode == SD_IO_RW_EXTENDED))
@@ -729,7 +794,9 @@ void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
             // sdhc_err("cmd%d: txfifo_cnt:%d, rxfifo_cnt:%d\n", 
                 // mrq->cmd->opcode, stat->txfifo_cnt, stat->rxfifo_cnt);
 
-            aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT); /*Wait command busy*/
+            if(aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT)){ /*Wait command busy*/
+            	sdhc_err("aml_sdhc_wait_ready error before start cmd fifo\n");
+            }
             vsrst = readl(host->base + SDHC_SRST);        
             srst->rxfifo = 1;
             srst->txfifo = 1;
@@ -751,6 +818,7 @@ void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
         if(mrq->data->flags & MMC_DATA_WRITE)
             send.data_dir = 1;
 
+
         /*Set package size*/
         if(mrq->data->blksz < 512)
             ctrl->pack_len = mrq->data->blksz;
@@ -766,7 +834,11 @@ void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
          * wait dma done interrupt(int[11]), don't need care about
          * dat0 busy or not.
          */
-        ictl.dma_done = 1;
+        if((mrq->data->flags & MMC_DATA_WRITE) 
+            || aml_card_type_sdio(pdata))
+            ictl.dma_done = 1; // for hardware automatical flush
+        else
+            ictl.data_xfer_ok = 1; // for software flush
     }else
         ictl.resp_ok = 1;
 
@@ -796,7 +868,9 @@ void aml_sdhc_start_cmd(struct amlsd_platform* pdata, struct mmc_request* mrq)
     writel(mrq->cmd->arg, host->base+SDHC_ARGU);
     writel(vctrl, host->base+SDHC_CTRL);
     writel(host->bn_dma_buf, host->base+SDHC_ADDR);
-    aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT); /*Wait command busy*/
+    if(aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT)){ /*Wait command busy*/
+		sdhc_err("aml_sdhc_wait_ready error before start cmd\n");
+	}
     if(mrq->data)
         aml_sdhc_set_pdma(pdata, mrq);/*Start dma transfer*/
 
@@ -878,7 +952,10 @@ void aml_sdhc_request_done(struct mmc_host *mmc, struct mmc_request *mrq)
     aml_sdhc_disable_imask(host, SDHC_ICTL_ALL);
     /*Set irq status: write 1 clear*/
     writel(SDHC_ISTA_W1C_ALL, host->base+SDHC_ISTA);
-    aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+    //aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+    if(aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT)){ /*Wait command busy*/
+		sdhc_err("aml_sdhc_wait_ready request done\n");
+    }
     mmc_request_done(host->mmc, mrq);
 }
 
@@ -1018,8 +1095,15 @@ static void aml_sdhc_timeout(struct work_struct *work)
     // u32 vista = readl(host->base + SDHC_ISTA);
     // struct sdhc_ista* ista = (struct sdhc_ista*)&vista;
     struct mmc_request* mrq;
+    struct amlsd_platform* pdata = mmc_priv(host->mmc);
+    
     unsigned long flags;
 
+	struct timeval ts_current;
+	unsigned long time_start_cnt = READ_CBUS_REG(ISA_TIMERE);
+	
+    time_start_cnt = (time_start_cnt - host->time_req_sta) / 1000;
+	
     BUG_ON(!host->mrq || !host->mrq->cmd);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
@@ -1031,33 +1115,51 @@ static void aml_sdhc_timeout(struct work_struct *work)
 
     if ((host->xfer_step == XFER_IRQ_TASKLET_DATA) 
             || (host->xfer_step == XFER_IRQ_TASKLET_CMD)) {
-        schedule_delayed_work(&host->timeout, 10);
+        schedule_delayed_work(&host->timeout, 50);
+        host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);
         
         timeout_cnt++;
-        if (timeout_cnt > 100)
+        if (timeout_cnt > 30)
             goto timeout_handle;
 
         spin_unlock_irqrestore(&host->mrq_lock, flags);
 
-        sdhc_err("%s: cmd%d, ISR have been run, xfer_step=%d\n",
-                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step);
+        sdhc_err("%s: cmd%d, ISR have been run, xfer_step=%d, time_start_cnt=%dmS, timeout_cnt=%d\n",
+                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step, time_start_cnt, timeout_cnt);
         return;
     }
 timeout_handle:
     timeout_cnt = 0;
 
     mrq = host->mrq;
-    spin_unlock_irqrestore(&host->mrq_lock, flags);
-
-    aml_sdhc_status(host);
-
-    spin_lock_irqsave(&host->mrq_lock, flags);
     host->xfer_step_prev = host->xfer_step;
     host->xfer_step = XFER_TIMER_TIMEOUT;
     mrq->cmd->error = -ETIMEDOUT;
-    spin_unlock_irqrestore(&host->mrq_lock, flags);
 
+    //do not retry for sdcard & sdio wifi
+    if(!aml_card_type_mmc(pdata)){
+        sdhc_error_flag = 0;
+        mrq->cmd->retries = 0;         
+    }
+    else if((sdhc_error_flag & (1<<3) == 0)  && (mrq->data != NULL) 
+            && pdata->is_in){  //set cmd retry cnt when first error.
+        sdhc_error_flag |= (1<<3);
+        mrq->cmd->retries = AML_TIMEOUT_RETRY_COUNTER; 
+    }   
+
+    if(sdhc_error_flag && (mrq->cmd->retries == 0)){
+        sdhc_error_flag |= (1<<30);
+        sdhc_err("Command retried failed\n");
+    }
+        
+    //spin_unlock_irqrestore(&host->mrq_lock, flags);
+
+    aml_sdhc_status(host);
+
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
     aml_sdhc_read_response(host->mmc, mrq->cmd);
+    sdhc_err("time_start_cnt:%d\n", time_start_cnt);
+
     aml_sdhc_print_err(host);
 
     /*read response, if error, set -EILSEQ, then retry in aml_sdhc_request_done*/
@@ -1110,8 +1212,26 @@ timeout_handle:
 // req_done:
     aml_sdhc_host_reset(host);
     /*write 1 clear irq status reg*/
-    // writel(vista, host->base+SDHC_ISTA);
-    aml_sdhc_request_done(host->mmc, mrq);
+    //writel(vista, host->base+SDHC_ISTA);
+ 
+    //do not send stop for sdio wifi case 
+    if(host->mrq->stop && aml_card_type_mmc(pdata) && !host->cmd_is_stop){
+    //if((host->mrq->cmd->opcode != SD_IO_RW_DIRECT) && (host->mrq->cmd->opcode != SD_IO_RW_EXTENDED) 
+   //         && (!mmc_card_removed(pdata->mmc->card)) && (!mrq->data)){
+        //spin_lock_irqsave(&host->mrq_lock, flags);
+        aml_sdhc_send_stop(host);                
+        //spin_unlock_irqrestore(&host->mrq_lock, flags);
+        schedule_delayed_work(&host->timeout, 1);
+    }
+    else{
+        spin_lock_irqsave(&host->mrq_lock, flags);        
+        if (host->cmd_is_stop)
+            host->cmd_is_stop = 0;
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+
+        aml_sdhc_request_done(host->mmc, mrq);
+    }          
+      
     return ;
 }
 
@@ -1145,9 +1265,11 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if (aml_check_unsupport_cmd(mmc, mrq))
         return;
 
-    if(!pdata->is_in){
+    //only for SDCARD
+    if(!pdata->is_in || (!host->init_flag && aml_card_type_sd(pdata))){
         spin_lock_irqsave(&host->mrq_lock, flags);
         mrq->cmd->error = -ENOMEDIUM;
+        mrq->cmd->retries = 0;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         mmc_request_done(mmc, mrq);
         return;
@@ -1180,9 +1302,16 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
         fifo_empty_cnt = 0;
         fifo_full_cnt = 0;
         timeout_cnt = 0;
+        host->init_flag = 1;
     }
+    
     if (mrq->cmd->opcode == 25)
         cmd25_cnt++;
+       
+    //clear error flag if last command retried failed here    
+    if(sdhc_error_flag & (1<<30)){
+        sdhc_error_flag = 0;
+    }
 
     /*setup reg  especially for cmd with transfering data*/
     if(mrq->data) {
@@ -1211,6 +1340,7 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
     else
         timeout = 500;//mod_timer(&host->timeout_tlist,
                 //jiffies + 500/*10*nsecs_to_jiffies(mrq->data->timeout_ns)*/); // 5s
+             
     schedule_delayed_work(&host->timeout, timeout);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
@@ -1223,13 +1353,14 @@ void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
     host->xfer_step = XFER_START;
     host->opcode = mrq->cmd->opcode;
     host->arg = mrq->cmd->arg;
+    host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);
 
     /*setup reg for all cmd*/
     aml_sdhc_start_cmd(pdata, mrq);
     host->xfer_step = XFER_AFTER_START;
     spin_unlock_irqrestore(&host->mrq_lock, flags);
 }
-
+    
 static int aml_sdhc_status (struct amlsd_host* host)
 {
     int ret = -1; // error
@@ -1244,7 +1375,7 @@ static int aml_sdhc_status (struct amlsd_host* host)
         return ret;
     }
 
-    spin_lock_irqsave(&host->mrq_lock, flags);
+    //spin_lock_irqsave(&host->mrq_lock, flags);
     if (victl & vista) {
         if(ista->rxfifo_full){
             host->status = HOST_RX_FIFO_FULL;
@@ -1275,6 +1406,11 @@ static int aml_sdhc_status (struct amlsd_host* host)
             ret = 0; // ok
             goto _status_exit;
         }
+        if(ista->data_xfer_ok){
+            host->status = HOST_TASKLET_DATA;
+            ret = 0; // ok
+            goto _status_exit;
+        }
         if(ista->resp_ok_noclear){
             host->status = HOST_TASKLET_CMD;
             ret = 0; // ok
@@ -1283,7 +1419,11 @@ static int aml_sdhc_status (struct amlsd_host* host)
     }
     ret = 0; // ok
 _status_exit:
-    spin_unlock_irqrestore(&host->mrq_lock, flags);
+    
+    //for debug
+    //sdhc_debug_status(host);
+
+    //spin_unlock_irqrestore(&host->mrq_lock, flags);
     return ret;
 }
 
@@ -1296,10 +1436,19 @@ static irqreturn_t aml_sdhc_irq(int irq, void *dev_id)
     struct mmc_request* mrq;
     unsigned long flags;
     bool exception_flag = false;
-    u32 victl = readl(host->base + SDHC_ICTL);
-    u32 vista = readl(host->base + SDHC_ISTA);
+    u32 victl ;//= readl(host->base + SDHC_ICTL);
+    u32 vista ;//= readl(host->base + SDHC_ISTA);
 
+    //if(sdhc_debug_flag == 9){
+    //    sdhc_err("FORCE ignore IRQ here\n");
+    //    sdhc_debug_flag = 0;
+    //    return IRQ_HANDLED;
+    //}
+        
     spin_lock_irqsave(&host->mrq_lock, flags);
+    victl = readl(host->base + SDHC_ICTL);
+    vista = readl(host->base + SDHC_ISTA);
+       
     mrq = host->mrq;
     mmc = host->mmc;
     pdata = mmc_priv(mmc);
@@ -1327,11 +1476,11 @@ static irqreturn_t aml_sdhc_irq(int irq, void *dev_id)
         host->xfer_step = XFER_IRQ_OCCUR;
 
     if (victl & vista) {
-        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        //spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdhc_status(host);
         if (exception_flag)
             sdhc_err("victl=%#x, vista=%#x, status=%#x\n", victl, vista, host->status);
-        spin_lock_irqsave(&host->mrq_lock, flags);
+        //spin_lock_irqsave(&host->mrq_lock, flags);
         switch(host->status)
         {
             case HOST_RX_FIFO_FULL:
@@ -1393,7 +1542,10 @@ static void aml_sdhc_com_err_handler (struct amlsd_host* host)
 
 static void aml_sdhc_not_timeout_err_handler (struct amlsd_host* host)
 {
-    aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+    //aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+    if(aml_sdhc_wait_ready(host, (STAT_POLL_TIMEOUT<<2))){ /*Wait command busy*/
+    	sdhc_err("aml_sdhc_wait_ready error not timeout error handler\n");
+    }    
     aml_sdhc_com_err_handler(host);
 }
 
@@ -1405,21 +1557,21 @@ struct mmc_request aml_sdhc_stop = {
     .cmd = &aml_sdhc_cmd,
 };
 
-int err_bak;
 void aml_sdhc_send_stop(struct amlsd_host* host)
 {
     struct amlsd_platform * pdata = mmc_priv(host->mmc);
     unsigned long flags;
 
     // sdhc_err("before cmd12\n");
-    
+   
     /*Already in mrq_lock*/
     spin_lock_irqsave(&host->mrq_lock, flags);
-    err_bak = host->mrq->cmd->error;
+    sdhc_err_bak = host->mrq->cmd->error;
     host->mrq->cmd->error = 0;
     host->cmd_is_stop = 1;
-    spin_unlock_irqrestore(&host->mrq_lock, flags);
     aml_sdhc_start_cmd(pdata, &aml_sdhc_stop);
+    spin_unlock_irqrestore(&host->mrq_lock, flags);
+    
 }
 
 static unsigned int clock[]={90000000,80000000,75000000,70000000,65000000,60000000,50000000};
@@ -1433,23 +1585,26 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
     unsigned long flags;
     u32 vstat, status;
     struct sdhc_stat* stat = (struct sdhc_stat*)&vstat;
-    struct amlsd_platform* pdata;
-    int cnt=0;
+    struct amlsd_platform* pdata = mmc_priv(host->mmc);
+    int cnt=0, i;
+    u32 esta = readl(host->base + SDHC_ESTA);
+    u32 dmc_sts = 0;
+    u32 vpdma = readl(host->base+SDHC_PDMA);   
+    struct sdhc_pdma* pdma = (struct sdhc_pdma*)&vpdma;
 
     spin_lock_irqsave(&host->mrq_lock, flags);
-    if ((host->xfer_step != XFER_IRQ_OCCUR) && (host->xfer_step != XFER_IRQ_TASKLET_BUSY)) {
-        sdhc_err("host->xfer_step=%d\n", host->xfer_step);
-    }
-
-    // if(host->xfer_step == XFER_TIMER_TIMEOUT){
-        // sdhc_err("Timeout Return\n");
-        // return IRQ_HANDLED;
-    // }
-
     mrq = host->mrq;
     xfer_step = host->xfer_step;
     status = host->status;
     
+    if ((xfer_step == XFER_FINISHED) || (xfer_step == XFER_TIMER_TIMEOUT)) {
+        sdhc_err("Warning: xfer_step=%d, host->status=%d\n", xfer_step, status);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        return IRQ_HANDLED;
+    }
+
+    WARN_ON((host->xfer_step != XFER_IRQ_OCCUR) && (host->xfer_step != XFER_IRQ_TASKLET_BUSY));
+
     if(!mrq){
         sdhc_err("!mrq xfer_step %d\n", xfer_step);
         if(xfer_step == XFER_FINISHED ||
@@ -1457,14 +1612,15 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
             spin_unlock_irqrestore(&host->mrq_lock, flags);
             return IRQ_HANDLED;
         }
-        BUG();
+        //BUG();
+        aml_sdhc_print_err(host);
     }
     if(host->cmd_is_stop){
         int delay = 1;
         if (mrq->cmd->error)
             sdhc_err("cmd12 error %d\n", mrq->cmd->error);
         host->cmd_is_stop = 0;
-        mrq->cmd->error = err_bak;
+        mrq->cmd->error = sdhc_err_bak;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         msleep(delay);
         sdhc_err("delay %dms\n", delay);
@@ -1477,15 +1633,41 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
 
     switch (status) {
         case HOST_TASKLET_DATA:
+            sdhc_error_flag = 0;
             BUG_ON(!mrq->data);
             cancel_delayed_work(&host->timeout);
 
             xfer_bytes = mrq->data->blksz*mrq->data->blocks;
             /* copy buffer from dma to data->sg in read cmd*/
             if(host->mrq->data->flags & MMC_DATA_READ){
+                
+                if(!aml_card_type_sdio(pdata)){
+                    for(i=0; i< STAT_POLL_TIMEOUT; i++){
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) 
+                        dmc_sts = readl(P_MMC_CHAN_STS);
+                        dmc_sts = (dmc_sts >> 11)&1;
+#elif(MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8B)    
+                        dmc_sts = readl(P_DMC_CHAN_STS);
+                        dmc_sts = (dmc_sts >> 15)&1;                        
+#endif                           
+                        esta = readl(host->base + SDHC_ESTA);
+                        esta = readl(host->base + SDHC_ESTA); // read twice, we just focus on the second result
+                        if ((((esta >> 11) & 7) == 0) && dmc_sts) // REGC_ESTA[13:11]=0? then OK
+                            break;
+                        else if (i == 10)
+                            sdhc_err("SDHC_ESTA=0x%x\n", esta);
+                    }
+                   
+                    if (i == STAT_POLL_TIMEOUT) // error
+                        sdhc_err("Warning: DMA state is wrong! SDHC_ESTA=0x%x\n", esta);
+    
+                    pdma->rxfifo_manual_flush |= 0x02; // bit[30]
+                    writel(vpdma, host->base+SDHC_PDMA);
+                }
+
                 aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len, host->bn_buf,
                             xfer_bytes, 0);
-                sdhc_dbg(AMLSD_DBG_RD_DATA, "R Cmd%d, arg %#x, size=%d\n",
+                sdhc_dbg(AMLSD_DBG_RD_DATA, "R Cmd%d, arg %x, size=%d\n",
                         mrq->cmd->opcode, mrq->cmd->arg, xfer_bytes);
                 sdhc_dbg(AMLSD_DBG_RD_DATA, "R Cmd %d, %x-%x-%x-%x-%x-%x-%x-%x\n",
                     host->mrq->cmd->opcode,
@@ -1509,19 +1691,27 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
             mrq->data->bytes_xfered = xfer_bytes;
             host->xfer_step = XFER_TASKLET_DATA;
             spin_unlock_irqrestore(&host->mrq_lock, flags);
-            aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+            //do not check device ready status here
+            //aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+            if(aml_sdhc_wait_ready(host, (STAT_POLL_TIMEOUT<<2))){ /*Wait command busy*/
+            	sdhc_err("aml_sdhc_wait_ready error after data thread\n");
+            }            
             aml_sdhc_read_response(host->mmc, mrq->cmd);
             // aml_sdhc_clear_fifo(host);
             aml_sdhc_request_done(host->mmc, mrq);
             break;
         case HOST_TASKLET_CMD:
+            sdhc_error_flag = 0;
             if(!host->mrq->data){
                 cancel_delayed_work(&host->timeout);
                 spin_lock_irqsave(&host->mrq_lock, flags);
                 host->mrq->cmd->error = 0;
                 host->xfer_step = XFER_TASKLET_CMD;
                 spin_unlock_irqrestore(&host->mrq_lock, flags);
-                aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+                //aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+	            if(aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT)){ /*Wait command busy*/
+	            	sdhc_err("aml_sdhc_wait_ready error cmd thread\n");
+	            }                
                 aml_sdhc_read_response(host->mmc, host->mrq->cmd);
                 aml_sdhc_request_done(host->mmc, mrq);
             } else {
@@ -1529,17 +1719,56 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
             }
             break;
         case HOST_TX_FIFO_EMPTY:
+        case HOST_RX_FIFO_FULL:   
+        case HOST_RSP_TIMEOUT_ERR:
+        case HOST_DAT_TIMEOUT_ERR:                                 
             cancel_delayed_work(&host->timeout);
-            aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+            //aml_sdhc_wait_ready(host, STAT_POLL_TIMEOUT);
+            if(aml_sdhc_wait_ready(host, (STAT_POLL_TIMEOUT<<2))){ /*Wait command busy*/
+            	sdhc_err("aml_sdhc_wait_ready error fifo or timeout thread\n");
+            }             
             aml_sdhc_read_response(host->mmc, host->mrq->cmd);
             aml_sdhc_print_err(host);
             aml_sdhc_host_reset(host);
             writel(SDHC_ISTA_W1C_ALL, host->base+SDHC_ISTA);
-            aml_sdhc_send_stop(host);
-            break;
-        case HOST_RX_FIFO_FULL:
-            aml_sdhc_not_timeout_err_handler(host);
+            spin_lock_irqsave(&host->mrq_lock, flags);
+            if((sdhc_error_flag == 0) && (host->mrq->cmd->opcode != MMC_SEND_TUNING_BLOCK) 
+                    && (host->mrq->cmd->opcode != MMC_SEND_TUNING_BLOCK_HS200) 
+                    && host->mrq->data){  //set cmd retry cnt when first error.
+                sdhc_error_flag |= (1<<0);
+                if((status == HOST_RSP_TIMEOUT_ERR) || (status == HOST_DAT_TIMEOUT_ERR)){
+                    if(aml_card_type_mmc(pdata)){
+                        mrq->cmd->retries = AML_TIMEOUT_RETRY_COUNTER; 
+                    }
+                    else{
+                        sdhc_error_flag = 0;
+                        mrq->cmd->retries = 0;
+                    }
+                }
+                else{
+                    mrq->cmd->retries = AML_ERROR_RETRY_COUNTER;                     
+                }
+            } 
+            
+            if(sdhc_error_flag && (mrq->cmd->retries == 0)){
+                sdhc_error_flag |= (1<<30);
+                sdhc_err("Command retried failed line:%d, status:%d\n", __LINE__, status);
+            }    
+            spin_unlock_irqrestore(&host->mrq_lock, flags);
+                          
+            //do not send stop for sdio wifi case 
+            if(host->mrq->stop && aml_card_type_mmc(pdata) && pdata->is_in){
+            //if((host->mrq->cmd->opcode != SD_IO_RW_DIRECT) && (host->mrq->cmd->opcode != SD_IO_RW_EXTENDED) 
+           //         && (!mmc_card_removed(pdata->mmc->card)) && (!mrq->data)){
+                aml_sdhc_send_stop(host);                
+            }
+            else{
+                aml_sdhc_request_done(host->mmc, mrq);
+            }
             break;
+        //case HOST_RX_FIFO_FULL:
+        //    aml_sdhc_not_timeout_err_handler(host);
+        //    break;
         case HOST_RSP_CRC_ERR:
         case HOST_DAT_CRC_ERR:
             pdata = mmc_priv(host->mmc);
@@ -1553,25 +1782,37 @@ irqreturn_t aml_sdhc_data_thread(int irq, void *data)
                     if(cnt >= (ARRAY_SIZE(clock) - 1))
                         break;
                 }
+                spin_lock_irqsave(&host->mrq_lock, flags);
+
                 host->mmc->ios.clock = clock[cnt]; 
                 aml_sdhc_set_clk_rate(host->mmc,host->mmc->ios.clock);
 
-                spin_lock_irqsave(&host->mrq_lock, flags);
                 pdata->need_retuning = true; // retuing will be done in the next request
                 mrq->cmd->retries = (ARRAY_SIZE(clock) - 1) - cnt;
-                spin_unlock_irqrestore(&host->mrq_lock, flags);
             }
+            else if(aml_card_type_mmc(pdata) && (host->mrq->cmd->opcode != MMC_SEND_TUNING_BLOCK) && (host->mrq->cmd->opcode != MMC_SEND_TUNING_BLOCK_HS200)){
+                spin_lock_irqsave(&host->mrq_lock, flags);
+
+                if(sdhc_error_flag == 0){  //set cmd retry cnt when first error.
+                    sdhc_error_flag |= (1<<1);
+                    mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
+                }                 
+                spin_unlock_irqrestore(&host->mrq_lock, flags);                                          
+            } 
+            if(sdhc_error_flag && (mrq->cmd->retries == 0)){
+                sdhc_error_flag |= (1<<30);
+                //sdhc_err("Command retried failed\n");
+            }       
+    
             aml_sdhc_not_timeout_err_handler(host);
             break;
-        case HOST_RSP_TIMEOUT_ERR:
-        case HOST_DAT_TIMEOUT_ERR:
-            aml_sdhc_com_err_handler(host);
-            break;
+
         default:
             sdhc_err("BUG xfer_step=%d, host->status=%d\n", xfer_step, status);
-            BUG();
+            aml_sdhc_print_err(host);
+            //BUG();
     }
-
+    
     return IRQ_HANDLED;
 }
 
@@ -1938,6 +2179,40 @@ static const struct mmc_host_ops aml_sdhc_ops = {
 /*for multi host claim host*/
 static struct mmc_claim aml_sdhc_claim;
 
+static ssize_t sdhc_debug_func(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
+    
+    sscanf(buf, "%x", &sdhc_debug_flag);    
+    printk("sdhc_debug_flag: %d\n", sdhc_debug_flag);
+
+    return count;
+}
+            
+static ssize_t show_sdhc_debug(struct class *class,
+                    struct class_attribute *attr,	char *buf)
+{
+    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
+    
+    printk("sdhc_debug_flag: %d\n", sdhc_debug_flag);
+    
+    printk("1 : Force sdhc HOST_TX_FIFO_EMPTY error \n");
+    printk("2 : Force sdhc HOST_RX_FIFO_FULL error \n");
+    printk("3 : Force sdhc HOST_RSP_CRC_ERR error \n");
+    printk("4 : Force sdhc HOST_DAT_CRC_ERR error \n");
+    printk("5 : Force sdhc HOST_DAT_TIMEOUT_ERR error \n");
+    printk("6 : Force sdhc HOST_RSP_TIMEOUT_ERR error \n");
+
+    printk("9 : Force sdhc irq timeout error \n");
+    
+    return 0;
+}
+
+static struct class_attribute sdhc_class_attrs[] = {
+    __ATTR(debug,  S_IRUGO | S_IWUSR , show_sdhc_debug, sdhc_debug_func),
+    __ATTR_NULL
+};
+
 static struct amlsd_host* aml_sdhc_init_host(void)
 {
     struct amlsd_host *host;
@@ -1969,6 +2244,8 @@ static struct amlsd_host* aml_sdhc_init_host(void)
 
     INIT_LIST_HEAD(&host->sibling);
     
+    host->init_flag = 1;
+    
     host->version = AML_MMC_VERSION;
     host->storage_flag = storage_flag;
     host->pinctrl = NULL;
@@ -1988,6 +2265,12 @@ static struct amlsd_host* aml_sdhc_init_host(void)
     sdhc_err("CONFIG_AML_MMC_DEBUG_FORCE_SINGLE_BLOCK_RW is on!\n");
 #endif
 
+	host->debug.name = kzalloc(strlen((const char*)AML_SDHC_MAGIC)+1, GFP_KERNEL);
+	strcpy(host->debug.name, (char*)AML_SDHC_MAGIC);
+	host->debug.class_attrs = sdhc_class_attrs;
+	if(class_register(&host->debug))
+		printk(" class register nand_class fail!\n");
+		
     return host;
 }
 
@@ -2070,11 +2353,15 @@ static int aml_sdhc_probe(struct platform_device *pdev)
         mmc->f_max = pdata->f_max;
         mmc->max_current_180 = 300; // 300 mA in 1.8V
         mmc->max_current_330 = 300; // 300 mA in 3.3V
-        
+
         if (aml_card_type_sdio(pdata)) { // if sdio_wifi
-            mmc->rescan_entered = 1; // do NOT run mmc_rescan for the first time
+            mmc->host_rescan_disable = true;
+			mmc->rescan_entered = 1; // do NOT run mmc_rescan for the first time
+        } else {
+            mmc->host_rescan_disable = false;
+			mmc->rescan_entered = 0; 
         }
-        
+
         if(pdata->port_init)
             pdata->port_init(pdata);
 
diff --git a/drivers/amlogic/mmc/aml_sdio.c b/drivers/amlogic/mmc/aml_sdio.c
index b33845a710a1..40353b2c7eaf 100755
--- a/drivers/amlogic/mmc/aml_sdio.c
+++ b/drivers/amlogic/mmc/aml_sdio.c
@@ -43,6 +43,34 @@ int SDIO_IRQ_SUPPORT = 0;
 static int aml_sdio_timeout_cmd(struct amlsd_host *host);
 void aml_sdio_send_stop(struct amlsd_host* host);
 
+static unsigned int sdio_error_flag = 0;
+static unsigned int sdio_debug_flag = 0;
+static unsigned int sdio_err_bak;
+
+void sdio_debug_irqstatus(struct sdio_status_irq* irqs, struct cmd_send* send)
+{    
+    switch (sdio_debug_flag)
+    {
+        case 1:
+            irqs->sdio_response_crc7_ok = 0;
+            send->response_do_not_have_crc7 = 0;
+            
+            sdhc_err("Force sdio cmd response crc error here\n");
+            break;
+        case 2:
+            irqs->sdio_data_read_crc16_ok = 0;
+            irqs->sdio_data_write_crc16_ok = 0;
+            sdhc_err("Force sdio data crc here\n");
+            break;  
+                                    
+        default:            
+            break;
+    }
+    
+    //only enable once for debug
+    sdio_debug_flag = 0;
+}
+
 static void aml_sdio_soft_reset(struct amlsd_host* host)
 {
     struct sdio_irq_config irqc={0};
@@ -413,11 +441,16 @@ static void aml_sdio_timeout(struct work_struct *work)
     u32 virqc;
     struct sdio_irq_config* irqc;
     unsigned long flags;
-#ifdef      CONFIG_MMC_AML_DEBUG
+//#ifdef      CONFIG_MMC_AML_DEBUG
     struct amlsd_platform * pdata = mmc_priv(host->mmc);
-#endif
+//#endif
 	static int timeout_cmd_cnt = 0;
 
+	struct timeval ts_current;
+	unsigned long time_start_cnt = READ_CBUS_REG(ISA_TIMERE);
+	
+    
+    time_start_cnt = (time_start_cnt - host->time_req_sta) / 1000;
 
 //	if(host->mmc->caps & MMC_CAP_SDIO_IRQ){
 	if(SDIO_IRQ_SUPPORT)
@@ -447,13 +480,15 @@ static void aml_sdio_timeout(struct work_struct *work)
             || (host->xfer_step == XFER_IRQ_OCCUR)){    // isr have been run
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         //mod_timer(&host->timeout_tlist, jiffies + 10);
-        schedule_delayed_work(&host->timeout, 10);
+        schedule_delayed_work(&host->timeout, 50);
+        host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);    
         
         if(irqs->sdio_cmd_int) {
             timeout_cnt++;
-            if (timeout_cnt > 10)
+            if (timeout_cnt > 30)
                 goto timeout_handle;
-            sdio_err("%s: irq have been occured\n", mmc_hostname(host->mmc));
+            sdio_err("%s: cmd%d, ISR have been run, xfer_step=%d, time_start_cnt=%dmS, timeout_cnt=%d\n",
+                mmc_hostname(host->mmc), host->mrq->cmd->opcode, host->xfer_step, time_start_cnt, timeout_cnt);        
         }
         else
             sdio_err("%s: isr have been run\n",  mmc_hostname(host->mmc));
@@ -476,10 +511,27 @@ timeout_handle:
     writel(virqc, host->base + SDIO_IRQC);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
+    
+    //do not retry for sdcard
+    if(!aml_card_type_mmc(pdata)){
+        sdio_error_flag |= (1<<30);
+        host->mrq->cmd->retries = 0;
+    }else if((sdio_error_flag & (1<<3) == 0) && (host->mrq->data != NULL) 
+            && pdata->is_in ){  //set cmd retry cnt when first error.
+        sdio_error_flag |= (1<<3);
+        host->mrq->cmd->retries = AML_TIMEOUT_RETRY_COUNTER; 
+    }   
+    
+    //here clear error flags after error retried
+    if(sdio_error_flag && (host->mrq->cmd->retries == 0)){
+        sdio_error_flag |= (1<<30);
+    } 
+    
     host->xfer_step = XFER_TIMEDOUT;
     host->mrq->cmd->error = -ETIMEDOUT;
     spin_unlock_irqrestore(&host->mrq_lock, flags);
     
+    sdio_err("time_start_cnt:%d\n", time_start_cnt);
     aml_sdio_print_err(host, "Timeout error");
     // if (pdata->port == MESON_SDIO_PORT_A) {
         // sdio_err("power_on_pin=%d\n",
@@ -497,10 +549,25 @@ timeout_handle:
     aml_dbg_verify_pull_up(pdata);
     aml_sdio_print_reg(host);
     // aml_dbg_print_pinmux();
-#endif
+#endif 
+
+    if(host->mrq->stop && aml_card_type_mmc(pdata) && !host->cmd_is_stop){
+        // sdio_err("Send stop cmd before timeout retry..\n");
+        spin_lock_irqsave(&host->mrq_lock, flags);
+        aml_sdio_send_stop(host);                
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        schedule_delayed_work(&host->timeout, 1);
+    }
+    else{
+            /*request done*/
+        // sdio_err("Just stop without retry..\n");
 
-    /*request done*/
-    aml_sdio_request_done(host->mmc, host->mrq);
+        if (host->cmd_is_stop)
+            host->cmd_is_stop = 0;
+
+        aml_sdio_request_done(host->mmc, host->mrq);
+    }
+            
 
     // spin_lock_irqsave(&host->mrq_lock, flags);
     // WARN_ON(!host->mrq->cmd);
@@ -528,9 +595,9 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
     unsigned long flags;
     struct mmc_request* mrq;
     enum aml_mmc_waitfor    xfer_step;
+    struct amlsd_platform * pdata = mmc_priv(host->mmc);
 
     spin_lock_irqsave(&host->mrq_lock, flags);
-
 	
     if((virqs >> sdio_cmd_busy_bit) & 0x1) 
     {      
@@ -543,12 +610,15 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
     mrq = host->mrq;
     xfer_step = host->xfer_step;
 	
+	// sdio_debug_irqstatus(irqs, send);
+	
     if(!mrq->data){
         if(irqs->sdio_response_crc7_ok || send->response_do_not_have_crc7)
             mrq->cmd->error = 0;
         else {
             mrq->cmd->error = -EILSEQ;
             aml_sdio_print_err(host, "cmd crc7 error");
+            
         }
        spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdio_request_done(host->mmc, mrq);
@@ -557,7 +627,12 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
             mrq->cmd->error = 0;
         else {
             mrq->cmd->error = -EILSEQ;
-            aml_sdio_print_err(host, "data crc16 error");
+            if((sdio_error_flag == 0) && aml_card_type_mmc(pdata)){  //set cmd retry cnt when first error.
+                sdio_error_flag |= (1<<0);
+                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
+            }  
+            
+            aml_sdio_print_err(host, "data crc16 error");            
         }
         mrq->data->bytes_xfered = mrq->data->blksz*mrq->data->blocks;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
@@ -570,6 +645,12 @@ static int aml_sdio_timeout_cmd(struct amlsd_host *host)
                 host->bn_buf[2], host->bn_buf[3]);
         }
         spin_lock_irqsave(&host->mrq_lock, flags);
+
+        if((mrq->cmd->error == 0) 
+            || (sdio_error_flag && (mrq->cmd->retries == 0))){
+            sdio_error_flag |= (1<<30);
+        }
+                
         if(mrq->stop){
             aml_sdio_send_stop(host);
             spin_unlock_irqrestore(&host->mrq_lock, flags);
@@ -607,9 +688,18 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if (aml_check_unsupport_cmd(mmc, mrq))
         return;
 
-    if(!pdata->is_in){
+    //only for SDCARD hotplag
+    if(!pdata->is_in || (!host->init_flag && aml_card_type_sd(pdata))){
+        spin_lock_irqsave(&host->mrq_lock, flags);
         mrq->cmd->error = -ENOMEDIUM;
+        mrq->cmd->retries = 0;
+        host->mrq = NULL;
+        host->xfer_step = XFER_FINISHED;        
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        
+        //aml_sdio_request_done(mmc, mrq);
         mmc_request_done(mmc, mrq);
+
         return;
     }
 
@@ -620,10 +710,14 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     host->req_cnt++;
 #endif
 
+    if (mrq->cmd->opcode == 0) {
+        host->init_flag = 1;
+    }
+
     sdio_dbg(AMLSD_DBG_REQ ,"%s: starting CMD%u arg %08x flags %08x\n",
         mmc_hostname(mmc), mrq->cmd->opcode,
         mrq->cmd->arg, mrq->cmd->flags);
-
+    
     if(mrq->data) {
         /*Copy data to dma buffer for write request*/
         aml_sdio_prepare_dma(host, mrq);
@@ -654,6 +748,7 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
         timeout = 500;//mod_timer(&host->timeout_tlist,
                 //jiffies + 500/*10*nsecs_to_jiffies(mrq->data->timeout_ns)*/); // 5s
 //	if(mmc->caps & MMC_CAP_SDIO_IRQ){
+
 	if(SDIO_IRQ_SUPPORT){
 		schedule_delayed_work(&host->timeout, timeout/20); 
 	}else{
@@ -666,11 +761,17 @@ void aml_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
     if(host->xfer_step != XFER_FINISHED && host->xfer_step != XFER_INIT)
         sdio_err("host->xfer_step %d\n", host->xfer_step);
 
+    //clear error flag if last command retried failed here    
+    if(sdio_error_flag & (1<<30)){
+        sdio_error_flag = 0;
+    }
+    
     host->mrq = mrq;
     host->mmc = mmc;
     host->xfer_step = XFER_START;
     host->opcode = mrq->cmd->opcode;
     host->arg = mrq->cmd->arg;
+    host->time_req_sta = READ_CBUS_REG(ISA_TIMERE);    
 
     // if(mrq->data){
         // sdio_dbg(AMLSD_DBG_REQ ,"%s: blksz %d blocks %d flags %08x "
@@ -699,6 +800,8 @@ void aml_sdio_send_stop(struct amlsd_host* host)
 {
     /*Already in mrq_lock*/
     host->cmd_is_stop = 1;
+    sdio_err_bak = host->mrq->cmd->error;
+    host->mrq->cmd->error = 0;
     aml_sdio_start_cmd(host->mmc, &aml_sdio_stop);
 }
 
@@ -714,6 +817,12 @@ static irqreturn_t aml_sdio_irq(int irq, void *dev_id)
     struct mmc_request* mrq;
     unsigned long flags;
 
+    //if(sdio_debug_flag == 9){
+    //    sdio_err("FORCE ignore IRQ here\n");
+    //    sdio_debug_flag = 0;
+    //    return IRQ_HANDLED;
+    //}
+    
     spin_lock_irqsave(&host->mrq_lock, flags);
     mrq = host->mrq;
    // if(!mrq){
@@ -770,6 +879,7 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
     unsigned long flags;
     struct mmc_request* mrq;
     enum aml_mmc_waitfor    xfer_step;
+    struct amlsd_platform * pdata = mmc_priv(host->mmc);
     // u32 time = READ_CBUS_REG(ISA_TIMERE);
 
     // time = time - host->time_req_sta;
@@ -780,6 +890,13 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
     spin_lock_irqsave(&host->mrq_lock, flags);
     mrq = host->mrq;
     xfer_step = host->xfer_step;
+
+    if ((xfer_step == XFER_FINISHED) || (xfer_step == XFER_TIMER_TIMEOUT)) {
+        sdhc_err("Warning: xfer_step=%d\n", xfer_step);
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
+        return IRQ_HANDLED;
+    }
+
     if(!mrq){
         sdio_err("CMD%u, arg %08x, mrq NULL xfer_step %d\n", host->opcode, host->arg, xfer_step);
         if(xfer_step == XFER_FINISHED ||
@@ -794,6 +911,7 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
     }
     if(host->cmd_is_stop){
         host->cmd_is_stop = 0;
+        mrq->cmd->error = sdio_err_bak;
         spin_unlock_irqrestore(&host->mrq_lock, flags);
         aml_sdio_request_done(host->mmc, mrq);
         return IRQ_HANDLED;
@@ -816,10 +934,21 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             spin_unlock_irqrestore(&host->mrq_lock, flags);
         } else {
             mrq->cmd->error = -EILSEQ;
+            if((sdio_error_flag == 0) && aml_card_type_mmc(pdata)){  //set cmd retry cnt when first error.
+                sdio_error_flag |= (1<<0);
+                mrq->cmd->retries = AML_ERROR_RETRY_COUNTER; 
+            }
             spin_unlock_irqrestore(&host->mrq_lock, flags);
             aml_sdio_print_err(host, "data crc16 error");
         }
+		spin_lock_irqsave(&host->mrq_lock, flags);
         mrq->data->bytes_xfered = mrq->data->blksz*mrq->data->blocks;
+       
+        if((mrq->cmd->error == 0) || (sdio_error_flag && (mrq->cmd->retries == 0))){
+            sdio_error_flag |= (1<<30);
+        } 
+               
+        spin_unlock_irqrestore(&host->mrq_lock, flags);
         if(mrq->data->flags & MMC_DATA_READ){
             aml_sg_copy_buffer(mrq->data->sg, mrq->data->sg_len,
                 host->bn_buf, mrq->data->blksz*mrq->data->blocks, 0);
@@ -838,6 +967,7 @@ irqreturn_t aml_sdio_irq_thread(int irq, void *data)
             aml_sdio_request_done(host->mmc, mrq);
         }
     }
+    
     return IRQ_HANDLED;
 }
 
@@ -1066,6 +1196,34 @@ static const struct mmc_host_ops aml_sdio_ops = {
     .get_ro = aml_sdio_get_ro,
 };
 
+static ssize_t sdio_debug_func(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
+    
+    sscanf(buf, "%x", &sdio_debug_flag);    
+    printk("sdio_debug_flag: %d\n", sdio_debug_flag);
+
+    return count;
+}
+
+static ssize_t show_sdio_debug(struct class *class,
+                    struct class_attribute *attr,	char *buf)
+{
+    struct amlsd_host *host = container_of(class, struct amlsd_host, debug);
+    
+    printk("sdio_debug_flag: %d\n", sdio_debug_flag);
+    printk("1 : Force sdio cmd crc error \n");
+    printk("2 : Force sdio data crc error \n");
+    printk("9 : Force sdio irq timeout error \n");
+
+    return 0;
+}
+
+static struct class_attribute sdio_class_attrs[] = {
+    __ATTR(debug,  S_IRUGO | S_IWUSR , show_sdio_debug, sdio_debug_func),
+    __ATTR_NULL
+};
+
 static struct amlsd_host* aml_sdio_init_host(void)
 {
     struct amlsd_host *host;
@@ -1098,11 +1256,20 @@ static struct amlsd_host* aml_sdio_init_host(void)
     host->version = AML_MMC_VERSION;
     host->storage_flag = storage_flag;
     host->pinctrl = NULL;
+    
+    host->init_flag = 1;
 
 #ifdef      CONFIG_MMC_AML_DEBUG
     host->req_cnt = 0;
     sdio_err("CONFIG_MMC_AML_DEBUG is on!\n");
 #endif
+
+	host->debug.name = kzalloc(strlen((const char*)AML_SDIO_MAGIC)+1, GFP_KERNEL);
+	strcpy(host->debug.name, (char*)AML_SDIO_MAGIC);
+	host->debug.class_attrs = sdio_class_attrs;
+	if(class_register(&host->debug))
+		printk(" class register nand_class fail!\n");
+		
     return host;
 }
 
@@ -1194,9 +1361,13 @@ static int aml_sdio_probe(struct platform_device *pdev)
         mmc->f_max = pdata->f_max;
 
         if (aml_card_type_sdio(pdata)) { // if sdio_wifi
-            mmc->rescan_entered = 1; // do NOT run mmc_rescan for the first time
+            mmc->host_rescan_disable = true;
+			mmc->rescan_entered = 1; // do NOT run mmc_rescan for the first time
+        } else {
+            mmc->host_rescan_disable = false;
+			mmc->rescan_entered = 0; 
         }
-         
+
         if(pdata->port_init)
             pdata->port_init(pdata);
 
diff --git a/drivers/amlogic/mmc/amlsd.c b/drivers/amlogic/mmc/amlsd.c
index 41a39b1aef50..9b47cc3b03d8 100644
--- a/drivers/amlogic/mmc/amlsd.c
+++ b/drivers/amlogic/mmc/amlsd.c
@@ -1153,10 +1153,15 @@ irqreturn_t aml_irq_cd_thread(int irq, void *data)
 {
 	struct amlsd_platform *pdata = (struct amlsd_platform*)data;
 
-    mdelay(500);
+    mdelay(20);
     aml_sd_uart_detect(pdata);
-
-    mmc_detect_change(pdata->mmc, msecs_to_jiffies(500));
+    
+    if((pdata->is_in == 0) && aml_card_type_sd(pdata)) {
+        pdata->host->init_flag = 0;
+    }
+        
+    //mdelay(500);
+    mmc_detect_change(pdata->mmc, msecs_to_jiffies(200));
 
 	return IRQ_HANDLED;
 }
diff --git a/drivers/amlogic/mmc/amlsd.h b/drivers/amlogic/mmc/amlsd.h
index 5ade61770ea6..83d315731eeb 100755
--- a/drivers/amlogic/mmc/amlsd.h
+++ b/drivers/amlogic/mmc/amlsd.h
@@ -5,9 +5,9 @@
 
 
 #define AML_MMC_MAJOR_VERSION   1
-#define AML_MMC_MINOR_VERSION   05
+#define AML_MMC_MINOR_VERSION   06
 #define AML_MMC_VERSION         ((AML_MMC_MAJOR_VERSION << 8) | AML_MMC_MINOR_VERSION)
-#define AML_MMC_VER_MESSAGE     "2014-05-14: sdhc regular tuning support"
+#define AML_MMC_VER_MESSAGE     "2014-06-24: sdhc rx fifo setting improve"
 
 extern unsigned sdhc_debug;
 extern unsigned sdio_debug;
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 951a20b5f28f..7ddd9e1833cb 100755
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -1400,7 +1400,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 		brq->data.flags |= MMC_DATA_READ;
 	} else {
 		brq->cmd.opcode = writecmd;
-		brq->cmd.retries = 5; // for eMMC debug
+		//brq->cmd.retries = 5; // for eMMC debug
 		brq->data.flags |= MMC_DATA_WRITE;
 	}
 
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ea916f9abd4c..fde96dc1e835 100755
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2398,6 +2398,9 @@ void mmc_rescan(struct work_struct *work)
 	int i;
 	bool extend_wakelock = false;
 
+	if (host->host_rescan_disable)
+		return;
+
 	if (host->rescan_disable)
 		return;
 
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 847abe6fc154..963b0e729b62 100755
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1315,6 +1315,7 @@ static void sdio_rescan (struct mmc_host *host)
     int ret;
 
     host->rescan_entered = 0;
+	host->host_rescan_disable = false;
     mmc_detect_change(host, 0); // start the delayed_work
     ret = flush_work(&(host->detect.work)); // wait for the delayed_work to finish
     if (!ret) {
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f49198343184..e6de3709b802 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -334,6 +334,7 @@ struct mmc_host {
 
 	int			rescan_disable;	/* disable card detection */
 	int			rescan_entered;	/* used with nonremovable devices */
+	bool		host_rescan_disable;	/* disable card detection */
 
 	struct mmc_card		*card;		/* device attached to this host */
 
-- 
2.19.0

