From 559a66940875ff8f69244db771df1e125491f235 Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Wed, 16 Jul 2014 14:16:23 +0800
Subject: [PATCH 4536/5965] PD#93896: lcd driver: Optimize lcd driver for
 common and specific by cpu_type

---
 arch/arm/boot/dts/amlogic/meson6_g24.dtd      |    4 +-
 arch/arm/boot/dts/amlogic/meson6_g33_1212.dtd |    6 +-
 arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd   |    6 +-
 arch/arm/boot/dts/amlogic/meson6_g33_512M.dtd |    6 +-
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |   11 +-
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |    9 +-
 arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd  |   11 +-
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |   13 +-
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |    9 +-
 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd  |    9 +-
 arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd  |    9 +-
 arch/arm/mach-meson6/Makefile                 |    2 +
 arch/arm/mach-meson6/include/mach/lcd_reg.h   |   26 +
 arch/arm/mach-meson6/include/mach/lcdoutc.h   |   24 +
 arch/arm/mach-meson6/lcd/Makefile             |    1 +
 arch/arm/mach-meson6/lcd/lcd_config.c         | 1868 +++++++
 arch/arm/mach-meson6/lcd/lcd_config.h         |  189 +
 arch/arm/mach-meson8/Makefile                 |    2 +
 .../arm/mach-meson8/include/mach}/lcd_reg.h   |    7 +-
 arch/arm/mach-meson8/include/mach/lcdoutc.h   |   25 +
 arch/arm/mach-meson8/lcd/Makefile             |    1 +
 .../arm/mach-meson8/lcd}/edp_drv.c            |  317 +-
 .../arm/mach-meson8/lcd}/edp_drv.h            |   64 +-
 arch/arm/mach-meson8/lcd/lcd_config.c         | 1848 +++++++
 arch/arm/mach-meson8/lcd/lcd_config.h         |  199 +
 .../arm/mach-meson8/lcd}/mipi_dsi_util.c      |  333 +-
 .../arm/mach-meson8/lcd}/mipi_dsi_util.h      |   12 -
 arch/arm/mach-meson8b/Makefile                |    2 +
 arch/arm/mach-meson8b/include/mach/lcd_reg.h  |   33 +
 arch/arm/mach-meson8b/include/mach/lcdoutc.h  |   24 +
 arch/arm/mach-meson8b/lcd/Makefile            |    1 +
 arch/arm/mach-meson8b/lcd/lcd_config.c        | 1438 ++++++
 arch/arm/mach-meson8b/lcd/lcd_config.h        |  191 +
 arch/arm/mach-meson8b/lcd/mipi_dsi_util.c     | 1218 +++++
 arch/arm/mach-meson8b/lcd/mipi_dsi_util.h     |  430 ++
 .../display/backlight/aml_bl_extern/Makefile  |    1 +
 .../display/backlight/aml_bl_extern/aml.dtd   |   15 +
 .../backlight/aml_bl_extern/mipi_LT070ME05.c  |  188 +
 drivers/amlogic/display/vout/Makefile         |    2 -
 drivers/amlogic/display/vout/aml_lcd.dtd      |   63 +
 drivers/amlogic/display/vout/lcdoutc.c        | 4524 +++--------------
 include/linux/amlogic/vout/lcdoutc.h          |  465 +-
 42 files changed, 9044 insertions(+), 4562 deletions(-)
 create mode 100755 arch/arm/mach-meson6/include/mach/lcd_reg.h
 create mode 100755 arch/arm/mach-meson6/include/mach/lcdoutc.h
 create mode 100755 arch/arm/mach-meson6/lcd/Makefile
 create mode 100755 arch/arm/mach-meson6/lcd/lcd_config.c
 create mode 100755 arch/arm/mach-meson6/lcd/lcd_config.h
 rename {include/linux/amlogic/vout => arch/arm/mach-meson8/include/mach}/lcd_reg.h (86%)
 create mode 100755 arch/arm/mach-meson8/include/mach/lcdoutc.h
 create mode 100755 arch/arm/mach-meson8/lcd/Makefile
 rename {drivers/amlogic/display/vout => arch/arm/mach-meson8/lcd}/edp_drv.c (87%)
 rename {drivers/amlogic/display/vout => arch/arm/mach-meson8/lcd}/edp_drv.h (86%)
 create mode 100755 arch/arm/mach-meson8/lcd/lcd_config.c
 create mode 100755 arch/arm/mach-meson8/lcd/lcd_config.h
 rename {drivers/amlogic/display/vout => arch/arm/mach-meson8/lcd}/mipi_dsi_util.c (84%)
 rename {drivers/amlogic/display/vout => arch/arm/mach-meson8/lcd}/mipi_dsi_util.h (97%)
 create mode 100755 arch/arm/mach-meson8b/include/mach/lcd_reg.h
 create mode 100755 arch/arm/mach-meson8b/include/mach/lcdoutc.h
 create mode 100755 arch/arm/mach-meson8b/lcd/Makefile
 create mode 100755 arch/arm/mach-meson8b/lcd/lcd_config.c
 create mode 100755 arch/arm/mach-meson8b/lcd/lcd_config.h
 create mode 100755 arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
 create mode 100755 arch/arm/mach-meson8b/lcd/mipi_dsi_util.h
 create mode 100755 drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c

diff --git a/arch/arm/boot/dts/amlogic/meson6_g24.dtd b/arch/arm/boot/dts/amlogic/meson6_g24.dtd
index b6f9a84b0cae..aa836f5038e0 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g24.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g24.dtd
@@ -474,9 +474,7 @@
 		lcd_bits_user=<6>;	/** user defined lcd bits(6 or 8, decided by hardware design; only valid when lcd_bits_option=1) */
 		
 		/* below configs are decided by hardware design, you can modify them if needed. */
-		//ttl config
 		ttl_rb_bit_swap=<0 0>;	/** ttl rb_swap, bit_swap : (0=normal, 1=swap) */
-		//lvds config
 		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap(0=normal, 1=swap) */
 		
 		/* recommend settings, you can modify them if needed. */
@@ -486,7 +484,7 @@
 		dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 		
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
diff --git a/arch/arm/boot/dts/amlogic/meson6_g33_1212.dtd b/arch/arm/boot/dts/amlogic/meson6_g33_1212.dtd
index 4bb6113d79ea..77f2189919de 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g33_1212.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g33_1212.dtd
@@ -834,7 +834,7 @@ void root_func(){
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -902,9 +902,7 @@ void root_func(){
 		lcd_bits_user=<6>;	/** user defined lcd bits(6 or 8, decided by hardware design; only valid when lcd_bits_option=1) */
 		
 		/* below configs are decided by hardware design, you can modify them if needed. */
-		//ttl config
 		ttl_rb_bit_swap=<0 0>;	/** ttl rb_swap, bit_swap : (0=normal, 1=swap) */
-		//lvds config
 		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap(0=normal, 1=swap) */
 		
 		/* recommend settings, you can modify them if needed. */
@@ -914,7 +912,7 @@ void root_func(){
 		dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 		
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
diff --git a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
index 0c42bc0f612d..3f0e89c8a9d8 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g33_1G.dtd
@@ -834,7 +834,7 @@ void root_func(){
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -902,9 +902,7 @@ void root_func(){
 		lcd_bits_user=<6>;	/** user defined lcd bits(6 or 8, decided by hardware design; only valid when lcd_bits_option=1) */
 		
 		/* below configs are decided by hardware design, you can modify them if needed. */
-		//ttl config
 		ttl_rb_bit_swap=<0 0>;	/** ttl rb_swap, bit_swap : (0=normal, 1=swap) */
-		//lvds config
 		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap(0=normal, 1=swap) */
 		
 		/* recommend settings, you can modify them if needed. */
@@ -914,7 +912,7 @@ void root_func(){
 		dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 		
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
diff --git a/arch/arm/boot/dts/amlogic/meson6_g33_512M.dtd b/arch/arm/boot/dts/amlogic/meson6_g33_512M.dtd
index f05508565fb2..3f662f199c47 100755
--- a/arch/arm/boot/dts/amlogic/meson6_g33_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson6_g33_512M.dtd
@@ -848,7 +848,7 @@ void root_func(){
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -916,9 +916,7 @@ void root_func(){
 		lcd_bits_user=<6>;	/** user defined lcd bits(6 or 8, decided by hardware design; only valid when lcd_bits_option=1) */
 		
 		/* below configs are decided by hardware design, you can modify them if needed. */
-		//ttl config
 		ttl_rb_bit_swap=<0 0>;	/** ttl rb_swap, bit_swap : (0=normal, 1=swap) */
-		//lvds config
 		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap(0=normal, 1=swap) */
 		
 		/* recommend settings, you can modify them if needed. */
@@ -928,7 +926,7 @@ void root_func(){
 		dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 		
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index c9721a83b87d..4ba020f2650d 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -993,7 +993,7 @@ sdio{
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -1004,6 +1004,7 @@ sdio{
 //$$ L4 PROP_U32 2 = "lvds_user_repack"
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
+//$$ L4 PROP_U32 = "edp_sync_clock_mode"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1070,7 +1071,7 @@ sdio{
 		dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 		
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 3 4 6 7 8 10 11 12 14 15 17 18 19 22 23 23 24 25 26 27 28 29 30 31 31 32 33 34 35 36 
@@ -1090,6 +1091,7 @@ sdio{
 		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
 		edp_user_link_rate_lane_count=<1 1 2>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
+		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
@@ -1139,7 +1141,8 @@ sdio{
 //$$ L2 PROP_U32 2 = "clock_hz_pol"
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
-//$$ L2 PROP_U32 2 = "pol_hsync_vsync"		
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "max_lane_count"
 	lcd_LP097QX1:lcd_LP097QX1{	//k100
 		model_name="LP097QX1";	/** lcd model name */
 		interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1153,6 +1156,8 @@ sdio{
 		hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
 		vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
 		pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+		
+		max_lane_count=<4>; /** max lane count supported */
 	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_B080XAN01>
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index 2363139d17a0..eb260b9575c0 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -983,7 +983,7 @@ sdio{
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -1060,7 +1060,7 @@ sdio{
 		dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 		
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 3 4 6 7 8 10 11 12 14 15 17 18 19 22 23 23 24 25 26 27 28 29 30 31 31 32 33 34 35 36 
@@ -1080,6 +1080,7 @@ sdio{
 		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
 		edp_user_link_rate_lane_count=<1 1 2>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
+		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 		
 		//lcd power ctrl	//support up to 15 steps for each sequence
@@ -1129,7 +1130,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "clock_hz_pol"
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
-//$$ L2 PROP_U32 2 = "pol_hsync_vsync"		
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 	lcd_LP097QX1:lcd_LP097QX1{	//k100
 		model_name="LP097QX1";	/** lcd model name */
 		interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1143,6 +1144,8 @@ sdio{
 		hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
 		vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
 		pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+		
+		max_lane_count=<4>; /** max lane count supported */
 	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_B080XAN01>
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
index c3d6d2082628..7f2c6f1768f8 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
@@ -925,7 +925,7 @@ sdio{
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -936,6 +936,7 @@ sdio{
 //$$ L4 PROP_U32 2 = "lvds_user_repack"
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
+//$$ L4 PROP_U32 = "edp_sync_clock_mode"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1002,7 +1003,7 @@ sdio{
 		dither_user_ctrl=<0 0x000>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 8 9 10 11 12 13 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
@@ -1022,6 +1023,7 @@ sdio{
 		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
+		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
@@ -1071,7 +1073,8 @@ sdio{
 //$$ L2 PROP_U32 2 = "clock_hz_pol"
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
-//$$ L2 PROP_U32 2 = "pol_hsync_vsync"		
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "max_lane_count"
 //	lcd_LP097QX1:lcd_LP097QX1{	//k100
 //		model_name="LP097QX1";	/** lcd model name */
 //		interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1085,6 +1088,8 @@ sdio{
 //		hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
 //		vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+		
+//		max_lane_count=<4>; /** max lane count supported */
 //	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_B080XAN01>
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index 3810786103ba..b589e321200c 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -926,7 +926,7 @@ sdio{
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -937,6 +937,7 @@ sdio{
 //$$ L4 PROP_U32 2 = "lvds_user_repack"
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
+//$$ L4 PROP_U32 = "edp_sync_clock_mode"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -994,7 +995,7 @@ sdio{
 
 		/* below configs are decided by hardware design, you can modify them if needed. */
 		ttl_rb_bit_swap=<0 0>;	/** ttl rb_swap, bit_swap : (0=normal, 1=swap) */
-		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap(0=normal, 1=swap) */
+		lvds_channel_pn_swap=<0>;	/** lvds channel pn swap: (0=normal, 1=swap) */
 
 		/* recommend settings, you can modify them if needed. */
 		valid_hvsync_de=<1 1>;	/** hvsync_signal_valid, DE_signal_valid : (0=disable signal, 1=enable signal) */
@@ -1003,7 +1004,7 @@ sdio{
 		dither_user_ctrl=<0 0x000>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 8 9 10 11 12 13 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
@@ -1023,6 +1024,7 @@ sdio{
 		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
+		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
@@ -1072,7 +1074,8 @@ sdio{
 //$$ L2 PROP_U32 2 = "clock_hz_pol"
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
-//$$ L2 PROP_U32 2 = "pol_hsync_vsync"		
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "max_lane_count"
 //	lcd_LP097QX1:lcd_LP097QX1{	//k100
 //		model_name="LP097QX1";	/** lcd model name */
 //		interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1086,6 +1089,8 @@ sdio{
 //		hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
 //		vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+		
+//		max_lane_count=<4>; /** max lane count supported */
 //	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_B080XAN01>
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index 31d87394607c..124bfef8dc29 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -976,7 +976,7 @@ sdio{
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -987,6 +987,7 @@ sdio{
 //$$ L4 PROP_U32 2 = "lvds_user_repack"
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
+//$$ L4 PROP_U32 = "edp_sync_clock_mode"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1053,7 +1054,7 @@ sdio{
 		dither_user_ctrl=<0 0x000>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 8 9 10 11 12 13 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
@@ -1073,6 +1074,7 @@ sdio{
 		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
+		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
@@ -1123,6 +1125,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"		
+//$$ L2 PROP_U32 = "max_lane_count"
 	lcd_LP097QX1:lcd_LP097QX1{	//k100
 		model_name="LP097QX1";	/** lcd model name */
 		interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1136,6 +1139,8 @@ sdio{
 		hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
 		vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+		
+		max_lane_count=<4>; /** max lane count supported */
 	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_KD079D1>
diff --git a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
index fabdff2b4b2a..cee1b6a65895 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
@@ -939,7 +939,7 @@ sdio{
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -950,6 +950,7 @@ sdio{
 //$$ L4 PROP_U32 2 = "lvds_user_repack"
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
+//$$ L4 PROP_U32 = "edp_sync_clock_mode"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1016,7 +1017,7 @@ sdio{
 		dither_user_ctrl=<0 0x000>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 8 9 10 11 12 13 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
@@ -1036,6 +1037,7 @@ sdio{
 		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
+		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
@@ -1086,6 +1088,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"		
+//$$ L2 PROP_U32 = "max_lane_count"
 	lcd_LP097QX1:lcd_LP097QX1{	//k100
 		model_name="LP097QX1";	/** lcd model name */
 		interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1099,6 +1102,8 @@ sdio{
 		hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
 		vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+		
+		max_lane_count=<4>; /** max lane count supported */
 	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_B080XAN01>
diff --git a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
index 13e86eb991de..83ac85281a3a 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
@@ -959,7 +959,7 @@ sdio{
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -970,6 +970,7 @@ sdio{
 //$$ L4 PROP_U32 2 = "lvds_user_repack"
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
+//$$ L4 PROP_U32 = "edp_sync_clock_mode"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1036,7 +1037,7 @@ sdio{
 		dither_user_ctrl=<0 0x000>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
 		vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 
-		gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+		gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=reverse) */
 		gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
 		/** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
 		gamma_table=<0 1 2 3 4 5 6 7 8 8 9 10 11 12 13 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
@@ -1056,6 +1057,7 @@ sdio{
 		lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
+		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
@@ -1106,6 +1108,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"		
+//$$ L2 PROP_U32 = "max_lane_count"
 	lcd_LP097QX1:lcd_LP097QX1{	//k100
 		model_name="LP097QX1";	/** lcd model name */
 		interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1119,6 +1122,8 @@ sdio{
 		hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
 		vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+		
+		max_lane_count=<4>; /** max lane count supported */
 	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_B080XAN01>
diff --git a/arch/arm/mach-meson6/Makefile b/arch/arm/mach-meson6/Makefile
index 6456ea2ee4c5..5a7cea76a5aa 100644
--- a/arch/arm/mach-meson6/Makefile
+++ b/arch/arm/mach-meson6/Makefile
@@ -42,6 +42,8 @@ obj-$(CONFIG_CPU_IDLE) += cpuidle.o
 
 obj-$(CONFIG_AML_HDMI_TX) +=  hdmi_tx_hw/
 
+obj-$(CONFIG_AM_LCD_OUTPUT) +=  lcd/
+
 # ARM Trustzone
 obj-$(CONFIG_MESON_TRUSTZONE) += meson-smc.o meson-secure.o
 ifeq ($(CONFIG_MESON_TRUSTZONE),y)
diff --git a/arch/arm/mach-meson6/include/mach/lcd_reg.h b/arch/arm/mach-meson6/include/mach/lcd_reg.h
new file mode 100755
index 000000000000..b1cabe50a535
--- /dev/null
+++ b/arch/arm/mach-meson6/include/mach/lcd_reg.h
@@ -0,0 +1,26 @@
+#ifndef LCD_CONTROLLER_REG_H
+#define LCD_CONTROLLER_REG_H
+#include <mach/io.h>
+
+#define LCD_REG_BASE_ADDR				IO_CBUS_BASE
+#define LCD_CBUS_BASE_ADDR				IO_CBUS_BASE
+
+#define LCD_REG_OFFSET(reg)				(reg << 2)
+#define LCD_CBUS_OFFSET(reg)			(reg << 2)
+
+#define LCD_REG_ADDR(reg)				(LCD_REG_BASE_ADDR + LCD_REG_OFFSET(reg))
+#define LCD_CBUS_ADDR(reg)				(LCD_CBUS_BASE_ADDR + LCD_CBUS_OFFSET(reg))
+
+#define WRITE_LCD_REG(reg, val) 					aml_write_reg32(LCD_REG_ADDR(reg), (val))
+#define READ_LCD_REG(reg) 							aml_read_reg32(LCD_REG_ADDR(reg))
+#define WRITE_LCD_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_REG_ADDR(reg), (val),start,len)
+#define CLR_LCD_REG_MASK(reg, mask)   				aml_clr_reg32_mask(LCD_REG_ADDR(reg), (mask))
+#define SET_LCD_REG_MASK(reg, mask)     			aml_set_reg32_mask(LCD_REG_ADDR(reg), (mask))
+
+#define WRITE_LCD_CBUS_REG(reg, val) 					aml_write_reg32(LCD_CBUS_ADDR(reg), (val))
+#define READ_LCD_CBUS_REG(reg) 							aml_read_reg32(LCD_CBUS_ADDR(reg))
+#define WRITE_LCD_CBUS_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_CBUS_ADDR(reg), (val),start,len)
+#define CLR_LCD_CBUS_REG_MASK(reg, mask)   				aml_clr_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
+#define SET_LCD_CBUS_REG_MASK(reg, mask)     			aml_set_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
+
+#endif
diff --git a/arch/arm/mach-meson6/include/mach/lcdoutc.h b/arch/arm/mach-meson6/include/mach/lcdoutc.h
new file mode 100755
index 000000000000..38751485000a
--- /dev/null
+++ b/arch/arm/mach-meson6/include/mach/lcdoutc.h
@@ -0,0 +1,24 @@
+
+#ifndef MACH_LCDOUTC_H
+#define MACH_LCDOUTC_H
+
+#define CONFIG_LCD_TYPE_MID_VALID
+#define CONFIG_LCD_IF_TTL_VALID
+#define CONFIG_LCD_IF_LVDS_VALID
+#define CONFIG_LCD_IF_MLVDS_VALID
+/*
+// lcd driver global API, special by CPU
+*/
+//*************************************************************
+// For mipi-dsi external driver use
+//*************************************************************
+//payload struct:
+//data_type, command, para_num, parameters...
+//data_type=0xff, command=0xff, means ending flag
+//data_type=0xff, command<0xff, means delay time(unit ms)
+//return:
+//command num
+extern int dsi_write_cmd(unsigned char* payload);
+//*************************************************************
+
+#endif
diff --git a/arch/arm/mach-meson6/lcd/Makefile b/arch/arm/mach-meson6/lcd/Makefile
new file mode 100755
index 000000000000..47e41434403b
--- /dev/null
+++ b/arch/arm/mach-meson6/lcd/Makefile
@@ -0,0 +1 @@
+obj-y		+= lcd_config.o
diff --git a/arch/arm/mach-meson6/lcd/lcd_config.c b/arch/arm/mach-meson6/lcd/lcd_config.c
new file mode 100755
index 000000000000..2be3a10e76c7
--- /dev/null
+++ b/arch/arm/mach-meson6/lcd/lcd_config.c
@@ -0,0 +1,1868 @@
+/*
+ * AMLOGIC lcd controller driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ * Modify:  Evoke Zhang <evoke.zhang@amlogic.com>
+ * compatible dts
+ *
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <plat/regops.h>
+#include <mach/am_regs.h>
+#include <mach/lcd_reg.h>
+#include <linux/amlogic/vout/lcdoutc.h>
+#include <mach/clock.h>
+#include <mach/mod_gate.h>
+#include <asm/fiq.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include "lcd_config.h"
+
+#define VPP_OUT_SATURATE	(1 << 0)
+
+static spinlock_t gamma_write_lock;
+static spinlock_t lcd_clk_lock;
+
+static Lcd_Config_t *lcd_Conf;
+static unsigned char lcd_gamma_init_err = 0;
+static unsigned gamma_cntl_port_offset = 0;
+
+void lcd_config_init(Lcd_Config_t *pConf);
+
+static void print_lcd_driver_version(void)
+{
+    printk("lcd driver version: %s%s\n\n", LCD_DRV_DATE, LCD_DRV_TYPE);
+}
+
+static void lcd_ports_ctrl_lvds(Bool_t status)
+{
+	if (status) {
+		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1); //enable lvds fifo
+		if (lcd_Conf->lcd_basic.lcd_bits == 6) {
+			WRITE_LCD_REG_BITS(LVDS_PHY_CNTL4, 0x27, 0, 7);	//enable LVDS 3 channels
+		}
+		else {
+			WRITE_LCD_REG_BITS(LVDS_PHY_CNTL4, 0x2f, 0, 7); //enable LVDS 4 channels
+		}
+	}
+	else {
+		WRITE_LCD_REG_BITS(LVDS_PHY_CNTL3, 0, 0, 1);
+		WRITE_LCD_REG_BITS(LVDS_PHY_CNTL5, 0, 11, 1);	//shutdown lvds phy
+		WRITE_LCD_REG_BITS(LVDS_PHY_CNTL4, 0, 0, 7);	//disable LVDS 4 channels
+		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
+	}
+
+	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl_ttl(Bool_t status)
+{
+	struct pinctrl_state *s;
+	int ret;
+	
+	if (IS_ERR(lcd_Conf->lcd_misc_ctrl.pin)) {
+		printk("set ttl_ports_ctrl pinmux error.\n");
+		return;
+	}
+
+	if (status) {
+	if (lcd_Conf->lcd_basic.lcd_bits == 6) {
+			if (lcd_Conf->lcd_timing.de_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_hvsync_on");
+			}
+			else if (lcd_Conf->lcd_timing.hvsync_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_de_on");
+			}
+			else {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_hvsync_de_on");	//select pinmux
+			}
+		}
+		else {
+			if (lcd_Conf->lcd_timing.de_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_hvsync_on");
+			}	
+			else if (lcd_Conf->lcd_timing.hvsync_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_de_on");
+			}
+			else {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_hvsync_de_on");	//select pinmux
+			}
+		}
+		if (IS_ERR(lcd_Conf->lcd_misc_ctrl.pin)) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+
+		ret = pinctrl_select_state(lcd_Conf->lcd_misc_ctrl.pin, s);	//set pinmux and lock pins
+		if (ret < 0) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+	}else {
+		//pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);	//release pins
+		if (lcd_Conf->lcd_basic.lcd_bits == 6) {
+			s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_hvsync_de_off");	//select pinmux
+		}
+		else {
+			s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_hvsync_de_off");	//select pinmux
+		}
+		if (IS_ERR(lcd_Conf->lcd_misc_ctrl.pin)) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+		
+		ret = pinctrl_select_state(lcd_Conf->lcd_misc_ctrl.pin, s);	//set pinmux and lock pins
+		if (ret < 0) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+	}
+	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl_mlvds(Bool_t status)
+{
+	return;
+}
+
+static void lcd_ports_ctrl(Bool_t status)
+{
+    switch(lcd_Conf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_LVDS:
+            lcd_ports_ctrl_lvds(status);
+            break;
+        case LCD_DIGITAL_TTL:
+            lcd_ports_ctrl_ttl(status);
+            break;
+        case LCD_DIGITAL_MINILVDS:
+            lcd_ports_ctrl_mlvds(status);
+            break;
+        default:
+            printk("Invalid LCD type.\n");
+            break;
+    }
+}
+
+#define LCD_GAMMA_RETRY_CNT  1000
+static void write_gamma_table(u16 *data, u32 rgb_mask, u16 gamma_coeff, u32 gamma_reverse)
+{
+	int i;
+	int cnt = 0;
+	unsigned long flags = 0;
+	
+	spin_lock_irqsave(&gamma_write_lock, flags);
+	rgb_mask = gamma_sel_table[rgb_mask];
+	while ((!(READ_LCD_REG(L_GAMMA_CNTL_PORT+gamma_cntl_port_offset) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG((L_GAMMA_ADDR_PORT+gamma_cntl_port_offset), (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x0 << LCD_HADR));
+	if (gamma_reverse == 0) {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT+gamma_cntl_port_offset) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG((L_GAMMA_DATA_PORT+gamma_cntl_port_offset), (data[i] * gamma_coeff / 100));
+		}
+	}
+	else {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT+gamma_cntl_port_offset) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG((L_GAMMA_DATA_PORT+gamma_cntl_port_offset), (data[255-i] * gamma_coeff / 100));
+		}
+	}
+	cnt = 0;
+	while ((!(READ_LCD_REG((L_GAMMA_CNTL_PORT+gamma_cntl_port_offset)) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG((L_GAMMA_ADDR_PORT+gamma_cntl_port_offset), (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x23 << LCD_HADR));
+
+	if (cnt >= LCD_GAMMA_RETRY_CNT)
+		lcd_gamma_init_err = 1;
+	
+	spin_unlock_irqrestore(&gamma_write_lock, flags);
+}
+
+static void set_gamma_table_lcd(unsigned gamma_en)
+{
+	DBG_PRINT("%s\n", __FUNCTION__);
+
+	lcd_gamma_init_err = 0;
+	if (lcd_Conf->lcd_basic.lcd_type == LCD_DIGITAL_TTL)
+		gamma_cntl_port_offset = 0x80;
+	else
+		gamma_cntl_port_offset = 0x0;
+	write_gamma_table(lcd_Conf->lcd_effect.GammaTableR, GAMMA_SEL_R, lcd_Conf->lcd_effect.gamma_r_coeff, ((lcd_Conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+	write_gamma_table(lcd_Conf->lcd_effect.GammaTableG, GAMMA_SEL_G, lcd_Conf->lcd_effect.gamma_g_coeff, ((lcd_Conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+	write_gamma_table(lcd_Conf->lcd_effect.GammaTableB, GAMMA_SEL_B, lcd_Conf->lcd_effect.gamma_b_coeff, ((lcd_Conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+
+	if (lcd_gamma_init_err) {
+		WRITE_LCD_REG_BITS((L_GAMMA_CNTL_PORT + gamma_cntl_port_offset), 0, 0, 1);
+		printk("[warning]: write gamma table error, gamma table disabled\n");
+	}
+	else
+		WRITE_LCD_REG_BITS((L_GAMMA_CNTL_PORT + gamma_cntl_port_offset), gamma_en, 0, 1);
+}
+
+static void write_tcon_double(MLVDS_Tcon_Config_t *mlvds_tcon)
+{
+    int channel_num = mlvds_tcon->channel_num;
+    int hv_sel = (mlvds_tcon->hv_sel) & 1;
+    int hstart_1 = mlvds_tcon->tcon_1st_hs_addr;
+    int hend_1 = mlvds_tcon->tcon_1st_he_addr;
+    int vstart_1 = mlvds_tcon->tcon_1st_vs_addr;
+    int vend_1 = mlvds_tcon->tcon_1st_ve_addr;
+    int hstart_2 = mlvds_tcon->tcon_2nd_hs_addr;
+    int hend_2 = mlvds_tcon->tcon_2nd_he_addr;
+    int vstart_2 = mlvds_tcon->tcon_2nd_vs_addr;
+    int vend_2 = mlvds_tcon->tcon_2nd_ve_addr;
+
+    switch(channel_num) {
+        case 0 :
+            WRITE_LCD_REG(MTCON0_1ST_HS_ADDR, hstart_1);
+            WRITE_LCD_REG(MTCON0_1ST_HE_ADDR, hend_1);
+            WRITE_LCD_REG(MTCON0_1ST_VS_ADDR, vstart_1);
+            WRITE_LCD_REG(MTCON0_1ST_VE_ADDR, vend_1);
+            WRITE_LCD_REG(MTCON0_2ND_HS_ADDR, hstart_2);
+            WRITE_LCD_REG(MTCON0_2ND_HE_ADDR, hend_2);
+            WRITE_LCD_REG(MTCON0_2ND_VS_ADDR, vstart_2);
+            WRITE_LCD_REG(MTCON0_2ND_VE_ADDR, vend_2);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STH1_SEL, 1);
+            break;
+        case 1 :
+            WRITE_LCD_REG(MTCON1_1ST_HS_ADDR, hstart_1);
+            WRITE_LCD_REG(MTCON1_1ST_HE_ADDR, hend_1);
+            WRITE_LCD_REG(MTCON1_1ST_VS_ADDR, vstart_1);
+            WRITE_LCD_REG(MTCON1_1ST_VE_ADDR, vend_1);
+            WRITE_LCD_REG(MTCON1_2ND_HS_ADDR, hstart_2);
+            WRITE_LCD_REG(MTCON1_2ND_HE_ADDR, hend_2);
+            WRITE_LCD_REG(MTCON1_2ND_VS_ADDR, vstart_2);
+            WRITE_LCD_REG(MTCON1_2ND_VE_ADDR, vend_2);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_CPV1_SEL, 1);
+            break;
+        case 2 :
+            WRITE_LCD_REG(MTCON2_1ST_HS_ADDR, hstart_1);
+            WRITE_LCD_REG(MTCON2_1ST_HE_ADDR, hend_1);
+            WRITE_LCD_REG(MTCON2_1ST_VS_ADDR, vstart_1);
+            WRITE_LCD_REG(MTCON2_1ST_VE_ADDR, vend_1);
+            WRITE_LCD_REG(MTCON2_2ND_HS_ADDR, hstart_2);
+            WRITE_LCD_REG(MTCON2_2ND_HE_ADDR, hend_2);
+            WRITE_LCD_REG(MTCON2_2ND_VS_ADDR, vstart_2);
+            WRITE_LCD_REG(MTCON2_2ND_VE_ADDR, vend_2);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STV1_SEL, 1);
+            break;
+        case 3 :
+            WRITE_LCD_REG(MTCON3_1ST_HS_ADDR, hstart_1);
+            WRITE_LCD_REG(MTCON3_1ST_HE_ADDR, hend_1);
+            WRITE_LCD_REG(MTCON3_1ST_VS_ADDR, vstart_1);
+            WRITE_LCD_REG(MTCON3_1ST_VE_ADDR, vend_1);
+            WRITE_LCD_REG(MTCON3_2ND_HS_ADDR, hstart_2);
+            WRITE_LCD_REG(MTCON3_2ND_HE_ADDR, hend_2);
+            WRITE_LCD_REG(MTCON3_2ND_VS_ADDR, vstart_2);
+            WRITE_LCD_REG(MTCON3_2ND_VE_ADDR, vend_2);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEV1_SEL, 1);
+            break;
+        case 4 :
+            WRITE_LCD_REG(MTCON4_1ST_HS_ADDR, hstart_1);
+            WRITE_LCD_REG(MTCON4_1ST_HE_ADDR, hend_1);
+            WRITE_LCD_REG(MTCON4_1ST_VS_ADDR, vstart_1);
+            WRITE_LCD_REG(MTCON4_1ST_VE_ADDR, vend_1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STH2_SEL, 1);
+            break;
+        case 5 :
+            WRITE_LCD_REG(MTCON5_1ST_HS_ADDR, hstart_1);
+            WRITE_LCD_REG(MTCON5_1ST_HE_ADDR, hend_1);
+            WRITE_LCD_REG(MTCON5_1ST_VS_ADDR, vstart_1);
+            WRITE_LCD_REG(MTCON5_1ST_VE_ADDR, vend_1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_CPV2_SEL, 1);
+            break;
+        case 6 :
+            WRITE_LCD_REG(MTCON6_1ST_HS_ADDR, hstart_1);
+            WRITE_LCD_REG(MTCON6_1ST_HE_ADDR, hend_1);
+            WRITE_LCD_REG(MTCON6_1ST_VS_ADDR, vstart_1);
+            WRITE_LCD_REG(MTCON6_1ST_VE_ADDR, vend_1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEH_SEL, 1);
+            break;
+        case 7 :
+            WRITE_LCD_REG(MTCON7_1ST_HS_ADDR, hstart_1);
+            WRITE_LCD_REG(MTCON7_1ST_HE_ADDR, hend_1);
+            WRITE_LCD_REG(MTCON7_1ST_VS_ADDR, vstart_1);
+            WRITE_LCD_REG(MTCON7_1ST_VE_ADDR, vend_1);
+            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEV3_SEL, 1);
+            break;
+        default:
+            break;
+    }
+}
+
+static void set_tcon_lvds(Lcd_Config_t *pConf)
+{
+	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
+	unsigned hs_pol_adj, vs_pol_adj;
+
+	DBG_PRINT("%s\n", __FUNCTION__);
+	
+	set_gamma_table_lcd(((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1));
+	
+	WRITE_LCD_REG(L_RGB_BASE_ADDR,  pConf->lcd_effect.rgb_base_addr);
+	WRITE_LCD_REG(L_RGB_COEFF_ADDR, pConf->lcd_effect.rgb_coeff_addr);
+	if (pConf->lcd_effect.dith_user) {
+		WRITE_LCD_REG(L_DITH_CNTL_ADDR,  pConf->lcd_effect.dith_cntl_addr);
+	}
+	else {
+		if(pConf->lcd_basic.lcd_bits == 8)
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x400);
+		else
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x600);
+	}
+	
+	WRITE_LCD_REG(L_POL_CNTL_ADDR,   (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1) << LCD_CPH1_POL));
+	
+	hs_pol_adj = (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1) ? 0 : 1); //1 for low active, 0 for high active.
+	vs_pol_adj = (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1) ? 0 : 1); //1 for low active, 0 for high active
+	WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((0 << LCD_DE_POL) | (vs_pol_adj << LCD_VS_POL) | (hs_pol_adj << LCD_HS_POL)))); //adjust hvsync pol
+	WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((1 << LCD_TCON_DE_SEL) | (1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL)))); //enable tcon DE, Hsync, Vsync 
+	
+	//DE signal
+	WRITE_LCD_REG(L_DE_HS_ADDR,		tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(L_DE_HE_ADDR,		tcon_adr->de_he_addr);
+	WRITE_LCD_REG(L_DE_VS_ADDR,		tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(L_DE_VE_ADDR,		tcon_adr->de_ve_addr);
+	
+	//Hsync signal
+	WRITE_LCD_REG(L_HSYNC_HS_ADDR,	tcon_adr->hs_hs_addr);
+	WRITE_LCD_REG(L_HSYNC_HE_ADDR,	tcon_adr->hs_he_addr);
+	WRITE_LCD_REG(L_HSYNC_VS_ADDR,	tcon_adr->hs_vs_addr);
+	WRITE_LCD_REG(L_HSYNC_VE_ADDR,	tcon_adr->hs_ve_addr);
+	
+	//Vsync signal
+	WRITE_LCD_REG(L_VSYNC_HS_ADDR,	tcon_adr->vs_hs_addr);
+	WRITE_LCD_REG(L_VSYNC_HE_ADDR,	tcon_adr->vs_he_addr);
+	WRITE_LCD_REG(L_VSYNC_VS_ADDR,	tcon_adr->vs_vs_addr);
+	WRITE_LCD_REG(L_VSYNC_VE_ADDR,	tcon_adr->vs_ve_addr);
+
+	if(pConf->lcd_misc_ctrl.vpp_sel)
+		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
+	else
+		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+}
+
+static void set_tcon_ttl(Lcd_Config_t *pConf)
+{
+	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
+	unsigned hs_pol_adj, vs_pol_adj;
+	
+	DBG_PRINT("%s\n", __FUNCTION__);
+
+	set_gamma_table_lcd(((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1));
+
+	WRITE_LCD_REG(RGB_BASE_ADDR,   pConf->lcd_effect.rgb_base_addr);
+	WRITE_LCD_REG(RGB_COEFF_ADDR,  pConf->lcd_effect.rgb_coeff_addr);
+	if (pConf->lcd_effect.dith_user) {
+		WRITE_LCD_REG(DITH_CNTL_ADDR,  pConf->lcd_effect.dith_cntl_addr);
+	}
+	else {
+		if(pConf->lcd_basic.lcd_bits == 8)
+			WRITE_LCD_REG(DITH_CNTL_ADDR,  0x400);
+		else
+			WRITE_LCD_REG(DITH_CNTL_ADDR,  0x600);
+	}
+	
+	WRITE_LCD_REG(POL_CNTL_ADDR,   (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1) << LCD_CPH1_POL));
+	
+	hs_pol_adj = (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1) ? 0 : 1); //1 for low active, 0 for high active.
+	vs_pol_adj = (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1) ? 0 : 1); //1 for low active, 0 for high active
+
+	//DE signal
+	WRITE_LCD_REG(OEH_HS_ADDR,     tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(OEH_HE_ADDR,     tcon_adr->de_he_addr);
+	WRITE_LCD_REG(OEH_VS_ADDR,     tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(OEH_VE_ADDR,     tcon_adr->de_ve_addr);
+	
+	//Hsync signal
+	if (hs_pol_adj == 0) {
+		WRITE_LCD_REG(STH1_HS_ADDR,    tcon_adr->hs_hs_addr);
+		WRITE_LCD_REG(STH1_HE_ADDR,    tcon_adr->hs_he_addr);
+	}
+	else {
+		WRITE_LCD_REG(STH1_HS_ADDR,    tcon_adr->hs_he_addr);
+		WRITE_LCD_REG(STH1_HE_ADDR,    tcon_adr->hs_hs_addr);
+	}
+	WRITE_LCD_REG(STH1_VS_ADDR,    tcon_adr->hs_vs_addr);
+	WRITE_LCD_REG(STH1_VE_ADDR,    tcon_adr->hs_ve_addr);
+
+	//Vsync signal
+	WRITE_LCD_REG(STV1_HS_ADDR,    tcon_adr->vs_hs_addr);
+	WRITE_LCD_REG(STV1_HE_ADDR,    tcon_adr->vs_he_addr);
+	if (vs_pol_adj == 0) {
+		WRITE_LCD_REG(STV1_VS_ADDR,    tcon_adr->vs_vs_addr);
+		WRITE_LCD_REG(STV1_VE_ADDR,    tcon_adr->vs_ve_addr);
+	}
+	else {
+		WRITE_LCD_REG(STV1_VS_ADDR,    tcon_adr->vs_ve_addr);
+		WRITE_LCD_REG(STV1_VE_ADDR,    tcon_adr->vs_vs_addr);	
+	}
+	
+	WRITE_LCD_REG(INV_CNT_ADDR,       0);
+	WRITE_LCD_REG(TCON_MISC_SEL_ADDR, ((1 << LCD_STV1_SEL) | (1 << LCD_STV2_SEL)));
+
+	if(pConf->lcd_misc_ctrl.vpp_sel)
+		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
+	else
+		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+}
+
+// Set the mlvds TCON
+// this function should support dual gate or singal gate TCON setting.
+// singal gate TCON, Scan Function TO DO.
+// scan_function   // 0 - Z1, 1 - Z2, 2- Gong
+static void set_tcon_mlvds(Lcd_Config_t *pConf)
+{
+	MLVDS_Tcon_Config_t *mlvds_tconfig_l = pConf->lcd_control.mlvds_tcon_config;
+    int dual_gate = pConf->lcd_control.mlvds_config->test_dual_gate;
+    int bit_num = pConf->lcd_basic.lcd_bits;
+    int pair_num = pConf->lcd_control.mlvds_config->test_pair_num;
+
+    unsigned int data32;
+
+    int pclk_div;
+    int ext_pixel = dual_gate ? pConf->lcd_control.mlvds_config->total_line_clk : 0;
+    int dual_wr_rd_start;
+    int i = 0;
+	
+	DBG_PRINT("%s.\n", __FUNCTION__);
+
+	set_gamma_table_lcd(((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1));
+
+    WRITE_LCD_REG(L_RGB_BASE_ADDR, pConf->lcd_effect.rgb_base_addr);
+    WRITE_LCD_REG(L_RGB_COEFF_ADDR, pConf->lcd_effect.rgb_coeff_addr);
+	if (pConf->lcd_effect.dith_user) {
+		WRITE_LCD_REG(L_DITH_CNTL_ADDR,  pConf->lcd_effect.dith_cntl_addr);
+	}	
+	else {
+		if(pConf->lcd_basic.lcd_bits == 8)
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x400);
+		else
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x600);
+	}
+    //WRITE_LCD_REG(L_POL_CNTL_ADDR, pConf->pol_cntl_addr);
+//    WRITE_LCD_REG(L_INV_CNT_ADDR, pConf->inv_cnt_addr);
+//    WRITE_LCD_REG(L_TCON_MISC_SEL_ADDR, pConf->tcon_misc_sel_addr);
+//    WRITE_LCD_REG(L_DUAL_PORT_CNTL_ADDR, pConf->dual_port_cntl_addr);
+//
+    data32 = (0x9867 << tcon_pattern_loop_data) |
+             (1 << tcon_pattern_loop_start) |
+             (4 << tcon_pattern_loop_end) |
+             (1 << ((mlvds_tconfig_l[6].channel_num)+tcon_pattern_enable)); // POL_CHANNEL use pattern generate
+
+    WRITE_LCD_REG(L_TCON_PATTERN_HI,  (data32 >> 16));
+    WRITE_LCD_REG(L_TCON_PATTERN_LO, (data32 & 0xffff));
+
+    pclk_div = (bit_num == 8) ? 3 : // phy_clk / 8
+                                2 ; // phy_clk / 6
+   data32 = (1 << ((mlvds_tconfig_l[7].channel_num)-2+tcon_pclk_enable)) |  // enable PCLK_CHANNEL
+            (pclk_div << tcon_pclk_div) |
+            (
+              (pair_num == 6) ?
+              (
+              ((bit_num == 8) & dual_gate) ?
+              (
+                (0 << (tcon_delay + 0*3)) |
+                (0 << (tcon_delay + 1*3)) |
+                (0 << (tcon_delay + 2*3)) |
+                (0 << (tcon_delay + 3*3)) |
+                (0 << (tcon_delay + 4*3)) |
+                (0 << (tcon_delay + 5*3)) |
+                (0 << (tcon_delay + 6*3)) |
+                (0 << (tcon_delay + 7*3))
+              ) :
+              (
+                (0 << (tcon_delay + 0*3)) |
+                (0 << (tcon_delay + 1*3)) |
+                (0 << (tcon_delay + 2*3)) |
+                (0 << (tcon_delay + 3*3)) |
+                (0 << (tcon_delay + 4*3)) |
+                (0 << (tcon_delay + 5*3)) |
+                (0 << (tcon_delay + 6*3)) |
+                (0 << (tcon_delay + 7*3))
+              )
+              ) :
+              (
+              ((bit_num == 8) & dual_gate) ?
+              (
+                (0 << (tcon_delay + 0*3)) |
+                (0 << (tcon_delay + 1*3)) |
+                (0 << (tcon_delay + 2*3)) |
+                (0 << (tcon_delay + 3*3)) |
+                (0 << (tcon_delay + 4*3)) |
+                (0 << (tcon_delay + 5*3)) |
+                (0 << (tcon_delay + 6*3)) |
+                (0 << (tcon_delay + 7*3))
+              ) :
+              (bit_num == 8) ?
+              (
+                (0 << (tcon_delay + 0*3)) |
+                (0 << (tcon_delay + 1*3)) |
+                (0 << (tcon_delay + 2*3)) |
+                (0 << (tcon_delay + 3*3)) |
+                (0 << (tcon_delay + 4*3)) |
+                (0 << (tcon_delay + 5*3)) |
+                (0 << (tcon_delay + 6*3)) |
+                (0 << (tcon_delay + 7*3))
+              ) :
+              (
+                (0 << (tcon_delay + 0*3)) |
+                (0 << (tcon_delay + 1*3)) |
+                (0 << (tcon_delay + 2*3)) |
+                (0 << (tcon_delay + 3*3)) |
+                (0 << (tcon_delay + 4*3)) |
+                (0 << (tcon_delay + 5*3)) |
+                (0 << (tcon_delay + 6*3)) |
+                (0 << (tcon_delay + 7*3))
+              )
+              )
+            );
+
+    WRITE_LCD_REG(TCON_CONTROL_HI,  (data32 >> 16));
+    WRITE_LCD_REG(TCON_CONTROL_LO, (data32 & 0xffff));
+
+    WRITE_LCD_REG(L_TCON_DOUBLE_CTL,
+                   (1<<(mlvds_tconfig_l[3].channel_num))   // invert CPV
+                  );
+
+	// for channel 4-7, set second setting same as first
+    WRITE_LCD_REG(L_DE_HS_ADDR, (0x3 << 14) | ext_pixel);   // 0x3 -- enable double_tcon fir channel7:6
+    WRITE_LCD_REG(L_DE_HE_ADDR, (0x3 << 14) | ext_pixel);   // 0x3 -- enable double_tcon fir channel5:4
+    WRITE_LCD_REG(L_DE_VS_ADDR, (0x3 << 14) | 0);	// 0x3 -- enable double_tcon fir channel3:2
+    WRITE_LCD_REG(L_DE_VE_ADDR, (0x3 << 14) | 0);	// 0x3 -- enable double_tcon fir channel1:0	
+
+    dual_wr_rd_start = 0x5d;
+    WRITE_LCD_REG(MLVDS_DUAL_GATE_WR_START, dual_wr_rd_start);
+    WRITE_LCD_REG(MLVDS_DUAL_GATE_WR_END, dual_wr_rd_start + 1280);
+    WRITE_LCD_REG(MLVDS_DUAL_GATE_RD_START, dual_wr_rd_start + ext_pixel - 2);
+    WRITE_LCD_REG(MLVDS_DUAL_GATE_RD_END, dual_wr_rd_start + 1280 + ext_pixel - 2);
+
+    WRITE_LCD_REG(MLVDS_SECOND_RESET_CTL, (pConf->lcd_control.mlvds_config->mlvds_insert_start + ext_pixel));
+
+    data32 = (0 << ((mlvds_tconfig_l[5].channel_num)+mlvds_tcon_field_en)) |  // enable EVEN_F on TCON channel 6
+             ( (0x0 << mlvds_scan_mode_odd) | (0x0 << mlvds_scan_mode_even)
+             ) | (0 << mlvds_scan_mode_start_line);
+
+	WRITE_LCD_REG(MLVDS_DUAL_GATE_CTL_HI,  (data32 >> 16));
+	WRITE_LCD_REG(MLVDS_DUAL_GATE_CTL_LO, (data32 & 0xffff));
+
+	DBG_PRINT("write minilvds tcon 0~7.\n");
+	for(i = 0; i < 8; i++) {
+		write_tcon_double(&mlvds_tconfig_l[i]);
+	}
+/*	
+	if(pConf->lcd_misc_ctrl.vpp_sel)
+		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
+	else
+		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+*/
+}
+
+static void set_lcd_spread_spectrum(int ss_level)
+{
+	unsigned pll_ctrl2, pll_ctrl3, pll_ctrl4;
+	DBG_PRINT("%s.\n", __FUNCTION__);
+	
+	switch (ss_level) {
+		case 1:  //about 0.5%
+			pll_ctrl2 = 0x16110696;
+			pll_ctrl3 = 0x6d625012;
+			pll_ctrl4 = 0x130;
+			break;
+		case 2:  //about 1%
+			pll_ctrl2 = 0x16110696;
+			pll_ctrl3 = 0x4d625012;
+			pll_ctrl4 = 0x130;
+			break;
+		case 3:  //about 2%
+			pll_ctrl2 = 0x16110696;
+			pll_ctrl3 = 0x2d425012;
+			pll_ctrl4 = 0x130;
+			break;
+		case 4:  //about 3%
+			pll_ctrl2 = 0x16110696;
+			pll_ctrl3 = 0x1d425012;
+			pll_ctrl4 = 0x130;
+			break;
+		case 5:  //about 4%
+			pll_ctrl2 = 0x16110696;
+			pll_ctrl3 = 0x0d125012;
+			pll_ctrl4 = 0x130;
+			break;
+		case 6:  //about 5%
+			pll_ctrl2 = 0x16110696;
+			pll_ctrl3 = 0x0e425012;
+			pll_ctrl4 = 0x130;
+			break;
+		case 0:	//disable ss
+		default:
+			pll_ctrl2 = 0x814d3928;
+			pll_ctrl3 = 0x6b425012;
+			pll_ctrl4 = 0x110;
+			break;
+	}
+
+	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL2, pll_ctrl2);
+	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL3, pll_ctrl3);
+	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL4, pll_ctrl4);
+}
+
+static void vclk_set_lcd(int lcd_type, unsigned long pll_reg, unsigned long vid_div_reg, unsigned int clk_ctrl_reg)
+{
+	unsigned xd = 0;
+	int wait_loop = PLL_WAIT_LOCK_CNT;
+	unsigned pll_lock = 0;
+	unsigned long flags = 0;
+	spin_lock_irqsave(&lcd_clk_lock, flags);
+	
+	DBG_PRINT("%s.\n", __FUNCTION__);
+
+	vid_div_reg = ((vid_div_reg & 0x1ffff) | (1 << 16) | (1 << 15) | (0x3 << 0));	//select vid2_pll and enable clk
+	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xf;
+	
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 19, 1);	//disable vclk2_en 
+	udelay(2);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_PLL_CNTL, 1, 29, 1);	//reset pll
+	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL, pll_reg|(1<<PLL_CTRL_RST));
+	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL2, 0x814d3928 );
+	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL3, 0x6b425012 );
+	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL4, 0x110 );
+	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL, pll_reg );
+	do{
+		udelay(50);
+		pll_lock = (READ_LCD_CBUS_REG(HHI_VIID_PLL_CNTL) >> PLL_CTRL_LOCK) & 0x1;
+		wait_loop--;
+	}while((pll_lock == 0) && (wait_loop > 0));
+	if (wait_loop == 0)
+		printk("[error]: vid2_pll lock failed\n");
+
+	//pll_div2
+	WRITE_LCD_CBUS_REG(HHI_VIID_DIVIDER_CNTL, vid_div_reg);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 7, 1);    //0x104c[7]:SOFT_RESET_POST
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 3, 1);    //0x104c[3]:SOFT_RESET_PRE
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 1, 1);    //0x104c[1]:RESET_N_POST
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 0, 1);    //0x104c[0]:RESET_N_PRE
+	udelay(5);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 3, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 7, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 3, 0, 2);
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, (xd-1), 0, 8);	// setup the XD divider value
+	udelay(5);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 4, 16, 3);	// Bit[18:16] - v2_cntl_clk_in_sel
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 19, 1);	//vclk2_en0
+	udelay(2);
+
+	if(lcd_type == LCD_DIGITAL_TTL)
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_DIV, 8, 20, 4); // [23:20] enct_clk_sel, select v2_clk_div1
+	else
+		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 8, 12, 4); // [23:20] encl_clk_sel, select v2_clk_div1
+
+	//WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 1, 16, 2); // release vclk2_div_reset and enable vclk2_div ??
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 0, 1);	//enable v2_clk_div1
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 15, 1);  //soft reset
+	udelay(10);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 15, 1);  //release soft reset
+	udelay(5);
+	
+	spin_unlock_irqrestore(&lcd_clk_lock, flags);
+}
+
+static void clk_util_lvds_set_clk_div(unsigned long divn_sel, unsigned long divn_tcnt, unsigned long div2_en)
+{
+    // assign          lvds_div_phy_clk_en     = tst_lvds_tmode ? 1'b1         : phy_clk_cntl[10];
+    // assign          lvds_div_div2_sel       = tst_lvds_tmode ? atest_i[5]   : phy_clk_cntl[9];
+    // assign          lvds_div_sel            = tst_lvds_tmode ? atest_i[7:6] : phy_clk_cntl[8:7];
+    // assign          lvds_div_tcnt           = tst_lvds_tmode ? 3'd6         : phy_clk_cntl[6:4];
+    // If dividing by 1, just select the divide by 1 path
+	if( divn_tcnt == 1 )
+		divn_sel = 0;
+
+	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 10, 1);
+	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, divn_sel, 7, 2);
+	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, div2_en, 9, 1);
+	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, ((divn_tcnt-1)&0x7), 4, 3);
+}
+
+static void set_pll_lcd(Lcd_Config_t *pConf)
+{
+    unsigned pll_reg, div_reg, clk_reg;
+    int xd;
+    int lcd_type, ss_level;
+    unsigned pll_div_post = 0, phy_clk_div2 = 0;
+
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    pll_reg = pConf->lcd_timing.pll_ctrl;
+    div_reg = pConf->lcd_timing.div_ctrl;
+    clk_reg = pConf->lcd_timing.clk_ctrl;
+    ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
+    xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
+
+    lcd_type = pConf->lcd_basic.lcd_type;
+
+    switch(lcd_type){
+        case LCD_DIGITAL_LVDS:
+            xd = 1;
+            pll_div_post = 7;
+            phy_clk_div2 = 0;
+            div_reg = (div_reg | (1 << DIV_CTRL_POST_SEL) | (1 << DIV_CTRL_LVDS_CLK_EN) | ((pll_div_post-1) << DIV_CTRL_DIV_POST) | (phy_clk_div2 << DIV_CTRL_PHY_CLK_DIV2));
+            break;
+        case LCD_DIGITAL_TTL:
+            break;
+        default:
+            break;
+    }
+    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
+
+    DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
+    vclk_set_lcd(lcd_type, pll_reg, div_reg, clk_reg);
+    set_lcd_spread_spectrum(ss_level);
+
+    switch(lcd_type){
+        case LCD_DIGITAL_LVDS:
+            clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
+            //    lvds_gen_cntl       <= {10'h0,      // [15:4] unused
+            //                            2'h1,       // [5:4] divide by 7 in the PHY
+            //                            1'b0,       // [3] fifo_en
+            //                            1'b0,       // [2] wr_bist_gate
+            //                            2'b00};     // [1:0] fifo_wr mode
+            //FIFO_CLK_SEL = 1; // div7
+            WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 4, 2);	//lvds fifo clk div 7
+
+            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 0, 15, 1);	// lvds div reset
+            udelay(5);
+            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 15, 1);	// Release lvds div reset
+            break;
+        case LCD_DIGITAL_TTL:
+            break;
+        default:
+            break;
+    }
+}
+
+static void set_pll_mlvds(Lcd_Config_t *pConf)
+{
+    int test_bit_num = pConf->lcd_basic.lcd_bits;
+    int test_dual_gate = pConf->lcd_control.mlvds_config->test_dual_gate;
+    int test_pair_num= pConf->lcd_control.mlvds_config->test_pair_num;
+	
+    int pll_div_post, phy_clk_div2, FIFO_CLK_SEL, MPCLK_DELAY, MCLK_half, MCLK_half_delay;
+    unsigned int data32;
+    unsigned long mclk_pattern_dual_6_6;
+    int test_high_phase = (test_bit_num != 8) | test_dual_gate;
+    unsigned long rd_data;
+
+    unsigned pll_reg, div_reg, clk_reg;
+    int xd;
+	int lcd_type, ss_level;
+	
+	DBG_PRINT("%s\n", __FUNCTION__);
+	
+    pll_reg = pConf->lcd_timing.pll_ctrl;
+    div_reg = pConf->lcd_timing.div_ctrl;
+	clk_reg = pConf->lcd_timing.clk_ctrl;
+	ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
+	xd = 1;
+	
+	lcd_type = pConf->lcd_basic.lcd_type;
+
+	switch(pConf->lcd_control.mlvds_config->TL080_phase) {
+		case 0 :
+			mclk_pattern_dual_6_6 = 0xc3c3c3;
+			MCLK_half = 1;
+			break;
+		case 1 :
+			mclk_pattern_dual_6_6 = 0xc3c3c3;
+			MCLK_half = 0;
+			break;
+		case 2 :
+			mclk_pattern_dual_6_6 = 0x878787;
+			MCLK_half = 1;
+			break;
+		case 3 :
+			mclk_pattern_dual_6_6 = 0x878787;
+			MCLK_half = 0;
+			break;
+		case 4 :
+			mclk_pattern_dual_6_6 = 0x3c3c3c;
+			MCLK_half = 1;
+			break;
+		case 5 :
+			mclk_pattern_dual_6_6 = 0x3c3c3c;
+			MCLK_half = 0;
+			break;
+		case 6 :
+			mclk_pattern_dual_6_6 = 0x787878;
+			MCLK_half = 1;
+			break;
+		default : // case 7
+			mclk_pattern_dual_6_6 = 0x787878;
+			MCLK_half = 0;
+			break;
+	}
+
+	pll_div_post = (test_bit_num == 8) ?
+					(test_dual_gate ? 4 : 8) :
+					(test_dual_gate ? 3 : 6);
+
+    phy_clk_div2 = (test_pair_num != 3);
+	
+	div_reg = (div_reg | (1 << DIV_CTRL_POST_SEL) | (1 << DIV_CTRL_LVDS_CLK_EN) | ((pll_div_post-1) << DIV_CTRL_DIV_POST) | (phy_clk_div2 << DIV_CTRL_PHY_CLK_DIV2));
+	clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
+	DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
+	vclk_set_lcd(lcd_type, pll_reg, div_reg, clk_reg);
+	set_lcd_spread_spectrum(ss_level);
+	
+	clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
+	
+	//enable v2_clk div
+    // WRITE_LCD_CBUS_REG(HHI_VIID_CLK_CNTL, READ_LCD_CBUS_REG(HHI_VIID_CLK_CNTL) | (0xF << 0) );
+    // WRITE_LCD_CBUS_REG(HHI_VID_CLK_CNTL, READ_LCD_CBUS_REG(HHI_VID_CLK_CNTL) | (0xF << 0) );
+
+    WRITE_LCD_REG(LVDS_PHY_CNTL0, 0xffff );
+
+    //    lvds_gen_cntl       <= {10'h0,      // [15:4] unused
+    //                            2'h1,       // [5:4] divide by 7 in the PHY
+    //                            1'b0,       // [3] fifo_en
+    //                            1'b0,       // [2] wr_bist_gate
+    //                            2'b00};     // [1:0] fifo_wr mode
+
+    FIFO_CLK_SEL = (test_bit_num == 8) ? 2 : // div8
+                                    0 ; // div6
+    rd_data = READ_LCD_REG(LVDS_GEN_CNTL);
+    rd_data = (rd_data & 0xffcf) | (FIFO_CLK_SEL<< 4);
+    WRITE_LCD_REG(LVDS_GEN_CNTL, rd_data);
+
+    MPCLK_DELAY = (test_pair_num == 6) ?
+                  ((test_bit_num == 8) ? (test_dual_gate ? 5 : 3) : 2) :
+                  ((test_bit_num == 8) ? 3 : 3) ;
+
+	MCLK_half_delay = pConf->lcd_control.mlvds_config->phase_select ? MCLK_half :
+																			(test_dual_gate & (test_bit_num == 8) & (test_pair_num != 6));
+
+    if(test_high_phase)
+    {
+        if(test_dual_gate)
+        data32 = (MPCLK_DELAY << mpclk_dly) |
+                 (((test_bit_num == 8) ? 3 : 2) << mpclk_div) |
+                 (1 << use_mpclk) |
+                 (MCLK_half_delay << mlvds_clk_half_delay) |
+                 (((test_bit_num == 8) ? (
+                                           (test_pair_num == 6) ? 0x999999 : // DIV4
+                                                                  0x555555   // DIV2
+                                         ) :
+                                         (
+                                           (test_pair_num == 6) ? mclk_pattern_dual_6_6 : //DIV8
+                                                                  0x999999   // DIV4
+                                         )
+                 ) << mlvds_clk_pattern);
+        else if(test_bit_num == 8)
+            data32 = (MPCLK_DELAY << mpclk_dly) |
+                     (((test_bit_num == 8) ? 3 : 2) << mpclk_div) |
+                     (1 << use_mpclk) |
+                     (0 << mlvds_clk_half_delay) |
+                     (0xc3c3c3 << mlvds_clk_pattern);      // DIV 8
+        else
+            data32 = (MPCLK_DELAY << mpclk_dly) |
+                     (((test_bit_num == 8) ? 3 : 2) << mpclk_div) |
+                     (1 << use_mpclk) |
+                     (0 << mlvds_clk_half_delay) |
+                     (
+                       (
+                         (test_pair_num == 6) ? 0xc3c3c3 : // DIV8
+                                                0x999999   // DIV4
+                       ) << mlvds_clk_pattern
+                     );
+    }
+    else {
+        if(test_pair_num == 6) {
+            data32 = (MPCLK_DELAY << mpclk_dly) |
+                     (((test_bit_num == 8) ? 3 : 2) << mpclk_div) |
+                     (1 << use_mpclk) |
+                     (0 << mlvds_clk_half_delay) |
+                     (
+                       (
+                         (test_pair_num == 6) ? 0x999999 : // DIV4
+                                                0x555555   // DIV2
+                       ) << mlvds_clk_pattern
+                     );
+        }
+        else {
+            data32 = (1 << mlvds_clk_half_delay) |
+                   (0x555555 << mlvds_clk_pattern);      // DIV 2
+        }
+    }
+
+    WRITE_LCD_REG(MLVDS_CLK_CTL_HI, (data32 >> 16));
+    WRITE_LCD_REG(MLVDS_CLK_CTL_LO, (data32 & 0xffff));
+
+	//pll2_div_sel
+	// Set Soft Reset vid_pll_div_pre
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 3, 1);
+	// Set Hard Reset vid_pll_div_post
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 1, 1);
+	// Set Hard Reset lvds_phy_ser_top
+	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 0, 15, 1);
+	// Release Hard Reset lvds_phy_ser_top
+	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 15, 1);
+	// Release Hard Reset vid_pll_div_post
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 1, 1);
+	// Release Soft Reset vid_pll_div_pre
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 3, 1);
+}
+
+static void set_venc_ttl(Lcd_Config_t *pConf)
+{
+    DBG_PRINT("%s\n", __FUNCTION__);
+    WRITE_LCD_REG(ENCT_VIDEO_EN,		0);
+#ifdef CONFIG_AM_TV_OUTPUT2
+    if(pConf->lcd_misc_ctrl.vpp_sel)
+        WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 3, 2, 2);
+    else
+        WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 3, 0, 2);//viu1 select enct
+#else
+    WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0xf, 0, 4);;	//viu1, viu2 select encl
+#endif
+    WRITE_LCD_REG(ENCT_VIDEO_MODE,        0);
+    WRITE_LCD_REG(ENCT_VIDEO_MODE_ADV,    0x0008);
+
+    WRITE_LCD_REG(ENCT_VIDEO_FILT_CTRL,    0x1000);  // bypass filter
+
+    WRITE_LCD_REG(ENCT_VIDEO_MAX_PXCNT,    pConf->lcd_basic.h_period - 1);
+    WRITE_LCD_REG(ENCT_VIDEO_MAX_LNCNT,    pConf->lcd_basic.v_period - 1);
+
+    WRITE_LCD_REG(ENCT_VIDEO_HAVON_BEGIN,  pConf->lcd_timing.video_on_pixel);
+    WRITE_LCD_REG(ENCT_VIDEO_HAVON_END,    pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
+    WRITE_LCD_REG(ENCT_VIDEO_VAVON_BLINE,  pConf->lcd_timing.video_on_line);
+    WRITE_LCD_REG(ENCT_VIDEO_VAVON_ELINE,  pConf->lcd_basic.v_active - 1 + pConf->lcd_timing.video_on_line);
+
+    WRITE_LCD_REG(ENCT_VIDEO_HSO_BEGIN,    15);
+    WRITE_LCD_REG(ENCT_VIDEO_HSO_END,      31);
+    WRITE_LCD_REG(ENCT_VIDEO_VSO_BEGIN,    15);
+    WRITE_LCD_REG(ENCT_VIDEO_VSO_END,      31);
+    WRITE_LCD_REG(ENCT_VIDEO_VSO_BLINE,    0);
+    WRITE_LCD_REG(ENCT_VIDEO_VSO_ELINE,    2);
+
+    WRITE_LCD_REG(ENCT_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
+
+    WRITE_LCD_REG(ENCT_VIDEO_EN,           1);  // enable enct
+}
+
+static void set_venc_lvds(Lcd_Config_t *pConf)
+{
+	DBG_PRINT("%s\n",__FUNCTION__);
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
+#ifdef CONFIG_AM_TV_OUTPUT2
+	if	(pConf->lcd_misc_ctrl.vpp_sel) {
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2, 2); //viu2 select encl
+	}
+	else {
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);//viu1 select encl
+	}
+#else
+	WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 4);;	//viu1, viu2 select encl
+#endif
+	
+	WRITE_LCD_REG(ENCL_VIDEO_MODE,			0);
+	WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV,		0x8); // Sampling rate: 1
+
+	WRITE_LCD_REG(ENCL_VIDEO_FILT_CTRL,		0x1000); // bypass filter
+
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_PXCNT,		pConf->lcd_basic.h_period - 1);
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_LNCNT,		pConf->lcd_basic.v_period - 1);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_BEGIN,	pConf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_END,		pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_BLINE,	pConf->lcd_timing.video_on_line);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_ELINE,	pConf->lcd_basic.v_active - 1  + pConf->lcd_timing.video_on_line);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_BEGIN,   0);//pConf->lcd_timing.hs_hs_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_END,     10);//pConf->lcd_timing.hs_he_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BEGIN,   0);//pConf->lcd_timing.vs_hs_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_END,     0);//pConf->lcd_timing.vs_he_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE,   0);//pConf->lcd_timing.vs_vs_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,   2);//pConf->lcd_timing.vs_ve_addr);
+
+	WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN,			1);	// enable encl
+}
+
+static void set_venc_mlvds(Lcd_Config_t *pConf)
+{
+    int ext_pixel = pConf->lcd_control.mlvds_config->test_dual_gate ? pConf->lcd_control.mlvds_config->total_line_clk : 0;
+	int active_h_start = pConf->lcd_timing.video_on_pixel;
+	int active_v_start = pConf->lcd_timing.video_on_line;
+	int width = pConf->lcd_basic.h_active;
+	int height = pConf->lcd_basic.v_active;
+	int max_height = pConf->lcd_basic.v_period;
+	
+	DBG_PRINT("%s\n", __FUNCTION__);
+
+    WRITE_LCD_REG(ENCL_VIDEO_EN,           0);
+
+#ifdef CONFIG_AM_TV_OUTPUT2
+    if(pConf->lcd_misc_ctrl.vpp_sel){
+        WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2, 2);	//viu2 select encl
+    }
+    else{
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);//viu1 select encl
+    }
+#else
+    WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 4);;	//viu1, viu2 select encl
+#endif	
+
+	WRITE_LCD_REG(ENCL_VIDEO_MODE,             0x0040 | (1<<14)); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+	WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV,         0x0008); // Sampling rate: 1
+	
+	// bypass filter
+ 	WRITE_LCD_REG(ENCL_VIDEO_FILT_CTRL,			0x1000);
+	
+	WRITE_LCD_REG(ENCL_VIDEO_YFP1_HTIME,       active_h_start);
+	WRITE_LCD_REG(ENCL_VIDEO_YFP2_HTIME,       active_h_start + width);
+
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_PXCNT,        pConf->lcd_control.mlvds_config->total_line_clk - 1 + ext_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_LNCNT,        max_height - 1);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_BEGIN,      active_h_start);
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_END,        active_h_start + width - 1);  // for dual_gate mode still read 1408 pixel at first half of line
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_BLINE,      active_v_start);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_ELINE,      active_v_start + height -1);  //15+768-1);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_BEGIN,        24);
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_END,          1420 + ext_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BEGIN,        1400 + ext_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_END,          1410 + ext_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE,        1);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,        3);
+
+	WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
+
+	// enable encl
+    WRITE_LCD_REG(ENCL_VIDEO_EN,		1);
+}
+
+static void set_control_lvds(Lcd_Config_t *pConf)
+{
+	unsigned lvds_repack, pn_swap, bit_num;
+	unsigned data32;
+	
+	DBG_PRINT("%s\n", __FUNCTION__);
+
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1); // disable lvds fifo
+	
+    data32 = (0x00 << LVDS_blank_data_r) |
+             (0x00 << LVDS_blank_data_g) |
+             (0x00 << LVDS_blank_data_b) ; 
+    WRITE_LCD_REG(LVDS_BLANK_DATA_HI, (data32 >> 16));
+    WRITE_LCD_REG(LVDS_BLANK_DATA_LO, (data32 & 0xffff));
+	
+	lvds_repack = (pConf->lcd_control.lvds_config->lvds_repack) & 0x1;
+	pn_swap = (pConf->lcd_control.lvds_config->pn_swap) & 0x1;
+
+	switch(pConf->lcd_basic.lcd_bits) {
+		case 10:
+			bit_num=0;
+			break;
+		case 8:
+			bit_num=1;
+			break;
+		case 6:
+			bit_num=2;
+			break;
+		case 4:
+			bit_num=3;
+			break;
+		default:
+			bit_num=1;
+			break;
+	}
+	
+	WRITE_LCD_REG_BITS(MLVDS_CONTROL, 0, 0, 1);  //disable mlvds
+
+	WRITE_LCD_REG(LVDS_PACK_CNTL_ADDR, 
+					( lvds_repack<<0 ) | // repack
+					( 0<<2 ) | // odd_even
+					( 0<<3 ) | // reserve
+					( 0<<4 ) | // lsb first
+					( pn_swap<<5 ) | // pn swap
+					( 0<<6 ) | // dual port
+					( 0<<7 ) | // use tcon control
+					( bit_num<<8 ) | // 0:10bits, 1:8bits, 2:6bits, 3:4bits.
+					( 0<<10 ) | //r_select  //0:R, 1:G, 2:B, 3:0
+					( 1<<12 ) | //g_select  //0:R, 1:G, 2:B, 3:0
+					( 2<<14 ));  //b_select  //0:R, 1:G, 2:B, 3:0; 
+				   
+    WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 0, 1);  //fifo enable
+	//WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1);  //enable fifo
+}
+
+static void set_control_ttl(Lcd_Config_t *pConf)
+{
+	unsigned rb_port_swap, rgb_bit_swap;
+	
+	rb_port_swap = (unsigned)(pConf->lcd_control.ttl_config->rb_swap);
+	rgb_bit_swap = (unsigned)(pConf->lcd_control.ttl_config->bit_swap);
+	
+	WRITE_LCD_REG(DUAL_PORT_CNTL_ADDR, (rb_port_swap << LCD_RGB_SWP) | (rgb_bit_swap << LCD_BIT_SWP));
+}
+
+static void set_control_mlvds(Lcd_Config_t *pConf)
+{
+	int test_bit_num = pConf->lcd_basic.lcd_bits;
+    int test_pair_num = pConf->lcd_control.mlvds_config->test_pair_num;
+    int test_dual_gate = pConf->lcd_control.mlvds_config->test_dual_gate;
+    int scan_function = pConf->lcd_control.mlvds_config->scan_function;     //0:U->D,L->R  //1:D->U,R->L
+    int mlvds_insert_start;
+    unsigned int reset_offset;
+    unsigned int reset_length;
+
+    unsigned long data32;
+	
+	DBG_PRINT("%s\n", __FUNCTION__);
+    
+    mlvds_insert_start = test_dual_gate ?
+                           ((test_bit_num == 8) ? ((test_pair_num == 6) ? 0x9f : 0xa9) :
+                                                  ((test_pair_num == 6) ? pConf->lcd_control.mlvds_config->mlvds_insert_start : 0xa7)
+                           ) :
+                           (
+                             (test_pair_num == 6) ? ((test_bit_num == 8) ? 0xa9 : 0xa7) :
+                                                    ((test_bit_num == 8) ? 0xae : 0xad)
+                           );
+
+    // Enable the LVDS PHY (power down bits)
+	WRITE_LCD_REG_BITS(LVDS_PHY_CNTL1, 0x7f, 8, 7);
+
+    data32 = (0x00 << LVDS_blank_data_r) |
+             (0x00 << LVDS_blank_data_g) |
+             (0x00 << LVDS_blank_data_b) ;
+    WRITE_LCD_REG(LVDS_BLANK_DATA_HI,  (data32 >> 16));
+    WRITE_LCD_REG(LVDS_BLANK_DATA_LO, (data32 & 0xffff));
+
+    data32 = 0x7fffffff; //  '0'x1 + '1'x32 + '0'x2
+    WRITE_LCD_REG(MLVDS_RESET_PATTERN_HI,  (data32 >> 16));
+    WRITE_LCD_REG(MLVDS_RESET_PATTERN_LO, (data32 & 0xffff));
+    data32 = 0x8000; // '0'x1 + '1'x32 + '0'x2
+    WRITE_LCD_REG(MLVDS_RESET_PATTERN_EXT,  (data32 & 0xffff));
+
+    reset_length = 1+32+2;
+    reset_offset = test_bit_num - (reset_length%test_bit_num);
+
+    data32 = (reset_offset << mLVDS_reset_offset) |
+             (reset_length << mLVDS_reset_length) |
+             ((test_pair_num == 6) << mLVDS_data_write_toggle) |
+             ((test_pair_num != 6) << mLVDS_data_write_ini) |
+             ((test_pair_num == 6) << mLVDS_data_latch_1_toggle) |
+             (0 << mLVDS_data_latch_1_ini) |
+             ((test_pair_num == 6) << mLVDS_data_latch_0_toggle) |
+             (1 << mLVDS_data_latch_0_ini) |
+             ((test_pair_num == 6) << mLVDS_reset_1_select) |
+             (mlvds_insert_start << mLVDS_reset_start);
+    WRITE_LCD_REG(MLVDS_CONFIG_HI, (data32 >> 16));
+    WRITE_LCD_REG(MLVDS_CONFIG_LO, (data32 & 0xffff));
+
+    data32 = (1 << mLVDS_double_pattern) |  //POL double pattern
+			 (0x3f << mLVDS_ins_reset) |
+             (test_dual_gate << mLVDS_dual_gate) |
+             ((test_bit_num == 8) << mLVDS_bit_num) |
+             ((test_pair_num == 6) << mLVDS_pair_num) |
+             (0 << mLVDS_msb_first) |
+             (0 << mLVDS_PORT_SWAP) |
+             ((scan_function==1 ? 1:0) << mLVDS_MLSB_SWAP) |
+             (0 << mLVDS_PN_SWAP) |
+             (1 << mLVDS_en);
+    WRITE_LCD_REG(MLVDS_CONTROL,  (data32 & 0xffff));
+
+    WRITE_LCD_REG(LVDS_PACK_CNTL_ADDR,
+                   ( 0 ) | // repack
+                   ( 0<<2 ) | // odd_even
+                   ( 0<<3 ) | // reserve
+                   ( 0<<4 ) | // lsb first
+                   ( 0<<5 ) | // pn swap
+                   ( 0<<6 ) | // dual port
+                   ( 0<<7 ) | // use tcon control
+                   ( 1<<8 ) | // 0:10bits, 1:8bits, 2:6bits, 3:4bits.
+                   ( (scan_function==1 ? 2:0)<<10 ) |  //r_select // 0:R, 1:G, 2:B, 3:0
+                   ( 1<<12 ) |                        //g_select
+                   ( (scan_function==1 ? 0:2)<<14 ));  //b_select
+
+    WRITE_LCD_REG(L_POL_CNTL_ADDR,  (1 << LCD_DCLK_SEL) |
+       //(0x1 << LCD_HS_POL) |
+       (0x1 << LCD_VS_POL)
+    );
+	
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1); // enable fifo
+}
+
+static void init_phy_lvds(Lcd_Config_t *pConf)
+{
+    unsigned swing_ctrl;
+    DBG_PRINT("%s\n", __FUNCTION__);
+	
+    WRITE_LCD_REG(LVDS_PHY_CNTL3, 0xee1);
+    WRITE_LCD_REG(LVDS_PHY_CNTL4 ,0);
+
+	switch (pConf->lcd_control.lvds_config->lvds_vswing) {
+		case 0:
+			swing_ctrl = 0xaf20;
+			break;
+		case 1:
+			swing_ctrl = 0xaf40;
+			break;
+		case 2:
+			swing_ctrl = 0xa840;
+			break;
+		case 3:
+			swing_ctrl = 0xa880;
+			break;
+		case 4:
+			swing_ctrl = 0xa8c0;
+			break;
+		default:
+			swing_ctrl = 0xaf40;
+			break;
+	}
+	WRITE_LCD_REG(LVDS_PHY_CNTL5, swing_ctrl);
+
+	WRITE_LCD_REG(LVDS_PHY_CNTL0,0x001f);
+	WRITE_LCD_REG(LVDS_PHY_CNTL1,0xffff);
+
+    WRITE_LCD_REG(LVDS_PHY_CNTL6,0xcccc);
+    WRITE_LCD_REG(LVDS_PHY_CNTL7,0xcccc);
+    WRITE_LCD_REG(LVDS_PHY_CNTL8,0xcccc);
+}
+
+static void set_video_adjust(Lcd_Config_t *pConf)
+{
+	DBG_PRINT("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x.\n", pConf->lcd_effect.vadj_brightness, pConf->lcd_effect.vadj_contrast, pConf->lcd_effect.vadj_saturation);
+	WRITE_LCD_REG(VPP_VADJ2_Y, (pConf->lcd_effect.vadj_brightness << 8) | (pConf->lcd_effect.vadj_contrast << 0));
+	WRITE_LCD_REG(VPP_VADJ2_MA_MB, (pConf->lcd_effect.vadj_saturation << 16));
+	WRITE_LCD_REG(VPP_VADJ2_MC_MD, (pConf->lcd_effect.vadj_saturation << 0));
+	WRITE_LCD_REG(VPP_VADJ_CTRL, 0xf);	//enable video adjust
+}
+
+static void switch_lcd_gates(Lcd_Type_t lcd_type)
+{
+	switch(lcd_type){
+		case LCD_DIGITAL_TTL:
+			switch_mod_gate_by_name("tcon", 1);
+			switch_mod_gate_by_name("lvds", 0);
+			break;
+		case LCD_DIGITAL_LVDS:
+		case LCD_DIGITAL_MINILVDS:
+			switch_mod_gate_by_name("lvds", 1);
+			switch_mod_gate_by_name("tcon", 0);
+			break;
+		default:
+			break;
+	}
+}
+
+static void _init_lcd_driver(Lcd_Config_t *pConf)
+{
+    int lcd_type = pConf->lcd_basic.lcd_type;
+    unsigned char ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
+
+    print_lcd_driver_version();
+    switch_lcd_gates(lcd_type);
+
+    printk("Init LCD mode: %s, %s(%u) %ubit, %ux%u@%u.%uHz, ss_level=%u(%s)\n", pConf->lcd_basic.model_name, lcd_type_table[lcd_type], lcd_type, pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10), ss_level, lcd_ss_level_table[ss_level]);
+
+    switch(lcd_type){
+        case LCD_DIGITAL_LVDS:
+            set_pll_lcd(pConf);
+            set_venc_lvds(pConf);
+            set_tcon_lvds(pConf);
+            set_control_lvds(pConf);
+            init_phy_lvds(pConf);
+            break;
+        case LCD_DIGITAL_TTL:
+            set_pll_lcd(pConf);
+            set_venc_ttl(pConf);
+            set_tcon_ttl(pConf);
+            set_control_ttl(pConf);
+            break;
+        case LCD_DIGITAL_MINILVDS:
+            set_pll_mlvds(pConf);
+            set_venc_mlvds(pConf);
+            set_tcon_mlvds(pConf);
+            set_control_mlvds(pConf);
+            init_phy_lvds(pConf);
+            break;
+        default:
+            printk("Invalid LCD type.\n");
+            break;
+    }
+    set_video_adjust(pConf);
+    printk("%s finished.\n", __FUNCTION__);
+}
+
+static void _disable_lcd_driver(Lcd_Config_t *pConf)
+{
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 11, 1);	//close lvds phy clk gate: 0x104c[11]
+    WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
+
+    WRITE_LCD_REG(ENCT_VIDEO_EN, 0);	//disable enct
+    WRITE_LCD_REG(ENCL_VIDEO_EN, 0);	//disable encl
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 0, 5);	//close vclk2 gate: 0x104b[4:0]
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 16, 1);	//close vid2_pll gate: 0x104c[16]
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_PLL_CNTL, 1, 30, 1);		//power down vid2_pll: 0x1047[30]
+
+    switch_mod_gate_by_name("tcon", 0);
+    switch_mod_gate_by_name("lvds", 0);
+    printk("disable lcd display driver.\n");
+}
+
+static void _enable_vsync_interrupt(void)
+{
+	if ((READ_LCD_REG(ENCT_VIDEO_EN) & 1) || (READ_LCD_REG(ENCL_VIDEO_EN) & 1)) {
+		WRITE_LCD_REG(VENC_INTCTRL, 0x200);
+	}
+	else{
+		WRITE_LCD_REG(VENC_INTCTRL, 0x2);
+	}
+}
+
+static void lcd_test(unsigned num)
+{
+	unsigned venc_video_mode, venc_test_base;
+	
+	if (lcd_Conf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
+		venc_video_mode = ENCT_VIDEO_MODE_ADV;
+		venc_test_base = ENCT_TST_EN;
+	}
+	else {
+		venc_video_mode = ENCL_VIDEO_MODE_ADV;
+		venc_test_base = ENCL_TST_EN;
+	}
+	
+	switch (num) {
+		case 0:
+			WRITE_LCD_REG(venc_video_mode, 0x8);
+			printk("disable bist pattern\n");
+			break;
+		case 1:
+			WRITE_LCD_REG(venc_video_mode, 0);
+			WRITE_LCD_REG((venc_test_base+1), 1);
+			WRITE_LCD_REG((venc_test_base+5), lcd_Conf->lcd_timing.video_on_pixel);
+			WRITE_LCD_REG((venc_test_base+6), (lcd_Conf->lcd_basic.h_active / 9));
+			WRITE_LCD_REG(venc_test_base, 1);
+			printk("show bist pattern 1: Color Bar\n");
+			break;
+		case 2:
+			WRITE_LCD_REG(venc_video_mode, 0);
+			WRITE_LCD_REG((venc_test_base+1), 2);
+			WRITE_LCD_REG(venc_test_base, 1);
+			printk("show bist pattern 2: Thin Line\n");
+			break;
+		case 3:
+			WRITE_LCD_REG(venc_video_mode, 0);
+			WRITE_LCD_REG((venc_test_base+1), 3);
+			WRITE_LCD_REG(venc_test_base, 1);
+			printk("show bist pattern 3: Dot Grid\n");
+			break;
+		case 4:
+			WRITE_LCD_REG(venc_video_mode, 0);
+			WRITE_LCD_REG((venc_test_base+1), 0);
+			WRITE_LCD_REG((venc_test_base+2), 0x3ff);
+			WRITE_LCD_REG((venc_test_base+3), 0x200);
+			WRITE_LCD_REG((venc_test_base+4), 0x200);
+			WRITE_LCD_REG(venc_test_base, 1);
+			printk("show test pattern 4: White\n");
+			break;
+		case 5:
+			WRITE_LCD_REG(venc_video_mode, 0);
+			WRITE_LCD_REG((venc_test_base+1), 0);
+			WRITE_LCD_REG((venc_test_base+2), 0);
+			WRITE_LCD_REG((venc_test_base+3), 0);
+			WRITE_LCD_REG((venc_test_base+4), 0x3ff);
+			WRITE_LCD_REG(venc_test_base, 1);
+			printk("show test pattern 5: Red\n");
+			break;
+		case 6:
+			WRITE_LCD_REG(venc_video_mode, 0);
+			WRITE_LCD_REG((venc_test_base+1), 0);
+			WRITE_LCD_REG((venc_test_base+2), 0x3ff);
+			WRITE_LCD_REG((venc_test_base+3), 0);
+			WRITE_LCD_REG((venc_test_base+4), 0);
+			WRITE_LCD_REG(venc_test_base, 1);
+			printk("show test pattern 6: Green\n");
+			break;
+		case 7:
+			WRITE_LCD_REG(venc_video_mode, 0);
+			WRITE_LCD_REG((venc_test_base+1), 0);
+			WRITE_LCD_REG((venc_test_base+2), 0);
+			WRITE_LCD_REG((venc_test_base+3), 0x3ff);
+			WRITE_LCD_REG((venc_test_base+4), 0);
+			WRITE_LCD_REG(venc_test_base, 1);
+			printk("show test pattern 7: Blue\n");
+			break;
+		default:
+			printk("un-support pattern num\n");
+			break;
+	}
+}
+
+static DEFINE_MUTEX(lcd_init_mutex);
+static void lcd_module_enable(void)
+{
+	mutex_lock(&lcd_init_mutex);
+
+	_init_lcd_driver(lcd_Conf);
+	lcd_Conf->lcd_power_ctrl.power_ctrl(ON);
+	_enable_vsync_interrupt();
+	lcd_Conf->lcd_misc_ctrl.lcd_status = 1;
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static void lcd_module_disable(void)
+{
+	mutex_lock(&lcd_init_mutex);
+	lcd_Conf->lcd_misc_ctrl.lcd_status = 0;
+	lcd_Conf->lcd_power_ctrl.power_ctrl(OFF);
+	_disable_lcd_driver(lcd_Conf);
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static unsigned error_abs(unsigned num1, unsigned num2)
+{
+	if (num1 >= num2)
+		return num1 - num2;
+	else
+		return num2 - num1;
+}
+
+static void generate_clk_parameter(Lcd_Config_t *pConf)
+{
+    unsigned pll_n = 0, pll_m = 0, pll_od = 0;
+    unsigned vid_div_pre = 0, crt_xd = 0;
+
+    unsigned m, n, od, div_pre, div_post, xd;
+    unsigned od_sel, pre_div_sel;
+    unsigned div_pre_sel_max, crt_xd_max;
+    unsigned f_ref, pll_vco, fout_pll, div_pre_out, div_post_out, final_freq, iflogic_vid_clk_in_max;
+    unsigned min_error = MAX_ERROR;
+    unsigned error = MAX_ERROR;
+    unsigned clk_num = 0;
+    unsigned fin = FIN_FREQ;
+    unsigned fout = pConf->lcd_timing.lcd_clk;
+
+    if (fout >= 200) {//clk
+        fout = fout / 1000;  //kHz
+    }
+    else {//frame_rate
+        fout = (fout * pConf->lcd_basic.h_period * pConf->lcd_basic.v_period) / 1000;	//kHz
+    }
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_LVDS:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 7;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = LVDS_MAX_VID_CLK_IN;
+            break;
+        case LCD_DIGITAL_TTL:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = CRT_VID_DIV_MAX;
+            iflogic_vid_clk_in_max = TTL_MAX_VID_CLK_IN;
+            break;
+        case LCD_DIGITAL_MINILVDS:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 6;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = MLVDS_MAX_VID_CLK_IN;
+            break;
+        default:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = LCD_VENC_MAX_CLK_IN;
+            break;
+    }
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_LVDS:
+        case LCD_DIGITAL_TTL:
+            for (n = PLL_N_MIN; n <= PLL_N_MAX; n++) {
+                f_ref = fin / n;
+                if ((f_ref >= PLL_FREF_MIN) && (f_ref <= PLL_FREF_MAX))    {
+                    for (m = PLL_M_MIN; m <= PLL_M_MAX; m++) {
+                        pll_vco = f_ref * m;
+                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
+                            for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
+                                od = od_table[od_sel - 1];
+                                fout_pll = pll_vco / od;
+                            if (fout_pll <= DIV_PRE_MAX_CLK_IN) {
+                                    for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                                        div_pre = div_pre_table[pre_div_sel];
+                                        div_pre_out = fout_pll / div_pre;
+                                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                                            div_post_out = div_pre_out / div_post;
+                                            if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                                                for (xd = 1; xd <= crt_xd_max; xd++) {
+                                                    final_freq = div_post_out / xd;
+                                                    if (final_freq < LCD_VENC_MAX_CLK_IN) {
+                                                        if (final_freq < iflogic_vid_clk_in_max) {
+                                                            error = error_abs(final_freq, fout);
+                                                            if (error < min_error) {
+                                                                min_error = error;
+                                                                pll_m = m;
+                                                                pll_n = n;
+                                                                pll_od = od_sel - 1;
+                                                                vid_div_pre = pre_div_sel;
+                                                                crt_xd = xd;
+                                                                clk_num++;
+                                                            }
+                                                        }
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    if (clk_num > 0) {
+        pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
+        pConf->lcd_timing.div_ctrl = 0x18803 | (vid_div_pre << DIV_CTRL_DIV_PRE);
+        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (crt_xd << CLK_CTRL_XD);
+    }
+    else {
+        pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (32 << PLL_CTRL_M);
+        pConf->lcd_timing.div_ctrl = 0x18803;
+        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+        printk("Out of clock range, reset to default setting!\n");
+    }
+}
+
+static void lcd_sync_duration(Lcd_Config_t *pConf)
+{
+	unsigned m, n, od, pre_div, xd, post_div;
+	unsigned h_period, v_period, sync_duration;
+	unsigned lcd_clk;
+
+	m = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_M) & 0x1ff;
+	n = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_N) & 0x1f;
+	od = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD) & 0x3;
+	od = od_table[od];
+	pre_div = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_DIV_PRE) & 0x7;
+	pre_div = div_pre_table[pre_div];
+	
+	h_period = pConf->lcd_basic.h_period;
+	v_period = pConf->lcd_basic.v_period;
+	
+	switch(pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_LVDS:
+			xd = 1;
+			post_div = 7;
+			break;
+		case LCD_DIGITAL_TTL:
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			post_div = 1;
+			break;
+		case LCD_DIGITAL_MINILVDS:
+			xd = 1;
+			post_div = 6;
+			break;
+		default:
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			post_div = 1;
+			break;
+	}
+	
+	lcd_clk = ((m * FIN_FREQ) / (n * od * pre_div * post_div * xd)) * 1000;
+	pConf->lcd_timing.lcd_clk = lcd_clk;
+	sync_duration = ((lcd_clk / h_period) * 100) / v_period;
+	sync_duration = (sync_duration + 5) / 10;
+	
+	pConf->lcd_timing.sync_duration_num = sync_duration;
+	pConf->lcd_timing.sync_duration_den = 10;
+	printk("lcd_clk=%u.%03uMHz, frame_rate=%u.%uHz.\n\n", (lcd_clk / 1000000), ((lcd_clk / 1000) % 1000), 
+			(sync_duration / pConf->lcd_timing.sync_duration_den), ((sync_duration * 10 / pConf->lcd_timing.sync_duration_den) % 10));
+}
+
+static void lcd_tcon_config(Lcd_Config_t *pConf)
+{
+	unsigned short hstart, hend, vstart, vend;
+	unsigned short h_delay = 0;
+	unsigned short h_offset = 0, v_offset = 0, vsync_h_phase=0;
+	
+	switch (pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_LVDS:
+			h_delay = LVDS_DELAY;
+			break;
+		case LCD_DIGITAL_TTL:
+			h_delay = TTL_DELAY;
+			break;
+		default:
+			h_delay = 0;
+			break;
+	}
+#if 0
+	h_offset = (pConf->lcd_timing.h_offset & 0xffff);
+	v_offset = (pConf->lcd_timing.v_offset & 0xffff);
+	if ((pConf->lcd_timing.h_offset >> 31) & 1)
+		pConf->lcd_timing.de_hstart = (pConf->lcd_timing.video_on_pixel + pConf->lcd_basic.h_period + h_delay + h_offset) % pConf->lcd_basic.h_period;
+	else
+		pConf->lcd_timing.de_hstart = (pConf->lcd_timing.video_on_pixel + pConf->lcd_basic.h_period + h_delay - h_offset) % pConf->lcd_basic.h_period;
+	if ((pConf->lcd_timing.v_offset >> 31) & 1)
+		pConf->lcd_timing.de_vstart = (pConf->lcd_timing.video_on_line + pConf->lcd_basic.v_period + v_offset) % pConf->lcd_basic.v_period;
+	else
+		pConf->lcd_timing.de_vstart = (pConf->lcd_timing.video_on_line + pConf->lcd_basic.v_period - v_offset) % pConf->lcd_basic.v_period;
+	
+	hstart = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp) % pConf->lcd_basic.h_period;
+	hend = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp + pConf->lcd_timing.hsync_width) % pConf->lcd_basic.h_period;	
+	pConf->lcd_timing.hs_hs_addr = hstart;
+	pConf->lcd_timing.hs_he_addr = hend;
+	pConf->lcd_timing.hs_vs_addr = 0;
+	pConf->lcd_timing.hs_ve_addr = pConf->lcd_basic.v_period - 1;
+	
+	vsync_h_phase = (pConf->lcd_timing.vsync_h_phase & 0xffff);
+	if ((pConf->lcd_timing.vsync_h_phase >> 31) & 1) //negative
+		vsync_h_phase = (hstart + pConf->lcd_basic.h_period - vsync_h_phase) % pConf->lcd_basic.h_period;
+	else	//positive
+		vsync_h_phase = (hstart + pConf->lcd_basic.h_period + vsync_h_phase) % pConf->lcd_basic.h_period;
+	pConf->lcd_timing.vs_hs_addr = vsync_h_phase;
+	pConf->lcd_timing.vs_he_addr = vsync_h_phase;
+	vstart = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp) % pConf->lcd_basic.v_period;
+	vend = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp + pConf->lcd_timing.vsync_width) % pConf->lcd_basic.v_period;
+	pConf->lcd_timing.vs_vs_addr = vstart;
+	pConf->lcd_timing.vs_ve_addr = vend;
+
+	pConf->lcd_timing.de_hstart = pConf->lcd_timing.de_hstart;
+	pConf->lcd_timing.de_vstart = pConf->lcd_timing.de_vstart;
+	
+	pConf->lcd_timing.de_hs_addr = pConf->lcd_timing.de_hstart;
+	pConf->lcd_timing.de_he_addr = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_active) % pConf->lcd_basic.h_period;
+	pConf->lcd_timing.de_vs_addr = pConf->lcd_timing.de_vstart;
+	pConf->lcd_timing.de_ve_addr = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_active - 1) % pConf->lcd_basic.v_period;
+#else
+    pConf->lcd_timing.video_on_pixel = pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 -h_delay;
+    pConf->lcd_timing.video_on_line = pConf->lcd_basic.v_period - pConf->lcd_basic.v_active;
+
+    h_offset = (pConf->lcd_timing.h_offset & 0xffff);
+    v_offset = (pConf->lcd_timing.v_offset & 0xffff);
+    if ((pConf->lcd_timing.h_offset >> 31) & 1)
+        pConf->lcd_timing.de_hstart = (pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 + pConf->lcd_basic.h_period - h_offset) % pConf->lcd_basic.h_period;
+    else
+        pConf->lcd_timing.de_hstart = (pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 + h_offset) % pConf->lcd_basic.h_period;
+    if ((pConf->lcd_timing.v_offset >> 31) & 1)
+        pConf->lcd_timing.de_vstart = (pConf->lcd_basic.v_period - pConf->lcd_basic.v_active + pConf->lcd_basic.v_period - v_offset) % pConf->lcd_basic.v_period;
+    else
+        pConf->lcd_timing.de_vstart = (pConf->lcd_basic.v_period - pConf->lcd_basic.v_active + v_offset) % pConf->lcd_basic.v_period;
+
+    hstart = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp) % pConf->lcd_basic.h_period;
+    hend = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp + pConf->lcd_timing.hsync_width) % pConf->lcd_basic.h_period;	
+    pConf->lcd_timing.hs_hs_addr = hstart;
+    pConf->lcd_timing.hs_he_addr = hend;
+    pConf->lcd_timing.hs_vs_addr = 0;
+    pConf->lcd_timing.hs_ve_addr = pConf->lcd_basic.v_period - 1;
+
+    vsync_h_phase = (pConf->lcd_timing.vsync_h_phase & 0xffff);
+    if ((pConf->lcd_timing.vsync_h_phase >> 31) & 1) //negative
+        vsync_h_phase = (hstart + pConf->lcd_basic.h_period - vsync_h_phase) % pConf->lcd_basic.h_period;
+    else //positive
+        vsync_h_phase = (hstart + pConf->lcd_basic.h_period + vsync_h_phase) % pConf->lcd_basic.h_period;
+    pConf->lcd_timing.vs_hs_addr = vsync_h_phase;
+    pConf->lcd_timing.vs_he_addr = vsync_h_phase;
+    vstart = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp) % pConf->lcd_basic.v_period;
+    vend = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp + pConf->lcd_timing.vsync_width) % pConf->lcd_basic.v_period;
+    pConf->lcd_timing.vs_vs_addr = vstart;
+    pConf->lcd_timing.vs_ve_addr = vend;
+
+    pConf->lcd_timing.de_hs_addr = pConf->lcd_timing.de_hstart;
+    pConf->lcd_timing.de_he_addr = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_active) % pConf->lcd_basic.h_period;
+    pConf->lcd_timing.de_vs_addr = pConf->lcd_timing.de_vstart;
+    pConf->lcd_timing.de_ve_addr = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_active - 1) % pConf->lcd_basic.v_period;
+#endif
+
+    //DBG_PRINT("hs_hs_addr=%d, hs_he_addr=%d, hs_vs_addr=%d, hs_ve_addr=%d\n", pConf->lcd_timing.hs_hs_addr, pConf->lcd_timing.hs_he_addr, pConf->lcd_timing.hs_vs_addr, pConf->lcd_timing.hs_ve_addr);
+    //DBG_PRINT("vs_hs_addr=%d, vs_he_addr=%d, vs_vs_addr=%d, vs_ve_addr=%d\n", pConf->lcd_timing.vs_hs_addr, pConf->lcd_timing.vs_he_addr, pConf->lcd_timing.vs_vs_addr, pConf->lcd_timing.vs_ve_addr);
+    //DBG_PRINT("de_hs_addr=%d, de_he_addr=%d, de_vs_addr=%d, de_ve_addr=%d\n", pConf->lcd_timing.de_hs_addr, pConf->lcd_timing.de_he_addr, pConf->lcd_timing.de_vs_addr, pConf->lcd_timing.de_ve_addr);
+}
+
+static void lcd_control_config_pre(Lcd_Config_t *pConf)
+{
+    unsigned ss_level;
+
+    ss_level = ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf);
+    ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_LVDS:
+            if (pConf->lcd_control.lvds_config->lvds_repack_user == 0) {
+                if (pConf->lcd_basic.lcd_bits == 6)
+                    pConf->lcd_control.lvds_config->lvds_repack = 0;
+                else
+                    pConf->lcd_control.lvds_config->lvds_repack = 1;
+            }
+            break;
+        default:
+            break;
+    }
+    pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & (~(0xf << CLK_CTRL_SS))) | (ss_level << CLK_CTRL_SS));
+}
+
+#ifdef CONFIG_USE_OF
+static LVDS_Config_t lcd_lvds_config = {
+    .lvds_vswing = 1,
+    .lvds_repack_user = 0,
+    .lvds_repack = 0,
+    .pn_swap = 0,
+};
+
+static TTL_Config_t lcd_ttl_config = {
+    .rb_swap = 0,
+    .bit_swap = 0,
+};
+
+static MLVDS_Config_t lcd_mlvds_config = {
+    .mlvds_insert_start = 0x45,
+    .total_line_clk = 1448,
+    .test_dual_gate = 1,
+    .test_pair_num = 6,
+    .scan_function = 1,
+    .phase_select = 1,
+    .TL080_phase =3,
+};
+
+static Lcd_Config_t lcd_config = {
+    .lcd_timing = {
+        .lcd_clk = 40000000,
+        .clk_ctrl = ((1 << CLK_CTRL_AUTO) | (0 << CLK_CTRL_SS)),
+        .hvsync_valid = 1,
+        .de_valid = 1,
+        .pol_ctrl = ((0 << POL_CTRL_CLK) | (1 << POL_CTRL_DE) | (0 << POL_CTRL_VS) | (0 << POL_CTRL_HS)),
+    },
+    .lcd_effect = {
+        .rgb_base_addr = 0xf0,
+        .rgb_coeff_addr = 0x74a,
+        .dith_user = 0,
+        .vadj_brightness = 0x0,
+        .vadj_contrast = 0x80,
+        .vadj_saturation = 0x100,
+        .gamma_ctrl = ((0 << GAMMA_CTRL_REVERSE) | (1 << LCD_GAMMA_EN)),
+        .gamma_r_coeff = 100,
+        .gamma_g_coeff = 100,
+        .gamma_b_coeff = 100,
+        .set_gamma_table = set_gamma_table_lcd,
+    },
+    .lcd_control = {
+        .lvds_config = &lcd_lvds_config,
+        .ttl_config = &lcd_ttl_config,
+        .mlvds_config = &lcd_mlvds_config,
+    },
+    .lcd_power_ctrl = {
+        .power_on_step = 0,
+        .power_off_step = 0,
+        .power_ctrl = NULL,
+        .power_ctrl_video = NULL,
+    },
+};
+
+Lcd_Config_t* get_lcd_config(void)
+{
+    return &lcd_config;
+}
+#endif
+
+static void lcd_config_assign(Lcd_Config_t *pConf)
+{
+    pConf->lcd_power_ctrl.ports_ctrl = lcd_ports_ctrl;
+
+    pConf->lcd_misc_ctrl.vpp_sel = 0;
+    pConf->lcd_misc_ctrl.lcd_status = 1;
+    pConf->lcd_misc_ctrl.module_enable = lcd_module_enable;
+    pConf->lcd_misc_ctrl.module_disable = lcd_module_disable;
+    pConf->lcd_misc_ctrl.lcd_test = lcd_test;
+    pConf->lcd_misc_ctrl.print_version = print_lcd_driver_version;
+}
+
+void lcd_config_init(Lcd_Config_t *pConf)
+{
+    lcd_control_config_pre(pConf);
+
+    if ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1) {
+        printk("\nAuto generate clock parameters.\n");
+        generate_clk_parameter(pConf);
+        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
+    }
+    else {
+        printk("\nCustome clock parameters.\n");
+        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
+    }
+
+    lcd_sync_duration(pConf);
+    lcd_tcon_config(pConf);
+}
+
+void lcd_config_probe(Lcd_Config_t *pConf)
+{
+    spin_lock_init(&gamma_write_lock);
+    spin_lock_init(&lcd_clk_lock);
+
+    lcd_Conf = pConf;
+    lcd_config_assign(pConf);
+}
+
+void lcd_config_remove(void)
+{
+    //none
+}
diff --git a/arch/arm/mach-meson6/lcd/lcd_config.h b/arch/arm/mach-meson6/lcd/lcd_config.h
new file mode 100755
index 000000000000..7984d73d65a0
--- /dev/null
+++ b/arch/arm/mach-meson6/lcd/lcd_config.h
@@ -0,0 +1,189 @@
+
+#ifndef LCD_CONFIG_H
+#define LCD_CONFIG_H
+#include <linux/types.h>
+#include <mach/mlvds_regs.h>
+
+//**********************************
+//lcd driver version
+//**********************************
+#define LCD_DRV_TYPE      "c6"
+#define LCD_DRV_DATE      "20140703"
+//**********************************
+
+/* for GAMMA_CNTL_PORT */
+	#define LCD_GAMMA_VCOM_POL       7
+	#define LCD_GAMMA_RVS_OUT        6
+	#define LCD_ADR_RDY              5
+	#define LCD_WR_RDY               4
+	#define LCD_RD_RDY               3
+	#define LCD_GAMMA_TR             2
+	#define LCD_GAMMA_SET            1
+	#define LCD_GAMMA_EN             0
+
+/* for GAMMA_ADDR_PORT */
+	#define LCD_H_RD                 12
+	#define LCD_H_AUTO_INC           11
+	#define LCD_H_SEL_R              10
+	#define LCD_H_SEL_G              9
+	#define LCD_H_SEL_B              8
+	#define LCD_HADR_MSB             7
+	#define LCD_HADR                 0
+
+/* for POL_CNTL_ADDR */
+	#define LCD_DCLK_SEL             14  //FOR DCLK OUTPUT
+	#define LCD_TCON_VSYNC_SEL_DVI   11  // FOR RGB format DVI output
+	#define LCD_TCON_HSYNC_SEL_DVI   10  // FOR RGB format DVI output
+	#define LCD_TCON_DE_SEL_DVI      9   // FOR RGB format DVI output
+	#define LCD_CPH3_POL             8
+	#define LCD_CPH2_POL             7
+	#define LCD_CPH1_POL             6
+	#define LCD_TCON_DE_SEL          5
+	#define LCD_TCON_VS_SEL          4
+	#define LCD_TCON_HS_SEL          3
+	#define LCD_DE_POL               2
+	#define LCD_VS_POL               1
+	#define LCD_HS_POL               0
+
+/* for DITH_CNTL_ADDR */
+	#define LCD_DITH10_EN            10
+	#define LCD_DITH8_EN             9
+	#define LCD_DITH_MD              8
+	#define LCD_DITH10_CNTL_MSB      7
+	#define LCD_DITH10_CNTL          4
+	#define LCD_DITH8_CNTL_MSB       3
+	#define LCD_DITH8_CNTL           0
+
+/* for INV_CNT_ADDR */
+	#define LCD_INV_EN               4
+	#define LCD_INV_CNT_MSB          3
+	#define LCD_INV_CNT              0
+
+/* for TCON_MISC_SEL_ADDR */
+	#define LCD_STH2_SEL             12
+	#define LCD_STH1_SEL             11
+	#define LCD_OEH_SEL              10
+	#define LCD_VCOM_SEL             9
+	#define LCD_DB_LINE_SW           8
+	#define LCD_CPV2_SEL             7
+	#define LCD_CPV1_SEL             6
+	#define LCD_STV2_SEL             5
+	#define LCD_STV1_SEL             4
+	#define LCD_OEV_UNITE            3
+	#define LCD_OEV3_SEL             2
+	#define LCD_OEV2_SEL             1
+	#define LCD_OEV1_SEL             0
+
+/* for DUAL_PORT_CNTL_ADDR */
+	#define LCD_ANALOG_SEL_CPH3      8
+	#define LCD_ANALOG_3PHI_CLK_SEL  7
+	#define LCD_LVDS_SEL54           6
+	#define LCD_LVDS_SEL27           5
+	#define LCD_TTL_SEL              4
+	#define LCD_DUAL_PIXEL           3
+	#define LCD_PORT_SWP             2
+	#define LCD_RGB_SWP              1
+	#define LCD_BIT_SWP              0
+
+/* for LVDS_PACK_CNTL_ADDR */
+	#define LCD_LD_CNT_MSB           7
+	#define LCD_LD_CNT               5
+	#define LCD_PN_SWP               4
+	#define LCD_RES                  3
+	#define LCD_LVDS_PORT_SWP        2
+	#define LCD_PACK_RVS             1
+	#define LCD_PACK_LITTLE          0
+
+ /* for LVDS_BLANK_DATA */  
+	#define LVDS_blank_data_reserved    30  // 31:30
+	#define LVDS_blank_data_r           20  // 29:20
+	#define LVDS_blank_data_g           10  // 19:10
+	#define LVDS_blank_data_b           0  //  9:0
+	
+/* for LVDS_PACK_CNTL_ADDR */  
+	#define LVDS_USE_TCON               7
+	#define LVDS_DUAL                   6
+	#define PN_SWP                      5
+	#define LSB_FIRST                   4
+	#define LVDS_RESV                   3
+	#define ODD_EVEN_SWP                2
+	#define LVDS_REPACK                 0
+
+static const unsigned gamma_sel_table[3] = {
+    LCD_H_SEL_R,
+    LCD_H_SEL_G,
+    LCD_H_SEL_B,
+};
+
+//********************************************//
+/* for video encoder */
+	#define	LVDS_DELAY				8
+	#define	TTL_DELAY				19
+	#define	MLVDS_DELAY				0
+
+//********************************************//
+// for clk parameter auto generation
+//********************************************//
+/**** clk parameters bit ***/
+	//pll_ctrl
+	#define PLL_CTRL_LOCK			31
+	#define PLL_CTRL_RST			29
+	#define PLL_CTRL_PD				30
+	#define PLL_CTRL_OD				16	//[17:16]
+	#define PLL_CTRL_N				9	//[13:9]
+	#define PLL_CTRL_M				0	//[8:0]
+
+	//div_ctrl
+	#define DIV_CTRL_DIV_POST		12	//[14:12]
+	#define DIV_CTRL_LVDS_CLK_EN	11
+	#define DIV_CTRL_PHY_CLK_DIV2	10
+	#define DIV_CTRL_POST_SEL		8	//[9:8]
+	#define DIV_CTRL_DIV_PRE		4	//[6:4]
+
+	#define PLL_WAIT_LOCK_CNT		100
+
+/**** clk frequency limit ***/
+	/* PLL */
+	#define PLL_M_MIN				2
+	#define PLL_M_MAX				100
+	#define PLL_N_MIN				1
+	#define PLL_N_MAX				1
+	#define PLL_FREF_MIN			(5 * 1000)
+	#define PLL_FREF_MAX			(30 * 1000)
+	#define PLL_VCO_MIN				(750 * 1000)
+	#define PLL_VCO_MAX				(1500 * 1000)
+	/* VIDEO */
+	#define DIV_PRE_MAX_CLK_IN		(1300 * 1000)
+	#define DIV_POST_MAX_CLK_IN		(800 * 1000)
+	#define CRT_VID_MAX_CLK_IN		(600 * 1000)
+	#define LCD_VENC_MAX_CLK_IN		(208 * 1000)
+	
+	/* lcd interface video clk */
+	#define LVDS_MAX_VID_CLK_IN		LCD_VENC_MAX_CLK_IN
+	#define TTL_MAX_VID_CLK_IN		LCD_VENC_MAX_CLK_IN
+	#define MLVDS_MAX_VID_CLK_IN	LCD_VENC_MAX_CLK_IN
+
+	/* clk max error */
+	#define MAX_ERROR				(2 * 1000)
+
+#define CRT_VID_DIV_MAX				15
+
+#define OD_SEL_MAX					2
+#define DIV_PRE_SEL_MAX				6
+
+static const unsigned od_table[4] = {1,2,4,8};
+static const unsigned div_pre_table[6] = {1,2,3,4,5,6};
+//********************************************//
+
+#define SS_LEVEL_MAX	7
+static const char *lcd_ss_level_table[]={
+	"0",
+	"0.5%",
+	"1%",
+	"2%",
+	"3%",
+	"4%",
+	"5%",
+};
+
+#endif
diff --git a/arch/arm/mach-meson8/Makefile b/arch/arm/mach-meson8/Makefile
index 52c06f0283ec..2ae182bf001d 100755
--- a/arch/arm/mach-meson8/Makefile
+++ b/arch/arm/mach-meson8/Makefile
@@ -43,6 +43,8 @@ obj-$(CONFIG_AMLOGIC_THERMAL) += thermal.o
 
 obj-$(CONFIG_AML_HDMI_TX) +=  hdmi_tx_hw/
 
+obj-$(CONFIG_AM_LCD_OUTPUT) +=  lcd/
+
 obj-$(CONFIG_GPIO_TEST) += gpiotest.o
 
 # ARM Trustzone
diff --git a/include/linux/amlogic/vout/lcd_reg.h b/arch/arm/mach-meson8/include/mach/lcd_reg.h
similarity index 86%
rename from include/linux/amlogic/vout/lcd_reg.h
rename to arch/arm/mach-meson8/include/mach/lcd_reg.h
index 4f12c9daf4d9..a2cc9f3216f5 100755
--- a/include/linux/amlogic/vout/lcd_reg.h
+++ b/arch/arm/mach-meson8/include/mach/lcd_reg.h
@@ -2,20 +2,15 @@
 #define LCD_CONTROLLER_REG_H
 #include <mach/io.h>
 
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-#define LCD_REG_BASE_ADDR				IO_CBUS_BASE
-#define LCD_CBUS_BASE_ADDR				IO_CBUS_BASE
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
 #define LCD_REG_BASE_ADDR				IO_VPU_BUS_BASE	//#define IO_VPU_BUS_BASE	(IO_APB_BUS_BASE + 0x100000)
 #define LCD_CBUS_BASE_ADDR				IO_CBUS_BASE
 #define LCD_DPTX_BASE_ADDR				IO_EDP_TX_BASE	//#define IO_EDP_TX_BASE	(IO_APB_BUS_BASE + 0x160000)
 #define LCD_DSI_BASE_ADDR				IO_MIPI_DSI_BASE
-#endif
 
 #define LCD_REG_OFFSET(reg)				(reg << 2)
 #define LCD_CBUS_OFFSET(reg)			(reg << 2)
 #define LCD_DPTX_OFFSET(reg)			(reg)
-#define LCD_DSI_OFFSET(reg)				(reg<<2)
+#define LCD_DSI_OFFSET(reg)				(reg << 2)
 
 #define LCD_REG_ADDR(reg)				(LCD_REG_BASE_ADDR + LCD_REG_OFFSET(reg))
 #define LCD_CBUS_ADDR(reg)				(LCD_CBUS_BASE_ADDR + LCD_CBUS_OFFSET(reg))
diff --git a/arch/arm/mach-meson8/include/mach/lcdoutc.h b/arch/arm/mach-meson8/include/mach/lcdoutc.h
new file mode 100755
index 000000000000..b4f919c2cae2
--- /dev/null
+++ b/arch/arm/mach-meson8/include/mach/lcdoutc.h
@@ -0,0 +1,25 @@
+
+#ifndef MACH_LCDOUTC_H
+#define MACH_LCDOUTC_H
+
+#define CONFIG_LCD_TYPE_MID_VALID
+#define CONFIG_LCD_IF_TTL_VALID
+#define CONFIG_LCD_IF_LVDS_VALID
+#define CONFIG_LCD_IF_MIPI_VALID
+#define CONFIG_LCD_IF_EDP_VALID
+/*
+// lcd driver global API, special by CPU
+*/
+//*************************************************************
+// For mipi-dsi external driver use
+//*************************************************************
+//payload struct:
+//data_type, command, para_num, parameters...
+//data_type=0xff, command=0xff, means ending flag
+//data_type=0xff, command<0xff, means delay time(unit ms)
+//return:
+//command num
+extern int dsi_write_cmd(unsigned char* payload);
+//*************************************************************
+
+#endif
diff --git a/arch/arm/mach-meson8/lcd/Makefile b/arch/arm/mach-meson8/lcd/Makefile
new file mode 100755
index 000000000000..eabe8c4efb8e
--- /dev/null
+++ b/arch/arm/mach-meson8/lcd/Makefile
@@ -0,0 +1 @@
+obj-y		+= edp_drv.o mipi_dsi_util.o lcd_config.o
diff --git a/drivers/amlogic/display/vout/edp_drv.c b/arch/arm/mach-meson8/lcd/edp_drv.c
similarity index 87%
rename from drivers/amlogic/display/vout/edp_drv.c
rename to arch/arm/mach-meson8/lcd/edp_drv.c
index 6bbb3edf2442..1fe725eb83a9 100755
--- a/drivers/amlogic/display/vout/edp_drv.c
+++ b/arch/arm/mach-meson8/lcd/edp_drv.c
@@ -11,22 +11,17 @@
 #include <linux/platform_device.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
-#include <mach/am_regs.h>
 #include <linux/delay.h>
 #include <mach/am_regs.h>
-#include <linux/amlogic/vout/lcd_reg.h>
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
+#include <mach/lcd_reg.h>
 #include <mach/edp_tx_reg.h>
+#include <linux/amlogic/vout/lcdoutc.h>
 #include "edp_drv.h"
 
-//#define PRINT_DEBUG_INFO
-#ifdef PRINT_DEBUG_INFO
-#define DBG_PRINT(...)		printk(__VA_ARGS__)
-#else
-#define DBG_PRINT(...)
-#endif
 #define DPRINT(...)		printk(__VA_ARGS__)
 
+static struct class *edp_debug_class = NULL;
+
 //*************************************//
 // dptx for operation eDP Host (Tx) 
 // trdp for operation eDP Sink (Rx)
@@ -72,9 +67,9 @@ static EDP_Link_Config_t lconfig = {
 	.bit_rate = 0,
 };
 
-unsigned char preset_vswing_tx, preset_vswing_rx;
-unsigned char preset_preemp_tx, preset_preemp_rx;
-unsigned char adj_req_lane01, adj_req_lane23;
+static unsigned char preset_vswing_tx, preset_vswing_rx;
+static unsigned char preset_preemp_tx, preset_preemp_rx;
+static unsigned char adj_req_lane01, adj_req_lane23;
 
 static inline void trdp_wait(unsigned n)
 {
@@ -107,20 +102,20 @@ static int dptx_wait_phy_ready(void)
 
 static void dptx_dump_link_config(void)
 {
-	EDP_Link_Config_t *link_config = dptx_get_link_config();
-	
-	DPRINT("********************************************\n");
-	DPRINT(" Link Config:\n"
+    EDP_Link_Config_t *link_config = dptx_get_link_config();
+
+    DPRINT("********************************************\n");
+    DPRINT(" Link Config:\n"
            "    Link Rate               : 0x%02x\n"
            "    Lane Count              : %u\n"
            "    Vswing                  : 0x%02x\n"
            "    Preemphasis             : 0x%02x\n"
            "    Spread Spectrum level   : %u\n"
-		   "    Use DPCD Caps           : %u\n"
+           "    Use DPCD Caps           : %u\n"
            "    Training Settings       : %u\n"
            "    Link Rate Adjust        : %u\n"
            "    Link Adaptive           : %u\n"
-		   "    Main Stream Enable      : %u\n",
+           "    Main Stream Enable      : %u\n",
            READ_DPTX_REG(EDP_TX_LINK_BW_SET),
            READ_DPTX_REG(EDP_TX_LINK_COUNT_SET),
            READ_DPTX_REG(EDP_TX_PHY_VOLTAGE_DIFF_LANE_0),
@@ -131,13 +126,13 @@ static void dptx_dump_link_config(void)
            link_config->link_rate_adjust_en,
            link_config->link_adaptive,
            READ_DPTX_REG(EDP_TX_MAIN_STREAM_ENABLE));
-	DPRINT("********************************************\n");
+    DPRINT("********************************************\n");
 }
 
 static void dptx_dump_MSA(void)
 {
-	DPRINT("********************************************\n");
-	DPRINT(" Main Stream Attributes TX\n"
+    DPRINT("********************************************\n");
+    DPRINT(" Main Stream Attributes TX\n"
            "    Clocks, H Total         : %u\n"
            "    Clocks, V Total         : %u\n"
            "    Polarity (V / H)        : %u\n"
@@ -170,7 +165,7 @@ static void dptx_dump_MSA(void)
            READ_DPTX_REG(EDP_TX_MAIN_STREAM_N_VID),
            READ_DPTX_REG(EDP_TX_MAIN_STREAM_TRANSFER_UNIT_SIZE), 
            READ_DPTX_REG(EDP_TX_MAIN_STREAM_DATA_COUNT_PER_LANE));
-	DPRINT("********************************************\n");
+    DPRINT("********************************************\n");
 }
 
 static int dptx_set_link_rate(unsigned char link_rate)
@@ -224,52 +219,52 @@ static int dptx_set_lane_count(unsigned char lane_count)
 }
 
 //Main Stream Attributes
-static void dptx_set_video_mode(EDP_Video_Mode_t *vm)
+static void dptx_set_MSA(EDP_MSA_t *vm)
 {
     unsigned lane_count;
     unsigned data_per_lane;
     unsigned misc0_data;
-	unsigned n_vid;
-	EDP_Link_Config_t *link_config = dptx_get_link_config();
-	
-	switch (link_config->link_rate) {
-		case VAL_EDP_TX_LINK_BW_SET_162:
-			n_vid = 16200;
-			break;
-		case VAL_EDP_TX_LINK_BW_SET_270:
-			n_vid = 27000;
-			break;
-		case VAL_EDP_TX_LINK_BW_SET_540:
-			n_vid = 54000;
-			break;
-		default:
-			n_vid = 27000;
-			break;
-	}
-	
-	lane_count = READ_DPTX_REG(EDP_TX_LINK_COUNT_SET);
+    unsigned n_vid;
+    EDP_Link_Config_t *link_config = dptx_get_link_config();
+
+    switch (link_config->link_rate) {
+        case VAL_EDP_TX_LINK_BW_SET_162:
+            n_vid = 162000;
+            break;
+        case VAL_EDP_TX_LINK_BW_SET_270:
+            n_vid = 270000;
+            break;
+        case VAL_EDP_TX_LINK_BW_SET_540:
+            n_vid = 540000;
+            break;
+        default:
+            n_vid = 270000;
+            break;
+    }
+
+    lane_count = READ_DPTX_REG(EDP_TX_LINK_COUNT_SET);
     data_per_lane = ((vm->h_active * vm->bpc * 3) + 15) / 16 - lane_count;//1;//lane_count;
-	
-	misc0_data = ((vm->cformat << 1) | (1 << 0));	//always sync mode
-	switch (vm->bpc) {
+
+    misc0_data = ((vm->cformat << 1) | (vm->sync_clock_mode << 0)); //bit[0] sync mode (1=sync 0=async)
+    switch (vm->bpc) {
         case 6:
-			misc0_data = (misc0_data & 0x1f) | (0x0 << 5);
-			break;
+            misc0_data = (misc0_data & 0x1f) | (0x0 << 5);
+            break;
         case 10:
-			misc0_data = (misc0_data & 0x1f) | (0x2 << 5);
-			break;
+            misc0_data = (misc0_data & 0x1f) | (0x2 << 5);
+            break;
         case 12:
-			misc0_data = (misc0_data & 0x1f) | (0x3 << 5);
-			break;
+            misc0_data = (misc0_data & 0x1f) | (0x3 << 5);
+            break;
         case 16:
-			misc0_data = (misc0_data & 0x1f) | (0x4 << 5);
-			break;
-		case 8:
+            misc0_data = (misc0_data & 0x1f) | (0x4 << 5);
+            break;
+        case 8:
         default:
-			misc0_data = (misc0_data & 0x1f) | (0x1 << 5);
-			break;
+            misc0_data = (misc0_data & 0x1f) | (0x1 << 5);
+            break;
     }
-	
+
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_HTOTAL, vm->h_period);
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_VTOTAL, vm->v_period);
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_POLARITY, ((vm->vsync_pol & 0x1) << 1) | (vm->vsync_pol & 0x1));
@@ -277,17 +272,15 @@ static void dptx_set_video_mode(EDP_Video_Mode_t *vm)
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_VSWIDTH, vm->vsync_width);
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_HRES, vm->h_active);
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_VRES, vm->v_active);
-    WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_HSTART, vm->de_hstart);	//need to tune
-    WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_VSTART, vm->de_vstart);	//need to tune
-    //WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_MISC0, ((vm->cformat << 1) | (1 << 0)));	//always sync mode
-	WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_MISC0, misc0_data);
+    WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_HSTART, vm->hsync_bp);
+    WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_VSTART, vm->vsync_bp);
+    //WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_MISC0, ((vm->cformat << 1) | (1 << 0))); //always sync mode
+    WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_MISC0, misc0_data);
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_MISC1, 0x00000000);
-    WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_M_VID, (vm->clk / 10000));	//10kHz
-	WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_N_VID, n_vid);	//10kHz
+    WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_M_VID, (vm->clk / 1000)); //unit: 1kHz
+    WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_N_VID, n_vid);             //unit: 10kHz
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_TRANSFER_UNIT_SIZE, 32);    
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_DATA_COUNT_PER_LANE, data_per_lane);// bytes per lane
-	//WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_USER_PIXEL_WIDTH, 2);
-	//mdelay(5);
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_USER_PIXEL_WIDTH, vm->ppc);
 }
 
@@ -425,7 +418,10 @@ static int trdp_AUXRead(unsigned long address, unsigned long byte_count, unsigne
 						reply_state = VAL_EDP_TX_AUX_OPERATION_ERROR;
 					break;
 			}
-		}		
+		}
+		else {
+			DPRINT("AUXRead timeout\n");
+		}
 	}
 	
 	if (reply_state == VAL_EDP_TX_AUX_OPERATION_SUCCESS) {
@@ -511,7 +507,7 @@ static int trdp_AUXWrite(unsigned long address, unsigned long byte_count, unsign
 		//write AUX command
 		WRITE_DPTX_REG(EDP_TX_AUX_ADDRESS, address);
 		for(i=0; i<byte_count; i++ )
-			 WRITE_DPTX_REG(EDP_TX_AUX_WRITE_FIFO, data[i] );
+			WRITE_DPTX_REG(EDP_TX_AUX_WRITE_FIFO, data[i] );
 
 		WRITE_DPTX_REG(EDP_TX_AUX_COMMAND, (VAL_EDP_TX_AUX_CMD_WRITE | ((byte_count-1) & 0xF)));
 		
@@ -549,6 +545,9 @@ static int trdp_AUXWrite(unsigned long address, unsigned long byte_count, unsign
 					break;
 			}
 		}
+		else {
+			DPRINT("AUXWrite time out\n");
+		}
 	}
 	
     return reply_state;
@@ -829,60 +828,26 @@ static int trdp_dump_DPCD_training_status(void)
 	return VAL_EDP_TX_AUX_OPERATION_SUCCESS;
 }
 
-static unsigned char trdp_select_edp_lane_count(unsigned char link_rate)
+static void trdp_edp_link_rate_update(unsigned char link_rate)
 {
-	unsigned int bit_rate, lane_capacity;
-	unsigned char lane_count;
 	EDP_Link_Config_t *link_config = dptx_get_link_config();
 	
-	lane_count = link_config->lane_count;
 	switch (link_rate) {
 		case VAL_EDP_TX_LINK_BW_SET_162:
 		case VAL_EDP_TX_LINK_BW_SET_270:
 			link_config->link_rate = link_rate;
-			bit_rate = edp_clk_config_update(link_rate);
 			break;
 		default:
-			lane_count = 0;
 			break;
 	}
-	
-	if (lane_count > 0) {
-		switch (link_rate) {
-			case VAL_EDP_TX_LINK_BW_SET_162:
-				lane_capacity = EDP_TX_LINK_CAPACITY_162;
-				break;
-			case VAL_EDP_TX_LINK_BW_SET_270:
-				lane_capacity = EDP_TX_LINK_CAPACITY_270;
-				break;
-			case VAL_EDP_TX_LINK_BW_SET_540:
-				lane_capacity = EDP_TX_LINK_CAPACITY_540;
-				break;
-			default:
-				lane_capacity = EDP_TX_LINK_CAPACITY_162;
-				break;
-		}
-		
-		if (bit_rate < lane_capacity * 1)
-			lane_count = 1;
-		else if (bit_rate < lane_capacity * 2)
-			lane_count = 2;
-		else if (bit_rate < lane_capacity * 4)
-			lane_count = 4;
-		else
-			lane_count = 0;
-
-		link_config->lane_count = lane_count;
-	}
-	return lane_count;
 }
 
 static int trdp_set_link_rate(unsigned char link_rate)
 {
 	int status = VAL_EDP_TX_AUX_OPERATION_SUCCESS;
 	
-	DBG_PRINT("set link rate\n");	
-	if (link_rate != READ_DPTX_REG(EDP_TX_LINK_BW_SET)) {	
+	DBG_PRINT("set link rate\n");
+	if (link_rate != READ_DPTX_REG(EDP_TX_LINK_BW_SET)) {
 		WRITE_DPTX_REG(EDP_TX_LINK_BW_SET, link_rate);
 		if (status)
 			return status;
@@ -1374,12 +1339,12 @@ static int trdp_update_status(void)
 	return status;
 }
 
-static int trdp_run_training_loop(unsigned training_settings, unsigned link_rate_adjust_en, unsigned adaptive)
+static int trdp_run_training_loop(unsigned training_settings, unsigned link_rate_adjust_en, unsigned adaptive, unsigned retry_num)
 {
 	int status = 0;
 	unsigned lanes = 0;
 	unsigned char aux_data[4];
-	unsigned done = 0;
+	unsigned done = 0, link_rate_adjust = 0;
 	unsigned training_state = VAL_EDP_TS_CLOCK_REC;
 	unsigned link_speed;
 	
@@ -1452,30 +1417,22 @@ static int trdp_run_training_loop(unsigned training_settings, unsigned link_rate
 			// the state of the status variable should not be changed in this state allowing a failure condition to report the proper status.
 			//**************************************
 			case VAL_EDP_TS_ADJUST_SPD:
-				link_speed = READ_DPTX_REG(EDP_TX_LINK_BW_SET);
-				lanes = READ_DPTX_REG(EDP_TX_LINK_COUNT_SET);
-				
-				if (link_speed != VAL_EDP_TX_LINK_BW_SET_162) {
-					if (link_speed == VAL_EDP_TX_LINK_BW_SET_270) {
-						link_speed = VAL_EDP_TX_LINK_BW_SET_162;
+				if (retry_num == 1) {
+					link_speed = READ_DPTX_REG(EDP_TX_LINK_BW_SET);
+					lanes = READ_DPTX_REG(EDP_TX_LINK_COUNT_SET);
+					if (link_speed != VAL_EDP_TX_LINK_BW_SET_162) {
+						if (link_speed == VAL_EDP_TX_LINK_BW_SET_270) {
+							link_speed = VAL_EDP_TX_LINK_BW_SET_162;
+						}
+						else {
+							link_speed = VAL_EDP_TX_LINK_BW_SET_270;
+						}
+						DPRINT("[warning]: reduce edp link rate\n");
+						trdp_edp_link_rate_update(link_speed);
+						link_rate_adjust = 1;
 					}
-					else {
-						link_speed = VAL_EDP_TX_LINK_BW_SET_270;
-					}
-					lanes = trdp_select_edp_lane_count(link_speed);
-					if (lanes > 0) {
-						trdp_set_link_rate(link_speed);
-						trdp_set_lane_count(lanes);
-					}
-					else {
-						DPRINT("couldn't reduce link rate\n");
-						done = 1;
-					}
-					training_state = VAL_EDP_TS_CLOCK_REC;
-				}
-				else {
-					done = 1;
 				}
+				done = 1;
 				break;
 		}
 	}
@@ -1484,6 +1441,9 @@ static int trdp_run_training_loop(unsigned training_settings, unsigned link_rate
 	WRITE_DPTX_REG(EDP_TX_SCRAMBLING_DISABLE, 0x00);	//turn on scrambling after training
 	
 	//if (status == VAL_EDP_TX_OPERATION_SUCCESS)
+	if (link_rate_adjust)
+		status = VAL_EDP_LPM_STATUS_LINK_RATE_ADJUST;
+	else
 		status = trdp_update_status();
 
 	return status;
@@ -1505,8 +1465,8 @@ static int trdp_set_link_config(unsigned char link_rate, unsigned char lane_coun
 			break;
 	}
 	switch (lane_count) {
-		case 1:			
-		case 2:			
+		case 1:
+		case 2:
 		case 4:
 			enhance_framing_mode = (READ_DPTX_REG(EDP_TX_ENHANCED_FRAME_EN) & 0x01);
 			if (enhance_framing_mode)
@@ -1584,44 +1544,47 @@ static int trdp_set_data_lane_config(EDP_Link_Config_t *link_config)
 	return status;
 }
 
-static void dplpm_get_training_status_string(int status, char *status_string)
+static void dplpm_print_training_status(int status)
 {
+	char status_string[80];
+
 	switch (status) {
 		case VAL_EDP_TRAINING_CR_FAILED:
-			sprintf(status_string, "displayport training: Clock Recovery failed");
+			sprintf(status_string, "Clock Recovery failed");
 			break;
 		case VAL_EDP_TRAINING_CHAN_EQ_FAILED:
-			sprintf(status_string, "displayport training: Symbol Lock failed");
+			sprintf(status_string, "Symbol Lock failed");
 			break;
 		case VAL_EDP_TX_AUX_OPERATION_FAILED:
-			sprintf(status_string, "displayport training: AUX operation failure during training");
+			sprintf(status_string, "AUX operation failure during training");
 			break;
 		case VAL_EDP_CONFIG_INVALID_LINK_RATE:
-			sprintf(status_string, "displayport training: Invalid link rate selected");
+			sprintf(status_string, "Invalid link rate selected");
 			break;
 		case VAL_EDP_CONFIG_INVALID_LANE_COUNT:
-			sprintf(status_string, "displayport training: Invalid lane count selected");
+			sprintf(status_string, "Invalid lane count selected");
 			break;
 		case VAL_EDP_CONFIG_HPD_DEASSERTED:
-			sprintf(status_string, "displayport training: HPD deasserted");
+			sprintf(status_string, "HPD deasserted");
 			break;
 		case VAL_EDP_TX_OPERATION_SUCCESS:
-			sprintf(status_string, "displayport training: Success");
+			sprintf(status_string, "Success");
 			break;
 		case VAL_EDP_LPM_STATUS_RETRAIN:
-			sprintf(status_string, "displayport training: Retrain");
+			sprintf(status_string, "Retrain");
 			break;
 		default:
-			sprintf(status_string, "displayport training: Error 0x%08x", status);
+			sprintf(status_string, "Error 0x%08x", status);
 			break;
 	}
+	DPRINT("displayport training: %s\n", status_string);
 }
 
 static void dplpm_main_stream_enable(unsigned enable)
 {
 	EDP_Link_Config_t *link_config = dptx_get_link_config();
 	
-	enable = (enable > 0) ? 1 : 0;	
+	enable = (enable > 0) ? 1 : 0;
 	link_config->main_stream_enable = enable;
 	
 	if (enable) {
@@ -1669,11 +1632,10 @@ static int dplpm_verify_link_status(void)
 
 static int dplpm_maintain_link(void)
 {
-	unsigned max_training_attempts = VAL_EDP_MAX_TRAINING_ATTEMPTS;
+	unsigned training_attempts = VAL_EDP_MAX_TRAINING_ATTEMPTS;
 	unsigned training_successful = 0, retrain = 0;
 	int status = VAL_EDP_LPM_STATUS_RETRAIN;
 	EDP_Link_Config_t *link_config = dptx_get_link_config();
-	char training_string[80];
 	
 	//status = dplpm_verify_link_status();
 	if (status == VAL_EDP_LPM_STATUS_RETRAIN) {
@@ -1682,15 +1644,15 @@ static int dplpm_maintain_link(void)
 	}
 
 	if (retrain == 1) {
-		while ((max_training_attempts > 0) && (training_successful != 1)) {
-			status = trdp_run_training_loop(link_config->training_settings, link_config->link_rate_adjust_en, link_config->link_adaptive);
+		while ((training_attempts > 0) && (training_successful != 1)) {
+			status = trdp_run_training_loop(link_config->training_settings, link_config->link_rate_adjust_en, link_config->link_adaptive, training_attempts);
 			status = dplpm_verify_link_status();
 			if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
 				training_successful = 1;
-				dplpm_main_stream_enable(1);
+				//dplpm_main_stream_enable(1);
 			}
 			else {
-				max_training_attempts--;
+				training_attempts--;
 				link_config->link_update = 0;
 			}
 		}
@@ -1699,15 +1661,13 @@ static int dplpm_maintain_link(void)
 		dplpm_main_stream_enable(1);
 	}
 	
-	dplpm_get_training_status_string(status, &training_string);
-	DPRINT("%s\n", training_string);
-	
+	dplpm_print_training_status(status);
 	return status;
 }
 
 static int dplpm_link_init(EDP_Link_Config_t *link_config)
 {
-	unsigned status = 0;	
+	unsigned status = 0;
 	unsigned char link_rate = link_config->link_rate & 0xff;
 	unsigned char lane_count = link_config->lane_count & 0x7;
 	unsigned char ss_level = link_config->ss_level & 0xf;
@@ -1770,7 +1730,7 @@ static int dplpm_link_init(EDP_Link_Config_t *link_config)
 	return status;
 }
 
-int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_Video_Mode_t *vm)
+int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_MSA_t *vm)
 {
 	int status = 0;
 	EDP_Link_Config_t *link_config = dptx_get_link_config();
@@ -1786,14 +1746,14 @@ int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_Video_Mode_t *vm)
 	link_config->bit_rate = mlconfig->bit_rate;
 	
 	status = dplpm_link_init(link_config);
-	
+
 	if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
 		status = dplpm_maintain_link();
-#ifdef PRINT_DEBUG_INFO
+#ifdef LCD_DEBUG_INFO
 		trdp_dump_DPCD();
 		trdp_dump_DPCD_training_status();
 #endif
-		dptx_set_video_mode(vm);
+		dptx_set_MSA(vm);
 		WRITE_LCD_REG(ENCL_VIDEO_EN, 1);
 		dplpm_main_stream_enable(1);
 	}
@@ -1801,7 +1761,7 @@ int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_Video_Mode_t *vm)
 		DPRINT("displayport initial failed\n");
 		status = VAL_EDP_TX_OPERATION_FAILED;
 	}
-#ifdef PRINT_DEBUG_INFO
+#ifdef LCD_DEBUG_INFO
 	dptx_dump_link_config();
 	dptx_dump_MSA();
 #endif
@@ -1962,27 +1922,50 @@ static ssize_t edp_debug(struct class *class, struct class_attribute *attr, cons
 static struct class_attribute edp_debug_class_attrs[] = {
 	__ATTR(debug, S_IRUGO | S_IWUSR, edp_debug_help, edp_debug),
 	__ATTR(help, S_IRUGO | S_IWUSR, edp_debug_help, NULL),
-	__ATTR_NULL
 };
 
-static struct class aml_edp_debug_class = {
-	.name = "edp",
-	.class_attrs = edp_debug_class_attrs,
-};
+static int creat_edp_attr(void)
+{
+	int i;
+
+	edp_debug_class = class_create(THIS_MODULE, "edp");
+	if(IS_ERR(edp_debug_class)) {
+		printk("create edp debug class fail\n");
+		return -1;
+	}
+	//create class attr
+	for(i=0;i<ARRAY_SIZE(edp_debug_class_attrs);i++) {
+		if (class_create_file(edp_debug_class, &edp_debug_class_attrs[i])) {
+			printk("create edp debug attribute %s fail\n",edp_debug_class_attrs[i].attr.name);
+		}
+	}
+
+	return 0;
+}
+static int remove_edp_attr(void)
+{
+    int i;
+
+    if (edp_debug_class == NULL)
+        return -1;
+
+    for(i=0;i<ARRAY_SIZE(edp_debug_class_attrs);i++) {
+        class_remove_file(edp_debug_class, &edp_debug_class_attrs[i]);
+    }
+    class_destroy(edp_debug_class);
+
+    return 0;
+}
 //*********************************************************//
 
 void edp_probe(void)
 {
 	int ret;
 	
-	ret = class_register(&aml_edp_debug_class);
-	if(ret){
-		DPRINT("class register aml_edp_debug_class fail!\n");
-	}
+	creat_edp_attr();
 }
 
 void edp_remove(void)
 {
-	//to do
+	remove_edp_attr();
 }
-#endif
diff --git a/drivers/amlogic/display/vout/edp_drv.h b/arch/arm/mach-meson8/lcd/edp_drv.h
similarity index 86%
rename from drivers/amlogic/display/vout/edp_drv.h
rename to arch/arm/mach-meson8/lcd/edp_drv.h
index eab9ce64a5fc..04c28534cece 100755
--- a/drivers/amlogic/display/vout/edp_drv.h
+++ b/arch/arm/mach-meson8/lcd/edp_drv.h
@@ -160,10 +160,11 @@
 #define VAL_EDP_LPM_STATUS_LINK_VALID			0x0000
 #define VAL_EDP_LPM_STATUS_CHANGED				0xAA10
 #define VAL_EDP_LPM_STATUS_RETRAIN				0xAA11
-#define VAL_EDP_LPM_STATUS_NOT_CONNECTED		0xAA12
-#define VAL_EDP_LPM_STATUS_TX_NOT_CONFIGURED	0xAA13
-#define VAL_EDP_LPM_STATUS_RX_IDLE				0xAA21
-#define VAL_EDP_LPM_STATUS_RX_ACTIVE			0xAA22
+#define VAL_EDP_LPM_STATUS_LINK_RATE_ADJUST		0xAA12
+#define VAL_EDP_LPM_STATUS_NOT_CONNECTED		0xAA13
+#define VAL_EDP_LPM_STATUS_TX_NOT_CONFIGURED	0xAA21
+#define VAL_EDP_LPM_STATUS_RX_IDLE				0xAA31
+#define VAL_EDP_LPM_STATUS_RX_ACTIVE			0xAA32
 
 #define VAL_EDP_TX_AUX_INVALID_PARAMETER		0x1144
 #define VAL_EDP_TX_AUX_OPERATION_TIMEOUT		0x1133
@@ -174,7 +175,43 @@
 #define VAL_EDP_TX_OPERATION_FAILED				0x00FF
 #define VAL_EDP_TX_OPERATION_SUCCESS			0x0000
 //********************************************************//
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
+
+#define VAL_EDP_TX_INVALID_VALUE    0xFF
+static const unsigned char edp_link_rate_table[] = {
+    VAL_EDP_TX_LINK_BW_SET_162,
+    VAL_EDP_TX_LINK_BW_SET_270,
+    VAL_EDP_TX_LINK_BW_SET_540,
+    VAL_EDP_TX_INVALID_VALUE,
+};
+static const char *edp_link_rate_string_table[]={
+    "1.62Gbps",
+    "2.70Gbps",
+    "5.40Gbps",
+    "invalid",
+};
+static const unsigned char edp_lane_count_table[] = {1, 2, 4, VAL_EDP_TX_INVALID_VALUE};
+#define LINK_RATE_TO_CAPACITY(x)    (x * 8 / 10) //8/10 coding
+static const unsigned edp_link_capacity_table[] = { //Mbps
+    LINK_RATE_TO_CAPACITY(1620), //1.62G
+    LINK_RATE_TO_CAPACITY(2700), //2.7G
+    LINK_RATE_TO_CAPACITY(5400), //5.4G
+};
+
+static const unsigned char edp_vswing_table[] = {
+    VAL_EDP_TX_PHY_VSWING_0,
+    VAL_EDP_TX_PHY_VSWING_1,
+    VAL_EDP_TX_PHY_VSWING_2,
+    VAL_EDP_TX_PHY_VSWING_3,
+    VAL_EDP_TX_INVALID_VALUE,
+};
+static const unsigned char edp_preemphasis_table[] = {
+    VAL_EDP_TX_PHY_PREEMPHASIS_0,
+    VAL_EDP_TX_PHY_PREEMPHASIS_1,
+    VAL_EDP_TX_PHY_PREEMPHASIS_2,
+    VAL_EDP_TX_PHY_PREEMPHASIS_3,
+    VAL_EDP_TX_INVALID_VALUE,
+};
+
 typedef enum {
 	EDP_HPD_STATE_DISCONNECTED = 0,
 	EDP_HPD_STATE_CONNECTED,
@@ -215,13 +252,12 @@ typedef struct {
 	unsigned short vsync_pol;
 	unsigned short vsync_width;
 	unsigned short vsync_bp;
-	unsigned short de_hstart;
-	unsigned short de_vstart;
 	
 	unsigned short ppc;		//pixels per clock cycle
 	unsigned short cformat;	//color format(0=RGB, 1=4:2:2, 2=Y only)
 	unsigned short bpc;		//bits per color
-} EDP_Video_Mode_t;
+	unsigned int sync_clock_mode;
+} EDP_MSA_t; //Main Stream Attribute
 
 typedef struct {
 	unsigned char max_lane_count;
@@ -238,21 +274,15 @@ typedef struct {
 	unsigned char use_dpcd_caps;
 	unsigned char link_rate_adjust_en;
 	unsigned char link_adaptive;
-	unsigned int bit_rate;	//Mbps
+	unsigned int bit_rate; //Mbps
 } EDP_Link_Config_t;
 
-#define EDP_TX_LINK_CAPACITY_162	1296	//Mbps
-#define EDP_TX_LINK_CAPACITY_270	2160	//Mbps
-#define EDP_TX_LINK_CAPACITY_540	4320	//Mbps
+extern void edp_phy_config_update(unsigned char vswing_tx, unsigned char preemp_tx);
 
-extern int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_Video_Mode_t *vm);
+extern int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_MSA_t *vm);
 extern int dplpm_link_off(void);
 extern void dplpm_off(void);
 extern void edp_probe(void);
 extern void edp_remove(void);
 
-extern unsigned edp_clk_config_update(unsigned char link_rate);
-extern void edp_phy_config_update(unsigned char vswing_tx, unsigned char preemp_tx);
-#endif
-
 #endif
diff --git a/arch/arm/mach-meson8/lcd/lcd_config.c b/arch/arm/mach-meson8/lcd/lcd_config.c
new file mode 100755
index 000000000000..5a393e67fb8a
--- /dev/null
+++ b/arch/arm/mach-meson8/lcd/lcd_config.c
@@ -0,0 +1,1848 @@
+/*
+ * AMLOGIC lcd controller driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ * Modify:  Evoke Zhang <evoke.zhang@amlogic.com>
+ * compatible dts
+ *
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <plat/regops.h>
+#include <mach/am_regs.h>
+#include <mach/lcd_reg.h>
+#include <linux/amlogic/vout/lcdoutc.h>
+#include <mach/clock.h>
+#include <mach/vpu.h>
+#include <mach/mod_gate.h>
+#include <asm/fiq.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include "lcd_config.h"
+#include "mipi_dsi_util.h"
+#include "edp_drv.h"
+
+#define VPP_OUT_SATURATE	(1 << 0)
+
+static spinlock_t gamma_write_lock;
+static spinlock_t lcd_clk_lock;
+
+static Lcd_Config_t *lcd_Conf;
+static unsigned char lcd_gamma_init_err = 0;
+
+void lcd_config_init(Lcd_Config_t *pConf);
+
+static void print_lcd_driver_version(void)
+{
+    printk("lcd driver version: %s%s\n\n", LCD_DRV_DATE, LCD_DRV_TYPE);
+}
+
+static void lcd_ports_ctrl_lvds(Bool_t status)
+{
+	if (status) {
+		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1); //enable lvds fifo
+		if (lcd_Conf->lcd_basic.lcd_bits == 6)
+			WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1e, 11, 5);	//enable LVDS phy 3 channels
+		else
+			WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);	//enable LVDS phy 4 channels
+	}
+	else {
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
+	}
+
+	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl_mipi(Bool_t status)
+{
+    if (status) {
+        switch (lcd_Conf->lcd_control.mipi_config->lane_num) {
+            case 1:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x11, 11, 5);
+                break;
+            case 2:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x19, 11, 5);
+                break;
+            case 3:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1d, 11, 5);
+                break;
+            case 4:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);
+                break;
+            default:
+                break;
+        }
+    }
+    else {
+        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
+        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
+        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
+    }
+
+    DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl_edp(Bool_t status)
+{
+	if (status) {
+		switch (lcd_Conf->lcd_control.edp_config->lane_count) {
+			case 1:
+				WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x18, 11, 5);
+				break;
+			case 2:
+				WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1c, 11, 5);
+				break;
+			case 4:
+				WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);
+				break;
+			default:
+				break;
+		}
+	}
+	else {
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
+	}
+	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl_ttl(Bool_t status)
+{
+	struct pinctrl_state *s;
+	int ret;
+	
+	if (IS_ERR(lcd_Conf->lcd_misc_ctrl.pin)) {
+		printk("set ttl_ports_ctrl pinmux error.\n");
+		return;
+	}
+
+	if (status) {
+	if (lcd_Conf->lcd_basic.lcd_bits == 6) {
+			if (lcd_Conf->lcd_timing.de_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_hvsync_on");
+			}
+			else if (lcd_Conf->lcd_timing.hvsync_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_de_on");
+			}
+			else {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_hvsync_de_on");	//select pinmux
+			}
+		}
+		else {
+			if (lcd_Conf->lcd_timing.de_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_hvsync_on");
+			}	
+			else if (lcd_Conf->lcd_timing.hvsync_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_de_on");
+			}
+			else {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_hvsync_de_on");	//select pinmux
+			}
+		}
+		if (IS_ERR(lcd_Conf->lcd_misc_ctrl.pin)) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+
+		ret = pinctrl_select_state(lcd_Conf->lcd_misc_ctrl.pin, s);	//set pinmux and lock pins
+		if (ret < 0) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+	}else {
+		//pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);	//release pins
+		if (lcd_Conf->lcd_basic.lcd_bits == 6) {
+			s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_hvsync_de_off");	//select pinmux
+		}
+		else {
+			s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_hvsync_de_off");	//select pinmux
+		}
+		if (IS_ERR(lcd_Conf->lcd_misc_ctrl.pin)) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+		
+		ret = pinctrl_select_state(lcd_Conf->lcd_misc_ctrl.pin, s);	//set pinmux and lock pins
+		if (ret < 0) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+	}
+	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl(Bool_t status)
+{
+    switch(lcd_Conf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            lcd_ports_ctrl_mipi(status);
+            break;
+        case LCD_DIGITAL_LVDS:
+            lcd_ports_ctrl_lvds(status);
+            break;
+        case LCD_DIGITAL_EDP:
+            lcd_ports_ctrl_edp(status);
+            break;
+        case LCD_DIGITAL_TTL:
+            lcd_ports_ctrl_ttl(status);
+            break;
+        default:
+            printk("Invalid LCD type.\n");
+            break;
+    }
+}
+
+static void set_control_mipi(Lcd_Config_t *pConf);
+static int set_control_edp(Lcd_Config_t *pConf);
+//for special interface
+static int lcd_power_ctrl_video(Bool_t status)
+{
+    int ret = 0;
+
+    if (status) {
+        switch(lcd_Conf->lcd_basic.lcd_type) {
+            case LCD_DIGITAL_MIPI:
+                set_control_mipi(lcd_Conf);
+                break;
+            case LCD_DIGITAL_EDP:
+                ret = set_control_edp(lcd_Conf);
+                break;
+            default:
+                break;
+        }
+    }
+    else {
+        switch(lcd_Conf->lcd_basic.lcd_type) {
+            case LCD_DIGITAL_MIPI:
+                mipi_dsi_link_off(lcd_Conf);  //link off command
+                break;
+            case LCD_DIGITAL_EDP:
+                ret = dplpm_link_off();  //link off command
+                break;
+            default:
+                break;
+        }
+    }
+    DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+    return ret;
+}
+
+#define LCD_GAMMA_RETRY_CNT  1000
+static void write_gamma_table(u16 *data, u32 rgb_mask, u16 gamma_coeff, u32 gamma_reverse)
+{
+	int i;
+	int cnt = 0;
+	unsigned long flags = 0;
+	
+	spin_lock_irqsave(&gamma_write_lock, flags);
+	rgb_mask = gamma_sel_table[rgb_mask];
+	while ((!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x0 << LCD_HADR));
+	if (gamma_reverse == 0) {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG(L_GAMMA_DATA_PORT, (data[i] * gamma_coeff / 100));
+		}
+	}
+	else {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG(L_GAMMA_DATA_PORT, (data[255-i] * gamma_coeff / 100));
+		}
+	}
+	cnt = 0;
+	while ((!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x23 << LCD_HADR));
+	
+	if (cnt >= LCD_GAMMA_RETRY_CNT)
+		lcd_gamma_init_err = 1;
+	
+	spin_unlock_irqrestore(&gamma_write_lock, flags);
+}
+
+static void set_gamma_table_lcd(unsigned gamma_en)
+{
+	DBG_PRINT("%s\n", __FUNCTION__);
+	lcd_gamma_init_err = 0;
+	write_gamma_table(lcd_Conf->lcd_effect.GammaTableR, GAMMA_SEL_R, lcd_Conf->lcd_effect.gamma_r_coeff, ((lcd_Conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+	write_gamma_table(lcd_Conf->lcd_effect.GammaTableG, GAMMA_SEL_G, lcd_Conf->lcd_effect.gamma_g_coeff, ((lcd_Conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+	write_gamma_table(lcd_Conf->lcd_effect.GammaTableB, GAMMA_SEL_B, lcd_Conf->lcd_effect.gamma_b_coeff, ((lcd_Conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+
+	if (lcd_gamma_init_err) {
+		WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 0, 0, 1);
+		printk("[warning]: write gamma table error, gamma table disabled\n");
+	}
+	else
+		WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, gamma_en, 0, 1);
+}
+
+static void set_tcon_lcd(Lcd_Config_t *pConf)
+{
+	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
+	unsigned hs_pol_adj, vs_pol_adj;
+
+	DBG_PRINT("%s\n", __FUNCTION__);
+	
+	set_gamma_table_lcd(((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1));
+	
+	WRITE_LCD_REG(L_RGB_BASE_ADDR,  pConf->lcd_effect.rgb_base_addr);
+	WRITE_LCD_REG(L_RGB_COEFF_ADDR, pConf->lcd_effect.rgb_coeff_addr);
+	if (pConf->lcd_effect.dith_user) {
+		WRITE_LCD_REG(L_DITH_CNTL_ADDR,  pConf->lcd_effect.dith_cntl_addr);
+	}
+	else {
+		if(pConf->lcd_basic.lcd_bits == 8)
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x400);
+		else
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x600);
+	}
+	
+	WRITE_LCD_REG(L_POL_CNTL_ADDR,   (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1) << LCD_CPH1_POL));
+	
+	switch (pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			hs_pol_adj = 1; //1 for low active, 0 for high active.
+			vs_pol_adj = 1; //1 for low active, 0 for high active
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((0 << LCD_DE_POL) | (vs_pol_adj << LCD_VS_POL) | (hs_pol_adj << LCD_HS_POL)))); //adjust hvsync pol
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((1 << LCD_TCON_DE_SEL) | (1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL)))); //enable tcon DE, Hsync, Vsync
+			break;
+		case LCD_DIGITAL_LVDS:
+		case LCD_DIGITAL_TTL:
+			hs_pol_adj = (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1) ? 0 : 1); //1 for low active, 0 for high active.
+			vs_pol_adj = (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1) ? 0 : 1); //1 for low active, 0 for high active
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((0 << LCD_DE_POL) | (vs_pol_adj << LCD_VS_POL) | (hs_pol_adj << LCD_HS_POL)))); //adjust hvsync pol
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((1 << LCD_TCON_DE_SEL) | (1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL)))); //enable tcon DE, Hsync, Vsync 
+			break;
+		case LCD_DIGITAL_EDP:
+			hs_pol_adj = 0; //1 for low active, 0 for high active.
+			vs_pol_adj = 0; //1 for low active, 0 for high active
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((0 << LCD_DE_POL) | (vs_pol_adj << LCD_VS_POL) | (hs_pol_adj << LCD_HS_POL)))); //adjust hvsync pol
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((1 << LCD_TCON_DE_SEL) | (1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL)))); //enable tcon DE, Hsync, Vsync 
+			break;
+		default:
+			hs_pol_adj = 0;
+			vs_pol_adj = 0;
+			break;
+	}
+	if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
+		//DE signal
+		WRITE_LCD_REG(L_OEH_HS_ADDR,     tcon_adr->de_hs_addr);
+		WRITE_LCD_REG(L_OEH_HE_ADDR,     tcon_adr->de_he_addr);
+		WRITE_LCD_REG(L_OEH_VS_ADDR,     tcon_adr->de_vs_addr);
+		WRITE_LCD_REG(L_OEH_VE_ADDR,     tcon_adr->de_ve_addr);
+		
+		//Hsync signal
+		if (hs_pol_adj == 0) {
+			WRITE_LCD_REG(L_STH1_HS_ADDR,    tcon_adr->hs_hs_addr);
+			WRITE_LCD_REG(L_STH1_HE_ADDR,    tcon_adr->hs_he_addr);
+		}
+		else {
+			WRITE_LCD_REG(L_STH1_HS_ADDR,    tcon_adr->hs_he_addr);
+			WRITE_LCD_REG(L_STH1_HE_ADDR,    tcon_adr->hs_hs_addr);
+		}
+		WRITE_LCD_REG(L_STH1_VS_ADDR,    tcon_adr->hs_vs_addr);
+		WRITE_LCD_REG(L_STH1_VE_ADDR,    tcon_adr->hs_ve_addr);
+
+		//Vsync signal
+		WRITE_LCD_REG(L_STV1_HS_ADDR,    tcon_adr->vs_hs_addr);
+		WRITE_LCD_REG(L_STV1_HE_ADDR,    tcon_adr->vs_he_addr);
+		if (vs_pol_adj == 0) {
+			WRITE_LCD_REG(L_STV1_VS_ADDR,    tcon_adr->vs_vs_addr);
+			WRITE_LCD_REG(L_STV1_VE_ADDR,    tcon_adr->vs_ve_addr);
+		}
+		else {
+			WRITE_LCD_REG(L_STV1_VS_ADDR,    tcon_adr->vs_ve_addr);
+			WRITE_LCD_REG(L_STV1_VE_ADDR,    tcon_adr->vs_vs_addr);
+		}
+		
+		WRITE_LCD_REG(L_INV_CNT_ADDR,       0);
+		WRITE_LCD_REG(L_TCON_MISC_SEL_ADDR, ((1 << LCD_STV1_SEL) | (1 << LCD_STV2_SEL)));
+	}
+	else {
+		//DE signal
+		WRITE_LCD_REG(L_DE_HS_ADDR,    tcon_adr->de_hs_addr);
+		WRITE_LCD_REG(L_DE_HE_ADDR,    tcon_adr->de_he_addr);
+		WRITE_LCD_REG(L_DE_VS_ADDR,    tcon_adr->de_vs_addr);
+		WRITE_LCD_REG(L_DE_VE_ADDR,    tcon_adr->de_ve_addr);
+		
+		//Hsync signal
+		WRITE_LCD_REG(L_HSYNC_HS_ADDR,  tcon_adr->hs_hs_addr);
+		WRITE_LCD_REG(L_HSYNC_HE_ADDR,  tcon_adr->hs_he_addr);
+		WRITE_LCD_REG(L_HSYNC_VS_ADDR,  tcon_adr->hs_vs_addr);
+		WRITE_LCD_REG(L_HSYNC_VE_ADDR,  tcon_adr->hs_ve_addr);
+		
+		//Vsync signal
+		WRITE_LCD_REG(L_VSYNC_HS_ADDR,  tcon_adr->vs_hs_addr);
+		WRITE_LCD_REG(L_VSYNC_HE_ADDR,  tcon_adr->vs_he_addr);
+		WRITE_LCD_REG(L_VSYNC_VS_ADDR,  tcon_adr->vs_vs_addr);
+		WRITE_LCD_REG(L_VSYNC_VE_ADDR,  tcon_adr->vs_ve_addr);
+	}
+	
+	if(pConf->lcd_misc_ctrl.vpp_sel)
+		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
+	else
+		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+}
+
+static void vclk_set_lcd(int lcd_type, unsigned long pll_reg, unsigned long vid_div_reg, unsigned int clk_ctrl_reg)
+{
+	unsigned edp_div0_sel = 0, edp_div1_sel = 0, xd = 0;
+	unsigned pll_level = 0, pll_frac = 0;
+	int wait_loop = PLL_WAIT_LOCK_CNT;
+	unsigned pll_lock = 0;
+	unsigned ss_level=0, pll_ctrl2, pll_ctrl3, pll_ctrl4, od_fb;
+	unsigned long flags = 0;
+	spin_lock_irqsave(&lcd_clk_lock, flags);
+	
+	DBG_PRINT("%s\n", __FUNCTION__);
+
+	edp_div0_sel = (vid_div_reg >> DIV_CTRL_EDP_DIV0) & 0xf;
+	edp_div1_sel = (vid_div_reg >> DIV_CTRL_EDP_DIV1) & 0x7;
+	vid_div_reg = ((vid_div_reg & 0x1ffff) | (1 << 16) | (1 << 15) | (0x3 << 0));	//select vid2_pll and enable clk
+	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xf;
+	pll_level = (clk_ctrl_reg >> CLK_CTRL_LEVEL) & 0x7;
+	pll_frac = (clk_ctrl_reg >> CLK_CTRL_FRAC) & 0xfff;
+	ss_level = (clk_ctrl_reg >> CLK_CTRL_SS) & 0xf;
+	pll_reg |= (1 << PLL_CTRL_EN);
+	
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 19, 1);	//disable vclk2_en
+	udelay(2);
+
+	WRITE_LCD_CBUS_REG(HHI_EDP_TX_PHY_CNTL0, (1 << 16));	//reset edp tx phy
+
+	if (pll_frac == 0)
+		pll_ctrl2 = 0x0421a000;
+	else
+		pll_ctrl2 = (0x0431a000 | pll_frac);
+	
+	pll_ctrl4 = (0xd4000d67 & ~((1<<13) | (0xf<<14) | (0xf<<18)));
+	switch (ss_level) {
+		case 1:	//0.5%
+			pll_ctrl4 |= ((1<<13) | (2<<18) | (1<<14));
+			break;
+		case 2:	//1%
+			pll_ctrl4 |= ((1<<13) | (1<<18) | (1<<14));
+			break;
+		case 3:	//1.5%
+			pll_ctrl4 |= ((1<<13) | (8<<18) | (1<<14));
+			break;
+		case 4: //2%
+			pll_ctrl4 |= ((1<<13) | (0<<18) | (1<<14));
+			break;
+		case 0:
+		default:
+			ss_level = 0;
+			break;
+	}
+	
+	switch (pll_level) {
+		case 1: //<=1.7G
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca45b823;
+			od_fb = 0;
+			break;
+		case 2: //1.7G~2.0G
+			pll_ctrl2 |= (1<<19);//special adjust
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca49b823;
+			od_fb = 1;
+			break;
+		case 3: //2.0G~2.5G
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca49b823;
+			od_fb = 1;
+			break;
+		case 4: //>=2.5G
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xce49c022;
+			od_fb = 1;
+			break;
+		default:
+			pll_ctrl3 = 0xca7e3823;
+			od_fb = 0;
+			break;
+	}
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL5, 1, 16, 1);//enable bandgap
+	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL2, pll_ctrl2);
+	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL3, pll_ctrl3);
+	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL4, pll_ctrl4);
+	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL5, (0x00700001 | (od_fb << 8)));	//[8] od_fb
+	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL, pll_reg | (1 << PLL_CTRL_RST));
+	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL, pll_reg);
+	
+	do{
+		udelay(50);
+		pll_lock = (READ_LCD_CBUS_REG(HHI_VID2_PLL_CNTL) >> PLL_CTRL_LOCK) & 0x1;
+		if (wait_loop == 100) {
+			if (pll_level == 2) {
+				//change setting if can't lock
+				WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL2, 1, 18, 1);
+				WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 1, PLL_CTRL_RST, 1);
+				WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0, PLL_CTRL_RST, 1);
+				printk("change setting for vid2 pll stability\n");
+			}
+		}
+		wait_loop--;
+	}while((pll_lock == 0) && (wait_loop > 0));
+	if (wait_loop == 0)
+		printk("[error]: vid2_pll lock failed\n");
+
+	//select logic & encl clock
+	switch (lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 3, 23, 3);	//pll_out mux to mipi-dsi phy & vid2_pll
+			WRITE_LCD_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 0, 4, 1);
+			break;
+		case LCD_DIGITAL_EDP:
+			WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 4, 23, 3);	//pll_out mux to edp phy
+			WRITE_LCD_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 1, 4, 1);
+			
+			WRITE_LCD_CBUS_REG(HHI_EDP_TX_PHY_CNTL0, ((0xf << 0) | (1 << 4)));	//enable edp phy channel & serializer clk, and release reset
+			WRITE_LCD_CBUS_REG_BITS(HHI_EDP_TX_PHY_CNTL0, edp_div0_sel, 20, 4);	//set edptx_phy_clk_div0
+			WRITE_LCD_CBUS_REG_BITS(HHI_EDP_TX_PHY_CNTL0, edp_div1_sel, 24, 3);	//set edptx_phy_clk_div1
+			WRITE_LCD_CBUS_REG_BITS(HHI_EDP_TX_PHY_CNTL0, 1, 5, 1);	//enable divider N, for vid_pll2_in
+			
+			WRITE_LCD_CBUS_REG(HHI_EDP_APB_CLK_CNTL, (1 << 7) | (2 << 0));	//fclk_div5---fixed 510M, div to 170M, edp apb clk
+			break;
+		case LCD_DIGITAL_LVDS:
+		case LCD_DIGITAL_TTL:
+		default:
+			WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 2, 23, 3);	//pll_out mux to vid2_pll
+			WRITE_LCD_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 0, 4, 1);
+			break;
+	}
+	udelay(10);
+
+	//pll_div2
+	WRITE_LCD_CBUS_REG(HHI_VIID_DIVIDER_CNTL, vid_div_reg);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 7, 1);    //0x104c[7]:SOFT_RESET_POST
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 3, 1);    //0x104c[3]:SOFT_RESET_PRE
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 1, 1);    //0x104c[1]:RESET_N_POST
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 0, 1);    //0x104c[0]:RESET_N_PRE
+	udelay(5);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 3, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 7, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 3, 0, 2);
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, (xd-1), 0, 8); // setup the XD divider value
+	udelay(5);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 4, 16, 3); // Bit[18:16] - v2_cntl_clk_in_sel
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 19, 1); //vclk2_en0
+	udelay(2);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 8, 12, 4); // [15:12] encl_clk_sel, select vclk2_div1
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 1, 16, 2); // release vclk2_div_reset and enable vclk2_div
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 0, 1); //enable v2_clk_div1
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 15, 1); //soft reset
+	udelay(10);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 15, 1);  //release soft reset
+	udelay(5);
+	
+	spin_unlock_irqrestore(&lcd_clk_lock, flags);
+}
+
+static void clk_util_lvds_set_clk_div(unsigned long divn_sel, unsigned long divn_tcnt, unsigned long div2_en)
+{
+    // ---------------------------------------------
+    // Configure the LVDS PHY
+    // ---------------------------------------------
+    // wire    [4:0]   cntl_ser_en         = control[20:16];
+    // wire            cntl_prbs_en        = control[13];
+    // wire            cntl_prbs_err_en    = control[12];
+    // wire    [1:0]   cntl_mode_set_high  = control[11:10];
+    // wire    [1:0]   cntl_mode_set_low   = control[9:8];
+    // 
+    // wire    [1:0]   fifo_clk_sel        = control[7;6]
+    // 
+    // wire            mode_port_rev       = control[4];
+    // wire            mode_bit_rev        = control[3];
+    // wire            mode_inv_p_n        = control[2];
+    // wire            phy_clk_en          = control[1];
+    // wire            soft_reset_int      = control[0];
+    WRITE_LCD_CBUS_REG(HHI_LVDS_TX_PHY_CNTL0, (0x1f << 16) | (0x1 << 6) ); // enable all serializers, divide by 7
+}
+
+static void set_pll_lcd(Lcd_Config_t *pConf)
+{
+    unsigned pll_reg, div_reg, clk_reg;
+    int xd;
+    int lcd_type, ss_level;
+    unsigned pll_div_post = 0, phy_clk_div2 = 0;
+
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    pll_reg = pConf->lcd_timing.pll_ctrl;
+    div_reg = pConf->lcd_timing.div_ctrl;
+    clk_reg = pConf->lcd_timing.clk_ctrl;
+    ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
+    xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
+
+    lcd_type = pConf->lcd_basic.lcd_type;
+
+    switch(lcd_type){
+        case LCD_DIGITAL_MIPI:
+            break;
+        case LCD_DIGITAL_EDP:
+            xd = 1;
+            break;
+        case LCD_DIGITAL_LVDS:
+            xd = 1;
+            pll_div_post = 7;
+            phy_clk_div2 = 0;
+            div_reg = (div_reg | (1 << DIV_CTRL_POST_SEL) | (1 << DIV_CTRL_LVDS_CLK_EN) | ((pll_div_post-1) << DIV_CTRL_DIV_POST) | (phy_clk_div2 << DIV_CTRL_PHY_CLK_DIV2));
+            break;
+        case LCD_DIGITAL_TTL:
+            break;
+        default:
+            break;
+    }
+    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
+
+    DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
+    vclk_set_lcd(lcd_type, pll_reg, div_reg, clk_reg);
+
+    switch(lcd_type){
+        case LCD_DIGITAL_MIPI:
+            WRITE_LCD_REG(MIPI_DSI_TOP_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0x7<<4)) | (1 << 4) | (1 << 5) | (0 << 6));
+            WRITE_LCD_REG(MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) | 0xf) );     // Release mipi_dsi_host's reset
+            WRITE_LCD_REG(MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) & 0xfffffff0) );     // Release mipi_dsi_host's reset
+            WRITE_LCD_REG(MIPI_DSI_TOP_CLK_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CLK_CNTL) | 0x3) );            // Enable dwc mipi_dsi_host's clock 
+            break;
+        case LCD_DIGITAL_EDP:
+            break;
+        case LCD_DIGITAL_LVDS:
+            clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
+            //    lvds_gen_cntl       <= {10'h0,      // [15:4] unused
+            //                            2'h1,       // [5:4] divide by 7 in the PHY
+            //                            1'b0,       // [3] fifo_en
+            //                            1'b0,       // [2] wr_bist_gate
+            //                            2'b00};     // [1:0] fifo_wr mode
+            //FIFO_CLK_SEL = 1; // div7
+            WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 4, 2);	//lvds fifo clk div 7
+
+            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 0, 15, 1);	// lvds div reset
+            udelay(5);
+            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 15, 1);	// Release lvds div reset
+            break;
+        case LCD_DIGITAL_TTL:
+            break;
+        default:
+            break;
+    }
+}
+
+static void set_venc_lcd(Lcd_Config_t *pConf)
+{
+	DBG_PRINT("%s\n",__FUNCTION__);
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
+#ifdef CONFIG_AM_TV_OUTPUT2
+	if	(pConf->lcd_misc_ctrl.vpp_sel) {
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2, 2); //viu2 select encl
+	}
+	else {
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);//viu1 select encl
+	}
+#else
+	WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 4);;	//viu1, viu2 select encl
+#endif
+	
+	WRITE_LCD_REG(ENCL_VIDEO_MODE,			0);
+	WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV,		0x8); // Sampling rate: 1
+
+	WRITE_LCD_REG(ENCL_VIDEO_FILT_CTRL,		0x1000); // bypass filter
+
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_PXCNT,		pConf->lcd_basic.h_period - 1);
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_LNCNT,		pConf->lcd_basic.v_period - 1);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_BEGIN,	pConf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_END,		pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_BLINE,	pConf->lcd_timing.video_on_line);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_ELINE,	pConf->lcd_basic.v_active - 1  + pConf->lcd_timing.video_on_line);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_BEGIN,   0);//pConf->lcd_timing.hs_hs_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_END,     10);//pConf->lcd_timing.hs_he_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BEGIN,   0);//pConf->lcd_timing.vs_hs_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_END,     0);//pConf->lcd_timing.vs_he_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE,   0);//pConf->lcd_timing.vs_vs_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,   2);//pConf->lcd_timing.vs_ve_addr);
+
+	WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN,			1);	// enable encl
+}
+
+static void set_control_lvds(Lcd_Config_t *pConf)
+{
+	unsigned lvds_repack, pn_swap, bit_num;
+	unsigned data32;
+	
+	DBG_PRINT("%s\n", __FUNCTION__);
+
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1); // disable lvds fifo
+	
+    data32 = (0x00 << LVDS_blank_data_r) |
+             (0x00 << LVDS_blank_data_g) |
+             (0x00 << LVDS_blank_data_b) ; 
+    WRITE_LCD_REG(LVDS_BLANK_DATA_HI, (data32 >> 16));
+    WRITE_LCD_REG(LVDS_BLANK_DATA_LO, (data32 & 0xffff));
+	
+	lvds_repack = (pConf->lcd_control.lvds_config->lvds_repack) & 0x1;
+	pn_swap = (pConf->lcd_control.lvds_config->pn_swap) & 0x1;
+
+	switch(pConf->lcd_basic.lcd_bits) {
+		case 10:
+			bit_num=0;
+			break;
+		case 8:
+			bit_num=1;
+			break;
+		case 6:
+			bit_num=2;
+			break;
+		case 4:
+			bit_num=3;
+			break;
+		default:
+			bit_num=1;
+			break;
+	}
+	
+	WRITE_LCD_REG(LVDS_PACK_CNTL_ADDR, 
+					( lvds_repack<<0 ) | // repack
+					( 0<<2 ) | // odd_even
+					( 0<<3 ) | // reserve
+					( 0<<4 ) | // lsb first
+					( pn_swap<<5 ) | // pn swap
+					( 0<<6 ) | // dual port
+					( 0<<7 ) | // use tcon control
+					( bit_num<<8 ) | // 0:10bits, 1:8bits, 2:6bits, 3:4bits.
+					( 0<<10 ) | //r_select  //0:R, 1:G, 2:B, 3:0
+					( 1<<12 ) | //g_select  //0:R, 1:G, 2:B, 3:0
+					( 2<<14 ));  //b_select  //0:R, 1:G, 2:B, 3:0; 
+				   
+    WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 0, 1);  //fifo enable
+	//WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1);  //enable fifo
+}
+
+static void set_control_mipi(Lcd_Config_t *pConf)
+{
+    set_mipi_dsi_control(pConf);
+}
+
+//**************************************************//
+// for edp link maintain control
+//**************************************************//
+static unsigned char get_edp_config_index(const unsigned char *edp_config_table, unsigned char edp_config_value)
+{
+    unsigned char index = 0;
+
+    while(index < 5) {
+        if((edp_config_value == edp_config_table[index]) || (edp_config_table[index] == VAL_EDP_TX_INVALID_VALUE))
+            break;
+        index++;
+    }
+    return index;
+}
+
+static void select_edp_link_config(Lcd_Config_t *pConf)
+{
+    unsigned bit_rate, band_width;
+    unsigned i, j, done = 0;
+
+    bit_rate = (pConf->lcd_timing.lcd_clk / 1000) * pConf->lcd_basic.lcd_bits * 3 / 1000;  //Mbps
+    pConf->lcd_control.edp_config->bit_rate = bit_rate;
+
+    if (pConf->lcd_control.edp_config->link_user == 0) {//auto calculate
+        i = 0;
+        while ((edp_lane_count_table[i] <= pConf->lcd_control.edp_config->max_lane_count) && (done == 0)) {
+            for (j=0; j<=1; j++) {
+                band_width = edp_link_capacity_table[j] * edp_lane_count_table[i];
+                if (band_width > bit_rate) {
+                    pConf->lcd_control.edp_config->link_rate = j;
+                    pConf->lcd_control.edp_config->lane_count = edp_lane_count_table[i];
+                    done = 1;
+                    break;
+                }
+            }
+            if (done == 0)
+                i++;
+        }
+        if (edp_lane_count_table[i] > pConf->lcd_control.edp_config->max_lane_count) {
+            pConf->lcd_control.edp_config->link_rate = 1;
+            pConf->lcd_control.edp_config->lane_count = pConf->lcd_control.edp_config->max_lane_count;
+            printk("Error: bit_rate is out of support, should reduce frame rate(pixel clock)\n");
+        }
+        else {
+            printk("select edp link_rate=%s, lane_count=%u\n", edp_link_rate_string_table[pConf->lcd_control.edp_config->link_rate], pConf->lcd_control.edp_config->lane_count);
+        }
+    }
+    else {//verify user define
+        i = get_edp_config_index(&edp_lane_count_table[0], pConf->lcd_control.edp_config->lane_count);
+        while ((edp_lane_count_table[i] <= pConf->lcd_control.edp_config->max_lane_count) && (done == 0)) {
+            band_width = edp_link_capacity_table[pConf->lcd_control.edp_config->link_rate] * edp_lane_count_table[i];
+            if (band_width > bit_rate) {
+                pConf->lcd_control.edp_config->lane_count = edp_lane_count_table[i];
+                done = 1;
+            }
+            else {
+                i++;
+            }
+        }
+        if (edp_lane_count_table[i] > pConf->lcd_control.edp_config->max_lane_count) {
+            pConf->lcd_control.edp_config->lane_count = pConf->lcd_control.edp_config->max_lane_count;
+            printk("Error: bandwidth is not enough at link_rate=%s, lane_count=%d\n", edp_link_rate_string_table[pConf->lcd_control.edp_config->link_rate], pConf->lcd_control.edp_config->lane_count);
+        }
+        else
+            printk("set edp link_rate=%s, lane_count=%u\n", edp_link_rate_string_table[pConf->lcd_control.edp_config->link_rate], pConf->lcd_control.edp_config->lane_count);
+    }
+}
+
+void edp_phy_config_update(unsigned char vswing_tx, unsigned char preemp_tx)
+{
+    unsigned vswing_ctrl, preemphasis_ctrl;
+
+    vswing_tx =  get_edp_config_index(&edp_vswing_table[0], vswing_tx);
+    preemp_tx =  get_edp_config_index(&edp_preemphasis_table[0], preemp_tx);
+    switch (vswing_tx) {
+        case 0: //0.4V
+            vswing_ctrl = 0x8018; //0x8038;
+            break;
+        case 1: //0.6V
+            vswing_ctrl = 0x8088;
+            break;
+        case 2: //0.8V
+            vswing_ctrl = 0x80c8;
+            break;
+        case 3: //1.2V
+            vswing_ctrl = 0x80f8;
+            break;
+        default:
+            vswing_ctrl = 0x80f8;
+            break;
+    }
+
+    switch (preemp_tx) {
+        case 0: //0db
+        case 1: //3.5db
+        case 2: //6db
+        case 3: //9.5db
+        default:
+            preemphasis_ctrl = 0x0; //to do
+            break;
+    }
+
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, vswing_ctrl);
+    printk("edp link adaptive update: vswing_level=%u, preemphasis_level=%u\n", vswing_tx, preemp_tx);
+}
+//**************************************************//
+
+static int set_control_edp(Lcd_Config_t *pConf)
+{
+    int ret = 0;
+    EDP_MSA_t  vm;
+    EDP_Link_Config_t link_config;
+
+    DBG_PRINT("%s\n", __FUNCTION__);
+    //edp link config
+    link_config.max_lane_count = 4;
+    link_config.max_link_rate = VAL_EDP_TX_LINK_BW_SET_270;
+    link_config.lane_count = pConf->lcd_control.edp_config->lane_count;
+    link_config.ss_level =((((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_SS) & 0xf) > 0 ? 1 : 0);
+    link_config.link_adaptive = pConf->lcd_control.edp_config->link_adaptive;
+    link_config.bit_rate = pConf->lcd_control.edp_config->bit_rate;
+    link_config.link_rate = edp_link_rate_table[pConf->lcd_control.edp_config->link_rate];
+    link_config.vswing = edp_vswing_table[pConf->lcd_control.edp_config->vswing];
+    link_config.preemphasis = edp_preemphasis_table[pConf->lcd_control.edp_config->preemphasis];
+
+    //edp main stream attribute
+    vm.h_active = pConf->lcd_basic.h_active;
+    vm.v_active = pConf->lcd_basic.v_active;
+    vm.h_period = pConf->lcd_basic.h_period;
+    vm.v_period = pConf->lcd_basic.v_period;
+    vm.clk = pConf->lcd_timing.lcd_clk;
+    vm.hsync_pol = (pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1;
+    vm.hsync_width = pConf->lcd_timing.hsync_width;
+    vm.hsync_bp = pConf->lcd_timing.hsync_bp;
+    vm.vsync_pol = (pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1;
+    vm.vsync_width = pConf->lcd_timing.vsync_width;
+    vm.vsync_bp = pConf->lcd_timing.vsync_bp;
+    vm.ppc = 1;							//pixels per clock cycle
+    vm.cformat = 0;						//color format(0=RGB, 1=4:2:2, 2=Y only)
+    vm.bpc = pConf->lcd_basic.lcd_bits;	//bits per color
+    vm.sync_clock_mode = pConf->lcd_control.edp_config->sync_clock_mode & 1;
+
+    //edp link maintain
+    ret = dplpm_link_policy_maker(&link_config, &vm);
+
+    //save feedback config by edp link maintain
+    pConf->lcd_control.edp_config->lane_count = link_config.lane_count;
+    pConf->lcd_control.edp_config->bit_rate = link_config.bit_rate;
+    pConf->lcd_control.edp_config->link_rate = get_edp_config_index(&edp_link_rate_table[0], link_config.link_rate);
+    pConf->lcd_control.edp_config->vswing = get_edp_config_index(&edp_vswing_table[0], link_config.vswing);
+    pConf->lcd_control.edp_config->preemphasis = get_edp_config_index(&edp_preemphasis_table[0], link_config.preemphasis);
+    return ret;
+}
+
+static void set_control_ttl(Lcd_Config_t *pConf)
+{
+	unsigned rb_port_swap, rgb_bit_swap;
+	
+	rb_port_swap = (unsigned)(pConf->lcd_control.ttl_config->rb_swap);
+	rgb_bit_swap = (unsigned)(pConf->lcd_control.ttl_config->bit_swap);
+	
+	WRITE_LCD_REG(L_DUAL_PORT_CNTL_ADDR, (rb_port_swap << LCD_RGB_SWP) | (rgb_bit_swap << LCD_BIT_SWP));
+}
+
+static void init_phy_lvds(Lcd_Config_t *pConf)
+{
+	unsigned swing_ctrl;
+	DBG_PRINT("%s\n", __FUNCTION__);
+	
+	WRITE_LCD_REG(LVDS_SER_EN, 0xfff);	//Enable the serializers
+
+	WRITE_LCD_REG(LVDS_PHY_CNTL0, 0xffff);
+	WRITE_LCD_REG(LVDS_PHY_CNTL1, 0xff00);
+	WRITE_LCD_REG(LVDS_PHY_CNTL4, 0x007f);
+	
+	//WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x00000348);
+	switch (pConf->lcd_control.lvds_config->lvds_vswing) {
+		case 0:
+			swing_ctrl = 0x028;
+			break;
+		case 1:
+			swing_ctrl = 0x048;
+			break;
+		case 2:
+			swing_ctrl = 0x088;
+			break;
+		case 3:
+			swing_ctrl = 0x0c8;
+			break;
+		case 4:
+			swing_ctrl = 0x0f8;
+			break;
+		default:
+			swing_ctrl = 0x048;
+			break;
+	}
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, swing_ctrl);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x000665b7);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x84070000);
+}
+
+static void init_phy_mipi(Lcd_Config_t *pConf)
+{
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x8);//DIF_REF_CTL0
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, (0x3e << 16) | (0xa5b8 << 0));//DIF_REF_CTL2:31-16bit, DIF_REF_CTL1:15-0bit
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, (0x26e0 << 16) | (0x459 << 0));//DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit
+}
+
+static void init_phy_edp(Lcd_Config_t *pConf)
+{
+    unsigned swing_ctrl;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    switch (pConf->lcd_control.edp_config->vswing) {
+        case 0:	//0.4V
+            swing_ctrl = 0x8018;
+            break;
+        case 1:	//0.6V
+            swing_ctrl = 0x8088;
+            break;
+        case 2:	//0.8V
+            swing_ctrl = 0x80c8;
+            break;
+        case 3:	//1.2V
+            swing_ctrl = 0x80f8;
+            break;
+        default:
+            swing_ctrl = 0x8018;
+            break;
+    }
+
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, swing_ctrl);//[7:4]swing b:800mv, step 50mv
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, ((0x6 << 16) | (0xf5d7 << 0)));
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, ((0xc2b2 << 16) | (0x600 << 0)));//0xd2b0fe00);
+}
+
+static void init_dphy(Lcd_Config_t *pConf)
+{
+	unsigned lcd_type = (unsigned)(pConf->lcd_basic.lcd_type);
+
+	switch (lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
+			init_phy_mipi(pConf);
+			break;
+		case LCD_DIGITAL_EDP:
+			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
+			init_phy_edp(pConf);
+			break;
+		case LCD_DIGITAL_LVDS:
+			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
+			init_phy_lvds(pConf);
+			break;
+		default:
+			break;
+	}
+}
+
+static void set_video_adjust(Lcd_Config_t *pConf)
+{
+	DBG_PRINT("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x.\n", pConf->lcd_effect.vadj_brightness, pConf->lcd_effect.vadj_contrast, pConf->lcd_effect.vadj_saturation);
+	WRITE_LCD_REG(VPP_VADJ2_Y, (pConf->lcd_effect.vadj_brightness << 8) | (pConf->lcd_effect.vadj_contrast << 0));
+	WRITE_LCD_REG(VPP_VADJ2_MA_MB, (pConf->lcd_effect.vadj_saturation << 16));
+	WRITE_LCD_REG(VPP_VADJ2_MC_MD, (pConf->lcd_effect.vadj_saturation << 0));
+	WRITE_LCD_REG(VPP_VADJ_CTRL, 0xf);	//enable video adjust
+}
+
+static void _init_lcd_driver(Lcd_Config_t *pConf)
+{
+    int lcd_type = pConf->lcd_basic.lcd_type;
+    unsigned char ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
+
+    print_lcd_driver_version();
+    request_vpu_clk_vmod(pConf->lcd_timing.lcd_clk, VMODE_LCD);
+    switch_vpu_mem_pd_vmod(VMODE_LCD, VPU_MEM_POWER_ON);
+    switch_lcd_mod_gate(ON);
+
+    printk("Init LCD mode: %s, %s(%u) %ubit, %ux%u@%u.%uHz, ss_level=%u(%s)\n", pConf->lcd_basic.model_name, lcd_type_table[lcd_type], lcd_type, pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10), ss_level, lcd_ss_level_table[ss_level]);
+
+    set_pll_lcd(pConf);
+    set_venc_lcd(pConf);
+    set_tcon_lcd(pConf);
+    switch(lcd_type){
+        case LCD_DIGITAL_MIPI:
+            init_dphy(pConf);
+            break;
+        case LCD_DIGITAL_LVDS:
+            set_control_lvds(pConf);
+            init_dphy(pConf);
+            break;
+        case LCD_DIGITAL_EDP:
+            init_dphy(pConf);
+            break;
+        case LCD_DIGITAL_TTL:
+            set_control_ttl(pConf);
+            break;
+        default:
+            printk("Invalid LCD type.\n");
+            break;
+    }
+    set_video_adjust(pConf);
+    printk("%s finished.\n", __FUNCTION__);
+}
+
+static void _disable_lcd_driver(Lcd_Config_t *pConf)
+{
+    switch(pConf->lcd_basic.lcd_type){
+        case LCD_DIGITAL_MIPI:
+            mipi_dsi_off();
+            break;
+        case LCD_DIGITAL_EDP:
+            dplpm_off();
+            break;
+        case LCD_DIGITAL_LVDS:
+        case LCD_DIGITAL_TTL:
+        default:
+            break;
+    }
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 11, 1);	//close lvds phy clk gate: 0x104c[11]
+    WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
+
+    WRITE_LCD_REG(ENCL_VIDEO_EN, 0);	//disable encl
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 0, 5);	//close vclk2 gate: 0x104b[4:0]
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 16, 1);	//close vid2_pll gate: 0x104c[16]
+    WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 0, 23, 3);	//disable pll_out mux
+    WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0, 30, 1);		//disable vid2_pll: 0x10e0[30]
+
+    switch_lcd_mod_gate(OFF);
+    switch_vpu_mem_pd_vmod(VMODE_LCD, VPU_MEM_POWER_DOWN);
+    release_vpu_clk_vmod(VMODE_LCD);
+    printk("disable lcd display driver.\n");
+}
+
+static void _enable_vsync_interrupt(void)
+{
+	if (READ_LCD_REG(ENCL_VIDEO_EN) & 1) {
+		WRITE_LCD_REG(VENC_INTCTRL, 0x200);
+	}
+	else{
+		WRITE_LCD_REG(VENC_INTCTRL, 0x2);
+	}
+}
+
+static void lcd_test(unsigned num)
+{
+	switch (num) {
+		case 0:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0x8);
+			printk("disable bist pattern\n");
+			break;
+		case 1:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 1);
+			WRITE_LCD_REG(ENCL_TST_CLRBAR_STRT, lcd_Conf->lcd_timing.video_on_pixel);
+			WRITE_LCD_REG(ENCL_TST_CLRBAR_WIDTH, (lcd_Conf->lcd_basic.h_active / 9));
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show bist pattern 1: Color Bar\n");
+			break;
+		case 2:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 2);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show bist pattern 2: Thin Line\n");
+			break;
+		case 3:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 3);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show bist pattern 3: Dot Grid\n");
+			break;
+		case 4:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+			WRITE_LCD_REG(ENCL_TST_Y, 0x3ff);
+			WRITE_LCD_REG(ENCL_TST_CB, 0x200);
+			WRITE_LCD_REG(ENCL_TST_CR, 0x200);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show test pattern 4: White\n");
+			break;
+		case 5:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+			WRITE_LCD_REG(ENCL_TST_Y, 0);
+			WRITE_LCD_REG(ENCL_TST_CB, 0);
+			WRITE_LCD_REG(ENCL_TST_CR, 0x3ff);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show test pattern 5: Red\n");
+			break;
+		case 6:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+			WRITE_LCD_REG(ENCL_TST_Y, 0x3ff);
+			WRITE_LCD_REG(ENCL_TST_CB, 0);
+			WRITE_LCD_REG(ENCL_TST_CR, 0);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show test pattern 6: Green\n");
+			break;
+		case 7:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+			WRITE_LCD_REG(ENCL_TST_Y, 0);
+			WRITE_LCD_REG(ENCL_TST_CB, 0x3ff);
+			WRITE_LCD_REG(ENCL_TST_CR, 0);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show test pattern 7: Blue\n");
+			break;
+		default:
+			printk("un-support pattern num\n");
+			break;
+	}
+}
+
+static DEFINE_MUTEX(lcd_init_mutex);
+static void lcd_module_enable(void)
+{
+	int ret = 0;
+
+	mutex_lock(&lcd_init_mutex);
+
+	_init_lcd_driver(lcd_Conf);
+	ret = lcd_Conf->lcd_power_ctrl.power_ctrl(ON);
+	if (lcd_Conf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
+		if (ret > 0) {
+			lcd_Conf->lcd_power_ctrl.power_ctrl(OFF);
+			_disable_lcd_driver(lcd_Conf);
+			mdelay(30);
+			lcd_config_init(lcd_Conf);
+			_init_lcd_driver(lcd_Conf);
+			lcd_Conf->lcd_power_ctrl.power_ctrl(ON);
+		}
+	}
+	_enable_vsync_interrupt();
+	lcd_Conf->lcd_misc_ctrl.lcd_status = 1;
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static void lcd_module_disable(void)
+{
+	mutex_lock(&lcd_init_mutex);
+	lcd_Conf->lcd_misc_ctrl.lcd_status = 0;
+	lcd_Conf->lcd_power_ctrl.power_ctrl(OFF);
+	_disable_lcd_driver(lcd_Conf);
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static void generate_clk_parameter(Lcd_Config_t *pConf)
+{
+    unsigned pll_n = 0, pll_m = 0, pll_od = 0, pll_frac = 0, pll_level = 0;
+    unsigned edp_phy_div0 = 0, edp_phy_div1 = 0, vid_div_pre = 0, crt_xd = 0;
+
+    unsigned m, n, od, div_pre, div_post, xd;
+    unsigned od_sel, pre_div_sel;
+    unsigned div_pre_sel_max, crt_xd_max;
+    unsigned pll_vco, fout_pll, div_pre_out, div_post_out, final_freq, iflogic_vid_clk_in_max;
+    unsigned min_error = MAX_ERROR;
+    unsigned error = MAX_ERROR;
+    unsigned od_fb=0;
+    unsigned int dsi_bit_rate_min=0, dsi_bit_rate_max=0;
+    unsigned edp_div0, edp_div1, edp_div0_sel, edp_div1_sel;
+    unsigned edp_tx_phy_out;
+    unsigned clk_num = 0;
+    unsigned tmp;
+    unsigned fin = FIN_FREQ;
+    unsigned fout = pConf->lcd_timing.lcd_clk;
+
+    if (fout >= 200) {//clk
+        fout = fout / 1000;  //kHz
+    }
+    else {//frame_rate
+        fout = (fout * pConf->lcd_basic.h_period * pConf->lcd_basic.v_period) / 1000;	//kHz
+    }
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = 16;
+            dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
+            dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
+            iflogic_vid_clk_in_max = MIPI_MAX_VID_CLK_IN;
+            break;
+        case LCD_DIGITAL_EDP:
+            div_pre_sel_max = 1;
+            div_post = 1;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = EDP_MAX_VID_CLK_IN;
+            min_error = 30 * 1000;
+            break;
+        case LCD_DIGITAL_LVDS:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 7;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = LVDS_MAX_VID_CLK_IN;
+            break;
+        case LCD_DIGITAL_TTL:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = CRT_VID_DIV_MAX;
+            iflogic_vid_clk_in_max = TTL_MAX_VID_CLK_IN;
+            break;
+        default:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = ENCL_MAX_CLK_IN;
+            break;
+    }
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            if (fout < ENCL_MAX_CLK_IN) {
+                for (xd = 1; xd <= crt_xd_max; xd++) {
+                    div_post_out = fout * xd;
+                    DBG_PRINT("div_post_out=%d, xd=%d, fout=%d\n",div_post_out, xd, fout);
+                    if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                        div_pre_out = div_post_out * div_post;
+                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                            for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                                div_pre = div_pre_table[pre_div_sel];
+                                fout_pll = div_pre_out * div_pre;
+                                DBG_PRINT("pre_div_sel=%d, div_pre=%d, fout_pll=%d\n", pre_div_sel, div_pre, fout_pll);
+                                if ((fout_pll <= dsi_bit_rate_max) && (fout_pll >= dsi_bit_rate_min)){
+                                    for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
+                                        od = od_table[od_sel - 1];
+                                        pll_vco = fout_pll * od;
+                                        DBG_PRINT("od_sel=%d, od=%d, pll_vco=%d\n", od_sel, od, pll_vco);
+                                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
+                                            if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
+                                                od_fb = 1;
+                                                pll_level = 4;
+                                            }
+                                            else if ((pll_vco >= 2000000) && (pll_vco < 2500000)) {
+                                                od_fb = 1;
+                                                pll_level = 3;
+                                            }
+                                            else if ((pll_vco >= 1700000) && (pll_vco < 2000000)) {//special adjust
+                                                od_fb = 1;
+                                                pll_level = 2;
+                                            }
+                                            else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
+                                                od_fb = 0;
+                                                pll_level = 1;
+                                            }
+                                            n = 1;
+                                            m = pll_vco / (fin * (od_fb + 1));
+                                            pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
+                                            pll_m = m;
+                                            pll_n = n;
+                                            pll_od = od_sel - 1;
+                                            vid_div_pre = pre_div_sel;
+                                            crt_xd = xd;
+                                            clk_num = 1;
+                                            DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
+                                                       pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
+                                        }
+                                        if (clk_num > 0)
+                                            break;
+                                    }
+                                }
+                                if (clk_num > 0)
+                                    break;
+                            }
+                        }
+                    }
+                    if (clk_num > 0)
+                        break;
+                }
+            }
+            break;
+        case LCD_DIGITAL_EDP:
+            switch (pConf->lcd_control.edp_config->link_rate) {
+                case 0:
+                    n = 1;
+                    m = 67;
+                    od_sel = 0;
+                    pll_level = 1;
+                    pll_frac = 0x800;
+                    fout_pll = 1620000;
+                    break;
+                case 1:
+                default:
+                    n = 1;
+                    m = 56;
+                    od_sel = 0;
+                    pll_level = 4;
+                    pll_frac = 0x400;
+                    fout_pll = 2700000;
+                    break;
+            }
+            pll_m = m;
+            pll_n = n;
+            pll_od = od_sel;
+
+            for(edp_div1_sel=0; edp_div1_sel<EDP_DIV1_SEL_MAX; edp_div1_sel++) {
+                edp_div1 = edp_div1_table[edp_div1_sel];
+                for (edp_div0_sel=0; edp_div0_sel<EDP_DIV0_SEL_MAX; edp_div0_sel++) {
+                    edp_div0 = edp_div0_table[edp_div0_sel];
+                    edp_tx_phy_out = fout_pll / (edp_div0 * edp_div1);
+                    if (edp_tx_phy_out <= DIV_PRE_MAX_CLK_IN) {
+                        for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                            div_pre = div_pre_table[pre_div_sel];
+                            div_pre_out = edp_tx_phy_out / div_pre;
+                            if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                                div_post_out = div_pre_out / div_post;
+                                if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                                    for (xd = 1; xd <= crt_xd_max; xd++) {
+                                        final_freq = div_post_out / xd;
+                                        if (final_freq < ENCL_MAX_CLK_IN) {
+                                            if (final_freq < iflogic_vid_clk_in_max) {
+                                                if (final_freq <= fout) {
+                                                    error = fout - final_freq;
+                                                    if (error < min_error) {
+                                                        min_error = error;
+                                                        edp_phy_div0 = edp_div0_sel;
+                                                        edp_phy_div1 = edp_div1_sel;
+                                                        vid_div_pre = pre_div_sel;
+                                                        crt_xd = xd;
+                                                        clk_num++;
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            break;
+        case LCD_DIGITAL_LVDS:
+        case LCD_DIGITAL_TTL:
+            if (fout < ENCL_MAX_CLK_IN) {
+                for (xd = 1; xd <= crt_xd_max; xd++) {
+                    div_post_out = fout * xd;
+                    DBG_PRINT("div_post_out=%d, xd=%d, fout=%d\n",div_post_out, xd, fout);
+                    if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                        div_pre_out = div_post_out * div_post;
+                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                            for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                                div_pre = div_pre_table[pre_div_sel];
+                                fout_pll = div_pre_out * div_pre;
+                                DBG_PRINT("pre_div_sel=%d, div_pre=%d, fout_pll=%d\n", pre_div_sel, div_pre, fout_pll);
+                                if (fout_pll <= DIV_PRE_MAX_CLK_IN) {
+                                    for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
+                                        od = od_table[od_sel - 1];
+                                        pll_vco = fout_pll * od;
+                                        DBG_PRINT("od_sel=%d, od=%d, pll_vco=%d\n", od_sel, od, pll_vco);
+                                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
+                                            if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
+                                                od_fb = 1;
+                                                pll_level = 4;
+                                            }
+                                            else if ((pll_vco >= 2000000) && (pll_vco < 2500000)) {
+                                                od_fb = 1;
+                                                pll_level = 3;
+                                            }
+                                            else if ((pll_vco >= 1700000) && (pll_vco < 2000000)) {
+                                                od_fb = 1;
+                                                pll_level = 2;
+                                            }
+                                            else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
+                                                od_fb = 0;
+                                                pll_level = 1;
+                                            }
+                                            n = 1;
+                                            m = pll_vco / (fin * (od_fb + 1));
+                                            pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
+
+                                            pll_m = m;
+                                            pll_n = n;
+                                            pll_od = od_sel - 1;
+                                            vid_div_pre = pre_div_sel;
+                                            crt_xd = xd;
+                                            DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
+                                                       pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
+                                            clk_num = 1;
+                                        }
+                                        if (clk_num > 0)
+                                            break;
+                                    }
+                                }
+                                if (clk_num > 0)
+                                    break;
+                            }
+                        }
+                    }
+                    if (clk_num > 0)
+                        break;
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    if (clk_num > 0) {
+        pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
+        pConf->lcd_timing.div_ctrl = 0x18803 | (edp_phy_div1 << DIV_CTRL_EDP_DIV1) | (edp_phy_div0 << DIV_CTRL_EDP_DIV0) | (vid_div_pre << DIV_CTRL_DIV_PRE);
+        tmp = (pConf->lcd_timing.clk_ctrl & ~((0xf << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
+        pConf->lcd_timing.clk_ctrl = (tmp | ((crt_xd << CLK_CTRL_XD) | (pll_level << CLK_CTRL_LEVEL) | (pll_frac << CLK_CTRL_FRAC)));
+    }
+    else {
+        pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (50 << PLL_CTRL_M);
+        pConf->lcd_timing.div_ctrl = 0x18803 | (0 << DIV_CTRL_EDP_DIV1) | (0 << DIV_CTRL_EDP_DIV0) | (1 << DIV_CTRL_DIV_PRE);
+        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+        printk("Out of clock range, reset to default setting!\n");
+    }
+}
+
+static void lcd_sync_duration(Lcd_Config_t *pConf)
+{
+	unsigned m, n, od, od_fb, frac, edp_div0, edp_div1, pre_div, xd, post_div;
+	unsigned h_period, v_period, sync_duration;
+	unsigned pll_out_clk, lcd_clk;
+
+	m = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_M) & 0x1ff;
+	n = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_N) & 0x1f;
+	od = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD) & 0x3;
+	od = od_table[od];
+	frac = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_FRAC) & 0xfff;
+	od_fb = ((((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_LEVEL) & 0x7) > 1) ? 1 : 0;
+	pre_div = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_DIV_PRE) & 0x7;
+	pre_div = div_pre_table[pre_div];
+	
+	h_period = pConf->lcd_basic.h_period;
+	v_period = pConf->lcd_basic.v_period;
+	
+	edp_div0 = 0;
+	edp_div1 = 0;
+	switch(pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			post_div = 1;
+			break;
+		case LCD_DIGITAL_EDP:
+			edp_div0 = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_EDP_DIV0) & 0xf;
+			edp_div1 = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_EDP_DIV1) & 0x7;
+			xd = 1;
+			post_div = 1;
+			break;
+		case LCD_DIGITAL_LVDS:
+			xd = 1;
+			post_div = 7;
+			break;
+		case LCD_DIGITAL_TTL:
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			post_div = 1;
+			break;
+		default:
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			post_div = 1;
+			break;
+	}
+	edp_div0 = edp_div0_table[edp_div0];
+	edp_div1 = edp_div1_table[edp_div1];
+	
+	pll_out_clk = (frac * (od_fb + 1) * FIN_FREQ) / 4096;
+	pll_out_clk = ((m * (od_fb + 1) * FIN_FREQ + pll_out_clk) / (n * od)) * 1000;
+	lcd_clk = pll_out_clk  / (edp_div0 * edp_div1 * pre_div * post_div * xd);
+	if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_MIPI)
+		pConf->lcd_control.mipi_config->bit_rate = pll_out_clk;
+	pConf->lcd_timing.lcd_clk = lcd_clk;
+	sync_duration = ((lcd_clk / h_period) * 100) / v_period;
+	sync_duration = (sync_duration + 5) / 10;
+	
+	pConf->lcd_timing.sync_duration_num = sync_duration;
+	pConf->lcd_timing.sync_duration_den = 10;
+	printk("lcd_clk=%u.%03uMHz, frame_rate=%u.%uHz.\n\n", (lcd_clk / 1000000), ((lcd_clk / 1000) % 1000), 
+			(sync_duration / pConf->lcd_timing.sync_duration_den), ((sync_duration * 10 / pConf->lcd_timing.sync_duration_den) % 10));
+}
+
+static void lcd_tcon_config(Lcd_Config_t *pConf)
+{
+	unsigned short hstart, hend, vstart, vend;
+	unsigned short h_delay = 0;
+	unsigned short h_offset = 0, v_offset = 0, vsync_h_phase=0;
+	
+	switch (pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			h_delay = MIPI_DELAY;
+			break;
+		case LCD_DIGITAL_EDP:
+			h_delay = EDP_DELAY;
+			break;
+		case LCD_DIGITAL_LVDS:
+			h_delay = LVDS_DELAY;
+			break;
+		case LCD_DIGITAL_TTL:
+			h_delay = TTL_DELAY;
+			break;
+		default:
+			h_delay = 0;
+			break;
+	}
+#if 0
+	h_offset = (pConf->lcd_timing.h_offset & 0xffff);
+	v_offset = (pConf->lcd_timing.v_offset & 0xffff);
+	if ((pConf->lcd_timing.h_offset >> 31) & 1)
+		pConf->lcd_timing.de_hstart = (pConf->lcd_timing.video_on_pixel + pConf->lcd_basic.h_period + h_delay + h_offset) % pConf->lcd_basic.h_period;
+	else
+		pConf->lcd_timing.de_hstart = (pConf->lcd_timing.video_on_pixel + pConf->lcd_basic.h_period + h_delay - h_offset) % pConf->lcd_basic.h_period;
+	if ((pConf->lcd_timing.v_offset >> 31) & 1)
+		pConf->lcd_timing.de_vstart = (pConf->lcd_timing.video_on_line + pConf->lcd_basic.v_period + v_offset) % pConf->lcd_basic.v_period;
+	else
+		pConf->lcd_timing.de_vstart = (pConf->lcd_timing.video_on_line + pConf->lcd_basic.v_period - v_offset) % pConf->lcd_basic.v_period;
+	
+	hstart = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp) % pConf->lcd_basic.h_period;
+	hend = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp + pConf->lcd_timing.hsync_width) % pConf->lcd_basic.h_period;	
+	pConf->lcd_timing.hs_hs_addr = hstart;
+	pConf->lcd_timing.hs_he_addr = hend;
+	pConf->lcd_timing.hs_vs_addr = 0;
+	pConf->lcd_timing.hs_ve_addr = pConf->lcd_basic.v_period - 1;
+	
+	vsync_h_phase = (pConf->lcd_timing.vsync_h_phase & 0xffff);
+	if ((pConf->lcd_timing.vsync_h_phase >> 31) & 1) //negative
+		vsync_h_phase = (hstart + pConf->lcd_basic.h_period - vsync_h_phase) % pConf->lcd_basic.h_period;
+	else	//positive
+		vsync_h_phase = (hstart + pConf->lcd_basic.h_period + vsync_h_phase) % pConf->lcd_basic.h_period;
+	pConf->lcd_timing.vs_hs_addr = vsync_h_phase;
+	pConf->lcd_timing.vs_he_addr = vsync_h_phase;
+	vstart = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp) % pConf->lcd_basic.v_period;
+	vend = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp + pConf->lcd_timing.vsync_width) % pConf->lcd_basic.v_period;
+	pConf->lcd_timing.vs_vs_addr = vstart;
+	pConf->lcd_timing.vs_ve_addr = vend;
+
+	pConf->lcd_timing.de_hstart = pConf->lcd_timing.de_hstart;
+	pConf->lcd_timing.de_vstart = pConf->lcd_timing.de_vstart;
+	
+	pConf->lcd_timing.de_hs_addr = pConf->lcd_timing.de_hstart;
+	pConf->lcd_timing.de_he_addr = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_active) % pConf->lcd_basic.h_period;
+	pConf->lcd_timing.de_vs_addr = pConf->lcd_timing.de_vstart;
+	pConf->lcd_timing.de_ve_addr = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_active - 1) % pConf->lcd_basic.v_period;
+#else
+    pConf->lcd_timing.video_on_pixel = pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 -h_delay;
+    pConf->lcd_timing.video_on_line = pConf->lcd_basic.v_period - pConf->lcd_basic.v_active;
+
+    h_offset = (pConf->lcd_timing.h_offset & 0xffff);
+    v_offset = (pConf->lcd_timing.v_offset & 0xffff);
+    if ((pConf->lcd_timing.h_offset >> 31) & 1)
+        pConf->lcd_timing.de_hstart = (pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 + pConf->lcd_basic.h_period - h_offset) % pConf->lcd_basic.h_period;
+    else
+        pConf->lcd_timing.de_hstart = (pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 + h_offset) % pConf->lcd_basic.h_period;
+    if ((pConf->lcd_timing.v_offset >> 31) & 1)
+        pConf->lcd_timing.de_vstart = (pConf->lcd_basic.v_period - pConf->lcd_basic.v_active + pConf->lcd_basic.v_period - v_offset) % pConf->lcd_basic.v_period;
+    else
+        pConf->lcd_timing.de_vstart = (pConf->lcd_basic.v_period - pConf->lcd_basic.v_active + v_offset) % pConf->lcd_basic.v_period;
+
+    hstart = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp) % pConf->lcd_basic.h_period;
+    hend = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp + pConf->lcd_timing.hsync_width) % pConf->lcd_basic.h_period;	
+    pConf->lcd_timing.hs_hs_addr = hstart;
+    pConf->lcd_timing.hs_he_addr = hend;
+    pConf->lcd_timing.hs_vs_addr = 0;
+    pConf->lcd_timing.hs_ve_addr = pConf->lcd_basic.v_period - 1;
+
+    vsync_h_phase = (pConf->lcd_timing.vsync_h_phase & 0xffff);
+    if ((pConf->lcd_timing.vsync_h_phase >> 31) & 1) //negative
+        vsync_h_phase = (hstart + pConf->lcd_basic.h_period - vsync_h_phase) % pConf->lcd_basic.h_period;
+    else //positive
+        vsync_h_phase = (hstart + pConf->lcd_basic.h_period + vsync_h_phase) % pConf->lcd_basic.h_period;
+    pConf->lcd_timing.vs_hs_addr = vsync_h_phase;
+    pConf->lcd_timing.vs_he_addr = vsync_h_phase;
+    vstart = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp) % pConf->lcd_basic.v_period;
+    vend = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp + pConf->lcd_timing.vsync_width) % pConf->lcd_basic.v_period;
+    pConf->lcd_timing.vs_vs_addr = vstart;
+    pConf->lcd_timing.vs_ve_addr = vend;
+
+    pConf->lcd_timing.de_hs_addr = pConf->lcd_timing.de_hstart;
+    pConf->lcd_timing.de_he_addr = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_active) % pConf->lcd_basic.h_period;
+    pConf->lcd_timing.de_vs_addr = pConf->lcd_timing.de_vstart;
+    pConf->lcd_timing.de_ve_addr = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_active - 1) % pConf->lcd_basic.v_period;
+#endif
+
+    //DBG_PRINT("hs_hs_addr=%d, hs_he_addr=%d, hs_vs_addr=%d, hs_ve_addr=%d\n", pConf->lcd_timing.hs_hs_addr, pConf->lcd_timing.hs_he_addr, pConf->lcd_timing.hs_vs_addr, pConf->lcd_timing.hs_ve_addr);
+    //DBG_PRINT("vs_hs_addr=%d, vs_he_addr=%d, vs_vs_addr=%d, vs_ve_addr=%d\n", pConf->lcd_timing.vs_hs_addr, pConf->lcd_timing.vs_he_addr, pConf->lcd_timing.vs_vs_addr, pConf->lcd_timing.vs_ve_addr);
+    //DBG_PRINT("de_hs_addr=%d, de_he_addr=%d, de_vs_addr=%d, de_ve_addr=%d\n", pConf->lcd_timing.de_hs_addr, pConf->lcd_timing.de_he_addr, pConf->lcd_timing.de_vs_addr, pConf->lcd_timing.de_ve_addr);
+}
+
+static void lcd_control_config_pre(Lcd_Config_t *pConf)
+{
+    unsigned ss_level;
+
+    ss_level = ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf);
+    ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            ss_level = ((ss_level > 0) ? 1 : 0);
+            set_mipi_dsi_control_config(pConf);
+            break;
+        case LCD_DIGITAL_EDP:
+            ss_level = ((ss_level > 0) ? 1 : 0);
+            select_edp_link_config(pConf);
+            if (pConf->lcd_control.edp_config->link_adaptive == 1) {
+                pConf->lcd_control.edp_config->vswing = 0;
+                pConf->lcd_control.edp_config->preemphasis = 0;
+            }
+            printk("edp vswing_level=%u, preemphasis_level=%u\n", pConf->lcd_control.edp_config->vswing, pConf->lcd_control.edp_config->preemphasis);
+            break;
+        case LCD_DIGITAL_LVDS:
+            if (pConf->lcd_control.lvds_config->lvds_repack_user == 0) {
+                if (pConf->lcd_basic.lcd_bits == 6)
+                    pConf->lcd_control.lvds_config->lvds_repack = 0;
+                else
+                    pConf->lcd_control.lvds_config->lvds_repack = 1;
+            }
+            break;
+        default:
+            break;
+    }
+    pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & (~(0xf << CLK_CTRL_SS))) | (ss_level << CLK_CTRL_SS));
+}
+
+//for special interface config after clk setting
+static void lcd_control_config_post(Lcd_Config_t *pConf)
+{
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            set_mipi_dsi_control_config_post(pConf);
+            break;
+        default:
+            break;
+    }
+}
+
+#ifdef CONFIG_USE_OF
+static unsigned char dsi_init_on_table[DSI_INIT_ON_MAX]={0xff,0xff};
+static unsigned char dsi_init_off_table[DSI_INIT_OFF_MAX]={0xff,0xff};
+static DSI_Config_t lcd_mipi_config = {
+    .lane_num = 4,
+    .bit_rate_min = 0,
+    .bit_rate_max = 0,
+    .factor_numerator = 0,
+    .factor_denominator = 10,
+    .transfer_ctrl = 0,
+    .dsi_init_on = &dsi_init_on_table[0],
+    .dsi_init_off = &dsi_init_off_table[0],
+    .lcd_extern_init = 0,
+};
+
+static EDP_Config_t lcd_edp_config = {
+    .max_lane_count = 4,
+    .link_user = 0,
+    .link_rate = 1,
+    .lane_count = 4,
+    .link_adaptive = 0,
+    .vswing = 0,
+    .preemphasis = 0,
+    .sync_clock_mode = 1,
+};
+
+static LVDS_Config_t lcd_lvds_config = {
+    .lvds_vswing = 1,
+    .lvds_repack_user = 0,
+    .lvds_repack = 0,
+    .pn_swap = 0,
+};
+
+static TTL_Config_t lcd_ttl_config = {
+    .rb_swap = 0,
+    .bit_swap = 0,
+};
+
+static Lcd_Config_t lcd_config = {
+    .lcd_timing = {
+        .lcd_clk = 40000000,
+        .clk_ctrl = ((1 << CLK_CTRL_AUTO) | (0 << CLK_CTRL_SS)),
+        .hvsync_valid = 1,
+        .de_valid = 1,
+        .pol_ctrl = ((0 << POL_CTRL_CLK) | (1 << POL_CTRL_DE) | (0 << POL_CTRL_VS) | (0 << POL_CTRL_HS)),
+    },
+    .lcd_effect = {
+        .rgb_base_addr = 0xf0,
+        .rgb_coeff_addr = 0x74a,
+        .dith_user = 0,
+        .vadj_brightness = 0x0,
+        .vadj_contrast = 0x80,
+        .vadj_saturation = 0x100,
+        .gamma_ctrl = ((0 << GAMMA_CTRL_REVERSE) | (1 << LCD_GAMMA_EN)),
+        .gamma_r_coeff = 100,
+        .gamma_g_coeff = 100,
+        .gamma_b_coeff = 100,
+        .set_gamma_table = set_gamma_table_lcd,
+    },
+    .lcd_control = {
+        .mipi_config = &lcd_mipi_config,
+        .edp_config = &lcd_edp_config,
+        .lvds_config = &lcd_lvds_config,
+        .ttl_config = &lcd_ttl_config,
+    },
+    .lcd_power_ctrl = {
+        .power_on_step = 0,
+        .power_off_step = 0,
+        .power_ctrl = NULL,
+    },
+};
+
+Lcd_Config_t* get_lcd_config(void)
+{
+    return &lcd_config;
+}
+#endif
+
+static void lcd_config_assign(Lcd_Config_t *pConf)
+{
+    pConf->lcd_power_ctrl.ports_ctrl = lcd_ports_ctrl;
+    pConf->lcd_power_ctrl.power_ctrl_video = lcd_power_ctrl_video;
+
+    pConf->lcd_misc_ctrl.vpp_sel = 0;
+    pConf->lcd_misc_ctrl.lcd_status = 1;
+    pConf->lcd_misc_ctrl.module_enable = lcd_module_enable;
+    pConf->lcd_misc_ctrl.module_disable = lcd_module_disable;
+    pConf->lcd_misc_ctrl.lcd_test = lcd_test;
+    pConf->lcd_misc_ctrl.print_version = print_lcd_driver_version;
+}
+
+void lcd_config_init(Lcd_Config_t *pConf)
+{
+    lcd_control_config_pre(pConf); //must before generate_clk_parameter, otherwise the clk parameter will not update base on the edp_link_rate
+
+    if ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1) {
+        printk("\nAuto generate clock parameters.\n");
+        generate_clk_parameter(pConf);
+        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
+    }
+    else {
+        printk("\nCustome clock parameters.\n");
+        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
+    }
+
+    lcd_sync_duration(pConf);
+    lcd_tcon_config(pConf);
+
+	lcd_control_config_post(pConf);
+}
+
+void lcd_config_probe(Lcd_Config_t *pConf)
+{
+    spin_lock_init(&gamma_write_lock);
+    spin_lock_init(&lcd_clk_lock);
+
+    lcd_Conf = pConf;
+    lcd_config_assign(pConf);
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            dsi_probe(pConf);
+            break;
+        case LCD_DIGITAL_EDP:
+            edp_probe();
+            break;
+        default:
+            break;
+    }
+}
+
+void lcd_config_remove(void)
+{
+    switch (lcd_Conf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            dsi_remove();
+            break;
+        case LCD_DIGITAL_EDP:
+            edp_remove();
+            break;
+        default:
+            break;
+    }
+}
diff --git a/arch/arm/mach-meson8/lcd/lcd_config.h b/arch/arm/mach-meson8/lcd/lcd_config.h
new file mode 100755
index 000000000000..325d72c53e93
--- /dev/null
+++ b/arch/arm/mach-meson8/lcd/lcd_config.h
@@ -0,0 +1,199 @@
+
+#ifndef LCD_CONFIG_H
+#define LCD_CONFIG_H
+#include <linux/types.h>
+
+//**********************************
+//lcd driver version
+//**********************************
+#define LCD_DRV_TYPE      "c8"
+#define LCD_DRV_DATE      "20140703"
+//**********************************
+
+/* for GAMMA_CNTL_PORT */
+	#define LCD_GAMMA_VCOM_POL       7
+	#define LCD_GAMMA_RVS_OUT        6
+	#define LCD_ADR_RDY              5
+	#define LCD_WR_RDY               4
+	#define LCD_RD_RDY               3
+	#define LCD_GAMMA_TR             2
+	#define LCD_GAMMA_SET            1
+	#define LCD_GAMMA_EN             0
+
+/* for GAMMA_ADDR_PORT */
+	#define LCD_H_RD                 12
+	#define LCD_H_AUTO_INC           11
+	#define LCD_H_SEL_R              10
+	#define LCD_H_SEL_G              9
+	#define LCD_H_SEL_B              8
+	#define LCD_HADR_MSB             7
+	#define LCD_HADR                 0
+
+/* for POL_CNTL_ADDR */
+	#define LCD_DCLK_SEL             14  //FOR DCLK OUTPUT
+	#define LCD_TCON_VSYNC_SEL_DVI   11  // FOR RGB format DVI output
+	#define LCD_TCON_HSYNC_SEL_DVI   10  // FOR RGB format DVI output
+	#define LCD_TCON_DE_SEL_DVI      9   // FOR RGB format DVI output
+	#define LCD_CPH3_POL             8
+	#define LCD_CPH2_POL             7
+	#define LCD_CPH1_POL             6
+	#define LCD_TCON_DE_SEL          5
+	#define LCD_TCON_VS_SEL          4
+	#define LCD_TCON_HS_SEL          3
+	#define LCD_DE_POL               2
+	#define LCD_VS_POL               1
+	#define LCD_HS_POL               0
+
+/* for DITH_CNTL_ADDR */
+	#define LCD_DITH10_EN            10
+	#define LCD_DITH8_EN             9
+	#define LCD_DITH_MD              8
+	#define LCD_DITH10_CNTL_MSB      7
+	#define LCD_DITH10_CNTL          4
+	#define LCD_DITH8_CNTL_MSB       3
+	#define LCD_DITH8_CNTL           0
+
+/* for INV_CNT_ADDR */
+	#define LCD_INV_EN               4
+	#define LCD_INV_CNT_MSB          3
+	#define LCD_INV_CNT              0
+
+/* for TCON_MISC_SEL_ADDR */
+	#define LCD_STH2_SEL             12
+	#define LCD_STH1_SEL             11
+	#define LCD_OEH_SEL              10
+	#define LCD_VCOM_SEL             9
+	#define LCD_DB_LINE_SW           8
+	#define LCD_CPV2_SEL             7
+	#define LCD_CPV1_SEL             6
+	#define LCD_STV2_SEL             5
+	#define LCD_STV1_SEL             4
+	#define LCD_OEV_UNITE            3
+	#define LCD_OEV3_SEL             2
+	#define LCD_OEV2_SEL             1
+	#define LCD_OEV1_SEL             0
+
+/* for DUAL_PORT_CNTL_ADDR */
+	#define LCD_ANALOG_SEL_CPH3      8
+	#define LCD_ANALOG_3PHI_CLK_SEL  7
+	#define LCD_LVDS_SEL54           6
+	#define LCD_LVDS_SEL27           5
+	#define LCD_TTL_SEL              4
+	#define LCD_DUAL_PIXEL           3
+	#define LCD_PORT_SWP             2
+	#define LCD_RGB_SWP              1
+	#define LCD_BIT_SWP              0
+
+/* for LVDS_PACK_CNTL_ADDR */
+	#define LCD_LD_CNT_MSB           7
+	#define LCD_LD_CNT               5
+	#define LCD_PN_SWP               4
+	#define LCD_RES                  3
+	#define LCD_LVDS_PORT_SWP        2
+	#define LCD_PACK_RVS             1
+	#define LCD_PACK_LITTLE          0
+
+ /* for LVDS_BLANK_DATA */  
+	#define LVDS_blank_data_reserved    30  // 31:30
+	#define LVDS_blank_data_r           20  // 29:20
+	#define LVDS_blank_data_g           10  // 19:10
+	#define LVDS_blank_data_b           0  //  9:0
+	
+/* for LVDS_PACK_CNTL_ADDR */  
+	#define LVDS_USE_TCON               7
+	#define LVDS_DUAL                   6
+	#define PN_SWP                      5
+	#define LSB_FIRST                   4
+	#define LVDS_RESV                   3
+	#define ODD_EVEN_SWP                2
+	#define LVDS_REPACK                 0
+
+static const unsigned gamma_sel_table[3] = {
+    LCD_H_SEL_R,
+    LCD_H_SEL_G,
+    LCD_H_SEL_B,
+};
+
+//********************************************//
+/* for video encoder */
+	#define MIPI_DELAY				8
+	#define LVDS_DELAY				8
+	#define EDP_DELAY				8
+	#define TTL_DELAY				19
+
+//********************************************//
+// for clk parameter auto generation
+//********************************************//
+/**** clk parameters bit ***/
+	//pll_ctrl
+	#define PLL_CTRL_LOCK			31
+	#define PLL_CTRL_EN				30
+	#define PLL_CTRL_RST			29
+	#define PLL_CTRL_OD				9	//[10:9]
+	#define PLL_CTRL_N				24	//[28:24]
+	#define PLL_CTRL_M				0	//[8:0]
+
+	//div_ctrl
+	#define DIV_CTRL_EDP_DIV1		24	//[26:24]
+	#define DIV_CTRL_EDP_DIV0		20	//[23:20]
+	#define DIV_CTRL_DIV_POST		12	//[14:12]
+	#define DIV_CTRL_LVDS_CLK_EN	11
+	#define DIV_CTRL_PHY_CLK_DIV2	10
+	#define DIV_CTRL_POST_SEL		8	//[9:8]
+	#define DIV_CTRL_DIV_PRE		4	//[6:4]
+
+	//clk_ctrl
+	#define CLK_CTRL_FRAC			16	//[27:16]
+	#define CLK_CTRL_LEVEL			12	//[14:12]
+	
+	#define PLL_WAIT_LOCK_CNT		200
+
+/**** clk frequency limit ***/
+	/* PLL */
+	#define PLL_M_MIN				2
+	#define PLL_M_MAX				511
+	#define PLL_N_MIN				1
+	#define PLL_N_MAX				1
+	#define PLL_FREF_MIN			(5 * 1000)
+	#define PLL_FREF_MAX			(25 * 1000)
+	#define PLL_VCO_MIN				(1200 * 1000)
+	#define PLL_VCO_MAX				(3000 * 1000)
+	/* VIDEO */
+	#define MIPI_PHY_MAX_CLK_IN		(1000 * 1000)
+	#define DIV_PRE_MAX_CLK_IN		(1500 * 1000)
+	#define DIV_POST_MAX_CLK_IN		(1000 * 1000)
+	#define CRT_VID_MAX_CLK_IN		(1300 * 1000)
+	#define ENCL_MAX_CLK_IN			(333 * 1000)
+
+	/* lcd interface video clk */
+	#define MIPI_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+	#define LVDS_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+	#define EDP_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+	#define TTL_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+
+	/* clk max error */
+	#define MAX_ERROR				(2 * 1000)
+
+#define CRT_VID_DIV_MAX				15
+
+#define OD_SEL_MAX					3
+#define DIV_PRE_SEL_MAX				6
+#define EDP_DIV0_SEL_MAX			15
+#define EDP_DIV1_SEL_MAX			8
+
+static const unsigned od_table[4] = {1,2,4,8};
+static const unsigned div_pre_table[6] = {1,2,3,4,5,6};
+static const unsigned edp_div0_table[15] = {1,2,3,4,5,7,8,9,11,13,17,19,23,29,31};
+static const unsigned edp_div1_table[8] = {1,2,4,5,6,7,9,13};
+//********************************************//
+
+#define SS_LEVEL_MAX	5
+static const char *lcd_ss_level_table[]={
+	"0",
+	"0.5%",
+	"1%",
+	"1.5%",
+	"2%",
+};
+
+#endif
diff --git a/drivers/amlogic/display/vout/mipi_dsi_util.c b/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
similarity index 84%
rename from drivers/amlogic/display/vout/mipi_dsi_util.c
rename to arch/arm/mach-meson8/lcd/mipi_dsi_util.c
index 0c626ad4d053..601aa777b774 100755
--- a/drivers/amlogic/display/vout/mipi_dsi_util.c
+++ b/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
@@ -1,26 +1,21 @@
 #include <linux/types.h>
 #include <mach/cpu.h>
 #include <plat/cpu.h>
+#include <mach/io.h>
+#include <plat/io.h>
+#include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
-#if ((MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)||(MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-#include <linux/amlogic/vout/lcdoutc.h>
 #include <linux/kernel.h>
-#include "mipi_dsi_util.h"
+#include <mach/lcd_reg.h>
 #include <mach/mipi_dsi_reg.h>
-#include <linux/amlogic/vout/lcd_reg.h>
-
-#include <mach/io.h>
-#include <plat/io.h>
-#include <linux/delay.h>
+#include <mach/lcdoutc.h>
+#include <linux/amlogic/vout/lcdoutc.h>
 #include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "lcd_config.h"
+#include "mipi_dsi_util.h"
 
-//#define PRINT_DEBUG_INFO
-#ifdef PRINT_DEBUG_INFO
 #define DPRINT(...)		printk(__VA_ARGS__)
-#else
-#define DPRINT(...)
-#endif
 
 //===============================================================================
 // Define MIPI DSI Default config
@@ -28,7 +23,7 @@
 #define MIPI_DSI_VIRTUAL_CHAN_ID        0                       // Range [0,3]
 #define MIPI_DSI_CMD_TRANS_TYPE         DCS_TRANS_LP            // Define DSI command transfer type: high speed or low power
 #define MIPI_DSI_DCS_ACK_TYPE           MIPI_DSI_DCS_NO_ACK     // Define if DSI command need ack: req_ack or no_ack
-#define MIPI_DSI_VIDEO_MODE_TYPE        BURST_MODE              // Applicable only to video mode. Define picture data transfer method: non-burst sync pulse; non-burst sync event; or burst.
+#define MIPI_DSI_VIDEO_MODE_TYPE        BURST_MODE              // Applicable only to video mode. Define data transfer method: non-burst sync pulse; non-burst sync event; or burst.
 #define MIPI_DSI_TEAR_SWITCH            MIPI_DCS_DISABLE_TEAR
 #define CMD_TIMEOUT_CNT                 3000
 //===============================================================================
@@ -54,8 +49,7 @@ static const char *video_mode_type_table[] = {
 
 static DSI_Phy_t dsi_phy_config;
 static DSI_Config_t *dsi_config = NULL;
-static unsigned char dsi_init_on_table[DSI_INIT_ON_MAX]={0xff,0xff};
-static unsigned char dsi_init_off_table[DSI_INIT_OFF_MAX]={0xff,0xff};
+static struct class *dsi_debug_class = NULL;
 static unsigned char dsi_init_on_table_dft[] = {
     0x05,0x11,0,
     0xff,50,
@@ -64,18 +58,10 @@ static unsigned char dsi_init_on_table_dft[] = {
     0xff,0xff,
 };
 
-unsigned char *get_dsi_init_table(int flag)
-{
-    if (flag > 0)
-        return &dsi_init_on_table[0];
-    else
-        return &dsi_init_off_table[0];
-}
-
 static inline void print_mipi_cmd_status(int cnt, unsigned status)
 {
     if (cnt == 0) {
-        printk("cmd error: status=0x%04x, int0=0x%06x, int1=0x%06x\n", status, READ_LCD_REG(MIPI_DSI_DWC_INT_ST0_OS), READ_LCD_REG(MIPI_DSI_DWC_INT_ST1_OS));
+        DPRINT("cmd error: status=0x%04x, int0=0x%06x, int1=0x%06x\n", status, READ_LCD_REG(MIPI_DSI_DWC_INT_ST0_OS), READ_LCD_REG(MIPI_DSI_DWC_INT_ST1_OS));
     }
 }
 
@@ -85,97 +71,97 @@ static void print_info(void)
     unsigned temp;
 
     if (dsi_config == NULL) {
-        printk("dsi config is NULL\n");
+        DPRINT("dsi config is NULL\n");
         return;
     }
-    printk("================================================\n");
-    printk("MIPI DSI Config\n");
-    printk(" Lane Num:              %d\n", dsi_config->lane_num);
-    printk(" Bit Rate min:          %dMHz\n", (dsi_config->bit_rate_min / 1000));
-    printk(" Bit Rate max:          %dMHz\n", (dsi_config->bit_rate_max / 1000));
-    printk(" Bit Rate:              %d.%03dMHz\n", (dsi_config->bit_rate / 1000000), (dsi_config->bit_rate % 1000000) / 1000);
-    printk(" Pclk lanebyte factor:  %d\n", ((dsi_config->factor_numerator * 100 / dsi_config->factor_denominator) + 5) / 10);
-    printk(" Operation mode:\n");
-    printk("     init:              %s\n", ((dsi_config->operation_mode == OPERATION_COMMAND_MODE>>BIT_OPERATION_MODE_INIT) & 1) ? "COMMAND":"VIDEO");
-    printk("     display:           %s\n", ((dsi_config->operation_mode == OPERATION_COMMAND_MODE>>BIT_OPERATION_MODE_DISP) & 1) ? "COMMAND":"VIDEO");
-    printk(" Transfer control:\n");
-    printk("     clk auto stop:     %d\n", ((dsi_config->transfer_ctrl>>BIT_TRANS_CTRL_CLK) & 1));
-    printk("     transfer switch:   %d\n", ((dsi_config->transfer_ctrl>>BIT_TRANS_CTRL_SWITCH) & 3));
+    DPRINT("================================================\n");
+    DPRINT("MIPI DSI Config\n");
+    DPRINT(" Lane Num:              %d\n", dsi_config->lane_num);
+    DPRINT(" Bit Rate min:          %dMHz\n", (dsi_config->bit_rate_min / 1000));
+    DPRINT(" Bit Rate max:          %dMHz\n", (dsi_config->bit_rate_max / 1000));
+    DPRINT(" Bit Rate:              %d.%03dMHz\n", (dsi_config->bit_rate / 1000000), (dsi_config->bit_rate % 1000000) / 1000);
+    DPRINT(" Pclk lanebyte factor:  %d\n", ((dsi_config->factor_numerator * 100 / dsi_config->factor_denominator) + 5) / 10);
+    DPRINT(" Operation mode:\n");
+    DPRINT("     init:              %s\n", ((dsi_config->operation_mode>>BIT_OPERATION_MODE_INIT) & 1) ? "COMMAND":"VIDEO");
+    DPRINT("     display:           %s\n", ((dsi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1) ? "COMMAND":"VIDEO");
+    DPRINT(" Transfer control:\n");
+    DPRINT("     clk auto stop:     %d\n", ((dsi_config->transfer_ctrl>>BIT_TRANS_CTRL_CLK) & 1));
+    DPRINT("     transfer switch:   %d\n", ((dsi_config->transfer_ctrl>>BIT_TRANS_CTRL_SWITCH) & 3));
     if(dsi_config->video_mode_type == NON_BURST_SYNC_PULSE) {
-        printk(" Video mode type:       NON_BURST_SYNC_PULSE\n");
+        DPRINT(" Video mode type:       NON_BURST_SYNC_PULSE\n");
     }
     else if(dsi_config->video_mode_type == NON_BURST_SYNC_EVENT) {
-        printk(" Video mode type:       NON_BURST_SYNC_EVENT\n");
+        DPRINT(" Video mode type:       NON_BURST_SYNC_EVENT\n");
     }
     else if(dsi_config->video_mode_type == BURST_MODE) {
-        printk(" Video mode type:       BURST_MODE\n");
+        DPRINT(" Video mode type:       BURST_MODE\n");
     }
 
-    //printk(" Venc format:           %d\n", dsi_config->venc_fmt);
-    printk(" Data Format:           %s\n\n", video_mode_type_table[dsi_config->dpi_data_format]);
-    //printk(" POLARITY:              HIGH ACTIVE\n");
-    //printk(" Enable CRC/ECC/BTA\n");
+    //DPRINT(" Venc format:           %d\n", dsi_config->venc_fmt);
+    DPRINT(" Data Format:           %s\n\n", video_mode_type_table[dsi_config->dpi_data_format]);
+    //DPRINT(" POLARITY:              HIGH ACTIVE\n");
+    //DPRINT(" Enable CRC/ECC/BTA\n");
 
     temp = dsi_config->bit_rate / 8 / dsi_phy_config.lp_tesc;
-    printk("DSI LP escape clock:    %d.%03dMHz\n", (temp / 1000000), (temp % 1000000) / 1000);
+    DPRINT("DSI LP escape clock:    %d.%03dMHz\n", (temp / 1000000), (temp % 1000000) / 1000);
     if (dsi_config->dsi_init_on) {
-        printk("DSI INIT ON:\n");
+        DPRINT("DSI INIT ON:\n");
         i = 0;
         while (i < DSI_INIT_ON_MAX) {
             if (dsi_config->dsi_init_on[i] == 0xff) {
                 n = 2;
                 if (dsi_config->dsi_init_on[i+1] == 0xff) {
-                    printk("    0x%02x,0x%02x,\n", dsi_config->dsi_init_on[i], dsi_config->dsi_init_on[i+1]);
+                    DPRINT("    0x%02x,0x%02x,\n", dsi_config->dsi_init_on[i], dsi_config->dsi_init_on[i+1]);
                     break;
                 }
                 else {
-                    printk("    0x%02x,%d,\n", dsi_config->dsi_init_on[i], dsi_config->dsi_init_on[i+1]);
+                    DPRINT("    0x%02x,%d,\n", dsi_config->dsi_init_on[i], dsi_config->dsi_init_on[i+1]);
                 }
             }
             else {
                 n = 3 + dsi_config->dsi_init_on[i+2];
-                printk("    ");
+                DPRINT("    ");
                 for (j=0; j<n; j++) {
                     if (j == 2)
-                        printk("%d,", dsi_config->dsi_init_on[i+j]);
+                        DPRINT("%d,", dsi_config->dsi_init_on[i+j]);
                     else
-                        printk("0x%02x,", dsi_config->dsi_init_on[i+j]);
+                        DPRINT("0x%02x,", dsi_config->dsi_init_on[i+j]);
                 }
-                printk("\n");
+                DPRINT("\n");
             }
             i += n;
         }
     }
     if (dsi_config->dsi_init_off) {
-        printk("DSI INIT OFF:\n");
+        DPRINT("DSI INIT OFF:\n");
         i = 0;
         while (i < DSI_INIT_OFF_MAX) {
             if (dsi_config->dsi_init_off[i] == 0xff) {
                 n = 2;
                 if (dsi_config->dsi_init_off[i+1] == 0xff) {
-                    printk("    0x%02x,0x%02x,\n", dsi_config->dsi_init_off[i], dsi_config->dsi_init_off[i+1]);
+                    DPRINT("    0x%02x,0x%02x,\n", dsi_config->dsi_init_off[i], dsi_config->dsi_init_off[i+1]);
                     break;
                 }
                 else {
-                    printk("    0x%02x,%d,\n", dsi_config->dsi_init_off[i], dsi_config->dsi_init_off[i+1]);
+                    DPRINT("    0x%02x,%d,\n", dsi_config->dsi_init_off[i], dsi_config->dsi_init_off[i+1]);
                 }
             }
             else {
                 n = 3 + dsi_config->dsi_init_off[i+2];
-                printk("    ");
+                DPRINT("    ");
                 for (j=0; j<n; j++) {
                     if (j == 2)
-                        printk("%d,", dsi_config->dsi_init_off[i+j]);
+                        DPRINT("%d,", dsi_config->dsi_init_off[i+j]);
                     else
-                        printk("0x%02x,", dsi_config->dsi_init_off[i+j]);
+                        DPRINT("0x%02x,", dsi_config->dsi_init_off[i+j]);
                 }
-                printk("\n");
+                DPRINT("\n");
             }
             i += n;
         }
     }
-    printk("DSI INIT EXTERN:        %d\n", dsi_config->lcd_extern_init);
-    printk("================================================\n");
+    DPRINT("DSI INIT EXTERN:        %d\n", dsi_config->lcd_extern_init);
+    DPRINT("================================================\n");
 }
 
 static void print_dphy_info(void)
@@ -183,8 +169,8 @@ static void print_dphy_info(void)
     unsigned temp;
 
     temp = ((1000000 * 100) / (dsi_config->bit_rate / 1000)) * 8;
-    printk("================================================\n");
-    printk("MIPI DSI DPHY timing (unit: ns)\n"
+    DPRINT("================================================\n");
+    DPRINT("MIPI DSI DPHY timing (unit: ns)\n"
         " UI:                  %d.%02d\n"
         " LP LPX:              %d\n"
         " LP TA_SURE:          %d\n"
@@ -207,7 +193,7 @@ static void print_dphy_info(void)
         (temp * dsi_phy_config.hs_zero / 100), (temp * dsi_phy_config.hs_prepare / 100), (temp * dsi_phy_config.clk_trail / 100), 
         (temp * dsi_phy_config.clk_post / 100), (temp * dsi_phy_config.clk_zero / 100), (temp * dsi_phy_config.clk_prepare / 100),
         (temp * dsi_phy_config.clk_pre / 100), (temp * dsi_phy_config.init / 100), (temp * dsi_phy_config.wakeup / 100));
-    printk("================================================\n");
+    DPRINT("================================================\n");
 }
 
 // -----------------------------------------------------------------------------
@@ -220,7 +206,7 @@ static void check_phy_status(void)
         udelay(6);
     }
     while((( READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS ) >> BIT_PHY_STOPSTATECLKLANE) & 0x1) == 0){
-        DPRINT(" Waiting STOP STATE LANE\n");
+        DBG_PRINT(" Waiting STOP STATE LANE\n");
         udelay(6);
     }
 }
@@ -329,10 +315,10 @@ static unsigned int wait_for_generic_read_response(void)
 static unsigned int generic_if_wr(unsigned int address, unsigned int data_in)
 {
     if(address != MIPI_DSI_DWC_GEN_HDR_OS && address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
-        DPRINT(" Error Address : 0x%x\n", address);
+        DBG_PRINT(" Error Address : 0x%x\n", address);
     }
 
-    DPRINT("address 0x%x = 0x%08x\n", address, data_in);
+    DBG_PRINT("address 0x%x = 0x%08x\n", address, data_in);
     WRITE_LCD_REG(address, data_in);
 
     return 0;
@@ -347,7 +333,7 @@ static unsigned int generic_if_rd(unsigned int address)
     unsigned int data_out;
 
     if(address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
-        DPRINT(" Error Address : %x\n", address);
+        DBG_PRINT(" Error Address : %x\n", address);
     }
 
     data_out = READ_DSI_REG(address);
@@ -365,8 +351,8 @@ static unsigned int generic_read_packet_0_para(unsigned char data_type, unsigned
 {
     unsigned int read_data;
 
-    // DPRINT(" para is %x, dcs_command is %x\n", para, dcs_command);
-    // DPRINT(" vc_id %x, data_type is %x\n", vc_id, data_type);
+    // DBG_PRINT(" para is %x, dcs_command is %x\n", para, dcs_command);
+    // DBG_PRINT(" vc_id %x, data_type is %x\n", vc_id, data_type);
     generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((0 << BIT_GEN_WC_MSBYTE)                           |
                                             (((unsigned int)dcs_command) << BIT_GEN_WC_LSBYTE) |
                                             (((unsigned int)vc_id) << BIT_GEN_VC)              |
@@ -512,10 +498,12 @@ static void dsi_write_long_packet(unsigned char data_type, unsigned char vc_id,
 //                      DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
 //                      DT_GEN_LONG_WR, DT_DCS_LONG_WR,
 //                      DT_SET_MAX_RPS
+// Return:              command number
 // ----------------------------------------------------------------------------
-void dsi_write_cmd(unsigned char* payload)
+int dsi_write_cmd(unsigned char* payload)
 {
     int i=0, j=0;
+    int num = 0;
     unsigned char vc_id = MIPI_DSI_VIRTUAL_CHAN_ID;
     unsigned int req_ack = MIPI_DSI_DCS_ACK_TYPE;
 
@@ -548,7 +536,7 @@ void dsi_write_cmd(unsigned char* payload)
                     dsi_write_long_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
                     break;
                 case DT_SET_MAX_RPS:
-                    printk("to do data_type: 0x%2x\n", payload[i]);
+                    DPRINT("to do data_type: 0x%2x\n", payload[i]);
                     break;
                 case DT_TURN_ON:
                     WRITE_LCD_REG_BITS(MIPI_DSI_TOP_CNTL, 1, 2, 1);
@@ -561,11 +549,14 @@ void dsi_write_cmd(unsigned char* payload)
                     mdelay(20); //wait for vsync trigger
                     break;
                 default:
-                    printk("un-support data_type: 0x%02x\n", payload[i]);
+                    DPRINT("un-support data_type: 0x%02x\n", payload[i]);
             }
         }
         i += j;
+        num++;
     }
+
+    return num;
 }
 
 static void set_dsi_phy_config(DSI_Phy_t *dphy, unsigned dsi_ui)
@@ -592,7 +583,7 @@ static void set_dsi_phy_config(DSI_Phy_t *dphy, unsigned dsi_ui)
     dphy->init = (DPHY_TIME_INIT(t_ui) + t_lane_byte - 1) / t_lane_byte;
     dphy->wakeup = (DPHY_TIME_WAKEUP(t_ui) + t_lane_byte - 1) / t_lane_byte;
 
-    DPRINT("lp_tesc = 0x%02x\n"
+    DBG_PRINT("lp_tesc = 0x%02x\n"
             "lp_lpx = 0x%02x\n"
             "lp_ta_sure = 0x%02x\n"
             "lp_ta_go = 0x%02x\n"
@@ -662,7 +653,7 @@ static void dsi_phy_init(DSI_Phy_t *dphy, unsigned char lane_num)
 
 static void mipi_dsi_phy_config(Lcd_Config_t *pConf)
 {
-    DPRINT("%s\n", __func__);
+    DBG_PRINT("%s\n", __func__);
     //Digital
     // Power up DSI
     WRITE_LCD_REG(MIPI_DSI_DWC_PWR_UP_OS, 1);
@@ -690,25 +681,36 @@ static void mipi_dsi_phy_config(Lcd_Config_t *pConf)
 
 static void dsi_video_config(Lcd_Config_t *pConf)
 {
+    unsigned int hline, hsa, hbp;
+    unsigned int vsa, vbp, vfp, vact;
     DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
 
-    DPRINT(" ============= VIDEO TIMING SETTING =============\n");
-    DPRINT(" HLINE        = %d\n", cfg->hline);
-    DPRINT(" HSA          = %d\n", cfg->hsa);
-    DPRINT(" HBP          = %d\n", cfg->hbp);
-    DPRINT(" VSA          = %d\n", cfg->vsa);
-    DPRINT(" VBP          = %d\n", cfg->vbp);
-    DPRINT(" VFP          = %d\n", cfg->vfp);
-    DPRINT(" VACT         = %d\n", cfg->vact);
-    DPRINT(" ================================================\n");
-
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HLINE_TIME_OS,    cfg->hline);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HSA_TIME_OS,      cfg->hsa);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HBP_TIME_OS,      cfg->hbp);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VSA_LINES_OS,     cfg->vsa);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VBP_LINES_OS,     cfg->vbp);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VFP_LINES_OS,     cfg->vfp);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VACTIVE_LINES_OS, cfg->vact);
+    hline =(pConf->lcd_basic.h_period * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;  // Rounded. Applicable for Period(pixclk)/Period(bytelaneclk)=9/16
+    hsa =(pConf->lcd_timing.hsync_width * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
+    hbp =((pConf->lcd_timing.hsync_bp-pConf->lcd_timing.hsync_width) * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
+
+    vsa = pConf->lcd_timing.vsync_width;
+    vbp = pConf->lcd_timing.vsync_bp - pConf->lcd_timing.vsync_width;
+    vfp = pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp - pConf->lcd_basic.v_active;
+    vact = pConf->lcd_basic.v_active;
+
+    DBG_PRINT(" ============= VIDEO TIMING SETTING =============\n");
+    DBG_PRINT(" HLINE        = %d\n", hline);
+    DBG_PRINT(" HSA          = %d\n", hsa);
+    DBG_PRINT(" HBP          = %d\n", hbp);
+    DBG_PRINT(" VSA          = %d\n", vsa);
+    DBG_PRINT(" VBP          = %d\n", vbp);
+    DBG_PRINT(" VFP          = %d\n", vfp);
+    DBG_PRINT(" VACT         = %d\n", vact);
+    DBG_PRINT(" ================================================\n");
+
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HLINE_TIME_OS,    hline);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HSA_TIME_OS,      hsa);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HBP_TIME_OS,      hbp);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VSA_LINES_OS,     vsa);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VBP_LINES_OS,     vbp);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VFP_LINES_OS,     vfp);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VACTIVE_LINES_OS, vact);
 }
 
 static void startup_transfer_cmd(void)
@@ -775,7 +777,7 @@ static void set_mipi_dsi_host(int lane_num,                      // lane number,
         case COLOR_RGB_444 :
             break;
         default :
-            DPRINT(" Error: un-support data Format So Far, Please Add More\n");
+            DBG_PRINT(" Error: un-support data Format So Far, Please Add More\n");
             break;
     }    /*switch(dpi_data_format)*/
     num_of_chunk = p->lcd_basic.h_active / pixel_per_chunk;
@@ -785,7 +787,7 @@ static void set_mipi_dsi_host(int lane_num,                      // lane number,
         if(chunk_overhead >= 6) {                                              // if room for null_vid's head(4)+crc(2)
             vid_null_size = chunk_overhead-6;                                  // chunk_overhead-null_vid's head(4)+crc(2) = null_vid's payload
         } else {
-            DPRINT(" No room for null, chunk_overhead is %d\n", chunk_overhead);
+            DBG_PRINT(" No room for null, chunk_overhead is %d\n", chunk_overhead);
         }
     }
     // -----------------------------------------------------
@@ -811,8 +813,8 @@ static void set_mipi_dsi_host(int lane_num,                      // lane number,
     // 2.3   Configure Signal polarity
     WRITE_LCD_REG( MIPI_DSI_DWC_DPI_CFG_POL_OS, (0x0 << BIT_COLORM_ACTIVE_LOW) |
                         (0x0 << BIT_SHUTD_ACTIVE_LOW)  |
-                        ((((p->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1) ? 0 : 1) << BIT_HSYNC_ACTIVE_LOW)  |
-                        ((((p->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1) ? 0 : 1) << BIT_VSYNC_ACTIVE_LOW)  |
+                        (0 << BIT_HSYNC_ACTIVE_LOW)  |//(((p->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1) << BIT_HSYNC_ACTIVE_LOW)  |
+                        (0 << BIT_VSYNC_ACTIVE_LOW)  |//(((p->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1) << BIT_VSYNC_ACTIVE_LOW)  |
                         (0x0 << BIT_DATAEN_ACTIVE_LOW));
 
     if (operation_mode == OPERATION_VIDEO_MODE) {
@@ -846,14 +848,14 @@ static void set_mipi_dsi_host(int lane_num,                      // lane number,
         else {                                                                     // non burst mode
             WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, num_of_chunk);                     // HACT/VID_PKT_SIZE
             WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, vid_null_size);                     // video null size
-            DPRINT(" ============== NON_BURST SETTINGS =============\n");
-            DPRINT(" pixel_per_chunk       = %d\n", pixel_per_chunk);
-            DPRINT(" num_of_chunk          = %d\n", num_of_chunk);
-            DPRINT(" totol_bytes_per_chunk = %d\n", totol_bytes_per_chunk);
-            DPRINT(" byte_per_chunk        = %d\n", byte_per_chunk);
-            DPRINT(" chunk_overhead        = %d\n", chunk_overhead);
-            DPRINT(" vid_null_size         = %d\n", vid_null_size);
-            DPRINT(" ===============================================\n");
+            DBG_PRINT(" ============== NON_BURST SETTINGS =============\n");
+            DBG_PRINT(" pixel_per_chunk       = %d\n", pixel_per_chunk);
+            DBG_PRINT(" num_of_chunk          = %d\n", num_of_chunk);
+            DBG_PRINT(" totol_bytes_per_chunk = %d\n", totol_bytes_per_chunk);
+            DBG_PRINT(" byte_per_chunk        = %d\n", byte_per_chunk);
+            DBG_PRINT(" chunk_overhead        = %d\n", chunk_overhead);
+            DBG_PRINT(" vid_null_size         = %d\n", vid_null_size);
+            DBG_PRINT(" ===============================================\n");
         }
 
         // 4     Configure the video relative parameters according to the output type
@@ -912,12 +914,12 @@ static void mipi_dsi_host_config(Lcd_Config_t *pConf)
     dpi_data_format = pConf->lcd_control.mipi_config->dpi_data_format;
     lane_num        = pConf->lcd_control.mipi_config->lane_num;
 
-#ifdef PRINT_DEBUG_INFO
+#ifdef LCD_DEBUG_INFO
     print_info();
     print_dphy_info();
 #endif
 
-    DPRINT("Set mipi_dsi_host\n");
+    DBG_PRINT("Set mipi_dsi_host\n");
     set_mipi_dcs(MIPI_DSI_CMD_TRANS_TYPE,              // 0: high speed, 1: low power
                  MIPI_DSI_DCS_ACK_TYPE,                // if need bta ack check
                  MIPI_DSI_TEAR_SWITCH);                // enable tear ack
@@ -943,7 +945,7 @@ void mipi_dsi_link_on(Lcd_Config_t *pConf)
     struct aml_lcd_extern_driver_t *lcd_extern_driver;
     unsigned int init_flag = 0;
 
-    printk("%s\n", __FUNCTION__);
+    DPRINT("%s\n", __FUNCTION__);
     operation_mode_disp = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
     video_mode_type = pConf->lcd_control.mipi_config->video_mode_type;
     venc_format     = pConf->lcd_control.mipi_config->venc_fmt;
@@ -954,26 +956,24 @@ void mipi_dsi_link_on(Lcd_Config_t *pConf)
     if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
         lcd_extern_driver = aml_lcd_extern_get_driver();
         if (lcd_extern_driver == NULL) {
-            printk("no lcd_extern driver\n");
+            DPRINT("no lcd_extern driver\n");
         }
         else {
             if (lcd_extern_driver->init_on_cmd_8) {
-                dsi_write_cmd(lcd_extern_driver->init_on_cmd_8);
-                printk("[extern]%s dsi init on\n", lcd_extern_driver->name);
+                init_flag += dsi_write_cmd(lcd_extern_driver->init_on_cmd_8);
+                DPRINT("[extern]%s dsi init on\n", lcd_extern_driver->name);
             }
-            init_flag++;
         }
     }
 
     if (pConf->lcd_control.mipi_config->dsi_init_on) {
-        dsi_write_cmd(pConf->lcd_control.mipi_config->dsi_init_on);
-        init_flag++;
-        DPRINT("dsi init on\n");
+        init_flag += dsi_write_cmd(pConf->lcd_control.mipi_config->dsi_init_on);
+        DBG_PRINT("dsi init on\n");
     }
 
     if (init_flag == 0) {
+        DPRINT("[warning]: not init for mipi-dsi, use default command\n");
         dsi_write_cmd(dsi_init_on_table_dft);
-        printk("[warning]: not init for mipi-dsi, use default command\n");
     }
 
     if (operation_mode_disp != ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1)) {
@@ -995,18 +995,18 @@ void mipi_dsi_link_off(Lcd_Config_t *pConf)
 
     if (pConf->lcd_control.mipi_config->dsi_init_off) {
         dsi_write_cmd(pConf->lcd_control.mipi_config->dsi_init_off);
-        DPRINT("dsi init off\n");
+        DBG_PRINT("dsi init off\n");
     }
 
     if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
         lcd_extern_driver = aml_lcd_extern_get_driver();
         if (lcd_extern_driver == NULL) {
-            printk("no lcd_extern driver\n");
+            DPRINT("no lcd_extern driver\n");
         }
         else {
             if (lcd_extern_driver->init_off_cmd_8) {
                 dsi_write_cmd(lcd_extern_driver->init_off_cmd_8);
-                printk("[extern]%s dsi init off\n", lcd_extern_driver->name);
+                DPRINT("[extern]%s dsi init off\n", lcd_extern_driver->name);
             }
         }
     }
@@ -1017,22 +1017,17 @@ void set_mipi_dsi_control_config(Lcd_Config_t *pConf)
     unsigned int bit_rate;
     DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
 
-    dsi_config = pConf->lcd_control.mipi_config;
     if (cfg->bit_rate_max == 0) {
         bit_rate = ((pConf->lcd_timing.lcd_clk / 1000) * 3 * 8) / cfg->lane_num;
         cfg->bit_rate_min = bit_rate - 20*1000;
         cfg->bit_rate_max = bit_rate - 20*1000 + (pConf->lcd_timing.lcd_clk / 1000);
-        printk("mipi dsi bit_rate min=%dMHz, max=%dMHz\n", (cfg->bit_rate_min / 1000), (cfg->bit_rate_max / 1000));
-    }
-    else {
-        cfg->bit_rate_min *= 1000;
-        cfg->bit_rate_max *= 1000;
+        DPRINT("mipi dsi bit_rate min=%dMHz, max=%dMHz\n", (cfg->bit_rate_min / 1000), (cfg->bit_rate_max / 1000));
     }
     if (cfg->bit_rate_max < (PLL_VCO_MIN / od_table[OD_SEL_MAX-1])) {
-        printk("[error]: mipi-dsi can't support %dMHz bit_rate (min bit_rate=%dMHz)\n", (cfg->bit_rate_max / 1000), ((PLL_VCO_MIN / od_table[OD_SEL_MAX-1]) / 1000));
+        DPRINT("[error]: mipi-dsi can't support %dMHz bit_rate (min bit_rate=%dMHz)\n", (cfg->bit_rate_max / 1000), ((PLL_VCO_MIN / od_table[OD_SEL_MAX-1]) / 1000));
     }
     if (cfg->bit_rate_max > MIPI_PHY_MAX_CLK_IN) {
-        printk("[warning]: mipi-dsi bit_rate_max %dMHz is out of spec (%dMHz)\n", (cfg->bit_rate_max / 1000), (MIPI_PHY_MAX_CLK_IN / 1000));
+        DPRINT("[warning]: mipi-dsi bit_rate_max %dMHz is out of spec (%dMHz)\n", (cfg->bit_rate_max / 1000), (MIPI_PHY_MAX_CLK_IN / 1000));
     }
 
     cfg->video_mode_type = MIPI_DSI_VIDEO_MODE_TYPE;
@@ -1063,39 +1058,23 @@ void set_mipi_dsi_control_config(Lcd_Config_t *pConf)
 
 void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf)
 {
-    unsigned pre_div, post_div, xd;
     unsigned pclk, lanebyteclk;
     DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
 
-    post_div = (((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_DIV_POST) & 0x7) + 1;
-    pre_div = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_DIV_PRE) & 0x7;
-    pre_div = div_pre_table[pre_div];
-    xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
-
     pclk = pConf->lcd_timing.lcd_clk;
-    cfg->bit_rate = pclk * pre_div * post_div * xd;
 
     if (cfg->factor_numerator == 0) {
         lanebyteclk = cfg->bit_rate / 8;
-        DPRINT("pixel_clk = %d.%03dMHz, bit_rate = %d.%03dMHz, lanebyteclk = %d.%03dMHz\n", (pclk / 1000000), ((pclk / 1000) % 1000), 
+        DBG_PRINT("pixel_clk = %d.%03dMHz, bit_rate = %d.%03dMHz, lanebyteclk = %d.%03dMHz\n", (pclk / 1000000), ((pclk / 1000) % 1000), 
                  (cfg->bit_rate / 1000000), ((cfg->bit_rate / 1000) % 1000), (lanebyteclk / 1000000), ((lanebyteclk / 1000) % 1000));
 
         cfg->factor_denominator = lanebyteclk/1000;
         cfg->factor_numerator = pclk/1000;
         //cfg->factor_denominator = 10;
     }
-    DPRINT("d=%d, n=%d, factor=%d.%02d\n", cfg->factor_denominator, cfg->factor_numerator, (cfg->factor_denominator/cfg->factor_numerator), 
+    DBG_PRINT("d=%d, n=%d, factor=%d.%02d\n", cfg->factor_denominator, cfg->factor_numerator, (cfg->factor_denominator/cfg->factor_numerator), 
              ((cfg->factor_denominator % cfg->factor_numerator) * 100 / cfg->factor_numerator));
 
-    cfg->hline =(pConf->lcd_basic.h_period * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;  // Rounded. Applicable for Period(pixclk)/Period(bytelaneclk)=9/16
-    cfg->hsa =(pConf->lcd_timing.hsync_width * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
-    cfg->hbp =((pConf->lcd_timing.hsync_bp-pConf->lcd_timing.hsync_width) * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
-
-    cfg->vsa = pConf->lcd_timing.vsync_width;
-    cfg->vbp = pConf->lcd_timing.vsync_bp - pConf->lcd_timing.vsync_width;
-    cfg->vfp = pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp - pConf->lcd_basic.v_active;
-    cfg->vact = pConf->lcd_basic.v_active;
-
     set_dsi_phy_config(&dsi_phy_config, cfg->bit_rate);
 }
 
@@ -1115,7 +1094,7 @@ void set_mipi_dsi_control(Lcd_Config_t *pConf)
 
 void mipi_dsi_off(void)
 {
-    DPRINT("poweroff dsi digital\n");
+    DBG_PRINT("poweroff dsi digital\n");
     // Power down DSI
     WRITE_LCD_REG(MIPI_DSI_DWC_PWR_UP_OS, 0);
 
@@ -1124,7 +1103,7 @@ void mipi_dsi_off(void)
     // WRITE_LCD_REG(MIPI_DSI_DWC_PHY_RSTZ_OS, 0xc);
 
     WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0x1f);
-    DPRINT("MIPI_DSI_PHY_CTRL=0x%x\n", READ_DSI_REG(MIPI_DSI_PHY_CTRL)); //read
+    DBG_PRINT("MIPI_DSI_PHY_CTRL=0x%x\n", READ_DSI_REG(MIPI_DSI_PHY_CTRL)); //read
     WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL, 0, 7, 1);
 }
 
@@ -1154,9 +1133,9 @@ static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, cons
             num = 1;
             t[0] = 0;
             ret = sscanf(buf, "read %x %u", &t[0], &num);
-            printk("read dsi phy reg:\n");
+            DPRINT("read dsi phy reg:\n");
             for (i=0; i<num; i++) {
-                printk("  0x%04x = 0x%08x\n", (t[0]+i), READ_DSI_REG((t[0]+i)));
+                DPRINT("  0x%04x = 0x%08x\n", (t[0]+i), READ_DSI_REG((t[0]+i)));
             }
             break;
         case 'w': //write
@@ -1164,7 +1143,7 @@ static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, cons
             t[1] = 0;
             ret = sscanf(buf, "write %x %x", &t[0], &t[1]);
             WRITE_DSI_REG(t[0], t[1]);
-            printk("write dsi phy reg 0x%04x = 0x%08x, readback 0x%08x\n", t[0], t[1], READ_DSI_REG(t[0]));
+            DPRINT("write dsi phy reg 0x%04x = 0x%08x, readback 0x%08x\n", t[0], t[1], READ_DSI_REG(t[0]));
             break;
         case 'i':
             print_info();
@@ -1173,7 +1152,7 @@ static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, cons
             print_dphy_info();
             break;
         default:
-            printk("wrong format of dsi debug command.\n");
+            DPRINT("wrong format of dsi debug command.\n");
             break;
     }
 
@@ -1187,29 +1166,53 @@ static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, cons
 static struct class_attribute dsi_debug_class_attrs[] = {
     __ATTR(debug, S_IRUGO | S_IWUSR, dsi_debug_help, dsi_debug),
     __ATTR(help, S_IRUGO | S_IWUSR, dsi_debug_help, NULL),
-    __ATTR_NULL
 };
 
-static struct class aml_dsi_debug_class = {
-    .name = "dsi",
-    .class_attrs = dsi_debug_class_attrs,
-};
+static int creat_dsi_attr(void)
+{
+	int i;
+
+	dsi_debug_class = class_create(THIS_MODULE, "dsi");
+	if(IS_ERR(dsi_debug_class)) {
+		printk("create dsi debug class fail\n");
+		return -1;
+	}
+	//create class attr
+	for(i=0;i<ARRAY_SIZE(dsi_debug_class_attrs);i++) {
+		if (class_create_file(dsi_debug_class, &dsi_debug_class_attrs[i])) {
+			printk("create dsi debug attribute %s fail\n",dsi_debug_class_attrs[i].attr.name);
+		}
+	}
+
+	return 0;
+}
+static int remove_dsi_attr(void)
+{
+    int i;
+
+    if (dsi_debug_class == NULL)
+        return -1;
+
+    for(i=0;i<ARRAY_SIZE(dsi_debug_class_attrs);i++) {
+        class_remove_file(dsi_debug_class, &dsi_debug_class_attrs[i]);
+    }
+    class_destroy(dsi_debug_class);
+
+    return 0;
+}
 //*********************************************************//
 
 void dsi_probe(Lcd_Config_t *pConf)
 {
-    int ret;
+    dsi_config = pConf->lcd_control.mipi_config;
+    pConf->lcd_control.mipi_config->bit_rate_min *= 1000;
+    pConf->lcd_control.mipi_config->bit_rate_max *= 1000;
 
-    ret = class_register(&aml_dsi_debug_class);
-    if(ret){
-        DPRINT("class register aml_dsi_debug_class fail!\n");
-    }
+    creat_dsi_attr();
 }
 
 void dsi_remove(void)
 {
-
+    remove_dsi_attr();
 }
 
-#endif
-
diff --git a/drivers/amlogic/display/vout/mipi_dsi_util.h b/arch/arm/mach-meson8/lcd/mipi_dsi_util.h
similarity index 97%
rename from drivers/amlogic/display/vout/mipi_dsi_util.h
rename to arch/arm/mach-meson8/lcd/mipi_dsi_util.h
index f0a46ac9cd71..972abcfb88e5 100755
--- a/drivers/amlogic/display/vout/mipi_dsi_util.h
+++ b/arch/arm/mach-meson8/lcd/mipi_dsi_util.h
@@ -2,12 +2,8 @@
 #define MIPI_DSI_UTIL_H
 
 #include <mach/register.h>
-#include <mach/cpu.h>
 #include <linux/amlogic/vout/lcdoutc.h>
 
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-#include <mach/mipi_dsi_reg.h>
-
 // --------------------------------------------------------
 // MIPI DSI Data Type/ MIPI DCS Command Type Definitions
 // --------------------------------------------------------
@@ -421,14 +417,7 @@ typedef struct DSI_Phy_s{
 }DSI_Phy_t;
 //********************************************************************************
 
-extern unsigned char *get_dsi_init_table(int flag);
-
 #define DSI_CMD_SIZE_MAX		2000
-//payload struct:
-//data_type, command, para_num, parameters...
-//data_type=0xff, command=0xff, means ending flag
-//data_type=0xff, command<0xff, means delay time(unit ms)
-extern void dsi_write_cmd(unsigned char* payload);
 
 extern void set_mipi_dsi_control_config(Lcd_Config_t *pConf);
 extern void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf);
@@ -439,4 +428,3 @@ extern void dsi_probe(Lcd_Config_t *pConf);
 extern void dsi_remove(void);
 
 #endif
-#endif
diff --git a/arch/arm/mach-meson8b/Makefile b/arch/arm/mach-meson8b/Makefile
index 96aa0f77f97b..c1747faac38c 100755
--- a/arch/arm/mach-meson8b/Makefile
+++ b/arch/arm/mach-meson8b/Makefile
@@ -42,6 +42,8 @@ obj-$(CONFIG_AMLOGIC_THERMAL) += thermal.o
 
 obj-$(CONFIG_AML_HDMI_TX) +=  hdmi_tx_hw/
 
+obj-$(CONFIG_AM_LCD_OUTPUT) +=  lcd/
+
 # ARM Trustzone
 obj-$(CONFIG_MESON_TRUSTZONE) += meson-smc.o meson-secure.o
 ifeq ($(CONFIG_MESON_TRUSTZONE),y)
diff --git a/arch/arm/mach-meson8b/include/mach/lcd_reg.h b/arch/arm/mach-meson8b/include/mach/lcd_reg.h
new file mode 100755
index 000000000000..778a25eda637
--- /dev/null
+++ b/arch/arm/mach-meson8b/include/mach/lcd_reg.h
@@ -0,0 +1,33 @@
+#ifndef LCD_CONTROLLER_REG_H
+#define LCD_CONTROLLER_REG_H
+#include <mach/io.h>
+
+#define LCD_REG_BASE_ADDR				IO_VPU_BUS_BASE	//#define IO_VPU_BUS_BASE	(IO_APB_BUS_BASE + 0x100000)
+#define LCD_CBUS_BASE_ADDR				IO_CBUS_BASE
+#define LCD_DSI_BASE_ADDR				IO_MIPI_DSI_BASE
+
+#define LCD_REG_OFFSET(reg)				(reg << 2)
+#define LCD_CBUS_OFFSET(reg)			(reg << 2)
+#define LCD_DSI_OFFSET(reg)				(reg << 2)
+
+#define LCD_REG_ADDR(reg)				(LCD_REG_BASE_ADDR + LCD_REG_OFFSET(reg))
+#define LCD_CBUS_ADDR(reg)				(LCD_CBUS_BASE_ADDR + LCD_CBUS_OFFSET(reg))
+#define LCD_DSI_ADDR(reg)				(LCD_DSI_BASE_ADDR + LCD_DSI_OFFSET(reg))
+
+#define WRITE_LCD_REG(reg, val) 					aml_write_reg32(LCD_REG_ADDR(reg), (val))
+#define READ_LCD_REG(reg) 							aml_read_reg32(LCD_REG_ADDR(reg))
+#define WRITE_LCD_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_REG_ADDR(reg), (val),start,len)
+#define CLR_LCD_REG_MASK(reg, mask)   				aml_clr_reg32_mask(LCD_REG_ADDR(reg), (mask))
+#define SET_LCD_REG_MASK(reg, mask)     			aml_set_reg32_mask(LCD_REG_ADDR(reg), (mask))
+
+#define WRITE_LCD_CBUS_REG(reg, val) 					aml_write_reg32(LCD_CBUS_ADDR(reg), (val))
+#define READ_LCD_CBUS_REG(reg) 							aml_read_reg32(LCD_CBUS_ADDR(reg))
+#define WRITE_LCD_CBUS_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_CBUS_ADDR(reg), (val),start,len)
+#define CLR_LCD_CBUS_REG_MASK(reg, mask)   				aml_clr_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
+#define SET_LCD_CBUS_REG_MASK(reg, mask)     			aml_set_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
+
+#define WRITE_DSI_REG(reg, val) *(volatile unsigned *)LCD_DSI_ADDR(reg) = (val)
+#define READ_DSI_REG(reg) (*(volatile unsigned *)LCD_DSI_ADDR(reg))
+#define WRITE_DSI_REG_BITS(reg, val, start, len) \
+	WRITE_DSI_REG(reg, (READ_DSI_REG(reg) & ~(((1L<<(len))-1)<<(start))) | ((unsigned)((val)&((1L<<(len))-1)) << (start)))
+#endif
diff --git a/arch/arm/mach-meson8b/include/mach/lcdoutc.h b/arch/arm/mach-meson8b/include/mach/lcdoutc.h
new file mode 100755
index 000000000000..a586f3a0eabe
--- /dev/null
+++ b/arch/arm/mach-meson8b/include/mach/lcdoutc.h
@@ -0,0 +1,24 @@
+
+#ifndef MACH_LCDOUTC_H
+#define MACH_LCDOUTC_H
+
+#define CONFIG_LCD_TYPE_MID_VALID
+#define CONFIG_LCD_IF_TTL_VALID
+#define CONFIG_LCD_IF_LVDS_VALID
+#define CONFIG_LCD_IF_MIPI_VALID
+/*
+// lcd driver global API, special by CPU
+*/
+//*************************************************************
+// For mipi-dsi external driver use
+//*************************************************************
+//payload struct:
+//data_type, command, para_num, parameters...
+//data_type=0xff, command=0xff, means ending flag
+//data_type=0xff, command<0xff, means delay time(unit ms)
+//return:
+//command num
+extern int dsi_write_cmd(unsigned char* payload);
+//*************************************************************
+
+#endif
diff --git a/arch/arm/mach-meson8b/lcd/Makefile b/arch/arm/mach-meson8b/lcd/Makefile
new file mode 100755
index 000000000000..a23cc505d5e2
--- /dev/null
+++ b/arch/arm/mach-meson8b/lcd/Makefile
@@ -0,0 +1 @@
+obj-y		+= mipi_dsi_util.o lcd_config.o
diff --git a/arch/arm/mach-meson8b/lcd/lcd_config.c b/arch/arm/mach-meson8b/lcd/lcd_config.c
new file mode 100755
index 000000000000..9f6d06a51a78
--- /dev/null
+++ b/arch/arm/mach-meson8b/lcd/lcd_config.c
@@ -0,0 +1,1438 @@
+/*
+ * AMLOGIC lcd controller driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ * Modify:  Evoke Zhang <evoke.zhang@amlogic.com>
+ * compatible dts
+ *
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <plat/regops.h>
+#include <mach/am_regs.h>
+#include <mach/lcd_reg.h>
+#include <linux/amlogic/vout/lcdoutc.h>
+#include <mach/clock.h>
+#include <mach/vpu.h>
+#include <mach/mod_gate.h>
+#include <asm/fiq.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include "lcd_config.h"
+#include "mipi_dsi_util.h"
+
+#define VPP_OUT_SATURATE	(1 << 0)
+
+static spinlock_t gamma_write_lock;
+static spinlock_t lcd_clk_lock;
+
+static Lcd_Config_t *lcd_Conf;
+static unsigned char lcd_gamma_init_err = 0;
+
+void lcd_config_init(Lcd_Config_t *pConf);
+
+static void print_lcd_driver_version(void)
+{
+    printk("lcd driver version: %s%s\n\n", LCD_DRV_DATE, LCD_DRV_TYPE);
+}
+
+static void lcd_ports_ctrl_lvds(Bool_t status)
+{
+	if (status) {
+		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1); //enable lvds fifo
+		if (lcd_Conf->lcd_basic.lcd_bits == 6)
+			WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1e, 11, 5);	//enable LVDS phy 3 channels
+		else
+			WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);	//enable LVDS phy 4 channels
+	}
+	else {
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
+	}
+
+	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl_mipi(Bool_t status)
+{
+    if (status) {
+        switch (lcd_Conf->lcd_control.mipi_config->lane_num) {
+            case 1:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x11, 11, 5);
+                break;
+            case 2:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x19, 11, 5);
+                break;
+            case 3:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1d, 11, 5);
+                break;
+            case 4:
+                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);
+                break;
+            default:
+                break;
+        }
+    }
+    else {
+        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
+        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
+        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
+    }
+
+    DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl_ttl(Bool_t status)
+{
+	struct pinctrl_state *s;
+	int ret;
+	
+	if (IS_ERR(lcd_Conf->lcd_misc_ctrl.pin)) {
+		printk("set ttl_ports_ctrl pinmux error.\n");
+		return;
+	}
+
+	if (status) {
+	if (lcd_Conf->lcd_basic.lcd_bits == 6) {
+			if (lcd_Conf->lcd_timing.de_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_hvsync_on");
+			}
+			else if (lcd_Conf->lcd_timing.hvsync_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_de_on");
+			}
+			else {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_hvsync_de_on");	//select pinmux
+			}
+		}
+		else {
+			if (lcd_Conf->lcd_timing.de_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_hvsync_on");
+			}	
+			else if (lcd_Conf->lcd_timing.hvsync_valid == 0) {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_de_on");
+			}
+			else {
+				s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_hvsync_de_on");	//select pinmux
+			}
+		}
+		if (IS_ERR(lcd_Conf->lcd_misc_ctrl.pin)) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+
+		ret = pinctrl_select_state(lcd_Conf->lcd_misc_ctrl.pin, s);	//set pinmux and lock pins
+		if (ret < 0) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+	}else {
+		//pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);	//release pins
+		if (lcd_Conf->lcd_basic.lcd_bits == 6) {
+			s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_6bit_hvsync_de_off");	//select pinmux
+		}
+		else {
+			s = pinctrl_lookup_state(lcd_Conf->lcd_misc_ctrl.pin, "ttl_8bit_hvsync_de_off");	//select pinmux
+		}
+		if (IS_ERR(lcd_Conf->lcd_misc_ctrl.pin)) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+		
+		ret = pinctrl_select_state(lcd_Conf->lcd_misc_ctrl.pin, s);	//set pinmux and lock pins
+		if (ret < 0) {
+			printk("set ttl_ports_ctrl pinmux error.\n");
+			devm_pinctrl_put(lcd_Conf->lcd_misc_ctrl.pin);
+			return;
+		}
+	}
+	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl(Bool_t status)
+{
+    switch(lcd_Conf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            lcd_ports_ctrl_mipi(status);
+            break;
+        case LCD_DIGITAL_LVDS:
+            lcd_ports_ctrl_lvds(status);
+            break;
+        case LCD_DIGITAL_TTL:
+            lcd_ports_ctrl_ttl(status);
+            break;
+        default:
+            printk("Invalid LCD type.\n");
+            break;
+    }
+}
+
+static void set_control_mipi(Lcd_Config_t *pConf);
+//for special interface
+static int lcd_power_ctrl_video(Bool_t status)
+{
+    int ret = 0;
+
+    if (status) {
+        switch(lcd_Conf->lcd_basic.lcd_type) {
+            case LCD_DIGITAL_MIPI:
+                set_control_mipi(lcd_Conf);
+                break;
+            default:
+                break;
+        }
+    }
+    else {
+        switch(lcd_Conf->lcd_basic.lcd_type) {
+            case LCD_DIGITAL_MIPI:
+                mipi_dsi_link_off(lcd_Conf);  //link off command
+                break;
+            default:
+                break;
+        }
+    }
+    DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+    return ret;
+}
+
+#define LCD_GAMMA_RETRY_CNT  1000
+static void write_gamma_table(u16 *data, u32 rgb_mask, u16 gamma_coeff, u32 gamma_reverse)
+{
+	int i;
+	int cnt = 0;
+	unsigned long flags = 0;
+	
+	spin_lock_irqsave(&gamma_write_lock, flags);
+	rgb_mask = gamma_sel_table[rgb_mask];
+	while ((!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x0 << LCD_HADR));
+	if (gamma_reverse == 0) {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG(L_GAMMA_DATA_PORT, (data[i] * gamma_coeff / 100));
+		}
+	}
+	else {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG(L_GAMMA_DATA_PORT, (data[255-i] * gamma_coeff / 100));
+		}
+	}
+	cnt = 0;
+	while ((!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x23 << LCD_HADR));
+	
+	if (cnt >= LCD_GAMMA_RETRY_CNT)
+		lcd_gamma_init_err = 1;
+	
+	spin_unlock_irqrestore(&gamma_write_lock, flags);
+}
+
+static void set_gamma_table_lcd(unsigned gamma_en)
+{
+	DBG_PRINT("%s\n", __FUNCTION__);
+	lcd_gamma_init_err = 0;
+	write_gamma_table(lcd_Conf->lcd_effect.GammaTableR, GAMMA_SEL_R, lcd_Conf->lcd_effect.gamma_r_coeff, ((lcd_Conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+	write_gamma_table(lcd_Conf->lcd_effect.GammaTableG, GAMMA_SEL_G, lcd_Conf->lcd_effect.gamma_g_coeff, ((lcd_Conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+	write_gamma_table(lcd_Conf->lcd_effect.GammaTableB, GAMMA_SEL_B, lcd_Conf->lcd_effect.gamma_b_coeff, ((lcd_Conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+
+	if (lcd_gamma_init_err) {
+		WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 0, 0, 1);
+		printk("[warning]: write gamma table error, gamma table disabled\n");
+	}
+	else
+		WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, gamma_en, 0, 1);
+}
+
+static void set_tcon_lcd(Lcd_Config_t *pConf)
+{
+	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
+	unsigned hs_pol_adj, vs_pol_adj;
+
+	DBG_PRINT("%s\n", __FUNCTION__);
+	
+	set_gamma_table_lcd(((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1));
+	
+	WRITE_LCD_REG(L_RGB_BASE_ADDR,  pConf->lcd_effect.rgb_base_addr);
+	WRITE_LCD_REG(L_RGB_COEFF_ADDR, pConf->lcd_effect.rgb_coeff_addr);
+	if (pConf->lcd_effect.dith_user) {
+		WRITE_LCD_REG(L_DITH_CNTL_ADDR,  pConf->lcd_effect.dith_cntl_addr);
+	}
+	else {
+		if(pConf->lcd_basic.lcd_bits == 8)
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x400);
+		else
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x600);
+	}
+	
+	WRITE_LCD_REG(L_POL_CNTL_ADDR,   (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1) << LCD_CPH1_POL));
+	
+	switch (pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			hs_pol_adj = 1; //1 for low active, 0 for high active.
+			vs_pol_adj = 1; //1 for low active, 0 for high active
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((0 << LCD_DE_POL) | (vs_pol_adj << LCD_VS_POL) | (hs_pol_adj << LCD_HS_POL)))); //adjust hvsync pol
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((1 << LCD_TCON_DE_SEL) | (1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL)))); //enable tcon DE, Hsync, Vsync
+			break;
+		case LCD_DIGITAL_LVDS:
+		case LCD_DIGITAL_TTL:
+			hs_pol_adj = (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1) ? 0 : 1); //1 for low active, 0 for high active.
+			vs_pol_adj = (((pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1) ? 0 : 1); //1 for low active, 0 for high active
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((0 << LCD_DE_POL) | (vs_pol_adj << LCD_VS_POL) | (hs_pol_adj << LCD_HS_POL)))); //adjust hvsync pol
+			WRITE_LCD_REG(L_POL_CNTL_ADDR, (READ_LCD_REG(L_POL_CNTL_ADDR) | ((1 << LCD_TCON_DE_SEL) | (1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL)))); //enable tcon DE, Hsync, Vsync 
+			break;
+		default:
+			hs_pol_adj = 0;
+			vs_pol_adj = 0;
+			break;
+	}
+	
+	//DE signal for lvds
+	WRITE_LCD_REG(L_DE_HS_ADDR,    tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(L_DE_HE_ADDR,    tcon_adr->de_he_addr);
+	WRITE_LCD_REG(L_DE_VS_ADDR,    tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(L_DE_VE_ADDR,    tcon_adr->de_ve_addr);
+	//DE signal for TTL
+	WRITE_LCD_REG(L_OEV1_HS_ADDR,  tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(L_OEV1_HE_ADDR,  tcon_adr->de_he_addr);
+	WRITE_LCD_REG(L_OEV1_VS_ADDR,  tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(L_OEV1_VE_ADDR,  tcon_adr->de_ve_addr);
+
+	//Hsync signal
+	WRITE_LCD_REG(L_HSYNC_HS_ADDR, tcon_adr->hs_hs_addr);
+	WRITE_LCD_REG(L_HSYNC_HE_ADDR, tcon_adr->hs_he_addr);
+	WRITE_LCD_REG(L_HSYNC_VS_ADDR, tcon_adr->hs_vs_addr);
+	WRITE_LCD_REG(L_HSYNC_VE_ADDR, tcon_adr->hs_ve_addr);
+
+	//Vsync signal
+	WRITE_LCD_REG(L_VSYNC_HS_ADDR, tcon_adr->vs_hs_addr);
+	WRITE_LCD_REG(L_VSYNC_HE_ADDR, tcon_adr->vs_he_addr);
+	WRITE_LCD_REG(L_VSYNC_VS_ADDR, tcon_adr->vs_vs_addr);
+	WRITE_LCD_REG(L_VSYNC_VE_ADDR, tcon_adr->vs_ve_addr);
+	
+	WRITE_LCD_REG(L_INV_CNT_ADDR,       0);
+	WRITE_LCD_REG(L_TCON_MISC_SEL_ADDR, ((1 << LCD_STV1_SEL) | (1 << LCD_STV2_SEL)));
+	
+	if(pConf->lcd_misc_ctrl.vpp_sel)
+		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
+	else
+		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+}
+
+static void vclk_set_lcd(int lcd_type, unsigned long pll_reg, unsigned long vid_div_reg, unsigned int clk_ctrl_reg)
+{
+	unsigned xd = 0;
+	unsigned pll_level = 0, pll_frac = 0;
+	int wait_loop = PLL_WAIT_LOCK_CNT;
+	unsigned pll_lock = 0;
+	unsigned ss_level=0, pll_ctrl2, pll_ctrl3, pll_ctrl4, od_fb;
+	unsigned long flags = 0;
+	spin_lock_irqsave(&lcd_clk_lock, flags);
+	
+	DBG_PRINT("%s\n", __FUNCTION__);
+
+	vid_div_reg = ((vid_div_reg & 0x1ffff) | (1 << 16) | (1 << 15) | (0x3 << 0));	//select vid2_pll and enable clk
+	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xf;
+	pll_level = (clk_ctrl_reg >> CLK_CTRL_LEVEL) & 0x7;
+	pll_frac = (clk_ctrl_reg >> CLK_CTRL_FRAC) & 0xfff;
+	ss_level = (clk_ctrl_reg >> CLK_CTRL_SS) & 0xf;
+	pll_reg |= (1 << PLL_CTRL_EN);
+	
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 19, 1);	//disable vclk2_en 
+	udelay(2);
+
+	if (pll_frac == 0)
+		pll_ctrl2 = 0x59c88000;
+	else
+		pll_ctrl2 = (0x59c8c000 | pll_frac);
+	
+	pll_ctrl4 = (0x00238100 & ~((1<<9) | (0xf<<4) | (0xf<<0)));
+	switch (ss_level) {
+		case 1:	//0.5%
+			pll_ctrl4 |= ((1<<9) | (2<<4) | (1<<0));
+			break;
+		case 2:	//1%
+			pll_ctrl4 |= ((1<<9) | (1<<4) | (1<<0));
+			break;
+		case 3:	//1.5%
+			pll_ctrl4 |= ((1<<9) | (8<<4) | (1<<0));
+			break;
+		case 4: //2%
+			pll_ctrl4 |= ((1<<9) | (0<<4) | (1<<0));
+			break;
+		case 0:
+		default:
+			ss_level = 0;
+			break;
+	}
+	
+	switch (pll_level) {
+		case 1: //<=1.7G
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca49b022;
+			od_fb = 0;
+			break;
+		case 2: //1.7G~2.0G
+			pll_ctrl2 |= (1<<13);//special adjust
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca493822;
+			od_fb = 1;
+			break;
+		case 3: //2.0G~2.5G
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca493822;
+			od_fb = 1;
+			break;
+		case 4: //>=2.5G
+			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xce49c022;
+			od_fb = 1;
+			break;
+		default:
+			pll_ctrl3 = 0xca7e3823;
+			od_fb = 0;
+			break;
+	}
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL2, 1, 16, 1);//enable ext LDO
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL2, pll_ctrl2);
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL3, pll_ctrl3);
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL4, (pll_ctrl4 | (od_fb << 24))); //[24] od_fb
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL5, 0x00012385);
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL, pll_reg | (1 << PLL_CTRL_RST));
+	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL, pll_reg);
+	
+	do{
+		udelay(50);
+		pll_lock = (READ_LCD_CBUS_REG(HHI_VID_PLL_CNTL) >> PLL_CTRL_LOCK) & 0x1;
+		if (wait_loop == 100) {
+			if (pll_level == 2) {
+				//change setting if can't lock
+				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL2, 1, 12, 1);
+				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 1, PLL_CTRL_RST, 1);
+				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, PLL_CTRL_RST, 1);
+				printk("change setting for vid pll stability\n");
+			}
+		}
+		wait_loop--;
+	}while((pll_lock == 0) && (wait_loop > 0));
+	if (wait_loop == 0)
+		printk("[error]: vid_pll lock failed\n");
+
+	//pll_div2
+	WRITE_LCD_CBUS_REG(HHI_VIID_DIVIDER_CNTL, vid_div_reg);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 7, 1);    //0x104c[7]:SOFT_RESET_POST
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 3, 1);    //0x104c[3]:SOFT_RESET_PRE
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 1, 1);    //0x104c[1]:RESET_N_POST
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 0, 1);    //0x104c[0]:RESET_N_PRE
+	udelay(5);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 3, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 7, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 3, 0, 2);
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, (xd-1), 0, 8); // setup the XD divider value
+	udelay(5);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 4, 16, 3); // Bit[18:16] - v2_cntl_clk_in_sel
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 19, 1); //vclk2_en0
+	udelay(2);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 8, 12, 4); // [15:12] encl_clk_sel, select vclk2_div1
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 1, 16, 2); // release vclk2_div_reset and enable vclk2_div
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 0, 1); //enable v2_clk_div1
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 15, 1); //soft reset
+	udelay(10);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 15, 1);  //release soft reset
+	udelay(5);
+	
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 1, 3, 1);	//enable cts_encl gate //new add for M8b
+	
+	spin_unlock_irqrestore(&lcd_clk_lock, flags);
+}
+
+static void clk_util_lvds_set_clk_div(unsigned long divn_sel, unsigned long divn_tcnt, unsigned long div2_en)
+{
+    // ---------------------------------------------
+    // Configure the LVDS PHY
+    // ---------------------------------------------
+    // wire    [4:0]   cntl_ser_en         = control[20:16];
+    // wire            cntl_prbs_en        = control[13];
+    // wire            cntl_prbs_err_en    = control[12];
+    // wire    [1:0]   cntl_mode_set_high  = control[11:10];
+    // wire    [1:0]   cntl_mode_set_low   = control[9:8];
+    // 
+    // wire    [1:0]   fifo_clk_sel        = control[7;6]
+    // 
+    // wire            mode_port_rev       = control[4];
+    // wire            mode_bit_rev        = control[3];
+    // wire            mode_inv_p_n        = control[2];
+    // wire            phy_clk_en          = control[1];
+    // wire            soft_reset_int      = control[0];
+    WRITE_LCD_CBUS_REG(HHI_LVDS_TX_PHY_CNTL0, (0x1f << 16) | (0x1 << 6) ); // enable all serializers, divide by 7
+}
+
+static void set_pll_lcd(Lcd_Config_t *pConf)
+{
+    unsigned pll_reg, div_reg, clk_reg;
+    int xd;
+    int lcd_type, ss_level;
+    unsigned pll_div_post = 0, phy_clk_div2 = 0;
+
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    pll_reg = pConf->lcd_timing.pll_ctrl;
+    div_reg = pConf->lcd_timing.div_ctrl;
+    clk_reg = pConf->lcd_timing.clk_ctrl;
+    ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
+    xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
+
+    lcd_type = pConf->lcd_basic.lcd_type;
+
+    switch(lcd_type){
+        case LCD_DIGITAL_MIPI:
+            break;
+        case LCD_DIGITAL_LVDS:
+            xd = 1;
+            pll_div_post = 7;
+            phy_clk_div2 = 0;
+            div_reg = (div_reg | (1 << DIV_CTRL_POST_SEL) | (1 << DIV_CTRL_LVDS_CLK_EN) | ((pll_div_post-1) << DIV_CTRL_DIV_POST) | (phy_clk_div2 << DIV_CTRL_PHY_CLK_DIV2));
+            break;
+        case LCD_DIGITAL_TTL:
+            break;
+        default:
+            break;
+    }
+    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
+
+    DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
+    vclk_set_lcd(lcd_type, pll_reg, div_reg, clk_reg);
+
+    switch(lcd_type){
+        case LCD_DIGITAL_MIPI:
+            WRITE_LCD_REG(MIPI_DSI_TOP_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0x7<<4)) | (1 << 4) | (1 << 5) | (0 << 6));
+            WRITE_LCD_REG(MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) | 0xf) );     // Release mipi_dsi_host's reset
+            WRITE_LCD_REG(MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) & 0xfffffff0) );     // Release mipi_dsi_host's reset
+            WRITE_LCD_REG(MIPI_DSI_TOP_CLK_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CLK_CNTL) | 0x3) );            // Enable dwc mipi_dsi_host's clock 
+            break;
+        case LCD_DIGITAL_LVDS:
+            clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
+            //    lvds_gen_cntl       <= {10'h0,      // [15:4] unused
+            //                            2'h1,       // [5:4] divide by 7 in the PHY
+            //                            1'b0,       // [3] fifo_en
+            //                            1'b0,       // [2] wr_bist_gate
+            //                            2'b00};     // [1:0] fifo_wr mode
+            //FIFO_CLK_SEL = 1; // div7
+            WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 4, 2);	//lvds fifo clk div 7
+
+            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 0, 15, 1);	// lvds div reset
+            udelay(5);
+            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 15, 1);	// Release lvds div reset
+            break;
+        case LCD_DIGITAL_TTL:
+            break;
+        default:
+            break;
+    }
+}
+
+static void set_venc_lcd(Lcd_Config_t *pConf)
+{
+	DBG_PRINT("%s\n",__FUNCTION__);
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
+#ifdef CONFIG_AM_TV_OUTPUT2
+	if	(pConf->lcd_misc_ctrl.vpp_sel) {
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2, 2); //viu2 select encl
+	}
+	else {
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);//viu1 select encl
+	}
+#else
+	WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 4);;	//viu1, viu2 select encl
+#endif
+	
+	WRITE_LCD_REG(ENCL_VIDEO_MODE,			0);
+	WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV,		0x8); // Sampling rate: 1
+
+	WRITE_LCD_REG(ENCL_VIDEO_FILT_CTRL,		0x1000); // bypass filter
+
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_PXCNT,		pConf->lcd_basic.h_period - 1);
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_LNCNT,		pConf->lcd_basic.v_period - 1);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_BEGIN,	pConf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_END,		pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_BLINE,	pConf->lcd_timing.video_on_line);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_ELINE,	pConf->lcd_basic.v_active - 1  + pConf->lcd_timing.video_on_line);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_BEGIN,   0);//pConf->lcd_timing.hs_hs_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_END,     10);//pConf->lcd_timing.hs_he_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BEGIN,   0);//pConf->lcd_timing.vs_hs_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_END,     0);//pConf->lcd_timing.vs_he_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE,   0);//pConf->lcd_timing.vs_vs_addr);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,   2);//pConf->lcd_timing.vs_ve_addr);
+
+	WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN,			1);	// enable encl
+}
+
+static void set_control_lvds(Lcd_Config_t *pConf)
+{
+	unsigned lvds_repack, pn_swap, bit_num;
+	unsigned data32;
+	
+	DBG_PRINT("%s\n", __FUNCTION__);
+
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1); // disable lvds fifo
+	
+    data32 = (0x00 << LVDS_blank_data_r) |
+             (0x00 << LVDS_blank_data_g) |
+             (0x00 << LVDS_blank_data_b) ; 
+    WRITE_LCD_REG(LVDS_BLANK_DATA_HI, (data32 >> 16));
+    WRITE_LCD_REG(LVDS_BLANK_DATA_LO, (data32 & 0xffff));
+	
+	lvds_repack = (pConf->lcd_control.lvds_config->lvds_repack) & 0x1;
+	pn_swap = (pConf->lcd_control.lvds_config->pn_swap) & 0x1;
+
+	switch(pConf->lcd_basic.lcd_bits) {
+		case 10:
+			bit_num=0;
+			break;
+		case 8:
+			bit_num=1;
+			break;
+		case 6:
+			bit_num=2;
+			break;
+		case 4:
+			bit_num=3;
+			break;
+		default:
+			bit_num=1;
+			break;
+	}
+	
+	WRITE_LCD_REG(LVDS_PACK_CNTL_ADDR, 
+					( lvds_repack<<0 ) | // repack
+					( 0<<2 ) | // odd_even
+					( 0<<3 ) | // reserve
+					( 0<<4 ) | // lsb first
+					( pn_swap<<5 ) | // pn swap
+					( 0<<6 ) | // dual port
+					( 0<<7 ) | // use tcon control
+					( bit_num<<8 ) | // 0:10bits, 1:8bits, 2:6bits, 3:4bits.
+					( 0<<10 ) | //r_select  //0:R, 1:G, 2:B, 3:0
+					( 1<<12 ) | //g_select  //0:R, 1:G, 2:B, 3:0
+					( 2<<14 ));  //b_select  //0:R, 1:G, 2:B, 3:0; 
+				   
+    WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 0, 1);  //fifo enable
+	//WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1);  //enable fifo
+}
+
+static void set_control_mipi(Lcd_Config_t *pConf)
+{
+    set_mipi_dsi_control(pConf);
+}
+
+static void set_control_ttl(Lcd_Config_t *pConf)
+{
+	unsigned rb_port_swap, rgb_bit_swap;
+	
+	rb_port_swap = (unsigned)(pConf->lcd_control.ttl_config->rb_swap);
+	rgb_bit_swap = (unsigned)(pConf->lcd_control.ttl_config->bit_swap);
+	
+	WRITE_LCD_REG(L_DUAL_PORT_CNTL_ADDR, (rb_port_swap << LCD_RGB_SWP) | (rgb_bit_swap << LCD_BIT_SWP));
+}
+
+static void init_phy_lvds(Lcd_Config_t *pConf)
+{
+    unsigned swing_ctrl;
+    DBG_PRINT("%s\n", __FUNCTION__);
+	
+	WRITE_LCD_REG(LVDS_SER_EN, 0xfff);	//Enable the serializers
+
+    WRITE_LCD_REG(LVDS_PHY_CNTL0, 0xffff);
+    WRITE_LCD_REG(LVDS_PHY_CNTL1, 0xff00);
+	WRITE_LCD_REG(LVDS_PHY_CNTL4, 0x007f);
+	
+	//WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x00000348);
+	switch (pConf->lcd_control.lvds_config->lvds_vswing) {
+		case 0:
+			swing_ctrl = 0x028;
+			break;
+		case 1:
+			swing_ctrl = 0x048;
+			break;
+		case 2:
+			swing_ctrl = 0x088;
+			break;
+		case 3:
+			swing_ctrl = 0x0c8;
+			break;
+		case 4:
+			swing_ctrl = 0x0f8;
+			break;
+		default:
+			swing_ctrl = 0x048;
+			break;
+	}
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, swing_ctrl);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x000665b7);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x84070000);
+}
+
+static void init_phy_mipi(Lcd_Config_t *pConf)
+{
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 1, 4, 1);//swap mipi channels, only for m8baby
+
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x8);//DIF_REF_CTL0
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, (0x3e << 16) | (0xa5b8 << 0));//DIF_REF_CTL2:31-16bit, DIF_REF_CTL1:15-0bit
+    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, (0x26e0 << 16) | (0x459 << 0));//DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit
+}
+
+static void init_dphy(Lcd_Config_t *pConf)
+{
+	unsigned lcd_type = (unsigned)(pConf->lcd_basic.lcd_type);
+
+	switch (lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
+			init_phy_mipi(pConf);
+			break;
+		case LCD_DIGITAL_LVDS:
+			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
+			init_phy_lvds(pConf);
+			break;
+		default:
+			break;
+	}
+}
+
+static void set_video_adjust(Lcd_Config_t *pConf)
+{
+	DBG_PRINT("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x.\n", pConf->lcd_effect.vadj_brightness, pConf->lcd_effect.vadj_contrast, pConf->lcd_effect.vadj_saturation);
+	WRITE_LCD_REG(VPP_VADJ2_Y, (pConf->lcd_effect.vadj_brightness << 8) | (pConf->lcd_effect.vadj_contrast << 0));
+	WRITE_LCD_REG(VPP_VADJ2_MA_MB, (pConf->lcd_effect.vadj_saturation << 16));
+	WRITE_LCD_REG(VPP_VADJ2_MC_MD, (pConf->lcd_effect.vadj_saturation << 0));
+	WRITE_LCD_REG(VPP_VADJ_CTRL, 0xf);	//enable video adjust
+}
+
+static void _init_lcd_driver(Lcd_Config_t *pConf)
+{
+    int lcd_type = pConf->lcd_basic.lcd_type;
+    unsigned char ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
+
+    print_lcd_driver_version();
+    request_vpu_clk_vmod(pConf->lcd_timing.lcd_clk, VMODE_LCD);
+    switch_vpu_mem_pd_vmod(VMODE_LCD, VPU_MEM_POWER_ON);
+    switch_lcd_mod_gate(ON);
+
+    printk("Init LCD mode: %s, %s(%u) %ubit, %ux%u@%u.%uHz, ss_level=%u(%s)\n", pConf->lcd_basic.model_name, lcd_type_table[lcd_type], lcd_type, pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10), ss_level, lcd_ss_level_table[ss_level]);
+
+    set_pll_lcd(pConf);
+    set_venc_lcd(pConf);
+    set_tcon_lcd(pConf);
+    switch(lcd_type){
+        case LCD_DIGITAL_MIPI:
+            init_dphy(pConf);
+            break;
+        case LCD_DIGITAL_LVDS:
+            set_control_lvds(pConf);
+            init_dphy(pConf);
+            break;
+        case LCD_DIGITAL_TTL:
+            set_control_ttl(pConf);
+            break;
+        default:
+            printk("Invalid LCD type.\n");
+            break;
+    }
+    set_video_adjust(pConf);
+    printk("%s finished.\n", __FUNCTION__);
+}
+
+static void _disable_lcd_driver(Lcd_Config_t *pConf)
+{
+    switch(pConf->lcd_basic.lcd_type){
+        case LCD_DIGITAL_MIPI:
+            mipi_dsi_off();
+            break;
+        case LCD_DIGITAL_LVDS:
+        case LCD_DIGITAL_TTL:
+        default:
+            break;
+    }
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 11, 1);	//close lvds phy clk gate: 0x104c[11]
+    WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
+
+    WRITE_LCD_REG(ENCL_VIDEO_EN, 0);	//disable encl
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 0, 5);	//close vclk2 gate: 0x104b[4:0]
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 16, 1);	//close vid2_pll gate: 0x104c[16]
+
+    WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, 30, 1);		//disable vid_pll: 0x10c8[30]
+
+    switch_lcd_mod_gate(OFF);
+    switch_vpu_mem_pd_vmod(VMODE_LCD, VPU_MEM_POWER_DOWN);
+    release_vpu_clk_vmod(VMODE_LCD);
+    printk("disable lcd display driver.\n");
+}
+
+static void _enable_vsync_interrupt(void)
+{
+	if (READ_LCD_REG(ENCL_VIDEO_EN) & 1) {
+		WRITE_LCD_REG(VENC_INTCTRL, 0x200);
+	}
+	else{
+		WRITE_LCD_REG(VENC_INTCTRL, 0x2);
+	}
+}
+
+static void lcd_test(unsigned num)
+{
+	switch (num) {
+		case 0:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0x8);
+			printk("disable bist pattern\n");
+			break;
+		case 1:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 1);
+			WRITE_LCD_REG(ENCL_TST_CLRBAR_STRT, lcd_Conf->lcd_timing.video_on_pixel);
+			WRITE_LCD_REG(ENCL_TST_CLRBAR_WIDTH, (lcd_Conf->lcd_basic.h_active / 9));
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show bist pattern 1: Color Bar\n");
+			break;
+		case 2:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 2);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show bist pattern 2: Thin Line\n");
+			break;
+		case 3:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 3);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show bist pattern 3: Dot Grid\n");
+			break;
+		case 4:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+			WRITE_LCD_REG(ENCL_TST_Y, 0x3ff);
+			WRITE_LCD_REG(ENCL_TST_CB, 0x200);
+			WRITE_LCD_REG(ENCL_TST_CR, 0x200);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show test pattern 4: White\n");
+			break;
+		case 5:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+			WRITE_LCD_REG(ENCL_TST_Y, 0);
+			WRITE_LCD_REG(ENCL_TST_CB, 0);
+			WRITE_LCD_REG(ENCL_TST_CR, 0x3ff);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show test pattern 5: Red\n");
+			break;
+		case 6:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+			WRITE_LCD_REG(ENCL_TST_Y, 0x3ff);
+			WRITE_LCD_REG(ENCL_TST_CB, 0);
+			WRITE_LCD_REG(ENCL_TST_CR, 0);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show test pattern 6: Green\n");
+			break;
+		case 7:
+			WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV, 0);
+			WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+			WRITE_LCD_REG(ENCL_TST_Y, 0);
+			WRITE_LCD_REG(ENCL_TST_CB, 0x3ff);
+			WRITE_LCD_REG(ENCL_TST_CR, 0);
+			WRITE_LCD_REG(ENCL_TST_EN, 1);
+			printk("show test pattern 7: Blue\n");
+			break;
+		default:
+			printk("un-support pattern num\n");
+			break;
+	}
+}
+
+static DEFINE_MUTEX(lcd_init_mutex);
+static void lcd_module_enable(void)
+{
+	mutex_lock(&lcd_init_mutex);
+
+	_init_lcd_driver(lcd_Conf);
+	lcd_Conf->lcd_power_ctrl.power_ctrl(ON);
+	_enable_vsync_interrupt();
+	lcd_Conf->lcd_misc_ctrl.lcd_status = 1;
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static void lcd_module_disable(void)
+{
+	mutex_lock(&lcd_init_mutex);
+	lcd_Conf->lcd_misc_ctrl.lcd_status = 0;
+	lcd_Conf->lcd_power_ctrl.power_ctrl(OFF);
+	_disable_lcd_driver(lcd_Conf);
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static void generate_clk_parameter(Lcd_Config_t *pConf)
+{
+    unsigned pll_n = 0, pll_m = 0, pll_od = 0, pll_frac = 0, pll_level = 0;
+    unsigned vid_div_pre = 0, crt_xd = 0;
+
+    unsigned m, n, od, div_pre, div_post, xd;
+    unsigned od_sel, pre_div_sel;
+    unsigned div_pre_sel_max, crt_xd_max;
+    unsigned pll_vco, fout_pll, div_pre_out, div_post_out, final_freq, iflogic_vid_clk_in_max;
+    unsigned od_fb=0;
+    unsigned int dsi_bit_rate_min=0, dsi_bit_rate_max=0;
+    unsigned clk_num = 0;
+    unsigned tmp;
+    unsigned fin = FIN_FREQ;
+    unsigned fout = pConf->lcd_timing.lcd_clk;
+
+    if (fout >= 200) {//clk
+        fout = fout / 1000;  //kHz
+    }
+    else {//frame_rate
+        fout = (fout * pConf->lcd_basic.h_period * pConf->lcd_basic.v_period) / 1000;	//kHz
+    }
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = 16;
+            dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
+            dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
+            iflogic_vid_clk_in_max = MIPI_MAX_VID_CLK_IN;
+            break;
+        case LCD_DIGITAL_LVDS:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 7;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = LVDS_MAX_VID_CLK_IN;
+            break;
+        case LCD_DIGITAL_TTL:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = CRT_VID_DIV_MAX;
+            iflogic_vid_clk_in_max = TTL_MAX_VID_CLK_IN;
+            break;
+        default:
+            div_pre_sel_max = DIV_PRE_SEL_MAX;
+            div_post = 1;
+            crt_xd_max = 1;
+            iflogic_vid_clk_in_max = ENCL_MAX_CLK_IN;
+            break;
+    }
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            if (fout < ENCL_MAX_CLK_IN) {
+                for (xd = 1; xd <= crt_xd_max; xd++) {
+                    div_post_out = fout * xd;
+                    DBG_PRINT("div_post_out=%d, xd=%d, fout=%d\n",div_post_out, xd, fout);
+                    if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                        div_pre_out = div_post_out * div_post;
+                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                            for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                                div_pre = div_pre_table[pre_div_sel];
+                                fout_pll = div_pre_out * div_pre;
+                                DBG_PRINT("pre_div_sel=%d, div_pre=%d, fout_pll=%d\n", pre_div_sel, div_pre, fout_pll);
+                                if ((fout_pll <= dsi_bit_rate_max) && (fout_pll >= dsi_bit_rate_min)){
+                                    for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
+                                        od = od_table[od_sel - 1];
+                                        pll_vco = fout_pll * od;
+                                        DBG_PRINT("od_sel=%d, od=%d, pll_vco=%d\n", od_sel, od, pll_vco);
+                                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
+                                            if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
+                                                od_fb = 1;
+                                                pll_level = 4;
+                                            }
+                                            else if ((pll_vco >= 2000000) && (pll_vco < 2500000)) {
+                                                od_fb = 1;
+                                                pll_level = 3;
+                                            }
+                                            else if ((pll_vco >= 1700000) && (pll_vco < 2000000)) {//special adjust
+                                                od_fb = 1;
+                                                pll_level = 2;
+                                            }
+                                            else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
+                                                od_fb = 0;
+                                                pll_level = 1;
+                                            }
+                                            n = 1;
+                                            m = pll_vco / (fin * (od_fb + 1));
+                                            pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
+                                            pll_m = m;
+                                            pll_n = n;
+                                            pll_od = od_sel - 1;
+                                            vid_div_pre = pre_div_sel;
+                                            crt_xd = xd;
+                                            clk_num = 1;
+                                            DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
+                                                       pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
+                                        }
+                                        if (clk_num > 0)
+                                            break;
+                                    }
+                                }
+                                if (clk_num > 0)
+                                    break;
+                            }
+                        }
+                    }
+                    if (clk_num > 0)
+                        break;
+                }
+            }
+            break;
+        case LCD_DIGITAL_LVDS:
+        case LCD_DIGITAL_TTL:
+            if (fout < ENCL_MAX_CLK_IN) {
+                for (xd = 1; xd <= crt_xd_max; xd++) {
+                    div_post_out = fout * xd;
+                    DBG_PRINT("div_post_out=%d, xd=%d, fout=%d\n",div_post_out, xd, fout);
+                    if (div_post_out <= CRT_VID_MAX_CLK_IN) {
+                        div_pre_out = div_post_out * div_post;
+                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
+                            for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
+                                div_pre = div_pre_table[pre_div_sel];
+                                fout_pll = div_pre_out * div_pre;
+                                DBG_PRINT("pre_div_sel=%d, div_pre=%d, fout_pll=%d\n", pre_div_sel, div_pre, fout_pll);
+                                if (fout_pll <= DIV_PRE_MAX_CLK_IN) {
+                                    for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
+                                        od = od_table[od_sel - 1];
+                                        pll_vco = fout_pll * od;
+                                        DBG_PRINT("od_sel=%d, od=%d, pll_vco=%d\n", od_sel, od, pll_vco);
+                                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
+                                            if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
+                                                od_fb = 1;
+                                                pll_level = 4;
+                                            }
+                                            else if ((pll_vco >= 2000000) && (pll_vco < 2500000)) {
+                                                od_fb = 1;
+                                                pll_level = 3;
+                                            }
+                                            else if ((pll_vco >= 1700000) && (pll_vco < 2000000)) {
+                                                od_fb = 1;
+                                                pll_level = 2;
+                                            }
+                                            else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
+                                                od_fb = 0;
+                                                pll_level = 1;
+                                            }
+                                            n = 1;
+                                            m = pll_vco / (fin * (od_fb + 1));
+                                            pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
+
+                                            pll_m = m;
+                                            pll_n = n;
+                                            pll_od = od_sel - 1;
+                                            vid_div_pre = pre_div_sel;
+                                            crt_xd = xd;
+                                            DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
+                                                       pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
+                                            clk_num = 1;
+                                        }
+                                        if (clk_num > 0)
+                                            break;
+                                    }
+                                }
+                                if (clk_num > 0)
+                                    break;
+                            }
+                        }
+                    }
+                    if (clk_num > 0)
+                        break;
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    if (clk_num > 0) {
+        pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
+        pConf->lcd_timing.div_ctrl = 0x18803 | (vid_div_pre << DIV_CTRL_DIV_PRE);
+        tmp = (pConf->lcd_timing.clk_ctrl & ~((0xf << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
+        pConf->lcd_timing.clk_ctrl = (tmp | ((crt_xd << CLK_CTRL_XD) | (pll_level << CLK_CTRL_LEVEL) | (pll_frac << CLK_CTRL_FRAC)));
+    }
+    else {
+        pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (50 << PLL_CTRL_M);
+        pConf->lcd_timing.div_ctrl = 0x18803 | (1 << DIV_CTRL_DIV_PRE);
+        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+        printk("Out of clock range, reset to default setting!\n");
+    }
+}
+
+static void lcd_sync_duration(Lcd_Config_t *pConf)
+{
+	unsigned m, n, od, od_fb, frac, pre_div, xd, post_div;
+	unsigned h_period, v_period, sync_duration;
+	unsigned pll_out_clk, lcd_clk;
+
+	m = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_M) & 0x1ff;
+	n = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_N) & 0x1f;
+	od = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD) & 0x3;
+	od = od_table[od];
+	frac = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_FRAC) & 0xfff;
+	od_fb = ((((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_LEVEL) & 0x7) > 1) ? 1 : 0;
+	pre_div = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_DIV_PRE) & 0x7;
+	pre_div = div_pre_table[pre_div];
+	
+	h_period = pConf->lcd_basic.h_period;
+	v_period = pConf->lcd_basic.v_period;
+	
+	switch(pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			post_div = 1;
+			break;
+		case LCD_DIGITAL_LVDS:
+			xd = 1;
+			post_div = 7;
+			break;
+		case LCD_DIGITAL_TTL:
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			post_div = 1;
+			break;
+		default:
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			post_div = 1;
+			break;
+	}
+	
+	pll_out_clk = (frac * (od_fb + 1) * FIN_FREQ) / 4096;
+	pll_out_clk = ((m * (od_fb + 1) * FIN_FREQ + pll_out_clk) / (n * od)) * 1000;
+	lcd_clk = pll_out_clk  / (pre_div * post_div * xd);
+	if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_MIPI)
+		pConf->lcd_control.mipi_config->bit_rate = pll_out_clk;
+	pConf->lcd_timing.lcd_clk = lcd_clk;
+	sync_duration = ((lcd_clk / h_period) * 100) / v_period;
+	sync_duration = (sync_duration + 5) / 10;
+	
+	pConf->lcd_timing.sync_duration_num = sync_duration;
+	pConf->lcd_timing.sync_duration_den = 10;
+	printk("lcd_clk=%u.%03uMHz, frame_rate=%u.%uHz.\n\n", (lcd_clk / 1000000), ((lcd_clk / 1000) % 1000), 
+			(sync_duration / pConf->lcd_timing.sync_duration_den), ((sync_duration * 10 / pConf->lcd_timing.sync_duration_den) % 10));
+}
+
+static void lcd_tcon_config(Lcd_Config_t *pConf)
+{
+	unsigned short hstart, hend, vstart, vend;
+	unsigned short h_delay = 0;
+	unsigned short h_offset = 0, v_offset = 0, vsync_h_phase=0;
+	
+	switch (pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			h_delay = MIPI_DELAY;
+			break;
+		case LCD_DIGITAL_LVDS:
+			h_delay = LVDS_DELAY;
+			break;
+		case LCD_DIGITAL_TTL:
+			h_delay = TTL_DELAY;
+			break;
+		default:
+			h_delay = 0;
+			break;
+	}
+#if 0
+	h_offset = (pConf->lcd_timing.h_offset & 0xffff);
+	v_offset = (pConf->lcd_timing.v_offset & 0xffff);
+	if ((pConf->lcd_timing.h_offset >> 31) & 1)
+		pConf->lcd_timing.de_hstart = (pConf->lcd_timing.video_on_pixel + pConf->lcd_basic.h_period + h_delay + h_offset) % pConf->lcd_basic.h_period;
+	else
+		pConf->lcd_timing.de_hstart = (pConf->lcd_timing.video_on_pixel + pConf->lcd_basic.h_period + h_delay - h_offset) % pConf->lcd_basic.h_period;
+	if ((pConf->lcd_timing.v_offset >> 31) & 1)
+		pConf->lcd_timing.de_vstart = (pConf->lcd_timing.video_on_line + pConf->lcd_basic.v_period + v_offset) % pConf->lcd_basic.v_period;
+	else
+		pConf->lcd_timing.de_vstart = (pConf->lcd_timing.video_on_line + pConf->lcd_basic.v_period - v_offset) % pConf->lcd_basic.v_period;
+	
+	hstart = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp) % pConf->lcd_basic.h_period;
+	hend = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp + pConf->lcd_timing.hsync_width) % pConf->lcd_basic.h_period;	
+	pConf->lcd_timing.hs_hs_addr = hstart;
+	pConf->lcd_timing.hs_he_addr = hend;
+	pConf->lcd_timing.hs_vs_addr = 0;
+	pConf->lcd_timing.hs_ve_addr = pConf->lcd_basic.v_period - 1;
+	
+	vsync_h_phase = (pConf->lcd_timing.vsync_h_phase & 0xffff);
+	if ((pConf->lcd_timing.vsync_h_phase >> 31) & 1) //negative
+		vsync_h_phase = (hstart + pConf->lcd_basic.h_period - vsync_h_phase) % pConf->lcd_basic.h_period;
+	else	//positive
+		vsync_h_phase = (hstart + pConf->lcd_basic.h_period + vsync_h_phase) % pConf->lcd_basic.h_period;
+	pConf->lcd_timing.vs_hs_addr = vsync_h_phase;
+	pConf->lcd_timing.vs_he_addr = vsync_h_phase;
+	vstart = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp) % pConf->lcd_basic.v_period;
+	vend = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp + pConf->lcd_timing.vsync_width) % pConf->lcd_basic.v_period;
+	pConf->lcd_timing.vs_vs_addr = vstart;
+	pConf->lcd_timing.vs_ve_addr = vend;
+
+	pConf->lcd_timing.de_hstart = pConf->lcd_timing.de_hstart;
+	pConf->lcd_timing.de_vstart = pConf->lcd_timing.de_vstart;
+	
+	pConf->lcd_timing.de_hs_addr = pConf->lcd_timing.de_hstart;
+	pConf->lcd_timing.de_he_addr = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_active) % pConf->lcd_basic.h_period;
+	pConf->lcd_timing.de_vs_addr = pConf->lcd_timing.de_vstart;
+	pConf->lcd_timing.de_ve_addr = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_active - 1) % pConf->lcd_basic.v_period;
+#else
+    pConf->lcd_timing.video_on_pixel = pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 -h_delay;
+    pConf->lcd_timing.video_on_line = pConf->lcd_basic.v_period - pConf->lcd_basic.v_active;
+
+    h_offset = (pConf->lcd_timing.h_offset & 0xffff);
+    v_offset = (pConf->lcd_timing.v_offset & 0xffff);
+    if ((pConf->lcd_timing.h_offset >> 31) & 1)
+        pConf->lcd_timing.de_hstart = (pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 + pConf->lcd_basic.h_period - h_offset) % pConf->lcd_basic.h_period;
+    else
+        pConf->lcd_timing.de_hstart = (pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 + h_offset) % pConf->lcd_basic.h_period;
+    if ((pConf->lcd_timing.v_offset >> 31) & 1)
+        pConf->lcd_timing.de_vstart = (pConf->lcd_basic.v_period - pConf->lcd_basic.v_active + pConf->lcd_basic.v_period - v_offset) % pConf->lcd_basic.v_period;
+    else
+        pConf->lcd_timing.de_vstart = (pConf->lcd_basic.v_period - pConf->lcd_basic.v_active + v_offset) % pConf->lcd_basic.v_period;
+
+    hstart = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp) % pConf->lcd_basic.h_period;
+    hend = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp + pConf->lcd_timing.hsync_width) % pConf->lcd_basic.h_period;	
+    pConf->lcd_timing.hs_hs_addr = hstart;
+    pConf->lcd_timing.hs_he_addr = hend;
+    pConf->lcd_timing.hs_vs_addr = 0;
+    pConf->lcd_timing.hs_ve_addr = pConf->lcd_basic.v_period - 1;
+
+    vsync_h_phase = (pConf->lcd_timing.vsync_h_phase & 0xffff);
+    if ((pConf->lcd_timing.vsync_h_phase >> 31) & 1) //negative
+        vsync_h_phase = (hstart + pConf->lcd_basic.h_period - vsync_h_phase) % pConf->lcd_basic.h_period;
+    else //positive
+        vsync_h_phase = (hstart + pConf->lcd_basic.h_period + vsync_h_phase) % pConf->lcd_basic.h_period;
+    pConf->lcd_timing.vs_hs_addr = vsync_h_phase;
+    pConf->lcd_timing.vs_he_addr = vsync_h_phase;
+    vstart = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp) % pConf->lcd_basic.v_period;
+    vend = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp + pConf->lcd_timing.vsync_width) % pConf->lcd_basic.v_period;
+    pConf->lcd_timing.vs_vs_addr = vstart;
+    pConf->lcd_timing.vs_ve_addr = vend;
+
+    pConf->lcd_timing.de_hs_addr = pConf->lcd_timing.de_hstart;
+    pConf->lcd_timing.de_he_addr = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_active) % pConf->lcd_basic.h_period;
+    pConf->lcd_timing.de_vs_addr = pConf->lcd_timing.de_vstart;
+    pConf->lcd_timing.de_ve_addr = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_active - 1) % pConf->lcd_basic.v_period;
+#endif
+
+    //DBG_PRINT("hs_hs_addr=%d, hs_he_addr=%d, hs_vs_addr=%d, hs_ve_addr=%d\n", pConf->lcd_timing.hs_hs_addr, pConf->lcd_timing.hs_he_addr, pConf->lcd_timing.hs_vs_addr, pConf->lcd_timing.hs_ve_addr);
+    //DBG_PRINT("vs_hs_addr=%d, vs_he_addr=%d, vs_vs_addr=%d, vs_ve_addr=%d\n", pConf->lcd_timing.vs_hs_addr, pConf->lcd_timing.vs_he_addr, pConf->lcd_timing.vs_vs_addr, pConf->lcd_timing.vs_ve_addr);
+    //DBG_PRINT("de_hs_addr=%d, de_he_addr=%d, de_vs_addr=%d, de_ve_addr=%d\n", pConf->lcd_timing.de_hs_addr, pConf->lcd_timing.de_he_addr, pConf->lcd_timing.de_vs_addr, pConf->lcd_timing.de_ve_addr);
+}
+
+static void lcd_control_config_pre(Lcd_Config_t *pConf)
+{
+    unsigned ss_level;
+
+    ss_level = ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf);
+    ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            ss_level = ((ss_level > 0) ? 1 : 0);
+            set_mipi_dsi_control_config(pConf);
+            break;
+        case LCD_DIGITAL_LVDS:
+            if (pConf->lcd_control.lvds_config->lvds_repack_user == 0) {
+                if (pConf->lcd_basic.lcd_bits == 6)
+                    pConf->lcd_control.lvds_config->lvds_repack = 0;
+                else
+                    pConf->lcd_control.lvds_config->lvds_repack = 1;
+            }
+            break;
+        case LCD_DIGITAL_TTL:
+            if (pConf->lcd_basic.lcd_bits != 6) {
+                pConf->lcd_basic.lcd_bits = 6;
+                printk("lcd change to 6bit for ttl support!\n");
+            }
+            break;
+        default:
+            break;
+    }
+    pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & (~(0xf << CLK_CTRL_SS))) | (ss_level << CLK_CTRL_SS));
+}
+
+//for special interface config after clk setting
+static void lcd_control_config_post(Lcd_Config_t *pConf)
+{
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            set_mipi_dsi_control_config_post(pConf);
+            break;
+        default:
+            break;
+    }
+}
+
+#ifdef CONFIG_USE_OF
+static unsigned char dsi_init_on_table[DSI_INIT_ON_MAX]={0xff,0xff};
+static unsigned char dsi_init_off_table[DSI_INIT_OFF_MAX]={0xff,0xff};
+static DSI_Config_t lcd_mipi_config = {
+    .lane_num = 4,
+    .bit_rate_min = 0,
+    .bit_rate_max = 0,
+    .factor_numerator = 0,
+    .factor_denominator = 10,
+    .transfer_ctrl = 0,
+    .dsi_init_on = &dsi_init_on_table[0],
+    .dsi_init_off = &dsi_init_off_table[0],
+    .lcd_extern_init = 0,
+};
+
+static LVDS_Config_t lcd_lvds_config = {
+    .lvds_vswing = 1,
+    .lvds_repack_user = 0,
+    .lvds_repack = 0,
+    .pn_swap = 0,
+};
+
+static TTL_Config_t lcd_ttl_config = {
+    .rb_swap = 0,
+    .bit_swap = 0,
+};
+
+static Lcd_Config_t lcd_config = {
+    .lcd_timing = {
+        .lcd_clk = 40000000,
+        .clk_ctrl = ((1 << CLK_CTRL_AUTO) | (0 << CLK_CTRL_SS)),
+        .hvsync_valid = 1,
+        .de_valid = 1,
+        .pol_ctrl = ((0 << POL_CTRL_CLK) | (1 << POL_CTRL_DE) | (0 << POL_CTRL_VS) | (0 << POL_CTRL_HS)),
+    },
+    .lcd_effect = {
+        .rgb_base_addr = 0xf0,
+        .rgb_coeff_addr = 0x74a,
+        .dith_user = 0,
+        .vadj_brightness = 0x0,
+        .vadj_contrast = 0x80,
+        .vadj_saturation = 0x100,
+        .gamma_ctrl = ((0 << GAMMA_CTRL_REVERSE) | (1 << LCD_GAMMA_EN)),
+        .gamma_r_coeff = 100,
+        .gamma_g_coeff = 100,
+        .gamma_b_coeff = 100,
+        .set_gamma_table = set_gamma_table_lcd,
+    },
+    .lcd_control = {
+        .mipi_config = &lcd_mipi_config,
+        .lvds_config = &lcd_lvds_config,
+        .ttl_config = &lcd_ttl_config,
+    },
+    .lcd_power_ctrl = {
+        .power_on_step = 0,
+        .power_off_step = 0,
+        .power_ctrl = NULL,
+    },
+};
+
+Lcd_Config_t* get_lcd_config(void)
+{
+    return &lcd_config;
+}
+#endif
+
+static void lcd_config_assign(Lcd_Config_t *pConf)
+{
+    pConf->lcd_power_ctrl.ports_ctrl = lcd_ports_ctrl;
+    pConf->lcd_power_ctrl.power_ctrl_video = lcd_power_ctrl_video;
+
+    pConf->lcd_misc_ctrl.vpp_sel = 0;
+    pConf->lcd_misc_ctrl.lcd_status = 1;
+    pConf->lcd_misc_ctrl.module_enable = lcd_module_enable;
+    pConf->lcd_misc_ctrl.module_disable = lcd_module_disable;
+    pConf->lcd_misc_ctrl.lcd_test = lcd_test;
+    pConf->lcd_misc_ctrl.print_version = print_lcd_driver_version;
+}
+
+void lcd_config_init(Lcd_Config_t *pConf)
+{
+    lcd_control_config_pre(pConf);
+
+    if ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1) {
+        printk("\nAuto generate clock parameters.\n");
+        generate_clk_parameter(pConf);
+        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
+    }
+    else {
+        printk("\nCustome clock parameters.\n");
+        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
+    }
+
+    lcd_sync_duration(pConf);
+    lcd_tcon_config(pConf);
+
+    lcd_control_config_post(pConf);
+}
+
+void lcd_config_probe(Lcd_Config_t *pConf)
+{
+    spin_lock_init(&gamma_write_lock);
+    spin_lock_init(&lcd_clk_lock);
+
+    lcd_Conf = pConf;
+    lcd_config_assign(pConf);
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            dsi_probe(pConf);
+            break;
+        default:
+            break;
+    }
+}
+
+void lcd_config_remove(void)
+{
+    switch (lcd_Conf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_MIPI:
+            dsi_remove();
+            break;
+        default:
+            break;
+    }
+}
diff --git a/arch/arm/mach-meson8b/lcd/lcd_config.h b/arch/arm/mach-meson8b/lcd/lcd_config.h
new file mode 100755
index 000000000000..bc3f778ab0f9
--- /dev/null
+++ b/arch/arm/mach-meson8b/lcd/lcd_config.h
@@ -0,0 +1,191 @@
+
+#ifndef LCD_CONFIG_H
+#define LCD_CONFIG_H
+#include <linux/types.h>
+
+//**********************************
+//lcd driver version
+//**********************************
+#define LCD_DRV_TYPE      "c8b"
+#define LCD_DRV_DATE      "20140703"
+//**********************************
+
+/* for GAMMA_CNTL_PORT */
+	#define LCD_GAMMA_VCOM_POL       7
+	#define LCD_GAMMA_RVS_OUT        6
+	#define LCD_ADR_RDY              5
+	#define LCD_WR_RDY               4
+	#define LCD_RD_RDY               3
+	#define LCD_GAMMA_TR             2
+	#define LCD_GAMMA_SET            1
+	#define LCD_GAMMA_EN             0
+
+/* for GAMMA_ADDR_PORT */
+	#define LCD_H_RD                 12
+	#define LCD_H_AUTO_INC           11
+	#define LCD_H_SEL_R              10
+	#define LCD_H_SEL_G              9
+	#define LCD_H_SEL_B              8
+	#define LCD_HADR_MSB             7
+	#define LCD_HADR                 0
+
+/* for POL_CNTL_ADDR */
+	#define LCD_DCLK_SEL             14  //FOR DCLK OUTPUT
+	#define LCD_TCON_VSYNC_SEL_DVI   11  // FOR RGB format DVI output
+	#define LCD_TCON_HSYNC_SEL_DVI   10  // FOR RGB format DVI output
+	#define LCD_TCON_DE_SEL_DVI      9   // FOR RGB format DVI output
+	#define LCD_CPH3_POL             8
+	#define LCD_CPH2_POL             7
+	#define LCD_CPH1_POL             6
+	#define LCD_TCON_DE_SEL          5
+	#define LCD_TCON_VS_SEL          4
+	#define LCD_TCON_HS_SEL          3
+	#define LCD_DE_POL               2
+	#define LCD_VS_POL               1
+	#define LCD_HS_POL               0
+
+/* for DITH_CNTL_ADDR */
+	#define LCD_DITH10_EN            10
+	#define LCD_DITH8_EN             9
+	#define LCD_DITH_MD              8
+	#define LCD_DITH10_CNTL_MSB      7
+	#define LCD_DITH10_CNTL          4
+	#define LCD_DITH8_CNTL_MSB       3
+	#define LCD_DITH8_CNTL           0
+
+/* for INV_CNT_ADDR */
+	#define LCD_INV_EN               4
+	#define LCD_INV_CNT_MSB          3
+	#define LCD_INV_CNT              0
+
+/* for TCON_MISC_SEL_ADDR */
+	#define LCD_STH2_SEL             12
+	#define LCD_STH1_SEL             11
+	#define LCD_OEH_SEL              10
+	#define LCD_VCOM_SEL             9
+	#define LCD_DB_LINE_SW           8
+	#define LCD_CPV2_SEL             7
+	#define LCD_CPV1_SEL             6
+	#define LCD_STV2_SEL             5
+	#define LCD_STV1_SEL             4
+	#define LCD_OEV_UNITE            3
+	#define LCD_OEV3_SEL             2
+	#define LCD_OEV2_SEL             1
+	#define LCD_OEV1_SEL             0
+
+/* for DUAL_PORT_CNTL_ADDR */
+	#define LCD_ANALOG_SEL_CPH3      8
+	#define LCD_ANALOG_3PHI_CLK_SEL  7
+	#define LCD_LVDS_SEL54           6
+	#define LCD_LVDS_SEL27           5
+	#define LCD_TTL_SEL              4
+	#define LCD_DUAL_PIXEL           3
+	#define LCD_PORT_SWP             2
+	#define LCD_RGB_SWP              1
+	#define LCD_BIT_SWP              0
+
+/* for LVDS_PACK_CNTL_ADDR */
+	#define LCD_LD_CNT_MSB           7
+	#define LCD_LD_CNT               5
+	#define LCD_PN_SWP               4
+	#define LCD_RES                  3
+	#define LCD_LVDS_PORT_SWP        2
+	#define LCD_PACK_RVS             1
+	#define LCD_PACK_LITTLE          0
+
+ /* for LVDS_BLANK_DATA */  
+	#define LVDS_blank_data_reserved    30  // 31:30
+	#define LVDS_blank_data_r           20  // 29:20
+	#define LVDS_blank_data_g           10  // 19:10
+	#define LVDS_blank_data_b           0  //  9:0
+	
+/* for LVDS_PACK_CNTL_ADDR */  
+	#define LVDS_USE_TCON               7
+	#define LVDS_DUAL                   6
+	#define PN_SWP                      5
+	#define LSB_FIRST                   4
+	#define LVDS_RESV                   3
+	#define ODD_EVEN_SWP                2
+	#define LVDS_REPACK                 0
+
+static const unsigned gamma_sel_table[3] = {
+    LCD_H_SEL_R,
+    LCD_H_SEL_G,
+    LCD_H_SEL_B,
+};
+
+//********************************************//
+/* for video encoder */
+	#define	MIPI_DELAY				8
+	#define	LVDS_DELAY				8
+	#define	TTL_DELAY				19
+
+//********************************************//
+// for clk parameter auto generation
+//********************************************//
+/**** clk parameters bit ***/
+	//pll_ctrl
+	#define PLL_CTRL_LOCK			31
+	#define PLL_CTRL_EN				30
+	#define PLL_CTRL_RST			29
+	#define PLL_CTRL_OD				16	//[17:16]
+	#define PLL_CTRL_N				10	//[14:10]
+	#define PLL_CTRL_M				0	//[8:0]
+
+	//div_ctrl
+	#define DIV_CTRL_DIV_POST		12	//[14:12]
+	#define DIV_CTRL_LVDS_CLK_EN	11
+	#define DIV_CTRL_PHY_CLK_DIV2	10
+	#define DIV_CTRL_POST_SEL		8	//[9:8]
+	#define DIV_CTRL_DIV_PRE		4	//[6:4]
+
+	//clk_ctrl
+	#define CLK_CTRL_FRAC			16	//[27:16]
+	#define CLK_CTRL_LEVEL			12	//[14:12]
+	
+	#define PLL_WAIT_LOCK_CNT		200
+
+/**** clk frequency limit ***/
+	/* PLL */
+	#define PLL_M_MIN				2
+	#define PLL_M_MAX				511
+	#define PLL_N_MIN				1
+	#define PLL_N_MAX				1
+	#define PLL_FREF_MIN			(5 * 1000)
+	#define PLL_FREF_MAX			(25 * 1000)
+	#define PLL_VCO_MIN				(1200 * 1000)
+	#define PLL_VCO_MAX				(3000 * 1000)
+	/* VIDEO */
+	#define MIPI_PHY_MAX_CLK_IN		(1000 * 1000)
+	#define DIV_PRE_MAX_CLK_IN		(1500 * 1000)
+	#define DIV_POST_MAX_CLK_IN		(1000 * 1000)
+	#define CRT_VID_MAX_CLK_IN		(1300 * 1000)
+	#define ENCL_MAX_CLK_IN			(333 * 1000)
+
+	/* lcd interface video clk */
+	#define MIPI_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+	#define LVDS_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+	#define TTL_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+
+	/* clk max error */
+	#define MAX_ERROR				(2 * 1000)
+
+#define CRT_VID_DIV_MAX				15
+
+#define OD_SEL_MAX					3
+#define DIV_PRE_SEL_MAX				6
+
+static const unsigned od_table[4] = {1,2,4,8};
+static const unsigned div_pre_table[6] = {1,2,3,4,5,6};
+//********************************************//
+
+#define SS_LEVEL_MAX	5
+static const char *lcd_ss_level_table[]={
+	"0",
+	"0.5%",
+	"1%",
+	"1.5%",
+	"2%",
+};
+
+#endif
diff --git a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
new file mode 100755
index 000000000000..601aa777b774
--- /dev/null
+++ b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
@@ -0,0 +1,1218 @@
+#include <linux/types.h>
+#include <mach/cpu.h>
+#include <plat/cpu.h>
+#include <mach/io.h>
+#include <plat/io.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <mach/lcd_reg.h>
+#include <mach/mipi_dsi_reg.h>
+#include <mach/lcdoutc.h>
+#include <linux/amlogic/vout/lcdoutc.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "lcd_config.h"
+#include "mipi_dsi_util.h"
+
+#define DPRINT(...)		printk(__VA_ARGS__)
+
+//===============================================================================
+// Define MIPI DSI Default config
+//===============================================================================
+#define MIPI_DSI_VIRTUAL_CHAN_ID        0                       // Range [0,3]
+#define MIPI_DSI_CMD_TRANS_TYPE         DCS_TRANS_LP            // Define DSI command transfer type: high speed or low power
+#define MIPI_DSI_DCS_ACK_TYPE           MIPI_DSI_DCS_NO_ACK     // Define if DSI command need ack: req_ack or no_ack
+#define MIPI_DSI_VIDEO_MODE_TYPE        BURST_MODE              // Applicable only to video mode. Define data transfer method: non-burst sync pulse; non-burst sync event; or burst.
+#define MIPI_DSI_TEAR_SWITCH            MIPI_DCS_DISABLE_TEAR
+#define CMD_TIMEOUT_CNT                 3000
+//===============================================================================
+
+static const char *video_mode_type_table[] = {
+    "COLOR_16BIT_CFG_1",
+    "COLOR_16BIT_CFG_2",
+    "COLOR_16BIT_CFG_3",
+    "COLOR_18BIT_CFG_1",
+    "COLOR_18BIT_CFG_2(loosely)",
+    "COLOR_24BIT",
+    "COLOR_20BIT_LOOSE",
+    "COLOR_24_BIT_YCBCR",
+    "COLOR_16BIT_YCBCR",
+    "COLOR_30BIT",
+    "COLOR_36BIT",
+    "COLOR_12BIT",
+    "COLOR_RGB_111",
+    "COLOR_RGB_332",
+    "COLOR_RGB_444",
+    "un-support type",
+};
+
+static DSI_Phy_t dsi_phy_config;
+static DSI_Config_t *dsi_config = NULL;
+static struct class *dsi_debug_class = NULL;
+static unsigned char dsi_init_on_table_dft[] = {
+    0x05,0x11,0,
+    0xff,50,
+    0x05,0x29,0,
+    0xff,20,
+    0xff,0xff,
+};
+
+static inline void print_mipi_cmd_status(int cnt, unsigned status)
+{
+    if (cnt == 0) {
+        DPRINT("cmd error: status=0x%04x, int0=0x%06x, int1=0x%06x\n", status, READ_LCD_REG(MIPI_DSI_DWC_INT_ST0_OS), READ_LCD_REG(MIPI_DSI_DWC_INT_ST1_OS));
+    }
+}
+
+static void print_info(void)
+{
+    int i, j, n;
+    unsigned temp;
+
+    if (dsi_config == NULL) {
+        DPRINT("dsi config is NULL\n");
+        return;
+    }
+    DPRINT("================================================\n");
+    DPRINT("MIPI DSI Config\n");
+    DPRINT(" Lane Num:              %d\n", dsi_config->lane_num);
+    DPRINT(" Bit Rate min:          %dMHz\n", (dsi_config->bit_rate_min / 1000));
+    DPRINT(" Bit Rate max:          %dMHz\n", (dsi_config->bit_rate_max / 1000));
+    DPRINT(" Bit Rate:              %d.%03dMHz\n", (dsi_config->bit_rate / 1000000), (dsi_config->bit_rate % 1000000) / 1000);
+    DPRINT(" Pclk lanebyte factor:  %d\n", ((dsi_config->factor_numerator * 100 / dsi_config->factor_denominator) + 5) / 10);
+    DPRINT(" Operation mode:\n");
+    DPRINT("     init:              %s\n", ((dsi_config->operation_mode>>BIT_OPERATION_MODE_INIT) & 1) ? "COMMAND":"VIDEO");
+    DPRINT("     display:           %s\n", ((dsi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1) ? "COMMAND":"VIDEO");
+    DPRINT(" Transfer control:\n");
+    DPRINT("     clk auto stop:     %d\n", ((dsi_config->transfer_ctrl>>BIT_TRANS_CTRL_CLK) & 1));
+    DPRINT("     transfer switch:   %d\n", ((dsi_config->transfer_ctrl>>BIT_TRANS_CTRL_SWITCH) & 3));
+    if(dsi_config->video_mode_type == NON_BURST_SYNC_PULSE) {
+        DPRINT(" Video mode type:       NON_BURST_SYNC_PULSE\n");
+    }
+    else if(dsi_config->video_mode_type == NON_BURST_SYNC_EVENT) {
+        DPRINT(" Video mode type:       NON_BURST_SYNC_EVENT\n");
+    }
+    else if(dsi_config->video_mode_type == BURST_MODE) {
+        DPRINT(" Video mode type:       BURST_MODE\n");
+    }
+
+    //DPRINT(" Venc format:           %d\n", dsi_config->venc_fmt);
+    DPRINT(" Data Format:           %s\n\n", video_mode_type_table[dsi_config->dpi_data_format]);
+    //DPRINT(" POLARITY:              HIGH ACTIVE\n");
+    //DPRINT(" Enable CRC/ECC/BTA\n");
+
+    temp = dsi_config->bit_rate / 8 / dsi_phy_config.lp_tesc;
+    DPRINT("DSI LP escape clock:    %d.%03dMHz\n", (temp / 1000000), (temp % 1000000) / 1000);
+    if (dsi_config->dsi_init_on) {
+        DPRINT("DSI INIT ON:\n");
+        i = 0;
+        while (i < DSI_INIT_ON_MAX) {
+            if (dsi_config->dsi_init_on[i] == 0xff) {
+                n = 2;
+                if (dsi_config->dsi_init_on[i+1] == 0xff) {
+                    DPRINT("    0x%02x,0x%02x,\n", dsi_config->dsi_init_on[i], dsi_config->dsi_init_on[i+1]);
+                    break;
+                }
+                else {
+                    DPRINT("    0x%02x,%d,\n", dsi_config->dsi_init_on[i], dsi_config->dsi_init_on[i+1]);
+                }
+            }
+            else {
+                n = 3 + dsi_config->dsi_init_on[i+2];
+                DPRINT("    ");
+                for (j=0; j<n; j++) {
+                    if (j == 2)
+                        DPRINT("%d,", dsi_config->dsi_init_on[i+j]);
+                    else
+                        DPRINT("0x%02x,", dsi_config->dsi_init_on[i+j]);
+                }
+                DPRINT("\n");
+            }
+            i += n;
+        }
+    }
+    if (dsi_config->dsi_init_off) {
+        DPRINT("DSI INIT OFF:\n");
+        i = 0;
+        while (i < DSI_INIT_OFF_MAX) {
+            if (dsi_config->dsi_init_off[i] == 0xff) {
+                n = 2;
+                if (dsi_config->dsi_init_off[i+1] == 0xff) {
+                    DPRINT("    0x%02x,0x%02x,\n", dsi_config->dsi_init_off[i], dsi_config->dsi_init_off[i+1]);
+                    break;
+                }
+                else {
+                    DPRINT("    0x%02x,%d,\n", dsi_config->dsi_init_off[i], dsi_config->dsi_init_off[i+1]);
+                }
+            }
+            else {
+                n = 3 + dsi_config->dsi_init_off[i+2];
+                DPRINT("    ");
+                for (j=0; j<n; j++) {
+                    if (j == 2)
+                        DPRINT("%d,", dsi_config->dsi_init_off[i+j]);
+                    else
+                        DPRINT("0x%02x,", dsi_config->dsi_init_off[i+j]);
+                }
+                DPRINT("\n");
+            }
+            i += n;
+        }
+    }
+    DPRINT("DSI INIT EXTERN:        %d\n", dsi_config->lcd_extern_init);
+    DPRINT("================================================\n");
+}
+
+static void print_dphy_info(void)
+{
+    unsigned temp;
+
+    temp = ((1000000 * 100) / (dsi_config->bit_rate / 1000)) * 8;
+    DPRINT("================================================\n");
+    DPRINT("MIPI DSI DPHY timing (unit: ns)\n"
+        " UI:                  %d.%02d\n"
+        " LP LPX:              %d\n"
+        " LP TA_SURE:          %d\n"
+        " LP TA_GO:            %d\n"
+        " LP TA_GET:           %d\n"
+        " HS EXIT:             %d\n"
+        " HS TRAIL:            %d\n"
+        " HS ZERO:             %d\n"
+        " HS PREPARE:          %d\n"
+        " CLK TRAIL:           %d\n"
+        " CLK POST:            %d\n"
+        " CLK ZERO:            %d\n"
+        " CLK PREPARE:         %d\n"
+        " CLK PRE:             %d\n"
+        " INIT:                %d\n"
+        " WAKEUP:              %d\n",
+        (temp / 8 / 100), ((temp / 8) % 100),
+        (temp * dsi_phy_config.lp_lpx / 100), (temp * dsi_phy_config.lp_ta_sure / 100), (temp * dsi_phy_config.lp_ta_go / 100), 
+        (temp * dsi_phy_config.lp_ta_get / 100), (temp * dsi_phy_config.hs_exit / 100), (temp * dsi_phy_config.hs_trail / 100), 
+        (temp * dsi_phy_config.hs_zero / 100), (temp * dsi_phy_config.hs_prepare / 100), (temp * dsi_phy_config.clk_trail / 100), 
+        (temp * dsi_phy_config.clk_post / 100), (temp * dsi_phy_config.clk_zero / 100), (temp * dsi_phy_config.clk_prepare / 100),
+        (temp * dsi_phy_config.clk_pre / 100), (temp * dsi_phy_config.init / 100), (temp * dsi_phy_config.wakeup / 100));
+    DPRINT("================================================\n");
+}
+
+// -----------------------------------------------------------------------------
+//                     Function: check_phy_st
+// Check the status of the dphy: phylock and stopstateclklane, to decide if the DPHY is ready
+// -----------------------------------------------------------------------------
+static void check_phy_status(void)
+{
+    while((( READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS ) >> BIT_PHY_LOCK) & 0x1) == 0){
+        udelay(6);
+    }
+    while((( READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS ) >> BIT_PHY_STOPSTATECLKLANE) & 0x1) == 0){
+        DBG_PRINT(" Waiting STOP STATE LANE\n");
+        udelay(6);
+    }
+}
+
+// -----------------------------------------------------------------------------
+//                     Function: set_mipi_dcs
+// Configure relative registers in command mode
+// -----------------------------------------------------------------------------
+static void set_mipi_dcs(int trans_type,        // 0: high speed, 1: low power
+                         int req_ack,           // 1: request ack, 0: do not need ack
+                         int tear_en)           // 1: enable tear ack, 0: disable tear ack
+{
+    WRITE_LCD_REG( MIPI_DSI_DWC_CMD_MODE_CFG_OS, (trans_type << BIT_MAX_RD_PKT_SIZE) | (trans_type << BIT_DCS_LW_TX)    |
+                    (trans_type << BIT_DCS_SR_0P_TX)    | (trans_type << BIT_DCS_SW_1P_TX) |
+                    (trans_type << BIT_DCS_SW_0P_TX)    | (trans_type << BIT_GEN_LW_TX)    |
+                    (trans_type << BIT_GEN_SR_2P_TX)    | (trans_type << BIT_GEN_SR_1P_TX) |
+                    (trans_type << BIT_GEN_SR_0P_TX)    | (trans_type << BIT_GEN_SW_2P_TX) |
+                    (trans_type << BIT_GEN_SW_1P_TX)    | (trans_type << BIT_GEN_SW_0P_TX) |
+                    (req_ack    << BIT_ACK_RQST_EN)     | (tear_en    << BIT_TEAR_FX_EN)  );
+
+    if (tear_en == MIPI_DCS_ENABLE_TEAR) {
+        // Enable Tear Interrupt if tear_en is valid
+        WRITE_LCD_REG( MIPI_DSI_TOP_INTR_CNTL_STAT, (READ_LCD_REG(MIPI_DSI_TOP_INTR_CNTL_STAT) | (0x1<<BIT_EDPITE_INT_EN)) );
+        // Enable Measure Vsync
+        WRITE_LCD_REG( MIPI_DSI_TOP_MEAS_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_MEAS_CNTL) | (0x1<<BIT_VSYNC_MEAS_EN | (0x1<<BIT_TE_MEAS_EN))));
+    }
+}
+// -----------------------------------------------------------------------------
+//                     Function: set_mipi_int
+// Configure relative registers for mipi interrupt
+// -----------------------------------------------------------------------------
+static void set_mipi_int(void)
+{
+    WRITE_LCD_REG( MIPI_DSI_DWC_INT_MSK0_OS, 0);
+    WRITE_LCD_REG( MIPI_DSI_DWC_INT_MSK1_OS, 0);
+}
+
+// ----------------------------------------------------------------------------
+// Function: wait_bta_ack
+// Poll to check if the BTA ack is finished
+// ----------------------------------------------------------------------------
+static void wait_bta_ack(void)
+{
+    unsigned int phy_status;
+
+    // Check if phydirection is RX
+    do {
+        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+    } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x0);
+
+    // Check if phydirection is return to TX
+    do {
+        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+    } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x1);
+}
+
+// ----------------------------------------------------------------------------
+// Function: wait_cmd_fifo_empty
+// Poll to check if the generic command fifo is empty
+// ----------------------------------------------------------------------------
+static void wait_cmd_fifo_empty(void)
+{
+    unsigned int cmd_status;
+    int i= CMD_TIMEOUT_CNT;
+
+    do {
+        udelay(10);
+        i--;
+        cmd_status = READ_LCD_REG(MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
+    } while((((cmd_status >> BIT_GEN_CMD_EMPTY) & 0x1) != 0x1) && (i>0));
+    print_mipi_cmd_status(i, cmd_status);
+}
+
+// ----------------------------------------------------------------------------
+// Function: wait_for_generic_read_response
+// Wait for generic read response
+// ----------------------------------------------------------------------------
+static unsigned int wait_for_generic_read_response(void)
+{
+    unsigned int timeout, phy_status, data_out;
+
+    phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+    for(timeout=0; timeout<50; timeout++) {
+        if(((phy_status & 0x40)>> BIT_PHY_RXULPSESC0LANE) == 0x0)
+            break;
+        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+        udelay(1);
+    }
+    phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+    for(timeout=0; timeout<50; timeout++) {
+        if(((phy_status & 0x40)>> BIT_PHY_RXULPSESC0LANE) == 0x1)
+            break;
+        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+        udelay(1);
+    }
+
+    data_out = READ_LCD_REG( MIPI_DSI_DWC_GEN_PLD_DATA_OS );
+    return data_out;
+}
+
+// ----------------------------------------------------------------------------
+// Function: generic_if_wr
+// Generic interface write, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS and
+// MIPI_DSI_DWC_GEN_HDR_OS, MIPI_DSI_DWC_GEN_VCID_OS
+// ----------------------------------------------------------------------------
+static unsigned int generic_if_wr(unsigned int address, unsigned int data_in)
+{
+    if(address != MIPI_DSI_DWC_GEN_HDR_OS && address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
+        DBG_PRINT(" Error Address : 0x%x\n", address);
+    }
+
+    DBG_PRINT("address 0x%x = 0x%08x\n", address, data_in);
+    WRITE_LCD_REG(address, data_in);
+
+    return 0;
+}
+
+// ----------------------------------------------------------------------------
+//                           Function: generic_if_rd
+// Generic interface read, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS
+// ----------------------------------------------------------------------------
+static unsigned int generic_if_rd(unsigned int address)
+{
+    unsigned int data_out;
+
+    if(address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
+        DBG_PRINT(" Error Address : %x\n", address);
+    }
+
+    data_out = READ_DSI_REG(address);
+
+    return data_out;
+}
+
+// ----------------------------------------------------------------------------
+//                           Function: generic_read_packet_0_para
+// Generic Read Packet 0 Parameter with Generic Interface
+// Supported DCS Command: DCS_SET_ADDRESS_MODE/DCS_SET_GAMMA_CURVE/
+//                        DCS_SET_PIXEL_FORMAT/DCS_SET_TEAR_ON
+// ----------------------------------------------------------------------------
+static unsigned int generic_read_packet_0_para(unsigned char data_type, unsigned char vc_id, unsigned char dcs_command)
+{
+    unsigned int read_data;
+
+    // DBG_PRINT(" para is %x, dcs_command is %x\n", para, dcs_command);
+    // DBG_PRINT(" vc_id %x, data_type is %x\n", vc_id, data_type);
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((0 << BIT_GEN_WC_MSBYTE)                           |
+                                            (((unsigned int)dcs_command) << BIT_GEN_WC_LSBYTE) |
+                                            (((unsigned int)vc_id) << BIT_GEN_VC)              |
+                                            (((unsigned int)data_type) << BIT_GEN_DT)));
+
+    read_data = wait_for_generic_read_response();
+
+    return read_data;
+}
+
+// ----------------------------------------------------------------------------
+//                           Function: generic_write_short_packet
+// Generic Write Short Packet with Generic Interface
+// Supported Data Type: DT_GEN_SHORT_WR_0, DT_GEN_SHORT_WR_1, DT_GEN_SHORT_WR_2,
+// ----------------------------------------------------------------------------
+static void dsi_generic_write_short_packet(unsigned char data_type, unsigned char vc_id, unsigned char* payload, unsigned short pld_count, unsigned int req_ack)
+{
+    unsigned int d_para[2];
+
+    vc_id &= 0x3;
+    switch (data_type) {
+        case DT_GEN_SHORT_WR_0:
+            d_para[0] = 0;
+            d_para[1] = 0;
+            break;
+        case DT_GEN_SHORT_WR_1:
+            d_para[0] = ((unsigned int)payload[1]) & 0xff;
+            d_para[1] = 0;
+            break;
+        case DT_GEN_SHORT_WR_2:
+        default:
+            d_para[0] = ((unsigned int)payload[1]) & 0xff;
+            d_para[1] = (pld_count == 0) ? 0 : (((unsigned int)payload[3]) & 0xff);
+            break;
+    }
+
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para[1] << BIT_GEN_WC_MSBYTE)      |
+                                            (d_para[0] << BIT_GEN_WC_LSBYTE)      |
+                                            (((unsigned int)vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)data_type) << BIT_GEN_DT)));
+    if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+        wait_bta_ack();
+    }
+    else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
+        wait_cmd_fifo_empty();
+    }
+}
+
+// ----------------------------------------------------------------------------
+//                           Function: dcs_write_short_packet
+// DCS Write Short Packet with Generic Interface
+// Supported Data Type: DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
+// ----------------------------------------------------------------------------
+static void dsi_dcs_write_short_packet(unsigned char data_type, unsigned char vc_id, unsigned char* payload, unsigned short pld_count, unsigned int req_ack)
+{
+    unsigned int d_command, d_para;
+
+    vc_id &= 0x3;
+    d_command = ((unsigned int)payload[1]) & 0xff;
+    d_para = (pld_count == 0) ? 0 : (((unsigned int)payload[3]) & 0xff);
+
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para << BIT_GEN_WC_MSBYTE)         |
+                                            (d_command << BIT_GEN_WC_LSBYTE)      |
+                                            (((unsigned int)vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)data_type) << BIT_GEN_DT)));
+    if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+        wait_bta_ack();
+    }
+    else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
+        wait_cmd_fifo_empty();
+    }
+}
+
+// ----------------------------------------------------------------------------
+//                           Function: dsi_write_long_packet
+// Write Long Packet with Generic Interface
+// Supported Data Type: DT_GEN_LONG_WR, DT_DCS_LONG_WR
+// ----------------------------------------------------------------------------
+static void dsi_write_long_packet(unsigned char data_type, unsigned char vc_id, unsigned char* payload, unsigned short pld_count, unsigned int req_ack)
+{
+    unsigned int d_command, payload_data=0, header_data;
+    unsigned int cmd_status;
+    unsigned int i, d_start_index;
+    int j;
+
+    vc_id &= 0x3;
+    d_command = ((unsigned int)payload[1]) & 0xff;
+    pld_count = (pld_count + 1) & 0xffff;//include command
+    d_start_index = 3;//payload[3] start (payload[0]: data_type, payload[1]: command, payload[2]: para_num)
+
+    // Write Payload Register First
+    payload_data = d_command;
+    for(i=1; i<pld_count; i++) {
+        if(i%4 == 0)
+            payload_data = 0;
+        payload_data |= (((unsigned int)payload[i-1+d_start_index]) << 8*(i%4));
+
+        if((i%4 == 3) || (i == (pld_count-1))) {  // when last byte  //write max 4 byte payload data once
+            // Check the pld fifo status before write to it, do not need check every word
+            if((i == (pld_count/3)) || (i == (pld_count/2))) {
+                j = CMD_TIMEOUT_CNT;
+                do {
+                    udelay(10);
+                    j--;
+                    cmd_status = READ_LCD_REG(MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
+                } while((((cmd_status >> BIT_GEN_PLD_W_FULL) & 0x1) == 0x1) && (j>0));
+                print_mipi_cmd_status(j, cmd_status);
+            }
+            if(d_command == DCS_WRITE_MEMORY_CONTINUE) { // Use direct memory write to save time when in WRITE_MEMORY_CONTINUE
+                WRITE_LCD_REG(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
+            }
+            else {
+                generic_if_wr(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
+            }
+        }
+    }
+
+    // Check cmd fifo status before write to it
+    j = CMD_TIMEOUT_CNT;
+    do {
+        udelay(10);
+        j--;
+        cmd_status = READ_LCD_REG(MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
+    } while((((cmd_status >> BIT_GEN_CMD_FULL) & 0x1) == 0x1) && (j>0));
+    print_mipi_cmd_status(j, cmd_status);
+    // Write Header Register
+    header_data = ( (((unsigned int)pld_count) << BIT_GEN_WC_LSBYTE) |//include command
+                    (((unsigned int)vc_id) << BIT_GEN_VC)                |
+                    (((unsigned int)data_type) << BIT_GEN_DT));
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, header_data);
+    if (req_ack == MIPI_DSI_DCS_REQ_ACK) {
+        wait_bta_ack();
+    }
+    else if (req_ack == MIPI_DSI_DCS_NO_ACK) {
+        wait_cmd_fifo_empty();
+    }
+}
+
+// ----------------------------------------------------------------------------
+//                           Function: dsi_write_cmd
+// Generic Write Command
+// Supported Data Type: DT_GEN_SHORT_WR_0, DT_GEN_SHORT_WR_1, DT_GEN_SHORT_WR_2,
+//                      DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
+//                      DT_GEN_LONG_WR, DT_DCS_LONG_WR,
+//                      DT_SET_MAX_RPS
+// Return:              command number
+// ----------------------------------------------------------------------------
+int dsi_write_cmd(unsigned char* payload)
+{
+    int i=0, j=0;
+    int num = 0;
+    unsigned char vc_id = MIPI_DSI_VIRTUAL_CHAN_ID;
+    unsigned int req_ack = MIPI_DSI_DCS_ACK_TYPE;
+
+    //payload struct:
+    //data_type, command, para_num, parameters...
+    //data_type=0xff, command=0xff, means ending flag
+    //data_type=0xff, command<0xff, means delay time(unit ms)
+    while(i < DSI_CMD_SIZE_MAX) {
+        if(payload[i]==0xff) {
+            j = 2;
+            if(payload[i+1]==0xff)
+                break;
+            else
+                mdelay(payload[i+1]);
+        }
+        else {
+            j = 3 + payload[i+2]; //payload[i+2] is parameter num
+            switch (payload[i]) {//analysis data_type
+                case DT_GEN_SHORT_WR_0:
+                case DT_GEN_SHORT_WR_1:
+                case DT_GEN_SHORT_WR_2:
+                    dsi_generic_write_short_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
+                    break;
+                case DT_DCS_SHORT_WR_0:
+                case DT_DCS_SHORT_WR_1:
+                    dsi_dcs_write_short_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
+                    break;
+                case DT_DCS_LONG_WR:
+                case DT_GEN_LONG_WR:
+                    dsi_write_long_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
+                    break;
+                case DT_SET_MAX_RPS:
+                    DPRINT("to do data_type: 0x%2x\n", payload[i]);
+                    break;
+                case DT_TURN_ON:
+                    WRITE_LCD_REG_BITS(MIPI_DSI_TOP_CNTL, 1, 2, 1);
+                    mdelay(20); //wait for vsync trigger
+                    WRITE_LCD_REG_BITS(MIPI_DSI_TOP_CNTL, 0, 2, 1);
+                    mdelay(20); //wait for vsync trigger
+                    break;
+                case DT_SHUT_DOWN:
+                    WRITE_LCD_REG_BITS(MIPI_DSI_TOP_CNTL, 1, 2, 1);
+                    mdelay(20); //wait for vsync trigger
+                    break;
+                default:
+                    DPRINT("un-support data_type: 0x%02x\n", payload[i]);
+            }
+        }
+        i += j;
+        num++;
+    }
+
+    return num;
+}
+
+static void set_dsi_phy_config(DSI_Phy_t *dphy, unsigned dsi_ui)
+{
+    unsigned t_lane_byte, t_ui;
+
+    t_ui = (1000000 * 100) / (dsi_ui / 1000); //0.01ns*100
+    t_lane_byte = t_ui * 8;
+
+    dphy->lp_tesc = ((DPHY_TIME_LP_TESC(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->lp_lpx = ((DPHY_TIME_LP_LPX(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->lp_ta_sure = ((DPHY_TIME_LP_TA_SURE(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->lp_ta_go = ((DPHY_TIME_LP_TA_GO(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->lp_ta_get = ((DPHY_TIME_LP_TA_GETX(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->hs_exit = ((DPHY_TIME_HS_EXIT(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->hs_trail = ((DPHY_TIME_HS_TRAIL(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->hs_prepare = ((DPHY_TIME_HS_PREPARE(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->hs_zero = ((DPHY_TIME_HS_ZERO(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->clk_trail = ((DPHY_TIME_CLK_TRAIL(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->clk_post = ((DPHY_TIME_CLK_POST(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->clk_prepare = ((DPHY_TIME_CLK_PREPARE(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->clk_zero = ((DPHY_TIME_CLK_ZERO(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->clk_pre = ((DPHY_TIME_CLK_PRE(t_ui) + t_lane_byte - 1) / t_lane_byte) & 0xff;
+    dphy->init = (DPHY_TIME_INIT(t_ui) + t_lane_byte - 1) / t_lane_byte;
+    dphy->wakeup = (DPHY_TIME_WAKEUP(t_ui) + t_lane_byte - 1) / t_lane_byte;
+
+    DBG_PRINT("lp_tesc = 0x%02x\n"
+            "lp_lpx = 0x%02x\n"
+            "lp_ta_sure = 0x%02x\n"
+            "lp_ta_go = 0x%02x\n"
+            "lp_ta_get = 0x%02x\n"
+            "hs_exit = 0x%02x\n"
+            "hs_trail = 0x%02x\n"
+            "hs_zero = 0x%02x\n"
+            "hs_prepare = 0x%02x\n"
+            "clk_trail = 0x%02x\n"
+            "clk_post = 0x%02x\n"
+            "clk_zero = 0x%02x\n"
+            "clk_prepare = 0x%02x\n"
+            "clk_pre = 0x%02x\n"
+            "init = 0x%02x\n"
+            "wakeup = 0x%02x\n",
+            dphy->lp_tesc, dphy->lp_lpx, dphy->lp_ta_sure, dphy->lp_ta_go, dphy->lp_ta_get,
+            dphy->hs_exit, dphy->hs_trail, dphy->hs_zero, dphy->hs_prepare,
+            dphy->clk_trail, dphy->clk_post, dphy->clk_zero, dphy->clk_prepare, dphy->clk_pre,
+            dphy->init, dphy->wakeup);
+}
+
+static void dsi_phy_init(DSI_Phy_t *dphy, unsigned char lane_num)
+{
+    // enable phy clock.
+    WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1);          //enable DSI top clock.
+    WRITE_DSI_REG(MIPI_DSI_PHY_CTRL,  0x1 |          //enable the DSI PLL clock .
+                    (1 << 7 )  |   //enable pll clock which connected to  DDR clock path
+                    (1 << 8 )  |   //enable the clock divider counter
+                    (0 << 9 )  |   //enable the divider clock out
+                    (0 << 10 ) |   //clock divider. 1: freq/4, 0: freq/2
+                    (0 << 11 ) |   //1: select the mipi DDRCLKHS from clock divider, 0: from PLL clock
+                    (0 << 12));    //enable the byte clock generateion.
+    WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL,  1, 9, 1); //enable the divider clock out
+    WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL,  1, 12, 1); //enable the byte clock generateion.
+    WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL,  1, 31, 1);
+    WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL,  0, 31, 1);
+
+    WRITE_DSI_REG(MIPI_DSI_CLK_TIM,  (dphy->clk_trail | (dphy->clk_post << 8) | (dphy->clk_zero << 16) | (dphy->clk_prepare << 24)));//0x05210f08);//0x03211c08
+    WRITE_DSI_REG(MIPI_DSI_CLK_TIM1, dphy->clk_pre);//??
+    WRITE_DSI_REG(MIPI_DSI_HS_TIM, (dphy->hs_exit | (dphy->hs_trail << 8) | (dphy->hs_zero << 16) | (dphy->hs_prepare << 24)));//0x050f090d
+    WRITE_DSI_REG(MIPI_DSI_LP_TIM, (dphy->lp_lpx | (dphy->lp_ta_sure << 8) | (dphy->lp_ta_go << 16) | (dphy->lp_ta_get << 24)));//0x4a370e0e
+    WRITE_DSI_REG(MIPI_DSI_ANA_UP_TIM, 0x0100); //?? //some number to reduce sim time.
+    WRITE_DSI_REG(MIPI_DSI_INIT_TIM, dphy->init); //0xe20   //30d4 -> d4 to reduce sim time.
+    WRITE_DSI_REG(MIPI_DSI_WAKEUP_TIM, dphy->wakeup); //0x8d40  //1E848-> 48 to reduct sim time.
+    WRITE_DSI_REG(MIPI_DSI_LPOK_TIM,  0x7C);   //wait for the LP analog ready.
+    WRITE_DSI_REG(MIPI_DSI_ULPS_CHECK,  0x927C);   //1/3 of the tWAKEUP.
+    WRITE_DSI_REG(MIPI_DSI_LP_WCHDOG,  0x1000);   // phy TURN watch dog.
+    WRITE_DSI_REG(MIPI_DSI_TURN_WCHDOG,  0x1000);   // phy ESC command watch dog.
+
+    // Powerup the analog circuit.
+    switch (lane_num) {
+        case 1:
+            WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0x0e);
+            break;
+        case 2:
+            WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0x0c);
+            break;
+        case 3:
+            WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0x08);
+            break;
+        case 4:
+        default:
+            WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0);
+            break;
+    }
+}
+
+static void mipi_dsi_phy_config(Lcd_Config_t *pConf)
+{
+    DBG_PRINT("%s\n", __func__);
+    //Digital
+    // Power up DSI
+    WRITE_LCD_REG(MIPI_DSI_DWC_PWR_UP_OS, 1);
+
+    // Setup Parameters of DPHY
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL1_OS, 0x00010044);                            // testcode
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x2);
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x0);
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL1_OS, 0x00000074);                            // testwrite
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x2);
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_TST_CTRL0_OS, 0x0);
+
+    // Power up D-PHY
+    WRITE_LCD_REG(MIPI_DSI_DWC_PHY_RSTZ_OS, 0xf);
+
+    //Analog
+    dsi_phy_init(&dsi_phy_config, pConf->lcd_control.mipi_config->lane_num);
+
+    // Check the phylock/stopstateclklane to decide if the DPHY is ready
+    check_phy_status();
+
+    // Trigger a sync active for esc_clk
+    WRITE_DSI_REG(MIPI_DSI_PHY_CTRL, READ_DSI_REG(MIPI_DSI_PHY_CTRL) | (1 << 1));
+}
+
+static void dsi_video_config(Lcd_Config_t *pConf)
+{
+    unsigned int hline, hsa, hbp;
+    unsigned int vsa, vbp, vfp, vact;
+    DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
+
+    hline =(pConf->lcd_basic.h_period * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;  // Rounded. Applicable for Period(pixclk)/Period(bytelaneclk)=9/16
+    hsa =(pConf->lcd_timing.hsync_width * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
+    hbp =((pConf->lcd_timing.hsync_bp-pConf->lcd_timing.hsync_width) * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
+
+    vsa = pConf->lcd_timing.vsync_width;
+    vbp = pConf->lcd_timing.vsync_bp - pConf->lcd_timing.vsync_width;
+    vfp = pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp - pConf->lcd_basic.v_active;
+    vact = pConf->lcd_basic.v_active;
+
+    DBG_PRINT(" ============= VIDEO TIMING SETTING =============\n");
+    DBG_PRINT(" HLINE        = %d\n", hline);
+    DBG_PRINT(" HSA          = %d\n", hsa);
+    DBG_PRINT(" HBP          = %d\n", hbp);
+    DBG_PRINT(" VSA          = %d\n", vsa);
+    DBG_PRINT(" VBP          = %d\n", vbp);
+    DBG_PRINT(" VFP          = %d\n", vfp);
+    DBG_PRINT(" VACT         = %d\n", vact);
+    DBG_PRINT(" ================================================\n");
+
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HLINE_TIME_OS,    hline);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HSA_TIME_OS,      hsa);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HBP_TIME_OS,      hbp);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VSA_LINES_OS,     vsa);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VBP_LINES_OS,     vbp);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VFP_LINES_OS,     vfp);
+    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VACTIVE_LINES_OS, vact);
+}
+
+static void startup_transfer_cmd(void)
+{
+    // Startup transfer
+    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_AUTOCLKLANE_CTRL) | (0x1 << BIT_TXREQUESTCLKHS));
+}
+static void startup_transfer_video(void)
+{
+    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_TXREQUESTCLKHS));
+}
+
+static void set_mipi_dsi_host(int lane_num,                      // lane number, from 1 to 4
+                              int vcid,                          // virtual id
+                              int venc_data_width,               // VENC output data width
+                              int dpi_data_format,               // dpi data format
+                              int chroma_subsample,              // chroma_subsample for YUV422 or YUV420 only
+                              int operation_mode,                // video mode/command mode
+                              tv_enc_lcd_type_t output_type,     // video type, such as 1080x720
+                              int vid_mode_type,                 // video mode : burst/non_burst
+                              Lcd_Config_t *p)
+{
+    int num_of_chunk;
+    int pixel_per_chunk = 4;
+    int byte_per_chunk=0;
+    int totol_bytes_per_chunk;
+    int chunk_overhead;
+    int vid_null_size=0;
+
+    totol_bytes_per_chunk = lane_num*pixel_per_chunk*3/4;
+
+    // one lene has 8 bytes for 4 pixels
+    // according to DSI spec line50
+    switch(dpi_data_format) {
+        case COLOR_24_BIT_YCBCR :
+        case COLOR_24BIT        :
+            byte_per_chunk = 18;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
+            // byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
+            break;
+        case COLOR_20BIT_LOOSE  :
+        case COLOR_18BIT_CFG_2  :
+            byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
+            break;
+        case COLOR_16BIT_YCBCR :
+        case COLOR_16BIT_CFG_1 :
+        case COLOR_16BIT_CFG_2 :
+        case COLOR_16BIT_CFG_3 :
+            byte_per_chunk =  8;                                             // at least 3 lanes(8+6=14): 3*8-14=10>6
+            break;
+        case COLOR_30BIT :
+            byte_per_chunk = 15;                                             // at least 4 lanes(15+6=21): 4*8-21=11>6
+            break;
+        case COLOR_36BIT :
+            byte_per_chunk = 18;                                             // at least 4 leans(18+6=24): 4*8-24=8>6
+            break;
+        case COLOR_12BIT :
+            byte_per_chunk =  6;                                             // at least 3 leans(6+6=12): 3*8-12=12>6
+            break;
+        case COLOR_18BIT_CFG_1 :
+            byte_per_chunk =  9;                                             // at least 23lanes(9+6=15): 3*8-15=9>6
+            break;
+        case COLOR_RGB_111 :
+        case COLOR_RGB_332 :
+        case COLOR_RGB_444 :
+            break;
+        default :
+            DBG_PRINT(" Error: un-support data Format So Far, Please Add More\n");
+            break;
+    }    /*switch(dpi_data_format)*/
+    num_of_chunk = p->lcd_basic.h_active / pixel_per_chunk;
+    chunk_overhead = totol_bytes_per_chunk-(byte_per_chunk+6);                 // byte_per_chunk+6=valid_payload
+
+    if(operation_mode == OPERATION_VIDEO_MODE && vid_mode_type != BURST_MODE) {
+        if(chunk_overhead >= 6) {                                              // if room for null_vid's head(4)+crc(2)
+            vid_null_size = chunk_overhead-6;                                  // chunk_overhead-null_vid's head(4)+crc(2) = null_vid's payload
+        } else {
+            DBG_PRINT(" No room for null, chunk_overhead is %d\n", chunk_overhead);
+        }
+    }
+    // -----------------------------------------------------
+    // Standard Configuration for Video Mode Operation
+    // -----------------------------------------------------
+    // 1,    Configure Lane number and phy stop wait time
+    if ((output_type != TV_ENC_LCD240x160_dsi) && (output_type != TV_ENC_LCD1920x1200p) &&
+        (output_type != TV_ENC_LCD2560x1600) && (output_type != TV_ENC_LCD768x1024p)) {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_IF_CFG_OS, (0x28 << BIT_PHY_STOP_WAIT_TIME) | ((lane_num-1) << BIT_N_LANES));
+    } else {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_IF_CFG_OS, (1 << BIT_PHY_STOP_WAIT_TIME) | ((lane_num-1) << BIT_N_LANES));
+    }
+
+    // 2.1,  Configure Virtual channel settings
+    WRITE_LCD_REG( MIPI_DSI_DWC_DPI_VCID_OS, vcid );
+    // 2.2,  Configure Color format
+    WRITE_LCD_REG( MIPI_DSI_DWC_DPI_COLOR_CODING_OS, (((dpi_data_format == COLOR_18BIT_CFG_2) ? 1 : 0) << BIT_LOOSELY18_EN) | (dpi_data_format << BIT_DPI_COLOR_CODING) );
+    // 2.2.1 Configure Set color format for DPI register
+    WRITE_LCD_REG( MIPI_DSI_TOP_CNTL, ((READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0xf<<BIT_DPI_COLOR_MODE) & ~(0x7<<BIT_IN_COLOR_MODE) & ~(0x3<<BIT_CHROMA_SUBSAMPLE)) |
+                                (dpi_data_format    << BIT_DPI_COLOR_MODE)  |
+                                (venc_data_width    << BIT_IN_COLOR_MODE)   |
+                                (chroma_subsample   << BIT_CHROMA_SUBSAMPLE)) );
+    // 2.3   Configure Signal polarity
+    WRITE_LCD_REG( MIPI_DSI_DWC_DPI_CFG_POL_OS, (0x0 << BIT_COLORM_ACTIVE_LOW) |
+                        (0x0 << BIT_SHUTD_ACTIVE_LOW)  |
+                        (0 << BIT_HSYNC_ACTIVE_LOW)  |//(((p->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1) << BIT_HSYNC_ACTIVE_LOW)  |
+                        (0 << BIT_VSYNC_ACTIVE_LOW)  |//(((p->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1) << BIT_VSYNC_ACTIVE_LOW)  |
+                        (0x0 << BIT_DATAEN_ACTIVE_LOW));
+
+    if (operation_mode == OPERATION_VIDEO_MODE) {
+        // 3.1   Configure Low power and video mode type settings
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_MODE_CFG_OS, (1 << BIT_LP_HFP_EN)  |                  // enalbe lp
+                        (1 << BIT_LP_HBP_EN)  |                  // enalbe lp
+                        (1 << BIT_LP_VCAT_EN) |                  // enalbe lp
+                        (1 << BIT_LP_VFP_EN)  |                  // enalbe lp
+                        (1 << BIT_LP_VBP_EN)  |                  // enalbe lp
+                        (1 << BIT_LP_VSA_EN)  |                  // enalbe lp
+                        (1 << BIT_FRAME_BTA_ACK_EN) |            // enable BTA after one frame, TODO, need check
+                        //(1 << BIT_LP_CMD_EN) |                   // enable the command transmission only in lp mode
+                        (vid_mode_type << BIT_VID_MODE_TYPE) );  // burst/non burst
+        WRITE_LCD_REG( MIPI_DSI_DWC_DPI_LP_CMD_TIM_OS, (4 << 16) | (4 << 0));  //[23:16]outvact, [7:0]invact
+
+        // 3.2   Configure video packet size settings
+        if( vid_mode_type == BURST_MODE ) {                                        // burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, p->lcd_basic.h_active);                          // should be one line in pixels, such as 480/240...
+        }
+        else if(vid_mode_type == NON_BURST_SYNC_PULSE || vid_mode_type == NON_BURST_SYNC_EVENT) {                           // non-burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, pixel_per_chunk);                    // in unit of pixels, (pclk period/byte clk period)*num_of_lane should be integer
+            // in our system, 16/8*num_of_lane is integer, so 6 pixel should be enough for 24bpp
+            // Worst case: (16/8)*8(pixel)*1(lane) >= 6(pkt head+crc)+3(max 24bpp)
+        }
+
+        // 3.3   Configure number of chunks and null packet size for one line
+        if( vid_mode_type == BURST_MODE ) {                                        // burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, 0);
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, 0);
+        }
+        else {                                                                     // non burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, num_of_chunk);                     // HACT/VID_PKT_SIZE
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, vid_null_size);                     // video null size
+            DBG_PRINT(" ============== NON_BURST SETTINGS =============\n");
+            DBG_PRINT(" pixel_per_chunk       = %d\n", pixel_per_chunk);
+            DBG_PRINT(" num_of_chunk          = %d\n", num_of_chunk);
+            DBG_PRINT(" totol_bytes_per_chunk = %d\n", totol_bytes_per_chunk);
+            DBG_PRINT(" byte_per_chunk        = %d\n", byte_per_chunk);
+            DBG_PRINT(" chunk_overhead        = %d\n", chunk_overhead);
+            DBG_PRINT(" vid_null_size         = %d\n", vid_null_size);
+            DBG_PRINT(" ===============================================\n");
+        }
+
+        // 4     Configure the video relative parameters according to the output type
+        //         include horizontal timing and vertical line
+        dsi_video_config(p);
+    }  /* operation_mode == OPERATION_VIDEO_MODE */
+
+    // -----------------------------------------------------
+    // Finish Configuration
+    // -----------------------------------------------------
+
+    // Inner clock divider settings
+    WRITE_LCD_REG( MIPI_DSI_DWC_CLKMGR_CFG_OS, (0x1 << BIT_TO_CLK_DIV) | (dsi_phy_config.lp_tesc << BIT_TX_ESC_CLK_DIV) );
+    // Packet header settings
+    WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
+                        (1 << BIT_ECC_RX_EN) |
+                        (0 << BIT_BTA_EN) |
+                        (0 << BIT_EOTP_RX_EN) |
+                        (0 << BIT_EOTP_TX_EN) );
+    // operation mode setting: video/command mode
+    WRITE_LCD_REG( MIPI_DSI_DWC_MODE_CFG_OS, operation_mode );
+
+    // Phy Timer
+    if ((output_type != TV_ENC_LCD240x160_dsi) &&
+                    (output_type != TV_ENC_LCD1920x1200p) &&
+                    (output_type != TV_ENC_LCD2560x1600) &&
+                    (output_type != TV_ENC_LCD768x1024p)) {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x03320000);
+    } else {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_CFG_OS, 0x090f0000);
+    }
+
+    // Configure DPHY Parameters
+    if ((output_type != TV_ENC_LCD240x160_dsi) &&
+                    (output_type != TV_ENC_LCD1920x1200p) &&
+                    (output_type != TV_ENC_LCD2560x1600) &&
+                    (output_type != TV_ENC_LCD768x1024p)) {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS, 0x870025);
+    } else {
+        WRITE_LCD_REG( MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS, 0x260017);
+    }
+}
+
+static void mipi_dsi_host_config(Lcd_Config_t *pConf)
+{
+    unsigned int        dpi_data_format;
+    unsigned int        venc_data_width;
+    tv_enc_lcd_type_t   venc_format;
+    unsigned char       lane_num;
+    unsigned char       operation_mode_init, video_mode_type;
+
+    operation_mode_init  = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1);
+    video_mode_type = pConf->lcd_control.mipi_config->video_mode_type;
+    venc_format     = pConf->lcd_control.mipi_config->venc_fmt;
+    venc_data_width = pConf->lcd_control.mipi_config->venc_data_width;
+    dpi_data_format = pConf->lcd_control.mipi_config->dpi_data_format;
+    lane_num        = pConf->lcd_control.mipi_config->lane_num;
+
+#ifdef LCD_DEBUG_INFO
+    print_info();
+    print_dphy_info();
+#endif
+
+    DBG_PRINT("Set mipi_dsi_host\n");
+    set_mipi_dcs(MIPI_DSI_CMD_TRANS_TYPE,              // 0: high speed, 1: low power
+                 MIPI_DSI_DCS_ACK_TYPE,                // if need bta ack check
+                 MIPI_DSI_TEAR_SWITCH);                // enable tear ack
+
+    set_mipi_dsi_host(lane_num,                        // Lane number
+                      MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
+                      venc_data_width,                 // MIPI dsi venc data bit width
+                      dpi_data_format,                 // MIPI dsi dpi data format
+                      0,                               // Chroma sub sample, only for YUV 422 or 420, even or odd
+                      operation_mode_init,             // DSI operation mode, video or command
+                      venc_format,                     // Venc resolution format, eg, 240x160
+                      video_mode_type,                 // Video mode, burst or non-burst
+                      pConf);
+}
+
+void mipi_dsi_link_on(Lcd_Config_t *pConf)
+{
+    unsigned int      dpi_data_format;
+    unsigned int      venc_data_width;
+    tv_enc_lcd_type_t venc_format;
+    unsigned char     lane_num;
+    unsigned char     operation_mode_disp, video_mode_type;
+    struct aml_lcd_extern_driver_t *lcd_extern_driver;
+    unsigned int init_flag = 0;
+
+    DPRINT("%s\n", __FUNCTION__);
+    operation_mode_disp = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
+    video_mode_type = pConf->lcd_control.mipi_config->video_mode_type;
+    venc_format     = pConf->lcd_control.mipi_config->venc_fmt;
+    venc_data_width = pConf->lcd_control.mipi_config->venc_data_width;
+    dpi_data_format = pConf->lcd_control.mipi_config->dpi_data_format;
+    lane_num        = pConf->lcd_control.mipi_config->lane_num;
+
+    if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
+        lcd_extern_driver = aml_lcd_extern_get_driver();
+        if (lcd_extern_driver == NULL) {
+            DPRINT("no lcd_extern driver\n");
+        }
+        else {
+            if (lcd_extern_driver->init_on_cmd_8) {
+                init_flag += dsi_write_cmd(lcd_extern_driver->init_on_cmd_8);
+                DPRINT("[extern]%s dsi init on\n", lcd_extern_driver->name);
+            }
+        }
+    }
+
+    if (pConf->lcd_control.mipi_config->dsi_init_on) {
+        init_flag += dsi_write_cmd(pConf->lcd_control.mipi_config->dsi_init_on);
+        DBG_PRINT("dsi init on\n");
+    }
+
+    if (init_flag == 0) {
+        DPRINT("[warning]: not init for mipi-dsi, use default command\n");
+        dsi_write_cmd(dsi_init_on_table_dft);
+    }
+
+    if (operation_mode_disp != ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1)) {
+        set_mipi_dsi_host(lane_num,                        // Lane number
+                          MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
+                          venc_data_width,                 // MIPI dsi venc RGB data bit width
+                          dpi_data_format,                 // MIPI dsi dpi data format
+                          0,                               // Chroma sub sample, only for YUV 422 or 420, even or odd
+                          operation_mode_disp,             // DSI operation mode, video or command
+                          venc_format,                     // Venc resolution format, eg, 240x160
+                          video_mode_type,                 // Video mode, burst or non-burst
+                          pConf);
+    }
+}
+
+void mipi_dsi_link_off(Lcd_Config_t *pConf)
+{
+    struct aml_lcd_extern_driver_t *lcd_extern_driver;
+
+    if (pConf->lcd_control.mipi_config->dsi_init_off) {
+        dsi_write_cmd(pConf->lcd_control.mipi_config->dsi_init_off);
+        DBG_PRINT("dsi init off\n");
+    }
+
+    if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
+        lcd_extern_driver = aml_lcd_extern_get_driver();
+        if (lcd_extern_driver == NULL) {
+            DPRINT("no lcd_extern driver\n");
+        }
+        else {
+            if (lcd_extern_driver->init_off_cmd_8) {
+                dsi_write_cmd(lcd_extern_driver->init_off_cmd_8);
+                DPRINT("[extern]%s dsi init off\n", lcd_extern_driver->name);
+            }
+        }
+    }
+}
+
+void set_mipi_dsi_control_config(Lcd_Config_t *pConf)
+{
+    unsigned int bit_rate;
+    DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
+
+    if (cfg->bit_rate_max == 0) {
+        bit_rate = ((pConf->lcd_timing.lcd_clk / 1000) * 3 * 8) / cfg->lane_num;
+        cfg->bit_rate_min = bit_rate - 20*1000;
+        cfg->bit_rate_max = bit_rate - 20*1000 + (pConf->lcd_timing.lcd_clk / 1000);
+        DPRINT("mipi dsi bit_rate min=%dMHz, max=%dMHz\n", (cfg->bit_rate_min / 1000), (cfg->bit_rate_max / 1000));
+    }
+    if (cfg->bit_rate_max < (PLL_VCO_MIN / od_table[OD_SEL_MAX-1])) {
+        DPRINT("[error]: mipi-dsi can't support %dMHz bit_rate (min bit_rate=%dMHz)\n", (cfg->bit_rate_max / 1000), ((PLL_VCO_MIN / od_table[OD_SEL_MAX-1]) / 1000));
+    }
+    if (cfg->bit_rate_max > MIPI_PHY_MAX_CLK_IN) {
+        DPRINT("[warning]: mipi-dsi bit_rate_max %dMHz is out of spec (%dMHz)\n", (cfg->bit_rate_max / 1000), (MIPI_PHY_MAX_CLK_IN / 1000));
+    }
+
+    cfg->video_mode_type = MIPI_DSI_VIDEO_MODE_TYPE;
+    if(pConf->lcd_basic.lcd_bits == 6){
+        cfg->dpi_data_format = COLOR_18BIT_CFG_2;
+        cfg->venc_data_width = MIPI_DSI_VENC_COLOR_18B;
+    }else{
+        cfg->dpi_data_format  = COLOR_24BIT;
+        cfg->venc_data_width = MIPI_DSI_VENC_COLOR_24B;
+    }
+
+    switch ((cfg->transfer_ctrl >> BIT_TRANS_CTRL_SWITCH) & 3) {
+        case 1: //standard
+            cfg->venc_fmt=TV_ENC_LCD768x1024p;
+            break;
+        case 2: //slow
+            cfg->venc_fmt=TV_ENC_LCD1280x720;
+            break;
+        case 0: //auto
+        default:
+            if((pConf->lcd_basic.h_active !=240)&&(pConf->lcd_basic.h_active !=768)&&(pConf->lcd_basic.h_active !=1920)&&(pConf->lcd_basic.h_active !=2560))
+                cfg->venc_fmt=TV_ENC_LCD1280x720;
+            else
+                cfg->venc_fmt=TV_ENC_LCD768x1024p;
+            break;
+    }
+}
+
+void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf)
+{
+    unsigned pclk, lanebyteclk;
+    DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
+
+    pclk = pConf->lcd_timing.lcd_clk;
+
+    if (cfg->factor_numerator == 0) {
+        lanebyteclk = cfg->bit_rate / 8;
+        DBG_PRINT("pixel_clk = %d.%03dMHz, bit_rate = %d.%03dMHz, lanebyteclk = %d.%03dMHz\n", (pclk / 1000000), ((pclk / 1000) % 1000), 
+                 (cfg->bit_rate / 1000000), ((cfg->bit_rate / 1000) % 1000), (lanebyteclk / 1000000), ((lanebyteclk / 1000) % 1000));
+
+        cfg->factor_denominator = lanebyteclk/1000;
+        cfg->factor_numerator = pclk/1000;
+        //cfg->factor_denominator = 10;
+    }
+    DBG_PRINT("d=%d, n=%d, factor=%d.%02d\n", cfg->factor_denominator, cfg->factor_numerator, (cfg->factor_denominator/cfg->factor_numerator), 
+             ((cfg->factor_denominator % cfg->factor_numerator) * 100 / cfg->factor_numerator));
+
+    set_dsi_phy_config(&dsi_phy_config, cfg->bit_rate);
+}
+
+void set_mipi_dsi_control(Lcd_Config_t *pConf)
+{
+    mipi_dsi_host_config(pConf);
+
+    mipi_dsi_phy_config(pConf);
+
+    if(((pConf->lcd_control.mipi_config->transfer_ctrl >> BIT_TRANS_CTRL_CLK) & 1) == 0)
+        startup_transfer_video();
+    else
+        startup_transfer_cmd();
+
+    mipi_dsi_link_on(pConf);
+}
+
+void mipi_dsi_off(void)
+{
+    DBG_PRINT("poweroff dsi digital\n");
+    // Power down DSI
+    WRITE_LCD_REG(MIPI_DSI_DWC_PWR_UP_OS, 0);
+
+    // Power down D-PHY, do not have to close dphy
+    // WRITE_LCD_REG(MIPI_DSI_DWC_PHY_RSTZ_OS, (READ_LCD_REG( MIPI_DSI_DWC_PHY_RSTZ_OS ) & 0xc));
+    // WRITE_LCD_REG(MIPI_DSI_DWC_PHY_RSTZ_OS, 0xc);
+
+    WRITE_DSI_REG(MIPI_DSI_CHAN_CTRL, 0x1f);
+    DBG_PRINT("MIPI_DSI_PHY_CTRL=0x%x\n", READ_DSI_REG(MIPI_DSI_PHY_CTRL)); //read
+    WRITE_DSI_REG_BITS(MIPI_DSI_PHY_CTRL, 0, 7, 1);
+}
+
+//***********************************************//
+static const char * dsi_usage_str =
+{"Usage:\n"
+"    echo read <addr> <reg_count> > debug ; read dsi phy reg value\n"
+"    echo write <addr> <value> > debug ; write dsi phy reg with value\n"
+"    echo info > debug ; print dsi config information\n"
+"    echo dphy > debug ; print dsi phy timing information\n"
+};
+
+static ssize_t dsi_debug_help(struct class *class, struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", dsi_usage_str);
+}
+
+static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+    unsigned int ret;
+    unsigned t[3];
+    unsigned num = 0;
+    int i;
+
+    switch (buf[0]) {
+        case 'r': //read
+            num = 1;
+            t[0] = 0;
+            ret = sscanf(buf, "read %x %u", &t[0], &num);
+            DPRINT("read dsi phy reg:\n");
+            for (i=0; i<num; i++) {
+                DPRINT("  0x%04x = 0x%08x\n", (t[0]+i), READ_DSI_REG((t[0]+i)));
+            }
+            break;
+        case 'w': //write
+            t[0] = 0;
+            t[1] = 0;
+            ret = sscanf(buf, "write %x %x", &t[0], &t[1]);
+            WRITE_DSI_REG(t[0], t[1]);
+            DPRINT("write dsi phy reg 0x%04x = 0x%08x, readback 0x%08x\n", t[0], t[1], READ_DSI_REG(t[0]));
+            break;
+        case 'i':
+            print_info();
+            break;
+        case 'd':
+            print_dphy_info();
+            break;
+        default:
+            DPRINT("wrong format of dsi debug command.\n");
+            break;
+    }
+
+    if (ret != 1 || ret !=2)
+        return -EINVAL;
+    
+    return count;
+    //return 0;
+}
+
+static struct class_attribute dsi_debug_class_attrs[] = {
+    __ATTR(debug, S_IRUGO | S_IWUSR, dsi_debug_help, dsi_debug),
+    __ATTR(help, S_IRUGO | S_IWUSR, dsi_debug_help, NULL),
+};
+
+static int creat_dsi_attr(void)
+{
+	int i;
+
+	dsi_debug_class = class_create(THIS_MODULE, "dsi");
+	if(IS_ERR(dsi_debug_class)) {
+		printk("create dsi debug class fail\n");
+		return -1;
+	}
+	//create class attr
+	for(i=0;i<ARRAY_SIZE(dsi_debug_class_attrs);i++) {
+		if (class_create_file(dsi_debug_class, &dsi_debug_class_attrs[i])) {
+			printk("create dsi debug attribute %s fail\n",dsi_debug_class_attrs[i].attr.name);
+		}
+	}
+
+	return 0;
+}
+static int remove_dsi_attr(void)
+{
+    int i;
+
+    if (dsi_debug_class == NULL)
+        return -1;
+
+    for(i=0;i<ARRAY_SIZE(dsi_debug_class_attrs);i++) {
+        class_remove_file(dsi_debug_class, &dsi_debug_class_attrs[i]);
+    }
+    class_destroy(dsi_debug_class);
+
+    return 0;
+}
+//*********************************************************//
+
+void dsi_probe(Lcd_Config_t *pConf)
+{
+    dsi_config = pConf->lcd_control.mipi_config;
+    pConf->lcd_control.mipi_config->bit_rate_min *= 1000;
+    pConf->lcd_control.mipi_config->bit_rate_max *= 1000;
+
+    creat_dsi_attr();
+}
+
+void dsi_remove(void)
+{
+    remove_dsi_attr();
+}
+
diff --git a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h
new file mode 100755
index 000000000000..972abcfb88e5
--- /dev/null
+++ b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h
@@ -0,0 +1,430 @@
+#ifndef MIPI_DSI_UTIL_H
+#define MIPI_DSI_UTIL_H
+
+#include <mach/register.h>
+#include <linux/amlogic/vout/lcdoutc.h>
+
+// --------------------------------------------------------
+// MIPI DSI Data Type/ MIPI DCS Command Type Definitions
+// --------------------------------------------------------
+typedef enum {DT_VSS                 = 0x01,
+        DT_VSE                 = 0x11,
+        DT_HSS                 = 0x21,
+        DT_HSE                 = 0x31,
+        DT_EOTP                = 0x08,
+        DT_CMOFF               = 0x02,
+        DT_CMON                = 0x12,
+        DT_SHUT_DOWN           = 0x22,
+        DT_TURN_ON             = 0x32,
+        DT_GEN_SHORT_WR_0      = 0x03,
+        DT_GEN_SHORT_WR_1      = 0x13,
+        DT_GEN_SHORT_WR_2      = 0x23,
+        DT_GEN_RD_0            = 0x04,
+        DT_GEN_RD_1            = 0x14,
+        DT_GEN_RD_2            = 0x24,
+        DT_DCS_SHORT_WR_0      = 0x05,
+        DT_DCS_SHORT_WR_1      = 0x15,
+        DT_DCS_RD_0            = 0x06,
+        DT_SET_MAX_RPS         = 0x37,
+        DT_NULL_PKT            = 0x09,
+        DT_BLANK_PKT           = 0x19,
+        DT_GEN_LONG_WR         = 0x29,
+        DT_DCS_LONG_WR         = 0x39,
+        DT_20BIT_LOOSE_YCBCR   = 0x0c,
+        DT_24BIT_YCBCR         = 0x1c,
+        DT_16BIT_YCBCR         = 0x2c,
+        DT_30BIT_RGB_101010    = 0x0d,
+        DT_36BIT_RGB_121212    = 0x1d,
+        DT_12BIT_YCBCR         = 0x3d,
+        DT_16BIT_RGB_565       = 0x0e,
+        DT_18BIT_RGB_666       = 0x1e,
+        DT_18BIT_LOOSE_RGB_666 = 0x2e,
+        DT_24BIT_RGB_888       = 0x3e
+} mipi_dsi_data_type_t;
+
+// DCS Command List
+#define DCS_ENTER_IDLE_MODE          0x39
+#define DCS_ENTER_INVERT_MODE        0x21
+#define DCS_ENTER_NORMAL_MODE        0x13
+#define DCS_ENTER_PARTIAL_MODE       0x12
+#define DCS_ENTER_SLEEP_MODE         0x10
+#define DCS_EXIT_IDLE_MODE           0x38
+#define DCS_EXIT_INVERT_MODE         0x20
+#define DCS_EXIT_SLEEP_MODE          0x11
+#define DCS_GET_3D_CONTROL           0x3f
+#define DCS_GET_ADDRESS_MODE         0x0b
+#define DCS_GET_BLUE_CHANNEL         0x08
+#define DCS_GET_DIAGNOSTIC_RESULT    0x0f
+#define DCS_GET_DISPLAY_MODE         0x0d
+#define DCS_GET_GREEN_CHANNEL        0x07
+#define DCS_GET_PIXEL_FORMAT         0x0c
+#define DCS_GET_POWER_MODE           0x0a
+#define DCS_GET_RED_CHANNEL          0x06
+#define DCS_GET_SCANLINE             0x45
+#define DCS_GET_SIGNAL_MODE          0x0e
+#define DCS_NOP                      0x00
+#define DCS_READ_DDB_CONTINUE        0xa8
+#define DCS_READ_DDB_START           0xa1
+#define DCS_READ_MEMORY_CONTINUE     0x3e
+#define DCS_READ_MEMORY_START        0x2e
+#define DCS_SET_3D_CONTROL           0x3d
+#define DCS_SET_ADDRESS_MODE         0x36
+#define DCS_SET_COLUMN_ADDRESS       0x2a
+#define DCS_SET_DISPLAY_OFF          0x28
+#define DCS_SET_DISPLAY_ON           0x29
+#define DCS_SET_GAMMA_CURVE          0x26
+#define DCS_SET_PAGE_ADDRESS         0x2b
+#define DCS_SET_PARTIAL_COLUMNS      0x31
+#define DCS_SET_PARTIAL_ROWS         0x30
+#define DCS_SET_PIXEL_FORMAT         0x3a
+#define DCS_SET_SCROLL_AREA          0x33
+#define DCS_SET_SCROLL_START         0x37
+#define DCS_SET_TEAR_OFF             0x34
+#define DCS_SET_TEAR_ON              0x35
+#define DCS_SET_TEAR_SCANLINE        0x44
+#define DCS_SET_VSYNC_TIMING         0x40
+#define DCS_SOFT_RESET               0x01
+#define DCS_WRITE_LUT                0x2d
+#define DCS_WRITE_MEMORY_CONTINUE    0x3c
+#define DCS_WRITE_MEMORY_START       0x2c
+
+// --------------------------------------------------------
+// MIPI DCS Pixel-to-Byte Format
+// --------------------------------------------------------
+// DCS pixel-to-byte format
+#define DCS_PF_RSVD                  0x0
+#define DCS_PF_3BIT                  0x1
+#define DCS_PF_8BIT                  0x2
+#define DCS_PF_12BIT                 0x3
+#define DCS_PF_16BIT                 0x5
+#define DCS_PF_18BIT                 0x6
+#define DCS_PF_24BIT                 0x7
+
+// --------------------------------------------------------
+// MIPI DSI/VENC Color Format Definitions
+// --------------------------------------------------------
+#define MIPI_DSI_VENC_COLOR_30B 0x0
+#define MIPI_DSI_VENC_COLOR_24B 0x1
+#define MIPI_DSI_VENC_COLOR_18B 0x2
+#define MIPI_DSI_VENC_COLOR_16B 0x3
+
+#define COLOR_16BIT_CFG_1  0x0
+#define COLOR_16BIT_CFG_2  0x1
+#define COLOR_16BIT_CFG_3  0x2
+#define COLOR_18BIT_CFG_1  0x3
+#define COLOR_18BIT_CFG_2  0x4
+#define COLOR_24BIT        0x5
+#define COLOR_20BIT_LOOSE  0x6
+#define COLOR_24_BIT_YCBCR 0x7
+#define COLOR_16BIT_YCBCR  0x8
+#define COLOR_30BIT        0x9
+#define COLOR_36BIT        0xa
+#define COLOR_12BIT        0xb
+#define COLOR_RGB_111      0xc
+#define COLOR_RGB_332      0xd
+#define COLOR_RGB_444      0xe
+
+// --------------------------------------------------------
+// MIPI DSI Relative REGISTERs Definitions
+// --------------------------------------------------------
+// For MIPI_DSI_TOP_CNTL
+#define BIT_DPI_COLOR_MODE    20
+#define BIT_IN_COLOR_MODE     16
+#define BIT_CHROMA_SUBSAMPLE  14
+#define BIT_COMP2_SEL         12
+#define BIT_COMP1_SEL         10
+#define BIT_COMP0_SEL          8
+#define BIT_DE_POL             6
+#define BIT_HSYNC_POL          5
+#define BIT_VSYNC_POL          4
+#define BIT_DPICOLORM          3
+#define BIT_DPISHUTDN          2
+#define BIT_EDPITE_INTR_PULSE  1
+#define BIT_ERR_INTR_PULSE     0
+
+// For MIPI_DSI_DWC_CLKMGR_CFG_OS 
+#define BIT_TO_CLK_DIV     8
+#define BIT_TX_ESC_CLK_DIV 0
+
+// For MIPI_DSI_DWC_PCKHDL_CFG_OS
+#define BIT_CRC_RX_EN      4
+#define BIT_ECC_RX_EN      3
+#define BIT_BTA_EN         2
+#define BIT_EOTP_RX_EN     1
+#define BIT_EOTP_TX_EN     0
+
+// For MIPI_DSI_DWC_VID_MODE_CFG_OS
+#define BIT_LP_CMD_EN        15
+#define BIT_FRAME_BTA_ACK_EN 14
+#define BIT_LP_HFP_EN        13
+#define BIT_LP_HBP_EN        12
+#define BIT_LP_VCAT_EN       11
+#define BIT_LP_VFP_EN        10
+#define BIT_LP_VBP_EN         9
+#define BIT_LP_VSA_EN         8
+#define BIT_VID_MODE_TYPE     0
+
+#define NON_BURST_SYNC_PULSE  0x0
+#define NON_BURST_SYNC_EVENT  0x1
+#define BURST_MODE            0x2
+
+// For MIPI_DSI_DWC_PHY_STATUS_OS
+#define BIT_PHY_ULPSACTIVENOT3LANE 12
+#define BIT_PHY_STOPSTATE3LANE     11
+#define BIT_PHY_ULPSACTIVENOT2LANE 10
+#define BIT_PHY_STOPSTATE2LANE      9
+#define BIT_PHY_ULPSACTIVENOT1LANE  8
+#define BIT_PHY_STOPSTATE1LANE      7
+#define BIT_PHY_RXULPSESC0LANE      6
+#define BIT_PHY_ULPSACTIVENOT0LANE  5
+#define BIT_PHY_STOPSTATE0LANE      4
+#define BIT_PHY_ULPSACTIVENOTCLK    3
+#define BIT_PHY_STOPSTATECLKLANE    2
+#define BIT_PHY_DIRECTION           1
+#define BIT_PHY_LOCK                0
+
+// For MIPI_DSI_DWC_PHY_IF_CFG_OS
+#define BIT_PHY_STOP_WAIT_TIME      8
+#define BIT_N_LANES                 0
+
+// For MIPI_DSI_DWC_DPI_COLOR_CODING_OS
+#define BIT_LOOSELY18_EN            8
+#define BIT_DPI_COLOR_CODING        0
+
+// For MIPI_DSI_DWC_GEN_HDR_OS
+#define BIT_GEN_WC_MSBYTE          16
+#define BIT_GEN_WC_LSBYTE           8
+#define BIT_GEN_VC                  6
+#define BIT_GEN_DT                  0
+
+// For MIPI_DSI_DWC_LPCLK_CTRL_OS
+#define BIT_AUTOCLKLANE_CTRL        1
+#define BIT_TXREQUESTCLKHS          0
+
+// For MIPI_DSI_DWC_DPI_CFG_POL_OS
+#define BIT_COLORM_ACTIVE_LOW       4
+#define BIT_SHUTD_ACTIVE_LOW        3
+#define BIT_HSYNC_ACTIVE_LOW        2
+#define BIT_VSYNC_ACTIVE_LOW        1
+#define BIT_DATAEN_ACTIVE_LOW       0
+
+// For MIPI_DSI_DWC_CMD_MODE_CFG_OS
+#define BIT_MAX_RD_PKT_SIZE        24
+#define BIT_DCS_LW_TX              19 
+#define BIT_DCS_SR_0P_TX           18
+#define BIT_DCS_SW_1P_TX           17
+#define BIT_DCS_SW_0P_TX           16
+#define BIT_GEN_LW_TX              14
+#define BIT_GEN_SR_2P_TX           13
+#define BIT_GEN_SR_1P_TX           12
+#define BIT_GEN_SR_0P_TX           11
+#define BIT_GEN_SW_2P_TX           10
+#define BIT_GEN_SW_1P_TX            9
+#define BIT_GEN_SW_0P_TX            8
+#define BIT_ACK_RQST_EN             1
+#define BIT_TEAR_FX_EN              0
+
+// For MIPI_DSI_DWC_CMD_PKT_STATUS_OS
+#define BIT_DBI_RD_CMD_BUSY        14    // For DBI no usefull 
+#define BIT_DBI_PLD_R_FULL         13    // For DBI no usefull 
+#define BIT_DBI_PLD_R_EMPTY        12    // For DBI no usefull 
+#define BIT_DBI_PLD_W_FULL         11    // For DBI no usefull 
+#define BIT_DBI_PLD_W_EMPTY        10    // For DBI no usefull 
+#define BIT_DBI_CMD_FULL            9    // For DBI no usefull 
+#define BIT_DBI_CMD_EMPTY           8    // For DBI no usefull 
+
+#define BIT_GEN_RD_CMD_BUSY         6    // For Generic interface 
+#define BIT_GEN_PLD_R_FULL          5    // For Generic interface               
+#define BIT_GEN_PLD_R_EMPTY         4    // For Generic interface    
+#define BIT_GEN_PLD_W_FULL          3    // For Generic interface 
+#define BIT_GEN_PLD_W_EMPTY         2    // For Generic interface 
+#define BIT_GEN_CMD_FULL            1    // For Generic interface 
+#define BIT_GEN_CMD_EMPTY           0    // For Generic interface 
+
+// For MIPI_DSI_TOP_MEAS_CNTL
+#define BIT_CNTL_MEAS_VSYNC        10    // measure vsync control
+#define BIT_EDPITE_MEAS_EN          9    // tear measure enable
+#define BIT_EDPITE_ACCUM_MEAS_EN    8    // not clear the counter
+#define BIT_EDPITE_VSYNC_SPAN       0    // 
+
+// For MIPI_DSI_TOP_STAT
+#define BIT_STAT_EDPIHALT          31    // signal from halt
+#define BIT_STAT_TE_LINE           16    // line number when edpite pulse
+#define BIT_STAT_TE_PIXEL           0    // pixel number when edpite pulse
+
+// For MIPI_DSI_TOP_INTR_CNTL_STAT
+#define BIT_STAT_CLR_DWC_PIC_EOF   21    // State/Clear for pic_eof
+#define BIT_STAT_CLR_DWC_DE_FALL   20    // State/Clear for de_fall
+#define BIT_STAT_CLR_DWC_DE_RISE   19    // State/Clear for de_rise
+#define BIT_STAT_CLR_DWC_VS_FALL   18    // State/Clear for vs_fall
+#define BIT_STAT_CLR_DWC_VS_RISE   17    // State/Clear for vs_rise
+#define BIT_STAT_CLR_DWC_EDPITE    16    // State/Clear for edpite
+#define BIT_PIC_EOF                 5    // end of picture
+#define BIT_DE_FALL                 4    // data enable fall
+#define BIT_DE_RISE                 3    // data enable rise
+#define BIT_VS_FALL                 2    // vsync fall
+#define BIT_VS_RISE                 1    // vsync rise
+#define BIT_EDPITE_INT_EN           0    // edpite int enable
+
+// For MIPI_DSI_TOP_MEAS_CNTL
+#define BIT_VSYNC_MEAS_EN          19    // vsync measure enable
+#define BIT_VSYNC_ACCUM_MEAS_EN    18    // vsync accumulate measure
+#define BIT_VSYNC_SPAN             10    // vsync span
+#define BIT_TE_MEAS_EN              9    // tearing measure enable
+#define BIT_TE_ACCUM_MEAS_EN        8    // tearing accumulate measure
+#define BIT_TE_SPAN                 0    // tearing span
+
+// For MIPI_DSI_DWC_INT_ST0_OS
+#define BIT_DPHY_ERR_4             20    // LP1 contention error from lane0
+#define BIT_DPHY_ERR_3             19    // LP0 contention error from lane0
+#define BIT_DPHY_ERR_2             18    // ErrControl error from lane0
+#define BIT_DPHY_ERR_1             17    // ErrSyncEsc error from lane0
+#define BIT_DPHY_ERR_0             16    // ErrEsc escape error lane0
+#define BIT_ACK_ERR_15             15
+#define BIT_ACK_ERR_14             14
+#define BIT_ACK_ERR_13             13
+#define BIT_ACK_ERR_12             12
+#define BIT_ACK_ERR_11             11
+#define BIT_ACK_ERR_10             10
+#define BIT_ACK_ERR_9               9
+#define BIT_ACK_ERR_8               8
+#define BIT_ACK_ERR_7               7
+#define BIT_ACK_ERR_6               6
+#define BIT_ACK_ERR_5               5
+#define BIT_ACK_ERR_4               4
+#define BIT_ACK_ERR_3               3
+#define BIT_ACK_ERR_2               2
+#define BIT_ACK_ERR_1               1
+#define BIT_ACK_ERR_0               0
+
+// Operation mode parameters
+#define OPERATION_VIDEO_MODE        0
+#define OPERATION_COMMAND_MODE      1
+
+// Command transfer type in command mode
+#define DCS_TRANS_HS                0
+#define DCS_TRANS_LP                1
+
+#define MIPI_DSI_DCS_NO_ACK         0
+#define MIPI_DSI_DCS_REQ_ACK        1
+
+// DSI Tear Defines
+#define MIPI_DCS_SET_TEAR_ON_MODE_0   0
+#define MIPI_DCS_SET_TEAR_ON_MODE_1   1
+#define MIPI_DCS_ENABLE_TEAR          1
+#define MIPI_DCS_DISABLE_TEAR         0
+
+// Pixel FIFO Depth
+#define PIXEL_FIFO_DEPTH              1440
+
+#define BYTE_PER_PIXEL_COLOR_16BIT_CFG_1  2
+#define BYTE_PER_PIXEL_COLOR_16BIT_CFG_2  2
+#define BYTE_PER_PIXEL_COLOR_16BIT_CFG_3  2
+#define BYTE_PER_PIXEL_COLOR_18BIT_CFG_1  3
+#define BYTE_PER_PIXEL_COLOR_18BIT_CFG_2  3
+#define BYTE_PER_PIXEL_COLOR_24BIT        3
+#define BYTE_PER_PIXEL_COLOR_20BIT_LOOSE  3
+#define BYTE_PER_PIXEL_COLOR_24_BIT_YCBCR 3
+#define BYTE_PER_PIXEL_COLOR_16BIT_YCBCR  2
+#define BYTE_PER_PIXEL_COLOR_30BIT        4
+#define BYTE_PER_PIXEL_COLOR_36BIT        5
+#define BYTE_PER_PIXEL_COLOR_12BIT        3    // in fact it should be 1.5(12bit)
+
+// Tearing Interrupt Bit
+#define INT_TEARING                       6
+
+typedef enum tv_enc_lcd_type_e{
+        TV_ENC_LCD480x234 = 0,
+        TV_ENC_LCD480x234_dsi36b = 1,       // For MIPI_DSI 36-bit color: sample rate=2, 1 pixel per 2 cycle
+        TV_ENC_LCD240x160 = 2,
+        TV_ENC_LCD240x160_dsi36b = 3,       // For MIPI_DSI 36-bit color: sample rate=2, 1 pixel per 2 cycle
+        TV_ENC_LCD720x480 = 4,
+        TV_ENC_LCD720x480_dsi36b = 5,       // For MIPI_DSI 36-bit color: sample rate=2, 1 pixel per 2 cycle
+        TV_ENC_LCD720x576 = 6,
+        TV_ENC_LCD720x576_dsi36b = 7,       // For MIPI_DSI 36-bit color: sample rate=2, 1 pixel per 2 cycle
+        TV_ENC_LCD1280x720 = 8,
+        TV_ENC_LCD1280x720_dsi36b = 9,      // For MIPI_DSI 36-bit color: sample rate=2, 1 pixel per 2 cycle
+        TV_ENC_LCD1920x1080 = 10,
+        TV_ENC_LCD1920x1080_dsi36b = 11,    // For MIPI_DSI 36-bit color: sample rate=2, 1 pixel per 2 cycle
+        TV_ENC_LCD1920x2205 = 12,
+        TV_ENC_LCD1920x2205_dsi36b = 13,    // For MIPI_DSI 36-bit color: sample rate=2, 1 pixel per 2 cycle
+        TV_ENC_LCD2560x1600 = 14,
+        TV_ENC_LCD2560x1600_dsi36b = 15,    // For MIPI_DSI 36-bit color: sample rate=2, 1 pixel per 2 cycle
+        TV_ENC_LCD3840x2440 = 16,
+        TV_ENC_LCD3840x2440_dsi36b = 17,    // For MIPI_DSI 36-bit color: sample rate=2, 1 pixel per 2 cycle
+        TV_ENC_LCD3840x2160p_vic03 = 18,
+        TV_ENC_LCD4096x2160p_vic04 = 19,
+        TV_ENC_LCD640x480 = 20,
+        TV_ENC_LCD1920x1200p = 21, 
+        TV_ENC_LCD240x160_dsi   = 22,
+        TV_ENC_LCD240x160_slow   = 23,
+        TV_ENC_LCD3840x2160p_vic01 = 24,
+        TV_ENC_LCD2048x1536  = 25,
+        TV_ENC_LCD768x1024p = 26,
+        TV_ENC_LCD_TYPE_MAX
+} tv_enc_lcd_type_t;   /* tv encoder output format */
+
+// DCS COMMAND LIST
+#define DCS_CMD_CODE_ENTER_IDLE_MODE      0x0
+#define DCS_CMD_CODE_ENTER_INVERT_MODE    0x1
+#define DCS_CMD_CODE_ENTER_NORMAL_MODE    0x2
+#define DCS_CMD_CODE_ENTER_PARTIAL_MODE   0x3
+#define DCS_CMD_CODE_ENTER_SLEEP_MODE     0x4
+#define DCS_CMD_CODE_EXIT_IDLE_MODE       0x5
+#define DCS_CMD_CODE_EXIT_INVERT_MODE     0x6
+#define DCS_CMD_CODE_EXIT_SLEEP_MODE      0x7
+#define DCS_CMD_CODE_NOP                  0x8
+#define DCS_CMD_CODE_SET_DISPLAY_OFF      0x9
+#define DCS_CMD_CODE_SET_DISPLAY_ON       0xa
+#define DCS_CMD_CODE_SET_TEAR_OFF         0xb
+#define DCS_CMD_CODE_SOFT_RESET           0xc
+
+//********************************************************************************
+//      DPHY timing parameter       Value (unit: 0.01ns)
+#define DPHY_TIME_LP_TESC(ui)       (250 * 100) //>100ns //4M
+#define DPHY_TIME_LP_LPX(ui)        (100 * 100) //>50ns
+#define DPHY_TIME_LP_TA_SURE(ui)    DPHY_TIME_LP_LPX(ui) //(lpx, 2*lpx)
+#define DPHY_TIME_LP_TA_GO(ui)      (4 * DPHY_TIME_LP_LPX(ui)) //4*lpx
+#define DPHY_TIME_LP_TA_GETX(ui)    (5 * DPHY_TIME_LP_LPX(ui)) //5*lpx
+#define DPHY_TIME_HS_EXIT(ui)       (120 * 100) //>100ns
+#define DPHY_TIME_HS_TRAIL(ui)      ((ui > (60 * 100 / 4)) ? (8 * ui) : ((60 * 100) + 4 * ui)) //max(8*ui, 60+4*ui) //(teot)<105+12*ui
+#define DPHY_TIME_HS_PREPARE(ui)    (50 * 100 + 4 * t_ui) //(40+4*ui, 85+6*ui)
+#define DPHY_TIME_HS_ZERO(ui)       (160 * 100 + 10 * ui - DPHY_TIME_HS_PREPARE(ui)) //hs_prepare+hs_zero >145+10*ui
+#define DPHY_TIME_CLK_TRAIL(ui)     (70 * 100) //>60ns //(teot)<105+12*ui
+#define DPHY_TIME_CLK_POST(ui)      (70 * 100 + 52 * ui) //>60+52*ui
+#define DPHY_TIME_CLK_PREPARE(ui)   (50 * 100) //(38, 95)
+#define DPHY_TIME_CLK_ZERO(ui)      (320 * 100 - DPHY_TIME_CLK_PREPARE(ui)) //clk_prepare+clk_zero > 300
+#define DPHY_TIME_CLK_PRE(ui)       (10 * ui) //>8*ui
+#define DPHY_TIME_INIT(ui)          (110 * 1000 * 100) //>100us
+#define DPHY_TIME_WAKEUP(ui)        (1020 * 1000 * 100) //>1ms
+typedef struct DSI_Phy_s{
+    unsigned int lp_tesc;
+    unsigned int lp_lpx;
+    unsigned int lp_ta_sure;
+    unsigned int lp_ta_go;
+    unsigned int lp_ta_get;
+    unsigned int hs_exit;
+    unsigned int hs_trail;
+    unsigned int hs_zero;
+    unsigned int hs_prepare;
+    unsigned int clk_trail;
+    unsigned int clk_post;
+    unsigned int clk_zero;
+    unsigned int clk_prepare;
+    unsigned int clk_pre;
+    unsigned int init;
+    unsigned int wakeup;
+}DSI_Phy_t;
+//********************************************************************************
+
+#define DSI_CMD_SIZE_MAX		2000
+
+extern void set_mipi_dsi_control_config(Lcd_Config_t *pConf);
+extern void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf);
+extern void mipi_dsi_link_off(Lcd_Config_t *pConf);
+extern void set_mipi_dsi_control(Lcd_Config_t *pConf);
+extern void mipi_dsi_off(void);
+extern void dsi_probe(Lcd_Config_t *pConf);
+extern void dsi_remove(void);
+
+#endif
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/Makefile b/drivers/amlogic/display/backlight/aml_bl_extern/Makefile
index d826c1ef08a1..9d057e56bf61 100644
--- a/drivers/amlogic/display/backlight/aml_bl_extern/Makefile
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/Makefile
@@ -2,4 +2,5 @@
 obj-y	+= aml_bl_extern.o
 obj-y	+= i2c_lp8556.o
 obj-y	+= pmu_aml1218.o
+obj-y	+= mipi_LT070ME05.o
 
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/aml.dtd b/drivers/amlogic/display/backlight/aml_bl_extern/aml.dtd
index d0e0fb5238db..b1e0ce993512 100755
--- a/drivers/amlogic/display/backlight/aml_bl_extern/aml.dtd
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/aml.dtd
@@ -37,6 +37,21 @@
 		dim_max_min = <255 10>;
 	};
 
+//$$ DEVICE = "bl_extern_mipi_LT070ME05"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_STR 2 = "gpio_enable"
+//$$ L2 PROP_U32 = "type"
+//$$ L2 PROP_U32 2 = "dim_max_min"
+	bl_extern_mipi_LT070ME05{
+		compatible = "amlogic,bl_mipi_LT070ME05";
+		dev_name ="bl_mipi_LT070ME056";
+		status = "disabled"; /** "disabled" or "okay" */
+
+		gpio_enable = "GPIODV_28"; /** "n" for none */
+		type = <2>;	/** bl_extern_driver type: 0=i2c, 1=spi, 2=other */
+		dim_max_min = <255 10>;
+	};
+
 //******************************************************************************
 
 #endif
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c b/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c
new file mode 100755
index 000000000000..c1ddfbdd066a
--- /dev/null
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c
@@ -0,0 +1,188 @@
+/*
+ * AMLOGIC backlight external driver.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h> 
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <mach/lcdoutc.h>
+#include <linux/amlogic/aml_bl_extern.h>
+
+#ifdef CONFIG_LCD_IF_MIPI_VALID
+static struct bl_extern_config_t *bl_ext_config = NULL;
+
+//#define BL_EXT_DEBUG_INFO
+#ifdef BL_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+#define BL_EXTERN_NAME			"bl_mipi_LT070ME05"
+static unsigned int bl_status = 1;
+static unsigned int bl_level = 0;
+
+static int bl_extern_set_level(unsigned int level)
+{
+    unsigned char payload[]={0x15,0x51,1,0xe6,0xff,0xff};
+
+    bl_level = level;
+
+    if (bl_ext_config == NULL) {
+        printk("no %s driver\n", BL_EXTERN_NAME);
+        return -1;
+    }
+    get_bl_ext_level(bl_ext_config);
+    level = bl_ext_config->dim_min - ((level - bl_ext_config->level_min) * (bl_ext_config->dim_min - bl_ext_config->dim_max)) / (bl_ext_config->level_max - bl_ext_config->level_min);
+    level &= 0xff;
+
+    if (bl_status) {
+        payload[3] = level;
+        dsi_write_cmd(payload);
+    }
+
+    return 0;
+}
+
+static int bl_extern_power_on(void)
+{
+    if (bl_ext_config->gpio_used > 0) {
+        bl_extern_gpio_direction_output(bl_ext_config->gpio, 1);
+    }
+
+    bl_status = 1;
+    bl_extern_set_level(bl_level);//recover bl level
+
+    printk("%s\n", __FUNCTION__);
+    return 0;
+}
+
+static int bl_extern_power_off(void)
+{
+    if (bl_ext_config->gpio_used > 0) {
+        bl_extern_gpio_direction_output(bl_ext_config->gpio, 0);
+    }
+
+    printk("%s\n", __FUNCTION__);
+    return 0;
+}
+
+static int bl_extern_driver_update(void)
+{
+    struct aml_bl_extern_driver_t* bl_ext;
+
+    bl_ext = aml_bl_extern_get_driver();
+    if (bl_ext) {
+        bl_ext->type      = bl_ext_config->type;
+        bl_ext->name      = bl_ext_config->name;
+        bl_ext->power_on  = bl_extern_power_on;
+        bl_ext->power_off = bl_extern_power_off;
+        bl_ext->set_level = bl_extern_set_level;
+    }
+    else {
+        printk("[error] %s get bl_extern_driver failed\n", bl_ext_config->name);
+    }
+
+    return 0;
+}
+
+static int aml_LT070ME05_probe(struct platform_device *pdev)
+{
+    if (bl_extern_driver_check()) {
+        return -1;
+    }
+    if (bl_ext_config == NULL)
+        bl_ext_config = kzalloc(sizeof(*bl_ext_config), GFP_KERNEL);
+    if (bl_ext_config == NULL) {
+        printk("[error] %s probe: failed to alloc data\n", BL_EXTERN_NAME);
+        return -1;
+    }
+
+    pdev->dev.platform_data = bl_ext_config;
+
+    if (get_bl_extern_dt_data(pdev->dev.of_node, bl_ext_config) != 0) {
+        printk("[error] %s probe: failed to get dt data\n", BL_EXTERN_NAME);
+        goto bl_extern_probe_failed;
+    }
+
+    bl_extern_driver_update();
+
+    printk("%s ok\n", __FUNCTION__);
+    return 0;
+
+bl_extern_probe_failed:
+    if (bl_ext_config)
+        kfree(bl_ext_config);
+    return -1;
+}
+
+static int aml_LT070ME05_remove(struct platform_device *pdev)
+{
+    if (pdev->dev.platform_data)
+        kfree (pdev->dev.platform_data);
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_LT070ME05_dt_match[]={
+    {
+        .compatible = "amlogic,bl_mipi_LT070ME05",
+    },
+    {},
+};
+#else
+#define aml_LT070ME05_dt_match NULL
+#endif
+
+static struct platform_driver aml_LT070ME05_driver = {
+    .probe  = aml_LT070ME05_probe,
+    .remove = aml_LT070ME05_remove,
+    .driver = {
+        .name  = BL_EXTERN_NAME,
+        .owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+        .of_match_table = aml_LT070ME05_dt_match,
+#endif
+    },
+};
+
+static int __init aml_LT070ME05_init(void)
+{
+    int ret;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    ret = platform_driver_register(&aml_LT070ME05_driver);
+    if (ret) {
+        printk("[error] %s failed to register bl extern driver module\n", __FUNCTION__);
+        return -ENODEV;
+    }
+    return ret;
+}
+
+static void __exit aml_LT070ME05_exit(void)
+{
+    platform_driver_unregister(&aml_LT070ME05_driver);
+}
+
+rootfs_initcall(aml_LT070ME05_init);
+module_exit(aml_LT070ME05_exit);
+
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("BL Extern driver for LT070ME05");
+MODULE_LICENSE("GPL");
+
+#endif
diff --git a/drivers/amlogic/display/vout/Makefile b/drivers/amlogic/display/vout/Makefile
index ebf05e24ed31..d661f10c874b 100755
--- a/drivers/amlogic/display/vout/Makefile
+++ b/drivers/amlogic/display/vout/Makefile
@@ -7,8 +7,6 @@ obj-$(CONFIG_AM_TV_OUTPUT)  += am_tvout.o
 am_tvout-objs :=   tvoutc.o  tvconf.o enc_clk_config.o
 
 obj-$(CONFIG_AM_LCD_OUTPUT)  += lcdoutc.o
-obj-$(CONFIG_AM_LCD_OUTPUT)  += edp_drv.o
-obj-$(CONFIG_AM_LCD_OUTPUT)  += mipi_dsi_util.o
 obj-$(CONFIG_AM_LCD_OUTPUT)  += lcd_extern/
 
 #EXTRA_CFLAGS += -DCONFIG_PM
diff --git a/drivers/amlogic/display/vout/aml_lcd.dtd b/drivers/amlogic/display/vout/aml_lcd.dtd
index 1a2025020414..13ea0bb42f18 100755
--- a/drivers/amlogic/display/vout/aml_lcd.dtd
+++ b/drivers/amlogic/display/vout/aml_lcd.dtd
@@ -26,6 +26,7 @@
 //$$ L4 PROP_U32 2 = "lvds_user_repack"
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
+//$$ L4 PROP_U32 = "edp_sync_clock_mode"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -112,6 +113,7 @@
         lvds_user_repack=<0 0>;	/** lvds_repack_user(0=auto setting, 1=user define), lvds_repack(0=JEIDA mode data mapping, 1=VESA mode data mapping. only valid when lvds_repack_user=1) */
         edp_user_link_rate_lane_count=<1 1 2>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
         edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
+        edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
         rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
         //lcd power ctrl	//support up to 15 steps for each sequence
@@ -534,6 +536,7 @@
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "max_lane_count"
     lcd_LP097QX1:lcd_LP097QX1{	//k100
         model_name="LP097QX1";	/** lcd model name */
         interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -547,6 +550,66 @@
         hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
         vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
         pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        max_lane_count=<4>; /** max lane count supported */
+    };
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_LM270WQ1_SDA2>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "max_lane_count"
+    lcd_LM270WQ1_SDA2:lcd_LM270WQ1_SDA2{
+        model_name="LM270WQ1_SDA2"; /** lcd model name */
+        interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
+        active_area=<597 336>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+        lcd_bits_option=<8 0>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+        resolution=<2560 1440>;	/** horizontal resolution, vertical resolution */
+        period=<2720 1481>;		/** horizontal period(htotal), vertical period(vtotal) */
+
+        clock_hz_pol=<245500000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+        hsync_width_backporch=<32 112>;	/** hsync_width, hsync_backporch(include hsync_width) */
+        vsync_width_backporch=<5 38>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        max_lane_count=<4>; /** max lane count supported */
+    };
+
+//$$ MATCH "lcd_model_config_match" = <&lcd_B140XTN02>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "max_lane_count"
+    lcd_B140XTN02:lcd_B140XTN02{
+        model_name="B140XTN02"; /** lcd model name */
+        interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
+        active_area=<309 173>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+        lcd_bits_option=<6 0>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+        resolution=<1366 768>;	/** horizontal resolution, vertical resolution */
+        period=<1598 798>;		/** horizontal period(htotal), vertical period(vtotal) */
+
+        clock_hz_pol=<76300000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+        hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
+        vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        max_lane_count=<1>; /** max lane count supported */
     };
 
 //******************************************************************************
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index 45b17b7fe9d8..e2b8ff9ec952 100755
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -30,78 +30,36 @@
 #include <linux/string.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/vout_notify.h>
-#include <linux/amlogic/aml_bl.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
 #include <linux/amlogic/logo/logo.h>
 #include <plat/regops.h>
 #include <mach/am_regs.h>
-#include <linux/amlogic/vout/lcd_reg.h>
+#include <mach/lcd_reg.h>
+#include <mach/lcdoutc.h>
 #include <linux/amlogic/vout/lcdoutc.h>
 #include <linux/amlogic/vout/lcd_aml.h>
 #include <mach/clock.h>
-#include <mach/power_gate.h>
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-#include <mach/vpu.h>
-#endif
-#include <mach/mod_gate.h>
 #include <asm/fiq.h>
 #include <linux/delay.h>
 #include <linux/notifier.h>
 #include <linux/reboot.h>
 #include <linux/of.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/pinctrl/consumer.h>
 #include <linux/amlogic/aml_lcd_bl.h>
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-#include <mach/mlvds_regs.h>
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-#include "mipi_dsi_util.h"
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-#include "edp_drv.h"
-#endif
 #include <linux/amlogic/vout/aml_lcd_extern.h>
 #ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
 #include <linux/amlogic/aml_pmu_common.h>
 #endif
 
-#define VPP_OUT_SATURATE	(1 << 0)
-
 #define PANEL_NAME		"panel"
 
-#define FIQ_VSYNC
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-#define DRV_TYPE "c6"
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-#define DRV_TYPE "c8"
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-#define DRV_TYPE "c8b"
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2)
-#define DRV_TYPE "c8m2"
-#endif
-#define DRIVER_DATE		"20140522"
-
-//#define LCD_DEBUG_INFO
-#ifdef LCD_DEBUG_INFO
-#define DBG_PRINT(...)		printk(__VA_ARGS__)
-#else
-#define DBG_PRINT(...)
-#endif
-
-unsigned int vpp2_sel = 0; /*0,vpp; 1, vpp2 */
-unsigned int lcd_status_flag = 1;
-
 typedef struct {
 	Lcd_Config_t *pConf;
 	vinfo_t lcd_info;
-	struct pinctrl *p;
 } lcd_dev_t;
 
 static lcd_dev_t *pDev = NULL;
-static spinlock_t gamma_write_lock;
-static spinlock_t lcd_clk_lock;
+static struct class *gamma_debug_class = NULL;
 static Bool_t data_status = ON;
 static int bl_status = ON;
 
@@ -111,96 +69,6 @@ static inline void lcd_mdelay(int n)
 }
 
 #ifdef CONFIG_USE_OF
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static DSI_Config_t lcd_mipi_config = {
-    .lane_num = 4,
-    .bit_rate_min = 0,
-    .bit_rate_max = 0,
-    .transfer_ctrl = 0,
-    .dsi_init_on = NULL,
-    .dsi_init_off = NULL,
-    .lcd_extern_init = 0,
-};
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static EDP_Config_t lcd_edp_config = {
-	.link_user = 0,
-	.link_rate = 1,
-	.lane_count = 4,
-	.link_adaptive = 0,
-	.vswing = 0,
-	.preemphasis = 0,
-};
-#endif
-
-static LVDS_Config_t lcd_lvds_config = {
-	.lvds_vswing = 1,
-	.lvds_repack_user = 0,
-	.lvds_repack = 0,
-	.pn_swap = 0,
-};
-
-static TTL_Config_t lcd_ttl_config = {
-	.rb_swap = 0,
-	.bit_swap = 0,
-};
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static MLVDS_Config_t lcd_mlvds_config = {
-    .mlvds_insert_start = 0x45,
-    .total_line_clk = 1448,
-    .test_dual_gate = 1,
-    .test_pair_num = 6,
-    .scan_function = 1,
-    .phase_select = 1,
-    .TL080_phase =3,
-};
-#endif
-
-static Lcd_Config_t lcd_config = {
-    .lcd_timing = {
-        .lcd_clk = 40000000,
-        .clk_ctrl = (1<<CLK_CTRL_AUTO) | (1<<CLK_CTRL_VCLK_SEL) | (7<<CLK_CTRL_XD),
-        .video_on_pixel = 120,
-        .video_on_line = 32,
-        .hvsync_valid = 1,
-        .de_valid = 1,
-        .pol_cntl_addr = (0 << LCD_CPH1_POL) |(0 << LCD_HS_POL) | (0 << LCD_VS_POL),
-        .inv_cnt_addr = (0 << LCD_INV_EN) | (0 << LCD_INV_CNT),
-        .tcon_misc_sel_addr = (1 << LCD_STV1_SEL) | (1 << LCD_STV2_SEL),
-    },
-    .lcd_effect = {
-        .gamma_cntl_port = (1 << LCD_GAMMA_EN),
-        .rgb_base_addr = 0xf0,
-        .rgb_coeff_addr = 0x74a,
-        .dith_user = 0,
-        .vadj_brightness = 0x0,
-        .vadj_contrast = 0x80,
-        .vadj_saturation = 0x100,
-        .gamma_revert = 0,
-        .gamma_r_coeff = 100,
-        .gamma_g_coeff = 100,
-        .gamma_b_coeff = 100,
-    },
-    .lcd_control = {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        .mipi_config = &lcd_mipi_config,
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        .edp_config = &lcd_edp_config,
-#endif
-        .lvds_config = &lcd_lvds_config,
-        .ttl_config = &lcd_ttl_config,
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-        .mlvds_config = &lcd_mlvds_config,
-#endif
-    },
-    .lcd_power_ctrl = {
-        .power_on_step = 0,
-        .power_off_step = 0,
-    }
-};
-
 static void lcd_setup_gamma_table(Lcd_Config_t *pConf, unsigned int rgb_flag)
 {
 	int i;
@@ -240,205 +108,6 @@ static void lcd_setup_gamma_table(Lcd_Config_t *pConf, unsigned int rgb_flag)
 	}
 }
 
-static void lcd_ports_ctrl_lvds(Bool_t status)
-{
-	if (status) {
-		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1);	//enable lvds fifo
-		if (pDev->pConf->lcd_basic.lcd_bits == 6) {
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-			WRITE_LCD_REG_BITS(LVDS_PHY_CNTL4, 0x27, 0, 7);	//enable LVDS 3 channels
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-			WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1e, 11, 5);	//enable LVDS phy 3 channels
-#endif
-		}
-		else {
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-			WRITE_LCD_REG_BITS(LVDS_PHY_CNTL4, 0x2f, 0, 7);	//enable LVDS 4 channels
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-			WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);	//enable LVDS phy 4 channels
-#endif
-		}
-	}
-	else {
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		WRITE_LCD_REG_BITS(LVDS_PHY_CNTL3, 0, 0, 1);
-		WRITE_LCD_REG_BITS(LVDS_PHY_CNTL5, 0, 11, 1);	//shutdown lvds phy
-		WRITE_LCD_REG_BITS(LVDS_PHY_CNTL4, 0, 0, 7);	//disable LVDS 4 channels
-		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
-		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
-		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
-#endif
-	}
-
-	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
-}
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static void lcd_ports_ctrl_mipi(Bool_t status)
-{
-    if (status) {
-        switch (pDev->pConf->lcd_control.mipi_config->lane_num) {
-            case 1:
-                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x11, 11, 5);
-                break;
-            case 2:
-                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x19, 11, 5);
-                break;
-            case 3:
-                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1d, 11, 5);
-                break;
-            case 4:
-                WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);
-                break;
-            default:
-                break;
-        }
-    }
-    else {
-        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
-        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
-        WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
-    }
-
-    DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
-}
-#endif
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static void lcd_ports_ctrl_edp(Bool_t status)
-{
-	if (status) {
-		switch (pDev->pConf->lcd_control.edp_config->lane_count) {
-			case 1:
-				WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x18, 11, 5);
-				break;
-			case 2:
-				WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1c, 11, 5);
-				break;
-			case 4:
-				WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x1f, 11, 5);
-				break;
-			default:
-				break;
-		}
-	}
-	else {
-		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
-		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
-		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
-	}
-	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
-}
-#endif
-
-static void lcd_ports_ctrl_ttl(Bool_t status)
-{
-	struct pinctrl_state *s;
-	int ret;
-	
-	if (IS_ERR(pDev->p)) {
-		printk("set ttl_ports_ctrl pinmux error.\n");
-		return;
-	}
-
-	if (status) {
-	if (pDev->pConf->lcd_basic.lcd_bits == 6) {
-			if (pDev->pConf->lcd_timing.de_valid == 0) {
-				s = pinctrl_lookup_state(pDev->p, "ttl_6bit_hvsync_on");
-			}
-			else if (pDev->pConf->lcd_timing.hvsync_valid == 0) {
-				s = pinctrl_lookup_state(pDev->p, "ttl_6bit_de_on");
-			}
-			else {
-				s = pinctrl_lookup_state(pDev->p, "ttl_6bit_hvsync_de_on");	//select pinmux
-			}
-		}
-		else {
-			if (pDev->pConf->lcd_timing.de_valid == 0) {
-				s = pinctrl_lookup_state(pDev->p, "ttl_8bit_hvsync_on");
-			}	
-			else if (pDev->pConf->lcd_timing.hvsync_valid == 0) {
-				s = pinctrl_lookup_state(pDev->p, "ttl_8bit_de_on");
-			}
-			else {
-				s = pinctrl_lookup_state(pDev->p, "ttl_8bit_hvsync_de_on");	//select pinmux
-			}
-		}
-		if (IS_ERR(pDev->p)) {
-			printk("set ttl_ports_ctrl pinmux error.\n");
-			devm_pinctrl_put(pDev->p);
-			return;
-		}
-
-		ret = pinctrl_select_state(pDev->p, s);	//set pinmux and lock pins
-		if (ret < 0) {
-			printk("set ttl_ports_ctrl pinmux error.\n");
-			devm_pinctrl_put(pDev->p);
-			return;
-		}
-	}else {
-		//pinctrl_put(pDev->p);	//release pins
-		if (pDev->pConf->lcd_basic.lcd_bits == 6) {
-			s = pinctrl_lookup_state(pDev->p, "ttl_6bit_hvsync_de_off");	//select pinmux
-		}
-		else {
-			s = pinctrl_lookup_state(pDev->p, "ttl_8bit_hvsync_de_off");	//select pinmux
-		}
-		if (IS_ERR(pDev->p)) {
-			printk("set ttl_ports_ctrl pinmux error.\n");
-			devm_pinctrl_put(pDev->p);
-			return;
-		}
-		
-		ret = pinctrl_select_state(pDev->p, s);	//set pinmux and lock pins
-		if (ret < 0) {
-			printk("set ttl_ports_ctrl pinmux error.\n");
-			devm_pinctrl_put(pDev->p);
-			return;
-		}
-	}
-	DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
-}
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static void lcd_ports_ctrl_mlvds(Bool_t status)
-{
-	return;
-}
-#endif
-
-static void lcd_ports_ctrl(Bool_t status)
-{
-    switch(pDev->pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_MIPI:
-            lcd_ports_ctrl_mipi(status);
-            break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_EDP:
-            lcd_ports_ctrl_edp(status);
-            break;
-#endif
-        case LCD_DIGITAL_LVDS:
-            lcd_ports_ctrl_lvds(status);
-            break;
-        case LCD_DIGITAL_TTL:
-            lcd_ports_ctrl_ttl(status);
-            break;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-        case LCD_DIGITAL_MINILVDS:
-            lcd_ports_ctrl_mlvds(status);
-            break;
-#endif
-        default:
-            printk("Invalid LCD type.\n");
-            break;
-    }
-}
-
 static void backlight_power_ctrl(Bool_t status)
 {
 	if( status == ON ){
@@ -451,57 +120,10 @@ static void backlight_power_ctrl(Bool_t status)
 			return;
 		bl_power_off(LCD_BL_FLAG);
 	}
-	DBG_PRINT("%s(%s): bl_status=%s, data_status=%s\n", __FUNCTION__, (status ? "ON" : "OFF"), (bl_status ? "ON" : "OFF"), (data_status ? "ON" : "OFF"));
+	DBG_PRINT("%s(%s): data_status=%s\n", __FUNCTION__, (status ? "ON" : "OFF"), (data_status ? "ON" : "OFF"));
 	bl_status = status;
 }
 
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static void set_control_mipi(Lcd_Config_t *pConf);
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static int set_control_edp(Lcd_Config_t *pConf);
-#endif
-//for special interface
-static int lcd_power_ctrl_video(Bool_t status)
-{
-    int ret = 0;
-
-    if (status) {
-        switch(pDev->pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-            case LCD_DIGITAL_MIPI:
-                set_control_mipi(pDev->pConf);
-                break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-            case LCD_DIGITAL_EDP:
-                ret = set_control_edp(pDev->pConf);
-                break;
-#endif
-            default:
-                break;
-        }
-    }
-    else {
-        switch(pDev->pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-            case LCD_DIGITAL_MIPI:
-                mipi_dsi_link_off(pDev->pConf);  //link off command
-                break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-            case LCD_DIGITAL_EDP:
-                ret = dplpm_link_off();  //link off command
-                break;
-#endif
-            default:
-                break;
-        }
-    }
-    DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
-    return ret;
-}
-
 static int lcd_power_ctrl(Bool_t status)
 {
 	int i;
@@ -544,7 +166,10 @@ static int lcd_power_ctrl(Bool_t status)
 #endif
 					break;
 				case LCD_POWER_TYPE_SIGNAL:
-					lcd_ports_ctrl(ON);
+					if (pDev->pConf->lcd_power_ctrl.ports_ctrl == NULL)
+						printk("no lcd_ports_ctrl\n");
+					else
+						pDev->pConf->lcd_power_ctrl.ports_ctrl(ON);
 					break;
 				case LCD_POWER_TYPE_INITIAL:
 					lcd_extern_driver = aml_lcd_extern_get_driver();
@@ -565,11 +190,15 @@ static int lcd_power_ctrl(Bool_t status)
 			if (pDev->pConf->lcd_power_ctrl.power_on_config[i].delay > 0)
 				lcd_mdelay(pDev->pConf->lcd_power_ctrl.power_on_config[i].delay);
 		}
-		ret = lcd_power_ctrl_video(ON);
+		if (pDev->pConf->lcd_power_ctrl.power_ctrl_video)
+			ret = pDev->pConf->lcd_power_ctrl.power_ctrl_video(ON);
+		data_status = status;
 	}
 	else {
+		data_status = status;
 		lcd_mdelay(30);
-		ret = lcd_power_ctrl_video(OFF);
+		if (pDev->pConf->lcd_power_ctrl.power_ctrl_video)
+			ret = pDev->pConf->lcd_power_ctrl.power_ctrl_video(OFF);
 		for (i=0; i<pDev->pConf->lcd_power_ctrl.power_off_step; i++) {
 			DBG_PRINT("%s %s step %d\n", __FUNCTION__, (status ? "ON" : "OFF"), i+1);
 			switch (pDev->pConf->lcd_power_ctrl.power_off_config[i].type) {
@@ -601,7 +230,10 @@ static int lcd_power_ctrl(Bool_t status)
 #endif
 					break;
 				case LCD_POWER_TYPE_SIGNAL:
-					lcd_ports_ctrl(OFF);
+					if (pDev->pConf->lcd_power_ctrl.ports_ctrl == NULL)
+						printk("no lcd_ports_ctrl\n");
+					else
+						pDev->pConf->lcd_power_ctrl.ports_ctrl(OFF);
 					break;
 				case LCD_POWER_TYPE_INITIAL:
 					lcd_extern_driver = aml_lcd_extern_get_driver();
@@ -629,2792 +261,89 @@ static int lcd_power_ctrl(Bool_t status)
 }
 #endif
 
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static void set_gamma_table_ttl(u16 *data, u32 rgb_mask, u16 gamma_coeff)
+void _enable_backlight(void)
 {
-	int i;
-	unsigned long flags = 0;
-	spin_lock_irqsave(&gamma_write_lock, flags);
-	
-	while (!(READ_LCD_REG(GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY)));
-	WRITE_LCD_REG(GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x0 << LCD_HADR));
-	for (i=0;i<256;i++) {
-		while (!( READ_LCD_REG(GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY)));
-		WRITE_LCD_REG(GAMMA_DATA_PORT, (data[i] * gamma_coeff / 100));
-	}
-	while (!(READ_LCD_REG(GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY)));
-	WRITE_LCD_REG(GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x23 << LCD_HADR));
-	spin_unlock_irqrestore(&gamma_write_lock, flags);
+	backlight_power_ctrl(ON);
+}
+void _disable_backlight(void)
+{
+	backlight_power_ctrl(OFF);
 }
-#endif
 
-static void set_gamma_table_lcd(u16 *data, u32 rgb_mask, u16 gamma_coeff)
+static void _lcd_module_enable(void)
 {
-	int i;
-	unsigned long flags = 0;
-	spin_lock_irqsave(&gamma_write_lock, flags);
-	
-	DBG_PRINT("%s\n", __FUNCTION__);
-	while (!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY)));
-	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x0 << LCD_HADR));
-	for (i=0;i<256;i++) {
-		while (!( READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY)));
-		WRITE_LCD_REG(L_GAMMA_DATA_PORT, (data[i] * gamma_coeff / 100));
-	}
-	while (!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY)));
-	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x23 << LCD_HADR));
-	spin_unlock_irqrestore(&gamma_write_lock, flags);
+    pDev->pConf->lcd_misc_ctrl.module_enable();
 }
 
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static void write_tcon_double(MLVDS_Tcon_Config_t *mlvds_tcon)
+static void _lcd_module_disable(void)
 {
-    int channel_num = mlvds_tcon->channel_num;
-    int hv_sel = (mlvds_tcon->hv_sel) & 1;
-    int hstart_1 = mlvds_tcon->tcon_1st_hs_addr;
-    int hend_1 = mlvds_tcon->tcon_1st_he_addr;
-    int vstart_1 = mlvds_tcon->tcon_1st_vs_addr;
-    int vend_1 = mlvds_tcon->tcon_1st_ve_addr;
-    int hstart_2 = mlvds_tcon->tcon_2nd_hs_addr;
-    int hend_2 = mlvds_tcon->tcon_2nd_he_addr;
-    int vstart_2 = mlvds_tcon->tcon_2nd_vs_addr;
-    int vend_2 = mlvds_tcon->tcon_2nd_ve_addr;
+    pDev->pConf->lcd_misc_ctrl.module_disable();
+}
 
-    switch(channel_num) {
-        case 0 :
-            WRITE_LCD_REG(MTCON0_1ST_HS_ADDR, hstart_1);
-            WRITE_LCD_REG(MTCON0_1ST_HE_ADDR, hend_1);
-            WRITE_LCD_REG(MTCON0_1ST_VS_ADDR, vstart_1);
-            WRITE_LCD_REG(MTCON0_1ST_VE_ADDR, vend_1);
-            WRITE_LCD_REG(MTCON0_2ND_HS_ADDR, hstart_2);
-            WRITE_LCD_REG(MTCON0_2ND_HE_ADDR, hend_2);
-            WRITE_LCD_REG(MTCON0_2ND_VS_ADDR, vstart_2);
-            WRITE_LCD_REG(MTCON0_2ND_VE_ADDR, vend_2);
-            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STH1_SEL, 1);
-            break;
-        case 1 :
-            WRITE_LCD_REG(MTCON1_1ST_HS_ADDR, hstart_1);
-            WRITE_LCD_REG(MTCON1_1ST_HE_ADDR, hend_1);
-            WRITE_LCD_REG(MTCON1_1ST_VS_ADDR, vstart_1);
-            WRITE_LCD_REG(MTCON1_1ST_VE_ADDR, vend_1);
-            WRITE_LCD_REG(MTCON1_2ND_HS_ADDR, hstart_2);
-            WRITE_LCD_REG(MTCON1_2ND_HE_ADDR, hend_2);
-            WRITE_LCD_REG(MTCON1_2ND_VS_ADDR, vstart_2);
-            WRITE_LCD_REG(MTCON1_2ND_VE_ADDR, vend_2);
-            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_CPV1_SEL, 1);
-            break;
-        case 2 :
-            WRITE_LCD_REG(MTCON2_1ST_HS_ADDR, hstart_1);
-            WRITE_LCD_REG(MTCON2_1ST_HE_ADDR, hend_1);
-            WRITE_LCD_REG(MTCON2_1ST_VS_ADDR, vstart_1);
-            WRITE_LCD_REG(MTCON2_1ST_VE_ADDR, vend_1);
-            WRITE_LCD_REG(MTCON2_2ND_HS_ADDR, hstart_2);
-            WRITE_LCD_REG(MTCON2_2ND_HE_ADDR, hend_2);
-            WRITE_LCD_REG(MTCON2_2ND_VS_ADDR, vstart_2);
-            WRITE_LCD_REG(MTCON2_2ND_VE_ADDR, vend_2);
-            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STV1_SEL, 1);
-            break;
-        case 3 :
-            WRITE_LCD_REG(MTCON3_1ST_HS_ADDR, hstart_1);
-            WRITE_LCD_REG(MTCON3_1ST_HE_ADDR, hend_1);
-            WRITE_LCD_REG(MTCON3_1ST_VS_ADDR, vstart_1);
-            WRITE_LCD_REG(MTCON3_1ST_VE_ADDR, vend_1);
-            WRITE_LCD_REG(MTCON3_2ND_HS_ADDR, hstart_2);
-            WRITE_LCD_REG(MTCON3_2ND_HE_ADDR, hend_2);
-            WRITE_LCD_REG(MTCON3_2ND_VS_ADDR, vstart_2);
-            WRITE_LCD_REG(MTCON3_2ND_VE_ADDR, vend_2);
-            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEV1_SEL, 1);
-            break;
-        case 4 :
-            WRITE_LCD_REG(MTCON4_1ST_HS_ADDR, hstart_1);
-            WRITE_LCD_REG(MTCON4_1ST_HE_ADDR, hend_1);
-            WRITE_LCD_REG(MTCON4_1ST_VS_ADDR, vstart_1);
-            WRITE_LCD_REG(MTCON4_1ST_VE_ADDR, vend_1);
-            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_STH2_SEL, 1);
-            break;
-        case 5 :
-            WRITE_LCD_REG(MTCON5_1ST_HS_ADDR, hstart_1);
-            WRITE_LCD_REG(MTCON5_1ST_HE_ADDR, hend_1);
-            WRITE_LCD_REG(MTCON5_1ST_VS_ADDR, vstart_1);
-            WRITE_LCD_REG(MTCON5_1ST_VE_ADDR, vend_1);
-            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_CPV2_SEL, 1);
-            break;
-        case 6 :
-            WRITE_LCD_REG(MTCON6_1ST_HS_ADDR, hstart_1);
-            WRITE_LCD_REG(MTCON6_1ST_HE_ADDR, hend_1);
-            WRITE_LCD_REG(MTCON6_1ST_VS_ADDR, vstart_1);
-            WRITE_LCD_REG(MTCON6_1ST_VE_ADDR, vend_1);
-            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEH_SEL, 1);
-            break;
-        case 7 :
-            WRITE_LCD_REG(MTCON7_1ST_HS_ADDR, hstart_1);
-            WRITE_LCD_REG(MTCON7_1ST_HE_ADDR, hend_1);
-            WRITE_LCD_REG(MTCON7_1ST_VS_ADDR, vstart_1);
-            WRITE_LCD_REG(MTCON7_1ST_VE_ADDR, vend_1);
-            WRITE_LCD_REG_BITS(L_TCON_MISC_SEL_ADDR, hv_sel, LCD_OEV3_SEL, 1);
-            break;
-        default:
-            break;
+static const vinfo_t *lcd_get_current_info(void)
+{
+    if (pDev == NULL) {
+        printk("[error] no lcd device exist!\n");
+        return NULL;
     }
+    else 
+        return &pDev->lcd_info;
 }
-#endif
 
-static void set_tcon_lcd(Lcd_Config_t *pConf)
+DEFINE_MUTEX(lcd_vout_mutex);
+static int lcd_set_current_vmode(vmode_t mode)
 {
-	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
-	unsigned hs_pol, vs_pol;
-	int lcd_type;
-	lcd_type = pConf->lcd_basic.lcd_type;
-	DBG_PRINT("%s\n", __FUNCTION__);
-	
-	set_gamma_table_lcd(pConf->lcd_effect.GammaTableR, LCD_H_SEL_R, pConf->lcd_effect.gamma_r_coeff);
-	set_gamma_table_lcd(pConf->lcd_effect.GammaTableG, LCD_H_SEL_G, pConf->lcd_effect.gamma_g_coeff);
-	set_gamma_table_lcd(pConf->lcd_effect.GammaTableB, LCD_H_SEL_B, pConf->lcd_effect.gamma_b_coeff);
-
-	WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, ((pConf->lcd_effect.gamma_cntl_port >> LCD_GAMMA_EN) & 1), 0, 1);
-	//WRITE_LCD_REG(L_GAMMA_VCOM_HSWITCH_ADDR, pConf->lcd_effect.gamma_vcom_hswitch_addr);
+    mutex_lock(&lcd_vout_mutex);
+    if (VMODE_LCD != (mode & VMODE_MODE_BIT_MASK)) {
+        mutex_unlock(&lcd_vout_mutex);
+        return -EINVAL;
+    }
 
-	WRITE_LCD_REG(L_RGB_BASE_ADDR, pConf->lcd_effect.rgb_base_addr);
-	WRITE_LCD_REG(L_RGB_COEFF_ADDR, pConf->lcd_effect.rgb_coeff_addr);
-	
-	if (pConf->lcd_effect.dith_user) {
-		WRITE_LCD_REG(L_DITH_CNTL_ADDR,  pConf->lcd_effect.dith_cntl_addr);
-	}
-	else {
-		if(pConf->lcd_basic.lcd_bits == 8)
-			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x400);
-		else
-			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x600);
-	}
-	
-	hs_pol = ((pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1);	//0 for low active, 1 for high active
-	vs_pol = ((pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1);	//0 for low active, 1 for high active
-	
-	WRITE_LCD_REG(L_POL_CNTL_ADDR,   ((1 << LCD_TCON_DE_SEL) | (1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL))); //enable tcon DE, Hsync, Vsync
-	SET_LCD_REG_MASK(L_POL_CNTL_ADDR, ((0 << LCD_DE_POL) | ((vs_pol ? 0 : 1) << LCD_VS_POL) | ((hs_pol ? 0 : 1) << LCD_HS_POL)));	//adjust hvsync pol
-	
-	//DE signal
-	WRITE_LCD_REG(L_DE_HS_ADDR,		tcon_adr->oeh_hs_addr);
-	WRITE_LCD_REG(L_DE_HE_ADDR,		tcon_adr->oeh_he_addr);
-	WRITE_LCD_REG(L_DE_VS_ADDR,		tcon_adr->oeh_vs_addr);
-	WRITE_LCD_REG(L_DE_VE_ADDR,		tcon_adr->oeh_ve_addr);
-	
-	//Hsync signal
-	WRITE_LCD_REG(L_HSYNC_HS_ADDR,	tcon_adr->sth1_hs_addr);
-	WRITE_LCD_REG(L_HSYNC_HE_ADDR,	tcon_adr->sth1_he_addr);
-	WRITE_LCD_REG(L_HSYNC_VS_ADDR,	tcon_adr->sth1_vs_addr);
-	WRITE_LCD_REG(L_HSYNC_VE_ADDR,	tcon_adr->sth1_ve_addr);
-	
-	//Vsync signal
-	WRITE_LCD_REG(L_VSYNC_HS_ADDR,	tcon_adr->stv1_hs_addr);
-	WRITE_LCD_REG(L_VSYNC_HE_ADDR,	tcon_adr->stv1_he_addr);
-	WRITE_LCD_REG(L_VSYNC_VS_ADDR,	tcon_adr->stv1_vs_addr);
-	WRITE_LCD_REG(L_VSYNC_VE_ADDR,	tcon_adr->stv1_ve_addr);
+    pDev->pConf->lcd_misc_ctrl.vpp_sel = 0;
+    WRITE_LCD_REG(VPP_POSTBLEND_H_SIZE, pDev->lcd_info.width);
 
-	if(vpp2_sel)
-		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
-	else
-		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+    if( !(mode&VMODE_LOGO_BIT_MASK) ){
+        _disable_backlight();
+        _lcd_module_enable();
+        _enable_backlight();
+    }
+    if (VMODE_INIT_NULL == pDev->lcd_info.mode)
+        pDev->lcd_info.mode = VMODE_LCD;
+    
+    mutex_unlock(&lcd_vout_mutex);
+    return 0;
 }
 
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static void set_tcon_ttl(Lcd_Config_t *pConf)
+#ifdef CONFIG_AM_TV_OUTPUT2
+static int lcd_set_current_vmode2(vmode_t mode)
 {
-	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
-	unsigned hs_pol, vs_pol;
-	
-	DBG_PRINT("%s.\n", __FUNCTION__);	
-
-	set_gamma_table_ttl(pConf->lcd_effect.GammaTableR, LCD_H_SEL_R, pConf->lcd_effect.gamma_r_coeff);
-	set_gamma_table_ttl(pConf->lcd_effect.GammaTableG, LCD_H_SEL_G, pConf->lcd_effect.gamma_g_coeff);
-	set_gamma_table_ttl(pConf->lcd_effect.GammaTableB, LCD_H_SEL_B, pConf->lcd_effect.gamma_b_coeff);
-
-	WRITE_LCD_REG_BITS(GAMMA_CNTL_PORT, ((pConf->lcd_effect.gamma_cntl_port >> LCD_GAMMA_EN) & 1), 0, 1);
-	//WRITE_LCD_REG(GAMMA_VCOM_HSWITCH_ADDR, pConf->lcd_effect.gamma_vcom_hswitch_addr);
-
-	WRITE_LCD_REG(RGB_BASE_ADDR,   pConf->lcd_effect.rgb_base_addr);
-	WRITE_LCD_REG(RGB_COEFF_ADDR,  pConf->lcd_effect.rgb_coeff_addr);
-	WRITE_LCD_REG(POL_CNTL_ADDR,   (pConf->lcd_timing.pol_cntl_addr) & ((1 << LCD_CPH1_POL) | (1 << LCD_CPH2_POL) | (1 << LCD_CPH3_POL)));
-
-	if (pConf->lcd_effect.dith_user) {
-		WRITE_LCD_REG(DITH_CNTL_ADDR,  pConf->lcd_effect.dith_cntl_addr);
-	}
-	else {
-		if(pConf->lcd_basic.lcd_bits == 8)
-			WRITE_LCD_REG(DITH_CNTL_ADDR,  0x400);
-		else
-			WRITE_LCD_REG(DITH_CNTL_ADDR,  0x600);
-	}
-	
-	hs_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1;
-	vs_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1;
-	
-	if (hs_pol) {
-		WRITE_LCD_REG(STH1_HS_ADDR,    tcon_adr->sth1_hs_addr);
-		WRITE_LCD_REG(STH1_HE_ADDR,    tcon_adr->sth1_he_addr);
-	}
-	else {
-		WRITE_LCD_REG(STH1_HS_ADDR,    tcon_adr->sth1_he_addr);
-		WRITE_LCD_REG(STH1_HE_ADDR,    tcon_adr->sth1_hs_addr);
-	}
-    WRITE_LCD_REG(STH1_VS_ADDR,    tcon_adr->sth1_vs_addr);
-    WRITE_LCD_REG(STH1_VE_ADDR,    tcon_adr->sth1_ve_addr);
-
-    WRITE_LCD_REG(OEH_HS_ADDR,     tcon_adr->oeh_hs_addr);
-    WRITE_LCD_REG(OEH_HE_ADDR,     tcon_adr->oeh_he_addr);
-	WRITE_LCD_REG(OEH_VS_ADDR,     tcon_adr->oeh_vs_addr);
-	WRITE_LCD_REG(OEH_VE_ADDR,     tcon_adr->oeh_ve_addr);
+    mutex_lock(&lcd_vout_mutex);
+    if (mode != VMODE_LCD) {
+        mutex_unlock(&lcd_vout_mutex);
+        return -EINVAL;
+    }
+    _disable_backlight();
+    pDev->pConf->lcd_misc_ctrl.vpp_sel = 1;
 
-    WRITE_LCD_REG(STV1_HS_ADDR,    tcon_adr->stv1_hs_addr);
-    WRITE_LCD_REG(STV1_HE_ADDR,    tcon_adr->stv1_he_addr);
-	if (vs_pol) {
-		WRITE_LCD_REG(STV1_VS_ADDR,    tcon_adr->stv1_vs_addr);
-		WRITE_LCD_REG(STV1_VE_ADDR,    tcon_adr->stv1_ve_addr);
-	}
-	else {
-		WRITE_LCD_REG(STV1_VS_ADDR,    tcon_adr->stv1_ve_addr);
-		WRITE_LCD_REG(STV1_VE_ADDR,    tcon_adr->stv1_vs_addr);	
-	}
-	
-    WRITE_LCD_REG(INV_CNT_ADDR,			tcon_adr->inv_cnt_addr);
-    WRITE_LCD_REG(TCON_MISC_SEL_ADDR,	tcon_adr->tcon_misc_sel_addr);
+    WRITE_LCD_REG(VPP2_POSTBLEND_H_SIZE, pDev->lcd_info.width);
 
-	if(vpp2_sel)
-		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
-	else
-		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+    _lcd_module_enable();
+    if (VMODE_INIT_NULL == pDev->lcd_info.mode)
+        pDev->lcd_info.mode = VMODE_LCD;
+    _enable_backlight();
+    mutex_unlock(&lcd_vout_mutex);
+    return 0;
 }
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static void set_tcon_ttl(Lcd_Config_t *pConf)
-{
-	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
-	unsigned hs_pol, vs_pol;
-	
-	DBG_PRINT("%s.\n", __FUNCTION__);	
-
-	set_gamma_table_lcd(pConf->lcd_effect.GammaTableR, LCD_H_SEL_R, pConf->lcd_effect.gamma_r_coeff);
-	set_gamma_table_lcd(pConf->lcd_effect.GammaTableG, LCD_H_SEL_G, pConf->lcd_effect.gamma_g_coeff);
-	set_gamma_table_lcd(pConf->lcd_effect.GammaTableB, LCD_H_SEL_B, pConf->lcd_effect.gamma_b_coeff);
-
-	WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, ((pConf->lcd_effect.gamma_cntl_port >> LCD_GAMMA_EN) & 1), 0, 1);
-	//WRITE_LCD_REG(L_GAMMA_VCOM_HSWITCH_ADDR, pConf->lcd_effect.gamma_vcom_hswitch_addr);
-
-	WRITE_LCD_REG(L_RGB_BASE_ADDR,   pConf->lcd_effect.rgb_base_addr);
-	WRITE_LCD_REG(L_RGB_COEFF_ADDR,  pConf->lcd_effect.rgb_coeff_addr);
-	WRITE_LCD_REG(L_POL_CNTL_ADDR,   (pConf->lcd_timing.pol_cntl_addr) & ((1 << LCD_CPH1_POL) | (1 << LCD_CPH2_POL) | (1 << LCD_CPH3_POL)));
-
-	if (pConf->lcd_effect.dith_user) {
-		WRITE_LCD_REG(L_DITH_CNTL_ADDR,  pConf->lcd_effect.dith_cntl_addr);
-	}
-	else {
-		if(pConf->lcd_basic.lcd_bits == 8)
-			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x400);
-		else
-			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x600);
-	}
-	
-	hs_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1;
-	vs_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1;
-	
-	if (hs_pol) {
-		WRITE_LCD_REG(L_STH1_HS_ADDR,    tcon_adr->sth1_hs_addr);
-		WRITE_LCD_REG(L_STH1_HE_ADDR,    tcon_adr->sth1_he_addr);
-	}
-	else {
-		WRITE_LCD_REG(L_STH1_HS_ADDR,    tcon_adr->sth1_he_addr);
-		WRITE_LCD_REG(L_STH1_HE_ADDR,    tcon_adr->sth1_hs_addr);
-	}
-    WRITE_LCD_REG(L_STH1_VS_ADDR,    tcon_adr->sth1_vs_addr);
-    WRITE_LCD_REG(L_STH1_VE_ADDR,    tcon_adr->sth1_ve_addr);
-
-    WRITE_LCD_REG(L_OEH_HS_ADDR,     tcon_adr->oeh_hs_addr);
-    WRITE_LCD_REG(L_OEH_HE_ADDR,     tcon_adr->oeh_he_addr);
-    WRITE_LCD_REG(L_OEH_VS_ADDR,     tcon_adr->oeh_vs_addr);
-    WRITE_LCD_REG(L_OEH_VE_ADDR,     tcon_adr->oeh_ve_addr);
-
-    WRITE_LCD_REG(L_STV1_HS_ADDR,    tcon_adr->stv1_hs_addr);
-    WRITE_LCD_REG(L_STV1_HE_ADDR,    tcon_adr->stv1_he_addr);
-	
-	if (vs_pol) {
-		WRITE_LCD_REG(L_STV1_VS_ADDR,    tcon_adr->stv1_vs_addr);
-		WRITE_LCD_REG(L_STV1_VE_ADDR,    tcon_adr->stv1_ve_addr);
-	}
-	else {
-		WRITE_LCD_REG(L_STV1_VS_ADDR,    tcon_adr->stv1_ve_addr);
-		WRITE_LCD_REG(L_STV1_VE_ADDR,    tcon_adr->stv1_vs_addr);
-	}
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-	WRITE_LCD_REG(L_POL_CNTL_ADDR,   ((1 << LCD_TCON_DE_SEL) | (1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL))); //enable tcon DE, Hsync, Vsync 
-	WRITE_LCD_REG(L_POL_CNTL_ADDR,   (READ_LCD_REG(L_POL_CNTL_ADDR) | ((0 << LCD_DE_POL) | ((vs_pol ? 0 : 1) << LCD_VS_POL) | ((hs_pol ? 0 : 1) << LCD_HS_POL))));	//adjust hvsync pol
-	
-	//DE signal
-	WRITE_LCD_REG(L_DE_HS_ADDR,    tcon_adr->oeh_hs_addr);
-	WRITE_LCD_REG(L_DE_HE_ADDR,    tcon_adr->oeh_he_addr);
-	WRITE_LCD_REG(L_DE_VS_ADDR,    tcon_adr->oeh_vs_addr);
-	WRITE_LCD_REG(L_DE_VE_ADDR,    tcon_adr->oeh_ve_addr);
-	
-	WRITE_LCD_REG(L_OEV1_HS_ADDR,  tcon_adr->oeh_hs_addr);
-	WRITE_LCD_REG(L_OEV1_HE_ADDR,  tcon_adr->oeh_he_addr);
-	WRITE_LCD_REG(L_OEV1_VS_ADDR,  tcon_adr->oeh_vs_addr);
-	WRITE_LCD_REG(L_OEV1_VE_ADDR,  tcon_adr->oeh_ve_addr);
-	
-	//Hsync signal
-	WRITE_LCD_REG(L_HSYNC_HS_ADDR, tcon_adr->sth1_hs_addr);
-	WRITE_LCD_REG(L_HSYNC_HE_ADDR, tcon_adr->sth1_he_addr);
-	WRITE_LCD_REG(L_HSYNC_VS_ADDR, tcon_adr->sth1_vs_addr);
-	WRITE_LCD_REG(L_HSYNC_VE_ADDR, tcon_adr->sth1_ve_addr);
-	
-	//Vsync signal
-	WRITE_LCD_REG(L_VSYNC_HS_ADDR, tcon_adr->stv1_hs_addr);
-	WRITE_LCD_REG(L_VSYNC_HE_ADDR, tcon_adr->stv1_he_addr);
-	WRITE_LCD_REG(L_VSYNC_VS_ADDR, tcon_adr->stv1_vs_addr);
-	WRITE_LCD_REG(L_VSYNC_VE_ADDR, tcon_adr->stv1_ve_addr);
 #endif
 
-    WRITE_LCD_REG(L_INV_CNT_ADDR,       tcon_adr->inv_cnt_addr);
-    WRITE_LCD_REG(L_TCON_MISC_SEL_ADDR, tcon_adr->tcon_misc_sel_addr);
-
-	if(vpp2_sel)
-		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
-	else
-		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+static vmode_t lcd_validate_vmode(char *mode)
+{
+    if ((strncmp(mode, PANEL_NAME, strlen(PANEL_NAME))) == 0)
+        return VMODE_LCD;
+    
+    return VMODE_MAX;
 }
-#endif
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-// Set the mlvds TCON
-// this function should support dual gate or singal gate TCON setting.
-// singal gate TCON, Scan Function TO DO.
-// scan_function   // 0 - Z1, 1 - Z2, 2- Gong
-static void set_tcon_mlvds(Lcd_Config_t *pConf)
-{
-	MLVDS_Tcon_Config_t *mlvds_tconfig_l = pConf->lcd_control.mlvds_tcon_config;
-    int dual_gate = pConf->lcd_control.mlvds_config->test_dual_gate;
-    int bit_num = pConf->lcd_basic.lcd_bits;
-    int pair_num = pConf->lcd_control.mlvds_config->test_pair_num;
-
-    unsigned int data32;
-
-    int pclk_div;
-    int ext_pixel = dual_gate ? pConf->lcd_control.mlvds_config->total_line_clk : 0;
-    int dual_wr_rd_start;
-    int i = 0;
-	
-	DBG_PRINT("%s.\n", __FUNCTION__);
-
-//    DBG_PRINT(" Notice: Setting VENC_DVI_SETTING[0x%4x] and GAMMA_CNTL_PORT[0x%4x].LCD_GAMMA_EN as 0 temporary\n", VENC_DVI_SETTING, GAMMA_CNTL_PORT);
-//    DBG_PRINT(" Otherwise, the panel will display color abnormal.\n");
-//    WRITE_LCD_REG(VENC_DVI_SETTING, 0);
-
-    set_gamma_table_lcd(pConf->lcd_effect.GammaTableR, LCD_H_SEL_R, pConf->lcd_effect.gamma_r_coeff);
-	set_gamma_table_lcd(pConf->lcd_effect.GammaTableG, LCD_H_SEL_G, pConf->lcd_effect.gamma_g_coeff);
-	set_gamma_table_lcd(pConf->lcd_effect.GammaTableB, LCD_H_SEL_B, pConf->lcd_effect.gamma_b_coeff);
-
-    WRITE_LCD_REG(L_GAMMA_CNTL_PORT, pConf->lcd_effect.gamma_cntl_port);
-    WRITE_LCD_REG(L_GAMMA_VCOM_HSWITCH_ADDR, pConf->lcd_effect.gamma_vcom_hswitch_addr);
-
-    WRITE_LCD_REG(L_RGB_BASE_ADDR, pConf->lcd_effect.rgb_base_addr);
-    WRITE_LCD_REG(L_RGB_COEFF_ADDR, pConf->lcd_effect.rgb_coeff_addr);
-    //WRITE_LCD_REG(L_POL_CNTL_ADDR, pConf->pol_cntl_addr);
-	if (pConf->lcd_effect.dith_user) {
-		WRITE_LCD_REG(L_DITH_CNTL_ADDR,  pConf->lcd_effect.dith_cntl_addr);
-	}	
-	else {
-		if(pConf->lcd_basic.lcd_bits == 8)
-			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x400);
-		else
-			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x600);
-	}
-	
-//    WRITE_LCD_REG(L_INV_CNT_ADDR, pConf->inv_cnt_addr);
-//    WRITE_LCD_REG(L_TCON_MISC_SEL_ADDR, pConf->tcon_misc_sel_addr);
-//    WRITE_LCD_REG(L_DUAL_PORT_CNTL_ADDR, pConf->dual_port_cntl_addr);
-//
-    data32 = (0x9867 << tcon_pattern_loop_data) |
-             (1 << tcon_pattern_loop_start) |
-             (4 << tcon_pattern_loop_end) |
-             (1 << ((mlvds_tconfig_l[6].channel_num)+tcon_pattern_enable)); // POL_CHANNEL use pattern generate
-
-    WRITE_LCD_REG(L_TCON_PATTERN_HI,  (data32 >> 16));
-    WRITE_LCD_REG(L_TCON_PATTERN_LO, (data32 & 0xffff));
-
-    pclk_div = (bit_num == 8) ? 3 : // phy_clk / 8
-                                2 ; // phy_clk / 6
-   data32 = (1 << ((mlvds_tconfig_l[7].channel_num)-2+tcon_pclk_enable)) |  // enable PCLK_CHANNEL
-            (pclk_div << tcon_pclk_div) |
-            (
-              (pair_num == 6) ?
-              (
-              ((bit_num == 8) & dual_gate) ?
-              (
-                (0 << (tcon_delay + 0*3)) |
-                (0 << (tcon_delay + 1*3)) |
-                (0 << (tcon_delay + 2*3)) |
-                (0 << (tcon_delay + 3*3)) |
-                (0 << (tcon_delay + 4*3)) |
-                (0 << (tcon_delay + 5*3)) |
-                (0 << (tcon_delay + 6*3)) |
-                (0 << (tcon_delay + 7*3))
-              ) :
-              (
-                (0 << (tcon_delay + 0*3)) |
-                (0 << (tcon_delay + 1*3)) |
-                (0 << (tcon_delay + 2*3)) |
-                (0 << (tcon_delay + 3*3)) |
-                (0 << (tcon_delay + 4*3)) |
-                (0 << (tcon_delay + 5*3)) |
-                (0 << (tcon_delay + 6*3)) |
-                (0 << (tcon_delay + 7*3))
-              )
-              ) :
-              (
-              ((bit_num == 8) & dual_gate) ?
-              (
-                (0 << (tcon_delay + 0*3)) |
-                (0 << (tcon_delay + 1*3)) |
-                (0 << (tcon_delay + 2*3)) |
-                (0 << (tcon_delay + 3*3)) |
-                (0 << (tcon_delay + 4*3)) |
-                (0 << (tcon_delay + 5*3)) |
-                (0 << (tcon_delay + 6*3)) |
-                (0 << (tcon_delay + 7*3))
-              ) :
-              (bit_num == 8) ?
-              (
-                (0 << (tcon_delay + 0*3)) |
-                (0 << (tcon_delay + 1*3)) |
-                (0 << (tcon_delay + 2*3)) |
-                (0 << (tcon_delay + 3*3)) |
-                (0 << (tcon_delay + 4*3)) |
-                (0 << (tcon_delay + 5*3)) |
-                (0 << (tcon_delay + 6*3)) |
-                (0 << (tcon_delay + 7*3))
-              ) :
-              (
-                (0 << (tcon_delay + 0*3)) |
-                (0 << (tcon_delay + 1*3)) |
-                (0 << (tcon_delay + 2*3)) |
-                (0 << (tcon_delay + 3*3)) |
-                (0 << (tcon_delay + 4*3)) |
-                (0 << (tcon_delay + 5*3)) |
-                (0 << (tcon_delay + 6*3)) |
-                (0 << (tcon_delay + 7*3))
-              )
-              )
-            );
-
-    WRITE_LCD_REG(TCON_CONTROL_HI,  (data32 >> 16));
-    WRITE_LCD_REG(TCON_CONTROL_LO, (data32 & 0xffff));
-
-
-    WRITE_LCD_REG(L_TCON_DOUBLE_CTL,
-                   (1<<(mlvds_tconfig_l[3].channel_num))   // invert CPV
-                  );
-
-	// for channel 4-7, set second setting same as first
-    WRITE_LCD_REG(L_DE_HS_ADDR, (0x3 << 14) | ext_pixel);   // 0x3 -- enable double_tcon fir channel7:6
-    WRITE_LCD_REG(L_DE_HE_ADDR, (0x3 << 14) | ext_pixel);   // 0x3 -- enable double_tcon fir channel5:4
-    WRITE_LCD_REG(L_DE_VS_ADDR, (0x3 << 14) | 0);	// 0x3 -- enable double_tcon fir channel3:2
-    WRITE_LCD_REG(L_DE_VE_ADDR, (0x3 << 14) | 0);	// 0x3 -- enable double_tcon fir channel1:0	
-
-    dual_wr_rd_start = 0x5d;
-    WRITE_LCD_REG(MLVDS_DUAL_GATE_WR_START, dual_wr_rd_start);
-    WRITE_LCD_REG(MLVDS_DUAL_GATE_WR_END, dual_wr_rd_start + 1280);
-    WRITE_LCD_REG(MLVDS_DUAL_GATE_RD_START, dual_wr_rd_start + ext_pixel - 2);
-    WRITE_LCD_REG(MLVDS_DUAL_GATE_RD_END, dual_wr_rd_start + 1280 + ext_pixel - 2);
-
-    WRITE_LCD_REG(MLVDS_SECOND_RESET_CTL, (pConf->lcd_control.mlvds_config->mlvds_insert_start + ext_pixel));
-
-    data32 = (0 << ((mlvds_tconfig_l[5].channel_num)+mlvds_tcon_field_en)) |  // enable EVEN_F on TCON channel 6
-             ( (0x0 << mlvds_scan_mode_odd) | (0x0 << mlvds_scan_mode_even)
-             ) | (0 << mlvds_scan_mode_start_line);
-
-	WRITE_LCD_REG(MLVDS_DUAL_GATE_CTL_HI,  (data32 >> 16));
-	WRITE_LCD_REG(MLVDS_DUAL_GATE_CTL_LO, (data32 & 0xffff));
-
-	DBG_PRINT("write minilvds tcon 0~7.\n");
-	for(i = 0; i < 8; i++) {
-		write_tcon_double(&mlvds_tconfig_l[i]);
-	}
-/*	
-	if(vpp2_sel)
-		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
-	else
-		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
-*/
-}
-#endif
-
-static void set_lcd_spread_spectrum(int ss_level)
-{
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	unsigned pll_ctrl2, pll_ctrl3, pll_ctrl4;
-	DBG_PRINT("%s.\n", __FUNCTION__);
-	
-	switch (ss_level) {
-		case 1:  //about 0.5%
-			pll_ctrl2 = 0x16110696;
-			pll_ctrl3 = 0x6d625012;
-			pll_ctrl4 = 0x130;
-			break;
-		case 2:  //about 1%
-			pll_ctrl2 = 0x16110696;
-			pll_ctrl3 = 0x4d625012;
-			pll_ctrl4 = 0x130;
-			break;
-		case 3:  //about 2%
-			pll_ctrl2 = 0x16110696;
-			pll_ctrl3 = 0x2d425012;
-			pll_ctrl4 = 0x130;
-			break;
-		case 4:  //about 3%
-			pll_ctrl2 = 0x16110696;
-			pll_ctrl3 = 0x1d425012;
-			pll_ctrl4 = 0x130;
-			break;
-		case 5:  //about 4%
-			pll_ctrl2 = 0x16110696;
-			pll_ctrl3 = 0x0d125012;
-			pll_ctrl4 = 0x130;
-			break;
-		case 6:  //about 5%
-			pll_ctrl2 = 0x16110696;
-			pll_ctrl3 = 0x0e425012;
-			pll_ctrl4 = 0x130;
-			break;
-		case 0:	//disable ss
-		default:
-			pll_ctrl2 = 0x814d3928;
-			pll_ctrl3 = 0x6b425012;
-			pll_ctrl4 = 0x110;
-			break;
-	}
-
-	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL2, pll_ctrl2);
-	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL3, pll_ctrl3);
-	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL4, pll_ctrl4);
-#endif
-}
-
-static void vclk_set_lcd(int lcd_type, int vclk_sel, unsigned long pll_reg, unsigned long vid_div_reg, unsigned int clk_ctrl_reg)
-{
-	unsigned edp_div0_sel = 0, edp_div1_sel = 0, xd = 0;
-	unsigned pll_level = 0, pll_frac = 0;
-	int wait_loop = PLL_WAIT_LOCK_CNT;
-	unsigned pll_lock = 0;
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	unsigned ss_level=0, pll_ctrl2, pll_ctrl3, pll_ctrl4, od_fb;
-#endif
-	unsigned long flags = 0;
-	spin_lock_irqsave(&lcd_clk_lock, flags);
-	
-	DBG_PRINT("%s.\n", __FUNCTION__);
-
-	edp_div0_sel = (vid_div_reg >> DIV_CTRL_EDP_DIV0) & 0xf;
-	edp_div1_sel = (vid_div_reg >> DIV_CTRL_EDP_DIV1) & 0x7;
-	vid_div_reg = ((vid_div_reg & 0x1ffff) | (1 << 16) | (1 << 15) | (0x3 << 0));	//select vid2_pll and enable clk
-	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xf;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	pll_level = 0;
-	pll_frac = 0;
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	pll_level = (clk_ctrl_reg >> CLK_CTRL_LEVEL) & 0x7;
-	pll_frac = (clk_ctrl_reg >> CLK_CTRL_FRAC) & 0xfff;
-	ss_level = (clk_ctrl_reg >> CLK_CTRL_SS) & 0xf;
-	pll_reg |= (1 << PLL_CTRL_EN);
-#endif
-	
-	if(vclk_sel)
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 19, 1);	//disable vclk2_en 
-	else
-		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 0, 19, 2);	//disable vclk1_en1,en0
-	udelay(2);
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	WRITE_LCD_CBUS_REG(HHI_EDP_TX_PHY_CNTL0, (1 << 16));	//reset edp tx phy
-#endif
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_PLL_CNTL, 1, 29, 1);	//reset pll
-	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL, pll_reg|(1<<PLL_CTRL_RST));
-	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL2, 0x814d3928 );
-	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL3, 0x6b425012 );
-	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL4, 0x110 );
-	WRITE_LCD_CBUS_REG(HHI_VIID_PLL_CNTL, pll_reg );
-	do{
-		udelay(50);
-		pll_lock = (READ_LCD_CBUS_REG(HHI_VIID_PLL_CNTL) >> PLL_CTRL_LOCK) & 0x1;
-		wait_loop--;
-	}while((pll_lock == 0) && (wait_loop > 0));
-	if (wait_loop == 0)
-		printk("[error]: vid2_pll lock failed\n");
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	if (pll_frac == 0)
-		pll_ctrl2 = 0x0421a000;
-	else
-		pll_ctrl2 = (0x0431a000 | pll_frac);
-	
-	pll_ctrl4 = (0xd4000d67 & ~((1<<13) | (0xf<<14) | (0xf<<18)));
-	switch (ss_level) {
-		case 1:	//0.5%
-			pll_ctrl4 |= ((1<<13) | (2<<18) | (1<<14));
-			break;
-		case 2:	//1%
-			pll_ctrl4 |= ((1<<13) | (1<<18) | (1<<14));
-			break;
-		case 3:	//1.5%
-			pll_ctrl4 |= ((1<<13) | (8<<18) | (1<<14));
-			break;
-		case 4: //2%
-			pll_ctrl4 |= ((1<<13) | (0<<18) | (1<<14));
-			break;
-		case 0:
-		default:
-			ss_level = 0;
-			break;
-	}
-	
-	switch (pll_level) {
-		case 1:
-			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca45b823;
-			od_fb = 0;
-			break;
-		case 2:
-			pll_ctrl2 |= (1<<19);//special adjust
-			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca49b823;
-			od_fb = 1;
-			break;
-		case 3:
-			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca49b823;
-			od_fb = 1;
-			break;
-		case 4:
-			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xce49c022;
-			od_fb = 1;
-			break;
-		default:
-			pll_ctrl3 = 0xca7e3823;
-			od_fb = 0;
-			break;
-	}
-	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL5, 1, 16, 1);//enable bandgap
-	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL2, pll_ctrl2);
-	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL3, pll_ctrl3);
-	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL4, pll_ctrl4);
-	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL5, (0x00700001 | (od_fb << 8)));	//[8] od_fb
-	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL, pll_reg | (1 << PLL_CTRL_RST));
-	WRITE_LCD_CBUS_REG(HHI_VID2_PLL_CNTL, pll_reg);
-	
-	do{
-		udelay(50);
-		pll_lock = (READ_LCD_CBUS_REG(HHI_VID2_PLL_CNTL) >> PLL_CTRL_LOCK) & 0x1;
-		if (wait_loop == 100) {
-			if (pll_level == 2) {
-				//change setting if can't lock
-				WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL2, 1, 18, 1);
-				WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 1, PLL_CTRL_RST, 1);
-				WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0, PLL_CTRL_RST, 1);
-				printk("change setting for vid2 pll stability\n");
-			}
-		}
-		wait_loop--;
-	}while((pll_lock == 0) && (wait_loop > 0));
-	if (wait_loop == 0)
-		printk("[error]: vid2_pll lock failed\n");
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-	if (pll_frac == 0)
-		pll_ctrl2 = 0x59c88000;
-	else
-		pll_ctrl2 = (0x59c8c000 | pll_frac);
-	
-	pll_ctrl4 = (0x00238100 & ~((1<<9) | (0xf<<4) | (0xf<<0)));
-	switch (ss_level) {
-		case 1:	//0.5%
-			pll_ctrl4 |= ((1<<9) | (2<<4) | (1<<0));
-			break;
-		case 2:	//1%
-			pll_ctrl4 |= ((1<<9) | (1<<4) | (1<<0));
-			break;
-		case 3:	//1.5%
-			pll_ctrl4 |= ((1<<9) | (8<<4) | (1<<0));
-			break;
-		case 4: //2%
-			pll_ctrl4 |= ((1<<9) | (0<<4) | (1<<0));
-			break;
-		case 0:
-		default:
-			ss_level = 0;
-			break;
-	}
-	
-	switch (pll_level) {
-		case 1: //<=1.7G
-			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca49b022;
-			od_fb = 0;
-			break;
-		case 2: //1.7G~2.0G
-			pll_ctrl2 |= (1<<13);//special adjust
-			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca493822;
-			od_fb = 1;
-			break;
-		case 3: //2.0G~2.5G
-			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xca493822;
-			od_fb = 1;
-			break;
-		case 4: //>=2.5G
-			pll_ctrl3 = (ss_level > 0) ? 0xca7e3823 : 0xce49c022;
-			od_fb = 1;
-			break;
-		default:
-			pll_ctrl3 = 0xca7e3823;
-			od_fb = 0;
-			break;
-	}
-	WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL2, 1, 16, 1);//enable ext LDO
-	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL2, pll_ctrl2);
-	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL3, pll_ctrl3);
-	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL4, (pll_ctrl4 | (od_fb << 24))); //[24] od_fb
-	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL5, 0x00012385);
-	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL, pll_reg | (1 << PLL_CTRL_RST));
-	WRITE_LCD_CBUS_REG(HHI_VID_PLL_CNTL, pll_reg);
-	
-	do{
-		udelay(50);
-		pll_lock = (READ_LCD_CBUS_REG(HHI_VID_PLL_CNTL) >> PLL_CTRL_LOCK) & 0x1;
-		if (wait_loop == 100) {
-			if (pll_level == 2) {
-				//change setting if can't lock
-				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL2, 1, 12, 1);
-				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 1, PLL_CTRL_RST, 1);
-				WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, PLL_CTRL_RST, 1);
-				printk("change setting for vid pll stability\n");
-			}
-		}
-		wait_loop--;
-	}while((pll_lock == 0) && (wait_loop > 0));
-	if (wait_loop == 0)
-		printk("[error]: vid_pll lock failed\n");
-#endif
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	//select logic & encl clock
-	switch (lcd_type) {
-		case LCD_DIGITAL_MIPI:
-			WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 3, 23, 3);	//pll_out mux to mipi-dsi phy & vid2_pll
-			WRITE_LCD_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 0, 4, 1);
-			break;
-		case LCD_DIGITAL_EDP:
-			WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 4, 23, 3);	//pll_out mux to edp phy
-			WRITE_LCD_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 1, 4, 1);
-			
-			WRITE_LCD_CBUS_REG(HHI_EDP_TX_PHY_CNTL0, (0xf << 0) | (1 << 4));	//enable edp phy channel & serializer clk, and release reset
-			WRITE_LCD_CBUS_REG_BITS(HHI_EDP_TX_PHY_CNTL0, edp_div0_sel, 20, 4);	//set edptx_phy_clk_div0
-			WRITE_LCD_CBUS_REG_BITS(HHI_EDP_TX_PHY_CNTL0, edp_div1_sel, 24, 3);	//set edptx_phy_clk_div1
-			WRITE_LCD_CBUS_REG_BITS(HHI_EDP_TX_PHY_CNTL0, 1, 5, 1);	//enable divider N, for vid_pll2_in
-			
-			WRITE_LCD_CBUS_REG(HHI_EDP_APB_CLK_CNTL, (1 << 7) | (2 << 0));	//fclk_div5---fixed 510M, div to 170M, edp apb clk
-			break;
-		case LCD_DIGITAL_LVDS:
-		case LCD_DIGITAL_TTL:
-		default:
-			WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 2, 23, 3);	//pll_out mux to vid2_pll
-			WRITE_LCD_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 0, 4, 1);
-			break;
-	}
-	udelay(10);
-#endif
-
-	//pll_div2
-	WRITE_LCD_CBUS_REG(HHI_VIID_DIVIDER_CNTL, vid_div_reg);
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 7, 1);    //0x104c[7]:SOFT_RESET_POST
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 3, 1);    //0x104c[3]:SOFT_RESET_PRE
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 1, 1);    //0x104c[1]:RESET_N_POST
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 0, 1);    //0x104c[0]:RESET_N_PRE
-	udelay(5);
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 3, 1);
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 7, 1);
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 3, 0, 2);
-	udelay(5);
-
-	if (vclk_sel) {
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, (xd-1), 0, 8);	// setup the XD divider value
-		udelay(5);
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 4, 16, 3);	// Bit[18:16] - v2_cntl_clk_in_sel
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 19, 1);	//vclk2_en0
-	}
-	else {
-		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_DIV, (xd-1), 0, 8);	// setup the XD divider value
-		udelay(5);
-		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 4, 16, 3);  // Bit[18:16] - v2_cntl_clk_in_sel
-		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 1, 19, 1);	//[19]vclk_en0
-		//WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 1, 20, 1);	//enable clk_div1 (en1 is for tcon_clko???)
-	}
-	udelay(2);
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	if(lcd_type == LCD_DIGITAL_TTL){
-		if (vclk_sel)
-			WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_DIV, 8, 20, 4); // [23:20] enct_clk_sel, select v2_clk_div1
-		else
-			WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_DIV, 0, 20, 4); // [23:20] enct_clk_sel, select v1_clk_div1
-	}
-	else {
-		if (vclk_sel)
-			WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 8, 12, 4); // [23:20] encl_clk_sel, select v2_clk_div1
-		else
-			WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 0, 12, 4); // [23:20] encl_clk_sel, select v1_clk_div1
-	}
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	if (vclk_sel) {
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 8, 12, 4); // [15:12] encl_clk_sel, select vclk2_div1
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 1, 16, 2); // release vclk2_div_reset and enable vclk2_div
-	}
-	else {
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 0, 12, 4); // [15:12] encl_clk_sel, select vclk_div1
-		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_DIV, 1, 16, 2); // release vclk_div_reset and enable vclk_div	
-	}
-#endif
-	udelay(5);
-
-	if(vclk_sel) {
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 0, 1);	//enable v2_clk_div1
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 15, 1);  //soft reset
-		udelay(10);
-		WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 15, 1);  //release soft reset
-	}
-	else {
-		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 1, 0, 1);	//enable v1_clk_div1
-		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 1, 15, 1);  //soft reset
-		udelay(10);
-		WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 0, 15, 1);  //release soft reset
-	}
-	udelay(5);
-	
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-	CLK_GATE_ON(CTS_ENCL); //enable encl clk gate //new add for M8b
-#endif
-	
-	spin_unlock_irqrestore(&lcd_clk_lock, flags);
-}
-
-static void clk_util_lvds_set_clk_div(unsigned long divn_sel, unsigned long divn_tcnt, unsigned long div2_en)
-{
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-    // assign          lvds_div_phy_clk_en     = tst_lvds_tmode ? 1'b1         : phy_clk_cntl[10];
-    // assign          lvds_div_div2_sel       = tst_lvds_tmode ? atest_i[5]   : phy_clk_cntl[9];
-    // assign          lvds_div_sel            = tst_lvds_tmode ? atest_i[7:6] : phy_clk_cntl[8:7];
-    // assign          lvds_div_tcnt           = tst_lvds_tmode ? 3'd6         : phy_clk_cntl[6:4];
-    // If dividing by 1, just select the divide by 1 path
-	if( divn_tcnt == 1 )
-		divn_sel = 0;
-
-	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 10, 1);	
-	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, divn_sel, 7, 2);
-	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, div2_en, 9, 1);
-	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, ((divn_tcnt-1)&0x7), 4, 3);
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	// ---------------------------------------------
-    // Configure the LVDS PHY
-    // ---------------------------------------------
-    // wire    [4:0]   cntl_ser_en         = control[20:16];
-    // wire            cntl_prbs_en        = control[13];
-    // wire            cntl_prbs_err_en    = control[12];
-    // wire    [1:0]   cntl_mode_set_high  = control[11:10];
-    // wire    [1:0]   cntl_mode_set_low   = control[9:8];
-    // 
-    // wire    [1:0]   fifo_clk_sel        = control[7;6]
-    // 
-    // wire            mode_port_rev       = control[4];
-    // wire            mode_bit_rev        = control[3];
-    // wire            mode_inv_p_n        = control[2];
-    // wire            phy_clk_en          = control[1];
-    // wire            soft_reset_int      = control[0];
-    WRITE_LCD_CBUS_REG(HHI_LVDS_TX_PHY_CNTL0, (0x1f << 16) | (0x1 << 6) ); // enable all serializers, divide by 7
-#endif
-}
-
-static void set_pll_lcd(Lcd_Config_t *pConf)
-{
-    unsigned pll_reg, div_reg, clk_reg;
-    int vclk_sel, xd;
-    int lcd_type, ss_level;
-    unsigned pll_div_post = 0, phy_clk_div2 = 0;
-
-    DBG_PRINT("%s\n", __FUNCTION__);
-
-    pll_reg = pConf->lcd_timing.pll_ctrl;
-    div_reg = pConf->lcd_timing.div_ctrl;
-    clk_reg = pConf->lcd_timing.clk_ctrl;
-    ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
-    vclk_sel = (clk_reg >> CLK_CTRL_VCLK_SEL) & 0x1;
-    xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
-
-    lcd_type = pConf->lcd_basic.lcd_type;
-
-    switch(lcd_type){
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_MIPI:
-            break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_EDP:
-            xd = 1;
-            break;
-#endif
-        case LCD_DIGITAL_LVDS:
-            xd = 1;
-            pll_div_post = 7;
-            phy_clk_div2 = 0;
-            div_reg = (div_reg | (1 << DIV_CTRL_POST_SEL) | (1 << DIV_CTRL_LVDS_CLK_EN) | ((pll_div_post-1) << DIV_CTRL_DIV_POST) | (phy_clk_div2 << DIV_CTRL_PHY_CLK_DIV2));
-            break;
-        case LCD_DIGITAL_TTL:
-            break;
-        default:
-            break;
-    }
-    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
-
-    DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
-    vclk_set_lcd(lcd_type, vclk_sel, pll_reg, div_reg, clk_reg);
-    set_lcd_spread_spectrum(ss_level);
-
-    switch(lcd_type){
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_MIPI:
-            WRITE_LCD_REG(MIPI_DSI_TOP_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CNTL) & ~(0x7<<4)) | (1 << 4) | (1 << 5) | (0 << 6));
-            //WRITE_LCD_CBUS_REG( HHI_DSI_LVDS_EDP_CNTL0, 0x0);                                          // Select DSI as the output for u_dsi_lvds_edp_top
-            WRITE_LCD_REG(MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) | 0xf) );     // Release mipi_dsi_host's reset
-            WRITE_LCD_REG(MIPI_DSI_TOP_SW_RESET, (READ_LCD_REG(MIPI_DSI_TOP_SW_RESET) & 0xfffffff0) );     // Release mipi_dsi_host's reset
-            WRITE_LCD_REG(MIPI_DSI_TOP_CLK_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_CLK_CNTL) | 0x3) );            // Enable dwc mipi_dsi_host's clock 
-            break;
-#endif
-        case LCD_DIGITAL_LVDS:
-            clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
-            //    lvds_gen_cntl       <= {10'h0,      // [15:4] unused
-            //                            2'h1,       // [5:4] divide by 7 in the PHY
-            //                            1'b0,       // [3] fifo_en
-            //                            1'b0,       // [2] wr_bist_gate
-            //                            2'b00};     // [1:0] fifo_wr mode
-            //FIFO_CLK_SEL = 1; // div7
-            WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 4, 2);	//lvds fifo clk div 7
-
-            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 0, 15, 1);	// lvds div reset
-            udelay(5);
-            WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 15, 1);	// Release lvds div reset
-            break;
-        case LCD_DIGITAL_TTL:
-            break;
-        default:
-            break;
-    }
-}
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static void set_pll_mlvds(Lcd_Config_t *pConf)
-{
-    int test_bit_num = pConf->lcd_basic.lcd_bits;
-    int test_dual_gate = pConf->lcd_control.mlvds_config->test_dual_gate;
-    int test_pair_num= pConf->lcd_control.mlvds_config->test_pair_num;
-	
-    int pll_div_post, phy_clk_div2, FIFO_CLK_SEL, MPCLK_DELAY, MCLK_half, MCLK_half_delay;
-    unsigned int data32;
-    unsigned long mclk_pattern_dual_6_6;
-    int test_high_phase = (test_bit_num != 8) | test_dual_gate;
-    unsigned long rd_data;
-
-    unsigned pll_reg, div_reg, clk_reg;
-    int vclk_sel, xd;
-	int lcd_type, ss_level;
-	
-	DBG_PRINT("%s\n", __FUNCTION__);
-	
-    pll_reg = pConf->lcd_timing.pll_ctrl;
-    div_reg = pConf->lcd_timing.div_ctrl;
-	clk_reg = pConf->lcd_timing.clk_ctrl;
-	ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
-	vclk_sel = (clk_reg >> CLK_CTRL_VCLK_SEL) & 0x1;
-	xd = 1;
-	
-	lcd_type = pConf->lcd_basic.lcd_type;
-
-	switch(pConf->lcd_control.mlvds_config->TL080_phase) {
-		case 0 :
-			mclk_pattern_dual_6_6 = 0xc3c3c3;
-			MCLK_half = 1;
-			break;
-		case 1 :
-			mclk_pattern_dual_6_6 = 0xc3c3c3;
-			MCLK_half = 0;
-			break;
-		case 2 :
-			mclk_pattern_dual_6_6 = 0x878787;
-			MCLK_half = 1;
-			break;
-		case 3 :
-			mclk_pattern_dual_6_6 = 0x878787;
-			MCLK_half = 0;
-			break;
-		case 4 :
-			mclk_pattern_dual_6_6 = 0x3c3c3c;
-			MCLK_half = 1;
-			break;
-		case 5 :
-			mclk_pattern_dual_6_6 = 0x3c3c3c;
-			MCLK_half = 0;
-			break;
-		case 6 :
-			mclk_pattern_dual_6_6 = 0x787878;
-			MCLK_half = 1;
-			break;
-		default : // case 7
-			mclk_pattern_dual_6_6 = 0x787878;
-			MCLK_half = 0;
-			break;
-	}
-
-	pll_div_post = (test_bit_num == 8) ?
-					(test_dual_gate ? 4 : 8) :
-					(test_dual_gate ? 3 : 6);
-
-    phy_clk_div2 = (test_pair_num != 3);
-	
-	div_reg = (div_reg | (1 << 8) | (1 << 11) | ((pll_div_post-1) << 12) | (phy_clk_div2 << 10));
-	DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
-    vclk_set_lcd(lcd_type, vclk_sel, pll_reg, div_reg, clk_reg);
-	set_lcd_spread_spectrum(ss_level);
-	
-	clk_util_lvds_set_clk_div(1, pll_div_post, phy_clk_div2);
-	
-	//enable v2_clk div
-    // WRITE_LCD_CBUS_REG(HHI_VIID_CLK_CNTL, READ_LCD_CBUS_REG(HHI_VIID_CLK_CNTL) | (0xF << 0) );
-    // WRITE_LCD_CBUS_REG(HHI_VID_CLK_CNTL, READ_LCD_CBUS_REG(HHI_VID_CLK_CNTL) | (0xF << 0) );
-
-    WRITE_LCD_REG(LVDS_PHY_CNTL0, 0xffff );
-
-    //    lvds_gen_cntl       <= {10'h0,      // [15:4] unused
-    //                            2'h1,       // [5:4] divide by 7 in the PHY
-    //                            1'b0,       // [3] fifo_en
-    //                            1'b0,       // [2] wr_bist_gate
-    //                            2'b00};     // [1:0] fifo_wr mode
-
-    FIFO_CLK_SEL = (test_bit_num == 8) ? 2 : // div8
-                                    0 ; // div6
-    rd_data = READ_LCD_REG(LVDS_GEN_CNTL);
-    rd_data = (rd_data & 0xffcf) | (FIFO_CLK_SEL<< 4);
-    WRITE_LCD_REG(LVDS_GEN_CNTL, rd_data);
-
-    MPCLK_DELAY = (test_pair_num == 6) ?
-                  ((test_bit_num == 8) ? (test_dual_gate ? 5 : 3) : 2) :
-                  ((test_bit_num == 8) ? 3 : 3) ;
-
-	MCLK_half_delay = pConf->lcd_control.mlvds_config->phase_select ? MCLK_half :
-																			(test_dual_gate & (test_bit_num == 8) & (test_pair_num != 6));
-
-    if(test_high_phase)
-    {
-        if(test_dual_gate)
-        data32 = (MPCLK_DELAY << mpclk_dly) |
-                 (((test_bit_num == 8) ? 3 : 2) << mpclk_div) |
-                 (1 << use_mpclk) |
-                 (MCLK_half_delay << mlvds_clk_half_delay) |
-                 (((test_bit_num == 8) ? (
-                                           (test_pair_num == 6) ? 0x999999 : // DIV4
-                                                                  0x555555   // DIV2
-                                         ) :
-                                         (
-                                           (test_pair_num == 6) ? mclk_pattern_dual_6_6 : //DIV8
-                                                                  0x999999   // DIV4
-                                         )
-                 ) << mlvds_clk_pattern);
-        else if(test_bit_num == 8)
-            data32 = (MPCLK_DELAY << mpclk_dly) |
-                     (((test_bit_num == 8) ? 3 : 2) << mpclk_div) |
-                     (1 << use_mpclk) |
-                     (0 << mlvds_clk_half_delay) |
-                     (0xc3c3c3 << mlvds_clk_pattern);      // DIV 8
-        else
-            data32 = (MPCLK_DELAY << mpclk_dly) |
-                     (((test_bit_num == 8) ? 3 : 2) << mpclk_div) |
-                     (1 << use_mpclk) |
-                     (0 << mlvds_clk_half_delay) |
-                     (
-                       (
-                         (test_pair_num == 6) ? 0xc3c3c3 : // DIV8
-                                                0x999999   // DIV4
-                       ) << mlvds_clk_pattern
-                     );
-    }
-    else {
-        if(test_pair_num == 6) {
-            data32 = (MPCLK_DELAY << mpclk_dly) |
-                     (((test_bit_num == 8) ? 3 : 2) << mpclk_div) |
-                     (1 << use_mpclk) |
-                     (0 << mlvds_clk_half_delay) |
-                     (
-                       (
-                         (test_pair_num == 6) ? 0x999999 : // DIV4
-                                                0x555555   // DIV2
-                       ) << mlvds_clk_pattern
-                     );
-        }
-        else {
-            data32 = (1 << mlvds_clk_half_delay) |
-                   (0x555555 << mlvds_clk_pattern);      // DIV 2
-        }
-    }
-
-    WRITE_LCD_REG(MLVDS_CLK_CTL_HI, (data32 >> 16));
-    WRITE_LCD_REG(MLVDS_CLK_CTL_LO, (data32 & 0xffff));
-
-	//pll2_div_sel
-	// Set Soft Reset vid_pll_div_pre
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 3, 1);
-	// Set Hard Reset vid_pll_div_post
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 1, 1);
-	// Set Hard Reset lvds_phy_ser_top
-	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 0, 15, 1);
-	// Release Hard Reset lvds_phy_ser_top
-	WRITE_LCD_REG_BITS(LVDS_PHY_CLK_CNTL, 1, 15, 1);
-	// Release Hard Reset vid_pll_div_post
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 1, 1, 1);
-	// Release Soft Reset vid_pll_div_pre
-	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 3, 1);
-}
-#endif
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static void set_venc_ttl(Lcd_Config_t *pConf)
-{
-    DBG_PRINT("%s\n", __FUNCTION__);
-	WRITE_LCD_REG(ENCT_VIDEO_EN,		0);
-#ifdef CONFIG_AM_TV_OUTPUT2
-    if(vpp2_sel)
-        WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 3, 2, 2);
-    else
-		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0x44, 4, 8);//Select encT clock to VDIN, Enable VIU of ENC_T domain to VDIN
-		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 3, 0, 2);//viu1 select enct
-#else
-	WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0xf, 0, 4);	// viu1 & viu2 select enct
-#endif
-    WRITE_LCD_REG(ENCT_VIDEO_MODE,        0);
-    WRITE_LCD_REG(ENCT_VIDEO_MODE_ADV,    0x0008);
-	  
-	// bypass filter
-    WRITE_LCD_REG(ENCT_VIDEO_FILT_CTRL,    0x1000);
-
-    WRITE_LCD_REG(ENCT_VIDEO_MAX_PXCNT,    pConf->lcd_basic.h_period - 1);
-    WRITE_LCD_REG(ENCT_VIDEO_MAX_LNCNT,    pConf->lcd_basic.v_period - 1);
-
-    WRITE_LCD_REG(ENCT_VIDEO_HAVON_BEGIN,  pConf->lcd_timing.video_on_pixel);
-    WRITE_LCD_REG(ENCT_VIDEO_HAVON_END,    pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
-    WRITE_LCD_REG(ENCT_VIDEO_VAVON_BLINE,  pConf->lcd_timing.video_on_line);
-    WRITE_LCD_REG(ENCT_VIDEO_VAVON_ELINE,  pConf->lcd_basic.v_active - 1  + pConf->lcd_timing.video_on_line);
-
-    WRITE_LCD_REG(ENCT_VIDEO_HSO_BEGIN,    15);
-    WRITE_LCD_REG(ENCT_VIDEO_HSO_END,      31);
-    WRITE_LCD_REG(ENCT_VIDEO_VSO_BEGIN,    15);
-    WRITE_LCD_REG(ENCT_VIDEO_VSO_END,      31);
-    WRITE_LCD_REG(ENCT_VIDEO_VSO_BLINE,    0);
-    WRITE_LCD_REG(ENCT_VIDEO_VSO_ELINE,    2);
-    
-	WRITE_LCD_REG(ENCT_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
-    // enable enct
-    WRITE_LCD_REG(ENCT_VIDEO_EN,           1);
-}
-
-static void set_venc_mlvds(Lcd_Config_t *pConf)
-{
-    int ext_pixel = pConf->lcd_control.mlvds_config->test_dual_gate ? pConf->lcd_control.mlvds_config->total_line_clk : 0;
-	int active_h_start = pConf->lcd_timing.video_on_pixel;
-	int active_v_start = pConf->lcd_timing.video_on_line;
-	int width = pConf->lcd_basic.h_active;
-	int height = pConf->lcd_basic.v_active;
-	int max_height = pConf->lcd_basic.v_period;
-	
-	DBG_PRINT("%s\n", __FUNCTION__);
-
-    WRITE_LCD_REG(ENCL_VIDEO_EN,           0);
-
-#ifdef CONFIG_AM_TV_OUTPUT2
-    if(vpp2_sel){
-        WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2, 2);	//viu2 select encl
-    }
-    else{
-		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);//viu1 select encl
-    }
-#else
-	WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 4);	// viu1 & viu2 select encl
-#endif	
-
-	WRITE_LCD_REG(ENCL_VIDEO_MODE,             0x0040 | (1<<14)); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
-	WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV,         0x0008); // Sampling rate: 1
-	
-	// bypass filter
- 	WRITE_LCD_REG(ENCL_VIDEO_FILT_CTRL,			0x1000);
-	
-	WRITE_LCD_REG(ENCL_VIDEO_YFP1_HTIME,       active_h_start);
-	WRITE_LCD_REG(ENCL_VIDEO_YFP2_HTIME,       active_h_start + width);
-
-	WRITE_LCD_REG(ENCL_VIDEO_MAX_PXCNT,        pConf->lcd_control.mlvds_config->total_line_clk - 1 + ext_pixel);
-	WRITE_LCD_REG(ENCL_VIDEO_MAX_LNCNT,        max_height - 1);
-
-	WRITE_LCD_REG(ENCL_VIDEO_HAVON_BEGIN,      active_h_start);
-	WRITE_LCD_REG(ENCL_VIDEO_HAVON_END,        active_h_start + width - 1);  // for dual_gate mode still read 1408 pixel at first half of line
-	WRITE_LCD_REG(ENCL_VIDEO_VAVON_BLINE,      active_v_start);
-	WRITE_LCD_REG(ENCL_VIDEO_VAVON_ELINE,      active_v_start + height -1);  //15+768-1);
-
-	WRITE_LCD_REG(ENCL_VIDEO_HSO_BEGIN,        24);
-	WRITE_LCD_REG(ENCL_VIDEO_HSO_END,          1420 + ext_pixel);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_BEGIN,        1400 + ext_pixel);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_END,          1410 + ext_pixel);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE,        1);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,        3);
-
-	WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
-
-	// enable encl
-    WRITE_LCD_REG(ENCL_VIDEO_EN,		1);
-}
-#endif
-
-static void set_venc_lcd(Lcd_Config_t *pConf)
-{
-	int lcd_type;
-	lcd_type = pConf->lcd_basic.lcd_type;
-	
-	DBG_PRINT("%s\n",__FUNCTION__);
-
-	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
-#ifdef CONFIG_AM_TV_OUTPUT2
-	if	(vpp2_sel) {
-		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2, 2);	//viu2 select encl
-		WRITE_LCD_REG(VPU_VIU_VENC_MUX_CTRL, (READ_LCD_REG(VPU_VIU_VENC_MUX_CTRL)&(~(0x3<<2)))|(0x0<<2)); //viu2 select encl
-	}
-	else {
-		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0x88, 4, 8);//Select encl clock to VDIN, Enable VIU of ENC_l domain to VDIN
-		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);//viu1 select encl
-	}
-#else
-	WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 4);	// viu1 & viu2 select encl
-#endif
-	
-	WRITE_LCD_REG(ENCL_VIDEO_MODE,			0);
-	WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV,		0x0008);	// Sampling rate: 1
-
- 	WRITE_LCD_REG(ENCL_VIDEO_FILT_CTRL,		0x1000);	// bypass filter
-
-	WRITE_LCD_REG(ENCL_VIDEO_MAX_PXCNT,		pConf->lcd_basic.h_period - 1);
-	WRITE_LCD_REG(ENCL_VIDEO_MAX_LNCNT,		pConf->lcd_basic.v_period - 1);
-
-	WRITE_LCD_REG(ENCL_VIDEO_HAVON_BEGIN,	pConf->lcd_timing.video_on_pixel);
-	WRITE_LCD_REG(ENCL_VIDEO_HAVON_END,		pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
-	WRITE_LCD_REG(ENCL_VIDEO_VAVON_BLINE,	pConf->lcd_timing.video_on_line);
-	WRITE_LCD_REG(ENCL_VIDEO_VAVON_ELINE,	pConf->lcd_basic.v_active - 1  + pConf->lcd_timing.video_on_line);
-
-	WRITE_LCD_REG(ENCL_VIDEO_HSO_BEGIN,		pConf->lcd_timing.sth1_hs_addr);
-	WRITE_LCD_REG(ENCL_VIDEO_HSO_END,		pConf->lcd_timing.sth1_he_addr);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_BEGIN,		pConf->lcd_timing.stv1_hs_addr);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_END,		pConf->lcd_timing.stv1_he_addr);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE,		pConf->lcd_timing.stv1_vs_addr);
-	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,		pConf->lcd_timing.stv1_ve_addr);
-
-	WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL, 	(1 << 0));//(1 << 1) | (1 << 0));	//bit[0] 1:RGB, 0:YUV
-
-	WRITE_LCD_REG(ENCL_VIDEO_EN,			1);	// enable encl
-}
-
-static void set_control_lvds(Lcd_Config_t *pConf)
-{
-	unsigned lvds_repack, pn_swap, bit_num;
-	unsigned data32;
-	
-	DBG_PRINT("%s\n", __FUNCTION__);
-
-	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1); // disable lvds fifo
-	
-    data32 = (0x00 << LVDS_blank_data_r) |
-             (0x00 << LVDS_blank_data_g) |
-             (0x00 << LVDS_blank_data_b) ; 
-    WRITE_LCD_REG(LVDS_BLANK_DATA_HI, (data32 >> 16));
-    WRITE_LCD_REG(LVDS_BLANK_DATA_LO, (data32 & 0xffff));
-	
-	lvds_repack = (pConf->lcd_control.lvds_config->lvds_repack) & 0x1;
-	pn_swap = (pConf->lcd_control.lvds_config->pn_swap) & 0x1;
-
-	switch(pConf->lcd_basic.lcd_bits) {
-		case 10:
-			bit_num=0;
-			break;
-		case 8:
-			bit_num=1;
-			break;
-		case 6:
-			bit_num=2;
-			break;
-		case 4:
-			bit_num=3;
-			break;
-		default:
-			bit_num=1;
-			break;
-	}
-	
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	WRITE_LCD_REG_BITS(MLVDS_CONTROL, 0, 0, 1);  //disable mlvds
-#endif
-
-	WRITE_LCD_REG(LVDS_PACK_CNTL_ADDR, 
-					( lvds_repack<<0 ) | // repack
-					( 0<<2 ) | // odd_even
-					( 0<<3 ) | // reserve
-					( 0<<4 ) | // lsb first
-					( pn_swap<<5 ) | // pn swap
-					( 0<<6 ) | // dual port
-					( 0<<7 ) | // use tcon control
-					( bit_num<<8 ) | // 0:10bits, 1:8bits, 2:6bits, 3:4bits.
-					( 0<<10 ) | //r_select  //0:R, 1:G, 2:B, 3:0
-					( 1<<12 ) | //g_select  //0:R, 1:G, 2:B, 3:0
-					( 2<<14 ));  //b_select  //0:R, 1:G, 2:B, 3:0; 
-				   
-    WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 0, 1);  //fifo enable
-	//WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1);  //enable fifo
-}
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static void set_control_mipi(Lcd_Config_t *pConf)
-{
-    set_mipi_dsi_control(pConf);
-}
-#endif
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-//**************************************************//
-// for edp link maintain control
-//**************************************************//
-static void generate_clk_parameter(Lcd_Config_t *pConf);
-static void lcd_sync_duration(Lcd_Config_t *pConf);
-unsigned edp_clk_config_update(unsigned char link_rate)
-{
-	unsigned bit_rate;
-	
-	switch (link_rate) {
-		case VAL_EDP_TX_LINK_BW_SET_162:
-			pDev->pConf->lcd_control.edp_config->link_rate = 0;
-			break;
-		case VAL_EDP_TX_LINK_BW_SET_270:
-		default:
-			pDev->pConf->lcd_control.edp_config->link_rate = 1;
-			break;
-	}
-	generate_clk_parameter(pDev->pConf);
-	lcd_sync_duration(pDev->pConf);
-	
-	bit_rate = (pDev->pConf->lcd_timing.lcd_clk / 1000) * pDev->pConf->lcd_basic.lcd_bits * 3 / 1000;	//Mbps
-	pDev->pConf->lcd_control.edp_config->bit_rate = bit_rate;
-	
-	//update lcd_info
-	pDev->lcd_info.sync_duration_num = pDev->pConf->lcd_timing.sync_duration_num;
-	pDev->lcd_info.sync_duration_den = pDev->pConf->lcd_timing.sync_duration_den;
-	pDev->lcd_info.video_clk = pDev->pConf->lcd_timing.lcd_clk;
-	
-	request_vpu_clk_vmod(pDev->lcd_info.video_clk, pDev->lcd_info.mode);
-	
-	set_pll_lcd(pDev->pConf);	//real change the clk
-	
-	return bit_rate;
-}
-
-void edp_phy_config_update(unsigned char vswing_tx, unsigned char preemp_tx)
-{
-    unsigned vswing_ctrl, preemphasis_ctrl;
-
-    switch (vswing_tx) {
-        case 0:	//0.4V
-            vswing_ctrl = 0x8018;	//0x8038;
-            break;
-        case 1:	//0.6V
-            vswing_ctrl = 0x8088;
-            break;
-        case 2:	//0.8V
-            vswing_ctrl = 0x80c8;
-            break;
-        case 3:	//1.2V
-            vswing_ctrl = 0x80f8;
-            break;
-        default:
-            vswing_ctrl = 0x80f8;
-            break;
-    }
-
-    switch (preemp_tx) {
-        case 0:	//0db
-        case 1:	//3.5db
-        case 2:	//6db
-        case 3:	//9.5db
-        default:
-            preemphasis_ctrl = 0x0;	//to do
-            break;
-    }
-
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, vswing_ctrl);
-    printk("edp link adaptive: vswing=0x%02x, preemphasis=0x%02x\n", vswing_tx, preemp_tx);
-}
-//**************************************************//
-
-static int set_control_edp(Lcd_Config_t *pConf)
-{
-    int ret = 0;
-    EDP_Video_Mode_t  vm;
-    EDP_Link_Config_t link_config;
-
-    DBG_PRINT("%s\n", __FUNCTION__);
-    //edp link config
-    link_config.max_lane_count = 4;
-    link_config.max_link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-    //link_config.link_rate = pConf->lcd_control.edp_config->link_rate;
-    link_config.lane_count = pConf->lcd_control.edp_config->lane_count;
-    link_config.ss_level =((((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_SS) & 0xf) > 0 ? 1 : 0);
-    link_config.link_adaptive = pConf->lcd_control.edp_config->link_adaptive;
-    //link_config.vswing = pConf->lcd_control.edp_config->vswing;
-    //link_config.preemphasis = pConf->lcd_control.edp_config->preemphasis;
-    link_config.bit_rate = pConf->lcd_control.edp_config->bit_rate;
-
-    switch (pConf->lcd_control.edp_config->link_rate) {
-        case 0:
-            link_config.link_rate = VAL_EDP_TX_LINK_BW_SET_162;
-            break;
-        case 1:
-            link_config.link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-            break;
-        default:
-            link_config.link_rate = VAL_EDP_TX_LINK_BW_SET_270;
-            break;
-    }
-    switch (pConf->lcd_control.edp_config->vswing) {
-        case 0:
-            link_config.vswing = VAL_EDP_TX_PHY_VSWING_0;
-            break;
-        case 1:
-            link_config.vswing = VAL_EDP_TX_PHY_VSWING_1;
-            break;
-        case 2:
-            link_config.vswing = VAL_EDP_TX_PHY_VSWING_2;
-            break;
-        case 3:
-            link_config.vswing = VAL_EDP_TX_PHY_VSWING_3;
-            break;
-        default:
-            link_config.vswing = VAL_EDP_TX_PHY_VSWING_0;
-            break;
-    }
-    switch (pConf->lcd_control.edp_config->preemphasis) {
-        case 0:
-            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_0;
-            break;
-        case 1:
-            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_1;
-            break;
-        case 2:
-            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_2;
-            break;
-        case 3:
-            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_3;
-            break;
-        default:
-            link_config.preemphasis = VAL_EDP_TX_PHY_PREEMPHASIS_0;
-            break;
-    }
-
-    //edp main stream attribute
-    vm.h_active = pConf->lcd_basic.h_active;
-    vm.v_active = pConf->lcd_basic.v_active;
-    vm.h_period = pConf->lcd_basic.h_period;
-    vm.v_period = pConf->lcd_basic.v_period;
-    vm.clk = pConf->lcd_timing.lcd_clk;
-    vm.hsync_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1;
-    vm.hsync_width = pConf->lcd_timing.hsync_width;
-    vm.hsync_bp = pConf->lcd_timing.hsync_bp;
-    vm.vsync_pol = (pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1;
-    vm.vsync_width = pConf->lcd_timing.vsync_width;
-    vm.vsync_bp = pConf->lcd_timing.vsync_bp;
-    vm.de_hstart = pConf->lcd_timing.de_hstart;
-    vm.de_vstart = pConf->lcd_timing.de_vstart;
-    vm.ppc = 1;							//pixels per clock cycle
-    vm.cformat = 0;						//color format(0=RGB, 1=4:2:2, 2=Y only)
-    vm.bpc = pConf->lcd_basic.lcd_bits;	//bits per color
-
-    //edp link maintain
-    ret = dplpm_link_policy_maker(&link_config, &vm);
-
-    //save feedback config by edp link maintain
-    //pConf->lcd_control.edp_config->link_rate = link_config.link_rate;
-    pConf->lcd_control.edp_config->lane_count = link_config.lane_count;
-    //pConf->lcd_control.edp_config->vswing = link_config.vswing;
-    //pConf->lcd_control.edp_config->preemphasis = link_config.preemphasis;
-    pConf->lcd_control.edp_config->bit_rate = link_config.bit_rate;
-    switch (link_config.link_rate) {
-        case VAL_EDP_TX_LINK_BW_SET_162:
-            pConf->lcd_control.edp_config->link_rate = 0;
-            break;
-        case VAL_EDP_TX_LINK_BW_SET_270:
-            pConf->lcd_control.edp_config->link_rate = 1;
-            break;
-        default:
-            pConf->lcd_control.edp_config->link_rate = 1;
-            break; 
-    }
-    switch (link_config.vswing) {
-        case VAL_EDP_TX_PHY_VSWING_0:
-            pConf->lcd_control.edp_config->vswing = 0;
-            break;
-        case VAL_EDP_TX_PHY_VSWING_1:
-            pConf->lcd_control.edp_config->vswing = 1;
-            break;
-        case VAL_EDP_TX_PHY_VSWING_2:
-            pConf->lcd_control.edp_config->vswing = 2;
-            break;
-        case VAL_EDP_TX_PHY_VSWING_3:
-            pConf->lcd_control.edp_config->vswing = 3;
-            break;
-        default:
-            pConf->lcd_control.edp_config->vswing = 0;
-            break;
-    }
-    switch (link_config.preemphasis) {
-        case VAL_EDP_TX_PHY_PREEMPHASIS_0:
-            pConf->lcd_control.edp_config->preemphasis = 0;
-            break;
-        case VAL_EDP_TX_PHY_PREEMPHASIS_1:
-            pConf->lcd_control.edp_config->preemphasis = 1;
-            break;
-        case VAL_EDP_TX_PHY_PREEMPHASIS_2:
-            pConf->lcd_control.edp_config->preemphasis = 2;
-            break;
-        case VAL_EDP_TX_PHY_PREEMPHASIS_3:
-            pConf->lcd_control.edp_config->preemphasis = 3;
-            break;
-        default:
-            pConf->lcd_control.edp_config->preemphasis = 0;
-            break;
-    }
-
-    return ret;
-}
-#endif
-
-static void set_control_ttl(Lcd_Config_t *pConf)
-{
-	unsigned rb_port_swap, rgb_bit_swap;
-	
-	rb_port_swap = (unsigned)(pConf->lcd_control.ttl_config->rb_swap);
-	rgb_bit_swap = (unsigned)(pConf->lcd_control.ttl_config->bit_swap);
-	
-	WRITE_LCD_REG(L_DUAL_PORT_CNTL_ADDR, (rb_port_swap << LCD_RGB_SWP) | (rgb_bit_swap << LCD_BIT_SWP));
-}
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static void set_control_mlvds(Lcd_Config_t *pConf)
-{
-	int test_bit_num = pConf->lcd_basic.lcd_bits;
-    int test_pair_num = pConf->lcd_control.mlvds_config->test_pair_num;
-    int test_dual_gate = pConf->lcd_control.mlvds_config->test_dual_gate;
-    int scan_function = pConf->lcd_control.mlvds_config->scan_function;     //0:U->D,L->R  //1:D->U,R->L
-    int mlvds_insert_start;
-    unsigned int reset_offset;
-    unsigned int reset_length;
-
-    unsigned long data32;
-	
-	DBG_PRINT("%s\n", __FUNCTION__);
-    
-    mlvds_insert_start = test_dual_gate ?
-                           ((test_bit_num == 8) ? ((test_pair_num == 6) ? 0x9f : 0xa9) :
-                                                  ((test_pair_num == 6) ? pConf->lcd_control.mlvds_config->mlvds_insert_start : 0xa7)
-                           ) :
-                           (
-                             (test_pair_num == 6) ? ((test_bit_num == 8) ? 0xa9 : 0xa7) :
-                                                    ((test_bit_num == 8) ? 0xae : 0xad)
-                           );
-
-    // Enable the LVDS PHY (power down bits)
-	WRITE_LCD_REG_BITS(LVDS_PHY_CNTL1, 0x7f, 8, 7);
-
-    data32 = (0x00 << LVDS_blank_data_r) |
-             (0x00 << LVDS_blank_data_g) |
-             (0x00 << LVDS_blank_data_b) ;
-    WRITE_LCD_REG(LVDS_BLANK_DATA_HI,  (data32 >> 16));
-    WRITE_LCD_REG(LVDS_BLANK_DATA_LO, (data32 & 0xffff));
-
-    data32 = 0x7fffffff; //  '0'x1 + '1'x32 + '0'x2
-    WRITE_LCD_REG(MLVDS_RESET_PATTERN_HI,  (data32 >> 16));
-    WRITE_LCD_REG(MLVDS_RESET_PATTERN_LO, (data32 & 0xffff));
-    data32 = 0x8000; // '0'x1 + '1'x32 + '0'x2
-    WRITE_LCD_REG(MLVDS_RESET_PATTERN_EXT,  (data32 & 0xffff));
-
-    reset_length = 1+32+2;
-    reset_offset = test_bit_num - (reset_length%test_bit_num);
-
-    data32 = (reset_offset << mLVDS_reset_offset) |
-             (reset_length << mLVDS_reset_length) |
-             ((test_pair_num == 6) << mLVDS_data_write_toggle) |
-             ((test_pair_num != 6) << mLVDS_data_write_ini) |
-             ((test_pair_num == 6) << mLVDS_data_latch_1_toggle) |
-             (0 << mLVDS_data_latch_1_ini) |
-             ((test_pair_num == 6) << mLVDS_data_latch_0_toggle) |
-             (1 << mLVDS_data_latch_0_ini) |
-             ((test_pair_num == 6) << mLVDS_reset_1_select) |
-             (mlvds_insert_start << mLVDS_reset_start);
-    WRITE_LCD_REG(MLVDS_CONFIG_HI, (data32 >> 16));
-    WRITE_LCD_REG(MLVDS_CONFIG_LO, (data32 & 0xffff));
-
-    data32 = (1 << mLVDS_double_pattern) |  //POL double pattern
-			 (0x3f << mLVDS_ins_reset) |
-             (test_dual_gate << mLVDS_dual_gate) |
-             ((test_bit_num == 8) << mLVDS_bit_num) |
-             ((test_pair_num == 6) << mLVDS_pair_num) |
-             (0 << mLVDS_msb_first) |
-             (0 << mLVDS_PORT_SWAP) |
-             ((scan_function==1 ? 1:0) << mLVDS_MLSB_SWAP) |
-             (0 << mLVDS_PN_SWAP) |
-             (1 << mLVDS_en);
-    WRITE_LCD_REG(MLVDS_CONTROL,  (data32 & 0xffff));
-
-    WRITE_LCD_REG(LVDS_PACK_CNTL_ADDR,
-                   ( 0 ) | // repack
-                   ( 0<<2 ) | // odd_even
-                   ( 0<<3 ) | // reserve
-                   ( 0<<4 ) | // lsb first
-                   ( 0<<5 ) | // pn swap
-                   ( 0<<6 ) | // dual port
-                   ( 0<<7 ) | // use tcon control
-                   ( 1<<8 ) | // 0:10bits, 1:8bits, 2:6bits, 3:4bits.
-                   ( (scan_function==1 ? 2:0)<<10 ) |  //r_select // 0:R, 1:G, 2:B, 3:0
-                   ( 1<<12 ) |                        //g_select
-                   ( (scan_function==1 ? 0:2)<<14 ));  //b_select
-
-    WRITE_LCD_REG(L_POL_CNTL_ADDR,  (1 << LCD_DCLK_SEL) |
-       //(0x1 << LCD_HS_POL) |
-       (0x1 << LCD_VS_POL)
-    );
-	
-	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1); // enable fifo
-}
-#endif
-
-static void init_phy_lvds(Lcd_Config_t *pConf)
-{
-    unsigned swing_ctrl;
-    DBG_PRINT("%s\n", __FUNCTION__);
-	
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-    WRITE_LCD_REG(LVDS_PHY_CNTL3, 0xee1);
-    WRITE_LCD_REG(LVDS_PHY_CNTL4 ,0);
-
-	switch (pConf->lcd_control.lvds_config->lvds_vswing) {
-		case 0:
-			swing_ctrl = 0xaf20;
-			break;
-		case 1:
-			swing_ctrl = 0xaf40;
-			break;
-		case 2:
-			swing_ctrl = 0xa840;
-			break;
-		case 3:
-			swing_ctrl = 0xa880;
-			break;
-		case 4:
-			swing_ctrl = 0xa8c0;
-			break;
-		default:
-			swing_ctrl = 0xaf40;
-			break;
-	}
-	WRITE_LCD_REG(LVDS_PHY_CNTL5, swing_ctrl);
-
-	WRITE_LCD_REG(LVDS_PHY_CNTL0,0x001f);
-	WRITE_LCD_REG(LVDS_PHY_CNTL1,0xffff);
-
-    WRITE_LCD_REG(LVDS_PHY_CNTL6,0xcccc);
-    WRITE_LCD_REG(LVDS_PHY_CNTL7,0xcccc);
-    WRITE_LCD_REG(LVDS_PHY_CNTL8,0xcccc);
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	WRITE_LCD_REG(LVDS_SER_EN, 0xfff);	//Enable the serializers
-
-    WRITE_LCD_REG(LVDS_PHY_CNTL0, 0xffff);
-    WRITE_LCD_REG(LVDS_PHY_CNTL1, 0xff00);
-	WRITE_LCD_REG(LVDS_PHY_CNTL4, 0x007f);
-	
-	//WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x00000348);
-	switch (pConf->lcd_control.lvds_config->lvds_vswing) {
-		case 0:
-			swing_ctrl = 0x028;
-			break;
-		case 1:
-			swing_ctrl = 0x048;
-			break;
-		case 2:
-			swing_ctrl = 0x088;
-			break;
-		case 3:
-			swing_ctrl = 0x0c8;
-			break;
-		case 4:
-			swing_ctrl = 0x0f8;
-			break;
-		default:
-			swing_ctrl = 0x048;
-			break;
-	}
-	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, swing_ctrl);
-	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x000665b7);
-	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x84070000);
-#endif
-}
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static void init_phy_mipi(Lcd_Config_t *pConf)
-{
-    DBG_PRINT("%s\n", __FUNCTION__);
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-    WRITE_LCD_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 1, 4, 1);//swap mipi channels, only for m8baby
-#endif
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x8);//DIF_REF_CTL0
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, (0x3e << 16) | (0xa5b8 << 0));//DIF_REF_CTL2:31-16bit, DIF_REF_CTL1:15-0bit
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, (0x26e0 << 16) | (0x459 << 0));//DIF_TX_CTL1:31-16bit, DIF_TX_CTL0:15-0bit
-}
-#endif
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static void init_phy_edp(Lcd_Config_t *pConf)
-{
-    unsigned swing_ctrl;
-    DBG_PRINT("%s\n", __FUNCTION__);
-
-    switch (pConf->lcd_control.edp_config->vswing) {
-        case 0:	//0.4V
-            swing_ctrl = 0x8018;
-            break;
-        case 1:	//0.6V
-            swing_ctrl = 0x8088;
-            break;
-        case 2:	//0.8V
-            swing_ctrl = 0x80c8;
-            break;
-        case 3:	//1.2V
-            swing_ctrl = 0x80f8;
-            break;
-        default:
-            swing_ctrl = 0x8018;
-            break;
-    }
-
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, swing_ctrl);//[7:4]swing b:800mv, step 50mv
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, ((0x6 << 16) | (0xf5d7 << 0)));
-    WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, ((0xc2b2 << 16) | (0x600 << 0)));//0xd2b0fe00);
-}
-#endif
-
-static void init_dphy(Lcd_Config_t *pConf)
-{
-	unsigned lcd_type = (unsigned)(pConf->lcd_basic.lcd_type);
-
-	switch (lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		case LCD_DIGITAL_MIPI:
-			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
-			init_phy_mipi(pConf);
-			break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		case LCD_DIGITAL_EDP:
-			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
-			init_phy_edp(pConf);
-			break;
-#endif
-		case LCD_DIGITAL_LVDS:
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-			WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);	//dphy select by interface
-#endif
-			init_phy_lvds(pConf);
-			break;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
-			init_phy_lvds(pConf);
-			break;
-#endif
-		default:
-			break;
-	}
-}
-
-static void set_video_adjust(Lcd_Config_t *pConf)
-{
-	DBG_PRINT("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x.\n", pConf->lcd_effect.vadj_brightness, pConf->lcd_effect.vadj_contrast, pConf->lcd_effect.vadj_saturation);
-	WRITE_LCD_REG(VPP_VADJ2_Y, (pConf->lcd_effect.vadj_brightness << 8) | (pConf->lcd_effect.vadj_contrast << 0));
-	WRITE_LCD_REG(VPP_VADJ2_MA_MB, (pConf->lcd_effect.vadj_saturation << 16));
-	WRITE_LCD_REG(VPP_VADJ2_MC_MD, (pConf->lcd_effect.vadj_saturation << 0));
-	WRITE_LCD_REG(VPP_VADJ_CTRL, 0xf);	//enable video adjust
-}
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static unsigned error_abs(unsigned num1, unsigned num2)
-{
-	if (num1 >= num2)
-		return num1 - num2;
-	else
-		return num2 - num1;
-}
-#endif
-
-static void generate_clk_parameter(Lcd_Config_t *pConf)
-{
-    unsigned pll_n = 0, pll_m = 0, pll_od = 0, pll_frac = 0, pll_level = 0;
-    unsigned edp_phy_div0 = 0, edp_phy_div1 = 0, vid_div_pre = 0;
-    unsigned crt_xd = 0;
-
-    unsigned m, n, od, div_pre, div_post, xd;
-    unsigned od_sel, pre_div_sel;
-    unsigned div_pre_sel_max, crt_xd_max;
-    unsigned f_ref, pll_vco, fout_pll, div_pre_out, div_post_out, final_freq, iflogic_vid_clk_in_max;
-    unsigned min_error = MAX_ERROR;
-    unsigned error = MAX_ERROR;
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-    unsigned od_fb=0;
-    unsigned int dsi_bit_rate_min=0, dsi_bit_rate_max=0;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-    unsigned edp_div0, edp_div1, edp_div0_sel, edp_div1_sel;
-    unsigned edp_tx_phy_out;
-#endif
-    unsigned clk_num = 0;
-    unsigned tmp;
-    unsigned fin = FIN_FREQ;
-    unsigned fout = pConf->lcd_timing.lcd_clk;
-
-    if (fout >= 200) {//clk
-        fout = fout / 1000;  //kHz
-    }
-    else {//frame_rate
-        fout = (fout * pConf->lcd_basic.h_period * pConf->lcd_basic.v_period) / 1000;	//kHz
-    }
-
-    switch (pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_MIPI:
-            div_pre_sel_max = DIV_PRE_SEL_MAX;
-            div_post = 1;
-            crt_xd_max = 16;
-            dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
-            dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
-            iflogic_vid_clk_in_max = MIPI_MAX_VID_CLK_IN;
-            break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_EDP:
-            div_pre_sel_max = 1;
-            div_post = 1;
-            crt_xd_max = 1;
-            iflogic_vid_clk_in_max = EDP_MAX_VID_CLK_IN;
-            min_error = 30 * 1000;
-            break;
-#endif
-        case LCD_DIGITAL_LVDS:
-            div_pre_sel_max = DIV_PRE_SEL_MAX;
-            div_post = 7;
-            crt_xd_max = 1;
-            iflogic_vid_clk_in_max = LVDS_MAX_VID_CLK_IN;
-            break;
-        case LCD_DIGITAL_TTL:
-            div_pre_sel_max = DIV_PRE_SEL_MAX;
-            div_post = 1;
-            crt_xd_max = CRT_VID_DIV_MAX;
-            iflogic_vid_clk_in_max = TTL_MAX_VID_CLK_IN;
-            break;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-        case LCD_DIGITAL_MINILVDS:
-            div_pre_sel_max = DIV_PRE_SEL_MAX;
-            div_post = 6;
-            crt_xd_max = 1;
-            iflogic_vid_clk_in_max = MLVDS_MAX_VID_CLK_IN;
-            break;
-#endif
-        default:
-            div_pre_sel_max = DIV_PRE_SEL_MAX;
-            div_post = 1;
-            crt_xd_max = 1;
-            iflogic_vid_clk_in_max = LCD_VENC_MAX_CLK_IN;
-            break;
-    }
-
-    switch (pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_MIPI:
-            if (fout < LCD_VENC_MAX_CLK_IN) {
-                for (xd = 1; xd <= crt_xd_max; xd++) {
-                    div_post_out = fout * xd;
-                    DBG_PRINT("div_post_out=%d, xd=%d, fout=%d\n",div_post_out, xd, fout);
-                    if (div_post_out <= CRT_VID_MAX_CLK_IN) {
-                        div_pre_out = div_post_out * div_post;
-                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
-                            for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
-                                div_pre = div_pre_table[pre_div_sel];
-                                fout_pll = div_pre_out * div_pre;
-                                DBG_PRINT("pre_div_sel=%d, div_pre=%d, fout_pll=%d\n", pre_div_sel, div_pre, fout_pll);
-                                if ((fout_pll <= dsi_bit_rate_max) && (fout_pll >= dsi_bit_rate_min)){
-                                    for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
-                                        od = od_table[od_sel - 1];
-                                        pll_vco = fout_pll * od;
-                                        DBG_PRINT("od_sel=%d, od=%d, pll_vco=%d\n", od_sel, od, pll_vco);
-                                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
-                                            if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
-                                                od_fb = 1;
-                                                pll_level = 4;
-                                            }
-                                            else if ((pll_vco >= 2000000) && (pll_vco < 2500000)) {
-                                                od_fb = 1;
-                                                pll_level = 3;
-                                            }
-                                            else if ((pll_vco >= 1700000) && (pll_vco < 2000000)) {//special adjust
-                                                od_fb = 1;
-                                                pll_level = 2;
-                                            }
-                                            else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
-                                                od_fb = 0;
-                                                pll_level = 1;
-                                            }
-                                            n = 1;
-                                            m = pll_vco / (fin * (od_fb + 1));
-                                            pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
-                                            pll_m = m;
-                                            pll_n = n;
-                                            pll_od = od_sel - 1;
-                                            vid_div_pre = pre_div_sel;
-                                            crt_xd = xd;
-                                            clk_num = 1;
-                                            DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
-                                                       pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
-                                        }
-                                        if (clk_num > 0)
-                                            break;
-                                    }
-                                }
-                                if (clk_num > 0)
-                                    break;
-                            }
-                        }
-                    }
-                    if (clk_num > 0)
-                        break;
-                }
-            }
-            break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_EDP:
-            switch (pConf->lcd_control.edp_config->link_rate) {
-                case 0:
-                    n = 1;
-                    m = 67;
-                    od_sel = 0;
-                    pll_level = 1;
-                    pll_frac = 0x800;
-                    fout_pll = 1620000;
-                    break;
-                case 1:
-                default:
-                    n = 1;
-                    m = 56;
-                    od_sel = 0;
-                    pll_level = 4;
-                    pll_frac = 0x400;
-                    fout_pll = 2700000;
-                    break;
-            }
-            pll_m = m;
-            pll_n = n;
-            pll_od = od_sel;
-
-            for(edp_div1_sel=0; edp_div1_sel<EDP_DIV1_SEL_MAX; edp_div1_sel++) {
-                edp_div1 = edp_div1_table[edp_div1_sel];
-                for (edp_div0_sel=0; edp_div0_sel<EDP_DIV0_SEL_MAX; edp_div0_sel++) {
-                    edp_div0 = edp_div0_table[edp_div0_sel];
-                    edp_tx_phy_out = fout_pll / (edp_div0 * edp_div1);
-                    if (edp_tx_phy_out <= DIV_PRE_MAX_CLK_IN) {
-                        for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
-                            div_pre = div_pre_table[pre_div_sel];
-                            div_pre_out = edp_tx_phy_out / div_pre;
-                            if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
-                                div_post_out = div_pre_out / div_post;
-                                if (div_post_out <= CRT_VID_MAX_CLK_IN) {
-                                    for (xd = 1; xd <= crt_xd_max; xd++) {
-                                        final_freq = div_post_out / xd;
-                                        if (final_freq < LCD_VENC_MAX_CLK_IN) {
-                                            if (final_freq < iflogic_vid_clk_in_max) {
-                                                if (final_freq <= fout) {
-                                                    error = fout - final_freq;
-                                                    if (error < min_error) {
-                                                        min_error = error;
-                                                        edp_phy_div0 = edp_div0_sel;
-                                                        edp_phy_div1 = edp_div1_sel;
-                                                        vid_div_pre = pre_div_sel;
-                                                        crt_xd = xd;
-                                                        clk_num++;
-                                                    }
-                                                }
-                                            }
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-            break;
-#endif
-        case LCD_DIGITAL_LVDS:
-        case LCD_DIGITAL_TTL:
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-            for (n = PLL_N_MIN; n <= PLL_N_MAX; n++) {
-                f_ref = fin / n;
-                if ((f_ref >= PLL_FREF_MIN) && (f_ref <= PLL_FREF_MAX))    {
-                    for (m = PLL_M_MIN; m <= PLL_M_MAX; m++) {
-                        pll_vco = f_ref * m;
-                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
-                            for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
-                                od = od_table[od_sel - 1];
-                                fout_pll = pll_vco / od;
-                            if (fout_pll <= DIV_PRE_MAX_CLK_IN) {
-                                    for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
-                                        div_pre = div_pre_table[pre_div_sel];
-                                        div_pre_out = fout_pll / div_pre;
-                                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
-                                            div_post_out = div_pre_out / div_post;
-                                            if (div_post_out <= CRT_VID_MAX_CLK_IN) {
-                                                for (xd = 1; xd <= crt_xd_max; xd++) {
-                                                    final_freq = div_post_out / xd;
-                                                    if (final_freq < LCD_VENC_MAX_CLK_IN) {
-                                                        if (final_freq < iflogic_vid_clk_in_max) {
-                                                            error = error_abs(final_freq, fout);
-                                                            if (error < min_error) {
-                                                                min_error = error;
-                                                                pll_m = m;
-                                                                pll_n = n;
-                                                                pll_od = od_sel - 1;
-                                                                vid_div_pre = pre_div_sel;
-                                                                crt_xd = xd;
-                                                                clk_num++;
-                                                            }
-                                                        }
-                                                    }
-                                                }
-                                            }
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-            if (fout < LCD_VENC_MAX_CLK_IN) {
-                for (xd = 1; xd <= crt_xd_max; xd++) {
-                    div_post_out = fout * xd;
-                    DBG_PRINT("div_post_out=%d, xd=%d, fout=%d\n",div_post_out, xd, fout);
-                    if (div_post_out <= CRT_VID_MAX_CLK_IN) {
-                        div_pre_out = div_post_out * div_post;
-                        if (div_pre_out <= DIV_POST_MAX_CLK_IN) {
-                            for (pre_div_sel = 0; pre_div_sel < div_pre_sel_max; pre_div_sel++) {
-                                div_pre = div_pre_table[pre_div_sel];
-                                fout_pll = div_pre_out * div_pre;
-                                DBG_PRINT("pre_div_sel=%d, div_pre=%d, fout_pll=%d\n", pre_div_sel, div_pre, fout_pll);
-                                if (fout_pll <= DIV_PRE_MAX_CLK_IN) {
-                                    for (od_sel = OD_SEL_MAX; od_sel > 0; od_sel--) {
-                                        od = od_table[od_sel - 1];
-                                        pll_vco = fout_pll * od;
-                                        DBG_PRINT("od_sel=%d, od=%d, pll_vco=%d\n", od_sel, od, pll_vco);
-                                        if ((pll_vco >= PLL_VCO_MIN) && (pll_vco <= PLL_VCO_MAX)) {
-                                            if ((pll_vco >= 2500000) && (pll_vco <= PLL_VCO_MAX)) {
-                                                od_fb = 1;
-                                                pll_level = 4;
-                                            }
-                                            else if ((pll_vco >= 2000000) && (pll_vco < 2500000)) {
-                                                od_fb = 1;
-                                                pll_level = 3;
-                                            }
-                                            else if ((pll_vco >= 1700000) && (pll_vco < 2000000)) {
-                                                od_fb = 1;
-                                                pll_level = 2;
-                                            }
-                                            else if ((pll_vco >= PLL_VCO_MIN) && (pll_vco < 1700000)) {
-                                                od_fb = 0;
-                                                pll_level = 1;
-                                            }
-                                            n = 1;
-                                            m = pll_vco / (fin * (od_fb + 1));
-                                            pll_frac = (pll_vco % (fin * (od_fb + 1))) * 4096 / (fin * (od_fb + 1));
-
-                                            pll_m = m;
-                                            pll_n = n;
-                                            pll_od = od_sel - 1;
-                                            vid_div_pre = pre_div_sel;
-                                            crt_xd = xd;
-                                            DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
-                                                       pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
-                                            clk_num = 1;
-                                        }
-                                        if (clk_num > 0)
-                                            break;
-                                    }
-                                }
-                                if (clk_num > 0)
-                                    break;
-                            }
-                        }
-                    }
-                    if (clk_num > 0)
-                        break;
-                }
-            }
-#endif
-            break;
-        default:
-            break;
-    }
-    if (clk_num > 0) {
-        pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
-        pConf->lcd_timing.div_ctrl = 0x18803 | (edp_phy_div1 << DIV_CTRL_EDP_DIV1) | (edp_phy_div0 << DIV_CTRL_EDP_DIV0) | (vid_div_pre << DIV_CTRL_DIV_PRE);
-        tmp = (pConf->lcd_timing.clk_ctrl & ~((0xf << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
-        pConf->lcd_timing.clk_ctrl = (tmp | ((crt_xd << CLK_CTRL_XD) | (pll_level << CLK_CTRL_LEVEL) | (pll_frac << CLK_CTRL_FRAC)));
-    }
-    else {
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-        pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (32 << PLL_CTRL_M);
-        pConf->lcd_timing.div_ctrl = 0x18803;
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (50 << PLL_CTRL_M);
-        pConf->lcd_timing.div_ctrl = 0x18803 | (0 << DIV_CTRL_EDP_DIV1) | (0 << DIV_CTRL_EDP_DIV0) | (1 << DIV_CTRL_DIV_PRE);
-#endif
-        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
-        printk("Out of clock range, reset to default setting!\n");
-    }
-}
-
-static void lcd_sync_duration(Lcd_Config_t *pConf)
-{
-	unsigned m, n, od, od_fb, frac, edp_div0, edp_div1, pre_div, xd, post_div;
-	unsigned h_period, v_period, sync_duration;
-	unsigned lcd_clk;
-
-	m = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_M) & 0x1ff;
-	n = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_N) & 0x1f;
-	od = ((pConf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD) & 0x3;
-	od = od_table[od];
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	frac = 0;
-	od_fb = 0;
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	frac = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_FRAC) & 0xfff;
-	od_fb = ((((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_LEVEL) & 0x7) > 1) ? 1 : 0;
-
-#endif	
-	pre_div = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_DIV_PRE) & 0x7;
-	pre_div = div_pre_table[pre_div];
-	
-	h_period = pConf->lcd_basic.h_period;
-	v_period = pConf->lcd_basic.v_period;
-	
-	edp_div0 = 0;
-	edp_div1 = 0;
-	switch(pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		case LCD_DIGITAL_MIPI:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
-			post_div = 1;
-			break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		case LCD_DIGITAL_EDP:
-			edp_div0 = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_EDP_DIV0) & 0xf;
-			edp_div1 = ((pConf->lcd_timing.div_ctrl) >> DIV_CTRL_EDP_DIV1) & 0x7;
-			xd = 1;
-			post_div = 1;
-			break;
-#endif
-		case LCD_DIGITAL_LVDS:
-			xd = 1;
-			post_div = 7;
-			break;
-		case LCD_DIGITAL_TTL:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
-			post_div = 1;
-			break;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
-			xd = 1;
-			post_div = 6;
-			break;
-#endif
-		default:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
-			post_div = 1;
-			break;
-	}
-	edp_div0 = edp_div0_table[edp_div0];
-	edp_div1 = edp_div1_table[edp_div1];
-	
-	lcd_clk = (frac * (od_fb + 1) * FIN_FREQ) / 4096;
-	lcd_clk = ((m * (od_fb + 1) * FIN_FREQ + lcd_clk) / (n * od * edp_div0 * edp_div1 * pre_div * post_div * xd)) * 1000;
-	pConf->lcd_timing.lcd_clk = lcd_clk;
-	sync_duration = ((lcd_clk / h_period) * 100) / v_period;
-	sync_duration = (sync_duration + 5) / 10;
-	
-	pConf->lcd_timing.sync_duration_num = sync_duration;
-	pConf->lcd_timing.sync_duration_den = 10;
-	printk("lcd_clk=%u.%03uMHz, frame_rate=%u.%uHz.\n\n", (lcd_clk / 1000000), ((lcd_clk / 1000) % 1000), 
-			(sync_duration / pConf->lcd_timing.sync_duration_den), ((sync_duration * 10 / pConf->lcd_timing.sync_duration_den) % 10));
-}
-
-static void lcd_tcon_config(Lcd_Config_t *pConf)
-{
-	unsigned short hstart, hend, vstart, vend;
-	unsigned short h_delay = 0;
-	unsigned short h_offset = 0, v_offset = 0, vsync_h_phase=0;
-	
-	switch (pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		case LCD_DIGITAL_MIPI:
-			h_delay = MIPI_DELAY;
-			break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		case LCD_DIGITAL_EDP:
-			h_delay = EDP_DELAY;
-			break;
-#endif
-		case LCD_DIGITAL_LVDS:
-			h_delay = LVDS_DELAY;
-			break;
-		case LCD_DIGITAL_TTL:
-			h_delay = TTL_DELAY;
-			break;
-		default:
-			h_delay = 0;
-			break;
-	}
-#if 0
-	h_offset = (pConf->lcd_timing.h_offset & 0xffff);
-	v_offset = (pConf->lcd_timing.v_offset & 0xffff);
-	if ((pConf->lcd_timing.h_offset >> 31) & 1)
-		pConf->lcd_timing.de_hstart = (pConf->lcd_timing.video_on_pixel + pConf->lcd_basic.h_period + h_delay + h_offset) % pConf->lcd_basic.h_period;
-	else
-		pConf->lcd_timing.de_hstart = (pConf->lcd_timing.video_on_pixel + pConf->lcd_basic.h_period + h_delay - h_offset) % pConf->lcd_basic.h_period;
-	if ((pConf->lcd_timing.v_offset >> 31) & 1)
-		pConf->lcd_timing.de_vstart = (pConf->lcd_timing.video_on_line + pConf->lcd_basic.v_period + v_offset) % pConf->lcd_basic.v_period;
-	else
-		pConf->lcd_timing.de_vstart = (pConf->lcd_timing.video_on_line + pConf->lcd_basic.v_period - v_offset) % pConf->lcd_basic.v_period;
-	
-	hstart = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp) % pConf->lcd_basic.h_period;
-	hend = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp + pConf->lcd_timing.hsync_width) % pConf->lcd_basic.h_period;	
-	pConf->lcd_timing.sth1_hs_addr = hstart;
-	pConf->lcd_timing.sth1_he_addr = hend;
-	pConf->lcd_timing.sth1_vs_addr = 0;
-	pConf->lcd_timing.sth1_ve_addr = pConf->lcd_basic.v_period - 1;
-	
-	vsync_h_phase = (pConf->lcd_timing.vsync_h_phase & 0xffff);
-	if ((pConf->lcd_timing.vsync_h_phase >> 31) & 1) //negative
-		vsync_h_phase = (hstart + pConf->lcd_basic.h_period - vsync_h_phase) % pConf->lcd_basic.h_period;
-	else	//positive
-		vsync_h_phase = (hstart + pConf->lcd_basic.h_period + vsync_h_phase) % pConf->lcd_basic.h_period;
-	pConf->lcd_timing.stv1_hs_addr = vsync_h_phase;
-	pConf->lcd_timing.stv1_he_addr = vsync_h_phase;
-	vstart = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp) % pConf->lcd_basic.v_period;
-	vend = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp + pConf->lcd_timing.vsync_width) % pConf->lcd_basic.v_period;
-	pConf->lcd_timing.stv1_vs_addr = vstart;
-	pConf->lcd_timing.stv1_ve_addr = vend;
-
-	pConf->lcd_timing.de_hstart = pConf->lcd_timing.de_hstart;
-	pConf->lcd_timing.de_vstart = pConf->lcd_timing.de_vstart;
-	
-	pConf->lcd_timing.oeh_hs_addr = pConf->lcd_timing.de_hstart;
-	pConf->lcd_timing.oeh_he_addr = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_active) % pConf->lcd_basic.h_period;
-	pConf->lcd_timing.oeh_vs_addr = pConf->lcd_timing.de_vstart;
-	pConf->lcd_timing.oeh_ve_addr = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_active - 1) % pConf->lcd_basic.v_period;
-#else
-    pConf->lcd_timing.video_on_pixel = pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 -h_delay;
-    pConf->lcd_timing.video_on_line = pConf->lcd_basic.v_period - pConf->lcd_basic.v_active;
-
-    h_offset = (pConf->lcd_timing.h_offset & 0xffff);
-    v_offset = (pConf->lcd_timing.v_offset & 0xffff);
-    if ((pConf->lcd_timing.h_offset >> 31) & 1)
-        pConf->lcd_timing.de_hstart = (pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 + pConf->lcd_basic.h_period - h_offset) % pConf->lcd_basic.h_period;
-    else
-        pConf->lcd_timing.de_hstart = (pConf->lcd_basic.h_period - pConf->lcd_basic.h_active - 1 + h_offset) % pConf->lcd_basic.h_period;
-    if ((pConf->lcd_timing.v_offset >> 31) & 1)
-        pConf->lcd_timing.de_vstart = (pConf->lcd_basic.v_period - pConf->lcd_basic.v_active + pConf->lcd_basic.v_period - v_offset) % pConf->lcd_basic.v_period;
-    else
-        pConf->lcd_timing.de_vstart = (pConf->lcd_basic.v_period - pConf->lcd_basic.v_active + v_offset) % pConf->lcd_basic.v_period;
-
-    hstart = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp) % pConf->lcd_basic.h_period;
-    hend = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_period - pConf->lcd_timing.hsync_bp + pConf->lcd_timing.hsync_width) % pConf->lcd_basic.h_period;	
-    pConf->lcd_timing.sth1_hs_addr = hstart;
-    pConf->lcd_timing.sth1_he_addr = hend;
-    pConf->lcd_timing.sth1_vs_addr = 0;
-    pConf->lcd_timing.sth1_ve_addr = pConf->lcd_basic.v_period - 1;
-
-    vsync_h_phase = (pConf->lcd_timing.vsync_h_phase & 0xffff);
-    if ((pConf->lcd_timing.vsync_h_phase >> 31) & 1) //negative
-        vsync_h_phase = (hstart + pConf->lcd_basic.h_period - vsync_h_phase) % pConf->lcd_basic.h_period;
-    else	//positive
-        vsync_h_phase = (hstart + pConf->lcd_basic.h_period + vsync_h_phase) % pConf->lcd_basic.h_period;
-    pConf->lcd_timing.stv1_hs_addr = vsync_h_phase;
-    pConf->lcd_timing.stv1_he_addr = vsync_h_phase;
-    vstart = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp) % pConf->lcd_basic.v_period;
-    vend = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp + pConf->lcd_timing.vsync_width) % pConf->lcd_basic.v_period;
-    pConf->lcd_timing.stv1_vs_addr = vstart;
-    pConf->lcd_timing.stv1_ve_addr = vend;
-
-    pConf->lcd_timing.oeh_hs_addr = pConf->lcd_timing.de_hstart;
-    pConf->lcd_timing.oeh_he_addr = (pConf->lcd_timing.de_hstart + pConf->lcd_basic.h_active) % pConf->lcd_basic.h_period;
-    pConf->lcd_timing.oeh_vs_addr = pConf->lcd_timing.de_vstart;
-    pConf->lcd_timing.oeh_ve_addr = (pConf->lcd_timing.de_vstart + pConf->lcd_basic.v_active - 1) % pConf->lcd_basic.v_period;
-#endif
-
-	DBG_PRINT("sth1_hs_addr=%d, sth1_he_addr=%d, sth1_vs_addr=%d, sth1_ve_addr=%d\n", pConf->lcd_timing.sth1_hs_addr, pConf->lcd_timing.sth1_he_addr, pConf->lcd_timing.sth1_vs_addr, pConf->lcd_timing.sth1_ve_addr);
-	DBG_PRINT("stv1_hs_addr=%d, stv1_he_addr=%d, stv1_vs_addr=%d, stv1_ve_addr=%d\n", pConf->lcd_timing.stv1_hs_addr, pConf->lcd_timing.stv1_he_addr, pConf->lcd_timing.stv1_vs_addr, pConf->lcd_timing.stv1_ve_addr);
-	DBG_PRINT("oeh_hs_addr=%d, oeh_he_addr=%d, oeh_vs_addr=%d, oeh_ve_addr=%d\n", pConf->lcd_timing.oeh_hs_addr, pConf->lcd_timing.oeh_he_addr, pConf->lcd_timing.oeh_vs_addr, pConf->lcd_timing.oeh_ve_addr);
-}
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-static void select_edp_link_config(Lcd_Config_t *pConf)
-{
-    unsigned bit_rate;
-    unsigned lane_cap;
-
-    bit_rate = (pConf->lcd_timing.lcd_clk / 1000) * pConf->lcd_basic.lcd_bits * 3 / 1000;    //Mbps
-    pConf->lcd_control.edp_config->bit_rate = bit_rate;
-
-    if (pConf->lcd_control.edp_config->link_user == 0) {
-        if (bit_rate < EDP_TX_LINK_CAPACITY_162 * 1) {
-            pConf->lcd_control.edp_config->link_rate = 0;
-            pConf->lcd_control.edp_config->lane_count = 1;
-        }
-        else if (bit_rate < EDP_TX_LINK_CAPACITY_270 * 1) {
-            pConf->lcd_control.edp_config->link_rate = 1;
-            pConf->lcd_control.edp_config->lane_count = 1;
-        }
-        else if (bit_rate < EDP_TX_LINK_CAPACITY_162 * 2) {
-            pConf->lcd_control.edp_config->link_rate = 0;
-            pConf->lcd_control.edp_config->lane_count = 2;
-        }
-        else if (bit_rate < EDP_TX_LINK_CAPACITY_270 * 2) {
-            pConf->lcd_control.edp_config->link_rate = 1;
-            pConf->lcd_control.edp_config->lane_count = 2;
-        }
-        else if (bit_rate < EDP_TX_LINK_CAPACITY_162 * 4) {
-            pConf->lcd_control.edp_config->link_rate = 0;
-            pConf->lcd_control.edp_config->lane_count = 4;
-        }
-        else if (bit_rate < EDP_TX_LINK_CAPACITY_270 * 4) {
-            pConf->lcd_control.edp_config->link_rate = 1;
-            pConf->lcd_control.edp_config->lane_count = 4;
-        }
-        else {
-            printk("Error: bit rate is out edp of support, should reduce frame rate(pixel clock)\n");
-            pConf->lcd_control.edp_config->link_rate = 1;
-            pConf->lcd_control.edp_config->lane_count = 4;
-        }
-    }
-    else {
-        lane_cap = (pConf->lcd_control.edp_config->link_rate == 0) ? EDP_TX_LINK_CAPACITY_162 : EDP_TX_LINK_CAPACITY_270;
-        while ((bit_rate > (lane_cap * pConf->lcd_control.edp_config->lane_count)) && (pConf->lcd_control.edp_config->lane_count < 4)) {
-            switch (pConf->lcd_control.edp_config->lane_count) {
-                case 1:
-                    pConf->lcd_control.edp_config->lane_count = 2;
-                    break;
-                case 2:
-                    pConf->lcd_control.edp_config->lane_count = 4;
-                    break;
-                default:
-                    break;
-            }
-        }
-        if (bit_rate > (lane_cap * pConf->lcd_control.edp_config->lane_count))
-            printk("Error: bit rate is out edp of support, should reduce frame rate(pixel clock)\n");
-    }
-}
-#endif
-
-static void lcd_control_config_pre(Lcd_Config_t *pConf)
-{
-    unsigned vclk_sel, ss_level;
-
-    vclk_sel = 1;
-    ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
-
-    switch (pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_MIPI:
-            ss_level = ((ss_level > 0) ? 1 : 0);
-            set_mipi_dsi_control_config(pConf);
-            break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_EDP:
-            ss_level = ((ss_level > 0) ? 1 : 0);
-            select_edp_link_config(pConf);
-            if (pConf->lcd_control.edp_config->link_adaptive == 1) {
-                pConf->lcd_control.edp_config->vswing = 0;
-                pConf->lcd_control.edp_config->preemphasis = 0;
-            }
-            printk("edp vswing=0x%x, preem=0x%x\n", pConf->lcd_control.edp_config->vswing, pConf->lcd_control.edp_config->preemphasis);
-            break;
-#endif
-        case LCD_DIGITAL_LVDS:
-            ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
-            if (pConf->lcd_control.lvds_config->lvds_repack_user == 0) {
-                if (pConf->lcd_basic.lcd_bits == 6)
-                    pConf->lcd_control.lvds_config->lvds_repack = 0;
-                else
-                    pConf->lcd_control.lvds_config->lvds_repack = 1;
-            }
-            break;
-        case LCD_DIGITAL_TTL:
-            ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-            if (pConf->lcd_basic.lcd_bits != 6) {
-                pConf->lcd_basic.lcd_bits = 6;
-                printk("lcd change to 6bit for ttl support!\n");
-            }
-#endif
-            break;
-        default:
-            ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX-1) : ss_level);
-            break;
-    }
-    pConf->lcd_timing.clk_ctrl &= (~((1 << CLK_CTRL_VCLK_SEL) | (0xf << CLK_CTRL_SS)));
-    pConf->lcd_timing.clk_ctrl |= ((vclk_sel << CLK_CTRL_VCLK_SEL) | (ss_level << CLK_CTRL_SS));
-}
-
-//for special interface config after clk setting
-static void lcd_control_config_post(Lcd_Config_t *pConf)
-{
-    switch (pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_MIPI:
-            set_mipi_dsi_control_config_post(pConf);
-            break;
-#endif
-        default:
-            break;
-    }
-}
-
-static void lcd_config_init(Lcd_Config_t *pConf)
-{
-	lcd_control_config_pre(pConf);//must before generate_clk_parameter, otherwise the clk parameter will not update base on the edp_link_rate
-	
-	if (pConf->lcd_timing.clk_ctrl & (1 << CLK_CTRL_AUTO)) {
-		printk("\nAuto generate clock parameters.\n");
-		generate_clk_parameter(pConf);
-		DBG_PRINT("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
-	}
-	else {
-		printk("\nCustome clock parameters.\n");
-		printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
-	}
-	
-	lcd_sync_duration(pConf);
-	lcd_tcon_config(pConf);
-
-	lcd_control_config_post(pConf);
-}
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-static void switch_lcd_gates(Lcd_Type_t lcd_type)
-{
-	switch(lcd_type){
-		case LCD_DIGITAL_TTL:
-			switch_mod_gate_by_name("tcon", 1);
-			switch_mod_gate_by_name("lvds", 0);
-			break;
-		case LCD_DIGITAL_LVDS:
-		case LCD_DIGITAL_MINILVDS:
-			switch_mod_gate_by_name("lvds", 1);
-			switch_mod_gate_by_name("tcon", 0);
-			break;
-		default:
-			break;
-	}
-}
-#endif
-
-static void _init_lcd_driver(Lcd_Config_t *pConf)
-{
-    int lcd_type = pConf->lcd_basic.lcd_type;
-    unsigned char ss_level = (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
-
-    printk("lcd driver version: %s%s\n\n", DRIVER_DATE, DRV_TYPE);
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-    switch_lcd_gates(lcd_type);
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-    switch_vpu_mem_pd_vmod(pDev->lcd_info.mode, VPU_MEM_POWER_ON);
-    switch_lcd_mod_gate(ON);
-#endif
-
-    printk("Init LCD mode: %s, %s(%u) %ubit, %ux%u@%u.%uHz, ss_level=%u(%s)\n", pConf->lcd_basic.model_name, lcd_type_table[lcd_type], lcd_type, pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10), ss_level, lcd_ss_level_table[ss_level]);
-
-    switch(lcd_type){
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_MIPI:
-            set_pll_lcd(pConf);
-            set_venc_lcd(pConf);
-            set_tcon_lcd(pConf);
-            init_dphy(pConf);
-            break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_EDP:
-            set_pll_lcd(pConf);
-            set_venc_lcd(pConf);
-            set_tcon_lcd(pConf);
-            init_dphy(pConf);
-            break;
-#endif
-        case LCD_DIGITAL_LVDS:
-            set_pll_lcd(pConf);
-            set_venc_lcd(pConf);
-            set_tcon_lcd(pConf);
-            set_control_lvds(pConf);
-            init_dphy(pConf);
-            break;
-        case LCD_DIGITAL_TTL:
-            set_pll_lcd(pConf);
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-            set_venc_ttl(pConf);
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-            set_venc_lcd(pConf);
-#endif
-            set_tcon_ttl(pConf);
-            set_control_ttl(pConf);
-            break;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-        case LCD_DIGITAL_MINILVDS:
-            set_pll_mlvds(pConf);
-            set_venc_mlvds(pConf);
-            set_tcon_mlvds(pConf);
-            set_control_mlvds(pConf);
-            init_dphy(pConf);
-            break;
-#endif
-        default:
-            printk("Invalid LCD type.\n");
-            break;
-    }
-    set_video_adjust(pConf);
-    printk("%s finished.\n", __FUNCTION__);
-}
-
-static void _disable_lcd_driver(Lcd_Config_t *pConf)
-{
-    int vclk_sel;
-
-    switch(pConf->lcd_basic.lcd_type){
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_MIPI:
-            mipi_dsi_off();
-            break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case LCD_DIGITAL_EDP:
-            dplpm_off();
-            break;
-#endif
-        case LCD_DIGITAL_LVDS:
-        case LCD_DIGITAL_TTL:
-        case LCD_DIGITAL_MINILVDS:
-        default:
-            break;
-    }
-
-    vclk_sel = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_VCLK_SEL) & 0x1;
-
-    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 11, 1);	//close lvds phy clk gate: 0x104c[11]
-    WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-    WRITE_LCD_REG(ENCT_VIDEO_EN, 0);	//disable enct
-#endif
-    WRITE_LCD_REG(ENCL_VIDEO_EN, 0);	//disable encl
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-    CLK_GATE_OFF(CTS_ENCL); //disable encl clk gate //new add for M8b
-#endif
-
-    if (vclk_sel)
-        WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 0, 5);	//close vclk2 gate: 0x104b[4:0]
-    else
-        WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 0, 0, 5);		//close vclk1 gate: 0x105f[4:0]
-
-    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 16, 1);	//close vid2_pll gate: 0x104c[16]
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-    WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 0, 23, 3);	//disable pll_out mux
-#endif
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-    WRITE_LCD_CBUS_REG_BITS(HHI_VIID_PLL_CNTL, 1, 30, 1);		//power down vid2_pll: 0x1047[30]
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-    WRITE_LCD_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0, 30, 1);		//disable vid2_pll: 0x10e0[30]
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-    WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, 30, 1);		//disable vid_pll: 0x10c8[30]
-#endif
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-    switch_mod_gate_by_name("tcon", 0);
-    switch_mod_gate_by_name("lvds", 0);
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-    //switch_lcd_gates(OFF);
-    switch_lcd_mod_gate(OFF);
-    switch_vpu_mem_pd_vmod(pDev->lcd_info.mode, VPU_MEM_POWER_DOWN);
-#endif
-    printk("disable lcd display driver.\n");
-}
-
-static inline void _enable_vsync_interrupt(void)
-{
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	if ((READ_LCD_REG(ENCT_VIDEO_EN) & 1) || (READ_LCD_REG(ENCL_VIDEO_EN) & 1)) {
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	if (READ_LCD_REG(ENCL_VIDEO_EN) & 1) {
-#endif
-		WRITE_LCD_REG(VENC_INTCTRL, 0x200);
-	}
-	else{
-		WRITE_LCD_REG(VENC_INTCTRL, 0x2);
-	}
-}
-
-void _enable_backlight(void)
-{
-	backlight_power_ctrl(ON);
-}
-void _disable_backlight(void)
-{
-	backlight_power_ctrl(OFF);
-}
-
-static DEFINE_MUTEX(lcd_init_mutex);
-static void _lcd_module_enable(void)
-{
-	int ret = 0;
-
-	mutex_lock(&lcd_init_mutex);
-	BUG_ON(pDev==NULL);
-
-	_init_lcd_driver(pDev->pConf);
-	ret = lcd_power_ctrl(ON);
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
-		if (ret > 0) {
-			lcd_power_ctrl(OFF);
-			_disable_lcd_driver(pDev->pConf);
-			mdelay(30);
-			_init_lcd_driver(pDev->pConf);
-			lcd_power_ctrl(ON);
-		}
-	}
-#endif
-	data_status = ON;
-	_enable_vsync_interrupt();
-	lcd_status_flag = 1;
-	mutex_unlock(&lcd_init_mutex);
-}
-
-static void _lcd_module_disable(void)
-{
-	mutex_lock(&lcd_init_mutex);
-	lcd_status_flag = 0;
-	BUG_ON(pDev==NULL);
-	data_status = OFF;
-	lcd_power_ctrl(OFF);
-	_disable_lcd_driver(pDev->pConf);
-	mutex_unlock(&lcd_init_mutex);
-}
-
-static const vinfo_t *lcd_get_current_info(void)
-{
-    if (pDev == NULL) {
-        printk("[error] no lcd device exist!\n");
-        return NULL;
-    }
-    else 
-        return &pDev->lcd_info;
-}
-
-static DEFINE_MUTEX(lcd_vout_mutex);
-static int lcd_set_current_vmode(vmode_t mode)
-{
-	mutex_lock(&lcd_vout_mutex);
-	if (VMODE_LCD != (mode & VMODE_MODE_BIT_MASK)) {
-		mutex_unlock(&lcd_vout_mutex);
-		return -EINVAL;
-	}
-
-	vpp2_sel = 0;
-	WRITE_LCD_REG(VPP_POSTBLEND_H_SIZE, pDev->lcd_info.width);
-
-	if( !(mode&VMODE_LOGO_BIT_MASK) ){
-		_disable_backlight();
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		request_vpu_clk_vmod(pDev->lcd_info.video_clk, pDev->lcd_info.mode);
-#endif
-		_lcd_module_enable();
-		_enable_backlight();
-	}
-	if (VMODE_INIT_NULL == pDev->lcd_info.mode)
-		pDev->lcd_info.mode = VMODE_LCD;
-	
-	mutex_unlock(&lcd_vout_mutex);
-	return 0;
-}
-
-#ifdef CONFIG_AM_TV_OUTPUT2
-static int lcd_set_current_vmode2(vmode_t mode)
-{
-	mutex_lock(&lcd_vout_mutex);
-	if (mode != VMODE_LCD) {
-		mutex_unlock(&lcd_vout_mutex);
-		return -EINVAL;
-	}
-	_disable_backlight();
-    vpp2_sel = 1;
-
-    WRITE_LCD_REG(VPP2_POSTBLEND_H_SIZE, pDev->lcd_info.width);
-	
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	request_vpu_clk_vmod(pDev->lcd_info.video_clk, pDev->lcd_info.mode);
-#endif
-    _lcd_module_enable();
-    if (VMODE_INIT_NULL == pDev->lcd_info.mode)
-        pDev->lcd_info.mode = VMODE_LCD;
-    _enable_backlight();
-	mutex_unlock(&lcd_vout_mutex);
-    return 0;
-}
-#endif
-
-static vmode_t lcd_validate_vmode(char *mode)
-{
-    if ((strncmp(mode, PANEL_NAME, strlen(PANEL_NAME))) == 0)
-        return VMODE_LCD;
-    
-    return VMODE_MAX;
-}
-static int lcd_vmode_is_supported(vmode_t mode)
+static int lcd_vmode_is_supported(vmode_t mode)
 {
     mode&=VMODE_MODE_BIT_MASK;
     if(mode == VMODE_LCD )
@@ -3424,40 +353,37 @@ static int lcd_vmode_is_supported(vmode_t mode)
 
 static int lcd_vout_disable(vmode_t cur_vmod)
 {
-	mutex_lock(&lcd_vout_mutex);
-	_disable_backlight();
-	_lcd_module_disable();
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	release_vpu_clk_vmod(pDev->lcd_info.mode);
-#endif
-	mutex_unlock(&lcd_vout_mutex);
-	return 0;
+    mutex_lock(&lcd_vout_mutex);
+    _disable_backlight();
+    _lcd_module_disable();
+    mutex_unlock(&lcd_vout_mutex);
+    return 0;
 }
 
 #ifdef  CONFIG_PM
 static int lcd_suspend(void)
 {
-	mutex_lock(&lcd_vout_mutex);
-	BUG_ON(pDev==NULL);
-	printk("lcd_suspend\n");
-	_disable_backlight();
-	_lcd_module_disable();
-	mutex_unlock(&lcd_vout_mutex);
-	return 0;
+    mutex_lock(&lcd_vout_mutex);
+    BUG_ON(pDev==NULL);
+    printk("lcd_suspend\n");
+    _disable_backlight();
+    _lcd_module_disable();
+    mutex_unlock(&lcd_vout_mutex);
+    return 0;
 }
 static int lcd_resume(void)
 {
-	mutex_lock(&lcd_vout_mutex);
-	printk("lcd_resume\n");
+    mutex_lock(&lcd_vout_mutex);
+    printk("lcd_resume\n");
     _lcd_module_enable();
     _enable_backlight();
-	mutex_unlock(&lcd_vout_mutex);
+    mutex_unlock(&lcd_vout_mutex);
     return 0;
 }
 #endif
 static vout_server_t lcd_vout_server={
     .name = "lcd_vout_server",
-    .op = {    
+    .op = {
         .get_vinfo = lcd_get_current_info,
         .set_vmode = lcd_set_current_vmode,
         .validate_vmode = lcd_validate_vmode,
@@ -3473,7 +399,7 @@ static vout_server_t lcd_vout_server={
 #ifdef CONFIG_AM_TV_OUTPUT2
 static vout_server_t lcd_vout2_server={
     .name = "lcd_vout2_server",
-    .op = {    
+    .op = {
         .get_vinfo = lcd_get_current_info,
         .set_vmode = lcd_set_current_vmode2,
         .validate_vmode = lcd_validate_vmode,
@@ -3486,7 +412,8 @@ static vout_server_t lcd_vout2_server={
     },
 };
 #endif
-static void _init_vout(lcd_dev_t *pDev)
+
+static void _init_vout(void)
 {
     pDev->lcd_info.name = PANEL_NAME;
     pDev->lcd_info.mode = VMODE_LCD;
@@ -3506,58 +433,40 @@ static void _init_vout(lcd_dev_t *pDev)
     vout_register_server(&lcd_vout_server);
 #ifdef CONFIG_AM_TV_OUTPUT2
     vout2_register_server(&lcd_vout2_server);
-#endif   
-}
-
-static void _lcd_init(Lcd_Config_t *pConf)
-{
-	//logo_object_t  *init_logo_obj=NULL;
-	_init_vout(pDev);
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	request_vpu_clk_vmod(pDev->lcd_info.video_clk, pDev->lcd_info.mode);
 #endif
-	//init_logo_obj = get_current_logo_obj();    
-	//if(NULL==init_logo_obj ||!init_logo_obj->para.loaded)
-		//_lcd_module_enable();
-}
-
-static int lcd_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
- {
-	printk("[%s]: %lu\n", __FUNCTION__, state);
-	_disable_backlight();
-	_lcd_module_disable();
-
-    return NOTIFY_DONE;
 }
 
-//****************************
+//*********************************************************
 //gamma debug
-//****************************
+//*********************************************************
 #ifdef CONFIG_AML_GAMMA_DEBUG
 static unsigned short gamma_adjust_r[256];
 static unsigned short gamma_adjust_g[256];
 static unsigned short gamma_adjust_b[256];
 static unsigned short gamma_r_coeff, gamma_g_coeff, gamma_b_coeff;
+static unsigned gamma_ctrl;
 
 static void save_original_gamma(Lcd_Config_t *pConf)
-{
-	int i;
-	
-	for (i=0; i<256; i++) {
+{
+    int i;
+
+    for (i=0; i<256; i++) {
         gamma_adjust_r[i] = pConf->lcd_effect.GammaTableR[i];
         gamma_adjust_g[i] = pConf->lcd_effect.GammaTableG[i];
-		gamma_adjust_b[i] = pConf->lcd_effect.GammaTableB[i];
+        gamma_adjust_b[i] = pConf->lcd_effect.GammaTableB[i];
     }
-	gamma_r_coeff = pConf->lcd_effect.gamma_r_coeff;
-	gamma_g_coeff = pConf->lcd_effect.gamma_g_coeff;
-	gamma_b_coeff = pConf->lcd_effect.gamma_b_coeff;
+    gamma_ctrl = pConf->lcd_effect.gamma_ctrl;
+    gamma_r_coeff = pConf->lcd_effect.gamma_r_coeff;
+    gamma_g_coeff = pConf->lcd_effect.gamma_g_coeff;
+    gamma_b_coeff = pConf->lcd_effect.gamma_b_coeff;
 }
 
 static void read_original_gamma_table(void)
 {
     unsigned i;
-	
-	printk("original gamma r_coeff=%u%%, g_coeff=%u%%, b_coeff=%u%%\n", gamma_r_coeff, gamma_g_coeff, gamma_b_coeff);
+
+    printk("original gamma: enable=%d, reverse=%d, r_coeff=%u%%, g_coeff=%u%%, b_coeff=%u%%\n", 
+          ((gamma_ctrl >> GAMMA_CTRL_EN) & 1), ((gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1), gamma_r_coeff, gamma_g_coeff, gamma_b_coeff);
     printk("read original gamma table R:\n");
     for (i=0; i<256; i++) {
         printk("%u,", gamma_adjust_r[i]);
@@ -3573,67 +482,60 @@ static void read_original_gamma_table(void)
     printk("\n");
 }
 
-static void read_current_gamma_table(void)
+static void read_current_gamma_table(Lcd_Config_t *pConf)
 {
-	unsigned i;
-	
-	printk("current gamma r_coeff=%u%%, g_coeff=%u%%, b_coeff=%u%%\n", pDev->pConf->lcd_effect.gamma_r_coeff, pDev->pConf->lcd_effect.gamma_g_coeff, pDev->pConf->lcd_effect.gamma_b_coeff);
-	printk("read current gamma table R:\n");
+    unsigned i;
+
+    printk("current gamma: enable=%d, reverse=%d, r_coeff=%u%%, g_coeff=%u%%, b_coeff=%u%%\n", 
+          ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1), ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1), 
+          pConf->lcd_effect.gamma_r_coeff, pConf->lcd_effect.gamma_g_coeff, pConf->lcd_effect.gamma_b_coeff);
+    printk("read current gamma table R:\n");
     for (i=0; i<256; i++) {
-        printk("%u ", pDev->pConf->lcd_effect.GammaTableR[i]);
+        printk("%u ", pConf->lcd_effect.GammaTableR[i]);
     }
     printk("\n\nread current gamma table G:\n");
     for (i=0; i<256; i++) {
-        printk("%u ", pDev->pConf->lcd_effect.GammaTableG[i]);
+        printk("%u ", pConf->lcd_effect.GammaTableG[i]);
     }
     printk("\n\nread current gamma table B:\n");
     for (i=0; i<256; i++) {
-        printk("%u ", pDev->pConf->lcd_effect.GammaTableB[i]);
+        printk("%u ", pConf->lcd_effect.GammaTableB[i]);
     }
     printk("\n");
 }
 
-static void write_gamma_table(void)
+static int write_gamma_table(Lcd_Config_t *pConf)
 {
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-    if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
-		WRITE_LCD_REG_BITS(GAMMA_CNTL_PORT, 0, 1, 1);
-        set_gamma_table_ttl(pDev->pConf->lcd_effect.GammaTableR, LCD_H_SEL_R, pDev->pConf->lcd_effect.gamma_r_coeff);
-        set_gamma_table_ttl(pDev->pConf->lcd_effect.GammaTableG, LCD_H_SEL_G, pDev->pConf->lcd_effect.gamma_g_coeff);
-        set_gamma_table_ttl(pDev->pConf->lcd_effect.GammaTableB, LCD_H_SEL_B, pDev->pConf->lcd_effect.gamma_b_coeff);
-		WRITE_LCD_REG_BITS(GAMMA_CNTL_PORT, 1, 1, 1);
+    int ret = 0;
+
+    if (pConf->lcd_effect.set_gamma_table == NULL) {
+        printk("set gamma table function is null\n");
+        ret = -1;
     }
     else {
-        WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 0, 1, 1);
-        set_gamma_table_lcd(pDev->pConf->lcd_effect.GammaTableR, LCD_H_SEL_R, pDev->pConf->lcd_effect.gamma_r_coeff);
-        set_gamma_table_lcd(pDev->pConf->lcd_effect.GammaTableG, LCD_H_SEL_G, pDev->pConf->lcd_effect.gamma_g_coeff);
-        set_gamma_table_lcd(pDev->pConf->lcd_effect.GammaTableB, LCD_H_SEL_B, pDev->pConf->lcd_effect.gamma_b_coeff);
-        WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 1, 1, 1);
+        pConf->lcd_effect.set_gamma_table(1); //force enable gamma table
+        printk("write gamma table ");
     }
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 0, 1, 1);
-	set_gamma_table_lcd(pDev->pConf->lcd_effect.GammaTableR, LCD_H_SEL_R, pDev->pConf->lcd_effect.gamma_r_coeff);
-	set_gamma_table_lcd(pDev->pConf->lcd_effect.GammaTableG, LCD_H_SEL_G, pDev->pConf->lcd_effect.gamma_g_coeff);
-	set_gamma_table_lcd(pDev->pConf->lcd_effect.GammaTableB, LCD_H_SEL_B, pDev->pConf->lcd_effect.gamma_b_coeff);
-	WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 1, 1, 1);
-#endif
-	printk("write gamma table ");
+    return ret;
 }
 
-static void set_gamma_coeff(unsigned r_coeff, unsigned g_coeff, unsigned b_coeff)
-{	    
-	pDev->pConf->lcd_effect.gamma_r_coeff = (unsigned short)(r_coeff);
-	pDev->pConf->lcd_effect.gamma_g_coeff = (unsigned short)(g_coeff);
-	pDev->pConf->lcd_effect.gamma_b_coeff = (unsigned short)(b_coeff);
-	write_gamma_table();
-	printk("with scale factor R:%u%%, G:%u%%, B:%u%%.\n", (unsigned short)(r_coeff), (unsigned short)(g_coeff), (unsigned short)(b_coeff));
+static void set_gamma_coeff(Lcd_Config_t *pConf, unsigned r_coeff, unsigned g_coeff, unsigned b_coeff)
+{
+    pConf->lcd_effect.gamma_r_coeff = (unsigned short)(r_coeff);
+    pConf->lcd_effect.gamma_g_coeff = (unsigned short)(g_coeff);
+    pConf->lcd_effect.gamma_b_coeff = (unsigned short)(b_coeff);
+    if (write_gamma_table(pConf) == 0)
+        printk("with scale factor R:%u%%, G:%u%%, B:%u%%.\n", r_coeff, g_coeff, b_coeff);
 }
 
 static const char * usage_str =
 {"Usage:\n"
 "    echo coeff <R_coeff> <G_coeff> <B_coeff> > write ; set R,G,B gamma scale factor\n"
+"    echo ctrl <enable> <reverse> > write; control gamma table enable and reverse\n"
 "data format:\n"
 "    <R/G/B_coeff>  : a number in Dec(0~100), means a percent value\n"
+"    <enable>       : 0=disable, 1=enable\n"
+"    <reverse>      : 0=normal, 1=reverse\n"
 "\n"
 "    echo [r|g|b] <step> <value> <value> <value> <value> <value> <value> <value> <value> > write ; input R/G/B gamma table\n"
 "    echo w [0 | 8 | 10] > write ; apply the original/8bit/10bit gamma table\n"
@@ -3650,17 +552,17 @@ static const char * usage_str =
 
 static ssize_t gamma_help(struct class *class, struct class_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%s\n",usage_str);
+    return sprintf(buf, "%s\n",usage_str);
 }
 
 static ssize_t aml_lcd_gamma_read(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
 {
-	if (buf[0] == '0')
-		read_original_gamma_table();
-	else
-		read_current_gamma_table();
+    if (buf[0] == '0')
+        read_original_gamma_table();
+    else
+        read_current_gamma_table(pDev->pConf);
 
-	return count;
+    return count;
 }
 
 static unsigned gamma_adjust_r_temp[128];
@@ -3668,17 +570,27 @@ static unsigned gamma_adjust_g_temp[128];
 static unsigned gamma_adjust_b_temp[128];
 static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
 {
-	unsigned int ret;
-	unsigned int i, j;
-	unsigned t[8];
+    unsigned int ret;
+    unsigned int i, j;
+    unsigned t[8];
 
     switch (buf[0]) {
     case 'c':
-        t[0] = 100;
-        t[1] = 100;
-        t[2] = 100;
-        ret = sscanf(buf, "coeff %u %u %u", &t[0], &t[1], &t[2]);
-        set_gamma_coeff(t[0], t[1], t[2]);
+        if (buf[1] == 'o') {
+            t[0] = 100;
+            t[1] = 100;
+            t[2] = 100;
+            ret = sscanf(buf, "coeff %u %u %u", &t[0], &t[1], &t[2]);
+            set_gamma_coeff(pDev->pConf, t[0], t[1], t[2]);
+        }
+        else if (buf[1] == 't') {
+            t[0] = 1;
+            t[1] = 0;
+            ret = sscanf(buf, "ctrl %u %u", &t[0], &t[1]);
+            pDev->pConf->lcd_effect.gamma_ctrl = ((t[0] << GAMMA_CTRL_EN) | (t[1] << GAMMA_CTRL_REVERSE));
+            if (write_gamma_table(pDev->pConf) == 0)
+                printk(" finished.\n");
+        }
         break;
     case 'r':
         ret = sscanf(buf, "r %x %x %x %x %x %x %x %x %x", &i, &t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]);
@@ -3721,8 +633,8 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
                     pDev->pConf->lcd_effect.GammaTableB[i*4+j] = (unsigned short)(((gamma_adjust_b_temp[i] >> (24-j*8)) & 0xff) << 2);
                 }
             }
-            write_gamma_table();
-            printk("8bit finished.\n");
+            if (write_gamma_table(pDev->pConf) == 0)
+                printk("8bit finished.\n");
         }
         else if (i == 10) {
             for (i=0; i<128; i++) {
@@ -3732,8 +644,8 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
                     pDev->pConf->lcd_effect.GammaTableB[i*2+j] = (unsigned short)((gamma_adjust_b_temp[i] >> (16-j*16)) & 0xffff);
                 }
             }
-            write_gamma_table();
-            printk("10bit finished.\n");
+            if (write_gamma_table(pDev->pConf) == 0)
+                printk("10bit finished.\n");
         }
         else {
             for (i=0; i<256; i++) {
@@ -3741,8 +653,8 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
                 pDev->pConf->lcd_effect.GammaTableG[i] = gamma_adjust_g[i];
                 pDev->pConf->lcd_effect.GammaTableB[i] = gamma_adjust_b[i];
             }
-            write_gamma_table();
-            printk("to original.\n");
+            if (write_gamma_table(pDev->pConf) == 0)
+                printk("to original.\n");
         }
         break;
     case 'f':
@@ -3753,7 +665,7 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
             for (j=0; j<256; j++) {
                 pDev->pConf->lcd_effect.GammaTableR[j] = i<<2;
             }
-            set_gamma_coeff(100, 0, 0);
+            set_gamma_coeff(pDev->pConf, 100, 0, 0);
             printk("with R fixed value %u finished.\n", i);
         }
         else if (buf[1] == 'g') {
@@ -3762,7 +674,7 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
             for (j=0; j<256; j++) {
                 pDev->pConf->lcd_effect.GammaTableG[j] = i<<2;
             }
-            set_gamma_coeff(0, 100, 0);
+            set_gamma_coeff(pDev->pConf, 0, 100, 0);
             printk("with G fixed value %u finished.\n", i);
         }
         else if (buf[1] == 'b') {
@@ -3771,7 +683,7 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
             for (j=0; j<256; j++) {
                 pDev->pConf->lcd_effect.GammaTableB[j] = i<<2;
             }
-            set_gamma_coeff(0, 0, 100);
+            set_gamma_coeff(pDev->pConf, 0, 0, 100);
             printk("with B fixed value %u finished.\n", i);
         }
         else {
@@ -3782,52 +694,75 @@ static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *
                 pDev->pConf->lcd_effect.GammaTableG[j] = i<<2;
                 pDev->pConf->lcd_effect.GammaTableB[j] = i<<2;
             }
-            set_gamma_coeff(100, 100, 100);
+            set_gamma_coeff(pDev->pConf, 100, 100, 100);
             printk("with fixed value %u finished.\n", i);
         }
         break;
-        default:
+    default:
             printk("wrong format of gamma table writing.\n");
     }
 
-	if (ret != 1 || ret !=2)
-		return -EINVAL;
+    if (ret != 1 || ret !=2)
+        return -EINVAL;
 
-	return count;
-	//return 0;
+    return count;
+    //return 0;
 }
 
-static struct class_attribute aml_lcd_class_attrs[] = {
-	__ATTR(write,  S_IRUGO | S_IWUSR, gamma_help, aml_lcd_gamma_debug),
-	__ATTR(read,  S_IRUGO | S_IWUSR, gamma_help, aml_lcd_gamma_read),
-	__ATTR(help,  S_IRUGO | S_IWUSR, gamma_help, NULL),
-    __ATTR_NULL
+static struct class_attribute aml_lcd_gamma_class_attrs[] = {
+    __ATTR(write,  S_IRUGO | S_IWUSR, gamma_help, aml_lcd_gamma_debug),
+    __ATTR(read,  S_IRUGO | S_IWUSR, gamma_help, aml_lcd_gamma_read),
+    __ATTR(help,  S_IRUGO | S_IWUSR, gamma_help, NULL),
 };
 
-static struct class aml_gamma_class = {
-    .name = "gamma",
-    .class_attrs = aml_lcd_class_attrs,
-};
+static int creat_lcd_gamma_attr(void)
+{
+    int i;
+
+    gamma_debug_class = class_create(THIS_MODULE, "gamma");
+    if(IS_ERR(gamma_debug_class)) {
+        printk("create gamma debug class fail\n");
+        return -1;
+    }
+
+    for(i=0;i<ARRAY_SIZE(aml_lcd_gamma_class_attrs);i++) {
+        if (class_create_file(gamma_debug_class, &aml_lcd_gamma_class_attrs[i])) {
+            printk("create gamma debug attribute %s fail\n", aml_lcd_gamma_class_attrs[i].attr.name);
+        }
+    }
+
+    return 0;
+}
+
+static int remove_lcd_gamma_attr(void)
+{
+    int i;
+
+    if (gamma_debug_class == NULL)
+        return -1;
+
+    for(i=0;i<ARRAY_SIZE(aml_lcd_gamma_class_attrs);i++) {
+        class_remove_file(gamma_debug_class, &aml_lcd_gamma_class_attrs[i]);
+    }
+    class_destroy(gamma_debug_class);
+
+    return 0;
+}
 #endif
-//****************************
+//*********************************************************
 
-//****************************
+//*********************************************************
 //LCD debug
-//****************************
+//*********************************************************
 static Lcd_Basic_t temp_lcd_basic;
 static Lcd_Timing_t temp_lcd_timing;
 static unsigned short temp_dith_user, temp_dith_ctrl;
 static unsigned int temp_vadj_brightness, temp_vadj_contrast, temp_vadj_saturation;
 static int temp_ttl_rb_swap, temp_ttl_bit_swap;
 static int temp_lvds_repack, temp_pn_swap, temp_lvds_vswing;
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
 static unsigned char temp_dsi_lane_num;
 static unsigned temp_dsi_bit_rate_min, temp_dsi_bit_rate_max, temp_factor_denominator, temp_factor_numerator;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
 static unsigned char temp_edp_link_rate, temp_edp_lane_count, temp_edp_vswing, temp_edp_preemphasis;
-#endif
-static unsigned short last_h_active, last_v_active;
 
 static const char * lcd_usage_str =
 {"Usage:\n"
@@ -3837,30 +772,41 @@ static const char * lcd_usage_str =
 "    echo sync <hs_width> <hs_backporch> <hs_pol> <vs_width> <vs_backporch> <vs_pol> > debug ; write lcd sync timing\n"
 "    echo valid <hvsync_valid> <de_valid> > debug ; enable lcd sync signals\n"
 "data format:\n"
-"    <lcd_type> : 0=mipi, 1=lvds, 2=edp, 3=ttl\n"
+"    <lcd_type> : "
+#ifdef CONFIG_LCD_IF_MIPI_VALID
+"0=mipi, "
+#endif
+"1=lvds, "
+#ifdef CONFIG_LCD_IF_EDP_VALID
+"2=edp, "
+#endif
+"3=ttl\n"
 "    <lcd_bits> : 6=6bit(RGB18bit), 8=8bit(RGB24bit)\n"
-"    <ss_level> : lcd clock spread spectrum level, 0~5, 0 for disable\n"
+"    <ss_level> : lcd clock spread spectrum level (0~6), 0 for disable\n"
 "    <xx_pol>   : 0=negative, 1=positive\n"
 "    <xx_valid> : 0=disable, 1=enable\n"
 "\n"
 "    echo ttl <rb_swap> <bit_swap> > debug ; write ttl RGB swap config\n"
 "    echo lvds <vswing_level> <lvds_repack> <pn_swap> > debug ; write lvds config\n"
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
+#ifdef CONFIG_LCD_IF_MIPI_VALID
 "    echo mdsi <bit_rate_min> <bit_rate_max> <factor> > debug ; write mipi-dsi config\n"
 #endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
+#ifdef CONFIG_LCD_IF_EDP_VALID
 "    echo edp <link_rate> <lane_count> <vswing_level> > debug ; write edp config\n"
 #endif
-"\n"
 "data format:\n"
 "    <xx_swap>      : 0=normal, 1=swap\n"
-"    <vswing_level> : lvds support 5 levels (0,1,2,3,4. Default=1). edp support level 0,1,2,3.\n"
+"    <vswing_level> : lvds support level 0~4 (Default=1); "
+#ifdef CONFIG_LCD_IF_EDP_VALID
+"edp support level 0~3 (default=0)"
+#endif
+"\n"
 "    <lvds_repack>  : 0=JEIDA mode, 1=VESA mode\n"
 "    <pn_swap>      : 0=normal, 1=swap lvds p/n channels\n"
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
+#ifdef CONFIG_LCD_IF_MIPI_VALID
 "    <bit_rate_xxx> : unit in MHz\n"
 #endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
+#ifdef CONFIG_LCD_IF_EDP_VALID
 "    <link_rate>    : 0=1.62G, 1=2.7G\n"
 #endif
 "\n"
@@ -3878,15 +824,15 @@ static const char * lcd_usage_str =
 "    echo write > debug ; update lcd driver\n"
 "    echo reset > debug ; reset lcd config & driver\n"
 "    echo read > debug ; read current lcd config\n"
-"    echo test <num> > debug ; bist pattern test, 0=pattern off, 1,2,3=different pattern \n"
+"    echo test <num> > debug ; bist pattern test, 0=pattern off, 1~7=different pattern\n"
 "\n"
-"    echo disable > debug ; power off lcd \n"
-"    echo enable > debug ; power on lcd \n"
+"    echo 0/1 > status ; 0=disable lcd; 1=enable lcd\n"
+"    cat status ; read current lcd status\n"
 };
 
 static ssize_t lcd_debug_help(struct class *class, struct class_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%s\n",lcd_usage_str);
+    return sprintf(buf, "%s\n",lcd_usage_str);
 }
 
 static void read_current_lcd_config(Lcd_Config_t *pConf)
@@ -3898,14 +844,14 @@ static void read_current_lcd_config(Lcd_Config_t *pConf)
     h_adj = ((pConf->lcd_timing.h_offset >> 31) & 1);
     v_adj = ((pConf->lcd_timing.v_offset >> 31) & 1);
 
-    printk("lcd driver version: %s%s\n\n", DRIVER_DATE, DRV_TYPE);
+    pConf->lcd_misc_ctrl.print_version();
     printk("LCD mode: %s, %s %ubit, %ux%u@%u.%uHz\n"
            "lcd_clk           %u.%03uMHz\n"
            "ss_level          %d\n"
            "clk_pol           %d\n\n",
            pConf->lcd_basic.model_name, lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active,
            (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10),
-           (lcd_clk / 1000), (lcd_clk % 1000), ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf), ((pConf->lcd_timing.pol_cntl_addr >> LCD_CPH1_POL) & 1));
+           (lcd_clk / 1000), (lcd_clk % 1000), ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf), ((pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1));
 
     printk("h_period          %d\n"
            "v_period          %d\n"
@@ -3921,8 +867,8 @@ static void read_current_lcd_config(Lcd_Config_t *pConf)
            "h_offset          %s%d\n"
            "v_offset          %s%d\n\n",
            pConf->lcd_basic.h_period, pConf->lcd_basic.v_period,
-           pConf->lcd_timing.hsync_width, pConf->lcd_timing.hsync_bp, ((pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1),
-           pConf->lcd_timing.vsync_width, pConf->lcd_timing.vsync_bp, ((pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1),
+           pConf->lcd_timing.hsync_width, pConf->lcd_timing.hsync_bp, ((pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1),
+           pConf->lcd_timing.vsync_width, pConf->lcd_timing.vsync_bp, ((pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1),
            (((pConf->lcd_timing.vsync_h_phase >> 31) & 1) ? "-":""), (pConf->lcd_timing.vsync_h_phase & 0xffff), pConf->lcd_timing.hvsync_valid, pConf->lcd_timing.de_valid,
            (h_adj ? "-" : ""), (pConf->lcd_timing.h_offset & 0xffff), (v_adj ? "-" : ""), (pConf->lcd_timing.v_offset & 0xffff));
 
@@ -3938,29 +884,27 @@ static void read_current_lcd_config(Lcd_Config_t *pConf)
                    "pn_swap           %u\n\n",
                    pConf->lcd_control.lvds_config->lvds_vswing, pConf->lcd_control.lvds_config->lvds_repack, pConf->lcd_control.lvds_config->pn_swap);
             break;
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
         case LCD_DIGITAL_MIPI:
             printk("dsi_lane_num      %u\n"
                    "dsi_bit_rate      %u.%03uMHz\n"
                    "operation_mode    %u(%s), %u(%s)\n"
                    "transfer_ctrl     %u, %u\n\n",
-                   pDev->pConf->lcd_control.mipi_config->lane_num,
-                   (pDev->pConf->lcd_control.mipi_config->bit_rate / 1000000), ((pDev->pConf->lcd_control.mipi_config->bit_rate % 1000000) / 1000),
-                   ((pDev->pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_INIT) &1), (((pDev->pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_INIT) & 1) ? "COMMAND" : "VIDEO"),
-                   ((pDev->pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1), (((pDev->pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1) ? "COMMAND" : "VIDEO"),
-                   ((pDev->pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_CLK) & 1), ((pDev->pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_SWITCH) & 3));
+                   pConf->lcd_control.mipi_config->lane_num, (pConf->lcd_control.mipi_config->bit_rate / 1000000), ((pConf->lcd_control.mipi_config->bit_rate % 1000000) / 1000),
+                   ((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_INIT) &1), (((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_INIT) & 1) ? "COMMAND" : "VIDEO"),
+                   ((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1), (((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1) ? "COMMAND" : "VIDEO"),
+                   ((pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_CLK) & 1), ((pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_SWITCH) & 3));
             break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
         case LCD_DIGITAL_EDP:
             printk("link_rate         %s\n"
                    "lane_count        %u\n"
                    "link_adaptive     %u\n"
-                   "vswing            %u\n\n",
-                   ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G" : "2.7G"), pConf->lcd_control.edp_config->lane_count,
-                   pConf->lcd_control.edp_config->link_adaptive, pConf->lcd_control.edp_config->vswing);
+                   "vswing            %u\n"
+                   "max_lane_count    %u\n"
+                   "sync_clock_mode   %u\n\n",
+                   ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count,
+                   pConf->lcd_control.edp_config->link_adaptive, pConf->lcd_control.edp_config->vswing,
+                   pConf->lcd_control.edp_config->max_lane_count, pConf->lcd_control.edp_config->sync_clock_mode);
             break;
-#endif
         default:
             break;
     }
@@ -3977,31 +921,6 @@ static void read_current_lcd_config(Lcd_Config_t *pConf)
            pConf->lcd_timing.video_on_pixel, pConf->lcd_timing.video_on_line);
 }
 
-static void scale_framebuffer(void)
-{
-	pDev->lcd_info.sync_duration_num = pDev->pConf->lcd_timing.sync_duration_num;
-	pDev->lcd_info.sync_duration_den = pDev->pConf->lcd_timing.sync_duration_den;
-	if ((pDev->pConf->lcd_basic.h_active != last_h_active) || (pDev->pConf->lcd_basic.v_active != last_v_active)) {
-		pDev->lcd_info.width = pDev->pConf->lcd_basic.h_active;
-		pDev->lcd_info.height = pDev->pConf->lcd_basic.v_active;
-		pDev->lcd_info.field_height = pDev->pConf->lcd_basic.v_active;
-
-		if (vpp2_sel)
-			WRITE_LCD_REG(VPP2_POSTBLEND_H_SIZE, pDev->lcd_info.width);
-		else
-			WRITE_LCD_REG(VPP_POSTBLEND_H_SIZE, pDev->lcd_info.width);
-		
-		last_h_active = pDev->pConf->lcd_basic.h_active;
-		last_v_active = pDev->pConf->lcd_basic.v_active;
-	
-		printk("\nPlease input below commands:\n");
-		printk("echo 0 0 %d %d > /sys/class/video/axis\n", pDev->pConf->lcd_basic.h_active, pDev->pConf->lcd_basic.v_active);
-		printk("echo %d > /sys/class/graphics/fb0/scale_width\n", temp_lcd_basic.h_active);
-		printk("echo %d > /sys/class/graphics/fb0/scale_height\n", temp_lcd_basic.v_active);
-		printk("echo 1 > /sys/class/graphics/fb0/free_scale\n\n");
-	}	
-}
-
 static void save_lcd_config(Lcd_Config_t *pConf)
 {
 	temp_lcd_basic.h_active = pConf->lcd_basic.h_active;
@@ -4025,10 +944,9 @@ static void save_lcd_config(Lcd_Config_t *pConf)
 	temp_lcd_timing.de_valid = pConf->lcd_timing.de_valid;
 	temp_lcd_timing.h_offset = pConf->lcd_timing.h_offset;
 	temp_lcd_timing.v_offset = pConf->lcd_timing.v_offset;
-	temp_lcd_timing.pol_cntl_addr = pConf->lcd_timing.pol_cntl_addr;
+	temp_lcd_timing.pol_ctrl = pConf->lcd_timing.pol_ctrl;
 	
 	switch (pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
 		case LCD_DIGITAL_MIPI:
 			temp_dsi_lane_num = pConf->lcd_control.mipi_config->lane_num;
 			temp_dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
@@ -4036,15 +954,12 @@ static void save_lcd_config(Lcd_Config_t *pConf)
 			temp_factor_denominator = pConf->lcd_control.mipi_config->factor_denominator;
 			temp_factor_numerator = pConf->lcd_control.mipi_config->factor_numerator;
 			break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
 		case LCD_DIGITAL_EDP:
 			temp_edp_link_rate = pConf->lcd_control.edp_config->link_rate;
 			temp_edp_lane_count = pConf->lcd_control.edp_config->lane_count;
 			temp_edp_vswing = pConf->lcd_control.edp_config->vswing;
 			temp_edp_preemphasis = pConf->lcd_control.edp_config->preemphasis;
 			break;
-#endif
 		case LCD_DIGITAL_LVDS:
 			temp_lvds_repack = pConf->lcd_control.lvds_config->lvds_repack;
 			temp_pn_swap = pConf->lcd_control.lvds_config->pn_swap;
@@ -4054,10 +969,6 @@ static void save_lcd_config(Lcd_Config_t *pConf)
 			temp_ttl_rb_swap = pConf->lcd_control.ttl_config->rb_swap;
 			temp_ttl_bit_swap = pConf->lcd_control.ttl_config->bit_swap;
 			break;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
-			break;
-#endif
 		default:
 			break;
 	}
@@ -4067,20 +978,15 @@ static void save_lcd_config(Lcd_Config_t *pConf)
 	temp_vadj_brightness = pConf->lcd_effect.vadj_brightness;
 	temp_vadj_contrast = pConf->lcd_effect.vadj_contrast;
 	temp_vadj_saturation = pConf->lcd_effect.vadj_saturation;
-	
-	last_h_active = pConf->lcd_basic.h_active;
-	last_v_active = pConf->lcd_basic.v_active;
 }
 
 static void reset_lcd_config(Lcd_Config_t *pConf)
 {
-	int res = 0;
+	printk("reset lcd config.\n");
 	
+	_disable_backlight();
 	_lcd_module_disable();
-	printk("reset lcd config.\n");
 	mdelay(200);
-	if ((pConf->lcd_basic.h_active != temp_lcd_basic.h_active) || (pConf->lcd_basic.v_active != temp_lcd_basic.v_active))
-		res = 1;
 	
 	pConf->lcd_basic.h_active = temp_lcd_basic.h_active;
 	pConf->lcd_basic.v_active = temp_lcd_basic.v_active;
@@ -4103,7 +1009,7 @@ static void reset_lcd_config(Lcd_Config_t *pConf)
 	pConf->lcd_timing.de_valid = temp_lcd_timing.de_valid;
 	pConf->lcd_timing.h_offset = temp_lcd_timing.h_offset;
 	pConf->lcd_timing.v_offset = temp_lcd_timing.v_offset;
-	pConf->lcd_timing.pol_cntl_addr = temp_lcd_timing.pol_cntl_addr;
+	pConf->lcd_timing.pol_ctrl = temp_lcd_timing.pol_ctrl;
 	
 	pConf->lcd_effect.dith_user = temp_dith_user;
 	pConf->lcd_effect.dith_cntl_addr = temp_dith_ctrl;
@@ -4112,7 +1018,6 @@ static void reset_lcd_config(Lcd_Config_t *pConf)
 	pConf->lcd_effect.vadj_saturation = temp_vadj_saturation;
 	
 	switch (pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
 		case LCD_DIGITAL_MIPI:
 			pConf->lcd_control.mipi_config->lane_num = temp_dsi_lane_num;
 			pConf->lcd_control.mipi_config->bit_rate_min = temp_dsi_bit_rate_min;
@@ -4120,16 +1025,12 @@ static void reset_lcd_config(Lcd_Config_t *pConf)
 			pConf->lcd_control.mipi_config->factor_denominator = temp_factor_denominator;
 			pConf->lcd_control.mipi_config->factor_numerator = temp_factor_numerator;
 			break;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
 		case LCD_DIGITAL_EDP:
-			//restore edp link config, for they are translate from user value to reg value
 			pConf->lcd_control.edp_config->link_rate = temp_edp_link_rate;
 			pConf->lcd_control.edp_config->lane_count = temp_edp_lane_count;
 			pConf->lcd_control.edp_config->vswing = temp_edp_vswing;
 			pConf->lcd_control.edp_config->preemphasis = temp_edp_preemphasis;
 			break;
-#endif
 		case LCD_DIGITAL_LVDS:
 			pConf->lcd_control.lvds_config->lvds_repack = temp_lvds_repack;
 			pConf->lcd_control.lvds_config->pn_swap = temp_pn_swap;
@@ -4139,42 +1040,20 @@ static void reset_lcd_config(Lcd_Config_t *pConf)
 			pConf->lcd_control.ttl_config->rb_swap = temp_ttl_rb_swap;
 			pConf->lcd_control.ttl_config->bit_swap = temp_ttl_bit_swap;
 			break;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-		case LCD_DIGITAL_MINILVDS:
-			break;
-#endif
 		default:
 			break;
 	}
 	
-	lcd_config_init(pDev->pConf);
+	lcd_config_init(pConf);
+	_init_vout();
 	_lcd_module_enable();
-	
-	pDev->lcd_info.sync_duration_num = pDev->pConf->lcd_timing.sync_duration_num;
-    pDev->lcd_info.sync_duration_den = pDev->pConf->lcd_timing.sync_duration_den;
-	if (res) {
-		pDev->lcd_info.width = pDev->pConf->lcd_basic.h_active;
-		pDev->lcd_info.height = pDev->pConf->lcd_basic.v_active;
-		pDev->lcd_info.field_height = pDev->pConf->lcd_basic.v_active;
-	
-		if (vpp2_sel)
-			WRITE_LCD_REG(VPP2_POSTBLEND_H_SIZE, pDev->lcd_info.width);
-		else
-			WRITE_LCD_REG(VPP_POSTBLEND_H_SIZE, pDev->lcd_info.width);
-		
-		last_h_active = pConf->lcd_basic.h_active;
-		last_v_active = pConf->lcd_basic.v_active;
-		
-		printk("\nPlease input below commands:\n");
-		printk("echo 0 > /sys/class/graphics/fb0/free_scale\n\n");
-	}
+	_enable_backlight();
 }
 
 static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
 {
 	unsigned int ret;
 	unsigned t[6];
-	unsigned venc_video_mode, venc_test_base;
 	
 	switch (buf[0]) {
 		case 'b':	//write basic config
@@ -4201,48 +1080,10 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 			else if (buf[1] == 'e') {//test
 				t[0] = 0;
 				ret = sscanf(buf, "test %d", &t[0]);
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-				if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
-					venc_video_mode = ENCT_VIDEO_MODE_ADV;
-					venc_test_base = ENCT_TST_EN;
-				}
-				else {
-					venc_video_mode = ENCL_VIDEO_MODE_ADV;
-					venc_test_base = ENCL_TST_EN;
-				}
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-				venc_video_mode = ENCL_VIDEO_MODE_ADV;
-				venc_test_base = ENCL_TST_EN;
-#endif				
-				switch (t[0]) {
-					case 0:
-						WRITE_LCD_REG(venc_video_mode, 0x8);
-						printk("disable bist pattern\n");
-						break;
-					case 1:
-						WRITE_LCD_REG(venc_video_mode, 0);
-						WRITE_LCD_REG((venc_test_base+1), 1);
-						WRITE_LCD_REG((venc_test_base+5), pDev->pConf->lcd_timing.video_on_pixel);
-						WRITE_LCD_REG((venc_test_base+6), (pDev->pConf->lcd_basic.h_active / 9));
-						WRITE_LCD_REG(venc_test_base, 1);
-						printk("show bist pattern 1\n");
-						break;
-					case 2:
-						WRITE_LCD_REG(venc_video_mode, 0);
-						WRITE_LCD_REG((venc_test_base+1), 2);
-						WRITE_LCD_REG(venc_test_base, 1);
-						printk("show bist pattern 2\n");
-						break;
-					case 3:
-						WRITE_LCD_REG(venc_video_mode, 0);
-						WRITE_LCD_REG((venc_test_base+1), 3);
-						WRITE_LCD_REG(venc_test_base, 1);
-						printk("show bist pattern 3\n");
-						break;
-					default:
-						printk("un-support pattern num\n");
-						break;
-				}
+				if (pDev->pConf->lcd_misc_ctrl.lcd_status == 0)
+					printk("lcd has already OFF, can't display test pattern\n");
+				else
+					pDev->pConf->lcd_misc_ctrl.lcd_test(t[0]);
 			}
 			else if (buf[1] == 't') {//ttl
 				t[0] = 0;
@@ -4259,8 +1100,8 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 			t[2] = 0;
 			ret = sscanf(buf, "clock %d %d %d", &t[0], &t[1], &t[2]);
 			pDev->pConf->lcd_timing.lcd_clk = t[0];
-			pDev->pConf->lcd_timing.clk_ctrl = ((pDev->pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_SS)) | ((t[1] << CLK_CTRL_SS) | (1 << CLK_CTRL_AUTO)));
-			pDev->pConf->lcd_timing.pol_cntl_addr = ((pDev->pConf->lcd_timing.pol_cntl_addr & ~(1 << LCD_CPH1_POL)) | (t[2] << LCD_CPH1_POL));
+			pDev->pConf->lcd_timing.clk_ctrl = ((pDev->pConf->lcd_timing.clk_ctrl & ~((1 << CLK_CTRL_AUTO) | (0xf << CLK_CTRL_SS))) | ((1 << CLK_CTRL_AUTO) | (t[1] << CLK_CTRL_SS)));
+			pDev->pConf->lcd_timing.pol_ctrl = ((pDev->pConf->lcd_timing.pol_ctrl & ~(1 << POL_CTRL_CLK)) | (t[2] << POL_CTRL_CLK));
 			printk("lcd_clk=%dHz, ss_level=%d, clk_pol=%s\n", t[0], t[1], ((t[2] == 0) ? "negative" : "positive"));
 			break;
 		case 's'://sync
@@ -4275,11 +1116,11 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 			pDev->pConf->lcd_timing.hsync_bp = t[1];
 			pDev->pConf->lcd_timing.vsync_width = t[3];
 			pDev->pConf->lcd_timing.vsync_bp = t[4];
-			pDev->pConf->lcd_timing.pol_cntl_addr = ((pDev->pConf->lcd_timing.pol_cntl_addr & ~((1 << LCD_HS_POL) | (1 << LCD_VS_POL))) | ((t[2] << LCD_HS_POL) | (t[5] << LCD_VS_POL)));
+			pDev->pConf->lcd_timing.pol_ctrl = ((pDev->pConf->lcd_timing.pol_ctrl & ~((1 << POL_CTRL_HS) | (1 << POL_CTRL_VS))) | ((t[2] << POL_CTRL_HS) | (t[5] << POL_CTRL_VS)));
 			printk("hs_width=%d, hs_bp=%d, hs_pol=%s, vs_width=%d, vs_bp=%d, vs_pol=%s\n", t[0], t[1], ((t[2] == 0) ? "negative" : "positive"), t[3], t[4], ((t[5] == 0) ? "negative" : "positive"));
 			break;
 		case 'v':
-			if (buf[2] == 'l') {	//valid
+			if (buf[2] == 'l') { //valid
 				t[0] = 0;
 				t[1] = 0;
 				t[2] = 1;
@@ -4288,7 +1129,7 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 				pDev->pConf->lcd_timing.de_valid = t[1];
 				printk("hvsync: %s, de: %s\n", ((t[0] == 0) ? "disable" : "enable"), ((t[1] == 0) ? "disable" : "enable"));
 			}
-			else if (buf[2] == 'd') {	//vadj
+			else if (buf[2] == 'd') { //vadj
 				t[0] = 0x0;
 				t[1] = 0x80;
 				t[2] = 0x100;
@@ -4319,19 +1160,18 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 			pDev->pConf->lcd_control.lvds_config->pn_swap = t[2];
 			printk("vswing_level: %u, lvds_repack: %s, rb_swap: %s\n", t[0], ((t[1] == 1) ? "VESA mode" : "JEIDA mode"), ((t[2] == 0) ? "disable" : "enable"));
 			break;
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        case 'm':	//write mipi config
-            t[0] = 0;
-            t[1] = 0;
-            t[2] = 0;
-            ret = sscanf(buf, "mdsi %d %d %d", &t[0],&t[1],&t[2]);
-            pDev->pConf->lcd_control.mipi_config->bit_rate_min = t[0]*1000;
-            pDev->pConf->lcd_control.mipi_config->bit_rate_max = t[1]*1000;
-            pDev->pConf->lcd_control.mipi_config->factor_numerator=t[2];
-            pDev->pConf->lcd_control.mipi_config->factor_denominator=10;
-            lcd_config_init(pDev->pConf);
-            printk("dsi bit_rate min=%dMHz, max=%dMHz, factor=%d",t[0], t[1], pDev->pConf->lcd_control.mipi_config->factor_numerator=t[2]);
-            break;
+#ifdef CONFIG_LCD_IF_MIPI_VALID
+		case 'm':	//write mipi config
+			t[0] = 0;
+			t[1] = 0;
+			t[2] = 0;
+			ret = sscanf(buf, "mdsi %d %d %d", &t[0],&t[1],&t[2]);
+			pDev->pConf->lcd_control.mipi_config->bit_rate_min = t[0]*1000;
+			pDev->pConf->lcd_control.mipi_config->bit_rate_max = t[1]*1000;
+			pDev->pConf->lcd_control.mipi_config->factor_numerator=t[2];
+			pDev->pConf->lcd_control.mipi_config->factor_denominator=10;
+			printk("dsi bit_rate min=%dMHz, max=%dMHz, factor=%d\n",t[0], t[1], pDev->pConf->lcd_control.mipi_config->factor_numerator=t[2]);
+			break;
 #endif
 		case 'd':
 			if (buf[2] == 't') {
@@ -4345,7 +1185,7 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 			else {
 				printk("power off lcd.\n");
 				_disable_backlight();
-				lcd_power_ctrl(OFF);
+				pDev->pConf->lcd_power_ctrl.power_ctrl(OFF);
 			}
 			break;
 		case 'w':	//update display config
@@ -4357,29 +1197,24 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 				_lcd_module_disable();
 				mdelay(200);
 				lcd_config_init(pDev->pConf);
+				_init_vout();
 				_lcd_module_enable();
-				scale_framebuffer();
 			}
 			break;
 		case 'r':	
-			if (buf[2] == 'a') {	//read lcd config
+			if (buf[2] == 'a') { //read lcd config
 				read_current_lcd_config(pDev->pConf);
 			}
-			else if (buf[2] == 's') {	//reset lcd config
+			else if (buf[2] == 's') { //reset lcd config
 				reset_lcd_config(pDev->pConf);
 			}
 			break;
 		case 'e':
 			if (buf[1] == 'n') {
 				printk("power on lcd.\n");
-				if (pDev->pConf->lcd_basic.lcd_type != LCD_DIGITAL_TTL) {
-					init_phy_lvds(pDev->pConf);	
-				}
-				_init_lcd_driver(pDev->pConf);
-				lcd_power_ctrl(ON);
-				_enable_backlight();
+				_lcd_module_enable();
 			}
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
+#ifdef CONFIG_LCD_IF_EDP_VALID
 			else if (buf[1] == 'd') {
 				t[0] = 1;
 				t[1] = 4;
@@ -4399,9 +1234,12 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 						break;
 				}
 				pDev->pConf->lcd_control.edp_config->vswing = t[2];
-				printk("set edp link_rate = %sGbps, lane_count = %u, vswing_level = %u\n", ((pDev->pConf->lcd_control.edp_config->link_rate == 0) ? "1.62" : "2.70"), pDev->pConf->lcd_control.edp_config->lane_count, pDev->pConf->lcd_control.edp_config->vswing);
+				printk("set edp link_rate = %s, lane_count = %u, vswing_level = %u\n", ((pDev->pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pDev->pConf->lcd_control.edp_config->lane_count, pDev->pConf->lcd_control.edp_config->vswing);
 			}
 #endif
+			else {
+				printk("wrong format of lcd debug command.\n");
+			}
 			break;
 		default:
 			printk("wrong format of lcd debug command.\n");
@@ -4416,7 +1254,7 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 
 static ssize_t lcd_status_read(struct class *class, struct class_attribute *attr, char *buf)
 {
-	return sprintf(buf, "read lcd status: %s\n", (lcd_status_flag ? "ON":"OFF"));
+	return sprintf(buf, "read lcd status: %s\n", (pDev->pConf->lcd_misc_ctrl.lcd_status ? "ON":"OFF"));
 }
 
 static ssize_t lcd_status_write(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
@@ -4427,7 +1265,7 @@ static ssize_t lcd_status_write(struct class *class, struct class_attribute *att
 	temp = 1;
 	ret = sscanf(buf, "%d", &temp);
 	if (temp) {
-		if (lcd_status_flag == 0) {
+		if (pDev->pConf->lcd_misc_ctrl.lcd_status == 0) {
 			mutex_lock(&lcd_vout_mutex);
 			_lcd_module_enable();
 			_enable_backlight();
@@ -4438,7 +1276,7 @@ static ssize_t lcd_status_write(struct class *class, struct class_attribute *att
 		}
 	}
 	else {
-		if (lcd_status_flag == 1) {
+		if (pDev->pConf->lcd_misc_ctrl.lcd_status == 1) {
 			mutex_lock(&lcd_vout_mutex);
 			_disable_backlight();
 			_lcd_module_disable();
@@ -4460,15 +1298,52 @@ static struct class_attribute lcd_debug_class_attrs[] = {
 	__ATTR(debug,  S_IRUGO | S_IWUSR, lcd_debug_help, lcd_debug),
 	__ATTR(help,  S_IRUGO | S_IWUSR, lcd_debug_help, NULL),
 	__ATTR(status,  S_IRUGO | S_IWUSR, lcd_status_read, lcd_status_write),
-    __ATTR_NULL
 };
 
-static struct class aml_lcd_debug_class = {
-    .name = "lcd",
-    .class_attrs = lcd_debug_class_attrs,
-};
+static int creat_lcd_attr(void)
+{
+    int i;
+
+    pDev->pConf->lcd_misc_ctrl.debug_class = class_create(THIS_MODULE, "lcd");
+    if(IS_ERR(pDev->pConf->lcd_misc_ctrl.debug_class)) {
+        printk("create lcd debug class fail\n");
+        return -1;
+    }
+
+    for(i=0;i<ARRAY_SIZE(lcd_debug_class_attrs);i++) {
+        if (class_create_file(pDev->pConf->lcd_misc_ctrl.debug_class, &lcd_debug_class_attrs[i])) {
+            printk("create lcd debug attribute %s fail\n", lcd_debug_class_attrs[i].attr.name);
+        }
+    }
+
+    return 0;
+}
+
+static int remove_lcd_attr(void)
+{
+    int i;
+
+    if (pDev->pConf->lcd_misc_ctrl.debug_class == NULL)
+        return -1;
+
+    for(i=0;i<ARRAY_SIZE(lcd_debug_class_attrs);i++) {
+        class_remove_file(pDev->pConf->lcd_misc_ctrl.debug_class, &lcd_debug_class_attrs[i]);
+    }
+    class_destroy(pDev->pConf->lcd_misc_ctrl.debug_class);
+
+    return 0;
+}
 //****************************
 
+static int lcd_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
+ {
+	printk("[%s]: %lu\n", __FUNCTION__, state);
+	_disable_backlight();
+	_lcd_module_disable();
+
+    return NOTIFY_DONE;
+}
+
 static int amlogic_pmu_gpio_name_map_num(const char *name)
 {
 	int index;
@@ -4481,28 +1356,40 @@ static int amlogic_pmu_gpio_name_map_num(const char *name)
 }
 
 #ifdef CONFIG_USE_OF
-static inline int _get_lcd_model_timing(struct platform_device *pdev)
+#define LCD_MODEL_LEN_MAX    30
+static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pdev)
 {
 	int ret=0;
 	const char *str;
 	unsigned int val;
-	unsigned int lcd_para[100];
+	//unsigned int lcd_para[100];
+	unsigned int *lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*100, GFP_KERNEL);
 	int i, j;
 	struct device_node *lcd_model_node;
 	phandle fhandle;
 	
+	if (lcd_para == NULL) {
+		printk("[_get_lcd_model_timing]: Not enough memory\n");
+		return -1;
+	}
 	if (pdev->dev.of_node) {
 		ret = of_property_read_u32(pdev->dev.of_node,"lcd_model_config",&fhandle);
 		lcd_model_node = of_find_node_by_phandle(fhandle);
 		ret = of_property_read_string(lcd_model_node,"model_name", &str);
 		if(ret) {
-			pDev->pConf->lcd_basic.model_name = "none";
+			str = "none";
 			printk("lcd: faild to get lcd_model_name!\n");
 		}
+		pConf->lcd_basic.model_name = (char *)kmalloc(sizeof(char)*LCD_MODEL_LEN_MAX, GFP_KERNEL);
+		if (pConf->lcd_basic.model_name == NULL) {
+			printk("[_get_lcd_model_timing]: Not enough memory\n");
+		}
 		else {
-			pDev->pConf->lcd_basic.model_name = str;
-			printk("load lcd model in dtb: %s\n", str);
+			memset(pConf->lcd_basic.model_name, 0, LCD_MODEL_LEN_MAX);
+			strcpy(pConf->lcd_basic.model_name, str);
+			printk("load lcd model in dtb: %s\n", pConf->lcd_basic.model_name);
 		}
+		
 		ret = of_property_read_string(lcd_model_node, "interface", &str);
 		if (ret) {
 			printk("faild to get lcd_type!\n");
@@ -4512,266 +1399,280 @@ static inline int _get_lcd_model_timing(struct platform_device *pdev)
 			if(!strcasecmp(str, lcd_type_table[val]))
 				break;
 		}		
-		pDev->pConf->lcd_basic.lcd_type = val;
-		DBG_PRINT("lcd_type= %s(%u),\n", lcd_type_table[pDev->pConf->lcd_basic.lcd_type], pDev->pConf->lcd_basic.lcd_type);
+		pConf->lcd_basic.lcd_type = val;
+		DBG_PRINT("lcd_type= %s(%u)\n", lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_type);
 		ret = of_property_read_u32_array(lcd_model_node,"active_area",&lcd_para[0],2);
 		if(ret){
 			printk("faild to get active_area\n");
 		}
 		else {
-			pDev->pConf->lcd_basic.h_active_area = lcd_para[0];
-			pDev->pConf->lcd_basic.v_active_area = lcd_para[1];
-			pDev->pConf->lcd_basic.screen_ratio_width = lcd_para[0];
-			pDev->pConf->lcd_basic.screen_ratio_height = lcd_para[1];
+			pConf->lcd_basic.h_active_area = lcd_para[0];
+			pConf->lcd_basic.v_active_area = lcd_para[1];
+			pConf->lcd_basic.screen_ratio_width = lcd_para[0];
+			pConf->lcd_basic.screen_ratio_height = lcd_para[1];
 		}
-		DBG_PRINT("h_active_area = %u, v_active_area =%u\n", pDev->pConf->lcd_basic.h_active_area, pDev->pConf->lcd_basic.v_active_area);
+		DBG_PRINT("h_active_area = %umm, v_active_area =%umm\n", pConf->lcd_basic.h_active_area, pConf->lcd_basic.v_active_area);
 		ret = of_property_read_u32_array(lcd_model_node,"lcd_bits_option",&lcd_para[0],2);
 		if(ret){
 			printk("faild to get lcd_bits_option\n");
 		}
 		else {
-			pDev->pConf->lcd_basic.lcd_bits = (unsigned short)(lcd_para[0]);
-			pDev->pConf->lcd_basic.lcd_bits_option = (unsigned short)(lcd_para[1]);
+			pConf->lcd_basic.lcd_bits = (unsigned short)(lcd_para[0]);
+			pConf->lcd_basic.lcd_bits_option = (unsigned short)(lcd_para[1]);
 		}
-		DBG_PRINT("lcd_bits = %u, lcd_bits_option = %u\n", pDev->pConf->lcd_basic.lcd_bits, pDev->pConf->lcd_basic.lcd_bits_option);
+		DBG_PRINT("lcd_bits = %u, lcd_bits_option = %u\n", pConf->lcd_basic.lcd_bits, pConf->lcd_basic.lcd_bits_option);
 		ret = of_property_read_u32_array(lcd_model_node,"resolution", &lcd_para[0], 2);
 		if(ret){
 			printk("faild to get resolution\n");
 		}
 		else {
-			pDev->pConf->lcd_basic.h_active = (unsigned short)(lcd_para[0]);
-			pDev->pConf->lcd_basic.v_active = (unsigned short)(lcd_para[1]);
+			pConf->lcd_basic.h_active = (unsigned short)(lcd_para[0]);
+			pConf->lcd_basic.v_active = (unsigned short)(lcd_para[1]);
 		}		
 		ret = of_property_read_u32_array(lcd_model_node,"period",&lcd_para[0],2);
 		if(ret){
 			printk("faild to get period\n");
 		}
 		else {
-			pDev->pConf->lcd_basic.h_period = (unsigned short)(lcd_para[0]);
-			pDev->pConf->lcd_basic.v_period = (unsigned short)(lcd_para[1]);
+			pConf->lcd_basic.h_period = (unsigned short)(lcd_para[0]);
+			pConf->lcd_basic.v_period = (unsigned short)(lcd_para[1]);
 		}
-		DBG_PRINT("h_active = %u, v_active =%u, h_period = %u, v_period = %u\n", pDev->pConf->lcd_basic.h_active, pDev->pConf->lcd_basic.v_active, pDev->pConf->lcd_basic.h_period, pDev->pConf->lcd_basic.v_period);
+		DBG_PRINT("h_active = %u, v_active =%u, h_period = %u, v_period = %u\n", pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, pConf->lcd_basic.h_period, pConf->lcd_basic.v_period);
 		ret = of_property_read_u32_array(lcd_model_node,"clock_hz_pol",&lcd_para[0], 2);
 		if(ret){
 			printk("faild to get clock_hz_pol\n");
 		}
 		else {
-			pDev->pConf->lcd_timing.lcd_clk = lcd_para[0];
-			pDev->pConf->lcd_timing.pol_cntl_addr = (lcd_para[1] << LCD_CPH1_POL);
+			pConf->lcd_timing.lcd_clk = lcd_para[0];
+			pConf->lcd_timing.pol_ctrl = (lcd_para[1] << POL_CTRL_CLK);
 		}
-		DBG_PRINT("pclk = %uHz, pol=%u\n", pDev->pConf->lcd_timing.lcd_clk, (pDev->pConf->lcd_timing.pol_cntl_addr >> LCD_CPH1_POL) & 1);
+		DBG_PRINT("pclk = %uHz, pol=%u\n", pConf->lcd_timing.lcd_clk, (pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1);
 		ret = of_property_read_u32_array(lcd_model_node,"hsync_width_backporch",&lcd_para[0], 2);
 		if(ret){
 			printk("faild to get hsync_width_backporch\n");
 		}
 		else {
-			pDev->pConf->lcd_timing.hsync_width = (unsigned short)(lcd_para[0]);
-			pDev->pConf->lcd_timing.hsync_bp = (unsigned short)(lcd_para[1]);
+			pConf->lcd_timing.hsync_width = (unsigned short)(lcd_para[0]);
+			pConf->lcd_timing.hsync_bp = (unsigned short)(lcd_para[1]);
 		}
-		DBG_PRINT("hsync width = %u, backporch = %u\n", pDev->pConf->lcd_timing.hsync_width, pDev->pConf->lcd_timing.hsync_bp);
+		DBG_PRINT("hsync width = %u, backporch = %u\n", pConf->lcd_timing.hsync_width, pConf->lcd_timing.hsync_bp);
 		ret = of_property_read_u32_array(lcd_model_node,"vsync_width_backporch",&lcd_para[0], 2);
 		if(ret){
 			printk("faild to get vsync_width_backporch\n");
 		}
 		else {
-			pDev->pConf->lcd_timing.vsync_width = (unsigned short)(lcd_para[0]);
-			pDev->pConf->lcd_timing.vsync_bp = (unsigned short)(lcd_para[1]);
+			pConf->lcd_timing.vsync_width = (unsigned short)(lcd_para[0]);
+			pConf->lcd_timing.vsync_bp = (unsigned short)(lcd_para[1]);
 		}
-		DBG_PRINT("vsync width = %u, backporch = %u\n", pDev->pConf->lcd_timing.vsync_width, pDev->pConf->lcd_timing.vsync_bp);
+		DBG_PRINT("vsync width = %u, backporch = %u\n", pConf->lcd_timing.vsync_width, pConf->lcd_timing.vsync_bp);
 		ret = of_property_read_u32_array(lcd_model_node,"pol_hsync_vsync",&lcd_para[0], 2);
 		if(ret){
 			printk("faild to get pol_hsync_vsync\n");
 		}
 		else {
-			pDev->pConf->lcd_timing.pol_cntl_addr = (pDev->pConf->lcd_timing.pol_cntl_addr & ~((1 << LCD_HS_POL) | (1 << LCD_VS_POL))) | ((lcd_para[0] << LCD_HS_POL) | (lcd_para[1] << LCD_VS_POL));
+			pConf->lcd_timing.pol_ctrl = (pConf->lcd_timing.pol_ctrl & ~((1 << POL_CTRL_HS) | (1 << POL_CTRL_VS))) | ((lcd_para[0] << POL_CTRL_HS) | (lcd_para[1] << POL_CTRL_VS));
 		}
-		DBG_PRINT("pol hsync = %u, vsync = %u\n", (pDev->pConf->lcd_timing.pol_cntl_addr >> LCD_HS_POL) & 1, (pDev->pConf->lcd_timing.pol_cntl_addr >> LCD_VS_POL) & 1);
+		DBG_PRINT("pol hsync = %u, vsync = %u\n", (pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1, (pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1);
 		ret = of_property_read_u32_array(lcd_model_node,"vsync_horizontal_phase",&lcd_para[0], 2);
 		if(ret){
 			printk("faild to get vsync_horizontal_phase\n");
-			pDev->pConf->lcd_timing.vsync_h_phase = 0;
+			pConf->lcd_timing.vsync_h_phase = 0;
 		} else {
-			pDev->pConf->lcd_timing.vsync_h_phase = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
+			pConf->lcd_timing.vsync_h_phase = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
 		}
 		if (lcd_para[0] == 0)
 			DBG_PRINT("vsync_horizontal_phase= %d\n", lcd_para[1]);
 		else
 			DBG_PRINT("vsync_horizontal_phase= -%d\n", lcd_para[1]);
 
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-        if (LCD_DIGITAL_MIPI == pDev->pConf->lcd_basic.lcd_type) {
+        if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_MIPI) {
             ret = of_property_read_u32(lcd_model_node,"dsi_lane_num",&val);
             if(ret){
                 printk("faild to get dsi_lane_num\n");
-                pDev->pConf->lcd_control.mipi_config->lane_num = 4;
+                pConf->lcd_control.mipi_config->lane_num = 4;
             }
             else {
-                pDev->pConf->lcd_control.mipi_config->lane_num = (unsigned char)val;
+                pConf->lcd_control.mipi_config->lane_num = (unsigned char)val;
             }
-            DBG_PRINT("dsi_lane_num= %d\n",  pDev->pConf->lcd_control.mipi_config->lane_num);
+            DBG_PRINT("dsi_lane_num= %d\n",  pConf->lcd_control.mipi_config->lane_num);
             ret = of_property_read_u32_array(lcd_model_node,"dsi_bit_rate_min_max",&lcd_para[0], 2);
             if(ret){
                 printk("faild to get dsi_bit_rate_min_max\n");
                 lcd_para[0] = 0;
                 lcd_para[1] = 0;
             }
-            pDev->pConf->lcd_control.mipi_config->bit_rate_min = lcd_para[0];
-            pDev->pConf->lcd_control.mipi_config->bit_rate_max = lcd_para[1];
-            DBG_PRINT("dsi_bit_rate_min= %dMHz max=%dMHz\n", lcd_para[0], lcd_para[1]);
+            pConf->lcd_control.mipi_config->bit_rate_min = lcd_para[0];
+            pConf->lcd_control.mipi_config->bit_rate_max = lcd_para[1];
+            DBG_PRINT("dsi bit_rate min = %dMHz max = %dMHz\n", lcd_para[0], lcd_para[1]);
             ret = of_property_read_u32(lcd_model_node,"pclk_lanebyteclk_factor",&val);
             if(ret){
                 printk("faild to get pclk_lanebyteclk_factor\n");
-                pDev->pConf->lcd_control.mipi_config->factor_numerator = 0;
+                pConf->lcd_control.mipi_config->factor_numerator = 0;
             }
             else {
-                pDev->pConf->lcd_control.mipi_config->factor_numerator = val;
+                pConf->lcd_control.mipi_config->factor_numerator = val;
             }
-            pDev->pConf->lcd_control.mipi_config->factor_denominator = 10;
-            DBG_PRINT("pclk_lanebyteclk factor= %d\n", pDev->pConf->lcd_control.mipi_config->factor_numerator);
+            pConf->lcd_control.mipi_config->factor_denominator = 10;
+            DBG_PRINT("pclk_lanebyteclk factor= %d\n", pConf->lcd_control.mipi_config->factor_numerator);
             ret = of_property_read_u32_array(lcd_model_node,"dsi_operation_mode",&lcd_para[0], 2);
             if(ret){
                 printk("faild to get dsi_operation_mode\n");
-                pDev->pConf->lcd_control.mipi_config->operation_mode = ((OPERATION_COMMAND_MODE << BIT_OPERATION_MODE_INIT) | (OPERATION_VIDEO_MODE << BIT_OPERATION_MODE_DISP));
+                pConf->lcd_control.mipi_config->operation_mode = ((1 << BIT_OPERATION_MODE_INIT) | (0 << BIT_OPERATION_MODE_DISP));
             }
             else {
-                pDev->pConf->lcd_control.mipi_config->operation_mode = ((lcd_para[0] << BIT_OPERATION_MODE_INIT) | (lcd_para[1] << BIT_OPERATION_MODE_DISP));
+                pConf->lcd_control.mipi_config->operation_mode = ((lcd_para[0] << BIT_OPERATION_MODE_INIT) | (lcd_para[1] << BIT_OPERATION_MODE_DISP));
             }
-            DBG_PRINT("dsi_operation_mode init=%d, display=%d\n", (pDev->pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1, (pDev->pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
+            DBG_PRINT("dsi_operation_mode init=%d, display=%d\n", (pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1, (pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
             ret = of_property_read_u32_array(lcd_model_node,"dsi_transfer_ctrl",&lcd_para[0], 2);
             if(ret){
                 printk("faild to get dsi_transfer_ctrl\n");
-                pDev->pConf->lcd_control.mipi_config->transfer_ctrl = ((0 << BIT_TRANS_CTRL_CLK) | (0 << BIT_TRANS_CTRL_SWITCH));
+                pConf->lcd_control.mipi_config->transfer_ctrl = ((0 << BIT_TRANS_CTRL_CLK) | (0 << BIT_TRANS_CTRL_SWITCH));
             }
             else {
-                pDev->pConf->lcd_control.mipi_config->transfer_ctrl = ((lcd_para[0] << BIT_TRANS_CTRL_CLK) | (lcd_para[1] << BIT_TRANS_CTRL_SWITCH));
+                pConf->lcd_control.mipi_config->transfer_ctrl = ((lcd_para[0] << BIT_TRANS_CTRL_CLK) | (lcd_para[1] << BIT_TRANS_CTRL_SWITCH));
             }
-            DBG_PRINT("dsi_transfer_ctrl clk=%d, switch=%d\n", (pDev->pConf->lcd_control.mipi_config->transfer_ctrl >> BIT_TRANS_CTRL_CLK) & 1, (pDev->pConf->lcd_control.mipi_config->transfer_ctrl >> BIT_TRANS_CTRL_SWITCH) & 3);
+            DBG_PRINT("dsi_transfer_ctrl clk=%d, switch=%d\n", (pConf->lcd_control.mipi_config->transfer_ctrl >> BIT_TRANS_CTRL_CLK) & 1, (pConf->lcd_control.mipi_config->transfer_ctrl >> BIT_TRANS_CTRL_SWITCH) & 3);
             //detect dsi init on table
-            pDev->pConf->lcd_control.mipi_config->dsi_init_on = get_dsi_init_table(1);//dsi_init_on
-            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", 0, &lcd_para[0]);
-            if (ret) {
-                printk("faild to get dsi_init_on\n");
-            }
-            else {
-                i = 0;
-                while (i < DSI_INIT_ON_MAX) {
-                    ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", i, &val);
-                    if (val == 0xff) {
-                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+1), &val);
-                        i += 2;
-                        if (val == 0xff)
-                            break;
-                    }
-                    else {
-                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+2), &val);
-                        i = i + 3 + val;
-                    }
-                }
-                ret = of_property_read_u32_array(lcd_model_node,"dsi_init_on", &lcd_para[0], i);
-                if(ret){
+            if (pConf->lcd_control.mipi_config->dsi_init_on != NULL) {
+                ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", 0, &lcd_para[0]);
+                if (ret) {
                     printk("faild to get dsi_init_on\n");
                 }
                 else {
-                    DBG_PRINT("dsi_init_on: ");
-                    for (j=0; j<i; j++) {
-                        pDev->pConf->lcd_control.mipi_config->dsi_init_on[j] = (unsigned char)(lcd_para[j] & 0xff);
-                        DBG_PRINT("0x%02x ", pDev->pConf->lcd_control.mipi_config->dsi_init_on[j]);
+                    i = 0;
+                    while (i < DSI_INIT_ON_MAX) {
+                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", i, &val);
+                        if (val == 0xff) {
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+1), &val);
+                            i += 2;
+                            if (val == 0xff)
+                                break;
+                        }
+                        else {
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+2), &val);
+                            i = i + 3 + val;
+                        }
                     }
-                    DBG_PRINT("\n");
-                }
-            }
-            //detect dsi init off table
-            pDev->pConf->lcd_control.mipi_config->dsi_init_off = get_dsi_init_table(0);//dsi_init_off
-            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", 0, &lcd_para[0]);
-            if (ret) {
-                printk("faild to get dsi_init_off\n");
-            }
-            else {
-                i = 0;
-                while (i < DSI_INIT_OFF_MAX) {
-                    ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", i, &val);
-                    if (val == 0xff) {
-                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+1), &val);
-                        i += 2;
-                        if (val == 0xff)
-                            break;
+                    ret = of_property_read_u32_array(lcd_model_node,"dsi_init_on", &lcd_para[0], i);
+                    if(ret){
+                        printk("faild to get dsi_init_on\n");
                     }
                     else {
-                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+2), &val);
-                        i = i + 3 + val;
+                        DBG_PRINT("dsi_init_on: ");
+                        for (j=0; j<i; j++) {
+                            pConf->lcd_control.mipi_config->dsi_init_on[j] = (unsigned char)(lcd_para[j] & 0xff);
+                            DBG_PRINT("0x%02x ", pConf->lcd_control.mipi_config->dsi_init_on[j]);
+                        }
+                        DBG_PRINT("\n");
                     }
                 }
-                ret = of_property_read_u32_array(lcd_model_node,"dsi_init_off", &lcd_para[0], i);
-                if(ret){
+            }
+            //detect dsi init off table
+            if (pConf->lcd_control.mipi_config->dsi_init_off != NULL) {
+                ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", 0, &lcd_para[0]);
+                if (ret) {
                     printk("faild to get dsi_init_off\n");
                 }
                 else {
-                    DBG_PRINT("dsi_init_off: ");
-                    for (j=0; j<i; j++) {
-                        pDev->pConf->lcd_control.mipi_config->dsi_init_off[j] = (unsigned char)(lcd_para[j] & 0xff);
-                        DBG_PRINT("0x%02x ", pDev->pConf->lcd_control.mipi_config->dsi_init_off[j]);
+                    i = 0;
+                    while (i < DSI_INIT_OFF_MAX) {
+                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", i, &val);
+                        if (val == 0xff) {
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+1), &val);
+                            i += 2;
+                            if (val == 0xff)
+                                break;
+                        }
+                        else {
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+2), &val);
+                            i = i + 3 + val;
+                        }
+                    }
+                    ret = of_property_read_u32_array(lcd_model_node,"dsi_init_off", &lcd_para[0], i);
+                    if(ret){
+                        printk("faild to get dsi_init_off\n");
+                    }
+                    else {
+                        DBG_PRINT("dsi_init_off: ");
+                        for (j=0; j<i; j++) {
+                            pConf->lcd_control.mipi_config->dsi_init_off[j] = (unsigned char)(lcd_para[j] & 0xff);
+                            DBG_PRINT("0x%02x ", pConf->lcd_control.mipi_config->dsi_init_off[j]);
+                        }
+                        DBG_PRINT("\n");
                     }
-                    DBG_PRINT("\n");
                 }
             }
             ret = of_property_read_u32(lcd_model_node,"lcd_extern_init",&val);
             if(ret){
                 printk("faild to get lcd_extern_init\n");
-                pDev->pConf->lcd_control.mipi_config->lcd_extern_init =0;
+                pConf->lcd_control.mipi_config->lcd_extern_init =0;
             } else {
-                pDev->pConf->lcd_control.mipi_config->lcd_extern_init =(unsigned char)(val);
+                pConf->lcd_control.mipi_config->lcd_extern_init =(unsigned char)(val);
             }
-            DBG_PRINT("lcd_extern_init = %d\n",  pDev->pConf->lcd_control.mipi_config->lcd_extern_init);
+            DBG_PRINT("lcd_extern_init = %d\n",  pConf->lcd_control.mipi_config->lcd_extern_init);
+        }
+        else if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
+            ret = of_property_read_u32(lcd_model_node,"max_lane_count",&val);
+            if(ret){
+                printk("faild to get max_lane_count\n");
+                pConf->lcd_control.edp_config->max_lane_count = 4;
+            } else {
+                pConf->lcd_control.edp_config->max_lane_count =(unsigned char)(val);
+            }
+            DBG_PRINT("max_lane_count = %d\n", pConf->lcd_control.edp_config->max_lane_count);
         }
-#endif
     }
+    kfree(lcd_para);
     return ret;
 }
 
-static inline int _get_lcd_default_config(struct platform_device *pdev)
+static int _get_lcd_default_config(Lcd_Config_t *pConf, struct platform_device *pdev)
 {
 	int ret=0;
 	unsigned int val;
 	unsigned int lcd_para[5];
-	unsigned int gamma_temp[256];
+	//unsigned int gamma_temp[256];
+	unsigned int *gamma_temp = (unsigned int *)kmalloc(sizeof(unsigned int)*256, GFP_KERNEL);
 	int i;
 	unsigned int lcd_gamma_multi = 0;
 	
+	if (gamma_temp == NULL) {
+		printk("[_get_lcd_default_config]: Not enough memory\n");
+		return -1;
+	}
 	//pdev->dev.of_node = of_find_node_by_name(NULL,"lcd");
 	if (pdev->dev.of_node) {
-		if (pDev->pConf->lcd_basic.lcd_bits_option == 1) {
+		if (pConf->lcd_basic.lcd_bits_option == 1) {
 			ret = of_property_read_u32(pdev->dev.of_node,"lcd_bits_user",&val);
 			if(ret){
 				printk("don't find to match lcd_bits_user, use panel typical setting.\n");
 			}
 			else {
-				pDev->pConf->lcd_basic.lcd_bits = (unsigned short)(val);
-				printk("lcd_bits = %u\n", pDev->pConf->lcd_basic.lcd_bits);
+				pConf->lcd_basic.lcd_bits = (unsigned short)(val);
+				printk("lcd_bits = %u\n", pConf->lcd_basic.lcd_bits);
 			}
 		}
 		//ttl & lvds config
-		ret = of_property_read_u32_array(pdev->dev.of_node,"ttl_rb_bit_swap",&lcd_para[0], 2);
-		if(ret){
-			printk("don't find to match ttl_rb_bit_swap, use default setting.\n");
-		}
-		else {
-			pDev->pConf->lcd_control.ttl_config->rb_swap = (unsigned char)(lcd_para[0]);
-			pDev->pConf->lcd_control.ttl_config->bit_swap = (unsigned char)(lcd_para[1]);
-			if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL)
-				printk("ttl rb_swap = %u, bit_swap = %u\n", pDev->pConf->lcd_control.ttl_config->rb_swap, pDev->pConf->lcd_control.ttl_config->bit_swap);
-			else
-				DBG_PRINT("ttl rb_swap = %u, bit_swap = %u\n", pDev->pConf->lcd_control.ttl_config->rb_swap, pDev->pConf->lcd_control.ttl_config->bit_swap);
-		}		
-		ret = of_property_read_u32(pdev->dev.of_node,"lvds_channel_pn_swap",&val);
-		if(ret){
-			printk("don't find to match lvds_channel_pn_swap, use default setting.\n");
+		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
+			ret = of_property_read_u32_array(pdev->dev.of_node,"ttl_rb_bit_swap",&lcd_para[0], 2);
+			if(ret){
+				printk("don't find to match ttl_rb_bit_swap, use default setting.\n");
+			}
+			else {
+				pConf->lcd_control.ttl_config->rb_swap = (unsigned char)(lcd_para[0]);
+				pConf->lcd_control.ttl_config->bit_swap = (unsigned char)(lcd_para[1]);
+				printk("ttl rb_swap = %u, bit_swap = %u\n", pConf->lcd_control.ttl_config->rb_swap, pConf->lcd_control.ttl_config->bit_swap);
+			}
 		}
-		else {
-			pDev->pConf->lcd_control.lvds_config->pn_swap = val;
-			if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS)
-				printk("lvds_pn_swap = %u\n", pDev->pConf->lcd_control.lvds_config->pn_swap);
-			else
-				DBG_PRINT("lvds_pn_swap = %u\n", pDev->pConf->lcd_control.lvds_config->pn_swap);
+		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+			ret = of_property_read_u32(pdev->dev.of_node,"lvds_channel_pn_swap",&val);
+			if(ret){
+				printk("don't find to match lvds_channel_pn_swap, use default setting.\n");
+			}
+			else {
+				pConf->lcd_control.lvds_config->pn_swap = val;
+				printk("lvds_pn_swap = %u\n", pConf->lcd_control.lvds_config->pn_swap);
+			}
 		}
 
 		//recommend setting
@@ -4780,51 +1681,49 @@ static inline int _get_lcd_default_config(struct platform_device *pdev)
 			printk("don't find to match valid_hvsync_de, use default setting.\n");
 		}
 		else {
-			pDev->pConf->lcd_timing.hvsync_valid = (unsigned short)(lcd_para[0]);
-			pDev->pConf->lcd_timing.de_valid = (unsigned short)(lcd_para[1]);
-			DBG_PRINT("valid hvsync = %u, de = %u\n", pDev->pConf->lcd_timing.hvsync_valid, pDev->pConf->lcd_timing.de_valid);
+			pConf->lcd_timing.hvsync_valid = (unsigned short)(lcd_para[0]);
+			pConf->lcd_timing.de_valid = (unsigned short)(lcd_para[1]);
+			DBG_PRINT("valid hvsync = %u, de = %u\n", pConf->lcd_timing.hvsync_valid, pConf->lcd_timing.de_valid);
 		}
 		ret = of_property_read_u32_array(pdev->dev.of_node,"hsign_hoffset_vsign_voffset",&lcd_para[0], 4);
 		if(ret){
 			printk("don't find to match hsign_hoffset_vsign_voffset, use default setting.\n");
-			pDev->pConf->lcd_timing.h_offset = 0;
-			pDev->pConf->lcd_timing.v_offset = 0;
+			pConf->lcd_timing.h_offset = 0;
+			pConf->lcd_timing.v_offset = 0;
 		}
 		else {
-			pDev->pConf->lcd_timing.h_offset = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
-			pDev->pConf->lcd_timing.v_offset = ((lcd_para[2] << 31) | ((lcd_para[3] & 0xffff) << 0));
-			DBG_PRINT("h_offset = %s%u, ", (((pDev->pConf->lcd_timing.h_offset >> 31) & 1) ? "-" : ""), (pDev->pConf->lcd_timing.h_offset & 0xffff));
-			DBG_PRINT("v_offset = %s%u\n", (((pDev->pConf->lcd_timing.v_offset >> 31) & 1) ? "-" : ""), (pDev->pConf->lcd_timing.v_offset & 0xffff));
+			pConf->lcd_timing.h_offset = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
+			pConf->lcd_timing.v_offset = ((lcd_para[2] << 31) | ((lcd_para[3] & 0xffff) << 0));
+			DBG_PRINT("h_offset = %s%u, ", (((pConf->lcd_timing.h_offset >> 31) & 1) ? "-" : ""), (pConf->lcd_timing.h_offset & 0xffff));
+			DBG_PRINT("v_offset = %s%u\n", (((pConf->lcd_timing.v_offset >> 31) & 1) ? "-" : ""), (pConf->lcd_timing.v_offset & 0xffff));
 		}
 		ret = of_property_read_u32_array(pdev->dev.of_node,"dither_user_ctrl",&lcd_para[0], 2);
 		if(ret){
 			printk("don't find to match dither_user_ctrl, use default setting.\n");
-			pDev->pConf->lcd_effect.dith_user = 0;
+			pConf->lcd_effect.dith_user = 0;
 		}
 		else {
-			pDev->pConf->lcd_effect.dith_user = (unsigned short)(lcd_para[0]);
-			pDev->pConf->lcd_effect.dith_cntl_addr = (unsigned short)(lcd_para[1]);
-			DBG_PRINT("dither_user = %u, dither_ctrl = 0x%x\n", pDev->pConf->lcd_effect.dith_user, pDev->pConf->lcd_effect.dith_cntl_addr);
+			pConf->lcd_effect.dith_user = (unsigned short)(lcd_para[0]);
+			pConf->lcd_effect.dith_cntl_addr = (unsigned short)(lcd_para[1]);
+			DBG_PRINT("dither_user = %u, dither_ctrl = 0x%x\n", pConf->lcd_effect.dith_user, pConf->lcd_effect.dith_cntl_addr);
 		}
 		ret = of_property_read_u32_array(pdev->dev.of_node,"vadj_brightness_contrast_saturation",&lcd_para[0], 3);
 		if(ret){
 			printk("don't find to match vadj_brightness_contrast_saturation, use default setting.\n");
 		}
 		else {
-			pDev->pConf->lcd_effect.vadj_brightness = lcd_para[0];
-			pDev->pConf->lcd_effect.vadj_contrast = lcd_para[1];
-			pDev->pConf->lcd_effect.vadj_saturation = lcd_para[2];
-			DBG_PRINT("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x\n", pDev->pConf->lcd_effect.vadj_brightness, pDev->pConf->lcd_effect.vadj_contrast, pDev->pConf->lcd_effect.vadj_saturation);
+			pConf->lcd_effect.vadj_brightness = lcd_para[0];
+			pConf->lcd_effect.vadj_contrast = lcd_para[1];
+			pConf->lcd_effect.vadj_saturation = lcd_para[2];
+			DBG_PRINT("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x\n", pConf->lcd_effect.vadj_brightness, pConf->lcd_effect.vadj_contrast, pConf->lcd_effect.vadj_saturation);
 		}
-		ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_en_revert",&lcd_para[0], 2);
+		ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_en_reverse",&lcd_para[0], 2);
 		if(ret){
-			printk("don't find to match gamma_en_revert, use default setting.\n");
+			printk("don't find to match gamma_en_reverse, use default setting.\n");
 		}
 		else {
-			pDev->pConf->lcd_effect.gamma_cntl_port = (lcd_para[0] << LCD_GAMMA_EN);
-			//pDev->pConf->lcd_effect.gamma_vcom_hswitch_addr = 0;
-			pDev->pConf->lcd_effect.gamma_revert = (unsigned char)(lcd_para[1]);
-			DBG_PRINT("gamma_en = %u, gamma_revert=%u\n", ((pDev->pConf->lcd_effect.gamma_cntl_port >> LCD_GAMMA_EN) & 1), pDev->pConf->lcd_effect.gamma_revert);
+			pConf->lcd_effect.gamma_ctrl = ((lcd_para[0] << GAMMA_CTRL_EN) | (lcd_para[1] << GAMMA_CTRL_REVERSE));
+			DBG_PRINT("gamma_en = %u, gamma_reverse=%u\n", ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1), ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
 		}
 		ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_multi_rgb_coeff",&lcd_para[0], 4);
 		if(ret){
@@ -4832,42 +1731,42 @@ static inline int _get_lcd_default_config(struct platform_device *pdev)
 		}
 		else {
 			lcd_gamma_multi = lcd_para[0];
-			pDev->pConf->lcd_effect.gamma_r_coeff = (unsigned short)(lcd_para[1]);
-			pDev->pConf->lcd_effect.gamma_g_coeff = (unsigned short)(lcd_para[2]);
-			pDev->pConf->lcd_effect.gamma_b_coeff = (unsigned short)(lcd_para[3]);
-			DBG_PRINT("gamma_multi = %u, gamma_r_coeff = %u, gamma_g_coeff = %u, gamma_b_coeff = %u\n", lcd_gamma_multi, pDev->pConf->lcd_effect.gamma_r_coeff, pDev->pConf->lcd_effect.gamma_g_coeff, pDev->pConf->lcd_effect.gamma_b_coeff);
+			pConf->lcd_effect.gamma_r_coeff = (unsigned short)(lcd_para[1]);
+			pConf->lcd_effect.gamma_g_coeff = (unsigned short)(lcd_para[2]);
+			pConf->lcd_effect.gamma_b_coeff = (unsigned short)(lcd_para[3]);
+			DBG_PRINT("gamma_multi = %u, gamma_r_coeff = %u, gamma_g_coeff = %u, gamma_b_coeff = %u\n", lcd_gamma_multi, pConf->lcd_effect.gamma_r_coeff, pConf->lcd_effect.gamma_g_coeff, pConf->lcd_effect.gamma_b_coeff);
 		}
 		if (lcd_gamma_multi == 1) {
 			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_r",&gamma_temp[0], 256);
 			if(ret){
 				printk("don't find to match gamma_table_r, use default table.\n");
-				lcd_setup_gamma_table(pDev->pConf, 0);
+				lcd_setup_gamma_table(pConf, 0);
 			}
 			else {
 				for (i=0; i<256; i++) {
-					pDev->pConf->lcd_effect.GammaTableR[i] = (unsigned short)(gamma_temp[i] << 2);
+					pConf->lcd_effect.GammaTableR[i] = (unsigned short)(gamma_temp[i] << 2);
 				}
 				DBG_PRINT("load gamma_table_r.\n");
 			}
 			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_g",&gamma_temp[0], 256);
 			if(ret){
 				printk("don't find to match gamma_table_g, use default table.\n");
-				lcd_setup_gamma_table(pDev->pConf, 1);
+				lcd_setup_gamma_table(pConf, 1);
 			}
 			else {
 				for (i=0; i<256; i++) {
-					pDev->pConf->lcd_effect.GammaTableG[i] = (unsigned short)(gamma_temp[i] << 2);
+					pConf->lcd_effect.GammaTableG[i] = (unsigned short)(gamma_temp[i] << 2);
 				}
 				DBG_PRINT("load gamma_table_g.\n");
 			}
 			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_b",&gamma_temp[0], 256);
 			if(ret){
 				printk("don't find to match gamma_table_b, use default table.\n");
-				lcd_setup_gamma_table(pDev->pConf, 2);
+				lcd_setup_gamma_table(pConf, 2);
 			}
 			else {
 				for (i=0; i<256; i++) {
-					pDev->pConf->lcd_effect.GammaTableB[i] = (unsigned short)(gamma_temp[i] << 2);
+					pConf->lcd_effect.GammaTableB[i] = (unsigned short)(gamma_temp[i] << 2);
 				}
 				DBG_PRINT("load gamma_table_b.\n");
 			}
@@ -4876,13 +1775,13 @@ static inline int _get_lcd_default_config(struct platform_device *pdev)
 			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table",&gamma_temp[0], 256);
 			if(ret){
 				printk("don't find to match gamma_table, use default table.\n");
-				lcd_setup_gamma_table(pDev->pConf, 3);
+				lcd_setup_gamma_table(pConf, 3);
 			}
 			else {
 				for (i=0; i<256; i++) {
-					pDev->pConf->lcd_effect.GammaTableR[i] = (unsigned short)(gamma_temp[i] << 2);
-					pDev->pConf->lcd_effect.GammaTableG[i] = (unsigned short)(gamma_temp[i] << 2);
-					pDev->pConf->lcd_effect.GammaTableB[i] = (unsigned short)(gamma_temp[i] << 2);
+					pConf->lcd_effect.GammaTableR[i] = (unsigned short)(gamma_temp[i] << 2);
+					pConf->lcd_effect.GammaTableG[i] = (unsigned short)(gamma_temp[i] << 2);
+					pConf->lcd_effect.GammaTableB[i] = (unsigned short)(gamma_temp[i] << 2);
 				}
 				DBG_PRINT("load gamma_table.\n");
 			}
@@ -4894,127 +1793,126 @@ static inline int _get_lcd_default_config(struct platform_device *pdev)
 			printk("don't find to match clock_spread_spectrum, use default setting.\n");
 		}
 		else {
-			pDev->pConf->lcd_timing.clk_ctrl = (pDev->pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_SS)) | (val << CLK_CTRL_SS);
-			DBG_PRINT("lcd clock spread spectrum = %u\n", (pDev->pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf);
+			pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_SS)) | (val << CLK_CTRL_SS));
+			DBG_PRINT("lcd clock spread spectrum = %u\n", (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf);
 		}
 		ret = of_property_read_u32(pdev->dev.of_node,"clock_auto_generation",&val);
 		if(ret){
 			printk("don't find to match clock_auto_generation, use default setting.\n");
 		}
 		else {
-			pDev->pConf->lcd_timing.clk_ctrl = ((pDev->pConf->lcd_timing.clk_ctrl & ~(1 << CLK_CTRL_AUTO)) | (val << CLK_CTRL_AUTO));
-			DBG_PRINT("lcd clock auto calculate = %u\n", (pDev->pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1);
+			pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & ~(1 << CLK_CTRL_AUTO)) | (val << CLK_CTRL_AUTO));
+			DBG_PRINT("lcd clock auto_generation = %u\n", (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 0x1);
 		}
-		if (((pDev->pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1) == 0) {
+		if (((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 0x1) == 0) {
 			ret = of_property_read_u32_array(pdev->dev.of_node,"clk_pll_div_clk_ctrl",&lcd_para[0], 3);
 			if(ret){
 				printk("don't find to match clk_pll_div_clk_ctrl, use default setting.\n");
 			}
 			else {
-				pDev->pConf->lcd_timing.pll_ctrl = lcd_para[0];
-				pDev->pConf->lcd_timing.div_ctrl = lcd_para[1];
-				pDev->pConf->lcd_timing.clk_ctrl = lcd_para[2];
-				printk("pll_ctrl = 0x%x, div_ctrl = 0x%x, clk_ctrl=0x%x\n", pDev->pConf->lcd_timing.pll_ctrl, pDev->pConf->lcd_timing.div_ctrl, (pDev->pConf->lcd_timing.clk_ctrl & 0xffff));
+				pConf->lcd_timing.pll_ctrl = lcd_para[0];
+				pConf->lcd_timing.div_ctrl = lcd_para[1];
+				pConf->lcd_timing.clk_ctrl = lcd_para[2];
+				printk("pll_ctrl = 0x%x, div_ctrl = 0x%x, clk_ctrl=0x%x\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, (pConf->lcd_timing.clk_ctrl & 0xffff));
 			}
 		}
-		ret = of_property_read_u32(pdev->dev.of_node,"lvds_vswing",&val);
-		if(ret){
-			printk("don't find to match lvds_vswing, use default setting.\n");
-		}
-		else {
-			pDev->pConf->lcd_control.lvds_config->lvds_vswing = val;
-			if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS)
-				printk("lvds_vswing = %u\n", pDev->pConf->lcd_control.lvds_config->lvds_vswing = val);
-			else
-				DBG_PRINT("lvds_vswing = %u\n", pDev->pConf->lcd_control.lvds_config->lvds_vswing = val);
-		}
-		ret = of_property_read_u32_array(pdev->dev.of_node,"lvds_user_repack",&lcd_para[0], 2);
-		if(ret){
-			printk("don't find to match lvds_user_repack, use default setting.\n");
-			pDev->pConf->lcd_control.lvds_config->lvds_repack_user = 0;
-			pDev->pConf->lcd_control.lvds_config->lvds_repack = 1;
-		}
-		else {
-			pDev->pConf->lcd_control.lvds_config->lvds_repack_user = lcd_para[0];
-			pDev->pConf->lcd_control.lvds_config->lvds_repack = lcd_para[1];
-			if (lcd_para[0] > 0) {
-				if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS)
-					printk("lvds_repack = %u\n", pDev->pConf->lcd_control.lvds_config->lvds_repack);
-				else
-					DBG_PRINT("lvds_repack = %u\n", pDev->pConf->lcd_control.lvds_config->lvds_repack);
+		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+			ret = of_property_read_u32(pdev->dev.of_node,"lvds_vswing",&val);
+			if(ret){
+				printk("don't find to match lvds_vswing, use default setting.\n");
 			}
 			else {
-				DBG_PRINT("lvds_repack_user = %u, lvds_repack = %u\n", pDev->pConf->lcd_control.lvds_config->lvds_repack_user, pDev->pConf->lcd_control.lvds_config->lvds_repack);
+				pConf->lcd_control.lvds_config->lvds_vswing = val;
+				printk("lvds_vswing level = %u\n", pConf->lcd_control.lvds_config->lvds_vswing = val);
 			}
-		}
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		ret = of_property_read_u32_array(pdev->dev.of_node,"edp_user_link_rate_lane_count",&lcd_para[0], 3);
-		if(ret){
-			pDev->pConf->lcd_control.edp_config->link_user = 0;
-			pDev->pConf->lcd_control.edp_config->link_rate = 1;
-			pDev->pConf->lcd_control.edp_config->lane_count = 4;
-			printk("don't find to match edp_user_link_rate_lane_count, use default setting.\n");
-		}
-		else {
-			pDev->pConf->lcd_control.edp_config->link_user = (unsigned char)(lcd_para[0]);
-			pDev->pConf->lcd_control.edp_config->link_rate = (unsigned char)(lcd_para[1]);
-			pDev->pConf->lcd_control.edp_config->lane_count = (unsigned char)(lcd_para[2]);
-			if (lcd_para[0] > 0) {
-				if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP)
-					printk("edp link_rate = %s, lane_count = %u\n", (lcd_para[1] == 0) ? "1.62G":"2.7G", pDev->pConf->lcd_control.edp_config->lane_count);
-				else
-					DBG_PRINT("edp link_rate = %s, lane_count = %u\n", (lcd_para[1] == 0) ? "1.62G":"2.7G", pDev->pConf->lcd_control.edp_config->lane_count);
+			ret = of_property_read_u32_array(pdev->dev.of_node,"lvds_user_repack",&lcd_para[0], 2);
+			if(ret){
+				printk("don't find to match lvds_user_repack, use default setting.\n");
+				pConf->lcd_control.lvds_config->lvds_repack_user = 0;
+				pConf->lcd_control.lvds_config->lvds_repack = 1;
 			}
 			else {
-				DBG_PRINT("edp user = %u, link_rate = %s, lane_count = %u\n", pDev->pConf->lcd_control.edp_config->link_user, (lcd_para[1] == 0) ? "1.62G":"2.7G", pDev->pConf->lcd_control.edp_config->lane_count);
+				pConf->lcd_control.lvds_config->lvds_repack_user = lcd_para[0];
+				pConf->lcd_control.lvds_config->lvds_repack = lcd_para[1];
+				if (lcd_para[0] > 0) {
+					printk("lvds_repack = %u\n", pConf->lcd_control.lvds_config->lvds_repack);
+				}
+				else {
+					DBG_PRINT("lvds_repack_user = %u, lvds_repack = %u\n", pConf->lcd_control.lvds_config->lvds_repack_user, pConf->lcd_control.lvds_config->lvds_repack);
+				}
 			}
 		}
-		ret = of_property_read_u32_array(pdev->dev.of_node,"edp_link_adaptive_vswing",&lcd_para[0], 2);
-		if(ret){
-			printk("don't find to match edp_link_adaptive_vswing, use default setting.\n");
-			pDev->pConf->lcd_control.edp_config->link_adaptive = 0;
-			pDev->pConf->lcd_control.edp_config->vswing = 0;
-			pDev->pConf->lcd_control.edp_config->preemphasis = 0;
-		}
-		else {
-			pDev->pConf->lcd_control.edp_config->link_adaptive = (unsigned char)(lcd_para[0]);
-			pDev->pConf->lcd_control.edp_config->vswing = (unsigned char)(lcd_para[1]);
-			pDev->pConf->lcd_control.edp_config->preemphasis = 0;
-			if (lcd_para[0] == 0) {
-				if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP)
-					printk("edp swing_level = %u\n", pDev->pConf->lcd_control.edp_config->vswing);
-				else
-					DBG_PRINT("edp swing_level = %u\n", pDev->pConf->lcd_control.edp_config->vswing);
+		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
+			ret = of_property_read_u32_array(pdev->dev.of_node,"edp_user_link_rate_lane_count",&lcd_para[0], 3);
+			if(ret){
+				pConf->lcd_control.edp_config->link_user = 0;
+				pConf->lcd_control.edp_config->link_rate = 1;
+				pConf->lcd_control.edp_config->lane_count = 4;
+				printk("don't find to match edp_user_link_rate_lane_count, use default setting.\n");
+			}
+			else {
+				pConf->lcd_control.edp_config->link_user = (unsigned char)(lcd_para[0]);
+				pConf->lcd_control.edp_config->link_rate = (unsigned char)(lcd_para[1]);
+				pConf->lcd_control.edp_config->lane_count = (unsigned char)(lcd_para[2]);
+				if (pConf->lcd_control.edp_config->link_user > 0) {
+					printk("edp link_rate = %s, lane_count = %u\n", ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count);
+				}
+				else {
+					DBG_PRINT("edp user = %u, link_rate = %s, lane_count = %u\n", pConf->lcd_control.edp_config->link_user, ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count);
+				}
+			}
+			ret = of_property_read_u32_array(pdev->dev.of_node,"edp_link_adaptive_vswing",&lcd_para[0], 2);
+			if(ret){
+				printk("don't find to match edp_link_adaptive_vswing, use default setting.\n");
+				pConf->lcd_control.edp_config->link_adaptive = 0;
+				pConf->lcd_control.edp_config->vswing = 0;
+				pConf->lcd_control.edp_config->preemphasis = 0;
+			}
+			else {
+				pConf->lcd_control.edp_config->link_adaptive = (unsigned char)(lcd_para[0]);
+				pConf->lcd_control.edp_config->vswing = (unsigned char)(lcd_para[1]);
+				pConf->lcd_control.edp_config->preemphasis = 0;
+				if (pConf->lcd_control.edp_config->link_adaptive == 0) {
+					printk("edp swing_level = %u\n", pConf->lcd_control.edp_config->vswing);
+				}
+				else {
+					DBG_PRINT("edp link_adaptive = %u, swing_level = %u\n", pConf->lcd_control.edp_config->link_adaptive, pConf->lcd_control.edp_config->vswing);
+				}
+			}
+			ret = of_property_read_u32(pdev->dev.of_node,"edp_sync_clock_mode",&val);
+			if(ret){
+				printk("don't find to match edp_sync_clock_mode, use default setting.\n");
+				pConf->lcd_control.edp_config->sync_clock_mode = 1;
 			}
 			else {
-				DBG_PRINT("edp link_adaptive = %u, swing_level = %u\n", pDev->pConf->lcd_control.edp_config->link_adaptive, pDev->pConf->lcd_control.edp_config->vswing);
+				pConf->lcd_control.edp_config->sync_clock_mode = (val & 1);
+				printk("edp sync_clock_mode = %u\n", pConf->lcd_control.edp_config->sync_clock_mode);
 			}
 		}
-#endif
 		ret = of_property_read_u32_array(pdev->dev.of_node,"rgb_base_coeff",&lcd_para[0], 2);
 		if(ret){
 			printk("don't find to match rgb_base_coeff, use default setting.\n");
 		}
 		else {
-			pDev->pConf->lcd_effect.rgb_base_addr = (unsigned short)(lcd_para[0]);
-			pDev->pConf->lcd_effect.rgb_coeff_addr = (unsigned short)(lcd_para[1]);
-			DBG_PRINT("rgb_base = 0x%x, rgb_coeff = 0x%x\n", pDev->pConf->lcd_effect.rgb_base_addr, pDev->pConf->lcd_effect.rgb_coeff_addr);
+			pConf->lcd_effect.rgb_base_addr = (unsigned short)(lcd_para[0]);
+			pConf->lcd_effect.rgb_coeff_addr = (unsigned short)(lcd_para[1]);
+			DBG_PRINT("rgb_base = 0x%x, rgb_coeff = 0x%x\n", pConf->lcd_effect.rgb_base_addr, pConf->lcd_effect.rgb_coeff_addr);
 		}
 		// ret = of_property_read_u32_array(pdev->dev.of_node,"video_on_pixel_line",&lcd_para[0], 2);
 		// if(ret){
 			// printk("don't find to match video_on_pixel_line, use default setting.\n");
 		// }
 		// else {
-			// pDev->pConf->lcd_timing.video_on_pixel = (unsigned short)(lcd_para[0]);
-			// pDev->pConf->lcd_timing.video_on_line = (unsigned short)(lcd_para[1]);
-			// DBG_PRINT("video_on_pixel = %u, video_on_line = %u\n", pDev->pConf->lcd_timing.video_on_pixel, pDev->pConf->lcd_timing.video_on_line);
+			// pConf->lcd_timing.video_on_pixel = (unsigned short)(lcd_para[0]);
+			// pConf->lcd_timing.video_on_line = (unsigned short)(lcd_para[1]);
+			// DBG_PRINT("video_on_pixel = %u, video_on_line = %u\n", pConf->lcd_timing.video_on_pixel, pConf->lcd_timing.video_on_line);
 		// }
 	}
-	
+	kfree(gamma_temp);
 	return ret;
 }
 
-static inline int _get_lcd_power_config(struct platform_device *pdev)
+static int _get_lcd_power_config(Lcd_Config_t *pConf, struct platform_device *pdev)
 {
 	int ret=0;
 	const char *str;
@@ -5042,55 +1940,55 @@ static inline int _get_lcd_power_config(struct platform_device *pdev)
 				for(index = 0; index < LCD_POWER_TYPE_MAX; index++) {
 					if(!strcasecmp(str, lcd_power_type_table[index]))
 						break;
-				}		
-				pDev->pConf->lcd_power_ctrl.power_on_config[i].type = index;
+				}
+				pConf->lcd_power_ctrl.power_on_config[i].type = index;
 				
-				if (pDev->pConf->lcd_power_ctrl.power_on_config[i].type != LCD_POWER_TYPE_SIGNAL) {
+				if (pConf->lcd_power_ctrl.power_on_config[i].type < LCD_POWER_TYPE_SIGNAL) {
 					ret = of_property_read_string_index(pdev->dev.of_node, propname, 1, &str);
 					if (ret) {
 						printk("faild to get %s index 1\n", propname);
 					}
-					else {					
-						if (pDev->pConf->lcd_power_ctrl.power_on_config[i].type == LCD_POWER_TYPE_CPU) {
+					else {
+						if (pConf->lcd_power_ctrl.power_on_config[i].type == LCD_POWER_TYPE_CPU) {
 							val = amlogic_gpio_name_map_num(str);
 							ret = lcd_gpio_request(val);
 							if (ret) {
 							  printk("faild to alloc lcd power ctrl gpio (%s)\n", str);
 							}
-							pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio = val;
+							pConf->lcd_power_ctrl.power_on_config[i].gpio = val;
 						}
-						else if (pDev->pConf->lcd_power_ctrl.power_on_config[i].type == LCD_POWER_TYPE_PMU) {
-							pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio = amlogic_pmu_gpio_name_map_num(str);
+						else if (pConf->lcd_power_ctrl.power_on_config[i].type == LCD_POWER_TYPE_PMU) {
+							pConf->lcd_power_ctrl.power_on_config[i].gpio = amlogic_pmu_gpio_name_map_num(str);
 						}
 					}
 					ret = of_property_read_string_index(pdev->dev.of_node, propname, 2, &str);
 					if (ret) {
 						printk("faild to get %s\n", propname);
 					}
-					else {					
+					else {
 						if ((strcasecmp(str, "output_low") == 0) || (strcasecmp(str, "0") == 0)) {
-							pDev->pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_OUTPUT_LOW;
+							pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_OUTPUT_LOW;
 						}
 						else if ((strcasecmp(str, "output_high") == 0) || (strcasecmp(str, "1") == 0)) {
-							pDev->pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_OUTPUT_HIGH;
+							pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_OUTPUT_HIGH;
 						}
 						else if ((strcasecmp(str, "input") == 0) || (strcasecmp(str, "2") == 0)) {
-							pDev->pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_INPUT;
+							pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_INPUT;
 						}
 					}
 				}
 			}
 		}
-		pDev->pConf->lcd_power_ctrl.power_on_step = i;
-		DBG_PRINT("lcd_power_on_step = %d\n", pDev->pConf->lcd_power_ctrl.power_on_step);
+		pConf->lcd_power_ctrl.power_on_step = i;
+		DBG_PRINT("lcd_power_on_step = %d\n", pConf->lcd_power_ctrl.power_on_step);
 		
-		ret = of_property_read_u32_array(pdev->dev.of_node,"power_on_delay",&lcd_para[0],pDev->pConf->lcd_power_ctrl.power_on_step);
+		ret = of_property_read_u32_array(pdev->dev.of_node,"power_on_delay",&lcd_para[0],pConf->lcd_power_ctrl.power_on_step);
 		if (ret) {
 			printk("faild to get power_on_delay\n");
 		}
 		else {
-			for (i=0; i<pDev->pConf->lcd_power_ctrl.power_on_step; i++) {
-				pDev->pConf->lcd_power_ctrl.power_on_config[i].delay = (unsigned short)(lcd_para[i]);
+			for (i=0; i<pConf->lcd_power_ctrl.power_on_step; i++) {
+				pConf->lcd_power_ctrl.power_on_config[i].delay = (unsigned short)(lcd_para[i]);
 			}
 		}
 		//lcd power off
@@ -5110,21 +2008,21 @@ static inline int _get_lcd_power_config(struct platform_device *pdev)
 				for(index = 0; index < LCD_POWER_TYPE_MAX; index++) {
 					if(!strcasecmp(str, lcd_power_type_table[index]))
 						break;
-				}		
-				pDev->pConf->lcd_power_ctrl.power_off_config[i].type = index;
+				}
+				pConf->lcd_power_ctrl.power_off_config[i].type = index;
 			
-				if (pDev->pConf->lcd_power_ctrl.power_off_config[i].type < LCD_POWER_TYPE_SIGNAL) {
+				if (pConf->lcd_power_ctrl.power_off_config[i].type < LCD_POWER_TYPE_SIGNAL) {
 					ret = of_property_read_string_index(pdev->dev.of_node, propname, 1, &str);
 					if (ret) {
 						printk("faild to get %s index 1\n", propname);
 					}
 					else {
-						if (pDev->pConf->lcd_power_ctrl.power_off_config[i].type == LCD_POWER_TYPE_CPU) {
+						if (pConf->lcd_power_ctrl.power_off_config[i].type == LCD_POWER_TYPE_CPU) {
 							val = amlogic_gpio_name_map_num(str);
-							pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio = val;
+							pConf->lcd_power_ctrl.power_off_config[i].gpio = val;
 						}
-						else if (pDev->pConf->lcd_power_ctrl.power_off_config[i].type == LCD_POWER_TYPE_PMU) {
-							pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio = amlogic_pmu_gpio_name_map_num(str);
+						else if (pConf->lcd_power_ctrl.power_off_config[i].type == LCD_POWER_TYPE_PMU) {
+							pConf->lcd_power_ctrl.power_off_config[i].gpio = amlogic_pmu_gpio_name_map_num(str);
 						}
 					}
 					ret = of_property_read_string_index(pdev->dev.of_node, propname, 2, &str);
@@ -5133,64 +2031,57 @@ static inline int _get_lcd_power_config(struct platform_device *pdev)
 					}
 					else {
 						if ((strcasecmp(str, "output_low") == 0) || (strcasecmp(str, "0") == 0)) {
-							pDev->pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_OUTPUT_LOW;
+							pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_OUTPUT_LOW;
 						}
 						else if ((strcasecmp(str, "output_high") == 0) || (strcasecmp(str, "1") == 0)) {
-							pDev->pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_OUTPUT_HIGH;
+							pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_OUTPUT_HIGH;
 						}
 						else if ((strcasecmp(str, "input") == 0) || (strcasecmp(str, "2") == 0)) {
-							pDev->pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_INPUT;
+							pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_INPUT;
 						}
 					}
 				}
 			}
 		}
-		pDev->pConf->lcd_power_ctrl.power_off_step = i;
-		DBG_PRINT("lcd_power_off_step = %d\n", pDev->pConf->lcd_power_ctrl.power_off_step);
+		pConf->lcd_power_ctrl.power_off_step = i;
+		DBG_PRINT("lcd_power_off_step = %d\n", pConf->lcd_power_ctrl.power_off_step);
 		
-		ret = of_property_read_u32_array(pdev->dev.of_node,"power_off_delay",&lcd_para[0],pDev->pConf->lcd_power_ctrl.power_off_step);
+		ret = of_property_read_u32_array(pdev->dev.of_node,"power_off_delay",&lcd_para[0],pConf->lcd_power_ctrl.power_off_step);
 		if (ret) {
 			printk("faild to get power_off_delay\n");
 		}
 		else {
-			for (i=0; i<pDev->pConf->lcd_power_ctrl.power_off_step; i++) {
-				pDev->pConf->lcd_power_ctrl.power_off_config[i].delay = (unsigned short)(lcd_para[i]);
+			for (i=0; i<pConf->lcd_power_ctrl.power_off_step; i++) {
+				pConf->lcd_power_ctrl.power_off_config[i].delay = (unsigned short)(lcd_para[i]);
 			}
 		}
 		
-		for (i=0; i<pDev->pConf->lcd_power_ctrl.power_on_step; i++) {
-			DBG_PRINT("power on step %d: type = %s(%d)\n", i+1, lcd_power_type_table[pDev->pConf->lcd_power_ctrl.power_on_config[i].type], pDev->pConf->lcd_power_ctrl.power_on_config[i].type);
-			DBG_PRINT("power on step %d: gpio = %d\n", i+1, pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio);
-			DBG_PRINT("power on step %d: value = %d\n", i+1, pDev->pConf->lcd_power_ctrl.power_on_config[i].value);
-			DBG_PRINT("power on step %d: delay = %d\n", i+1, pDev->pConf->lcd_power_ctrl.power_on_config[i].delay);
+		for (i=0; i<pConf->lcd_power_ctrl.power_on_step; i++) {
+			DBG_PRINT("power on step %d: type = %s(%d)\n", i+1, lcd_power_type_table[pConf->lcd_power_ctrl.power_on_config[i].type], pConf->lcd_power_ctrl.power_on_config[i].type);
+			DBG_PRINT("power on step %d: gpio = %d\n", i+1, pConf->lcd_power_ctrl.power_on_config[i].gpio);
+			DBG_PRINT("power on step %d: value = %d\n", i+1, pConf->lcd_power_ctrl.power_on_config[i].value);
+			DBG_PRINT("power on step %d: delay = %d\n", i+1, pConf->lcd_power_ctrl.power_on_config[i].delay);
 		}
 		
-		for (i=0; i<pDev->pConf->lcd_power_ctrl.power_off_step; i++) {
-			DBG_PRINT("power off step %d: type = %s(%d)\n", i+1, lcd_power_type_table[pDev->pConf->lcd_power_ctrl.power_off_config[i].type], pDev->pConf->lcd_power_ctrl.power_off_config[i].type);
-			DBG_PRINT("power off step %d: gpio = %d\n", i+1, pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio);
-			DBG_PRINT("power off step %d: value = %d\n", i+1, pDev->pConf->lcd_power_ctrl.power_off_config[i].value);
-			DBG_PRINT("power off step %d: delay = %d\n", i+1, pDev->pConf->lcd_power_ctrl.power_off_config[i].delay);
+		for (i=0; i<pConf->lcd_power_ctrl.power_off_step; i++) {
+			DBG_PRINT("power off step %d: type = %s(%d)\n", i+1, lcd_power_type_table[pConf->lcd_power_ctrl.power_off_config[i].type], pConf->lcd_power_ctrl.power_off_config[i].type);
+			DBG_PRINT("power off step %d: gpio = %d\n", i+1, pConf->lcd_power_ctrl.power_off_config[i].gpio);
+			DBG_PRINT("power off step %d: value = %d\n", i+1, pConf->lcd_power_ctrl.power_off_config[i].value);
+			DBG_PRINT("power off step %d: delay = %d\n", i+1, pConf->lcd_power_ctrl.power_off_config[i].delay);
 		}
 
-		pDev->p = devm_pinctrl_get(&pdev->dev);
-		if (IS_ERR(pDev->p))
+		pConf->lcd_misc_ctrl.pin = devm_pinctrl_get(&pdev->dev);
+		if (IS_ERR(pConf->lcd_misc_ctrl.pin))
 			printk("get lcd ttl ports pinmux error.\n");
-	}	
+	}
 	return ret;
 }
 #endif
 
 #ifdef CONFIG_USE_OF
-static struct aml_lcd_platform meson_lcd_platform = {
-	.lcd_conf = &lcd_config,
-};
-
-#define AMLOGIC_LCD_DRV_DATA ((kernel_ulong_t)&meson_lcd_platform)
-
 static const struct of_device_id lcd_dt_match[] = {
 	{
 		.compatible = "amlogic,lcd",
-		.data = (void *)AMLOGIC_LCD_DRV_DATA
 	},
 	{},
 };
@@ -5198,94 +2089,73 @@ static const struct of_device_id lcd_dt_match[] = {
 #define lcd_dt_match NULL
 #endif
 
-#ifdef CONFIG_USE_OF
-static inline struct aml_lcd_platform *lcd_get_driver_data(struct platform_device *pdev)
+static void lcd_config_assign(Lcd_Config_t *pConf)
 {
-	const struct of_device_id *match;
-	
-	if(pdev->dev.of_node) {
-		//DBG_PRINT("***of_device: get lcd driver data.***\n");		
-		match = of_match_node(lcd_dt_match, pdev->dev.of_node);
-		return (struct aml_lcd_platform *)match->data;
-	}
-	return NULL;
+    pConf->lcd_power_ctrl.power_ctrl = lcd_power_ctrl;
 }
-#endif
 
 static struct notifier_block lcd_reboot_nb;
 static int lcd_probe(struct platform_device *pdev)
 {
-    struct aml_lcd_platform *pdata;  
+	struct aml_lcd_platform *pdata;  
 	int ret = 0;
-	spin_lock_init(&gamma_write_lock);
-	spin_lock_init(&lcd_clk_lock);
 	
-	printk("lcd driver version: %s%s\n\n", DRIVER_DATE, DRV_TYPE);
+	pDev = (lcd_dev_t *)kmalloc(sizeof(lcd_dev_t), GFP_KERNEL);
+	if (!pDev) {
+		printk("[lcd probe]: Not enough memory.\n");
+		return -ENOMEM;
+	}
 	
-#ifdef 	CONFIG_USE_OF
-	pdata = lcd_get_driver_data(pdev);
+#ifdef CONFIG_USE_OF
+	//pdata = lcd_get_driver_data(pdev);
+	pDev->pConf = get_lcd_config();
 #else
 	pdata = pdev->dev.platform_data;
+	pDev->pConf = (Lcd_Config_t *)(pdata->lcd_conf);
 #endif
-
-    pDev = (lcd_dev_t *)kmalloc(sizeof(lcd_dev_t), GFP_KERNEL);
-    if (!pDev) {
-        printk("[lcd probe]: Not enough memory.\n");
-        return -ENOMEM;
-    }    
-
-    pDev->pConf = (Lcd_Config_t *)(pdata->lcd_conf);
+	
 #ifdef CONFIG_USE_OF
-	_get_lcd_model_timing(pdev);
-	_get_lcd_default_config(pdev);
-	_get_lcd_power_config(pdev);
+	_get_lcd_model_timing(pDev->pConf, pdev);
+	_get_lcd_default_config(pDev->pConf, pdev);
+	_get_lcd_power_config(pDev->pConf, pdev);
 #endif
+	
+	lcd_config_assign(pDev->pConf);
+	lcd_config_probe(pDev->pConf);
 	save_lcd_config(pDev->pConf);
+	
+	pDev->pConf->lcd_misc_ctrl.print_version();
 	lcd_config_init(pDev->pConf);
-    _lcd_init(pDev->pConf);
+	_init_vout();
 	
 	lcd_reboot_nb.notifier_call = lcd_reboot_notifier;
-    ret = register_reboot_notifier(&lcd_reboot_nb);
+	ret = register_reboot_notifier(&lcd_reboot_nb);
 	if (ret) {
 		printk("notifier register lcd_reboot_notifier fail!\n");
-	}	
-	
-	ret = class_register(&aml_lcd_debug_class);
-	if(ret){
-		printk("class register aml_lcd_debug_class fail!\n");
 	}
+	
+	ret = creat_lcd_attr();
 #ifdef CONFIG_AML_GAMMA_DEBUG
 	save_original_gamma(pDev->pConf);
-	ret = class_register(&aml_gamma_class);
-	if(ret){
-		printk("class register aml_gamma_class fail!\n");
-	}
-#endif
-
-	switch (pDev->pConf->lcd_basic.lcd_type) {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		case LCD_DIGITAL_MIPI :
-			dsi_probe(pDev->pConf);
-			break;
+	ret = creat_lcd_gamma_attr();
 #endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-		case LCD_DIGITAL_EDP :
-			edp_probe();
-			break;
-#endif
-		default:
-			break;
-    }
-
+	
 	printk("LCD probe ok\n");
-
 	return 0;
 }
 
 static int lcd_remove(struct platform_device *pdev)
 {
 	unregister_reboot_notifier(&lcd_reboot_nb);
-	kfree(pDev);
+	
+	remove_lcd_gamma_attr();
+	lcd_config_remove();
+	remove_lcd_attr();
+	
+	if (pDev->pConf->lcd_basic.model_name)
+		kfree(pDev->pConf->lcd_basic.model_name);
+	if (pDev)
+		kfree(pDev);
 
     return 0;
 }
@@ -5296,8 +2166,8 @@ static struct platform_driver lcd_driver = {
 	.remove = lcd_remove,
 	.driver = {
 		.name = "mesonlcd",
-#ifdef CONFIG_USE_OF
 		.owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
 		.of_match_table = lcd_dt_match,
 #endif
 	},
@@ -5305,7 +2175,7 @@ static struct platform_driver lcd_driver = {
 
 static int __init lcd_init(void)
 {
-	printk("LCD driver init\n");
+    DBG_PRINT("LCD driver init\n");
     if (platform_driver_register(&lcd_driver)) {
         printk("failed to register lcd driver module\n");
         return -ENODEV;
diff --git a/include/linux/amlogic/vout/lcdoutc.h b/include/linux/amlogic/vout/lcdoutc.h
index d0b173550595..ca2598400b1b 100755
--- a/include/linux/amlogic/vout/lcdoutc.h
+++ b/include/linux/amlogic/vout/lcdoutc.h
@@ -24,216 +24,51 @@
 #ifndef LCDOUTC_H
 #define LCDOUTC_H
 #include <linux/types.h>
-#include <plat/cpu.h>
-#include <mach/cpu.h>
-/* for GAMMA_CNTL_PORT */
-	#define LCD_GAMMA_VCOM_POL       7
-	#define LCD_GAMMA_RVS_OUT        6
-	#define LCD_ADR_RDY              5
-	#define LCD_WR_RDY               4
-	#define LCD_RD_RDY               3
-	#define LCD_GAMMA_TR             2
-	#define LCD_GAMMA_SET            1
-	#define LCD_GAMMA_EN             0
-
-/* for GAMMA_ADDR_PORT */
-	#define LCD_H_RD                 12
-	#define LCD_H_AUTO_INC           11
-	#define LCD_H_SEL_R              10
-	#define LCD_H_SEL_G              9
-	#define LCD_H_SEL_B              8
-	#define LCD_HADR_MSB             7
-	#define LCD_HADR                 0
-
-/* for POL_CNTL_ADDR */
-	#define LCD_DCLK_SEL             14    //FOR DCLK OUTPUT
-	#define LCD_TCON_VSYNC_SEL_DVI   11	 // FOR RGB format DVI output
-	#define LCD_TCON_HSYNC_SEL_DVI   10	 // FOR RGB format DVI output
-	#define LCD_TCON_DE_SEL_DVI      9	 // FOR RGB format DVI output
-	#define LCD_CPH3_POL             8
-	#define LCD_CPH2_POL             7
-	#define LCD_CPH1_POL             6
-	#define LCD_TCON_DE_SEL          5
-	#define LCD_TCON_VS_SEL          4
-	#define LCD_TCON_HS_SEL          3
-	#define LCD_DE_POL               2
-	#define LCD_VS_POL               1
-	#define LCD_HS_POL               0
-
-/* for DITH_CNTL_ADDR */
-	#define LCD_DITH10_EN            10
-	#define LCD_DITH8_EN             9
-	#define LCD_DITH_MD              8
-	#define LCD_DITH10_CNTL_MSB      7
-	#define LCD_DITH10_CNTL          4
-	#define LCD_DITH8_CNTL_MSB       3
-	#define LCD_DITH8_CNTL           0
-
-/* for INV_CNT_ADDR */
-	#define LCD_INV_EN               4
-	#define LCD_INV_CNT_MSB          3
-	#define LCD_INV_CNT              0
-
-/* for TCON_MISC_SEL_ADDR */
-	#define LCD_STH2_SEL             12
-	#define LCD_STH1_SEL             11
-	#define LCD_OEH_SEL              10
-	#define LCD_VCOM_SEL             9
-	#define LCD_DB_LINE_SW           8
-	#define LCD_CPV2_SEL             7
-	#define LCD_CPV1_SEL             6
-	#define LCD_STV2_SEL             5
-	#define LCD_STV1_SEL             4
-	#define LCD_OEV_UNITE            3
-	#define LCD_OEV3_SEL             2
-	#define LCD_OEV2_SEL             1
-	#define LCD_OEV1_SEL             0
-
-/* for DUAL_PORT_CNTL_ADDR */
-	#define LCD_ANALOG_SEL_CPH3      8
-	#define LCD_ANALOG_3PHI_CLK_SEL  7
-	#define LCD_LVDS_SEL54           6
-	#define LCD_LVDS_SEL27           5
-	#define LCD_TTL_SEL              4
-	#define LCD_DUAL_PIXEL           3
-	#define LCD_PORT_SWP             2
-	#define LCD_RGB_SWP              1
-	#define LCD_BIT_SWP              0
-
-/* for LVDS_PACK_CNTL_ADDR */
-	#define LCD_LD_CNT_MSB           7
-	#define LCD_LD_CNT               5
-	#define LCD_PN_SWP               4
-	#define LCD_RES                  3
-	#define LCD_LVDS_PORT_SWP        2
-	#define LCD_PACK_RVS             1
-	#define LCD_PACK_LITTLE          0
-
-/* for LVDS_PACK_CNTL_ADDR */   
-	#define LVDS_blank_data_reserved	30  // 31:30
-	#define LVDS_blank_data_r			20  // 29:20
-	#define LVDS_blank_data_g			10  // 19:10
-	#define LVDS_blank_data_b			0  //  9:0
-	#define LVDS_USE_TCON				7
-	#define LVDS_DUAL					6
-	#define PN_SWP						5
-	#define LSB_FIRST					4
-	#define LVDS_RESV					3
-	#define ODD_EVEN_SWP				2
-	#define LVDS_REPACK					0
-
-/* for video encoder */
-	#define	MIPI_DELAY				8
-	#define	LVDS_DELAY				8
-	#define	EDP_DELAY				8
-	#define	TTL_DELAY				19
-	#define	MLVDS_DELAY				0
-
-//********************************************//
-// for clk parameter auto generation
-//********************************************//
-/**** clk parameters bit ***/
-	#define PLL_CTRL_LOCK			31
-	#define PLL_CTRL_RST			29
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	#define PLL_CTRL_PD				30
-	#define PLL_CTRL_OD				16	//[17:16]
-	#define PLL_CTRL_N				9	//[13:9]
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	#define PLL_CTRL_EN				30
-	#define PLL_CTRL_OD				9	//[10:9]
-	#define PLL_CTRL_N				24	//[28:24]
-#elif (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
-	#define PLL_CTRL_EN				30
-	#define PLL_CTRL_OD				16	//[17:16]
-	#define PLL_CTRL_N				10	//[14:10]
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/pinctrl/consumer.h>
+
+//**********************************************
+//debug print define
+//***********************************************
+//#define LCD_DEBUG_INFO
+#ifdef LCD_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
 #endif
-	#define PLL_CTRL_M				0	//[8:0]
-
-	#define DIV_CTRL_EDP_DIV1		24	//[26:24]
-	#define DIV_CTRL_EDP_DIV0		20	//[23:20]
-	#define DIV_CTRL_DIV_POST		12	//[14:12]
-	#define DIV_CTRL_LVDS_CLK_EN	11
-	#define DIV_CTRL_PHY_CLK_DIV2	10
-	#define DIV_CTRL_POST_SEL		8	//[9:8]
-	#define DIV_CTRL_DIV_PRE		4	//[6:4]
-
-	#define CLK_CTRL_AUTO			31
-	#define CLK_TEST_FLAG			30
-	#define CLK_CTRL_FRAC			16	//[27:16]
-	#define CLK_CTRL_LEVEL			12	//[14:12]
-	//#define CLK_CTRL_PLL_SEL		10
-	//#define CLK_CTRL_DIV_SEL		9
-	#define CLK_CTRL_VCLK_SEL		8
-	#define CLK_CTRL_SS				4	//[7:4]
-	#define CLK_CTRL_XD				0	//[3:0]
+
+//**********************************************
+//global define
+//***********************************************
+	#define FIN_FREQ                 (24 * 1000)
 	
-	#define PLL_WAIT_LOCK_CNT		200
-
-/**** clk frequency limit ***/
-	#define FIN_FREQ				(24 * 1000)
-	/* PLL */
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	#define PLL_M_MIN				2
-	#define PLL_M_MAX				100
-	#define PLL_N_MIN				1
-	#define PLL_N_MAX				1
-	#define PLL_FREF_MIN			(5 * 1000)
-	#define PLL_FREF_MAX			(30 * 1000)
-	#define PLL_VCO_MIN				(750 * 1000)
-	#define PLL_VCO_MAX				(1500 * 1000)
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	#define PLL_M_MIN				2
-	#define PLL_M_MAX				511
-	#define PLL_N_MIN				1
-	#define PLL_N_MAX				1
-	#define PLL_FREF_MIN			(5 * 1000)
-	#define PLL_FREF_MAX			(25 * 1000)
-	#define PLL_VCO_MIN				(1200 * 1000)
-	#define PLL_VCO_MAX				(3000 * 1000)
-#endif
-	/* VIDEO */
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-	#define DIV_PRE_MAX_CLK_IN		(1300 * 1000)
-	#define DIV_POST_MAX_CLK_IN		(800 * 1000)
-	#define CRT_VID_MAX_CLK_IN		(600 * 1000)
-	#define LCD_VENC_MAX_CLK_IN		(208 * 1000)
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-	#define MIPI_PHY_MAX_CLK_IN		(1000 * 1000)
-	#define DIV_PRE_MAX_CLK_IN		(1500 * 1000)
-	#define DIV_POST_MAX_CLK_IN		(1000 * 1000)
-	#define CRT_VID_MAX_CLK_IN		(1300 * 1000)
-	#define LCD_VENC_MAX_CLK_IN		(333 * 1000)
-#endif
-	/* lcd interface video clk */
-	#define MIPI_MAX_VID_CLK_IN		LCD_VENC_MAX_CLK_IN
-	#define LVDS_MAX_VID_CLK_IN		LCD_VENC_MAX_CLK_IN
-	#define EDP_MAX_VID_CLK_IN		(235 * 1000)
-	#define TTL_MAX_VID_CLK_IN		LCD_VENC_MAX_CLK_IN
-	#define MLVDS_MAX_VID_CLK_IN	LCD_VENC_MAX_CLK_IN
-
-	/* clk max error */
-	#define MAX_ERROR				(2 * 1000)
-
-#define CRT_VID_DIV_MAX				15
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-#define OD_SEL_MAX					2
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-#define OD_SEL_MAX					3
-#endif
-#define DIV_PRE_SEL_MAX				6
-#define EDP_DIV0_SEL_MAX			15
-#define EDP_DIV1_SEL_MAX			8
-
-static const unsigned od_table[4] = {1,2,4,8};
-static const unsigned div_pre_table[6] = {1,2,3,4,5,6};
-static const unsigned edp_div0_table[15]={1,2,3,4,5,7,8,9,11,13,17,19,23,29,31};
-static const unsigned edp_div1_table[8]={1,2,4,5,6,7,9,13};
-//********************************************//
-
-/* for lcd power on/off config */
-typedef enum
-{
+	//clk_ctrl
+	#define CLK_CTRL_AUTO             31
+	//#define CLK_CTRL_VCLK_SEL         30
+	//#define CLK_CTRL_DIV_SEL          29
+	//#define CLK_CTRL_PLL_SEL          28
+	#define CLK_CTRL_RESERVED         12 //[27:12] //for specific CPU define
+	#define CLK_CTRL_SS               8  //[11:8]
+	#define CLK_CTRL_XD               0  //[7:0]
+
+	//pol_ctrl
+	#define POL_CTRL_CLK              6
+	#define POL_CTRL_DE               2
+	#define POL_CTRL_VS               1
+	#define POL_CTRL_HS               0
+	
+	//gamma_ctrl
+	#define GAMMA_CTRL_REVERSE        4
+	#define GAMMA_CTRL_EN             0
+
+typedef enum {
+	GAMMA_SEL_R = 0,
+	GAMMA_SEL_G,
+	GAMMA_SEL_B,
+} Lcd_Gamma_Sel_t;
+//***************************************
+
+typedef enum {
 	LCD_POWER_TYPE_CPU = 0,
 	LCD_POWER_TYPE_PMU,
 	LCD_POWER_TYPE_SIGNAL,
@@ -241,8 +76,7 @@ typedef enum
 	LCD_POWER_TYPE_MAX,
 } Lcd_Power_Type_t;
 
-typedef enum
-{
+typedef enum {
 	LCD_POWER_PMU_GPIO0 = 0,
 	LCD_POWER_PMU_GPIO1,
 	LCD_POWER_PMU_GPIO2,
@@ -272,8 +106,7 @@ static const char* lcd_power_pmu_gpio_table[]={
 	"null",
 }; 
 
-typedef enum
-{
+typedef enum {
 	LCD_DIGITAL_MIPI = 0,
 	LCD_DIGITAL_LVDS,
 	LCD_DIGITAL_EDP,
@@ -291,28 +124,6 @@ static const char* lcd_type_table[]={
 	"invalid",
 };
 
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-#define SS_LEVEL_MAX	7
-static const char *lcd_ss_level_table[]={
-	"0",
-	"0.5%",
-	"1%",
-	"2%",
-	"3%",
-	"4%",
-	"5%",
-};
-#elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-#define SS_LEVEL_MAX	5
-static const char *lcd_ss_level_table[]={
-	"0",
-	"0.5%",
-	"1%",
-	"1.5%",
-	"2%",
-};
-#endif
-
 typedef struct {
 	char *model_name;
 	u16 h_active;		// Horizontal display area
@@ -332,11 +143,15 @@ typedef struct {
 typedef struct {
 	u32 pll_ctrl;		/* video PLL settings */
 	u32 div_ctrl;		/* video pll div settings */
-	u32 clk_ctrl;		/* video clock settings */  //[20]clk_auto, [19:16]ss_ctrl, [12]pll_sel, [8]div_sel, [4]vclk_sel, [3:0]xd
+	u32 clk_ctrl;		/* video clock settings */  //[31]clk_auto, [11:8]ss_ctrl, [7:0]xd
 	u32 lcd_clk;		/* lcd clock*/
 	u16 sync_duration_num;
 	u16 sync_duration_den;
 	
+	u16 pol_ctrl;
+	//u16 inv_cnt_addr;
+	//u16 tcon_misc_sel_addr;
+	
 	u16 video_on_pixel;
 	u16 video_on_line;
 	
@@ -344,104 +159,59 @@ typedef struct {
 	u16 hsync_bp;
 	u16 vsync_width;
 	u16 vsync_bp;
+	u32 vsync_h_phase; //[31]sign [15:0]value
 	u16 hvsync_valid;
 	u16 de_hstart;
 	u16 de_vstart;
 	u16 de_valid;
-	u32 vsync_h_phase; //[31]sign [15:0]value
 	u32 h_offset;
 	u32 v_offset;
 
-	u16 sth1_hs_addr;
-	u16 sth1_he_addr;
-	u16 sth1_vs_addr;
-	u16 sth1_ve_addr;
-
-	u16 oeh_hs_addr;
-	u16 oeh_he_addr;
-	u16 oeh_vs_addr;
-	u16 oeh_ve_addr;
-
-	//u16 vcom_hswitch_addr;
-	//u16 vcom_vs_addr;
-	//u16 vcom_ve_addr;
-
-	//u16 cpv1_hs_addr;
-	//u16 cpv1_he_addr;
-	//u16 cpv1_vs_addr;
-	//u16 cpv1_ve_addr;
-
-	u16 stv1_hs_addr;
-	u16 stv1_he_addr;
-	u16 stv1_vs_addr;
-	u16 stv1_ve_addr;
-
-	//u16 oev1_hs_addr;
-	//u16 oev1_he_addr;
-	//u16 oev1_vs_addr;
-	//u16 oev1_ve_addr;
-
-	u16 pol_cntl_addr;
-	u16 inv_cnt_addr;
-	u16 tcon_misc_sel_addr;
+	u16 de_hs_addr;
+	u16 de_he_addr;
+	u16 de_vs_addr;
+	u16 de_ve_addr;
+
+	u16 hs_hs_addr;
+	u16 hs_he_addr;
+	u16 hs_vs_addr;
+	u16 hs_ve_addr;
+
+	u16 vs_hs_addr;
+	u16 vs_he_addr;
+	u16 vs_vs_addr;
+	u16 vs_ve_addr;
 } Lcd_Timing_t;
 
 // Fine Effect Tune
 typedef struct {
-	u16 gamma_cntl_port;
-	u16 gamma_vcom_hswitch_addr;
-
-	u16 rgb_base_addr;
-	u16 rgb_coeff_addr;
-	u16 dith_user;
-	u16 dith_cntl_addr;
+	u32 rgb_base_addr;
+	u32 rgb_coeff_addr;
+	unsigned char dith_user;
+	u32 dith_cntl_addr;
 
 	u32 vadj_brightness;
 	u32 vadj_contrast;
 	u32 vadj_saturation;
 	
-	unsigned char gamma_revert;
+	unsigned char gamma_ctrl;
 	u16 gamma_r_coeff;
 	u16 gamma_g_coeff;
 	u16 gamma_b_coeff;
 	u16 GammaTableR[256];
 	u16 GammaTableG[256];
 	u16 GammaTableB[256];
+	void (*set_gamma_table)(unsigned gamma_en);
 } Lcd_Effect_t;
 
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
-typedef struct {
-	int channel_num;
-	int hv_sel;
-	int tcon_1st_hs_addr;
-	int tcon_1st_he_addr;
-	int tcon_1st_vs_addr;
-	int tcon_1st_ve_addr;
-	int tcon_2nd_hs_addr;
-	int tcon_2nd_he_addr;
-	int tcon_2nd_vs_addr;
-	int tcon_2nd_ve_addr;
-} MLVDS_Tcon_Config_t;
+//mipi-dsi config
+#define DSI_INIT_ON_MAX           100
+#define DSI_INIT_OFF_MAX          30
 
-typedef struct {
-	int mlvds_insert_start;
-	int total_line_clk;
-	int test_dual_gate;
-	int test_pair_num;
-	int phase_select;
-	int TL080_phase;
-	int scan_function;
-} MLVDS_Config_t;
-#endif
-
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
-#define DSI_INIT_ON_MAX              100
-#define DSI_INIT_OFF_MAX             30
-
-#define BIT_OPERATION_MODE_INIT      0
-#define BIT_OPERATION_MODE_DISP      4
-#define BIT_TRANS_CTRL_CLK           0
-#define BIT_TRANS_CTRL_SWITCH        4 //[5:4]
+#define BIT_OPERATION_MODE_INIT   0
+#define BIT_OPERATION_MODE_DISP   4
+#define BIT_TRANS_CTRL_CLK        0
+#define BIT_TRANS_CTRL_SWITCH     4 //[5:4]
 typedef struct DSI_Config_s{
     unsigned char lane_num;
     unsigned int bit_rate_max;
@@ -449,13 +219,6 @@ typedef struct DSI_Config_s{
     unsigned int bit_rate;
     unsigned int factor_denominator;
     unsigned int factor_numerator;
-    unsigned int hline;
-    unsigned int hsa;
-    unsigned int hbp;
-    unsigned int vsa;
-    unsigned int vbp;
-    unsigned int vfp;
-    unsigned int vact;
 
     unsigned int venc_data_width;
     unsigned int dpi_data_format;
@@ -468,9 +231,9 @@ typedef struct DSI_Config_s{
     unsigned char *dsi_init_off;
     unsigned char lcd_extern_init;
 }DSI_Config_t;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
+
 typedef struct {
+	unsigned char max_lane_count;
 	unsigned char link_user;
 	unsigned char lane_count;
 	unsigned char link_rate;
@@ -478,8 +241,8 @@ typedef struct {
 	unsigned char vswing;
 	unsigned char preemphasis;
 	unsigned int bit_rate;
+	unsigned int sync_clock_mode;
 } EDP_Config_t;
-#endif
 
 typedef struct {
 	unsigned lvds_vswing;
@@ -494,18 +257,35 @@ typedef struct {
 } TTL_Config_t;
 
 typedef struct {
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
+	int channel_num;
+	int hv_sel;
+	int tcon_1st_hs_addr;
+	int tcon_1st_he_addr;
+	int tcon_1st_vs_addr;
+	int tcon_1st_ve_addr;
+	int tcon_2nd_hs_addr;
+	int tcon_2nd_he_addr;
+	int tcon_2nd_vs_addr;
+	int tcon_2nd_ve_addr;
+} MLVDS_Tcon_Config_t;
+
+typedef struct {
+	int mlvds_insert_start;
+	int total_line_clk;
+	int test_dual_gate;
+	int test_pair_num;
+	int phase_select;
+	int TL080_phase;
+	int scan_function;
+} MLVDS_Config_t;
+
+typedef struct {
 	DSI_Config_t *mipi_config;
-#endif
-#if ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8M2))
 	EDP_Config_t *edp_config;
-#endif
 	LVDS_Config_t *lvds_config;
 	TTL_Config_t *ttl_config;
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
 	MLVDS_Config_t *mlvds_config;
 	MLVDS_Tcon_Config_t *mlvds_tcon_config;
-#endif
 } Lcd_Control_Config_t;
 
 typedef enum {
@@ -527,22 +307,43 @@ typedef struct {
 	Lcd_Power_Config_t power_off_config[LCD_POWER_CTRL_STEP_MAX];
 	int power_on_step;
 	int power_off_step;
+	int (*power_ctrl)(Bool_t status);
+	void (*ports_ctrl)(Bool_t status);
+	int (*power_ctrl_video)(Bool_t status);
 } Lcd_Power_Ctrl_t;
 
+typedef struct {
+    struct pinctrl *pin;
+    unsigned char vpp_sel; /*0:vpp, 1:vpp2 */
+    struct class *debug_class;
+    unsigned char lcd_status;
+    void (*module_enable)(void);
+    void (*module_disable)(void);
+    void (*lcd_test)(unsigned num);
+    void (*print_version)(void);
+} Lcd_Misc_Ctrl_t;
+
 typedef struct {
     Lcd_Basic_t lcd_basic;
     Lcd_Timing_t lcd_timing;
     Lcd_Effect_t lcd_effect;
-	Lcd_Control_Config_t lcd_control;
-	Lcd_Power_Ctrl_t lcd_power_ctrl;
+    Lcd_Control_Config_t lcd_control;
+    Lcd_Power_Ctrl_t lcd_power_ctrl;
+    Lcd_Misc_Ctrl_t lcd_misc_ctrl;
 } Lcd_Config_t;
 
+extern Lcd_Config_t* get_lcd_config(void);
+extern void lcd_config_init(Lcd_Config_t *pConf);
+extern void lcd_config_probe(Lcd_Config_t *pConf);
+extern void lcd_config_remove(void);
+
+
 #define LCD_NAME	"lcd"
-#define lcd_gpio_request(gpio) amlogic_gpio_request(gpio, LCD_NAME)
-#define lcd_gpio_free(gpio) amlogic_gpio_free(gpio, LCD_NAME)
-#define lcd_gpio_direction_input(gpio) amlogic_gpio_direction_input(gpio, LCD_NAME)
+#define lcd_gpio_request(gpio)               amlogic_gpio_request(gpio, LCD_NAME)
+#define lcd_gpio_free(gpio)                  amlogic_gpio_free(gpio, LCD_NAME)
+#define lcd_gpio_direction_input(gpio)       amlogic_gpio_direction_input(gpio, LCD_NAME)
 #define lcd_gpio_direction_output(gpio, val) amlogic_gpio_direction_output(gpio, val, LCD_NAME)
-#define lcd_gpio_get_value(gpio) amlogic_get_value(gpio, LCD_NAME)
-#define lcd_gpio_set_value(gpio,val) amlogic_set_value(gpio, val, LCD_NAME)
+#define lcd_gpio_get_value(gpio)             amlogic_get_value(gpio, LCD_NAME)
+#define lcd_gpio_set_value(gpio,val)         amlogic_set_value(gpio, val, LCD_NAME)
 
-#endif /* TCON_H */
+#endif
-- 
2.19.0

