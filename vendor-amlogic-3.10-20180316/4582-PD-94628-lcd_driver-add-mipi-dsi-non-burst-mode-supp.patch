From 72e925a447507146558ef613326ec0fef8e1f38d Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Thu, 24 Jul 2014 15:17:36 +0800
Subject: [PATCH 4582/5965] PD#94628: lcd_driver: add mipi-dsi non-burst mode
 support

Change-Id: I04e2a8fcccc15dff7b60560c453f6afc6b615b50
---
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |   4 +-
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |   4 +-
 arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd  |  12 +-
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |  12 +-
 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd  |  12 +-
 arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd  |  12 +-
 arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd |   4 +-
 .../arm/boot/dts/amlogic/meson8m2_n100_1G.dtd |   4 +-
 .../boot/dts/amlogic/meson8m2_n101_512M.dtd   |   9 +-
 arch/arm/mach-meson6/lcd/lcd_config.c         |  20 +-
 arch/arm/mach-meson8/lcd/lcd_config.c         |  51 ++-
 arch/arm/mach-meson8/lcd/lcd_config.h         |   2 +-
 arch/arm/mach-meson8/lcd/mipi_dsi_util.c      | 333 +++++++++---------
 arch/arm/mach-meson8/lcd/mipi_dsi_util.h      |  15 +
 arch/arm/mach-meson8b/lcd/lcd_config.c        |  50 ++-
 arch/arm/mach-meson8b/lcd/lcd_config.h        |   2 +-
 arch/arm/mach-meson8b/lcd/mipi_dsi_util.c     | 333 +++++++++---------
 arch/arm/mach-meson8b/lcd/mipi_dsi_util.h     |  15 +
 drivers/amlogic/display/vout/aml_lcd.dtd      |  32 +-
 drivers/amlogic/display/vout/lcdoutc.c        |  14 +-
 21 files changed, 476 insertions(+), 472 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index a2f82edace83..d72e6e9367e3 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -1173,7 +1173,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1194,7 +1194,7 @@ sdio{
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 //		dsi_lane_num=<4>;/** mipi dsi data lane number */
-//		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+//		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		dsi_init_on=<0x05 0x11 0 //sleep out
 //					0xff 20      //delay 20ms
 //					0x05 0x29 0  //display on
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index ebf37a2e60ac..52adeb847c03 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -1163,7 +1163,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1184,7 +1184,7 @@ sdio{
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 //		dsi_lane_num=<4>;/** mipi dsi data lane number */
-//		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+//		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		dsi_init_on=<0x05 0x11 0 //sleep out
 //					0xff 20      //delay 20ms
 //					0x05 0x29 0  //display on
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
index bf6ae14cfd67..5c760db565a3 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
@@ -1105,7 +1105,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1127,7 +1127,7 @@ sdio{
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
 		dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 		pclk_lanebyteclk_factor =<0>;/** special adjust, default is 0 */
 		dsi_transfer_ctrl=<0 0>;/** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
 		dsi_init_on=<0x05 0x11 0 //sleep out
@@ -1157,7 +1157,7 @@ sdio{
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 42 = "dsi_init_on"
@@ -1180,7 +1180,7 @@ sdio{
 
 //		dsi_lane_num=<4>;/** mipi dsi data lane number */
 //		dsi_operation_mode=<0 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-//		dsi_bit_rate_min_max=<400 500>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+//		dsi_bit_rate_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
 //		dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
 //		dsi_init_on=<0x15 0x01 1 0x0 
@@ -1296,7 +1296,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1318,7 +1318,7 @@ sdio{
 
 //		dsi_lane_num=<4>;/** mipi dsi data lane number */
 //		dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-//		dsi_bit_rate_min_max=<900 1000>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+//		dsi_bit_rate_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		pclk_lanebyteclk_factor =<15>;   /** special adjust, default is 0 */
 //		dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
 //		dsi_init_on=<0x05 0x11 0 //sleep out
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index 2be5f1ff1321..19bd47b9838a 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -1105,7 +1105,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
 	lcd_B080XAN01:lcd_B080XAN01{	//k101
@@ -1123,7 +1123,7 @@ sdio{
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
-		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 		dsi_init_on=<0x05 0x11 0 //sleep out
 					0xff 20      //delay 20ms
 					0x05 0x29 0  //display on
@@ -1226,7 +1226,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1246,7 +1246,7 @@ sdio{
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 //		dsi_lane_num=<4>;/** mipi dsi data lane number */
-//		dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+//		dsi_bit_rate_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
 //		dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
 //		dsi_init_on=<0x05 0x11 0 //sleep out
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index d8149fd3e2b0..e4e96f2cee43 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -1155,7 +1155,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
 	lcd_KD079D1:lcd_KD079D1{	//k102
@@ -1173,7 +1173,7 @@ sdio{
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 		
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
-		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 		dsi_init_on=<0x05 0x11 0 //sleep out
 					0xff 20      //delay 20ms
 					0x05 0x29 0  //display on
@@ -1200,7 +1200,7 @@ sdio{
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 42 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
 lcd_LD070WX4:lcd_LD070WX4{
@@ -1220,7 +1220,7 @@ lcd_LD070WX4:lcd_LD070WX4{
 		
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
 		dsi_operation_mode=<0 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-		dsi_bit_rate_min_max=<400 500>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 		dsi_init_on=<0x15 0x01 1 0x0 
 				0xff 20     //delay 20ms
 				0x15 0xAE 1 0x0B 
@@ -1332,7 +1332,7 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1352,7 +1352,7 @@ lcd_LD070WX4:lcd_LD070WX4{
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
-		dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 		pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
 		dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
 		dsi_init_on=<0x05 0x11 0 //sleep out
diff --git a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
index 35cd709c8b08..a455a1ece95b 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
@@ -1118,7 +1118,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
 	lcd_B080XAN01:lcd_B080XAN01{	//k101
@@ -1136,7 +1136,7 @@ sdio{
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
-		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 		dsi_init_on=<0x05 0x11 0 //sleep out
 					0xff 20      //delay 20ms
 					0x05 0x29 0  //display on
@@ -1163,7 +1163,7 @@ sdio{
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 42 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
 lcd_LD070WX4:lcd_LD070WX4{
@@ -1183,7 +1183,7 @@ lcd_LD070WX4:lcd_LD070WX4{
 		
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
 		dsi_operation_mode=<0 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-		dsi_bit_rate_min_max=<400 500>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 		dsi_init_on=<0x15 0x01 1 0x0 
 				0xff 20     //delay 20ms
 				0x15 0xAE 1 0x0B 
@@ -1295,7 +1295,7 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1315,7 +1315,7 @@ lcd_LD070WX4:lcd_LD070WX4{
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
-		dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 		pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
 		dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
 		dsi_init_on=<0x05 0x11 0 //sleep out
diff --git a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
index eca47e5e071b..7b317e48139e 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
@@ -1138,7 +1138,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
 	lcd_B080XAN01:lcd_B080XAN01{	//k101
@@ -1156,7 +1156,7 @@ sdio{
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
-		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 		dsi_init_on=<0x05 0x11 0 //sleep out
 					0xff 20      //delay 20ms
 					0x05 0x29 0  //display on
@@ -1183,7 +1183,7 @@ sdio{
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 42 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
 lcd_LD070WX4:lcd_LD070WX4{
@@ -1203,7 +1203,7 @@ lcd_LD070WX4:lcd_LD070WX4{
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
 		dsi_operation_mode=<0 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-		dsi_bit_rate_min_max=<400 500>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 		dsi_init_on=<0x15 0x01 1 0x0 
 				0xff 20     //delay 20ms
 				0x15 0xAE 1 0x0B 
@@ -1315,7 +1315,7 @@ lcd_LD070WX4:lcd_LD070WX4{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1335,7 +1335,7 @@ lcd_LD070WX4:lcd_LD070WX4{
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
-		dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 		pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
 		dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
 		dsi_init_on=<0x05 0x11 0 //sleep out
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
index 205cae34a81d..c16df343b4f4 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
@@ -1147,7 +1147,7 @@ void root_func(){
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1169,7 +1169,7 @@ void root_func(){
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
 		dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 		pclk_lanebyteclk_factor =<0>;/** special adjust, default is 0 */
 		dsi_transfer_ctrl=<0 0>;/** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
 		dsi_init_on=<0x05 0x11 0 //sleep out
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd
index 345ed70bcd88..7d5f5d9513d1 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd
@@ -1167,7 +1167,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1188,7 +1188,7 @@ sdio{
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 //		dsi_lane_num=<4>;/** mipi dsi data lane number */
-//		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+//		dsi_bit_rate_max=<550>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		dsi_init_on=<0x05 0x11 0 //sleep out
 //					0xff 20      //delay 20ms
 //					0x05 0x29 0  //display on
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd
index f2cedcef9ef8..d7ebf2178754 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd
@@ -931,6 +931,7 @@ sdio{
 //$$ L4 PROP_U32 2 = "lvds_user_repack"
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
+//$$ L4 PROP_U32 = "edp_sync_clock_mode"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1099,7 +1100,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1120,7 +1121,7 @@ sdio{
 		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
-		dsi_bit_rate_min_max=<500 600>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 		dsi_init_on=<0x05 0x11 0 //sleep out
 					0xff 20      //delay 20ms
 					0x05 0x29 0  //display on
@@ -1223,7 +1224,7 @@ sdio{
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -1243,7 +1244,7 @@ sdio{
 //		pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
 //		dsi_lane_num=<4>;/** mipi dsi data lane number */
-//		dsi_bit_rate_min_max=<900 1000>;/** range of mipi dsi data lane bit rate(unit: MHz) */
+//		dsi_bit_rate_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
 //		dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
 //		dsi_init_on=<0x05 0x11 0 //sleep out
diff --git a/arch/arm/mach-meson6/lcd/lcd_config.c b/arch/arm/mach-meson6/lcd/lcd_config.c
index d60ebc087262..502aa6d8ec69 100755
--- a/arch/arm/mach-meson6/lcd/lcd_config.c
+++ b/arch/arm/mach-meson6/lcd/lcd_config.c
@@ -658,7 +658,7 @@ static void vclk_set_lcd(int lcd_type, unsigned long pll_reg, unsigned long vid_
 	DBG_PRINT("%s.\n", __FUNCTION__);
 
 	vid_div_reg = ((vid_div_reg & 0x1ffff) | (1 << 16) | (1 << 15) | (0x3 << 0));	//select vid2_pll and enable clk
-	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xf;
+	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xff;
 	
 	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 19, 1);	//disable vclk2_en 
 	udelay(2);
@@ -741,7 +741,7 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
     div_reg = pConf->lcd_timing.div_ctrl;
     clk_reg = pConf->lcd_timing.clk_ctrl;
     ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
-    xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
+    xd = (clk_reg >> CLK_CTRL_XD) & 0xff;
 
     lcd_type = pConf->lcd_basic.lcd_type;
 
@@ -757,9 +757,8 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
         default:
             break;
     }
-    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
+    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
 
-    DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
     vclk_set_lcd(lcd_type, pll_reg, div_reg, clk_reg);
     set_lcd_spread_spectrum(ss_level);
 
@@ -853,7 +852,7 @@ static void set_pll_mlvds(Lcd_Config_t *pConf)
     phy_clk_div2 = (test_pair_num != 3);
 	
 	div_reg = (div_reg | (1 << DIV_CTRL_POST_SEL) | (1 << DIV_CTRL_LVDS_CLK_EN) | ((pll_div_post-1) << DIV_CTRL_DIV_POST) | (phy_clk_div2 << DIV_CTRL_PHY_CLK_DIV2));
-	clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
+	clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
 	DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
 	vclk_set_lcd(lcd_type, pll_reg, div_reg, clk_reg);
 	set_lcd_spread_spectrum(ss_level);
@@ -1582,12 +1581,12 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
     if (clk_num > 0) {
         pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
         pConf->lcd_timing.div_ctrl = 0x18803 | (vid_div_pre << DIV_CTRL_DIV_PRE);
-        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (crt_xd << CLK_CTRL_XD);
+        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) | (crt_xd << CLK_CTRL_XD);
     }
     else {
         pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (32 << PLL_CTRL_M);
         pConf->lcd_timing.div_ctrl = 0x18803;
-        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
         printk("Out of clock range, reset to default setting!\n");
     }
 }
@@ -1614,7 +1613,7 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 			post_div = 7;
 			break;
 		case LCD_DIGITAL_TTL:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
 			post_div = 1;
 			break;
 		case LCD_DIGITAL_MINILVDS:
@@ -1622,7 +1621,7 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 			post_div = 6;
 			break;
 		default:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
 			post_div = 1;
 			break;
 	}
@@ -1842,12 +1841,11 @@ void lcd_config_init(Lcd_Config_t *pConf)
     if ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1) {
         printk("\nAuto generate clock parameters.\n");
         generate_clk_parameter(pConf);
-        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
     }
     else {
         printk("\nCustome clock parameters.\n");
-        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
     }
+    printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
 
     lcd_sync_duration(pConf);
     lcd_tcon_config(pConf);
diff --git a/arch/arm/mach-meson8/lcd/lcd_config.c b/arch/arm/mach-meson8/lcd/lcd_config.c
index ec225144bda4..abb868937870 100755
--- a/arch/arm/mach-meson8/lcd/lcd_config.c
+++ b/arch/arm/mach-meson8/lcd/lcd_config.c
@@ -443,7 +443,7 @@ static void vclk_set_lcd(int lcd_type, unsigned long pll_reg, unsigned long vid_
 	edp_div0_sel = (vid_div_reg >> DIV_CTRL_EDP_DIV0) & 0xf;
 	edp_div1_sel = (vid_div_reg >> DIV_CTRL_EDP_DIV1) & 0x7;
 	vid_div_reg = ((vid_div_reg & 0x1ffff) | (1 << 16) | (1 << 15) | (0x3 << 0));	//select vid2_pll and enable clk
-	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xf;
+	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xff;
 	pll_level = (clk_ctrl_reg >> CLK_CTRL_LEVEL) & 0x7;
 	pll_frac = (clk_ctrl_reg >> CLK_CTRL_FRAC) & 0xfff;
 	ss_level = (clk_ctrl_reg >> CLK_CTRL_SS) & 0xf;
@@ -609,7 +609,7 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
 {
     unsigned pll_reg, div_reg, clk_reg;
     int xd;
-    int lcd_type, ss_level;
+    int lcd_type;
     unsigned pll_div_post = 0, phy_clk_div2 = 0;
 
     DBG_PRINT("%s\n", __FUNCTION__);
@@ -617,8 +617,7 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
     pll_reg = pConf->lcd_timing.pll_ctrl;
     div_reg = pConf->lcd_timing.div_ctrl;
     clk_reg = pConf->lcd_timing.clk_ctrl;
-    ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
-    xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
+    xd = (clk_reg >> CLK_CTRL_XD) & 0xff;
 
     lcd_type = pConf->lcd_basic.lcd_type;
 
@@ -639,9 +638,8 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
         default:
             break;
     }
-    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
+    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
 
-    DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
     vclk_set_lcd(lcd_type, pll_reg, div_reg, clk_reg);
 
     switch(lcd_type){
@@ -811,7 +809,7 @@ static void select_edp_link_config(Lcd_Config_t *pConf)
             if (done == 0)
                 i++;
         }
-        if (edp_lane_count_table[i] > pConf->lcd_control.edp_config->max_lane_count) {
+        if (done == 0) {
             pConf->lcd_control.edp_config->link_rate = 1;
             pConf->lcd_control.edp_config->lane_count = pConf->lcd_control.edp_config->max_lane_count;
             printk("Error: bit_rate is out of support, should reduce frame rate(pixel clock)\n");
@@ -832,7 +830,7 @@ static void select_edp_link_config(Lcd_Config_t *pConf)
                 i++;
             }
         }
-        if (edp_lane_count_table[i] > pConf->lcd_control.edp_config->max_lane_count) {
+        if (done == 0) {
             pConf->lcd_control.edp_config->lane_count = pConf->lcd_control.edp_config->max_lane_count;
             printk("Error: bandwidth is not enough at link_rate=%s, lane_count=%d\n", edp_link_rate_string_table[pConf->lcd_control.edp_config->link_rate], pConf->lcd_control.edp_config->lane_count);
         }
@@ -1254,7 +1252,7 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
         case LCD_DIGITAL_MIPI:
             div_pre_sel_max = DIV_PRE_SEL_MAX;
             div_post = 1;
-            crt_xd_max = 16;
+            crt_xd_max = CRT_VID_DIV_MAX;
             dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
             dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
             iflogic_vid_clk_in_max = MIPI_MAX_VID_CLK_IN;
@@ -1332,18 +1330,13 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
                                             clk_num = 1;
                                             DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
                                                        pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
+                                            goto generate_clk_done;
                                         }
-                                        if (clk_num > 0)
-                                            break;
                                     }
                                 }
-                                if (clk_num > 0)
-                                    break;
                             }
                         }
                     }
-                    if (clk_num > 0)
-                        break;
                 }
             }
             break;
@@ -1455,34 +1448,31 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
                                             DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
                                                        pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
                                             clk_num = 1;
+                                            goto generate_clk_done;
                                         }
-                                        if (clk_num > 0)
-                                            break;
                                     }
                                 }
-                                if (clk_num > 0)
-                                    break;
                             }
                         }
                     }
-                    if (clk_num > 0)
-                        break;
                 }
             }
             break;
         default:
             break;
     }
+
+generate_clk_done:
     if (clk_num > 0) {
         pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
         pConf->lcd_timing.div_ctrl = 0x18803 | (edp_phy_div1 << DIV_CTRL_EDP_DIV1) | (edp_phy_div0 << DIV_CTRL_EDP_DIV0) | (vid_div_pre << DIV_CTRL_DIV_PRE);
-        tmp = (pConf->lcd_timing.clk_ctrl & ~((0xf << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
+        tmp = (pConf->lcd_timing.clk_ctrl & ~((0xff << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
         pConf->lcd_timing.clk_ctrl = (tmp | ((crt_xd << CLK_CTRL_XD) | (pll_level << CLK_CTRL_LEVEL) | (pll_frac << CLK_CTRL_FRAC)));
     }
     else {
         pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (50 << PLL_CTRL_M);
         pConf->lcd_timing.div_ctrl = 0x18803 | (0 << DIV_CTRL_EDP_DIV1) | (0 << DIV_CTRL_EDP_DIV0) | (1 << DIV_CTRL_DIV_PRE);
-        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
         printk("Out of clock range, reset to default setting!\n");
     }
 }
@@ -1509,7 +1499,7 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 	edp_div1 = 0;
 	switch(pConf->lcd_basic.lcd_type) {
 		case LCD_DIGITAL_MIPI:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
 			post_div = 1;
 			break;
 		case LCD_DIGITAL_EDP:
@@ -1523,11 +1513,11 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 			post_div = 7;
 			break;
 		case LCD_DIGITAL_TTL:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
 			post_div = 1;
 			break;
 		default:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
 			post_div = 1;
 			break;
 	}
@@ -1537,8 +1527,10 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 	pll_out_clk = (frac * (od_fb + 1) * FIN_FREQ) / 4096;
 	pll_out_clk = ((m * (od_fb + 1) * FIN_FREQ + pll_out_clk) / (n * od)) * 1000;
 	lcd_clk = pll_out_clk  / (edp_div0 * edp_div1 * pre_div * post_div * xd);
-	if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_MIPI)
+	if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_MIPI) {
 		pConf->lcd_control.mipi_config->bit_rate = pll_out_clk;
+		printk("mipi-dsi bit rate: %d.%03dMHz\n", (pConf->lcd_control.mipi_config->bit_rate / 1000000), ((pConf->lcd_control.mipi_config->bit_rate / 1000) % 1000));
+	}
 	pConf->lcd_timing.lcd_clk = lcd_clk;
 	sync_duration = ((lcd_clk / h_period) * 100) / v_period;
 	sync_duration = (sync_duration + 5) / 10;
@@ -1800,17 +1792,16 @@ void lcd_config_init(Lcd_Config_t *pConf)
     if ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1) {
         printk("\nAuto generate clock parameters.\n");
         generate_clk_parameter(pConf);
-        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
     }
     else {
         printk("\nCustome clock parameters.\n");
-        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
     }
+    printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
 
     lcd_sync_duration(pConf);
     lcd_tcon_config(pConf);
 
-	lcd_control_config_post(pConf);
+    lcd_control_config_post(pConf);
 }
 
 void lcd_config_probe(Lcd_Config_t *pConf)
diff --git a/arch/arm/mach-meson8/lcd/lcd_config.h b/arch/arm/mach-meson8/lcd/lcd_config.h
index 325d72c53e93..bcd657130181 100755
--- a/arch/arm/mach-meson8/lcd/lcd_config.h
+++ b/arch/arm/mach-meson8/lcd/lcd_config.h
@@ -7,7 +7,7 @@
 //lcd driver version
 //**********************************
 #define LCD_DRV_TYPE      "c8"
-#define LCD_DRV_DATE      "20140703"
+#define LCD_DRV_DATE      "20140721"
 //**********************************
 
 /* for GAMMA_CNTL_PORT */
diff --git a/arch/arm/mach-meson8/lcd/mipi_dsi_util.c b/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
index 601aa777b774..83d84e2e6426 100755
--- a/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
+++ b/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
@@ -24,6 +24,8 @@
 #define MIPI_DSI_CMD_TRANS_TYPE         DCS_TRANS_LP            // Define DSI command transfer type: high speed or low power
 #define MIPI_DSI_DCS_ACK_TYPE           MIPI_DSI_DCS_NO_ACK     // Define if DSI command need ack: req_ack or no_ack
 #define MIPI_DSI_VIDEO_MODE_TYPE        BURST_MODE              // Applicable only to video mode. Define data transfer method: non-burst sync pulse; non-burst sync event; or burst.
+#define MIPI_DSI_COLOR_18BIT            COLOR_18BIT_CFG_1
+#define MIPI_DSI_COLOR_24BIT            COLOR_24BIT
 #define MIPI_DSI_TEAR_SWITCH            MIPI_DCS_DISABLE_TEAR
 #define CMD_TIMEOUT_CNT                 3000
 //===============================================================================
@@ -48,6 +50,7 @@ static const char *video_mode_type_table[] = {
 };
 
 static DSI_Phy_t dsi_phy_config;
+static DSI_Vid_t dsi_vid_config;
 static DSI_Config_t *dsi_config = NULL;
 static struct class *dsi_debug_class = NULL;
 static unsigned char dsi_init_on_table_dft[] = {
@@ -77,7 +80,7 @@ static void print_info(void)
     DPRINT("================================================\n");
     DPRINT("MIPI DSI Config\n");
     DPRINT(" Lane Num:              %d\n", dsi_config->lane_num);
-    DPRINT(" Bit Rate min:          %dMHz\n", (dsi_config->bit_rate_min / 1000));
+    //DPRINT(" Bit Rate min:          %dMHz\n", (dsi_config->bit_rate_min / 1000));
     DPRINT(" Bit Rate max:          %dMHz\n", (dsi_config->bit_rate_max / 1000));
     DPRINT(" Bit Rate:              %d.%03dMHz\n", (dsi_config->bit_rate / 1000000), (dsi_config->bit_rate % 1000000) / 1000);
     DPRINT(" Pclk lanebyte factor:  %d\n", ((dsi_config->factor_numerator * 100 / dsi_config->factor_denominator) + 5) / 10);
@@ -681,115 +684,99 @@ static void mipi_dsi_phy_config(Lcd_Config_t *pConf)
 
 static void dsi_video_config(Lcd_Config_t *pConf)
 {
-    unsigned int hline, hsa, hbp;
-    unsigned int vsa, vbp, vfp, vact;
     DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
 
-    hline =(pConf->lcd_basic.h_period * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;  // Rounded. Applicable for Period(pixclk)/Period(bytelaneclk)=9/16
-    hsa =(pConf->lcd_timing.hsync_width * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
-    hbp =((pConf->lcd_timing.hsync_bp-pConf->lcd_timing.hsync_width) * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
+    dsi_vid_config.hline =(pConf->lcd_basic.h_period * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;  // Rounded. Applicable for Period(pixclk)/Period(bytelaneclk)=9/16
+    dsi_vid_config.hsa =(pConf->lcd_timing.hsync_width * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
+    dsi_vid_config.hbp =((pConf->lcd_timing.hsync_bp-pConf->lcd_timing.hsync_width) * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
 
-    vsa = pConf->lcd_timing.vsync_width;
-    vbp = pConf->lcd_timing.vsync_bp - pConf->lcd_timing.vsync_width;
-    vfp = pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp - pConf->lcd_basic.v_active;
-    vact = pConf->lcd_basic.v_active;
+    dsi_vid_config.vsa = pConf->lcd_timing.vsync_width;
+    dsi_vid_config.vbp = pConf->lcd_timing.vsync_bp - pConf->lcd_timing.vsync_width;
+    dsi_vid_config.vfp = pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp - pConf->lcd_basic.v_active;
+    dsi_vid_config.vact = pConf->lcd_basic.v_active;
 
     DBG_PRINT(" ============= VIDEO TIMING SETTING =============\n");
-    DBG_PRINT(" HLINE        = %d\n", hline);
-    DBG_PRINT(" HSA          = %d\n", hsa);
-    DBG_PRINT(" HBP          = %d\n", hbp);
-    DBG_PRINT(" VSA          = %d\n", vsa);
-    DBG_PRINT(" VBP          = %d\n", vbp);
-    DBG_PRINT(" VFP          = %d\n", vfp);
-    DBG_PRINT(" VACT         = %d\n", vact);
+    DBG_PRINT(" HLINE        = %d\n", dsi_vid_config.hline);
+    DBG_PRINT(" HSA          = %d\n", dsi_vid_config.hsa);
+    DBG_PRINT(" HBP          = %d\n", dsi_vid_config.hbp);
+    DBG_PRINT(" VSA          = %d\n", dsi_vid_config.vsa);
+    DBG_PRINT(" VBP          = %d\n", dsi_vid_config.vbp);
+    DBG_PRINT(" VFP          = %d\n", dsi_vid_config.vfp);
+    DBG_PRINT(" VACT         = %d\n", dsi_vid_config.vact);
     DBG_PRINT(" ================================================\n");
-
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HLINE_TIME_OS,    hline);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HSA_TIME_OS,      hsa);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HBP_TIME_OS,      hbp);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VSA_LINES_OS,     vsa);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VBP_LINES_OS,     vbp);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VFP_LINES_OS,     vfp);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VACTIVE_LINES_OS, vact);
 }
 
-static void startup_transfer_cmd(void)
-{
-    // Startup transfer
-    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_AUTOCLKLANE_CTRL) | (0x1 << BIT_TXREQUESTCLKHS));
-}
-static void startup_transfer_video(void)
+#define DSI_PACKET_HEADER_CRC      6 //4(header)+2(CRC)
+static void dsi_non_burst_chunk_config(Lcd_Config_t *pConf)
 {
-    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_TXREQUESTCLKHS));
+    int pixel_per_chunk, num_of_chunk, vid_null_size;
+    int byte_per_chunk, total_bytes_per_chunk, chunk_overhead;
+    int bit_rate_pclk_factor;
+    int lane_num;
+    int i, done;
+
+    i = 1;
+    done = 0;
+    lane_num = (int)(pConf->lcd_control.mipi_config->lane_num);
+    bit_rate_pclk_factor = pConf->lcd_control.mipi_config->bit_rate / pConf->lcd_timing.lcd_clk;
+    while ((i<=(pConf->lcd_basic.h_active/8)) && (done == 0)) {
+        pixel_per_chunk = i * 8;
+        if (pConf->lcd_control.mipi_config->dpi_data_format == COLOR_18BIT_CFG_1)
+            byte_per_chunk = pixel_per_chunk * 9/4; //18bit (4*18/8=9byte)
+        else
+            byte_per_chunk = pixel_per_chunk * 3; //24bit or 18bit-loosely
+        total_bytes_per_chunk = (lane_num * pixel_per_chunk * bit_rate_pclk_factor) / 8;
+        num_of_chunk = pConf->lcd_basic.h_active / pixel_per_chunk;
+        chunk_overhead = total_bytes_per_chunk - (byte_per_chunk + DSI_PACKET_HEADER_CRC); // byte_per_chunk+6=valid_payload
+        if (chunk_overhead >= DSI_PACKET_HEADER_CRC) { // if room for null_vid's head(4)+crc(2)
+            vid_null_size = chunk_overhead - DSI_PACKET_HEADER_CRC; // chunk_overhead-null_vid's head(4)+crc(2) = null_vid's payload
+            done = 1;
+        }
+        else if (chunk_overhead >= 0) {
+            vid_null_size = 0;
+            done = 1;
+        }
+        else
+            vid_null_size = 0;
+        i++;
+    }
+    if (done == 0) {
+        DPRINT(" No room packet header & CRC, chunk_overhead is %d\n", chunk_overhead);
+    }
+
+    dsi_vid_config.pixel_per_chunk = pixel_per_chunk;
+    dsi_vid_config.num_of_chunk = num_of_chunk;
+    dsi_vid_config.vid_null_size = vid_null_size;
+    DBG_PRINT(" ============== NON_BURST SETTINGS =============\n");
+    DBG_PRINT(" pixel_per_chunk       = %d\n", pixel_per_chunk);
+    DBG_PRINT(" num_of_chunk          = %d\n", num_of_chunk);
+    DBG_PRINT(" total_bytes_per_chunk = %d\n", total_bytes_per_chunk);
+    DBG_PRINT(" byte_per_chunk        = %d\n", byte_per_chunk);
+    DBG_PRINT(" chunk_overhead        = %d\n", chunk_overhead);
+    DBG_PRINT(" vid_null_size         = %d\n", vid_null_size);
+    DBG_PRINT(" ===============================================\n");
 }
 
-static void set_mipi_dsi_host(int lane_num,                      // lane number, from 1 to 4
-                              int vcid,                          // virtual id
-                              int venc_data_width,               // VENC output data width
-                              int dpi_data_format,               // dpi data format
-                              int chroma_subsample,              // chroma_subsample for YUV422 or YUV420 only
-                              int operation_mode,                // video mode/command mode
-                              tv_enc_lcd_type_t output_type,     // video type, such as 1080x720
-                              int vid_mode_type,                 // video mode : burst/non_burst
-                              Lcd_Config_t *p)
+// ----------------------------------------------------------------------------
+//                           Function: set_mipi_dsi_host
+// Parameters:
+//              vcid,                    // virtual id
+//              chroma_subsample,        // chroma_subsample for YUV422 or YUV420 only
+//              operation_mode,          // video mode/command mode
+//              p,                       //lcd config
+// ----------------------------------------------------------------------------
+static void set_mipi_dsi_host(unsigned int vcid, unsigned int chroma_subsample, unsigned int operation_mode, Lcd_Config_t *p)
 {
-    int num_of_chunk;
-    int pixel_per_chunk = 4;
-    int byte_per_chunk=0;
-    int totol_bytes_per_chunk;
-    int chunk_overhead;
-    int vid_null_size=0;
-
-    totol_bytes_per_chunk = lane_num*pixel_per_chunk*3/4;
-
-    // one lene has 8 bytes for 4 pixels
-    // according to DSI spec line50
-    switch(dpi_data_format) {
-        case COLOR_24_BIT_YCBCR :
-        case COLOR_24BIT        :
-            byte_per_chunk = 18;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-            // byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-            break;
-        case COLOR_20BIT_LOOSE  :
-        case COLOR_18BIT_CFG_2  :
-            byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-            break;
-        case COLOR_16BIT_YCBCR :
-        case COLOR_16BIT_CFG_1 :
-        case COLOR_16BIT_CFG_2 :
-        case COLOR_16BIT_CFG_3 :
-            byte_per_chunk =  8;                                             // at least 3 lanes(8+6=14): 3*8-14=10>6
-            break;
-        case COLOR_30BIT :
-            byte_per_chunk = 15;                                             // at least 4 lanes(15+6=21): 4*8-21=11>6
-            break;
-        case COLOR_36BIT :
-            byte_per_chunk = 18;                                             // at least 4 leans(18+6=24): 4*8-24=8>6
-            break;
-        case COLOR_12BIT :
-            byte_per_chunk =  6;                                             // at least 3 leans(6+6=12): 3*8-12=12>6
-            break;
-        case COLOR_18BIT_CFG_1 :
-            byte_per_chunk =  9;                                             // at least 23lanes(9+6=15): 3*8-15=9>6
-            break;
-        case COLOR_RGB_111 :
-        case COLOR_RGB_332 :
-        case COLOR_RGB_444 :
-            break;
-        default :
-            DBG_PRINT(" Error: un-support data Format So Far, Please Add More\n");
-            break;
-    }    /*switch(dpi_data_format)*/
-    num_of_chunk = p->lcd_basic.h_active / pixel_per_chunk;
-    chunk_overhead = totol_bytes_per_chunk-(byte_per_chunk+6);                 // byte_per_chunk+6=valid_payload
-
-    if(operation_mode == OPERATION_VIDEO_MODE && vid_mode_type != BURST_MODE) {
-        if(chunk_overhead >= 6) {                                              // if room for null_vid's head(4)+crc(2)
-            vid_null_size = chunk_overhead-6;                                  // chunk_overhead-null_vid's head(4)+crc(2) = null_vid's payload
-        } else {
-            DBG_PRINT(" No room for null, chunk_overhead is %d\n", chunk_overhead);
-        }
-    }
+    unsigned int dpi_data_format, venc_data_width;
+    unsigned int lane_num, vid_mode_type;
+    tv_enc_lcd_type_t  output_type;
+
+    venc_data_width = p->lcd_control.mipi_config->venc_data_width;
+    dpi_data_format = p->lcd_control.mipi_config->dpi_data_format;
+    lane_num        = (unsigned int)(p->lcd_control.mipi_config->lane_num);
+    vid_mode_type   = (unsigned int)(p->lcd_control.mipi_config->video_mode_type);
+    output_type     = p->lcd_control.mipi_config->venc_fmt;
+
     // -----------------------------------------------------
     // Standard Configuration for Video Mode Operation
     // -----------------------------------------------------
@@ -832,35 +819,31 @@ static void set_mipi_dsi_host(int lane_num,                      // lane number,
 
         // 3.2   Configure video packet size settings
         if( vid_mode_type == BURST_MODE ) {                                        // burst mode
-            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, p->lcd_basic.h_active);                          // should be one line in pixels, such as 480/240...
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, p->lcd_basic.h_active);                   // should be one line in pixels, such as 480/240...
         }
-        else if(vid_mode_type == NON_BURST_SYNC_PULSE || vid_mode_type == NON_BURST_SYNC_EVENT) {                           // non-burst mode
-            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, pixel_per_chunk);                    // in unit of pixels, (pclk period/byte clk period)*num_of_lane should be integer
-            // in our system, 16/8*num_of_lane is integer, so 6 pixel should be enough for 24bpp
-            // Worst case: (16/8)*8(pixel)*1(lane) >= 6(pkt head+crc)+3(max 24bpp)
+        else {  // non-burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, dsi_vid_config.pixel_per_chunk);        // in unit of pixels, (pclk period/byte clk period)*num_of_lane should be integer
         }
 
         // 3.3   Configure number of chunks and null packet size for one line
-        if( vid_mode_type == BURST_MODE ) {                                        // burst mode
+        if( vid_mode_type == BURST_MODE ) {                                // burst mode
             WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, 0);
             WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, 0);
         }
-        else {                                                                     // non burst mode
-            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, num_of_chunk);                     // HACT/VID_PKT_SIZE
-            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, vid_null_size);                     // video null size
-            DBG_PRINT(" ============== NON_BURST SETTINGS =============\n");
-            DBG_PRINT(" pixel_per_chunk       = %d\n", pixel_per_chunk);
-            DBG_PRINT(" num_of_chunk          = %d\n", num_of_chunk);
-            DBG_PRINT(" totol_bytes_per_chunk = %d\n", totol_bytes_per_chunk);
-            DBG_PRINT(" byte_per_chunk        = %d\n", byte_per_chunk);
-            DBG_PRINT(" chunk_overhead        = %d\n", chunk_overhead);
-            DBG_PRINT(" vid_null_size         = %d\n", vid_null_size);
-            DBG_PRINT(" ===============================================\n");
+        else {                                                             // non burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, dsi_vid_config.num_of_chunk);  // HACT/VID_PKT_SIZE
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, dsi_vid_config.vid_null_size);  // video null size
         }
 
         // 4     Configure the video relative parameters according to the output type
         //         include horizontal timing and vertical line
-        dsi_video_config(p);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_HLINE_TIME_OS,    dsi_vid_config.hline);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_HSA_TIME_OS,      dsi_vid_config.hsa);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_HBP_TIME_OS,      dsi_vid_config.hbp);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VSA_LINES_OS,     dsi_vid_config.vsa);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VBP_LINES_OS,     dsi_vid_config.vbp);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VFP_LINES_OS,     dsi_vid_config.vfp);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VACTIVE_LINES_OS, dsi_vid_config.vact);
     }  /* operation_mode == OPERATION_VIDEO_MODE */
 
     // -----------------------------------------------------
@@ -899,20 +882,21 @@ static void set_mipi_dsi_host(int lane_num,                      // lane number,
     }
 }
 
+static void startup_transfer_cmd(void)
+{
+    // Startup transfer
+    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_AUTOCLKLANE_CTRL) | (0x1 << BIT_TXREQUESTCLKHS));
+}
+static void startup_transfer_video(void)
+{
+    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_TXREQUESTCLKHS));
+}
+
 static void mipi_dsi_host_config(Lcd_Config_t *pConf)
 {
-    unsigned int        dpi_data_format;
-    unsigned int        venc_data_width;
-    tv_enc_lcd_type_t   venc_format;
-    unsigned char       lane_num;
-    unsigned char       operation_mode_init, video_mode_type;
 
+    unsigned int       operation_mode_init;
     operation_mode_init  = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1);
-    video_mode_type = pConf->lcd_control.mipi_config->video_mode_type;
-    venc_format     = pConf->lcd_control.mipi_config->venc_fmt;
-    venc_data_width = pConf->lcd_control.mipi_config->venc_data_width;
-    dpi_data_format = pConf->lcd_control.mipi_config->dpi_data_format;
-    lane_num        = pConf->lcd_control.mipi_config->lane_num;
 
 #ifdef LCD_DEBUG_INFO
     print_info();
@@ -924,34 +908,21 @@ static void mipi_dsi_host_config(Lcd_Config_t *pConf)
                  MIPI_DSI_DCS_ACK_TYPE,                // if need bta ack check
                  MIPI_DSI_TEAR_SWITCH);                // enable tear ack
 
-    set_mipi_dsi_host(lane_num,                        // Lane number
-                      MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
-                      venc_data_width,                 // MIPI dsi venc data bit width
-                      dpi_data_format,                 // MIPI dsi dpi data format
+    set_mipi_dsi_host(MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
                       0,                               // Chroma sub sample, only for YUV 422 or 420, even or odd
                       operation_mode_init,             // DSI operation mode, video or command
-                      venc_format,                     // Venc resolution format, eg, 240x160
-                      video_mode_type,                 // Video mode, burst or non-burst
                       pConf);
 }
 
 void mipi_dsi_link_on(Lcd_Config_t *pConf)
 {
-    unsigned int      dpi_data_format;
-    unsigned int      venc_data_width;
-    tv_enc_lcd_type_t venc_format;
-    unsigned char     lane_num;
-    unsigned char     operation_mode_disp, video_mode_type;
+    unsigned int      operation_mode_disp, operation_mode_init;
     struct aml_lcd_extern_driver_t *lcd_extern_driver;
     unsigned int init_flag = 0;
 
     DPRINT("%s\n", __FUNCTION__);
     operation_mode_disp = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
-    video_mode_type = pConf->lcd_control.mipi_config->video_mode_type;
-    venc_format     = pConf->lcd_control.mipi_config->venc_fmt;
-    venc_data_width = pConf->lcd_control.mipi_config->venc_data_width;
-    dpi_data_format = pConf->lcd_control.mipi_config->dpi_data_format;
-    lane_num        = pConf->lcd_control.mipi_config->lane_num;
+    operation_mode_init = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1);
 
     if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
         lcd_extern_driver = aml_lcd_extern_get_driver();
@@ -976,15 +947,10 @@ void mipi_dsi_link_on(Lcd_Config_t *pConf)
         dsi_write_cmd(dsi_init_on_table_dft);
     }
 
-    if (operation_mode_disp != ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1)) {
-        set_mipi_dsi_host(lane_num,                        // Lane number
-                          MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
-                          venc_data_width,                 // MIPI dsi venc RGB data bit width
-                          dpi_data_format,                 // MIPI dsi dpi data format
+    if (operation_mode_disp != operation_mode_init) {
+        set_mipi_dsi_host(MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
                           0,                               // Chroma sub sample, only for YUV 422 or 420, even or odd
                           operation_mode_disp,             // DSI operation mode, video or command
-                          venc_format,                     // Venc resolution format, eg, 240x160
-                          video_mode_type,                 // Video mode, burst or non-burst
                           pConf);
     }
 }
@@ -1014,32 +980,54 @@ void mipi_dsi_link_off(Lcd_Config_t *pConf)
 
 void set_mipi_dsi_control_config(Lcd_Config_t *pConf)
 {
-    unsigned int bit_rate;
+    unsigned int bit_rate, lcd_bits;
+    unsigned int operation_mode;
     DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
+    int n;
 
-    if (cfg->bit_rate_max == 0) {
-        bit_rate = ((pConf->lcd_timing.lcd_clk / 1000) * 3 * 8) / cfg->lane_num;
-        cfg->bit_rate_min = bit_rate - 20*1000;
-        cfg->bit_rate_max = bit_rate - 20*1000 + (pConf->lcd_timing.lcd_clk / 1000);
-        DPRINT("mipi dsi bit_rate min=%dMHz, max=%dMHz\n", (cfg->bit_rate_min / 1000), (cfg->bit_rate_max / 1000));
-    }
-    if (cfg->bit_rate_max < (PLL_VCO_MIN / od_table[OD_SEL_MAX-1])) {
-        DPRINT("[error]: mipi-dsi can't support %dMHz bit_rate (min bit_rate=%dMHz)\n", (cfg->bit_rate_max / 1000), ((PLL_VCO_MIN / od_table[OD_SEL_MAX-1]) / 1000));
-    }
-    if (cfg->bit_rate_max > MIPI_PHY_MAX_CLK_IN) {
-        DPRINT("[warning]: mipi-dsi bit_rate_max %dMHz is out of spec (%dMHz)\n", (cfg->bit_rate_max / 1000), (MIPI_PHY_MAX_CLK_IN / 1000));
-    }
-
+    operation_mode = ((cfg->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
     cfg->video_mode_type = MIPI_DSI_VIDEO_MODE_TYPE;
     if(pConf->lcd_basic.lcd_bits == 6){
-        cfg->dpi_data_format = COLOR_18BIT_CFG_2;
         cfg->venc_data_width = MIPI_DSI_VENC_COLOR_18B;
+        cfg->dpi_data_format = MIPI_DSI_COLOR_18BIT;
+        if (cfg->dpi_data_format == COLOR_18BIT_CFG_2)
+            lcd_bits = 8;
+        else
+            lcd_bits = 6;
     }else{
-        cfg->dpi_data_format  = COLOR_24BIT;
         cfg->venc_data_width = MIPI_DSI_VENC_COLOR_24B;
+        cfg->dpi_data_format  = MIPI_DSI_COLOR_24BIT;
+        lcd_bits = 8;
+    }
+    if (cfg->bit_rate_max == 0) { //auto calculate
+        if ((operation_mode == OPERATION_VIDEO_MODE) && (cfg->video_mode_type != BURST_MODE))
+            bit_rate = ((pConf->lcd_timing.lcd_clk / 1000) * 4 * lcd_bits) / cfg->lane_num;
+        else
+            bit_rate = ((pConf->lcd_timing.lcd_clk / 1000) * 3 * lcd_bits) / cfg->lane_num;
+        cfg->bit_rate_min = 0;
+        n = 0;
+        while ((cfg->bit_rate_min < (PLL_VCO_MIN / od_table[OD_SEL_MAX-1])) && (n < 50)) {
+            cfg->bit_rate_max = bit_rate + 20000 + (n * (pConf->lcd_timing.lcd_clk / 1000));
+            cfg->bit_rate_min = cfg->bit_rate_max - (pConf->lcd_timing.lcd_clk / 1000);
+            n++;
+        }
+        if (cfg->bit_rate_max > MIPI_PHY_MAX_CLK_IN) {
+            cfg->bit_rate_max = MIPI_PHY_MAX_CLK_IN;
+            cfg->bit_rate_min = cfg->bit_rate_max - (pConf->lcd_timing.lcd_clk / 1000);
+        }
+        DPRINT("mipi dsi bit_rate max=%dMHz\n", (cfg->bit_rate_max / 1000));
+    }
+    else { //user define
+        cfg->bit_rate_min = cfg->bit_rate_max - (pConf->lcd_timing.lcd_clk / 1000);
+        if (cfg->bit_rate_max < (PLL_VCO_MIN / od_table[OD_SEL_MAX-1])) {
+            DPRINT("[error]: mipi-dsi can't support %dMHz bit_rate (min bit_rate=%dMHz)\n", (cfg->bit_rate_max / 1000), ((PLL_VCO_MIN / od_table[OD_SEL_MAX-1]) / 1000));
+        }
+        if (cfg->bit_rate_max > MIPI_PHY_MAX_CLK_IN) {
+            DPRINT("[warning]: mipi-dsi bit_rate_max %dMHz is out of spec (%dMHz)\n", (cfg->bit_rate_max / 1000), (MIPI_PHY_MAX_CLK_IN / 1000));
+        }
     }
 
-    switch ((cfg->transfer_ctrl >> BIT_TRANS_CTRL_SWITCH) & 3) {
+    switch ((cfg->transfer_ctrl >> BIT_TRANS_CTRL_SWITCH) & 3) {//Venc resolution format
         case 1: //standard
             cfg->venc_fmt=TV_ENC_LCD768x1024p;
             break;
@@ -1058,7 +1046,8 @@ void set_mipi_dsi_control_config(Lcd_Config_t *pConf)
 
 void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf)
 {
-    unsigned pclk, lanebyteclk;
+    unsigned int pclk, lanebyteclk;
+    unsigned int operation_mode;
     DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
 
     pclk = pConf->lcd_timing.lcd_clk;
@@ -1075,6 +1064,13 @@ void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf)
     DBG_PRINT("d=%d, n=%d, factor=%d.%02d\n", cfg->factor_denominator, cfg->factor_numerator, (cfg->factor_denominator/cfg->factor_numerator), 
              ((cfg->factor_denominator % cfg->factor_numerator) * 100 / cfg->factor_numerator));
 
+    operation_mode = ((cfg->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
+    if (operation_mode == OPERATION_VIDEO_MODE) {
+        dsi_video_config(pConf);
+        if (cfg->video_mode_type != BURST_MODE)
+            dsi_non_burst_chunk_config(pConf);
+    }
+
     set_dsi_phy_config(&dsi_phy_config, cfg->bit_rate);
 }
 
@@ -1205,7 +1201,8 @@ static int remove_dsi_attr(void)
 void dsi_probe(Lcd_Config_t *pConf)
 {
     dsi_config = pConf->lcd_control.mipi_config;
-    pConf->lcd_control.mipi_config->bit_rate_min *= 1000;
+
+    //pConf->lcd_control.mipi_config->bit_rate_min *= 1000;
     pConf->lcd_control.mipi_config->bit_rate_max *= 1000;
 
     creat_dsi_attr();
diff --git a/arch/arm/mach-meson8/lcd/mipi_dsi_util.h b/arch/arm/mach-meson8/lcd/mipi_dsi_util.h
index 972abcfb88e5..c8dc1991c36c 100755
--- a/arch/arm/mach-meson8/lcd/mipi_dsi_util.h
+++ b/arch/arm/mach-meson8/lcd/mipi_dsi_util.h
@@ -417,6 +417,21 @@ typedef struct DSI_Phy_s{
 }DSI_Phy_t;
 //********************************************************************************
 
+typedef struct DSI_Vid_s{
+    unsigned int hline;
+    unsigned int hsa;
+    unsigned int hbp;
+    unsigned int vsa;
+    unsigned int vbp;
+    unsigned int vfp;
+    unsigned int vact;
+
+    //for non-burst chunk overhead
+    unsigned int pixel_per_chunk;
+    unsigned int num_of_chunk;
+    unsigned int vid_null_size;
+}DSI_Vid_t;
+
 #define DSI_CMD_SIZE_MAX		2000
 
 extern void set_mipi_dsi_control_config(Lcd_Config_t *pConf);
diff --git a/arch/arm/mach-meson8b/lcd/lcd_config.c b/arch/arm/mach-meson8b/lcd/lcd_config.c
index db23c4c37396..96e194f4cdf6 100755
--- a/arch/arm/mach-meson8b/lcd/lcd_config.c
+++ b/arch/arm/mach-meson8b/lcd/lcd_config.c
@@ -197,8 +197,6 @@ static void set_control_mipi(Lcd_Config_t *pConf);
 //for special interface
 static int lcd_power_ctrl_video(Bool_t status)
 {
-    int ret = 0;
-
     if (status) {
         switch(lcd_Conf->lcd_basic.lcd_type) {
             case LCD_DIGITAL_MIPI:
@@ -218,7 +216,7 @@ static int lcd_power_ctrl_video(Bool_t status)
         }
     }
     DBG_PRINT("%s: %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
-    return ret;
+    return 0;
 }
 
 #define LCD_GAMMA_RETRY_CNT  1000
@@ -372,7 +370,7 @@ static void vclk_set_lcd(int lcd_type, unsigned long pll_reg, unsigned long vid_
 	DBG_PRINT("%s\n", __FUNCTION__);
 
 	vid_div_reg = ((vid_div_reg & 0x1ffff) | (1 << 16) | (1 << 15) | (0x3 << 0));	//select vid2_pll and enable clk
-	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xf;
+	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xff;
 	pll_level = (clk_ctrl_reg >> CLK_CTRL_LEVEL) & 0x7;
 	pll_frac = (clk_ctrl_reg >> CLK_CTRL_FRAC) & 0xfff;
 	ss_level = (clk_ctrl_reg >> CLK_CTRL_SS) & 0xf;
@@ -512,7 +510,7 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
 {
     unsigned pll_reg, div_reg, clk_reg;
     int xd;
-    int lcd_type, ss_level;
+    int lcd_type;
     unsigned pll_div_post = 0, phy_clk_div2 = 0;
 
     DBG_PRINT("%s\n", __FUNCTION__);
@@ -520,8 +518,7 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
     pll_reg = pConf->lcd_timing.pll_ctrl;
     div_reg = pConf->lcd_timing.div_ctrl;
     clk_reg = pConf->lcd_timing.clk_ctrl;
-    ss_level = (clk_reg >> CLK_CTRL_SS) & 0xf;
-    xd = (clk_reg >> CLK_CTRL_XD) & 0xf;
+    xd = (clk_reg >> CLK_CTRL_XD) & 0xff;
 
     lcd_type = pConf->lcd_basic.lcd_type;
 
@@ -539,9 +536,8 @@ static void set_pll_lcd(Lcd_Config_t *pConf)
         default:
             break;
     }
-    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
+    clk_reg = (pConf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) | (xd << CLK_CTRL_XD);
 
-    DBG_PRINT("ss_level=%u(%s), pll_reg=0x%x, div_reg=0x%x, xd=%d.\n", ss_level, lcd_ss_level_table[ss_level], pll_reg, div_reg, xd);
     vclk_set_lcd(lcd_type, pll_reg, div_reg, clk_reg);
 
     switch(lcd_type){
@@ -806,6 +802,7 @@ static void _disable_lcd_driver(Lcd_Config_t *pConf)
     WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1);	//disable lvds fifo
 
     WRITE_LCD_REG(ENCL_VIDEO_EN, 0);	//disable encl
+    WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 0, 3, 1);	//disable CTS_ENCL
 
     WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 0, 5);	//close vclk2 gate: 0x104b[4:0]
 
@@ -946,7 +943,7 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
         case LCD_DIGITAL_MIPI:
             div_pre_sel_max = DIV_PRE_SEL_MAX;
             div_post = 1;
-            crt_xd_max = 16;
+            crt_xd_max = CRT_VID_DIV_MAX;
             dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
             dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
             iflogic_vid_clk_in_max = MIPI_MAX_VID_CLK_IN;
@@ -1017,18 +1014,13 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
                                             clk_num = 1;
                                             DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
                                                        pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
+                                            goto generate_clk_done;
                                         }
-                                        if (clk_num > 0)
-                                            break;
                                     }
                                 }
-                                if (clk_num > 0)
-                                    break;
                             }
                         }
                     }
-                    if (clk_num > 0)
-                        break;
                 }
             }
             break;
@@ -1079,34 +1071,31 @@ static void generate_clk_parameter(Lcd_Config_t *pConf)
                                             DBG_PRINT("pll_m=0x%x, pll_n=0x%x, pll_od=0x%x, vid_div_pre=0x%x, crt_xd=0x%x, pll_frac=0x%x, pll_level=%d\n",
                                                        pll_m, pll_n, pll_od, vid_div_pre, crt_xd, pll_frac, pll_level);
                                             clk_num = 1;
+                                            goto generate_clk_done;
                                         }
-                                        if (clk_num > 0)
-                                            break;
                                     }
                                 }
-                                if (clk_num > 0)
-                                    break;
                             }
                         }
                     }
-                    if (clk_num > 0)
-                        break;
                 }
             }
             break;
         default:
             break;
     }
+
+generate_clk_done:
     if (clk_num > 0) {
         pConf->lcd_timing.pll_ctrl = (pll_od << PLL_CTRL_OD) | (pll_n << PLL_CTRL_N) | (pll_m << PLL_CTRL_M);
         pConf->lcd_timing.div_ctrl = 0x18803 | (vid_div_pre << DIV_CTRL_DIV_PRE);
-        tmp = (pConf->lcd_timing.clk_ctrl & ~((0xf << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
+        tmp = (pConf->lcd_timing.clk_ctrl & ~((0xff << CLK_CTRL_XD) | (0x7 << CLK_CTRL_LEVEL) | (0xfff << CLK_CTRL_FRAC)));
         pConf->lcd_timing.clk_ctrl = (tmp | ((crt_xd << CLK_CTRL_XD) | (pll_level << CLK_CTRL_LEVEL) | (pll_frac << CLK_CTRL_FRAC)));
     }
     else {
         pConf->lcd_timing.pll_ctrl = (1 << PLL_CTRL_OD) | (1 << PLL_CTRL_N) | (50 << PLL_CTRL_M);
         pConf->lcd_timing.div_ctrl = 0x18803 | (1 << DIV_CTRL_DIV_PRE);
-        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+        pConf->lcd_timing.clk_ctrl = (pConf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
         printk("Out of clock range, reset to default setting!\n");
     }
 }
@@ -1131,7 +1120,7 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 	
 	switch(pConf->lcd_basic.lcd_type) {
 		case LCD_DIGITAL_MIPI:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
 			post_div = 1;
 			break;
 		case LCD_DIGITAL_LVDS:
@@ -1139,11 +1128,11 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 			post_div = 7;
 			break;
 		case LCD_DIGITAL_TTL:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
 			post_div = 1;
 			break;
 		default:
-			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xf;
+			xd = ((pConf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
 			post_div = 1;
 			break;
 	}
@@ -1151,8 +1140,10 @@ static void lcd_sync_duration(Lcd_Config_t *pConf)
 	pll_out_clk = (frac * (od_fb + 1) * FIN_FREQ) / 4096;
 	pll_out_clk = ((m * (od_fb + 1) * FIN_FREQ + pll_out_clk) / (n * od)) * 1000;
 	lcd_clk = pll_out_clk  / (pre_div * post_div * xd);
-	if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_MIPI)
+	if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_MIPI) {
 		pConf->lcd_control.mipi_config->bit_rate = pll_out_clk;
+		printf("mipi-dsi bit rate: %d.%03dMHz\n", (pConf->lcd_control.mipi_config->bit_rate / 1000000), ((pConf->lcd_control.mipi_config->bit_rate / 1000) % 1000));
+	}
 	pConf->lcd_timing.lcd_clk = lcd_clk;
 	sync_duration = ((lcd_clk / h_period) * 100) / v_period;
 	sync_duration = (sync_duration + 5) / 10;
@@ -1396,12 +1387,11 @@ void lcd_config_init(Lcd_Config_t *pConf)
     if ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1) {
         printk("\nAuto generate clock parameters.\n");
         generate_clk_parameter(pConf);
-        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
     }
     else {
         printk("\nCustome clock parameters.\n");
-        printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
     }
+    printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl);
 
     lcd_sync_duration(pConf);
     lcd_tcon_config(pConf);
diff --git a/arch/arm/mach-meson8b/lcd/lcd_config.h b/arch/arm/mach-meson8b/lcd/lcd_config.h
index bc3f778ab0f9..e31d2d9380e4 100755
--- a/arch/arm/mach-meson8b/lcd/lcd_config.h
+++ b/arch/arm/mach-meson8b/lcd/lcd_config.h
@@ -7,7 +7,7 @@
 //lcd driver version
 //**********************************
 #define LCD_DRV_TYPE      "c8b"
-#define LCD_DRV_DATE      "20140703"
+#define LCD_DRV_DATE      "20140721"
 //**********************************
 
 /* for GAMMA_CNTL_PORT */
diff --git a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
index 601aa777b774..83d84e2e6426 100755
--- a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
+++ b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
@@ -24,6 +24,8 @@
 #define MIPI_DSI_CMD_TRANS_TYPE         DCS_TRANS_LP            // Define DSI command transfer type: high speed or low power
 #define MIPI_DSI_DCS_ACK_TYPE           MIPI_DSI_DCS_NO_ACK     // Define if DSI command need ack: req_ack or no_ack
 #define MIPI_DSI_VIDEO_MODE_TYPE        BURST_MODE              // Applicable only to video mode. Define data transfer method: non-burst sync pulse; non-burst sync event; or burst.
+#define MIPI_DSI_COLOR_18BIT            COLOR_18BIT_CFG_1
+#define MIPI_DSI_COLOR_24BIT            COLOR_24BIT
 #define MIPI_DSI_TEAR_SWITCH            MIPI_DCS_DISABLE_TEAR
 #define CMD_TIMEOUT_CNT                 3000
 //===============================================================================
@@ -48,6 +50,7 @@ static const char *video_mode_type_table[] = {
 };
 
 static DSI_Phy_t dsi_phy_config;
+static DSI_Vid_t dsi_vid_config;
 static DSI_Config_t *dsi_config = NULL;
 static struct class *dsi_debug_class = NULL;
 static unsigned char dsi_init_on_table_dft[] = {
@@ -77,7 +80,7 @@ static void print_info(void)
     DPRINT("================================================\n");
     DPRINT("MIPI DSI Config\n");
     DPRINT(" Lane Num:              %d\n", dsi_config->lane_num);
-    DPRINT(" Bit Rate min:          %dMHz\n", (dsi_config->bit_rate_min / 1000));
+    //DPRINT(" Bit Rate min:          %dMHz\n", (dsi_config->bit_rate_min / 1000));
     DPRINT(" Bit Rate max:          %dMHz\n", (dsi_config->bit_rate_max / 1000));
     DPRINT(" Bit Rate:              %d.%03dMHz\n", (dsi_config->bit_rate / 1000000), (dsi_config->bit_rate % 1000000) / 1000);
     DPRINT(" Pclk lanebyte factor:  %d\n", ((dsi_config->factor_numerator * 100 / dsi_config->factor_denominator) + 5) / 10);
@@ -681,115 +684,99 @@ static void mipi_dsi_phy_config(Lcd_Config_t *pConf)
 
 static void dsi_video_config(Lcd_Config_t *pConf)
 {
-    unsigned int hline, hsa, hbp;
-    unsigned int vsa, vbp, vfp, vact;
     DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
 
-    hline =(pConf->lcd_basic.h_period * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;  // Rounded. Applicable for Period(pixclk)/Period(bytelaneclk)=9/16
-    hsa =(pConf->lcd_timing.hsync_width * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
-    hbp =((pConf->lcd_timing.hsync_bp-pConf->lcd_timing.hsync_width) * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
+    dsi_vid_config.hline =(pConf->lcd_basic.h_period * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;  // Rounded. Applicable for Period(pixclk)/Period(bytelaneclk)=9/16
+    dsi_vid_config.hsa =(pConf->lcd_timing.hsync_width * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
+    dsi_vid_config.hbp =((pConf->lcd_timing.hsync_bp-pConf->lcd_timing.hsync_width) * cfg->factor_denominator + cfg->factor_numerator - 1) / cfg->factor_numerator;
 
-    vsa = pConf->lcd_timing.vsync_width;
-    vbp = pConf->lcd_timing.vsync_bp - pConf->lcd_timing.vsync_width;
-    vfp = pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp - pConf->lcd_basic.v_active;
-    vact = pConf->lcd_basic.v_active;
+    dsi_vid_config.vsa = pConf->lcd_timing.vsync_width;
+    dsi_vid_config.vbp = pConf->lcd_timing.vsync_bp - pConf->lcd_timing.vsync_width;
+    dsi_vid_config.vfp = pConf->lcd_basic.v_period - pConf->lcd_timing.vsync_bp - pConf->lcd_basic.v_active;
+    dsi_vid_config.vact = pConf->lcd_basic.v_active;
 
     DBG_PRINT(" ============= VIDEO TIMING SETTING =============\n");
-    DBG_PRINT(" HLINE        = %d\n", hline);
-    DBG_PRINT(" HSA          = %d\n", hsa);
-    DBG_PRINT(" HBP          = %d\n", hbp);
-    DBG_PRINT(" VSA          = %d\n", vsa);
-    DBG_PRINT(" VBP          = %d\n", vbp);
-    DBG_PRINT(" VFP          = %d\n", vfp);
-    DBG_PRINT(" VACT         = %d\n", vact);
+    DBG_PRINT(" HLINE        = %d\n", dsi_vid_config.hline);
+    DBG_PRINT(" HSA          = %d\n", dsi_vid_config.hsa);
+    DBG_PRINT(" HBP          = %d\n", dsi_vid_config.hbp);
+    DBG_PRINT(" VSA          = %d\n", dsi_vid_config.vsa);
+    DBG_PRINT(" VBP          = %d\n", dsi_vid_config.vbp);
+    DBG_PRINT(" VFP          = %d\n", dsi_vid_config.vfp);
+    DBG_PRINT(" VACT         = %d\n", dsi_vid_config.vact);
     DBG_PRINT(" ================================================\n");
-
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HLINE_TIME_OS,    hline);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HSA_TIME_OS,      hsa);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_HBP_TIME_OS,      hbp);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VSA_LINES_OS,     vsa);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VBP_LINES_OS,     vbp);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VFP_LINES_OS,     vfp);
-    WRITE_LCD_REG( MIPI_DSI_DWC_VID_VACTIVE_LINES_OS, vact);
 }
 
-static void startup_transfer_cmd(void)
-{
-    // Startup transfer
-    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_AUTOCLKLANE_CTRL) | (0x1 << BIT_TXREQUESTCLKHS));
-}
-static void startup_transfer_video(void)
+#define DSI_PACKET_HEADER_CRC      6 //4(header)+2(CRC)
+static void dsi_non_burst_chunk_config(Lcd_Config_t *pConf)
 {
-    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_TXREQUESTCLKHS));
+    int pixel_per_chunk, num_of_chunk, vid_null_size;
+    int byte_per_chunk, total_bytes_per_chunk, chunk_overhead;
+    int bit_rate_pclk_factor;
+    int lane_num;
+    int i, done;
+
+    i = 1;
+    done = 0;
+    lane_num = (int)(pConf->lcd_control.mipi_config->lane_num);
+    bit_rate_pclk_factor = pConf->lcd_control.mipi_config->bit_rate / pConf->lcd_timing.lcd_clk;
+    while ((i<=(pConf->lcd_basic.h_active/8)) && (done == 0)) {
+        pixel_per_chunk = i * 8;
+        if (pConf->lcd_control.mipi_config->dpi_data_format == COLOR_18BIT_CFG_1)
+            byte_per_chunk = pixel_per_chunk * 9/4; //18bit (4*18/8=9byte)
+        else
+            byte_per_chunk = pixel_per_chunk * 3; //24bit or 18bit-loosely
+        total_bytes_per_chunk = (lane_num * pixel_per_chunk * bit_rate_pclk_factor) / 8;
+        num_of_chunk = pConf->lcd_basic.h_active / pixel_per_chunk;
+        chunk_overhead = total_bytes_per_chunk - (byte_per_chunk + DSI_PACKET_HEADER_CRC); // byte_per_chunk+6=valid_payload
+        if (chunk_overhead >= DSI_PACKET_HEADER_CRC) { // if room for null_vid's head(4)+crc(2)
+            vid_null_size = chunk_overhead - DSI_PACKET_HEADER_CRC; // chunk_overhead-null_vid's head(4)+crc(2) = null_vid's payload
+            done = 1;
+        }
+        else if (chunk_overhead >= 0) {
+            vid_null_size = 0;
+            done = 1;
+        }
+        else
+            vid_null_size = 0;
+        i++;
+    }
+    if (done == 0) {
+        DPRINT(" No room packet header & CRC, chunk_overhead is %d\n", chunk_overhead);
+    }
+
+    dsi_vid_config.pixel_per_chunk = pixel_per_chunk;
+    dsi_vid_config.num_of_chunk = num_of_chunk;
+    dsi_vid_config.vid_null_size = vid_null_size;
+    DBG_PRINT(" ============== NON_BURST SETTINGS =============\n");
+    DBG_PRINT(" pixel_per_chunk       = %d\n", pixel_per_chunk);
+    DBG_PRINT(" num_of_chunk          = %d\n", num_of_chunk);
+    DBG_PRINT(" total_bytes_per_chunk = %d\n", total_bytes_per_chunk);
+    DBG_PRINT(" byte_per_chunk        = %d\n", byte_per_chunk);
+    DBG_PRINT(" chunk_overhead        = %d\n", chunk_overhead);
+    DBG_PRINT(" vid_null_size         = %d\n", vid_null_size);
+    DBG_PRINT(" ===============================================\n");
 }
 
-static void set_mipi_dsi_host(int lane_num,                      // lane number, from 1 to 4
-                              int vcid,                          // virtual id
-                              int venc_data_width,               // VENC output data width
-                              int dpi_data_format,               // dpi data format
-                              int chroma_subsample,              // chroma_subsample for YUV422 or YUV420 only
-                              int operation_mode,                // video mode/command mode
-                              tv_enc_lcd_type_t output_type,     // video type, such as 1080x720
-                              int vid_mode_type,                 // video mode : burst/non_burst
-                              Lcd_Config_t *p)
+// ----------------------------------------------------------------------------
+//                           Function: set_mipi_dsi_host
+// Parameters:
+//              vcid,                    // virtual id
+//              chroma_subsample,        // chroma_subsample for YUV422 or YUV420 only
+//              operation_mode,          // video mode/command mode
+//              p,                       //lcd config
+// ----------------------------------------------------------------------------
+static void set_mipi_dsi_host(unsigned int vcid, unsigned int chroma_subsample, unsigned int operation_mode, Lcd_Config_t *p)
 {
-    int num_of_chunk;
-    int pixel_per_chunk = 4;
-    int byte_per_chunk=0;
-    int totol_bytes_per_chunk;
-    int chunk_overhead;
-    int vid_null_size=0;
-
-    totol_bytes_per_chunk = lane_num*pixel_per_chunk*3/4;
-
-    // one lene has 8 bytes for 4 pixels
-    // according to DSI spec line50
-    switch(dpi_data_format) {
-        case COLOR_24_BIT_YCBCR :
-        case COLOR_24BIT        :
-            byte_per_chunk = 18;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-            // byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-            break;
-        case COLOR_20BIT_LOOSE  :
-        case COLOR_18BIT_CFG_2  :
-            byte_per_chunk = 12;                                             // at least 3 lanes(12+6)=18: 3*8-18=6>=6
-            break;
-        case COLOR_16BIT_YCBCR :
-        case COLOR_16BIT_CFG_1 :
-        case COLOR_16BIT_CFG_2 :
-        case COLOR_16BIT_CFG_3 :
-            byte_per_chunk =  8;                                             // at least 3 lanes(8+6=14): 3*8-14=10>6
-            break;
-        case COLOR_30BIT :
-            byte_per_chunk = 15;                                             // at least 4 lanes(15+6=21): 4*8-21=11>6
-            break;
-        case COLOR_36BIT :
-            byte_per_chunk = 18;                                             // at least 4 leans(18+6=24): 4*8-24=8>6
-            break;
-        case COLOR_12BIT :
-            byte_per_chunk =  6;                                             // at least 3 leans(6+6=12): 3*8-12=12>6
-            break;
-        case COLOR_18BIT_CFG_1 :
-            byte_per_chunk =  9;                                             // at least 23lanes(9+6=15): 3*8-15=9>6
-            break;
-        case COLOR_RGB_111 :
-        case COLOR_RGB_332 :
-        case COLOR_RGB_444 :
-            break;
-        default :
-            DBG_PRINT(" Error: un-support data Format So Far, Please Add More\n");
-            break;
-    }    /*switch(dpi_data_format)*/
-    num_of_chunk = p->lcd_basic.h_active / pixel_per_chunk;
-    chunk_overhead = totol_bytes_per_chunk-(byte_per_chunk+6);                 // byte_per_chunk+6=valid_payload
-
-    if(operation_mode == OPERATION_VIDEO_MODE && vid_mode_type != BURST_MODE) {
-        if(chunk_overhead >= 6) {                                              // if room for null_vid's head(4)+crc(2)
-            vid_null_size = chunk_overhead-6;                                  // chunk_overhead-null_vid's head(4)+crc(2) = null_vid's payload
-        } else {
-            DBG_PRINT(" No room for null, chunk_overhead is %d\n", chunk_overhead);
-        }
-    }
+    unsigned int dpi_data_format, venc_data_width;
+    unsigned int lane_num, vid_mode_type;
+    tv_enc_lcd_type_t  output_type;
+
+    venc_data_width = p->lcd_control.mipi_config->venc_data_width;
+    dpi_data_format = p->lcd_control.mipi_config->dpi_data_format;
+    lane_num        = (unsigned int)(p->lcd_control.mipi_config->lane_num);
+    vid_mode_type   = (unsigned int)(p->lcd_control.mipi_config->video_mode_type);
+    output_type     = p->lcd_control.mipi_config->venc_fmt;
+
     // -----------------------------------------------------
     // Standard Configuration for Video Mode Operation
     // -----------------------------------------------------
@@ -832,35 +819,31 @@ static void set_mipi_dsi_host(int lane_num,                      // lane number,
 
         // 3.2   Configure video packet size settings
         if( vid_mode_type == BURST_MODE ) {                                        // burst mode
-            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, p->lcd_basic.h_active);                          // should be one line in pixels, such as 480/240...
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, p->lcd_basic.h_active);                   // should be one line in pixels, such as 480/240...
         }
-        else if(vid_mode_type == NON_BURST_SYNC_PULSE || vid_mode_type == NON_BURST_SYNC_EVENT) {                           // non-burst mode
-            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, pixel_per_chunk);                    // in unit of pixels, (pclk period/byte clk period)*num_of_lane should be integer
-            // in our system, 16/8*num_of_lane is integer, so 6 pixel should be enough for 24bpp
-            // Worst case: (16/8)*8(pixel)*1(lane) >= 6(pkt head+crc)+3(max 24bpp)
+        else {  // non-burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_PKT_SIZE_OS, dsi_vid_config.pixel_per_chunk);        // in unit of pixels, (pclk period/byte clk period)*num_of_lane should be integer
         }
 
         // 3.3   Configure number of chunks and null packet size for one line
-        if( vid_mode_type == BURST_MODE ) {                                        // burst mode
+        if( vid_mode_type == BURST_MODE ) {                                // burst mode
             WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, 0);
             WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, 0);
         }
-        else {                                                                     // non burst mode
-            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, num_of_chunk);                     // HACT/VID_PKT_SIZE
-            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, vid_null_size);                     // video null size
-            DBG_PRINT(" ============== NON_BURST SETTINGS =============\n");
-            DBG_PRINT(" pixel_per_chunk       = %d\n", pixel_per_chunk);
-            DBG_PRINT(" num_of_chunk          = %d\n", num_of_chunk);
-            DBG_PRINT(" totol_bytes_per_chunk = %d\n", totol_bytes_per_chunk);
-            DBG_PRINT(" byte_per_chunk        = %d\n", byte_per_chunk);
-            DBG_PRINT(" chunk_overhead        = %d\n", chunk_overhead);
-            DBG_PRINT(" vid_null_size         = %d\n", vid_null_size);
-            DBG_PRINT(" ===============================================\n");
+        else {                                                             // non burst mode
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NUM_CHUNKS_OS, dsi_vid_config.num_of_chunk);  // HACT/VID_PKT_SIZE
+            WRITE_LCD_REG( MIPI_DSI_DWC_VID_NULL_SIZE_OS, dsi_vid_config.vid_null_size);  // video null size
         }
 
         // 4     Configure the video relative parameters according to the output type
         //         include horizontal timing and vertical line
-        dsi_video_config(p);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_HLINE_TIME_OS,    dsi_vid_config.hline);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_HSA_TIME_OS,      dsi_vid_config.hsa);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_HBP_TIME_OS,      dsi_vid_config.hbp);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VSA_LINES_OS,     dsi_vid_config.vsa);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VBP_LINES_OS,     dsi_vid_config.vbp);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VFP_LINES_OS,     dsi_vid_config.vfp);
+        WRITE_LCD_REG( MIPI_DSI_DWC_VID_VACTIVE_LINES_OS, dsi_vid_config.vact);
     }  /* operation_mode == OPERATION_VIDEO_MODE */
 
     // -----------------------------------------------------
@@ -899,20 +882,21 @@ static void set_mipi_dsi_host(int lane_num,                      // lane number,
     }
 }
 
+static void startup_transfer_cmd(void)
+{
+    // Startup transfer
+    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_AUTOCLKLANE_CTRL) | (0x1 << BIT_TXREQUESTCLKHS));
+}
+static void startup_transfer_video(void)
+{
+    WRITE_LCD_REG( MIPI_DSI_DWC_LPCLK_CTRL_OS, (0x1 << BIT_TXREQUESTCLKHS));
+}
+
 static void mipi_dsi_host_config(Lcd_Config_t *pConf)
 {
-    unsigned int        dpi_data_format;
-    unsigned int        venc_data_width;
-    tv_enc_lcd_type_t   venc_format;
-    unsigned char       lane_num;
-    unsigned char       operation_mode_init, video_mode_type;
 
+    unsigned int       operation_mode_init;
     operation_mode_init  = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1);
-    video_mode_type = pConf->lcd_control.mipi_config->video_mode_type;
-    venc_format     = pConf->lcd_control.mipi_config->venc_fmt;
-    venc_data_width = pConf->lcd_control.mipi_config->venc_data_width;
-    dpi_data_format = pConf->lcd_control.mipi_config->dpi_data_format;
-    lane_num        = pConf->lcd_control.mipi_config->lane_num;
 
 #ifdef LCD_DEBUG_INFO
     print_info();
@@ -924,34 +908,21 @@ static void mipi_dsi_host_config(Lcd_Config_t *pConf)
                  MIPI_DSI_DCS_ACK_TYPE,                // if need bta ack check
                  MIPI_DSI_TEAR_SWITCH);                // enable tear ack
 
-    set_mipi_dsi_host(lane_num,                        // Lane number
-                      MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
-                      venc_data_width,                 // MIPI dsi venc data bit width
-                      dpi_data_format,                 // MIPI dsi dpi data format
+    set_mipi_dsi_host(MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
                       0,                               // Chroma sub sample, only for YUV 422 or 420, even or odd
                       operation_mode_init,             // DSI operation mode, video or command
-                      venc_format,                     // Venc resolution format, eg, 240x160
-                      video_mode_type,                 // Video mode, burst or non-burst
                       pConf);
 }
 
 void mipi_dsi_link_on(Lcd_Config_t *pConf)
 {
-    unsigned int      dpi_data_format;
-    unsigned int      venc_data_width;
-    tv_enc_lcd_type_t venc_format;
-    unsigned char     lane_num;
-    unsigned char     operation_mode_disp, video_mode_type;
+    unsigned int      operation_mode_disp, operation_mode_init;
     struct aml_lcd_extern_driver_t *lcd_extern_driver;
     unsigned int init_flag = 0;
 
     DPRINT("%s\n", __FUNCTION__);
     operation_mode_disp = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
-    video_mode_type = pConf->lcd_control.mipi_config->video_mode_type;
-    venc_format     = pConf->lcd_control.mipi_config->venc_fmt;
-    venc_data_width = pConf->lcd_control.mipi_config->venc_data_width;
-    dpi_data_format = pConf->lcd_control.mipi_config->dpi_data_format;
-    lane_num        = pConf->lcd_control.mipi_config->lane_num;
+    operation_mode_init = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1);
 
     if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
         lcd_extern_driver = aml_lcd_extern_get_driver();
@@ -976,15 +947,10 @@ void mipi_dsi_link_on(Lcd_Config_t *pConf)
         dsi_write_cmd(dsi_init_on_table_dft);
     }
 
-    if (operation_mode_disp != ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1)) {
-        set_mipi_dsi_host(lane_num,                        // Lane number
-                          MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
-                          venc_data_width,                 // MIPI dsi venc RGB data bit width
-                          dpi_data_format,                 // MIPI dsi dpi data format
+    if (operation_mode_disp != operation_mode_init) {
+        set_mipi_dsi_host(MIPI_DSI_VIRTUAL_CHAN_ID,        // Virtual channel id
                           0,                               // Chroma sub sample, only for YUV 422 or 420, even or odd
                           operation_mode_disp,             // DSI operation mode, video or command
-                          venc_format,                     // Venc resolution format, eg, 240x160
-                          video_mode_type,                 // Video mode, burst or non-burst
                           pConf);
     }
 }
@@ -1014,32 +980,54 @@ void mipi_dsi_link_off(Lcd_Config_t *pConf)
 
 void set_mipi_dsi_control_config(Lcd_Config_t *pConf)
 {
-    unsigned int bit_rate;
+    unsigned int bit_rate, lcd_bits;
+    unsigned int operation_mode;
     DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
+    int n;
 
-    if (cfg->bit_rate_max == 0) {
-        bit_rate = ((pConf->lcd_timing.lcd_clk / 1000) * 3 * 8) / cfg->lane_num;
-        cfg->bit_rate_min = bit_rate - 20*1000;
-        cfg->bit_rate_max = bit_rate - 20*1000 + (pConf->lcd_timing.lcd_clk / 1000);
-        DPRINT("mipi dsi bit_rate min=%dMHz, max=%dMHz\n", (cfg->bit_rate_min / 1000), (cfg->bit_rate_max / 1000));
-    }
-    if (cfg->bit_rate_max < (PLL_VCO_MIN / od_table[OD_SEL_MAX-1])) {
-        DPRINT("[error]: mipi-dsi can't support %dMHz bit_rate (min bit_rate=%dMHz)\n", (cfg->bit_rate_max / 1000), ((PLL_VCO_MIN / od_table[OD_SEL_MAX-1]) / 1000));
-    }
-    if (cfg->bit_rate_max > MIPI_PHY_MAX_CLK_IN) {
-        DPRINT("[warning]: mipi-dsi bit_rate_max %dMHz is out of spec (%dMHz)\n", (cfg->bit_rate_max / 1000), (MIPI_PHY_MAX_CLK_IN / 1000));
-    }
-
+    operation_mode = ((cfg->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
     cfg->video_mode_type = MIPI_DSI_VIDEO_MODE_TYPE;
     if(pConf->lcd_basic.lcd_bits == 6){
-        cfg->dpi_data_format = COLOR_18BIT_CFG_2;
         cfg->venc_data_width = MIPI_DSI_VENC_COLOR_18B;
+        cfg->dpi_data_format = MIPI_DSI_COLOR_18BIT;
+        if (cfg->dpi_data_format == COLOR_18BIT_CFG_2)
+            lcd_bits = 8;
+        else
+            lcd_bits = 6;
     }else{
-        cfg->dpi_data_format  = COLOR_24BIT;
         cfg->venc_data_width = MIPI_DSI_VENC_COLOR_24B;
+        cfg->dpi_data_format  = MIPI_DSI_COLOR_24BIT;
+        lcd_bits = 8;
+    }
+    if (cfg->bit_rate_max == 0) { //auto calculate
+        if ((operation_mode == OPERATION_VIDEO_MODE) && (cfg->video_mode_type != BURST_MODE))
+            bit_rate = ((pConf->lcd_timing.lcd_clk / 1000) * 4 * lcd_bits) / cfg->lane_num;
+        else
+            bit_rate = ((pConf->lcd_timing.lcd_clk / 1000) * 3 * lcd_bits) / cfg->lane_num;
+        cfg->bit_rate_min = 0;
+        n = 0;
+        while ((cfg->bit_rate_min < (PLL_VCO_MIN / od_table[OD_SEL_MAX-1])) && (n < 50)) {
+            cfg->bit_rate_max = bit_rate + 20000 + (n * (pConf->lcd_timing.lcd_clk / 1000));
+            cfg->bit_rate_min = cfg->bit_rate_max - (pConf->lcd_timing.lcd_clk / 1000);
+            n++;
+        }
+        if (cfg->bit_rate_max > MIPI_PHY_MAX_CLK_IN) {
+            cfg->bit_rate_max = MIPI_PHY_MAX_CLK_IN;
+            cfg->bit_rate_min = cfg->bit_rate_max - (pConf->lcd_timing.lcd_clk / 1000);
+        }
+        DPRINT("mipi dsi bit_rate max=%dMHz\n", (cfg->bit_rate_max / 1000));
+    }
+    else { //user define
+        cfg->bit_rate_min = cfg->bit_rate_max - (pConf->lcd_timing.lcd_clk / 1000);
+        if (cfg->bit_rate_max < (PLL_VCO_MIN / od_table[OD_SEL_MAX-1])) {
+            DPRINT("[error]: mipi-dsi can't support %dMHz bit_rate (min bit_rate=%dMHz)\n", (cfg->bit_rate_max / 1000), ((PLL_VCO_MIN / od_table[OD_SEL_MAX-1]) / 1000));
+        }
+        if (cfg->bit_rate_max > MIPI_PHY_MAX_CLK_IN) {
+            DPRINT("[warning]: mipi-dsi bit_rate_max %dMHz is out of spec (%dMHz)\n", (cfg->bit_rate_max / 1000), (MIPI_PHY_MAX_CLK_IN / 1000));
+        }
     }
 
-    switch ((cfg->transfer_ctrl >> BIT_TRANS_CTRL_SWITCH) & 3) {
+    switch ((cfg->transfer_ctrl >> BIT_TRANS_CTRL_SWITCH) & 3) {//Venc resolution format
         case 1: //standard
             cfg->venc_fmt=TV_ENC_LCD768x1024p;
             break;
@@ -1058,7 +1046,8 @@ void set_mipi_dsi_control_config(Lcd_Config_t *pConf)
 
 void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf)
 {
-    unsigned pclk, lanebyteclk;
+    unsigned int pclk, lanebyteclk;
+    unsigned int operation_mode;
     DSI_Config_t *cfg= pConf->lcd_control.mipi_config;
 
     pclk = pConf->lcd_timing.lcd_clk;
@@ -1075,6 +1064,13 @@ void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf)
     DBG_PRINT("d=%d, n=%d, factor=%d.%02d\n", cfg->factor_denominator, cfg->factor_numerator, (cfg->factor_denominator/cfg->factor_numerator), 
              ((cfg->factor_denominator % cfg->factor_numerator) * 100 / cfg->factor_numerator));
 
+    operation_mode = ((cfg->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
+    if (operation_mode == OPERATION_VIDEO_MODE) {
+        dsi_video_config(pConf);
+        if (cfg->video_mode_type != BURST_MODE)
+            dsi_non_burst_chunk_config(pConf);
+    }
+
     set_dsi_phy_config(&dsi_phy_config, cfg->bit_rate);
 }
 
@@ -1205,7 +1201,8 @@ static int remove_dsi_attr(void)
 void dsi_probe(Lcd_Config_t *pConf)
 {
     dsi_config = pConf->lcd_control.mipi_config;
-    pConf->lcd_control.mipi_config->bit_rate_min *= 1000;
+
+    //pConf->lcd_control.mipi_config->bit_rate_min *= 1000;
     pConf->lcd_control.mipi_config->bit_rate_max *= 1000;
 
     creat_dsi_attr();
diff --git a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h
index 972abcfb88e5..c8dc1991c36c 100755
--- a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h
+++ b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h
@@ -417,6 +417,21 @@ typedef struct DSI_Phy_s{
 }DSI_Phy_t;
 //********************************************************************************
 
+typedef struct DSI_Vid_s{
+    unsigned int hline;
+    unsigned int hsa;
+    unsigned int hbp;
+    unsigned int vsa;
+    unsigned int vbp;
+    unsigned int vfp;
+    unsigned int vact;
+
+    //for non-burst chunk overhead
+    unsigned int pixel_per_chunk;
+    unsigned int num_of_chunk;
+    unsigned int vid_null_size;
+}DSI_Vid_t;
+
 #define DSI_CMD_SIZE_MAX		2000
 
 extern void set_mipi_dsi_control_config(Lcd_Config_t *pConf);
diff --git a/drivers/amlogic/display/vout/aml_lcd.dtd b/drivers/amlogic/display/vout/aml_lcd.dtd
index 13ea0bb42f18..bacc09292f98 100755
--- a/drivers/amlogic/display/vout/aml_lcd.dtd
+++ b/drivers/amlogic/display/vout/aml_lcd.dtd
@@ -15,7 +15,7 @@
 //$$ L3 PROP_U32 2 = "dither_user_ctrl"
 //$$ L3 PROP_U32 3 = "vadj_brightness_contrast_saturation"
 
-//$$ L3 PROP_U32 2 = "gamma_en_revert"
+//$$ L3 PROP_U32 2 = "gamma_en_reverse"
 //$$ L4 PROP_U32 4 = "gamma_multi_rgb_coeff"
 //$$ L3 PROP_U32 256 = "gamma_table"
 
@@ -93,7 +93,7 @@
         dither_user_ctrl=<0 0x600>;	/**  dither_user(0=auto setting, 1=user define), dither_ctrl(user defined dither control, only valid when user_define=1) */
         vadj_brightness_contrast_saturation=<0x0 0x80 0x100>;	/** video adjust brightness, contrast, saturation */
 
-        gamma_en_revert=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_revert(0=normal, 1=revert) */
+        gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_reverse(0=normal, 1=reverse) */
         gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
         /** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
         gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
@@ -169,7 +169,7 @@
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -191,7 +191,7 @@
 
         dsi_lane_num=<4>; /** mipi dsi data lane number */
         dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-        dsi_bit_rate_min_max=<500 600>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+        dsi_bit_rate_max=<550>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
         dsi_init_on=<0x05 0x11 0 //sleep out
@@ -220,7 +220,7 @@
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -242,7 +242,7 @@
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
         dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-        dsi_bit_rate_min_max=<500 600>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+        dsi_bit_rate_min_max=<550>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
         dsi_init_on=<0x05 0x11 0 //sleep out
@@ -271,7 +271,7 @@
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
@@ -293,7 +293,7 @@
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
         dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-        dsi_bit_rate_min_max=<900 1000>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+        dsi_bit_rate_min_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<15>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
         dsi_init_on=<0x05 0x11 0 //sleep out
@@ -323,7 +323,7 @@
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 42 = "dsi_init_on"
@@ -346,7 +346,7 @@
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
         dsi_operation_mode=<0 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-        dsi_bit_rate_min_max=<400 500>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+        dsi_bit_rate_min_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
         dsi_init_on=<0x15 0x01 1 0x0 
@@ -385,7 +385,7 @@
 //$$ L2 PROP_U32 = "vsync_horizontal_phase"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 2 = "dsi_init_on"
@@ -408,7 +408,7 @@
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
         dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-        dsi_bit_rate_min_max=<400 500>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+        dsi_bit_rate_min_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
         dsi_init_on=<0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
@@ -429,7 +429,7 @@
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 5 = "dsi_init_on"
@@ -451,7 +451,7 @@
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
         dsi_operation_mode=<0 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-        dsi_bit_rate_min_max=<800 900>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+        dsi_bit_rate_min_max=<900>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 2>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
         dsi_init_on=<0x32 0x0 0  //turn on peripheral
@@ -473,7 +473,7 @@
 //$$ L2 PROP_U32 2 = "pol_hsync_vsync"
 //$$ L2 PROP_U32 = "dsi_lane_num"
 //$$ L2 PROP_U32 2 = "dsi_operation_mode"
-//$$ L2 PROP_U32 2 = "dsi_bit_rate_min_max"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 50 = "dsi_init_on"
@@ -495,7 +495,7 @@
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
         dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
-        dsi_bit_rate_min_max=<800 900>; /** range of mipi dsi data lane bit rate(unit: MHz) */
+        dsi_bit_rate_max=<900>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
         dsi_init_on=<0x05 0x01 0  //soft reset
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index e2b8ff9ec952..3ece2a8371b2 100755
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -1495,15 +1495,15 @@ static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pd
                 pConf->lcd_control.mipi_config->lane_num = (unsigned char)val;
             }
             DBG_PRINT("dsi_lane_num= %d\n",  pConf->lcd_control.mipi_config->lane_num);
-            ret = of_property_read_u32_array(lcd_model_node,"dsi_bit_rate_min_max",&lcd_para[0], 2);
+            ret = of_property_read_u32(lcd_model_node,"dsi_bit_rate_max",&val);
             if(ret){
-                printk("faild to get dsi_bit_rate_min_max\n");
-                lcd_para[0] = 0;
-                lcd_para[1] = 0;
+                printk("faild to get dsi_bit_rate_max\n");
+                pConf->lcd_control.mipi_config->bit_rate_max = 0;
             }
-            pConf->lcd_control.mipi_config->bit_rate_min = lcd_para[0];
-            pConf->lcd_control.mipi_config->bit_rate_max = lcd_para[1];
-            DBG_PRINT("dsi bit_rate min = %dMHz max = %dMHz\n", lcd_para[0], lcd_para[1]);
+            else {
+                pConf->lcd_control.mipi_config->bit_rate_max = val;
+            }
+            DBG_PRINT("dsi bit_rate max = %dMHz\n", pConf->lcd_control.mipi_config->bit_rate_max);
             ret = of_property_read_u32(lcd_model_node,"pclk_lanebyteclk_factor",&val);
             if(ret){
                 printk("faild to get pclk_lanebyteclk_factor\n");
-- 
2.19.0

