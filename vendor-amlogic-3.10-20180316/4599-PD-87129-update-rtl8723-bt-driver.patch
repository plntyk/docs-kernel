From 36537ed033de25956fb0e3bc401a1db23628df97 Mon Sep 17 00:00:00 2001
From: "jiamin.miao" <jiamin.miao@amlogic.com>
Date: Fri, 20 Jun 2014 15:33:48 +0800
Subject: [PATCH 4599/5965] PD#87129:update rtl8723 bt driver

Conflicts:

	arch/arm/configs/meson8_defconfig
---
 drivers/amlogic/bluetooth/rtk8723/rtk_btusb.c | 903 +++++++++++++++---
 drivers/amlogic/bluetooth/rtk8723/rtk_btusb.h | 159 ++-
 2 files changed, 916 insertions(+), 146 deletions(-)

diff --git a/drivers/amlogic/bluetooth/rtk8723/rtk_btusb.c b/drivers/amlogic/bluetooth/rtk8723/rtk_btusb.c
index a0e3e5ffeb77..798a083797ff 100755
--- a/drivers/amlogic/bluetooth/rtk8723/rtk_btusb.c
+++ b/drivers/amlogic/bluetooth/rtk8723/rtk_btusb.c
@@ -2,7 +2,7 @@
  *
  *  Realtek Bluetooth USB driver
  *
- *  
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
@@ -28,11 +28,12 @@
 #include <linux/errno.h>
 #include <linux/skbuff.h>
 #include <linux/usb.h>
+#include <linux/dcache.h>
 
 /*******************************/
 #include "rtk_btusb.h"
 
-#if 0
+#if 1
 #define RTKBT_DBG(fmt, arg...) printk(KERN_INFO "rtk_btusb: " fmt "\n" , ## arg)
 #else
 #define RTKBT_DBG(fmt, arg...)
@@ -52,7 +53,7 @@ static struct cdev c_dev; // Global variable for the character device structure
 static struct class *cl; // Global variable for the device class
 
 /* HCI device list */
-DEFINE_RWLOCK(hci_dev_list_lock1);
+static DEFINE_RWLOCK(hci_dev_list_lock);
 struct hci_dev *Ghdev = NULL;
 
 static struct file_operations btfcd_file_ops_g =
@@ -63,10 +64,15 @@ static struct file_operations btfcd_file_ops_g =
     write   : btfcd_write,
     poll    : btfcd_poll
 };
-#endif 
+#endif
 /*******************************/
 
-#define VERSION "0.9"
+#define VERSION "2.11"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 1)
+static bool reset = 0;
+#endif
+
 static struct usb_driver btusb_driver;
 static struct usb_device_id btusb_table[] = {
 	{ .match_flags = USB_DEVICE_ID_MATCH_VENDOR |
@@ -78,6 +84,24 @@ static struct usb_device_id btusb_table[] = {
 	{ }
 };
 
+static void rtk_free( struct btusb_data *data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 1)
+	kfree(data);
+#endif
+	return;
+}
+
+static struct btusb_data * rtk_alloc(struct usb_interface *intf)
+{
+	struct btusb_data *data;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 1)
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+#else
+	data = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);
+#endif
+	return data;
+}
 MODULE_DEVICE_TABLE(usb, btusb_table);
 
 static int inc_tx(struct btusb_data *data)
@@ -99,27 +123,19 @@ static void btusb_intr_complete(struct urb *urb)
 	struct hci_dev *hdev = urb->context;
 	struct btusb_data *data = GET_DRV_DATA(hdev);
 	int err;
-    
-	/*
-	struct usb_device    *dev ;
-	u8* opcode = (u8*)(urb->transfer_buffer);
-	uint wlength = urb->actual_length;
-	uint icount=0;
-		
-	RTKBT_DBG("btusb_intr_complete %s urb %p status %d count %d ", hdev->name,
-					urb, urb->status, urb->actual_length);
+//	struct usb_device    *dev ;
+//	RTKBT_DBG("btusb_intr_complete %s urb %p status %d count %d ", hdev->name,
+//					urb, urb->status, urb->actual_length);
+//	print_event(urb);
 
-	for(icount=0;icount <wlength;icount++)
-	{
-		RTKBT_DBG("0x%x ",*(opcode+icount) );
-	}
-*/	
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return;
-	
-	/*add to avoid suspend fail at usb_kill_urb*/
-	if(test_bit(BTUSB_SUSPENDING, &data->flags))
-	        return;
+
+	/*******************************/
+	// Added by Realtek
+	if(!test_bit(BTUSB_NEXT_RX_URB_SUBMITTING, &data->flags))
+		return;
+	/*******************************/
 
 	if (urb->status == 0) {
 		hdev->stat.byte_rx += urb->actual_length;
@@ -213,6 +229,12 @@ static void btusb_bulk_complete(struct urb *urb)
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return;
 
+	/*******************************/
+	// Added by Realtek
+	if(!test_bit(BTUSB_NEXT_RX_URB_SUBMITTING, &data->flags))
+		return;
+	/*******************************/
+
 	if (urb->status == 0) {
 		hdev->stat.byte_rx += urb->actual_length;
 
@@ -227,10 +249,6 @@ static void btusb_bulk_complete(struct urb *urb)
 	if (!test_bit(BTUSB_BULK_RUNNING, &data->flags))
 		return;
 
-	/*add to avoid suspend fail at usb_kill_urb*/
-	if(test_bit(BTUSB_SUSPENDING, &data->flags))
-	        return;
-	
 	usb_anchor_urb(urb, &data->bulk_anchor);
 	usb_mark_last_busy(data->udev);
 
@@ -475,7 +493,7 @@ static int btusb_open(struct hci_dev *hdev)
 	if (err < 0)
 		return err;
 
-	data->intf->needs_remote_wakeup = 1;	
+	data->intf->needs_remote_wakeup = 1;
 	RTKBT_DBG("%s start pm_usage_cnt(0x%x)",__FUNCTION__,atomic_read(&(data->intf ->pm_usage_cnt)));
 
 	/*******************************/
@@ -485,10 +503,15 @@ static int btusb_open(struct hci_dev *hdev)
 		err = -1;
                 //goto failed;
 	}
-	err = download_patch(data->intf);	
+	err = download_patch(data->intf);
 	if (err < 0) goto failed;
 	/*******************************/
 
+	/*******************************/
+	// Added by Realtek
+	set_bit(BTUSB_NEXT_RX_URB_SUBMITTING, &data->flags);
+	/*******************************/
+
 	if (test_and_set_bit(HCI_RUNNING, &hdev->flags))
 		goto done;
 
@@ -542,8 +565,8 @@ static int btusb_close(struct hci_dev *hdev)
 	RTKBT_DBG("btusb_close");
 	/*******************************/
 	for (i = 0; i < NUM_REASSEMBLY; i++)
-	{	
-		if(hdev->reassembly[i])		
+	{
+		if(hdev->reassembly[i])
 		{
 			kfree_skb(hdev->reassembly[i]);
 			hdev->reassembly[i] = NULL;
@@ -554,6 +577,11 @@ static int btusb_close(struct hci_dev *hdev)
 	cancel_work_sync(&data->work);
 	cancel_work_sync(&data->waker);
 
+	/*******************************/
+	// Added by Realtek
+	clear_bit(BTUSB_NEXT_RX_URB_SUBMITTING, &data->flags);
+	/*******************************/
+
 	clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
 	clear_bit(BTUSB_BULK_RUNNING, &data->flags);
 	clear_bit(BTUSB_INTR_RUNNING, &data->flags);
@@ -562,7 +590,7 @@ static int btusb_close(struct hci_dev *hdev)
 	err = usb_autopm_get_interface(data->intf);
 	if (err < 0)
 		goto failed;
-	
+
 	data->intf->needs_remote_wakeup = 0;
 	usb_autopm_put_interface(data->intf);
 
@@ -576,42 +604,41 @@ static int btusb_flush(struct hci_dev *hdev)
 {
 	struct btusb_data *data = GET_DRV_DATA(hdev);
 
-	RTKBT_DBG("%s add delay ",__FUNCTION__);	
+	RTKBT_DBG("%s add delay ",__FUNCTION__);
 	mdelay(URB_CANCELING_DELAY_MS);     // Added by Realtek
 	usb_kill_anchored_urbs(&data->tx_anchor);
 
 	return 0;
 }
 
+#if LINUX_VERSION_CODE >=KERNEL_VERSION(3, 13, 0)
+static int btusb_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
+{
+#else
 static int btusb_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+#endif
+
 	struct btusb_data *data = GET_DRV_DATA(hdev);
 	struct usb_ctrlrequest *dr;
 	struct urb *urb;
 	unsigned int pipe;
 	int err;
 
-/*	u16* opcode = (u16*)(skb->data);
-	uint wlength = skb->len;
-	uint icount=0;		
-	
-	 RTKBT_DBG("==========%s opcode=0x%x,wlength = %d",__FUNCTION__,*opcode,wlength );
-		RTKBT_DBG("==========wlength=%d \n",wlength);
-		for(icount=0;icount <wlength;icount++)
-		{
-		RTKBT_DBG("0x%x ",*(opcode+icount) );
-		}
-	RTKBT_DBG("\n==========");
-*/
-
 //	RTKBT_DBG("%s", hdev->name);
 
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
 		return -EBUSY;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+#else
+skb->dev = (void *) hdev;
+#endif
+
 	switch (bt_cb(skb)->pkt_type) {
 	case HCI_COMMAND_PKT:
+		print_command(skb);
 		urb = usb_alloc_urb(0, GFP_ATOMIC);
 		if (!urb)
 			return -ENOMEM;
@@ -637,6 +664,7 @@ static int btusb_send_frame(struct sk_buff *skb)
 		break;
 
 	case HCI_ACLDATA_PKT:
+		print_acl(skb,1);
 		if (!data->bulk_tx_ep)
 			return -ENODEV;
 
@@ -654,7 +682,7 @@ static int btusb_send_frame(struct sk_buff *skb)
 		break;
 
 	case HCI_SCODATA_PKT:
-		if (!data->isoc_tx_ep || hdev->conn_hash.sco_num < 1)
+		if (!data->isoc_tx_ep ||SCO_NUM< 1)
 			return -ENODEV;
 
 		urb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, GFP_ATOMIC);
@@ -722,8 +750,8 @@ static void btusb_notify(struct hci_dev *hdev, unsigned int evt)
 	RTKBT_DBG("%s evt %d", hdev->name, evt);
 	RTKBT_DBG("btusb_notify : %s evt %d", hdev->name, evt);
 
-	if (hdev->conn_hash.sco_num != data->sco_num) {
-		data->sco_num = hdev->conn_hash.sco_num;
+	if (SCO_NUM != data->sco_num) {
+		data->sco_num = SCO_NUM;
 		schedule_work(&data->work);
 	}
 }
@@ -776,8 +804,8 @@ static void btusb_work(struct work_struct *work)
 	struct btusb_data *data = container_of(work, struct btusb_data, work);
 	struct hci_dev *hdev = data->hdev;
 	int err;
-
-	if (hdev->conn_hash.sco_num > 0) {
+	int new_alts;
+	if (data->sco_num > 0) {
 		if (!test_bit(BTUSB_DID_ISO_RESUME, &data->flags)) {
 			err = usb_autopm_get_interface(data->isoc ? data->isoc : data->intf);
 			if (err < 0) {
@@ -789,12 +817,24 @@ static void btusb_work(struct work_struct *work)
 
 			set_bit(BTUSB_DID_ISO_RESUME, &data->flags);
 		}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 1)
+		if (hdev->voice_setting & 0x0020) {
+			static const int alts[3] = { 2, 4, 5 };
+			new_alts = alts[data->sco_num - 1];
+		} else {
+			new_alts = data->sco_num;
+		}
+		if (data->isoc_altsetting != new_alts) {
+#else
 		if (data->isoc_altsetting != 2) {
+			new_alts = 2;
+#endif
+
 			clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
 			mdelay(URB_CANCELING_DELAY_MS);    // Added by Realtek
 			usb_kill_anchored_urbs(&data->isoc_anchor);
 
-			if (__set_isoc_interface(hdev, 2) < 0)
+			if (__set_isoc_interface(hdev, new_alts) < 0)
 				return;
 		}
 
@@ -836,9 +876,12 @@ static int btusb_probe(struct usb_interface *intf,
 	struct btusb_data *data;
 	struct hci_dev *hdev;
 	int i, err,flag1,flag2;
-	struct usb_device *udev;	
+	struct usb_device *udev;
 	udev = interface_to_usbdev(intf);
 
+
+	RTKBT_DBG("btusb_probe intf->cur_altsetting->desc.bInterfaceNumber=%d",intf->cur_altsetting->desc.bInterfaceNumber);
+
 	/* interface numbers are hardcoded in the spec */
 	if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
 		return -ENODEV;
@@ -846,21 +889,21 @@ static int btusb_probe(struct usb_interface *intf,
 	/*******************************/
 	flag1=device_can_wakeup(&udev->dev);
 	flag2=device_may_wakeup(&udev->dev);
-	RTKBT_DBG("btusb_probe 1==========can_wakeup=%x	 flag2=%x",flag1,flag2);
+	RTKBT_DBG("btusb_probe can_wakeup=%x	 flag2=%x",flag1,flag2);
 	//device_wakeup_enable(&udev->dev);
 	/*device_wakeup_disable(&udev->dev);
 	flag1=device_can_wakeup(&udev->dev);
 	flag2=device_may_wakeup(&udev->dev);
-	RTKBT_DBG("btusb_probe 2==========can_wakeup=%x	 flag2=%x",flag1,flag2);
+	RTKBT_DBG("btusb_probe can_wakeup=%x	 flag2=%x",flag1,flag2);
 	*/
-	err = patch_add(intf);	
+	err = patch_add(intf);
 	if (err < 0) return -1;
 	/*******************************/
 
-	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	data = rtk_alloc(intf);
 	if (!data)
 		return -ENOMEM;
-	
+
 
 	for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {
 		ep_desc = &intf->cur_altsetting->endpoint[i].desc;
@@ -882,7 +925,7 @@ static int btusb_probe(struct usb_interface *intf,
 	}
 
 	if (!data->intr_ep || !data->bulk_tx_ep || !data->bulk_rx_ep) {
-		kfree(data);
+		rtk_free(data);
 		return -ENODEV;
 	}
 
@@ -905,7 +948,7 @@ static int btusb_probe(struct usb_interface *intf,
 
 	hdev = hci_alloc_dev();
 	if (!hdev) {
-		kfree(data);
+		rtk_free(data);
 		return -ENOMEM;
 	}
 
@@ -921,8 +964,8 @@ static int btusb_probe(struct usb_interface *intf,
 	hdev->send     = btusb_send_frame;
 	hdev->notify   = btusb_notify;
 
-	
-#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 4, 0)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
 	hci_set_drvdata(hdev, data);
 #else
 	hdev->driver_data = data;
@@ -930,7 +973,11 @@ static int btusb_probe(struct usb_interface *intf,
 	hdev->owner = THIS_MODULE;
 #endif
 
-	
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 1)
+	if (!reset)
+		set_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);
+	RTKBT_DBG("set_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);");
+#endif
 
 	/* Interface numbers are hardcoded in the specification */
 	data->isoc = usb_ifnum_to_if(data->udev, 1);
@@ -940,7 +987,7 @@ static int btusb_probe(struct usb_interface *intf,
 							data->isoc, data);
 		if (err < 0) {
 			hci_free_dev(hdev);
-			kfree(data);
+			rtk_free(data);
 			return err;
 		}
 	}
@@ -948,7 +995,7 @@ static int btusb_probe(struct usb_interface *intf,
 	err = hci_register_dev(hdev);
 	if (err < 0) {
 		hci_free_dev(hdev);
-		kfree(data);
+		rtk_free(data);
 		return err;
 	}
 
@@ -972,8 +1019,8 @@ static void btusb_disconnect(struct usb_interface *intf)
 
 	if (!data)
 		return;
-	
-	RTKBT_DBG("btusb_disconnect");	
+
+	RTKBT_DBG("btusb_disconnect");
 	/*******************************/
 	patch_remove(intf);
 	/*******************************/
@@ -1005,7 +1052,7 @@ static void btusb_disconnect(struct usb_interface *intf)
 #endif
 
 	hci_free_dev(hdev);
-	kfree(data);
+	rtk_free(data);
 
 #if CONFIG_BLUEDROID //for 4.2
 	btfcd_exit();
@@ -1024,15 +1071,15 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 	/*******************************/
 	RTKBT_DBG("btusb_suspend message.event=0x%x,data->suspend_count=%d",message.event,data->suspend_count);
 	if (!test_bit(HCI_RUNNING, &data->hdev->flags))
-	{	
-		RTKBT_DBG("btusb_suspend-----bt is off");	
+	{
+		RTKBT_DBG("btusb_suspend-----bt is off");
 		set_btoff(data->intf);
 	}
 	/*******************************/
-	
+
 	if (data->suspend_count++)
 		return 0;
-	
+
 	spin_lock_irq(&data->txlock);
 	if (!((message.event & PM_EVENT_AUTO) && data->tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &data->flags);
@@ -1045,6 +1092,11 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 
 	cancel_work_sync(&data->work);
 
+	/*******************************/
+	// Added by Realtek
+	clear_bit(BTUSB_NEXT_RX_URB_SUBMITTING, &data->flags);
+	/*******************************/
+
 	btusb_stop_traffic(data);
 	mdelay(URB_CANCELING_DELAY_MS);      // Added by Realtek
 	usb_kill_anchored_urbs(&data->tx_anchor);
@@ -1058,7 +1110,7 @@ static void play_deferred(struct btusb_data *data)
 	int err;
 
 	while ((urb = usb_get_from_anchor(&data->deferred))) {
-	
+
 	       /************************************/
 		usb_anchor_urb(urb, &data->tx_anchor);
 		err = usb_submit_urb(urb, GFP_ATOMIC);
@@ -1086,21 +1138,25 @@ static int btusb_resume(struct usb_interface *intf)
 	if (intf->cur_altsetting->desc.bInterfaceNumber != 0)
 		return 0;
 
-        
 	/*******************************/
 	RTKBT_DBG("btusb_resume data->suspend_count=%d",data->suspend_count);
 
 	if (!test_bit(HCI_RUNNING, &hdev->flags))
-	{	
+	{
 		RTKBT_DBG("btusb_resume-----bt is off,download patch");
-		download_patch(intf);                
+		download_patch(intf);
 	}
 	else
-	        RTKBT_DBG("btusb_resume,----bt is on");                
+	        RTKBT_DBG("btusb_resume,----bt is on");
 	/*******************************/
 	if (--data->suspend_count)
 		return 0;
-	
+
+	/*******************************/
+	// Added by Realtek
+	set_bit(BTUSB_NEXT_RX_URB_SUBMITTING, &data->flags);
+	/*******************************/
+
 	if (test_bit(BTUSB_INTR_RUNNING, &data->flags)) {
 		err = btusb_submit_intr_urb(hdev, GFP_NOIO);
 		if (err < 0) {
@@ -1156,9 +1212,12 @@ static struct usb_driver btusb_driver = {
 #endif
 #if  CONFIG_RESET_RESUME
 	.reset_resume = btusb_resume,
-#endif 
+#endif
 	.id_table	= btusb_table,
 	.supports_autosuspend = 1,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 1)
+	.disable_hub_initiated_lpm = 1,
+#endif
 };
 
 static int __init btusb_init(void)
@@ -1188,7 +1247,7 @@ MODULE_LICENSE("GPL");
 ********************************/
 #define CMD_CMP_EVT		0x0e
 #define PKT_LEN			300
-#define MSG_TO			1000
+#define MSG_TO			1000    //us
 #define PATCH_SEG_MAX	252
 #define DATA_END		0x80
 #define DOWNLOAD_OPCODE	0xfc20
@@ -1210,6 +1269,7 @@ enum rtk_endpoit {
 typedef struct {
 	uint16_t	prod_id;
 	uint16_t	lmp_sub;
+        char          *mp_patch_name;
 	char		*patch_name;
 	char		*config_name;
 	uint8_t		*fw_cache;
@@ -1247,6 +1307,20 @@ typedef struct {
 	uint8_t index;
 } __attribute__((packed)) download_rp;
 
+#define RTK_VENDOR_CONFIG_MAGIC 0x8723ab55
+struct rtk_bt_vendor_config_entry{
+    uint16_t offset;
+    uint8_t entry_len;
+    uint8_t entry_data[0];
+} __attribute__ ((packed));
+
+
+struct rtk_bt_vendor_config{
+    uint32_t signature;
+    uint16_t data_len;
+    struct rtk_bt_vendor_config_entry entry[0];
+} __attribute__ ((packed));
+
 
 static dev_data* dev_data_find(struct usb_interface* intf);
 static patch_info* get_patch_entry(struct usb_device* udev);
@@ -1258,15 +1332,50 @@ static int get_firmware(xchange_data* xdata);
 static int download_data(xchange_data* xdata);
 static int send_hci_cmd(xchange_data* xdata);
 static int rcv_hci_evt(xchange_data* xdata);
+static uint8_t rtk_get_eversion(dev_data * dev_entry);
+
+static uint8_t gEVersion = 0xFF;
 
 
 static patch_info patch_table[] = {
-	{ 0, 0x1200, "rtk8723a", "rtk8723_bt_config", NULL, 0 }
+//{pid, lmp ,fw_name,config_name,fw_cache,fw_len}
+    { 0x1724, 0x1200,  "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0 }, //Rtl8723A
+    { 0x8723, 0x1200, "mp_rtl8723a_fw",      "rtl8723a_fw", "rtl8723a_config", NULL, 0 }, //8723AE
+    { 0xA723, 0x1200, "mp_rtl8723a_fw",      "rtl8723a_fw", "rtl8723a_config", NULL, 0 }, //8723AE for LI
+    { 0x0723, 0x1200, "mp_rtl8723a_fw",      "rtl8723a_fw", "rtl8723a_config", NULL, 0 }, //8723AE
+
+    { 0x0724, 0x1200, "mp_rtl8723a_fw",      "rtl8723a_fw", "rtl8723a_config", NULL, 0 }, //8723AU
+    { 0x8725, 0x1200, "mp_rtl8723a_fw",      "rtl8723a_fw", "rtl8723a_config", NULL, 0 }, //8723AU
+    { 0x872A, 0x1200, "mp_rtl8723a_fw",      "rtl8723a_fw", "rtl8723a_config", NULL, 0 }, //8723AU
+    { 0x872B, 0x1200, "mp_rtl8723a_fw",      "rtl8723a_fw", "rtl8723a_config", NULL, 0 }, //8723AU
+
+    { 0xA761, 0x8761, "mp_rtl8761a_fw",     "rtl8761au_fw",              "rtl8761a_config", NULL, 0 }, //Rtl8761AU only
+    { 0x818B, 0x8761, "mp_rtl8761a_fw",     "rtl8761aw8192eu_fw", "rtl8761a_config", NULL, 0 }, //Rtl8761Aw + 8192EU
+    { 0x818C, 0x8761, "mp_rtl8761a_fw",     "rtl8761aw8192eu_fw", "rtl8761a_config", NULL, 0 }, //Rtl8761Aw + 8192EU
+    { 0x8760, 0x8761, "mp_rtl8761a_fw",     "rtl8761au8192ee_fw", "rtl8761a_config", NULL, 0 }, //Rtl8761AU + 8192EE
+    { 0xB761, 0x8761, "mp_rtl8761a_fw",     "rtl8761au8192ee_fw", "rtl8761a_config", NULL, 0 }, //Rtl8761AU + 8192EE
+    { 0x8761, 0x8761, "mp_rtl8761a_fw",     "rtl8761au8192ee_fw", "rtl8761a_config", NULL, 0 }, //Rtl8761AU + 8192EE for LI
+    { 0x8A60, 0x8761, "mp_rtl8761a_fw",      "rtl8761au8812ae_fw", "rtl8761a_config", NULL, 0 }, //Rtl8761AU + 8812AE
+
+    { 0x8821, 0x8821, "mp_rtl8821a_fw",      "rtl8821a_fw",     "rtl8821a_config", NULL, 0 },  //Rtl8821AE
+    { 0x0821, 0x8821, "mp_rtl8821a_fw",      "rtl8821a_fw",     "rtl8821a_config", NULL, 0 },  //Rtl8821AE
+    { 0x0823, 0x8821, "mp_rtl8821a_fw",      "rtl8821a_fw",     "rtl8821a_config", NULL, 0 },  //Rtl8821AU
+
+    { 0xb720, 0x8723, "mp_rtl8723b_fw",       "rtl8723b_fw", "rtl8723bu_config", NULL, 0 },  //Rtl8723BU
+    { 0xb72A, 0x8723,  "mp_rtl8723b_fw",      "rtl8723b_fw", "rtl8723bu_config", NULL, 0 },  //Rtl8723BU
+    { 0xb728, 0x8723,  "mp_rtl8723b_fw",      "rtl8723b_fw", "rtl8723b_config", NULL, 0 },  //Rtl8723BE for LC
+    { 0xb723, 0x8723,  "mp_rtl8723b_fw",      "rtl8723b_fw", "rtl8723b_config", NULL, 0 },  //Rtl8723BE
+    { 0xb72B, 0x8723,  "mp_rtl8723b_fw",      "rtl8723b_fw", "rtl8723b_config", NULL, 0 }, //Rtl8723BE
+    { 0xb002, 0x8723,  "mp_rtl8723b_fw",      "rtl8723b_fw", "rtl8723b_config", NULL, 0 }, //Rtl8723BE
+    { 0xb001, 0x8723, "mp_rtl8723b_fw",       "rtl8723b_fw", "rtl8723b_config", NULL, 0 },  //Rtl8723BE for hp
+
+    { 0, 0, NULL,NULL, NULL, 0 }
+
+  //  { 0, 0x1200, "rtl8723a_fw", "rtl8723a_config", NULL, 0 } //Rtl8723AU & Rtl8723AE by default
 };
 
 static LIST_HEAD(dev_data_list);
 
-
 int patch_add(struct usb_interface* intf)
 {
 	dev_data	*dev_entry;
@@ -1280,9 +1389,9 @@ int patch_add(struct usb_interface* intf)
 	}
 
 	udev = interface_to_usbdev(intf);
-#if BTUSB_RPM	
-	RTKBT_DBG("auto suspend is enabled");  
-	usb_enable_autosuspend(udev);	
+#if BTUSB_RPM
+	RTKBT_DBG("auto suspend is enabled");
+	usb_enable_autosuspend(udev);
 	pm_runtime_set_autosuspend_delay(&(udev->dev),2000);
 #endif
 
@@ -1291,6 +1400,11 @@ int patch_add(struct usb_interface* intf)
 	dev_entry->udev = udev;
 	dev_entry->pm_notifier.notifier_call = rtkbt_pm_notify;
 	dev_entry->patch_entry = get_patch_entry(udev);
+	if(NULL == dev_entry->patch_entry)
+	{
+		kfree(dev_entry);
+		return -1;
+	}
 	list_add(&dev_entry->list_node, &dev_data_list);
 	register_pm_notifier(&dev_entry->pm_notifier);
 
@@ -1304,7 +1418,7 @@ void patch_remove(struct usb_interface* intf)
 
 	udev = interface_to_usbdev(intf);
 #if BTUSB_RPM
-	usb_disable_autosuspend(udev);	
+	usb_disable_autosuspend(udev);
 #endif
 
 	dev_entry = dev_data_find(intf);
@@ -1312,7 +1426,7 @@ void patch_remove(struct usb_interface* intf)
 	{
 		return;
 	}
-	
+
 	RTKBT_DBG("patch_remove");
 	list_del(&dev_entry->list_node);
 	unregister_pm_notifier(&dev_entry->pm_notifier);
@@ -1334,19 +1448,23 @@ int download_patch(struct usb_interface* intf)
 		RTKBT_ERR("NULL == dev_entry");
 		goto patch_end;
 	}
-	
+
         xdata = kzalloc(sizeof(xchange_data), GFP_KERNEL);
 	if(NULL == xdata)
 	{
 		ret_val = -1;
 		RTKBT_DBG("NULL == xdata");
-		goto patch_end;	
+		goto patch_end;
 	}
-		
+
 	init_xdata(xdata, dev_entry);
 	ret_val = check_fw_version(xdata);
 	if (ret_val != 0)
 	{
+		if(gEVersion == 0xFF) {
+			RTKBT_DBG("global_version is not set, get it!");
+			gEVersion=rtk_get_eversion(dev_entry);
+		}
 		goto patch_end;
 	}
 
@@ -1380,7 +1498,7 @@ patch_end:
 	{
                 if(xdata->send_pkt)
 			kfree(xdata->send_pkt);
-		if(xdata->rcv_pkt)	
+		if(xdata->rcv_pkt)
 			kfree(xdata->rcv_pkt);
         	kfree(xdata);
 	}
@@ -1408,7 +1526,7 @@ int set_btoff(struct usb_interface* intf)
 		RTKBT_DBG("NULL == xdata");
               return ret_val;
        }
-	
+
 	init_xdata(xdata, dev_entry);
 
 
@@ -1416,7 +1534,7 @@ int set_btoff(struct usb_interface* intf)
 	xdata->cmd_hdr->plen = 1;
 	xdata->pkt_len = CMD_HDR_LEN + 1;
 	xdata->send_pkt[CMD_HDR_LEN] = 1;
-	
+
 	ret_val = send_hci_cmd(xdata);
 	if (ret_val < 0)
 	{
@@ -1434,7 +1552,7 @@ tagEnd:
 	{
                 if(xdata->send_pkt)
 			kfree(xdata->send_pkt);
-		if(xdata->rcv_pkt)	
+		if(xdata->rcv_pkt)
 			kfree(xdata->rcv_pkt);
         	kfree(xdata);
 	}
@@ -1467,9 +1585,14 @@ patch_info* get_patch_entry(struct usb_device* udev)
 
 	patch_entry = patch_table;
 	pid = le16_to_cpu(udev->descriptor.idProduct);
+	RTKBT_DBG("pid = 0x%x", pid);
 	while (pid != patch_entry->prod_id)
 	{
-		if (0 == patch_entry->prod_id) break;
+		if (0 == patch_entry->prod_id)
+		{
+			RTKBT_DBG("get_patch_entry =NULL, can not find device pid in patch_table");
+			return NULL;	//break;
+		}
 		patch_entry++;
 	}
 
@@ -1499,10 +1622,10 @@ int rtkbt_pm_notify(
 				RTKBT_DBG("rtkbt_pm_notify return NOTIFY_BAD");
 				return NOTIFY_BAD;
 			}
-	
+
 			if (!device_may_wakeup(&udev->dev))
 			{
-				#ifdef CONFIG_RESET_RESUME
+				#if (CONFIG_RESET_RESUME || CONFIG_BLUEDROID)
 					RTKBT_DBG("remote wakeup not support, reset_resume support ");
 				#else
 					dev_entry->intf->needs_binding = 1;
@@ -1534,6 +1657,55 @@ int rtkbt_pm_notify(
 	return NOTIFY_DONE;
 }
 
+int rtk_parse_config_file(unsigned char* config_buf, int* filelen, char bt_addr[6])
+{
+    struct rtk_bt_vendor_config* config = (struct rtk_bt_vendor_config*)config_buf;
+    uint16_t config_len = config->data_len, temp = 0;
+    struct rtk_bt_vendor_config_entry* entry = config->entry;
+    unsigned int i = 0;
+    //uint32_t baudrate = 0;
+    uint32_t config_has_bdaddr = 0;
+
+   if(config==NULL)
+	return 0;
+    if (config->signature != RTK_VENDOR_CONFIG_MAGIC)
+    {
+        RTKBT_ERR("config signature magic number(%x) is not set to RTK_VENDOR_CONFIG_MAGIC", config->signature);
+        return 0;
+    }
+
+    if (config_len != *filelen - sizeof(struct rtk_bt_vendor_config))
+    {
+        RTKBT_ERR("config len(%x) is not right(%x)", config_len, *filelen-sizeof(struct rtk_bt_vendor_config));
+        return 0;
+    }
+
+    for (i=0; i<config_len;)
+    {
+
+        switch(entry->offset)
+        {
+            int j = 0;
+            case 0x3c:
+            {
+                config_has_bdaddr = 1;
+                for (j=0; j<entry->entry_len; j++)
+                    entry->entry_data[j] = bt_addr[entry->entry_len - 1- j];
+                RTKBT_DBG("rtk_parse_config_file: config has bdaddr");
+                break;
+            }
+
+            default:
+                RTKBT_DBG("config offset(%x),length(%x)", entry->offset, entry->entry_len);
+                break;
+        }
+        temp = entry->entry_len + sizeof(struct rtk_bt_vendor_config_entry);
+        i += temp;
+        entry = (struct rtk_bt_vendor_config_entry*)((uint8_t*)entry + temp);
+    }
+
+    return 1;
+}
 int load_firmware(dev_data* dev_entry, uint8_t** buff)
 {
 	const struct firmware	*fw;
@@ -1542,39 +1714,195 @@ int load_firmware(dev_data* dev_entry, uint8_t** buff)
 	char		*fw_name;
 	int			fw_len = 0, ret_val;
 
-	RTKBT_DBG("load_firmware");
+	int config_len = 0 ,buf_len =-1;
+	uint8_t* buf = *buff, *config_file_buf = NULL;
+   	uint8_t* epatch_buf = NULL;
+
+	struct rtk_epatch* epatch_info = NULL;
+        uint8_t need_download_fw = 1;
+	struct rtk_extension_entry patch_lmp = {0};
+	struct rtk_epatch_entry current_entry = {0};
+	uint16_t lmp_version ;
+	// read bt mac address from file to  vnd_local_bd_addr
+        uint8_t vnd_local_bd_addr[6]={0x01,0x02,0x03,0x04,0x05,0x06};
+
+	RTKBT_DBG("load_firmware start");
 	udev = dev_entry->udev;
 	patch_entry = dev_entry->patch_entry;
-	fw_name = patch_entry->patch_name;
+	lmp_version = patch_entry->lmp_sub;
+
+
+	RTKBT_ERR("lmp_version = 0x%04x", lmp_version);
+
+	fw_name = patch_entry->config_name;
 	ret_val = request_firmware(&fw, fw_name, &udev->dev);
-	if (ret_val < 0) goto fw_fail;
-	
-	*buff = kzalloc(fw->size, GFP_KERNEL);
-	if (NULL == *buff) goto alloc_fail;
-	memcpy(*buff, fw->data, fw->size);
-	fw_len = fw->size;
-
-#if LOAD_CONFIG
+	if (ret_val < 0)
+		config_len = 0;
+	else
+	{
+		config_file_buf = kzalloc(fw->size, GFP_KERNEL);
+		if (NULL == config_file_buf) goto alloc_fail;
+			memcpy(config_file_buf, fw->data, fw->size);
+		config_len = fw->size;
+                rtk_parse_config_file(config_file_buf, &config_len, vnd_local_bd_addr);
+
+	}
+
 	release_firmware(fw);
-	fw_name = patch_entry->config_name;
+	fw_name = patch_entry->patch_name;
 	ret_val = request_firmware(&fw, fw_name, &udev->dev);
 	if (ret_val < 0)
 	{
 		fw_len = 0;
-		kfree(*buff);
-		*buff = NULL;
+		kfree(config_file_buf);
+		config_file_buf= NULL;
 		goto fw_fail;
 	}
+	epatch_buf = kzalloc(fw->size, GFP_KERNEL);
+	if (NULL == epatch_buf) goto alloc_fail;
+	memcpy(epatch_buf, fw->data, fw->size);
+	buf_len = fw->size + config_len;
 
-	*buff = krealloc(*buff, fw_len + fw->size, GFP_KERNEL);
-	if (NULL == *buff)
+	if(lmp_version == ROM_LMP_8723a)
 	{
-		fw_len = 0;
-		goto alloc_fail;
+		RTKBT_ERR("This is 8723a, use old patch style!");
+		if(memcmp(epatch_buf, RTK_EPATCH_SIGNATURE, 8) == 0)
+		{
+			RTKBT_ERR("8723as Check signature error!");
+			need_download_fw = 0;
+	}
+		else
+		{
+			if (!(buf = kzalloc(buf_len, GFP_KERNEL))) {
+				RTKBT_ERR("Can't alloc memory for fw&config");
+				buf_len = -1;
+			}
+			else
+			{
+				RTKBT_DBG("8723as, fw copy direct");
+				memcpy(buf,epatch_buf,buf_len);
+				kfree(epatch_buf);
+				epatch_buf = NULL;
+				if (config_len)
+				{
+					memcpy(&buf[buf_len - config_len], config_file_buf, config_len);
+				}
+			}
+		}
 	}
-	memcpy(*buff + fw_len, fw->data, fw->size);
-	fw_len += fw->size;
-#endif
+
+	else
+	{
+		RTKBT_ERR("This is not 8723a, use new patch style!");
+		//Get version from ROM
+		gEVersion = rtk_get_eversion(dev_entry);  //gEVersion is set.
+		RTKBT_DBG("gEVersion=%d", gEVersion);
+		if(gEVersion == 0xFE) {
+			RTKBT_DBG("gEVersion=%d", gEVersion);
+			need_download_fw = 0;
+			fw_len = 0;
+			goto alloc_fail;
+		}
+
+		//check Extension Section Field
+		if(memcmp(epatch_buf + buf_len-config_len-4 ,Extension_Section_SIGNATURE,4) != 0)
+		{
+			RTKBT_ERR("Check Extension_Section_SIGNATURE error! do not download fw");
+			need_download_fw = 0;
+		}
+		else
+		{
+			uint8_t *temp;
+			temp = epatch_buf+buf_len-config_len-5;
+			do{
+				if(*temp == 0x00)
+				{
+					patch_lmp.opcode = *temp;
+					patch_lmp.length = *(temp-1);
+					if ((patch_lmp.data = kzalloc(patch_lmp.length, GFP_KERNEL)))
+					{
+						memcpy(patch_lmp.data,temp-2,patch_lmp.length);
+					}
+					RTKBT_DBG("opcode = 0x%x",patch_lmp.opcode);
+					RTKBT_DBG("length = 0x%x",patch_lmp.length);
+					RTKBT_DBG("data = 0x%x",*(patch_lmp.data));
+					break;
+				}
+				temp -= *(temp-1)+2;
+			}while(*temp != 0xFF);
+
+			if(lmp_version != project_id[*(patch_lmp.data)])
+			{
+				RTKBT_ERR("lmp_version is %x, project_id is %x, does not match!!!",lmp_version,project_id[*(patch_lmp.data)]);
+				need_download_fw = 0;
+			}
+			else
+			{
+				RTKBT_DBG("lmp_version is %x, project_id is %x, match!",lmp_version, project_id[*(patch_lmp.data)]);
+
+				if(memcmp(epatch_buf, RTK_EPATCH_SIGNATURE, 8) != 0)
+				{
+					RTKBT_DBG("Check signature error!");
+					need_download_fw = 0;
+				}
+				else
+				{
+					int i = 0;
+					epatch_info = (struct rtk_epatch*)epatch_buf;
+					RTKBT_DBG("fm_version = 0x%x",epatch_info->fm_version);
+					RTKBT_DBG("number_of_total_patch = %d",epatch_info->number_of_total_patch);
+
+					//get right epatch entry
+					for(i=0; i<epatch_info->number_of_total_patch; i++)
+					{
+						if(*(uint16_t*)(epatch_buf+14+2*i) == gEVersion + 1)
+						{
+							current_entry.chipID = gEVersion + 1;
+							current_entry.patch_length = *(uint16_t*)(epatch_buf+14+2*epatch_info->number_of_total_patch+2*i);
+							current_entry.start_offset = *(uint32_t*)(epatch_buf+14+4*epatch_info->number_of_total_patch+4*i);
+							break;
+						}
+					}
+					RTKBT_DBG("chipID = %d",current_entry.chipID);
+					RTKBT_DBG("patch_length = 0x%x",current_entry.patch_length);
+					RTKBT_DBG("start_offset = 0x%x",current_entry.start_offset);
+
+					//get right eversion patch: buf, buf_len
+					buf_len = current_entry.patch_length + config_len;
+					RTKBT_DBG("buf_len = 0x%x",buf_len);
+
+					if (!(buf = kzalloc(buf_len, GFP_KERNEL))) {
+						RTKBT_ERR("Can't alloc memory for multi fw&config");
+						buf_len = -1;
+					}
+					else
+					{
+						memcpy(buf,&epatch_buf[current_entry.start_offset],current_entry.patch_length);
+						memcpy(&buf[current_entry.patch_length-4],&epatch_info->fm_version,4);
+					}
+					kfree(epatch_buf);
+						epatch_buf = NULL;
+
+					if (config_len)
+					{
+						memcpy(&buf[buf_len - config_len], config_file_buf, config_len);
+					}
+				}
+			}
+		}
+	}
+
+       if (config_file_buf)
+        	 kfree(config_file_buf);
+
+	RTKBT_ERR("Fw:%s exists, config file:%s exists", (buf_len > 0) ? "":"not", (config_len>0)?"":"not");
+	if (buf && (buf_len > 0) && (need_download_fw))
+	{
+		fw_len = buf_len;
+		*buff = buf;
+	}
+
+	RTKBT_DBG("load_firmware done");
 
 alloc_fail:
 	release_firmware(fw);
@@ -1591,7 +1919,7 @@ void init_xdata(
 	xdata->pipe_in = usb_rcvintpipe(dev_entry->udev, INTR_EP);
 	xdata->pipe_out = usb_sndctrlpipe(dev_entry->udev, CTRL_EP);
         xdata->send_pkt = kzalloc(PKT_LEN, GFP_KERNEL);
-	xdata->rcv_pkt = kzalloc(PKT_LEN, GFP_KERNEL);	   
+	xdata->rcv_pkt = kzalloc(PKT_LEN, GFP_KERNEL);
 	xdata->cmd_hdr = (struct hci_command_hdr*)(xdata->send_pkt);
 	xdata->evt_hdr = (struct hci_event_hdr*)(xdata->rcv_pkt);
 	xdata->cmd_cmp = (struct hci_ev_cmd_complete*)(xdata->rcv_pkt + EVT_HDR_LEN);
@@ -1624,6 +1952,7 @@ int check_fw_version(xchange_data* xdata)
 	patch_entry = xdata->dev_entry->patch_entry;
 	read_ver_rsp = (struct hci_rp_read_local_version*)(xdata->rsp_para);
 	RTKBT_DBG("check_fw_version : read_ver_rsp->lmp_subver = 0x%x",read_ver_rsp->lmp_subver);
+	RTKBT_DBG("check_fw_version : patch_entry->lmp_sub = 0x%x",patch_entry->lmp_sub);
 	if (patch_entry->lmp_sub != read_ver_rsp->lmp_subver)
 	{
 		return 1;
@@ -1634,10 +1963,79 @@ version_end:
 	return ret_val;
 }
 
+uint8_t rtk_get_eversion(dev_data * dev_entry)
+{
+	struct rtk_eversion_evt *eversion;
+	patch_info	*patch_entry;
+	int			ret_val = 0;
+	xchange_data* xdata = NULL;
+
+	RTKBT_DBG("rtk_get_eversion::gEVersion=%d", gEVersion);
+	if(gEVersion != 0xFF && gEVersion != 0xFE) {
+		RTKBT_DBG("gEVersion != 0xFF, return it directly!");
+		return gEVersion;
+	}
+
+	xdata = kzalloc(sizeof(xchange_data), GFP_KERNEL);
+	if(NULL == xdata)
+	{
+		ret_val = 0xFE;
+		RTKBT_DBG("NULL == xdata");
+              return ret_val;
+       }
+
+	init_xdata(xdata, dev_entry);
+
+	xdata->cmd_hdr->opcode = cpu_to_le16(HCI_VENDOR_READ_RTK_ROM_VERISION);
+	xdata->cmd_hdr->plen = 0;
+	xdata->pkt_len = CMD_HDR_LEN;
+
+	ret_val = send_hci_cmd(xdata);
+	if (ret_val < 0)
+	{
+		ret_val = 0xFE;
+		goto version_end;
+	}
+
+	ret_val = rcv_hci_evt(xdata);
+	if (ret_val < 0)
+	{
+		ret_val = 0xFE;
+		goto version_end;
+	}
+
+	patch_entry = xdata->dev_entry->patch_entry;
+	eversion = (struct rtk_eversion_evt*)(xdata->rsp_para);
+	RTKBT_DBG("rtk_get_eversion : eversion->status = 0x%x, eversion->version = 0x%x",eversion->status, eversion->version);
+	if (eversion->status)
+	{
+		ret_val = 0;
+	//	global_eversion = 0;
+	}
+	else
+	{
+		ret_val =  eversion->version;
+	//	global_eversion = eversion->version;
+	}
+
+version_end:
+	if(xdata != NULL)
+	{
+                if(xdata->send_pkt)
+			kfree(xdata->send_pkt);
+		if(xdata->rcv_pkt)
+			kfree(xdata->rcv_pkt);
+        	kfree(xdata);
+	}
+	return ret_val;
+
+}
+
 int get_firmware(xchange_data* xdata)
 {
 	dev_data	*dev_entry;
 	patch_info	*patch_entry;
+	RTKBT_DBG("get_firmware start");
 
 	dev_entry = xdata->dev_entry;
 	patch_entry = dev_entry->patch_entry;
@@ -1653,7 +2051,7 @@ int get_firmware(xchange_data* xdata)
 		xdata->fw_len = load_firmware(dev_entry, &xdata->fw_data);
 		if (xdata->fw_len <= 0) return -1;
 	}
-	
+	RTKBT_DBG("get_firmware done");
 	return 0;
 }
 
@@ -1665,13 +2063,15 @@ int download_data(xchange_data* xdata)
 	int			pkt_len, frag_num, frag_len;
 	int			i, ret_val;
 
+	RTKBT_DBG("download_data start");
+
 	cmd_para = (download_cp*)xdata->req_para;
 	evt_para = (download_rp*)xdata->rsp_para;
 	pcur = xdata->fw_data;
 	pkt_len = CMD_HDR_LEN + sizeof(download_cp);
 	frag_num = xdata->fw_len / PATCH_SEG_MAX + 1;
 	frag_len = PATCH_SEG_MAX;
-	
+
 	for (i = 0; i < frag_num; i++)
 	{
 		cmd_para->index = i;
@@ -1705,6 +2105,7 @@ int download_data(xchange_data* xdata)
 		pcur += PATCH_SEG_MAX;
 	}
 
+	RTKBT_DBG("download_data done");
 	return xdata->fw_len;
 }
 
@@ -1723,12 +2124,12 @@ int send_hci_cmd(xchange_data* xdata)
 
 int rcv_hci_evt(xchange_data* xdata)
 {
-	int ret_len, ret_val;
+	int ret_len = 0, ret_val = 0;
 	int i;   // Added by Realtek
 
 	while (1)
 	{
-		
+
 		// **************************** Modifed by Realtek (begin)
 		for(i = 0; i < 5; i++)   // Try to send USB interrupt message 5 times.
 		{
@@ -1746,9 +2147,9 @@ int rcv_hci_evt(xchange_data* xdata)
 			return ret_val;
 		}
 
-		
+
 	      if (CMD_CMP_EVT == xdata->evt_hdr->evt)
-	       {   
+	       {
 	           if (xdata->cmd_hdr->opcode == xdata->cmd_cmp->opcode)
 	              return ret_len;
 	       }
@@ -1757,6 +2158,220 @@ int rcv_hci_evt(xchange_data* xdata)
 	}
 }
 
+void print_acl (struct sk_buff *skb,int dataOut)
+{
+#if PRINT_ACL_DATA
+	uint wlength = skb->len;
+	uint icount=0;
+	u16* handle = (u16*)(skb->data);
+	u16 dataLen=*(handle+1);
+	u8* acl_data =(u8*)(skb->data);
+//if (0==dataOut)
+	printk("%d handle:%04x,len:%d,",dataOut,*handle,dataLen);
+//else
+//	printk("In handle:%04x,len:%d,",*handle,dataLen);
+/*	for(icount=4;(icount<wlength)&&(icount<32);icount++)
+		{
+			printk("%02x ",*(acl_data+icount) );
+		}
+	printk("\n");
+*/
+#endif
+}
+void print_command(struct sk_buff *skb)
+{
+#if PRINT_CMD_EVENT
+	uint wlength = skb->len;
+	uint icount=0;
+	u16* opcode = (u16*)(skb->data);
+	u8* cmd_data =(u8*)(skb->data);
+	u8 paramLen=*(cmd_data+2);
+
+	switch (*opcode) {
+	case HCI_OP_INQUIRY:
+		printk("HCI_OP_INQUIRY");
+		break;
+	case HCI_OP_INQUIRY_CANCEL:
+		printk("HCI_OP_INQUIRY_CANCEL");
+		break;
+	case HCI_OP_EXIT_PERIODIC_INQ:
+		printk("HCI_OP_EXIT_PERIODIC_INQ");
+		break;
+	case HCI_OP_CREATE_CONN:
+		printk("HCI_OP_CREATE_CONN");
+		break;
+	case HCI_OP_DISCONNECT:
+		printk("HCI_OP_DISCONNECT");
+		break;
+	case HCI_OP_CREATE_CONN_CANCEL:
+		printk("HCI_OP_CREATE_CONN_CANCEL");
+		break;
+	case HCI_OP_ACCEPT_CONN_REQ:
+		printk("HCI_OP_ACCEPT_CONN_REQ");
+		break;
+	case HCI_OP_REJECT_CONN_REQ:
+		printk("HCI_OP_REJECT_CONN_REQ");
+		break;
+	case HCI_OP_AUTH_REQUESTED:
+		printk("HCI_OP_AUTH_REQUESTED");
+		break;
+	case HCI_OP_SET_CONN_ENCRYPT:
+		printk("HCI_OP_SET_CONN_ENCRYPT");
+		break;
+	case HCI_OP_REMOTE_NAME_REQ:
+		printk("HCI_OP_REMOTE_NAME_REQ");
+		break;
+	case HCI_OP_READ_REMOTE_FEATURES:
+		printk("HCI_OP_READ_REMOTE_FEATURES");
+		break;
+	case HCI_OP_SNIFF_MODE:
+		printk("HCI_OP_SNIFF_MODE");
+		break;
+	case HCI_OP_EXIT_SNIFF_MODE:
+		printk("HCI_OP_EXIT_SNIFF_MODE");
+		break;
+	case HCI_OP_SWITCH_ROLE:
+		printk("HCI_OP_SWITCH_ROLE");
+		break;
+	case HCI_OP_SNIFF_SUBRATE:
+		printk("HCI_OP_SNIFF_SUBRATE");
+		break;
+	case HCI_OP_RESET:
+		printk("HCI_OP_RESET");
+		break;
+	default:
+		printk("CMD");
+		break;
+	}
+	printk(":%04x,len:%d,",*opcode,paramLen);
+	for(icount=3;(icount<wlength)&&(icount<24);icount++)
+		{
+			printk("%02x ",*(cmd_data+icount) );
+		}
+	printk("\n");
+
+#endif
+}
+void print_event(struct sk_buff *skb)
+{
+#if PRINT_CMD_EVENT
+	uint wlength = skb->len;
+	uint icount=0;
+	u8* opcode = (u8*)(skb->data);
+	u8 paramLen=*(opcode+1);
+
+	switch (*opcode) {
+	case HCI_EV_INQUIRY_COMPLETE:
+		printk("HCI_EV_INQUIRY_COMPLETE");
+		break;
+	case HCI_EV_INQUIRY_RESULT:
+		printk("HCI_EV_INQUIRY_RESULT");
+		break;
+	case HCI_EV_CONN_COMPLETE:
+		printk("HCI_EV_CONN_COMPLETE");
+		break;
+	case HCI_EV_CONN_REQUEST:
+		printk("HCI_EV_CONN_REQUEST");
+		break;
+	case HCI_EV_DISCONN_COMPLETE:
+		printk("HCI_EV_DISCONN_COMPLETE");
+		break;
+	case HCI_EV_AUTH_COMPLETE:
+		printk("HCI_EV_AUTH_COMPLETE");
+		break;
+	case HCI_EV_REMOTE_NAME:
+		printk("HCI_EV_REMOTE_NAME");
+		break;
+	case HCI_EV_ENCRYPT_CHANGE:
+		printk("HCI_EV_ENCRYPT_CHANGE");
+		break;
+	case HCI_EV_CHANGE_LINK_KEY_COMPLETE:
+		printk("HCI_EV_CHANGE_LINK_KEY_COMPLETE");
+		break;
+	case HCI_EV_REMOTE_FEATURES:
+		printk("HCI_EV_REMOTE_FEATURES");
+		break;
+	case HCI_EV_REMOTE_VERSION:
+		printk("HCI_EV_REMOTE_VERSION");
+		break;
+	case HCI_EV_QOS_SETUP_COMPLETE:
+		printk("HCI_EV_QOS_SETUP_COMPLETE");
+		break;
+	case HCI_EV_CMD_COMPLETE:
+		printk("HCI_EV_CMD_COMPLETE");
+		break;
+	case HCI_EV_CMD_STATUS:
+		printk("HCI_EV_CMD_STATUS");
+		break;
+	case HCI_EV_ROLE_CHANGE:
+		printk("HCI_EV_ROLE_CHANGE");
+		break;
+	case HCI_EV_NUM_COMP_PKTS:
+		printk("HCI_EV_NUM_COMP_PKTS");
+		break;
+	case HCI_EV_MODE_CHANGE:
+		printk("HCI_EV_MODE_CHANGE");
+		break;
+	case HCI_EV_PIN_CODE_REQ:
+		printk("HCI_EV_PIN_CODE_REQ");
+		break;
+	case HCI_EV_LINK_KEY_REQ:
+		printk("HCI_EV_LINK_KEY_REQ");
+		break;
+	case HCI_EV_LINK_KEY_NOTIFY:
+		printk("HCI_EV_LINK_KEY_NOTIFY");
+		break;
+	case HCI_EV_CLOCK_OFFSET:
+		printk("HCI_EV_CLOCK_OFFSET");
+		break;
+	case HCI_EV_PKT_TYPE_CHANGE:
+		printk("HCI_EV_PKT_TYPE_CHANGE");
+		break;
+	case HCI_EV_PSCAN_REP_MODE:
+		printk("HCI_EV_PSCAN_REP_MODE");
+		break;
+	case HCI_EV_INQUIRY_RESULT_WITH_RSSI:
+		printk("HCI_EV_INQUIRY_RESULT_WITH_RSSI");
+		break;
+	case HCI_EV_REMOTE_EXT_FEATURES:
+		printk("HCI_EV_REMOTE_EXT_FEATURES");
+		break;
+	case HCI_EV_SYNC_CONN_COMPLETE:
+		printk("HCI_EV_SYNC_CONN_COMPLETE");
+		break;
+	case HCI_EV_SYNC_CONN_CHANGED:
+		printk("HCI_EV_SYNC_CONN_CHANGED");
+		break;
+	case HCI_EV_SNIFF_SUBRATE:
+		printk("HCI_EV_SNIFF_SUBRATE");
+		break;
+	case HCI_EV_EXTENDED_INQUIRY_RESULT:
+		printk("HCI_EV_EXTENDED_INQUIRY_RESULT");
+		break;
+	case HCI_EV_IO_CAPA_REQUEST:
+		printk("HCI_EV_IO_CAPA_REQUEST");
+		break;
+	case HCI_EV_SIMPLE_PAIR_COMPLETE:
+		printk("HCI_EV_SIMPLE_PAIR_COMPLETE");
+		break;
+	case HCI_EV_REMOTE_HOST_FEATURES:
+		printk("HCI_EV_REMOTE_HOST_FEATURES");
+		break;
+	default:
+		printk("event");
+		break;
+	}
+	printk(":%02x,len:%d,",*opcode,paramLen);
+	for(icount=2;(icount<wlength)&&(icount<24);icount++)
+	{
+			printk("%02x ",*(opcode+icount) );
+	}
+	printk("\n");
+
+#endif
+
+}
+
 #if CONFIG_BLUEDROID //for 4.2
 //=========================================
 /*
@@ -1773,6 +2388,8 @@ btfcd_open(struct inode *inode_p,
 	RTKBT_DBG("btfcd open\n");
 
 	hdev = hci_dev_get(0);
+	if (!hdev)
+		return -1;
 	data = GET_DRV_DATA(hdev);
 
 	skb_queue_head_init(&data->readq);
@@ -1931,7 +2548,6 @@ btfcd_write(struct file  *file_p,
 	skb = bt_skb_alloc(count, GFP_ATOMIC);
 	if (!skb)
 		return -ENOMEM;
-	skb_reserve(skb, -1); // Add this line
 
 	if (copy_from_user(skb_put(skb, count), buf_p, count)) {
 		printk("==========btfcd copy_from_user return -1 \n");
@@ -1939,6 +2555,10 @@ btfcd_write(struct file  *file_p,
 		return -EFAULT;
 	}
 
+        if (!data || !data->hdev) {
+                return -EFAULT;
+        }
+
 	skb->dev = (void *) data->hdev;
 	bt_cb(skb)->pkt_type = *((__u8 *) skb->data);
 	skb_pull(skb, 1);
@@ -2065,7 +2685,7 @@ static void hci_send_to_stack(struct hci_dev *hdev, struct sk_buff *skb)
 
 /* Get HCI device by index.
  * Device is held on return. */
-struct hci_dev *hci_dev_get(int index)
+static struct hci_dev *hci_dev_get(int index)
 {
 	//RTKBT_DBG("hci_dev_get index=%d", index);
 
@@ -2078,7 +2698,7 @@ struct hci_dev *hci_dev_get(int index)
 }
 
 /* ---- HCI ioctl helpers ---- */
-int hci_dev_open(__u16 dev)
+static int hci_dev_open(__u16 dev)
 {
 	struct hci_dev *hdev;
 	int ret = 0;
@@ -2126,7 +2746,7 @@ static int hci_dev_do_close(struct hci_dev *hdev)
 	hdev->flags = 0;
 	return 0;
 }
-int hci_dev_close(__u16 dev)
+static int hci_dev_close(__u16 dev)
 {
 	struct hci_dev *hdev;
 	int err;
@@ -2140,7 +2760,7 @@ int hci_dev_close(__u16 dev)
 	return err;
 }
 
-struct hci_dev *hci_alloc_dev(void)
+static struct hci_dev *hci_alloc_dev(void)
 {
 	struct hci_dev *hdev;
 
@@ -2152,7 +2772,7 @@ struct hci_dev *hci_alloc_dev(void)
 }
 
 /* Free HCI device */
-void hci_free_dev(struct hci_dev *hdev)
+static void hci_free_dev(struct hci_dev *hdev)
 {
     //	skb_queue_purge(&hdev->driver_init);
     //RTKBT_DBG("hci_free_dev-----1 ");
@@ -2163,7 +2783,7 @@ void hci_free_dev(struct hci_dev *hdev)
 }
 
 /* Register HCI device */
-int hci_register_dev(struct hci_dev *hdev)
+static int hci_register_dev(struct hci_dev *hdev)
 {
 	int i, id;
 
@@ -2175,7 +2795,7 @@ int hci_register_dev(struct hci_dev *hdev)
 
 	RTKBT_DBG("id=%d ",id);
 
-	write_lock(&hci_dev_list_lock1);
+	write_lock(&hci_dev_list_lock);
 
 	sprintf(hdev->name, "hci%d", id);
 	RTKBT_DBG("hdev->name=%s ",hdev->name);
@@ -2195,22 +2815,22 @@ int hci_register_dev(struct hci_dev *hdev)
 	Ghdev =hdev;
 	if(Ghdev)
 		RTKBT_ERR(" ===================hci_register_dev success");
-	write_unlock(&hci_dev_list_lock1);
+	write_unlock(&hci_dev_list_lock);
 
 	return id;
 }
 
 /* Unregister HCI device */
-void hci_unregister_dev(struct hci_dev *hdev)
+static void hci_unregister_dev(struct hci_dev *hdev)
 {
 	int i;
 
 	RTKBT_DBG("hci_unregister_dev hdev%p name %s bus %d", hdev, hdev->name, hdev->bus);
 	set_bit(HCI_UNREGISTER, &hdev->dev_flags);
 
-	write_lock(&hci_dev_list_lock1);
+	write_lock(&hci_dev_list_lock);
 	Ghdev = NULL;
-	write_unlock(&hci_dev_list_lock1);
+	write_unlock(&hci_dev_list_lock);
 
 	hci_dev_do_close(hdev);
 	for (i = 0; i < NUM_REASSEMBLY; i++)
@@ -2218,10 +2838,10 @@ void hci_unregister_dev(struct hci_dev *hdev)
 }
 
 /* Receive frame from HCI drivers */
-int hci_recv_frame(struct sk_buff *skb)
+static int hci_recv_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	RTKBT_DBG("hci_recv_frame hdev->flags =%d",hdev->flags);
+//	RTKBT_DBG("hci_recv_frame hdev->flags =%d",hdev->flags);
 	if (!hdev || (!test_bit(HCI_UP, &hdev->flags)
 				&& !test_bit(HCI_INIT, &hdev->flags))) {
 		kfree_skb(skb);
@@ -2342,6 +2962,11 @@ static int hci_reassembly(struct hci_dev *hdev, int type, void *data,
 		if (scb->expect == 0) {
 			/* Complete frame */
 
+			if(HCI_ACLDATA_PKT==type )
+				print_acl(skb,0);
+			if(HCI_EVENT_PKT==type)
+				print_event(skb);
+
 			bt_cb(skb)->pkt_type = type;
 			hci_recv_frame(skb);
 
@@ -2353,7 +2978,7 @@ static int hci_reassembly(struct hci_dev *hdev, int type, void *data,
 	return remain;
 }
 
-int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count)
+static int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count)
 {
 	int rem = 0;
 
diff --git a/drivers/amlogic/bluetooth/rtk8723/rtk_btusb.h b/drivers/amlogic/bluetooth/rtk8723/rtk_btusb.h
index cdbb10dd10e2..6db56450e432 100755
--- a/drivers/amlogic/bluetooth/rtk8723/rtk_btusb.h
+++ b/drivers/amlogic/bluetooth/rtk8723/rtk_btusb.h
@@ -39,7 +39,7 @@
 #define CONFIG_BLUEDROID        1 //bleuz 0 ;  bluedroid 1
 
 #if CONFIG_BLUEDROID //for 4.2
-#else //for blueZ	
+#else //for blueZ
 	#include <net/bluetooth/bluetooth.h>
 	#include <net/bluetooth/hci_core.h>
 	#include <net/bluetooth/hci.h>
@@ -50,11 +50,14 @@
 ** Realtek - For rtk_btusb driver **
 ***********************************/
 #define BTUSB_RPM		0* USB_RPM 	//	1 SS enable; 0 SS disable
-#define LOAD_CONFIG		1         // set 1 if need to reconfig bt efuse
-#define URB_CANCELING_DELAY_MS	10  	 // Added by Realtek
-//when os suspend, module is still powered,usb is not powered, 
+
+//when os suspend, module is still powered,usb is not powered,
 //this may set to 1 ,and must comply with special patch code
-#define CONFIG_RESET_RESUME		1
+#define CONFIG_RESET_RESUME		0
+
+#define URB_CANCELING_DELAY_MS	10  	 // Added by Realtek
+#define PRINT_CMD_EVENT			0
+#define PRINT_ACL_DATA			0
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 33)
 #define HDEV_BUS		hdev->bus
@@ -68,16 +71,25 @@
 #define NUM_REASSEMBLY 3
 #endif
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 4, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
 #define GET_DRV_DATA(x)		hci_get_drvdata(x)
 #else
 #define GET_DRV_DATA(x)		x->driver_data
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+#define SCO_NUM    hdev->conn_hash.sco_num
+#else
+#define SCO_NUM     hci_conn_num(hdev, SCO_LINK)
+#endif
+
 static int patch_add(struct usb_interface* intf);
 static void patch_remove(struct usb_interface* intf);
 static int download_patch(struct usb_interface* intf);
 static int set_btoff(struct usb_interface* intf);
+static void print_event(struct sk_buff *skb);
+static void print_command(struct sk_buff *skb);
+static void print_acl (struct sk_buff *skb,int dataOut);
 
 #define BTUSB_MAX_ISOC_FRAMES	10
 #define BTUSB_INTR_RUNNING		0
@@ -85,6 +97,10 @@ static int set_btoff(struct usb_interface* intf);
 #define BTUSB_ISOC_RUNNING		2
 #define BTUSB_SUSPENDING		3
 #define BTUSB_DID_ISO_RESUME	4
+/*******************************/
+// Added by Realtek
+#define BTUSB_NEXT_RX_URB_SUBMITTING		5
+/*******************************/
 
 struct btusb_data {
 	struct hci_dev       *hdev;
@@ -125,6 +141,53 @@ struct btusb_data {
 #endif
 };
 
+
+//----------
+#define HCI_CMD_READ_BD_ADDR 0x1009
+#define HCI_VENDOR_CHANGE_BDRATE 0xfc17
+#define HCI_VENDOR_READ_RTK_ROM_VERISION 0xfc6d
+#define HCI_VENDOR_READ_LMP_VERISION 0x1001
+
+#define ROM_LMP_8723a               0x1200
+#define ROM_LMP_8723b               0x8723
+#define ROM_LMP_8821a               0X8821
+#define ROM_LMP_8761a               0X8761
+
+//signature: Realtech
+const uint8_t  RTK_EPATCH_SIGNATURE[8]={0x52,0x65,0x61,0x6C,0x74,0x65,0x63,
+0x68};
+//Extension Section IGNATURE:0x77FD0451
+const uint8_t Extension_Section_SIGNATURE[4]={0x51,0x04,0xFD,0x77};
+uint16_t project_id[]=
+{
+	ROM_LMP_8723a,
+	ROM_LMP_8723b,
+	ROM_LMP_8821a,
+	ROM_LMP_8761a
+};
+struct rtk_eversion_evt {
+	uint8_t status;
+	uint8_t version;
+}__attribute__ ((packed));
+
+struct rtk_epatch_entry{
+	uint16_t chipID;
+	uint16_t patch_length;
+	uint32_t start_offset;
+} __attribute__ ((packed));
+
+struct rtk_epatch{
+    	uint8_t signature[8];
+	uint32_t fm_version;
+	uint16_t number_of_total_patch;
+	struct rtk_epatch_entry entry[0];
+} __attribute__ ((packed));
+
+struct rtk_extension_entry{
+	uint8_t opcode;
+	uint8_t length;
+	uint8_t *data;
+} __attribute__ ((packed));
 /* Realtek - For rtk_btusb driver end */
 
 //========================================================================
@@ -132,7 +195,7 @@ struct btusb_data {
 #if CONFIG_BLUEDROID //for 4.2
 #define SUCCESS               0 /* Linux success code */
 #define ERROR                -1 /* Linux error code */
-#define QUEUE_SIZE 100
+#define QUEUE_SIZE 500
 static int btfcd_init(void);
 static void btfcd_exit(void);
 static int btfcd_open(struct inode *inode_p, struct file *file_p);
@@ -367,6 +430,9 @@ struct hci_dev {
 	int (*send)(struct sk_buff *skb);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
 	void (*destruct)(struct hci_dev *hdev);
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 1)
+	__u16               voice_setting;
 #endif
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 	int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
@@ -411,4 +477,83 @@ static int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int cou
 #define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->parent = (pdev))
 /* Realtek - Integrate from hci_core.h end */
 
+
+
+/* -----  HCI Commands ---- */
+#define HCI_OP_INQUIRY			0x0401
+#define HCI_OP_INQUIRY_CANCEL		0x0402
+#define HCI_OP_EXIT_PERIODIC_INQ	0x0404
+#define HCI_OP_CREATE_CONN		0x0405
+#define HCI_OP_ADD_SCO			0x0407
+#define HCI_OP_CREATE_CONN_CANCEL	0x0408
+#define HCI_OP_ACCEPT_CONN_REQ		0x0409
+#define HCI_OP_REJECT_CONN_REQ		0x040a
+#define HCI_OP_LINK_KEY_REPLY		0x040b
+#define HCI_OP_LINK_KEY_NEG_REPLY	0x040c
+#define HCI_OP_PIN_CODE_REPLY		0x040d
+#define HCI_OP_PIN_CODE_NEG_REPLY	0x040e
+#define HCI_OP_CHANGE_CONN_PTYPE	0x040f
+#define HCI_OP_AUTH_REQUESTED		0x0411
+#define HCI_OP_SET_CONN_ENCRYPT		0x0413
+#define HCI_OP_CHANGE_CONN_LINK_KEY	0x0415
+#define HCI_OP_REMOTE_NAME_REQ		0x0419
+#define HCI_OP_REMOTE_NAME_REQ_CANCEL	0x041a
+#define HCI_OP_READ_REMOTE_FEATURES	0x041b
+#define HCI_OP_READ_REMOTE_EXT_FEATURES	0x041c
+#define HCI_OP_READ_REMOTE_VERSION	0x041d
+#define HCI_OP_SETUP_SYNC_CONN		0x0428
+#define HCI_OP_ACCEPT_SYNC_CONN_REQ	0x0429
+#define HCI_OP_REJECT_SYNC_CONN_REQ	0x042a
+#define HCI_OP_SNIFF_MODE		0x0803
+#define HCI_OP_EXIT_SNIFF_MODE		0x0804
+#define HCI_OP_ROLE_DISCOVERY		0x0809
+#define HCI_OP_SWITCH_ROLE		0x080b
+#define HCI_OP_READ_LINK_POLICY		0x080c
+#define HCI_OP_WRITE_LINK_POLICY	0x080d
+#define HCI_OP_READ_DEF_LINK_POLICY	0x080e
+#define HCI_OP_WRITE_DEF_LINK_POLICY	0x080f
+#define HCI_OP_SNIFF_SUBRATE		0x0811
+#define HCI_OP_SET_EVENT_MASK		0x0c01
+#define HCI_OP_RESET			0x0c03
+#define HCI_OP_SET_EVENT_FLT		0x0c05
+
+/* -----  HCI events---- */
+#define HCI_OP_DISCONNECT		0x0406
+#define HCI_EV_INQUIRY_COMPLETE		0x01
+#define HCI_EV_INQUIRY_RESULT		0x02
+#define HCI_EV_CONN_COMPLETE		0x03
+#define HCI_EV_CONN_REQUEST			0x04
+#define HCI_EV_DISCONN_COMPLETE		0x05
+#define HCI_EV_AUTH_COMPLETE		0x06
+#define HCI_EV_REMOTE_NAME			0x07
+#define HCI_EV_ENCRYPT_CHANGE		0x08
+#define HCI_EV_CHANGE_LINK_KEY_COMPLETE	0x09
+
+#define HCI_EV_REMOTE_FEATURES		0x0b
+#define HCI_EV_REMOTE_VERSION		0x0c
+#define HCI_EV_QOS_SETUP_COMPLETE	0x0d
+#define HCI_EV_CMD_COMPLETE			0x0e
+#define HCI_EV_CMD_STATUS			0x0f
+
+#define HCI_EV_ROLE_CHANGE			0x12
+#define HCI_EV_NUM_COMP_PKTS		0x13
+#define HCI_EV_MODE_CHANGE			0x14
+#define HCI_EV_PIN_CODE_REQ			0x16
+#define HCI_EV_LINK_KEY_REQ			0x17
+#define HCI_EV_LINK_KEY_NOTIFY		0x18
+#define HCI_EV_CLOCK_OFFSET			0x1c
+#define HCI_EV_PKT_TYPE_CHANGE		0x1d
+#define HCI_EV_PSCAN_REP_MODE		0x20
+
+#define HCI_EV_INQUIRY_RESULT_WITH_RSSI	0x22
+#define HCI_EV_REMOTE_EXT_FEATURES	0x23
+#define HCI_EV_SYNC_CONN_COMPLETE	0x2c
+#define HCI_EV_SYNC_CONN_CHANGED	0x2d
+#define HCI_EV_SNIFF_SUBRATE			0x2e
+#define HCI_EV_EXTENDED_INQUIRY_RESULT	0x2f
+#define HCI_EV_IO_CAPA_REQUEST		0x31
+#define HCI_EV_SIMPLE_PAIR_COMPLETE	0x36
+#define HCI_EV_REMOTE_HOST_FEATURES	0x3d
+
+
 #endif //if bluedroid 4.2
-- 
2.19.0

