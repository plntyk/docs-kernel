From 1bd3e24ec2d4f808b6167e27f47bad8a9cc3ee98 Mon Sep 17 00:00:00 2001
From: Lawrence Mok <lawrence.mok@amlogic.com>
Date: Mon, 13 Oct 2014 14:43:12 -0700
Subject: [PATCH 4949/5965] drivers/amlogic: remove printed \r

Change-Id: I64f61cf5d2a316eb369b311ce65257f031fd1cbe
---
 drivers/amlogic/amports/encoder.c             |   2 +-
 drivers/amlogic/amports/jpegenc.c             |   2 +-
 drivers/amlogic/amports/picdec.c              |   6 +-
 drivers/amlogic/amports/vh265.c               |   8 +--
 drivers/amlogic/amports/video.c               |   8 +--
 drivers/amlogic/amports/video2.c              |   2 +-
 drivers/amlogic/audiodsp/dsp_data.z           | Bin 64284 -> 64282 bytes
 drivers/amlogic/camera/common/vm.c            |   4 +-
 drivers/amlogic/camera/common/vmcls.h         |   2 +-
 drivers/amlogic/camera/sp1628.c               |  12 ++--
 drivers/amlogic/camera/sp2518.c               |  12 ++--
 drivers/amlogic/deinterlace/deinterlace.c     |   2 +-
 .../aml_logo/logo_display/logo_output.c       |   2 +-
 drivers/amlogic/display/ge2d/ge2d_main.c      |  32 ++++-----
 drivers/amlogic/display/ge2d/ge2d_wq.c        |  62 +++++++++---------
 drivers/amlogic/display/osd/osd_hw.c          |  10 +--
 drivers/amlogic/display/osd/osd_main.c        |  34 +++++-----
 drivers/amlogic/display/osd_ext/osd_hw.c      |   8 +--
 drivers/amlogic/display/osd_ext/osd_main.c    |  30 ++++-----
 drivers/amlogic/display/vout/tvconf.c         |  16 ++---
 drivers/amlogic/display/vout/vdac_switch.c    |   2 +-
 drivers/amlogic/display/vout/vout_serve.c     |  18 ++---
 drivers/amlogic/display/vout2/tvconf2.c       |  16 ++---
 drivers/amlogic/display/vout2/vout2_serve.c   |  22 +++----
 drivers/amlogic/dvb_tv/amldemod/aml_demod.c   |   4 +-
 drivers/amlogic/dvb_tv/amldemod/amlfrontend.c |  20 +++---
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c        |  16 ++---
 drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c   |  24 +++----
 drivers/amlogic/i2c/aml_sw_i2c.c              |   4 +-
 drivers/amlogic/input/call_key/aml_callkey.c  |   2 +-
 drivers/amlogic/input/gpio_key/aml_gpiokey.c  |   6 +-
 drivers/amlogic/input/holdkey/aml_holdkey.c   |   2 +-
 drivers/amlogic/input/keyboard/adc_keypad.c   |   6 +-
 drivers/amlogic/input/keyboard/ha2605.c       |   6 +-
 drivers/amlogic/input/keyboard/it7230.c       |   4 +-
 drivers/amlogic/input/keyboard/so340010.c     |   6 +-
 .../amlogic/input/new_remote/remote_func.c    |   2 +-
 .../amlogic/input/new_remote/remote_main.c    |  12 ++--
 drivers/amlogic/input/remote/am_remote.c      |  14 ++--
 drivers/amlogic/input/remote/sw_remote_kbd.c  |   2 +-
 drivers/amlogic/input/remote/sw_remote_rc6.c  |   2 +-
 drivers/amlogic/input/remote/virtual_remote.c |   6 +-
 .../input/simcard_detect/simcard_detect.c     |   4 +-
 .../input/touchscreen/ft5x02/ft5x02_ts.c      |   4 +-
 drivers/amlogic/input/touchscreen/uor6x5x.c   |  32 ++++-----
 drivers/amlogic/mhl/it6681/it6681_drv.c       |   2 +-
 drivers/amlogic/ppmgr/ppmgr_drv.c             |   6 +-
 47 files changed, 249 insertions(+), 249 deletions(-)

diff --git a/drivers/amlogic/amports/encoder.c b/drivers/amlogic/amports/encoder.c
index 1809a82b5f34..1f45d96f64da 100755
--- a/drivers/amlogic/amports/encoder.c
+++ b/drivers/amlogic/amports/encoder.c
@@ -2353,7 +2353,7 @@ int  init_avc_device(void)
     r =register_chrdev(0,DEVICE_NAME,&amvenc_avc_fops);
     if(r<=0)
     {
-        amlog_level(LOG_LEVEL_HIGH,"register amvenc_avc device error\r\n");
+        amlog_level(LOG_LEVEL_HIGH,"register amvenc_avc device error\n");
         return  r  ;
     }
     avc_device_major= r ;
diff --git a/drivers/amlogic/amports/jpegenc.c b/drivers/amlogic/amports/jpegenc.c
index a5f2f3064ae0..316c074d2c9c 100755
--- a/drivers/amlogic/amports/jpegenc.c
+++ b/drivers/amlogic/amports/jpegenc.c
@@ -1728,7 +1728,7 @@ int  init_jpegenc_device(void)
     r =register_chrdev(0,DEVICE_NAME,&jpegenc_fops);
     if(r<=0) 
     {
-        debug_level(2,"register jpegenc device error\r\n");
+        debug_level(2,"register jpegenc device error\n");
         return  r  ;
     }
     jpegenc_device_major= r ;
diff --git a/drivers/amlogic/amports/picdec.c b/drivers/amlogic/amports/picdec.c
index a85ee173e13a..25008f2a22f3 100755
--- a/drivers/amlogic/amports/picdec.c
+++ b/drivers/amlogic/amports/picdec.c
@@ -1354,7 +1354,7 @@ struct class* init_picdec_cls(void) {
 	ret = class_register(&picdec_class);
 	if(ret < 0)
 	{
-		amlog_level(LOG_LEVEL_HIGH,"error create picdec class\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"error create picdec class\n");
 		return NULL;
 	}
 	return &picdec_class;
@@ -1370,12 +1370,12 @@ int init_picdec_device(void)
 	ret=register_chrdev(0,picdec_device.name,&picdec_fops);
 	if(ret <=0)
 	{
-		amlog_level(LOG_LEVEL_HIGH,"register picdec device error\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"register picdec device error\n");
 		return  ret ;
 	}
 	picdec_device.major=ret;
 	picdec_device.dbg_enable=0;
-	amlog_level(LOG_LEVEL_LOW,"picdec_dev major:%d\r\n",ret);
+	amlog_level(LOG_LEVEL_LOW,"picdec_dev major:%d\n",ret);
 
 	picdec_device.cla = init_picdec_cls();
 	if(picdec_device.cla == NULL)
diff --git a/drivers/amlogic/amports/vh265.c b/drivers/amlogic/amports/vh265.c
index 5b163a78062e..4be4e43ee041 100755
--- a/drivers/amlogic/amports/vh265.c
+++ b/drivers/amlogic/amports/vh265.c
@@ -1120,7 +1120,7 @@ static void init_pic_list_hw(void)
 static void dump_pic_list(hevc_stru_t* hevc)
 {
 	PIC_t* pic = hevc->decode_pic_list;
-	printk("pic_list_init_flag is %d\r\n", hevc->pic_list_init_flag);
+	printk("pic_list_init_flag is %d\n", hevc->pic_list_init_flag);
 	while(pic){
 		printk("index %d decode_idx:%d,	POC:%d,	referenced:%d,	num_reorder_pic:%d, output_mark:%d, output_ready:%d, mv_wr_start %lx\n", pic->index, pic->decode_idx, pic->POC, pic->referenced, pic->num_reorder_pic, pic->output_mark, pic->output_ready, pic->mpred_mv_wr_start_addr);
 		pic = pic->next;
@@ -3218,7 +3218,7 @@ static irqreturn_t vh265_isr(int irq, void *dev_id)
    if(debug&H265_DEBUG_UCODE){
        if(READ_HREG(DEBUG_REG1)&0x10000){
 #if 0
-            printk("PPS \r\n");
+            printk("PPS\n");
             for(i=0; i<(hevc->debug_ptr_size/2); i+=4){
                 int ii;
                 for(ii=0; ii<4; ii++){
@@ -3409,7 +3409,7 @@ static irqreturn_t vh265_isr(int irq, void *dev_id)
                         printk("\n");
                 } 
                 
-                printk("vui_timing_info: %x, %x, %x, %x\r\n",         rpm_param.p.vui_num_units_in_tick_hi,
+                printk("vui_timing_info: %x, %x, %x, %x\n",         rpm_param.p.vui_num_units_in_tick_hi,
                             rpm_param.p.vui_num_units_in_tick_lo,
                             rpm_param.p.vui_time_scale_hi,
                             rpm_param.p.vui_time_scale_lo);
@@ -3754,7 +3754,7 @@ static s32 vh265_init(void)
     amhevc_enable();
 #if 0
     if(debug &H265_DEBUG_LOAD_UCODE_FROM_FILE){
-        printk("load ucode from file\r\n");
+        printk("load ucode from file\n");
         if (amhevc_loadmc(ucode_buf) < 0) {
             amhevc_disable();
             return -EBUSY;
diff --git a/drivers/amlogic/amports/video.c b/drivers/amlogic/amports/video.c
index 24ea3ff2287e..9fc9e6d73e28 100755
--- a/drivers/amlogic/amports/video.c
+++ b/drivers/amlogic/amports/video.c
@@ -4040,7 +4040,7 @@ static void set_video_crop(const char *para)
         _set_video_crop(parsed);
     }
     amlog_mask(LOG_MASK_SYSFS,
-               "video crop=>x0:%d,y0:%d,x1:%d,y1:%d\r\n ",
+               "video crop=>x0:%d,y0:%d,x1:%d,y1:%d\n ",
                parsed[0], parsed[1], parsed[2], parsed[3]);
 }
 
@@ -4052,7 +4052,7 @@ static void set_video_speed_check(const char *para)
         vpp_set_video_speed_check(parsed[0], parsed[1]);
     }
     amlog_mask(LOG_MASK_SYSFS,
-               "video speed_check=>h:%d,w:%d\r\n ",
+               "video speed_check=>h:%d,w:%d\n ",
                parsed[0], parsed[1]);
 }
 
@@ -4064,7 +4064,7 @@ static void set_video_window(const char *para)
         _set_video_window(parsed);
     }
     amlog_mask(LOG_MASK_SYSFS,
-               "video=>x0:%d,y0:%d,x1:%d,y1:%d\r\n ",
+               "video=>x0:%d,y0:%d,x1:%d,y1:%d\n ",
                parsed[0], parsed[1], parsed[2], parsed[3]);
 }
 static ssize_t video_3d_scale_store(struct class *cla, struct class_attribute *attr, const char *buf, size_t count)
@@ -4168,7 +4168,7 @@ static ssize_t video_global_offset_store(struct class *cla, struct class_attribu
         video_property_changed = true;
 
         amlog_mask(LOG_MASK_SYSFS,
-                   "video_offset=>x0:%d,y0:%d\r\n ",
+                   "video_offset=>x0:%d,y0:%d\n ",
                    parsed[0], parsed[1]);
     }
 
diff --git a/drivers/amlogic/amports/video2.c b/drivers/amlogic/amports/video2.c
index b407404f0eed..35ad9097ad60 100755
--- a/drivers/amlogic/amports/video2.c
+++ b/drivers/amlogic/amports/video2.c
@@ -2231,7 +2231,7 @@ static void set_video_window(const char *para)
         video_property_changed = true;
     }
     amlog_mask(LOG_MASK_SYSFS,
-               "video=>x0:%d,y0:%d,x1:%d,y1:%d\r\n ",
+               "video=>x0:%d,y0:%d,x1:%d,y1:%d\n",
                parsed[0], parsed[1], parsed[2], parsed[3]);
 }
 
diff --git a/drivers/amlogic/audiodsp/dsp_data.z b/drivers/amlogic/audiodsp/dsp_data.z
index a3afca49dc20c7432c3cb53568401e93cbad47e6..cac06c7e81a18c83289ef8340d790a0307a768e7 100755
GIT binary patch
delta 14
WcmbR9jd|8L<_*_NHs369ZUX>3@dxby

delta 17
ZcmbRBjd{*D<_*_Nm|}`HUoUZP0{~Hv2)h6P

diff --git a/drivers/amlogic/camera/common/vm.c b/drivers/amlogic/camera/common/vm.c
index d79a297183d3..f757451c0df6 100755
--- a/drivers/amlogic/camera/common/vm.c
+++ b/drivers/amlogic/camera/common/vm.c
@@ -1888,12 +1888,12 @@ int init_vm_device(void)
 	ret=register_chrdev(0,vm_device.name,&vm_fops);
 	if(ret <=0)
 	{
-		amlog_level(LOG_LEVEL_HIGH,"register vm device error\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"register vm device error\n");
 		return  ret ;
 	}
 	vm_device.major=ret;
 	vm_device.dbg_enable=0;
-	amlog_level(LOG_LEVEL_LOW,"vm_dev major:%d\r\n",ret);
+	amlog_level(LOG_LEVEL_LOW,"vm_dev major:%d\n",ret);
 
 	vm_device.cla = init_vm_cls();
 	if(vm_device.cla == NULL)
diff --git a/drivers/amlogic/camera/common/vmcls.h b/drivers/amlogic/camera/common/vmcls.h
index 126b5594ed8a..e730bdaa6e33 100755
--- a/drivers/amlogic/camera/common/vmcls.h
+++ b/drivers/amlogic/camera/common/vmcls.h
@@ -167,7 +167,7 @@ struct class* init_vm_cls() {
 	ret = class_register(&vm_class);
 	if(ret < 0)
 	{
-		amlog_level(LOG_LEVEL_HIGH,"error create vm class\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"error create vm class\n");
 		return NULL;
 	}
 	return &vm_class;
diff --git a/drivers/amlogic/camera/sp1628.c b/drivers/amlogic/camera/sp1628.c
index f94010558bb3..60e435f210c6 100755
--- a/drivers/amlogic/camera/sp1628.c
+++ b/drivers/amlogic/camera/sp1628.c
@@ -1202,7 +1202,7 @@ void SP1628_night_mode(struct sp1628_device *dev,enum  camera_night_mode_flip_e
 			{
 				//i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
 				//i2c_put_byte_add8_new(client,0x32,0x08);
-				printk("night mode 50hz\r\n");
+				printk("night mode 50hz\n");
 				#if 0					   
 					//capture preview night  24M 3pll 50hz 17.6-6FPS vga
 				i2c_put_byte_add8_new(client,0xfd,0x00);
@@ -1284,7 +1284,7 @@ void SP1628_night_mode(struct sp1628_device *dev,enum  camera_night_mode_flip_e
 			{
 				//i2c_put_byte_add8_new(client,,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
 				//i2c_put_byte_add8_new(client,,0x32,0x08);
-				printk("night mode 60hz\r\n");
+				printk("night mode 60hz\n");
 	            #if 0
 				 //capture preview night  24M 3pll 60hz 17.6-6FPS vga
 				i2c_put_byte_add8_new(client,0xfd,0x00);
@@ -1371,7 +1371,7 @@ void SP1628_night_mode(struct sp1628_device *dev,enum  camera_night_mode_flip_e
 			{
 				//i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
 				//i2c_put_byte_add8_new(client,0x32,0x08);
-				printk("normal mode 50hz\r\n"); 
+				printk("normal mode 50hz\n"); 
 	            #if 0
 			   //capture preview daylight 24M 3pll 50hz 17.6-9FPS vga
 				i2c_put_byte_add8_new(client,0xfd,0x00);
@@ -1451,7 +1451,7 @@ void SP1628_night_mode(struct sp1628_device *dev,enum  camera_night_mode_flip_e
 			{
 				//i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
 				//i2c_put_byte_add8_new(client,0x32,0x08);
-				printk("normal mode 60hz\r\n"); 
+				printk("normal mode 60hz\n"); 
 			    #if 0
 				//capture preview daylight 24M 3pll 60hz 17.6-9FPS vga
 				i2c_put_byte_add8_new(client,0xfd,0x00);
@@ -1562,7 +1562,7 @@ void SP1628_set_param_banding(struct sp1628_device *dev,enum  camera_banding_fli
 		
 			Antiflicker = DCAMERA_FLICKER_50HZ;
 		
-			printk( " set_SP1628_anti_flicker  50hz \r\n" );
+			printk( " set_SP1628_anti_flicker  50hz\n" );
 		
 			break;
 		
@@ -1570,7 +1570,7 @@ void SP1628_set_param_banding(struct sp1628_device *dev,enum  camera_banding_fli
 		
 			Antiflicker = DCAMERA_FLICKER_60HZ;
 		
-			printk( " set_SP1628_anti_flicker  60hz \r\n" );
+			printk( " set_SP1628_anti_flicker  60hz\n" );
 		
 			break;
 		
diff --git a/drivers/amlogic/camera/sp2518.c b/drivers/amlogic/camera/sp2518.c
index fe6142c97027..a5e3063b658d 100755
--- a/drivers/amlogic/camera/sp2518.c
+++ b/drivers/amlogic/camera/sp2518.c
@@ -1260,7 +1260,7 @@ void SP2518_set_night_mode(struct sp2518_device *dev,enum  camera_night_mode_fli
 		{
 			i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
 			i2c_put_byte_add8_new(client,0x32,0x05);
-			printk("night mode 50hz\r\n");
+			printk("night mode 50hz\n");
 			#ifdef CLK24M_48M
 
 			//capture preview night 48M 50hz fix 6FPS maxgain 
@@ -1337,7 +1337,7 @@ void SP2518_set_night_mode(struct sp2518_device *dev,enum  camera_night_mode_fli
 		{
 			i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
 			i2c_put_byte_add8_new(client,0x32,0x05);
-			printk("night mode 60hz\r\n");
+			printk("night mode 60hz\n");
 
 			#ifdef CLK24M_48M
 
@@ -1423,7 +1423,7 @@ void SP2518_set_night_mode(struct sp2518_device *dev,enum  camera_night_mode_fli
 		{
 			i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
 			i2c_put_byte_add8_new(client,0x32,0x05);
-			printk("normal mode 50hz\r\n");	
+			printk("normal mode 50hz\n");	
 			#ifdef CLK24M_48M
 			//capture preview daylight 48M 50hz fix 9FPS maxgain  
 			i2c_put_byte_add8_new(client,0xfd,0x00);
@@ -1491,7 +1491,7 @@ void SP2518_set_night_mode(struct sp2518_device *dev,enum  camera_night_mode_fli
 		{
 			i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
 			i2c_put_byte_add8_new(client,0x32,0x05);
-			printk("normal mode 60hz\r\n");	
+			printk("normal mode 60hz\n");	
 			#ifdef CLK24M_48M
 			//capture preview daylight 48M 60Hz fix 9FPS maxgain   
 			i2c_put_byte_add8_new(client,0xfd,0x00);
@@ -1567,11 +1567,11 @@ void SP2518_set_param_banding(struct sp2518_device *dev,enum  camera_banding_fli
 	switch(banding) {
 	case CAM_BANDING_50HZ: 		
 		Antiflicker = DCAMERA_FLICKER_50HZ;
-		printk( " set_SP2518_anti_flicker  50hz \r\n" );
+		printk( " set_SP2518_anti_flicker  50hz\n" );
 		break;
 	case CAM_BANDING_60HZ:
 		Antiflicker = DCAMERA_FLICKER_60HZ;
-		printk( " set_SP2518_anti_flicker  60hz \r\n" );
+		printk( " set_SP2518_anti_flicker  60hz\n" );
 		break;
 	default:
 		break;
diff --git a/drivers/amlogic/deinterlace/deinterlace.c b/drivers/amlogic/deinterlace/deinterlace.c
index 5fed4b94b57f..a106629239ee 100755
--- a/drivers/amlogic/deinterlace/deinterlace.c
+++ b/drivers/amlogic/deinterlace/deinterlace.c
@@ -2897,7 +2897,7 @@ static void log_buffer_state(unsigned char* tag)
 			  		buf_state_log_start = 1;
 				}
 				if(buf_state_log_start){
-	        di_print("[%s]i %d, i_f %d/%d, l_f %d/%d, pre_r %d, post_f %d/%d, post_r (%d:%d), disp (%d:%d),rec %d, di_i %d, di_w %d\r\n",
+	        di_print("[%s]i %d, i_f %d/%d, l_f %d/%d, pre_r %d, post_f %d/%d, post_r (%d:%d), disp (%d:%d),rec %d, di_i %d, di_w %d\n",
 	            tag,
 	            provider_vframe_level,
 	            in_free,MAX_IN_BUF_NUM,
diff --git a/drivers/amlogic/display/aml_logo/logo_display/logo_output.c b/drivers/amlogic/display/aml_logo/logo_display/logo_output.c
index bf16219a58cb..b22bbf5d95b3 100755
--- a/drivers/amlogic/display/aml_logo/logo_display/logo_output.c
+++ b/drivers/amlogic/display/aml_logo/logo_display/logo_output.c
@@ -62,7 +62,7 @@ static  output_dev_list_t aml_output_dev[LOGO_DEV_MAX];
 #endif
 			if(res)
 			{
-				amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"resource: start=0x%x,end=0x%x\r\n",res->start,res->end);
+				amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"resource: start=0x%x,end=0x%x\n",res->start,res->end);
 				logo->platform_res[i].mem_start=res->start;
 				logo->platform_res[i].mem_end=res->end;
 			}else{
diff --git a/drivers/amlogic/display/ge2d/ge2d_main.c b/drivers/amlogic/display/ge2d/ge2d_main.c
index 034767aeb88b..5500d3dfd484 100755
--- a/drivers/amlogic/display/ge2d/ge2d_main.c
+++ b/drivers/amlogic/display/ge2d/ge2d_main.c
@@ -35,7 +35,7 @@ ge2d_open(struct inode *inode, struct file *file)
          //       switch_mod_gate_by_name("ge2d", 1);
 	 if(NULL==(context=create_ge2d_work_queue()))
 	 {
-	 	amlog_level(LOG_LEVEL_HIGH,"can't create work queue \r\n");
+	 	amlog_level(LOG_LEVEL_HIGH,"can't create work queue\n");
 		return -1;		
 	 }
 	 //amlog_level(LOG_LEVEL_LOW,"open one ge2d device\n");
@@ -90,7 +90,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
 		ge2dgen_src_key(context , ge2d_config.src_key.key_enable,ge2d_config.src_key.key_color, ge2d_config.src_key.key_mask,ge2d_config.src_key.key_mode);  //RGBA MODE		
 		break;
 		case GE2D_FILLRECTANGLE:
-		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"fill rect...,x=%d,y=%d,w=%d,h=%d,color=0x%x\r\n",
+		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"fill rect...,x=%d,y=%d,w=%d,h=%d,color=0x%x\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.color);
@@ -101,7 +101,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
                      para.color) ;	
 		break;
 		case GE2D_FILLRECTANGLE_NOBLOCK:
-		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"fill rect...,x=%d,y=%d,w=%d,h=%d,color=0x%x,noblk\r\n",
+		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"fill rect...,x=%d,y=%d,w=%d,h=%d,color=0x%x,noblk\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.color);
@@ -113,7 +113,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
 		break;
 		case GE2D_STRETCHBLIT:
 		//stretch blit
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\r\n",
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.w, para.dst_rect.h);
@@ -124,7 +124,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
 		break;
 		case GE2D_STRETCHBLIT_NOBLOCK:
 		//stretch blit
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d,noblk\r\n",
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d,noblk\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.w, para.dst_rect.h);
@@ -135,7 +135,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
 		break;
 		case GE2D_BLIT:
 		//bitblt
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit...\r\n");
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit...\n");
 
             	bitblt(context ,
                    para.src1_rect.x, para.src1_rect.y,
@@ -144,7 +144,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
            	break;
 		case GE2D_BLIT_NOBLOCK:
 		//bitblt
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit...,noblk\r\n");
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit...,noblk\n");
 
             	bitblt_noblk(context ,
                    para.src1_rect.x, para.src1_rect.y,
@@ -152,7 +152,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
                    para.dst_rect.x, para.dst_rect.y);
            	break;	
 		case GE2D_BLEND:
-		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blend ...\r\n");
+		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blend ...\n");
 		blend(context,
             		para.src1_rect.x, para.src1_rect.y,
             		para.src1_rect.w, para.src1_rect.h,
@@ -163,7 +163,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
            		para.op) ;	
 		break;
 		case GE2D_BLEND_NOBLOCK:
-		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blend ...,noblk\r\n");
+		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blend ...,noblk\n");
 		blend_noblk(context,
             		para.src1_rect.x, para.src1_rect.y,
             		para.src1_rect.w, para.src1_rect.h,
@@ -175,7 +175,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
 		break;
 		case GE2D_BLIT_NOALPHA:
 		//bitblt_noalpha
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit_noalpha...\r\n");
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit_noalpha...\n");
             	bitblt_noalpha(context ,
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
@@ -183,7 +183,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
 		break;
 		case GE2D_BLIT_NOALPHA_NOBLOCK:
 		//bitblt_noalpha
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit_noalpha...,noblk\r\n");
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit_noalpha...,noblk\n");
             	bitblt_noalpha_noblk(context ,
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
@@ -191,7 +191,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
 		break;
 		case GE2D_STRETCHBLIT_NOALPHA:
 		//stretch blit
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt_noalpha...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\r\n",
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt_noalpha...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.w, para.dst_rect.h);
@@ -202,7 +202,7 @@ ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
 		break;
 		case GE2D_STRETCHBLIT_NOALPHA_NOBLOCK:
 		//stretch blit
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt_noalpha...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d,noblk\r\n",
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt_noalpha...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d,noblk\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.w, para.dst_rect.h);
@@ -245,16 +245,16 @@ init_ge2d_device(void)
 	ret=register_chrdev(0,ge2d_device.name,&ge2d_fops);
 	if(ret <=0) 
 	{
-		amlog_level(LOG_LEVEL_HIGH,"register ge2d device error\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"register ge2d device error\n");
 		return  ret ;
 	}
 	ge2d_device.major=ret;
 	ge2d_device.dbg_enable=0;
-	amlog_level(LOG_LEVEL_LOW,"ge2d_dev major:%d\r\n",ret);
+	amlog_level(LOG_LEVEL_LOW,"ge2d_dev major:%d\n",ret);
 	ret = class_register(&ge2d_class);
 	if(ret<0 )
 	{
-		amlog_level(LOG_LEVEL_HIGH,"error create ge2d class\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"error create ge2d class\n");
 		return ret;
 	}
 	ge2d_device.cla=&ge2d_class ;
diff --git a/drivers/amlogic/display/ge2d/ge2d_wq.c b/drivers/amlogic/display/ge2d/ge2d_wq.c
index 1d7a4984f272..f3204109b71c 100755
--- a/drivers/amlogic/display/ge2d/ge2d_wq.c
+++ b/drivers/amlogic/display/ge2d/ge2d_wq.c
@@ -76,7 +76,7 @@ static int ge2d_process_work_queue(ge2d_context_t *  wq)
 			if(pitem)
 				pitem->config.update_flag=UPDATE_ALL;
 			else {
-				amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_HIGH,"can't get pitem\r\n");	
+				amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_HIGH,"can't get pitem\n");	
 				ret=-1;
 				goto  exit;
 			}
@@ -212,16 +212,16 @@ int ge2d_wq_add_work(ge2d_context_t *wq)
 
 	ge2d_queue_item_t  *pitem ;
     
-     	amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"add new work @@%s:%d\r\n",__func__,__LINE__)	; 
+     	amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"add new work @@%s:%d\n",__func__,__LINE__)	; 
  	if(work_queue_no_space(wq))
  	{
- 		amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"work queue no space\r\n");
+ 		amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"work queue no space\n");
 		//we should wait for queue empty at this point.
 		while(work_queue_no_space(wq))
 		{
 			interruptible_sleep_on_timeout(&ge2d_manager.event.cmd_complete, 3);
 		}
-		amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"got free space\r\n");
+		amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"got free space\n");
 	}
 
       pitem=list_entry(wq->free_queue.next,ge2d_queue_item_t,list); 
@@ -236,7 +236,7 @@ int ge2d_wq_add_work(ge2d_context_t *wq)
 	spin_lock(&wq->lock);
 	list_move_tail(&pitem->list,&wq->work_queue);
 	spin_unlock(&wq->lock);
-	amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"add new work ok\r\n"); 
+	amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"add new work ok\n"); 
 	if(ge2d_manager.event.cmd_in_sem.count == 0 )//only read not need lock
 	up(&ge2d_manager.event.cmd_in_sem) ;//new cmd come in	
 	//add block mode   if()
@@ -278,7 +278,7 @@ static int ge2d_monitor_thread(void *data)
 	ge2d_manager_t*  manager = (  ge2d_manager_t*)data ;
         int ret;
 	
- 	amlog_level(LOG_LEVEL_HIGH,"ge2d workqueue monitor start\r\n");
+ 	amlog_level(LOG_LEVEL_HIGH,"ge2d workqueue monitor start\n");
 	//setup current_wq here.
 	while(ge2d_manager.process_queue_state!=GE2D_PROCESS_QUEUE_STOP)
 	{
@@ -293,14 +293,14 @@ static int ge2d_monitor_thread(void *data)
 		switch_mod_gate_by_name("ge2d", 0);
 		//CLK_GATE_OFF(GE2D);
 	}
-	amlog_level(LOG_LEVEL_HIGH,"exit ge2d_monitor_thread\r\n");
+	amlog_level(LOG_LEVEL_HIGH,"exit ge2d_monitor_thread\n");
 	return 0;
 }
 static  int ge2d_start_monitor(void )
 {
 	int ret =0;
 	
-	amlog_level(LOG_LEVEL_HIGH,"ge2d start monitor\r\n");
+	amlog_level(LOG_LEVEL_HIGH,"ge2d start monitor\n");
 	ge2d_manager.process_queue_state=GE2D_PROCESS_QUEUE_START;
 	ge2d_manager.ge2d_thread=kthread_run(ge2d_monitor_thread,&ge2d_manager,"ge2d_monitor");
 	if (IS_ERR(ge2d_manager.ge2d_thread)) {
@@ -502,7 +502,7 @@ int   ge2d_context_config(ge2d_context_t *context, config_para_t *ge2d_config)
 	src_dst_para_t  src,dst,tmp;
 	int type=ge2d_config->src_dst_type;
 		
-	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW," ge2d init\r\n");
+	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW," ge2d init\n");
 	//setup src and dst  
 	switch (type)
 	{
@@ -533,7 +533,7 @@ int   ge2d_context_config(ge2d_context_t *context, config_para_t *ge2d_config)
 		default:
 		break;
 	}
-	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"OSD ge2d type %d\r\n",type);
+	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"OSD ge2d type %d\n",type);
 	switch (type)
 	{
 		case  OSD0_OSD0:
@@ -562,11 +562,11 @@ int   ge2d_context_config(ge2d_context_t *context, config_para_t *ge2d_config)
 	}
 	if(src.bpp < 16 || dst.bpp < 16 )
 	{
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"src dst bpp type, src=%d,dst=%d \r\n",src.bpp,dst.bpp);
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"src dst bpp type, src=%d,dst=%d\n",src.bpp,dst.bpp);
 	}
 	
 	//next will config regs
-	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d xres %d yres %d : dst xres %d yres %d\n,src_format:0x%x,dst_format:0x%x\r\n",src.xres,src.yres,
+	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d xres %d yres %d : dst xres %d yres %d\n,src_format:0x%x,dst_format:0x%x\n",src.xres,src.yres,
 	dst.xres,dst.yres,src.ge2d_color_index, dst.ge2d_color_index);
 	
 	ge2dgen_src(context,src.canvas_index, src.ge2d_color_index);
@@ -637,23 +637,23 @@ int ge2d_context_config_ex(ge2d_context_t *context, config_para_ex_t *ge2d_confi
 		ge2d_config->src_para.canvas_index = tmp.canvas_index;
 		ge2d_config->src_para.format = tmp.ge2d_color_index;
 
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src1-->type: osd%d, format: 0x%x !!\r\n",ge2d_config->src_para.mem_type - CANVAS_OSD0, ge2d_config->src_para.format);
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src1-->type: osd%d, format: 0x%x !!\n",ge2d_config->src_para.mem_type - CANVAS_OSD0, ge2d_config->src_para.format);
 
 		if((ge2d_config->src_para.left+ge2d_config->src_para.width>tmp.xres)||(ge2d_config->src_para.top+ge2d_config->src_para.height>tmp.yres)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src1-->type: osd%d,  out of range \r\n",ge2d_config->src_para.mem_type - CANVAS_OSD0);
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src1-->type: osd%d,  out of range\n",ge2d_config->src_para.mem_type - CANVAS_OSD0);
 			return -1;
 		}
 		break;
 	case  CANVAS_ALLOC:
 		if((ge2d_config->src_para.left+ge2d_config->src_para.width>ge2d_config->src_planes[0].w)
 		    ||(ge2d_config->src_para.top+ge2d_config->src_para.height>ge2d_config->src_planes[0].h)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src1-->type: alloc,  out of range \r\n");
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src1-->type: alloc,  out of range\n");
 			return -1;
 		}
 		if(build_ge2d_config_ex(&ge2d_config->src_planes[0], ge2d_config->src_para.format, &index,ALLOC_CANVAS_INDEX+alloc_canvas_offset,&alloc_canvas_offset)<0)
 			return -1;
 		ge2d_config->src_para.canvas_index = index;
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src1--> type: alloc, canvas index : 0x%x,format :0x%x \r\n", index,ge2d_config->src_para.format);
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src1--> type: alloc, canvas index : 0x%x,format :0x%x\n", index,ge2d_config->src_para.format);
 	default:
 		break;
 	}
@@ -666,17 +666,17 @@ int ge2d_context_config_ex(ge2d_context_t *context, config_para_ex_t *ge2d_confi
 		ge2d_config->src2_para.canvas_index = tmp.canvas_index;
 		ge2d_config->src2_para.format = tmp.ge2d_color_index;
 
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src2-->type: osd%d, format: 0x%x !!\r\n",ge2d_config->src2_para.mem_type - CANVAS_OSD0, ge2d_config->src2_para.format);
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src2-->type: osd%d, format: 0x%x !!\n",ge2d_config->src2_para.mem_type - CANVAS_OSD0, ge2d_config->src2_para.format);
 
 		if((ge2d_config->src2_para.left+ge2d_config->src2_para.width>tmp.xres)||(ge2d_config->src2_para.top+ge2d_config->src2_para.height>tmp.yres)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src2-->type: osd%d,  out of range \r\n",ge2d_config->src2_para.mem_type - CANVAS_OSD0);
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src2-->type: osd%d,  out of range\n",ge2d_config->src2_para.mem_type - CANVAS_OSD0);
 			return -1;
 		}
 		break;
 	case  CANVAS_ALLOC:
 		if((ge2d_config->src2_para.left+ge2d_config->src2_para.width>ge2d_config->src2_planes[0].w)
 		    ||(ge2d_config->src2_para.top+ge2d_config->src2_para.height>ge2d_config->src2_planes[0].h)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src2-->type: alloc,  out of range \r\n");
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src2-->type: alloc,  out of range\n");
 			return -1;
 		}
 		if(ge2d_config->src2_planes[0].addr == ge2d_config->src_planes[0].addr){
@@ -685,7 +685,7 @@ int ge2d_context_config_ex(ge2d_context_t *context, config_para_ex_t *ge2d_confi
 			return -1;
 		}
 		ge2d_config->src2_para.canvas_index = index;
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src2--> type: alloc, canvas index : 0x%x ,format :0x%x \r\n", index,ge2d_config->src2_para.format);
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src2--> type: alloc, canvas index : 0x%x ,format :0x%x\n", index,ge2d_config->src2_para.format);
 	default:
 		break;
 	}
@@ -698,17 +698,17 @@ int ge2d_context_config_ex(ge2d_context_t *context, config_para_ex_t *ge2d_confi
 		ge2d_config->dst_para.canvas_index = tmp.canvas_index;
 		ge2d_config->dst_para.format = tmp.ge2d_color_index;
 
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: dst-->type: osd%d, format: 0x%x !!\r\n",ge2d_config->dst_para.mem_type - CANVAS_OSD0, ge2d_config->dst_para.format);
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: dst-->type: osd%d, format: 0x%x !!\n",ge2d_config->dst_para.mem_type - CANVAS_OSD0, ge2d_config->dst_para.format);
 
 		if((ge2d_config->dst_para.left+ge2d_config->dst_para.width>tmp.xres)||(ge2d_config->dst_para.top+ge2d_config->dst_para.height>tmp.yres)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: dst-->type: osd%d,  out of range \r\n",ge2d_config->dst_para.mem_type - CANVAS_OSD0);
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: dst-->type: osd%d,  out of range\n",ge2d_config->dst_para.mem_type - CANVAS_OSD0);
 			return -1;
 		}
 		break;
 	case  CANVAS_ALLOC:
 		if((ge2d_config->dst_para.left+ge2d_config->dst_para.width>ge2d_config->dst_planes[0].w)
 		    ||(ge2d_config->dst_para.top+ge2d_config->dst_para.height>ge2d_config->dst_planes[0].h)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: dst-->type: alloc,  out of range \r\n");
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: dst-->type: alloc,  out of range\n");
 			return -1;
 		}
 		if(ge2d_config->dst_planes[0].addr == ge2d_config->src_planes[0].addr)
@@ -718,7 +718,7 @@ int ge2d_context_config_ex(ge2d_context_t *context, config_para_ex_t *ge2d_confi
 		else if(build_ge2d_config_ex(&ge2d_config->dst_planes[0], ge2d_config->dst_para.format, &index,ALLOC_CANVAS_INDEX+alloc_canvas_offset,&alloc_canvas_offset)<0)
 			return -1;
 		ge2d_config->dst_para.canvas_index = index;
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: dst--> type: alloc, canvas index : 0x%x  ,format :0x%x \r\n",index,ge2d_config->dst_para.format);
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: dst--> type: alloc, canvas index : 0x%x  ,format :0x%x\n",index,ge2d_config->dst_para.format);
 	default:
 		break;
 	}
@@ -814,7 +814,7 @@ ge2d_context_t* create_ge2d_work_queue(void)
 	ge2d_work_queue->config.v_scale_coef_type=FILTER_TYPE_BILINEAR;
 	if(IS_ERR(ge2d_work_queue))
 	{
-		amlog_level(LOG_LEVEL_HIGH,"can't create work queue\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"can't create work queue\n");
 		return NULL;
 	}
 	INIT_LIST_HEAD(&ge2d_work_queue->work_queue);
@@ -826,7 +826,7 @@ ge2d_context_t* create_ge2d_work_queue(void)
 		p_item=(ge2d_queue_item_t*)kcalloc(1,sizeof(ge2d_queue_item_t),GFP_KERNEL);
 		if(IS_ERR(p_item))
 		{
-			amlog_level(LOG_LEVEL_HIGH,"can't request queue item memory\r\n");
+			amlog_level(LOG_LEVEL_HIGH,"can't request queue item memory\n");
 			return NULL;
 		}
 		list_add_tail(&p_item->list, &ge2d_work_queue->free_queue) ;
@@ -891,11 +891,11 @@ int ge2d_wq_init(void)
    	ge2d_gen_t           ge2d_gen_cfg;
 	
 
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"enter %s line %d\r\n",__func__,__LINE__)	;    
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"enter %s line %d\n",__func__,__LINE__)	;    
 	
     	if ((ge2d_manager.irq_num=request_irq(INT_GE2D, ge2d_wq_handle , IRQF_SHARED,"ge2d irq", (void *)&ge2d_manager))<0)
    	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"ge2d request irq error\r\n")	;
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"ge2d request irq error\n")	;
 		return -1;
 	}
 	//prepare bottom half		
@@ -916,7 +916,7 @@ int ge2d_wq_init(void)
     	ge2d_set_gen(&ge2d_gen_cfg);
 	if(ge2d_start_monitor())
  	{
- 		amlog_level(LOG_LEVEL_HIGH,"ge2d create thread error\r\n");	
+ 		amlog_level(LOG_LEVEL_HIGH,"ge2d create thread error\n");	
 		return -1;
  	}	
 	return 0;
@@ -926,7 +926,7 @@ int   ge2d_setup(void)
 	// do init work for ge2d.
 	if (ge2d_wq_init())
       	{
-      		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"ge2d work queue init error \r\n");	
+      		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"ge2d work queue init error\n");	
 		return -1;	
       	}
  	return  0;
@@ -935,7 +935,7 @@ EXPORT_SYMBOL(ge2d_setup);
 int   ge2d_deinit( void )
 {
 	ge2d_stop_monitor();
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"deinit ge2d device \r\n") ;
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"deinit ge2d device\n") ;
 	if (ge2d_manager.irq_num >= 0) {
       		free_irq(INT_GE2D,&ge2d_manager);
        	 ge2d_manager.irq_num= -1;
diff --git a/drivers/amlogic/display/osd/osd_hw.c b/drivers/amlogic/display/osd/osd_hw.c
index 60fa22e85b17..ea52d4803575 100755
--- a/drivers/amlogic/display/osd/osd_hw.c
+++ b/drivers/amlogic/display/osd/osd_hw.c
@@ -824,7 +824,7 @@ void  osd_set_colorkey_hw(u32 index,u32 color_index,u32 colorkey )
 	if( osd_hw.color_key[index]!=data32)
 	{
 		osd_hw.color_key[index]=data32;
-		amlog_mask_level(LOG_MASK_HARDWARE,LOG_LEVEL_LOW,"bpp:%d--r:0x%x g:0x%x b:0x%x ,a:0x%x\r\n",color_index,r,g,b,a);
+		amlog_mask_level(LOG_MASK_HARDWARE,LOG_LEVEL_LOW,"bpp:%d--r:0x%x g:0x%x b:0x%x ,a:0x%x\n",color_index,r,g,b,a);
 		add_to_update_list(index,OSD_COLOR_KEY);
 
 		osd_wait_vsync_hw();
@@ -1110,7 +1110,7 @@ void osd_free_scale_enable_hw(u32 index,u32 enable)
 			mode_changed = 1;
 #endif
 #endif
-		amlog_level(LOG_LEVEL_HIGH,"osd%d free scale %s\r\n",index,enable?"ENABLE":"DISABLE");
+		amlog_level(LOG_LEVEL_HIGH,"osd%d free scale %s\n",index,enable?"ENABLE":"DISABLE");
 		enable = (enable&0xffff?1:0);
 		osd_hw.free_scale_enable[index]=enable;
 		if (index==OSD1)
@@ -1428,7 +1428,7 @@ void osd_enable_hw(int enable ,int index )
 
 void osd_set_2x_scale_hw(u32 index,u16 h_scale_enable,u16 v_scale_enable)
 {
-	amlog_level(LOG_LEVEL_HIGH, "osd[%d] set scale, h_scale: %s, v_scale: %s\r\n",
+	amlog_level(LOG_LEVEL_HIGH, "osd[%d] set scale, h_scale: %s, v_scale: %s\n",
 			index, h_scale_enable ? "ENABLE" : "DISABLE", v_scale_enable ? "ENABLE" : "DISABLE");
 	amlog_level(LOG_LEVEL_HIGH, "osd[%d].scaledata: %d %d %d %d\n",
 			index,
@@ -2999,7 +2999,7 @@ void osd_init_hw(u32  logo_loaded)
 		IRQF_SHARED , "am_osd_vsync", osd_setup))
 #endif
 	{
-		amlog_level(LOG_LEVEL_HIGH,"can't request irq for vsync\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"can't request irq for vsync\n");
 	}
 
 #ifdef FIQ_VSYNC
@@ -3014,7 +3014,7 @@ void osd_init_hw(u32  logo_loaded)
 	if (request_irq(INT_RDMA, &osd_rdma_isr,
                     IRQF_SHARED, "osd_rdma", (void *)"osd_rdma"))
 	{
-		amlog_level(LOG_LEVEL_HIGH,"can't request irq for rdma\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"can't request irq for rdma\n");
 	}
 #endif
 	return ;
diff --git a/drivers/amlogic/display/osd/osd_main.c b/drivers/amlogic/display/osd/osd_main.c
index 96f0b7b04caf..0a88b0a5e459 100755
--- a/drivers/amlogic/display/osd/osd_main.c
+++ b/drivers/amlogic/display/osd/osd_main.c
@@ -113,7 +113,7 @@ _find_color_format(struct fb_var_screeninfo * var)
 	if((var->red.length==0)||(var->green.length==0)||(var->blue.length==0)||
 		var->bits_per_pixel != (var->red.length+var->green.length+var->blue.length+var->transp.length))
 	{
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"not provide color component length,use default color \n");
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"not provide color component length,use default color\n");
 		ret =&default_color_format_array[upper_margin];
 	}
 	else
@@ -159,7 +159,7 @@ osd_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	{
 		return -EFAULT ;
 	}
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"select color format :index%d,bpp %d\r\n",color_format_pt->color_index, \
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"select color format :index%d,bpp %d\n",color_format_pt->color_index, \
 												color_format_pt->bpp) ;
 	fbdev->color=color_format_pt;
 	var->red.offset = color_format_pt->red_offset;
@@ -183,10 +183,10 @@ osd_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	fix->visual=color_format_pt->color_type ;
 	//adjust memory length.	
  	fix->line_length = var->xres_virtual*var->bits_per_pixel/8;
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"xvirtual=%d,bpp:%d,kernel_line_length=%d\r\n",var->xres_virtual,var->bits_per_pixel,fix->line_length);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"xvirtual=%d,bpp:%d,kernel_line_length=%d\n",var->xres_virtual,var->bits_per_pixel,fix->line_length);
 	if(var->xres_virtual*var->yres_virtual*var->bits_per_pixel/8> fbdev->fb_len )
 	{
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"no enough memory for %d*%d*%d\r\n",var->xres,var->yres,var->bits_per_pixel);
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"no enough memory for %d*%d*%d\n",var->xres,var->yres,var->bits_per_pixel);
 		return  -ENOMEM;
 	}
 	if (var->xres_virtual < var->xres)
@@ -339,7 +339,7 @@ osd_ioctl(struct fb_info *info, unsigned int cmd,
 			ret=copy_from_user(&osd_dst_axis, argp, 4 * sizeof(s32));
 			break;
 		default :
-			amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_HIGH,"command not supported\r\n ");
+			amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_HIGH,"command not supported\n ");
 			return -1;
 	}
 	mutex_lock(&fbdev->lock);
@@ -394,7 +394,7 @@ osd_ioctl(struct fb_info *info, unsigned int cmd,
 			case COLOR_INDEX_24_888_B:
 			case COLOR_INDEX_24_RGB:
 			case COLOR_INDEX_YUV_422:
-	  	   	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"set osd color key 0x%x\r\n",src_colorkey);
+	  	   	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"set osd color key 0x%x\n",src_colorkey);
             fbdev->color_key = src_colorkey;
 	  	 	osddev_set_colorkey(info->node,fbdev->color->color_index,src_colorkey);
 			break;
@@ -410,7 +410,7 @@ osd_ioctl(struct fb_info *info, unsigned int cmd,
 			case COLOR_INDEX_24_888_B:
 			case COLOR_INDEX_24_RGB:
 			case COLOR_INDEX_YUV_422:	
-			amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"set osd color key %s\r\n",srckey_enable?"enable":"disable");
+			amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"set osd color key %s\n",srckey_enable?"enable":"disable");
 			if (srckey_enable != 0) {
 				fbdev->enable_key_flag |= KEYCOLOR_FLAG_TARGET;
 				if (!(fbdev->enable_key_flag & KEYCOLOR_FLAG_ONHOLD)) {
@@ -506,7 +506,7 @@ static int osd_pan_display(struct fb_var_screeninfo *var,
                         struct fb_info *fbi)
 {
 	osddev_pan_display(var,fbi);
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd_pan_display:=>osd%d\r\n",fbi->node);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd_pan_display:=>osd%d\n",fbi->node);
 	return 0;
 }
 
@@ -587,12 +587,12 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd , void *
 	disp_rect_t  *disp_rect;
 	
 	vinfo = get_current_vinfo();
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"tv_server:vmode=%s\r\n", vinfo->name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"tv_server:vmode=%s\n", vinfo->name);
 	
 	switch(cmd)
 	{
 		case  VOUT_EVENT_MODE_CHANGE:
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"recevie change mode  message \r\n");
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"recevie change mode  message\n");
 		for(i=0;i<OSD_COUNT;i++)
 		{
 			if(NULL==(fb_dev=gp_fbdev_list[i])) continue;
@@ -624,7 +624,7 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd , void *
 			if(fb_dev->preblend_enable) break;  //if osd layer preblend ,it's position is controled by vpp.
 			fb_dev->osd_ctl.disp_start_x=disp_rect->x  ;
 			fb_dev->osd_ctl.disp_start_y=disp_rect->y  ;
-			amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"set disp axis: x:%d y:%d w:%d h:%d\r\n"  , \
+			amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"set disp axis: x:%d y:%d w:%d h:%d\n"  , \
 					disp_rect->x, disp_rect->y,\
 					disp_rect->w, disp_rect->h );
 			if(disp_rect->x+disp_rect->w > vinfo->width)
@@ -644,7 +644,7 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd , void *
 				fb_dev->osd_ctl.disp_end_y=fb_dev->osd_ctl.disp_start_y + disp_rect->h - 1 ;
 			}
 			disp_rect ++;
-			amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"new disp axis: startx:%d starty:%d endx:%d endy:%d\r\n"  , \
+			amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"new disp axis: startx:%d starty:%d endx:%d endy:%d\n"  , \
 					fb_dev->osd_ctl.disp_start_x, fb_dev->osd_ctl.disp_start_y,\
 					fb_dev->osd_ctl.disp_end_x,fb_dev->osd_ctl.disp_end_y);
 			console_lock();
@@ -1657,7 +1657,7 @@ osd_probe(struct platform_device *pdev)
 
 		if(prop_idx == 3){
 			if(get_current_mode_state() == VMODE_SETTED){
-				amlog_level(LOG_LEVEL_HIGH,"vmode has setted in aml logo module\r\n");
+				amlog_level(LOG_LEVEL_HIGH,"vmode has setted in aml logo module\n");
 			}else{
 				DisableVideoLayer();
 				#ifdef CONFIG_AM_HDMI_ONLY
@@ -1761,7 +1761,7 @@ osd_probe(struct platform_device *pdev)
 			mydef_var[index].yres_virtual=init_logo_obj->dev->vinfo->height<<1;//logo always use double buffer
 			mydef_var[index].bits_per_pixel=bpp;
 			
-			amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\r\n",mydef_var[index].bits_per_pixel);
+			amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\n",mydef_var[index].bits_per_pixel);
 			if(mydef_var[index].bits_per_pixel>32){
 				mydef_var[index].bits_per_pixel=32;
 			}
@@ -1779,14 +1779,14 @@ osd_probe(struct platform_device *pdev)
 					mydef_var[index].yres_virtual=var_screeninfo[3];//logo always use double buffer
 					mydef_var[index].bits_per_pixel=bpp;
 				
-					amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\r\n",mydef_var[index].bits_per_pixel);
+					amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\n",mydef_var[index].bits_per_pixel);
 					if(mydef_var[index].bits_per_pixel>32) 
 					{
 						mydef_var[index].bits_per_pixel=32;
 					}
 				}
 			}
-			amlog_level(LOG_LEVEL_HIGH,"---------------clear framebuffer%d memory  \r\n",index);
+			amlog_level(LOG_LEVEL_HIGH,"---------------clear framebuffer%d memory\n",index);
 			memset((char*)fbdev->fb_mem_vaddr, 0x00, fbdev->fb_len);
 		}
 
@@ -1868,7 +1868,7 @@ osd_probe(struct platform_device *pdev)
 	}else{
 		osddev_set_osd_reverse(osd_info.index, osd_info.osd_reverse);
 	}
-	amlog_level(LOG_LEVEL_HIGH,"osd probe ok  \r\n");
+	amlog_level(LOG_LEVEL_HIGH,"osd probe ok\n");
 	return 0;
 
 failed2:
diff --git a/drivers/amlogic/display/osd_ext/osd_hw.c b/drivers/amlogic/display/osd_ext/osd_hw.c
index 85bbe4b250be..06992eac8ec4 100755
--- a/drivers/amlogic/display/osd_ext/osd_hw.c
+++ b/drivers/amlogic/display/osd_ext/osd_hw.c
@@ -591,7 +591,7 @@ void osd_ext_set_colorkey_hw(u32 index, u32 color_index, u32 colorkey)
 	data32 = r << 24 | g << 16 | b << 8 | a;
 	if (osd_ext_hw.color_key[index] != data32) {
 		osd_ext_hw.color_key[index] = data32;
-		amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW, "bpp:%d--r:0x%x g:0x%x b:0x%x ,a:0x%x\r\n",
+		amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW, "bpp:%d--r:0x%x g:0x%x b:0x%x ,a:0x%x\n",
 				 color_index, r, g, b, a);
 		add_to_update_list(index, OSD_COLOR_KEY);
 
@@ -848,7 +848,7 @@ void osd_ext_free_scale_enable_hw(u32 index, u32 enable)
 #endif
 #endif
 
-	amlog_level(LOG_LEVEL_HIGH, "osd%d free scale %s\r\n", index, enable ? "ENABLE" : "DISABLE");
+	amlog_level(LOG_LEVEL_HIGH, "osd%d free scale %s\n", index, enable ? "ENABLE" : "DISABLE");
 	osd_ext_hw.free_scale_enable[index] = enable;
 	if (index == OSD1) {
 		if (enable) {
@@ -1069,7 +1069,7 @@ void osd_ext_set_block_mode_hw(u32 index, u32 mode)
 
 void osd_ext_set_2x_scale_hw(u32 index, u16 h_scale_enable, u16 v_scale_enable)
 {
-	amlog_level(LOG_LEVEL_HIGH, "osd[%d] set scale, h_scale: %s, v_scale: %s\r\n",
+	amlog_level(LOG_LEVEL_HIGH, "osd[%d] set scale, h_scale: %s, v_scale: %s\n",
 		    index, h_scale_enable ? "ENABLE" : "DISABLE", v_scale_enable ? "ENABLE" : "DISABLE");
 	amlog_level(LOG_LEVEL_HIGH, "osd[%d].scaledata: %d %d %d %d\n",
 		    index,
@@ -2284,7 +2284,7 @@ void osd_ext_init_hw(u32 logo_loaded)
 	if (request_irq(INT_VIU2_VSYNC, &vsync_isr, IRQF_SHARED, "am_osd_ext_vsync", osd_ext_setup))
 #endif
 	{
-		amlog_level(LOG_LEVEL_HIGH, "can't request irq for vsync\r\n");
+		amlog_level(LOG_LEVEL_HIGH, "can't request irq for vsync\n");
 	}
 #ifdef FIQ_VSYNC
 	request_fiq(INT_VIU2_VSYNC, &osd_ext_fiq_isr);
diff --git a/drivers/amlogic/display/osd_ext/osd_main.c b/drivers/amlogic/display/osd_ext/osd_main.c
index d29ef889404c..ef76ef632d2c 100755
--- a/drivers/amlogic/display/osd_ext/osd_main.c
+++ b/drivers/amlogic/display/osd_ext/osd_main.c
@@ -101,7 +101,7 @@ _find_color_format(struct fb_var_screeninfo * var)
 	//if not provide color component length then we find the first depth match.
 	if ((var->red.length == 0) || (var->green.length == 0) || (var->blue.length == 0) ||
 	    var->bits_per_pixel != (var->red.length + var->green.length + var->blue.length + var->transp.length)) {
-		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "not provide color component length,use default color \n");
+		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "not provide color component length,use default color\n");
 		ret = &default_color_format_array[upper_margin];
 	} else {
 		for (i = upper_margin; i >= lower_margin; i--) {
@@ -142,7 +142,7 @@ osd_ext_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	if (color_format_pt == NULL || color_format_pt->color_index == 0) {
 		return -EFAULT ;
 	}
-	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "select color format :index%d,bpp %d\r\n", color_format_pt->color_index, \
+	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "select color format :index%d,bpp %d\n", color_format_pt->color_index, \
 	                 color_format_pt->bpp) ;
 	fbdev->color = color_format_pt ;
 	var->red.offset = color_format_pt->red_offset;
@@ -168,7 +168,7 @@ osd_ext_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	//adjust memory length.
 	fix->line_length = var->xres_virtual * var->bits_per_pixel / 8;
 	if (var->xres_virtual * var->yres_virtual * var->bits_per_pixel / 8 > fbdev->fb_len) {
-		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_HIGH, "no enough memory for %d*%d*%d\r\n", var->xres, var->yres, var->bits_per_pixel);
+		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_HIGH, "no enough memory for %d*%d*%d\n", var->xres, var->yres, var->bits_per_pixel);
 		return  -ENOMEM;
 	}
 	if (var->xres_virtual < var->xres) {
@@ -318,7 +318,7 @@ osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 		ret=copy_from_user(&osd_ext_dst_axis, argp, 4 * sizeof(s32));
 		break;
 	default :
-		amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_HIGH, "command not supported\r\n ");
+		amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_HIGH, "command not supported\n ");
 		return -1;
 	}
 	mutex_lock(&fbdev->lock);
@@ -363,7 +363,7 @@ osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 		case COLOR_INDEX_24_888_B:
 		case COLOR_INDEX_24_RGB:
 		case COLOR_INDEX_YUV_422:
-			amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_LOW, "set osd color key 0x%x\r\n", src_colorkey);
+			amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_LOW, "set osd color key 0x%x\n", src_colorkey);
 			fbdev->color_key = src_colorkey;
 			osddev_ext_set_colorkey(info->node, fbdev->color->color_index, src_colorkey);
 			break;
@@ -379,7 +379,7 @@ osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 		case COLOR_INDEX_24_888_B:
 		case COLOR_INDEX_24_RGB:
 		case COLOR_INDEX_YUV_422:
-			amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_LOW, "set osd color key %s\r\n", srckey_enable ? "enable" : "disable");
+			amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_LOW, "set osd color key %s\n", srckey_enable ? "enable" : "disable");
 			if (srckey_enable != 0) {
 				fbdev->enable_key_flag |= KEYCOLOR_FLAG_TARGET;
 				if (!(fbdev->enable_key_flag & KEYCOLOR_FLAG_ONHOLD)) {
@@ -476,7 +476,7 @@ static int osd_ext_pan_display(struct fb_var_screeninfo *var,
 {
 
 	osddev_ext_pan_display(var, fbi);
-	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "osd_ext_pan_display:=>osd%d\r\n", fbi->node);
+	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "osd_ext_pan_display:=>osd%d\n", fbi->node);
 	return 0;
 }
 
@@ -550,7 +550,7 @@ int osd_ext_notify_callback(struct notifier_block *block, unsigned long cmd , vo
 	disp_rect_t *disp_rect;
 
 	vinfo = get_current_vinfo2();
-	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "tv_server:vmode=%s\r\n", vinfo->name);
+	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "tv_server:vmode=%s\n", vinfo->name);
 
 	if(vinfo->mode == VMODE_INIT_NULL){
 		return 1;
@@ -558,7 +558,7 @@ int osd_ext_notify_callback(struct notifier_block *block, unsigned long cmd , vo
 
 	switch (cmd) {
 	case  VOUT_EVENT_MODE_CHANGE:
-		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "recevie change mode  message \r\n");
+		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "recevie change mode  message\n");
 		for (i = 0; i < OSD_COUNT; i++) {
 			if (NULL == (fb_dev = gp_fbdev_list[i])) {
 				continue;
@@ -594,7 +594,7 @@ int osd_ext_notify_callback(struct notifier_block *block, unsigned long cmd , vo
 			}
 			fb_dev->osd_ext_ctl.disp_start_x = disp_rect->x  ;
 			fb_dev->osd_ext_ctl.disp_start_y = disp_rect->y  ;
-			amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "set disp axis: x:%d y:%d w:%d h:%d\r\n"  , \
+			amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "set disp axis: x:%d y:%d w:%d h:%d\n"  , \
 			                 disp_rect->x, disp_rect->y, \
 			                 disp_rect->w, disp_rect->h);
 			if (disp_rect->x + disp_rect->w > vinfo->width) {
@@ -608,7 +608,7 @@ int osd_ext_notify_callback(struct notifier_block *block, unsigned long cmd , vo
 				fb_dev->osd_ext_ctl.disp_end_y = fb_dev->osd_ext_ctl.disp_start_y + disp_rect->h - 1 ;
 			}
 			disp_rect ++;
-			amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "new disp axis: startx:%d starty:%d endx:%d endy:%d\r\n"  , \
+			amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "new disp axis: startx:%d starty:%d endx:%d endy:%d\n"  , \
 			                 fb_dev->osd_ext_ctl.disp_start_x, fb_dev->osd_ext_ctl.disp_start_y, \
 			                 fb_dev->osd_ext_ctl.disp_end_x, fb_dev->osd_ext_ctl.disp_end_y);
 			console_lock();
@@ -1457,7 +1457,7 @@ osd_ext_probe(struct platform_device *pdev)
 			mydef_var[index].xres_virtual = init_logo_obj->dev->vinfo->width;
 			mydef_var[index].yres_virtual = init_logo_obj->dev->vinfo->height << 1; //logo always use double buffer
 			mydef_var[index].bits_per_pixel = bpp ;
-			amlog_level(LOG_LEVEL_HIGH, "init fbdev bpp is :%d\r\n", mydef_var[index].bits_per_pixel);
+			amlog_level(LOG_LEVEL_HIGH, "init fbdev bpp is :%d\n", mydef_var[index].bits_per_pixel);
 
 			if (mydef_var[index].bits_per_pixel > 32) {
 				mydef_var[index].bits_per_pixel = 32;
@@ -1476,7 +1476,7 @@ osd_ext_probe(struct platform_device *pdev)
 					mydef_var[index].yres_virtual=var_screeninfo[3];//logo always use double buffer
 					mydef_var[index].bits_per_pixel=bpp;
 
-					amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\r\n",mydef_var[index].bits_per_pixel);
+					amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\n",mydef_var[index].bits_per_pixel);
 					if(mydef_var[index].bits_per_pixel>32)
 					{
 						mydef_var[index].bits_per_pixel=32;
@@ -1484,7 +1484,7 @@ osd_ext_probe(struct platform_device *pdev)
 				}
 			}
 #if 0 //avoid clearing the mem of uboot osd1 logo
-			amlog_level(LOG_LEVEL_HIGH, "---------------clear framebuffer%d memory  \r\n", index + 2);
+			amlog_level(LOG_LEVEL_HIGH, "---------------clear framebuffer%d memory\n", index + 2);
 			memset((char*)fbdev->fb_mem_vaddr, 0x80, fbdev->fb_len);
 #endif
 		}
@@ -1543,7 +1543,7 @@ osd_ext_probe(struct platform_device *pdev)
 	register_early_suspend(&early_suspend);
 #endif
 
-	amlog_level(LOG_LEVEL_HIGH, "osd-ext probe ok  \r\n");
+	amlog_level(LOG_LEVEL_HIGH, "osd-ext probe ok\n");
 	return 0;
 
 failed2:
diff --git a/drivers/amlogic/display/vout/tvconf.c b/drivers/amlogic/display/vout/tvconf.c
index 8100df3602f0..0dd673f07497 100755
--- a/drivers/amlogic/display/vout/tvconf.c
+++ b/drivers/amlogic/display/vout/tvconf.c
@@ -579,7 +579,7 @@ static int  create_tv_attr(disp_module_info_t* info)
 	info->base_class=class_create(THIS_MODULE,info->name);
 	if(IS_ERR(info->base_class))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create tv display class fail\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create tv display class fail\n");
 		return  -1 ;
 	}
 	//create  class attr
@@ -587,7 +587,7 @@ static int  create_tv_attr(disp_module_info_t* info)
 	{
 		if ( class_create_file(info->base_class,tv_attr[i]))
 		{
-			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\r\n",tv_attr[i]->attr.name);
+			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\n",tv_attr[i]->attr.name);
 		}
 	}
 	sprintf(vdac_setting,"%x",get_current_vdac_setting());
@@ -602,7 +602,7 @@ static int __init tv_init_module(void)
 
 	if (!info)
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"can't alloc display info struct\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"can't alloc display info struct\n");
 		return -ENOMEM;
 	}
 	
@@ -612,19 +612,19 @@ static int __init tv_init_module(void)
 	ret=register_chrdev(0,info->name,&am_tv_fops);
 	if(ret <0) 
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register char dev tv error\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register char dev tv error\n");
 		return  ret ;
 	}
 	info->major=ret;
 	_init_vout();
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"major number %d for disp\r\n",ret);
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"major number %d for disp\n",ret);
 	if(vout_register_server(&tv_server))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server fail \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server fail\n");
 	}
 	else
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server ok \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server ok\n");
 	}
 	create_tv_attr(info);
 	return 0;
@@ -650,7 +650,7 @@ static __exit void tv_exit_module(void)
 	}
 	vout_unregister_server(&tv_server);
 	
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"exit tv module\r\n");
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"exit tv module\n");
 }
 
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
diff --git a/drivers/amlogic/display/vout/vdac_switch.c b/drivers/amlogic/display/vout/vdac_switch.c
index 8cf30afbcbf9..bbaa64892748 100755
--- a/drivers/amlogic/display/vout/vdac_switch.c
+++ b/drivers/amlogic/display/vout/vdac_switch.c
@@ -254,7 +254,7 @@ static int meson_vdac_switch_probe(struct platform_device *pdev)
     int val = 0;
     struct device_node *init_data;
 #endif
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vdac switch module \r\n");
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vdac switch module\n");
 #ifdef CONFIG_HAS_EARLYSUSPEND
     early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
     early_suspend.suspend = meson_vdac_switch_early_suspend;
diff --git a/drivers/amlogic/display/vout/vout_serve.c b/drivers/amlogic/display/vout/vout_serve.c
index 64098664ff24..7feb7a6b3521 100755
--- a/drivers/amlogic/display/vout/vout_serve.c
+++ b/drivers/amlogic/display/vout/vout_serve.c
@@ -138,7 +138,7 @@ static  void  set_vout_mode(char * name)
 {
 	vmode_t    mode;
 
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"tvmode set to %s\r\n",name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"tvmode set to %s\n",name);
 	mode=validate_vmode(name);
 	if(VMODE_MAX==mode)
 	{
@@ -147,11 +147,11 @@ static  void  set_vout_mode(char * name)
 	}
 	if(mode==get_current_vmode())
 	{
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"don't set the same mode as current.\r\n");	
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"don't set the same mode as current.\n");
 		return ;
 	}
 	set_current_vmode(mode);
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"new mode %s set ok\r\n",name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"new mode %s set ok\n",name);
 	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,&mode) ;
 	printk("%s[%d]\n", __func__, __LINE__);
 }
@@ -178,7 +178,7 @@ static void  set_vout_window(char *para)
 	{
 		disp_rect[1]=disp_rect[0] ;
 	}
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd0=>x:%d ,y:%d,w:%d,h:%d\r\n osd1=> x:%d,y:%d,w:%d,h:%d \r\n", \
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd0=>x:%d ,y:%d,w:%d,h:%d\n osd1=> x:%d,y:%d,w:%d,h:%d\n", \
 			*pt,*(pt+1),*(pt+2),*(pt+3),*(pt+4),*(pt+5),*(pt+6),*(pt+7));
 	vout_notifier_call_chain(VOUT_EVENT_OSD_DISP_AXIS,&disp_rect[0]) ;
 }
@@ -207,7 +207,7 @@ static int  create_vout_attr(void)
 	vout_info.base_class=class_create(THIS_MODULE,VOUT_CLASS_NAME);
 	if(IS_ERR(vout_info.base_class))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create vout class fail\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create vout class fail\n");
 		return  -1 ;
 	}
 	//create  class attr
@@ -215,7 +215,7 @@ static int  create_vout_attr(void)
 	{
 		if ( class_create_file(vout_info.base_class,vout_attr[i]))
 		{
-			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\r\n",vout_attr[i]->attr.name);
+			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\n",vout_attr[i]->attr.name);
 		}
 	}
 
@@ -299,7 +299,7 @@ static int
 	int ret =-1;
 	
 	vout_info.base_class=NULL;
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vout module \r\n");
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vout module\n");
 #ifdef CONFIG_HAS_EARLYSUSPEND
     early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
     early_suspend.suspend = meson_vout_early_suspend;
@@ -314,11 +314,11 @@ static int
 	ret =create_vout_attr();
 	if(ret==0)
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout attribute ok \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout attribute ok\n");
 	}
 	else
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout attribute fail \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout attribute fail\n");
 	}
 
 	return ret;
diff --git a/drivers/amlogic/display/vout2/tvconf2.c b/drivers/amlogic/display/vout2/tvconf2.c
index 95cc03b5cdb2..a711b9888423 100755
--- a/drivers/amlogic/display/vout2/tvconf2.c
+++ b/drivers/amlogic/display/vout2/tvconf2.c
@@ -370,7 +370,7 @@ static int  create_tv_attr(disp_module_info_t* info)
 	info->base_class=class_create(THIS_MODULE,info->name);
 	if(IS_ERR(info->base_class))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create tv display class fail\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create tv display class fail\n");
 		return  -1 ;
 	}
 	//create  class attr
@@ -378,7 +378,7 @@ static int  create_tv_attr(disp_module_info_t* info)
 	{
 		if ( class_create_file(info->base_class,tv_attr[i]))
 		{
-			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\r\n",tv_attr[i]->attr.name);
+			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\n",tv_attr[i]->attr.name);
 		}
 	}
 	sprintf(vdac_setting,"%x",get_current_vdac_setting2());
@@ -391,7 +391,7 @@ static int __init tv_init_module(void)
 	info=(disp_module_info_t*)kmalloc(sizeof(disp_module_info_t),GFP_KERNEL) ;
 	if (!info)
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"can't alloc display info struct\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"can't alloc display info struct\n");
 		return -ENOMEM;
 	}
 	
@@ -401,18 +401,18 @@ static int __init tv_init_module(void)
 	ret=register_chrdev(TV2_CONF_MAJOR,info->name,&am_tv_fops);
 	if(ret <0) 
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register char dev tv error\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register char dev tv error\n");
 		return  ret ;
 	}
 	info->major=TV2_CONF_MAJOR;
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"major number %d for disp\r\n",ret);
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"major number %d for disp\n",ret);
 	if(vout2_register_server(&tv_server))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server fail \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server fail\n");
 	}
 	else
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server ok \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server ok\n");
 	}
 	create_tv_attr(info);
 	return 0;
@@ -438,7 +438,7 @@ static __exit void tv_exit_module(void)
 	}
 	vout2_unregister_server(&tv_server);
 	
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"exit tv module\r\n");
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"exit tv module\n");
 }
 
 
diff --git a/drivers/amlogic/display/vout2/vout2_serve.c b/drivers/amlogic/display/vout2/vout2_serve.c
index 6b7b859f39cd..13c712381366 100755
--- a/drivers/amlogic/display/vout2/vout2_serve.c
+++ b/drivers/amlogic/display/vout2/vout2_serve.c
@@ -113,7 +113,7 @@ static  void  set_vout_mode(char * name)
 {
 	vmode_t    mode;
 
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"tvmode2 set to %s\r\n",name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"tvmode2 set to %s\n",name);
 	mode=validate_vmode2(name);
 	if(VMODE_MAX==mode)
 	{
@@ -122,11 +122,11 @@ static  void  set_vout_mode(char * name)
 	}
 	if(mode==get_current_vmode2())
 	{
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"don't set the same mode as current.\r\n");	
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"don't set the same mode as current.\n");	
 		return ;
 	}
 	set_current_vmode2(mode);
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"new mode2 %s set ok\r\n",name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"new mode2 %s set ok\n",name);
 	vout2_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,&mode) ;
 }
 
@@ -158,7 +158,7 @@ static void  set_vout_window(char *para)
 	{
 		disp_rect[1]=disp_rect[0] ;
 	}
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd0=>x:%d ,y:%d,w:%d,h:%d\r\n osd1=> x:%d,y:%d,w:%d,h:%d \r\n", \
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd0=>x:%d ,y:%d,w:%d,h:%d\n osd1=> x:%d,y:%d,w:%d,h:%d\n", \
 			*pt,*(pt+1),*(pt+2),*(pt+3),*(pt+4),*(pt+5),*(pt+6),*(pt+7));
 	vout2_notifier_call_chain(VOUT_EVENT_OSD_DISP_AXIS,&disp_rect[0]) ;
 }
@@ -179,7 +179,7 @@ static const char *venc_mux_help = {
 
 static ssize_t venc_mux_show(struct class *class, struct class_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%s\ncurrent venc_mux: %d\r\n", venc_mux_help, s_venc_mux);
+	return sprintf(buf, "%s\ncurrent venc_mux: %d\n", venc_mux_help, s_venc_mux);
 }
 
 static ssize_t venc_mux_store(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
@@ -233,7 +233,7 @@ static int  create_vout_attr(void)
 	vout_info.base_class=class_create(THIS_MODULE,VOUT_CLASS_NAME);
 	if(IS_ERR(vout_info.base_class))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create vout2 class fail\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create vout2 class fail\n");
 		return  -1 ;
 	}
 	//create  class attr
@@ -241,11 +241,11 @@ static int  create_vout_attr(void)
 	{
 		if ( class_create_file(vout_info.base_class,vout_attr[i]))
 		{
-			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp2 attribute %s fail\r\n",vout_attr[i]->attr.name);
+			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp2 attribute %s fail\n",vout_attr[i]->attr.name);
 		}
 	}
 	if (class_create_file(vout_info.base_class, &class_attr_venc_mux))
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp2 attribute venc_mux fail\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp2 attribute venc_mux fail\n");
 
 	return   0;
 }
@@ -309,7 +309,7 @@ static int
 	int ret =-1;
 	
 	vout_info.base_class=NULL;
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vout2 module \r\n");
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vout2 module\n");
 #if 0 //def CONFIG_HAS_EARLYSUSPEND
     early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
     early_suspend.suspend = meson_vout_early_suspend;
@@ -322,11 +322,11 @@ static int
 	s_venc_mux = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL) & 0x3;
 	if(ret==0)
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout2 attribute ok \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout2 attribute ok\n");
 	}
 	else
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout2 attribute fail \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout2 attribute fail\n");
 	}
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
diff --git a/drivers/amlogic/dvb_tv/amldemod/aml_demod.c b/drivers/amlogic/dvb_tv/amldemod/aml_demod.c
index e04a27ef504e..21d73714e795 100755
--- a/drivers/amlogic/dvb_tv/amldemod/aml_demod.c
+++ b/drivers/amlogic/dvb_tv/amldemod/aml_demod.c
@@ -549,7 +549,7 @@ int aml_demod_ui_init(void)
 
 	r = class_register(&aml_demod_ui_class);
     if (r) {
-        printk("create aml_demod class fail\r\n");
+        printk("create aml_demod class fail\n");
         class_unregister(&aml_demod_ui_class);
 		return r;
     }
@@ -643,7 +643,7 @@ static int __init aml_demod_init(void)
     /* sysfs node creation */
     r = class_register(&aml_demod_class);
     if (r) {
-        printk("create aml_demod class fail\r\n");
+        printk("create aml_demod class fail\n");
         goto err1;
     }
 
diff --git a/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c b/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
index 3ab9668becfb..8dfaf306ca08 100755
--- a/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
+++ b/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
@@ -492,7 +492,7 @@ retry:
 	afe->params.u.qam.modulation = c->modulation;*/
 
 
-	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",c->frequency,c->symbol_rate);
+	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\n",c->frequency,c->symbol_rate);
 	return  0;
 
 }
@@ -519,7 +519,7 @@ static int M6_Demod_Dvbc_Init(struct aml_fe_dev *dev,int mode)
 {
 	struct aml_demod_sys sys;
 	struct aml_demod_i2c i2c;
-	pr_dbg("AML Demod DVB-C init\r\n");
+	pr_dbg("AML Demod DVB-C init\n");
 	memset(&sys, 0, sizeof(sys));
 	memset(&i2c, 0, sizeof(i2c));
 	i2c.tuner = dev->drv->id;
@@ -691,7 +691,7 @@ retry:
 	afe->params = *c;
 
 
-//	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",p->frequency,p->u.qam.symbol_rate);
+//	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\n",p->frequency,p->u.qam.symbol_rate);
 	return  0;
 
 }
@@ -713,7 +713,7 @@ int M6_Demod_Dvbt_Init(struct aml_fe_dev *dev)
 	struct aml_demod_sys sys;
 	struct aml_demod_i2c i2c;
 
-	pr_dbg("AML Demod DVB-T init\r\n");
+	pr_dbg("AML Demod DVB-T init\n");
 
 	memset(&sys, 0, sizeof(sys));
 	memset(&i2c, 0, sizeof(i2c));
@@ -883,7 +883,7 @@ retry:
 	aml_dmx_after_retune(AM_TS_SRC_TS2, fe);
 
 	afe->params = *c;
-//	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",p->frequency,p->u.qam.symbol_rate);
+//	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\n",p->frequency,p->u.qam.symbol_rate);
 	return  0;
 
 }
@@ -904,7 +904,7 @@ int M6_Demod_Atsc_Init(struct aml_fe_dev *dev)
 	struct aml_demod_sys sys;
 	struct aml_demod_i2c i2c;
 
-	pr_dbg("AML Demod ATSC init\r\n");
+	pr_dbg("AML Demod ATSC init\n");
 
 	memset(&sys, 0, sizeof(sys));
 	memset(&i2c, 0, sizeof(i2c));
@@ -1066,7 +1066,7 @@ static int m6_demod_dtmb_set_frontend(struct dvb_frontend *fe)
 	aml_dmx_after_retune(AM_TS_SRC_TS2, fe);*/
 
 	afe->params = *c;
-//	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",p->frequency,p->u.qam.symbol_rate);
+//	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\n",p->frequency,p->u.qam.symbol_rate);
 	return  0;
 
 }
@@ -1087,7 +1087,7 @@ int M6_Demod_Dtmb_Init(struct aml_fe_dev *dev)
 	struct aml_demod_sys sys;
 	struct aml_demod_i2c i2c;
 
-	pr_dbg("AML Demod DTMB init\r\n");
+	pr_dbg("AML Demod DTMB init\n");
 
 	memset(&sys, 0, sizeof(sys));
 	memset(&i2c, 0, sizeof(i2c));
@@ -1130,7 +1130,7 @@ static int m6_demod_fe_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
 	fe_ops->read_snr = m6_demod_dvbt_read_snr;
 	fe_ops->read_ucblocks = m6_demod_dvbt_read_ucblocks;
 
-	pr_dbg("=========================dvbt demod init\r\n");
+	pr_dbg("=========================dvbt demod init\n");
 	M6_Demod_Dvbt_Init(dev);
 	}
 	else if(mode == AM_FE_QAM){
@@ -1160,7 +1160,7 @@ static int m6_demod_fe_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
 
 //	init_waitqueue_head(&dev->lock_wq);
 	install_isr(dev);
-	pr_dbg("=========================dvbc demod init\r\n");
+	pr_dbg("=========================dvbc demod init\n");
 	M6_Demod_Dvbc_Init(dev,Adc_mode);
 	}else if(mode == AM_FE_ATSC){
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
index 2b90d14fd893..5221e0d083cd 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
@@ -472,7 +472,7 @@ static unsigned char is_dispmode_valid_for_hdmi(void)
 static ssize_t show_disp_mode(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int pos=0;
-    pos+=snprintf(buf+pos, PAGE_SIZE, "VIC:%d\r\n", hdmitx_device.cur_VIC);
+    pos+=snprintf(buf+pos, PAGE_SIZE, "VIC:%d\n", hdmitx_device.cur_VIC);
     return pos;
 }
 
@@ -504,7 +504,7 @@ static ssize_t store_cec(struct device * dev, struct device_attribute *attr, con
 static ssize_t show_cec_config(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int pos=0;
-    pos+=snprintf(buf+pos, PAGE_SIZE, "P_AO_DEBUG_REG0:0x%x\r\n", aml_read_reg32(P_AO_DEBUG_REG0));
+    pos+=snprintf(buf+pos, PAGE_SIZE, "P_AO_DEBUG_REG0:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG0));
     return pos;
 }
 
@@ -627,8 +627,8 @@ static ssize_t show_config(struct device * dev, struct device_attribute *attr, c
     default:
         aud_conf = "none";
     }
-    pos += snprintf(buf+pos, PAGE_SIZE, "disp switch (force or edid): %s\r\n", (hdmitx_device.disp_switch_config==DISP_SWITCH_FORCE)?"force":"edid");
-    pos += snprintf(buf+pos, PAGE_SIZE, "audio config: %s\r\n", aud_conf);
+    pos += snprintf(buf+pos, PAGE_SIZE, "disp switch (force or edid): %s\n", (hdmitx_device.disp_switch_config==DISP_SWITCH_FORCE)?"force":"edid");
+    pos += snprintf(buf+pos, PAGE_SIZE, "audio config: %s\n", aud_conf);
     return pos;
 }
 
@@ -776,7 +776,7 @@ static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *at
             }
         }
     }
-    pos += snprintf(buf+pos, PAGE_SIZE, "\r\n");
+    pos += snprintf(buf+pos, PAGE_SIZE, "\n");
 
     return pos;
 }
@@ -851,13 +851,13 @@ static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *
     for(i = 0;i < 5; i++) {
         pos+=snprintf(buf+pos, PAGE_SIZE, "%02x", aksv_buf[i]);
     }
-    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\r\n", hdcp_ksv_valid(aksv_buf) ? "Valid" : "Invalid");
+    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\n", hdcp_ksv_valid(aksv_buf) ? "Valid" : "Invalid");
 
     pos+=snprintf(buf+pos, PAGE_SIZE, "BKSV: ");
     for(i = 0;i < 5; i++) {
         pos+=snprintf(buf+pos, PAGE_SIZE, "%02x", bksv_buf[i]);
     }
-    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\r\n", hdcp_ksv_valid(bksv_buf) ? "Valid" : "Invalid");
+    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\n", hdcp_ksv_valid(bksv_buf) ? "Valid" : "Invalid");
 
     return pos;
 }
@@ -875,7 +875,7 @@ static ssize_t show_support_3d(struct device * dev, struct device_attribute *att
 {
     int pos=0;
 
-    pos += snprintf(buf+pos, PAGE_SIZE,"%d\r\n", hdmitx_device.RXCap.threeD_present);
+    pos += snprintf(buf+pos, PAGE_SIZE,"%d\n", hdmitx_device.RXCap.threeD_present);
     return pos;
 }
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
index 9ebaf0d73578..387b8263fc24 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
@@ -1580,34 +1580,34 @@ int hdmitx_edid_dump(hdmitx_dev_t* hdmitx_device, char* buffer, int buffer_len)
     int i,pos=0;
     rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Brand Name: %s\r\n", pRXCap->ReceiverBrandName);
-    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Product Name: %s\r\n", pRXCap->ReceiverProductName);
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Brand Name: %s\n", pRXCap->ReceiverBrandName);
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Product Name: %s\n", pRXCap->ReceiverProductName);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "EDID block number: 0x%x\r\n",hdmitx_device->EDID_buf[0x7e]);
+    pos+=snprintf(buffer+pos, buffer_len-pos, "EDID block number: 0x%x\n",hdmitx_device->EDID_buf[0x7e]);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "Source Physical Address[a.b.c.d]: %x.%x.%x.%x\r\n",
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Source Physical Address[a.b.c.d]: %x.%x.%x.%x\n",
         hdmitx_device->hdmi_info.vsdb_phy_addr.a, hdmitx_device->hdmi_info.vsdb_phy_addr.b, hdmitx_device->hdmi_info.vsdb_phy_addr.c, hdmitx_device->hdmi_info.vsdb_phy_addr.d);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "native Mode %x, VIC (native %d):\r\n",
+    pos+=snprintf(buffer+pos, buffer_len-pos, "native Mode %x, VIC (native %d):\n",
         pRXCap->native_Mode, pRXCap->native_VIC);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "ColorDeepSupport %x, MaxTMDSClock %d\r\n",
+    pos+=snprintf(buffer+pos, buffer_len-pos, "ColorDeepSupport %x, MaxTMDSClock %d\n",
         pRXCap->ColorDeepSupport, pRXCap->Max_TMDS_Clock); 
 
     for( i = 0 ; i < pRXCap->VIC_count ; i++ )
     {
         pos+=snprintf(buffer+pos, buffer_len-pos,"%d ", pRXCap->VIC[i]);
     }
-    pos+=snprintf(buffer+pos, buffer_len-pos,"\r\n");
-    pos+=snprintf(buffer+pos, buffer_len-pos, "Audio {format, channel, freq, cce}\r\n");
+    pos+=snprintf(buffer+pos, buffer_len-pos,"\n");
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Audio {format, channel, freq, cce}\n");
     for(i = 0; i< pRXCap->AUD_count; i++) {
-        pos+=snprintf(buffer+pos, buffer_len-pos, "{%d, %d, %x, %x}\r\n", pRXCap->RxAudioCap[i].audio_format_code,
+        pos+=snprintf(buffer+pos, buffer_len-pos, "{%d, %d, %x, %x}\n", pRXCap->RxAudioCap[i].audio_format_code,
             pRXCap->RxAudioCap[i].channel_num_max, pRXCap->RxAudioCap[i].freq_cc, pRXCap->RxAudioCap[i].cc3);
     }
-    pos+=snprintf(buffer+pos,buffer_len-pos,"Speaker Allocation: %x\r\n", pRXCap->RxSpeakerAllocation);
-    pos+=snprintf(buffer+pos,buffer_len-pos,"Vendor: %x\r\n", pRXCap->IEEEOUI);
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Speaker Allocation: %x\n", pRXCap->RxSpeakerAllocation);
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Vendor: %x\n", pRXCap->IEEEOUI);
 
-    pos+=snprintf(buffer+pos,buffer_len-pos,"Rx 3D Format Support List:\r\n{VIC FramePacking TopBottom SidebySide}\r\n");
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Rx 3D Format Support List:\n{VIC FramePacking TopBottom SidebySide}\n");
     for(i = 0 ; i < pRXCap->VIC_count; i++){
         pos+=snprintf(buffer+pos,buffer_len-pos,"{ %d\t%d\t%d\t%d }\n", pRXCap->VIC[i], 
                                                                    pRXCap->support_3d_format[pRXCap->VIC[i]].frame_packing,
diff --git a/drivers/amlogic/i2c/aml_sw_i2c.c b/drivers/amlogic/i2c/aml_sw_i2c.c
index 6f5d4e7ce29f..caecd5f43bb8 100755
--- a/drivers/amlogic/i2c/aml_sw_i2c.c
+++ b/drivers/amlogic/i2c/aml_sw_i2c.c
@@ -298,7 +298,7 @@ static int aml_sw_i2c_probe(struct platform_device *pdev)
 	if ((ret = i2c_bit_add_numbered_bus(&(drv_data->adapter)) != 0)) 
 	{
 		printk(KERN_ERR "\033[0;40;36mERROR: Could not add %s to i2c bit" 
-							"algos\033[0m\r\n", drv_data->adapter.name);
+							"algos\033[0m\n", drv_data->adapter.name);
 		return ret;
 	}
 
@@ -309,7 +309,7 @@ static int aml_sw_i2c_probe(struct platform_device *pdev)
 		printk(" class register sw_i2c_class[%d] fail![ret=0x%x]\n", drv_data->adapter.nr, ret);
 	}
 	
-	printk("aml gpio i2c bus [%d] initialized\r\n", drv_data->adapter.nr);
+	printk("aml gpio i2c bus [%d] initialized\n", drv_data->adapter.nr);
 	return 0;
 }
 
diff --git a/drivers/amlogic/input/call_key/aml_callkey.c b/drivers/amlogic/input/call_key/aml_callkey.c
index 82f42e1fb965..f689b5094a0e 100755
--- a/drivers/amlogic/input/call_key/aml_callkey.c
+++ b/drivers/amlogic/input/call_key/aml_callkey.c
@@ -306,7 +306,7 @@ static int __devinit callkey_probe(struct platform_device *pdev)
     register_early_suspend(&callkey_early_suspend);
     #endif
     
-    printk("CallKey register  completed.\r\n");
+    printk("CallKey register  completed.\n");
     return 0;
 }
 
diff --git a/drivers/amlogic/input/gpio_key/aml_gpiokey.c b/drivers/amlogic/input/gpio_key/aml_gpiokey.c
index dd9470fa8dea..2d3612e46ff7 100755
--- a/drivers/amlogic/input/gpio_key/aml_gpiokey.c
+++ b/drivers/amlogic/input/gpio_key/aml_gpiokey.c
@@ -198,11 +198,11 @@ static int register_keypad_dev(struct kp  *kp)
     ret=register_chrdev(0, kp->config_name, &keypad_fops);
     if(ret<=0)
     {
-        printk("register char device error\r\n");
+        printk("register char device error\n");
         return  ret ;
     }
     kp->config_major=ret;
-    printk("gpio keypad major:%d\r\n",ret);
+    printk("gpio keypad major:%d\n",ret);
     kp->config_class=class_create(THIS_MODULE,kp->config_name);
     kp->config_dev=device_create(kp->config_class,	NULL,
     		MKDEV(kp->config_major,0),NULL,kp->config_name);
@@ -403,7 +403,7 @@ static int gpio_key_probe(struct platform_device *pdev)
 		    goto get_key_param_failed;
     }
 	set_pwr_key();
-    printk("gpio keypad register input device completed.\r\n");
+    printk("gpio keypad register input device completed.\n");
     register_keypad_dev(gp_kp);
     kfree(key_param);
     return 0;
diff --git a/drivers/amlogic/input/holdkey/aml_holdkey.c b/drivers/amlogic/input/holdkey/aml_holdkey.c
index 5c852b969e31..131cfb9fc652 100755
--- a/drivers/amlogic/input/holdkey/aml_holdkey.c
+++ b/drivers/amlogic/input/holdkey/aml_holdkey.c
@@ -127,7 +127,7 @@ static int __devinit holdkey_probe(struct platform_device *pdev)
 
     switch_dev_register(&sdev);
     
-    printk("HoldKey register  completed.\r\n");
+    printk("HoldKey register  completed.\n");
     return 0;
 }
 
diff --git a/drivers/amlogic/input/keyboard/adc_keypad.c b/drivers/amlogic/input/keyboard/adc_keypad.c
index abf43cf2353d..a1cdbd69d936 100755
--- a/drivers/amlogic/input/keyboard/adc_keypad.c
+++ b/drivers/amlogic/input/keyboard/adc_keypad.c
@@ -186,11 +186,11 @@ static int register_keypad_dev(struct kp  *kp)
     ret=register_chrdev(0, kp->config_name, &keypad_fops);
     if(ret<=0)
     {
-        printk("register char device error\r\n");
+        printk("register char device error\n");
         return  ret ;
     }
     kp->config_major=ret;
-    printk("adc keypad major:%d\r\n",ret);
+    printk("adc keypad major:%d\n",ret);
     kp->config_class=class_create(THIS_MODULE,kp->config_name);
     kp->config_dev=device_create(kp->config_class,	NULL,
     		MKDEV(kp->config_major,0),NULL,kp->config_name);
@@ -373,7 +373,7 @@ static int kp_probe(struct platform_device *pdev)
 		    state = -EINVAL;
 		    goto get_key_param_failed;
     }
-    printk("adc keypad register input device completed.\r\n");
+    printk("adc keypad register input device completed.\n");
     register_keypad_dev(gp_kp);
     kfree(key_param);
 #ifdef CONFIG_HAS_EARLYSUSPEND
diff --git a/drivers/amlogic/input/keyboard/ha2605.c b/drivers/amlogic/input/keyboard/ha2605.c
index d936f094abf7..480c444dfcbc 100755
--- a/drivers/amlogic/input/keyboard/ha2605.c
+++ b/drivers/amlogic/input/keyboard/ha2605.c
@@ -150,7 +150,7 @@ static void ha2605_work(struct work_struct *work)
 	}
 
 #if	__HA2605_DEBUG__
-	printk(KERN_INFO "button_val = 0x%04x\r\n", button_val);
+	printk(KERN_INFO "button_val = 0x%04x\n", button_val);
 #endif
 
 	key = kp->key;
@@ -303,11 +303,11 @@ static int ha2605_register_device(struct ha2605 *kp)
 	strcpy(kp->config_name,DRIVER_NAME);
 	ret=register_chrdev(0, kp->config_name, &ha2605_fops);
 	if(ret<=0) {
-		printk("register char device error\r\n");
+		printk("register char device error\n");
 		return  ret ;
 	}
 	kp->config_major=ret;
-	printk("ha2605 major:%d\r\n",ret);
+	printk("ha2605 major:%d\n",ret);
 	kp->config_class=class_create(THIS_MODULE,kp->config_name);
 	kp->config_dev=device_create(kp->config_class,	NULL,
 	MKDEV(kp->config_major,0),NULL,kp->config_name);
diff --git a/drivers/amlogic/input/keyboard/it7230.c b/drivers/amlogic/input/keyboard/it7230.c
index 17ff7a58c0fd..8f36fc1cfa25 100755
--- a/drivers/amlogic/input/keyboard/it7230.c
+++ b/drivers/amlogic/input/keyboard/it7230.c
@@ -568,11 +568,11 @@ static int it7230_register_device(struct it7230 *kp)
     strcpy(kp->config_name,DRIVER_NAME);
     ret=register_chrdev(0, kp->config_name, &it7230_fops);
     if(ret<=0) {
-        printk("register char device error\r\n");
+        printk("register char device error\n");
         return  ret ;
     }
     kp->config_major=ret;
-    printk("it7230 major:%d\r\n",ret);
+    printk("it7230 major:%d\n",ret);
     kp->config_class=class_create(THIS_MODULE,kp->config_name);
     kp->config_dev=device_create(kp->config_class,  NULL,
     MKDEV(kp->config_major,0),NULL,kp->config_name);
diff --git a/drivers/amlogic/input/keyboard/so340010.c b/drivers/amlogic/input/keyboard/so340010.c
index 81581da0a767..804c2120cb30 100755
--- a/drivers/amlogic/input/keyboard/so340010.c
+++ b/drivers/amlogic/input/keyboard/so340010.c
@@ -175,7 +175,7 @@ static void so340010_work(struct work_struct *work)
 		so340010_reset(kp->client);
 		return;
 	}
-	printk(KERN_INFO "gpio_val=0x%04x, button_val = 0x%04x\r\n", gpio_val, button_val);
+	printk(KERN_INFO "gpio_val=0x%04x, button_val = 0x%04x\n", gpio_val, button_val);
 
 	key = kp->key;
 	for (i = 0; i < kp->key_num; i++) {
@@ -296,11 +296,11 @@ static int so340010_register_device(struct so340010 *kp)
 	strcpy(kp->config_name,DRIVER_NAME);
 	ret=register_chrdev(0, kp->config_name, &so340010_fops);
 	if(ret<=0) {
-		printk("register char device error\r\n");
+		printk("register char device error\n");
 		return  ret ;
 	}
 	kp->config_major=ret;
-	printk("so340010 major:%d\r\n",ret);
+	printk("so340010 major:%d\n",ret);
 	kp->config_class=class_create(THIS_MODULE,kp->config_name);
 	kp->config_dev=device_create(kp->config_class,	NULL,
 	MKDEV(kp->config_major,0),NULL,kp->config_name);
diff --git a/drivers/amlogic/input/new_remote/remote_func.c b/drivers/amlogic/input/new_remote/remote_func.c
index ec7b9fe4a7bf..4800300ca5d1 100755
--- a/drivers/amlogic/input/new_remote/remote_func.c
+++ b/drivers/amlogic/input/new_remote/remote_func.c
@@ -562,7 +562,7 @@ static int get_pulse_width(struct remote *remote_data )
 		remote_data->step == REMOTE_STATUS_LEADER ? "leader" :
 		remote_data->step == REMOTE_STATUS_DATA ? "data" :
 		remote_data->step == REMOTE_STATUS_SYNC ? "sync" : NULL;
-	dbg_printk("%02d:pulse_wdith:%d==>%s\r\n",
+	dbg_printk("%02d:pulse_wdith:%d==>%s\n",
 			remote_data->bit_count - remote_data->bit_num, pulse_width, state);
 	//sometimes we found remote  pulse width==0.        in order to sync machine state we modify it .
 	if (pulse_width == 0) {
diff --git a/drivers/amlogic/input/new_remote/remote_main.c b/drivers/amlogic/input/new_remote/remote_main.c
index e4b5ad3e8235..2d0552d70b12 100755
--- a/drivers/amlogic/input/new_remote/remote_main.c
+++ b/drivers/amlogic/input/new_remote/remote_main.c
@@ -597,11 +597,11 @@ static int register_remote_dev(struct remote *remote)
 	strcpy(remote->config_name, "amremote");
 	ret = register_chrdev(0, remote->config_name, &remote_fops);
 	if (ret <= 0) {
-		printk("register char dev tv error\r\n");
+		printk("register char dev tv error\n");
 		return ret;
 	}
 	remote->config_major = ret;
-	printk("remote config major:%d\r\n", ret);
+	printk("remote config major:%d\n", ret);
 	remote->config_class = class_create(THIS_MODULE, remote->config_name);
 	remote->config_dev = device_create(remote->config_class, NULL, MKDEV(remote->config_major, 0), NULL, remote->config_name);
 	return ret;
@@ -680,7 +680,7 @@ static int remote_probe(struct platform_device *pdev)
 	remote->repeat_delay = 250;
 	remote->repeat_peroid = 33;
 	/* get the irq and init timer */
-	input_dbg("set drvdata completed\r\n");
+	input_dbg("set drvdata completed\n");
 	tasklet_enable(&tasklet);
 	tasklet.data = (unsigned long)remote;
 	setup_timer(&remote->timer, remote_release_timer_sr, 0);
@@ -704,7 +704,7 @@ static int remote_probe(struct platform_device *pdev)
 		device_remove_file(&pdev->dev, &dev_attr_enable);
 		goto err1;
 	}
-	input_dbg("device_create_file completed \r\n");
+	input_dbg("device_create_file completed\n");
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) | BIT_MASK(EV_ABS);
 	input_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_MIDDLE);
 	input_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y) | BIT_MASK(REL_WHEEL);
@@ -729,7 +729,7 @@ static int remote_probe(struct platform_device *pdev)
 		printk(KERN_ERR "Unable to register keypad input device\n");
 		goto err2;
 	}
-	input_dbg("input_register_device completed \r\n");
+	input_dbg("input_register_device completed\n");
 	if (hardware_init(pdev)) {
 		goto err3;
 	}
@@ -753,7 +753,7 @@ static int remote_remove(struct platform_device *pdev)
 {
 	struct remote *remote = platform_get_drvdata(pdev);
 	/* disable keypad interrupt handling */
-	input_dbg("remove remote\r\n");
+	input_dbg("remove remote\n");
 	tasklet_disable(&tasklet);
 	tasklet_kill(&tasklet);
 	/* unregister everything */
diff --git a/drivers/amlogic/input/remote/am_remote.c b/drivers/amlogic/input/remote/am_remote.c
index a3b935250ffc..79bc58743f4e 100755
--- a/drivers/amlogic/input/remote/am_remote.c
+++ b/drivers/amlogic/input/remote/am_remote.c
@@ -316,7 +316,7 @@ static void remote_timer_sr(unsigned long data)
 static irqreturn_t remote_interrupt(int irq, void *dev_id)
 {
 	/* disable keyboard interrupt and schedule for handling */
-	//  input_dbg("===trigger one  remoteads interupt \r\n");
+	//  input_dbg("===trigger one  remoteads interupt\n");
 	tasklet_schedule(&tasklet);
 
 	return IRQ_HANDLED;
@@ -883,11 +883,11 @@ static int register_remote_dev(struct remote *remote)
 	strcpy(remote->config_name, "amremote");
 	ret = register_chrdev(0, remote->config_name, &remote_fops);
 	if (ret <= 0) {
-		printk("register char dev tv error\r\n");
+		printk("register char dev tv error\n");
 		return ret;
 	}
 	remote->config_major = ret;
-	printk("remote config major:%d\r\n", ret);
+	printk("remote config major:%d\n", ret);
 	remote->config_class = class_create(THIS_MODULE, remote->config_name);
 	remote->config_dev = device_create(remote->config_class, NULL, MKDEV(remote->config_major, 0), NULL, remote->config_name);
 	return ret;
@@ -961,7 +961,7 @@ static int remote_probe(struct platform_device *pdev)
 	remote->repeat_peroid = 33;
 
 	/* get the irq and init timer */
-	input_dbg("set drvdata completed\r\n");
+	input_dbg("set drvdata completed\n");
 	tasklet_enable(&tasklet);
 	tasklet.data = (unsigned long)remote;
 	setup_timer(&remote->timer, remote_timer_sr, 0);
@@ -976,7 +976,7 @@ static int remote_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
-	input_dbg("device_create_file completed \r\n");
+	input_dbg("device_create_file completed\n");
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);
 	input_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_MIDDLE);
 	input_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y) | BIT_MASK(REL_WHEEL);
@@ -1009,7 +1009,7 @@ static int remote_probe(struct platform_device *pdev)
 		printk(KERN_ERR "Unable to register keypad input device\n");
 		goto err2;
 	}
-	input_dbg("input_register_device completed \r\n");
+	input_dbg("input_register_device completed\n");
 	if (hardware_init(pdev)) {
 		goto err3;
 	}
@@ -1039,7 +1039,7 @@ static int remote_remove(struct platform_device *pdev)
 	struct remote *remote = platform_get_drvdata(pdev);
 
 	/* disable keypad interrupt handling */
-	input_dbg("remove remoteads \r\n");
+	input_dbg("remove remoteads\n");
 	tasklet_disable(&tasklet);
 	tasklet_kill(&tasklet);
 
diff --git a/drivers/amlogic/input/remote/sw_remote_kbd.c b/drivers/amlogic/input/remote/sw_remote_kbd.c
index 876fe4289366..17e9f77f28fd 100755
--- a/drivers/amlogic/input/remote/sw_remote_kbd.c
+++ b/drivers/amlogic/input/remote/sw_remote_kbd.c
@@ -81,7 +81,7 @@ static int get_pulse_width(unsigned long data)
 	        remote_data->step == REMOTE_STATUS_LEADER ? "leader" :
 	        remote_data->step == REMOTE_STATUS_DATA ? "data" :
 	        remote_data->step == REMOTE_STATUS_SYNC ? "sync" : NULL;
-	dbg_printk("%02d:pulse_wdith:%d==>%s\r\n",
+	dbg_printk("%02d:pulse_wdith:%d==>%s\n",
 	           remote_data->bit_count - remote_data->bit_num, pulse_width, state);
 	//sometimes we found remote  pulse width==0.        in order to sync machine state we modify it .
 	if (pulse_width == 0) {
diff --git a/drivers/amlogic/input/remote/sw_remote_rc6.c b/drivers/amlogic/input/remote/sw_remote_rc6.c
index 8a083bc9e6cb..bc279c2b2cd4 100755
--- a/drivers/amlogic/input/remote/sw_remote_rc6.c
+++ b/drivers/amlogic/input/remote/sw_remote_rc6.c
@@ -192,7 +192,7 @@ static inline int get_pulse_width(unsigned long data)
 	        remote_data->step == RC6_STATUS_CONTROL ? "control" :
 	        remote_data->step == RC6_STATUS_INFO ? "information" :
 	        remote_data->step == RC6_STATUS_FREE ? "free" : NULL;
-	dbg_printk("%02d:pulse_wdith:%d==>%s\r\n",
+	dbg_printk("%02d:pulse_wdith:%d==>%s\n",
 	           remote_data->bit_count - remote_data->bit_num, ret, state);
 
 	return ret;
diff --git a/drivers/amlogic/input/remote/virtual_remote.c b/drivers/amlogic/input/remote/virtual_remote.c
index 8d634cce60f6..9c80a49e264b 100755
--- a/drivers/amlogic/input/remote/virtual_remote.c
+++ b/drivers/amlogic/input/remote/virtual_remote.c
@@ -112,7 +112,7 @@ static void register_remote_dev(struct input_struct *kp)
 	strcpy(kp->config_name, "virtualremote");
 	ret = register_chrdev(0, kp->config_name, &virtual_remote_fops);
 	if (ret <= 0) {
-		printk("register char dev (VirtualRemote) error\r\n");
+		printk("register char dev (VirtualRemote) error\n");
 		return;
 	}
 	kp->config_major = ret;
@@ -173,7 +173,7 @@ static int __init virtual_remote_probe(struct platform_device *pdev)
 		gp_input_device = NULL;
 		return -EINVAL;
 	}
-	printk("input_register_device completed \r\n");
+	printk("input_register_device completed\n");
 
 	register_remote_dev(apollo_kp);
 	return 0;
@@ -183,7 +183,7 @@ static int virtual_remote_remove(struct platform_device *pdev)
 {
 	struct input_struct *apollo_kp = platform_get_drvdata(pdev);
 	/* disable keypad interrupt handling */
-	printk("remove Virtual Remote. \r\n");
+	printk("remove Virtual Remote.\n");
 
 	/* unregister everything */
 	input_unregister_device(apollo_kp->input);
diff --git a/drivers/amlogic/input/simcard_detect/simcard_detect.c b/drivers/amlogic/input/simcard_detect/simcard_detect.c
index 570b0bfe08ac..1e481721d446 100755
--- a/drivers/amlogic/input/simcard_detect/simcard_detect.c
+++ b/drivers/amlogic/input/simcard_detect/simcard_detect.c
@@ -152,11 +152,11 @@ static int register_simdetect_dev(struct sim_detect  *p_sd, int dev_id)
     ret=register_chrdev(0, p_sd->config_name, &simdetect_fops);
     if(ret<=0)
     {
-        printk("register char device error\r\n");
+        printk("register char device error\n");
         return  ret ;
     }
     p_sd->config_major=ret;
-    printk("simdetect major:%d\r\n",ret);
+    printk("simdetect major:%d\n",ret);
     p_sd->config_class=class_create(THIS_MODULE,p_sd->config_name);
     p_sd->config_dev=device_create(p_sd->config_class,	NULL,
     		MKDEV(p_sd->config_major,0),NULL,p_sd->config_name);
diff --git a/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.c b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.c
index 7923ccb8b61a..8d4ae166b576 100755
--- a/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.c
+++ b/drivers/amlogic/input/touchscreen/ft5x02/ft5x02_ts.c
@@ -842,10 +842,10 @@ static ssize_t ft5x02_initparam_show(struct device *dev,
 	mutex_lock(&g_device_mutex);
 	if (ft5x02_Init_IC_Param(client) >= 0)
 		num_read_chars = sprintf(buf, "%s",
-			"ft5x02 init param successful\r\n");
+			"ft5x02 init param successful\n");
 	else
 		num_read_chars = sprintf(buf, "%s",
-			"ft5x02 init param failed!\r\n");
+			"ft5x02 init param failed!\n");
 	//ft5x02_get_ic_param(client);
 	mutex_unlock(&g_device_mutex);
 	
diff --git a/drivers/amlogic/input/touchscreen/uor6x5x.c b/drivers/amlogic/input/touchscreen/uor6x5x.c
index ec14d928ac0f..e807d75b7cfd 100755
--- a/drivers/amlogic/input/touchscreen/uor6x5x.c
+++ b/drivers/amlogic/input/touchscreen/uor6x5x.c
@@ -345,82 +345,82 @@ void SendGestureKey(VUINT8 Gesture ){
 		case Tap:
 			ts.GesNo = 'T';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is TAP\r\n");
+				printk(KERN_INFO "Gesture is TAP\n");
 			break;
 		case RHorizontal:
 			ts.GesNo = 'R';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is RHorizontal\r\n");
+				printk(KERN_INFO "Gesture is RHorizontal\n");
 			break;
 		case LHorizontal:
 			ts.GesNo = 'L';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is LHorizontal\r\n");
+				printk(KERN_INFO "Gesture is LHorizontal\n");
 			break;
 		case UVertical:
 			ts.GesNo = 'U';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is UVertical\r\n");
+				printk(KERN_INFO "Gesture is UVertical\n");
 			break;
 		case DVertical:
 			ts.GesNo = 'D';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is DVertical\r\n");
+				printk(KERN_INFO "Gesture is DVertical\n");
 			break;
 		case RArc:
 			ts.GesNo = 'A';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is RArc\r\n");
+				printk(KERN_INFO "Gesture is RArc\n");
 			break;
 		case LArc:
 			ts.GesNo = 'A';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is LArc\r\n");
+				printk(KERN_INFO "Gesture is LArc\n");
 			break;
 		case CWCircle:
 			ts.GesNo = 'C';
 			if(UOR6X5X_DEBUG
-				printk(KERN_INFO "Gesture is CWCircle\r\n");
+				printk(KERN_INFO "Gesture is CWCircle\n");
 			break;
 		case CCWCircle:
 			ts.GesNo = 'c';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is CCWCircle\r\n");
+				printk(KERN_INFO "Gesture is CCWCircle\n");
 			break;
 		case RPan:
 			ts.GesNo = 'r';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is RPan\r\n");
+				printk(KERN_INFO "Gesture is RPan\n");
 			break;
 		case LPan:
 			ts.GesNo = 'l';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is LPan\r\n");
+				printk(KERN_INFO "Gesture is LPan\n");
 			break;
 		case DPan:
 			ts.GesNo = 'd';		
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is DPan\r\n");
+				printk(KERN_INFO "Gesture is DPan\n");
 			break;
 		case UPan:
 			ts.GesNo = 'u';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is UPan\r\n");
+				printk(KERN_INFO "Gesture is UPan\n");
 			break;
 		case PressTap:
 			ts.GesNo = 'p';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is PressTap\r\n");
+				printk(KERN_INFO "Gesture is PressTap\n");
 			break;
 		case PinchIn:
 			ts.GesNo = 'I';
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is PinchIn\r\n");
+				printk(KERN_INFO "Gesture is PinchIn\n");
 			break;
 		case PinchOut:
 			ts.GesNo = 'O';	
 			if(UOR6X5X_DEBUG)
-				printk(KERN_INFO "Gesture is PinchOut\r\n");
+				printk(KERN_INFO "Gesture is PinchOut\n");
 			break;
 		default:
 			if(UOR6X5X_DEBUG)
diff --git a/drivers/amlogic/mhl/it6681/it6681_drv.c b/drivers/amlogic/mhl/it6681/it6681_drv.c
index afb3bf9d7791..eb3a08ad9f67 100755
--- a/drivers/amlogic/mhl/it6681/it6681_drv.c
+++ b/drivers/amlogic/mhl/it6681/it6681_drv.c
@@ -4084,7 +4084,7 @@ void DumpHDMITXReg8051(void)
     int ij;
     unsigned char ucData = 0;
     IT6681_DEBUG_PRINTF(("########################################################################\n"));
-    IT6681_DEBUG_PRINTF(("#Dump IT6681\r\n"));
+    IT6681_DEBUG_PRINTF(("#Dump IT6681\n"));
     IT6681_DEBUG_PRINTF(("########################################################################\n" "       "));
 
     IT6681_DEBUG_PRINTF((""));
diff --git a/drivers/amlogic/ppmgr/ppmgr_drv.c b/drivers/amlogic/ppmgr/ppmgr_drv.c
index b1a416cea4aa..2bf2300626c2 100755
--- a/drivers/amlogic/ppmgr/ppmgr_drv.c
+++ b/drivers/amlogic/ppmgr/ppmgr_drv.c
@@ -957,7 +957,7 @@ struct class* init_ppmgr_cls() {
     ret = class_register(&ppmgr_class);
     if(ret<0 )
     {
-        amlog_level(LOG_LEVEL_HIGH,"error create ppmgr class\r\n");
+        amlog_level(LOG_LEVEL_HIGH,"error create ppmgr class\n");
         return NULL;
     }
     return &ppmgr_class;
@@ -1101,7 +1101,7 @@ int  init_ppmgr_device(void)
     ret=register_chrdev(0,ppmgr_device.name,&ppmgr_fops);
     if(ret <=0)
     {
-        amlog_level(LOG_LEVEL_HIGH,"register ppmgr device error\r\n");
+        amlog_level(LOG_LEVEL_HIGH,"register ppmgr device error\n");
         return  ret ;
     }
     ppmgr_device.major=ret;
@@ -1130,7 +1130,7 @@ int  init_ppmgr_device(void)
 #endif
     ppmgr_device.mirror_flag  = 0;
     ppmgr_device.canvas_width = ppmgr_device.canvas_height = 0;
-    amlog_level(LOG_LEVEL_LOW,"ppmgr_dev major:%d\r\n",ret);
+    amlog_level(LOG_LEVEL_LOW,"ppmgr_dev major:%d\n",ret);
 
     if((ppmgr_device.cla = init_ppmgr_cls())==NULL) return -1;
     ppmgr_device.dev=device_create(ppmgr_device.cla,NULL,MKDEV(ppmgr_device.major,0),NULL,ppmgr_device.name);
-- 
2.19.0

