From 758c003fb3a98531aec1deb20117fae305ed7754 Mon Sep 17 00:00:00 2001
From: "brian.zhu" <brian.zhu@amlogic.com>
Date: Mon, 20 Oct 2014 21:42:37 +0800
Subject: [PATCH 4976/5965] PD#98713, implement encode multi-instance

---
 arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd |    2 +-
 .../arm/boot/dts/amlogic/meson8m2_n200_1G.dtd |    2 +-
 .../arm/boot/dts/amlogic/meson8m2_n200_2G.dtd |    2 +-
 drivers/amlogic/amports/encoder.c             | 3053 +++++++++--------
 drivers/amlogic/amports/encoder.h             |  256 +-
 drivers/amlogic/amports/jpegenc.c             |    2 +-
 .../m8/ucode/encoder/h264_enc_mix_dump.h      |    2 +-
 .../m8/ucode/encoder/h264_enc_mix_dump_dblk.h |    2 +-
 .../m8/ucode/encoder/h264_enc_mix_sw.h        |    2 +-
 .../ucode/encoder/h264_enc_mix_sw_hdec_dblk.h |    2 +-
 .../encoder/h264_enc_mix_sw_hdec_m2_dblk.h    |    2 +-
 .../encoder/h264_enc_mix_sw_vdec2_dblk.h      |    2 +-
 drivers/amlogic/video_dev/amlvideo2.c         |   17 +-
 13 files changed, 1949 insertions(+), 1397 deletions(-)
 mode change 100644 => 100755 drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_hdec_m2_dblk.h

diff --git a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
index 8c15e8a82269..6b21898a218e 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
@@ -92,7 +92,7 @@ void root_func(){
         };
         cma_1:region@1 {
            region_name = "cma_1";
-           reg = <0 0x01200000>;
+           reg = <0 0x02400000>;
            linux,contiguous-region;
         };
 
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd
index 2df0bd4ac991..7063a51da295 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd
@@ -88,7 +88,7 @@ void root_func(){
 
         cma_0:region@0 {
            region_name = "cma_0";
-           reg = <0 0x01200000>;
+           reg = <0 0x02400000>;
            linux,contiguous-region;
         };
 	};
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n200_2G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n200_2G.dtd
index c615e3aeb008..7f347d1300a2 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n200_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n200_2G.dtd
@@ -88,7 +88,7 @@ void root_func(){
 
         cma_0:region@0 {
            region_name = "cma_0";
-           reg = <0 0x01200000>;
+           reg = <0 0x02400000>;
            linux,contiguous-region;
         };
 	};
diff --git a/drivers/amlogic/amports/encoder.c b/drivers/amlogic/amports/encoder.c
index 1f45d96f64da..3c182845115c 100755
--- a/drivers/amlogic/amports/encoder.c
+++ b/drivers/amlogic/amports/encoder.c
@@ -9,26 +9,17 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/errno.h>
-#include <linux/interrupt.h>
 #include <linux/timer.h>
 #include <linux/fs.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
-#include <linux/spinlock.h>
 #include <mach/am_regs.h>
 #include <mach/power_gate.h>
 #include <mach/mod_gate.h>
 #include <plat/io.h>
 #include <linux/ctype.h>
-#include <linux/amlogic/amports/ptsserv.h>
 #include <linux/amlogic/amports/amstream.h>
 #include <linux/amlogic/amports/canvas.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <linux/amlogic/amports/vframe_receiver.h>
-#include <linux/amlogic/amports/vformat.h>
 #include "vdec_reg.h"
 #include "vdec.h"
 #include <linux/delay.h>
@@ -36,171 +27,98 @@
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/dma-contiguous.h>
+#include <linux/kthread.h>
+#include <linux/sched/rt.h>
 #include "amports_config.h"
-
-#define MULTI_SLICE_MC
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
-#define USE_VDEC2
-#endif
-#define ENC_CANVAS_OFFSET  AMVENC_CANVAS_INDEX
-//#define DUMP_PRE_ENCODE_INTRA
-
-#define UCODE_MODE_FULL 0
-#define UCODE_MODE_SW_MIX 1
-
-#define LOG_LEVEL_VAR 1
-#define debug_level(level, x...) \
-	do { \
-		if (level >= LOG_LEVEL_VAR) \
-			printk(x); \
-	} while (0);
-
-
-#ifdef CONFIG_AM_VDEC_MJPEG_LOG
-#define AMLOG
-#define LOG_LEVEL_VAR       amlog_level_avc
-#define LOG_MASK_VAR        amlog_mask_avc
-#define LOG_LEVEL_ERROR     0
-#define LOG_LEVEL_INFO      1
-#define LOG_LEVEL_DESC  "0:ERROR, 1:INFO"
-#endif
-#include <linux/amlogic/amlog.h>
-MODULE_AMLOG(LOG_LEVEL_ERROR, 0, LOG_LEVEL_DESC, LOG_DEFAULT_MASK_DESC);
-
 #include "encoder.h"
 #include "amvdec.h"
 #include "encoder_mc.h"
+#include <linux/amlogic/amlog.h>
 
+//device 
 static int avc_device_major = 0;
-static struct class *amvenc_avc_class;
-static struct device *amvenc_avc_dev;
+static struct device *amvenc_avc_dev = NULL;
 #define DRIVER_NAME "amvenc_avc"
-#define MODULE_NAME "amvenc_avc"
+#define CLASS_NAME "amvenc_avc"
 #define DEVICE_NAME "amvenc_avc"
 
-/* protocol register usage
-	#define ENCODER_STATUS            HENC_SCRATCH_0    : encode stage
-	#define MEM_OFFSET_REG            HENC_SCRATCH_1    : assit buffer physical address
-	#define DEBUG_REG  				  HENC_SCRATCH_2    : debug register
-	#define MB_COUNT				  HENC_SCRATCH_3	: MB encoding number
-*/
+static encode_manager_t encode_manager;
+
+#define MULTI_SLICE_MC
+/*same as INIT_ENCODER*/
+#define INTRA_IN_P_TOP
+
+#define ENC_CANVAS_OFFSET  AMVENC_CANVAS_INDEX
+
+#define UCODE_MODE_FULL 0
+#define UCODE_MODE_SW_MIX 1
+
 #ifdef USE_VDEC2
 #define STREAM_WR_PTR               DOS_SCRATCH20
 #define DECODABLE_MB_Y              DOS_SCRATCH21
 #define DECODED_MB_Y                DOS_SCRATCH22
 #endif
 
-/*output buffer define*/
-static unsigned BitstreamStart;
-static unsigned BitstreamEnd;
-//static unsigned BitstreamIntAddr;
-/*input buffer define*/
-static unsigned dct_buff_start_addr;
-static unsigned dct_buff_end_addr;
-
-/*deblock buffer define*/
-//static unsigned dblk_buf_addr;
-static unsigned dblk_buf_canvas;
-
-/*reference buffer define*/
-//static unsigned ref_buf_addr ; //192
-static unsigned ref_buf_canvas;  //((192<<16)|(192<<8)|(192<<0))
-
-/*microcode assitant buffer*/
-static unsigned assit_buffer_offset;
-//static struct dec_sysinfo avc_amstream_dec_info;
-
-u32 inter_bits_info_ddr_start_addr = 0;
-u32 inter_mv_info_ddr_start_addr = 0;
-u32 intra_bits_info_ddr_start_addr = 0;
-u32 intra_pred_info_ddr_start_addr = 0;
-u32 sw_ctl_info_start_addr = 0;
-#ifdef USE_VDEC2
-#define VDEC2_DEF_BUF_START_ADDR            0x01000000
-u32 vdec2_start_addr = 0;
-#endif
-
-static u32 stat;
-//static u32 cur_stage;
-static u32 frame_start;//0: processing 1:restart
-static u32 quant = 28;
-static u32 encoder_width = 1280;
-static u32 encoder_height = 720;
-static void avc_prot_init(bool IDR);
-static s32 avc_poweron(int clock);
-static void dma_flush(unsigned buf_start , unsigned buf_size );
-//static void avc_local_init(void);
-static int idr_pic_id = 0;  //need reset as 0 for IDR
-static u32 frame_number = 0 ;   //need plus each frame
-static u32 pic_order_cnt_lsb = 0 ; //need reset as 0 for IDR and plus 2 for NON-IDR
-
-static u32 log2_max_pic_order_cnt_lsb = 4 ;
-static u32 log2_max_frame_num =4 ;
 static u32 anc0_buffer_id =0;
-static u32 qppicture  =28;
-static u32 process_irq = 0;
 static u32 ie_me_mb_type  = 0;
 static u32 ie_me_mode  = 0;
 static u32 ie_pippeline_block = 3;
 static u32 ie_cur_ref_sel = 0;
-static int encode_inited = 0;
-static int encode_opened = 0;
-static int encoder_status = 0;
 static int avc_endian = 6;
 static int clock_level = 1;
+static int enable_dblk = 1;  // 0 disable, 1 vdec 2 hdec
 
-static wait_queue_head_t avc_wait;
-atomic_t avc_ready = ATOMIC_INIT(0);
-static struct tasklet_struct encode_tasklet;
-#ifdef MULTI_SLICE_MC
-static int rows_per_slice = 1;
-#endif
+static u32 encode_print_level = LOG_LEVEL_DEBUG;
 
-static bool dblk_fix_flag = false;
+static int me_mv_merge_ctl =
+              ( 0x1 << 31)  |  // [31] me_merge_mv_en_16
+              ( 0x1 << 30)  |  // [30] me_merge_small_mv_en_16
+              ( 0x1 << 29)  |  // [29] me_merge_flex_en_16
+              ( 0x1 << 28)  |  // [28] me_merge_sad_en_16
+              ( 0x1 << 27)  |  // [27] me_merge_mv_en_8
+              ( 0x1 << 26)  |  // [26] me_merge_small_mv_en_8
+              ( 0x1 << 25)  |  // [25] me_merge_flex_en_8
+              ( 0x1 << 24)  |  // [24] me_merge_sad_en_8
+              ( 0x12 << 18)  |  // [23:18] me_merge_mv_diff_16 - MV diff <= n pixel can be merged
+              ( 0x2b << 12)  |  // [17:12] me_merge_mv_diff_8 - MV diff <= n pixel can be merged
+              ( 0x80 << 0);    // [11:0] me_merge_min_sad - SAD >= 0x180 can be merged with other MV
+              //( 0x4 << 18)  |  // [23:18] me_merge_mv_diff_16 - MV diff <= n pixel can be merged
+              //( 0x3f << 12)  |  // [17:12] me_merge_mv_diff_8 - MV diff <= n pixel can be merged
+              //( 0xc0 << 0);    // [11:0] me_merge_min_sad - SAD >= 0x180 can be merged with other MV
 
-static DEFINE_SPINLOCK(lock);
+static int me_mv_weight_01 = (0x40<<24)|(0x30<<16)|(0x20<<8)|0x30;
+static int me_mv_weight_23 = (0x40<<8)|0x30;
+static int me_sad_range_inc = 0x03030303;
+static int me_step0_close_mv = 0x003ffc21;
+static int me_f_skip_sad = 0;
+static int me_f_skip_weight = 0;
+static int me_sad_enough_01 = 0;//0x00018010;
+static int me_sad_enough_23 = 0;//0x00000020;
 
-static const char avc_dec_id[] = "avc-dev";
+static int p_intra_config =(30 << 16)|(0xffff << 0);
 
-#define AMVENC_BUFFER_LEVEL_480P   0
-#define AMVENC_BUFFER_LEVEL_720P   1
-#define AMVENC_BUFFER_LEVEL_1080P 2
+// [31:16] TARGET_BITS_PER_MB
+// [15:8] MIN_QUANT
+//  [7:0] MAX_QUANT
+static int p_mb_quant_config = (20 << 16)|(24 << 8)|(24 << 0);
 
-static int ucode_index = UCODE_MODE_FULL;
-static int enable_dblk = 1;  // 0 disable, 1 vdec 2 hdec
-#ifdef DUMP_PRE_ENCODE_INTRA
-static bool preencode_intra;
-static unsigned intra_pic_id = 0;
-#endif
+// [31:24] INC_4_BITS
+// [23:16] INC_3_BITS
+// [15:8]  INC_2_BITS
+// [7:0]   INC_1_BITS
+static int p_mb_quant_inc_cfg = (20 << 24)|(15 << 16)|(10 << 8)|(5 << 0);
 
-typedef struct
-{
-    u32 buf_start;
-    u32 buf_size;
-} Buff_t;
+// [31:24] DEC_4_BITS
+// [23:16] DEC_3_BITS
+// [15:8]  DEC_2_BITS
+// [7:0]   DEC_1_BITS
+static int p_mb_quant_dec_cfg =(60 << 24)|(40 << 16)|(30 << 8)|(20 << 0);
 
-typedef struct
-{
-    u32 lev_id;
-    u32 min_buffsize;
-    u32 max_width;
-    u32 max_height;
-    Buff_t dct;
-    Buff_t dec0_y;
-    Buff_t dec0_uv;
-    Buff_t dec1_y;
-    Buff_t dec1_uv;
-    Buff_t assit;
-    Buff_t bitstream;
-    Buff_t inter_bits_info;
-    Buff_t inter_mv_info;
-    Buff_t intra_bits_info;
-    Buff_t intra_pred_info;
-    Buff_t qp_info;
-#ifdef USE_VDEC2
-    Buff_t vdec2_info;
-#endif
-} BuffInfo_t;
+// [31:0] NUM_ROWS_PER_SLICE_P
+// [15:0] NUM_ROWS_PER_SLICE_I
+static int fixed_slice_cfg = 0;
+
+static DEFINE_SPINLOCK(lock);
 
 static BuffInfo_t amvenc_buffspec[]={
     {
@@ -362,263 +280,219 @@ static BuffInfo_t amvenc_buffspec[]={
     }
 };
 
-typedef struct
-{
-    u32 buf_start;
-    u32 buf_size;
-    u8 cur_buf_lev;
-    BuffInfo_t* bufspec;
-} EncBuffer_t;
-
-static EncBuffer_t gAmvencbuff = {0,0,0,NULL};
-
-static void avc_canvas_init(void);
-
-void amvenc_reset(void);
-
 #ifdef CONFIG_AM_JPEG_ENCODER
 extern bool jpegenc_on(void);
 #endif
 
-int avc_dec_status(struct vdec_status *vstatus)
+static void dma_flush(unsigned buf_start , unsigned buf_size );
+
+static const u32 *select_ucode(u32 ucode_index)
 {
-    return 0;
+    const u32 * p = mix_dump_mc;
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    switch(ucode_index){
+        case UCODE_MODE_FULL:
+            if(enable_dblk)
+                p = mix_dump_mc_dblk;
+            else
+                p = mix_dump_mc;
+            break;
+        case UCODE_MODE_SW_MIX:
+            if(IS_MESON_M8B_CPU){
+                if(enable_dblk)
+                    p = mix_sw_mc_hdec_dblk;
+                else
+                    p = mix_sw_mc;
+            }
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
+            else if(IS_MESON_M8_CPU){
+                if(enable_dblk == 1)
+                    p = mix_sw_mc_vdec2_dblk;
+                else if (enable_dblk ==2)
+                    p = mix_sw_mc_hdec_dblk;
+                else
+                    p = mix_sw_mc;
+            }else if(IS_MESON_M8M2_CPU){
+                if(enable_dblk)
+                    p = mix_sw_mc_hdec_m2_dblk;
+                else
+                    p = mix_sw_mc;
+            }
+#endif
+            break;
+        default:
+            break;
+    }
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
+    if(IS_MESON_M8M2_CPU){
+        encode_manager.dblk_fix_flag = (p==mix_sw_mc_hdec_m2_dblk);
+    }else
+#endif
+    {
+        encode_manager.dblk_fix_flag = false;
+    }
+#else
+    encode_manager.dblk_fix_flag = false;
+#endif
+    return p;
 }
 
 /*output stream buffer setting*/
-static void avc_init_output_buffer(void)
+static void avc_init_output_buffer(encode_wq_t* wq)
 {
-	WRITE_HREG(VLC_VB_MEM_CTL ,((1<<31)|(0x3f<<24)|(0x20<<16)|(2<<0)) );
-	WRITE_HREG(VLC_VB_START_PTR, BitstreamStart);
-	WRITE_HREG(VLC_VB_WR_PTR, BitstreamStart);
-	WRITE_HREG(VLC_VB_SW_RD_PTR, BitstreamStart);
-	WRITE_HREG(VLC_VB_END_PTR, BitstreamEnd);
-	WRITE_HREG(VLC_VB_CONTROL, 1);
-	WRITE_HREG(VLC_VB_CONTROL, ((0<<14)|(7<<3)|(1<<1)|(0<<0)));
+    WRITE_HREG(VLC_VB_MEM_CTL ,((1<<31)|(0x3f<<24)|(0x20<<16)|(2<<0)) );
+    WRITE_HREG(VLC_VB_START_PTR, wq->mem.BitstreamStart);
+    WRITE_HREG(VLC_VB_WR_PTR, wq->mem.BitstreamStart);
+    WRITE_HREG(VLC_VB_SW_RD_PTR, wq->mem.BitstreamStart);
+    WRITE_HREG(VLC_VB_END_PTR, wq->mem.BitstreamEnd);
+    WRITE_HREG(VLC_VB_CONTROL, 1);
+    WRITE_HREG(VLC_VB_CONTROL, ((0<<14)|(7<<3)|(1<<1)|(0<<0)));
 }
 
 /*input dct buffer setting*/
-static void avc_init_input_buffer(void)
+static void avc_init_input_buffer(encode_wq_t* wq)
 {
-	WRITE_HREG(QDCT_MB_START_PTR ,dct_buff_start_addr );
-	WRITE_HREG(QDCT_MB_END_PTR, dct_buff_end_addr);
-	WRITE_HREG(QDCT_MB_WR_PTR, dct_buff_start_addr);
-	WRITE_HREG(QDCT_MB_RD_PTR, dct_buff_start_addr);
-	WRITE_HREG(QDCT_MB_BUFF, 0);
+    WRITE_HREG(QDCT_MB_START_PTR ,wq->mem.dct_buff_start_addr );
+    WRITE_HREG(QDCT_MB_END_PTR, wq->mem.dct_buff_end_addr);
+    WRITE_HREG(QDCT_MB_WR_PTR, wq->mem.dct_buff_start_addr);
+    WRITE_HREG(QDCT_MB_RD_PTR, wq->mem.dct_buff_start_addr);
+    WRITE_HREG(QDCT_MB_BUFF, 0);
 }
 
 /*input reference buffer setting*/
 static void avc_init_reference_buffer(int canvas)
 {
-	WRITE_HREG(HCODEC_ANC0_CANVAS_ADDR ,canvas);
-	WRITE_HREG(VLC_HCMD_CONFIG ,0);
+    WRITE_HREG(HCODEC_ANC0_CANVAS_ADDR ,canvas);
+    WRITE_HREG(VLC_HCMD_CONFIG ,0);
 }
 
-static void avc_init_assit_buffer(void)
+static void avc_init_assit_buffer(encode_wq_t* wq)
 {
-	WRITE_HREG(MEM_OFFSET_REG,assit_buffer_offset);  //memory offset ?
+    WRITE_HREG(MEM_OFFSET_REG,wq->mem.assit_buffer_offset);  //memory offset ?
 }
 
 /*deblock buffer setting, same as INI_CANVAS*/
 static void avc_init_dblk_buffer(int canvas)
 {
-	WRITE_HREG(HCODEC_REC_CANVAS_ADDR,canvas);
-	WRITE_HREG(HCODEC_DBKR_CANVAS_ADDR,canvas);
-	WRITE_HREG(HCODEC_DBKW_CANVAS_ADDR,canvas);
+    WRITE_HREG(HCODEC_REC_CANVAS_ADDR,canvas);
+    WRITE_HREG(HCODEC_DBKR_CANVAS_ADDR,canvas);
+    WRITE_HREG(HCODEC_DBKW_CANVAS_ADDR,canvas);
 }
 
-/*same as INIT_ENCODER*/
-#define INTRA_IN_P_TOP
-static void avc_init_encoder(bool idr)
+static void avc_init_encoder(encode_wq_t* wq, bool idr)
 {
-	WRITE_HREG(VLC_TOTAL_BYTES, 0);
-	WRITE_HREG(VLC_CONFIG, 0x07);
-	WRITE_HREG(VLC_INT_CONTROL, 0);
-	WRITE_HREG(HCODEC_ASSIST_AMR1_INT0, 0x15);
+    WRITE_HREG(VLC_TOTAL_BYTES, 0);
+    WRITE_HREG(VLC_CONFIG, 0x07);
+    WRITE_HREG(VLC_INT_CONTROL, 0);
+    WRITE_HREG(HCODEC_ASSIST_AMR1_INT0, 0x15);
 #ifdef MULTI_SLICE_MC
-	if(dblk_fix_flag){
-		WRITE_HREG(HCODEC_ASSIST_AMR1_INT2, 0x19);
-		WRITE_HREG(HCODEC_ASSIST_AMR1_INT1, 0x8);
-	}else{
-		WRITE_HREG(HCODEC_ASSIST_AMR1_INT1, 0x19);
-		WRITE_HREG(HCODEC_ASSIST_AMR1_INT2, 0x8);
-	}
+    if(encode_manager.dblk_fix_flag){
+        WRITE_HREG(HCODEC_ASSIST_AMR1_INT2, 0x19);
+        WRITE_HREG(HCODEC_ASSIST_AMR1_INT1, 0x8);
+    }else{
+        WRITE_HREG(HCODEC_ASSIST_AMR1_INT1, 0x19);
+        WRITE_HREG(HCODEC_ASSIST_AMR1_INT2, 0x8);
+    }
 #else
-	if(dblk_fix_flag)
-		WRITE_HREG(HCODEC_ASSIST_AMR1_INT1, 0x8);
-	else
-		WRITE_HREG(HCODEC_ASSIST_AMR1_INT2, 0x8);
+    if(encode_manager.dblk_fix_flag)
+        WRITE_HREG(HCODEC_ASSIST_AMR1_INT1, 0x8);
+    else
+        WRITE_HREG(HCODEC_ASSIST_AMR1_INT2, 0x8);
 #endif
-	WRITE_HREG(HCODEC_ASSIST_AMR1_INT3, 0x14);
+    WRITE_HREG(HCODEC_ASSIST_AMR1_INT3, 0x14);
 #ifdef INTRA_IN_P_TOP
-	WRITE_HREG(HCODEC_ASSIST_DMA_INT_MSK, 0xfd);
-	WRITE_HREG(HCODEC_ASSIST_DMA_INT_MSK2, 0xff);
-	WRITE_HREG(HCODEC_ASSIST_AMR1_INT4, 0x18);
-        //mtspi   0xfd, HCODEC_ASSIST_DMA_INT_MSK // enable lmem_mpeg_dma_int
-        //mtspi   0xff, HCODEC_ASSIST_DMA_INT_MSK2 // disable  cpu19_int
-        //mtspi   0x18, HCODEC_ASSIST_AMR1_INT4   // lmem_dma_isr
+    WRITE_HREG(HCODEC_ASSIST_DMA_INT_MSK, 0xfd);
+    WRITE_HREG(HCODEC_ASSIST_DMA_INT_MSK2, 0xff);
+    WRITE_HREG(HCODEC_ASSIST_AMR1_INT4, 0x18);
+    //mtspi   0xfd, HCODEC_ASSIST_DMA_INT_MSK // enable lmem_mpeg_dma_int
+    //mtspi   0xff, HCODEC_ASSIST_DMA_INT_MSK2 // disable  cpu19_int
+    //mtspi   0x18, HCODEC_ASSIST_AMR1_INT4   // lmem_dma_isr
 #else
-	WRITE_HREG(HCODEC_ASSIST_DMA_INT_MSK, 0xff);
-	WRITE_HREG(HCODEC_ASSIST_DMA_INT_MSK2, 0xff);
-#endif
-#ifdef DUMP_PRE_ENCODE_INTRA
-	if(preencode_intra == true)
-		WRITE_HREG(IDR_PIC_ID ,intra_pic_id);
-	else
+    WRITE_HREG(HCODEC_ASSIST_DMA_INT_MSK, 0xff);
+    WRITE_HREG(HCODEC_ASSIST_DMA_INT_MSK2, 0xff);
 #endif
-		WRITE_HREG(IDR_PIC_ID ,idr_pic_id);
-	WRITE_HREG(FRAME_NUMBER ,(idr== true)?0:frame_number);
-	WRITE_HREG(PIC_ORDER_CNT_LSB,(idr== true)?0:pic_order_cnt_lsb);
-	log2_max_pic_order_cnt_lsb= 4;
-	log2_max_frame_num = 4;
-	WRITE_HREG(LOG2_MAX_PIC_ORDER_CNT_LSB ,  log2_max_pic_order_cnt_lsb);
-	WRITE_HREG(LOG2_MAX_FRAME_NUM , log2_max_frame_num);
-	WRITE_HREG(ANC0_BUFFER_ID, anc0_buffer_id);
-	WRITE_HREG(QPPICTURE, qppicture);
+    WRITE_HREG(IDR_PIC_ID ,wq->pic.idr_pic_id);
+    WRITE_HREG(FRAME_NUMBER ,(idr== true)?0:wq->pic.frame_number);
+    WRITE_HREG(PIC_ORDER_CNT_LSB,(idr== true)?0:wq->pic.pic_order_cnt_lsb);
+    WRITE_HREG(LOG2_MAX_PIC_ORDER_CNT_LSB ,  wq->pic.log2_max_pic_order_cnt_lsb);
+    WRITE_HREG(LOG2_MAX_FRAME_NUM , wq->pic.log2_max_frame_num);
+    WRITE_HREG(ANC0_BUFFER_ID, anc0_buffer_id);
+    WRITE_HREG(QPPICTURE, wq->pic.init_qppicture);
 }
 
 /****************************************/
-static void avc_canvas_init(void)
+static void avc_canvas_init(encode_wq_t* wq)
 {
     u32 canvas_width, canvas_height;
-    int start_addr = gAmvencbuff.buf_start;
+    int start_addr = wq->mem.buf_start;
 
-    canvas_width = ((encoder_width+31)>>5)<<5;
-    canvas_height = ((encoder_height+15)>>4)<<4;
-
-	/*input dct buffer config */
-    dct_buff_start_addr = start_addr+gAmvencbuff.bufspec->dct.buf_start;   //(w>>4)*(h>>4)*864
-    dct_buff_end_addr = dct_buff_start_addr + gAmvencbuff.bufspec->dct.buf_size -1 ;
-    debug_level(0,"dct_buff_start_addr is %x \n",dct_buff_start_addr);
+    canvas_width = ((wq->pic.encoder_width+31)>>5)<<5;
+    canvas_height = ((wq->pic.encoder_height+15)>>4)<<4;
 
     canvas_config(ENC_CANVAS_OFFSET,
-        start_addr + gAmvencbuff.bufspec->dec0_y.buf_start,
+        start_addr + wq->mem.bufspec.dec0_y.buf_start,
         canvas_width, canvas_height,
         CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-
-    gAmvencbuff.bufspec->dec0_uv.buf_start = gAmvencbuff.bufspec->dec0_y.buf_start+canvas_width*canvas_height;
-    gAmvencbuff.bufspec->dec0_uv.buf_size = canvas_width*canvas_height/2;
     canvas_config(1 + ENC_CANVAS_OFFSET,
-        start_addr + gAmvencbuff.bufspec->dec0_uv.buf_start,
+        start_addr + wq->mem.bufspec.dec0_uv.buf_start,
         canvas_width , canvas_height/2,
         CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
     /*here the third plane use the same address as the second plane*/
     canvas_config(2 + ENC_CANVAS_OFFSET,
-        start_addr + gAmvencbuff.bufspec->dec0_uv.buf_start,
+        start_addr + wq->mem.bufspec.dec0_uv.buf_start,
         canvas_width , canvas_height/2,
         CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
 
     canvas_config(3 + ENC_CANVAS_OFFSET,
-        start_addr + gAmvencbuff.bufspec->dec1_y.buf_start,
+        start_addr + wq->mem.bufspec.dec1_y.buf_start,
         canvas_width, canvas_height,
         CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-    gAmvencbuff.bufspec->dec1_uv.buf_start = gAmvencbuff.bufspec->dec1_y.buf_start+canvas_width*canvas_height;
-    gAmvencbuff.bufspec->dec1_uv.buf_size = canvas_width*canvas_height/2;
     canvas_config(4 + ENC_CANVAS_OFFSET,
-        start_addr + gAmvencbuff.bufspec->dec1_uv.buf_start,
+        start_addr + wq->mem.bufspec.dec1_uv.buf_start,
         canvas_width , canvas_height/2,
         CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
     /*here the third plane use the same address as the second plane*/
     canvas_config(5 + ENC_CANVAS_OFFSET,
-        start_addr + gAmvencbuff.bufspec->dec1_uv.buf_start,
+        start_addr + wq->mem.bufspec.dec1_uv.buf_start,
         canvas_width , canvas_height/2,
         CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
 
-    assit_buffer_offset = start_addr + gAmvencbuff.bufspec->assit.buf_start;
-    debug_level(0,"assit_buffer_offset is %x \n",assit_buffer_offset);
-	/*output stream buffer config*/
-    BitstreamStart  = start_addr + gAmvencbuff.bufspec->bitstream.buf_start;
-    BitstreamEnd  =  BitstreamStart + gAmvencbuff.bufspec->bitstream.buf_size -1;
-
-    debug_level(0,"BitstreamStart is %x \n",BitstreamStart);
-
-    dblk_buf_canvas = ((ENC_CANVAS_OFFSET+2) <<16)|((ENC_CANVAS_OFFSET + 1) <<8)|(ENC_CANVAS_OFFSET);
-    ref_buf_canvas = ((ENC_CANVAS_OFFSET +5) <<16)|((ENC_CANVAS_OFFSET + 4) <<8)|(ENC_CANVAS_OFFSET +3);
-    debug_level(0,"dblk_buf_canvas is %d ; ref_buf_canvas is %d \n",dblk_buf_canvas , ref_buf_canvas);
+    //wq->mem.dblk_buf_canvas = ((ENC_CANVAS_OFFSET+2) <<16)|((ENC_CANVAS_OFFSET + 1) <<8)|(ENC_CANVAS_OFFSET);
+    //wq->mem.ref_buf_canvas = ((ENC_CANVAS_OFFSET +5) <<16)|((ENC_CANVAS_OFFSET + 4) <<8)|(ENC_CANVAS_OFFSET +3);
+    //encode_debug_level(LOG_LEVEL_INFO,"dblk_buf_canvas is 0x%x ; ref_buf_canvas is 0x%x, wq: %p.\n",wq->mem.dblk_buf_canvas , wq->mem.ref_buf_canvas,(void*)wq);
 }
 
-static int me_mv_merge_ctl =
-              ( 0x1 << 31)  |  // [31] me_merge_mv_en_16
-              ( 0x1 << 30)  |  // [30] me_merge_small_mv_en_16
-              ( 0x1 << 29)  |  // [29] me_merge_flex_en_16
-              ( 0x1 << 28)  |  // [28] me_merge_sad_en_16
-              ( 0x1 << 27)  |  // [27] me_merge_mv_en_8
-              ( 0x1 << 26)  |  // [26] me_merge_small_mv_en_8
-              ( 0x1 << 25)  |  // [25] me_merge_flex_en_8
-              ( 0x1 << 24)  |  // [24] me_merge_sad_en_8
-              ( 0x12 << 18)  |  // [23:18] me_merge_mv_diff_16 - MV diff <= n pixel can be merged
-              ( 0x2b << 12)  |  // [17:12] me_merge_mv_diff_8 - MV diff <= n pixel can be merged
-              ( 0x80 << 0);    // [11:0] me_merge_min_sad - SAD >= 0x180 can be merged with other MV
-              //( 0x4 << 18)  |  // [23:18] me_merge_mv_diff_16 - MV diff <= n pixel can be merged
-              //( 0x3f << 12)  |  // [17:12] me_merge_mv_diff_8 - MV diff <= n pixel can be merged
-              //( 0xc0 << 0);    // [11:0] me_merge_min_sad - SAD >= 0x180 can be merged with other MV
-
-static int me_mv_weight_01 = (0x40<<24)|(0x30<<16)|(0x20<<8)|0x30;
-
-static int me_mv_weight_23 = (0x40<<8)|0x30;
-
-static int me_sad_range_inc = 0x03030303;
-
-
-static int me_step0_close_mv = 0x003ffc21;
-static int me_f_skip_sad = 0;
-static int me_f_skip_weight = 0;
-
-static int me_sad_enough_01 = 0;//0x00018010;
-static int me_sad_enough_23 = 0;//0x00000020;
-
-#define TARGET_BITS_PER_MB 20
-
-#define P_INTRA_QUANT   30
-#define INTRA_MIN_BITS 0xffff
-
-static int p_intra_config =
-              ( P_INTRA_QUANT << 16) |
-              ( INTRA_MIN_BITS << 0);
-
-
-#define MB_INC_1_BITS                  5
-#define MB_INC_2_BITS                  10
-#define MB_INC_3_BITS                  15
-#define MB_INC_4_BITS                  20
-#define MB_DEC_1_BITS                  20
-#define MB_DEC_2_BITS                  30
-#define MB_DEC_3_BITS                  40
-#define MB_DEC_4_BITS                  60
-#define MB_MIN_QUANT                   24
-#define MB_MAX_QUANT                   24
-
-// [31:16] TARGET_BITS_PER_MB
-// [15:8] MIN_QUANT
-//  [7:0] MAX_QUANT
-static int p_mb_quant_config =
-              ( TARGET_BITS_PER_MB << 16)  |
-              ( MB_MIN_QUANT << 8)  |
-              ( MB_MAX_QUANT << 0);
-
-// [31:24] INC_4_BITS
-// [23:16] INC_3_BITS
-// [15:8]  INC_2_BITS
-// [7:0]   INC_1_BITS
-static int p_mb_quant_inc_cfg =
-              ( MB_INC_4_BITS << 24)  |
-              ( MB_INC_3_BITS << 16)  |
-              ( MB_INC_2_BITS << 8)  |
-              ( MB_INC_1_BITS << 0);
-
-// [31:24] DEC_4_BITS
-// [23:16] DEC_3_BITS
-// [15:8]  DEC_2_BITS
-// [7:0]   DEC_1_BITS
-static int p_mb_quant_dec_cfg =
-              ( MB_DEC_4_BITS << 24)  |
-              ( MB_DEC_3_BITS << 16)  |
-              ( MB_DEC_2_BITS << 8)  |
-              ( MB_DEC_1_BITS << 0);
-
-// [31:0] NUM_ROWS_PER_SLICE_P
-// [15:0] NUM_ROWS_PER_SLICE_I
-static int fixed_slice_cfg = 0;
+static void avc_buffspec_init(encode_wq_t* wq)
+{
+    u32 canvas_width, canvas_height;
+    int start_addr = wq->mem.buf_start;
+
+    canvas_width = ((wq->pic.encoder_width+31)>>5)<<5;
+    canvas_height = ((wq->pic.encoder_height+15)>>4)<<4;
+
+    /*input dct buffer config */
+    wq->mem.dct_buff_start_addr = start_addr+wq->mem.bufspec.dct.buf_start;   //(w>>4)*(h>>4)*864
+    wq->mem.dct_buff_end_addr = wq->mem.dct_buff_start_addr + wq->mem.bufspec.dct.buf_size -1 ;
+    encode_debug_level(LOG_LEVEL_INFO,"dct_buff_start_addr is 0x%x, wq:%p.\n",wq->mem.dct_buff_start_addr,(void*)wq);
+
+    wq->mem.bufspec.dec0_uv.buf_start = wq->mem.bufspec.dec0_y.buf_start+canvas_width*canvas_height;
+    wq->mem.bufspec.dec0_uv.buf_size = canvas_width*canvas_height/2;
+    wq->mem.bufspec.dec1_uv.buf_start = wq->mem.bufspec.dec1_y.buf_start+canvas_width*canvas_height;
+    wq->mem.bufspec.dec1_uv.buf_size = canvas_width*canvas_height/2;
+    wq->mem.assit_buffer_offset = start_addr + wq->mem.bufspec.assit.buf_start;
+    encode_debug_level(LOG_LEVEL_INFO,"assit_buffer_offset is 0x%x, wq: %p.\n",wq->mem.assit_buffer_offset,(void*)wq);
+    /*output stream buffer config*/
+    wq->mem.BitstreamStart  = start_addr + wq->mem.bufspec.bitstream.buf_start;
+    wq->mem.BitstreamEnd  =  wq->mem.BitstreamStart + wq->mem.bufspec.bitstream.buf_size -1;
+
+    encode_debug_level(LOG_LEVEL_INFO,"BitstreamStart is 0x%x, wq: %p. \n",wq->mem.BitstreamStart,(void*)wq);
+
+    wq->mem.dblk_buf_canvas = ((ENC_CANVAS_OFFSET+2) <<16)|((ENC_CANVAS_OFFSET + 1) <<8)|(ENC_CANVAS_OFFSET);
+    wq->mem.ref_buf_canvas = ((ENC_CANVAS_OFFSET +5) <<16)|((ENC_CANVAS_OFFSET + 4) <<8)|(ENC_CANVAS_OFFSET +3);
+    //encode_debug_level(LOG_LEVEL_INFO,"dblk_buf_canvas is %d ; ref_buf_canvas is %d, wq: %p.\n",wq->mem.dblk_buf_canvas , wq->mem.ref_buf_canvas,(void*)wq);
+}
 
 #ifdef USE_VDEC2
 static int abort_vdec2_flag = 0;
@@ -628,7 +502,7 @@ void AbortEncodeWithVdec2(int abort)
 }
 #endif
 
-static void avc_init_ie_me_parameter(void)
+static void avc_init_ie_me_parameter(encode_wq_t* wq, int quant)
 {
     ie_pippeline_block = 3;
 
@@ -639,7 +513,7 @@ static void avc_init_ie_me_parameter(void)
     }else if(ie_pippeline_block == 0){
         ie_cur_ref_sel = 0xffffffff;
     }else{
-        debug_level(1,"Error : Please calculate IE_CUR_REF_SEL for IE_PIPPELINE_BLOCK. \n");
+        encode_debug_level(LOG_LEVEL_ERROR,"Error : Please calculate IE_CUR_REF_SEL for IE_PIPPELINE_BLOCK. wq:%p \n", (void*)wq);
     }
     ie_me_mode |= (ie_pippeline_block&IE_PIPPELINE_BLOCK_MASK)<<IE_PIPPELINE_BLOCK_SHIFT; // currently disable half and sub pixel
     WRITE_HREG(IE_ME_MODE,ie_me_mode);
@@ -665,15 +539,15 @@ static void avc_init_ie_me_parameter(void)
 
     if(fixed_slice_cfg){
         WRITE_HREG(FIXED_SLICE_CFG, fixed_slice_cfg);
-    }else if(rows_per_slice !=  (encoder_height+15)>>4){
-        WRITE_HREG(FIXED_SLICE_CFG, (rows_per_slice<<16)|rows_per_slice);
+    }else if(wq->pic.rows_per_slice !=  (wq->pic.encoder_height+15)>>4){
+        WRITE_HREG(FIXED_SLICE_CFG, (wq->pic.rows_per_slice<<16)|wq->pic.rows_per_slice);
     }else{
         WRITE_HREG(FIXED_SLICE_CFG, 0);
     }
     WRITE_HREG(P_INTRA_CONFIG, p_intra_config);
     WRITE_HREG(P_MB_QUANT_CONFIG, p_mb_quant_config);
-    if(ucode_index != UCODE_MODE_SW_MIX){
-        p_mb_quant_config = ( TARGET_BITS_PER_MB << 16)  |
+    if(encode_manager.ucode_index != UCODE_MODE_SW_MIX){
+        p_mb_quant_config = ( 20 << 16)  |
               ( quant<< 8)  |
               ( quant << 0);
         WRITE_HREG(P_MB_QUANT_CONFIG, p_mb_quant_config);
@@ -752,35 +626,36 @@ static void mfdin_basic (unsigned input, unsigned char iformat, unsigned char of
     WRITE_HREG(HCODEC_MFDIN_REG9_ENDN,(7<<0)| (6<<3)|( 5<<6)|(4<<9) |(3<<12) |(2<<15) |( 1<<18) |(0<<21));
 }
 
-static int  set_input_format (amvenc_mem_type type, amvenc_frame_fmt fmt, unsigned input, unsigned offset, unsigned size, unsigned char need_flush)
+static int  set_input_format (encode_wq_t* wq, encode_request_t* request)
 {
     int ret = 0;
     unsigned char iformat = MAX_FRAME_FMT, oformat = MAX_FRAME_FMT, r2y_en = 0;
     unsigned picsize_x, picsize_y;
     unsigned canvas_w = 0;
+    unsigned input = request->src;
 
-    if((fmt == FMT_RGB565)||(fmt>=MAX_FRAME_FMT))
+    if((request->fmt == FMT_RGB565)||(request->fmt>=MAX_FRAME_FMT))
         return -1;
 
-    picsize_x = ((encoder_width+15)>>4)<<4;
-    picsize_y = ((encoder_height+15)>>4)<<4;
+    picsize_x = ((wq->pic.encoder_width+15)>>4)<<4;
+    picsize_y = ((wq->pic.encoder_height+15)>>4)<<4;
     oformat = 0;
-    if((type == LOCAL_BUFF)||(type == PHYSICAL_BUFF)){
-        if(type == LOCAL_BUFF){
-            if(need_flush)
-                dma_flush(dct_buff_start_addr + offset, size);
-            input = dct_buff_start_addr + offset;
+    if((request->type == LOCAL_BUFF)||(request->type == PHYSICAL_BUFF)){
+        if(request->type == LOCAL_BUFF){
+            if(request->flush_flag&AMVENC_FLUSH_FLAG_INPUT)
+                dma_flush(wq->mem.dct_buff_start_addr, request->framesize);
+            input = wq->mem.dct_buff_start_addr;
         }
-        if(fmt <= FMT_YUV444_PLANE)
+        if(request->fmt <= FMT_YUV444_PLANE)
             r2y_en = 0;
         else
             r2y_en = 1;
 
-        if(fmt == FMT_YUV422_SINGLE){
+        if(request->fmt == FMT_YUV422_SINGLE){
             iformat = 10;
-        }else if((fmt == FMT_YUV444_SINGLE)||(fmt== FMT_RGB888)){
+        }else if((request->fmt == FMT_YUV444_SINGLE)||(request->fmt== FMT_RGB888)){
             iformat = 1;
-            if(fmt == FMT_RGB888)
+            if(request->fmt == FMT_RGB888)
                 r2y_en = 1;
             canvas_w =  picsize_x*3;
             canvas_w =  ((canvas_w+31)>>5)<<5;
@@ -789,9 +664,9 @@ static int  set_input_format (amvenc_mem_type type, amvenc_frame_fmt fmt, unsign
                 canvas_w, picsize_y,
                 CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
             input = ENC_CANVAS_OFFSET+6;
-        }else if((fmt == FMT_NV21)||(fmt == FMT_NV12)){
-            canvas_w =  ((encoder_width+31)>>5)<<5;
-            iformat = (fmt == FMT_NV21)?2:3;
+        }else if((request->fmt == FMT_NV21)||(request->fmt == FMT_NV12)){
+            canvas_w =  ((wq->pic.encoder_width+31)>>5)<<5;
+            iformat = (request->fmt == FMT_NV21)?2:3;
             canvas_config(ENC_CANVAS_OFFSET+6,
                 input,
                 canvas_w, picsize_y,
@@ -801,9 +676,9 @@ static int  set_input_format (amvenc_mem_type type, amvenc_frame_fmt fmt, unsign
                 canvas_w , picsize_y/2,
                 CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
             input = ((ENC_CANVAS_OFFSET+7)<<8)|(ENC_CANVAS_OFFSET+6);
-        }else if(fmt == FMT_YUV420){
+        }else if(request->fmt == FMT_YUV420){
             iformat = 4;
-            canvas_w =  ((encoder_width+63)>>6)<<6;
+            canvas_w =  ((wq->pic.encoder_width+63)>>6)<<6;
             canvas_config(ENC_CANVAS_OFFSET+6,
                 input,
                 canvas_w, picsize_y,
@@ -817,11 +692,11 @@ static int  set_input_format (amvenc_mem_type type, amvenc_frame_fmt fmt, unsign
                 canvas_w/2 , picsize_y/2,
                 CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
             input = ((ENC_CANVAS_OFFSET+8)<<16)|((ENC_CANVAS_OFFSET+7)<<8)|(ENC_CANVAS_OFFSET+6);
-        }else if((fmt == FMT_YUV444_PLANE)||(fmt == FMT_RGB888_PLANE)){
-            if(fmt == FMT_RGB888_PLANE)
+        }else if((request->fmt == FMT_YUV444_PLANE)||(request->fmt == FMT_RGB888_PLANE)){
+            if(request->fmt == FMT_RGB888_PLANE)
                 r2y_en = 1;
             iformat = 5;
-            canvas_w =  ((encoder_width+31)>>5)<<5;
+            canvas_w =  ((wq->pic.encoder_width+31)>>5)<<5;
             canvas_config(ENC_CANVAS_OFFSET+6,
                 input,
                 canvas_w, picsize_y,
@@ -835,26 +710,26 @@ static int  set_input_format (amvenc_mem_type type, amvenc_frame_fmt fmt, unsign
                 canvas_w, picsize_y,
                 CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
             input = ((ENC_CANVAS_OFFSET+8)<<16)|((ENC_CANVAS_OFFSET+7)<<8)|(ENC_CANVAS_OFFSET+6);
-        }else if(fmt == FMT_RGBA8888){
+        }else if(request->fmt == FMT_RGBA8888){
             iformat = 12;
         }
         ret = 0;
-    }else if(type == CANVAS_BUFF){
+    }else if(request->type == CANVAS_BUFF){
         r2y_en = 0;
-        if(fmt == FMT_YUV422_SINGLE){
+        if(request->fmt == FMT_YUV422_SINGLE){
             iformat = 0;
             input = input&0xff;
-        }else if(fmt == FMT_YUV444_SINGLE){
+        }else if(request->fmt == FMT_YUV444_SINGLE){
             iformat = 1;
             input = input&0xff;
-        }else if((fmt == FMT_NV21)||(fmt == FMT_NV12)){
-            iformat = (fmt == FMT_NV21)?2:3;
+        }else if((request->fmt == FMT_NV21)||(request->fmt == FMT_NV12)){
+            iformat = (request->fmt == FMT_NV21)?2:3;
             input = input&0xffff;
-        }else if(fmt == FMT_YUV420){
+        }else if(request->fmt == FMT_YUV420){
             iformat = 4;
             input = input&0xffffff;
-        }else if((fmt == FMT_YUV444_PLANE)||(fmt == FMT_RGB888_PLANE)){
-            if(fmt == FMT_RGB888_PLANE)
+        }else if((request->fmt == FMT_YUV444_PLANE)||(request->fmt == FMT_RGB888_PLANE)){
+            if(request->fmt == FMT_RGB888_PLANE)
                 r2y_en = 1;
             iformat = 5;
             input = input&0xffffff;
@@ -864,184 +739,136 @@ static int  set_input_format (amvenc_mem_type type, amvenc_frame_fmt fmt, unsign
     }
     if(ret == 0)
         mfdin_basic(input,iformat,oformat,picsize_x,picsize_y,r2y_en);
+    wq->control.finish = true;
     return ret;
 }
 
-static void encode_isr_tasklet(ulong data)
-{
-    debug_level(0,"encoder is done %d\n",encoder_status);
-    if(((encoder_status == ENCODER_IDR_DONE)
-	||(encoder_status == ENCODER_NON_IDR_DONE))&&(process_irq)){
-#ifdef USE_VDEC2
-        if(IS_MESON_M8_CPU){
-            if((abort_vdec2_flag)&&(get_vdec2_usage() == USAGE_ENCODE))
-                set_vdec2_usage(USAGE_NONE);
-        }
-#endif
-        atomic_inc(&avc_ready);
-        wake_up_interruptible(&avc_wait);
-    }
-}
-
-static irqreturn_t enc_isr(int irq, void *dev_id)
-{
-	WRITE_HREG(HCODEC_IRQ_MBOX_CLR, 1);
-
-#ifdef DEBUG_UCODE
-//rain
-       if(READ_HREG(DEBUG_REG)!=0){
-            printk("dbg%x: %x\n",  READ_HREG(DEBUG_REG), READ_HREG(HENC_SCRATCH_1));
-            WRITE_HREG(DEBUG_REG, 0);
-            return IRQ_HANDLED;
-       }
-#endif
-
-	encoder_status  = READ_HREG(ENCODER_STATUS);
-	if((encoder_status == ENCODER_IDR_DONE)
-	||(encoder_status == ENCODER_NON_IDR_DONE)
-	||(encoder_status == ENCODER_SEQUENCE_DONE)
-	||(encoder_status == ENCODER_PICTURE_DONE)){
-		debug_level(0,"encoder stage is %d\n",encoder_status);
-	}
-	if(encoder_status == ENCODER_PICTURE_DONE)
-		frame_start = 1;
-	if(((encoder_status == ENCODER_IDR_DONE)
-	||(encoder_status == ENCODER_NON_IDR_DONE))&&(!process_irq)){
-		process_irq = 1;
-		frame_start = 1;
-		tasklet_schedule(&encode_tasklet);
-	}
-	return IRQ_HANDLED;
-}
-
-static void avc_prot_init(bool IDR)
+static void avc_prot_init(encode_wq_t*wq, int quant,bool IDR)
 {
-	unsigned int data32;
-
-	int pic_width, pic_height;
-	int pic_mb_nr;
-	int pic_mbx, pic_mby;
-	int i_pic_qp, p_pic_qp;
-
-	int i_pic_qp_c, p_pic_qp_c;
-	pic_width  = encoder_width;
-	pic_height = encoder_height;
-	pic_mb_nr  = 0;
-	pic_mbx    = 0;
-	pic_mby    = 0;
-	i_pic_qp   = quant;
-	p_pic_qp   = quant;
-	WRITE_HREG(VLC_PIC_SIZE, pic_width | (pic_height<<16));
-	WRITE_HREG(VLC_PIC_POSITION, (pic_mb_nr<<16) | (pic_mby << 8) |  (pic_mbx <<0));	//start mb
+    unsigned int data32;
+    int pic_width, pic_height;
+    int pic_mb_nr;
+    int pic_mbx, pic_mby;
+    int i_pic_qp, p_pic_qp;
+    int i_pic_qp_c, p_pic_qp_c;
+    pic_width  = wq->pic.encoder_width;
+    pic_height = wq->pic.encoder_height;
+    pic_mb_nr  = 0;
+    pic_mbx    = 0;
+    pic_mby    = 0;
+    i_pic_qp   = quant;
+    p_pic_qp   = quant;
+    WRITE_HREG(VLC_PIC_SIZE, pic_width | (pic_height<<16));
+    WRITE_HREG(VLC_PIC_POSITION, (pic_mb_nr<<16) | (pic_mby << 8) |  (pic_mbx <<0));	//start mb
 
     switch (i_pic_qp) {    // synopsys parallel_case full_case
-      case 0 : i_pic_qp_c = 0; break;
-      case 1 : i_pic_qp_c = 1; break;
-      case 2 : i_pic_qp_c = 2; break;
-      case 3 : i_pic_qp_c = 3; break;
-      case 4 : i_pic_qp_c = 4; break;
-      case 5 : i_pic_qp_c = 5; break;
-      case 6 : i_pic_qp_c = 6; break;
-      case 7 : i_pic_qp_c = 7; break;
-      case 8 : i_pic_qp_c = 8; break;
-      case 9 : i_pic_qp_c = 9; break;
-      case 10 : i_pic_qp_c = 10; break;
-      case 11 : i_pic_qp_c = 11; break;
-      case 12 : i_pic_qp_c = 12; break;
-      case 13 : i_pic_qp_c = 13; break;
-      case 14 : i_pic_qp_c = 14; break;
-      case 15 : i_pic_qp_c = 15; break;
-      case 16 : i_pic_qp_c = 16; break;
-      case 17 : i_pic_qp_c = 17; break;
-      case 18 : i_pic_qp_c = 18; break;
-      case 19 : i_pic_qp_c = 19; break;
-      case 20 : i_pic_qp_c = 20; break;
-      case 21 : i_pic_qp_c = 21; break;
-      case 22 : i_pic_qp_c = 22; break;
-      case 23 : i_pic_qp_c = 23; break;
-      case 24 : i_pic_qp_c = 24; break;
-      case 25 : i_pic_qp_c = 25; break;
-      case 26 : i_pic_qp_c = 26; break;
-      case 27 : i_pic_qp_c = 27; break;
-      case 28 : i_pic_qp_c = 28; break;
-      case 29 : i_pic_qp_c = 29; break;
-      case 30 : i_pic_qp_c = 29; break;
-      case 31 : i_pic_qp_c = 30; break;
-      case 32 : i_pic_qp_c = 31; break;
-      case 33 : i_pic_qp_c = 32; break;
-      case 34 : i_pic_qp_c = 32; break;
-      case 35 : i_pic_qp_c = 33; break;
-      case 36 : i_pic_qp_c = 34; break;
-      case 37 : i_pic_qp_c = 34; break;
-      case 38 : i_pic_qp_c = 35; break;
-      case 39 : i_pic_qp_c = 35; break;
-      case 40 : i_pic_qp_c = 36; break;
-      case 41 : i_pic_qp_c = 36; break;
-      case 42 : i_pic_qp_c = 37; break;
-      case 43 : i_pic_qp_c = 37; break;
-      case 44 : i_pic_qp_c = 37; break;
-      case 45 : i_pic_qp_c = 38; break;
-      case 46 : i_pic_qp_c = 38; break;
-      case 47 : i_pic_qp_c = 38; break;
-      case 48 : i_pic_qp_c = 39; break;
-      case 49 : i_pic_qp_c = 39; break;
-      case 50 : i_pic_qp_c = 39; break;
-    default : i_pic_qp_c = 39; break; // should only be 51 or more (when index_offset)
+        case 0 : i_pic_qp_c = 0; break;
+        case 1 : i_pic_qp_c = 1; break;
+        case 2 : i_pic_qp_c = 2; break;
+        case 3 : i_pic_qp_c = 3; break;
+        case 4 : i_pic_qp_c = 4; break;
+        case 5 : i_pic_qp_c = 5; break;
+        case 6 : i_pic_qp_c = 6; break;
+        case 7 : i_pic_qp_c = 7; break;
+        case 8 : i_pic_qp_c = 8; break;
+        case 9 : i_pic_qp_c = 9; break;
+        case 10 : i_pic_qp_c = 10; break;
+        case 11 : i_pic_qp_c = 11; break;
+        case 12 : i_pic_qp_c = 12; break;
+        case 13 : i_pic_qp_c = 13; break;
+        case 14 : i_pic_qp_c = 14; break;
+        case 15 : i_pic_qp_c = 15; break;
+        case 16 : i_pic_qp_c = 16; break;
+        case 17 : i_pic_qp_c = 17; break;
+        case 18 : i_pic_qp_c = 18; break;
+        case 19 : i_pic_qp_c = 19; break;
+        case 20 : i_pic_qp_c = 20; break;
+        case 21 : i_pic_qp_c = 21; break;
+        case 22 : i_pic_qp_c = 22; break;
+        case 23 : i_pic_qp_c = 23; break;
+        case 24 : i_pic_qp_c = 24; break;
+        case 25 : i_pic_qp_c = 25; break;
+        case 26 : i_pic_qp_c = 26; break;
+        case 27 : i_pic_qp_c = 27; break;
+        case 28 : i_pic_qp_c = 28; break;
+        case 29 : i_pic_qp_c = 29; break;
+        case 30 : i_pic_qp_c = 29; break;
+        case 31 : i_pic_qp_c = 30; break;
+        case 32 : i_pic_qp_c = 31; break;
+        case 33 : i_pic_qp_c = 32; break;
+        case 34 : i_pic_qp_c = 32; break;
+        case 35 : i_pic_qp_c = 33; break;
+        case 36 : i_pic_qp_c = 34; break;
+        case 37 : i_pic_qp_c = 34; break;
+        case 38 : i_pic_qp_c = 35; break;
+        case 39 : i_pic_qp_c = 35; break;
+        case 40 : i_pic_qp_c = 36; break;
+        case 41 : i_pic_qp_c = 36; break;
+        case 42 : i_pic_qp_c = 37; break;
+        case 43 : i_pic_qp_c = 37; break;
+        case 44 : i_pic_qp_c = 37; break;
+        case 45 : i_pic_qp_c = 38; break;
+        case 46 : i_pic_qp_c = 38; break;
+        case 47 : i_pic_qp_c = 38; break;
+        case 48 : i_pic_qp_c = 39; break;
+        case 49 : i_pic_qp_c = 39; break;
+        case 50 : i_pic_qp_c = 39; break;
+        default : i_pic_qp_c = 39; break; // should only be 51 or more (when index_offset)
     }
 
     switch (p_pic_qp) {    // synopsys parallel_case full_case
-      case 0 : p_pic_qp_c = 0; break;
-      case 1 : p_pic_qp_c = 1; break;
-      case 2 : p_pic_qp_c = 2; break;
-      case 3 : p_pic_qp_c = 3; break;
-      case 4 : p_pic_qp_c = 4; break;
-      case 5 : p_pic_qp_c = 5; break;
-      case 6 : p_pic_qp_c = 6; break;
-      case 7 : p_pic_qp_c = 7; break;
-      case 8 : p_pic_qp_c = 8; break;
-      case 9 : p_pic_qp_c = 9; break;
-      case 10 : p_pic_qp_c = 10; break;
-      case 11 : p_pic_qp_c = 11; break;
-      case 12 : p_pic_qp_c = 12; break;
-      case 13 : p_pic_qp_c = 13; break;
-      case 14 : p_pic_qp_c = 14; break;
-      case 15 : p_pic_qp_c = 15; break;
-      case 16 : p_pic_qp_c = 16; break;
-      case 17 : p_pic_qp_c = 17; break;
-      case 18 : p_pic_qp_c = 18; break;
-      case 19 : p_pic_qp_c = 19; break;
-      case 20 : p_pic_qp_c = 20; break;
-      case 21 : p_pic_qp_c = 21; break;
-      case 22 : p_pic_qp_c = 22; break;
-      case 23 : p_pic_qp_c = 23; break;
-      case 24 : p_pic_qp_c = 24; break;
-      case 25 : p_pic_qp_c = 25; break;
-      case 26 : p_pic_qp_c = 26; break;
-      case 27 : p_pic_qp_c = 27; break;
-      case 28 : p_pic_qp_c = 28; break;
-      case 29 : p_pic_qp_c = 29; break;
-      case 30 : p_pic_qp_c = 29; break;
-      case 31 : p_pic_qp_c = 30; break;
-      case 32 : p_pic_qp_c = 31; break;
-      case 33 : p_pic_qp_c = 32; break;
-      case 34 : p_pic_qp_c = 32; break;
-      case 35 : p_pic_qp_c = 33; break;
-      case 36 : p_pic_qp_c = 34; break;
-      case 37 : p_pic_qp_c = 34; break;
-      case 38 : p_pic_qp_c = 35; break;
-      case 39 : p_pic_qp_c = 35; break;
-      case 40 : p_pic_qp_c = 36; break;
-      case 41 : p_pic_qp_c = 36; break;
-      case 42 : p_pic_qp_c = 37; break;
-      case 43 : p_pic_qp_c = 37; break;
-      case 44 : p_pic_qp_c = 37; break;
-      case 45 : p_pic_qp_c = 38; break;
-      case 46 : p_pic_qp_c = 38; break;
-      case 47 : p_pic_qp_c = 38; break;
-      case 48 : p_pic_qp_c = 39; break;
-      case 49 : p_pic_qp_c = 39; break;
-      case 50 : p_pic_qp_c = 39; break;
-    default : p_pic_qp_c = 39; break; // should only be 51 or more (when index_offset)
+        case 0 : p_pic_qp_c = 0; break;
+        case 1 : p_pic_qp_c = 1; break;
+        case 2 : p_pic_qp_c = 2; break;
+        case 3 : p_pic_qp_c = 3; break;
+        case 4 : p_pic_qp_c = 4; break;
+        case 5 : p_pic_qp_c = 5; break;
+        case 6 : p_pic_qp_c = 6; break;
+        case 7 : p_pic_qp_c = 7; break;
+        case 8 : p_pic_qp_c = 8; break;
+        case 9 : p_pic_qp_c = 9; break;
+        case 10 : p_pic_qp_c = 10; break;
+        case 11 : p_pic_qp_c = 11; break;
+        case 12 : p_pic_qp_c = 12; break;
+        case 13 : p_pic_qp_c = 13; break;
+        case 14 : p_pic_qp_c = 14; break;
+        case 15 : p_pic_qp_c = 15; break;
+        case 16 : p_pic_qp_c = 16; break;
+        case 17 : p_pic_qp_c = 17; break;
+        case 18 : p_pic_qp_c = 18; break;
+        case 19 : p_pic_qp_c = 19; break;
+        case 20 : p_pic_qp_c = 20; break;
+        case 21 : p_pic_qp_c = 21; break;
+        case 22 : p_pic_qp_c = 22; break;
+        case 23 : p_pic_qp_c = 23; break;
+        case 24 : p_pic_qp_c = 24; break;
+        case 25 : p_pic_qp_c = 25; break;
+        case 26 : p_pic_qp_c = 26; break;
+        case 27 : p_pic_qp_c = 27; break;
+        case 28 : p_pic_qp_c = 28; break;
+        case 29 : p_pic_qp_c = 29; break;
+        case 30 : p_pic_qp_c = 29; break;
+        case 31 : p_pic_qp_c = 30; break;
+        case 32 : p_pic_qp_c = 31; break;
+        case 33 : p_pic_qp_c = 32; break;
+        case 34 : p_pic_qp_c = 32; break;
+        case 35 : p_pic_qp_c = 33; break;
+        case 36 : p_pic_qp_c = 34; break;
+        case 37 : p_pic_qp_c = 34; break;
+        case 38 : p_pic_qp_c = 35; break;
+        case 39 : p_pic_qp_c = 35; break;
+        case 40 : p_pic_qp_c = 36; break;
+        case 41 : p_pic_qp_c = 36; break;
+        case 42 : p_pic_qp_c = 37; break;
+        case 43 : p_pic_qp_c = 37; break;
+        case 44 : p_pic_qp_c = 37; break;
+        case 45 : p_pic_qp_c = 38; break;
+        case 46 : p_pic_qp_c = 38; break;
+        case 47 : p_pic_qp_c = 38; break;
+        case 48 : p_pic_qp_c = 39; break;
+        case 49 : p_pic_qp_c = 39; break;
+        case 50 : p_pic_qp_c = 39; break;
+        default : p_pic_qp_c = 39; break; // should only be 51 or more (when index_offset)
     }
     WRITE_HREG(QDCT_Q_QUANT_I,
                 (i_pic_qp_c<<22) |
@@ -1076,7 +903,7 @@ static void avc_prot_init(bool IDR)
                 (1<<9) | // mb_info_soft_reset
                 (1<<0)); // mb read buffer soft reset
 
-    if(ucode_index != UCODE_MODE_SW_MIX){
+    if(encode_manager.ucode_index != UCODE_MODE_SW_MIX){
         WRITE_HREG(QDCT_MB_CONTROL,
                   (0<<28) | // ignore_t_p8x8
                   (0<<27) | // zero_mc_out_null_non_skipped_mb
@@ -1118,7 +945,7 @@ static void avc_prot_init(bool IDR)
                   (0<<0));   // soft reset
     }
 
-    if(ucode_index != UCODE_MODE_SW_MIX){
+    if(encode_manager.ucode_index != UCODE_MODE_SW_MIX){
         int me_mode  = (ie_me_mode >>ME_PIXEL_MODE_SHIFT)&ME_PIXEL_MODE_MASK;
         WRITE_HREG(SAD_CONTROL,
                   (0<<3) | // ie_result_buff_enable
@@ -1202,21 +1029,20 @@ static void avc_prot_init(bool IDR)
     }
 
     WRITE_HREG(HCODEC_CURR_CANVAS_CTRL,0);
-    //debug_level(0,"current endian is %d \n" , avc_endian);
     data32 = READ_HREG(VLC_CONFIG);
     data32 = data32 | (1<<0); // set pop_coeff_even_all_zero
     WRITE_HREG(VLC_CONFIG , data32);
 
-    if(ucode_index != UCODE_MODE_SW_MIX){
+    if(encode_manager.ucode_index != UCODE_MODE_SW_MIX){
         if(IDR){
-            WRITE_HREG(BITS_INFO_DDR_START, intra_bits_info_ddr_start_addr);
-            WRITE_HREG(MV_INFO_DDR_START,intra_pred_info_ddr_start_addr);
+            WRITE_HREG(BITS_INFO_DDR_START, wq->mem.intra_bits_info_ddr_start_addr);
+            WRITE_HREG(MV_INFO_DDR_START, wq->mem.intra_pred_info_ddr_start_addr);
         }else{
-            WRITE_HREG(BITS_INFO_DDR_START, inter_bits_info_ddr_start_addr);
-            WRITE_HREG(MV_INFO_DDR_START, inter_mv_info_ddr_start_addr);
+            WRITE_HREG(BITS_INFO_DDR_START, wq->mem.inter_bits_info_ddr_start_addr);
+            WRITE_HREG(MV_INFO_DDR_START, wq->mem.inter_mv_info_ddr_start_addr);
         }
     }else{
-        WRITE_HREG(SW_CTL_INFO_DDR_START,sw_ctl_info_start_addr);
+        WRITE_HREG(SW_CTL_INFO_DDR_START, wq->mem.sw_ctl_info_start_addr);
     }
     /* clear mailbox interrupt */
     WRITE_HREG(HCODEC_IRQ_MBOX_CLR, 1);
@@ -1280,18 +1106,18 @@ void amvenc_stop(void)
 static void __iomem *mc_addr=NULL;
 static unsigned mc_addr_map;
 #define MC_SIZE (4096 * 4)
-s32 amvenc_loadmc(const u32 *p)
+s32 amvenc_loadmc(const u32 *p, encode_wq_t* wq)
 {
     ulong timeout;
     s32 ret = 0 ;
 
-    mc_addr_map = assit_buffer_offset;
+    mc_addr_map = wq->mem.assit_buffer_offset;
     mc_addr = ioremap_wc(mc_addr_map,MC_SIZE);
     memcpy(mc_addr, p, MC_SIZE);
-    debug_level(0,"address 0 is 0x%x\n", *((u32*)mc_addr));
-    debug_level(0,"address 1 is 0x%x\n", *((u32*)mc_addr + 1));
-    debug_level(0,"address 2 is 0x%x\n", *((u32*)mc_addr + 2));
-    debug_level(0,"address 3 is 0x%x\n", *((u32*)mc_addr + 3));
+    encode_debug_level(LOG_LEVEL_ALL, "address 0 is 0x%x\n", *((u32*)mc_addr));
+    encode_debug_level(LOG_LEVEL_ALL, "address 1 is 0x%x\n", *((u32*)mc_addr + 1));
+    encode_debug_level(LOG_LEVEL_ALL, "address 2 is 0x%x\n", *((u32*)mc_addr + 2));
+    encode_debug_level(LOG_LEVEL_ALL, "address 3 is 0x%x\n", *((u32*)mc_addr + 3));
     WRITE_HREG(HCODEC_MPSR, 0);
     WRITE_HREG(HCODEC_CPSR, 0);
 
@@ -1309,7 +1135,7 @@ s32 amvenc_loadmc(const u32 *p)
         if (time_before(jiffies, timeout)) {
             schedule();
         } else {
-            debug_level(1,"hcodec load mc error\n");
+            encode_debug_level(LOG_LEVEL_ERROR, "hcodec load mc error\n");
             ret = -EBUSY;
             break;
         }
@@ -1375,7 +1201,7 @@ bool amvenc_avc_on(void)
     spin_lock_irqsave(&lock, flags);
 
     hcodec_on = vdec_on(VDEC_HCODEC);
-    hcodec_on |=(encode_opened>0);
+    hcodec_on &=(encode_manager.wq_count>0);
 
     spin_unlock_irqrestore(&lock, flags);
     return hcodec_on;
@@ -1389,152 +1215,114 @@ bool amvenc_avc_on(void)
 void enable_hcoder_ddr_access(void)
 {
 #if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
-	WRITE_SEC_REG(DMC_SEC_PORT8_RANGE0 , 0xffff);
-	WRITE_SEC_REG(DMC_SEC_CTRL , 0x80000000);
+    WRITE_SEC_REG(DMC_SEC_PORT8_RANGE0 , 0xffff);
+    WRITE_SEC_REG(DMC_SEC_CTRL , 0x80000000);
 #endif
 }
 
 static s32 avc_poweron(int clock)
 {
-	unsigned long flags;
-	u32 data32 = 0;
-	data32 = 0;
-	enable_hcoder_ddr_access();
+    unsigned long flags;
+    u32 data32 = 0;
+    data32 = 0;
+    enable_hcoder_ddr_access();
 
-	//CLK_GATE_ON(DOS);
-	switch_mod_gate_by_name("vdec", 1);
+    //CLK_GATE_ON(DOS);
+    switch_mod_gate_by_name("vdec", 1);
 
-	spin_lock_irqsave(&lock, flags);
+    spin_lock_irqsave(&lock, flags);
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	data32 = READ_AOREG(AO_RTI_PWR_CNTL_REG0);
-	data32 = data32 & (~(0x18));
-	WRITE_AOREG(AO_RTI_PWR_CNTL_REG0, data32);
-	udelay(10);
-	// Powerup HCODEC
-	data32 = READ_AOREG(AO_RTI_GEN_PWR_SLEEP0); // [1:0] HCODEC
-	data32 = data32 & (~0x3);
-	WRITE_AOREG(AO_RTI_GEN_PWR_SLEEP0, data32);
-	udelay(10);
+    data32 = READ_AOREG(AO_RTI_PWR_CNTL_REG0);
+    data32 = data32 & (~(0x18));
+    WRITE_AOREG(AO_RTI_PWR_CNTL_REG0, data32);
+    udelay(10);
+    // Powerup HCODEC
+    data32 = READ_AOREG(AO_RTI_GEN_PWR_SLEEP0); // [1:0] HCODEC
+    data32 = data32 & (~0x3);
+    WRITE_AOREG(AO_RTI_GEN_PWR_SLEEP0, data32);
+    udelay(10);
 #endif
 
-	WRITE_VREG(DOS_SW_RESET1, 0xffffffff);
-	WRITE_VREG(DOS_SW_RESET1, 0);
+    WRITE_VREG(DOS_SW_RESET1, 0xffffffff);
+    WRITE_VREG(DOS_SW_RESET1, 0);
 
-	// Enable Dos internal clock gating
-	hvdec_clock_enable(clock);
+    // Enable Dos internal clock gating
+    hvdec_clock_enable(clock);
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	//Powerup HCODEC memories
-	WRITE_VREG(DOS_MEM_PD_HCODEC, 0x0);
-
-	// Remove HCODEC ISO
-	data32 = READ_AOREG(AO_RTI_GEN_PWR_ISO0);
-	data32 = data32 & (~(0x30));
-	WRITE_AOREG(AO_RTI_GEN_PWR_ISO0, data32);
-	udelay(10);
+    //Powerup HCODEC memories
+    WRITE_VREG(DOS_MEM_PD_HCODEC, 0x0);
+
+    // Remove HCODEC ISO
+    data32 = READ_AOREG(AO_RTI_GEN_PWR_ISO0);
+    data32 = data32 & (~(0x30));
+    WRITE_AOREG(AO_RTI_GEN_PWR_ISO0, data32);
+    udelay(10);
 #endif
-	// Disable auto-clock gate
-	data32 = READ_VREG(DOS_GEN_CTRL0);
-	data32 = data32 | 0x1;
-	WRITE_VREG(DOS_GEN_CTRL0, data32);
-	data32 = READ_VREG(DOS_GEN_CTRL0);
-	data32 = data32 & 0xFFFFFFFE;
-	WRITE_VREG(DOS_GEN_CTRL0, data32);
+    // Disable auto-clock gate
+    data32 = READ_VREG(DOS_GEN_CTRL0);
+    data32 = data32 | 0x1;
+    WRITE_VREG(DOS_GEN_CTRL0, data32);
+    data32 = READ_VREG(DOS_GEN_CTRL0);
+    data32 = data32 & 0xFFFFFFFE;
+    WRITE_VREG(DOS_GEN_CTRL0, data32);
 
 #ifdef USE_VDEC2
-	if(IS_MESON_M8_CPU){
-		if (!vdec_on(VDEC_2) && get_vdec2_usage() == USAGE_NONE) {//++++
-			set_vdec2_usage(USAGE_ENCODE);
-			vdec_poweron(VDEC_2);//++++
-		}
-	}
+    if(IS_MESON_M8_CPU){
+        if (!vdec_on(VDEC_2) && get_vdec2_usage() == USAGE_NONE) {//++++
+            set_vdec2_usage(USAGE_ENCODE);
+            vdec_poweron(VDEC_2);//++++
+        }
+    }
 #endif
 
-	spin_unlock_irqrestore(&lock, flags);
-
-	mdelay(10);
+    spin_unlock_irqrestore(&lock, flags);
 
-	return 0;
+    mdelay(10);
+    return 0;
 }
 
 static s32 avc_poweroff(void)
 {
-	unsigned long flags;
+    unsigned long flags;
 
-	spin_lock_irqsave(&lock, flags);
+    spin_lock_irqsave(&lock, flags);
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	// enable HCODEC isolation
-	WRITE_AOREG(AO_RTI_GEN_PWR_ISO0, READ_AOREG(AO_RTI_GEN_PWR_ISO0) | 0x30);
-	// power off HCODEC memories
-	WRITE_VREG(DOS_MEM_PD_HCODEC, 0xffffffffUL);
+    // enable HCODEC isolation
+    WRITE_AOREG(AO_RTI_GEN_PWR_ISO0, READ_AOREG(AO_RTI_GEN_PWR_ISO0) | 0x30);
+    // power off HCODEC memories
+    WRITE_VREG(DOS_MEM_PD_HCODEC, 0xffffffffUL);
 #endif
-	// disable HCODEC clock
-	hvdec_clock_disable();
+    // disable HCODEC clock
+    hvdec_clock_disable();
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	// HCODEC power off
-	WRITE_AOREG(AO_RTI_GEN_PWR_SLEEP0, READ_AOREG(AO_RTI_GEN_PWR_SLEEP0) | 0x3);
+    // HCODEC power off
+    WRITE_AOREG(AO_RTI_GEN_PWR_SLEEP0, READ_AOREG(AO_RTI_GEN_PWR_SLEEP0) | 0x3);
 #endif
 
 #ifdef USE_VDEC2
-	if(IS_MESON_M8_CPU){
-		if (vdec_on(VDEC_2) && get_vdec2_usage() != USAGE_DEC_4K2K) {//++++
-			vdec_poweroff(VDEC_2);//++++
-			set_vdec2_usage(USAGE_NONE);
-		}
-	}
+    if(IS_MESON_M8_CPU){
+        if (vdec_on(VDEC_2) && get_vdec2_usage() != USAGE_DEC_4K2K) {//++++
+            vdec_poweroff(VDEC_2);//++++
+            set_vdec2_usage(USAGE_NONE);
+        }
+    }
 #endif
 
-	spin_unlock_irqrestore(&lock, flags);
-
-	// release DOS clk81 clock gating
-	//CLK_GATE_OFF(DOS);
-	switch_mod_gate_by_name("vdec", 0);
+    spin_unlock_irqrestore(&lock, flags);
 
-	return 0;
+    // release DOS clk81 clock gating
+    //CLK_GATE_OFF(DOS);
+    switch_mod_gate_by_name("vdec", 0);
+    return 0;
 }
 
-static s32 reload_mc(void)
+static s32 reload_mc(encode_wq_t* wq)
 {
-    const u32 * p = mix_dump_mc;
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    switch(ucode_index){
-        case UCODE_MODE_FULL:
-            if(enable_dblk)
-                p = mix_dump_mc_dblk;
-            else
-                p = mix_dump_mc;
-            break;
-        case UCODE_MODE_SW_MIX:
-            if(IS_MESON_M8B_CPU){
-                if(enable_dblk)
-                    p = mix_sw_mc_hdec_dblk;
-                else
-                    p = mix_sw_mc;
-            }
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
-            else if(IS_MESON_M8_CPU){
-                if(enable_dblk == 1)
-                    p = mix_sw_mc_vdec2_dblk;
-                else if (enable_dblk ==2)
-                    p = mix_sw_mc_hdec_dblk;
-                else
-                    p = mix_sw_mc;
-            }else if(IS_MESON_M8M2_CPU){
-                if(enable_dblk)
-                    p = mix_sw_mc_hdec_m2_dblk;
-                else
-                    p = mix_sw_mc;
-            }
-#endif
-            break;
-        default:
-            break;
-    }
-#endif
+    const u32 * p = select_ucode(encode_manager.ucode_index);
 
     amvenc_stop();
 
@@ -1546,130 +1334,390 @@ static s32 reload_mc(void)
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
     if(IS_MESON_M8M2_CPU){
         WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x32);
-        dblk_fix_flag = (p==mix_sw_mc_hdec_m2_dblk);
     }else{
         WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x2);
-        dblk_fix_flag = false;
     }
 #else
     WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x2);
-    dblk_fix_flag = false;
 #endif
 
-    debug_level(0,"reload microcode\n");
+    encode_debug_level(LOG_LEVEL_INFO,"reload microcode\n");
 
-    if (amvenc_loadmc(p) < 0) {
-        //amvdec_disable();
+    if (amvenc_loadmc(p,wq) < 0) {
         return -EBUSY;
     }
     return 0;
 }
 
-static s32 avc_init(void)
+static void encode_isr_tasklet(ulong data)
 {
-    int r;
-    const u32 * p = mix_dump_mc;
+    encode_manager_t*  manager = (encode_manager_t*)data ;
+    encode_debug_level(LOG_LEVEL_INFO,"encoder is done %d\n",manager->encode_hw_status);
+    if(((manager->encode_hw_status == ENCODER_IDR_DONE)
+      ||(manager->encode_hw_status == ENCODER_NON_IDR_DONE)
+      ||(manager->encode_hw_status == ENCODER_SEQUENCE_DONE)
+      ||(manager->encode_hw_status == ENCODER_PICTURE_DONE))&&(manager->process_irq)){
+#ifdef USE_VDEC2
+        if(IS_MESON_M8_CPU){
+            if((abort_vdec2_flag)&&(get_vdec2_usage() == USAGE_ENCODE))
+                set_vdec2_usage(USAGE_NONE);
+        }
+#endif
+        wake_up_interruptible(&manager->event.hw_complete);
+    }
+}
 
-    avc_poweron(clock_level);
-    avc_canvas_init();
+// irq function
+static irqreturn_t enc_isr(int  irq_number, void *para)
+{
+    encode_manager_t*  manager = (encode_manager_t*)para ;
+    WRITE_HREG(HCODEC_IRQ_MBOX_CLR, 1);
 
-    debug_level(1,"start to load microcode %d\n", ucode_index);
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    switch(ucode_index){
-        case UCODE_MODE_FULL:
-            if(enable_dblk)
-                p = mix_dump_mc_dblk;
-            else
-                p = mix_dump_mc;
-            break;
-        case UCODE_MODE_SW_MIX:
-            if(IS_MESON_M8B_CPU){
-                if(enable_dblk)
-                    p = mix_sw_mc_hdec_dblk;
-                else
-                    p = mix_sw_mc;
-            }
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
-            else if(IS_MESON_M8_CPU){
-                if(enable_dblk == 1)
-                    p = mix_sw_mc_vdec2_dblk;
-                else if (enable_dblk ==2)
-                    p = mix_sw_mc_hdec_dblk;
-                else
-                    p = mix_sw_mc;
-            }else if(IS_MESON_M8M2_CPU){
-                if(enable_dblk)
-                    p = mix_sw_mc_hdec_m2_dblk;
-                else
-                    p = mix_sw_mc;
+#ifdef DEBUG_UCODE
+//rain
+    if(READ_HREG(DEBUG_REG)!=0){
+        printk("dbg%x: %x\n",  READ_HREG(DEBUG_REG), READ_HREG(HENC_SCRATCH_1));
+        WRITE_HREG(DEBUG_REG, 0);
+        return IRQ_HANDLED;
+    }
+#endif
+
+    manager->encode_hw_status  = READ_HREG(ENCODER_STATUS);
+    if((manager->encode_hw_status == ENCODER_IDR_DONE)
+      ||(manager->encode_hw_status == ENCODER_NON_IDR_DONE)
+      ||(manager->encode_hw_status == ENCODER_SEQUENCE_DONE)
+      ||(manager->encode_hw_status == ENCODER_PICTURE_DONE)){
+        encode_debug_level(LOG_LEVEL_ALL, "encoder stage is %d\n",manager->encode_hw_status);
+    }
+
+    if(((manager->encode_hw_status == ENCODER_IDR_DONE)
+      ||(manager->encode_hw_status == ENCODER_NON_IDR_DONE)
+      ||(manager->encode_hw_status == ENCODER_SEQUENCE_DONE)
+      ||(manager->encode_hw_status == ENCODER_PICTURE_DONE))&&(!manager->process_irq)){
+        manager->process_irq = true;
+        if(manager->encode_hw_status != ENCODER_SEQUENCE_DONE)
+            manager->need_reset = true;
+        tasklet_schedule(&manager->encode_tasklet);
+    }
+    return IRQ_HANDLED;
+}
+
+static s32 convert_request(encode_wq_t* wq, unsigned* cmd_info)
+{
+    unsigned cmd = cmd_info[0];
+    if(!wq)
+        return -1;
+    memset(&wq->request, 0, sizeof(encode_request_t));
+
+    if(cmd == ENCODER_SEQUENCE){
+        wq->request.cmd = cmd;
+        wq->request.ucode_mode = cmd_info[1];
+        wq->request.quant = cmd_info[2];
+        wq->request.flush_flag = cmd_info[3];
+        wq->request.timeout = cmd_info[4];
+        wq->request.timeout = 5000; // 5000 ms
+    }else if((cmd == ENCODER_IDR)||(cmd == ENCODER_NON_IDR)){
+        wq->request.cmd = cmd;
+        wq->request.ucode_mode = cmd_info[1];
+        if(wq->request.ucode_mode == UCODE_MODE_FULL){
+            wq->request.type = cmd_info[2];
+            wq->request.fmt = cmd_info[3];
+            wq->request.src = cmd_info[4];
+            wq->request.framesize = cmd_info[5];
+            wq->request.quant = cmd_info[6];
+            wq->request.flush_flag = cmd_info[7];
+            wq->request.timeout = cmd_info[8];
+        }else{
+            wq->request.quant = cmd_info[2];
+            wq->request.qp_info_size = cmd_info[3];
+            wq->request.flush_flag = cmd_info[4];
+            wq->request.timeout = cmd_info[5];
+        }
+    }else{
+        encode_debug_level(LOG_LEVEL_ERROR," error cmd = %d, wq: %p.\n", cmd, (void*)wq);
+        return -1;
+    }
+    wq->request.parent = wq;
+    return 0;
+}
+
+void amvenc_avc_start_cmd(encode_wq_t* wq, encode_request_t* request)
+{
+    int reload_flag = 0;
+#ifdef USE_VDEC2
+    if(IS_MESON_M8_CPU){
+        if((request->ucode_mode == UCODE_MODE_SW_MIX)&&(enable_dblk>0)){
+            if((get_vdec2_usage() == USAGE_DEC_4K2K)||(abort_vdec2_flag)){
+                enable_dblk = 2;
+                if((abort_vdec2_flag)&&(get_vdec2_usage() == USAGE_ENCODE)){
+                    encode_debug_level(LOG_LEVEL_DEBUG, "switch encode ucode, wq:%p \n",(void*)wq);
+                    set_vdec2_usage(USAGE_NONE);
+                }
+            }else{
+                if(get_vdec2_usage() == USAGE_NONE)
+                    set_vdec2_usage(USAGE_ENCODE);
+                    if(!vdec_on(VDEC_2)){
+                        vdec_poweron(VDEC_2);//++++
+                        mdelay(10);
+                    }
+                    enable_dblk = 1;
+                }
             }
+    }
+#endif
+    if(request->ucode_mode!=encode_manager.ucode_index){
+        encode_manager.ucode_index = request->ucode_mode;
+        if(reload_mc(wq)){
+            encode_debug_level(LOG_LEVEL_ERROR, "reload mc fail, wq:%p\n", (void*)wq);
+            return;
+        }
+        reload_flag = 1;
+        encode_manager.need_reset= true;
+    }else if((request->parent != encode_manager.last_wq)&&(request->ucode_mode == UCODE_MODE_SW_MIX)){
+        //walk around to reset the armrisc
+        if(reload_mc(wq)){
+            encode_debug_level(LOG_LEVEL_ERROR, "reload mc fail, wq:%p\n", (void*)wq);
+            return;
+        }
+        reload_flag = 1;
+        encode_manager.need_reset= true;
+    }
+
+    wq->hw_status = 0;
+    wq->output_size = 0;
+    wq->ucode_index = encode_manager.ucode_index;
+    if((request->cmd == ENCODER_SEQUENCE)||(request->cmd == ENCODER_PICTURE))
+        wq->control.finish = true;
+
+    ie_me_mode |= (0 & ME_PIXEL_MODE_MASK)<<ME_PIXEL_MODE_SHIFT;
+    if(encode_manager.need_reset){
+        encode_manager.need_reset = false;
+        encode_manager.encode_hw_status = ENCODER_IDLE ;
+        amvenc_reset();
+        avc_canvas_init(wq);
+        avc_init_encoder(wq,(request->cmd == ENCODER_IDR)?true:false);
+        avc_init_input_buffer(wq);
+        avc_init_output_buffer(wq);
+        avc_prot_init(wq, request->quant, (request->cmd == ENCODER_IDR)?true:false);
+        avc_init_assit_buffer(wq);
+        encode_debug_level(LOG_LEVEL_INFO,"begin to new frame, request->cmd: %d, ucode mode: %d, wq:%p.\n",request->cmd, request->ucode_mode, (void*)wq);
+    }
+    if((request->cmd == ENCODER_IDR)||(request->cmd == ENCODER_NON_IDR)){
+        avc_init_dblk_buffer(wq->mem.dblk_buf_canvas);
+        avc_init_reference_buffer(wq->mem.ref_buf_canvas);
+    }
+    if(encode_manager.ucode_index != UCODE_MODE_SW_MIX){
+        if((request->cmd == ENCODER_IDR)||(request->cmd == ENCODER_NON_IDR)){
+            set_input_format(wq, request);
+        }
+        if(request->cmd == ENCODER_IDR)
+            ie_me_mb_type = HENC_MB_Type_I4MB;
+        else if(request->cmd == ENCODER_NON_IDR)
+            ie_me_mb_type = (HENC_SKIP_RUN_AUTO<<16)|(HENC_MB_Type_AUTO<<4) | (HENC_MB_Type_AUTO <<0);
+        else
+            ie_me_mb_type = 0;
+        avc_init_ie_me_parameter(wq,request->quant);
+    }
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    else{
+        if((wq->mem.dblk_buf_canvas&0xff)==ENC_CANVAS_OFFSET){
+            WRITE_HREG(CURRENT_Y_CANVAS_START, wq->mem.buf_start + wq->mem.bufspec.dec0_y.buf_start);
+            WRITE_HREG(CURRENT_C_CANVAS_START, wq->mem.buf_start + wq->mem.bufspec.dec0_uv.buf_start);
+        }else{
+            WRITE_HREG(CURRENT_Y_CANVAS_START, wq->mem.buf_start + wq->mem.bufspec.dec1_y.buf_start);
+            WRITE_HREG(CURRENT_C_CANVAS_START, wq->mem.buf_start + wq->mem.bufspec.dec1_uv.buf_start);
+        }
+        WRITE_HREG(CANVAS_ROW_SIZE,(((wq->pic.encoder_width+31)>>5)<<5));
+
+#ifdef USE_VDEC2
+        if((enable_dblk == 1)&&(IS_MESON_M8_CPU)){
+            amvdec2_stop();
+            WRITE_VREG(VDEC2_AV_SCRATCH_2, 0xffff);
+            // set vdec2 input, clone hcodec input buffer and set to manual mode
+            WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_CONTROL, 0); //++++
+
+            WRITE_VREG(DOS_SW_RESET2, (1<<4));
+            WRITE_VREG(DOS_SW_RESET2, 0);
+            (void)READ_VREG(DOS_SW_RESET2);
+            (void)READ_VREG(DOS_SW_RESET2);
+            WRITE_VREG(VDEC2_POWER_CTL_VLD, (1<<4)|(1<<6)|(1<<9));//++++
+
+            WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_START_PTR,wq->mem.BitstreamStart);//++++
+            WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_END_PTR,wq->mem.BitstreamEnd);//++++
+            WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_CURR_PTR,wq->mem.BitstreamStart);//++++
+
+            SET_VREG_MASK(VDEC2_VLD_MEM_VIFIFO_CONTROL, 1);//++++
+            CLEAR_VREG_MASK(VDEC2_VLD_MEM_VIFIFO_CONTROL, 1);//++++
+
+            WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_BUF_CNTL, 2);//++++
+            WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_WP,wq->mem.BitstreamStart);//++++
+
+            SET_VREG_MASK(VDEC2_VLD_MEM_VIFIFO_BUF_CNTL, 1);//++++
+            CLEAR_VREG_MASK(VDEC2_VLD_MEM_VIFIFO_BUF_CNTL, 1);//++++
+
+            WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_CONTROL, (0x11<<16) | (1<<10) | (7<<3) | (1<<2) | (1<<1)); //++++
+
+            amvdec2_loadmc(vdec2_encoder_mc);//++++
+
+            WRITE_VREG(VDEC2_AV_SCRATCH_1, wq->mem.vdec2_start_addr - VDEC2_DEF_BUF_START_ADDR);//++++
+            WRITE_VREG(VDEC2_AV_SCRATCH_8, wq->pic.log2_max_pic_order_cnt_lsb);//++++
+            WRITE_VREG(VDEC2_AV_SCRATCH_9, wq->pic.log2_max_frame_num);//++++
+            WRITE_VREG(VDEC2_AV_SCRATCH_B, wq->pic.init_qppicture);//++++
+            WRITE_VREG(VDEC2_AV_SCRATCH_A, (((wq->pic.encoder_height+15)/16) << 16) | ((wq->pic.encoder_width+15)/16));//++++
+
+            // Input/Output canvas
+            WRITE_VREG(VDEC2_ANC0_CANVAS_ADDR, wq->mem.ref_buf_canvas);//++++
+            WRITE_VREG(VDEC2_ANC1_CANVAS_ADDR, wq->mem.dblk_buf_canvas);//++++
+
+            WRITE_VREG(DECODED_MB_Y, 0);
+            // MBY limit
+            WRITE_VREG(DECODABLE_MB_Y, 0);
+            // VB WP
+            WRITE_VREG(STREAM_WR_PTR, wq->mem.BitstreamStart);
+            // NV21
+            SET_VREG_MASK(VDEC2_MDEC_PIC_DC_CTRL, 1<<17);//++++
+
+            WRITE_VREG(VDEC2_M4_CONTROL_REG, 1<<13); //set h264_en//++++
+            WRITE_VREG(VDEC2_MDEC_PIC_DC_THRESH, 0x404038aa);//++++
+
+            amvdec2_start();//amvdec2_start();//++++
+        }
+#endif
+    }
 #endif
+    encode_manager.encode_hw_status = request->cmd;
+    wq->hw_status = request->cmd;
+	
+    //if((request->cmd == ENCODER_IDR)||(request->cmd == ENCODER_NON_IDR)
+    //  ||(request->cmd == ENCODER_SEQUENCE)||(request->cmd == ENCODER_PICTURE)){
+    //    encode_manager.process_irq = false;
+    //}
+
+    WRITE_HREG(ENCODER_STATUS , request->cmd);
+    if((request->cmd == ENCODER_IDR)||(request->cmd == ENCODER_NON_IDR)
+      ||(request->cmd == ENCODER_SEQUENCE)||(request->cmd == ENCODER_PICTURE)){
+        encode_manager.process_irq = false;
+    }
+#ifdef MULTI_SLICE_MC
+    if(fixed_slice_cfg){
+        WRITE_HREG(FIXED_SLICE_CFG, fixed_slice_cfg);
+    }else if(wq->pic.rows_per_slice !=  (wq->pic.encoder_height+15)>>4){
+        WRITE_HREG(FIXED_SLICE_CFG, (wq->pic.rows_per_slice<<16)|wq->pic.rows_per_slice);
+    }else{
+        WRITE_HREG(FIXED_SLICE_CFG, 0);
+    }
+#else
+    WRITE_HREG(FIXED_SLICE_CFG, 0);
+#endif
+    if(reload_flag)
+        amvenc_start();
+    if((encode_manager.ucode_index == UCODE_MODE_SW_MIX)&&((request->cmd == ENCODER_IDR)||(request->cmd == ENCODER_NON_IDR))){
+        wq->control.can_update = true;
+    }
+    encode_debug_level(LOG_LEVEL_ALL,"amvenc_avc_start cmd, wq:%p.\n", (void*)wq);
+}
+
+static void dma_flush(unsigned buf_start , unsigned buf_size )
+{
+    //dma_sync_single_for_cpu(amvenc_avc_dev,buf_start, buf_size, DMA_TO_DEVICE);
+    dma_sync_single_for_device(amvenc_avc_dev,buf_start ,buf_size, DMA_TO_DEVICE);
+}
+
+static void cache_flush(unsigned buf_start , unsigned buf_size )
+{
+    dma_sync_single_for_cpu(amvenc_avc_dev , buf_start, buf_size, DMA_FROM_DEVICE);
+    //dma_sync_single_for_device(amvenc_avc_dev ,buf_start , buf_size, DMA_FROM_DEVICE);
+}
+
+static unsigned getbuffer(encode_wq_t* wq, unsigned type)
+{
+    unsigned ret = 0;
+
+    switch(type){
+        case ENCODER_BUFFER_INPUT:
+            ret = wq->mem.dct_buff_start_addr;
+            break;
+        case ENCODER_BUFFER_REF0:
+            ret = wq->mem.dct_buff_start_addr + wq->mem.bufspec.dec0_y.buf_start;
+            break;
+        case ENCODER_BUFFER_REF1:
+            ret = wq->mem.dct_buff_start_addr + wq->mem.bufspec.dec1_y.buf_start;
+            break;
+        case ENCODER_BUFFER_OUTPUT:
+            ret = wq->mem.BitstreamStart ;
+            break;
+        case ENCODER_BUFFER_INTER_INFO:
+            ret = wq->mem.inter_bits_info_ddr_start_addr;
+            break;
+        case ENCODER_BUFFER_INTRA_INFO:
+            ret = wq->mem.intra_bits_info_ddr_start_addr;
+            break;
+        case ENCODER_BUFFER_QP:
+            ret = wq->mem.sw_ctl_info_start_addr;
             break;
         default:
             break;
     }
+    return ret;
+}
+
+s32 amvenc_avc_start(encode_wq_t* wq, int clock)
+{
+    const u32 * p = select_ucode(encode_manager.ucode_index);
+
+    avc_poweron(clock);
+    avc_canvas_init(wq);
 
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
     if(IS_MESON_M8M2_CPU){
         WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x32);
-        dblk_fix_flag = (p==mix_sw_mc_hdec_m2_dblk);
-    }else
-#endif
-    {
+    }else{
         WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x2);
-        dblk_fix_flag = false;
     }
 #else
     WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x2);
-    dblk_fix_flag = false;
 #endif
 
-    if (amvenc_loadmc(p) < 0) {
-        //amvdec_disable();
+    if (amvenc_loadmc(p,wq) < 0) {
         return -EBUSY;
     }
-    debug_level(1,"succeed to load microcode\n");
-    //avc_canvas_init();
-    frame_start = 0;
-    idr_pic_id = 0 ;
-#ifdef DUMP_PRE_ENCODE_INTRA
-    intra_pic_id = 0;
-#endif
-    frame_number = 0 ;
-    process_irq = 0;
-    pic_order_cnt_lsb = 0 ;
-    encoder_status = ENCODER_IDLE ;
-    amvenc_reset();
 
-    avc_init_encoder(true);
-    avc_init_input_buffer();  //dct buffer setting
-    avc_init_output_buffer();  //output stream buffer
-    avc_prot_init(true);
-    r = request_irq(INT_AMVENCODER, enc_isr, IRQF_SHARED, "enc-irq", (void *)avc_dec_id);//INT_MAILBOX_1A
-    avc_init_dblk_buffer(dblk_buf_canvas);   //decoder buffer , need set before each frame start
-    avc_init_reference_buffer(ref_buf_canvas); //reference  buffer , need set before each frame start
-    avc_init_assit_buffer(); //assitant buffer for microcode
-    if(ucode_index != UCODE_MODE_SW_MIX){
-        avc_init_ie_me_parameter();
+    encode_manager.need_reset = true;
+    encode_manager.process_irq = false;
+    encode_manager.encode_hw_status = ENCODER_IDLE ;
+    amvenc_reset();
+    avc_init_encoder(wq,true);
+    avc_init_input_buffer(wq);  //dct buffer setting
+    avc_init_output_buffer(wq);  //output stream buffer
+
+    ie_me_mode |= (0 & ME_PIXEL_MODE_MASK)<<ME_PIXEL_MODE_SHIFT;
+    avc_prot_init(wq, wq->pic.init_qppicture, true);
+    encode_manager.irq_num = request_irq(INT_AMVENCODER, enc_isr, IRQF_SHARED, "enc-irq", (void *)&encode_manager);//INT_MAILBOX_1A
+    avc_init_dblk_buffer(wq->mem.dblk_buf_canvas);   //decoder buffer , need set before each frame start
+    avc_init_reference_buffer(wq->mem.ref_buf_canvas); //reference  buffer , need set before each frame start
+    avc_init_assit_buffer(wq); //assitant buffer for microcode
+    if(encode_manager.ucode_index != UCODE_MODE_SW_MIX){
+        ie_me_mb_type = 0;
+        avc_init_ie_me_parameter(wq, wq->pic.init_qppicture);
     }
     else{
-        if((dblk_buf_canvas&0xff)==ENC_CANVAS_OFFSET){
-            WRITE_HREG(CURRENT_Y_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec0_y.buf_start);
-            WRITE_HREG(CURRENT_C_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec0_uv.buf_start);
+        if((wq->mem.dblk_buf_canvas&0xff)==ENC_CANVAS_OFFSET){
+            WRITE_HREG(CURRENT_Y_CANVAS_START, wq->mem.buf_start + wq->mem.bufspec.dec0_y.buf_start);
+            WRITE_HREG(CURRENT_C_CANVAS_START, wq->mem.buf_start + wq->mem.bufspec.dec0_uv.buf_start);
         }
         else{
-            WRITE_HREG(CURRENT_Y_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec1_y.buf_start);
-            WRITE_HREG(CURRENT_C_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec1_uv.buf_start);
+            WRITE_HREG(CURRENT_Y_CANVAS_START, wq->mem.buf_start + wq->mem.bufspec.dec1_y.buf_start);
+            WRITE_HREG(CURRENT_C_CANVAS_START, wq->mem.buf_start + wq->mem.bufspec.dec1_uv.buf_start);
         }
-        WRITE_HREG(CANVAS_ROW_SIZE,(((encoder_width+31)>>5)<<5));
+        WRITE_HREG(CANVAS_ROW_SIZE,(((wq->pic.encoder_width+31)>>5)<<5));
     }
     WRITE_HREG(ENCODER_STATUS , ENCODER_IDLE);
 
 #ifdef MULTI_SLICE_MC
     if(fixed_slice_cfg){
         WRITE_HREG(FIXED_SLICE_CFG, fixed_slice_cfg);
-    }else if(rows_per_slice !=  (encoder_height+15)>>4){
-        WRITE_HREG(FIXED_SLICE_CFG, (rows_per_slice<<16)|rows_per_slice);
+    }else if(wq->pic.rows_per_slice !=  (wq->pic.encoder_height+15)>>4){
+        WRITE_HREG(FIXED_SLICE_CFG, (wq->pic.rows_per_slice<<16)|wq->pic.rows_per_slice);
     }else{
         WRITE_HREG(FIXED_SLICE_CFG, 0);
     }
@@ -1677,387 +1725,152 @@ static s32 avc_init(void)
     WRITE_HREG(FIXED_SLICE_CFG, 0);
 #endif
     amvenc_start();
-    encode_inited = 1;
     return 0;
 }
 
-void amvenc_avc_start_cmd(int cmd, unsigned* input_info, int ucode_mode)
-{
-	int reload_flag = 0;
-#ifdef USE_VDEC2
-	if(IS_MESON_M8_CPU){
-		if(((ucode_mode&0x1) == UCODE_MODE_SW_MIX)&&(enable_dblk>0)){
-			if((get_vdec2_usage() == USAGE_DEC_4K2K)||(abort_vdec2_flag)){
-				enable_dblk = 2;
-				if((abort_vdec2_flag)&&(get_vdec2_usage() == USAGE_ENCODE)){
-					debug_level(1,"switch encode ucode\n");
-					set_vdec2_usage(USAGE_NONE);
-				}
-			}else{
-				if(get_vdec2_usage() == USAGE_NONE)
-					set_vdec2_usage(USAGE_ENCODE);
-				if(!vdec_on(VDEC_2)){
-					vdec_poweron(VDEC_2);//++++
-					mdelay(10);
-				}
-				enable_dblk = 1;
-			}
-		}
-	}
-#endif
-	if(ucode_mode!=ucode_index){
-		ucode_index = ucode_mode&0x1;
-		if(reload_mc()){
-			debug_level(1,"reload mc fail\n");
-			return;
-		}
-		reload_flag = 1;
-		frame_start = 1;
-       }
-
-	if(frame_start){
-		frame_start = 0;
-		encoder_status = ENCODER_IDLE ;
-		amvenc_reset();
-		avc_init_encoder((cmd == ENCODER_IDR)?true:false);
-		avc_init_input_buffer();
-		avc_init_output_buffer();
-		avc_prot_init((cmd == ENCODER_IDR)?true:false);
-		avc_init_assit_buffer();
-		debug_level(0,"begin to new frame\n");
-	}
-	if((cmd == ENCODER_IDR)||(cmd == ENCODER_NON_IDR)){
-		avc_init_dblk_buffer(dblk_buf_canvas);
-		avc_init_reference_buffer(ref_buf_canvas);
-	}
-	if(ucode_index != UCODE_MODE_SW_MIX){
-		if((cmd == ENCODER_IDR)||(cmd == ENCODER_NON_IDR)){
-			set_input_format((amvenc_mem_type)input_info[0], (amvenc_frame_fmt)input_info[1], input_info[2], input_info[3], input_info[4],(unsigned char)input_info[5]);
-		}
-		avc_init_ie_me_parameter();
-	}
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	else{
-		if((dblk_buf_canvas&0xff)==ENC_CANVAS_OFFSET){
-			WRITE_HREG(CURRENT_Y_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec0_y.buf_start);
-			WRITE_HREG(CURRENT_C_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec0_uv.buf_start);
-		}else{
-			WRITE_HREG(CURRENT_Y_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec1_y.buf_start);
-			WRITE_HREG(CURRENT_C_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec1_uv.buf_start);
-		}
-		WRITE_HREG(CANVAS_ROW_SIZE,(((encoder_width+31)>>5)<<5));
-
-#ifdef USE_VDEC2
-		if((enable_dblk == 1)&&(IS_MESON_M8_CPU)){
-			amvdec2_stop();// amvdec2_stop(); //++++
-			WRITE_VREG(VDEC2_AV_SCRATCH_2, 0xffff);
-			// set vdec2 input, clone hcodec input buffer and set to manual mode
-			WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_CONTROL, 0); //++++
-
-			WRITE_VREG(DOS_SW_RESET2, (1<<4));
-			WRITE_VREG(DOS_SW_RESET2, 0);
-			(void)READ_VREG(DOS_SW_RESET2);
-			(void)READ_VREG(DOS_SW_RESET2);
-			WRITE_VREG(VDEC2_POWER_CTL_VLD, (1<<4)|(1<<6)|(1<<9));//++++
-
-			WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_START_PTR,BitstreamStart);//++++
-			WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_END_PTR,BitstreamEnd);//++++
-			WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_CURR_PTR,BitstreamStart);//++++
-
-			SET_VREG_MASK(VDEC2_VLD_MEM_VIFIFO_CONTROL, 1);//++++
-			CLEAR_VREG_MASK(VDEC2_VLD_MEM_VIFIFO_CONTROL, 1);//++++
-
-			WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_BUF_CNTL, 2);//++++
-			WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_WP,BitstreamStart);//++++
-
-			SET_VREG_MASK(VDEC2_VLD_MEM_VIFIFO_BUF_CNTL, 1);//++++
-			CLEAR_VREG_MASK(VDEC2_VLD_MEM_VIFIFO_BUF_CNTL, 1);//++++
-
-			WRITE_VREG(VDEC2_VLD_MEM_VIFIFO_CONTROL, (0x11<<16) | (1<<10) | (7<<3) | (1<<2) | (1<<1)); //++++
-
-			amvdec2_loadmc(vdec2_encoder_mc);//++++
-
-			WRITE_VREG(VDEC2_AV_SCRATCH_1, vdec2_start_addr - VDEC2_DEF_BUF_START_ADDR);//++++
-			WRITE_VREG(VDEC2_AV_SCRATCH_8, log2_max_pic_order_cnt_lsb);//++++
-			WRITE_VREG(VDEC2_AV_SCRATCH_9, log2_max_frame_num);//++++
-			WRITE_VREG(VDEC2_AV_SCRATCH_B, qppicture);//++++
-			WRITE_VREG(VDEC2_AV_SCRATCH_A, (((encoder_height+15)/16) << 16) | ((encoder_width+15)/16));//++++
-
-			// Input/Output canvas
-			WRITE_VREG(VDEC2_ANC0_CANVAS_ADDR, ref_buf_canvas);//++++
-			WRITE_VREG(VDEC2_ANC1_CANVAS_ADDR, dblk_buf_canvas);//++++
-
-			WRITE_VREG(DECODED_MB_Y, 0);
-			// MBY limit
-			WRITE_VREG(DECODABLE_MB_Y, 0);
-			// VB WP
-			WRITE_VREG(STREAM_WR_PTR, BitstreamStart);
-			// NV21
-			SET_VREG_MASK(VDEC2_MDEC_PIC_DC_CTRL, 1<<17);//++++
-
-			WRITE_VREG(VDEC2_M4_CONTROL_REG, 1<<13); //set h264_en//++++
-			WRITE_VREG(VDEC2_MDEC_PIC_DC_THRESH, 0x404038aa);//++++
-
-			amvdec2_start();//amvdec2_start();//++++
-		}
-#endif
-	}
-#endif
-	encoder_status = cmd;
-	WRITE_HREG(ENCODER_STATUS , cmd);
-	if((cmd == ENCODER_IDR)||(cmd == ENCODER_NON_IDR)){
-		process_irq = 0;
-	}
-#ifdef MULTI_SLICE_MC
-	if(fixed_slice_cfg){
-		WRITE_HREG(FIXED_SLICE_CFG, fixed_slice_cfg);
-	}else if(rows_per_slice !=  (encoder_height+15)>>4){
-		WRITE_HREG(FIXED_SLICE_CFG, (rows_per_slice<<16)|rows_per_slice);
-	}else{
-		WRITE_HREG(FIXED_SLICE_CFG, 0);
-	}
-#else
-	WRITE_HREG(FIXED_SLICE_CFG, 0);
-#endif
-	if(reload_flag)
-	    amvenc_start();
-	debug_level(0,"amvenc_avc_start\n");
-}
-
 void amvenc_avc_stop(void)
 {
+    if(encode_manager.irq_num >=0){
+        free_irq(INT_AMVENCODER,&encode_manager);
+        encode_manager.irq_num = -1;
+    }
 #ifdef USE_VDEC2
     if(IS_MESON_M8_CPU){
-        if(get_vdec2_usage() != USAGE_DEC_4K2K)
-            amvdec2_stop();// amvdec2_stop(); //++++
+        if((get_vdec2_usage() != USAGE_DEC_4K2K)&&(vdec_on(VDEC_2)))
+            amvdec2_stop();
     }
 #endif
     amvenc_stop();
     avc_poweroff();
-    debug_level(1,"amvenc_avc_stop\n");
 }
 
-#ifdef CONFIG_CMA
-static struct platform_device *this_pdev;
-static struct page *venc_pages;
-#endif
-
-static int amvenc_avc_open(struct inode *inode, struct file *file)
+static s32 avc_init(encode_wq_t* wq)
 {
-    int r = 0;
-    debug_level(1,"avc open\n");
-#ifdef CONFIG_AM_JPEG_ENCODER
-    if(jpegenc_on() == true){
-        debug_level(1,"hcodec in use for JPEG Encode now.\n");
-        return -EBUSY;
-    }
-#endif
-    if(encode_opened>0){
-        amlog_level(LOG_LEVEL_ERROR, "amvenc_avc open busy.\n");
-        return -EBUSY;
-    }
+    s32 r = 0;
 
-#ifdef CONFIG_CMA
-    venc_pages = dma_alloc_from_contiguous(&this_pdev->dev, (18 * SZ_1M) >> PAGE_SHIFT, 0);
-    if(venc_pages)
-    {
-        gAmvencbuff.buf_start = page_to_phys(venc_pages);
-        gAmvencbuff.buf_size = 18 * SZ_1M;
-        pr_info("%s: allocating phys %p, size %dk\n", __func__, (void *)gAmvencbuff.buf_start, gAmvencbuff.buf_size >> 10);
-    }
-    else
-    {
-        pr_err("CMA failed to allocate dma buffer for %s\n", this_pdev->name);
-        return -ENOMEM;
-    }
-
-    if(gAmvencbuff.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P].min_buffsize){
-        gAmvencbuff.cur_buf_lev = AMVENC_BUFFER_LEVEL_1080P;
-        gAmvencbuff.bufspec = (BuffInfo_t*)&amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P];
-    }else if(gAmvencbuff.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_720P].min_buffsize){
-        gAmvencbuff.cur_buf_lev = AMVENC_BUFFER_LEVEL_720P;
-        gAmvencbuff.bufspec= (BuffInfo_t*)&amvenc_buffspec[AMVENC_BUFFER_LEVEL_720P];
-    }else if(gAmvencbuff.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_480P].min_buffsize){
-        gAmvencbuff.cur_buf_lev = AMVENC_BUFFER_LEVEL_480P;
-        gAmvencbuff.bufspec= (BuffInfo_t*)&amvenc_buffspec[AMVENC_BUFFER_LEVEL_480P];
-    }else{
-        gAmvencbuff.buf_start = 0;
-        gAmvencbuff.buf_size = 0;
-        amlog_level(LOG_LEVEL_ERROR, "amvenc_avc memory resource too small, size is %d.\n",gAmvencbuff.buf_size);
-        return -EFAULT;
-    }
-    inter_bits_info_ddr_start_addr = gAmvencbuff.buf_start+gAmvencbuff.bufspec->inter_bits_info.buf_start; // 32 bytes alignment
-    inter_mv_info_ddr_start_addr  = gAmvencbuff.buf_start+gAmvencbuff.bufspec->inter_mv_info.buf_start;
-    intra_bits_info_ddr_start_addr = gAmvencbuff.buf_start+gAmvencbuff.bufspec->intra_bits_info.buf_start; // 32 bytes alignment
-    intra_pred_info_ddr_start_addr  = gAmvencbuff.buf_start+gAmvencbuff.bufspec->intra_pred_info.buf_start;
-    sw_ctl_info_start_addr = gAmvencbuff.buf_start+gAmvencbuff.bufspec->qp_info.buf_start;
-#ifdef USE_VDEC2
-    vdec2_start_addr = gAmvencbuff.buf_start+gAmvencbuff.bufspec->vdec2_info.buf_start;
-#endif
-    debug_level(1,"amvenc_avc  memory config sucess, buff size is 0x%x, level is %s\n",gAmvencbuff.buf_size,(gAmvencbuff.cur_buf_lev == 0)?"480P":(gAmvencbuff.cur_buf_lev == 1)?"720P":"1080P");
-
-#endif
+    encode_manager.ucode_index = wq->ucode_index;
+    r = amvenc_avc_start(wq, clock_level);
 
-    init_waitqueue_head(&avc_wait);
-    atomic_set(&avc_ready, 0);
-    tasklet_init(&encode_tasklet, encode_isr_tasklet, 0);
-    encode_opened++;
-#ifdef USE_VDEC2
-    abort_vdec2_flag = 0;
-#endif
-    return r;
+    encode_debug_level(LOG_LEVEL_DEBUG,"init avc encode. microcode %d, ret=%d, wq:%p.\n", encode_manager.ucode_index, r, (void*)wq);
+    return 0;
 }
 
-static int amvenc_avc_release(struct inode *inode, struct file *file)
+static s32 amvenc_avc_light_reset(encode_wq_t* wq, unsigned value)
 {
-    if(encode_inited){
-        free_irq(INT_AMVENCODER, (void *)avc_dec_id);
-        //amvdec_disable();
-        amvenc_avc_stop();
-        encode_inited = 0;
-    }
-    if(encode_opened>0)
-        encode_opened--;
+    s32 r = 0;
 
-#ifdef CONFIG_CMA
-    if(venc_pages){
-        dma_release_from_contiguous(&this_pdev->dev, venc_pages, (18 * SZ_1M)>>PAGE_SHIFT);
-        venc_pages = 0;
-    }
-#endif
-    debug_level(1,"avc release\n");
-    return 0;
-}
+    amvenc_avc_stop();
 
-static void dma_flush(unsigned buf_start , unsigned buf_size )
-{
-    //dma_sync_single_for_cpu(amvenc_avc_dev,buf_start, buf_size, DMA_TO_DEVICE);
-	dma_sync_single_for_device(amvenc_avc_dev,buf_start ,buf_size, DMA_TO_DEVICE);
-}
+    mdelay(value);
 
-static void cache_flush(unsigned buf_start , unsigned buf_size )
-{
-	dma_sync_single_for_cpu(amvenc_avc_dev , buf_start, buf_size, DMA_FROM_DEVICE);
-	//dma_sync_single_for_device(amvenc_avc_dev ,buf_start , buf_size, DMA_FROM_DEVICE);
+    encode_manager.ucode_index = UCODE_MODE_FULL;
+    r = amvenc_avc_start(wq, clock_level);
+
+    encode_debug_level(LOG_LEVEL_DEBUG, "amvenc_avc_light_reset finish, wq:%p. ret=%d\n",(void*)wq,r);
+    return r;
 }
 
-static u32 amvenc_avc_light_reset(unsigned value)
+#ifdef CONFIG_CMA
+static int checkCMA(void)
 {
-    const u32 * p = mix_dump_mc;
-    int r = 0;
-    free_irq(INT_AMVENCODER, (void *)avc_dec_id);
+    int i = 0, j = 0;
+    struct page *buff[MAX_ENCODE_INSTANCE];
 
-#ifdef USE_VDEC2
-    if(IS_MESON_M8_CPU){
-        if(get_vdec2_usage() != USAGE_DEC_4K2K)
-            amvdec2_stop();// amvdec2_stop(); //++++
+    for(i = 0; i< MAX_ENCODE_INSTANCE;i++)
+        buff[i] = NULL;
+
+    for(i = 0; i< MAX_ENCODE_INSTANCE;i++){
+        buff[i] = dma_alloc_from_contiguous(&encode_manager.this_pdev->dev, (18 * SZ_1M) >> PAGE_SHIFT, 0);
+        if(buff[i] == NULL)
+            break;
     }
+    for(j = 0; j< i;j++){
+        if(buff[j])
+            dma_release_from_contiguous(&encode_manager.this_pdev->dev, buff[j], (18 * SZ_1M)>>PAGE_SHIFT);
+    }    
+    return i;
+}
 #endif
-    amvenc_stop();
-    avc_poweroff();
 
-    mdelay(value);
-    avc_poweron(1);
-    avc_canvas_init();
-
-    ucode_index = UCODE_MODE_FULL;
+// file operation
+static int amvenc_avc_open(struct inode *inode, struct file *file)
+{
+    int r = 0;
+    encode_wq_t* wq = NULL;
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    switch(ucode_index){
-        case UCODE_MODE_FULL:
-            if(enable_dblk)
-                p = mix_dump_mc_dblk;
-            else
-                p = mix_dump_mc;
-            break;
-        case UCODE_MODE_SW_MIX:
-            if(IS_MESON_M8B_CPU){
-                if(enable_dblk)
-                    p = mix_sw_mc_hdec_dblk;
-                else
-                    p = mix_sw_mc;
-            }
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
-            else if(IS_MESON_M8_CPU){
-                if(enable_dblk == 1)
-                    p = mix_sw_mc_vdec2_dblk;
-                else if (enable_dblk ==2)
-                    p = mix_sw_mc_hdec_dblk;
-                else
-                    p = mix_sw_mc;
-            }else if(IS_MESON_M8M2_CPU){
-                if(enable_dblk)
-                    p = mix_sw_mc_hdec_m2_dblk;
-                else
-                    p = mix_sw_mc;
-            }
-#endif
-            break;
-        default:
-            break;
+    file->private_data = NULL;
+    encode_debug_level(LOG_LEVEL_DEBUG,"avc open\n");
+#ifdef CONFIG_AM_JPEG_ENCODER
+    if(jpegenc_on() == true){
+        encode_debug_level(LOG_LEVEL_ERROR,"hcodec in use for JPEG Encode now.\n");
+        return -EBUSY;
     }
-
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
-    if(IS_MESON_M8M2_CPU){
-        WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x32);
-        dblk_fix_flag = (p==mix_sw_mc_hdec_m2_dblk);
-    }else
 #endif
-    {
-        WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x2);
-        dblk_fix_flag = false;
+#ifdef CONFIG_CMA
+    if((encode_manager.use_reserve == false)&&(encode_manager.check_cma == false)){
+        encode_manager.max_instance = checkCMA();
+        if(encode_manager.max_instance>0){
+            encode_debug_level(LOG_LEVEL_DEBUG, "amvenc_avc  check CMA pool sucess, max instance: %d.\n", encode_manager.max_instance);
+        }else{
+            encode_debug_level(LOG_LEVEL_ERROR, "amvenc_avc  CMA pool too small.\n");
+        }
+        encode_manager.check_cma = true;
     }
-#else
-    WRITE_HREG(HCODEC_ASSIST_MMC_CTRL1,0x2);
-    dblk_fix_flag = false;
 #endif
 
-    if (amvenc_loadmc(p) < 0) {
-        debug_level(1,"amvenc_avc_light_reset fail \n");
+    wq = create_encode_work_queue();
+    if(wq == NULL){
+        encode_debug_level(LOG_LEVEL_ERROR, "amvenc_avc create instance fail.\n");
         return -EBUSY;
     }
 
-    frame_start = 1;
-    process_irq = 0;
-    encoder_status = ENCODER_IDLE ;
-    amvenc_reset();
-    avc_init_encoder(true);
-    avc_init_input_buffer();  //dct buffer setting
-    avc_init_output_buffer();  //output stream buffer
-    avc_prot_init(true);
-    r = request_irq(INT_AMVENCODER, enc_isr, IRQF_SHARED, "enc-irq", (void *)avc_dec_id);//INT_MAILBOX_1A
-    avc_init_dblk_buffer(dblk_buf_canvas);   //decoder buffer , need set before each frame start
-    avc_init_reference_buffer(ref_buf_canvas); //reference  buffer , need set before each frame start
-    avc_init_assit_buffer(); //assitant buffer for microcode
-    if(ucode_index != UCODE_MODE_SW_MIX){
-        avc_init_ie_me_parameter();
-    }
-    else{
-        if((dblk_buf_canvas&0xff)==ENC_CANVAS_OFFSET){
-            WRITE_HREG(CURRENT_Y_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec0_y.buf_start);
-            WRITE_HREG(CURRENT_C_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec0_uv.buf_start);
+#ifdef CONFIG_CMA
+    if(encode_manager.use_reserve == false){
+        wq->mem.venc_pages = dma_alloc_from_contiguous(&encode_manager.this_pdev->dev, (18 * SZ_1M) >> PAGE_SHIFT, 0);
+        if(wq->mem.venc_pages)
+        {
+            wq->mem.buf_start = page_to_phys(wq->mem.venc_pages);
+            wq->mem.buf_size = 18 * SZ_1M;
+            encode_debug_level(LOG_LEVEL_DEBUG, "%s: allocating phys %p, size %dk, wq:%p.\n", __func__, (void *)wq->mem.buf_start, wq->mem.buf_size >> 10, (void *)wq);
         }
-        else{
-            WRITE_HREG(CURRENT_Y_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec1_y.buf_start);
-            WRITE_HREG(CURRENT_C_CANVAS_START, gAmvencbuff.buf_start + gAmvencbuff.bufspec->dec1_uv.buf_start);
+        else
+        {
+            encode_debug_level(LOG_LEVEL_ERROR, "CMA failed to allocate dma buffer for %s, wq:%p.\n", encode_manager.this_pdev->name, (void*)wq);
+            destroy_encode_work_queue(wq);
+            return -ENOMEM;
         }
-        WRITE_HREG(CANVAS_ROW_SIZE,(((encoder_width+31)>>5)<<5));
     }
-    WRITE_HREG(ENCODER_STATUS , ENCODER_IDLE);
+#endif
 
-#ifdef MULTI_SLICE_MC
-    if(fixed_slice_cfg){
-        WRITE_HREG(FIXED_SLICE_CFG, fixed_slice_cfg);
-    }else if(rows_per_slice !=  (encoder_height+15)>>4){
-        WRITE_HREG(FIXED_SLICE_CFG, (rows_per_slice<<16)|rows_per_slice);
-    }else{
-        WRITE_HREG(FIXED_SLICE_CFG, 0);
+    if((wq->mem.buf_start == 0)||(wq->mem.buf_size<amvenc_buffspec[wq->mem.cur_buf_lev].min_buffsize)){
+        encode_debug_level(LOG_LEVEL_ERROR, "alloc mem failed, start: 0x%x, size:0x%x, wq:%p.\n", wq->mem.buf_start,wq->mem.buf_size,(void*)wq);
+        destroy_encode_work_queue(wq);
+        return -ENOMEM;
     }
-#else
-    WRITE_HREG(FIXED_SLICE_CFG, 0);
+
+    wq->mem.cur_buf_lev = AMVENC_BUFFER_LEVEL_1080P;
+    memcpy(&wq->mem.bufspec, &amvenc_buffspec[wq->mem.cur_buf_lev], sizeof(BuffInfo_t));
+    wq->mem.inter_bits_info_ddr_start_addr = wq->mem.buf_start+wq->mem.bufspec.inter_bits_info.buf_start; // 32 bytes alignment
+    wq->mem.inter_mv_info_ddr_start_addr  = wq->mem.buf_start+wq->mem.bufspec.inter_mv_info.buf_start;
+    wq->mem.intra_bits_info_ddr_start_addr = wq->mem.buf_start+wq->mem.bufspec.intra_bits_info.buf_start; // 32 bytes alignment
+    wq->mem.intra_pred_info_ddr_start_addr  = wq->mem.buf_start+wq->mem.bufspec.intra_pred_info.buf_start;
+    wq->mem.sw_ctl_info_start_addr = wq->mem.buf_start+wq->mem.bufspec.qp_info.buf_start;
+#ifdef USE_VDEC2
+    wq->mem.vdec2_start_addr = wq->mem.buf_start+wq->mem.bufspec.vdec2_info.buf_start;
 #endif
-    amvenc_start();
-    debug_level(1,"amvenc_avc_light_reset finish \n");
+    encode_debug_level(LOG_LEVEL_DEBUG,"amvenc_avc  memory config sucess, buff start:0x%x, size is 0x%x, wq:%p.\n",wq->mem.buf_start, wq->mem.buf_size,(void*)wq);
+
+    file->private_data = (void*) wq;
+    return r;
+}
+
+static int amvenc_avc_release(struct inode *inode, struct file *file)
+{
+    encode_wq_t* wq = (encode_wq_t*)file->private_data;
+    if(wq){
+        encode_debug_level(LOG_LEVEL_DEBUG, "avc release, wq:%p\n", (void*)wq);
+        destroy_encode_work_queue(wq);
+    }
     return 0;
 }
 
@@ -2066,7 +1879,7 @@ static long amvenc_avc_ioctl(struct file *file,
 {
     int r = 0;
     unsigned amrisc_cmd = 0;
-    unsigned offset;
+    encode_wq_t* wq = file->private_data;
     #define MAX_ADDR_INFO_SIZE 30
     unsigned addr_info[MAX_ADDR_INFO_SIZE + 4];
     ulong argV;
@@ -2074,252 +1887,187 @@ static long amvenc_avc_ioctl(struct file *file,
     int canvas = -1;
     canvas_t dst;
     switch (cmd) {
-	case AMVENC_AVC_IOC_GET_ADDR:
-		if((ref_buf_canvas & 0xff) == (ENC_CANVAS_OFFSET)){
-			 put_user(1,(int *)arg);
-		}else{
-			 put_user(2,(int *)arg);
-		}
-		break;
-	case AMVENC_AVC_IOC_INPUT_UPDATE:
-		get_user(offset,((unsigned*)arg));
-		WRITE_HREG(QDCT_MB_WR_PTR, (dct_buff_start_addr+ offset));
-		break;
-	case AMVENC_AVC_IOC_NEW_CMD:
-		if(copy_from_user(addr_info,(void*)arg,MAX_ADDR_INFO_SIZE)){
-			debug_level(1,"avc get new cmd error\n");
-			return -1;
-		}
-#ifdef DUMP_PRE_ENCODE_INTRA
-		if(addr_info[0] == ENCODER_IDR && addr_info[8] == 1)
-			preencode_intra = true;
-		else
-			preencode_intra = false;
-#endif
-		if((addr_info[1]&0x1) != UCODE_MODE_SW_MIX){ // mc mode
-			amvenc_avc_start_cmd(addr_info[0], &addr_info[2], addr_info[1]);
-		}else{
-			amvenc_avc_start_cmd(addr_info[0], NULL, addr_info[1]);
-		}
-		break;
-	case AMVENC_AVC_IOC_GET_STAGE:
-		put_user(encoder_status,(int *)arg);
-		break;
-	case AMVENC_AVC_IOC_GET_OUTPUT_SIZE:
-		put_user(READ_HREG(VLC_TOTAL_BYTES),(int *)arg);
-		break;
-	case AMVENC_AVC_IOC_SET_QUANT:
-		get_user(quant,((unsigned*)arg));
-		break;
-	case AMVENC_AVC_IOC_SET_ENCODER_WIDTH:
-		get_user(argV,((unsigned*)arg));
-		if(argV>gAmvencbuff.bufspec->max_width)
-		    argV = gAmvencbuff.bufspec->max_width;
-		else
-		    encoder_width = argV;
-		put_user(argV,(int *)arg);
-		break;
-	case AMVENC_AVC_IOC_SET_ENCODER_HEIGHT:
-		get_user(argV,((unsigned*)arg));
-		if(argV > gAmvencbuff.bufspec->max_height)
-		    argV = gAmvencbuff.bufspec->max_height;
-		else
-		    encoder_height = argV;
-		put_user(argV,(int *)arg);
-		break;
-	case AMVENC_AVC_IOC_CONFIG_INIT:
-		if(copy_from_user(addr_info,(void*)arg,MAX_ADDR_INFO_SIZE)){
-			debug_level(1,"avc config init error\n");
-			return -1;
-		}
-		if(addr_info[0] <= UCODE_MODE_SW_MIX)
-			ucode_index = addr_info[0];
-		else
-			ucode_index = UCODE_MODE_FULL;
+        case AMVENC_AVC_IOC_GET_ADDR:
+            if((wq->mem.ref_buf_canvas & 0xff) == (ENC_CANVAS_OFFSET)){
+                put_user(1,(int *)arg);
+            }else{
+                put_user(2,(int *)arg);
+            }
+            break;
+        case AMVENC_AVC_IOC_INPUT_UPDATE:
+            if(copy_from_user(addr_info,(void*)arg,MAX_ADDR_INFO_SIZE*sizeof(unsigned))){
+                encode_debug_level(LOG_LEVEL_ERROR,"avc update input ptr error, wq: %p.\n", (void*)wq);
+                return -1;
+            }
+
+            wq->control.dct_buffer_write_ptr = addr_info[2];
+            if((encode_manager.current_wq == wq)&&(wq->control.can_update == true)){
+                buf_start = getbuffer(wq, addr_info[0]);
+                if(buf_start)
+                    dma_flush(buf_start + wq->control.dct_flush_start, wq->control.dct_buffer_write_ptr - wq->control.dct_flush_start);  // may be move flush operation to process request function
+                WRITE_HREG(QDCT_MB_WR_PTR, (wq->mem.dct_buff_start_addr+ wq->control.dct_buffer_write_ptr));
+                wq->control.dct_flush_start =  wq->control.dct_buffer_write_ptr;
+            }
+            wq->control.finish = (addr_info[3] == 1)?true:false;
+            break;
+        case AMVENC_AVC_IOC_NEW_CMD:
+            if(copy_from_user(addr_info,(void*)arg,MAX_ADDR_INFO_SIZE*sizeof(unsigned))){
+                encode_debug_level(LOG_LEVEL_ERROR,"avc get new cmd error, wq:%p.\n",(void*)wq);
+                return -1;
+            }
+            r = convert_request(wq, addr_info);
+            if(r == 0)
+                r = encode_wq_add_request(wq);
+            if(r)
+                encode_debug_level(LOG_LEVEL_ERROR,"avc add new request error, wq:%p.\n",(void*)wq);
+            break;
+        case AMVENC_AVC_IOC_GET_STAGE:
+            put_user(wq->hw_status,(int *)arg);
+            break;
+        case AMVENC_AVC_IOC_GET_OUTPUT_SIZE:
+            put_user(wq->output_size,(int *)arg);
+            break;
+        case AMVENC_AVC_IOC_CONFIG_INIT:
+            if(copy_from_user(addr_info,(void*)arg,MAX_ADDR_INFO_SIZE*sizeof(unsigned))){
+                encode_debug_level(LOG_LEVEL_ERROR,"avc config init error, wq:%p.\n",(void*)wq);
+                return -1;
+            }
+            if(addr_info[0] <= UCODE_MODE_SW_MIX)
+               wq->ucode_index = addr_info[0];
+            else
+               wq->ucode_index = UCODE_MODE_FULL;
 
 #if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
-		ucode_index = UCODE_MODE_FULL;
+            wq->ucode_index = UCODE_MODE_FULL;
 #endif
 
 #ifdef MULTI_SLICE_MC
-		rows_per_slice = addr_info[1];
-		debug_level(1,"avc init -- rows_per_slice: %d \n", rows_per_slice);
+            wq->pic.rows_per_slice = addr_info[1];
+            encode_debug_level(LOG_LEVEL_DEBUG,"avc init -- rows_per_slice: %d, wq: %p.\n", wq->pic.rows_per_slice, (void*)wq);
 #endif
-		debug_level(1,"avc init as mode %d \n",ucode_index);
-		avc_init();
-		addr_info[1] = gAmvencbuff.bufspec->dct.buf_start;
-		addr_info[2] = gAmvencbuff.bufspec->dct.buf_size;
-		addr_info[3] = gAmvencbuff.bufspec->dec0_y.buf_start;
-		addr_info[4] = gAmvencbuff.bufspec->dec0_y.buf_size;
-		addr_info[5] = gAmvencbuff.bufspec->dec0_uv.buf_start;
-		addr_info[6] = gAmvencbuff.bufspec->dec0_uv.buf_size;
-		addr_info[7] = gAmvencbuff.bufspec->dec1_y.buf_start;
-		addr_info[8] = gAmvencbuff.bufspec->dec1_y.buf_size;
-		addr_info[9] = gAmvencbuff.bufspec->dec1_uv.buf_start;
-		addr_info[10] = gAmvencbuff.bufspec->dec1_uv.buf_size;
-		addr_info[11] = gAmvencbuff.bufspec->bitstream.buf_start;
-		addr_info[12] = gAmvencbuff.bufspec->bitstream.buf_size;
-		addr_info[13] = gAmvencbuff.bufspec->inter_bits_info.buf_start;
-		addr_info[14] = gAmvencbuff.bufspec->inter_bits_info.buf_size;
-		addr_info[15] = gAmvencbuff.bufspec->inter_mv_info.buf_start;
-		addr_info[16] = gAmvencbuff.bufspec->inter_mv_info.buf_size;
-		addr_info[17] = gAmvencbuff.bufspec->intra_bits_info.buf_start;
-		addr_info[18] = gAmvencbuff.bufspec->intra_bits_info.buf_size;
-		addr_info[19] = gAmvencbuff.bufspec->intra_pred_info.buf_start;
-		addr_info[20] = gAmvencbuff.bufspec->intra_pred_info.buf_size;
-		addr_info[21] = gAmvencbuff.bufspec->qp_info.buf_start;
-		addr_info[22] = gAmvencbuff.bufspec->qp_info.buf_size;
-		r = copy_to_user((unsigned *)arg, addr_info , 23*sizeof(unsigned));
-		break;
-	case AMVENC_AVC_IOC_FLUSH_CACHE:
-		if(copy_from_user(addr_info,(void*)arg,MAX_ADDR_INFO_SIZE)){
-			debug_level(1,"avc fluch cache error\n");
-			return -1;
-		}
-		switch(addr_info[0]){
-			case 0:
-			buf_start = dct_buff_start_addr;
-			break;
-			case 1:
-			buf_start = dct_buff_start_addr + gAmvencbuff.bufspec->dec0_y.buf_start;
-			break;
-			case 2:
-			buf_start = dct_buff_start_addr + gAmvencbuff.bufspec->dec1_y.buf_start;
-			break;
-			case 3:
-			buf_start = BitstreamStart ;
-			break;
-			case 4:
-			buf_start = inter_bits_info_ddr_start_addr;
-			break;
-			case 5:
-			buf_start = intra_bits_info_ddr_start_addr;
-			break;
-			case 6:
-			buf_start = sw_ctl_info_start_addr;
-			break;
-			default:
-			buf_start = dct_buff_start_addr;
-			break;
-		}
-		dma_flush(buf_start + addr_info[1] ,addr_info[2] - addr_info[1]);
-		break;
-	case AMVENC_AVC_IOC_FLUSH_DMA:
-		if(copy_from_user(addr_info,(void*)arg,MAX_ADDR_INFO_SIZE)){
-			debug_level(1,"avc fluch dma error\n");
-			return -1;
-		}
-		switch(addr_info[0]){
-			case 0:
-			buf_start = dct_buff_start_addr;
-			break;
-			case 1:
-			buf_start = dct_buff_start_addr + gAmvencbuff.bufspec->dec0_y.buf_start;
-			break;
-			case 2:
-			buf_start = dct_buff_start_addr + gAmvencbuff.bufspec->dec1_y.buf_start;
-			break;
-			case 3:
-			buf_start = BitstreamStart ;
-			break;
-			case 4:
-			buf_start = inter_bits_info_ddr_start_addr;
-			break;
-			case 5:
-			buf_start = intra_bits_info_ddr_start_addr;
-			break;
-			default:
-			buf_start = dct_buff_start_addr;
-			break;
-		}
- 		cache_flush(buf_start + addr_info[1] ,addr_info[2] - addr_info[1]);
-		break;
-	case AMVENC_AVC_IOC_GET_BUFFINFO:
-		put_user(gAmvencbuff.buf_size,(unsigned *)arg);
-		break;
-	case AMVENC_AVC_IOC_SET_IE_ME_MB_TYPE:
-		get_user(ie_me_mb_type,((unsigned*)arg));
-		break;
-	case AMVENC_AVC_IOC_SET_ME_PIXEL_MODE:
-		get_user(argV,((unsigned*)arg));
-		ie_me_mode |= (argV & ME_PIXEL_MODE_MASK)<<ME_PIXEL_MODE_SHIFT;
-		break;
-	case AMVENC_AVC_IOC_GET_DEVINFO:
-		r = copy_to_user((char *)arg,AMVENC_DEV_VERSION,strlen(AMVENC_DEV_VERSION));
-		break;
-	case AMVENC_AVC_IOC_SUBMIT_ENCODE_DONE:
-		get_user(amrisc_cmd,((unsigned*)arg));
-		if(amrisc_cmd == ENCODER_IDR){
-			idr_pic_id ++;
-			if(idr_pic_id > 65535)
-				idr_pic_id = 0;
-			pic_order_cnt_lsb = 2;
-			frame_number = 1;
-#ifdef DUMP_PRE_ENCODE_INTRA
-			intra_pic_id++;
-			if(intra_pic_id > 65535)
-				intra_pic_id = 0;
-#endif
-		}else if(amrisc_cmd == ENCODER_NON_IDR){
-			frame_number ++;
-			pic_order_cnt_lsb += 2;
-			if(frame_number > 65535)
-				frame_number = 0;
-#ifdef DUMP_PRE_ENCODE_INTRA
-			intra_pic_id++;
-			if(intra_pic_id > 65535)
-				intra_pic_id = 0;
-#endif
-		}
-		amrisc_cmd = dblk_buf_canvas;
-		dblk_buf_canvas = ref_buf_canvas;
-		ref_buf_canvas = amrisc_cmd;   //current dblk buffer as next reference buffer
-		break;
-	case AMVENC_AVC_IOC_READ_CANVAS:
-		get_user(argV,((unsigned*)arg));
-		canvas = argV;
-		if(canvas&0xff){
-			canvas_read(canvas&0xff,&dst);
-			addr_info[0] = dst.addr;
-			if((canvas&0xff00)>>8)
-				canvas_read((canvas&0xff00)>>8,&dst);
-			if((canvas&0xff0000)>>16)
-				canvas_read((canvas&0xff0000)>>16,&dst);
-			addr_info[1] = dst.addr - addr_info[0] +dst.width*dst.height;
-		}else{
-			addr_info[0] = 0;
-			addr_info[1] = 0;
-		}
-		r = copy_to_user((unsigned *)arg, addr_info , 2*sizeof(unsigned));
-		break;
-	case AMVENC_AVC_IOC_LIGHT_RESET:
-		get_user(argV,((unsigned*)arg));
-		amvenc_avc_light_reset(argV);
-		break;
-	default:
-		r= -1;
-		break;
+            encode_debug_level(LOG_LEVEL_DEBUG,"avc init as mode %d, wq: %p.\n",wq->ucode_index, (void*)wq);
+
+            if((addr_info[2]>wq->mem.bufspec.max_width)||(addr_info[3]>wq->mem.bufspec.max_height)){
+                encode_debug_level(LOG_LEVEL_ERROR,"avc config init- encode size %dx%d is larger than supported (%dx%d).  wq:%p.\n",addr_info[2], addr_info[3], wq->mem.bufspec.max_width, wq->mem.bufspec.max_height,(void*)wq);
+                return -1;
+            }
+            wq->pic.encoder_width = addr_info[2];
+            wq->pic.encoder_height= addr_info[3];
+
+            avc_buffspec_init(wq);
+            up(&encode_manager.event.request_in_sem) ;
+            //avc_init();
+            addr_info[1] = wq->mem.bufspec.dct.buf_start;
+            addr_info[2] = wq->mem.bufspec.dct.buf_size;
+            addr_info[3] = wq->mem.bufspec.dec0_y.buf_start;
+            addr_info[4] = wq->mem.bufspec.dec0_y.buf_size;
+            addr_info[5] = wq->mem.bufspec.dec0_uv.buf_start;
+            addr_info[6] = wq->mem.bufspec.dec0_uv.buf_size;
+            addr_info[7] = wq->mem.bufspec.dec1_y.buf_start;
+            addr_info[8] = wq->mem.bufspec.dec1_y.buf_size;
+            addr_info[9] = wq->mem.bufspec.dec1_uv.buf_start;
+            addr_info[10] = wq->mem.bufspec.dec1_uv.buf_size;
+            addr_info[11] = wq->mem.bufspec.bitstream.buf_start;
+            addr_info[12] = wq->mem.bufspec.bitstream.buf_size;
+            addr_info[13] = wq->mem.bufspec.inter_bits_info.buf_start;
+            addr_info[14] = wq->mem.bufspec.inter_bits_info.buf_size;
+            addr_info[15] = wq->mem.bufspec.inter_mv_info.buf_start;
+            addr_info[16] = wq->mem.bufspec.inter_mv_info.buf_size;
+            addr_info[17] = wq->mem.bufspec.intra_bits_info.buf_start;
+            addr_info[18] = wq->mem.bufspec.intra_bits_info.buf_size;
+            addr_info[19] = wq->mem.bufspec.intra_pred_info.buf_start;
+            addr_info[20] = wq->mem.bufspec.intra_pred_info.buf_size;
+            addr_info[21] = wq->mem.bufspec.qp_info.buf_start;
+            addr_info[22] = wq->mem.bufspec.qp_info.buf_size;
+            r = copy_to_user((unsigned *)arg, addr_info , 23*sizeof(unsigned));
+            break;
+        case AMVENC_AVC_IOC_FLUSH_CACHE:
+            if(copy_from_user(addr_info,(void*)arg,MAX_ADDR_INFO_SIZE*sizeof(unsigned))){
+                encode_debug_level(LOG_LEVEL_ERROR,"avc fluch cache error, wq: %p.\n", (void*)wq);
+                return -1;
+            }
+            buf_start = getbuffer(wq, addr_info[0]);
+            if(buf_start)
+                dma_flush(buf_start + addr_info[1] ,addr_info[2] - addr_info[1]);
+            break;
+        case AMVENC_AVC_IOC_FLUSH_DMA:
+            if(copy_from_user(addr_info,(void*)arg,MAX_ADDR_INFO_SIZE*sizeof(unsigned))){
+                encode_debug_level(LOG_LEVEL_ERROR,"avc fluch dma error, wq:%p.\n", (void*)wq);
+                return -1;
+            }
+            buf_start = getbuffer(wq, addr_info[0]);
+            if(buf_start)
+                cache_flush(buf_start + addr_info[1] ,addr_info[2] - addr_info[1]);
+            break;
+        case AMVENC_AVC_IOC_GET_BUFFINFO:
+            put_user(wq->mem.buf_size,(unsigned *)arg);
+            break;
+        case AMVENC_AVC_IOC_GET_DEVINFO:
+            r = copy_to_user((char *)arg,AMVENC_DEV_VERSION,strlen(AMVENC_DEV_VERSION));
+            break;
+        case AMVENC_AVC_IOC_SUBMIT_ENCODE_DONE:
+            get_user(amrisc_cmd,((unsigned*)arg));
+            if(amrisc_cmd == ENCODER_IDR){
+                wq->pic.idr_pic_id ++;
+                if(wq->pic.idr_pic_id > 65535)
+                    wq->pic.idr_pic_id = 0;
+                wq->pic.pic_order_cnt_lsb = 2;
+                wq->pic.frame_number = 1;
+            }else if(amrisc_cmd == ENCODER_NON_IDR){
+                wq->pic.frame_number ++;
+                wq->pic.pic_order_cnt_lsb += 2;
+                if(wq->pic.frame_number > 65535)
+                    wq->pic.frame_number = 0;
+            }
+            amrisc_cmd = wq->mem.dblk_buf_canvas;
+            wq->mem.dblk_buf_canvas = wq->mem.ref_buf_canvas;
+            wq->mem.ref_buf_canvas = amrisc_cmd;   //current dblk buffer as next reference buffer
+            break;
+        case AMVENC_AVC_IOC_READ_CANVAS:
+            get_user(argV,((unsigned*)arg));
+            canvas = argV;
+            if(canvas&0xff){
+                canvas_read(canvas&0xff,&dst);
+                addr_info[0] = dst.addr;
+                if((canvas&0xff00)>>8)
+                    canvas_read((canvas&0xff00)>>8,&dst);
+                if((canvas&0xff0000)>>16)
+                    canvas_read((canvas&0xff0000)>>16,&dst);
+                addr_info[1] = dst.addr - addr_info[0] +dst.width*dst.height;
+            }else{
+                addr_info[0] = 0;
+                addr_info[1] = 0;
+            }
+            r = copy_to_user((unsigned *)arg, addr_info , 2*sizeof(unsigned));
+            break;
+        case AMVENC_AVC_IOC_MAX_INSTANCE:
+            put_user(encode_manager.max_instance,(unsigned *)arg);
+            break;
+        default:
+            r= -1;
+            break;
     }
     return r;
 }
 
 static int avc_mmap(struct file *filp, struct vm_area_struct *vma)
 {
+    encode_wq_t* wq = (encode_wq_t*)filp->private_data;
     unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
     unsigned vma_size = vma->vm_end - vma->vm_start;
 
     if (vma_size == 0) {
-        debug_level(1,"vma_size is 0 \n");
+        encode_debug_level(LOG_LEVEL_ERROR,"vma_size is 0, wq:%p.\n", (void*)wq);
         return -EAGAIN;
     }
     if(!off)
-        off += gAmvencbuff.buf_start;
-    debug_level(0,"vma_size is %d , off is %ld \n" , vma_size ,off);
+        off += wq->mem.buf_start;
+    encode_debug_level(LOG_LEVEL_ALL,"vma_size is %d , off is %ld, wq:%p.\n" , vma_size ,off, (void*)wq);
     vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;
     //vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
     if (remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
                         vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
-        debug_level(1,"set_cached: failed remap_pfn_range\n");
+        encode_debug_level(LOG_LEVEL_ERROR,"set_cached: failed remap_pfn_range, wq:%p.\n", (void*)wq);
         return -EAGAIN;
     }
     return 0;
@@ -2328,10 +2076,11 @@ static int avc_mmap(struct file *filp, struct vm_area_struct *vma)
 
 static unsigned int amvenc_avc_poll(struct file *file, poll_table *wait_table)
 {
-    poll_wait(file, &avc_wait, wait_table);
+    encode_wq_t* wq = (encode_wq_t*)file->private_data;
+    poll_wait(file, &wq->request_complete, wait_table);
 
-    if (atomic_read(&avc_ready)) {
-        atomic_dec(&avc_ready);
+    if (atomic_read(&wq->request_ready)) {
+        atomic_dec(&wq->request_ready);
         return POLLIN | POLLRDNORM;
     }
 
@@ -2347,96 +2096,671 @@ const static struct file_operations amvenc_avc_fops = {
     .poll     = amvenc_avc_poll,
 };
 
+// work queue function
+static int encode_process_request(encode_manager_t*  manager, encode_queue_item_t *pitem)
+{
+    int ret=0;
+    encode_wq_t* wq = pitem->request.parent;
+    encode_request_t* request = &pitem->request;
+    u32 timeout = (request->timeout == 0)?1:msecs_to_jiffies(request->timeout);
+    unsigned buf_start = 0;
+    unsigned size = 0;
+
+    if(((request->cmd == ENCODER_IDR)||(request->cmd == ENCODER_NON_IDR))&&(request->ucode_mode == UCODE_MODE_SW_MIX)){
+        if(request->flush_flag & AMVENC_FLUSH_FLAG_QP){
+            buf_start = getbuffer(wq, ENCODER_BUFFER_QP);
+            if((buf_start)&&(request->qp_info_size>0))
+               dma_flush(buf_start, request->qp_info_size);
+        }
+    }
+
+Again:
+    amvenc_avc_start_cmd(wq, request);
+
+    while(wq->control.finish == 0)
+        wait_event_interruptible_timeout(manager->event.hw_complete, (wq->control.finish == true), msecs_to_jiffies(1));
+
+    if((wq->control.finish == true)&&(wq->control.dct_flush_start<wq->control.dct_buffer_write_ptr)){
+        buf_start = getbuffer(wq, ENCODER_BUFFER_INPUT);
+        if(buf_start)
+            dma_flush(buf_start + wq->control.dct_flush_start, wq->control.dct_buffer_write_ptr - wq->control.dct_flush_start);  // may be move flush operation to process request function
+        WRITE_HREG(QDCT_MB_WR_PTR, (wq->mem.dct_buff_start_addr+ wq->control.dct_buffer_write_ptr));
+        wq->control.dct_flush_start = wq->control.dct_buffer_write_ptr;
+    }
+    wait_event_interruptible_timeout(manager->event.hw_complete, 
+		((manager->encode_hw_status == ENCODER_IDR_DONE)
+		||(manager->encode_hw_status == ENCODER_NON_IDR_DONE)
+		||(manager->encode_hw_status == ENCODER_SEQUENCE_DONE)
+		||(manager->encode_hw_status == ENCODER_PICTURE_DONE)),
+		timeout);
+
+    if((request->cmd == ENCODER_SEQUENCE)&&(manager->encode_hw_status == ENCODER_SEQUENCE_DONE)){
+        wq->sps_size = READ_HREG(VLC_TOTAL_BYTES);
+        wq->hw_status = manager->encode_hw_status;
+        request->cmd = ENCODER_PICTURE;
+        goto Again;
+    }else if((request->cmd == ENCODER_PICTURE)&&(manager->encode_hw_status == ENCODER_PICTURE_DONE)){
+        wq->pps_size = READ_HREG(VLC_TOTAL_BYTES) - wq->sps_size;
+        wq->hw_status = manager->encode_hw_status;
+        if(request->flush_flag & AMVENC_FLUSH_FLAG_OUTPUT){
+            buf_start = getbuffer(wq, ENCODER_BUFFER_OUTPUT);
+            if(buf_start)
+                cache_flush(buf_start,wq->sps_size+wq->pps_size);
+        }
+        wq->output_size = (wq->sps_size<<16)|wq->pps_size;
+    }else{
+        wq->hw_status = manager->encode_hw_status;
+        if((manager->encode_hw_status == ENCODER_IDR_DONE)||(manager->encode_hw_status == ENCODER_NON_IDR_DONE)){
+            wq->output_size = READ_HREG(VLC_TOTAL_BYTES);
+            if(request->flush_flag & AMVENC_FLUSH_FLAG_OUTPUT){
+                buf_start = getbuffer(wq, ENCODER_BUFFER_OUTPUT);
+                if(buf_start)
+                    cache_flush(buf_start, wq->output_size);
+            }
+            if(request->flush_flag & AMVENC_FLUSH_FLAG_INTER_INFO){
+                buf_start = getbuffer(wq, ENCODER_BUFFER_INTER_INFO);
+                size = wq->mem.inter_mv_info_ddr_start_addr-wq->mem.inter_bits_info_ddr_start_addr+wq->mem.bufspec.inter_mv_info.buf_size;
+                if(buf_start)
+                    cache_flush(buf_start, size);
+            }
+            if(request->flush_flag & AMVENC_FLUSH_FLAG_INTRA_INFO){
+                buf_start = getbuffer(wq, ENCODER_BUFFER_INTRA_INFO);
+                size = wq->mem.intra_pred_info_ddr_start_addr-wq->mem.intra_bits_info_ddr_start_addr+wq->mem.bufspec.intra_pred_info.buf_size;
+                if(buf_start)
+                    cache_flush(buf_start, size);
+            }
+            if(request->flush_flag & AMVENC_FLUSH_FLAG_REFERENCE){
+                u32 ref_id = ENCODER_BUFFER_REF0;
+                u32 flush_size = ((wq->pic.encoder_width+31)>>5<<5)*((wq->pic.encoder_height+15)>>4<<4)*3/2;
+                if((wq->mem.ref_buf_canvas & 0xff) == (ENC_CANVAS_OFFSET)){
+                    ref_id = ENCODER_BUFFER_REF0;
+                }else{
+                    ref_id = ENCODER_BUFFER_REF1;
+                }
+                buf_start = getbuffer(wq, ref_id);
+                if(buf_start)
+                    cache_flush(buf_start, flush_size);
+            }
+        }else{
+            manager->encode_hw_status = ENCODER_ERROR;
+            amvenc_avc_light_reset(wq, 30);
+        }
+    }
+
+    wq->control.can_update = false;
+    wq->control.dct_buffer_write_ptr = 0;
+    wq->control.dct_flush_start = 0;
+    wq->control.finish = false;
+    atomic_inc(&wq->request_ready);
+    wake_up_interruptible(&wq->request_complete);
+    return ret;	
+}
+
+int encode_wq_add_request(encode_wq_t *wq)
+{
+    encode_queue_item_t  *pitem = NULL;
+    struct list_head *head = NULL;
+    encode_wq_t* tmp = NULL;
+    bool find = false;
+
+    spin_lock(&encode_manager.event.sem_lock);
+
+    head=&encode_manager.wq;
+    list_for_each_entry(tmp, head, list){
+        if((wq == tmp)&&(wq !=NULL)){
+            find = true;
+            break;
+        }
+    }
+
+    if(find == false){
+        encode_debug_level(LOG_LEVEL_ERROR, "current wq (%p) doesn't register.\n",(void*)wq);
+        goto error;
+    }
+
+    if(list_empty(&encode_manager.free_queue)){
+        encode_debug_level(LOG_LEVEL_ERROR, "work queue no space, wq:%p.\n",(void*)wq);
+        goto error;
+    }
+
+    pitem=list_entry(encode_manager.free_queue.next,encode_queue_item_t,list); 
+    if(IS_ERR(pitem)){
+        goto error;
+    }
+
+    memcpy(&pitem->request, &wq->request, sizeof(encode_request_t));
+    memset(&wq->request, 0, sizeof(encode_request_t));
+    wq->hw_status = 0;
+    wq->output_size = 0;
+    wq->control.dct_buffer_write_ptr = 0;
+    wq->control.dct_flush_start = 0;
+    wq->control.finish = false;
+    wq->control.can_update = false;
+    pitem->request.parent = wq;
+    list_move_tail(&pitem->list,&encode_manager.process_queue);
+    spin_unlock(&encode_manager.event.sem_lock);
+
+    encode_debug_level(LOG_LEVEL_INFO, "add new work ok, cmd:%d, ucode mode: %d, wq:%p.\n", pitem->request.cmd, pitem->request.ucode_mode, (void*)wq); 
+    up(&encode_manager.event.request_in_sem) ;//new cmd come in	
+    return 0;
+error:
+    spin_unlock(&encode_manager.event.sem_lock);
+    return -1;	
+}
+
+encode_wq_t* create_encode_work_queue(void)
+{
+    encode_wq_t *encode_work_queue = NULL;
+    bool done = false;
+    int i;
+
+    encode_work_queue=kzalloc(sizeof(encode_wq_t), GFP_KERNEL);
+    if(IS_ERR(encode_work_queue)){
+        encode_debug_level(LOG_LEVEL_ERROR, "can't create work queue\n");
+        return NULL;
+    }
+    encode_work_queue->pic.init_qppicture = 26;
+    encode_work_queue->pic.log2_max_frame_num = 4;
+    encode_work_queue->pic.log2_max_pic_order_cnt_lsb= 4;
+    encode_work_queue->pic.idr_pic_id = 0;
+    encode_work_queue->pic.frame_number = 0;
+    encode_work_queue->pic.pic_order_cnt_lsb = 0;
+    encode_work_queue->ucode_index = UCODE_MODE_FULL;
+    init_waitqueue_head (&encode_work_queue->request_complete);
+    atomic_set(&encode_work_queue->request_ready, 0);
+    spin_lock(&encode_manager.event.sem_lock);
+    if(encode_manager.wq_count<encode_manager.max_instance){
+        list_add_tail(&encode_work_queue->list, &encode_manager.wq);
+        encode_manager.wq_count++;
+        if(encode_manager.use_reserve == true){
+            for(i = 0;i<encode_manager.max_instance; i++){
+                if(encode_manager.reserve_buff[i].used == false){
+                    encode_work_queue->mem.buf_start = encode_manager.reserve_buff[i].buf_start;
+                    encode_work_queue->mem.buf_size= encode_manager.reserve_buff[i].buf_size;
+                    encode_manager.reserve_buff[i].used = true;
+                    done = true;
+                    break;
+                }
+            }
+        }else{
+            done = true;
+        }
+    }
+    spin_unlock(&encode_manager.event.sem_lock);
+    if(done == false){
+        kfree(encode_work_queue);
+        encode_work_queue = NULL;
+        encode_debug_level(LOG_LEVEL_ERROR, "too many work queue!\n");
+    }
+    return encode_work_queue; //find it 
+}
+
+int destroy_encode_work_queue(encode_wq_t* encode_work_queue)
+{
+    encode_queue_item_t *pitem,*tmp;
+    encode_wq_t *wq = NULL, *wp_tmp = NULL;
+    int i;
+    bool find = false;
+
+    struct list_head *head;
+    if (encode_work_queue){
+        spin_lock(&encode_manager.event.sem_lock);
+        if(encode_manager.current_wq == encode_work_queue){
+            encode_manager.remove_flag= true;
+            spin_unlock(&encode_manager.event.sem_lock);
+            encode_debug_level(LOG_LEVEL_DEBUG, "warning--Destory the running queue, should not be here.\n");
+            wait_for_completion(&encode_manager.event.process_complete);
+            spin_lock(&encode_manager.event.sem_lock);
+        }//else we can delete it safely.
+       
+        head=&encode_manager.process_queue;
+        list_for_each_entry_safe(pitem,tmp,head,list){
+            if(pitem){
+                if(pitem->request.parent == encode_work_queue){
+                    pitem->request.parent = NULL;
+                    encode_debug_level(LOG_LEVEL_DEBUG, "warning--remove not process request, should not be here.\n");
+                    list_move_tail(&pitem->list,&encode_manager.free_queue);
+                }
+            }
+        }
+
+        head=&encode_manager.wq;
+        list_for_each_entry_safe(wq,wp_tmp,head,list){
+            if((wq)&&(wq == encode_work_queue)){
+                list_del(&wq->list);
+                if(encode_manager.use_reserve == true){
+                    for(i = 0;i<encode_manager.max_instance; i++){
+                        if((encode_manager.reserve_buff[i].used == true)&&(encode_work_queue->mem.buf_start = encode_manager.reserve_buff[i].buf_start)){
+                            encode_manager.reserve_buff[i].used = false;
+                            break;
+                        }
+                    }
+                }
+                find = true;
+                encode_manager.wq_count--;
+                encode_debug_level(LOG_LEVEL_DEBUG, "remove  encode_work_queue %p sucess, %s line %d.\n",(void*)encode_work_queue, __func__,__LINE__);
+                break;
+            }
+        }
+        spin_unlock(&encode_manager.event.sem_lock);
+#ifdef CONFIG_CMA
+        if(encode_work_queue->mem.venc_pages){
+            dma_release_from_contiguous(&encode_manager.this_pdev->dev, wq->mem.venc_pages, (18 * SZ_1M)>>PAGE_SHIFT);
+            encode_work_queue->mem.venc_pages = NULL;
+        }
+#endif
+        kfree(encode_work_queue);
+        up(&encode_manager.event.request_in_sem);
+    }
+    return  0;	
+}
+
+static int encode_monitor_thread(void *data)
+{
+    encode_manager_t*  manager = (encode_manager_t*)data ;
+    encode_queue_item_t *pitem = NULL;
+    struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1 };
+    int ret = 0;
+
+    encode_debug_level(LOG_LEVEL_DEBUG, "encode workqueue monitor start.\n");
+    sched_setscheduler(current, SCHED_FIFO, &param);
+    allow_signal(SIGTERM);
+    //setup current_wq here.
+    while(manager->process_queue_state!=ENCODE_PROCESS_QUEUE_STOP){
+        if(kthread_should_stop())
+            break;
+
+        ret = down_interruptible(&manager->event.request_in_sem);
+
+        if (kthread_should_stop())
+            break;
+        if(manager->inited == false){
+            spin_lock(&manager->event.sem_lock);
+            if(!list_empty(&manager->wq)){
+	         encode_wq_t* first_wq = list_entry(manager->wq.next,encode_wq_t,list);
+                manager->current_wq = first_wq;
+                spin_unlock(&manager->event.sem_lock);
+                if(first_wq){
+                    avc_init(first_wq);
+                    manager->inited = true;
+                }
+                spin_lock(&manager->event.sem_lock);
+                manager->current_wq = NULL;
+                spin_unlock(&manager->event.sem_lock);
+                if(manager->remove_flag){
+                    complete(&manager->event.process_complete);
+                    manager->remove_flag = false;
+                }
+            }else{
+                spin_unlock(&manager->event.sem_lock);
+            }
+            continue;
+        }
+
+        spin_lock(&manager->event.sem_lock);
+        pitem = NULL;
+        if(list_empty(&manager->wq)){
+            spin_unlock(&manager->event.sem_lock);
+            manager->inited = false;
+            amvenc_avc_stop();
+            encode_debug_level(LOG_LEVEL_DEBUG, "power off encode.\n");
+            continue;
+        }else if(!list_empty(&manager->process_queue)){
+            pitem=list_entry(manager->process_queue.next,encode_queue_item_t,list);
+            list_del(&pitem->list);
+            manager->current_item = pitem;
+            manager->current_wq = pitem->request.parent;
+        }
+        spin_unlock(&manager->event.sem_lock);
+
+        if(pitem){
+            encode_process_request(manager,pitem);
+            spin_lock(&manager->event.sem_lock);
+            list_add_tail(&pitem->list, &manager->free_queue);
+            manager->current_item = NULL;
+            manager->last_wq = manager->current_wq;
+            manager->current_wq = NULL;
+            spin_unlock(&manager->event.sem_lock);
+        }
+        if(manager->remove_flag){
+            complete(&manager->event.process_complete);
+            manager->remove_flag = false;
+        }
+    }
+    while(!kthread_should_stop())
+        msleep(10);
+
+    encode_debug_level(LOG_LEVEL_DEBUG, "exit encode_monitor_thread.\n");
+    return 0;
+}
+
+static int encode_start_monitor(void)
+{
+    int ret =0;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
+    if(IS_MESON_M8M2_CPU)
+        clock_level = 3;
+#endif
+    encode_debug_level(LOG_LEVEL_DEBUG, "encode start monitor.\n");
+    encode_manager.process_queue_state=ENCODE_PROCESS_QUEUE_START;
+    encode_manager.encode_thread=kthread_run(encode_monitor_thread,&encode_manager,"encode_monitor");
+    if (IS_ERR(encode_manager.encode_thread)){
+        ret = PTR_ERR(encode_manager.encode_thread);
+        encode_manager.process_queue_state=ENCODE_PROCESS_QUEUE_STOP;
+        encode_debug_level(LOG_LEVEL_ERROR, "encode monitor : failed to start kthread (%d)\n", ret);
+    }
+    return ret;
+}
+
+static int  encode_stop_monitor(void)
+{
+    encode_debug_level(LOG_LEVEL_DEBUG, "stop encode monitor thread\n");
+    if(encode_manager.encode_thread){
+        spin_lock(&encode_manager.event.sem_lock);
+        if(!list_empty(&encode_manager.wq)){
+            int count = encode_manager.wq_count;
+            spin_unlock(&encode_manager.event.sem_lock);
+            encode_debug_level(LOG_LEVEL_ERROR, "stop encode monitor thread error, active wq (%d) is not 0.\n", count);
+            return -1;
+        }
+        spin_unlock(&encode_manager.event.sem_lock);
+        encode_manager.process_queue_state =ENCODE_PROCESS_QUEUE_STOP;
+        send_sig(SIGTERM, encode_manager.encode_thread, 1);
+        up(&encode_manager.event.request_in_sem) ;
+        kthread_stop(encode_manager.encode_thread);
+        encode_manager.encode_thread = NULL;
+    }
+    return  0;
+}
+
+static int encode_wq_init(void)
+{
+    int i = 0;
+    encode_queue_item_t *pitem = NULL;
+
+    encode_debug_level(LOG_LEVEL_DEBUG, "encode_wq_init.\n");    
+    encode_manager.irq_num = -1;
+
+    spin_lock_init(&encode_manager.event.sem_lock);
+    sema_init (&encode_manager.event.request_in_sem,0); 
+    init_waitqueue_head (&encode_manager.event.hw_complete);
+    init_completion(&encode_manager.event.process_complete);
+    INIT_LIST_HEAD(&encode_manager.process_queue);
+    INIT_LIST_HEAD(&encode_manager.free_queue);
+    INIT_LIST_HEAD(&encode_manager.wq);
+
+    tasklet_init(&encode_manager.encode_tasklet, encode_isr_tasklet, (ulong)&encode_manager);
+
+    for(i=0;i<MAX_ENCODE_REQUEST;i++){
+        pitem=(encode_queue_item_t*)kcalloc(1,sizeof(encode_queue_item_t),GFP_KERNEL);
+        if(IS_ERR(pitem)){
+            encode_debug_level(LOG_LEVEL_ERROR, "can't request queue item memory.\n");
+            return -1;
+        }
+        pitem->request.parent = NULL;
+        list_add_tail(&pitem->list, &encode_manager.free_queue) ;
+    }
+    encode_manager.current_wq = NULL;
+    encode_manager.last_wq = NULL;
+    encode_manager.encode_thread = NULL;
+    encode_manager.current_item = NULL;
+    encode_manager.wq_count = 0;
+    encode_manager.remove_flag = false;
+    if(encode_start_monitor()){
+        encode_debug_level(LOG_LEVEL_ERROR, "encode create thread error.\n");	
+        return -1;
+    }	
+    return 0;
+}
+
+static int encode_wq_uninit(void)
+{
+    encode_queue_item_t *pitem,*tmp;
+    struct list_head *head;
+    int count = 0;
+    int r = -1;
+    encode_debug_level(LOG_LEVEL_DEBUG, "uninit encode wq.\n") ;
+    if(encode_stop_monitor() == 0){
+        if(encode_manager.irq_num >=0){
+            free_irq(INT_AMVENCODER,&encode_manager);
+            encode_manager.irq_num = -1;
+        }
+        spin_lock(&encode_manager.event.sem_lock);
+        head=&encode_manager.process_queue;
+        list_for_each_entry_safe(pitem,tmp,head,list){
+            if(pitem){
+                list_del(&pitem->list);
+                kfree(pitem);
+                count++;
+            }
+        }
+        head=&encode_manager.free_queue;
+        list_for_each_entry_safe(pitem,tmp,head,list){
+            if(pitem){
+                list_del(&pitem->list);
+                kfree(pitem);
+                count++;
+            }
+        }
+        spin_unlock(&encode_manager.event.sem_lock);
+        if(count == MAX_ENCODE_REQUEST)
+            r = 0;
+        else
+            encode_debug_level(LOG_LEVEL_ERROR, "lost  some request item %d.\n",MAX_ENCODE_REQUEST-count);
+    }
+    return  r;
+}
+
+static ssize_t encode_status_show(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    int process_count=0;
+    int free_count = 0;
+    encode_queue_item_t *pitem = NULL;
+    encode_wq_t* current_wq = NULL;
+    encode_wq_t* last_wq = NULL;
+    struct list_head *head = NULL;
+    int irq_num = 0;
+    int hw_status = 0;
+    int process_queue_state = 0;
+    int wq_count = 0;
+    u32 ucode_index;
+    bool need_reset;
+    bool process_irq;
+    bool inited;
+    bool use_reserve;
+    Buff_t reserve_mem;
+    u32 max_instance;
+#ifdef CONFIG_CMA
+    bool check_cma = false;
+#endif
+
+    spin_lock(&encode_manager.event.sem_lock);
+    head = &encode_manager.free_queue;
+    list_for_each_entry(pitem, head , list){
+        free_count++;
+        if(free_count>MAX_ENCODE_REQUEST)//error has occured
+            break;
+    }
+
+    head = &encode_manager.process_queue;
+    list_for_each_entry(pitem, head , list){
+        process_count++;
+        if(free_count>MAX_ENCODE_REQUEST)//error has occured
+            break;
+    }
+
+    current_wq = encode_manager.current_wq;
+    last_wq = encode_manager.last_wq;
+    pitem = encode_manager.current_item;
+    irq_num = encode_manager.irq_num;
+    hw_status = encode_manager.encode_hw_status;
+    process_queue_state = encode_manager.process_queue_state;
+    wq_count = encode_manager.wq_count;
+    ucode_index = encode_manager.ucode_index;
+    need_reset = encode_manager.need_reset;
+    process_irq = encode_manager.process_irq;
+    inited = encode_manager.inited;
+    use_reserve = encode_manager.use_reserve;
+    if(use_reserve){
+        reserve_mem.buf_start = encode_manager.reserve_mem.buf_start;
+        reserve_mem.buf_size = encode_manager.reserve_mem.buf_size;
+    }
+    max_instance = encode_manager.max_instance;
+#ifdef CONFIG_CMA
+    check_cma = encode_manager.check_cma;
+#endif
+
+    spin_unlock(&encode_manager.event.sem_lock);
+    
+    encode_debug_level(LOG_LEVEL_DEBUG, "encode process queue count: %d, free queue count: %d.\n",process_count, free_count);
+    encode_debug_level(LOG_LEVEL_DEBUG, "encode curent wq: %p, last wq: %p, wq count: %d, max_instance: %d.\n",current_wq, last_wq, wq_count,max_instance);
+    encode_debug_level(LOG_LEVEL_DEBUG, "encode curent pitem: %p, ucode_index: %d, hw_status: %d, need_reset: %s, process_irq: %s.\n",pitem, ucode_index, hw_status, need_reset?"true":"false",process_irq?"true":"false");
+    encode_debug_level(LOG_LEVEL_DEBUG, "encode irq num: %d,  inited: %s, process_queue_state: %d.\n",irq_num, inited?"true":"false",  process_queue_state);
+    if(use_reserve){
+        encode_debug_level(LOG_LEVEL_DEBUG, "encode use reserve memory, buffer start: %d, size: %d.\n",reserve_mem.buf_start, reserve_mem.buf_size);
+    }else{
+#ifdef CONFIG_CMA
+        encode_debug_level(LOG_LEVEL_DEBUG, "encode check cma: %s.\n",check_cma?"true":"false");
+#endif
+    }
+    return snprintf(buf,40,"encode max instance: %d\n", max_instance);
+}
+
+static struct class_attribute amvenc_class_attrs[] = {
+    __ATTR(encode_status,
+        S_IRUGO | S_IWUSR,
+        encode_status_show,
+        NULL),
+    __ATTR_NULL
+};
+
+static struct class amvenc_avc_class = {
+	.name = CLASS_NAME,
+	.class_attrs = amvenc_class_attrs,
+};
+
 int  init_avc_device(void)
 {
     int  r =0;
     r =register_chrdev(0,DEVICE_NAME,&amvenc_avc_fops);
-    if(r<=0)
-    {
-        amlog_level(LOG_LEVEL_HIGH,"register amvenc_avc device error\n");
+    if(r<=0){
+        encode_debug_level(LOG_LEVEL_ERROR,"register amvenc_avc device error.\n");
         return  r  ;
     }
     avc_device_major= r ;
 
-    amvenc_avc_class = class_create(THIS_MODULE, DEVICE_NAME);
-
-    amvenc_avc_dev = device_create(amvenc_avc_class, NULL,
+    r = class_register(&amvenc_avc_class);
+    if(r<0){
+        encode_debug_level(LOG_LEVEL_ERROR,"error create amvenc_avc class.\n");
+        return r;
+    }
+    
+    amvenc_avc_dev = device_create(&amvenc_avc_class, NULL,
                                   MKDEV(avc_device_major, 0), NULL,
                                   DEVICE_NAME);
+
+    if (IS_ERR(amvenc_avc_dev)){
+        encode_debug_level(LOG_LEVEL_ERROR,"create amvenc_avc device error.\n");
+        class_unregister(&amvenc_avc_class);
+        return -1 ;
+    }
     return r;
 }
+
 int uninit_avc_device(void)
 {
-    device_destroy(amvenc_avc_class, MKDEV(avc_device_major, 0));
+    if(amvenc_avc_dev)
+        device_destroy(&amvenc_avc_class, MKDEV(avc_device_major, 0));
 
-    class_destroy(amvenc_avc_class);
+    class_destroy(&amvenc_avc_class);
 
     unregister_chrdev(avc_device_major, DEVICE_NAME);
     return 0;
 }
 
-#ifndef CONFIG_CMA
-static struct resource memobj;
-#endif
 static int amvenc_avc_probe(struct platform_device *pdev)
 {
-#ifndef CONFIG_CMA
-    struct resource *mem;
+    struct resource mem;
     int idx;
-#endif
 
-    amlog_level(LOG_LEVEL_INFO, "amvenc_avc probe start.\n");
+    encode_debug_level(LOG_LEVEL_INFO, "amvenc_avc probe start.\n");
 
 #ifdef CONFIG_CMA
-    this_pdev = pdev;
-#else
-    mem = &memobj;
+    encode_manager.this_pdev = pdev;
+    encode_manager.check_cma = false;
+#endif
+    encode_manager.reserve_mem.buf_start = 0;
+    encode_manager.reserve_mem.buf_size= 0;
+    encode_manager.use_reserve = false;
+    encode_manager.max_instance = 0;
+    encode_manager.reserve_buff = NULL;
+
     idx = find_reserve_block(pdev->dev.of_node->name,0);
     if(idx < 0){
-		amlog_level(LOG_LEVEL_ERROR, "amvenc_avc memory resource undefined.\n");
-        return -EFAULT;
-    }
-    mem->start = (phys_addr_t)get_reserve_block_addr(idx);
-    mem->end = mem->start+ (phys_addr_t)get_reserve_block_size(idx)-1;
-    gAmvencbuff.buf_start = mem->start;
-    gAmvencbuff.buf_size = mem->end - mem->start + 1;
-
-    if(gAmvencbuff.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P].min_buffsize){
-        gAmvencbuff.cur_buf_lev = AMVENC_BUFFER_LEVEL_1080P;
-        gAmvencbuff.bufspec = (BuffInfo_t*)&amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P];
-    }else if(gAmvencbuff.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_720P].min_buffsize){
-        gAmvencbuff.cur_buf_lev = AMVENC_BUFFER_LEVEL_720P;
-        gAmvencbuff.bufspec= (BuffInfo_t*)&amvenc_buffspec[AMVENC_BUFFER_LEVEL_720P];
-    }else if(gAmvencbuff.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_480P].min_buffsize){
-        gAmvencbuff.cur_buf_lev = AMVENC_BUFFER_LEVEL_480P;
-        gAmvencbuff.bufspec= (BuffInfo_t*)&amvenc_buffspec[AMVENC_BUFFER_LEVEL_480P];
+        encode_debug_level(LOG_LEVEL_ERROR, "amvenc_avc memory resource undefined.\n");
     }else{
-        gAmvencbuff.buf_start = 0;
-        gAmvencbuff.buf_size = 0;
-        amlog_level(LOG_LEVEL_ERROR, "amvenc_avc memory resource too small, size is %d.\n",gAmvencbuff.buf_size);
+        mem.start = (phys_addr_t)get_reserve_block_addr(idx);
+        mem.end = mem.start+ (phys_addr_t)get_reserve_block_size(idx)-1;
+        encode_manager.reserve_mem.buf_start = mem.start;
+        encode_manager.reserve_mem.buf_size = mem.end - mem.start + 1;
+        
+        if(encode_manager.reserve_mem.buf_size>=amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P].min_buffsize){
+            encode_manager.max_instance = encode_manager.reserve_mem.buf_size/amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P].min_buffsize;
+            if(encode_manager.max_instance>MAX_ENCODE_INSTANCE)
+                encode_manager.max_instance = MAX_ENCODE_INSTANCE;
+            encode_manager.reserve_buff = (Buff_t*)kzalloc(encode_manager.max_instance*sizeof(Buff_t), GFP_KERNEL);
+            if(encode_manager.reserve_buff){
+                int i = 0;
+                for(i = 0; i < encode_manager.max_instance;i++){
+                    encode_manager.reserve_buff[i].buf_start = i*amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P].min_buffsize+encode_manager.reserve_mem.buf_start;
+                    encode_manager.reserve_buff[i].buf_size = encode_manager.reserve_mem.buf_start;
+                    encode_manager.reserve_buff[i].used = false;
+                }
+                encode_manager.use_reserve = true;
+                encode_debug_level(LOG_LEVEL_DEBUG, "amvenc_avc  use reserve memory, buff start: 0x%x, size: 0x%x,  max instance is %d\n",encode_manager.reserve_mem.buf_start,encode_manager.reserve_mem.buf_size,encode_manager.max_instance);
+            }else{
+                encode_debug_level(LOG_LEVEL_ERROR, "amvenc_avc alloc reserve buffer pointer fail. max instance is %d.\n",encode_manager.max_instance);
+                encode_manager.max_instance = 0;
+                encode_manager.reserve_mem.buf_start = 0;
+                encode_manager.reserve_mem.buf_size= 0;
+            }
+        }else{
+            encode_debug_level(LOG_LEVEL_ERROR, "amvenc_avc memory resource too small, size is 0x%x. Need 0x%x bytes at least.\n",encode_manager.reserve_mem.buf_size, amvenc_buffspec[AMVENC_BUFFER_LEVEL_1080P].min_buffsize);
+            encode_manager.reserve_mem.buf_start = 0;
+            encode_manager.reserve_mem.buf_size= 0;
+        }
+    }
+#ifndef CONFIG_CMA
+    if(encode_manager.use_reserve == false){
+        encode_debug_level(LOG_LEVEL_ERROR, "amvenc_avc memory is invaild, probe fail!\n");
         return -EFAULT;
     }
-
-    inter_bits_info_ddr_start_addr = gAmvencbuff.buf_start+gAmvencbuff.bufspec->inter_bits_info.buf_start; // 32 bytes alignment
-    inter_mv_info_ddr_start_addr  = gAmvencbuff.buf_start+gAmvencbuff.bufspec->inter_mv_info.buf_start;
-    intra_bits_info_ddr_start_addr = gAmvencbuff.buf_start+gAmvencbuff.bufspec->intra_bits_info.buf_start; // 32 bytes alignment
-    intra_pred_info_ddr_start_addr  = gAmvencbuff.buf_start+gAmvencbuff.bufspec->intra_pred_info.buf_start;
-    sw_ctl_info_start_addr = gAmvencbuff.buf_start+gAmvencbuff.bufspec->qp_info.buf_start;
-#ifdef USE_VDEC2
-    vdec2_start_addr = gAmvencbuff.buf_start+gAmvencbuff.bufspec->vdec2_info.buf_start;
-#endif
-    debug_level(1,"amvenc_avc  memory config sucess, buff size is 0x%x, level is %s\n",gAmvencbuff.buf_size,(gAmvencbuff.cur_buf_lev == 0)?"480P":(gAmvencbuff.cur_buf_lev == 1)?"720P":"1080P");
 #endif
+    if (encode_wq_init()){
+        if(encode_manager.reserve_buff){
+            kfree(encode_manager.reserve_buff);
+            encode_manager.reserve_buff = NULL;
+        }
+        encode_debug_level(LOG_LEVEL_ERROR, "encode work queue init error .\n");	
+        return -EFAULT;	
+    }
 
     init_avc_device();
-    amlog_level(LOG_LEVEL_INFO, "amvenc_avc probe end.\n");
+    encode_debug_level(LOG_LEVEL_INFO, "amvenc_avc probe end.\n");
     return 0;
 }
 
 static int amvenc_avc_remove(struct platform_device *pdev)
 {
+    if(encode_manager.reserve_buff){
+        kfree(encode_manager.reserve_buff);
+        encode_manager.reserve_buff = NULL;
+    }
+    if (encode_wq_uninit()){
+        encode_debug_level(LOG_LEVEL_ERROR, "encode work queue uninit error.\n");	
+    }
     uninit_avc_device();
-    amlog_level(LOG_LEVEL_INFO, "amvenc_avc remove.\n");
+    encode_debug_level(LOG_LEVEL_INFO, "amvenc_avc remove.\n");
     return 0;
 }
 
@@ -2460,16 +2784,18 @@ static struct platform_driver amvenc_avc_driver = {
         .of_match_table = amlogic_avcenc_dt_match,
     }
 };
+
 static struct codec_profile_t amvenc_avc_profile = {
 	.name = "avc",
 	.profile = ""
 };
+
 static int __init amvenc_avc_driver_init_module(void)
 {
-    amlog_level(LOG_LEVEL_INFO, "amvenc_avc module init\n");
+    encode_debug_level(LOG_LEVEL_INFO, "amvenc_avc module init\n");
 
     if (platform_driver_register(&amvenc_avc_driver)) {
-        amlog_level(LOG_LEVEL_ERROR, "failed to register amvenc_avc driver\n");
+        encode_debug_level(LOG_LEVEL_ERROR, "failed to register amvenc_avc driver\n");
         return -ENODEV;
     }
     vcodec_profile_register(&amvenc_avc_profile);
@@ -2478,16 +2804,13 @@ static int __init amvenc_avc_driver_init_module(void)
 
 static void __exit amvenc_avc_driver_remove_module(void)
 {
-    amlog_level(LOG_LEVEL_INFO, "amvenc_avc module remove.\n");
+    encode_debug_level(LOG_LEVEL_INFO, "amvenc_avc module remove.\n");
 
     platform_driver_unregister(&amvenc_avc_driver);
 }
 
 /****************************************/
 
-module_param(stat, uint, 0664);
-MODULE_PARM_DESC(stat, "\n amvenc_avc stat \n");
-
 module_param(me_mv_merge_ctl, uint, 0664);
 MODULE_PARM_DESC(me_mv_merge_ctl, "\n me_mv_merge_ctl \n");
 
@@ -2518,15 +2841,15 @@ MODULE_PARM_DESC(me_sad_enough_23, "\n me_sad_enough_23 \n");
 module_param(fixed_slice_cfg, uint, 0664);
 MODULE_PARM_DESC(fixed_slice_cfg, "\n fixed_slice_cfg \n");
 
-module_param(ucode_index, uint, 0664);
-MODULE_PARM_DESC(ucode_index, "\n ucode_index \n");
-
 module_param(enable_dblk, uint, 0664);
 MODULE_PARM_DESC(enable_dblk, "\n enable_dblk \n");
 
 module_param(clock_level, uint, 0664);
 MODULE_PARM_DESC(clock_level, "\n clock_level \n");
 
+module_param(encode_print_level, uint, 0664);
+MODULE_PARM_DESC(encode_print_level, "\n encode_print_level \n");
+
 module_init(amvenc_avc_driver_init_module);
 module_exit(amvenc_avc_driver_remove_module);
 
diff --git a/drivers/amlogic/amports/encoder.h b/drivers/amlogic/amports/encoder.h
index f77c60150b89..e34e731c6985 100755
--- a/drivers/amlogic/amports/encoder.h
+++ b/drivers/amlogic/amports/encoder.h
@@ -1,7 +1,15 @@
-
 #ifndef __H264_H__
 #define __H264_H__
 
+#include <linux/mutex.h>
+#include <linux/semaphore.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+
 #define AMVENC_DEV_VERSION "AML-M8"
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 #define INT_AMVENCODER INT_DOS_MAILBOX_2
@@ -65,29 +73,41 @@
 #define HCODEC_IMEM_DMA_COUNT   IMEM_DMA_COUNT
 #endif
 
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
+#define USE_VDEC2
+#endif
+
+#ifdef USE_VDEC2
+ #define VDEC2_DEF_BUF_START_ADDR            0x01000000
+#endif
+
+#define LOG_LEVEL_ALL      0
+#define LOG_LEVEL_INFO    1
+#define LOG_LEVEL_DEBUG 2
+#define LOG_LEVEL_ERROR 3
+
+#define encode_debug_level(level, x...) \
+	do { \
+		if (level >= encode_print_level) \
+			printk(x); \
+	} while (0);
+
 #define AMVENC_AVC_IOC_MAGIC  'E'
 
 #define AMVENC_AVC_IOC_GET_DEVINFO 				_IOW(AMVENC_AVC_IOC_MAGIC, 0xf0, unsigned int)
+#define AMVENC_AVC_IOC_MAX_INSTANCE 				_IOW(AMVENC_AVC_IOC_MAGIC, 0xf1, unsigned int)
 
 #define AMVENC_AVC_IOC_GET_ADDR			 		_IOW(AMVENC_AVC_IOC_MAGIC, 0x00, unsigned int)
 #define AMVENC_AVC_IOC_INPUT_UPDATE				_IOW(AMVENC_AVC_IOC_MAGIC, 0x01, unsigned int)
-#define AMVENC_AVC_IOC_GET_STATUS				_IOW(AMVENC_AVC_IOC_MAGIC, 0x02, unsigned int)
-#define AMVENC_AVC_IOC_NEW_CMD					_IOW(AMVENC_AVC_IOC_MAGIC, 0x03, unsigned int)
-#define AMVENC_AVC_IOC_GET_STAGE					_IOW(AMVENC_AVC_IOC_MAGIC, 0x04, unsigned int)
-#define AMVENC_AVC_IOC_GET_OUTPUT_SIZE			_IOW(AMVENC_AVC_IOC_MAGIC, 0x05, unsigned int)
-#define AMVENC_AVC_IOC_SET_QUANT 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x06, unsigned int)
-#define AMVENC_AVC_IOC_SET_ENCODER_WIDTH 		_IOW(AMVENC_AVC_IOC_MAGIC, 0x07, unsigned int)
-#define AMVENC_AVC_IOC_SET_ENCODER_HEIGHT 		_IOW(AMVENC_AVC_IOC_MAGIC, 0x08, unsigned int)
-#define AMVENC_AVC_IOC_CONFIG_INIT 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x09, unsigned int)
-#define AMVENC_AVC_IOC_FLUSH_CACHE 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x0a, unsigned int)
-#define AMVENC_AVC_IOC_FLUSH_DMA 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x0b, unsigned int)
-#define AMVENC_AVC_IOC_GET_BUFFINFO 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x0c, unsigned int)
-
-#define AMVENC_AVC_IOC_SET_IE_ME_MB_TYPE 		_IOW(AMVENC_AVC_IOC_MAGIC, 0x0d, unsigned int)
-#define AMVENC_AVC_IOC_SET_ME_PIXEL_MODE 		_IOW(AMVENC_AVC_IOC_MAGIC, 0x0e, unsigned int)
-#define AMVENC_AVC_IOC_SUBMIT_ENCODE_DONE 		_IOW(AMVENC_AVC_IOC_MAGIC, 0x0f, unsigned int)
-#define AMVENC_AVC_IOC_READ_CANVAS 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x10, unsigned int)
-#define AMVENC_AVC_IOC_LIGHT_RESET 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x11, unsigned int)
+#define AMVENC_AVC_IOC_NEW_CMD					_IOW(AMVENC_AVC_IOC_MAGIC, 0x02, unsigned int)
+#define AMVENC_AVC_IOC_GET_STAGE					_IOW(AMVENC_AVC_IOC_MAGIC, 0x03, unsigned int)
+#define AMVENC_AVC_IOC_GET_OUTPUT_SIZE			_IOW(AMVENC_AVC_IOC_MAGIC, 0x04, unsigned int)
+#define AMVENC_AVC_IOC_CONFIG_INIT 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x05, unsigned int)
+#define AMVENC_AVC_IOC_FLUSH_CACHE 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x06, unsigned int)
+#define AMVENC_AVC_IOC_FLUSH_DMA 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x07, unsigned int)
+#define AMVENC_AVC_IOC_GET_BUFFINFO 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x08, unsigned int)
+#define AMVENC_AVC_IOC_SUBMIT_ENCODE_DONE 		_IOW(AMVENC_AVC_IOC_MAGIC, 0x09, unsigned int)
+#define AMVENC_AVC_IOC_READ_CANVAS 				_IOW(AMVENC_AVC_IOC_MAGIC, 0x0a, unsigned int)
 
 
 #define IE_PIPPELINE_BLOCK_SHIFT 0
@@ -116,6 +136,204 @@ typedef enum{
     MAX_FRAME_FMT
 }amvenc_frame_fmt;
 
+#define AMVENC_BUFFER_LEVEL_480P   0
+#define AMVENC_BUFFER_LEVEL_720P   1
+#define AMVENC_BUFFER_LEVEL_1080P 2
+
+#define MAX_ENCODE_REQUEST  8   //64  
+
+#define MAX_ENCODE_INSTANCE  8   //64  
+
+#define ENCODE_PROCESS_QUEUE_START 	0
+#define ENCODE_PROCESS_QUEUE_STOP 	1
+
+#define AMVENC_FLUSH_FLAG_INPUT 			0x1
+#define AMVENC_FLUSH_FLAG_OUTPUT 		0x2
+#define AMVENC_FLUSH_FLAG_REFERENCE 		0x4
+#define AMVENC_FLUSH_FLAG_INTRA_INFO 	0x8
+#define AMVENC_FLUSH_FLAG_INTER_INFO 	0x10
+#define AMVENC_FLUSH_FLAG_QP			 	0x20
+
+#define ENCODER_BUFFER_INPUT              0
+#define ENCODER_BUFFER_REF0                1
+#define ENCODER_BUFFER_REF1                2
+#define ENCODER_BUFFER_OUTPUT           3
+#define ENCODER_BUFFER_INTER_INFO    4
+#define ENCODER_BUFFER_INTRA_INFO    5
+#define ENCODER_BUFFER_QP           	    6
+
+typedef struct encode_wq_s encode_wq_t;
+
+typedef struct {
+    u32 quant;
+    u32 cmd;
+    u32 ucode_mode;
+
+    u32 src;
+    amvenc_mem_type type;
+    amvenc_frame_fmt fmt;
+    u32 framesize;
+    u32 qp_info_size;
+
+    u32 flush_flag;
+    u32 timeout;
+    encode_wq_t* parent;
+}encode_request_t;
+
+typedef  struct {
+    struct list_head list;
+    encode_request_t request ;
+}encode_queue_item_t;
+
+typedef struct
+{
+    u32 buf_start;
+    u32 buf_size;
+    bool used;
+} Buff_t;
+
+typedef struct
+{
+    u32 lev_id;
+    u32 min_buffsize;
+    u32 max_width;
+    u32 max_height;
+    Buff_t dct;
+    Buff_t dec0_y;
+    Buff_t dec0_uv;
+    Buff_t dec1_y;
+    Buff_t dec1_uv;
+    Buff_t assit;
+    Buff_t bitstream;
+    Buff_t inter_bits_info;
+    Buff_t inter_mv_info;
+    Buff_t intra_bits_info;
+    Buff_t intra_pred_info;
+    Buff_t qp_info;
+#ifdef USE_VDEC2
+    Buff_t vdec2_info;
+#endif
+} BuffInfo_t;
+
+typedef struct{
+#ifdef CONFIG_CMA
+    struct page *venc_pages;
+#endif
+    u32 buf_start;
+    u32 buf_size;
+    u8 cur_buf_lev;
+    BuffInfo_t bufspec; 
+    u32 BitstreamStart;
+    u32 BitstreamEnd;
+
+    /*input buffer define*/
+    u32 dct_buff_start_addr;
+    u32 dct_buff_end_addr;
+
+    /*microcode assitant buffer*/
+    u32 assit_buffer_offset;
+
+    u32 inter_bits_info_ddr_start_addr;
+    u32 inter_mv_info_ddr_start_addr;
+    u32 intra_bits_info_ddr_start_addr;
+    u32 intra_pred_info_ddr_start_addr;
+    u32 sw_ctl_info_start_addr;
+#ifdef USE_VDEC2
+    u32 vdec2_start_addr;
+#endif
+
+    u32 dblk_buf_canvas;
+    u32 ref_buf_canvas;
+} encode_meminfo_t;
+
+typedef struct{
+    u32 encoder_width;
+    u32 encoder_height;
+
+    u32 rows_per_slice;
+
+    u32 idr_pic_id;  //need reset as 0 for IDR
+    u32 frame_number;   //need plus each frame
+    u32 pic_order_cnt_lsb; //need reset as 0 for IDR and plus 2 for NON-IDR
+
+    u32 log2_max_pic_order_cnt_lsb;
+    u32 log2_max_frame_num;
+    u32 init_qppicture;
+} encode_picinfo_t;
+
+typedef struct{
+    u32 dct_buffer_write_ptr;
+    u32 dct_flush_start;
+    bool can_update;
+    bool finish;
+} encode_control_t;
+
+struct encode_wq_s{
+    struct list_head list;
+    encode_request_t request;
+    atomic_t request_ready;
+    wait_queue_head_t request_complete;
+
+    // dev info
+    u32 ucode_index;
+    u32 hw_status;
+    u32 output_size;
+
+    u32 sps_size;
+    u32 pps_size;
+
+    encode_meminfo_t mem;
+    encode_picinfo_t pic;
+    encode_control_t control;
+};
+
+typedef  struct {
+    wait_queue_head_t hw_complete;
+    struct completion process_complete;
+    spinlock_t sem_lock; //for queue switch and create destroy queue.
+    struct semaphore request_in_sem;
+}encode_event_t;
+
+typedef  struct {
+    struct list_head wq;
+    struct list_head process_queue;
+    struct list_head free_queue;
+    encode_wq_t* current_wq;
+    encode_wq_t* last_wq;
+    encode_queue_item_t* current_item;
+    struct task_struct* encode_thread;
+    encode_event_t event ;
+
+    struct tasklet_struct encode_tasklet;
+
+    int encode_hw_status;
+    int process_queue_state;
+    int irq_num;
+    int wq_count;
+
+    u32 ucode_index;
+    bool dblk_fix_flag;
+    bool need_reset;
+    bool process_irq;
+    bool inited; // power on encode
+    bool remove_flag; // remove wq;
+    bool uninit_flag; //power off encode
+
+    bool use_reserve;
+    Buff_t reserve_mem;
+    Buff_t* reserve_buff;
+    u32 max_instance;
+
+#ifdef CONFIG_CMA
+    bool check_cma;
+    struct platform_device *this_pdev;
+#endif
+}encode_manager_t ;
+
+extern int encode_wq_add_request(encode_wq_t *wq);
+extern encode_wq_t* create_encode_work_queue(void);
+extern int destroy_encode_work_queue(encode_wq_t* encode_work_queue);
+
 // Memory Address
 ///////////////////////////////////////////////////////////////////////////
 #define MicrocodeStart        0x0000
@@ -380,6 +598,8 @@ typedef enum{
 #define ENCODER_NON_IDR_INTRA     13
 #define ENCODER_NON_IDR_INTER     14
 
+#define ENCODER_ERROR     0xff
+
 //---------------------------------------------------
 // NAL start code define
 //---------------------------------------------------
diff --git a/drivers/amlogic/amports/jpegenc.c b/drivers/amlogic/amports/jpegenc.c
index 316c074d2c9c..ef9b432224af 100755
--- a/drivers/amlogic/amports/jpegenc.c
+++ b/drivers/amlogic/amports/jpegenc.c
@@ -1336,7 +1336,7 @@ bool jpegenc_on(void)
     spin_lock_irqsave(&lock, flags);
 
     hcodec_on = vdec_on(VDEC_HCODEC);
-    hcodec_on |=(encode_opened>0);
+    hcodec_on &=(encode_opened>0);
 
     spin_unlock_irqrestore(&lock, flags);
     return hcodec_on;
diff --git a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_dump.h b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_dump.h
index a9c1afa9708f..20ab8b59d450 100755
--- a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_dump.h
+++ b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_dump.h
@@ -35,7 +35,7 @@ const u32 MicroCode[] __attribute__ ((aligned (8))) = {
 	0x0000000,0x0000000,0x0000000,0x0000000,0x64d1608,0xbefc108,0x0000000,0x64d1b08,
 	0x9808648,0x60d1b08,0x64d1608,0xbefc108,0x0000000,0x80ac008,0xc787400,0x8007801,
 	0x64d3109,0x9010289,0x400f28a,0x580428a,0x440128a,0x7c0030a,0x9210289,0x400f28a,
-	0x580428a,0x440128a,0x7c0034a,0x6800049,0xcc00000,0x7c003c9,0xc014000,0x0000000,
+	0x580428a,0x440128a,0x7c0034a,0x6800009,0xcc00000,0x7c003c9,0xc014000,0x0000000,
 	0x6498e08,0x9c08788,0x6098e08,0x6490b08,0x9c08608,0x9c08648,0x6090b08,0x6401108,
 	0x9c08748,0x9c08788,0x6001108,0x6401008,0x9808008,0x6001008,0x9c08008,0x6001008,
 	0xc014480,0x0000000,0xc013a80,0x0000000,0xc07bcc0,0x0000000,0x64f4908,0x9c08048,
diff --git a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_dump_dblk.h b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_dump_dblk.h
index 419d5a444fe0..e73282d4ae9a 100755
--- a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_dump_dblk.h
+++ b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_dump_dblk.h
@@ -35,7 +35,7 @@ const u32 MicroCode[] __attribute__ ((aligned (8))) = {
 	0x0000000,0x0000000,0x0000000,0x0000000,0x64d1608,0xbefc108,0x0000000,0x64d1b08,
 	0x9808648,0x60d1b08,0x64d1608,0xbefc108,0x0000000,0x80ac008,0xc787180,0x8007801,
 	0x64d3109,0x9010289,0x400f28a,0x580428a,0x440128a,0x7c0030a,0x9210289,0x400f28a,
-	0x580428a,0x440128a,0x7c0034a,0x6800049,0xcc00000,0x7c003c9,0xc013d80,0x0000000,
+	0x580428a,0x440128a,0x7c0034a,0x6800009,0xcc00000,0x7c003c9,0xc013d80,0x0000000,
 	0x6498e08,0x9c08788,0x6098e08,0x6490b08,0x9c08608,0x9c08648,0x6090b08,0x6401108,
 	0x9c08748,0x9c08788,0x6001108,0x6401008,0x9808008,0x6001008,0x9c08008,0x6001008,
 	0xc014200,0x0000000,0xc013800,0x0000000,0xc07bcc0,0x0000000,0x64f4908,0x9c08048,
diff --git a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw.h b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw.h
index 6f82ae0c4357..4c69af065994 100755
--- a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw.h
+++ b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw.h
@@ -35,7 +35,7 @@ const u32 MicroCode[] __attribute__ ((aligned (8))) = {
 	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x64d1608,0xbefc108,
 	0x0000000,0x64d1b08,0x9808648,0x60d1b08,0x64d1608,0xbefc108,0x0000000,0x80ac008,
 	0xc785b80,0x8007801,0x64d3109,0x9010289,0x400f28a,0x580428a,0x440128a,0x7c0030a,
-	0x9210289,0x400f28a,0x580428a,0x440128a,0x7c0034a,0x6800049,0xcc00000,0x7c003c9,
+	0x9210289,0x400f28a,0x580428a,0x440128a,0x7c0034a,0x6800009,0xcc00000,0x7c003c9,
 	0x64f4008,0x9c08048,0x60f4008,0xc017400,0x0000000,0x6498e08,0x9c08788,0x6098e08,
 	0x6490b08,0x9c08608,0x9c08648,0x6090b08,0x6401008,0x9808008,0x6001008,0xc017a00,
 	0x0000000,0xc017000,0x0000000,0xc07bd80,0x0000000,0x64f4908,0x9c08048,0x60f4908,
diff --git a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_hdec_dblk.h b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_hdec_dblk.h
index aa5c9471a4c9..870c97ef3d8a 100755
--- a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_hdec_dblk.h
+++ b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_hdec_dblk.h
@@ -35,7 +35,7 @@ const u32 MicroCode[] __attribute__ ((aligned (8))) = {
 	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x64d1608,0xbefc108,
 	0x0000000,0x64d1b08,0x9808648,0x60d1b08,0x64d1608,0xbefc108,0x0000000,0x80ac008,
 	0xc785940,0x8007801,0x64d3109,0x9010289,0x400f28a,0x580428a,0x440128a,0x7c0030a,
-	0x9210289,0x400f28a,0x580428a,0x440128a,0x7c0034a,0x6800049,0xcc00000,0x7c003c9,
+	0x9210289,0x400f28a,0x580428a,0x440128a,0x7c0034a,0x6800009,0xcc00000,0x7c003c9,
 	0x64f4008,0x9c08048,0x60f4008,0xc0171c0,0x0000000,0x6498e08,0x9c08788,0x6098e08,
 	0x6490b08,0x9c08608,0x9c08648,0x6090b08,0x6401008,0x9808008,0x6001008,0xc0177c0,
 	0x0000000,0xc016dc0,0x0000000,0xc07bd80,0x0000000,0x64f4908,0x9c08048,0x60f4908,
diff --git a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_hdec_m2_dblk.h b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_hdec_m2_dblk.h
old mode 100644
new mode 100755
index 9a566aeb2d26..064b2143d1b1
--- a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_hdec_m2_dblk.h
+++ b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_hdec_m2_dblk.h
@@ -35,7 +35,7 @@ const u32 MicroCode[] __attribute__ ((aligned (8))) = {
 	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x64d1608,0xbefc108,
 	0x0000000,0x64d1b08,0x9808648,0x60d1b08,0x64d1608,0xbefc108,0x0000000,0x80ac008,
 	0xc785a80,0x8007801,0x64d3109,0x9010289,0x400f28a,0x580428a,0x440128a,0x7c0030a,
-	0x9210289,0x400f28a,0x580428a,0x440128a,0x7c0034a,0x6800049,0xcc00000,0x7c003c9,
+	0x9210289,0x400f28a,0x580428a,0x440128a,0x7c0034a,0x6800009,0xcc00000,0x7c003c9,
 	0x64f4008,0x9c08048,0x60f4008,0xc017a40,0x0000000,0x6498e08,0x9c08788,0x6098e08,
 	0x6490b08,0x9c08608,0x9c08648,0x6090b08,0x6401008,0x9808008,0x6001008,0xc018140,
 	0x0000000,0xc017640,0x0000000,0xc07bd80,0x0000000,0x64f4908,0x9c08048,0x60f4908,
diff --git a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_vdec2_dblk.h b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_vdec2_dblk.h
index 9bab4fb9932f..9a84aace0f79 100755
--- a/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_vdec2_dblk.h
+++ b/drivers/amlogic/amports/m8/ucode/encoder/h264_enc_mix_sw_vdec2_dblk.h
@@ -35,7 +35,7 @@ const u32 MicroCode[] __attribute__ ((aligned (8))) = {
 	0x80d1d00,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x64d1608,
 	0xbefc108,0x0000000,0x64d1b08,0x9808648,0x60d1b08,0x64d1608,0xbefc108,0x0000000,
 	0x80ac008,0xc785940,0x8007801,0x64d3109,0x9010289,0x400f28a,0x580428a,0x440128a,
-	0x7c0030a,0x9210289,0x400f28a,0x580428a,0x440128a,0x7c0034a,0x6800049,0xcc00000,
+	0x7c0030a,0x9210289,0x400f28a,0x580428a,0x440128a,0x7c0034a,0x6800009,0xcc00000,
 	0x7c003c9,0x64f4008,0x9c08048,0x60f4008,0xc017740,0x0000000,0x6498e08,0x9c08788,
 	0x6098e08,0x6490b08,0x9c08608,0x9c08648,0x6090b08,0x6401008,0x9808008,0x6001008,
 	0xc017d40,0x0000000,0xc017340,0x0000000,0xc07bd80,0x0000000,0x64f4908,0x9c08048,
diff --git a/drivers/amlogic/video_dev/amlvideo2.c b/drivers/amlogic/video_dev/amlvideo2.c
index 5b01add87ed8..28c05617d201 100755
--- a/drivers/amlogic/video_dev/amlvideo2.c
+++ b/drivers/amlogic/video_dev/amlvideo2.c
@@ -2224,6 +2224,10 @@ static int  amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 	if(no_frame)
 		goto unlock;
 	if(frame_inittime == 1){
+		if(tmp_vf){
+			vf_inqueue(tmp_vf,node->recv.name);
+			tmp_vf = NULL;
+		}
 		frameInv_adjust = 0;
 		frameInv = 0;
 		thread_ts1.tv_sec = vf->pts_us64& 0xFFFFFFFF;
@@ -2239,6 +2243,10 @@ static int  amlvideo2_thread_tick(struct amlvideo2_fh *fh)
 	}
 #else
 	if(frame_inittime == 1){
+		if(tmp_vf){
+			vf_inqueue(tmp_vf,node->recv.name);
+			tmp_vf = NULL;
+		}
 	   	if(no_frame)
 			goto unlock;
 		frameInv_adjust = 0;
@@ -2423,6 +2431,7 @@ static int amlvideo2_thread(void *data)
 	while(!kthread_should_stop()){
 		msleep(10);
 	}
+	tmp_vf = NULL;
 	dprintk(node->vid_dev, 1, "thread: exit\n");
 	return ret;
 }
@@ -3042,11 +3051,11 @@ static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 	vops->start_tvin_service(node->vdin_device_num,&para);
 
 start:
-	fh->is_streamed_on = 1;
-	frameInv_adjust = 0;
-	frameInv = 0;
-	tmp_vf = NULL;
 	frame_inittime = 1;
+	fh->is_streamed_on = 1;
+	//frameInv_adjust = 0;
+	//frameInv = 0;
+	//tmp_vf = NULL;
 	do_gettimeofday( &thread_ts1);
 #ifdef TEST_LATENCY
 	cur_time  = cur_time_out = thread_ts1.tv_sec;
-- 
2.19.0

