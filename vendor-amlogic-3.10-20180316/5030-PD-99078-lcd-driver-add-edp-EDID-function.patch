From da9d1110c3b3ad7854bb166477f95d35bc555210 Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Thu, 30 Oct 2014 10:22:26 +0800
Subject: [PATCH 5030/5965] PD#99078: lcd driver: add edp EDID function

Change-Id: Ic893b4a854a3d73264aa3e11e67c2a67d7ec1f78
---
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |    2 +
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |    2 +
 arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd  |    2 +
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |    2 +
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |    2 +
 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd  |    2 +
 arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd  |    2 +
 arch/arm/mach-meson8/lcd/edp_drv.c            | 1017 ++++++++++++-----
 arch/arm/mach-meson8/lcd/edp_drv.h            |  158 ++-
 arch/arm/mach-meson8/lcd/lcd_config.c         |   47 +-
 drivers/amlogic/display/vout/aml_lcd.dtd      |    2 +
 drivers/amlogic/display/vout/lcdoutc.c        |   50 +-
 include/linux/amlogic/vout/lcdoutc.h          |    2 +
 13 files changed, 951 insertions(+), 339 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index 3aabda9389e3..76768a869c4a 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -1007,6 +1007,7 @@ sdio{
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
 //$$ L4 PROP_U32 = "edp_sync_clock_mode"
+//$$ L4 PROP_U32 = "edp_edid_timing_used"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1094,6 +1095,7 @@ sdio{
 		edp_user_link_rate_lane_count=<1 1 2>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
 		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
+		edp_edid_timing_used=<0>; /** edp use edid timing: (0=no use, 1=use) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index da19ba03b29a..b53b2d6d1186 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -997,6 +997,7 @@ sdio{
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
 //$$ L4 PROP_U32 = "edp_sync_clock_mode"
+//$$ L4 PROP_U32 = "edp_edid_timing_used"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1084,6 +1085,7 @@ sdio{
 		edp_user_link_rate_lane_count=<1 1 2>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
 		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
+		edp_edid_timing_used=<0>; /** edp use edid timing: (0=no use, 1=use) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 		
 		//lcd power ctrl	//support up to 15 steps for each sequence
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
index 36aea4b6bc9a..80c28b646b62 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
@@ -938,6 +938,7 @@ sdio{
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
 //$$ L4 PROP_U32 = "edp_sync_clock_mode"
+//$$ L4 PROP_U32 = "edp_edid_timing_used"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1025,6 +1026,7 @@ sdio{
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
 		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
+		edp_edid_timing_used=<0>; /** edp use edid timing: (0=no use, 1=use) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index 0ed1d09368eb..96a3a96889f5 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -939,6 +939,7 @@ sdio{
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
 //$$ L4 PROP_U32 = "edp_sync_clock_mode"
+//$$ L4 PROP_U32 = "edp_edid_timing_used"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1026,6 +1027,7 @@ sdio{
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
 		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
+		edp_edid_timing_used=<0>; /** edp use edid timing: (0=no use, 1=use) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index 62f462ca36a7..9c94b792ad6d 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -989,6 +989,7 @@ sdio{
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
 //$$ L4 PROP_U32 = "edp_sync_clock_mode"
+//$$ L4 PROP_U32 = "edp_edid_timing_used"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1076,6 +1077,7 @@ sdio{
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
 		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
+		edp_edid_timing_used=<0>; /** edp use edid timing: (0=no use, 1=use) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
diff --git a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
index 85cf25e6a1cd..c549d5ca755b 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
@@ -952,6 +952,7 @@ sdio{
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
 //$$ L4 PROP_U32 = "edp_sync_clock_mode"
+//$$ L4 PROP_U32 = "edp_edid_timing_used"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1039,6 +1040,7 @@ sdio{
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
 		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
+		edp_edid_timing_used=<0>; /** edp use edid timing: (0=no use, 1=use) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
diff --git a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
index 28f78841a345..2ba6d54feeea 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
@@ -972,6 +972,7 @@ sdio{
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
 //$$ L4 PROP_U32 = "edp_sync_clock_mode"
+//$$ L4 PROP_U32 = "edp_edid_timing_used"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -1059,6 +1060,7 @@ sdio{
 		edp_user_link_rate_lane_count=<1 1 4>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
 		edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
 		edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
+		edp_edid_timing_used=<0>; /** edp use edid timing: (0=no use, 1=use) */
 		rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
 		//lcd power ctrl	//support up to 15 steps for each sequence
diff --git a/arch/arm/mach-meson8/lcd/edp_drv.c b/arch/arm/mach-meson8/lcd/edp_drv.c
index 78f7d5f7e3f3..50a2b830f0f2 100755
--- a/arch/arm/mach-meson8/lcd/edp_drv.c
+++ b/arch/arm/mach-meson8/lcd/edp_drv.c
@@ -98,10 +98,10 @@ static EDP_Link_Config_t *dptx_get_link_config(void)
 	return &lconfig;
 }
 
-static int dptx_wait_phy_ready(void)
+static unsigned int dptx_wait_phy_ready(void)
 {
-	unsigned reg_val = 0;
-	unsigned done = 100;
+	unsigned int reg_val = 0;
+	unsigned int done = 100;
 	
 	do{
 		reg_val = READ_DPTX_REG(EDP_TX_PHY_STATUS);
@@ -112,9 +112,9 @@ static int dptx_wait_phy_ready(void)
 	}while(((reg_val & 0x7f) != 0x7f) && (done > 0));
 	
 	if ((reg_val & 0x7f) == 0x7f)
-		return VAL_EDP_TX_OPERATION_SUCCESS;
+		return RET_EDP_TX_OPERATION_SUCCESS;
 	else
-		return VAL_EDP_TX_OPERATION_FAILED;
+		return RET_EDP_TX_OPERATION_FAILED;
 }
 
 static void dptx_dump_link_config(void)
@@ -185,21 +185,21 @@ static void dptx_dump_MSA(void)
     DPRINT("********************************************\n");
 }
 #if 0
-static int dptx_set_link_rate(unsigned char link_rate)
+static unsigned int dptx_set_link_rate(unsigned char link_rate)
 {
-	int status = 0;
+	unsigned int status = 0;
 	
 	switch (link_rate) {
 		case VAL_EDP_TX_LINK_BW_SET_162:
 		case VAL_EDP_TX_LINK_BW_SET_270:
-			status = VAL_EDP_TX_OPERATION_SUCCESS;
+			status = RET_EDP_TX_OPERATION_SUCCESS;
 			break;
 		default:
-			status = VAL_EDP_TX_AUX_INVALID_PARAMETER;
+			status = RET_EDP_TX_AUX_INVALID_PARAMETER;
 			break;
 	}
 	
-	if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
+	if (status == RET_EDP_TX_OPERATION_SUCCESS) {
 		//reset the PHY
 		WRITE_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE, 0);	//disable the transmitter
 		WRITE_DPTX_REG(EDP_TX_PHY_RESET, 0xf);	//reset the PHY
@@ -216,9 +216,9 @@ static int dptx_set_link_rate(unsigned char link_rate)
 	return status;
 }
 
-static int dptx_set_lane_count(unsigned char lane_count)
+static unsigned int dptx_set_lane_count(unsigned char lane_count)
 {
-	int status = 0;
+	unsigned int status = 0;
 	
 	//reset the PHY
 	WRITE_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE, 0);	//disable the transmitter
@@ -301,19 +301,19 @@ static void dptx_set_MSA(EDP_MSA_t *vm)
     WRITE_DPTX_REG(EDP_TX_MAIN_STREAM_USER_PIXEL_WIDTH, vm->ppc);
 }
 
-static int dptx_init_lane_config(unsigned char link_rate, unsigned char lane_count)
+static unsigned int dptx_init_lane_config(unsigned char link_rate, unsigned char lane_count)
 {
 	unsigned enhance_framing_mode;
-	int status = 0;
+	unsigned int status = 0;
 	
 	DPRINT("set link_rate=0x%x, lane_count=%u\n", link_rate, lane_count);
 	switch (link_rate) {
 		case VAL_EDP_TX_LINK_BW_SET_162:
 		case VAL_EDP_TX_LINK_BW_SET_270:
-			status = VAL_EDP_TX_OPERATION_SUCCESS;
+			status = RET_EDP_TX_OPERATION_SUCCESS;
 			break;
 		default:
-			status = VAL_EDP_TX_AUX_INVALID_PARAMETER;
+			status = RET_EDP_TX_AUX_INVALID_PARAMETER;
 			break;
 	}
 	if (status) {
@@ -321,19 +321,19 @@ static int dptx_init_lane_config(unsigned char link_rate, unsigned char lane_cou
 	}
 	
 	switch (lane_count) {
-		case 1:			
-		case 2:			
+		case 1:
+		case 2:
 		case 4:
 			enhance_framing_mode = (READ_DPTX_REG(EDP_TX_ENHANCED_FRAME_EN) & 0x01);
 			if (enhance_framing_mode)
 				lane_count |= (1 << 7);
-			status = VAL_EDP_TX_OPERATION_SUCCESS;
+			status = RET_EDP_TX_OPERATION_SUCCESS;
 			break;
 		default:
-			status = VAL_EDP_TX_AUX_INVALID_PARAMETER;
+			status = RET_EDP_TX_AUX_INVALID_PARAMETER;
 			break;
 	}
-	if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
+	if (status == RET_EDP_TX_OPERATION_SUCCESS) {
 		WRITE_DPTX_REG(EDP_TX_LINK_BW_SET, link_rate);
 		WRITE_DPTX_REG(EDP_TX_LINK_COUNT_SET, lane_count);
 		switch (lane_count) {
@@ -358,9 +358,9 @@ static int dptx_init_lane_config(unsigned char link_rate, unsigned char lane_cou
 	return status;
 }
 
-static int dptx_init_downspread(unsigned char ss_enable)
+static unsigned int dptx_init_downspread(unsigned char ss_enable)
 {
-	int status = 0;
+	unsigned int status = 0;
 	
 	lcd_print("set spread spectrum\n");
 	ss_enable = (ss_enable > 0) ? 1 : 0;
@@ -371,7 +371,7 @@ static int dptx_init_downspread(unsigned char ss_enable)
 	return status;
 }
 
-static int trdp_AUX_check_status(void)
+static unsigned int trdp_AUX_check_status(void)
 {
 	if (READ_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE) & 1)
 		return 0;
@@ -379,26 +379,142 @@ static int trdp_AUX_check_status(void)
 		return 1;
 }
 
+static unsigned int trdp_AUX_request(TRDP_AUXTrans_Req_t *req)
+{
+    unsigned int status = 0;
+    int i = 0;
+
+	status = trdp_AUX_check_status();
+	if (status) {
+		DPRINT("AUXRead error: edp transmitter disabled\n");
+		return status;
+	}
+
+    //check for transmitter ready state
+    do {
+        status = READ_DPTX_REG(EDP_TX_AUX_STATE);
+    }while(status & VAL_EDP_TX_AUX_STATE_REQUEST_IN_PROGRESS);
+
+    WRITE_DPTX_REG(EDP_TX_AUX_ADDRESS, req->address); //set address
+    //submit data only for write commands
+    if (req->cmd_state == VAL_AUX_CMD_STATE_WRITE) {
+        for (i=0; i<req->byte_count; i++)
+            WRITE_DPTX_REG(EDP_TX_AUX_WRITE_FIFO, req->wr_data[i]);
+    }
+    //submit the command and the data size
+    WRITE_DPTX_REG(EDP_TX_AUX_COMMAND, (req->cmd_code | ((req->byte_count - 1) & 0x0f)));
+
+    return status;
+}
+
+static unsigned int trdp_wait_reply(void)
+{
+    unsigned int status = 0;
+	unsigned int state_value = 0;
+	unsigned int done = 0;
+	int timeout_count = 0;
+	unsigned int failsafe_timeout = 100 * 1000 / VAL_EDP_TX_AUX_WAIT_TIME;
+	
+	while (!done) {
+		state_value = READ_DPTX_REG(EDP_TX_AUX_STATUS);
+		if (state_value & VAL_EDP_TX_AUX_STATUS_REPLY_RECEIVED) {
+			status = RET_EDP_TX_AUX_OPERATION_SUCCESS;
+			done = 1;
+		}
+		else if (state_value & VAL_EDP_TX_AUX_STATUS_REPLY_ERROR) {
+			status = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
+			done = 1;
+		}
+		else {
+			status = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
+			if (timeout_count++ == failsafe_timeout)
+				done = 1;
+			udelay(VAL_EDP_TX_AUX_WAIT_TIME);
+		}
+	}
+	
+	return status;
+}
+
+static unsigned int trdp_AUX_submit_cmd(TRDP_AUXTrans_Req_t *req)
+{
+	unsigned int status = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
+	unsigned int reply_code = 0;
+	unsigned int defer_count = 0;
+	unsigned int timeout_count = 0;
+
+	while((status == RET_EDP_TX_AUX_OPERATION_TIMEOUT) &&
+		(defer_count < VAL_EDP_TX_AUX_MAX_DEFER_COUNT) &&
+		(timeout_count < VAL_EDP_TX_AUX_MAX_TIMEOUT_COUNT))
+	{
+		trdp_AUX_request(req);
+		status = trdp_wait_reply();
+		if (status != RET_EDP_TX_AUX_OPERATION_TIMEOUT) {
+			reply_code = READ_DPTX_REG(EDP_TX_AUX_REPLY_CODE);
+			switch (reply_code) {
+				case VAL_EDP_TX_AUX_REPLY_CODE_ACK: //same as VAL_EDP_TX_AUX_REPLY_CODE_I2C_ACK
+					status = RET_EDP_TX_AUX_OPERATION_SUCCESS;
+					//DPRINT("edp AUX %s successful\n", ((req->cmd_state == VAL_AUX_CMD_STATE_WRITE) ? "write" : "read"));
+					break;
+				case VAL_EDP_TX_AUX_REPLY_CODE_I2C_DEFER:
+					status = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
+					udelay(VAL_EDP_TX_AUX_WAIT_TIME);
+					defer_count++;
+					DPRINT("edp AUX i2c %s defered\n", ((req->cmd_state == VAL_AUX_CMD_STATE_WRITE) ? "write" : "read"));
+					break;
+				case VAL_EDP_TX_AUX_REPLY_CODE_I2C_NACK:
+					status = RET_EDP_TX_AUX_OPERATION_FAILED;
+					DPRINT("edp AUX i2c %s NACK\n", ((req->cmd_state == VAL_AUX_CMD_STATE_WRITE) ? "write" : "read"));
+					break;
+				case VAL_EDP_TX_AUX_REPLY_CODE_DEFER:
+					status = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
+					udelay(VAL_EDP_TX_AUX_WAIT_TIME);
+					defer_count++;
+					DPRINT("edp AUX %s defered\n", ((req->cmd_state == VAL_AUX_CMD_STATE_WRITE) ? "write" : "read"));
+					break;
+				case VAL_EDP_TX_AUX_REPLY_CODE_NACK:
+					status = RET_EDP_TX_AUX_OPERATION_FAILED;
+					DPRINT("edp AUX %s NACK\n", ((req->cmd_state == VAL_AUX_CMD_STATE_WRITE) ? "write" : "read"));
+					break;
+				default: //unknown or illegal response code
+					status = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
+					udelay(VAL_EDP_TX_AUX_WAIT_TIME);
+					if (timeout_count++ > 2)
+						status = RET_EDP_TX_AUX_OPERATION_ERROR;
+					DPRINT("edp AUX %s error\n", ((req->cmd_state == VAL_AUX_CMD_STATE_WRITE) ? "write" : "read"));
+					break;
+			}
+		}
+		else { //timeout failsafe to avoid an infinite loop
+			timeout_count++;
+			udelay(VAL_EDP_TX_AUX_WAIT_TIME);
+			DPRINT("edp AUX %s timeout\n", ((req->cmd_state == VAL_AUX_CMD_STATE_WRITE) ? "write" : "read"));
+		}
+	}
+
+	return status;
+}
+
+#if 0
 #define EDP_AUX_OPERATION_RETRY
 // Read EDPTX
 // Read N-bytes from Aux-Channel -- upto 16bytes
-#ifdef EDP_AUX_OPERATION_RETRY
 //retry
-static int trdp_AUXRead(unsigned long address, unsigned long byte_count, unsigned char *data)
+static unsigned int trdp_AUXRead(unsigned long address, unsigned long byte_count, unsigned char *data)
 {
     int i;
-	unsigned status;
-	int reply_state = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
+	unsigned int status;
+	int reply_state = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
 	unsigned defer_count = 0;
 	unsigned timeout_count = 0;
 	
 	status = trdp_AUX_check_status();
 	if (status) {
 		DPRINT("AUXRead error: edp transmitter disabled\n");
-		return (int)status;
+		return status;
 	}
 	
-	while ((reply_state == VAL_EDP_TX_AUX_OPERATION_TIMEOUT) && (defer_count < VAL_EDP_TX_AUX_MAX_DEFER_COUNT) && (timeout_count < VAL_EDP_TX_AUX_MAX_TIMEOUT_COUNT)) {
+	while ((reply_state == RET_EDP_TX_AUX_OPERATION_TIMEOUT) && (defer_count < VAL_EDP_TX_AUX_MAX_DEFER_COUNT) && (timeout_count < VAL_EDP_TX_AUX_MAX_TIMEOUT_COUNT)) {
 		//check for transmitter ready state
 		do {
 			status = READ_DPTX_REG(EDP_TX_AUX_STATE);
@@ -409,36 +525,36 @@ static int trdp_AUXRead(unsigned long address, unsigned long byte_count, unsigne
 		WRITE_DPTX_REG(EDP_TX_AUX_COMMAND, (VAL_EDP_TX_AUX_CMD_READ | ((byte_count-1) & 0xF)));
 		
 		//wait reply
-		reply_state = VAL_EDP_TX_AUX_OPERATION_SUCCESS;
+		reply_state = RET_EDP_TX_AUX_OPERATION_SUCCESS;
 		do {
 			status = READ_DPTX_REG(EDP_TX_AUX_STATE);
 			if (status & VAL_EDP_TX_AUX_STATE_TIMEOUT) {
-				reply_state = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
+				reply_state = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
 				timeout_count++;
 				udelay(VAL_EDP_TX_AUX_WAIT_TIME);
 				break;
 			}
 		}while((status & VAL_EDP_TX_AUX_STATE_RECEIVED) == 0);
 		
-		if (reply_state != VAL_EDP_TX_AUX_OPERATION_TIMEOUT) {
+		if (reply_state != RET_EDP_TX_AUX_OPERATION_TIMEOUT) {
 			status = READ_DPTX_REG(EDP_TX_AUX_REPLY_CODE);
 			switch (status) {
 				case VAL_EDP_TX_AUX_REPLY_CODE_ACK:
-					reply_state = VAL_EDP_TX_AUX_OPERATION_SUCCESS;
+					reply_state = RET_EDP_TX_AUX_OPERATION_SUCCESS;
 					break;
 				case VAL_EDP_TX_AUX_REPLY_CODE_NACK:
-					reply_state = VAL_EDP_TX_AUX_OPERATION_FAILED;
+					reply_state = RET_EDP_TX_AUX_OPERATION_FAILED;
 					break;
 				case VAL_EDP_TX_AUX_REPLY_CODE_DEFER:
-					reply_state = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
+					reply_state = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
 					udelay(VAL_EDP_TX_AUX_WAIT_TIME);
 					defer_count++;
 					break;
 				default:
-					reply_state = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
+					reply_state = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
 					udelay(VAL_EDP_TX_AUX_WAIT_TIME);
 					if (timeout_count++ > 2)
-						reply_state = VAL_EDP_TX_AUX_OPERATION_ERROR;
+						reply_state = RET_EDP_TX_AUX_OPERATION_ERROR;
 					break;
 			}
 		}
@@ -447,7 +563,7 @@ static int trdp_AUXRead(unsigned long address, unsigned long byte_count, unsigne
 		}
 	}
 	
-	if (reply_state == VAL_EDP_TX_AUX_OPERATION_SUCCESS) {
+	if (reply_state == RET_EDP_TX_AUX_OPERATION_SUCCESS) {
 		for(i=0; i<byte_count; i++ )
 			data[i] = READ_DPTX_REG(EDP_TX_AUX_REPLY_DATA);
 	}
@@ -457,83 +573,24 @@ static int trdp_AUXRead(unsigned long address, unsigned long byte_count, unsigne
 	
     return reply_state;
 }
-#else
-//no retry
-static int trdp_AUXRead(unsigned long address, unsigned long byte_count, unsigned long *data)
-{
-    int i;
-    unsigned status;
-	
-	status = trdp_AUX_check_status();
-	if (status) {
-		DPRINT("AUXRead error: edp transmitter disabled\n");
-		return (int)status;
-	}
-	
-    //check for transmitter ready state
-	do {
-		status = READ_DPTX_REG(EDP_TX_AUX_STATE);
-	}while(status & VAL_EDP_TX_AUX_STATE_REQUEST_IN_PROGRESS);
-	
-	WRITE_DPTX_REG(EDP_TX_AUX_ADDRESS, address);
-    WRITE_DPTX_REG(EDP_TX_AUX_COMMAND, (VAL_EDP_TX_AUX_CMD_READ | ((byte_count-1) & 0xF)));
-
-    //wait reply
-	do {
-		status = READ_DPTX_REG(EDP_TX_AUX_STATE);
-		if (status & VAL_EDP_TX_AUX_STATE_TIMEOUT) {
-			DPRINT("AUXRead timeout\n");
-			return VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
-		}
-		udelay(VAL_EDP_TX_AUX_WAIT_TIME);
-	}while((status & VAL_EDP_TX_AUX_STATE_RECEIVED) == 0);
-	
-	status = READ_DPTX_REG(EDP_TX_AUX_REPLY_CODE);
-	switch (status) {
-		case VAL_EDP_TX_AUX_REPLY_CODE_ACK:
-			status = VAL_EDP_TX_AUX_OPERATION_SUCCESS;
-			break;
-		case VAL_EDP_TX_AUX_REPLY_CODE_NACK:
-			DPRINT("AUXRead failed\n");
-			status = VAL_EDP_TX_AUX_OPERATION_FAILED;
-			break;
-		case VAL_EDP_TX_AUX_REPLY_CODE_DEFER:
-			DPRINT("AUXRead defered\n");
-			status = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
-			break;
-		default:
-			DPRINT("AUXRead error\n");
-			status = VAL_EDP_TX_AUX_OPERATION_ERROR;
-			break;
-	}
-	
-	if (status == VAL_EDP_TX_AUX_OPERATION_SUCCESS) {
-        for(i=0; i<byte_count; i++ )
-            data[i] = READ_DPTX_REG(EDP_TX_AUX_REPLY_DATA);
-    }
-	
-    return (int)status; 
-}
-#endif
 
 // Write N-bytes to Aux-Channel -- upto 16bytes
-#ifdef EDP_AUX_OPERATION_RETRY
 //retry
-static int trdp_AUXWrite(unsigned long address, unsigned long byte_count, unsigned char *data)
+static unsigned int trdp_AUXWrite(unsigned long address, unsigned long byte_count, unsigned char *data)
 {
     int i;
-	unsigned status;
-	int reply_state = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
+	unsigned int status;
+	unsigned int reply_state = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
 	unsigned defer_count = 0;
 	unsigned timeout_count = 0;
 	
 	status = trdp_AUX_check_status();
 	if (status) {
 		DPRINT("AUXWrite error: edp transmitter disabled\n");
-		return (int)status;
+		return status;
 	}
 	
-	while ((reply_state == VAL_EDP_TX_AUX_OPERATION_TIMEOUT) && (defer_count < VAL_EDP_TX_AUX_MAX_DEFER_COUNT) && (timeout_count < VAL_EDP_TX_AUX_MAX_TIMEOUT_COUNT)) {
+	while ((reply_state == RET_EDP_TX_AUX_OPERATION_TIMEOUT) && (defer_count < VAL_EDP_TX_AUX_MAX_DEFER_COUNT) && (timeout_count < VAL_EDP_TX_AUX_MAX_TIMEOUT_COUNT)) {
 		//check for transmitter ready state
 		do {
 			status = READ_DPTX_REG(EDP_TX_AUX_STATE);
@@ -547,36 +604,36 @@ static int trdp_AUXWrite(unsigned long address, unsigned long byte_count, unsign
 		WRITE_DPTX_REG(EDP_TX_AUX_COMMAND, (VAL_EDP_TX_AUX_CMD_WRITE | ((byte_count-1) & 0xF)));
 		
 		//wait reply
-		reply_state = VAL_EDP_TX_AUX_OPERATION_SUCCESS;
+		reply_state = RET_EDP_TX_AUX_OPERATION_SUCCESS;
 		do {
 			status = READ_DPTX_REG(EDP_TX_AUX_STATE);
 			if (status & VAL_EDP_TX_AUX_STATE_TIMEOUT) {
-				reply_state = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
+				reply_state = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
 				timeout_count++;
 				udelay(VAL_EDP_TX_AUX_WAIT_TIME);
 				break;
 			}
 		}while((status & VAL_EDP_TX_AUX_STATE_RECEIVED) == 0);
 		
-		if (reply_state != VAL_EDP_TX_AUX_OPERATION_TIMEOUT) {
+		if (reply_state != RET_EDP_TX_AUX_OPERATION_TIMEOUT) {
 			status = READ_DPTX_REG(EDP_TX_AUX_REPLY_CODE);
 			switch (status) {
 				case VAL_EDP_TX_AUX_REPLY_CODE_ACK:
-					reply_state = VAL_EDP_TX_AUX_OPERATION_SUCCESS;
+					reply_state = RET_EDP_TX_AUX_OPERATION_SUCCESS;
 					break;
 				case VAL_EDP_TX_AUX_REPLY_CODE_NACK:
-					reply_state = VAL_EDP_TX_AUX_OPERATION_FAILED;
+					reply_state = RET_EDP_TX_AUX_OPERATION_FAILED;
 					break;
 				case VAL_EDP_TX_AUX_REPLY_CODE_DEFER:
-					reply_state = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
+					reply_state = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
 					udelay(VAL_EDP_TX_AUX_WAIT_TIME);
 					defer_count++;
 					break;
 				default:
-					reply_state = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
+					reply_state = RET_EDP_TX_AUX_OPERATION_TIMEOUT;
 					udelay(VAL_EDP_TX_AUX_WAIT_TIME);
 					if (timeout_count++ > 2)
-						reply_state = VAL_EDP_TX_AUX_OPERATION_ERROR;
+						reply_state = RET_EDP_TX_AUX_OPERATION_ERROR;
 					break;
 			}
 		}
@@ -587,72 +644,384 @@ static int trdp_AUXWrite(unsigned long address, unsigned long byte_count, unsign
 	
     return reply_state;
 }
+
 #else
-//no retry
-static int trdp_AUXWrite(unsigned long address, unsigned long byte_count, unsigned char *data)
+static unsigned int trdp_AUXRead(unsigned long address, unsigned long byte_count, unsigned char *data)
 {
-    int i;
-	unsigned status;
+	int i;
+	unsigned int status;
+	TRDP_AUXTrans_Req_t request;
+	
+	status = trdp_AUX_check_status();
+	if (status) {
+		DPRINT("AUXRead error: edp transmitter disabled\n");
+		return status;
+	}
+	
+	request.cmd_code = VAL_EDP_TX_AUX_CMD_READ;
+	request.cmd_state = VAL_AUX_CMD_STATE_READ;
+	request.address = address;
+	request.byte_count = byte_count;
+	status = trdp_AUX_submit_cmd(&request);
+	if (status == RET_EDP_TX_AUX_OPERATION_SUCCESS) {
+		for(i=0; i<byte_count; i++ )
+			data[i] = READ_DPTX_REG(EDP_TX_AUX_REPLY_DATA);
+	}
+	else {
+		DPRINT("AUXRead failed\n");
+		return RET_EDP_TX_AUX_OPERATION_FAILED;
+	}
+	
+	return status;
+}
 
+static unsigned int trdp_AUXWrite(unsigned long address, unsigned long byte_count, unsigned char *data)
+{
+	unsigned int status;
+	TRDP_AUXTrans_Req_t request;
+	
 	status = trdp_AUX_check_status();
 	if (status) {
-		DPRINT("AUXWrite error: edp transmitter disabled\n");
-		return (int)status;
+		DPRINT("AUXRead error: edp transmitter disabled\n");
+		return status;
+	}
+	
+	request.cmd_code = VAL_EDP_TX_AUX_CMD_WRITE;
+	request.cmd_state = VAL_AUX_CMD_STATE_WRITE;
+	request.address = address;
+	request.byte_count = byte_count;
+	request.wr_data = data;
+	status = trdp_AUX_submit_cmd(&request);
+	if (status) {
+		DPRINT("AUXWrite failed\n");
+		return RET_EDP_TX_AUX_OPERATION_FAILED;
 	}
 	
-	//check for transmitter ready state
-	do {
-		status = READ_DPTX_REG(EDP_TX_AUX_STATE);
-	}while(status & VAL_EDP_TX_AUX_STATE_REQUEST_IN_PROGRESS);
+	return status;
+}
+#endif
+static unsigned int trdp_AUX_I2C_Read(unsigned int dev_addr, unsigned int reg_addr, unsigned int byte_count, unsigned char *data_buffer)
+{
+	unsigned int status = 0;
+	unsigned int data_count = 0, data_index = 0;
+	int i;
+	unsigned char aux_data[4];
+	unsigned char done = 0;
+	unsigned int reply_data_count = 0;
+	TRDP_AUXTrans_Req_t request;
+
+	status = trdp_AUX_check_status();
+	if (status) {
+		DPRINT("AUXRead error: edp transmitter disabled\n");
+		return status;
+	}
 	
-	//write AUX command
-	WRITE_DPTX_REG(EDP_TX_AUX_ADDRESS, address);
-	for(i=0; i<byte_count; i++ )
-		 WRITE_DPTX_REG(EDP_TX_AUX_WRITE_FIFO, data[i] );
+	byte_count = (byte_count > 16) ? 16 : byte_count; //cap the byte count
 
-	WRITE_DPTX_REG(EDP_TX_AUX_COMMAND, (VAL_EDP_TX_AUX_CMD_WRITE | ((byte_count-1) & 0xF)));
+	aux_data[0] = reg_addr;
+	aux_data[1] = 0x00;
+	
+	//setup command
+	request.cmd_code = VAL_EDP_TX_AUX_CMD_I2C_WRITE_MOT;
+	request.cmd_state = VAL_AUX_CMD_STATE_WRITE;
+	request.address = dev_addr;
+	request.byte_count = 1;
+	request.wr_data = aux_data;
 	
-	//wait reply
-	do {
-		status = READ_DPTX_REG(EDP_TX_AUX_STATE);
-		if (status & VAL_EDP_TX_AUX_STATE_TIMEOUT) {
-			DPRINT("AUXWrite timeout\n");
-			return VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
+	//send the address write
+	status = trdp_AUX_submit_cmd(&request);
+	if (status != RET_EDP_TX_AUX_OPERATION_SUCCESS) {
+		DPRINT("Error: I2C writing device address (0x%04x) failed (0x%02x)\n", dev_addr, status);
+		return RET_EDP_TX_OPERATION_FAILED;
+	}
+	//submit the read command to hardware
+	request.cmd_code = VAL_EDP_TX_AUX_CMD_I2C_READ;
+	request.cmd_state = VAL_AUX_CMD_STATE_READ;
+	request.address = dev_addr;
+	request.byte_count = byte_count;
+	
+	data_count = 0;
+	data_index = 0;
+	while ((data_count < byte_count) && (!done)) {
+		status = trdp_AUX_submit_cmd(&request);
+		if (status == RET_EDP_TX_AUX_OPERATION_SUCCESS) {
+			reply_data_count = READ_DPTX_REG(EDP_TX_AUX_REPLY_DATA_COUNT);
+			for (i=0; i<reply_data_count; i++) {
+				data_buffer[data_index] = READ_DPTX_REG(EDP_TX_AUX_REPLY_DATA);
+				data_index++;
+				data_count++;
+			}
+			done = 1;
+		}
+		else {
+			DPRINT("Error: I2C read device address (0x%04x) failed (0x%02x)\n", dev_addr, status);
+			return RET_EDP_TX_OPERATION_FAILED;
 		}
-		udelay(VAL_EDP_TX_AUX_WAIT_TIME);
-	}while((status & VAL_EDP_TX_AUX_STATE_RECEIVED) == 0);
+		request.byte_count -= reply_data_count;
+		aux_data[0] += reply_data_count; //increment the address for the next transaction
+	}
+
+	return status;
+}
+#if 0
+static unsigned int trdp_AUX_I2C_Write(unsigned int dev_addr, unsigned int reg_addr, unsigned int byte_count, unsigned char *data_buffer)
+{
+	unsigned int status = 0;
+	unsigned char aux_data[4];
+	TRDP_AUXTrans_Req_t request;
 	
-	status = READ_DPTX_REG(EDP_TX_AUX_REPLY_CODE);
-	switch (status) {
-		case VAL_EDP_TX_AUX_REPLY_CODE_ACK:
-			status = VAL_EDP_TX_AUX_OPERATION_SUCCESS;
-			break;
-		case VAL_EDP_TX_AUX_REPLY_CODE_NACK:
-			DPRINT("AUXWrite failed\n");
-			status = VAL_EDP_TX_AUX_OPERATION_FAILED;
-			break;
-		case VAL_EDP_TX_AUX_REPLY_CODE_DEFER:
-			DPRINT("AUXWrite defered\n");
-			status = VAL_EDP_TX_AUX_OPERATION_TIMEOUT;
-			break;
-		default:
-			DPRINT("AUXWrite error\n");
-			status = VAL_EDP_TX_AUX_OPERATION_ERROR;
-			break;
+	status = trdp_AUX_check_status();
+	if (status) {
+		DPRINT("AUXRead error: edp transmitter disabled\n");
+		return status;
 	}
 	
-    return (int)status;
+	byte_count = (byte_count > 16) ? 16 : byte_count;
+	
+	aux_data[0] = reg_addr;
+	aux_data[1] = 0;
+	
+	//setup command
+	request.cmd_code = VAL_EDP_TX_AUX_CMD_I2C_WRITE_MOT;
+	request.cmd_state = VAL_AUX_CMD_STATE_WRITE;
+	request.byte_count = 1;
+	request.wr_data = aux_data;
+	
+	//send the address write
+	status = trdp_AUX_submit_cmd(&request);
+	if (status != VAL_EDP_TX_AUX_REPLY_CODE_I2C_ACK) {
+		DPRINT("Error: I2C writing device address (0x%04x) failed (0x%02x)\n", dev_addr, status);
+		return RET_EDP_TX_OPERATION_FAILED;
+	}
+	
+	//submit the write command to hardware
+	request.cmd_code = VAL_EDP_TX_AUX_CMD_I2C_WRITE;
+	request.cmd_state = VAL_AUX_CMD_STATE_WRITE;
+	request.address = dev_addr;
+	request.byte_count = byte_count;
+	request.wr_data = data_buffer;
+	
+	status = trdp_AUX_submit_cmd(&request);
+	if (status != VAL_EDP_TX_AUX_REPLY_CODE_I2C_ACK) {
+		DPRINT("Error: I2C writing device address (0x%04x) failed (0x%02x)\n", dev_addr, status);
+		status = RET_EDP_TX_OPERATION_FAILED;
+	}
+	
+	return status;
 }
 #endif
 
-static int trdp_get_sink_caps(TRDP_DPCDData_t *dpcd_data)
+static void EDID_parase_print(EDP_EDID_Data_Type_t *edid_data_parase)
+{
+	DPRINT( "Manufacturer ID:       %s\n"
+			"Product ID:            0x%04x\n"
+			"Product SN:            0x%08x\n"
+			"Week:                  %d\n"
+			"Year:                  %d\n"
+			"EDID Version:          %04x\n",
+			&edid_data_parase->mid[0], edid_data_parase->pid, edid_data_parase->psn,
+			edid_data_parase->week, edid_data_parase->year, edid_data_parase->version
+			);
+	if ((edid_data_parase->string_flag >> 0) & 1) { //monitor name
+	DPRINT( "Monitor Name:          %s\n", &edid_data_parase->name[0]);
+	}
+	if ((edid_data_parase->string_flag >> 1) & 1) { //monitor ascii string
+	DPRINT( "Monitor AScii String:  %s\n", &edid_data_parase->asc_string[0]);
+	}
+	if ((edid_data_parase->string_flag >> 2) & 1) { //monitor serial num
+	DPRINT( "Monitor SN:            %s\n", &edid_data_parase->serial_num[0]);
+	}
+	DPRINT( "Detail Timing:\n"
+			"    Pixel Clock:   %d.%dMHz\n"
+			"    H Active:      %d\n"
+			"    H Blank:       %d\n"
+			"    V Active:      %d\n"
+			"    V Blank:       %d\n"
+			"    H FP:          %d\n"
+			"    H PW:          %d\n"
+			"    V FP:          %d\n"
+			"    V PW:          %d\n"
+			"    H Size:        %dmm\n"
+			"    V Size:        %dmm\n"
+			"    H Border:      %d\n"
+			"    V Border:      %d\n"
+			"    Hsync Pol:     %d\n"
+			"    Vsync Pol:     %d\n",
+			(edid_data_parase->preferred_timing.pclk / 1000000), ((edid_data_parase->preferred_timing.pclk % 1000000) / 1000),
+			edid_data_parase->preferred_timing.h_active, edid_data_parase->preferred_timing.h_blank,
+			edid_data_parase->preferred_timing.v_active, edid_data_parase->preferred_timing.v_blank,
+			edid_data_parase->preferred_timing.h_fp, edid_data_parase->preferred_timing.h_pw,
+			edid_data_parase->preferred_timing.v_fp, edid_data_parase->preferred_timing.v_pw,
+			edid_data_parase->preferred_timing.h_size, edid_data_parase->preferred_timing.v_size,
+			edid_data_parase->preferred_timing.h_border, edid_data_parase->preferred_timing.v_border,
+			((edid_data_parase->preferred_timing.timing_ctrl >> 1) & 1), ((edid_data_parase->preferred_timing.timing_ctrl >> 2) & 1));
+}
+
+static unsigned int EDID_parase(unsigned char *edid_data, EDP_EDID_Data_Type_t *edid_data_parase)
+{
+	int i,j,k;
+	unsigned int status = 0;
+	unsigned int checksum;
+	unsigned int temp;
+	unsigned char edid_header[8] = {0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00};
+	
+	for (i=0; i<8; i++) {
+		if (edid_data[i] != edid_header[i]) {
+			status = RET_EDP_TX_OPERATION_FAILED;
+			DPRINT("Invalid EDID data\n");
+			return status;
+		}
+	}
+	
+	temp = ((((unsigned short)edid_data[8]) << 8) | ((unsigned short)edid_data[9]));
+	for (i=0; i<3; i++) {
+		edid_data_parase->mid[i] = (((temp >> ((2-i)*5)) & 0x1f) - 1) + 'A';
+	}
+	edid_data_parase->mid[3] = '\0';
+	edid_data_parase->pid = ((((unsigned short)edid_data[11]) << 8) | ((unsigned short)edid_data[10]));
+	edid_data_parase->psn = ((((unsigned int)edid_data[12]) << 24) | (((unsigned int)edid_data[13]) << 16) | (((unsigned int)edid_data[14]) << 8) | ((unsigned int)edid_data[15]));
+	edid_data_parase->week = edid_data[16];
+	edid_data_parase->year = 1990 + edid_data[17];
+	edid_data_parase->version = ((((unsigned short)edid_data[18]) << 8) | ((unsigned short)edid_data[19]));
+	
+	edid_data_parase->string_flag = 0;
+	for (i=0; i<4; i++) {
+		j = 54 + i * 18;
+		if ((edid_data[j] + edid_data[j+1]) == 0) {
+			if ((edid_data[j+2] + edid_data[j+4]) == 0) {
+				switch (edid_data[j+3]) {
+					case 0xfc: //monitor name
+						for (k=0; k<13; k++) {
+							edid_data_parase->name[k] = edid_data[j+5+k];
+						}
+						edid_data_parase->name[13] = '\0';
+						edid_data_parase->string_flag |= (1 << 0);
+						break;
+					case 0xfd: //monitor range limits
+						edid_data_parase->range_limit.min_vfreq = (unsigned int)edid_data[j+5];
+						edid_data_parase->range_limit.max_v_freq = (unsigned int)edid_data[j+6];
+						edid_data_parase->range_limit.min_hfreq = (unsigned int)edid_data[j+7];
+						edid_data_parase->range_limit.max_hfreq = (unsigned int)edid_data[j+8];
+						edid_data_parase->range_limit.max_pclk = (unsigned int)edid_data[j+9];
+						edid_data_parase->range_limit.GTF_ctrl = ((((unsigned int)edid_data[j+11]) << 8) | ((unsigned int)edid_data[j+10]));
+						edid_data_parase->range_limit.GTF_start_hfreq = (unsigned int)edid_data[j+12] * 2000;
+						edid_data_parase->range_limit.GTF_C = (unsigned int)edid_data[j+13] / 2;
+						edid_data_parase->range_limit.GTF_M = ((((unsigned int)edid_data[j+15]) << 8) | ((unsigned int)edid_data[j+14]));
+						edid_data_parase->range_limit.GTF_K = (unsigned int)edid_data[j+16];
+						edid_data_parase->range_limit.GTF_J = (unsigned int)edid_data[j+17] / 2;
+						break;
+					case 0xfe: //ascii string
+						for (k=0; k<13; k++) {
+							edid_data_parase->asc_string[k] = edid_data[j+5+k];
+						}
+						edid_data_parase->asc_string[13] = '\0';
+						edid_data_parase->string_flag |= (1 << 1);
+						break;
+					case 0xff: //monitor serial num
+						for (k=0; k<13; k++) {
+							edid_data_parase->serial_num[k] = edid_data[j+5+k];
+						}
+						edid_data_parase->serial_num[13] = '\0';
+						edid_data_parase->string_flag |= (1 << 2);
+						break;
+					default:
+						break;
+				}
+			}
+		}
+		else {//detail timing
+			edid_data_parase->preferred_timing.pclk = ((((unsigned int)edid_data[j+1]) << 8) | ((unsigned int)edid_data[j])) * 10000;
+			edid_data_parase->preferred_timing.h_active = ((((((unsigned short)edid_data[j+4]) >> 4) & 0xf) << 8) | ((unsigned short)edid_data[j+2]));
+			edid_data_parase->preferred_timing.h_blank = ((((((unsigned short)edid_data[j+4]) >> 0) & 0xf) << 8) | ((unsigned short)edid_data[j+3]));
+			edid_data_parase->preferred_timing.v_active = ((((((unsigned short)edid_data[j+7]) >> 4) & 0xf) << 8) | ((unsigned short)edid_data[j+5]));
+			edid_data_parase->preferred_timing.v_blank = ((((((unsigned short)edid_data[j+7]) >> 0) & 0xf) << 8) | ((unsigned short)edid_data[j+6]));
+			edid_data_parase->preferred_timing.h_fp = ((((((unsigned short)edid_data[j+11]) >> 6) & 0x3) << 8) | ((unsigned short)edid_data[j+8]));
+			edid_data_parase->preferred_timing.h_pw = ((((((unsigned short)edid_data[j+11]) >> 4) & 0x3) << 8) | ((unsigned short)edid_data[j+9]));
+			edid_data_parase->preferred_timing.v_fp = ((((((unsigned short)edid_data[j+11]) >> 2) & 0x3) << 4) | ((((unsigned short)edid_data[j+10]) >> 4) & 0xf));
+			edid_data_parase->preferred_timing.v_pw = ((((((unsigned short)edid_data[j+11]) >> 0) & 0x3) << 4) | ((((unsigned short)edid_data[j+10]) >> 0) & 0xf));
+			edid_data_parase->preferred_timing.h_size = ((((((unsigned int)edid_data[j+14]) >> 4) & 0xf) << 8) | ((unsigned int)edid_data[j+12]));
+			edid_data_parase->preferred_timing.v_size = ((((((unsigned int)edid_data[j+14]) >> 0) & 0xf) << 8) | ((unsigned int)edid_data[j+13]));
+			edid_data_parase->preferred_timing.h_border = (unsigned short)edid_data[j+15];
+			edid_data_parase->preferred_timing.v_border = (unsigned short)edid_data[j+16];
+			edid_data_parase->preferred_timing.timing_ctrl = (unsigned int)edid_data[j+17];
+		}
+	}
+	
+	edid_data_parase->ext_flag = edid_data[126];
+	edid_data_parase->checksum = edid_data[127];
+	checksum = 0;
+	for (i=0; i<128; i++) {
+		checksum += edid_data[i];
+	}
+	if ((checksum & 0xff) == 0) {
+		//status = RET_EDP_TX_OPERATION_SUCCESS;
+		DPRINT("EDID checksum: Right\n");
+	}
+	else {
+		//status = RET_EDP_TX_OPERATION_FAILED;
+		DPRINT("EDID checksum: Wrong\n");
+	}
+	
+	return status;
+}
+
+static unsigned int trdp_read_EDID(unsigned char *edid_data)
+{
+	unsigned int status = 0;
+	int i;
+	
+	if (edid_data == NULL) {
+		DPRINT("Invalid pointer for EDID data\n");
+		return RET_EDP_TX_OPERATION_FAILED;
+	}
+	
+	for (i=0; i<128; i+= 16) {
+		status = trdp_AUX_I2C_Read(0x50, i, 16, &edid_data[i]);
+		if (status)
+			break;
+	}
+	
+	return status;
+}
+
+static unsigned int trdp_dump_EDID(void)
 {
-	int status = 0, xx = 0;
+	unsigned char edid_data[128];
+	unsigned int status = 0;
+	EDP_EDID_Data_Type_t edid_data_parase;
+	int i = 0;
+	
+	status = trdp_read_EDID(&edid_data[0]);
+	if (status) {
+		DPRINT("Failed to get EDID from sink device\n");
+	}
+	else {
+		DPRINT("********************************************\n");
+		DPRINT("dump EDID Raw data:");
+		for (i=0; i<128; i++) {
+			if (i % 16 == 0)
+				DPRINT("\n");
+			DPRINT("0x%02x ", edid_data[i]);
+		}
+		DPRINT("\n");
+		
+		status = EDID_parase(&edid_data[0], &edid_data_parase);
+		if (status == RET_EDP_TX_OPERATION_SUCCESS)
+			EDID_parase_print(&edid_data_parase);
+		DPRINT("********************************************\n");
+	}
+	
+	return status;
+}
+
+static unsigned int trdp_get_sink_caps(TRDP_DPCDData_t *dpcd_data)
+{
+	unsigned int status = 0, xx = 0;
 	unsigned char aux_data[16];
 
     if (dpcd_data == NULL) {
 		DPRINT("Invalid pointer for DPCD data\n");
-		return VAL_EDP_TX_AUX_OPERATION_FAILED;
+		return RET_EDP_TX_AUX_OPERATION_FAILED;
 	}
 
     status = trdp_AUXRead(EDP_DPCD_REVISION, 12, aux_data);
@@ -757,18 +1126,18 @@ static int trdp_get_sink_caps(TRDP_DPCDData_t *dpcd_data)
     else // No downstream ports
         dpcd_data->port_type_string = "None";
 
-    return VAL_EDP_TX_AUX_OPERATION_SUCCESS;
+    return RET_EDP_TX_AUX_OPERATION_SUCCESS;
 }
 
-static int trdp_dump_DPCD(void)
+static unsigned int trdp_dump_DPCD(void)
 {
-	int status = 0;
+	unsigned int status = 0;
 	int i;
 	TRDP_DPCDData_t dpcdinfo;
 	
 	DPRINT("********************************************\n");
 	status = trdp_get_sink_caps(&dpcdinfo);
-	if (status != VAL_EDP_TX_AUX_OPERATION_SUCCESS) {
+	if (status != RET_EDP_TX_AUX_OPERATION_SUCCESS) {
 		DPRINT("Failed to get DPCD from sink device\n");
 		return status;
 	}
@@ -814,17 +1183,17 @@ static int trdp_dump_DPCD(void)
     }
 	DPRINT("********************************************\n");
 	
-	return VAL_EDP_TX_AUX_OPERATION_SUCCESS;
+	return RET_EDP_TX_AUX_OPERATION_SUCCESS;
 }
 
-static int trdp_dump_DPCD_training_status(void)
+static unsigned int trdp_dump_DPCD_training_status(void)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned char aux_data[8];
 	
 	DPRINT("********************************************\n");
 	status = trdp_AUXRead(EDP_DPCD_SINK_COUNT, 8, aux_data);
-	if (status != VAL_EDP_TX_AUX_OPERATION_SUCCESS) {
+	if (status != RET_EDP_TX_AUX_OPERATION_SUCCESS) {
 		DPRINT("Failed to get DPCD status from sink device\n");
 		return status;
 	}
@@ -843,7 +1212,7 @@ static int trdp_dump_DPCD_training_status(void)
 			aux_data[7]);
 	
 	status = trdp_AUXRead(EDP_DPCD_LINK_BANDWIDTH_SET, 8, aux_data);
-	if (status != VAL_EDP_TX_AUX_OPERATION_SUCCESS) {
+	if (status != RET_EDP_TX_AUX_OPERATION_SUCCESS) {
 		DPRINT("Failed to get DPCD settings from sink device\n");
 		return status;
 	}
@@ -866,7 +1235,7 @@ static int trdp_dump_DPCD_training_status(void)
 			aux_data[7]);
 	DPRINT("********************************************\n");
 	
-	return VAL_EDP_TX_AUX_OPERATION_SUCCESS;
+	return RET_EDP_TX_AUX_OPERATION_SUCCESS;
 }
 
 static void trdp_edp_link_rate_update(unsigned char link_rate)
@@ -883,9 +1252,9 @@ static void trdp_edp_link_rate_update(unsigned char link_rate)
 	}
 }
 #if 0
-static int trdp_set_link_rate(unsigned char link_rate)
+static unsigned int trdp_set_link_rate(unsigned char link_rate)
 {
-	int status = VAL_EDP_TX_AUX_OPERATION_SUCCESS;
+	unsigned int status = RET_EDP_TX_AUX_OPERATION_SUCCESS;
 	
 	lcd_print("set link rate\n");
 	if (link_rate != READ_DPTX_REG(EDP_TX_LINK_BW_SET)) {
@@ -899,7 +1268,7 @@ static int trdp_set_link_rate(unsigned char link_rate)
 				status = trdp_AUXWrite(EDP_DPCD_LINK_BANDWIDTH_SET, 1, &link_rate);
 				break;
 			default:
-				status = VAL_EDP_TX_AUX_INVALID_PARAMETER;
+				status = RET_EDP_TX_AUX_INVALID_PARAMETER;
 				break;
 		}
 	}
@@ -907,9 +1276,9 @@ static int trdp_set_link_rate(unsigned char link_rate)
 	return status;
 }
 
-static int trdp_set_lane_count(unsigned char lane_count)
+static unsigned int trdp_set_lane_count(unsigned char lane_count)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned enhance_framing_mode;
 	
 	lcd_print("set lane count\n");
@@ -924,16 +1293,16 @@ static int trdp_set_lane_count(unsigned char lane_count)
 			status = trdp_AUXWrite(EDP_DPCD_LANE_COUNT_SET, 1, &lane_count);
 			break;
 		default:
-			status = VAL_EDP_TX_AUX_INVALID_PARAMETER;
+			status = RET_EDP_TX_AUX_INVALID_PARAMETER;
 			break;
 	}
 	
 	return status;
 }
 #endif
-static int trdp_set_downspread(unsigned char ss_enable)
+static unsigned int trdp_set_downspread(unsigned char ss_enable)
 {
-	int status = 0;
+	unsigned int status = 0;
 	
 	//lcd_print("set spread spectrum\n");
 	ss_enable = (ss_enable > 0) ? 1 : 0;
@@ -945,9 +1314,9 @@ static int trdp_set_downspread(unsigned char ss_enable)
 	return status;
 }
 
-static int trdp_verify_training_config(void)
+static unsigned int trdp_verify_training_config(void)
 {
-	int status = VAL_EDP_CONFIG_VALID;
+	unsigned int status = RET_EDP_CONFIG_VALID;
 	unsigned link_rate = 0, lane_count = 0;
 	
 	link_rate = READ_DPTX_REG(EDP_TX_LINK_BW_SET);
@@ -959,7 +1328,7 @@ static int trdp_verify_training_config(void)
 		case VAL_EDP_TX_LINK_BW_SET_540:
 			break;
 		default:
-			status = VAL_EDP_CONFIG_INVALID_LINK_RATE;
+			status = RET_EDP_CONFIG_INVALID_LINK_RATE;
 			break;
 	}
 	
@@ -969,7 +1338,7 @@ static int trdp_verify_training_config(void)
 		case 4:
 			break;
 		default:
-			status = VAL_EDP_CONFIG_INVALID_LANE_COUNT;
+			status = RET_EDP_CONFIG_INVALID_LANE_COUNT;
 			break;
 	}
 	
@@ -1063,9 +1432,9 @@ static void trdp_preset_preemphasis(unsigned preemp)
 	preset_preemp_rx = trdp_DPCD_preemphasis_for_value(preset_preemp_tx, preset_vswing_tx);
 }
 
-static int trdp_select_training_settings(unsigned training_settings)
+static unsigned int trdp_select_training_settings(unsigned training_settings)
 {
-	int status = 0;
+	unsigned int status = 0;
 	
 	switch (training_settings) {
 		case 0:	//vswing 0, preemphasis 0
@@ -1109,16 +1478,16 @@ static int trdp_select_training_settings(unsigned training_settings)
 			trdp_preset_preemphasis(VAL_EDP_TX_PHY_PREEMPHASIS_0);
 			break;
 		default:
-			status = VAL_EDP_TX_AUX_INVALID_PARAMETER;
+			status = RET_EDP_TX_AUX_INVALID_PARAMETER;
 			break;
 	}
 
 	return status;
 }
 
-static int trdp_set_training_values(void)
+static unsigned int trdp_set_training_values(void)
 {
-	int status = 0;
+	unsigned int status = 0;
 	EDP_Link_Config_t *link_config = dptx_get_link_config();
 	unsigned char aux_data[4];
 	
@@ -1152,9 +1521,9 @@ static int trdp_set_training_values(void)
 	return status;
 }
 
-static int trdp_set_training_pattern(unsigned char pattern)
+static unsigned int trdp_set_training_pattern(unsigned char pattern)
 {
-	int status = 0;
+	unsigned int status = 0;
 	
 	lcd_print("%s: pattern %u\n", __FUNCTION__, pattern);
 	//disable scrambling for any active test pattern
@@ -1167,9 +1536,9 @@ static int trdp_set_training_pattern(unsigned char pattern)
 	return status;
 }
 
-static int trdp_run_training_adjustment(void)
+static unsigned int trdp_run_training_adjustment(void)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned training_set = 0;
 	unsigned char vswing_level[4], preemp_level[4];
 	EDP_Link_Config_t *link_config = dptx_get_link_config();
@@ -1201,9 +1570,9 @@ static int trdp_run_training_adjustment(void)
 	return status;
 }
 
-static int trdp_run_clock_recovery(void)
+static unsigned int trdp_run_clock_recovery(void)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned lane_count;
 	unsigned char cr_done[4];
 	unsigned char aux_data[6];
@@ -1218,7 +1587,7 @@ static int trdp_run_clock_recovery(void)
 		cr_done[1] = 0;
 		cr_done[2] = 0;
 		cr_done[3] = 0;
-		status = VAL_EDP_TX_AUX_OPERATION_FAILED;
+		status = RET_EDP_TX_AUX_OPERATION_FAILED;
 	}
 	else {
 		adj_req_lane01 = aux_data[4];
@@ -1231,17 +1600,17 @@ static int trdp_run_clock_recovery(void)
 		
 		clock_recovery_done = cr_done[0] + cr_done[1] + cr_done[2] + cr_done[3];
 		if (clock_recovery_done == lane_count)
-			status = VAL_EDP_TX_OPERATION_SUCCESS;
+			status = RET_EDP_TX_OPERATION_SUCCESS;
 		else
-			status = VAL_EDP_TX_OPERATION_FAILED;
+			status = RET_EDP_TX_OPERATION_FAILED;
 	}
 	
 	return status;
 }
 
-static int trdp_run_channel_equalization(void)
+static unsigned int trdp_run_channel_equalization(void)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned lane_count, cr_valid;
 	unsigned channel_equalization_done, symbol_lock_done, lane_align_done;
 	unsigned char chan_eq_done[4], sym_lock_done[4], aux_data[6];
@@ -1251,7 +1620,7 @@ static int trdp_run_channel_equalization(void)
 	
 	status = trdp_AUXRead(EDP_DPCD_STATUS_LANE_0_1, 6, aux_data);
 	if (status) {
-		status = VAL_EDP_TX_AUX_OPERATION_FAILED;
+		status = RET_EDP_TX_AUX_OPERATION_FAILED;
 	}
 	else {
 		adj_req_lane01 = aux_data[4];
@@ -1263,7 +1632,7 @@ static int trdp_run_channel_equalization(void)
 					((aux_data[1] >> BIT_EDP_LANE_3_STATUS_CLK_REC_DONE) & 0x01);
 		
 		if (cr_valid != lane_count) {
-			status = VAL_EDP_TRAINING_CR_FAILED;
+			status = RET_EDP_TRAINING_CR_FAILED;
 			DPRINT("%s: training CR failed\n", __FUNCTION__);
 		}
 		else {
@@ -1283,18 +1652,18 @@ static int trdp_run_channel_equalization(void)
 			lane_align_done = ((aux_data[2] >> BIT_EDP_LANE_ALIGNMENT_DONE) & 0x01);
 			
 			if ((channel_equalization_done == lane_count) && (symbol_lock_done == lane_count) && (lane_align_done == 1))
-				status = VAL_EDP_TX_OPERATION_SUCCESS;
+				status = RET_EDP_TX_OPERATION_SUCCESS;
 			else
-				status = VAL_EDP_TX_OPERATION_FAILED;
+				status = RET_EDP_TX_OPERATION_FAILED;
 		}		
 	}
 
 	return status;
 }
 
-static int trdp_run_clock_recovery_loop(unsigned max_iterations, unsigned adaptive)
+static unsigned int trdp_run_clock_recovery_loop(unsigned max_iterations, unsigned adaptive)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned xx = 0;
 	unsigned done = 0;
 	
@@ -1306,10 +1675,10 @@ static int trdp_run_clock_recovery_loop(unsigned max_iterations, unsigned adapti
 		
 		status = trdp_run_clock_recovery();
 		switch (status) {
-			case VAL_EDP_TX_OPERATION_SUCCESS:
+			case RET_EDP_TX_OPERATION_SUCCESS:
 				done = 1;
 				break;
-			case VAL_EDP_TX_OPERATION_FAILED:
+			case RET_EDP_TX_OPERATION_FAILED:
 				if (adaptive == 1) {
 					if ((preset_vswing_rx & 0x07) != 0x07)	//check for max vswing level
 						trdp_run_training_adjustment();
@@ -1317,7 +1686,7 @@ static int trdp_run_clock_recovery_loop(unsigned max_iterations, unsigned adapti
 						done = 1;
 				}
 				break;
-			case VAL_EDP_TX_AUX_OPERATION_FAILED:
+			case RET_EDP_TX_AUX_OPERATION_FAILED:
 				done = 1;
 				break;
 			default:
@@ -1329,9 +1698,9 @@ static int trdp_run_clock_recovery_loop(unsigned max_iterations, unsigned adapti
 	return status;
 }
 
-static int trdp_run_channel_equalization_loop(unsigned max_iterations, unsigned adaptive)
+static unsigned int trdp_run_channel_equalization_loop(unsigned max_iterations, unsigned adaptive)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned xx = 0;
 	unsigned done = 0;
 	
@@ -1344,16 +1713,16 @@ static int trdp_run_channel_equalization_loop(unsigned max_iterations, unsigned
 		
 		status = trdp_run_channel_equalization();
 		switch (status) {
-			case VAL_EDP_TRAINING_CR_FAILED:
+			case RET_EDP_TRAINING_CR_FAILED:
 				done = 1;
 				break;
-			case VAL_EDP_TX_OPERATION_SUCCESS:
+			case RET_EDP_TX_OPERATION_SUCCESS:
 				done = 1;
 				break;
-			case VAL_EDP_TX_AUX_OPERATION_FAILED:
+			case RET_EDP_TX_AUX_OPERATION_FAILED:
 				done = 1;
 				break;
-			case VAL_EDP_TX_OPERATION_FAILED:
+			case RET_EDP_TX_OPERATION_FAILED:
 				if (adaptive == 1)
 					trdp_run_training_adjustment();
 				break;
@@ -1367,26 +1736,26 @@ static int trdp_run_channel_equalization_loop(unsigned max_iterations, unsigned
 	return status;
 }
 
-static int trdp_update_status(void)
+static unsigned int trdp_update_status(void)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned char aux_data[3];
 	
 	status = trdp_AUXRead(EDP_DPCD_STATUS_LANE_0_1, 3, aux_data);
 	lcd_print("%s: aux_data0=0x%x, aux_data1=0x%x, aux_data2=0x%x, \n", __FUNCTION__, aux_data[0], aux_data[1], aux_data[2]);
-	if (status == VAL_EDP_TX_OPERATION_SUCCESS)
+	if (status == RET_EDP_TX_OPERATION_SUCCESS)
 		status = (aux_data[2] << 16) | (aux_data[1] << 8) | (aux_data[0] << 0);
 		
 	return status;
 }
 
-static int trdp_run_training_loop(unsigned training_settings, unsigned link_rate_adjust_en, unsigned adaptive, unsigned retry_num)
+static unsigned int trdp_run_training_loop(unsigned training_settings, unsigned link_rate_adjust_en, unsigned adaptive, unsigned retry_num)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned lanes = 0;
 	unsigned char aux_data[4];
 	unsigned done = 0, link_rate_adjust = 0;
-	unsigned training_state = VAL_EDP_TS_CLOCK_REC;
+	unsigned training_state = STA_EDP_TRAINING_CLOCK_REC;
 	unsigned link_speed;
 	
 	memset(aux_data, 0, 4);
@@ -1411,20 +1780,20 @@ static int trdp_run_training_loop(unsigned training_settings, unsigned link_rate
 			// if successful, the training sequence moves on to symbol lock.
 			// if clock recovery fails, the training loop exits.
 			//**************************************
-			case VAL_EDP_TS_CLOCK_REC:	//clock recovery loop
+			case STA_EDP_TRAINING_CLOCK_REC:	//clock recovery loop
 				status = trdp_run_clock_recovery_loop(VAL_EDP_MAX_TRAINING_ATTEMPTS, adaptive);
-				if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
-					training_state = VAL_EDP_TS_CHANNEL_EQ;
+				if (status == RET_EDP_TX_OPERATION_SUCCESS) {
+					training_state = STA_EDP_TRAINING_CHANNEL_EQ;
 				}
-				else if (status == VAL_EDP_TX_AUX_OPERATION_FAILED) {
+				else if (status == RET_EDP_TX_AUX_OPERATION_FAILED) {
 					DPRINT("trdp_run_clock_recovery_loop aux failed\n");
 					done = 1;
 				}
 				else {
 					DPRINT("trdp_run_clock_recovery_loop CR failed\n");
-					status = VAL_EDP_TRAINING_CR_FAILED;
+					status = RET_EDP_TRAINING_CR_FAILED;
 					if (link_rate_adjust_en == 1)
-						training_state = VAL_EDP_TS_ADJUST_SPD;
+						training_state = STA_EDP_TRAINING_ADJUST_SPD;
 					else
 						done = 1;
 				}
@@ -1434,20 +1803,20 @@ static int trdp_run_training_loop(unsigned training_settings, unsigned link_rate
 			// once clock recovery is complete, perform symbol lock and channel equalization.
 			// if this state fails, then we can adjust the link rate.
 			//**************************************
-			case VAL_EDP_TS_CHANNEL_EQ:
+			case STA_EDP_TRAINING_CHANNEL_EQ:
 				status = trdp_run_channel_equalization_loop(VAL_EDP_MAX_TRAINING_ATTEMPTS, adaptive);
-				if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
+				if (status == RET_EDP_TX_OPERATION_SUCCESS) {
 					done = 1;
 				}
-				else if (status == VAL_EDP_TX_AUX_OPERATION_FAILED) {
+				else if (status == RET_EDP_TX_AUX_OPERATION_FAILED) {
 					DPRINT("trdp_run_channel_equalization_loop AUX failed\n");
 					done = 1;
 				}
 				else {
 					DPRINT("trdp_run_channel_equalization_loop EQ failed\n");
-					status = VAL_EDP_TRAINING_CHAN_EQ_FAILED;
+					status = RET_EDP_TRAINING_CHAN_EQ_FAILED;
 					if (link_rate_adjust_en == 1)
-						training_state = VAL_EDP_TS_ADJUST_SPD;
+						training_state = STA_EDP_TRAINING_ADJUST_SPD;
 					else
 						done = 1;
 				}
@@ -1457,7 +1826,7 @@ static int trdp_run_training_loop(unsigned training_settings, unsigned link_rate
 			// when allowed by the function parameter, adjust the link speed and attempt to retrain the link starting with clock recovery.
 			// the state of the status variable should not be changed in this state allowing a failure condition to report the proper status.
 			//**************************************
-			case VAL_EDP_TS_ADJUST_SPD:
+			case STA_EDP_TRAINING_ADJUST_SPD:
 				if (retry_num == 1) {
 					link_speed = READ_DPTX_REG(EDP_TX_LINK_BW_SET);
 					lanes = READ_DPTX_REG(EDP_TX_LINK_COUNT_SET);
@@ -1481,20 +1850,20 @@ static int trdp_run_training_loop(unsigned training_settings, unsigned link_rate
 	trdp_set_training_pattern(VAL_EDP_TRAINING_PATTERN_OFF);
 	WRITE_DPTX_REG(EDP_TX_SCRAMBLING_DISABLE, 0x00);	//turn on scrambling after training
 	
-	//if (status == VAL_EDP_TX_OPERATION_SUCCESS)
+	//if (status == RET_EDP_TX_OPERATION_SUCCESS)
 	if (link_rate_adjust)
-		status = VAL_EDP_LPM_STATUS_LINK_RATE_ADJUST;
+		status = RET_EDP_LPM_STATUS_LINK_RATE_ADJUST;
 	else
 		status = trdp_update_status();
 
 	return status;
 }
 
-static int trdp_set_link_config(unsigned char link_rate, unsigned char lane_count)
+static unsigned int trdp_set_link_config(unsigned char link_rate, unsigned char lane_count)
 {
 	unsigned char aux_data[2];
 	unsigned enhance_framing_mode;
-	int status = 0;
+	unsigned int status = 0;
 
 	switch (link_rate) {
 		case VAL_EDP_TX_LINK_BW_SET_162:
@@ -1502,7 +1871,7 @@ static int trdp_set_link_config(unsigned char link_rate, unsigned char lane_coun
 			aux_data[0] = link_rate;
 			break;
 		default:
-			status = VAL_EDP_TX_AUX_INVALID_PARAMETER;
+			status = RET_EDP_TX_AUX_INVALID_PARAMETER;
 			break;
 	}
 	switch (lane_count) {
@@ -1515,7 +1884,7 @@ static int trdp_set_link_config(unsigned char link_rate, unsigned char lane_coun
 			aux_data[1] = lane_count;
 			break;
 		default:
-			status = VAL_EDP_TX_AUX_INVALID_PARAMETER;
+			status = RET_EDP_TX_AUX_INVALID_PARAMETER;
 			break;
 	}
 	if (status == 0) {
@@ -1529,9 +1898,9 @@ static int trdp_set_link_config(unsigned char link_rate, unsigned char lane_coun
 	return status;
 }
 
-static int trdp_set_data_lane_config(EDP_Link_Config_t *link_config)
+static unsigned int trdp_set_data_lane_config(EDP_Link_Config_t *link_config)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned char aux_data[4];
 	unsigned vswing = link_config->vswing & 0xff;
 	unsigned preemphasis = link_config->preemphasis & 0xff;
@@ -1549,7 +1918,7 @@ static int trdp_set_data_lane_config(EDP_Link_Config_t *link_config)
 			WRITE_DPTX_REG(EDP_TX_PHY_VOLTAGE_DIFF_LANE_3, vswing);
 			break;
 		default:
-			status = VAL_EDP_TX_OPERATION_FAILED;
+			status = RET_EDP_TX_OPERATION_FAILED;
 			break;
 	}
 	
@@ -1565,14 +1934,14 @@ static int trdp_set_data_lane_config(EDP_Link_Config_t *link_config)
 			WRITE_DPTX_REG(EDP_TX_PHY_PRE_EMPHASIS_LANE_3, preemphasis);
 			break;
 		default:
-			status = VAL_EDP_TX_OPERATION_FAILED;
+			status = RET_EDP_TX_OPERATION_FAILED;
 			break;
 	}
 
 	//write the preset values to the sink device
 	vswing_rx = trdp_DPCD_vswing_for_value(vswing);
 	preemp_rx = trdp_DPCD_preemphasis_for_value(preemphasis, vswing);
-	if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
+	if (status == RET_EDP_TX_OPERATION_SUCCESS) {
 		aux_data[0] = (preemp_rx << 3) | vswing_rx;
 		aux_data[1] = (preemp_rx << 3) | vswing_rx;
 		aux_data[2] = (preemp_rx << 3) | vswing_rx;
@@ -1590,28 +1959,28 @@ static void dplpm_print_training_status(int status)
 	char status_string[80];
 
 	switch (status) {
-		case VAL_EDP_TRAINING_CR_FAILED:
+		case RET_EDP_TRAINING_CR_FAILED:
 			sprintf(status_string, "Clock Recovery failed");
 			break;
-		case VAL_EDP_TRAINING_CHAN_EQ_FAILED:
+		case RET_EDP_TRAINING_CHAN_EQ_FAILED:
 			sprintf(status_string, "Symbol Lock failed");
 			break;
-		case VAL_EDP_TX_AUX_OPERATION_FAILED:
+		case RET_EDP_TX_AUX_OPERATION_FAILED:
 			sprintf(status_string, "AUX operation failure during training");
 			break;
-		case VAL_EDP_CONFIG_INVALID_LINK_RATE:
-			sprintf(status_string, "Invalid link rate selected");
+		case RET_EDP_CONFIG_INVALID_LINK_RATE:
+			sprintf(status_string, "Invalid link rate config");
 			break;
-		case VAL_EDP_CONFIG_INVALID_LANE_COUNT:
-			sprintf(status_string, "Invalid lane count selected");
+		case RET_EDP_CONFIG_INVALID_LANE_COUNT:
+			sprintf(status_string, "Invalid lane count config");
 			break;
-		case VAL_EDP_CONFIG_HPD_DEASSERTED:
+		case RET_EDP_CONFIG_HPD_DEASSERTED:
 			sprintf(status_string, "HPD deasserted");
 			break;
-		case VAL_EDP_TX_OPERATION_SUCCESS:
+		case RET_EDP_TX_OPERATION_SUCCESS:
 			sprintf(status_string, "Success");
 			break;
-		case VAL_EDP_LPM_STATUS_RETRAIN:
+		case RET_EDP_LPM_STATUS_RETRAIN:
 			sprintf(status_string, "Retrain");
 			break;
 		default:
@@ -1637,9 +2006,9 @@ static void dplpm_main_stream_enable(unsigned enable)
 	lcd_print("displayport main stream %s\n", enable ? "enable" : "disable");
 }
 
-static int dplpm_verify_link_status(void)
+static unsigned int dplpm_verify_link_status(void)
 {
-	int status = 0;
+	unsigned int status = 0;
 	unsigned link_ok = 0;
 	unsigned char aux_data[8];
 	
@@ -1663,23 +2032,23 @@ static int dplpm_verify_link_status(void)
 	}
 
 	if ((status & link_ok) == link_ok)
-		status = VAL_EDP_LPM_STATUS_TRAINING_SUCCESS;
+		status = RET_EDP_LPM_STATUS_TRAINING_SUCCESS;
 	else
-		status = VAL_EDP_LPM_STATUS_RETRAIN;
+		status = RET_EDP_LPM_STATUS_RETRAIN;
 
-	lcd_print("%s: %s\n",__FUNCTION__, (status == VAL_EDP_LPM_STATUS_TRAINING_SUCCESS) ? "training success" : "retrain");
+	lcd_print("%s: %s\n",__FUNCTION__, (status == RET_EDP_LPM_STATUS_TRAINING_SUCCESS) ? "training success" : "retrain");
 	return status;
 }
 
-static int dplpm_maintain_link(void)
+static unsigned int dplpm_maintain_link(void)
 {
 	unsigned training_attempts = VAL_EDP_MAX_TRAINING_ATTEMPTS;
 	unsigned training_successful = 0, retrain = 0;
-	int status = VAL_EDP_LPM_STATUS_RETRAIN;
+	unsigned int status = RET_EDP_LPM_STATUS_RETRAIN;
 	EDP_Link_Config_t *link_config = dptx_get_link_config();
 	
 	//status = dplpm_verify_link_status();
-	if (status == VAL_EDP_LPM_STATUS_RETRAIN) {
+	if (status == RET_EDP_LPM_STATUS_RETRAIN) {
 		dplpm_main_stream_enable(0);
 		retrain = 1;
 	}
@@ -1688,7 +2057,7 @@ static int dplpm_maintain_link(void)
 		while ((training_attempts > 0) && (training_successful != 1)) {
 			status = trdp_run_training_loop(link_config->training_settings, link_config->link_rate_adjust_en, link_config->link_adaptive, training_attempts);
 			status = dplpm_verify_link_status();
-			if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
+			if (status == RET_EDP_TX_OPERATION_SUCCESS) {
 				training_successful = 1;
 				//dplpm_main_stream_enable(1);
 			}
@@ -1706,9 +2075,9 @@ static int dplpm_maintain_link(void)
 	return status;
 }
 
-static int dplpm_link_init(EDP_Link_Config_t *link_config)
+static unsigned int dplpm_link_init(EDP_Link_Config_t *link_config)
 {
-	unsigned status = 0;
+	unsigned int status = 0;
 	unsigned char link_rate = link_config->link_rate & 0xff;
 	unsigned char lane_count = link_config->lane_count & 0x7;
 	unsigned char ss_level = link_config->ss_level & 0xf;
@@ -1719,7 +2088,7 @@ static int dplpm_link_init(EDP_Link_Config_t *link_config)
 	if (core_id == VAL_EDP_TX_CORE_ID) {
 		WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
 		mdelay(10);
-		WRITE_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE, 0);	//disable the transmitter
+		WRITE_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE, 0); //disable the transmitter
 		WRITE_DPTX_REG(EDP_TX_PHY_RESET, 0xf);	//reset the PHY
 		
 		//reset edp tx fifo
@@ -1731,11 +2100,11 @@ static int dplpm_link_init(EDP_Link_Config_t *link_config)
 		WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 0, 11, 1);
 		WRITE_LCD_CBUS_REG_BITS(RESET4_REGISTER, 0, 11, 1);
 		WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 1, 11, 1);
-		lcd_print("release reset edp tx\n");		
+		lcd_print("release reset edp tx\n");
 		
 		WRITE_DPTX_REG(EDP_TX_AUX_CLOCK_DIVIDER, 170); // Set Aux clk-div by APB clk
 
-		status = dptx_init_lane_config(link_rate, lane_count);			
+		status = dptx_init_lane_config(link_rate, lane_count);
 		status = dptx_init_downspread(ss_level);
 		
 		mdelay(10);
@@ -1747,33 +2116,33 @@ static int dplpm_link_init(EDP_Link_Config_t *link_config)
 		
 		status = trdp_set_link_config(link_rate, lane_count);
 		if (status)
-			return VAL_EDP_TX_OPERATION_FAILED;
+			return RET_EDP_TX_OPERATION_FAILED;
 		
 		status = trdp_set_downspread(ss_level);
 		if (status)
-			return VAL_EDP_TX_OPERATION_FAILED;
+			return RET_EDP_TX_OPERATION_FAILED;
 			
 		status = trdp_set_data_lane_config(link_config);	//set vswing & preemphasis
 		if (status)
-			return VAL_EDP_TX_OPERATION_FAILED;
+			return RET_EDP_TX_OPERATION_FAILED;
 			
 		lcd_print("..... Power up sink link .....\n");
 		power_state = 1;	//normal operation
 		status = trdp_AUXWrite(EDP_DPCD_SET_POWER, 1, &power_state);
 		mdelay(30);
 		if (status)
-			return VAL_EDP_TX_OPERATION_FAILED;
+			return RET_EDP_TX_OPERATION_FAILED;
 	}
 	else { 
 		DPRINT("Can't find eDP Core ID\n");
-		return VAL_EDP_TX_OPERATION_FAILED;
+		return RET_EDP_TX_OPERATION_FAILED;
 	}
 	return status;
 }
 
-int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_MSA_t *vm)
+unsigned int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_MSA_t *vm)
 {
-	int status = 0;
+	unsigned int status = 0;
 	EDP_Link_Config_t *link_config = dptx_get_link_config();
 	
 	link_config->max_lane_count = mlconfig->max_lane_count;
@@ -1788,9 +2157,10 @@ int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_MSA_t *vm)
 	
 	status = dplpm_link_init(link_config);
 
-	if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
+	if (status == RET_EDP_TX_OPERATION_SUCCESS) {
 		status = dplpm_maintain_link();
 		if (lcd_print_flag > 0) {
+			trdp_dump_EDID();
 			trdp_dump_DPCD();
 			trdp_dump_DPCD_training_status();
 		}
@@ -1800,7 +2170,7 @@ int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_MSA_t *vm)
 	}
 	else {
 		DPRINT("displayport initial failed\n");
-		status = VAL_EDP_TX_OPERATION_FAILED;
+		status = RET_EDP_TX_OPERATION_FAILED;
 	}
 	if (lcd_print_flag > 0) {
 		dptx_dump_link_config();
@@ -1818,9 +2188,9 @@ int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_MSA_t *vm)
 	return status;
 }
 
-int dplpm_link_off(void)
+unsigned int dplpm_link_off(void)
 {
-    int status = 0;
+    unsigned int status = 0;
     unsigned char aux_data;
 
     lcd_print("..... Power down edp sink link .....\n");
@@ -1846,6 +2216,41 @@ void dplpm_off(void)
 	WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 1, 11, 1);
 }
 
+void edp_edid_pre_enable(void)
+{
+	WRITE_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE, 0); //disable the transmitter
+	WRITE_DPTX_REG(EDP_TX_PHY_RESET, 0xf);	//reset the PHY
+	
+	//reset edp tx fifo
+	WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 0, 11, 1);
+	WRITE_LCD_CBUS_REG_BITS(RESET4_REGISTER, 1, 11, 1);
+	WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 1, 11, 1);
+	mdelay(10);
+	WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 0, 11, 1);
+	WRITE_LCD_CBUS_REG_BITS(RESET4_REGISTER, 0, 11, 1);
+	WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 1, 11, 1);
+	
+	WRITE_DPTX_REG(EDP_TX_AUX_CLOCK_DIVIDER, 170); // Set Aux clk-div by APB clk
+	
+	mdelay(10);
+	WRITE_DPTX_REG(EDP_TX_PHY_RESET, 0);
+	dptx_wait_phy_ready();
+	mdelay(10);
+	WRITE_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE, 1);
+	WRITE_DPTX_REG(EDP_TX_AUX_INTERRUPT_MASK, 0xf);	//mask the interrupt, use polling mode
+}
+
+void edp_edid_pre_disable(void)
+{
+	WRITE_DPTX_REG(EDP_TX_TRANSMITTER_OUTPUT_ENABLE, 0);	//disable the transmitter
+	WRITE_DPTX_REG(EDP_TX_PHY_RESET, 0xf);	//reset the PHY
+	WRITE_DPTX_REG(EDP_TX_PHY_POWER_DOWN, 0xf);	//need to set
+
+	WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 0, 11, 1);
+	WRITE_LCD_CBUS_REG_BITS(RESET4_REGISTER, 1, 11, 1);
+	WRITE_LCD_CBUS_REG_BITS(RESET4_MASK, 1, 11, 1);
+}
+
 //***********************************************//
 static const char * edp_usage_str =
 {"Usage:\n"
@@ -1856,6 +2261,7 @@ static const char * edp_usage_str =
 "    echo link > edp ; print edp link config information\n"
 "    echo msa > edp ; print edp main stream attributes information\n"
 "    echo dpcd > edp ; print edp DPCD information\n"
+"    echo edid > edp ; print edp EDID information\n"
 "    echo status > edp ; print edp link training status information\n"
 };
 
@@ -1887,7 +2293,7 @@ static ssize_t edp_debug(struct class *class, struct class_attribute *attr, cons
 			else if (s[0] == 'r') {	//rx -- aux --dpcd
 				num = (num < 16) ? num : 16;
 				status = trdp_AUXRead(t[0], num, aux_data);
-				if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
+				if (status == RET_EDP_TX_OPERATION_SUCCESS) {
 					DPRINT("read edp DPCD reg:\n");
 					for (i=0; i<num; i++) {
 						DPRINT("  0x%04x = 0x%02x\n", t[0]+i, aux_data[i]);
@@ -1907,9 +2313,9 @@ static ssize_t edp_debug(struct class *class, struct class_attribute *attr, cons
 			else if (s[0] == 'r') {	//rx -- aux --dpcd
 				aux_data[0] = t[0];
 				status = trdp_AUXWrite(t[1], 1, aux_data);
-				if (status == VAL_EDP_TX_OPERATION_SUCCESS) {
+				if (status == RET_EDP_TX_OPERATION_SUCCESS) {
 					status = trdp_AUXRead(t[1], 1, aux_data);
-					if (status != VAL_EDP_TX_OPERATION_SUCCESS) {
+					if (status != RET_EDP_TX_OPERATION_SUCCESS) {
 						DPRINT("Failed to readback DPCD reg\n");
 						aux_data[0] = 0;
 					}
@@ -1945,6 +2351,9 @@ static ssize_t edp_debug(struct class *class, struct class_attribute *attr, cons
 		case 'd':
 			trdp_dump_DPCD();
 			break;
+		case 'e':
+			trdp_dump_EDID();
+			break;
 		case 's':
 			trdp_dump_DPCD_training_status();
 			break;
@@ -1991,6 +2400,64 @@ static int remove_edp_attr(Lcd_Config_t *pConf)
     return 0;
 }
 //*********************************************************//
+static void edp_edid_timing_config(Lcd_Config_t *pConf, EDP_EDID_Data_Type_t *edid_data_parase)
+{
+	unsigned int temp;
+	
+	pConf->lcd_basic.h_active = edid_data_parase->preferred_timing.h_active;
+	pConf->lcd_basic.v_active = edid_data_parase->preferred_timing.v_active;
+	if (edid_data_parase->preferred_timing.h_blank > 120)
+		pConf->lcd_basic.h_period = edid_data_parase->preferred_timing.h_active + edid_data_parase->preferred_timing.h_blank;
+	else
+		pConf->lcd_basic.h_period = edid_data_parase->preferred_timing.h_active + 121;
+	if (edid_data_parase->preferred_timing.v_blank >= 22)
+		pConf->lcd_basic.v_period = edid_data_parase->preferred_timing.v_active + edid_data_parase->preferred_timing.v_blank;
+	else
+		pConf->lcd_basic.v_period = edid_data_parase->preferred_timing.v_active + 22;
+	
+	temp = edid_data_parase->preferred_timing.pclk / (edid_data_parase->preferred_timing.h_active + edid_data_parase->preferred_timing.h_blank);
+	temp = temp * 100 / (edid_data_parase->preferred_timing.v_active + edid_data_parase->preferred_timing.v_blank);
+	temp = (temp + 5) / 10;
+	pConf->lcd_timing.lcd_clk = (temp * pConf->lcd_basic.v_period / 10) * pConf->lcd_basic.h_period;
+	
+	pConf->lcd_timing.hsync_width = edid_data_parase->preferred_timing.h_pw;
+	pConf->lcd_timing.hsync_bp = edid_data_parase->preferred_timing.h_blank - edid_data_parase->preferred_timing.h_fp; //include pw
+	pConf->lcd_timing.vsync_width = edid_data_parase->preferred_timing.v_pw;
+	pConf->lcd_timing.vsync_bp = edid_data_parase->preferred_timing.v_blank - edid_data_parase->preferred_timing.v_fp; //include pw
+	
+	pConf->lcd_basic.h_active_area = edid_data_parase->preferred_timing.h_size;
+	pConf->lcd_basic.v_active_area = edid_data_parase->preferred_timing.v_size;
+	pConf->lcd_basic.screen_ratio_width = edid_data_parase->preferred_timing.h_size;
+	pConf->lcd_basic.screen_ratio_height = edid_data_parase->preferred_timing.v_size;
+	
+	pConf->lcd_timing.pol_ctrl = ((pConf->lcd_timing.pol_ctrl & ~((1 << POL_CTRL_HS) | (1 << POL_CTRL_VS))) | (((edid_data_parase->preferred_timing.timing_ctrl >> 1) & 1) << POL_CTRL_HS) | (((edid_data_parase->preferred_timing.timing_ctrl >> 2) & 1) << POL_CTRL_VS));
+}
+
+int edp_edid_timing_probe(Lcd_Config_t *pConf)
+{
+	unsigned int status;
+	unsigned char edid_data[128];
+	EDP_EDID_Data_Type_t edid_data_parase;
+	
+	status = trdp_read_EDID(&edid_data[0]);
+	if (status) {
+		DPRINT("Failed to get EDID from sink device\n");
+		return -1;
+	}
+	else {
+		status = EDID_parase(&edid_data[0], &edid_data_parase);
+		if (status == RET_EDP_TX_OPERATION_SUCCESS) {
+			edp_edid_timing_config(pConf, &edid_data_parase);
+			DPRINT("Load edp EDID timing\n");
+		}
+		else {
+			DPRINT("Failed to load EDID timing\n");
+			return -1;
+		}
+	}
+	
+	return 0;
+}
 
 void edp_probe(Lcd_Config_t *pConf)
 {
diff --git a/arch/arm/mach-meson8/lcd/edp_drv.h b/arch/arm/mach-meson8/lcd/edp_drv.h
index 88b223cb88aa..8cb646fe4d59 100755
--- a/arch/arm/mach-meson8/lcd/edp_drv.h
+++ b/arch/arm/mach-meson8/lcd/edp_drv.h
@@ -24,8 +24,6 @@
 #define VAL_EDP_TX_PHY_PREEMPHASIS_3					0x0f   // 9.5 db
 
 //AUX Channel Interface
-#define VAL_EDP_TX_AUX_WAIT_TIME						400	//us
-
 #define VAL_EDP_TX_AUX_CMD_WRITE						(0x8 << 8)
 #define VAL_EDP_TX_AUX_CMD_READ							(0x9 << 8)
 #define VAL_EDP_TX_AUX_CMD_I2C_WRITE					(0x0 << 8)
@@ -41,11 +39,13 @@
 #define VAL_EDP_TX_AUX_REPLY_CODE_I2C_NACK				(0x4 << 0)
 #define VAL_EDP_TX_AUX_REPLY_CODE_I2C_DEFER				(0x8 << 0)
 
+//AUX channel management logic
 #define VAL_EDP_TX_AUX_STATE_TIMEOUT					(1 << 3)
 #define VAL_EDP_TX_AUX_STATE_RECEIVED					(1 << 2)
 #define VAL_EDP_TX_AUX_STATE_REQUEST_IN_PROGRESS		(1 << 1)
 #define VAL_EDP_TX_AUX_STATE_HPD_STATE					(1 << 0)
 
+//AUX channel controller status
 #define VAL_EDP_TX_AUX_STATUS_REPLY_ERROR				(1 << 3)
 #define VAL_EDP_TX_AUX_STATUS_REQUEST_IN_PROGRESS		(1 << 2)
 #define VAL_EDP_TX_AUX_STATUS_REPLY_IN_PROGRESS			(1 << 1)
@@ -56,10 +56,10 @@
 #define VAL_EDP_TX_LANE_STATUS_OK_1						0x10007
 #define VAL_EDP_TX_LANE_STATUS_OK_NONE					0xfffff
 
-//operation
-#define VAL_EDP_TX_TRAINING_RETRY_COUNT			5
-#define VAL_EDP_TX_AUX_MAX_DEFER_COUNT			7
-#define VAL_EDP_TX_AUX_MAX_TIMEOUT_COUNT		5
+//AUX operation
+#define VAL_EDP_TX_AUX_WAIT_TIME						400	//us
+#define VAL_EDP_TX_AUX_MAX_DEFER_COUNT					7
+#define VAL_EDP_TX_AUX_MAX_TIMEOUT_COUNT				5
 
 
 //******************************************************//
@@ -106,7 +106,7 @@
 #define BIT_EDP_LANE_1_STATUS_CLK_REC_DONE			4
 #define BIT_EDP_LANE_1_STATUS_CHAN_EQ_DONE			5
 #define BIT_EDP_LANE_1_STATUS_SYM_LOCK_DONE			6
-#define BIT_EDP_LANE_2_STATUS_CLK_REC_DONE			BIT_EDP_LANE_0_STATUS_CLK_REC_DONE      
+#define BIT_EDP_LANE_2_STATUS_CLK_REC_DONE			BIT_EDP_LANE_0_STATUS_CLK_REC_DONE
 #define BIT_EDP_LANE_2_STATUS_CHAN_EQ_DONE			BIT_EDP_LANE_0_STATUS_CHAN_EQ_DONE 
 #define BIT_EDP_LANE_2_STATUS_SYM_LOCK_DONE			BIT_EDP_LANE_0_STATUS_SYM_LOCK_DONE
 #define BIT_EDP_LANE_3_STATUS_CLK_REC_DONE			BIT_EDP_LANE_1_STATUS_CLK_REC_DONE 
@@ -115,6 +115,7 @@
 #define BIT_EDP_LANE_ALIGNMENT_DONE					0
 
 // Link training constants
+#define VAL_EDP_TX_TRAINING_RETRY_COUNT				5
 #define VAL_EDP_MAX_TRAINING_ATTEMPTS				5
 #define VAL_EDP_CLOCK_REC_TIMEOUT					1//ms //100 //us
 #define VAL_EDP_CHAN_EQ_TIMEOUT						4//ms //400 //us
@@ -123,11 +124,11 @@
 #define VAL_EDP_MAX_DELAY_CYCLES					10 // 10us delay
 
 // Link training state constants
-#define VAL_EDP_TS_CLOCK_REC						0x01
-#define VAL_EDP_TS_CHANNEL_EQ						0x02
-#define VAL_EDP_TS_ADJUST_SPD						0x04
-#define VAL_EDP_TS_ADJUST_LANES						0x08
-#define VAL_EDP_TS_UPDATE_STATUS					0x10
+#define STA_EDP_TRAINING_CLOCK_REC					0x01
+#define STA_EDP_TRAINING_CHANNEL_EQ					0x02
+#define STA_EDP_TRAINING_ADJUST_SPD					0x04
+#define STA_EDP_TRAINING_ADJUST_LANES				0x08
+#define STA_EDP_TRAINING_UPDATE_STATUS				0x10
 
 // Embedded DisplayPort constants
 #define VAL_EDP_NOT_SUPPORTED						0x707
@@ -138,43 +139,44 @@
 #define VAL_EDP_DPCD_TEST_RESPONSE_EDID_CHKSUM_WR	(1 << 2)
 
 //********************************************************//
-// displayport operation stauts
+// displayport operation return stauts
 //
 // 0x00xx: EDP total operaion
 // 0x11xx: AUX operation
-// 0xAAxx: EDP link policy maker control
-// 0xEExx: EDP configuration verify
-// 0xFFxx: EDP training operation
+// 0x22xx: EDP configuration verify
+// 0xAAxx: EDP training operation
+// 0xBBxx: EDP link policy maker control
 //
-// note: all success or correct status are x0000
+// note: all success or correct status are 0x0000
+//       all failed status are 0xxxFF
 //********************************************************//
-#define VAL_EDP_CONFIG_VALID					0x0000
-#define VAL_EDP_CONFIG_INVALID_LINK_RATE		0xEEAA
-#define VAL_EDP_CONFIG_INVALID_LANE_COUNT		0xEEBB
-#define VAL_EDP_CONFIG_HPD_DEASSERTED			0xEECC
-
-#define VAL_EDP_TRAINING_CR_FAILED				0xFF11
-#define VAL_EDP_TRAINING_CHAN_EQ_FAILED			0xFF22
-#define VAL_EDP_TRAINING_INVALID_CONFIG			0xFF88
-
-#define VAL_EDP_LPM_STATUS_TRAINING_SUCCESS		0x0000
-#define VAL_EDP_LPM_STATUS_LINK_VALID			0x0000
-#define VAL_EDP_LPM_STATUS_CHANGED				0xAA10
-#define VAL_EDP_LPM_STATUS_RETRAIN				0xAA11
-#define VAL_EDP_LPM_STATUS_LINK_RATE_ADJUST		0xAA12
-#define VAL_EDP_LPM_STATUS_NOT_CONNECTED		0xAA13
-#define VAL_EDP_LPM_STATUS_TX_NOT_CONFIGURED	0xAA21
-#define VAL_EDP_LPM_STATUS_RX_IDLE				0xAA31
-#define VAL_EDP_LPM_STATUS_RX_ACTIVE			0xAA32
-
-#define VAL_EDP_TX_AUX_INVALID_PARAMETER		0x1144
-#define VAL_EDP_TX_AUX_OPERATION_TIMEOUT		0x1133
-#define VAL_EDP_TX_AUX_OPERATION_ERROR			0x1122
-#define VAL_EDP_TX_AUX_OPERATION_FAILED			0x1111
-#define VAL_EDP_TX_AUX_OPERATION_SUCCESS		0x0000
-
-#define VAL_EDP_TX_OPERATION_FAILED				0x00FF
-#define VAL_EDP_TX_OPERATION_SUCCESS			0x0000
+#define RET_EDP_TX_OPERATION_SUCCESS			0x0000
+#define RET_EDP_TX_OPERATION_FAILED				0x00FF
+
+#define RET_EDP_TX_AUX_OPERATION_SUCCESS		0x0000
+#define RET_EDP_TX_AUX_OPERATION_ERROR			0x1111
+#define RET_EDP_TX_AUX_OPERATION_TIMEOUT		0x1122
+#define RET_EDP_TX_AUX_INVALID_PARAMETER		0x1144
+#define RET_EDP_TX_AUX_OPERATION_FAILED			0x11FF
+
+#define RET_EDP_CONFIG_VALID					0x0000
+#define RET_EDP_CONFIG_INVALID_LINK_RATE		0x2211
+#define RET_EDP_CONFIG_INVALID_LANE_COUNT		0x2222
+#define RET_EDP_CONFIG_HPD_DEASSERTED			0x2244
+
+#define RET_EDP_TRAINING_CR_FAILED				0xAA11
+#define RET_EDP_TRAINING_CHAN_EQ_FAILED			0xAA22
+#define RET_EDP_TRAINING_INVALID_CONFIG			0xAA44
+
+#define RET_EDP_LPM_STATUS_TRAINING_SUCCESS		0x0000
+#define RET_EDP_LPM_STATUS_LINK_VALID			0x0000
+#define RET_EDP_LPM_STATUS_CHANGED				0xBB10
+#define RET_EDP_LPM_STATUS_RETRAIN				0xBB11
+#define RET_EDP_LPM_STATUS_LINK_RATE_ADJUST		0xBB12
+#define RET_EDP_LPM_STATUS_NOT_CONNECTED		0xBB13
+#define RET_EDP_LPM_STATUS_TX_NOT_CONFIGURED	0xBB21
+#define RET_EDP_LPM_STATUS_RX_IDLE				0xBB31
+#define RET_EDP_LPM_STATUS_RX_ACTIVE			0xBB32
 //********************************************************//
 
 #define VAL_EDP_TX_INVALID_VALUE    0xFF
@@ -214,6 +216,16 @@ typedef enum {
 	EDP_HPD_STATE_INTERRUPT,
 } EDP_HPD_state_t;
 
+#define VAL_AUX_CMD_STATE_WRITE			0
+#define VAL_AUX_CMD_STATE_READ			1
+typedef struct {
+	unsigned int cmd_code;
+	unsigned int cmd_state;
+	unsigned int address;
+	unsigned int byte_count;
+	unsigned char *wr_data;
+} TRDP_AUXTrans_Req_t;
+
 typedef struct {
 	unsigned char dpcd_rev;
 	unsigned char max_lane_count;
@@ -273,11 +285,65 @@ typedef struct {
 	unsigned int bit_rate; //Mbps
 } EDP_Link_Config_t;
 
+typedef struct {
+	unsigned int pclk;
+	unsigned short h_active;
+	unsigned short h_blank;
+	unsigned short v_active;
+	unsigned short v_blank;
+	unsigned short h_fp;
+	unsigned short h_pw;
+	unsigned short v_fp;
+	unsigned short v_pw;
+	unsigned int h_size;
+	unsigned int v_size;
+	unsigned short h_border;
+	unsigned short v_border;
+	unsigned int timing_ctrl;
+} EDID_Timing_t;
+
+typedef struct {
+	unsigned int min_vfreq;
+	unsigned int max_v_freq;
+	unsigned int min_hfreq;
+	unsigned int max_hfreq;
+	unsigned int max_pclk;
+	unsigned int GTF_ctrl;
+	unsigned int GTF_start_hfreq;
+	unsigned int GTF_C;
+	unsigned int GTF_M;
+	unsigned int GTF_K;
+	unsigned int GTF_J;
+} EDID_Range_Limit_t;
+
+typedef struct {
+	unsigned char mid[4];     //[8:9]2byte
+	unsigned short pid;     //[10:11]2byte
+	unsigned int psn;       //[12:15]4byte
+	unsigned char week;     //[16]1byte
+	unsigned int year;     //[17]1byte
+	unsigned short version;  //[18:19]2byte
+	unsigned int established_timing; //[35:37]3byte
+	unsigned int standard_timing1;   //[38:45]4byte
+	unsigned int standard_timing2;   //[46:53]4byte
+	EDID_Timing_t preferred_timing;
+	unsigned int string_flag; //[2]serial_num, [1]asc_string, [0]name
+	unsigned char name[14]; //include "\0"
+	unsigned char serial_num[14];
+	unsigned char asc_string[14];
+	EDID_Range_Limit_t range_limit;
+	unsigned char ext_flag;  //[126]1byte
+	unsigned char checksum;  //[127]1byte, 256-(sum(byte0:126)%256) =? 0x100-(sum(byte0:126) & 0xff)
+} EDP_EDID_Data_Type_t;
+
 extern void edp_phy_config_update(unsigned char vswing_tx, unsigned char preemp_tx);
 
-extern int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_MSA_t *vm);
-extern int dplpm_link_off(void);
+extern unsigned int dplpm_link_policy_maker(EDP_Link_Config_t *mlconfig, EDP_MSA_t *vm);
+extern unsigned int dplpm_link_off(void);
 extern void dplpm_off(void);
+extern void edp_edid_pre_enable(void);
+extern void edp_edid_pre_disable(void);
+extern int edp_edid_timing_probe(Lcd_Config_t *pConf);
 extern void edp_probe(Lcd_Config_t *pConf);
 extern void edp_remove(Lcd_Config_t *pConf);
 
diff --git a/arch/arm/mach-meson8/lcd/lcd_config.c b/arch/arm/mach-meson8/lcd/lcd_config.c
index db68ee0c83c3..9a905e5629ba 100755
--- a/arch/arm/mach-meson8/lcd/lcd_config.c
+++ b/arch/arm/mach-meson8/lcd/lcd_config.c
@@ -893,6 +893,39 @@ void edp_phy_config_update(unsigned char vswing_tx, unsigned char preemp_tx)
     WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, vswing_ctrl);
     printk("edp link adaptive update: vswing_level=%u, preemphasis_level=%u\n", vswing_tx, preemp_tx);
 }
+
+static void lcd_config_edp_edid_load(void)
+{
+    if (lcd_Conf->lcd_control.edp_config->edid_timing_used) {
+        if (lcd_Conf->lcd_misc_ctrl.lcd_status == 0) {
+            //enable edp power, phy and tx
+            if (IS_MESON_M8_CPU)
+                WRITE_LCD_CBUS_REG(HHI_EDP_APB_CLK_CNTL, (1 << 7) | (2 << 0));      //fclk_div5---fixed 510M, div to 170M, edp apb clk
+            else if (IS_MESON_M8M2_CPU)
+                WRITE_LCD_CBUS_REG(HHI_EDP_APB_CLK_CNTL_M8M2, (1 << 7) | (2 << 0)); //fclk_div5---fixed 510M, div to 170M, edp apb clk
+
+            WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, LCD_DIGITAL_EDP);    //dphy select by interface
+            WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x8018);//[7:4]swing b:800mv, step 50mv
+            WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, ((0x6 << 16) | (0xf5d7 << 0)));
+            WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, ((0xc2b2 << 16) | (0x600 << 0)));//0xd2b0fe00);
+            WRITE_LCD_CBUS_REG_BITS(HHI_DIF_CSI_PHY_CNTL3, 0x10, 11, 5); //enable AUX channel
+            lcd_Conf->lcd_power_ctrl.power_ctrl(ON);
+            edp_edid_pre_enable();
+
+            edp_edid_timing_probe(lcd_Conf);
+
+            //disable edp tx, phy and power
+            edp_edid_pre_disable();
+            lcd_Conf->lcd_power_ctrl.power_ctrl(OFF);
+            WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
+            WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x00060000);
+            WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00200000);
+        }
+        else {
+            edp_edid_timing_probe(lcd_Conf);
+        }
+    }
+}
 //**************************************************//
 
 static int set_control_edp(Lcd_Config_t *pConf)
@@ -1850,6 +1883,8 @@ static Lcd_Config_t lcd_config = {
         .power_on_step = 0,
         .power_off_step = 0,
         .power_ctrl = NULL,
+        .ports_ctrl = NULL,
+        .power_ctrl_video = NULL,
     },
 };
 
@@ -1869,14 +1904,11 @@ static void lcd_config_assign(Lcd_Config_t *pConf)
     pConf->lcd_power_ctrl.power_ctrl_video = lcd_power_ctrl_video;
 
     pConf->lcd_misc_ctrl.vpp_sel = 0;
-    if (READ_LCD_REG(ENCL_VIDEO_EN) & 1)
-        pConf->lcd_misc_ctrl.lcd_status = 1;
-    else
-        pConf->lcd_misc_ctrl.lcd_status = 0;
     pConf->lcd_misc_ctrl.module_enable = lcd_module_enable;
     pConf->lcd_misc_ctrl.module_disable = lcd_module_disable;
     pConf->lcd_misc_ctrl.lcd_test = lcd_test;
     pConf->lcd_misc_ctrl.print_version = print_lcd_driver_version;
+    pConf->lcd_misc_ctrl.edp_edid_load = lcd_config_edp_edid_load;
 }
 
 void lcd_config_init(Lcd_Config_t *pConf)
@@ -1904,7 +1936,10 @@ void lcd_config_probe(Lcd_Config_t *pConf)
     spin_lock_init(&lcd_clk_lock);
 
     lcd_Conf = pConf;
-    lcd_config_assign(pConf);
+    if (READ_LCD_REG(ENCL_VIDEO_EN) & 1)
+        pConf->lcd_misc_ctrl.lcd_status = 1;
+    else
+        pConf->lcd_misc_ctrl.lcd_status = 0;
 
     switch (pConf->lcd_basic.lcd_type) {
         case LCD_DIGITAL_MIPI:
@@ -1912,10 +1947,12 @@ void lcd_config_probe(Lcd_Config_t *pConf)
             break;
         case LCD_DIGITAL_EDP:
             edp_probe(pConf);
+            lcd_config_edp_edid_load();
             break;
         default:
             break;
     }
+    lcd_config_assign(pConf);
 
     creat_lcd_video_attr(pConf);
 }
diff --git a/drivers/amlogic/display/vout/aml_lcd.dtd b/drivers/amlogic/display/vout/aml_lcd.dtd
index e538283932a3..baaf9ae8705e 100755
--- a/drivers/amlogic/display/vout/aml_lcd.dtd
+++ b/drivers/amlogic/display/vout/aml_lcd.dtd
@@ -27,6 +27,7 @@
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
 //$$ L4 PROP_U32 = "edp_sync_clock_mode"
+//$$ L4 PROP_U32 = "edp_edid_timing_used"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -114,6 +115,7 @@
         edp_user_link_rate_lane_count=<1 1 2>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
         edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
         edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
+        edp_edid_timing_used=<0>; /** edp use edid timing: (0=no use, 1=use) */
         rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
         //lcd power ctrl	//support up to 15 steps for each sequence
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index 4246af12f963..3f5ab1bbdb0a 100755
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -197,7 +197,7 @@ static int lcd_power_ctrl(Bool_t status)
 					break;
 				case LCD_POWER_TYPE_SIGNAL:
 					if (pDev->pConf->lcd_power_ctrl.ports_ctrl == NULL)
-						printk("no lcd_ports_ctrl\n");
+						lcd_print("no lcd_ports_ctrl\n");
 					else
 						pDev->pConf->lcd_power_ctrl.ports_ctrl(ON);
 					break;
@@ -261,7 +261,7 @@ static int lcd_power_ctrl(Bool_t status)
 					break;
 				case LCD_POWER_TYPE_SIGNAL:
 					if (pDev->pConf->lcd_power_ctrl.ports_ctrl == NULL)
-						printk("no lcd_ports_ctrl\n");
+						lcd_print("no lcd_ports_ctrl\n");
 					else
 						pDev->pConf->lcd_power_ctrl.ports_ctrl(OFF);
 					break;
@@ -793,7 +793,8 @@ static int temp_ttl_rb_swap, temp_ttl_bit_swap;
 static int temp_lvds_repack, temp_pn_swap, temp_lvds_vswing;
 static unsigned char temp_dsi_lane_num;
 static unsigned temp_dsi_bit_rate_min, temp_dsi_bit_rate_max, temp_factor_denominator, temp_factor_numerator;
-static unsigned char temp_edp_link_rate, temp_edp_lane_count, temp_edp_vswing, temp_edp_preemphasis;
+static unsigned char temp_edp_link_rate, temp_edp_lane_count, temp_edp_vswing, temp_edp_preemphasis, temp_edp_edid_timing_used;
+static unsigned int temp_edp_sync_clock_mode;
 
 static const char * lcd_common_usage_str =
 {"Usage:\n"
@@ -846,11 +847,12 @@ static const char * lcd_usage_str =
 "    echo mctl <init_mode> <disp_mode> <lp_clk_auto_stop> <transfer_switch> > debug ; write mipi-dsi control config\n"
 #endif
 #ifdef CONFIG_LCD_IF_EDP_VALID
-"    echo edp <link_rate> <lane_count> <vswing_level> > debug ; write edp config\n"
+"    echo edp <link_rate> <lane_count> <vswing_level> > debug ; write edp lane config\n"
+"    echo ectl <edid_timing_used> <sync_clock_mode> > debug; write edp control config"
 #endif
 "data format:\n"
 "    <xx_swap>      : 0=normal, 1=swap\n"
-"    <vswing_level> : lvds support level 0~4 (Default=1);"
+"    <vswing_level> : lvds support level 0~4 (Default=1),"
 #ifdef CONFIG_LCD_IF_EDP_VALID
 " edp support level 0~3 (default=0)"
 #endif
@@ -865,7 +867,9 @@ static const char * lcd_usage_str =
 "    <transfer_switch>  : 0=auto, 1=standard, 2=slow\n"
 #endif
 #ifdef CONFIG_LCD_IF_EDP_VALID
-"    <link_rate>    : 0=1.62G, 1=2.7G\n"
+"    <link_rate>        : 0=1.62G, 1=2.7G\n"
+"    <edid_timing_used> : 0=no use, 1=use, default=0\n"
+"    <sync_clock_mode>  : 0=asyncronous, 1=synchronous, default=1\n"
 #endif
 "\n"
 "    echo offset <h_sign> <h_offset> <v_sign> <v_offset> > debug ; write ttl display offset\n"
@@ -960,10 +964,11 @@ static void read_current_lcd_config(Lcd_Config_t *pConf)
                    "link_adaptive     %u\n"
                    "vswing            %u\n"
                    "max_lane_count    %u\n"
-                   "sync_clock_mode   %u\n\n",
+                   "sync_clock_mode   %u\n"
+                   "EDID timing used  %u\n\n",
                    ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count,
                    pConf->lcd_control.edp_config->link_adaptive, pConf->lcd_control.edp_config->vswing,
-                   pConf->lcd_control.edp_config->max_lane_count, pConf->lcd_control.edp_config->sync_clock_mode);
+                   pConf->lcd_control.edp_config->max_lane_count, pConf->lcd_control.edp_config->sync_clock_mode, pConf->lcd_control.edp_config->edid_timing_used);
             break;
         default:
             break;
@@ -1019,6 +1024,8 @@ static void save_lcd_config(Lcd_Config_t *pConf)
 			temp_edp_lane_count = pConf->lcd_control.edp_config->lane_count;
 			temp_edp_vswing = pConf->lcd_control.edp_config->vswing;
 			temp_edp_preemphasis = pConf->lcd_control.edp_config->preemphasis;
+			temp_edp_sync_clock_mode = pConf->lcd_control.edp_config->sync_clock_mode;
+			temp_edp_edid_timing_used = pConf->lcd_control.edp_config->edid_timing_used;
 			break;
 		case LCD_DIGITAL_LVDS:
 			temp_lvds_repack = pConf->lcd_control.lvds_config->lvds_repack;
@@ -1090,6 +1097,8 @@ static void reset_lcd_config(Lcd_Config_t *pConf)
 			pConf->lcd_control.edp_config->lane_count = temp_edp_lane_count;
 			pConf->lcd_control.edp_config->vswing = temp_edp_vswing;
 			pConf->lcd_control.edp_config->preemphasis = temp_edp_preemphasis;
+			pConf->lcd_control.edp_config->sync_clock_mode = temp_edp_sync_clock_mode;
+			pConf->lcd_control.edp_config->edid_timing_used = temp_edp_edid_timing_used;
 			break;
 		case LCD_DIGITAL_LVDS:
 			pConf->lcd_control.lvds_config->lvds_repack = temp_lvds_repack;
@@ -1295,10 +1304,7 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 				t[1] = 4;
 				t[2] = 0;
 				ret = sscanf(buf, "edp %u %u %u", &t[0], &t[1], &t[2]);
-				if (t[0] == 0)
-					pDev->pConf->lcd_control.edp_config->link_rate = 0;
-				else
-					pDev->pConf->lcd_control.edp_config->link_rate = 1;
+				pDev->pConf->lcd_control.edp_config->link_rate = ((t[0] == 0) ? 0 : 1);
 				switch (t[1]) {
 					case 1:
 					case 2:
@@ -1311,6 +1317,15 @@ static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, cons
 				pDev->pConf->lcd_control.edp_config->vswing = t[2];
 				printk("set edp link_rate = %s, lane_count = %u, vswing_level = %u\n", ((pDev->pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pDev->pConf->lcd_control.edp_config->lane_count, pDev->pConf->lcd_control.edp_config->vswing);
 			}
+			else if (buf[1] == 'c') {
+				t[0] = 0;
+				t[1] = 1;
+				ret = sscanf(buf, "ectl %u %u", &t[0], &t[1]);
+				pDev->pConf->lcd_control.edp_config->edid_timing_used = ((t[0] == 0) ? 0 : 1);
+				pDev->pConf->lcd_control.edp_config->sync_clock_mode = ((t[1] == 0) ? 0 : 1);
+				printk("set edp edid_timing_used = %u, sync_clock_mode = %u\n", pDev->pConf->lcd_control.edp_config->edid_timing_used, pDev->pConf->lcd_control.edp_config->sync_clock_mode);
+				pDev->pConf->lcd_misc_ctrl.edp_edid_load();
+			}
 #endif
 			else {
 				printk("wrong format of lcd debug command.\n");
@@ -1591,7 +1606,7 @@ static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pd
 		lcd_print("pol hsync = %u, vsync = %u\n", (pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1, (pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1);
 		ret = of_property_read_u32_array(lcd_model_node,"vsync_horizontal_phase",&lcd_para[0], 2);
 		if(ret){
-			printk("faild to get vsync_horizontal_phase\n");
+			lcd_print("faild to get vsync_horizontal_phase\n");
 			pConf->lcd_timing.vsync_h_phase = 0;
 		} else {
 			pConf->lcd_timing.vsync_h_phase = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
@@ -2004,6 +2019,15 @@ static int _get_lcd_default_config(Lcd_Config_t *pConf, struct platform_device *
 				pConf->lcd_control.edp_config->sync_clock_mode = (val & 1);
 				printk("edp sync_clock_mode = %u\n", pConf->lcd_control.edp_config->sync_clock_mode);
 			}
+			ret = of_property_read_u32(pdev->dev.of_node,"edp_edid_timing_used",&val);
+			if(ret){
+				printk("don't find to match edp_edid_timing_used, use default setting.\n");
+				pConf->lcd_control.edp_config->edid_timing_used = 0;
+			}
+			else {
+				pConf->lcd_control.edp_config->edid_timing_used = (unsigned char)(val & 1);
+				printk("edp edid_timing_used = %u\n", pConf->lcd_control.edp_config->edid_timing_used);
+			}
 		}
 		ret = of_property_read_u32_array(pdev->dev.of_node,"rgb_base_coeff",&lcd_para[0], 2);
 		if(ret){
diff --git a/include/linux/amlogic/vout/lcdoutc.h b/include/linux/amlogic/vout/lcdoutc.h
index 02949ba518df..bf598a3535dc 100755
--- a/include/linux/amlogic/vout/lcdoutc.h
+++ b/include/linux/amlogic/vout/lcdoutc.h
@@ -217,6 +217,7 @@ typedef struct {
 	unsigned char preemphasis;
 	unsigned int bit_rate;
 	unsigned int sync_clock_mode;
+	unsigned char edid_timing_used;
 } EDP_Config_t;
 
 typedef struct {
@@ -296,6 +297,7 @@ typedef struct {
     void (*module_disable)(void);
     void (*lcd_test)(unsigned num);
     void (*print_version)(void);
+    void (*edp_edid_load)(void);
 } Lcd_Misc_Ctrl_t;
 
 typedef struct {
-- 
2.19.0

