From 6ad2956aa11153f9287d06c286b2a44856fcd1b0 Mon Sep 17 00:00:00 2001
From: "zongdong.jiao" <zongdong.jiao@amlogic.com>
Date: Mon, 17 Nov 2014 21:59:42 +0800
Subject: [PATCH 5085/5965] g9tv: hdmitx20: add support hdmitx20 for g9tv

---
 arch/arm/configs/mesong9tv_defconfig          |    1 +
 .../mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c   |    2 +
 arch/arm/mach-mesong9tv/Makefile              |    3 +-
 arch/arm/mach-mesong9tv/clock.c               |    9 +-
 arch/arm/mach-mesong9tv/enc_clk_config.c      |  687 +++
 .../arm/mach-mesong9tv/hdmi_tx_hw_20/Makefile |    1 +
 .../hdmi_tx_hw_20/hdmi_tx_cec_hw.c            | 1014 ++++
 .../mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_hw.c | 4155 +++++++++++++++++
 .../hdmi_tx_hw_20/hdmi_tx_reg.c               |  173 +
 .../hdmi_tx_hw_20/hdmi_tx_reg.h               |  786 ++++
 .../hdmi_tx_hw_20/hdmitx_regs.h               |  564 +++
 .../mach-mesong9tv/hdmi_tx_hw_20/tvenc_conf.h |  231 +
 arch/arm/mach-mesong9tv/hw_enc_clk_config.h   |   41 +
 arch/arm/mach-mesong9tv/include/mach/io.h     |    4 +-
 arch/arm/mach-mesong9tv/include/mach/tvregs.h | 1996 ++++----
 drivers/amlogic/display/vout/Makefile         |    7 +-
 drivers/amlogic/display/vout/enc_clk_config.c |    6 +
 drivers/amlogic/display/vout/tvconf.c         |   24 +
 drivers/amlogic/display/vout/tvmode.h         |    2 +
 drivers/amlogic/display/vout/tvoutc.c         |    8 +-
 drivers/amlogic/hdmi/Kconfig                  |   16 +-
 drivers/amlogic/hdmi/Makefile                 |    5 +
 drivers/amlogic/hdmi/hdmi_common/Makefile     |    3 +
 .../hdmi/hdmi_common/hdmi_parameters.c        |  647 +++
 drivers/amlogic/hdmi/hdmi_tx_2/Makefile       |    5 +
 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_cec_key.c |  172 +
 .../amlogic/hdmi/hdmi_tx_2/hdmi_tx_audio.c    |  236 +
 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_cec.c  | 2425 ++++++++++
 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_edid.c | 1572 +++++++
 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.c |  164 +
 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.h |   17 +
 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c | 1819 ++++++++
 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_scdc.c |    1 +
 .../amlogic/hdmi/hdmi_tx_2/hdmi_tx_video.c    |  640 +++
 include/linux/amlogic/hdmi_tx/hdmi_common.h   |  427 ++
 .../linux/amlogic/hdmi_tx/hdmi_info_global.h  |  236 +-
 include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h   |  135 +-
 .../linux/amlogic/hdmi_tx/hdmi_tx_module.h    |   24 +-
 include/linux/amlogic/hdmi_tx/hdmi_tx_scdc.h  |   30 +
 include/linux/amlogic/vout/vinfo.h            |    3 +
 40 files changed, 17019 insertions(+), 1272 deletions(-)
 create mode 100644 arch/arm/mach-mesong9tv/enc_clk_config.c
 create mode 100644 arch/arm/mach-mesong9tv/hdmi_tx_hw_20/Makefile
 create mode 100644 arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_cec_hw.c
 create mode 100644 arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_hw.c
 create mode 100644 arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_reg.c
 create mode 100644 arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_reg.h
 create mode 100644 arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmitx_regs.h
 create mode 100644 arch/arm/mach-mesong9tv/hdmi_tx_hw_20/tvenc_conf.h
 create mode 100644 arch/arm/mach-mesong9tv/hw_enc_clk_config.h
 mode change 100644 => 100755 arch/arm/mach-mesong9tv/include/mach/io.h
 create mode 100644 drivers/amlogic/hdmi/hdmi_common/Makefile
 create mode 100644 drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/Makefile
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_cec_key.c
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_audio.c
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_cec.c
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_edid.c
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.c
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.h
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_scdc.c
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_video.c
 create mode 100644 include/linux/amlogic/hdmi_tx/hdmi_common.h
 mode change 100644 => 100755 include/linux/amlogic/hdmi_tx/hdmi_info_global.h
 create mode 100644 include/linux/amlogic/hdmi_tx/hdmi_tx_scdc.h

diff --git a/arch/arm/configs/mesong9tv_defconfig b/arch/arm/configs/mesong9tv_defconfig
index e8fe52d67add..5a2f5564a530 100755
--- a/arch/arm/configs/mesong9tv_defconfig
+++ b/arch/arm/configs/mesong9tv_defconfig
@@ -183,6 +183,7 @@ CONFIG_FB_OSD1_DEFAULT_HEIGHT_VIRTUAL=2160
 # CONFIG_AMLOGIC_BACKLIGHT is not set
 CONFIG_AM_GE2D=y
 CONFIG_AM_LOGO=y
+CONFIG_AML_HDMI_TX_20=y
 # CONFIG_AML_HDMI_TX is not set
 # CONFIG_AML_EXT_HDMIIN is not set
 CONFIG_AMLOGIC_IONVIDEO=y
diff --git a/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c
index 282ebca5e42c..27a9f0f29552 100755
--- a/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c
+++ b/arch/arm/mach-meson8/hdmi_tx_hw/hdmi_tx_cec_hw.c
@@ -34,6 +34,8 @@ void cec_enable_irq(void)
     hdmi_print(INF, CEC "enable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
 }
 
+void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag);
+
 void cec_hw_reset(void)
 {
     //unsigned long data32;
diff --git a/arch/arm/mach-mesong9tv/Makefile b/arch/arm/mach-mesong9tv/Makefile
index 80ca12415a1e..bc8bec1367b3 100755
--- a/arch/arm/mach-mesong9tv/Makefile
+++ b/arch/arm/mach-mesong9tv/Makefile
@@ -39,7 +39,7 @@ obj-$(CONFIG_MESON_SUSPEND)	+= power_suspend.o
 #endif
 obj-$(CONFIG_AMLOGIC_THERMAL) += thermal.o
 
-#obj-$(CONFIG_AML_HDMI_TX)	+=  hdmi_tx_hw/
+obj-$(CONFIG_AML_HDMI_TX_20)   +=  hdmi_tx_hw_20/
 
 # ARM Trustzone
 obj-$(CONFIG_MESON_TRUSTZONE)	+= meson-smc.o meson-secure.o
@@ -48,3 +48,4 @@ plus_sec			:= $(call as-instr,.arch_extension sec,+sec)
 AFLAGS_meson-smc.o		:= -Wa,-march=armv7-a$(plus_sec)
 endif
 
+obj-$(CONFIG_AM_TV_OUTPUT) += enc_clk_config.o
diff --git a/arch/arm/mach-mesong9tv/clock.c b/arch/arm/mach-mesong9tv/clock.c
index e31111cd45e7..c7acc66294b5 100644
--- a/arch/arm/mach-mesong9tv/clock.c
+++ b/arch/arm/mach-mesong9tv/clock.c
@@ -239,6 +239,7 @@ static  unsigned int clk_util_clk_msr(unsigned int clk_mux)
 
 int    clk_measure(char  index )
 {
+    unsigned int clk_mrs_result = 0;
     const char* clk_table[]={
     " CTS_AOCLK_INT(76)",
     " CTS_AOCLKx2_INT(75)",
@@ -324,12 +325,14 @@ int    clk_measure(char  index )
 	{
 	 	for(i = 0;i < len;i++)
 		{
-			printk("[%10d]%s\n",clk_util_clk_msr(i),clk_table[len-i]);
+            clk_mrs_result = clk_util_clk_msr(i);
+			printk("[%10d]%s\n", clk_mrs_result, clk_table[len-i]);
 		}
 		return 0;
 	}
-	printk("[%10d]%s\n",clk_util_clk_msr(index),clk_table[len-index]);
-	return 0;
+    clk_mrs_result = clk_util_clk_msr(index);
+	printk("[%10d]%s\n", clk_mrs_result ,clk_table[len-index]);
+	return clk_mrs_result;
 }
 
 long clk_round_rate_sys(struct clk *clk, unsigned long rate)
diff --git a/arch/arm/mach-mesong9tv/enc_clk_config.c b/arch/arm/mach-mesong9tv/enc_clk_config.c
new file mode 100644
index 000000000000..c4599710bc70
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/enc_clk_config.c
@@ -0,0 +1,687 @@
+/*
+ * arch/arm/mach-mesong9tv/enc_clk_config.c
+ *
+ * Copyright (C) 2014 Amlogic, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/cpu.h>
+
+#include <linux/clkdev.h>
+#include <linux/printk.h>
+#include <linux/delay.h>
+#include <plat/io.h>
+#include <plat/cpufreq.h>
+#include <mach/am_regs.h>
+#include <mach/clock.h>
+#include <mach/cpu.h>
+
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/enc_clk_config.h>
+#include "hw_enc_clk_config.h"
+
+static DEFINE_MUTEX(enc_clock_lock);
+
+#define check_clk_config(para)\
+    if (para == -1)\
+        return;
+
+#define check_div() \
+    if(div == -1)\
+        return ;\
+    switch(div){\
+        case 1:\
+            div = 0; break;\
+        case 2:\
+            div = 1; break;\
+        case 4:\
+            div = 2; break;\
+        case 6:\
+            div = 3; break;\
+        case 12:\
+            div = 4; break;\
+        default:\
+            break;\
+    }
+
+#define h_delay()       \
+    do {                \
+        int i = 1000;   \
+        while(i--);     \
+    }while(0)
+static void hpll_load_en(void);
+#define WAIT_FOR_PLL_LOCKED(reg)                        \
+    do {                                                \
+        unsigned int st = 0, cnt = 10;                  \
+        while(cnt --) {                                 \
+            aml_set_reg32_bits(reg, 0x5, 28, 3);        \
+            aml_set_reg32_bits(reg, 0x4, 28, 3);        \
+            hpll_load_en();                             \
+            msleep_interruptible(10);                   \
+            st = !!(aml_read_reg32(reg) & (1 << 31));   \
+            if(st) {                                    \
+                printk("hpll locked\n");                \
+                break;                                  \
+            }                                           \
+            else {  /* reset pll */                     \
+                printk("hpll reseting\n");              \
+            }                                           \
+        }                                               \
+        if(cnt < 9)                                     \
+            printk(KERN_CRIT "pll[0x%x] reset %d times\n", reg, 9 - cnt);\
+    }while(0);
+
+static void set_hpll_clk_out(unsigned clk)
+{
+    check_clk_config(clk);
+    printk("config HPLL\n");
+    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c88000);
+    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0xca563823);
+    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x40238100);
+    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012286);
+    aml_write_reg32(P_HHI_VID2_PLL_CNTL2, 0x430a800);       // internal LDO share with HPLL & VIID PLL
+    switch(clk){
+        case 2970:
+            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c84e00);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0xce49c822);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4123b100);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012385);
+
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000043d);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000043d);
+            printk("waiting HPLL lock\n");
+            while(!(aml_read_reg32(P_HHI_VID_PLL_CNTL) & (1 << 31))) {
+                ;
+            }
+            h_delay();
+            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00016385);   // optimise HPLL VCO 2.97GHz performance
+            break;
+        case 2160:
+            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6001042d);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001042d);
+            while(!(aml_read_reg32(P_HHI_VID_PLL_CNTL) & (1 << 31))) {
+                ;
+            }
+            break;
+        case 1488:
+            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8ce00);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000043d);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000043d);
+            while(!(aml_read_reg32(P_HHI_VID_PLL_CNTL) & (1 << 31))) {
+                ;
+            }
+            break;
+        case 1080:
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000042d);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000042d);
+            break;
+        case 1066:
+            WRITE_CBUS_REG(HHI_VID_PLL_CNTL, 0x42a);
+            break;
+        case 1058:
+            WRITE_CBUS_REG(HHI_VID_PLL_CNTL, 0x422);
+            break;
+        case 1086:
+            WRITE_CBUS_REG(HHI_VID_PLL_CNTL, 0x43e);
+            break;
+        case 1296:
+            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c88000);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0xca49b022);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0023b100);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012385);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x600c0436);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x400c0436);
+            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00016385);
+            break;
+        default:
+            printk("error hpll clk: %d\n", clk);
+            break;
+    }
+    if(clk < 2970)
+        aml_write_reg32(P_HHI_VID_PLL_CNTL5, (aml_read_reg32(P_HHI_VID_PLL_CNTL5) & (~(0xf << 12))) | (0x6 << 12));
+    printk("config HPLL done\n");
+}
+
+static void set_hpll_hdmi_od(unsigned div)
+{
+    check_clk_config(div);
+    switch(div){
+        case 1:
+            WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, 18, 2);
+            break;
+        case 2:
+            WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 1, 18, 2);
+            break;
+        case 3:
+            WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 1, 16, 2);
+            break;
+        case 4:
+            WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 3, 18, 2);
+            break;
+        case 8:
+            WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 1, 16, 2);
+            WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 3, 18, 2);
+            break;
+        default:
+            break;
+    }
+}
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+static void set_hpll_lvds_od(unsigned div)
+{
+    check_clk_config(div);
+    switch(div) {
+        case 1:
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 16, 2);
+            break;
+        case 2:
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 1, 16, 2);
+            break;
+        case 4:
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 2, 16, 2);
+            break;
+        case 8:     // note: need test
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 3, 16, 2);
+            break;
+        default:
+            break;
+    }
+}
+#endif
+
+// viu_channel_sel: 1 or 2
+// viu_type_sel: 0: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT.
+int set_viu_path(unsigned viu_channel_sel, viu_type_e viu_type_sel)
+{
+    if((viu_channel_sel > 2) || (viu_channel_sel == 0))
+        return -1;
+    printk("VPU_VIU_VENC_MUX_CTRL: 0x%x\n", aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL));
+    if(viu_channel_sel == 1){
+        aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, viu_type_sel, 0, 2);
+        printk("viu chan = 1\n");
+    }
+    else{
+        //viu_channel_sel ==2
+        aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, viu_type_sel, 2, 2);
+        printk("viu chan = 2\n");
+    }
+    printk("VPU_VIU_VENC_MUX_CTRL: 0x%x\n", aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL));
+    return 0;
+}
+
+static void set_vid_pll_div(unsigned div)
+{
+    check_clk_config(div);
+    // Gate disable
+    aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 0, 16, 1);
+    switch(div){
+        case 10:
+            aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 4, 4, 3);
+            aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 1, 8, 2);
+            aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 1, 12, 3);
+            break;
+        case 5:
+            aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 4, 4, 3);
+            aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 0, 8, 2);
+            aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 0, 12, 3);
+            break;
+        case 6:
+            aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 5, 4, 3);
+            aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 0, 8, 2);
+            aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 0, 12, 3);
+            break;
+        default:
+            break;
+    }
+    // Soft Reset div_post/div_pre
+    aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 0, 0, 2);
+    aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 1, 3, 1);
+    aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 1, 7, 1);
+    aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 3, 0, 2);
+    aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 0, 3, 1);
+    aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 0, 7, 1);
+    // Gate enable
+    aml_set_reg32_bits(P_HHI_VID_DIVIDER_CNTL, 1, 16, 1);
+}
+
+static void set_clk_final_div(unsigned div)
+{
+    check_clk_config(div);
+    if(div == 0)
+        div = 1;
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 1, 19, 1);
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 0, 16, 3);
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_DIV, div-1, 0, 8);
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 7, 0, 3);
+}
+
+static void set_hdmi_tx_pixel_div(unsigned div)
+{
+    check_div();
+    WRITE_CBUS_REG_BITS(HHI_HDMI_CLK_CNTL, div, 16, 4);
+}
+static void set_encp_div(unsigned div)
+{
+    check_div();
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_DIV, div, 24, 4);
+}
+
+static void set_enci_div(unsigned div)
+{
+    check_div();
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_DIV, div, 28, 4);
+}
+
+static void set_enct_div(unsigned div)
+{
+    check_div();
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_DIV, div, 20, 4);
+}
+
+static void set_encl_div(unsigned div)
+{
+    check_div();
+    WRITE_CBUS_REG_BITS(HHI_VIID_CLK_DIV, div, 12, 4);
+}
+
+static void set_vdac0_div(unsigned div)
+{
+    check_div();
+    WRITE_CBUS_REG_BITS(HHI_VIID_CLK_DIV, div, 28, 4);
+}
+
+static void set_vdac1_div(unsigned div)
+{
+    check_div();
+    WRITE_CBUS_REG_BITS(HHI_VIID_CLK_DIV, div, 24, 4);
+}
+
+// --------------------------------------------------
+//              clocks_set_vid_clk_div
+// --------------------------------------------------
+// wire            clk_final_en    = control[19];
+// wire            clk_div1        = control[18];
+// wire    [1:0]   clk_sel         = control[17:16];
+// wire            set_preset      = control[15];
+// wire    [14:0]  shift_preset    = control[14:0];
+extern void clocks_set_vid_clk_div(int div_sel);
+void clocks_set_vid_clk_div(int div_sel)
+{
+    int shift_val = 0;
+    int shift_sel = 0;
+
+    printk("%s[%d] div = %d\n", __func__, __LINE__, div_sel);
+    // Disable the output clock
+    aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 19, 1);
+    aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+
+    switch(div_sel) {
+    case CLK_UTIL_VID_PLL_DIV_1:      shift_val = 0xFFFF; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_2:      shift_val = 0x0aaa; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_3:      shift_val = 0x0db6; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_3p5:    shift_val = 0x36cc; shift_sel = 1; break;
+    case CLK_UTIL_VID_PLL_DIV_3p75:   shift_val = 0x6666; shift_sel = 2; break;
+    case CLK_UTIL_VID_PLL_DIV_4:      shift_val = 0x0ccc; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_5:      shift_val = 0x739c; shift_sel = 2; break;
+    case CLK_UTIL_VID_PLL_DIV_6:      shift_val = 0x0e38; shift_sel = 0; break;
+    case CLK_UTIL_VID_PLL_DIV_6p25:   shift_val = 0x0000; shift_sel = 3; break;
+    case CLK_UTIL_VID_PLL_DIV_7:      shift_val = 0x3c78; shift_sel = 1; break;
+    case CLK_UTIL_VID_PLL_DIV_7p5:    shift_val = 0x78f0; shift_sel = 2; break;
+    case CLK_UTIL_VID_PLL_DIV_12:     shift_val = 0x0fc0; shift_sel = 0; break; 
+    case CLK_UTIL_VID_PLL_DIV_14:     shift_val = 0x3f80; shift_sel = 1; break;
+    case CLK_UTIL_VID_PLL_DIV_15:     shift_val = 0x7f80; shift_sel = 2; break;
+    case CLK_UTIL_VID_PLL_DIV_2p5:    shift_val = 0x5294; shift_sel = 2; break;
+    default: 
+        printk("Error: clocks_set_vid_clk_div:  Invalid parameter\n");
+        break;
+    }
+
+    if(shift_val == 0xffff ) {      // if divide by 1
+        aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 18, 1);
+    } else {
+        aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 16, 2);
+        aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+        aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 0, 14);
+        
+        aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, shift_sel, 16, 2);
+        aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 15, 1);
+        aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, shift_val, 0, 14);
+        aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+    }
+    // Enable the final output clock
+    aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 19, 1);
+}
+
+static void hpll_load_initial(void)
+{
+//hdmi load initial
+    aml_write_reg32(P_HHI_VID_CLK_CNTL2, 0x2c);
+    aml_write_reg32(P_HHI_VID_CLK_DIV, 0x100);
+    aml_write_reg32(P_HHI_VIID_CLK_CNTL, 0x0);
+    aml_write_reg32(P_HHI_VIID_CLK_DIV, 0x101);
+    aml_write_reg32(P_HHI_VID_LOCK_CLK_CNTL, 0x80);
+
+//    aml_write_reg32(P_HHI_VPU_CLK_CNTL, 25);
+//    aml_set_reg32_bits(P_HHI_VPU_CLK_CNTL, 1, 8, 1);
+    aml_write_reg32(P_AO_RTI_GEN_PWR_SLEEP0, 0x0);
+    aml_write_reg32(P_HHI_HDMI_PLL_CNTL6, 0x100);
+
+    aml_write_reg32(P_VPU_CLK_GATE, 0xffff);
+    aml_write_reg32(P_ENCL_VIDEO_VSO_BLINE, 0x0);
+    aml_write_reg32(P_ENCL_VIDEO_VSO_BEGIN, 0x0);
+    aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 0x7);
+    aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
+    aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+}
+
+static void hpll_load_en(void)
+{
+//hdmi load gen
+    aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1);
+    aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 7, 0 , 3);
+    aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 16, 3);  // tmp use fclk_div4
+    aml_write_reg32(P_ENCL_VIDEO_EN, 0x1);
+//    msleep(20);
+    aml_write_reg32(P_ENCL_VIDEO_EN, 0x0);
+//    msleep(20);
+//    printk("read Addr: 0x%x[0x%x]  Data: 0x%x\n", P_HHI_HDMI_PLL_CNTL, (P_HHI_HDMI_PLL_CNTL & 0xffff) >> 2, aml_read_reg32(P_HHI_HDMI_PLL_CNTL));
+    aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 16, 3);  // use vid_pll
+}
+
+// mode hpll_clk_out hpll_hdmi_od viu_path viu_type vid_pll_div clk_final_div
+// hdmi_tx_pixel_div unsigned encp_div unsigned enci_div unsigned enct_div unsigned ecnl_div;
+static enc_clk_val_t setting_enc_clk_val[] = {
+		{VMODE_480I,       2160, 8, 1, 1, VIU_ENCI,  5, 4, 2,-1,  2, -1, -1,  2,  -1},
+		{VMODE_480I_RPT,   2160, 4, 1, 1, VIU_ENCI,  5, 4, 2,-1,  4, -1, -1,  2,  -1},
+		{VMODE_480CVBS,    1296, 4, 1, 1, VIU_ENCI,  6, 4, 2,-1,  2, -1, -1,  2,  -1},
+		{VMODE_480P,       2160, 8, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
+		{VMODE_480P_RPT,   2160, 2, 1, 1, VIU_ENCP,  5, 4, 1, 2, -1, -1, -1,  1,  -1},
+		{VMODE_576I,       2160, 8, 1, 1, VIU_ENCI,  5, 4, 2,-1,  2, -1, -1,  2,  -1},
+		{VMODE_576I_RPT,   2160, 4, 1, 1, VIU_ENCI,  5, 4, 2,-1,  4, -1, -1,  2,  -1},
+		{VMODE_576CVBS,    1296, 4, 1, 1, VIU_ENCI,  6, 4, 2,-1,  2, -1, -1,  2,  -1},
+		{VMODE_576P,       2160, 8, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
+		{VMODE_576P_RPT,   2160, 2, 1, 1, VIU_ENCP,  5, 4, 1, 2, -1, -1, -1,  1,  -1},
+		{VMODE_720P,       1488, 2, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+		{VMODE_1080I,      1488, 2, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+		{VMODE_1080P,      1488, 1, 1, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+		{VMODE_1080P,      1488, 1, 1, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+		{VMODE_720P_50HZ,  1488, 2, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+		{VMODE_1080I_50HZ, 1488, 2, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+		{VMODE_1080P_50HZ, 1488, 1, 1, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+		{VMODE_1080P_24HZ, 1488, 2, 1, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
+		{VMODE_4K2K_30HZ,  2970, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
+		{VMODE_4K2K_25HZ,  2970, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
+		{VMODE_4K2K_24HZ,  2970, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
+		{VMODE_4K2K_SMPTE, 2970, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
+		{VMODE_VGA,  1066, 3, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  1},
+		{VMODE_SVGA, 1058, 2, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  1},
+		{VMODE_XGA, 1085, 1, 1, 1, VIU_ENCP, 5, 1, 1, 1, -1, -1, -1,  1,  1},
+};
+
+#define MAX_CLK_INDEX   4
+#define MAX_SAME_CONF   (4 + 1)
+struct cts_mode_clk {
+    vmode_t mode[MAX_SAME_CONF];
+    struct {
+        unsigned int cts_idx;
+        unsigned char *name;
+        unsigned int target_clk;
+    }idx_clk[MAX_CLK_INDEX];
+};
+
+struct cts_mode_clk hdmitx_clk[] = {
+    {
+        .mode = {VMODE_1080P, VMODE_1080P_50HZ, VMODE_MAX},
+        .idx_clk[0] = {
+            .cts_idx = 55,
+            .name = "VID_PLL_DIV_CLK_OUT",
+            .target_clk = -1,//148000000,
+        },
+    },
+    {
+        .mode = {VMODE_4K2K_30HZ, VMODE_4K2K_25HZ, VMODE_4K2K_24HZ, VMODE_4K2K_SMPTE, VMODE_MAX},
+        .idx_clk[0] = {
+            .cts_idx = 55,
+            .name = "VID_PLL_DIV_CLK_OUT",
+            .target_clk = -1,//297000000 * 2,
+        },
+    },
+    {
+        .mode = {VMODE_4K2K_FAKE_5G, VMODE_4K2K_60HZ, VMODE_MAX},
+        .idx_clk[0] = {
+            .cts_idx = 55,
+            .name = "VID_PLL_DIV_CLK_OUT",
+            .target_clk = -1,//494000000,
+        },
+    },
+};
+/*
+ * Please refer to clock tree document to check related clocks
+ * 
+ */
+static unsigned int cts_clk_match(vmode_t mode)
+{
+    unsigned int i = 0, j = 0;
+    unsigned int clk_msr = 0;
+
+    for(i = 0; i < ARRAY_SIZE(hdmitx_clk); i ++) {
+        for(j = 0; j < MAX_SAME_CONF; j ++) {
+            if((mode == hdmitx_clk[i].mode[j]) && (hdmitx_clk[i].mode[j] != VMODE_MAX)) {
+                clk_msr = clk_measure(hdmitx_clk[i].idx_clk[0].cts_idx);
+                if(hdmitx_clk[i].idx_clk[0].target_clk == -1)
+                    return 1;   // not check
+                if(clk_msr == hdmitx_clk[i].idx_clk[0].target_clk) {
+                    return 1;
+                }
+                else {
+                    printk("mode: %d  %s(%d)  TargetClk: %d  !=  MsrClk: %d\n", mode, hdmitx_clk[i].idx_clk[0].name,
+                           hdmitx_clk[i].idx_clk[0].cts_idx, hdmitx_clk[i].idx_clk[0].target_clk, clk_msr);
+                    return 0;
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+#define MAX_CHK_TIMES   10
+static void cts_clk_check(vmode_t mode)
+{
+    unsigned int chk_times = 0;
+
+    while(chk_times < MAX_CHK_TIMES) {
+        msleep_interruptible(100);
+        if(cts_clk_match(mode))
+            return;
+        else {
+            chk_times ++;
+            WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+        }
+    }
+    if(chk_times == MAX_CHK_TIMES) {
+        printk("**************************************************\n");
+        printk("HDMI TX clock ABNORMAL STATE\n");
+        printk("**************************************************\n");
+    }
+}
+
+static int vmode_clk_match(vmode_t mode)
+{
+    unsigned int clk_msr = 0;
+
+return 0;
+    if(!(aml_read_reg32(P_HHI_HDMI_PLL_CNTL) & (1 << 31)))
+        return 0;
+    if((aml_read_reg32(P_HHI_HDMI_PLL_CNTL) & 0xfff) != 0x23d)
+        return 0;
+    if((mode == VMODE_4K2K_FAKE_5G) || (mode == VMODE_4K2K_5G))
+        return 0;
+
+    clk_msr = clk_measure(55);
+    switch(mode) {
+    case VMODE_720P:
+    case VMODE_1080I:
+    case VMODE_1080P:
+    case VMODE_720P_50HZ:
+    case VMODE_1080I_50HZ:
+    case VMODE_1080P_50HZ:
+    case VMODE_1080P_24HZ:
+    case VMODE_4K2K_30HZ:
+    case VMODE_4K2K_25HZ:
+    case VMODE_4K2K_24HZ:
+    case VMODE_4K2K_SMPTE:
+    case VMODE_4K2K_60HZ:
+        if(  (clk_msr == 148000000) || (clk_msr == 149000000)
+          || (clk_msr == 593000000) || (clk_msr == 594000000) || (clk_msr == 595000000)
+          || (clk_msr == 74000000) || (clk_msr == 73000000) || (clk_msr == 75000000))
+            return 1;
+        break;
+    default:
+        break;
+    }
+    return 0;
+}
+
+void set_vmode_clk(vmode_t mode)
+{
+    int i = 0;
+    int j = 0;
+    enc_clk_val_t *p_enc =NULL;
+
+    hpll_load_initial();
+printk("set_vmode_clk mode is %d\n", mode);
+
+	if( (VMODE_576CVBS==mode) || (VMODE_480CVBS==mode) )
+	{
+		printk("g9tv: cvbs clk!\n");
+		aml_write_reg32(P_HHI_HDMI_PLL_CNTL, 0x5000022d);
+	    aml_write_reg32(P_HHI_HDMI_PLL_CNTL2, 0x00890000);
+	    aml_write_reg32(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+	    aml_write_reg32(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+		// P_HHI_HDMI_PLL_CNTL5
+		// 0x71c86900 for div2 disable inside PLL2 of HPLL
+		// 0x71486900 for div2 enable inside PLL2 of HPLL
+	    aml_write_reg32(P_HHI_HDMI_PLL_CNTL5, 0x71c86900);
+	    aml_write_reg32(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+	    aml_write_reg32(P_HHI_HDMI_PLL_CNTL, 0x4000022d);
+
+	    WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+
+	    clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_5);
+
+		// select vid_pll_clk for muxing
+		aml_write_reg32(P_HHI_VID_CLK_CNTL, (aml_read_reg32(P_HHI_VID_CLK_CNTL)&(~(0x7<<16))) );
+		// disable divider for clk_rst_tst()
+		aml_write_reg32(P_HHI_VID_CLK_DIV, (aml_read_reg32(P_HHI_VID_CLK_DIV)&(~0xff)) );
+		// select clk_div1 for enci clk muxing
+		aml_write_reg32(P_HHI_VID_CLK_DIV, (aml_read_reg32(P_HHI_VID_CLK_DIV)&(~(0xf<<28))) );
+		// select clk_div1 for vdac clk muxing
+		aml_write_reg32(P_HHI_VIID_CLK_DIV, (aml_read_reg32(P_HHI_VIID_CLK_DIV)&(~(0x1<<19))) );
+		aml_write_reg32(P_HHI_VIID_CLK_DIV, (aml_read_reg32(P_HHI_VIID_CLK_DIV)&(~(0xf<<28))) );
+		// clk gate for enci(bit0) and vdac(bit4)
+		aml_write_reg32(P_HHI_VID_CLK_CNTL2, (aml_read_reg32(P_HHI_VID_CLK_CNTL2)|0x1|(0x1<<4)) );
+
+		return;
+	}
+
+    if(!vmode_clk_match(mode)) {
+        printk("%s[%d] reset hdmi hpll\n", __func__, __LINE__);
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL, 0x5000023d);
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL2, 0x00454e00);
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL5, 0x71486900);    //5940 0x71c86900      // 0x71486900 2970
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL, 0x4000023d);
+
+        WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+    }
+    aml_write_reg32(P_HHI_HDMI_CLK_CNTL, 0x100);
+
+    switch(mode) {
+    case VMODE_1080P:
+    case VMODE_1080P_50HZ:
+        aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2, 0x44, 16, 8);
+        break;
+    case VMODE_4K2K_30HZ:
+    case VMODE_4K2K_25HZ:
+    case VMODE_4K2K_24HZ:
+    case VMODE_4K2K_SMPTE:
+        aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2, 0, 16, 8);
+        aml_set_reg32_bits(P_HHI_VID_CLK_DIV, 1, 0, 8);
+        break;
+    case VMODE_4K2K_60HZ:
+        aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2, 0, 16, 8);
+        aml_set_reg32_bits(P_HHI_VID_CLK_DIV, 0, 0, 8);
+        break;
+    case VMODE_4K2K_FAKE_5G:
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL, 0x50000266);
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL, 0x40000266);
+        WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+        aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2, 0x40, 16, 8);
+        aml_set_reg32_bits(P_HHI_VID_CLK_DIV, 0, 0, 8);
+        break;
+    case VMODE_4K2K_5G:
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL, 0x50000266);
+        aml_write_reg32(P_HHI_HDMI_PLL_CNTL, 0x40000266);
+        WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+        aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2, 0x44, 16, 8);
+        aml_set_reg32_bits(P_HHI_VID_CLK_DIV, 1, 0, 8);
+        break;
+    default:
+        break;
+    }
+    clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_5);
+    cts_clk_check(mode);
+return;
+
+    p_enc=&setting_enc_clk_val[0];
+    i = sizeof(setting_enc_clk_val) / sizeof(enc_clk_val_t);
+
+    printk("mode is: %d\n", mode);
+    for (j = 0; j < i; j++){
+        if(mode == p_enc[j].mode)
+            break;
+    }
+    set_viu_path(p_enc[j].viu_path, p_enc[j].viu_type);
+    set_hpll_clk_out(p_enc[j].hpll_clk_out);
+    set_hpll_lvds_od(p_enc[j].hpll_lvds_od);
+    set_hpll_hdmi_od(p_enc[j].hpll_hdmi_od);
+    set_vid_pll_div(p_enc[j].vid_pll_div);
+    set_clk_final_div(p_enc[j].clk_final_div);
+    set_hdmi_tx_pixel_div(p_enc[j].hdmi_tx_pixel_div);
+    set_encp_div(p_enc[j].encp_div);
+    set_enci_div(p_enc[j].enci_div);
+    set_enct_div(p_enc[j].enct_div);
+    set_encl_div(p_enc[j].encl_div);
+    set_vdac0_div(p_enc[j].vdac0_div);
+    set_vdac1_div(p_enc[j].vdac1_div);
+
+}
+ 
diff --git a/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/Makefile b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/Makefile
new file mode 100644
index 000000000000..64b17e5a7a9d
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/Makefile
@@ -0,0 +1 @@
+obj-y		+= hdmi_tx_hw.o hdmi_tx_reg.o hdmi_tx_cec_hw.o
diff --git a/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_cec_hw.c b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_cec_hw.c
new file mode 100644
index 000000000000..5534a4b71633
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_cec_hw.c
@@ -0,0 +1,1014 @@
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/cdev.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+#include "hdmi_tx_reg.h"
+//#include "mach/hdmi_parameter.h" 
+
+static DEFINE_MUTEX(cec_mutex);
+
+unsigned int cec_irq_enable_flag = 1;
+extern bool cec_msg_dbg_en;
+
+static unsigned char msg_log_buf[128] = { 0 };
+static int pos;
+//There are two cec modules:AO CEC & HDMI CEC2.0
+
+#ifdef AO_CEC
+//*****************************************************AOCEC*************************************************
+static void ao_cec_disable_irq(void)
+{
+    // disable all AO_CEC interrupt sources
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 0, 3);
+    cec_irq_enable_flag = 0;
+    hdmi_print(INF, CEC "disable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
+}
+
+static void ao_cec_enable_irq(void)
+{
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
+    cec_irq_enable_flag = 1;
+    hdmi_print(INF, CEC "enable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
+}
+
+static void ao_cec_clk_set(void)
+{
+    //AO CEC clock = 24M/732=32786.9Hz
+    //unsigned long data32;
+    
+    //data32  = 0;
+	//data32 |= 1         << (10+16);  // [26]  clk_en
+	//data32 |= (732 - 1) << (0+16);   // [25:16] clk_div
+    //*P_AO_CRT_CLK_CNTL1 =  data32;
+    aml_set_reg32_bits(P_AO_CRT_CLK_CNTL1, 0, 16, 10);
+    aml_set_reg32_bits(P_AO_CRT_CLK_CNTL1, 1, 26, 1);
+    //aocec_wr_reg(CEC_CLOCK_DIV_L,                   (240-1)&0xff);
+    //aocec_wr_reg(CEC_CLOCK_DIV_H,                   ((240-1)>>8)&0xff);
+}
+
+static void ao_cec_sw_reset(void)
+{
+    // Assert SW reset AO_CEC
+    //data32  = 0;
+    //data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
+    //data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
+    aml_write_reg32(P_AO_CEC_GEN_CNTL, 0x1);
+    // Enable gated clock (Normal mode).
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
+    // Release SW reset
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
+}
+
+static void ao_cec_logic_addr_set(enum _cec_log_dev_addr_e logic_addr)
+{
+    //tmp debug:set addr 4 for G9TV CEC. To do.
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0x4);
+}
+/*
+static void ao_cec_arbit_bit_time_read(void){//11bit:bit[10:0]
+    //3 bit
+    hdmi_print(INF, CEC "read 3 bit:0x%x%x \n", aocec_rd_reg(CEC_TXTIME_4BIT_BIT15_8),aocec_rd_reg(CEC_TXTIME_4BIT_BIT7_0));
+    //5 bit
+    hdmi_print(INF, CEC "read 5 bit:0x%x%x \n", aocec_rd_reg(CEC_TXTIME_2BIT_BIT15_8), aocec_rd_reg(CEC_TXTIME_2BIT_BIT7_0));
+    //7 bit
+    hdmi_print(INF, CEC "read 7 bit:0x%x%x \n", aocec_rd_reg(CEC_TXTIME_17MS_BIT15_8), aocec_rd_reg(CEC_TXTIME_17MS_BIT7_0));
+}
+
+static void ao_cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag){//11bit:bit[10:0]
+    if(flag)
+        hdmi_print(INF, CEC "bit_set:0x%x;time_set:0x%x \n", bit_set, time_set);
+    switch(bit_set){
+    case 3:
+        //3 bit
+        if(flag)
+            hdmi_print(INF, CEC "read 3 bit:0x%x%x \n", aocec_rd_reg(CEC_TXTIME_4BIT_BIT15_8),aocec_rd_reg(CEC_TXTIME_4BIT_BIT7_0));
+        aocec_wr_reg(CEC_TXTIME_4BIT_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(CEC_TXTIME_4BIT_BIT15_8, (time_set >> 8) & 0x7);
+        if(flag)
+            hdmi_print(INF, CEC "write 3 bit:0x%x%x \n", aocec_rd_reg(CEC_TXTIME_4BIT_BIT15_8),aocec_rd_reg(CEC_TXTIME_4BIT_BIT7_0));
+        break;
+        //5 bit
+    case 5:
+        if(flag)
+            hdmi_print(INF, CEC "read 5 bit:0x%x%x \n", aocec_rd_reg(CEC_TXTIME_2BIT_BIT15_8), aocec_rd_reg(CEC_TXTIME_2BIT_BIT7_0));
+        aocec_wr_reg(CEC_TXTIME_2BIT_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(CEC_TXTIME_2BIT_BIT15_8, (time_set >> 8) & 0x7);
+        if(flag)
+            hdmi_print(INF, CEC "write 5 bit:0x%x%x \n", aocec_rd_reg(CEC_TXTIME_2BIT_BIT15_8), aocec_rd_reg(CEC_TXTIME_2BIT_BIT7_0));
+        break;
+        //7 bit
+	case 7:
+        if(flag)
+            hdmi_print(INF, CEC "read 7 bit:0x%x%x \n", aocec_rd_reg(CEC_TXTIME_17MS_BIT15_8), aocec_rd_reg(CEC_TXTIME_17MS_BIT7_0));
+        aocec_wr_reg(CEC_TXTIME_17MS_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(CEC_TXTIME_17MS_BIT15_8, (time_set >> 8) & 0x7);
+        if(flag)
+            hdmi_print(INF, CEC "write 7 bit:0x%x%x \n", aocec_rd_reg(CEC_TXTIME_17MS_BIT15_8), aocec_rd_reg(CEC_TXTIME_17MS_BIT7_0));
+        break;
+    default:
+        break;
+    }
+}
+*/
+
+static void ao_cec_timing_set(void)
+{
+    //Cec arbitration 3/5/7 bit time set.
+    //ao_cec_arbit_bit_time_set(3, 0x118, 0);
+    //ao_cec_arbit_bit_time_set(5, 0x000, 0);
+    //ao_cec_arbit_bit_time_set(7, 0x2aa, 0);
+    
+    // Program AO CEC's timing parameters to work with 24MHz cec_clk 
+    aocec_wr_reg(CEC_CLOCK_DIV_L,                   (240-1)&0xff);
+    aocec_wr_reg(CEC_CLOCK_DIV_H,                   ((240-1)>>8)&0xff);
+    aocec_wr_reg(CEC_QUIESCENT_25MS_BIT7_0,         0xC4);  // addr=0x20
+    aocec_wr_reg(CEC_QUIESCENT_25MS_BIT11_8,        0x09);  // addr=0x21
+    aocec_wr_reg(CEC_STARTBITMINL2H_3MS5_BIT7_0,    0x5E);  // addr=0x22
+    aocec_wr_reg(CEC_STARTBITMINL2H_3MS5_BIT8,      0x01);  // addr=0x23
+    aocec_wr_reg(CEC_STARTBITMAXL2H_3MS9_BIT7_0,    0x86);  // addr=0x24
+    aocec_wr_reg(CEC_STARTBITMAXL2H_3MS9_BIT8,      0x01);  // addr=0x25
+    aocec_wr_reg(CEC_STARTBITMINH_0MS6_BIT7_0,      0x3C);  // addr=0x26
+    aocec_wr_reg(CEC_STARTBITMINH_0MS6_BIT8,        0x00);  // addr=0x27
+    aocec_wr_reg(CEC_STARTBITMAXH_1MS0_BIT7_0,      0x64);  // addr=0x28
+    aocec_wr_reg(CEC_STARTBITMAXH_1MS0_BIT8,        0x00);  // addr=0x29
+    aocec_wr_reg(CEC_STARTBITMINTOTAL_4MS3_BIT7_0,  0xAE);  // addr=0x2A
+    aocec_wr_reg(CEC_STARTBITMINTOTAL_4MS3_BIT9_8,  0x01);  // addr=0x2B
+    aocec_wr_reg(CEC_STARTBITMAXTOTAL_4MS7_BIT7_0,  0xD6);  // addr=0x2C
+    aocec_wr_reg(CEC_STARTBITMAXTOTAL_4MS7_BIT9_8,  0x01);  // addr=0x2D
+    aocec_wr_reg(CEC_LOGIC1MINL2H_0MS4_BIT7_0,      0x28);  // addr=0x2E
+    aocec_wr_reg(CEC_LOGIC1MINL2H_0MS4_BIT8,        0x00);  // addr=0x2F
+    aocec_wr_reg(CEC_LOGIC1MAXL2H_0MS8_BIT7_0,      0x50);  // addr=0x30
+    aocec_wr_reg(CEC_LOGIC1MAXL2H_0MS8_BIT8,        0x00);  // addr=0x31
+    aocec_wr_reg(CEC_LOGIC0MINL2H_1MS3_BIT7_0,      0x82);  // addr=0x32
+    aocec_wr_reg(CEC_LOGIC0MINL2H_1MS3_BIT8,        0x00);  // addr=0x33
+    aocec_wr_reg(CEC_LOGIC0MAXL2H_1MS7_BIT7_0,      0xAA);  // addr=0x34
+    aocec_wr_reg(CEC_LOGIC0MAXL2H_1MS7_BIT8,        0x00);  // addr=0x35
+    aocec_wr_reg(CEC_LOGICMINTOTAL_2MS05_BIT7_0,    0xCD);  // addr=0x36
+    aocec_wr_reg(CEC_LOGICMINTOTAL_2MS05_BIT9_8,    0x00);  // addr=0x37
+    aocec_wr_reg(CEC_LOGICMAXHIGH_2MS8_BIT7_0,      0x18);  // addr=0x38
+    aocec_wr_reg(CEC_LOGICMAXHIGH_2MS8_BIT8,        0x01);  // addr=0x39
+    aocec_wr_reg(CEC_LOGICERRLOW_3MS4_BIT7_0,       0x54);  // addr=0x3A
+    aocec_wr_reg(CEC_LOGICERRLOW_3MS4_BIT8,         0x01);  // addr=0x3B
+    aocec_wr_reg(CEC_NOMSMPPOINT_1MS05,             0x69);  // addr=0x3C
+    aocec_wr_reg(CEC_DELCNTR_LOGICERR,              0x35);  // addr=0x3E
+    aocec_wr_reg(CEC_TXTIME_17MS_BIT7_0,            0xA4);  // addr=0x40
+    aocec_wr_reg(CEC_TXTIME_17MS_BIT15_8,           0x06);  // addr=0x41
+    aocec_wr_reg(CEC_TXTIME_2BIT_BIT7_0,            0xF0);  // addr=0x42
+    aocec_wr_reg(CEC_TXTIME_2BIT_BIT15_8,           0x01);  // addr=0x43
+    aocec_wr_reg(CEC_TXTIME_4BIT_BIT7_0,            0xD0);  // addr=0x44
+    aocec_wr_reg(CEC_TXTIME_4BIT_BIT15_8,           0x03);  // addr=0x45
+    aocec_wr_reg(CEC_STARTBITNOML2H_3MS7_BIT7_0,    0x72);  // addr=0x46
+    aocec_wr_reg(CEC_STARTBITNOML2H_3MS7_BIT8,      0x01);  // addr=0x47
+    aocec_wr_reg(CEC_STARTBITNOMH_0MS8_BIT7_0,      0x50);  // addr=0x48
+    aocec_wr_reg(CEC_STARTBITNOMH_0MS8_BIT8,        0x00);  // addr=0x49
+    aocec_wr_reg(CEC_LOGIC1NOML2H_0MS6_BIT7_0,      0x3C);  // addr=0x4A
+    aocec_wr_reg(CEC_LOGIC1NOML2H_0MS6_BIT8,        0x00);  // addr=0x4B
+    aocec_wr_reg(CEC_LOGIC0NOML2H_1MS5_BIT7_0,      0x96);  // addr=0x4C
+    aocec_wr_reg(CEC_LOGIC0NOML2H_1MS5_BIT8,        0x00);  // addr=0x4D
+    aocec_wr_reg(CEC_LOGIC1NOMH_1MS8_BIT7_0,        0xB4);  // addr=0x4E
+    aocec_wr_reg(CEC_LOGIC1NOMH_1MS8_BIT8,          0x00);  // addr=0x4F
+    aocec_wr_reg(CEC_LOGIC0NOMH_0MS9_BIT7_0,        0x5A);  // addr=0x50
+    aocec_wr_reg(CEC_LOGIC0NOMH_0MS9_BIT8,          0x00);  // addr=0x51
+    aocec_wr_reg(CEC_LOGICERRLOW_3MS6_BIT7_0,       0x68);  // addr=0x52
+    aocec_wr_reg(CEC_LOGICERRLOW_3MS6_BIT8,         0x01);  // addr=0x53
+    aocec_wr_reg(CEC_CHKCONTENTION_0MS1,            0x0A);  // addr=0x54
+    aocec_wr_reg(CEC_PREPARENXTBIT_0MS05_BIT7_0,    0x05);  // addr=0x56
+    aocec_wr_reg(CEC_PREPARENXTBIT_0MS05_BIT8,      0x00);  // addr=0x57
+    aocec_wr_reg(CEC_NOMSMPACKPOINT_0MS45,          0x2D);  // addr=0x58
+    aocec_wr_reg(CEC_ACK0NOML2H_1MS5_BIT7_0,        0x96);  // addr=0x5A
+    aocec_wr_reg(CEC_ACK0NOML2H_1MS5_BIT8,          0x00);  // addr=0x5B
+}
+
+static void ao_cec_set(void)
+{
+    //to do
+}
+
+static void ao_cec_hw_reset(void)
+{ 
+    //init ao cec clk
+    //ao_cec_clk_set();
+    
+    //ao cec software reset
+    ao_cec_sw_reset();
+    
+    ao_cec_timing_set();
+        
+    // Enable all AO_CEC interrupt sources
+    if(!cec_irq_enable_flag)
+        cec_enable_irq();
+
+    cec_logic_addr_set(CEC_PLAYBACK_DEVICE_1_ADDR);
+}
+
+static int ao_cec_ll_rx( unsigned char *msg, unsigned char *len)
+{
+    unsigned char i;
+    unsigned char data;
+
+    unsigned char n;
+    unsigned char *msg_start = msg;
+	unsigned int num;
+    int rx_msg_length;
+    int rx_status;
+	
+	rx_status = aocec_rd_reg(CEC_RX_MSG_STATUS);
+	num = aocec_rd_reg(CEC_RX_NUM_MSG);
+	
+	printk("rx irq:rx_status:0x%x:: num :0x%x\n", rx_status, num);
+	//aml_set_reg32_bits(P_AO_CEC_INTR_CLR, 1, 2, 1);
+    if(RX_DONE != rx_status){
+		printk("rx irq:!!!RX_DONE\n");
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
+        return -1;
+    }
+    if(1 != num){
+		printk("rx irq:!!!num\n");
+        //aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        //aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
+		aocec_wr_reg(CEC_RX_CLEAR_BUF, 1);
+		aml_set_reg32_bits(P_AO_CEC_INTR_CLR, 1, 2, 1);
+        return -1;
+    }
+    rx_msg_length = aocec_rd_reg(CEC_RX_MSG_LENGTH) + 1;
+
+    aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+
+    for (i = 0; i < rx_msg_length && i < MAX_MSG; i++) {
+        data = aocec_rd_reg(CEC_RX_MSG_0_HEADER +i);
+        *msg = data;
+        msg++;
+    }
+    *len = rx_msg_length;
+    rx_status = aocec_rd_reg(CEC_RX_MSG_STATUS);
+
+    aocec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+    //aocec_wr_reg(CEC_RX_CLEAR_BUF, 1);
+    aml_set_reg32_bits(P_AO_CEC_INTR_CLR, 1, 2, 1);
+	cec_hw_reset();
+
+    if(cec_msg_dbg_en  == 1){
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: rx msg len: %d   dat: ", rx_msg_length);
+        for(n = 0; n < rx_msg_length; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg_start[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+        msg_log_buf[pos] = '\0';
+        hdmi_print(INF, CEC "%s", msg_log_buf);
+    }
+    return rx_status;
+}
+
+static int ao_cec_rx_irq_handle(unsigned char *msg, unsigned char *len)
+{
+    //to do
+    return ao_cec_ll_rx(msg, len);
+}
+
+static unsigned int ao_cec_intr_stat(void)
+{
+    return aml_read_reg32(P_AO_CEC_INTR_STAT);
+}
+
+// return value: 1: successful      0: error
+static int ao_cec_ll_tx(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 0xf;
+    unsigned int n;
+    unsigned int cnt = 30;
+
+    while(aocec_rd_reg(CEC_TX_MSG_STATUS)){
+        msleep(5);
+        if(TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS)){
+            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            //cec_hw_reset();
+            break;
+        }
+        if(!(cnt--)){
+            hdmi_print(INF, CEC "tx busy time out.\n");
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            break;
+        }
+    }
+
+    for (i = 0; i < len; i++)
+    {
+        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
+
+    if(cec_msg_dbg_en  == 1) {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for(n = 0; n < len; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+
+        msg_log_buf[pos] = '\0';
+        printk("%s", msg_log_buf);
+    }
+    return ret;
+}
+
+static int ao_cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 0xf;
+    unsigned int n;
+	unsigned int j = 30;
+
+    while( aocec_rd_reg(CEC_TX_MSG_STATUS)){
+        if(TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS)){
+            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            //cec_hw_reset();
+            break;
+        }
+        if(!(j--)){
+            hdmi_print(INF, CEC "tx busy time out.\n");
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            break;
+        }
+        msleep(5);
+    }
+
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 1, 1);
+    for (i = 0; i < len; i++)
+    {
+        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
+
+    j = 30;
+    while((TX_DONE != aocec_rd_reg(CEC_TX_MSG_STATUS)) && (j--)){
+        if(TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS))
+            break;
+		msleep(5);
+	}
+
+    ret = aocec_rd_reg(CEC_TX_MSG_STATUS);
+
+    if(ret == TX_DONE)
+        ret = 1;
+    else
+        ret = 0;
+    aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 1, 1, 1);
+    
+    msleep(100);
+    if(cec_msg_dbg_en  == 1) {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for(n = 0; n < len; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\nCEC: tx state: %d\n", ret);
+        msg_log_buf[pos] = '\0';
+        printk("%s", msg_log_buf);
+    }
+    return ret;
+}
+
+static void ao_cec_tx_irq_handle(void)
+{
+    unsigned tx_status = aocec_rd_reg(CEC_TX_MSG_STATUS);
+    printk("tx_status:0x%x\n", tx_status);
+    switch(tx_status){
+    case TX_DONE:
+      aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+      break;
+    case TX_BUSY:
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        break;
+    case TX_ERROR:
+        cec_hw_reset();
+        //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+        //aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        break;
+    default:
+        break;
+    }
+    aml_set_reg32_bits(P_AO_CEC_INTR_CLR, 1, 1, 1);
+}
+
+static void ao_cec_polling_online_dev(int log_addr, int *bool)
+{
+    unsigned long r;
+    unsigned char msg[1];
+
+    cec_global_info.my_node_index = log_addr;
+    msg[0] = (log_addr<<4) | log_addr;
+
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0x4);
+    hdmi_print(INF, CEC "CEC_LOGICAL_ADDR0:0x%lx\n",aocec_rd_reg(CEC_LOGICAL_ADDR0));
+    r = cec_ll_tx_polling(msg, 1);
+    cec_hw_reset();
+
+    if (r == 0) {
+        *bool = 0;
+    }else{
+        memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
+        cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
+    	  *bool = 1;
+    }
+    if(*bool == 0) {
+        aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
+    }
+
+}
+
+#else
+//****************************************************HDMI CEC2.0**************************************************
+static void hdmi_cec_disable_irq(void)
+{
+    //to do
+    // Configure HDMI CEC2.0 interrupts
+    //data32  = 0;
+    //data32 |= (0    << 6);  // [  6] wakeup
+    //data32 |= (0    << 5);  // [  5] error_follower
+    //data32 |= (0    << 4);  // [  4] error_initiator
+    //data32 |= (0    << 3);  // [  3] arb_lost
+    //data32 |= (0    << 2);  // [  2] nack
+    //data32 |= (0    << 1);  // [  1] eom
+    //data32 |= (0    << 0);  // [  0] done
+    //hdmitx_wr_reg(HDMITX_DWC_CEC_INTR_MASK, 0);
+    cec_irq_enable_flag = 0;
+    //hdmi_print(INF, CEC "disable:int mask:0x%x\n", hdmitx_rd_reg(HDMITX_DWC_CEC_INTR_MASK));
+}
+
+static void hdmi_cec_enable_irq(void)
+{
+    cec_irq_enable_flag = 1;
+    //hdmi_print(INF, CEC "enable:int mask:0x%x\n", hdmitx_rd_reg(HDMITX_DWC_CEC_INTR_MASK));
+}
+
+static void hdmi_cec_clk_set(void)
+{
+    //HDMI IP CEC clock = 24M/732=32786.9Hz
+    //unsigned long data32;
+    //data32  = 0;
+    //data32 |= 0         << 16;  // [17:16] clk_sel: 0=oscin; 1=slow_oscin; 2=fclk_div3; 3=fclk_div5.
+    //data32 |= 1         << 15;  // [   15] clk_en
+    //data32 |= (732-1)   << 0;   // [13: 0] clk_div 
+    aml_set_reg32_bits(P_HHI_32K_CLK_CNTL, 1, 15, 1);
+    aml_set_reg32_bits(P_HHI_32K_CLK_CNTL, 0, 16, 2);
+    aml_set_reg32_bits(P_HHI_32K_CLK_CNTL, (732 - 1), 0, 14);
+}
+
+static void hdmi_cec_sw_reset(void)
+{
+    //to do
+}
+
+static void hdmi_cec_logic_addr_set(enum _cec_log_dev_addr_e logic_addr)
+{
+    //tmp debug:set addr 4 for G9TV CEC. To do.
+    hdmitx_wr_reg(HDMITX_DWC_CEC_LADD_LOW, (1<<4));
+    hdmitx_wr_reg(HDMITX_DWC_CEC_LADD_HIGH, 0);
+}
+
+static void hdmi_cec_timing_set(void)
+{
+    //to do
+}
+/*
+static void hdmi_cec_ctrl(void)
+{
+    //to do;
+    //HDMITX_DWC_CEC_CTRL
+    hdmitx_wr_reg(HDMITX_DWC_CEC_CTRL, hdmitx_rd_reg(HDMITX_DWC_CEC_CTRL) | 0x1);
+}
+
+
+static void hdmi_cec_mask(void)
+{
+    //to do;
+    //HDMITX_DWC_CEC_INTR_MASK
+}
+
+static int hdmi_cec_lock(cec_rw_e flag, int value)
+{
+    int ret;
+    switch(flag)
+    {
+    case CEC_READ:
+        ret = hdmitx_rd_reg(HDMITX_DWC_CEC_LOCK_BUF);
+        break;
+    case CEC_WRITE:
+        hdmitx_wr_reg(HDMITX_DWC_CEC_LOCK_BUF, value);
+        ret = hdmitx_rd_reg(HDMITX_DWC_CEC_LOCK_BUF);
+        break;
+    default:
+        ret = hdmitx_rd_reg(HDMITX_DWC_CEC_LOCK_BUF);
+        break;
+    }
+    return ret;
+}
+static void _hdmi_clean_buf_(unsigned int offset)
+{
+    int i;
+    if(!offset)
+        return;
+    for(i = 0; i < MAX_MSG; i++)
+    {
+        hdmitx_wr_reg(offset +i, 0);
+    }
+}
+
+static void hdmi_clean_buf(cec_rw_e flag)
+{
+    unsigned int offset;
+    switch(flag)
+    {
+    case CEC_READ:
+        offset = HDMITX_DWC_CEC_RX_DATA00;
+        break;
+    case CEC_WRITE:
+        offset = HDMITX_DWC_CEC_TX_DATA00; 
+        break;
+    default:
+        break;
+    }
+   _hdmi_clean_buf_(offset);
+}
+
+*/
+static void hdmi_cec_set(void)
+{
+    unsigned long data32;
+    // Configure CEC interrupts
+    data32  = 0;
+    data32 |= (0    << 6);  // [  6] wakeup
+    data32 |= (0    << 5);  // [  5] error_follower
+    data32 |= (0    << 4);  // [  4] error_initiator
+    data32 |= (0    << 3);  // [  3] arb_lost
+    data32 |= (0    << 2);  // [  2] nack
+    data32 |= (0    << 1);  // [  1] eom
+    data32 |= (0    << 0);  // [  0] done
+    hdmitx_wr_reg(HDMITX_DWC_CEC_INTR_MASK,  data32);
+    
+    data32  = 0;
+    data32 |= (0    << 6);  // [  6] wakeup
+    data32 |= (0    << 5);  // [  5] error_follower
+    data32 |= (0    << 4);  // [  4] error_initiator
+    data32 |= (0    << 3);  // [  3] arb_lost
+    data32 |= (0    << 2);  // [  2] nack
+    data32 |= (0    << 1);  // [  1] eom
+    data32 |= (0    << 0);  // [  0] done
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_CEC_STAT0,  data32);
+
+    data32  = 0;
+    data32 |= (0    << 1);  // [  1] mute_wakeup_interrupt
+    data32 |= (0    << 0);  // [  0] mute_all_interrupt
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE,    data32);
+
+    data32  = 0;
+    data32 |= (1    << 2);  // [  2] hpd_fall_intr
+    data32 |= (1    << 1);  // [  1] hpd_rise_intr
+    data32 |= (1    << 0);  // [  0] core_intr
+    hdmitx_wr_reg(HDMITX_TOP_INTR_MASKN, data32);
+
+    // Mute all interrupts except CEC related
+    //hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT0,      0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT1,      0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT2,      0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_AS_STAT0,      0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_PHY_STAT0,     0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_I2CM_STAT0,    0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_VP_STAT0,      0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0, 0xff);
+
+    // Clear all interrupts
+    //hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT0,       0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT1,       0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT2,       0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_AS_STAT0,       0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_PHY_STAT0,      0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_I2CM_STAT0,     0xff);
+    hdmitx_wr_reg(HDMITX_DWC_IH_CEC_STAT0,      0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_VP_STAT0,       0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_IH_I2CMPHY_STAT0,  0xff);
+    //hdmitx_wr_reg(HDMITX_DWC_A_APIINTCLR,       0xff);
+    // [2]      hpd_fall
+    // [1]      hpd_rise
+    // [0]      core_intr_rise
+    hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR, 0x00000007);
+}
+
+static void hdmi_cec_hw_reset(void)
+{ 
+    
+    // Enable HDMI IP CEC2.0 interrupt sources
+    if(!cec_irq_enable_flag)
+        cec_enable_irq();
+
+    //cec_logic_addr_set(CEC_PLAYBACK_DEVICE_1_ADDR);
+}
+
+static int hdmi_cec_ll_rx( unsigned char *msg, unsigned char *len)
+{
+    unsigned char i;
+    unsigned char data;
+    unsigned char n;
+    unsigned char *msg_start = msg;
+    int rx_status = 1;
+    int rx_msg_length;
+
+    // Check received message
+    
+    hdmitx_wr_reg(HDMITX_DWC_CEC_LOCK_BUF, 1);
+    rx_msg_length = aocec_rd_reg(HDMITX_DWC_CEC_RX_CNT);
+    
+    for (i = 0; i < rx_msg_length && i < MAX_MSG; i++) {
+        data = hdmitx_rd_reg(HDMITX_DWC_CEC_RX_DATA00+i);
+        *msg = data;
+        msg++;
+    }
+    
+    hdmitx_wr_reg(HDMITX_DWC_CEC_LOCK_BUF, 0);
+
+    //if(cec_lock(CEC_READ, 0))
+    //    cec_lock(CEC_WRITE, 0);
+    //
+    //clean_buf(CEC_READ);
+    
+    if(cec_msg_dbg_en  == 1)
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: rx msg len: %d   dat: ", rx_msg_length);
+        for(n = 0; n < rx_msg_length; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg_start[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+        msg_log_buf[pos] = '\0';
+        hdmi_print(INF, CEC "%s", msg_log_buf);
+
+    return rx_status;
+}
+
+static int hdmi_cec_rx_irq_handle(unsigned char *msg, unsigned char *len)
+{
+    unsigned long data32;
+    int ret;
+    int int_stat_main;
+    int int_stat;
+    
+    ret = 0;
+    data32  = hdmitx_rd_reg(HDMITX_TOP_INTR_STAT);
+    hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR, data32);    // clear interrupts in HDMITX_TOP module
+    
+    if (data32 & (1 << 0))
+    {  // core_intr
+        int_stat_main = hdmitx_rd_reg(HDMITX_DWC_IH_DECODE);
+        if (int_stat_main)
+        {
+            int_stat = hdmitx_rd_reg(HDMITX_DWC_IH_CEC_STAT0);
+            hdmitx_wr_reg(HDMITX_DWC_IH_CEC_STAT0, int_stat);  // Clear ih_cec_stat0 in HDMITX_DWC
+            if (int_stat == 0x01) {
+                //HDMITX cec_done Interrupt Process_Irq
+                ret = cec_ll_rx(msg, len);
+            } else {
+                hdmi_print(INF, CEC "Error: HDMITX CEC interrupt error, expecting DONE\n");
+            }
+        } else {
+            hdmi_print(INF, CEC "Error: Unintended interrupt seen at HDMITX DWC\n");
+        }
+    } else {
+        hdmi_print(INF, CEC "[Error: Unintended interrupt seen at HDMITX TOP\n");
+    }
+    
+    return ret;
+}
+
+static unsigned int hdmi_cec_intr_stat(void)
+{
+    return hdmitx_rd_reg(HDMITX_DWC_IH_CEC_STAT0);
+}
+
+// return value: 1: successful      0: error
+static int hdmi_cec_ll_tx(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 1;
+    unsigned int n;
+
+    hdmitx_wr_reg(HDMITX_DWC_CEC_TX_CNT, len);
+    for (i = 0; i < len; i++) {
+        hdmitx_wr_reg(HDMITX_DWC_CEC_TX_DATA00+i, msg[i]);
+    }
+    hdmitx_wr_reg(HDMITX_DWC_CEC_CTRL,   hdmitx_rd_reg(HDMITX_DWC_CEC_CTRL) | (1<<0));
+
+    if(cec_msg_dbg_en  == 1) {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for(n = 0; n < len; n++) {
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+
+        msg_log_buf[pos] = '\0';
+        printk("%s", msg_log_buf);
+    }
+    return ret;
+}
+
+static int hdmi_cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
+{
+    //to do
+    return 1;
+}
+
+static int hdmi_cec_tx_irq_handle(void)
+{
+    unsigned long data32;
+    int ret;
+    int int_stat_main;
+    int int_stat;
+    
+    ret = 0;
+    data32  = hdmitx_rd_reg(HDMITX_TOP_INTR_STAT);
+    hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR, data32);    // clear interrupts in HDMITX_TOP module
+    
+    if (data32 & (1 << 0))
+    {  // core_intr
+        int_stat_main = hdmitx_rd_reg(HDMITX_DWC_IH_DECODE);
+        if (int_stat_main)
+        {
+            int_stat = hdmitx_rd_reg(HDMITX_DWC_IH_CEC_STAT0);
+            hdmitx_wr_reg(HDMITX_DWC_IH_CEC_STAT0, int_stat);  // Clear ih_cec_stat0 in HDMITX_DWC
+            if (int_stat == 0x02) {
+                //HDMITX cec_eom Interrupt Process_Irq
+                hdmi_print(INF, CEC "tx successful\n");
+            } else {
+                hdmi_print(INF, CEC "Error: HDMITX CEC interrupt error, expecting EOM\n\n");
+            }
+        } else {
+            hdmi_print(INF, CEC "Error: Unintended interrupt seen at HDMITX DWC\n");
+        }
+    } else {
+        hdmi_print(INF, CEC "[Error: Unintended interrupt seen at HDMITX TOP\n");
+    }
+    
+    return ret;
+}
+
+static void hdmi_cec_polling_online_dev(int log_addr, int *bool)
+{
+    //to do
+}
+
+#endif
+
+//******************************************************************************************************
+void cec_disable_irq(void)
+{
+#ifdef AO_CEC
+    ao_cec_disable_irq();
+#else
+    hdmi_cec_disable_irq();
+#endif
+}
+
+void cec_enable_irq(void)
+{
+#ifdef AO_CEC
+    ao_cec_enable_irq();
+#else
+    hdmi_cec_enable_irq();
+#endif
+}
+
+// 0xc8100014              
+void cec_pinmux_set(cec_pinmux_set_e cnt, int vaule)
+{
+    //To do. gpioao_8/9
+    switch(cnt)
+    {
+    case JTAG_TMS:
+        break;
+    case HDMI_CEC_AO:
+        //pm_gpioAO_8_cec bit[17]
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);
+        //pm_gpioAO_9_cec bit[27]
+        //aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 27, 1);
+        
+        //disable HDMITX_CEC on gpioao_8 pin
+        // out: pm_hdmitx_cec_gpioAO_8          = pin_mux_reg[14];
+        // in:  pm_hdmitx_cec_gpioAO_8          = pin_mux_reg11[26];
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 14, 1);
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_11, 0, 26, 1); 
+        //disable JTAG on gpioao_8 pin for aocec
+        // Secureregister[1:0] = 0;
+        aml_set_reg32_bits(P_AO_SECURE_REG1, 0, 0, 2); 
+        //disable HDMIRX_CEC on gpioao_8 pin
+        // out: pm_hdmitx_cec_gpioAO_8          = pin_mux_reg[16];
+        // in:  pm_hdmitx_cec_gpioAO_8          = pin_mux_reg11[28];
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 16, 1);
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 28, 1); 
+        break;
+    case HDMITX_CEC:
+        //gpioao_8
+        // out: pm_hdmitx_cec_gpioAO_8          = pin_mux_reg[14];
+        // in:  pm_hdmitx_cec_gpioAO_8          = pin_mux_reg11[26];
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 14, 1);
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_11, 1, 26, 1);        
+        
+        //gpioao_9
+        // out: pm_hdmitx_cec_gpioAO_9          = pin_mux_reg[13];
+        // in:  pm_hdmitx_cec_gpioAO_9          = pin_mux_reg11[25];
+        //aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 13, 1);
+        //aml_set_reg32_bits(P_PERIPHS_PIN_MUX_11, 1, 25, 1);
+        break;
+    case HDMIRX_CEC:
+        break;
+    default:
+        //GPIOAO_9
+        break;
+    }
+}
+
+void cec_clk_set(void)
+{
+#ifdef AO_CEC
+    ao_cec_clk_set();
+#else
+    hdmi_cec_clk_set();
+#endif
+}
+
+void cec_sw_reset(void)
+{
+#ifdef AO_CEC
+    ao_cec_sw_reset();
+#else
+    hdmi_cec_sw_reset();
+#endif
+}
+
+void cec_logic_addr_set(enum _cec_log_dev_addr_e logic_addr)
+{
+#ifdef AO_CEC
+    ao_cec_logic_addr_set(logic_addr);
+#else
+    hdmi_cec_logic_addr_set(logic_addr);
+#endif
+}
+
+void cec_timing_set(void)
+{
+#ifdef AO_CEC
+    ao_cec_timing_set();
+#else
+    hdmi_cec_timing_set();
+#endif
+}
+
+void cec_phyaddr_set(int phyaddr)
+{
+    //to do
+}
+
+void cec_set(void)
+{
+#ifdef AO_CEC
+    ao_cec_set();
+#else
+    hdmi_cec_set();
+#endif
+}
+
+void cec_hw_reset(void)
+{ 
+#ifdef AO_CEC
+    ao_cec_hw_reset();
+#else
+    hdmi_cec_hw_reset();
+#endif
+    hdmi_print(INF, CEC "hw reset!\n");
+}
+
+void cec_hw_init(void)
+{
+    cec_clk_set();
+    
+    cec_pinmux_set(HDMI_CEC_AO, 0);
+    
+    //init cec clk
+    cec_clk_set();
+    
+    //cec software reset
+    cec_sw_reset();
+    
+    cec_timing_set();
+    
+    cec_set();
+
+    // Enable CEC interrupt sources
+    cec_enable_irq();
+
+    cec_logic_addr_set(CEC_PLAYBACK_DEVICE_1_ADDR);
+    
+    hdmi_print(INF, CEC "cec hw init!\n");
+}
+
+int cec_ll_rx( unsigned char *msg, unsigned char *len)
+{
+#ifdef AO_CEC
+    return ao_cec_ll_rx(msg, len);
+#else
+    return hdmi_cec_ll_rx(msg, len);
+#endif
+}
+
+// Return value: 0: fail    1: success
+int cec_ll_tx(const unsigned char *msg, unsigned char len)
+{
+    int ret = 0;
+    if(!cec_irq_enable_flag)
+        return 2;
+        
+    mutex_lock(&cec_mutex);
+#ifdef AO_CEC
+    ao_cec_ll_tx(msg, len);
+#else
+    hdmi_cec_ll_tx(msg, len);
+#endif
+    mutex_unlock(&cec_mutex);
+    
+    return ret;
+}
+
+unsigned int cec_intr_stat(void)
+{
+    //to do
+#ifdef AO_CEC
+    return ao_cec_intr_stat();
+#else
+    return hdmi_cec_intr_stat();
+#endif
+}
+
+int cec_rx_irq_handle(unsigned char *msg, unsigned char *len)
+{
+    //to do
+#ifdef AO_CEC
+    return ao_cec_rx_irq_handle(msg, len);
+#else
+    return hdmi_cec_rx_irq_handle(msg, len);
+#endif
+}
+
+int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
+{
+#ifdef AO_CEC
+    return ao_cec_ll_tx_polling(msg, len);
+#else
+    return hdmi_cec_ll_tx_polling(msg, len);
+#endif
+}
+
+void cec_tx_irq_handle(void)
+{
+#ifdef AO_CEC
+    ao_cec_tx_irq_handle();
+#else
+    hdmi_cec_tx_irq_handle();
+#endif
+}
+
+void cec_polling_online_dev(int log_addr, int *bool)
+{
+#ifdef AO_CEC
+    ao_cec_polling_online_dev(log_addr, bool);
+#else
+    hdmi_cec_polling_online_dev(log_addr, bool);
+#endif
+    hdmi_print(INF, CEC "CEC: poll online logic device: 0x%x BOOL: %d\n", log_addr, *bool);
+}
+
+
+// DELETE LATER, TEST ONLY
+void cec_test_(unsigned int cmd)
+{
+    
+}
diff --git a/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_hw.c b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_hw.c
new file mode 100644
index 000000000000..9893a4df848b
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_hw.c
@@ -0,0 +1,4155 @@
+/*
+ * Amlogic Meson HDMI Transmitter Driver
+ * Copyright (C) 2010 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/slab.h>
+//#include <linux/amports/canvas.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/clock.h>
+#include <mach/power_gate.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/enc_clk_config.h>
+#include <mach/io.h>
+#include <mach/register.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+
+#include "hdmi_tx_reg.h"
+#include "tvenc_conf.h"
+#ifdef Wr
+#undef Wr
+#endif
+#ifdef Rd
+#undef Rd
+#endif
+#define Wr(reg,val) WRITE_MPEG_REG(reg,val)
+#define Rd(reg)   READ_MPEG_REG(reg)
+#define Wr_reg_bits(reg, val, start, len) \
+  Wr(reg, (Rd(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
+
+#define EDID_RAM_ADDR_SIZE      (8)
+
+static void hdmi_audio_init(unsigned char spdif_flag);
+static void hdmitx_dump_tvenc_reg(int cur_VIC, int printk_flag);
+
+static void hdmi_phy_suspend(void);
+static void hdmi_phy_wakeup(hdmitx_dev_t* hdmitx_device);
+static void hdmitx_set_phy(hdmitx_dev_t* hdmitx_device);
+static void C_Entry(HDMI_Video_Codes_t vic);
+void set_hdmi_audio_source(unsigned int src);
+static void hdmitx_csc_config(unsigned char input_color_format, unsigned char output_color_format, unsigned char color_depth);
+unsigned char hdmi_pll_mode = 0; /* 1, use external clk as hdmi pll source */
+extern void clocks_set_vid_clk_div(int div_sel);
+
+#define HSYNC_POLARITY      1                       // HSYNC polarity: active high 
+#define VSYNC_POLARITY      1                       // VSYNC polarity: active high
+#define TX_INPUT_COLOR_DEPTH    0                   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
+#define TX_INPUT_COLOR_FORMAT   1                   // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
+#define TX_INPUT_COLOR_RANGE    0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
+
+
+#define TX_OUTPUT_COLOR_RANGE   0                   // Pixel range: 0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
+
+#define TX_I2S_SPDIF        1                       // 0=SPDIF; 1=I2S. Note: Must select I2S if CHIP_HAVE_HDMI_RX is defined.
+#define TX_I2S_8_CHANNEL    0                       // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
+
+//static struct tasklet_struct EDID_tasklet;
+static unsigned delay_flag = 0;
+static unsigned serial_reg_val=0x1; //0x22;
+static unsigned char i2s_to_spdif_flag=1;   // if current channel number is larger than 2ch, using i2s
+static unsigned color_depth_f=0;
+static unsigned color_space_f=0;
+static unsigned char new_reset_sequence_flag=1;
+static unsigned char power_mode=1;
+static unsigned char power_off_vdac_flag=0;
+    /* 0, do not use fixed tvenc val for all mode; 1, use fixed tvenc val mode for 480i; 2, use fixed tvenc val mode for all modes */
+static unsigned char use_tvenc_conf_flag=1;
+
+static unsigned char cur_vout_index = 1; //CONFIG_AM_TV_OUTPUT2
+
+static void hdmitx_set_packet(int type, unsigned char* DB, unsigned char* HB);
+static void hdmitx_setaudioinfoframe(unsigned char* AUD_DB, unsigned char* CHAN_STAT_BUF);
+static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *param);
+static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio_para_t* audio_param);
+static void hdmitx_setupirq(hdmitx_dev_t* hdmitx_device);
+static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf);
+static void hdmitx_uninit(hdmitx_dev_t* hdmitx_device);
+static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv);
+static int hdmitx_cntl_ddc(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv);
+static int hdmitx_get_state(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv);
+static int hdmitx_cntl_config(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv);
+static int hdmitx_cntl_misc(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv);
+static void digital_clk_on(unsigned char flag);
+static void digital_clk_off(unsigned char flag);
+static void tmp_generate_vid_hpll(void);
+/*
+ * HDMITX HPD HW related operations
+ */
+enum hpd_op{
+    HPD_INIT_DISABLE_PULLUP,
+    HPD_INIT_SET_FILTER,
+    HPD_IS_HPD_MUXED,
+    HPD_MUX_HPD,
+    HPD_UNMUX_HPD,
+    HPD_READ_HPD_GPIO,
+};
+
+static int hdmitx_hpd_hw_op(enum hpd_op cmd)
+{
+    int ret = 0;
+    switch(cmd) {
+    case HPD_INIT_DISABLE_PULLUP:
+        aml_set_reg32_bits(P_PAD_PULL_UP_REG1, 0, 21, 1);
+        break;
+    case HPD_INIT_SET_FILTER:
+        hdmitx_wr_reg(HDMITX_TOP_HPD_FILTER, ((0xa << 12) | (0xa0 << 0)));
+        break;
+    case HPD_IS_HPD_MUXED:
+        ret = !!(aml_read_reg32(P_PERIPHS_PIN_MUX_1)&(1<<26));
+        break;
+    case HPD_MUX_HPD:
+        aml_set_reg32_bits(P_PREG_PAD_GPIO1_EN_N, 1, 21, 1);    // GPIOH_5 input
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0, 19, 1);      // clear other pinmux
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 26, 1);
+        break;
+    case HPD_UNMUX_HPD:
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0, 26, 1);
+        aml_set_reg32_bits(P_PREG_PAD_GPIO1_EN_N, 1, 21, 1);    // GPIOH_5 input
+        break;
+    case HPD_READ_HPD_GPIO:
+        ret = !!(aml_read_reg32(P_PREG_PAD_GPIO1_I) & (1 << 21));
+        break;
+    default:
+        printk("error hpd cmd %d\n", cmd);
+        break;
+    }
+    return ret;
+}
+
+extern int read_hpd_gpio(void);
+int read_hpd_gpio(void)
+{
+    return !!(aml_read_reg32(P_PREG_PAD_GPIO1_I) & (1 << 21));
+}
+EXPORT_SYMBOL(read_hpd_gpio);
+
+/*
+ * HDMITX DDC HW related operations
+ */
+enum ddc_op {
+    DDC_INIT_DISABLE_PULLUP,
+    DDC_MUX_DDC,
+    DDC_UNMUX_DDC,
+};
+
+static int hdmitx_ddc_hw_op(enum ddc_op cmd)
+{
+    int ret = 0;
+    switch(cmd) {
+    case DDC_INIT_DISABLE_PULLUP:
+        aml_set_reg32_bits(P_PAD_PULL_UP_REG1, 0, 19, 2);
+        break;
+    case DDC_MUX_DDC:
+        aml_set_reg32_bits(P_PREG_PAD_GPIO1_EN_N, 3, 2, 2);    // GPIOH_3/4 input
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 3, 24, 2);
+        break;
+    case DDC_UNMUX_DDC:
+        aml_set_reg32_bits(P_PREG_PAD_GPIO1_EN_N, 3, 19, 2);    // GPIOH_3/4 input
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 0, 24, 2);
+        break;
+    default:
+        printk("error ddc cmd %d\n", cmd);
+    }
+    return ret;
+}
+
+
+static void configure_hdcp_dpk(unsigned long sw_enc_key)
+{
+    const unsigned long hw_enc_key      = 0xcac;
+    const unsigned char dpk_aksv[5]     = {0x12};
+    unsigned char       dpk_key[280]    = {
+        // test
+    };
+    unsigned long       sr_1;
+    unsigned long       sr_2;
+    unsigned char       mask;
+    unsigned int        i, j;
+    unsigned int        dpk_index;
+    unsigned long       sr2_b24_b1, sr2_b0, sr1_b24_b0, sr1_b26_b0, sr1_b27, sr1_b24;
+
+    printk("[HDMITX.C] Configure HDCP keys -- Begin\n");
+
+    //init key encrypt vectors
+    sr_1    = ((hw_enc_key&0xfff)<<16) | (sw_enc_key&0xffff);
+    sr_2    = 0x1978F5E;
+
+    //encrypt keys loop
+    for (j=0; j<40; j++) {
+        for (i=0; i<7; i++) {
+            mask    =   (((sr_2>>0)&0x1) << 7)  |
+                        (((sr_2>>2)&0x1) << 6)  |
+                        (((sr_2>>4)&0x1) << 5)  |
+                        (((sr_2>>6)&0x1) << 4)  |
+                        (((sr_2>>1)&0x1) << 3)  |
+                        (((sr_2>>3)&0x1) << 2)  |
+                        (((sr_2>>5)&0x1) << 1)  |
+                        (((sr_2>>7)&0x1) << 0);
+            //sr_2 shift + bit manipulation
+            sr2_b24_b1  = (sr_2>>1)&0xffffff;
+            sr2_b0      = sr_2&0x1;
+            sr1_b24_b0  = sr_1&0x1ffffff;
+            sr_2        = (((sr2_b0<<24) | sr2_b24_b1) ^ sr1_b24_b0) & 0x1ffffff;
+            //sr_2    = ((((sr_2&0x1)<<24) | ((sr_2>>1)&0xffffff)) ^ (sr_1&0x1ffffff)) & 0x1ffffff;
+            //sr_1 shift left + bit manipulation
+            sr1_b26_b0  = sr_1&0x7ffffff;
+            sr1_b27     = (sr_1>>27)&0x1;
+            sr1_b24     = (sr_1>>24)&0x1;
+            sr_1        = (((sr1_b26_b0<<1) | sr1_b27) & 0xffffffe) + (sr1_b27 ^ sr1_b24);
+            //sr_1    = ((((sr_1&0x7ffffff)<<1) | ((sr_1>>27)&0x1)) & 0xffffffe) + (((sr_1>>27)0x1) ^ ((sr_1>>24)&0x1));
+            //Encrypt Key
+            dpk_key[j*7+(6-i)]  = dpk_key[j*7+(6-i)] ^ mask;
+        }
+    }
+
+    // Disable key encryption for writing KSV
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_RMLCTL,    0);
+    //wait for memory access ok
+    hdmitx_poll_reg(HDMITX_DWC_HDCPREG_RMLSTS, (1<<6), HZ);
+    //write AKSV (unecrypted)
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK6, 0);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK5, 0);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK4, dpk_aksv[4]);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK3, dpk_aksv[3]);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK2, dpk_aksv[2]);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK1, dpk_aksv[1]);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK0, dpk_aksv[0]);
+    
+    //wait for memory access ok
+    hdmitx_poll_reg(HDMITX_DWC_HDCPREG_RMLSTS, (1<<6)|1, HZ);
+    
+    //enable encryption
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_RMLCTL,    1);
+    
+    //configure seed
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_SEED1,    (sw_enc_key>>8)&0xff);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_SEED0,    sw_enc_key&0xff);
+    
+    //store encrypted keys
+    for (dpk_index = 0; dpk_index < 40; dpk_index++) {
+        hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK6, dpk_key[dpk_index*7+6]);
+        hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK5, dpk_key[dpk_index*7+5]);
+        hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK4, dpk_key[dpk_index*7+4]);
+        hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK3, dpk_key[dpk_index*7+3]);
+        hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK2, dpk_key[dpk_index*7+2]);
+        hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK1, dpk_key[dpk_index*7+1]);
+        hdmitx_wr_reg(HDMITX_DWC_HDCPREG_DPK0, dpk_key[dpk_index*7+0]);
+        hdmitx_poll_reg(HDMITX_DWC_HDCPREG_RMLSTS, (1<<6)|((dpk_index==39)? 40:(dpk_index+2)), HZ);
+    }
+    
+    printk("[HDMITX.C] Configure HDCP keys -- End\n");
+}   /* configure_hdcp_dpk */
+
+#define HDCP_AN_SW_VAL_HI   0x88a663a8
+#define HDCP_AN_SW_VAL_LO   0xb4317416
+
+static void hdmitx_hdcp_test(void)
+{
+    unsigned int data32 = 0;
+
+    //--------------------------------------------------------------------------
+    // Configure HDCP
+    //--------------------------------------------------------------------------
+
+    data32  = 0;
+    data32 |= (0    << 7);  // [  7] hdcp_engaged_int_mask
+    data32 |= (0    << 6);  // [  6] hdcp_failed_int_mask
+    data32 |= (0    << 4);  // [  4] i2c_nack_int_mask
+    data32 |= (0    << 3);  // [  3] lost_arbitration_int_mask
+    data32 |= (0    << 2);  // [  2] keepout_error_int_mask
+    data32 |= (0    << 1);  // [  1] ksv_sha1_calc_int_mask
+    data32 |= (1    << 0);  // [  0] ksv_access_int_mask
+    hdmitx_wr_reg(HDMITX_DWC_A_APIINTMSK,   data32);
+
+    data32  = 0;
+    data32 |= (0    << 5);  // [6:5] unencryptconf
+    data32 |= (1    << 4);  // [  4] dataenpol
+    data32 |= (1    << 3);  // [  3] vsyncpol
+    data32 |= (1    << 1);  // [  1] hsyncpol
+    hdmitx_wr_reg(HDMITX_DWC_A_VIDPOLCFG,   data32);
+
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_AN0,   (HDCP_AN_SW_VAL_LO>> 0)&0xff);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_AN1,   (HDCP_AN_SW_VAL_LO>> 8)&0xff);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_AN2,   (HDCP_AN_SW_VAL_LO>>16)&0xff);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_AN3,   (HDCP_AN_SW_VAL_LO>>24)&0xff);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_AN4,   (HDCP_AN_SW_VAL_HI>> 0)&0xff);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_AN5,   (HDCP_AN_SW_VAL_HI>> 8)&0xff);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_AN6,   (HDCP_AN_SW_VAL_HI>>16)&0xff);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_AN7,   (HDCP_AN_SW_VAL_HI>>24)&0xff);
+    hdmitx_wr_reg(HDMITX_DWC_HDCPREG_ANCONF, 0);    // 0=AN is from HW; 1=AN is from SW register.
+
+    hdmitx_wr_reg(HDMITX_DWC_A_OESSWCFG,    0x40);
+
+    data32  = 0;
+    data32 |= (0    << 3);  // [  3] sha1_fail
+    data32 |= (0    << 2);  // [  2] ksv_ctrl_update
+    data32 |= (0    << 1);  // [  1] Rsvd for read-only ksv_mem_access
+    data32 |= (1    << 0);  // [  0] ksv_mem_request
+    hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, data32);
+    hdmitx_poll_reg(HDMITX_DWC_A_KSVMEMCTRL, (1<<1), 2 * HZ);
+    hdmitx_wr_reg(HDMITX_DWC_HDCP_REVOC_SIZE_0, 0);
+    hdmitx_wr_reg(HDMITX_DWC_HDCP_REVOC_SIZE_1, 0);
+    data32  = 0;
+    data32 |= (0    << 3);  // [  3] sha1_fail
+    data32 |= (0    << 2);  // [  2] ksv_ctrl_update
+    data32 |= (0    << 1);  // [  1] Rsvd for read-only ksv_mem_access
+    data32 |= (0    << 0);  // [  0] ksv_mem_request
+    hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, data32);
+#define hdcp_on 1
+    data32  = 0;
+    data32 |= (0                << 4);  // [  4] hdcp_lock
+    data32 |= (0                << 3);  // [  3] dissha1check
+    data32 |= (1                << 2);  // [  2] ph2upshiftenc
+    data32 |= ((hdcp_on?0:1)    << 1);  // [  1] encryptiondisable
+    data32 |= (1                << 0);  // [  0] swresetn. Write 0 to activate, self-clear to 1.
+    hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG1,    data32);
+
+    configure_hdcp_dpk(0xa938);
+
+    //initialize HDCP, with rxdetect low
+    data32  = 0;
+    data32 |= (0                << 7);  // [  7] ELV_ena
+    data32 |= (1                << 6);  // [  6] i2c_fastmode
+    data32 |= ((hdcp_on?0:1)    << 5);  // [  5] byp_encryption
+    data32 |= (1                << 4);  // [  4] sync_ri_check
+    data32 |= (0                << 3);  // [  3] avmute
+    data32 |= (0                << 2);  // [  2] rxdetect
+    data32 |= (1                << 1);  // [  1] en11_feature
+    data32 |= (1                << 0);  // [  0] hdmi_dvi
+    hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG0,    data32);
+
+    printk("[TEST.C] Start HDCP\n");
+    hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG0, hdmitx_rd_reg(HDMITX_DWC_A_HDCPCFG0) | (1<<2));
+
+}
+
+static void hdmi_hwp_init(hdmitx_dev_t* hdev)
+{
+
+    hdmitx_hpd_hw_op(HPD_INIT_DISABLE_PULLUP);
+    hdmitx_hpd_hw_op(HPD_INIT_SET_FILTER);
+    hdmitx_ddc_hw_op(DDC_INIT_DISABLE_PULLUP);
+                                                                  //     1=Map data pins from Venc to Hdmi Tx as RGB mode.
+    // --------------------------------------------------------
+    // Configure HDMI TX analog, and use HDMI PLL to generate TMDS clock
+    // --------------------------------------------------------
+    // Enable APB3 fail on error
+//    WRITE_APB_REG(HDMI_CNTL_PORT, READ_APB_REG(HDMI_CNTL_PORT)|(1<<15)); //APB3 err_en
+//\\ TODO
+    tmp_generate_vid_hpll();
+    set_vmode_clk(VMODE_1080P);
+    C_Entry(HDMI_1920x1080p60_16x9);
+    set_vmode_clk(VMODE_1080P);
+    hdmitx_set_phy(hdev);
+    aml_write_reg32(P_ENCP_VIDEO_EN, 1);
+    set_hdmi_audio_source(2);
+    hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 0, 3, 1);
+    msleep(1);
+    hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 1, 3, 1);
+
+    //TODO
+
+    // clock gate on
+
+    // detect display alread on uboot
+
+    // tx h/w init
+}
+
+static void hdmi_hwi_init(hdmitx_dev_t* hdev)
+{
+    unsigned int data32 = 0;
+//--------------------------------------------------------------------------
+// Configure E-DDC interface
+//--------------------------------------------------------------------------
+    data32  = 0;
+    data32 |= (0    << 6);  // [  6] read_req_mask
+    data32 |= (0    << 2);  // [  2] done_mask
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_INT,      data32);
+
+    data32  = 0;
+    data32 |= (0    << 6);  // [  6] nack_mask
+    data32 |= (0    << 2);  // [  2] arbitration_error_mask
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_CTLINT,   data32);
+
+    data32  = 0;
+    data32 |= (0    << 3);  // [  3] i2c_fast_mode: 0=standard mode; 1=fast mode.
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_DIV,      data32);
+
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_HCNT_1,    0);
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_HCNT_0,    0x60);
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_LCNT_1,    0);
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_SS_SCL_LCNT_0,    0x71);
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_HCNT_1,    0);
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_HCNT_0,    0x0f);
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_LCNT_1,    0);
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_FS_SCL_LCNT_0,    0x20);
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_SDA_HOLD,         0x08);
+
+    data32  = 0;
+    data32 |= (0    << 5);  // [  5] updt_rd_vsyncpoll_en
+    data32 |= (0    << 4);  // [  4] read_request_en  // scdc
+    data32 |= (0    << 0);  // [  0] read_update
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_SCDC_UPDATE,  data32);
+}
+
+void HDMITX_Meson_Init(hdmitx_dev_t* hdev)
+{
+    hdev->HWOp.SetPacket = hdmitx_set_packet;
+    hdev->HWOp.SetAudioInfoFrame = hdmitx_setaudioinfoframe;
+    hdev->HWOp.SetDispMode = hdmitx_set_dispmode;
+    hdev->HWOp.SetAudMode = hdmitx_set_audmode;
+    hdev->HWOp.SetupIRQ = hdmitx_setupirq;
+    hdev->HWOp.DebugFun = hdmitx_debug;
+    hdev->HWOp.UnInit = hdmitx_uninit;
+    hdev->HWOp.Cntl = hdmitx_cntl;             // todo
+    hdev->HWOp.CntlDDC = hdmitx_cntl_ddc;
+    hdev->HWOp.GetState = hdmitx_get_state;
+    hdev->HWOp.CntlPacket = hdmitx_cntl;
+    hdev->HWOp.CntlConfig = hdmitx_cntl_config;
+    hdev->HWOp.CntlMisc = hdmitx_cntl_misc;
+
+    digital_clk_on(0xff);
+    hdmi_hwp_init(hdev);
+    hdmi_hwi_init(hdev);
+}
+
+static irqreturn_t intr_handler(int irq, void *dev)
+{
+    unsigned int data32 = 0;
+    hdmitx_dev_t* hdev = (hdmitx_dev_t*)dev;
+    // get interrupt status
+    data32 = hdmitx_rd_reg(HDMITX_TOP_INTR_STAT);
+    hdmi_print(IMP, SYS "irq %x\n", data32);
+    if(hdev->hpd_lock == 1) {
+        hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR, 0xf);
+        hdmi_print(IMP, HPD "HDMI hpd locked\n");
+        return IRQ_HANDLED;
+    }
+    // check HPD status
+    if((data32 & (1 << 1)) &&(data32 & (1 << 2))) {
+        if(hdmitx_hpd_hw_op(HPD_READ_HPD_GPIO))
+            data32 &= ~(1 << 2);
+        else
+            data32 &= ~(1 << 1);
+    }
+    // internal interrupt
+    if(data32 & (1 << 0)) {
+        hdev->hdmitx_event |= HDMI_TX_INTERNAL_INTR;
+        PREPARE_WORK(&hdev->work_internal_intr, hdmitx_internal_intr_handler);
+        queue_work(hdev->hdmi_wq, &hdev->work_internal_intr);
+    }
+    // HPD rising
+    if(data32 & (1 << 1)) {
+        hdev->hdmitx_event |= HDMI_TX_HPD_PLUGIN;
+        hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGOUT;
+        PREPARE_DELAYED_WORK(&hdev->work_hpd_plugin, hdmitx_hpd_plugin_handler);
+        queue_delayed_work(hdev->hdmi_wq, &hdev->work_hpd_plugin, HZ / 3);
+    }
+    // HPD falling
+    if(data32 & (1 << 2)) {
+        hdev->hdmitx_event |= HDMI_TX_HPD_PLUGOUT;
+        hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGIN;
+        PREPARE_DELAYED_WORK(&hdev->work_hpd_plugout, hdmitx_hpd_plugout_handler);
+        queue_delayed_work(hdev->hdmi_wq, &hdev->work_hpd_plugout, HZ / 3);
+    }
+    // HPD falling
+    hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR, data32 | 0x6);
+    return IRQ_HANDLED;
+}
+
+static unsigned long modulo(unsigned long a, unsigned long b)
+{
+    if (a >= b) {
+        return(a-b);
+    } else {
+        return(a);
+    }
+}
+        
+static signed int to_signed(unsigned int a)
+{
+    if (a <= 7) {
+        return(a);
+    } else {
+        return(a-16);
+    }
+}
+
+static void delay_us (int us)
+{
+    //udelay(us);
+    if(delay_flag&0x1)
+        mdelay((us+999)/1000);
+    else
+        ;
+//    udelay(us);
+} /* delay_us */
+
+/*
+ * mode: 1 means Progressive;  0 means interlaced
+ */
+static void enc_vpu_bridge_reset(int mode)
+{
+    unsigned int wr_clk = 0;
+
+    printk("%s[%d]\n", __func__, __LINE__);
+    wr_clk = (aml_read_reg32(P_VPU_HDMI_SETTING) & 0xf00) >> 8;
+    if(mode) {
+        aml_write_reg32(P_ENCP_VIDEO_EN, 0);
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, 0, 0, 2);  // [    0] src_sel_enci: Disable ENCP output to HDMI
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, 0, 8, 4);  // [    0] src_sel_enci: Disable ENCP output to HDMI
+        mdelay(1);
+        aml_write_reg32(P_ENCP_VIDEO_EN, 1);
+        mdelay(1);
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, wr_clk, 8, 4);
+        mdelay(1);
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, 2, 0, 2);  // [    0] src_sel_enci: Enable ENCP output to HDMI
+    } else {
+        aml_write_reg32(P_ENCI_VIDEO_EN, 0);
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, 0, 0, 2);  // [    0] src_sel_enci: Disable ENCI output to HDMI
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, 0, 8, 4);  // [    0] src_sel_enci: Disable ENCP output to HDMI
+        mdelay(1);
+        aml_write_reg32(P_ENCI_VIDEO_EN, 1);
+        mdelay(1);
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, wr_clk, 8, 4);
+        mdelay(1);
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 0, 2);  // [    0] src_sel_enci: Enable ENCI output to HDMI
+    }
+}
+
+static void hdmi_tvenc1080i_set(Hdmi_tx_video_para_t* param)
+{
+    unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2; // Annie 01Sep2011: Change value from 3 to 2, due to video encoder path delay change.
+    unsigned long TOTAL_PIXELS = 0, PIXEL_REPEAT_HDMI = 0, PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 0;
+    unsigned FRONT_PORCH = 88, HSYNC_PIXELS = 0, ACTIVE_LINES = 0, INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0, VSYNC_LINES = 0;
+    unsigned LINES_F0 = 0, LINES_F1 = 563, BACK_PORCH = 0, EOF_LINES = 2, TOTAL_FRAMES = 0;
+
+    unsigned long total_pixels_venc  = 0;
+    unsigned long active_pixels_venc = 0;
+    unsigned long front_porch_venc = 0;
+    unsigned long hsync_pixels_venc  = 0;
+
+    unsigned long de_h_begin = 0, de_h_end = 0;
+    unsigned long de_v_begin_even = 0, de_v_end_even = 0, de_v_begin_odd = 0, de_v_end_odd = 0;
+    unsigned long hs_begin = 0, hs_end = 0;
+    unsigned long vs_adjust = 0;
+    unsigned long vs_bline_evn = 0, vs_eline_evn = 0, vs_bline_odd = 0, vs_eline_odd = 0;
+    unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+    
+    if(param->VIC==HDMI_1080i60){
+         INTERLACE_MODE     = 1;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 0;
+         ACTIVE_PIXELS  =     (1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 562;
+         LINES_F1           = 563;
+         FRONT_PORCH        = 88;
+         HSYNC_PIXELS       = 44;
+         BACK_PORCH         = 148;
+         EOF_LINES          = 2;
+         VSYNC_LINES        = 5;
+         SOF_LINES          = 15;
+         TOTAL_FRAMES       = 4;
+    }
+    else if(param->VIC==HDMI_1080i50){
+         INTERLACE_MODE     = 1;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 0;
+         ACTIVE_PIXELS  =     (1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 562;
+         LINES_F1           = 563;
+         FRONT_PORCH        = 528;
+         HSYNC_PIXELS       = 44;
+         BACK_PORCH         = 148;
+         EOF_LINES          = 2;
+         VSYNC_LINES        = 5;
+         SOF_LINES          = 15;
+         TOTAL_FRAMES       = 4;
+    }
+    TOTAL_PIXELS =(FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
+    TOTAL_LINES  =(LINES_F0+(LINES_F1*INTERLACE_MODE));                // Number of total lines per frame.
+
+    total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 2200 / 1 * 2 = 4400
+    active_pixels_venc= (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 1920 / 1 * 2 = 3840
+    front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 88   / 1 * 2 = 176
+    hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 44   / 1 * 2 = 88
+
+    aml_write_reg32(P_ENCP_VIDEO_MODE, aml_read_reg32(P_ENCP_VIDEO_MODE)|(1<<14)); // cfg_de_v = 1
+
+    // Program DE timing
+    de_h_begin = modulo(aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN) + VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc); // (383 + 3) % 4400 = 386
+    de_h_end   = modulo(de_h_begin + active_pixels_venc,                        total_pixels_venc); // (386 + 3840) % 4400 = 4226
+    aml_write_reg32(P_ENCP_DE_H_BEGIN, de_h_begin);    // 386
+    aml_write_reg32(P_ENCP_DE_H_END,   de_h_end);      // 4226
+    // Program DE timing for even field
+    de_v_begin_even = aml_read_reg32(P_ENCP_VIDEO_VAVON_BLINE);       // 20
+    de_v_end_even   = de_v_begin_even + ACTIVE_LINES;   // 20 + 540 = 560
+    aml_write_reg32(P_ENCP_DE_V_BEGIN_EVEN,de_v_begin_even);   // 20
+    aml_write_reg32(P_ENCP_DE_V_END_EVEN,  de_v_end_even);     // 560
+    // Program DE timing for odd field if needed
+    if (INTERLACE_MODE) {
+        // Calculate de_v_begin_odd according to enc480p_timing.v:
+        //wire[10:0]    cfg_ofld_vavon_bline    = {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline    + ofld_line;
+        de_v_begin_odd  = to_signed((aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2; // 1 + 20 + (1125-1)/2 = 583
+        de_v_end_odd    = de_v_begin_odd + ACTIVE_LINES;    // 583 + 540 = 1123
+        aml_write_reg32(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);// 583
+        aml_write_reg32(P_ENCP_DE_V_END_ODD,   de_v_end_odd);  // 1123
+    }
+
+    // Program Hsync timing
+    if (de_h_end + front_porch_venc >= total_pixels_venc) {
+        hs_begin    = de_h_end + front_porch_venc - total_pixels_venc; // 4226 + 176 - 4400 = 2
+        vs_adjust   = 1;
+    } else {
+        hs_begin    = de_h_end + front_porch_venc;
+        vs_adjust   = 0;
+    }
+    hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc); // (2 + 88) % 4400 = 90
+    aml_write_reg32(P_ENCP_DVI_HSO_BEGIN,  hs_begin);  // 2
+    aml_write_reg32(P_ENCP_DVI_HSO_END,    hs_end);    // 90
+    
+    // Program Vsync timing for even field
+    if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust)) {
+        vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust); // 20 - 15 - 5 - 0 = 0
+    } else {
+        vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust);
+    }
+    vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES); // (0 + 5) % 1125 = 5
+    aml_write_reg32(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);   // 0
+    aml_write_reg32(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);   // 5
+    vso_begin_evn = hs_begin; // 2
+    aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);  // 2
+    aml_write_reg32(P_ENCP_DVI_VSO_END_EVN,   vso_begin_evn);  // 2
+    // Program Vsync timing for odd field if needed
+    if (INTERLACE_MODE) {
+        vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;  // 583-1 - 15 - 5   = 562
+        vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;                // 583-1 - 15       = 567
+        vso_begin_odd   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc); // (2 + 4400/2) % 4400 = 2202
+        aml_write_reg32(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);   // 562
+        aml_write_reg32(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);   // 567
+        aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);  // 2202
+        aml_write_reg32(P_ENCP_DVI_VSO_END_ODD,   vso_begin_odd);  // 2202
+    }
+
+    // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+    aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                         (0                                 << 1) | // [    1] src_sel_encp
+                         (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                         (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                         (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                         (((TX_INPUT_COLOR_FORMAT==0)?1:0)  << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                    //                          0=output CrYCb(BRG);
+                                                                    //                          1=output YCbCr(RGB);
+                                                                    //                          2=output YCrCb(RBG);
+                                                                    //                          3=output CbCrY(GBR);
+                                                                    //                          4=output CbYCr(GRB);
+                                                                    //                          5=output CrCbY(BGR);
+                                                                    //                          6,7=Rsrv.
+#ifdef DOUBLE_CLK_720P_1080I
+                         (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+#else                         
+                         (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+#endif                         
+                         (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+    );
+    aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+
+}    
+
+static void hdmi_tvenc4k2k_set(Hdmi_tx_video_para_t* param)
+{
+    unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2; // Annie 01Sep2011: Change value from 3 to 2, due to video encoder path delay change.
+    unsigned long TOTAL_PIXELS = 4400, PIXEL_REPEAT_HDMI = 0, PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 3840;
+    unsigned FRONT_PORCH = 1020, HSYNC_PIXELS = 0, ACTIVE_LINES = 2160, INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0, VSYNC_LINES = 0;
+    unsigned LINES_F0 = 2250, LINES_F1 = 2250, BACK_PORCH = 0, EOF_LINES = 8, TOTAL_FRAMES = 0;
+
+    unsigned long total_pixels_venc = 0;
+    unsigned long active_pixels_venc = 0;
+    unsigned long front_porch_venc = 0;
+    unsigned long hsync_pixels_venc = 0;
+
+    unsigned long de_h_begin = 0, de_h_end = 0;
+    unsigned long de_v_begin_even = 0, de_v_end_even = 0, de_v_begin_odd = 0, de_v_end_odd = 0;
+    unsigned long hs_begin = 0, hs_end = 0;
+    unsigned long vs_adjust = 0;
+    unsigned long vs_bline_evn = 0, vs_eline_evn = 0, vs_bline_odd = 0, vs_eline_odd = 0;
+    unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+
+    if((param->VIC==HDMI_4k2k_30) || (param->VIC==HDMI_3840x2160p60_16x9) || (param->VIC==HDMI_3840x2160p50_16x9)){
+         INTERLACE_MODE     = 0;
+         PIXEL_REPEAT_VENC  = 0;
+         PIXEL_REPEAT_HDMI  = 0;
+         ACTIVE_PIXELS  =     (3840*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (2160/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 2250;
+         LINES_F1           = 2250;
+         FRONT_PORCH        = 176;
+         HSYNC_PIXELS       = 88;
+         BACK_PORCH         = 296;
+         EOF_LINES          = 8 + 1;
+         VSYNC_LINES        = 10;
+         SOF_LINES          = 72 + 1;
+         TOTAL_FRAMES       = 3;
+    }
+    else if(param->VIC==HDMI_4k2k_25){
+         INTERLACE_MODE     = 0;
+         PIXEL_REPEAT_VENC  = 0;
+         PIXEL_REPEAT_HDMI  = 0;
+         ACTIVE_PIXELS  =     (3840*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (2160/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 2250;
+         LINES_F1           = 2250;
+         FRONT_PORCH        = 1056;
+         HSYNC_PIXELS       = 88;
+         BACK_PORCH         = 296;
+         EOF_LINES          = 8 + 1;
+         VSYNC_LINES        = 10;
+         SOF_LINES          = 72 + 1;
+         TOTAL_FRAMES       = 3;
+    }
+    else if(param->VIC==HDMI_4k2k_24){
+         INTERLACE_MODE     = 0;
+         PIXEL_REPEAT_VENC  = 0;
+         PIXEL_REPEAT_HDMI  = 0;
+         ACTIVE_PIXELS  =     (3840*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (2160/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 2250;
+         LINES_F1           = 2250;
+         FRONT_PORCH        = 1276;
+         HSYNC_PIXELS       = 88;
+         BACK_PORCH         = 296;
+         EOF_LINES          = 8 + 1;
+         VSYNC_LINES        = 10;
+         SOF_LINES          = 72 + 1;
+         TOTAL_FRAMES       = 3;
+    }
+    else if(param->VIC==HDMI_4k2k_smpte_24){
+         INTERLACE_MODE     = 0;
+         PIXEL_REPEAT_VENC  = 0;
+         PIXEL_REPEAT_HDMI  = 0;
+         ACTIVE_PIXELS  =     (4096*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+         ACTIVE_LINES   =     (2160/(1+INTERLACE_MODE));    // Number of active lines per field.
+         LINES_F0           = 2250;
+         LINES_F1           = 2250;
+         FRONT_PORCH        = 1020;
+         HSYNC_PIXELS       = 88;
+         BACK_PORCH         = 296;
+         EOF_LINES          = 8 + 1;
+         VSYNC_LINES        = 10;
+         SOF_LINES          = 72 + 1;
+         TOTAL_FRAMES       = 3;
+    }
+    else {
+        // nothing
+    }
+
+    TOTAL_PIXELS       = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
+    TOTAL_LINES        = (LINES_F0+(LINES_F1*INTERLACE_MODE));                // Number of total lines per frame.
+
+    total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
+    active_pixels_venc= (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
+    front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
+    hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC);
+
+    de_h_begin = modulo(aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN) + VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc);
+    de_h_end   = modulo(de_h_begin + active_pixels_venc,                        total_pixels_venc);
+    aml_write_reg32(P_ENCP_DE_H_BEGIN, de_h_begin);
+    aml_write_reg32(P_ENCP_DE_H_END,   de_h_end);
+    // Program DE timing for even field
+    de_v_begin_even = aml_read_reg32(P_ENCP_VIDEO_VAVON_BLINE);
+    de_v_end_even   = modulo(de_v_begin_even + ACTIVE_LINES, TOTAL_LINES);
+    aml_write_reg32(P_ENCP_DE_V_BEGIN_EVEN,de_v_begin_even);
+    aml_write_reg32(P_ENCP_DE_V_END_EVEN,  de_v_end_even);
+    // Program DE timing for odd field if needed
+    if (INTERLACE_MODE) {
+        // Calculate de_v_begin_odd according to enc480p_timing.v:
+        //wire[10:0]    cfg_ofld_vavon_bline    = {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline    + ofld_line;
+        de_v_begin_odd  = to_signed((aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2;
+        de_v_end_odd    = modulo(de_v_begin_odd + ACTIVE_LINES, TOTAL_LINES);
+        aml_write_reg32(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
+        aml_write_reg32(P_ENCP_DE_V_END_ODD,   de_v_end_odd);
+    }
+
+    // Program Hsync timing
+    if (de_h_end + front_porch_venc >= total_pixels_venc) {
+        hs_begin    = de_h_end + front_porch_venc - total_pixels_venc;
+        vs_adjust   = 1;
+    } else {
+        hs_begin    = de_h_end + front_porch_venc;
+        vs_adjust   = 1;
+    }
+    hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc);
+    aml_write_reg32(P_ENCP_DVI_HSO_BEGIN,  hs_begin);
+    aml_write_reg32(P_ENCP_DVI_HSO_END,    hs_end);
+    
+    // Program Vsync timing for even field
+    if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust)) {
+        vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust);
+    } else {
+        vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust);
+    }
+    vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES);
+    aml_write_reg32(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);
+    aml_write_reg32(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);
+    vso_begin_evn = hs_begin;
+    aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);
+    aml_write_reg32(P_ENCP_DVI_VSO_END_EVN,   vso_begin_evn);
+    // Program Vsync timing for odd field if needed
+    if (INTERLACE_MODE) {
+        vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
+        vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
+        vso_begin_odd   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc);
+        aml_write_reg32(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
+        aml_write_reg32(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
+        aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+        aml_write_reg32(P_ENCP_DVI_VSO_END_ODD,   vso_begin_odd);
+    }
+    aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                         (0                                 << 1) | // [    1] src_sel_encp
+                         (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                         (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                         (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                         (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                    //                          0=output CrYCb(BRG);
+                                                                    //                          1=output YCbCr(RGB);
+                                                                    //                          2=output YCrCb(RBG);
+                                                                    //                          3=output CbCrY(GBR);
+                                                                    //                          4=output CbYCr(GRB);
+                                                                    //                          5=output CrCbY(BGR);
+                                                                    //                          6,7=Rsrv.
+                         (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                         (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+    );
+    aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+    aml_write_reg32(P_ENCP_VIDEO_EN, 1); // Enable VENC
+}
+
+static void hdmi_tvenc480i_set(Hdmi_tx_video_para_t* param)
+{
+    unsigned long VFIFO2VD_TO_HDMI_LATENCY = 1; // Annie 01Sep2011: Change value from 2 to 1, due to video encoder path delay change.
+    unsigned long TOTAL_PIXELS = 0, PIXEL_REPEAT_HDMI = 0, PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 0;
+    unsigned FRONT_PORCH = 38, HSYNC_PIXELS = 124, ACTIVE_LINES = 0, INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0, VSYNC_LINES = 0;
+    unsigned LINES_F0 = 262, LINES_F1 = 263, BACK_PORCH = 114, EOF_LINES = 2, TOTAL_FRAMES = 0;
+
+    unsigned long total_pixels_venc  = 0;
+    unsigned long active_pixels_venc = 0;
+    unsigned long front_porch_venc = 0;
+    unsigned long hsync_pixels_venc  = 0;
+
+    unsigned long de_h_begin = 0, de_h_end = 0;
+    unsigned long de_v_begin_even = 0, de_v_end_even = 0, de_v_begin_odd = 0, de_v_end_odd = 0;
+    unsigned long hs_begin = 0, hs_end = 0;
+    unsigned long vs_adjust = 0;
+    unsigned long vs_bline_evn = 0, vs_eline_evn = 0, vs_bline_odd = 0, vs_eline_odd = 0;
+    unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+
+    switch(param->VIC) {
+    case HDMI_480i60:
+    case HDMI_480i60_16x9:
+    case HDMI_480i60_16x9_rpt:
+        INTERLACE_MODE     = 1;
+        PIXEL_REPEAT_VENC  = 1;
+        PIXEL_REPEAT_HDMI  = 1;
+        ACTIVE_PIXELS      = (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+        ACTIVE_LINES       = (480/(1+INTERLACE_MODE));    // Number of active lines per field.
+        LINES_F0           = 262;
+        LINES_F1           = 263;
+        FRONT_PORCH        = 38;
+        HSYNC_PIXELS       = 124;
+        BACK_PORCH         = 114;
+        EOF_LINES          = 4;
+        VSYNC_LINES        = 3;
+        SOF_LINES          = 15;
+        TOTAL_FRAMES       = 4;
+        break;
+    case HDMI_576i50:
+    case HDMI_576i50_16x9:
+    case HDMI_576i50_16x9_rpt:
+        INTERLACE_MODE     = 1;
+        PIXEL_REPEAT_VENC  = 1;
+        PIXEL_REPEAT_HDMI  = 1;
+        ACTIVE_PIXELS      = (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+        ACTIVE_LINES       = (576/(1+INTERLACE_MODE));    // Number of active lines per field.
+        LINES_F0           = 312;
+        LINES_F1           = 313;
+        FRONT_PORCH        = 24;
+        HSYNC_PIXELS       = 126;
+        BACK_PORCH         = 138;
+        EOF_LINES          = 2;
+        VSYNC_LINES        = 3;
+        SOF_LINES          = 19;
+        TOTAL_FRAMES       = 4;
+        break;
+    default:
+        break;
+    }
+
+    TOTAL_PIXELS =(FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
+    TOTAL_LINES  =(LINES_F0+(LINES_F1*INTERLACE_MODE));                // Number of total lines per frame.
+
+    total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 1716 / 2 * 2 = 1716
+    active_pixels_venc= (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 1440 / 2 * 2 = 1440
+    front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 38   / 2 * 2 = 38
+    hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 124  / 2 * 2 = 124
+
+    // Annie 01Sep2011: Comment out the following 2 lines. Because ENCP is not used for 480i and 576i.
+    //Wr(ENCP_VIDEO_MODE,Rd(ENCP_VIDEO_MODE)|(1<<14)); // cfg_de_v = 1
+
+    // Program DE timing
+    // Annie 01Sep2011: for 480/576i, replace VFIFO2VD_PIXEL_START with ENCI_VFIFO2VD_PIXEL_START.
+    de_h_begin = modulo(aml_read_reg32(P_ENCI_VFIFO2VD_PIXEL_START) + VFIFO2VD_TO_HDMI_LATENCY,   total_pixels_venc); // (233 + 2) % 1716 = 235
+    de_h_end   = modulo(de_h_begin + active_pixels_venc, total_pixels_venc); // (235 + 1440) % 1716 = 1675
+    aml_write_reg32(P_ENCI_DE_H_BEGIN, de_h_begin);    // 235
+    aml_write_reg32(P_ENCI_DE_H_END,   de_h_end);      // 1675
+
+    // Annie 01Sep2011: for 480/576i, replace VFIFO2VD_LINE_TOP/BOT_START with ENCI_VFIFO2VD_LINE_TOP/BOT_START.
+    de_v_begin_even = aml_read_reg32(P_ENCI_VFIFO2VD_LINE_TOP_START);      // 17
+    de_v_end_even   = de_v_begin_even + ACTIVE_LINES;   // 17 + 240 = 257
+    de_v_begin_odd  = aml_read_reg32(P_ENCI_VFIFO2VD_LINE_BOT_START);      // 18
+    de_v_end_odd    = de_v_begin_odd + ACTIVE_LINES;    // 18 + 480/2 = 258
+    aml_write_reg32(P_ENCI_DE_V_BEGIN_EVEN,de_v_begin_even);   // 17
+    aml_write_reg32(P_ENCI_DE_V_END_EVEN,  de_v_end_even);     // 257
+    aml_write_reg32(P_ENCI_DE_V_BEGIN_ODD, de_v_begin_odd);    // 18
+    aml_write_reg32(P_ENCI_DE_V_END_ODD,   de_v_end_odd);      // 258
+
+    // Program Hsync timing
+    if (de_h_end + front_porch_venc >= total_pixels_venc) {
+        hs_begin    = de_h_end + front_porch_venc - total_pixels_venc;
+        vs_adjust   = 1;
+    } else {
+        hs_begin    = de_h_end + front_porch_venc; // 1675 + 38 = 1713
+        vs_adjust   = 0;
+    }
+    hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc); // (1713 + 124) % 1716 = 121
+    aml_write_reg32(P_ENCI_DVI_HSO_BEGIN,  hs_begin);  // 1713
+    aml_write_reg32(P_ENCI_DVI_HSO_END,    hs_end);    // 121
+    
+    // Program Vsync timing for even field
+    if (de_v_end_odd-1 + EOF_LINES + vs_adjust >= LINES_F1) {
+        vs_bline_evn = de_v_end_odd-1 + EOF_LINES + vs_adjust - LINES_F1;
+        vs_eline_evn = vs_bline_evn + VSYNC_LINES;
+        aml_write_reg32(P_ENCI_DVI_VSO_BLINE_EVN, vs_bline_evn);
+        //vso_bline_evn_reg_wr_cnt ++;
+        aml_write_reg32(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+        //vso_eline_evn_reg_wr_cnt ++;
+        aml_write_reg32(P_ENCI_DVI_VSO_BEGIN_EVN, hs_begin);
+        aml_write_reg32(P_ENCI_DVI_VSO_END_EVN,   hs_begin);
+    } else {
+        vs_bline_odd = de_v_end_odd-1 + EOF_LINES + vs_adjust; // 258-1 + 4 + 0 = 261
+        aml_write_reg32(P_ENCI_DVI_VSO_BLINE_ODD, vs_bline_odd); // 261
+        //vso_bline_odd_reg_wr_cnt ++;
+        aml_write_reg32(P_ENCI_DVI_VSO_BEGIN_ODD, hs_begin);  // 1713
+        if (vs_bline_odd + VSYNC_LINES >= LINES_F1) {
+            vs_eline_evn = vs_bline_odd + VSYNC_LINES - LINES_F1; // 261 + 3 - 263 = 1
+            aml_write_reg32(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);   // 1
+            //vso_eline_evn_reg_wr_cnt ++;
+            aml_write_reg32(P_ENCI_DVI_VSO_END_EVN,   hs_begin);       // 1713
+        } else {
+            vs_eline_odd = vs_bline_odd + VSYNC_LINES;
+            aml_write_reg32(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+            //vso_eline_odd_reg_wr_cnt ++;
+            aml_write_reg32(P_ENCI_DVI_VSO_END_ODD,   hs_begin);
+        }
+    }
+    // Program Vsync timing for odd field
+    if (de_v_end_even-1 + EOF_LINES + 1 >= LINES_F0) {
+        vs_bline_odd = de_v_end_even-1 + EOF_LINES + 1 - LINES_F0;
+        vs_eline_odd = vs_bline_odd + VSYNC_LINES;
+        aml_write_reg32(P_ENCI_DVI_VSO_BLINE_ODD, vs_bline_odd);
+        //vso_bline_odd_reg_wr_cnt ++;
+        aml_write_reg32(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);
+        //vso_eline_odd_reg_wr_cnt ++;
+        vso_begin_odd   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc);
+        aml_write_reg32(P_ENCI_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+        aml_write_reg32(P_ENCI_DVI_VSO_END_ODD,   vso_begin_odd);
+    } else {
+        vs_bline_evn = de_v_end_even-1 + EOF_LINES + 1; // 257-1 + 4 + 1 = 261
+        aml_write_reg32(P_ENCI_DVI_VSO_BLINE_EVN, vs_bline_evn); // 261
+        //vso_bline_evn_reg_wr_cnt ++;
+        vso_begin_evn   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc);   // (1713 + 1716/2) % 1716 = 855
+        aml_write_reg32(P_ENCI_DVI_VSO_BEGIN_EVN, vso_begin_evn);  // 855
+        if (vs_bline_evn + VSYNC_LINES >= LINES_F0) {
+            vs_eline_odd = vs_bline_evn + VSYNC_LINES - LINES_F0; // 261 + 3 - 262 = 2
+            aml_write_reg32(P_ENCI_DVI_VSO_ELINE_ODD, vs_eline_odd);   // 2
+            //vso_eline_odd_reg_wr_cnt ++;
+            aml_write_reg32(P_ENCI_DVI_VSO_END_ODD,   vso_begin_evn);  // 855
+        } else {
+            vs_eline_evn = vs_bline_evn + VSYNC_LINES;
+            aml_write_reg32(P_ENCI_DVI_VSO_ELINE_EVN, vs_eline_evn);
+            //vso_eline_evn_reg_wr_cnt ++;
+            aml_write_reg32(P_ENCI_DVI_VSO_END_EVN,   vso_begin_evn);
+        }
+    }
+
+    // Check if there are duplicate or missing timing settings
+    //if ((vso_bline_evn_reg_wr_cnt != 1) || (vso_bline_odd_reg_wr_cnt != 1) ||
+    //    (vso_eline_evn_reg_wr_cnt != 1) || (vso_eline_odd_reg_wr_cnt != 1)) {
+        //printk("[TEST.C] Error: Multiple or missing timing settings on reg ENCI_DVI_VSO_B(E)LINE_EVN(ODD)!\n");
+        //stimulus_finish_fail(1);
+    //}
+
+    // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+    aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                         (0                                 << 1) | // [    1] src_sel_encp
+                         (0                                 << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                         (0                                 << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                         (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                         (((TX_INPUT_COLOR_FORMAT==0)?1:0)  << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                    //                          0=output CrYCb(BRG);
+                                                                    //                          1=output YCbCr(RGB);
+                                                                    //                          2=output YCrCb(RBG);
+                                                                    //                          3=output CbCrY(GBR);
+                                                                    //                          4=output CbYCr(GRB);
+                                                                    //                          5=output CrCbY(BGR);
+                                                                    //                          6,7=Rsrv.
+                         (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                         (1                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+    );
+    if((param->VIC == HDMI_480i60_16x9_rpt) || (param->VIC == HDMI_576i50_16x9_rpt)) {
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, 3, 12, 4);
+    }
+    aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 0, 1);  // [    0] src_sel_enci: Enable ENCI output to HDMI
+
+}    
+
+static void hdmi_tvenc_set(Hdmi_tx_video_para_t *param)
+{
+    unsigned long VFIFO2VD_TO_HDMI_LATENCY = 2; // Annie 01Sep2011: Change value from 3 to 2, due to video encoder path delay change.
+    unsigned long TOTAL_PIXELS = 0, PIXEL_REPEAT_HDMI = 0, PIXEL_REPEAT_VENC = 0, ACTIVE_PIXELS = 0;
+    unsigned FRONT_PORCH = 0, HSYNC_PIXELS = 0, ACTIVE_LINES = 0, INTERLACE_MODE = 0, TOTAL_LINES = 0, SOF_LINES = 0, VSYNC_LINES = 0;
+    unsigned LINES_F0 = 0, LINES_F1 = 0, BACK_PORCH = 0, EOF_LINES = 0, TOTAL_FRAMES = 0;
+
+    unsigned long total_pixels_venc = 0;
+    unsigned long active_pixels_venc = 0;
+    unsigned long front_porch_venc = 0;
+    unsigned long hsync_pixels_venc = 0;
+
+    unsigned long de_h_begin = 0, de_h_end = 0;
+    unsigned long de_v_begin_even = 0, de_v_end_even = 0, de_v_begin_odd = 0, de_v_end_odd = 0;
+    unsigned long hs_begin = 0, hs_end = 0;
+    unsigned long vs_adjust = 0;
+    unsigned long vs_bline_evn = 0, vs_eline_evn = 0, vs_bline_odd = 0, vs_eline_odd = 0;
+    unsigned long vso_begin_evn = 0, vso_begin_odd = 0;
+
+    switch(param->VIC) {
+    case HDMI_480p60:
+    case HDMI_480p60_16x9:
+    case HDMI_480p60_16x9_rpt:
+        INTERLACE_MODE     = 0;
+        PIXEL_REPEAT_VENC  = 1;
+        PIXEL_REPEAT_HDMI  = 0;
+        ACTIVE_PIXELS      = (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+        ACTIVE_LINES       = (480/(1+INTERLACE_MODE));    // Number of active lines per field.
+        LINES_F0           = 525;
+        LINES_F1           = 525;
+        FRONT_PORCH        = 16;
+        HSYNC_PIXELS       = 62;
+        BACK_PORCH         = 60;
+        EOF_LINES          = 9;
+        VSYNC_LINES        = 6;
+        SOF_LINES          = 30;
+        TOTAL_FRAMES       = 4;
+        break;
+    case HDMI_576p50:
+    case HDMI_576p50_16x9:
+    case HDMI_576p50_16x9_rpt:
+        INTERLACE_MODE     = 0;
+        PIXEL_REPEAT_VENC  = 1;
+        PIXEL_REPEAT_HDMI  = 0;
+        ACTIVE_PIXELS      = (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+        ACTIVE_LINES       = (576/(1+INTERLACE_MODE));    // Number of active lines per field.
+        LINES_F0           = 625;
+        LINES_F1           = 625;
+        FRONT_PORCH        = 12;
+        HSYNC_PIXELS       = 64;
+        BACK_PORCH         = 68;
+        EOF_LINES          = 5;
+        VSYNC_LINES        = 5;
+        SOF_LINES          = 39;
+        TOTAL_FRAMES       = 4;
+        break;
+    case HDMI_720p60:
+        INTERLACE_MODE     = 0;
+        PIXEL_REPEAT_VENC  = 1;
+        PIXEL_REPEAT_HDMI  = 0;
+        ACTIVE_PIXELS      = (1280*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+        ACTIVE_LINES       = (720/(1+INTERLACE_MODE));    // Number of active lines per field.
+        LINES_F0           = 750;
+        LINES_F1           = 750;
+        FRONT_PORCH        = 110;
+        HSYNC_PIXELS       = 40;
+        BACK_PORCH         = 220;
+        EOF_LINES          = 5;
+        VSYNC_LINES        = 5;
+        SOF_LINES          = 20;
+        TOTAL_FRAMES       = 4;
+        break;
+    case HDMI_720p50:
+        INTERLACE_MODE     = 0;
+        PIXEL_REPEAT_VENC  = 1;
+        PIXEL_REPEAT_HDMI  = 0;
+        ACTIVE_PIXELS      = (1280*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+        ACTIVE_LINES       = (720/(1+INTERLACE_MODE));    // Number of active lines per field.
+        LINES_F0           = 750;
+        LINES_F1           = 750;
+        FRONT_PORCH        = 440;
+        HSYNC_PIXELS       = 40;
+        BACK_PORCH         = 220;
+        EOF_LINES          = 5;
+        VSYNC_LINES        = 5;
+        SOF_LINES          = 20;
+        TOTAL_FRAMES       = 4;
+        break;
+    case HDMI_1080p50:
+        INTERLACE_MODE      = 0;
+        PIXEL_REPEAT_VENC   = 0;
+        PIXEL_REPEAT_HDMI   = 0;
+        ACTIVE_PIXELS       = (1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+        ACTIVE_LINES        = (1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+        LINES_F0            = 1125;
+        LINES_F1            = 1125;
+        FRONT_PORCH         = 528;
+        HSYNC_PIXELS        = 44;
+        BACK_PORCH          = 148;
+        EOF_LINES           = 4;
+        VSYNC_LINES         = 5;
+        SOF_LINES           = 36;
+        TOTAL_FRAMES        = 4;
+        break;
+    case HDMI_1080p24:
+        INTERLACE_MODE      = 0;
+        PIXEL_REPEAT_VENC   = 0;
+        PIXEL_REPEAT_HDMI   = 0;
+        ACTIVE_PIXELS       = (1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+        ACTIVE_LINES        = (1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+        LINES_F0            = 1125;
+        LINES_F1            = 1125;
+        FRONT_PORCH         = 638;
+        HSYNC_PIXELS        = 44;
+        BACK_PORCH          = 148;
+        EOF_LINES           = 4;
+        VSYNC_LINES         = 5;
+        SOF_LINES           = 36;
+        TOTAL_FRAMES        = 4;
+        break;
+    case HDMI_1080p60:
+    case HDMI_1080p30:
+        INTERLACE_MODE      = 0;
+        PIXEL_REPEAT_VENC   = 0;
+        PIXEL_REPEAT_HDMI   = 0;
+        ACTIVE_PIXELS       = (1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
+        ACTIVE_LINES        = (1080/(1+INTERLACE_MODE));    // Number of active lines per field.
+        LINES_F0            = 1125;
+        LINES_F1            = 1125;
+        FRONT_PORCH         = 88;
+        HSYNC_PIXELS        = 44;
+        BACK_PORCH          = 148;
+        EOF_LINES           = 4;
+        VSYNC_LINES         = 5;
+        SOF_LINES           = 36;
+        TOTAL_FRAMES        = 4;
+        break;
+    default:
+        break;
+    }
+
+    TOTAL_PIXELS       = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
+    TOTAL_LINES        = (LINES_F0+(LINES_F1*INTERLACE_MODE));                // Number of total lines per frame.
+
+    total_pixels_venc = (TOTAL_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 858 / 1 * 2 = 1716
+    active_pixels_venc= (ACTIVE_PIXELS / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 720 / 1 * 2 = 1440
+    front_porch_venc  = (FRONT_PORCH   / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 16   / 1 * 2 = 32
+    hsync_pixels_venc = (HSYNC_PIXELS  / (1+PIXEL_REPEAT_HDMI)) * (1+PIXEL_REPEAT_VENC); // 62   / 1 * 2 = 124
+
+    aml_write_reg32(P_ENCP_VIDEO_MODE,aml_read_reg32(P_ENCP_VIDEO_MODE)|(1<<14)); // cfg_de_v = 1
+    // Program DE timing
+    de_h_begin = modulo(aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN) + VFIFO2VD_TO_HDMI_LATENCY,  total_pixels_venc); // (217 + 3) % 1716 = 220
+    de_h_end   = modulo(de_h_begin + active_pixels_venc,                        total_pixels_venc); // (220 + 1440) % 1716 = 1660
+    aml_write_reg32(P_ENCP_DE_H_BEGIN, de_h_begin);    // 220
+    aml_write_reg32(P_ENCP_DE_H_END,   de_h_end);      // 1660
+    // Program DE timing for even field
+    de_v_begin_even = aml_read_reg32(P_ENCP_VIDEO_VAVON_BLINE);       // 42
+    de_v_end_even   = de_v_begin_even + ACTIVE_LINES;   // 42 + 480 = 522
+    aml_write_reg32(P_ENCP_DE_V_BEGIN_EVEN,de_v_begin_even);   // 42
+    aml_write_reg32(P_ENCP_DE_V_END_EVEN,  de_v_end_even);     // 522
+    // Program DE timing for odd field if needed
+    if (INTERLACE_MODE) {
+        // Calculate de_v_begin_odd according to enc480p_timing.v:
+        //wire[10:0]    cfg_ofld_vavon_bline    = {{7{ofld_vavon_ofst1 [3]}},ofld_vavon_ofst1 [3:0]} + cfg_video_vavon_bline    + ofld_line;
+        de_v_begin_odd  = to_signed((aml_read_reg32(P_ENCP_VIDEO_OFLD_VOAV_OFST) & 0xf0)>>4) + de_v_begin_even + (TOTAL_LINES-1)/2;
+        de_v_end_odd    = de_v_begin_odd + ACTIVE_LINES;
+        aml_write_reg32(P_ENCP_DE_V_BEGIN_ODD, de_v_begin_odd);
+        aml_write_reg32(P_ENCP_DE_V_END_ODD,   de_v_end_odd);
+    }
+
+    // Program Hsync timing
+    if (de_h_end + front_porch_venc >= total_pixels_venc) {
+        hs_begin    = de_h_end + front_porch_venc - total_pixels_venc;
+        vs_adjust   = 1;
+    } else {
+        hs_begin    = de_h_end + front_porch_venc; // 1660 + 32 = 1692
+        vs_adjust   = 0;
+    }
+    hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc); // (1692 + 124) % 1716 = 100
+    aml_write_reg32(P_ENCP_DVI_HSO_BEGIN,  hs_begin);  // 1692
+    aml_write_reg32(P_ENCP_DVI_HSO_END,    hs_end);    // 100
+    
+    // Program Vsync timing for even field
+    if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust)) {
+        vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust); // 42 - 30 - 6 - 1 = 5
+    } else {
+        vs_bline_evn = TOTAL_LINES + de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust);
+    }
+    vs_eline_evn = modulo(vs_bline_evn + VSYNC_LINES, TOTAL_LINES); // (5 + 6) % 525 = 11
+    aml_write_reg32(P_ENCP_DVI_VSO_BLINE_EVN, vs_bline_evn);   // 5
+    aml_write_reg32(P_ENCP_DVI_VSO_ELINE_EVN, vs_eline_evn);   // 11
+    vso_begin_evn = hs_begin; // 1692
+    aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_EVN, vso_begin_evn);  // 1692
+    aml_write_reg32(P_ENCP_DVI_VSO_END_EVN,   vso_begin_evn);  // 1692
+    // Program Vsync timing for odd field if needed
+    if (INTERLACE_MODE) {
+        vs_bline_odd = de_v_begin_odd-1 - SOF_LINES - VSYNC_LINES;
+        vs_eline_odd = de_v_begin_odd-1 - SOF_LINES;
+        vso_begin_odd   = modulo(hs_begin + (total_pixels_venc>>1), total_pixels_venc);
+        aml_write_reg32(P_ENCP_DVI_VSO_BLINE_ODD, vs_bline_odd);
+        aml_write_reg32(P_ENCP_DVI_VSO_ELINE_ODD, vs_eline_odd);
+        aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_ODD, vso_begin_odd);
+        aml_write_reg32(P_ENCP_DVI_VSO_END_ODD,   vso_begin_odd);
+    }
+    // Annie 01Sep2011: Remove the following line as register VENC_DVI_SETTING_MORE is no long valid, use VPU_HDMI_SETTING instead.
+    //Wr(VENC_DVI_SETTING_MORE, (TX_INPUT_COLOR_FORMAT==0)? 1 : 0); // [0] 0=Map data pins from Venc to Hdmi Tx as CrYCb mode;
+
+    switch(param->VIC)
+    {
+        case HDMI_480p60:
+        case HDMI_480p60_16x9:
+        case HDMI_480p60_16x9_rpt:
+        case HDMI_576p50:
+        case HDMI_576p50_16x9:
+        case HDMI_576p50_16x9_rpt:
+//Note: Hsync & Vsync polarity should be negative.
+//Refer to HDMI CTS 1.4A Page 169
+            // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+            aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                                 (0                                 << 1) | // [    1] src_sel_encp
+                                 (0                                 << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                                 (0                                 << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                                 (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                                 (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                            //                          0=output CrYCb(BRG);
+                                                                            //                          1=output YCbCr(RGB);
+                                                                            //                          2=output YCrCb(RBG);
+                                                                            //                          3=output CbCrY(GBR);
+                                                                            //                          4=output CbYCr(GRB);
+                                                                            //                          5=output CrCbY(BGR);
+                                                                            //                          6,7=Rsrv.
+                                 (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                                 (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+            );
+            break;
+        case HDMI_720p60:
+        case HDMI_720p50:
+            // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+            aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                                 (0                                 << 1) | // [    1] src_sel_encp
+                                 (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                                 (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                                 (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                                 (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                            //                          0=output CrYCb(BRG);
+                                                                            //                          1=output YCbCr(RGB);
+                                                                            //                          2=output YCrCb(RBG);
+                                                                            //                          3=output CbCrY(GBR);
+                                                                            //                          4=output CbYCr(GRB);
+                                                                            //                          5=output CrCbY(BGR);
+                                                                            //                          6,7=Rsrv.
+#ifdef DOUBLE_CLK_720P_1080I
+                                 (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+#else
+                                 (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+#endif                             
+                                 (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+            );
+            break;
+        default:
+            // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+            aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                                 (0                                 << 1) | // [    1] src_sel_encp
+                                 (HSYNC_POLARITY                    << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                                 (VSYNC_POLARITY                    << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                                 (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                                 (4                                 << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                            //                          0=output CrYCb(BRG);
+                                                                            //                          1=output YCbCr(RGB);
+                                                                            //                          2=output YCrCb(RBG);
+                                                                            //                          3=output CbCrY(GBR);
+                                                                            //                          4=output CbYCr(GRB);
+                                                                            //                          5=output CrCbY(BGR);
+                                                                            //                          6,7=Rsrv.
+                                 (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                                 (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+            );
+    }
+
+    if((param->VIC == HDMI_480p60_16x9_rpt) || (param->VIC == HDMI_576p50_16x9_rpt)) {
+        aml_set_reg32_bits(P_VPU_HDMI_SETTING, 3, 12, 4);
+    }
+    // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
+    aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+}    
+
+static void digital_clk_off(unsigned char flag)
+{
+    // TODO
+}
+
+static void digital_clk_on(unsigned char flag)
+{
+//    clk81_set();
+    if(flag&4){
+        /* on hdmi sys clock */
+        // -----------------------------------------
+        // HDMI (90Mhz)
+        // -----------------------------------------
+        //         .clk_div            ( hi_hdmi_clk_cntl[6:0] ),
+        //         .clk_en             ( hi_hdmi_clk_cntl[8]   ),
+        //         .clk_sel            ( hi_hdmi_clk_cntl[11:9]),
+        aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 0, 0, 7);    // Divide the "other" PLL output by 1
+        aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 0, 9, 3);    // select "XTAL" PLL
+        aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 1, 8, 1);    // Enable gated clock
+//        Wr( HHI_HDMI_CLK_CNTL,  ((2 << 9)  |   // select "misc" PLL
+//                                 (1 << 8)  |   // Enable gated clock
+//                                 (5 << 0)) );  // Divide the "other" PLL output by 6
+    }
+    if(flag&2){
+        /* on hdmi pixel clock */
+        aml_write_reg32(P_HHI_GCLK_MPEG2, aml_read_reg32(P_HHI_GCLK_MPEG2) | (1<<4));     //Enable HDMI PCLK
+//        Wr(HHI_GCLK_MPEG2, Rd(HHI_GCLK_MPEG2)|(1<<4)); //enable pixel clock, set cbus reg HHI_GCLK_MPEG2 bit [4] = 1
+        aml_write_reg32(P_HHI_GCLK_OTHER, aml_read_reg32(P_HHI_GCLK_OTHER)|(1<<17)); //enable VCLK1_HDMI GATE, set cbus reg HHI_GCLK_OTHER bit [17] = 1
+    }
+    if(flag&1){
+    }  
+}
+
+static void phy_pll_off(void)
+{
+    hdmi_phy_suspend();
+}
+
+/**/
+void hdmi_hw_set_powermode(hdmitx_dev_t* hdmitx_device)
+{
+    int vic = hdmitx_device->cur_VIC;
+
+    switch(vic) {
+    case HDMI_480i60:
+    case HDMI_480i60_16x9:
+    case HDMI_576p50:
+    case HDMI_576p50_16x9:
+    case HDMI_576i50:
+    case HDMI_576i50_16x9:
+    case HDMI_480p60:
+    case HDMI_480p60_16x9:
+    case HDMI_720p50:
+    case HDMI_720p60:
+    case HDMI_1080i50:
+    case HDMI_1080i60:
+    case HDMI_1080p24://1080p24 support
+    case HDMI_1080p50:
+    case HDMI_1080p60:
+    default:
+        //aml_write_reg32(P_HHI_HDMI_PHY_CNTL0, 0x08c38d0b);
+        break;
+    }
+    //aml_write_reg32(P_HHI_HDMI_PHY_CNTL1, 2);
+}
+
+#if 0
+// When have below format output, we shall manually configure
+// bolow register to get stable Video Timing.
+static void hdmi_reconfig_packet_setting(HDMI_Video_Codes_t vic)
+{
+    //TODO
+}
+#endif
+
+static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *param)
+{
+    // reset REG init
+    // TODO
+}
+
+static void hdmi_audio_init(unsigned char spdif_flag)
+{
+    // TODO
+}
+
+static void enable_audio_spdif(void)
+{    
+    hdmi_print(INF, AUD "Enable audio spdif to HDMI\n");
+
+    // TODO
+}
+
+static void enable_audio_i2s(void)
+{
+    hdmi_print(INF, AUD "Enable audio i2s to HDMI\n");
+    // TODO
+}    
+
+/************************************
+*    hdmitx hardware level interface
+*************************************/
+
+static void hdmitx_dump_tvenc_reg(int cur_VIC, int printk_flag) 
+{
+    int i,j;
+    for(i=0;hdmi_tvenc_configs[i].vic!=HDMI_Unkown;i++){
+        if(cur_VIC==hdmi_tvenc_configs[i].vic){
+            reg_t* reg_set=hdmi_tvenc_configs[i].reg_set;
+            hdmi_print(printk_flag, "------dump tevenc reg for mode %d----\n", cur_VIC);
+            for(j=0;reg_set[j].reg;j++){
+                hdmi_print(printk_flag, "[%08x]=%08x\n",reg_set[j].reg,aml_read_reg32(CBUS_REG_ADDR(reg_set[j].reg)));
+            }
+            hdmi_print(printk_flag, "------------------\n");
+            break;
+        }
+    }
+}    
+
+static void hdmitx_config_tvenc_reg(int vic, unsigned reg, unsigned val)
+{
+    int i,j;
+    for(i=0;hdmi_tvenc_configs[i].vic!=HDMI_Unkown;i++){
+        if(vic==hdmi_tvenc_configs[i].vic){
+            reg_t* reg_set=hdmi_tvenc_configs[i].reg_set;
+            for(j=0;reg_set[j].reg;j++){
+                if(reg_set[j].reg==reg){
+                    reg_set[j].val = val;    
+                    hdmi_print(INF, SYS "set [%08x]=%08x\n",reg_set[j].reg, reg_set[j].val);
+                    break;
+                }
+            }
+            if(reg_set[j].reg == 0){
+                hdmi_print(INF, SYS "no [%08x] in config\n", reg);
+            }
+            break;
+        }
+    }
+}
+
+static void hdmitx_set_pll(Hdmi_tx_video_para_t *param)
+{
+    hdmi_print(IMP, SYS "set pll\n");
+    hdmi_print(IMP, SYS "param->VIC:%d\n", param->VIC);
+    
+    cur_vout_index = get_cur_vout_index();
+    switch(param->VIC)
+    {
+        case HDMI_480p60:
+        case HDMI_480p60_16x9:
+            set_vmode_clk(VMODE_480P);
+            break;
+        case HDMI_576p50:
+        case HDMI_576p50_16x9:
+            set_vmode_clk(VMODE_576P);
+            break;
+        case HDMI_480i60_16x9_rpt:
+            set_vmode_clk(VMODE_480I_RPT);
+            break;
+        case HDMI_480p60_16x9_rpt:
+            set_vmode_clk(VMODE_480P_RPT);
+            break;
+        case HDMI_576i50_16x9_rpt:
+            set_vmode_clk(VMODE_576I_RPT);
+            break;
+        case HDMI_576p50_16x9_rpt:
+            set_vmode_clk(VMODE_576P_RPT);
+            break;
+        case HDMI_480i60:
+        case HDMI_480i60_16x9:
+            set_vmode_clk(VMODE_480I);
+            break;
+        case HDMI_576i50:
+        case HDMI_576i50_16x9:
+            set_vmode_clk(VMODE_576I);
+            break;
+        case HDMI_1080p24://1080p24 support
+            set_vmode_clk(VMODE_1080P_24HZ);
+            break;
+        case HDMI_1080p30:
+        case HDMI_720p60:
+        case HDMI_720p50:
+            set_vmode_clk(VMODE_720P);
+            break;
+        case HDMI_1080i60:
+        case HDMI_1080i50:
+            set_vmode_clk(VMODE_1080I);
+            break;
+        case HDMI_1080p60:
+        case HDMI_1080p50:
+            set_vmode_clk(VMODE_1080P);
+            break;
+        case HDMI_4k2k_30:
+        case HDMI_4k2k_25:
+        case HDMI_4k2k_24:
+        case HDMI_4k2k_smpte_24:
+            set_vmode_clk(VMODE_4K2K_24HZ);
+            break;
+        case HDMI_3840x2160p60_16x9:
+            set_vmode_clk(VMODE_4K2K_60HZ);
+            break;
+        case HDMI_3840x2160p50_16x9:
+            set_vmode_clk(VMODE_4K2K_FAKE_5G);
+            break;
+        default:
+            break;
+    }
+}
+
+static void hdmitx_set_phy(hdmitx_dev_t* hdmitx_device)
+{
+    if(!hdmitx_device)
+        return;
+
+    switch(hdmitx_device->cur_VIC) {
+    case HDMI_3840x2160p50_16x9:
+    case HDMI_3840x2160p60_16x9:
+    case HDMI_4096x2160p50_256x135:
+    case HDMI_4096x2160p60_256x135:
+        aml_write_reg32(P_HHI_HDMI_PHY_CNTL0, 0x33b544ab);
+        aml_write_reg32(P_HHI_HDMI_PHY_CNTL3, 0x303e0003);
+        break;
+    case HDMI_1080p60:
+    case HDMI_4k2k_24:
+    case HDMI_4k2k_25:
+    case HDMI_4k2k_30:
+    case HDMI_4k2k_smpte_24:
+    default:
+        aml_write_reg32(P_HHI_HDMI_PHY_CNTL0, 0x33b544ab);
+        aml_write_reg32(P_HHI_HDMI_PHY_CNTL3, 0x303e005b);
+        break;
+    }
+// P_HHI_HDMI_PHY_CNTL1     bit[1]: enable clock    bit[0]: soft reset
+#define RESET_HDMI_PHY()                        \
+    aml_write_reg32(P_HHI_HDMI_PHY_CNTL1, 0xf);   \
+    msleep(1);                                  \
+    aml_write_reg32(P_HHI_HDMI_PHY_CNTL1, 0xe);   \
+    msleep(1)
+
+    aml_write_reg32(P_HHI_HDMI_PHY_CNTL1, 0x0);
+    RESET_HDMI_PHY();
+    RESET_HDMI_PHY();
+    RESET_HDMI_PHY();
+#undef RESET_HDMI_PHY
+    hdmi_print(IMP, SYS "phy setting done\n");
+}
+
+static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *param)
+{
+    if(param == NULL){ //disable HDMI
+        return 0;
+    }
+    else {
+        if(!hdmitx_edid_VIC_support(param->VIC))
+            return -1;
+    }
+
+    if(color_depth_f==24)
+        param->color_depth = COLOR_24BIT;
+    else if(color_depth_f==30)
+        param->color_depth = COLOR_30BIT;
+    else if(color_depth_f==36)
+        param->color_depth = COLOR_36BIT;
+    else if(color_depth_f==48)
+        param->color_depth = COLOR_48BIT;
+    hdmi_print(INF, SYS "set mode VIC %d (cd%d,cs%d,pm%d,vd%d,%x) \n",param->VIC, color_depth_f, color_space_f,power_mode,power_off_vdac_flag,serial_reg_val);
+    if(color_space_f != 0){
+        param->color = color_space_f;
+    }
+    C_Entry(param->VIC);
+    hdmitx_set_pll(param);
+    hdmitx_set_phy(hdmitx_device);
+    switch(param->VIC){
+    case HDMI_480i60:
+    case HDMI_480i60_16x9:
+    case HDMI_576i50:
+    case HDMI_576i50_16x9:
+    case HDMI_480i60_16x9_rpt:
+    case HDMI_576i50_16x9_rpt:
+        hdmi_tvenc480i_set(param);
+        break;
+    case HDMI_1080i60:
+    case HDMI_1080i50:
+        hdmi_tvenc1080i_set(param);
+        break;
+    case HDMI_4k2k_30:
+    case HDMI_4k2k_25:
+    case HDMI_4k2k_24:
+    case HDMI_4k2k_smpte_24:
+    case HDMI_3840x2160p50_16x9:
+    case HDMI_3840x2160p60_16x9:
+        hdmi_tvenc4k2k_set(param);
+        break;
+    default:
+        hdmi_tvenc_set(param);
+    }
+
+printk("1c37 0x%x\n", aml_read_reg32(P_ENCP_DVI_VSO_BEGIN_ODD));
+printk("1c39 0x%x\n", aml_read_reg32(P_ENCP_DVI_VSO_END_ODD));
+printk("1c3d 0x%x\n", aml_read_reg32(P_ENCP_DE_V_END_EVEN));
+printk("1c3f 0x%x\n", aml_read_reg32(P_ENCP_DE_V_END_ODD));
+if(param->VIC == HDMI_1920x1080p60_16x9) {
+    aml_write_reg32(P_ENCP_DVI_VSO_BEGIN_ODD, 0x111);
+    aml_write_reg32(P_ENCP_DVI_VSO_END_ODD, 0x111);
+    aml_write_reg32(P_ENCP_DE_V_END_EVEN, 0x0);
+    aml_write_reg32(P_ENCP_DE_V_END_ODD, 0x2a);
+}
+    switch(param->VIC) {
+    case HDMI_480i60:
+    case HDMI_480i60_16x9:
+    case HDMI_576i50:
+    case HDMI_576i50_16x9:
+    case HDMI_480i60_16x9_rpt:
+    case HDMI_576i50_16x9_rpt:
+        enc_vpu_bridge_reset(0);
+        break;
+    default:
+        enc_vpu_bridge_reset(1);
+        break;
+    }
+
+    hdmi_hw_reset(hdmitx_device, param);    
+	// move hdmitx_set_pll() to the end of this function.
+    // hdmitx_set_pll(param);
+    hdmitx_device->cur_VIC = param->VIC;
+    hdmitx_set_phy(hdmitx_device);
+
+	hdmitx_set_pll(param);
+
+    hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 0, 3, 1);
+    msleep(1);
+    hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 1, 3, 1);
+
+    return 0;
+}
+
+static void hdmitx_set_packet(int type, unsigned char* DB, unsigned char* HB)
+{
+    // TODO
+    // AVI frame
+    int i ;
+    unsigned char ucData ;
+    //unsigned int pkt_reg_base= 0x0;     //TODO
+    int pkt_data_len=0;
+    
+    switch(type)
+    {
+        case HDMI_PACKET_AVI:
+            pkt_data_len=13;
+            break;
+        case HDMI_PACKET_VEND:
+            pkt_data_len=6;
+            break;
+        case HDMI_AUDIO_INFO:
+            pkt_data_len=9;
+            break;
+        case HDMI_SOURCE_DESCRIPTION:
+            pkt_data_len=25;
+        default:
+            break;
+    }
+    
+    if(DB){
+        for(i=0;i<pkt_data_len;i++){
+//            hdmitx_wr_reg(pkt_reg_base+i+1, DB[i]);  
+        }
+    
+        for(i = 0,ucData = 0; i < pkt_data_len ; i++)
+        {
+            ucData -= DB[i] ;
+        }
+        for(i=0; i<3; i++){
+            ucData -= HB[i];
+        }
+    }
+    else{
+//        hdmitx_wr_reg(pkt_reg_base+0x1F, 0x0);        // disable packet generation
+    }
+}
+
+
+static void hdmitx_setaudioinfoframe(unsigned char* AUD_DB, unsigned char* CHAN_STAT_BUF)
+{
+    int i ;
+    unsigned char AUD_HB[3]={0x84, 0x1, 0xa};
+    hdmitx_set_packet(HDMI_AUDIO_INFO, AUD_DB, AUD_HB);    
+    //channel status
+    if(CHAN_STAT_BUF){
+        for(i=0;i<24;i++){
+// TODO
+        }
+    }
+}
+
+
+//------------------------------------------------------------------------------
+// set_hdmi_audio_source(unsigned int src)
+//
+// Description:
+// Select HDMI audio clock source, and I2S input data source.
+//
+// Parameters:
+//  src -- 0=no audio clock to HDMI; 1=pcmout to HDMI; 2=Aiu I2S out to HDMI.
+//------------------------------------------------------------------------------
+void set_hdmi_audio_source(unsigned int src)
+{
+    unsigned long data32;
+    unsigned int i;
+    
+    // Disable HDMI audio clock input and its I2S input
+    data32  = 0;
+    data32 |= (0    << 4);  // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= (0    << 0);  // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+    aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, data32);
+
+    // Enable HDMI audio clock from the selected source
+    data32  = 0;
+    data32 |= (0    << 4);  // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= (src  << 0);  // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+    aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, data32);
+    
+    // Wait until clock change is settled
+    i = 0;
+    msleep_interruptible(1000);
+    data32 = aml_read_reg32(P_AIU_HDMI_CLK_DATA_CTRL);
+    if(((data32 >> 8) & 0x3) != src)
+        printk("audio clock wait time out\n");
+
+    // Enable HDMI I2S input from the selected source
+    data32  = 0;
+    data32 |= (src  << 4);  // [5:4]    hdmi_data_sel: 00=disable hdmi i2s input; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+    data32 |= (src  << 0);  // [1:0]    hdmi_clk_sel: 00=Disable hdmi audio clock input; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+    aml_write_reg32(P_AIU_HDMI_CLK_DATA_CTRL, data32);
+
+    // Wait until data change is settled
+    msleep_interruptible(1000);
+    data32 = aml_read_reg32(P_AIU_HDMI_CLK_DATA_CTRL);
+    if(((data32 >> 12) & 0x3) != src)
+        printk("audio data wait time out\n");
+} /* set_hdmi_audio_source */
+
+static void hdmitx_set_aud_pkt_type(audio_type_t type)
+{
+    // TX_AUDIO_CONTROL [5:4]
+    //   0: Audio sample packet (HB0 = 0x02)
+    //   1: One bit audio packet (HB0 = 0x07)
+    //   2: HBR Audio packet (HB0 = 0x09)
+    //   3: DST Audio packet (HB0 = 0x08)
+    switch(type) {
+    case CT_MAT:
+        break;
+    case CT_ONE_BIT_AUDIO:
+        break;
+    case CT_DST:
+        break;
+    default:
+        break;
+    }
+}
+
+#if 0
+static Cts_conf_tab cts_table_192k[] = {
+    {24576,  27000,  27000},
+    {24576,  54000,  54000},
+    {24576, 108000, 108000},
+    {24576,  74250,  74250},
+    {24576, 148500, 148500},
+    {24576, 297000, 297000},
+};
+
+static unsigned int get_cts(unsigned int clk)
+{
+    int i;
+
+    for(i = 0; i < ARRAY_SIZE(cts_table_192k); i++) {
+        if(clk == cts_table_192k[i].tmds_clk)
+            return cts_table_192k[i].fixed_cts;
+    }
+
+    return 0;
+}
+
+static Vic_attr_map vic_attr_map_table[] = {
+    {HDMI_640x480p60,       27000 },
+    {HDMI_480p60,           27000 },
+    {HDMI_480p60_16x9,      27000 },
+    {HDMI_720p60,           74250 },
+    {HDMI_1080i60,          74250 },
+    {HDMI_480i60,           27000 },
+    {HDMI_480i60_16x9,      27000 },
+    {HDMI_480i60_16x9_rpt,  54000 },
+    {HDMI_1440x480p60,      27000 },
+    {HDMI_1440x480p60_16x9, 27000 },
+    {HDMI_1080p60,          148500},
+    {HDMI_576p50,           27000 },
+    {HDMI_576p50_16x9,      27000 },
+    {HDMI_720p50,           74250 },
+    {HDMI_1080i50,          74250 },
+    {HDMI_576i50,           27000 },
+    {HDMI_576i50_16x9,      27000 },
+    {HDMI_576i50_16x9_rpt,  54000 },
+    {HDMI_1080p50,          148500},
+    {HDMI_1080p24,          74250 },
+    {HDMI_1080p25,          74250 },
+    {HDMI_1080p30,          74250 },
+    {HDMI_480p60_16x9_rpt,  108000},
+    {HDMI_576p50_16x9_rpt,  108000},
+    {HDMI_4k2k_24,          247500},
+    {HDMI_4k2k_25,          247500},
+    {HDMI_4k2k_30,          247500},
+    {HDMI_4k2k_smpte_24,    247500},
+};
+
+static unsigned int vic_map_clk(HDMI_Video_Codes_t vic)
+{
+    int i;
+
+    for(i = 0; i < ARRAY_SIZE(vic_attr_map_table); i++) {
+        if(vic == vic_attr_map_table[i].VIC)
+            return vic_attr_map_table[i].tmds_clk;
+    }
+
+    return 0;
+}
+#endif
+
+#if 0
+static void hdmitx_set_aud_cts(audio_type_t type, Hdmi_tx_audio_cts_t cts_mode, HDMI_Video_Codes_t vic)
+{
+    unsigned int cts_val = 0;
+
+    switch(type) {
+    case CT_MAT:
+        if(cts_mode == AUD_CTS_FIXED) {
+            unsigned int clk = vic_map_clk(vic);
+            if(clk) {
+                cts_val = get_cts(clk);
+                if(!cts_val)
+                    hdmi_print(ERR, AUD "not find cts\n");
+            }
+            else {
+                hdmi_print(ERR, AUD "not find tmds clk\n");
+            }
+        }
+        if(cts_mode == AUD_CTS_CALC) {
+            // TODO
+        }
+        break;
+    default:
+        break;
+    }
+
+    if(cts_mode == AUD_CTS_FIXED) {
+        hdmi_print(IMP, AUD "type: %d  CTS Mode: %d  VIC: %d  CTS: %d\n", type, cts_mode, vic, cts_val);
+    }
+}
+#endif
+
+static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdev, Hdmi_tx_audio_para_t* audio_param)
+{
+    unsigned int data32;
+    unsigned int aud_n_para = 6144;
+
+    printk("test hdmi audio\n");
+    if (TX_I2S_SPDIF) {
+        set_hdmi_audio_source(2);
+    } else {
+        set_hdmi_audio_source(1);
+    }
+    
+// config IP
+//--------------------------------------------------------------------------
+// Configure audio
+//--------------------------------------------------------------------------
+    //I2S Sampler config
+    data32  = 0;
+    data32 |= (1    << 3);  // [  3] fifo_empty_mask: 0=enable int; 1=mask int.
+    data32 |= (1    << 2);  // [  2] fifo_full_mask: 0=enable int; 1=mask int.
+    hdmitx_wr_reg(HDMITX_DWC_AUD_INT,   data32);
+
+    data32  = 0;
+    data32 |= (1    << 4);  // [  4] fifo_overrun_mask: 0=enable int; 1=mask int. Enable it later when audio starts.
+    hdmitx_wr_reg(HDMITX_DWC_AUD_INT1,  data32);
+
+    data32  = 0;
+    data32 |= (0            << 7);  // [  7] sw_audio_fifo_rst
+    data32 |= (TX_I2S_SPDIF    << 5);  // [  5] 0=select SPDIF; 1=select I2S.
+    data32 |= (0            << 0);  // [3:0] i2s_in_en: enable it later in test.c
+                                    // if enable it now, fifo_overrun will happen, because packet don't get sent out until initial DE detected.
+    hdmitx_wr_reg(HDMITX_DWC_AUD_CONF0, data32);
+
+    data32  = 0;
+    data32 |= (0    << 5);  // [7:5] i2s_mode: 0=standard I2S mode
+    data32 |= (24   << 0);  // [4:0] i2s_width
+    hdmitx_wr_reg(HDMITX_DWC_AUD_CONF1, data32);
+
+    data32  = 0;
+    data32 |= (0                                                    << 1);  // [  1] NLPCM
+    data32 |= (0    << 0);  // [  0] HBR
+    hdmitx_wr_reg(HDMITX_DWC_AUD_CONF2, data32);
+
+    //spdif sampler config
+
+    data32  = 0;
+    data32 |= (1    << 3);  // [  3] SPDIF fifo_empty_mask: 0=enable int; 1=mask int.
+    data32 |= (1    << 2);  // [  2] SPDIF fifo_full_mask: 0=enable int; 1=mask int.
+    hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT,  data32);
+
+    data32  = 0;
+    data32 |= (0    << 4);  // [  4] SPDIF fifo_overrun_mask: 0=enable int; 1=mask int.
+    hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT1, data32);
+
+    data32  = 0;
+    data32 |= (0    << 7);  // [  7] sw_audio_fifo_rst
+    hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF0,    data32);
+
+    data32  = 0;
+    data32 |= (0                                                    << 7);  // [  7] setnlpcm
+    data32 |= (0    << 6);  // [  6] spdif_hbr_mode
+    data32 |= (24                                                   << 0);  // [4:0] spdif_width
+    hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF1,    data32);
+
+    // ACR packet configuration
+
+    data32  = 0;
+    data32 |= (1    << 7);  // [  7] ncts_atomic_write
+    data32 |= (0    << 0);  // [3:0] AudN[19:16]
+    hdmitx_wr_reg(HDMITX_DWC_AUD_N3,   data32);
+
+    data32  = 0;
+    data32 |= (0    << 7);  // [7:5] N_shift
+    data32 |= (0    << 4);  // [  4] CTS_manual
+    data32 |= (0    << 0);  // [3:0] manual AudCTS[19:16]
+    hdmitx_wr_reg(HDMITX_DWC_AUD_CTS3, data32);
+
+    hdmitx_wr_reg(HDMITX_DWC_AUD_CTS2, 0); // manual AudCTS[15:8]
+    hdmitx_wr_reg(HDMITX_DWC_AUD_CTS1, 0); // manual AudCTS[7:0]
+
+    data32  = 0;
+    data32 |= (1                    << 7);  // [  7] ncts_atomic_write
+    data32 |= (((aud_n_para>>16)&0xf)    << 0);  // [3:0] AudN[19:16]
+    hdmitx_wr_reg(HDMITX_DWC_AUD_N3,   data32);
+    hdmitx_wr_reg(HDMITX_DWC_AUD_N2,   (aud_n_para>>8)&0xff);   // AudN[15:8]
+    hdmitx_wr_reg(HDMITX_DWC_AUD_N1,   aud_n_para&0xff);        // AudN[7:0]
+
+    //audio packetizer config
+    hdmitx_wr_reg(HDMITX_DWC_AUD_INPUTCLKFS, TX_I2S_SPDIF? 4 : 0); // lfsfactor: use 2*F_i2s or F_spdif as audio_master_clk for CTS calculation
+
+    
+    if (TX_I2S_SPDIF) {
+        hdmitx_wr_reg(HDMITX_DWC_AUD_CONF0,  hdmitx_rd_reg(HDMITX_DWC_AUD_CONF0) | ((TX_I2S_8_CHANNEL? 0xf : 0x1) << 0));
+        // Enable audi2s_fifo_overrun interrupt
+        hdmitx_wr_reg(HDMITX_DWC_AUD_INT1,   hdmitx_rd_reg(HDMITX_DWC_AUD_INT1) & (~(1<<4)));
+        msleep(10);     // Wait for 40 us for TX I2S decoder to settle
+    } else {
+    }
+    hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO3, 1, 0, 1);
+
+    enable_audio_spdif();
+    enable_audio_i2s();
+    hdmitx_set_aud_pkt_type(CT_PCM);
+    return 1;
+}
+
+static void hdmitx_setupirq(hdmitx_dev_t* hdmitx_device)
+{
+   int r;
+   r = request_irq(INT_HDMI_TX, &intr_handler,
+                    IRQF_SHARED, "hdmitx",
+                    (void *)hdmitx_device);
+}    
+
+static void hdmitx_uninit(hdmitx_dev_t* hdmitx_device)
+{
+    //aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR);
+    //aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK)&(~(1 << 25)));
+    free_irq(INT_HDMI_TX, (void *)hdmitx_device);
+    hdmi_print(1,"power off hdmi, unmux hpd\n");
+    
+    phy_pll_off();
+    digital_clk_off(7); //off sys clk
+    hdmitx_hpd_hw_op(HPD_UNMUX_HPD);
+}    
+
+static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(cmd == HDMITX_AVMUTE_CNTL) {
+        return 0;
+    }
+    else if(cmd == HDMITX_SW_INTERNAL_HPD_TRIG){
+    }
+    else if(cmd == HDMITX_EARLY_SUSPEND_RESUME_CNTL) {
+        if(argv == HDMITX_EARLY_SUSPEND) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);
+            hdmi_phy_suspend();
+        }
+        if(argv == HDMITX_LATE_RESUME) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 1, 30, 1);
+            //hdmi_phy_wakeup();  	// no need
+        }
+        return 0;
+    }
+    else if(cmd == HDMITX_HDCP_MONITOR) {
+        //TODO
+        return 0;
+    }
+    else if(cmd == HDMITX_IP_SW_RST){
+        return 0;    //TODO
+    }
+    else if(cmd == HDMITX_CBUS_RST) {
+        return 0;//todo
+        aml_set_reg32_bits(P_RESET2_REGISTER, 1, 15, 1);
+        return 0;
+    }
+    else if(cmd == HDMITX_INTR_MASKN_CNTL) {
+// TODO
+        return 0;
+    }
+    else if(cmd == HDMITX_IP_INTR_MASN_RST){
+
+    }
+    else if(cmd == HDMITX_HWCMD_MUX_HPD_IF_PIN_HIGH){
+        /* turnon digital module if gpio is high */
+        if(hdmitx_hpd_hw_op(HPD_IS_HPD_MUXED) == 0){
+            if(hdmitx_hpd_hw_op(HPD_READ_HPD_GPIO)){
+                hdmitx_device->internal_mode_change = 0;
+                msleep(500);
+                if(hdmitx_hpd_hw_op(HPD_READ_HPD_GPIO)){
+                    hdmi_print(IMP, HPD "mux hpd\n");
+                    digital_clk_on(4);
+                    delay_us(1000*100);
+                    hdmitx_hpd_hw_op(HPD_MUX_HPD);
+                }
+            }
+        }
+    }
+    else if(cmd == HDMITX_HWCMD_MUX_HPD){
+         hdmitx_hpd_hw_op(HPD_MUX_HPD);
+    } 
+// For test only. 
+    else if(cmd == HDMITX_HWCMD_TURNOFF_HDMIHW){
+        int unmux_hpd_flag = argv;
+//        WRITE_MPEG_REG(VENC_DVI_SETTING, READ_MPEG_REG(VENC_DVI_SETTING)&(~(1<<13))); //bit 13 is used by HDMI only
+//        digital_clk_on(4); //enable sys clk so that hdmi registers can be accessed when calling phy_pll_off/digit_clk_off
+        if(unmux_hpd_flag){
+            hdmi_print(IMP, SYS "power off hdmi, unmux hpd\n");
+            phy_pll_off();
+            digital_clk_off(4); //off sys clk
+            hdmitx_hpd_hw_op(HPD_UNMUX_HPD);
+        }
+        else{
+            hdmi_print(IMP, SYS "power off hdmi\n");
+            digital_clk_on(6);
+            phy_pll_off();      //should call digital_clk_on(), otherwise hdmi_rd/wr_reg will hungup
+            digital_clk_off(3); //do not off sys clk
+        }
+#ifdef CONFIG_HDMI_TX_PHY
+    digital_clk_off(7);
+#endif
+    }
+    return 0;
+}
+
+static void hdmitx_print_info(hdmitx_dev_t* hdmitx_device, int printk_flag)
+{
+    hdmi_print(INF, "------------------\nHdmitx driver version: %s\nSerial %x\nColor Depth %d\n", HDMITX_VER, serial_reg_val, color_depth_f);
+    hdmi_print(INF, "current vout index %d\n", cur_vout_index);
+    hdmi_print(INF, "reset sequence %d\n", new_reset_sequence_flag);
+    hdmi_print(INF, "power mode %d\n", power_mode);
+    hdmi_print(INF, "%spowerdown when unplug\n",hdmitx_device->unplug_powerdown?"":"do not ");
+    hdmi_print(INF, "use_tvenc_conf_flag=%d\n",use_tvenc_conf_flag); 
+    hdmi_print(INF, "vdac %s\n", power_off_vdac_flag?"off":"on");
+    hdmi_print(INF, "hdmi audio %s\n", hdmi_audio_off_flag?"off":"on");
+    if(!hdmi_audio_off_flag){
+        hdmi_print(INF, "audio out type %s\n", i2s_to_spdif_flag?"spdif":"i2s");
+    }
+    hdmi_print(INF, "delay flag %d\n", delay_flag);
+    hdmi_print(INF, "------------------\n");
+}
+
+typedef struct {
+    unsigned int val : 20;
+    unsigned int stable: 1;
+}aud_cts_log_t;
+
+static inline unsigned int get_msr_cts(void)
+{
+    unsigned int ret = 0;
+
+    // TODO
+
+    return ret;
+}
+
+static inline unsigned int get_msr_cts_st(void)
+{
+    // TODO
+    return 0;
+}
+
+#define AUD_CTS_LOG_NUM     1000
+aud_cts_log_t cts_buf[AUD_CTS_LOG_NUM];
+static void cts_test(hdmitx_dev_t* hdmitx_device)
+{
+    int i, j;
+    unsigned int min = 0, max = 0, total = 0;
+
+    printk("\nhdmitx: audio: cts test\n");
+    memset(cts_buf, 0, sizeof(cts_buf));
+    for(i = 0; i < AUD_CTS_LOG_NUM; i++) {
+        cts_buf[i].val = get_msr_cts();
+        cts_buf[i].stable = get_msr_cts_st();
+        mdelay(1);
+    }
+
+    printk("cts unstable:\n");
+    for(i = 0, j = 0; i < AUD_CTS_LOG_NUM; i++) {
+        if(cts_buf[i].stable == 0) {
+            printk("%d  ", i);
+            j ++;
+            if(((j+1) & 0xf) == 0)
+                printk("\n");
+        }
+    }
+
+    printk("\ncts change:\n");
+    for(i = 1; i < AUD_CTS_LOG_NUM; i++) {
+        if(cts_buf[i].val > cts_buf[i-1].val)
+            printk("dis: +%d  [%d] %d  [%d] %d\n", cts_buf[i].val - cts_buf[i-1].val, i, cts_buf[i].val, i - 1, cts_buf[i - 1].val);
+        if(cts_buf[i].val < cts_buf[i-1].val)
+            printk("dis: %d  [%d] %d  [%d] %d\n", cts_buf[i].val - cts_buf[i-1].val, i, cts_buf[i].val, i - 1, cts_buf[i - 1].val);
+    }
+
+    for(i = 0; i < AUD_CTS_LOG_NUM; i++) {
+        total += cts_buf[i].val;
+        if(min > cts_buf[i].val)
+            min = cts_buf[i].val;
+        if(max < cts_buf[i].val)
+            max = cts_buf[i].val;
+    }
+    printk("\nCTS Min: %d   Max: %d   Avg: %d/1000\n\n", min, max, total);
+}
+
+void hdmitx_dump_inter_timing(void)
+{
+    unsigned int tmp = 0;
+#define CONNECT2REG(reg)        ((hdmitx_rd_reg(reg)) + (hdmitx_rd_reg(reg + 1) << 8))
+    tmp = CONNECT2REG(HDMITX_DWC_FC_INHACTV0);
+    printk("Hactive = %d\n", tmp);
+
+    tmp = CONNECT2REG(HDMITX_DWC_FC_INHBLANK0);
+    printk("Hblank = %d\n", tmp);
+
+    tmp = CONNECT2REG(HDMITX_DWC_FC_INVACTV0);
+    printk("Vactive = %d\n", tmp);
+
+    tmp = hdmitx_rd_reg(HDMITX_DWC_FC_INVBLANK);
+    printk("Vblank = %d\n", tmp);
+
+    tmp = CONNECT2REG(HDMITX_DWC_FC_HSYNCINDELAY0);
+    printk("Hfront = %d\n", tmp);
+
+    tmp = CONNECT2REG(HDMITX_DWC_FC_HSYNCINWIDTH0);
+    printk("Hsync = %d\n", tmp);
+
+    tmp = hdmitx_rd_reg(HDMITX_DWC_FC_VSYNCINDELAY);
+    printk("Vfront = %d\n", tmp);
+
+    tmp = hdmitx_rd_reg(HDMITX_DWC_FC_VSYNCINWIDTH);
+    printk("Vactive = %d\n", tmp);
+
+    //HDMITX_DWC_FC_INFREQ0 ???
+}
+
+#define DUMP_CVREG_SECTION(start, end)                \
+    do {                                            \
+        if(start > end) {                           \
+            printk("Error start = 0x%x > end = 0x%x\n", ((start & 0xffff) >> 2), ((end & 0xffff) >> 2));    \
+            break;                                  \
+        }                                           \
+        printk("Start = 0x%x[0x%x]   End = 0x%x[0x%x]\n", start, ((start & 0xffff) >> 2), end, ((end & 0xffff) >> 2));    \
+        for(addr = start; addr < end + 1; addr += 4) {    \
+            val = aml_read_reg32(addr);                 \
+            if(val)                                     \
+                printk("0x%08x[0x%04x]: 0x%08x\n", addr,  \
+                ((addr & 0xffff) >> 2), val);           \
+        }                                               \
+    }while(0)
+
+static void hdmitx_dump_all_cvregs(void)
+{
+    unsigned addr = 0, val = 0;
+
+    DUMP_CVREG_SECTION(P_STB_TOP_CONFIG, P_CIPLUS_ENDIAN);
+    DUMP_CVREG_SECTION(P_PREG_CTLREG0_ADDR, P_AHB_BRIDGE_CNTL_REG2);
+    DUMP_CVREG_SECTION(P_BT_CTRL, P_BT656_ADDR_END);
+    DUMP_CVREG_SECTION(P_VERSION_CTRL, P_RESET7_LEVEL);
+    DUMP_CVREG_SECTION(P_SCR_HIU, P_HHI_HDMIRX_AUD_PLL_CNTL6);
+    DUMP_CVREG_SECTION(P_PARSER_CONTROL, P_PARSER_AV2_WRAP_COUNT);
+    DUMP_CVREG_SECTION(P_DVIN_FRONT_END_CTRL, P_DVIN_CTRL_STAT);
+    DUMP_CVREG_SECTION(P_AIU_958_BPF, P_AIU_I2S_CBUS_DDR_ADDR);
+    DUMP_CVREG_SECTION(P_GE2D_GEN_CTRL0, P_GE2D_GEN_CTRL4);
+    DUMP_CVREG_SECTION(P_AUDIO_COP_CTL2, P_EE_ASSIST_MBOX3_FIQ_SEL);
+    DUMP_CVREG_SECTION(P_AUDIN_SPDIF_MODE, P_AUDIN_ADDR_END);
+    DUMP_CVREG_SECTION(P_VDIN_SCALE_COEF_IDX, P_VDIN0_SCALE_COEF_IDX);
+    DUMP_CVREG_SECTION(P_VDIN0_SCALE_COEF, P_VDIN1_ASFIFO_CTRL3);
+    DUMP_CVREG_SECTION(P_L_GAMMA_CNTL_PORT, P_MLVDS_RESET_CONFIG_LO);
+    DUMP_CVREG_SECTION(P_VPP2_DUMMY_DATA, P_DI_CHAN2_URGENT_CTRL);
+    DUMP_CVREG_SECTION(P_DI_PRE_CTRL, P_DI_CANVAS_URGENT2);
+    DUMP_CVREG_SECTION(P_ENCP_VFIFO2VD_CTL, P_VIU2_VD1_FMT_W);
+    DUMP_CVREG_SECTION(P_VPU_OSD1_MMC_CTRL, P_VPU_PROT3_REQ_ONOFF);
+    DUMP_CVREG_SECTION(P_D2D3_GLB_CTRL, P_D2D3_RESEV_STATUS2);
+    DUMP_CVREG_SECTION(P_VI_HIST_CTRL, P_DEMO_CRTL);
+    DUMP_CVREG_SECTION(P_AO_RTI_STATUS_REG0, P_AO_SAR_ADC_REG12);
+    DUMP_CVREG_SECTION(P_STB_VERSION, P_DEMUX_SECTION_RESET_3);
+}
+
+#define DUMP_HDMITXREG_SECTION(start, end)                \
+    do {                                            \
+        if(start > end) {                           \
+            printk("Error start = 0x%x > end = 0x%x\n", start, end);    \
+            break;                                  \
+        }                                           \
+        printk("Start = 0x%x   End = 0x%x\n", start, end);    \
+        for(addr = start; addr < end + 1; addr ++) {    \
+            val = hdmitx_rd_reg(addr);                 \
+            if(val)                                     \
+                printk("[0x%08x]: 0x%08x\n", addr,  \
+                val);           \
+        }                                               \
+    }while(0)
+
+static void hdmitx_dump_intr(void)
+{
+    unsigned addr = 0, val = 0;
+
+    DUMP_HDMITXREG_SECTION(HDMITX_DWC_IH_FC_STAT0, HDMITX_DWC_IH_MUTE);
+}
+ 
+static void hdmitx_4k2k60hz444_debug(void)
+{
+    printk("4k2k60hzYCBCR444\n");
+    printk("set clk:data = 1 : 40 set double rate\n");
+    aml_write_reg32(P_HHI_HDMI_PHY_CNTL0, 0x33b544ab);
+    aml_write_reg32(P_HHI_HDMI_PHY_CNTL3, 0x303e0003);
+    aml_write_reg32(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+    aml_write_reg32(P_HHI_VID_CLK_DIV, 0x101);
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_01, 0x0);
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_23, 0xffffffff);
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 1);
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 2);
+    hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, HDMI_3840x2160p60_16x9);
+}
+
+static void hdmitx_4k2k5g_debug(void)
+{
+    printk("4k2k5g\n");
+    printk("set clk:data = 1 : 40 set double rate\n");
+    aml_write_reg32(P_HHI_HDMI_PHY_CNTL0, 0x33b544ab);
+    aml_write_reg32(P_HHI_HDMI_PHY_CNTL3, 0x303e0003);
+    aml_write_reg32(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_01, 0x0);
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_23, 0xffffffff);
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 1);
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 2);
+    hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, HDMI_3840x2160p50_16x9);
+    set_vmode_clk(VMODE_4K2K_5G);
+    aml_write_reg32(P_HHI_VID_CLK_DIV, 0x100);
+}
+
+static void hdmitx_4k2k60hz420_debug(void)
+{
+    printk("4k2k60hzYCBCR420\n");
+    printk("set clk:data = 1 : 10 set double rate\n");
+    aml_write_reg32(P_HHI_VID_CLK_DIV, 0x101);
+    //hdmitx_wr_reg(HDMITX_DWC_MC_FLOWCTRL, 1);   //csc_en
+    //hdmitx_wr_reg(HDMITX_DWC_CSC_CFG, 2);
+    hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF0, 0x43);
+    hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, HDMI_3840x2160p60_16x9);
+}
+
+static void hdmitx_debug(hdmitx_dev_t* hdev, const char* buf)
+{
+    char tmpbuf[128];
+    int i=0;
+    unsigned int adr;
+    unsigned int value=0;
+    while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
+        tmpbuf[i]=buf[i];
+        i++;    
+    }
+    tmpbuf[i]=0;
+    if((strncmp(tmpbuf, "dumpreg", 7)==0) || (strncmp(tmpbuf, "dumptvencreg", 12)==0)){
+        hdmitx_dump_tvenc_reg(hdev->cur_VIC, 1);
+        return;
+    }
+    else if(strncmp(tmpbuf, "4k2k60hz444", 11) == 0) {
+        hdmitx_4k2k60hz444_debug();
+    }
+    else if(strncmp(tmpbuf, "testpll", 7) == 0) {
+        set_vmode_clk((tmpbuf[7] == '0') ? VMODE_1080P : VMODE_4K2K_FAKE_5G);
+        return;
+    }
+    else if(strncmp(tmpbuf, "4k2k60hz420", 11) == 0) {
+        hdmitx_4k2k60hz420_debug();
+    }
+    else if(strncmp(tmpbuf, "4k2k5g", 6) == 0) {
+        hdmitx_4k2k5g_debug();
+    }
+else if(strncmp(tmpbuf, "testedid", 8) == 0) {
+dd();
+    hdev->HWOp.CntlDDC(hdev, DDC_RESET_EDID, 0);
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_READ_DATA, 0);
+}
+    else if(strncmp(tmpbuf, "dumptiming", 10) == 0) {
+        hdmitx_dump_inter_timing();
+        return;
+    }
+    else if(strncmp(tmpbuf, "testaudio", 9) == 0) {
+        hdmitx_set_audmode(hdev, NULL);
+    }
+    else if(strncmp(tmpbuf, "dumpintr", 8) == 0) {
+        hdmitx_dump_intr();
+    }
+    else if(strncmp(tmpbuf, "hdcptest", 8) == 0) {
+        hdmitx_hdcp_test();
+    }
+    else if(strncmp(tmpbuf, "dumpallregs", 11) == 0) {
+        hdmitx_dump_all_cvregs();
+        return;
+    }
+    else if(strncmp(tmpbuf, "chkfmt", 6) == 0) {
+        check_detail_fmt();
+        return;
+    }
+    else if(strncmp(tmpbuf, "ctstest", 7) == 0) {
+        cts_test(hdev);
+        return;
+    }
+    else if(strncmp(tmpbuf, "ss", 2) == 0) {
+        printk("hdmitx_device->output_blank_flag: 0x%x\n", hdev->output_blank_flag);
+        printk("hdmitx_device->hpd_state: 0x%x\n", hdev->hpd_state);
+        printk("hdmitx_device->cur_VIC: 0x%x\n", hdev->cur_VIC);
+    }
+    else if(strncmp(tmpbuf, "hpd_lock", 8) == 0) {
+        if(tmpbuf[8] == '1') {
+            hdev->hpd_lock = 1;
+            hdmi_print(INF, HPD "hdmitx: lock hpd\n");
+        }
+        else {
+            hdev->hpd_lock = 0;
+            hdmi_print(INF, HPD "hdmitx: unlock hpd\n");
+        }
+        return ;
+    }
+    else if(strncmp(tmpbuf, "vic", 3)==0) {
+        printk("hdmi vic count = %d\n", hdev->vic_count);
+        if((tmpbuf[3] >= '0') && (tmpbuf[3] <= '9')){
+            hdev->vic_count = tmpbuf[3] - '0';
+            hdmi_print(INF, SYS "set hdmi vic count = %d\n", hdev->vic_count);
+        }
+    }
+    else if(strncmp(tmpbuf, "cec", 3)==0) {
+        extern void cec_test_(unsigned int cmd);
+        cec_test_(tmpbuf[3] - '0');
+    }
+    else if(strncmp(tmpbuf, "dumphdmireg", 11)==0){
+        unsigned char reg_val = 0;
+        unsigned int reg_adr = 0;
+        for (reg_adr = HDMITX_TOP_SW_RESET; reg_adr < HDMITX_TOP_STAT0 + 1; reg_adr ++){
+            reg_val = hdmitx_rd_reg(reg_adr);
+            if(reg_val)
+                printk("TOP[0x%x]: 0x%x\n", reg_adr, reg_val);
+        }
+        for (reg_adr = HDMITX_DWC_DESIGN_ID; reg_adr < HDMITX_DWC_I2CM_SCDC_UPDATE1 + 1; reg_adr ++){
+            if((reg_adr > HDMITX_DWC_HDCP_BSTATUS_0 -1) && (reg_adr < HDMITX_DWC_HDCPREG_BKSV0)) {
+                hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x1);
+                hdmitx_poll_reg(HDMITX_DWC_A_KSVMEMCTRL, (1<<1), 2 * HZ);
+                reg_val = hdmitx_rd_reg(reg_adr);
+            }
+            else {
+                reg_val = hdmitx_rd_reg(reg_adr);
+            }
+            if(reg_val) {
+                if(tmpbuf[11] == 'h') {
+                    // print all HDCP regisiters
+                    printk("DWC[0x%x]: 0x%x\n", reg_adr, reg_val);
+                } else {
+                    // excluse HDCP regisiters
+                    if((reg_adr < HDMITX_DWC_A_HDCPCFG0) || (reg_adr > HDMITX_DWC_CEC_CTRL))
+                        printk("DWC[0x%x]: 0x%x\n", reg_adr, reg_val);
+                }
+            }
+        }
+        return ;
+    }
+    else if(strncmp(tmpbuf, "dumpcecreg",10) == 0){
+        unsigned char cec_val = 0;
+        unsigned int cec_adr =0;
+        //HDMI CEC Regs address range:0xc000~0xc01c;0xc080~0xc094
+        for(cec_adr = 0xc000; cec_adr < 0xc01d; cec_adr ++){
+            cec_val = hdmitx_rd_reg(cec_adr);
+            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);
+        }
+         for(cec_adr = 0xc080; cec_adr < 0xc095; cec_adr ++){
+            cec_val = hdmitx_rd_reg(cec_adr);
+            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);
+        }
+        return;      
+    }
+    else if(strncmp(tmpbuf, "dumpcbusreg", 11) == 0) {
+        unsigned i, val;
+        for(i = 0; i < 0x3000; i++) {
+            val = aml_read_reg32(CBUS_REG_ADDR(i));
+            if(val)
+                printk("CBUS[0x%x]: 0x%x\n", i, val);
+        }
+        return;
+    }
+    else if(strncmp(tmpbuf, "dumpvcbusreg", 12) == 0) {
+        unsigned i, val;
+        for(i = 0; i < 0x3000; i++) {
+            val = aml_read_reg32(VCBUS_REG_ADDR(i));
+            if(val)
+                printk("VCBUS[0x%x]: 0x%x\n", i, val);
+        }
+        return;
+    }
+    else if(strncmp(tmpbuf, "log", 3)==0){
+        if(strncmp(tmpbuf+3, "hdcp", 4)==0){
+            static unsigned int i = 1;
+            if(i & 1){
+                hdev->log |= HDMI_LOG_HDCP;
+            }
+            else{
+                hdev->log &= ~HDMI_LOG_HDCP;
+            }
+            i ++;
+        }
+        return ;
+    }
+    else if(strncmp(tmpbuf, "pllcalc", 7)==0){
+        clk_measure(0xff);
+        return;
+    }
+    else if(strncmp(tmpbuf, "hdmiaudio", 9)==0){
+        value=simple_strtoul(tmpbuf+9, NULL, 16);
+        if(value == 1){
+            hdmi_audio_off_flag = 0;
+            hdmi_audio_init(i2s_to_spdif_flag);
+        }
+        else if(value == 0){
+        }
+        return;
+    }
+    else if(strncmp(tmpbuf, "cfgreg", 6)==0){
+        adr=simple_strtoul(tmpbuf+6, NULL, 16);
+        value=simple_strtoul(buf+i+1, NULL, 16);
+        hdmitx_config_tvenc_reg(hdev->cur_VIC, adr, value);
+        return;
+    }
+    else if(strncmp(tmpbuf, "tvenc_flag", 10)==0){
+        use_tvenc_conf_flag = tmpbuf[10]-'0';
+        hdmi_print(INF, "set use_tvenc_conf_flag = %d\n", use_tvenc_conf_flag);
+    }
+    else if(strncmp(tmpbuf, "reset", 5)==0){
+        if(tmpbuf[5]=='0')
+            new_reset_sequence_flag=0;
+        else 
+            new_reset_sequence_flag=1;
+        return;
+    }
+    else if(strncmp(tmpbuf, "delay_flag", 10)==0){
+        delay_flag = tmpbuf[10]-'0';    
+    }
+    else if(tmpbuf[0]=='v'){
+        hdmitx_print_info(hdev, 1);
+        return;    
+    }
+    else if(tmpbuf[0]=='s'){
+        serial_reg_val=simple_strtoul(tmpbuf+1,NULL,16);
+        return;
+    }
+    else if(tmpbuf[0]=='c'){
+        if(tmpbuf[1]=='d'){
+            color_depth_f=simple_strtoul(tmpbuf+2,NULL,10);
+            if((color_depth_f!=24)&&(color_depth_f!=30)&&(color_depth_f!=36)){
+                printk("Color depth %d is not supported\n", color_depth_f);
+                color_depth_f=0;
+            }
+            return;
+        }
+        else if(tmpbuf[1]=='s'){
+            color_space_f=simple_strtoul(tmpbuf+2,NULL,10);
+            if(color_space_f>2){
+                printk("Color space %d is not supported\n", color_space_f);
+                color_space_f=0;
+            }
+        }
+    }
+    else if(strncmp(tmpbuf,"i2s",2)==0){
+        if(strncmp(tmpbuf+3,"off",3)==0)
+            i2s_to_spdif_flag=1;
+        else   
+            i2s_to_spdif_flag=0;
+    }
+    else if(strncmp(tmpbuf, "pattern_on", 10)==0){
+//        turn_on_shift_pattern();
+        hdmi_print(INF, "Shift Pattern On\n");
+        return;        
+    }
+    else if(strncmp(tmpbuf, "pattern_off", 11)==0){
+        hdmi_print(INF, "Shift Pattern Off\n");
+        return;        
+    }
+    else if(strncmp(tmpbuf, "prbs", 4)==0){
+        //int prbs_mode =simple_strtoul(tmpbuf+4, NULL, 10);
+        return;
+    }
+    else if(tmpbuf[0]=='w'){
+        unsigned read_back = 0;
+        adr=simple_strtoul(tmpbuf+2, NULL, 16);
+        value=simple_strtoul(buf+i+1, NULL, 16);
+        if(buf[1]=='h'){
+            hdmitx_wr_reg(adr, value);
+            read_back = hdmitx_rd_reg(adr);
+        }
+        else if(buf[1]=='c'){
+            aml_write_reg32(CBUS_REG_ADDR(adr), value);
+            read_back = aml_read_reg32(CBUS_REG_ADDR(adr));
+            
+        }
+        else if(buf[1]=='p'){
+            aml_write_reg32(APB_REG_ADDR(adr), value);
+            read_back = aml_read_reg32(APB_REG_ADDR(adr));
+        }
+        hdmi_print(INF, "write %x to %s reg[%x]\n",value,buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr);
+        //Add read back function in order to judge writting is OK or NG.
+        hdmi_print(INF, "Read Back %s reg[%x]=%x\n",buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr, read_back);
+    }
+    else if(tmpbuf[0]=='r'){
+        adr=simple_strtoul(tmpbuf+2, NULL, 16);
+        if(buf[1]=='h'){
+            value = hdmitx_rd_reg(adr);
+            
+        }
+        else if(buf[1]=='c'){
+            value = aml_read_reg32(CBUS_REG_ADDR(adr));
+        }
+        else if(buf[1]=='p'){
+            value = aml_read_reg32(APB_REG_ADDR(adr));
+        }
+        hdmi_print(INF, "%s reg[%x]=%x\n",buf[1]=='p'?"APB":(buf[1]=='h'?"HDMI":"CBUS"), adr, value);
+    }
+}
+
+
+static void hdmitx_getediddata(unsigned char * des, unsigned char * src)
+{
+    int i = 0;
+    unsigned int blk = src[126] + 1;
+
+    if(blk > 4)
+        blk = 4;
+
+    for(i = 0; i < 128 * blk; i++) {
+        des[i] = src[i];
+    }
+}    
+
+/*
+ * Note: read 8 Bytes of EDID data every time
+ */
+static void hdmitx_read_edid(unsigned char* rx_edid)
+{
+    unsigned int timeout = 0;
+    unsigned int    i;
+    unsigned int    byte_num = 0;
+    unsigned char   blk_no  = 1;
+
+    // Program SLAVE/SEGMENT/ADDR
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_SLAVE,    0x50);
+    hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGADDR,  0x30);
+    // Read complete EDID data sequentially
+    while (byte_num < 128 * blk_no) {
+        if ((byte_num % 256) == 0) {
+            hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGPTR, byte_num>>8);
+        }
+        hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS,  byte_num&0xff);
+        // Do extended sequential read
+dd();   hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION,   1<<3);
+        // Wait until I2C done
+        timeout = 0;
+        while((!(hdmitx_rd_reg(HDMITX_DWC_IH_I2CM_STAT0) & (1 << 1))) && (timeout < 3)) {
+            msleep(2);
+            timeout ++;
+        }
+        if(timeout == 3)
+            printk("ddc timeout\n");
+        hdmitx_wr_reg(HDMITX_DWC_IH_I2CM_STAT0, 1 << 1);
+        // Read back 8 bytes
+        for (i = 0; i < 8; i ++) {
+            rx_edid[byte_num] = hdmitx_rd_reg(HDMITX_DWC_I2CM_READ_BUFF0 + i);
+            if (byte_num == 126) {
+                blk_no  = rx_edid[byte_num] + 1;
+                if(blk_no > 4) {
+                    printk("edid extension block number: %d, reset to MAX 3\n", blk_no - 1);
+                    blk_no = 4;     // Max extended block
+                }
+            }
+            byte_num ++;
+        }
+    }
+}   /* hdmi20_tx_read_edid */
+
+static unsigned char tmp_edid_buf[128*EDID_MAX_BLOCK] = { 0 };
+
+static int hdmitx_cntl_ddc(hdmitx_dev_t* hdev, unsigned cmd, unsigned argv)
+{
+    int i = 0;
+    unsigned char *tmp_char = NULL;
+    
+    if(!(cmd & CMD_DDC_OFFSET))
+        hdmi_print(ERR, "ddc: " "w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "ddc: " "cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case DDC_RESET_EDID:
+        hdmitx_wr_reg(HDMITX_DWC_I2CM_SOFTRSTZ, 0);
+        memset(tmp_edid_buf, 0, ARRAY_SIZE(tmp_edid_buf));
+        break;
+    case DDC_IS_EDID_DATA_READY:
+        
+        break;
+    case DDC_EDID_READ_DATA:
+        hdmitx_read_edid(tmp_edid_buf);
+        break;
+    case DDC_EDID_GET_DATA:
+        if(argv == 0)
+            hdmitx_getediddata(&hdev->EDID_buf[0], tmp_edid_buf);
+        else
+            hdmitx_getediddata(&hdev->EDID_buf1[0], tmp_edid_buf);
+        break;
+    case DDC_PIN_MUX_OP:
+        if(argv == PIN_MUX) {
+            hdmitx_ddc_hw_op(DDC_MUX_DDC);
+        }
+        if(argv == PIN_UNMUX) {
+            hdmitx_ddc_hw_op(DDC_UNMUX_DDC);
+        }
+        break;
+    case DDC_EDID_CLEAR_RAM:
+        for(i = 0; i < EDID_RAM_ADDR_SIZE; i++) {
+            hdmitx_wr_reg(HDMITX_DWC_I2CM_READ_BUFF0 + i, 0);
+        }
+        break;
+    case DDC_RESET_HDCP:
+
+        break;
+    case DDC_HDCP_OP:
+        if(argv == HDCP_ON) {
+//            hdmi_set_reg_bits(TX_HDCP_MODE, 1, 7, 1);
+        }
+        if(argv == HDCP_OFF) {
+//            hdmi_set_reg_bits(TX_HDCP_MODE, 0, 7, 1);
+        }
+        break;
+    case DDC_IS_HDCP_ON:
+//        argv = !!((hdmitx_rd_reg(TX_HDCP_MODE)) & (1 << 7));
+        break;
+    case DDC_HDCP_GET_AKSV:
+        tmp_char = (unsigned char *) argv;
+        for(i = 0; i < 5; i++) {
+//            tmp_char[i] = (unsigned char)hdmitx_rd_reg(TX_HDCP_AKSV_SHADOW + 4 - i);
+        }
+        break;
+    case DDC_HDCP_GET_BKSV:
+        tmp_char = (unsigned char *) argv;
+        for(i = 0; i < 5; i++) {
+//            tmp_char[i] = (unsigned char)hdmitx_rd_reg(TX_HDCP_BKSV_SHADOW + 4 - i);
+        }
+        break;
+    case DDC_HDCP_GET_AUTH:
+        break;
+    default:
+        hdmi_print(INF, "ddc: " "unknown cmd: 0x%x\n", cmd);
+    }
+    return 1;
+}
+
+#if 0
+// clear hdmi packet configure registers
+static void hdmitx_clr_sub_packet(unsigned int reg_base)
+{
+    int i = 0;
+    for(i = 0; i < 0x20; i++) {
+        hdmitx_wr_reg(reg_base + i, 0x00);
+    }
+}
+#endif
+
+static int hdmitx_cntl_config(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(!(cmd & CMD_CONF_OFFSET))
+        hdmi_print(ERR, "config: " "hdmitx: w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "config: " "hdmitx: conf cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case CONF_HDMI_DVI_MODE:
+        if(argv == HDMI_MODE) {
+        }
+        if(argv == DVI_MODE) {
+        }
+        break;
+    case CONF_SYSTEM_ST:
+        break;
+    case CONF_AUDIO_MUTE_OP:
+        if(argv == AUDIO_MUTE) {
+        }
+        if((argv == AUDIO_UNMUTE) && (hdmitx_device->tx_aud_cfg != 0)) {
+        }
+        break;
+    case CONF_VIDEO_BLANK_OP:
+        if(argv == VIDEO_BLANK) {
+            aml_write_reg32(P_VPU_HDMI_DATA_OVR, (0x200 << 20) | (0x0 << 10) | (0x200 << 0));   // set blank CrYCb as 0x200 0x0 0x200
+            aml_set_reg32_bits(P_VPU_HDMI_SETTING, 0, 5, 3);        // Output data map: CrYCb
+            aml_set_reg32_bits(P_VPU_HDMI_DATA_OVR, 1, 31, 1);      // Enable HDMI data override
+        }
+        if(argv == VIDEO_UNBLANK) {
+            aml_write_reg32(P_VPU_HDMI_DATA_OVR, 0);    // Disable HDMI data override
+        }
+        break;
+    case CONF_CLR_AVI_PACKET:
+        break;
+    case CONF_CLR_VSDB_PACKET:
+        break;
+    case CONF_CLR_AUDINFO_PACKET:
+        break;
+    default:
+        hdmi_print(ERR, "config: ""hdmitx: unknown cmd: 0x%x\n", cmd);
+    }
+    return 1;
+}
+
+static int hdmitx_cntl_misc(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(!(cmd & CMD_MISC_OFFSET))
+        hdmi_print(ERR, "misc: " "hdmitx: w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "misc: " "hdmitx: misc cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case MISC_HPD_MUX_OP:
+        if(argv == PIN_MUX)
+            argv = HPD_MUX_HPD;
+        else
+            argv = HPD_UNMUX_HPD;
+        return hdmitx_hpd_hw_op(argv);
+        break;
+    case MISC_HPD_GPI_ST:
+        return 1;
+        //return hdmitx_hpd_hw_op(HPD_READ_HPD_GPIO); // tmp mark
+        break;
+    case MISC_HPLL_OP:
+        printk("todo\n");
+        break;
+        if(argv == HPLL_ENABLE) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 1, 30, 1);   // disable hpll
+        }
+        if(argv == HPLL_DISABLE) {
+            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);   // disable hpll
+        }
+        break;
+    case MISC_TMDS_PHY_OP:
+        if(argv == TMDS_PHY_ENABLE) {
+            hdmi_phy_wakeup(hdmitx_device);  // TODO
+        }
+        if(argv == TMDS_PHY_DISABLE) {
+            hdmi_phy_suspend();
+        }
+        break;
+    case MISC_VIID_IS_USING:
+        return !!(aml_read_reg32(P_HHI_VID2_PLL_CNTL) & (1 << 30));     // bit30: enable
+        break;
+    case MISC_CONF_MODE420:
+#define CLK_UTIL_VID_PLL_DIV_2p5    14
+        aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2, 0, 16, 2);
+        aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2, 0, 18, 2);
+        aml_set_reg32_bits(P_HHI_VID_CLK_DIV, 0, 0, 8);
+        aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 1, 1);
+        aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 1, 16, 4);
+        aml_write_reg32(P_HHI_HDMI_PHY_CNTL3, 0x303e005b);
+        hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF0, 0x43);
+        hdmitx_wr_reg(HDMITX_DWC_FC_SCRAMBLER_CTRL, 0);
+        aml_write_reg32(P_VPU_HDMI_FMT_CTRL, 0x1a);
+        aml_write_reg32(P_VPU_HDMI_SETTING, 0x10e);
+        break;
+    case MISC_TMDS_CLK_DIV40:
+        hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 1);
+        msleep(10);
+        hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 3);
+        break;
+    default:
+        hdmi_print(ERR, "misc: " "hdmitx: unknown cmd: 0x%x\n", cmd);
+    }
+    return 1;
+}
+
+static int hdmitx_get_state(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
+{
+    if(!(cmd & CMD_STAT_OFFSET))
+        hdmi_print(ERR, "stat: " "hdmitx: w: invalid cmd 0x%x\n", cmd);
+    else
+        hdmi_print(LOW, "stat: " "hdmitx: misc cmd 0x%x\n", cmd);
+
+    switch(cmd) {
+    case STAT_VIDEO_VIC:
+        break;
+    case STAT_VIDEO_CLK:
+        break;
+    default:
+        break;
+    }
+    return 0;
+}
+
+// The following two functions should move to 
+// static struct platform_driver amhdmitx_driver.suspend & .wakeup
+// For tempelet use only.
+// Later will change it.
+typedef struct 
+{
+    unsigned long reg;
+    unsigned long val_sleep;
+    unsigned long val_save;
+}hdmi_phy_t;
+
+static unsigned int hdmi_phy_save = 0x08930e9b;     // Default setting
+
+static void hdmi_phy_suspend(void)
+{
+    hdmi_phy_save = aml_read_reg32(P_HHI_HDMI_PHY_CNTL0);
+    aml_write_reg32(P_HHI_HDMI_PHY_CNTL0, 0x08418d00);
+    //hdmi_print(INF, SYS "phy suspend\n");
+}
+
+static void hdmi_phy_wakeup(hdmitx_dev_t* hdmitx_device)
+{
+    hdmitx_set_phy(hdmitx_device);
+    //hdmi_print(INF, SYS "phy wakeup\n");
+}
+
+
+
+enum hdmi_color_depth {
+    HDMI_COLOR_DEPTH_24B = 4,
+    HDMI_COLOR_DEPTH_30B = 5,
+    HDMI_COLOR_DEPTH_36B = 6,
+    HDMI_COLOR_DEPTH_48B = 7,
+};
+
+enum hdmi_color_format {
+    HDMI_COLOR_FORMAT_RGB,
+    HDMI_COLOR_FORMAT_444,
+    HDMI_COLOR_FORMAT_422,
+    HDMI_COLOR_FORMAT_420,
+};
+
+enum hdmi_color_range {
+    HDMI_COLOR_RANGE_LIM,
+    HDMI_COLOR_RANGE_FUL,
+};
+
+enum hdmi_audio_packet {
+    HDMI_AUDIO_PACKET_SMP = 0x02,
+    HDMI_AUDIO_PACKET_1BT = 0x07,
+    HDMI_AUDIO_PACKET_DST = 0x08,
+    HDMI_AUDIO_PACKET_HBR = 0x09,
+};
+
+#define TX_COLOR_DEPTH          HDMI_COLOR_DEPTH_24B    // Pixel bit width: 4=24-bit; 5=30-bit; 6=36-bit; 7=48-bit.
+//#define TX_INPUT_COLOR_FORMAT   HDMI_COLOR_FORMAT_444   // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+#define TX_OUTPUT_COLOR_FORMAT  HDMI_COLOR_FORMAT_444   // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+//#define TX_INPUT_COLOR_RANGE    HDMI_COLOR_RANGE_LIM    // Pixel range: 0=limited; 1=full.
+//#define TX_OUTPUT_COLOR_RANGE   HDMI_COLOR_RANGE_LIM    // Pixel range: 0=limited; 1=full.
+
+static struct hdmi_format_para hdmi_1080p50hz_fmt_para = {
+    .vic = HDMI_1080p50,
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .timing = {
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2640,
+        .h_blank = 720,
+        .h_front = 528,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_back = 36,
+        .v_sync = 5,
+        .v_front = 4,
+    },
+};
+
+struct hdmi_format_para hdmi_1080p_fmt_para = {
+    .vic = HDMI_1080p60,
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .timing = {
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_front = 88,
+        .h_sync = 44,
+        .h_back = 148,
+        .h_blank = (88 + 44 + 148),
+        .h_total = (1920 + 88 + 44 + 148),
+        .v_active = 1080,
+        .v_front = 4,
+        .v_sync = 5,
+        .v_back = 36,
+        .v_blank = (4 + 5 + 36),
+        .v_total = (1080 + 4 + 5 + 36),
+    },
+};
+
+struct hdmi_format_para hdmi_4k2k30hz_fmt_para = {
+    .vic = HDMI_3840x2160p30_16x9,
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .timing = {
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_front = 176,
+        .h_sync = 88,
+        .h_back = 296,
+        .h_blank = (176 + 88 + 296),
+        .h_total = (3840 + 176 + 88 + 296),
+        .v_active = 2160,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_blank = (8 + 10 + 72),
+        .v_total = (2160 + 8 + 10 + 72),
+    },
+};
+
+struct hdmi_format_para hdmi_4k2k50hz_fmt_para = {
+    .vic = HDMI_3840x2160p50_16x9,
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .timing = {
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_front = 176,
+        .h_sync = 88,
+        .h_back = 296,
+        .h_blank = (176 + 88 + 296),
+        .h_total = (3840 + 176 + 88 + 296),
+        .v_active = 2160,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_blank = (8 + 10 + 72),
+        .v_total = (2160 + 8 + 10 + 72),
+    },
+};
+
+struct hdmi_format_para hdmi_4k2k60hz_fmt_para = {
+    .vic = HDMI_3840x2160p60_16x9,
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .timing = {
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_front = 176,
+        .h_sync = 88,
+        .h_back = 296,
+        .h_blank = (176 + 88 + 296),
+        .h_total = (3840 + 176 + 88 + 296),
+        .v_active = 2160,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_blank = (8 + 10 + 72),
+        .v_total = (2160 + 8 + 10 + 72),
+    },
+};
+
+// TODO
+struct hdmi_format_para *all_fmt_paras[] = {
+    &hdmi_4k2k60hz_fmt_para,
+    &hdmi_4k2k50hz_fmt_para,
+    &hdmi_1080p50hz_fmt_para,
+    &hdmi_4k2k30hz_fmt_para,
+    &hdmi_1080p_fmt_para,
+};
+
+//TODO VIC
+static struct hdmi_format_para * get_fmt_paras(HDMI_Video_Codes_t vic)
+{
+    int i;
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        if(vic == all_fmt_paras[i]->vic)
+            return all_fmt_paras[i];
+    }
+    return NULL;
+}
+
+enum tvout_enc_type
+{
+    TVOUT_480I  = 0,
+    TVOUT_480CVBS,
+    TVOUT_480P  ,
+    TVOUT_576I  ,
+    TVOUT_576CVBS,
+    TVOUT_576P  ,
+    TVOUT_720P  ,
+    TVOUT_1080I ,
+    TVOUT_1080P ,
+    TVOUT_720P_50HZ,
+    TVOUT_1080I_50HZ,
+    TVOUT_1080P_50HZ,
+    TVOUT_1080P_24HZ,
+    TVOUT_4K2K_30HZ,
+    TVOUT_4K2K_25HZ,
+    TVOUT_4K2K_24HZ,
+    TVOUT_4K2K_SMPTE,
+    TVOUT_4K2K_5G,
+    TVOUT_4K2K_60HZ,
+    TVOUT_MAX   
+};
+
+struct enc_reg_set {
+    unsigned int addr;
+    unsigned int val;
+};
+
+struct enc_reg_map {
+    enum tvout_enc_type type;
+    struct enc_reg_set *set;
+};
+
+static struct enc_reg_set tvregs_1080p_50hz[] = {
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x1052,},
+
+    // bit 13    1          (delayed prog_vs)
+    // bit 5:4:  2          (pixel[0])
+    // bit 3:    1          invert vsync or not
+    // bit 2:    1          invert hsync or not
+    // bit1:     1          (select viu sync)
+    // bit0:     1          (progressive)
+    {P_VENC_DVI_SETTING,           0x000d,},
+    {P_ENCP_VIDEO_MAX_PXCNT,       2639,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       1124,  },
+    /* horizontal timing settings */
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    44,  },//1980
+    {P_ENCP_VIDEO_HSPULS_END,      132,    },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   44,    },
+
+    //DE position in horizontal
+    {P_ENCP_VIDEO_HAVON_BEGIN,     271,   },
+    {P_ENCP_VIDEO_HAVON_END,       2190,  },
+
+    //ditital hsync positon in horizontal
+    {P_ENCP_VIDEO_HSO_BEGIN,       79 ,    },
+    {P_ENCP_VIDEO_HSO_END,         123,  },
+
+    /* vsync horizontal timing */
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    220,   },
+    {P_ENCP_VIDEO_VSPULS_END,      2140,  },
+
+    /* vertical timing settings */
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    4,     },//35
+    {P_ENCP_VIDEO_EQPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    4,     },//35
+    {P_ENCP_VIDEO_VAVON_BLINE,     41,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     1120,  },
+
+    //adjust the hsync & vsync start point and end point
+    {P_ENCP_VIDEO_VSO_BEGIN,       79,  },
+    {P_ENCP_VIDEO_VSO_END,         79,  },
+
+    //adjust the vsync start line and end line
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
+
+    {P_ENCP_VIDEO_YFP1_HTIME,      271,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      2190,  },
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_ENCP_VIDEO_MODE,            0x4040,},
+    {P_ENCP_VIDEO_MODE_ADV,        0x0018,},
+
+    {P_ENCP_VIDEO_SYNC_MODE,       0x7, }, //bit[15:8] -- adjust the vsync vertical position
+
+    {P_ENCP_VIDEO_YC_DLY,          0,     },      //Y/Cb/Cr delay
+
+    {P_ENCP_VIDEO_RGB_CTRL, 2,},       // enable sync on B
+
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,},
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},
+    {P_ENCP_DACSEL_0,              0x3102,},
+    {P_ENCP_DACSEL_1,              0x0054,},
+    {P_VENC_VDAC_DACSEL0,          0x0001,},
+    {P_VENC_VDAC_DACSEL1,          0x0001,},
+    {P_VENC_VDAC_DACSEL2,          0x0001,},
+    {P_VENC_VDAC_DACSEL3,          0x0001,},
+    {P_VENC_VDAC_DACSEL4,          0x0001,},
+    {P_VENC_VDAC_DACSEL5,          0x0001,},
+    {P_ENCI_VIDEO_EN,              0,     },
+    {P_ENCP_VIDEO_EN,              1,     },
+    {-1,            -1      }
+};
+
+static struct enc_reg_set enc_1080p_set[] = {
+    {P_ENCP_VIDEO_MODE,             0x0040 | (1<<14)}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+    {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
+    {P_ENCP_VIDEO_YFP1_HTIME,       140},
+    {P_ENCP_VIDEO_YFP2_HTIME,       140 + 1920},//2060},
+    {P_ENCP_VIDEO_MAX_PXCNT,        2200 - 1},//2199},
+    {P_ENCP_VIDEO_HSPULS_BEGIN,     2156},
+    {P_ENCP_VIDEO_HSPULS_END,       44},
+    {P_ENCP_VIDEO_HSPULS_SWITCH,    44},
+    {P_ENCP_VIDEO_VSPULS_BEGIN,     140},
+    {P_ENCP_VIDEO_VSPULS_END,       140 + 1920 - 1},//2059},
+    {P_ENCP_VIDEO_VSPULS_BLINE,     0},
+    {P_ENCP_VIDEO_VSPULS_ELINE,     4},
+    {P_ENCP_VIDEO_HAVON_BEGIN,      148},
+    {P_ENCP_VIDEO_HAVON_END,        148 + 1920 - 1},//2067},
+    {P_ENCP_VIDEO_VAVON_BLINE,      45},
+    {P_ENCP_VIDEO_VAVON_ELINE,      45 + 1080 - 1},//1124},
+    {P_ENCP_VIDEO_HSO_BEGIN,        44},
+    {P_ENCP_VIDEO_HSO_END,          2156},
+    {P_ENCP_VIDEO_VSO_BEGIN,        2100},
+    {P_ENCP_VIDEO_VSO_END,          2164},
+    {P_ENCP_VIDEO_VSO_BLINE,        3},
+    {P_ENCP_VIDEO_VSO_ELINE,        5},
+    {P_ENCP_VIDEO_MAX_LNCNT,        1125 - 1},//1124},
+    {P_ENCP_VIDEO_FILT_CTRL,        0x1000}, //bypass filter
+    {P_VENC_VDAC_DACSEL0,           0x9},
+    {P_VENC_VDAC_DACSEL1,           0xa},
+    {P_VENC_VDAC_DACSEL2,           0xb},
+    {P_VENC_VDAC_DACSEL3,           0xc},
+    {P_VENC_VDAC_DACSEL4,           0xd},
+    {P_VENC_VDAC_DACSEL5,           0xe},
+    {-1, -1},   //end
+};
+
+static struct enc_reg_set enc_4k2k30hz_set[] = {
+    {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+    {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
+    {P_ENCP_VIDEO_YFP1_HTIME,       140},
+    {P_ENCP_VIDEO_YFP2_HTIME,       140+3840},
+    {P_ENCP_VIDEO_MAX_PXCNT,        3840+560-1},
+    {P_ENCP_VIDEO_HSPULS_BEGIN,     2156+1920},
+    {P_ENCP_VIDEO_HSPULS_END,       44},
+    {P_ENCP_VIDEO_HSPULS_SWITCH,    44},
+    {P_ENCP_VIDEO_VSPULS_BEGIN,     140},
+    {P_ENCP_VIDEO_VSPULS_END,       2059+1920},
+    {P_ENCP_VIDEO_VSPULS_BLINE,     0},
+    {P_ENCP_VIDEO_VSPULS_ELINE,     4},
+
+    {P_ENCP_VIDEO_HAVON_BEGIN,      148},
+    {P_ENCP_VIDEO_HAVON_END,        3987},
+    {P_ENCP_VIDEO_VAVON_BLINE,      89},
+    {P_ENCP_VIDEO_VAVON_ELINE,      2248},
+
+    {P_ENCP_VIDEO_HSO_BEGIN,	    44},
+    {P_ENCP_VIDEO_HSO_END, 		    2156+1920},
+    {P_ENCP_VIDEO_VSO_BEGIN,	    2100+1920},
+    {P_ENCP_VIDEO_VSO_END, 		    2164+1920},
+
+    {P_ENCP_VIDEO_VSO_BLINE,        51},
+    {P_ENCP_VIDEO_VSO_ELINE,        53},
+    {P_ENCP_VIDEO_MAX_LNCNT,        2249},
+
+    {P_ENCP_VIDEO_FILT_CTRL,        0x1000}, //bypass filter
+    {-1, -1},
+};
+
+static struct enc_reg_set enc_4k2k5g_set[] = {
+    {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+    {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
+    {P_ENCP_VIDEO_YFP1_HTIME,       140},
+    {P_ENCP_VIDEO_YFP2_HTIME,       140+3840},
+    {P_ENCP_VIDEO_MAX_PXCNT,        3840+560-1},
+    {P_ENCP_VIDEO_HSPULS_BEGIN,     2156+1920},
+    {P_ENCP_VIDEO_HSPULS_END,       44},
+    {P_ENCP_VIDEO_HSPULS_SWITCH,    44},
+    {P_ENCP_VIDEO_VSPULS_BEGIN,     140},
+    {P_ENCP_VIDEO_VSPULS_END,       2059+1920},
+    {P_ENCP_VIDEO_VSPULS_BLINE,     0},
+    {P_ENCP_VIDEO_VSPULS_ELINE,     4},
+
+    {P_ENCP_VIDEO_HAVON_BEGIN,      148},
+    {P_ENCP_VIDEO_HAVON_END,        3987},
+    {P_ENCP_VIDEO_VAVON_BLINE,      89},
+    {P_ENCP_VIDEO_VAVON_ELINE,      2248},
+
+    {P_ENCP_VIDEO_HSO_BEGIN,	    44},
+    {P_ENCP_VIDEO_HSO_END, 		    2156+1920},
+    {P_ENCP_VIDEO_VSO_BEGIN,	    2100+1920},
+    {P_ENCP_VIDEO_VSO_END, 		    2164+1920},
+
+    {P_ENCP_VIDEO_VSO_BLINE,        51},
+    {P_ENCP_VIDEO_VSO_ELINE,        53},
+    {P_ENCP_VIDEO_MAX_LNCNT,        2249},
+
+    {P_ENCP_VIDEO_FILT_CTRL,        0x1000}, //bypass filter
+    {-1, -1},
+};
+
+static struct enc_reg_set enc_4k2k60hz_set[] = {
+    {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+    {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
+    {P_ENCP_VIDEO_YFP1_HTIME,       140},
+    {P_ENCP_VIDEO_YFP2_HTIME,       140+3840},
+    {P_ENCP_VIDEO_MAX_PXCNT,        3840+560-1},
+    {P_ENCP_VIDEO_HSPULS_BEGIN,     2156+1920},
+    {P_ENCP_VIDEO_HSPULS_END,       44},
+    {P_ENCP_VIDEO_HSPULS_SWITCH,    44},
+    {P_ENCP_VIDEO_VSPULS_BEGIN,     140},
+    {P_ENCP_VIDEO_VSPULS_END,       2059+1920},
+    {P_ENCP_VIDEO_VSPULS_BLINE,     0},
+    {P_ENCP_VIDEO_VSPULS_ELINE,     4},
+
+    {P_ENCP_VIDEO_HAVON_BEGIN,      148},
+    {P_ENCP_VIDEO_HAVON_END,        3987},
+    {P_ENCP_VIDEO_VAVON_BLINE,      89},
+    {P_ENCP_VIDEO_VAVON_ELINE,      2248},
+
+    {P_ENCP_VIDEO_HSO_BEGIN,	    44},
+    {P_ENCP_VIDEO_HSO_END, 		    2156+1920},
+    {P_ENCP_VIDEO_VSO_BEGIN,	    2100+1920},
+    {P_ENCP_VIDEO_VSO_END, 		    2164+1920},
+
+    {P_ENCP_VIDEO_VSO_BLINE,        51},
+    {P_ENCP_VIDEO_VSO_ELINE,        53},
+    {P_ENCP_VIDEO_MAX_LNCNT,        2249},
+
+    {P_ENCP_VIDEO_FILT_CTRL,        0x1000}, //bypass filter
+    {-1, -1},
+};
+
+// TODO, add other formats timing here
+static struct enc_reg_map enc_reg_array[] = {
+    {TVOUT_1080P, &enc_1080p_set[0]},
+    {TVOUT_4K2K_30HZ, &enc_4k2k30hz_set[0]},
+    {TVOUT_1080P_50HZ, &tvregs_1080p_50hz[0]},
+    {TVOUT_4K2K_5G, &enc_4k2k5g_set[0]},
+    {TVOUT_4K2K_60HZ, &enc_4k2k60hz_set[0]},
+};
+
+void config_tv_enc(enum tvout_enc_type output_type )
+{
+    int i;
+    struct enc_reg_set *reg;
+
+    for(i = 0; i < sizeof(enc_reg_array) / sizeof(struct enc_reg_map); i++) {
+        if(output_type == enc_reg_array[i].type) {
+            reg = enc_reg_array[i].set;
+            while(reg->addr != -1) {
+                aml_write_reg32(reg->addr, reg->val);
+                reg ++;
+            }
+            break;
+        }
+    }
+    if(i == sizeof(enc_reg_array) / sizeof(struct enc_reg_map)) {
+        printk("not find output_type %d\n", output_type);
+    }
+} /* config_tv_enc */
+
+static void power_switch_to_vpu_hdmi(int pwr_ctrl)
+{
+    unsigned int i;
+    if(pwr_ctrl == 1) {
+        // Powerup VPU_HDMI
+        aml_set_reg32_bits(P_AO_RTI_GEN_PWR_SLEEP0, 0, 8, 1);
+
+        // power up memories
+        for(i = 0; i < 32; i++) {
+            aml_set_reg32_bits(P_HHI_VPU_MEM_PD_REG0, 0, i, 1);
+            msleep(10);
+        }
+        for(i = 0; i < 32; i++) {
+            aml_set_reg32_bits(P_HHI_VPU_MEM_PD_REG1, 0, i, 1);
+            msleep(10);
+        }
+        for(i = 8; i < 16; i++) {
+            aml_set_reg32_bits(P_HHI_MEM_PD_REG0, 0, i, 8); // MEM-PD
+        }
+        // Remove VPU_HDMI ISO
+        aml_set_reg32_bits(P_AO_RTI_GEN_PWR_SLEEP0, 0, 9, 1);
+    } else {
+        // Add isolations
+        aml_set_reg32_bits(P_AO_RTI_GEN_PWR_SLEEP0, 1, 9, 1);
+
+        // Power off VPU_HDMI domain
+        aml_write_reg32(P_HHI_VPU_MEM_PD_REG0, 0xffffffff );
+        aml_write_reg32(P_HHI_VPU_MEM_PD_REG1, 0xffffffff );
+        aml_write_reg32(P_HHI_MEM_PD_REG0, aml_read_reg32(HHI_MEM_PD_REG0) | (0xff << 8)); // HDMI MEM-PD
+        aml_set_reg32_bits(P_AO_RTI_GEN_PWR_SLEEP0, 1, 8, 1);  //PDN
+    }
+}
+
+static void hdmitx_vpu_init(void)
+{
+    power_switch_to_vpu_hdmi(1);
+}
+
+static void tmp_generate_vid_hpll(void)
+{
+    printk("%s[%d]\n", __func__, __LINE__);
+    hdmitx_vpu_init();
+}
+
+void config_hdmi20_tx ( HDMI_Video_Codes_t vic, struct hdmi_format_para *para,
+                        unsigned char   color_depth,            // Pixel bit width: 4=24-bit; 5=30-bit; 6=36-bit; 7=48-bit.
+                        unsigned char   input_color_format,     // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                        unsigned char   input_color_range,      // Pixel range: 0=limited; 1=full.
+                        unsigned char   output_color_format,    // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                        unsigned char   output_color_range     // Pixel range: 0=limited; 1=full.
+                    )          // 0:TMDS_CLK_rate=TMDS_Character_rate; 1:TMDS_CLK_rate=TMDS_Character_rate/4, for TMDS_Character_rate>340Mcsc.
+{
+    struct hdmi_cea_timing *t = &para->timing;
+    unsigned long   data32;
+    unsigned char   vid_map;
+    unsigned char   csc_en;
+    unsigned char   default_phase = 0;
+
+#define GET_TIMING(name)      (t->name)
+
+    //--------------------------------------------------------------------------
+    // Enable clocks and bring out of reset
+    //--------------------------------------------------------------------------
+    
+    // Enable hdmitx_sys_clk
+    //         .clk0               ( cts_oscin_clk         ),
+    //         .clk1               ( fclk_div4             ),
+    //         .clk2               ( fclk_div3             ),
+    //         .clk3               ( fclk_div5             ),
+    aml_set_reg32_bits(P_HHI_HDMI_CLK_CNTL, 0x100, 0, 16);   // [10: 9] clk_sel. select cts_oscin_clk=24MHz
+                                                                // [    8] clk_en. Enable gated clock
+                                                                // [ 6: 0] clk_div. Divide by 1. = 24/1 = 24 MHz
+    
+    aml_set_reg32_bits(P_HHI_GCLK_MPEG2, 1, 4, 1);       // Enable clk81_hdmitx_pclk
+    // wire            wr_enable           = control[3];
+    // wire            fifo_enable         = control[2];    
+    // assign          phy_clk_en          = control[1];
+    aml_set_reg32_bits(P_HHI_HDMI_PHY_CNTL1, 1, 1, 1);   // Enable tmds_clk
+    aml_set_reg32_bits(P_HHI_HDMI_PHY_CNTL1, 1, 2, 1);   // Enable the decoupling FIFO
+    aml_set_reg32_bits(P_HHI_HDMI_PHY_CNTL1, 1, 3, 1);   // Enable enable the write/read decoupling state machine 
+    aml_set_reg32_bits(P_HHI_MEM_PD_REG0, 0, 8, 8);      // Bring HDMITX MEM output of power down
+
+    // Enable APB3 fail on error
+    aml_set_reg32_bits(P_HDMITX_CTRL_PORT, 1, 15, 1);
+    aml_set_reg32_bits((P_HDMITX_CTRL_PORT + 0x10), 1, 15, 1);
+
+    // Bring out of reset
+    hdmitx_wr_reg(HDMITX_TOP_SW_RESET,  0);
+
+    // Enable internal pixclk, tmds_clk, spdif_clk, i2s_clk, cecclk
+    hdmitx_wr_reg(HDMITX_TOP_CLK_CNTL,  0x0000001f);
+    hdmitx_wr_reg(HDMITX_DWC_MC_LOCKONCLOCK,   0xff);
+
+    // But keep spdif_clk and i2s_clk disable until later enable by test.c
+    data32  = 0;
+    data32 |= (0    << 6);  // [  6] hdcpclk_disable
+    data32 |= (0    << 5);  // [  5] cecclk_disable
+    data32 |= (0    << 4);  // [  4] cscclk_disable
+    data32 |= (0    << 3);  // [  3] audclk_disable
+    data32 |= (0    << 2);  // [  2] prepclk_disable
+    data32 |= (0    << 1);  // [  1] tmdsclk_disable
+    data32 |= (0    << 0);  // [  0] pixelclk_disable
+    hdmitx_wr_reg(HDMITX_DWC_MC_CLKDIS, data32);
+
+    // Enable normal output to PHY
+
+    switch(vic) {
+    case HDMI_3840x2160p50_16x9:
+    case HDMI_3840x2160p60_16x9:
+        para->tmds_clk_div40 = 1;
+        break;
+    default:
+        break;
+    }
+
+    data32  = 0;
+    data32 |= (1    << 12); // [14:12] tmds_sel: 0=output 0; 1=output normal data; 2=output PRBS; 4=output shift pattern.
+    data32 |= (0    << 8);  // [11: 8] shift_pttn
+    data32 |= (0    << 0);  // [ 4: 0] prbs_pttn
+    hdmitx_wr_reg(HDMITX_TOP_BIST_CNTL, data32);                        // 0x6
+
+    printk("vic = %d, tmds_clk_div40 = %d\n", vic, para->tmds_clk_div40);
+    if (para->tmds_clk_div40) {
+        data32  = 0;
+        data32 |= (0    << 16); // [25:16] tmds_clk_pttn[19:10]
+        data32 |= (0    << 0);  // [ 9: 0] tmds_clk_pttn[ 9: 0]
+        hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_01, data32);             // 0xa
+        
+        data32  = 0;
+        data32 |= (0x3ff<< 16); // [25:16] tmds_clk_pttn[39:30]
+        data32 |= (0x3ff<< 0);  // [ 9: 0] tmds_clk_pttn[29:20]
+        hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_23, data32);             // 0xb
+    }
+    else {
+        data32  = 0;
+        data32 |= (0x1f    << 16); // [25:16] tmds_clk_pttn[19:10]
+        data32 |= (0x1f    << 0);  // [ 9: 0] tmds_clk_pttn[ 9: 0]
+        hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_01, data32);             // 0xa
+        
+        data32  = 0;
+        data32 |= (0x1f<< 16); // [25:16] tmds_clk_pttn[39:30]
+        data32 |= (0x1f<< 0);  // [ 9: 0] tmds_clk_pttn[29:20]
+        hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_23, data32);             // 0xb
+    }
+
+
+    printk("%s[%d]0x%x\n", __func__, __LINE__, hdmitx_rd_reg(HDMITX_TOP_TMDS_CLK_PTTN_01));
+    printk("%s[%d]0x%x\n", __func__, __LINE__, hdmitx_rd_reg(HDMITX_TOP_TMDS_CLK_PTTN_23));
+
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x1);            // 0xc
+
+    msleep(10);
+
+    hdmitx_wr_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x2);            // 0xc
+
+    printk("%s[%d]0x%x\n", __func__, __LINE__, hdmitx_rd_reg(HDMITX_TOP_TMDS_CLK_PTTN_CNTL));
+
+    //--------------------------------------------------------------------------
+    // Configure video
+    //--------------------------------------------------------------------------
+    
+    if (((input_color_format == HDMI_COLOR_FORMAT_420) || (output_color_format == HDMI_COLOR_FORMAT_420)) &&
+        ((input_color_format != output_color_format) || (input_color_range != output_color_range))) {
+        printk("Error: HDMITX input/output color combination not supported!\n");
+    }
+
+    // Configure video sampler
+
+    vid_map = ( input_color_format == HDMI_COLOR_FORMAT_RGB )?  ((color_depth == HDMI_COLOR_DEPTH_24B)? 0x01    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_30B)? 0x03    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_36B)? 0x05    :
+                                                                                                        0x07)   :
+              ((input_color_format == HDMI_COLOR_FORMAT_444) ||
+               (input_color_format == HDMI_COLOR_FORMAT_420))?  ((color_depth == HDMI_COLOR_DEPTH_24B)? 0x09    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_30B)? 0x0b    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_36B)? 0x0d    :
+                                                                                                        0x0f)   :
+                                                                ((color_depth == HDMI_COLOR_DEPTH_24B)? 0x16    :
+                                                                 (color_depth == HDMI_COLOR_DEPTH_30B)? 0x14    :
+                                                                                                        0x12);
+    
+    data32  = 0;
+    data32 |= (0        << 7);  // [  7] internal_de_generator
+    data32 |= (vid_map  << 0);  // [4:0] video_mapping
+    hdmitx_wr_reg(HDMITX_DWC_TX_INVID0, data32);
+    
+    data32  = 0;
+    data32 |= (0        << 2);  // [  2] bcbdata_stuffing
+    data32 |= (0        << 1);  // [  1] rcrdata_stuffing
+    data32 |= (0        << 0);  // [  0] gydata_stuffing
+    hdmitx_wr_reg(HDMITX_DWC_TX_INSTUFFING, data32);
+    hdmitx_wr_reg(HDMITX_DWC_TX_GYDATA0,    0x00);
+    hdmitx_wr_reg(HDMITX_DWC_TX_GYDATA1,    0x00);
+    hdmitx_wr_reg(HDMITX_DWC_TX_RCRDATA0,   0x00);
+    hdmitx_wr_reg(HDMITX_DWC_TX_RCRDATA1,   0x00);
+    hdmitx_wr_reg(HDMITX_DWC_TX_BCBDATA0,   0x00);
+    hdmitx_wr_reg(HDMITX_DWC_TX_BCBDATA1,   0x00);
+
+    // Configure Color Space Converter
+    
+    csc_en  = ((input_color_format != output_color_format) ||
+               (input_color_range  != output_color_range))? 1 : 0;
+    
+    data32  = 0;
+    data32 |= (csc_en   << 0);  // [  0] CSC enable
+    hdmitx_wr_reg(HDMITX_DWC_MC_FLOWCTRL,   data32);
+
+    data32  = 0;
+    data32 |= ((((input_color_format ==HDMI_COLOR_FORMAT_422) &&
+                 (output_color_format!=HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 4);  // [5:4] intmode
+    data32 |= ((((input_color_format !=HDMI_COLOR_FORMAT_422) &&
+                 (output_color_format==HDMI_COLOR_FORMAT_422))? 2 : 0 ) << 0);  // [1:0] decmode
+    hdmitx_wr_reg(HDMITX_DWC_CSC_CFG,       data32);
+
+    hdmitx_csc_config(input_color_format, output_color_format, color_depth);
+    
+    // Configure video packetizer
+
+    // Video Packet color depth and pixel repetition
+    data32  = 0;
+    data32 |= (((output_color_format==HDMI_COLOR_FORMAT_422)? HDMI_COLOR_DEPTH_24B : color_depth)   << 4);  // [7:4] color_depth
+    data32 |= (0                                                                                    << 0);  // [3:0] desired_pr_factor
+    hdmitx_wr_reg(HDMITX_DWC_VP_PR_CD,  data32);
+
+    // Video Packet Stuffing
+    data32  = 0;
+    data32 |= (default_phase    << 5);  // [  5] default_phase
+    data32 |= (0                << 2);  // [  2] ycc422_stuffing
+    data32 |= (0                << 1);  // [  1] pp_stuffing
+    data32 |= (0                << 0);  // [  0] pr_stuffing
+    hdmitx_wr_reg(HDMITX_DWC_VP_STUFF,  data32);
+
+    // Video Packet YCC color remapping
+    data32  = 0;
+    data32 |= (((color_depth == HDMI_COLOR_DEPTH_30B)? 1 :
+                (color_depth == HDMI_COLOR_DEPTH_36B)? 2 : 0)   << 0);  // [1:0] ycc422_size
+    hdmitx_wr_reg(HDMITX_DWC_VP_REMAP,  data32);
+
+    // Video Packet configuration
+    data32  = 0;
+    data32 |= ((((output_color_format != HDMI_COLOR_FORMAT_422) &&
+                 (color_depth         == HDMI_COLOR_DEPTH_24B))? 1 : 0) << 6);  // [  6] bypass_en
+    data32 |= ((((output_color_format == HDMI_COLOR_FORMAT_422) ||
+                 (color_depth         == HDMI_COLOR_DEPTH_24B))? 0 : 1) << 5);  // [  5] pp_en
+    data32 |= (0                                                        << 4);  // [  4] pr_en
+    data32 |= (((output_color_format == HDMI_COLOR_FORMAT_422)?  1 : 0) << 3);  // [  3] ycc422_en
+    data32 |= (1                                                        << 2);  // [  2] pr_bypass_select
+    data32 |= (((output_color_format == HDMI_COLOR_FORMAT_422)? 1 :
+                (color_depth         == HDMI_COLOR_DEPTH_24B)?  2 : 0)  << 0);  // [1:0] output_selector: 0=pixel packing; 1=YCC422 remap; 2/3=8-bit bypass
+    hdmitx_wr_reg(HDMITX_DWC_VP_CONF,   data32);
+
+    data32  = 0;
+    data32 |= (1    << 7);  // [  7] mask_int_full_prpt
+    data32 |= (1    << 6);  // [  6] mask_int_empty_prpt
+    data32 |= (1    << 5);  // [  5] mask_int_full_ppack
+    data32 |= (1    << 4);  // [  4] mask_int_empty_ppack
+    data32 |= (1    << 3);  // [  3] mask_int_full_remap
+    data32 |= (1    << 2);  // [  2] mask_int_empty_remap
+    data32 |= (1    << 1);  // [  1] mask_int_full_byp
+    data32 |= (1    << 0);  // [  0] mask_int_empty_byp
+    hdmitx_wr_reg(HDMITX_DWC_VP_MASK,   data32);
+
+    //--------------------------------------------------------------------------
+    // Configure audio
+    //--------------------------------------------------------------------------
+
+    //I2S Sampler config
+
+    data32  = 0;
+    data32 |= (1    << 3);  // [  3] fifo_empty_mask: 0=enable int; 1=mask int.
+    data32 |= (1    << 2);  // [  2] fifo_full_mask: 0=enable int; 1=mask int.
+    hdmitx_wr_reg(HDMITX_DWC_AUD_INT,   data32);
+
+    data32  = 0;
+    data32 |= (1    << 4);  // [  4] fifo_overrun_mask: 0=enable int; 1=mask int. Enable it later when audio starts.
+    hdmitx_wr_reg(HDMITX_DWC_AUD_INT1,  data32);
+
+    data32  = 0;
+    data32 |= (0    << 5);  // [7:5] i2s_mode: 0=standard I2S mode
+    data32 |= (24   << 0);  // [4:0] i2s_width
+    hdmitx_wr_reg(HDMITX_DWC_AUD_CONF1, data32);
+
+    //spdif sampler config
+
+    data32  = 0;
+    data32 |= (1    << 3);  // [  3] SPDIF fifo_empty_mask: 0=enable int; 1=mask int.
+    data32 |= (1    << 2);  // [  2] SPDIF fifo_full_mask: 0=enable int; 1=mask int.
+    hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT,  data32);
+
+    data32  = 0;
+    data32 |= (0    << 4);  // [  4] SPDIF fifo_overrun_mask: 0=enable int; 1=mask int.
+    hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIFINT1, data32);
+
+    data32  = 0;
+    data32 |= (0    << 7);  // [  7] sw_audio_fifo_rst
+    hdmitx_wr_reg(HDMITX_DWC_AUD_SPDIF0,    data32);
+
+    //--------------------------------------------------------------------------
+    // Frame Composer configuration
+    //--------------------------------------------------------------------------
+
+    // Video definitions, as per output video (for packet gen/schedulling)
+
+    data32  = 0;
+//    data32 |= (((hdcp_on|scrambler_en)?1:0) << 7);  // [  7] HDCP_keepout
+    data32 |= (1                            << 7);  // [  7] HDCP_keepout
+    data32 |= (GET_TIMING(vsync_polarity)     << 6);  // [  6] vs_in_pol: 0=active low; 1=active high.
+    data32 |= (GET_TIMING(hsync_polarity)     << 5);  // [  5] hs_in_pol: 0=active low; 1=active high.
+    data32 |= (1                            << 4);  // [  4] de_in_pol: 0=active low; 1=active high.
+    data32 |= (1                            << 3);  // [  3] dvi_modez: 0=dvi; 1=hdmi.
+    data32 |= (!(para->progress_mode)         << 1);  // [  1] r_v_blank_in_osc
+    data32 |= (!(para->progress_mode)         << 0);  // [  0] in_I_P: 0=progressive; 1=interlaced.
+    hdmitx_wr_reg(HDMITX_DWC_FC_INVIDCONF,  data32);
+
+    data32  = GET_TIMING(h_active)&0xff;       // [7:0] H_in_active[7:0]
+    hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV0,   data32);
+    data32  = (GET_TIMING(h_active)>>8)&0x3f;  // [5:0] H_in_active[13:8]
+    hdmitx_wr_reg(HDMITX_DWC_FC_INHACTV1,   data32);
+
+    data32  = GET_TIMING(h_blank)&0xff;        // [7:0] H_in_blank[7:0]
+    hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK0,  data32);
+    data32  = (GET_TIMING(h_blank)>>8)&0x1f;   // [4:0] H_in_blank[12:8]
+    hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK1,  data32);
+
+    data32  = GET_TIMING(v_active)&0xff;        // [7:0] V_in_active[7:0]
+    hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV0,   data32);
+    data32  = (GET_TIMING(v_active)>>8)&0x1f;   // [4:0] V_in_active[12:8]
+    hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV1,   data32);
+
+    data32  = GET_TIMING(v_blank)&0xff;         // [7:0] V_in_blank
+    hdmitx_wr_reg(HDMITX_DWC_FC_INVBLANK,   data32);
+
+    data32  = GET_TIMING(h_front)&0xff;         // [7:0] H_in_delay[7:0]
+    hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY0,  data32);
+    data32  = (GET_TIMING(h_front)>>8)&0x1f;    // [4:0] H_in_delay[12:8]
+    hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINDELAY1,  data32);
+
+    data32  = GET_TIMING(h_sync)&0xff;        // [7:0] H_in_width[7:0]
+    hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH0,  data32);
+    data32  = (GET_TIMING(h_sync)>>8)&0x3;    // [1:0] H_in_width[9:8]
+    hdmitx_wr_reg(HDMITX_DWC_FC_HSYNCINWIDTH1,  data32);
+
+    data32  = GET_TIMING(v_front)&0xff;           // [7:0] V_in_delay
+    hdmitx_wr_reg(HDMITX_DWC_FC_VSYNCINDELAY,   data32);
+
+    data32  = GET_TIMING(v_sync)&0x3f;         // [5:0] V_in_width
+    hdmitx_wr_reg(HDMITX_DWC_FC_VSYNCINWIDTH,   data32);
+
+    //control period duration (typ 12 tmds periods)
+    hdmitx_wr_reg(HDMITX_DWC_FC_CTRLDUR,    12);
+    //extended control period duration (typ 32 tmds periods)
+    hdmitx_wr_reg(HDMITX_DWC_FC_EXCTRLDUR,  32);
+    //max interval betwen extended control period duration (typ 50)
+    hdmitx_wr_reg(HDMITX_DWC_FC_EXCTRLSPAC, 1);     // ??
+    //preamble filler
+    hdmitx_wr_reg(HDMITX_DWC_FC_CH0PREAM,   0x0b);
+    hdmitx_wr_reg(HDMITX_DWC_FC_CH1PREAM,   0x16);
+    hdmitx_wr_reg(HDMITX_DWC_FC_CH2PREAM,   0x21);
+
+    //write GCP packet configuration
+    data32  = 0;
+    data32 |= (default_phase    << 2);  // [  2] default_phase
+    data32 |= (0                << 1);  // [  1] set_avmute
+    data32 |= (0                << 0);  // [  0] clear_avmute
+    hdmitx_wr_reg(HDMITX_DWC_FC_GCP,    data32);
+
+    //write AVI Infoframe packet configuration
+    
+    data32  = 0;
+    data32 |= (((output_color_format>>2)&0x1)   << 7);  // [  7] rgb_ycc_indication[2]
+    data32 |= (1                                << 6);  // [  6] active_format_present
+    data32 |= (0                                << 4);  // [5:4] scan_information
+    data32 |= (0                                << 2);  // [3:2] bar_information
+    data32 |= (0x2                              << 0);  // [1:0] rgb_ycc_indication[1:0]
+    hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF0,   data32);
+
+    data32  = 0;
+    data32 |= (0    << 6);  // [7:6] colorimetry
+    data32 |= (0    << 4);  // [5:4] picture_aspect_ratio
+    data32 |= (8    << 0);  // [3:0] active_aspect_ratio
+    hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF1,   data32);
+
+    data32  = 0;
+    data32 |= (0    << 7);  // [  7] IT_content
+    data32 |= (0    << 4);  // [6:4] extended_colorimetry
+    data32 |= (0    << 2);  // [3:2] quantization_range
+    data32 |= (0    << 0);  // [1:0] non_uniform_picture_scaling
+    hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF2,   data32);
+
+    data32  = 0;
+    data32 |= (((output_color_range == HDMI_COLOR_RANGE_FUL)?1:0)   << 2);  // [3:2] YQ
+    data32 |= (0                                                    << 0);  // [1:0] CN
+    hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF3,   data32);
+
+    hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, para->vic);
+
+    // the audio setting bellow are only used for I2S audio IEC60958-3 frame insertion
+
+    //packet queue priority (auto mode)
+    hdmitx_wr_reg(HDMITX_DWC_FC_CTRLQHIGH,  15);
+    hdmitx_wr_reg(HDMITX_DWC_FC_CTRLQLOW,   3);
+
+    //packet scheduller configuration for SPD, VSD, ISRC1/2, ACP.
+    data32  = 0;
+    data32 |= (0    << 4);  // [  4] spd_auto
+    data32 |= (0    << 3);  // [  3] vsd_auto
+    data32 |= (0    << 2);  // [  2] isrc2_auto
+    data32 |= (0    << 1);  // [  1] isrc1_auto
+    data32 |= (0    << 0);  // [  0] acp_auto
+    hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO0,   data32);
+    hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO1,   0);
+    hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO2,   0);
+    hdmitx_wr_reg(HDMITX_DWC_FC_DATMAN,     0);
+
+    //packet scheduller configuration for AVI, GCP, AUDI, ACR.
+    data32  = 0;
+    data32 |= (1    << 3);  // [  3] avi_auto: insert on Vsync
+    data32 |= (1    << 2);  // [  2] gcp_auto: insert on Vsync
+    data32 |= (1    << 1);  // [  1] audi_auto: insert on Vsync
+    data32 |= (0    << 0);  // [  0] acr_auto: insert on CTS update. Assert this bit later to avoid inital packets with false CTS value
+    hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO3,   data32);
+    hdmitx_wr_reg(HDMITX_DWC_FC_RDRB0,      0);
+    hdmitx_wr_reg(HDMITX_DWC_FC_RDRB1,      0);
+    hdmitx_wr_reg(HDMITX_DWC_FC_RDRB2,      0);
+    hdmitx_wr_reg(HDMITX_DWC_FC_RDRB3,      0);
+    hdmitx_wr_reg(HDMITX_DWC_FC_RDRB4,      0);
+    hdmitx_wr_reg(HDMITX_DWC_FC_RDRB5,      0);
+    hdmitx_wr_reg(HDMITX_DWC_FC_RDRB6,      0);
+    hdmitx_wr_reg(HDMITX_DWC_FC_RDRB7,      0);
+
+    // Do not enable these interrupt below, we can check them at RX side.
+
+    data32  = 0;
+    data32 |= (1    << 7);  // [  7] AUDI_int_mask
+    data32 |= (1    << 6);  // [  6] ACP_int_mask
+    data32 |= (1    << 5);  // [  5] HBR_int_mask
+    data32 |= (1    << 2);  // [  2] AUDS_int_mask
+    data32 |= (1    << 1);  // [  1] ACR_int_mask
+    data32 |= (1    << 0);  // [  0] NULL_int_mask
+    hdmitx_wr_reg(HDMITX_DWC_FC_MASK0,      data32);
+
+    data32  = 0;
+    data32 |= (1    << 7);  // [  7] GMD_int_mask
+    data32 |= (1    << 6);  // [  6] ISRC1_int_mask
+    data32 |= (1    << 5);  // [  5] ISRC2_int_mask
+    data32 |= (1    << 4);  // [  4] VSD_int_mask
+    data32 |= (1    << 3);  // [  3] SPD_int_mask
+    data32 |= (1    << 1);  // [  1] AVI_int_mask
+    data32 |= (1    << 0);  // [  0] GCP_int_mask
+    hdmitx_wr_reg(HDMITX_DWC_FC_MASK1,      data32);
+
+    data32  = 0;
+    data32 |= (1    << 1);  // [  1] LowPriority_fifo_full
+    data32 |= (1    << 0);  // [  0] HighPriority_fifo_full
+    hdmitx_wr_reg(HDMITX_DWC_FC_MASK2,      data32);
+
+    // Pixel repetition ratio the input and output video
+    data32  = 0;
+    data32 |= ((para->pixel_repetition_factor+1) << 4);  // [7:4] incoming_pr_factor
+    data32 |= (para->pixel_repetition_factor     << 0);  // [3:0] output_pr_factor
+    hdmitx_wr_reg(HDMITX_DWC_FC_PRCONF, data32);
+
+    // Scrambler control
+    data32  = 0;
+    data32 |= (0            << 4);  // [  4] scrambler_ucp_line
+    data32 |= (para->scrambler_en << 0);  // [  0] scrambler_en. Only update this bit once we've sent SCDC message, in test.c
+    hdmitx_wr_reg(HDMITX_DWC_FC_SCRAMBLER_CTRL, data32);
+
+    //--------------------------------------------------------------------------
+    // Configure HDCP
+    //--------------------------------------------------------------------------
+
+    data32  = 0;
+    data32 |= (0    << 7);  // [  7] hdcp_engaged_int_mask
+    data32 |= (0    << 6);  // [  6] hdcp_failed_int_mask
+    data32 |= (0    << 4);  // [  4] i2c_nack_int_mask
+    data32 |= (0    << 3);  // [  3] lost_arbitration_int_mask
+    data32 |= (0    << 2);  // [  2] keepout_error_int_mask
+    data32 |= (0    << 1);  // [  1] ksv_sha1_calc_int_mask
+    data32 |= (1    << 0);  // [  0] ksv_access_int_mask
+    hdmitx_wr_reg(HDMITX_DWC_A_APIINTMSK,   data32);
+
+    data32  = 0;
+    data32 |= (0    << 5);  // [6:5] unencryptconf
+    data32 |= (1    << 4);  // [  4] dataenpol
+    data32 |= (1    << 3);  // [  3] vsyncpol
+    data32 |= (1    << 1);  // [  1] hsyncpol
+    hdmitx_wr_reg(HDMITX_DWC_A_VIDPOLCFG,   data32);
+
+    hdmitx_wr_reg(HDMITX_DWC_A_OESSWCFG,    0x40);
+
+    data32  = 0;
+    data32 |= (0                << 4);  // [  4] hdcp_lock
+    data32 |= (0                << 3);  // [  3] dissha1check
+    data32 |= (1                << 2);  // [  2] ph2upshiftenc
+    data32 |= (1                << 1);  // [  1] encryptiondisable
+    data32 |= (1                << 0);  // [  0] swresetn. Write 0 to activate, self-clear to 1.
+    hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG1,    data32);
+
+//    configure_hdcp_dpk(base_offset, 0xa938);
+
+    //initialize HDCP, with rxdetect low
+    data32  = 0;
+    data32 |= (0                << 7);  // [  7] ELV_ena
+    data32 |= (1                << 6);  // [  6] i2c_fastmode
+    data32 |= (1                << 5);  // [  5] byp_encryption
+    data32 |= (1                << 4);  // [  4] sync_ri_check
+    data32 |= (0                << 3);  // [  3] avmute
+    data32 |= (0                << 2);  // [  2] rxdetect
+    data32 |= (1                << 1);  // [  1] en11_feature
+    data32 |= (1                << 0);  // [  0] hdmi_dvi
+    hdmitx_wr_reg(HDMITX_DWC_A_HDCPCFG0,    data32);
+
+    //--------------------------------------------------------------------------
+    // Interrupts
+    //--------------------------------------------------------------------------
+
+    // Clear interrupts
+    hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT0,      0xff);
+    hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT1,      0xff);
+    hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT2,      0xff);
+    hdmitx_wr_reg(HDMITX_DWC_IH_AS_STAT0,      0xff);
+    hdmitx_wr_reg(HDMITX_DWC_IH_PHY_STAT0,     0xff);
+    hdmitx_wr_reg(HDMITX_DWC_IH_I2CM_STAT0,    0xff);
+    hdmitx_wr_reg(HDMITX_DWC_IH_CEC_STAT0,     0xff);
+    hdmitx_wr_reg(HDMITX_DWC_IH_VP_STAT0,      0xff);
+    hdmitx_wr_reg(HDMITX_DWC_IH_I2CMPHY_STAT0, 0xff);
+    hdmitx_wr_reg(HDMITX_DWC_A_APIINTCLR,      0xff);
+    // [2]      hpd_fall
+    // [1]      hpd_rise
+    // [0]      core_intr_rise
+    hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR,    0x00000007);
+
+    // Selectively enable/mute interrupt sources
+    
+    data32  = 0;
+    data32 |= (1    << 7);  // [  7] mute_AUDI
+    data32 |= (1    << 6);  // [  6] mute_ACP
+    data32 |= (1    << 4);  // [  4] mute_DST
+    data32 |= (1    << 3);  // [  3] mute_OBA
+    data32 |= (1    << 2);  // [  2] mute_AUDS
+    data32 |= (1    << 1);  // [  1] mute_ACR
+    data32 |= (1    << 0);  // [  0] mute_NULL
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT0,  data32);
+
+    data32  = 0;
+    data32 |= (1    << 7);  // [  7] mute_GMD
+    data32 |= (1    << 6);  // [  6] mute_ISRC1
+    data32 |= (1    << 5);  // [  5] mute_ISRC2
+    data32 |= (1    << 4);  // [  4] mute_VSD
+    data32 |= (1    << 3);  // [  3] mute_SPD
+    data32 |= (1    << 1);  // [  1] mute_AVI
+    data32 |= (1    << 0);  // [  0] mute_GCP
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT1,  data32);
+
+    data32  = 0;
+    data32 |= (1    << 1);  // [  1] mute_LowPriority_fifo_full
+    data32 |= (1    << 0);  // [  0] mute_HighPriority_fifo_full
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_FC_STAT2,  data32);
+
+    data32  = 0;
+    data32 |= (0    << 3);  // [  3] mute_aud_fifo_overrun
+    data32 |= (1    << 2);  // [  2] mute_aud_fifo_underflow_thr. aud_fifo_underflow tied to 0.
+    data32 |= (1    << 1);  // [  1] mute_aud_fifo_empty
+    data32 |= (1    << 0);  // [  0] mute_aud_fifo_full
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_AS_STAT0,  data32);
+
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_PHY_STAT0, 0x3f);
+
+    data32  = 0;
+    data32 |= (0    << 2);  // [  2] mute_scdc_readreq
+    data32 |= (1    << 1);  // [  1] mute_edid_i2c_master_done
+    data32 |= (0    << 0);  // [  0] mute_edid_i2c_master_error
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_I2CM_STAT0,data32);
+
+    data32  = 0;
+    data32 |= (0    << 6);  // [  6] cec_wakeup
+    data32 |= (0    << 5);  // [  5] cec_error_follower
+    data32 |= (0    << 4);  // [  4] cec_error_initiator
+    data32 |= (0    << 3);  // [  3] cec_arb_lost
+    data32 |= (0    << 2);  // [  2] cec_nack
+    data32 |= (0    << 1);  // [  1] cec_eom
+    data32 |= (0    << 0);  // [  0] cec_done
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_CEC_STAT0, data32);
+
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_VP_STAT0,      0xff);
+
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0, 0x03);
+
+    data32  = 0;
+    data32 |= (0    << 1);  // [  1] mute_wakeup_interrupt
+    data32 |= (0    << 0);  // [  0] mute_all_interrupt
+    hdmitx_wr_reg(HDMITX_DWC_IH_MUTE,   data32);
+
+    data32  = 0;
+    data32 |= (1    << 2);  // [  2] hpd_fall_intr
+    data32 |= (1    << 1);  // [  1] hpd_rise_intr
+    data32 |= (1    << 0);  // [  0] core_intr
+    hdmitx_wr_reg(HDMITX_TOP_INTR_MASKN,data32);
+
+    //--------------------------------------------------------------------------
+    // Reset pulse
+    //--------------------------------------------------------------------------
+
+    hdmitx_rd_check_reg(HDMITX_DWC_MC_LOCKONCLOCK, 0xff, 0x9f);
+    
+    data32  = 0;
+    data32 |= (0    << 7);  // [  7] gpaswrst_req: 0=generate reset pulse; 1=no reset.
+    data32 |= (0    << 6);  // [  6] cecswrst_req: 0=generate reset pulse; 1=no reset.
+    data32 |= (0    << 4);  // [  4] spdifswrst_req: 0=generate reset pulse; 1=no reset.
+    data32 |= (0    << 3);  // [  3] i2sswrst_req: 0=generate reset pulse; 1=no reset.
+    data32 |= (0    << 2);  // [  2] prepswrst_req: 0=generate reset pulse; 1=no reset.
+    data32 |= (0    << 1);  // [  1] tmdsswrst_req: 0=generate reset pulse; 1=no reset.
+    data32 |= (0    << 0);  // [  0] pixelswrst_req: 0=generate reset pulse; 1=no reset.
+    hdmitx_wr_reg(HDMITX_DWC_MC_SWRSTZREQ, data32);
+
+//TODO
+    printk("TODO %s[%d]\n", __func__, __LINE__);
+} /* config_hdmi20_tx */
+
+// TODO
+void hdmitx_csc_config (unsigned char input_color_format,
+                        unsigned char output_color_format,
+                        unsigned char color_depth)
+{
+    unsigned char   conv_en;
+    unsigned long   csc_coeff_a1, csc_coeff_a2, csc_coeff_a3, csc_coeff_a4;
+    unsigned long   csc_coeff_b1, csc_coeff_b2, csc_coeff_b3, csc_coeff_b4;
+    unsigned long   csc_coeff_c1, csc_coeff_c2, csc_coeff_c3, csc_coeff_c4;
+    unsigned char   csc_scale;
+    unsigned long   data32;
+
+    conv_en = (((input_color_format  == HDMI_COLOR_FORMAT_RGB) ||
+                (output_color_format == HDMI_COLOR_FORMAT_RGB)) &&
+               ( input_color_format  != output_color_format))? 1 : 0;
+    
+    if (conv_en) {
+        if (output_color_format == HDMI_COLOR_FORMAT_RGB) {
+            csc_coeff_a1    = 0x2000;
+            csc_coeff_a2    = 0x6926;
+            csc_coeff_a3    = 0x74fd;
+            csc_coeff_a4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x010e :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x043b :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x10ee :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x10ee : 0x010e;
+            csc_coeff_b1    = 0x2000;
+            csc_coeff_b2    = 0x2cdd;
+            csc_coeff_b3    = 0x0000;
+            csc_coeff_b4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x7e9a :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x7a65 :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x6992 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x6992 : 0x7e9a;
+            csc_coeff_c1    = 0x2000;
+            csc_coeff_c2    = 0x0000;
+            csc_coeff_c3    = 0x38b4;
+            csc_coeff_c4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x7e3b :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x78ea :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x63a6 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x63a6 : 0x7e3b;
+            csc_scale       = 1;
+        } else {    // input_color_format == HDMI_COLOR_FORMAT_RGB
+            csc_coeff_a1    = 0x2591;
+            csc_coeff_a2    = 0x1322;
+            csc_coeff_a3    = 0x074b;
+            csc_coeff_a4    = 0x0000;
+            csc_coeff_b1    = 0x6535;
+            csc_coeff_b2    = 0x2000;
+            csc_coeff_b3    = 0x7acc;
+            csc_coeff_b4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x0200 :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x0800 :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x2000 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x2000 : 0x0200;
+            csc_coeff_c1    = 0x6acd;
+            csc_coeff_c2    = 0x7534;
+            csc_coeff_c3    = 0x2000;
+            csc_coeff_c4    = (color_depth==HDMI_COLOR_DEPTH_24B)? 0x0200 :
+                              (color_depth==HDMI_COLOR_DEPTH_30B)? 0x0800 :
+                              (color_depth==HDMI_COLOR_DEPTH_36B)? 0x2000 :
+                              (color_depth==HDMI_COLOR_DEPTH_48B)? 0x2000 : 0x0200;
+            csc_scale       = 0;
+        }
+    } else {
+            csc_coeff_a1    = 0x2000;
+            csc_coeff_a2    = 0x0000;
+            csc_coeff_a3    = 0x0000;
+            csc_coeff_a4    = 0x0000;
+            csc_coeff_b1    = 0x0000;
+            csc_coeff_b2    = 0x2000;
+            csc_coeff_b3    = 0x0000;
+            csc_coeff_b4    = 0x0000;
+            csc_coeff_c1    = 0x0000;
+            csc_coeff_c2    = 0x0000;
+            csc_coeff_c3    = 0x2000;
+            csc_coeff_c4    = 0x0000;
+            csc_scale       = 1;
+    }
+
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A1_MSB,   (csc_coeff_a1>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A1_LSB,    csc_coeff_a1&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A2_MSB,   (csc_coeff_a2>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A2_LSB,    csc_coeff_a2&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A3_MSB,   (csc_coeff_a3>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A3_LSB,    csc_coeff_a3&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A4_MSB,   (csc_coeff_a4>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_A4_LSB,    csc_coeff_a4&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B1_MSB,   (csc_coeff_b1>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B1_LSB,    csc_coeff_b1&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B2_MSB,   (csc_coeff_b2>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B2_LSB,    csc_coeff_b2&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B3_MSB,   (csc_coeff_b3>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B3_LSB,    csc_coeff_b3&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B4_MSB,   (csc_coeff_b4>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_B4_LSB,    csc_coeff_b4&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C1_MSB,   (csc_coeff_c1>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C1_LSB,    csc_coeff_c1&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C2_MSB,   (csc_coeff_c2>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C2_LSB,    csc_coeff_c2&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C3_MSB,   (csc_coeff_c3>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C3_LSB,    csc_coeff_c3&0xff      );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C4_MSB,   (csc_coeff_c4>>8)&0xff  );
+    hdmitx_wr_reg(HDMITX_DWC_CSC_COEF_C4_LSB,    csc_coeff_c4&0xff      );
+
+    data32  = 0;
+    data32 |= (color_depth  << 4);  // [7:4] csc_color_depth
+    data32 |= (csc_scale    << 0);  // [1:0] cscscale
+    hdmitx_wr_reg(HDMITX_DWC_CSC_SCALE,         data32);
+}   /* hdmitx_csc_config */
+
+static void C_Entry(HDMI_Video_Codes_t vic)
+{
+    struct hdmi_format_para * para = get_fmt_paras(vic);
+    struct hdmi_cea_timing * t = NULL;
+
+    if(para == NULL) {
+        printk("error at %s[%d]\n", __func__, __LINE__);
+        return;
+    }
+    printk("%s[%d] set VIC = %d\n", __func__, __LINE__, para->vic);
+    t = &para->timing;
+
+    // --------------------------------------------------------
+    // Set TV encoder for HDMI
+    // --------------------------------------------------------
+    printk("Configure VENC\n");
+
+    switch (vic) {
+        case HDMI_1920x1080p60_16x9: // 1920x1080p@59.94/60Hz
+            //                      viu1_sel    viu2_sel    enable)
+            config_tv_enc(TVOUT_1080P);
+            break;
+        case HDMI_1920x1080p50_16x9:
+            //                      viu1_sel    viu2_sel    enable)
+            config_tv_enc(TVOUT_1080P_50HZ);
+            break;
+        case HDMI_3840x2160p30_16x9:
+        case HDMI_3840x2160p50_16x9:
+        case HDMI_3840x2160p60_16x9:
+            config_tv_enc(TVOUT_4K2K_30HZ);
+            break;
+        default :
+            printk("Error: Unkown HDMI Video Identification Code (VIC)!\n");
+            break;
+    }
+    aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 2, 0, 2); // [1:0] cntl_viu1_sel_venc: 0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT.
+
+    // --------------------------------------------------------
+    // Configure video format timing for HDMI:
+    // Based on the corresponding settings in set_tv_enc.c, calculate
+    // the register values to meet the timing requirements defined in CEA-861-D
+    // --------------------------------------------------------
+    printk("Configure HDMI video format timing\n");
+
+    aml_write_reg32(P_VPU_HDMI_FMT_CTRL,(((TX_INPUT_COLOR_FORMAT==HDMI_COLOR_FORMAT_420)?2:0)  << 0) | // [ 1: 0] hdmi_vid_fmt. 0=444; 1=convert to 422; 2=convert to 420.
+                         (2                                                     << 2) | // [ 3: 2] chroma_dnsmp. 0=use pixel 0; 1=use pixel 1; 2=use average.
+                         (((TX_COLOR_DEPTH==HDMI_COLOR_DEPTH_24B)? 1:0)         << 4) | // [    4] dith_en. 1=enable dithering before HDMI TX input.
+                         (0                                                     << 5) | // [    5] hdmi_dith_md: random noise selector.
+                         (0                                                     << 6)); // [ 9: 6] hdmi_dith10_cntl.
+
+    aml_write_reg32(P_VPU_HDMI_SETTING, (0                                 << 0) | // [    0] src_sel_enci
+                         (0                                 << 1) | // [    1] src_sel_encp
+                         (GET_TIMING(hsync_polarity)        << 2) | // [    2] inv_hsync. 1=Invert Hsync polarity.
+                         (GET_TIMING(vsync_polarity)        << 3) | // [    3] inv_vsync. 1=Invert Vsync polarity.
+                         (0                                 << 4) | // [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+                         (((TX_INPUT_COLOR_FORMAT==HDMI_COLOR_FORMAT_RGB)? 1 :  // RGB. Output RGB to HDMITX20 IP.
+                           (TX_INPUT_COLOR_FORMAT==HDMI_COLOR_FORMAT_420)? 0 :  // YUV420. vpu_hdmi_vfmt.v already mapped the components for 420 mode, do not change.
+                                                                           4)   // YUV444 or YUV422. Output CbYCr to HDMITX20 IP.
+                                                            << 5) | // [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+                                                                    //                          0=output CrYCb(BRG);
+                                                                    //                          1=output YCbCr(RGB);
+                                                                    //                          2=output YCrCb(RBG);
+                                                                    //                          3=output CbCrY(GBR);
+                                                                    //                          4=output CbYCr(GRB);
+                                                                    //                          5=output CrCbY(BGR);
+                                                                    //                          6,7=Rsrv.
+                         (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+                         (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+    );
+    aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
+
+    // --------------------------------------------------------
+    // Set up HDMI
+    // --------------------------------------------------------
+    config_hdmi20_tx(vic, para,                     // pixel_repeat,
+                     TX_COLOR_DEPTH,                        // Pixel bit width: 4=24-bit; 5=30-bit; 6=36-bit; 7=48-bit.
+                     TX_INPUT_COLOR_FORMAT,                 // input_color_format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                     TX_INPUT_COLOR_RANGE,                  // input_color_range: 0=limited; 1=full.
+                     TX_OUTPUT_COLOR_FORMAT,                // output_color_format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                     TX_OUTPUT_COLOR_RANGE                 // output_color_range: 0=limited; 1=full.
+                     );
+    return;
+}
diff --git a/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_reg.c b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_reg.c
new file mode 100644
index 000000000000..b271e7fe7d68
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_reg.c
@@ -0,0 +1,173 @@
+/*
+ * Amlogic Meson HDMI Transmitter Driver
+ * frame buffer driver-----------HDMI_TX
+ * Copyright (C) 2010 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+#include <mach/am_regs.h>
+#include "hdmi_tx_reg.h"
+
+//static DEFINE_SPINLOCK(reg_lock);
+static DEFINE_SPINLOCK(reg_lock2);
+
+void hdmitx_wr_reg(unsigned int addr, unsigned int data)
+{
+    unsigned long offset = (addr >> 24);
+    addr = addr & 0xffff;
+    aml_write_reg32(P_HDMITX_ADDR_PORT + offset, addr);
+    aml_write_reg32(P_HDMITX_ADDR_PORT + offset, addr);
+    aml_write_reg32(P_HDMITX_DATA_PORT + offset, data);
+    aml_write_reg32(P_HDMITX_DATA_PORT + offset, data);
+} /* hdmitx_wr_reg */
+
+void hdmitx_set_reg_bits(unsigned int addr, unsigned int value, unsigned int offset, unsigned int len)
+{
+    unsigned int data32 = 0;
+
+    data32 = hdmitx_rd_reg(addr);
+    data32 &= ~(((1 << len) - 1) << offset);
+    data32 |= (value & ((1 << len) - 1)) << offset;
+    hdmitx_wr_reg(addr, data32);
+}
+
+unsigned int hdmitx_rd_reg (unsigned int addr)
+{
+    unsigned int offset = (addr >> 24);
+    addr = addr & 0xffff;
+    aml_write_reg32(P_HDMITX_ADDR_PORT + offset, addr);
+    aml_write_reg32(P_HDMITX_ADDR_PORT + offset, addr);
+
+    return aml_read_reg32(P_HDMITX_DATA_PORT + offset);
+} /* hdmitx_rd_reg */
+
+void hdmitx_poll_reg(unsigned int addr, unsigned int val, unsigned long timeout)
+{
+    unsigned long time = 0;
+
+    time = jiffies;
+    while((!(hdmitx_rd_reg(addr) & val)) && time_before(jiffies, time + timeout)) {
+        msleep_interruptible(2);
+    }
+    if(time_after(jiffies, time + timeout))
+        printk("poll hdmitx reg:0x%x  val:0x%x T1=%lu t=%lu T2=%lu timeout\n", addr, val, time, timeout, jiffies);
+}
+void hdmitx_rd_check_reg (unsigned int addr, unsigned int exp_data, unsigned int mask)
+{
+    unsigned long rd_data;
+    rd_data = hdmitx_rd_reg(addr);
+    if ((rd_data | mask) != (exp_data | mask)) {
+        printk("HDMITX-DWC addr=0x%04x rd_data=0x%02x\n", (unsigned int)addr, (unsigned int)rd_data);
+        printk("Error: HDMITX-DWC exp_data=0x%02x mask=0x%02x\n", (unsigned int)exp_data, (unsigned int)mask);
+    }
+}
+#if 0
+unsigned int hdmitx_rd_reg(unsigned int addr)
+{
+    unsigned int data;
+
+    unsigned int flags, fiq_flag;
+
+    spin_lock_irqsave(&reg_lock, flags);
+    raw_local_save_flags(fiq_flag);
+    local_fiq_disable();
+
+    check_cts_hdmi_sys_clk_status();
+    aml_write_reg32(P_HDMITX_DATA_PORT, addr);
+    aml_write_reg32(P_HDMITX_DATA_PORT, addr);
+    data = aml_read_reg32(P_HDMITX_DATA_PORT);
+
+    raw_local_irq_restore(fiq_flag);
+    spin_unlock_irqrestore(&reg_lock, flags);
+    return (data);
+}
+
+void hdmitx_wr_reg(unsigned int addr, unsigned int data)
+{
+    unsigned int flags, fiq_flag;
+    spin_lock_irqsave(&reg_lock, flags);
+    raw_local_save_flags(fiq_flag);
+    local_fiq_disable();
+
+    check_cts_hdmi_sys_clk_status();
+    aml_write_reg32(P_HDMITX_DATA_PORT, addr);
+    aml_write_reg32(P_HDMITX_DATA_PORT, addr);
+    aml_write_reg32(P_HDMITX_DATA_PORT, data);
+    raw_local_irq_restore(fiq_flag);
+    spin_unlock_irqrestore(&reg_lock, flags);
+}
+#endif
+//#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#define waiting_aocec_free() \
+        do{\
+            unsigned long cnt = 0;\
+            while(aml_read_reg32(P_AO_CEC_RW_REG) & (1<<23))\
+            {\
+                if(3500 == cnt++)\
+                {\
+                    break;\
+                }\
+            }\
+        }while(0)
+        
+unsigned long aocec_rd_reg (unsigned long addr)
+{
+    unsigned long data32;
+    unsigned long flags;
+    
+    data32  = 0;
+    data32 |= 0     << 16;  // [16]     cec_reg_wr
+    data32 |= 0     << 8;   // [15:8]   cec_reg_wrdata
+    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
+    
+    waiting_aocec_free();
+    spin_lock_irqsave(&reg_lock2, flags);
+    aml_write_reg32(P_AO_CEC_RW_REG, data32);
+
+    waiting_aocec_free();
+    data32 = ((aml_read_reg32(P_AO_CEC_RW_REG)) >> 24) & 0xff;
+    spin_unlock_irqrestore(&reg_lock2, flags);
+    return (data32);
+} /* aocec_rd_reg */
+
+void aocec_wr_reg (unsigned long addr, unsigned long data)
+{
+    unsigned long data32;
+    unsigned long flags;
+    waiting_aocec_free();
+    spin_lock_irqsave(&reg_lock2, flags);
+    data32  = 0;
+    data32 |= 1     << 16;  // [16]     cec_reg_wr
+    data32 |= data  << 8;   // [15:8]   cec_reg_wrdata
+    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
+    aml_write_reg32(P_AO_CEC_RW_REG, data32);
+    spin_unlock_irqrestore(&reg_lock2, flags);
+    waiting_aocec_free();
+} /* aocec_wr_only_reg */
+
+//#endif
diff --git a/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_reg.h b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_reg.h
new file mode 100644
index 000000000000..2dcad3e1b04b
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmi_tx_reg.h
@@ -0,0 +1,786 @@
+#ifndef  __HDMI_TX_REG_H_
+#define  __HDMI_TX_REG_H_
+
+// Use the following functions to access the on-chip HDMITX modules by default
+extern void hdmitx_wr_reg(unsigned int addr, unsigned int data);
+extern void hdmitx_poll_reg(unsigned int addr, unsigned int val, unsigned long timeout);
+extern void hdmitx_set_reg_bits(unsigned int addr, unsigned int value, unsigned int offset, unsigned int len);
+extern unsigned int hdmitx_rd_reg(unsigned int addr);
+extern void hdmitx_rd_check_reg(unsigned int addr, unsigned int exp_data, unsigned int mask);
+extern unsigned long aocec_rd_reg (unsigned long addr);
+extern void aocec_wr_reg (unsigned long addr, unsigned long data);
+
+//------------------------------------------------------------------------------
+// TOP-level wrapper registers addresses
+//------------------------------------------------------------------------------
+#define TOP_OFFSET_MASK      (0x00 << 24)
+#define DWC_OFFSET_MASK      (0x10 << 24)
+
+// Bit     7 RW Reserved.                                                                                        Default 1.
+// Bit     6 RW Reserved.                                                                                        Default 1.
+// Bit     5 RW Reserved.                                                                                        Default 1.
+// Bit     4 RW sw_reset_phyif: PHY interface.                              1=Apply reset; 0=Release from reset. Default 1.
+// Bit     3 RW sw_reset_intr:  interrupt module.                           1=Apply reset; 0=Release from reset. Default 1.
+// Bit     2 RW sw_reset_mem:   KSV/REVOC mem.                              1=Apply reset; 0=Release from reset. Default 1.
+// Bit     1 RW sw_reset_rnd:   random number interface to HDCP.            1=Apply reset; 0=Release from reset. Default 1.
+// Bit     0 RW sw_reset_core:  connects to IP's ~irstz.                    1=Apply reset; 0=Release from reset. Default 1.
+#define HDMITX_TOP_SW_RESET                     (TOP_OFFSET_MASK + 0x000)
+
+// Bit    12 RW i2s_ws_inv:     1=Invert i2s_ws;    0=No invert.    Default 0.
+// Bit    11 RW i2s_clk_inv:    1=Invert i2s_clk;   0=No invert.    Default 0.
+// Bit    10 RW spdif_clk_inv:  1=Invert spdif_clk; 0=No invert.    Default 0.
+// Bit     9 RW tmds_clk_inv:   1=Invert tmds_clk;  0=No invert.    Default 0.
+// Bit     8 RW pixel_clk_inv:  1=Invert pixel_clk; 0=No invert.    Default 0.
+// Bit     4 RW cec_clk_en:     1=enable cec_clk;   0=disable.      Default 0.
+// Bit     3 RW i2s_clk_en:     1=enable i2s_clk;   0=disable.      Default 0.
+// Bit     2 RW spdif_clk_en:   1=enable spdif_clk; 0=disable.      Default 0.
+// Bit     1 RW tmds_clk_en:    1=enable tmds_clk;  0=disable.      Default 0.
+// Bit     0 RW pixel_clk_en:   1=enable pixel_clk; 0=disable.      Default 0.
+#define HDMITX_TOP_CLK_CNTL                     (TOP_OFFSET_MASK + 0x001)
+
+// Bit 11: 0 RW hpd_valid_width: filter out width <= M*1024.    Default 0.
+// Bit 15:12 RW hpd_glitch_width: filter out glitch <= N.       Default 0.
+#define HDMITX_TOP_HPD_FILTER                   (TOP_OFFSET_MASK + 0x002)
+
+// intr_maskn: MASK_N, one bit per interrupt source. 1=Enable interrupt source; 0=Disable interrupt source. Default 0.
+// Bit     2 RW hpd_fall
+// Bit     1 RW hpd_rise
+// Bit     0 RW IP interrupt
+#define HDMITX_TOP_INTR_MASKN                   (TOP_OFFSET_MASK + 0x003)
+
+// Bit 30: 0 RW intr_stat: For each bit, write 1 to manually set the interrupt bit, read back the interrupt status.
+// Bit    31 R  IP interrupt status
+// Bit     2 RW hpd_fall
+// Bit     1 RW hpd_rise
+// Bit     0 RW IP interrupt
+#define HDMITX_TOP_INTR_STAT                    (TOP_OFFSET_MASK + 0x004)
+
+// Bit  2: 0  W intr_stat_clr: For each bit, write 1 to clear the interrupt bit.
+// Bit     2 RW hpd_fall
+// Bit     1 RW hpd_rise
+// Bit     0 RW IP interrupt
+#define HDMITX_TOP_INTR_STAT_CLR                (TOP_OFFSET_MASK + 0x005)
+
+// Bit 14:12 RW tmds_sel: 3'b000=Output zero; 3'b001=Output normal TMDS data; 3'b010=Output PRBS data; 3'b100=Output shift pattern.         Default 0.
+// Bit 11: 9 RW shift_pttn_repeat: 0=New pattern every clk cycle; 1=New pattern every 2 clk cycles; ...; 7=New pattern every 8 clk cycles.  Default 0.
+// Bit     8 RW shift_pttn_en: 1= Eanble shift pattern generator; 0=Disable.                                                                Default 0.
+// Bit  4: 3 RW prbs_pttn_mode: 0=PRBS11; 1=PRBS15; 2=PRBS7; 3=PRBS31.                                                                      Default 0.
+// Bit  2: 1 RW prbs_pttn_width: 0=idle; 1=output 8-bit pattern; 2=Output 1-bit pattern; 3=output 10-bit pattern.                           Default 0.
+// Bit     0 RW prbs_pttn_en: 1=Enable PRBS generator; 0=Disable.                                                                           Default 0.
+#define HDMITX_TOP_BIST_CNTL                    (TOP_OFFSET_MASK + 0x006)
+
+// Bit 29:20 RW shift_pttn_data[59:50]. Default 0.
+// Bit 19:10 RW shift_pttn_data[69:60]. Default 0.
+// Bit  9: 0 RW shift_pttn_data[79:70]. Default 0.
+#define HDMITX_TOP_SHIFT_PTTN_012               (TOP_OFFSET_MASK + 0x007)
+
+// Bit 29:20 RW shift_pttn_data[29:20]. Default 0.
+// Bit 19:10 RW shift_pttn_data[39:30]. Default 0.
+// Bit  9: 0 RW shift_pttn_data[49:40]. Default 0.
+#define HDMITX_TOP_SHIFT_PTTN_345               (TOP_OFFSET_MASK + 0x008)
+
+// Bit 19:10 RW shift_pttn_data[ 9: 0]. Default 0.
+// Bit  9: 0 RW shift_pttn_data[19:10]. Default 0.
+#define HDMITX_TOP_SHIFT_PTTN_67                (TOP_OFFSET_MASK + 0x009)
+
+// Bit 25:16 RW tmds_clk_pttn[19:10]. Default 0.
+// Bit  9: 0 RW tmds_clk_pttn[ 9: 0]. Default 0.
+#define HDMITX_TOP_TMDS_CLK_PTTN_01             (TOP_OFFSET_MASK + 0x00A)
+
+// Bit 25:16 RW tmds_clk_pttn[39:30]. Default 0.
+// Bit  9: 0 RW tmds_clk_pttn[29:20]. Default 0.
+#define HDMITX_TOP_TMDS_CLK_PTTN_23             (TOP_OFFSET_MASK + 0x00B)
+
+// Bit     1 RW shift_tmds_clk_pttn:1=Enable shifting clk pattern, used when TMDS CLK rate = TMDS character rate /4.    Default 0.
+// Bit     0 R  Reserved.                                                                                               Default 0.
+#define HDMITX_TOP_TMDS_CLK_PTTN_CNTL           (TOP_OFFSET_MASK + 0x00C)
+
+// Bit     0 RW revocmem_wr_fail: Read back 1 to indicate Host write REVOC MEM failure, write 1 to clear the failure flag.  Default 0.
+#define HDMITX_TOP_REVOCMEM_STAT                (TOP_OFFSET_MASK + 0x00D)
+
+// Bit     0 R  filtered HPD status.
+#define HDMITX_TOP_STAT0                        (TOP_OFFSET_MASK + 0x00E)
+
+#define HDMITX_TOP_DONT_TOUCH0                  (TOP_OFFSET_MASK + 0x0FE)
+#define HDMITX_TOP_DONT_TOUCH1                  (TOP_OFFSET_MASK + 0x0FF)
+
+//------------------------------------------------------------------------------
+// DWC_HDMI_TX Controller registers addresses
+//------------------------------------------------------------------------------
+
+// Identification Registers
+#define HDMITX_DWC_DESIGN_ID                    (DWC_OFFSET_MASK + 0x0000)
+#define HDMITX_DWC_REVISION_ID                  (DWC_OFFSET_MASK + 0x0001)
+#define HDMITX_DWC_PRODUCT_ID0                  (DWC_OFFSET_MASK + 0x0002)
+#define HDMITX_DWC_PRODUCT_ID1                  (DWC_OFFSET_MASK + 0x0003)
+#define HDMITX_DWC_CONFIG0_ID                   (DWC_OFFSET_MASK + 0x0004)
+#define HDMITX_DWC_CONFIG1_ID                   (DWC_OFFSET_MASK + 0x0005)
+#define HDMITX_DWC_CONFIG2_ID                   (DWC_OFFSET_MASK + 0x0006)
+#define HDMITX_DWC_CONFIG3_ID                   (DWC_OFFSET_MASK + 0x0007)
+
+// Interrupt Registers
+#define HDMITX_DWC_IH_FC_STAT0                  (DWC_OFFSET_MASK + 0x0100)
+#define HDMITX_DWC_IH_FC_STAT1                  (DWC_OFFSET_MASK + 0x0101)
+#define HDMITX_DWC_IH_FC_STAT2                  (DWC_OFFSET_MASK + 0x0102)
+#define HDMITX_DWC_IH_AS_STAT0                  (DWC_OFFSET_MASK + 0x0103)
+#define HDMITX_DWC_IH_PHY_STAT0                 (DWC_OFFSET_MASK + 0x0104)
+#define HDMITX_DWC_IH_I2CM_STAT0                (DWC_OFFSET_MASK + 0x0105)
+#define HDMITX_DWC_IH_CEC_STAT0                 (DWC_OFFSET_MASK + 0x0106)
+#define HDMITX_DWC_IH_VP_STAT0                  (DWC_OFFSET_MASK + 0x0107)
+#define HDMITX_DWC_IH_I2CMPHY_STAT0             (DWC_OFFSET_MASK + 0x0108)
+#define HDMITX_DWC_IH_DECODE                    (DWC_OFFSET_MASK + 0x0170)
+#define HDMITX_DWC_IH_MUTE_FC_STAT0             (DWC_OFFSET_MASK + 0x0180)
+#define HDMITX_DWC_IH_MUTE_FC_STAT1             (DWC_OFFSET_MASK + 0x0181)
+#define HDMITX_DWC_IH_MUTE_FC_STAT2             (DWC_OFFSET_MASK + 0x0182)
+#define HDMITX_DWC_IH_MUTE_AS_STAT0             (DWC_OFFSET_MASK + 0x0183)
+#define HDMITX_DWC_IH_MUTE_PHY_STAT0            (DWC_OFFSET_MASK + 0x0184)
+#define HDMITX_DWC_IH_MUTE_I2CM_STAT0           (DWC_OFFSET_MASK + 0x0185)
+#define HDMITX_DWC_IH_MUTE_CEC_STAT0            (DWC_OFFSET_MASK + 0x0186)
+#define HDMITX_DWC_IH_MUTE_VP_STAT0             (DWC_OFFSET_MASK + 0x0187)
+#define HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0        (DWC_OFFSET_MASK + 0x0188)
+#define HDMITX_DWC_IH_MUTE                      (DWC_OFFSET_MASK + 0x01FF)
+
+// Video Sampler Registers
+#define HDMITX_DWC_TX_INVID0                    (DWC_OFFSET_MASK + 0x0200)
+#define HDMITX_DWC_TX_INSTUFFING                (DWC_OFFSET_MASK + 0x0201)
+#define HDMITX_DWC_TX_GYDATA0                   (DWC_OFFSET_MASK + 0x0202)
+#define HDMITX_DWC_TX_GYDATA1                   (DWC_OFFSET_MASK + 0x0203)
+#define HDMITX_DWC_TX_RCRDATA0                  (DWC_OFFSET_MASK + 0x0204)
+#define HDMITX_DWC_TX_RCRDATA1                  (DWC_OFFSET_MASK + 0x0205)
+#define HDMITX_DWC_TX_BCBDATA0                  (DWC_OFFSET_MASK + 0x0206)
+#define HDMITX_DWC_TX_BCBDATA1                  (DWC_OFFSET_MASK + 0x0207)
+
+// Video Packetizer Registers
+#define HDMITX_DWC_VP_STATUS                    (DWC_OFFSET_MASK + 0x0800)
+#define HDMITX_DWC_VP_PR_CD                     (DWC_OFFSET_MASK + 0x0801)
+#define HDMITX_DWC_VP_STUFF                     (DWC_OFFSET_MASK + 0x0802)
+#define HDMITX_DWC_VP_REMAP                     (DWC_OFFSET_MASK + 0x0803)
+#define HDMITX_DWC_VP_CONF                      (DWC_OFFSET_MASK + 0x0804)
+#define HDMITX_DWC_VP_MASK                      (DWC_OFFSET_MASK + 0x0807)
+
+// Frmae Composer Registers
+#define HDMITX_DWC_FC_INVIDCONF                 (DWC_OFFSET_MASK + 0x1000)
+#define HDMITX_DWC_FC_INHACTV0                  (DWC_OFFSET_MASK + 0x1001)
+#define HDMITX_DWC_FC_INHACTV1                  (DWC_OFFSET_MASK + 0x1002)
+#define HDMITX_DWC_FC_INHBLANK0                 (DWC_OFFSET_MASK + 0x1003)
+#define HDMITX_DWC_FC_INHBLANK1                 (DWC_OFFSET_MASK + 0x1004)
+#define HDMITX_DWC_FC_INVACTV0                  (DWC_OFFSET_MASK + 0x1005)
+#define HDMITX_DWC_FC_INVACTV1                  (DWC_OFFSET_MASK + 0x1006)
+#define HDMITX_DWC_FC_INVBLANK                  (DWC_OFFSET_MASK + 0x1007)
+#define HDMITX_DWC_FC_HSYNCINDELAY0             (DWC_OFFSET_MASK + 0x1008)
+#define HDMITX_DWC_FC_HSYNCINDELAY1             (DWC_OFFSET_MASK + 0x1009)
+#define HDMITX_DWC_FC_HSYNCINWIDTH0             (DWC_OFFSET_MASK + 0x100A)
+#define HDMITX_DWC_FC_HSYNCINWIDTH1             (DWC_OFFSET_MASK + 0x100B)
+#define HDMITX_DWC_FC_VSYNCINDELAY              (DWC_OFFSET_MASK + 0x100C)
+#define HDMITX_DWC_FC_VSYNCINWIDTH              (DWC_OFFSET_MASK + 0x100D)
+#define HDMITX_DWC_FC_INFREQ0                   (DWC_OFFSET_MASK + 0x100E)
+#define HDMITX_DWC_FC_INFREQ1                   (DWC_OFFSET_MASK + 0x100F)
+#define HDMITX_DWC_FC_INFREQ2                   (DWC_OFFSET_MASK + 0x1010)
+#define HDMITX_DWC_FC_CTRLDUR                   (DWC_OFFSET_MASK + 0x1011)
+#define HDMITX_DWC_FC_EXCTRLDUR                 (DWC_OFFSET_MASK + 0x1012)
+#define HDMITX_DWC_FC_EXCTRLSPAC                (DWC_OFFSET_MASK + 0x1013)
+#define HDMITX_DWC_FC_CH0PREAM                  (DWC_OFFSET_MASK + 0x1014)
+#define HDMITX_DWC_FC_CH1PREAM                  (DWC_OFFSET_MASK + 0x1015)
+#define HDMITX_DWC_FC_CH2PREAM                  (DWC_OFFSET_MASK + 0x1016)
+#define HDMITX_DWC_FC_AVICONF3                  (DWC_OFFSET_MASK + 0x1017)
+#define HDMITX_DWC_FC_GCP                       (DWC_OFFSET_MASK + 0x1018)
+#define HDMITX_DWC_FC_AVICONF0                  (DWC_OFFSET_MASK + 0x1019)
+#define HDMITX_DWC_FC_AVICONF1                  (DWC_OFFSET_MASK + 0x101A)
+#define HDMITX_DWC_FC_AVICONF2                  (DWC_OFFSET_MASK + 0x101B)
+#define HDMITX_DWC_FC_AVIVID                    (DWC_OFFSET_MASK + 0x101C)
+#define HDMITX_DWC_FC_AVIETB0                   (DWC_OFFSET_MASK + 0x101D)
+#define HDMITX_DWC_FC_AVIETB1                   (DWC_OFFSET_MASK + 0x101E)
+#define HDMITX_DWC_FC_AVISBB0                   (DWC_OFFSET_MASK + 0x101F)
+#define HDMITX_DWC_FC_AVISBB1                   (DWC_OFFSET_MASK + 0x1020)
+#define HDMITX_DWC_FC_AVIELB0                   (DWC_OFFSET_MASK + 0x1021)
+#define HDMITX_DWC_FC_AVIELB1                   (DWC_OFFSET_MASK + 0x1022)
+#define HDMITX_DWC_FC_AVISRB0                   (DWC_OFFSET_MASK + 0x1023)
+#define HDMITX_DWC_FC_AVISRB1                   (DWC_OFFSET_MASK + 0x1024)
+#define HDMITX_DWC_FC_AUDICONF0                 (DWC_OFFSET_MASK + 0x1025)
+#define HDMITX_DWC_FC_AUDICONF1                 (DWC_OFFSET_MASK + 0x1026)
+#define HDMITX_DWC_FC_AUDICONF2                 (DWC_OFFSET_MASK + 0x1027)
+#define HDMITX_DWC_FC_AUDICONF3                 (DWC_OFFSET_MASK + 0x1028)
+#define HDMITX_DWC_FC_VSDIEEEID0                (DWC_OFFSET_MASK + 0x1029)
+#define HDMITX_DWC_FC_VSDSIZE                   (DWC_OFFSET_MASK + 0x102A)
+#define HDMITX_DWC_FC_VSDIEEEID1                (DWC_OFFSET_MASK + 0x1030)
+#define HDMITX_DWC_FC_VSDIEEEID2                (DWC_OFFSET_MASK + 0x1031)
+#define HDMITX_DWC_FC_VSDPAYLOAD0               (DWC_OFFSET_MASK + 0x1032)
+#define HDMITX_DWC_FC_VSDPAYLOAD1               (DWC_OFFSET_MASK + 0x1033)
+#define HDMITX_DWC_FC_VSDPAYLOAD2               (DWC_OFFSET_MASK + 0x1034)
+#define HDMITX_DWC_FC_VSDPAYLOAD3               (DWC_OFFSET_MASK + 0x1035)
+#define HDMITX_DWC_FC_VSDPAYLOAD4               (DWC_OFFSET_MASK + 0x1036)
+#define HDMITX_DWC_FC_VSDPAYLOAD5               (DWC_OFFSET_MASK + 0x1037)
+#define HDMITX_DWC_FC_VSDPAYLOAD6               (DWC_OFFSET_MASK + 0x1038)
+#define HDMITX_DWC_FC_VSDPAYLOAD7               (DWC_OFFSET_MASK + 0x1039)
+#define HDMITX_DWC_FC_VSDPAYLOAD8               (DWC_OFFSET_MASK + 0x103A)
+#define HDMITX_DWC_FC_VSDPAYLOAD9               (DWC_OFFSET_MASK + 0x103B)
+#define HDMITX_DWC_FC_VSDPAYLOAD10              (DWC_OFFSET_MASK + 0x103C)
+#define HDMITX_DWC_FC_VSDPAYLOAD11              (DWC_OFFSET_MASK + 0x103D)
+#define HDMITX_DWC_FC_VSDPAYLOAD12              (DWC_OFFSET_MASK + 0x103E)
+#define HDMITX_DWC_FC_VSDPAYLOAD13              (DWC_OFFSET_MASK + 0x103F)
+#define HDMITX_DWC_FC_VSDPAYLOAD14              (DWC_OFFSET_MASK + 0x1040)
+#define HDMITX_DWC_FC_VSDPAYLOAD15              (DWC_OFFSET_MASK + 0x1041)
+#define HDMITX_DWC_FC_VSDPAYLOAD16              (DWC_OFFSET_MASK + 0x1042)
+#define HDMITX_DWC_FC_VSDPAYLOAD17              (DWC_OFFSET_MASK + 0x1043)
+#define HDMITX_DWC_FC_VSDPAYLOAD18              (DWC_OFFSET_MASK + 0x1044)
+#define HDMITX_DWC_FC_VSDPAYLOAD19              (DWC_OFFSET_MASK + 0x1045)
+#define HDMITX_DWC_FC_VSDPAYLOAD20              (DWC_OFFSET_MASK + 0x1046)
+#define HDMITX_DWC_FC_VSDPAYLOAD21              (DWC_OFFSET_MASK + 0x1047)
+#define HDMITX_DWC_FC_VSDPAYLOAD22              (DWC_OFFSET_MASK + 0x1048)
+#define HDMITX_DWC_FC_VSDPAYLOAD23              (DWC_OFFSET_MASK + 0x1049)
+#define HDMITX_DWC_FC_SPDVENDORNAME0            (DWC_OFFSET_MASK + 0x104A)
+#define HDMITX_DWC_FC_SPDVENDORNAME1            (DWC_OFFSET_MASK + 0x104B)
+#define HDMITX_DWC_FC_SPDVENDORNAME2            (DWC_OFFSET_MASK + 0x104C)
+#define HDMITX_DWC_FC_SPDVENDORNAME3            (DWC_OFFSET_MASK + 0x104D)
+#define HDMITX_DWC_FC_SPDVENDORNAME4            (DWC_OFFSET_MASK + 0x104E)
+#define HDMITX_DWC_FC_SPDVENDORNAME5            (DWC_OFFSET_MASK + 0x104F)
+#define HDMITX_DWC_FC_SPDVENDORNAME6            (DWC_OFFSET_MASK + 0x1050)
+#define HDMITX_DWC_FC_SPDVENDORNAME7            (DWC_OFFSET_MASK + 0x1051)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME0           (DWC_OFFSET_MASK + 0x1052)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME1           (DWC_OFFSET_MASK + 0x1053)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME2           (DWC_OFFSET_MASK + 0x1054)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME3           (DWC_OFFSET_MASK + 0x1055)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME4           (DWC_OFFSET_MASK + 0x1056)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME5           (DWC_OFFSET_MASK + 0x1057)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME6           (DWC_OFFSET_MASK + 0x1058)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME7           (DWC_OFFSET_MASK + 0x1059)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME8           (DWC_OFFSET_MASK + 0x105A)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME9           (DWC_OFFSET_MASK + 0x105B)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME10          (DWC_OFFSET_MASK + 0x105C)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME11          (DWC_OFFSET_MASK + 0x105D)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME12          (DWC_OFFSET_MASK + 0x105E)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME13          (DWC_OFFSET_MASK + 0x105F)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME14          (DWC_OFFSET_MASK + 0x1060)
+#define HDMITX_DWC_FC_SPDPRODUCTNAME15          (DWC_OFFSET_MASK + 0x1061)
+#define HDMITX_DWC_FC_SPDDEVICEINF              (DWC_OFFSET_MASK + 0x1062)
+#define HDMITX_DWC_FC_AUDSCONF                  (DWC_OFFSET_MASK + 0x1063)
+#define HDMITX_DWC_FC_AUDSSTAT                  (DWC_OFFSET_MASK + 0x1064)
+#define HDMITX_DWC_FC_AUDSV                     (DWC_OFFSET_MASK + 0x1065)
+#define HDMITX_DWC_FC_AUDSU                     (DWC_OFFSET_MASK + 0x1066)
+#define HDMITX_DWC_FC_AUDSCHNLS0                (DWC_OFFSET_MASK + 0x1067)
+#define HDMITX_DWC_FC_AUDSCHNLS1                (DWC_OFFSET_MASK + 0x1068)
+#define HDMITX_DWC_FC_AUDSCHNLS2                (DWC_OFFSET_MASK + 0x1069)
+#define HDMITX_DWC_FC_AUDSCHNLS3                (DWC_OFFSET_MASK + 0x106A)
+#define HDMITX_DWC_FC_AUDSCHNLS4                (DWC_OFFSET_MASK + 0x106B)
+#define HDMITX_DWC_FC_AUDSCHNLS5                (DWC_OFFSET_MASK + 0x106C)
+#define HDMITX_DWC_FC_AUDSCHNLS6                (DWC_OFFSET_MASK + 0x106D)
+#define HDMITX_DWC_FC_AUDSCHNLS7                (DWC_OFFSET_MASK + 0x106E)
+#define HDMITX_DWC_FC_AUDSCHNLS8                (DWC_OFFSET_MASK + 0x106F)
+#define HDMITX_DWC_FC_DATACH0FILL               (DWC_OFFSET_MASK + 0x1070)
+#define HDMITX_DWC_FC_DATACH1FILL               (DWC_OFFSET_MASK + 0x1071)
+#define HDMITX_DWC_FC_DATACH2FILL               (DWC_OFFSET_MASK + 0x1072)
+#define HDMITX_DWC_FC_CTRLQHIGH                 (DWC_OFFSET_MASK + 0x1073)
+#define HDMITX_DWC_FC_CTRLQLOW                  (DWC_OFFSET_MASK + 0x1074)
+#define HDMITX_DWC_FC_ACP0                      (DWC_OFFSET_MASK + 0x1075)
+#define HDMITX_DWC_FC_ACP16                     (DWC_OFFSET_MASK + 0x1082)
+#define HDMITX_DWC_FC_ACP15                     (DWC_OFFSET_MASK + 0x1083)
+#define HDMITX_DWC_FC_ACP14                     (DWC_OFFSET_MASK + 0x1084)
+#define HDMITX_DWC_FC_ACP13                     (DWC_OFFSET_MASK + 0x1085)
+#define HDMITX_DWC_FC_ACP12                     (DWC_OFFSET_MASK + 0x1086)
+#define HDMITX_DWC_FC_ACP11                     (DWC_OFFSET_MASK + 0x1087)
+#define HDMITX_DWC_FC_ACP10                     (DWC_OFFSET_MASK + 0x1088)
+#define HDMITX_DWC_FC_ACP9                      (DWC_OFFSET_MASK + 0x1089)
+#define HDMITX_DWC_FC_ACP8                      (DWC_OFFSET_MASK + 0x108A)
+#define HDMITX_DWC_FC_ACP7                      (DWC_OFFSET_MASK + 0x108B)
+#define HDMITX_DWC_FC_ACP6                      (DWC_OFFSET_MASK + 0x108C)
+#define HDMITX_DWC_FC_ACP5                      (DWC_OFFSET_MASK + 0x108D)
+#define HDMITX_DWC_FC_ACP4                      (DWC_OFFSET_MASK + 0x108E)
+#define HDMITX_DWC_FC_ACP3                      (DWC_OFFSET_MASK + 0x108F)
+#define HDMITX_DWC_FC_ACP2                      (DWC_OFFSET_MASK + 0x1090)
+#define HDMITX_DWC_FC_ACP1                      (DWC_OFFSET_MASK + 0x1091)
+#define HDMITX_DWC_FC_ISCR1_0                   (DWC_OFFSET_MASK + 0x1092)
+#define HDMITX_DWC_FC_ISCR1_16                  (DWC_OFFSET_MASK + 0x1093)
+#define HDMITX_DWC_FC_ISCR1_15                  (DWC_OFFSET_MASK + 0x1094)
+#define HDMITX_DWC_FC_ISCR1_14                  (DWC_OFFSET_MASK + 0x1095)
+#define HDMITX_DWC_FC_ISCR1_13                  (DWC_OFFSET_MASK + 0x1096)
+#define HDMITX_DWC_FC_ISCR1_12                  (DWC_OFFSET_MASK + 0x1097)
+#define HDMITX_DWC_FC_ISCR1_11                  (DWC_OFFSET_MASK + 0x1098)
+#define HDMITX_DWC_FC_ISCR1_10                  (DWC_OFFSET_MASK + 0x1099)
+#define HDMITX_DWC_FC_ISCR1_9                   (DWC_OFFSET_MASK + 0x109A)
+#define HDMITX_DWC_FC_ISCR1_8                   (DWC_OFFSET_MASK + 0x109B)
+#define HDMITX_DWC_FC_ISCR1_7                   (DWC_OFFSET_MASK + 0x109C)
+#define HDMITX_DWC_FC_ISCR1_6                   (DWC_OFFSET_MASK + 0x109D)
+#define HDMITX_DWC_FC_ISCR1_5                   (DWC_OFFSET_MASK + 0x109E)
+#define HDMITX_DWC_FC_ISCR1_4                   (DWC_OFFSET_MASK + 0x109F)
+#define HDMITX_DWC_FC_ISCR1_3                   (DWC_OFFSET_MASK + 0x10A0)
+#define HDMITX_DWC_FC_ISCR1_2                   (DWC_OFFSET_MASK + 0x10A1)
+#define HDMITX_DWC_FC_ISCR1_1                   (DWC_OFFSET_MASK + 0x10A2)
+#define HDMITX_DWC_FC_ISCR0_15                  (DWC_OFFSET_MASK + 0x10A3)
+#define HDMITX_DWC_FC_ISCR0_14                  (DWC_OFFSET_MASK + 0x10A4)
+#define HDMITX_DWC_FC_ISCR0_13                  (DWC_OFFSET_MASK + 0x10A5)
+#define HDMITX_DWC_FC_ISCR0_12                  (DWC_OFFSET_MASK + 0x10A6)
+#define HDMITX_DWC_FC_ISCR0_11                  (DWC_OFFSET_MASK + 0x10A7)
+#define HDMITX_DWC_FC_ISCR0_10                  (DWC_OFFSET_MASK + 0x10A8)
+#define HDMITX_DWC_FC_ISCR0_9                   (DWC_OFFSET_MASK + 0x10A9)
+#define HDMITX_DWC_FC_ISCR0_8                   (DWC_OFFSET_MASK + 0x10AA)
+#define HDMITX_DWC_FC_ISCR0_7                   (DWC_OFFSET_MASK + 0x10AB)
+#define HDMITX_DWC_FC_ISCR0_6                   (DWC_OFFSET_MASK + 0x10AC)
+#define HDMITX_DWC_FC_ISCR0_5                   (DWC_OFFSET_MASK + 0x10AD)
+#define HDMITX_DWC_FC_ISCR0_4                   (DWC_OFFSET_MASK + 0x10AE)
+#define HDMITX_DWC_FC_ISCR0_3                   (DWC_OFFSET_MASK + 0x10AF)
+#define HDMITX_DWC_FC_ISCR0_2                   (DWC_OFFSET_MASK + 0x10B0)
+#define HDMITX_DWC_FC_ISCR0_1                   (DWC_OFFSET_MASK + 0x10B1)
+#define HDMITX_DWC_FC_ISCR0_0                   (DWC_OFFSET_MASK + 0x10B2)
+#define HDMITX_DWC_FC_DATAUTO0                  (DWC_OFFSET_MASK + 0x10B3)
+#define HDMITX_DWC_FC_DATAUTO1                  (DWC_OFFSET_MASK + 0x10B4)
+#define HDMITX_DWC_FC_DATAUTO2                  (DWC_OFFSET_MASK + 0x10B5)
+#define HDMITX_DWC_FC_DATMAN                    (DWC_OFFSET_MASK + 0x10B6)
+#define HDMITX_DWC_FC_DATAUTO3                  (DWC_OFFSET_MASK + 0x10B7)
+#define HDMITX_DWC_FC_RDRB0                     (DWC_OFFSET_MASK + 0x10B8)
+#define HDMITX_DWC_FC_RDRB1                     (DWC_OFFSET_MASK + 0x10B9)
+#define HDMITX_DWC_FC_RDRB2                     (DWC_OFFSET_MASK + 0x10BA)
+#define HDMITX_DWC_FC_RDRB3                     (DWC_OFFSET_MASK + 0x10BB)
+#define HDMITX_DWC_FC_RDRB4                     (DWC_OFFSET_MASK + 0x10BC)
+#define HDMITX_DWC_FC_RDRB5                     (DWC_OFFSET_MASK + 0x10BD)
+#define HDMITX_DWC_FC_RDRB6                     (DWC_OFFSET_MASK + 0x10BE)
+#define HDMITX_DWC_FC_RDRB7                     (DWC_OFFSET_MASK + 0x10BF)
+#define HDMITX_DWC_FC_MASK0                     (DWC_OFFSET_MASK + 0x10D2)
+#define HDMITX_DWC_FC_MASK1                     (DWC_OFFSET_MASK + 0x10D6)
+#define HDMITX_DWC_FC_MASK2                     (DWC_OFFSET_MASK + 0x10DA)
+#define HDMITX_DWC_FC_PRCONF                    (DWC_OFFSET_MASK + 0x10E0)
+#define HDMITX_DWC_FC_SCRAMBLER_CTRL            (DWC_OFFSET_MASK + 0x10E1)
+
+#define HDMITX_DWC_FC_GMD_STAT                  (DWC_OFFSET_MASK + 0x1100)
+#define HDMITX_DWC_FC_GMD_EN                    (DWC_OFFSET_MASK + 0x1101)
+#define HDMITX_DWC_FC_GMD_UP                    (DWC_OFFSET_MASK + 0x1102)
+#define HDMITX_DWC_FC_GMD_CONF                  (DWC_OFFSET_MASK + 0x1103)
+#define HDMITX_DWC_FC_GMD_HB                    (DWC_OFFSET_MASK + 0x1104)
+#define HDMITX_DWC_FC_GMD_PB0                   (DWC_OFFSET_MASK + 0x1105)
+#define HDMITX_DWC_FC_GMD_PB1                   (DWC_OFFSET_MASK + 0x1106)
+#define HDMITX_DWC_FC_GMD_PB2                   (DWC_OFFSET_MASK + 0x1107)
+#define HDMITX_DWC_FC_GMD_PB3                   (DWC_OFFSET_MASK + 0x1108)
+#define HDMITX_DWC_FC_GMD_PB4                   (DWC_OFFSET_MASK + 0x1109)
+#define HDMITX_DWC_FC_GMD_PB5                   (DWC_OFFSET_MASK + 0x110A)
+#define HDMITX_DWC_FC_GMD_PB6                   (DWC_OFFSET_MASK + 0x110B)
+#define HDMITX_DWC_FC_GMD_PB7                   (DWC_OFFSET_MASK + 0x110C)
+#define HDMITX_DWC_FC_GMD_PB8                   (DWC_OFFSET_MASK + 0x110D)
+#define HDMITX_DWC_FC_GMD_PB9                   (DWC_OFFSET_MASK + 0x110E)
+#define HDMITX_DWC_FC_GMD_PB10                  (DWC_OFFSET_MASK + 0x110F)
+#define HDMITX_DWC_FC_GMD_PB11                  (DWC_OFFSET_MASK + 0x1110)
+#define HDMITX_DWC_FC_GMD_PB12                  (DWC_OFFSET_MASK + 0x1111)
+#define HDMITX_DWC_FC_GMD_PB13                  (DWC_OFFSET_MASK + 0x1112)
+#define HDMITX_DWC_FC_GMD_PB14                  (DWC_OFFSET_MASK + 0x1113)
+#define HDMITX_DWC_FC_GMD_PB15                  (DWC_OFFSET_MASK + 0x1114)
+#define HDMITX_DWC_FC_GMD_PB16                  (DWC_OFFSET_MASK + 0x1115)
+#define HDMITX_DWC_FC_GMD_PB17                  (DWC_OFFSET_MASK + 0x1116)
+#define HDMITX_DWC_FC_GMD_PB18                  (DWC_OFFSET_MASK + 0x1117)
+#define HDMITX_DWC_FC_GMD_PB19                  (DWC_OFFSET_MASK + 0x1118)
+#define HDMITX_DWC_FC_GMD_PB20                  (DWC_OFFSET_MASK + 0x1119)
+#define HDMITX_DWC_FC_GMD_PB21                  (DWC_OFFSET_MASK + 0x111A)
+#define HDMITX_DWC_FC_GMD_PB22                  (DWC_OFFSET_MASK + 0x111B)
+#define HDMITX_DWC_FC_GMD_PB23                  (DWC_OFFSET_MASK + 0x111C)
+#define HDMITX_DWC_FC_GMD_PB24                  (DWC_OFFSET_MASK + 0x111D)
+#define HDMITX_DWC_FC_GMD_PB25                  (DWC_OFFSET_MASK + 0x111E)
+#define HDMITX_DWC_FC_GMD_PB26                  (DWC_OFFSET_MASK + 0x111F)
+#define HDMITX_DWC_FC_GMD_PB27                  (DWC_OFFSET_MASK + 0x1120)
+
+#define HDMITX_DWC_FC_DBGFORCE                  (DWC_OFFSET_MASK + 0x1200)
+#define HDMITX_DWC_FC_DBGAUD0CH0                (DWC_OFFSET_MASK + 0x1201)
+#define HDMITX_DWC_FC_DBGAUD1CH0                (DWC_OFFSET_MASK + 0x1202)
+#define HDMITX_DWC_FC_DBGAUD2CH0                (DWC_OFFSET_MASK + 0x1203)
+#define HDMITX_DWC_FC_DBGAUD0CH1                (DWC_OFFSET_MASK + 0x1204)
+#define HDMITX_DWC_FC_DBGAUD1CH1                (DWC_OFFSET_MASK + 0x1205)
+#define HDMITX_DWC_FC_DBGAUD2CH1                (DWC_OFFSET_MASK + 0x1206)
+#define HDMITX_DWC_FC_DBGAUD0CH2                (DWC_OFFSET_MASK + 0x1207)
+#define HDMITX_DWC_FC_DBGAUD1CH2                (DWC_OFFSET_MASK + 0x1208)
+#define HDMITX_DWC_FC_DBGAUD2CH2                (DWC_OFFSET_MASK + 0x1209)
+#define HDMITX_DWC_FC_DBGAUD0CH3                (DWC_OFFSET_MASK + 0x120A)
+#define HDMITX_DWC_FC_DBGAUD1CH3                (DWC_OFFSET_MASK + 0x120B)
+#define HDMITX_DWC_FC_DBGAUD2CH3                (DWC_OFFSET_MASK + 0x120C)
+#define HDMITX_DWC_FC_DBGAUD0CH4                (DWC_OFFSET_MASK + 0x120D)
+#define HDMITX_DWC_FC_DBGAUD1CH4                (DWC_OFFSET_MASK + 0x120E)
+#define HDMITX_DWC_FC_DBGAUD2CH4                (DWC_OFFSET_MASK + 0x120F)
+#define HDMITX_DWC_FC_DBGAUD0CH5                (DWC_OFFSET_MASK + 0x1210)
+#define HDMITX_DWC_FC_DBGAUD1CH5                (DWC_OFFSET_MASK + 0x1211)
+#define HDMITX_DWC_FC_DBGAUD2CH5                (DWC_OFFSET_MASK + 0x1212)
+#define HDMITX_DWC_FC_DBGAUD0CH6                (DWC_OFFSET_MASK + 0x1213)
+#define HDMITX_DWC_FC_DBGAUD1CH6                (DWC_OFFSET_MASK + 0x1214)
+#define HDMITX_DWC_FC_DBGAUD2CH6                (DWC_OFFSET_MASK + 0x1215)
+#define HDMITX_DWC_FC_DBGAUD0CH7                (DWC_OFFSET_MASK + 0x1216)
+#define HDMITX_DWC_FC_DBGAUD1CH7                (DWC_OFFSET_MASK + 0x1217)
+#define HDMITX_DWC_FC_DBGAUD2CH7                (DWC_OFFSET_MASK + 0x1218)
+#define HDMITX_DWC_FC_DBGTMDS0                  (DWC_OFFSET_MASK + 0x1219)
+#define HDMITX_DWC_FC_DBGTMDS1                  (DWC_OFFSET_MASK + 0x121A)
+#define HDMITX_DWC_FC_DBGTMDS2                  (DWC_OFFSET_MASK + 0x121B)
+
+// HDMI Source PHY Registers
+#define HDMITX_DWC_PHY_CONF0                    (DWC_OFFSET_MASK + 0x3000)
+#define HDMITX_DWC_PHY_TST0                     (DWC_OFFSET_MASK + 0x3001)
+#define HDMITX_DWC_PHY_TST1                     (DWC_OFFSET_MASK + 0x3002)
+#define HDMITX_DWC_PHY_TST2                     (DWC_OFFSET_MASK + 0x3003)
+#define HDMITX_DWC_PHY_STAT0                    (DWC_OFFSET_MASK + 0x3004)
+#define HDMITX_DWC_PHY_INT0                     (DWC_OFFSET_MASK + 0x3005)
+#define HDMITX_DWC_PHY_MASK0                    (DWC_OFFSET_MASK + 0x3006)
+#define HDMITX_DWC_PHY_POL0                     (DWC_OFFSET_MASK + 0x3007)
+
+// I2C Master PHY Registers
+#define HDMITX_DWC_I2CM_PHY_SLAVE               (DWC_OFFSET_MASK + 0x3020)
+#define HDMITX_DWC_I2CM_PHY_ADDRESS             (DWC_OFFSET_MASK + 0x3021)
+#define HDMITX_DWC_I2CM_PHY_DATAO_1             (DWC_OFFSET_MASK + 0x3022)
+#define HDMITX_DWC_I2CM_PHY_DATAO_0             (DWC_OFFSET_MASK + 0x3023)
+#define HDMITX_DWC_I2CM_PHY_DATAI_1             (DWC_OFFSET_MASK + 0x3024)
+#define HDMITX_DWC_I2CM_PHY_DATAI_0             (DWC_OFFSET_MASK + 0x3025)
+#define HDMITX_DWC_I2CM_PHY_OPERATION           (DWC_OFFSET_MASK + 0x3026)
+#define HDMITX_DWC_I2CM_PHY_INT                 (DWC_OFFSET_MASK + 0x3027)
+#define HDMITX_DWC_I2CM_PHY_CTLINT              (DWC_OFFSET_MASK + 0x3028)
+#define HDMITX_DWC_I2CM_PHY_DIV                 (DWC_OFFSET_MASK + 0x3029)
+#define HDMITX_DWC_I2CM_PHY_SOFTRSTZ            (DWC_OFFSET_MASK + 0x302A)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302B)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x302C)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x302D)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x302E)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302F)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x3030)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x3031)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x3032)
+#define HDMITX_DWC_I2CM_PHY_SDA_HOLD            (DWC_OFFSET_MASK + 0x3033)
+
+// Audio Sampler Registers
+#define HDMITX_DWC_AUD_CONF0                    (DWC_OFFSET_MASK + 0x3100)
+#define HDMITX_DWC_AUD_CONF1                    (DWC_OFFSET_MASK + 0x3101)
+#define HDMITX_DWC_AUD_INT                      (DWC_OFFSET_MASK + 0x3102)
+#define HDMITX_DWC_AUD_CONF2                    (DWC_OFFSET_MASK + 0x3103)
+#define HDMITX_DWC_AUD_INT1                     (DWC_OFFSET_MASK + 0x3104)
+
+#define HDMITX_DWC_AUD_N1                       (DWC_OFFSET_MASK + 0x3200)
+#define HDMITX_DWC_AUD_N2                       (DWC_OFFSET_MASK + 0x3201)
+#define HDMITX_DWC_AUD_N3                       (DWC_OFFSET_MASK + 0x3202)
+#define HDMITX_DWC_AUD_CTS1                     (DWC_OFFSET_MASK + 0x3203)
+#define HDMITX_DWC_AUD_CTS2                     (DWC_OFFSET_MASK + 0x3204)
+#define HDMITX_DWC_AUD_CTS3                     (DWC_OFFSET_MASK + 0x3205)
+#define HDMITX_DWC_AUD_INPUTCLKFS               (DWC_OFFSET_MASK + 0x3206)
+
+#define HDMITX_DWC_AUD_SPDIF0                   (DWC_OFFSET_MASK + 0x3300)
+#define HDMITX_DWC_AUD_SPDIF1                   (DWC_OFFSET_MASK + 0x3301)
+#define HDMITX_DWC_AUD_SPDIFINT                 (DWC_OFFSET_MASK + 0x3302)
+#define HDMITX_DWC_AUD_SPDIFINT1                (DWC_OFFSET_MASK + 0x3303)
+
+// Generic Parallel Audio Interface Registers   (DWC_OFFSET_MASK + 0x3500)
+// Audio DMA Registers                          (DWC_OFFSET_MASK + 0x3600)
+
+// Main Controller Registers
+#define HDMITX_DWC_MC_CLKDIS                    (DWC_OFFSET_MASK + 0x4001)
+#define HDMITX_DWC_MC_SWRSTZREQ                 (DWC_OFFSET_MASK + 0x4002)
+#define HDMITX_DWC_MC_OPCTRL                    (DWC_OFFSET_MASK + 0x4003)
+#define HDMITX_DWC_MC_FLOWCTRL                  (DWC_OFFSET_MASK + 0x4004)
+#define HDMITX_DWC_MC_PHYRSTZ                   (DWC_OFFSET_MASK + 0x4005)
+#define HDMITX_DWC_MC_LOCKONCLOCK               (DWC_OFFSET_MASK + 0x4006)
+
+// Color Space Converter Registers
+#define HDMITX_DWC_CSC_CFG                      (DWC_OFFSET_MASK + 0x4100)
+#define HDMITX_DWC_CSC_SCALE                    (DWC_OFFSET_MASK + 0x4101)
+#define HDMITX_DWC_CSC_COEF_A1_MSB              (DWC_OFFSET_MASK + 0x4102)
+#define HDMITX_DWC_CSC_COEF_A1_LSB              (DWC_OFFSET_MASK + 0x4103)
+#define HDMITX_DWC_CSC_COEF_A2_MSB              (DWC_OFFSET_MASK + 0x4104)
+#define HDMITX_DWC_CSC_COEF_A2_LSB              (DWC_OFFSET_MASK + 0x4105)
+#define HDMITX_DWC_CSC_COEF_A3_MSB              (DWC_OFFSET_MASK + 0x4106)
+#define HDMITX_DWC_CSC_COEF_A3_LSB              (DWC_OFFSET_MASK + 0x4107)
+#define HDMITX_DWC_CSC_COEF_A4_MSB              (DWC_OFFSET_MASK + 0x4108)
+#define HDMITX_DWC_CSC_COEF_A4_LSB              (DWC_OFFSET_MASK + 0x4109)
+#define HDMITX_DWC_CSC_COEF_B1_MSB              (DWC_OFFSET_MASK + 0x410A)
+#define HDMITX_DWC_CSC_COEF_B1_LSB              (DWC_OFFSET_MASK + 0x410B)
+#define HDMITX_DWC_CSC_COEF_B2_MSB              (DWC_OFFSET_MASK + 0x410C)
+#define HDMITX_DWC_CSC_COEF_B2_LSB              (DWC_OFFSET_MASK + 0x410D)
+#define HDMITX_DWC_CSC_COEF_B3_MSB              (DWC_OFFSET_MASK + 0x410E)
+#define HDMITX_DWC_CSC_COEF_B3_LSB              (DWC_OFFSET_MASK + 0x410F)
+#define HDMITX_DWC_CSC_COEF_B4_MSB              (DWC_OFFSET_MASK + 0x4110)
+#define HDMITX_DWC_CSC_COEF_B4_LSB              (DWC_OFFSET_MASK + 0x4111)
+#define HDMITX_DWC_CSC_COEF_C1_MSB              (DWC_OFFSET_MASK + 0x4112)
+#define HDMITX_DWC_CSC_COEF_C1_LSB              (DWC_OFFSET_MASK + 0x4113)
+#define HDMITX_DWC_CSC_COEF_C2_MSB              (DWC_OFFSET_MASK + 0x4114)
+#define HDMITX_DWC_CSC_COEF_C2_LSB              (DWC_OFFSET_MASK + 0x4115)
+#define HDMITX_DWC_CSC_COEF_C3_MSB              (DWC_OFFSET_MASK + 0x4116)
+#define HDMITX_DWC_CSC_COEF_C3_LSB              (DWC_OFFSET_MASK + 0x4117)
+#define HDMITX_DWC_CSC_COEF_C4_MSB              (DWC_OFFSET_MASK + 0x4118)
+#define HDMITX_DWC_CSC_COEF_C4_LSB              (DWC_OFFSET_MASK + 0x4119)
+#define HDMITX_DWC_CSC_SPARE1                   (DWC_OFFSET_MASK + 0x411A)
+#define HDMITX_DWC_CSC_SPARE2                   (DWC_OFFSET_MASK + 0x411B)
+
+// HDCP Encryption Engine Registers
+#define HDMITX_DWC_A_HDCPCFG0                   (DWC_OFFSET_MASK + 0x5000)
+#define HDMITX_DWC_A_HDCPCFG1                   (DWC_OFFSET_MASK + 0x5001)
+#define HDMITX_DWC_A_HDCPOBS0                   (DWC_OFFSET_MASK + 0x5002)
+#define HDMITX_DWC_A_HDCPOBS1                   (DWC_OFFSET_MASK + 0x5003)
+#define HDMITX_DWC_A_HDCPOBS2                   (DWC_OFFSET_MASK + 0x5004)
+#define HDMITX_DWC_A_HDCPOBS3                   (DWC_OFFSET_MASK + 0x5005)
+#define HDMITX_DWC_A_APIINTCLR                  (DWC_OFFSET_MASK + 0x5006)
+#define HDMITX_DWC_A_APIINTSTAT                 (DWC_OFFSET_MASK + 0x5007)
+#define HDMITX_DWC_A_APIINTMSK                  (DWC_OFFSET_MASK + 0x5008)
+#define HDMITX_DWC_A_VIDPOLCFG                  (DWC_OFFSET_MASK + 0x5009)
+#define HDMITX_DWC_A_OESSWCFG                   (DWC_OFFSET_MASK + 0x500A)
+#define HDMITX_DWC_A_COREVERLSB                 (DWC_OFFSET_MASK + 0x5014)
+#define HDMITX_DWC_A_COREVERMSB                 (DWC_OFFSET_MASK + 0x5015)
+#define HDMITX_DWC_A_KSVMEMCTRL                 (DWC_OFFSET_MASK + 0x5016)
+
+#define HDMITX_DWC_HDCP_BSTATUS_0               (DWC_OFFSET_MASK + 0x5020)
+#define HDMITX_DWC_HDCP_BSTATUS_1               (DWC_OFFSET_MASK + 0x5021)
+#define HDMITX_DWC_HDCP_M0_0                    (DWC_OFFSET_MASK + 0x5022)
+#define HDMITX_DWC_HDCP_M0_1                    (DWC_OFFSET_MASK + 0x5023)
+#define HDMITX_DWC_HDCP_M0_2                    (DWC_OFFSET_MASK + 0x5024)
+#define HDMITX_DWC_HDCP_M0_3                    (DWC_OFFSET_MASK + 0x5025)
+#define HDMITX_DWC_HDCP_M0_4                    (DWC_OFFSET_MASK + 0x5026)
+#define HDMITX_DWC_HDCP_M0_5                    (DWC_OFFSET_MASK + 0x5027)
+#define HDMITX_DWC_HDCP_M0_6                    (DWC_OFFSET_MASK + 0x5028)
+#define HDMITX_DWC_HDCP_M0_7                    (DWC_OFFSET_MASK + 0x5029)
+#define HDMITX_DWC_HDCP_KSV                     (DWC_OFFSET_MASK + 0x502A)
+#define HDMITX_DWC_HDCP_VH                      (DWC_OFFSET_MASK + 0x52A5)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_0            (DWC_OFFSET_MASK + 0x52B9)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_1            (DWC_OFFSET_MASK + 0x52BA)
+#define HDMITX_DWC_HDCP_REVOC_LIST              (DWC_OFFSET_MASK + 0x52BB)
+
+// HDCP BKSV Registers
+#define HDMITX_DWC_HDCPREG_BKSV0                (DWC_OFFSET_MASK + 0x7800)
+#define HDMITX_DWC_HDCPREG_BKSV1                (DWC_OFFSET_MASK + 0x7801)
+#define HDMITX_DWC_HDCPREG_BKSV2                (DWC_OFFSET_MASK + 0x7802)
+#define HDMITX_DWC_HDCPREG_BKSV3                (DWC_OFFSET_MASK + 0x7803)
+#define HDMITX_DWC_HDCPREG_BKSV4                (DWC_OFFSET_MASK + 0x7804)
+
+// HDCP AN Registers
+#define HDMITX_DWC_HDCPREG_ANCONF               (DWC_OFFSET_MASK + 0x7805)
+#define HDMITX_DWC_HDCPREG_AN0                  (DWC_OFFSET_MASK + 0x7806)
+#define HDMITX_DWC_HDCPREG_AN1                  (DWC_OFFSET_MASK + 0x7807)
+#define HDMITX_DWC_HDCPREG_AN2                  (DWC_OFFSET_MASK + 0x7808)
+#define HDMITX_DWC_HDCPREG_AN3                  (DWC_OFFSET_MASK + 0x7809)
+#define HDMITX_DWC_HDCPREG_AN4                  (DWC_OFFSET_MASK + 0x780A)
+#define HDMITX_DWC_HDCPREG_AN5                  (DWC_OFFSET_MASK + 0x780B)
+#define HDMITX_DWC_HDCPREG_AN6                  (DWC_OFFSET_MASK + 0x780C)
+#define HDMITX_DWC_HDCPREG_AN7                  (DWC_OFFSET_MASK + 0x780D)
+#define HDMITX_DWC_HDCPREG_RMLCTL               (DWC_OFFSET_MASK + 0x780E)
+
+// Encrypted DPK Embedded Storage Registers
+#define HDMITX_DWC_HDCPREG_RMLSTS               (DWC_OFFSET_MASK + 0x780F)
+#define HDMITX_DWC_HDCPREG_SEED0                (DWC_OFFSET_MASK + 0x7810)
+#define HDMITX_DWC_HDCPREG_SEED1                (DWC_OFFSET_MASK + 0x7811)
+#define HDMITX_DWC_HDCPREG_DPK0                 (DWC_OFFSET_MASK + 0x7812)
+#define HDMITX_DWC_HDCPREG_DPK1                 (DWC_OFFSET_MASK + 0x7813)
+#define HDMITX_DWC_HDCPREG_DPK2                 (DWC_OFFSET_MASK + 0x7814)
+#define HDMITX_DWC_HDCPREG_DPK3                 (DWC_OFFSET_MASK + 0x7815)
+#define HDMITX_DWC_HDCPREG_DPK4                 (DWC_OFFSET_MASK + 0x7816)
+#define HDMITX_DWC_HDCPREG_DPK5                 (DWC_OFFSET_MASK + 0x7817)
+#define HDMITX_DWC_HDCPREG_DPK6                 (DWC_OFFSET_MASK + 0x7818)
+
+// I2C Master Registers(E-DDC/SCDC)
+#define HDMITX_DWC_I2CM_SLAVE                   (DWC_OFFSET_MASK + 0x7E00)
+#define HDMITX_DWC_I2CM_ADDRESS                 (DWC_OFFSET_MASK + 0x7E01)
+#define HDMITX_DWC_I2CM_DATAO                   (DWC_OFFSET_MASK + 0x7E02)
+#define HDMITX_DWC_I2CM_DATAI                   (DWC_OFFSET_MASK + 0x7E03)
+#define HDMITX_DWC_I2CM_OPERATION               (DWC_OFFSET_MASK + 0x7E04)
+#define HDMITX_DWC_I2CM_INT                     (DWC_OFFSET_MASK + 0x7E05)
+#define HDMITX_DWC_I2CM_CTLINT                  (DWC_OFFSET_MASK + 0x7E06)
+#define HDMITX_DWC_I2CM_DIV                     (DWC_OFFSET_MASK + 0x7E07)
+#define HDMITX_DWC_I2CM_SEGADDR                 (DWC_OFFSET_MASK + 0x7E08)
+#define HDMITX_DWC_I2CM_SOFTRSTZ                (DWC_OFFSET_MASK + 0x7E09)
+#define HDMITX_DWC_I2CM_SEGPTR                  (DWC_OFFSET_MASK + 0x7E0A)
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0B)
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E0C)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E0D)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E0E)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0F)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E10)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E11)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E12)
+#define HDMITX_DWC_I2CM_SDA_HOLD                (DWC_OFFSET_MASK + 0x7E13)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE             (DWC_OFFSET_MASK + 0x7E14)
+#define HDMITX_DWC_I2CM_READ_BUFF0              (DWC_OFFSET_MASK + 0x7E20)
+#define HDMITX_DWC_I2CM_READ_BUFF1              (DWC_OFFSET_MASK + 0x7E21)
+#define HDMITX_DWC_I2CM_READ_BUFF2              (DWC_OFFSET_MASK + 0x7E22)
+#define HDMITX_DWC_I2CM_READ_BUFF3              (DWC_OFFSET_MASK + 0x7E23)
+#define HDMITX_DWC_I2CM_READ_BUFF4              (DWC_OFFSET_MASK + 0x7E24)
+#define HDMITX_DWC_I2CM_READ_BUFF5              (DWC_OFFSET_MASK + 0x7E25)
+#define HDMITX_DWC_I2CM_READ_BUFF6              (DWC_OFFSET_MASK + 0x7E26)
+#define HDMITX_DWC_I2CM_READ_BUFF7              (DWC_OFFSET_MASK + 0x7E27)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE0            (DWC_OFFSET_MASK + 0x7E30)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE1            (DWC_OFFSET_MASK + 0x7E31)
+
+
+//********** CEC related **********//
+
+// CEC 2.0 Engine Registers
+#define HDMITX_DWC_CEC_CTRL                     (DWC_OFFSET_MASK + 0x7D00)
+#define HDMITX_DWC_CEC_INTR_MASK                (DWC_OFFSET_MASK + 0x7D02)
+#define HDMITX_DWC_CEC_LADD_LOW                 (DWC_OFFSET_MASK + 0x7D05)
+#define HDMITX_DWC_CEC_LADD_HIGH                (DWC_OFFSET_MASK + 0x7D06)
+#define HDMITX_DWC_CEC_TX_CNT                   (DWC_OFFSET_MASK + 0x7D07)
+#define HDMITX_DWC_CEC_RX_CNT                   (DWC_OFFSET_MASK + 0x7D08)
+#define HDMITX_DWC_CEC_TX_DATA00                (DWC_OFFSET_MASK + 0x7D10)
+#define HDMITX_DWC_CEC_TX_DATA01                (DWC_OFFSET_MASK + 0x7D11)
+#define HDMITX_DWC_CEC_TX_DATA02                (DWC_OFFSET_MASK + 0x7D12)
+#define HDMITX_DWC_CEC_TX_DATA03                (DWC_OFFSET_MASK + 0x7D13)
+#define HDMITX_DWC_CEC_TX_DATA04                (DWC_OFFSET_MASK + 0x7D14)
+#define HDMITX_DWC_CEC_TX_DATA05                (DWC_OFFSET_MASK + 0x7D15)
+#define HDMITX_DWC_CEC_TX_DATA06                (DWC_OFFSET_MASK + 0x7D16)
+#define HDMITX_DWC_CEC_TX_DATA07                (DWC_OFFSET_MASK + 0x7D17)
+#define HDMITX_DWC_CEC_TX_DATA08                (DWC_OFFSET_MASK + 0x7D18)
+#define HDMITX_DWC_CEC_TX_DATA09                (DWC_OFFSET_MASK + 0x7D19)
+#define HDMITX_DWC_CEC_TX_DATA10                (DWC_OFFSET_MASK + 0x7D1A)
+#define HDMITX_DWC_CEC_TX_DATA11                (DWC_OFFSET_MASK + 0x7D1B)
+#define HDMITX_DWC_CEC_TX_DATA12                (DWC_OFFSET_MASK + 0x7D1C)
+#define HDMITX_DWC_CEC_TX_DATA13                (DWC_OFFSET_MASK + 0x7D1D)
+#define HDMITX_DWC_CEC_TX_DATA14                (DWC_OFFSET_MASK + 0x7D1E)
+#define HDMITX_DWC_CEC_TX_DATA15                (DWC_OFFSET_MASK + 0x7D1F)
+#define HDMITX_DWC_CEC_RX_DATA00                (DWC_OFFSET_MASK + 0x7D20)
+#define HDMITX_DWC_CEC_RX_DATA01                (DWC_OFFSET_MASK + 0x7D21)
+#define HDMITX_DWC_CEC_RX_DATA02                (DWC_OFFSET_MASK + 0x7D22)
+#define HDMITX_DWC_CEC_RX_DATA03                (DWC_OFFSET_MASK + 0x7D23)
+#define HDMITX_DWC_CEC_RX_DATA04                (DWC_OFFSET_MASK + 0x7D24)
+#define HDMITX_DWC_CEC_RX_DATA05                (DWC_OFFSET_MASK + 0x7D25)
+#define HDMITX_DWC_CEC_RX_DATA06                (DWC_OFFSET_MASK + 0x7D26)
+#define HDMITX_DWC_CEC_RX_DATA07                (DWC_OFFSET_MASK + 0x7D27)
+#define HDMITX_DWC_CEC_RX_DATA08                (DWC_OFFSET_MASK + 0x7D28)
+#define HDMITX_DWC_CEC_RX_DATA09                (DWC_OFFSET_MASK + 0x7D29)
+#define HDMITX_DWC_CEC_RX_DATA10                (DWC_OFFSET_MASK + 0x7D2A)
+#define HDMITX_DWC_CEC_RX_DATA11                (DWC_OFFSET_MASK + 0x7D2B)
+#define HDMITX_DWC_CEC_RX_DATA12                (DWC_OFFSET_MASK + 0x7D2C)
+#define HDMITX_DWC_CEC_RX_DATA13                (DWC_OFFSET_MASK + 0x7D2D)
+#define HDMITX_DWC_CEC_RX_DATA14                (DWC_OFFSET_MASK + 0x7D2E)
+#define HDMITX_DWC_CEC_RX_DATA15                (DWC_OFFSET_MASK + 0x7D2F)
+#define HDMITX_DWC_CEC_LOCK_BUF                 (DWC_OFFSET_MASK + 0x7D30)
+#define HDMITX_DWC_CEC_WAKEUPCTRL               (DWC_OFFSET_MASK + 0x7D31)
+
+
+//read/write
+#define CEC_TX_MSG_0_HEADER        0x00
+#define CEC_TX_MSG_1_OPCODE        0x01
+#define CEC_TX_MSG_2_OP1           0x02
+#define CEC_TX_MSG_3_OP2           0x03
+#define CEC_TX_MSG_4_OP3           0x04
+#define CEC_TX_MSG_5_OP4           0x05
+#define CEC_TX_MSG_6_OP5           0x06
+#define CEC_TX_MSG_7_OP6           0x07
+#define CEC_TX_MSG_8_OP7           0x08
+#define CEC_TX_MSG_9_OP8           0x09
+#define CEC_TX_MSG_A_OP9           0x0A
+#define CEC_TX_MSG_B_OP10          0x0B
+#define CEC_TX_MSG_C_OP11          0x0C
+#define CEC_TX_MSG_D_OP12          0x0D
+#define CEC_TX_MSG_E_OP13          0x0E
+#define CEC_TX_MSG_F_OP14          0x0F
+
+//read/write
+#define CEC_TX_MSG_LENGTH          0x10
+#define CEC_TX_MSG_CMD             0x11
+#define CEC_TX_WRITE_BUF           0x12
+#define CEC_TX_CLEAR_BUF           0x13
+#define CEC_RX_MSG_CMD             0x14
+#define CEC_RX_CLEAR_BUF           0x15
+#define CEC_LOGICAL_ADDR0          0x16
+#define CEC_LOGICAL_ADDR1          0x17
+#define CEC_LOGICAL_ADDR2          0x18
+#define CEC_LOGICAL_ADDR3          0x19
+#define CEC_LOGICAL_ADDR4          0x1A
+#define CEC_CLOCK_DIV_H            0x1B
+#define CEC_CLOCK_DIV_L            0x1C
+
+// The following registers are for fine tuning CEC bit timing parameters.
+// They are only valid in AO CEC, NOT valid in HDMITX CEC.
+// The AO CEC's timing parameters are already set default to work with 32768Hz clock, so hopefully
+// SW never need to program these registers. The timing registers are made programmable just in case.
+#define CEC_QUIESCENT_25MS_BIT7_0               0x20
+#define CEC_QUIESCENT_25MS_BIT11_8              0x21
+#define CEC_STARTBITMINL2H_3MS5_BIT7_0          0x22
+#define CEC_STARTBITMINL2H_3MS5_BIT8            0x23
+#define CEC_STARTBITMAXL2H_3MS9_BIT7_0          0x24
+#define CEC_STARTBITMAXL2H_3MS9_BIT8            0x25
+#define CEC_STARTBITMINH_0MS6_BIT7_0            0x26
+#define CEC_STARTBITMINH_0MS6_BIT8              0x27
+#define CEC_STARTBITMAXH_1MS0_BIT7_0            0x28
+#define CEC_STARTBITMAXH_1MS0_BIT8              0x29
+#define CEC_STARTBITMINTOTAL_4MS3_BIT7_0        0x2A
+#define CEC_STARTBITMINTOTAL_4MS3_BIT9_8        0x2B
+#define CEC_STARTBITMAXTOTAL_4MS7_BIT7_0        0x2C
+#define CEC_STARTBITMAXTOTAL_4MS7_BIT9_8        0x2D
+#define CEC_LOGIC1MINL2H_0MS4_BIT7_0            0x2E
+#define CEC_LOGIC1MINL2H_0MS4_BIT8              0x2F
+#define CEC_LOGIC1MAXL2H_0MS8_BIT7_0            0x30
+#define CEC_LOGIC1MAXL2H_0MS8_BIT8              0x31
+#define CEC_LOGIC0MINL2H_1MS3_BIT7_0            0x32
+#define CEC_LOGIC0MINL2H_1MS3_BIT8              0x33
+#define CEC_LOGIC0MAXL2H_1MS7_BIT7_0            0x34
+#define CEC_LOGIC0MAXL2H_1MS7_BIT8              0x35
+#define CEC_LOGICMINTOTAL_2MS05_BIT7_0          0x36
+#define CEC_LOGICMINTOTAL_2MS05_BIT9_8          0x37
+#define CEC_LOGICMAXHIGH_2MS8_BIT7_0            0x38
+#define CEC_LOGICMAXHIGH_2MS8_BIT8              0x39
+#define CEC_LOGICERRLOW_3MS4_BIT7_0             0x3A
+#define CEC_LOGICERRLOW_3MS4_BIT8               0x3B
+#define CEC_NOMSMPPOINT_1MS05                   0x3C
+#define CEC_DELCNTR_LOGICERR                    0x3E
+#define CEC_TXTIME_17MS_BIT7_0                  0x40
+#define CEC_TXTIME_17MS_BIT15_8                 0x41
+#define CEC_TXTIME_2BIT_BIT7_0                  0x42
+#define CEC_TXTIME_2BIT_BIT15_8                 0x43
+#define CEC_TXTIME_4BIT_BIT7_0                  0x44
+#define CEC_TXTIME_4BIT_BIT15_8                 0x45
+#define CEC_STARTBITNOML2H_3MS7_BIT7_0          0x46
+#define CEC_STARTBITNOML2H_3MS7_BIT8            0x47
+#define CEC_STARTBITNOMH_0MS8_BIT7_0            0x48
+#define CEC_STARTBITNOMH_0MS8_BIT8              0x49
+#define CEC_LOGIC1NOML2H_0MS6_BIT7_0            0x4A
+#define CEC_LOGIC1NOML2H_0MS6_BIT8              0x4B
+#define CEC_LOGIC0NOML2H_1MS5_BIT7_0            0x4C
+#define CEC_LOGIC0NOML2H_1MS5_BIT8              0x4D
+#define CEC_LOGIC1NOMH_1MS8_BIT7_0              0x4E
+#define CEC_LOGIC1NOMH_1MS8_BIT8                0x4F
+#define CEC_LOGIC0NOMH_0MS9_BIT7_0              0x50
+#define CEC_LOGIC0NOMH_0MS9_BIT8                0x51
+#define CEC_LOGICERRLOW_3MS6_BIT7_0             0x52
+#define CEC_LOGICERRLOW_3MS6_BIT8               0x53
+#define CEC_CHKCONTENTION_0MS1                  0x54
+#define CEC_PREPARENXTBIT_0MS05_BIT7_0          0x56
+#define CEC_PREPARENXTBIT_0MS05_BIT8            0x57
+#define CEC_NOMSMPACKPOINT_0MS45                0x58
+#define CEC_ACK0NOML2H_1MS5_BIT7_0              0x5A
+#define CEC_ACK0NOML2H_1MS5_BIT8                0x5B
+
+#define CEC_BUGFIX_DISABLE_0                    0x60
+#define CEC_BUGFIX_DISABLE_1                    0x61
+
+//read only
+#define CEC_RX_MSG_0_HEADER        0x80
+#define CEC_RX_MSG_1_OPCODE        0x81
+#define CEC_RX_MSG_2_OP1           0x82
+#define CEC_RX_MSG_3_OP2           0x83
+#define CEC_RX_MSG_4_OP3           0x84
+#define CEC_RX_MSG_5_OP4           0x85
+#define CEC_RX_MSG_6_OP5           0x86
+#define CEC_RX_MSG_7_OP6           0x87
+#define CEC_RX_MSG_8_OP7           0x88
+#define CEC_RX_MSG_9_OP8           0x89
+#define CEC_RX_MSG_A_OP9           0x8A
+#define CEC_RX_MSG_B_OP10          0x8B
+#define CEC_RX_MSG_C_OP11          0x8C
+#define CEC_RX_MSG_D_OP12          0x8D
+#define CEC_RX_MSG_E_OP13          0x8E
+#define CEC_RX_MSG_F_OP14          0x8F
+
+//read only
+#define CEC_RX_MSG_LENGTH          0x90
+#define CEC_RX_MSG_STATUS          0x91
+#define CEC_RX_NUM_MSG             0x92
+#define CEC_TX_MSG_STATUS          0x93
+#define CEC_TX_NUM_MSG             0x94
+
+// tx_msg_cmd definition
+#define TX_NO_OP                0  // No transaction
+#define TX_REQ_CURRENT          1  // Transmit earliest message in buffer
+#define TX_ABORT                2  // Abort transmitting earliest message
+#define TX_REQ_NEXT             3  // Overwrite earliest message in buffer and transmit next message
+
+// tx_msg_status definition
+#define TX_IDLE                 0  // No transaction
+#define TX_BUSY                 1  // Transmitter is busy
+#define TX_DONE                 2  // Message has been successfully transmitted
+#define TX_ERROR                3  // Message has been transmitted with error
+
+// rx_msg_cmd
+#define RX_NO_OP                0  // No transaction
+#define RX_ACK_CURRENT          1  // Read earliest message in buffer
+#define RX_DISABLE              2  // Disable receiving latest message
+#define RX_ACK_NEXT             3  // Clear earliest message from buffer and read next message
+
+// rx_msg_status
+#define RX_IDLE                 0  // No transaction
+#define RX_BUSY                 1  // Receiver is busy
+#define RX_DONE                 2  // Message has been received successfully
+#define RX_ERROR                3  // Message has been received with error
+#endif  /* __HDMI_TX_REG_H_ */
diff --git a/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmitx_regs.h b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmitx_regs.h
new file mode 100644
index 000000000000..29b5e6681035
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/hdmitx_regs.h
@@ -0,0 +1,564 @@
+#ifndef  HDMITX_PARAMETER_DEFINE_H
+#define  HDMITX_PARAMETER_DEFINE_H
+
+// Use the following functions to access the on-chip HDMITX modules by default
+extern void hdmitx_wr_reg(unsigned long addr, unsigned long data);
+extern unsigned long hdmitx_rd_reg(unsigned long addr);
+extern void hdmitx_rd_check_reg(unsigned long addr, unsigned long exp_data, unsigned long mask);
+
+//------------------------------------------------------------------------------
+// TOP-level wrapper registers addresses
+//------------------------------------------------------------------------------
+#define TOP_OFFSET_MASK      (0x00 << 24)
+#define DWC_OFFSET_MASK      (0x10 << 24)
+
+#define HDMITX_TOP_SW_RESET                     (TOP_OFFSET_MASK + 0x000)
+#define HDMITX_TOP_CLK_CNTL                     (TOP_OFFSET_MASK + 0x001)
+#define HDMITX_TOP_HPD_FILTER                   (TOP_OFFSET_MASK + 0x002)
+#define HDMITX_TOP_INTR_MASKN                   (TOP_OFFSET_MASK + 0x003)
+#define HDMITX_TOP_INTR_STAT                    (TOP_OFFSET_MASK + 0x004)
+#define HDMITX_TOP_INTR_STAT_CLR                (TOP_OFFSET_MASK + 0x005)
+#define HDMITX_TOP_BIST_CNTL                    (TOP_OFFSET_MASK + 0x006)
+#define HDMITX_TOP_SHIFT_PTTN_012               (TOP_OFFSET_MASK + 0x007)
+#define HDMITX_TOP_SHIFT_PTTN_345               (TOP_OFFSET_MASK + 0x008)
+#define HDMITX_TOP_SHIFT_PTTN_67                (TOP_OFFSET_MASK + 0x009)
+#define HDMITX_TOP_TMDS_CLK_PTTN_01             (TOP_OFFSET_MASK + 0x00A)
+#define HDMITX_TOP_TMDS_CLK_PTTN_23             (TOP_OFFSET_MASK + 0x00B)
+#define HDMITX_TOP_TMDS_CLK_PTTN_CNTL           (TOP_OFFSET_MASK + 0x00C)
+#define HDMITX_TOP_REVOCMEM_STAT                (TOP_OFFSET_MASK + 0x00D)
+#define HDMITX_TOP_STAT0                        (TOP_OFFSET_MASK + 0x00E)
+
+#define HDMITX_TOP_DONT_TOUCH0                  (TOP_OFFSET_MASK + 0x0FE)
+#define HDMITX_TOP_DONT_TOUCH1                  (TOP_OFFSET_MASK + 0x0FF)
+
+//------------------------------------------------------------------------------
+// DWC_HDMI_TX Controller registers addresses
+//------------------------------------------------------------------------------
+
+// Identification Registers
+#define HDMITX_DWC_DESIGN_ID                    (DWC_OFFSET_MASK + 0x0000)
+#define HDMITX_DWC_REVISION_ID                  (DWC_OFFSET_MASK + 0x0001)
+#define HDMITX_DWC_PRODUCT_ID0                  (DWC_OFFSET_MASK + 0x0002)
+#define HDMITX_DWC_PRODUCT_ID1                  (DWC_OFFSET_MASK + 0x0003)
+#define HDMITX_DWC_CONFIG0_ID                   (DWC_OFFSET_MASK + 0x0004)
+#define HDMITX_DWC_CONFIG1_ID                   (DWC_OFFSET_MASK + 0x0005)
+#define HDMITX_DWC_CONFIG2_ID                   (DWC_OFFSET_MASK + 0x0006)
+#define HDMITX_DWC_CONFIG3_ID                   (DWC_OFFSET_MASK + 0x0007)
+
+// Interrupt Registers
+#define HDMITX_DWC_IH_FC_STAT0                  (DWC_OFFSET_MASK + 0x0100)
+#define HDMITX_DWC_IH_FC_STAT1                  (DWC_OFFSET_MASK + 0x0101)
+#define HDMITX_DWC_IH_FC_STAT2                  (DWC_OFFSET_MASK + 0x0102)
+#define HDMITX_DWC_IH_AS_STAT0                  (DWC_OFFSET_MASK + 0x0103)
+#define HDMITX_DWC_IH_PHY_STAT0                 (DWC_OFFSET_MASK + 0x0104)
+#define HDMITX_DWC_IH_I2CM_STAT0                (DWC_OFFSET_MASK + 0x0105)
+#define HDMITX_DWC_IH_CEC_STAT0                 (DWC_OFFSET_MASK + 0x0106)
+#define HDMITX_DWC_IH_VP_STAT0                  (DWC_OFFSET_MASK + 0x0107)
+#define HDMITX_DWC_IH_I2CMPHY_STAT0             (DWC_OFFSET_MASK + 0x0108)
+#define HDMITX_DWC_IH_DECODE                    (DWC_OFFSET_MASK + 0x0170)
+#define HDMITX_DWC_IH_MUTE_FC_STAT0             (DWC_OFFSET_MASK + 0x0180)
+#define HDMITX_DWC_IH_MUTE_FC_STAT1             (DWC_OFFSET_MASK + 0x0181)
+#define HDMITX_DWC_IH_MUTE_FC_STAT2             (DWC_OFFSET_MASK + 0x0182)
+#define HDMITX_DWC_IH_MUTE_AS_STAT0             (DWC_OFFSET_MASK + 0x0183)
+#define HDMITX_DWC_IH_MUTE_PHY_STAT0            (DWC_OFFSET_MASK + 0x0184)
+#define HDMITX_DWC_IH_MUTE_I2CM_STAT0           (DWC_OFFSET_MASK + 0x0185)
+#define HDMITX_DWC_IH_MUTE_CEC_STAT0            (DWC_OFFSET_MASK + 0x0186)
+#define HDMITX_DWC_IH_MUTE_VP_STAT0             (DWC_OFFSET_MASK + 0x0187)
+#define HDMITX_DWC_IH_MUTE_I2CMPHY_STAT0        (DWC_OFFSET_MASK + 0x0188)
+#define HDMITX_DWC_IH_MUTE                      (DWC_OFFSET_MASK + 0x01FF)
+
+// Video Sampler Registers
+#define HDMITX_DWC_TX_INVID0                    (DWC_OFFSET_MASK + 0x0200)
+#define HDMITX_DWC_TX_INSTUFFING                (DWC_OFFSET_MASK + 0x0201)
+#define HDMITX_DWC_TX_GYDATA0                   (DWC_OFFSET_MASK + 0x0202)
+#define HDMITX_DWC_TX_GYDATA1                   (DWC_OFFSET_MASK + 0x0203)
+#define HDMITX_DWC_TX_RCRDATA0                  (DWC_OFFSET_MASK + 0x0204)
+#define HDMITX_DWC_TX_RCRDATA1                  (DWC_OFFSET_MASK + 0x0205)
+#define HDMITX_DWC_TX_BCBDATA0                  (DWC_OFFSET_MASK + 0x0206)
+#define HDMITX_DWC_TX_BCBDATA1                  (DWC_OFFSET_MASK + 0x0207)
+
+// Video Packetizer Registers
+#define HDMITX_DWC_VP_STATUS                    (DWC_OFFSET_MASK + 0x0800)
+#define HDMITX_DWC_VP_PR_CD                     (DWC_OFFSET_MASK + 0x0801)
+#define HDMITX_DWC_VP_STUFF                     (DWC_OFFSET_MASK + 0x0802)
+#define HDMITX_DWC_VP_REMAP                     (DWC_OFFSET_MASK + 0x0803)
+#define HDMITX_DWC_VP_CONF                      (DWC_OFFSET_MASK + 0x0804)
+#define HDMITX_DWC_VP_MASK                      (DWC_OFFSET_MASK + 0x0807)
+
+// Frmae Composer Registers
+#define HDMITX_DWC_FC_INVIDCONF                 (DWC_OFFSET_MASK + 0x1000)
+#define HDMITX_DWC_FC_INHACTV0                  (DWC_OFFSET_MASK + 0x1001)
+#define HDMITX_DWC_FC_INHACTV1                  (DWC_OFFSET_MASK + 0x1002)
+#define HDMITX_DWC_FC_INHBLANK0                 (DWC_OFFSET_MASK + 0x1003)
+#define HDMITX_DWC_FC_INHBLANK1                 (DWC_OFFSET_MASK + 0x1004)
+#define HDMITX_DWC_FC_INVACTV0                  (DWC_OFFSET_MASK + 0x1005)
+#define HDMITX_DWC_FC_INVACTV1                  (DWC_OFFSET_MASK + 0x1006)
+#define HDMITX_DWC_FC_INVBLANK                  (DWC_OFFSET_MASK + 0x1007)
+#define HDMITX_DWC_FC_HSYNCINDELAY0             (DWC_OFFSET_MASK + 0x1008)
+#define HDMITX_DWC_FC_HSYNCINDELAY1             (DWC_OFFSET_MASK + 0x1009)
+#define HDMITX_DWC_FC_HSYNCINWIDTH0             (DWC_OFFSET_MASK + 0x100A)
+#define HDMITX_DWC_FC_HSYNCINWIDTH1             (DWC_OFFSET_MASK + 0x100B)
+#define HDMITX_DWC_FC_VSYNCINDELAY              (DWC_OFFSET_MASK + 0x100C)
+#define HDMITX_DWC_FC_VSYNCINWIDTH              (DWC_OFFSET_MASK + 0x100D)
+#define HDMITX_DWC_FC_INFREQ0                   (DWC_OFFSET_MASK + 0x100E)
+#define HDMITX_DWC_FC_INFREQ1                   (DWC_OFFSET_MASK + 0x100F)
+#define HDMITX_DWC_FC_INFREQ2                   (DWC_OFFSET_MASK + 0x1010)
+#define HDMITX_DWC_FC_CTRLDUR                   (DWC_OFFSET_MASK + 0x1011)
+#define HDMITX_DWC_FC_EXCTRLDUR                 (DWC_OFFSET_MASK + 0x1012)
+#define HDMITX_DWC_FC_EXCTRLSPAC                (DWC_OFFSET_MASK + 0x1013)
+#define HDMITX_DWC_FC_CH0PREAM                  (DWC_OFFSET_MASK + 0x1014)
+#define HDMITX_DWC_FC_CH1PREAM                  (DWC_OFFSET_MASK + 0x1015)
+#define HDMITX_DWC_FC_CH2PREAM                  (DWC_OFFSET_MASK + 0x1016)
+#define HDMITX_DWC_FC_AVICONF3                  (DWC_OFFSET_MASK + 0x1017)
+#define HDMITX_DWC_FC_GCP                       (DWC_OFFSET_MASK + 0x1018)
+#define HDMITX_DWC_FC_AVICONF0                  (DWC_OFFSET_MASK + 0x1019)
+#define HDMITX_DWC_FC_AVICONF1                  (DWC_OFFSET_MASK + 0x101A)
+#define HDMITX_DWC_FC_AVICONF2                  (DWC_OFFSET_MASK + 0x101B)
+#define HDMITX_DWC_FC_AVIVID                    (DWC_OFFSET_MASK + 0x101C)
+#define HDMITX_DWC_FC_AVIETB0                   (DWC_OFFSET_MASK + 0x101D)
+#define HDMITX_DWC_FC_AVIETB1                   (DWC_OFFSET_MASK + 0x101E)
+#define HDMITX_DWC_FC_AVISBB0                   (DWC_OFFSET_MASK + 0x101F)
+#define HDMITX_DWC_FC_AVISBB1                   (DWC_OFFSET_MASK + 0x1020)
+#define HDMITX_DWC_FC_AVIELB0                   (DWC_OFFSET_MASK + 0x1021)
+#define HDMITX_DWC_FC_AVIELB1                   (DWC_OFFSET_MASK + 0x1022)
+#define HDMITX_DWC_FC_AVISRB0                   (DWC_OFFSET_MASK + 0x1023)
+#define HDMITX_DWC_FC_AVISRB1                   (DWC_OFFSET_MASK + 0x1024)
+#define HDMITX_DWC_FC_AUDICONF0                 (DWC_OFFSET_MASK + 0x1025)
+#define HDMITX_DWC_FC_AUDICONF1                 (DWC_OFFSET_MASK + 0x1026)
+#define HDMITX_DWC_FC_AUDICONF2                 (DWC_OFFSET_MASK + 0x1027)
+#define HDMITX_DWC_FC_AUDICONF3                 (DWC_OFFSET_MASK + 0x1028)
+#define HDMITX_DWC_FC_VSDIEEEID0                (DWC_OFFSET_MASK + 0x1029)
+#define HDMITX_DWC_FC_VSDSIZE                   (DWC_OFFSET_MASK + 0x102A)
+#define HDMITX_DWC_FC_VSDIEEEID1                (DWC_OFFSET_MASK + 0x1030)
+#define HDMITX_DWC_FC_VSDIEEEID2                (DWC_OFFSET_MASK + 0x1031)
+#define HDMITX_DWC_FC_VSDPAYLOAD0               (DWC_OFFSET_MASK + 0x1032)
+#define HDMITX_DWC_FC_VSDPAYLOAD1               (DWC_OFFSET_MASK + 0x1033)
+#define HDMITX_DWC_FC_VSDPAYLOAD2               (DWC_OFFSET_MASK + 0x1034)
+#define HDMITX_DWC_FC_VSDPAYLOAD3               (DWC_OFFSET_MASK + 0x1035)
+#define HDMITX_DWC_FC_VSDPAYLOAD4               (DWC_OFFSET_MASK + 0x1036)
+#define HDMITX_DWC_FC_VSDPAYLOAD5               (DWC_OFFSET_MASK + 0x1037)
+#define HDMITX_DWC_FC_VSDPAYLOAD6               (DWC_OFFSET_MASK + 0x1038)
+#define HDMITX_DWC_FC_VSDPAYLOAD7               (DWC_OFFSET_MASK + 0x1039)
+#define HDMITX_DWC_FC_VSDPAYLOAD8               (DWC_OFFSET_MASK + 0x103A)
+#define HDMITX_DWC_FC_VSDPAYLOAD9               (DWC_OFFSET_MASK + 0x103B)
+#define HDMITX_DWC_FC_VSDPAYLOAD10              (DWC_OFFSET_MASK + 0x103C)
+#define HDMITX_DWC_FC_VSDPAYLOAD11              (DWC_OFFSET_MASK + 0x103D)
+#define HDMITX_DWC_FC_VSDPAYLOAD12              (DWC_OFFSET_MASK + 0x103E)
+#define HDMITX_DWC_FC_VSDPAYLOAD13              (DWC_OFFSET_MASK + 0x103F)
+#define HDMITX_DWC_FC_VSDPAYLOAD14              (DWC_OFFSET_MASK + 0x1040)
+#define HDMITX_DWC_FC_VSDPAYLOAD15              (DWC_OFFSET_MASK + 0x1041)
+#define HDMITX_DWC_FC_VSDPAYLOAD16              (DWC_OFFSET_MASK + 0x1042)
+#define HDMITX_DWC_FC_VSDPAYLOAD17              (DWC_OFFSET_MASK + 0x1043)
+#define HDMITX_DWC_FC_VSDPAYLOAD18              (DWC_OFFSET_MASK + 0x1044)
+#define HDMITX_DWC_FC_VSDPAYLOAD19              (DWC_OFFSET_MASK + 0x1045)
+#define HDMITX_DWC_FC_VSDPAYLOAD20              (DWC_OFFSET_MASK + 0x1046)
+#define HDMITX_DWC_FC_VSDPAYLOAD21              (DWC_OFFSET_MASK + 0x1047)
+#define HDMITX_DWC_FC_VSDPAYLOAD22              (DWC_OFFSET_MASK + 0x1048)
+#define HDMITX_DWC_FC_VSDPAYLOAD23              (DWC_OFFSET_MASK + 0x1049)
+#define HDMITX_DWC_FC_SPDVENDORNAME0            (DWC_OFFSET_MASK + 0x104A)
+#define HDMITX_DWC_FC_SPDVENDORNAME1            (DWC_OFFSET_MASK + 0x104B)
+#define HDMITX_DWC_FC_SPDVENDORNAME2            (DWC_OFFSET_MASK + 0x104C)
+#define HDMITX_DWC_FC_SPDVENDORNAME3            (DWC_OFFSET_MASK + 0x104D)
+#define HDMITX_DWC_FC_SPDVENDORNAME4            (DWC_OFFSET_MASK + 0x104E)
+#define HDMITX_DWC_FC_SPDVENDORNAME5            (DWC_OFFSET_MASK + 0x104F)
+#define HDMITX_DWC_FC_SPDVENDORNAME6            (DWC_OFFSET_MASK + 0x1050)
+#define HDMITX_DWC_FC_SPDVENDORNAME7            (DWC_OFFSET_MASK + 0x1051)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME0           (DWC_OFFSET_MASK + 0x1052)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME1           (DWC_OFFSET_MASK + 0x1053)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME2           (DWC_OFFSET_MASK + 0x1054)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME3           (DWC_OFFSET_MASK + 0x1055)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME4           (DWC_OFFSET_MASK + 0x1056)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME5           (DWC_OFFSET_MASK + 0x1057)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME6           (DWC_OFFSET_MASK + 0x1058)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME7           (DWC_OFFSET_MASK + 0x1059)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME8           (DWC_OFFSET_MASK + 0x105A)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME9           (DWC_OFFSET_MASK + 0x105B)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME10          (DWC_OFFSET_MASK + 0x105C)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME11          (DWC_OFFSET_MASK + 0x105D)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME12          (DWC_OFFSET_MASK + 0x105E)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME13          (DWC_OFFSET_MASK + 0x105F)
+#define HDMITX_DWC_FC_SDPPRODUCTNAME14          (DWC_OFFSET_MASK + 0x1060)
+#define HDMITX_DWC_FC_SPDPRODUCTNAME15          (DWC_OFFSET_MASK + 0x1061)
+#define HDMITX_DWC_FC_SPDDEVICEINF              (DWC_OFFSET_MASK + 0x1062)
+#define HDMITX_DWC_FC_AUDSCONF                  (DWC_OFFSET_MASK + 0x1063)
+#define HDMITX_DWC_FC_AUDSSTAT                  (DWC_OFFSET_MASK + 0x1064)
+#define HDMITX_DWC_FC_AUDSV                     (DWC_OFFSET_MASK + 0x1065)
+#define HDMITX_DWC_FC_AUDSU                     (DWC_OFFSET_MASK + 0x1066)
+#define HDMITX_DWC_FC_AUDSCHNLS0                (DWC_OFFSET_MASK + 0x1067)
+#define HDMITX_DWC_FC_AUDSCHNLS1                (DWC_OFFSET_MASK + 0x1068)
+#define HDMITX_DWC_FC_AUDSCHNLS2                (DWC_OFFSET_MASK + 0x1069)
+#define HDMITX_DWC_FC_AUDSCHNLS3                (DWC_OFFSET_MASK + 0x106A)
+#define HDMITX_DWC_FC_AUDSCHNLS4                (DWC_OFFSET_MASK + 0x106B)
+#define HDMITX_DWC_FC_AUDSCHNLS5                (DWC_OFFSET_MASK + 0x106C)
+#define HDMITX_DWC_FC_AUDSCHNLS6                (DWC_OFFSET_MASK + 0x106D)
+#define HDMITX_DWC_FC_AUDSCHNLS7                (DWC_OFFSET_MASK + 0x106E)
+#define HDMITX_DWC_FC_AUDSCHNLS8                (DWC_OFFSET_MASK + 0x106F)
+#define HDMITX_DWC_FC_DATACH0FILL               (DWC_OFFSET_MASK + 0x1070)
+#define HDMITX_DWC_FC_DATACH1FILL               (DWC_OFFSET_MASK + 0x1071)
+#define HDMITX_DWC_FC_DATACH2FILL               (DWC_OFFSET_MASK + 0x1072)
+#define HDMITX_DWC_FC_CTRLQHIGH                 (DWC_OFFSET_MASK + 0x1073)
+#define HDMITX_DWC_FC_CTRLQLOW                  (DWC_OFFSET_MASK + 0x1074)
+#define HDMITX_DWC_FC_ACP0                      (DWC_OFFSET_MASK + 0x1075)
+#define HDMITX_DWC_FC_ACP16                     (DWC_OFFSET_MASK + 0x1082)
+#define HDMITX_DWC_FC_ACP15                     (DWC_OFFSET_MASK + 0x1083)
+#define HDMITX_DWC_FC_ACP14                     (DWC_OFFSET_MASK + 0x1084)
+#define HDMITX_DWC_FC_ACP13                     (DWC_OFFSET_MASK + 0x1085)
+#define HDMITX_DWC_FC_ACP12                     (DWC_OFFSET_MASK + 0x1086)
+#define HDMITX_DWC_FC_ACP11                     (DWC_OFFSET_MASK + 0x1087)
+#define HDMITX_DWC_FC_ACP10                     (DWC_OFFSET_MASK + 0x1088)
+#define HDMITX_DWC_FC_ACP9                      (DWC_OFFSET_MASK + 0x1089)
+#define HDMITX_DWC_FC_ACP8                      (DWC_OFFSET_MASK + 0x108A)
+#define HDMITX_DWC_FC_ACP7                      (DWC_OFFSET_MASK + 0x108B)
+#define HDMITX_DWC_FC_ACP6                      (DWC_OFFSET_MASK + 0x108C)
+#define HDMITX_DWC_FC_ACP5                      (DWC_OFFSET_MASK + 0x108D)
+#define HDMITX_DWC_FC_ACP4                      (DWC_OFFSET_MASK + 0x108E)
+#define HDMITX_DWC_FC_ACP3                      (DWC_OFFSET_MASK + 0x108F)
+#define HDMITX_DWC_FC_ACP2                      (DWC_OFFSET_MASK + 0x1090)
+#define HDMITX_DWC_FC_ACP1                      (DWC_OFFSET_MASK + 0x1091)
+#define HDMITX_DWC_FC_ISCR1_0                   (DWC_OFFSET_MASK + 0x1092)
+#define HDMITX_DWC_FC_ISCR1_16                  (DWC_OFFSET_MASK + 0x1093)
+#define HDMITX_DWC_FC_ISCR1_15                  (DWC_OFFSET_MASK + 0x1094)
+#define HDMITX_DWC_FC_ISCR1_14                  (DWC_OFFSET_MASK + 0x1095)
+#define HDMITX_DWC_FC_ISCR1_13                  (DWC_OFFSET_MASK + 0x1096)
+#define HDMITX_DWC_FC_ISCR1_12                  (DWC_OFFSET_MASK + 0x1097)
+#define HDMITX_DWC_FC_ISCR1_11                  (DWC_OFFSET_MASK + 0x1098)
+#define HDMITX_DWC_FC_ISCR1_10                  (DWC_OFFSET_MASK + 0x1099)
+#define HDMITX_DWC_FC_ISCR1_9                   (DWC_OFFSET_MASK + 0x109A)
+#define HDMITX_DWC_FC_ISCR1_8                   (DWC_OFFSET_MASK + 0x109B)
+#define HDMITX_DWC_FC_ISCR1_7                   (DWC_OFFSET_MASK + 0x109C)
+#define HDMITX_DWC_FC_ISCR1_6                   (DWC_OFFSET_MASK + 0x109D)
+#define HDMITX_DWC_FC_ISCR1_5                   (DWC_OFFSET_MASK + 0x109E)
+#define HDMITX_DWC_FC_ISCR1_4                   (DWC_OFFSET_MASK + 0x109F)
+#define HDMITX_DWC_FC_ISCR1_3                   (DWC_OFFSET_MASK + 0x10A0)
+#define HDMITX_DWC_FC_ISCR1_2                   (DWC_OFFSET_MASK + 0x10A1)
+#define HDMITX_DWC_FC_ISCR1_1                   (DWC_OFFSET_MASK + 0x10A2)
+#define HDMITX_DWC_FC_ISCR0_15                  (DWC_OFFSET_MASK + 0x10A3)
+#define HDMITX_DWC_FC_ISCR0_14                  (DWC_OFFSET_MASK + 0x10A4)
+#define HDMITX_DWC_FC_ISCR0_13                  (DWC_OFFSET_MASK + 0x10A5)
+#define HDMITX_DWC_FC_ISCR0_12                  (DWC_OFFSET_MASK + 0x10A6)
+#define HDMITX_DWC_FC_ISCR0_11                  (DWC_OFFSET_MASK + 0x10A7)
+#define HDMITX_DWC_FC_ISCR0_10                  (DWC_OFFSET_MASK + 0x10A8)
+#define HDMITX_DWC_FC_ISCR0_9                   (DWC_OFFSET_MASK + 0x10A9)
+#define HDMITX_DWC_FC_ISCR0_8                   (DWC_OFFSET_MASK + 0x10AA)
+#define HDMITX_DWC_FC_ISCR0_7                   (DWC_OFFSET_MASK + 0x10AB)
+#define HDMITX_DWC_FC_ISCR0_6                   (DWC_OFFSET_MASK + 0x10AC)
+#define HDMITX_DWC_FC_ISCR0_5                   (DWC_OFFSET_MASK + 0x10AD)
+#define HDMITX_DWC_FC_ISCR0_4                   (DWC_OFFSET_MASK + 0x10AE)
+#define HDMITX_DWC_FC_ISCR0_3                   (DWC_OFFSET_MASK + 0x10AF)
+#define HDMITX_DWC_FC_ISCR0_2                   (DWC_OFFSET_MASK + 0x10B0)
+#define HDMITX_DWC_FC_ISCR0_1                   (DWC_OFFSET_MASK + 0x10B1)
+#define HDMITX_DWC_FC_ISCR0_0                   (DWC_OFFSET_MASK + 0x10B2)
+#define HDMITX_DWC_FC_DATAUTO0                  (DWC_OFFSET_MASK + 0x10B3)
+#define HDMITX_DWC_FC_DATAUTO1                  (DWC_OFFSET_MASK + 0x10B4)
+#define HDMITX_DWC_FC_DATAUTO2                  (DWC_OFFSET_MASK + 0x10B5)
+#define HDMITX_DWC_FC_DATMAN                    (DWC_OFFSET_MASK + 0x10B6)
+#define HDMITX_DWC_FC_DATAUTO3                  (DWC_OFFSET_MASK + 0x10B7)
+#define HDMITX_DWC_FC_RDRB0                     (DWC_OFFSET_MASK + 0x10B8)
+#define HDMITX_DWC_FC_RDRB1                     (DWC_OFFSET_MASK + 0x10B9)
+#define HDMITX_DWC_FC_RDRB2                     (DWC_OFFSET_MASK + 0x10BA)
+#define HDMITX_DWC_FC_RDRB3                     (DWC_OFFSET_MASK + 0x10BB)
+#define HDMITX_DWC_FC_RDRB4                     (DWC_OFFSET_MASK + 0x10BC)
+#define HDMITX_DWC_FC_RDRB5                     (DWC_OFFSET_MASK + 0x10BD)
+#define HDMITX_DWC_FC_RDRB6                     (DWC_OFFSET_MASK + 0x10BE)
+#define HDMITX_DWC_FC_RDRB7                     (DWC_OFFSET_MASK + 0x10BF)
+#define HDMITX_DWC_FC_MASK0                     (DWC_OFFSET_MASK + 0x10D2)
+#define HDMITX_DWC_FC_MASK1                     (DWC_OFFSET_MASK + 0x10D6)
+#define HDMITX_DWC_FC_MASK2                     (DWC_OFFSET_MASK + 0x10DA)
+#define HDMITX_DWC_FC_PRCONF                    (DWC_OFFSET_MASK + 0x10E0)
+#define HDMITX_DWC_FC_SCRAMBLER_CTRL            (DWC_OFFSET_MASK + 0x10E1)
+
+#define HDMITX_DWC_FC_GMD_STAT                  (DWC_OFFSET_MASK + 0x1100)
+#define HDMITX_DWC_FC_GMD_EN                    (DWC_OFFSET_MASK + 0x1101)
+#define HDMITX_DWC_FC_GMD_UP                    (DWC_OFFSET_MASK + 0x1102)
+#define HDMITX_DWC_FC_GMD_CONF                  (DWC_OFFSET_MASK + 0x1103)
+#define HDMITX_DWC_FC_GMD_HB                    (DWC_OFFSET_MASK + 0x1104)
+#define HDMITX_DWC_FC_GMD_PB0                   (DWC_OFFSET_MASK + 0x1105)
+#define HDMITX_DWC_FC_GMD_PB1                   (DWC_OFFSET_MASK + 0x1106)
+#define HDMITX_DWC_FC_GMD_PB2                   (DWC_OFFSET_MASK + 0x1107)
+#define HDMITX_DWC_FC_GMD_PB3                   (DWC_OFFSET_MASK + 0x1108)
+#define HDMITX_DWC_FC_GMD_PB4                   (DWC_OFFSET_MASK + 0x1109)
+#define HDMITX_DWC_FC_GMD_PB5                   (DWC_OFFSET_MASK + 0x110A)
+#define HDMITX_DWC_FC_GMD_PB6                   (DWC_OFFSET_MASK + 0x110B)
+#define HDMITX_DWC_FC_GMD_PB7                   (DWC_OFFSET_MASK + 0x110C)
+#define HDMITX_DWC_FC_GMD_PB8                   (DWC_OFFSET_MASK + 0x110D)
+#define HDMITX_DWC_FC_GMD_PB9                   (DWC_OFFSET_MASK + 0x110E)
+#define HDMITX_DWC_FC_GMD_PB10                  (DWC_OFFSET_MASK + 0x110F)
+#define HDMITX_DWC_FC_GMD_PB11                  (DWC_OFFSET_MASK + 0x1110)
+#define HDMITX_DWC_FC_GMD_PB12                  (DWC_OFFSET_MASK + 0x1111)
+#define HDMITX_DWC_FC_GMD_PB13                  (DWC_OFFSET_MASK + 0x1112)
+#define HDMITX_DWC_FC_GMD_PB14                  (DWC_OFFSET_MASK + 0x1113)
+#define HDMITX_DWC_FC_GMD_PB15                  (DWC_OFFSET_MASK + 0x1114)
+#define HDMITX_DWC_FC_GMD_PB16                  (DWC_OFFSET_MASK + 0x1115)
+#define HDMITX_DWC_FC_GMD_PB17                  (DWC_OFFSET_MASK + 0x1116)
+#define HDMITX_DWC_FC_GMD_PB18                  (DWC_OFFSET_MASK + 0x1117)
+#define HDMITX_DWC_FC_GMD_PB19                  (DWC_OFFSET_MASK + 0x1118)
+#define HDMITX_DWC_FC_GMD_PB20                  (DWC_OFFSET_MASK + 0x1119)
+#define HDMITX_DWC_FC_GMD_PB21                  (DWC_OFFSET_MASK + 0x111A)
+#define HDMITX_DWC_FC_GMD_PB22                  (DWC_OFFSET_MASK + 0x111B)
+#define HDMITX_DWC_FC_GMD_PB23                  (DWC_OFFSET_MASK + 0x111C)
+#define HDMITX_DWC_FC_GMD_PB24                  (DWC_OFFSET_MASK + 0x111D)
+#define HDMITX_DWC_FC_GMD_PB25                  (DWC_OFFSET_MASK + 0x111E)
+#define HDMITX_DWC_FC_GMD_PB26                  (DWC_OFFSET_MASK + 0x111F)
+#define HDMITX_DWC_FC_GMD_PB27                  (DWC_OFFSET_MASK + 0x1120)
+
+#define HDMITX_DWC_FC_DBGFORCE                  (DWC_OFFSET_MASK + 0x1200)
+#define HDMITX_DWC_FC_DBGAUD0CH0                (DWC_OFFSET_MASK + 0x1201)
+#define HDMITX_DWC_FC_DBGAUD1CH0                (DWC_OFFSET_MASK + 0x1202)
+#define HDMITX_DWC_FC_DBGAUD2CH0                (DWC_OFFSET_MASK + 0x1203)
+#define HDMITX_DWC_FC_DBGAUD0CH1                (DWC_OFFSET_MASK + 0x1204)
+#define HDMITX_DWC_FC_DBGAUD1CH1                (DWC_OFFSET_MASK + 0x1205)
+#define HDMITX_DWC_FC_DBGAUD2CH1                (DWC_OFFSET_MASK + 0x1206)
+#define HDMITX_DWC_FC_DBGAUD0CH2                (DWC_OFFSET_MASK + 0x1207)
+#define HDMITX_DWC_FC_DBGAUD1CH2                (DWC_OFFSET_MASK + 0x1208)
+#define HDMITX_DWC_FC_DBGAUD2CH2                (DWC_OFFSET_MASK + 0x1209)
+#define HDMITX_DWC_FC_DBGAUD0CH3                (DWC_OFFSET_MASK + 0x120A)
+#define HDMITX_DWC_FC_DBGAUD1CH3                (DWC_OFFSET_MASK + 0x120B)
+#define HDMITX_DWC_FC_DBGAUD2CH3                (DWC_OFFSET_MASK + 0x120C)
+#define HDMITX_DWC_FC_DBGAUD0CH4                (DWC_OFFSET_MASK + 0x120D)
+#define HDMITX_DWC_FC_DBGAUD1CH4                (DWC_OFFSET_MASK + 0x120E)
+#define HDMITX_DWC_FC_DBGAUD2CH4                (DWC_OFFSET_MASK + 0x120F)
+#define HDMITX_DWC_FC_DBGAUD0CH5                (DWC_OFFSET_MASK + 0x1210)
+#define HDMITX_DWC_FC_DBGAUD1CH5                (DWC_OFFSET_MASK + 0x1211)
+#define HDMITX_DWC_FC_DBGAUD2CH5                (DWC_OFFSET_MASK + 0x1212)
+#define HDMITX_DWC_FC_DBGAUD0CH6                (DWC_OFFSET_MASK + 0x1213)
+#define HDMITX_DWC_FC_DBGAUD1CH6                (DWC_OFFSET_MASK + 0x1214)
+#define HDMITX_DWC_FC_DBGAUD2CH6                (DWC_OFFSET_MASK + 0x1215)
+#define HDMITX_DWC_FC_DBGAUD0CH7                (DWC_OFFSET_MASK + 0x1216)
+#define HDMITX_DWC_FC_DBGAUD1CH7                (DWC_OFFSET_MASK + 0x1217)
+#define HDMITX_DWC_FC_DBGAUD2CH7                (DWC_OFFSET_MASK + 0x1218)
+#define HDMITX_DWC_FC_DBGTMDS0                  (DWC_OFFSET_MASK + 0x1219)
+#define HDMITX_DWC_FC_DBGTMDS1                  (DWC_OFFSET_MASK + 0x121A)
+#define HDMITX_DWC_FC_DBGTMDS2                  (DWC_OFFSET_MASK + 0x121B)
+
+// HDMI Source PHY Registers
+#define HDMITX_DWC_PHY_CONF0                    (DWC_OFFSET_MASK + 0x3000)
+#define HDMITX_DWC_PHY_TST0                     (DWC_OFFSET_MASK + 0x3001)
+#define HDMITX_DWC_PHY_TST1                     (DWC_OFFSET_MASK + 0x3002)
+#define HDMITX_DWC_PHY_TST2                     (DWC_OFFSET_MASK + 0x3003)
+#define HDMITX_DWC_PHY_STAT0                    (DWC_OFFSET_MASK + 0x3004)
+#define HDMITX_DWC_PHY_INT0                     (DWC_OFFSET_MASK + 0x3005)
+#define HDMITX_DWC_PHY_MASK0                    (DWC_OFFSET_MASK + 0x3006)
+#define HDMITX_DWC_PHY_POL0                     (DWC_OFFSET_MASK + 0x3007)
+
+// I2C Master PHY Registers
+#define HDMITX_DWC_I2CM_PHY_SLAVE               (DWC_OFFSET_MASK + 0x3020)
+#define HDMITX_DWC_I2CM_PHY_ADDRESS             (DWC_OFFSET_MASK + 0x3021)
+#define HDMITX_DWC_I2CM_PHY_DATAO_1             (DWC_OFFSET_MASK + 0x3022)
+#define HDMITX_DWC_I2CM_PHY_DATAO_0             (DWC_OFFSET_MASK + 0x3023)
+#define HDMITX_DWC_I2CM_PHY_DATAI_1             (DWC_OFFSET_MASK + 0x3024)
+#define HDMITX_DWC_I2CM_PHY_DATAI_0             (DWC_OFFSET_MASK + 0x3025)
+#define HDMITX_DWC_I2CM_PHY_OPERATION           (DWC_OFFSET_MASK + 0x3026)
+#define HDMITX_DWC_I2CM_PHY_INT                 (DWC_OFFSET_MASK + 0x3027)
+#define HDMITX_DWC_I2CM_PHY_CTLINT              (DWC_OFFSET_MASK + 0x3028)
+#define HDMITX_DWC_I2CM_PHY_DIV                 (DWC_OFFSET_MASK + 0x3029)
+#define HDMITX_DWC_I2CM_PHY_SOFTRSTZ            (DWC_OFFSET_MASK + 0x302A)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302B)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x302C)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x302D)
+#define HDMITX_DWC_I2CM_PHY_SS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x302E)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_1       (DWC_OFFSET_MASK + 0x302F)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_HCNT_0       (DWC_OFFSET_MASK + 0x3030)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_1       (DWC_OFFSET_MASK + 0x3031)
+#define HDMITX_DWC_I2CM_PHY_FS_SCL_LCNT_0       (DWC_OFFSET_MASK + 0x3032)
+#define HDMITX_DWC_I2CM_PHY_SDA_HOLD            (DWC_OFFSET_MASK + 0x3033)
+
+// Audio Sampler Registers
+#define HDMITX_DWC_AUD_CONF0                    (DWC_OFFSET_MASK + 0x3100)
+#define HDMITX_DWC_AUD_CONF1                    (DWC_OFFSET_MASK + 0x3101)
+#define HDMITX_DWC_AUD_INT                      (DWC_OFFSET_MASK + 0x3102)
+#define HDMITX_DWC_AUD_CONF2                    (DWC_OFFSET_MASK + 0x3103)
+#define HDMITX_DWC_AUD_INT1                     (DWC_OFFSET_MASK + 0x3104)
+
+#define HDMITX_DWC_AUD_N1                       (DWC_OFFSET_MASK + 0x3200)
+#define HDMITX_DWC_AUD_N2                       (DWC_OFFSET_MASK + 0x3201)
+#define HDMITX_DWC_AUD_N3                       (DWC_OFFSET_MASK + 0x3202)
+#define HDMITX_DWC_AUD_CTS1                     (DWC_OFFSET_MASK + 0x3203)
+#define HDMITX_DWC_AUD_CTS2                     (DWC_OFFSET_MASK + 0x3204)
+#define HDMITX_DWC_AUD_CTS3                     (DWC_OFFSET_MASK + 0x3205)
+#define HDMITX_DWC_AUD_INPUTCLKFS               (DWC_OFFSET_MASK + 0x3206)
+
+#define HDMITX_DWC_AUD_SPDIF0                   (DWC_OFFSET_MASK + 0x3300)
+#define HDMITX_DWC_AUD_SPDIF1                   (DWC_OFFSET_MASK + 0x3301)
+#define HDMITX_DWC_AUD_SPDIFINT                 (DWC_OFFSET_MASK + 0x3302)
+#define HDMITX_DWC_AUD_SPDIFINT1                (DWC_OFFSET_MASK + 0x3303)
+
+// Generic Parallel Audio Interface Registers   (DWC_OFFSET_MASK + 0x3500)
+// Audio DMA Registers                          (DWC_OFFSET_MASK + 0x3600)
+
+// Main Controller Registers
+#define HDMITX_DWC_MC_CLKDIS                    (DWC_OFFSET_MASK + 0x4001)
+#define HDMITX_DWC_MC_SWRSTZREQ                 (DWC_OFFSET_MASK + 0x4002)
+#define HDMITX_DWC_MC_OPCTRL                    (DWC_OFFSET_MASK + 0x4003)
+#define HDMITX_DWC_MC_FLOWCTRL                  (DWC_OFFSET_MASK + 0x4004)
+#define HDMITX_DWC_MC_PHYRSTZ                   (DWC_OFFSET_MASK + 0x4005)
+#define HDMITX_DWC_MC_LOCKONCLOCK               (DWC_OFFSET_MASK + 0x4006)
+
+// Color Space Converter Registers
+#define HDMITX_DWC_CSC_CFG                      (DWC_OFFSET_MASK + 0x4100)
+#define HDMITX_DWC_CSC_SCALE                    (DWC_OFFSET_MASK + 0x4101)
+#define HDMITX_DWC_CSC_COEF_A1_MSB              (DWC_OFFSET_MASK + 0x4102)
+#define HDMITX_DWC_CSC_COEF_A1_LSB              (DWC_OFFSET_MASK + 0x4103)
+#define HDMITX_DWC_CSC_COEF_A2_MSB              (DWC_OFFSET_MASK + 0x4104)
+#define HDMITX_DWC_CSC_COEF_A2_LSB              (DWC_OFFSET_MASK + 0x4105)
+#define HDMITX_DWC_CSC_COEF_A3_MSB              (DWC_OFFSET_MASK + 0x4106)
+#define HDMITX_DWC_CSC_COEF_A3_LSB              (DWC_OFFSET_MASK + 0x4107)
+#define HDMITX_DWC_CSC_COEF_A4_MSB              (DWC_OFFSET_MASK + 0x4108)
+#define HDMITX_DWC_CSC_COEF_A4_LSB              (DWC_OFFSET_MASK + 0x4109)
+#define HDMITX_DWC_CSC_COEF_B1_MSB              (DWC_OFFSET_MASK + 0x410A)
+#define HDMITX_DWC_CSC_COEF_B1_LSB              (DWC_OFFSET_MASK + 0x410B)
+#define HDMITX_DWC_CSC_COEF_B2_MSB              (DWC_OFFSET_MASK + 0x410C)
+#define HDMITX_DWC_CSC_COEF_B2_LSB              (DWC_OFFSET_MASK + 0x410D)
+#define HDMITX_DWC_CSC_COEF_B3_MSB              (DWC_OFFSET_MASK + 0x410E)
+#define HDMITX_DWC_CSC_COEF_B3_LSB              (DWC_OFFSET_MASK + 0x410F)
+#define HDMITX_DWC_CSC_COEF_B4_MSB              (DWC_OFFSET_MASK + 0x4110)
+#define HDMITX_DWC_CSC_COEF_B4_LSB              (DWC_OFFSET_MASK + 0x4111)
+#define HDMITX_DWC_CSC_COEF_C1_MSB              (DWC_OFFSET_MASK + 0x4112)
+#define HDMITX_DWC_CSC_COEF_C1_LSB              (DWC_OFFSET_MASK + 0x4113)
+#define HDMITX_DWC_CSC_COEF_C2_MSB              (DWC_OFFSET_MASK + 0x4114)
+#define HDMITX_DWC_CSC_COEF_C2_LSB              (DWC_OFFSET_MASK + 0x4115)
+#define HDMITX_DWC_CSC_COEF_C3_MSB              (DWC_OFFSET_MASK + 0x4116)
+#define HDMITX_DWC_CSC_COEF_C3_LSB              (DWC_OFFSET_MASK + 0x4117)
+#define HDMITX_DWC_CSC_COEF_C4_MSB              (DWC_OFFSET_MASK + 0x4118)
+#define HDMITX_DWC_CSC_COEF_C4_LSB              (DWC_OFFSET_MASK + 0x4119)
+#define HDMITX_DWC_CSC_SPARE1                   (DWC_OFFSET_MASK + 0x411A)
+#define HDMITX_DWC_CSC_SPARE2                   (DWC_OFFSET_MASK + 0x411B)
+
+// HDCP Encryption Engine Registers
+#define HDMITX_DWC_A_HDCPCFG0                   (DWC_OFFSET_MASK + 0x5000)
+#define HDMITX_DWC_A_HDCPCFG1                   (DWC_OFFSET_MASK + 0x5001)
+#define HDMITX_DWC_A_HDCPOBS0                   (DWC_OFFSET_MASK + 0x5002)
+#define HDMITX_DWC_A_HDCPOBS1                   (DWC_OFFSET_MASK + 0x5003)
+#define HDMITX_DWC_A_HDCPOBS2                   (DWC_OFFSET_MASK + 0x5004)
+#define HDMITX_DWC_A_HDCPOBS3                   (DWC_OFFSET_MASK + 0x5005)
+#define HDMITX_DWC_A_APIINTCLR                  (DWC_OFFSET_MASK + 0x5006)
+#define HDMITX_DWC_A_APIINTSTAT                 (DWC_OFFSET_MASK + 0x5007)
+#define HDMITX_DWC_A_APIINTMSK                  (DWC_OFFSET_MASK + 0x5008)
+#define HDMITX_DWC_A_VIDPOLCFG                  (DWC_OFFSET_MASK + 0x5009)
+#define HDMITX_DWC_A_OESSWCFG                   (DWC_OFFSET_MASK + 0x500A)
+#define HDMITX_DWC_A_COREVERLSB                 (DWC_OFFSET_MASK + 0x5014)
+#define HDMITX_DWC_A_COREVERMSB                 (DWC_OFFSET_MASK + 0x5015)
+#define HDMITX_DWC_A_KSVMEMCTRL                 (DWC_OFFSET_MASK + 0x5016)
+
+#define HDMITX_DWC_HDCP_BSTATUS_0               (DWC_OFFSET_MASK + 0x5020)
+#define HDMITX_DWC_HDCP_BSTATUS_1               (DWC_OFFSET_MASK + 0x5021)
+#define HDMITX_DWC_HDCP_M0_0                    (DWC_OFFSET_MASK + 0x5022)
+#define HDMITX_DWC_HDCP_M0_1                    (DWC_OFFSET_MASK + 0x5023)
+#define HDMITX_DWC_HDCP_M0_2                    (DWC_OFFSET_MASK + 0x5024)
+#define HDMITX_DWC_HDCP_M0_3                    (DWC_OFFSET_MASK + 0x5025)
+#define HDMITX_DWC_HDCP_M0_4                    (DWC_OFFSET_MASK + 0x5026)
+#define HDMITX_DWC_HDCP_M0_5                    (DWC_OFFSET_MASK + 0x5027)
+#define HDMITX_DWC_HDCP_M0_6                    (DWC_OFFSET_MASK + 0x5028)
+#define HDMITX_DWC_HDCP_M0_7                    (DWC_OFFSET_MASK + 0x5029)
+#define HDMITX_DWC_HDCP_KSV                     (DWC_OFFSET_MASK + 0x502A)
+#define HDMITX_DWC_HDCP_VH                      (DWC_OFFSET_MASK + 0x52A5)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_0            (DWC_OFFSET_MASK + 0x52B9)
+#define HDMITX_DWC_HDCP_REVOC_SIZE_1            (DWC_OFFSET_MASK + 0x52BA)
+#define HDMITX_DWC_HDCP_REVOC_LIST              (DWC_OFFSET_MASK + 0x52BB)
+
+// HDCP BKSV Registers
+#define HDMITX_DWC_HDCPREG_BKSV0                (DWC_OFFSET_MASK + 0x7800)
+#define HDMITX_DWC_HDCPREG_BKSV1                (DWC_OFFSET_MASK + 0x7801)
+#define HDMITX_DWC_HDCPREG_BKSV2                (DWC_OFFSET_MASK + 0x7802)
+#define HDMITX_DWC_HDCPREG_BKSV3                (DWC_OFFSET_MASK + 0x7803)
+#define HDMITX_DWC_HDCPREG_BKSV4                (DWC_OFFSET_MASK + 0x7804)
+
+// HDCP AN Registers
+#define HDMITX_DWC_HDCPREG_ANCONF               (DWC_OFFSET_MASK + 0x7805)
+#define HDMITX_DWC_HDCPREG_AN0                  (DWC_OFFSET_MASK + 0x7806)
+#define HDMITX_DWC_HDCPREG_AN1                  (DWC_OFFSET_MASK + 0x7807)
+#define HDMITX_DWC_HDCPREG_AN2                  (DWC_OFFSET_MASK + 0x7808)
+#define HDMITX_DWC_HDCPREG_AN3                  (DWC_OFFSET_MASK + 0x7809)
+#define HDMITX_DWC_HDCPREG_AN4                  (DWC_OFFSET_MASK + 0x780A)
+#define HDMITX_DWC_HDCPREG_AN5                  (DWC_OFFSET_MASK + 0x780B)
+#define HDMITX_DWC_HDCPREG_AN6                  (DWC_OFFSET_MASK + 0x780C)
+#define HDMITX_DWC_HDCPREG_AN7                  (DWC_OFFSET_MASK + 0x780D)
+#define HDMITX_DWC_HDCPREG_RMLCTL               (DWC_OFFSET_MASK + 0x780E)
+
+// Encrypted DPK Embedded Storage Registers
+#define HDMITX_DWC_HDCPREG_RMLSTS               (DWC_OFFSET_MASK + 0x780F)
+#define HDMITX_DWC_HDCPREG_SEED0                (DWC_OFFSET_MASK + 0x7810)
+#define HDMITX_DWC_HDCPREG_SEED1                (DWC_OFFSET_MASK + 0x7811)
+#define HDMITX_DWC_HDCPREG_DPK0                 (DWC_OFFSET_MASK + 0x7812)
+#define HDMITX_DWC_HDCPREG_DPK1                 (DWC_OFFSET_MASK + 0x7813)
+#define HDMITX_DWC_HDCPREG_DPK2                 (DWC_OFFSET_MASK + 0x7814)
+#define HDMITX_DWC_HDCPREG_DPK3                 (DWC_OFFSET_MASK + 0x7815)
+#define HDMITX_DWC_HDCPREG_DPK4                 (DWC_OFFSET_MASK + 0x7816)
+#define HDMITX_DWC_HDCPREG_DPK5                 (DWC_OFFSET_MASK + 0x7817)
+#define HDMITX_DWC_HDCPREG_DPK6                 (DWC_OFFSET_MASK + 0x7818)
+
+// CEC Engine Registers
+#define HDMITX_DWC_CEC_CTRL                     (DWC_OFFSET_MASK + 0x7D00)
+#define HDMITX_DWC_CEC_INTR_MASK                (DWC_OFFSET_MASK + 0x7D02)
+#define HDMITX_DWC_CEC_LADD_LOW                 (DWC_OFFSET_MASK + 0x7D05)
+#define HDMITX_DWC_CEC_LADD_HIGH                (DWC_OFFSET_MASK + 0x7D06)
+#define HDMITX_DWC_CEC_TX_CNT                   (DWC_OFFSET_MASK + 0x7D07)
+#define HDMITX_DWC_CEC_RX_CNT                   (DWC_OFFSET_MASK + 0x7D08)
+#define HDMITX_DWC_CEC_TX_DATA00                (DWC_OFFSET_MASK + 0x7D10)
+#define HDMITX_DWC_CEC_TX_DATA01                (DWC_OFFSET_MASK + 0x7D11)
+#define HDMITX_DWC_CEC_TX_DATA02                (DWC_OFFSET_MASK + 0x7D12)
+#define HDMITX_DWC_CEC_TX_DATA03                (DWC_OFFSET_MASK + 0x7D13)
+#define HDMITX_DWC_CEC_TX_DATA04                (DWC_OFFSET_MASK + 0x7D14)
+#define HDMITX_DWC_CEC_TX_DATA05                (DWC_OFFSET_MASK + 0x7D15)
+#define HDMITX_DWC_CEC_TX_DATA06                (DWC_OFFSET_MASK + 0x7D16)
+#define HDMITX_DWC_CEC_TX_DATA07                (DWC_OFFSET_MASK + 0x7D17)
+#define HDMITX_DWC_CEC_TX_DATA08                (DWC_OFFSET_MASK + 0x7D18)
+#define HDMITX_DWC_CEC_TX_DATA09                (DWC_OFFSET_MASK + 0x7D19)
+#define HDMITX_DWC_CEC_TX_DATA10                (DWC_OFFSET_MASK + 0x7D1A)
+#define HDMITX_DWC_CEC_TX_DATA11                (DWC_OFFSET_MASK + 0x7D1B)
+#define HDMITX_DWC_CEC_TX_DATA12                (DWC_OFFSET_MASK + 0x7D1C)
+#define HDMITX_DWC_CEC_TX_DATA13                (DWC_OFFSET_MASK + 0x7D1D)
+#define HDMITX_DWC_CEC_TX_DATA14                (DWC_OFFSET_MASK + 0x7D1E)
+#define HDMITX_DWC_CEC_TX_DATA15                (DWC_OFFSET_MASK + 0x7D1F)
+#define HDMITX_DWC_CEC_RX_DATA00                (DWC_OFFSET_MASK + 0x7D20)
+#define HDMITX_DWC_CEC_RX_DATA01                (DWC_OFFSET_MASK + 0x7D21)
+#define HDMITX_DWC_CEC_RX_DATA02                (DWC_OFFSET_MASK + 0x7D22)
+#define HDMITX_DWC_CEC_RX_DATA03                (DWC_OFFSET_MASK + 0x7D23)
+#define HDMITX_DWC_CEC_RX_DATA04                (DWC_OFFSET_MASK + 0x7D24)
+#define HDMITX_DWC_CEC_RX_DATA05                (DWC_OFFSET_MASK + 0x7D25)
+#define HDMITX_DWC_CEC_RX_DATA06                (DWC_OFFSET_MASK + 0x7D26)
+#define HDMITX_DWC_CEC_RX_DATA07                (DWC_OFFSET_MASK + 0x7D27)
+#define HDMITX_DWC_CEC_RX_DATA08                (DWC_OFFSET_MASK + 0x7D28)
+#define HDMITX_DWC_CEC_RX_DATA09                (DWC_OFFSET_MASK + 0x7D29)
+#define HDMITX_DWC_CEC_RX_DATA10                (DWC_OFFSET_MASK + 0x7D2A)
+#define HDMITX_DWC_CEC_RX_DATA11                (DWC_OFFSET_MASK + 0x7D2B)
+#define HDMITX_DWC_CEC_RX_DATA12                (DWC_OFFSET_MASK + 0x7D2C)
+#define HDMITX_DWC_CEC_RX_DATA13                (DWC_OFFSET_MASK + 0x7D2D)
+#define HDMITX_DWC_CEC_RX_DATA14                (DWC_OFFSET_MASK + 0x7D2E)
+#define HDMITX_DWC_CEC_RX_DATA15                (DWC_OFFSET_MASK + 0x7D2F)
+#define HDMITX_DWC_CEC_LOCK_BUF                 (DWC_OFFSET_MASK + 0x7D30)
+#define HDMITX_DWC_CEC_WAKEUPCTRL               (DWC_OFFSET_MASK + 0x7D31)
+
+// I2C Master Registers(E-DDC/SCDC)
+#define HDMITX_DWC_I2CM_SLAVE                   (DWC_OFFSET_MASK + 0x7E00)
+#define HDMITX_DWC_I2CM_ADDRESS                 (DWC_OFFSET_MASK + 0x7E01)
+#define HDMITX_DWC_I2CM_DATAO                   (DWC_OFFSET_MASK + 0x7E02)
+#define HDMITX_DWC_I2CM_DATAI                   (DWC_OFFSET_MASK + 0x7E03)
+#define HDMITX_DWC_I2CM_OPERATION               (DWC_OFFSET_MASK + 0x7E04)
+#define HDMITX_DWC_I2CM_INT                     (DWC_OFFSET_MASK + 0x7E05)
+#define HDMITX_DWC_I2CM_CTLINT                  (DWC_OFFSET_MASK + 0x7E06)
+#define HDMITX_DWC_I2CM_DIV                     (DWC_OFFSET_MASK + 0x7E07)
+#define HDMITX_DWC_I2CM_SEGADDR                 (DWC_OFFSET_MASK + 0x7E08)
+#define HDMITX_DWC_I2CM_SOFTRSTZ                (DWC_OFFSET_MASK + 0x7E09)
+#define HDMITX_DWC_I2CM_SEGPTR                  (DWC_OFFSET_MASK + 0x7E0A)
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0B)
+#define HDMITX_DWC_I2CM_SS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E0C)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E0D)
+#define HDMITX_DWC_I2CM_SS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E0E)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_1           (DWC_OFFSET_MASK + 0x7E0F)
+#define HDMITX_DWC_I2CM_FS_SCL_HCNT_0           (DWC_OFFSET_MASK + 0x7E10)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_1           (DWC_OFFSET_MASK + 0x7E11)
+#define HDMITX_DWC_I2CM_FS_SCL_LCNT_0           (DWC_OFFSET_MASK + 0x7E12)
+#define HDMITX_DWC_I2CM_SDA_HOLD                (DWC_OFFSET_MASK + 0x7E13)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE             (DWC_OFFSET_MASK + 0x7E14)
+#define HDMITX_DWC_I2CM_READ_BUFF0              (DWC_OFFSET_MASK + 0x7E20)
+#define HDMITX_DWC_I2CM_READ_BUFF1              (DWC_OFFSET_MASK + 0x7E21)
+#define HDMITX_DWC_I2CM_READ_BUFF2              (DWC_OFFSET_MASK + 0x7E22)
+#define HDMITX_DWC_I2CM_READ_BUFF3              (DWC_OFFSET_MASK + 0x7E23)
+#define HDMITX_DWC_I2CM_READ_BUFF4              (DWC_OFFSET_MASK + 0x7E24)
+#define HDMITX_DWC_I2CM_READ_BUFF5              (DWC_OFFSET_MASK + 0x7E25)
+#define HDMITX_DWC_I2CM_READ_BUFF6              (DWC_OFFSET_MASK + 0x7E26)
+#define HDMITX_DWC_I2CM_READ_BUFF7              (DWC_OFFSET_MASK + 0x7E27)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE0            (DWC_OFFSET_MASK + 0x7E30)
+#define HDMITX_DWC_I2CM_SCDC_UPDATE1            (DWC_OFFSET_MASK + 0x7E31)
+
+#endif  /* HDMITX_PARAMETER_DEFINE_H */
diff --git a/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/tvenc_conf.h b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/tvenc_conf.h
new file mode 100644
index 000000000000..204eb88fe089
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/hdmi_tx_hw_20/tvenc_conf.h
@@ -0,0 +1,231 @@
+typedef struct reg_s {
+    uint reg;
+    uint val;
+} reg_t;
+
+static  reg_t hdmi_tvenc_regs_480i[] = {
+    /*1st col: recommmended, but eof/sof/vs_lines +/- 1 from spec; 2nd col: from simu */
+    {ENCP_VIDEO_MODE,             0      /*0     */  },
+    {ENCI_DE_H_BEGIN,             229    /*0xeb  */  },
+    {ENCI_DE_H_END,               1669   /*0x68b */  },
+    {ENCI_DE_V_BEGIN_EVEN,        18     /*0x11  */  },
+    {ENCI_DE_V_END_EVEN,          258    /*0x101 */  },
+    {ENCI_DE_V_BEGIN_ODD,         19     /*0x12  */  },
+    {ENCI_DE_V_END_ODD,           259    /*0x102 */  },
+    {ENCI_DVI_HSO_BEGIN,          1707   /*0x6b1 */  },
+    {ENCI_DVI_HSO_END,            115    /*0x79  */  },
+    {ENCI_DVI_VSO_BLINE_EVN,      0      /*0x105 */  },
+    {ENCI_DVI_VSO_ELINE_EVN,      2      /*0x1   */  },
+    {ENCI_DVI_VSO_BEGIN_EVN,      1707   /*0x357 */  },
+    {ENCI_DVI_VSO_END_EVN,        1707   /*0x6b1 */  },
+    {ENCI_DVI_VSO_BLINE_ODD,      0      /*0x105 */  },
+    {ENCI_DVI_VSO_BEGIN_ODD,      849    /*0x6b1 */  },
+    {ENCI_DVI_VSO_ELINE_ODD,      3      /*0x2   */  },
+    {ENCI_DVI_VSO_END_ODD,        849    /*0x357 */  },
+    {VENC_DVI_SETTING,            0x809c /*0x809c*/  },
+    {VENC_DVI_SETTING_MORE,       0x0    /*0x0   */  },
+    {0,0}
+};
+
+static  reg_t hdmi_tvenc_regs_576i[] = {
+    {ENCP_VIDEO_MODE,                    0x00004000},
+    {ENCI_DE_H_BEGIN,                    0x000000f9},
+    {ENCI_DE_H_END,                      0x00000699},
+    {ENCI_DE_V_BEGIN_EVEN,               0x00000015},
+    {ENCI_DE_V_END_EVEN,                 0x00000135},
+    {ENCI_DE_V_BEGIN_ODD,                0x00000016},
+    {ENCI_DE_V_END_ODD,                  0x00000136},
+    {ENCI_DVI_HSO_BEGIN,                 0x000006b1},
+    {ENCI_DVI_HSO_END,                   0x0000006f},
+    {ENCI_DVI_VSO_BLINE_EVN,             0x00000137},
+    {ENCI_DVI_VSO_ELINE_EVN,             0x00000001},
+    {ENCI_DVI_VSO_BEGIN_EVN,             0x00000351},
+    {ENCI_DVI_VSO_END_EVN,               0x000006b1},
+    {ENCI_DVI_VSO_BLINE_ODD,             0x00000137},
+    {ENCI_DVI_VSO_BEGIN_ODD,             0x000006b1},
+    {ENCI_DVI_VSO_ELINE_ODD,             0x00000002},
+    {ENCI_DVI_VSO_END_ODD,               0x00000351},
+    {VENC_DVI_SETTING,                   0x0000809c},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {0,0}
+};
+
+static  reg_t hdmi_tvenc_regs_1080i[] = {
+    {ENCP_VIDEO_MODE,                    0x00005ffc},
+    {ENCP_DE_H_BEGIN,                    0x00000210},
+    {ENCP_DE_H_END,                      0x00001110},
+    {ENCP_DE_V_BEGIN_EVEN,               0x00000014},
+    {ENCP_DE_V_END_EVEN,                 0x00000230},
+    {ENCP_DE_V_BEGIN_ODD,                0x00000247},
+    {ENCP_DE_V_END_ODD,                  0x00000463},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000090},
+    {ENCP_DVI_HSO_END,                   0x000000e8},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000090},
+    {ENCP_DVI_VSO_END_EVN,               0x00000090},
+    {ENCP_DVI_VSO_BLINE_ODD,             0x00000232},
+    {ENCP_DVI_VSO_ELINE_ODD,             0x00000237},
+    {ENCP_DVI_VSO_BEGIN_ODD,             0x00000928},
+    {ENCP_DVI_VSO_END_ODD,               0x00000928},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {VENC_DVI_SETTING_MORE,              0x00000000}, 
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_1080i50[] = {
+    {ENCP_VIDEO_MODE,                    0x00005ffc},
+    {ENCP_DE_H_BEGIN,                    0x00000210},
+    {ENCP_DE_H_END,                      0x00001110},
+    {ENCP_DE_V_BEGIN_EVEN,               0x00000014},
+    {ENCP_DE_V_END_EVEN,                 0x00000230},
+    {ENCP_DE_V_BEGIN_ODD,                0x00000247},
+    {ENCP_DE_V_END_ODD,                  0x00000463},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000090},
+    {ENCP_DVI_HSO_END,                   0x000000e8},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000090},
+    {ENCP_DVI_VSO_END_EVN,               0x00000090},
+    {ENCP_DVI_VSO_BLINE_ODD,             0x00000232},
+    {ENCP_DVI_VSO_ELINE_ODD,             0x00000237},
+    {ENCP_DVI_VSO_BEGIN_ODD,             0x00000ae0},
+    {ENCP_DVI_VSO_END_ODD,               0x00000ae0},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {VENC_DVI_SETTING_MORE,              0x00000000}, 
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_480p[] = {
+    {ENCP_VIDEO_MODE,                   /*0x4000 */ 0x00004000},
+    {ENCP_DE_H_BEGIN,                   /*0xdc   */ 0x000000d7},
+    {ENCP_DE_H_END,                     /*0x67c  */ 0x00000677},
+    {ENCP_DE_V_BEGIN_EVEN,              /*0x2a   */ 0x0000002b},
+    {ENCP_DE_V_END_EVEN,                /*0x2a   */ 0x0000020b},
+    {ENCP_DVI_HSO_BEGIN,                /*0x69c  */ 0x00000697},
+    {ENCP_DVI_HSO_END,                  /*0x64   */ 0x0000005f},
+    {ENCP_DVI_VSO_BLINE_EVN,            /*0x5    */ 0x00000006},
+    {ENCP_DVI_VSO_ELINE_EVN,            /*0xb    */ 0x0000000c},
+    {ENCP_DVI_VSO_BEGIN_EVN,            /*0x69c  */ 0x00000697},
+    {ENCP_DVI_VSO_END_EVN,              /*0x69c  */ 0x00000697},
+    {VENC_DVI_SETTING_MORE,             /*0x0    */ 0x00000000},
+    {VENC_DVI_SETTING,                  /*0x80ad */ 0x000080ad},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_576p[] = {
+    {ENCP_VIDEO_MODE,                    0x00004000},
+    {ENCP_DE_H_BEGIN,                    0x000000ef},
+    {ENCP_DE_H_END,                      0x0000068f},
+    {ENCP_DE_V_BEGIN_EVEN,               0x0000002d},
+    {ENCP_DE_V_END_EVEN,                 0x0000026d},
+    {ENCP_DVI_HSO_BEGIN,                 0x000006a7},
+    {ENCP_DVI_HSO_END,                   0x00000067},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x000006a7},
+    {ENCP_DVI_VSO_END_EVN,               0x000006a7},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_720p[] = {
+    {ENCP_VIDEO_MODE,                    0x00004040},
+    {ENCP_DE_H_BEGIN,                    0x0000028a},
+    {ENCP_DE_H_END,                      0x00000c8a},
+    {ENCP_DE_V_BEGIN_EVEN,               0x0000001d},
+    {ENCP_DE_V_END_EVEN,                 0x000002ed},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000082},
+    {ENCP_DVI_HSO_END,                   0x000000d2},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000004},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000009},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000082},
+    {ENCP_DVI_VSO_END_EVN,               0x00000082},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_1080p[] = {
+    {ENCP_VIDEO_MODE,                    0x00004040},
+    {ENCP_DE_H_BEGIN,                    0x00000112},
+    {ENCP_DE_H_END,                      0x00000892},
+    {ENCP_DE_V_BEGIN_EVEN,               0x00000029},
+    {ENCP_DE_V_END_EVEN,                 0x00000461},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000052},
+    {ENCP_DVI_HSO_END,                   0x0000007e},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000052},
+    {ENCP_DVI_VSO_END_EVN,               0x00000052},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x0000809d},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_720p50[] = {
+    {ENCP_VIDEO_MODE,                    0x00004040},
+    {ENCP_DE_H_BEGIN,                    0x0000028a},
+    {ENCP_DE_H_END,                      0x00000c8a},
+    {ENCP_DE_V_BEGIN_EVEN,               0x0000001d},
+    {ENCP_DE_V_END_EVEN,                 0x000002ed},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000082},
+    {ENCP_DVI_HSO_END,                   0x000000d2},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000004},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000009},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000082},
+    {ENCP_DVI_VSO_END_EVN,               0x00000082},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x000080ad},
+    {0,0}
+};    
+
+static  reg_t hdmi_tvenc_regs_1080p50[] = {
+    {ENCP_VIDEO_MODE,                    0x00004040},
+    {ENCP_DE_H_BEGIN,                    0x00000112},
+    {ENCP_DE_H_END,                      0x00000892},
+    {ENCP_DE_V_BEGIN_EVEN,               0x00000029},
+    {ENCP_DE_V_END_EVEN,                 0x00000461},
+    {ENCP_DVI_HSO_BEGIN,                 0x00000052},
+    {ENCP_DVI_HSO_END,                   0x0000007e},
+    {ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
+    {ENCP_DVI_VSO_ELINE_EVN,             0x00000005},
+    {ENCP_DVI_VSO_BEGIN_EVN,             0x00000052},
+    {ENCP_DVI_VSO_END_EVN,               0x00000052},
+    {VENC_DVI_SETTING_MORE,              0x00000000},
+    {VENC_DVI_SETTING,                   0x0000809d},
+    {0,0}
+};    
+
+typedef struct hdmi_tvenc_config_
+{
+    int vic;
+    reg_t* reg_set;
+}hdmi_tvenc_config_t;
+
+static const hdmi_tvenc_config_t hdmi_tvenc_configs[] = {
+    {HDMI_640x480p60  ,          NULL          },
+    {HDMI_480p60,                hdmi_tvenc_regs_480p},
+    {HDMI_480p60_16x9,           hdmi_tvenc_regs_480p},
+    {HDMI_720p60,                hdmi_tvenc_regs_720p},
+    {HDMI_1080i60,               hdmi_tvenc_regs_1080i},
+    {HDMI_480i60,                hdmi_tvenc_regs_480i},
+    {HDMI_480i60_16x9,           hdmi_tvenc_regs_480i},
+    {HDMI_1440x480p60  ,         NULL          },
+    {HDMI_1440x480p60_16x9  ,    NULL          },
+    {HDMI_1080p60 ,              hdmi_tvenc_regs_1080p},
+    {HDMI_576p50,                hdmi_tvenc_regs_576p},
+    {HDMI_576p50_16x9,           hdmi_tvenc_regs_576p},
+    {HDMI_720p50,                hdmi_tvenc_regs_720p50},
+    {HDMI_1080i50,               hdmi_tvenc_regs_1080i50},
+    {HDMI_576i50,                hdmi_tvenc_regs_576i},
+    {HDMI_576i50_16x9,           hdmi_tvenc_regs_576i},
+    {HDMI_1080p50 ,              hdmi_tvenc_regs_1080p50},
+    {HDMI_1080p24,               hdmi_tvenc_regs_1080p},
+    {HDMI_1080p25,               hdmi_tvenc_regs_1080p},
+    {HDMI_1080p30,               hdmi_tvenc_regs_1080p},
+    {HDMI_Unkown,               NULL},
+};
+
+
diff --git a/arch/arm/mach-mesong9tv/hw_enc_clk_config.h b/arch/arm/mach-mesong9tv/hw_enc_clk_config.h
new file mode 100644
index 000000000000..50e454200ecc
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/hw_enc_clk_config.h
@@ -0,0 +1,41 @@
+#ifndef __HW_ENC_CLK_CONFIG_H__
+#define __HW_ENC_CLK_CONFIG_H__
+
+#include <linux/amlogic/vout/enc_clk_config.h>
+
+#define CLK_UTIL_VID_PLL_DIV_1      0
+#define CLK_UTIL_VID_PLL_DIV_2      1
+#define CLK_UTIL_VID_PLL_DIV_3      2
+#define CLK_UTIL_VID_PLL_DIV_3p5    3
+#define CLK_UTIL_VID_PLL_DIV_3p75   4
+#define CLK_UTIL_VID_PLL_DIV_4      5
+#define CLK_UTIL_VID_PLL_DIV_5      6
+#define CLK_UTIL_VID_PLL_DIV_6      7
+#define CLK_UTIL_VID_PLL_DIV_6p25   8
+#define CLK_UTIL_VID_PLL_DIV_7      9
+#define CLK_UTIL_VID_PLL_DIV_7p5    10
+#define CLK_UTIL_VID_PLL_DIV_12     11
+#define CLK_UTIL_VID_PLL_DIV_14     12
+#define CLK_UTIL_VID_PLL_DIV_15     13
+#define CLK_UTIL_VID_PLL_DIV_2p5    14
+
+typedef struct{
+    vmode_t mode;
+    unsigned viu_path;
+    viu_type_e viu_type;
+    unsigned hpll_clk_out;
+    unsigned od1;
+    unsigned od2;
+    unsigned od3;
+    unsigned vid_pll_div;
+    unsigned vid_clk_div;
+    unsigned hdmi_tx_pixel_div;
+    unsigned encp_div;
+    unsigned enci_div;
+    unsigned enct_div;
+    unsigned encl_div;
+    unsigned vdac0_div;
+    unsigned vdac1_div;
+}hw_enc_clk_val_t;
+
+#endif
diff --git a/arch/arm/mach-mesong9tv/include/mach/io.h b/arch/arm/mach-mesong9tv/include/mach/io.h
old mode 100644
new mode 100755
index a94b91ac405f..febf47049e10
--- a/arch/arm/mach-mesong9tv/include/mach/io.h
+++ b/arch/arm/mach-mesong9tv/include/mach/io.h
@@ -159,6 +159,8 @@
 #define APB_REG_ADDR(reg)		(IO_APB_BUS_BASE + APB_REG_OFFSET(reg))
 #define APB_REG_ADDR_VALID(reg)		(((unsigned long)(reg) & 3) == 0)
 
+#define HDMI_TX_REG_ADDR(reg)		(IO_HDMI_PHY_BASE + reg)
+
 #define AOBUS_REG_OFFSET(reg)		((reg) )
 #define AOBUS_REG_ADDR(reg)		(IO_AOBUS_BASE + AOBUS_REG_OFFSET(reg))
 
@@ -171,4 +173,4 @@
 #define TVBUS_REG_ADDR(reg)             (IO_TV_BUS_BASE-0x8000+TVBUS_REG_OFFSET(reg))
 void meson_map_default_io(void);
 
-#endif //__MACH_MESONG9TV_IO_H
\ No newline at end of file
+#endif //__MACH_MESONG9TV_IO_H
diff --git a/arch/arm/mach-mesong9tv/include/mach/tvregs.h b/arch/arm/mach-mesong9tv/include/mach/tvregs.h
index 09649a15726e..d5a254ec502d 100644
--- a/arch/arm/mach-mesong9tv/include/mach/tvregs.h
+++ b/arch/arm/mach-mesong9tv/include/mach/tvregs.h
@@ -49,773 +49,639 @@ typedef struct tvinfo_s {
 25M
 */
 static const  reg_t tvreg_vclk_sd[]={
-	{HHI_VID_PLL_CNTL,VIDEO_CLOCK_SD_24},//SD.24
-    {HHI_VID_PLL_CNTL,VIDEO_CLOCK_SD_25},//SD,25
+//	{HHI_VID_PLL_CNTL,VIDEO_CLOCK_SD_24},//SD.24
+//    {HHI_VID_PLL_CNTL,VIDEO_CLOCK_SD_25},//SD,25
 };
 
 static const  reg_t tvreg_vclk_hd[]={
-    {HHI_VID_PLL_CNTL,VIDEO_CLOCK_HD_24},//HD,24
-    {HHI_VID_PLL_CNTL,VIDEO_CLOCK_HD_25},//HD,25
+//    {HHI_VID_PLL_CNTL,VIDEO_CLOCK_HD_24},//HD,24
+//    {HHI_VID_PLL_CNTL,VIDEO_CLOCK_HD_25},//HD,25
 };
 
 static const  reg_t tvregs_720p[] = {
-    {VENC_VDAC_SETTING,          0xff,  },
-
-    {HHI_VID_CLK_CNTL,           0x0,},
-
-    {HHI_VID_PLL_CNTL2,          0x814d3928},
-    {HHI_VID_PLL_CNTL3,          0x6b425012},
-     {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001043e,},
-    {HHI_VID_DIVIDER_CNTL,       0x00010843,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-    {HHI_HDMI_AFC_CNTL,          0x8c0000c3},
-    {ENCP_VIDEO_FILT_CTRL,       0x0052,},
-    {VENC_DVI_SETTING,           0x2029,},
-    {ENCP_VIDEO_MODE,            0x4040,},
-    {ENCP_VIDEO_MODE_ADV,        0x0019,},
-    {ENCP_VIDEO_YFP1_HTIME,      648,   },
-    {ENCP_VIDEO_YFP2_HTIME,      3207,  },
-    {ENCP_VIDEO_MAX_PXCNT,       3299,  },
-    {ENCP_VIDEO_HSPULS_BEGIN,    80,    },
-    {ENCP_VIDEO_HSPULS_END,      240,   },
-    {ENCP_VIDEO_HSPULS_SWITCH,   80,    },
-    {ENCP_VIDEO_VSPULS_BEGIN,    688,   },
-    {ENCP_VIDEO_VSPULS_END,      3248,  },
-    {ENCP_VIDEO_VSPULS_BLINE,    4,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    8,     },
-    {ENCP_VIDEO_EQPULS_BLINE,    4,     },
-    {ENCP_VIDEO_EQPULS_ELINE,    8,     },
-    {ENCP_VIDEO_HAVON_BEGIN,     648,   },
-    {ENCP_VIDEO_HAVON_END,       3207,  },
-    {ENCP_VIDEO_VAVON_BLINE,     29,    },
-    {ENCP_VIDEO_VAVON_ELINE,     748,   },
-    {ENCP_VIDEO_HSO_BEGIN,       256    },
-    {ENCP_VIDEO_HSO_END,         168,   },
-    {ENCP_VIDEO_VSO_BEGIN,       168,   },
-    {ENCP_VIDEO_VSO_END,         256,   },
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_VSO_ELINE,       5,     },
-    {ENCP_VIDEO_MAX_LNCNT,       749,   },
-    {VENC_VIDEO_PROG_MODE,       0x100, },
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_SETTING,          0,     },
-    {VENC_UPSAMPLE_CTRL0,        0x9061,},
-    {VENC_UPSAMPLE_CTRL1,        0xa061,},
-    {VENC_UPSAMPLE_CTRL2,        0xb061,},
-    {VENC_VDAC_DACSEL0,          0x0001,},
-    {VENC_VDAC_DACSEL1,          0x0001,},
-    {VENC_VDAC_DACSEL2,          0x0001,},
-    {VENC_VDAC_DACSEL3,          0x0001,},
-    {VENC_VDAC_DACSEL4,          0x0001,},
-    {VENC_VDAC_DACSEL5,          0x0001,},
-    {VPU_VIU_VENC_MUX_CTRL,      0x000a,},
-    {VENC_VDAC_FIFO_CTRL,        0x1000,},
-    {ENCP_DACSEL_0,              0x3102,},
-    {ENCP_DACSEL_1,              0x0054,},
-    {ENCP_VIDEO_EN,              1,     },
-    {ENCI_VIDEO_EN,              0,     },
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_HHI_HDMI_AFC_CNTL,          0x8c0000c3},
+    {P_ENCP_VIDEO_FILT_CTRL,       0x0052,},
+    {P_VENC_DVI_SETTING,           0x2029,},
+    {P_ENCP_VIDEO_MODE,            0x4040,},
+    {P_ENCP_VIDEO_MODE_ADV,        0x0019,},
+    {P_ENCP_VIDEO_YFP1_HTIME,      648,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      3207,  },
+    {P_ENCP_VIDEO_MAX_PXCNT,       3299,  },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    80,    },
+    {P_ENCP_VIDEO_HSPULS_END,      240,   },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   80,    },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    688,   },
+    {P_ENCP_VIDEO_VSPULS_END,      3248,  },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    4,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    8,     },
+    {P_ENCP_VIDEO_EQPULS_BLINE,    4,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    8,     },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     648,   },
+    {P_ENCP_VIDEO_HAVON_END,       3207,  },
+    {P_ENCP_VIDEO_VAVON_BLINE,     29,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     748,   },
+    {P_ENCP_VIDEO_HSO_BEGIN,       256    },
+    {P_ENCP_VIDEO_HSO_END,         168,   },
+    {P_ENCP_VIDEO_VSO_BEGIN,       168,   },
+    {P_ENCP_VIDEO_VSO_END,         256,   },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
+    {P_ENCP_VIDEO_MAX_LNCNT,       749,   },
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VENC_UPSAMPLE_CTRL0,        0x9061,},
+    {P_VENC_UPSAMPLE_CTRL1,        0xa061,},
+    {P_VENC_UPSAMPLE_CTRL2,        0xb061,},
+    {P_VENC_VDAC_DACSEL0,          0x0001,},
+    {P_VENC_VDAC_DACSEL1,          0x0001,},
+    {P_VENC_VDAC_DACSEL2,          0x0001,},
+    {P_VENC_VDAC_DACSEL3,          0x0001,},
+    {P_VENC_VDAC_DACSEL4,          0x0001,},
+    {P_VENC_VDAC_DACSEL5,          0x0001,},
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,},
+    {P_ENCP_DACSEL_0,              0x3102,},
+    {P_ENCP_DACSEL_1,              0x0054,},
+    {P_ENCP_VIDEO_EN,              1,     },
+    {P_ENCI_VIDEO_EN,              0,     },
     {MREG_END_MARKER,            0      }
 };
 
 static const  reg_t tvregs_720p_50hz[] = {
-    {VENC_VDAC_SETTING,          0xff,  },
-    {HHI_VID_CLK_CNTL,           0x0,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928},
-    {HHI_VID_PLL_CNTL3,          0x6b425012},
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001043e,},
-    {HHI_VID_DIVIDER_CNTL,       0x00010843,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-    {ENCP_VIDEO_FILT_CTRL,       0x0052,},
-
-    {VENC_DVI_SETTING,           0x202d,},
-    {ENCP_VIDEO_MAX_PXCNT,       3959,  },
-    {ENCP_VIDEO_MAX_LNCNT,       749,   },
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x0052,},
+
+    {P_VENC_DVI_SETTING,           0x202d,},
+    {P_ENCP_VIDEO_MAX_PXCNT,       3959,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       749,   },
 
      //analog vidoe position in horizontal
-    {ENCP_VIDEO_HSPULS_BEGIN,    80,    },
-    {ENCP_VIDEO_HSPULS_END,      240,   },
-    {ENCP_VIDEO_HSPULS_SWITCH,   80,    },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    80,    },
+    {P_ENCP_VIDEO_HSPULS_END,      240,   },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   80,    },
 
     //DE position in horizontal
-    {ENCP_VIDEO_HAVON_BEGIN,     648,   },
-    {ENCP_VIDEO_HAVON_END,       3207,  },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     648,   },
+    {P_ENCP_VIDEO_HAVON_END,       3207,  },
 
     //ditital hsync positon in horizontal
-    {ENCP_VIDEO_HSO_BEGIN,       128 ,},
-    {ENCP_VIDEO_HSO_END,         208 , },
+    {P_ENCP_VIDEO_HSO_BEGIN,       128 ,},
+    {P_ENCP_VIDEO_HSO_END,         208 , },
 
     /* vsync horizontal timing */
-    {ENCP_VIDEO_VSPULS_BEGIN,    688,   },
-    {ENCP_VIDEO_VSPULS_END,      3248,  },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    688,   },
+    {P_ENCP_VIDEO_VSPULS_END,      3248,  },
 
     /* vertical timing settings */
-    {ENCP_VIDEO_VSPULS_BLINE,    4,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    8,     },
-    {ENCP_VIDEO_EQPULS_BLINE,    4,     },
-    {ENCP_VIDEO_EQPULS_ELINE,    8,     },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    4,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    8,     },
+    {P_ENCP_VIDEO_EQPULS_BLINE,    4,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    8,     },
 
     //DE position in vertical
-    {ENCP_VIDEO_VAVON_BLINE,     29,    },
-    {ENCP_VIDEO_VAVON_ELINE,     748,   },
+    {P_ENCP_VIDEO_VAVON_BLINE,     29,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     748,   },
 
     //adjust the vsync start point and end point
-    {ENCP_VIDEO_VSO_BEGIN,       128,},  //168,   },
-    {ENCP_VIDEO_VSO_END,         128, },  //256,   },
+    {P_ENCP_VIDEO_VSO_BEGIN,       128,},  //168,   },
+    {P_ENCP_VIDEO_VSO_END,         128, },  //256,   },
 
     //adjust the vsync start line and end line
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_VSO_ELINE,       5,     },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
 
     /* filter & misc settings */
-    {ENCP_VIDEO_YFP1_HTIME,      648,   },
-    {ENCP_VIDEO_YFP2_HTIME,      3207,  },
+    {P_ENCP_VIDEO_YFP1_HTIME,      648,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      3207,  },
 
 
-    {VENC_VIDEO_PROG_MODE,       0x100, },
-    {ENCP_VIDEO_MODE,            0x4040,},  //Enable Hsync and equalization pulse switch in center
-    {ENCP_VIDEO_MODE_ADV,        0x0019,},//bit6:swap PbPr; bit4:YPBPR gain as HDTV type;
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_ENCP_VIDEO_MODE,            0x4040,},  //Enable Hsync and equalization pulse switch in center
+    {P_ENCP_VIDEO_MODE_ADV,        0x0019,},//bit6:swap PbPr; bit4:YPBPR gain as HDTV type;
                                                  //bit3:Data input from VFIFO;bit[2}0]:repreat pixel a time
 
-     {ENCP_VIDEO_SYNC_MODE,       0x407,  },//Video input Synchronization mode ( bit[7:0] -- 4:Slave mode, 7:Master mode)
+     {P_ENCP_VIDEO_SYNC_MODE,       0x407,  },//Video input Synchronization mode ( bit[7:0] -- 4:Slave mode, 7:Master mode)
                                                  //bit[15:6] -- adjust the vsync vertical position
-    {ENCP_VIDEO_YC_DLY,          0,     },      //Y/Cb/Cr delay
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_SETTING,          0,     },
-    {VPU_VIU_VENC_MUX_CTRL,      0x000a,},
-    {ENCP_VIDEO_EN,              1,     },
-    {ENCI_VIDEO_EN,              0,     },
+    {P_ENCP_VIDEO_YC_DLY,          0,     },      //Y/Cb/Cr delay
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,},
+    {P_ENCP_DACSEL_0,              0x3102,},
+    {P_ENCP_DACSEL_1,              0x0054,},
+    {P_VENC_VDAC_DACSEL0,          0x0001,},
+    {P_VENC_VDAC_DACSEL1,          0x0001,},
+    {P_VENC_VDAC_DACSEL2,          0x0001,},
+    {P_VENC_VDAC_DACSEL3,          0x0001,},
+    {P_VENC_VDAC_DACSEL4,          0x0001,},
+    {P_VENC_VDAC_DACSEL5,          0x0001,},
+    {P_ENCP_VIDEO_EN,              1,     },
+    {P_ENCI_VIDEO_EN,              0,     },
     {MREG_END_MARKER,            0      }
 };
 
 static const reg_t tvregs_480i[] = {
-    {VENC_VDAC_SETTING,            0xff,  },
-
-    {HHI_VID_CLK_CNTL,           0x0,       },
-    {HHI_VID_PLL_CNTL,           0x2001042d,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928,},
-    {HHI_VID_PLL_CNTL3,          0x6b425012,    },
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001042d,},
-
-    {HHI_VID_DIVIDER_CNTL,       0x00011943,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-    {ENCI_CFILT_CTRL,              0x12,},
-    {ENCI_CFILT_CTRL2,              0x12,},
-    {VENC_DVI_SETTING,             0,     },
-    {ENCI_VIDEO_MODE,              0,     },
-    {ENCI_VIDEO_MODE_ADV,          0,     },
-    {ENCI_SYNC_HSO_BEGIN,          5,     },
-    {ENCI_SYNC_HSO_END,            129,   },
-    {ENCI_SYNC_VSO_EVNLN,          0x0003 },
-    {ENCI_SYNC_VSO_ODDLN,          0x0104 },
-    {ENCI_MACV_MAX_AMP,            0x810b },
-    {VENC_VIDEO_PROG_MODE,         0xf0   },
-    {ENCI_VIDEO_MODE,              0x08   },
-    {ENCI_VIDEO_MODE_ADV,          0x26,  },
-    {ENCI_VIDEO_SCH,               0x20,  },
-    {ENCI_SYNC_MODE,               0x07,  },
-    {ENCI_YC_DELAY,                0x353, },
-    {ENCI_VFIFO2VD_PIXEL_START,    0xf3,  },
-    {ENCI_VFIFO2VD_PIXEL_END,      0x0693,},
-    {ENCI_VFIFO2VD_LINE_TOP_START, 0x12,  },
-    {ENCI_VFIFO2VD_LINE_TOP_END,   0x102, },
-    {ENCI_VFIFO2VD_LINE_BOT_START, 0x13,  },
-    {ENCI_VFIFO2VD_LINE_BOT_END,   0x103, },
-    {VENC_SYNC_ROUTE,              0,     },
-    {ENCI_DBG_PX_RST,              0,     },
-    {VENC_INTCTRL,                 0x2,   },
-    {ENCI_VFIFO2VD_CTL,            0x4e01,},
-    {VENC_VDAC_SETTING,            0,     },
-    {VENC_UPSAMPLE_CTRL0,          0x0061,},
-    {VENC_UPSAMPLE_CTRL1,          0x4061,},
-    {VENC_UPSAMPLE_CTRL2,          0x5061,},
-    {VENC_VDAC_DACSEL0,            0x0000,},
-    {VENC_VDAC_DACSEL1,            0x0000,},
-    {VENC_VDAC_DACSEL2,            0x0000,},
-    {VENC_VDAC_DACSEL3,            0x0000,},
-    {VENC_VDAC_DACSEL4,            0x0000,},
-    {VENC_VDAC_DACSEL5,            0x0000,},
-    {VPU_VIU_VENC_MUX_CTRL,        0x0005,},
-    {VENC_VDAC_FIFO_CTRL,          0x2000,},
-    {ENCI_DACSEL_0,                0x6405 },
-    {ENCI_DACSEL_1,                0x87   },
-    {ENCP_VIDEO_EN,                0,     },
-    {ENCI_VIDEO_EN,                1,     },
+    {P_VENC_VDAC_SETTING,            0xff,  },
+
+    {P_ENCI_CFILT_CTRL,              0x12,},
+    {P_ENCI_CFILT_CTRL2,              0x12,},
+    {P_VENC_DVI_SETTING,             0,     },
+    {P_ENCI_VIDEO_MODE,              0,     },
+    {P_ENCI_VIDEO_MODE_ADV,          0,     },
+    {P_ENCI_SYNC_HSO_BEGIN,          5,     },
+    {P_ENCI_SYNC_HSO_END,            129,   },
+    {P_ENCI_SYNC_VSO_EVNLN,          0x0003 },
+    {P_ENCI_SYNC_VSO_ODDLN,          0x0104 },
+    {P_ENCI_MACV_MAX_AMP,            0x810b },
+    {P_VENC_VIDEO_PROG_MODE,         0xf0   },
+    {P_ENCI_VIDEO_MODE,              0x08   },
+    {P_ENCI_VIDEO_MODE_ADV,          0x26,  },
+    {P_ENCI_VIDEO_SCH,               0x20,  },
+    {P_ENCI_SYNC_MODE,               0x07,  },
+    {P_ENCI_YC_DELAY,                0x333, },
+    {P_ENCI_VFIFO2VD_PIXEL_START,    0xf3,  },
+    {P_ENCI_VFIFO2VD_PIXEL_END,      0x0693,},
+    {P_ENCI_VFIFO2VD_LINE_TOP_START, 0x12,  },
+    {P_ENCI_VFIFO2VD_LINE_TOP_END,   0x102, },
+    {P_ENCI_VFIFO2VD_LINE_BOT_START, 0x13,  },
+    {P_ENCI_VFIFO2VD_LINE_BOT_END,   0x103, },
+    {P_VENC_SYNC_ROUTE,              0,     },
+    {P_ENCI_DBG_PX_RST,              0,     },
+    {P_VENC_INTCTRL,                 0x2,   },
+    {P_ENCI_VFIFO2VD_CTL,            0x4e01,},
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VENC_UPSAMPLE_CTRL0,          0x0061,},
+    {P_VENC_UPSAMPLE_CTRL1,          0x4061,},
+    {P_VENC_UPSAMPLE_CTRL2,          0x5061,},
+    {P_VENC_VDAC_DACSEL0,            0x0000,},
+    {P_VENC_VDAC_DACSEL1,            0x0000,},
+    {P_VENC_VDAC_DACSEL2,            0x0000,},
+    {P_VENC_VDAC_DACSEL3,            0x0000,},
+    {P_VENC_VDAC_DACSEL4,            0x0000,},
+    {P_VENC_VDAC_DACSEL5,            0x0000,},
+    {P_VPU_VIU_VENC_MUX_CTRL,        0x0005,},
+    {P_VENC_VDAC_FIFO_CTRL,          0x2000,},
+    {P_ENCI_DACSEL_0,                0x0011 },
+    {P_ENCI_DACSEL_1,                0x87   },
+    {P_ENCP_VIDEO_EN,                0,     },
+    {P_ENCI_VIDEO_EN,                1,     },
     {MREG_END_MARKER,              0      }
 };
 
 static const reg_t tvregs_480cvbs[] = {
-     {VENC_VDAC_SETTING,            0xff,  },
-
-    {HHI_VID_CLK_CNTL,           0x0,       },
-    {HHI_VID_PLL_CNTL,           0x2001042d,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928,},
-    {HHI_VID_PLL_CNTL3,          0x6b425012,    },
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001042d,},
-
-    {HHI_VID_DIVIDER_CNTL,       0x00011943,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-    {ENCI_CFILT_CTRL,              0x12,},
-    {ENCI_CFILT_CTRL2,              0x12,},
-    {VENC_DVI_SETTING,             0,     },
-    {ENCI_VIDEO_MODE,              0,     },
-    {ENCI_VIDEO_MODE_ADV,          0,     },
-    {ENCI_SYNC_HSO_BEGIN,          5,     },
-    {ENCI_SYNC_HSO_END,            129,   },
-    {ENCI_SYNC_VSO_EVNLN,          0x0003 },
-    {ENCI_SYNC_VSO_ODDLN,          0x0104 },
-    {ENCI_MACV_MAX_AMP,            0x810b },
-    {VENC_VIDEO_PROG_MODE,         0xf0   },
-    {ENCI_VIDEO_MODE,              0x08   },
-    {ENCI_VIDEO_MODE_ADV,          0x26,  },
-    {ENCI_VIDEO_SCH,               0x20,  },
-    {ENCI_SYNC_MODE,               0x07,  },
-    {ENCI_YC_DELAY,                0x353, },
-    {ENCI_VFIFO2VD_PIXEL_START,    0xf3,  },
-    {ENCI_VFIFO2VD_PIXEL_END,      0x0693,},
-    {ENCI_VFIFO2VD_LINE_TOP_START, 0x12,  },
-    {ENCI_VFIFO2VD_LINE_TOP_END,   0x102, },
-    {ENCI_VFIFO2VD_LINE_BOT_START, 0x13,  },
-    {ENCI_VFIFO2VD_LINE_BOT_END,   0x103, },
-    {VENC_SYNC_ROUTE,              0,     },
-    {ENCI_DBG_PX_RST,              0,     },
-    {VENC_INTCTRL,                 0x2,   },
-    {ENCI_VFIFO2VD_CTL,            0x4e01,},
-    {VENC_VDAC_SETTING,            0,     },
-    {VENC_UPSAMPLE_CTRL0,          0x0061,},
-    {VENC_UPSAMPLE_CTRL1,          0x4061,},
-    {VENC_UPSAMPLE_CTRL2,          0x5061,},
-    {VENC_VDAC_DACSEL0,            0x0000,},
-    {VENC_VDAC_DACSEL1,            0x0000,},
-    {VENC_VDAC_DACSEL2,            0x0000,},
-    {VENC_VDAC_DACSEL3,            0x0000,},
-    {VENC_VDAC_DACSEL4,            0x0000,},
-    {VENC_VDAC_DACSEL5,            0x0000,},
-    {VPU_VIU_VENC_MUX_CTRL,        0x0005,},
-    {VENC_VDAC_FIFO_CTRL,          0x2000,},
-    {ENCI_DACSEL_0,                0x1111 },
-    {ENCI_DACSEL_1,                0x11   },
-    {ENCP_VIDEO_EN,                0,     },
-    {ENCI_VIDEO_EN,                1,     },
+    {P_VENC_VDAC_SETTING,            0xff,  },
+
+    {P_ENCI_CFILT_CTRL,              0x12,},
+    {P_ENCI_CFILT_CTRL2,              0x12,},
+    {P_VENC_DVI_SETTING,             0,     },
+    {P_ENCI_VIDEO_MODE,              0,     },
+    {P_ENCI_VIDEO_MODE_ADV,          0,     },
+    {P_ENCI_SYNC_HSO_BEGIN,          5,     },
+    {P_ENCI_SYNC_HSO_END,            129,   },
+    {P_ENCI_SYNC_VSO_EVNLN,          0x0003 },
+    {P_ENCI_SYNC_VSO_ODDLN,          0x0104 },
+    {P_ENCI_MACV_MAX_AMP,            0x810b },
+    {P_VENC_VIDEO_PROG_MODE,         0xf0   },
+    {P_ENCI_VIDEO_MODE,              0x08   },
+    {P_ENCI_VIDEO_MODE_ADV,          0x26,  },
+    {P_ENCI_VIDEO_SCH,               0x20,  },
+    {P_ENCI_SYNC_MODE,               0x07,  },
+    {P_ENCI_YC_DELAY,                0x333, },
+    {P_ENCI_VFIFO2VD_PIXEL_START,    0xe3,  },
+    {P_ENCI_VFIFO2VD_PIXEL_END,      0x0683,},
+    {P_ENCI_VFIFO2VD_LINE_TOP_START, 0x12,  },
+    {P_ENCI_VFIFO2VD_LINE_TOP_END,   0x102, },
+    {P_ENCI_VFIFO2VD_LINE_BOT_START, 0x13,  },
+    {P_ENCI_VFIFO2VD_LINE_BOT_END,   0x103, },
+    {P_VENC_SYNC_ROUTE,              0,     },
+    {P_ENCI_DBG_PX_RST,              0,     },
+    {P_VENC_INTCTRL,                 0x2,   },
+    {P_ENCI_VFIFO2VD_CTL,            0x4e01,},
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VENC_UPSAMPLE_CTRL0,          0x0061,},
+    {P_VENC_UPSAMPLE_CTRL1,          0x4061,},
+    {P_VENC_UPSAMPLE_CTRL2,          0x5061,},
+    {P_VENC_VDAC_DACSEL0,            0x0000,},
+    {P_VENC_VDAC_DACSEL1,            0x0000,},
+    {P_VENC_VDAC_DACSEL2,            0x0000,},
+    {P_VENC_VDAC_DACSEL3,            0x0000,},
+    {P_VENC_VDAC_DACSEL4,            0x0000,},
+    {P_VENC_VDAC_DACSEL5,            0x0000,},
+    {P_VPU_VIU_VENC_MUX_CTRL,        0x0005,},
+    {P_VENC_VDAC_FIFO_CTRL,          0x2000,},
+    {P_ENCI_DACSEL_0,                0x0011 },
+    {P_ENCI_DACSEL_1,                0x11   },
+    {P_ENCP_VIDEO_EN,                0,     },
+    {P_ENCI_VIDEO_EN,                1,     },
+    {P_ENCI_VIDEO_SAT,               0x7        },
+    {P_VENC_VDAC_DAC0_FILT_CTRL0,    0x1        },
+    {P_VENC_VDAC_DAC0_FILT_CTRL1,    0xfc48     },
+    {P_ENCI_MACV_N0,                 0x0        },
     {MREG_END_MARKER,              0      }
 };
 
 static const reg_t tvregs_480p[] = {
-    {VENC_VDAC_SETTING,          0xff,  },
-    {HHI_VID_CLK_CNTL,           0x0,       },
-    {HHI_VID_PLL_CNTL,           0x2001042d,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928,},
-    {HHI_VID_PLL_CNTL3,          0x6b425012,    },
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001042d,},
-
-    {HHI_VID_DIVIDER_CNTL,       0x00011943,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-    //{HHI_VID_CLK_DIV,            0x01000100,},
-    {ENCP_VIDEO_FILT_CTRL,       0x2052,},
-    {VENC_DVI_SETTING,           0x21,  },
-    {ENCP_VIDEO_MODE,            0x4000,},
-    {ENCP_VIDEO_MODE_ADV,        9,     },
-    {ENCP_VIDEO_YFP1_HTIME,      244,   },
-    {ENCP_VIDEO_YFP2_HTIME,      1630,  },
-    {ENCP_VIDEO_YC_DLY,          0,     },
-    {ENCP_VIDEO_MAX_PXCNT,       1715,  },
-    {ENCP_VIDEO_MAX_LNCNT,       524,   },
-    {ENCP_VIDEO_HSPULS_BEGIN,    0x22,  },
-    {ENCP_VIDEO_HSPULS_END,      0xa0,  },
-    {ENCP_VIDEO_HSPULS_SWITCH,   88,    },
-    {ENCP_VIDEO_VSPULS_BEGIN,    0,     },
-    {ENCP_VIDEO_VSPULS_END,      1589   },
-    {ENCP_VIDEO_VSPULS_BLINE,    0,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    5,     },
-    {ENCP_VIDEO_HAVON_BEGIN,     249,   },
-    {ENCP_VIDEO_HAVON_END,       1689,  },
-    {ENCP_VIDEO_VAVON_BLINE,     42,    },
-    {ENCP_VIDEO_VAVON_ELINE,     521,   },
-    {ENCP_VIDEO_SYNC_MODE,       0x07,  },
-    {VENC_VIDEO_PROG_MODE,       0x0,   },
-    {VENC_VIDEO_EXSRC,           0x0,   },
-    {ENCP_VIDEO_HSO_BEGIN,       0x3,   },
-    {ENCP_VIDEO_HSO_END,         0x5,   },
-    {ENCP_VIDEO_VSO_BEGIN,       0x3,   },
-    {ENCP_VIDEO_VSO_END,         0x5,   },
-    {ENCP_VIDEO_VSO_BLINE,       0,     },  //added by JZD. Switch Panel to 480p first time, movie video flicks if not set this to 0
-    {ENCP_VIDEO_SY_VAL,          8,     },
-    {ENCP_VIDEO_SY2_VAL,         0x1d8, },
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_SETTING,          0,     },
-    {VENC_UPSAMPLE_CTRL0,        0x9061,},
-    {VENC_UPSAMPLE_CTRL1,        0xa061,},
-    {VENC_UPSAMPLE_CTRL2,        0xb061,},
-    {VENC_VDAC_DACSEL0,          0xf003,},
-    {VENC_VDAC_DACSEL1,          0xf003,},
-    {VENC_VDAC_DACSEL2,          0xf003,},
-    {VENC_VDAC_DACSEL3,          0xf003,},
-    {VENC_VDAC_DACSEL4,          0xf003,},
-    {VENC_VDAC_DACSEL5,          0xf003,},
-    {VPU_VIU_VENC_MUX_CTRL,      0x000a,},
-    {VENC_VDAC_FIFO_CTRL,        0x1000,},
-    {ENCP_DACSEL_0,              0x3102,},
-    {ENCP_DACSEL_1,              0x0054,},
-    {ENCI_VIDEO_EN,              0      },
-    {ENCP_VIDEO_EN,              1      },
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    //{P_HHI_VID_CLK_DIV,            0x01000100,},
+    {P_ENCP_VIDEO_FILT_CTRL,       0x2052,},
+    {P_VENC_DVI_SETTING,           0x21,  },
+    {P_ENCP_VIDEO_MODE,            0x4000,},
+    {P_ENCP_VIDEO_MODE_ADV,        9,     },
+    {P_ENCP_VIDEO_YFP1_HTIME,      244,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      1630,  },
+    {P_ENCP_VIDEO_YC_DLY,          0,     },
+    {P_ENCP_VIDEO_MAX_PXCNT,       1715,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       524,   },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    0x22,  },
+    {P_ENCP_VIDEO_HSPULS_END,      0xa0,  },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   88,    },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    0,     },
+    {P_ENCP_VIDEO_VSPULS_END,      1589   },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    5,     },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     249,   },
+    {P_ENCP_VIDEO_HAVON_END,       1689,  },
+    {P_ENCP_VIDEO_VAVON_BLINE,     42,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     521,   },
+    {P_ENCP_VIDEO_SYNC_MODE,       0x07,  },
+    {P_VENC_VIDEO_PROG_MODE,       0x0,   },
+    {P_VENC_VIDEO_EXSRC,           0x0,   },
+    {P_ENCP_VIDEO_HSO_BEGIN,       0x3,   },
+    {P_ENCP_VIDEO_HSO_END,         0x5,   },
+    {P_ENCP_VIDEO_VSO_BEGIN,       0x3,   },
+    {P_ENCP_VIDEO_VSO_END,         0x5,   },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },  //added by JZD. Switch Panel to 480p first time, movie video flicks if not set this to 0
+    {P_ENCP_VIDEO_SY_VAL,          8,     },
+    {P_ENCP_VIDEO_SY2_VAL,         0x1d8, },
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VENC_UPSAMPLE_CTRL0,        0x9061,},
+    {P_VENC_UPSAMPLE_CTRL1,        0xa061,},
+    {P_VENC_UPSAMPLE_CTRL2,        0xb061,},
+    {P_VENC_VDAC_DACSEL0,          0xf003,},
+    {P_VENC_VDAC_DACSEL1,          0xf003,},
+    {P_VENC_VDAC_DACSEL2,          0xf003,},
+    {P_VENC_VDAC_DACSEL3,          0xf003,},
+    {P_VENC_VDAC_DACSEL4,          0xf003,},
+    {P_VENC_VDAC_DACSEL5,          0xf003,},
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,},
+    {P_ENCP_DACSEL_0,              0x3102,},
+    {P_ENCP_DACSEL_1,              0x0054,},
+    {P_ENCI_VIDEO_EN,              0      },
+    {P_ENCP_VIDEO_EN,              1      },
     {MREG_END_MARKER,            0      }
 };
 
 static const reg_t tvregs_576i[] = {
-    {VENC_VDAC_SETTING,               0xff,      },
-
-    {HHI_VID_CLK_CNTL,           0x0,       },
-    {HHI_VID_PLL_CNTL,           0x2001042d,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928,},
-    {HHI_VID_PLL_CNTL3,          0x6b425012,    },
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001042d,},
-
-    {HHI_VID_DIVIDER_CNTL,       0x00011943,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-    {ENCI_CFILT_CTRL,                 0x12,    },
-    {ENCI_CFILT_CTRL2,                 0x12,    },
-    {VENC_DVI_SETTING,                0,         },
-    {ENCI_VIDEO_MODE,                 0,         },
-    {ENCI_VIDEO_MODE_ADV,             0,         },
-    {ENCI_SYNC_HSO_BEGIN,             3,         },
-    {ENCI_SYNC_HSO_END,               129,       },
-    {ENCI_SYNC_VSO_EVNLN,             0x0003     },
-    {ENCI_SYNC_VSO_ODDLN,             0x0104     },
-    {ENCI_MACV_MAX_AMP,               0x8107     },
-    {VENC_VIDEO_PROG_MODE,            0xff       },
-    {ENCI_VIDEO_MODE,                 0x13       },
-    {ENCI_VIDEO_MODE_ADV,             0x26,      },
-    {ENCI_VIDEO_SCH,                  0x28,      },
-    {ENCI_SYNC_MODE,                  0x07,      },
-    {ENCI_YC_DELAY,                   0x353,     },
-    {ENCI_VFIFO2VD_PIXEL_START,       0x010b     },
-    {ENCI_VFIFO2VD_PIXEL_END,         0x06ab     },
-    {ENCI_VFIFO2VD_LINE_TOP_START,    0x0016     },
-    {ENCI_VFIFO2VD_LINE_TOP_END,      0x0136     },
-    {ENCI_VFIFO2VD_LINE_BOT_START,    0x0017     },
-    {ENCI_VFIFO2VD_LINE_BOT_END,      0x0137     },
-    {VENC_SYNC_ROUTE,                 0,         },
-    {ENCI_DBG_PX_RST,                 0,         },
-    {VENC_INTCTRL,                    0x2,       },
-    {ENCI_VFIFO2VD_CTL,               0x4e01,    },
-    {VENC_VDAC_SETTING,               0,         },
-    {VENC_UPSAMPLE_CTRL0,             0x0061,    },
-    {VENC_UPSAMPLE_CTRL1,             0x4061,    },
-    {VENC_UPSAMPLE_CTRL2,             0x5061,    },
-    {VENC_VDAC_DACSEL0,               0x0000,    },
-    {VENC_VDAC_DACSEL1,               0x0000,    },
-    {VENC_VDAC_DACSEL2,               0x0000,    },
-    {VENC_VDAC_DACSEL3,               0x0000,    },
-    {VENC_VDAC_DACSEL4,               0x0000,    },
-    {VENC_VDAC_DACSEL5,               0x0000,    },
-    {VPU_VIU_VENC_MUX_CTRL,           0x0005,    },
-    {VENC_VDAC_FIFO_CTRL,             0x2000,    },
-    {ENCI_DACSEL_0,                   0x6405     },
-    {ENCI_DACSEL_1,                   0x87       },
-    {ENCP_VIDEO_EN,                   0,         },
-    {ENCI_VIDEO_EN,                   1,         },
+    {P_VENC_VDAC_SETTING,               0xff,      },
+
+    {P_ENCI_CFILT_CTRL,                 0x12,    },
+    {P_ENCI_CFILT_CTRL2,                 0x12,    },
+    {P_VENC_DVI_SETTING,                0,         },
+    {P_ENCI_VIDEO_MODE,                 0,         },
+    {P_ENCI_VIDEO_MODE_ADV,             0,         },
+    {P_ENCI_SYNC_HSO_BEGIN,             3,         },
+    {P_ENCI_SYNC_HSO_END,               129,       },
+    {P_ENCI_SYNC_VSO_EVNLN,             0x0003     },
+    {P_ENCI_SYNC_VSO_ODDLN,             0x0104     },
+    {P_ENCI_MACV_MAX_AMP,               0x8107     },
+    {P_VENC_VIDEO_PROG_MODE,            0xff       },
+    {P_ENCI_VIDEO_MODE,                 0x13       },
+    {P_ENCI_VIDEO_MODE_ADV,             0x26,      },
+    {P_ENCI_VIDEO_SCH,                  0x28,      },
+    {P_ENCI_SYNC_MODE,                  0x07,      },
+    {P_ENCI_YC_DELAY,                   0x333,     },
+    {P_ENCI_VFIFO2VD_PIXEL_START,       0x010b     },
+    {P_ENCI_VFIFO2VD_PIXEL_END,         0x06ab     },
+    {P_ENCI_VFIFO2VD_LINE_TOP_START,    0x0016     },
+    {P_ENCI_VFIFO2VD_LINE_TOP_END,      0x0136     },
+    {P_ENCI_VFIFO2VD_LINE_BOT_START,    0x0017     },
+    {P_ENCI_VFIFO2VD_LINE_BOT_END,      0x0137     },
+    {P_VENC_SYNC_ROUTE,                 0,         },
+    {P_ENCI_DBG_PX_RST,                 0,         },
+    {P_VENC_INTCTRL,                    0x2,       },
+    {P_ENCI_VFIFO2VD_CTL,               0x4e01,    },
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VENC_UPSAMPLE_CTRL0,             0x0061,    },
+    {P_VENC_UPSAMPLE_CTRL1,             0x4061,    },
+    {P_VENC_UPSAMPLE_CTRL2,             0x5061,    },
+    {P_VENC_VDAC_DACSEL0,               0x0000,    },
+    {P_VENC_VDAC_DACSEL1,               0x0000,    },
+    {P_VENC_VDAC_DACSEL2,               0x0000,    },
+    {P_VENC_VDAC_DACSEL3,               0x0000,    },
+    {P_VENC_VDAC_DACSEL4,               0x0000,    },
+    {P_VENC_VDAC_DACSEL5,               0x0000,    },
+    {P_VPU_VIU_VENC_MUX_CTRL,           0x0005,    },
+    {P_VENC_VDAC_FIFO_CTRL,             0x2000,    },
+    {P_ENCI_DACSEL_0,                   0x0011     },
+    {P_ENCI_DACSEL_1,                   0x87       },
+    {P_ENCP_VIDEO_EN,                   0,         },
+    {P_ENCI_VIDEO_EN,                   1,         },
     {MREG_END_MARKER,                 0          }
 };
 
 static const reg_t tvregs_576cvbs[] = {
-{VENC_VDAC_SETTING,               0xff,      },
-
-    {HHI_VID_CLK_CNTL,           0x0,       },
-    {HHI_VID_PLL_CNTL,           0x2001042d,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928,},
-    {HHI_VID_PLL_CNTL3,          0x6b425012,    },
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001042d,},
-
-    {HHI_VID_DIVIDER_CNTL,       0x00011943,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-    {ENCI_CFILT_CTRL,                 0x12,    },
-    {ENCI_CFILT_CTRL2,                 0x12,    },
-    {VENC_DVI_SETTING,                0,         },
-    {ENCI_VIDEO_MODE,                 0,         },
-    {ENCI_VIDEO_MODE_ADV,             0,         },
-    {ENCI_SYNC_HSO_BEGIN,             3,         },
-    {ENCI_SYNC_HSO_END,               129,       },
-    {ENCI_SYNC_VSO_EVNLN,             0x0003     },
-    {ENCI_SYNC_VSO_ODDLN,             0x0104     },
-    {ENCI_MACV_MAX_AMP,               0x8107     },
-    {VENC_VIDEO_PROG_MODE,            0xff       },
-    {ENCI_VIDEO_MODE,                 0x13       },
-    {ENCI_VIDEO_MODE_ADV,             0x26,      },
-    {ENCI_VIDEO_SCH,                  0x28,      },
-    {ENCI_SYNC_MODE,                  0x07,      },
-    {ENCI_YC_DELAY,                   0x353,     },
-    {ENCI_VFIFO2VD_PIXEL_START,       0x010b     },
-    {ENCI_VFIFO2VD_PIXEL_END,         0x06ab     },
-    {ENCI_VFIFO2VD_LINE_TOP_START,    0x0016     },
-    {ENCI_VFIFO2VD_LINE_TOP_END,      0x0136     },
-    {ENCI_VFIFO2VD_LINE_BOT_START,    0x0017     },
-    {ENCI_VFIFO2VD_LINE_BOT_END,      0x0137     },
-    {VENC_SYNC_ROUTE,                 0,         },
-    {ENCI_DBG_PX_RST,                 0,         },
-    {VENC_INTCTRL,                    0x2,       },
-    {ENCI_VFIFO2VD_CTL,               0x4e01,    },
-    {VENC_VDAC_SETTING,               0,         },
-    {VENC_UPSAMPLE_CTRL0,             0x0061,    },
-    {VENC_UPSAMPLE_CTRL1,             0x4061,    },
-    {VENC_UPSAMPLE_CTRL2,             0x5061,    },
-    {VENC_VDAC_DACSEL0,               0x0000,    },
-    {VENC_VDAC_DACSEL1,               0x0000,    },
-    {VENC_VDAC_DACSEL2,               0x0000,    },
-    {VENC_VDAC_DACSEL3,               0x0000,    },
-    {VENC_VDAC_DACSEL4,               0x0000,    },
-    {VENC_VDAC_DACSEL5,               0x0000,    },
-    {VPU_VIU_VENC_MUX_CTRL,           0x0005,    },
-    {VENC_VDAC_FIFO_CTRL,             0x2000,    },
-    {ENCI_DACSEL_0,                   0x1111     },
-    {ENCI_DACSEL_1,                   0x11       },
-    {ENCP_VIDEO_EN,                   0,         },
-    {ENCI_VIDEO_EN,                   1,         },
+    {P_VENC_VDAC_SETTING,               0xff,      },
+
+    {P_ENCI_CFILT_CTRL,                 0x12,    },
+    {P_ENCI_CFILT_CTRL2,                 0x12,    },
+    {P_VENC_DVI_SETTING,                0,         },
+    {P_ENCI_VIDEO_MODE,                 0,         },
+    {P_ENCI_VIDEO_MODE_ADV,             0,         },
+    {P_ENCI_SYNC_HSO_BEGIN,             3,         },
+    {P_ENCI_SYNC_HSO_END,               129,       },
+    {P_ENCI_SYNC_VSO_EVNLN,             0x0003     },
+    {P_ENCI_SYNC_VSO_ODDLN,             0x0104     },
+    {P_ENCI_MACV_MAX_AMP,               0x8107     },
+    {P_VENC_VIDEO_PROG_MODE,            0xff       },
+    {P_ENCI_VIDEO_MODE,                 0x13       },
+    {P_ENCI_VIDEO_MODE_ADV,             0x26,      },
+    {P_ENCI_VIDEO_SCH,                  0x28,      },
+    {P_ENCI_SYNC_MODE,                  0x07,      },
+    {P_ENCI_YC_DELAY,                   0x333,     },
+    {P_ENCI_VFIFO2VD_PIXEL_START,       0x0fb	   },
+    {P_ENCI_VFIFO2VD_PIXEL_END,         0x069b     },
+    {P_ENCI_VFIFO2VD_LINE_TOP_START,    0x0016     },
+    {P_ENCI_VFIFO2VD_LINE_TOP_END,      0x0136     },
+    {P_ENCI_VFIFO2VD_LINE_BOT_START,    0x0017     },
+    {P_ENCI_VFIFO2VD_LINE_BOT_END,      0x0137     },
+    {P_VENC_SYNC_ROUTE,                 0,         },
+    {P_ENCI_DBG_PX_RST,                 0,         },
+    {P_VENC_INTCTRL,                    0x2,       },
+    {P_ENCI_VFIFO2VD_CTL,               0x4e01,    },
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VENC_UPSAMPLE_CTRL0,             0x0061,    },
+    {P_VENC_UPSAMPLE_CTRL1,             0x4061,    },
+    {P_VENC_UPSAMPLE_CTRL2,             0x5061,    },
+    {P_VENC_VDAC_DACSEL0,               0x0000,    },
+    {P_VENC_VDAC_DACSEL1,               0x0000,    },
+    {P_VENC_VDAC_DACSEL2,               0x0000,    },
+    {P_VENC_VDAC_DACSEL3,               0x0000,    },
+    {P_VENC_VDAC_DACSEL4,               0x0000,    },
+    {P_VENC_VDAC_DACSEL5,               0x0000,    },
+    {P_VPU_VIU_VENC_MUX_CTRL,           0x0005,    },
+    {P_VENC_VDAC_FIFO_CTRL,             0x2000,    },
+    {P_ENCI_DACSEL_0,                   0x0011     },
+    {P_ENCI_DACSEL_1,                   0x11       },
+    {P_ENCP_VIDEO_EN,                   0,         },
+    {P_ENCI_VIDEO_EN,                   1,         },
+    {P_ENCI_VIDEO_SAT,                  0x7        },
+    {P_VENC_VDAC_DAC0_FILT_CTRL0,       0x1        },
+    {P_VENC_VDAC_DAC0_FILT_CTRL1,       0xfc48     },
+    {P_ENCI_MACV_N0,                    0x0        },
     {MREG_END_MARKER,                 0          }
 };
 
 static const reg_t tvregs_576p[] = {
-    {VENC_VDAC_SETTING,          0xff,      },
-    {HHI_VID_CLK_CNTL,           0x0,       },
-    {HHI_VID_PLL_CNTL,           0x2001042d,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928,},
-    {HHI_VID_PLL_CNTL3,          0x6b425012,    },
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001042d,},
-
-    {HHI_VID_DIVIDER_CNTL,       0x00011943,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-    {HHI_HDMI_AFC_CNTL,          0x8c0000c3,},
-    {ENCP_VIDEO_FILT_CTRL,       0x52,      },
-    {VENC_DVI_SETTING,           0x21,      },
-    {ENCP_VIDEO_MODE,            0x4000,    },
-    {ENCP_VIDEO_MODE_ADV,        9,         },
-    {ENCP_VIDEO_YFP1_HTIME,      235,       },
-    {ENCP_VIDEO_YFP2_HTIME,      1674,      },
-    {ENCP_VIDEO_YC_DLY,          0xf,       },
-    {ENCP_VIDEO_MAX_PXCNT,       1727,      },
-    {ENCP_VIDEO_MAX_LNCNT,       624,       },
-    {ENCP_VIDEO_HSPULS_BEGIN,    0,         },
-    {ENCP_VIDEO_HSPULS_END,      0x80,      },
-    {ENCP_VIDEO_HSPULS_SWITCH,   88,        },
-    {ENCP_VIDEO_VSPULS_BEGIN,    0,         },
-    {ENCP_VIDEO_VSPULS_END,      1599       },
-    {ENCP_VIDEO_VSPULS_BLINE,    0,         },
-    {ENCP_VIDEO_VSPULS_ELINE,    4,         },
-    {ENCP_VIDEO_HAVON_BEGIN,     235,       },
-    {ENCP_VIDEO_HAVON_END,       1674,      },
-    {ENCP_VIDEO_VAVON_BLINE,     44,        },
-    {ENCP_VIDEO_VAVON_ELINE,     619,       },
-    {ENCP_VIDEO_SYNC_MODE,       0x07,      },
-    {VENC_VIDEO_PROG_MODE,       0x0,       },
-    {VENC_VIDEO_EXSRC,           0x0,       },
-    {ENCP_VIDEO_HSO_BEGIN,       0x80,      },
-    {ENCP_VIDEO_HSO_END,         0x0,       },
-    {ENCP_VIDEO_VSO_BEGIN,       0x0,       },
-    {ENCP_VIDEO_VSO_END,         0x5,       },
-    {ENCP_VIDEO_VSO_BLINE,       0,         },
-    {ENCP_VIDEO_SY_VAL,          8,         },
-    {ENCP_VIDEO_SY2_VAL,         0x1d8,     },
-    {VENC_SYNC_ROUTE,            0,         },
-    {VENC_INTCTRL,               0x200,     },
-    {VFIFO2VD_CTL,               0,         },
-    {VENC_VDAC_SETTING,          0,         },
-    {VENC_UPSAMPLE_CTRL0,        0x9061,    },
-    {VENC_UPSAMPLE_CTRL1,        0xa061,    },
-    {VENC_UPSAMPLE_CTRL2,        0xb061,    },
-    {VENC_VDAC_DACSEL0,          0xf003,    },
-    {VENC_VDAC_DACSEL1,          0xf003,    },
-    {VENC_VDAC_DACSEL2,          0xf003,    },
-    {VENC_VDAC_DACSEL3,          0xf003,    },
-    {VENC_VDAC_DACSEL4,          0xf003,    },
-    {VENC_VDAC_DACSEL5,          0xf003,    },
-    {VPU_VIU_VENC_MUX_CTRL,      0x000a,    },
-    {VENC_VDAC_FIFO_CTRL,        0x1000,    },
-    {ENCP_DACSEL_0,              0x3102,    },
-    {ENCP_DACSEL_1,              0x0054,    },
-    {ENCI_VIDEO_EN,              0          },
-    {ENCP_VIDEO_EN,              1          },
+    {P_VENC_VDAC_SETTING,          0xff,      },
+
+    {P_HHI_HDMI_AFC_CNTL,          0x8c0000c3,},
+    {P_ENCP_VIDEO_FILT_CTRL,       0x52,      },
+    {P_VENC_DVI_SETTING,           0x21,      },
+    {P_ENCP_VIDEO_MODE,            0x4000,    },
+    {P_ENCP_VIDEO_MODE_ADV,        9,         },
+    {P_ENCP_VIDEO_YFP1_HTIME,      235,       },
+    {P_ENCP_VIDEO_YFP2_HTIME,      1674,      },
+    {P_ENCP_VIDEO_YC_DLY,          0xf,       },
+    {P_ENCP_VIDEO_MAX_PXCNT,       1727,      },
+    {P_ENCP_VIDEO_MAX_LNCNT,       624,       },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    0,         },
+    {P_ENCP_VIDEO_HSPULS_END,      0x80,      },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   88,        },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    0,         },
+    {P_ENCP_VIDEO_VSPULS_END,      1599       },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,         },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    4,         },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     235,       },
+    {P_ENCP_VIDEO_HAVON_END,       1674,      },
+    {P_ENCP_VIDEO_VAVON_BLINE,     44,        },
+    {P_ENCP_VIDEO_VAVON_ELINE,     619,       },
+    {P_ENCP_VIDEO_SYNC_MODE,       0x07,      },
+    {P_VENC_VIDEO_PROG_MODE,       0x0,       },
+    {P_VENC_VIDEO_EXSRC,           0x0,       },
+    {P_ENCP_VIDEO_HSO_BEGIN,       0x80,      },
+    {P_ENCP_VIDEO_HSO_END,         0x0,       },
+    {P_ENCP_VIDEO_VSO_BEGIN,       0x0,       },
+    {P_ENCP_VIDEO_VSO_END,         0x5,       },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,         },
+    {P_ENCP_VIDEO_SY_VAL,          8,         },
+    {P_ENCP_VIDEO_SY2_VAL,         0x1d8,     },
+    {P_VENC_SYNC_ROUTE,            0,         },
+    {P_VENC_INTCTRL,               0x200,     },
+    {P_ENCP_VFIFO2VD_CTL,               0,         },
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VENC_UPSAMPLE_CTRL0,        0x9061,    },
+    {P_VENC_UPSAMPLE_CTRL1,        0xa061,    },
+    {P_VENC_UPSAMPLE_CTRL2,        0xb061,    },
+    {P_VENC_VDAC_DACSEL0,          0xf003,    },
+    {P_VENC_VDAC_DACSEL1,          0xf003,    },
+    {P_VENC_VDAC_DACSEL2,          0xf003,    },
+    {P_VENC_VDAC_DACSEL3,          0xf003,    },
+    {P_VENC_VDAC_DACSEL4,          0xf003,    },
+    {P_VENC_VDAC_DACSEL5,          0xf003,    },
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,    },
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,    },
+    {P_ENCP_DACSEL_0,              0x3102,    },
+    {P_ENCP_DACSEL_1,              0x0054,    },
+    {P_ENCI_VIDEO_EN,              0          },
+    {P_ENCP_VIDEO_EN,              1          },
     {MREG_END_MARKER,            0          }
 };
 
 static const reg_t tvregs_1080i[] = {
-    {VENC_VDAC_SETTING,          0xff,  },
-//	{VCLK_HD},
-    {HHI_VID_CLK_CNTL,           0x0,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928},
-    {HHI_VID_PLL_CNTL3,          0x6b425012},
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001043e,},
-    {HHI_VID_DIVIDER_CNTL,       0x00010843,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-    {ENCP_VIDEO_FILT_CTRL,       0x0052,},
-    {VENC_DVI_SETTING,           0x2029,},
-    {ENCP_VIDEO_MAX_PXCNT,       4399,  },
-    {ENCP_VIDEO_MAX_LNCNT,       1124,  },
-    {ENCP_VIDEO_HSPULS_BEGIN,    88,    },
-    {ENCP_VIDEO_HSPULS_END,      264,   },
-    {ENCP_VIDEO_HSPULS_SWITCH,   88,    },
-    {ENCP_VIDEO_HAVON_BEGIN,     516,   },
-    {ENCP_VIDEO_HAVON_END,       4355,  },
-    {ENCP_VIDEO_HSO_BEGIN,       264,   },
-    {ENCP_VIDEO_HSO_END,         176,   },
-    {ENCP_VIDEO_EQPULS_BEGIN,    2288,  },
-    {ENCP_VIDEO_EQPULS_END,      2464,  },
-    {ENCP_VIDEO_VSPULS_BEGIN,    440,   },
-    {ENCP_VIDEO_VSPULS_END,      2200,  },
-    {ENCP_VIDEO_VSPULS_BLINE,    0,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    4,     },
-    {ENCP_VIDEO_EQPULS_BLINE,    0,     },
-    {ENCP_VIDEO_EQPULS_ELINE,    4,     },
-    {ENCP_VIDEO_VAVON_BLINE,     20,    },
-    {ENCP_VIDEO_VAVON_ELINE,     559,   },
-    {ENCP_VIDEO_VSO_BEGIN,       88,    },
-    {ENCP_VIDEO_VSO_END,         88,    },
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_VSO_ELINE,       5,     },
-    {ENCP_VIDEO_YFP1_HTIME,      516,   },
-    {ENCP_VIDEO_YFP2_HTIME,      4355,  },
-    {VENC_VIDEO_PROG_MODE,       0x100, },
-    {ENCP_VIDEO_OFLD_VOAV_OFST,  0x11   },
-    {ENCP_VIDEO_MODE,            0x5ffc,},
-    {ENCP_VIDEO_MODE_ADV,        0x0019,},
-    {ENCP_VIDEO_SYNC_MODE,       0x207, },
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_FIFO_CTRL,        0x1000,},
-    {VENC_VDAC_SETTING,          0,     },
-    {ENCP_DACSEL_0,              0x3102,},
-    {ENCP_DACSEL_1,              0x0054,},
-    {VENC_VDAC_DACSEL0,          0x0001,},
-    {VENC_VDAC_DACSEL1,          0x0001,},
-    {VENC_VDAC_DACSEL2,          0x0001,},
-    {VENC_VDAC_DACSEL3,          0x0001,},
-    {VENC_VDAC_DACSEL4,          0x0001,},
-    {VENC_VDAC_DACSEL5,          0x0001,},
-    {ENCI_VIDEO_EN,              0,     },
-    {ENCP_VIDEO_EN,              1,     },
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x0052,},
+    {P_VENC_DVI_SETTING,           0x2029,},
+    {P_ENCP_VIDEO_MAX_PXCNT,       4399,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       1124,  },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    88,    },
+    {P_ENCP_VIDEO_HSPULS_END,      264,   },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   88,    },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     516,   },
+    {P_ENCP_VIDEO_HAVON_END,       4355,  },
+    {P_ENCP_VIDEO_HSO_BEGIN,       264,   },
+    {P_ENCP_VIDEO_HSO_END,         176,   },
+    {P_ENCP_VIDEO_EQPULS_BEGIN,    2288,  },
+    {P_ENCP_VIDEO_EQPULS_END,      2464,  },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    440,   },
+    {P_ENCP_VIDEO_VSPULS_END,      2200,  },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    4,     },
+    {P_ENCP_VIDEO_EQPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    4,     },
+    {P_ENCP_VIDEO_VAVON_BLINE,     20,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     559,   },
+    {P_ENCP_VIDEO_VSO_BEGIN,       88,    },
+    {P_ENCP_VIDEO_VSO_END,         88,    },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
+    {P_ENCP_VIDEO_YFP1_HTIME,      516,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      4355,  },
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_ENCP_VIDEO_OFLD_VOAV_OFST,  0x11   },
+    {P_ENCP_VIDEO_MODE,            0x5ffc,},
+    {P_ENCP_VIDEO_MODE_ADV,        0x0019,},
+    {P_ENCP_VIDEO_SYNC_MODE,       0x207, },
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,},
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_ENCP_DACSEL_0,              0x3102,},
+    {P_ENCP_DACSEL_1,              0x0054,},
+    {P_VENC_VDAC_DACSEL0,          0x0001,},
+    {P_VENC_VDAC_DACSEL1,          0x0001,},
+    {P_VENC_VDAC_DACSEL2,          0x0001,},
+    {P_VENC_VDAC_DACSEL3,          0x0001,},
+    {P_VENC_VDAC_DACSEL4,          0x0001,},
+    {P_VENC_VDAC_DACSEL5,          0x0001,},
+    {P_ENCI_VIDEO_EN,              0,     },
+    {P_ENCP_VIDEO_EN,              1,     },
     {MREG_END_MARKER,            0      }
 };
 
 static const reg_t tvregs_1080i_50hz[] = {
-    {VENC_VDAC_SETTING,          0xff,  },
+    {P_VENC_VDAC_SETTING,          0xff,  },
 //	{VCLK_HD},
-	    {HHI_VID_CLK_CNTL,           0x0,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928},
-    {HHI_VID_PLL_CNTL3,          0x6b425012},
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001043e,},
-    {HHI_VID_DIVIDER_CNTL,       0x00010843,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-    {ENCP_VIDEO_FILT_CTRL,       0x0052,},
-
-    {VENC_DVI_SETTING,           0x202d,},
-    {ENCP_VIDEO_MAX_PXCNT,       5279,  },
-    {ENCP_VIDEO_MAX_LNCNT,       1124,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x0052,},
+
+    {P_VENC_DVI_SETTING,           0x202d,},
+    {P_ENCP_VIDEO_MAX_PXCNT,       5279,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       1124,  },
 
     //analog vidoe position in horizontal
-    {ENCP_VIDEO_HSPULS_BEGIN,    88,    },
-    {ENCP_VIDEO_HSPULS_END,      264,   },
-    {ENCP_VIDEO_HSPULS_SWITCH,   88,    },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    88,    },
+    {P_ENCP_VIDEO_HSPULS_END,      264,   },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   88,    },
 
     //DE position in horizontal
-    {ENCP_VIDEO_HAVON_BEGIN,     526,   },
-    {ENCP_VIDEO_HAVON_END,       4365,  },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     526,   },
+    {P_ENCP_VIDEO_HAVON_END,       4365,  },
 
     //ditital hsync positon in horizontal
-    {ENCP_VIDEO_HSO_BEGIN,       142,   },
-    {ENCP_VIDEO_HSO_END,         230,   },
+    {P_ENCP_VIDEO_HSO_BEGIN,       142,   },
+    {P_ENCP_VIDEO_HSO_END,         230,   },
 
     /* vsync horizontal timing */
-    {ENCP_VIDEO_EQPULS_BEGIN,    2728,  },
-    {ENCP_VIDEO_EQPULS_END,      2904,  },
-    {ENCP_VIDEO_VSPULS_BEGIN,    440,   },
-    {ENCP_VIDEO_VSPULS_END,      2200,  },
+    {P_ENCP_VIDEO_EQPULS_BEGIN,    2728,  },
+    {P_ENCP_VIDEO_EQPULS_END,      2904,  },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    440,   },
+    {P_ENCP_VIDEO_VSPULS_END,      2200,  },
 
-    {ENCP_VIDEO_VSPULS_BLINE,    0,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    4,     },
-    {ENCP_VIDEO_EQPULS_BLINE,    0,     },
-    {ENCP_VIDEO_EQPULS_ELINE,    4,     },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    4,     },
+    {P_ENCP_VIDEO_EQPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    4,     },
 
     //DE position in vertical
-    {ENCP_VIDEO_VAVON_BLINE,     20,    },
-    {ENCP_VIDEO_VAVON_ELINE,     559,   },
+    {P_ENCP_VIDEO_VAVON_BLINE,     20,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     559,   },
 
     //adjust vsync start point and end point
-    {ENCP_VIDEO_VSO_BEGIN,       142,    },
-    {ENCP_VIDEO_VSO_END,         142,    },
+    {P_ENCP_VIDEO_VSO_BEGIN,       142,    },
+    {P_ENCP_VIDEO_VSO_END,         142,    },
 
     //adjust the vsync start line and end line
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_VSO_ELINE,       5,     },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
 
     /* filter & misc settings */
-    {ENCP_VIDEO_YFP1_HTIME,      526,   },
-    {ENCP_VIDEO_YFP2_HTIME,      4365,  },
+    {P_ENCP_VIDEO_YFP1_HTIME,      526,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      4365,  },
 
-    {VENC_VIDEO_PROG_MODE,       0x100, },  // Select clk108 as DAC clock, progressive mode
-    {ENCP_VIDEO_OFLD_VOAV_OFST,  0x11   },//bit[15:12]: Odd field VSO  offset begin,
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },  // Select clk108 as DAC clock, progressive mode
+    {P_ENCP_VIDEO_OFLD_VOAV_OFST,  0x11   },//bit[15:12]: Odd field VSO  offset begin,
                                                         //bit[11:8]: Odd field VSO  offset end,
                                                         //bit[7:4]: Odd field VAVON offset begin,
                                                         //bit[3:0]: Odd field VAVON offset end,
-    {ENCP_VIDEO_MODE,            0x5ffc,},//Enable Hsync and equalization pulse switch in center
-    {ENCP_VIDEO_MODE_ADV,        0x0019,}, //bit6:swap PbPr; bit4:YPBPR gain as HDTV type;
+    {P_ENCP_VIDEO_MODE,            0x5ffc,},//Enable Hsync and equalization pulse switch in center
+    {P_ENCP_VIDEO_MODE_ADV,        0x0019,}, //bit6:swap PbPr; bit4:YPBPR gain as HDTV type;
                                                  //bit3:Data input from VFIFO;bit[2}0]:repreat pixel a time
-    {ENCP_VIDEO_SYNC_MODE,       0x7, }, //bit[15:8] -- adjust the vsync vertical position
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_FIFO_CTRL,        0x1000,},
-    {VENC_VDAC_SETTING,          0,     },
-    {ENCP_DACSEL_0,              0x3102,},
-    {ENCP_DACSEL_1,              0x0054,},
-    {VENC_VDAC_DACSEL0,          0x0001,},
-    {VENC_VDAC_DACSEL1,          0x0001,},
-    {VENC_VDAC_DACSEL2,          0x0001,},
-    {VENC_VDAC_DACSEL3,          0x0001,},
-    {VENC_VDAC_DACSEL4,          0x0001,},
-    {VENC_VDAC_DACSEL5,          0x0001,},
-    {ENCI_VIDEO_EN,              0,     },
-    {ENCP_VIDEO_EN,              1,     },
+    {P_ENCP_VIDEO_SYNC_MODE,       0x7, }, //bit[15:8] -- adjust the vsync vertical position
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,},
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_ENCP_DACSEL_0,              0x3102,},
+    {P_ENCP_DACSEL_1,              0x0054,},
+    {P_VENC_VDAC_DACSEL0,          0x0001,},
+    {P_VENC_VDAC_DACSEL1,          0x0001,},
+    {P_VENC_VDAC_DACSEL2,          0x0001,},
+    {P_VENC_VDAC_DACSEL3,          0x0001,},
+    {P_VENC_VDAC_DACSEL4,          0x0001,},
+    {P_VENC_VDAC_DACSEL5,          0x0001,},
+    {P_ENCI_VIDEO_EN,              0,     },
+    {P_ENCP_VIDEO_EN,              1,     },
     {MREG_END_MARKER,            0      }
 };
 
 static const reg_t tvregs_1080p[] = {
-    {VENC_VDAC_SETTING,          0xff,  },
-
-     {HHI_VID_CLK_CNTL,           0x0,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928},
-    {HHI_VID_PLL_CNTL3,          0x6b425012},
-     {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001043e,},
-    {HHI_VID_DIVIDER_CNTL,       0x00010843,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-
-
-    {ENCP_VIDEO_FILT_CTRL,       0x1052,},
-    {VENC_DVI_SETTING,           0x0001,},
-    {ENCP_VIDEO_MODE,            0x4040,},
-    {ENCP_VIDEO_MODE_ADV,        0x0018,},
-    {ENCP_VIDEO_YFP1_HTIME,      140,   },
-    {ENCP_VIDEO_YFP2_HTIME,      2060,  },
-    {ENCP_VIDEO_MAX_PXCNT,       2199,  },
-    {ENCP_VIDEO_HSPULS_BEGIN,    2156,  },//1980
-    {ENCP_VIDEO_HSPULS_END,      44,    },
-    {ENCP_VIDEO_HSPULS_SWITCH,   44,    },
-    {ENCP_VIDEO_VSPULS_BEGIN,    140,   },
-    {ENCP_VIDEO_VSPULS_END,      2059,  },
-    {ENCP_VIDEO_VSPULS_BLINE,    0,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    4,     },//35
-    {ENCP_VIDEO_HAVON_BEGIN,     148,   },
-    {ENCP_VIDEO_HAVON_END,       2067,  },
-    {ENCP_VIDEO_VAVON_BLINE,     41,    },
-    {ENCP_VIDEO_VAVON_ELINE,     1120,  },
-    {ENCP_VIDEO_HSO_BEGIN,       44,    },
-    {ENCP_VIDEO_HSO_END,         2156,  },
-    {ENCP_VIDEO_VSO_BEGIN,       2100,  },
-    {ENCP_VIDEO_VSO_END,         2164,  },
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_VSO_ELINE,       5,     },
-    {ENCP_VIDEO_MAX_LNCNT,       1124,  },
-    {VPU_VIU_VENC_MUX_CTRL,      0x000a,},      //New Add. If not set, when system boots up, switch panel to HDMI 1080P, nothing on TV.
-    {VENC_VIDEO_PROG_MODE,       0x100, },
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_SETTING,          0,     },
-    {VENC_VDAC_DACSEL0,          0x0001,},
-    {VENC_VDAC_DACSEL1,          0x0001,},
-    {VENC_VDAC_DACSEL2,          0x0001,},
-    {VENC_VDAC_DACSEL3,          0x0001,},
-    {VENC_VDAC_DACSEL4,          0x0001,},
-    {VENC_VDAC_DACSEL5,          0x0001,},
-    {VENC_VDAC_FIFO_CTRL,        0x1000,},
-    {ENCP_DACSEL_0,              0x3102,},
-    {ENCP_DACSEL_1,              0x0054,},
-    {ENCI_VIDEO_EN,              0,     },
-    {ENCP_VIDEO_EN,              1,     },
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x1052,},
+    {P_VENC_DVI_SETTING,           0x0001,},
+    {P_ENCP_VIDEO_MODE,            0x4040,},
+    {P_ENCP_VIDEO_MODE_ADV,        0x0018,},
+    {P_ENCP_VIDEO_YFP1_HTIME,      140,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      2060,  },
+    {P_ENCP_VIDEO_MAX_PXCNT,       2199,  },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    2156,  },//1980
+    {P_ENCP_VIDEO_HSPULS_END,      44,    },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   44,    },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    140,   },
+    {P_ENCP_VIDEO_VSPULS_END,      2059,  },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    4,     },//35
+    {P_ENCP_VIDEO_HAVON_BEGIN,     148,   },
+    {P_ENCP_VIDEO_HAVON_END,       2067,  },
+    {P_ENCP_VIDEO_VAVON_BLINE,     41,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     1120,  },
+    {P_ENCP_VIDEO_HSO_BEGIN,       44,    },
+    {P_ENCP_VIDEO_HSO_END,         2156,  },
+    {P_ENCP_VIDEO_VSO_BEGIN,       2100,  },
+    {P_ENCP_VIDEO_VSO_END,         2164,  },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
+    {P_ENCP_VIDEO_MAX_LNCNT,       1124,  },
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},      //New Add. If not set, when system boots up, switch panel to HDMI 1080P, nothing on TV.
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VENC_VDAC_DACSEL0,          0x0001,},
+    {P_VENC_VDAC_DACSEL1,          0x0001,},
+    {P_VENC_VDAC_DACSEL2,          0x0001,},
+    {P_VENC_VDAC_DACSEL3,          0x0001,},
+    {P_VENC_VDAC_DACSEL4,          0x0001,},
+    {P_VENC_VDAC_DACSEL5,          0x0001,},
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,},
+    {P_ENCP_DACSEL_0,              0x3102,},
+    {P_ENCP_DACSEL_1,              0x0054,},
+    {P_ENCI_VIDEO_EN,              0,     },
+    {P_ENCP_VIDEO_EN,              1,     },
     {MREG_END_MARKER,            0      }
 };
 
 static const reg_t tvregs_1080p_50hz[] = {
-    {VENC_VDAC_SETTING,          0xff,  },
-    {HHI_VID_CLK_CNTL,           0x0,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928},
-    {HHI_VID_PLL_CNTL3,          0x6b425012},
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001043e,},
-    {HHI_VID_DIVIDER_CNTL,       0x00010843,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-    {ENCP_VIDEO_FILT_CTRL,       0x1052,},
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x1052,},
 
     // bit 13    1          (delayed prog_vs)
     // bit 5:4:  2          (pixel[0])
@@ -823,323 +689,503 @@ static const reg_t tvregs_1080p_50hz[] = {
     // bit 2:    1          invert hsync or not
     // bit1:     1          (select viu sync)
     // bit0:     1          (progressive)
-    {VENC_DVI_SETTING,           0x000d,},
-    {ENCP_VIDEO_MAX_PXCNT,       2639,  },
-    {ENCP_VIDEO_MAX_LNCNT,       1124,  },
+    {P_VENC_DVI_SETTING,           0x000d,},
+    {P_ENCP_VIDEO_MAX_PXCNT,       2639,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       1124,  },
     /* horizontal timing settings */
-    {ENCP_VIDEO_HSPULS_BEGIN,    44,  },//1980
-    {ENCP_VIDEO_HSPULS_END,      132,    },
-    {ENCP_VIDEO_HSPULS_SWITCH,   44,    },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    44,  },//1980
+    {P_ENCP_VIDEO_HSPULS_END,      132,    },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   44,    },
 
     //DE position in horizontal
-    {ENCP_VIDEO_HAVON_BEGIN,     271,   },
-    {ENCP_VIDEO_HAVON_END,       2190,  },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     271,   },
+    {P_ENCP_VIDEO_HAVON_END,       2190,  },
 
     //ditital hsync positon in horizontal
-    {ENCP_VIDEO_HSO_BEGIN,       79 ,    },
-    {ENCP_VIDEO_HSO_END,         123,  },
+    {P_ENCP_VIDEO_HSO_BEGIN,       79 ,    },
+    {P_ENCP_VIDEO_HSO_END,         123,  },
 
     /* vsync horizontal timing */
-    {ENCP_VIDEO_VSPULS_BEGIN,    220,   },
-    {ENCP_VIDEO_VSPULS_END,      2140,  },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    220,   },
+    {P_ENCP_VIDEO_VSPULS_END,      2140,  },
 
     /* vertical timing settings */
-    {ENCP_VIDEO_VSPULS_BLINE,    0,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    4,     },//35
-    {ENCP_VIDEO_EQPULS_BLINE,    0,     },
-    {ENCP_VIDEO_EQPULS_ELINE,    4,     },//35
-    {ENCP_VIDEO_VAVON_BLINE,     41,    },
-    {ENCP_VIDEO_VAVON_ELINE,     1120,  },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    4,     },//35
+    {P_ENCP_VIDEO_EQPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    4,     },//35
+    {P_ENCP_VIDEO_VAVON_BLINE,     41,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     1120,  },
 
     //adjust the hsync & vsync start point and end point
-    {ENCP_VIDEO_VSO_BEGIN,       79,  },
-    {ENCP_VIDEO_VSO_END,         79,  },
+    {P_ENCP_VIDEO_VSO_BEGIN,       79,  },
+    {P_ENCP_VIDEO_VSO_END,         79,  },
 
     //adjust the vsync start line and end line
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_VSO_ELINE,       5,     },
-
-    {ENCP_VIDEO_YFP1_HTIME,      271,   },
-    {ENCP_VIDEO_YFP2_HTIME,      2190,  },
-    {VENC_VIDEO_PROG_MODE,       0x100, },
-    {ENCP_VIDEO_MODE,            0x0040,},
-    {ENCP_VIDEO_MODE_ADV,        0x0018,},
-
-    {ENCP_VIDEO_SYNC_MODE,       0x7, }, //bit[15:8] -- adjust the vsync vertical position
-
-    {ENCP_VIDEO_YC_DLY,          0,     },      //Y/Cb/Cr delay
-
-    {ENCP_VIDEO_RGB_CTRL, 2,},       // enable sync on B
-
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_FIFO_CTRL,        0x1000,},
-    {VENC_VDAC_SETTING,          0,     },
-    {VPU_VIU_VENC_MUX_CTRL,      0x000a,},
-    {ENCP_DACSEL_0,              0x3102,},
-    {ENCP_DACSEL_1,              0x0054,},
-    {VENC_VDAC_DACSEL0,          0x0001,},
-    {VENC_VDAC_DACSEL1,          0x0001,},
-    {VENC_VDAC_DACSEL2,          0x0001,},
-    {VENC_VDAC_DACSEL3,          0x0001,},
-    {VENC_VDAC_DACSEL4,          0x0001,},
-    {VENC_VDAC_DACSEL5,          0x0001,},
-    {ENCI_VIDEO_EN,              0,     },
-    {ENCP_VIDEO_EN,              1,     },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
+
+    {P_ENCP_VIDEO_YFP1_HTIME,      271,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      2190,  },
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_ENCP_VIDEO_MODE,            0x4040,},
+    {P_ENCP_VIDEO_MODE_ADV,        0x0018,},
+
+    {P_ENCP_VIDEO_SYNC_MODE,       0x7, }, //bit[15:8] -- adjust the vsync vertical position
+
+    {P_ENCP_VIDEO_YC_DLY,          0,     },      //Y/Cb/Cr delay
+
+    {P_ENCP_VIDEO_RGB_CTRL, 2,},       // enable sync on B
+
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,},
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},
+    {P_ENCP_DACSEL_0,              0x3102,},
+    {P_ENCP_DACSEL_1,              0x0054,},
+    {P_VENC_VDAC_DACSEL0,          0x0001,},
+    {P_VENC_VDAC_DACSEL1,          0x0001,},
+    {P_VENC_VDAC_DACSEL2,          0x0001,},
+    {P_VENC_VDAC_DACSEL3,          0x0001,},
+    {P_VENC_VDAC_DACSEL4,          0x0001,},
+    {P_VENC_VDAC_DACSEL5,          0x0001,},
+    {P_ENCI_VIDEO_EN,              0,     },
+    {P_ENCP_VIDEO_EN,              1,     },
     {MREG_END_MARKER,            0      }
 };
+
+static const reg_t tvregs_1080p_24hz[] = {
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x1052,},
+
+    // bit 13    1          (delayed prog_vs)
+    // bit 5:4:  2          (pixel[0])
+    // bit 3:    1          invert vsync or not
+    // bit 2:    1          invert hsync or not
+    // bit1:     1          (select viu sync)
+    // bit0:     1          (progressive)
+    {P_VENC_DVI_SETTING,           0x000d,},
+    {P_ENCP_VIDEO_MAX_PXCNT,       2749,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       1124,  },
+    /* horizontal timing settings */
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    44,  },//1980
+    {P_ENCP_VIDEO_HSPULS_END,      132,    },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   44,    },
+
+    //DE position in horizontal
+    {P_ENCP_VIDEO_HAVON_BEGIN,     271,   },
+    {P_ENCP_VIDEO_HAVON_END,       2190,  },
+
+    //ditital hsync positon in horizontal
+    {P_ENCP_VIDEO_HSO_BEGIN,       79 ,    },
+    {P_ENCP_VIDEO_HSO_END,         123,  },
+
+    /* vsync horizontal timing */
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    220,   },
+    {P_ENCP_VIDEO_VSPULS_END,      2140,  },
+
+    /* vertical timing settings */
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    4,     },//35
+    {P_ENCP_VIDEO_EQPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    4,     },//35
+    {P_ENCP_VIDEO_VAVON_BLINE,     41,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     1120,  },
+
+    //adjust the hsync & vsync start point and end point
+    {P_ENCP_VIDEO_VSO_BEGIN,       79,  },
+    {P_ENCP_VIDEO_VSO_END,         79,  },
+
+    //adjust the vsync start line and end line
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
+
+    {P_ENCP_VIDEO_YFP1_HTIME,      271,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      2190,  },
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_ENCP_VIDEO_MODE,            0x4040,},
+    {P_ENCP_VIDEO_MODE_ADV,        0x0018,},
+
+    {P_ENCP_VIDEO_SYNC_MODE,       0x7, }, //bit[15:8] -- adjust the vsync vertical position
+
+    {P_ENCP_VIDEO_YC_DLY,          0,     },      //Y/Cb/Cr delay
+
+    {P_ENCP_VIDEO_RGB_CTRL, 2,},       // enable sync on B
+
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_FIFO_CTRL,        0x1000,},
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},
+    {P_ENCP_DACSEL_0,              0x3102,},
+    {P_ENCP_DACSEL_1,              0x0054,},
+    {P_VENC_VDAC_DACSEL0,          0x0001,},
+    {P_VENC_VDAC_DACSEL1,          0x0001,},
+    {P_VENC_VDAC_DACSEL2,          0x0001,},
+    {P_VENC_VDAC_DACSEL3,          0x0001,},
+    {P_VENC_VDAC_DACSEL4,          0x0001,},
+    {P_VENC_VDAC_DACSEL5,          0x0001,},
+    {P_ENCI_VIDEO_EN,              0,     },
+    {P_ENCP_VIDEO_EN,              1,     },
+    {MREG_END_MARKER,            0      }
+};
+
+static const reg_t tvregs_4k2k_30hz[] = {
+    {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+    {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
+    {P_ENCP_VIDEO_YFP1_HTIME,       140},
+    {P_ENCP_VIDEO_YFP2_HTIME,       140+3840},
+
+    {P_ENCP_VIDEO_MAX_PXCNT,        3840+560-1},
+    {P_ENCP_VIDEO_HSPULS_BEGIN,     2156+1920},
+    {P_ENCP_VIDEO_HSPULS_END,       44},
+    {P_ENCP_VIDEO_HSPULS_SWITCH,    44},
+    {P_ENCP_VIDEO_VSPULS_BEGIN,     140},
+    {P_ENCP_VIDEO_VSPULS_END,       2059+1920},
+    {P_ENCP_VIDEO_VSPULS_BLINE,     0},
+    {P_ENCP_VIDEO_VSPULS_ELINE,     4},
+
+    {P_ENCP_VIDEO_HAVON_BEGIN,      148},
+    {P_ENCP_VIDEO_HAVON_END,        3987},
+    {P_ENCP_VIDEO_VAVON_BLINE,      89},
+    {P_ENCP_VIDEO_VAVON_ELINE,      2248},
+
+    {P_ENCP_VIDEO_HSO_BEGIN,	    44},
+    {P_ENCP_VIDEO_HSO_END, 		    2156+1920},
+    {P_ENCP_VIDEO_VSO_BEGIN,	    2100+1920},
+    {P_ENCP_VIDEO_VSO_END, 		    2164+1920},
+
+    {P_ENCP_VIDEO_VSO_BLINE,        51},
+    {P_ENCP_VIDEO_VSO_ELINE,        53},
+    {P_ENCP_VIDEO_MAX_LNCNT,        2249},
+
+    {P_ENCP_VIDEO_FILT_CTRL,        0x1000}, //bypass filter
+    {MREG_END_MARKER,            0      },
+};
+
+static const reg_t tvregs_4k2k_25hz[] = {
+    {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+    {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
+    {P_ENCP_VIDEO_YFP1_HTIME,       140},
+    {P_ENCP_VIDEO_YFP2_HTIME,       140+3840},
+
+    {P_ENCP_VIDEO_MAX_PXCNT,        3840+1440-1},
+    {P_ENCP_VIDEO_HSPULS_BEGIN,     2156+1920},
+    {P_ENCP_VIDEO_HSPULS_END,       44},
+    {P_ENCP_VIDEO_HSPULS_SWITCH,    44},
+    {P_ENCP_VIDEO_VSPULS_BEGIN,     140},
+    {P_ENCP_VIDEO_VSPULS_END,       2059+1920},
+    {P_ENCP_VIDEO_VSPULS_BLINE,     0},
+    {P_ENCP_VIDEO_VSPULS_ELINE,     4},
+
+    {P_ENCP_VIDEO_HAVON_BEGIN,      148},
+    {P_ENCP_VIDEO_HAVON_END,        3987},
+    {P_ENCP_VIDEO_VAVON_BLINE,      89},
+    {P_ENCP_VIDEO_VAVON_ELINE,      2248},
+
+    {P_ENCP_VIDEO_HSO_BEGIN,	    44},
+    {P_ENCP_VIDEO_HSO_END, 		    2156+1920},
+    {P_ENCP_VIDEO_VSO_BEGIN,	    2100+1920},
+    {P_ENCP_VIDEO_VSO_END, 		    2164+1920},
+
+    {P_ENCP_VIDEO_VSO_BLINE,        51},
+    {P_ENCP_VIDEO_VSO_ELINE,        53},
+    {P_ENCP_VIDEO_MAX_LNCNT,        2249},
+
+    {P_ENCP_VIDEO_FILT_CTRL,        0x1000}, //bypass filter
+    {MREG_END_MARKER,            0      },
+};
+
+static const reg_t tvregs_4k2k_24hz[] = {
+    {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+    {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
+    {P_ENCP_VIDEO_YFP1_HTIME,       140},
+    {P_ENCP_VIDEO_YFP2_HTIME,       140+3840},
+
+    {P_ENCP_VIDEO_MAX_PXCNT,        3840+1660-1},
+    {P_ENCP_VIDEO_HSPULS_BEGIN,     2156+1920},
+    {P_ENCP_VIDEO_HSPULS_END,       44},
+    {P_ENCP_VIDEO_HSPULS_SWITCH,    44},
+    {P_ENCP_VIDEO_VSPULS_BEGIN,     140},
+    {P_ENCP_VIDEO_VSPULS_END,       2059+1920},
+    {P_ENCP_VIDEO_VSPULS_BLINE,     0},
+    {P_ENCP_VIDEO_VSPULS_ELINE,     4},
+
+    {P_ENCP_VIDEO_HAVON_BEGIN,      148},
+    {P_ENCP_VIDEO_HAVON_END,        3987},
+    {P_ENCP_VIDEO_VAVON_BLINE,      89},
+    {P_ENCP_VIDEO_VAVON_ELINE,      2248},
+
+    {P_ENCP_VIDEO_HSO_BEGIN,	    44},
+    {P_ENCP_VIDEO_HSO_END, 		    2156+1920},
+    {P_ENCP_VIDEO_VSO_BEGIN,	    2100+1920},
+    {P_ENCP_VIDEO_VSO_END, 		    2164+1920},
+
+    {P_ENCP_VIDEO_VSO_BLINE,        51},
+    {P_ENCP_VIDEO_VSO_ELINE,        53},
+    {P_ENCP_VIDEO_MAX_LNCNT,        2249},
+
+    {P_ENCP_VIDEO_FILT_CTRL,        0x1000}, //bypass filter
+
+    {MREG_END_MARKER,            0      },
+};
+
+static const reg_t tvregs_4k2k_smpte[] = {      //24hz
+    {P_ENCP_VIDEO_MODE,             0x4040}, // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+    {P_ENCP_VIDEO_MODE_ADV,         0x0008}, // Sampling rate: 1
+    {P_ENCP_VIDEO_YFP1_HTIME,       140},
+    {P_ENCP_VIDEO_YFP2_HTIME,       140+3840+256},
+
+    {P_ENCP_VIDEO_MAX_PXCNT,        4096+1404-1},
+    {P_ENCP_VIDEO_HSPULS_BEGIN,     2156+1920},
+    {P_ENCP_VIDEO_HSPULS_END,       44},
+    {P_ENCP_VIDEO_HSPULS_SWITCH,    44},
+    {P_ENCP_VIDEO_VSPULS_BEGIN,     140},
+    {P_ENCP_VIDEO_VSPULS_END,       2059+1920},
+    {P_ENCP_VIDEO_VSPULS_BLINE,     0},
+    {P_ENCP_VIDEO_VSPULS_ELINE,     4},
+
+    {P_ENCP_VIDEO_HAVON_BEGIN,      148},
+    {P_ENCP_VIDEO_HAVON_END,        3987+256},
+    {P_ENCP_VIDEO_VAVON_BLINE,      89},
+    {P_ENCP_VIDEO_VAVON_ELINE,      2248},
+
+    {P_ENCP_VIDEO_HSO_BEGIN,	    44},
+    {P_ENCP_VIDEO_HSO_END, 		    2156+1920+256},
+    {P_ENCP_VIDEO_VSO_BEGIN,	    2100+1920+256},
+    {P_ENCP_VIDEO_VSO_END, 		    2164+1920+256},
+
+    {P_ENCP_VIDEO_VSO_BLINE,        51},
+    {P_ENCP_VIDEO_VSO_ELINE,        53},
+    {P_ENCP_VIDEO_MAX_LNCNT,        2249},
+
+    {P_ENCP_VIDEO_FILT_CTRL,        0x1000}, //bypass filter
+    {MREG_END_MARKER,            0      },
+};
+
 static const reg_t tvregs_vga_640x480[] = { // 25.17mhz 800 *525
-     {VENC_VDAC_SETTING,          0xff,  },
-    {HHI_VID_CLK_CNTL,           0x0,       },
-    {HHI_VID_PLL_CNTL,           0x2001042d,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928,},
-    {HHI_VID_PLL_CNTL3,          0x6b425012,    },
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001042a,},//50
-
-    {HHI_VID_DIVIDER_CNTL,       0x00011943,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-    {ENCP_VIDEO_FILT_CTRL,       0x1052,},
-    //{HHI_VID_CLK_DIV,            0x01000100,},
-    {ENCP_VIDEO_FILT_CTRL,       0x2052,},
-    {VENC_DVI_SETTING,           0x21,  },
-    {ENCP_VIDEO_MODE,            0,     },
-    {ENCP_VIDEO_MODE_ADV,        0x009,     },
-    {ENCP_VIDEO_YFP1_HTIME,      244,   },
-    {ENCP_VIDEO_YFP2_HTIME,      1630,  },
-    {ENCP_VIDEO_YC_DLY,          0,     },
-    {ENCP_VIDEO_MAX_PXCNT,       1599,  },
-    {ENCP_VIDEO_MAX_LNCNT,       525,   },
-    {ENCP_VIDEO_HSPULS_BEGIN,    0x60,  },
-    {ENCP_VIDEO_HSPULS_END,      0xa0,  },
-    {ENCP_VIDEO_HSPULS_SWITCH,   88,    },
-    {ENCP_VIDEO_VSPULS_BEGIN,    0,     },
-    {ENCP_VIDEO_VSPULS_END,      1589   },
-    {ENCP_VIDEO_VSPULS_BLINE,    0,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    5,     },
-    {ENCP_VIDEO_HAVON_BEGIN,     153,   },
-    {ENCP_VIDEO_HAVON_END,       1433,  },
-    {ENCP_VIDEO_VAVON_BLINE,     59,    },
-    {ENCP_VIDEO_VAVON_ELINE,     540,   },
-    {ENCP_VIDEO_SYNC_MODE,       0x07,  },
-    {VENC_VIDEO_PROG_MODE,       0x100,   },
-    {VENC_VIDEO_EXSRC,           0x0,   },
-    {ENCP_VIDEO_HSO_BEGIN,       0x3,   },
-    {ENCP_VIDEO_HSO_END,         0x5,   },
-    {ENCP_VIDEO_VSO_BEGIN,       0x3,   },
-    {ENCP_VIDEO_VSO_END,         0x5,   },
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_SY_VAL,          8,     },
-    {ENCP_VIDEO_SY2_VAL,         0x1d8, },
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_SETTING,          0,     },
+     {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x1052,},
+    //{P_HHI_VID_CLK_DIV,            0x01000100,},
+    {P_ENCP_VIDEO_FILT_CTRL,       0x2052,},
+    {P_VENC_DVI_SETTING,           0x21,  },
+    {P_ENCP_VIDEO_MODE,            0,     },
+    {P_ENCP_VIDEO_MODE_ADV,        0x009,     },
+    {P_ENCP_VIDEO_YFP1_HTIME,      244,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      1630,  },
+    {P_ENCP_VIDEO_YC_DLY,          0,     },
+    {P_ENCP_VIDEO_MAX_PXCNT,       1599,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       525,   },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    0x60,  },
+    {P_ENCP_VIDEO_HSPULS_END,      0xa0,  },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   88,    },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    0,     },
+    {P_ENCP_VIDEO_VSPULS_END,      1589   },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    5,     },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     153,   },
+    {P_ENCP_VIDEO_HAVON_END,       1433,  },
+    {P_ENCP_VIDEO_VAVON_BLINE,     59,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     540,   },
+    {P_ENCP_VIDEO_SYNC_MODE,       0x07,  },
+    {P_VENC_VIDEO_PROG_MODE,       0x100,   },
+    {P_VENC_VIDEO_EXSRC,           0x0,   },
+    {P_ENCP_VIDEO_HSO_BEGIN,       0x3,   },
+    {P_ENCP_VIDEO_HSO_END,         0x5,   },
+    {P_ENCP_VIDEO_VSO_BEGIN,       0x3,   },
+    {P_ENCP_VIDEO_VSO_END,         0x5,   },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_SY_VAL,          8,     },
+    {P_ENCP_VIDEO_SY2_VAL,         0x1d8, },
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_SETTING,          0,     },
     /////////////////////////////
-    {ENCP_VIDEO_RGB_CTRL,		 0,},
-    {VENC_UPSAMPLE_CTRL0,        0xc061,},
-    {VENC_UPSAMPLE_CTRL1,        0xd061,},
-    {VENC_UPSAMPLE_CTRL2,        0xe061,},
-    {VENC_VDAC_DACSEL0,          0xf003,},
-    {VENC_VDAC_DACSEL1,          0xf003,},
-    {VENC_VDAC_DACSEL2,          0xf003,},
-    {VENC_VDAC_DACSEL3,          0xf003,},
-    {VENC_VDAC_DACSEL4,          0xf003,},
-    {VENC_VDAC_DACSEL5,          0xf003,},
-    {VPU_VIU_VENC_MUX_CTRL,      0x000a,},
-    {VENC_VDAC_FIFO_CTRL,        0x1fc0,},
-    {ENCP_DACSEL_0,              0x0543,},
-    {ENCP_DACSEL_1,              0x0000,},
-
-    {ENCI_VIDEO_EN,              0      },
-    {ENCP_VIDEO_EN,              1      },
+    {P_ENCP_VIDEO_RGB_CTRL,		 0,},
+    {P_VENC_UPSAMPLE_CTRL0,        0xc061,},
+    {P_VENC_UPSAMPLE_CTRL1,        0xd061,},
+    {P_VENC_UPSAMPLE_CTRL2,        0xe061,},
+    {P_VENC_VDAC_DACSEL0,          0xf003,},
+    {P_VENC_VDAC_DACSEL1,          0xf003,},
+    {P_VENC_VDAC_DACSEL2,          0xf003,},
+    {P_VENC_VDAC_DACSEL3,          0xf003,},
+    {P_VENC_VDAC_DACSEL4,          0xf003,},
+    {P_VENC_VDAC_DACSEL5,          0xf003,},
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},
+    {P_VENC_VDAC_FIFO_CTRL,        0x1fc0,},
+    {P_ENCP_DACSEL_0,              0x0543,},
+    {P_ENCP_DACSEL_1,              0x0000,},
+
+    {P_ENCI_VIDEO_EN,              0      },
+    {P_ENCP_VIDEO_EN,              1      },
     {MREG_END_MARKER,            0      }
 /////////////////////////////////////
 };
 static const reg_t tvregs_svga_800x600[]={ //39.5mhz 1056 *628
-    {VENC_VDAC_SETTING,          0xff,  },
-    {HHI_VID_CLK_CNTL,           0x0,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928},
-    {HHI_VID_PLL_CNTL3,          0x6b425012},
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x00010422,},//79
-    {HHI_VID_DIVIDER_CNTL,       0x00010843,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-    {ENCP_VIDEO_FILT_CTRL,       0x0052,},
-    {VENC_DVI_SETTING,           0x2029,},
-    {ENCP_VIDEO_MODE,            0x0040,},
-    {ENCP_VIDEO_MODE_ADV,        0x0019,},
-    {ENCP_VIDEO_YFP1_HTIME,      500,   },
-    {ENCP_VIDEO_YFP2_HTIME,      2112,  },
-    {ENCP_VIDEO_MAX_PXCNT,       2111,  },
-    {ENCP_VIDEO_MAX_LNCNT,       628,   },//628
-    {ENCP_VIDEO_HSPULS_BEGIN,    0,    },
-    {ENCP_VIDEO_HSPULS_END,      230,   },
-    {ENCP_VIDEO_HSPULS_SWITCH,   80,    },
-    {ENCP_VIDEO_VSPULS_BEGIN,    0x58,   },
-    {ENCP_VIDEO_VSPULS_END,      0x80,  },
-    {ENCP_VIDEO_VSPULS_BLINE,    0,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    5,     },
-    {ENCP_VIDEO_EQPULS_BLINE,    0,     },
-    {ENCP_VIDEO_EQPULS_ELINE,    5,     },
-    {ENCP_VIDEO_HAVON_BEGIN,     267,   },//59
-    {ENCP_VIDEO_HAVON_END,       1866,  },//1659
-    {ENCP_VIDEO_VAVON_BLINE,    59,    },//59
-    {ENCP_VIDEO_VAVON_ELINE,     658,   },//659
-    {ENCP_VIDEO_HSO_BEGIN,       0,    },
-    {ENCP_VIDEO_HSO_END,         260,   },
-    {ENCP_VIDEO_VSO_BEGIN,       0,   },
-    {ENCP_VIDEO_VSO_END,         2200,   },
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_VSO_ELINE,       5,     },
-    {VENC_VIDEO_PROG_MODE,       0x100, },
-    {VENC_VIDEO_EXSRC,           0x0,   },
-    {ENCP_VIDEO_HSO_BEGIN,       0x3,   },
-    {ENCP_VIDEO_HSO_END,         0x5,   },
-    {ENCP_VIDEO_VSO_BEGIN,       0x3,   },
-    {ENCP_VIDEO_VSO_END,         0x5,   },
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_SY_VAL,          8,     },
-    {ENCP_VIDEO_SY2_VAL,         0x1d8, },
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_SETTING,          0,     },
-    //////////////////////////
-    {ENCP_VIDEO_RGB_CTRL,		 0,},
-    {VENC_UPSAMPLE_CTRL0,        0xc061,},
-    {VENC_UPSAMPLE_CTRL1,        0xd061,},
-    {VENC_UPSAMPLE_CTRL2,        0xe061,},
-    {VENC_VDAC_DACSEL0,          0xf003,},
-    {VENC_VDAC_DACSEL1,          0xf003,},
-    {VENC_VDAC_DACSEL2,          0xf003,},
-    {VENC_VDAC_DACSEL3,          0xf003,},
-    {VENC_VDAC_DACSEL4,          0xf003,},
-    {VENC_VDAC_DACSEL5,          0xf003,},
-    {VPU_VIU_VENC_MUX_CTRL,      0x000a,},
-    {VENC_VDAC_FIFO_CTRL,        0x1fc0,},
-    {ENCP_DACSEL_0,              0x0543,},
-    {ENCP_DACSEL_1,              0x0000,},
-    {ENCI_VIDEO_EN,              0      },
-    {ENCP_VIDEO_EN,              1      },
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x0052,},
+    {P_VENC_DVI_SETTING,           0x2029,},
+    {P_ENCP_VIDEO_MODE,            0x0040,},
+    {P_ENCP_VIDEO_MODE_ADV,        0x0019,},
+    {P_ENCP_VIDEO_YFP1_HTIME,      500,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      2112,  },
+    {P_ENCP_VIDEO_MAX_PXCNT,       2111,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       628,   },//628
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    0,    },
+    {P_ENCP_VIDEO_HSPULS_END,      230,   },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   80,    },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    0x58,   },
+    {P_ENCP_VIDEO_VSPULS_END,      0x80,  },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    5,     },
+    {P_ENCP_VIDEO_EQPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    5,     },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     267,   },//59
+    {P_ENCP_VIDEO_HAVON_END,       1866,  },//1659
+    {P_ENCP_VIDEO_VAVON_BLINE,    59,    },//59
+    {P_ENCP_VIDEO_VAVON_ELINE,     658,   },//659
+    {P_ENCP_VIDEO_HSO_BEGIN,       0,    },
+    {P_ENCP_VIDEO_HSO_END,         260,   },
+    {P_ENCP_VIDEO_VSO_BEGIN,       0,   },
+    {P_ENCP_VIDEO_VSO_END,         2200,   },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_VENC_VIDEO_EXSRC,           0x0,   },
+    {P_ENCP_VIDEO_HSO_BEGIN,       0x3,   },
+    {P_ENCP_VIDEO_HSO_END,         0x5,   },
+    {P_ENCP_VIDEO_VSO_BEGIN,       0x3,   },
+    {P_ENCP_VIDEO_VSO_END,         0x5,   },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_SY_VAL,          8,     },
+    {P_ENCP_VIDEO_SY2_VAL,         0x1d8, },
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_SETTING,          0,     },
+    {P_ENCP_VIDEO_RGB_CTRL,		 0,},
+    {P_VENC_UPSAMPLE_CTRL0,        0xc061,},
+    {P_VENC_UPSAMPLE_CTRL1,        0xd061,},
+    {P_VENC_UPSAMPLE_CTRL2,        0xe061,},
+    {P_VENC_VDAC_DACSEL0,          0xf003,},
+    {P_VENC_VDAC_DACSEL1,          0xf003,},
+    {P_VENC_VDAC_DACSEL2,          0xf003,},
+    {P_VENC_VDAC_DACSEL3,          0xf003,},
+    {P_VENC_VDAC_DACSEL4,          0xf003,},
+    {P_VENC_VDAC_DACSEL5,          0xf003,},
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},
+    {P_VENC_VDAC_FIFO_CTRL,        0x1fc0,},
+    {P_ENCP_DACSEL_0,              0x0543,},
+    {P_ENCP_DACSEL_1,              0x0000,},
+    {P_ENCI_VIDEO_EN,              0      },
+    {P_ENCP_VIDEO_EN,              1      },
     {MREG_END_MARKER,            0      }
 	//////////////////////////////
  };
 static const reg_t tvregs_xga_1024x768[] = {
-   /* {VENC_VDAC_SETTING,          0xff,  },
-    {HHI_VID_CLK_CNTL,           0x0,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928},
-    {HHI_VID_PLL_CNTL3,          0x6b425012},
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x0001043e,},
-    {HHI_VID_DIVIDER_CNTL,       0x00010843,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-    {ENCP_VIDEO_FILT_CTRL,       0x0052,},
-    {VENC_DVI_SETTING,           0x2029,},
-    {ENCP_VIDEO_MODE,            0x0040,},
-    {ENCP_VIDEO_MODE_ADV,        0x0009,},
-    {ENCP_VIDEO_YFP1_HTIME,      500,   },
-    {ENCP_VIDEO_YFP2_HTIME,      2500,  },
-    {ENCP_VIDEO_MAX_PXCNT,       2531,  },
-    {ENCP_VIDEO_MAX_LNCNT,       804,   },
-    {ENCP_VIDEO_HSPULS_BEGIN,    0,    },
-    {ENCP_VIDEO_HSPULS_END,      230,   },
-    {ENCP_VIDEO_HSPULS_SWITCH,   80,    },
-    {ENCP_VIDEO_VSPULS_BEGIN,    0x22,   },
-    {ENCP_VIDEO_VSPULS_END,      0xa0,  },
-    {ENCP_VIDEO_VSPULS_BLINE,    0,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    5,     },
-    {ENCP_VIDEO_EQPULS_BLINE,    0,     },
-    {ENCP_VIDEO_EQPULS_ELINE,    5,     },
-    {ENCP_VIDEO_HAVON_BEGIN,     59,   },
-    {ENCP_VIDEO_HAVON_END,       2106,  },
-    {ENCP_VIDEO_VAVON_BLINE,     59,    },
-    {ENCP_VIDEO_VAVON_ELINE,     827,   },//827
-    {ENCP_VIDEO_HSO_BEGIN,       0,    },
-    {ENCP_VIDEO_HSO_END,         260,   },
-    {ENCP_VIDEO_VSO_BEGIN,       0,   },
-    {ENCP_VIDEO_VSO_END,         2200,   },
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_VSO_ELINE,       5,     },
-    {VENC_VIDEO_PROG_MODE,       0x100, },
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_SETTING,          0,     },*/
-    {VENC_VDAC_SETTING,          0xff,  },
-    {HHI_VID_CLK_CNTL,           0x0,},
-    {HHI_VID_PLL_CNTL2,          0x814d3928},
-    {HHI_VID_PLL_CNTL3,          0x6b425012},
-    {HHI_VID_PLL_CNTL4,          0x110},
-    {HHI_VID_PLL_CNTL,           0x00010436,},
-    {HHI_VID_DIVIDER_CNTL,       0x00010843,},
-    {HHI_VID_CLK_DIV,            0x100},
-    {HHI_VID_CLK_CNTL,           0x80000,},
-    {HHI_VID_CLK_CNTL,           0x88001,},
-    {HHI_VID_CLK_CNTL,           0x80003,},
-    {HHI_VIID_CLK_DIV,           0x00000101,},
-    {ENCP_VIDEO_FILT_CTRL,       0x0052,},
-    {VENC_DVI_SETTING,           0x2029,},
-    {ENCP_VIDEO_MODE,            0x0040,},
-    {ENCP_VIDEO_MODE_ADV,        0x0009,},
-    {ENCP_VIDEO_YFP1_HTIME,      500,   },
-    {ENCP_VIDEO_YFP2_HTIME,      2500,  },
-    {ENCP_VIDEO_MAX_PXCNT,       2691,  },
-    {ENCP_VIDEO_MAX_LNCNT,       806,   },
-    {ENCP_VIDEO_HSPULS_BEGIN,    0,    },
-    {ENCP_VIDEO_HSPULS_END,      230,   },
-    {ENCP_VIDEO_HSPULS_SWITCH,   80,    },
-    {ENCP_VIDEO_VSPULS_BEGIN,    0x22,   },
-    {ENCP_VIDEO_VSPULS_END,      0xa0,  },
-    {ENCP_VIDEO_VSPULS_BLINE,    0,     },
-    {ENCP_VIDEO_VSPULS_ELINE,    5,     },
-    {ENCP_VIDEO_EQPULS_BLINE,    0,     },
-    {ENCP_VIDEO_EQPULS_ELINE,    5,     },
-    {ENCP_VIDEO_HAVON_BEGIN,     315,   },
-    {ENCP_VIDEO_HAVON_END,       2362,  },
-    {ENCP_VIDEO_VAVON_BLINE,     59,    },
-    {ENCP_VIDEO_VAVON_ELINE,     827,   },//827
-    {ENCP_VIDEO_HSO_BEGIN,       0,    },
-    {ENCP_VIDEO_HSO_END,         260,   },
-    {ENCP_VIDEO_VSO_BEGIN,       0,   },
-    {ENCP_VIDEO_VSO_END,         2200,   },
-    {ENCP_VIDEO_VSO_BLINE,       0,     },
-    {ENCP_VIDEO_VSO_ELINE,       5,     },
-    {VENC_VIDEO_PROG_MODE,       0x100, },
-    {VENC_SYNC_ROUTE,            0,     },
-    {VENC_INTCTRL,               0x200, },
-    {VFIFO2VD_CTL,               0,     },
-    {VENC_VDAC_SETTING,          0,     },
+   /* {P_VENC_VDAC_SETTING,          0xff,  },
+    {P_HHI_VID_CLK_CNTL,           0x0,},
+    {P_HHI_VID_PLL_CNTL2,          0x814d3928},
+    {P_HHI_VID_PLL_CNTL3,          0x6b425012},
+    {P_HHI_VID_PLL_CNTL4,          0x110},
+    {P_HHI_VID_PLL_CNTL,           0x0001043e,},
+    {P_HHI_VID_DIVIDER_CNTL,       0x00010843,},
+    {P_HHI_VID_CLK_DIV,            0x100},
+    {P_HHI_VID_CLK_CNTL,           0x80000,},
+    {P_HHI_VID_CLK_CNTL,           0x88001,},
+    {P_HHI_VID_CLK_CNTL,           0x80003,},
+    {P_HHI_VIID_CLK_DIV,           0x00000101,},
+    {P_ENCP_VIDEO_FILT_CTRL,       0x0052,},
+    {P_VENC_DVI_SETTING,           0x2029,},
+    {P_ENCP_VIDEO_MODE,            0x0040,},
+    {P_ENCP_VIDEO_MODE_ADV,        0x0009,},
+    {P_ENCP_VIDEO_YFP1_HTIME,      500,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      2500,  },
+    {P_ENCP_VIDEO_MAX_PXCNT,       2531,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       804,   },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    0,    },
+    {P_ENCP_VIDEO_HSPULS_END,      230,   },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   80,    },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    0x22,   },
+    {P_ENCP_VIDEO_VSPULS_END,      0xa0,  },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    5,     },
+    {P_ENCP_VIDEO_EQPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    5,     },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     59,   },
+    {P_ENCP_VIDEO_HAVON_END,       2106,  },
+    {P_ENCP_VIDEO_VAVON_BLINE,     59,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     827,   },//827
+    {P_ENCP_VIDEO_HSO_BEGIN,       0,    },
+    {P_ENCP_VIDEO_HSO_END,         260,   },
+    {P_ENCP_VIDEO_VSO_BEGIN,       0,   },
+    {P_ENCP_VIDEO_VSO_END,         2200,   },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_SETTING,          0,     },
+    */
+    {P_VENC_VDAC_SETTING,          0xff,  },
+
+    {P_ENCP_VIDEO_FILT_CTRL,       0x0052,},
+    {P_VENC_DVI_SETTING,           0x2029,},
+    {P_ENCP_VIDEO_MODE,            0x0040,},
+    {P_ENCP_VIDEO_MODE_ADV,        0x0009,},
+    {P_ENCP_VIDEO_YFP1_HTIME,      500,   },
+    {P_ENCP_VIDEO_YFP2_HTIME,      2500,  },
+    {P_ENCP_VIDEO_MAX_PXCNT,       2691,  },
+    {P_ENCP_VIDEO_MAX_LNCNT,       806,   },
+    {P_ENCP_VIDEO_HSPULS_BEGIN,    0,    },
+    {P_ENCP_VIDEO_HSPULS_END,      230,   },
+    {P_ENCP_VIDEO_HSPULS_SWITCH,   80,    },
+    {P_ENCP_VIDEO_VSPULS_BEGIN,    0x22,   },
+    {P_ENCP_VIDEO_VSPULS_END,      0xa0,  },
+    {P_ENCP_VIDEO_VSPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_VSPULS_ELINE,    5,     },
+    {P_ENCP_VIDEO_EQPULS_BLINE,    0,     },
+    {P_ENCP_VIDEO_EQPULS_ELINE,    5,     },
+    {P_ENCP_VIDEO_HAVON_BEGIN,     315,   },
+    {P_ENCP_VIDEO_HAVON_END,       2362,  },
+    {P_ENCP_VIDEO_VAVON_BLINE,     59,    },
+    {P_ENCP_VIDEO_VAVON_ELINE,     827,   },//827
+    {P_ENCP_VIDEO_HSO_BEGIN,       0,    },
+    {P_ENCP_VIDEO_HSO_END,         260,   },
+    {P_ENCP_VIDEO_VSO_BEGIN,       0,   },
+    {P_ENCP_VIDEO_VSO_END,         2200,   },
+    {P_ENCP_VIDEO_VSO_BLINE,       0,     },
+    {P_ENCP_VIDEO_VSO_ELINE,       5,     },
+    {P_VENC_VIDEO_PROG_MODE,       0x100, },
+    {P_VENC_SYNC_ROUTE,            0,     },
+    {P_VENC_INTCTRL,               0x200, },
+    {P_ENCP_VFIFO2VD_CTL,               0,     },
+    {P_VENC_VDAC_SETTING,          0,     },
     ////////////////////////
-    {ENCP_VIDEO_RGB_CTRL,		 0,},
-    {VENC_UPSAMPLE_CTRL0,        0xc061,},
-    {VENC_UPSAMPLE_CTRL1,        0xd061,},
-    {VENC_UPSAMPLE_CTRL2,        0xe061,},
-    {VENC_VDAC_DACSEL0,          0xf003,},
-    {VENC_VDAC_DACSEL1,          0xf003,},
-    {VENC_VDAC_DACSEL2,          0xf003,},
-    {VENC_VDAC_DACSEL3,          0xf003,},
-    {VENC_VDAC_DACSEL4,          0xf003,},
-    {VENC_VDAC_DACSEL5,          0xf003,},
-    {VPU_VIU_VENC_MUX_CTRL,      0x000a,},
-    {VENC_VDAC_FIFO_CTRL,        0x1fc0,},
-    {ENCP_DACSEL_0,              0x0543,},
-    {ENCP_DACSEL_1,              0x0000,},
-    {ENCI_VIDEO_EN,              0      },
-    {ENCP_VIDEO_EN,              1      },
+    {P_ENCP_VIDEO_RGB_CTRL,		 0,},
+    {P_VENC_UPSAMPLE_CTRL0,        0xc061,},
+    {P_VENC_UPSAMPLE_CTRL1,        0xd061,},
+    {P_VENC_UPSAMPLE_CTRL2,        0xe061,},
+    {P_VENC_VDAC_DACSEL0,          0xf003,},
+    {P_VENC_VDAC_DACSEL1,          0xf003,},
+    {P_VENC_VDAC_DACSEL2,          0xf003,},
+    {P_VENC_VDAC_DACSEL3,          0xf003,},
+    {P_VENC_VDAC_DACSEL4,          0xf003,},
+    {P_VENC_VDAC_DACSEL5,          0xf003,},
+    {P_VPU_VIU_VENC_MUX_CTRL,      0x000a,},
+    {P_VENC_VDAC_FIFO_CTRL,        0x1fc0,},
+    {P_ENCP_DACSEL_0,              0x0543,},
+    {P_ENCP_DACSEL_1,              0x0000,},
+    {P_ENCI_VIDEO_EN,              0      },
+    {P_ENCP_VIDEO_EN,              1      },
     {MREG_END_MARKER,            0      }
 	///////////////////////////////////
 
@@ -1148,17 +1194,28 @@ static const reg_t tvregs_xga_1024x768[] = {
 /* The sequence of register tables items must match the enum define in tvmode.h */
 static const reg_t *tvregsTab[] = {
     tvregs_480i,
+    tvregs_480i,        // For REPEAT MODE use, ENC setting is same
     tvregs_480cvbs,
     tvregs_480p,
+    tvregs_480p,        // For REPEAT MODE use, ENC setting is same
     tvregs_576i,
+    tvregs_576i,        // For REPEAT MODE use, ENC setting is same
     tvregs_576cvbs,
     tvregs_576p,
+    tvregs_576p,        // For REPEAT MODE use, ENC setting is same
     tvregs_720p,
     tvregs_1080i,       //Adjust tvregs_* sequences and match the enum define in tvmode.h
     tvregs_1080p,
     tvregs_720p_50hz,
     tvregs_1080i_50hz,
     tvregs_1080p_50hz,
+    tvregs_1080p_24hz,
+    tvregs_4k2k_30hz,
+    tvregs_4k2k_25hz,
+    tvregs_4k2k_24hz,
+    tvregs_4k2k_smpte,
+    tvregs_4k2k_30hz,         // FAKE 4k2k5g
+    tvregs_4k2k_30hz,         // 4k2k60hz
     tvregs_vga_640x480,
     tvregs_svga_800x600,
     tvregs_xga_1024x768
@@ -1166,17 +1223,28 @@ static const reg_t *tvregsTab[] = {
 
 static const tvinfo_t tvinfoTab[] = {
     {.xres =  720, .yres =  480, .id = "480i"},
+    {.xres =  720, .yres =  480, .id = "480i_rpt"},
     {.xres =  720, .yres =  480, .id = "480cvbs"},
     {.xres =  720, .yres =  480, .id = "480p"},
+    {.xres =  720, .yres =  480, .id = "480p_rpt"},
     {.xres =  720, .yres =  576, .id = "576i"},
+    {.xres =  720, .yres =  576, .id = "576i_rpt"},
     {.xres =  720, .yres =  576, .id = "576cvbs"},
     {.xres =  720, .yres =  576, .id = "576p"},
+    {.xres =  720, .yres =  576, .id = "576p_prt"},
     {.xres = 1280, .yres =  720, .id = "720p"},
     {.xres = 1920, .yres = 1080, .id = "1080i"},
     {.xres = 1920, .yres = 1080, .id = "1080p"},
     {.xres = 1280, .yres =  720, .id = "720p50hz"},
     {.xres = 1920, .yres = 1080, .id = "1080i50hz"},
     {.xres = 1920, .yres = 1080, .id = "1080p50hz"},
+    {.xres = 1920, .yres = 1080, .id = "1080p24hz"},
+    {.xres = 3840, .yres = 2160, .id = "4k2k30hz"},
+    {.xres = 3840, .yres = 2160, .id = "4k2k25hz"},
+    {.xres = 3840, .yres = 2160, .id = "4k2k24hz"},
+    {.xres = 4096, .yres = 2160, .id = "4k2ksmpte"},
+    {.xres = 4096, .yres = 2160, .id = "4k2k5g"},
+    {.xres = 4096, .yres = 2160, .id = "4k2k60hz"},
     {.xres = 640, .yres = 480, .id = "vga"},
     {.xres = 800, .yres = 600, .id = "svga"},
     {.xres = 1024, .yres = 768, .id = "xga"},
@@ -1184,8 +1252,8 @@ static const tvinfo_t tvinfoTab[] = {
 
 static inline void setreg(const reg_t *r)
 {
-    aml_write_reg32(CBUS_REG_ADDR(r->reg), r->val);
-    printk("[0x%x] = 0x%x\n", r->reg, r->val);
+	aml_write_reg32(r->reg, r->val);
+	//printk("[0x%x] = 0x%x\n", r->reg, r->val);
 }
 
 #endif /* TVREGS_H */
diff --git a/drivers/amlogic/display/vout/Makefile b/drivers/amlogic/display/vout/Makefile
index d661f10c874b..0ef5d7c3f740 100755
--- a/drivers/amlogic/display/vout/Makefile
+++ b/drivers/amlogic/display/vout/Makefile
@@ -4,8 +4,11 @@ display-objs-$(CONFIG_AM_LCD_OUTPUT)  += vdac_switch.o
 
 
 obj-$(CONFIG_AM_TV_OUTPUT)  += am_tvout.o
-am_tvout-objs :=   tvoutc.o  tvconf.o enc_clk_config.o
-
+am_tvout-objs :=   tvoutc.o  tvconf.o
+ifeq ($(CONFIG_ARCH_MESONG9TV),y)
+else
+am_tvout-objs += enc_clk_config.o
+endif
 obj-$(CONFIG_AM_LCD_OUTPUT)  += lcdoutc.o
 obj-$(CONFIG_AM_LCD_OUTPUT)  += lcd_extern/
 
diff --git a/drivers/amlogic/display/vout/enc_clk_config.c b/drivers/amlogic/display/vout/enc_clk_config.c
index c1aaaecad623..788d98fcb83c 100755
--- a/drivers/amlogic/display/vout/enc_clk_config.c
+++ b/drivers/amlogic/display/vout/enc_clk_config.c
@@ -58,6 +58,12 @@ static void set_hpll_clk_out(unsigned clk)
     check_clk_config(clk);
     printk("config HPLL\n");
 
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV
+    printk("%s[%d]\n", __FILE__, __LINE__);
+    printk("TODO\n");
+    return;
+#endif
+
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
     printk("%s[%d] clk = %d\n", __func__, __LINE__, clk);
     aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c88000);
diff --git a/drivers/amlogic/display/vout/tvconf.c b/drivers/amlogic/display/vout/tvconf.c
index bf672a7a51c8..edb0d5987f6d 100755
--- a/drivers/amlogic/display/vout/tvconf.c
+++ b/drivers/amlogic/display/vout/tvconf.c
@@ -469,6 +469,30 @@ static const vinfo_t tv_info[] =
         .sync_duration_den = 1,
         .video_clk         = 297000000,
     },
+    { /* VMODE_4K2K_FAKE_5G */
+        .name              = "4k2k5g",
+        .mode              = TVMODE_4K2K_FAKE_5G,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 50,
+        .sync_duration_den = 1,
+        .video_clk         = 495000000,
+    },
+    { /* VMODE_4K2K_60HZ */
+        .name              = "4k2k60hz",
+        .mode              = TVMODE_4K2K_60HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
     { /* VMODE_vga */
 		.name              = "vga",
 		.mode              = VMODE_VGA,
diff --git a/drivers/amlogic/display/vout/tvmode.h b/drivers/amlogic/display/vout/tvmode.h
index 54659c1b37f0..b24de47c8ab0 100755
--- a/drivers/amlogic/display/vout/tvmode.h
+++ b/drivers/amlogic/display/vout/tvmode.h
@@ -68,6 +68,8 @@ typedef enum {
 	TVMODE_4K2K_23HZ , // for framerate automation 4k2k 23.97hz
 #endif
     TVMODE_4K2K_SMPTE ,
+    TVMODE_4K2K_FAKE_5G ,
+    TVMODE_4K2K_60HZ ,
     TVMODE_VGA ,
     TVMODE_SVGA,
     TVMODE_XGA,
diff --git a/drivers/amlogic/display/vout/tvoutc.c b/drivers/amlogic/display/vout/tvoutc.c
index 757b84cc4527..d6405110654c 100755
--- a/drivers/amlogic/display/vout/tvoutc.c
+++ b/drivers/amlogic/display/vout/tvoutc.c
@@ -461,8 +461,8 @@ int tvoutc_setmode(tvmode_t mode)
 		(mode==TVMODE_1080I) || (mode==TVMODE_1080I_50HZ) ||
 		(mode==TVMODE_1080P) || (mode==TVMODE_1080P_50HZ) ||
 		(mode==TVMODE_1080P_24HZ) || (mode==TVMODE_4K2K_24HZ) ||
-		(mode==TVMODE_4K2K_25HZ) || (mode==TVMODE_4K2K_30HZ) ||
-		(mode==TVMODE_4K2K_SMPTE) )
+		(mode==TVMODE_4K2K_25HZ) || (mode==TVMODE_4K2K_30HZ) || (mode==TVMODE_4K2K_FAKE_5G) ||
+		(mode==TVMODE_4K2K_SMPTE) || (mode==TVMODE_4K2K_60HZ) )
 	{
 		WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0x0, 30, 1);
 	}
@@ -483,7 +483,7 @@ int tvoutc_setmode(tvmode_t mode)
     }else{
 	aml_write_reg32(P_PERIPHS_PIN_MUX_0, (aml_read_reg32(P_PERIPHS_PIN_MUX_0)&(~(3<<20))));
     }
-
+printk("%s[%d] mode is %d\n", __func__, __LINE__, mode);
 #if ((defined CONFIG_ARCH_MESON8) || (defined CONFIG_ARCH_MESON8B))
 	// for hdmi mode, leave the hpll setting to be done by hdmi module.
 	if( (mode==TVMODE_480CVBS) || (mode==TVMODE_576CVBS) )
@@ -546,6 +546,8 @@ int tvoutc_setmode(tvmode_t mode)
 		case TVMODE_4K2K_23HZ:
 #endif
         case TVMODE_4K2K_SMPTE:
+        case TVMODE_4K2K_FAKE_5G:
+        case TVMODE_4K2K_60HZ:
 		case TVMODE_VGA:
 		case TVMODE_SVGA:
 		case TVMODE_XGA:
diff --git a/drivers/amlogic/hdmi/Kconfig b/drivers/amlogic/hdmi/Kconfig
index 9f6d9ad49d35..71f6bf848ff6 100755
--- a/drivers/amlogic/hdmi/Kconfig
+++ b/drivers/amlogic/hdmi/Kconfig
@@ -1,14 +1,22 @@
 menu "HDMI TX Support"
 
+config AML_HDMI_TX_20
+        bool "HDMI 2.0 Output Enable"
+        default n
+        select SWITCH
+        select AM_DISPLAY_MODULE
+        help  
+                hdmi 2.0 output enable. It should be enalbe if board have hdmi 2.0 out interface
+
 config AML_HDMI_TX
-        bool "HDMI Output Enable"
+        bool "HDMI 1.4 Output Enable"
         default y
         select SWITCH
         select AM_DISPLAY_MODULE
-        help  
-                hdmi output enable,It should be enalbe if board have hdmi out interface
+        help
+                hdmi 1.4 output enable, It should be enalbe if board have hdmi 1.4 out interface
 
-if AML_HDMI_TX
+if AML_HDMI_TX || AML_HDMI_TX_20
 config AML_HDMI_TX_HDCP
         bool "HDMI HDCP Enable"
         default n
diff --git a/drivers/amlogic/hdmi/Makefile b/drivers/amlogic/hdmi/Makefile
index cb5f878b425d..8c66238a583f 100755
--- a/drivers/amlogic/hdmi/Makefile
+++ b/drivers/amlogic/hdmi/Makefile
@@ -1 +1,6 @@
 obj-$(CONFIG_AML_HDMI_TX)  +=  hdmi_tx/
+obj-$(CONFIG_AML_HDMI_TX_20)  +=  hdmi_tx_2/
+
+ifdef CONFIG_AML_HDMI_TX_20
+obj-y	+= hdmi_common/
+endif
diff --git a/drivers/amlogic/hdmi/hdmi_common/Makefile b/drivers/amlogic/hdmi/hdmi_common/Makefile
new file mode 100644
index 000000000000..6964e1c3a618
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_common/Makefile
@@ -0,0 +1,3 @@
+obj-y		+= hdmi_common.o
+
+hdmi_common-objs := hdmi_parameters.o
diff --git a/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c b/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
new file mode 100644
index 000000000000..aa80412ebb97
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
@@ -0,0 +1,647 @@
+#include <linux/kernel.h>
+#include <linux/amlogic/hdmi_tx/hdmi_common.h>
+
+static struct hdmi_format_para fmt_para_1920x1080p60_16x9 = {
+    .vic = HDMI_1920x1080p60_16x9,
+    .name = "1920x1080p60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 148500,
+    .timing = {
+        .pixel_freq = 148500,
+        .h_freq = 67500,
+        .v_freq = 60000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2200,
+        .h_blank = 280,
+        .h_front = 88,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 4,
+        .v_sync = 5,
+        .v_back = 36,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1920x1080p50_16x9 = {
+    .vic = HDMI_1920x1080p50_16x9,
+    .name = "1920x1080p50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 148500,
+    .timing = {
+        .pixel_freq = 148500,
+        .h_freq = 56250,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2640,
+        .h_blank = 720,
+        .h_front = 528,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 4,
+        .v_sync = 5,
+        .v_back = 36,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1920x1080p24_16x9 = {
+    .vic = HDMI_1920x1080p24_16x9,
+    .name = "1920x1080p24hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 27000,
+        .v_freq = 24000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2750,
+        .h_blank = 830,
+        .h_front = 638,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 4,
+        .v_sync = 5,
+        .v_back = 36,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p30_16x9 = {
+    .vic = HDMI_3840x2160p30_16x9,
+    .name = "3840x2160p30hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 297000,
+    .timing = {
+        .pixel_freq = 297000,
+        .h_freq = 67500,
+        .v_freq = 30000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 4400,
+        .h_blank = 560,
+        .h_front = 176,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p60_16x9 = {
+    .vic = HDMI_3840x2160p60_16x9,
+    .name = "3840x2160p60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .tmds_clk = 594000,
+    .timing = {
+        .pixel_freq = 594000,
+        .h_freq = 135000,
+        .v_freq = 60000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 4400,
+        .h_blank = 560,
+        .h_front = 176,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p50_16x9 = {
+    .vic = HDMI_3840x2160p50_16x9,
+    .name = "3840x2160p50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .tmds_clk = 594000,
+    .timing = {
+        .pixel_freq = 594000,
+        .h_freq = 112500,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 5280,
+        .h_blank = 1440,
+        .h_front = 1056,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p25_16x9 = {
+    .vic = HDMI_3840x2160p25_16x9,
+    .name = "3840x2160p25hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 297000,
+    .timing = {
+        .pixel_freq = 297000,
+        .h_freq = 56250,
+        .v_freq = 25000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 5280,
+        .h_blank = 1440,
+        .h_front = 1056,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p24_16x9 = {
+    .vic = HDMI_3840x2160p24_16x9,
+    .name = "3840x2160p24hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 297000,
+    .timing = {
+        .pixel_freq = 297000,
+        .h_freq = 54000,
+        .v_freq = 24000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 5500,
+        .h_blank = 1660,
+        .h_front = 1276,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_4096x2160p24_256x135 = {
+    .vic = HDMI_4096x2160p24_256x135,
+    .name = "4096x2160p24hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 297000,
+    .timing = {
+        .pixel_freq = 297000,
+        .h_freq = 54000,
+        .v_freq = 24000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 4096,
+        .h_total = 5500,
+        .h_blank = 1404,
+        .h_front = 1020,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1920x1080i60_16x9 = {
+    .vic = HDMI_1920x1080i60_16x9,
+    .name = "1920x1080i60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 0,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 33750,
+        .v_freq = 60000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2200,
+        .h_blank = 280,
+        .h_front = 88,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 2,
+        .v_sync = 5,
+        .v_back = 15,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1920x1080i50_16x9 = {
+    .vic = HDMI_1920x1080i50_16x9,
+    .name = "1920x1080i50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 0,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 28125,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2640,
+        .h_blank = 720,
+        .h_front = 528,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 2,
+        .v_sync = 5,
+        .v_back = 15,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1280x720p60_16x9 = {
+    .vic = HDMI_1280x720p60_16x9,
+    .name = "1280x720p60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 45000,
+        .v_freq = 60000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1280,
+        .h_total = 1650,
+        .h_blank = 370,
+        .h_front = 110,
+        .h_sync = 40,
+        .h_back = 220,
+        .v_active = 720,
+        .v_total = 750,
+        .v_blank = 30,
+        .v_front = 5,
+        .v_sync = 5,
+        .v_back = 20,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1280x720p50_16x9 = {
+    .vic = HDMI_1280x720p50_16x9,
+    .name = "1280x720p50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 37500,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1280,
+        .h_total = 1980,
+        .h_blank = 700,
+        .h_front = 440,
+        .h_sync = 40,
+        .h_back = 220,
+        .v_active = 720,
+        .v_total = 750,
+        .v_blank = 30,
+        .v_front = 5,
+        .v_sync = 5,
+        .v_back = 20,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_720x480p60_16x9 = {
+    .vic = HDMI_720x480p60_16x9,
+    .name = "720x480p60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 27000,
+    .timing = {
+        .pixel_freq = 27000,
+        .h_freq = 31469,
+        .v_freq = 59940,
+        .vsync_polarity = 0,
+        .hsync_polarity = 0,
+        .h_active = 720,
+        .h_total = 858,
+        .h_blank = 138,
+        .h_front = 16,
+        .h_sync = 62,
+        .h_back = 60,
+        .v_active = 480,
+        .v_total = 525,
+        .v_blank = 45,
+        .v_front = 9,
+        .v_sync = 6,
+        .v_back = 30,
+        .v_sync_ln = 7,
+    },
+};
+
+static struct hdmi_format_para fmt_para_720x480i60_16x9 = {
+    .vic = HDMI_720x480i60_16x9,
+    .name = "720x480i60hz",
+    .pixel_repetition_factor = 1,
+    .progress_mode = 0,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 27000,
+    .timing = {
+        .pixel_freq = 27000,
+        .h_freq = 15734,
+        .v_freq = 59940,
+        .vsync_polarity = 0,
+        .hsync_polarity = 0,
+        .h_active = 1440,
+        .h_total = 1716,
+        .h_blank = 276,
+        .h_front = 38,
+        .h_sync = 124,
+        .h_back = 114,
+        .v_active = 480,
+        .v_total = 525,
+        .v_blank = 45,
+        .v_front = 4,
+        .v_sync = 3,
+        .v_back = 15,
+        .v_sync_ln = 4,
+    },
+};
+
+static struct hdmi_format_para fmt_para_720x576p50_16x9 = {
+    .vic = HDMI_720x576p50_16x9,
+    .name = "720x576p50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 27000,
+    .timing = {
+        .pixel_freq = 27000,
+        .h_freq = 31250,
+        .v_freq = 50000,
+        .vsync_polarity = 0,
+        .hsync_polarity = 0,
+        .h_active = 720,
+        .h_total = 864,
+        .h_blank = 144,
+        .h_front = 12,
+        .h_sync = 64,
+        .h_back = 68,
+        .v_active = 576,
+        .v_total = 625,
+        .v_blank = 49,
+        .v_front = 5,
+        .v_sync = 5,
+        .v_back = 39,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_720x576i50_16x9 = {
+    .vic = HDMI_720x576i50_16x9,
+    .name = "720x576i50hz",
+    .pixel_repetition_factor = 1,
+    .progress_mode = 0,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 27000,
+    .timing = {
+        .pixel_freq = 27000,
+        .h_freq = 15625,
+        .v_freq = 50000,
+        .vsync_polarity = 0,
+        .hsync_polarity = 0,
+        .h_active = 1440,
+        .h_total = 1728,
+        .h_blank = 288,
+        .h_front = 24,
+        .h_sync = 126,
+        .h_back = 138,
+        .v_active = 576,
+        .v_total = 625,
+        .v_blank = 49,
+        .v_front = 2,
+        .v_sync = 3,
+        .v_back = 19,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para *all_fmt_paras[] = {
+    &fmt_para_3840x2160p60_16x9,
+    &fmt_para_3840x2160p50_16x9,
+    &fmt_para_3840x2160p30_16x9,
+    &fmt_para_3840x2160p25_16x9,
+    &fmt_para_3840x2160p24_16x9,
+    &fmt_para_4096x2160p24_256x135,
+    &fmt_para_1920x1080p50_16x9,
+    &fmt_para_1920x1080p60_16x9,
+    &fmt_para_1920x1080p24_16x9,
+    &fmt_para_1920x1080i60_16x9,
+    &fmt_para_1920x1080i50_16x9,
+    &fmt_para_1280x720p60_16x9,
+    &fmt_para_1280x720p50_16x9,
+    &fmt_para_720x480p60_16x9,
+    &fmt_para_720x480i60_16x9,
+    &fmt_para_720x576p50_16x9,
+    &fmt_para_720x576i50_16x9,
+};
+
+struct hdmi_format_para * hdmi_get_fmt_paras(HDMI_Video_Codes_t vic)
+{
+    int i;
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        if(vic == all_fmt_paras[i]->vic)
+            return all_fmt_paras[i];
+    }
+    return NULL;
+}
+
+// For check all format parameters only
+void check_detail_fmt(void)
+{
+    int i;
+    struct hdmi_format_para * p;
+    struct hdmi_cea_timing * t;
+    printk("VIC Hactive Vactive I/P Htotal Hblank Vtotal Vblank Hfreq Vfreq Pfreq\n");
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        p = all_fmt_paras[i];
+        t = &p->timing;
+        printk("%s[%d] %d %d %c %d %d %d %d %d %d %d\n", all_fmt_paras[i]->name, all_fmt_paras[i]->vic,
+                t->h_active, t->v_active, (p->progress_mode) ? 'P' : 'I',
+                t->h_total, t->h_blank, t->v_total, t->v_blank,
+                t->h_freq, t->v_freq, t->pixel_freq);
+    }
+
+    printk("\nVIC Hfront Hsync Hback Hpol Vfront Vsync Vback Vpol Ln\n");
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        p = all_fmt_paras[i];
+        t = &p->timing;
+        printk("%s[%d] %d %d %d %c %d %d %d %c %d\n", all_fmt_paras[i]->name, all_fmt_paras[i]->vic,
+                t->h_front, t->h_sync, t->h_back, (t->hsync_polarity) ? 'P' : 'N',
+                t->v_front, t->v_sync, t->v_back, (t->vsync_polarity) ? 'P' : 'N',
+                t->v_sync_ln);
+    }
+
+    printk("\nCheck Horizon parameter\n");
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        p = all_fmt_paras[i];
+        t = &p->timing;
+        if(t->h_total != (t->h_active + t->h_blank))
+            printk("VIC[%d] Ht[%d] != (Ha[%d] + Hb[%d])\n", all_fmt_paras[i]->vic,
+                   t->h_total, t->h_active, t->h_blank);
+        if(t->h_blank != (t->h_front + t->h_sync + t->h_back))
+            printk("VIC[%d] Hb[%d] != (Hf[%d] + Hs[%d] + Hb[%d])\n", all_fmt_paras[i]->vic, t->h_blank,
+                    t->h_front, t->h_sync, t->h_back);
+    }
+
+    printk("\nCheck Vertical parameter\n");
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        p = all_fmt_paras[i];
+        t = &p->timing;
+        if(t->v_total != (t->v_active + t->v_blank))
+            printk("VIC[%d] Vt[%d] != (Va[%d] + Vb[%d]\n", all_fmt_paras[i]->vic,
+                   t->v_total, t->v_active, t->v_blank);
+        if((t->v_blank != (t->v_front + t->v_sync + t->v_back)) & (p->progress_mode == 1))
+            printk("VIC[%d] Vb[%d] != (Vf[%d] + Vs[%d] + Vb[%d])\n", all_fmt_paras[i]->vic, t->v_blank,
+                    t->v_front, t->v_sync, t->v_back);
+        if((t->v_blank/2 != (t->v_front + t->v_sync + t->v_back)) & (p->progress_mode == 0))
+            printk("VIC[%d] Vb[%d] != (Vf[%d] + Vs[%d] + Vb[%d])\n", all_fmt_paras[i]->vic, t->v_blank,
+                    t->v_front, t->v_sync, t->v_back);
+    }
+}
+
+struct hdmi_audio_fs_fmt_n_cts aud_32k_para = {
+    .array[0] = {
+        .tmds_clk = 25174,
+        .n = 4576,
+        .cts = 28125,
+    },
+    .array[1] = {
+        .tmds_clk = 74176,
+        .n = 11648,
+        .cts = 210937,
+    },
+    .array[2] = {
+        .tmds_clk = 148352,
+        .n = 11648,
+        .cts = 421875,
+    },
+    .array[3] = {
+        .tmds_clk = 296703,
+        .n = 5824,
+        .cts = 421875,
+    },
+    .array[4] = {
+        .tmds_clk = 297000,
+        .n = 3072,
+        .cts = 222750,
+    },
+    .def_n = 4096,
+};
+
+static struct hdmi_audio_fs_fmt_n_cts *all_aud_paras [] = {
+    NULL,
+    &aud_32k_para,
+};
+
+unsigned int hdmi_get_aud_n_paras(audio_fs_t fs, unsigned int tmds_clk)
+{
+    struct hdmi_audio_fs_fmt_n_cts *p = NULL;
+    unsigned int i;
+
+    p = all_aud_paras[fs];
+    for(i = 0; i < AUDIO_PARA_MAX_NUM; i++) {
+        if(tmds_clk == p->array[i].tmds_clk)
+            break;
+    }
+
+    if((i < AUDIO_PARA_MAX_NUM) && (p->array[i].n))
+        return p->array[i].n;
+    else
+        return p->def_n;
+}
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/Makefile b/drivers/amlogic/hdmi/hdmi_tx_2/Makefile
new file mode 100644
index 000000000000..487ba81f01f0
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_AML_HDMI_TX_20)		+= hdmitx2.o
+
+hdmitx2-objs := hdmi_tx_main.o hdmi_tx_cec.o hdmi_cec_key.o hdmi_tx_video.o hdmi_tx_audio.o hdmi_tx_edid.o hdmi_tx_audio.o hdmi_tx_hdcp.o hdmi_tx_scdc.o
+
+#EXTRA_CFLAGS += -O2
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_cec_key.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_cec_key.c
new file mode 100644
index 000000000000..57652d771906
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_cec_key.c
@@ -0,0 +1,172 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+hdmitx_dev_t *hdmitx_device = NULL;
+
+__u16 cec_key_map[128] = {
+    KEY_SELECT, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, 0 , 0 , 0 ,//0x00
+    0 , KEY_HOMEPAGE , KEY_MENU, 0, 0, KEY_BACK, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x10
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_0 , KEY_1, KEY_2, KEY_3,KEY_4, KEY_5, KEY_6, KEY_7,//0x20
+    KEY_8 , KEY_9, KEY_DOT, 0, 0, 0, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x30
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    
+    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
+    KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x50
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
+    0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
+    0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
+    0 , 0, 0, 0, 0, 0, 0, 0x2fd,
+};
+
+void cec_send_event(cec_rx_message_t* pcec_message)
+{
+    int i;
+    unsigned char brdcst, opcode;
+    unsigned char initiator, follower;
+    unsigned char operand_num;
+    unsigned char msg_length;
+    unsigned char operands[14];
+    
+    /* parse message */
+    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0)) return;
+
+    initiator   = pcec_message->content.msg.header >> 4;
+    follower    = pcec_message->content.msg.header & 0x0f;
+    opcode      = pcec_message->content.msg.opcode;   
+    operand_num = pcec_message->operand_num;
+    brdcst      = (follower == 0x0f);
+    msg_length  = pcec_message->msg_length;
+    
+    for (i = 0; i < operand_num; i++ ) {
+       operands[i] = pcec_message->content.msg.operands[i]; 
+       hdmi_print(INF, CEC  ":operands[%d]:%u\n", i, operands[i]);       
+    }
+    if(cec_global_info.cec_flag.cec_key_flag) {
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 1);
+        input_sync(cec_global_info.remote_cec_dev);
+        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
+    }
+    else{
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 0);
+        input_sync(cec_global_info.remote_cec_dev);
+        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
+    }   
+}
+
+
+void cec_send_event_irq(void)
+{
+    int i;
+    unsigned char   operand_num_irq;
+    unsigned char operands_irq[14];
+         
+    operand_num_irq = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
+    for (i = 0; i < operand_num_irq; i++ )
+    {
+        operands_irq[i] = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[i]; 
+        hdmi_print(INF, CEC  ":operands_irq[%d]:0x%x\n", i, operands_irq[i]);       
+    }
+    
+    switch(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[0]){
+    case 0x33:
+        //cec_system_audio_mode_request();
+        //cec_set_system_audio_mode();
+        break;
+    case 0x35:
+        break;
+    default:
+        break;      
+    }	
+    
+    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 1);
+    input_sync(cec_global_info.remote_cec_dev);	
+    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 0);
+    input_sync(cec_global_info.remote_cec_dev);
+    hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands_irq[0]]);      		  	 	
+}
+
+void cec_user_control_pressed_irq(void)
+{
+    hdmi_print(INF, CEC  ": Key pressed \n");
+    cec_send_event_irq();
+}
+
+void cec_user_control_released_irq(void)  
+{
+    hdmi_print(INF, CEC  ": Key released \n");
+} 
+
+void cec_user_control_pressed(cec_rx_message_t* pcec_message)
+{
+    hdmi_print(INF, CEC  ": Key pressed \n");
+    cec_global_info.cec_flag.cec_key_flag = 1;
+    cec_send_event(pcec_message);
+}
+
+void cec_user_control_released(cec_rx_message_t* pcec_message)  
+{
+    hdmi_print(INF, CEC  ": Key released \n");
+    cec_global_info.cec_flag.cec_key_flag = 1;
+    cec_send_event(pcec_message);
+}
+
+
+/*
+ * STANDBY: get STANDBY command from TV
+ */
+void cec_standby(cec_rx_message_t* pcec_message)
+{
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
+            hdmi_print(INF, CEC  ": System will be in standby mode\n");
+            input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 1);
+            input_sync(cec_global_info.remote_cec_dev);
+            input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 0);
+            input_sync(cec_global_info.remote_cec_dev);
+        }
+    }
+}
+
+void cec_key_init(void)
+{
+    extern hdmitx_dev_t * get_hdmitx_device(void);
+    hdmitx_device = get_hdmitx_device();
+}
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_audio.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_audio.c
new file mode 100644
index 000000000000..5d66bde37a2e
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_audio.c
@@ -0,0 +1,236 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+
+#undef PCM_USE_INFOFRAME
+
+static const unsigned char channel_status_freq[]=
+{
+    0x0,
+    0x3, //32K
+    0x0, //44.1k
+    0x2, //48k
+    0x8, //88.2k
+    0xa, //96k
+    0xc, //176.4k
+    0xe, //192k
+};
+
+static const unsigned char channel_status_sample_word_length[]=
+{
+    0x0,
+    0x2, //16 bits
+    0x3, //20 bits
+    0xb //24 bits
+};
+
+void hdmi_tx_set_N_CTS(unsigned N_value, unsigned CTS)
+{
+}
+
+#if 0
+static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsigned char* AUD_DB, unsigned char* CHAN_STAT_BUF, int hdmi_ch)
+{
+#ifndef PCM_USE_INFOFRAME
+    if(audio_param->type == CT_PCM){
+        hdmi_print(INF, AUD "Audio Type: PCM\n");
+        if(AUD_DB){
+//Note: HDMI Spec V1.4 Page 154
+            if((audio_param->channel_num == CC_2CH) || (audio_param->channel_num == CC_REFER_TO_STREAM))
+                AUD_DB[0] = 0;
+            else
+                AUD_DB[0] = (0<<4)|(audio_param->channel_num);
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[2] = 0x0;
+            if(audio_param->channel_num == CC_6CH)
+                AUD_DB[3] = 0xb; //CA, 6 channel
+            else if(audio_param->channel_num == CC_8CH){
+                if(hdmi_ch == CC_6CH){
+                    AUD_DB[3] = 0x0b; //CA, 6 channel
+                }
+                else{
+                    AUD_DB[3] = 0x13; //CA, 8 channel
+               }
+            }
+            else
+                AUD_DB[3] = 0; //CA, 2 channel, default
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+        if(CHAN_STAT_BUF){
+            CHAN_STAT_BUF[2]=0x10|(audio_param->channel_num+1);  CHAN_STAT_BUF[24+2]=0x20|(audio_param->channel_num+1);
+            CHAN_STAT_BUF[3]=CHAN_STAT_BUF[24+3]=channel_status_freq[audio_param->sample_rate];
+            CHAN_STAT_BUF[4]=CHAN_STAT_BUF[24+4]=channel_status_sample_word_length[audio_param->sample_size]|
+                    ((~channel_status_freq[audio_param->sample_rate])<<4);
+        }
+    }
+    else if(audio_param->type == CT_AC_3){
+        hdmi_print(INF, AUD "Audio Type: AC3\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_AC_3<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_MPEG1){
+        hdmi_print(INF, AUD "Audio Type: MPEG1\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_MPEG1<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_MP3){
+        hdmi_print(INF, AUD "Audio Type: MP3\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_MP3<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_MPEG2){
+        hdmi_print(INF, AUD "Audio Type: MPEG2\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_MPEG2<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_AAC){
+        hdmi_print(INF, AUD "Audio Type: AAC\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_AAC<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_DTS){
+        hdmi_print(INF, AUD "Audio Type: DTS\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_DTS<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_ATRAC){
+        hdmi_print(INF, AUD "Audio Type: ATRAC\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_ATRAC<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_ONE_BIT_AUDIO){
+        hdmi_print(INF, AUD "Audio Type: One Bit Audio\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_ONE_BIT_AUDIO<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_DOLBY_D){
+        hdmi_print(INF, AUD "Audio Type: Dobly Digital +\n");
+        if(AUD_DB){
+            AUD_DB[0] = (FS_REFER_TO_STREAM<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+        if(CHAN_STAT_BUF){
+            CHAN_STAT_BUF[0] = CHAN_STAT_BUF[24+0]= 0x2;
+            CHAN_STAT_BUF[3] = CHAN_STAT_BUF[24+3]= 0x1e;
+            CHAN_STAT_BUF[4] = CHAN_STAT_BUF[24+4]= 0x1;
+        }
+    }
+    else if(audio_param->type == CT_DTS_HD){
+        hdmi_print(INF, AUD "Audio Type: DTS-HD\n");
+        if(AUD_DB){
+            AUD_DB[0] = (FS_REFER_TO_STREAM<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_MAT){
+        hdmi_print(INF, AUD "Audio Type: MAT(MLP)\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_MAT<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_DST){
+        hdmi_print(INF, AUD "Audio Type: DST\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_DST<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_WMA){
+        hdmi_print(INF, AUD "Audio Type: WMA Pro\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_WMA<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else
+#endif
+    {
+//        if(AUD_DB){
+//            AUD_DB[0] = (audio_param->type<<4)|audio_param->channel_num ;
+//            AUD_DB[1] = (audio_param->sample_rate<<2)|audio_param->sample_size;
+//            AUD_DB[3] = 0; //CA, 2 channel
+//            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+//        }
+//        if(CHAN_STAT_BUF){
+//            CHAN_STAT_BUF[3]=CHAN_STAT_BUF[24+3]=channel_status_freq[audio_param->sample_rate];
+//        }
+    }
+    AUD_DB[0] = AUD_DB[0] & 0xf;        // bit[7:4] always set to 0 in HDMI
+    AUD_DB[1] = 0;                      // always set to 0 in HDMI
+}
+#endif
+
+int hdmitx_set_audio(hdmitx_dev_t* hdmitx_device, Hdmi_tx_audio_para_t* audio_param, int hdmi_ch)
+{
+    int i,ret=-1;
+    unsigned char AUD_DB[32];
+    unsigned char CHAN_STAT_BUF[24*2];
+    for(i=0;i<32;i++) AUD_DB[i]=0;
+    for(i=0;i<(24*2);i++) CHAN_STAT_BUF[i]=0;
+    if(hdmitx_device->HWOp.SetAudMode(hdmitx_device, audio_param)>=0){
+//        hdmi_tx_construct_aud_packet(audio_param, AUD_DB, CHAN_STAT_BUF, hdmi_ch);
+
+//        hdmitx_device->HWOp.SetAudioInfoFrame(AUD_DB, CHAN_STAT_BUF);
+        ret = 0;
+    }
+    return ret;
+}
+
+
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_cec.c
new file mode 100644
index 000000000000..4dcee13db94a
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_cec.c
@@ -0,0 +1,2425 @@
+/*
+ * Amlogic Meson HDMI Transmitter Driver
+ * HDMI CEC Driver-----------HDMI_TX
+ * Copyright (C) 2011 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/switch.h>
+#include <linux/workqueue.h>
+#include <linux/poll.h>
+
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+
+static hdmitx_dev_t* hdmitx_device = NULL;
+static struct class *cec_class;
+static struct device *cec_device;
+static dev_t devno;
+#define DEVICE_NAME "aocec"
+
+#define CEC_MSG_BUF_SIZE 16
+static unsigned char msg_log_buf[512] = { 0 };
+
+void cec_do_tasklet(unsigned long data);
+DECLARE_TASKLET(cec_tasklet, cec_do_tasklet, 0);
+
+static DEFINE_SPINLOCK(p_tx_list_lock);
+//static DEFINE_SPINLOCK(p_rx_list_lock);
+static unsigned long cec_tx_list_flags;
+//static unsigned long cec_rx_list_flags;
+static unsigned int tx_msg_cnt = 0;
+static unsigned int rx_msg_cnt = 0;
+static struct list_head cec_tx_msg_phead = LIST_HEAD_INIT(cec_tx_msg_phead);
+static struct list_head cec_rx_msg_phead = LIST_HEAD_INIT(cec_rx_msg_phead);
+static unsigned char rx_msg[MAX_MSG];
+static unsigned char rx_len;
+static unsigned char g_rx_buf[128];
+static int g_rx_len = 0;
+
+struct cec_dev
+{
+    struct cdev cdev;
+    unsigned int current_len;
+    unsigned char cec_msg_buf[CEC_MSG_BUF_SIZE];
+    struct semaphore sem;
+    struct file_operations *ops;
+    wait_queue_head_t r_wait;
+    wait_queue_head_t w_wait;
+};
+
+static struct cec_dev *cec_devp;
+
+static int cec_open(struct inode *inode, struct file *file)
+{
+    hdmi_print(INF, CEC "file open!\n");
+    return 0;
+}
+
+static int cec_release(struct inode *inode, struct file *file)
+{
+    hdmi_print(INF, CEC "file release!\n");
+    return 0;
+}
+
+static ssize_t cec_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
+{
+//    unsigned long pp = *ppos;
+//    char * buf_tmp = buf;
+    int ret = 0;
+   // int n;
+   // int pos;
+    cec_usr_message_list_t *p, *ptmp;
+//    struct cec_dev *dev = cec_devp;
+//    DECLARE_WAITQUEUE(wait, current);
+//    down(&dev->sem);
+
+    printk("\ngoing to read cec data in driver........\n");
+    //add_wait_queue(&dev->r_wait, &wait);
+/*
+    list_for_each_entry_safe(p, ptmp, &cec_rx_msg_phead, list) 
+    {
+        {
+            pos = 0;
+            pos += sprintf(msg_log_buf + pos, "CEC111: read file: rx msg len: %d   dat: ", p->length);
+            for(n = 0; n < p->length; n++)
+            {
+                pos += sprintf(msg_log_buf + pos, "%02x ", p->msg[n]);
+            }
+            pos += sprintf(msg_log_buf + pos, "\n");
+
+            msg_log_buf[pos] = '\0';
+            printk("%s", msg_log_buf);
+        }
+
+        copy_to_user(buf, p->msg, p->length);
+        unregister_cec_rx_msg(p);
+    }
+
+return p->length;*/
+    list_for_each_entry_safe(p, ptmp, &cec_rx_msg_phead, list) {
+
+        // {
+        //     pos = 0;
+        //     pos += sprintf(msg_log_buf + pos, "\n-------file-------\nCEC: read file: rx msg len: %d   dat: ", p->length);
+        //     for(n = 0; n < p->length; n++) {
+        //         pos += sprintf(msg_log_buf + pos, "%02x ", p->msg[n]);
+        //     }
+        //     pos += sprintf(msg_log_buf + pos, "\n");
+
+        //     msg_log_buf[pos] = '\0';
+        //     printk("%s", msg_log_buf);
+        // }
+/*        if(filp->f_flags & O_NONBLOCK)
+        {
+            ret = - EAGAIN;
+            goto out;
+        }
+        __set_current_state(TASK_INTERRUPTIBLE);
+        up(&dev->sem);
+
+        schedule();
+        if(signal_pending(current))
+        {
+            ret = - ERESTARTSYS;
+            goto out2;
+        }
+        down(&dev->sem);*/
+        // if (pp >= p->length)
+        // {
+        //     return count ? -ENXIO : 0;
+        // }
+
+/*        if(pp >= 16)
+        {
+            printk("HDMI CEC:: pp >= 16!\n");
+            return count;
+        }
+        if(count > 16 - pp)
+            count = 16 - pp;*/
+
+        //pp += count;
+        #if 1
+        printk("The data len is:%d\n", g_rx_len);
+        if(copy_to_user(buf, g_rx_buf, g_rx_len))
+        {
+            ret = -EFAULT;
+            printk("HDMI CEC:: ret = -EFAULT\n");
+            //goto out;
+        }
+        ret = g_rx_len;
+
+        #else
+        p->msg[p->length] = '\0';
+        if(copy_to_user(buf_tmp, p->msg, p->length + 1))
+        {
+            ret = -EFAULT;
+            printk("HDMI CEC:: ret = -EFAULT\n");
+            //goto out;
+        }
+        else
+        {
+
+            {
+                pos = 0;
+                pos += sprintf(msg_log_buf + pos, "\n-------buf--------\nCEC: read buf: rx msg len: %d   dat: ", p->length);
+                for(n = 0; n < p->length; n++) {
+                    pos += sprintf(msg_log_buf + pos, "%02x ", buf_tmp[n]);
+                }
+                pos += sprintf(msg_log_buf + pos, "\n");
+
+                msg_log_buf[pos] = '\0';
+                printk("%s", msg_log_buf);
+            }
+
+            *ppos += p->length;
+            for(n = 0; n < p->length + 1; n++)
+            {
+                printk("buf_tmp[%d]:0x%02x\n", n, buf_tmp[n]);
+            }
+            
+            buf_tmp += (p->length + 1);
+
+            // memcpy(dev->cec_msg_buf, dev->cec_msg_buf, dev->current_len - count);
+            // dev->current_len -=count;
+            //wake_up_interruptible(&dev->w_wait);
+            ret = p->length; 
+
+            //printk(KERN_INFO "HDMI CEC:: read %d bytes, current_len: %d\n", count, dev->current_len);
+        }
+        #endif
+        unregister_cec_rx_msg(p);
+
+    }
+
+/*    while(dev->current_len == 0)
+    {
+        if(filp->f_flags & O_NONBLOCK)
+        {
+            ret = - EAGAIN;
+            goto out;
+        }
+        __set_current_state(TASK_INTERRUPTIBLE);
+        up(&dev->sem);
+
+        schedule();
+        if(signal_pending(current))
+        {
+            ret = - ERESTARTSYS;
+            goto out2;
+        }
+        down(&dev->sem);
+    }
+
+    if(count > dev->current_len)
+        count = dev->current_len;*/
+
+    // if(p >= CEC_MSG_BUF_SIZE)
+    //     return count ? -ENXIO : 0;
+    // if(count > CEC_MSG_BUF_SIZE - p)
+    //     count = CEC_MSG_BUF_SIZE - p;
+
+    // if(copy_to user(buf, (void*) (cec_dev.cec_msg_buf + p), count))
+/*    if(copy_to_user(buf, dev->cec_msg_buf, count))
+    {
+        ret = -EFAULT;
+        goto out;
+    }
+    else
+    {
+        // *ppos +=count;
+        memcpy(dev->cec_msg_buf, dev->cec_msg_buf, dev->current_len - count);
+        dev->current_len -=count;
+        wake_up_interruptible(&dev->w_wait);
+        ret = count; 
+
+        printk(KERN_INFO "HDMI CEC:: read %d bytes, current_len: %d\n", count, dev->current_len);
+    }*/
+    //out: up(&dev->sem);
+    //out2: remove_wait_queue(&dev->r_wait, &wait);
+    //set_current_state(TASK_RUNNING);
+    //return (ssize_t)(buf_tmp - buf);
+    return (ssize_t)(ret);
+}
+
+static ssize_t cec_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos)
+{
+    // unsigned long p = 16*(*ppos);
+    int ret = 0;
+    char param[32] = {0};
+    unsigned len = 0;
+    DECLARE_WAITQUEUE(wait, current);
+
+//    int i;
+    struct cec_dev *dev = cec_devp;
+
+    unsigned int idx = 0;
+    for(idx = 0; idx < count; idx++)
+    {
+        printk("data %d is:0x%x\n", idx, buf[idx]);
+        param[idx] = buf[idx];
+    }
+    len = count;
+    printk("len:%d\n", len);
+
+    //len = dispatch_buffer_parse(buf, "", param, count);
+
+    //down(&dev->sem);
+    add_wait_queue(&dev->w_wait, &wait);
+
+/*    while(dev->current_len == CEC_MSG_BUF_SIZE)
+    {
+        if(filp->f_flags * O_NONBLOCK)
+        {
+            ret = -EAGAIN;
+            goto out;
+        }
+        __set_current_state(TASK_INTERRUPTIBLE);
+        up(&dev->sem);
+
+        schedule();
+        if(signal_pending(current))
+        {
+            ret = -ERESTARTSYS;
+            goto out2;
+        }
+
+        down(&dev->sem);
+    }
+
+    // if(p >= CEC_MSG_BUF_SIZE)
+    //     return count ? -ENXIO : 0;
+
+    // if(count > CEC_MSG_BUF_SIZE - p)
+    //     count = CEC_MSG_BUF_SIZE - p;
+    if(count > CEC_MSG_BUF_SIZE - dev->current_len)
+        count = CEC_MSG_BUF_SIZE - dev->current_len;
+
+    if(copy_from_user(dev->cec_msg_buf + dev->current_len, buf, count))
+    {
+        ret = -EFAULT;
+        goto out;
+    }
+    else
+    {
+        // *ppos += count;
+        dev->current_len += count;
+        ret = count;
+
+        printk(KERN_INFO "HDMI CEC:: written %d bytes,current_len: %d \n", count, dev->current_len);
+        wake_up_interruptible(&dev->r_wait);
+    }
+*/
+
+    //if(len > CEC_MSG_BUF_SIZE)
+    //    len = CEC_MSG_BUF_SIZE;
+
+    register_cec_tx_msg(param, len);
+
+    //out: up(&dev->sem);
+    ret = count;
+    remove_wait_queue(&dev->w_wait, &wait);
+    // set_current_state(TASK_RUNNING);
+    return ret;
+}
+
+static long cec_ioctl(struct file* filp, unsigned int cmd,unsigned long arg)
+{
+    switch(cmd)
+    {
+        case 1:
+        case 2:
+        default:
+        return - EINVAL;
+    }
+    return 0;
+}
+
+
+static unsigned int cec_poll(struct file *filp, struct poll_table_struct *wait)
+{
+    unsigned int mask = 0;
+
+    struct cec_dev *dev = cec_devp;
+
+    //down(&dev->sem);
+
+    poll_wait(filp, &dev->r_wait, wait);
+    poll_wait(filp, &dev->w_wait, wait);
+
+    if(rx_msg_cnt >=100)
+    {
+        printk("HDMI CEC:: too many msg, rx_msg_cnt:%d\n", rx_msg_cnt);
+        return mask;
+    }
+    printk("cec_poll::tx_msg_cnt:%d\n", tx_msg_cnt);
+    if(tx_msg_cnt >=100)
+    {
+        printk("HDMI CEC:: too many msg, tx_msg_cnt:%d\n", tx_msg_cnt);
+        return mask;
+    }
+
+    if(rx_msg_cnt != 0)
+    {
+        mask|= POLLIN | POLLRDNORM;
+    }
+
+    if(tx_msg_cnt == 0)
+    {
+        mask |=POLLOUT | POLLWRNORM;
+    }
+
+    //up(&dev->sem);
+    return mask;
+}
+
+static struct file_operations cec_fops =
+{
+    .owner = THIS_MODULE,
+    .open = cec_open,
+    .release = cec_release,
+    .read = cec_read,
+    .write = cec_write,
+    .unlocked_ioctl = cec_ioctl,
+    .poll = cec_poll,
+};
+
+static void cec_setup_cdev(void)
+{
+    int err;
+
+    cdev_init(&cec_devp->cdev, &cec_fops);
+    cec_devp->cdev.owner = THIS_MODULE;
+    cec_devp->ops = &cec_fops;
+
+    err = cdev_add(&cec_devp->cdev, devno, 1);
+
+    if(err)
+    {
+        printk(KERN_NOTICE "Error %d adding cec\n", err);
+    }
+
+}
+
+DEFINE_SPINLOCK(cec_input_key);
+
+/* global variables */
+static    unsigned char    gbl_msg[MAX_MSG];
+cec_global_info_t cec_global_info;
+unsigned char rc_long_press_pwr_key = 0;
+EXPORT_SYMBOL(rc_long_press_pwr_key);
+bool cec_msg_dbg_en = 0;
+
+ssize_t    cec_lang_config_state(struct switch_dev *sdev, char *buf){
+    int pos=0;
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%c%c%c\n", (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >>16) & 0xff, 
+                                                  (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 8) & 0xff,
+                                                  (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 0) & 0xff);
+    return pos;  
+};
+
+struct switch_dev lang_dev = {    // android ics switch device
+    .name = "lang_config",
+    .print_state = cec_lang_config_state,
+    };
+EXPORT_SYMBOL(lang_dev);
+
+unsigned int menu_lang_array[] = {(((unsigned int)'c')<<16)|(((unsigned int)'h')<<8)|((unsigned int)'i'),
+                                  (((unsigned int)'e')<<16)|(((unsigned int)'n')<<8)|((unsigned int)'g'),
+                                  (((unsigned int)'j')<<16)|(((unsigned int)'p')<<8)|((unsigned int)'n'),
+                                  (((unsigned int)'k')<<16)|(((unsigned int)'o')<<8)|((unsigned int)'r'),
+                                  (((unsigned int)'f')<<16)|(((unsigned int)'r')<<8)|((unsigned int)'a'),
+                                  (((unsigned int)'g')<<16)|(((unsigned int)'e')<<8)|((unsigned int)'r')
+                                 };
+
+// CEC default setting
+static unsigned char * osd_name = "Amlogic MBox";
+static unsigned int vendor_id = 0x00;
+
+static irqreturn_t cec_isr_handler(int irq, void *dev_instance);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend hdmitx_cec_early_suspend_handler;
+static void hdmitx_cec_early_suspend(struct early_suspend *h)
+{
+    hdmi_print(INF, CEC "early suspend!\n");
+    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
+        hdmi_print(INF, CEC "HPD low!\n");
+        return;
+    }
+    
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+        cec_inactive_source();
+
+        if(rc_long_press_pwr_key == 1) {
+            cec_set_standby();
+            msleep(100);
+            hdmi_print(INF, CEC "get power-off command from Romote Control\n");
+            rc_long_press_pwr_key = 0;
+        }
+    }
+    cec_disable_irq();
+}
+
+static void hdmitx_cec_late_resume(struct early_suspend *h)
+{
+    cec_enable_irq();
+    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
+        hdmi_print(INF, CEC "HPD low!\n");
+        return;
+    }
+    
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        cec_hw_reset();//for M8 CEC standby.
+        cec_imageview_on_smp();
+        cec_active_source_smp();
+        msleep(200);
+        cec_active_source_smp();
+        cec_menu_status_smp(DEVICE_MENU_ACTIVE);
+    }
+    hdmi_print(INF, CEC "late resume\n");
+}
+
+#endif
+
+void cec_isr_post_process(void)
+{
+    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
+        return;
+    }
+    /* isr post process */
+    while(cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos) {
+        cec_handle_message(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_read_pos]));
+        (cec_global_info.cec_rx_msg_buf.rx_read_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? (cec_global_info.cec_rx_msg_buf.rx_read_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_read_pos++);
+    }
+}
+
+void cec_rx_cmd_post_process(void)
+{
+    cec_usr_message_list_t *p, *ptmp;
+    /* usr command post process */
+    list_for_each_entry_safe(p, ptmp, &cec_rx_msg_phead, list) {
+
+        unregister_cec_rx_msg(p);
+    }
+}
+
+void cec_tx_cmd_post_process(void)
+{
+    cec_usr_message_list_t *p, *ptmp;
+    /* usr command post process */
+    list_for_each_entry_safe(p, ptmp, &cec_tx_msg_phead, list) {
+        cec_ll_tx(p->msg, p->length);
+        unregister_cec_tx_msg(p);
+    }
+}
+
+static int detect_tv_support_cec(unsigned addr)
+{
+    unsigned int ret = 0;
+    unsigned char msg[1];
+    msg[0] = (addr<<4) | 0x0;       // 0x0, TV's root address
+    ret = cec_ll_tx_polling(msg, 1);
+    cec_hw_reset();
+    hdmi_print(INF, CEC "tv%s have CEC feature\n", ret ? " " : " don\'t ");
+    return (hdmitx_device->tv_cec_support = ret);
+}
+
+void cec_node_init(hdmitx_dev_t* hdmitx_device)
+{
+    struct vendor_info_data *vend_data = NULL;
+
+    int i, bool = 0;
+    const enum _cec_log_dev_addr_e player_dev[3] = {CEC_PLAYBACK_DEVICE_1_ADDR,
+                                                    CEC_PLAYBACK_DEVICE_2_ADDR,
+                                                    CEC_PLAYBACK_DEVICE_3_ADDR,
+                                                   };
+
+    unsigned long cec_phy_addr;
+
+    if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
+        hdmi_print(INF, CEC "CEC not ready\n");
+        return;
+    }
+    else {
+        hdmi_print(INF, CEC "CEC node init\n");
+    }
+
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+        return ;
+
+#if 1       //todo
+    if(hdmitx_device->config_data.vend_data)
+        vend_data = hdmitx_device->config_data.vend_data;
+    if((vend_data) && (vend_data->cec_osd_string)) {
+        i = strlen(vend_data->cec_osd_string);
+        if(i > 14) 
+            vend_data->cec_osd_string[14] = '\0';   // OSD string length must be less than 14 bytes
+        osd_name = vend_data->cec_osd_string;
+    }
+    if((vend_data) && (vend_data->vendor_id)) {
+        vendor_id = (vend_data->vendor_id ) & 0xffffff;
+    }
+#endif
+
+   cec_hw_init();
+
+    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12) |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
+
+//#ifdef G9_CEC
+#if 0
+    hdmi_print(INF, CEC "G9 CEC: start poll dev\n");
+    aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
+    cec_global_info.my_node_index = 0x4;
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0x4);
+    hdmi_print(INF, CEC "G9 CEC: node init end.\n");
+    return;
+#endif
+    
+    for(i = 0; i < 3; i++){ 
+	    hdmi_print(INF, CEC "CEC: start poll dev\n");
+        cec_polling_online_dev(player_dev[i], &bool);
+        i = 0;
+        bool = 0;
+        hdmi_print(INF, CEC "player_dev[%d]:0x%x\n", i, player_dev[i]);
+        if(bool == 0){  // 0 means that no any respond
+            // If VSDB is not valid,use last or default physical address.  
+            if(hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
+                hdmi_print(INF, CEC "no valid cec physical address\n");
+                if(aml_read_reg32(P_AO_DEBUG_REG1))
+                    hdmi_print(INF, CEC "use last physical address\n");
+                else{
+                    aml_write_reg32(P_AO_DEBUG_REG1, 0x1000);
+                    hdmi_print(INF, CEC "use default physical address\n"); 
+                }  
+            }else{
+                aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
+            } 
+            hdmi_print(INF, CEC "physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1));
+            
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;
+            cec_global_info.my_node_index = player_dev[i];
+            aml_write_reg32(P_AO_DEBUG_REG3, aml_read_reg32(P_AO_DEBUG_REG3) | (cec_global_info.my_node_index & 0xf));
+            cec_global_info.cec_node_info[player_dev[i]].log_addr = player_dev[i];
+            // Set Physical address
+            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = cec_phy_addr;
+
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.sys_audio_mode = OFF;
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF; 
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;         
+
+            cec_global_info.cec_node_info[player_dev[i]].cec_version = CEC_VERSION_14A;
+            cec_global_info.cec_node_info[player_dev[i]].vendor_id = vendor_id;
+            cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
+            cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
+            strcpy(cec_global_info.cec_node_info[player_dev[i]].osd_name, osd_name); //Max num: 14Bytes
+
+            cec_logic_addr_set(CEC_PLAYBACK_DEVICE_1_ADDR);
+            
+     		hdmi_print(INF, CEC "Set logical address: %d\n", player_dev[i]);
+
+            hdmi_print(INF, CEC "P_AO_DEBUG_REG0:0x%x\n" ,aml_read_reg32(P_AO_DEBUG_REG0));
+        	if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status == DEVICE_MENU_INACTIVE)
+        	    break;
+            msleep(100);
+			cec_report_physical_address_smp();
+            msleep(150);
+            cec_device_vendor_id((cec_rx_message_t*)0);
+
+            msleep(150);
+            cec_imageview_on_smp();
+            msleep(100);
+
+            // here, we need to detect whether TV is supporting the CEC function
+            // if not, jump out to save system time
+            //if(!detect_tv_support_cec(player_dev[i])) {
+            //    break;
+            //}
+            cec_get_menu_language_smp();
+            msleep(350);
+
+            cec_active_source_smp();
+            msleep(120);
+
+            cec_menu_status_smp(DEVICE_MENU_ACTIVE);
+            msleep(100);
+
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_ON;
+            break;
+        }
+    }
+    if(bool == 1)
+        hdmi_print(INF, CEC "Can't get a valid logical address\n");
+    else
+        hdmi_print(INF, CEC "cec node init: cec features ok !\n");
+}
+
+void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
+{
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+       return ;
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_ON_TO_STANDBY;
+    hdmi_print(INF, CEC "cec node uninit!\n");
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_STANDBY;
+}
+
+static int cec_task(void *data)
+{
+    extern void dump_hdmi_cec_reg(void);
+    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*) data;
+    cec_global_info.cec_flag.cec_init_flag = 1;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    hdmitx_cec_early_suspend_handler.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
+    hdmitx_cec_early_suspend_handler.suspend = hdmitx_cec_early_suspend;
+    hdmitx_cec_early_suspend_handler.resume = hdmitx_cec_late_resume;
+    hdmitx_cec_early_suspend_handler.param = hdmitx_device;
+
+    register_early_suspend(&hdmitx_cec_early_suspend_handler);
+#endif
+
+    // Get logical address
+
+    hdmi_print(INF, CEC "CEC task process\n");
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)){
+        msleep_interruptible(10000);
+        
+        cec_node_init(hdmitx_device);
+    }
+    while (1) {
+   /*  	if (kthread_should_stop()){
+     		break;
+     	}
+     	wait_event_interruptible(hdmitx_device->cec_wait_rx,
+		 cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos);*/
+        msleep_interruptible(10);
+        cec_isr_post_process();
+        cec_tx_cmd_post_process();
+    }
+
+    return 0;
+}
+
+/***************************** cec low level code end *****************************/
+
+
+/***************************** cec middle level code *****************************/
+
+
+void register_cec_rx_msg_sub(unsigned char *msg, unsigned char len )
+{
+    cec_usr_message_list_t* cec_rx_message_list = kmalloc(sizeof(cec_usr_message_list_t), GFP_ATOMIC);
+    int pos;
+    int n;
+
+    if (cec_rx_message_list != NULL)
+    {
+        memset(g_rx_buf, 0, sizeof(g_rx_buf));
+        g_rx_len = len;
+        memcpy(g_rx_buf, msg, g_rx_len);
+
+        memset(cec_rx_message_list, 0, sizeof(cec_usr_message_list_t));      
+        memcpy(cec_rx_message_list->msg, msg, len);
+        cec_rx_message_list->length = len;
+
+        //spin_lock_irqsave(&p_rx_list_lock, cec_rx_list_flags);
+        list_add_tail(&cec_rx_message_list->list, &cec_rx_msg_phead);
+        //spin_unlock_irqrestore(&p_rx_list_lock, cec_rx_list_flags);
+        rx_msg_cnt++;
+
+        //if(cec_msg_dbg_en  == 1)
+        {
+            pos = 0;
+            pos += sprintf(msg_log_buf + pos, "CEC: register rx msg len: %d   dat: ", len);
+            for(n = 0; n < len; n++) {
+                pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+            }
+            pos += sprintf(msg_log_buf + pos, "\n");
+
+            msg_log_buf[pos] = '\0';
+            printk("%s", msg_log_buf);
+        }
+    }
+}
+
+void register_cec_rx_msg(unsigned char *msg, unsigned char len )
+{
+    unsigned long flags;
+    spin_lock_irqsave(&cec_input_key,flags);
+    //memset((void*)(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos])), 0, sizeof(cec_rx_message_t));
+    memcpy(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.buffer, msg, len);
+
+    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num = len >= 2 ? len - 2 : 0;
+    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].msg_length = len;
+
+    //cec_input_handle_message();
+    register_cec_rx_msg_sub(msg, len);
+    (cec_global_info.cec_rx_msg_buf.rx_write_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? 
+    (cec_global_info.cec_rx_msg_buf.rx_write_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_write_pos++);
+    spin_unlock_irqrestore(&cec_input_key,flags);
+}
+
+void register_cec_tx_msg(unsigned char *msg, unsigned char len )
+{
+    cec_usr_message_list_t* cec_tx_message_list = kmalloc(sizeof(cec_usr_message_list_t), GFP_ATOMIC);
+    int pos;
+    int n;
+    if (cec_tx_message_list != NULL)
+    {
+        memset(cec_tx_message_list, 0, sizeof(cec_usr_message_list_t));
+        memcpy(cec_tx_message_list->msg, msg, len);
+        cec_tx_message_list->length = len;
+
+        spin_lock_irqsave(&p_tx_list_lock, cec_tx_list_flags);
+        list_add_tail(&cec_tx_message_list->list, &cec_tx_msg_phead);
+        spin_unlock_irqrestore(&p_tx_list_lock, cec_tx_list_flags);
+
+        tx_msg_cnt++;
+
+        //if(cec_msg_dbg_en  == 1)
+        {
+            pos = 0;
+            pos += sprintf(msg_log_buf + pos, "CEC: register tx msg len: %d   dat: ", len);
+            for(n = 0; n < len; n++) {
+                pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+            }
+            pos += sprintf(msg_log_buf + pos, "\n");
+
+            msg_log_buf[pos] = '\0';
+            printk("%s", msg_log_buf);
+        }
+    }
+    wake_up_interruptible(&cec_devp->w_wait);
+}
+
+void cec_do_tasklet(unsigned long data)
+{
+    register_cec_rx_msg(rx_msg, rx_len);
+    udelay(1000);
+    wake_up_interruptible(&cec_devp->r_wait);
+}
+
+void cec_input_handle_message(void)
+{
+    unsigned char   opcode;
+
+    opcode = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.opcode;
+
+    /* process key event messages from tv */
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        switch (opcode) {
+        case CEC_OC_USER_CONTROL_PRESSED:
+            // check valid msg
+            {
+                unsigned char opernum;
+                unsigned char follower;
+                opernum  = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
+                follower = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.header & 0x0f;
+                if(opernum != 1 || follower == 0xf) break;
+            }
+            cec_user_control_pressed_irq();
+            break;
+        default:
+            break;
+        }
+    }
+}
+
+void unregister_cec_rx_msg(cec_usr_message_list_t* cec_rx_message_list)
+{
+
+    if (cec_rx_message_list != NULL) {
+        list_del(&cec_rx_message_list->list);
+        kfree(cec_rx_message_list);
+        cec_rx_message_list = NULL;
+
+        if (rx_msg_cnt > 0) rx_msg_cnt--;
+    }
+}
+
+void unregister_cec_tx_msg(cec_usr_message_list_t* cec_tx_message_list)
+{
+
+    if (cec_tx_message_list != NULL) {
+        list_del(&cec_tx_message_list->list);
+        kfree(cec_tx_message_list);
+        cec_tx_message_list = NULL;
+        printk("unregister_cec_tx_msg::tx_msg_cnt:%d\n", tx_msg_cnt);
+        if (tx_msg_cnt > 0) tx_msg_cnt--;
+    }
+}
+
+unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
+{
+    unsigned char rt = 0;
+    unsigned char opcode;
+    unsigned char opernum;
+    unsigned char follower;
+    if (!pcec_message)
+        return rt;
+
+    opcode = pcec_message->content.msg.opcode;
+    opernum = pcec_message->operand_num;
+
+    switch (opcode) {
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_STANDBY:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_USER_CONTROL_RELEASED:
+        case CEC_OC_GIVE_OSD_NAME:
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+        case CEC_OC_GET_CEC_VERSION:
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_IMAGE_VIEW_ON:
+        case CEC_OC_ABORT_MESSAGE:
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+            if ( opernum == 0)  rt = 1;
+            break;
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_DECK_CONTROL:
+        case CEC_OC_DECK_STATUS:
+        case CEC_OC_GIVE_DECK_STATUS:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_PLAY:
+        case CEC_OC_MENU_REQUEST:
+        case CEC_OC_MENU_STATUS:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_USER_CONTROL_PRESSED:
+        case CEC_OC_CEC_VERSION:
+        case CEC_OC_REPORT_POWER_STATUS:
+        case CEC_OC_SET_AUDIO_RATE:
+            if ( opernum == 1)  rt = 1;
+            break;
+        case CEC_OC_INACTIVE_SOURCE:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_FEATURE_ABORT:
+        case CEC_OC_ACTIVE_SOURCE:
+        case CEC_OC_ROUTING_INFORMATION:
+        case CEC_OC_SET_STREAM_PATH:
+            if (opernum == 2) rt = 1;
+            break;
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+        case CEC_OC_SET_MENU_LANGUAGE:
+        case CEC_OC_DEVICE_VENDOR_ID:
+            if (opernum == 3) rt = 1;
+            break;
+        case CEC_OC_ROUTING_CHANGE:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+            if (opernum == 4) rt = 1;
+            break;
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+            if ((opernum > 3)&&(opernum < 15))  rt = 1;
+            break;
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+            if (opernum < 15)  rt = 1;
+            break;
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+            if (opernum == 7) rt = 1;
+            break;
+        case CEC_OC_SET_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+            if (opernum == 11) rt = 1;
+            break;
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+            if (opernum == 14) rt = 1;
+            break;
+        case CEC_OC_TIMER_STATUS:
+            if ((opernum == 1 || opernum == 3)) rt = 1;
+            break;
+        case CEC_OC_TUNER_DEVICE_STATUS:
+            if ((opernum == 5 || opernum == 8)) rt = 1;
+            break;
+        case CEC_OC_RECORD_ON:
+            if (opernum > 0 && opernum < 9)  rt = 1;
+            break;
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+            if ((opernum == 9 || opernum == 10)) rt = 1;
+            break;
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_SET_OSD_NAME:
+            if (opernum > 0 && opernum < 15) rt = 1;
+            break;
+        case CEC_OC_SET_OSD_STRING:
+            if (opernum > 1 && opernum < 15) rt = 1;
+            break;
+        case CEC_OC_VENDOR_COMMAND:
+            if (opernum < 15)   rt = 1;
+            break;
+        default:
+            rt = 1;
+            break;
+    }
+
+ // for CTS12.2
+    follower = pcec_message->content.msg.header & 0x0f;
+    switch (opcode) {
+        case CEC_OC_ACTIVE_SOURCE:
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+        case CEC_OC_ROUTING_CHANGE:
+        case CEC_OC_ROUTING_INFORMATION:
+        case CEC_OC_SET_STREAM_PATH:
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+        case CEC_OC_SET_MENU_LANGUAGE:
+        case CEC_OC_DEVICE_VENDOR_ID:
+            // broadcast only
+            if(follower != 0xf) rt = 0;
+            break;
+
+        case CEC_OC_IMAGE_VIEW_ON:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_INACTIVE_SOURCE:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_ON:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_SET_ANALOGUE_TIMER:
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_TIMER_STATUS:
+        case CEC_OC_CEC_VERSION:
+        case CEC_OC_GET_CEC_VERSION:
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_DECK_CONTROL:
+        case CEC_OC_DECK_STATUS:
+        case CEC_OC_GIVE_DECK_STATUS:
+        case CEC_OC_PLAY:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+        case CEC_OC_TUNER_DEVICE_STATUS:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+        case CEC_OC_VENDOR_COMMAND:
+        case CEC_OC_SET_OSD_STRING:
+        case CEC_OC_GIVE_OSD_NAME:
+        case CEC_OC_SET_OSD_NAME:
+        case CEC_OC_MENU_REQUEST:
+        case CEC_OC_MENU_STATUS:
+        case CEC_OC_USER_CONTROL_PRESSED:
+        case CEC_OC_USER_CONTROL_RELEASED:
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+        case CEC_OC_REPORT_POWER_STATUS:
+        case CEC_OC_FEATURE_ABORT:
+        case CEC_OC_ABORT_MESSAGE:
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_SET_AUDIO_RATE:
+            // directly addressed only
+            if(follower == 0xf) rt = 0;
+            break;
+
+        case CEC_OC_STANDBY:
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+            // both broadcast and directly addressed
+            break;
+
+        default:
+            break;
+    }
+
+    if ((rt == 0) & (opcode != 0)){
+        hdmirx_cec_dbg_print("CEC: opcode & opernum not match: %x, %x\n", opcode, opernum);
+    }
+    return rt;
+}
+
+static irqreturn_t cec_isr_handler(int irq, void *dev_instance)
+{
+    unsigned int intr_stat = 0;
+
+    //cec_disable_irq();
+    intr_stat = cec_intr_stat();
+    hdmi_print(INF, CEC "cec %s irq %x\n", (0x2 == intr_stat) ? "tx" : "rx",intr_stat);
+    if(!intr_stat){
+        cec_hw_reset();
+        return IRQ_HANDLED;
+    }
+        
+    if(intr_stat & (1<<1)) { // aocec tx intr
+        cec_tx_irq_handle();
+        //cec_enable_irq();
+        return IRQ_HANDLED;
+    }
+    
+    if((-1) == cec_rx_irq_handle(rx_msg, &rx_len)){
+        //cec_enable_irq();
+        return IRQ_HANDLED;
+    }
+
+    //register_cec_rx_msg(rx_msg, rx_len);
+    //wake_up(&hdmitx_device->cec_wait_rx);
+    tasklet_schedule(&cec_tasklet);
+
+    //cec_enable_irq();
+
+    return IRQ_HANDLED;
+}
+
+unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
+{
+    unsigned short us = CEC_UNREGISTERED_DEVICE_TYPE;
+    if ((1 << log_addr) & CEC_DISPLAY_DEVICE) {
+        us = CEC_DISPLAY_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_RECORDING_DEVICE) {
+        us = CEC_RECORDING_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_PLAYBACK_DEVICE) {
+        us = CEC_PLAYBACK_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_TUNER_DEVICE) {
+        us = CEC_TUNER_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_AUDIO_SYSTEM_DEVICE) {
+        us = CEC_AUDIO_SYSTEM_DEVICE_TYPE;
+    }
+
+    return us;
+}
+// -------------- command from cec devices ---------------------
+//***************************************************************
+void cec_device_vendor_id(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[5];
+    
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_DEVICE_VENDOR_ID;
+    msg[2] = (vendor_id >> 16) & 0xff;
+    msg[3] = (vendor_id >> 8) & 0xff;
+    msg[4] = (vendor_id >> 0) & 0xff;
+    
+    cec_ll_tx(msg, 5);
+}
+
+void cec_report_power_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_REPORT_POWER_STATUS;
+    msg[2] = cec_global_info.cec_node_info[index].power_status;
+    cec_ll_tx(msg, 3);
+
+}
+
+void cec_feature_abort(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char opcode = pcec_message->content.msg.opcode;
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+    unsigned char dst_log_addr = pcec_message->content.msg.header & 0xf;
+    if(dst_log_addr != 0xf){
+        unsigned char msg[4];
+        
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_FEATURE_ABORT;
+        msg[2] = opcode;
+        msg[3] = CEC_UNRECONIZED_OPCODE;
+        
+        cec_ll_tx(msg, 4);        
+    }
+}
+
+void cec_report_version(cec_rx_message_t* pcec_message)
+{
+    ;//todo
+}
+
+
+void cec_report_physical_address_smp(void)
+{
+    unsigned char msg[5]; 
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    msg[4] = cec_global_info.cec_node_info[index].dev_type;
+
+    cec_ll_tx(msg, 5);
+        
+}
+
+void cec_imageview_on_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_global_info.my_node_index;
+
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
+            msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+            msg[1] = CEC_OC_IMAGE_VIEW_ON;
+            cec_ll_tx(msg, 2);
+        }
+    }  
+}
+
+void cec_get_menu_language_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_global_info.my_node_index;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_GET_MENU_LANGUAGE;
+    
+    cec_ll_tx(msg, 2);
+    
+}
+
+void cec_menu_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char msg[3];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+
+     if(0xf != src_log_addr) {
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_MENU_STATUS;
+        msg[2] = cec_global_info.cec_node_info[index].menu_status;
+        cec_ll_tx(msg, 3);
+    }
+}
+
+void cec_menu_status_smp(cec_device_menu_state_e status)
+{
+    unsigned char msg[3];
+    unsigned char index = cec_global_info.my_node_index;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_MENU_STATUS;
+    if(status == DEVICE_MENU_ACTIVE){
+        msg[2] = DEVICE_MENU_ACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
+    }else{
+        msg[2] = DEVICE_MENU_INACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+    }
+    cec_ll_tx(msg, 3);
+}
+
+void cec_menu_status_smp_irq(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    if(1 == pcec_message->content.msg.operands[0]){
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+    }else if(0 == pcec_message->content.msg.operands[0]){
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
+    }
+}
+
+void cec_active_source_rx(cec_rx_message_t* pcec_message)
+{
+    unsigned int phy_addr_active;
+
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
+}
+
+void cec_active_source_smp(void)
+{
+    unsigned char msg[4];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;      
+
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
+            msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+            msg[1] = CEC_OC_ACTIVE_SOURCE;
+            msg[2] = phy_addr_ab;
+            msg[3] = phy_addr_cd;
+            cec_ll_tx(msg, 4);
+        }
+    }
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+}
+void cec_active_source(cec_rx_message_t* pcec_message)
+{
+    unsigned char msg[4];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_ACTIVE_SOURCE;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+}
+
+
+void cec_set_stream_path(cec_rx_message_t* pcec_message)
+{
+    unsigned int phy_addr_active;
+
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_active_source_smp();
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
+}
+void cec_set_system_audio_mode(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P1( index, CEC_TV_ADDR,
+            CEC_OC_SET_SYSTEM_AUDIO_MODE,
+            cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode
+            );
+
+    cec_ll_tx(gbl_msg, 3);
+    if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
+    else
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
+}
+
+void cec_system_audio_mode_request(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == OFF){
+        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
+                phy_addr_ab,
+                phy_addr_cd
+                );
+        cec_ll_tx(gbl_msg, 4);
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
+    }
+    else{
+        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST
+                );
+        cec_ll_tx(gbl_msg, 2);
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
+    }
+}
+
+void cec_report_audio_status(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P1( index, CEC_TV_ADDR,
+            CEC_OC_REPORT_AUDIO_STATUS,
+            cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_mute_status | \
+            cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_volume_status
+            );
+
+    cec_ll_tx(gbl_msg, 3);
+}
+void cec_request_active_source(cec_rx_message_t* pcec_message)
+{
+    cec_set_stream_path(pcec_message);
+}
+
+void cec_set_imageview_on_irq(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[2];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_IMAGE_VIEW_ON;
+
+    cec_ll_tx(msg, 2);
+}
+
+void cec_inactive_source(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[4];
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_INACTIVE_SOURCE;
+	msg[2] = phy_addr_ab;
+	msg[3] = phy_addr_cd;
+
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+}
+
+void cec_inactive_source_rx(cec_rx_message_t* pcec_message)
+{
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+}
+
+void cec_get_version(cec_rx_message_t* pcec_message)
+{
+    unsigned char dest_log_addr = pcec_message->content.msg.header&0xf;
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    if (0xf != dest_log_addr) {
+        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+        msg[1] = CEC_OC_CEC_VERSION;
+        msg[2] = CEC_VERSION_14A;
+        cec_ll_tx(msg, 3);
+    }
+}
+
+void cec_give_deck_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_DECK_STATUS;
+    msg[2] = 0x1a;
+    cec_ll_tx(msg, 3);
+}
+
+
+void cec_deck_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    if (cec_global_info.dev_mask & (1 << index)) {
+        cec_global_info.cec_node_info[index].specific_info.playback.deck_info = pcec_message->content.msg.operands[0];
+        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DECK_INfO;
+        hdmirx_cec_dbg_print("cec_deck_status: %x\n", cec_global_info.cec_node_info[index].specific_info.playback.deck_info);
+    }
+}
+
+// STANDBY: long press our remote control, send STANDBY to TV
+void cec_set_standby(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[2];
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_STANDBY;
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
+			cec_ll_tx(msg, 2);
+		}
+	}
+}
+
+void cec_set_osd_name(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+    unsigned char msg[16];
+
+    if(0xf != src_log_addr) {
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_SET_OSD_NAME;
+        memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
+
+        cec_ll_tx(msg, 2 + osd_len);
+    }
+}
+
+void cec_set_osd_name_init(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+    unsigned char msg[16];
+
+    msg[0] = ((index & 0xf) << 4) | 0;
+    msg[1] = CEC_OC_SET_OSD_NAME;
+    memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
+
+    cec_ll_tx(msg, 2 + osd_len);
+}
+
+void cec_vendor_cmd_with_id(cec_rx_message_t* pcec_message)
+{
+    ;//todo
+}
+
+
+void cec_set_menu_language(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+
+    if(0x0 == src_log_addr) {
+        cec_global_info.cec_node_info[index].menu_lang = (int)((pcec_message->content.msg.operands[0] << 16)  |
+                                                               (pcec_message->content.msg.operands[1] <<  8)  |
+                                                               (pcec_message->content.msg.operands[2]));
+
+        switch_set_state(&lang_dev, cec_global_info.cec_node_info[index].menu_lang);
+        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_MENU_LANGUAGE;
+        hdmirx_cec_dbg_print("cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff,
+                                                                 (cec_global_info.cec_node_info[index].menu_lang >> 8) & 0xff,
+                                                                 (cec_global_info.cec_node_info[index].menu_lang >> 0) & 0xff);
+    }
+}
+
+void cec_handle_message(cec_rx_message_t* pcec_message)
+{
+    unsigned char	brdcst, opcode;
+    unsigned char	initiator, follower;
+    unsigned char   operand_num;
+    unsigned char   msg_length;
+//#ifdef G9_CEC
+#if 0
+    return;
+#endif
+    /* parse message */
+    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0))
+        return;
+
+    initiator	= pcec_message->content.msg.header >> 4;
+    follower	= pcec_message->content.msg.header & 0x0f;
+    opcode		= pcec_message->content.msg.opcode;
+    operand_num = pcec_message->operand_num;
+    brdcst      = (follower == 0x0f);
+    msg_length  = pcec_message->msg_length;
+
+    if(0 == pcec_message->content.msg.header)
+        return;
+
+    /* process messages from tv polling and cec devices */
+    if(CEC_OC_GIVE_OSD_NAME == opcode)
+        cec_set_osd_name(pcec_message);
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+
+        switch (opcode) {
+        case CEC_OC_ACTIVE_SOURCE:
+            cec_active_source_rx(pcec_message);
+            break;
+        case CEC_OC_INACTIVE_SOURCE:
+            break;
+        case CEC_OC_CEC_VERSION:
+            break;
+        case CEC_OC_DECK_STATUS:
+            break;
+        case CEC_OC_DEVICE_VENDOR_ID:
+            break;
+        case CEC_OC_FEATURE_ABORT:
+            break;
+        case CEC_OC_GET_CEC_VERSION:
+            cec_get_version(pcec_message);
+            break;
+        case CEC_OC_GIVE_DECK_STATUS:
+            cec_give_deck_status(pcec_message);
+            break;
+        case CEC_OC_MENU_STATUS:
+            cec_menu_status_smp_irq(pcec_message);
+            break;
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+            break;
+        case CEC_OC_REPORT_POWER_STATUS:
+            break;
+        case CEC_OC_SET_OSD_NAME:
+            break;
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+            break;
+        case CEC_OC_SET_MENU_LANGUAGE:
+            cec_set_menu_language(pcec_message);
+            break;
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+            cec_report_physical_address_smp();
+            break;
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+            cec_device_vendor_id(pcec_message);
+            break;
+        case CEC_OC_GIVE_OSD_NAME:
+            break;
+        case CEC_OC_STANDBY:
+            cec_inactive_source_rx(pcec_message);
+            cec_standby(pcec_message);
+            break;
+        case CEC_OC_SET_STREAM_PATH:
+            cec_set_stream_path(pcec_message);
+            break;
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+            if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status != DEVICE_MENU_ACTIVE)
+                break;
+            cec_active_source_smp();
+            break;
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+            cec_report_power_status(pcec_message);
+            break;
+        case CEC_OC_USER_CONTROL_PRESSED:
+            break;
+        case CEC_OC_USER_CONTROL_RELEASED:
+            break;
+        case CEC_OC_IMAGE_VIEW_ON:      //not support in source
+            cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
+            break;
+        case CEC_OC_ROUTING_CHANGE:
+            cec_routing_change(pcec_message);
+            break;
+        case CEC_OC_ROUTING_INFORMATION:
+        	cec_routing_information(pcec_message);
+        	break;
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        	cec_report_audio_status();
+        	break;
+        case CEC_OC_MENU_REQUEST:
+            cec_menu_status(pcec_message);
+            break;
+        case CEC_OC_PLAY:
+            hdmi_print(INF,CEC, "CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);
+            switch(pcec_message->content.msg.operands[0]){
+                case 0x24:
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    break;
+                case 0x25:
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case CEC_OC_DECK_CONTROL:
+            hdmi_print(INF, CEC "CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);
+            switch(pcec_message->content.msg.operands[0]){
+                case 0x3:
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 1);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 0);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_SET_OSD_STRING:
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_TIMER_STATUS:
+        case CEC_OC_TUNER_DEVICE_STATUS:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_VENDOR_COMMAND:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+        case CEC_OC_SET_ANALOGUE_TIMER :
+        case CEC_OC_SET_AUDIO_RATE:
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_ON:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_ABORT_MESSAGE:
+            cec_feature_abort(pcec_message);
+            break;
+        default:
+            break;
+        }
+    }
+}
+
+
+// --------------- cec command from user application --------------------
+
+void cec_usrcmd_parse_all_dev_online(void)
+{
+    int i;
+    unsigned short tmp_mask;
+
+    hdmirx_cec_dbg_print("cec online: ###############################################\n");
+    hdmirx_cec_dbg_print("active_log_dev %x\n", cec_global_info.active_log_dev);
+    for (i = 0; i < MAX_NUM_OF_DEV; i++) {
+        tmp_mask = 1 << i;
+        if (tmp_mask & cec_global_info.dev_mask) {
+            hdmirx_cec_dbg_print("cec online: -------------------------------------------\n");
+            hdmirx_cec_dbg_print("hdmi_port:     %x\n", cec_global_info.cec_node_info[i].hdmi_port);
+            hdmirx_cec_dbg_print("dev_type:      %x\n", cec_global_info.cec_node_info[i].dev_type);
+            hdmirx_cec_dbg_print("power_status:  %x\n", cec_global_info.cec_node_info[i].power_status);
+            hdmirx_cec_dbg_print("cec_version:   %x\n", cec_global_info.cec_node_info[i].cec_version);
+            hdmirx_cec_dbg_print("vendor_id:     %x\n", cec_global_info.cec_node_info[i].vendor_id);
+            hdmirx_cec_dbg_print("phy_addr:      %x\n", cec_global_info.cec_node_info[i].phy_addr.phy_addr_4);
+            hdmirx_cec_dbg_print("log_addr:      %x\n", cec_global_info.cec_node_info[i].log_addr);
+            hdmirx_cec_dbg_print("osd_name:      %s\n", cec_global_info.cec_node_info[i].osd_name);
+            hdmirx_cec_dbg_print("osd_name_def:  %s\n", cec_global_info.cec_node_info[i].osd_name_def);
+            hdmirx_cec_dbg_print("menu_state:    %x\n", cec_global_info.cec_node_info[i].menu_state);
+
+            if (cec_global_info.cec_node_info[i].dev_type == CEC_PLAYBACK_DEVICE_TYPE) {
+                hdmirx_cec_dbg_print("deck_cnt_mode: %x\n", cec_global_info.cec_node_info[i].specific_info.playback.deck_cnt_mode);
+                hdmirx_cec_dbg_print("deck_info:     %x\n", cec_global_info.cec_node_info[i].specific_info.playback.deck_info);
+                hdmirx_cec_dbg_print("play_mode:     %x\n", cec_global_info.cec_node_info[i].specific_info.playback.play_mode);
+            }
+        }
+    }
+    hdmirx_cec_dbg_print("##############################################################\n");
+}
+
+void cec_usrcmd_get_cec_version(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr,
+            CEC_OC_GET_CEC_VERSION);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_audio_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_AUDIO_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_deck_status(unsigned char log_addr)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DECK_STATUS, STATUS_REQ_ON);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_set_deck_cnt_mode(unsigned char log_addr, deck_cnt_mode_e deck_cnt_mode)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_DECK_CONTROL, deck_cnt_mode);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_get_device_power_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_POWER_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_device_vendor_id(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_VENDOR_ID);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_osd_name(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_OSD_NAME);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_physical_address(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_PHYSICAL_ADDRESS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_system_audio_mode_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_set_standby(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_STANDBY);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+/////////////////////////
+void cec_usrcmd_set_imageview_on(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr,
+            CEC_OC_IMAGE_VIEW_ON);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_text_view_on(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr,
+            CEC_OC_TEXT_VIEW_ON);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_tuner_device_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_TUNER_DEVICE_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_PLAY, play_mode);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_get_menu_state(unsigned char log_addr)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, MENU_REQ_QUERY);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, menu_req_type);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_get_menu_language(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GET_MENU_LANGUAGE);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_active_source(void)
+{
+    MSG_P0(cec_global_info.my_node_index, 0xF, CEC_OC_REQUEST_ACTIVE_SOURCE);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_set_active_source(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P2(index, CEC_BROADCAST_ADDR,
+            CEC_OC_ACTIVE_SOURCE,
+			phy_addr_ab,
+			phy_addr_cd);
+
+    cec_ll_tx(gbl_msg, 4);
+}
+
+void cec_usrcmd_set_deactive_source(unsigned char log_addr)
+{
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_INACTIVE_SOURCE,
+           phy_addr_ab,
+           phy_addr_cd);
+
+    cec_ll_tx(gbl_msg, 4);
+}
+
+void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_mask mask)
+{
+    cec_global_info.cec_node_info[log_addr].real_info_mask &= ~mask;
+}
+
+
+void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message)
+{
+
+    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P14(index, log_addr,
+            CEC_OC_SET_OSD_NAME,
+            cec_global_info.cec_node_info[index].osd_name[0],
+            cec_global_info.cec_node_info[index].osd_name[1],
+            cec_global_info.cec_node_info[index].osd_name[2],
+            cec_global_info.cec_node_info[index].osd_name[3],
+            cec_global_info.cec_node_info[index].osd_name[4],
+            cec_global_info.cec_node_info[index].osd_name[5],
+            cec_global_info.cec_node_info[index].osd_name[6],
+            cec_global_info.cec_node_info[index].osd_name[7],
+            cec_global_info.cec_node_info[index].osd_name[8],
+            cec_global_info.cec_node_info[index].osd_name[9],
+            cec_global_info.cec_node_info[index].osd_name[10],
+            cec_global_info.cec_node_info[index].osd_name[11],
+            cec_global_info.cec_node_info[index].osd_name[12],
+            cec_global_info.cec_node_info[index].osd_name[13]);
+
+    cec_ll_tx(gbl_msg, 16);
+}
+
+
+
+void cec_usrcmd_set_device_vendor_id(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P3(index, CEC_BROADCAST_ADDR,
+            CEC_OC_DEVICE_VENDOR_ID,
+            (cec_global_info.cec_node_info[index].vendor_id >> 16) & 0xff,
+            (cec_global_info.cec_node_info[index].vendor_id >> 8) & 0xff,
+            (cec_global_info.cec_node_info[index].vendor_id >> 0) & 0xff);
+
+    cec_ll_tx(gbl_msg, 5);
+}
+void cec_usrcmd_set_report_physical_address(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P3(index, CEC_BROADCAST_ADDR,
+           CEC_OC_REPORT_PHYSICAL_ADDRESS,
+           phy_addr_ab,
+           phy_addr_cd,
+           CEC_PLAYBACK_DEVICE_TYPE);
+
+    cec_ll_tx(gbl_msg, 5);
+}
+
+void cec_routing_change(cec_rx_message_t* pcec_message)
+{
+    unsigned int phy_addr_origin;
+    unsigned int phy_addr_destination;
+
+    phy_addr_origin = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[2] << 8) |
+                                         (pcec_message->content.msg.operands[3] << 0));
+
+	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
+}
+
+void cec_routing_information(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+    unsigned int phy_addr_destination;
+    unsigned char msg[4];
+
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                         (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_ROUTING_INFORMATION;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    cec_ll_tx(msg, 4);
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
+}
+/***************************** cec middle level code end *****************************/
+
+
+/***************************** cec high level code *****************************/
+
+static int __init cec_init(void)
+{
+    int i;
+    int ret;
+    extern __u16 cec_key_map[128];
+    extern hdmitx_dev_t * get_hdmitx_device(void);
+    hdmitx_device = get_hdmitx_device();
+    //init_waitqueue_head(&hdmitx_device->cec_wait_rx);
+    cec_key_init();
+    hdmi_print(INF, CEC "CEC init\n");
+    cec_global_info.cec_flag.cec_key_flag = 0; 
+    cec_global_info.cec_flag.cec_fiq_flag = 0;
+    cec_global_info.cec_flag.cec_init_flag = 0;
+    
+
+
+    ret = alloc_chrdev_region(&devno, 0, 30, DEVICE_NAME);
+
+    if(ret < 0)
+    {
+        hdmi_print(INF, CEC "cec chrdev region fail\n");
+        return ret;
+    }
+
+    cec_devp = kmalloc(sizeof(struct cec_dev), GFP_KERNEL);
+    if(!cec_devp)
+    {
+        ret = - ENOMEM;
+        hdmi_print(INF, CEC "cec kmalloc fail\n");
+        goto out;
+    }
+    memset(cec_devp, 0, sizeof(struct cec_dev));
+    cec_setup_cdev();
+
+    cec_class = class_create(THIS_MODULE, "hdmitx_aocec");
+    if (IS_ERR(cec_class))
+    {
+        unregister_chrdev_region(devno, 1);
+        hdmi_print(INF, CEC "cec class create fail\n");
+        goto out;
+    }
+
+    cec_device = device_create(cec_class, NULL, devno, NULL, DEVICE_NAME);
+
+    sema_init(&cec_devp->sem, 1);
+    init_waitqueue_head(&cec_devp->r_wait);
+    init_waitqueue_head(&cec_devp->w_wait);
+
+    cec_global_info.cec_rx_msg_buf.rx_write_pos = 0;
+    cec_global_info.cec_rx_msg_buf.rx_read_pos = 0;
+    cec_global_info.cec_rx_msg_buf.rx_buf_size = sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message)/sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message[0]);
+    memset(cec_global_info.cec_rx_msg_buf.cec_rx_message, 0, sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message));
+
+    memset(&cec_global_info, 0, sizeof(cec_global_info_t));
+    
+    cec_global_info.hdmitx_device = hdmitx_device;
+    
+    hdmitx_device->task_cec = kthread_run(cec_task, (void*)hdmitx_device, "kthread_cec");
+
+    if(request_irq(INT_AO_CEC, &cec_isr_handler,
+                IRQF_SHARED, "amhdmitx-aocec",
+                (void *)hdmitx_device)){
+        hdmi_print(INF, CEC "Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
+    }
+
+    cec_global_info.remote_cec_dev = input_allocate_device();
+    if (!cec_global_info.remote_cec_dev)
+    {
+        hdmi_print(INF, CEC "remote_cec.c: Not enough memory\n");
+    }
+    cec_global_info.remote_cec_dev->name = "cec_input";
+
+    cec_global_info.remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);
+    cec_global_info.remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
+    cec_global_info.remote_cec_dev->id.bustype = BUS_ISA;
+    cec_global_info.remote_cec_dev->id.vendor = 0x1b8e;
+    cec_global_info.remote_cec_dev->id.product = 0x0cec;
+    cec_global_info.remote_cec_dev->id.version = 0x0001;
+
+    for (i = 0; i < 128; i++){
+          set_bit( cec_key_map[i], cec_global_info.remote_cec_dev->keybit);
+      }
+
+    if(input_register_device(cec_global_info.remote_cec_dev)) {
+        hdmi_print(INF, CEC "remote_cec.c: Failed to register device\n");
+        input_free_device(cec_global_info.remote_cec_dev);
+    }
+
+    hdmitx_device->cec_init_ready = 1;
+    hdmi_print(INF, CEC "hdmitx_device->cec_init_ready:0x%x", hdmitx_device->cec_init_ready);
+    return 0;
+    out:unregister_chrdev_region(devno, 1);
+    return ret;
+}
+
+static void __exit cec_uninit(void)
+{
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))) {
+        return ;
+    }
+    hdmi_print(INF, CEC "cec uninit!\n");
+    if (cec_global_info.cec_flag.cec_init_flag == 1) {
+
+        free_irq(INT_AO_CEC, (void *)hdmitx_device);
+        
+    	kthread_stop(hdmitx_device->task_cec);
+        cec_global_info.cec_flag.cec_init_flag = 0;
+    }
+    
+    cdev_del(&cec_devp->cdev);
+    device_destroy(cec_class, devno);
+    class_destroy(cec_class);
+    unregister_chrdev_region(devno, 1);
+
+    hdmitx_device->cec_init_ready = 0;
+    input_unregister_device(cec_global_info.remote_cec_dev);
+    cec_global_info.cec_flag.cec_fiq_flag = 0;
+}
+
+size_t cec_usrcmd_get_global_info(char * buf)
+{
+    int i = 0;
+    int dev_num = 0;
+
+    cec_node_info_t * buf_node_addr = (cec_node_info_t *)(buf + (unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
+
+    for (i = 0; i < MAX_NUM_OF_DEV; i++) {
+        if (cec_global_info.dev_mask & (1 << i)) {
+            memcpy(&(buf_node_addr[dev_num]), &(cec_global_info.cec_node_info[i]), sizeof(cec_node_info_t));
+            dev_num++;
+        }
+    }
+
+    buf[0] = dev_num;
+    buf[1] = cec_global_info.active_log_dev;
+#if 0
+    hdmi_print(INF, CEC "\n");
+    hdmi_print(INF, CEC "%x\n",(unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->dev_number);
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->active_log_dev);
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->cec_node_info_online[0].hdmi_port);
+    for (i=0; i < (sizeof(cec_node_info_t) * dev_num) + 2; i++) {
+        hdmi_print(INF, CEC "%x,",buf[i]);
+    }
+    hdmi_print(INF, CEC "\n");
+#endif
+    return (sizeof(cec_node_info_t) * dev_num) + (unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online);
+}
+
+void cec_usrcmd_set_lang_config(const char * buf, size_t count)
+{
+    char tmpbuf[128];
+    int i=0;
+
+    while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
+        tmpbuf[i]=buf[i];
+        i++;    
+    }
+
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = simple_strtoul(tmpbuf, NULL, 16);
+
+}
+void cec_usrcmd_set_config(const char * buf, size_t count)
+{
+    int i = 0;
+    int j = 0;
+    unsigned long value;
+    char param[16] = {0};
+
+    if(count > 32){
+        hdmi_print(INF, CEC "too many args\n");
+    }
+    for(i = 0; i < count; i++){
+        if ( (buf[i] >= '0') && (buf[i] <= 'f') ){
+            param[j] = simple_strtoul(&buf[i], NULL, 16);
+            j ++;
+        }
+        while ( buf[i] != ' ' )
+            i ++;
+    }
+    value = aml_read_reg32(P_AO_DEBUG_REG0) & 0x1;
+    aml_set_reg32_bits(P_AO_DEBUG_REG0, param[0], 0, 4);
+    hdmitx_device->cec_func_config = aml_read_reg32(P_AO_DEBUG_REG0);
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))) {
+        return ;
+    }
+    if((0 == value) && (1 == (param[0] & 1))){
+        hdmitx_device->cec_init_ready = 1;
+        hdmitx_device->hpd_state = 1;
+        
+        cec_node_init(hdmitx_device);
+    }
+    if((1 == (param[0] & 1)) && (0x2 == (value & 0x2)) && (0x0 == (param[0] & 0x2))){
+        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+    }
+    if((1 == (param[0] & 1)) && (0x0 == (value & 0x2)) && (0x2 == (param[0] & 0x2))){
+        cec_active_source_smp();
+    }
+    hdmi_print(INF, CEC "cec_func_config:0x%x : 0x%x\n",hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
+}
+
+unsigned int dispatch_buffer_parse(const char *buf, const char *string,  char *param, size_t count){
+    unsigned int i;
+    unsigned int j;
+    unsigned int len;
+    
+    j = 0;
+    len = ('\0' == *string) ? 0 : 1 ;
+    for(i = strlen(string) + len; i < count; i++){
+        param[j] = simple_strtoul(&buf[i], NULL, 16);
+        printk("param[%d]:0x%x\n", j, param[j]);
+        j ++;
+        while ( (buf[i] != ' ') && (buf[i] != ',') )
+            i ++;
+    }
+    param[j]=0;
+    return j;
+}
+
+void cec_usrcmd_set_dispatch(const char * buf, size_t count)
+{
+    int i = 0;
+//    int j = 0;
+    int bool = 0;
+    char param[32] = {0};
+    unsigned bit_set;
+    unsigned time_set;
+    unsigned param_count;
+    unsigned char msg[4] = {0};
+    unsigned char log_buf[912] = {0};
+    int pos = 0;
+    
+    hdmi_print(INF, CEC "cec usrcmd set dispatch start:\n");
+    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
+        hdmi_print(INF, CEC "HPD low!\n");
+        return;
+    }
+    
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))){
+        hdmi_print(INF, CEC "cec function masked!\n");
+        return;
+    }
+        
+    if(count > 32){
+        hdmi_print(INF, CEC "too many args\n");
+    }
+    
+    if(!strncmp(buf, "waocec", 6))
+    {
+        bit_set = simple_strtoul(buf+6, NULL, 16);
+        time_set = simple_strtoul(buf+8, NULL, 16);
+        //cec_arbit_bit_time_set(bit_set, time_set, 1);
+    }else if(!strncmp(buf, "raocec", 6))
+    {
+        //cec_arbit_bit_time_read();
+    }else if(!strncmp(buf, "wcec", 4))
+    {
+        param_count = dispatch_buffer_parse(buf, "wcec", param, count);
+        printk("G9 CEC msg: param_count:%d :", param_count);
+        printk("%s\n", buf );
+        cec_ll_tx(param, param_count);
+    }else if(!strncmp(buf, "rcec", 4))
+    {
+        pos = 0;
+        pos += sprintf(log_buf + pos, "CEC rx msg::");
+        for (i = 0; i < cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos - 1].msg_length; ++i)
+        {
+            pos += sprintf(log_buf + pos, "%02x ", cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos - 1].content.buffer[i]);
+        }
+        pos += sprintf(log_buf + pos, "\n");
+        log_buf[pos] = '\0';
+        printk("%s", log_buf);
+        return;
+    }else if(!strncmp(buf, "dumpaocec", 9))
+    {
+        pos = 0;
+        for (i = 0; i < 0x68; ++i)
+        {
+            if(!(i%8))
+                pos += sprintf(log_buf + pos, "\nAO_CEC[0x%02x]:: ", i);
+            //pos += sprintf(log_buf + pos, "0x%02x  ", (unsigned char)aocec_rd_reg(i)); //modifiy later
+
+        }
+        
+        for (i = 0; i < 5; ++i)
+        {
+            pos += sprintf(log_buf + pos, "\nAO_REG[0x%x]:: 0x%x",
+            AOBUS_REG_ADDR( (0x00 << 10) | ((0x40 + i)<< 2) ),
+            aml_read_reg32( AOBUS_REG_ADDR( (0x00 << 10) | ((0x40 + i)<< 2)) ) );
+        }
+        pos += sprintf(log_buf + pos, "\n");
+        log_buf[pos] = '\0';
+        printk("%s", log_buf);
+        return;
+    }
+    
+    dispatch_buffer_parse(buf, "", param, count);
+    switch (param[0]) {
+    case GET_CEC_VERSION:   //0 LA
+        cec_usrcmd_get_cec_version(param[1]);
+        break;
+    case GET_DEV_POWER_STATUS:
+        cec_usrcmd_get_device_power_status(param[1]);
+        break;
+    case GET_DEV_VENDOR_ID:
+        cec_usrcmd_get_device_vendor_id(param[1]);
+        break;
+    case GET_OSD_NAME:
+        cec_usrcmd_get_osd_name(param[1]);
+        break;
+    case GET_PHYSICAL_ADDR:
+        cec_usrcmd_get_physical_address(param[1]);
+        break;
+    case SET_STANDBY:       //d LA
+        cec_usrcmd_set_standby(param[1]);
+        break;
+    case SET_IMAGEVIEW_ON:  //e LA
+        cec_usrcmd_set_imageview_on(param[1]);
+        break;
+    case GIVE_DECK_STATUS:
+        cec_usrcmd_get_deck_status(param[1]);
+        break;
+    case SET_DECK_CONTROL_MODE:
+        cec_usrcmd_set_deck_cnt_mode(param[1], param[2]);
+        break;
+    case SET_PLAY_MODE:
+        cec_usrcmd_set_play_mode(param[1], param[2]);
+        break;
+    case GET_SYSTEM_AUDIO_MODE:
+        cec_usrcmd_get_system_audio_mode_status(param[1]);
+        break;
+    case GET_TUNER_DEV_STATUS:
+        cec_usrcmd_get_tuner_device_status(param[1]);
+        break;
+    case GET_AUDIO_STATUS:
+        cec_usrcmd_get_audio_status(param[1]);
+        break;
+    case GET_OSD_STRING:
+        break;
+    case GET_MENU_STATE:
+        cec_usrcmd_get_menu_state(param[1]);
+        break;
+    case SET_MENU_STATE:
+        cec_usrcmd_set_menu_state(param[1], param[2]);
+        break;
+    case SET_MENU_LANGAGE:
+        break;
+    case GET_MENU_LANGUAGE:
+        cec_usrcmd_get_menu_language(param[1]);
+        break;
+    case GET_ACTIVE_SOURCE:     //13
+        cec_usrcmd_get_active_source();
+        break;
+    case SET_ACTIVE_SOURCE:
+        cec_usrcmd_set_active_source();
+        break;
+    case SET_DEACTIVE_SOURCE:
+        cec_usrcmd_set_deactive_source(param[1]);
+        break;
+    case REPORT_PHYSICAL_ADDRESS:    //17
+    	cec_usrcmd_set_report_physical_address();
+    	break;
+    case SET_TEXT_VIEW_ON:          //18 LA
+    	cec_usrcmd_text_view_on(param[1]);
+        break;
+    case POLLING_ONLINE_DEV:    //19 LA
+        cec_polling_online_dev(param[1], &bool);
+        break;
+
+    case CEC_OC_MENU_STATUS:
+        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+        break;
+    case CEC_OC_ABORT_MESSAGE:
+
+        msg[0] = 0x40;
+        msg[1] = CEC_OC_FEATURE_ABORT;
+        msg[2] = 0;
+        msg[3] = CEC_UNRECONIZED_OPCODE;
+
+        cec_ll_tx(msg, 4);
+        break;
+    case PING_TV:    //0x1a LA : For TV CEC detected.
+        detect_tv_support_cec(param[1]);
+        break;
+    default:
+        break;
+    }
+    hdmi_print(INF, CEC "cec usrcmd set dispatch end!\n\n");
+}
+
+/***************************** cec high level code end *****************************/
+
+
+
+late_initcall(cec_init);
+module_exit(cec_uninit);
+MODULE_DESCRIPTION("AMLOGIC HDMI TX CEC driver");
+MODULE_LICENSE("GPL");
+//MODULE_LICENSE("Dual BSD/GPL");
+//MODULE_VERSION("1.0.0");
+
+MODULE_PARM_DESC(cec_msg_dbg_en, "\n cec_msg_dbg_en\n");
+module_param(cec_msg_dbg_en, bool, 0664);
+
+
+
+
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_edid.c
new file mode 100644
index 000000000000..a8559fa16584
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_edid.c
@@ -0,0 +1,1572 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+//#include <mach/register.h>
+#include <plat/io.h>
+//#include "hw/hdmi_tx_reg.h"
+#include <crypto/hash.h>
+#include <linux/crypto.h>
+#include <linux/scatterlist.h>
+#include <mach/am_regs.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+
+#define CEA_DATA_BLOCK_COLLECTION_ADDR_1StP 0x04
+#define VIDEO_TAG 0x40
+#define AUDIO_TAG 0x20
+#define VENDOR_TAG 0x60
+#define SPEAKER_TAG 0x80
+
+
+
+#define HDMI_EDID_BLOCK_TYPE_RESERVED     0
+#define HDMI_EDID_BLOCK_TYPE_AUDIO        1
+#define HDMI_EDID_BLOCK_TYPE_VIDEO        2
+#define HDMI_EDID_BLOCK_TYPE_VENDER       3
+#define HDMI_EDID_BLOCK_TYPE_SPEAKER      4
+#define HDMI_EDID_BLOCK_TYPE_VESA         5
+#define HDMI_EDID_BLOCK_TYPE_RESERVED2    6
+#define HDMI_EDID_BLOCK_TYPE_EXTENDED_TAG 7
+
+#define EDID_DETAILED_TIMING_DES_BLOCK0_POS 0x36
+#define EDID_DETAILED_TIMING_DES_BLOCK1_POS 0x48
+#define EDID_DETAILED_TIMING_DES_BLOCK2_POS 0x5A
+#define EDID_DETAILED_TIMING_DES_BLOCK3_POS 0x6C
+
+
+//-----------------------------------------------------------
+static int Edid_DecodeHeader(HDMI_TX_INFO_t *info, unsigned char *buff)
+{
+    int i, ret = 0;
+//    UpdateCRC16WithBlock( pCRC16, 8, Data);
+    if(!(buff[0] | buff[7]))
+    {
+        for(i = 1; i < 7; i++){
+           if(buff[i]!= 0xFF)
+               {
+                info->output_state = CABLE_PLUGIN_DVI_OUT;
+                ret = -1;
+               }
+        }
+    }
+    else
+        {
+            info->output_state = CABLE_PLUGIN_DVI_OUT;
+            ret = -1;
+        }
+    return ret;
+}
+
+static void Edid_ReceiverBrandNameParse(rx_cap_t * pRxCap, unsigned char * data)
+{
+    int i;
+    unsigned char uppercase[26] = { 0 };
+    unsigned char brand[3];
+
+    // Fill array uppercase with 'A' to 'Z'
+    for(i = 0; i < 26; i++)
+        uppercase[i] = 'A' + i;
+
+    brand[0] = data[0] >> 2;
+    brand[1] = ((data[0] & 0x3) << 3) + (data[1] >> 5);
+    brand[2] = data[1] & 0x1f;
+
+    for(i = 0; i < 3; i++) {
+        pRxCap->ReceiverBrandName[i] = uppercase[brand[i] - 1];
+    }
+}
+
+static int Edid_find_name_block(unsigned char * data)
+{
+    int ret = 0;
+    int i;
+    for(i = 0; i < 3; i++) {
+        if(data[i])
+            return ret;
+    }
+    if(data[3] == 0xfc)
+        ret = 1;
+    return ret;
+}
+
+static void Edid_ReceiverProductNameParse(rx_cap_t * pRxCap, unsigned char * data)
+{
+    int i = 0;
+    while((data[i] != 0x0a) && (data[i] != 0x20) && (i < 13)) {  // some Display Product name end with 0x20, not 0x0a
+        pRxCap->ReceiverProductName[i] = data[i];
+        i++;
+    }
+    pRxCap->ReceiverProductName[i] = '\0';
+}
+
+void Edid_DecodeStandardTiming(HDMI_TX_INFO_t * info, unsigned char * Data, unsigned char length)
+{
+     unsigned char  i, TmpVal;
+     int hor_pixel, frame_rate;
+
+     for(i = 0; i < length; i++ )
+     {
+        if((Data[i*2] != 0x01)&&(Data[i*2 + 1] != 0x01))   //else
+        {
+             hor_pixel = (int)((Data[i*2]+31)*8);
+             TmpVal = Data[i*2 + 1] & 0xC0;
+
+             frame_rate = (int)((Data[i*2 + 1])& 0x3F) + 60;
+
+             if((hor_pixel == 720) && (frame_rate == 30))
+                 {
+                   info->hdmi_sup_480i  = 1;
+                 }
+
+             else if((hor_pixel == 720) && (frame_rate == 25))
+                {
+                   info->hdmi_sup_576i  = 1;
+                 }
+
+             else if((hor_pixel == 720) && (frame_rate == 60))
+                {
+                   info->hdmi_sup_480p  = 1;
+//                   if(TmpVal==0x40)
+//                       info->video_480p.support_4_3  = 1;
+//                   else if(TmpVal==0xc0)
+//                       info->video_480p.support_16_9  = 1;
+                 }
+
+             else if((hor_pixel == 720) && (frame_rate == 50))
+               {
+                   info->hdmi_sup_576p  = 1;
+                 }
+
+             else if((hor_pixel == 1280) && (frame_rate == 60))
+             {
+                   info->hdmi_sup_720p_60hz  = 1;
+                 }
+
+             else if((hor_pixel == 1280) && (frame_rate == 50))
+             {
+                   info->hdmi_sup_720p_50hz  = 1;
+                 }
+
+             else if((hor_pixel == 1920) && (frame_rate == 30))
+             {
+                   info->hdmi_sup_1080i_60hz  = 1;
+                 }
+
+             else if((hor_pixel == 1920) && (frame_rate == 25))
+             {
+                   info->hdmi_sup_1080i_50hz  = 1;
+                 }
+
+             else if((hor_pixel == 1920) && (frame_rate == 60))
+             {
+                   info->hdmi_sup_1080p_60hz  = 1;
+                 }
+
+             else if((hor_pixel == 1920) && (frame_rate == 50))
+             {
+                   info->hdmi_sup_1080p_50hz  = 1;
+                 }
+             else if((hor_pixel == 1920) && (frame_rate == 24))
+             {
+                   info->hdmi_sup_1080p_24hz  = 1;
+                 }
+             else if((hor_pixel == 1920) && (frame_rate == 25))
+             {
+                   info->hdmi_sup_1080p_25hz  = 1;
+                 }
+             else if((hor_pixel == 1920) && (frame_rate == 30))
+             {
+                   info->hdmi_sup_1080p_30hz  = 1;
+                 }
+
+          }
+     }
+}
+
+static unsigned char Edid_TimingDescriptors[204]=    //12x17
+ {
+ //pixel clk --hsync active & blank  -- vsync  active & blank-- hsync/vsync off & wid -- Image size
+    0x8C,0x0A,  0xA0,0x14,0x51,     0xF0,0x16,0x00,     0x26,0x7c,0x43,0x00,    //0x13,0x8e,   //480i(4:3)
+     0x8C,0x0A,  0xA0,0x14,0x51,     0xF0,0x16,0x00,     0x26,0x7c,0x43,0x00,   // 0xc4,0x8e,   //480i(16:9)
+     0x8C,0x0A,  0xA0,0x20,0x51,     0x20,0x18,0x10,     0x18,0x7e,0x23,0x00,   // 0x13,0x8e,   //576i (4:3)
+     0x8C,0x0A,  0xA0,0x20,0x51,     0x20,0x18,0x10,     0x18,0x7e,0x23,0x00,   // 0xc4,0x8e,   //576i (16:9)
+     0x8C,0x0A,  0xD0,0x8A,0x20,     0xE0,0x2D,0x10,     0x10,0x3e,0x96,0x00,   // 0x13,0x8e,   //480p (4:3)
+     0x8C,0x0A,  0xD0,0x8A,0x20,     0xE0,0x2D,0x10,     0x10,0x3e,0x96,0x00,   // 0xc4,0x8e,   //480p (16:9)
+     0x8C,0x0A,  0xD0,0x90,0x20,     0x40,0x31,0x20,     0x0c,0x40,0x55,0x00,   // 0x13,0x8e,   //576p  (4:3)
+     0x8C,0x0A,  0xD0,0x90,0x20,     0x40,0x31,0x20,     0x0c,0x40,0x55,0x00,   // 0xc4,0x8e,  //576p  (16:9)
+    0x01,0x1D,    0x00,0x72,0x51,     0xD0,0x1E,0x20,     0x6e,0x28,0x55,0x00,  //  0xc4,0x8e,  //720p60(16:9)
+    0x01,0x1D,    0x00,0xBC,0x52,     0xD0,0x1E,0x20,     0xb8,0x28,0x55,0x40,  //  0xc4,0x8e,  //720p50 (16:9)
+    0x01,0x1D,    0x80,0x18,0x71,     0x1C,0x16,0x20,     0x58,0x2c,0x25,0x00,  //  0xc4,0x8e,  //1080i60 (16:9)
+    0x01,0x1D,    0x80,0xD0,0x72,     0x1C,0x16,0x20,     0x10,0x2c,0x25,0x80,  //  0xc4,0x8e,   //1080i50 (16:9)
+    0x02,0x3a,    0x80,0x18,0x71,     0x38,0x2d,0x40,     0x58,0x2c,0x45,0x00,  //  0xc4,0x8e,  //1080p60 (16:9)
+    0x02,0x3a,    0x80,0xD0,0x72,     0x38,0x2d,0x40,     0x10,0x2c,0x45,0x80,  //  0xc4,0x8e ,  //1080p50 (16:9)
+    0xfa,0x1c,    0x80,0x3e,0x73,     0x38,0x2d,0x40,     0x7e,0x2c,0x45,0x80,  //  0xc4,0x8e,  //1080p24 (16:9)
+    0x01,0x1D,    0x80,0xD0,0x72,     0x38,0x2d,0x40,     0x10,0x2c,0x45,0x80,  //  0xc4,0x8e,   //1080p25 (16:9)
+    0x01,0x1D,    0x80,0x18,0x71,     0x38,0x2d,0x40,     0x58,0x2c,0x45,0x00,  //  0xc4,0x8e,  //1080p30 (16:9)
+
+ };
+
+//-----------------------------------------------------------
+void Edid_CompareTimingDescriptors(HDMI_TX_INFO_t * info, unsigned char *Data)
+{
+   int index1,index2;
+
+    for(index1=0;index1<17;index1++)
+    {
+        for(index2=0;index2<12;index2++)
+        {
+            if(Data[index2]!=Edid_TimingDescriptors[index1*14+index2])
+                break;
+        }
+        if(index2==12)
+        {
+            switch(index1)
+            {
+                case 0:
+                case 1:
+                    info->hdmi_sup_480i  = 1;
+                    break;
+
+                case 2:
+                case 3:
+                     info->hdmi_sup_576i  = 1;
+                   break;
+
+                case 4:
+                case 5:
+                     info->hdmi_sup_480p  = 1;
+//                  if((Data[12]==Edid_TimingDescriptors[4*14 + 12]) && (Data[13]==Edid_TimingDescriptors[4*14 + 13]))
+//                     info->video_480p.support_4_3  = 1;
+//                  else if((Data[12]==Edid_TimingDescriptors[5*14 + 12]) && (Data[13]==Edid_TimingDescriptors[5*14 + 13]))
+//                     info->video_480p.support_16_9  = 1;
+                    break;
+
+                case 6:
+                case 7:
+                     info->hdmi_sup_576p  = 1;
+                    break;
+
+                case 8:
+                     info->hdmi_sup_720p_60hz  = 1;
+                       break;
+
+                case 9:
+                     info->hdmi_sup_720p_50hz  = 1;
+                       break;
+
+                case 10:
+                     info->hdmi_sup_1080i_60hz  = 1;
+                       break;
+
+                case 11:
+                     info->hdmi_sup_1080i_50hz  = 1;
+                    break;
+
+                case 12:
+                     info->hdmi_sup_1080p_60hz  = 1;
+                    break;
+
+                case 13:
+                     info->hdmi_sup_1080p_50hz  = 1;
+                    break;
+
+                case 14:
+                     info->hdmi_sup_1080p_24hz  = 1;
+                    break;
+
+                case 15:
+                     info->hdmi_sup_1080p_25hz  = 1;
+                    break;
+
+                case 16:
+                     info->hdmi_sup_1080p_30hz  = 1;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        }
+    }
+}
+
+
+//-----------------------------------------------------------
+void Edid_ParseCEADetailedTimingDescriptors(HDMI_TX_INFO_t * info, unsigned char blk_mun, unsigned char BaseAddr, unsigned char *buff)
+{
+    unsigned char index_edid;
+
+    for( index_edid = 0; index_edid < blk_mun; index_edid++)
+    {
+        Edid_CompareTimingDescriptors(info, &buff[BaseAddr]);
+        BaseAddr += 18;
+       if((BaseAddr + 18) > 0x7d)   //there is not the TimingDescriptors
+                break;
+      }
+
+}
+static vsdb_phy_addr_t vsdb_local = {0};
+int get_vsdb_phy_addr(vsdb_phy_addr_t * vsdb)
+{
+    vsdb = &vsdb_local;
+    return vsdb->valid;
+}
+
+void set_vsdb_phy_addr(vsdb_phy_addr_t * vsdb, unsigned char *edid_offset)
+{
+    vsdb->a = (edid_offset[4] >> 4 ) & 0xf;
+    vsdb->b = (edid_offset[4] >> 0 ) & 0xf;
+    vsdb->c = (edid_offset[5] >> 4 ) & 0xf;
+    vsdb->d = (edid_offset[5] >> 0 ) & 0xf;
+    vsdb_local = *vsdb;
+    vsdb->valid = 1;
+}
+
+int Edid_Parse_check_HDMI_VSDB(HDMI_TX_INFO_t * info, unsigned char *buff)
+{
+    unsigned char  VSpecificBoundary, BlockAddr,  len;
+    int temp_addr=0;
+    VSpecificBoundary = buff[2] ;
+    if(VSpecificBoundary < 4)
+    {
+        info->output_state = CABLE_PLUGIN_DVI_OUT;
+        return -1;
+    }
+    BlockAddr = CEA_DATA_BLOCK_COLLECTION_ADDR_1StP;
+    while( BlockAddr < VSpecificBoundary) {
+        len = buff[BlockAddr] & 0x1F;
+             if((buff[BlockAddr] & 0xE0)== VENDOR_TAG){        //find the HDMI Vendor Specific Data Block
+                    break;
+        }
+        temp_addr =     BlockAddr + len + 1;
+        if(temp_addr >= VSpecificBoundary)
+            break;
+        BlockAddr = BlockAddr + len + 1;
+    }
+
+    set_vsdb_phy_addr(&info->vsdb_phy_addr, &buff[BlockAddr]);
+
+    if(temp_addr >= VSpecificBoundary)
+    {
+        info->output_state = CABLE_PLUGIN_DVI_OUT;
+        return -1;
+    }
+    else
+    {
+        if((buff[BlockAddr + 1]!= 0x03)||(buff[BlockAddr + 2]!= 0x0C)||(buff[BlockAddr + 3]!= 0x0))
+        {
+            info->output_state = CABLE_PLUGIN_DVI_OUT;
+            return -1;
+        }
+    }
+    return 0;
+}
+
+//-----------------------------------------------------------
+void Edid_MonitorCapable861(HDMI_TX_INFO_t * info, unsigned char edid_flag)
+{
+     if(edid_flag & 0x80)
+        info->support_underscan_flag = 1;
+     if(edid_flag & 0x40)
+        info->support_basic_audio_flag =1;
+     if(edid_flag & 0x20)
+         {
+            info->support_ycbcr444_flag =1;
+//            info->videopath_outindex = 1;    // Video Output Color Space Conversion : 0 - RGB out; 1 - YCbr (4:4:4) out; 2 - YCbr (4:2:2) out;
+      }
+     if(edid_flag & 0x10)
+         {
+            info->support_ycbcr422_flag =1 ;
+//            if(!(edid_flag & 0x20))
+//                info->videopath_outindex = 2;    // Video Output Color Space Conversion : 0 - RGB out; 1 - YCbr (4:4:4) out; 2 - YCbr (4:2:2) out;
+      }
+}
+
+
+//-----------------------------------------------------------
+static void Edid_ParsingVideoDATABlock(HDMI_TX_INFO_t * info, unsigned char *buff, unsigned char BaseAddr, unsigned char NBytes)
+{
+    unsigned char i;
+    NBytes &= 0x1F;
+    for(i = 0; i < NBytes; i++)
+      {
+        switch(buff[i + BaseAddr]&0x7F)
+        {
+            case 6:
+            case 7:
+                info->hdmi_sup_480i  = 1;
+                break;
+
+            case 21:
+            case 22:
+                info->hdmi_sup_576i  = 1;
+                  break;
+
+            case 2:
+            case 3:
+                info->hdmi_sup_480p  = 1;
+                break;
+
+            case 17:
+            case 18:
+                info->hdmi_sup_576p  = 1;
+                break;
+
+            case 4:
+                info->hdmi_sup_720p_60hz  = 1;
+                break;
+
+            case 19:
+                info->hdmi_sup_720p_50hz  = 1;
+                break;
+
+            case 5:
+                info->hdmi_sup_1080i_60hz  = 1;
+                break;
+
+            case 20:
+               info->hdmi_sup_1080i_50hz  = 1;
+               break;
+
+            case 16:
+                info->hdmi_sup_1080p_60hz  = 1;
+                break;
+
+            case 31:
+                info->hdmi_sup_1080p_50hz  = 1;
+                break;
+
+            case 32:
+                info->hdmi_sup_1080p_24hz  = 1;
+                break;
+
+            case 33:
+                info->hdmi_sup_1080p_25hz  = 1;
+                break;
+            case 34:
+                info->hdmi_sup_1080p_30hz  = 1;
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+//-----------------------------------------------------------
+static void Edid_ParsingAudioDATABlock(HDMI_TX_INFO_t * info, unsigned char *Data, unsigned char BaseAddr, unsigned char NBytes)
+{
+     unsigned char AudioFormatCode;
+     int i = BaseAddr ;
+   NBytes&=0x1F;
+   do{
+        AudioFormatCode = (Data[i]&0xF8)>>3;
+        switch(AudioFormatCode)
+          {
+                case 1:
+                         info->tv_audio_info._60958_PCM.support_flag = 1;
+                         info->tv_audio_info._60958_PCM.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._60958_PCM._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._60958_PCM._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._60958_PCM._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._60958_PCM._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._60958_PCM._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._60958_PCM._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._60958_PCM._32k = 1;
+                         if((Data[i+2]&0x04))
+                             info->tv_audio_info._60958_PCM._24bit = 1;
+                         if((Data[i+2]&0x02))
+                             info->tv_audio_info._60958_PCM._20bit = 1;
+                         if((Data[i+2]&0x01))
+                             info->tv_audio_info._60958_PCM._16bit = 1;
+                         break;
+
+                case 2:
+                         info->tv_audio_info._AC3.support_flag = 1;
+                         info->tv_audio_info._AC3.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._AC3._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._AC3._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._AC3._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._AC3._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._AC3._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._AC3._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._AC3._32k = 1;
+                         info->tv_audio_info._AC3._max_bit = Data[i+2];
+                         break;
+
+                case 3:
+                         info->tv_audio_info._MPEG1.support_flag = 1;
+                         info->tv_audio_info._MPEG1.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MPEG1._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MPEG1._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MPEG1._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MPEG1._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MPEG1._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MPEG1._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MPEG1._32k = 1;
+                         info->tv_audio_info._MPEG1._max_bit = Data[i+2];
+                         break;
+
+                case 4:
+                         info->tv_audio_info._MP3.support_flag = 1;
+                         info->tv_audio_info._MP3.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MP3._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MP3._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MP3._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MP3._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MP3._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MP3._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MP3._32k = 1;
+                         info->tv_audio_info._MP3._max_bit = Data[i+2];
+                         break;
+
+                case 5:
+                        info->tv_audio_info._MPEG2.support_flag = 1;
+                         info->tv_audio_info._MPEG2.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MPEG2._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MPEG2._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MPEG2._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MPEG2._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MPEG2._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MPEG2._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MPEG2._32k = 1;
+                         info->tv_audio_info._MPEG2._max_bit = Data[i+2];
+                         break;
+
+                case 6:
+                        info->tv_audio_info._AAC.support_flag = 1;
+                         info->tv_audio_info._AAC.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._AAC._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._AAC._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._AAC._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._AAC._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._AAC._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._AAC._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._AAC._32k = 1;
+                         info->tv_audio_info._AAC._max_bit = Data[i+2];
+                         break;
+
+                case 7:
+                        info->tv_audio_info._DTS.support_flag = 1;
+                         info->tv_audio_info._DTS.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._DTS._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._DTS._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._DTS._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._DTS._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._DTS._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._DTS._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._DTS._32k = 1;
+                         info->tv_audio_info._DTS._max_bit = Data[i+2];
+                         break;
+
+                case 8:
+                        info->tv_audio_info._ATRAC.support_flag = 1;
+                         info->tv_audio_info._ATRAC.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._ATRAC._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._ATRAC._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._ATRAC._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._ATRAC._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._ATRAC._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._ATRAC._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._ATRAC._32k = 1;
+                         info->tv_audio_info._ATRAC._max_bit = Data[i+2];
+                         break;
+
+                case 9:
+                        info->tv_audio_info._One_Bit_Audio.support_flag = 1;
+                         info->tv_audio_info._One_Bit_Audio.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._One_Bit_Audio._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._One_Bit_Audio._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._One_Bit_Audio._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._One_Bit_Audio._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._One_Bit_Audio._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._One_Bit_Audio._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._One_Bit_Audio._32k = 1;
+                         info->tv_audio_info._One_Bit_Audio._max_bit = Data[i+2];
+                         break;
+
+                case 10:
+                        info->tv_audio_info._Dolby.support_flag = 1;
+                         info->tv_audio_info._Dolby.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._Dolby._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._Dolby._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._Dolby._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._Dolby._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._Dolby._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._Dolby._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._Dolby._32k = 1;
+                         info->tv_audio_info._Dolby._max_bit = Data[i+2];
+                         break;
+
+                case 11:
+                        info->tv_audio_info._DTS_HD.support_flag = 1;
+                         info->tv_audio_info._DTS_HD.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._DTS_HD._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._DTS_HD._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._DTS_HD._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._DTS_HD._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._DTS_HD._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._DTS_HD._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._DTS_HD._32k = 1;
+                         info->tv_audio_info._DTS_HD._max_bit = Data[i+2];
+                         break;
+
+
+                case 12:
+                        info->tv_audio_info._MAT.support_flag = 1;
+                         info->tv_audio_info._MAT.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MAT._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MAT._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MAT._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MAT._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MAT._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MAT._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MAT._32k = 1;
+                         info->tv_audio_info._MAT._max_bit = Data[i+2];
+                         break;
+
+                case 13:
+                        info->tv_audio_info._ATRAC.support_flag = 1;
+                         info->tv_audio_info._ATRAC.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._DST._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._DST._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._DST._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._DST._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._DST._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._DST._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._DST._32k = 1;
+                         info->tv_audio_info._DST._max_bit = Data[i+2];
+                         break;
+
+                case 14:
+                        info->tv_audio_info._WMA.support_flag = 1;
+                         info->tv_audio_info._WMA.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._WMA._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._WMA._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._WMA._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._WMA._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._WMA._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._WMA._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._WMA._32k = 1;
+                         info->tv_audio_info._WMA._max_bit = Data[i+2];
+                         break;
+
+                default:
+                         break;
+                 }
+                i+=3;
+      }while (i < (NBytes + BaseAddr));
+}
+
+//-----------------------------------------------------------
+static void Edid_ParsingSpeakerDATABlock(HDMI_TX_INFO_t * info, unsigned char *buff, unsigned char BaseAddr)
+{
+   int ii;
+   for(ii = 1; ii < 0x80; )
+   {
+     switch(buff[BaseAddr] & ii)
+      {
+            case 0x40:
+                info->tv_audio_info.speaker_allocation.rlc_rrc = 1;
+                break;
+
+            case 0x20:
+                info->tv_audio_info.speaker_allocation.flc_frc = 1;
+                break;
+
+            case 0x10:
+                info->tv_audio_info.speaker_allocation.rc = 1;
+                break;
+
+            case 0x08:
+                info->tv_audio_info.speaker_allocation.rl_rr = 1;
+                break;
+
+            case 0x04:
+                info->tv_audio_info.speaker_allocation.fc = 1;
+                break;
+
+            case 0x02:
+                info->tv_audio_info.speaker_allocation.lfe = 1;
+                break;
+
+            case 0x01:
+                info->tv_audio_info.speaker_allocation.fl_fr = 1;
+                break;
+
+          default :
+              break;
+       }
+       ii = ii << 1;
+     }
+}
+
+
+
+//-----------------------------------------------------------
+int Edid_ParsingCEADataBlockCollection(HDMI_TX_INFO_t * info, unsigned char *buff)
+{
+   unsigned char AddrTag, D, Addr, Data;
+   int temp_addr;
+
+   D = buff[2];   //Byte number offset d where Detailed Timing data begins
+   Addr = 4;
+
+   AddrTag = Addr;
+   do{
+        Data = buff[AddrTag];
+        switch(Data&0xE0)
+        {
+            case VIDEO_TAG:
+                if((Addr + (Data&0x1f)) < D)
+                      Edid_ParsingVideoDATABlock(info, buff, Addr + 1, (Data & 0x1F) );
+                break;
+
+            case AUDIO_TAG:
+                if((Addr + (Data&0x1f)) < D)
+                      Edid_ParsingAudioDATABlock(info, buff, Addr + 1, (Data & 0x1F) );
+                break;
+
+            case SPEAKER_TAG:
+                if((Addr + (Data&0x1f)) < D)
+                      Edid_ParsingSpeakerDATABlock(info, buff, Addr + 1 );
+                break;
+
+            case VENDOR_TAG:
+                if((Addr + (Data&0x1f)) < D)
+                {
+                         if((buff[Addr + 1] != 0x03) || (buff[Addr + 2] != 0x0c) || (buff[Addr + 3] != 0x00))
+                         {
+                              info->auth_state = HDCP_NO_AUTH ;
+                              info->output_state = CABLE_PLUGIN_DVI_OUT;
+                         }
+                      if((Data&0x1f) > 5)
+                      {
+                     //A Source shall not transmit an ISRC1 or ISRC2 Packet to a Sink that does not have Supports_AI = 1
+                     //International Standard Recording Code (ISRC)
+                          if(buff[Addr + 6] & 0x80)
+                              info->support_ai_flag = 1;
+                      }
+                }
+                break;
+
+            default:
+                break;
+          }
+          Addr += ( Data & 0x1F ) ;   // next Tag Address
+          AddrTag = ++Addr;
+        temp_addr =   Addr + ( Data & 0x1F ) ;
+        if(temp_addr >= D)    //force to break;
+            break;
+     }while (Addr < D);
+
+   return 0;
+}
+
+//-----------------------------------------------------------
+
+//parse Sink 3D information
+static int hdmitx_edid_3d_parse(rx_cap_t* pRXCap, unsigned char *dat, unsigned size)
+{
+    int j = 0;
+    int bit = 16;
+    unsigned int base = 0;
+    unsigned int pos = base + 1;
+
+    if(dat[base] & (1<<7))
+        pos += 2;
+    if(dat[base] & (1<<6))
+        pos += 2;
+    if(dat[base] & (1<<5)){
+        pRXCap->threeD_present = dat[pos] >> 7;
+        pRXCap->threeD_Multi_present = (dat[pos] >> 5) & 0x3;
+        pos += 1;
+        pRXCap->HDMI_VIC_LEN = (dat[pos] ) >> 5;
+        pRXCap->HDMI_3D_LEN = (dat[pos] ) & 0x1f;
+        pos += pRXCap->HDMI_VIC_LEN + 1;
+        if((pRXCap->threeD_Multi_present == 0x01) || (pRXCap->threeD_Multi_present == 0x2)) {
+            pRXCap->threeD_Structure_ALL_15_0 = (dat[pos] << 8) + dat[pos+1];
+            pos +=2;
+        }
+        if(pRXCap->threeD_Multi_present == 0x2) {
+            pRXCap->threeD_MASK_15_0 = (dat[pos] << 8) + dat[pos+1];
+            pos +=2;
+        }
+    }
+    while(pos < size) {
+        if((dat[pos] & 0xf) == 0x0 ){ // frame packing
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos] & 0xf0) >> 4)]].frame_packing = 1;
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos+1] & 0xf0) >> 4)]].frame_packing = 1;
+        }
+        if((dat[pos] & 0xf) == 0x6 ){ // top and bottom
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos] & 0xf0) >> 4)]].top_and_bottom = 1;
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos+1] & 0xf0) >> 4)]].top_and_bottom = 1;
+        }
+        if((dat[pos] & 0xf) == 0x8 ){ // top and bottom
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos] & 0xf0) >> 4)]].side_by_side = 1;
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos+1] & 0xf0) >> 4)]].side_by_side = 1;
+        }
+        pos += 2;
+    }
+
+    while(bit--){
+        if(((pRXCap->threeD_MASK_15_0) >> j) & 0x1)
+            if(pRXCap->threeD_Structure_ALL_15_0 & (1 << 0)) { // frame packing
+                pRXCap->support_3d_format[pRXCap->VIC[j]].frame_packing = 1;
+            }
+            if(pRXCap->threeD_Structure_ALL_15_0 & (1 << 6)) { // top and bottom
+                pRXCap->support_3d_format[pRXCap->VIC[j]].top_and_bottom = 1;
+            }
+            if(pRXCap->threeD_Structure_ALL_15_0 & (1 << 8)) { // top and bottom
+                pRXCap->support_3d_format[pRXCap->VIC[j]].side_by_side = 1;
+            }
+        j++;
+    }
+    return 1;
+}
+
+//parse Sink 4k2k information
+static void hdmitx_edid_4k2k_parse(rx_cap_t* pRXCap, unsigned char *dat, unsigned size)
+{
+    if((size > 4) || (size == 0)) {
+        hdmi_print(ERR, EDID "HDMI: 4k2k in edid out of range, SIZE = %d\n", size);
+        return;
+    }
+    while(size--) {
+        if(*dat == 1)
+            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_30;
+        else if(*dat == 2)
+            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_25;
+        else if(*dat == 3)
+            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_24;
+        else if(*dat == 4)
+            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_smpte_24;
+        else {
+        }
+        dat ++;
+        pRXCap->VIC_count++ ;
+    }
+}
+
+static int hdmitx_edid_block_parse(hdmitx_dev_t* hdmitx_device, unsigned char *BlockBuf)
+{
+    unsigned char offset,End ;
+    unsigned char count ;
+    unsigned char tag ;
+    int i, tmp, idx;
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+
+    if( BlockBuf[0] != 0x02 )
+        return -1 ; // not a CEA BLOCK.
+    End = BlockBuf[2]  ; // CEA description.
+    pRXCap->native_Mode = BlockBuf[3] ;
+
+      pRXCap->VIC_count = 0 ;
+    pRXCap->native_VIC = 0xff ;
+    for( offset = 4 ; offset < End ; ){
+        tag = BlockBuf[offset] >> 5 ;
+        count = BlockBuf[offset] & 0x1f ;
+        switch( tag ){
+            case HDMI_EDID_BLOCK_TYPE_AUDIO: 
+                pRXCap->AUD_count = count/3 ;
+                offset++ ;
+                for( i = 0 ; i < pRXCap->AUD_count ; i++)
+                {
+                    pRXCap->RxAudioCap[i].audio_format_code = (BlockBuf[offset + i * 3]>>3)&0xf;
+                    pRXCap->RxAudioCap[i].channel_num_max = BlockBuf[offset + i * 3]&0x7;
+                    pRXCap->RxAudioCap[i].freq_cc = BlockBuf[offset + i * 3 +1]&0x7f;
+                    pRXCap->RxAudioCap[i].cc3 = BlockBuf[offset + i * 3 + 2]&0x7;
+                }
+                offset += count;
+                break ;
+            
+            case HDMI_EDID_BLOCK_TYPE_VIDEO:
+                offset ++;
+                for( i = 0 ; i < count ; i++)
+                {
+                    unsigned char VIC ;
+                    VIC = BlockBuf[offset + i] & (~0x80) ;
+                    pRXCap->VIC[pRXCap->VIC_count] = VIC ;
+                    if( BlockBuf[offset + i] & 0x80 ){
+                        pRXCap->native_VIC = VIC;
+                    }
+                    pRXCap->VIC_count++ ;
+                }
+                offset += count;
+                break ;
+            
+            case HDMI_EDID_BLOCK_TYPE_VENDER: 
+                offset ++ ;
+                pRXCap->IEEEOUI = (unsigned long)BlockBuf[offset+2] ;
+                pRXCap->IEEEOUI <<= 8 ;
+                pRXCap->IEEEOUI += (unsigned long)BlockBuf[offset+1] ;
+                pRXCap->IEEEOUI <<= 8 ;
+                pRXCap->IEEEOUI += (unsigned long)BlockBuf[offset] ;
+                /**/
+                hdmi_print(0, "HDMI_EDID_BLOCK_TYPE_VENDER: IEEEOUI %x:", pRXCap->IEEEOUI);
+                for(i = 0; i<count ;i++){
+                    hdmi_print(0, "%d: %02x\n",i+1, BlockBuf[offset+i]);
+                }
+                /**/
+                pRXCap->ColorDeepSupport = (unsigned long)BlockBuf[offset+5];
+                pRXCap->Max_TMDS_Clock = (unsigned long)BlockBuf[offset+6];
+                if(count > 7) {
+                    tmp = BlockBuf[offset+7];
+                    idx = offset + 8;
+                    if(tmp & (1<<6)) {
+                        idx += 2;
+                    }
+                    if(tmp & (1<<7)) {
+                        idx += 2;
+                    }
+                    if(tmp & (1<<5)) {
+                        idx += 1;
+                        if(BlockBuf[idx] & 0xe0) {   //valid 4k
+                            hdmitx_edid_4k2k_parse(pRXCap, &BlockBuf[idx + 1], BlockBuf[idx] >> 5);
+                        }
+                        if(BlockBuf[idx-1] & 0xe0) {  //valid 3D
+                            hdmitx_edid_3d_parse(pRXCap, &BlockBuf[offset+7], count - 7);
+                        }
+                    }
+                }
+                offset += count ; // ignore the remaind.
+                break ;
+            
+            case HDMI_EDID_BLOCK_TYPE_SPEAKER: 
+                offset ++ ;
+                pRXCap->RxSpeakerAllocation = BlockBuf[offset] ;
+                offset += count;
+                break ;
+
+            case HDMI_EDID_BLOCK_TYPE_VESA: 
+                offset ++;
+                offset += count;
+                break ;
+
+            case HDMI_EDID_BLOCK_TYPE_EXTENDED_TAG: 
+                offset ++;
+                offset += count;
+                break ;
+
+            case HDMI_EDID_BLOCK_TYPE_RESERVED:
+                offset ++;
+                offset += count;
+                break;
+
+            case HDMI_EDID_BLOCK_TYPE_RESERVED2:
+                offset ++;
+                offset += count;
+                break;
+
+            default:
+                break;
+        }
+    }
+    hdmitx_device->vic_count=pRXCap->VIC_count;
+    return 0 ;
+}
+
+// add default VICs for DVI case
+static void hdmitx_edid_set_default_vic(hdmitx_dev_t* hdmitx_device)
+{
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+    pRXCap->VIC_count = 0x3;
+    pRXCap->VIC[0] = 2;
+    pRXCap->VIC[1] = 4;
+    pRXCap->VIC[2] = 16;
+    pRXCap->native_VIC = 4;
+    hdmitx_device->vic_count = pRXCap->VIC_count;
+    hdmi_print(IMP, EDID "HDMI: set default vic\n");
+}
+
+#if 0
+#define PRINT_HASH(hash) {printk("%s:%d ",__func__,__LINE__);int __i;for(__i=0;__i<20;__i++)printk("%02x,",hash[__i]);printk("\n");}
+#else
+#define PRINT_HASH(hash) 
+#endif
+
+static int edid_hash_calc(unsigned char *hash, const char *data, unsigned int len)
+{
+    struct scatterlist sg;
+
+    struct crypto_hash *tfm;
+    struct hash_desc desc;
+
+    tfm = crypto_alloc_hash("sha1", 0, CRYPTO_ALG_ASYNC);
+    PRINT_HASH(hash);
+    if (IS_ERR(tfm))
+        return -EINVAL;
+
+    PRINT_HASH(hash);
+    /* ... set up the scatterlists ... */
+    sg_init_one(&sg, (u8 *) data, len);
+    desc.tfm = tfm;
+    desc.flags = 0;
+
+    if (crypto_hash_digest(&desc, &sg,len, hash))
+        return -EINVAL;
+    PRINT_HASH(hash);
+    crypto_free_hash(tfm);
+    return 1;
+}
+
+static int hdmitx_edid_search_IEEEOUI(char *buf)
+{
+    int i;
+
+    for(i = 0; i < 125; i++) {
+        if((buf[i] == 0x03) && (buf[i+1] == 0x0c) && (buf[i+2] == 0x00)) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned char CheckSum ;
+    unsigned char zero_numbers;
+    unsigned char BlockCount ;
+    unsigned char* EDID_buf = hdmitx_device->EDID_buf;
+    int i, j, ret_val ;
+    int idx[4];
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+    hdmi_print(0, "EDID Parser:\n");
+
+    // Calculate the EDID hash for special use
+    memset(hdmitx_device->EDID_hash, 0, ARRAY_SIZE(hdmitx_device->EDID_hash));
+    edid_hash_calc(hdmitx_device->EDID_hash, hdmitx_device->EDID_buf, 256);
+
+    ret_val = Edid_DecodeHeader(&hdmitx_device->hdmi_info, &EDID_buf[0]);
+
+//    if(ret_val == -1)
+//        return -1;
+
+    for( i = 0, CheckSum = 0 ; i < 128 ; i++ )
+    {
+        CheckSum += EDID_buf[i] ;
+        CheckSum &= 0xFF ;
+    }
+    
+    if( CheckSum != 0 )
+    {
+        hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_DVI_OUT;
+        hdmi_print(0, "PLUGIN_DVI_OUT\n");
+//        return -1 ;
+    }
+    
+    Edid_ReceiverBrandNameParse(&hdmitx_device->RXCap, &EDID_buf[8]);
+
+    idx[0] = EDID_DETAILED_TIMING_DES_BLOCK0_POS;
+    idx[1] = EDID_DETAILED_TIMING_DES_BLOCK1_POS;
+    idx[2] = EDID_DETAILED_TIMING_DES_BLOCK2_POS;
+    idx[3] = EDID_DETAILED_TIMING_DES_BLOCK3_POS;
+    for(i = 0; i < 4; i++) {
+        if(Edid_find_name_block(&EDID_buf[idx[i]]))
+            Edid_ReceiverProductNameParse(&hdmitx_device->RXCap, &EDID_buf[idx[i]+5]);
+    }
+    Edid_DecodeStandardTiming(&hdmitx_device->hdmi_info, &EDID_buf[26], 8);
+    Edid_ParseCEADetailedTimingDescriptors(&hdmitx_device->hdmi_info, 4, 0x36, &EDID_buf[0]);
+
+    BlockCount = EDID_buf[0x7E] ;
+
+    if( BlockCount == 0 ){
+        hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_DVI_OUT;
+        hdmi_print(0, "EDID BlockCount=0\n");
+        hdmitx_edid_set_default_vic(hdmitx_device);
+
+        // DVI case judgement: only contains one block and checksum valid
+        CheckSum = 0;
+        zero_numbers = 0;
+        for(i = 0; i < 128; i++) {
+            CheckSum += EDID_buf[i];
+            if(EDID_buf[i] == 0)
+                zero_numbers ++;
+        }
+        hdmi_print(INF, EDID "edid blk0 checksum:%d ext_flag:%d\n",CheckSum, EDID_buf[0x7e]);
+        if((CheckSum & 0xff) == 0) {
+            hdmitx_device->RXCap.IEEEOUI = 0;
+        } else {
+            hdmitx_device->RXCap.IEEEOUI = 0x0c03;
+        }
+        if(zero_numbers > 120)
+            hdmitx_device->RXCap.IEEEOUI = 0x0c03;
+
+        return 0 ; // do nothing.
+    }
+
+    if((BlockCount == 1) && (EDID_buf[0x81] == 1)) {    // Note: some DVI monitor have more than 1 block
+        hdmitx_device->RXCap.IEEEOUI = 0;
+        return 0;
+    }
+
+    else if ( BlockCount > EDID_MAX_BLOCK )
+    {
+        BlockCount = EDID_MAX_BLOCK ;
+    }
+
+    for( i = 1 ; i <= BlockCount ; i++ )
+    {
+
+        if((BlockCount > 1) && (i == 1))
+        {
+                CheckSum = 0;       //ignore the block1 data
+        }
+        else
+        {
+            if(((BlockCount == 1) && (i == 1)) || ((BlockCount > 1) && (i == 2)))
+                Edid_Parse_check_HDMI_VSDB( &hdmitx_device->hdmi_info,  &EDID_buf[i * 128]);
+
+            for( j = 0, CheckSum = 0 ; j < 128 ; j++ )
+            {
+                CheckSum += EDID_buf[i*128 + j] ;
+                CheckSum &= 0xFF ;
+            }
+            if( CheckSum != 0 )
+            {
+                    hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_DVI_OUT;
+            }
+            else
+            {
+                Edid_MonitorCapable861(&hdmitx_device->hdmi_info, EDID_buf[i * 128 + 3]);
+                ret_val = Edid_ParsingCEADataBlockCollection(&hdmitx_device->hdmi_info, &EDID_buf[i * 128]);
+                Edid_ParseCEADetailedTimingDescriptors(&hdmitx_device->hdmi_info, 5, EDID_buf[i * 128 + 2], &EDID_buf[i * 128]);
+                if(hdmitx_device->hdmi_info.output_state != CABLE_PLUGIN_DVI_OUT)
+                    hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_HDMI_OUT;
+            }
+
+        }
+
+        if( EDID_buf[i*128+0] == 0x2  )
+        {
+            if(hdmitx_edid_block_parse(hdmitx_device, &(EDID_buf[i*128]))>=0){
+                if(hdmitx_device->RXCap.IEEEOUI==0x0c03){
+                    break;
+                }
+            }
+        }
+    }
+
+    if(hdmitx_edid_search_IEEEOUI(&EDID_buf[128])) {
+        pRXCap->IEEEOUI = 0x0c03;
+        printk("hdmitx: edid: find IEEEOUT\n");
+    }
+    else {
+        pRXCap->IEEEOUI = 0x0;
+        printk("hdmitx: edid: not find IEEEOUT\n");
+    }
+
+    if((pRXCap->IEEEOUI != 0x0c03) || (pRXCap->IEEEOUI == 0x0)|| (pRXCap->VIC_count == 0)){
+        hdmitx_edid_set_default_vic(hdmitx_device);
+    }    
+
+#if 1    
+    i=hdmitx_edid_dump(hdmitx_device, (char*)(hdmitx_device->tmp_buf), HDMI_TMP_BUF_SIZE);
+    hdmitx_device->tmp_buf[i]=0;
+    hdmi_print(0,"\n");
+#endif    
+    return 0;
+
+}
+
+typedef struct{
+    const char* disp_mode;
+    HDMI_Video_Codes_t VIC;
+}dispmode_vic_t;
+
+static dispmode_vic_t dispmode_VIC_tab[]=
+{
+    {"480i_4_3",  HDMI_480i60},
+    {"480i_rpt",  HDMI_480i60_16x9_rpt},
+    {"480i",      HDMI_480i60_16x9},
+    {"480p_4_3",  HDMI_480p60},
+    {"480p_rpt",  HDMI_480p60_16x9_rpt},
+    {"480p",      HDMI_480p60_16x9},
+    {"576i_4_3",  HDMI_576i50},
+    {"576i_rpt",  HDMI_576i50_16x9_rpt},
+    {"576i",      HDMI_576i50_16x9},
+    {"576p_4_3",  HDMI_576p50},
+    {"576p_rpt",  HDMI_576p50_16x9_rpt},
+    {"576p",      HDMI_576p50_16x9},
+    {"720p50hz",  HDMI_720p50},
+    {"720p",      HDMI_720p60},
+    {"1080i50hz", HDMI_1080i50},
+    {"1080i",     HDMI_1080i60},
+    {"1080p50hz", HDMI_1080p50},
+    {"1080p30hz", HDMI_1080p30},
+    {"1080p24hz", HDMI_1080p24},
+    {"1080p",     HDMI_1080p60},
+    {"4k2k30hz",  HDMI_4k2k_30},
+    {"4k2k25hz",  HDMI_4k2k_25},
+    {"4k2k24hz",  HDMI_4k2k_24},
+    {"4k2ksmpte", HDMI_4k2k_smpte_24},
+    {"4k2k5g",    HDMI_3840x2160p50_16x9},
+    {"4k2k60hz",  HDMI_3840x2160p60_16x9},
+};
+
+int hdmitx_edid_VIC_support(HDMI_Video_Codes_t vic)
+{
+    int i;
+
+    for(i = 0; i < ARRAY_SIZE(dispmode_VIC_tab); i++) {
+        if(vic == dispmode_VIC_tab[i].VIC)
+            return 1;
+    }
+
+    return 0;
+}
+
+HDMI_Video_Codes_t hdmitx_edid_vic_tab_map_vic(const char* disp_mode)
+{
+    HDMI_Video_Codes_t vic = HDMI_Unkown;
+    int i;
+
+    for(i = 0; i < ARRAY_SIZE(dispmode_VIC_tab); i++) {
+        if(strncmp(disp_mode, dispmode_VIC_tab[i].disp_mode, strlen(dispmode_VIC_tab[i].disp_mode))==0) {
+            vic = dispmode_VIC_tab[i].VIC;
+            break;
+        }
+    }
+
+    if(vic == HDMI_Unkown)
+        hdmi_print(INF, EDID "not find mapped vic\n");
+
+    return vic;
+}
+
+const char * hdmitx_edid_vic_tab_map_string(HDMI_Video_Codes_t vic)
+{
+    int i;
+    const char * disp_str = NULL;
+
+    for(i = 0; i < ARRAY_SIZE(dispmode_VIC_tab); i++) {
+        if(vic == dispmode_VIC_tab[i].VIC) {
+            disp_str = dispmode_VIC_tab[i].disp_mode;
+            break;
+        }
+    }
+
+    if(!disp_str)
+        hdmi_print(INF, EDID "not find mapped display mode\n");
+
+    return disp_str;
+}
+
+// force_flag: 0 means check with RX's edid
+//             1 means no check wich RX's edid
+HDMI_Video_Codes_t hdmitx_edid_get_VIC(hdmitx_dev_t* hdmitx_device, const char* disp_mode, char force_flag)
+{
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+    int  j;
+    HDMI_Video_Codes_t vic = hdmitx_edid_vic_tab_map_vic(disp_mode);
+
+    if(vic != HDMI_Unkown) {
+        if(force_flag == 0) {
+            for( j = 0 ; j < pRXCap->VIC_count ; j++ ){
+                if(pRXCap->VIC[j]==vic)
+                    break;
+            }
+            if(j>=pRXCap->VIC_count){
+                vic = HDMI_Unkown;
+            }
+        }
+    }
+    return vic;
+}    
+
+const char* hdmitx_edid_get_native_VIC(hdmitx_dev_t* hdmitx_device)
+{
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+
+    return hdmitx_edid_vic_tab_map_string(pRXCap->native_VIC);
+}    
+
+//Clear HDMI Hardware Module EDID RAM and EDID Buffer
+void hdmitx_edid_ram_buffer_clear(hdmitx_dev_t* hdev)
+{
+    unsigned int i = 0;
+    
+    //Clear HDMI Hardware Module EDID RAM
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_CLEAR_RAM, 0);
+    
+    //Clear EDID Buffer
+    for(i = 0; i < EDID_MAX_BLOCK*128; i++) {
+        hdev->EDID_buf[i] = 0;
+    }
+    for(i = 0; i < EDID_MAX_BLOCK*128; i++) {
+        hdev->EDID_buf1[i] = 0;
+    }
+}
+
+//Clear the Parse result of HDMI Sink's EDID.
+void hdmitx_edid_clear(hdmitx_dev_t* hdmitx_device)
+{
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+    hdmitx_device->vic_count=0;
+    pRXCap->VIC_count = 0;
+    pRXCap->AUD_count = 0;
+    // Note: in most cases, we think that rx is tv and the default IEEEOUI is HDMI Identifier
+    pRXCap->IEEEOUI = 0x000c03;
+    pRXCap->native_Mode = 0;
+    pRXCap->native_VIC = 0xff;
+    pRXCap->RxSpeakerAllocation = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.a = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.b = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.c = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.d = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.valid = 0;
+    memset(&vsdb_local, 0, sizeof(vsdb_phy_addr_t));
+    pRXCap->Video_Latency = 0;
+    pRXCap->Audio_Latency = 0;
+    pRXCap->Interlaced_Video_Latency=0;
+    pRXCap->Interlaced_Audio_Latency=0;
+    pRXCap->threeD_present=0;
+    pRXCap->threeD_Multi_present=0;
+    pRXCap->HDMI_VIC_LEN=0;
+    pRXCap->HDMI_3D_LEN=0;
+    pRXCap->threeD_Structure_ALL_15_0=0;
+    pRXCap->threeD_MASK_15_0=0;
+    memset(pRXCap->ReceiverBrandName, 0, sizeof(pRXCap->ReceiverBrandName));
+    memset(pRXCap->ReceiverProductName, 0, sizeof(pRXCap->ReceiverProductName));
+    memset(&hdmitx_device->RXCap.support_3d_format[0], 0, sizeof(hdmitx_device->RXCap.support_3d_format));
+    memset(&hdmitx_device->EDID_hash[0], 0, sizeof(hdmitx_device->EDID_hash));
+}
+
+/*
+ * print one block data of edid
+ */
+static void hdmitx_edid_blk_print(unsigned char *blk, unsigned int blk_idx)
+{
+    unsigned int i;
+    hdmi_print(INF, EDID "blk%d raw data\n", blk_idx);
+    for(i = 0; i < 128; i++) {
+        printk("%02x", blk[i]);
+        if(((i+1) & 0x1f) == 0)     // print 32bytes a line
+            printk("\n");
+    }
+    printk("\n");
+}
+
+/*
+ * check EDID buf contains valid block numbers
+ */
+static unsigned int hdmitx_edid_check_valid_blocks(unsigned char *buf)
+{
+    unsigned int valid_blk_no = 0;
+    unsigned int i = 0, j = 0;
+    unsigned int tmp_chksum = 0;
+    for(j = 0; j < EDID_MAX_BLOCK; j++) {
+        for(i = 0; i < 128; i++) {
+            tmp_chksum += buf[i + j*128];
+        }
+        if(tmp_chksum !=0) {
+            valid_blk_no ++;
+            if((tmp_chksum & 0xff) == 0) {
+                hdmi_print(INF, EDID "check sum valid\n");
+            }
+            else {
+                hdmi_print(INF, EDID "check sum invalid\n");
+            }
+        }
+        tmp_chksum = 0;
+    }
+    return valid_blk_no;
+}
+
+/*
+ * suppose DDC read EDID two times successfully,
+ * then compare EDID_buf and EDID_buf1.
+ * if same, just print out EDID_buf raw data, else print out 2 buffers
+ */
+void hdmitx_edid_buf_compare_print(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned int i = 0;
+    unsigned int err_no = 0;
+    unsigned char *buf0 = hdmitx_device->EDID_buf;
+    unsigned char *buf1 = hdmitx_device->EDID_buf1;
+    unsigned int valid_blk_no = 0;
+    unsigned int blk_idx = 0;
+
+    for(i = 0; i < EDID_MAX_BLOCK*128; i++) {
+        if(buf0[i] != buf1[i]) {
+            err_no ++;
+        }
+    }
+
+    if(err_no == 0) {
+        // calculate valid edid block numbers
+        valid_blk_no = hdmitx_edid_check_valid_blocks(buf0);
+
+        if(valid_blk_no == 0) {
+            hdmi_print(ERR, EDID "raw data are all zeroes\n");
+        }
+        else {
+            for(blk_idx = 0; blk_idx < valid_blk_no; blk_idx++) {
+                hdmitx_edid_blk_print(&buf0[blk_idx*128], blk_idx);
+            }
+        }
+    }
+    else {
+        hdmi_print(ERR, EDID "%d errors between two reading\n", err_no);
+        valid_blk_no = hdmitx_edid_check_valid_blocks(buf0);
+        for(blk_idx = 0; blk_idx < valid_blk_no; blk_idx++) {
+            hdmitx_edid_blk_print(&buf0[blk_idx*128], blk_idx);
+        }
+
+        valid_blk_no = hdmitx_edid_check_valid_blocks(buf1);
+        for(blk_idx = 0; blk_idx < valid_blk_no; blk_idx++) {
+            hdmitx_edid_blk_print(&buf1[blk_idx*128], blk_idx);
+        }
+    }
+}
+
+int hdmitx_edid_dump(hdmitx_dev_t* hdmitx_device, char* buffer, int buffer_len)
+{
+    int i,pos=0;
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Brand Name: %s\r\n", pRXCap->ReceiverBrandName);
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Product Name: %s\r\n", pRXCap->ReceiverProductName);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "EDID block number: 0x%x\r\n",hdmitx_device->EDID_buf[0x7e]);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Source Physical Address[a.b.c.d]: %x.%x.%x.%x\r\n",
+        hdmitx_device->hdmi_info.vsdb_phy_addr.a, hdmitx_device->hdmi_info.vsdb_phy_addr.b, hdmitx_device->hdmi_info.vsdb_phy_addr.c, hdmitx_device->hdmi_info.vsdb_phy_addr.d);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "native Mode %x, VIC (native %d):\r\n",
+        pRXCap->native_Mode, pRXCap->native_VIC);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "ColorDeepSupport %x, MaxTMDSClock %d\r\n",
+        pRXCap->ColorDeepSupport, pRXCap->Max_TMDS_Clock); 
+
+    for( i = 0 ; i < pRXCap->VIC_count ; i++ )
+    {
+        pos+=snprintf(buffer+pos, buffer_len-pos,"%d ", pRXCap->VIC[i]);
+    }
+    pos+=snprintf(buffer+pos, buffer_len-pos,"\r\n");
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Audio {format, channel, freq, cce}\r\n");
+    for(i = 0; i< pRXCap->AUD_count; i++) {
+        pos+=snprintf(buffer+pos, buffer_len-pos, "{%d, %d, %x, %x}\r\n", pRXCap->RxAudioCap[i].audio_format_code,
+            pRXCap->RxAudioCap[i].channel_num_max, pRXCap->RxAudioCap[i].freq_cc, pRXCap->RxAudioCap[i].cc3);
+    }
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Speaker Allocation: %x\r\n", pRXCap->RxSpeakerAllocation);
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Vendor: %x\r\n", pRXCap->IEEEOUI);
+
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Rx 3D Format Support List:\r\n{VIC FramePacking TopBottom SidebySide}\r\n");
+    for(i = 0 ; i < pRXCap->VIC_count; i++){
+        pos+=snprintf(buffer+pos,buffer_len-pos,"{ %d\t%d\t%d\t%d }\n", pRXCap->VIC[i], 
+                                                                   pRXCap->support_3d_format[pRXCap->VIC[i]].frame_packing,
+                                                                   pRXCap->support_3d_format[pRXCap->VIC[i]].top_and_bottom,
+                                                                   pRXCap->support_3d_format[pRXCap->VIC[i]].side_by_side);
+    }
+    return pos;        
+}    
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.c
new file mode 100644
index 000000000000..3bb33431ccaf
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.c
@@ -0,0 +1,164 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/switch.h>
+#include <asm/uaccess.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include "hdmi_tx_hdcp.h"
+/*
+    hdmi_tx_hdcp.c
+    version 1.1
+*/
+
+static struct switch_dev hdcp_dev = {  // android ics switch device
+       .name = "hdcp",
+};
+
+// For most cases, we don't use HDCP
+// If using HDCP, need add follow command in boot/init.rc and recovery/boot/init.rc
+// write /sys/module/hdmitx/parameters/hdmi_output_force 0
+static int hdmi_output_force = 1;
+static int hdmi_authenticated = -1;
+static int hdmi_hdcp_process = 1;   // default hdcp is on, if aksv is 0, then disable
+
+// Notic: the HDCP key setting has been moved to uboot
+// On MBX project, it is too late for HDCP get from 
+// other devices
+
+/* verify ksv, 20 ones and 20 zeroes*/
+int hdcp_ksv_valid(unsigned char * dat)
+{
+    int i, j, one_num = 0;
+    for(i = 0; i < 5; i++){
+        for(j=0;j<8;j++) {
+            if((dat[i]>>j)&0x1) {
+                one_num++;
+            }
+        }
+    }
+    if(one_num == 0)
+        hdmi_print(INF, HDCP "no HDCP key available\n");
+    return (one_num == 20);
+}
+
+static struct timer_list hdcp_monitor_timer;
+static void hdcp_monitor_func(unsigned long arg)
+{
+    //static int hdcp_auth_flag = 0;
+    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t* )hdcp_monitor_timer.data;
+    if((hdmitx_device->HWOp.Cntl) && (hdmitx_device->log & (HDMI_LOG_HDCP))){
+        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_MONITOR, 1);
+    }
+
+    mod_timer(&hdcp_monitor_timer, jiffies + 2 * HZ);
+}
+
+static int hdmitx_hdcp_task(void *data)
+{
+    static int err_cnt = 0;
+    static int time_cnt = 0;
+    hdmitx_dev_t *hdmitx_device = (hdmitx_dev_t*)data;
+
+    init_timer(&hdcp_monitor_timer);
+    hdcp_monitor_timer.data = (ulong) data;
+    hdcp_monitor_timer.function = hdcp_monitor_func;
+    hdcp_monitor_timer.expires = jiffies + HZ;
+    add_timer(&hdcp_monitor_timer);
+
+    while(hdmitx_device->hpd_event != 0xff) {
+        if((hdmitx_device->output_blank_flag == 1) && (hdmitx_device->hpd_state == 1) && (hdmitx_device->cur_VIC != HDMI_Unkown)) {
+            err_cnt = 0;
+            time_cnt = 1;
+            hdmitx_device->output_blank_flag = 0;
+#ifdef CONFIG_AML_HDMI_TX_HDCP
+            hdmi_print(INF, HDCP "start hdcp\n");
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, AVMUTE_OFF, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_EDID, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_EDID_READ_DATA, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_HDCP, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_OP, HDCP_ON);
+            msleep(100);
+            while((hdmitx_device->hpd_state == 1) && (hdmitx_device->cur_VIC != HDMI_Unkown)) {
+                hdmi_authenticated = hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_GET_AUTH, 0);
+                switch_set_state(&hdcp_dev, hdmi_authenticated);
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, hdmi_authenticated ? VIDEO_UNBLANK: VIDEO_BLANK);
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, hdmi_authenticated ? AUDIO_UNMUTE : AUDIO_MUTE);
+                if( !hdmi_authenticated ) {
+                    err_cnt ++;
+                    if(err_cnt & (3 << time_cnt)) {
+                        time_cnt ++;
+                        hdmi_print(ERR, HDCP "authenticated failed\n");
+                    }
+                }
+                msleep(20);
+                if(hdmitx_device->output_blank_flag == 1)
+                    break;
+            }
+#else
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
+            hdmitx_device->audio_step = 1;
+#endif
+        }
+        msleep_interruptible(100);
+    }
+
+    return 0;
+}
+
+static int __init hdmitx_hdcp_init(void)
+{
+    hdmitx_dev_t *hdmitx_device = get_hdmitx_device();
+
+    switch_dev_register(&hdcp_dev);
+
+    hdmitx_device->task_hdcp = kthread_run(hdmitx_hdcp_task, (void*)hdmitx_device, "kthread_hdcp");
+
+    return 0;
+}
+
+static void __exit hdmitx_hdcp_exit(void)
+{
+    switch_dev_unregister(&hdcp_dev);
+}
+
+
+MODULE_PARM_DESC(hdmi_authenticated, "\n hdmi_authenticated \n");
+module_param(hdmi_authenticated, int, S_IRUGO);
+
+MODULE_PARM_DESC(hdmi_hdcp_process, "\n hdmi_hdcp_process \n");
+module_param(hdmi_hdcp_process, int, 0664);
+
+MODULE_PARM_DESC(hdmi_output_force, "\n hdmi_output_force \n");
+module_param(hdmi_output_force, int, 0664);
+
+
+module_init(hdmitx_hdcp_init);
+//device_initcall_sync(hdmitx_hdcp_init);
+module_exit(hdmitx_hdcp_exit);
+MODULE_DESCRIPTION("AMLOGIC HDMI TX HDCP driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.h b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.h
new file mode 100644
index 000000000000..eac0270f0ef3
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.h
@@ -0,0 +1,17 @@
+#ifndef __HDMI_TX_HDCP_H
+#define __HDMI_TX_HDCP_H
+/*
+    hdmi_tx_hdcp.c
+    version 1.0
+*/
+
+// Notic: the HDCP key setting has been moved to uboot
+// On MBX project, it is too late for HDCP get from
+// other devices
+
+//int task_tx_key_setting(unsigned force_wrong);
+
+int hdcp_ksv_valid(unsigned char * dat);
+
+#endif
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c
new file mode 100644
index 000000000000..f6e1ccb44461
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c
@@ -0,0 +1,1819 @@
+/*
+ * Amlogic HDMI Transmitter 2.0 Driver
+ * Copyright (C) 2014 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/switch.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <mach/am_regs.h>
+
+#include <linux/amlogic/osd/osd_dev.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include <plat/hdmi_config.h>
+#include "hdmi_tx_hdcp.h"
+
+#include <linux/input.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/of.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+
+#define DEVICE_NAME "amhdmitx"
+#define HDMI_TX_COUNT 32
+#define HDMI_TX_POOL_NUM  6
+#define HDMI_TX_RESOURCE_NUM 4
+#define HDMI_TX_PWR_CTRL_NUM    6
+
+static dev_t hdmitx_id;
+static struct class *hdmitx_class;
+static struct device *hdmitx_dev;
+
+static int set_disp_mode_auto(void);
+const vinfo_t * hdmi_get_current_vinfo(void);
+extern void hdmitx_edid_ram_buffer_clear(hdmitx_dev_t*);
+
+struct hdmi_config_platform_data *hdmi_pdata;
+
+static hdmitx_dev_t hdmitx_device;
+static struct switch_dev sdev = {      // android ics switch device
+       .name = "hdmi",
+       };
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static void hdmitx_early_suspend(struct early_suspend *h)
+{
+    const vinfo_t *info = hdmi_get_current_vinfo();
+    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
+    if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0))
+        return;
+    phdmi->hpd_lock = 1;
+    phdmi->HWOp.Cntl((hdmitx_dev_t *)h->param, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_EARLY_SUSPEND);
+    phdmi->cur_VIC = HDMI_Unkown;
+    phdmi->output_blank_flag = 0;
+    phdmi->HWOp.CntlDDC(phdmi, DDC_HDCP_OP, HDCP_OFF);
+    phdmi->HWOp.CntlDDC(phdmi, DDC_HDCP_OP, DDC_RESET_HDCP);
+    phdmi->HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+    phdmi->HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+    hdmi_print(IMP, SYS "HDMITX: early suspend\n");
+}
+
+static void hdmitx_late_resume(struct early_suspend *h)
+{
+    const vinfo_t *info = hdmi_get_current_vinfo();
+    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
+    if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0)) {
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+       return ;
+    } else {
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
+    }
+    phdmi->hpd_lock = 0;
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    hdmitx_device.internal_mode_change = 0;
+    set_disp_mode_auto();
+    pr_info("amhdmitx: late resume module %d\n", __LINE__);
+    phdmi->HWOp.Cntl((hdmitx_dev_t *)h->param, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_LATE_RESUME);
+    hdmi_print(INF, SYS "late resume\n");
+}
+
+static struct early_suspend hdmitx_early_suspend_handler = {
+    .level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 10,
+    .suspend = hdmitx_early_suspend,
+    .resume = hdmitx_late_resume,
+    .param = &hdmitx_device,
+};
+#endif
+
+//static HDMI_TX_INFO_t hdmi_info;
+#define INIT_FLAG_VDACOFF        0x1
+    /* unplug powerdown */
+#define INIT_FLAG_POWERDOWN      0x2
+
+#define INIT_FLAG_NOT_LOAD 0x80
+
+int hdmi_ch = 1;        //1: 2ch
+
+static unsigned char init_flag=0;
+static unsigned char init_powermode=0;
+#undef DISABLE_AUDIO
+unsigned char hdmi_audio_off_flag = 0;        //if set to 1, then HDMI will output no audio
+                                                //In KTV case, HDMI output Picture only, and Audio is driven by other sources.
+static int hpdmode = 1; /*
+                            0, do not unmux hpd when off or unplug ;
+                            1, unmux hpd when unplug;
+                            2, unmux hpd when unplug  or off;
+                        */
+#ifdef CONFIG_AM_TV_OUTPUT2
+static int force_vout_index = 0;
+#endif
+static int hdmi_prbs_mode = 0xffff; /* 0xffff=disable; 0=PRBS 11; 1=PRBS 15; 2=PRBS 7; 3=PRBS 31*/
+static int hdmi_480p_force_clk = 0; /* 200, 225, 250, 270 */
+
+static int debug_level = INF;     // 1: error  2: important  3: normal  4: detailed
+
+/*****************************
+*    hdmitx attr management :
+*    enable
+*    mode
+*    reg
+******************************/
+static void set_test_mode(void)
+{
+#ifdef ENABLE_TEST_MODE
+//when it is used as test source (PRBS and 20,22.5,25MHz)
+                if((hdmi_480p_force_clk)&&
+                   ((hdmitx_device.cur_VIC==HDMI_480p60)||
+                    (hdmitx_device.cur_VIC==HDMI_480p60_16x9)||
+                    (hdmitx_device.cur_VIC==HDMI_480i60)||
+                    (hdmitx_device.cur_VIC==HDMI_480i60_16x9)||
+                    (hdmitx_device.cur_VIC==HDMI_576p50)||
+                    (hdmitx_device.cur_VIC==HDMI_576p50_16x9)||
+                    (hdmitx_device.cur_VIC==HDMI_576i50)||
+                    (hdmitx_device.cur_VIC==HDMI_576i50_16x9))
+                    ){
+                    if(hdmitx_device.HWOp.Cntl){
+                        hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_FORCE_480P_CLK, hdmi_480p_force_clk);
+                    }
+                }
+                if(hdmi_prbs_mode != 0xffff){
+                    if(hdmitx_device.HWOp.Cntl){
+                        hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURN_ON_PRBS, hdmi_prbs_mode);
+                    }
+                }
+#endif
+
+}
+
+int get_cur_vout_index(void)
+/*
+return value: 1, vout; 2, vout2;
+*/
+{
+    int vout_index = 1;
+#ifdef CONFIG_AM_TV_OUTPUT2
+    if(force_vout_index){
+        vout_index = force_vout_index;
+    }
+    else{
+//VPU_VIU_VENC_MUX_CTRL
+// [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
+//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
+// [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
+//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
+        int viu2_sel = (aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)>>2)&0x3;
+        int viu1_sel = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
+        if(((viu2_sel==1)||(viu2_sel==2))&&
+            (viu1_sel!=1)&&(viu1_sel!=2)){
+            vout_index = 2;
+        }
+    }
+#endif
+    return vout_index;
+}
+
+const vinfo_t * hdmi_get_current_vinfo(void)
+{
+    const vinfo_t *info;
+#ifdef CONFIG_AM_TV_OUTPUT2
+    if(get_cur_vout_index() == 2){
+        info = get_current_vinfo2();
+        if(info == NULL){ //add to fix problem when dual display is not enabled in UI
+            info = get_current_vinfo();
+        }
+    }
+    else{
+        info = get_current_vinfo();
+    }
+#else
+    info = get_current_vinfo();
+#endif
+    return info;
+}
+
+static  int  set_disp_mode(const char *mode)
+{
+    int ret=-1;
+    HDMI_Video_Codes_t vic;
+
+    vic = hdmitx_edid_get_VIC(&hdmitx_device, mode, 1);
+    if(strncmp(mode, "4k2k30hz", strlen("4k2k30hz")) == 0) {
+        vic = HDMI_4k2k_30;
+    }
+    else if(strncmp(mode, "4k2k25hz", strlen("4k2k25hz")) == 0) {
+        vic = HDMI_4k2k_25;
+    }
+    else if(strncmp(mode, "4k2k24hz", strlen("4k2k24hz")) == 0) {
+        vic = HDMI_4k2k_24;
+    }
+    else if(strncmp(mode, "4k2ksmpte", strlen("4k2ksmpte")) == 0) {
+        vic = HDMI_4k2k_smpte_24;
+    }
+    else if(strncmp(mode, "4k2k5G", strlen("4k2k5G")) == 0) {
+        vic = HDMI_3840x2160p50_16x9;
+    }
+    else {
+        //nothing
+    }
+
+    if(vic != HDMI_Unkown){
+        hdmitx_device.mux_hpd_if_pin_high_flag = 1;
+        if(hdmitx_device.vic_count == 0){
+               if(hdmitx_device.unplug_powerdown){
+                   return 0;
+                }
+            }
+        }
+
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    ret = hdmitx_set_display(&hdmitx_device, vic);
+    if(ret>=0){
+        hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_CLEAR);
+        hdmitx_device.cur_VIC = vic;
+        hdmitx_device.audio_param_update_flag = 1;
+        hdmitx_device.auth_process_timer = AUTH_PROCESS_TIME;
+        hdmitx_device.internal_mode_change = 0;
+        set_test_mode();
+    }
+
+    if(hdmitx_device.cur_VIC == HDMI_Unkown){
+        if(hpdmode == 2){
+            hdmitx_edid_clear(&hdmitx_device); /* edid will be read again when hpd is muxed and it is high */
+            hdmitx_device.mux_hpd_if_pin_high_flag = 0;
+        }
+        if(hdmitx_device.HWOp.Cntl){
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
+        }
+    }
+
+    return ret;
+}
+
+static void hdmitx_pre_display_init(void)
+{
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    hdmitx_device.auth_process_timer = AUTH_PROCESS_TIME;
+    hdmitx_device.internal_mode_change = 1;
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    //msleep(10);
+    hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_ENABLE);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_CBUS_RST, 0);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_IP_SW_RST, TX_SYS_SW_RST);
+    //msleep(50);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_DISABLE);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_CLEAR);
+//    msleep(20);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+    hdmi_print(DET);
+    hdmitx_device.internal_mode_change = 0;
+}
+
+static int set_disp_mode_auto(void)
+{
+    int ret=-1;
+    const vinfo_t *info = NULL;
+    unsigned char mode[16];
+    HDMI_Video_Codes_t vic = HDMI_Unkown;
+    // vic_ready got from IP
+    HDMI_Video_Codes_t vic_ready = hdmitx_device.HWOp.GetState(&hdmitx_device, STAT_VIDEO_VIC, 0);
+
+    memset(mode, 0, 10);
+
+    // if HDMI plug-out, directly return
+    if(!(hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_HPD_GPI_ST, 0))) {
+        hdmi_print(ERR, HPD "HPD deassert!\n");
+        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+        return -1;
+    }
+
+    // get current vinfo
+    info = hdmi_get_current_vinfo();
+    if(info == NULL) {
+        hdmi_print(ERR, VID "cann't get valid mode\n");
+        return -1;
+    }
+    else {
+        hdmi_print(IMP, VID "get current mode: %s\n", info->name);
+    }
+
+// If info->name equals to cvbs, then set mode to I mode to hdmi
+    if((strncmp(info->name, "480cvbs", 7) == 0) || (strncmp(info->name, "576cvbs", 7) == 0) ||
+       (strncmp(info->name, "panel", 5) == 0) || (strncmp(info->name, "null", 4) == 0)) {
+        hdmi_print(ERR, VID "%s not valid hdmi mode\n", info->name);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+        return -1;
+    }
+    else {
+        memcpy(mode, info->name, strlen(info->name));
+    }
+
+    //msleep(500);
+    vic = hdmitx_edid_get_VIC(&hdmitx_device, mode, 1);
+    if(strncmp(info->name, "4k2k30hz", strlen("4k2k30hz")) == 0) {
+        vic = HDMI_4k2k_30;
+    }
+    else if(strncmp(info->name, "4k2k25hz", strlen("4k2k25hz")) == 0) {
+        vic = HDMI_4k2k_25;
+    }
+    else if(strncmp(info->name, "4k2k24hz", strlen("4k2k24hz")) == 0) {
+        vic = HDMI_4k2k_24;
+    }
+    else if(strncmp(info->name, "4k2ksmpte", strlen("4k2ksmpte")) == 0) {
+        vic = HDMI_4k2k_smpte_24;
+    }
+    else if(strncmp(mode, "4k2k5G", strlen("4k2k5G")) == 0) {
+        vic = HDMI_3840x2160p50_16x9;
+    }
+    else if(strncmp(mode, "4k2k60hz", strlen("4k2k60hz")) == 0) {
+        vic = HDMI_3840x2160p60_16x9;
+    }
+    else {
+        //nothing
+    }
+
+    if((vic_ready != HDMI_Unkown) && (vic_ready == vic)) {
+        hdmi_print(IMP, SYS "[%s] ALREADY init VIC = %d\n", __func__, vic);
+#ifdef CONFIG_AML_HDMI_TX_CTS_DVI
+        if(hdmitx_device.RXCap.IEEEOUI == 0) {
+            // DVI case judgement. In uboot, directly output HDMI mode
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_HDMI_DVI_MODE, DVI_MODE);
+            hdmi_print(IMP, SYS "change to DVI mode\n");
+        }
+#endif
+        hdmitx_device.cur_VIC = vic;
+        hdmitx_device.output_blank_flag = 1;
+        return 1;
+    }
+    else {
+        hdmitx_pre_display_init();
+    }
+
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    ret = hdmitx_set_display(&hdmitx_device, vic); //if vic is HDMI_Unkown, hdmitx_set_display will disable HDMI
+    if(ret>=0){
+        hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_CLEAR);
+        hdmitx_device.cur_VIC = vic;
+        hdmitx_device.audio_param_update_flag = 1;
+        hdmitx_device.auth_process_timer = AUTH_PROCESS_TIME;
+        hdmitx_device.internal_mode_change = 0;
+        set_test_mode();
+    }
+    if(hdmitx_device.cur_VIC == HDMI_Unkown){
+        if(hpdmode==2){
+            hdmitx_edid_clear(&hdmitx_device); /* edid will be read again when hpd is muxed and it is high */
+            hdmitx_device.mux_hpd_if_pin_high_flag = 0;
+        }
+        // If current display is NOT panel, needn't TURNOFF_HDMIHW
+        if(strncmp(mode, "panel", 5) == 0){
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
+        }
+    }
+    if(hdmitx_device.mode420) {
+        if(hdmitx_device.cur_VIC == HDMI_3840x2160p60_16x9) {
+            printk("configure mode420, VIC = %d\n", hdmitx_device.cur_VIC);
+            hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_CONF_MODE420, hdmitx_device.mode420);
+        }
+        else {
+            hdmitx_device.mode420 = 0;
+            printk("mode420 only at VIC: %d\n", HDMI_3840x2160p60_16x9);
+        }
+    }
+    hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_CLK_DIV40, hdmitx_device.cur_VIC);
+    hdmitx_set_audio(&hdmitx_device, &(hdmitx_device.cur_audio_param), hdmi_ch);
+    hdmitx_device.output_blank_flag = 1;
+    return ret;
+}
+#if 0
+static unsigned int set_cec_code(const char * buf, size_t count)
+{
+    char tmpbuf[128];
+    int i=0;
+    //int j;
+    unsigned int cec_code;
+    //unsigned int value=0;
+
+    while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
+        tmpbuf[i]=buf[i];
+        i++;
+    }
+    tmpbuf[i]=0;
+
+    cec_code=simple_strtoul(tmpbuf, NULL, 16);
+
+    input_event(remote_cec_dev, EV_KEY, cec_code,1);
+    input_event(remote_cec_dev, EV_KEY, cec_code,0);
+    input_sync(remote_cec_dev);
+    return cec_code;
+}
+#endif
+static unsigned char is_dispmode_valid_for_hdmi(void)
+{
+    HDMI_Video_Codes_t vic;
+    const vinfo_t *info = hdmi_get_current_vinfo();
+
+    vic = hdmitx_edid_get_VIC(&hdmitx_device, info->name, 1);
+
+    return (vic != HDMI_Unkown);
+}
+
+/*disp_mode attr*/
+static ssize_t show_disp_mode(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+    pos+=snprintf(buf+pos, PAGE_SIZE, "VIC:%d\r\n", hdmitx_device.cur_VIC);
+    return pos;
+}
+
+static ssize_t store_disp_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    set_disp_mode(buf);
+    return 16;
+}
+
+/*cec attr*/
+static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    ssize_t t = cec_usrcmd_get_global_info(buf);
+    return t;
+}
+
+static ssize_t store_cec(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    cec_usrcmd_set_dispatch(buf, count);
+    return count;
+}
+
+//static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
+//{
+//    ssize_t t = cec_usrcmd_get_global_info(buf);
+//    return t;
+//}
+
+static ssize_t show_cec_config(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+    pos+=snprintf(buf+pos, PAGE_SIZE, "P_AO_DEBUG_REG0:0x%x\r\n", aml_read_reg32(P_AO_DEBUG_REG0));
+    return pos;
+}
+
+static ssize_t store_cec_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    cec_usrcmd_set_config(buf, count);
+    return count;
+}
+
+static ssize_t store_cec_lang_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    hdmi_print(INF, CEC "store_cec_lang_config\n");
+    //cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = strtoul(buf, NULL, 16);
+    cec_usrcmd_set_lang_config(buf, count);
+    return count;
+}
+
+static ssize_t show_cec_lang_config(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+    hdmi_print(INF, CEC "show_cec_lang_config\n");
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);
+    return pos;
+}
+
+/*aud_mode attr*/
+static ssize_t show_aud_mode(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    return 0;
+}
+
+static ssize_t store_aud_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    //set_disp_mode(buf);
+    Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
+    if(strncmp(buf, "32k", 3)==0){
+        audio_param->sample_rate = FS_32K;
+    }
+    else if(strncmp(buf, "44.1k", 5)==0){
+        audio_param->sample_rate = FS_44K1;
+    }
+    else if(strncmp(buf, "48k", 3)==0){
+        audio_param->sample_rate = FS_48K;
+    }
+    else{
+        hdmitx_device.force_audio_flag = 0;
+        return count;
+    }
+    audio_param->type = CT_PCM;
+    audio_param->channel_num = CC_2CH;
+    audio_param->sample_size = SS_16BITS;
+
+    hdmitx_device.audio_param_update_flag = 1;
+    hdmitx_device.force_audio_flag = 1;
+
+    return count;
+}
+
+/*edid attr*/
+static ssize_t show_edid(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return hdmitx_edid_dump(&hdmitx_device, buf, PAGE_SIZE);
+}
+
+static ssize_t store_edid(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    if(buf[0]=='h'){
+        int i;
+        hdmi_print(INF, EDID "EDID hash value:\n");
+        for(i=0; i < 20; i++)
+            printk("%02x", hdmitx_device.EDID_hash[i]);
+        printk("\n");
+    }
+    if(buf[0]=='d'){
+        int ii,jj;
+        int block_idx;
+        block_idx=simple_strtoul(buf+1,NULL,16);
+        if(block_idx<EDID_MAX_BLOCK){
+            for(ii=0;ii<8;ii++){
+                for(jj=0;jj<16;jj++){
+                    printk("%02x ",hdmitx_device.EDID_buf[block_idx*128+ii*16+jj]);
+                }
+                printk("\n");
+            }
+            printk("\n");
+        }
+    }
+    if(buf[0]=='e'){
+        int ii,jj;
+        int block_idx;
+        block_idx=simple_strtoul(buf+1,NULL,16);
+        if(block_idx<EDID_MAX_BLOCK){
+            for(ii=0;ii<8;ii++){
+                for(jj=0;jj<16;jj++){
+                    printk("%02x ",hdmitx_device.EDID_buf1[block_idx*128+ii*16+jj]);
+                }
+                printk("\n");
+            }
+            printk("\n");
+        }
+    }
+    return 16;
+}
+
+/*config attr*/
+static ssize_t show_config(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+    unsigned char *aud_conf;
+    switch(hdmitx_device.tx_aud_cfg) {
+    case 0:
+        aud_conf = "off";
+        break;
+    case 1:
+        aud_conf = "on";
+        break;
+    case 2:
+        aud_conf = "auto";
+        break;
+    default:
+        aud_conf = "none";
+    }
+    pos += snprintf(buf+pos, PAGE_SIZE, "disp switch (force or edid): %s\r\n", (hdmitx_device.disp_switch_config==DISP_SWITCH_FORCE)?"force":"edid");
+    pos += snprintf(buf+pos, PAGE_SIZE, "audio config: %s\r\n", aud_conf);
+    pos += snprintf(buf+pos, PAGE_SIZE, "mode420: %s\r\n", hdmitx_device.mode420 ? "on" : "off");
+    return pos;
+}
+
+static ssize_t store_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    if(strncmp(buf, "force", 5)==0){
+        hdmitx_device.disp_switch_config=DISP_SWITCH_FORCE;
+    }
+    else if(strncmp(buf, "edid", 4)==0){
+        hdmitx_device.disp_switch_config=DISP_SWITCH_EDID;
+    }
+    else if(strncmp(buf, "mode420", 7) == 0) {
+        if(strncmp(buf+7, "on", 2) == 0) {
+            hdmitx_device.mode420 = 1;
+        }
+        if(strncmp(buf+7, "off", 3) == 0) {
+            hdmitx_device.mode420 = 0;
+        }
+    }
+    else if(strncmp(buf, "unplug_powerdown", 16) == 0){
+        if(buf[16] == '0'){
+            hdmitx_device.unplug_powerdown = 0;
+        }
+        else{
+            hdmitx_device.unplug_powerdown = 1;
+        }
+    }
+    else if(strncmp(buf, "3d", 2)==0){
+			// First, disable HDMI TMDS
+			hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+			// Second, set 3D parameters
+        if(strncmp(buf+2, "tb", 2)==0){
+            hdmi_set_3d(&hdmitx_device, 6, 0);
+        }
+        else if(strncmp(buf+2, "lr", 2)==0){
+            int sub_sample_mode=0;
+            if(buf[2])
+                sub_sample_mode = simple_strtoul(buf+2,NULL,10);
+            hdmi_set_3d(&hdmitx_device, 8, sub_sample_mode); //side by side
+        }
+        else if(strncmp(buf+2, "off", 3)==0){
+            hdmi_set_3d(&hdmitx_device, 0xf, 0);
+        }
+				// Last, delay sometime and enable HDMI TMDS
+				msleep(20);
+				hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_ENABLE);
+    }
+    else if(strncmp(buf, "audio_", 6)==0) {
+        if(strncmp(buf+6, "off", 3) == 0) {
+            hdmitx_device.tx_aud_cfg = 0;
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+            hdmi_print(IMP, AUD "configure off\n");
+        }
+        else if(strncmp(buf+6, "on", 2) == 0) {
+            hdmitx_device.tx_aud_cfg = 1;
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
+            hdmi_print(IMP, AUD "configure on\n");
+        }
+        else if(strncmp(buf+6, "auto", 4) == 0) {
+            // auto mode. if sink doesn't support current audio format, then no audio output
+            hdmitx_device.tx_aud_cfg = 2;
+            hdmi_print(IMP, AUD "configure auto\n");
+        }
+        else {
+            hdmi_print(ERR, AUD "configure error\n");
+        }
+    }
+    return 16;
+}
+
+
+static ssize_t store_debug(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    hdmitx_device.HWOp.DebugFun(&hdmitx_device, buf);
+    return 16;
+}
+
+// support format lists
+const char* disp_mode_t[]={
+    "480i",
+    "480i_rpt",
+    "480p",
+    "480p_rpt",
+    "576i",
+    "576i_rpt",
+    "576p",
+    "576p_rpt",
+    "720p",
+    "1080i",
+    "1080p",
+    "720p50hz",
+    "1080i50hz",
+    "1080p50hz",
+    "1080p24hz",
+    "4k2k30hz",
+    "4k2k25hz",
+    "4k2k24hz",
+    "4k2ksmpte",
+    NULL
+};
+
+/**/
+static ssize_t show_disp_cap(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int i,pos=0;
+    const char* native_disp_mode = hdmitx_edid_get_native_VIC(&hdmitx_device);
+    HDMI_Video_Codes_t vic;
+    if(hdmitx_device.tv_no_edid){
+        pos += snprintf(buf+pos, PAGE_SIZE,"null edid\n");
+    }
+    else{
+        for(i=0; disp_mode_t[i]; i++){
+            vic = hdmitx_edid_get_VIC(&hdmitx_device, disp_mode_t[i], 0);
+            if( vic != HDMI_Unkown){
+                pos += snprintf(buf+pos, PAGE_SIZE,"%s",disp_mode_t[i]);
+                if(native_disp_mode&&(strcmp(native_disp_mode, disp_mode_t[i])==0)){
+                    pos += snprintf(buf+pos, PAGE_SIZE,"*\n");
+                }
+                else{
+                pos += snprintf(buf+pos, PAGE_SIZE,"\n");
+                }
+            }
+        }
+    }
+    return pos;
+}
+
+
+/**/
+static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int i,pos=0;
+    int j=0;
+    HDMI_Video_Codes_t vic;
+
+    for(i=0; disp_mode_t[i]; i++){
+        vic = hdmitx_edid_get_VIC(&hdmitx_device, disp_mode_t[i], 0);
+        if( vic == hdmitx_device.cur_VIC) {
+            for(j = 0; j < hdmitx_device.RXCap.VIC_count; j++) {
+                if(vic == hdmitx_device.RXCap.VIC[j]){
+                    break;
+                }
+            }
+            pos += snprintf(buf+pos, PAGE_SIZE,"%s ",disp_mode_t[i]);
+            if(hdmitx_device.RXCap.support_3d_format[hdmitx_device.RXCap.VIC[j]].frame_packing == 1) {
+                pos += snprintf(buf+pos, PAGE_SIZE, "FramePacking ");
+            }
+            if(hdmitx_device.RXCap.support_3d_format[hdmitx_device.RXCap.VIC[j]].top_and_bottom == 1) {
+                pos += snprintf(buf+pos, PAGE_SIZE, "TopBottom ");
+            }
+            if(hdmitx_device.RXCap.support_3d_format[hdmitx_device.RXCap.VIC[j]].side_by_side == 1) {
+                pos += snprintf(buf+pos, PAGE_SIZE, "SidebySide ");
+            }
+        }
+    }
+    pos += snprintf(buf+pos, PAGE_SIZE, "\r\n");
+
+    return pos;
+}
+
+/**/
+static ssize_t show_aud_cap(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int i,pos=0, j;
+    const char* aud_coding_type[] =  {"ReferToStreamHeader", "PCM", "AC-3", "MPEG1", "MP3", "MPEG2", "AAC", "DTS", "ATRAC",
+                "OneBitAudio", "Dobly_Digital+", "DTS-HD", "MAT", "DST", "WMA_Pro", "Reserved", NULL};
+    const char* aud_sampling_frequency[] = {"ReferToStreamHeader", "32", "44.1", "48", "88.2", "96", "176.4", "192", NULL};
+    const char* aud_sample_size[] = {"ReferToStreamHeader", "16", "20", "24", NULL};
+
+    rx_cap_t* pRXCap = &(hdmitx_device.RXCap);
+    pos += snprintf(buf + pos, PAGE_SIZE, "CodingType, MaxChannels, SamplingFrequency, SampleSize\n");
+    for(i = 0; i< pRXCap->AUD_count; i++) {
+        pos += snprintf(buf + pos, PAGE_SIZE, "%s, %d ch, ", aud_coding_type[pRXCap->RxAudioCap[i].audio_format_code],
+            pRXCap->RxAudioCap[i].channel_num_max + 1);
+        for(j = 0; j < 7; j++) {
+            if(pRXCap->RxAudioCap[i].freq_cc & (1 << j))
+                pos += snprintf(buf + pos, PAGE_SIZE, "%s/", aud_sampling_frequency[j+1]);
+        }
+        pos += snprintf(buf + pos - 1, PAGE_SIZE, " kHz, ");
+        for(j = 0; j < 3; j++) {
+            if(pRXCap->RxAudioCap[i].cc3 & (1 << j))
+                pos += snprintf(buf + pos, PAGE_SIZE, "%s/", aud_sample_size[j+1]);
+        }
+        pos += snprintf(buf + pos - 1, PAGE_SIZE, " bit\n");
+    }
+
+    return pos;
+}
+
+static ssize_t show_aud_ch(struct device * dev, struct device_attribute *attr, char * buf)
+{
+       int pos = 0;
+       pos += snprintf(buf + pos, PAGE_SIZE, "hdmi_channel = %d ch\n", hdmi_ch ? hdmi_ch + 1 : 0);
+       return pos;
+}
+
+static ssize_t store_aud_ch(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    if(strncmp(buf, "6ch", 3) == 0){
+        hdmi_ch = 5;
+    }
+    else if(strncmp(buf, "8ch", 3) == 0){
+        hdmi_ch = 7;
+    }
+    else if(strncmp(buf, "2ch", 3) == 0){
+        hdmi_ch = 1;
+    }
+    else{
+        return count;
+    }
+
+    hdmitx_device.audio_param_update_flag = 1;
+    hdmitx_device.force_audio_flag = 1;
+
+    return count;
+}
+
+static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos = 0, i;
+    char aksv_buf[5];
+    char bksv_buf[5];
+
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_GET_AKSV, (unsigned int)aksv_buf);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_GET_BKSV, (unsigned int)bksv_buf);
+
+    pos+=snprintf(buf+pos, PAGE_SIZE, "AKSV: ");
+    for(i = 0;i < 5; i++) {
+        pos+=snprintf(buf+pos, PAGE_SIZE, "%02x", aksv_buf[i]);
+    }
+    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\r\n", hdcp_ksv_valid(aksv_buf) ? "Valid" : "Invalid");
+
+    pos+=snprintf(buf+pos, PAGE_SIZE, "BKSV: ");
+    for(i = 0;i < 5; i++) {
+        pos+=snprintf(buf+pos, PAGE_SIZE, "%02x", bksv_buf[i]);
+    }
+    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\r\n", hdcp_ksv_valid(bksv_buf) ? "Valid" : "Invalid");
+
+    return pos;
+}
+
+static ssize_t show_hpd_state(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+
+    hdmitx_device.hpd_state = hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_HPD_GPI_ST, 0);
+    pos += snprintf(buf+pos, PAGE_SIZE,"%d", hdmitx_device.hpd_state);
+    return pos;
+}
+
+static ssize_t show_support_3d(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+
+    pos += snprintf(buf+pos, PAGE_SIZE,"%d\r\n", hdmitx_device.RXCap.threeD_present);
+    return pos;
+}
+
+void hdmi_print(int dbg_lvl, const char *fmt, ...)
+{
+    va_list args;
+    if(dbg_lvl == OFF)
+        return ;
+    if(dbg_lvl <= debug_level) {
+        va_start(args, fmt);
+        vprintk(fmt, args);
+        va_end(args);
+    }
+}
+
+static DEVICE_ATTR(disp_mode, S_IWUSR | S_IRUGO | S_IWGRP, show_disp_mode, store_disp_mode);
+static DEVICE_ATTR(aud_mode, S_IWUSR | S_IRUGO, show_aud_mode, store_aud_mode);
+static DEVICE_ATTR(edid, S_IWUSR | S_IRUGO, show_edid, store_edid);
+static DEVICE_ATTR(config, S_IWUSR | S_IRUGO | S_IWGRP, show_config, store_config);
+static DEVICE_ATTR(debug, S_IWUSR | S_IRUGO, NULL, store_debug);
+static DEVICE_ATTR(disp_cap, S_IWUSR | S_IRUGO, show_disp_cap, NULL);
+static DEVICE_ATTR(aud_cap, S_IWUSR | S_IRUGO, show_aud_cap, NULL);
+static DEVICE_ATTR(aud_ch, S_IWUSR | S_IRUGO | S_IWGRP, show_aud_ch, store_aud_ch);
+static DEVICE_ATTR(disp_cap_3d, S_IWUSR | S_IRUGO, show_disp_cap_3d, NULL);
+static DEVICE_ATTR(hdcp_ksv_info, S_IWUSR | S_IRUGO, show_hdcp_ksv_info, NULL);
+static DEVICE_ATTR(hpd_state, S_IWUSR | S_IRUGO, show_hpd_state, NULL);
+static DEVICE_ATTR(support_3d, S_IWUSR | S_IRUGO, show_support_3d, NULL);
+static DEVICE_ATTR(cec, S_IWUSR | S_IRUGO, show_cec, store_cec);
+static DEVICE_ATTR(cec_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_config, store_cec_config);
+//static DEVICE_ATTR(cec_config, S_IWUGO | S_IRUGO , NULL, store_cec_config);
+static DEVICE_ATTR(cec_lang_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_lang_config, store_cec_lang_config);
+
+/*****************************
+*    hdmitx display client interface
+*
+******************************/
+static int hdmitx_notify_callback_v(struct notifier_block *block, unsigned long cmd , void *para)
+{
+    if(get_cur_vout_index()!=1)
+        return 0;
+
+    if (cmd != VOUT_EVENT_MODE_CHANGE)
+        return 0;
+    if(hdmitx_device.vic_count == 0){
+        if(is_dispmode_valid_for_hdmi()){
+            hdmitx_device.mux_hpd_if_pin_high_flag = 1;
+            if(hdmitx_device.unplug_powerdown){
+                      return 0;
+                  }
+            }
+    }
+
+    set_disp_mode_auto();
+
+    return 0;
+}
+
+#ifdef CONFIG_AM_TV_OUTPUT2
+static int hdmitx_notify_callback_v2(struct notifier_block *block, unsigned long cmd , void *para)
+{
+    if(get_cur_vout_index()!=2)
+        return 0;
+
+    if (cmd != VOUT_EVENT_MODE_CHANGE)
+        return 0;
+
+    if(hdmitx_device.vic_count == 0){
+        if(is_dispmode_valid_for_hdmi()){
+            hdmitx_device.mux_hpd_if_pin_high_flag = 1;
+            if(hdmitx_device.unplug_powerdown){
+                      return 0;
+                  }
+            }
+    }
+
+    set_disp_mode_auto();
+
+    return 0;
+}
+#endif
+
+static struct notifier_block hdmitx_notifier_nb_v = {
+    .notifier_call    = hdmitx_notify_callback_v,
+};
+
+#ifdef CONFIG_AM_TV_OUTPUT2
+static struct notifier_block hdmitx_notifier_nb_v2 = {
+    .notifier_call    = hdmitx_notify_callback_v2,
+};
+#endif
+
+// Refer to CEA-861-D Page 88
+#define AOUT_EVENT_REFER_TO_STREAM_HEADER       0x0
+#define AOUT_EVENT_IEC_60958_PCM                0x1
+#define AOUT_EVENT_RAWDATA_AC_3                 0x2
+#define AOUT_EVENT_RAWDATA_MPEG1                0x3
+#define AOUT_EVENT_RAWDATA_MP3                  0x4
+#define AOUT_EVENT_RAWDATA_MPEG2                0x5
+#define AOUT_EVENT_RAWDATA_AAC                  0x6
+#define AOUT_EVENT_RAWDATA_DTS                  0x7
+#define AOUT_EVENT_RAWDATA_ATRAC                0x8
+#define AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO        0x9
+#define AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS   0xA
+#define AOUT_EVENT_RAWDATA_DTS_HD               0xB
+#define AOUT_EVENT_RAWDATA_MAT_MLP              0xC
+#define AOUT_EVENT_RAWDATA_DST                  0xD
+#define AOUT_EVENT_RAWDATA_WMA_PRO              0xE
+#include <linux/soundcard.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+
+static struct rate_map_fs map_fs[] = {
+    {0,      FS_REFER_TO_STREAM},
+    {32000,  FS_32K},
+    {44100,  FS_44K1},
+    {48000,  FS_48K},
+    {88200,  FS_88K2},
+    {96000,  FS_96K},
+    {176400, FS_176K4},
+    {192000, FS_192K},
+};
+
+static audio_fs_t aud_samp_rate_map(unsigned int rate)
+{
+    int i = 0;
+
+    for(i = 0; i < ARRAY_SIZE(map_fs); i++) {
+        if(map_fs[i].rate == rate) {
+            hdmi_print(IMP, AUD "aout notify rate %d\n", rate);
+            return map_fs[i].fs;
+        }
+    }
+    hdmi_print(IMP, AUD "get FS_MAX\n");
+    return FS_MAX;
+}
+
+static unsigned char *aud_type_string[] = {
+    "CT_REFER_TO_STREAM",
+    "CT_PCM",
+    "CT_AC_3",
+    "CT_MPEG1",
+    "CT_MP3",
+    "CT_MPEG2",
+    "CT_AAC",
+    "CT_DTS",
+    "CT_ATRAC",
+    "CT_ONE_BIT_AUDIO",
+    "CT_DOLBY_D",
+    "CT_DTS_HD",
+    "CT_MAT",
+    "CT_DST",
+    "CT_WMA",
+    "CT_MAX",
+};
+
+static struct size_map_ss aud_size_map_ss[] = {
+    {0,     SS_REFER_TO_STREAM},
+    {16,    SS_16BITS},
+    {20,    SS_20BITS},
+    {24,    SS_24BITS},
+    {32,    SS_MAX},
+};
+
+static audio_sample_size_t aud_size_map(unsigned int bits)
+{
+    int i;
+
+    for(i = 0; i < ARRAY_SIZE(aud_size_map_ss); i ++) {
+        if(bits == aud_size_map_ss[i].sample_bits) {
+            hdmi_print(IMP, AUD "aout notify size %d\n", bits);
+            return aud_size_map_ss[i].ss;
+        }
+    }
+    hdmi_print(IMP, AUD "get SS_MAX\n");
+    return SS_MAX;
+}
+
+extern int aout_register_client(struct notifier_block * ) ;
+extern int aout_unregister_client(struct notifier_block * ) ;
+static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long cmd , void *para);
+struct notifier_block hdmitx_notifier_nb_a = {
+    .notifier_call    = hdmitx_notify_callback_a,
+};
+static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long cmd , void *para)
+{
+    int i, audio_check = 0;
+    rx_cap_t* pRXCap = &(hdmitx_device.RXCap);
+    struct snd_pcm_substream *substream =(struct snd_pcm_substream*)para;
+    Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
+    audio_fs_t n_rate = aud_samp_rate_map(substream->runtime->rate);
+    audio_sample_size_t n_size = aud_size_map(substream->runtime->sample_bits);
+
+    hdmitx_device.audio_param_update_flag = 1;
+    hdmitx_device.audio_notify_flag = 0;
+
+    if(audio_param->sample_rate != n_rate) {
+        audio_param->sample_rate = n_rate;
+        hdmitx_device.audio_param_update_flag = 1;
+    }
+
+    if(audio_param->type != cmd) {
+        audio_param->type = cmd;
+        hdmi_print(INF, AUD "aout notify format %s\n", aud_type_string[audio_param->type]);
+        hdmitx_device.audio_param_update_flag = 1;
+    }
+
+    if(audio_param->sample_size != n_size) {
+        audio_param->sample_size = n_size;
+        hdmitx_device.audio_param_update_flag = 1;
+    }
+
+    if(audio_param->channel_num != (substream->runtime->channels - 1)) {
+        audio_param->channel_num = substream->runtime->channels - 1;
+        hdmitx_device.audio_param_update_flag = 1;
+    }
+    if(hdmitx_device.tx_aud_cfg == 2) {
+        hdmi_print(INF, AUD "auto mode\n");
+        // Detect whether Rx is support current audio format
+        for(i = 0; i < pRXCap->AUD_count; i++){
+            if(pRXCap->RxAudioCap[i].audio_format_code == cmd)
+            audio_check = 1;
+        }
+        if((!audio_check) && (cmd != AOUT_EVENT_IEC_60958_PCM)) {      // sink don't support current audio mode
+            printk("Sink not support this audio format %lu\n", cmd);
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+            hdmitx_device.audio_param_update_flag = 0;
+        }
+    }
+    if(hdmitx_device.audio_param_update_flag == 0)
+        hdmi_print(INF, AUD "no update\n");
+    else
+        hdmitx_device.audio_notify_flag = 1;
+
+
+    if((!hdmi_audio_off_flag)&&(hdmitx_device.audio_param_update_flag)) {
+        if(hdmitx_device.hpd_state == 1) {     // plug-in & update audio param
+            hdmitx_set_audio(&hdmitx_device, &(hdmitx_device.cur_audio_param), hdmi_ch);
+	    if((hdmitx_device.audio_notify_flag == 1) || (hdmitx_device.audio_step == 1)) {
+                hdmitx_device.audio_notify_flag = 0;
+                hdmitx_device.audio_step = 0;
+#ifndef CONFIG_AML_HDMI_TX_HDCP
+                hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
+#endif
+            }
+            hdmitx_device.audio_param_update_flag = 0;
+            hdmi_print(INF, AUD "set audio param\n");
+        }
+    }
+
+
+    return 0;
+}
+
+static DEFINE_MUTEX(setclk_mutex);
+void hdmitx_hpd_plugin_handler(struct work_struct *work)
+{
+    hdmitx_dev_t *hdev = container_of((struct delayed_work *)work, struct hdmi_tx_dev_s, work_hpd_plugin);
+
+    if(!(hdev->hdmitx_event & (HDMI_TX_HPD_PLUGIN)))
+        return;
+    printk("TODO plugin\n");
+    mutex_lock(&setclk_mutex);
+    // start reading E-EDID
+    hdev->hpd_state = 1;
+    hdmitx_edid_ram_buffer_clear(hdev);
+    hdev->HWOp.CntlDDC(hdev, DDC_RESET_EDID, 0);
+    hdev->HWOp.CntlDDC(hdev, DDC_PIN_MUX_OP, PIN_MUX);
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_READ_DATA, 0);      // start reading edid frist time
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_GET_DATA, 0);
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_READ_DATA, 0);      // start reading edid second time
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_GET_DATA, 1);
+    // compare EDID_buf & EDID_buf1
+    hdmitx_edid_buf_compare_print(hdev);
+    hdmitx_edid_clear(hdev);
+    hdmitx_edid_parse(hdev);
+
+    set_disp_mode_auto();
+    hdmitx_set_audio(hdev, &(hdev->cur_audio_param), hdmi_ch);
+//    switch_set_state(&sdev, 1);
+    cec_node_init(hdev);
+
+    hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGIN;
+    mutex_unlock(&setclk_mutex);
+}
+
+void hdmitx_hpd_plugout_handler(struct work_struct *work)
+{
+    hdmitx_dev_t *hdev = container_of((struct delayed_work *)work, struct hdmi_tx_dev_s, work_hpd_plugout);
+
+    if(!(hdev->hdmitx_event & (HDMI_TX_HPD_PLUGOUT)))
+        return;
+    mutex_lock(&setclk_mutex);
+    hdev->hpd_state = 0;
+    printk("TODO plugout\n");
+    hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGOUT;
+    mutex_unlock(&setclk_mutex);
+}
+
+void hdmitx_internal_intr_handler(struct work_struct *work)
+{
+    hdmitx_dev_t *hdev = container_of((struct work_struct *)work, struct hdmi_tx_dev_s, work_internal_intr);
+
+    hdev->HWOp.DebugFun(hdev, "dumpintr");
+}
+
+/******************************
+*  hdmitx kernel task
+*******************************/
+
+static int hdmi_task_handle(void *data)
+{
+    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)data;
+
+    sdev.state = !!(hdmitx_device->HWOp.CntlMisc(hdmitx_device, MISC_HPD_GPI_ST, 0));
+    hdmitx_device->hpd_state = sdev.state;
+
+    //When init hdmi, clear the hdmitx module edid ram and edid buffer.
+    hdmitx_edid_ram_buffer_clear(hdmitx_device);
+
+    hdmitx_device->hdmi_wq = alloc_workqueue(DEVICE_NAME, WQ_HIGHPRI | WQ_CPU_INTENSIVE, 0);
+    INIT_DELAYED_WORK(&hdmitx_device->work_hpd_plugin, hdmitx_hpd_plugin_handler);
+    INIT_DELAYED_WORK(&hdmitx_device->work_hpd_plugout, hdmitx_hpd_plugout_handler);
+    INIT_WORK(&hdmitx_device->work_internal_intr, hdmitx_internal_intr_handler);
+
+    hdmitx_device->tx_aud_cfg = 1; // default audio configure is on
+
+    hdmitx_device->HWOp.SetupIRQ(hdmitx_device);
+    if(init_flag&INIT_FLAG_POWERDOWN){
+        hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL); //power down
+        hdmitx_device->unplug_powerdown=1;
+        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);
+    }
+    else{
+        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD, 0);
+    }
+    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_IP_INTR_MASN_RST, 0);
+    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD_IF_PIN_HIGH, 0);
+    return 0;
+}
+
+/* Linux */
+/*****************************
+*    hdmitx driver file_operations
+*
+******************************/
+static int amhdmitx_open(struct inode *node, struct file *file)
+{
+    hdmitx_dev_t *hdmitx_in_devp;
+
+    /* Get the per-device structure that contains this cdev */
+    hdmitx_in_devp = container_of(node->i_cdev, hdmitx_dev_t, cdev);
+    file->private_data = hdmitx_in_devp;
+
+    return 0;
+
+}
+
+
+static int amhdmitx_release(struct inode *node, struct file *file)
+{
+    //hdmitx_dev_t *hdmitx_in_devp = file->private_data;
+
+    /* Reset file pointer */
+
+    /* Release some other fields */
+    /* ... */
+    return 0;
+}
+
+
+#if 0
+static int amhdmitx_ioctl(struct inode *node, struct file *file, unsigned int cmd,   unsigned long args)
+{
+    int   r = 0;
+    switch (cmd) {
+        default:
+            break;
+    }
+    return r;
+}
+#endif
+const static struct file_operations amhdmitx_fops = {
+    .owner    = THIS_MODULE,
+    .open     = amhdmitx_open,
+    .release  = amhdmitx_release,
+//    .ioctl    = amhdmitx_ioctl,
+};
+
+hdmitx_dev_t * get_hdmitx_device(void)
+{
+    return &hdmitx_device;
+}
+EXPORT_SYMBOL(get_hdmitx_device);
+
+static int get_dt_vend_init_data(struct device_node *np, struct vendor_info_data *vend)
+{
+    int ret;
+
+    ret = of_property_read_string(np, "vendor_name", (const char **)&(vend->vendor_name));
+    if(ret) {
+        hdmi_print(INF, SYS "not find vendor name\n");
+        return 1;
+    }
+
+    ret = of_property_read_u32(np, "vendor_id", &(vend->vendor_id));
+    if(ret) {
+        hdmi_print(INF, SYS "not find vendor id\n");
+        return 1;
+    }
+
+    ret = of_property_read_string(np, "product_desc", (const char **)&(vend->product_desc));
+    if(ret) {
+        hdmi_print(INF, SYS "not find product desc\n");
+        return 1;
+    }
+
+    ret = of_property_read_string(np, "cec_osd_string", (const char **)&(vend->cec_osd_string));
+    if(ret) {
+        hdmi_print(INF, SYS "not find cec osd string\n");
+        return 1;
+    }
+    return 0;
+}
+
+static int pwr_type_match(struct device_node *np, const char *str, int idx, struct hdmi_pwr_ctl *pwr, char* pwr_col)
+{
+    int i = 0;
+    int ret = 0;
+    int gpio_val;
+    struct pwr_ctl_var (*var)[HDMI_TX_PWR_CTRL_NUM] = (struct pwr_ctl_var (*)[HDMI_TX_PWR_CTRL_NUM])pwr;
+
+    const static char *pwr_types_id[] = {"none", "cpu", "axp202", NULL};     //match with dts file
+    while(pwr_types_id[i]) {
+        if(strcasecmp(pwr_types_id[i], str) == 0) {
+            ret = 1;
+            break;
+        }
+        i ++;
+    }
+    switch(i) {
+    case CPU_GPO:
+        var[idx]->type = CPU_GPO;
+        ret = of_property_read_string_index(np, pwr_col, 1, &str);
+        if(!ret) {
+            gpio_val = amlogic_gpio_name_map_num(str);
+            ret = amlogic_gpio_request(gpio_val, DEVICE_NAME);
+            if (!ret) {
+                var[idx]->var.gpo.pin = gpio_val;
+                ret = of_property_read_string_index(np, pwr_col, 2, &str);
+                if(!ret) {
+                    var[idx]->var.gpo.val = (strcmp(str, "H") == 0);
+                }
+            }
+        }
+        break;
+    case AXP202:
+        var[idx]->type = AXP202;
+// TODO later
+        break;
+    default:
+        var[idx]->type = NONE;
+    };
+    return ret;
+}
+
+static int get_dt_pwr_init_data(struct device_node *np, struct hdmi_pwr_ctl *pwr)
+{
+    int ret = 0;
+    int idx = 0;
+    const char *str = NULL;
+    char *hdmi_pwr_string[] = {"pwr_5v_on", "pwr_5v_off", "pwr_3v3_on", "pwr_3v3_off", "pwr_hpll_vdd_on", "pwr_hpll_vdd_off", NULL};    //match with dts file
+
+    while(hdmi_pwr_string[idx]) {
+        ret = of_property_read_string_index(np, hdmi_pwr_string[idx], 0, &str);
+        if(!ret) {
+            pwr_type_match(np, str, idx, pwr, hdmi_pwr_string[idx]);
+        }
+        idx++;
+    }
+
+    if(np != NULL) {
+	    ret = of_property_read_u32(np,"pwr_level",&pwr->pwr_level);
+    }
+#if 0
+    struct pwr_ctl_var (*var)[HDMI_TX_PWR_CTRL_NUM] = (struct pwr_ctl_var (*)[HDMI_TX_PWR_CTRL_NUM])pwr;
+    for(idx = 0; idx < HDMI_TX_PWR_CTRL_NUM; idx++) {
+        hdmi_print(INF, SYS "%d %d %d\n", var[idx]->type, var[idx]->var.gpo.pin, var[idx]->var.gpo.val);
+        return 1;
+    }
+#endif
+    return 0;
+}
+
+static void hdmitx_pwr_init(struct hdmi_pwr_ctl *ctl)
+{
+    if(ctl) {
+        if(ctl->pwr_5v_on.type == CPU_GPO) {
+            amlogic_gpio_direction_output(ctl->pwr_5v_on.var.gpo.pin, ctl->pwr_5v_on.var.gpo.val, DEVICE_NAME);
+        }
+        if(ctl->pwr_3v3_on.type == CPU_GPO) {
+            amlogic_gpio_direction_output(ctl->pwr_3v3_on.var.gpo.pin, ctl->pwr_3v3_on.var.gpo.val, DEVICE_NAME);
+        }
+        if(ctl->pwr_hpll_vdd_on.type == CPU_GPO) {
+            amlogic_gpio_direction_output(ctl->pwr_hpll_vdd_on.var.gpo.pin, ctl->pwr_hpll_vdd_on.var.gpo.val, DEVICE_NAME);
+        }
+    }
+}
+
+static int amhdmitx_probe(struct platform_device *pdev)
+{
+    extern struct switch_dev lang_dev;
+    int r,ret=0;
+
+#ifdef CONFIG_USE_OF
+    int psize, val;
+    phandle phandle;
+    struct device_node *init_data;
+#endif
+
+    hdmi_print(IMP, SYS "amhdmitx_probe\n");
+
+    r = alloc_chrdev_region(&hdmitx_id, 0, HDMI_TX_COUNT, DEVICE_NAME);
+    if (r < 0) {
+        hdmi_print(INF, SYS "Can't register major for amhdmitx device\n");
+        return r;
+    }
+
+    hdmitx_class = class_create(THIS_MODULE, DEVICE_NAME);
+    if (IS_ERR(hdmitx_class))
+    {
+        unregister_chrdev_region(hdmitx_id, HDMI_TX_COUNT);
+        return -1;
+        //return PTR_ERR(aoe_class);
+    }
+
+    hdmitx_device.unplug_powerdown=0;
+    hdmitx_device.vic_count=0;
+    hdmitx_device.auth_process_timer=0;
+    hdmitx_device.force_audio_flag=0;
+    hdmitx_device.tv_cec_support=0;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    register_early_suspend(&hdmitx_early_suspend_handler);
+#endif
+
+    if((init_flag&INIT_FLAG_POWERDOWN)&&(hpdmode==2)){
+        hdmitx_device.mux_hpd_if_pin_high_flag=0;
+    }
+    else{
+        hdmitx_device.mux_hpd_if_pin_high_flag=1;
+    }
+    hdmitx_device.audio_param_update_flag=0;
+    cdev_init(&(hdmitx_device.cdev), &amhdmitx_fops);
+    hdmitx_device.cdev.owner = THIS_MODULE;
+    cdev_add(&(hdmitx_device.cdev), hdmitx_id, HDMI_TX_COUNT);
+
+    //hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, "amhdmitx%d", 0);
+    hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, NULL, "amhdmitx%d", 0); //kernel>=2.6.27
+
+    ret=device_create_file(hdmitx_dev, &dev_attr_disp_mode);
+    ret=device_create_file(hdmitx_dev, &dev_attr_aud_mode);
+    ret=device_create_file(hdmitx_dev, &dev_attr_edid);
+    ret=device_create_file(hdmitx_dev, &dev_attr_config);
+    ret=device_create_file(hdmitx_dev, &dev_attr_debug);
+    ret=device_create_file(hdmitx_dev, &dev_attr_disp_cap);
+    ret=device_create_file(hdmitx_dev, &dev_attr_disp_cap_3d);
+    ret=device_create_file(hdmitx_dev, &dev_attr_aud_cap);
+    ret=device_create_file(hdmitx_dev, &dev_attr_aud_ch);
+    ret=device_create_file(hdmitx_dev, &dev_attr_hdcp_ksv_info);
+    ret=device_create_file(hdmitx_dev, &dev_attr_hpd_state);
+    ret=device_create_file(hdmitx_dev, &dev_attr_support_3d);
+    ret=device_create_file(hdmitx_dev, &dev_attr_cec);
+    ret=device_create_file(hdmitx_dev, &dev_attr_cec_config);
+    ret=device_create_file(hdmitx_dev, &dev_attr_cec_lang_config);
+
+    if (hdmitx_dev == NULL) {
+        hdmi_print(ERR, SYS "device_create create error\n");
+        class_destroy(hdmitx_class);
+        r = -EEXIST;
+        return r;
+    }
+    vout_register_client(&hdmitx_notifier_nb_v);
+#ifdef CONFIG_AM_TV_OUTPUT2
+    vout2_register_client(&hdmitx_notifier_nb_v2);
+#endif
+//    aout_register_client(&hdmitx_notifier_nb_a);
+
+#ifdef CONFIG_USE_OF
+    if(pdev->dev.of_node){
+        memset(&hdmitx_device.config_data, 0, sizeof(struct hdmi_config_platform_data));
+// Get physical setting data
+        ret = of_property_read_u32(pdev->dev.of_node, "phy-size", &psize);
+        if(!ret) {
+            hdmitx_device.config_data.phy_data = kzalloc(sizeof(struct hdmi_phy_set_data)*psize, GFP_KERNEL);
+            if(!hdmitx_device.config_data.phy_data) {
+                hdmi_print(INF, SYS "can not get phy_data mem\n");
+            }
+            else {
+                ret = of_property_read_u32_array(pdev->dev.of_node, "phy-data", (unsigned int *)(hdmitx_device.config_data.phy_data), (sizeof(struct hdmi_phy_set_data))*psize/sizeof(struct hdmi_phy_set_data*));
+                if(ret){
+                    hdmi_print(INF, SYS "not find match psize\n");
+                }
+            }
+        }
+// Get vendor information
+        ret = of_property_read_u32(pdev->dev.of_node,"vend-data",&val);
+        if(ret) {
+            hdmi_print(INF, SYS "not find match init-data\n");
+        }
+        if(ret == 0) {
+            phandle = val;
+            init_data = of_find_node_by_phandle(phandle);
+            if(!init_data) {
+                hdmi_print(INF, SYS "not find device node\n");
+            }
+            hdmitx_device.config_data.vend_data = kzalloc(sizeof(struct vendor_info_data), GFP_KERNEL);
+            if(!hdmitx_device.config_data.vend_data) {
+                hdmi_print(INF, SYS "can not get vend_data mem\n");
+            }
+            ret = get_dt_vend_init_data(init_data, hdmitx_device.config_data.vend_data);
+            if(ret) {
+                hdmi_print(INF, SYS "not find vend_init_data\n");
+            }
+        }
+// Get power control
+        ret = of_property_read_u32(pdev->dev.of_node,"pwr-ctrl", &val);
+        if(ret) {
+            hdmi_print(INF, SYS "not find match pwr-ctl\n");
+        }
+        if(ret == 0) {
+            phandle = val;
+            init_data = of_find_node_by_phandle(phandle);
+            if(!init_data) {
+                hdmi_print(INF, SYS "not find device node\n");
+            }
+            hdmitx_device.config_data.pwr_ctl = kzalloc((sizeof(struct hdmi_pwr_ctl)) * HDMI_TX_PWR_CTRL_NUM, GFP_KERNEL);
+            if(!hdmitx_device.config_data.pwr_ctl) {
+                hdmi_print(INF, SYS "can not get pwr_ctl mem\n");
+            }
+            memset(hdmitx_device.config_data.pwr_ctl, 0, sizeof(struct hdmi_pwr_ctl));
+            ret = get_dt_pwr_init_data(init_data, hdmitx_device.config_data.pwr_ctl);
+            if(ret) {
+                hdmi_print(INF, SYS "not find pwr_ctl\n");
+            }
+        }
+    }
+// open hdmi power
+    hdmitx_pwr_init(hdmitx_device.config_data.pwr_ctl);
+
+#else
+    hdmi_pdata = pdev->dev.platform_data;
+    if (!hdmi_pdata) {
+        hdmi_print(INF, SYS "not get platform data\n");
+        r = -ENOENT;
+    }
+    else{
+        hdmi_print(INF, SYS "get hdmi platform data\n");
+    }
+#endif
+    //switch_dev_register(&sdev);
+    switch_dev_register(&lang_dev);
+
+    hdmitx_init_parameters(&hdmitx_device.hdmi_info);
+    HDMITX_Meson_Init(&hdmitx_device);
+    hdmitx_device.task = kthread_run(hdmi_task_handle, &hdmitx_device, "kthread_hdmi");
+
+    if (r < 0){
+        hdmi_print(INF, SYS "register switch dev failed\n");
+        return r;
+    }
+    return r;
+}
+
+static int amhdmitx_remove(struct platform_device *pdev)
+{
+    switch_dev_unregister(&sdev);
+
+    if(hdmitx_device.HWOp.UnInit){
+        hdmitx_device.HWOp.UnInit(&hdmitx_device);
+    }
+    hdmitx_device.hpd_event = 0xff;
+    kthread_stop(hdmitx_device.task);
+
+    vout_unregister_client(&hdmitx_notifier_nb_v);
+#ifdef CONFIG_AM_TV_OUTPUT2
+    vout2_unregister_client(&hdmitx_notifier_nb_v2);
+#endif
+//    aout_unregister_client(&hdmitx_notifier_nb_a);
+
+    /* Remove the cdev */
+    device_remove_file(hdmitx_dev, &dev_attr_disp_mode);
+    device_remove_file(hdmitx_dev, &dev_attr_aud_mode);
+    device_remove_file(hdmitx_dev, &dev_attr_edid);
+    device_remove_file(hdmitx_dev, &dev_attr_config);
+    device_remove_file(hdmitx_dev, &dev_attr_debug);
+    device_remove_file(hdmitx_dev, &dev_attr_disp_cap);
+    device_remove_file(hdmitx_dev, &dev_attr_disp_cap_3d);
+    device_remove_file(hdmitx_dev, &dev_attr_hpd_state);
+    device_remove_file(hdmitx_dev, &dev_attr_support_3d);
+    device_remove_file(hdmitx_dev, &dev_attr_cec);
+
+    cdev_del(&hdmitx_device.cdev);
+
+    device_destroy(hdmitx_class, hdmitx_id);
+
+    class_destroy(hdmitx_class);
+
+// TODO
+//    kfree(hdmi_pdata->phy_data);
+//    kfree(hdmi_pdata);
+
+    unregister_chrdev_region(hdmitx_id, HDMI_TX_COUNT);
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int amhdmitx_suspend(struct platform_device *pdev,pm_message_t state)
+{
+#if 0
+    pr_info("amhdmitx: hdmirx_suspend\n");
+    hdmitx_pre_display_init();
+    if(hdmi_pdata){
+        hdmi_pdata->hdmi_5v_ctrl ? hdmi_pdata->hdmi_5v_ctrl(0) : 0;
+        hdmi_pdata->hdmi_3v3_ctrl ? hdmi_pdata->hdmi_3v3_ctrl(1) : 0;   // prevent Voff leak current
+    }
+    if(hdmitx_device.HWOp.Cntl)
+        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+#endif
+    return 0;
+}
+
+static int amhdmitx_resume(struct platform_device *pdev)
+{
+#if 0
+    pr_info("amhdmitx: resume module\n");
+    if(hdmi_pdata){
+        hdmi_pdata->hdmi_5v_ctrl ? hdmi_pdata->hdmi_5v_ctrl(1) : 0;
+    }
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    hdmitx_device.internal_mode_change = 0;
+    set_disp_mode_auto();
+    pr_info("amhdmitx: resume module %d\n", __LINE__);
+#endif
+    return 0;
+}
+#endif
+
+#ifdef CONFIG_OF
+static const struct of_device_id meson_amhdmitx_dt_match[]={
+    {
+        .compatible     = "amlogic,amhdmitx",
+    },
+    {},
+};
+#else
+#define meson_amhdmitx_dt_match NULL
+#endif
+static struct platform_driver amhdmitx_driver = {
+    .probe      = amhdmitx_probe,
+    .remove     = amhdmitx_remove,
+#ifdef CONFIG_PM
+    .suspend    = amhdmitx_suspend,
+    .resume     = amhdmitx_resume,
+#endif
+    .driver     = {
+        .name   = DEVICE_NAME,
+            .owner    = THIS_MODULE,
+            .of_match_table = meson_amhdmitx_dt_match,
+    }
+};
+
+
+static int  __init amhdmitx_init(void)
+{
+    if(init_flag&INIT_FLAG_NOT_LOAD)
+        return 0;
+
+    hdmi_print(IMP, SYS "amhdmitx_init\n");
+    hdmi_print(IMP, SYS "Ver: %s\n", HDMITX_VER);
+
+    if (platform_driver_register(&amhdmitx_driver)) {
+        hdmi_print(ERR, SYS "failed to register amhdmitx module\n");
+        return -ENODEV;
+    }
+    return 0;
+}
+
+
+
+
+static void __exit amhdmitx_exit(void)
+{
+    hdmi_print(INF, SYS "amhdmitx_exit\n");
+    platform_driver_unregister(&amhdmitx_driver);
+
+    return ;
+}
+
+//module_init(amhdmitx_init);
+arch_initcall(amhdmitx_init);
+module_exit(amhdmitx_exit);
+
+MODULE_DESCRIPTION("AMLOGIC HDMI TX driver 2.0");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.0");
+
+
+static char* next_token_ex(char* seperator, char *buf, unsigned size, unsigned offset, unsigned *token_len, unsigned *token_offset)
+{ /* besides characters defined in seperator, '\"' are used as seperator; and any characters in '\"' will not act as seperator */
+    char *pToken = NULL;
+    char last_seperator = 0;
+    char trans_char_flag = 0;
+    if(buf){
+        for (;offset<size;offset++){
+            int ii=0;
+            char ch;
+            if (buf[offset] == '\\'){
+                trans_char_flag = 1;
+                continue;
+            }
+            while(((ch=seperator[ii++])!=buf[offset])&&(ch)){
+            }
+            if (ch){
+                if (!pToken){
+                    continue;
+                }
+                else {
+                    if (last_seperator != '"'){
+                        *token_len = (unsigned)(buf + offset - pToken);
+                        *token_offset = offset;
+                        return pToken;
+                    }
+                }
+            }
+            else if (!pToken)
+            {
+                if (trans_char_flag&&(buf[offset] == '"'))
+                    last_seperator = buf[offset];
+                pToken = &buf[offset];
+            }
+            else if ((trans_char_flag&&(buf[offset] == '"'))&&(last_seperator == '"')){
+                *token_len = (unsigned)(buf + offset - pToken - 2);
+                *token_offset = offset + 1;
+                return pToken + 1;
+            }
+            trans_char_flag = 0;
+        }
+        if (pToken) {
+            *token_len = (unsigned)(buf + offset - pToken);
+            *token_offset = offset;
+        }
+    }
+    return pToken;
+}
+
+static  int __init hdmitx_boot_para_setup(char *s)
+{
+    char separator[]={' ',',',';',0x0};
+    char *token;
+    unsigned token_len, token_offset, offset=0;
+    int size=strlen(s);
+
+    do{
+        token=next_token_ex(separator, s, size, offset, &token_len, &token_offset);
+        if(token){
+            if((token_len==3) && (strncmp(token, "off", token_len)==0)){
+                init_flag|=INIT_FLAG_NOT_LOAD;
+            }
+            else if((token_len==7) && (strncmp(token, "vdacoff", token_len)==0)){
+                init_flag|=INIT_FLAG_VDACOFF;
+            }
+            else if((token_len==16) && (strncmp(token, "unplug_powerdown", token_len)==0)){
+                init_flag|=INIT_FLAG_POWERDOWN;
+            }
+            else if(strncmp(token, "pllmode1",  8)==0){
+                    /* use external xtal as source of hdmi pll */
+                hdmi_pll_mode = 1;
+            }
+            else if((token_len==7)&& (strncmp(token, "hpdmode", token_len)==0)){
+                hpdmode = simple_strtoul(token+7,NULL,10);
+            }
+            else if((token_len==3)&&(strncmp(token, "rgb", 3)==0)){
+                hdmitx_output_rgb();
+            }
+            else if(strncmp(token, "audpara", 7)==0){
+                int tmp;
+                tmp = simple_strtoul(token+7,NULL,10);
+                hdmi_print(INF, AUD "set hdmi aud_para %d\n", tmp);
+            }
+            else if(strncmp(token, "powermode", 9)==0){
+                int tmp;
+                tmp = simple_strtoul(token+9,NULL,10);
+                init_powermode=tmp|0x80;
+                hdmi_print(INF, SYS "set init powermode %d\n", tmp);
+            }
+            else if(strncmp(token, "audiooff", 8)==0){
+                hdmi_audio_off_flag = 1;
+                hdmi_print(INF, AUD "set no audio output\n");
+            }
+            else if(strncmp(token, "prbs", 4)==0){
+                hdmi_prbs_mode = simple_strtoul(token+4,NULL,16);
+                hdmi_print(INF, SYS "set prbs mode as %x always\n", hdmi_prbs_mode);
+            }
+            else if(strncmp(token, "480p_clk", 8)==0){
+                hdmi_480p_force_clk = simple_strtoul(token+8,NULL,10);
+                hdmi_print(INF, SYS "hdmi, set 480p mode clock as %dMHz always\n", hdmi_480p_force_clk);
+            }
+            else if(strncmp(token, "cec", 3)==0) {
+                unsigned int list = simple_strtoul(token+3,NULL,16);
+                if((list >= 0) && (list <= 0xf)) {
+                    hdmitx_device.cec_func_config = list;
+                    aml_write_reg32(P_AO_DEBUG_REG0, hdmitx_device.cec_func_config);         // save cec function list to AO_REG
+                }
+                hdmi_print(INF, CEC "Function List: %s, %s, %s, %s\n", (hdmitx_device.cec_func_config & (1 << CEC_FUNC_MSAK)) ? "enable" : "disable",
+                                                              (hdmitx_device.cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) ? "one touch play" : "",
+                                                              (hdmitx_device.cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) ? "one touch standby" : "",
+                                                              (hdmitx_device.cec_func_config & (1 << AUTO_POWER_ON_MASK)) ? "auto power by tv" : ""
+                      );
+                hdmi_print(INF, CEC "HDMI aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n",aml_read_reg32(P_AO_DEBUG_REG0));
+                hdmi_print(INF, CEC "HDMI hdmi_cec_func_config:0x%x\n",hdmitx_device.cec_func_config);
+            }
+        }
+        offset=token_offset;
+    }while(token);
+    return 0;
+}
+
+__setup("hdmitx=",hdmitx_boot_para_setup);
+
+#ifdef CONFIG_AM_TV_OUTPUT2
+MODULE_PARM_DESC(force_vout_index, "\n force_vout_index\n");
+module_param(force_vout_index, uint, 0664);
+#endif
+
+MODULE_PARM_DESC(hdmi_480p_force_clk, "\n hdmi_480p_force_clk \n");
+module_param(hdmi_480p_force_clk, int, 0664);
+
+MODULE_PARM_DESC(hdmi_prbs_mode, "\n hdmi_prbs_mode \n");
+module_param(hdmi_prbs_mode, int, 0664);
+
+MODULE_PARM_DESC(debug_level, "\n debug_level \n");
+module_param(debug_level, int, 0664);
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_scdc.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_scdc.c
new file mode 100644
index 000000000000..8242ceed1b78
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_scdc.c
@@ -0,0 +1 @@
+#include <linux/amlogic/hdmi_tx/hdmi_tx_scdc.h>
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_video.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_video.c
new file mode 100644
index 000000000000..de006a7b41f2
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_video.c
@@ -0,0 +1,640 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+
+static unsigned char hdmi_output_rgb = 0;
+static void hdmitx_set_spd_info(hdmitx_dev_t* hdmitx_device);
+static void hdmi_set_vend_spec_infofram(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode);
+
+static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
+{
+    {
+        .VIC            = HDMI_640x480p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480p60_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480p60_16x9_rpt,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_4_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_720p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+#ifdef DOUBLE_CLK_720P_1080I
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+#else
+        .repeat_time    = NO_REPEAT,
+#endif
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080i60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+#ifdef DOUBLE_CLK_720P_1080I
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+#else
+        .repeat_time    = NO_REPEAT,
+#endif
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480i60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480i60_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480i60_16x9_rpt,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_4_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1440x480p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576p50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576p50_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576p50_16x9_rpt,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_4_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_720p50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080i50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576i50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576i50_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576i50_16x9_rpt,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_4_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p24,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p25,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p30,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_4k2k_30,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_4k2k_25,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_4k2k_24,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_4k2k_smpte_24,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_3840x2160p50_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_3840x2160p60_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+};
+
+static Hdmi_tx_video_para_t *hdmi_get_video_param(HDMI_Video_Codes_t VideoCode)
+{
+    Hdmi_tx_video_para_t * video_param=NULL;
+    int  i;
+    int count=ARRAY_SIZE(hdmi_tx_video_params);
+    for(i=0;i<count;i++){
+        if(hdmi_tx_video_params[i].VIC == VideoCode){
+            break;
+        }
+    }
+    if(i<count){
+        video_param = &(hdmi_tx_video_params[i]);
+    }
+    return video_param;
+}
+
+static void hdmi_tx_construct_avi_packet(Hdmi_tx_video_para_t *video_param, char* AVI_DB)
+{
+    unsigned char color, bar_info, aspect_ratio, cc, ss, sc, ec = 0;
+    ss = video_param->ss;
+    bar_info = video_param->bar_info;
+    if(video_param->color == COLOR_SPACE_YUV444){
+        color = 2;
+    }
+    else if(video_param->color == COLOR_SPACE_YUV422){
+        color = 1;
+    }
+    else{ //(video_param->color == COLOR_SPACE_RGB444)
+        color = 0;
+    }
+    AVI_DB[0] = (ss) | (bar_info << 2) | (1<<4) | (color << 5);
+    //AVI_DB[0] = (1<<4) | (color << 5);
+
+    aspect_ratio = video_param->aspect_ratio;
+    cc = video_param->cc;
+//HDMI CT 7-24
+    //AVI_DB[1] = (aspect_ratio) | (aspect_ratio << 4) | (cc << 6);
+    AVI_DB[1] = 8 | (aspect_ratio << 4) | (cc << 6);
+
+    sc = video_param->sc;
+    if(video_param->cc == CC_ITU601)
+        ec = 0;
+    if(video_param->cc == CC_ITU709)
+        ec = 1;    // according to CEA-861-D, all other values are reserved
+    AVI_DB[2] = (sc) | (ec << 4);
+    //AVI_DB[2] = 0;
+
+    AVI_DB[3] = video_param->VIC;
+    if((video_param->VIC == HDMI_4k2k_30) || (video_param->VIC == HDMI_4k2k_25) || (video_param->VIC == HDMI_4k2k_24) || (video_param->VIC == HDMI_4k2k_smpte_24))
+        AVI_DB[3] = 0;      // HDMI Spec V1.4b P151
+
+    AVI_DB[4] = video_param->repeat_time;
+}
+
+/************************************
+*    hdmitx protocol level interface
+*************************************/
+
+void hdmitx_init_parameters(HDMI_TX_INFO_t *info)
+{
+    memset(info, 0, sizeof(HDMI_TX_INFO_t));
+
+    info->video_out_changing_flag = 1;
+
+    info->audio_flag = 1;
+    info->audio_info.type = CT_REFER_TO_STREAM;
+    info->audio_info.format = AF_I2S;
+    info->audio_info.fs = FS_44K1;
+    info->audio_info.ss = SS_16BITS;
+    info->audio_info.channels = CC_2CH;
+    info->audio_info.audio_mclk = MCLK_256_Fs;
+    info->audio_out_changing_flag = 1;
+
+    info->auto_hdcp_ri_flag = 1;     // If == 1, turn on Auto Ri Checking
+    info->hw_sha_calculator_flag = 1;    // If  == 1, use the HW SHA calculator, otherwise, use SW SHA calculator
+
+}
+
+//HDMI Identifier = 0x000c03
+//If not, treated as a DVI Device
+static int is_dvi_device(rx_cap_t* pRXCap)
+{
+    hdmitx_dev_t *hdmitx_device = container_of(pRXCap, struct hdmi_tx_dev_s, RXCap);
+
+#ifndef CONFIG_AML_HDMI_TX_CTS_DVI
+    hdmi_print(IMP, SYS "fixed HDMI mode output\n");
+    return 0;
+#endif
+    if(hdmitx_device->tv_no_edid)
+        return 0;
+
+    if(pRXCap->IEEEOUI != 0x000c03)
+        return 1;
+    else
+        return 0;
+}
+
+void hdmitx_output_rgb(void)
+{
+    hdmi_output_rgb = 1;
+}
+
+int hdmitx_set_display(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode)
+{
+    Hdmi_tx_video_para_t *param;
+    HDMI_Video_Codes_t vic;
+    int i,ret=-1;
+    unsigned char AVI_DB[32];
+    unsigned char AVI_HB[32];
+    AVI_HB[0] = TYPE_AVI_INFOFRAMES ;
+    AVI_HB[1] = AVI_INFOFRAMES_VERSION ;
+    AVI_HB[2] = AVI_INFOFRAMES_LENGTH ;
+    for(i=0;i<32;i++){
+        AVI_DB[i]=0;
+    }
+//TODO
+
+    vic = hdmitx_device->HWOp.GetState(hdmitx_device, STAT_VIDEO_VIC, 0);
+    hdmi_print(IMP, SYS "already init VIC = %d  Now VIC = %d\n", vic, VideoCode);
+    if((vic != HDMI_Unkown) && (vic == VideoCode)) {
+        hdmitx_device->cur_VIC = vic;
+        return 1;;
+    }
+
+    param = hdmi_get_video_param(VideoCode);
+    hdmitx_device->cur_video_param = param;
+    if(param){
+        param->color = param->color_prefer;
+        if(hdmi_output_rgb){
+            param->color = COLOR_SPACE_RGB444;
+        }
+        else{
+//HDMI CT 7-24 Pixel Encoding - YCbCr to YCbCr Sink
+            switch(hdmitx_device->RXCap.native_Mode & 0x30)
+            {
+                case 0x20:    //bit5==1, then support YCBCR444 + RGB
+                case 0x30:
+                    param->color = COLOR_SPACE_YUV444;
+                    break;
+                case 0x10:    //bit4==1, then support YCBCR422 + RGB
+                    param->color = COLOR_SPACE_YUV422;
+                    break;
+                default:
+                    param->color = COLOR_SPACE_RGB444;
+            }
+        }
+        if(hdmitx_device->HWOp.SetDispMode(hdmitx_device, param)>=0){
+//HDMI CT 7-33 DVI Sink, no HDMI VSDB nor any other VSDB, No GB or DI expected
+//TMDS_MODE[hdmi_config]
+//0: DVI Mode       1: HDMI Mode
+            //if(hdmitx_device->hdmi_info.output_state==CABLE_PLUGIN_DVI_OUT)
+            if(is_dvi_device(&hdmitx_device->RXCap)) {
+                hdmi_print(1,"Sink is DVI device\n");
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_HDMI_DVI_MODE, DVI_MODE);        //todo ColorFormat
+            }
+            else {
+                hdmi_print(1,"Sink is HDMI device\n");
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_HDMI_DVI_MODE, HDMI_MODE);
+            }
+//check system status by reading EDID_STATUS
+            switch(hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_SYSTEM_ST, 0))
+            {
+                case 0:
+                    hdmi_print(1,"No sink attached\n");
+                    break;
+                case 1:
+                    hdmi_print(1,"Source reading EDID\n");
+                    break;
+                case 2:
+                    hdmi_print(1,"Source in DVI Mode\n");
+                    break;
+                case 3:
+                    hdmi_print(1,"Source in HDMI Mode\n");
+                    break;
+                default:
+                    hdmi_print(1,"EDID Status error\n");
+            }
+
+            hdmi_tx_construct_avi_packet(param, (char*)AVI_DB);
+
+            if((VideoCode == HDMI_4k2k_30) || (VideoCode == HDMI_4k2k_25) || (VideoCode == HDMI_4k2k_24) || (VideoCode == HDMI_4k2k_smpte_24)) {
+                hdmi_set_vend_spec_infofram(hdmitx_device, VideoCode);
+            }
+            else {
+                hdmi_set_vend_spec_infofram(hdmitx_device, 0);
+            }
+
+            hdmitx_device->HWOp.SetPacket(HDMI_PACKET_AVI, AVI_DB, AVI_HB);
+            ret = 0;
+        }
+    }
+    else{
+        if(hdmitx_device->HWOp.SetDispMode) {
+            hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL); //disable HDMI
+        }
+    }
+    hdmitx_set_spd_info(hdmitx_device);
+    return ret;
+}
+
+static void hdmi_set_vend_spec_infofram(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode)
+{
+    int i;
+    unsigned char VEN_DB[6];
+    unsigned char VEN_HB[3];
+    VEN_HB[0] = 0x81;
+    VEN_HB[1] = 0x01;
+    VEN_HB[2] = 0x6;
+
+    for(i = 0; i < 0x6; i++){
+        VEN_DB[i] = 0;
+    }
+    VEN_DB[0] = 0x03;
+    VEN_DB[1] = 0x0c;
+    VEN_DB[2] = 0x00;
+
+    VEN_DB[3] = 0x20;         // 4k x 2k  Spec P156
+    if(VideoCode == 0) {       // For non-4kx2k mode setting
+        hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, VEN_HB);
+        return ;
+    }
+    if(VideoCode == HDMI_4k2k_30)
+        VEN_DB[4] = 0x1;
+    else if(VideoCode == HDMI_4k2k_25)
+        VEN_DB[4] = 0x2;
+    else if(VideoCode == HDMI_4k2k_24)
+        VEN_DB[4] = 0x3;
+    else if(VideoCode == HDMI_4k2k_smpte_24)
+        VEN_DB[4] = 0x4;
+    else {
+        // nothing
+    }
+    hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
+}
+
+int hdmi_set_3d(hdmitx_dev_t* hdmitx_device, int type, unsigned int param)
+{
+    int i;
+    unsigned char VEN_DB[6];
+    unsigned char VEN_HB[3];
+    VEN_HB[0] = 0x81 ;
+    VEN_HB[1] = 0x01 ;
+    VEN_HB[2] = 0x6 ;
+    if(type==0xf){
+        hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, VEN_HB);
+    }
+    else{
+        for(i=0;i<0x6;i++){
+            VEN_DB[i]=0;
+        }
+        VEN_DB[0]=0x03;
+        VEN_DB[1]=0x0c;
+        VEN_DB[2]=0x00;
+
+        VEN_DB[3]=0x40;
+        VEN_DB[4]=type<<4;
+        VEN_DB[5]=param<<4;
+        hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
+    }
+    return 0;
+
+}
+
+// Set Source Product Descriptor InfoFrame
+static void hdmitx_set_spd_info(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned char SPD_DB[25] = {0x00};
+    unsigned char SPD_HB[3] = {0x83, 0x1, 0x19};
+    unsigned int len = 0;
+    struct vendor_info_data *vend_data;
+    if(hdmitx_device->config_data.vend_data) {
+        vend_data = hdmitx_device->config_data.vend_data;
+    }
+    else {
+        hdmi_print(INF, SYS "packet: can\'t get vendor data\n");
+        return;
+    }
+    if(vend_data->vendor_name) {
+        len = strlen(vend_data->vendor_name);
+        strncpy(&SPD_DB[0], vend_data->vendor_name, (len > 8) ? 8 : len);
+    }
+    if(vend_data->product_desc) {
+        len = strlen(vend_data->product_desc);
+        strncpy(&SPD_DB[8], vend_data->product_desc, (len > 16) ? 16 : len);
+    }
+    hdmitx_device->HWOp.SetPacket(HDMI_SOURCE_DESCRIPTION, SPD_DB, SPD_HB);
+}
+
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_common.h b/include/linux/amlogic/hdmi_tx/hdmi_common.h
new file mode 100644
index 000000000000..700f9a65f5a5
--- /dev/null
+++ b/include/linux/amlogic/hdmi_tx/hdmi_common.h
@@ -0,0 +1,427 @@
+#ifndef __HDMI_COMMON_H__
+#define __HDMI_COMMON_H__
+
+// HDMI VIC definitions
+typedef enum HDMI_Video_Type_ {
+// Refer to CEA 861-D
+    HDMI_Unkown = 0,
+    HDMI_640x480p60_4x3 = 1,
+    HDMI_720x480p60_4x3 = 2,
+    HDMI_720x480p60_16x9 = 3,
+    HDMI_1280x720p60_16x9 = 4,
+    HDMI_1920x1080i60_16x9 = 5,
+    HDMI_720x480i60_4x3 = 6,
+    HDMI_720x480i60_16x9 = 7,
+    HDMI_720x240p60_4x3 = 8,
+    HDMI_720x240p60_16x9 = 9,
+    HDMI_2880x480i60_4x3 = 10,
+    HDMI_2880x480i60_16x9 = 11,
+    HDMI_2880x240p60_4x3 = 12,
+    HDMI_2880x240p60_16x9 = 13,
+    HDMI_1440x480p60_4x3 = 14,
+    HDMI_1440x480p60_16x9 = 15,
+    HDMI_1920x1080p60_16x9 = 16,
+    HDMI_720x576p50_4x3 = 17,
+    HDMI_720x576p50_16x9 = 18,
+    HDMI_1280x720p50_16x9 = 19,
+    HDMI_1920x1080i50_16x9 = 20,
+    HDMI_720x576i50_4x3 = 21,
+    HDMI_720x576i50_16x9 = 22,
+    HDMI_720x288p_4x3 = 23,
+    HDMI_720x288p_16x9 = 24,
+    HDMI_2880x576i50_4x3 = 25,
+    HDMI_2880x576i50_16x9 = 26,
+    HDMI_2880x288p50_4x3 = 27,
+    HDMI_2880x288p50_16x9 = 28,
+    HDMI_1440x576p_4x3 = 29,
+    HDMI_1440x576p_16x9 = 30,
+    HDMI_1920x1080p50_16x9 = 31,
+    HDMI_1920x1080p24_16x9 = 32,
+    HDMI_1920x1080p25_16x9 = 33,
+    HDMI_1920x1080p30_16x9 = 34,
+    HDMI_2880x480p60_4x3 = 35,
+    HDMI_2880x480p60_16x9 = 36,
+    HDMI_2880x576p50_4x3 = 37,
+    HDMI_2880x576p50_16x9 = 38,
+    HDMI_1920x1080i_t1250_50_16x9 = 39,
+    HDMI_1920x1080i100_16x9 = 40,
+    HDMI_1280x720p100_16x9 = 41,
+    HDMI_720x576p100_4x3 = 42,
+    HDMI_720x576p100_16x9 = 43,
+    HDMI_720x576i100_4x3 = 44,
+    HDMI_720x576i100_16x9 = 45,
+    HDMI_1920x1080i120_16x9 = 46,
+    HDMI_1280x720p120_16x9 = 47,
+    HDMI_720x480p120_4x3 = 48,
+    HDMI_720x480p120_16x9 = 49,
+    HDMI_720X480i120_4x3 = 50,
+    HDMI_720X480i120_16x9 = 51,
+    HDMI_720x576p200_4x3 = 52,
+    HDMI_720x576p200_16x9 = 53,
+    HDMI_720x576i200_4x3 = 54,
+    HDMI_720x576i200_16x9 = 55,
+    HDMI_720x480p240_4x3 = 56,
+    HDMI_720x480p240_16x9 = 57,
+    HDMI_720x480i240_4x3 = 58,
+    HDMI_720x480i240_16x9 = 59,
+// Refet to CEA 861-F
+    HDMI_1280x720p24_16x9 = 60,
+    HDMI_1280x720p25_16x9 = 61,
+    HDMI_1280x720p30_16x9 = 62,
+    HDMI_1920x1080p120_16x9 = 63,
+    HDMI_1920x1080p100_16x9 = 64,
+    HDMI_1280x720p24_64x27 = 65,
+    HDMI_1280x720p25_64x27 = 66,
+    HDMI_1280x720p30_64x27 = 67,
+    HDMI_1280x720p50_64x27 = 68,
+    HDMI_1280x720p60_64x27 = 69,
+    HDMI_1280x720p100_64x27 = 70,
+    HDMI_1280x720p120_64x27 = 71,
+    HDMI_1920x1080p24_64x27 = 72,
+    HDMI_1920x1080p25_64x27 = 73,
+    HDMI_1920x1080p30_64x27 = 74,
+    HDMI_1920x1080p50_64x27 = 75,
+    HDMI_1920x1080p60_64x27 = 76,
+    HDMI_1920x1080p100_64x27 = 77,
+    HDMI_1920x1080p120_64x27 = 78,
+    HDMI_1680x720p24_64x27 = 79,
+    HDMI_1680x720p25_64x27 = 80,
+    HDMI_1680x720p30_64x27 = 81,
+    HDMI_1680x720p50_64x27 = 82,
+    HDMI_1680x720p60_64x27 = 83,
+    HDMI_1680x720p100_64x27 = 84,
+    HDMI_1680x720p120_64x27 = 85,
+    HDMI_2560x1080p24_64x27 = 86,
+    HDMI_2560x1080p25_64x27 = 87,
+    HDMI_2560x1080p30_64x27 = 88,
+    HDMI_2560x1080p50_64x27 = 89,
+    HDMI_2560x1080p60_64x27 = 90,
+    HDMI_2560x1080p100_64x27 = 91,
+    HDMI_2560x1080p120_64x27 = 92,
+    HDMI_3840x2160p24_16x9 = 93,
+    HDMI_3840x2160p25_16x9 = 94,
+    HDMI_3840x2160p30_16x9 = 95,
+    HDMI_3840x2160p50_16x9 = 96,
+    HDMI_3840x2160p60_16x9 = 97,
+    HDMI_4096x2160p24_256x135 = 98,
+    HDMI_4096x2160p25_256x135 = 99,
+    HDMI_4096x2160p30_256x135 = 100,
+    HDMI_4096x2160p50_256x135 = 101,
+    HDMI_4096x2160p60_256x135 = 102,
+    HDMI_3840x2160p24_64x27 = 103,
+    HDMI_3840x2160p25_64x27 = 104,
+    HDMI_3840x2160p30_64x27 = 105,
+    HDMI_3840x2160p50_64x27 = 106,
+    HDMI_3840x2160p60_64x27 = 107,
+    HDMI_RESERVED = 108,
+} HDMI_Video_Codes_t;
+
+// Compliance with old definitions
+#define HDMI_640x480p60         HDMI_640x480p60_4x3
+#define HDMI_480p60             HDMI_720x480p60_4x3
+#define HDMI_480p60_16x9        HDMI_720x480p60_16x9
+#define HDMI_720p60             HDMI_1280x720p60_16x9
+#define HDMI_1080i60            HDMI_1920x1080i60_16x9
+#define HDMI_480i60             HDMI_720x480i60_4x3
+#define HDMI_480i60_16x9        HDMI_720x480i60_16x9
+#define HDMI_480i60_16x9_rpt    HDMI_2880x480i60_16x9
+#define HDMI_1440x480p60        HDMI_1440x480p60_4x3
+#define HDMI_1440x480p60_16x9   HDMI_1440x480p60_16x9
+#define HDMI_1080p60            HDMI_1920x1080p60_16x9
+#define HDMI_576p50             HDMI_720x576p50_4x3
+#define HDMI_576p50_16x9        HDMI_720x576p50_16x9
+#define HDMI_720p50             HDMI_1280x720p50_16x9
+#define HDMI_1080i50            HDMI_1920x1080i50_16x9
+#define HDMI_576i50             HDMI_720x576i50_4x3
+#define HDMI_576i50_16x9        HDMI_720x576i50_16x9
+#define HDMI_576i50_16x9_rpt    HDMI_2880x576i50_16x9
+#define HDMI_1080p50            HDMI_1920x1080p50_16x9
+#define HDMI_1080p24            HDMI_1920x1080p24_16x9
+#define HDMI_1080p25            HDMI_1920x1080p25_16x9
+#define HDMI_1080p30            HDMI_1920x1080p30_16x9
+#define HDMI_480p60_16x9_rpt    HDMI_2880x480p60_16x9
+#define HDMI_576p50_16x9_rpt    HDMI_2880x576p50_16x9
+#define HDMI_4k2k_24            HDMI_3840x2160p24_16x9
+#define HDMI_4k2k_25            HDMI_3840x2160p25_16x9
+#define HDMI_4k2k_30            HDMI_3840x2160p30_16x9
+#define HDMI_4k2k_50            HDMI_3840x2160p50_16x9
+#define HDMI_4k2k_60            HDMI_3840x2160p60_16x9
+#define HDMI_4k2k_smpte_24      HDMI_4096x2160p24_256x135
+#define HDMI_4k2k_smpte_50      HDMI_4096x2160p50_256x135
+#define HDMI_4k2k_smpte_60      HDMI_4096x2160p60_256x135
+
+// CEA TIMING STRUCT DEFINITION
+struct hdmi_cea_timing {
+    unsigned int pixel_freq;            // Unit: 1000
+    unsigned int h_freq;              // Unit: Hz
+    unsigned int v_freq;              // Unit: 0.001 Hz
+    unsigned int vsync_polarity : 1;    // 1: positive  0: negative
+    unsigned int hsync_polarity : 1;
+    unsigned short h_active;
+    unsigned short h_total;
+    unsigned short h_blank;
+    unsigned short h_front;
+    unsigned short h_sync;
+    unsigned short h_back;
+    unsigned short v_active;
+    unsigned short v_total;
+    unsigned short v_blank;
+    unsigned short v_front;
+    unsigned short v_sync;
+    unsigned short v_back;
+    unsigned short v_sync_ln;
+};
+
+// get hdmi cea timing
+// t: struct hdmi_cea_timing *
+#define GET_TIMING(name)      (t->name)
+
+struct hdmi_format_para {
+    HDMI_Video_Codes_t vic;
+    unsigned char * name;
+    unsigned int pixel_repetition_factor;
+    unsigned int progress_mode : 1;         // 0: Interlace mode  1: Progressive Mode
+    unsigned int scrambler_en : 1;
+    unsigned int tmds_clk_div40 : 1;
+    unsigned int tmds_clk;            // Unit: 1000
+    struct hdmi_cea_timing timing;
+};
+
+// HDMI Packet Type Definitions
+#define PT_NULL_PKT                 0x00
+#define PT_AUD_CLK_REGENERATION     0x01
+#define PT_AUD_SAMPLE               0x02
+#define PT_GENERAL_CONTROL          0x03
+#define PT_ACP                      0x04
+#define PT_ISRC1                    0x05
+#define PT_ISRC2                    0x06
+#define PT_ONE_BIT_AUD_SAMPLE       0x07
+#define PT_DST_AUD                  0x08
+#define PT_HBR_AUD_STREAM           0x09
+#define PT_GAMUT_METADATA           0x0A
+#define PT_3D_AUD_SAMPLE            0x0B
+#define PT_ONE_BIT_3D_AUD_SAMPLE    0x0C
+#define PT_AUD_METADATA             0x0D
+#define PT_MULTI_SREAM_AUD_SAMPLE   0x0E
+#define PT_ONE_BIT_MULTI_SREAM_AUD_SAMPLE   0x0F
+// Infoframe Packet
+#define PT_IF_VENDOR_SEPCIFIC       0x81
+#define PT_IF_AVI                   0x82
+#define PT_IF_SPD                   0x83
+#define PT_IF_AUD                   0x84
+#define PT_IF_MPEG_SOURCE           0x85
+
+// Old definitions
+#define TYPE_AVI_INFOFRAMES       0x82
+#define AVI_INFOFRAMES_VERSION    0x02
+#define AVI_INFOFRAMES_LENGTH     0x0D
+
+typedef enum
+{
+    COLOR_SPACE_RGB444 = 0,
+    COLOR_SPACE_YUV422 = 1,
+    COLOR_SPACE_YUV444 = 2,
+    COLOR_SPACE_YUV420 = 3,
+    COLOR_SPACE_RESERVED,
+}color_space_type_t;
+
+typedef enum
+{
+    ASPECT_RATIO_SAME_AS_SOURCE = 0x8,
+    TV_ASPECT_RATIO_4_3 = 0x9,
+    TV_ASPECT_RATIO_16_9 = 0xA,
+    TV_ASPECT_RATIO_14_9 = 0xB,
+    TV_ASPECT_RATIO_MAX
+} hdmi_aspect_ratio_t;
+
+typedef enum
+{
+    COLOR_24BIT = 0,
+    COLOR_30BIT,
+    COLOR_36BIT,
+    COLOR_48BIT
+} hdmi_color_depth_t;
+
+
+struct hdmi_format_para * hdmi_get_fmt_paras(HDMI_Video_Codes_t vic);
+void check_detail_fmt(void);
+
+
+// HDMI Audio Parmeters
+typedef enum
+{
+    CT_REFER_TO_STREAM = 0,
+    CT_PCM,
+    CT_AC_3,
+    CT_MPEG1,
+    CT_MP3,
+    CT_MPEG2,
+    CT_AAC,
+    CT_DTS,
+    CT_ATRAC,
+    CT_ONE_BIT_AUDIO,
+    CT_DOLBY_D,
+    CT_DTS_HD,
+    CT_MAT,
+    CT_DST,
+    CT_WMA,
+    CT_MAX,
+} audio_type_t;
+
+typedef enum
+{
+    CC_REFER_TO_STREAM = 0,
+    CC_2CH,
+    CC_3CH,
+    CC_4CH,
+    CC_5CH,
+    CC_6CH,
+    CC_7CH,
+    CC_8CH,
+    CC_MAX_CH
+} audio_channel_t;
+
+typedef enum
+{
+    AF_SPDIF = 0,
+    AF_I2S,
+    AF_DSD,
+    AF_HBR,
+    AT_MAX
+} audio_format_t;
+
+typedef enum {
+    SS_REFER_TO_STREAM = 0,
+    SS_16BITS,
+    SS_20BITS,
+    SS_24BITS,
+    SS_MAX
+}audio_sample_size_t;
+
+struct size_map_ss {
+    unsigned int sample_bits;
+    audio_sample_size_t ss;
+};
+
+//FL-- Front Left
+//FC --Front Center
+//FR --Front Right
+//FLC-- Front Left Center
+//FRC-- Front RiQhtCenter
+//RL-- Rear Left
+//RC --Rear Center
+//RR-- Rear Right
+//RLC-- Rear Left Center
+//RRC --Rear RiQhtCenter
+//LFE-- Low Frequency Effect
+typedef enum {
+    CA_FR_FL = 0,
+    CA_LFE_FR_FL,
+    CA_FC_FR_FL,
+    CA_FC_LFE_FR_FL,
+
+    CA_RC_FR_FL,
+    CA_RC_LFE_FR_FL,
+    CA_RC_FC_FR_FL,
+    CA_RC_FC_LFE_FR_FL,
+
+    CA_RR_RL_FR_FL,
+    CA_RR_RL_LFE_FR_FL,
+    CA_RR_RL_FC_FR_FL,
+    CA_RR_RL_FC_LFE_FR_FL,
+
+    CA_RC_RR_RL_FR_FL,
+    CA_RC_RR_RL_LFE_FR_FL,
+    CA_RC_RR_RL_FC_FR_FL,
+    CA_RC_RR_RL_FC_LFE_FR_FL,
+
+    CA_RRC_RC_RR_RL_FR_FL,
+    CA_RRC_RC_RR_RL_LFE_FR_FL,
+    CA_RRC_RC_RR_RL_FC_FR_FL,
+    CA_RRC_RC_RR_RL_FC_LFE_FR_FL,
+
+    CA_FRC_RLC_FR_FL,
+    CA_FRC_RLC_LFE_FR_FL,
+    CA_FRC_RLC_FC_FR_FL,
+    CA_FRC_RLC_FC_LFE_FR_FL,
+
+    CA_FRC_RLC_RC_FR_FL,
+    CA_FRC_RLC_RC_LFE_FR_FL,
+    CA_FRC_RLC_RC_FC_FR_FL,
+    CA_FRC_RLC_RC_FC_LFE_FR_FL,
+
+    CA_FRC_RLC_RR_RL_FR_FL,
+    CA_FRC_RLC_RR_RL_LFE_FR_FL,
+    CA_FRC_RLC_RR_RL_FC_FR_FL,
+    CA_FRC_RLC_RR_RL_FC_LFE_FR_FL,
+}speak_location_t;
+
+typedef enum {
+	LSV_0DB = 0,
+        LSV_1DB,
+        LSV_2DB,
+        LSV_3DB,
+        LSV_4DB,
+        LSV_5DB,
+        LSV_6DB,
+        LSV_7DB,
+        LSV_8DB,
+        LSV_9DB,
+        LSV_10DB,
+        LSV_11DB,
+        LSV_12DB,
+        LSV_13DB,
+        LSV_14DB,
+        LSV_15DB,
+}audio_down_mix_t;
+
+typedef enum
+{
+	 STATE_AUDIO__MUTED         =  0,
+	 STATE_AUDIO__REQUEST_AUDIO = 1,
+	 STATE_AUDIO__AUDIO_READY   = 2,
+	 STATE_AUDIO__ON            = 3,
+}hdmi_rx_audio_state_t;
+
+//Sampling Freq Fs:0 - Refer to Stream Header; 1 - 32KHz; 2 - 44.1KHz; 3 - 48KHz; 4 - 88.2KHz...
+typedef enum {
+    FS_REFER_TO_STREAM = 0,
+    FS_32K   = 1,
+    FS_44K1  = 2,
+    FS_48K   = 3,
+    FS_88K2  = 4,
+    FS_96K   = 5,
+    FS_176K4 = 6,
+    FS_192K  = 7,
+    FS_MAX,
+}audio_fs_t;
+
+struct rate_map_fs {
+    unsigned int rate;
+    audio_fs_t fs;
+};
+
+typedef struct
+{
+    audio_type_t type ;     //!< Signal decoding type -- TvAudioType
+    audio_format_t format;
+     audio_channel_t channels ; //!< active audio channels bit mask.
+    audio_fs_t fs;     //!< Signal sample rate in Hz
+    audio_sample_size_t ss;
+    speak_location_t speak_loc;
+    audio_down_mix_t lsv;
+    unsigned N_value;
+    unsigned CTS;
+} Hdmi_rx_audio_info_t;
+
+#define AUDIO_PARA_MAX_NUM       7
+struct hdmi_audio_fs_fmt_n_cts {
+    struct {
+        unsigned int tmds_clk;
+        unsigned int n;
+        unsigned int cts;
+    }array[AUDIO_PARA_MAX_NUM];
+    unsigned int def_n;
+};
+
+#endif
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_info_global.h b/include/linux/amlogic/hdmi_tx/hdmi_info_global.h
old mode 100644
new mode 100755
index d85796531ec5..fda90083a3e7
--- a/include/linux/amlogic/hdmi_tx/hdmi_info_global.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_info_global.h
@@ -1,54 +1,9 @@
 #ifndef _HDMI_INFO_GLOBAL_H
 #define _HDMI_INFO_GLOBAL_H
 
-typedef enum HDMI_Video_Type_ {
-    HDMI_Unkown = 0 ,
-    HDMI_640x480p60 = 1 ,
-    HDMI_480p60,
-    HDMI_480p60_16x9,
-    HDMI_720p60,
-    HDMI_1080i60,
-    HDMI_480i60,
-    HDMI_480i60_16x9,
-    HDMI_480i60_16x9_rpt = 11,
-    HDMI_1440x480p60 = 14 ,
-    HDMI_1440x480p60_16x9 = 15 ,
-    HDMI_1080p60 = 16,
-    HDMI_576p50,
-    HDMI_576p50_16x9,
-    HDMI_720p50,
-    HDMI_1080i50,
-    HDMI_576i50,
-    HDMI_576i50_16x9,
-    HDMI_576i50_16x9_rpt = 26,
-    HDMI_1080p50 = 31,
-    HDMI_1080p24,
-    HDMI_1080p25,
-    HDMI_1080p30,
-    HDMI_480p60_16x9_rpt = 36,
-    HDMI_576p50_16x9_rpt = 38,
-    HDMI_4k2k_24 = 93,      // CEA-861-F
-    HDMI_4k2k_25,
-    HDMI_4k2k_30,
-    HDMI_4k2k_50,
-    HDMI_4k2k_60,
-    HDMI_4k2k_smpte_24 = 98,   //24 Hz
-    HDMI_4k2k_smpte_50 = 101,
-    HDMI_4k2k_smpte_60,
-} HDMI_Video_Codes_t ;
-
-
-//-------------------HDMI VIDEO--------------------------------
-#define TYPE_AVI_INFOFRAMES       0x82
-#define AVI_INFOFRAMES_VERSION    0x02
-#define AVI_INFOFRAMES_LENGTH     0x0D
+#include "hdmi_common.h"
 
-typedef enum
-{
-    COLOR_SPACE_RGB444 = 0,
-    COLOR_SPACE_YUV422 = 1,
-    COLOR_SPACE_YUV444 = 2,
-}color_space_type_t;
+// old definitions move to hdmi_common.h
 
 typedef enum
 {
@@ -66,23 +21,6 @@ typedef struct
 }pixs_type_t;
 
 
-typedef enum
-{
-    ASPECT_RATIO_SAME_AS_SOURCE= 0,
-    TV_ASPECT_RATIO_4_3,
-    TV_ASPECT_RATIO_16_9,
-    TV_ASPECT_RATIO_14_9,
-    ASPECT_RATIO_MAX
-} hdmi_aspect_ratio_t;
-
-typedef enum
-{
-    COLOR_24BIT = 0,
-    COLOR_30BIT,
-    COLOR_36BIT,
-    COLOR_48BIT
-} hdmi_color_depth_t;
-
 typedef enum
 {
     NO_REPEAT = 0,
@@ -157,176 +95,6 @@ typedef struct {
 #define AUDIO_INFOFRAMES_LENGTH     0x0A
 
 
-typedef enum
-{
-    CT_REFER_TO_STREAM = 0,
-    CT_PCM,
-    CT_AC_3,
-    CT_MPEG1,
-    CT_MP3,
-    CT_MPEG2,
-    CT_AAC,
-    CT_DTS,
-    CT_ATRAC,
-    CT_ONE_BIT_AUDIO,
-    CT_DOLBY_D,
-    CT_DTS_HD,
-    CT_MAT,
-    CT_DST,
-    CT_WMA,
-    CT_MAX,
-} audio_type_t;
-
-
-typedef enum
-{
-    CC_REFER_TO_STREAM = 0,
-    CC_2CH,
-    CC_3CH,
-    CC_4CH,
-    CC_5CH,
-    CC_6CH,
-    CC_7CH,
-    CC_8CH,
-    CC_MAX_CH
-} audio_channel_t;
-
-typedef enum
-{
-    AF_SPDIF = 0,
-    AF_I2S,
-    AF_DSD,
-    AF_HBR,
-    AT_MAX
-} audio_format_t;
-
-
-//Sampling Freq Fs:0 - Refer to Stream Header; 1 - 32KHz; 2 - 44.1KHz; 3 - 48KHz; 4 - 88.2KHz...
-typedef enum {
-    FS_REFER_TO_STREAM = 0,
-    FS_32K   = 1,
-    FS_44K1  = 2,
-    FS_48K   = 3,
-    FS_88K2  = 4,
-    FS_96K   = 5,
-    FS_176K4 = 6,
-    FS_192K  = 7,
-    FS_MAX,
-}audio_fs_t;
-
-struct rate_map_fs {
-    unsigned int rate;
-    audio_fs_t fs;
-};
-
-typedef enum {
-    SS_REFER_TO_STREAM = 0,
-    SS_16BITS,
-    SS_20BITS,
-    SS_24BITS,
-    SS_MAX
-}audio_sample_size_t;
-
-struct size_map_ss {
-    unsigned int sample_bits;
-    audio_sample_size_t ss;
-};
-
-//FL-- Front Left
-//FC --Front Center
-//FR --Front Right
-//FLC-- Front Left Center
-//FRC-- Front RiQhtCenter
-//RL-- Rear Left
-//RC --Rear Center
-//RR-- Rear Right
-//RLC-- Rear Left Center
-//RRC --Rear RiQhtCenter
-//LFE-- Low Frequency Effect
-typedef enum {
-    CA_FR_FL = 0,
-    CA_LFE_FR_FL,
-    CA_FC_FR_FL,
-    CA_FC_LFE_FR_FL,
-
-    CA_RC_FR_FL,
-    CA_RC_LFE_FR_FL,
-    CA_RC_FC_FR_FL,
-    CA_RC_FC_LFE_FR_FL,
-
-    CA_RR_RL_FR_FL,
-    CA_RR_RL_LFE_FR_FL,
-    CA_RR_RL_FC_FR_FL,
-    CA_RR_RL_FC_LFE_FR_FL,
-
-    CA_RC_RR_RL_FR_FL,
-    CA_RC_RR_RL_LFE_FR_FL,
-    CA_RC_RR_RL_FC_FR_FL,
-    CA_RC_RR_RL_FC_LFE_FR_FL,
-
-    CA_RRC_RC_RR_RL_FR_FL,
-    CA_RRC_RC_RR_RL_LFE_FR_FL,
-    CA_RRC_RC_RR_RL_FC_FR_FL,
-    CA_RRC_RC_RR_RL_FC_LFE_FR_FL,
-
-    CA_FRC_RLC_FR_FL,
-    CA_FRC_RLC_LFE_FR_FL,
-    CA_FRC_RLC_FC_FR_FL,
-    CA_FRC_RLC_FC_LFE_FR_FL,
-
-    CA_FRC_RLC_RC_FR_FL,
-    CA_FRC_RLC_RC_LFE_FR_FL,
-    CA_FRC_RLC_RC_FC_FR_FL,
-    CA_FRC_RLC_RC_FC_LFE_FR_FL,
-
-    CA_FRC_RLC_RR_RL_FR_FL,
-    CA_FRC_RLC_RR_RL_LFE_FR_FL,
-    CA_FRC_RLC_RR_RL_FC_FR_FL,
-    CA_FRC_RLC_RR_RL_FC_LFE_FR_FL,
-
-}speak_location_t;
-
-typedef enum {
-	LSV_0DB = 0,
-        LSV_1DB,
-        LSV_2DB,
-        LSV_3DB,
-        LSV_4DB,
-        LSV_5DB,
-        LSV_6DB,
-        LSV_7DB,
-        LSV_8DB,
-        LSV_9DB,
-        LSV_10DB,
-        LSV_11DB,
-        LSV_12DB,
-        LSV_13DB,
-        LSV_14DB,
-        LSV_15DB,
-
-}audio_down_mix_t;
-
-typedef enum
-{
-	 STATE_AUDIO__MUTED         =  0,
-	 STATE_AUDIO__REQUEST_AUDIO = 1,
-	 STATE_AUDIO__AUDIO_READY   = 2,
-	 STATE_AUDIO__ON            = 3,
-}hdmi_rx_audio_state_t;
-
-typedef struct
-{
-    audio_type_t		            type ;     //!< Signal decoding type -- TvAudioType
-    audio_format_t                      format;
-     audio_channel_t			 channels ; //!< active audio channels bit mask.
-    audio_fs_t				        fs;     //!< Signal sample rate in Hz
-    audio_sample_size_t                 ss;
-    speak_location_t                        speak_loc;
-    audio_down_mix_t                       lsv;
-    unsigned                                    N_value;
-    unsigned                                    CTS;
-} Hdmi_rx_audio_info_t;
-
 #define HDMI_E_NONE         0x0
 // HPD Event & Status
 #define E_HPD_PULG_IN       0x1
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
index 51a7190f4d18..a76fff139cfc 100755
--- a/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
@@ -18,7 +18,7 @@
 #ifndef _TV_CEC_H_
 #define _TV_CEC_H_
 #include <linux/amlogic/hdmi_tx/hdmi_tx_module.h> 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8) && (MESON_CPU_TYPE < MESON_CPU_TYPE_MESONG9TV)
 #include <mach/hdmi_parameter.h>
 #endif
 
@@ -44,6 +44,9 @@
 #endif
 #define HDMI_CEC_DEBUG()  printk("HDMI CEC DEBUG: %s [%d]\n", __FUNCTION__, __LINE__)
 
+//#define G9_CEC  //for G9 CEC debug.
+#define AO_CEC  //for switch between aocec and hdmi cec2.0
+
 extern unsigned int cec_tx_irq_flag;
 extern unsigned int cec_tx_irq_syn_flag;
 void fiq_gpio_test(unsigned int cmd);
@@ -159,72 +162,92 @@ typedef enum  {
     CEC_UNABLE_TO_DETERMINE,
 } cec_feature_abort_e;
 
+//#ifdef AO_CEC
+#if 1
+
+typedef enum {
+    JTAG_TMS = 1,
+    HDMI_CEC_AO,
+    HDMITX_CEC,
+    HDMIRX_CEC,
+    HDMI_GPIOAO_9,
+} cec_pinmux_set_e;
+
+typedef enum {
+    CEC_READ = 1,
+    CEC_WRITE,
+} cec_rw_e;
+
+void cec_hw_init(void);
+void cec_logic_addr_set(enum _cec_log_dev_addr_e phyaddr);
+
+#endif
 /*
  * CEC OPCODES
  */
 #define    CEC_OC_ABORT_MESSAGE                     0xFF
 #define    CEC_OC_ACTIVE_SOURCE                     0x82
-#define    CEC_OC_CEC_VERSION                         0x9E
-#define    CEC_OC_CLEAR_ANALOGUE_TIMER             0x33
-#define    CEC_OC_CLEAR_DIGITAL_TIMER                 0x99
-#define    CEC_OC_CLEAR_EXTERNAL_TIMER             0xA1
-#define    CEC_OC_DECK_CONTROL                     0x42
-#define    CEC_OC_DECK_STATUS                         0x1B
-#define    CEC_OC_DEVICE_VENDOR_ID                 0x87
+#define    CEC_OC_CEC_VERSION                       0x9E
+#define    CEC_OC_CLEAR_ANALOGUE_TIMER              0x33
+#define    CEC_OC_CLEAR_DIGITAL_TIMER               0x99
+#define    CEC_OC_CLEAR_EXTERNAL_TIMER              0xA1
+#define    CEC_OC_DECK_CONTROL                      0x42
+#define    CEC_OC_DECK_STATUS                       0x1B
+#define    CEC_OC_DEVICE_VENDOR_ID                  0x87
 #define    CEC_OC_FEATURE_ABORT                     0x00
-#define    CEC_OC_GET_CEC_VERSION                     0x9F
+#define    CEC_OC_GET_CEC_VERSION                   0x9F
 #define    CEC_OC_GET_MENU_LANGUAGE                 0x91
 #define    CEC_OC_GIVE_AUDIO_STATUS                 0x71
-#define    CEC_OC_GIVE_DECK_STATUS                 0x1A
-#define    CEC_OC_GIVE_DEVICE_POWER_STATUS         0x8F
+#define    CEC_OC_GIVE_DECK_STATUS                  0x1A
+#define    CEC_OC_GIVE_DEVICE_POWER_STATUS          0x8F
 #define    CEC_OC_GIVE_DEVICE_VENDOR_ID             0x8C
 #define    CEC_OC_GIVE_OSD_NAME                     0x46
 #define    CEC_OC_GIVE_PHYSICAL_ADDRESS             0x83
 #define    CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS     0x7D
-#define    CEC_OC_GIVE_TUNER_DEVICE_STATUS         0x08
+#define    CEC_OC_GIVE_TUNER_DEVICE_STATUS          0x08
 #define    CEC_OC_IMAGE_VIEW_ON                     0x04
-#define    CEC_OC_INACTIVE_SOURCE                     0x9D
-#define    CEC_OC_MENU_REQUEST                     0x8D
-#define    CEC_OC_MENU_STATUS                         0x8E
-#define    CEC_OC_PLAY                             0x41
-#define    CEC_OC_POLLING_MESSAGE                     0xFC    /* Fake Code - <Poll Message> has no OP Code and requires only the header byte */
-#define    CEC_OC_RECORD_OFF                         0x0B
+#define    CEC_OC_INACTIVE_SOURCE                   0x9D
+#define    CEC_OC_MENU_REQUEST                      0x8D
+#define    CEC_OC_MENU_STATUS                       0x8E
+#define    CEC_OC_PLAY                              0x41
+#define    CEC_OC_POLLING_MESSAGE                   0xFC    /* Fake Code - <Poll Message> has no OP Code and requires only the header byte */
+#define    CEC_OC_RECORD_OFF                        0x0B
 #define    CEC_OC_RECORD_ON                         0x09
 #define    CEC_OC_RECORD_STATUS                     0x0A
-#define    CEC_OC_RECORD_TV_SCREEN                 0x0F
-#define    CEC_OC_REPORT_AUDIO_STATUS                 0x7A
-#define    CEC_OC_REPORT_PHYSICAL_ADDRESS             0x84
-#define    CEC_OC_REPORT_POWER_STATUS                 0x90
+#define    CEC_OC_RECORD_TV_SCREEN                  0x0F
+#define    CEC_OC_REPORT_AUDIO_STATUS               0x7A
+#define    CEC_OC_REPORT_PHYSICAL_ADDRESS           0x84
+#define    CEC_OC_REPORT_POWER_STATUS               0x90
 #define    CEC_OC_REQUEST_ACTIVE_SOURCE             0x85
-#define    CEC_OC_ROUTING_CHANGE                     0x80
-#define    CEC_OC_ROUTING_INFORMATION                 0x81
-#define    CEC_OC_SELECT_ANALOGUE_SERVICE             0x92
-#define    CEC_OC_SELECT_DIGITAL_SERVICE             0x93
-#define    CEC_OC_SET_ANALOGUE_TIMER                 0x34
-#define    CEC_OC_SET_AUDIO_RATE                     0x9A
+#define    CEC_OC_ROUTING_CHANGE                    0x80
+#define    CEC_OC_ROUTING_INFORMATION               0x81
+#define    CEC_OC_SELECT_ANALOGUE_SERVICE           0x92
+#define    CEC_OC_SELECT_DIGITAL_SERVICE            0x93
+#define    CEC_OC_SET_ANALOGUE_TIMER                0x34
+#define    CEC_OC_SET_AUDIO_RATE                    0x9A
 #define    CEC_OC_SET_DIGITAL_TIMER                 0x97
-#define    CEC_OC_SET_EXTERNAL_TIMER                 0xA2
+#define    CEC_OC_SET_EXTERNAL_TIMER                0xA2
 #define    CEC_OC_SET_MENU_LANGUAGE                 0x32
-#define    CEC_OC_SET_OSD_NAME                     0x47
-#define    CEC_OC_SET_OSD_STRING                     0x64
-#define    CEC_OC_SET_STREAM_PATH                     0x86
+#define    CEC_OC_SET_OSD_NAME                      0x47
+#define    CEC_OC_SET_OSD_STRING                    0x64
+#define    CEC_OC_SET_STREAM_PATH                   0x86
 #define    CEC_OC_SET_SYSTEM_AUDIO_MODE             0x72
-#define    CEC_OC_SET_TIMER_PROGRAM_TITLE             0x67
-#define    CEC_OC_STANDBY                             0x36
+#define    CEC_OC_SET_TIMER_PROGRAM_TITLE           0x67
+#define    CEC_OC_STANDBY                           0x36
 #define    CEC_OC_SYSTEM_AUDIO_MODE_REQUEST         0x70
-#define    CEC_OC_SYSTEM_AUDIO_MODE_STATUS         0x7E
-#define    CEC_OC_TEXT_VIEW_ON                     0x0D
-#define    CEC_OC_TIMER_CLEARED_STATUS             0x43
-#define    CEC_OC_TIMER_STATUS                     0x35
-#define    CEC_OC_TUNER_DEVICE_STATUS                 0x07
-#define    CEC_OC_TUNER_STEP_DECREMENT             0x06
-#define    CEC_OC_TUNER_STEP_INCREMENT             0x05
-#define    CEC_OC_USER_CONTROL_PRESSED             0x44
+#define    CEC_OC_SYSTEM_AUDIO_MODE_STATUS          0x7E
+#define    CEC_OC_TEXT_VIEW_ON                      0x0D
+#define    CEC_OC_TIMER_CLEARED_STATUS              0x43
+#define    CEC_OC_TIMER_STATUS                      0x35
+#define    CEC_OC_TUNER_DEVICE_STATUS               0x07
+#define    CEC_OC_TUNER_STEP_DECREMENT              0x06
+#define    CEC_OC_TUNER_STEP_INCREMENT              0x05
+#define    CEC_OC_USER_CONTROL_PRESSED              0x44
 #define    CEC_OC_USER_CONTROL_RELEASED             0x45
-#define    CEC_OC_VENDOR_COMMAND                     0x89
-#define    CEC_OC_VENDOR_COMMAND_WITH_ID             0xA0
+#define    CEC_OC_VENDOR_COMMAND                    0x89
+#define    CEC_OC_VENDOR_COMMAND_WITH_ID            0xA0
 #define    CEC_OC_VENDOR_REMOTE_BUTTON_DOWN         0x8A
-#define    CEC_OC_VENDOR_REMOTE_BUTTON_UP             0x8B
+#define    CEC_OC_VENDOR_REMOTE_BUTTON_UP           0x8B
 
 /* cec message structure */
 typedef struct {
@@ -250,7 +273,7 @@ typedef struct {
     unsigned char msg[MAX_MSG];
     unsigned char length;
     struct list_head list;
-} cec_tx_message_list_t;
+} cec_usr_message_list_t;
 
 /* cec global struct */
 
@@ -502,6 +525,8 @@ int cec_ll_tx_polling(const unsigned char *msg, unsigned char len);
 
 int cec_ll_tx(const unsigned char *msg, unsigned char len);
 int cec_ll_rx( unsigned char *msg, unsigned char *len);
+int cec_rx_irq_handle(unsigned char *msg, unsigned char *len);
+unsigned int cec_intr_stat(void);
 
 void cec_test_function(unsigned char* arg, unsigned char arg_cnt);
 void cec_node_init(hdmitx_dev_t* hdmitx_device);
@@ -509,11 +534,13 @@ void cec_node_uninit(hdmitx_dev_t* hdmitx_device);
 
 void cec_hw_reset(void);
 
+unsigned int dispatch_buffer_parse(const char *buf, const char *string,  char *param, size_t count);
 void register_cec_rx_msg(unsigned char *msg, unsigned char len );
 void cec_handle_message(cec_rx_message_t* pcec_message);
-void unregister_cec_tx_msg(cec_tx_message_list_t* cec_usr_message_list);
+void unregister_cec_tx_msg(cec_usr_message_list_t* cec_tx_message_list);
+void unregister_cec_rx_msg(cec_usr_message_list_t* cec_rx_message_list);
 void register_cec_tx_msg(unsigned char *msg, unsigned char len);
-void cec_usr_cmd_post_process(void);
+void cec_tx_cmd_post_process(void);
 void cec_set_pending(tv_cec_pending_e on_off);
 void cec_polling_online_dev(int log_addr, int *bool);
 unsigned short cec_log_addr_to_dev_type(unsigned char log_addr);
@@ -581,17 +608,7 @@ void cec_set_standby(void);
 void cec_isr_post_process(void);
 void cec_clear_buf(unsigned int flag);
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag);
-void tx_irq_handle(void);
-void cec_arbit_bit_time_read(void);
-void tx_irq_handle(void);
-void ao_cec_init(void);
-#endif
-
-#ifdef CONFIG_ARCH_MESON6
-void cec_gpi_init(void);
-#endif
+void cec_tx_irq_handle(void);
 
 unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message);
 void cec_send_event(cec_rx_message_t* pcec_message);
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
index 00eb9b802660..a8a0bca76541 100755
--- a/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
@@ -78,6 +78,13 @@ typedef struct Vic_attr_map_ {
     unsigned int tmds_clk;
 }Vic_attr_map;
 
+enum hdmi_event_t {
+    HDMI_TX_NONE = 0,
+    HDMI_TX_HPD_PLUGIN = 1,
+    HDMI_TX_HPD_PLUGOUT = 2,
+    HDMI_TX_INTERNAL_INTR = 4,
+};
+
 #define EDID_MAX_BLOCK              4
 #define HDMI_TMP_BUF_SIZE           1024
 typedef struct hdmi_tx_dev_s {
@@ -87,6 +94,10 @@ typedef struct hdmi_tx_dev_s {
     struct task_struct *task_monitor;
     struct task_struct *task_hdcp;
     struct task_struct *task_cec;
+    struct workqueue_struct *hdmi_wq;
+    struct delayed_work work_hpd_plugin;
+    struct delayed_work work_hpd_plugout;
+    struct work_struct work_internal_intr;
     wait_queue_head_t cec_wait_rx;
     struct {
         void (*SetPacket)(int type, unsigned char* DB, unsigned char* HB);
@@ -106,7 +117,7 @@ typedef struct hdmi_tx_dev_s {
     }HWOp;
 
     struct hdmi_config_platform_data config_data;
-    
+    enum hdmi_event_t hdmitx_event;
     //wait_queue_head_t   wait_queue;            /* wait queues */
     /*EDID*/
     unsigned cur_edid_block;
@@ -143,6 +154,7 @@ typedef struct hdmi_tx_dev_s {
     unsigned int  tx_aud_cfg; /* 0, off; 1, on */
     unsigned int  tv_no_edid;           // For some un-well-known TVs, no edid at all
     unsigned int  hpd_lock;
+    unsigned int  mode420;
     unsigned int  output_blank_flag;    // if equals to 1, means current video & audio output are blank
     unsigned int  audio_notify_flag;
     unsigned int  audio_step;
@@ -208,6 +220,8 @@ typedef struct hdmi_tx_dev_s {
     #define TMDS_PHY_ENABLE     0x1
     #define TMDS_PHY_DISABLE    0x2
 #define MISC_VIID_IS_USING      (CMD_MISC_OFFSET + 0x05)
+#define MISC_CONF_MODE420       (CMD_MISC_OFFSET + 0x06)
+#define MISC_TMDS_CLK_DIV40     (CMD_MISC_OFFSET + 0x07)
 
 /***********************************************************************
  *                          Get State //GetState
@@ -278,6 +292,9 @@ extern unsigned char hdmi_pll_mode; /* 1, use external clk as hdmi pll source */
 
 extern void HDMITX_Meson_Init(hdmitx_dev_t* hdmitx_device);
 
+extern void hdmitx_hpd_plugin_handler(struct work_struct *work);
+extern void hdmitx_hpd_plugout_handler(struct work_struct *work);
+extern void hdmitx_internal_intr_handler(struct work_struct *work);
 extern unsigned char hdmi_audio_off_flag;
 
 #define HDMITX_HWCMD_MUX_HPD_IF_PIN_HIGH       0x3
@@ -344,5 +361,10 @@ typedef struct {
 
 extern void hdmi_print(int level, const char *fmt, ...);
 
+#define dd()
+#ifndef dd
+#error delete debug information
+#endif
+
 #endif
 
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_tx_scdc.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_scdc.h
new file mode 100644
index 000000000000..943447c8ebd4
--- /dev/null
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_scdc.h
@@ -0,0 +1,30 @@
+#ifndef __HDMI_TX_SCDC_H__
+#define __HDMI_TX_SCDC_H__
+
+// Little-Endian format
+enum {
+    SINK_VER = 0x01,
+    SOURCE_VER,                 // RW
+    UPDATE_0 = 0x10,            // RW
+    UPDATE_1,                   // RW
+    TMDS_CFG = 0x20,            // RW
+    SCRAMBLER_ST,
+    CONFIG_0 = 0x30,            // RW
+    STATUS_FLAGS_0 = 0x40,
+    STATUS_FLAGS_1,
+    ERR_DET_0_L = 0x50,
+    ERR_DET_0_H,
+    ERR_DET_1_L,
+    ERR_DET_1_H,
+    ERR_DET_2_L,
+    ERR_DET_2_H,
+    ERR_DET_CHKSUM,
+    TEST_CONFIG_0 = 0xC0,       // RW
+    MANUFACT_IEEE_OUI_2 = 0xD0,
+    MANUFACT_IEEE_OUI_1,
+    MANUFACT_IEEE_OUI_0,
+    DEVICE_ID = 0xD3,           // 0xD3 ~ 0xDD
+    MANUFACT_SPECIFIC = 0xDE,   // RW   0xDE ~ 0xFF
+}scdc_addr;
+
+#endif  // __HDMI_TX_SCDC_H__
diff --git a/include/linux/amlogic/vout/vinfo.h b/include/linux/amlogic/vout/vinfo.h
index 3c057bd3178b..f4360902e602 100755
--- a/include/linux/amlogic/vout/vinfo.h
+++ b/include/linux/amlogic/vout/vinfo.h
@@ -70,6 +70,9 @@ typedef enum {
 	VMODE_4K2K_23HZ , // for framerate automation 4k2k 23.97hz
 #endif
     VMODE_4K2K_SMPTE,
+    VMODE_4K2K_FAKE_5G,   // timing same as 4k2k30hz, Vsync from 30hz to 50hz
+    VMODE_4K2K_60HZ,	  // timing same as 4k2k30hz, Vsync from 30hz to 60hz
+    VMODE_4K2K_5G,
     VMODE_VGA,
     VMODE_SVGA,
     VMODE_XGA,
-- 
2.19.0

