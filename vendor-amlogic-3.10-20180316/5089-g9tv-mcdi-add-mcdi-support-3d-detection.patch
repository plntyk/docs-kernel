From 102d25d65b9c4fe7114d62909fa548ae7f683e5a Mon Sep 17 00:00:00 2001
From: "kele.bai" <kele.bai@amlogic.com>
Date: Tue, 18 Nov 2014 10:25:47 +0800
Subject: [PATCH 5089/5965] g9tv:mcdi,add mcdi,support 3d detection.

Change-Id: I3a04ca3d168788d1a869d462650a28dd7a72f549
---
 arch/arm/configs/mesong9tv_defconfig         |   1 +
 arch/arm/mach-mesong9tv/include/mach/irqs.h  |   1 +
 drivers/amlogic/deinterlace/deinterlace.c    | 376 ++++++++++++-------
 drivers/amlogic/deinterlace/deinterlace.h    |  54 ++-
 drivers/amlogic/deinterlace/deinterlace_hw.c | 315 +++++++---------
 drivers/amlogic/deinterlace/detect3d.c       |   2 +-
 drivers/amlogic/deinterlace/detect3d.h       |   2 +-
 include/linux/amlogic/amports/canvas.h       |   8 +-
 8 files changed, 441 insertions(+), 318 deletions(-)
 mode change 100644 => 100755 arch/arm/mach-mesong9tv/include/mach/irqs.h

diff --git a/arch/arm/configs/mesong9tv_defconfig b/arch/arm/configs/mesong9tv_defconfig
index 5a2f5564a530..93213c216e99 100755
--- a/arch/arm/configs/mesong9tv_defconfig
+++ b/arch/arm/configs/mesong9tv_defconfig
@@ -187,6 +187,7 @@ CONFIG_AML_HDMI_TX_20=y
 # CONFIG_AML_HDMI_TX is not set
 # CONFIG_AML_EXT_HDMIIN is not set
 CONFIG_AMLOGIC_IONVIDEO=y
+CONFIG_DEINTERLACE=y
 CONFIG_MALI400=y
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
diff --git a/arch/arm/mach-mesong9tv/include/mach/irqs.h b/arch/arm/mach-mesong9tv/include/mach/irqs.h
old mode 100644
new mode 100755
index 93031b330b62..96fedbb26e3d
--- a/arch/arm/mach-mesong9tv/include/mach/irqs.h
+++ b/arch/arm/mach-mesong9tv/include/mach/irqs.h
@@ -129,6 +129,7 @@
 #define INT_A9_DBG_COMRX0		AM_IRQ(141)
 #define INT_A9_DBG_COMRX1		AM_IRQ(142)
 #define INT_L2_CACHE			AM_IRQ(143)
+#define INT_DET3D			AM_IRQ(144)
 #define INT_ASSIST_MBOX0		AM_IRQ(145)
 #define INT_ASSIST_MBOX1		AM_IRQ(146)
 #define INT_ASSIST_MBOX2		AM_IRQ(147)
diff --git a/drivers/amlogic/deinterlace/deinterlace.c b/drivers/amlogic/deinterlace/deinterlace.c
index 6910b1aa7945..5790a38d2ad4 100755
--- a/drivers/amlogic/deinterlace/deinterlace.c
+++ b/drivers/amlogic/deinterlace/deinterlace.c
@@ -186,7 +186,7 @@ static dev_t di_id;
 static struct class *di_class;
 
 #define INIT_FLAG_NOT_LOAD 0x80
-static char version_s[] = "2014-11-3a";//remap dup_p buffer to mtnp
+static char version_s[] = "2014-11-13a";//update mvrd start/end
 static unsigned char boot_init_flag=0;
 static int receiver_is_amvideo = 1;
 
@@ -571,10 +571,6 @@ static void force_source_change(void);
 static int run_flag = DI_RUN_FLAG_RUN;
 static int pre_run_flag = DI_RUN_FLAG_RUN;
 static int dump_state_flag = 0;
-#ifdef NEW_DI_V1
-static char dump_path[20]={0};
-//static int capture_flag =0 ;
-#endif
 
 static ssize_t store_dbg(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
 {
@@ -835,49 +831,6 @@ static ssize_t store_log(struct device * dev, struct device_attribute *attr, con
     return 16;
 }
 
-static int set_noise_reduction_level(void)
-{
-    int nr_zone_0 = 4, nr_zone_1 = 8, nr_zone_2 = 12;
-    //int nr_hfilt_en = 0;
-    int nr_hfilt_mb_en = 0;
-    /* int post_mb_en = 0;
-    int blend_mtn_filt_en = 1;
-    int blend_data_filt_en = 1;
-    */
-    unsigned int nr_strength = 0, nr_gain2 = 0, nr_gain1 = 0, nr_gain0 = 0;
-
-    nr_strength = noise_reduction_level;
-    if (nr_strength > 64)
-        nr_strength = 64;
-    nr_gain2 = 64 - nr_strength;
-    nr_gain1 = nr_gain2 - ((nr_gain2 * nr_strength + 32) >> 6);
-    nr_gain0 = nr_gain1 - ((nr_gain1 * nr_strength + 32) >> 6);
-    nr_ctrl1 = (64 << 24) | (nr_gain2 << 16) | (nr_gain1 << 8) | (nr_gain0 << 0);
-
-    nr_ctrl0 =     (1 << 31 ) |          									// nr yuv enable.
-                       	(1 << 30 ) |          												// nr range. 3 point
-                       	(0 << 29 ) |          												// max of 3 point.
-                       	(nr_hfilt_en << 28 ) |          									// nr hfilter enable.
-                       	(nr_hfilt_mb_en << 27 ) |          									// nr hfilter motion_blur enable.
-#ifdef NEW_DI_V1
-                                (1 << 25)                 |//enable nr2
-#endif
-                                (nr_zone_2 <<16 ) |   												// zone 2
-                       	(nr_zone_1 << 8 ) |    												// zone 1
-                       	(nr_zone_0 << 0 ) ;   												// zone 0
-
-//    blend_ctrl =     ( post_mb_en << 28 ) |      											// post motion blur enable.
-//                              ( 0 << 27 ) |               													// mtn3p(l, c, r) max.
-//                              ( 0 << 26 ) |               													// mtn3p(l, c, r) min.
-//                              ( 0 << 25 ) |               													// mtn3p(l, c, r) ave.
-//                              ( 1 << 24 ) |               													// mtntopbot max
-//                              ( blend_mtn_filt_en  << 23 ) | 												// blend mtn filter enable.
-//                              ( blend_data_filt_en << 22 ) | 												// blend data filter enable.
-//                                kdeint0;                              												// kdeint.
-    return 0;
-
-}
-
 typedef struct{
     char* name;
     uint* param;
@@ -895,11 +848,6 @@ di_param_t di_params[]=
 #ifdef NEW_DI_V1
     {"ei_ctrl3",     &ei_ctrl3, NULL   },
 #endif
-    {"nr_ctrl0",     &nr_ctrl0, NULL   },
-    {"nr_ctrl1",     &nr_ctrl1, NULL   },
-    {"nr_ctrl2",     &nr_ctrl2, NULL   },
-    {"nr_ctrl3",     &nr_ctrl3, NULL   },
-
     {"mtn_ctrl_char_diff_cnt",     &mtn_ctrl_char_diff_cnt, NULL   },
     {"mtn_ctrl_low_level",	   &mtn_ctrl_low_level, NULL   },
     {"mtn_ctrl_high_level",	   &mtn_ctrl_high_level, NULL   },
@@ -937,7 +885,6 @@ di_param_t di_params[]=
     {"post_ctrl__di_post_repeat",  &post_ctrl__di_post_repeat, NULL},
     {"di_pre_ctrl__di_pre_repeat",  &di_pre_ctrl__di_pre_repeat, NULL},
 
-    {"noise_reduction_level", &noise_reduction_level, set_noise_reduction_level},
 
     {"field_32lvl", &field_32lvl, NULL},
     {"field_22lvl", &field_22lvl, NULL},
@@ -1661,6 +1608,11 @@ typedef struct{
                      2 (f2,nr1_cnt,nr0)->nr2_cnt
                      3 (f3,nr2_cnt,nr1_cnt)->nr3_cnt
                      */
+#endif
+#ifdef NEW_DI_V3
+    DI_MC_MIF_t di_mcinford_mif;
+    DI_MC_MIF_t di_mcvecwr_mif;
+    DI_MC_MIF_t di_mcinfowr_mif;
 #endif
     /* pre state */
     int in_seq;
@@ -1745,6 +1697,9 @@ typedef struct{
     DI_MIF_t di_buf1_mif;
     DI_SIM_MIF_t di_mtncrd_mif;
     DI_SIM_MIF_t di_mtnprd_mif;
+    #ifdef NEW_DI_V3
+    DI_MC_MIF_t di_mcvecrd_mif;
+    #endif
     int update_post_reg_flag;
     int post_process_fun_index;
     int run_early_proc_fun_flag;
@@ -1761,7 +1716,7 @@ static ssize_t store_dump_mem(struct device * dev, struct device_attribute *attr
 {
 	unsigned int n=0, canvas_w=0, canvas_h=0, canvas_real_size=0;
         char *buf_orig, *ps, *token;
-        char *parm[6] = {NULL};
+        char *parm[3] = {NULL};
         struct file *filp = NULL;
 	loff_t pos = 0;
 	void * buff = NULL;
@@ -1779,11 +1734,9 @@ static ssize_t store_dump_mem(struct device * dev, struct device_attribute *attr
                 continue;
             parm[n++] = token;
         }
-	if(!strncmp(parm[0],"capture",strlen("capture"))){
+	if(!strcmp(parm[0],"capture")){
 	    if(parm[1]!=NULL)
-		strcpy(dump_path,parm[1]);
 	    if(unlikely(di_pre_stru.di_mem_buf_dup_p==NULL)){
-                dump_state_flag=0;
 	        return len;
 	    }
 	    canvas_w = (di_pre_stru.di_mem_buf_dup_p->canvas_config_size>>16)&0xffff;
@@ -1792,15 +1745,14 @@ static ssize_t store_dump_mem(struct device * dev, struct device_attribute *attr
 	    old_fs = get_fs();
 	    set_fs(KERNEL_DS);
 	    //	printk("dump path =%s\n",dump_path);
-	    filp = filp_open(dump_path,O_RDWR|O_CREAT,0666);
+	    filp = filp_open(parm[1],O_RDWR|O_CREAT,0666);
 	    if(IS_ERR(filp)){
-		printk(KERN_ERR"create %s error.\n",dump_path);
+		printk(KERN_ERR"create %s error.\n",parm[1]);
 		return len;
 	    }
 	    dump_state_flag=1;
-	    for(n=0; n < 1; n++){
-		pos = canvas_real_size * n;
-		buf = phys_to_virt(di_pre_stru.di_mem_buf_dup_p->nr_adr+ local_buf_num*n);
+
+	    buff = phys_to_virt(di_pre_stru.di_mem_buf_dup_p->nr_adr);
 		vfs_write(filp,buff,canvas_real_size,&pos);
 		/*	pr_info("di_chan2_buf_dup_p:\n  nr:%u,mtn:%u,cnt:%u\n",di_pre_stru.di_chan2_buf_dup_p->nr_adr,
 														di_pre_stru.di_chan2_buf_dup_p->mtn_adr,
@@ -1816,12 +1768,11 @@ static ssize_t store_dump_mem(struct device * dev, struct device_attribute *attr
 														di_pre_stru.di_mem_buf_dup_p->cnt_adr);
 			pr_info("di_mem_start=%u\n",di_mem_start);
 			*/
-	    }
 	    vfs_fsync(filp,0);
 	    dump_state_flag=0;
 	    filp_close(filp,NULL);
 	    set_fs(old_fs);
-	    pr_info("write buffer %2d of %2u  from %u to %s.\n",n,canvas_real_size,di_pre_stru.di_mem_buf_dup_p->nr_adr,dump_path);
+	    pr_info("write buffer %d  to %s.\n",di_pre_stru.di_mem_buf_dup_p->seq,parm[1]);
 	}
 	else
 	    printk("wrong dump di canvas\n");
@@ -2087,7 +2038,7 @@ reg_cfg_t di_default_pre =
 //#define DI_EI_CTRL11
                 {0x179e, 0x486ab07a,0, 31},
 //#define DI_EI_CTRL12
-                {0x179f, 0xdb0c2503,0, 31},
+                {0x179f, 0xdb0c2503,0, 32},
 //#define DI_EI_CTRL13
                 {0x17a8, 0x0f021414 ,0, 31},
                 {0},
@@ -2416,7 +2367,9 @@ static int di_post_buf0_canvas_idx[2];
 static int di_post_buf1_canvas_idx[2];
 static int di_post_mtncrd_canvas_idx[2];
 static int di_post_mtnprd_canvas_idx[2];
-
+#ifdef NEW_DI_V3
+static int di_post_mcvecrd_canvas_idx[2];
+#endif
 static void config_canvas_idx(di_buf_t* di_buf, int nr_canvas_idx, int mtn_canvas_idx)
 {
     if(di_buf){
@@ -2456,6 +2409,26 @@ static void config_cnt_canvas_idx(di_buf_t* di_buf, int cnt_canvas_idx)
     }
 }
 #endif
+#ifdef NEW_DI_V3
+static void config_mcinfo_canvas_idx(di_buf_t* di_buf, int mcinfo_canvas_idx)
+{
+    if(di_buf){
+        //int width = (di_buf->canvas_config_size>>16)&0xffff;
+        int canvas_height = (di_buf->canvas_config_size)&0xffff;
+        di_buf->mcinfo_canvas_idx = mcinfo_canvas_idx;
+        canvas_config(mcinfo_canvas_idx,di_buf->mcinfo_adr,canvas_height,1,0,0);
+    }
+}
+static void config_mcvec_canvas_idx(di_buf_t* di_buf, int mcvec_canvas_idx)
+{
+    if(di_buf){
+        int width = (di_buf->canvas_config_size>>16)&0xffff;
+        int canvas_height = (di_buf->canvas_config_size)&0xffff;
+        di_buf->mcvec_canvas_idx = mcvec_canvas_idx;
+        canvas_config(mcvec_canvas_idx,di_buf->mcvec_adr,width*2/5,canvas_height/2,0,0);
+    }
+}
+#endif
 
 #else
 
@@ -2487,6 +2460,7 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
     unsigned dp_buf_size = 0;
     unsigned dp_mem_start = 0;
 #endif
+    unsigned int di_buf_size;
     frame_count = 0;
     disp_frame_count = 0;
     cur_post_ready_di_buf = NULL;
@@ -2494,18 +2468,20 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 	vframe_in[i]=NULL;
     }
     memset(&di_pre_stru, 0, sizeof(di_pre_stru));
-
+#ifdef D2D3_SUPPORT
+    dp_buf_size = 256*canvas_height/2;
+#endif
     if(prog_flag){
         di_pre_stru.prog_proc_type = 1;
+        di_buf_size = width*canvas_height*2;
 #ifdef D2D3_SUPPORT
         if(d2d3_enable){
-            dp_buf_size = 256*canvas_height/2;
-            local_buf_num = di_mem_size/((width*canvas_height*2)+dp_buf_size);
-            dp_mem_start = di_mem_start + (width*canvas_height*2)*local_buf_num;
+            local_buf_num = di_mem_size/(di_buf_size + dp_buf_size);
+            dp_mem_start = di_mem_start + di_buf_size*local_buf_num;
         }
         else
 #endif
-        local_buf_num = di_mem_size/(width*canvas_height*2);
+        local_buf_num = di_mem_size/di_buf_size;
         local_buf_num_available = local_buf_num;
         if(local_buf_num > (2*MAX_LOCAL_BUF_NUM)){
             local_buf_num = 2*MAX_LOCAL_BUF_NUM;
@@ -2519,24 +2495,23 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
     }
     else{
         di_pre_stru.prog_proc_type = 0;
-#ifdef D2D3_SUPPORT
-        if(d2d3_enable){
-            dp_buf_size = 256*canvas_height/2;
-#ifdef NEW_DI_V1
-            local_buf_num = di_mem_size/((width*canvas_height*6/4)+dp_buf_size);
-            dp_mem_start = di_mem_start + (width*canvas_height*6/4)*local_buf_num;
+#ifdef NEW_DI_V3
+	/*nr_size(bits)=w*active_h*8*2(yuv422) mtn(bits)=w*active_h*4 cont(bits)=w*active_h*4 mv(bits)=w*active_h/5*16 mcinfo(bits)=active_h*16*/
+	di_buf_size = width*canvas_height*6/4 + width*canvas_height/5 + canvas_height;
+#elif defined NEW_DI_V1
+        di_buf_size = width*canvas_height*6/4;
 #else
-            local_buf_num = di_mem_size/((width*canvas_height*5/4)+dp_buf_size);
-            dp_mem_start = di_mem_start + (width*canvas_height*5/4)*local_buf_num;
+        di_buf_size = width*canvas_height*5/4;
 #endif
+#ifdef D2D3_SUPPORT
+        if(d2d3_enable){
+	    local_buf_num = di_mem_size/(di_buf_size+dp_buf_size);
+            dp_mem_start = di_mem_start + di_buf_size*local_buf_num;
         }
         else
 #endif
-#ifdef NEW_DI_V1
-        local_buf_num = di_mem_size/(width*canvas_height*6/4);
-#else
-        local_buf_num = di_mem_size/(width*canvas_height*5/4);
-#endif
+	    local_buf_num = di_mem_size/di_buf_size;
+
         local_buf_num_available = local_buf_num;
         if(local_buf_num > MAX_LOCAL_BUF_NUM){
             local_buf_num = MAX_LOCAL_BUF_NUM;
@@ -2577,7 +2552,7 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
             di_buf->pre_ref_count = 0;
             di_buf->post_ref_count = 0;
             if(prog_flag){
-                di_buf->nr_adr = di_mem_start + (width*canvas_height*2)*i;
+                di_buf->nr_adr = di_mem_start + di_buf_size*i;
 #ifndef DI_USE_FIXED_CANVAS_IDX
     	        di_buf->nr_canvas_idx = DEINTERLACE_CANVAS_BASE_INDEX+i;
 #endif
@@ -2592,20 +2567,18 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 #endif
             }
             else{
-#ifdef NEW_DI_V1
-                di_buf->nr_adr = di_mem_start + (width*canvas_height*6/4)*i;
-#else
-                di_buf->nr_adr = di_mem_start + (width*canvas_height*5/4)*i;
-#endif
+		di_buf->nr_adr = di_mem_start + di_buf_size*i;
+		di_buf->mtn_adr = di_mem_start + di_buf_size*i + (width*canvas_height);
 #ifndef DI_USE_FIXED_CANVAS_IDX
     	        di_buf->nr_canvas_idx = DEINTERLACE_CANVAS_BASE_INDEX+i*2;
 #endif
-	              //canvas_config(di_buf->nr_canvas_idx, di_buf->nr_adr, width*2, canvas_height/2, 0, 0);
+	      //canvas_config(di_buf->nr_canvas_idx, di_buf->nr_adr, width*2, canvas_height/2, 0, 0);
 #ifdef NEW_DI_V1
-                di_buf->mtn_adr = di_mem_start + (width*canvas_height*6/4)*i + (width*canvas_height);
-                di_buf->cnt_adr = di_mem_start + (width*canvas_height*6/4)*i + (width*canvas_height)*5/4;
-#else
-                di_buf->mtn_adr = di_mem_start + (width*canvas_height*5/4)*i + (width*canvas_height);
+                di_buf->cnt_adr = di_mem_start + di_buf_size*i + (width*canvas_height)*5/4;
+#endif
+#ifdef NEW_DI_V3
+		di_buf->mcvec_adr = di_mem_start + di_buf_size*i + (width*canvas_height)*6/4;
+		di_buf->mcinfo_adr = di_mem_start + di_buf_size*i + (width*canvas_height)*6/4 + width*canvas_height/5;
 #endif
 #ifndef DI_USE_FIXED_CANVAS_IDX
     	        di_buf->mtn_canvas_idx = DEINTERLACE_CANVAS_BASE_INDEX+i*2+1;
@@ -3130,6 +3103,28 @@ static unsigned char check_di_buf(di_buf_t* di_buf, int reason)
 /*
 *  di pre process
 */
+#ifdef NEW_DI_V3
+static void config_di_mcinford_mif(DI_MC_MIF_t* di_mcinford_mif, di_buf_t* di_buf)
+{
+    if(di_buf){
+        di_mcinford_mif->size_x = di_buf->vframe->height/2 -1;
+	di_mcinford_mif->size_y = 1;
+	di_mcinford_mif->canvas_num = di_buf->mcinfo_canvas_idx;
+    }
+}
+static void config_di_pre_mc_mif(DI_MC_MIF_t* di_mcinfo_mif,DI_MC_MIF_t* di_mcvec_mif, di_buf_t* di_buf)
+{
+    if(di_buf){
+        di_mcinfo_mif->size_x = di_buf->vframe->height/2 -1;
+	di_mcinfo_mif->size_y = 1;
+	di_mcinfo_mif->canvas_num = di_buf->mcinfo_canvas_idx;
+
+	di_mcvec_mif->size_x = (di_buf->vframe->width+4)/5 - 1;
+	di_mcvec_mif->size_y = di_buf->vframe->height/2 - 1;
+	di_mcvec_mif->canvas_num = di_buf->mcvec_canvas_idx;
+    }
+}
+#endif
 #ifdef NEW_DI_V1
 static void config_di_cnt_mif(DI_SIM_MIF_t* di_cnt_mif, di_buf_t* di_buf)
 {
@@ -3306,6 +3301,9 @@ static void pre_de_process(void)
 #ifdef NEW_DI_V1
   int cont_rd = 1;
 #endif
+#ifdef NEW_DI_V3
+    int blkhsize = 0;
+#endif
 #ifdef DI_DEBUG
     di_print("%s: start\n", __func__);
 #endif
@@ -3325,12 +3323,19 @@ static void pre_de_process(void)
         config_canvas_idx(di_pre_stru.di_chan2_buf_dup_p, DI_PRE_CHAN2_NR_CANVAS_IDX, -1);
 #ifdef NEW_DI_V1
         config_cnt_canvas_idx(di_pre_stru.di_chan2_buf_dup_p, DI_CONTPRD_CANVAS_IDX);
+#endif
+#ifdef NEW_DI_V3
+	config_mcinfo_canvas_idx(di_pre_stru.di_chan2_buf_dup_p, DI_MCINFORD_CANVAS_IDX);
 #endif
     }
     config_canvas_idx(di_pre_stru.di_wr_buf, DI_PRE_WR_NR_CANVAS_IDX, DI_PRE_WR_MTN_CANVAS_IDX);
 #ifdef NEW_DI_V1
     config_cnt_canvas_idx(di_pre_stru.di_wr_buf, DI_CONTWR_CANVAS_IDX);
 #endif
+#ifdef NEW_DI_V3
+	config_mcinfo_canvas_idx(di_pre_stru.di_wr_buf, DI_MCINFOWR_CANVAS_IDX);
+	config_mcvec_canvas_idx(di_pre_stru.di_wr_buf, DI_MCVECWR_CANVAS_IDX);
+#endif
 #endif
     config_di_mif(&di_pre_stru.di_mem_mif, di_pre_stru.di_mem_buf_dup_p);
     config_di_mif(&di_pre_stru.di_chan2_mif, di_pre_stru.di_chan2_buf_dup_p);
@@ -3341,6 +3346,10 @@ static void pre_de_process(void)
     config_di_cnt_mif(&di_pre_stru.di_contprd_mif, di_pre_stru.di_chan2_buf_dup_p);
     config_di_cnt_mif(&di_pre_stru.di_contwr_mif, di_pre_stru.di_wr_buf);
 #endif
+#ifdef NEW_DI_V3
+    config_di_mcinford_mif(&di_pre_stru.di_mcinford_mif,di_pre_stru.di_chan2_buf_dup_p);
+    config_di_pre_mc_mif(&di_pre_stru.di_mcinfowr_mif,&di_pre_stru.di_mcvecwr_mif,di_pre_stru.di_wr_buf);
+#endif
 
     if((di_pre_stru.di_chan2_buf_dup_p)&&
         ((di_pre_stru.di_chan2_buf_dup_p->vframe->type & VIDTYPE_TYPEMASK) == VIDTYPE_INTERLACE_TOP)){
@@ -3348,7 +3357,12 @@ static void pre_de_process(void)
     }
 
     Wr(DI_PRE_SIZE,    di_pre_stru.di_nrwr_mif.end_x|(di_pre_stru.di_nrwr_mif.end_y << 16) );
-
+#ifdef NEW_DI_V3
+    blkhsize = (di_pre_stru.di_nrwr_mif.end_x+4)/5;
+    Wr(MCDI_HV_SIZEIN, (di_pre_stru.di_nrwr_mif.end_y+1)|((di_pre_stru.di_nrwr_mif.end_x+1) << 16));
+    Wr(MCDI_HV_BLKSIZEIN,(blkhsize << 16)|(di_pre_stru.di_nrwr_mif.end_y+1));
+    Wr(MCDI_BLKTOTAL,blkhsize*(di_pre_stru.di_nrwr_mif.end_y+1));		
+#endif
     // set interrupt mask for pre module.
 #ifdef NEW_DI_V1
   Wr(DI_INTR_CTRL, ((di_pre_stru.enable_mtnwr?1:0) << 16) |       // mask nrwr interrupt.
@@ -3356,6 +3370,11 @@ static void pre_de_process(void)
                     (1 << 18) |       // mask diwr interrupt.
                     (1 << 19) |       // mask hist check interrupt.
 					(1 << 20) |       // mask cont interrupt.
+                    #ifdef NEW_DI_V3
+		    (1 << 21) |       // mask medi interrupt.
+		    (1 << 22) |       // mask vecwr interrupt.
+		    (1 << 23) |       // mask infwr interrupt.
+                    #endif
                      0xf );            // clean all pending interrupt bits.
 #else
     Wr(DI_INTR_CTRL, (0 << 16) |       //  nrwr interrupt.
@@ -3412,17 +3431,16 @@ static void pre_de_process(void)
                di_pre_stru.enable_mtnwr,                      // mtn enable
                di_pre_stru.enable_pulldown_check,                                 // pd32 check_en
                di_pre_stru.enable_pulldown_check,                                  // pd22 check_en
-#if defined(CONFIG_ARCH_MESON)
-			         1,                      											// hist check_en
-#else
 			         0,                      											// hist check_en
-#endif
                chan2_field_num,                      //  field num for chan2. 1 bottom, 0 top.
                0,                      // pre viu link.
                pre_hold_line,                     //hold line.
                pre_urgent
              );
 		Wr(DI_PRE_CTRL, Rd(DI_PRE_CTRL)|(0x3 << 30)); //add for M6, reset
+#ifdef NEW_DI_V3
+    enable_mc_di_pre(&di_pre_stru.di_mcinford_mif,&di_pre_stru.di_mcinfowr_mif,&di_pre_stru.di_mcvecwr_mif);
+#endif
 #ifdef NEW_DI_V1
     if(get_new_mode_flag() == 1){
     if (di_pre_stru.cur_prog_flag == 1) {
@@ -3431,14 +3449,41 @@ static void pre_de_process(void)
 		cont_rd = 0;
     } else {
         di_mtn_1_ctrl1 |= (1<<31); //enable contwr
+            #ifdef NEW_DI_V3
+            Wr(DI_PRE_CTRL, Rd(DI_PRE_CTRL)|(1<<1));//mtn must enable for mtn1 enable
+            #endif
         di_mtn_1_ctrl1 &= (~(1<<29));//disable txt
         cont_rd = 1;
 	}
         if(di_pre_stru.field_count_for_cont >= 3){
-	    di_mtn_1_ctrl1 &= (~(1<<30)); // enable contp2rd and contprd
             di_mtn_1_ctrl1 |= 1<<29;//enable txt
+            #ifndef NEW_DI_V3
             Wr(DI_CLKG_CTRL, 0xfeff0000); //di enable nr clock gate
+            #else
+            Wr(DI_CLKG_CTRL, 0xfcf60000); //nr/blend0/ei0/mtn0 clock gate
+            #endif
             Wr(DI_PRE_CTRL, Rd(DI_PRE_CTRL)|(cont_rd<<25));
+            #ifdef NEW_DI_V3
+            if(di_pre_stru.cur_prog_flag == 0)
+                Wr(DI_MTN_CTRL1, 0x3000|Rd(DI_MTN_CTRL1));//enable me(mc di)
+            if(di_pre_stru.field_count_for_cont == 4){
+            	di_mtn_1_ctrl1 &= (~(1<<30)); // enable contp2rd and contprd
+            	Wr(MCDI_MOTINEN,1<<1|1);    //enable motin refinement
+            }
+            if(di_pre_stru.field_count_for_cont == 5){         
+                Wr(MCDI_CTRL_MODE,0x1bffffff);//disalbe reflinfo
+            }
+       	    #else
+	    di_mtn_1_ctrl1 &= (~(1<<30)); // enable contp2rd and contprd
+	    #endif
+        }else{
+            #ifdef NEW_DI_V3
+            Wr_reg_bits(MCDI_CTRL_MODE,1,9,1); // ref	
+            Wr_reg_bits(MCDI_CTRL_MODE,1,16,1);// qme
+            Wr_reg_bits(MCDI_CTRL_MODE,0,28,1);// close linf    
+            Wr(MCDI_MOTINEN,0);    //disable motin refinement
+            Wr(DI_MTN_CTRL1, (0xffffcfff&Rd(DI_MTN_CTRL1)));//disable me(mc di)
+            #endif
         }
 		    di_pre_stru.field_count_for_cont++;
     }
@@ -3698,11 +3743,6 @@ static void di_set_para_by_tvinfo(vframe_t* vframe)
 #endif
         kdeint2 = 25;
 	mtn_ctrl= 0xe228c440;
-    #ifdef CONFIG_MACH_MESON2_7366M_REFE03
-        if (vframe_source_type == VFRAME_SOURCE_TYPE_COMP)
-            blend_ctrl = 0x15f00019;
-        else
-    #endif
 		blend_ctrl=0x1f00019;
 	pr_info("%s: tvinfo change, reset di Reg \n", __FUNCTION__);
     }
@@ -3732,14 +3772,8 @@ static void di_set_para_by_tvinfo(vframe_t* vframe)
 	}
        else{
 	       kdeint2 = 25;
-        #ifdef CONFIG_MESON2_CHIP_C
-            mtn_ctrl = 0xe228c440;
-            blend_ctrl = 0x15f00019;
-            mtn_ctrl1_shift = 0x00000055;
-        #else
 		mtn_ctrl= 0x0 ;
 		blend_ctrl=0x19f00019;
-        #endif
 		pr_info("%s: tvinfo change, reset di Reg in tuner source \n", __FUNCTION__);
        }
     }
@@ -4441,6 +4475,50 @@ static irqreturn_t det3d_irq(int irq, void *dev_instance)
    return IRQ_HANDLED;
 }
 #endif
+#ifdef NEW_DI_V3
+static bool calc_mcinfo_en = 1;
+module_param(calc_mcinfo_en,bool,0664);
+MODULE_PARM_DESC(calc_mcinfo_en,"/n get mcinfo for post /n");
+
+static unsigned int colcfd_thr = 128;
+module_param(colcfd_thr,uint,0664);
+MODULE_PARM_DESC(colcfd_thr,"/n threshold for cfd/n");
+
+unsigned int ro_mcdi_col_cfd[26];
+static void get_mcinfo_from_reg_in_irq(void)
+{
+    unsigned int i=0, ncolcrefsum=0, blkcount=0;
+    /*get info for current field process by post*/
+    di_pre_stru.di_wr_buf->curr_field_mcinfo.highvertfrqflg = (Rd(MCDI_RO_HIGH_VERT_FRQ_FLG)&0x1);//post:MCDI_MC_REL_GAIN_OFFST_0
+    di_pre_stru.di_wr_buf->curr_field_mcinfo.motionparadoxflg = (Rd(MCDI_RO_MOTION_PARADOX_FLG)&0x1);//post:MCDI_MC_REL_GAIN_OFFST_0
+    for(i=0;i<26;i++){
+    	ro_mcdi_col_cfd[i] = Rd(0x2fb0+i);
+    	di_pre_stru.di_wr_buf->curr_field_mcinfo.regs[i] = 0;
+    	if(!calc_mcinfo_en){
+	    di_pre_stru.di_wr_buf->curr_field_mcinfo.regs[i] = ro_mcdi_col_cfd[i];
+	}
+    }
+    if(calc_mcinfo_en){
+	blkcount = (di_pre_stru.cur_width+4)/5;
+	for(i=0;i<blkcount;i++){
+            ncolcrefsum += ((ro_mcdi_col_cfd[i/32]>>(i%32))&0x1);
+	    if(((ncolcrefsum+(blkcount>>1))<<8)/blkcount > colcfd_thr){
+		for(i=0;i<blkcount;i++)
+	            di_pre_stru.di_wr_buf->curr_field_mcinfo.regs[i/32] += (1<<(i%32));
+	    }
+	}
+    }
+}
+static void set_post_mcinfo(struct mcinfo_pre_s *curr_field_mcinfo)
+{
+    unsigned int i=0;
+    VSYNC_WR_MPEG_REG_BITS(MCDI_MC_REL_GAIN_OFFST_0,curr_field_mcinfo->highvertfrqflg,24,1);
+    VSYNC_WR_MPEG_REG_BITS(MCDI_MC_REL_GAIN_OFFST_0,curr_field_mcinfo->motionparadoxflg,25,1);
+    for(i=0;i<26;i++){
+	VSYNC_WR_MPEG_REG(0x2f78+i,curr_field_mcinfo->regs[i]);
+    }
+}
+#endif
 static irqreturn_t de_irq(int irq, void *dev_instance)
 {
 #ifndef CHECK_DI_DONE
@@ -4465,6 +4543,9 @@ static irqreturn_t de_irq(int irq, void *dev_instance)
         di_print("%s: start\n", __func__);
 #endif
 
+#ifdef NEW_DI_V3
+    get_mcinfo_from_reg_in_irq();
+#endif
     di_pre_stru.pre_de_process_done = 1;
     di_pre_stru.pre_de_busy = 0;
 
@@ -4665,10 +4746,6 @@ static void get_vscale_skip_count(unsigned par)
 
 #define get_vpp_reg_update_flag(par) ((par>>16)&0x1)
 
-static int blend_mode = -2;
-module_param(blend_mode,int,0664);
-MODULE_PARM_DESC(blend_mode,"\n force post blend mode \n");
-
 static int de_post_process(void* arg, unsigned zoom_start_x_lines,
      unsigned zoom_end_x_lines, unsigned zoom_start_y_lines, unsigned zoom_end_y_lines, vframe_t* disp_vf)
 {
@@ -4744,6 +4821,12 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
 	     di_post_stru.di_mtnprd_mif.end_x 	        = di_end_x;
 	     di_post_stru.di_mtnprd_mif.start_y 	= di_start_y>>1;
 	     di_post_stru.di_mtnprd_mif.end_y 	        = di_end_y >>1;
+	     #ifdef NEW_DI_V3
+	     di_post_stru.di_mcvecrd_mif.start_x = (di_start_x+4)/5;
+	     di_post_stru.di_mcvecrd_mif.start_y = (di_start_y>>1);
+	     di_post_stru.di_mcvecrd_mif.size_x  = (di_width+4)/5 - 1;
+	     di_post_stru.di_mcvecrd_mif.size_y  = (di_height>>1)-1;
+	     #endif
 	     di_post_stru.update_post_reg_flag = update_post_reg_count;
     	}
 
@@ -4757,9 +4840,6 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
              di_post_stru.next_canvas_id = 1;
         }
 #endif
-	/*for debug*/
-	if(blend_mode != -2)
-	    di_buf->pulldown_mode = blend_mode;
 		
 	switch(di_buf->pulldown_mode){
 	    case PULL_DONW_BLEND_0:
@@ -4768,12 +4848,18 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
 		config_canvas_idx(di_buf->di_buf_dup_p[2], -1, di_post_mtnprd_canvas_idx[di_post_stru.canvas_id]);
 		config_canvas_idx(di_buf->di_buf_dup_p[0], di_post_buf1_canvas_idx[di_post_stru.canvas_id], -1);
 		config_canvas_idx(di_buf->di_buf_dup_p[1], -1, di_post_mtncrd_canvas_idx[di_post_stru.canvas_id]);//remove from m8
+		#ifdef NEW_DI_V3
+		config_mcvec_canvas_idx(di_buf->di_buf_dup_p[2], di_post_mcvecrd_canvas_idx[di_post_stru.canvas_id]);
+		#endif
 		break;
 	    case PULL_DOWN_BLEND_2:
 		config_canvas_idx(di_buf->di_buf_dup_p[1], di_post_buf0_canvas_idx[di_post_stru.canvas_id], -1);
 		config_canvas_idx(di_buf->di_buf_dup_p[1], -1, di_post_mtnprd_canvas_idx[di_post_stru.canvas_id]);
 		config_canvas_idx(di_buf->di_buf_dup_p[2], di_post_buf1_canvas_idx[di_post_stru.canvas_id], -1);
-		config_canvas_idx(di_buf->di_buf_dup_p[2], -1, di_post_mtncrd_canvas_idx[di_post_stru.canvas_id]);
+		config_canvas_idx(di_buf->di_buf_dup_p[1], -1, di_post_mtncrd_canvas_idx[di_post_stru.canvas_id]);
+		#ifdef NEW_DI_V3
+		config_mcvec_canvas_idx(di_buf->di_buf_dup_p[2], di_post_mcvecrd_canvas_idx[di_post_stru.canvas_id]);
+		#endif
 		break;
 	    case PULL_DOWN_MTN:
 		config_canvas_idx(di_buf->di_buf_dup_p[1], di_post_buf0_canvas_idx[di_post_stru.canvas_id], -1);
@@ -4802,6 +4888,9 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
 		di_post_stru.di_buf1_mif.canvas0_addr0 = di_buf->di_buf_dup_p[0]->nr_canvas_idx;
 		di_post_stru.di_mtncrd_mif.canvas_num = di_buf->di_buf_dup_p[1]->mtn_canvas_idx;
 		di_post_stru.di_mtnprd_mif.canvas_num = di_buf->di_buf_dup_p[2]->mtn_canvas_idx;
+		#ifdef NEW_DI_V3
+		di_post_stru.di_mcvecrd_mif.canvas_num = di_buf->di_buf_dup_p[2]->mcvec_canvas_idx;
+		#endif
 		post_blend_mode = 3;
 		blend_mtn_en = 1;
 		ei_en = 1;
@@ -4812,6 +4901,9 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
 		di_post_stru.di_buf1_mif.canvas0_addr0 = di_buf->di_buf_dup_p[2]->nr_canvas_idx;
 		di_post_stru.di_mtnprd_mif.canvas_num = di_buf->di_buf_dup_p[1]->mtn_canvas_idx;
 		di_post_stru.di_mtncrd_mif.canvas_num = di_buf->di_buf_dup_p[2]->mtn_canvas_idx;
+		#ifdef NEW_DI_V3
+		di_post_stru.di_mcvecrd_mif.canvas_num = di_buf->di_buf_dup_p[2]->mcvec_canvas_idx;
+		#endif
 		post_blend_mode = 3;
 		blend_mtn_en = 1;
 		ei_en = 1;
@@ -4857,7 +4949,10 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
     }
 #endif
 
-    if((di_post_stru.update_post_reg_flag)&&((force_update_post_reg&0x80)==0))
+#ifdef NEW_DI_V3
+    di_post_stru.di_mcvecrd_mif.blend_mode = post_blend_mode;
+#endif
+    if((di_post_stru.update_post_reg_flag)&&((force_update_post_reg&0x80)==0)){
 	enable_di_post_2 (
 	    		&di_post_stru.di_buf0_mif,
 	    		&di_post_stru.di_buf1_mif,
@@ -4875,6 +4970,10 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
 	    		post_urgent,
 	    		reg_mtn_info
 	    	);
+    	#ifdef NEW_DI_V3
+	enable_mc_di_post(&di_post_stru.di_mcvecrd_mif);
+	#endif
+	}
 	else
 	     di_post_switch_buffer (
 	    		&di_post_stru.di_buf0_mif,
@@ -4882,6 +4981,9 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
 	    		NULL,
 	    		&di_post_stru.di_mtncrd_mif,
 	    		&di_post_stru.di_mtnprd_mif,
+	    		#ifdef NEW_DI_V3
+	    		&di_post_stru.di_mcvecrd_mif,
+	    		#endif
 	    		ei_en, 																// ei enable
 	    		post_blend_en,													// blend enable
 	    		blend_mtn_en,													// blend mtn enable
@@ -4901,7 +5003,10 @@ static int de_post_process(void* arg, unsigned zoom_start_x_lines,
 
     di_post_read_reverse_irq(overturn);
 #endif
-
+#ifdef NEW_DI_V3
+    if(di_buf->di_buf_dup_p[2])
+        set_post_mcinfo(&di_buf->di_buf_dup_p[2]->curr_field_mcinfo);
+#endif
     if(di_post_stru.update_post_reg_flag>0)
 	di_post_stru.update_post_reg_flag--;
     return 0;
@@ -5525,6 +5630,9 @@ static void force_bob_vframe(di_buf_t* di_buf)
     di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
 }
 #endif
+static int blend_mode = -2;
+module_param(blend_mode,int,0664);
+MODULE_PARM_DESC(blend_mode,"\n force post blend mode \n");
 static int process_post_vframe(void)
 {
 /*
@@ -5673,6 +5781,9 @@ static int process_post_vframe(void)
                         }
                         */
                         else{
+               		    /*for debug*/
+                            if(blend_mode != -2)				
+                                di_buf->pulldown_mode = blend_mode;
                             di_buf->vframe->process_fun = de_post_process;
                             di_buf->process_fun_index = PROCESS_FUN_DI;
                             inc_post_ref_count(di_buf);
@@ -6143,8 +6254,6 @@ static void di_reg_process(void)
 /* add for di Reg re-init */
 #ifdef NEW_DI_TV
 di_set_para_by_tvinfo(vframe);
-#else
-di_load_nr_setting();
 #endif
             if(di_printk_flag&2){
                 di_printk_flag=1;
@@ -6960,11 +7069,11 @@ static DEVICE_ATTR(frame_format, 0664, show_frame_format, NULL);
 static struct resource memobj;
 static int di_probe(struct platform_device *pdev)
 {
-    int r, i;
-    struct resource *mem;
-    int buf_num_avail;
-    const void*name;
-    int offset,size;
+    int r=0, i=0, offset=0, size=0;
+    struct resource *mem=NULL;
+    int buf_num_avail=0;
+    const void *name=NULL;
+
     pr_dbg("di_probe\n");
     vout_register_client(&display_mode_notifier_nb_v);
 
@@ -6975,7 +7084,10 @@ static int di_probe(struct platform_device *pdev)
     di_post_buf1_canvas_idx[0] = DI_POST_BUF1_CANVAS_IDX;
     di_post_mtncrd_canvas_idx[0] = DI_POST_MTNCRD_CANVAS_IDX;
     di_post_mtnprd_canvas_idx[0] = DI_POST_MTNPRD_CANVAS_IDX;
-
+#ifdef NEW_DI_V3
+		di_post_mcvecrd_canvas_idx[0] = DI_POST_MCVECRD_CANVAS_IDX;
+		di_post_mcvecrd_canvas_idx[1] = DI_POST_MCVECRD_CANVAS_IDX2;
+#endif
 #ifdef CONFIG_VSYNC_RDMA
     di_post_buf0_canvas_idx[1] = DI_POST_BUF0_CANVAS_IDX2;
     di_post_buf1_canvas_idx[1] = DI_POST_BUF1_CANVAS_IDX2;
@@ -6991,7 +7103,7 @@ static int di_probe(struct platform_device *pdev)
 
     /* call di_add_reg_cfg() */
 #ifdef NEW_DI_V1
-	#if (defined(CONFIG_MACH_MESON6TV_H31)||defined(CONFIG_MACH_MESON6TV_H32))  //tcl
+	#if 0  //tcl
 	{
 		di_add_reg_cfg(&di_default_pre);
 		di_add_reg_cfg(&di_default_post_hd);
diff --git a/drivers/amlogic/deinterlace/deinterlace.h b/drivers/amlogic/deinterlace/deinterlace.h
index 30abd4065683..c74a08c17174 100755
--- a/drivers/amlogic/deinterlace/deinterlace.h
+++ b/drivers/amlogic/deinterlace/deinterlace.h
@@ -16,11 +16,13 @@
 #define NEW_KEEP_LAST_FRAME
 #endif
 
-#if (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD)
+#if (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESONG9TV)
 #ifndef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
 #define CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
 #endif
+#if (MESON_CPU_TYPE!=MESON_CPU_TYPE_MESONG9TV)
 #define D2D3_SUPPORT
+#endif
 #define DET3D
 //#define SUPPORT_MPEG_TO_VDIN
 #endif
@@ -36,9 +38,15 @@
 #elif (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8 || MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8B)
 #define NEW_DI_V1 //from m6tvc
 #define NEW_DI_V2 //from m6tvd(noise meter bug fix,improvement for 2:2 pull down)
-#elif (MESON_CPU_TYPE > MESON_CPU_TYPE_MESON8B)
+#elif (MESON_CPU_TYPE==MESON_CPU_TYPE_MESONG9TV)
+#define NEW_DI_TV
+#define NEW_DI_V1 //from m6tvc
+#define NEW_DI_V2 //from m6tvd(noise meter bug fix,improvement for 2:2 pull down)
+#define NEW_DI_V3 //from g9tv(mcdi added,d2d3 removed)
+#elif (MESON_CPU_TYPE > MESON_CPU_TYPE_MESONG9TV)
 #define NEW_DI_V1 //from m6tvc
 #define NEW_DI_V2 //from m6tvd(noise meter bug fix,improvement for 2:2 pull down)
+#define NEW_DI_V3
 #endif
 
 #ifndef CONFIG_VSYNC_RDMA
@@ -59,14 +67,13 @@
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 #define Wr(adr, val) WRITE_VCBUS_REG(adr, val)
 #define Rd(adr) READ_VCBUS_REG(adr)
-//#define Wr_reg_bits(reg, val, start, len) WRITE_VCBUS_REG_BITS(adr, val, start, len)
+#define Wr_reg_bits(adr, val, start, len) WRITE_VCBUS_REG_BITS(adr, val, start, len)
 #else
 #define Wr(adr, val) WRITE_MPEG_REG(adr, val)
 #define Rd(adr) READ_MPEG_REG(adr)
-//#define Wr_reg_bits(reg, val, start, len) WRITE_MPEG_REG_BITS(adr, val, start, len)
+#define Wr_reg_bits(adr, val, start, len) WRITE_MPEG_REG_BITS(adr, val, start, len)
 #endif
-#define Wr_reg_bits(reg, val, start, len) \
-  Wr(reg, (Rd(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
+//Wr(reg, (Rd(reg) & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start)))
 
 
 /************************************
@@ -176,6 +183,17 @@ typedef struct di_buf_s{
 #ifdef NEW_DI_V1
     unsigned int cnt_adr;
     int cnt_canvas_idx;
+#endif
+#ifdef NEW_DI_V3
+    unsigned int mcinfo_adr;
+    int mcinfo_canvas_idx;
+    unsigned int mcvec_adr;
+    int mcvec_canvas_idx;
+    struct mcinfo_pre_s{
+  	unsigned int highvertfrqflg;
+ 	unsigned int motionparadoxflg;
+        unsigned int regs[26];/* reg 0x2fb0~0x2fc9 */
+    }curr_field_mcinfo;
 #endif
     unsigned int canvas_config_flag; /* 0, configed; 1, config type 1 (prog); 2, config type 2 (interlace) */
     unsigned int canvas_config_size; /* bit [31~16] width; bit [15~0] height */
@@ -205,10 +223,6 @@ extern uint ei_ctrl3;
 #ifdef DET3D
 extern bool det3d_en;
 #endif
-extern uint nr_ctrl0;
-extern uint nr_ctrl1;
-extern uint nr_ctrl2;
-extern uint nr_ctrl3;
 extern uint mtn_ctrl;
 extern uint mtn_ctrl_char_diff_cnt;
 extern uint mtn_ctrl_low_level;
@@ -303,6 +317,15 @@ typedef struct DI_SIM_MIF_TYPE
    unsigned short  	canvas_num;
 } DI_SIM_MIF_t;
 
+typedef struct DI_MC_MIF_TYPE
+{
+    unsigned short start_x;
+    unsigned short start_y;
+    unsigned short size_x;
+    unsigned short size_y;
+    unsigned short canvas_num;
+    unsigned short blend_mode;
+} DI_MC_MIF_t;
 void disable_deinterlace(void);
 
 void disable_pre_deinterlace(void);
@@ -337,6 +360,10 @@ void enable_di_pre_aml (
    		int pre_field_num, int pre_viu_link, int hold_line, int urgent
    	);
 
+#ifdef NEW_DI_V3
+void enable_mc_di_pre(DI_MC_MIF_t *di_mcinford_mif,DI_MC_MIF_t *di_mcinfowr_mif,DI_MC_MIF_t *di_mcvecwr_mif);
+void enable_mc_di_post(DI_MC_MIF_t *di_mcvecrd_mif);
+#endif
 
 void enable_region_blend (
         int reg0_en, int reg0_start_x, int reg0_end_x, int reg0_start_y, int reg0_end_y, int reg0_mode,
@@ -371,6 +398,9 @@ void di_post_switch_buffer (
    DI_SIM_MIF_t    *di_diwr_mif,
    DI_SIM_MIF_t    *di_mtncrd_mif,
    DI_SIM_MIF_t    *di_mtnprd_mif,
+   #ifdef NEW_DI_V3
+   DI_MC_MIF_t     *di_mcvecrd_mif,
+   #endif
    int ei_en, int blend_en, int blend_mtn_en, int blend_mode, int di_vpp_en, int di_ddr_en,
    int post_field_num, int hold_line, int urgent,
    unsigned long * reg_mtn_info );
@@ -422,10 +452,6 @@ extern unsigned int pd32_debug_th;
 extern unsigned int pd32_diff_num_0_th;
 extern unsigned int pd22_th;
 extern unsigned int pd22_num_th;
-extern int nr_hfilt_en;
-
-/* init for nr */
-void di_load_nr_setting(void);
 
 #undef DI_DEBUG
 
diff --git a/drivers/amlogic/deinterlace/deinterlace_hw.c b/drivers/amlogic/deinterlace/deinterlace_hw.c
index 274a80205ba8..04b2efe6024c 100755
--- a/drivers/amlogic/deinterlace/deinterlace_hw.c
+++ b/drivers/amlogic/deinterlace/deinterlace_hw.c
@@ -38,10 +38,6 @@ uint ei_ctrl2;
 #ifdef NEW_DI_V1
 uint ei_ctrl3;
 #endif
-uint nr_ctrl0;
-uint nr_ctrl1;
-uint nr_ctrl2;
-uint nr_ctrl3;
 uint mtn_ctrl;
 uint mtn_ctrl_char_diff_cnt;
 uint mtn_ctrl_low_level;
@@ -96,6 +92,11 @@ module_param(frame_dynamic_level, int, 0664);
 
 MODULE_PARM_DESC(cue_enable, "\n cue_enable\n");
 module_param(cue_enable, bool, 0664);
+#ifdef NEW_DI_V3
+static unsigned short mcen_mode = 1;
+MODULE_PARM_DESC(mcen_mode, "\n blend mc enable\n");
+module_param(mcen_mode, ushort, 0664);
+#endif
 
 #ifdef DET3D
 static unsigned int det3d_cfg = 0;
@@ -147,22 +148,6 @@ static void init_pd_para(void)
 
 void reset_di_para(void)
 {
-  	int nr_zone_0 = 4, nr_zone_1 = 8, nr_zone_2 = 12;
-    //int nr_hfilt_en = 0;
-    int nr_hfilt_mb_en = 0;
-    //int mtn_modify_en = 1;
-    //int post_mb_en = 0;
-    //int blend_mtn_filt_en = 1;
-    //int blend_data_filt_en = 1;
-    unsigned int nr_strength = 0, nr_gain2 = 0, nr_gain1 = 0, nr_gain0 = 0;
-
-    nr_strength = noise_reduction_level;
-    if (nr_strength > 64)
-        nr_strength = 64;
-    nr_gain2 = 64 - nr_strength;
-    nr_gain1 = nr_gain2 - ((nr_gain2 * nr_strength + 32) >> 6);
-    nr_gain0 = nr_gain1 - ((nr_gain1 * nr_strength + 32) >> 6);
-    nr_ctrl1 = (64 << 24) | (nr_gain2 << 16) | (nr_gain1 << 8) | (nr_gain0 << 0);
 
 #if 1          //if input is pal and ntsc
     ei_ctrl0 =  (255 << 16) |     		// ei_filter.
@@ -199,33 +184,6 @@ void reset_di_para(void)
                   (10 << 8 ) |       				// far2
                    255;             				// far1
 #endif
-       nr_ctrl0 =     (1 << 31 ) |          									// nr yuv enable.
-                       	(1 << 30 ) |          												// nr range. 3 point
-                       	(0 << 29 ) |          												// max of 3 point.
-                       	(nr_hfilt_en << 28 ) |          									// nr hfilter enable.
-                       	(nr_hfilt_mb_en << 27 ) |          									// nr hfilter motion_blur enable.
-#ifdef NEW_DI_V1
-                                (1 << 25)|//enable nr 2
-#endif
-                                (nr_zone_2 <<16 ) |   												// zone 2
-                       	(nr_zone_1 << 8 ) |    												// zone 1
-                       	(nr_zone_0 << 0 ) ;   												// zone 0
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-     	nr_ctrl2 =      ( 8 << 24 ) |         									//intra noise level
-                     	( 1 << 16 )  |         												// intra no noise level.
-                     	( 10 << 8 ) |          												// inter noise level.
-                     	( 1 << 0 ) ;          												// inter no noise level.
-#else
-     	nr_ctrl2 =      ( 10 << 24 ) |         									//intra noise level
-                     	( 1 << 16 )  |         												// intra no noise level.
-                     	( 10 << 8 ) |          												// inter noise level.
-                     	( 1 << 0 ) ;          												// inter no noise level.
-#endif
-     	nr_ctrl3 =      ( 16 << 16 ) |         									// if any one of 3 point  mtn larger than 16 don't use 3 point.
-                       	720 ;               												// if one line eq cnt is larger than this number, this line is not conunted.
-
-
 	    mtn_ctrl_char_diff_cnt = 2;
 		mtn_ctrl_diff_level = 40;
 		mtn_ctrl_high_level = 196;
@@ -326,20 +284,37 @@ static void set_di_chan2_mif ( DI_MIF_t *mif, int urgent, int hold_line );
 
 static void set_di_if0_mif ( DI_MIF_t *mif, int urgent, int hold_line );
 
+static void di_nr_init(void);
 
+#ifdef NEW_DI_V3
+static void mc_di_param_init(void)
+{
+    Wr(MCDI_CHK_EDGE_GAIN_OFFST,0x4f6124);
+    Wr(MCDI_LMV_RT,0x7455);
+    Wr(MCDI_LMV_GAINTHD,0x6014d409);
+    Wr(MCDI_REL_DET_LPF_MSK_22_30,0x0a010001);
+    Wr(MCDI_REL_DET_LPF_MSK_31_34,0x01010101);
+}
+#endif
 void di_hw_init(void)
 {
+#ifdef NEW_DI_V1
+    unsigned short fifo_size = 0x120;
+#endif
+#ifdef NEW_DI_V3
+    fifo_size = 0x300;
+#endif
 #ifdef NEW_DI_V1
     Wr(DI_MTN_1_CTRL1, Rd(DI_MTN_1_CTRL1)&(~(1<<31))); //enable old DI mode for m6tv
     Wr(DI_CLKG_CTRL, Rd(DI_CLKG_CTRL)|0x1); //di no clock gate
 
     /* fifo size setting from 0x1be60 to 0x1bf20 */
-    Wr(VD1_IF0_LUMA_FIFO_SIZE, 0x1bf20);  // 1a63 is vd1_if0_luma_fifo_size
-    Wr(VD2_IF0_LUMA_FIFO_SIZE, 0x1bf20);  // 1a83 is vd2_if0_luma_fifo_size
-    Wr(DI_INP_LUMA_FIFO_SIZE, 0x1bf20);   // 17d8 is DI_INP_luma_fifo_size
-    Wr(DI_MEM_LUMA_FIFO_SIZE, 0x1bf20);   // 17e5 is DI_MEM_luma_fifo_size
-    Wr(DI_IF1_LUMA_FIFO_SIZE, 0x1bf20);   // 17f2 is  DI_IF1_luma_fifo_size
-    Wr(DI_CHAN2_LUMA_FIFO_SIZE, 0x1bf20); // 17b3 is DI_chan2_luma_fifo_size
+    Wr(VD1_IF0_LUMA_FIFO_SIZE,  fifo_size);  // 1a63 is vd1_if0_luma_fifo_size
+    Wr(VD2_IF0_LUMA_FIFO_SIZE,  fifo_size);  // 1a83 is vd2_if0_luma_fifo_size
+    Wr(DI_INP_LUMA_FIFO_SIZE,   fifo_size);  // 17d8 is DI_INP_luma_fifo_size
+    Wr(DI_MEM_LUMA_FIFO_SIZE,   fifo_size);  // 17e5 is DI_MEM_luma_fifo_size
+    Wr(DI_IF1_LUMA_FIFO_SIZE,   fifo_size);  // 17f2 is  DI_IF1_luma_fifo_size
+    Wr(DI_CHAN2_LUMA_FIFO_SIZE, fifo_size);  // 17b3 is DI_chan2_luma_fifo_size
 #endif
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
@@ -347,14 +322,15 @@ void di_hw_init(void)
 #else
     Wr(DI_PRE_HOLD, (1 << 31) | (31 << 16) | 31);
 #endif
-#if defined(CONFIG_ARCH_MESON)
-    Wr(DI_NRMTN_CTRL0, 0xb00a0603);
-#endif
-
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
         //need not set DI_CLKG_CTRL, hardware default value of this register is already 0
     //Wr_reg_bits(DI_CLKG_CTRL, 0x0, 0, 2);    // bit 0: 1, no clock; bit 1: 0, auto clock gate
+#endif
+	//nr default setting
+    di_nr_init();
+#ifdef NEW_DI_V3
+    mc_di_param_init();
 #endif
 }
 
@@ -401,12 +377,10 @@ void enable_di_pre_aml (
   	{
        	set_di_chan2_mif(di_chan2_mif, urgent, hold_line);   	// set urgent 0.
        	#ifdef NEW_DI_V1
-            Wr(DI_NR_CTRL0, nr_ctrl0 | (cue_enable << 26));
-	#else
-     	    Wr(DI_NR_CTRL0, nr_ctrl0);
+            Wr_reg_bits(DI_NR_CTRL0,cue_enable,26,1);
 	#endif
   	}else{
-            Wr(DI_NR_CTRL0, nr_ctrl0 | (0 << 26));
+            Wr_reg_bits(DI_NR_CTRL0,0,26,1);
   	}
 
   	// set nr wr mif interface.
@@ -421,11 +395,7 @@ void enable_di_pre_aml (
      	Wr(DI_NRWR_CTRL, di_nrwr_mif->canvas_num );     						// canvas index.
      	                                                                    // urgent bit 8
 #endif
-#if !defined(CONFIG_ARCH_MESON)
-     	Wr(DI_NR_CTRL1, nr_ctrl1);
-     	Wr(DI_NR_CTRL2, nr_ctrl2);
-     	Wr(DI_NR_CTRL3, nr_ctrl3);
-#endif
+
    	}
 
    	// motion wr mif.
@@ -461,12 +431,13 @@ void enable_di_pre_aml (
 #else
                       (0 << 8));       															// urgent.
 #endif
-#if !defined(CONFIG_ARCH_MESON)
+
        //	Wr(DI_MTN_CTRL, (1 << 31) | (1 << 30) | (1 << 29) |  (mtn_ctrl_char_diff_cnt<< 24) |  (mtn_ctrl_diff_level<<16) |   (mtn_ctrl_high_level<<8) |    (mtn_ctrl_low_level<< 0));
        //   Wr(DI_MTN_CTRL,0x2300f080);
+        #ifndef NEW_DI_V3
         Wr(DI_MTN_CTRL,mtn_ctrl);
+        #endif
        	Wr(DI_MTN_CTRL1, (mtn_ctrl1_shift<< 8) |  mtn_ctrl1_reduce);
-#endif
     }
 
 #ifdef NEW_DI_V1
@@ -489,25 +460,6 @@ void enable_di_pre_aml (
   	Wr(DI_PRE_CTRL, Rd(DI_PRE_CTRL) |
                    1 << 31 );                  						// frame reset for the pre modules.
 
-#if defined(CONFIG_ARCH_MESON)
-  	Wr(DI_PRE_CTRL, nr_en |        						// NR enable
-                    (mtn_en << 1 ) |        						// MTN_EN
-                    (pd32_check_en << 2 ) |        					// check 3:2 pulldown
-                    (pd22_check_en << 3 ) |        					// check 2:2 pulldown
-                    (1 << 4 ) |        								// 2:2 check mid pixel come from next field after MTN.
-                    (hist_check_en << 5 ) |        					// hist check enable
-                    (hist_check_only << 6 ) |        				// hist check  use chan2.
-                    ((!nr_en) << 7 ) |        						// hist check use data before noise reduction.
-                    ((pd22_check_en || hist_check_only) << 8 ) |	// chan 2 enable for 2:2 pull down check.
-                    (pd22_check_en << 9) |        					// line buffer 2 enable
-                    (0 << 10) |        								// pre drop first.
-                    (0 << 11) |        								// pre repeat.
-                    (0 << 12) |        								// pre viu link
-                    (hold_line << 16) |      						// pre hold line number
-                    (pre_field_num << 29) |        					// pre field number.
-                    (0x1 << 30 )      								// pre soft rst, pre frame rst.
-                   );
-#else
   	Wr(DI_PRE_CTRL, nr_en |        						// NR enable
                     (mtn_en << 1 ) |        						// MTN_EN
                     (pd32_check_en << 2 ) |        					// check 3:2 pulldown
@@ -526,7 +478,7 @@ void enable_di_pre_aml (
                     (pre_field_num << 29) |        					// pre field number.
                     (0x1 << 30 )      								// pre soft rst, pre frame rst.
                    );
-#endif
+
 #ifdef SUPPORT_MPEG_TO_VDIN
 	if(mpeg2vdin_flag)
 		WRITE_MPEG_REG_BITS(DI_PRE_CTRL,1,13,1);// pre sync with vdin vsync
@@ -541,7 +493,55 @@ void enable_di_pre_aml (
     }
 #endif
 }
+#ifdef NEW_DI_V3
+void enable_mc_di_pre(DI_MC_MIF_t *di_mcinford_mif,DI_MC_MIF_t *di_mcinfowr_mif,DI_MC_MIF_t *di_mcvecwr_mif)
+{
+    Wr(MCDI_MCVECWR_X, di_mcvecwr_mif->size_x);
+    Wr(MCDI_MCVECWR_Y, di_mcvecwr_mif->size_y);
+    Wr(MCDI_MCINFOWR_X, di_mcinfowr_mif->size_x);
+    Wr(MCDI_MCINFOWR_Y, di_mcinfowr_mif->size_y);
+
+    Wr(MCDI_MCINFORD_X, di_mcinford_mif->size_x);
+    Wr(MCDI_MCINFORD_Y, di_mcinford_mif->size_y);
+    Wr(MCDI_MCVECWR_CANVAS_SIZE,(di_mcvecwr_mif->size_x<<16)+di_mcvecwr_mif->size_y);
+    Wr(MCDI_MCINFOWR_CANVAS_SIZE,(di_mcinfowr_mif->size_x<<16)+di_mcinfowr_mif->size_y);
+    Wr(MCDI_MCINFORD_CANVAS_SIZE,(di_mcinford_mif->size_x<<16)+di_mcinford_mif->size_y);
+
+    //Wr(MCDI_MOTINEN,1<<1);    //enable motin refinement
+    
+   Wr(MCDI_MCVECWR_CTRL ,di_mcvecwr_mif->canvas_num |
+                         (0<<14) |   // sync latch en
+			 (0<<8 ) |   //urgent
+			 (1<<12) |   // enable reset by frame rst
+			 (0xc031<<16));   
+   Wr(MCDI_MCINFOWR_CTRL,di_mcinfowr_mif->canvas_num |
+                         (0<<14) |   // sync latch en
+		         (0<<8 ) |   //urgent
+			 (1<<12) |   // enable reset by frame rst
+			 (0xc042<<16));          
+   Wr(MCDI_MCINFORD_CTRL,di_mcinford_mif->canvas_num |
+                         (0<<10) |   // sync latch en
+			 (0<<8 ) |   //urgent
+			 (1<<9)  |      // enable reset by frame rst
+			 (0x8042<<16));
+}
 
+void enable_mc_di_post(DI_MC_MIF_t *di_mcvecrd_mif)
+{
+    VSYNC_WR_MPEG_REG(MCDI_MCVECRD_X, di_mcvecrd_mif->start_x<<16|(di_mcvecrd_mif->size_x+di_mcvecrd_mif->start_x));
+    VSYNC_WR_MPEG_REG(MCDI_MCVECRD_Y, di_mcvecrd_mif->start_y<<16|(di_mcvecrd_mif->size_y+di_mcvecrd_mif->start_y));
+    VSYNC_WR_MPEG_REG(MCDI_MCVECRD_CANVAS_SIZE,(di_mcvecrd_mif->size_x<<16)+di_mcvecrd_mif->size_y);
+    VSYNC_WR_MPEG_REG(MCDI_MCVECRD_CTRL, di_mcvecrd_mif->canvas_num |  // canvas index. 
+                                         (1<<9)   |  // canvas enable
+                                         (0<< 10) |
+                                         (0x8031<<16));  
+   if(di_mcvecrd_mif->blend_mode == 3)  
+       VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,mcen_mode,0,2);  //open mc
+   else
+       VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,0,0,2);  //disable mc
+}
+
+#endif
 
 static void set_vd1_fmt_more (
 		int hfmt_en,
@@ -1561,6 +1561,9 @@ void di_post_switch_buffer (
    DI_SIM_MIF_t    *di_diwr_mif,
    DI_SIM_MIF_t    *di_mtncrd_mif,
    DI_SIM_MIF_t    *di_mtnprd_mif,
+#ifdef NEW_DI_V3
+   DI_MC_MIF_t     *di_mcvecrd_mif,
+#endif
    int ei_en, int blend_en, int blend_mtn_en, int blend_mode, int di_vpp_en, int di_ddr_en,
    int post_field_num, int hold_line, int urgent,
    unsigned long * reg_mtn_info )
@@ -1609,14 +1612,6 @@ void di_post_switch_buffer (
     }
    	if ( ei_only == 0)
    	{
-#if defined(CONFIG_ARCH_MESON)
-      	VSYNC_WR_MPEG_REG(DI_BLEND_CTRL,  (Rd(DI_BLEND_CTRL) & (~((1 << 25) | (3 << 20 )))) | // clean some bit we need to set.
-                              (blend_mtn_en << 26 ) |   													// blend mtn enable.
-                              (0 << 25 ) |   																// blend with the mtn of the pre display field and next display field.
-                              (1 << 24 ) |   																// blend with pre display field.
-                              (blend_mode << 20)    														// motion adaptive blend.
-               );
-#else
 
 	//VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (blend_ctrl&(~(3<<20))&~(0xff))|(blend_mode<<20)|kdeint);
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (blend_ctrl&0xffcfff00)| (blend_mode<<20) | (0xff&kdeint0));
@@ -1628,11 +1623,18 @@ void di_post_switch_buffer (
 	if(reg_mtn_info[4]>mtn_thre_2_high){
 	VSYNC_WR_MPEG_REG(DI_BLEND_CTRL,((blend_ctrl&0xffcfff00) | (blend_mode<<20)| (0xff&kdeint2)));
 	}
+	#ifndef NEW_DI_V3
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL1, (blend_ctrl1_char_level<< 24 ) |    ( blend_ctrl1_angle_thd << 16 ) |    ( blend_ctrl1_filt_thd<< 8 )  |    ( blend_ctrl1_diff_thd));
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL2,   (blend_ctrl2_black_level<< 8 ) |     (blend_ctrl2_mtn_no_mov)  );
-#ifdef NEW_DI_V1
-//    VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, Rd(DI_BLEND_CTRL)&(~(1<<31)));
-#endif
+  #else
+  	VSYNC_WR_MPEG_REG(MCDI_MCVECRD_CTRL, (Rd(MCDI_MCVECRD_CTRL) & 0xffffff00 ) |
+			( 1<<9 ) |									  // canvas enable
+							di_mcvecrd_mif->canvas_num |  // canvas index.
+		    (0 << 8));
+        if(di_mcvecrd_mif->blend_mode == 3)  
+            VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,mcen_mode,0,2);  //open mc
+        else
+   	    VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,0,0,2);  //diable mc
 #endif
    	}
 
@@ -1679,8 +1681,10 @@ void enable_di_post_2 (
     {
         VSYNC_WR_MPEG_REG(DI_MTNPRD_X, (di_mtnprd_mif->start_x <<16) | (di_mtnprd_mif->end_x));   			// start_x 0 end_x 719.
         VSYNC_WR_MPEG_REG(DI_MTNPRD_Y, (di_mtnprd_mif->start_y <<16) | (di_mtnprd_mif->end_y));   			// start_y 0 end_y 239.
+   #ifndef NEW_DI_V3
       	VSYNC_WR_MPEG_REG(DI_MTNCRD_X, (di_mtncrd_mif->start_x <<16) | (di_mtncrd_mif->end_x));   				// start_x 0 end_x 719.
       	VSYNC_WR_MPEG_REG(DI_MTNCRD_Y, (di_mtncrd_mif->start_y <<16) | (di_mtncrd_mif->end_y));             	// start_y 0 end_y 239.
+	 #endif
 	VSYNC_WR_MPEG_REG(DI_MTNRD_CTRL, (di_mtnprd_mif->canvas_num <<8 ) |									//mtnp canvas index.
 					 (urgent << 16) |// urgent
 					 di_mtncrd_mif->canvas_num );
@@ -1701,14 +1705,6 @@ void enable_di_post_2 (
 
    	if ( ei_only == 0)
    	{
-#if defined(CONFIG_ARCH_MESON)
-      	VSYNC_WR_MPEG_REG(DI_BLEND_CTRL,  (Rd(DI_BLEND_CTRL) & (~((1 << 25) | (3 << 20 )))) | // clean some bit we need to set.
-                              (blend_mtn_en << 26 ) |   													// blend mtn enable.
-                              (0 << 25 ) |   																// blend with the mtn of the pre display field and next display field.
-                              (1 << 24 ) |   																// blend with pre display field.
-                              (blend_mode << 20)    														// motion adaptive blend.
-               );
-#else
 
 	//VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (blend_ctrl&(~(3<<20))&~(0xff))|(blend_mode<<20)|kdeint);
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (blend_ctrl&0xffcfff00)|(blend_mode<<20)|(0xff&kdeint0));
@@ -1721,33 +1717,15 @@ void enable_di_post_2 (
 	if(reg_mtn_info[4]>mtn_thre_2_high){
 	VSYNC_WR_MPEG_REG(DI_BLEND_CTRL,((blend_ctrl&0xffcfff00) | (blend_mode<<20)| (0xff&kdeint2)));
 	}
+	#ifndef NEW_DI_V3
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL1, (blend_ctrl1_char_level<< 24 ) |    ( blend_ctrl1_angle_thd << 16 ) |    ( blend_ctrl1_filt_thd<< 8 )  |    ( blend_ctrl1_diff_thd));
     VSYNC_WR_MPEG_REG(DI_BLEND_CTRL2,   (blend_ctrl2_black_level<< 8 ) |     (blend_ctrl2_mtn_no_mov)  );
+    #endif
 #ifdef NEW_DI_V1
 //    VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, Rd(DI_BLEND_CTRL)&(~(1<<31)));
-#endif
 #endif
    	}
 
-#if defined(CONFIG_ARCH_MESON)
-   	VSYNC_WR_MPEG_REG(DI_POST_CTRL, ((ei_en | blend_en) << 0 ) | 		// line buffer 0 enable
-                      (0 << 1)  |        							// line buffer 1 enable
-                      (ei_en << 2) |        						// ei  enable
-                      (blend_mtn_en << 3) |        					// mtn line buffer enable
-                      (blend_mtn_en  << 4) |        				// mtnp read mif enable
-                      ((post_ctrl__di_blend_en!=0xff)?(post_ctrl__di_blend_en&0x1):(blend_en << 5)) |        						// di blend enble.
-                      (1 << 6) |        							// di mux output enable
-                      (di_ddr_en << 7) |        					// di write to SDRAM enable.
-                      (di_vpp_en << 8) |        					// di to VPP enable.
-                      (0 << 9) |        							// mif0 to VPP enable.
-                      (0 << 10) |        							// post drop first.
-                      (0 << 11) |        							// post repeat.
-                      (1 << 12) |        							// post viu link
-                      (hold_line << 16) |       					// post hold line number
-                      (post_field_num << 29) |        				// post field number.
-                      (0x1 << 30 )       							// post soft rst  post frame rst.
-        );
-#else
    	VSYNC_WR_MPEG_REG(DI_POST_CTRL, ((ei_en | blend_en) << 0 ) | 		// line buffer 0 enable
                       (0 << 1)  |        							// line buffer 1 enable
                       (ei_en << 2) |        						// ei  enable
@@ -1765,7 +1743,6 @@ void enable_di_post_2 (
                       (post_field_num << 29) |        				// post field number.
                       (0x1 << 30 )       							// post soft rst  post frame rst.
         );
-#endif
 #ifdef NEW_DI_V1
         VSYNC_WR_MPEG_REG(DI_EI_CTRL3, ei_ctrl3);
 #endif
@@ -1822,14 +1799,6 @@ void di_post_switch_buffer_pd (
     }
 
     if (ei_only == 0) {
-#if defined(CONFIG_ARCH_MESON)
-        VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (Rd(DI_BLEND_CTRL) & (~((1 << 25) | (3 << 20)))) |   // clean some bit we need to set.
-                       (blend_mtn_en << 26) |                                                        // blend mtn enable.
-                       (0 << 25) |                                                                   // blend with the mtn of the pre display field and next display field.
-                       (1 << 24) |                                                                   // blend with pre display field.
-                       (blend_mode << 20)                                                            // motion adaptive blend.
-                      );
-#else
         VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, 
 	#ifdef NEW_DI_V1
        		       (1<<31) |        //enable new ei(remove from m8b)
@@ -1844,7 +1813,6 @@ void di_post_switch_buffer_pd (
                        (blend_mode << 20) |                                                       // motion adaptive blend.
                        25                                                                            // kdeint.
                       );
-#endif
     }
     VSYNC_WR_MPEG_REG_BITS(DI_POST_CTRL, post_field_num, 29, 1);
 }
@@ -1899,14 +1867,6 @@ void enable_di_post_pd(
     }
 
     if (ei_only == 0) {
-#if defined(CONFIG_ARCH_MESON)
-        VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, (Rd(DI_BLEND_CTRL) & (~((1 << 25) | (3 << 20)))) |   // clean some bit we need to set.
-                       (blend_mtn_en << 26) |                                                        // blend mtn enable.
-                       (0 << 25) |                                                                   // blend with the mtn of the pre display field and next display field.
-                       (1 << 24) |                                                                   // blend with pre display field.
-                       (blend_mode << 20)                                                            // motion adaptive blend.
-                      );
-#else
         VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, 
      	#ifdef NEW_DI_V1
        		       (1<<31)   |      //enable new ei(remove from m8b)
@@ -1927,28 +1887,8 @@ void enable_di_post_pd(
                        (64));                                                                         // all 4 equal
         VSYNC_WR_MPEG_REG(DI_BLEND_CTRL2, (4 << 8) |                                                           // mtn no mov level.
                        (48));                                                                        //black level.
-#endif
     }
 
-#if defined(CONFIG_ARCH_MESON)
-    VSYNC_WR_MPEG_REG(DI_POST_CTRL, ((ei_en | blend_en) << 0) |        // line buffer 0 enable
-                   (0 << 1)  |                                   // line buffer 1 enable
-                   (ei_en << 2) |                                // ei  enable
-                   (blend_mtn_en << 3) |                         // mtn line buffer enable
-                   (blend_mtn_en  << 4) |                        // mtnp read mif enable
-                   (blend_en << 5) |                             // di blend enble.
-                   (1 << 6) |                                    // di mux output enable
-                   (di_ddr_en << 7) |                            // di write to SDRAM enable.
-                   (di_vpp_en << 8) |                            // di to VPP enable.
-                   (0 << 9) |                                    // mif0 to VPP enable.
-                   (0 << 10) |                                   // post drop first.
-                   (0 << 11) |                                   // post repeat.
-                   (1 << 12) |                                   // post viu link
-                   (hold_line << 16) |                           // post hold line number
-                   (post_field_num << 29) |                      // post field number.
-                   (0x1 << 30)                                   // post soft rst  post frame rst.
-                  );
-#else
     VSYNC_WR_MPEG_REG(DI_POST_CTRL, ((ei_en | blend_en) << 0) |        // line buffer 0 enable
                    (0 << 1)  |                                   // line buffer 1 enable
                    (ei_en << 2) |                                // ei  enable
@@ -1966,7 +1906,6 @@ void enable_di_post_pd(
                    (post_field_num << 29) |                      // post field number.
                    (0x1 << 30)                                   // post soft rst  post frame rst.
                   );
-#endif
 }
 #endif
 
@@ -2121,15 +2060,24 @@ void read_mtn_info(unsigned long* mtn_info, unsigned long * reg_mtn_info)
 }
 void di_post_read_reverse(bool reverse)
 {
-#if ((MESON_CPU_TYPE ==  MESON_CPU_TYPE_MESON6TV)||	(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TVD	))
+#ifdef NEW_DI_TV
     if(reverse) {
         Wr_reg_bits(DI_IF1_GEN_REG2,    3, 2, 2);
         Wr_reg_bits(VD1_IF0_GEN_REG2, 0xf, 2, 4);
         Wr_reg_bits(VD2_IF0_GEN_REG2, 0xf, 2, 4);
+        #ifdef NEW_DI_V3
+        /* motion vector read reverse*/
+        Wr_reg_bits(MCDI_MCVECRD_X, 1, 30, 1);
+        Wr_reg_bits(MCDI_MCVECRD_Y, 1, 30, 1);
+        #endif
     } else {
         Wr_reg_bits(DI_IF1_GEN_REG2,  0, 2, 2);
 	Wr_reg_bits(VD1_IF0_GEN_REG2, 0, 2, 4);
 	Wr_reg_bits(VD2_IF0_GEN_REG2, 0, 2, 4);
+	#ifdef NEW_DI_V3
+	Wr_reg_bits(MCDI_MCVECRD_X, 0, 30, 1);
+        Wr_reg_bits(MCDI_MCVECRD_Y, 0, 30, 1);
+        #endif
     }
 #endif    
 }
@@ -2191,9 +2139,38 @@ unsigned char di_get_power_control(unsigned char type)
 
 }
 
-void di_load_nr_setting()
+static void di_nr_init()
 {
-#ifdef NEW_DI_V1
+#ifdef NEW_DI_V3
+    Wr(DI_NR_CTRL0,0xc60c0804);
+    Wr(DI_NR_CTRL1,0x403e3c3a);
+    Wr(DI_NR_CTRL2,0x08010a01);
+    Wr(NR2_MET_NM_CCTRL,0x45056410);
+    Wr(NR2_MATNR_SNR_NRM_GAIN,0x4);
+    Wr(NR2_MATNR_SNR_LPF_CFG,0xc1d64);
+    Wr(NR2_MATNR_SNR_EDGE2B,0xcff08);
+    Wr(NR2_MATNR_YBETA_SCL,0x00ff2000);
+    Wr(NR2_MATNR_MTN_CRTL2,0x32020);
+    Wr(NR2_MATNR_MTN_COR,0x3333);
+    Wr(NR2_MATNR_DEGHOST,0x133);
+    Wr(NR2_MATNR_ALPHALP_LUT1,0x80805040);
+    Wr(NR2_MATNR_ALPHALP_LUT2,0x90808080);
+    Wr(NR2_MATNR_ALPHALP_LUT3,0xffe0c0a4);
+    Wr(NR2_MATNR_ALPHAHP_LUT1,0x80805040);
+    Wr(NR2_MATNR_ALPHAHP_LUT2,0x90808080);
+    Wr(NR2_MATNR_ALPHAHP_LUT3,0xffe0c0a4);
+    Wr(NR3_MODE,0x3);
+    Wr(NR3_COOP_PARA,0x28ff00);
+    Wr(NR3_CNOOP_GAIN,0x881900);
+    Wr(NR3_YMOT_PARA,0x0c0a1e);
+    Wr(NR3_CMOT_PARA,0x08140f);
+    Wr(NR3_SUREMOT_YGAIN,0x100c4014);
+    Wr(NR3_SUREMOT_CGAIN,0x22264014);
+#elif (defined NEW_DI_V1)
+    Wr(DI_NR_CTRL0,0xc60c0804);
+    Wr(DI_NR_CTRL1,0x403e3c3a);
+    Wr(DI_NR_CTRL2,0x08010a01);
+    Wr(DI_NR_CTRL3,0x001002d0);
     Wr(NR2_3DEN_MODE, 0x77);
     Wr(NR2_SNR_SAD_CFG, 0x134f);
     Wr(NR2_MATNR_SNR_NRM_GAIN, 0x0);
diff --git a/drivers/amlogic/deinterlace/detect3d.c b/drivers/amlogic/deinterlace/detect3d.c
index 0038562d55b5..3621ad45b6c8 100755
--- a/drivers/amlogic/deinterlace/detect3d.c
+++ b/drivers/amlogic/deinterlace/detect3d.c
@@ -4,7 +4,7 @@
 /* Amlogic Headers */
 #include <mach/am_regs.h>
 
-#if (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD)
+#if (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD)||( MESON_CPU_TYPE==MESON_CPU_TYPE_MESONG9TV) 
 /* Local include */
 #include <linux/amlogic/tvin/tvin.h>
 #include "detect3d.h"
diff --git a/drivers/amlogic/deinterlace/detect3d.h b/drivers/amlogic/deinterlace/detect3d.h
index e628d0e59903..2bcb1f6c2bfc 100755
--- a/drivers/amlogic/deinterlace/detect3d.h
+++ b/drivers/amlogic/deinterlace/detect3d.h
@@ -1,7 +1,7 @@
 #ifndef _DET3D_H
 #define _DET3D_H
 
-#if (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD)
+#if (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD)||( MESON_CPU_TYPE==MESON_CPU_TYPE_MESONG9TV) 
 //***************************************************************************
 //******** DET3D REGISTERS ********
 //***************************************************************************
diff --git a/include/linux/amlogic/amports/canvas.h b/include/linux/amlogic/amports/canvas.h
index 78101e7815b7..db78ffac98eb 100755
--- a/include/linux/amlogic/amports/canvas.h
+++ b/include/linux/amlogic/amports/canvas.h
@@ -99,11 +99,17 @@ typedef struct {
 #define DI_CONTPRD_CANVAS_IDX           0x74
 #define DI_CONTP2RD_CANVAS_IDX           0x75
 #define DI_CONTWR_CANVAS_IDX            0x76
+#define DI_MCINFORD_CANVAS_IDX          0x26
+#define DI_MCINFOWR_CANVAS_IDX          0x27
+#define DI_MCVECWR_CANVAS_IDX           0x28
 //DI POST, share with DISPLAY
 #define DI_POST_BUF0_CANVAS_IDX         0x66
 #define DI_POST_BUF1_CANVAS_IDX         0x67
 #define DI_POST_MTNCRD_CANVAS_IDX       0x68
 #define DI_POST_MTNPRD_CANVAS_IDX       0x69
+//MCDI POST
+#define DI_POST_MCVECRD_CANVAS_IDX      0xE4
+#define DI_POST_MCVECRD_CANVAS_IDX2     0xE5
 
 #ifdef CONFIG_VSYNC_RDMA
 #define DI_POST_BUF0_CANVAS_IDX2         0x6a
@@ -129,7 +135,7 @@ typedef struct {
 #define MIPI_CANVAS_MAX_INDEX 0x7f
 
 //tvin vdin: 0x18-0x3B
-#define VDIN_CANVAS_INDEX              0x26
+#define VDIN_CANVAS_INDEX              0x29
 #define VDIN_CANVAS_MAX_INDEX          0x3B
 
 #define CAMERA_USER_CANVAS_INDEX             0x4e
-- 
2.19.0

