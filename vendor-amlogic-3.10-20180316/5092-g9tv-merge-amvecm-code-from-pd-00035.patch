From d20acbaa5997ab9435dad8fd5142996af6ac7112 Mon Sep 17 00:00:00 2001
From: "dezhi.kong" <dezhi.kong@amlogic.com>
Date: Fri, 21 Nov 2014 17:53:05 +0800
Subject: [PATCH 5092/5965] g9tv: merge amvecm code from pd-00035.

---
 arch/arm/configs/mesong9tv_defconfig         |    1 +
 drivers/amlogic/amports/Makefile             |    4 +-
 drivers/amlogic/amports/amcm.c               |  139 -
 drivers/amlogic/amports/amcm.h               |   47 -
 drivers/amlogic/amports/amve.c               |  370 ---
 drivers/amlogic/amports/amve.h               |   46 -
 drivers/amlogic/amports/video.c              |  146 +-
 drivers/amlogic/amvecm/amcm.c                |  562 ++--
 drivers/amlogic/amvecm/amcm.h                |   10 +-
 drivers/amlogic/amvecm/amcm_regmap.h         |  917 ++++++
 drivers/amlogic/amvecm/amve.c                | 1529 ++++-----
 drivers/amlogic/amvecm/amve.h                |   12 +-
 drivers/amlogic/amvecm/amve_gamma_table.h    |   64 +
 drivers/amlogic/amvecm/amvecm.c              | 3005 +++++-------------
 drivers/amlogic/amvecm/amvecm_vlock_regmap.h |   76 +
 include/linux/amlogic/amports/amstream.h     |   19 -
 include/linux/amlogic/amports/cm.h           |  169 -
 include/linux/amlogic/amports/ve.h           |  184 --
 include/linux/amlogic/amstream.h             |   19 -
 include/linux/amlogic/amvecm.h               |   21 +-
 include/linux/amlogic/cm.h                   |   26 +-
 include/linux/amlogic/tvin/tvin.h            |   19 +-
 22 files changed, 3047 insertions(+), 4338 deletions(-)
 delete mode 100755 drivers/amlogic/amports/amcm.c
 delete mode 100755 drivers/amlogic/amports/amcm.h
 delete mode 100755 drivers/amlogic/amports/amve.c
 delete mode 100755 drivers/amlogic/amports/amve.h
 create mode 100755 drivers/amlogic/amvecm/amcm_regmap.h
 create mode 100755 drivers/amlogic/amvecm/amve_gamma_table.h
 create mode 100755 drivers/amlogic/amvecm/amvecm_vlock_regmap.h
 delete mode 100755 include/linux/amlogic/amports/cm.h
 delete mode 100755 include/linux/amlogic/amports/ve.h

diff --git a/arch/arm/configs/mesong9tv_defconfig b/arch/arm/configs/mesong9tv_defconfig
index 93213c216e99..83accf31e780 100755
--- a/arch/arm/configs/mesong9tv_defconfig
+++ b/arch/arm/configs/mesong9tv_defconfig
@@ -186,6 +186,7 @@ CONFIG_AM_LOGO=y
 CONFIG_AML_HDMI_TX_20=y
 # CONFIG_AML_HDMI_TX is not set
 # CONFIG_AML_EXT_HDMIIN is not set
+CONFIG_AM_VECM=y
 CONFIG_AMLOGIC_IONVIDEO=y
 CONFIG_DEINTERLACE=y
 CONFIG_MALI400=y
diff --git a/drivers/amlogic/amports/Makefile b/drivers/amlogic/amports/Makefile
index 51f5944830d4..7bf21b9dc8c3 100755
--- a/drivers/amlogic/amports/Makefile
+++ b/drivers/amlogic/amports/Makefile
@@ -64,8 +64,8 @@ ifeq ($(CONFIG_ARCH_MESONG9TV),y)
 amports-objs := $(AMPORTS_OBJS)
 amports-y    := $(AMPORTS_OBJS)
 else
-amports-objs := $(AMPORTS_OBJS) amve.o amcm.o
-amports-y    := $(AMPORTS_OBJS) amve.o amcm.o
+amports-objs := $(AMPORTS_OBJS)
+amports-y    := $(AMPORTS_OBJS)
 endif
 endif
 endif
diff --git a/drivers/amlogic/amports/amcm.c b/drivers/amlogic/amports/amcm.c
deleted file mode 100755
index 61bdecdb8e1c..000000000000
--- a/drivers/amlogic/amports/amcm.c
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Color Management
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#include <mach/am_regs.h>
-
-#include "linux/amlogic/amports/vframe.h"
-#include "linux/amlogic/amports/cm.h"
-
-#include "cm_regs.h"
-#include "amcm.h"
-
-#if 0
-struct cm_region_s cm_region;
-struct cm_top_s    cm_top;
-struct cm_demo_s   cm_demo;
-#endif
-
-static inline ulong read_cm_reg_bits(ulong reg, ulong bit, ulong wid)
-{
-    WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, reg);
-    return((READ_CBUS_REG(VPP_CHROMA_DATA_PORT) >> bit) & ((1 << wid) - 1));
-}
-
-static inline void write_cm_reg_bits(ulong reg, ulong val, ulong bit, ulong wid)
-{
-    ulong mask = (1 << wid) - 1;
-    ulong data = read_cm_reg_bits(reg, 0, 31);
-
-    if (val > mask) {
-        val = mask;
-    }
-    data &= ~(mask << bit);
-    data |= (val << bit);
-    WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, reg);
-    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, val);
-}
-
-// ***************************************************************************
-// *** IOCTL-oriented functions *********************************************
-// ***************************************************************************
-
-void cm_set_region(struct cm_region_s *p)
-{
-    ulong reg_off         = (p->region_idx) * 6;
-    ulong hue_shf_ran_inv = ((1 << 20) / (p->hue_shf_ran) + 1) >> 1;
-
-    write_cm_reg_bits(HUE_HUE_RANGE_REG00 + reg_off, p->sym_en         , SYM_EN_BIT         , SYM_EN_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->sat_en         , SAT_EN_BIT         , SAT_EN_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->sat_central_en , SAT_CENTRAL_EN_BIT , SAT_CENTRAL_EN_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->sat_shape      , SAT_SHAPE_BIT      , SAT_SHAPE_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->sat_gain       , SAT_GAIN_BIT       , SAT_GAIN_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->sat_inc        , SAT_INC_BIT        , SAT_INC_WID);
-    write_cm_reg_bits(SAT_SAT_RANGE_REG00 + reg_off, p->sat_lum_h_slope, SAT_LUM_H_SLOPE_BIT, SAT_LUM_H_SLOPE_WID);
-    write_cm_reg_bits(SAT_SAT_RANGE_REG00 + reg_off, p->sat_lum_l_slope, SAT_LUM_L_SLOPE_BIT, SAT_LUM_L_SLOPE_WID);
-    write_cm_reg_bits(HUE_SAT_RANGE_REG00 + reg_off, p->sat_lum_h      , SAT_LUM_H_BIT      , SAT_LUM_H_WID);
-    write_cm_reg_bits(HUE_LUM_RANGE_REG00 + reg_off, p->sat_lum_l      , SAT_LUM_L_BIT      , SAT_LUM_L_WID);
-    write_cm_reg_bits(SAT_SAT_RANGE_REG00 + reg_off, p->sat_sat_h_slope, SAT_SAT_H_SLOPE_BIT, SAT_SAT_H_SLOPE_WID);
-    write_cm_reg_bits(SAT_SAT_RANGE_REG00 + reg_off, p->sat_sat_l_slope, SAT_SAT_L_SLOPE_BIT, SAT_SAT_L_SLOPE_WID);
-    write_cm_reg_bits(SAT_SAT_RANGE_REG00 + reg_off, p->sat_sat_h      , SAT_SAT_H_BIT      , SAT_SAT_H_WID);
-    write_cm_reg_bits(SAT_SAT_RANGE_REG00 + reg_off, p->sat_sat_l      , SAT_SAT_L_BIT      , SAT_SAT_L_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->hue_en         , HUE_EN_BIT         , HUE_EN_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->hue_central_en , HUE_CENTRAL_EN_BIT , HUE_CENTRAL_EN_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->hue_shape      , HUE_SHAPE_BIT      , HUE_SHAPE_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->hue_gain       , HUE_GAIN_BIT       , HUE_GAIN_WID);
-    write_cm_reg_bits(CHROMA_GAIN_REG00  + reg_off, p->hue_clockwise  , HUE_CLOCKWISE_BIT  , HUE_CLOCKWISE_WID);
-    write_cm_reg_bits(HUE_HUE_RANGE_REG00 + reg_off, p->hue_shf_ran    , HUE_SHF_RAN_BIT    , HUE_SHF_RAN_WID);
-    write_cm_reg_bits(HUE_RANGE_INV_REG00 + reg_off, hue_shf_ran_inv   , HUE_SHF_RAN_INV_BIT, HUE_SHF_RAN_INV_WID);
-    write_cm_reg_bits(HUE_HUE_RANGE_REG00 + reg_off, p->hue_shf_sta    , HUE_SHF_STA_BIT    , HUE_SHF_STA_WID);
-    write_cm_reg_bits(HUE_LUM_RANGE_REG00 + reg_off, p->hue_lum_h_slope, HUE_LUM_H_SLOPE_BIT, HUE_LUM_H_SLOPE_WID);
-    write_cm_reg_bits(HUE_LUM_RANGE_REG00 + reg_off, p->hue_lum_l_slope, HUE_LUM_L_SLOPE_BIT, HUE_LUM_L_SLOPE_WID);
-    write_cm_reg_bits(HUE_LUM_RANGE_REG00 + reg_off, p->hue_lum_h      , HUE_LUM_H_BIT      , HUE_LUM_H_WID);
-    write_cm_reg_bits(HUE_LUM_RANGE_REG00 + reg_off, p->hue_lum_l      , HUE_LUM_L_BIT      , HUE_LUM_L_WID);
-    write_cm_reg_bits(HUE_SAT_RANGE_REG00 + reg_off, p->hue_sat_h_slope, HUE_SAT_H_SLOPE_BIT, HUE_SAT_H_SLOPE_WID);
-    write_cm_reg_bits(HUE_SAT_RANGE_REG00 + reg_off, p->hue_sat_l_slope, HUE_SAT_L_SLOPE_BIT, HUE_SAT_L_SLOPE_WID);
-    write_cm_reg_bits(HUE_SAT_RANGE_REG00 + reg_off, p->hue_sat_h      , HUE_SAT_H_BIT      , HUE_SAT_H_WID);
-    write_cm_reg_bits(HUE_SAT_RANGE_REG00 + reg_off, p->hue_sat_l      , HUE_SAT_L_BIT      , HUE_SAT_L_WID);
-}
-
-void cm_set_top(struct cm_top_s *p)
-{
-    write_cm_reg_bits(REG_CHROMA_CONTROL, p->chroma_en    , CHROMA_EN_BIT    , CHROMA_EN_WID);
-    write_cm_reg_bits(REG_CHROMA_CONTROL, p->sat_sel      , SAT_SEL_BIT      , SAT_SEL_WID);
-    write_cm_reg_bits(REG_CHROMA_CONTROL, p->uv_adj_en    , UV_ADJ_EN_BIT    , UV_ADJ_EN_WID);
-    write_cm_reg_bits(REG_CHROMA_CONTROL, p->rgb_to_hue_en, RGB_TO_HUE_EN_BIT, RGB_TO_HUE_EN_WID);
-    write_cm_reg_bits(REG_CHROMA_CONTROL, p->csc_sel      , CSC_SEL_BIT      , CSC_SEL_WID);
-}
-
-void cm_set_demo(struct cm_demo_s *p)
-{
-    write_cm_reg_bits(REG_CHROMA_CONTROL, p->en        , DEMO_EN_BIT        , DEMO_EN_WID);
-    write_cm_reg_bits(REG_CHROMA_CONTROL, p->pos       , CM_DEMO_POS_BIT    , CM_DEMO_POS_WID);
-    write_cm_reg_bits(REG_CHROMA_CONTROL, p->hlight_adj, DEMO_HLIGHT_ADJ_BIT, DEMO_HLIGHT_ADJ_WID);
-    write_cm_reg_bits(REG_CHROMA_CONTROL, p->wid       , CM_DEMO_WID_BIT       , CM_DEMO_WID_WID);
-}
-
-void cm_set_regs(struct cm_regs_s *p)
-{
-    if (!(p->mode)) { // read
-        switch (p->port) {
-        case 0:    // reserved
-            break;
-        case 1:    // CM port registers
-            p->val = read_cm_reg_bits(p->reg, p->bit, p->wid);
-            break;
-        case 2:    // reserved
-            break;
-        case 3:    // reserved
-            break;
-        default:   // NA
-            break;
-        }
-    } else {           // write
-        switch (p->port) {
-        case 0:    // reserved
-            break;
-        case 1:    // CM port registers
-            write_cm_reg_bits(p->reg, p->val, p->bit, p->wid);
-            break;
-        case 2:    // reserved
-            break;
-        case 3:    // reserved
-            break;
-        default:   // NA
-            break;
-        }
-    }
-}
-
diff --git a/drivers/amlogic/amports/amcm.h b/drivers/amlogic/amports/amcm.h
deleted file mode 100755
index ab5a83f6c1e6..000000000000
--- a/drivers/amlogic/amports/amcm.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Color Management
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef __AM_CM_H
-#define __AM_CM_H
-
-
-#include "linux/amlogic/amports/vframe.h"
-#include "linux/amlogic/amports/cm.h"
-
-typedef struct cm_regs_s {
-    unsigned int val  : 32;
-    unsigned int reg  : 14;
-    unsigned int port :  2; // port port_addr            port_data            remark
-                        // 0    NA                   NA                   direct access
-                        // 1    VPP_CHROMA_ADDR_PORT VPP_CHROMA_DATA_PORT CM port registers
-                        // 2    NA                   NA                   reserved
-                        // 3    NA                   NA                   reserved
-    unsigned int bit  :  5;
-    unsigned int wid  :  5;
-    unsigned int mode :  1; // 0:read, 1:write
-    unsigned int rsv  :  5;
-} cm_regs_t;
-
-
-// ***************************************************************************
-// *** IOCTL-oriented functions *********************************************
-// ***************************************************************************
-
-void cm_set_region(struct cm_region_s *p);
-void cm_set_top(struct cm_top_s *p);
-void cm_set_demo(struct cm_demo_s *p);
-
-void cm_set_regs(struct cm_regs_s *p);
-
-#endif
-
diff --git a/drivers/amlogic/amports/amve.c b/drivers/amlogic/amports/amve.c
deleted file mode 100755
index c5fcd0a45acf..000000000000
--- a/drivers/amlogic/amports/amve.c
+++ /dev/null
@@ -1,370 +0,0 @@
-/*
- * Video Enhancement
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#include <mach/am_regs.h>
-
-#include "linux/amlogic/amports/vframe.h"
-#include "linux/amlogic/amports/ve.h"
-
-#include "ve_regs.h"
-#include "amve.h"
-
-
-static unsigned char ve_dnlp_tgt[64], ve_dnlp_rt;
-static ulong ve_dnlp_lpf[64], ve_dnlp_reg[16];
-
-static ulong ve_benh_inv[32][2] = { // [0]: inv_10_0, [1]: inv_11
-    {2047, 1}, {2047, 1}, {   0, 1}, {1365, 0}, {1024, 0}, { 819, 0}, { 683, 0}, { 585, 0},
-    { 512, 0}, { 455, 0}, { 410, 0}, { 372, 0}, { 341, 0}, { 315, 0}, { 293, 0}, { 273, 0},
-    { 256, 0}, { 241, 0}, { 228, 0}, { 216, 0}, { 205, 0}, { 195, 0}, { 186, 0}, { 178, 0},
-    { 171, 0}, { 164, 0}, { 158, 0}, { 152, 0}, { 146, 0}, { 141, 0}, { 137, 0}, { 132, 0},
-};
-
-static ulong ve_reg_limit(ulong val, ulong wid)
-{
-    if (val < (1 << wid)) {
-        return(val);
-    } else {
-        return((1 << wid) - 1);
-    }
-}
-
-
-// ***************************************************************************
-// *** VPP_FIQ-oriented functions *********************************************
-// ***************************************************************************
-
-static void ve_dnlp_calculate_tgt(vframe_t *vf) // target (starting point) of a new seg is upon the total partition of the previous segs, so:
-// tgt[0] is always 0 & no need calculation
-// tgt[1] is calculated upon gamma[0]
-// tgt[2] is calculated upon gamma[0~1]
-// tgt[3] is calculated upon gamma[0~2]
-// ...
-// tgt[63] is calculated upon gamma[0~62], understood that gamma[63] will never be used
-{
-    struct vframe_prop_s *p = &vf->prop;
-    ulong i = 0, flag = 0, sum = 0, tgt = 0, gain = 8 + 3 + ((p->hist.pixel_sum) >> 30), pixs = (p->hist.pixel_sum) & 0x3fffffff;
-
-    for (i = 1; i < 64; i++) {
-        if (!flag) {
-            sum += p->hist.gamma[i - 1]; // sum of gamma[0] ~ gamma[i-1]
-            tgt = (sum << gain) / pixs; // mapping to total 256 luminance
-            if (tgt < 255) {
-                ve_dnlp_tgt[i] = (unsigned char) tgt;
-            } else {
-                ve_dnlp_tgt[i] = 255;
-                flag = 1;
-            }
-        } else {
-            ve_dnlp_tgt[i] = 255;
-        }
-    }
-}
-
-static void ve_dnlp_calculate_lpf(void) // lpf[0] is always 0 & no need calculation
-{
-    ulong i = 0;
-
-    for (i = 1; i < 64; i++) {
-        ve_dnlp_lpf[i] = ve_dnlp_lpf[i] - (ve_dnlp_lpf[i] >> ve_dnlp_rt) + ve_dnlp_tgt[i];
-    }
-}
-
-static void ve_dnlp_calculate_reg(void)
-{
-    ulong i = 0;
-
-    for (i = 0; i < 16; i++) {
-        ve_dnlp_reg[i]  =  ve_dnlp_lpf[ i << 2   ] >> ve_dnlp_rt     ;
-        ve_dnlp_reg[i] |= (ve_dnlp_lpf[(i << 2) + 1] >> ve_dnlp_rt) << 8;
-        ve_dnlp_reg[i] |= (ve_dnlp_lpf[(i << 2) + 2] >> ve_dnlp_rt) << 16;
-        ve_dnlp_reg[i] |= (ve_dnlp_lpf[(i << 2) + 3] >> ve_dnlp_rt) << 24;
-    }
-}
-
-static void ve_dnlp_load_reg(void)
-{
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_00, ve_dnlp_reg[0]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_01, ve_dnlp_reg[1]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_02, ve_dnlp_reg[2]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_03, ve_dnlp_reg[3]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_04, ve_dnlp_reg[4]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_05, ve_dnlp_reg[5]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_06, ve_dnlp_reg[6]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_07, ve_dnlp_reg[7]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_08, ve_dnlp_reg[8]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_09, ve_dnlp_reg[9]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_10, ve_dnlp_reg[10]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_11, ve_dnlp_reg[11]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_12, ve_dnlp_reg[12]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_13, ve_dnlp_reg[13]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_14, ve_dnlp_reg[14]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_15, ve_dnlp_reg[15]);
-}
-
-void ve_on_vs(vframe_t *vf)
-{
-    if (ve_dnlp_rt == VE_DNLP_RT_FREEZE) {
-        return;
-    }
-    // calculate dnlp target data
-    ve_dnlp_calculate_tgt(vf);
-    // calculate dnlp low-pass-filter data
-    ve_dnlp_calculate_lpf();
-    // calculate dnlp reg data
-    ve_dnlp_calculate_reg();
-    // load dnlp reg data
-    ve_dnlp_load_reg();
-}
-
-
-// ***************************************************************************
-// *** IOCTL-oriented functions *********************************************
-// ***************************************************************************
-
-void ve_set_bext(struct ve_bext_s *p)
-{
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, ve_reg_limit(p->en    , BEXT_EN_WID), BEXT_EN_BIT    , BEXT_EN_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLACKEXT_CTRL , ve_reg_limit(p->start , BEXT_START_WID), BEXT_START_BIT , BEXT_START_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLACKEXT_CTRL , ve_reg_limit(p->slope1, BEXT_SLOPE1_WID), BEXT_SLOPE1_BIT, BEXT_SLOPE1_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLACKEXT_CTRL , ve_reg_limit(p->midpt , BEXT_MIDPT_WID), BEXT_MIDPT_BIT , BEXT_MIDPT_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLACKEXT_CTRL , ve_reg_limit(p->slope2, BEXT_SLOPE2_WID), BEXT_SLOPE2_BIT, BEXT_SLOPE2_WID);
-}
-
-
-
-void ve_set_dnlp(struct ve_dnlp_s *p)
-{
-    ulong i = 0;
-
-    ve_dnlp_rt = p->rt;
-    if (!(p->en)) {
-        ve_dnlp_rt = VE_DNLP_RT_FREEZE;
-    }
-    if (!(ve_dnlp_rt == VE_DNLP_RT_FREEZE)) {
-        for (i = 0; i < 64; i++) {
-            ve_dnlp_lpf[i] = (ulong)(p->gamma[i]) << (ulong)ve_dnlp_rt;
-        }
-    }
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, ve_reg_limit(p->en       , DNLP_EN_WID), DNLP_EN_BIT     , DNLP_EN_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_00  , ve_reg_limit(p->gamma[0],  DNLP_GAMMA00_WID), DNLP_GAMMA00_BIT, DNLP_GAMMA00_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_00  , ve_reg_limit(p->gamma[1],  DNLP_GAMMA01_WID), DNLP_GAMMA01_BIT, DNLP_GAMMA01_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_00  , ve_reg_limit(p->gamma[2],  DNLP_GAMMA02_WID), DNLP_GAMMA02_BIT, DNLP_GAMMA02_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_00  , ve_reg_limit(p->gamma[3],  DNLP_GAMMA03_WID), DNLP_GAMMA03_BIT, DNLP_GAMMA03_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_01  , ve_reg_limit(p->gamma[4],  DNLP_GAMMA04_WID), DNLP_GAMMA04_BIT, DNLP_GAMMA04_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_01  , ve_reg_limit(p->gamma[5],  DNLP_GAMMA05_WID), DNLP_GAMMA05_BIT, DNLP_GAMMA05_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_01  , ve_reg_limit(p->gamma[6],  DNLP_GAMMA06_WID), DNLP_GAMMA06_BIT, DNLP_GAMMA06_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_01  , ve_reg_limit(p->gamma[7],  DNLP_GAMMA07_WID), DNLP_GAMMA07_BIT, DNLP_GAMMA07_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_02  , ve_reg_limit(p->gamma[8],  DNLP_GAMMA08_WID), DNLP_GAMMA08_BIT, DNLP_GAMMA08_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_02  , ve_reg_limit(p->gamma[9],  DNLP_GAMMA09_WID), DNLP_GAMMA09_BIT, DNLP_GAMMA09_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_02  , ve_reg_limit(p->gamma[10], DNLP_GAMMA10_WID), DNLP_GAMMA10_BIT, DNLP_GAMMA10_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_02  , ve_reg_limit(p->gamma[11], DNLP_GAMMA11_WID), DNLP_GAMMA11_BIT, DNLP_GAMMA11_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_03  , ve_reg_limit(p->gamma[12], DNLP_GAMMA12_WID), DNLP_GAMMA12_BIT, DNLP_GAMMA12_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_03  , ve_reg_limit(p->gamma[13], DNLP_GAMMA13_WID), DNLP_GAMMA13_BIT, DNLP_GAMMA13_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_03  , ve_reg_limit(p->gamma[14], DNLP_GAMMA14_WID), DNLP_GAMMA14_BIT, DNLP_GAMMA14_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_03  , ve_reg_limit(p->gamma[15], DNLP_GAMMA15_WID), DNLP_GAMMA15_BIT, DNLP_GAMMA15_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_04  , ve_reg_limit(p->gamma[16], DNLP_GAMMA16_WID), DNLP_GAMMA16_BIT, DNLP_GAMMA16_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_04  , ve_reg_limit(p->gamma[17], DNLP_GAMMA17_WID), DNLP_GAMMA17_BIT, DNLP_GAMMA17_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_04  , ve_reg_limit(p->gamma[18], DNLP_GAMMA18_WID), DNLP_GAMMA18_BIT, DNLP_GAMMA18_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_04  , ve_reg_limit(p->gamma[19], DNLP_GAMMA19_WID), DNLP_GAMMA19_BIT, DNLP_GAMMA19_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_05  , ve_reg_limit(p->gamma[20], DNLP_GAMMA20_WID), DNLP_GAMMA20_BIT, DNLP_GAMMA20_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_05  , ve_reg_limit(p->gamma[21], DNLP_GAMMA21_WID), DNLP_GAMMA21_BIT, DNLP_GAMMA21_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_05  , ve_reg_limit(p->gamma[22], DNLP_GAMMA22_WID), DNLP_GAMMA22_BIT, DNLP_GAMMA22_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_05  , ve_reg_limit(p->gamma[23], DNLP_GAMMA23_WID), DNLP_GAMMA23_BIT, DNLP_GAMMA23_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_06  , ve_reg_limit(p->gamma[24], DNLP_GAMMA24_WID), DNLP_GAMMA24_BIT, DNLP_GAMMA24_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_06  , ve_reg_limit(p->gamma[25], DNLP_GAMMA25_WID), DNLP_GAMMA25_BIT, DNLP_GAMMA25_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_06  , ve_reg_limit(p->gamma[26], DNLP_GAMMA26_WID), DNLP_GAMMA26_BIT, DNLP_GAMMA26_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_06  , ve_reg_limit(p->gamma[27], DNLP_GAMMA27_WID), DNLP_GAMMA27_BIT, DNLP_GAMMA27_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_07  , ve_reg_limit(p->gamma[28], DNLP_GAMMA28_WID), DNLP_GAMMA28_BIT, DNLP_GAMMA28_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_07  , ve_reg_limit(p->gamma[29], DNLP_GAMMA29_WID), DNLP_GAMMA29_BIT, DNLP_GAMMA29_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_07  , ve_reg_limit(p->gamma[30], DNLP_GAMMA30_WID), DNLP_GAMMA30_BIT, DNLP_GAMMA30_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_07  , ve_reg_limit(p->gamma[31], DNLP_GAMMA31_WID), DNLP_GAMMA31_BIT, DNLP_GAMMA31_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_08  , ve_reg_limit(p->gamma[32], DNLP_GAMMA32_WID), DNLP_GAMMA32_BIT, DNLP_GAMMA32_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_08  , ve_reg_limit(p->gamma[33], DNLP_GAMMA33_WID), DNLP_GAMMA33_BIT, DNLP_GAMMA33_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_08  , ve_reg_limit(p->gamma[34], DNLP_GAMMA34_WID), DNLP_GAMMA34_BIT, DNLP_GAMMA34_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_08  , ve_reg_limit(p->gamma[35], DNLP_GAMMA35_WID), DNLP_GAMMA35_BIT, DNLP_GAMMA35_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_09  , ve_reg_limit(p->gamma[36], DNLP_GAMMA36_WID), DNLP_GAMMA36_BIT, DNLP_GAMMA36_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_09  , ve_reg_limit(p->gamma[37], DNLP_GAMMA37_WID), DNLP_GAMMA37_BIT, DNLP_GAMMA37_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_09  , ve_reg_limit(p->gamma[38], DNLP_GAMMA38_WID), DNLP_GAMMA38_BIT, DNLP_GAMMA38_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_09  , ve_reg_limit(p->gamma[39], DNLP_GAMMA39_WID), DNLP_GAMMA39_BIT, DNLP_GAMMA39_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_10  , ve_reg_limit(p->gamma[40], DNLP_GAMMA40_WID), DNLP_GAMMA40_BIT, DNLP_GAMMA40_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_10  , ve_reg_limit(p->gamma[41], DNLP_GAMMA41_WID), DNLP_GAMMA41_BIT, DNLP_GAMMA41_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_10  , ve_reg_limit(p->gamma[42], DNLP_GAMMA42_WID), DNLP_GAMMA42_BIT, DNLP_GAMMA42_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_10  , ve_reg_limit(p->gamma[43], DNLP_GAMMA43_WID), DNLP_GAMMA43_BIT, DNLP_GAMMA43_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_11  , ve_reg_limit(p->gamma[44], DNLP_GAMMA44_WID), DNLP_GAMMA44_BIT, DNLP_GAMMA44_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_11  , ve_reg_limit(p->gamma[45], DNLP_GAMMA45_WID), DNLP_GAMMA45_BIT, DNLP_GAMMA45_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_11  , ve_reg_limit(p->gamma[46], DNLP_GAMMA46_WID), DNLP_GAMMA46_BIT, DNLP_GAMMA46_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_11  , ve_reg_limit(p->gamma[47], DNLP_GAMMA47_WID), DNLP_GAMMA47_BIT, DNLP_GAMMA47_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_12  , ve_reg_limit(p->gamma[48], DNLP_GAMMA48_WID), DNLP_GAMMA48_BIT, DNLP_GAMMA48_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_12  , ve_reg_limit(p->gamma[49], DNLP_GAMMA49_WID), DNLP_GAMMA49_BIT, DNLP_GAMMA49_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_12  , ve_reg_limit(p->gamma[50], DNLP_GAMMA50_WID), DNLP_GAMMA50_BIT, DNLP_GAMMA50_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_12  , ve_reg_limit(p->gamma[51], DNLP_GAMMA51_WID), DNLP_GAMMA51_BIT, DNLP_GAMMA51_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_13  , ve_reg_limit(p->gamma[52], DNLP_GAMMA52_WID), DNLP_GAMMA52_BIT, DNLP_GAMMA52_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_13  , ve_reg_limit(p->gamma[53], DNLP_GAMMA53_WID), DNLP_GAMMA53_BIT, DNLP_GAMMA53_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_13  , ve_reg_limit(p->gamma[54], DNLP_GAMMA54_WID), DNLP_GAMMA54_BIT, DNLP_GAMMA54_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_13  , ve_reg_limit(p->gamma[55], DNLP_GAMMA55_WID), DNLP_GAMMA55_BIT, DNLP_GAMMA55_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_14  , ve_reg_limit(p->gamma[56], DNLP_GAMMA56_WID), DNLP_GAMMA56_BIT, DNLP_GAMMA56_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_14  , ve_reg_limit(p->gamma[57], DNLP_GAMMA57_WID), DNLP_GAMMA57_BIT, DNLP_GAMMA57_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_14  , ve_reg_limit(p->gamma[58], DNLP_GAMMA58_WID), DNLP_GAMMA58_BIT, DNLP_GAMMA58_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_14  , ve_reg_limit(p->gamma[59], DNLP_GAMMA59_WID), DNLP_GAMMA59_BIT, DNLP_GAMMA59_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_15  , ve_reg_limit(p->gamma[60], DNLP_GAMMA60_WID), DNLP_GAMMA60_BIT, DNLP_GAMMA60_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_15  , ve_reg_limit(p->gamma[61], DNLP_GAMMA61_WID), DNLP_GAMMA61_BIT, DNLP_GAMMA61_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_15  , ve_reg_limit(p->gamma[62], DNLP_GAMMA62_WID), DNLP_GAMMA62_BIT, DNLP_GAMMA62_WID);
-    WRITE_CBUS_REG_BITS(VPP_DNLP_CTRL_15  , ve_reg_limit(p->gamma[63], DNLP_GAMMA63_WID), DNLP_GAMMA63_BIT, DNLP_GAMMA63_WID);
-}
-
-
-void ve_set_hsvs(struct ve_hsvs_s *p)
-{
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, ve_reg_limit(p->en                , HSVS_EN_WID), HSVS_EN_BIT           , HSVS_EN_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_HGAIN , ve_reg_limit(p->peak_gain_h1      , PEAK_GAIN_H1_WID), PEAK_GAIN_H1_BIT      , PEAK_GAIN_H1_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_HGAIN , ve_reg_limit(p->peak_gain_h2      , PEAK_GAIN_H2_WID), PEAK_GAIN_H2_BIT      , PEAK_GAIN_H2_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_HGAIN , ve_reg_limit(p->peak_gain_h3      , PEAK_GAIN_H3_WID), PEAK_GAIN_H3_BIT      , PEAK_GAIN_H3_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_HGAIN , ve_reg_limit(p->peak_gain_h4      , PEAK_GAIN_H4_WID), PEAK_GAIN_H4_BIT      , PEAK_GAIN_H4_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_HGAIN , ve_reg_limit(p->peak_gain_h5      , PEAK_GAIN_H5_WID), PEAK_GAIN_H5_BIT      , PEAK_GAIN_H5_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_VGAIN , ve_reg_limit(p->peak_gain_v1      , PEAK_GAIN_V1_WID), PEAK_GAIN_V1_BIT      , PEAK_GAIN_V1_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_VGAIN , ve_reg_limit(p->peak_gain_v2      , PEAK_GAIN_V2_WID), PEAK_GAIN_V2_BIT      , PEAK_GAIN_V2_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_VGAIN , ve_reg_limit(p->peak_gain_v3      , PEAK_GAIN_V3_WID), PEAK_GAIN_V3_BIT      , PEAK_GAIN_V3_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_VGAIN , ve_reg_limit(p->peak_gain_v4      , PEAK_GAIN_V4_WID), PEAK_GAIN_V4_BIT      , PEAK_GAIN_V4_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_VGAIN , ve_reg_limit(p->peak_gain_v5      , PEAK_GAIN_V5_WID), PEAK_GAIN_V5_BIT      , PEAK_GAIN_V5_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_VGAIN , ve_reg_limit(p->peak_gain_v6      , PEAK_GAIN_V6_WID), PEAK_GAIN_V6_BIT      , PEAK_GAIN_V6_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_1 , ve_reg_limit(p->hpeak_slope1      , HPEAK_SLOPE1_WID), HPEAK_SLOPE1_BIT      , HPEAK_SLOPE1_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_1 , ve_reg_limit(p->hpeak_slope2      , HPEAK_SLOPE2_WID), HPEAK_SLOPE2_BIT      , HPEAK_SLOPE2_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_1 , ve_reg_limit(p->hpeak_thr1        , HPEAK_THR1_WID), HPEAK_THR1_BIT        , HPEAK_THR1_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_2 , ve_reg_limit(p->hpeak_thr2        , HPEAK_THR2_WID), HPEAK_THR2_BIT        , HPEAK_THR2_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_2 , ve_reg_limit(p->hpeak_nlp_cor_thr , HPEAK_NLP_COR_THR_WID), HPEAK_NLP_COR_THR_BIT , HPEAK_NLP_COR_THR_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_2 , ve_reg_limit(p->hpeak_nlp_gain_pos, HPEAK_NLP_GAIN_POS_WID), HPEAK_NLP_GAIN_POS_BIT, HPEAK_NLP_GAIN_POS_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_2 , ve_reg_limit(p->hpeak_nlp_gain_neg, HPEAK_NLP_GAIN_NEG_WID), HPEAK_NLP_GAIN_NEG_BIT, HPEAK_NLP_GAIN_NEG_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_1 , ve_reg_limit(p->vpeak_slope1      , VPEAK_SLOPE1_WID), VPEAK_SLOPE1_BIT      , VPEAK_SLOPE1_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_1 , ve_reg_limit(p->vpeak_slope2      , VPEAK_SLOPE2_WID), VPEAK_SLOPE2_BIT      , VPEAK_SLOPE2_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_3 , ve_reg_limit(p->vpeak_thr1        , VPEAK_THR1_WID), VPEAK_THR1_BIT        , VPEAK_THR1_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_4 , ve_reg_limit(p->vpeak_thr2        , VPEAK_THR2_WID), VPEAK_THR2_BIT        , VPEAK_THR2_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_4 , ve_reg_limit(p->vpeak_nlp_cor_thr , VPEAK_NLP_COR_THR_WID), VPEAK_NLP_COR_THR_BIT , VPEAK_NLP_COR_THR_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_4 , ve_reg_limit(p->vpeak_nlp_gain_pos, VPEAK_NLP_GAIN_POS_WID), VPEAK_NLP_GAIN_POS_BIT, VPEAK_NLP_GAIN_POS_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_4 , ve_reg_limit(p->vpeak_nlp_gain_neg, VPEAK_NLP_GAIN_NEG_WID), VPEAK_NLP_GAIN_NEG_BIT, VPEAK_NLP_GAIN_NEG_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_3 , ve_reg_limit(p->speak_slope1      , SPEAK_SLOPE1_WID), SPEAK_SLOPE1_BIT      , SPEAK_SLOPE1_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_3 , ve_reg_limit(p->speak_slope2      , SPEAK_SLOPE2_WID), SPEAK_SLOPE2_BIT      , SPEAK_SLOPE2_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_3 , ve_reg_limit(p->speak_thr1        , SPEAK_THR1_WID), SPEAK_THR1_BIT        , SPEAK_THR1_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_5 , ve_reg_limit(p->speak_thr2        , SPEAK_THR2_WID), SPEAK_THR2_BIT        , SPEAK_THR2_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_5 , ve_reg_limit(p->speak_nlp_cor_thr , SPEAK_NLP_COR_THR_WID), SPEAK_NLP_COR_THR_BIT , SPEAK_NLP_COR_THR_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_5 , ve_reg_limit(p->speak_nlp_gain_pos, SPEAK_NLP_GAIN_POS_WID), SPEAK_NLP_GAIN_POS_BIT, SPEAK_NLP_GAIN_POS_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_5 , ve_reg_limit(p->speak_nlp_gain_neg, SPEAK_NLP_GAIN_NEG_WID), SPEAK_NLP_GAIN_NEG_BIT, SPEAK_NLP_GAIN_NEG_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_NLP_3 , ve_reg_limit(p->peak_cor_gain     , PEAK_COR_GAIN_WID), PEAK_COR_GAIN_BIT     , PEAK_COR_GAIN_WID);
-    WRITE_CBUS_REG_BITS(VPP_SHARP_LIMIT    , ve_reg_limit(p->peak_cor_thr_l   , PEAK_COR_THR_L_WID), PEAK_COR_THR_L_BIT    , PEAK_COR_THR_L_WID);
-    WRITE_CBUS_REG_BITS(VPP_SHARP_LIMIT    , ve_reg_limit(p->peak_cor_thr_h   , PEAK_COR_THR_H_WID), PEAK_COR_THR_H_BIT    , PEAK_COR_THR_H_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_HGAIN , ve_reg_limit(p->vlti_step         , VLTI_STEP_WID), VLTI_STEP_BIT         , VLTI_STEP_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_HGAIN , ve_reg_limit(p->vlti_step2        , VLTI_STEP2_WID), VLTI_STEP2_BIT        , VLTI_STEP2_WID);
-    WRITE_CBUS_REG_BITS(VPP_VLTI_CTRL     , ve_reg_limit(p->vlti_thr          , VLTI_THR_WID), VLTI_THR_BIT          , VLTI_THR_WID);
-    WRITE_CBUS_REG_BITS(VPP_VLTI_CTRL     , ve_reg_limit(p->vlti_gain_pos     , VLTI_GAIN_POS_WID), VLTI_GAIN_POS_BIT     , VLTI_GAIN_POS_WID);
-    WRITE_CBUS_REG_BITS(VPP_VLTI_CTRL     , ve_reg_limit(p->vlti_gain_neg     , VLTI_GAIN_NEG_WID), VLTI_GAIN_NEG_BIT     , VLTI_GAIN_NEG_WID);
-    WRITE_CBUS_REG_BITS(VPP_VLTI_CTRL     , ve_reg_limit(p->vlti_blend_factor , VLTI_BLEND_FACTOR_WID), VLTI_BLEND_FACTOR_BIT , VLTI_BLEND_FACTOR_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_HGAIN , ve_reg_limit(p->hlti_step         , HLTI_STEP_WID), HLTI_STEP_BIT         , HLTI_STEP_WID);
-    WRITE_CBUS_REG_BITS(VPP_HLTI_CTRL     , ve_reg_limit(p->hlti_thr          , HLTI_THR_WID), HLTI_THR_BIT          , HLTI_THR_WID);
-    WRITE_CBUS_REG_BITS(VPP_HLTI_CTRL     , ve_reg_limit(p->hlti_gain_pos     , HLTI_GAIN_POS_WID), HLTI_GAIN_POS_BIT     , HLTI_GAIN_POS_WID);
-    WRITE_CBUS_REG_BITS(VPP_HLTI_CTRL     , ve_reg_limit(p->hlti_gain_neg     , HLTI_GAIN_NEG_WID), HLTI_GAIN_NEG_BIT     , HLTI_GAIN_NEG_WID);
-    WRITE_CBUS_REG_BITS(VPP_HLTI_CTRL     , ve_reg_limit(p->hlti_blend_factor , HLTI_BLEND_FACTOR_WID), HLTI_BLEND_FACTOR_BIT , HLTI_BLEND_FACTOR_WID);
-    WRITE_CBUS_REG_BITS(VPP_SHARP_LIMIT    , ve_reg_limit(p->vlimit_coef_h    , VLIMIT_COEF_H_WID), VLIMIT_COEF_H_BIT     , VLIMIT_COEF_H_WID);
-    WRITE_CBUS_REG_BITS(VPP_SHARP_LIMIT    , ve_reg_limit(p->vlimit_coef_l    , VLIMIT_COEF_L_WID), VLIMIT_COEF_L_BIT     , VLIMIT_COEF_L_WID);
-    WRITE_CBUS_REG_BITS(VPP_SHARP_LIMIT    , ve_reg_limit(p->hlimit_coef_h    , HLIMIT_COEF_H_WID), HLIMIT_COEF_H_BIT     , HLIMIT_COEF_H_WID);
-    WRITE_CBUS_REG_BITS(VPP_SHARP_LIMIT    , ve_reg_limit(p->hlimit_coef_l    , HLIMIT_COEF_L_WID), HLIMIT_COEF_L_BIT     , HLIMIT_COEF_L_WID);
-    WRITE_CBUS_REG_BITS(VPP_CTI_CTRL      , ve_reg_limit(p->cti_444_422_en    , CTI_C444TO422_EN_WID), CTI_C444TO422_EN_BIT  , CTI_C444TO422_EN_WID);
-    WRITE_CBUS_REG_BITS(VPP_CTI_CTRL      , ve_reg_limit(p->cti_422_444_en    , CTI_C422TO444_EN_WID), CTI_C422TO444_EN_BIT  , CTI_C422TO444_EN_WID);
-    WRITE_CBUS_REG_BITS(VPP_CTI_CTRL      , ve_reg_limit(p->cti_blend_factor  , CTI_BLEND_FACTOR_WID), CTI_BLEND_FACTOR_BIT  , CTI_BLEND_FACTOR_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_VGAIN , ve_reg_limit(p->vcti_buf_en       , VCTI_BUF_EN_WID), VCTI_BUF_EN_BIT       , VCTI_BUF_EN_WID);
-    WRITE_CBUS_REG_BITS(VPP_PEAKING_VGAIN , ve_reg_limit(p->vcti_buf_mode_c5l , VCTI_BUF_MODE_C5L_WID), VCTI_BUF_MODE_C5L_BIT , VCTI_BUF_MODE_C5L_WID);
-    WRITE_CBUS_REG_BITS(VPP_CTI_CTRL      , ve_reg_limit(p->vcti_filter       , VCTI_FILTER_WID), VCTI_FILTER_BIT       , VCTI_FILTER_WID);
-    WRITE_CBUS_REG_BITS(VPP_CTI_CTRL      , ve_reg_limit(p->hcti_step         , HCTI_STEP_WID), HCTI_STEP_BIT         , HCTI_STEP_WID);
-    WRITE_CBUS_REG_BITS(VPP_CTI_CTRL      , ve_reg_limit(p->hcti_step2        , HCTI_STEP2_WID), HCTI_STEP2_BIT        , HCTI_STEP2_WID);
-    WRITE_CBUS_REG_BITS(VPP_CTI_CTRL      , ve_reg_limit(p->hcti_thr          , HCTI_THR_WID), HCTI_THR_BIT          , HCTI_THR_WID);
-    WRITE_CBUS_REG_BITS(VPP_CTI_CTRL      , ve_reg_limit(p->hcti_gain         , HCTI_GAIN_WID), HCTI_GAIN_BIT         , HCTI_GAIN_WID);
-    WRITE_CBUS_REG_BITS(VPP_CTI_CTRL      , ve_reg_limit(p->hcti_mode_median  , HCTI_MODE_MEDIAN_WID), HCTI_MODE_MEDIAN_BIT  , HCTI_MODE_MEDIAN_WID);
-}
-
-
-void ve_set_ccor(struct ve_ccor_s *p)
-{
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, ve_reg_limit(p->en   , CCOR_EN_WID), CCOR_EN_BIT   , CCOR_EN_WID);
-    WRITE_CBUS_REG_BITS(VPP_CCORING_CTRL  , ve_reg_limit(p->slope, CCOR_SLOPE_WID), CCOR_SLOPE_BIT, CCOR_SLOPE_WID);
-    WRITE_CBUS_REG_BITS(VPP_CCORING_CTRL  , ve_reg_limit(p->thr  , CCOR_THR_WID), CCOR_THR_BIT  , CCOR_THR_WID);
-}
-
-
-void ve_set_benh(struct ve_benh_s *p)
-{
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, ve_reg_limit(p->en                 , BENH_EN_WID)         , BENH_EN_BIT           , BENH_EN_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_1, ve_reg_limit(p->cb_inc             , BENH_CB_INC_WID)     , BENH_CB_INC_BIT       , BENH_CB_INC_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_1, ve_reg_limit(p->cr_inc             , BENH_CR_INC_WID)     , BENH_CR_INC_BIT       , BENH_CR_INC_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_1, ve_reg_limit(p->gain_cr            , BENH_GAIN_CR_WID)    , BENH_GAIN_CR_BIT      , BENH_GAIN_CR_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_1, ve_reg_limit(p->gain_cb4cr         , BENH_GAIN_CB4CR_WID) , BENH_GAIN_CB4CR_BIT   , BENH_GAIN_CB4CR_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_1, ve_reg_limit(p->luma_h             , BENH_LUMA_H_WID)     , BENH_LUMA_H_BIT       , BENH_LUMA_H_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_2, ve_reg_limit(p->err_crp            , BENH_ERR_CRP_WID)    , BENH_ERR_CRP_BIT      , BENH_ERR_CRP_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_2, ve_reg_limit(p->err_crn            , BENH_ERR_CRN_WID)    , BENH_ERR_CRN_BIT      , BENH_ERR_CRN_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_3, ve_reg_limit(p->err_cbp            , BENH_ERR_CBP_WID)    , BENH_ERR_CBP_BIT      , BENH_ERR_CBP_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_3, ve_reg_limit(p->err_cbn            , BENH_ERR_CBN_WID)    , BENH_ERR_CBN_BIT      , BENH_ERR_CBN_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_1, ve_benh_inv[ve_reg_limit(p->err_crp, BENH_ERR_CRP_WID)][1], BENH_ERR_CRP_INV_H_BIT, BENH_ERR_CRP_INV_H_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_1, ve_benh_inv[ve_reg_limit(p->err_crn, BENH_ERR_CRN_WID)][1], BENH_ERR_CRN_INV_H_BIT, BENH_ERR_CRN_INV_H_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_1, ve_benh_inv[ve_reg_limit(p->err_cbp, BENH_ERR_CBP_WID)][1], BENH_ERR_CBP_INV_H_BIT, BENH_ERR_CBP_INV_H_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_1, ve_benh_inv[ve_reg_limit(p->err_cbn, BENH_ERR_CBN_WID)][1], BENH_ERR_CBN_INV_H_BIT, BENH_ERR_CBN_INV_H_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_2, ve_benh_inv[ve_reg_limit(p->err_crp, BENH_ERR_CRP_WID)][0], BENH_ERR_CRP_INV_L_BIT, BENH_ERR_CRP_INV_L_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_2, ve_benh_inv[ve_reg_limit(p->err_crn, BENH_ERR_CRN_WID)][0], BENH_ERR_CRN_INV_L_BIT, BENH_ERR_CRN_INV_L_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_3, ve_benh_inv[ve_reg_limit(p->err_cbp, BENH_ERR_CBP_WID)][0], BENH_ERR_CBP_INV_L_BIT, BENH_ERR_CBP_INV_L_WID);
-    WRITE_CBUS_REG_BITS(VPP_BLUE_STRETCH_3, ve_benh_inv[ve_reg_limit(p->err_cbn, BENH_ERR_CBN_WID)][0], BENH_ERR_CBN_INV_L_BIT, BENH_ERR_CBN_INV_L_WID);
-}
-
-
-void ve_set_demo(struct ve_demo_s *p)
-{
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL           , ve_reg_limit(p->bext, DEMO_BEXT_WID), DEMO_BEXT_BIT, DEMO_BEXT_WID);
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL           , ve_reg_limit(p->dnlp, DEMO_DNLP_WID), DEMO_DNLP_BIT, DEMO_DNLP_WID);
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL           , ve_reg_limit(p->hsvs, DEMO_HSVS_WID), DEMO_HSVS_BIT, DEMO_HSVS_WID);
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL           , ve_reg_limit(p->ccor, DEMO_CCOR_WID), DEMO_CCOR_BIT, DEMO_CCOR_WID);
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL           , ve_reg_limit(p->benh, DEMO_BENH_WID), DEMO_BENH_BIT, DEMO_BENH_WID);
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL           , ve_reg_limit(p->pos , VE_DEMO_POS_WID), VE_DEMO_POS_BIT, VE_DEMO_POS_WID);
-    WRITE_CBUS_REG_BITS(VPP_VE_DEMO_LEFT_SCREEN_WIDTH, ve_reg_limit(p->wid , DEMO_WID_WID), DEMO_WID_BIT , DEMO_WID_WID);
-}
-
-
-void ve_set_regs(struct ve_regs_s *p)
-{
-    if (!(p->mode)) { // read
-        switch (p->port) {
-        case 0:    // direct access
-            p->val = READ_CBUS_REG_BITS(p->reg, p->bit, p->wid);
-            break;
-        case 1:    // reserved
-            break;
-        case 2:    // reserved
-            break;
-        case 3:    // reserved
-            break;
-        default:   // NA
-            break;
-        }
-    } else {           // write
-        switch (p->port) {
-        case 0:    // direct access
-            WRITE_CBUS_REG_BITS(p->reg, ve_reg_limit(p->val, p->wid), p->bit, p->wid);
-            break;
-        case 1:    // reserved
-            break;
-        case 2:    // reserved
-            break;
-        case 3:    // reserved
-            break;
-        default:   // NA
-            break;
-        }
-    }
-}
-
diff --git a/drivers/amlogic/amports/amve.h b/drivers/amlogic/amports/amve.h
deleted file mode 100755
index 1c706ec743ce..000000000000
--- a/drivers/amlogic/amports/amve.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Video Enhancement
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef __AM_VE_H
-#define __AM_VE_H
-
-#include "linux/amlogic/amports/vframe.h"
-#include "linux/amlogic/amports/ve.h"
-
-typedef struct ve_regs_s {
-    unsigned int val  : 32;
-    unsigned int reg  : 14;
-    unsigned int port :  2; // port port_addr            port_data            remark
-                        // 0    NA                   NA                   direct access
-                        // 1    VPP_CHROMA_ADDR_PORT VPP_CHROMA_DATA_PORT CM port registers
-                        // 2    NA                   NA                   reserved
-                        // 3    NA                   NA                   reserved
-    unsigned int bit  :  5;
-    unsigned int wid  :  5;
-    unsigned int mode :  1; // 0:read, 1:write
-    unsigned int rsv  :  5;
-} ve_regs_t;
-
-
-void ve_on_vs(vframe_t *vf);
-
-void ve_set_bext(struct ve_bext_s *p);
-void ve_set_dnlp(struct ve_dnlp_s *p);
-void ve_set_hsvs(struct ve_hsvs_s *p);
-void ve_set_ccor(struct ve_ccor_s *p);
-void ve_set_benh(struct ve_benh_s *p);
-void ve_set_demo(struct ve_demo_s *p);
-void ve_set_regs(struct ve_regs_s *p);
-
-#endif
-
diff --git a/drivers/amlogic/amports/video.c b/drivers/amlogic/amports/video.c
index 408fd47cd3b2..98e542349525 100755
--- a/drivers/amlogic/amports/video.c
+++ b/drivers/amlogic/amports/video.c
@@ -79,14 +79,8 @@ MODULE_AMLOG(LOG_LEVEL_ERROR, 0, LOG_DEFAULT_LEVEL_DESC, LOG_MASK_DESC);
 
 #include "video.h"
 #include "vpp.h"
-
-#include "linux/amlogic/amports/ve.h"
-#include "linux/amlogic/amports/cm.h"
 #include "linux/amlogic/tvin/tvin_v4l2.h"
-#include "ve_regs.h"
-#include "amve.h"
-#include "cm_regs.h"
-#include "amcm.h"
+
 #include <linux/amlogic/amports/video_prot.h>
 #ifdef CONFIG_GE2D_KEEP_FRAME
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
@@ -4441,144 +4435,6 @@ static long amvideo_ioctl(struct file *file,
         vsync_slow_factor = arg;
         break;
 
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6
-    /**********************************************************************
-    video enhancement ioctl
-    **********************************************************************/
-    case AMSTREAM_IOC_VE_DEBUG: {
-        struct ve_regs_s data;
-#if 0
-        if (get_user((unsigned long long)data, (void __user *)arg))
-#else
-        if (copy_from_user(&data, (void __user *)arg, sizeof(struct ve_regs_s)))
-#endif
-        {
-            ret = -EFAULT;
-        } else {
-            ve_set_regs(&data);
-            if (!(data.mode)) { // read
-#if 0
-                if (put_user((unsigned long long)data, (void __user *)arg))
-#else
-                if (copy_to_user(&data, (void __user *)arg, sizeof(struct ve_regs_s)))
-#endif
-                {
-                    ret = -EFAULT;
-                }
-            }
-        }
-
-        break;
-    }
-    case AMSTREAM_IOC_VE_BEXT: {
-        struct ve_bext_s ve_bext;
-        if (copy_from_user(&ve_bext, (void __user *)arg, sizeof(struct ve_bext_s))) {
-            ret = -EFAULT;
-            break;
-        }
-        ve_set_bext(&ve_bext);
-        break;
-    }
-
-    case AMSTREAM_IOC_VE_DNLP: {
-        struct ve_dnlp_s ve_dnlp;
-        if (copy_from_user(&ve_dnlp, (void __user *)arg, sizeof(struct ve_dnlp_s))) {
-            ret = -EFAULT;
-            break;
-        }
-        ve_set_dnlp(&ve_dnlp);
-        break;
-    }
-
-    case AMSTREAM_IOC_VE_HSVS: {
-        struct ve_hsvs_s ve_hsvs;
-        if (copy_from_user(&ve_hsvs, (void __user *)arg, sizeof(struct ve_hsvs_s))) {
-            ret = -EFAULT;
-            break;
-        }
-        ve_set_hsvs(&ve_hsvs);
-        break;
-    }
-
-    case AMSTREAM_IOC_VE_CCOR: {
-        struct ve_ccor_s ve_ccor;
-        if (copy_from_user(&ve_ccor, (void __user *)arg, sizeof(struct ve_ccor_s))) {
-            ret = -EFAULT;
-            break;
-        }
-        ve_set_ccor(&ve_ccor);
-        break;
-    }
-
-    case AMSTREAM_IOC_VE_BENH: {
-        struct ve_benh_s ve_benh;
-        if (copy_from_user(&ve_benh, (void __user *)arg, sizeof(struct ve_benh_s))) {
-            ret = -EFAULT;
-            break;
-        }
-        ve_set_benh(&ve_benh);
-        break;
-    }
-
-    case AMSTREAM_IOC_VE_DEMO: {
-        struct ve_demo_s ve_demo;
-        if (copy_from_user(&ve_demo, (void __user *)arg, sizeof(struct ve_demo_s))) {
-            ret = -EFAULT;
-            break;
-        }
-        ve_set_demo(&ve_demo);
-        break;
-    }
-
-    /**********************************************************************
-    color management ioctl
-    **********************************************************************/
-    case AMSTREAM_IOC_CM_DEBUG: {
-        struct cm_regs_s data;
-        if (copy_from_user(&data, (void __user *)arg, sizeof(struct cm_regs_s))) {
-            ret = -EFAULT;
-        } else {
-            cm_set_regs(&data);
-            if (!(data.mode)) { // read
-                if (copy_to_user(&data, (void __user *)arg, sizeof(struct cm_regs_s))) {
-                    ret = -EFAULT;
-                }
-            }
-        }
-        break;
-    }
-
-    case AMSTREAM_IOC_CM_REGION: {
-        struct cm_region_s cm_region;
-        if (copy_from_user(&cm_region, (void __user *)arg, sizeof(struct cm_region_s))) {
-            ret = -EFAULT;
-            break;
-        }
-        cm_set_region(&cm_region);
-        break;
-    }
-
-    case AMSTREAM_IOC_CM_TOP: {
-        struct cm_top_s cm_top;
-        if (copy_from_user(&cm_top, (void __user *)arg, sizeof(struct cm_top_s))) {
-            ret = -EFAULT;
-            break;
-        }
-        cm_set_top(&cm_top);
-        break;
-    }
-
-    case AMSTREAM_IOC_CM_DEMO: {
-        struct cm_demo_s cm_demo;
-        if (copy_from_user(&cm_demo, (void __user *)arg, sizeof(struct cm_demo_s))) {
-            ret = -EFAULT;
-            break;
-        }
-        cm_set_demo(&cm_demo);
-        break;
-    }
-#endif
-
     default:
         return -EINVAL;
     }
diff --git a/drivers/amlogic/amvecm/amcm.c b/drivers/amlogic/amvecm/amcm.c
index 45acbc43f9b5..11be4073c011 100755
--- a/drivers/amlogic/amvecm/amcm.c
+++ b/drivers/amlogic/amvecm/amcm.c
@@ -17,258 +17,348 @@
 #include <linux/amlogic/cm.h>
 #include <linux/amlogic/aml_common.h>
 #include <linux/amlogic/vframe.h>
+#include <linux/amlogic/amvecm.h>
+#include <asm/uaccess.h>
 #include "cm_regs.h"
 #include "amcm.h"
+#include "amcm_regmap.h"
+
+#define pr_amcm_dbg(fmt, args...)\
+	do{\
+		if(debug_amcm)\
+			printk("AMCM: " fmt, ## args);\
+	}while(0)
+
+static bool debug_amcm = 0;
+module_param(debug_amcm, bool, 0664);
+MODULE_PARM_DESC(debug_amcm, "\n debug_amcm \n");
+
+static bool debug_regload = 0;
+module_param(debug_regload, bool, 0664);
+MODULE_PARM_DESC(debug_regload, "\n debug_regload \n");
+
+static int cm_level = 1;//0:optimize;1:enhancement
+module_param(cm_level, int, 0664);
+MODULE_PARM_DESC(cm_level, "\n selcet cm lever \n");
+
+int cm_en = 1;//0:disabel;1:enable
+module_param(cm_en, int, 0664);
+MODULE_PARM_DESC(cm_en, "\n enable or disable cm \n");
 
 #if 0
 struct cm_region_s cm_region;
 struct cm_top_s    cm_top;
 struct cm_demo_s   cm_demo;
 #endif
-
+static int cm_level_last = 0xff;//0:optimize;1:enhancement
 unsigned int cm2_patch_flag = 0;
+unsigned int cm_size;
+static struct am_regs_s amregs0;
+static struct am_regs_s amregs1;
+static struct am_regs_s amregs2;
+static struct am_regs_s amregs3;
+static struct am_regs_s amregs4;
+static struct am_regs_s amregs5;
 
-#ifdef AMVIDEO_REG_TABLE_DYNAMIC
-void am_set_regmap(unsigned int cnt, struct am_reg_s *p)
-{
-    unsigned short i;
-    unsigned int temp = 0;
+extern unsigned int vecm_latch_flag;
 
-    for (i=0; i<cnt; i++) {
-        switch (p->type)
-        {
-            case REG_TYPE_PHY:
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: bus type: phy..............\n", __func__);
-                #endif
-            break;
-            case REG_TYPE_CBUS:
-                if (p->mask == 0xffffffff)
-                    WRITE_CBUS_REG(p->addr, p->val);
-                else
-                    WRITE_CBUS_REG(p->addr, (READ_CBUS_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: cbus: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
-                #endif
-            break;
-            case REG_TYPE_APB:
-                if (p->mask == 0xffffffff)
-                    WRITE_APB_REG(p->addr, p->val);
-                else
-                    WRITE_APB_REG(p->addr, (READ_APB_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: apb bus: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
-                #endif
-            break;
-            case REG_TYPE_MPEG:
-                if (p->mask == 0xffffffff)
-                    WRITE_MPEG_REG(p->addr, p->val);
-                else
-                    WRITE_MPEG_REG(p->addr, (READ_MPEG_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: mpeg: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
-                #endif
-            break;
-            case REG_TYPE_AXI:
-                if (p->mask == 0xffffffff)
-                    WRITE_AXI_REG(p->addr, p->val);
-                else
-                    WRITE_AXI_REG(p->addr, (READ_AXI_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: axi: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
-                #endif
-            break;
-            case REG_TYPE_AHB:
-                if (p->mask == 0xffffffff)
-                    WRITE_AHB_REG(p->addr, p->val);
-                else
-                    WRITE_AHB_REG(p->addr, (READ_AHB_REG(p->addr) & (~p->mask)) | (p->val & p->mask));
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: ahb: Reg0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
-                #endif
-            break;
-            case REG_TYPE_INDEX_VPPCHROMA:
-                WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->addr);
-                if (p->mask == 0xffffffff)
-                {
-                    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->val);
-                }
-                else
-                {
-                    temp = READ_CBUS_REG(VPP_CHROMA_DATA_PORT);
-                    WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->addr);
-                    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, (temp & (~p->mask)) | (p->val & p->mask));
-                }
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: vppchroma: 0x1d70:port0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
-                #endif
-            break;
-            case REG_TYPE_INDEX_GAMMA:
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: bus type: REG_TYPE_INDEX_GAMMA..............\n", __func__);
-                #endif
-            break;
-            case VALUE_TYPE_CONTRAST_BRIGHTNESS:
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: bus type: VALUE_TYPE_CONTRAST_BRIGHTNESS..............\n", __func__);
-                #endif
-            break;
-            case REG_TYPE_INDEX_VPP_COEF:
-		    	if (((p->addr&0xf) == 0)||((p->addr&0xf) == 0x8))
-		    		{
-		            WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->addr);
-					WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->val);
-		    		}
+void am_set_regmap(struct am_regs_s *p)
+{
+	unsigned short i;
+	unsigned int temp = 0;
+	for (i=0; i<p->length; i++) {
+		switch (p->am_reg[i].type){
+		case REG_TYPE_PHY:
+			break;
+		case REG_TYPE_CBUS:
+			if (p->am_reg[i].mask == 0xffffffff)
+				WRITE_CBUS_REG(p->am_reg[i].addr, p->am_reg[i].val);
+			else
+				WRITE_CBUS_REG(p->am_reg[i].addr, (READ_CBUS_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+			break;
+		case REG_TYPE_APB:
+			if (p->am_reg[i].mask == 0xffffffff)
+				WRITE_APB_REG(p->am_reg[i].addr, p->am_reg[i].val);
+			else
+				WRITE_APB_REG(p->am_reg[i].addr, (READ_APB_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+			break;
+		case REG_TYPE_MPEG:
+			if (p->am_reg[i].mask == 0xffffffff)
+				WRITE_MPEG_REG(p->am_reg[i].addr, p->am_reg[i].val);
+			else
+				WRITE_MPEG_REG(p->am_reg[i].addr, (READ_MPEG_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+			break;
+		case REG_TYPE_AXI:
+			if (p->am_reg[i].mask == 0xffffffff)
+				WRITE_AXI_REG(p->am_reg[i].addr, p->am_reg[i].val);
+			else
+				WRITE_AXI_REG(p->am_reg[i].addr, (READ_AXI_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+			break;
+		case REG_TYPE_INDEX_VPPCHROMA:
+			/*  add for vm2 demo frame size setting */
+			if (p->am_reg[i].addr == 0x20f) {
+				if ((p->am_reg[i].val & 0xff) != 0) {
+					cm2_patch_flag = p->am_reg[i].val;
+					p->am_reg[i].val = p->am_reg[i].val & 0xffffff00;
+				}
 				else
-					{
-					WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->val);
-					}
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: vppcoef: 0x1d70:port0x%x = 0x%x...............\n", __func__, p->addr, (p->val & p->mask));
-                #endif
-            break;
-            default:
-                pr_info("%s: bus type error!!!bustype = 0x%x................\n", __func__, p->type);
-            break;
-        }
-        p++;
-    }
+					cm2_patch_flag = 0;
+			}
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV)
+			WRITE_VCBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
+			if (p->am_reg[i].mask == 0xffffffff)
+				WRITE_VCBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
+			else{
+				temp = READ_VCBUS_REG(VPP_CHROMA_DATA_PORT);
+				WRITE_VCBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
+				WRITE_VCBUS_REG(VPP_CHROMA_DATA_PORT, (temp & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+			}
+#else
+			WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
+			if (p->am_reg[i].mask == 0xffffffff)
+				WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
+			else{
+				temp = READ_CBUS_REG(VPP_CHROMA_DATA_PORT);
+				WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
+				WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, (temp & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+			}
+#endif
+			break;
+		case REG_TYPE_INDEX_GAMMA:
+			break;
+		case VALUE_TYPE_CONTRAST_BRIGHTNESS:
+			break;
+		case REG_TYPE_INDEX_VPP_COEF:
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV)
+			if (((p->am_reg[i].addr&0xf) == 0)||((p->am_reg[i].addr&0xf) == 0x8)){
+				WRITE_VCBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
+				WRITE_VCBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
+			}
+			else
+				WRITE_VCBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
+#else
+			if (((p->am_reg[i].addr&0xf) == 0)||((p->am_reg[i].addr&0xf) == 0x8)){
+				WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
+				WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
+			}
+			else
+				WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
+#endif
+			break;
+		case REG_TYPE_VCBUS:
+			if (p->am_reg[i].mask == 0xffffffff)
+				WRITE_VCBUS_REG(p->am_reg[i].addr, p->am_reg[i].val);
+			else
+				WRITE_VCBUS_REG(p->am_reg[i].addr, (READ_VCBUS_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
+			break;
+		default:
+			break;
+		}
+	}
+	return;
+}
 
-    return;
+void amcm_enable(void)
+{
+	WRITE_CBUS_REG_BITS(VPP_MISC,0,28,1);//CM manage enable
 }
-#else
-void am_set_regmap(struct am_regs_s *p)
+
+void cm_regmap_latch(am_regs_t *am_regs,unsigned int reg_map)
 {
-    unsigned short i;
-    unsigned int temp = 0;
+	am_set_regmap(am_regs);
+	vecm_latch_flag &= ~reg_map;
+	pr_amcm_dbg("\n[amcm..] load reg %d table OK!!!\n",reg_map);
+}
 
-    for (i=0; i<p->length; i++) {
-        switch (p->am_reg[i].type)
-        {
-            case REG_TYPE_PHY:
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: bus type: phy..............\n", __func__);
-                #endif
-            break;
-            case REG_TYPE_CBUS:
-                if (p->am_reg[i].mask == 0xffffffff)
-                    WRITE_CBUS_REG(p->am_reg[i].addr, p->am_reg[i].val);
-                else
-                    WRITE_CBUS_REG(p->am_reg[i].addr, (READ_CBUS_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
-                #ifdef PQ_DEBUG_EN
-					pr_info("%s: cbus: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
-					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
-					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
-                #endif
-            break;
-            case REG_TYPE_APB:
-                if (p->am_reg[i].mask == 0xffffffff)
-                    WRITE_APB_REG(p->am_reg[i].addr, p->am_reg[i].val);
-                else
-                    WRITE_APB_REG(p->am_reg[i].addr, (READ_APB_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
-                #ifdef PQ_DEBUG_EN
-					pr_info("%s: apb: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
-					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
-					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
-                #endif
-            break;
-            case REG_TYPE_MPEG:
-                if (p->am_reg[i].mask == 0xffffffff)
-                    WRITE_MPEG_REG(p->am_reg[i].addr, p->am_reg[i].val);
-                else
-                    WRITE_MPEG_REG(p->am_reg[i].addr, (READ_MPEG_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
-                #ifdef PQ_DEBUG_EN
-					pr_info("%s: mpeg: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
-					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
-					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
-                #endif
-            break;
-            case REG_TYPE_AXI:
-                if (p->am_reg[i].mask == 0xffffffff)
-                    WRITE_AXI_REG(p->am_reg[i].addr, p->am_reg[i].val);
-                else
-                    WRITE_AXI_REG(p->am_reg[i].addr, (READ_AXI_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
-                #ifdef PQ_DEBUG_EN
-					pr_info("%s: axi: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
-					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
-					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
-                #endif
-            break;
-		#if 0
-            case REG_TYPE_AHB:
-                if (p->am_reg[i].mask == 0xffffffff)
-                    WRITE_AHB_REG(p->am_reg[i].addr, p->am_reg[i].val);
-                else
-                    WRITE_AHB_REG(p->am_reg[i].addr, (READ_AHB_REG(p->am_reg[i].addr) & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
-                #ifdef PQ_DEBUG_EN
-					pr_info("%s: ahb: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
-					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
-					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
-                #endif
-            break;
-		#endif
-            case REG_TYPE_INDEX_VPPCHROMA:
-				/*  add for vm2 demo frame size setting */
-				if (p->am_reg[i].addr == 0x20f) {
-                	if ((p->am_reg[i].val & 0xff) != 0) {
-						cm2_patch_flag = p->am_reg[i].val;
-                    	p->am_reg[i].val = p->am_reg[i].val & 0xffffff00;
-                    }
-                    else
-                  		cm2_patch_flag = 0;
-                }
-                WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
-                if (p->am_reg[i].mask == 0xffffffff)
-                {
-                    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
-                }
-                else
-                {
-                    temp = READ_CBUS_REG(VPP_CHROMA_DATA_PORT);
-                    WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
-                    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, (temp & (~(p->am_reg[i].mask))) | (p->am_reg[i].val & p->am_reg[i].mask));
-                }
-                #ifdef PQ_DEBUG_EN
-					pr_info("%s: chroma: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
-					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
-					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
-                #endif
-            break;
-            case REG_TYPE_INDEX_GAMMA:
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: bus type: REG_TYPE_INDEX_GAMMA..............\n", __func__);
-                #endif
-            break;
-            case VALUE_TYPE_CONTRAST_BRIGHTNESS:
-                #ifdef PQ_DEBUG_EN
-                    pr_info("%s: bus type: VALUE_TYPE_CONTRAST_BRIGHTNESS..............\n", __func__);
-                #endif
-            break;
-			case REG_TYPE_INDEX_VPP_COEF:
-				if (((p->am_reg[i].addr&0xf) == 0)||((p->am_reg[i].addr&0xf) == 0x8))
-					{
-					WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, p->am_reg[i].addr);
-					WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
-					}
-				else
-					{
-					WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, p->am_reg[i].val);
-					}
-				#ifdef PQ_DEBUG_EN
-					pr_info("%s: coef: Reg0x%x(%u)=0x%x(%u)val=%x(%u)mask=%x(%u)\n", __func__, p->am_reg[i].addr,p->am_reg[i].addr,
-					(p->am_reg[i].val & p->am_reg[i].mask),(p->am_reg[i].val & p->am_reg[i].mask),
-					p->am_reg[i].val,p->am_reg[i].val,p->am_reg[i].mask,p->am_reg[i].mask);
-                #endif
-            break;
-            default:
-            #ifdef PQ_DEBUG_EN
-                pr_info("%s: bus type error!!!bustype = 0x%x................\n", __func__, p->am_reg[i].type);
-            #endif
-            break;
-        }
-    }
+void amcm_level_sel(unsigned int cm_level)
+{
+	if(cm_level == 1)
+		am_set_regmap(&cmreg_lever1);
+	else if(cm_level == 2)
+		am_set_regmap(&cmreg_lever2);
+	else if(cm_level == 3)
+		am_set_regmap(&cmreg_lever3);
+	else if(cm_level == 4)
+		am_set_regmap(&cmreg_enhancement);
+	else
+		am_set_regmap(&cmreg_optimize);
+	WRITE_CBUS_REG_BITS(VPP_MISC,1,28,1);//CM manage enable
+}
 
-    return;
+void cm2_frame_size_patch(unsigned int width,unsigned int height)
+{
+	unsigned int vpp_size;
+	/*check if the cm2 enable/disable to config the cm2 size*/
+	if(!(READ_CBUS_REG(VPP_MISC)&(0x1<<28)))
+		return;
+	vpp_size = width|(height << 16);
+	if(cm_size == 0){
+		WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x205);
+		cm_size = READ_CBUS_REG(VPP_CHROMA_DATA_PORT);
+	}
+	if (cm_size != vpp_size) {
+		WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x205);
+		WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, vpp_size);
+		WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x209);
+		WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, width<<15);
+		WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x20a);
+		WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, height<<16);
+		cm_size =  vpp_size;
+		pr_amcm_dbg("\n[amcm..]cm2_frame_patch: set cm2 framesize %x, set demo mode  %x\n",
+				vpp_size, cm2_patch_flag);
+	}
+}
+
+/*
+* set the frame size for cm2 demo
+*/
+void cm2_frame_switch_patch(void)
+{
+	WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x20f);
+	WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, cm2_patch_flag);
+}
+
+void cm_latch_process(void)
+{
+	/*if ((vecm_latch_flag & FLAG_REG_MAP0) || (vecm_latch_flag & FLAG_REG_MAP1) ||
+	(vecm_latch_flag & FLAG_REG_MAP2) || (vecm_latch_flag & FLAG_REG_MAP3) ||
+	(vecm_latch_flag & FLAG_REG_MAP4) || (vecm_latch_flag & FLAG_REG_MAP5)){*/
+	do{
+		if (vecm_latch_flag & FLAG_REG_MAP0){
+			cm_regmap_latch(&amregs0,FLAG_REG_MAP0);
+			break;
+		}
+		if (vecm_latch_flag & FLAG_REG_MAP1){
+			cm_regmap_latch(&amregs1,FLAG_REG_MAP1);
+			break;
+		}
+		if (vecm_latch_flag & FLAG_REG_MAP2){
+			cm_regmap_latch(&amregs2,FLAG_REG_MAP2);
+			break;
+		}
+		if (vecm_latch_flag & FLAG_REG_MAP3){
+			cm_regmap_latch(&amregs3,FLAG_REG_MAP3);
+			break;
+		}
+		if (vecm_latch_flag & FLAG_REG_MAP4){
+			cm_regmap_latch(&amregs4,FLAG_REG_MAP4);
+			break;
+		}
+		if (vecm_latch_flag & FLAG_REG_MAP5){
+			cm_regmap_latch(&amregs5,FLAG_REG_MAP5);
+			break;
+		}
+		if((cm2_patch_flag & 0xff) > 0)
+			cm2_frame_switch_patch();
+	}while(0);
+	if (cm_en&&(cm_level_last != cm_level)){
+		cm_level_last = cm_level;
+		amcm_level_sel(cm_level);
+		pr_amcm_dbg("\n[amcm..] set cm2 load OK!!!\n");
+	}
+	else if((cm_en == 0)&&(cm_level_last != 0xff)){
+		cm_level_last = 0xff;
+		amcm_enable();//CM manage disable
+	}
+}
+
+static int amvecm_regmap_info(am_regs_t *p)
+{
+	unsigned short i;
+
+	for (i=0; i<p->length; i++) {
+		switch (p->am_reg[i].type){
+		case REG_TYPE_PHY:
+			printk("%s:%d bus type: phy..............\n", __func__,i);
+			break;
+		case REG_TYPE_CBUS:
+			printk("%s:%-3d cbus: 0x%-4x=0x%-8x (%-5u)=(%-10u) mask=%-8x(%u)\n", __func__,
+					i, p->am_reg[i].addr,(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].mask,p->am_reg[i].mask);
+			break;
+		case REG_TYPE_APB:
+			printk("%s:%-3d apb: 0x%-4x=0x%-8x (%-5u)=(%-10u) mask=%-8x(%u)\n", __func__,
+					i, p->am_reg[i].addr,(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].mask,p->am_reg[i].mask);
+			break;
+		case REG_TYPE_MPEG:
+			printk("%s:%-3d mpeg: 0x%-4x=0x%-8x (%-5u)=(%-10u) mask=%-8x(%u)\n", __func__,
+					i, p->am_reg[i].addr,(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].mask,p->am_reg[i].mask);
+			break;
+		case REG_TYPE_AXI:
+			printk("%s:%-3d axi: 0x%-4x=0x%-8x (%-5u)=(%-10u) mask=%-8x(%u)\n", __func__,
+					i, p->am_reg[i].addr,(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].mask,p->am_reg[i].mask);
+			break;
+		case REG_TYPE_INDEX_VPPCHROMA:
+			printk("%s:%-3d chroma: 0x%-4x=0x%-8x (%-5u)=(%-10u) mask=%-8x(%u)\n", __func__,
+					i, p->am_reg[i].addr,(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].mask,p->am_reg[i].mask);
+			break;
+		case REG_TYPE_INDEX_GAMMA:
+			printk("%s:%-3d bus type: REG_TYPE_INDEX_GAMMA..............\n", __func__,i);
+			break;
+		case VALUE_TYPE_CONTRAST_BRIGHTNESS:
+			printk("%s:%-3d bus type: VALUE_TYPE_CONTRAST_BRIGHTNESS..............\n", __func__,i);
+			break;
+		case REG_TYPE_INDEX_VPP_COEF:
+			printk("%s:%-3d coef: 0x%-4x=0x%-8x (%-5u)=(%-10u) mask=%-8x(%u)\n", __func__,
+					i, p->am_reg[i].addr,(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].mask,p->am_reg[i].mask);
+			break;
+		case REG_TYPE_VCBUS:
+			printk("%s:%-3d vcbus: 0x%-4x=0x%-8x (%-5u)=(%-10u) mask=%-8x(%u)\n", __func__,
+					i, p->am_reg[i].addr,(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].addr,
+					(p->am_reg[i].val & p->am_reg[i].mask),p->am_reg[i].mask,p->am_reg[i].mask);
+			break;
+		default:
+			printk("%s:%3d bus type error!!!bustype = 0x%x................\n", __func__,i, p->am_reg[i].type);
+			break;
+		}
+	}
+	return 0;
+}
+
+static long amvecm_regmap_set(am_regs_t *regs,am_regs_t *arg,unsigned int reg_map)
+{
+	int ret = 0;
+	if(!(memcpy(regs, arg, sizeof(struct am_regs_s)))) {
+		pr_amcm_dbg(KERN_ERR "[amcm..]0x%x load reg errors: can't get buffer lenght\n",reg_map);
+		return -EFAULT;
+	}
+	if (!regs->length || (regs->length > 512)) {
+		pr_amcm_dbg(KERN_ERR "[amcm..]0x%x load regs error: buffer length abnormal!!!, length=0x%x \n",
+				reg_map,regs->length);
+		return -EINVAL;
+	}
+	pr_amcm_dbg("\n[amcm..]0x%x reg length=0x%x ......\n",reg_map, regs->length);
+
+	if (debug_regload)
+		amvecm_regmap_info(regs);
+
+	vecm_latch_flag |= reg_map;
+	return ret;
+}
+
+int cm_load_reg(am_regs_t *arg)
+{
+	int ret = 0;
+	/*force set cm size to 0,enable check vpp size*/
+	cm_size = 0;
+	if (!(vecm_latch_flag & FLAG_REG_MAP0)) {
+		ret = amvecm_regmap_set(&amregs0,arg,FLAG_REG_MAP0);
+	}else if(!(vecm_latch_flag & FLAG_REG_MAP1)){
+		ret = amvecm_regmap_set(&amregs1,arg,FLAG_REG_MAP1);
+	}else if(!(vecm_latch_flag & FLAG_REG_MAP2)){
+		ret = amvecm_regmap_set(&amregs2,arg,FLAG_REG_MAP2);
+	}else if(!(vecm_latch_flag & FLAG_REG_MAP3)){
+		ret = amvecm_regmap_set(&amregs3,arg,FLAG_REG_MAP3);
+	}else if(!(vecm_latch_flag & FLAG_REG_MAP4)){
+		ret = amvecm_regmap_set(&amregs4,arg,FLAG_REG_MAP4);
+	}else if(!(vecm_latch_flag & FLAG_REG_MAP5)){
+		ret = amvecm_regmap_set(&amregs5,arg,FLAG_REG_MAP5);
+	}
+	return ret;
 }
-#endif
 
diff --git a/drivers/amlogic/amvecm/amcm.h b/drivers/amlogic/amvecm/amcm.h
index 0eaa22db6196..ab49f0a062b5 100755
--- a/drivers/amlogic/amvecm/amcm.h
+++ b/drivers/amlogic/amvecm/amcm.h
@@ -36,11 +36,13 @@ typedef struct cm_regs_s {
 // ***************************************************************************
 // *** IOCTL-oriented functions *********************************************
 // ***************************************************************************
-#ifdef AMVIDEO_REG_TABLE_DYNAMIC
-void am_set_regmap(unsigned int cnt, struct am_reg_s *p);
-#else
 void am_set_regmap(struct am_regs_s *p);
-#endif
+extern void amcm_enable(void);
+extern void amcm_level_sel(unsigned int cm_level);
+extern void cm2_frame_size_patch(unsigned int width,unsigned int height);
+extern void cm2_frame_switch_patch(void);
+extern void cm_latch_process(void);
+extern int cm_load_reg(am_regs_t *arg);
 
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
 #undef WRITE_CBUS_REG
diff --git a/drivers/amlogic/amvecm/amcm_regmap.h b/drivers/amlogic/amvecm/amcm_regmap.h
new file mode 100755
index 000000000000..3262de154c52
--- /dev/null
+++ b/drivers/amlogic/amvecm/amcm_regmap.h
@@ -0,0 +1,917 @@
+/*
+ * Color Management
+ *
+ * Author: dezhi kong <dezhi.kong@amlogic.com>
+ *
+ * Copyright (C) 2014 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __AM_CM_REGMAP_H
+#define __AM_CM_REGMAP_H
+
+#include <linux/amlogic/cm.h>
+
+static am_regs_t cmreg_lever1={
+	172,
+	{
+/* optimize */
+{6,	512,	    0xffffffff,	0           },
+{6,	513,	    0xffffffff,	0           },
+{6,	514,	    0xffffffff,	0           },
+{6,	515,	    0xffffffff,	134218752   },
+{6,	516,	    0xffffffff,	144         },
+{6,	518,	    0xffffffff,	0           },
+{6,	519,	    0xffffffff,	33554432    },
+{6,	520,	    0xffffffff,	118         },
+{6,	521,	    0xffffffff,	0           },
+{6,	522,	    0xffffffff,	0           },
+{6,	527,	    0xf,	0           },
+{6,	517,	    0xffffffff,	70715263    },
+{9,	256,	    0xffffffff,	532992      },
+{9,	257,	    0xffffffff,	0xf3f600af  },
+{9,	258,	    0xffffffff,	0xe3000000  },
+{9,	259,	    0xffffffff,	240         },
+{9,	260,	    0xffffffff,	63506       },
+{9,	264,	    0xffffffff,	16650496    },
+{9,	265,	    0xffffffff,	249         },
+{9,	266,	    0xffffffff,	0           },
+{9,	267,	    0xffffffff,	0           },
+{9,	268,	    0xffffffff,	0           },
+{9,	272,	    0xffffffff,	135936      },
+{9,	273,	    0xffffffff,	253         },
+{9,	274,	    0xffffffff,	0           },
+{9,	275,	    0xffffffff,	0           },
+{9,	276,	    0xffffffff,	0           },
+{9,	280,	    0xffffffff,	0xf3f11300  },
+{9,	281,	    0xffffffff,	214         },
+{9,	282,	    0xffffffff,	0           },
+{9,	283,	    0xffffffff,	0           },
+{9,	284,	    0xffffffff,	0           },
+{9,	288,	    0xffffffff,	0xede91300  },
+{9,	289,	    0xffffffff,	177         },
+{9,	290,	    0xffffffff,	0           },
+{9,	291,	    0xffffffff,	0           },
+{9,	292,	    0xffffffff,	15660544    },
+{9,	296,	    0xffffffff,	0xe9e61100  },
+{9,	297,	    0xffffffff,	184         },
+{9,	298,	    0xffffffff,	0           },
+{9,	299,	    0xffffffff,	0           },
+{9,	300,	    0xffffffff,	15464448    },
+{9,	304,	    0xffffffff,	0xeff80f00  },
+{9,	305,	    0xffffffff,	232         },
+{9,	306,	    0xffffffff,	0           },
+{9,	307,	    0xffffffff,	0           },
+{9,	308,	    0xffffffff,	0           },
+{9,	312,	    0xffffffff,	0xf60a0d00  },
+{9,	313,	    0xffffffff,	245         },
+{9,	314,	    0xffffffff,	0           },
+{9,	315,	    0xffffffff,	0           },
+{9,	316,	    0xffffffff,	0           },
+{9,	320,	    0xffffffff,	526848      },
+{9,	321,	    0xffffffff,	238         },
+{9,	322,	    0xffffffff,	0           },
+{9,	323,	    0xffffffff,	10          },
+{9,	324,	    0xffffffff,	0           },
+{9,	328,	    0xffffffff,	527616      },
+{9,	329,	    0xffffffff,	134742245   },
+{9,	330,	    0xffffffff,	167903232   },
+{9,	331,	    0xffffffff,	21          },
+{9,	332,	    0xffffffff,	3328        },
+{9,	336,	    0xffffffff,	397056      },
+{9,	337,	    0xffffffff,	0xf80d00da  },
+{9,	338,	    0xffffffff,	0xf80500fb  },
+{9,	339,	    0xffffffff,	2           },
+{9,	340,	    0xffffffff,	132357      },
+{9,	344,	    0xffffffff,	526848      },
+{9,	345,	    0xffffffff,	0xfb0a00c7  },
+{9,	346,	    0xffffffff,	0xf6020002  },
+{9,	347,	    0xffffffff,	251         },
+{9,	348,	    0xffffffff,	16646656    },
+{9,	352,	    0xffffffff,	657408      },
+{9,	353,	    0xffffffff,	327857      },
+{9,	354,	    0xffffffff,	0xf6050000  },
+{9,	355,	    0xffffffff,	2           },
+{9,	356,	    0xffffffff,	0           },
+{9,	360,	    0xffffffff,	526336      },
+{9,	361,	    0xffffffff,	162         },
+{9,	362,	    0xffffffff,	0xf600f600  },
+{9,	363,	    0xffffffff,	254         },
+{9,	364,	    0xffffffff,	33554432    },
+{9,	368,	    0xffffffff,	986368      },
+{9,	369,	    0xffffffff,	166         },
+{9,	370,	    0xffffffff,	0xf300eef6  },
+{9,	371,	    0xffffffff,	243         },
+{9,	372,	    0xffffffff,	0xfb050000  },
+{9,	376,	    0xffffffff,	34541312    },
+{9,	377,	    0xffffffff,	83886277    },
+{9,	378,	    0xffffffff,	0xfbfef8f8  },
+{9,	379,	    0xffffffff,	246         },
+{9,	380,	    0xffffffff,	0xf8080200  },
+{9,	384,	    0xffffffff,	286331136   },
+{9,	385,	    0xffffffff,	353698041   },
+{9,	386,	    0xffffffff,	168427768   },
+{9,	387,	    0xffffffff,	13          },
+{9,	388,	    0xffffffff,	0xfb081000  },
+{9,	392,	    0xffffffff,	218960128   },
+{9,	393,	    0xffffffff,	674758687   },
+{9,	394,	    0xffffffff,	573177856   },
+{9,	395,	    0xffffffff,	21          },
+{9,	396,	    0xffffffff,	854766      },
+{9,	400,	    0xffffffff,	168430080   },
+{9,	401,	    0xffffffff,	809304110   },
+{9,	402,	    0xffffffff,	674234389   },
+{9,	403,	    0xffffffff,	13          },
+{9,	404,	    0xffffffff,	716515      },
+{9,	408,	    0xffffffff,	134745344   },
+{9,	409,	    0xffffffff,	807731246   },
+{9,	410,	    0xffffffff,	403308562   },
+{9,	411,	    0xffffffff,	0           },
+{9,	412,	    0xffffffff,	59590       },
+{9,	416,	    0xffffffff,	67504640    },
+{9,	417,	    0xffffffff,	269484072   },
+{9,	418,	    0xffffffff,	182845440   },
+{9,	419,	    0xffffffff,	0           },
+{9,	420,	    0xffffffff,	61139       },
+{9,	424,	    0xffffffff,	396544      },
+{9,	425,	    0xffffffff,	134217757   },
+{9,	426,	    0xffffffff,	0xfb0b0000  },
+{9,	427,	    0xffffffff,	0           },
+{9,	428,	    0xffffffff,	246         },
+{9,	432,	    0xffffffff,	527616      },
+{9,	433,	    0xffffffff,	12          },
+{9,	434,	    0xffffffff,	15597568    },
+{9,	435,	    0xffffffff,	0           },
+{9,	436,	    0xffffffff,	0           },
+{9,	440,	    0xffffffff,	658688      },
+{9,	441,	    0xffffffff,	7           },
+{9,	442,	    0xffffffff,	0           },
+{9,	443,	    0xffffffff,	0           },
+{9,	444,	    0xffffffff,	0           },
+{9,	448,	    0xffffffff,	986880      },
+{9,	449,	    0xffffffff,	255         },
+{9,	450,	    0xffffffff,	0           },
+{9,	451,	    0xffffffff,	0           },
+{9,	452,	    0xffffffff,	0           },
+{9,	456,	    0xffffffff,	219811584   },
+{9,	457,	    0xffffffff,	238         },
+{9,	458,	    0xffffffff,	0           },
+{9,	459,	    0xffffffff,	0           },
+{9,	460,	    0xffffffff,	0           },
+{9,	464,	    0xffffffff,	287183104   },
+{9,	465,	    0xffffffff,	197         },
+{9,	466,	    0xffffffff,	0xf3000000  },
+{9,	467,	    0xffffffff,	246         },
+{9,	468,	    0xffffffff,	0xfb000000  },
+{9,	472,	    0xffffffff,	219943168   },
+{9,	473,	    0xffffffff,	169         },
+{9,	474,	    0xffffffff,	0xf0000000  },
+{9,	475,	    0xffffffff,	232         },
+{9,	476,	    0xffffffff,	0           },
+{9,	480,	    0xffffffff,	1707264     },
+{9,	481,	    0xffffffff,	0xfb0000ab  },
+{9,	482,	    0xffffffff,	0xe300f3f3  },
+{9,	483,	    0xffffffff,	219         },
+{9,	484,	    0xffffffff,	15597568    },
+{9,	488,	    0xffffffff,	1509888     },
+{9,	489,	    0xffffffff,	0xf30000b6  },
+{9,	490,	    0xffffffff,	0xd800e8e3  },
+{9,	491,	    0xffffffff,	222         },
+{9,	492,	    0xffffffff,	14876680    },
+{9,	496,	    0xffffffff,	1117440     },
+{9,	497,	    0xffffffff,	0xf3fb00ba  },
+{9,	498,	    0xffffffff,	0xd300ebe6  },
+{9,	499,	    0xffffffff,	232         },
+{9,	500,	    0xffffffff,	15661840    },
+{9,	504,	    0xffffffff,	989696      },
+{9,	505,	    0xffffffff,	0xf6f800b6  },
+{9,	506,	    0xffffffff,	0xe600f3f3  },
+{9,	507,	    0xffffffff,	235         },
+{9,	508,	    0xffffffff,	18          },
+{0}
+	}
+};
+static am_regs_t cmreg_lever2={
+	172,
+	{
+/* optimize */
+{6,	512,	    0xffffffff,	0          },
+{6,	513,	    0xffffffff,	0          },
+{6,	514,	    0xffffffff,	0          },
+{6,	515,	    0xffffffff,	134218752  },
+{6,	516,	    0xffffffff,	144        },
+{6,	518,	    0xffffffff,	0          },
+{6,	519,	    0xffffffff,	33554432   },
+{6,	520,	    0xffffffff,	122        },
+{6,	521,	    0xffffffff,	0          },
+{6,	522,	    0xffffffff,	0          },
+{6,	527,	    0xf,	0          },
+{6,	517,	    0xffffffff,	70715263   },
+{9,	256,	    0xffffffff,	2840064    },
+{9,	257,	    0xffffffff,	12         },
+{9,	258,	    0xffffffff,	0          },
+{9,	259,	    0xffffffff,	0          },
+{9,	260,	    0xffffffff,	0          },
+{9,	264,	    0xffffffff,	2708992    },
+{9,	265,	    0xffffffff,	31         },
+{9,	266,	    0xffffffff,	0          },
+{9,	267,	    0xffffffff,	0          },
+{9,	268,	    0xffffffff,	0          },
+{9,	272,	    0xffffffff,	2708992    },
+{9,	273,	    0xffffffff,	51         },
+{9,	274,	    0xffffffff,	0          },
+{9,	275,	    0xffffffff,	0          },
+{9,	276,	    0xffffffff,	0          },
+{9,	280,	    0xffffffff,	2840064    },
+{9,	281,	    0xffffffff,	63         },
+{9,	282,	    0xffffffff,	0          },
+{9,	283,	    0xffffffff,	0          },
+{9,	284,	    0xffffffff,	0          },
+{9,	288,	    0xffffffff,	2840064    },
+{9,	289,	    0xffffffff,	63         },
+{9,	290,	    0xffffffff,	0          },
+{9,	291,	    0xffffffff,	0          },
+{9,	292,	    0xffffffff,	0          },
+{9,	296,	    0xffffffff,	2708992    },
+{9,	297,	    0xffffffff,	63         },
+{9,	298,	    0xffffffff,	0          },
+{9,	299,	    0xffffffff,	0          },
+{9,	300,	    0xffffffff,	0          },
+{9,	304,	    0xffffffff,	2708480    },
+{9,	305,	    0xffffffff,	63         },
+{9,	306,	    0xffffffff,	0          },
+{9,	307,	    0xffffffff,	0          },
+{9,	308,	    0xffffffff,	0          },
+{9,	312,	    0xffffffff,	2708480    },
+{9,	313,	    0xffffffff,	51         },
+{9,	314,	    0xffffffff,	0          },
+{9,	315,	    0xffffffff,	0          },
+{9,	316,	    0xffffffff,	0          },
+{9,	320,	    0xffffffff,	2708480    },
+{9,	321,	    0xffffffff,	9          },
+{9,	322,	    0xffffffff,	0          },
+{9,	323,	    0xffffffff,	0          },
+{9,	324,	    0xffffffff,	0          },
+{9,	328,	    0xffffffff,	2708480    },
+{9,	329,	    0xffffffff,	234        },
+{9,	330,	    0xffffffff,	0          },
+{9,	331,	    0xffffffff,	0          },
+{9,	332,	    0xffffffff,	0          },
+{9,	336,	    0xffffffff,	2708480    },
+{9,	337,	    0xffffffff,	212        },
+{9,	338,	    0xffffffff,	0          },
+{9,	339,	    0xffffffff,	0          },
+{9,	340,	    0xffffffff,	0          },
+{9,	344,	    0xffffffff,	2708480    },
+{9,	345,	    0xffffffff,	197        },
+{9,	346,	    0xffffffff,	0          },
+{9,	347,	    0xffffffff,	0          },
+{9,	348,	    0xffffffff,	0          },
+{9,	352,	    0xffffffff,	2708480    },
+{9,	353,	    0xffffffff,	193        },
+{9,	354,	    0xffffffff,	0          },
+{9,	355,	    0xffffffff,	0          },
+{9,	356,	    0xffffffff,	0          },
+{9,	360,	    0xffffffff,	2708480    },
+{9,	361,	    0xffffffff,	203        },
+{9,	362,	    0xffffffff,	0          },
+{9,	363,	    0xffffffff,	0          },
+{9,	364,	    0xffffffff,	0          },
+{9,	368,	    0xffffffff,	2708480    },
+{9,	369,	    0xffffffff,	214        },
+{9,	370,	    0xffffffff,	0          },
+{9,	371,	    0xffffffff,	0          },
+{9,	372,	    0xffffffff,	0          },
+{9,	376,	    0xffffffff,	2708992    },
+{9,	377,	    0xffffffff,	219        },
+{9,	378,	    0xffffffff,	0          },
+{9,	379,	    0xffffffff,	0          },
+{9,	380,	    0xffffffff,	0          },
+{9,	384,	    0xffffffff,	2708480    },
+{9,	385,	    0xffffffff,	236        },
+{9,	386,	    0xffffffff,	0          },
+{9,	387,	    0xffffffff,	0          },
+{9,	388,	    0xffffffff,	0          },
+{9,	392,	    0xffffffff,	2708992    },
+{9,	393,	    0xffffffff,	249        },
+{9,	394,	    0xffffffff,	0          },
+{9,	395,	    0xffffffff,	0          },
+{9,	396,	    0xffffffff,	0          },
+{9,	400,	    0xffffffff,	2708992    },
+{9,	401,	    0xffffffff,	3          },
+{9,	402,	    0xffffffff,	0          },
+{9,	403,	    0xffffffff,	0          },
+{9,	404,	    0xffffffff,	0          },
+{9,	408,	    0xffffffff,	2708992    },
+{9,	409,	    0xffffffff,	9          },
+{9,	410,	    0xffffffff,	0          },
+{9,	411,	    0xffffffff,	0          },
+{9,	412,	    0xffffffff,	0          },
+{9,	416,	    0xffffffff,	2708480    },
+{9,	417,	    0xffffffff,	12         },
+{9,	418,	    0xffffffff,	0          },
+{9,	419,	    0xffffffff,	0          },
+{9,	420,	    0xffffffff,	0          },
+{9,	424,	    0xffffffff,	2708480    },
+{9,	425,	    0xffffffff,	14         },
+{9,	426,	    0xffffffff,	0          },
+{9,	427,	    0xffffffff,	0          },
+{9,	428,	    0xffffffff,	0          },
+{9,	432,	    0xffffffff,	2708480    },
+{9,	433,	    0xffffffff,	12         },
+{9,	434,	    0xffffffff,	0          },
+{9,	435,	    0xffffffff,	0          },
+{9,	436,	    0xffffffff,	0          },
+{9,	440,	    0xffffffff,	2708480    },
+{9,	441,	    0xffffffff,	7          },
+{9,	442,	    0xffffffff,	0          },
+{9,	443,	    0xffffffff,	0          },
+{9,	444,	    0xffffffff,	0          },
+{9,	448,	    0xffffffff,	2708480    },
+{9,	449,	    0xffffffff,	251        },
+{9,	450,	    0xffffffff,	0          },
+{9,	451,	    0xffffffff,	0          },
+{9,	452,	    0xffffffff,	0          },
+{9,	456,	    0xffffffff,	2708480    },
+{9,	457,	    0xffffffff,	242        },
+{9,	458,	    0xffffffff,	0          },
+{9,	459,	    0xffffffff,	0          },
+{9,	460,	    0xffffffff,	0          },
+{9,	464,	    0xffffffff,	36262912   },
+{9,	465,	    0xffffffff,	238        },
+{9,	466,	    0xffffffff,	0          },
+{9,	467,	    0xffffffff,	0          },
+{9,	468,	    0xffffffff,	0          },
+{9,	472,	    0xffffffff,	69817344   },
+{9,	473,	    0xffffffff,	245        },
+{9,	474,	    0xffffffff,	0          },
+{9,	475,	    0xffffffff,	0          },
+{9,	476,	    0xffffffff,	0          },
+{9,	480,	    0xffffffff,	136926208  },
+{9,	481,	    0xffffffff,	1          },
+{9,	482,	    0xffffffff,	0          },
+{9,	483,	    0xffffffff,	0          },
+{9,	484,	    0xffffffff,	0          },
+{9,	488,	    0xffffffff,	136926208  },
+{9,	489,	    0xffffffff,	5          },
+{9,	490,	    0xffffffff,	0          },
+{9,	491,	    0xffffffff,	0          },
+{9,	492,	    0xffffffff,	0          },
+{9,	496,	    0xffffffff,	136926208  },
+{9,	497,	    0xffffffff,	5          },
+{9,	498,	    0xffffffff,	0          },
+{9,	499,	    0xffffffff,	0          },
+{9,	500,	    0xffffffff,	0          },
+{9,	504,	    0xffffffff,	69817344   },
+{9,	505,	    0xffffffff,	7          },
+{9,	506,	    0xffffffff,	0          },
+{9,	507,	    0xffffffff,	0          },
+{9,	508,	    0xffffffff,	0          },
+{0}
+	}
+};
+static am_regs_t cmreg_lever3={
+	172,
+	{
+/* optimize */
+{6,	512,	    0xffffffff,	0          },
+{6,	513,	    0xffffffff,	0          },
+{6,	514,	    0xffffffff,	0          },
+{6,	515,	    0xffffffff,	134218752  },
+{6,	516,	    0xffffffff,	144        },
+{6,	518,	    0xffffffff,	0          },
+{6,	519,	    0xffffffff,	33554432   },
+{6,	520,	    0xffffffff,	118        },
+{6,	521,	    0xffffffff,	62914560   },
+{6,	522,	    0xffffffff,	70778880   },
+{6,	527,	           0xf,	1          },
+{6,	517,	    0xffffffff,	70780799   },
+{9,	256,	    0xffffffff,	16648704   },
+{9,	257,	    0xffffffff,	0xf3f6000b },
+{9,	258,	    0xffffffff,	0xe3000000 },
+{9,	259,	    0xffffffff,	240        },
+{9,	260,	    0xffffffff,	63742      },
+{9,	264,	    0xffffffff,	16650496   },
+{9,	265,	    0xffffffff,	14         },
+{9,	266,	    0xffffffff,	0          },
+{9,	267,	    0xffffffff,	0          },
+{9,	268,	    0xffffffff,	0          },
+{9,	272,	    0xffffffff,	135936     },
+{9,	273,	    0xffffffff,	253        },
+{9,	274,	    0xffffffff,	0          },
+{9,	275,	    0xffffffff,	0          },
+{9,	276,	    0xffffffff,	0          },
+{9,	280,	    0xffffffff,	0xf3f11300 },
+{9,	281,	    0xffffffff,	214        },
+{9,	282,	    0xffffffff,	0          },
+{9,	283,	    0xffffffff,	0          },
+{9,	284,	    0xffffffff,	0          },
+{9,	288,	    0xffffffff,	0xede91300 },
+{9,	289,	    0xffffffff,	177        },
+{9,	290,	    0xffffffff,	0          },
+{9,	291,	    0xffffffff,	0          },
+{9,	292,	    0xffffffff,	15660544   },
+{9,	296,	    0xffffffff,	0xe9e61100 },
+{9,	297,	    0xffffffff,	184        },
+{9,	298,	    0xffffffff,	0          },
+{9,	299,	    0xffffffff,	0          },
+{9,	300,	    0xffffffff,	15464448   },
+{9,	304,	    0xffffffff,	0xeff80f00 },
+{9,	305,	    0xffffffff,	232        },
+{9,	306,	    0xffffffff,	0          },
+{9,	307,	    0xffffffff,	0          },
+{9,	308,	    0xffffffff,	0          },
+{9,	312,	    0xffffffff,	0xf60a0d00 },
+{9,	313,	    0xffffffff,	5          },
+{9,	314,	    0xffffffff,	0          },
+{9,	315,	    0xffffffff,	0          },
+{9,	316,	    0xffffffff,	0          },
+{9,	320,	    0xffffffff,	526848     },
+{9,	321,	    0xffffffff,	5          },
+{9,	322,	    0xffffffff,	0          },
+{9,	323,	    0xffffffff,	10         },
+{9,	324,	    0xffffffff,	0          },
+{9,	328,	    0xffffffff,	526848     },
+{9,	329,	    0xffffffff,	134742265  },
+{9,	330,	    0xffffffff,	167903232  },
+{9,	331,	    0xffffffff,	21         },
+{9,	332,	    0xffffffff,	3328       },
+{9,	336,	    0xffffffff,	131072     },
+{9,	337,	    0xffffffff,	0xf80d00ea },
+{9,	338,	    0xffffffff,	0xf80500fb },
+{9,	339,	    0xffffffff,	2          },
+{9,	340,	    0xffffffff,	132357     },
+{9,	344,	    0xffffffff,	131584     },
+{9,	345,	    0xffffffff,	0xfb0100da },
+{9,	346,	    0xffffffff,	0xf6020002 },
+{9,	347,	    0xffffffff,	251        },
+{9,	348,	    0xffffffff,	16646656   },
+{9,	352,	    0xffffffff,	657408     },
+{9,	353,	    0xffffffff,	327872     },
+{9,	354,	    0xffffffff,	0xf6050000 },
+{9,	355,	    0xffffffff,	2          },
+{9,	356,	    0xffffffff,	0          },
+{9,	360,	    0xffffffff,	526336     },
+{9,	361,	    0xffffffff,	175        },
+{9,	362,	    0xffffffff,	0xf600f600 },
+{9,	363,	    0xffffffff,	254        },
+{9,	364,	    0xffffffff,	33554432   },
+{9,	368,	    0xffffffff,	986368     },
+{9,	369,	    0xffffffff,	169        },
+{9,	370,	    0xffffffff,	0xf300eef6 },
+{9,	371,	    0xffffffff,	243        },
+{9,	372,	    0xffffffff,	0xfb050000 },
+{9,	376,	    0xffffffff,	34541312   },
+{9,	377,	    0xffffffff,	83886277   },
+{9,	378,	    0xffffffff,	0xfbfef8f8 },
+{9,	379,	    0xffffffff,	246        },
+{9,	380,	    0xffffffff,	0xf8080200 },
+{9,	384,	    0xffffffff,	135339520  },
+{9,	385,	    0xffffffff,	353697836  },
+{9,	386,	    0xffffffff,	168427768  },
+{9,	387,	    0xffffffff,	13         },
+{9,	388,	    0xffffffff,	0xfb080800 },
+{9,	392,	    0xffffffff,	219356160  },
+{9,	393,	    0xffffffff,	674758739  },
+{9,	394,	    0xffffffff,	573177856  },
+{9,	395,	    0xffffffff,	21         },
+{9,	396,	    0xffffffff,	657920     },
+{9,	400,	    0xffffffff,	219223808  },
+{9,	401,	    0xffffffff,	809304160  },
+{9,	402,	    0xffffffff,	674562069  },
+{9,	403,	    0xffffffff,	13         },
+{9,	404,	    0xffffffff,	657920     },
+{9,	408,	    0xffffffff,	168629504  },
+{9,	409,	    0xffffffff,	807731289  },
+{9,	410,	    0xffffffff,	403308562  },
+{9,	411,	    0xffffffff,	0          },
+{9,	412,	    0xffffffff,	526848     },
+{9,	416,	    0xffffffff,	395776     },
+{9,	417,	    0xffffffff,	269484098  },
+{9,	418,	    0xffffffff,	167772160  },
+{9,	419,	    0xffffffff,	0          },
+{9,	420,	    0xffffffff,	0          },
+{9,	424,	    0xffffffff,	396544     },
+{9,	425,	    0xffffffff,	134217757  },
+{9,	426,	    0xffffffff,	0          },
+{9,	427,	    0xffffffff,	0          },
+{9,	428,	    0xffffffff,	0          },
+{9,	432,	    0xffffffff,	527616     },
+{9,	433,	    0xffffffff,	12         },
+{9,	434,	    0xffffffff,	0          },
+{9,	435,	    0xffffffff,	0          },
+{9,	436,	    0xffffffff,	0          },
+{9,	440,	    0xffffffff,	658688     },
+{9,	441,	    0xffffffff,	7          },
+{9,	442,	    0xffffffff,	0          },
+{9,	443,	    0xffffffff,	0          },
+{9,	444,	    0xffffffff,	0          },
+{9,	448,	    0xffffffff,	986880     },
+{9,	449,	    0xffffffff,	5          },
+{9,	450,	    0xffffffff,	0          },
+{9,	451,	    0xffffffff,	0          },
+{9,	452,	    0xffffffff,	0          },
+{9,	456,	    0xffffffff,	219811584  },
+{9,	457,	    0xffffffff,	244        },
+{9,	458,	    0xffffffff,	0          },
+{9,	459,	    0xffffffff,	0          },
+{9,	460,	    0xffffffff,	0          },
+{9,	464,	    0xffffffff,	287183104  },
+{9,	465,	    0xffffffff,	186        },
+{9,	466,	    0xffffffff,	0xf3000000 },
+{9,	467,	    0xffffffff,	246        },
+{9,	468,	    0xffffffff,	0xfb000000 },
+{9,	472,	    0xffffffff,	219944192  },
+{9,	473,	    0xffffffff,	158        },
+{9,	474,	    0xffffffff,	0xf0000000 },
+{9,	475,	    0xffffffff,	232        },
+{9,	476,	    0xffffffff,	0          },
+{9,	480,	    0xffffffff,	1382912    },
+{9,	481,	    0xffffffff,	0xfb0000a4 },
+{9,	482,	    0xffffffff,	0xe300f3f3 },
+{9,	483,	    0xffffffff,	219        },
+{9,	484,	    0xffffffff,	0          },
+{9,	488,	    0xffffffff,	1514496    },
+{9,	489,	    0xffffffff,	0xf30000ba },
+{9,	490,	    0xffffffff,	0xe600f3f0 },
+{9,	491,	    0xffffffff,	222        },
+{9,	492,	    0xffffffff,	0          },
+{9,	496,	    0xffffffff,	1120000    },
+{9,	497,	    0xffffffff,	0xf3fb00db },
+{9,	498,	    0xffffffff,	0xe800f6ee },
+{9,	499,	    0xffffffff,	232        },
+{9,	500,	    0xffffffff,	64256      },
+{9,	504,	    0xffffffff,	397056     },
+{9,	505,	    0xffffffff,	0xf6f800f7 },
+{9,	506,	    0xffffffff,	0xe60000f8 },
+{9,	507,	    0xffffffff,	235        },
+{9,	508,	    0xffffffff,	65278      },
+{0}
+	}
+};
+
+static am_regs_t cmreg_optimize={
+	172,
+	{
+/* optimize */
+{REG_TYPE_INDEX_VPPCHROMA,	0x200,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x201,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x202,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x203,    0xffffffff, 0x8000400},
+{REG_TYPE_INDEX_VPPCHROMA,	0x204,    0xffffffff, 0x90   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x205,    0xffffffff, 0x437077f},
+{REG_TYPE_INDEX_VPPCHROMA,	0x206,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x207,    0xffffffff, 0x1f60000},
+{REG_TYPE_INDEX_VPPCHROMA,	0x208,    0xffffffff, 0x76   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x209,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x20a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x20f,    0xf, 0x0,   },
+{REG_TYPE_INDEX_VPP_COEF,	0x100,    0xffffffff, 0xa1100  },
+{REG_TYPE_INDEX_VPP_COEF,	0x101,    0xffffffff, 0xc   },
+{REG_TYPE_INDEX_VPP_COEF,	0x102,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x103,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x104,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x108,    0xffffffff, 0xd1100  },
+{REG_TYPE_INDEX_VPP_COEF,	0x109,    0xffffffff, 0x1f   },
+{REG_TYPE_INDEX_VPP_COEF,	0x10a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x10b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x10c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x110,    0xffffffff, 0xf1300  },
+{REG_TYPE_INDEX_VPP_COEF,	0x111,    0xffffffff, 0x33   },
+{REG_TYPE_INDEX_VPP_COEF,	0x112,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x113,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x114,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x118,    0xffffffff, 0xf1300  },
+{REG_TYPE_INDEX_VPP_COEF,	0x119,    0xffffffff, 0x3f   },
+{REG_TYPE_INDEX_VPP_COEF,	0x11a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x11b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x11c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x120,    0xffffffff, 0xf1300  },
+{REG_TYPE_INDEX_VPP_COEF,	0x121,    0xffffffff, 0x40   },
+{REG_TYPE_INDEX_VPP_COEF,	0x122,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x123,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x124,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x128,    0xffffffff, 0xf1100  },
+{REG_TYPE_INDEX_VPP_COEF,	0x129,    0xffffffff, 0x40   },
+{REG_TYPE_INDEX_VPP_COEF,	0x12a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x12b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x12c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x130,    0xffffffff, 0xd0f00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x131,    0xffffffff, 0x3f   },
+{REG_TYPE_INDEX_VPP_COEF,	0x132,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x133,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x134,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x138,    0xffffffff, 0xa0d00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x139,    0xffffffff, 0x32   },
+{REG_TYPE_INDEX_VPP_COEF,	0x13a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x13b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x13c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x140,    0xffffffff, 0x80a00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x141,    0xffffffff, 0x9   },
+{REG_TYPE_INDEX_VPP_COEF,	0x142,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x143,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x144,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x148,    0xffffffff, 0x80a00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x149,    0xffffffff, 0xea   },
+{REG_TYPE_INDEX_VPP_COEF,	0x14a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x14b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x14c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x150,    0xffffffff, 0xa0a00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x151,    0xffffffff, 0xd4   },
+{REG_TYPE_INDEX_VPP_COEF,	0x152,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x153,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x154,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x158,    0xffffffff, 0xa0800  },
+{REG_TYPE_INDEX_VPP_COEF,	0x159,    0xffffffff, 0xc3   },
+{REG_TYPE_INDEX_VPP_COEF,	0x15a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x15b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x15c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x160,    0xffffffff, 0xa0800  },
+{REG_TYPE_INDEX_VPP_COEF,	0x161,    0xffffffff, 0xc0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x162,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x163,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x164,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x168,    0xffffffff, 0x80800  },
+{REG_TYPE_INDEX_VPP_COEF,	0x169,    0xffffffff, 0xcb   },
+{REG_TYPE_INDEX_VPP_COEF,	0x16a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x16b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x16c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x170,    0xffffffff, 0x60800  },
+{REG_TYPE_INDEX_VPP_COEF,	0x171,    0xffffffff, 0xd4   },
+{REG_TYPE_INDEX_VPP_COEF,	0x172,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x173,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x174,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x178,    0xffffffff, 0x40600  },
+{REG_TYPE_INDEX_VPP_COEF,	0x179,    0xffffffff, 0xdb   },
+{REG_TYPE_INDEX_VPP_COEF,	0x17a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x17b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x17c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x180,    0xffffffff, 0x60600  },
+{REG_TYPE_INDEX_VPP_COEF,	0x181,    0xffffffff, 0xea   },
+{REG_TYPE_INDEX_VPP_COEF,	0x182,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x183,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x184,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x188,    0xffffffff, 0x60600  },
+{REG_TYPE_INDEX_VPP_COEF,	0x189,    0xffffffff, 0xf7   },
+{REG_TYPE_INDEX_VPP_COEF,	0x18a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x18b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x18c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x190,    0xffffffff, 0x60600  },
+{REG_TYPE_INDEX_VPP_COEF,	0x191,    0xffffffff, 0x3   },
+{REG_TYPE_INDEX_VPP_COEF,	0x192,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x193,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x194,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x198,    0xffffffff, 0x80800  },
+{REG_TYPE_INDEX_VPP_COEF,	0x199,    0xffffffff, 0x9   },
+{REG_TYPE_INDEX_VPP_COEF,	0x19a,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x19b,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x19c,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a0,    0xffffffff, 0x60a00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a1,    0xffffffff, 0xc   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a2,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a3,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a4,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a8,    0xffffffff, 0x60d00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a9,    0xffffffff, 0xe   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1aa,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ab,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ac,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b0,    0xffffffff, 0x80d00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b1,    0xffffffff, 0xc   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b2,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b3,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b4,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b8,    0xffffffff, 0xa0d00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b9,    0xffffffff, 0x7   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ba,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1bb,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1bc,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c0,    0xffffffff, 0xf0f00  },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c1,    0xffffffff, 0xfb   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c2,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c3,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c4,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c8,    0xffffffff, 0x110f00 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c9,    0xffffffff, 0xf2   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ca,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1cb,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1cc,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d0,    0xffffffff, 0x131100 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d1,    0xffffffff, 0xee   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d2,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d3,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d4,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d8,    0xffffffff, 0x131500 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d9,    0xffffffff, 0xf5   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1da,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1db,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1dc,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e0,    0xffffffff, 0x151a00 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e1,    0xffffffff, 0x1   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e2,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e3,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e4,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e8,    0xffffffff, 0x171c00 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e9,    0xffffffff, 0x5   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ea,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1eb,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ec,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f0,    0xffffffff, 0x171a00 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f1,    0xffffffff, 0x5   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f2,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f3,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f4,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f8,    0xffffffff, 0x131500 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f9,    0xffffffff, 0x7   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1fa,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1fb,    0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1fc,    0xffffffff, 0x0   },
+{0}
+	}
+};
+static am_regs_t cmreg_enhancement={
+	172,
+	{
+/* enhancement */
+{REG_TYPE_INDEX_VPPCHROMA,	0x200,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x201,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x202,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x203,	  0xffffffff, 0x8000400},
+{REG_TYPE_INDEX_VPPCHROMA,	0x204,	  0xffffffff, 0x90   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x205,	  0xffffffff, 0x437077f},
+{REG_TYPE_INDEX_VPPCHROMA,	0x206,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x207,	  0xffffffff, 0x2640000},
+{REG_TYPE_INDEX_VPPCHROMA,	0x208,	  0xffffffff, 0x7a   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x209,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x20a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPPCHROMA,	0x20f,	  0xf, 0x0,   },
+{REG_TYPE_INDEX_VPP_COEF,	0x100,	  0xffffffff, 0x2b5600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x101,	  0xffffffff, 0xc   },
+{REG_TYPE_INDEX_VPP_COEF,	0x102,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x103,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x104,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x108,	  0xffffffff, 0x295600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x109,	  0xffffffff, 0x1f   },
+{REG_TYPE_INDEX_VPP_COEF,	0x10a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x10b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x10c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x110,	  0xffffffff, 0x295600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x111,	  0xffffffff, 0x33   },
+{REG_TYPE_INDEX_VPP_COEF,	0x112,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x113,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x114,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x118,	  0xffffffff, 0x2b5600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x119,	  0xffffffff, 0x3f   },
+{REG_TYPE_INDEX_VPP_COEF,	0x11a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x11b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x11c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x120,	  0xffffffff, 0x2b5600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x121,	  0xffffffff, 0x3f   },
+{REG_TYPE_INDEX_VPP_COEF,	0x122,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x123,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x124,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x128,	  0xffffffff, 0x295600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x129,	  0xffffffff, 0x3f   },
+{REG_TYPE_INDEX_VPP_COEF,	0x12a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x12b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x12c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x130,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x131,	  0xffffffff, 0x3f   },
+{REG_TYPE_INDEX_VPP_COEF,	0x132,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x133,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x134,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x138,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x139,	  0xffffffff, 0x33   },
+{REG_TYPE_INDEX_VPP_COEF,	0x13a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x13b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x13c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x140,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x141,	  0xffffffff, 0x9   },
+{REG_TYPE_INDEX_VPP_COEF,	0x142,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x143,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x144,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x148,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x149,	  0xffffffff, 0xea   },
+{REG_TYPE_INDEX_VPP_COEF,	0x14a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x14b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x14c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x150,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x151,	  0xffffffff, 0xd4   },
+{REG_TYPE_INDEX_VPP_COEF,	0x152,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x153,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x154,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x158,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x159,	  0xffffffff, 0xc5   },
+{REG_TYPE_INDEX_VPP_COEF,	0x15a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x15b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x15c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x160,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x161,	  0xffffffff, 0xc1   },
+{REG_TYPE_INDEX_VPP_COEF,	0x162,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x163,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x164,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x168,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x169,	  0xffffffff, 0xcb   },
+{REG_TYPE_INDEX_VPP_COEF,	0x16a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x16b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x16c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x170,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x171,	  0xffffffff, 0xd6   },
+{REG_TYPE_INDEX_VPP_COEF,	0x172,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x173,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x174,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x178,	  0xffffffff, 0x295600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x179,	  0xffffffff, 0xdb   },
+{REG_TYPE_INDEX_VPP_COEF,	0x17a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x17b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x17c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x180,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x181,	  0xffffffff, 0xec   },
+{REG_TYPE_INDEX_VPP_COEF,	0x182,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x183,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x184,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x188,	  0xffffffff, 0x295600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x189,	  0xffffffff, 0xf9   },
+{REG_TYPE_INDEX_VPP_COEF,	0x18a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x18b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x18c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x190,	  0xffffffff, 0x295600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x191,	  0xffffffff, 0x3   },
+{REG_TYPE_INDEX_VPP_COEF,	0x192,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x193,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x194,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x198,	  0xffffffff, 0x295600 },
+{REG_TYPE_INDEX_VPP_COEF,	0x199,	  0xffffffff, 0x9   },
+{REG_TYPE_INDEX_VPP_COEF,	0x19a,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x19b,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x19c,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a0,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a1,	  0xffffffff, 0xc   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a2,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a3,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a4,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a8,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1a9,	  0xffffffff, 0xe   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1aa,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ab,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ac,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b0,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b1,	  0xffffffff, 0xc   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b2,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b3,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b4,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b8,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1b9,	  0xffffffff, 0x7   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ba,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1bb,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1bc,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c0,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c1,	  0xffffffff, 0xfb   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c2,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c3,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c4,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c8,	  0xffffffff, 0x295400 },
+{REG_TYPE_INDEX_VPP_COEF,	0x1c9,	  0xffffffff, 0xf2   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ca,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1cb,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1cc,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d0,	  0xffffffff, 0x2295400},
+{REG_TYPE_INDEX_VPP_COEF,	0x1d1,	  0xffffffff, 0xee   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d2,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d3,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d4,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1d8,	  0xffffffff, 0x4295400},
+{REG_TYPE_INDEX_VPP_COEF,	0x1d9,	  0xffffffff, 0xf5   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1da,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1db,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1dc,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e0,	  0xffffffff, 0x8295400},
+{REG_TYPE_INDEX_VPP_COEF,	0x1e1,	  0xffffffff, 0x1   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e2,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e3,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e4,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1e8,	  0xffffffff, 0x8295400},
+{REG_TYPE_INDEX_VPP_COEF,	0x1e9,	  0xffffffff, 0x5   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ea,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1eb,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1ec,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f0,	  0xffffffff, 0x8295400},
+{REG_TYPE_INDEX_VPP_COEF,	0x1f1,	  0xffffffff, 0x5   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f2,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f3,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f4,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1f8,	  0xffffffff, 0x4295400},
+{REG_TYPE_INDEX_VPP_COEF,	0x1f9,	  0xffffffff, 0x7   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1fa,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1fb,	  0xffffffff, 0x0   },
+{REG_TYPE_INDEX_VPP_COEF,	0x1fc,	  0xffffffff, 0x0   },
+{0}
+	}
+};
+
+
+#endif
+
diff --git a/drivers/amlogic/amvecm/amve.c b/drivers/amlogic/amvecm/amve.c
index ae29f9111a94..1ff6510f7a1c 100755
--- a/drivers/amlogic/amvecm/amve.c
+++ b/drivers/amlogic/amvecm/amve.c
@@ -14,25 +14,33 @@
 #include <linux/string.h>
 #include <linux/spinlock.h>
 #include <linux/module.h>
-
-
 #include <mach/am_regs.h>
 #include <linux/amlogic/amstream.h>
 #include <linux/amlogic/ve.h>
-
 #include <linux/amlogic/aml_common.h>
 #include <linux/amlogic/vframe.h>
+#include <linux/amlogic/amvecm.h>
 
 #include "ve_regs.h"
 #include "amve.h"
+#include "amve_gamma_table.h"
+
+#define pr_amve_dbg(fmt, args...)\
+	do{\
+		if(dnlp_debug)\
+			printk("AMVECM: " fmt, ## args);\
+	}while(0)
+#define pr_amve_error(fmt, args...) printk("AMVECM: " fmt, ## args)
+
 
 // 0: Invalid
 // 1: Valid
 // 2: Updated in 2D mode
 // 3: Updated in 3D mode
 unsigned long flags;
-//#define NEW_DNLP_AFTER_PEAKING
-
+#if (MESON_CPU_TYPE>=MESON_CPU_TYPE_MESONG9TV)
+#define NEW_DNLP_IN_SHARPNESS
+#endif
 struct ve_hist_s video_ve_hist;
 
 static unsigned char ve_dnlp_tgt[64];
@@ -44,12 +52,29 @@ unsigned int ve_dnlp_black;
 unsigned int ve_dnlp_white;
 unsigned int ve_dnlp_luma_sum;
 static ulong ve_dnlp_lpf[64], ve_dnlp_reg[16];
+unsigned int ve_size;
 
 static bool frame_lock_nosm = 1;
 static int ve_dnlp_waist_h = 128;
 static int ve_dnlp_waist_l = 128;
 static int ve_dnlp_ankle = 16;
 static int ve_dnlp_strength = 255;
+unsigned int vpp_log[128][10];
+struct ve_dnlp_s am_ve_dnlp;
+struct ve_dnlp_table_s am_ve_new_dnlp;
+static unsigned int lock_range_50hz_fast =  7; // <= 14
+static unsigned int lock_range_50hz_slow =  7; // <= 14
+static unsigned int lock_range_60hz_fast =  5; // <=  4
+static unsigned int lock_range_60hz_slow =  2; // <= 10
+struct tcon_gamma_table_s video_gamma_table_r;
+struct tcon_gamma_table_s video_gamma_table_g;
+struct tcon_gamma_table_s video_gamma_table_b;
+struct tcon_gamma_table_s video_gamma_table_r_adj;
+struct tcon_gamma_table_s video_gamma_table_g_adj;
+struct tcon_gamma_table_s video_gamma_table_b_adj;
+struct tcon_rgb_ogo_s     video_rgb_ogo;
+
+#define FLAG_LVDS_FREQ_SW1       (1 <<  6)
 
 module_param(ve_dnlp_waist_h, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_waist_h, "ve_dnlp_waist_h");
@@ -103,177 +128,152 @@ static int dnlp_adj_level = 6;
 module_param(dnlp_adj_level, int, 0664);
 MODULE_PARM_DESC(dnlp_adj_level, "dnlp_adj_level");
 
+static int dnlp_en = 0;//0:disabel;1:enable
+module_param(dnlp_en, int, 0664);
+MODULE_PARM_DESC(dnlp_en, "\n enable or disable dnlp \n");
+static int dnlp_status = 1;//0:done;1:todo
+
+static int frame_lock_freq = 0;
+module_param(frame_lock_freq, int, 0664);
+MODULE_PARM_DESC(frame_lock_freq, "frame_lock_50");
+
+static int video_rgb_ogo_mode_sw = 0;
+module_param(video_rgb_ogo_mode_sw, int, 0664);
+MODULE_PARM_DESC(video_rgb_ogo_mode_sw, "enable/disable video_rgb_ogo_mode_sw");
+
 // ***************************************************************************
 // *** VPP_FIQ-oriented functions *********************************************
 // ***************************************************************************
 static void ve_hist_gamma_tgt(vframe_t *vf)
 {
-    struct vframe_prop_s *p = &vf->prop;
-    video_ve_hist.sum    = p->hist.luma_sum;
-    video_ve_hist.width  = p->hist.width;
-    video_ve_hist.height = p->hist.height;
+	struct vframe_prop_s *p = &vf->prop;
+	video_ve_hist.sum    = p->hist.luma_sum;
+	video_ve_hist.width  = p->hist.width;
+	video_ve_hist.height = p->hist.height;
 }
 
 static void ve_dnlp_calculate_tgt_ext(vframe_t *vf)
 {
-    struct vframe_prop_s *p = &vf->prop;
+	struct vframe_prop_s *p = &vf->prop;
 	static unsigned int sum_b = 0, sum_c = 0;
-    ulong i = 0, j = 0, sum = 0, ave = 0, ankle = 0, waist = 0, peak = 0, start = 0;
-    ulong qty_h = 0, qty_l = 0, ratio_h = 0, ratio_l = 0;
-    ulong div1  = 0, div2  = 0, step_h  = 0, step_l  = 0;
-    ulong data[55];
-    bool  flag[55], previous_state_high = false;
+	ulong i = 0, j = 0, sum = 0, ave = 0, ankle = 0, waist = 0, peak = 0, start = 0;
+	ulong qty_h = 0, qty_l = 0, ratio_h = 0, ratio_l = 0;
+	ulong div1  = 0, div2  = 0, step_h  = 0, step_l  = 0;
+	ulong data[55];
+	bool  flag[55], previous_state_high = false;
 	unsigned int cnt = READ_CBUS_REG(ASSIST_SPARE8_REG1);
-
-    // old historic luma sum
-    sum_b = sum_c;
-    sum_c = ve_dnlp_luma_sum;
-    // new historic luma sum
-    ve_dnlp_luma_sum = p->hist.luma_sum;
-	if(dnlp_debug)
-	printk("ve_dnlp_luma_sum=%x,sum_b=%x,sum_c=%x\n",ve_dnlp_luma_sum,sum_b,sum_c);
-
-    // picture mode: freeze dnlp curve
-    if(dnlp_respond)
-    {
-		if (// new luma sum is 0, something is wrong, freeze dnlp curve
-			(!ve_dnlp_luma_sum)
-		   )
-		return;
-    }
-	else
-	{
-	    if (// new luma sum is 0, something is wrong, freeze dnlp curve
-	        (!ve_dnlp_luma_sum) ||
-	        // new luma sum is closed to old one (1 +/- 1/64), picture mode, freeze curve
-	        ((ve_dnlp_luma_sum < sum_b + (sum_b >> dnlp_adj_level)) &&
-	         (ve_dnlp_luma_sum > sum_b - (sum_b>> dnlp_adj_level))
-	        )
-	       )
-	    return;
+	// old historic luma sum
+	sum_b = sum_c;
+	sum_c = ve_dnlp_luma_sum;
+	// new historic luma sum
+	ve_dnlp_luma_sum = p->hist.luma_sum;
+	pr_amve_dbg("ve_dnlp_luma_sum=%x,sum_b=%x,sum_c=%x\n",ve_dnlp_luma_sum,sum_b,sum_c);
+	// picture mode: freeze dnlp curve
+	if(dnlp_respond){
+		if(!ve_dnlp_luma_sum)// new luma sum is 0, something is wrong, freeze dnlp curve
+			return;
+	}else{
+		if((!ve_dnlp_luma_sum) ||// new luma sum is 0, something is wrong, freeze dnlp curve
+			// new luma sum is closed to old one (1 +/- 1/64), picture mode, freeze curve
+			((ve_dnlp_luma_sum < sum_b + (sum_b >> dnlp_adj_level)) &&
+			(ve_dnlp_luma_sum > sum_b - (sum_b>> dnlp_adj_level))))
+			return;
 	}
-
-    // calculate ave (55 times of ave & data[] for accuracy)
-    // ave    22-bit
-    // data[] 22-bit
-    //printk("ankle=%d,waist_h=%d,waist_l=%d,strenth=%d\n",ve_dnlp_ankle,ve_dnlp_waist_h,ve_dnlp_waist_l,ve_dnlp_strength);
-    ave = 0;
-    for (i = 0; i < 55; i++)
-    {
-        data[i]  = (ulong)p->hist.gamma[i + 4];
-        ave     += data[i];
-        data[i] *= 55;
-        flag[i]  = false;
-    }
-
-    // calculate ankle
-    // ankle 22-bit
-    // waist 22-bit
-    // qty_h 6-bit
-    ankle = (ave * ve_dnlp_ankle+ 128) >> 8;
-
-    // scan data[] to find out waist pulses
-    qty_h = 0;
-    previous_state_high = false;
-    for (i = 0; i < 55; i++)
-    {
-        if (data[i] >= ankle)
-        {
-            // ankle pulses start
-            if (!previous_state_high)
-            {
-                previous_state_high = true;
-                start = i;
-                peak = 0;
-            }
-            // normal maintenance
-            if (peak < data[i])
-                peak = data[i];
-        }
-        else
-        {
-            // ankle pulses end + 1
-            if (previous_state_high)
-            {
-                previous_state_high = false;
-                // calculate waist of high area pulses
-                if (peak >= ave)
-                    waist = ((peak - ankle) * ve_dnlp_waist_h + 128) >> 8;
-	                // calculate waist of high area pulses
-	                else
-	                    waist = ((peak - ankle) * ve_dnlp_waist_l + 128) >> 8;
-	                // find out waist pulses
-	                for (j = start; j < i; j++)
-	                {
-	                    if (data[j] >= waist)
-	                    {
-	                        flag[j] = true;
-	                        qty_h++;
-	                    }
-	                }
-	            }
-        }
-    }
-
-    // calculate ratio_h and ratio_l (div2 = 512*H*L times of value for accuracy)
-    // averaged duty > 1/3
-    // qty_l 6-bit
-    // div1 20-bit
-    // div2 21-bit
-    // ratio_h 22-bit
-    // ratio_l 21-bit
-    qty_l =  55 - qty_h;
-	if ((!qty_h) || (!qty_l))
-		{
-			for (i = 5; i <= 58; i++)
-			{
-				ve_dnlp_tgt[i] = i << 2;
+	// calculate ave (55 times of ave & data[] for accuracy)
+	// ave    22-bit
+	// data[] 22-bit
+	ave = 0;
+	for(i = 0; i < 55; i++){
+		data[i]  = (ulong)p->hist.gamma[i + 4];
+		ave     += data[i];
+		data[i] *= 55;
+		flag[i]  = false;
+	}
+	// calculate ankle
+	// ankle 22-bit
+	// waist 22-bit
+	// qty_h 6-bit
+	ankle = (ave * ve_dnlp_ankle+ 128) >> 8;
+	// scan data[] to find out waist pulses
+	qty_h = 0;
+	previous_state_high = false;
+	for(i = 0; i < 55; i++){
+		if(data[i] >= ankle){
+			// ankle pulses start
+			if(!previous_state_high){
+				previous_state_high = true;
+				start = i;
+				peak = 0;
 			}
+			// normal maintenance
+			if (peak < data[i])
+				peak = data[i];
 		}
-	else
-		{
-		    div1  = 256 * qty_h * qty_l;
-		    div2  = 512 * qty_h * qty_l;
-		    if (qty_h > 18)
-		    {
-		        ratio_h = div2 + ve_dnlp_strength * qty_l * qty_l; // [1.0 ~ 2.0)
-		        ratio_l = div2 - ve_dnlp_strength * qty_h * qty_l; // [0.5 ~ 1.0]
-		    }
-		    // averaged duty < 1/3
-		    {
-		        ratio_h = div2 + (ve_dnlp_strength << 1) * qty_h * qty_l; // [1.0 ~ 2.0]
-		        ratio_l = div2 - (ve_dnlp_strength << 1) * qty_h * qty_h; // (0.5 ~ 1.0]
-		    }
-
-		    // distribute ratio_h & ratio_l to ve_dnlp_tgt[5] ~ ve_dnlp_tgt[58]
-		    // sum 29-bit
-		    // step_h 24-bit
-		    // step_l 23-bit
+		else{
+			// ankle pulses end + 1
+			if(previous_state_high){
+				previous_state_high = false;
+				// calculate waist of high area pulses
+				if (peak >= ave)
+					waist = ((peak - ankle) * ve_dnlp_waist_h + 128) >> 8;
+				// calculate waist of high area pulses
+				else
+					waist = ((peak - ankle) * ve_dnlp_waist_l + 128) >> 8;
+				// find out waist pulses
+				for (j = start; j < i; j++){
+					if (data[j] >= waist){
+						flag[j] = true;
+						qty_h++;
+					}
+				}
+			}
+		}
+	}
 
-		    sum = div2 << 4; // start from 16
-		    step_h = ratio_h << 2;
-		    step_l = ratio_l << 2;
-		    for (i = 5; i <= 58; i++)
-		    {
-		        // high phase
-		        if (flag[i - 5])
-		            sum += step_h;
-		        // low  phase
-		        else
-		            sum += step_l;
-		        ve_dnlp_tgt[i] = (sum + div1) / div2;
-		    }
-			if(cnt)
-			{
+	// calculate ratio_h and ratio_l (div2 = 512*H*L times of value for accuracy)
+	// averaged duty > 1/3
+	// qty_l 6-bit
+	// div1 20-bit
+	// div2 21-bit
+	// ratio_h 22-bit
+	// ratio_l 21-bit
+	qty_l =  55 - qty_h;
+	if((!qty_h) || (!qty_l)){
+		for (i = 5; i <= 58; i++){
+			ve_dnlp_tgt[i] = i << 2;
+		}
+	}else{
+		div1  = 256 * qty_h * qty_l;
+		div2  = 512 * qty_h * qty_l;
+		if (qty_h > 18){
+			ratio_h = div2 + ve_dnlp_strength * qty_l * qty_l; // [1.0 ~ 2.0)
+			ratio_l = div2 - ve_dnlp_strength * qty_h * qty_l; // [0.5 ~ 1.0]
+		}
+		// averaged duty < 1/3
+		ratio_h = div2 + (ve_dnlp_strength << 1) * qty_h * qty_l; // [1.0 ~ 2.0]
+		ratio_l = div2 - (ve_dnlp_strength << 1) * qty_h * qty_h; // (0.5 ~ 1.0]
+		// distribute ratio_h & ratio_l to ve_dnlp_tgt[5] ~ ve_dnlp_tgt[58]
+		// sum 29-bit
+		// step_h 24-bit
+		// step_l 23-bit
+		sum = div2 << 4; // start from 16
+		step_h = ratio_h << 2;
+		step_l = ratio_l << 2;
+		for (i = 5; i <= 58; i++){
+			// high phase
+			if (flag[i - 5])
+				sum += step_h;
+			// low  phase
+			else
+				sum += step_l;
+			ve_dnlp_tgt[i] = (sum + div1) / div2;
+		}
+		if(cnt){
 			for(i=0;i<64;i++)
-				printk(" ve_dnlp_tgte[%ld]=%d\n",i,ve_dnlp_tgt[i]);
+				pr_amve_dbg(" ve_dnlp_tgte[%ld]=%d\n",i,ve_dnlp_tgt[i]);
 			WRITE_CBUS_REG(ASSIST_SPARE8_REG1, 0);
-			}
 		}
-
-    // calculate black extension
-
-    // calculate white extension
+	}
 }
 
 void GetWgtLst(ulong *iHst, ulong tAvg, ulong nLen, ulong alpha)
@@ -282,55 +282,41 @@ void GetWgtLst(ulong *iHst, ulong tAvg, ulong nLen, ulong alpha)
 	ulong iMin=0;
 	ulong iPxl=0;
 	ulong iT=0;
-
-	for(iT=0;iT<nLen;iT++)
-	{
+	for(iT=0;iT<nLen;iT++){
 		iPxl = iHst[iT];
-		if(iPxl>tAvg)
-		{
+		if(iPxl>tAvg){
 			iMax=iPxl;
 			iMin=tAvg;
-		}
-		else
-		{
+		}else{
 			iMax=tAvg;
 			iMin=iPxl;
 		}
-
-		if(alpha<16)
-		{
+		if(alpha<16){
 			iPxl = ((16-alpha)*iMin+8)>>4;
 			iPxl += alpha*iMin;
-		}
-		else if(alpha<32)
-		{
+		}else if(alpha<32){
 			iPxl = (32-alpha)*iMin;
 			iPxl += (alpha-16)*iMax;
-		}
-		else
-		{
+		}else{
 			iPxl = (48-alpha)+4*(alpha-32);
 			iPxl *= iMax;
 		}
-
 		iPxl = (iPxl+8)>>4;
-
 		iHst[iT] = iPxl<1 ? 1 : iPxl;
 	}
 }
 
 static void ve_dnlp_calculate_tgtx(vframe_t *vf)
 {
-    struct vframe_prop_s *p = &vf->prop;
-    ulong iHst[64];
-    ulong oHst[64];
+	struct vframe_prop_s *p = &vf->prop;
+	ulong iHst[64];
+	ulong oHst[64];
 	static unsigned int sum_b = 0, sum_c = 0;
-    ulong i = 0, j = 0, sum = 0, max = 0;
+	ulong i = 0, j = 0, sum = 0, max = 0;
 	ulong cLmt=0, nStp=0, stp=0, uLmt=0;
 	long nExc=0;
 	unsigned int cnt = READ_CBUS_REG(ASSIST_SPARE8_REG1);
 	unsigned int cnt2 = READ_CBUS_REG(ASSIST_SPARE8_REG2);
-
 	unsigned int clip_rate = ve_dnlp_cliprate; //8bit
 	unsigned int low_range = ve_dnlp_lowrange;//18; //6bit [0-54]
 	unsigned int hgh_range = ve_dnlp_hghrange;//18; //6bit [0-54]
@@ -341,418 +327,344 @@ static void ve_dnlp_calculate_tgtx(vframe_t *vf)
 	ulong tAvg=0;
 	ulong nPnt=0;
 	ulong mRng=0;
-
-
-    // old historic luma sum
-    sum_b = sum_c;
-    sum_c = ve_dnlp_luma_sum;
-    // new historic luma sum
-    ve_dnlp_luma_sum = p->hist.luma_sum;
-	if(dnlp_debug)
-	printk("ve_dnlp_luma_sum=%x,sum_b=%x,sum_c=%x\n",ve_dnlp_luma_sum,sum_b,sum_c);
-
-    // picture mode: freeze dnlp curve
-    if(dnlp_respond)
-    {
-		if (// new luma sum is 0, something is wrong, freeze dnlp curve
-			(!ve_dnlp_luma_sum)
-		   )
-		return;
-    }
-	else
-	{
-	    if (// new luma sum is 0, something is wrong, freeze dnlp curve
-	        (!ve_dnlp_luma_sum) ||
-	        // new luma sum is closed to old one (1 +/- 1/64), picture mode, freeze curve
-	        ((ve_dnlp_luma_sum < sum_b + (sum_b >> dnlp_adj_level)) &&
-	         (ve_dnlp_luma_sum > sum_b - (sum_b >> dnlp_adj_level))
-	        )
-	       )
-	    return;
+	// old historic luma sum
+	sum_b = sum_c;
+	sum_c = ve_dnlp_luma_sum;
+	// new historic luma sum
+	ve_dnlp_luma_sum = p->hist.luma_sum;
+	pr_amve_dbg("ve_dnlp_luma_sum=%x,sum_b=%x,sum_c=%x\n",ve_dnlp_luma_sum,sum_b,sum_c);
+	// picture mode: freeze dnlp curve
+	if(dnlp_respond){
+		if(!ve_dnlp_luma_sum)// new luma sum is 0, something is wrong, freeze dnlp curve
+			return;
+	}else{
+		if((!ve_dnlp_luma_sum) ||// new luma sum is 0, something is wrong, freeze dnlp curve
+			// new luma sum is closed to old one (1 +/- 1/64), picture mode, freeze curve
+			((ve_dnlp_luma_sum < sum_b + (sum_b >> dnlp_adj_level)) &&
+			(ve_dnlp_luma_sum > sum_b - (sum_b >> dnlp_adj_level))))
+			return;
 	}
-
-    // 64 bins, max, ave
-    for (i = 0; i < 64; i++)
-    {
-        iHst[i] = (ulong)p->hist.gamma[i];
-
-		if(i>=4 && i<=58) { //55 bins
+	// 64 bins, max, ave
+	for (i = 0; i < 64; i++){
+		iHst[i] = (ulong)p->hist.gamma[i];
+		if(i>=4 && i<=58){ //55 bins
 			oHst[i] = iHst[i];
-
-			if (max < iHst[i])
+			if(max < iHst[i])
 				max = iHst[i];
 			sum += iHst[i];
 		}
 		else {
 			oHst[i] = 0;
 		}
-    }
+	}
 	cLmt = (clip_rate*sum)>>8;
 	tAvg = sum/55;
-
-
-    // invalid histgram: freeze dnlp curve
-    if (max<=55)
-        return;
-
-    // get 1st 4 points
-    for (i = 4; i <= 58; i++)
-    {
+	// invalid histgram: freeze dnlp curve
+	if (max<=55)
+		return;
+	// get 1st 4 points
+	for (i = 4; i <= 58; i++){
 		if(iHst[i]>cLmt)
 			nExc += (iHst[i]-cLmt);
-    }
+	}
 	nStp = (nExc+28)/55;
 	uLmt = cLmt-nStp;
-    if(cnt2)
-    	{
-	    printk(" ve_dnlp_tgtx:cLmt=%ld,nStp=%ld,uLmt=%ld\n",cLmt,nStp,uLmt);
+	if(cnt2){
+		pr_amve_dbg(" ve_dnlp_tgtx:cLmt=%ld,nStp=%ld,uLmt=%ld\n",cLmt,nStp,uLmt);
 		WRITE_CBUS_REG(ASSIST_SPARE8_REG2, 0);
-    	}
-    if(clip_rate<=4 || tAvg<=2)
-    {
-        cLmt = (sum+28)/55;
-        sum = cLmt*55;
-
-        for(i=4; i<=58; i++)
-        {
-             oHst[i] = cLmt;
-        }
-    }
-    else if(nStp!=0)
-    {
-		for(i=4; i<=58; i++)
-			{
-				if(iHst[i]>=cLmt)
+	}
+	if(clip_rate<=4 || tAvg<=2){
+		cLmt = (sum+28)/55;
+		sum = cLmt*55;
+		for(i=4; i<=58; i++){
+			oHst[i] = cLmt;
+		}
+	}else if(nStp!=0){
+		for(i=4; i<=58; i++){
+			if(iHst[i]>=cLmt)
+				oHst[i] = cLmt;
+			else{
+				if(iHst[i]>uLmt){
 					oHst[i] = cLmt;
-				else {
-					if(iHst[i]>uLmt)
-					{
-						oHst[i] = cLmt;
-						nExc -= cLmt-iHst[i];
-					}
-					else
-					{
-						oHst[i] = iHst[i]+nStp;
-						nExc -= nStp;
-					}
-                    if(nExc<0 )
-					nExc = 0;
+					nExc -= cLmt-iHst[i];
+				}else{
+					oHst[i] = iHst[i]+nStp;
+					nExc -= nStp;
 				}
+				if(nExc<0 )
+				nExc = 0;
 			}
-
-        j=4;
-        while(nExc>0) {
-            if(nExc>=55)
-            {
-                nStp = 1;
-                stp = nExc/55;
-            }
-            else
-            {
-                nStp = 55/nExc;
-                stp = 1;
-            }
-            for(i=j;i<=58;i+=nStp)
-			{
-                if(oHst[i]<cLmt)
-                {
-                    oHst[i] += stp;
-                    nExc -= stp;
-                }
-                if(nExc<=0)
-                    break;
-            }
-            j += 1;
-            if(j>58)
-                break;
-        }
-    }
+		}
+		j=4;
+		while(nExc>0) {
+			if(nExc>=55){
+				nStp = 1;
+				stp = nExc/55;
+			}else{
+				nStp = 55/nExc;
+				stp = 1;
+			}
+			for(i=j;i<=58;i+=nStp){
+				if(oHst[i]<cLmt){
+					oHst[i] += stp;
+					nExc -= stp;
+				}
+				if(nExc<=0)
+					break;
+			}
+			j += 1;
+			if(j>58)
+				break;
+		}
+	}
 	if(low_range==0 && hgh_range==0)
 		nPnt = 0;
-	else
-	{
-		if(low_range==0 || hgh_range==0)
-		{
+	else{
+		if(low_range==0 || hgh_range==0){
 			nPnt = 1;
 			mRng = (hgh_range>low_range ? hgh_range : low_range); //max
-		}
-		else if(low_range+hgh_range>=54)
-		{
+		}else if(low_range+hgh_range>=54){
 			nPnt = 1;
 			mRng = (hgh_range<low_range ? hgh_range : low_range); //min
-		}
-		else
+		}else
 			nPnt = 2;
 	}
-	if(nPnt==0 && low_alpha>=16 && low_alpha<=32)
-	{
+	if(nPnt==0 && low_alpha>=16 && low_alpha<=32){
 		sum = 0;
-		for(i=5;i<=59;i++)
-		{
+		for(i=5;i<=59;i++){
 			j = oHst[i]*(32-low_alpha)+tAvg*(low_alpha-16);
 			j = (j+8)>>4;
 			oHst[i] = j;
 			sum += j;
-			}
-    	}
-	else if(nPnt==1)
-	{
+		}
+	}else if(nPnt==1){
 		GetWgtLst(oHst+4, tAvg, mRng, low_alpha);
 		GetWgtLst(oHst+4+mRng, tAvg, 54-mRng, hgh_alpha);
-	}
-	else if(nPnt==2)
-	{
+	}else if(nPnt==2){
 		mRng = 55-(low_range+hgh_range);
 		GetWgtLst(oHst+4, tAvg, low_range, low_alpha);
 		GetWgtLst(oHst+4+low_range, tAvg, mRng, mid_alpha);
 		GetWgtLst(oHst+4+mRng+low_range, tAvg, hgh_range, hgh_alpha);
 	}
 	sum=0;
-	for(i=4;i<=58;i++)
-	{
+	for(i=4;i<=58;i++){
 		if(oHst[i]>cLmt)
 			oHst[i] = cLmt;
 		sum += oHst[i];
 	}
-
 	nStp = 0;
 	//sum -= oHst[4];
-	for(i=5;i<=59;i++)//5,59
-	{
+	for(i=5;i<=59;i++){//5,59
 		nStp += oHst[i-1];
 		//nStp += oHst[i];
-
 		j = (236-16)*nStp;
 		j += (sum>>1);
 		j /= sum;
-
 		ve_dnlp_tgt[i] = j + 16;
 	}
-	if(cnt)
-	{
-	for(i=0;i<64;i++)
-		printk(" ve_dnlp_tgtx[%ld]=%d\n",i,ve_dnlp_tgt[i]);
-	WRITE_CBUS_REG(ASSIST_SPARE8_REG1, 0);
+	if(cnt){
+		for(i=0;i<64;i++)
+			pr_amve_dbg(" ve_dnlp_tgtx[%ld]=%d\n",i,ve_dnlp_tgt[i]);
+		WRITE_CBUS_REG(ASSIST_SPARE8_REG1, 0);
 	}
 	return;
 }
 
 static void ve_dnlp_calculate_tgt(vframe_t *vf)
 {
-    struct vframe_prop_s *p = &vf->prop;
-    ulong data[5];
+	struct vframe_prop_s *p = &vf->prop;
+	ulong data[5];
 	static unsigned int sum_b = 0, sum_c = 0;
-    ulong i = 0, j = 0, ave = 0, max = 0, div = 0;
+	ulong i = 0, j = 0, ave = 0, max = 0, div = 0;
 	unsigned int cnt = READ_CBUS_REG(ASSIST_SPARE8_REG1);
-
-    // old historic luma sum
-    sum_b = sum_c;
-    sum_c = ve_dnlp_luma_sum;
-    // new historic luma sum
-    ve_dnlp_luma_sum = p->hist.luma_sum;
-	if(dnlp_debug)
-	printk("ve_dnlp_luma_sum=%x,sum_b=%x,sum_c=%x\n",ve_dnlp_luma_sum,sum_b,sum_c);
-
-    // picture mode: freeze dnlp curve
-    if(dnlp_respond)
-    {
-		if (// new luma sum is 0, something is wrong, freeze dnlp curve
-			(!ve_dnlp_luma_sum)
-		   )
-	    return;
-    }
-	else
-	{
-	    if (// new luma sum is 0, something is wrong, freeze dnlp curve
-	        (!ve_dnlp_luma_sum) ||
-	        // new luma sum is closed to old one (1 +/- 1/64), picture mode, freeze curve
-	        ((ve_dnlp_luma_sum < sum_b + (sum_b >> dnlp_adj_level)) &&//5
-	         (ve_dnlp_luma_sum > sum_b - (sum_b >> dnlp_adj_level)) //5
-	        )
-	       )
-	    return;
+	// old historic luma sum
+	sum_b = sum_c;
+	sum_c = ve_dnlp_luma_sum;
+	// new historic luma sum
+	ve_dnlp_luma_sum = p->hist.luma_sum;
+	pr_amve_dbg("ve_dnlp_luma_sum=%x,sum_b=%x,sum_c=%x\n",ve_dnlp_luma_sum,sum_b,sum_c);
+	// picture mode: freeze dnlp curve
+	if(dnlp_respond){
+		if (!ve_dnlp_luma_sum)// new luma sum is 0, something is wrong, freeze dnlp curve
+			return;
+	}else{
+		if ((!ve_dnlp_luma_sum) ||// new luma sum is 0, something is wrong, freeze dnlp curve
+			// new luma sum is closed to old one (1 +/- 1/64), picture mode, freeze curve
+			((ve_dnlp_luma_sum < sum_b + (sum_b >> dnlp_adj_level)) &&//5
+			(ve_dnlp_luma_sum > sum_b - (sum_b >> dnlp_adj_level))))//5
+			return;
 	}
-
-    // get 5 regions
-    for (i = 0; i < 5; i++)
-    {
-        j = 4 + 11 * i;
-        data[i] = (ulong)p->hist.gamma[j     ] +
-                  (ulong)p->hist.gamma[j +  1] +
-                  (ulong)p->hist.gamma[j +  2] +
-                  (ulong)p->hist.gamma[j +  3] +
-                  (ulong)p->hist.gamma[j +  4] +
-                  (ulong)p->hist.gamma[j +  5] +
-                  (ulong)p->hist.gamma[j +  6] +
-                  (ulong)p->hist.gamma[j +  7] +
-                  (ulong)p->hist.gamma[j +  8] +
-                  (ulong)p->hist.gamma[j +  9] +
-                  (ulong)p->hist.gamma[j + 10];
-    }
-
-    // get max, ave, div
-    for (i = 0; i < 5; i++)
-    {
-        if (max < data[i])
-            max = data[i];
-        ave += data[i];
-        data[i] *= 5;
-    }
-    max *= 5;
-    div = (max - ave > ave) ? max - ave : ave;
-
-    // invalid histgram: freeze dnlp curve
-    if (!max)
-        return;
-
-    // get 1st 4 points
-    for (i = 0; i < 4; i++)
-    {
-        if (data[i] > ave)
-            data[i] = 64 + (((data[i] - ave) << 1) + div) * ve_dnlp_rl / (div << 1);
-        else if (data[i] < ave)
-            data[i] = 64 - (((ave - data[i]) << 1) + div) * ve_dnlp_rl / (div << 1);
-        else
-            data[i] = 64;
-        ve_dnlp_tgt[4 + 11 * (i + 1)] = ve_dnlp_tgt[4 + 11 * i] +
-                                        ((44 * data[i] + 32) >> 6);
-    }
-
-    // fill in region 0 with black extension
-    data[0] = ve_dnlp_black;
-    if (data[0] > 16)
-        data[0] = 16;
-    data[0] = (ve_dnlp_tgt[15] - ve_dnlp_tgt[4]) * (16 - data[0]);
-    for (j = 1; j <= 6; j++)
-        ve_dnlp_tgt[4 + j] = ve_dnlp_tgt[4] + (data[0] * j + 88) / 176;
-    data[0] = (ve_dnlp_tgt[15] - ve_dnlp_tgt[10]) << 1;
-    for (j = 1; j <=4; j++)
-        ve_dnlp_tgt[10 + j] = ve_dnlp_tgt[10] + (data[0] * j + 5) / 10;
-
-    // fill in regions 1~3
-    for (i = 1; i <= 3; i++)
-    {
-        data[i] = (ve_dnlp_tgt[11 * i + 15] - ve_dnlp_tgt[11 * i + 4]) << 1;
-        for (j = 1; j <= 10; j++)
-            ve_dnlp_tgt[11 * i + 4 + j] = ve_dnlp_tgt[11 * i + 4] + (data[i] * j + 11) / 22;
-    }
-
-    // fill in region 4 with white extension
-    data[4] /= 20;
-    data[4] = (ve_dnlp_white * ((ave << 4) - data[4] * ve_dnlp_white_factor)  + (ave << 3)) / (ave << 4);
-    if (data[4] > 16)
-        data[4] = 16;
-    data[4] = (ve_dnlp_tgt[59] - ve_dnlp_tgt[48]) * (16 - data[4]);
-    for (j = 1; j <= 6; j++)
-        ve_dnlp_tgt[59 - j] = ve_dnlp_tgt[59] - (data[4] * j + 88) / 176;
-    data[4] = (ve_dnlp_tgt[53] - ve_dnlp_tgt[48]) << 1;
-    for (j = 1; j <= 4; j++)
-        ve_dnlp_tgt[53 - j] = ve_dnlp_tgt[53] - (data[4] * j + 5) / 10;
-	if(cnt)
-	{
-	for(i=0;i<64;i++)
-		printk(" ve_dnlp_tgt[%ld]=%d\n",i,ve_dnlp_tgt[i]);
-	WRITE_CBUS_REG(ASSIST_SPARE8_REG1, 0);
+	// get 5 regions
+	for (i = 0; i < 5; i++){
+		j = 4 + 11 * i;
+		data[i] = (ulong)p->hist.gamma[j] +
+		(ulong)p->hist.gamma[j +  1] +
+		(ulong)p->hist.gamma[j +  2] +
+		(ulong)p->hist.gamma[j +  3] +
+		(ulong)p->hist.gamma[j +  4] +
+		(ulong)p->hist.gamma[j +  5] +
+		(ulong)p->hist.gamma[j +  6] +
+		(ulong)p->hist.gamma[j +  7] +
+		(ulong)p->hist.gamma[j +  8] +
+		(ulong)p->hist.gamma[j +  9] +
+		(ulong)p->hist.gamma[j + 10];
+	}
+	// get max, ave, div
+	for (i = 0; i < 5; i++){
+		if (max < data[i])
+			max = data[i];
+		ave += data[i];
+		data[i] *= 5;
+	}
+	max *= 5;
+	div = (max - ave > ave) ? max - ave : ave;
+	// invalid histgram: freeze dnlp curve
+	if(!max)
+		return;
+	// get 1st 4 points
+	for(i = 0; i < 4; i++){
+		if (data[i] > ave)
+			data[i] = 64 + (((data[i] - ave) << 1) + div) * ve_dnlp_rl / (div << 1);
+		else if (data[i] < ave)
+			data[i] = 64 - (((ave - data[i]) << 1) + div) * ve_dnlp_rl / (div << 1);
+		else
+			data[i] = 64;
+		ve_dnlp_tgt[4 + 11 * (i + 1)] = ve_dnlp_tgt[4 + 11 * i] +
+		        ((44 * data[i] + 32) >> 6);
+	}
+	// fill in region 0 with black extension
+	data[0] = ve_dnlp_black;
+	if (data[0] > 16)
+		data[0] = 16;
+	data[0] = (ve_dnlp_tgt[15] - ve_dnlp_tgt[4]) * (16 - data[0]);
+	for (j = 1; j <= 6; j++)
+		ve_dnlp_tgt[4 + j] = ve_dnlp_tgt[4] + (data[0] * j + 88) / 176;
+	data[0] = (ve_dnlp_tgt[15] - ve_dnlp_tgt[10]) << 1;
+	for (j = 1; j <=4; j++)
+		ve_dnlp_tgt[10 + j] = ve_dnlp_tgt[10] + (data[0] * j + 5) / 10;
+	// fill in regions 1~3
+	for (i = 1; i <= 3; i++){
+		data[i] = (ve_dnlp_tgt[11 * i + 15] - ve_dnlp_tgt[11 * i + 4]) << 1;
+		for (j = 1; j <= 10; j++)
+			ve_dnlp_tgt[11 * i + 4 + j] = ve_dnlp_tgt[11 * i + 4] + (data[i] * j + 11) / 22;
+	}
+	// fill in region 4 with white extension
+	data[4] /= 20;
+	data[4] = (ve_dnlp_white * ((ave << 4) - data[4] * ve_dnlp_white_factor)  + (ave << 3)) / (ave << 4);
+	if (data[4] > 16)
+		data[4] = 16;
+	data[4] = (ve_dnlp_tgt[59] - ve_dnlp_tgt[48]) * (16 - data[4]);
+	for (j = 1; j <= 6; j++)
+		ve_dnlp_tgt[59 - j] = ve_dnlp_tgt[59] - (data[4] * j + 88) / 176;
+	data[4] = (ve_dnlp_tgt[53] - ve_dnlp_tgt[48]) << 1;
+	for (j = 1; j <= 4; j++)
+		ve_dnlp_tgt[53 - j] = ve_dnlp_tgt[53] - (data[4] * j + 5) / 10;
+	if(cnt){
+		for(i=0;i<64;i++)
+			pr_amve_dbg(" ve_dnlp_tgt[%ld]=%d\n",i,ve_dnlp_tgt[i]);
+		WRITE_CBUS_REG(ASSIST_SPARE8_REG1, 0);
 	}
-
 }
 
 static void ve_dnlp_calculate_lpf(void) // lpf[0] is always 0 & no need calculation
 {
-    ulong i = 0;
-
-    for (i = 0; i < 64; i++) {
-        ve_dnlp_lpf[i] = ve_dnlp_lpf[i] - (ve_dnlp_lpf[i] >> ve_dnlp_rt) + ve_dnlp_tgt[i];
-    }
+	ulong i = 0;
+	for(i = 0; i < 64; i++)
+		ve_dnlp_lpf[i] = ve_dnlp_lpf[i] - (ve_dnlp_lpf[i] >> ve_dnlp_rt) + ve_dnlp_tgt[i];
 }
 
 static void ve_dnlp_calculate_reg(void)
 {
-    ulong i = 0, j = 0, cur = 0, data = 0, offset = ve_dnlp_rt ? (1 << (ve_dnlp_rt - 1)) : 0;
-
-    for (i = 0; i < 16; i++)
-    {
-        ve_dnlp_reg[i] = 0;
-        cur = i << 2;
-        for (j = 0; j < 4; j++)
-        {
-            data = (ve_dnlp_lpf[cur + j] + offset) >> ve_dnlp_rt;
-            if (data > 255)
-                data = 255;
-            ve_dnlp_reg[i] |= data << (j << 3);
-        }
-    }
+	ulong i = 0, j = 0, cur = 0, data = 0, offset = ve_dnlp_rt ? (1 << (ve_dnlp_rt - 1)) : 0;
+	for (i = 0; i < 16; i++){
+		ve_dnlp_reg[i] = 0;
+		cur = i << 2;
+		for (j = 0; j < 4; j++){
+			data = (ve_dnlp_lpf[cur + j] + offset) >> ve_dnlp_rt;
+			if (data > 255)
+				data = 255;
+			ve_dnlp_reg[i] |= data << (j << 3);
+		}
+	}
 }
 
 static void ve_dnlp_load_reg(void)
 {
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_00, ve_dnlp_reg[0]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_01, ve_dnlp_reg[1]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_02, ve_dnlp_reg[2]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_03, ve_dnlp_reg[3]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_04, ve_dnlp_reg[4]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_05, ve_dnlp_reg[5]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_06, ve_dnlp_reg[6]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_07, ve_dnlp_reg[7]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_08, ve_dnlp_reg[8]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_09, ve_dnlp_reg[9]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_10, ve_dnlp_reg[10]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_11, ve_dnlp_reg[11]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_12, ve_dnlp_reg[12]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_13, ve_dnlp_reg[13]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_14, ve_dnlp_reg[14]);
-    WRITE_CBUS_REG(VPP_DNLP_CTRL_15, ve_dnlp_reg[15]);
+#ifdef NEW_DNLP_IN_SHARPNESS
+	WRITE_CBUS_REG(DNLP_00, ve_dnlp_reg[0]);
+	WRITE_CBUS_REG(DNLP_01, ve_dnlp_reg[1]);
+	WRITE_CBUS_REG(DNLP_02, ve_dnlp_reg[2]);
+	WRITE_CBUS_REG(DNLP_03, ve_dnlp_reg[3]);
+	WRITE_CBUS_REG(DNLP_04, ve_dnlp_reg[4]);
+	WRITE_CBUS_REG(DNLP_05, ve_dnlp_reg[5]);
+	WRITE_CBUS_REG(DNLP_06, ve_dnlp_reg[6]);
+	WRITE_CBUS_REG(DNLP_07, ve_dnlp_reg[7]);
+	WRITE_CBUS_REG(DNLP_08, ve_dnlp_reg[8]);
+	WRITE_CBUS_REG(DNLP_09, ve_dnlp_reg[9]);
+	WRITE_CBUS_REG(DNLP_10, ve_dnlp_reg[10]);
+	WRITE_CBUS_REG(DNLP_11, ve_dnlp_reg[11]);
+	WRITE_CBUS_REG(DNLP_12, ve_dnlp_reg[12]);
+	WRITE_CBUS_REG(DNLP_13, ve_dnlp_reg[13]);
+	WRITE_CBUS_REG(DNLP_14, ve_dnlp_reg[14]);
+	WRITE_CBUS_REG(DNLP_15, ve_dnlp_reg[15]);
+#else
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_00, ve_dnlp_reg[0]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_01, ve_dnlp_reg[1]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_02, ve_dnlp_reg[2]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_03, ve_dnlp_reg[3]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_04, ve_dnlp_reg[4]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_05, ve_dnlp_reg[5]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_06, ve_dnlp_reg[6]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_07, ve_dnlp_reg[7]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_08, ve_dnlp_reg[8]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_09, ve_dnlp_reg[9]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_10, ve_dnlp_reg[10]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_11, ve_dnlp_reg[11]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_12, ve_dnlp_reg[12]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_13, ve_dnlp_reg[13]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_14, ve_dnlp_reg[14]);
+	WRITE_CBUS_REG(VPP_DNLP_CTRL_15, ve_dnlp_reg[15]);
+#endif
 }
-static unsigned int lock_range_50hz_fast =  7; // <= 14
-static unsigned int lock_range_50hz_slow =  7; // <= 14
-static unsigned int lock_range_60hz_fast =  5; // <=  4
-static unsigned int lock_range_60hz_slow =  2; // <= 10
-#define FLAG_LVDS_FREQ_SW1       (1 <<  6)
 
 void ve_on_vs(vframe_t *vf)
 {
 
-    if (ve_en) {
-        // calculate dnlp target data
-        if(ve_dnlp_method == 0)
-        ve_dnlp_calculate_tgt(vf);
+	if (ve_en){
+		// calculate dnlp target data
+		if(ve_dnlp_method == 0)
+			ve_dnlp_calculate_tgt(vf);
 		else if(ve_dnlp_method == 1)
-		ve_dnlp_calculate_tgtx(vf);
+			ve_dnlp_calculate_tgtx(vf);
 		else if(ve_dnlp_method == 2)
-		ve_dnlp_calculate_tgt_ext(vf);
+			ve_dnlp_calculate_tgt_ext(vf);
 		else
-        ve_dnlp_calculate_tgt(vf);
-        // calculate dnlp low-pass-filter data
-        ve_dnlp_calculate_lpf();
-        // calculate dnlp reg data
-        ve_dnlp_calculate_reg();
-        // load dnlp reg data
-        ve_dnlp_load_reg();
-    }
+			ve_dnlp_calculate_tgt(vf);
+		// calculate dnlp low-pass-filter data
+		ve_dnlp_calculate_lpf();
+		// calculate dnlp reg data
+		ve_dnlp_calculate_reg();
+		// load dnlp reg data
+		ve_dnlp_load_reg();
+	}
 	ve_hist_gamma_tgt(vf);
-    /* comment for duration algorithm is not based on panel vsync */
-    if (vf->prop.meas.vs_cycle && !frame_lock_nosm)
-    {
-        if ((vecm_latch_flag & FLAG_LVDS_FREQ_SW1) &&
-          (vf->duration >= 1920 - 19) &&
-          (vf->duration <= 1920 + 19)
-         )
-            vpp_phase_lock_on_vs(vf->prop.meas.vs_cycle,
-                                 vf->prop.meas.vs_stamp,
-                                 true,
-                                 lock_range_50hz_fast,
-                                 lock_range_50hz_slow);
-        if ((!(vecm_latch_flag & FLAG_LVDS_FREQ_SW1)) &&
-          (vf->duration >= 1600 - 5) &&
-          (vf->duration <= 1600 + 13)
-         )
-            vpp_phase_lock_on_vs(vf->prop.meas.vs_cycle,
-                                 vf->prop.meas.vs_stamp,
-                                 false,
-                                 lock_range_60hz_fast,
-                                 lock_range_60hz_slow);
-    }
-
+	/* comment for duration algorithm is not based on panel vsync */
+	if (vf->prop.meas.vs_cycle && !frame_lock_nosm){
+		if ((vecm_latch_flag & FLAG_LVDS_FREQ_SW1) &&
+		(vf->duration >= 1920 - 19) &&(vf->duration <= 1920 + 19))
+			vpp_phase_lock_on_vs(vf->prop.meas.vs_cycle,
+				vf->prop.meas.vs_stamp,
+				true,
+				lock_range_50hz_fast,
+				lock_range_50hz_slow);
+		if ((!(vecm_latch_flag & FLAG_LVDS_FREQ_SW1)) &&
+		(vf->duration >= 1600 - 5) &&(vf->duration <= 1600 + 13))
+			vpp_phase_lock_on_vs(vf->prop.meas.vs_cycle,
+				vf->prop.meas.vs_stamp,
+				false,
+				lock_range_60hz_fast,
+				lock_range_60hz_slow);
+	}
 }
 EXPORT_SYMBOL(ve_on_vs);
 
@@ -762,271 +674,460 @@ EXPORT_SYMBOL(ve_on_vs);
 
 void vpp_enable_lcd_gamma_table(void)
 {
-    WRITE_MPEG_REG_BITS(L_GAMMA_CNTL_PORT, 1, GAMMA_EN, 1);
+	WRITE_CBUS_REG_BITS(L_GAMMA_CNTL_PORT, 1, GAMMA_EN, 1);
 }
 
 void vpp_disable_lcd_gamma_table(void)
 {
-    WRITE_MPEG_REG_BITS(L_GAMMA_CNTL_PORT, 0, GAMMA_EN, 1);
+	WRITE_CBUS_REG_BITS(L_GAMMA_CNTL_PORT, 0, GAMMA_EN, 1);
 }
 
 void vpp_set_lcd_gamma_table(u16 *data, u32 rgb_mask)
 {
-    int i;
-
-    while (!(READ_MPEG_REG(L_GAMMA_CNTL_PORT) & (0x1 << ADR_RDY)));
-    WRITE_MPEG_REG(L_GAMMA_ADDR_PORT, (0x1 << H_AUTO_INC) |
-                                    (0x1 << rgb_mask)   |
-                                    (0x0 << HADR));
-    for (i=0;i<256;i++) {
-        while (!( READ_MPEG_REG(L_GAMMA_CNTL_PORT) & (0x1 << WR_RDY) )) ;
-        WRITE_MPEG_REG(L_GAMMA_DATA_PORT, data[i]);
-    }
-    while (!(READ_MPEG_REG(L_GAMMA_CNTL_PORT) & (0x1 << ADR_RDY)));
-    WRITE_MPEG_REG(L_GAMMA_ADDR_PORT, (0x1 << H_AUTO_INC) |
-                                    (0x1 << rgb_mask)   |
-                                    (0x23 << HADR));
+	int i;
+	while (!(READ_CBUS_REG(L_GAMMA_CNTL_PORT) & (0x1 << ADR_RDY)));
+	WRITE_CBUS_REG(L_GAMMA_ADDR_PORT, (0x1 << H_AUTO_INC) |
+	                            (0x1 << rgb_mask)   |
+	                            (0x0 << HADR));
+	for (i=0;i<256;i++){
+		while (!( READ_CBUS_REG(L_GAMMA_CNTL_PORT) & (0x1 << WR_RDY) )) ;
+		WRITE_CBUS_REG(L_GAMMA_DATA_PORT, data[i]);
+	}
+	while (!(READ_CBUS_REG(L_GAMMA_CNTL_PORT) & (0x1 << ADR_RDY)));
+	WRITE_CBUS_REG(L_GAMMA_ADDR_PORT, (0x1 << H_AUTO_INC) |
+	                            (0x1 << rgb_mask)   |
+	                            (0x23 << HADR));
 }
 
 void vpp_set_rgb_ogo(struct tcon_rgb_ogo_s *p)
 {
-
-    // write to registers
-    WRITE_CBUS_REG(VPP_GAINOFF_CTRL0, ((p->en            << 31) & 0x80000000) |
-                                      ((p->r_gain        << 16) & 0x07ff0000) |
-                                      ((p->g_gain        <<  0) & 0x000007ff));
-    WRITE_CBUS_REG(VPP_GAINOFF_CTRL1, ((p->b_gain        << 16) & 0x07ff0000) |
-                                      ((p->r_post_offset <<  0) & 0x000007ff));
-    WRITE_CBUS_REG(VPP_GAINOFF_CTRL2, ((p->g_post_offset << 16) & 0x07ff0000) |
-                                      ((p->b_post_offset <<  0) & 0x000007ff));
-    WRITE_CBUS_REG(VPP_GAINOFF_CTRL3, ((p->r_pre_offset  << 16) & 0x07ff0000) |
-                                      ((p->g_pre_offset  <<  0) & 0x000007ff));
-    WRITE_CBUS_REG(VPP_GAINOFF_CTRL4, ((p->b_pre_offset  <<  0) & 0x000007ff));
-
+	// write to registers
+	WRITE_CBUS_REG(VPP_GAINOFF_CTRL0, ((p->en << 31) & 0x80000000) |
+	                      ((p->r_gain << 16) & 0x07ff0000) |
+	                      ((p->g_gain <<  0) & 0x000007ff));
+	WRITE_CBUS_REG(VPP_GAINOFF_CTRL1, ((p->b_gain        << 16) & 0x07ff0000) |
+	                      ((p->r_post_offset <<  0) & 0x000007ff));
+	WRITE_CBUS_REG(VPP_GAINOFF_CTRL2, ((p->g_post_offset << 16) & 0x07ff0000) |
+	                      ((p->b_post_offset <<  0) & 0x000007ff));
+	WRITE_CBUS_REG(VPP_GAINOFF_CTRL3, ((p->r_pre_offset  << 16) & 0x07ff0000) |
+	                      ((p->g_pre_offset  <<  0) & 0x000007ff));
+	WRITE_CBUS_REG(VPP_GAINOFF_CTRL4, ((p->b_pre_offset  <<  0) & 0x000007ff));
 }
 
 void ve_enable_dnlp(void)
 {
-    ve_en = 1;
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 1, DNLP_EN_BIT, DNLP_EN_WID);
+	ve_en = 1;
+#ifdef NEW_DNLP_IN_SHARPNESS
+	WRITE_CBUS_REG_BITS(DNLP_EN, 1, 0, 1);
+#else
+	WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 1, DNLP_EN_BIT, DNLP_EN_WID);
+#endif
 }
 
 void ve_disable_dnlp(void)
 {
-    ve_en = 0;
-    WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 0, DNLP_EN_BIT, DNLP_EN_WID);
+	ve_en = 0;
+#ifdef NEW_DNLP_IN_SHARPNESS
+	WRITE_CBUS_REG_BITS(DNLP_EN, 0, 0, 1);
+#else
+	WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 0, DNLP_EN_BIT, DNLP_EN_WID);
+#endif
 }
 
 void ve_set_dnlp(struct ve_dnlp_s *p)
 {
-    ulong i = 0;
-
-    // get command parameters
-    ve_en                = p->en;
-    ve_dnlp_white_factor = (p->rt >> 4) & 0xf;
-    ve_dnlp_rt           = p->rt & 0xf;
-    ve_dnlp_rl           = p->rl;
-    ve_dnlp_black        = p->black;
-    ve_dnlp_white        = p->white;
-    if (ve_en)
-    {
-        // clear historic luma sum
-        ve_dnlp_luma_sum = 0;
-        // init tgt & lpf
-        for (i = 0; i < 64; i++) {
-            ve_dnlp_tgt[i] = i << 2;
-            ve_dnlp_lpf[i] = ve_dnlp_tgt[i] << ve_dnlp_rt;
-        }
-        // calculate dnlp reg data
-        ve_dnlp_calculate_reg();
-        // load dnlp reg data
-        ve_dnlp_load_reg();
-#ifdef NEW_DNLP_AFTER_PEAKING
-        // enable dnlp
-        WRITE_CBUS_REG_BITS(VPP_PEAKING_DNLP, 1, PEAKING_DNLP_EN_BIT, PEAKING_DNLP_EN_WID);
-    }
-    else
-    {
-        // disable dnlp
-        WRITE_CBUS_REG_BITS(VPP_PEAKING_DNLP, 0, PEAKING_DNLP_EN_BIT, PEAKING_DNLP_EN_WID);
-    }
+	ulong i = 0;
+	// get command parameters
+	ve_en                = p->en;
+	ve_dnlp_white_factor = (p->rt >> 4) & 0xf;
+	ve_dnlp_rt           = p->rt & 0xf;
+	ve_dnlp_rl           = p->rl;
+	ve_dnlp_black        = p->black;
+	ve_dnlp_white        = p->white;
+	if(ve_en){
+		// clear historic luma sum
+		ve_dnlp_luma_sum = 0;
+		// init tgt & lpf
+		for (i = 0; i < 64; i++){
+			ve_dnlp_tgt[i] = i << 2;
+			ve_dnlp_lpf[i] = ve_dnlp_tgt[i] << ve_dnlp_rt;
+		}
+		// calculate dnlp reg data
+		ve_dnlp_calculate_reg();
+		// load dnlp reg data
+		ve_dnlp_load_reg();
+#ifdef NEW_DNLP_IN_SHARPNESS
+		// enable dnlp
+		WRITE_CBUS_REG_BITS(DNLP_EN, 1, 0, 1);
+	}else{
+		// disable dnlp
+		WRITE_CBUS_REG_BITS(DNLP_EN, 0, 0, 1);
+	}
 #else
-        // enable dnlp
-        WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 1, DNLP_EN_BIT, DNLP_EN_WID);
-    }
-    else
-    {
-        // disable dnlp
-        WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 0, DNLP_EN_BIT, DNLP_EN_WID);
-    }
+	// enable dnlp
+		WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 1, DNLP_EN_BIT, DNLP_EN_WID);
+	}else{
+		// disable dnlp
+		WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 0, DNLP_EN_BIT, DNLP_EN_WID);
+	}
 #endif
 }
+
 void ve_set_dnlp_2(void)
 {
-    ulong i = 0;
-
-    // get command parameters
-    ve_dnlp_method       = 1;
-    ve_dnlp_cliprate     = 6;
-    ve_dnlp_hghrange     = 14;
-    ve_dnlp_lowrange     = 18;
-    ve_dnlp_hghalpha     = 26;
-    ve_dnlp_midalpha     = 28;
-    ve_dnlp_lowalpha     = 18;
-
+	ulong i = 0;
+	// get command parameters
+	ve_dnlp_method       = 1;
+	ve_dnlp_cliprate     = 6;
+	ve_dnlp_hghrange     = 14;
+	ve_dnlp_lowrange     = 18;
+	ve_dnlp_hghalpha     = 26;
+	ve_dnlp_midalpha     = 28;
+	ve_dnlp_lowalpha     = 18;
 	// clear historic luma sum
 	ve_dnlp_luma_sum = 0;
 	// init tgt & lpf
-	for (i = 0; i < 64; i++) {
-	    ve_dnlp_tgt[i] = i << 2;
-	    ve_dnlp_lpf[i] = ve_dnlp_tgt[i] << ve_dnlp_rt;
+	for(i = 0; i < 64; i++){
+		ve_dnlp_tgt[i] = i << 2;
+		ve_dnlp_lpf[i] = ve_dnlp_tgt[i] << ve_dnlp_rt;
 	}
 	// calculate dnlp reg data
 	ve_dnlp_calculate_reg();
 	// load dnlp reg data
 	ve_dnlp_load_reg();
 }
+
 void ve_set_new_dnlp(struct ve_dnlp_table_s *p)
 {
-    ulong i = 0;
-
-    // get command parameters
-    ve_en                = p->en;
+	ulong i = 0;
+	// get command parameters
+	ve_en                = p->en;
 	ve_dnlp_method       = p->method;
-    ve_dnlp_cliprate     = p->cliprate;
-    ve_dnlp_hghrange     = p->hghrange;
-    ve_dnlp_lowrange     = p->lowrange;
-    ve_dnlp_hghalpha     = p->hghalpha;
-    ve_dnlp_midalpha     = p->midalpha;
-    ve_dnlp_lowalpha     = p->lowalpha;
-
-    if (ve_en)
-    {
-        // clear historic luma sum
-        ve_dnlp_luma_sum = 0;
-        // init tgt & lpf
-        for (i = 0; i < 64; i++) {
-            ve_dnlp_tgt[i] = i << 2;
-            ve_dnlp_lpf[i] = ve_dnlp_tgt[i] << ve_dnlp_rt;
-        }
-        // calculate dnlp reg data
-        ve_dnlp_calculate_reg();
-        // load dnlp reg data
-        ve_dnlp_load_reg();
-#ifdef NEW_DNLP_AFTER_PEAKING
-        // enable dnlp
-        WRITE_CBUS_REG_BITS(VPP_PEAKING_DNLP, 1, PEAKING_DNLP_EN_BIT, PEAKING_DNLP_EN_WID);
-    }
-    else
-    {
-        // disable dnlp
-        WRITE_CBUS_REG_BITS(VPP_PEAKING_DNLP, 0, PEAKING_DNLP_EN_BIT, PEAKING_DNLP_EN_WID);
-    }
+	ve_dnlp_cliprate     = p->cliprate;
+	ve_dnlp_hghrange     = p->hghrange;
+	ve_dnlp_lowrange     = p->lowrange;
+	ve_dnlp_hghalpha     = p->hghalpha;
+	ve_dnlp_midalpha     = p->midalpha;
+	ve_dnlp_lowalpha     = p->lowalpha;
+	if(ve_en){
+		// clear historic luma sum
+		ve_dnlp_luma_sum = 0;
+		// init tgt & lpf
+		for (i = 0; i < 64; i++) {
+			ve_dnlp_tgt[i] = i << 2;
+			ve_dnlp_lpf[i] = ve_dnlp_tgt[i] << ve_dnlp_rt;
+		}
+		// calculate dnlp reg data
+		ve_dnlp_calculate_reg();
+		// load dnlp reg data
+		ve_dnlp_load_reg();
+#ifdef NEW_DNLP_IN_SHARPNESS
+		// enable dnlp
+		WRITE_CBUS_REG_BITS(DNLP_EN, 1, 0, 1);
+	}else{
+		// disable dnlp
+		WRITE_CBUS_REG_BITS(DNLP_EN, 0, 0, 1);
+	}
 #else
-        // enable dnlp
-        WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 1, DNLP_EN_BIT, DNLP_EN_WID);
-    }
-    else
-    {
-        // disable dnlp
-        WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 0, DNLP_EN_BIT, DNLP_EN_WID);
-    }
+		// enable dnlp
+		WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 1, DNLP_EN_BIT, DNLP_EN_WID);
+	}else{
+		// disable dnlp
+		WRITE_CBUS_REG_BITS(VPP_VE_ENABLE_CTRL, 0, DNLP_EN_BIT, DNLP_EN_WID);
+	}
 #endif
 }
+
 unsigned int ve_get_vs_cnt(void)
 {
-    return (READ_CBUS_REG(VPP_VDO_MEAS_VS_COUNT_LO));
+	return (READ_CBUS_REG(VPP_VDO_MEAS_VS_COUNT_LO));
 }
 
-unsigned int vpp_log[128][10];
-
 void vpp_phase_lock_on_vs(unsigned int cycle,
                           unsigned int stamp,
                           bool         lock50,
                           unsigned int range_fast,
                           unsigned int range_slow)
 {
-    unsigned int vtotal_ori = READ_CBUS_REG(ENCL_VIDEO_MAX_LNCNT);
-    unsigned int vtotal     = lock50 ? 1349 : 1124;
+	unsigned int vtotal_ori = READ_CBUS_REG(ENCL_VIDEO_MAX_LNCNT);
+	unsigned int vtotal     = lock50 ? 1349 : 1124;
 	unsigned int stamp_in   = READ_CBUS_REG(VDIN_MEAS_VS_COUNT_LO);
-    unsigned int stamp_out  = ve_get_vs_cnt();
-    unsigned int phase      = 0;
+	unsigned int stamp_out  = ve_get_vs_cnt();
+	unsigned int phase      = 0;
 	unsigned int cnt = READ_CBUS_REG(ASSIST_SPARE8_REG1);
 	int step = 0, i = 0;
-
-    // get phase
-    if (stamp_out < stamp)
-        phase = 0xffffffff - stamp + stamp_out + 1;
-    else
-        phase = stamp_out - stamp;
-    while (phase >= cycle)
-        phase -= cycle;
-    // 225~315 degree => tune fast panel output
-    if ((phase > ((cycle * 5) >> 3)) &&
-        (phase < ((cycle * 7) >> 3))
-       )
-    {
-        vtotal -= range_slow;
+	// get phase
+	if (stamp_out < stamp)
+		phase = 0xffffffff - stamp + stamp_out + 1;
+	else
+		phase = stamp_out - stamp;
+	while(phase >= cycle)
+		phase -= cycle;
+	// 225~315 degree => tune fast panel output
+	if ((phase > ((cycle * 5) >> 3)) &&(phase < ((cycle * 7) >> 3))){
+		vtotal -= range_slow;
 		step = 1;
-    }
-    // 45~135 degree => tune slow panel output
-    else if ((phase > ( cycle      >> 3)) &&
-             (phase < ((cycle * 3) >> 3))
-            )
-    {
-        vtotal += range_slow;
+	}else if ((phase > (cycle>> 3))&&(phase < ((cycle * 3) >> 3))){// 45~135 degree => tune slow panel output
+		vtotal += range_slow;
 		step = -1;
-    }
-    // 315~360 degree => tune fast panel output
-    else if (phase >= ((cycle * 7) >> 3))
-    {
-        vtotal -= range_fast;
+	}else if (phase >= ((cycle * 7) >> 3)){// 315~360 degree => tune fast panel output
+		vtotal -= range_fast;
 		step = +2;
-    }
-    // 0~45 degree => tune slow panel output
-    else if (phase <= (cycle >> 3))
-    {
-        vtotal += range_fast;
+	}else if (phase <= (cycle >> 3)){// 0~45 degree => tune slow panel output
+		vtotal += range_fast;
 		step = -2;
-    }
-    // 135~225 degree => keep still
-    else
-    {
-        vtotal = vtotal_ori;
+	}else{// 135~225 degree => keep still
+		vtotal = vtotal_ori;
 		step = 0;
-    }
-    if (vtotal != vtotal_ori)
-        WRITE_CBUS_REG(ENCL_VIDEO_MAX_LNCNT, vtotal);
-    if (cnt)
-    {
-        cnt--;
-        WRITE_CBUS_REG(ASSIST_SPARE8_REG1, cnt);
-        if (cnt)
-        {
-            vpp_log[cnt][0] = stamp;
-            vpp_log[cnt][1] = stamp_in;
-            vpp_log[cnt][2] = stamp_out;
-            vpp_log[cnt][3] = cycle;
-            vpp_log[cnt][4] = phase;
-            vpp_log[cnt][5] = vtotal;
-            vpp_log[cnt][6] = step;
-        }
-        else
-        {
-            for (i = 127; i > 0; i--)
-            {
-                printk("Ti=%10u Tio=%10u To=%10u CY=%6u PH =%10u Vt=%4u S=%2d\n",
-                       vpp_log[i][0],
-                       vpp_log[i][1],
-                       vpp_log[i][2],
-                       vpp_log[i][3],
-                       vpp_log[i][4],
-                       vpp_log[i][5],
-                       vpp_log[i][6]
-                       );
-            }
-            }
-        }
+	}
+	if (vtotal != vtotal_ori)
+		WRITE_CBUS_REG(ENCL_VIDEO_MAX_LNCNT, vtotal);
+	if (cnt){
+		cnt--;
+		WRITE_CBUS_REG(ASSIST_SPARE8_REG1, cnt);
+		if (cnt){
+			vpp_log[cnt][0] = stamp;
+			vpp_log[cnt][1] = stamp_in;
+			vpp_log[cnt][2] = stamp_out;
+			vpp_log[cnt][3] = cycle;
+			vpp_log[cnt][4] = phase;
+			vpp_log[cnt][5] = vtotal;
+			vpp_log[cnt][6] = step;
+		}else{
+			for(i = 127; i > 0; i--){
+				pr_amve_dbg("Ti=%10u Tio=%10u To=%10u CY=%6u PH =%10u Vt=%4u S=%2d\n",
+					vpp_log[i][0],vpp_log[i][1],vpp_log[i][2],vpp_log[i][3],
+					vpp_log[i][4],vpp_log[i][5],vpp_log[i][6]);
+			}
+		}
+	}
+
+}
+
+#if (MESON_CPU_TYPE>=MESON_CPU_TYPE_MESON6TVD)
+void ve_frame_size_patch(unsigned int width,unsigned int height)
+{
+	unsigned int vpp_size = height|(width << 16);
+	if(ve_size != vpp_size){
+		WRITE_CBUS_REG(VPP_VE_H_V_SIZE, vpp_size);
+		ve_size = vpp_size;
+	}
+}
+#endif
 
+void ve_dnlp_latch_process(void)
+{
+	if (vecm_latch_flag & FLAG_VE_DNLP){
+		vecm_latch_flag &= ~FLAG_VE_DNLP;
+		ve_set_dnlp(&am_ve_dnlp);
+	}
+	if (vecm_latch_flag & FLAG_VE_NEW_DNLP){
+		vecm_latch_flag &= ~FLAG_VE_NEW_DNLP;
+		ve_set_new_dnlp(&am_ve_new_dnlp);
+	}
+	if (vecm_latch_flag & FLAG_VE_DNLP_EN){
+		vecm_latch_flag &= ~FLAG_VE_DNLP_EN;
+		ve_enable_dnlp();
+		pr_amve_dbg("\n[amve..] set vpp_enable_dnlp OK!!!\n");
+	}
+	if (vecm_latch_flag & FLAG_VE_DNLP_DIS){
+		vecm_latch_flag &= ~FLAG_VE_DNLP_DIS;
+		ve_disable_dnlp();
+		pr_amve_dbg("\n[amve..] set vpp_disable_dnlp OK!!!\n");
+	}
+	if(dnlp_en&&dnlp_status){
+		dnlp_status = 0;
+		ve_set_dnlp_2();
+		ve_enable_dnlp();
+		pr_amve_dbg("\n[amve..] set vpp_enable_dnlp OK!!!\n");
+	}
+	else if(dnlp_en == 0){
+		dnlp_status = 1;
+		ve_disable_dnlp();
+		pr_amve_dbg("\n[amve..] set vpp_disable_dnlp OK!!!\n");
+	}
+}
+
+void ve_lcd_gamma_process(void)
+{
+	if (vecm_latch_flag & FLAG_GAMMA_TABLE_EN){
+		vecm_latch_flag &= ~FLAG_GAMMA_TABLE_EN;
+		vpp_enable_lcd_gamma_table();
+		pr_amve_dbg("\n[amve..] set vpp_enable_lcd_gamma_table OK!!!\n");
+	}
+	if (vecm_latch_flag & FLAG_GAMMA_TABLE_DIS){
+		vecm_latch_flag &= ~FLAG_GAMMA_TABLE_DIS;
+		vpp_disable_lcd_gamma_table();
+		pr_amve_dbg("\n[amve..] set vpp_disable_lcd_gamma_table OK!!!\n");
+	}
+	if (vecm_latch_flag & FLAG_GAMMA_TABLE_R){
+		vecm_latch_flag &= ~FLAG_GAMMA_TABLE_R;
+		vpp_set_lcd_gamma_table(video_gamma_table_r.data, H_SEL_R);
+		pr_amve_dbg("\n[amve..] set vpp_set_lcd_gamma_table OK!!!\n");
+	}
+	if (vecm_latch_flag & FLAG_GAMMA_TABLE_G){
+		vecm_latch_flag &= ~FLAG_GAMMA_TABLE_G;
+		vpp_set_lcd_gamma_table(video_gamma_table_g.data, H_SEL_G);
+		pr_amve_dbg("\n[amve..] set vpp_set_lcd_gamma_table OK!!!\n");
+	}
+	if (vecm_latch_flag & FLAG_GAMMA_TABLE_B){
+		vecm_latch_flag &= ~FLAG_GAMMA_TABLE_B;
+		vpp_set_lcd_gamma_table(video_gamma_table_b.data, H_SEL_B);
+		pr_amve_dbg("\n[amve..] set vpp_set_lcd_gamma_table OK!!!\n");
+	}
+	if (vecm_latch_flag & FLAG_RGB_OGO){
+		vecm_latch_flag &= ~FLAG_RGB_OGO;
+		if (video_rgb_ogo_mode_sw){
+			if (video_rgb_ogo.en){
+				vpp_set_lcd_gamma_table(video_gamma_table_r_adj.data, H_SEL_R);
+				vpp_set_lcd_gamma_table(video_gamma_table_g_adj.data, H_SEL_G);
+				vpp_set_lcd_gamma_table(video_gamma_table_b_adj.data, H_SEL_B);
+			}
+			else{
+				vpp_set_lcd_gamma_table(video_gamma_table_r.data, H_SEL_R);
+				vpp_set_lcd_gamma_table(video_gamma_table_g.data, H_SEL_G);
+				vpp_set_lcd_gamma_table(video_gamma_table_b.data, H_SEL_B);
+			}
+			pr_amve_dbg("\n[amve..] set vpp_set_lcd_gamma_table OK!!!\n");
+		}
+		else{
+			vpp_set_rgb_ogo(&video_rgb_ogo);
+			pr_amve_dbg("\n[amve..] set vpp_set_rgb_ogo OK!!!\n");
+		}
+	}
+}
+void lvds_freq_process(void)
+{
+#if ((MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD))
+	/* lvds freq 50Hz/60Hz */
+	if (frame_lock_freq == 1){//50 hz
+		// panel freq is 60Hz => change back to 50Hz
+		if (READ_CBUS_REG(ENCP_VIDEO_MAX_LNCNT) < 1237) // (1124 + 1349 +1) / 2
+			WRITE_CBUS_REG(ENCP_VIDEO_MAX_LNCNT, 1349);
+	}
+	else if (frame_lock_freq == 2){//60 hz
+		// panel freq is 50Hz => change back to 60Hz
+		if(READ_CBUS_REG(ENCP_VIDEO_MAX_LNCNT) >= 1237) // (1124 + 1349 + 1) / 2
+			WRITE_CBUS_REG(ENCP_VIDEO_MAX_LNCNT, 1124);
+	}
+	else if (frame_lock_freq == 0){
+		/* lvds freq 50Hz/60Hz */
+		if (vecm_latch_flag & FLAG_LVDS_FREQ_SW){  //50 hz
+			// panel freq is 60Hz => change back to 50Hz
+			if (READ_CBUS_REG(ENCP_VIDEO_MAX_LNCNT) < 1237) // (1124 + 1349 +1) / 2
+				WRITE_CBUS_REG(ENCP_VIDEO_MAX_LNCNT, 1349);
+		}else{	 //60 hz
+			// panel freq is 50Hz => change back to 60Hz
+			if (READ_CBUS_REG(ENCP_VIDEO_MAX_LNCNT) >= 1237) // (1124 + 1349 + 1) / 2
+				WRITE_CBUS_REG(ENCP_VIDEO_MAX_LNCNT, 1124);
+		}
+	}
+#endif
+}
+
+void ve_dnlp_param_update(void)
+{
+	if(am_ve_dnlp.en    >  1) am_ve_dnlp.en    =  1;
+	if(am_ve_dnlp.black > 16) am_ve_dnlp.black = 16;
+	if(am_ve_dnlp.white > 16) am_ve_dnlp.white = 16;
+	vecm_latch_flag |= FLAG_VE_DNLP;
+}
+
+void ve_new_dnlp_param_update(void)
+{
+	if (am_ve_new_dnlp.en > 1) am_ve_new_dnlp.en = 1;
+	if (am_ve_new_dnlp.cliprate> 256) am_ve_new_dnlp.cliprate= 256;
+	if (am_ve_new_dnlp.lowrange> 54) am_ve_new_dnlp.lowrange= 54;
+	if (am_ve_new_dnlp.hghrange> 54) am_ve_new_dnlp.hghrange= 54;
+	if (am_ve_new_dnlp.lowalpha> 48) am_ve_new_dnlp.lowalpha= 48;
+	if (am_ve_new_dnlp.midalpha> 48) am_ve_new_dnlp.midalpha= 48;
+	if (am_ve_new_dnlp.hghalpha> 48) am_ve_new_dnlp.hghalpha= 48;
+	vecm_latch_flag |= FLAG_VE_NEW_DNLP;
+}
+
+
+
+static void video_data_limitation(int *val)
+{
+	if (*val > 1023) *val = 1023;
+	if (*val < 0) *val = 0;
+}
+
+static void video_lookup(struct tcon_gamma_table_s *tbl, int *val)
+{
+	unsigned int idx = (*val) >> 2, mod = (*val) & 3;
+	if (idx < 255)
+		*val = tbl->data[idx] + (((tbl->data[idx + 1] - tbl->data[idx]) * mod + 2) >> 2);
+	else
+		*val = tbl->data[idx] + (((1023 - tbl->data[idx]) * mod + 2) >> 2);
+}
+
+static void video_set_rgb_ogo(void)
+{
+	int i = 0, r = 0, g = 0, b = 0;
+	for (i = 0; i < 256; i++){
+		// Get curve_straight = input(curve_2d2_inv) * video_curve_2d2
+		r = video_curve_2d2.data[i];
+		g = video_curve_2d2.data[i];
+		b = video_curve_2d2.data[i];
+		// Pre_offset
+		r += video_rgb_ogo.r_pre_offset;
+		g += video_rgb_ogo.g_pre_offset;
+		b += video_rgb_ogo.b_pre_offset;
+		video_data_limitation(&r);
+		video_data_limitation(&g);
+		video_data_limitation(&b);
+		// Gain
+		r  *= video_rgb_ogo.r_gain;
+		r >>= 10;
+		g  *= video_rgb_ogo.g_gain;
+		g >>= 10;
+		b  *= video_rgb_ogo.b_gain;
+		b >>= 10;
+		video_data_limitation(&r);
+		video_data_limitation(&g);
+		video_data_limitation(&b);
+		// Post_offset
+		r += video_rgb_ogo.r_post_offset;
+		g += video_rgb_ogo.g_post_offset;
+		b += video_rgb_ogo.b_post_offset;
+		video_data_limitation(&r);
+		video_data_limitation(&g);
+		video_data_limitation(&b);
+		// Get curve_2d2_inv_ogo = curve_straight_ogo * video_curve_2d2_inv
+		video_lookup(&video_curve_2d2_inv, &r);
+		video_lookup(&video_curve_2d2_inv, &g);
+		video_lookup(&video_curve_2d2_inv, &b);
+		// Get gamma_ogo = curve_2d2_inv_ogo * gamma
+		video_lookup(&video_gamma_table_r, &r);
+		video_lookup(&video_gamma_table_g, &g);
+		video_lookup(&video_gamma_table_b, &b);
+		// Save gamma_ogo
+		video_gamma_table_r_adj.data[i] = r;
+		video_gamma_table_g_adj.data[i] = g;
+		video_gamma_table_b_adj.data[i] = b;
+	}
+}
+
+void ve_ogo_param_update(void)
+{
+	if (video_rgb_ogo.en > 1) video_rgb_ogo.en = 1;
+	if (video_rgb_ogo.r_pre_offset > 1023) video_rgb_ogo.r_pre_offset = 1023;
+	if (video_rgb_ogo.r_pre_offset < -1024) video_rgb_ogo.r_pre_offset = -1024;
+	if (video_rgb_ogo.g_pre_offset > 1023) video_rgb_ogo.g_pre_offset = 1023;
+	if (video_rgb_ogo.g_pre_offset < -1024) video_rgb_ogo.g_pre_offset = -1024;
+	if (video_rgb_ogo.b_pre_offset > 1023) video_rgb_ogo.b_pre_offset = 1023;
+	if (video_rgb_ogo.b_pre_offset < -1024) video_rgb_ogo.b_pre_offset = -1024;
+	if (video_rgb_ogo.r_gain > 2047) video_rgb_ogo.r_gain = 2047;
+	if (video_rgb_ogo.g_gain > 2047) video_rgb_ogo.g_gain = 2047;
+	if (video_rgb_ogo.b_gain > 2047) video_rgb_ogo.b_gain = 2047;
+	if (video_rgb_ogo.r_post_offset > 1023) video_rgb_ogo.r_post_offset = 1023;
+	if (video_rgb_ogo.r_post_offset < -1024) video_rgb_ogo.r_post_offset = -1024;
+	if (video_rgb_ogo.g_post_offset > 1023) video_rgb_ogo.g_post_offset = 1023;
+	if (video_rgb_ogo.g_post_offset < -1024) video_rgb_ogo.g_post_offset = -1024;
+	if (video_rgb_ogo.b_post_offset > 1023) video_rgb_ogo.b_post_offset = 1023;
+	if (video_rgb_ogo.b_post_offset < -1024) video_rgb_ogo.b_post_offset = -1024;
+	if (video_rgb_ogo_mode_sw) video_set_rgb_ogo();
+	vecm_latch_flag |= FLAG_RGB_OGO;
 }
 
diff --git a/drivers/amlogic/amvecm/amve.h b/drivers/amlogic/amvecm/amve.h
index 14d748434042..4474aa2d6c8c 100755
--- a/drivers/amlogic/amvecm/amve.h
+++ b/drivers/amlogic/amvecm/amve.h
@@ -17,7 +17,7 @@
 #include "linux/amlogic/vframe.h"
 #include "linux/amlogic/ve.h"
 
-#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+#if ((MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8))//&&(MESON_CPU_TYPE != MESON_CPU_TYPE_MESONG9TV))
 #undef WRITE_CBUS_REG
 #undef WRITE_CBUS_REG_BITS
 #undef READ_CBUS_REG
@@ -64,12 +64,20 @@ extern void vpp_enable_lcd_gamma_table(void);
 extern void vpp_disable_lcd_gamma_table(void);
 extern void vpp_set_lcd_gamma_table(u16 *data, u32 rgb_mask);
 extern void vpp_set_rgb_ogo(struct tcon_rgb_ogo_s *p);
-extern void vd1_brightness_contrast(signed int brightness, signed int contrast);
 extern void vpp_phase_lock_on_vs(unsigned int cycle,
                                  unsigned int stamp,
                                  bool         lock50,
                                  unsigned int range_fast,
                                  unsigned int range_slow);
+#if (MESON_CPU_TYPE>=MESON_CPU_TYPE_MESON6TVD)
+extern void ve_frame_size_patch(unsigned int width,unsigned int height);
+#endif
+extern void ve_dnlp_latch_process(void);
+extern void ve_lcd_gamma_process(void);
+extern void lvds_freq_process(void);
+extern void ve_dnlp_param_update(void);
+extern void ve_new_dnlp_param_update(void);
+extern void ve_ogo_param_update(void);
 
 extern unsigned int vecm_latch_flag;
 extern unsigned int cm_size;
diff --git a/drivers/amlogic/amvecm/amve_gamma_table.h b/drivers/amlogic/amvecm/amve_gamma_table.h
new file mode 100755
index 000000000000..50dfb1cd2e48
--- /dev/null
+++ b/drivers/amlogic/amvecm/amve_gamma_table.h
@@ -0,0 +1,64 @@
+/*
+ * Video Enhancement
+ *
+ * Author: dezhi kong <lin.xu@amlogic.com>
+ *
+ * Copyright (C) 2014 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __AM_VE_GAMMATABLE_H
+#define __AM_VE_GAMMATABLE_H
+
+#include <linux/amlogic/amports/amstream.h>
+
+struct tcon_gamma_table_s video_curve_2d2_inv =
+{
+	{
+	   0,	82,  113,  136,  155,  171,  186,  199,  212,  223,  234,  245,  255,  264,  273,  282,
+	 290,  298,  306,  314,  321,  328,  335,  342,  349,  356,  362,  368,  374,  380,  386,  392,
+	 398,  403,  409,  414,  420,  425,  430,  435,  440,  445,  450,  455,  460,  464,  469,  474,
+	 478,  483,  487,  492,  496,  500,  505,  509,  513,  517,  521,  525,  529,  533,  537,  541,
+	 545,  549,  553,  556,  560,  564,  568,  571,  575,  579,  582,  586,  589,  593,  596,  600,
+	 603,  607,  610,  613,  617,  620,  623,  627,  630,  633,  636,  640,  643,  646,  649,  652,
+	 655,  658,  661,  665,  668,  671,  674,  677,  680,  683,  686,  688,  691,  694,  697,  700,
+	 703,  706,  709,  711,  714,  717,  720,  723,  725,  728,  731,  733,  736,  739,  742,  744,
+	 747,  750,  752,  755,  757,  760,  763,  765,  768,  770,  773,  775,  778,  780,  783,  785,
+	 788,  790,  793,  795,  798,  800,  803,  805,  808,  810,  812,  815,  817,  820,  822,  824,
+	 827,  829,  831,  834,  836,  838,  841,  843,  845,  847,  850,  852,  854,  856,  859,  861,
+	 863,  865,  868,  870,  872,  874,  876,  879,  881,  883,  885,  887,  889,  892,  894,  896,
+	 898,  900,  902,  904,  906,  909,  911,  913,  915,  917,  919,  921,  923,  925,  927,  929,
+	 931,  933,  935,  937,  939,  941,  943,  945,  947,  949,  951,  953,  955,  957,  959,  961,
+	 963,  965,  967,  969,  971,  973,  975,  977,  979,  981,  982,  984,  986,  988,  990,  992,
+	 994,  996,  998,  999, 1001, 1003, 1005, 1007, 1009, 1011, 1012, 1014, 1016, 1018, 1020, 1022,
+	},
+};
+
+struct tcon_gamma_table_s video_curve_2d2 =
+{
+	{
+	   0,	 0,    0,	 0,    0,	 0,    0,	 0,    1,	 1,    1,	 1,    1,	 1,    2,	 2,
+	   2,	 3,    3,	 3,    4,	 4,    5,	 5,    6,	 6,    7,	 7,    8,	 9,    9,	10,
+	  11,	11,   12,	13,   14,	15,   15,	16,   17,	18,   19,	20,   21,	22,   23,	25,
+	  26,	27,   28,	29,   31,	32,   33,	35,   36,	38,   39,	41,   42,	44,   45,	47,
+	  49,	50,   52,	54,   55,	57,   59,	61,   63,	65,   67,	69,   71,	73,   75,	77,
+	  79,	82,   84,	86,   88,	91,   93,	95,   98,  100,  103,  105,  108,  110,  113,  116,
+	 118,  121,  124,  127,  130,  132,  135,  138,  141,  144,  147,  150,  154,  157,  160,  163,
+	 166,  170,  173,  176,  180,  183,  187,  190,  194,  197,  201,  204,  208,  212,  216,  219,
+	 223,  227,  231,  235,  239,  243,  247,  251,  255,  259,  263,  267,  272,  276,  280,  285,
+	 289,  294,  298,  303,  307,  312,  316,  321,  326,  330,  335,  340,  345,  350,  355,  360,
+	 365,  370,  375,  380,  385,  390,  395,  401,  406,  411,  417,  422,  427,  433,  438,  444,
+	 450,  455,  461,  467,  472,  478,  484,  490,  496,  502,  508,  514,  520,  526,  532,  538,
+	 544,  551,  557,  563,  570,  576,  583,  589,  596,  602,  609,  615,  622,  629,  636,  642,
+	 649,  656,  663,  670,  677,  684,  691,  698,  705,  713,  720,  727,  735,  742,  749,  757,
+	 764,  772,  779,  787,  795,  802,  810,  818,  826,  833,  841,  849,  857,  865,  873,  881,
+	 889,  898,  906,  914,  922,  931,  939,  948,  956,  965,  973,  982,  990,  999, 1008, 1016,
+	},
+};
+
+
+#endif
+
diff --git a/drivers/amlogic/amvecm/amvecm.c b/drivers/amlogic/amvecm/amvecm.c
index 119f46e4452f..ff75172c15ab 100755
--- a/drivers/amlogic/amvecm/amvecm.c
+++ b/drivers/amlogic/amvecm/amvecm.c
@@ -22,21 +22,22 @@
 #include <linux/stat.h>
 #include <linux/errno.h>
 #include <asm/uaccess.h>
-
 #include <linux/amlogic/aml_common.h>
-
-
+#include <linux/ctype.h>//for parse_para_pq
 #include <mach/am_regs.h>
 #include <linux/amlogic/vframe.h>
-
 #include <linux/amlogic/amvecm.h>        /* For user used */
 #include "ve_regs.h"
 #include "amve.h"
 #include "cm_regs.h"
 #include "amcm.h"
-
-/* local defines */
-#define AMVECM_COUNT              1
+#include "amvecm_vlock_regmap.h"
+#define pr_amvecm_dbg(fmt, args...)\
+	do{\
+		if(debug_amvecm)\
+			printk("AMVECM: " fmt, ## args);\
+	}while(0)
+#define pr_amvecm_error(fmt, args...) printk("AMVECM: " fmt, ## args)
 
 #define AMVECM_NAME               "amvecm"
 #define AMVECM_DRIVER_NAME        "amvecm"
@@ -51,2140 +52,866 @@ typedef struct amvecm_dev_s {
     struct class                *clsp;
 } amvecm_dev_t;
 
-static bool hold_cmd_en = 0;
-module_param(hold_cmd_en, bool, 0664);
-MODULE_PARM_DESC(hold_cmd_en, "\n hold_cmd_en \n");
-
-static int cm_level = 0;//0:optimize;1:enhancement
-module_param(cm_level, int, 0664);
-MODULE_PARM_DESC(cm_level, "\n selcet cm lever \n");
-
-static int cm_en = 0;//0:disabel;1:enable
-module_param(cm_en, int, 0664);
-MODULE_PARM_DESC(cm_en, "\n enable or disable cm \n");
-static int cm_level_last = 0;//0:optimize;1:enhancement
-
-static int dnlp_en = 0;//0:disabel;1:enable
-module_param(dnlp_en, int, 0664);
-MODULE_PARM_DESC(dnlp_en, "\n enable or disable dnlp \n");
-static int dnlp_status = 1;//0:done;1:todo
-
+static int hue_pre = 0;  /*-25~25*/
+static int saturation_pre = 0;  /*-128~127*/
+static int hue_post = 0;  /*-25~25*/
+static int saturation_post = 0;  /*-128~127*/
+static signed int vd1_brightness = 0, vd1_contrast = 0;
 static struct amvecm_dev_s amvecm_dev;
-static struct ve_dnlp_s am_ve_dnlp;
-static struct ve_dnlp_table_s am_ve_new_dnlp;
+
+static bool debug_amvecm = 0;
+module_param(debug_amvecm, bool, 0664);
+MODULE_PARM_DESC(debug_amvecm, "\n debug_amvecm \n");
 
 unsigned int vecm_latch_flag;
 module_param(vecm_latch_flag, uint, 0664);
 MODULE_PARM_DESC(vecm_latch_flag, "\n vecm_latch_flag \n");
 
-unsigned int cm_size,ve_size;
-static int video_rgb_ogo_mode_sw = 0;
-static signed int vd1_brightness = 0, vd1_contrast = 0;
-extern unsigned int cm2_patch_flag;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV)
+unsigned int vlock_en = 0;
+module_param(vlock_en, uint, 0664);
+MODULE_PARM_DESC(vlock_en, "\n vlock_en \n");
 
-static struct am_regs_s amregs0;
-static struct am_regs_s amregs1;
-static struct am_regs_s amregs2;
-static struct am_regs_s amregs3;
-static struct am_regs_s amregs4;
-static struct am_regs_s amregs5;
-struct am_regs_s cmreg_lever1={
-	172,
-	{
-/* optimize */
-{6,	512,	    0xffffffff,	0           },
-{6,	513,	    0xffffffff,	0           },
-{6,	514,	    0xffffffff,	0           },
-{6,	515,	    0xffffffff,	134218752   },
-{6,	516,	    0xffffffff,	144         },
-{6,	518,	    0xffffffff,	0           },
-{6,	519,	    0xffffffff,	33554432    },
-{6,	520,	    0xffffffff,	118         },
-{6,	521,	    0xffffffff,	0           },
-{6,	522,	    0xffffffff,	0           },
-{6,	527,	    0xf,	0           },
-{6,	517,	    0xffffffff,	70715263    },
-{9,	256,	    0xffffffff,	532992      },
-{9,	257,	    0xffffffff,	0xf3f600af  },
-{9,	258,	    0xffffffff,	0xe3000000  },
-{9,	259,	    0xffffffff,	240         },
-{9,	260,	    0xffffffff,	63506       },
-{9,	264,	    0xffffffff,	16650496    },
-{9,	265,	    0xffffffff,	249         },
-{9,	266,	    0xffffffff,	0           },
-{9,	267,	    0xffffffff,	0           },
-{9,	268,	    0xffffffff,	0           },
-{9,	272,	    0xffffffff,	135936      },
-{9,	273,	    0xffffffff,	253         },
-{9,	274,	    0xffffffff,	0           },
-{9,	275,	    0xffffffff,	0           },
-{9,	276,	    0xffffffff,	0           },
-{9,	280,	    0xffffffff,	0xf3f11300  },
-{9,	281,	    0xffffffff,	214         },
-{9,	282,	    0xffffffff,	0           },
-{9,	283,	    0xffffffff,	0           },
-{9,	284,	    0xffffffff,	0           },
-{9,	288,	    0xffffffff,	0xede91300  },
-{9,	289,	    0xffffffff,	177         },
-{9,	290,	    0xffffffff,	0           },
-{9,	291,	    0xffffffff,	0           },
-{9,	292,	    0xffffffff,	15660544    },
-{9,	296,	    0xffffffff,	0xe9e61100  },
-{9,	297,	    0xffffffff,	184         },
-{9,	298,	    0xffffffff,	0           },
-{9,	299,	    0xffffffff,	0           },
-{9,	300,	    0xffffffff,	15464448    },
-{9,	304,	    0xffffffff,	0xeff80f00  },
-{9,	305,	    0xffffffff,	232         },
-{9,	306,	    0xffffffff,	0           },
-{9,	307,	    0xffffffff,	0           },
-{9,	308,	    0xffffffff,	0           },
-{9,	312,	    0xffffffff,	0xf60a0d00  },
-{9,	313,	    0xffffffff,	245         },
-{9,	314,	    0xffffffff,	0           },
-{9,	315,	    0xffffffff,	0           },
-{9,	316,	    0xffffffff,	0           },
-{9,	320,	    0xffffffff,	526848      },
-{9,	321,	    0xffffffff,	238         },
-{9,	322,	    0xffffffff,	0           },
-{9,	323,	    0xffffffff,	10          },
-{9,	324,	    0xffffffff,	0           },
-{9,	328,	    0xffffffff,	527616      },
-{9,	329,	    0xffffffff,	134742245   },
-{9,	330,	    0xffffffff,	167903232   },
-{9,	331,	    0xffffffff,	21          },
-{9,	332,	    0xffffffff,	3328        },
-{9,	336,	    0xffffffff,	397056      },
-{9,	337,	    0xffffffff,	0xf80d00da  },
-{9,	338,	    0xffffffff,	0xf80500fb  },
-{9,	339,	    0xffffffff,	2           },
-{9,	340,	    0xffffffff,	132357      },
-{9,	344,	    0xffffffff,	526848      },
-{9,	345,	    0xffffffff,	0xfb0a00c7  },
-{9,	346,	    0xffffffff,	0xf6020002  },
-{9,	347,	    0xffffffff,	251         },
-{9,	348,	    0xffffffff,	16646656    },
-{9,	352,	    0xffffffff,	657408      },
-{9,	353,	    0xffffffff,	327857      },
-{9,	354,	    0xffffffff,	0xf6050000  },
-{9,	355,	    0xffffffff,	2           },
-{9,	356,	    0xffffffff,	0           },
-{9,	360,	    0xffffffff,	526336      },
-{9,	361,	    0xffffffff,	162         },
-{9,	362,	    0xffffffff,	0xf600f600  },
-{9,	363,	    0xffffffff,	254         },
-{9,	364,	    0xffffffff,	33554432    },
-{9,	368,	    0xffffffff,	986368      },
-{9,	369,	    0xffffffff,	166         },
-{9,	370,	    0xffffffff,	0xf300eef6  },
-{9,	371,	    0xffffffff,	243         },
-{9,	372,	    0xffffffff,	0xfb050000  },
-{9,	376,	    0xffffffff,	34541312    },
-{9,	377,	    0xffffffff,	83886277    },
-{9,	378,	    0xffffffff,	0xfbfef8f8  },
-{9,	379,	    0xffffffff,	246         },
-{9,	380,	    0xffffffff,	0xf8080200  },
-{9,	384,	    0xffffffff,	286331136   },
-{9,	385,	    0xffffffff,	353698041   },
-{9,	386,	    0xffffffff,	168427768   },
-{9,	387,	    0xffffffff,	13          },
-{9,	388,	    0xffffffff,	0xfb081000  },
-{9,	392,	    0xffffffff,	218960128   },
-{9,	393,	    0xffffffff,	674758687   },
-{9,	394,	    0xffffffff,	573177856   },
-{9,	395,	    0xffffffff,	21          },
-{9,	396,	    0xffffffff,	854766      },
-{9,	400,	    0xffffffff,	168430080   },
-{9,	401,	    0xffffffff,	809304110   },
-{9,	402,	    0xffffffff,	674234389   },
-{9,	403,	    0xffffffff,	13          },
-{9,	404,	    0xffffffff,	716515      },
-{9,	408,	    0xffffffff,	134745344   },
-{9,	409,	    0xffffffff,	807731246   },
-{9,	410,	    0xffffffff,	403308562   },
-{9,	411,	    0xffffffff,	0           },
-{9,	412,	    0xffffffff,	59590       },
-{9,	416,	    0xffffffff,	67504640    },
-{9,	417,	    0xffffffff,	269484072   },
-{9,	418,	    0xffffffff,	182845440   },
-{9,	419,	    0xffffffff,	0           },
-{9,	420,	    0xffffffff,	61139       },
-{9,	424,	    0xffffffff,	396544      },
-{9,	425,	    0xffffffff,	134217757   },
-{9,	426,	    0xffffffff,	0xfb0b0000  },
-{9,	427,	    0xffffffff,	0           },
-{9,	428,	    0xffffffff,	246         },
-{9,	432,	    0xffffffff,	527616      },
-{9,	433,	    0xffffffff,	12          },
-{9,	434,	    0xffffffff,	15597568    },
-{9,	435,	    0xffffffff,	0           },
-{9,	436,	    0xffffffff,	0           },
-{9,	440,	    0xffffffff,	658688      },
-{9,	441,	    0xffffffff,	7           },
-{9,	442,	    0xffffffff,	0           },
-{9,	443,	    0xffffffff,	0           },
-{9,	444,	    0xffffffff,	0           },
-{9,	448,	    0xffffffff,	986880      },
-{9,	449,	    0xffffffff,	255         },
-{9,	450,	    0xffffffff,	0           },
-{9,	451,	    0xffffffff,	0           },
-{9,	452,	    0xffffffff,	0           },
-{9,	456,	    0xffffffff,	219811584   },
-{9,	457,	    0xffffffff,	238         },
-{9,	458,	    0xffffffff,	0           },
-{9,	459,	    0xffffffff,	0           },
-{9,	460,	    0xffffffff,	0           },
-{9,	464,	    0xffffffff,	287183104   },
-{9,	465,	    0xffffffff,	197         },
-{9,	466,	    0xffffffff,	0xf3000000  },
-{9,	467,	    0xffffffff,	246         },
-{9,	468,	    0xffffffff,	0xfb000000  },
-{9,	472,	    0xffffffff,	219943168   },
-{9,	473,	    0xffffffff,	169         },
-{9,	474,	    0xffffffff,	0xf0000000  },
-{9,	475,	    0xffffffff,	232         },
-{9,	476,	    0xffffffff,	0           },
-{9,	480,	    0xffffffff,	1707264     },
-{9,	481,	    0xffffffff,	0xfb0000ab  },
-{9,	482,	    0xffffffff,	0xe300f3f3  },
-{9,	483,	    0xffffffff,	219         },
-{9,	484,	    0xffffffff,	15597568    },
-{9,	488,	    0xffffffff,	1509888     },
-{9,	489,	    0xffffffff,	0xf30000b6  },
-{9,	490,	    0xffffffff,	0xd800e8e3  },
-{9,	491,	    0xffffffff,	222         },
-{9,	492,	    0xffffffff,	14876680    },
-{9,	496,	    0xffffffff,	1117440     },
-{9,	497,	    0xffffffff,	0xf3fb00ba  },
-{9,	498,	    0xffffffff,	0xd300ebe6  },
-{9,	499,	    0xffffffff,	232         },
-{9,	500,	    0xffffffff,	15661840    },
-{9,	504,	    0xffffffff,	989696      },
-{9,	505,	    0xffffffff,	0xf6f800b6  },
-{9,	506,	    0xffffffff,	0xe600f3f3  },
-{9,	507,	    0xffffffff,	235         },
-{9,	508,	    0xffffffff,	18          },
-{0}
-	}
-};
-struct am_regs_s cmreg_lever2={
-	172,
-	{
-/* optimize */
-{6,	512,	    0xffffffff,	0          },
-{6,	513,	    0xffffffff,	0          },
-{6,	514,	    0xffffffff,	0          },
-{6,	515,	    0xffffffff,	134218752  },
-{6,	516,	    0xffffffff,	144        },
-{6,	518,	    0xffffffff,	0          },
-{6,	519,	    0xffffffff,	33554432   },
-{6,	520,	    0xffffffff,	122        },
-{6,	521,	    0xffffffff,	0          },
-{6,	522,	    0xffffffff,	0          },
-{6,	527,	    0xf,	0          },
-{6,	517,	    0xffffffff,	70715263   },
-{9,	256,	    0xffffffff,	2840064    },
-{9,	257,	    0xffffffff,	12         },
-{9,	258,	    0xffffffff,	0          },
-{9,	259,	    0xffffffff,	0          },
-{9,	260,	    0xffffffff,	0          },
-{9,	264,	    0xffffffff,	2708992    },
-{9,	265,	    0xffffffff,	31         },
-{9,	266,	    0xffffffff,	0          },
-{9,	267,	    0xffffffff,	0          },
-{9,	268,	    0xffffffff,	0          },
-{9,	272,	    0xffffffff,	2708992    },
-{9,	273,	    0xffffffff,	51         },
-{9,	274,	    0xffffffff,	0          },
-{9,	275,	    0xffffffff,	0          },
-{9,	276,	    0xffffffff,	0          },
-{9,	280,	    0xffffffff,	2840064    },
-{9,	281,	    0xffffffff,	63         },
-{9,	282,	    0xffffffff,	0          },
-{9,	283,	    0xffffffff,	0          },
-{9,	284,	    0xffffffff,	0          },
-{9,	288,	    0xffffffff,	2840064    },
-{9,	289,	    0xffffffff,	63         },
-{9,	290,	    0xffffffff,	0          },
-{9,	291,	    0xffffffff,	0          },
-{9,	292,	    0xffffffff,	0          },
-{9,	296,	    0xffffffff,	2708992    },
-{9,	297,	    0xffffffff,	63         },
-{9,	298,	    0xffffffff,	0          },
-{9,	299,	    0xffffffff,	0          },
-{9,	300,	    0xffffffff,	0          },
-{9,	304,	    0xffffffff,	2708480    },
-{9,	305,	    0xffffffff,	63         },
-{9,	306,	    0xffffffff,	0          },
-{9,	307,	    0xffffffff,	0          },
-{9,	308,	    0xffffffff,	0          },
-{9,	312,	    0xffffffff,	2708480    },
-{9,	313,	    0xffffffff,	51         },
-{9,	314,	    0xffffffff,	0          },
-{9,	315,	    0xffffffff,	0          },
-{9,	316,	    0xffffffff,	0          },
-{9,	320,	    0xffffffff,	2708480    },
-{9,	321,	    0xffffffff,	9          },
-{9,	322,	    0xffffffff,	0          },
-{9,	323,	    0xffffffff,	0          },
-{9,	324,	    0xffffffff,	0          },
-{9,	328,	    0xffffffff,	2708480    },
-{9,	329,	    0xffffffff,	234        },
-{9,	330,	    0xffffffff,	0          },
-{9,	331,	    0xffffffff,	0          },
-{9,	332,	    0xffffffff,	0          },
-{9,	336,	    0xffffffff,	2708480    },
-{9,	337,	    0xffffffff,	212        },
-{9,	338,	    0xffffffff,	0          },
-{9,	339,	    0xffffffff,	0          },
-{9,	340,	    0xffffffff,	0          },
-{9,	344,	    0xffffffff,	2708480    },
-{9,	345,	    0xffffffff,	197        },
-{9,	346,	    0xffffffff,	0          },
-{9,	347,	    0xffffffff,	0          },
-{9,	348,	    0xffffffff,	0          },
-{9,	352,	    0xffffffff,	2708480    },
-{9,	353,	    0xffffffff,	193        },
-{9,	354,	    0xffffffff,	0          },
-{9,	355,	    0xffffffff,	0          },
-{9,	356,	    0xffffffff,	0          },
-{9,	360,	    0xffffffff,	2708480    },
-{9,	361,	    0xffffffff,	203        },
-{9,	362,	    0xffffffff,	0          },
-{9,	363,	    0xffffffff,	0          },
-{9,	364,	    0xffffffff,	0          },
-{9,	368,	    0xffffffff,	2708480    },
-{9,	369,	    0xffffffff,	214        },
-{9,	370,	    0xffffffff,	0          },
-{9,	371,	    0xffffffff,	0          },
-{9,	372,	    0xffffffff,	0          },
-{9,	376,	    0xffffffff,	2708992    },
-{9,	377,	    0xffffffff,	219        },
-{9,	378,	    0xffffffff,	0          },
-{9,	379,	    0xffffffff,	0          },
-{9,	380,	    0xffffffff,	0          },
-{9,	384,	    0xffffffff,	2708480    },
-{9,	385,	    0xffffffff,	236        },
-{9,	386,	    0xffffffff,	0          },
-{9,	387,	    0xffffffff,	0          },
-{9,	388,	    0xffffffff,	0          },
-{9,	392,	    0xffffffff,	2708992    },
-{9,	393,	    0xffffffff,	249        },
-{9,	394,	    0xffffffff,	0          },
-{9,	395,	    0xffffffff,	0          },
-{9,	396,	    0xffffffff,	0          },
-{9,	400,	    0xffffffff,	2708992    },
-{9,	401,	    0xffffffff,	3          },
-{9,	402,	    0xffffffff,	0          },
-{9,	403,	    0xffffffff,	0          },
-{9,	404,	    0xffffffff,	0          },
-{9,	408,	    0xffffffff,	2708992    },
-{9,	409,	    0xffffffff,	9          },
-{9,	410,	    0xffffffff,	0          },
-{9,	411,	    0xffffffff,	0          },
-{9,	412,	    0xffffffff,	0          },
-{9,	416,	    0xffffffff,	2708480    },
-{9,	417,	    0xffffffff,	12         },
-{9,	418,	    0xffffffff,	0          },
-{9,	419,	    0xffffffff,	0          },
-{9,	420,	    0xffffffff,	0          },
-{9,	424,	    0xffffffff,	2708480    },
-{9,	425,	    0xffffffff,	14         },
-{9,	426,	    0xffffffff,	0          },
-{9,	427,	    0xffffffff,	0          },
-{9,	428,	    0xffffffff,	0          },
-{9,	432,	    0xffffffff,	2708480    },
-{9,	433,	    0xffffffff,	12         },
-{9,	434,	    0xffffffff,	0          },
-{9,	435,	    0xffffffff,	0          },
-{9,	436,	    0xffffffff,	0          },
-{9,	440,	    0xffffffff,	2708480    },
-{9,	441,	    0xffffffff,	7          },
-{9,	442,	    0xffffffff,	0          },
-{9,	443,	    0xffffffff,	0          },
-{9,	444,	    0xffffffff,	0          },
-{9,	448,	    0xffffffff,	2708480    },
-{9,	449,	    0xffffffff,	251        },
-{9,	450,	    0xffffffff,	0          },
-{9,	451,	    0xffffffff,	0          },
-{9,	452,	    0xffffffff,	0          },
-{9,	456,	    0xffffffff,	2708480    },
-{9,	457,	    0xffffffff,	242        },
-{9,	458,	    0xffffffff,	0          },
-{9,	459,	    0xffffffff,	0          },
-{9,	460,	    0xffffffff,	0          },
-{9,	464,	    0xffffffff,	36262912   },
-{9,	465,	    0xffffffff,	238        },
-{9,	466,	    0xffffffff,	0          },
-{9,	467,	    0xffffffff,	0          },
-{9,	468,	    0xffffffff,	0          },
-{9,	472,	    0xffffffff,	69817344   },
-{9,	473,	    0xffffffff,	245        },
-{9,	474,	    0xffffffff,	0          },
-{9,	475,	    0xffffffff,	0          },
-{9,	476,	    0xffffffff,	0          },
-{9,	480,	    0xffffffff,	136926208  },
-{9,	481,	    0xffffffff,	1          },
-{9,	482,	    0xffffffff,	0          },
-{9,	483,	    0xffffffff,	0          },
-{9,	484,	    0xffffffff,	0          },
-{9,	488,	    0xffffffff,	136926208  },
-{9,	489,	    0xffffffff,	5          },
-{9,	490,	    0xffffffff,	0          },
-{9,	491,	    0xffffffff,	0          },
-{9,	492,	    0xffffffff,	0          },
-{9,	496,	    0xffffffff,	136926208  },
-{9,	497,	    0xffffffff,	5          },
-{9,	498,	    0xffffffff,	0          },
-{9,	499,	    0xffffffff,	0          },
-{9,	500,	    0xffffffff,	0          },
-{9,	504,	    0xffffffff,	69817344   },
-{9,	505,	    0xffffffff,	7          },
-{9,	506,	    0xffffffff,	0          },
-{9,	507,	    0xffffffff,	0          },
-{9,	508,	    0xffffffff,	0          },
-{0}
-	}
-};
-struct am_regs_s cmreg_lever3={
-	172,
-	{
-/* optimize */
-{6,	512,	    0xffffffff,	0          },
-{6,	513,	    0xffffffff,	0          },
-{6,	514,	    0xffffffff,	0          },
-{6,	515,	    0xffffffff,	134218752  },
-{6,	516,	    0xffffffff,	144        },
-{6,	518,	    0xffffffff,	0          },
-{6,	519,	    0xffffffff,	33554432   },
-{6,	520,	    0xffffffff,	118        },
-{6,	521,	    0xffffffff,	62914560   },
-{6,	522,	    0xffffffff,	70778880   },
-{6,	527,	           0xf,	1          },
-{6,	517,	    0xffffffff,	70780799   },
-{9,	256,	    0xffffffff,	16648704   },
-{9,	257,	    0xffffffff,	0xf3f6000b },
-{9,	258,	    0xffffffff,	0xe3000000 },
-{9,	259,	    0xffffffff,	240        },
-{9,	260,	    0xffffffff,	63742      },
-{9,	264,	    0xffffffff,	16650496   },
-{9,	265,	    0xffffffff,	14         },
-{9,	266,	    0xffffffff,	0          },
-{9,	267,	    0xffffffff,	0          },
-{9,	268,	    0xffffffff,	0          },
-{9,	272,	    0xffffffff,	135936     },
-{9,	273,	    0xffffffff,	253        },
-{9,	274,	    0xffffffff,	0          },
-{9,	275,	    0xffffffff,	0          },
-{9,	276,	    0xffffffff,	0          },
-{9,	280,	    0xffffffff,	0xf3f11300 },
-{9,	281,	    0xffffffff,	214        },
-{9,	282,	    0xffffffff,	0          },
-{9,	283,	    0xffffffff,	0          },
-{9,	284,	    0xffffffff,	0          },
-{9,	288,	    0xffffffff,	0xede91300 },
-{9,	289,	    0xffffffff,	177        },
-{9,	290,	    0xffffffff,	0          },
-{9,	291,	    0xffffffff,	0          },
-{9,	292,	    0xffffffff,	15660544   },
-{9,	296,	    0xffffffff,	0xe9e61100 },
-{9,	297,	    0xffffffff,	184        },
-{9,	298,	    0xffffffff,	0          },
-{9,	299,	    0xffffffff,	0          },
-{9,	300,	    0xffffffff,	15464448   },
-{9,	304,	    0xffffffff,	0xeff80f00 },
-{9,	305,	    0xffffffff,	232        },
-{9,	306,	    0xffffffff,	0          },
-{9,	307,	    0xffffffff,	0          },
-{9,	308,	    0xffffffff,	0          },
-{9,	312,	    0xffffffff,	0xf60a0d00 },
-{9,	313,	    0xffffffff,	5          },
-{9,	314,	    0xffffffff,	0          },
-{9,	315,	    0xffffffff,	0          },
-{9,	316,	    0xffffffff,	0          },
-{9,	320,	    0xffffffff,	526848     },
-{9,	321,	    0xffffffff,	5          },
-{9,	322,	    0xffffffff,	0          },
-{9,	323,	    0xffffffff,	10         },
-{9,	324,	    0xffffffff,	0          },
-{9,	328,	    0xffffffff,	526848     },
-{9,	329,	    0xffffffff,	134742265  },
-{9,	330,	    0xffffffff,	167903232  },
-{9,	331,	    0xffffffff,	21         },
-{9,	332,	    0xffffffff,	3328       },
-{9,	336,	    0xffffffff,	131072     },
-{9,	337,	    0xffffffff,	0xf80d00ea },
-{9,	338,	    0xffffffff,	0xf80500fb },
-{9,	339,	    0xffffffff,	2          },
-{9,	340,	    0xffffffff,	132357     },
-{9,	344,	    0xffffffff,	131584     },
-{9,	345,	    0xffffffff,	0xfb0100da },
-{9,	346,	    0xffffffff,	0xf6020002 },
-{9,	347,	    0xffffffff,	251        },
-{9,	348,	    0xffffffff,	16646656   },
-{9,	352,	    0xffffffff,	657408     },
-{9,	353,	    0xffffffff,	327872     },
-{9,	354,	    0xffffffff,	0xf6050000 },
-{9,	355,	    0xffffffff,	2          },
-{9,	356,	    0xffffffff,	0          },
-{9,	360,	    0xffffffff,	526336     },
-{9,	361,	    0xffffffff,	175        },
-{9,	362,	    0xffffffff,	0xf600f600 },
-{9,	363,	    0xffffffff,	254        },
-{9,	364,	    0xffffffff,	33554432   },
-{9,	368,	    0xffffffff,	986368     },
-{9,	369,	    0xffffffff,	169        },
-{9,	370,	    0xffffffff,	0xf300eef6 },
-{9,	371,	    0xffffffff,	243        },
-{9,	372,	    0xffffffff,	0xfb050000 },
-{9,	376,	    0xffffffff,	34541312   },
-{9,	377,	    0xffffffff,	83886277   },
-{9,	378,	    0xffffffff,	0xfbfef8f8 },
-{9,	379,	    0xffffffff,	246        },
-{9,	380,	    0xffffffff,	0xf8080200 },
-{9,	384,	    0xffffffff,	135339520  },
-{9,	385,	    0xffffffff,	353697836  },
-{9,	386,	    0xffffffff,	168427768  },
-{9,	387,	    0xffffffff,	13         },
-{9,	388,	    0xffffffff,	0xfb080800 },
-{9,	392,	    0xffffffff,	219356160  },
-{9,	393,	    0xffffffff,	674758739  },
-{9,	394,	    0xffffffff,	573177856  },
-{9,	395,	    0xffffffff,	21         },
-{9,	396,	    0xffffffff,	657920     },
-{9,	400,	    0xffffffff,	219223808  },
-{9,	401,	    0xffffffff,	809304160  },
-{9,	402,	    0xffffffff,	674562069  },
-{9,	403,	    0xffffffff,	13         },
-{9,	404,	    0xffffffff,	657920     },
-{9,	408,	    0xffffffff,	168629504  },
-{9,	409,	    0xffffffff,	807731289  },
-{9,	410,	    0xffffffff,	403308562  },
-{9,	411,	    0xffffffff,	0          },
-{9,	412,	    0xffffffff,	526848     },
-{9,	416,	    0xffffffff,	395776     },
-{9,	417,	    0xffffffff,	269484098  },
-{9,	418,	    0xffffffff,	167772160  },
-{9,	419,	    0xffffffff,	0          },
-{9,	420,	    0xffffffff,	0          },
-{9,	424,	    0xffffffff,	396544     },
-{9,	425,	    0xffffffff,	134217757  },
-{9,	426,	    0xffffffff,	0          },
-{9,	427,	    0xffffffff,	0          },
-{9,	428,	    0xffffffff,	0          },
-{9,	432,	    0xffffffff,	527616     },
-{9,	433,	    0xffffffff,	12         },
-{9,	434,	    0xffffffff,	0          },
-{9,	435,	    0xffffffff,	0          },
-{9,	436,	    0xffffffff,	0          },
-{9,	440,	    0xffffffff,	658688     },
-{9,	441,	    0xffffffff,	7          },
-{9,	442,	    0xffffffff,	0          },
-{9,	443,	    0xffffffff,	0          },
-{9,	444,	    0xffffffff,	0          },
-{9,	448,	    0xffffffff,	986880     },
-{9,	449,	    0xffffffff,	5          },
-{9,	450,	    0xffffffff,	0          },
-{9,	451,	    0xffffffff,	0          },
-{9,	452,	    0xffffffff,	0          },
-{9,	456,	    0xffffffff,	219811584  },
-{9,	457,	    0xffffffff,	244        },
-{9,	458,	    0xffffffff,	0          },
-{9,	459,	    0xffffffff,	0          },
-{9,	460,	    0xffffffff,	0          },
-{9,	464,	    0xffffffff,	287183104  },
-{9,	465,	    0xffffffff,	186        },
-{9,	466,	    0xffffffff,	0xf3000000 },
-{9,	467,	    0xffffffff,	246        },
-{9,	468,	    0xffffffff,	0xfb000000 },
-{9,	472,	    0xffffffff,	219944192  },
-{9,	473,	    0xffffffff,	158        },
-{9,	474,	    0xffffffff,	0xf0000000 },
-{9,	475,	    0xffffffff,	232        },
-{9,	476,	    0xffffffff,	0          },
-{9,	480,	    0xffffffff,	1382912    },
-{9,	481,	    0xffffffff,	0xfb0000a4 },
-{9,	482,	    0xffffffff,	0xe300f3f3 },
-{9,	483,	    0xffffffff,	219        },
-{9,	484,	    0xffffffff,	0          },
-{9,	488,	    0xffffffff,	1514496    },
-{9,	489,	    0xffffffff,	0xf30000ba },
-{9,	490,	    0xffffffff,	0xe600f3f0 },
-{9,	491,	    0xffffffff,	222        },
-{9,	492,	    0xffffffff,	0          },
-{9,	496,	    0xffffffff,	1120000    },
-{9,	497,	    0xffffffff,	0xf3fb00db },
-{9,	498,	    0xffffffff,	0xe800f6ee },
-{9,	499,	    0xffffffff,	232        },
-{9,	500,	    0xffffffff,	64256      },
-{9,	504,	    0xffffffff,	397056     },
-{9,	505,	    0xffffffff,	0xf6f800f7 },
-{9,	506,	    0xffffffff,	0xe60000f8 },
-{9,	507,	    0xffffffff,	235        },
-{9,	508,	    0xffffffff,	65278      },
-{0}
-	}
-};
+unsigned int sync_3d_en = 0;
+module_param(sync_3d_en, uint, 0664);
+MODULE_PARM_DESC(sync_3d_en, "\n 3d_sync_en \n");
 
-struct am_regs_s cmreg_optimize={
-	172,
-	{
-/* optimize */
-{REG_TYPE_INDEX_VPPCHROMA,	0x200,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x201,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x202,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x203,    0xffffffff, 0x8000400},
-{REG_TYPE_INDEX_VPPCHROMA,	0x204,    0xffffffff, 0x90   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x205,    0xffffffff, 0x437077f},
-{REG_TYPE_INDEX_VPPCHROMA,	0x206,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x207,    0xffffffff, 0x1f60000},
-{REG_TYPE_INDEX_VPPCHROMA,	0x208,    0xffffffff, 0x76   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x209,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x20a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x20f,    0xf, 0x0,   },
-{REG_TYPE_INDEX_VPP_COEF,	0x100,    0xffffffff, 0xa1100  },
-{REG_TYPE_INDEX_VPP_COEF,	0x101,    0xffffffff, 0xc   },
-{REG_TYPE_INDEX_VPP_COEF,	0x102,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x103,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x104,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x108,    0xffffffff, 0xd1100  },
-{REG_TYPE_INDEX_VPP_COEF,	0x109,    0xffffffff, 0x1f   },
-{REG_TYPE_INDEX_VPP_COEF,	0x10a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x10b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x10c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x110,    0xffffffff, 0xf1300  },
-{REG_TYPE_INDEX_VPP_COEF,	0x111,    0xffffffff, 0x33   },
-{REG_TYPE_INDEX_VPP_COEF,	0x112,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x113,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x114,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x118,    0xffffffff, 0xf1300  },
-{REG_TYPE_INDEX_VPP_COEF,	0x119,    0xffffffff, 0x3f   },
-{REG_TYPE_INDEX_VPP_COEF,	0x11a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x11b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x11c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x120,    0xffffffff, 0xf1300  },
-{REG_TYPE_INDEX_VPP_COEF,	0x121,    0xffffffff, 0x40   },
-{REG_TYPE_INDEX_VPP_COEF,	0x122,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x123,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x124,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x128,    0xffffffff, 0xf1100  },
-{REG_TYPE_INDEX_VPP_COEF,	0x129,    0xffffffff, 0x40   },
-{REG_TYPE_INDEX_VPP_COEF,	0x12a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x12b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x12c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x130,    0xffffffff, 0xd0f00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x131,    0xffffffff, 0x3f   },
-{REG_TYPE_INDEX_VPP_COEF,	0x132,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x133,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x134,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x138,    0xffffffff, 0xa0d00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x139,    0xffffffff, 0x32   },
-{REG_TYPE_INDEX_VPP_COEF,	0x13a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x13b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x13c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x140,    0xffffffff, 0x80a00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x141,    0xffffffff, 0x9   },
-{REG_TYPE_INDEX_VPP_COEF,	0x142,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x143,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x144,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x148,    0xffffffff, 0x80a00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x149,    0xffffffff, 0xea   },
-{REG_TYPE_INDEX_VPP_COEF,	0x14a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x14b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x14c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x150,    0xffffffff, 0xa0a00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x151,    0xffffffff, 0xd4   },
-{REG_TYPE_INDEX_VPP_COEF,	0x152,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x153,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x154,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x158,    0xffffffff, 0xa0800  },
-{REG_TYPE_INDEX_VPP_COEF,	0x159,    0xffffffff, 0xc3   },
-{REG_TYPE_INDEX_VPP_COEF,	0x15a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x15b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x15c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x160,    0xffffffff, 0xa0800  },
-{REG_TYPE_INDEX_VPP_COEF,	0x161,    0xffffffff, 0xc0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x162,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x163,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x164,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x168,    0xffffffff, 0x80800  },
-{REG_TYPE_INDEX_VPP_COEF,	0x169,    0xffffffff, 0xcb   },
-{REG_TYPE_INDEX_VPP_COEF,	0x16a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x16b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x16c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x170,    0xffffffff, 0x60800  },
-{REG_TYPE_INDEX_VPP_COEF,	0x171,    0xffffffff, 0xd4   },
-{REG_TYPE_INDEX_VPP_COEF,	0x172,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x173,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x174,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x178,    0xffffffff, 0x40600  },
-{REG_TYPE_INDEX_VPP_COEF,	0x179,    0xffffffff, 0xdb   },
-{REG_TYPE_INDEX_VPP_COEF,	0x17a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x17b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x17c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x180,    0xffffffff, 0x60600  },
-{REG_TYPE_INDEX_VPP_COEF,	0x181,    0xffffffff, 0xea   },
-{REG_TYPE_INDEX_VPP_COEF,	0x182,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x183,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x184,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x188,    0xffffffff, 0x60600  },
-{REG_TYPE_INDEX_VPP_COEF,	0x189,    0xffffffff, 0xf7   },
-{REG_TYPE_INDEX_VPP_COEF,	0x18a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x18b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x18c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x190,    0xffffffff, 0x60600  },
-{REG_TYPE_INDEX_VPP_COEF,	0x191,    0xffffffff, 0x3   },
-{REG_TYPE_INDEX_VPP_COEF,	0x192,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x193,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x194,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x198,    0xffffffff, 0x80800  },
-{REG_TYPE_INDEX_VPP_COEF,	0x199,    0xffffffff, 0x9   },
-{REG_TYPE_INDEX_VPP_COEF,	0x19a,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x19b,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x19c,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a0,    0xffffffff, 0x60a00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a1,    0xffffffff, 0xc   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a2,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a3,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a4,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a8,    0xffffffff, 0x60d00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a9,    0xffffffff, 0xe   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1aa,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ab,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ac,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b0,    0xffffffff, 0x80d00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b1,    0xffffffff, 0xc   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b2,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b3,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b4,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b8,    0xffffffff, 0xa0d00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b9,    0xffffffff, 0x7   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ba,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1bb,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1bc,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c0,    0xffffffff, 0xf0f00  },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c1,    0xffffffff, 0xfb   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c2,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c3,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c4,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c8,    0xffffffff, 0x110f00 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c9,    0xffffffff, 0xf2   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ca,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1cb,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1cc,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d0,    0xffffffff, 0x131100 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d1,    0xffffffff, 0xee   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d2,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d3,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d4,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d8,    0xffffffff, 0x131500 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d9,    0xffffffff, 0xf5   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1da,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1db,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1dc,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e0,    0xffffffff, 0x151a00 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e1,    0xffffffff, 0x1   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e2,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e3,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e4,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e8,    0xffffffff, 0x171c00 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e9,    0xffffffff, 0x5   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ea,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1eb,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ec,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f0,    0xffffffff, 0x171a00 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f1,    0xffffffff, 0x5   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f2,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f3,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f4,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f8,    0xffffffff, 0x131500 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f9,    0xffffffff, 0x7   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1fa,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1fb,    0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1fc,    0xffffffff, 0x0   },
-{0}
-	}
-};
-struct am_regs_s cmreg_enhancement={
-	172,
-	{
-/* enhancement */
-{REG_TYPE_INDEX_VPPCHROMA,	0x200,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x201,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x202,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x203,	  0xffffffff, 0x8000400},
-{REG_TYPE_INDEX_VPPCHROMA,	0x204,	  0xffffffff, 0x90   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x205,	  0xffffffff, 0x437077f},
-{REG_TYPE_INDEX_VPPCHROMA,	0x206,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x207,	  0xffffffff, 0x2640000},
-{REG_TYPE_INDEX_VPPCHROMA,	0x208,	  0xffffffff, 0x7a   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x209,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x20a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPPCHROMA,	0x20f,	  0xf, 0x0,   },
-{REG_TYPE_INDEX_VPP_COEF,	0x100,	  0xffffffff, 0x2b5600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x101,	  0xffffffff, 0xc   },
-{REG_TYPE_INDEX_VPP_COEF,	0x102,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x103,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x104,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x108,	  0xffffffff, 0x295600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x109,	  0xffffffff, 0x1f   },
-{REG_TYPE_INDEX_VPP_COEF,	0x10a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x10b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x10c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x110,	  0xffffffff, 0x295600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x111,	  0xffffffff, 0x33   },
-{REG_TYPE_INDEX_VPP_COEF,	0x112,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x113,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x114,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x118,	  0xffffffff, 0x2b5600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x119,	  0xffffffff, 0x3f   },
-{REG_TYPE_INDEX_VPP_COEF,	0x11a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x11b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x11c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x120,	  0xffffffff, 0x2b5600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x121,	  0xffffffff, 0x3f   },
-{REG_TYPE_INDEX_VPP_COEF,	0x122,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x123,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x124,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x128,	  0xffffffff, 0x295600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x129,	  0xffffffff, 0x3f   },
-{REG_TYPE_INDEX_VPP_COEF,	0x12a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x12b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x12c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x130,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x131,	  0xffffffff, 0x3f   },
-{REG_TYPE_INDEX_VPP_COEF,	0x132,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x133,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x134,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x138,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x139,	  0xffffffff, 0x33   },
-{REG_TYPE_INDEX_VPP_COEF,	0x13a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x13b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x13c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x140,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x141,	  0xffffffff, 0x9   },
-{REG_TYPE_INDEX_VPP_COEF,	0x142,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x143,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x144,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x148,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x149,	  0xffffffff, 0xea   },
-{REG_TYPE_INDEX_VPP_COEF,	0x14a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x14b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x14c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x150,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x151,	  0xffffffff, 0xd4   },
-{REG_TYPE_INDEX_VPP_COEF,	0x152,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x153,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x154,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x158,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x159,	  0xffffffff, 0xc5   },
-{REG_TYPE_INDEX_VPP_COEF,	0x15a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x15b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x15c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x160,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x161,	  0xffffffff, 0xc1   },
-{REG_TYPE_INDEX_VPP_COEF,	0x162,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x163,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x164,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x168,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x169,	  0xffffffff, 0xcb   },
-{REG_TYPE_INDEX_VPP_COEF,	0x16a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x16b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x16c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x170,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x171,	  0xffffffff, 0xd6   },
-{REG_TYPE_INDEX_VPP_COEF,	0x172,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x173,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x174,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x178,	  0xffffffff, 0x295600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x179,	  0xffffffff, 0xdb   },
-{REG_TYPE_INDEX_VPP_COEF,	0x17a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x17b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x17c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x180,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x181,	  0xffffffff, 0xec   },
-{REG_TYPE_INDEX_VPP_COEF,	0x182,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x183,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x184,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x188,	  0xffffffff, 0x295600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x189,	  0xffffffff, 0xf9   },
-{REG_TYPE_INDEX_VPP_COEF,	0x18a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x18b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x18c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x190,	  0xffffffff, 0x295600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x191,	  0xffffffff, 0x3   },
-{REG_TYPE_INDEX_VPP_COEF,	0x192,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x193,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x194,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x198,	  0xffffffff, 0x295600 },
-{REG_TYPE_INDEX_VPP_COEF,	0x199,	  0xffffffff, 0x9   },
-{REG_TYPE_INDEX_VPP_COEF,	0x19a,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x19b,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x19c,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a0,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a1,	  0xffffffff, 0xc   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a2,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a3,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a4,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a8,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1a9,	  0xffffffff, 0xe   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1aa,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ab,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ac,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b0,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b1,	  0xffffffff, 0xc   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b2,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b3,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b4,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b8,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1b9,	  0xffffffff, 0x7   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ba,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1bb,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1bc,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c0,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c1,	  0xffffffff, 0xfb   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c2,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c3,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c4,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c8,	  0xffffffff, 0x295400 },
-{REG_TYPE_INDEX_VPP_COEF,	0x1c9,	  0xffffffff, 0xf2   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ca,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1cb,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1cc,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d0,	  0xffffffff, 0x2295400},
-{REG_TYPE_INDEX_VPP_COEF,	0x1d1,	  0xffffffff, 0xee   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d2,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d3,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d4,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1d8,	  0xffffffff, 0x4295400},
-{REG_TYPE_INDEX_VPP_COEF,	0x1d9,	  0xffffffff, 0xf5   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1da,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1db,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1dc,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e0,	  0xffffffff, 0x8295400},
-{REG_TYPE_INDEX_VPP_COEF,	0x1e1,	  0xffffffff, 0x1   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e2,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e3,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e4,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1e8,	  0xffffffff, 0x8295400},
-{REG_TYPE_INDEX_VPP_COEF,	0x1e9,	  0xffffffff, 0x5   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ea,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1eb,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1ec,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f0,	  0xffffffff, 0x8295400},
-{REG_TYPE_INDEX_VPP_COEF,	0x1f1,	  0xffffffff, 0x5   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f2,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f3,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f4,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1f8,	  0xffffffff, 0x4295400},
-{REG_TYPE_INDEX_VPP_COEF,	0x1f9,	  0xffffffff, 0x7   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1fa,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1fb,	  0xffffffff, 0x0   },
-{REG_TYPE_INDEX_VPP_COEF,	0x1fc,	  0xffffffff, 0x0   },
-{0}
-	}
-};
+unsigned int sync_3d_h_start = 0;
+module_param(sync_3d_h_start, uint, 0664);
+MODULE_PARM_DESC(sync_3d_h_start, "\n sync_3d_h_start \n");
 
-module_param(video_rgb_ogo_mode_sw, int, 0664);
-MODULE_PARM_DESC(video_rgb_ogo_mode_sw, "enable/disable video_rgb_ogo_mode_sw");
+unsigned int sync_3d_h_end = 0;
+module_param(sync_3d_h_end, uint, 0664);
+MODULE_PARM_DESC(sync_3d_h_end, "\n sync_3d_h_end \n");
 
-static int frame_lock_freq = 0;
-module_param(frame_lock_freq, int, 0664);
-MODULE_PARM_DESC(frame_lock_freq, "frame_lock_50");
+unsigned int sync_3d_v_start = 10;
+module_param(sync_3d_v_start, uint, 0664);
+MODULE_PARM_DESC(sync_3d_v_start, "\n sync_3d_v_start \n");
 
-/*
-* set the frame size for cm2 demo
-*/
-static void cm2_frame_switch_patch(void)
-{
-    WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x20f);
-    WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, cm2_patch_flag);
-}
-#if (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD)
-static void ve_frame_size_patch(unsigned int width,unsigned int height)
-{
-    unsigned int vpp_size = height|(width << 16);
-    if(ve_size != vpp_size){
-	WRITE_CBUS_REG(VPP_VE_H_V_SIZE, vpp_size);
-	ve_size = vpp_size;
-    }
-}
-#endif
-static void cm2_frame_size_patch(unsigned int width,unsigned int height)
-{
-    unsigned int vpp_size;
-    /*check if the cm2 enable/disable to config the cm2 size*/
-    if(!(READ_CBUS_REG(VPP_MISC)&(0x1<<28)))
-        return;
-
-    vpp_size = width|(height << 16);
-    if(cm_size == 0){
-         WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x205);
-         cm_size = READ_CBUS_REG(VPP_CHROMA_DATA_PORT);
-    }
-    if (cm_size != vpp_size) {
-        WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x205);
-        WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, vpp_size);
-        WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x209);
-        WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, width<<15);
-        WRITE_CBUS_REG(VPP_CHROMA_ADDR_PORT, 0x20a);
-        WRITE_CBUS_REG(VPP_CHROMA_DATA_PORT, height<<16);
-        cm_size =  vpp_size;
-    }
-#ifdef PQ_DEBUG_EN
-	printk("\n[amvecm..]cm2_frame_patch: set cm2 framesize %x, set demo mode  %x\n",vpp_size, cm2_patch_flag);
-#endif
-}
+unsigned int sync_3d_v_end = 20;
+module_param(sync_3d_v_end, uint, 0664);
+MODULE_PARM_DESC(sync_3d_v_end, "\n sync_3d_v_end \n");
 
-void amvecm_video_latch(void)
-{
-    unsigned int hs, he, vs, ve;
-
-    if ((vecm_latch_flag & FLAG_REG_MAP0) ||
-    	(vecm_latch_flag & FLAG_REG_MAP1) ||
-    	(vecm_latch_flag & FLAG_REG_MAP2) ||
-    	(vecm_latch_flag & FLAG_REG_MAP3) ||
-    	(vecm_latch_flag & FLAG_REG_MAP4) ||
-    	(vecm_latch_flag & FLAG_REG_MAP5)
-       )
-    {
-    	if (vecm_latch_flag & FLAG_REG_MAP0) {
-            am_set_regmap(&amregs0);
-            vecm_latch_flag &= ~FLAG_REG_MAP0;
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] load reg 0 table OK!!!\n");
-#endif
-    	}
-    	if (vecm_latch_flag & FLAG_REG_MAP1) {
-            am_set_regmap(&amregs1);
-            vecm_latch_flag &= ~FLAG_REG_MAP1;
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] load reg 1 table OK!!!\n");
-#endif
-    	}
-    	if (vecm_latch_flag & FLAG_REG_MAP2) {
-            am_set_regmap(&amregs2);
-            vecm_latch_flag &= ~FLAG_REG_MAP2;
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] load reg 2 table OK!!!\n");
-#endif
-    	}
-    	if (vecm_latch_flag & FLAG_REG_MAP3) {
-            am_set_regmap(&amregs3);
-            vecm_latch_flag &= ~FLAG_REG_MAP3;
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] load reg 3 table OK!!!\n");
-#endif
-    	}
-    	if (vecm_latch_flag & FLAG_REG_MAP4) {
-            am_set_regmap(&amregs4);
-            vecm_latch_flag &= ~FLAG_REG_MAP4;
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] load reg 4 table OK!!!\n");
-#endif
-    	}
-    	if (vecm_latch_flag & FLAG_REG_MAP5) {
-            am_set_regmap(&amregs5);
-            vecm_latch_flag &= ~FLAG_REG_MAP5;
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] load reg 5 table OK!!!\n");
+unsigned int sync_3d_polarity = 0;
+module_param(sync_3d_polarity, uint, 0664);
+MODULE_PARM_DESC(sync_3d_polarity, "\n sync_3d_polarity \n");
+
+unsigned int sync_3d_out_inv = 0;
+module_param(sync_3d_out_inv, uint, 0664);
+MODULE_PARM_DESC(sync_3d_out_inv, "\n sync_3d_out_inv \n");
+
+unsigned int sync_3d_black_en = 0;
+module_param(sync_3d_black_en, uint, 0664);
+MODULE_PARM_DESC(sync_3d_black_en, "\n sync_3d_black_en \n");
+
+unsigned int sync_3d_black_color = 0x008080;//yuv black
+module_param(sync_3d_black_color, uint, 0664);
+MODULE_PARM_DESC(sync_3d_black_color, "\n sync_3d_black_color \n");
+
+unsigned int sync_3d_sync_to_vbo = 0;//3d sync to v by one enable/disable
+module_param(sync_3d_sync_to_vbo, uint, 0664);
+MODULE_PARM_DESC(sync_3d_sync_to_vbo, "\n sync_3d_sync_to_vbo \n");
 #endif
-    	}
 
-	if((cm2_patch_flag & 0xff) > 0)
-	    cm2_frame_switch_patch();
-    }
-    hs = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_H_START_END,16,12);
-    he = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_H_START_END,0,12);
+unsigned int pq_load_en = 1;// load pq table enable/disable
+module_param(pq_load_en, uint, 0664);
+MODULE_PARM_DESC(pq_load_en, "\n pq_load_en \n");
 
-    vs = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_V_START_END,16,12);
-    ve = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_V_START_END,0,12);
-#if ((MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8B))
-    if(cm_en)
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV)
+bool wb_gamma_en = 0;  // wb_gamma_en enable/disable
+#else
+bool wb_gamma_en = 1;
 #endif
-        cm2_frame_size_patch(he-hs+1,ve-vs+1);
-#if (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD)
-    ve_frame_size_patch(he-hs+1,ve-vs+1);
+module_param(wb_gamma_en, bool, 0664);
+MODULE_PARM_DESC(wb_gamma_en, "\n wb_gamma_en \n");
+
+extern unsigned int cm_size;
+extern unsigned int ve_size;
+extern unsigned int cm2_patch_flag;
+extern struct ve_dnlp_s am_ve_dnlp;
+extern struct ve_dnlp_table_s am_ve_new_dnlp;
+extern int cm_en;//0:disabel;1:enable
+extern struct tcon_gamma_table_s video_gamma_table_r;
+extern struct tcon_gamma_table_s video_gamma_table_g;
+extern struct tcon_gamma_table_s video_gamma_table_b;
+extern struct tcon_gamma_table_s video_gamma_table_r_adj;
+extern struct tcon_gamma_table_s video_gamma_table_g_adj;
+extern struct tcon_gamma_table_s video_gamma_table_b_adj;
+extern struct tcon_rgb_ogo_s     video_rgb_ogo;
+
+static void amvecm_size_patch(void)
+{
+	unsigned int hs, he, vs, ve;
+	hs = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_H_START_END,16,12);
+	he = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_H_START_END,0,12);
+
+	vs = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_V_START_END,16,12);
+	ve = READ_CBUS_REG_BITS(VPP_POSTBLEND_VD1_V_START_END,0,12);
+#if ((MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8B))
+	if(cm_en)
 #endif
-    if (vecm_latch_flag & FLAG_VE_DNLP)
-    {
-        vecm_latch_flag &= ~FLAG_VE_DNLP;
-        ve_set_dnlp(&am_ve_dnlp);
-    }
-    if (vecm_latch_flag & FLAG_VE_NEW_DNLP)
-    {
-        vecm_latch_flag &= ~FLAG_VE_NEW_DNLP;
-        ve_set_new_dnlp(&am_ve_new_dnlp);
-    }
-	if (vecm_latch_flag & FLAG_VE_DNLP_EN)
-	{
-		vecm_latch_flag &= ~FLAG_VE_DNLP_EN;
-		ve_enable_dnlp();
-#ifdef PQ_DEBUG_EN
-		printk("\n[amvecm..] set vpp_enable_dnlp OK!!!\n");
+	cm2_frame_size_patch(he-hs+1,ve-vs+1);
+#if (MESON_CPU_TYPE>=MESON_CPU_TYPE_MESON6TVD)
+	ve_frame_size_patch(he-hs+1,ve-vs+1);
 #endif
+
+}
+
+static void vd1_brightness_contrast(signed int brightness, signed int contrast)
+{
+	signed int ao0 =  -64, g00 = 1024, g01 =    0, g02 =    0, po0 =  64;
+	signed int ao1 = -512, g10 =    0, g11 = 1024, g12 =    0, po1 = 512;
+	signed int ao2 = -512, g20 =    0, g21 =    0, g22 = 1024, po2 = 512;
+	unsigned int gc0 =    0, gc1 =    0, gc2 =    0, gc3 =    0, gc4 =   0;
+	unsigned int a01 =    0, a_2 =    0, p01 =    0, p_2 =    0;
+	// enable vd0_csc
+	unsigned int ori = READ_CBUS_REG(VPP_MATRIX_CTRL) | 0x00000020;
+	// point to vd0_csc
+	unsigned int ctl = (ori & 0xfffffcff) | 0x00000100;
+	po0 += brightness >> 1;
+	if (po0 >  1023) po0 =  1023;
+	if (po0 < -1024) po0 = -1024;
+	g00  *= contrast + 2048;
+	g00 >>= 11;
+	if (g00 >  4095) g00 =  4095;
+	if (g00 < -4096) g00 = -4096;
+	if (contrast < 0){
+		g11  *= contrast   + 2048;
+		g11 >>= 11;
 	}
-	if (vecm_latch_flag & FLAG_VE_DNLP_DIS)
-	{
-		vecm_latch_flag &= ~FLAG_VE_DNLP_DIS;
-		ve_disable_dnlp();
-#ifdef PQ_DEBUG_EN
-		printk("\n[amvecm..] set vpp_disable_dnlp OK!!!\n");
-#endif
+	if (brightness < 0){
+		g11  += brightness >> 1;
+		if (g11 >  4095) g11 =  4095;
+		if (g11 < -4096) g11 = -4096;
 	}
-    if (vecm_latch_flag & FLAG_GAMMA_TABLE_EN)
-    {
-        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_EN;
-        vpp_enable_lcd_gamma_table();
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] set vpp_enable_lcd_gamma_table OK!!!\n");
-#endif
-    }
-    if (vecm_latch_flag & FLAG_GAMMA_TABLE_DIS)
-    {
-        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_DIS;
-        vpp_disable_lcd_gamma_table();
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] set vpp_disable_lcd_gamma_table OK!!!\n");
-#endif
-    }
-    if (vecm_latch_flag & FLAG_GAMMA_TABLE_R)
-    {
-        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_R;
-        vpp_set_lcd_gamma_table(video_gamma_table_r.data, H_SEL_R);
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] set vpp_set_lcd_gamma_table OK!!!\n");
-#endif
-    }
-    if (vecm_latch_flag & FLAG_GAMMA_TABLE_G)
-    {
-        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_G;
-        vpp_set_lcd_gamma_table(video_gamma_table_g.data, H_SEL_G);
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] set vpp_set_lcd_gamma_table OK!!!\n");
-#endif
-    }
-    if (vecm_latch_flag & FLAG_GAMMA_TABLE_B)
-    {
-        vecm_latch_flag &= ~FLAG_GAMMA_TABLE_B;
-        vpp_set_lcd_gamma_table(video_gamma_table_b.data, H_SEL_B);
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] set vpp_set_lcd_gamma_table OK!!!\n");
-#endif
-    }
-    if (vecm_latch_flag & FLAG_RGB_OGO)
-    {
-        vecm_latch_flag &= ~FLAG_RGB_OGO;
-        if (video_rgb_ogo_mode_sw)
-        {
-            if (video_rgb_ogo.en)
-            {
-                vpp_set_lcd_gamma_table(video_gamma_table_r_adj.data, H_SEL_R);
-                vpp_set_lcd_gamma_table(video_gamma_table_g_adj.data, H_SEL_G);
-                vpp_set_lcd_gamma_table(video_gamma_table_b_adj.data, H_SEL_B);
-            }
-            else
-            {
-                vpp_set_lcd_gamma_table(video_gamma_table_r.data, H_SEL_R);
-                vpp_set_lcd_gamma_table(video_gamma_table_g.data, H_SEL_G);
-                vpp_set_lcd_gamma_table(video_gamma_table_b.data, H_SEL_B);
-            }
-	#ifdef PQ_DEBUG_EN
-            printk("\n[amvecm..] set vpp_set_lcd_gamma_table OK!!!\n");
-	#endif
-        }
-        else
-        {
-            vpp_set_rgb_ogo(&video_rgb_ogo);
-	#ifdef PQ_DEBUG_EN
-            printk("\n[amvecm..] set vpp_set_rgb_ogo OK!!!\n");
+	if (contrast < 0){
+		g22  *= contrast   + 2048;
+		g22 >>= 11;
+	}
+	if (brightness < 0){
+		g22  += brightness >> 1;
+		if (g22 >  4095) g22 =  4095;
+		if (g22 < -4096) g22 = -4096;
+	}
+	gc0 = ((g00 << 16) & 0x1fff0000) | ((g01 <<  0) & 0x00001fff);
+	gc1 = ((g02 << 16) & 0x1fff0000) | ((g10 <<  0) & 0x00001fff);
+	gc2 = ((g11 << 16) & 0x1fff0000) | ((g12 <<  0) & 0x00001fff);
+	gc3 = ((g20 << 16) & 0x1fff0000) | ((g21 <<  0) & 0x00001fff);
+	gc4 = ((g22 <<  0) & 0x00001fff);
+	#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV)
+	a01 = ((ao0 << 16) & 0x0fff0000) | ((ao1 <<  0) & 0x00000fff);
+	a_2 = ((ao2 <<  0) & 0x00000fff);
+	p01 = ((po0 << 16) & 0x0fff0000) | ((po1 <<  0) & 0x00000fff);
+	p_2 = ((po2 <<  0) & 0x00000fff);
+	#else
+	a01 = ((ao0 << 16) & 0x07ff0000) | ((ao1 <<  0) & 0x000007ff);
+	a_2 = ((ao2 <<  0) & 0x000007ff);
+	p01 = ((po0 << 16) & 0x07ff0000) | ((po1 <<  0) & 0x000007ff);
+	p_2 = ((po2 <<  0) & 0x000007ff);
 	#endif
-        }
-    }
-    if (vecm_latch_flag & FLAG_BRI_CON)
-    {
-        vecm_latch_flag &= ~FLAG_BRI_CON;
-        vd1_brightness_contrast(vd1_brightness, vd1_contrast);
-#ifdef PQ_DEBUG_EN
-        printk("\n[amvecm..] set vd1_brightness_contrast OK!!!\n");
-#endif
-    }
-    if (cm_en&&(cm_level_last != cm_level))
-    {
-    	cm_level_last = cm_level;
-    	WRITE_CBUS_REG_BITS(VPP_MISC,1,28,1);//CM manage enable
-    	if(cm_level == 1)
-    		am_set_regmap(&cmreg_lever1);
-	else if(cm_level == 2)
-		am_set_regmap(&cmreg_lever2);
-	else if(cm_level == 3)
-		am_set_regmap(&cmreg_lever3);
-	else if(cm_level == 4)
-		am_set_regmap(&cmreg_enhancement);
-	else
-		am_set_regmap(&cmreg_optimize);
-#if 1//def PQ_DEBUG_EN
-        printk("\n[amvecm..] set cm2 load OK!!!\n");
-#endif
-    }
-    else if(cm_en == 0){
-    	cm_level_last = 0xff;
-    	WRITE_CBUS_REG_BITS(VPP_MISC,0,28,1);//CM manage enable
-    }
-    if(dnlp_en&&dnlp_status)
-    {
-	dnlp_status = 0;
-	ve_set_dnlp_2();
-	ve_enable_dnlp();
-#ifdef PQ_DEBUG_EN
-	printk("\n[amvecm..] set vpp_enable_dnlp OK!!!\n");
-#endif
-    }
-    else if(dnlp_en == 0){
-    	dnlp_status = 1;
-    	ve_disable_dnlp();
-#ifdef PQ_DEBUG_EN
-	printk("\n[amvecm..] set vpp_disable_dnlp OK!!!\n");
-#endif
-    }
-#if ((MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE==MESON_CPU_TYPE_MESON6TVD))
-    /* lvds freq 50Hz/60Hz */
-    if (frame_lock_freq == 1)  //50 hz
-    {
-        // panel freq is 60Hz => change back to 50Hz
-        if (READ_MPEG_REG(ENCP_VIDEO_MAX_LNCNT) < 1237) // (1124 + 1349 +1) / 2
-        {
-            WRITE_MPEG_REG(ENCP_VIDEO_MAX_LNCNT, 1349);
-        }
-    }
-    else if (frame_lock_freq == 2)  //60 hz
-    {
-        // panel freq is 50Hz => change back to 60Hz
-        if (READ_MPEG_REG(ENCP_VIDEO_MAX_LNCNT) >= 1237) // (1124 + 1349 + 1) / 2
-        {
-            WRITE_MPEG_REG(ENCP_VIDEO_MAX_LNCNT, 1124);
-        }
-    }
-    else if (frame_lock_freq == 0)
-    {
-        /* lvds freq 50Hz/60Hz */
-        if (vecm_latch_flag & FLAG_LVDS_FREQ_SW)  //50 hz
-        {
-            // panel freq is 60Hz => change back to 50Hz
-            if (READ_MPEG_REG(ENCP_VIDEO_MAX_LNCNT) < 1237) // (1124 + 1349 +1) / 2
-            {
-                WRITE_MPEG_REG(ENCP_VIDEO_MAX_LNCNT, 1349);
-            }
-        }
-        else   //60 hz
-        {
-            // panel freq is 50Hz => change back to 60Hz
-            if (READ_MPEG_REG(ENCP_VIDEO_MAX_LNCNT) >= 1237) // (1124 + 1349 + 1) / 2
-            {
-                WRITE_MPEG_REG(ENCP_VIDEO_MAX_LNCNT, 1124);
-            }
-        }
-    }
-#endif
-
+	WRITE_CBUS_REG(VPP_MATRIX_CTRL         , ctl);
+	WRITE_CBUS_REG(VPP_MATRIX_COEF00_01    , gc0);
+	WRITE_CBUS_REG(VPP_MATRIX_COEF02_10    , gc1);
+	WRITE_CBUS_REG(VPP_MATRIX_COEF11_12    , gc2);
+	WRITE_CBUS_REG(VPP_MATRIX_COEF20_21    , gc3);
+	WRITE_CBUS_REG(VPP_MATRIX_COEF22       , gc4);
+	WRITE_CBUS_REG(VPP_MATRIX_PRE_OFFSET0_1, a01);
+	WRITE_CBUS_REG(VPP_MATRIX_PRE_OFFSET2  , a_2);
+	WRITE_CBUS_REG(VPP_MATRIX_OFFSET0_1    , p01);
+	WRITE_CBUS_REG(VPP_MATRIX_OFFSET2      , p_2);
+	WRITE_CBUS_REG(VPP_MATRIX_CTRL         , ori);
 }
-EXPORT_SYMBOL(amvecm_video_latch);
 
-/*
-amvecm device driver
-*/
-struct tcon_gamma_table_s video_curve_2d2_inv =
+static void amvecm_bricon_process(void)
 {
-	{
-	   0,	82,  113,  136,  155,  171,  186,  199,  212,  223,  234,  245,  255,  264,  273,  282,
-	 290,  298,  306,  314,  321,  328,  335,  342,  349,  356,  362,  368,  374,  380,  386,  392,
-	 398,  403,  409,  414,  420,  425,  430,  435,  440,  445,  450,  455,  460,  464,  469,  474,
-	 478,  483,  487,  492,  496,  500,  505,  509,  513,  517,  521,  525,  529,  533,  537,  541,
-	 545,  549,  553,  556,  560,  564,  568,  571,  575,  579,  582,  586,  589,  593,  596,  600,
-	 603,  607,  610,  613,  617,  620,  623,  627,  630,  633,  636,  640,  643,  646,  649,  652,
-	 655,  658,  661,  665,  668,  671,  674,  677,  680,  683,  686,  688,  691,  694,  697,  700,
-	 703,  706,  709,  711,  714,  717,  720,  723,  725,  728,  731,  733,  736,  739,  742,  744,
-	 747,  750,  752,  755,  757,  760,  763,  765,  768,  770,  773,  775,  778,  780,  783,  785,
-	 788,  790,  793,  795,  798,  800,  803,  805,  808,  810,  812,  815,  817,  820,  822,  824,
-	 827,  829,  831,  834,  836,  838,  841,  843,  845,  847,  850,  852,  854,  856,  859,  861,
-	 863,  865,  868,  870,  872,  874,  876,  879,  881,  883,  885,  887,  889,  892,  894,  896,
-	 898,  900,  902,  904,  906,  909,  911,  913,  915,  917,  919,  921,  923,  925,  927,  929,
-	 931,  933,  935,  937,  939,  941,  943,  945,  947,  949,  951,  953,  955,  957,  959,  961,
-	 963,  965,  967,  969,  971,  973,  975,  977,  979,  981,  982,  984,  986,  988,  990,  992,
-	 994,  996,  998,  999, 1001, 1003, 1005, 1007, 1009, 1011, 1012, 1014, 1016, 1018, 1020, 1022,
-	},
-};
-
-struct tcon_gamma_table_s video_curve_2d2 =
-{
-	{
-	   0,	 0,    0,	 0,    0,	 0,    0,	 0,    1,	 1,    1,	 1,    1,	 1,    2,	 2,
-	   2,	 3,    3,	 3,    4,	 4,    5,	 5,    6,	 6,    7,	 7,    8,	 9,    9,	10,
-	  11,	11,   12,	13,   14,	15,   15,	16,   17,	18,   19,	20,   21,	22,   23,	25,
-	  26,	27,   28,	29,   31,	32,   33,	35,   36,	38,   39,	41,   42,	44,   45,	47,
-	  49,	50,   52,	54,   55,	57,   59,	61,   63,	65,   67,	69,   71,	73,   75,	77,
-	  79,	82,   84,	86,   88,	91,   93,	95,   98,  100,  103,  105,  108,  110,  113,  116,
-	 118,  121,  124,  127,  130,  132,  135,  138,  141,  144,  147,  150,  154,  157,  160,  163,
-	 166,  170,  173,  176,  180,  183,  187,  190,  194,  197,  201,  204,  208,  212,  216,  219,
-	 223,  227,  231,  235,  239,  243,  247,  251,  255,  259,  263,  267,  272,  276,  280,  285,
-	 289,  294,  298,  303,  307,  312,  316,  321,  326,  330,  335,  340,  345,  350,  355,  360,
-	 365,  370,  375,  380,  385,  390,  395,  401,  406,  411,  417,  422,  427,  433,  438,  444,
-	 450,  455,  461,  467,  472,  478,  484,  490,  496,  502,  508,  514,  520,  526,  532,  538,
-	 544,  551,  557,  563,  570,  576,  583,  589,  596,  602,  609,  615,  622,  629,  636,  642,
-	 649,  656,  663,  670,  677,  684,  691,  698,  705,  713,  720,  727,  735,  742,  749,  757,
-	 764,  772,  779,  787,  795,  802,  810,  818,  826,  833,  841,  849,  857,  865,  873,  881,
-	 889,  898,  906,  914,  922,  931,  939,  948,  956,  965,  973,  982,  990,  999, 1008, 1016,
-	},
-};
-
-static void video_data_limitation(int *val)
-{
-	if (*val > 1023)
-		*val = 1023;
-	if (*val <	  0)
-		*val =	  0;
+	if (vecm_latch_flag & FLAG_BRI_CON){
+		vecm_latch_flag &= ~FLAG_BRI_CON;
+		vd1_brightness_contrast(vd1_brightness, vd1_contrast);
+		pr_amvecm_dbg("\n[amvecm..] set vd1_brightness_contrast OK!!!\n");
+	}
 }
-
-static void video_lookup(struct tcon_gamma_table_s *tbl, int *val)
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV)
+static void amvecm_vlock_process(void)
 {
-	unsigned int idx = (*val) >> 2, mod = (*val) & 3;
-
-	if (idx < 255)
-		*val = tbl->data[idx] + (((tbl->data[idx + 1] - tbl->data[idx]) * mod + 2) >> 2);
-	else
-		*val = tbl->data[idx] + (((1023 			  - tbl->data[idx]) * mod + 2) >> 2);
+	return;
+	if(vlock_en == 0){
+		WRITE_CBUS_REG_BITS(VPU_VLOCK_CTRL,0,31,1);//disable vid_lock_en
+		return;
+	}
+	WRITE_CBUS_REG(HHI_VID_LOCK_CLK_CNTL,0x80);
+	if (vecm_latch_flag & FLAG_VLOCK_ENC){
+		am_set_regmap(&vlock_enc);
+		vecm_latch_flag &= ~FLAG_VLOCK_ENC;
+	}
+	if (vecm_latch_flag & FLAG_VLOCK_PLL){
+		am_set_regmap(&vlock_pll);
+		vecm_latch_flag &= ~FLAG_VLOCK_PLL;
+	}
+	WRITE_CBUS_REG(ENCL_MAX_LINE_SWITCH_POINT,READ_CBUS_REG(ENCL_MAX_LINE_SWITCH_POINT)|0x2000);
 }
-
-static void video_set_rgb_ogo(void)
-{
-	int i = 0, r = 0, g = 0, b = 0;
-
-	for (i = 0; i < 256; i++)
-	{
-		// Get curve_straight = input(curve_2d2_inv) * video_curve_2d2
-		r = video_curve_2d2.data[i];
-		g = video_curve_2d2.data[i];
-		b = video_curve_2d2.data[i];
-		// Pre_offset
-		r += video_rgb_ogo.r_pre_offset;
-		g += video_rgb_ogo.g_pre_offset;
-		b += video_rgb_ogo.b_pre_offset;
-		video_data_limitation(&r);
-		video_data_limitation(&g);
-		video_data_limitation(&b);
-		// Gain
-		r  *= video_rgb_ogo.r_gain;
-		r >>= 10;
-		g  *= video_rgb_ogo.g_gain;
-		g >>= 10;
-		b  *= video_rgb_ogo.b_gain;
-		b >>= 10;
-		video_data_limitation(&r);
-		video_data_limitation(&g);
-		video_data_limitation(&b);
-		// Post_offset
-		r += video_rgb_ogo.r_post_offset;
-		g += video_rgb_ogo.g_post_offset;
-		b += video_rgb_ogo.b_post_offset;
-		video_data_limitation(&r);
-		video_data_limitation(&g);
-		video_data_limitation(&b);
-		// Get curve_2d2_inv_ogo = curve_straight_ogo * video_curve_2d2_inv
-		video_lookup(&video_curve_2d2_inv, &r);
-		video_lookup(&video_curve_2d2_inv, &g);
-		video_lookup(&video_curve_2d2_inv, &b);
-		// Get gamma_ogo = curve_2d2_inv_ogo * gamma
-		video_lookup(&video_gamma_table_r, &r);
-		video_lookup(&video_gamma_table_g, &g);
-		video_lookup(&video_gamma_table_b, &b);
-		// Save gamma_ogo
-		video_gamma_table_r_adj.data[i] = r;
-		video_gamma_table_g_adj.data[i] = g;
-		video_gamma_table_b_adj.data[i] = b;
+static void amvecm_3d_black_process(void)
+{
+	if(vecm_latch_flag & FLAG_3D_BLACK_DIS){
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,0,31,1);//disable reg_3dsync_enable
+		WRITE_CBUS_REG_BITS(VIU_MISC_CTRL0,0,8,1);
+		WRITE_CBUS_REG_BITS(VPP_BLEND_ONECOLOR_CTRL,0,26,1);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,0,13,1);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC2,0,31,1);
+		vecm_latch_flag &= ~FLAG_3D_BLACK_DIS;
+	}
+	if(vecm_latch_flag & FLAG_3D_BLACK_EN){
+		WRITE_CBUS_REG_BITS(VIU_MISC_CTRL0,1,8,1);
+		WRITE_CBUS_REG_BITS(VPP_BLEND_ONECOLOR_CTRL,1,26,1);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC2,1,31,1);
+		WRITE_CBUS_REG_BITS(VPP_BLEND_ONECOLOR_CTRL,sync_3d_black_color&0xffffff,0,24);
+		if(sync_3d_sync_to_vbo)
+			WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,1,13,1);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,1,31,1);//enable
+		vecm_latch_flag &= ~FLAG_3D_BLACK_EN;
 	}
 }
+static void amvecm_3d_sync_process(void)
+{
 
-void vd1_brightness_contrast(signed int brightness, signed int contrast)
+	if(vecm_latch_flag & FLAG_3D_SYNC_DIS){
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,0,31,1);//disable reg_3dsync_enable
+		vecm_latch_flag &= ~FLAG_3D_SYNC_DIS;
+	}
+	if(vecm_latch_flag & FLAG_3D_SYNC_EN){
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC2,sync_3d_h_start,0,13);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC2,sync_3d_h_end,16,13);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,sync_3d_v_start,0,13);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,sync_3d_v_end,16,13);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,sync_3d_polarity,29,1);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,sync_3d_out_inv,15,1);
+		WRITE_CBUS_REG_BITS(VPU_VPU_3D_SYNC1,1,31,1);//enable
+		vecm_latch_flag &= ~FLAG_3D_SYNC_EN;
+	}
+}
+#endif
+void amvecm_video_latch(void)
 {
-      signed int ao0 =  -64, g00 = 1024, g01 =    0, g02 =    0, po0 =  64;
-      signed int ao1 = -512, g10 =    0, g11 = 1024, g12 =    0, po1 = 512;
-      signed int ao2 = -512, g20 =    0, g21 =    0, g22 = 1024, po2 = 512;
-    unsigned int gc0 =    0, gc1 =    0, gc2 =    0, gc3 =    0, gc4 =   0;
-    unsigned int a01 =    0, a_2 =    0, p01 =    0, p_2 =    0;
-    // enable vd0_csc
-    unsigned int ori = READ_CBUS_REG(VPP_MATRIX_CTRL) | 0x00000020;
-    // point to vd0_csc
-    unsigned int ctl = (ori & 0xfffffcff) | 0x00000100;
-
-    po0 += brightness >> 1;
-    if (po0 >  1023)
-        po0 =  1023;
-    if (po0 < -1024)
-        po0 = -1024;
-
-    g00  *= contrast + 2048;
-    g00 >>= 11;
-    if (g00 >  4095)
-        g00 =  4095;
-    if (g00 < -4096)
-        g00 = -4096;
-
-    if (contrast < 0)
-    {
-        g11  *= contrast   + 2048;
-        g11 >>= 11;
-    }
-
-    if (brightness < 0)
-    {
-        g11  += brightness >> 1;
-        if (g11 >  4095)
-            g11 =  4095;
-        if (g11 < -4096)
-            g11 = -4096;
-    }
-
-    if (contrast < 0)
-    {
-        g22  *= contrast   + 2048;
-        g22 >>= 11;
-    }
-
-    if (brightness < 0)
-    {
-        g22  += brightness >> 1;
-        if (g22 >  4095)
-            g22 =  4095;
-        if (g22 < -4096)
-            g22 = -4096;
-    }
-
-    gc0 = ((g00 << 16) & 0x1fff0000) |
-          ((g01 <<  0) & 0x00001fff);
-    gc1 = ((g02 << 16) & 0x1fff0000) |
-          ((g10 <<  0) & 0x00001fff);
-    gc2 = ((g11 << 16) & 0x1fff0000) |
-          ((g12 <<  0) & 0x00001fff);
-    gc3 = ((g20 << 16) & 0x1fff0000) |
-          ((g21 <<  0) & 0x00001fff);
-    gc4 = ((g22 <<  0) & 0x00001fff);
-    a01 = ((ao0 << 16) & 0x07ff0000) |
-          ((ao1 <<  0) & 0x000007ff);
-    a_2 = ((ao2 <<  0) & 0x000007ff);
-    p01 = ((po0 << 16) & 0x07ff0000) |
-          ((po1 <<  0) & 0x000007ff);
-    p_2 = ((po2 <<  0) & 0x000007ff);
-
-    WRITE_CBUS_REG(VPP_MATRIX_CTRL         , ctl);
-    WRITE_CBUS_REG(VPP_MATRIX_COEF00_01    , gc0);
-    WRITE_CBUS_REG(VPP_MATRIX_COEF02_10    , gc1);
-    WRITE_CBUS_REG(VPP_MATRIX_COEF11_12    , gc2);
-    WRITE_CBUS_REG(VPP_MATRIX_COEF20_21    , gc3);
-    WRITE_CBUS_REG(VPP_MATRIX_COEF22       , gc4);
-    WRITE_CBUS_REG(VPP_MATRIX_PRE_OFFSET0_1, a01);
-    WRITE_CBUS_REG(VPP_MATRIX_PRE_OFFSET2  , a_2);
-    WRITE_CBUS_REG(VPP_MATRIX_OFFSET0_1    , p01);
-    WRITE_CBUS_REG(VPP_MATRIX_OFFSET2      , p_2);
-    WRITE_CBUS_REG(VPP_MATRIX_CTRL         , ori);
+	//if (pq_load_en == 0)
+	//	return;
+	cm_latch_process();
+	amvecm_size_patch();
+	ve_dnlp_latch_process();
+	ve_lcd_gamma_process();
+	amvecm_bricon_process();
+	lvds_freq_process();
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV)
+	amvecm_vlock_process();
+	amvecm_3d_sync_process();
+	amvecm_3d_black_process();
+#endif
 }
+EXPORT_SYMBOL(amvecm_video_latch);
 
 static int amvecm_open(struct inode *inode, struct file *file)
 {
-    amvecm_dev_t *devp;
-
-    /* Get the per-device structure that contains this cdev */
-    devp = container_of(inode->i_cdev, amvecm_dev_t, cdev);
-    file->private_data = devp;
-
-    return 0;
+	amvecm_dev_t *devp;
+	/* Get the per-device structure that contains this cdev */
+	devp = container_of(inode->i_cdev, amvecm_dev_t, cdev);
+	file->private_data = devp;
+	return 0;
 }
 
 static int amvecm_release(struct inode *inode, struct file *file)
 {
-    //amvecm_dev_t *devp = file->private_data;
-
-    file->private_data = NULL;
-
-    return 0;
+	file->private_data = NULL;
+	return 0;
 }
+static struct am_regs_s amregs_ext;
 
 static long amvecm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-    int ret = 0;
-
-    switch (cmd)
-    {
-		case AMVECM_IOC_LOAD_REG: {
-#if 1
-		    if ((vecm_latch_flag & FLAG_REG_MAP0) &&
-		    	(vecm_latch_flag & FLAG_REG_MAP1) &&
-		    	(vecm_latch_flag & FLAG_REG_MAP2) &&
-		    	(vecm_latch_flag & FLAG_REG_MAP3) &&
-		    	(vecm_latch_flag & FLAG_REG_MAP4) &&
-		    	(vecm_latch_flag & FLAG_REG_MAP5)
-		       ) {
-		           ret = -EBUSY;
-			   printk(KERN_ERR "[amvecm..] load regs error: loading regs, please wait\n");
-			   goto out;
-		    }
-		    ret = -EFAULT;
-                    /*force set cm size to 0,enable check vpp size*/
-                    cm_size = 0;
-		    if (!(vecm_latch_flag & FLAG_REG_MAP0)) {
-		        if (copy_from_user(&amregs0, (void __user *)arg, sizeof(struct am_regs_s))) {
-				printk(KERN_ERR "[amvecm..]0 load reg errors: can't get buffer lenght\n");
-				goto out;
-			}
-			ret = -EINVAL;
-			if (!amregs0.length || (amregs0.length > 512)) {
-				printk(KERN_ERR "[amvecm..]0 load regs error: buffer length overflow!!!, length=0x%x \n",
-					amregs0.length);
-				goto out;
-			}
-#ifdef PQ_DEBUG_EN
-			printk("\n[amvecm..]0 reg length=0x%x ......\n", amregs0.length);
-#endif
-			vecm_latch_flag |= FLAG_REG_MAP0;
-		        ret = 0;
-			goto out;
-		    }
-		    if (!(vecm_latch_flag & FLAG_REG_MAP1)) {
-		        if (copy_from_user(&amregs1, (void __user *)arg, sizeof(struct am_regs_s))) {
-				printk(KERN_ERR "[amvecm..]1 load reg errors: can't get buffer lenght\n");
-				goto out;
-			}
-			ret = -EINVAL;
-			if (!amregs1.length || (amregs1.length > 512)) {
-				printk(KERN_ERR "[amvecm..]1 load regs error: buffer length overflow!!!, length=0x%x \n",
-					amregs1.length);
-				goto out;
-			}
-#ifdef PQ_DEBUG_EN
-			printk("\n[amvecm..]1 reg length=0x%x ......\n", amregs1.length);
-#endif
-			vecm_latch_flag |= FLAG_REG_MAP1;
-		        ret = 0;
-			goto out;
-		    }
-		    if (!(vecm_latch_flag & FLAG_REG_MAP2)) {
-		        if (copy_from_user(&amregs2, (void __user *)arg, sizeof(struct am_regs_s))) {
-				printk(KERN_ERR "[amvecm..]2 load reg errors: can't get buffer lenght\n");
-				goto out;
-			}
-			ret = -EINVAL;
-			if (!amregs2.length || (amregs2.length > 512)) {
-				printk(KERN_ERR "[amvecm..]2 load regs error: buffer length overflow!!!, length=0x%x \n",
-					amregs2.length);
-				goto out;
-			}
-#ifdef PQ_DEBUG_EN
-			printk("\n[amvecm..]2 reg length=0x%x ......\n", amregs1.length);
-#endif
-			vecm_latch_flag |= FLAG_REG_MAP2;
-		        ret = 0;
-			goto out;
-		    }
-		    if (!(vecm_latch_flag & FLAG_REG_MAP3)) {
-		        if (copy_from_user(&amregs3, (void __user *)arg, sizeof(struct am_regs_s))) {
-				printk(KERN_ERR "[amvecm..]3 load reg errors: can't get buffer lenght\n");
-				goto out;
-			}
-			ret = -EINVAL;
-			if (!amregs3.length || (amregs3.length > 512)) {
-				printk(KERN_ERR "[amvecm..]3 load regs error: buffer length overflow!!!, length=0x%x \n",
-					amregs3.length);
-				goto out;
-			}
-#ifdef PQ_DEBUG_EN
-			printk("\n[amvecm..]3 reg length=0x%x ......\n", amregs3.length);
-#endif
-			vecm_latch_flag |= FLAG_REG_MAP3;
-		        ret = 0;
-			goto out;
-		    }
-		    if (!(vecm_latch_flag & FLAG_REG_MAP4)) {
-		        if (copy_from_user(&amregs4, (void __user *)arg, sizeof(struct am_regs_s))) {
-				printk(KERN_ERR "[amvecm..]4 load reg errors: can't get buffer lenght\n");
-				goto out;
-			}
-			ret = -EINVAL;
-			if (!amregs4.length || (amregs4.length > 512)) {
-				printk(KERN_ERR "[amvecm..]4 load regs error: buffer length overflow!!!, length=0x%x \n",
-					amregs4.length);
-				goto out;
-			}
-#ifdef PQ_DEBUG_EN
-			printk("\n[amvecm..]4 reg length=0x%x ......\n", amregs1.length);
-#endif
-			vecm_latch_flag |= FLAG_REG_MAP4;
-		        ret = 0;
-			goto out;
-		    }
-		    if (!(vecm_latch_flag & FLAG_REG_MAP5)) {
-		        if (copy_from_user(&amregs5, (void __user *)arg, sizeof(struct am_regs_s))) {
-				printk(KERN_ERR "[amvecm..]5 load reg errors: can't get buffer lenght\n");
-				goto out;
-			}
-			ret = -EINVAL;
-			if (!amregs5.length || (amregs5.length > 512)) {
-				printk(KERN_ERR "[amvecm..]5 load regs error: buffer length overflow!!!, length=0x%x \n",
-					amregs5.length);
-				goto out;
-			}
-#ifdef PQ_DEBUG_EN
-			printk("\n[amvecm..]5 reg length=0x%x ......\n", amregs5.length);
-#endif
-			vecm_latch_flag |= FLAG_REG_MAP5;
-		        ret = 0;
-			goto out;
-		    }
-
-#else
-			if (vecm_latch_flag & FLAG_REG_MAP)
-			{
-			    if (hold_cmd_en) {
-			        while (vecm_latch_flag & FLAG_REG_MAP) {
-                #ifdef PQ_DEBUG_EN
-			            printk(KERN_ERR "[amvecm..] command busy, please wait!!!\n");
-                #else
-			            ;
-                #endif
-			         }
-			     } else {
-			         ret = -EBUSY;
-			         printk(KERN_ERR "[amvecm..] load regs error: loading regs, please wait\n");
-			         goto out;
-			     }
-			}
-			ret = -EFAULT;
-			if (copy_from_user(&amregs, (void __user *)arg, sizeof(struct am_regs_s))) {
-				printk(KERN_ERR "[amvecm..] load reg errors: can't get buffer lenght\n");
-				goto out;
-			}
-			ret = -EINVAL;
-			if (!amregs.length || (amregs.length > 512)) {
-				printk(KERN_ERR "[amvecm..] load regs error: buffer length overflow!!!, length=0x%x \n", amregs.length);
-				goto out;
-			}
-#ifdef PQ_DEBUG_EN
-			printk("\n[amvecm..] reg length=0x%x ......\n", amregs.length);
-#endif
-			vecm_latch_flag |= FLAG_REG_MAP;
-			ret = 0;
-#endif
-		out:
-			break;
-		}
-
-        case AMVECM_IOC_VE_DNLP_EN: {
-            if (vecm_latch_flag & FLAG_VE_DNLP_EN)
-            {
-                ret = -EFAULT;
-            }
-            else
-            {
-                vecm_latch_flag |= FLAG_VE_DNLP_EN;
-                printk(KERN_ERR "[amvecm..] ioctl: enable dnlp function\n");
-            }
-            break;
-        }
-
-        case AMVECM_IOC_VE_DNLP_DIS: {
-            if (vecm_latch_flag & FLAG_VE_DNLP_DIS)
-            {
-                ret = -EFAULT;
-            }
-            else
-            {
-                vecm_latch_flag |= FLAG_VE_DNLP_DIS;
-                printk(KERN_ERR "[amvecm..] ioctl: disenable dnlp function\n");
-            }
-            break;
-        }
-
-        case AMVECM_IOC_VE_DNLP:
-        {
-            if (vecm_latch_flag & FLAG_VE_DNLP)
-            {
-                ret = -EFAULT;
-            }
-            else if (copy_from_user(&am_ve_dnlp, (void __user *)arg, sizeof(struct ve_dnlp_s)))
-            {
-                ret = -EFAULT;
-            }
-            else
-            {
-                if (am_ve_dnlp.en    >  1)
-                    am_ve_dnlp.en    =  1;
-                if (am_ve_dnlp.black > 16)
-                    am_ve_dnlp.black = 16;
-                if (am_ve_dnlp.white > 16)
-                    am_ve_dnlp.white = 16;
-                vecm_latch_flag |= FLAG_VE_DNLP;
-            }
-            break;
-        }
-
-		case AMVECM_IOC_VE_NEW_DNLP:
-        {
-            if (vecm_latch_flag & FLAG_VE_NEW_DNLP)
-            {
-                ret = -EFAULT;
-            }
-            else if (copy_from_user(&am_ve_new_dnlp, (void __user *)arg, sizeof(struct ve_dnlp_table_s)))
-            {
-                ret = -EFAULT;
-            }
-            else
-            {
-                if (am_ve_new_dnlp.en    >  1)
-                    am_ve_new_dnlp.en    =  1;
-                if (am_ve_new_dnlp.cliprate> 256)
-                    am_ve_new_dnlp.cliprate= 256;
-                if (am_ve_new_dnlp.lowrange> 54)
-                    am_ve_new_dnlp.lowrange= 54;
-                if (am_ve_new_dnlp.hghrange> 54)
-                    am_ve_new_dnlp.hghrange= 54;
-                if (am_ve_new_dnlp.lowalpha> 48)
-                    am_ve_new_dnlp.lowalpha= 48;
-                if (am_ve_new_dnlp.midalpha> 48)
-                    am_ve_new_dnlp.midalpha= 48;
-                if (am_ve_new_dnlp.hghalpha> 48)
-                    am_ve_new_dnlp.hghalpha= 48;
-                vecm_latch_flag |= FLAG_VE_NEW_DNLP;
-            }
-            break;
-        }
-
-        case AMVECM_IOC_G_HIST_AVG: {
-            void __user *argp = (void __user *)arg;
-            if ((video_ve_hist.height == 0) || (video_ve_hist.width == 0))
-            {
-                ret = -EFAULT;
-            }
-            else
-            {
-                video_ve_hist.ave = video_ve_hist.sum/(video_ve_hist.height*video_ve_hist.width);
-                if (copy_to_user(argp, &video_ve_hist, sizeof(struct ve_hist_s)))
-                    ret = -EFAULT;
-            }
-            break;
-        }
-		/**********************************************************************
-		gamma ioctl
-		**********************************************************************/
-		case AMVECM_IOC_GAMMA_TABLE_EN: {
-			vecm_latch_flag |= FLAG_GAMMA_TABLE_EN;
-			break;
-		}
-
-		case AMVECM_IOC_GAMMA_TABLE_DIS: {
-			vecm_latch_flag |= FLAG_GAMMA_TABLE_DIS;
+	int ret = 0;
+	void __user *argp;
+	pr_amvecm_dbg(KERN_INFO "[amvecm..] %s: cmd_nr = 0x%x\n",__func__,_IOC_NR(cmd));
+
+	switch (cmd){
+	case AMVECM_IOC_LOAD_REG:
+	    if (pq_load_en == 0) {
+		    ret = -EBUSY;
+		    pr_amvecm_dbg(KERN_ERR "[amvecm..] pq ioctl function disabled !!\n");
+		    return ret;
+	    }
+		if ((vecm_latch_flag & FLAG_REG_MAP0) &&(vecm_latch_flag & FLAG_REG_MAP1) &&
+		(vecm_latch_flag & FLAG_REG_MAP2) &&(vecm_latch_flag & FLAG_REG_MAP3) &&
+		(vecm_latch_flag & FLAG_REG_MAP4) &&(vecm_latch_flag & FLAG_REG_MAP5)) {
+			ret = -EBUSY;
+			pr_amvecm_dbg(KERN_ERR "[amvecm..] load regs error: loading regs, please wait\n");
 			break;
 		}
-
-		case AMVECM_IOC_GAMMA_TABLE_R: {
-			if (vecm_latch_flag & FLAG_GAMMA_TABLE_R)
-			{
-				ret = -EFAULT;
-			}
-			else if (copy_from_user(&video_gamma_table_r, (void __user *)arg, sizeof(struct tcon_gamma_table_s)))
-			{
-				ret = -EFAULT;
-			}
-			else
-			{
-				vecm_latch_flag |= FLAG_GAMMA_TABLE_R;
-			}
-			break;
-		}
-
-		case AMVECM_IOC_GAMMA_TABLE_G: {
-			if (vecm_latch_flag & FLAG_GAMMA_TABLE_G)
-			{
-				ret = -EFAULT;
-			}
-			else if (copy_from_user(&video_gamma_table_g, (void __user *)arg, sizeof(struct tcon_gamma_table_s)))
-			{
-				ret = -EFAULT;
-			}
-			else
-			{
-				vecm_latch_flag |= FLAG_GAMMA_TABLE_G;
-			}
-			break;
-		}
-
-		case AMVECM_IOC_GAMMA_TABLE_B: {
-			if (vecm_latch_flag & FLAG_GAMMA_TABLE_B)
-			{
-				ret = -EFAULT;
-			}
-			else if (copy_from_user(&video_gamma_table_b, (void __user *)arg, sizeof(struct tcon_gamma_table_s)))
-			{
-				ret = -EFAULT;
-			}
-			else
-			{
-				vecm_latch_flag |= FLAG_GAMMA_TABLE_B;
-			}
-			break;
+		if(copy_from_user(&amregs_ext, (void __user *)arg, sizeof(struct am_regs_s))) {
+			pr_amvecm_dbg(KERN_ERR "[amcm..]0x%x load reg errors: can't get buffer lenght\n",FLAG_REG_MAP0);
+			ret = 0;
 		}
-
-		case AMVECM_IOC_S_RGB_OGO: {
-			if (vecm_latch_flag & FLAG_RGB_OGO)
-			{
-				ret = -EFAULT;
-			}
-			else if (copy_from_user(&video_rgb_ogo, (void __user *)arg, sizeof(struct tcon_rgb_ogo_s)))
-			{
+		ret = cm_load_reg(&amregs_ext);
+		break;
+	case AMVECM_IOC_VE_DNLP_EN:
+		vecm_latch_flag |= FLAG_VE_DNLP_EN;
+		break;
+	case AMVECM_IOC_VE_DNLP_DIS:
+		vecm_latch_flag |= FLAG_VE_DNLP_DIS;
+		break;
+	case AMVECM_IOC_VE_DNLP:
+		if (copy_from_user(&am_ve_dnlp, (void __user *)arg, sizeof(struct ve_dnlp_s)))
+			ret = -EFAULT;
+		else
+			ve_dnlp_param_update();
+		break;
+	case AMVECM_IOC_VE_NEW_DNLP:
+		if (copy_from_user(&am_ve_new_dnlp, (void __user *)arg, sizeof(struct ve_dnlp_table_s)))
+			ret = -EFAULT;
+		else
+			ve_new_dnlp_param_update();
+		break;
+	case AMVECM_IOC_G_HIST_AVG:
+		argp = (void __user *)arg;
+		if ((video_ve_hist.height == 0) || (video_ve_hist.width == 0)){
+			ret = -EFAULT;
+		}else{
+			video_ve_hist.ave = video_ve_hist.sum/(video_ve_hist.height*video_ve_hist.width);
+			if (copy_to_user(argp, &video_ve_hist, sizeof(struct ve_hist_s)))
 				ret = -EFAULT;
-			}
-			else
-			{
-				// en
-				if (video_rgb_ogo.en > 1)
-					video_rgb_ogo.en = 1;
-				// r_pre_offset
-				if (video_rgb_ogo.r_pre_offset > 1023)
-					video_rgb_ogo.r_pre_offset = 1023;
-				if (video_rgb_ogo.r_pre_offset < -1024)
-					video_rgb_ogo.r_pre_offset = -1024;
-				// g_pre_offset
-				if (video_rgb_ogo.g_pre_offset > 1023)
-					video_rgb_ogo.g_pre_offset = 1023;
-				if (video_rgb_ogo.g_pre_offset < -1024)
-					video_rgb_ogo.g_pre_offset = -1024;
-				// b_pre_offset
-				if (video_rgb_ogo.b_pre_offset > 1023)
-					video_rgb_ogo.b_pre_offset = 1023;
-				if (video_rgb_ogo.b_pre_offset < -1024)
-					video_rgb_ogo.b_pre_offset = -1024;
-				// r_gain
-				if (video_rgb_ogo.r_gain > 2047)
-					video_rgb_ogo.r_gain = 2047;
-				// g_gain
-				if (video_rgb_ogo.g_gain > 2047)
-					video_rgb_ogo.g_gain = 2047;
-				// b_gain
-				if (video_rgb_ogo.b_gain > 2047)
-					video_rgb_ogo.b_gain = 2047;
-				// r_post_offset
-				if (video_rgb_ogo.r_post_offset > 1023)
-					video_rgb_ogo.r_post_offset = 1023;
-				if (video_rgb_ogo.r_post_offset < -1024)
-					video_rgb_ogo.r_post_offset = -1024;
-				// g_post_offset
-				if (video_rgb_ogo.g_post_offset > 1023)
-					video_rgb_ogo.g_post_offset = 1023;
-				if (video_rgb_ogo.g_post_offset < -1024)
-					video_rgb_ogo.g_post_offset = -1024;
-				// b_post_offset
-				if (video_rgb_ogo.b_post_offset > 1023)
-					video_rgb_ogo.b_post_offset = 1023;
-				if (video_rgb_ogo.b_post_offset < -1024)
-					video_rgb_ogo.b_post_offset = -1024;
-				if (video_rgb_ogo_mode_sw)
-					video_set_rgb_ogo();
-				vecm_latch_flag |= FLAG_RGB_OGO;
-			}
-			break;
 		}
-
-		case AMVECM_IOC_G_RGB_OGO: {
-			if (copy_to_user((void __user *)arg, &video_rgb_ogo, sizeof(struct tcon_rgb_ogo_s)))
-			{
-				ret = -EFAULT;
-				break;
-			}
-			break;
+		break;
+	/**********************************************************************
+	gamma ioctl
+	**********************************************************************/
+	case AMVECM_IOC_GAMMA_TABLE_EN:
+		if (!wb_gamma_en)
+			return (-EINVAL);
+
+		vecm_latch_flag |= FLAG_GAMMA_TABLE_EN;
+		break;
+	case AMVECM_IOC_GAMMA_TABLE_DIS:
+		vecm_latch_flag |= FLAG_GAMMA_TABLE_DIS;
+		break;
+	case AMVECM_IOC_GAMMA_TABLE_R:
+		if (!wb_gamma_en)
+			return (-EINVAL);
+
+		if (copy_from_user(&video_gamma_table_r, (void __user *)arg, sizeof(struct tcon_gamma_table_s)))
+			ret = -EFAULT;
+		else
+			vecm_latch_flag |= FLAG_GAMMA_TABLE_R;
+		break;
+	case AMVECM_IOC_GAMMA_TABLE_G:
+		if (!wb_gamma_en)
+			return (-EINVAL);
+
+		if (copy_from_user(&video_gamma_table_g, (void __user *)arg, sizeof(struct tcon_gamma_table_s)))
+			ret = -EFAULT;
+		else
+			vecm_latch_flag |= FLAG_GAMMA_TABLE_G;
+		break;
+	case AMVECM_IOC_GAMMA_TABLE_B:
+		if (!wb_gamma_en)
+			return (-EINVAL);
+
+		if (copy_from_user(&video_gamma_table_b, (void __user *)arg, sizeof(struct tcon_gamma_table_s)))
+			ret = -EFAULT;
+		else
+			vecm_latch_flag |= FLAG_GAMMA_TABLE_B;
+		break;
+	case AMVECM_IOC_S_RGB_OGO:
+		if (!wb_gamma_en)
+			return (-EINVAL);
+
+		if (copy_from_user(&video_rgb_ogo, (void __user *)arg, sizeof(struct tcon_rgb_ogo_s)))
+			ret = -EFAULT;
+		else
+			ve_ogo_param_update();
+		break;
+	case AMVECM_IOC_G_RGB_OGO:
+		if (!wb_gamma_en)
+			return (-EINVAL);
+
+		if (copy_to_user((void __user *)arg, &video_rgb_ogo, sizeof(struct tcon_rgb_ogo_s))){
+			ret = -EFAULT;
 		}
-
-       default:
-            return -EINVAL;
-    }
-    return ret;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
 }
 
 static ssize_t amvecm_dnlp_show(struct class *cla, struct class_attribute *attr, char *buf)
 {
-    return sprintf(buf, "0x%x\n", (am_ve_dnlp.en    << 28) |
-                                  (am_ve_dnlp.rt    << 24) |
-                                  (am_ve_dnlp.rl    << 16) |
-                                  (am_ve_dnlp.black <<  8) |
-                                  (am_ve_dnlp.white <<  0));
+	return sprintf(buf, "0x%x\n", (am_ve_dnlp.en    << 28) |(am_ve_dnlp.rt    << 24) |
+					(am_ve_dnlp.rl    << 16) |(am_ve_dnlp.black <<  8) |
+					(am_ve_dnlp.white <<  0));
 }
 // [   28] en    0~1
 // [27:20] rt    0~16
 // [19:16] rl-1  0~15
 // [15: 8] black 0~16
 // [ 7: 0] white 0~16
-static ssize_t amvecm_dnlp_store(struct class *cla, struct class_attribute *attr, const char *buf,
-                                      size_t count)
-{
-    size_t r;
-    s32 val;
-
-    r = sscanf(buf, "0x%x", &val);
-
-    if ((r != 1) || (vecm_latch_flag & FLAG_VE_DNLP)){
-        return -EINVAL;
-    }
-
-    am_ve_dnlp.en    = (val & 0xf0000000) >> 28;
-    am_ve_dnlp.rt    =  (val & 0x0f000000) >> 24;
-    am_ve_dnlp.rl    = (val & 0x00ff0000) >> 16;
-    am_ve_dnlp.black =  (val & 0x0000ff00) >>  8;
-    am_ve_dnlp.white = (val & 0x000000ff) >>  0;
-
-    if (am_ve_dnlp.en    >  1)
-        am_ve_dnlp.en    =  1;
-    if (am_ve_dnlp.rl    > 64)
-        am_ve_dnlp.rl    = 64;
-    if (am_ve_dnlp.black > 16)
-        am_ve_dnlp.black = 16;
-    if (am_ve_dnlp.white > 16)
-        am_ve_dnlp.white = 16;
-
-    vecm_latch_flag |= FLAG_VE_DNLP;
-
-    return count;
+static ssize_t amvecm_dnlp_store(struct class *cla, struct class_attribute *attr, const char *buf,size_t count)
+{
+	size_t r;
+	s32 val;
+	r = sscanf(buf, "0x%x", &val);
+	if((r != 1) || (vecm_latch_flag & FLAG_VE_DNLP))
+		return -EINVAL;
+	am_ve_dnlp.en    = (val & 0xf0000000) >> 28;
+	am_ve_dnlp.rt    =  (val & 0x0f000000) >> 24;
+	am_ve_dnlp.rl    = (val & 0x00ff0000) >> 16;
+	am_ve_dnlp.black =  (val & 0x0000ff00) >>  8;
+	am_ve_dnlp.white = (val & 0x000000ff) >>  0;
+	if (am_ve_dnlp.en >  1) am_ve_dnlp.en    =  1;
+	if (am_ve_dnlp.rl > 64) am_ve_dnlp.rl    = 64;
+	if (am_ve_dnlp.black > 16) am_ve_dnlp.black = 16;
+	if (am_ve_dnlp.white > 16) am_ve_dnlp.white = 16;
+	vecm_latch_flag |= FLAG_VE_DNLP;
+	return count;
 }
 
 static ssize_t amvecm_brightness_show(struct class *cla, struct class_attribute *attr, char *buf)
 {
-    return sprintf(buf, "%d\n", vd1_brightness);
+	return sprintf(buf, "%d\n", vd1_brightness);
 }
 
-static ssize_t amvecm_brightness_store(struct class *cla, struct class_attribute *attr, const char *buf,
-                                      size_t count)
+static ssize_t amvecm_brightness_store(struct class *cla, struct class_attribute *attr, const char *buf,size_t count)
 {
-    size_t r;
-    int val;
-
-    r = sscanf(buf, "%d", &val);
-    if ((r != 1) || (val < -1024) || (val > 1024)) {
-        return -EINVAL;
-    }
-
-    vd1_brightness = val;
-    vecm_latch_flag |= FLAG_BRI_CON;
-
-    return count;
+	size_t r;
+	int val;
+	r = sscanf(buf, "%d", &val);
+	if ((r != 1) || (val < -1024) || (val > 1024)) {
+		return -EINVAL;
+	}
+	vd1_brightness = val;
+	vecm_latch_flag |= FLAG_BRI_CON;
+	return count;
 }
 
 static ssize_t amvecm_contrast_show(struct class *cla, struct class_attribute *attr, char *buf)
 {
-    return sprintf(buf, "%d\n", vd1_contrast);
+	return sprintf(buf, "%d\n", vd1_contrast);
 }
 
-static ssize_t amvecm_contrast_store(struct class *cla, struct class_attribute *attr, const char *buf,
-                                    size_t count)
+static ssize_t amvecm_contrast_store(struct class *cla, struct class_attribute *attr, const char *buf,size_t count)
 {
-    size_t r;
-    int val;
-
-    r = sscanf(buf, "%d", &val);
-    if ((r != 1) || (val < -1024) || (val > 1024)) {
-        return -EINVAL;
-    }
-
-    vd1_contrast = val;
-    vecm_latch_flag |= FLAG_BRI_CON;
-
-    return count;
+	size_t r;
+	int val;
+	r = sscanf(buf, "%d", &val);
+	if ((r != 1) || (val < -1024) || (val > 1024)) {
+		return -EINVAL;
+	}
+	vd1_contrast = val;
+	vecm_latch_flag |= FLAG_BRI_CON;
+	return count;
 }
-static int hue_pre = 0;  /*-25~25*/
-static int saturation_pre = 0;  /*-128~127*/
-static int hue_post = 0;  /*-25~25*/
-static int saturation_post = 0;  /*-128~127*/
+
 static ssize_t amvecm_saturation_hue_show(struct class *cla, struct class_attribute *attr, char *buf)
 {
-    return sprintf(buf, "0x%x\n", READ_MPEG_REG(VPP_VADJ1_MA_MB));
+	return sprintf(buf, "0x%x\n", READ_CBUS_REG(VPP_VADJ1_MA_MB));
 }
 
-static ssize_t amvecm_saturation_hue_store(struct class *cla, struct class_attribute *attr, const char *buf,
-                                      size_t count)
+static ssize_t amvecm_saturation_hue_store(struct class *cla, struct class_attribute *attr, const char *buf,size_t count)
 {
-    size_t r;
-    s32 mab = 0;
-    s16 mc = 0, md = 0;
-
-    r = sscanf(buf, "0x%x", &mab);
-    if ((r != 1) || (mab&0xfc00fc00)) {
-        return -EINVAL;
-    }
-
-    WRITE_MPEG_REG(VPP_VADJ1_MA_MB, mab);
-    mc = (s16)((mab<<22)>>22); // mc = -mb
-    mc = 0 - mc;
-    if (mc> 511)
-        mc= 511;
-    if (mc<-512)
-        mc=-512;
-    md = (s16)((mab<<6)>>22);  // md =  ma;
-    mab = ((mc&0x3ff)<<16)|(md&0x3ff);
-    WRITE_MPEG_REG(VPP_VADJ1_MC_MD, mab);
-    WRITE_MPEG_REG(VPP_VADJ_CTRL, 1);
-#ifdef PQ_DEBUG_EN
-    printk("\n[amvideo..] set video_saturation_hue OK!!!\n");
-#endif
-    return count;
+	size_t r;
+	s32 mab = 0;
+	s16 mc = 0, md = 0;
+	r = sscanf(buf, "0x%x", &mab);
+	if ((r != 1) || (mab&0xfc00fc00)) {
+		return -EINVAL;
+	}
+	WRITE_CBUS_REG(VPP_VADJ1_MA_MB, mab);
+	mc = (s16)((mab<<22)>>22); // mc = -mb
+	mc = 0 - mc;
+	if (mc> 511) mc= 511;
+	if (mc<-512) mc = -512;
+	md = (s16)((mab<<6)>>22);  // md =  ma;
+	mab = ((mc&0x3ff)<<16)|(md&0x3ff);
+	WRITE_CBUS_REG(VPP_VADJ1_MC_MD, mab);
+	WRITE_CBUS_REG_BITS(VPP_VADJ_CTRL, 1, 0, 1);
+	pr_amvecm_dbg(KERN_INFO "%s set video_saturation_hue OK!!!\n", __func__);
+	return count;
 }
-#include <linux/ctype.h>
-
 
 static int parse_para_pq(const char *para, int para_num, int *result)
 {
-    char *endp;
-    const char *startp = para;
-    int *out = result;
-    int len = 0, count = 0;
-
-    if (!startp) {
-        return 0;
-    }
-
-    len = strlen(startp);
-
-    do {
-        //filter space out
-        while (startp && (isspace(*startp) || !isgraph(*startp)) && len) {
-            startp++;
-            len--;
-        }
-
-        if (len == 0) {
-            break;
-        }
-
-        *out++ = simple_strtol(startp, &endp, 0);
-
-        len -= endp - startp;
-        startp = endp;
-        count++;
-
-    } while ((endp) && (count < para_num) && (len > 0));
-
-    return count;
+	char *endp;
+	const char *startp = para;
+	int *out = result;
+	int len = 0, count = 0;
+	if (!startp) {
+		return 0;
+	}
+	len = strlen(startp);
+	do {
+		//filter space out
+		while (startp && (isspace(*startp) || !isgraph(*startp)) && len) {
+			startp++;
+			len--;
+		}
+		if (len == 0) {
+			break;
+		}
+		*out++ = simple_strtol(startp, &endp, 0);
+		len -= endp - startp;
+		startp = endp;
+		count++;
+	} while ((endp) && (count < para_num) && (len > 0));
+	return count;
 }
 
 static ssize_t amvecm_saturation_hue_pre_show(struct class *cla, struct class_attribute *attr, char *buf)
 {
-    return snprintf(buf, 20, "%d %d\n", saturation_pre, hue_pre);
+	return snprintf(buf, 20, "%d %d\n", saturation_pre, hue_pre);
 }
 
-static ssize_t amvecm_saturation_hue_pre_store(struct class *cla, struct class_attribute *attr, const char *buf,
-                                      size_t count)
+static ssize_t amvecm_saturation_hue_pre_store(struct class *cla, struct class_attribute *attr, const char *buf,size_t count)
 {
-    int parsed[2];
-    int i, ma, mb, mab, mc, md;
+	int parsed[2];
+	int i, ma, mb, mab, mc, md;
 	int hue_cos[] = {
-    256, 256, 256, 255, 255, 254, 253, 252, 251, 250, 248, 247, 245, /*0~12*/
-    243, 241, 239, 237, 234, 231, 229, 226, 223, 220, 216, 213, 209  /*13~25*/
-    };
-    int hue_sin[] = {
-    -147, -142, -137, -132, -126, -121, -115, -109, -104, -98, -92, -86, -80, /*-25~-13*/
-     -74,  -68,  -62,  -56,  -50,  -44,  -38,  -31,  -25, -19, -13,  -6,      /*-12~-1*/
-       0,								      /*0*/
-       6,   13,   19,	25,   31,   38,   44,	50,   56,  62,	68,  74,      /*1~12*/
-      80,   86,   92,	98,  104,  109,  115,  121,  126,  132, 137, 142, 147 /*13~25*/
-    };
-
-    if (likely(parse_para_pq(buf, 2, parsed) != 2)) {
-	return -EINVAL;
-    }
-
-    if ((parsed[0] < -128) || (parsed[0] > 128) || (parsed[1] < -25) || (parsed[1] > 25)) {
-	return -EINVAL;
-    }
-    saturation_pre = parsed[0];
-    hue_pre = parsed[1];
-
-    i = (hue_pre > 0) ? hue_pre: -hue_pre;
-    ma = (hue_cos[i]*(saturation_pre + 128)) >> 7;
-    mb = (hue_sin[25+hue_pre]*(saturation_pre + 128)) >> 7;
-
-    if	(ma > 511) ma = 511;
-    if (ma < -512) ma = -512;
+		256, 256, 256, 255, 255, 254, 253, 252, 251, 250, 248, 247, 245, /*0~12*/
+		243, 241, 239, 237, 234, 231, 229, 226, 223, 220, 216, 213, 209  /*13~25*/
+	};
+	int hue_sin[] = {
+		-147, -142, -137, -132, -126, -121, -115, -109, -104, -98, -92, -86, -80, /*-25~-13*/
+		-74,  -68,  -62,  -56,  -50,  -44,  -38,  -31,  -25, -19, -13,  -6,      /*-12~-1*/
+		0,								      /*0*/
+		6,   13,   19,	25,   31,   38,   44,	50,   56,  62,	68,  74,      /*1~12*/
+		80,   86,   92,	98,  104,  109,  115,  121,  126,  132, 137, 142, 147 /*13~25*/
+	};
+	if (likely(parse_para_pq(buf, 2, parsed) != 2)) {
+		return -EINVAL;
+	}
+	if ((parsed[0] < -128) || (parsed[0] > 128) || (parsed[1] < -25) || (parsed[1] > 25)) {
+		return -EINVAL;
+	}
+	saturation_pre = parsed[0];
+	hue_pre = parsed[1];
+	i = (hue_pre > 0) ? hue_pre: -hue_pre;
+	ma = (hue_cos[i]*(saturation_pre + 128)) >> 7;
+	mb = (hue_sin[25+hue_pre]*(saturation_pre + 128)) >> 7;
+	if (ma > 511) ma = 511;
+	if (ma < -512) ma = -512;
 	if (mb > 511)  mb = 511;
 	if (mb < -512) mb = -512;
 	mab =  ((ma & 0x3ff) << 16) | (mb & 0x3ff);
-
-    printk("\n[amvideo..] saturation_pre:%d hue_pre:%d mab:%x\n", saturation_pre,hue_pre,mab);
-
-    WRITE_MPEG_REG(VPP_VADJ2_MA_MB, mab);
-    mc = (s16)((mab<<22)>>22); // mc = -mb
-    mc = 0 - mc;
-    if (mc > 511)  mc = 511;
-    if (mc < -512) mc = -512;
-    md = (s16)((mab<<6)>>22);  // md =	ma;
-    mab = ((mc&0x3ff)<<16)|(md&0x3ff);
-    WRITE_MPEG_REG(VPP_VADJ1_MC_MD, mab);
-    WRITE_MPEG_REG_BITS(VPP_VADJ_CTRL, 1, 0, 1);
-
-    return count;
+	printk("\n[amvideo..] saturation_pre:%d hue_pre:%d mab:%x\n", saturation_pre,hue_pre,mab);
+	WRITE_CBUS_REG(VPP_VADJ2_MA_MB, mab);
+	mc = (s16)((mab<<22)>>22); // mc = -mb
+	mc = 0 - mc;
+	if (mc > 511)  mc = 511;
+	if (mc < -512) mc = -512;
+	md = (s16)((mab<<6)>>22);  // md =	ma;
+	mab = ((mc&0x3ff)<<16)|(md&0x3ff);
+	WRITE_CBUS_REG(VPP_VADJ1_MC_MD, mab);
+	WRITE_CBUS_REG_BITS(VPP_VADJ_CTRL, 1, 0, 1);
+	return count;
 }
 
 static ssize_t amvecm_saturation_hue_post_show(struct class *cla, struct class_attribute *attr, char *buf)
 {
-    return snprintf(buf, 20, "%d %d\n", saturation_post, hue_post);
+	return snprintf(buf, 20, "%d %d\n", saturation_post, hue_post);
 }
 
-static ssize_t amvecm_saturation_hue_post_store(struct class *cla, struct class_attribute *attr, const char *buf,
-                                      size_t count)
+static ssize_t amvecm_saturation_hue_post_store(struct class *cla, struct class_attribute *attr, const char *buf,size_t count)
 {
-    int parsed[2];
-    int i, ma, mb, mab, mc, md;
+	int parsed[2];
+	int i, ma, mb, mab, mc, md;
 	int hue_cos[] = {
-    256, 256, 256, 255, 255, 254, 253, 252, 251, 250, 248, 247, 245, /*0~12*/
-    243, 241, 239, 237, 234, 231, 229, 226, 223, 220, 216, 213, 209  /*13~25*/
-    };
-    int hue_sin[] = {
-    -147, -142, -137, -132, -126, -121, -115, -109, -104, -98, -92, -86, -80, /*-25~-13*/
-     -74,  -68,  -62,  -56,  -50,  -44,  -38,  -31,  -25, -19, -13,  -6,      /*-12~-1*/
-       0,								      /*0*/
-       6,   13,   19,	25,   31,   38,   44,	50,   56,  62,	68,  74,      /*1~12*/
-      80,   86,   92,	98,  104,  109,  115,  121,  126,  132, 137, 142, 147 /*13~25*/
-    };
-
-    if (likely(parse_para_pq(buf, 2, parsed) != 2)) {
-	return -EINVAL;
-    }
-
-    if ((parsed[0] < -128) || (parsed[0] > 128) || (parsed[1] < -25) || (parsed[1] > 25)) {
-	return -EINVAL;
-    }
-    saturation_post = parsed[0];
-    hue_post = parsed[1];
-
-    i = (hue_post > 0) ? hue_post: -hue_post;
-    ma = (hue_cos[i]*(saturation_post + 128)) >> 7;
-    mb = (hue_sin[25+hue_post]*(saturation_post + 128)) >> 7;
-
-    if	(ma > 511) ma = 511;
-    if (ma < -512) ma = -512;
+		256, 256, 256, 255, 255, 254, 253, 252, 251, 250, 248, 247, 245, /*0~12*/
+		243, 241, 239, 237, 234, 231, 229, 226, 223, 220, 216, 213, 209  /*13~25*/
+	};
+	int hue_sin[] = {
+		-147, -142, -137, -132, -126, -121, -115, -109, -104, -98, -92, -86, -80, /*-25~-13*/
+		-74,  -68,  -62,  -56,  -50,  -44,  -38,  -31,  -25, -19, -13,  -6,      /*-12~-1*/
+		0,								      /*0*/
+		6,   13,   19,	25,   31,   38,   44,	50,   56,  62,	68,  74,      /*1~12*/
+		80,   86,   92,	98,  104,  109,  115,  121,  126,  132, 137, 142, 147 /*13~25*/
+	};
+	if (likely(parse_para_pq(buf, 2, parsed) != 2)) {
+		return -EINVAL;
+	}
+	if ((parsed[0] < -128) || (parsed[0] > 128) || (parsed[1] < -25) || (parsed[1] > 25)) {
+		return -EINVAL;
+	}
+	saturation_post = parsed[0];
+	hue_post = parsed[1];
+	i = (hue_post > 0) ? hue_post: -hue_post;
+	ma = (hue_cos[i]*(saturation_post + 128)) >> 7;
+	mb = (hue_sin[25+hue_post]*(saturation_post + 128)) >> 7;
+	if (ma > 511) ma = 511;
+	if (ma < -512) ma = -512;
 	if (mb > 511)  mb = 511;
 	if (mb < -512) mb = -512;
 	mab =  ((ma & 0x3ff) << 16) | (mb & 0x3ff);
+	printk("\n[amvideo..] saturation_post:%d hue_post:%d mab:%x\n", saturation_post,hue_post,mab);
+	WRITE_CBUS_REG(VPP_VADJ2_MA_MB, mab);
+	mc = (s16)((mab<<22)>>22); // mc = -mb
+	mc = 0 - mc;
+	if (mc > 511)  mc = 511;
+	if (mc < -512) mc = -512;
+	md = (s16)((mab<<6)>>22);  // md =	ma;
+	mab = ((mc&0x3ff)<<16)|(md&0x3ff);
+	WRITE_CBUS_REG(VPP_VADJ2_MC_MD, mab);
+	WRITE_CBUS_REG_BITS(VPP_VADJ_CTRL, 1, 2, 1);
+	return count;
+}
+
+static ssize_t amvecm_cm2_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+	pr_info("Usage:");
+	pr_info("	echo wm addr data0 data1 data2 data3 data4 > /sys/class/amvecm/cm2 \n");
+	pr_info("	echo rm addr > /sys/class/amvecm/cm2 \n");
+	return 0;
+}
 
-printk("\n[amvideo..] saturation_post:%d hue_post:%d mab:%x\n", saturation_post,hue_post,mab);
+static ssize_t amvecm_cm2_store(struct class *cls,
+		 struct class_attribute *attr,
+		 const char *buffer, size_t count)
+{
+	int n = 0;
+	char *buf_orig, *ps, *token;
+	char *parm[7];
+	u32 addr;
+	int data[5] = {0};
+	unsigned int addr_port = VPP_CHROMA_ADDR_PORT;//0x1d70;
+	unsigned int data_port = VPP_CHROMA_DATA_PORT;//0x1d71;
+
+	buf_orig = kstrdup(buffer, GFP_KERNEL);
+	ps = buf_orig;
+	while (1) {
+		token = strsep(&ps, " \n");
+		if (token == NULL)
+			break;
+		if (*token == '\0')
+			continue;
+		parm[n++] = token;
+	}
+
+	if ((parm[0][0] == 'w') && parm[0][1] == 'm' ) {
+		if (n != 7) {
+			pr_info("read: invalid parameter\n");
+			pr_info("please: cat /sys/class/amvecm/cm2 \n");
+			kfree(buf_orig);
+			return count;
+		}
+		addr = simple_strtol(parm[1], NULL, 16);
+		addr = addr - addr%8;
+		data[0] = simple_strtol(parm[2], NULL, 16);
+		data[1] = simple_strtol(parm[3], NULL, 16);
+		data[2] = simple_strtol(parm[4], NULL, 16);
+		data[3] = simple_strtol(parm[5], NULL, 16);
+		data[4] = simple_strtol(parm[6], NULL, 16);
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV)
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr);
+		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[0]);
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr + 1);
+		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[1]);
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr + 2);
+		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[2]);
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr + 3);
+		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[3]);
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr + 4);
+		aml_write_reg32(VCBUS_REG_ADDR(data_port), data[4]);
+#else
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr);
+		aml_write_reg32(CBUS_REG_ADDR(data_port), data[0]);
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr + 1);
+		aml_write_reg32(CBUS_REG_ADDR(data_port), data[1]);
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr + 2);
+		aml_write_reg32(CBUS_REG_ADDR(data_port), data[2]);
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr + 3);
+		aml_write_reg32(CBUS_REG_ADDR(data_port), data[3]);
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr + 4);
+		aml_write_reg32(CBUS_REG_ADDR(data_port), data[4]);
+#endif
+		pr_info("wm: [0x%x] <-- 0x0 \n",addr);
+	}
+	else if ((parm[0][0] == 'r') && parm[0][1] == 'm' ) {
+		if (n != 2) {
+			pr_info("read: invalid parameter\n");
+			pr_info("please: cat /sys/class/amvecm/cm2 \n");
+			kfree(buf_orig);
+			return count;
+		}
+		addr = simple_strtol(parm[1], NULL, 16);
+		addr = addr - addr%8;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV)
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr);
+		data[0] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[0] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[0] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr+1);
+		data[1] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[1] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[1] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr+2);
+		data[2] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[2] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[2] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr+3);
+		data[3] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[3] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[3] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		aml_write_reg32(VCBUS_REG_ADDR(addr_port), addr+4);
+		data[4] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[4] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+		data[4] = aml_read_reg32(VCBUS_REG_ADDR(data_port));
+#else
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr);
+		data[0] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[0] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[0] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr+1);
+		data[1] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[1] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[1] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr+2);
+		data[2] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[2] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[2] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr+3);
+		data[3] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[3] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[3] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		aml_write_reg32(CBUS_REG_ADDR(addr_port), addr+4);
+		data[4] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[4] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+		data[4] = aml_read_reg32(CBUS_REG_ADDR(data_port));
+#endif
+		pr_info("rm:[0x%x]-->[0x%x][0x%x][0x%x][0x%x][0x%x] \n",addr, data[0],data[1],data[2],data[3],data[4]);
+	} else {
+		pr_info("invalid command\n");
+		pr_info("please: cat /sys/class/amvecm/bit");
+	}
+	kfree(buf_orig);
+	return count;
+}
 
-    WRITE_MPEG_REG(VPP_VADJ2_MA_MB, mab);
-    mc = (s16)((mab<<22)>>22); // mc = -mb
-    mc = 0 - mc;
-    if (mc > 511)  mc = 511;
-    if (mc < -512) mc = -512;
-    md = (s16)((mab<<6)>>22);  // md =	ma;
-    mab = ((mc&0x3ff)<<16)|(md&0x3ff);
-    WRITE_MPEG_REG(VPP_VADJ2_MC_MD, mab);
-    WRITE_MPEG_REG_BITS(VPP_VADJ_CTRL, 1, 2, 1);
 
-    return count;
+static ssize_t amvecm_gamma_show(struct class *cls,
+			struct class_attribute *attr,
+			char *buf)
+{
+	pr_info("Usage:");
+	pr_info("	echo sgr|sgg|sgb xxx...xx > /sys/class/amvecm/gamma\n");
+	pr_info("Notes:");
+	pr_info("	if the string xxx......xx is less than 256*3,");
+	pr_info("	then the remaining will be set value 0\n");
+	pr_info("	if the string xxx......xx is more than 256*3, ");
+	pr_info("	then the remaining will be ignored\n");
+	return 0;
 }
 
+static ssize_t amvecm_gamma_store(struct class *cls,
+			 struct class_attribute *attr,
+			 const char *buffer, size_t count)
+{
+
+	int n = 0;
+	char *buf_orig, *ps, *token;
+	char *parm[4];
+	unsigned short *gammaR, *gammaG, *gammaB;
+	unsigned int gamma_count;
+	char gamma[4];
+	int i = 0;
+
+	/* to avoid the bellow warning message while compiling:
+	 * warning: the frame size of 1576 bytes is larger than 1024 bytes
+	 */
+	gammaR = kmalloc(256 * sizeof(unsigned short), GFP_KERNEL);
+	gammaG = kmalloc(256 * sizeof(unsigned short), GFP_KERNEL);
+	gammaB = kmalloc(256 * sizeof(unsigned short), GFP_KERNEL);
+
+	buf_orig = kstrdup(buffer, GFP_KERNEL);
+	ps = buf_orig;
+	while (1) {
+		token = strsep(&ps, " \n");
+		if (token == NULL)
+			break;
+		if (*token == '\0')
+			continue;
+		parm[n++] = token;
+	}
+
+	if ((parm[0][0] == 's') && (parm[0][1] == 'g')) {
+		memset(gammaR, 0, 256 * sizeof(unsigned short));
+		gamma_count = (strlen(parm[1]) + 2) / 3;
+		if (gamma_count > 256)
+			gamma_count = 256;
+
+		for (i = 0; i < gamma_count; ++i) {
+			gamma[0] = parm[1][3 * i + 0];
+			gamma[1] = parm[1][3 * i + 1];
+			gamma[2] = parm[1][3 * i + 2];
+			gamma[3] = '\0';
+			gammaR[i] = simple_strtol(gamma, NULL, 16);
+		}
+
+		switch (parm[0][2]) {
+		case 'r':
+			vpp_set_lcd_gamma_table(gammaR, H_SEL_R);
+			break;
+
+		case 'g':
+			vpp_set_lcd_gamma_table(gammaR, H_SEL_G);
+			break;
+
+		case 'b':
+			vpp_set_lcd_gamma_table(gammaR, H_SEL_B);
+			break;
+		default:
+			break;
+		}
+	} else {
+		pr_info("invalid command\n");
+		pr_info("please: cat /sys/class/amvecm/gamma");
+
+	}
+	kfree(buf_orig);
+	kfree(gammaR);
+	kfree(gammaG);
+	kfree(gammaB);
+	return count;
+}
+void init_sharpness(void)
+{
+	WRITE_CBUS_REG(VPP_VE_ENABLE_CTRL, 0x2);
+	WRITE_CBUS_REG(NR_GAUSSIAN_MODE, 0x0);
+	WRITE_CBUS_REG(PK_HVCON_LPF_MODE, 0x11111111);
+	WRITE_CBUS_REG(PK_CON_2CIRHPGAIN_LIMIT, 0x05600500);
+	WRITE_CBUS_REG(PK_CON_2CIRBPGAIN_LIMIT, 0x05280500);
+	WRITE_CBUS_REG(PK_CON_2DRTHPGAIN_LIMIT, 0x05600500);
+	WRITE_CBUS_REG(PK_CON_2DRTBPGAIN_LIMIT, 0x05280500);
+
+	WRITE_CBUS_REG(PK_CIRFB_BLEND_GAIN, 0x8f808f80);
+	WRITE_CBUS_REG(NR_ALP0_MIN_MAX, 0x003f003f);
+	WRITE_CBUS_REG(PK_ALP2_MIERR_CORING, 0x00010101);
+	WRITE_CBUS_REG(PK_ALP2_ERR2CURV_TH_RATE, 0x50504010);
+	WRITE_CBUS_REG(PK_FINALGAIN_HP_BP, 0x00002820);
+	WRITE_CBUS_REG(PK_OS_STATIC, 0x22014014);
+	WRITE_CBUS_REG(PK_DRT_SAD_MISC, 0x18180418);
+	WRITE_CBUS_REG(NR_TI_DNLP_BLEND, 0x00000406);
+	WRITE_CBUS_REG(LTI_CTI_DF_GAIN, 0x18181818);
+	WRITE_CBUS_REG(LTI_CTI_DIR_AC_DBG, 0x57ff0000);
+	WRITE_CBUS_REG(HCTI_FLT_CLP_DC, 0x1a555310);
+	WRITE_CBUS_REG(HCTI_BST_CORE, 0x05050503);
+	WRITE_CBUS_REG(HCTI_CON_2_GAIN_0, 0x28193c00);
+	WRITE_CBUS_REG(HLTI_FLT_CLP_DC, 0x19552104);
+	WRITE_CBUS_REG(HLTI_BST_GAIN, 0x20201c0c);
+	WRITE_CBUS_REG(HLTI_CON_2_GAIN_0, 0x24193c5a);
+	WRITE_CBUS_REG(VLTI_FLT_CON_CLP, 0x00006a90);
+	WRITE_CBUS_REG(VLTI_CON_2_GAIN_0, 0x193c0560);
+	WRITE_CBUS_REG(VCTI_FLT_CON_CLP, 0x00006a90);
+	WRITE_CBUS_REG(VCTI_BST_GAIN, 0x00101010);
+	WRITE_CBUS_REG(VCTI_BST_CORE, 0x00050503);
+	WRITE_CBUS_REG(PK_CIRFB_BP_CORING, 0x00043f04);
+	WRITE_CBUS_REG(PK_DRTFB_HP_CORING, 0x00043f04);
+	printk("**********sharpness init ok!*********\n");
+}
 
-//static CLASS_ATTR(dnlp, S_IRUGO | S_IWUSR, amvecm_dnlp_show, amvecm_dnlp_store);
 static struct class_attribute amvecm_class_attrs[] = {
 	__ATTR(dnlp, S_IRUGO | S_IWUSR,
 		amvecm_dnlp_show, amvecm_dnlp_store),
@@ -2201,199 +928,87 @@ static struct class_attribute amvecm_class_attrs[] = {
 	__ATTR(saturation_hue_post,S_IRUGO | S_IWUSR,
 		amvecm_saturation_hue_post_show,
 		amvecm_saturation_hue_post_store),
+	__ATTR(cm2,S_IRUGO | S_IWUSR,
+		amvecm_cm2_show,
+		amvecm_cm2_store),
+	__ATTR(gamma,S_IRUGO | S_IWUSR,
+		amvecm_gamma_show,
+		amvecm_gamma_store),
 	__ATTR_NULL
 };
 
-#if 0
-static int amvecm_probe(struct platform_device *pdev)
-{
-    int ret;
-
-    ret = alloc_chrdev_region(&amvecm_devno, 0, AMVECM_COUNT, AMVECM_NAME);
-	if (ret < 0) {
-		pr_info("[amvecm.] : failed to allocate major number\n");
-		return 0;
-	}
-
-    amvecm_clsp = class_create(THIS_MODULE, AMVECM_NAME);
-    if (IS_ERR(amvecm_clsp))
-    {
-        pr_info(KERN_ERR "[amvecm.] : can't get amvecm_clsp\n");
-        unregister_chrdev_region(amvecm_devno, 0);
-        return PTR_ERR(amvecm_clsp);
-	}
-
-    /* allocate memory for the per-device structure */
-    amvecm_devp = kmalloc(sizeof(struct amvecm_dev_s), GFP_KERNEL);
-    if (!amvecm_devp)
-    {
-        pr_info("[amvecm.] : failed to allocate memory for amvecm device\n");
-        return -ENOMEM;
-    }
-
-    memset(amvecm_devp, 0, sizeof(struct amvecm_dev_s));
-
-    /* connect the file operations with cdev */
-    cdev_init(&amvecm_devp->cdev, &amvecm_fops);
-    amvecm_devp->cdev.owner = THIS_MODULE;
-    ret = cdev_add(&amvecm_devp->cdev, amvecm_devno, 1);
-    if (ret) {
-        pr_err("[amvecm.] : failed to add device\n");
-        /* @todo do with error */
-        return ret;
-    }
-    /* create /dev nodes */
-    //amvecm_devp->devt = MKDEV(MAJOR(amvecm_devno), 0);
-    amvecm_devp->dev = device_create(amvecm_clsp, NULL, MKDEV(MAJOR(amvecm_devno), 0),
-                        NULL, "%s%d", AMVECM_NAME, 0);
-    if (IS_ERR(amvecm_devp->dev)) {
-         pr_info("[amvecm.] : failed to create device node\n");
-         cdev_del(&amvecm_devp->cdev);
-		 kfree(amvecm_devp);
-         return PTR_ERR(amvecm_devp->dev);;
-    }
-
-    device_create_file(amvecm_devp->dev, &dev_attr_dnlp);
-
-    pr_info("[amvecm.] : driver probe ok\n");
-
-    return ret;
-}
-
-static int amvecm_remove(struct platform_device *pdev)
-{
-    int i = 0;
-
-    device_remove_file(amvecm_devp->dev, &dev_attr_dnlp);
-    device_destroy(amvecm_clsp, MKDEV(MAJOR(amvecm_devno), i));
-    cdev_del(&amvecm_devp->cdev);
-    kfree(amvecm_devp);
-    class_destroy(amvecm_clsp);
-    unregister_chrdev_region(amvecm_devno, 0);
-
-    pr_info("[amvecm.] : driver removed ok.\n");
-    return 0;
-}
-
-#ifdef CONFIG_PM
-static int amvecm_suspend(struct platform_device *pdev,pm_message_t state)
-{
-    pr_info("[amvecm.] : suspend module\n");
-    return 0;
-}
-
-static int amvecm_resume(struct platform_device *pdev)
-{
-    pr_info("[amvecm.] : resume module\n");
-    return 0;
-}
-#endif
-
-static struct platform_driver amvecm_driver = {
-    .probe      = amvecm_probe,
-    .remove     = amvecm_remove,
-#ifdef CONFIG_PM
-    .suspend    = amvecm_suspend,
-    .resume     = amvecm_resume,
-#endif
-    .driver     = {
-        .name   = AMVECM_DRIVER_NAME,
-    }
-};
-#endif
 static struct file_operations amvecm_fops = {
-    .owner   = THIS_MODULE,
-    .open    = amvecm_open,
-    .release = amvecm_release,
-    .unlocked_ioctl   = amvecm_ioctl,
+	.owner   = THIS_MODULE,
+	.open    = amvecm_open,
+	.release = amvecm_release,
+	.unlocked_ioctl   = amvecm_ioctl,
 };
 
 static int __init amvecm_init(void)
 {
-    //int ret = 0;
-
-    //ret = platform_driver_register(&amvecm_driver);
-    //if (ret != 0) {
-    //    pr_info("failed to register amvecm module, error %d\n", ret);
-    //    return -ENODEV;
-    //}
-
-    int ret = 0;
+	int ret = 0;
 	int i = 0;
-    struct amvecm_dev_s *devp = &amvecm_dev;
-
-    memset(devp, 0, (sizeof(struct amvecm_dev_s)));
+	struct amvecm_dev_s *devp = &amvecm_dev;
+	memset(devp, 0, (sizeof(struct amvecm_dev_s)));
 	printk("\n\n VECM init \n\n");
-    ret = alloc_chrdev_region(&devp->devno, 0, 1, AMVECM_NAME);
-    if (ret < 0)
-    {
-        goto fail_alloc_region;
-    }
-
-    devp->clsp = class_create(THIS_MODULE, AMVECM_CLASS_NAME);
-    if (IS_ERR(devp->clsp)) {
-        ret = PTR_ERR(devp->clsp);
-        goto fail_create_class;
-    }
-
+	ret = alloc_chrdev_region(&devp->devno, 0, 1, AMVECM_NAME);
+	if (ret < 0){
+		goto fail_alloc_region;
+	}
+	devp->clsp = class_create(THIS_MODULE, AMVECM_CLASS_NAME);
+	if (IS_ERR(devp->clsp)) {
+		ret = PTR_ERR(devp->clsp);
+		goto fail_create_class;
+	}
 	for(i = 0; amvecm_class_attrs[i].attr.name; i++){
-		if(class_create_file(devp->clsp,
-				&amvecm_class_attrs[i]) < 0)
-		goto fail_class_create_file;
+		if(class_create_file(devp->clsp,&amvecm_class_attrs[i]) < 0)
+			goto fail_class_create_file;
 	}
-
-    cdev_init(&devp->cdev, &amvecm_fops);
-    devp->cdev.owner = THIS_MODULE;
-    ret = cdev_add(&devp->cdev, devp->devno, 1);
-    if (ret)
-    {
-        goto fail_add_cdev;
-    }
-
-    devp->dev = device_create(devp->clsp, NULL, devp->devno, NULL, AMVECM_NAME);
-
-    if (IS_ERR(devp->dev)) {
-        ret = PTR_ERR(devp->dev);
-        goto fail_create_device;
-    }
-
-    return 0;
+	cdev_init(&devp->cdev, &amvecm_fops);
+	devp->cdev.owner = THIS_MODULE;
+	ret = cdev_add(&devp->cdev, devp->devno, 1);
+	if (ret){
+		goto fail_add_cdev;
+	}
+	devp->dev = device_create(devp->clsp, NULL, devp->devno, NULL, AMVECM_NAME);
+	if (IS_ERR(devp->dev)) {
+		ret = PTR_ERR(devp->dev);
+		goto fail_create_device;
+	}
+	init_sharpness();
+	return 0;
 
 fail_create_device:
 	pr_info("[amvecm.] : amvecm device create error.\n");
-    cdev_del(&devp->cdev);
-fail_add_cdev:
+	cdev_del(&devp->cdev);
+	fail_add_cdev:
 	pr_info("[amvecm.] : amvecm add device error.\n");
-    kfree(devp);
+	kfree(devp);
 fail_class_create_file:
 	pr_info("[amvecm.] : amvecm class create file error.\n");
 	for(i=0; amvecm_class_attrs[i].attr.name; i++){
 		class_remove_file(devp->clsp,
-				&amvecm_class_attrs[i]);
+		&amvecm_class_attrs[i]);
 	}
-    class_destroy(devp->clsp);
+	class_destroy(devp->clsp);
 fail_create_class:
 	pr_info("[amvecm.] : amvecm class create error.\n");
-    unregister_chrdev_region(devp->devno, 1);
+	unregister_chrdev_region(devp->devno, 1);
 fail_alloc_region:
-    pr_info("[amvecm.] : amvecm alloc error.\n");
-    pr_info("[amvecm.] : amvecm_init.\n");
-    return ret;
+	pr_info("[amvecm.] : amvecm alloc error.\n");
+	pr_info("[amvecm.] : amvecm_init.\n");
+	return ret;
 }
 
 static void __exit amvecm_exit(void)
 {
-    //platform_driver_unregister(&amvecm_driver);
-
-    struct amvecm_dev_s *devp = &amvecm_dev;
-
-    device_destroy(devp->clsp, devp->devno);
-    cdev_del(&devp->cdev);
-    class_destroy(devp->clsp);
-    unregister_chrdev_region(devp->devno, 1);
-    kfree(devp);
-
-    pr_info("[amvecm.] : amvecm_exit.\n");
+	struct amvecm_dev_s *devp = &amvecm_dev;
+	device_destroy(devp->clsp, devp->devno);
+	cdev_del(&devp->cdev);
+	class_destroy(devp->clsp);
+	unregister_chrdev_region(devp->devno, 1);
+	kfree(devp);
+	pr_info("[amvecm.] : amvecm_exit.\n");
 }
 
 module_init(amvecm_init);
diff --git a/drivers/amlogic/amvecm/amvecm_vlock_regmap.h b/drivers/amlogic/amvecm/amvecm_vlock_regmap.h
new file mode 100755
index 000000000000..95c5abba7181
--- /dev/null
+++ b/drivers/amlogic/amvecm/amvecm_vlock_regmap.h
@@ -0,0 +1,76 @@
+/*
+ * Color Management
+ *
+ * Author: dezhi kong <dezhi.kong@amlogic.com>
+ *
+ * Copyright (C) 2014 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __AMVECM_VLOCK_REGMAP_H
+#define __AMVECM_VLOCK_REGMAP_H
+
+#include <linux/amlogic/cm.h>
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV)
+//TV_ENC_LCD720x480
+static am_regs_t vlock_enc={
+	20,
+	{
+/* optimize */
+{REG_TYPE_CBUS,	0x3000,	    0xffffffff,	0xE0f50f1b  },
+{REG_TYPE_CBUS, 0x3001,     0xffffffff, 0x41E3c3c   },
+{REG_TYPE_CBUS, 0x3002,     0xffffffff, 0x6000000   },
+{REG_TYPE_CBUS, 0x3003,     0xffffffff, 0x40280280  },
+{REG_TYPE_CBUS, 0x3004,     0xffffffff, 0x280280    },
+{REG_TYPE_CBUS, 0x3005,     0xffffffff, 0x8020000   },
+{REG_TYPE_CBUS, 0x3006,     0xffffffff, 0x0008000   },
+{REG_TYPE_CBUS, 0x3007,     0xffffffff, 0x6000000   },
+{REG_TYPE_CBUS, 0x3008,     0xffffffff, 0x6000000   },
+{REG_TYPE_CBUS, 0x3009,     0xffffffff, 0x0008000   },
+{REG_TYPE_CBUS, 0x300a,     0xffffffff, 0x8000000   },
+{REG_TYPE_CBUS, 0x300b,     0xffffffff, 0x0008000   },
+{REG_TYPE_CBUS, 0x300c,     0xffffffff, 0xa000000   },
+{REG_TYPE_CBUS, 0x300d,     0xffffffff, 0x0004000   },
+{REG_TYPE_CBUS, 0x3010,     0xffffffff, 0x20001000  },
+{REG_TYPE_CBUS, 0x3016,     0xffffffff, 0x18000     },
+{REG_TYPE_CBUS, 0x3017,     0xffffffff, 0x01080     },
+{REG_TYPE_CBUS, 0x301d,     0xffffffff, 0x30501080  },
+{REG_TYPE_CBUS, 0x301e,     0xffffffff, 0x7	    },
+{REG_TYPE_CBUS, 0x301f,     0xffffffff, 0x6000000   },
+{0}
+	}
+};
+static am_regs_t vlock_pll={
+	20,
+	{
+/* optimize */
+{REG_TYPE_CBUS,	0x3000,	    0xffffffff,	0xE0f50f1b  },
+{REG_TYPE_CBUS, 0x3001,     0xffffffff, 0x4013c3c   },
+{REG_TYPE_CBUS, 0x3002,     0xffffffff, 0x6000000   },
+{REG_TYPE_CBUS, 0x3003,     0xffffffff, 0x40240280  },
+{REG_TYPE_CBUS, 0x3004,     0xffffffff, 0x240280    },
+{REG_TYPE_CBUS, 0x3005,     0xffffffff, 0x8020000   },
+{REG_TYPE_CBUS, 0x3006,     0xffffffff, 0x0100000   },
+{REG_TYPE_CBUS, 0x3007,     0xffffffff, 0x6000000   },
+{REG_TYPE_CBUS, 0x3008,     0xffffffff, 0x6000000   },
+{REG_TYPE_CBUS, 0x3009,     0xffffffff, 0x0100000   },
+{REG_TYPE_CBUS, 0x300a,     0xffffffff, 0x8000000   },
+{REG_TYPE_CBUS, 0x300b,     0xffffffff, 0x0100000   },
+{REG_TYPE_CBUS, 0x300c,     0xffffffff, 0x0100000   },
+{REG_TYPE_CBUS, 0x300d,     0xffffffff, 0x0000100   },
+{REG_TYPE_CBUS, 0x3010,     0xffffffff, 0x20001000  },
+{REG_TYPE_CBUS, 0x3016,     0xffffffff, 0x81eff     },
+{REG_TYPE_CBUS, 0x3017,     0xffffffff, 0x01080     },
+{REG_TYPE_CBUS, 0x301d,     0xffffffff, 0x30501080  },
+{REG_TYPE_CBUS, 0x301e,     0xffffffff, 0x7	    },
+{REG_TYPE_CBUS, 0x301f,     0xffffffff, 0x6000000   },
+{0}
+	}
+};
+#endif
+
+#endif
+
diff --git a/include/linux/amlogic/amports/amstream.h b/include/linux/amlogic/amports/amstream.h
index 7e8e642a830d..dabe171bcd6b 100755
--- a/include/linux/amlogic/amports/amstream.h
+++ b/include/linux/amlogic/amports/amstream.h
@@ -23,7 +23,6 @@
 #define AMSTREAM_H
 
 //#include <linux/interrupt.h>
-#include "ve.h"
 
 #ifdef __KERNEL__
 #define PORT_FLAG_IN_USE    0x0001
@@ -104,24 +103,6 @@
 #define AMSTREAM_IOC_SET_VIDEO_CROP   _IOW(AMSTREAM_IOC_MAGIC, 0x4e, unsigned long)
 #define AMSTREAM_IOC_PCRID        _IOW(AMSTREAM_IOC_MAGIC, 0x4f, int)
 
-// VPP.VE IOCTL command list
-#define AMSTREAM_IOC_VE_BEXT   _IOW(AMSTREAM_IOC_MAGIC, 0x20, struct ve_bext_s  )
-#define AMSTREAM_IOC_VE_DNLP   _IOW(AMSTREAM_IOC_MAGIC, 0x21, struct ve_dnlp_s  )
-#define AMSTREAM_IOC_VE_HSVS   _IOW(AMSTREAM_IOC_MAGIC, 0x22, struct ve_hsvs_s  )
-#define AMSTREAM_IOC_VE_CCOR   _IOW(AMSTREAM_IOC_MAGIC, 0x23, struct ve_ccor_s  )
-#define AMSTREAM_IOC_VE_BENH   _IOW(AMSTREAM_IOC_MAGIC, 0x24, struct ve_benh_s  )
-#define AMSTREAM_IOC_VE_DEMO   _IOW(AMSTREAM_IOC_MAGIC, 0x25, struct ve_demo_s  )
-#define AMSTREAM_IOC_VE_VDO_MEAS _IOW(AMSTREAM_IOC_MAGIC, 0x27, struct vdo_meas_s )
-#define AMSTREAM_IOC_VE_DEBUG    _IOWR(AMSTREAM_IOC_MAGIC, 0x28, unsigned long long)
-#define AMSTREAM_IOC_VE_REGMAP   _IOW(AMSTREAM_IOC_MAGIC, 0x29, struct ve_regmap_s)
-
-// VPP.CM IOCTL command list
-#define AMSTREAM_IOC_CM_REGION _IOW(AMSTREAM_IOC_MAGIC, 0x30, struct cm_region_s)
-#define AMSTREAM_IOC_CM_TOP    _IOW(AMSTREAM_IOC_MAGIC, 0x31, struct cm_top_s   )
-#define AMSTREAM_IOC_CM_DEMO   _IOW(AMSTREAM_IOC_MAGIC, 0x32, struct cm_demo_s  )
-#define AMSTREAM_IOC_CM_DEBUG  _IOWR(AMSTREAM_IOC_MAGIC, 0x33, unsigned long long)
-#define AMSTREAM_IOC_CM_REGMAP  _IOW(AMSTREAM_IOC_MAGIC, 0x34, struct cm_regmap_s)
-
 //VPP.3D IOCTL command list^M
 #define  AMSTREAM_IOC_SET_3D_TYPE  _IOW(AMSTREAM_IOC_MAGIC, 0x3c, unsigned int)
 #define  AMSTREAM_IOC_GET_3D_TYPE  _IOW(AMSTREAM_IOC_MAGIC, 0x3d, unsigned int)
diff --git a/include/linux/amlogic/amports/cm.h b/include/linux/amlogic/amports/cm.h
deleted file mode 100755
index 3405656cd5d2..000000000000
--- a/include/linux/amlogic/amports/cm.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Color Management
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-
-#ifndef _TVOUT_CM_H
-#define _TVOUT_CM_H
-
-// ***************************************************************************
-// *** enum definitions *********************************************
-// ***************************************************************************
-
-typedef enum cm_region_idx_e {
-    CM_REGION_IDX_0 = 0,
-    CM_REGION_IDX_1,
-    CM_REGION_IDX_2,
-    CM_REGION_IDX_3,
-    CM_REGION_IDX_4,
-    CM_REGION_IDX_5,
-    CM_REGION_IDX_6,
-    CM_REGION_IDX_7,
-} cm_region_idx_t;
-
-typedef enum cm_sat_shape_e {
-    CM_SAT_SHAPE_RIGHT_BIGGEST = 0,
-    CM_SAT_SHAPE_LEFT_BIGGEST,
-} cm_sat_shape_t;
-
-typedef enum cm_hue_shape_e {
-    CM_HUE_SHAPE_LEFT_MORE = 0,
-    CM_HUE_SHAPE_RIGHT_MORE,
-} cm_hue_shape_t;
-
-typedef enum cm_demo_pos_e {
-    CM_DEMO_POS_TOP = 0,
-    CM_DEMO_POS_BOTTOM,
-    CM_DEMO_POS_LEFT,
-    CM_DEMO_POS_RIGHT,
-} cm_demo_pos_t;
-
-typedef enum cm_sat_sel_e {
-    CM_SAT_SEL_U2_V2 = 0,
-    CM_SAT_SEL_UV_MAX,
-} cm_sat_sel_t;
-
-typedef enum cm_csc_e {
-    CM_CSC_601 = 0,
-    CM_CSC_709,
-    CM_CSC_FULL_601,
-    CM_CSC_FULL_709,
-} cm_csc_t;
-
-// ***************************************************************************
-// *** struct definitions *********************************************
-// ***************************************************************************
-
-typedef struct cm_region_s {
-    enum cm_region_idx_e region_idx;
-    // sym
-    unsigned char       sym_en;
-    // sat - top
-    unsigned char       sat_en;
-    unsigned char       sat_central_en;
-    enum cm_sat_shape_e sat_shape;
-    unsigned char       sat_gain;
-    unsigned char       sat_inc;
-    // sat - lum
-    unsigned char       sat_lum_h_slope;
-    unsigned char       sat_lum_l_slope;
-    unsigned char       sat_lum_h;
-    unsigned char       sat_lum_l;
-    // sat - sat
-    unsigned char       sat_sat_h_slope;
-    unsigned char       sat_sat_l_slope;
-    unsigned char       sat_sat_h;
-    unsigned char       sat_sat_l;
-    // hue - top
-    unsigned char       hue_en;
-    unsigned char       hue_central_en;
-    enum cm_hue_shape_e hue_shape;
-    unsigned char       hue_gain;
-    unsigned char       hue_clockwise;
-    unsigned char       hue_shf_ran;
-    ushort              hue_shf_sta;
-    // hue - lum
-    unsigned char       hue_lum_h_slope;
-    unsigned char       hue_lum_l_slope;
-    unsigned char       hue_lum_h;
-    unsigned char       hue_lum_l;
-    // hue - sat
-    unsigned char       hue_sat_h_slope;
-    unsigned char       hue_sat_l_slope;
-    unsigned char       hue_sat_h;
-    unsigned char       hue_sat_l;
-} cm_region_t;
-
-typedef struct cm_top_s {
-    unsigned char       chroma_en;
-    enum cm_sat_sel_e   sat_sel;
-    unsigned char       uv_adj_en;
-    unsigned char       rgb_to_hue_en;
-    enum cm_csc_e       csc_sel;
-} cm_top_t;
-
-typedef struct cm_cbar_s {
-    unsigned char en;
-    unsigned char wid;
-    unsigned char cr;
-    unsigned char cb;
-    unsigned char y;
-} cm_cbar_t;
-typedef struct cm_demo_s {
-    unsigned char       en;
-    enum cm_demo_pos_e  pos;
-    unsigned char       hlight_adj;
-    ushort              wid;
-    struct cm_cbar_s   cbar;
-} cm_demo_t;
-
-typedef struct cm_regmap_s {
-    ulong reg[50];
-} cm_regmap_t;
-
-#if defined(CONFIG_AM_VECM)
-typedef enum reg_bus_type_e {
-    REG_TYPE_PHY = 0,
-    REG_TYPE_CBUS,
-    REG_TYPE_APB,
-    REG_TYPE_AXI,
-    REG_TYPE_AHB,
-    REG_TYPE_MPEG,
-    REG_TYPE_INDEX_VPPCHROMA,
-    REG_TYPE_INDEX_GAMMA,
-    VALUE_TYPE_CONTRAST_BRIGHTNESS,
-    REG_TYPE_INDEX_VPP_COEF,
-    REG_TYPE_MAX,
-} reg_bus_type_t;
-
-/* Register table structure */
-typedef struct am_reg_s {
-    unsigned int type; //32-bits; 0: CBUS; 1: APB BUS...
-    unsigned int addr; //32-bits; Register address
-    unsigned int mask; //32-bits; Valid bits
-    unsigned int  val; //32-bits; Register Value
-} am_reg_t;
-
-#ifdef AMVIDEO_REG_TABLE_DYNAMIC
-typedef struct am_regs_s {
-    unsigned int    length; // Length of total am_reg
-    struct am_reg_s *am_reg;
-} am_regs_t;
-#else
-typedef struct am_regs_s {
-    unsigned int    length; // Length of total am_reg
-    struct am_reg_s am_reg[512];
-} am_regs_t;
-#endif
-#endif
-
-#endif  // _TVOUT_CM_H
diff --git a/include/linux/amlogic/amports/ve.h b/include/linux/amlogic/amports/ve.h
deleted file mode 100755
index 2f57cea2665a..000000000000
--- a/include/linux/amlogic/amports/ve.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * Video Enhancement
- *
- * Author: Lin Xu <lin.xu@amlogic.com>
- *         Bobby Yang <bo.yang@amlogic.com>
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef __VE_H
-#define __VE_H
-
-// ***************************************************************************
-// *** enum definitions *********************************************
-// ***************************************************************************
-
-typedef enum ve_demo_pos_e {
-  VE_DEMO_POS_TOP = 0,
-  VE_DEMO_POS_BOTTOM,
-  VE_DEMO_POS_LEFT,
-  VE_DEMO_POS_RIGHT,
-} ve_demo_pos_t;
-
-typedef enum ve_dnlp_rt_e {
-	VE_DNLP_RT_0S = 0,
-	VE_DNLP_RT_1S = 6,
-    VE_DNLP_RT_2S,
-    VE_DNLP_RT_4S,
-    VE_DNLP_RT_8S,
-    VE_DNLP_RT_16S,
-    VE_DNLP_RT_32S,
-    VE_DNLP_RT_64S,
-    VE_DNLP_RT_FREEZE,
-} ve_dnlp_rt_t;
-
-// ***************************************************************************
-// *** struct definitions *********************************************
-// ***************************************************************************
-
-typedef struct ve_bext_s {
-    unsigned char en;
-    unsigned char start;
-    unsigned char slope1;
-    unsigned char midpt;
-    unsigned char slope2;
-} ve_bext_t;
-#if defined(CONFIG_AM_VECM)
-typedef struct ve_dnlp_s {
-    unsigned int      en;
-    unsigned int rt;    //       0 ~ 255,
-    unsigned int rl;    //       0 ~  15, 1.0000x ~ 1.9375x, step 0.0625x
-    unsigned int black; //       0 ~  16, weak ~ strong
-    unsigned int white; //       0 ~  16, weak ~ strong
-} ve_dnlp_t;
-#else
-typedef struct ve_dnlp_s {
-    unsigned char en;
-    enum  ve_dnlp_rt_e rt;
-    unsigned char gamma[64];
-} ve_dnlp_t;
-#endif
-typedef struct ve_hsvs_s {
-    unsigned char en;
-    unsigned char peak_gain_h1;
-    unsigned char peak_gain_h2;
-    unsigned char peak_gain_h3;
-    unsigned char peak_gain_h4;
-    unsigned char peak_gain_h5;
-    unsigned char peak_gain_v1;
-    unsigned char peak_gain_v2;
-    unsigned char peak_gain_v3;
-    unsigned char peak_gain_v4;
-    unsigned char peak_gain_v5;
-    unsigned char peak_gain_v6;
-    unsigned char hpeak_slope1;
-    unsigned char hpeak_slope2;
-    unsigned char hpeak_thr1;
-    unsigned char hpeak_thr2;
-    unsigned char hpeak_nlp_cor_thr;
-    unsigned char hpeak_nlp_gain_pos;
-    unsigned char hpeak_nlp_gain_neg;
-    unsigned char vpeak_slope1;
-    unsigned char vpeak_slope2;
-    unsigned char vpeak_thr1;
-    unsigned char vpeak_thr2;
-    unsigned char vpeak_nlp_cor_thr;
-    unsigned char vpeak_nlp_gain_pos;
-    unsigned char vpeak_nlp_gain_neg;
-    unsigned char speak_slope1;
-    unsigned char speak_slope2;
-    unsigned char speak_thr1;
-    unsigned char speak_thr2;
-    unsigned char speak_nlp_cor_thr;
-    unsigned char speak_nlp_gain_pos;
-    unsigned char speak_nlp_gain_neg;
-    unsigned char peak_cor_gain;
-    unsigned char peak_cor_thr_l;
-    unsigned char peak_cor_thr_h;
-    unsigned char vlti_step;
-    unsigned char vlti_step2;
-    unsigned char vlti_thr;
-    unsigned char vlti_gain_pos;
-    unsigned char vlti_gain_neg;
-    unsigned char vlti_blend_factor;
-    unsigned char hlti_step;
-    unsigned char hlti_thr;
-    unsigned char hlti_gain_pos;
-    unsigned char hlti_gain_neg;
-    unsigned char hlti_blend_factor;
-    unsigned char vlimit_coef_h;
-    unsigned char vlimit_coef_l;
-    unsigned char hlimit_coef_h;
-    unsigned char hlimit_coef_l;
-    unsigned char cti_444_422_en;
-    unsigned char cti_422_444_en;
-    unsigned char cti_blend_factor;
-    unsigned char vcti_buf_en;
-    unsigned char vcti_buf_mode_c5l;
-    unsigned char vcti_filter;
-    unsigned char hcti_step;
-    unsigned char hcti_step2;
-    unsigned char hcti_thr;
-    unsigned char hcti_gain;
-    unsigned char hcti_mode_median;
-} ve_hsvs_t;
-
-typedef struct ve_ccor_s {
-    unsigned char en;
-    unsigned char slope;
-    unsigned char thr;
-} ve_ccor_t;
-
-typedef struct ve_benh_s {
-    unsigned char en;
-    unsigned char cb_inc;
-    unsigned char cr_inc;
-    unsigned char gain_cr;
-    unsigned char gain_cb4cr;
-    unsigned char luma_h;
-    unsigned char err_crp;
-    unsigned char err_crn;
-    unsigned char err_cbp;
-    unsigned char err_cbn;
-} ve_benh_t;
-
-typedef struct ve_cbar_s {
-    unsigned char en;
-    unsigned char wid;
-    unsigned char cr;
-    unsigned char cb;
-    unsigned char y;
-} ve_cbar_t;
-typedef struct ve_demo_s {
-    unsigned char bext;
-    unsigned char dnlp;
-    unsigned char hsvs;
-    unsigned char ccor;
-    unsigned char benh;
-    enum  ve_demo_pos_e  pos;
-    unsigned long wid;
-    struct ve_cbar_s   cbar;
-} ve_demo_t;
-
-typedef struct vdo_meas_s {
-    //...
-} vdo_meas_t;
-
-typedef struct ve_regmap_s {
-    unsigned long reg[43];
-} ve_regmap_t;
-
-// ***************************************************************************
-// *** MACRO definitions **********
-// ***************************************************************************
-
-// ***************************************************************************
-// *** FUNCTION definitions **********
-// ***************************************************************************
-
-#endif  // _VE_H
diff --git a/include/linux/amlogic/amstream.h b/include/linux/amlogic/amstream.h
index 813508c2254d..03738789bb51 100755
--- a/include/linux/amlogic/amstream.h
+++ b/include/linux/amlogic/amstream.h
@@ -23,7 +23,6 @@
 #define AMSTREAM_H
 
 //#include <linux/interrupt.h>
-#include "ve.h"
 
 #ifdef __KERNEL__
 #define PORT_FLAG_IN_USE    0x0001
@@ -101,24 +100,6 @@
 #define AMSTREAM_IOC_GET_VIDEO_CROP     _IOR(AMSTREAM_IOC_MAGIC, 0x4d, unsigned long)
 #define AMSTREAM_IOC_SET_VIDEO_CROP     _IOW(AMSTREAM_IOC_MAGIC, 0x4e, unsigned long)
 
-// VPP.VE IOCTL command list
-#define AMSTREAM_IOC_VE_BEXT     _IOW(AMSTREAM_IOC_MAGIC, 0x20, struct ve_bext_s  )
-#define AMSTREAM_IOC_VE_DNLP     _IOW(AMSTREAM_IOC_MAGIC, 0x21, struct ve_dnlp_s  )
-#define AMSTREAM_IOC_VE_HSVS     _IOW(AMSTREAM_IOC_MAGIC, 0x22, struct ve_hsvs_s  )
-#define AMSTREAM_IOC_VE_CCOR     _IOW(AMSTREAM_IOC_MAGIC, 0x23, struct ve_ccor_s  )
-#define AMSTREAM_IOC_VE_BENH     _IOW(AMSTREAM_IOC_MAGIC, 0x24, struct ve_benh_s  )
-#define AMSTREAM_IOC_VE_DEMO     _IOW(AMSTREAM_IOC_MAGIC, 0x25, struct ve_demo_s  )
-#define AMSTREAM_IOC_VE_VDO_MEAS _IOW(AMSTREAM_IOC_MAGIC, 0x27, struct vdo_meas_s )
-#define AMSTREAM_IOC_VE_DEBUG    _IOWR(AMSTREAM_IOC_MAGIC, 0x28, unsigned long long)
-#define AMSTREAM_IOC_VE_REGMAP   _IOW(AMSTREAM_IOC_MAGIC, 0x29, struct ve_regmap_s)
-
-// VPP.CM IOCTL command list
-#define AMSTREAM_IOC_CM_REGION  _IOW(AMSTREAM_IOC_MAGIC, 0x30, struct cm_region_s)
-#define AMSTREAM_IOC_CM_TOP     _IOW(AMSTREAM_IOC_MAGIC, 0x31, struct cm_top_s   )
-#define AMSTREAM_IOC_CM_DEMO    _IOW(AMSTREAM_IOC_MAGIC, 0x32, struct cm_demo_s  )
-#define AMSTREAM_IOC_CM_DEBUG   _IOWR(AMSTREAM_IOC_MAGIC, 0x33, unsigned long long)
-#define AMSTREAM_IOC_CM_REGMAP  _IOW(AMSTREAM_IOC_MAGIC, 0x34, struct cm_regmap_s)
-
 //VPP.3D IOCTL command list
 #define  AMSTREAM_IOC_SET_3D_TYPE  _IOW(AMSTREAM_IOC_MAGIC, 0x3c, unsigned int)
 #define  AMSTREAM_IOC_GET_3D_TYPE  _IOW(AMSTREAM_IOC_MAGIC, 0x3d, unsigned int)
diff --git a/include/linux/amlogic/amvecm.h b/include/linux/amlogic/amvecm.h
index d1fafc2c0e77..6a14534d8c75 100755
--- a/include/linux/amlogic/amvecm.h
+++ b/include/linux/amlogic/amvecm.h
@@ -27,14 +27,7 @@
 #include <linux/amlogic/amstream.h>
 
 
-struct ve_dnlp_s          video_ve_dnlp;
-struct tcon_gamma_table_s video_gamma_table_r;
-struct tcon_gamma_table_s video_gamma_table_g;
-struct tcon_gamma_table_s video_gamma_table_b;
-struct tcon_gamma_table_s video_gamma_table_r_adj;
-struct tcon_gamma_table_s video_gamma_table_g_adj;
-struct tcon_gamma_table_s video_gamma_table_b_adj;
-struct tcon_rgb_ogo_s     video_rgb_ogo;
+//struct ve_dnlp_s          video_ve_dnlp;
 
 #define FLAG_RSV31              (1 << 31)
 #define FLAG_RSV30              (1 << 30)
@@ -42,12 +35,12 @@ struct tcon_rgb_ogo_s     video_rgb_ogo;
 #define FLAG_VE_NEW_DNLP        (1 << 28)
 #define FLAG_RSV27              (1 << 27)
 #define FLAG_RSV26              (1 << 26)
-#define FLAG_RSV25              (1 << 25)
-#define FLAG_RSV24              (1 << 24)
-#define FLAG_RSV23              (1 << 23)
-#define FLAG_RSV22              (1 << 22)
-#define FLAG_RSV21              (1 << 21)
-#define FLAG_RSV20              (1 << 20)
+#define FLAG_3D_BLACK_DIS       (1 << 25)
+#define FLAG_3D_BLACK_EN        (1 << 24)
+#define FLAG_3D_SYNC_DIS        (1 << 23)
+#define FLAG_3D_SYNC_EN         (1 << 22)
+#define FLAG_VLOCK_PLL          (1 << 21)
+#define FLAG_VLOCK_ENC          (1 << 20)
 #define FLAG_VE_DNLP_EN         (1 << 19)
 #define FLAG_VE_DNLP_DIS        (1 << 18)
 #define FLAG_RSV17              (1 << 17)
diff --git a/include/linux/amlogic/cm.h b/include/linux/amlogic/cm.h
index 8fba6a346a6c..5a8932780c81 100755
--- a/include/linux/amlogic/cm.h
+++ b/include/linux/amlogic/cm.h
@@ -132,15 +132,16 @@ typedef struct cm_regmap_s {
 
 typedef enum reg_bus_type_e {
     REG_TYPE_PHY = 0,
-    REG_TYPE_CBUS,
-    REG_TYPE_APB,
-    REG_TYPE_AXI,
-    REG_TYPE_AHB,
-    REG_TYPE_MPEG,
-    REG_TYPE_INDEX_VPPCHROMA,
-    REG_TYPE_INDEX_GAMMA,
-    VALUE_TYPE_CONTRAST_BRIGHTNESS,
-    REG_TYPE_INDEX_VPP_COEF,
+    REG_TYPE_CBUS = 1,
+    REG_TYPE_APB = 2,
+    REG_TYPE_AXI = 3,
+    REG_TYPE_AHB = 4,
+    REG_TYPE_MPEG = 5,
+    REG_TYPE_INDEX_VPPCHROMA = 6,
+    REG_TYPE_INDEX_GAMMA = 7,
+    VALUE_TYPE_CONTRAST_BRIGHTNESS = 8,
+    REG_TYPE_INDEX_VPP_COEF = 9,
+    REG_TYPE_VCBUS = 10,
     REG_TYPE_MAX,
 } reg_bus_type_t;
 
@@ -152,16 +153,9 @@ typedef struct am_reg_s {
     unsigned int  val; //32-bits; Register Value
 } am_reg_t;
 
-#ifdef AMVIDEO_REG_TABLE_DYNAMIC
-typedef struct am_regs_s {
-    unsigned int    length; // Length of total am_reg
-    struct am_reg_s *am_reg;
-} am_regs_t;
-#else
 typedef struct am_regs_s {
     unsigned int    length; // Length of total am_reg
     struct am_reg_s am_reg[512];
 } am_regs_t;
-#endif
 
 #endif  // _TVOUT_CM_H
diff --git a/include/linux/amlogic/tvin/tvin.h b/include/linux/amlogic/tvin/tvin.h
index 1f33ddd6c4f7..7b27ab305e27 100755
--- a/include/linux/amlogic/tvin/tvin.h
+++ b/include/linux/amlogic/tvin/tvin.h
@@ -15,23 +15,8 @@
 #ifndef __TVIN_H
 #define __TVIN_H
 
-#include <plat/io.h>
-#include <linux/amlogic/amports/cm.h>
-
-#define R_CBUS_REG(reg) aml_read_reg32(CBUS_REG_ADDR(reg))
-#define W_CBUS_REG(reg, val) aml_write_reg32(CBUS_REG_ADDR(reg), val)
-#define R_CBUS_BIT(reg, start, len) \
-	aml_get_reg32_bits(CBUS_REG_ADDR(reg), start, len)
-#define W_CBUS_BIT(reg, val, start, len) \
-	aml_set_reg32_bits(CBUS_REG_ADDR(reg), val, start, len)
-
-#define R_APB_REG(reg) aml_read_reg32(APB_REG_ADDR(reg))
-#define W_APB_REG(reg, val) aml_write_reg32(APB_REG_ADDR(reg), val)
-#define R_APB_BIT(reg, start, len) \
-	aml_get_reg32_bits(APB_REG_ADDR(reg), start, len)
-#define W_APB_BIT(reg, val, start, len) \
-	aml_set_reg32_bits(APB_REG_ADDR(reg), val, start, len)
-
+#include <linux/amlogic/cm.h>
+#include <mach/am_regs.h>
 
 enum {
     MEMP_VDIN_WITHOUT_3D = 0,
-- 
2.19.0

