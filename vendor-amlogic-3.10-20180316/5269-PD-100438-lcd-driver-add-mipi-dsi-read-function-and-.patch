From 3025d206ba499293027e64876dd2f8793da1c0b6 Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Tue, 30 Dec 2014 14:55:12 +0800
Subject: [PATCH 5269/5965] PD#100438: lcd driver: add mipi-dsi read function,
 and update mipi-dsi command foramt

Squashed commit of the following:

commit 3faf815c16a86db9dc73308708e7ce7f8dd0c36d
Author: Evoke Zhang <evoke.zhang@amlogic.com>
Date:   Thu Dec 25 13:58:13 2014 +0800

    PD#101438: modify remark for DSI_CMD_CNT_INDEX

    Change-Id: If865492435de5c65b1753be44d75909094dc569b

commit d7314a7bb231dfd6018420aed678f9783f1d85d5
Author: Evoke Zhang <evoke.zhang@amlogic.com>
Date:   Thu Dec 25 13:46:54 2014 +0800

    PD#100438: lcd driver: add mipi-dsi read function, and update mipi-dsi command foramt

    Change-Id: Ia7a345232f2f47edaccf677c79ccb22f931547ef

Change-Id: Ic0a60f6dd2fb3510480703fd46d516170efbefdc
---
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |   8 +-
 arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd  |  38 +-
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |  16 +-
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |  40 +-
 arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd |   8 +-
 arch/arm/mach-meson6/include/mach/lcdoutc.h   |  14 +-
 arch/arm/mach-meson8/include/mach/lcdoutc.h   |  21 +-
 arch/arm/mach-meson8/lcd/lcd_config.h         |   2 +-
 arch/arm/mach-meson8/lcd/mipi_dsi_util.c      | 510 +++++++++++++-----
 arch/arm/mach-meson8/lcd/mipi_dsi_util.h      |  97 ++--
 arch/arm/mach-meson8b/include/mach/lcdoutc.h  |  21 +-
 arch/arm/mach-meson8b/lcd/lcd_config.h        |   2 +-
 arch/arm/mach-meson8b/lcd/mipi_dsi_util.c     | 510 +++++++++++++-----
 arch/arm/mach-meson8b/lcd/mipi_dsi_util.h     |  97 ++--
 drivers/amlogic/display/backlight/aml.dtd     |   2 +-
 .../backlight/aml_bl_extern/mipi_LT070ME05.c  |   6 +-
 drivers/amlogic/display/vout/aml_lcd.dtd      | 133 +++--
 .../amlogic/display/vout/lcd_extern/Makefile  |   1 +
 .../amlogic/display/vout/lcd_extern/aml.dtd   |  12 +
 .../display/vout/lcd_extern/mipi_KD080D13.c   | 200 +++++++
 .../display/vout/lcd_extern/mipi_N070ICN.c    | 328 +++++------
 drivers/amlogic/display/vout/lcdoutc.c        |  52 +-
 include/linux/amlogic/vout/lcdoutc.h          |   1 +
 24 files changed, 1482 insertions(+), 645 deletions(-)
 create mode 100644 drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index 95d19d826e91..bcdf217aec4a 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -1199,14 +1199,14 @@ sdio{
 
 //		dsi_lane_num=<4>;/** mipi dsi data lane number */
 //		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
-//		dsi_init_on=<0x05 0x11 0 //sleep out
+//		dsi_init_on=<0x05 1 0x11 //sleep out
 //					0xff 20      //delay 20ms
-//					0x05 0x29 0  //display on
+//					0x05 1 0x29  //display on
 //					0xff 20      //delay 20ms
 //					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-//		dsi_init_off=<0x05 0x28 0 //display off
+//		dsi_init_off=<0x05 1 0x28 //display off
 //					0xff 10       //delay 10ms
-//					0x05 0x10 0   //sleep in
+//					0x05 1 0x10   //sleep in
 //					0xff 10       //delay 10ms
 //					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 //	};
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index 6f7a2c785190..8837ace13b79 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -1189,14 +1189,14 @@ sdio{
 
 //		dsi_lane_num=<4>;/** mipi dsi data lane number */
 //		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
-//		dsi_init_on=<0x05 0x11 0 //sleep out
+//		dsi_init_on=<0x05 1 0x11 //sleep out
 //					0xff 20      //delay 20ms
-//					0x05 0x29 0  //display on
+//					0x05 1 0x29  //display on
 //					0xff 20      //delay 20ms
 //					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-//		dsi_init_off=<0x05 0x28 0 //display off
+//		dsi_init_off=<0x05 1 0x28 //display off
 //					0xff 10       //delay 10ms
-//					0x05 0x10 0   //sleep in
+//					0x05 1 0x10   //sleep in
 //					0xff 10       //delay 10ms
 //					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 //	};
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
index f9b2f7309be2..e91482fc7dd4 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
@@ -1133,14 +1133,14 @@ sdio{
 		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 		pclk_lanebyteclk_factor =<0>;/** special adjust, default is 0 */
 		dsi_transfer_ctrl=<0 0>;/** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-		dsi_init_on=<0x05 0x11 0 //sleep out
+		dsi_init_on=<0x05 1 0x11 //sleep out
 					0xff 20      //delay 20ms
-					0x05 0x29 0  //display on
+					0x05 1 0x29  //display on
 					0xff 20      //delay 20ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-		dsi_init_off=<0x05 0x28 0 //display off
+		dsi_init_off=<0x05 1 0x28 //display off
 					0xff 10       //delay 10ms
-					0x05 0x10 0   //sleep in
+					0x05 1 0x10   //sleep in
 					0xff 10       //delay 10ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 		lcd_extern_init=<0>;/** lcd extern init command control(0=disable, 1=enable) */
@@ -1186,23 +1186,23 @@ sdio{
 //		dsi_bit_rate_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
 //		dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-//		dsi_init_on=<0x15 0x01 1 0x0 
+//		dsi_init_on=<0x15 2 0x01 0x0 
 //				0xff 20     //delay 20ms
-//				0x15 0xAE 1 0x0B 
-//				0x15 0xEE 1 0xEA 
-//				0x15 0xEF 1 0x5F 
-//				0x15 0xF2 1 0x68 
-//				0x15 0xEE 1 0x0 
-//				0x15 0xEF 1 0x0 
+//				0x15 2 0xAE 0x0B 
+//				0x15 2 0xEE 0xEA 
+//				0x15 2 0xEF 0x5F 
+//				0x15 2 0xF2 0x68 
+//				0x15 2 0xEE 0x0 
+//				0x15 2 0xEF 0x0 
 //
-//				0x05 0x11 0  //sleep out
+//				0x05 1 0x11  //sleep out
 //				0xff 200     //delay 200ms
-//				0x05 0x29 0  //display on
+//				0x05 1 0x29  //display on
 //				0xff 100     //delay 100ms
 //				0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-//		dsi_init_off=<0x05 0x28 0 //display off
+//		dsi_init_off=<0x05 1 0x28 //display off
 //				0xff 10       //delay 10ms
-//				0x05 0x10 0   //sleep in
+//				0x05 1 0x10   //sleep in
 //				0xff 10       //delay 10ms
 //				0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 //		lcd_extern_init=<0>;  /** lcd extern init command control(0=disable, 1=enable) */
@@ -1324,14 +1324,14 @@ sdio{
 //		dsi_bit_rate_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		pclk_lanebyteclk_factor =<15>;   /** special adjust, default is 0 */
 //		dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-//		dsi_init_on=<0x05 0x11 0 //sleep out
+//		dsi_init_on=<0x05 1 0x11 //sleep out
 //				0xff 100     //delay 100ms
-//				0x05 0x29 0  //display on
+//				0x05 1 0x29  //display on
 //				0xff 100     //delay 100ms
 //				0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-//		dsi_init_off=<0x05 0x28 0 //display off
+//		dsi_init_off=<0x05 1 0x28 //display off
 //				0xff 10       //delay 10ms
-//				0x05 0x10 0   //sleep in
+//				0x05 1 0x10   //sleep in
 //				0xff 10       //delay 10ms
 //				0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 //		lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index 8a6ee3406f9b..a23c980ac898 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -1127,14 +1127,14 @@ sdio{
 
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
 		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
-		dsi_init_on=<0x05 0x11 0 //sleep out
+		dsi_init_on=<0x05 1 0x11 //sleep out
 					0xff 20      //delay 20ms
-					0x05 0x29 0  //display on
+					0x05 1 0x29  //display on
 					0xff 20      //delay 20ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-		dsi_init_off=<0x05 0x28 0 //display off
+		dsi_init_off=<0x05 1 0x28 //display off
 					0xff 10       //delay 10ms
-					0x05 0x10 0   //sleep in
+					0x05 1 0x10   //sleep in
 					0xff 10       //delay 10ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 	};
@@ -1252,14 +1252,14 @@ sdio{
 //		dsi_bit_rate_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 //		pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
 //		dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-//		dsi_init_on=<0x05 0x11 0 //sleep out
+//		dsi_init_on=<0x05 1 0x11 //sleep out
 //				0xff 100     //delay 100ms
-//				0x05 0x29 0  //display on
+//				0x05 1 0x29  //display on
 //				0xff 100     //delay 100ms
 //				0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-//		dsi_init_off=<0x05 0x28 0 //display off
+//		dsi_init_off=<0x05 1 0x28 //display off
 //				0xff 10       //delay 10ms
-//				0x05 0x10 0   //sleep in
+//				0x05 1 0x10   //sleep in
 //				0xff 10       //delay 10ms
 //				0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 //	};
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index a02a9933455f..746c73d63a1d 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -1177,14 +1177,14 @@ sdio{
 		
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
 		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
-		dsi_init_on=<0x05 0x11 0 //sleep out
+		dsi_init_on=<0x05 1 0x11 //sleep out
 					0xff 20      //delay 20ms
-					0x05 0x29 0  //display on
+					0x05 1 0x29  //display on
 					0xff 20      //delay 20ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-		dsi_init_off=<0x05 0x28 0 //display off
+		dsi_init_off=<0x05 1 0x28 //display off
 					0xff 10       //delay 10ms
-					0x05 0x10 0   //sleep in
+					0x05 1 0x10   //sleep in
 					0xff 10       //delay 10ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 	};
@@ -1224,23 +1224,23 @@ lcd_LD070WX4:lcd_LD070WX4{
 		dsi_lane_num=<4>;/** mipi dsi data lane number */
 		dsi_operation_mode=<0 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
 		dsi_bit_rate_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
-		dsi_init_on=<0x15 0x01 1 0x0 
+		dsi_init_on=<0x15 2 0x01 0x0 
 				0xff 20     //delay 20ms
-				0x15 0xAE 1 0x0B 
-				0x15 0xEE 1 0xEA 
-				0x15 0xEF 1 0x5F 
-				0x15 0xF2 1 0x68 
-				0x15 0xEE 1 0x0 
-				0x15 0xEF 1 0x0 
-
-				0x05 0x11 0  //sleep out
+				0x15 2 0xAE 0x0B 
+				0x15 2 0xEE 0xEA 
+				0x15 2 0xEF 0x5F 
+				0x15 2 0xF2 0x68 
+				0x15 2 0xEE 0x0 
+				0x15 2 0xEF 0x0 
+
+				0x05 1 0x11  //sleep out
 				0xff 200     //delay 200ms
-				0x05 0x29 0  //display on
+				0x05 1 0x29  //display on
 				0xff 100     //delay 100ms
 				0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-		dsi_init_off=<0x05 0x28 0 //display off
+		dsi_init_off=<0x05 1 0x28 //display off
 				0xff 10       //delay 10ms
-				0x05 0x10 0   //sleep in
+				0x05 1 0x10   //sleep in
 				0xff 10       //delay 10ms
 				0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 	};
@@ -1358,14 +1358,14 @@ lcd_LD070WX4:lcd_LD070WX4{
 		dsi_bit_rate_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
 		pclk_lanebyteclk_factor =<15>;/** special adjust, default is 0 */
 		dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-		dsi_init_on=<0x05 0x11 0 //sleep out
+		dsi_init_on=<0x05 1 0x11 //sleep out
 				0xff 100     //delay 100ms
-				0x05 0x29 0  //display on
+				0x05 1 0x29  //display on
 				0xff 100     //delay 100ms
 				0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-		dsi_init_off=<0x05 0x28 0 //display off
+		dsi_init_off=<0x05 1 0x28 //display off
 				0xff 10       //delay 10ms
-				0x05 0x10 0   //sleep in
+				0x05 1 0x10   //sleep in
 				0xff 10       //delay 10ms
 				0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 	};
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
index 5deae0b20f83..465c9d9ac969 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
@@ -1169,14 +1169,14 @@ void root_func(){
 		dsi_bit_rate_max=<550>;/** mipi-dsi data lane bit rate limit(unit: MHz) */
 		pclk_lanebyteclk_factor =<0>;/** special adjust, default is 0 */
 		dsi_transfer_ctrl=<0 0>;/** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-		dsi_init_on=<0x05 0x11 0 //sleep out
+		dsi_init_on=<0x05 1 0x11 //sleep out
 					0xff 20      //delay 20ms
-					0x05 0x29 0  //display on
+					0x05 1 0x29  //display on
 					0xff 20      //delay 20ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-		dsi_init_off=<0x05 0x28 0 //display off
+		dsi_init_off=<0x05 1 0x28 //display off
 					0xff 10       //delay 10ms
-					0x05 0x10 0   //sleep in
+					0x05 1 0x10   //sleep in
 					0xff 10       //delay 10ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
 		lcd_extern_init=<0>;/** lcd extern init command control(0=disable, 1=enable) */
diff --git a/arch/arm/mach-meson6/include/mach/lcdoutc.h b/arch/arm/mach-meson6/include/mach/lcdoutc.h
index 38751485000a..bd3e66cc87d4 100755
--- a/arch/arm/mach-meson6/include/mach/lcdoutc.h
+++ b/arch/arm/mach-meson6/include/mach/lcdoutc.h
@@ -6,19 +6,7 @@
 #define CONFIG_LCD_IF_TTL_VALID
 #define CONFIG_LCD_IF_LVDS_VALID
 #define CONFIG_LCD_IF_MLVDS_VALID
-/*
-// lcd driver global API, special by CPU
-*/
-//*************************************************************
-// For mipi-dsi external driver use
-//*************************************************************
-//payload struct:
-//data_type, command, para_num, parameters...
-//data_type=0xff, command=0xff, means ending flag
-//data_type=0xff, command<0xff, means delay time(unit ms)
-//return:
-//command num
-extern int dsi_write_cmd(unsigned char* payload);
+
 //*************************************************************
 
 #endif
diff --git a/arch/arm/mach-meson8/include/mach/lcdoutc.h b/arch/arm/mach-meson8/include/mach/lcdoutc.h
index b4f919c2cae2..1dab41ec115c 100755
--- a/arch/arm/mach-meson8/include/mach/lcdoutc.h
+++ b/arch/arm/mach-meson8/include/mach/lcdoutc.h
@@ -13,13 +13,22 @@
 //*************************************************************
 // For mipi-dsi external driver use
 //*************************************************************
-//payload struct:
-//data_type, command, para_num, parameters...
-//data_type=0xff, command=0xff, means ending flag
-//data_type=0xff, command<0xff, means delay time(unit ms)
-//return:
-//command num
+//mipi command(payload)
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+
+// ----------------------------------------------------------------------------
+//                           Function: dsi_write_cmd
+// Supported Data Type: DT_GEN_SHORT_WR_0, DT_GEN_SHORT_WR_1, DT_GEN_SHORT_WR_2,
+//                      DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
+//                      DT_GEN_LONG_WR, DT_DCS_LONG_WR,
+//                      DT_SET_MAX_RET_PKT_SIZE
+//                      DT_GEN_RD_0, DT_GEN_RD_1, DT_GEN_RD_2,
+//                      DT_DCS_RD_0
+// Return:              command number
+// ----------------------------------------------------------------------------
 extern int dsi_write_cmd(unsigned char* payload);
+
 //*************************************************************
 
 #endif
diff --git a/arch/arm/mach-meson8/lcd/lcd_config.h b/arch/arm/mach-meson8/lcd/lcd_config.h
index f0a49a159e3b..ad13f1236821 100755
--- a/arch/arm/mach-meson8/lcd/lcd_config.h
+++ b/arch/arm/mach-meson8/lcd/lcd_config.h
@@ -7,7 +7,7 @@
 //lcd driver version
 //**********************************
 #define LCD_DRV_TYPE      "c8"
-#define LCD_DRV_DATE      "20141113"
+#define LCD_DRV_DATE      "20141223"
 //**********************************
 
 /* for GAMMA_CNTL_PORT */
diff --git a/arch/arm/mach-meson8/lcd/mipi_dsi_util.c b/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
index 4bc890ea506f..689f7b0d962f 100755
--- a/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
+++ b/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
@@ -16,7 +16,7 @@
 #include "mipi_dsi_util.h"
 
 #define DPRINT(...)		printk(__VA_ARGS__)
-//#define MIPI_DSI_COMMAND_READ
+
 //===============================================================================
 // Define MIPI DSI Default config
 //===============================================================================
@@ -53,12 +53,13 @@ static DSI_Phy_t dsi_phy_config;
 static DSI_Vid_t dsi_vid_config;
 static DSI_Config_t *dsi_config = NULL;
 static unsigned char dsi_init_on_table_dft[] = {
-    0x05,0x11,0,
+    0x05,1,0x11,
     0xff,50,
-    0x05,0x29,0,
+    0x05,1,0x29,
     0xff,20,
     0xff,0xff,
 };
+static unsigned short dsi_rx_n = 0;
 
 static inline void print_mipi_cmd_status(int cnt, unsigned status)
 {
@@ -125,10 +126,10 @@ static void print_info(void)
                 break;
             }
             else {
-                n = 3 + dsi_config->dsi_init_on[i+2];
+                n = (DSI_CMD_CNT_INDEX + 1) + dsi_config->dsi_init_on[i+DSI_CMD_CNT_INDEX];
                 DPRINT("    ");
                 for (j=0; j<n; j++) {
-                    if (j == 2)
+                    if (j == DSI_CMD_CNT_INDEX)
                         DPRINT("%d,", dsi_config->dsi_init_on[i+j]);
                     else
                         DPRINT("0x%02x,", dsi_config->dsi_init_on[i+j]);
@@ -157,10 +158,10 @@ static void print_info(void)
                 break;
             }
             else {
-                n = 3 + dsi_config->dsi_init_off[i+2];
+                n = (DSI_CMD_CNT_INDEX + 1) + dsi_config->dsi_init_off[i+DSI_CMD_CNT_INDEX];
                 DPRINT("    ");
                 for (j=0; j<n; j++) {
-                    if (j == 2)
+                    if (j == DSI_CMD_CNT_INDEX)
                         DPRINT("%d,", dsi_config->dsi_init_off[i+j]);
                     else
                         DPRINT("0x%02x,", dsi_config->dsi_init_off[i+j]);
@@ -224,10 +225,11 @@ static void check_phy_status(void)
 // -----------------------------------------------------------------------------
 //                     Function: set_mipi_dcs
 // Configure relative registers in command mode
+// Parameters:           int trans_type,       // 0: high speed, 1: low power
+//                       int req_ack,          // 1: request ack, 0: do not need ack
+//                       int tear_en           // 1: enable tear ack, 0: disable tear ack
 // -----------------------------------------------------------------------------
-static void set_mipi_dcs(int trans_type,        // 0: high speed, 1: low power
-                         int req_ack,           // 1: request ack, 0: do not need ack
-                         int tear_en)           // 1: enable tear ack, 0: disable tear ack
+static void set_mipi_dcs(int trans_type, int req_ack, int tear_en)
 {
     WRITE_LCD_REG( MIPI_DSI_DWC_CMD_MODE_CFG_OS, (trans_type << BIT_MAX_RD_PKT_SIZE) | (trans_type << BIT_DCS_LW_TX)    |
                     (trans_type << BIT_DCS_SR_0P_TX)    | (trans_type << BIT_DCS_SW_1P_TX) |
@@ -243,7 +245,15 @@ static void set_mipi_dcs(int trans_type,        // 0: high speed, 1: low power
         // Enable Measure Vsync
         WRITE_LCD_REG( MIPI_DSI_TOP_MEAS_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_MEAS_CNTL) | (0x1<<BIT_VSYNC_MEAS_EN | (0x1<<BIT_TE_MEAS_EN))));
     }
+
+    // Packet header settings
+    WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
+                        (1 << BIT_ECC_RX_EN)  |
+                        (0 << BIT_BTA_EN)     |
+                        (0 << BIT_EOTP_RX_EN) |
+                        (0 << BIT_EOTP_TX_EN) );
 }
+
 #if 0
 // -----------------------------------------------------------------------------
 //                     Function: set_mipi_int
@@ -255,23 +265,82 @@ static void set_mipi_int(void)
     WRITE_LCD_REG( MIPI_DSI_DWC_INT_MSK1_OS, 0);
 }
 #endif
+
+#ifdef DSI_CMD_READ_VALID
+static void dsi_bta_control(int en)
+{
+    if (en) {
+        WRITE_LCD_REG_BITS(MIPI_DSI_DWC_CMD_MODE_CFG_OS, MIPI_DSI_DCS_REQ_ACK, BIT_ACK_RQST_EN, 1);
+        WRITE_LCD_REG_BITS(MIPI_DSI_DWC_PCKHDL_CFG_OS, MIPI_DSI_DCS_REQ_ACK, BIT_BTA_EN, 1);
+    }
+    else {
+        WRITE_LCD_REG_BITS(MIPI_DSI_DWC_PCKHDL_CFG_OS, MIPI_DSI_DCS_NO_ACK, BIT_BTA_EN, 1);
+        WRITE_LCD_REG_BITS(MIPI_DSI_DWC_CMD_MODE_CFG_OS, MIPI_DSI_DCS_NO_ACK, BIT_ACK_RQST_EN, 1);
+    }
+}
+
+// ----------------------------------------------------------------------------
+//                           Function: generic_if_rd
+// Generic interface read, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS
+// ----------------------------------------------------------------------------
+static unsigned int generic_if_rd(unsigned int address)
+{
+    unsigned int data_out;
+
+    if(address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
+        DPRINT(" Error Address : %x\n", address);
+    }
+
+    data_out = READ_LCD_REG(address);
+
+    return data_out;
+}
+#endif
+
+// ----------------------------------------------------------------------------
+// Function: generic_if_wr
+// Generic interface write, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS and
+// MIPI_DSI_DWC_GEN_HDR_OS, MIPI_DSI_DWC_GEN_VCID_OS
+// ----------------------------------------------------------------------------
+static unsigned int generic_if_wr(unsigned int address, unsigned int data_in)
+{
+    if(address != MIPI_DSI_DWC_GEN_HDR_OS && address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
+        DPRINT(" Error Address : 0x%x\n", address);
+    }
+
+    lcd_print("address 0x%x = 0x%08x\n", address, data_in);
+    WRITE_LCD_REG(address, data_in);
+
+    return 0;
+}
+
 // ----------------------------------------------------------------------------
 // Function: wait_bta_ack
 // Poll to check if the BTA ack is finished
 // ----------------------------------------------------------------------------
 static void wait_bta_ack(void)
 {
-    unsigned int phy_status;
+    unsigned int phy_status, i;
 
     // Check if phydirection is RX
+    i = CMD_TIMEOUT_CNT;
     do {
-        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
-    } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x0);
+        udelay(10);
+        i--;
+        phy_status = READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS);
+    } while((((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x0) && (i>0));
+    if (i == 0)
+        DPRINT("phy direction error: RX\n");
 
     // Check if phydirection is return to TX
+    i = CMD_TIMEOUT_CNT;
     do {
-        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+        udelay(10);
+        i--;
+        phy_status = READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS);
     } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x1);
+    if (i == 0)
+        DPRINT("phy direction error: TX\n");
 }
 
 // ----------------------------------------------------------------------------
@@ -290,7 +359,8 @@ static void wait_cmd_fifo_empty(void)
     } while((((cmd_status >> BIT_GEN_CMD_EMPTY) & 0x1) != 0x1) && (i>0));
     print_mipi_cmd_status(i, cmd_status);
 }
-#ifdef MIPI_DSI_COMMAND_READ
+
+#if 0
 // ----------------------------------------------------------------------------
 // Function: wait_for_generic_read_response
 // Wait for generic read response
@@ -317,40 +387,6 @@ static unsigned int wait_for_generic_read_response(void)
     data_out = READ_LCD_REG( MIPI_DSI_DWC_GEN_PLD_DATA_OS );
     return data_out;
 }
-#endif
-// ----------------------------------------------------------------------------
-// Function: generic_if_wr
-// Generic interface write, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS and
-// MIPI_DSI_DWC_GEN_HDR_OS, MIPI_DSI_DWC_GEN_VCID_OS
-// ----------------------------------------------------------------------------
-static unsigned int generic_if_wr(unsigned int address, unsigned int data_in)
-{
-    if(address != MIPI_DSI_DWC_GEN_HDR_OS && address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
-        lcd_print(" Error Address : 0x%x\n", address);
-    }
-
-    lcd_print("address 0x%x = 0x%08x\n", address, data_in);
-    WRITE_LCD_REG(address, data_in);
-
-    return 0;
-}
-#ifdef MIPI_DSI_COMMAND_READ
-// ----------------------------------------------------------------------------
-//                           Function: generic_if_rd
-// Generic interface read, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS
-// ----------------------------------------------------------------------------
-static unsigned int generic_if_rd(unsigned int address)
-{
-    unsigned int data_out;
-
-    if(address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
-        lcd_print(" Error Address : %x\n", address);
-    }
-
-    data_out = READ_LCD_REG(address);
-
-    return data_out;
-}
 
 // ----------------------------------------------------------------------------
 //                           Function: generic_read_packet_0_para
@@ -374,40 +410,146 @@ static unsigned int generic_read_packet_0_para(unsigned char data_type, unsigned
     return read_data;
 }
 #endif
+
+static void dsi_set_max_return_pkt_size(DSI_Cmd_Request_t *req)
+{
+    unsigned int d_para[2];
+
+    d_para[0] = (unsigned int)(req->payload[2] & 0xff);
+    d_para[1] = (unsigned int)(req->payload[3] & 0xff);
+    dsi_rx_n = (unsigned short)((d_para[1] << 8) | d_para[0]);
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para[1] << BIT_GEN_WC_MSBYTE)      |
+                                            (d_para[0] << BIT_GEN_WC_LSBYTE)      |
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (DT_SET_MAX_RET_PKT_SIZE << BIT_GEN_DT)));
+    if( req->req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+        wait_bta_ack();
+    }
+    else if( req->req_ack == MIPI_DSI_DCS_NO_ACK ) {
+        wait_cmd_fifo_empty();
+    }
+}
+
+#ifdef DSI_CMD_READ_VALID
+static int dsi_generic_read_packet(DSI_Cmd_Request_t *req, unsigned char *r_data)
+{
+    unsigned int d_para[2], read_data;
+    unsigned int i,j,done;
+
+    switch (req->data_type) {
+        case DT_GEN_RD_1:
+            d_para[0] = (req->pld_count == 0) ? 0 : (((unsigned int)req->payload[2]) & 0xff);
+            d_para[1] = 0;
+            break;
+        case DT_GEN_RD_2:
+            d_para[0] = (req->pld_count == 0) ? 0 : (((unsigned int)req->payload[2]) & 0xff);
+            d_para[1] = (req->pld_count < 2) ? 0 : (((unsigned int)req->payload[3]) & 0xff);
+            break;
+        case DT_GEN_RD_0:
+        default:
+            d_para[0] = 0;
+            d_para[1] = 0;
+            break;
+    }
+
+    if (MIPI_DSI_DCS_ACK_TYPE == MIPI_DSI_DCS_NO_ACK)
+        dsi_bta_control(1);
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para[1] << BIT_GEN_WC_MSBYTE)      |
+                                            (d_para[0] << BIT_GEN_WC_LSBYTE)      |
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)req->data_type) << BIT_GEN_DT)));
+    wait_bta_ack();
+    i = 0;
+    done = 0;
+    while (done == 0) {
+        read_data = generic_if_rd(MIPI_DSI_DWC_GEN_PLD_DATA_OS);
+        for (j=0; j<4; j++) {
+            if (i < dsi_rx_n) {
+                r_data[i] = (unsigned char)((read_data >> (j*8)) & 0xff);
+                i++;
+            }
+            else {
+                done = 1;
+                break;
+            }
+        }
+    }
+    if (MIPI_DSI_DCS_ACK_TYPE == MIPI_DSI_DCS_NO_ACK)
+        dsi_bta_control(0);
+
+    return dsi_rx_n;
+}
+
+static int dsi_dcs_read_packet(DSI_Cmd_Request_t *req, unsigned char *r_data)
+{
+    unsigned int d_command, read_data;
+    unsigned int i,j,done;
+
+    d_command = ((unsigned int)req->payload[2]) & 0xff;
+
+    if (MIPI_DSI_DCS_ACK_TYPE == MIPI_DSI_DCS_NO_ACK)
+        dsi_bta_control(1);
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((0 << BIT_GEN_WC_MSBYTE)         |
+                                            (d_command << BIT_GEN_WC_LSBYTE)      |
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)req->data_type) << BIT_GEN_DT)));
+    wait_bta_ack();
+    i = 0;
+    done = 0;
+    while (done == 0) {
+        read_data = generic_if_rd(MIPI_DSI_DWC_GEN_PLD_DATA_OS);
+        for (j=0; j<4; j++) {
+            if (i < dsi_rx_n) {
+                r_data[i] = (unsigned char)((read_data >> (j*8)) & 0xff);
+                i++;
+            }
+            else {
+                done = 1;
+                break;
+            }
+        }
+    }
+
+    if (MIPI_DSI_DCS_ACK_TYPE == MIPI_DSI_DCS_NO_ACK)
+        dsi_bta_control(0);
+
+    return dsi_rx_n;
+}
+#endif
+
 // ----------------------------------------------------------------------------
 //                           Function: generic_write_short_packet
 // Generic Write Short Packet with Generic Interface
 // Supported Data Type: DT_GEN_SHORT_WR_0, DT_GEN_SHORT_WR_1, DT_GEN_SHORT_WR_2,
 // ----------------------------------------------------------------------------
-static void dsi_generic_write_short_packet(unsigned char data_type, unsigned char vc_id, unsigned char* payload, unsigned short pld_count, unsigned int req_ack)
+static void dsi_generic_write_short_packet(DSI_Cmd_Request_t *req)
 {
     unsigned int d_para[2];
 
-    vc_id &= 0x3;
-    switch (data_type) {
-        case DT_GEN_SHORT_WR_0:
-            d_para[0] = 0;
-            d_para[1] = 0;
-            break;
+    switch (req->data_type) {
         case DT_GEN_SHORT_WR_1:
-            d_para[0] = ((unsigned int)payload[1]) & 0xff;
+            d_para[0] = (req->pld_count == 0) ? 0 : (((unsigned int)req->payload[2]) & 0xff);
             d_para[1] = 0;
             break;
         case DT_GEN_SHORT_WR_2:
+            d_para[0] = (req->pld_count == 0) ? 0 : (((unsigned int)req->payload[2]) & 0xff);
+            d_para[1] = (req->pld_count < 2) ? 0 : (((unsigned int)req->payload[3]) & 0xff);
+            break;
+        case DT_GEN_SHORT_WR_0:
         default:
-            d_para[0] = ((unsigned int)payload[1]) & 0xff;
-            d_para[1] = (pld_count == 0) ? 0 : (((unsigned int)payload[3]) & 0xff);
+            d_para[0] = 0;
+            d_para[1] = 0;
             break;
     }
 
     generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para[1] << BIT_GEN_WC_MSBYTE)      |
                                             (d_para[0] << BIT_GEN_WC_LSBYTE)      |
-                                            (((unsigned int)vc_id) << BIT_GEN_VC) |
-                                            (((unsigned int)data_type) << BIT_GEN_DT)));
-    if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)req->data_type) << BIT_GEN_DT)));
+    if( req->req_ack == MIPI_DSI_DCS_REQ_ACK ) {
         wait_bta_ack();
     }
-    else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
+    else if( req->req_ack == MIPI_DSI_DCS_NO_ACK ) {
         wait_cmd_fifo_empty();
     }
 }
@@ -417,22 +559,21 @@ static void dsi_generic_write_short_packet(unsigned char data_type, unsigned cha
 // DCS Write Short Packet with Generic Interface
 // Supported Data Type: DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
 // ----------------------------------------------------------------------------
-static void dsi_dcs_write_short_packet(unsigned char data_type, unsigned char vc_id, unsigned char* payload, unsigned short pld_count, unsigned int req_ack)
+static void dsi_dcs_write_short_packet(DSI_Cmd_Request_t *req)
 {
     unsigned int d_command, d_para;
 
-    vc_id &= 0x3;
-    d_command = ((unsigned int)payload[1]) & 0xff;
-    d_para = (pld_count == 0) ? 0 : (((unsigned int)payload[3]) & 0xff);
+    d_command = ((unsigned int)req->payload[2]) & 0xff;
+    d_para = (req->pld_count < 2) ? 0 : (((unsigned int)req->payload[3]) & 0xff);
 
     generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para << BIT_GEN_WC_MSBYTE)         |
                                             (d_command << BIT_GEN_WC_LSBYTE)      |
-                                            (((unsigned int)vc_id) << BIT_GEN_VC) |
-                                            (((unsigned int)data_type) << BIT_GEN_DT)));
-    if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)req->data_type) << BIT_GEN_DT)));
+    if( req->req_ack == MIPI_DSI_DCS_REQ_ACK ) {
         wait_bta_ack();
     }
-    else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
+    else if( req->req_ack == MIPI_DSI_DCS_NO_ACK ) {
         wait_cmd_fifo_empty();
     }
 }
@@ -442,42 +583,42 @@ static void dsi_dcs_write_short_packet(unsigned char data_type, unsigned char vc
 // Write Long Packet with Generic Interface
 // Supported Data Type: DT_GEN_LONG_WR, DT_DCS_LONG_WR
 // ----------------------------------------------------------------------------
-static void dsi_write_long_packet(unsigned char data_type, unsigned char vc_id, unsigned char* payload, unsigned short pld_count, unsigned int req_ack)
+static void dsi_write_long_packet(DSI_Cmd_Request_t *req)
 {
-    unsigned int d_command, payload_data=0, header_data;
+    unsigned int d_command, payload_data, header_data;
     unsigned int cmd_status;
-    unsigned int i, d_start_index;
-    int j;
+    unsigned int i, j, data_index, n, temp;
 
-    vc_id &= 0x3;
-    d_command = ((unsigned int)payload[1]) & 0xff;
-    pld_count = (pld_count + 1) & 0xffff;//include command
-    d_start_index = 3;//payload[3] start (payload[0]: data_type, payload[1]: command, payload[2]: para_num)
+    data_index = DSI_CMD_CNT_INDEX + 1;//payload[2] start (payload[0]: data_type, payload[1]: data_cnt)
+    d_command = ((unsigned int)req->payload[data_index]) & 0xff;
 
     // Write Payload Register First
-    payload_data = d_command;
-    for(i=1; i<pld_count; i++) {
-        if(i%4 == 0)
-            payload_data = 0;
-        payload_data |= (((unsigned int)payload[i-1+d_start_index]) << 8*(i%4));
-
-        if((i%4 == 3) || (i == (pld_count-1))) {  // when last byte  //write max 4 byte payload data once
-            // Check the pld fifo status before write to it, do not need check every word
-            if((i == (pld_count/3)) || (i == (pld_count/2))) {
-                j = CMD_TIMEOUT_CNT;
-                do {
-                    udelay(10);
-                    j--;
-                    cmd_status = READ_LCD_REG(MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
-                } while((((cmd_status >> BIT_GEN_PLD_W_FULL) & 0x1) == 0x1) && (j>0));
-                print_mipi_cmd_status(j, cmd_status);
-            }
-            if(d_command == DCS_WRITE_MEMORY_CONTINUE) { // Use direct memory write to save time when in WRITE_MEMORY_CONTINUE
-                WRITE_LCD_REG(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
-            }
-            else {
-                generic_if_wr(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
-            }
+    n = (req->pld_count+3)/4;
+    for(i=0; i<n; i++) {
+        payload_data = 0;
+        if (i < (req->pld_count/4))
+            temp = 4;
+        else
+            temp = req->pld_count % 4;
+        for (j=0; j<temp; j++) {
+            payload_data |= (((unsigned int)req->payload[data_index+(i*4)+j]) << (j*8));
+        }
+
+        // Check the pld fifo status before write to it, do not need check every word
+        if((i == (n/3)) || (i == (n/2))) {
+            j = CMD_TIMEOUT_CNT;
+            do {
+                udelay(10);
+                j--;
+                cmd_status = READ_LCD_REG(MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
+            } while((((cmd_status >> BIT_GEN_PLD_W_FULL) & 0x1) == 0x1) && (j>0));
+            print_mipi_cmd_status(j, cmd_status);
+        }
+        if(d_command == DCS_WRITE_MEMORY_CONTINUE) { // Use direct memory write to save time when in WRITE_MEMORY_CONTINUE
+            WRITE_LCD_REG(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
+        }
+        else {
+            generic_if_wr(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
         }
     }
 
@@ -490,38 +631,42 @@ static void dsi_write_long_packet(unsigned char data_type, unsigned char vc_id,
     } while((((cmd_status >> BIT_GEN_CMD_FULL) & 0x1) == 0x1) && (j>0));
     print_mipi_cmd_status(j, cmd_status);
     // Write Header Register
-    header_data = ( (((unsigned int)pld_count) << BIT_GEN_WC_LSBYTE) |//include command
-                    (((unsigned int)vc_id) << BIT_GEN_VC)                |
-                    (((unsigned int)data_type) << BIT_GEN_DT));
+    header_data = ( (((unsigned int)req->pld_count) << BIT_GEN_WC_LSBYTE) |//include command
+                    (((unsigned int)req->vc_id) << BIT_GEN_VC)                |
+                    (((unsigned int)req->data_type) << BIT_GEN_DT));
     generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, header_data);
-    if (req_ack == MIPI_DSI_DCS_REQ_ACK) {
+    if (req->req_ack == MIPI_DSI_DCS_REQ_ACK) {
         wait_bta_ack();
     }
-    else if (req_ack == MIPI_DSI_DCS_NO_ACK) {
+    else if (req->req_ack == MIPI_DSI_DCS_NO_ACK) {
         wait_cmd_fifo_empty();
     }
 }
 
 // ----------------------------------------------------------------------------
 //                           Function: dsi_write_cmd
-// Generic Write Command
 // Supported Data Type: DT_GEN_SHORT_WR_0, DT_GEN_SHORT_WR_1, DT_GEN_SHORT_WR_2,
 //                      DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
 //                      DT_GEN_LONG_WR, DT_DCS_LONG_WR,
-//                      DT_SET_MAX_RPS
+//                      DT_SET_MAX_RET_PKT_SIZE
+//                      DT_GEN_RD_0, DT_GEN_RD_1, DT_GEN_RD_2,
+//                      DT_DCS_RD_0
 // Return:              command number
 // ----------------------------------------------------------------------------
 int dsi_write_cmd(unsigned char* payload)
 {
-    int i=0, j=0;
-    int num = 0;
+    int i=0, j=0, num=0;
+#ifdef DSI_CMD_READ_VALID
+    int k=0, n=0;
+    unsigned char rd_data[100];
+#endif
+    DSI_Cmd_Request_t dsi_cmd_req;
     unsigned char vc_id = MIPI_DSI_VIRTUAL_CHAN_ID;
     unsigned int req_ack = MIPI_DSI_DCS_ACK_TYPE;
 
-    //payload struct:
-    //data_type, command, para_num, parameters...
-    //data_type=0xff, command=0xff, means ending flag
-    //data_type=0xff, command<0xff, means delay time(unit ms)
+    //mipi command(payload)
+    //format:  data_type, num, data....
+    //special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
     while(i < DSI_CMD_SIZE_MAX) {
         if(payload[i]==0xff) {
             j = 2;
@@ -535,23 +680,25 @@ int dsi_write_cmd(unsigned char* payload)
             break;
         }
         else {
-            j = 3 + payload[i+2]; //payload[i+2] is parameter num
-            switch (payload[i]) {//analysis data_type
+            j = (DSI_CMD_CNT_INDEX + 1) + payload[i+DSI_CMD_CNT_INDEX]; //payload[i+DSI_CMD_CNT_INDEX] is data count
+            dsi_cmd_req.data_type = payload[i];
+            dsi_cmd_req.vc_id = (vc_id & 0x3);
+            dsi_cmd_req.payload = &payload[i];
+            dsi_cmd_req.pld_count = payload[i+DSI_CMD_CNT_INDEX];
+            dsi_cmd_req.req_ack = req_ack;
+            switch (dsi_cmd_req.data_type) {//analysis data_type
                 case DT_GEN_SHORT_WR_0:
                 case DT_GEN_SHORT_WR_1:
                 case DT_GEN_SHORT_WR_2:
-                    dsi_generic_write_short_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
+                    dsi_generic_write_short_packet(&dsi_cmd_req);
                     break;
                 case DT_DCS_SHORT_WR_0:
                 case DT_DCS_SHORT_WR_1:
-                    dsi_dcs_write_short_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
+                    dsi_dcs_write_short_packet(&dsi_cmd_req);
                     break;
                 case DT_DCS_LONG_WR:
                 case DT_GEN_LONG_WR:
-                    dsi_write_long_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
-                    break;
-                case DT_SET_MAX_RPS:
-                    DPRINT("to do data_type: 0x%2x\n", payload[i]);
+                    dsi_write_long_packet(&dsi_cmd_req);
                     break;
                 case DT_TURN_ON:
                     WRITE_LCD_REG_BITS(MIPI_DSI_TOP_CNTL, 1, 2, 1);
@@ -563,8 +710,38 @@ int dsi_write_cmd(unsigned char* payload)
                     WRITE_LCD_REG_BITS(MIPI_DSI_TOP_CNTL, 1, 2, 1);
                     mdelay(20); //wait for vsync trigger
                     break;
+                case DT_SET_MAX_RET_PKT_SIZE:
+                    dsi_set_max_return_pkt_size(&dsi_cmd_req);
+                    break;
+#ifdef DSI_CMD_READ_VALID
+                case DT_GEN_RD_0:
+                case DT_GEN_RD_1:
+                case DT_GEN_RD_2:
+                    dsi_cmd_req.req_ack = MIPI_DSI_DCS_REQ_ACK; //need BTA ack
+                    dsi_cmd_req.pld_count = (dsi_cmd_req.pld_count > 2) ? 2 : dsi_cmd_req.pld_count;
+                    n = dsi_generic_read_packet(&dsi_cmd_req, &rd_data[0]);
+                    DPRINT("generic read data");
+                    for (k=0; k<dsi_cmd_req.pld_count; k++) {
+                        DPRINT(" 0x%02x", dsi_cmd_req.payload[k+2]);
+                    }
+                    DPRINT(":\n");
+                    for (k=0; k<n; k++) {
+                        DPRINT("0x%02x ", rd_data[k]);
+                    }
+                    DPRINT("\n");
+                    break;
+                case DT_DCS_RD_0:
+                    dsi_cmd_req.req_ack = MIPI_DSI_DCS_REQ_ACK; //need BTA ack
+                    n = dsi_dcs_read_packet(&dsi_cmd_req, &rd_data[0]);
+                    DPRINT("dcs read data 0x%02x:\n", dsi_cmd_req.payload[2]);
+                    for (k=0; k<n; k++) {
+                        DPRINT("0x%02x ", rd_data[k]);
+                    }
+                    DPRINT("\n");
+                    break;
+#endif
                 default:
-                    DPRINT("un-support data_type: 0x%02x\n", payload[i]);
+                    DPRINT("[warning]dsi un-support data_type: 0x%02x\n", dsi_cmd_req.data_type);
                     break;
             }
         }
@@ -575,6 +752,59 @@ int dsi_write_cmd(unsigned char* payload)
     return num;
 }
 
+#ifdef DSI_CMD_READ_VALID
+// ----------------------------------------------------------------------------
+//                           Function: dsi_read_single
+// Supported Data Type: DT_GEN_RD_0, DT_GEN_RD_1, DT_GEN_RD_2,
+//                      DT_DCS_RD_0
+// Return:              data count
+// ----------------------------------------------------------------------------
+int dsi_read_single(unsigned char* payload, unsigned char *rd_data, unsigned int rd_byte_len)
+{
+    int num = 0;
+    unsigned char temp[4];
+    unsigned char vc_id = MIPI_DSI_VIRTUAL_CHAN_ID;
+    unsigned int req_ack;
+    DSI_Cmd_Request_t dsi_cmd_req;
+
+    req_ack = MIPI_DSI_DCS_ACK_TYPE;
+    dsi_cmd_req.data_type = DT_SET_MAX_RET_PKT_SIZE;
+    dsi_cmd_req.vc_id = (vc_id & 0x3);
+    temp[0] = dsi_cmd_req.data_type;
+    temp[1] = 2;
+    temp[2] = (unsigned char)((rd_byte_len >> 0) & 0xff);
+    temp[3] = (unsigned char)((rd_byte_len >> 8) & 0xff);
+    dsi_cmd_req.payload = &temp[0];
+    dsi_cmd_req.pld_count = 2;
+    dsi_cmd_req.req_ack = req_ack;
+    dsi_set_max_return_pkt_size(&dsi_cmd_req);
+
+    //payload struct:
+    //data_type, data_cnt, command, parameters...
+    req_ack = MIPI_DSI_DCS_REQ_ACK; //need BTA ack
+    dsi_cmd_req.data_type = payload[0];
+    dsi_cmd_req.vc_id = (vc_id & 0x3);
+    dsi_cmd_req.payload = &payload[0];
+    dsi_cmd_req.pld_count = payload[DSI_CMD_CNT_INDEX];
+    dsi_cmd_req.req_ack = req_ack;
+    switch (dsi_cmd_req.data_type) {//analysis data_type
+        case DT_GEN_RD_0:
+        case DT_GEN_RD_1:
+        case DT_GEN_RD_2:
+            num = dsi_generic_read_packet(&dsi_cmd_req, rd_data);
+            break;
+        case DT_DCS_RD_0:
+            num = dsi_dcs_read_packet(&dsi_cmd_req, rd_data);
+            break;
+        default:
+            DPRINT("dsi read un-support data_type: 0x%02x\n", dsi_cmd_req.data_type);
+            break;
+    }
+
+    return num;
+}
+#endif
+
 static void set_dsi_phy_config(DSI_Phy_t *dphy, unsigned dsi_ui)
 {
     unsigned t_lane_byte, t_ui;
@@ -865,12 +1095,12 @@ static void set_mipi_dsi_host(unsigned int vcid, unsigned int chroma_subsample,
 
     // Inner clock divider settings
     WRITE_LCD_REG( MIPI_DSI_DWC_CLKMGR_CFG_OS, (0x1 << BIT_TO_CLK_DIV) | (dsi_phy_config.lp_tesc << BIT_TX_ESC_CLK_DIV) );
-    // Packet header settings
-    WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
-                        (1 << BIT_ECC_RX_EN) |
-                        (0 << BIT_BTA_EN) |
-                        (0 << BIT_EOTP_RX_EN) |
-                        (0 << BIT_EOTP_TX_EN) );
+    // Packet header settings  //move to set_mipi_dcs
+    //WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
+    //                    (1 << BIT_ECC_RX_EN) |
+    //                    (0 << BIT_BTA_EN) |
+    //                    (0 << BIT_EOTP_RX_EN) |
+    //                    (0 << BIT_EOTP_TX_EN) );
     // operation mode setting: video/command mode
     WRITE_LCD_REG( MIPI_DSI_DWC_MODE_CFG_OS, operation_mode );
 
@@ -1123,6 +1353,9 @@ static const char * dsi_usage_str =
 "    echo write <addr> <value> > dsi ; write dsi phy reg with value\n"
 "    echo info > dsi ; print dsi config information\n"
 "    echo dphy > dsi ; print dsi phy timing information\n"
+"    echo cmd <data_type> <data_num> <data_1> <data_2> ... > dsi ; write single dsi command\n"
+"        <data_num>: decimal number\n"
+"        <data_n>:   variable length, total length must equal to <data_num>. no need '0xff,0xff' ending flag"
 };
 
 static ssize_t dsi_debug_help(struct class *class, struct class_attribute *attr, char *buf)
@@ -1133,7 +1366,8 @@ static ssize_t dsi_debug_help(struct class *class, struct class_attribute *attr,
 static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
 {
     unsigned int ret;
-    unsigned t[3];
+    unsigned t[4];
+    unsigned char cmd[6];
     unsigned num = 0;
     int i;
 
@@ -1160,6 +1394,20 @@ static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, cons
         case 'd':
             print_dphy_info();
             break;
+        case 'c':
+            t[0] = 0xff;
+            t[1] = 0xff;
+            t[2] = 0;
+            t[3] = 0;
+            ret = sscanf(buf, "cmd %x %d %x %x", &t[0], &t[1], &t[2], &t[3]);
+            cmd[0] = (unsigned char)(t[0] & 0xff);
+            cmd[1] = (unsigned char)(t[1] & 0xff);
+            cmd[2] = (unsigned char)(t[2] & 0xff);
+            cmd[3] = (unsigned char)(t[3] & 0xff);
+            cmd[4] = 0xff;
+            cmd[5] = 0xff;
+            dsi_write_cmd(&cmd[0]);
+            break;
         default:
             DPRINT("wrong format of dsi debug command.\n");
             break;
diff --git a/arch/arm/mach-meson8/lcd/mipi_dsi_util.h b/arch/arm/mach-meson8/lcd/mipi_dsi_util.h
index 78c236dfe500..f7b01f7067ee 100755
--- a/arch/arm/mach-meson8/lcd/mipi_dsi_util.h
+++ b/arch/arm/mach-meson8/lcd/mipi_dsi_util.h
@@ -7,40 +7,42 @@
 // --------------------------------------------------------
 // MIPI DSI Data Type/ MIPI DCS Command Type Definitions
 // --------------------------------------------------------
-typedef enum {DT_VSS                 = 0x01,
-        DT_VSE                 = 0x11,
-        DT_HSS                 = 0x21,
-        DT_HSE                 = 0x31,
-        DT_EOTP                = 0x08,
-        DT_CMOFF               = 0x02,
-        DT_CMON                = 0x12,
-        DT_SHUT_DOWN           = 0x22,
-        DT_TURN_ON             = 0x32,
-        DT_GEN_SHORT_WR_0      = 0x03,
-        DT_GEN_SHORT_WR_1      = 0x13,
-        DT_GEN_SHORT_WR_2      = 0x23,
-        DT_GEN_RD_0            = 0x04,
-        DT_GEN_RD_1            = 0x14,
-        DT_GEN_RD_2            = 0x24,
-        DT_DCS_SHORT_WR_0      = 0x05,
-        DT_DCS_SHORT_WR_1      = 0x15,
-        DT_DCS_RD_0            = 0x06,
-        DT_SET_MAX_RPS         = 0x37,
-        DT_NULL_PKT            = 0x09,
-        DT_BLANK_PKT           = 0x19,
-        DT_GEN_LONG_WR         = 0x29,
-        DT_DCS_LONG_WR         = 0x39,
-        DT_20BIT_LOOSE_YCBCR   = 0x0c,
-        DT_24BIT_YCBCR         = 0x1c,
-        DT_16BIT_YCBCR         = 0x2c,
-        DT_30BIT_RGB_101010    = 0x0d,
-        DT_36BIT_RGB_121212    = 0x1d,
-        DT_12BIT_YCBCR         = 0x3d,
-        DT_16BIT_RGB_565       = 0x0e,
-        DT_18BIT_RGB_666       = 0x1e,
-        DT_18BIT_LOOSE_RGB_666 = 0x2e,
-        DT_24BIT_RGB_888       = 0x3e
-} mipi_dsi_data_type_t;
+//Pheripheral to Host
+typedef enum {
+	DT_VSS                  = 0x01,
+	DT_VSE                  = 0x11,
+	DT_HSS                  = 0x21,
+	DT_HSE                  = 0x31,
+	DT_EOTP                 = 0x08,
+	DT_CMOFF                = 0x02,
+	DT_CMON                 = 0x12,
+	DT_SHUT_DOWN            = 0x22,
+	DT_TURN_ON              = 0x32,
+	DT_GEN_SHORT_WR_0       = 0x03,
+	DT_GEN_SHORT_WR_1       = 0x13,
+	DT_GEN_SHORT_WR_2       = 0x23,
+	DT_GEN_RD_0             = 0x04,
+	DT_GEN_RD_1             = 0x14,
+	DT_GEN_RD_2             = 0x24,
+	DT_DCS_SHORT_WR_0       = 0x05,
+	DT_DCS_SHORT_WR_1       = 0x15,
+	DT_DCS_RD_0             = 0x06,
+	DT_SET_MAX_RET_PKT_SIZE = 0x37,
+	DT_NULL_PKT             = 0x09,
+	DT_BLANK_PKT            = 0x19,
+	DT_GEN_LONG_WR          = 0x29,
+	DT_DCS_LONG_WR          = 0x39,
+	DT_20BIT_LOOSE_YCBCR    = 0x0c,
+	DT_24BIT_YCBCR          = 0x1c,
+	DT_16BIT_YCBCR          = 0x2c,
+	DT_30BIT_RGB_101010     = 0x0d,
+	DT_36BIT_RGB_121212     = 0x1d,
+	DT_12BIT_YCBCR          = 0x3d,
+	DT_16BIT_RGB_565        = 0x0e,
+	DT_18BIT_RGB_666        = 0x1e,
+	DT_18BIT_LOOSE_RGB_666  = 0x2e,
+	DT_24BIT_RGB_888        = 0x3e
+} mipi_dsi_data_type_host_t;
 
 // DCS Command List
 #define DCS_ENTER_IDLE_MODE          0x39
@@ -88,6 +90,32 @@ typedef enum {DT_VSS                 = 0x01,
 #define DCS_WRITE_MEMORY_CONTINUE    0x3c
 #define DCS_WRITE_MEMORY_START       0x2c
 
+//Pheripheral to Host
+//normal: 0x87(LPDT), data_type, 0, 0, ecc.  //write or tearing-effect
+//error:  0x87(LPDT), 0x02, error_code[15:0], ecc.
+//short read: 0x87, data_type, data0, data1, ecc
+//long read:  0x87, data_type, word_cnt[15:0], ecc, data0, ... data(N-1), checksum(or 0)[15:0].
+typedef enum {
+	DT_RESP_TE             = 0xba,
+	DT_RESP_ACK            = 0x84,
+	DT_RESP_ACK_ERR        = 0x02,
+	DT_RESP_EOT            = 0x08,
+	DT_RESP_GEN_READ_1     = 0x11,
+	DT_RESP_GEN_READ_2     = 0x12,
+	DT_RESP_GEN_READ_LONG  = 0x1a,
+	DT_RESP_DCS_READ_LONG  = 0x1c,
+	DT_RESP_DCS_READ_1     = 0x21,
+	DT_RESP_DCS_READ_2     = 0x22,
+} mipi_dsi_data_type_peripheral_t;
+
+typedef struct {
+    unsigned char data_type;
+    unsigned char vc_id;
+    unsigned char *payload;
+    unsigned short pld_count;
+    unsigned int req_ack;
+} DSI_Cmd_Request_t;
+
 // --------------------------------------------------------
 // MIPI DCS Pixel-to-Byte Format
 // --------------------------------------------------------
@@ -433,6 +461,7 @@ typedef struct DSI_Vid_s{
 }DSI_Vid_t;
 
 #define DSI_CMD_SIZE_MAX		2000
+//#define DSI_CMD_READ_VALID   //DPHY don't support
 
 extern void set_mipi_dsi_control_config(Lcd_Config_t *pConf);
 extern void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf);
diff --git a/arch/arm/mach-meson8b/include/mach/lcdoutc.h b/arch/arm/mach-meson8b/include/mach/lcdoutc.h
index a586f3a0eabe..16a98a1eaa19 100755
--- a/arch/arm/mach-meson8b/include/mach/lcdoutc.h
+++ b/arch/arm/mach-meson8b/include/mach/lcdoutc.h
@@ -12,13 +12,22 @@
 //*************************************************************
 // For mipi-dsi external driver use
 //*************************************************************
-//payload struct:
-//data_type, command, para_num, parameters...
-//data_type=0xff, command=0xff, means ending flag
-//data_type=0xff, command<0xff, means delay time(unit ms)
-//return:
-//command num
+//mipi command(payload)
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+
+// ----------------------------------------------------------------------------
+//                           Function: dsi_write_cmd
+// Supported Data Type: DT_GEN_SHORT_WR_0, DT_GEN_SHORT_WR_1, DT_GEN_SHORT_WR_2,
+//                      DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
+//                      DT_GEN_LONG_WR, DT_DCS_LONG_WR,
+//                      DT_SET_MAX_RET_PKT_SIZE
+//                      DT_GEN_RD_0, DT_GEN_RD_1, DT_GEN_RD_2,
+//                      DT_DCS_RD_0
+// Return:              command number
+// ----------------------------------------------------------------------------
 extern int dsi_write_cmd(unsigned char* payload);
+
 //*************************************************************
 
 #endif
diff --git a/arch/arm/mach-meson8b/lcd/lcd_config.h b/arch/arm/mach-meson8b/lcd/lcd_config.h
index 574f0905693a..7727956b80d6 100755
--- a/arch/arm/mach-meson8b/lcd/lcd_config.h
+++ b/arch/arm/mach-meson8b/lcd/lcd_config.h
@@ -7,7 +7,7 @@
 //lcd driver version
 //**********************************
 #define LCD_DRV_TYPE      "c8b"
-#define LCD_DRV_DATE      "20141113"
+#define LCD_DRV_DATE      "20141223"
 //**********************************
 
 /* for GAMMA_CNTL_PORT */
diff --git a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
index 4bc890ea506f..689f7b0d962f 100755
--- a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
+++ b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
@@ -16,7 +16,7 @@
 #include "mipi_dsi_util.h"
 
 #define DPRINT(...)		printk(__VA_ARGS__)
-//#define MIPI_DSI_COMMAND_READ
+
 //===============================================================================
 // Define MIPI DSI Default config
 //===============================================================================
@@ -53,12 +53,13 @@ static DSI_Phy_t dsi_phy_config;
 static DSI_Vid_t dsi_vid_config;
 static DSI_Config_t *dsi_config = NULL;
 static unsigned char dsi_init_on_table_dft[] = {
-    0x05,0x11,0,
+    0x05,1,0x11,
     0xff,50,
-    0x05,0x29,0,
+    0x05,1,0x29,
     0xff,20,
     0xff,0xff,
 };
+static unsigned short dsi_rx_n = 0;
 
 static inline void print_mipi_cmd_status(int cnt, unsigned status)
 {
@@ -125,10 +126,10 @@ static void print_info(void)
                 break;
             }
             else {
-                n = 3 + dsi_config->dsi_init_on[i+2];
+                n = (DSI_CMD_CNT_INDEX + 1) + dsi_config->dsi_init_on[i+DSI_CMD_CNT_INDEX];
                 DPRINT("    ");
                 for (j=0; j<n; j++) {
-                    if (j == 2)
+                    if (j == DSI_CMD_CNT_INDEX)
                         DPRINT("%d,", dsi_config->dsi_init_on[i+j]);
                     else
                         DPRINT("0x%02x,", dsi_config->dsi_init_on[i+j]);
@@ -157,10 +158,10 @@ static void print_info(void)
                 break;
             }
             else {
-                n = 3 + dsi_config->dsi_init_off[i+2];
+                n = (DSI_CMD_CNT_INDEX + 1) + dsi_config->dsi_init_off[i+DSI_CMD_CNT_INDEX];
                 DPRINT("    ");
                 for (j=0; j<n; j++) {
-                    if (j == 2)
+                    if (j == DSI_CMD_CNT_INDEX)
                         DPRINT("%d,", dsi_config->dsi_init_off[i+j]);
                     else
                         DPRINT("0x%02x,", dsi_config->dsi_init_off[i+j]);
@@ -224,10 +225,11 @@ static void check_phy_status(void)
 // -----------------------------------------------------------------------------
 //                     Function: set_mipi_dcs
 // Configure relative registers in command mode
+// Parameters:           int trans_type,       // 0: high speed, 1: low power
+//                       int req_ack,          // 1: request ack, 0: do not need ack
+//                       int tear_en           // 1: enable tear ack, 0: disable tear ack
 // -----------------------------------------------------------------------------
-static void set_mipi_dcs(int trans_type,        // 0: high speed, 1: low power
-                         int req_ack,           // 1: request ack, 0: do not need ack
-                         int tear_en)           // 1: enable tear ack, 0: disable tear ack
+static void set_mipi_dcs(int trans_type, int req_ack, int tear_en)
 {
     WRITE_LCD_REG( MIPI_DSI_DWC_CMD_MODE_CFG_OS, (trans_type << BIT_MAX_RD_PKT_SIZE) | (trans_type << BIT_DCS_LW_TX)    |
                     (trans_type << BIT_DCS_SR_0P_TX)    | (trans_type << BIT_DCS_SW_1P_TX) |
@@ -243,7 +245,15 @@ static void set_mipi_dcs(int trans_type,        // 0: high speed, 1: low power
         // Enable Measure Vsync
         WRITE_LCD_REG( MIPI_DSI_TOP_MEAS_CNTL, (READ_LCD_REG(MIPI_DSI_TOP_MEAS_CNTL) | (0x1<<BIT_VSYNC_MEAS_EN | (0x1<<BIT_TE_MEAS_EN))));
     }
+
+    // Packet header settings
+    WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
+                        (1 << BIT_ECC_RX_EN)  |
+                        (0 << BIT_BTA_EN)     |
+                        (0 << BIT_EOTP_RX_EN) |
+                        (0 << BIT_EOTP_TX_EN) );
 }
+
 #if 0
 // -----------------------------------------------------------------------------
 //                     Function: set_mipi_int
@@ -255,23 +265,82 @@ static void set_mipi_int(void)
     WRITE_LCD_REG( MIPI_DSI_DWC_INT_MSK1_OS, 0);
 }
 #endif
+
+#ifdef DSI_CMD_READ_VALID
+static void dsi_bta_control(int en)
+{
+    if (en) {
+        WRITE_LCD_REG_BITS(MIPI_DSI_DWC_CMD_MODE_CFG_OS, MIPI_DSI_DCS_REQ_ACK, BIT_ACK_RQST_EN, 1);
+        WRITE_LCD_REG_BITS(MIPI_DSI_DWC_PCKHDL_CFG_OS, MIPI_DSI_DCS_REQ_ACK, BIT_BTA_EN, 1);
+    }
+    else {
+        WRITE_LCD_REG_BITS(MIPI_DSI_DWC_PCKHDL_CFG_OS, MIPI_DSI_DCS_NO_ACK, BIT_BTA_EN, 1);
+        WRITE_LCD_REG_BITS(MIPI_DSI_DWC_CMD_MODE_CFG_OS, MIPI_DSI_DCS_NO_ACK, BIT_ACK_RQST_EN, 1);
+    }
+}
+
+// ----------------------------------------------------------------------------
+//                           Function: generic_if_rd
+// Generic interface read, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS
+// ----------------------------------------------------------------------------
+static unsigned int generic_if_rd(unsigned int address)
+{
+    unsigned int data_out;
+
+    if(address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
+        DPRINT(" Error Address : %x\n", address);
+    }
+
+    data_out = READ_LCD_REG(address);
+
+    return data_out;
+}
+#endif
+
+// ----------------------------------------------------------------------------
+// Function: generic_if_wr
+// Generic interface write, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS and
+// MIPI_DSI_DWC_GEN_HDR_OS, MIPI_DSI_DWC_GEN_VCID_OS
+// ----------------------------------------------------------------------------
+static unsigned int generic_if_wr(unsigned int address, unsigned int data_in)
+{
+    if(address != MIPI_DSI_DWC_GEN_HDR_OS && address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
+        DPRINT(" Error Address : 0x%x\n", address);
+    }
+
+    lcd_print("address 0x%x = 0x%08x\n", address, data_in);
+    WRITE_LCD_REG(address, data_in);
+
+    return 0;
+}
+
 // ----------------------------------------------------------------------------
 // Function: wait_bta_ack
 // Poll to check if the BTA ack is finished
 // ----------------------------------------------------------------------------
 static void wait_bta_ack(void)
 {
-    unsigned int phy_status;
+    unsigned int phy_status, i;
 
     // Check if phydirection is RX
+    i = CMD_TIMEOUT_CNT;
     do {
-        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
-    } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x0);
+        udelay(10);
+        i--;
+        phy_status = READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS);
+    } while((((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x0) && (i>0));
+    if (i == 0)
+        DPRINT("phy direction error: RX\n");
 
     // Check if phydirection is return to TX
+    i = CMD_TIMEOUT_CNT;
     do {
-        phy_status = READ_LCD_REG( MIPI_DSI_DWC_PHY_STATUS_OS );
+        udelay(10);
+        i--;
+        phy_status = READ_LCD_REG(MIPI_DSI_DWC_PHY_STATUS_OS);
     } while(((phy_status & 0x2) >> BIT_PHY_DIRECTION) == 0x1);
+    if (i == 0)
+        DPRINT("phy direction error: TX\n");
 }
 
 // ----------------------------------------------------------------------------
@@ -290,7 +359,8 @@ static void wait_cmd_fifo_empty(void)
     } while((((cmd_status >> BIT_GEN_CMD_EMPTY) & 0x1) != 0x1) && (i>0));
     print_mipi_cmd_status(i, cmd_status);
 }
-#ifdef MIPI_DSI_COMMAND_READ
+
+#if 0
 // ----------------------------------------------------------------------------
 // Function: wait_for_generic_read_response
 // Wait for generic read response
@@ -317,40 +387,6 @@ static unsigned int wait_for_generic_read_response(void)
     data_out = READ_LCD_REG( MIPI_DSI_DWC_GEN_PLD_DATA_OS );
     return data_out;
 }
-#endif
-// ----------------------------------------------------------------------------
-// Function: generic_if_wr
-// Generic interface write, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS and
-// MIPI_DSI_DWC_GEN_HDR_OS, MIPI_DSI_DWC_GEN_VCID_OS
-// ----------------------------------------------------------------------------
-static unsigned int generic_if_wr(unsigned int address, unsigned int data_in)
-{
-    if(address != MIPI_DSI_DWC_GEN_HDR_OS && address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
-        lcd_print(" Error Address : 0x%x\n", address);
-    }
-
-    lcd_print("address 0x%x = 0x%08x\n", address, data_in);
-    WRITE_LCD_REG(address, data_in);
-
-    return 0;
-}
-#ifdef MIPI_DSI_COMMAND_READ
-// ----------------------------------------------------------------------------
-//                           Function: generic_if_rd
-// Generic interface read, address has to be MIPI_DSI_DWC_GEN_PLD_DATA_OS
-// ----------------------------------------------------------------------------
-static unsigned int generic_if_rd(unsigned int address)
-{
-    unsigned int data_out;
-
-    if(address != MIPI_DSI_DWC_GEN_PLD_DATA_OS) {
-        lcd_print(" Error Address : %x\n", address);
-    }
-
-    data_out = READ_LCD_REG(address);
-
-    return data_out;
-}
 
 // ----------------------------------------------------------------------------
 //                           Function: generic_read_packet_0_para
@@ -374,40 +410,146 @@ static unsigned int generic_read_packet_0_para(unsigned char data_type, unsigned
     return read_data;
 }
 #endif
+
+static void dsi_set_max_return_pkt_size(DSI_Cmd_Request_t *req)
+{
+    unsigned int d_para[2];
+
+    d_para[0] = (unsigned int)(req->payload[2] & 0xff);
+    d_para[1] = (unsigned int)(req->payload[3] & 0xff);
+    dsi_rx_n = (unsigned short)((d_para[1] << 8) | d_para[0]);
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para[1] << BIT_GEN_WC_MSBYTE)      |
+                                            (d_para[0] << BIT_GEN_WC_LSBYTE)      |
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (DT_SET_MAX_RET_PKT_SIZE << BIT_GEN_DT)));
+    if( req->req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+        wait_bta_ack();
+    }
+    else if( req->req_ack == MIPI_DSI_DCS_NO_ACK ) {
+        wait_cmd_fifo_empty();
+    }
+}
+
+#ifdef DSI_CMD_READ_VALID
+static int dsi_generic_read_packet(DSI_Cmd_Request_t *req, unsigned char *r_data)
+{
+    unsigned int d_para[2], read_data;
+    unsigned int i,j,done;
+
+    switch (req->data_type) {
+        case DT_GEN_RD_1:
+            d_para[0] = (req->pld_count == 0) ? 0 : (((unsigned int)req->payload[2]) & 0xff);
+            d_para[1] = 0;
+            break;
+        case DT_GEN_RD_2:
+            d_para[0] = (req->pld_count == 0) ? 0 : (((unsigned int)req->payload[2]) & 0xff);
+            d_para[1] = (req->pld_count < 2) ? 0 : (((unsigned int)req->payload[3]) & 0xff);
+            break;
+        case DT_GEN_RD_0:
+        default:
+            d_para[0] = 0;
+            d_para[1] = 0;
+            break;
+    }
+
+    if (MIPI_DSI_DCS_ACK_TYPE == MIPI_DSI_DCS_NO_ACK)
+        dsi_bta_control(1);
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para[1] << BIT_GEN_WC_MSBYTE)      |
+                                            (d_para[0] << BIT_GEN_WC_LSBYTE)      |
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)req->data_type) << BIT_GEN_DT)));
+    wait_bta_ack();
+    i = 0;
+    done = 0;
+    while (done == 0) {
+        read_data = generic_if_rd(MIPI_DSI_DWC_GEN_PLD_DATA_OS);
+        for (j=0; j<4; j++) {
+            if (i < dsi_rx_n) {
+                r_data[i] = (unsigned char)((read_data >> (j*8)) & 0xff);
+                i++;
+            }
+            else {
+                done = 1;
+                break;
+            }
+        }
+    }
+    if (MIPI_DSI_DCS_ACK_TYPE == MIPI_DSI_DCS_NO_ACK)
+        dsi_bta_control(0);
+
+    return dsi_rx_n;
+}
+
+static int dsi_dcs_read_packet(DSI_Cmd_Request_t *req, unsigned char *r_data)
+{
+    unsigned int d_command, read_data;
+    unsigned int i,j,done;
+
+    d_command = ((unsigned int)req->payload[2]) & 0xff;
+
+    if (MIPI_DSI_DCS_ACK_TYPE == MIPI_DSI_DCS_NO_ACK)
+        dsi_bta_control(1);
+    generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((0 << BIT_GEN_WC_MSBYTE)         |
+                                            (d_command << BIT_GEN_WC_LSBYTE)      |
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)req->data_type) << BIT_GEN_DT)));
+    wait_bta_ack();
+    i = 0;
+    done = 0;
+    while (done == 0) {
+        read_data = generic_if_rd(MIPI_DSI_DWC_GEN_PLD_DATA_OS);
+        for (j=0; j<4; j++) {
+            if (i < dsi_rx_n) {
+                r_data[i] = (unsigned char)((read_data >> (j*8)) & 0xff);
+                i++;
+            }
+            else {
+                done = 1;
+                break;
+            }
+        }
+    }
+
+    if (MIPI_DSI_DCS_ACK_TYPE == MIPI_DSI_DCS_NO_ACK)
+        dsi_bta_control(0);
+
+    return dsi_rx_n;
+}
+#endif
+
 // ----------------------------------------------------------------------------
 //                           Function: generic_write_short_packet
 // Generic Write Short Packet with Generic Interface
 // Supported Data Type: DT_GEN_SHORT_WR_0, DT_GEN_SHORT_WR_1, DT_GEN_SHORT_WR_2,
 // ----------------------------------------------------------------------------
-static void dsi_generic_write_short_packet(unsigned char data_type, unsigned char vc_id, unsigned char* payload, unsigned short pld_count, unsigned int req_ack)
+static void dsi_generic_write_short_packet(DSI_Cmd_Request_t *req)
 {
     unsigned int d_para[2];
 
-    vc_id &= 0x3;
-    switch (data_type) {
-        case DT_GEN_SHORT_WR_0:
-            d_para[0] = 0;
-            d_para[1] = 0;
-            break;
+    switch (req->data_type) {
         case DT_GEN_SHORT_WR_1:
-            d_para[0] = ((unsigned int)payload[1]) & 0xff;
+            d_para[0] = (req->pld_count == 0) ? 0 : (((unsigned int)req->payload[2]) & 0xff);
             d_para[1] = 0;
             break;
         case DT_GEN_SHORT_WR_2:
+            d_para[0] = (req->pld_count == 0) ? 0 : (((unsigned int)req->payload[2]) & 0xff);
+            d_para[1] = (req->pld_count < 2) ? 0 : (((unsigned int)req->payload[3]) & 0xff);
+            break;
+        case DT_GEN_SHORT_WR_0:
         default:
-            d_para[0] = ((unsigned int)payload[1]) & 0xff;
-            d_para[1] = (pld_count == 0) ? 0 : (((unsigned int)payload[3]) & 0xff);
+            d_para[0] = 0;
+            d_para[1] = 0;
             break;
     }
 
     generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para[1] << BIT_GEN_WC_MSBYTE)      |
                                             (d_para[0] << BIT_GEN_WC_LSBYTE)      |
-                                            (((unsigned int)vc_id) << BIT_GEN_VC) |
-                                            (((unsigned int)data_type) << BIT_GEN_DT)));
-    if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)req->data_type) << BIT_GEN_DT)));
+    if( req->req_ack == MIPI_DSI_DCS_REQ_ACK ) {
         wait_bta_ack();
     }
-    else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
+    else if( req->req_ack == MIPI_DSI_DCS_NO_ACK ) {
         wait_cmd_fifo_empty();
     }
 }
@@ -417,22 +559,21 @@ static void dsi_generic_write_short_packet(unsigned char data_type, unsigned cha
 // DCS Write Short Packet with Generic Interface
 // Supported Data Type: DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
 // ----------------------------------------------------------------------------
-static void dsi_dcs_write_short_packet(unsigned char data_type, unsigned char vc_id, unsigned char* payload, unsigned short pld_count, unsigned int req_ack)
+static void dsi_dcs_write_short_packet(DSI_Cmd_Request_t *req)
 {
     unsigned int d_command, d_para;
 
-    vc_id &= 0x3;
-    d_command = ((unsigned int)payload[1]) & 0xff;
-    d_para = (pld_count == 0) ? 0 : (((unsigned int)payload[3]) & 0xff);
+    d_command = ((unsigned int)req->payload[2]) & 0xff;
+    d_para = (req->pld_count < 2) ? 0 : (((unsigned int)req->payload[3]) & 0xff);
 
     generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, ((d_para << BIT_GEN_WC_MSBYTE)         |
                                             (d_command << BIT_GEN_WC_LSBYTE)      |
-                                            (((unsigned int)vc_id) << BIT_GEN_VC) |
-                                            (((unsigned int)data_type) << BIT_GEN_DT)));
-    if( req_ack == MIPI_DSI_DCS_REQ_ACK ) {
+                                            (((unsigned int)req->vc_id) << BIT_GEN_VC) |
+                                            (((unsigned int)req->data_type) << BIT_GEN_DT)));
+    if( req->req_ack == MIPI_DSI_DCS_REQ_ACK ) {
         wait_bta_ack();
     }
-    else if( req_ack == MIPI_DSI_DCS_NO_ACK ) {
+    else if( req->req_ack == MIPI_DSI_DCS_NO_ACK ) {
         wait_cmd_fifo_empty();
     }
 }
@@ -442,42 +583,42 @@ static void dsi_dcs_write_short_packet(unsigned char data_type, unsigned char vc
 // Write Long Packet with Generic Interface
 // Supported Data Type: DT_GEN_LONG_WR, DT_DCS_LONG_WR
 // ----------------------------------------------------------------------------
-static void dsi_write_long_packet(unsigned char data_type, unsigned char vc_id, unsigned char* payload, unsigned short pld_count, unsigned int req_ack)
+static void dsi_write_long_packet(DSI_Cmd_Request_t *req)
 {
-    unsigned int d_command, payload_data=0, header_data;
+    unsigned int d_command, payload_data, header_data;
     unsigned int cmd_status;
-    unsigned int i, d_start_index;
-    int j;
+    unsigned int i, j, data_index, n, temp;
 
-    vc_id &= 0x3;
-    d_command = ((unsigned int)payload[1]) & 0xff;
-    pld_count = (pld_count + 1) & 0xffff;//include command
-    d_start_index = 3;//payload[3] start (payload[0]: data_type, payload[1]: command, payload[2]: para_num)
+    data_index = DSI_CMD_CNT_INDEX + 1;//payload[2] start (payload[0]: data_type, payload[1]: data_cnt)
+    d_command = ((unsigned int)req->payload[data_index]) & 0xff;
 
     // Write Payload Register First
-    payload_data = d_command;
-    for(i=1; i<pld_count; i++) {
-        if(i%4 == 0)
-            payload_data = 0;
-        payload_data |= (((unsigned int)payload[i-1+d_start_index]) << 8*(i%4));
-
-        if((i%4 == 3) || (i == (pld_count-1))) {  // when last byte  //write max 4 byte payload data once
-            // Check the pld fifo status before write to it, do not need check every word
-            if((i == (pld_count/3)) || (i == (pld_count/2))) {
-                j = CMD_TIMEOUT_CNT;
-                do {
-                    udelay(10);
-                    j--;
-                    cmd_status = READ_LCD_REG(MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
-                } while((((cmd_status >> BIT_GEN_PLD_W_FULL) & 0x1) == 0x1) && (j>0));
-                print_mipi_cmd_status(j, cmd_status);
-            }
-            if(d_command == DCS_WRITE_MEMORY_CONTINUE) { // Use direct memory write to save time when in WRITE_MEMORY_CONTINUE
-                WRITE_LCD_REG(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
-            }
-            else {
-                generic_if_wr(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
-            }
+    n = (req->pld_count+3)/4;
+    for(i=0; i<n; i++) {
+        payload_data = 0;
+        if (i < (req->pld_count/4))
+            temp = 4;
+        else
+            temp = req->pld_count % 4;
+        for (j=0; j<temp; j++) {
+            payload_data |= (((unsigned int)req->payload[data_index+(i*4)+j]) << (j*8));
+        }
+
+        // Check the pld fifo status before write to it, do not need check every word
+        if((i == (n/3)) || (i == (n/2))) {
+            j = CMD_TIMEOUT_CNT;
+            do {
+                udelay(10);
+                j--;
+                cmd_status = READ_LCD_REG(MIPI_DSI_DWC_CMD_PKT_STATUS_OS);
+            } while((((cmd_status >> BIT_GEN_PLD_W_FULL) & 0x1) == 0x1) && (j>0));
+            print_mipi_cmd_status(j, cmd_status);
+        }
+        if(d_command == DCS_WRITE_MEMORY_CONTINUE) { // Use direct memory write to save time when in WRITE_MEMORY_CONTINUE
+            WRITE_LCD_REG(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
+        }
+        else {
+            generic_if_wr(MIPI_DSI_DWC_GEN_PLD_DATA_OS, payload_data);
         }
     }
 
@@ -490,38 +631,42 @@ static void dsi_write_long_packet(unsigned char data_type, unsigned char vc_id,
     } while((((cmd_status >> BIT_GEN_CMD_FULL) & 0x1) == 0x1) && (j>0));
     print_mipi_cmd_status(j, cmd_status);
     // Write Header Register
-    header_data = ( (((unsigned int)pld_count) << BIT_GEN_WC_LSBYTE) |//include command
-                    (((unsigned int)vc_id) << BIT_GEN_VC)                |
-                    (((unsigned int)data_type) << BIT_GEN_DT));
+    header_data = ( (((unsigned int)req->pld_count) << BIT_GEN_WC_LSBYTE) |//include command
+                    (((unsigned int)req->vc_id) << BIT_GEN_VC)                |
+                    (((unsigned int)req->data_type) << BIT_GEN_DT));
     generic_if_wr(MIPI_DSI_DWC_GEN_HDR_OS, header_data);
-    if (req_ack == MIPI_DSI_DCS_REQ_ACK) {
+    if (req->req_ack == MIPI_DSI_DCS_REQ_ACK) {
         wait_bta_ack();
     }
-    else if (req_ack == MIPI_DSI_DCS_NO_ACK) {
+    else if (req->req_ack == MIPI_DSI_DCS_NO_ACK) {
         wait_cmd_fifo_empty();
     }
 }
 
 // ----------------------------------------------------------------------------
 //                           Function: dsi_write_cmd
-// Generic Write Command
 // Supported Data Type: DT_GEN_SHORT_WR_0, DT_GEN_SHORT_WR_1, DT_GEN_SHORT_WR_2,
 //                      DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
 //                      DT_GEN_LONG_WR, DT_DCS_LONG_WR,
-//                      DT_SET_MAX_RPS
+//                      DT_SET_MAX_RET_PKT_SIZE
+//                      DT_GEN_RD_0, DT_GEN_RD_1, DT_GEN_RD_2,
+//                      DT_DCS_RD_0
 // Return:              command number
 // ----------------------------------------------------------------------------
 int dsi_write_cmd(unsigned char* payload)
 {
-    int i=0, j=0;
-    int num = 0;
+    int i=0, j=0, num=0;
+#ifdef DSI_CMD_READ_VALID
+    int k=0, n=0;
+    unsigned char rd_data[100];
+#endif
+    DSI_Cmd_Request_t dsi_cmd_req;
     unsigned char vc_id = MIPI_DSI_VIRTUAL_CHAN_ID;
     unsigned int req_ack = MIPI_DSI_DCS_ACK_TYPE;
 
-    //payload struct:
-    //data_type, command, para_num, parameters...
-    //data_type=0xff, command=0xff, means ending flag
-    //data_type=0xff, command<0xff, means delay time(unit ms)
+    //mipi command(payload)
+    //format:  data_type, num, data....
+    //special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
     while(i < DSI_CMD_SIZE_MAX) {
         if(payload[i]==0xff) {
             j = 2;
@@ -535,23 +680,25 @@ int dsi_write_cmd(unsigned char* payload)
             break;
         }
         else {
-            j = 3 + payload[i+2]; //payload[i+2] is parameter num
-            switch (payload[i]) {//analysis data_type
+            j = (DSI_CMD_CNT_INDEX + 1) + payload[i+DSI_CMD_CNT_INDEX]; //payload[i+DSI_CMD_CNT_INDEX] is data count
+            dsi_cmd_req.data_type = payload[i];
+            dsi_cmd_req.vc_id = (vc_id & 0x3);
+            dsi_cmd_req.payload = &payload[i];
+            dsi_cmd_req.pld_count = payload[i+DSI_CMD_CNT_INDEX];
+            dsi_cmd_req.req_ack = req_ack;
+            switch (dsi_cmd_req.data_type) {//analysis data_type
                 case DT_GEN_SHORT_WR_0:
                 case DT_GEN_SHORT_WR_1:
                 case DT_GEN_SHORT_WR_2:
-                    dsi_generic_write_short_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
+                    dsi_generic_write_short_packet(&dsi_cmd_req);
                     break;
                 case DT_DCS_SHORT_WR_0:
                 case DT_DCS_SHORT_WR_1:
-                    dsi_dcs_write_short_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
+                    dsi_dcs_write_short_packet(&dsi_cmd_req);
                     break;
                 case DT_DCS_LONG_WR:
                 case DT_GEN_LONG_WR:
-                    dsi_write_long_packet(payload[i], vc_id, &payload[i], payload[i+2], req_ack);
-                    break;
-                case DT_SET_MAX_RPS:
-                    DPRINT("to do data_type: 0x%2x\n", payload[i]);
+                    dsi_write_long_packet(&dsi_cmd_req);
                     break;
                 case DT_TURN_ON:
                     WRITE_LCD_REG_BITS(MIPI_DSI_TOP_CNTL, 1, 2, 1);
@@ -563,8 +710,38 @@ int dsi_write_cmd(unsigned char* payload)
                     WRITE_LCD_REG_BITS(MIPI_DSI_TOP_CNTL, 1, 2, 1);
                     mdelay(20); //wait for vsync trigger
                     break;
+                case DT_SET_MAX_RET_PKT_SIZE:
+                    dsi_set_max_return_pkt_size(&dsi_cmd_req);
+                    break;
+#ifdef DSI_CMD_READ_VALID
+                case DT_GEN_RD_0:
+                case DT_GEN_RD_1:
+                case DT_GEN_RD_2:
+                    dsi_cmd_req.req_ack = MIPI_DSI_DCS_REQ_ACK; //need BTA ack
+                    dsi_cmd_req.pld_count = (dsi_cmd_req.pld_count > 2) ? 2 : dsi_cmd_req.pld_count;
+                    n = dsi_generic_read_packet(&dsi_cmd_req, &rd_data[0]);
+                    DPRINT("generic read data");
+                    for (k=0; k<dsi_cmd_req.pld_count; k++) {
+                        DPRINT(" 0x%02x", dsi_cmd_req.payload[k+2]);
+                    }
+                    DPRINT(":\n");
+                    for (k=0; k<n; k++) {
+                        DPRINT("0x%02x ", rd_data[k]);
+                    }
+                    DPRINT("\n");
+                    break;
+                case DT_DCS_RD_0:
+                    dsi_cmd_req.req_ack = MIPI_DSI_DCS_REQ_ACK; //need BTA ack
+                    n = dsi_dcs_read_packet(&dsi_cmd_req, &rd_data[0]);
+                    DPRINT("dcs read data 0x%02x:\n", dsi_cmd_req.payload[2]);
+                    for (k=0; k<n; k++) {
+                        DPRINT("0x%02x ", rd_data[k]);
+                    }
+                    DPRINT("\n");
+                    break;
+#endif
                 default:
-                    DPRINT("un-support data_type: 0x%02x\n", payload[i]);
+                    DPRINT("[warning]dsi un-support data_type: 0x%02x\n", dsi_cmd_req.data_type);
                     break;
             }
         }
@@ -575,6 +752,59 @@ int dsi_write_cmd(unsigned char* payload)
     return num;
 }
 
+#ifdef DSI_CMD_READ_VALID
+// ----------------------------------------------------------------------------
+//                           Function: dsi_read_single
+// Supported Data Type: DT_GEN_RD_0, DT_GEN_RD_1, DT_GEN_RD_2,
+//                      DT_DCS_RD_0
+// Return:              data count
+// ----------------------------------------------------------------------------
+int dsi_read_single(unsigned char* payload, unsigned char *rd_data, unsigned int rd_byte_len)
+{
+    int num = 0;
+    unsigned char temp[4];
+    unsigned char vc_id = MIPI_DSI_VIRTUAL_CHAN_ID;
+    unsigned int req_ack;
+    DSI_Cmd_Request_t dsi_cmd_req;
+
+    req_ack = MIPI_DSI_DCS_ACK_TYPE;
+    dsi_cmd_req.data_type = DT_SET_MAX_RET_PKT_SIZE;
+    dsi_cmd_req.vc_id = (vc_id & 0x3);
+    temp[0] = dsi_cmd_req.data_type;
+    temp[1] = 2;
+    temp[2] = (unsigned char)((rd_byte_len >> 0) & 0xff);
+    temp[3] = (unsigned char)((rd_byte_len >> 8) & 0xff);
+    dsi_cmd_req.payload = &temp[0];
+    dsi_cmd_req.pld_count = 2;
+    dsi_cmd_req.req_ack = req_ack;
+    dsi_set_max_return_pkt_size(&dsi_cmd_req);
+
+    //payload struct:
+    //data_type, data_cnt, command, parameters...
+    req_ack = MIPI_DSI_DCS_REQ_ACK; //need BTA ack
+    dsi_cmd_req.data_type = payload[0];
+    dsi_cmd_req.vc_id = (vc_id & 0x3);
+    dsi_cmd_req.payload = &payload[0];
+    dsi_cmd_req.pld_count = payload[DSI_CMD_CNT_INDEX];
+    dsi_cmd_req.req_ack = req_ack;
+    switch (dsi_cmd_req.data_type) {//analysis data_type
+        case DT_GEN_RD_0:
+        case DT_GEN_RD_1:
+        case DT_GEN_RD_2:
+            num = dsi_generic_read_packet(&dsi_cmd_req, rd_data);
+            break;
+        case DT_DCS_RD_0:
+            num = dsi_dcs_read_packet(&dsi_cmd_req, rd_data);
+            break;
+        default:
+            DPRINT("dsi read un-support data_type: 0x%02x\n", dsi_cmd_req.data_type);
+            break;
+    }
+
+    return num;
+}
+#endif
+
 static void set_dsi_phy_config(DSI_Phy_t *dphy, unsigned dsi_ui)
 {
     unsigned t_lane_byte, t_ui;
@@ -865,12 +1095,12 @@ static void set_mipi_dsi_host(unsigned int vcid, unsigned int chroma_subsample,
 
     // Inner clock divider settings
     WRITE_LCD_REG( MIPI_DSI_DWC_CLKMGR_CFG_OS, (0x1 << BIT_TO_CLK_DIV) | (dsi_phy_config.lp_tesc << BIT_TX_ESC_CLK_DIV) );
-    // Packet header settings
-    WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
-                        (1 << BIT_ECC_RX_EN) |
-                        (0 << BIT_BTA_EN) |
-                        (0 << BIT_EOTP_RX_EN) |
-                        (0 << BIT_EOTP_TX_EN) );
+    // Packet header settings  //move to set_mipi_dcs
+    //WRITE_LCD_REG( MIPI_DSI_DWC_PCKHDL_CFG_OS, (1 << BIT_CRC_RX_EN) |
+    //                    (1 << BIT_ECC_RX_EN) |
+    //                    (0 << BIT_BTA_EN) |
+    //                    (0 << BIT_EOTP_RX_EN) |
+    //                    (0 << BIT_EOTP_TX_EN) );
     // operation mode setting: video/command mode
     WRITE_LCD_REG( MIPI_DSI_DWC_MODE_CFG_OS, operation_mode );
 
@@ -1123,6 +1353,9 @@ static const char * dsi_usage_str =
 "    echo write <addr> <value> > dsi ; write dsi phy reg with value\n"
 "    echo info > dsi ; print dsi config information\n"
 "    echo dphy > dsi ; print dsi phy timing information\n"
+"    echo cmd <data_type> <data_num> <data_1> <data_2> ... > dsi ; write single dsi command\n"
+"        <data_num>: decimal number\n"
+"        <data_n>:   variable length, total length must equal to <data_num>. no need '0xff,0xff' ending flag"
 };
 
 static ssize_t dsi_debug_help(struct class *class, struct class_attribute *attr, char *buf)
@@ -1133,7 +1366,8 @@ static ssize_t dsi_debug_help(struct class *class, struct class_attribute *attr,
 static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
 {
     unsigned int ret;
-    unsigned t[3];
+    unsigned t[4];
+    unsigned char cmd[6];
     unsigned num = 0;
     int i;
 
@@ -1160,6 +1394,20 @@ static ssize_t dsi_debug(struct class *class, struct class_attribute *attr, cons
         case 'd':
             print_dphy_info();
             break;
+        case 'c':
+            t[0] = 0xff;
+            t[1] = 0xff;
+            t[2] = 0;
+            t[3] = 0;
+            ret = sscanf(buf, "cmd %x %d %x %x", &t[0], &t[1], &t[2], &t[3]);
+            cmd[0] = (unsigned char)(t[0] & 0xff);
+            cmd[1] = (unsigned char)(t[1] & 0xff);
+            cmd[2] = (unsigned char)(t[2] & 0xff);
+            cmd[3] = (unsigned char)(t[3] & 0xff);
+            cmd[4] = 0xff;
+            cmd[5] = 0xff;
+            dsi_write_cmd(&cmd[0]);
+            break;
         default:
             DPRINT("wrong format of dsi debug command.\n");
             break;
diff --git a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h
index 78c236dfe500..0f3f099cbe90 100755
--- a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h
+++ b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.h
@@ -7,40 +7,42 @@
 // --------------------------------------------------------
 // MIPI DSI Data Type/ MIPI DCS Command Type Definitions
 // --------------------------------------------------------
-typedef enum {DT_VSS                 = 0x01,
-        DT_VSE                 = 0x11,
-        DT_HSS                 = 0x21,
-        DT_HSE                 = 0x31,
-        DT_EOTP                = 0x08,
-        DT_CMOFF               = 0x02,
-        DT_CMON                = 0x12,
-        DT_SHUT_DOWN           = 0x22,
-        DT_TURN_ON             = 0x32,
-        DT_GEN_SHORT_WR_0      = 0x03,
-        DT_GEN_SHORT_WR_1      = 0x13,
-        DT_GEN_SHORT_WR_2      = 0x23,
-        DT_GEN_RD_0            = 0x04,
-        DT_GEN_RD_1            = 0x14,
-        DT_GEN_RD_2            = 0x24,
-        DT_DCS_SHORT_WR_0      = 0x05,
-        DT_DCS_SHORT_WR_1      = 0x15,
-        DT_DCS_RD_0            = 0x06,
-        DT_SET_MAX_RPS         = 0x37,
-        DT_NULL_PKT            = 0x09,
-        DT_BLANK_PKT           = 0x19,
-        DT_GEN_LONG_WR         = 0x29,
-        DT_DCS_LONG_WR         = 0x39,
-        DT_20BIT_LOOSE_YCBCR   = 0x0c,
-        DT_24BIT_YCBCR         = 0x1c,
-        DT_16BIT_YCBCR         = 0x2c,
-        DT_30BIT_RGB_101010    = 0x0d,
-        DT_36BIT_RGB_121212    = 0x1d,
-        DT_12BIT_YCBCR         = 0x3d,
-        DT_16BIT_RGB_565       = 0x0e,
-        DT_18BIT_RGB_666       = 0x1e,
-        DT_18BIT_LOOSE_RGB_666 = 0x2e,
-        DT_24BIT_RGB_888       = 0x3e
-} mipi_dsi_data_type_t;
+//Pheripheral to Host
+typedef enum {
+	DT_VSS                  = 0x01,
+	DT_VSE                  = 0x11,
+	DT_HSS                  = 0x21,
+	DT_HSE                  = 0x31,
+	DT_EOTP                 = 0x08,
+	DT_CMOFF                = 0x02,
+	DT_CMON                 = 0x12,
+	DT_SHUT_DOWN            = 0x22,
+	DT_TURN_ON              = 0x32,
+	DT_GEN_SHORT_WR_0       = 0x03,
+	DT_GEN_SHORT_WR_1       = 0x13,
+	DT_GEN_SHORT_WR_2       = 0x23,
+	DT_GEN_RD_0             = 0x04,
+	DT_GEN_RD_1             = 0x14,
+	DT_GEN_RD_2             = 0x24,
+	DT_DCS_SHORT_WR_0       = 0x05,
+	DT_DCS_SHORT_WR_1       = 0x15,
+	DT_DCS_RD_0             = 0x06,
+	DT_SET_MAX_RET_PKT_SIZE = 0x37,
+	DT_NULL_PKT             = 0x09,
+	DT_BLANK_PKT            = 0x19,
+	DT_GEN_LONG_WR          = 0x29,
+	DT_DCS_LONG_WR          = 0x39,
+	DT_20BIT_LOOSE_YCBCR    = 0x0c,
+	DT_24BIT_YCBCR          = 0x1c,
+	DT_16BIT_YCBCR          = 0x2c,
+	DT_30BIT_RGB_101010     = 0x0d,
+	DT_36BIT_RGB_121212     = 0x1d,
+	DT_12BIT_YCBCR          = 0x3d,
+	DT_16BIT_RGB_565        = 0x0e,
+	DT_18BIT_RGB_666        = 0x1e,
+	DT_18BIT_LOOSE_RGB_666  = 0x2e,
+	DT_24BIT_RGB_888        = 0x3e
+} mipi_dsi_data_type_host_t;
 
 // DCS Command List
 #define DCS_ENTER_IDLE_MODE          0x39
@@ -88,6 +90,32 @@ typedef enum {DT_VSS                 = 0x01,
 #define DCS_WRITE_MEMORY_CONTINUE    0x3c
 #define DCS_WRITE_MEMORY_START       0x2c
 
+//Pheripheral to Host
+//normal: 0x87(LPDT), data_type, 0, 0, ecc.  //write or tearing-effect
+//error:  0x87(LPDT), 0x02, error_code[15:0], ecc.
+//short read: 0x87, data_type, data0, data1, ecc
+//long read:  0x87, data_type, word_cnt[15:0], ecc, data0, ... data(N-1), checksum(or 0)[15:0].
+typedef enum {
+	DT_RESP_TE             = 0xba,
+	DT_RESP_ACK            = 0x84,
+	DT_RESP_ACK_ERR        = 0x02,
+	DT_RESP_EOT            = 0x08,
+	DT_RESP_GEN_READ_1     = 0x11,
+	DT_RESP_GEN_READ_2     = 0x12,
+	DT_RESP_GEN_READ_LONG  = 0x1a,
+	DT_RESP_DCS_READ_LONG  = 0x1c,
+	DT_RESP_DCS_READ_1     = 0x21,
+	DT_RESP_DCS_READ_2     = 0x22,
+} mipi_dsi_data_type_peripheral_t;
+
+typedef struct {
+    unsigned char data_type;
+    unsigned char vc_id;
+    unsigned char *payload;
+    unsigned short pld_count;
+    unsigned int req_ack;
+} DSI_Cmd_Request_t;
+
 // --------------------------------------------------------
 // MIPI DCS Pixel-to-Byte Format
 // --------------------------------------------------------
@@ -433,6 +461,7 @@ typedef struct DSI_Vid_s{
 }DSI_Vid_t;
 
 #define DSI_CMD_SIZE_MAX		2000
+#define DSI_CMD_READ_VALID
 
 extern void set_mipi_dsi_control_config(Lcd_Config_t *pConf);
 extern void set_mipi_dsi_control_config_post(Lcd_Config_t *pConf);
diff --git a/drivers/amlogic/display/backlight/aml.dtd b/drivers/amlogic/display/backlight/aml.dtd
index c0e5097a23fd..beb99ca1d917 100755
--- a/drivers/amlogic/display/backlight/aml.dtd
+++ b/drivers/amlogic/display/backlight/aml.dtd
@@ -35,7 +35,7 @@
 		bl_power_on_delay=<200>; /** delay time before backlight power on(unit: ms) */
 		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive. 3=pwm_combo. 4=extern. decided by hardware design) */
 		
-		bl_gpio_port="GPIODV_28";	/** backlight control gpio port */
+		bl_gpio_port_on_off="GPIODV_28","1","0";	/** backlight control gpio port */
 		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
 		bl_pwm_port_gpio_used="PWM_C","1";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
 		bl_pwm_freq=<1000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c b/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c
index a7a99bec8440..ac192537d789 100755
--- a/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c
@@ -36,9 +36,13 @@ static struct bl_extern_config_t *bl_ext_config = NULL;
 static unsigned int bl_status = 1;
 static unsigned int bl_level = 0;
 
+//******************** mipi command ********************//
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+//******************************************************//
 static int bl_extern_set_level(unsigned int level)
 {
-    unsigned char payload[]={0x15,0x51,1,0xe6,0xff,0xff};
+    unsigned char payload[]={0x15,2,0x51,0xe6,0xff,0xff};
 
     bl_level = level;
 
diff --git a/drivers/amlogic/display/vout/aml_lcd.dtd b/drivers/amlogic/display/vout/aml_lcd.dtd
index baaf9ae8705e..041854848b81 100755
--- a/drivers/amlogic/display/vout/aml_lcd.dtd
+++ b/drivers/amlogic/display/vout/aml_lcd.dtd
@@ -156,7 +156,11 @@
     };
 
 //******************************************************************************
-//mipi
+//Interface: mipi
+
+//mipi command
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_B080XAN01>
 //$$ L2 PROP_STR = "model_name"
@@ -196,14 +200,14 @@
         dsi_bit_rate_max=<550>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x05 0x11 0 //sleep out
+        dsi_init_on=<0x05 1 0x11 //sleep out
                     0xff 20      //delay 20ms
-                    0x05 0x29 0  //display on
+                    0x05 1 0x29  //display on
                     0xff 20      //delay 20ms
                     0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
@@ -247,14 +251,14 @@
         dsi_bit_rate_min_max=<550>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x05 0x11 0 //sleep out
+        dsi_init_on=<0x05 1 0x11 //sleep out
                     0xff 100     //delay 100ms
-                    0x05 0x29 0  //display on
+                    0x05 1 0x29  //display on
                     0xff 100     //delay 100ms
                     0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
@@ -298,14 +302,14 @@
         dsi_bit_rate_min_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<15>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x05 0x11 0 //sleep out
+        dsi_init_on=<0x05 1 0x11 //sleep out
                     0xff 100     //delay 100ms
-                    0x05 0x29 0  //display on
+                    0x05 1 0x29  //display on
                     0xff 100     //delay 100ms
                     0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
@@ -351,23 +355,23 @@
         dsi_bit_rate_min_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x15 0x01 1 0x0 
+        dsi_init_on=<0x15 2 0x01 0x0 
                     0xff 20     //delay 20ms
-                    0x15 0xAE 1 0x0B 
-                    0x15 0xEE 1 0xEA 
-                    0x15 0xEF 1 0x5F 
-                    0x15 0xF2 1 0x68 
-                    0x15 0xEE 1 0x0 
-                    0x15 0xEF 1 0x0 
-
-                    0x05 0x11 0  //sleep out
+                    0x15 2 0xAE 0x0B 
+                    0x15 2 0xEE 0xEA 
+                    0x15 2 0xEF 0x5F 
+                    0x15 2 0xF2 0x68 
+                    0x15 2 0xEE 0x0 
+                    0x15 2 0xEF 0x0 
+
+                    0x05 1 0x11  //sleep out
                     0xff 200     //delay 200ms
-                    0x05 0x29 0  //display on
+                    0x05 1 0x29  //display on
                     0xff 100     //delay 100ms
                     0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;  /** lcd extern init command control(0=disable, 1=enable) */
@@ -456,7 +460,7 @@
         dsi_bit_rate_min_max=<900>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 2>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x32 0x0 0  //turn on peripheral
+        dsi_init_on=<0x32 0  //turn on peripheral
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         dsi_init_off=<0xff 0xff>; /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
@@ -500,32 +504,77 @@
         dsi_bit_rate_max=<900>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x05 0x01 0  //soft reset
+        dsi_init_on=<0x05 1 0x01  //soft reset
                     0xff 5        //delay 5ms
-                    0x23 0xb0 1 0x00  //MCAP
-                    0x29 0xb4 1 0x0c  //interface ID setting
-                    0x29 0xb6 2 0x3a 0xd3 //DSI control
+                    0x23 2 0xb0 0x00  //MCAP
+                    0x29 2 0xb4 0x0c  //interface ID setting
+                    0x29 3 0xb6 0x3a 0xd3 //DSI control
 
-                    0x15 0x51 1 0xe6 //write display brightness
-                    0x15 0x53 1 0x2c //write control display
+                    0x15 2 0x51 0xe6 //write display brightness
+                    0x15 2 0x53 0x2c //write control display
 
-                    0x15 0x3a 1 0x77 //set pixel format
-                    0x05 0x11 0 //sleep out
+                    0x15 2 0x3a 0x77 //set pixel format
+                    0x05 1 0x11 //sleep out
                     0xff 120    //delay 120ms
-                    0x29 0xb3 5 0x14 0x08 0x00 0x22 0x00 //Interface setting
-                    0x05 0x29 0 //display on
+                    0x29 6 0xb3 0x14 0x08 0x00 0x22 0x00 //Interface setting
+                    0x05 1 0x29 //display on
                     0xff 30     //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
     };
 
+//$$ MATCH "lcd_model_config_match" = <&lcd_KD080D13>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "vsync_horizontal_phase"
+//$$ L2 PROP_U32 = "dsi_lane_num"
+//$$ L2 PROP_U32 2 = "dsi_operation_mode"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
+//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
+//$$ L2 PROP_U32 2 = "dsi_init_on"
+//$$ L2 PROP_U32 2 = "dsi_init_off"
+//$$ L2 PROP_U32 = "lcd_extern_init"
+    lcd_KD080D13:lcd_KD080D13{
+        model_name="KD080D13";	/** lcd model name */
+        interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
+        active_area=<108 172>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+        lcd_bits_option=<8 0>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+        resolution=<800 1280>;	/** horizontal resolution, vertical resolution */
+        period=<880 1380>;		/** horizontal period(htotal), vertical period(vtotal) */
+
+        clock_hz_pol=<72864000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+        hsync_width_backporch=<16 64>;	/** hsync_width, hsync_backporch(include hsync_width) */
+        vsync_width_backporch=<4 8>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+        vsync_horizontal_phase=<1 4>; /** adj_sign(0=positive, 1=negative), adj_value. default is <0 0> */
+
+        dsi_lane_num=<4>;/** mipi dsi data lane number */
+        dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
+        dsi_bit_rate_min_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
+        pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
+        dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
+        dsi_init_on=<0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
+        dsi_init_off=<0xff 0xff>; /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
+        lcd_extern_init=<1>;    /** lcd extern init command control(0=disable, 1=enable) */
+    };
+
 //******************************************************************************
-//edp
+//Interface: edp
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_LP097QX1>
 //$$ L2 PROP_STR = "model_name"
@@ -673,7 +722,7 @@
 	};
 
 //******************************************************************************
-//lvds
+//Interface: lvds
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_LP097X02>
 //$$ L2 PROP_STR = "model_name"
@@ -990,7 +1039,7 @@
         pol_hsync_vsync=<0 0>;    /** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 //******************************************************************************
-//ttl
+//Interface: ttl
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_CLAP070NJ02>
 //$$ L2 PROP_STR = "model_name"
@@ -1123,7 +1172,7 @@
     };
 
 //******************************************************************************
-//bridge
+//Interface: bridge
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_TM080XSZ00>
 //$$ L2 PROP_STR = "model_name"
diff --git a/drivers/amlogic/display/vout/lcd_extern/Makefile b/drivers/amlogic/display/vout/lcd_extern/Makefile
index 3a5b2b01a5e8..631d6bcc7198 100755
--- a/drivers/amlogic/display/vout/lcd_extern/Makefile
+++ b/drivers/amlogic/display/vout/lcd_extern/Makefile
@@ -2,5 +2,6 @@
 obj-y	+= lcd_extern.o
 obj-y	+= i2c_tc101.o
 obj-y	+= mipi_N070ICN.o
+obj-y	+= mipi_KD080D13.o
 obj-y	+= spi_LD070WS2.o
 
diff --git a/drivers/amlogic/display/vout/lcd_extern/aml.dtd b/drivers/amlogic/display/vout/lcd_extern/aml.dtd
index 6bd37c0fd73a..bd39b51c35d8 100755
--- a/drivers/amlogic/display/vout/lcd_extern/aml.dtd
+++ b/drivers/amlogic/display/vout/lcd_extern/aml.dtd
@@ -44,6 +44,18 @@
 
 		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
 	};
+	
+//$$ DEVICE = "lcd_extern_mipi_KD080D13"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_KD080D13{
+		compatible = "amlogic,lcd_mipi_KD080D13";
+		dev_name ="lcd_mipi_KD080D13";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+	};
+	
 //$$ DEVICE = "lcd_extern_edp_ANX6345"
 //$$ L2 PROP_STR = "status"
 //$$ L2 PROP_U32 = "type"
diff --git a/drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c b/drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c
new file mode 100644
index 000000000000..b3a89c07ae38
--- /dev/null
+++ b/drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c
@@ -0,0 +1,200 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * MIPI 
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h> 
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+
+static struct lcd_extern_config_t *lcd_ext_config = NULL;
+
+//#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+#define LCD_EXTERN_NAME			"lcd_mipi_KD080D13"
+
+//******************** mipi command ********************//
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+//******************************************************//
+static unsigned char mipi_init_on_table[] = {
+    0x39,3,0xf0,0x5a,0x5a,
+    0x39,3,0xf1,0x5a,0x5a,
+    0x39,3,0xfc,0xa5,0xa5,
+    0x39,3,0xd0,0x00,0x10,
+    0x15,2,0xb1,0x10,
+    0x39,5,0xb2,0x14,0x22,0x2f,0x04,
+    0x39,6,0xf2,0x02,0x08,0x08,0x40,0x10,
+    0x15,2,0xb0,0x03,
+    0x39,3,0xfd,0x23,0x09,
+    0x39,11,0xf3,0x01,0x93,0x20,0x22,0x80,0x05,0x25,0x3c,0x26,0x00,
+    0x39,46,0xf4,0x00,0x02,0x03,0x26,0x03,0x02,0x09,0x00,0x07,0x16,0x16,0x03,0x00,0x08,0x08,0x03,0x0E,0x0F,0x12,0x1C,0x1D,0x1E,0x0C,0x09,0x01,0x04,0x02,0x61,0x74,0x75,0x72,0x83,0x80,0x80,0xB0,0x00,0x01,0x01,0x28,0x04,0x03,0x28,0x01,0xD1,0x32,
+    0x39,27,0xf5,0x84,0x2F,0x2F,0x5F,0xAB,0x98,0x52,0x0F,0x33,0x43,0x04,0x59,0x54,0x52,0x05,0x40,0x60,0x4E,0x60,0x40,0x27,0x26,0x52,0x25,0x6D,0x18,
+    0x39,9,0xee,0x25,0x00,0x25,0x00,0x25,0x00,0x25,0x00,
+    0x39,9,0xef,0x34,0x12,0x98,0xBA,0x20,0x00,0x24,0x80,
+    0x39,33,0xf7,0x0E,0x0E,0x0A,0x0A,0x0F,0x0F,0x0B,0x0B,0x05,0x07,0x01,0x01,0x01,0x01,0x01,0x01,0x0C,0x0C,0x08,0x08,0x0D,0x0D,0x09,0x09,0x04,0x06,0x01,0x01,0x01,0x01,0x01,0x01,
+    0x39,4,0xbc,0x01,0x4e,0x0a,
+    0x39,6,0xe1,0x03,0x10,0x1c,0xa0,0x10,
+    0x39,7,0xf6,0x60,0x21,0xA6,0x00,0x00,0x00,
+    0x39,7,0xfe,0x00,0x0D,0x03,0x21,0x80,0x48,
+    0x15,2,0xb0,0x22,
+    0x39,18,0xfa,0x02,0x34,0x09,0x13,0x0B,0x0F,0x16,0x16,0x17,0x1E,0x1D,0x1C,0x1E,0x1D,0x1D,0x1F,0x24,
+    0x15,2,0xb0,0x22,
+    0x39,18,0xfb,0x00,0x34,0x07,0x11,0x09,0x0D,0x14,0x14,0x15,0x1C,0x1F,0x1C,0x1D,0x1D,0x1D,0x20,0x26,
+    0x15,2,0xb0,0x11,
+    0x39,18,0xfa,0x20,0x34,0x24,0x27,0x19,0x1B,0x1F,0x1E,0x1B,0x1F,0x21,0x1F,0x1E,0x20,0x1E,0x1E,0x21,
+    0x15,2,0xb0,0x11,
+    0x39,18,0xfb,0x1E,0x34,0x22,0x25,0x17,0x19,0x1D,0x1A,0x19,0x20,0x1F,0x1E,0x20,0x1E,0x1E,0x1F,0x22,
+    0x39,18,0xfa,0x1C,0x34,0x1C,0x1F,0x13,0x17,0x1A,0x18,0x18,0x1E,0x20,0x21,0x21,0x21,0x23,0x22,0x2A,
+    0x39,18,0xfb,0x1A,0x34,0x1A,0x1D,0x11,0x15,0x18,0x16,0x16,0x1C,0x20,0x20,0x20,0x1F,0x23,0x23,0x2B,
+
+    0x05,1,0x11,
+    0xff,20,
+    0x39,4,0xc3,0x40,0x00,0x28,
+    0xff,200,
+    0x15,2,0x35,0x00,
+    0x05,1,0x29,
+    0xff,30,     //delay 30ms
+    0xff,0xff,   //ending flag
+};
+
+static unsigned char mipi_init_off_table[] = {
+    0x05,1,0x28, //display off
+    0xff,30,     //delay 30ms
+    0x05,1,0x10, //sleep in
+    0xff,30,     //delay 30ms
+    0x39,4,0xc3,0x40,0x00,0x20,
+    0xff,10,
+    0xff,0xff,   //ending flag
+};
+
+static int lcd_extern_driver_update(void)
+{
+    struct aml_lcd_extern_driver_t* lcd_ext;
+
+    lcd_ext = aml_lcd_extern_get_driver();
+    if (lcd_ext) {
+        lcd_ext->type       = lcd_ext_config->type;
+        lcd_ext->name       = lcd_ext_config->name;
+        lcd_ext->init_on_cmd_8  = &mipi_init_on_table[0];
+        lcd_ext->init_off_cmd_8 = &mipi_init_off_table[0];
+    }
+    else {
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_config->name);
+    }
+
+    return 0;
+}
+
+static int aml_KD080D13_probe(struct platform_device *pdev)
+{
+    //int i = 0;
+
+    if (lcd_extern_driver_check()) {
+        return -1;
+    }
+    if (lcd_ext_config == NULL)
+        lcd_ext_config = kzalloc(sizeof(*lcd_ext_config), GFP_KERNEL);
+    if (lcd_ext_config == NULL) {
+        printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
+        return -1;
+    }
+
+    pdev->dev.platform_data = lcd_ext_config;
+
+    if (get_lcd_extern_dt_data(pdev->dev.of_node, lcd_ext_config) != 0) {
+        printk("[error] %s probe: failed to get dt data\n", LCD_EXTERN_NAME);
+        goto lcd_extern_probe_failed;
+    }
+    lcd_extern_driver_update();
+
+    printk("%s probe ok\n", LCD_EXTERN_NAME);
+    return 0;
+
+lcd_extern_probe_failed:
+    if (lcd_ext_config)
+        kfree(lcd_ext_config);
+    return -1;
+}
+
+static int aml_KD080D13_remove(struct platform_device *pdev)
+{
+    remove_lcd_extern(lcd_ext_config);
+    if (pdev->dev.platform_data)
+        kfree (pdev->dev.platform_data);
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_KD080D13_dt_match[]={
+    {
+        .compatible = "amlogic,lcd_mipi_KD080D13",
+    },
+    {},
+};
+#else
+#define aml_KD080D13_dt_match NULL
+#endif
+
+static struct platform_driver aml_KD080D13_driver = {
+    .probe  = aml_KD080D13_probe,
+    .remove = aml_KD080D13_remove,
+    .driver = {
+        .name  = LCD_EXTERN_NAME,
+        .owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+        .of_match_table = aml_KD080D13_dt_match,
+#endif
+    },
+};
+
+static int __init aml_KD080D13_init(void)
+{
+    int ret;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    ret = platform_driver_register(&aml_KD080D13_driver);
+    if (ret) {
+        printk("[error] %s failed to register lcd extern driver module\n", __FUNCTION__);
+        return -ENODEV;
+    }
+
+    return ret;
+}
+
+static void __exit aml_KD080D13_exit(void)
+{
+    platform_driver_unregister(&aml_KD080D13_driver);
+}
+
+//late_initcall(aml_KD080D13_init);
+module_init(aml_KD080D13_init);
+module_exit(aml_KD080D13_exit);
+
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("LCD Extern driver for KD080D13");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c b/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c
index a8ae633c2cae..6977b020d47b 100755
--- a/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c
+++ b/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c
@@ -37,176 +37,180 @@ static struct lcd_extern_config_t *lcd_ext_config = NULL;
 
 #define LCD_EXTERN_NAME			"lcd_mipi_N070ICN"
 
+//******************** mipi command ********************//
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+//******************************************************//
 static unsigned char mipi_init_on_table[] = {
-    0x39,0xFF,4,0xAA,0x55,0xA5,0x80, //========== Internal setting ==========
-
-    0x39,0x6F,2,0x11,0x00, //MIPI related Timing Setting
-    0x39,0xF7,2,0x20,0x00,
-
-    0x15,0x6F,1,0x06,      //Improve ESD option
-    0x15,0xF7,1,0xA0,
-    0x15,0x6F,1,0x19,
-    0x15,0xF7,1,0x12,
-
-    0x15,0x6F,1,0x08,     //Vcom floating
-    0x15,0xFA,1,0x40,
-    0x15,0x6F,1,0x11,
-    0x15,0xF3,1,0x01,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x00, //========== page0 relative ==========
-    0x15,0xC8,1,0x80,
-
-    0x39,0xB1,2,0x6C,0x01, //Set WXGA resolution
-
-    0x15,0xB6,1,0x08,      //Set source output hold time
-
-    0x15,0x6F,1,0x02,      //EQ control function
-    0x15,0xB8,1,0x08,
-
-    0x39,0xBB,2,0x54,0x54, //Set bias current for GOP and SOP
-
-    0x39,0xBC,2,0x05,0x05, //Inversion setting
-
-    0x15,0xC7,1,0x01,      //zigzag setting
-
-    0x39,0xBD,5,0x02,0xB0,0x0C,0x0A,0x00, //DSP Timing Settings update for BIST
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x01, //========== page1 relative ==========
-
-    0x39,0xB0,2,0x05,0x05,                // Setting AVDD, AVEE clamp
-    0x39,0xB1,2,0x05,0x05,
-
-    0x39,0xBC,2,0x3A,0x01,                // VGMP, VGMN, VGSP, VGSN setting
-    0x39,0xBD,2,0x3E,0x01,
-
-    0x15,0xCA,1,0x00,                    // gate signal control
-
-    0x15,0xC0,1,0x04,                    // power IC control
-    0x15,0xB2,1,0x00,
-    0x15,0xBE,1,0x80,      //vcom    -1.88V
-
-    0x39,0xB3,2,0x19,0x19, // Setting VGH=15V, VGL=-11V
-    0x39,0xB4,2,0x12,0x12,
-
-    0x39,0xB9,2,0x24,0x24, // power control for VGH, VGL
-    0x39,0xBA,2,0x14,0x14,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x02, //========== page2 relative ==========
-
-    0x15,0xEE,1,0x01,                     //Gamma setting
-    0x39,0xEF,4,0x09,0x06,0x15,0x18,      //Gradient Control for Gamma Voltage
-
-    0x39,0xB0,6,0x00,0x00,0x00,0x08,0x00,0x17, //========== GOA relative ==========
-    0x15,0x6F,1,0x06,
-    0x39,0xB0,6,0x00,0x25,0x00,0x30,0x00,0x45,
-    0x15,0x6F,1,0x0C,
-    0x39,0xB0,4,0x00,0x56,0x00,0x7A,
-    0x39,0xB1,6,0x00,0xA3,0x00,0xE7,0x01,0x20, ////////////////////////////
-    0x15,0x6F,1,0x06,
-    0x39,0xB1,6,0x01,0x7A,0x01,0xC2,0x01,0xC5,
-    0x15,0x6F,1,0x0C,
-    0x39,0xB1,4,0x02,0x06,0x02,0x5F,
-    0x39,0xB2,6,0x02,0x92,0x02,0xD0,0x02,0xFC,
-    0x15,0x6F,1,0x06,
-    0x39,0xB2,6,0x03,0x35,0x03,0x5D,0x03,0x8B,
-    0x15,0x6F,1,0x0C,
-    0x39,0xB2,4,0x03,0xA2,0x03,0xBF,
-    0x39,0xB3,4,0x03,0xD2,0x03,0xFF,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x06,      //PAGE6 : GOUT Mapping, VGLO select
-    0x39,0xB0,2,0x00,0x17,
-    0x39,0xB1,2,0x16,0x15,
-    0x39,0xB2,2,0x14,0x13,
-    0x39,0xB3,2,0x12,0x11,
-    0x39,0xB4,2,0x10,0x2D,
-    0x39,0xB5,2,0x01,0x08,
-    0x39,0xB6,2,0x09,0x31,
-    0x39,0xB7,2,0x31,0x31,
-    0x39,0xB8,2,0x31,0x31,
-    0x39,0xB9,2,0x31,0x31,
-    0x39,0xBA,2,0x31,0x31,
-    0x39,0xBB,2,0x31,0x31,
-    0x39,0xBC,2,0x31,0x31,
-    0x39,0xBD,2,0x31,0x09,
-    0x39,0xBE,2,0x08,0x01,
-    0x39,0xBF,2,0x2D,0x10,
-    0x39,0xC0,2,0x11,0x12,
-    0x39,0xC1,2,0x13,0x14,
-    0x39,0xC2,2,0x15,0x16,
-    0x39,0xC3,2,0x17,0x00,
-    0x39,0xE5,2,0x31,0x31,
-    0x39,0xC4,2,0x00,0x17,
-    0x39,0xC5,2,0x16,0x15,
-    0x39,0xC6,2,0x14,0x13,
-    0x39,0xC7,2,0x12,0x11,
-    0x39,0xC8,2,0x10,0x2D,
-    0x39,0xC9,2,0x01,0x08,
-    0x39,0xCA,2,0x09,0x31,
-    0x39,0xCB,2,0x31,0x31,
-    0x39,0xCC,2,0x31,0x31,
-    0x39,0xCD,2,0x31,0x31,
-    0x39,0xCE,2,0x31,0x31,
-    0x39,0xCF,2,0x31,0x31,
-    0x39,0xD0,2,0x31,0x31,
-    0x39,0xD1,2,0x31,0x09,
-    0x39,0xD2,2,0x08,0x01,
-    0x39,0xD3,2,0x2D,0x10,
-    0x39,0xD4,2,0x11,0x12,
-    0x39,0xD5,2,0x13,0x14,
-    0x39,0xD6,2,0x15,0x16,
-    0x39,0xD7,2,0x17,0x00,
-    0x39,0xE6,2,0x31,0x31,
-    0x39,0xD8,5,0x00,0x00,0x00,0x00,0x00, //VGL level select;
-    0x39,0xD9,5,0x00,0x00,0x00,0x00,0x00,
-    0x15,0xE7,1,0x00,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x03, //===page 3====//gate timing control
-    0x39,0xB0,2,0x20,0x00,
-    0x39,0xB1,2,0x20,0x00,
-    0x39,0xB2,5,0x05,0x00,0x42,0x00,0x00,
-    0x39,0xB6,5,0x05,0x00,0x42,0x00,0x00,
-    0x39,0xBA,5,0x53,0x00,0x42,0x00,0x00,
-    0x39,0xBB,5,0x53,0x00,0x42,0x00,0x00,
-    0x15,0xC4,1,0x40,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x05, //===page 5====//
-    0x39,0xB0,2,0x17,0x06,
-    0x15,0xB8,1,0x00,
-    0x39,0xBD,5,0x03,0x01,0x01,0x00,0x01,
-    0x39,0xB1,2,0x17,0x06,
-    0x39,0xB9,2,0x00,0x01,
-    0x39,0xB2,2,0x17,0x06,
-    0x39,0xBA,2,0x00,0x01,
-    0x39,0xB3,2,0x17,0x06,
-    0x39,0xBB,2,0x0A,0x00,
-    0x39,0xB4,2,0x17,0x06,
-    0x39,0xB5,2,0x17,0x06,
-    0x39,0xB6,2,0x14,0x03,
-    0x39,0xB7,2,0x00,0x00,
-    0x39,0xBC,2,0x02,0x01,
-    0x15,0xC0,1,0x05,
-    0x15,0xC4,1,0xA5,
-    0x39,0xC8,2,0x03,0x30,
-    0x39,0xC9,2,0x03,0x51,
-    0x39,0xD1,5,0x00,0x05,0x03,0x00,0x00,
-    0x39,0xD2,5,0x00,0x05,0x09,0x00,0x00,
-    0x15,0xE5,1,0x02,
-    0x15,0xE6,1,0x02,
-    0x15,0xE7,1,0x02,
-    0x15,0xE9,1,0x02,
-    0x15,0xED,1,0x33,
-
-    0x05,0x11,0, //sleep out
+    0x39,5,0xFF,0xAA,0x55,0xA5,0x80, //========== Internal setting ==========
+
+    0x39,3,0x6F,0x11,0x00, //MIPI related Timing Setting
+    0x39,3,0xF7,0x20,0x00,
+
+    0x15,2,0x6F,0x06,      //Improve ESD option
+    0x15,2,0xF7,0xA0,
+    0x15,2,0x6F,0x19,
+    0x15,2,0xF7,0x12,
+
+    0x15,2,0x6F,0x08,     //Vcom floating
+    0x15,2,0xFA,0x40,
+    0x15,2,0x6F,0x11,
+    0x15,2,0xF3,0x01,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x00, //========== page0 relative ==========
+    0x15,2,0xC8,0x80,
+
+    0x39,3,0xB1,0x6C,0x01, //Set WXGA resolution
+
+    0x15,2,0xB6,0x08,      //Set source output hold time
+
+    0x15,2,0x6F,0x02,      //EQ control function
+    0x15,2,0xB8,0x08,
+
+    0x39,3,0xBB,0x54,0x54, //Set bias current for GOP and SOP
+
+    0x39,3,0xBC,0x05,0x05, //Inversion setting
+
+    0x15,2,0xC7,0x01,      //zigzag setting
+
+    0x39,6,0xBD,0x02,0xB0,0x0C,0x0A,0x00, //DSP Timing Settings update for BIST
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x01, //========== page1 relative ==========
+
+    0x39,3,0xB0,0x05,0x05,                // Setting AVDD, AVEE clamp
+    0x39,3,0xB1,0x05,0x05,
+
+    0x39,3,0xBC,0x3A,0x01,                // VGMP, VGMN, VGSP, VGSN setting
+    0x39,3,0xBD,0x3E,0x01,
+
+    0x15,2,0xCA,0x00,                    // gate signal control
+
+    0x15,2,0xC0,0x04,                    // power IC control
+    0x15,2,0xB2,0x00,
+    0x15,2,0xBE,0x80,      //vcom    -1.88V
+
+    0x39,3,0xB3,0x19,0x19, // Setting VGH=15V, VGL=-11V
+    0x39,3,0xB4,0x12,0x12,
+
+    0x39,3,0xB9,0x24,0x24, // power control for VGH, VGL
+    0x39,3,0xBA,0x14,0x14,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x02, //========== page2 relative ==========
+
+    0x15,2,0xEE,0x01,                     //Gamma setting
+    0x39,5,0xEF,0x09,0x06,0x15,0x18,      //Gradient Control for Gamma Voltage
+
+    0x39,7,0xB0,0x00,0x00,0x00,0x08,0x00,0x17, //========== GOA relative ==========
+    0x15,2,0x6F,0x06,
+    0x39,7,0xB0,0x00,0x25,0x00,0x30,0x00,0x45,
+    0x15,2,0x6F,0x0C,
+    0x39,5,0xB0,0x00,0x56,0x00,0x7A,
+    0x39,7,0xB1,0x00,0xA3,0x00,0xE7,0x01,0x20, ////////////////////////////
+    0x15,2,0x6F,0x06,
+    0x39,7,0xB1,0x01,0x7A,0x01,0xC2,0x01,0xC5,
+    0x15,2,0x6F,0x0C,
+    0x39,5,0xB1,0x02,0x06,0x02,0x5F,
+    0x39,7,0xB2,0x02,0x92,0x02,0xD0,0x02,0xFC,
+    0x15,2,0x6F,0x06,
+    0x39,7,0xB2,0x03,0x35,0x03,0x5D,0x03,0x8B,
+    0x15,2,0x6F,1,0x0C,
+    0x39,5,0xB2,0x03,0xA2,0x03,0xBF,
+    0x39,5,0xB3,0x03,0xD2,0x03,0xFF,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x06,      //PAGE6 : GOUT Mapping, VGLO select
+    0x39,3,0xB0,0x00,0x17,
+    0x39,3,0xB1,0x16,0x15,
+    0x39,3,0xB2,0x14,0x13,
+    0x39,3,0xB3,0x12,0x11,
+    0x39,3,0xB4,0x10,0x2D,
+    0x39,3,0xB5,0x01,0x08,
+    0x39,3,0xB6,0x09,0x31,
+    0x39,3,0xB7,0x31,0x31,
+    0x39,3,0xB8,0x31,0x31,
+    0x39,3,0xB9,0x31,0x31,
+    0x39,3,0xBA,0x31,0x31,
+    0x39,3,0xBB,0x31,0x31,
+    0x39,3,0xBC,0x31,0x31,
+    0x39,3,0xBD,0x31,0x09,
+    0x39,3,0xBE,0x08,0x01,
+    0x39,3,0xBF,0x2D,0x10,
+    0x39,3,0xC0,0x11,0x12,
+    0x39,3,0xC1,0x13,0x14,
+    0x39,3,0xC2,0x15,0x16,
+    0x39,3,0xC3,0x17,0x00,
+    0x39,3,0xE5,0x31,0x31,
+    0x39,3,0xC4,0x00,0x17,
+    0x39,3,0xC5,0x16,0x15,
+    0x39,3,0xC6,0x14,0x13,
+    0x39,3,0xC7,0x12,0x11,
+    0x39,3,0xC8,0x10,0x2D,
+    0x39,3,0xC9,0x01,0x08,
+    0x39,3,0xCA,0x09,0x31,
+    0x39,3,0xCB,0x31,0x31,
+    0x39,3,0xCC,0x31,0x31,
+    0x39,3,0xCD,0x31,0x31,
+    0x39,3,0xCE,0x31,0x31,
+    0x39,3,0xCF,0x31,0x31,
+    0x39,3,0xD0,0x31,0x31,
+    0x39,3,0xD1,0x31,0x09,
+    0x39,3,0xD2,0x08,0x01,
+    0x39,3,0xD3,0x2D,0x10,
+    0x39,3,0xD4,0x11,0x12,
+    0x39,3,0xD5,0x13,0x14,
+    0x39,3,0xD6,0x15,0x16,
+    0x39,3,0xD7,0x17,0x00,
+    0x39,3,0xE6,0x31,0x31,
+    0x39,6,0xD8,0x00,0x00,0x00,0x00,0x00, //VGL level select;
+    0x39,6,0xD9,0x00,0x00,0x00,0x00,0x00,
+    0x15,2,0xE7,0x00,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x03, //===page 3====//gate timing control
+    0x39,3,0xB0,0x20,0x00,
+    0x39,3,0xB1,0x20,0x00,
+    0x39,6,0xB2,0x05,0x00,0x42,0x00,0x00,
+    0x39,6,0xB6,0x05,0x00,0x42,0x00,0x00,
+    0x39,6,0xBA,0x53,0x00,0x42,0x00,0x00,
+    0x39,6,0xBB,0x53,0x00,0x42,0x00,0x00,
+    0x15,2,0xC4,0x40,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x05, //===page 5====//
+    0x39,3,0xB0,0x17,0x06,
+    0x15,2,0xB8,0x00,
+    0x39,6,0xBD,0x03,0x01,0x01,0x00,0x01,
+    0x39,3,0xB1,0x17,0x06,
+    0x39,3,0xB9,0x00,0x01,
+    0x39,3,0xB2,0x17,0x06,
+    0x39,3,0xBA,0x00,0x01,
+    0x39,3,0xB3,0x17,0x06,
+    0x39,3,0xBB,0x0A,0x00,
+    0x39,3,0xB4,0x17,0x06,
+    0x39,3,0xB5,0x17,0x06,
+    0x39,3,0xB6,0x14,0x03,
+    0x39,3,0xB7,0x00,0x00,
+    0x39,3,0xBC,0x02,0x01,
+    0x15,2,0xC0,0x05,
+    0x15,2,0xC4,0xA5,
+    0x39,3,0xC8,0x03,0x30,
+    0x39,3,0xC9,0x03,0x51,
+    0x39,6,0xD1,0x00,0x05,0x03,0x00,0x00,
+    0x39,6,0xD2,0x00,0x05,0x09,0x00,0x00,
+    0x15,2,0xE5,0x02,
+    0x15,2,0xE6,0x02,
+    0x15,2,0xE7,0x02,
+    0x15,2,0xE9,0x02,
+    0x15,2,0xED,0x33,
+
+    0x05,1,0x11, //sleep out
     0xff,30,     //delay 30ms
-    0x05,0x29,0, //display on
+    0x05,1,0x29, //display on
     0xff,30,     //delay 30ms
     0xff,0xff,   //ending flag
 };
 
 static unsigned char mipi_init_off_table[] = {
-    0x05,0x28,0, //display off
+    0x05,1,0x28, //display off
     0xff,10,     //delay 10ms
-    0x05,0x10,0, //sleep in
+    0x05,1,0x10, //sleep in
     0xff,10,     //delay 10ms
     0xff,0xff,   //ending flag
 };
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index 5d380bfbd9fc..7c76e9488c00 100755
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -53,22 +53,11 @@
 #endif
 
 #define PANEL_NAME		"panel"
- 
-#ifdef LCD_DEBUG_INFO
-unsigned int lcd_print_flag = 1;
-#else
-unsigned int lcd_print_flag = 0;
-#endif
-void lcd_print(const char *fmt, ...)
-{
-	va_list args;
 
-	if (lcd_print_flag == 0)
-		return;
-	va_start(args, fmt);
-	vprintk(fmt, args);
-	va_end(args);
-}
+typedef struct {
+	Lcd_Config_t *pConf;
+	vinfo_t lcd_info;
+} lcd_dev_t;
 
 static const char* lcd_power_type_table[]={
 	"cpu",
@@ -87,15 +76,29 @@ static const char* lcd_power_pmu_gpio_table[]={
 	"null",
 }; 
 
-typedef struct {
-	Lcd_Config_t *pConf;
-	vinfo_t lcd_info;
-} lcd_dev_t;
+#ifdef LCD_DEBUG_INFO
+unsigned int lcd_print_flag = 1;
+#else
+unsigned int lcd_print_flag = 0;
+#endif
 
 static lcd_dev_t *pDev = NULL;
+#ifdef CONFIG_AML_GAMMA_DEBUG
 static struct class *gamma_debug_class = NULL;
+#endif
 static Bool_t data_status = ON;
 
+void lcd_print(const char *fmt, ...)
+{
+	va_list args;
+
+	if (lcd_print_flag == 0)
+		return;
+	va_start(args, fmt);
+	vprintk(fmt, args);
+	va_end(args);
+}
+
 static inline void lcd_mdelay(int n)
 {
 	mdelay(n);
@@ -368,6 +371,9 @@ static int lcd_set_current_vmode2(vmode_t mode)
 
 static vmode_t lcd_validate_vmode(char *mode)
 {
+    if (mode == NULL)
+        return VMODE_MAX;
+
     if ((strncmp(mode, PANEL_NAME, strlen(PANEL_NAME))) == 0)
         return VMODE_LCD;
     
@@ -1684,11 +1690,11 @@ static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pd
                             break;
                         }
                         else {
-                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+2), &val);
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+DSI_CMD_CNT_INDEX), &val);
                             if (val > 0xffff)
                                 break;
                             else
-                                i = i + 3 + (val & 0xff);
+                                i = i + (DSI_CMD_CNT_INDEX + 1) + (val & 0xff);
                         }
                     }
                     i = (i > DSI_INIT_ON_MAX) ? DSI_INIT_ON_MAX : i;
@@ -1727,11 +1733,11 @@ static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pd
                             break;
                         }
                         else {
-                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+2), &val);
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+DSI_CMD_CNT_INDEX), &val);
                             if (val > 0xffff)
                                 break;
                             else
-                                i = i + 3 + (val & 0xff);
+                                i = i + (DSI_CMD_CNT_INDEX + 1) + (val & 0xff);
                         }
                     }
                     i = (i > DSI_INIT_OFF_MAX) ? DSI_INIT_OFF_MAX : i;
diff --git a/include/linux/amlogic/vout/lcdoutc.h b/include/linux/amlogic/vout/lcdoutc.h
index bf598a3535dc..066db6b05ecc 100755
--- a/include/linux/amlogic/vout/lcdoutc.h
+++ b/include/linux/amlogic/vout/lcdoutc.h
@@ -180,6 +180,7 @@ typedef struct {
 } Lcd_Effect_t;
 
 //mipi-dsi config
+#define DSI_CMD_CNT_INDEX         1 //byte[1]
 #define DSI_INIT_ON_MAX           100
 #define DSI_INIT_OFF_MAX          30
 
-- 
2.19.0

