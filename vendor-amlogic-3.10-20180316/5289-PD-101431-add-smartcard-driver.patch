From b565f41bc0c546f74df288f9d2962739c641e902 Mon Sep 17 00:00:00 2001
From: "zhenwu.che" <zhenwu.che@amlogic.com>
Date: Sun, 4 Jan 2015 13:51:43 +0800
Subject: [PATCH 5289/5965] PD#101431:add smartcard driver

Change-Id: I8ebff59e8011e9a05577994eba8e49c030e476bc
---
 .../dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd |   26 +
 arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd |   90 +
 drivers/amlogic/smartcard/Kconfig             |   14 +
 drivers/amlogic/smartcard/smartcard.c         | 2458 +++++++++--------
 drivers/amlogic/smartcard/smc_reg.h           |    9 +-
 include/linux/amlogic/amsmc.h                 |    2 +
 6 files changed, 1498 insertions(+), 1101 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd
index 4630163a8e2f..e5f6c85c2119 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd
@@ -1862,6 +1862,14 @@ sdio{
 			amlogic,pins = "GPIOY_6";
 		};
 
+		smc_pins:smc_pins {
+		amlogic,setmask = <4 0xC0000>;
+		amlogic,clrmask = <4 0x3F0
+								3 0x1000>;
+		amlogic,pins= "GPIOX_18","GPIOX_19";
+		
+		};
+
 	};
 /// ***************************************************************************************
 ///	-	Ethernet
@@ -1924,6 +1932,24 @@ sdio{
 		pinctrl-0 = <&dvb_fe_pins>;
 	};
 
+	smartcard {
+		compatible = "amlogic,smartcard";
+		smc0_irq = <69>;
+		//smc0_enable_pin = "GPIOX_16";
+		//smc0_enable_level = <1>;
+		smc0_reset_pin = "GPIOX_17";
+		smc0_reset_level = <0>;
+		smc0_clk_pinmux_reg = <0x2030>;
+		smc0_clk_pinmux_bit = <0x80000>;
+		smc0_clk_oen_reg = <0x200C>;
+		smc0_clk_out_reg = <0x200D>;
+		//smc0_clk_pin = "GPIOX_18";
+		smc0_clk_bit = <0x40000>;
+		smc0_det_pin = "GPIOX_16";
+		pinctrl-names = "default";
+		pinctrl-0 = <&smc_pins>;
+	};
+
 /// ***************************************************************************************
 ///	-	RNG
 //$$ MODULE="RNG"
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd
index fc181a974c12..3891da8819c4 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd
@@ -1891,7 +1891,34 @@ void root_func(){
 			amlogic,clrmask=<2 0x380000>;
 			amlogic,pins = "BOOT_11","BOOT_12","BOOT_13","BOOT_18";
 		};
+//$$ MATCH "dvb_p_ts0_pins_match" = "&dvb_p_ts0_pins"
+//$$ L2 PROP_U32 1 = "amlogic,setmask"
+//$$ L2 PROP_U32 2 = "amlogic,clrmask"
+//$$ L2 PROP_STR 11 = "amlogic,pins"
+		dvb_p_ts0_pins: dvb_p_ts0_pins {
+			amlogic,setmask = <3 0x37>;
+			amlogic,clrmask = <5 0xC0
+								9 0x37C>;
+			amlogic,pins = "GPIOY_9","GPIOY_10","GPIOY_11","GPIOY_12","GPIOY_13","GPIOY_14","GPIOY_6","GPIOY_7","GPIOY_0","GPIOY_1","GPIOY_8";
+		};
 
+//$$ MATCH "dvb_s_ts0_pins_match" = "&dvb_s_ts0_pins"
+//$$ L2 PROP_U32 1 = "amlogic,setmask"
+//$$ L2 PROP_U32 1 = "amlogic,clrmask"
+//$$ L2 PROP_STR 4 = "amlogic,pins"
+		dvb_s_ts0_pins: dvb_s_ts0_pins {
+			amlogic,setmask = <3 0x17>;
+			amlogic,clrmask = <9 0x378>;
+			amlogic,pins = "GPIOY_9","GPIOY_0","GPIOY_1","GPIOY_8";
+		};
+		
+		smc_pins:smc_pins {
+		amlogic,setmask = <4 0xC0000>;
+		amlogic,clrmask = <4 0x3F0
+								3 0x1000>;
+		amlogic,pins= "GPIOX_18","GPIOX_19";
+		
+		};
 	};
 /// ***************************************************************************************
 ///	-	Ethernet
@@ -1912,5 +1939,68 @@ void root_func(){
 		compatible = "amlogic,meson-rng";
 		status = "ok";
 	};
+///	-	DVB
+//$$ MODULE="DVB"
+
+//$$ DEVICE="dvb"
+//$$ L2 PROP_STR = "ts0"
+//$$ L2 PROP_U32 = "ts0_invert"
+//$$ L2 PROP_U32 = "ts0_control"
+//$$ L2 PROP_STR 6 = "pinctrl-names"
+//$$ L2 PROP_CHOICE "dvb_p_ts0_pins_match" = "pinctrl-0"
+//$$ L2 PROP_CHOICE "dvb_s_ts0_pins_match" = "pinctrl-1"
+	dvb{
+		compatible = "amlogic,dvb";
+		/*"parallel","serial","disable"*/
+		ts0 = "parallel";
+		ts0_control = <0>;
+		ts0_invert = <0>;
+		pinctrl-names = "p_ts0", "s_ts0";
+		pinctrl-0 = <&dvb_p_ts0_pins>;
+		pinctrl-1 = <&dvb_s_ts0_pins>;
+	};
+
+//$$ DEVICE="dvbfe"
+//$$ L2 PROP_STR = "dtv_demod0"
+//$$ L2 PROP_U32 = "dtv_demod0_i2c_adap_id"
+//$$ L2 PROP_U32 = "dtv_demod0_i2c_addr"
+//$$ L2 PROP_U32 = "dtv_demod0_reset_value"
+//$$ L2 PROP_STR = "dtv_demod0_reset_gpio"
+//$$ L2 PROP_U32 = "fe0_dtv_demod"
+//$$ L2 PROP_U32 = "fe0_ts"
+//$$ L2 PROP_U32 = "fe0_dev"
+//$$ L2 PROP_STR 6 = "pinctrl-names"
+//$$ L2 PROP_CHOICE "dvb_fe_pins_match" = "pinctrl-0"
+
+
+	dvbfe{
+		compatible = "amlogic,dvbfe";
+		dtv_demod0 = "Mxl241";
+		dtv_demod0_i2c_adap_id = <2>;
+		dtv_demod0_i2c_addr = <0x60>;
+		dtv_demod0_reset_value = <0>;
+		dtv_demod0_reset_gpio = "GPIOY_3";
+		fe0_dtv_demod = <0>;
+		fe0_ts = <0>;
+		fe0_dev = <0>;
+	};
+	
+	smartcard {
+		compatible = "amlogic,smartcard";
+		smc0_irq = <69>;
+		//smc0_enable_pin = "GPIOX_16";
+		//smc0_enable_level = <1>;
+		smc0_reset_pin = "GPIOX_17";
+		smc0_reset_level = <0>;
+		smc0_clk_pinmux_reg = <0x2030>;
+		smc0_clk_pinmux_bit = <0x80000>;
+		smc0_clk_oen_reg = <0x200C>;
+		smc0_clk_out_reg = <0x200D>;
+		//smc0_clk_pin = "GPIOX_18";
+		smc0_clk_bit = <0x40000>;
+		smc0_det_pin = "GPIOX_16";
+		pinctrl-names = "default";
+		pinctrl-0 = <&smc_pins>;
+	};
 
 }; /* end of / */
diff --git a/drivers/amlogic/smartcard/Kconfig b/drivers/amlogic/smartcard/Kconfig
index b4cda3bc85d9..382a69a92a64 100755
--- a/drivers/amlogic/smartcard/Kconfig
+++ b/drivers/amlogic/smartcard/Kconfig
@@ -9,5 +9,19 @@ config AM_SMARTCARD
 	default n
 	help
 		Select to enable Smartcard driver.
+
+if AM_SMARTCARD
+config AM_SMARTCARD_GPIO_FOR_DET
+	bool "Use GPIO for DETECT pin"
+	default n
+	help
+		Select to enable DETECT in GPIO mode.
+
+config AM_SMARTCARD_GPIO_FOR_RST
+	bool "Use GPIO for RESET pin"
+	default n
+	help
+		Select to enable RESET in GPIO mode.
+endif
 endmenu
 
diff --git a/drivers/amlogic/smartcard/smartcard.c b/drivers/amlogic/smartcard/smartcard.c
index c4ad78f8d868..a7a1ad70545d 100755
--- a/drivers/amlogic/smartcard/smartcard.c
+++ b/drivers/amlogic/smartcard/smartcard.c
@@ -37,17 +37,22 @@
 #include "linux/clk.h"
 #include <mach/am_regs.h>
 #endif
-#include <mach/devio_aml.h>
-#include <mach/gpio.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
 #include <linux/poll.h>
 #include <linux/delay.h>
-#include <linux/amlogic/amsmc.h>
+#include <mach/gpio.h>
 #include <linux/platform_device.h>
-#include <linux/time.h>
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #include <mach/mod_gate.h>
+#include <mach/power_gate.h>
+#endif
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE>= KERNEL_VERSION(3,10,0)
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/amlogic/amsmc.h>
+#else
+#include <linux/amsmc.h>
 #endif
 
 #include "smc_reg.h"
@@ -57,14 +62,69 @@
 #define DEVICE_NAME "amsmc"
 #define CLASS_NAME  "amsmc-class"
 
-#if 0
-#define pr_dbg(fmt, args...) printk("Smartcard: " fmt, ## args)
+#define FILE_DEBUG
+
+#ifdef FILE_DEBUG
+#include <linux/fs.h>
+#define DEBUG_FILE_NAME     "/storage/external_storage/debug.smc"
+static struct file* debug_filp = NULL;
+static loff_t debug_file_pos = 0;
+
+void debug_write(const char __user *buf, size_t count)
+{
+    mm_segment_t old_fs;
+
+    if (!debug_filp)
+        return;
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    if (count != vfs_write(debug_filp, buf, count, &debug_file_pos)) {
+        printk("Failed to write debug file\n");
+    }
+    set_fs(old_fs);
+
+    return;
+}
+void open_debug(void) {
+    debug_filp = filp_open(DEBUG_FILE_NAME, O_WRONLY, 0);
+    if (IS_ERR(debug_filp)) {
+        printk("smartcard: open debug file failed\n");
+        debug_filp = NULL;
+    }else {
+		printk("smc: debug file[%s] open.\n", DEBUG_FILE_NAME);
+    }
+}
+void close_debug(void) {
+    if (debug_filp) {
+        filp_close(debug_filp, current->files);
+        debug_filp = NULL;
+        debug_file_pos = 0;
+    }
+	printk("smc: debug file close.\n");
+}
+#endif
+
+#ifdef FILE_DEBUG
+char dbuf[512*2];
+int cnt;
+#define pr_dbg(fmt, args...) do { if(smc_debug>0) {cnt = sprintf(dbuf, "Smartcard: " fmt, ## args);debug_write(dbuf, cnt);}} while(0)
+#define Fpr(a...)            do { if(smc_debug>1) {cnt = sprintf(dbuf, a);debug_write(dbuf, cnt);}} while(0)
+#define Ipr                  Fpr
+#else
+#if 1
+#define pr_dbg(fmt, args...) do { if(smc_debug>0) printk("Smartcard: " fmt, ## args);} while(0)
+#define Fpr(a...)            do { if(smc_debug>1) printk(a);} while(0)
+#define Ipr                  Fpr
 #else
 #define pr_dbg(fmt, args...)
+#define Fpr(a...)
+#endif
 #endif
 
 #define pr_error(fmt, args...) printk(KERN_ERR "Smartcard: " fmt, ## args)
 
+
 MODULE_PARM_DESC(smc0_irq, "\n\t\t Irq number of smartcard0");
 static int smc0_irq = -1;
 module_param(smc0_irq, int, S_IRUGO);
@@ -73,17 +133,61 @@ MODULE_PARM_DESC(smc0_reset, "\n\t\t Reset GPIO pin of smartcard0");
 static int smc0_reset = -1;
 module_param(smc0_reset, int, S_IRUGO);
 
+MODULE_PARM_DESC(smc_debug, "\n\t\t more debug info");
+static int smc_debug = 0;
+module_param(smc_debug, int, 0644);
+
+MODULE_PARM_DESC(atr_delay, "\n\t\t atr delay");
+static int atr_delay = 0;
+module_param(atr_delay, int, 0644);
+
+MODULE_PARM_DESC(atr_holdoff, "\n\t\t atr_holdoff");
+static int atr_holdoff = 1;
+module_param(atr_holdoff, int, 0644);
+
+MODULE_PARM_DESC(cwt_det_en, "\n\t\t cwt_det_en");
+static int cwt_det_en = 1;
+module_param(cwt_det_en, int, 0644);
+
 #define NO_HOT_RESET
 //#define DISABLE_RECV_INT
 #define ATR_FROM_INT
+#define SW_INVERT
+#define SMC_FIQ
+
+#ifdef CONFIG_AM_SMARTCARD_GPIO_FOR_DET
+#define DET_FROM_PIO
+#endif
+#ifdef CONFIG_AM_SMARTCARD_GPIO_FOR_RST
+#define RST_FROM_PIO
+#endif
+
+#ifndef  CONFIG_MESON_ARM_GIC_FIQ
+#undef SMC_FIQ
+#endif
+
+#ifdef SMC_FIQ
+#include <plat/fiq_bridge.h>
+#ifndef ATR_FROM_INT
+#define ATR_FROM_INT
+#endif
+#endif
 
+#ifdef SMC_FIQ
+#define RECV_BUF_SIZE     1024
+#define SEND_BUF_SIZE     1024
+#else
 #define RECV_BUF_SIZE     512
 #define SEND_BUF_SIZE     512
+#endif
 
-#define RESET_ENABLE      (smc->reset_level)
-#define RESET_DISABLE     (!smc->reset_level)
+#define RESET_ENABLE      (smc->reset_level)  //reset
+#define RESET_DISABLE     (!smc->reset_level) //dis-reset
 
-#define VBUS_SMC_RESET_GPIO_OWNER  "SMARTCARD"
+typedef enum sc_type {
+	SC_DIRECT,
+	SC_INVERSE,
+} sc_type_t;
 
 typedef struct {
 	int                id;
@@ -105,11 +209,45 @@ typedef struct {
 	char               send_buf[SEND_BUF_SIZE];
 	struct am_smc_param param;
 	struct am_smc_atr   atr;
-	u32                reset_pin;
-	int 			(*reset)(void *, int);
+
+	u32                enable_pin;
+#define SMC_ENABLE_PIN_NAME "smc:ENABLE"
+	int 			   enable_level;
+
+	int                (*reset)(void *, int);
 	u32                irq_num;
 	int                reset_level;
-	struct pinctrl     *pinctrl;
+
+	u32              pin_clk_pinmux_reg;
+	u32              pin_clk_pinmux_bit;
+	u32              pin_clk_pin;
+#define SMC_CLK_PIN_NAME "smc:PINCLK"
+	u32              pin_clk_oen_reg;
+	u32              pin_clk_out_reg;
+	u32              pin_clk_bit;
+
+#ifdef SW_INVERT
+	int                atr_mode;
+	sc_type_t          sc_type;
+#endif
+
+#ifdef SMC_FIQ
+	int 			   recv_end;
+	int 			   send_end;
+	bridge_item_t      smc_fiq_bridge;
+#endif
+
+#ifdef DET_FROM_PIO
+	u32                detect_pin;
+#define SMC_DETECT_PIN_NAME "smc:DETECT"
+#endif
+#ifdef RST_FROM_PIO
+		u32 		   reset_pin;
+#define SMC_RESET_PIN_NAME "smc:RESET"
+#endif
+	
+
+	struct pinctrl	   *pinctrl;
 } smc_dev_t;
 
 #define SMC_DEV_NAME     "smc"
@@ -118,44 +256,42 @@ typedef struct {
 
 #define SMC_READ_REG(a)           READ_MPEG_REG(SMARTCARD_##a)
 #define SMC_WRITE_REG(a,b)        WRITE_MPEG_REG(SMARTCARD_##a,b)
-#define SUSPEND_CARD_STATUS         (0xFF)
-/** to enable this in
-*** System Tyep-->Amlogic Meson platform-->ARM Generic Interrupt Controller FIQ
-*** by make menuconfig if default not be set to y
-*** which is used to solve IRQ not responsed sometimes
-**/
-#ifdef  CONFIG_MESON_ARM_GIC_FIQ
-#define SMC_FIQ
-#endif
+
 static struct mutex smc_lock;
 static int          smc_major;
 static smc_dev_t    smc_dev[SMC_DEV_COUNT];
 static int ENA_GPIO_PULL = 1;
-static int smc_status = -1;
 
-#ifdef SMC_FIQ
-#include <plat/fiq_bridge.h>
-#define SMC_CNT     (1024)
-static char smc_send_data[SMC_CNT];
-static char smc_recv_data[SMC_CNT];
-static char smc_recv_data_bak[SMC_CNT];//for debug only and only be reset if another serial data be sent to smartcard
-//the smc_write_idx always >= smc_write_fiq_idx
-static int smc_write_idx = -1;
-static int smc_write_fiq_idx = -1;
-//the smc_read_idx always <= smc_read_fiq_idx
-static int smc_read_fiq_idx = -1;
-static int smc_recv_bak_idx = -1;
-static int smc_read_idx = -1;
-static int smc_cardin = -1;
-static int smc_debug_flag = 0;
-//volatile
-wait_queue_head_t  *smc_rd_wq;
-//volatile
-wait_queue_head_t  *smc_wr_wq;
-static struct timer_list smc_wakeup_wq_timer;
-static bridge_item_t smc_fiq_bridge;
-static void smc_print_data(char buf[], int cnt);
-#endif
+#ifdef SW_INVERT
+static const unsigned char inv_table[256] = {
+	0xFF, 0x7F, 0xBF, 0x3F, 0xDF, 0x5F, 0x9F, 0x1F, 0xEF, 0x6F, 0xAF, 0x2F, 0xCF, 0x4F, 0x8F, 0x0F,
+	0xF7, 0x77, 0xB7, 0x37, 0xD7, 0x57, 0x97, 0x17, 0xE7, 0x67, 0xA7, 0x27, 0xC7, 0x47, 0x87, 0x07,
+	0xFB, 0x7B, 0xBB, 0x3B, 0xDB, 0x5B, 0x9B, 0x1B, 0xEB, 0x6B, 0xAB, 0x2B, 0xCB, 0x4B, 0x8B, 0x0B,
+	0xF3, 0x73, 0xB3, 0x33, 0xD3, 0x53, 0x93, 0x13, 0xE3, 0x63, 0xA3, 0x23, 0xC3, 0x43, 0x83, 0x03,
+	0xFD, 0x7D, 0xBD, 0x3D, 0xDD, 0x5D, 0x9D, 0x1D, 0xED, 0x6D, 0xAD, 0x2D, 0xCD, 0x4D, 0x8D, 0x0D,
+	0xF5, 0x75, 0xB5, 0x35, 0xD5, 0x55, 0x95, 0x15, 0xE5, 0x65, 0xA5, 0x25, 0xC5, 0x45, 0x85, 0x05,
+	0xF9, 0x79, 0xB9, 0x39, 0xD9, 0x59, 0x99, 0x19, 0xE9, 0x69, 0xA9, 0x29, 0xC9, 0x49, 0x89, 0x09,
+	0xF1, 0x71, 0xB1, 0x31, 0xD1, 0x51, 0x91, 0x11, 0xE1, 0x61, 0xA1, 0x21, 0xC1, 0x41, 0x81, 0x01,
+	0xFE, 0x7E, 0xBE, 0x3E, 0xDE, 0x5E, 0x9E, 0x1E, 0xEE, 0x6E, 0xAE, 0x2E, 0xCE, 0x4E, 0x8E, 0x0E,
+	0xF6, 0x76, 0xB6, 0x36, 0xD6, 0x56, 0x96, 0x16, 0xE6, 0x66, 0xA6, 0x26, 0xC6, 0x46, 0x86, 0x06,
+	0xFA, 0x7A, 0xBA, 0x3A, 0xDA, 0x5A, 0x9A, 0x1A, 0xEA, 0x6A, 0xAA, 0x2A, 0xCA, 0x4A, 0x8A, 0x0A,
+	0xF2, 0x72, 0xB2, 0x32, 0xD2, 0x52, 0x92, 0x12, 0xE2, 0x62, 0xA2, 0x22, 0xC2, 0x42, 0x82, 0x02,
+	0xFC, 0x7C, 0xBC, 0x3C, 0xDC, 0x5C, 0x9C, 0x1C, 0xEC, 0x6C, 0xAC, 0x2C, 0xCC, 0x4C, 0x8C, 0x0C,
+	0xF4, 0x74, 0xB4, 0x34, 0xD4, 0x54, 0x94, 0x14, 0xE4, 0x64, 0xA4, 0x24, 0xC4, 0x44, 0x84, 0x04,
+	0xF8, 0x78, 0xB8, 0x38, 0xD8, 0x58, 0x98, 0x18, 0xE8, 0x68, 0xA8, 0x28, 0xC8, 0x48, 0x88, 0x08,
+	0xF0, 0x70, 0xB0, 0x30, 0xD0, 0x50, 0x90, 0x10, 0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00 
+};
+#endif /*SW_INVERT*/
+
+#define dump(b, l) do { \
+	int i; \
+	pr_dbg("dump: "); \
+	for(i=0; i<(l); i++) \
+		pr_dbg("%02x ", *(((unsigned char*)(b))+i)); \
+	pr_dbg("\n"); \
+	}while(0)
+
+
 static ssize_t show_gpio_pull(struct class *class, struct class_attribute *attr,	char *buf)
 {
 	if(ENA_GPIO_PULL > 0)
@@ -178,60 +314,8 @@ static ssize_t set_gpio_pull(struct class *class, struct class_attribute *attr,
     return count;
 }
 
-#ifdef SMC_FIQ
-static ssize_t smc_show_communication_state(struct class *class, struct class_attribute *attr,	const char *buf, size_t count)
-{
-    unsigned int dbg;
-    ssize_t r;
-
-    r = sscanf(buf, "%d", &dbg);
-
-    if(smc_debug_flag > 0){
-        if(dbg ==0)
-        {
-            printk(KERN_ALERT"communication OK......\n");
-        }else{
-            printk(KERN_ALERT"communication failed dbg:%d, smc_recv_bak_idx:%d:\n", dbg, smc_recv_bak_idx);
-            smc_print_data(smc_recv_data_bak, smc_recv_bak_idx);
-        }
-    }
-    return count;
-}
-
-static ssize_t smc_show_debug(struct class *class, struct class_attribute *attr,	char *buf)
-{
-    printk(KERN_ALERT"the smc debug flag is:0x%x.\n", smc_debug_flag);
-
-    if(smc_debug_flag > 0)
-        return sprintf(buf, "%s\n","smc debug enabled.");
-    else
-        return sprintf(buf, "%s\n","smc debug disabled.");
-}
-
-static ssize_t smc_store_debug(struct class *class, struct class_attribute *attr,	const char *buf, size_t count)
-{
-    unsigned int dbg;
-    ssize_t r;
-
-    r = sscanf(buf, "%d", &dbg);
-
-    printk(KERN_ALERT"set the smc debug flag to:0x%x.\n", dbg);
-
-    if(dbg > 0)
-        smc_debug_flag = dbg;
-    else
-        smc_debug_flag = 0;
-
-    return count;
-}
-#endif
-
 static struct class_attribute smc_class_attrs[] = {
-    __ATTR(smc_gpio_pull,  S_IRUGO | S_IWUSR, show_gpio_pull,    set_gpio_pull),
-#ifdef SMC_FIQ
-    __ATTR(smc_com_state,  S_IRUGO | S_IWUSR, NULL,    smc_show_communication_state),
-    __ATTR(smc_debug,  S_IRUGO | S_IWUSR, smc_show_debug,    smc_store_debug),
-#endif
+	__ATTR(smc_gpio_pull,  S_IRUGO | S_IWUSR, show_gpio_pull,    set_gpio_pull),
     __ATTR_NULL
 };
 
@@ -267,35 +351,91 @@ static unsigned long get_module_clk(int sel)
 		case 2: clk = get_clk("fixed")/5; break;
 		case 3: clk = get_clk("xtal"); break;
 	}
-#else /*M6TV*/
-	/*sel = [0:fclk-div2, 1:fclk-div3, 2:fclk-div5, 3:XTAL]*/
+#else
+	/*sel = [0:fclk-div2/fclk-div4(M8 and further), 1:fclk-div3, 2:fclk-div5, 3:XTAL]*/
 	switch(sel)
 	{
+#if defined(MESON_CPU_TYPE_MESON8) && (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+		case 0: clk = get_clk("pll_fixed")/4;break;
+#else/*M6TV/TVD/TVLITE*/
 		case 0: clk = 1000000000; break;
 		//case 0: clk = get_clk("fixed")/2; break;
-		case 1: clk = get_clk("fixed")/3; break;
-		case 2: clk = get_clk("fixed")/5; break;
+#endif
+		case 1: clk = get_clk("pll_fixed")/3; break;
+		case 2: clk = get_clk("pll_fixed")/5; break;
 		case 3: clk = get_clk("xtal"); break;
 	}
 #endif /*M6*/
 
 	if(!clk)
-		printk("fail: unknown clk source");
+		pr_error("fail: unknown clk source");
 
 	return clk;
 
 #endif
 }
 
+static int _gpio_request(unsigned int gpio, const char *owner)
+{
+#if LINUX_VERSION_CODE>= KERNEL_VERSION(3,10,0)
+	amlogic_gpio_request(gpio, owner);
+#else
+	gpio_request(gpio, owner);
+#endif
+	return 0;
+}
+
+static int _gpio_out(unsigned int gpio, int val, const char *owner)
+{
+	if(val<0) {
+		pr_error("gpio out val=-1.\n");
+		return -1;
+	}
+
+#if LINUX_VERSION_CODE>= KERNEL_VERSION(3,10,0)
+	amlogic_gpio_direction_output(gpio, val, owner);
+#else
+	gpio_out(gpio, val);
+#endif
+
+	return 0;
+}
+
+#ifdef DET_FROM_PIO
+static int _gpio_in(unsigned int gpio, const char *owner)
+{
+	int ret=0;
+
+#if LINUX_VERSION_CODE>= KERNEL_VERSION(3,10,0)
+	ret = amlogic_get_value(gpio, owner);
+#else
+	ret = gpio_in_get(gpio);
+#endif
+
+	return ret;
+}
+#endif
+static int _gpio_free(unsigned int gpio, const char *owner)
+{
+
+#if LINUX_VERSION_CODE>= KERNEL_VERSION(3,10,0)
+	amlogic_gpio_free(gpio, owner);
+#else
+	gpio_free(gpio);
+#endif
+
+	return 0;
+}
+
 static int inline smc_write_end(smc_dev_t *smc)
 {
 	int ret;
 	unsigned long flags;
-
+	
 	spin_lock_irqsave(&smc->slock, flags);
 	ret = (!smc->cardin || !smc->send_count);
 	spin_unlock_irqrestore(&smc->slock, flags);
-
+	
 	return ret;
 }
 
@@ -304,11 +444,11 @@ static int inline smc_can_read(smc_dev_t *smc)
 {
 	int ret;
 	unsigned long flags;
-
+	
 	spin_lock_irqsave(&smc->slock, flags);
 	ret = (!smc->cardin || smc->recv_count);
 	spin_unlock_irqrestore(&smc->slock, flags);
-
+	
 	return ret;
 }
 
@@ -316,11 +456,10 @@ static int inline smc_can_write(smc_dev_t *smc)
 {
 	int ret;
 	unsigned long flags;
-
+	
 	spin_lock_irqsave(&smc->slock, flags);
 	ret = (!smc->cardin || (smc->send_count!=SEND_BUF_SIZE));
 	spin_unlock_irqrestore(&smc->slock, flags);
-
 	return ret;
 }
 
@@ -328,28 +467,78 @@ static int smc_hw_set_param(smc_dev_t *smc)
 {
 	unsigned long v=0;
 	SMCCARD_HW_Reg0_t *reg0;
-	//SMC_ANSWER_TO_RST_t *reg1;
-	//SMCCARD_HW_Reg2_t *reg2;
-	//SMC_INTERRUPT_Reg_t *reg_int;
-	//SMCCARD_HW_Reg5_t *reg5;
 	SMCCARD_HW_Reg6_t *reg6;
+	SMCCARD_HW_Reg2_t *reg2;
+	SMCCARD_HW_Reg5_t *reg5;
+/*
+	SMC_ANSWER_TO_RST_t *reg1;
+	SMC_INTERRUPT_Reg_t *reg_int;
+*/
+	unsigned sys_clk_rate = get_module_clk(CLK_SRC_DEFAULT);
+	unsigned long freq_cpu = sys_clk_rate/1000;
 
 	v = SMC_READ_REG(REG0);
 	reg0 = (SMCCARD_HW_Reg0_t*)&v;
 	reg0->etu_divider = ETU_DIVIDER_CLOCK_HZ*smc->param.f/(smc->param.d*smc->param.freq)-1;
 	SMC_WRITE_REG(REG0, v);
 
+	v = SMC_READ_REG(REG2);
+	reg2 = (SMCCARD_HW_Reg2_t*)&v;
+	reg2->recv_invert = smc->param.recv_invert;
+	reg2->recv_parity = smc->param.recv_parity;
+	reg2->recv_lsb_msb = smc->param.recv_lsb_msb;
+	reg2->xmit_invert = smc->param.xmit_invert;
+	reg2->xmit_parity = smc->param.xmit_parity;
+	reg2->xmit_lsb_msb = smc->param.xmit_lsb_msb;   
+	reg2->xmit_retries = smc->param.xmit_retries;
+	reg2->xmit_repeat_dis = smc->param.xmit_repeat_dis;
+	reg2->recv_no_parity = smc->param.recv_no_parity;
+	reg2->clk_tcnt = freq_cpu/smc->param.freq - 1;
+	reg2->det_filter_sel = DET_FILTER_SEL_DEFAULT;
+	reg2->io_filter_sel = IO_FILTER_SEL_DEFAULT; 
+	reg2->clk_sel = CLK_SRC_DEFAULT;
+	//reg2->pulse_irq = 0;
+	SMC_WRITE_REG(REG2, v);
+
+	v = SMC_READ_REG(REG5);
+	reg5 = (SMCCARD_HW_Reg5_t*)&v;
+	//reg5->cwt_detect_en = 1;
+	reg5->bwt_base_time_gnt = BWT_BASE_DEFAULT;
+	SMC_WRITE_REG(REG5, v);
+
 	v = SMC_READ_REG(REG6);
 	reg6 = (SMCCARD_HW_Reg6_t*)&v;
-	reg6->N_parameter = smc->param.n;
 	reg6->cwi_value = smc->param.cwi;
-	reg6->bgt = smc->param.bgt;
 	reg6->bwi = smc->param.bwi;
+	reg6->bgt = smc->param.bgt-2;
+	reg6->N_parameter = smc->param.n;
 	SMC_WRITE_REG(REG6, v);
 
 	return 0;
 }
 
+/*
+static int smc_hw_get_param(smc_dev_t *smc)
+{
+	unsigned long v=0;
+	SMCCARD_HW_Reg0_t *reg0;
+	SMC_ANSWER_TO_RST_t *reg1;
+	SMCCARD_HW_Reg2_t *reg2;
+	SMC_INTERRUPT_Reg_t *reg_int;
+	SMCCARD_HW_Reg5_t *reg5;
+	SMCCARD_HW_Reg6_t *reg6;
+
+	v = SMC_READ_REG(REG0);
+	printk("REG0:0X%08X\n", v);
+	v = SMC_READ_REG(REG2);
+	printk("REG2:0X%08X\n", v);
+	v = SMC_READ_REG(REG6);
+	printk("REG6:0X%08X\n", v);
+
+	return 0;
+}
+*/
+
 static int smc_hw_setup(smc_dev_t *smc)
 {
 	unsigned long v=0;
@@ -364,8 +553,12 @@ static int smc_hw_setup(smc_dev_t *smc)
 
 	unsigned long freq_cpu = sys_clk_rate/1000;
 
-	printk("SMC CLK SOURCE - %luKHz\n", freq_cpu);
+	pr_error("SMC CLK SOURCE - %luKHz\n", freq_cpu);
 
+#ifdef RST_FROM_PIO
+	_gpio_out(smc->reset_pin, RESET_ENABLE, SMC_RESET_PIN_NAME);
+#endif
+	
 	v = SMC_READ_REG(REG0);
 	reg0 = (SMCCARD_HW_Reg0_t*)&v;
 	reg0->enable = 1;
@@ -374,37 +567,55 @@ static int smc_hw_setup(smc_dev_t *smc)
 	reg0->card_detect = 0;
 	reg0->start_atr = 0;
 	reg0->start_atr_en = 0;
-	reg0->rst_level = RESET_DISABLE;
+	reg0->rst_level = RESET_ENABLE;
 	reg0->io_level = 0;
 	reg0->recv_fifo_threshold = FIFO_THRESHOLD_DEFAULT;
 	reg0->etu_divider = ETU_DIVIDER_CLOCK_HZ*smc->param.f/(smc->param.d*smc->param.freq)-1;
+	reg0->first_etu_offset = 5;
 	SMC_WRITE_REG(REG0, v);
+	pr_error("REG0: 0x%08lx\n", v);
+	pr_error("f       :%d\n", smc->param.f);	
+	pr_error("d       :%d\n", smc->param.d);
+	pr_error("freq    :%d\n", smc->param.freq);
 
 	v = SMC_READ_REG(REG1);
 	reg1 = (SMC_ANSWER_TO_RST_t*)&v;
 	reg1->atr_final_tcnt = ATR_FINAL_TCNT_DEFAULT;
 	reg1->atr_holdoff_tcnt = ATR_HOLDOFF_TCNT_DEFAULT;
 	reg1->atr_clk_mux = ATR_CLK_MUX_DEFAULT;
-	reg1->atr_holdoff_en = ATR_HOLDOFF_EN;
+	reg1->atr_holdoff_en = atr_holdoff;//ATR_HOLDOFF_EN;
+	reg1->etu_clk_sel = ETU_CLK_SEL;
 	SMC_WRITE_REG(REG1, v);
-
+	pr_error("REG1: 0x%08lx\n", v);
+	
 	v = SMC_READ_REG(REG2);
 	reg2 = (SMCCARD_HW_Reg2_t*)&v;
 	reg2->recv_invert = smc->param.recv_invert;
+	reg2->recv_parity = smc->param.recv_parity;
 	reg2->recv_lsb_msb = smc->param.recv_lsb_msb;
 	reg2->xmit_invert = smc->param.xmit_invert;
-	reg2->xmit_lsb_msb = smc->param.xmit_lsb_msb;
+	reg2->xmit_lsb_msb = smc->param.xmit_lsb_msb;	
 	reg2->xmit_retries = smc->param.xmit_retries;
 	reg2->xmit_repeat_dis = smc->param.xmit_repeat_dis;
 	reg2->recv_no_parity = smc->param.recv_no_parity;
 	reg2->clk_tcnt = freq_cpu/smc->param.freq - 1;
 	reg2->det_filter_sel = DET_FILTER_SEL_DEFAULT;
-	reg2->io_filter_sel = IO_FILTER_SEL_DEFAULT;
+	reg2->io_filter_sel = IO_FILTER_SEL_DEFAULT; 
 	reg2->clk_sel = CLK_SRC_DEFAULT;
 	//reg2->pulse_irq = 0;
 	SMC_WRITE_REG(REG2, v);
-
-	v = SMC_READ_REG(INTR);
+	pr_error("REG2: 0x%08lx\n", v);
+	pr_error("recv_inv:%d\n", smc->param.recv_invert);
+	pr_error("recv_lsb:%d\n", smc->param.recv_lsb_msb);
+	pr_error("recv_par:%d\n", smc->param.recv_parity);
+	pr_error("recv_npa:%d\n", smc->param.recv_no_parity);
+	pr_error("xmit_inv:%d\n", smc->param.xmit_invert);
+	pr_error("xmit_lsb:%d\n", smc->param.xmit_lsb_msb);
+	pr_error("xmit_par:%d\n", smc->param.xmit_parity);
+	pr_error("xmit_rep:%d\n", smc->param.xmit_repeat_dis);
+	pr_error("xmit_try:%d\n", smc->param.xmit_retries);
+	
+	v = SMC_READ_REG(INTR);	
 	reg_int = (SMC_INTERRUPT_Reg_t*)&v;
 	reg_int->recv_fifo_bytes_threshold_int_mask = 0;
 	reg_int->send_fifo_last_byte_int_mask = 1;
@@ -417,77 +628,109 @@ static int smc_hw_setup(smc_dev_t *smc)
 	reg_int->rst_expired_int_mask = 1;
 	reg_int->card_detect_int_mask = 0;
 	SMC_WRITE_REG(INTR,v|0x03FF);
+	pr_error("INTR: 0x%08lx\n", v);
 
 	v = SMC_READ_REG(REG5);
 	reg5 = (SMCCARD_HW_Reg5_t*)&v;
-	reg5->cwt_detect_en = 1;
+	reg5->cwt_detect_en = cwt_det_en;
 	reg5->bwt_base_time_gnt = BWT_BASE_DEFAULT;
 	SMC_WRITE_REG(REG5, v);
+	pr_error("REG5: 0x%08lx\n", v);
 
-
+						
 	v = SMC_READ_REG(REG6);
 	reg6 = (SMCCARD_HW_Reg6_t*)&v;
 	reg6->N_parameter = smc->param.n;
 	reg6->cwi_value = smc->param.cwi;
-	reg6->bgt = smc->param.bgt;
+	reg6->bgt = smc->param.bgt-2;
 	reg6->bwi = smc->param.bwi;
 	SMC_WRITE_REG(REG6, v);
-
+	pr_error("REG6: 0x%08lx\n", v);
+	pr_error("N       :%d\n", smc->param.n);
+	pr_error("cwi     :%d\n", smc->param.cwi);
+	pr_error("bgt     :%d\n", smc->param.bgt);
+	pr_error("bwi     :%d\n", smc->param.bwi);
 	return 0;
 }
 
-static void enable_smc_clk(void){
-    unsigned int _value = READ_CBUS_REG(0x2030);
-    _value |= 0x100000;
-    WRITE_CBUS_REG(0x2030, _value);
-    _value = READ_CBUS_REG(0x2030);
-}
+static void enable_smc_clk(smc_dev_t *smc){
+	unsigned int _value;
 
-static void disable_smc_clk(void){
-    unsigned int _value = READ_CBUS_REG(0x2030);
-    _value &= 0xFFEFFFFF;
-    WRITE_CBUS_REG(0x2030, _value);
-    _value = READ_CBUS_REG(0x2030);
-    return;
-}
+	if((smc->pin_clk_pinmux_reg == -1)
+		|| (smc->pin_clk_pinmux_bit == -1))
+		return;
 
-static int smc_hw_active2(smc_dev_t *smc)
-{
-	if(smc->reset_pin != -1) {
-		amlogic_gpio_direction_output(smc->reset_pin,0,VBUS_SMC_RESET_GPIO_OWNER);
-	}
-    return 0;
+	_value = READ_CBUS_REG(smc->pin_clk_pinmux_reg);
+	_value |= smc->pin_clk_pinmux_bit;
+	WRITE_CBUS_REG(smc->pin_clk_pinmux_reg, _value);
+	_value = READ_CBUS_REG(smc->pin_clk_pinmux_reg);
+
+	pr_dbg("enable smc_clk: mux[%x] \n", _value);
 }
 
-static int smc_hw_deactive2(smc_dev_t *smc)
-{
-	if(smc->reset_pin != -1) {
-		amlogic_gpio_direction_output(smc->reset_pin,1,VBUS_SMC_RESET_GPIO_OWNER);
+static void disable_smc_clk(smc_dev_t *smc){
+	unsigned int _value;
+
+	if((smc->pin_clk_pinmux_reg == -1)
+		|| (smc->pin_clk_pinmux_bit == -1))
+		return;
+
+	_value = READ_CBUS_REG(smc->pin_clk_pinmux_reg);
+	_value &= ~smc->pin_clk_pinmux_bit;
+	WRITE_CBUS_REG(smc->pin_clk_pinmux_reg, _value);
+	_value = READ_CBUS_REG(smc->pin_clk_pinmux_reg);
+
+	pr_dbg("disable smc_clk: mux[%x] \n", _value);
+
+	if((smc->pin_clk_oen_reg != -1)
+		&&(smc->pin_clk_out_reg != -1)
+		&&(smc->pin_clk_bit != -1)) {
+
+		//force the clk pin to low.
+		_value = READ_CBUS_REG(smc->pin_clk_oen_reg);
+		_value &= ~smc->pin_clk_bit;
+		WRITE_CBUS_REG(smc->pin_clk_oen_reg, _value);
+		_value = READ_CBUS_REG(smc->pin_clk_out_reg);
+		_value &= ~smc->pin_clk_bit;
+		WRITE_CBUS_REG(smc->pin_clk_out_reg, _value);
+
+		pr_dbg("disable smc_clk: pin[%x](reg) \n", _value);
+	} else if(smc->pin_clk_pin != -1) {
+
+	   udelay(20);
+	   _gpio_out(smc->pin_clk_pin, 0, SMC_CLK_PIN_NAME);
+	   udelay(1000);
+
+		pr_dbg("disable smc_clk: pin[%x](pin) \n", smc->pin_clk_pin);
+	} else {
+
+		pr_error("no reg/bit or pin defined for clk-pin contrl.\n");
 	}
-    return 0;
+
+	return;
 }
 
 static int smc_hw_active(smc_dev_t *smc)
 {
     if(ENA_GPIO_PULL > 0){
-        enable_smc_clk();
+        enable_smc_clk(smc);
         udelay(200);
     }
 	if(!smc->active) {
 		if(smc->reset) {
 			smc->reset(NULL, 0);
 		} else {
-			if(smc->reset_pin != -1) {
-				amlogic_gpio_direction_output(smc->reset_pin,0,VBUS_SMC_RESET_GPIO_OWNER);
+			if(smc->enable_pin != -1) {
+				_gpio_out(smc->enable_pin, smc->enable_level, SMC_ENABLE_PIN_NAME);
 			}
 		}
-
+	
 		udelay(200);
 		smc_hw_setup(smc);
 
 		smc->active = 1;
 	}
-
+	
 	return 0;
 }
 
@@ -496,50 +739,51 @@ static int smc_hw_deactive(smc_dev_t *smc)
 	if(smc->active) {
 		unsigned long sc_reg0 = SMC_READ_REG(REG0);
 		SMCCARD_HW_Reg0_t *sc_reg0_reg = (void *)&sc_reg0;
-		sc_reg0_reg->rst_level = RESET_DISABLE;
+		sc_reg0_reg->rst_level = RESET_ENABLE;
 		sc_reg0_reg->enable= 1;
-		sc_reg0_reg->start_atr = 0;
-		sc_reg0_reg->start_atr_en = 0;
+		sc_reg0_reg->start_atr = 0;	
+		sc_reg0_reg->start_atr_en = 0;	
 		sc_reg0_reg->clk_en=0;
 		SMC_WRITE_REG(REG0,sc_reg0);
+#ifdef RST_FROM_PIO
+		_gpio_out(smc->reset_pin, RESET_ENABLE, SMC_RESET_PIN_NAME);
+#endif
 
 		udelay(200);
 
 		if(smc->reset) {
 			smc->reset(NULL, 1);
 		} else {
-			if(smc->reset_pin != -1) {
-				amlogic_gpio_direction_output(smc->reset_pin,1,VBUS_SMC_RESET_GPIO_OWNER);
+			if(smc->enable_pin != -1) {
+				_gpio_out(smc->enable_pin, !smc->enable_level, SMC_ENABLE_PIN_NAME);
 			}
 		}
-            if(ENA_GPIO_PULL > 0){
-                 disable_smc_clk();
-                 udelay(1000);
-            }
+        if(ENA_GPIO_PULL > 0){
+             disable_smc_clk(smc);
+        }
 		smc->active = 0;
 	}
-
+	
 	return 0;
 }
 
-#if 0
+#ifndef ATR_FROM_INT
 static int smc_hw_get(smc_dev_t *smc, int cnt, int timeout)
 {
-
 	unsigned long sc_status;
 	int times = timeout*100;
 	SMC_STATUS_Reg_t *sc_status_reg = (SMC_STATUS_Reg_t*)&sc_status;
-
+	
 	while((times > 0) && (cnt > 0)) {
 		sc_status = SMC_READ_REG(STATUS);
 
 		//pr_dbg("read atr status %08x\n", sc_status);
-
+						
 		if(sc_status_reg->rst_expired_status)
 		{
 			//pr_error("atr timeout\n");
 		}
-
+		
 		if(sc_status_reg->cwt_expeired_status)
 		{
 			//pr_error("cwt timeout when get atr, but maybe it is natural!\n");
@@ -554,7 +798,14 @@ static int smc_hw_get(smc_dev_t *smc, int cnt, int timeout)
 		{
 			while(sc_status_reg->recv_fifo_bytes_number > 0)
 			{
-				smc->atr.atr[smc->atr.atr_len++] = (SMC_READ_REG(FIFO))&0xff;
+				u8 byte = (SMC_READ_REG(FIFO))&0xff;
+
+#ifdef SW_INVERT
+				if(smc->sc_type == SC_INVERSE)
+					byte = inv_table[byte];
+#endif
+
+				smc->atr.atr[smc->atr.atr_len++] = byte;
 				sc_status_reg->recv_fifo_bytes_number--;
 				cnt--;
 				if(cnt==0){
@@ -564,292 +815,24 @@ static int smc_hw_get(smc_dev_t *smc, int cnt, int timeout)
 			}
 		}
 	}
-
+	
 	pr_error("read atr failed\n");
 	return -1;
 }
-#endif
-
-#ifdef SMC_FIQ
-static void smc_print_data(char buf[], int cnt)
-{
-    int temp = cnt/8,idx = 0,left_cnt = 0;
-
-    for(idx = 0; idx < temp*8;){
-        printk(KERN_ALERT"0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
-        buf[idx+0],  buf[idx+1],buf[idx+2],  buf[idx+3],buf[idx+4],  buf[idx+5],buf[idx+6],  buf[idx+7]);
-        idx+=8;
-    }
+#endif /*ifndef ATR_FROM_INT*/
 
-    left_cnt = cnt - temp * 8;
-
-    if(left_cnt > 0){
-        switch(left_cnt){
-            case 7:
-                printk(KERN_ALERT"0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
-                buf[temp * 8+0],  buf[temp * 8+1],buf[temp * 8+2],  buf[temp * 8+3],
-                buf[temp * 8+4],  buf[temp * 8+5],buf[temp * 8+6]);
-            break;
-
-            case 6:
-                printk(KERN_ALERT"0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
-                buf[temp * 8+0],  buf[temp * 8+1],buf[temp * 8+2],  buf[temp * 8+3],
-                buf[temp * 8+4],  buf[temp * 8+5]);
-            break;
-
-            case 5:
-                printk(KERN_ALERT"0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
-                buf[temp * 8+0],  buf[temp * 8+1],buf[temp * 8+2],  buf[temp * 8+3],
-                buf[temp * 8+4]);
-            break;
-
-            case 4:
-                printk(KERN_ALERT"0x%02x 0x%02x 0x%02x 0x%02x\n",
-                buf[temp * 8+0],  buf[temp * 8+1],buf[temp * 8+2],  buf[temp * 8+3]);
-            break;
-
-            case 3:
-                printk(KERN_ALERT"0x%02x 0x%02x 0x%02x\n",
-                buf[temp * 8+0],  buf[temp * 8+1],buf[temp * 8+2]);
-            break;
-
-            case 2:
-                printk(KERN_ALERT"0x%02x 0x%02x\n",
-                buf[temp * 8+0],  buf[temp * 8+1]);
-            break;
-
-            case 1:
-                printk(KERN_ALERT"0x%02x\n",
-                buf[temp * 8+0]);
-            break;
-        }
-    }
-
-}
+#define INV(a) ((smc->sc_type==SC_INVERSE)? inv_table[(int)(a)] : (a))
 
-/*==============================================================
-*  Function Name:
-*  Function Description:to check wheter api like smc_read can read/write data from/to the fiq array
-*  Function Parameters:
-*===============================================================
-*/
-static bool smc_read_write_check(bool r_flag, int r_fiq_idx, int w_fiq_idx)
+static int smc_get(smc_dev_t *smc, int size, int timeout)
 {
-    //to check read flag
-    if(r_flag == true){
-        if(r_fiq_idx < 0)
-            r_fiq_idx = smc_read_fiq_idx;
-        //printk(KERN_ALERT"smc read write check r_fiq_idx:%d, smc_read_idx:%d.\n",r_fiq_idx, smc_read_idx);
-        if((r_fiq_idx > 0)&&(r_fiq_idx != smc_read_idx))
-            return true;
-        else if((r_fiq_idx == 0)&&(smc_read_idx > 0))
-            return true;
-        else
-            return false;
-    }else if(r_flag == false){
-        if(w_fiq_idx < 0)
-            w_fiq_idx = smc_write_fiq_idx;
-        //printk(KERN_ALERT"smc read write check w_fiq_idx:%d, smc_write_idx:%d.\n",w_fiq_idx, smc_write_idx);
-        //if not equal that means FIQ need more time to sent the data to smartcard and API should poll again
-        if(w_fiq_idx == smc_write_idx)
-            return true;
-        else
-            return false;
-    }
+	unsigned long flags;
+	int pos = 0, ret=0;
+	int times = timeout/10;
 
-    return false;
-}
+	if(!times)
+		times = 1;
 
-/*==============================================================
-*  Function Name:
-*  Function Description:to check wheter api like smc_read can read/write data from/to the fiq array
-*                               if there are more data avaible
-*  Function Parameters:
-*===============================================================
-*/
-static int smc_read_write_data(bool r_flag, char temp_buf[], int size)
-{
-    int cnt = 0, smc_read_fiq_idx_temp, smc_write_fiq_idx_temp;
-
-    //if read and read avaible
-    if(r_flag){
-        smc_read_fiq_idx_temp = smc_read_fiq_idx;//this can be read only only since it will be updated by FIQ
-        //printk(KERN_ALERT"before the size is:%d, the smc_read_fiq_idx_temp:%d, the smc_read_idx:%d.\n", size, smc_read_fiq_idx_temp, smc_read_idx);
-        if(smc_read_fiq_idx_temp > smc_read_idx){//this case: |||||smc_read_idx||||||smc_read_fiq_idx|||||
-            if((smc_read_fiq_idx_temp - smc_read_idx) < size){
-                //printk(KERN_ALERT"(smc_read_fiq_idx > smc_read_idx)");
-                return -1;
-            }
-        }else if(smc_read_fiq_idx_temp < smc_read_idx){//this case: |||||smc_read_fiq_idx||||||smc_read_idx|||||
-            cnt = SMC_CNT - smc_read_idx + smc_read_fiq_idx_temp;
-            if(size > cnt){
-                //printk(KERN_ALERT"(smc_read_fiq_idx_temp < smc_read_idx)");
-                return -1;
-            }
-        }else if(smc_read_fiq_idx_temp == smc_read_idx){//this case: |||||smc_read_fiq_idx smc_read_idx|||||
-            //printk(KERN_ALERT"(smc_read_fiq_idx == smc_read_idx)");
-            return -1;
-        }else{
-            //printk(KERN_ALERT"(read else return -1 which should not be happened.\n)");
-            return -1;
-        }
-
-        cnt = 0;
-        while(smc_read_write_check(true, smc_read_fiq_idx_temp, -1)){
-            if(cnt == size){
-                break;
-            }
-            //and the smc_read_idx can be updated here only
-            smc_read_idx%=SMC_CNT;
-            temp_buf[cnt++] = smc_recv_data[smc_read_idx++];
-        }
-        //printk(KERN_ALERT"after the size is:%d, the smc_read_fiq_idx_temp:%d, the smc_read_idx:%d.\n", size, smc_read_fiq_idx_temp, smc_read_idx);
-        return cnt;
-    }else if(r_flag == false){
-        //assume there are always enought space for API to write fiq array because
-        //first, write data to smartcard is active and indicate
-        //second, FIQ will send the data to smartcard at a very high speed
-        smc_write_fiq_idx_temp = smc_write_fiq_idx;
-        cnt = 0;
-        //this means the data has been send out and here we should not set FIQ send data enable trigger
-        if(smc_write_fiq_idx_temp == smc_write_idx){
-            while(cnt != size){
-                smc_write_idx%=SMC_CNT;
-                smc_send_data[smc_write_idx++] = temp_buf[cnt++];
-            }
-            return size;
-        }else{
-            return -1;
-        }
-    }else{
-        ;//this will not happen
-    }
-
-    return -1;
-}
-
-/*==============================================================
-*  Function Name:
-*  Function Description: this can be called only during smartcard reset and module init
-*  Function Parameters:
-*===============================================================
-*/
-static irqreturn_t smc_bridge_isr(int irq, void *dev_id)
-{
-    //smc_dev_t *smc = (smc_dev_t*)dev_id;
-
-    bool can_read = false, can_write = false;
-    int temp_r_idx = smc_read_fiq_idx, temp_w_idx = smc_write_fiq_idx;
-
-    can_read  = smc_read_write_check(true, temp_r_idx, temp_w_idx);
-    can_write = smc_read_write_check(false, temp_r_idx, temp_w_idx);
-
-    if(can_read) wake_up_interruptible(smc_rd_wq);
-    if(can_write) wake_up_interruptible(smc_wr_wq);
-
-    //if(can_read && can_write)printk(KERN_ALERT"smc bridge isr func be called.......and can rw.\n");
-    return IRQ_HANDLED;
-}
-
-/*==============================================================
-*  Function Name:
-*  Function Description: this can be called only during smartcard reset and module init
-*  Function Parameters:
-*===============================================================
-*/
-static void smc_wakeup_wq_timer_fun(unsigned long arg)
-{
-#if 0
-    bool can_read = false, can_write = false;
-    int temp_r_idx = smc_read_fiq_idx, temp_w_idx = smc_write_fiq_idx;
-
-    can_read  = smc_read_write_check(true, temp_r_idx, temp_w_idx);
-    can_write = smc_read_write_check(false, temp_r_idx, temp_w_idx);
-
-    if(can_read) wake_up_interruptible(smc_rd_wq);
-    if(can_write) wake_up_interruptible(smc_wr_wq);
-
-    if(can_read && can_write)
-    printk(KERN_ALERT"wake up func be called.......\n");
-    mod_timer(&smc_wakeup_wq_timer,jiffies + 20);
-#endif
-}
-
-/*==============================================================
-*  Function Name:
-*  Function Description: this can be called only during smartcard reset and module init
-*  Function Parameters:
-*===============================================================
-*/
-static void smc_reset_fiq_varible(void)
-{
-    int idx = 0;
-
-    for(idx = 0; idx < SMC_CNT; idx++){
-        smc_send_data[idx] = 0;
-        smc_recv_data[idx] = 0;
-    }
-
-    smc_write_idx = 0;
-    smc_write_fiq_idx = 0;
-    smc_read_fiq_idx = 0;
-    smc_read_idx = 0;
-}
-
-/*==============================================================
-*  Function Name:
-*  Function Description: this can be called only during smartcard reset and module init
-*  Function Parameters:
-*===============================================================
-*/
-static int smc_fiq_get(smc_dev_t *smc, int size, int timeout)
-{
-    int times = timeout/10, ret = 0, idx = 0;
-    char data_buf[512];
-
-    if(!times)
-        times = 1;
-
-    if(!(size > 0)){
-        printk(KERN_ALERT"smc fiq get size not large 0.\n");
-        return -1;
-    }
-
-    if(!smc){
-        printk(KERN_ALERT"smc fiq get smc NULL.\n");
-        return -1;
-    }
-
-    while(times > 0){
-        ret = smc_read_write_data(true,data_buf,size);
-        //printk(KERN_ALERT"to read atr ret is:%d.\n", ret);
-        if(ret < 0){
-            msleep(10);
-            times--;
-        }else if(ret == size){
-            for(idx = 0; idx < size; idx++){
-                smc->atr.atr[smc->atr.atr_len+idx] = data_buf[idx];
-            }
-            smc->atr.atr_len+=size;
-            return 0;
-        }
-    }
-
-    return -1;
-
-}
-#endif
-
-static int smc_get(smc_dev_t *smc, int size, int timeout)
-{
-	unsigned long flags;
-	int pos = 0, ret=0;
-	int times = timeout/10;
-
-	if(!times)
-		times = 1;
-
-	while((times>0) && (size>0)) {
+	while((times>0) && (size>0)) {
 
 		spin_lock_irqsave(&smc->slock, flags);
 
@@ -860,7 +843,7 @@ static int smc_get(smc_dev_t *smc, int size, int timeout)
 		} else {
 			ret = smc->recv_count;
 			if(ret>size) ret = size;
-
+			
 			pos = smc->recv_start;
 			smc->recv_start += ret;
 			smc->recv_count -= ret;
@@ -873,42 +856,35 @@ static int smc_get(smc_dev_t *smc, int size, int timeout)
 			int cnt = RECV_BUF_SIZE-pos;
 			int i;
 			unsigned char byte = 0xff;
-
 			pr_dbg("read %d bytes\n", ret);
 
 			if(cnt>=ret) {
 				for(i=0; i<ret; i++){
 					byte = smc->recv_buf[pos+i];
-//					if(SC_DIRECT != smcTpye)
-//						byte = inv_table[byte&0xff];
-					smc->atr.atr[smc->atr.atr_len+i] = byte;
+					smc->atr.atr[smc->atr.atr_len+i] = INV(byte);
 				}
-				//memcpy(&smc->atr.atr[smc->atr.atr_len], smc->recv_buf+pos, ret);
 				smc->atr.atr_len+=ret;
+				dump(smc->recv_buf+pos, ret);
 			} else {
 				int cnt1 = ret-cnt;
-
+				
 				for(i=0; i<cnt; i++){
 					byte = smc->recv_buf[pos+i];
-//					if(SC_DIRECT != smcTpye)
-//						byte = inv_table[byte&0xff];
-					smc->atr.atr[smc->atr.atr_len+i] = byte;
+					smc->atr.atr[smc->atr.atr_len+i] = INV(byte);
 				}
-				//memcpy(&smc->atr.atr[smc->atr.atr_len], smc->recv_buf+pos, cnt);
 				smc->atr.atr_len+=cnt;
+				dump(smc->recv_buf+pos, cnt);
 
 				for(i=0; i<cnt1; i++){
 					byte = smc->recv_buf[i];
-//					if(SC_DIRECT != smcTpye)
-//						byte = inv_table[byte&0xff];
-					smc->atr.atr[smc->atr.atr_len+i] = byte;
+					smc->atr.atr[smc->atr.atr_len+i] = INV(byte);
 				}
-				//memcpy(&smc->atr.atr[smc->atr.atr_len], smc->recv_buf, cnt1);
 				smc->atr.atr_len+=cnt1;
+				dump(smc->recv_buf, cnt1);
 			}
 			size-=ret;
 		} else {
-			msleep(10);
+			msleep(1);
 			times--;
 		}
 	}
@@ -919,13 +895,61 @@ static int smc_get(smc_dev_t *smc, int size, int timeout)
 	return ret;
 }
 
+#ifdef SMC_FIQ
+static int smc_fiq_get(smc_dev_t *smc, int size, int timeout)
+{
+	int pos = 0, ret=0;
+	int times = timeout/10;
+	int start, end;
+
+	if(!times)
+		times = 1;
+	
+	while((times>0) && (size>0)) {
+
+		start = smc->recv_start;
+		end = smc->recv_end;/*momentary value*/
+		
+		if(!smc->cardin) {
+			ret = -ENODEV;
+		} else if (start == end) {
+			ret = -EAGAIN;
+		} else {
+			int i;
+			/*ATR only, no loop*/
+			ret = end - start;
+			if(ret>size) ret=size;
+			memcpy(&smc->atr.atr[smc->atr.atr_len], &smc->recv_buf[start], ret);
+			for(i=smc->atr.atr_len;i<smc->atr.atr_len+ret;i++)
+				smc->atr.atr[i] = INV((int)smc->atr.atr[i]);
+			smc->atr.atr_len += ret;
+
+			smc->recv_start += ret;
+			size -= ret;
+		}
+
+		if(ret<0) {
+			msleep(10);
+			times--;
+		}
+	}
+
+	if(size>0)
+		ret = -ETIMEDOUT;
+	
+	return ret;
+}
+#endif
+
+//static int smc_hw_read_atr(smc_dev_t *smc) __attribute__((unused));
+
 static int smc_hw_read_atr(smc_dev_t *smc)
 {
 	char *ptr = smc->atr.atr;
 	int his_len, t, tnext = 0, only_t0 = 1, loop_cnt=0;
 	int i;
-
-	printk(KERN_ALERT"read atr\n");
+	
+	pr_dbg("read atr\n");
 
 #ifdef ATR_FROM_INT
 #ifdef SMC_FIQ
@@ -934,27 +958,31 @@ static int smc_hw_read_atr(smc_dev_t *smc)
 #define smc_hw_get smc_get
 #endif
 #endif
-
+	
 	smc->atr.atr_len = 0;
-#if 0
 	if(smc_hw_get(smc, 2, 2000)<0){
 		goto end;
 	}
-#else
-	if(smc_hw_get(smc, 1, 2000)<0)
-		goto end;
 
-	if(smc_hw_get(smc, 1, 2000)<0)
-		goto end;
-#endif
-
-	if(ptr[0] == 0){
-		smc->atr.atr[0] = smc->atr.atr[1];
-		smc->atr.atr_len = 1;
-		if(smc_hw_get(smc, 1, 2000)<0){
-			goto end;
-		}
+#ifdef SW_INVERT
+	if(0x03 == ptr[0]){
+		smc->sc_type = SC_INVERSE;
+		ptr[0] = inv_table[(int)ptr[0]];
+		if(smc->atr.atr_len>1)
+			ptr[1] = inv_table[(int)ptr[1]];
+	}else if(0x3F == ptr[0]){
+		smc->sc_type = SC_INVERSE;
+		if(smc->atr.atr_len>1)
+			ptr[1] = inv_table[(int)ptr[1]];
+	}else if(0x3B == ptr[0]){
+		smc->sc_type = SC_DIRECT;
+	}else if(0x23 == ptr[0]){
+		smc->sc_type = SC_DIRECT;
+		ptr[0] = inv_table[(int)ptr[0]];
+		if(smc->atr.atr_len>1)
+			ptr[1] = inv_table[(int)ptr[1]];
 	}
+#endif /*SW_INVERT*/
 
 	ptr++;
 	his_len = ptr[0]&0x0F;
@@ -977,6 +1005,7 @@ static int smc_hw_read_atr(smc_dev_t *smc)
 		if(ptr[0]&0x80) {
 			if(smc_hw_get(smc, 1, 1000)<0)
 				goto end;
+
 			ptr = &smc->atr.atr[smc->atr.atr_len-1];
 			t = ptr[0]&0x0F;
 			if(t) {
@@ -987,25 +1016,24 @@ static int smc_hw_read_atr(smc_dev_t *smc)
 			}
 		}
 	} while(tnext && loop_cnt<4);
-
+	
 	if(!only_t0) his_len++;
-	smc_hw_get(smc, his_len, 1000);
+	smc_hw_get(smc, his_len, 2000);
 
-	printk(KERN_ALERT"get atr len:%d data: ", smc->atr.atr_len);
+	printk("get atr len:%d data: ", smc->atr.atr_len);
 	for(i=0; i<smc->atr.atr_len; i++){
-		printk(KERN_ALERT"%02x ", smc->atr.atr[i]);
+		printk("%02x ", smc->atr.atr[i]);
 	}
-	printk(KERN_ALERT"\n");
+	printk("\n");
 
 	return 0;
 
 end:
 	pr_error("read atr failed\n");
 	return -EIO;
-
 #ifdef ATR_FROM_INT
 #undef smc_hw_get
-#endif
+#endif	
 }
 
 static int smc_hw_reset(smc_dev_t *smc)
@@ -1016,86 +1044,60 @@ static int smc_hw_reset(smc_dev_t *smc)
 	SMCCARD_HW_Reg0_t *sc_reg0_reg = (void *)&sc_reg0;
 	unsigned long sc_int;
 	SMC_INTERRUPT_Reg_t *sc_int_reg = (void *)&sc_int;
-
+	
 	spin_lock_irqsave(&smc->slock, flags);
 	if(smc->cardin) {
 		ret = 0;
-              //smc_status = smc->cardin;
-              //printk(KERN_ALERT"smc_hw_reset card status is:%d.\n", smc_status);
 	} else {
 		ret = -ENODEV;
 	}
 	spin_unlock_irqrestore(&smc->slock, flags);
-
+	
 	if(ret>=0) {
 		/*Reset*/
 #ifdef NO_HOT_RESET
 		smc->active = 0;
 #endif
 		if(smc->active) {
-			sc_reg0_reg->rst_level = RESET_DISABLE;
-			sc_reg0_reg->clk_en = 1;
-			sc_reg0_reg->etu_divider = ETU_DIVIDER_CLOCK_HZ*smc->param.f/(smc->param.d*smc->param.freq)-1;
-
 			pr_dbg("hot reset\n");
 
+			sc_reg0_reg->rst_level = RESET_ENABLE; 
+			sc_reg0_reg->clk_en = 1;
+			sc_reg0_reg->etu_divider = ETU_DIVIDER_CLOCK_HZ*smc->param.f/(smc->param.d*smc->param.freq)-1;
 			SMC_WRITE_REG(REG0, sc_reg0);
-
+#ifdef RST_FROM_PIO
+			_gpio_out(smc->reset_pin, RESET_ENABLE, SMC_RESET_PIN_NAME);
+#endif
+			
 			udelay(800/smc->param.freq); // >= 400/f ;
 
 			/* disable receive interrupt*/
 			sc_int = SMC_READ_REG(INTR);
 			sc_int_reg->recv_fifo_bytes_threshold_int_mask = 0;
 			SMC_WRITE_REG(INTR, sc_int|0x3FF);
-
-			sc_reg0_reg->rst_level = RESET_ENABLE;
+		
+			sc_reg0_reg->rst_level = RESET_DISABLE;
 			sc_reg0_reg->start_atr = 1;
 			SMC_WRITE_REG(REG0, sc_reg0);
-		} else {
-			printk(KERN_ALERT"cold reset build at %s %s.\n",__DATE__,__TIME__);
-#ifdef SMC_FIQ
-                    smc_reset_fiq_varible();
-                    smc_rd_wq = &smc->rd_wq;
-                    smc_wr_wq = &smc->wr_wq;
+#ifdef RST_FROM_PIO
+			_gpio_out(smc->reset_pin, RESET_DISABLE, SMC_RESET_PIN_NAME);
 #endif
+		} else {
+			pr_dbg("cold reset\n");
+			
 			smc_hw_deactive(smc);
+			
 			udelay(200);
-			smc_hw_active(smc);
-			udelay(200);
-			{
-				int idx = 0;
-				sc_reg0_reg->rst_level = RESET_ENABLE;
-				sc_reg0_reg->enable = 1;
-				SMC_WRITE_REG(REG0, sc_reg0);
-
-				for(idx = 0; idx < 50; idx++){
-					udelay(2000);
-				}
-
-				smc_hw_deactive2(smc);
 
-				for(idx = 0; idx < 40; idx++){
-					if(idx == 35){
-						sc_reg0_reg->enable = 0;
-						sc_reg0_reg->clk_en =1 ;
-						sc_reg0_reg->rst_level = RESET_DISABLE;
-						SMC_WRITE_REG(REG0, sc_reg0);
-					}
-					udelay(2000);
-				}
-				smc_hw_active2(smc);
-				sc_reg0_reg->rst_level = RESET_ENABLE;
-				sc_reg0_reg->enable = 1;
-				SMC_WRITE_REG(REG0, sc_reg0);
-				for(idx = 0; idx < 10; idx++)
-					udelay(2000);
-			}
+			smc_hw_active(smc);
 
 			sc_reg0_reg->clk_en =1 ;
 			sc_reg0_reg->enable = 0;
-			sc_reg0_reg->rst_level = RESET_DISABLE;
+			sc_reg0_reg->rst_level = RESET_ENABLE;
 			SMC_WRITE_REG(REG0, sc_reg0);
-
+#ifdef RST_FROM_PIO
+			_gpio_out(smc->reset_pin, RESET_ENABLE, SMC_RESET_PIN_NAME);
+#endif
 			udelay(2000); // >= 400/f ;
 
 			/* disable receive interrupt*/
@@ -1103,11 +1105,14 @@ static int smc_hw_reset(smc_dev_t *smc)
 			sc_int_reg->recv_fifo_bytes_threshold_int_mask = 0;
 			SMC_WRITE_REG(INTR, sc_int|0x3FF);
 
-			sc_reg0_reg->rst_level = RESET_ENABLE;
+			sc_reg0_reg->rst_level = RESET_DISABLE;
 			sc_reg0_reg->start_atr_en = 1;
-			sc_reg0_reg->start_atr = 1;
+			sc_reg0_reg->start_atr = 1;	
 			sc_reg0_reg->enable = 1;
 			SMC_WRITE_REG(REG0, sc_reg0);
+#ifdef RST_FROM_PIO
+			_gpio_out(smc->reset_pin, RESET_DISABLE, SMC_RESET_PIN_NAME);
+#endif
 		}
 
 		/*reset recv&send buf*/
@@ -1115,23 +1120,34 @@ static int smc_hw_reset(smc_dev_t *smc)
 		smc->send_count = 0;
 		smc->recv_start = 0;
 		smc->recv_count = 0;
-
+		
 		/*Read ATR*/
 		smc->atr.atr_len = 0;
 		smc->recv_count = 0;
 		smc->send_count = 0;
 
+#ifdef SMC_FIQ
+		smc->recv_end = 0;
+		smc->send_end = 0;
+#endif
+
+#ifdef SW_INVERT
+		smc->atr_mode = 1;
+#endif
+
 #ifdef ATR_FROM_INT
-		printk(KERN_ALERT"ATR from INT\n");
+		printk("ATR from INT\n");
 		/* enable receive interrupt*/
 		sc_int = SMC_READ_REG(INTR);
 		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 1;
 		SMC_WRITE_REG(INTR, sc_int|0x3FF);
 #endif
 
+		//msleep(atr_delay);
 		ret = smc_hw_read_atr(smc);
-#ifdef SMC_FIQ
-		smc_reset_fiq_varible();
+
+#ifdef SW_INVERT
+		smc->atr_mode = 0;
 #endif
 
 #ifdef ATR_FROM_INT
@@ -1140,88 +1156,230 @@ static int smc_hw_reset(smc_dev_t *smc)
 		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 0;
 		SMC_WRITE_REG(INTR, sc_int|0x3FF);
 #endif
-
+		
 		/*Disable ATR*/
 		sc_reg0 = SMC_READ_REG(REG0);
 		sc_reg0_reg->start_atr_en = 0;
 		sc_reg0_reg->start_atr = 0;
 		SMC_WRITE_REG(REG0,sc_reg0);
-
+		
 #ifndef DISABLE_RECV_INT
 		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 1;
 #endif
 		SMC_WRITE_REG(INTR, sc_int|0x3FF);
 	}
-
+	
 	return ret;
 }
 
 static int smc_hw_get_status(smc_dev_t *smc, int *sret)
 {
-    unsigned long flags;
-    unsigned int  reg_val;
-    SMCCARD_HW_Reg0_t *reg = (SMCCARD_HW_Reg0_t*)&reg_val;
-#ifdef SMC_FIQ
-    //bool can_read = false, can_write = false;
-    //int temp_r_idx = smc_read_fiq_idx, temp_w_idx = smc_write_fiq_idx;
+	unsigned long flags;
+#ifndef DET_FROM_PIO
+	unsigned int  reg_val;
+	SMCCARD_HW_Reg0_t *reg = (SMCCARD_HW_Reg0_t*)&reg_val;
 #endif
-    spin_lock_irqsave(&smc->slock, flags);
 
-#ifdef SMC_FIQ
-    //can_read  = smc_read_write_check(true, temp_r_idx, temp_w_idx);
-    //can_write = smc_read_write_check(false, temp_r_idx, temp_w_idx);
-    //printk(KERN_ALERT"read/write:%d/%d.\n", can_read, can_write);
-    //if(can_read)
-        //wake_up_interruptible(&smc->rd_wq);
-    //if(can_write)
-        //wake_up_interruptible(&smc->wr_wq);
-#endif
+	spin_lock_irqsave(&smc->slock, flags);
 
+#ifdef DET_FROM_PIO
+	smc->cardin = _gpio_in(smc->detect_pin, SMC_DETECT_PIN_NAME);
+	pr_dbg("get_status: card detect: %d\n", smc->cardin);
+#else
 	reg_val = SMC_READ_REG(REG0);
-
 	smc->cardin = reg->card_detect;
-
 	//pr_dbg("get_status: smc reg0 %08x, card detect: %d\n", reg_val, smc->cardin);
-#if 0
-	if(smc_status != smc->cardin){
-            //printk(KERN_ALERT"smc_hw_get_status card status changed from %d to %d.", smc_status, smc->cardin);
-            if(smc_status == SUSPEND_CARD_STATUS)
-                smc->cardin = 0;//to pass user API an artificial status of card removed to let API reset card again to enable communication ok while suspend/resume
+#endif	
 
-            smc_status = smc->cardin;
-       }
-#endif
 	*sret = smc->cardin;
-
+	
 	spin_unlock_irqrestore(&smc->slock, flags);
 
 	return 0;
 }
 
 #ifdef SMC_FIQ
+
+static inline void _atomic_wrap_inc(int *p, int wrap)
+{
+    int i = *p;
+    i++;
+    if(i>=wrap)
+		i = 0;
+	*p = i;
+}
+
+static inline void _atomic_wrap_add(int *p, int add, int wrap)
+{
+    int i = *p;
+    i+=add;
+    if(i>=wrap)
+		i %= wrap;
+	*p = i;
+}
+
 static int smc_hw_start_send(smc_dev_t *smc)
 {
-    unsigned int sc_status;
-    SMC_STATUS_Reg_t *sc_status_reg = (SMC_STATUS_Reg_t*)&sc_status;
-    u8 byte;
-    int cnt = 0, smc_write_idx_temp;
-
-    while(1) {
-        smc_write_idx_temp = smc_write_idx;
-        sc_status = SMC_READ_REG(STATUS);
-        if ((smc_write_idx_temp == smc_write_fiq_idx) || sc_status_reg->send_fifo_full_status){
-            break;
-        }
-        smc_write_fiq_idx%=SMC_CNT;
-        byte = smc_send_data[smc_write_fiq_idx++];
-        SMC_WRITE_REG(FIFO, byte);
-        cnt++;
-    }
-    //printk(KERN_ALERT"smc_hw_start_send %d byte data to smartcard.\n", cnt);
+	unsigned long flags;
+	unsigned int sc_status;
+	SMC_STATUS_Reg_t *sc_status_reg = (SMC_STATUS_Reg_t*)&sc_status;
+	u8 byte;
+	int cnt = 0;
+
+#if 1
+	/*trigger only*/
+	sc_status = SMC_READ_REG(STATUS);
+	if (smc->send_end!=smc->send_start && !sc_status_reg->send_fifo_full_status) {
+		pr_dbg("s i f [%d:%d]\n", smc->send_start, smc->send_end);
+		byte = smc->send_buf[smc->send_end];
+		_atomic_wrap_inc(&smc->send_end, SEND_BUF_SIZE);
+#ifdef SW_INVERT
+		if(smc->sc_type == SC_INVERSE)
+			byte = inv_table[byte];
+#endif
+		SMC_WRITE_REG(FIFO, byte);
+		pr_dbg("send 1st byte to hw\n");
+	}
+#else
+	while(1) {
+		sc_status = SMC_READ_REG(STATUS);
+		if (smc->send_end==smc->send_start || sc_status_reg->send_fifo_full_status) {
+			break;
+		}
 
-    return 0;
+		pr_dbg("s i f [%d:%d]\n", smc->send_start, smc->send_end);
+		byte = smc->send_buf[smc->send_end];
+		_atomic_wrap_inc(&smc->send_end, SEND_BUF_SIZE);
+#ifdef SW_INVERT
+		if(smc->sc_type == SC_INVERSE)
+			byte = inv_table[byte];
+#endif
+		SMC_WRITE_REG(FIFO, byte);
+		cnt++;
+	}
+	pr_dbg("send %d bytes to hw\n", cnt);
+#endif
+	
+	return 0;
 }
+
+static irqreturn_t smc_bridge_isr(int irq, void *dev_id)
+{
+	smc_dev_t *smc = (smc_dev_t*)dev_id;
+
+#ifdef DET_FROM_PIO
+	smc->cardin = _gpio_in(smc->detect_pin, SMC_DETECT_PIN_NAME);
+#endif
+
+    if(smc->recv_start != smc->recv_end)
+		wake_up_interruptible(&smc->rd_wq);
+    if(smc->send_start == smc->send_end)
+		wake_up_interruptible(&smc->wr_wq);
+
+    return IRQ_HANDLED;
+}
+
+static inline int smc_can_recv_max(smc_dev_t *smc)
+{
+	int start=smc->recv_start;
+	int end=smc->recv_end;
+
+	if(end >= start)
+		return RECV_BUF_SIZE - end + start;
+	else
+		return start - end;
+}
+
+static void smc_irq_handler(void)
+{
+	smc_dev_t *smc = &smc_dev[0];
+	unsigned int sc_status;
+	unsigned int sc_reg0;
+	unsigned int sc_int;
+	SMC_STATUS_Reg_t *sc_status_reg = (SMC_STATUS_Reg_t*)&sc_status;
+	SMC_INTERRUPT_Reg_t *sc_int_reg = (SMC_INTERRUPT_Reg_t*)&sc_int;
+	SMCCARD_HW_Reg0_t *sc_reg0_reg = (void *)&sc_reg0;
+
+	sc_int = SMC_READ_REG(INTR);
+	//Fpr("smc intr:0x%x\n", sc_int);
+
+	if(sc_int_reg->recv_fifo_bytes_threshold_int) {
+
+		int num;
+
+		sc_status = SMC_READ_REG(STATUS);
+		num = sc_status_reg->recv_fifo_bytes_number;
+
+		if(num > smc_can_recv_max(smc)) {
+			pr_error("receive buffer overflow\n");
+		} else {
+			u8 byte;
+
+			while(num){
+				byte = SMC_READ_REG(FIFO);
+#ifdef SW_INVERT
+				if(!smc->atr_mode && smc->sc_type == SC_INVERSE)
+					byte = inv_table[byte];
+#endif
+				smc->recv_buf[smc->recv_end] = byte;
+				_atomic_wrap_inc(&smc->recv_end, RECV_BUF_SIZE);
+				num--;
+				Fpr("fiq R[%x]     \n", smc->recv_buf[smc->recv_end]);
+			}
+			Fpr("fiq R%d     \n", sc_status_reg->recv_fifo_bytes_number);
+
+			fiq_bridge_pulse_trigger(&smc->smc_fiq_bridge);
+		}
+
+		sc_int_reg->recv_fifo_bytes_threshold_int = 0;
+		
+	}
+	
+	if(sc_int_reg->send_fifo_last_byte_int) {
+		int start = smc->send_start;
+		int cnt = 0;
+		u8 byte;
+
+		while(1) {
+			sc_status = SMC_READ_REG(STATUS);
+			if (smc->send_end == start || sc_status_reg->send_fifo_full_status) {
+				break;
+			}
+			
+			byte = smc->send_buf[smc->send_end];
+			_atomic_wrap_inc(&smc->send_end, SEND_BUF_SIZE);
+#ifdef SW_INVERT
+			if(smc->sc_type == SC_INVERSE)
+				byte = inv_table[byte];
+#endif
+			SMC_WRITE_REG(FIFO, byte);
+			cnt++;
+		}
+		
+		Fpr("fiq W%d     \n", cnt);
+
+		if(smc->send_end==start) {
+			sc_int_reg->send_fifo_last_byte_int_mask = 0;
+			sc_int_reg->recv_fifo_bytes_threshold_int_mask = 1;
+			fiq_bridge_pulse_trigger(&smc->smc_fiq_bridge);
+		}
+
+		sc_int_reg->send_fifo_last_byte_int = 0;
+		
+	}
+
+#ifndef DET_FROM_PIO
+	sc_reg0 = SMC_READ_REG(REG0);
+	smc->cardin = sc_reg0_reg->card_detect;
+#endif
+
+	SMC_WRITE_REG(INTR, sc_int|0x3FF);
+
+	return IRQ_HANDLED;
+}
+
 #else
+
 static int smc_hw_start_send(smc_dev_t *smc)
 {
 	unsigned long flags;
@@ -1230,9 +1388,9 @@ static int smc_hw_start_send(smc_dev_t *smc)
 	u8 byte;
 	int cnt = 0;
 
-	while(1) {
+	while(1) {			
 		spin_lock_irqsave(&smc->slock, flags);
-
+		
 		sc_status = SMC_READ_REG(STATUS);
 		if (!smc->send_count || sc_status_reg->send_fifo_full_status) {
 			spin_unlock_irqrestore(&smc->slock, flags);
@@ -1241,6 +1399,10 @@ static int smc_hw_start_send(smc_dev_t *smc)
 
 		pr_dbg("s i f [%d], [%d]\n", smc->send_count, cnt);
 		byte = smc->send_buf[smc->send_start++];
+#ifdef SW_INVERT
+		if(smc->sc_type == SC_INVERSE)
+			byte = inv_table[byte];
+#endif
 		SMC_WRITE_REG(FIFO, byte);
 		smc->send_start %= SEND_BUF_SIZE;
 		smc->send_count--;
@@ -1250,166 +1412,86 @@ static int smc_hw_start_send(smc_dev_t *smc)
 	}
 
 	pr_dbg("send %d bytes to hw\n", cnt);
-
+	
 	return 0;
 }
-#endif
-
-#ifdef SMC_FIQ
-/*==============================================================
-*  Function Name: FIQ hander
-*  Function Description: to solve sometimes irq will not response, which will result in CA data lost
-*  Function Parameters:
-*===============================================================
-*/
-static void smc_irq_handler(void)
-{
-    unsigned int sc_status;
-    unsigned int sc_reg0;
-    unsigned int sc_int;
-    SMC_STATUS_Reg_t *sc_status_reg = (SMC_STATUS_Reg_t*)&sc_status;
-    SMC_INTERRUPT_Reg_t *sc_int_reg = (SMC_INTERRUPT_Reg_t*)&sc_int;
-    SMCCARD_HW_Reg0_t *sc_reg0_reg = (void *)&sc_reg0;
-
-    sc_int = SMC_READ_REG(INTR);
-
-    //if data avaible to read
-    if(sc_int_reg->recv_fifo_bytes_threshold_int){
-        int total_data = 0;
-        sc_status = SMC_READ_REG(STATUS);
-        total_data = sc_status_reg->recv_fifo_bytes_number ;
-        while(total_data > 0){
-            smc_read_fiq_idx%=SMC_CNT;
-            smc_recv_data[smc_read_fiq_idx++] = SMC_READ_REG(FIFO);
-            smc_recv_bak_idx%=SMC_CNT;
-            smc_recv_data_bak[smc_recv_bak_idx++] = smc_recv_data[smc_read_fiq_idx-1];
-            total_data--;
-            sc_status = SMC_READ_REG(STATUS);
-        }
-        sc_int_reg->recv_fifo_bytes_threshold_int = 0;
-        //no system call like kmalloc spinlock wait queue mutex_lock.. can be call in FIQ
-        //wake_up_interruptible(&smc_rd_wq);
-        //mod_timer(&smc_wakeup_wq_timer,jiffies + 20);
-        fiq_bridge_pulse_trigger(&smc_fiq_bridge);
-    }
-
-    //if more data need to be sent to the smartcard
-    if(sc_int_reg->send_fifo_last_byte_int) {
-        int cnt = 0,smc_write_idx_temp = -1;
-        char byte;
-
-        while(1) {
-            smc_write_idx_temp = smc_write_idx;//need update here everytime?
-            sc_status = SMC_READ_REG(STATUS);
-            if ((smc_write_idx_temp == smc_write_fiq_idx) || sc_status_reg->send_fifo_full_status){
-                break;
-            }
-            smc_write_fiq_idx%=SMC_CNT;
-            byte = smc_send_data[smc_write_fiq_idx++];
-            SMC_WRITE_REG(FIFO, byte);
-            cnt++;
-        }
-
-        //if no more data be sent, which means we are going to receive data from smartcard
-        if(smc_write_idx_temp == smc_write_fiq_idx){
-            sc_int_reg->send_fifo_last_byte_int_mask = 0;
-            sc_int_reg->recv_fifo_bytes_threshold_int_mask = 1;
-            //no system call like kmalloc spinlock wait queue mutex_lock.. can be call in FIQ
-            //wake_up_interruptible(&smc_rd_wq);
-            //mod_timer(&smc_wakeup_wq_timer,jiffies + 20);
-            fiq_bridge_pulse_trigger(&smc_fiq_bridge);
-        }
-        sc_int_reg->send_fifo_last_byte_int = 0;
-        //wake_up_interruptible(&smc_wr_wq);
-    }
-
-    //should be update here
-    sc_reg0 = SMC_READ_REG(REG0);
-    smc_cardin = sc_reg0_reg->card_detect;
-    //smc->cardin = sc_reg0_reg->card_detect;
-
-    SMC_WRITE_REG(INTR, sc_int|0x3FF);
 
-    return;
-}
-#else
 static irqreturn_t smc_irq_handler(int irq, void *data)
 {
 	smc_dev_t *smc = (smc_dev_t*)data;
 	unsigned int sc_status;
-	unsigned int sc_reg0;
 	unsigned int sc_int;
 	SMC_STATUS_Reg_t *sc_status_reg = (SMC_STATUS_Reg_t*)&sc_status;
 	SMC_INTERRUPT_Reg_t *sc_int_reg = (SMC_INTERRUPT_Reg_t*)&sc_int;
+#ifndef DET_FROM_PIO
+	unsigned int sc_reg0;
 	SMCCARD_HW_Reg0_t *sc_reg0_reg = (void *)&sc_reg0;
+#endif
 	unsigned long flags;
 
-	spin_lock_irqsave(&smc->slock, flags);
+	spin_lock_irqsave(&smc->slock, flags);		
 
 	sc_int = SMC_READ_REG(INTR);
-	pr_dbg("smc intr:0x%x\n", sc_int);
-#if 1
-        if(sc_int_reg->recv_fifo_bytes_threshold_int) {
-            if(smc->recv_count==RECV_BUF_SIZE) {
-                pr_error("receive buffer overflow\n");
-            } else {
-                int total_data;
-                sc_status = SMC_READ_REG(STATUS);
-                total_data = sc_status_reg->recv_fifo_bytes_number ;
-                while(total_data > 0){
-                    int pos = smc->recv_start+smc->recv_count;
-
-                    pos %= RECV_BUF_SIZE;
-                    smc->recv_buf[pos] = SMC_READ_REG(FIFO);
-                    smc->recv_count++;
-                    total_data--;
-                    sc_status = SMC_READ_REG(STATUS);
-                    pr_dbg("irq: recv 1 byte=:%x.......\n", smc->recv_buf[pos]);
-                }
-            }
-            sc_int_reg->recv_fifo_bytes_threshold_int = 0;
-
-            wake_up_interruptible(&smc->rd_wq);
-        }
-#else
-	if(sc_int_reg->recv_fifo_bytes_threshold_int) {
+	Ipr("smc intr:0x%x\n", sc_int);
 
+	if(sc_int_reg->recv_fifo_bytes_threshold_int) {
+		
 		if(smc->recv_count==RECV_BUF_SIZE) {
 			pr_error("receive buffer overflow\n");
 		} else {
 			int pos = smc->recv_start+smc->recv_count;
-
+			int i;
+			u8 byte;
+#if 0
 			pos %= RECV_BUF_SIZE;
 			smc->recv_buf[pos] = SMC_READ_REG(FIFO);
 			smc->recv_count++;
-
+			
 			pr_dbg("irq: recv 1 byte [0x%x]\n", smc->recv_buf[pos]);
+#else
+			sc_status = SMC_READ_REG(STATUS);
+			for(i=0; i< sc_status_reg->recv_fifo_bytes_number; i++) {
+				pos %= RECV_BUF_SIZE;
+				byte = SMC_READ_REG(FIFO);
+#ifdef SW_INVERT
+				if(!smc->atr_mode && smc->sc_type == SC_INVERSE)
+					byte = inv_table[byte];
+#endif
+				Ipr("%02x ", byte);
+				smc->recv_buf[pos++] = byte;
+				smc->recv_count++;
+			}
+			Ipr("irq: recv %d byte from hw\n", sc_status_reg->recv_fifo_bytes_number);
+#endif
 		}
 
 		sc_int_reg->recv_fifo_bytes_threshold_int = 0;
-
+		
 		wake_up_interruptible(&smc->rd_wq);
 	}
-#endif
+	
 	if(sc_int_reg->send_fifo_last_byte_int) {
 		int cnt = 0;
+		u8 byte;
 
 		while(1) {
-			u8 byte;
-
 			sc_status = SMC_READ_REG(STATUS);
 			if (!smc->send_count || sc_status_reg->send_fifo_full_status) {
 				break;
 			}
-
+			
 			byte = smc->send_buf[smc->send_start++];
+#ifdef SW_INVERT
+			if(smc->sc_type == SC_INVERSE)
+				byte = inv_table[byte];
+#endif
 			SMC_WRITE_REG(FIFO, byte);
 			smc->send_start %= SEND_BUF_SIZE;
 			smc->send_count--;
 			cnt++;
 		}
-
-		pr_dbg("irq: send %d bytes to hw\n", cnt);
+		
+		Ipr("irq: send %d bytes to hw\n", cnt);
 
 		if(!smc->send_count) {
 			sc_int_reg->send_fifo_last_byte_int_mask = 0;
@@ -1417,147 +1499,384 @@ static irqreturn_t smc_irq_handler(int irq, void *data)
 		}
 
 		sc_int_reg->send_fifo_last_byte_int = 0;
-
+		
 		wake_up_interruptible(&smc->wr_wq);
 	}
-
+	
+#ifndef DET_FROM_PIO
 	sc_reg0 = SMC_READ_REG(REG0);
 	smc->cardin = sc_reg0_reg->card_detect;
-
-	if(smc_status != smc->cardin){
-            //not to set here and let user API to call smc_hw_get_status to update the card status
-            //printk(KERN_ALERT"smc_irq_handler card status changed from %d to %d.", smc_status, smc->cardin);
-            //smc_status = smc->cardin;
-       }
+#else
+	smc->cardin = _gpio_in(smc->detect_pin, SMC_DETECT_PIN_NAME);
+#endif
 
 	SMC_WRITE_REG(INTR, sc_int|0x3FF);
 
 	spin_unlock_irqrestore(&smc->slock, flags);
+	
 	return IRQ_HANDLED;
 }
 #endif
 
 static void smc_dev_deinit(smc_dev_t *smc)
 {
-	struct devio_aml_platform_data *pd_smc;
+	if(smc->irq_num!=-1) {
+		free_irq(smc->irq_num, &smc);
+	}
 
-#ifdef SMC_FIQ
-        free_fiq(INT_SMART_CARD, &smc_irq_handler);
-        del_timer(&smc_wakeup_wq_timer);
-        unregister_fiq_bridge_handle(&smc_fiq_bridge);
-#else
-        if(smc->irq_num!=-1) {
-            free_irq(smc->irq_num, &smc);
-        }
+	if(smc->enable_pin != -1) {
+		_gpio_free(smc->enable_pin,SMC_ENABLE_PIN_NAME);
+	}
+	if(smc->pin_clk_pin != -1) {
+		_gpio_free(smc->pin_clk_pin,SMC_CLK_PIN_NAME);
+	}
+#ifdef DET_FROM_PIO
+	if(smc->detect_pin != -1) {
+		_gpio_free(smc->detect_pin,SMC_DETECT_PIN_NAME);
+	}
 #endif
-
+#ifdef RST_FROM_PIO
 	if(smc->reset_pin != -1) {
-		amlogic_gpio_free(smc->reset_pin,VBUS_SMC_RESET_GPIO_OWNER);
+		_gpio_free(smc->reset_pin,SMC_RESET_PIN_NAME);
 	}
-
+#endif
+#ifdef CONFIG_OF
+	if(smc->pinctrl)
+		devm_pinctrl_put(smc->pinctrl);
+#endif
 	if(smc->dev) {
 		device_destroy(&smc_class, MKDEV(smc_major, smc->id));
 	}
+	
+	mutex_destroy(&smc->lock);
+
+	smc->init = 0;
+
+#if defined(MESON_CPU_TYPE_MESON8) && (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+	CLK_GATE_OFF(SMART_CARD_MPEG_DOMAIN);
+#endif
+
+}
+
+static int smc_dev_init(smc_dev_t *smc, int id)
+{
+#ifndef CONFIG_OF
+	struct resource *res;
+#else
+	const char *str;
+	u32 value;
+	int ret;
+#endif
+	char buf[32];
+
+#if defined(MESON_CPU_TYPE_MESON8) && (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+	CLK_GATE_ON(SMART_CARD_MPEG_DOMAIN);
+#endif
+
+	smc->id = id;
+
+#ifdef CONFIG_OF
+	smc->pinctrl = devm_pinctrl_get_select_default(&smc->pdev->dev);
+#endif
+
+	smc->enable_pin = -1;
+	if(smc->enable_pin==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_enable_pin", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_string(smc->pdev->dev.of_node, buf, &str);
+		if(!ret){
+			smc->enable_pin = amlogic_gpio_name_map_num(str);
+			ret = _gpio_request(smc->enable_pin, SMC_ENABLE_PIN_NAME);
+			pr_error("%s: %s [%d]\n", buf, str, ret);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->enable_pin = res->start;
+			gpio_request(smc->enable_pin, SMC_ENABLE_PIN_NAME);
+		}
+#endif /*CONFIG_OF*/
+	}
+
+	smc->enable_level = 1;
+	if(1) {
+		snprintf(buf, sizeof(buf), "smc%d_enable_level", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
+		if(!ret){
+			smc->enable_level = value;
+			pr_error("%s: %d\n", buf, smc->enable_level);
+			if(smc->enable_pin!=-1) {
+				_gpio_out(smc->enable_pin, !smc->enable_level, SMC_ENABLE_PIN_NAME);
+				pr_error("enable_pin: -->(%d)\n", (!smc->enable_level)?1:0);
+			}
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->enable_level = res->start;
+		}
+#endif /*CONFIG_OF*/
+	}
+
+	smc->reset_level = 1;
+	if(1) {
+		snprintf(buf, sizeof(buf), "smc%d_reset_level", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
+		if(!ret){
+			smc->reset_level = value;
+			pr_error("%s: %d\n", buf, smc->reset_level);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->reset_level = res->start;
+		}
+#endif /*CONFIG_OF*/
+	}
+	
+	smc->irq_num = smc0_irq;
+	if(smc->irq_num==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_irq", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
+		if(!ret){
+			smc->irq_num = value;
+			pr_error("%s: %d\n", buf, smc->irq_num);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+			return -1;
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_IRQ, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+			return -1;
+		}
+		smc->irq_num = res->start;
+#endif /*CONFIG_OF*/
+	}
+	
+	smc->pin_clk_pinmux_reg = -1;
+	if(smc->pin_clk_pinmux_reg==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_clk_pinmux_reg", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
+		if(!ret){
+			smc->pin_clk_pinmux_reg = value;
+			pr_error("%s: 0x%x\n", buf, smc->pin_clk_pinmux_reg);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->pin_clk_pinmux_reg = res->start;
+		}
+#endif /*CONFIG_OF*/
+	}
 
-	mutex_destroy(&smc->lock);
-
-	pd_smc =  (struct devio_aml_platform_data*)smc->pdev->dev.platform_data;
-	if(pd_smc && pd_smc->io_cleanup)
-		pd_smc->io_cleanup(NULL);
-
-	smc->init = 0;
-
-}
+	smc->pin_clk_pinmux_bit = -1;
+	if(smc->pin_clk_pinmux_bit==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_clk_pinmux_bit", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
+		if(!ret){
+			smc->pin_clk_pinmux_bit = value;
+			pr_error("%s: 0x%x\n", buf, smc->pin_clk_pinmux_bit);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->pin_clk_pinmux_bit = res->start;
+		}
+#endif /*CONFIG_OF*/
+	}
 
-static int smc_dev_init(smc_dev_t *smc, int id)
-{
-	char buf[32];
-	struct devio_aml_platform_data *pd_smc;
-	const char *gpio_name = NULL;
-	unsigned int smc_reset_pin = -1;
-	int smc_reset_level = -1;
-	int ret;
+	smc->pin_clk_oen_reg = -1;
+	if(smc->pin_clk_oen_reg==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_clk_oen_reg", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
+		if(!ret){
+			smc->pin_clk_oen_reg = value;
+			pr_error("%s: 0x%x\n", buf, smc->pin_clk_oen_reg);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->pin_clk_oen_reg = res->start;
+		}
+#endif /*CONFIG_OF*/
+	}
 
-	smc->id = id;
+	smc->pin_clk_out_reg = -1;
+	if(smc->pin_clk_out_reg==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_clk_out_reg", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
+		if(!ret){
+			smc->pin_clk_out_reg = value;
+			pr_error("%s: 0x%x\n", buf, smc->pin_clk_out_reg);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->pin_clk_out_reg = res->start;
+		}
+#endif /*CONFIG_OF*/
+	}
 
-	smc->pinctrl = devm_pinctrl_get_select_default(&smc->pdev->dev);
+	smc->pin_clk_bit = -1;
+	if(smc->pin_clk_bit==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_clk_bit", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
+		if(!ret){
+			smc->pin_clk_bit = value;
+			pr_error("%s: 0x%x\n", buf, smc->pin_clk_bit);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->pin_clk_bit = res->start;
+		}
+#endif /*CONFIG_OF*/
+	}
 
-	smc->reset_pin = smc0_reset;
-	if(smc->reset_pin==-1) {
-		gpio_name = of_get_property(smc->pdev->dev.of_node, "smc_reset", NULL);
-		if(gpio_name) {
-			smc_reset_pin = amlogic_gpio_name_map_num(gpio_name);
-			amlogic_gpio_request(smc_reset_pin,VBUS_SMC_RESET_GPIO_OWNER);
-			smc->reset_pin = smc_reset_pin;
+	smc->pin_clk_pin = -1;
+	if(smc->pin_clk_pin==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_clk_pin", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_string(smc->pdev->dev.of_node, buf, &str);
+		if(!ret){
+			smc->pin_clk_pin = amlogic_gpio_name_map_num(str);
+			ret = _gpio_request(smc->pin_clk_pin, SMC_CLK_PIN_NAME);
+			pr_error("%s: %s [%d]\n", buf, str, ret);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
 		} else {
-			pr_error("don't find to match \"smc_reset\" \n");
+			smc->pin_clk_pin = res->start;
+			gpio_request(smc->pin_clk_pin, SMC_CLK_PIN_NAME);
 		}
+#endif /*CONFIG_OF*/
 	}
 
-	smc->reset_level = 1;
-	if(1) {
-		ret = of_property_read_u32(smc->pdev->dev.of_node, "smc_reset_level",&smc_reset_level);
-		if(ret){
-			pr_error("don't find to match \"smc_reset_level\"\n");
-			return -1;
+#ifdef DET_FROM_PIO
+	smc->detect_pin = -1;
+	if(smc->detect_pin==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_det_pin", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_string(smc->pdev->dev.of_node, buf, &str);
+		if(!ret){
+			smc->detect_pin = amlogic_gpio_name_map_num(str);
+			ret = _gpio_request(smc->detect_pin, SMC_DETECT_PIN_NAME);
+			amlogic_gpio_direction_input(smc->detect_pin, SMC_DETECT_PIN_NAME);
+			pr_error("%s: %s [%d]\n", buf, str, ret);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
 		}
-		smc->reset_level = smc_reset_level;
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->detect_pin = res->start;
+			gpio_request(smc->detect_pin, SMC_DETECT_PIN_NAME);
+		}
+#endif /*CONFIG_OF*/
 	}
+#endif
 
-#ifdef SMC_FIQ
-    //since we using register_fiq_bridge_handle to handle callback, reserved only
-    init_timer(&smc_wakeup_wq_timer);
-    smc_wakeup_wq_timer.function = smc_wakeup_wq_timer_fun;
-    smc_wakeup_wq_timer.expires = jiffies + HZ;
-    add_timer(&smc_wakeup_wq_timer);
-
-    smc_reset_fiq_varible();
-    {
-        int r = -1;
-        smc_fiq_bridge.handle = smc_bridge_isr;
-        smc_fiq_bridge.key=(u32)smc_bridge_isr;
-        smc_fiq_bridge.name="smc_bridge_isr";
-        r = register_fiq_bridge_handle(&smc_fiq_bridge);
-        if(r) {
-            pr_error( "smc fiq bridge register error.\n");
-            return -1;
-        }
-    }
-    request_fiq(INT_SMART_CARD, &smc_irq_handler);
-#else
-        smc->irq_num = INT_SMART_CARD;
+#ifdef RST_FROM_PIO
+	smc->reset_pin = -1;
+	if(smc->reset_pin==-1) {
+		snprintf(buf, sizeof(buf), "smc%d_reset_pin", id);
+#ifdef CONFIG_OF
+		ret = of_property_read_string(smc->pdev->dev.of_node, buf, &str);
+		if(!ret){
+			smc->reset_pin = amlogic_gpio_name_map_num(str);
+			ret = _gpio_request(smc->reset_pin, SMC_RESET_PIN_NAME);
+			pr_error("%s: %s [%d]\n", buf, str, ret);
+		}else{
+			pr_error("cannot find resource \"%s\"\n", buf);
+		}
+#else /*CONFIG_OF*/
+		res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
+		if (!res) {
+			pr_error("cannot get resource \"%s\"\n", buf);
+		} else {
+			smc->reset_pin = res->start;
+			gpio_request(smc->reset_pin, SMC_RESET_PIN_NAME);
+		}
+#endif /*CONFIG_OF*/
+	}
 #endif
 
 	init_waitqueue_head(&smc->rd_wq);
 	init_waitqueue_head(&smc->wr_wq);
 
-#ifdef SMC_FIQ
-        smc_rd_wq = &smc->rd_wq;
-        smc_wr_wq = &smc->wr_wq;
-#endif
-
 	spin_lock_init(&smc->slock);
 	mutex_init(&smc->lock);
 
-	pd_smc =  (struct devio_aml_platform_data*)smc->pdev->dev.platform_data;
-	if(pd_smc) {
-		if(pd_smc->io_setup)
-			pd_smc->io_setup(NULL);
-
-		smc->reset = pd_smc->io_reset;
-	}
-
 #ifdef SMC_FIQ
-        request_fiq(INT_SMART_CARD, &smc_irq_handler);
+	{
+		int r = -1;
+		smc->smc_fiq_bridge.handle = smc_bridge_isr;
+		smc->smc_fiq_bridge.key=(u32)smc;
+		smc->smc_fiq_bridge.name="smc_bridge_isr";
+		r = register_fiq_bridge_handle(&smc->smc_fiq_bridge);
+		if(r) {
+			pr_error( "smc fiq bridge register error.\n");
+			return -1;
+		}
+	}
+	request_fiq(smc->irq_num, &smc_irq_handler);
 #else
-        smc->irq_num=request_irq(smc->irq_num,(irq_handler_t)smc_irq_handler,IRQF_SHARED,"smc",smc);
-        if(smc->irq_num<0) {
-            pr_error("request irq error!\n");
-            smc_dev_deinit(smc);
-            return -1;
-        }
+	smc->irq_num=request_irq(smc->irq_num,(irq_handler_t)smc_irq_handler,IRQF_SHARED,"smc",smc);
+	if(smc->irq_num<0) {
+		pr_error("request irq error!\n");
+		smc_dev_deinit(smc);
+		return -1;
+	}
 #endif
-
+	
 	snprintf(buf, sizeof(buf), "smc%d", smc->id);
 	smc->dev=device_create(&smc_class, NULL, MKDEV(smc_major, smc->id), smc, buf);
 	if(!smc->dev) {
@@ -1574,16 +1893,18 @@ static int smc_dev_init(smc_dev_t *smc, int id)
 	smc->param.bgt = BGT_DEFAULT;
 	smc->param.freq = FREQ_DEFAULT;
 	smc->param.recv_invert = 0;
+	smc->param.recv_parity = 0;
 	smc->param.recv_lsb_msb = 0;
 	smc->param.recv_no_parity = 1;
 	smc->param.xmit_invert = 0;
 	smc->param.xmit_lsb_msb = 0;
 	smc->param.xmit_retries = 1;
 	smc->param.xmit_repeat_dis = 1;
+	smc->param.xmit_parity = 0;
 	smc->init = 1;
 
 	smc_hw_setup(smc);
-
+	
 	return 0;
 }
 
@@ -1591,15 +1912,19 @@ static int smc_open(struct inode *inode, struct file *filp)
 {
 	int id = iminor(inode);
 	smc_dev_t *smc = &smc_dev[id];
-
+	
 	mutex_lock(&smc->lock);
 
+#ifdef FILE_DEBUG
+	open_debug();
+#endif
+	
 	if(smc->used) {
 		mutex_unlock(&smc->lock);
 		pr_error("smartcard %d already openned!", id);
 		return -EBUSY;
 	}
-
+	
 	smc->used = 1;
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
@@ -1607,15 +1932,16 @@ static int smc_open(struct inode *inode, struct file *filp)
 #endif
 
 	mutex_unlock(&smc->lock);
-
+	
 	filp->private_data = smc;
+
 	return 0;
 }
 
 static int smc_close(struct inode *inode, struct file *filp)
 {
 	smc_dev_t *smc = (smc_dev_t*)filp->private_data;
-
+	
 	mutex_lock(&smc->lock);
 	smc_hw_deactive(smc);
 	smc->used = 0;
@@ -1624,133 +1950,158 @@ static int smc_close(struct inode *inode, struct file *filp)
 	switch_mod_gate_by_name("smart_card", 0);
 #endif
 
-	mutex_unlock(&smc->lock);
+#ifdef FILE_DEBUG
+	close_debug();
+#endif
 
+	mutex_unlock(&smc->lock);
+	
 	return 0;
 }
 
 #ifdef SMC_FIQ
 static int smc_read(struct file *filp,char __user *buff, size_t size, loff_t *ppos)
 {
-    smc_dev_t *smc = (smc_dev_t*)filp->private_data;
-    int ret;
-    char temp_buf[512];
-    unsigned long flags;
-
-    ret = mutex_lock_interruptible(&smc->lock);
-    if(ret) return ret;
+	smc_dev_t *smc = (smc_dev_t*)filp->private_data;
+	unsigned long flags;
+	int ret;
+	unsigned long sc_int;
+	SMC_INTERRUPT_Reg_t *sc_int_reg = (void *)&sc_int;
+	int start=0, end;
 
-    if(!smc->cardin) {
-        mutex_unlock(&smc->lock);
-        return -ENODEV;
-    }
+	ret = mutex_lock_interruptible(&smc->lock);
+	if(ret) return ret;
 
-    //printk(KERN_ALERT"<<<<==== to read %d data  from smartcard and received:%d.\n", size, smc_recv_bak_idx);
-    //if(!(filp->f_flags&O_NONBLOCK))
-    {
-        //ret = wait_event_interruptible(smc->rd_wq, smc_read_write_check(true, -1, -1));
-    }
-    //printk(KERN_ALERT"ret is:0x%x.\n", ret);
-
-    if(ret ==0){
-        spin_lock_irqsave(&smc->slock, flags);
-        ret = smc_read_write_data(true, temp_buf, size);
-        spin_unlock_irqrestore(&smc->slock, flags);
-        if(ret == size){
-            if(smc_debug_flag > 0){
-                if(8==size)
-                    printk(KERN_ALERT"smc_read......success data 7 is:%d.\n", temp_buf[7]);
-                else
-                    printk(KERN_ALERT"<<<<==== to read %d data  from smartcard and received:%d.\n", size, smc_recv_bak_idx);
-                smc_print_data(temp_buf, size);
-            }
-            ret = copy_to_user(buff, temp_buf, size);
-		if(ret<0) {
-			printk("ret =%d \n",ret);
-        		return ret;
-    		}
-        }else{
-            //printk(KERN_ALERT"smc_read.......failed.\n");
-            ret = 0;
-        }
-    }
+	spin_lock_irqsave(&smc->slock, flags);
+	if(ret==0) {
+		
+		start = smc->recv_start;
+		end = smc->recv_end;
 
-    mutex_unlock(&smc->lock);
-    //printk(KERN_ALERT"smc_read.......ret:%d..\n", ret);
-    return ret;
+		if(!smc->cardin) {
+			ret = -ENODEV;
+		} else if (start==end) {
+			ret = -EAGAIN;
+		} else {
+			ret = (end>start)? (end-start):(RECV_BUF_SIZE-start+end);
+			if(ret>size)
+				ret = size;
+		}
+	}
+	
+	if(ret>0) {
+		int cnt = RECV_BUF_SIZE-start;
+		pr_dbg("read %d bytes\n", ret);
+		if(cnt>=ret) {
+			copy_to_user(buff, smc->recv_buf+start, ret);
+		} else {
+			int cnt1 = ret-cnt;
+			copy_to_user(buff, smc->recv_buf+start, cnt);
+			copy_to_user(buff+cnt, smc->recv_buf, cnt1);
+		}
+		_atomic_wrap_add(&smc->recv_start, ret, RECV_BUF_SIZE);
+	}
+	spin_unlock_irqrestore(&smc->slock, flags);
+	
+	mutex_unlock(&smc->lock);
+	
+	return ret;
 }
 
-static void smc_reset_recv_bak_data(void){
-    int idx = 0;
+static int smc_write(struct file *filp, const char __user *buff, size_t size, loff_t *offp)
+{
+	smc_dev_t *smc = (smc_dev_t*)filp->private_data;
+	unsigned long flags;
+	int pos = 0, ret;
+	unsigned long sc_int;
+	SMC_INTERRUPT_Reg_t *sc_int_reg = (void *)&sc_int;
+	int start=0, end;
+
+	ret = mutex_lock_interruptible(&smc->lock);
+	if(ret) return ret;
+	
+	spin_lock_irqsave(&smc->slock, flags);
+
+	if(ret==0) {
+
+		start = smc->send_start;
+		end = smc->send_end;
+
+		if(!smc->cardin) {
+			ret = -ENODEV;
+		} else if(start!=end){
+			ret = -EAGAIN;
+		} else {
+			ret = size;
+			if(ret>=SEND_BUF_SIZE)
+				ret=SEND_BUF_SIZE-1;
+		}
+	}
+	
+	if(ret>0) {
+		int cnt = SEND_BUF_SIZE-start;
+		
+		if(cnt>=ret) {
+			copy_from_user(smc->send_buf+start, buff, ret);
+		} else {
+			int cnt1 = ret-cnt;
+			copy_from_user(smc->send_buf+start, buff, cnt);
+			copy_from_user(smc->send_buf, buff+cnt, cnt1);
+		}
+		_atomic_wrap_add(&smc->send_start, ret, SEND_BUF_SIZE);
+	}
+
+	spin_unlock_irqrestore(&smc->slock, flags);
+	
+	if(ret>0) {
+		sc_int = SMC_READ_REG(INTR);
+#ifdef DISABLE_RECV_INT
+		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 0;
+#endif
+		sc_int_reg->send_fifo_last_byte_int_mask = 1;
+		SMC_WRITE_REG(INTR, sc_int|0x3FF);
+		
+		pr_dbg("write %d bytes\n", ret);
 
-    smc_recv_bak_idx = 0;
-    for(idx = 0; idx < SMC_CNT; idx++)
-        smc_recv_data_bak[idx] = 0x0;
+		smc_hw_start_send(smc);
+	}
+	
+	mutex_unlock(&smc->lock);
+	
+	return ret;
 }
 
-static int smc_write(struct file *filp, const char __user *buff, size_t size, loff_t *offp)
+static unsigned int smc_poll(struct file *filp, struct poll_table_struct *wait)
 {
-    smc_dev_t *smc = (smc_dev_t*)filp->private_data;
-    int ret;
-    unsigned long sc_int;
-    SMC_INTERRUPT_Reg_t *sc_int_reg = (void *)&sc_int;
-    char temp_buf[512];
-    unsigned long flags;
-
-    ret = mutex_lock_interruptible(&smc->lock);
-    if(ret) return ret;
-
-    if(!smc->cardin) {
-        mutex_unlock(&smc->lock);
-        return -ENODEV;
-    }
-
-    //printk(KERN_ALERT"===>>>> to write %d byte data to smartcard. -->\n", size);
-    //ret = wait_event_interruptible(smc->wr_wq, smc_read_write_check(false, -1, -1));
-    //printk(KERN_ALERT"ret is:0x%x.\n", ret);
-
-    if(ret == 0){
-        ret = copy_from_user(temp_buf, buff, size);
-	if(ret<0) {
-		printk("ret =%d \n",ret);
-        	return ret;
-    	}
-
-        spin_lock_irqsave(&smc->slock, flags);
-        if(smc_read_write_check(true, smc_read_fiq_idx, -1)) ret = -1;
-        else ret = smc_read_write_data(false, temp_buf, size);
-        spin_unlock_irqrestore(&smc->slock, flags);
-
-        smc_reset_recv_bak_data();
-
-        if(ret == size){
-            //smc_print_data(temp_buf, size);
-            if(smc_debug_flag > 0){
-                printk(KERN_ALERT"smc_write %d byte success.\n", size);
-                smc_print_data(temp_buf, size);
-            }
-            smc_hw_start_send(smc);
-            sc_int = SMC_READ_REG(INTR);
-            sc_int_reg->send_fifo_last_byte_int_mask = 1;
-            SMC_WRITE_REG(INTR, sc_int|0x3FF);
-        }else{
-            //printk(KERN_ALERT"smc_write.....failed.\n");
-            ret = 0;
-        }
-    }
-    mutex_unlock(&smc->lock);
-    //printk(KERN_ALERT"smc_write.....ret:%d..\n", ret);
+	smc_dev_t *smc = (smc_dev_t*)filp->private_data;
+	unsigned int ret = 0;
+	unsigned long flags;
+	
+	poll_wait(filp, &smc->rd_wq, wait);
+	poll_wait(filp, &smc->wr_wq, wait);
+	
+	spin_lock_irqsave(&smc->slock, flags);
 
-    return ret;
+	if(smc->recv_start!=smc->recv_end) ret |= POLLIN|POLLRDNORM;
+	if(smc->send_start==smc->send_end) ret |= POLLOUT|POLLWRNORM;
+	if(!smc->cardin) ret |= POLLERR;
+	
+	spin_unlock_irqrestore(&smc->slock, flags);
+	
+	return ret;
 }
+
 #else
+
 static int smc_read(struct file *filp,char __user *buff, size_t size, loff_t *ppos)
 {
 	smc_dev_t *smc = (smc_dev_t*)filp->private_data;
 	unsigned long flags;
 	int pos = 0, ret;
-	//unsigned long sc_int;
-	//SMC_INTERRUPT_Reg_t *sc_int_reg = (void *)&sc_int;
+#ifdef DISABLE_RECV_INT
+	unsigned long sc_int;
+	SMC_INTERRUPT_Reg_t *sc_int_reg = (void *)&sc_int;
+#endif
 
 	ret = mutex_lock_interruptible(&smc->lock);
 	if(ret) return ret;
@@ -1760,25 +2111,25 @@ static int smc_read(struct file *filp,char __user *buff, size_t size, loff_t *pp
 	if(!(filp->f_flags&O_NONBLOCK)) {
 		ret = wait_event_interruptible(smc->wr_wq, smc_write_end(smc));
 	}
-
+	
 	if(ret==0) {
 		pr_dbg("wait read buffer\n");
-
+		
 		sc_int = SMC_READ_REG(INTR);
 		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 1;
 		sc_int_reg->send_fifo_last_byte_int_mask = 0;
 		SMC_WRITE_REG(INTR, sc_int|0x3FF);
-
+		
 		if(!(filp->f_flags&O_NONBLOCK)) {
 			ret = wait_event_interruptible(smc->rd_wq, smc_can_read(smc));
 		}
 	}
 #endif
-
+	
 	if(ret==0) {
-
+		
 		spin_lock_irqsave(&smc->slock, flags);
-
+		
 		if(!smc->cardin) {
 			ret = -ENODEV;
 		} else if (!smc->recv_count) {
@@ -1786,7 +2137,7 @@ static int smc_read(struct file *filp,char __user *buff, size_t size, loff_t *pp
 		} else {
 			ret = smc->recv_count;
 			if(ret>size) ret = size;
-
+			
 			pos = smc->recv_start;
 			smc->recv_start += ret;
 			smc->recv_count -= ret;
@@ -1794,34 +2145,24 @@ static int smc_read(struct file *filp,char __user *buff, size_t size, loff_t *pp
 		}
 		spin_unlock_irqrestore(&smc->slock, flags);
 	}
-
+	
 	if(ret>0) {
 		int cnt = RECV_BUF_SIZE-pos;
+		long cr;
+
 		pr_dbg("read %d bytes\n", ret);
 
 		if(cnt>=ret) {
-			ret = copy_to_user(buff, smc->recv_buf+pos, ret);
-			if(ret<0) {
-				printk("ret =%d \n",ret);
-        			return ret;
-    			}
+			cr = copy_to_user(buff, smc->recv_buf+pos, ret);
 		} else {
 			int cnt1 = ret-cnt;
-			ret = copy_to_user(buff, smc->recv_buf+pos, cnt);
-			if(ret<0) {
-				printk("ret =%d \n",ret);
-        			return ret;
-    			}
-			ret = copy_to_user(buff+cnt, smc->recv_buf, cnt1);
-			if(ret<0) {
-				printk("ret =%d \n",ret);
-        			return ret;
-    			}
+			cr = copy_to_user(buff, smc->recv_buf+pos, cnt);
+			cr = copy_to_user(buff+cnt, smc->recv_buf, cnt1);
 		}
 	}
-
+	
 	mutex_unlock(&smc->lock);
-
+	
 	return ret;
 }
 
@@ -1835,16 +2176,16 @@ static int smc_write(struct file *filp, const char __user *buff, size_t size, lo
 
 	ret = mutex_lock_interruptible(&smc->lock);
 	if(ret) return ret;
-
-	pr_dbg("wait write buffer\n");
-
+	
+	//pr_dbg("wait write buffer\n");
+	
 	if(!(filp->f_flags&O_NONBLOCK)) {
 		ret = wait_event_interruptible(smc->wr_wq, smc_can_write(smc));
 	}
-
+	
 	if(ret==0) {
 		spin_lock_irqsave(&smc->slock, flags);
-
+		
 		if(!smc->cardin) {
 			ret = -ENODEV;
 		} else if (smc->send_count==SEND_BUF_SIZE) {
@@ -1852,77 +2193,84 @@ static int smc_write(struct file *filp, const char __user *buff, size_t size, lo
 		} else {
 			ret = SEND_BUF_SIZE-smc->send_count;
 			if(ret>size) ret = size;
-
+			
 			pos = smc->send_start+smc->send_count;
 			pos %= SEND_BUF_SIZE;
 			smc->send_count += ret;
 		}
-
+		
 		spin_unlock_irqrestore(&smc->slock, flags);
 	}
-
+	
 	if(ret>0) {
 		int cnt = SEND_BUF_SIZE-pos;
+		long cr;
 
 		if(cnt>=ret) {
-			ret = copy_from_user(smc->send_buf+pos, buff, ret);
-			 if(ret<0) {
-				printk("ret =%d \n",ret);
-        			return ret;
-    			}
+			cr = copy_from_user(smc->send_buf+pos, buff, ret);
 		} else {
 			int cnt1 = ret-cnt;
-			ret = copy_from_user(smc->send_buf+pos, buff, cnt);
-			 if(ret<0) {
-				printk("ret =%d \n",ret);
-        			return ret;
-    			}
-			ret = copy_from_user(smc->send_buf, buff+cnt, cnt1);
-			 if(ret<0) {
-				printk("ret =%d \n",ret);
-        			return ret;
-    			}
+			cr = copy_from_user(smc->send_buf+pos, buff, cnt);
+			cr = copy_from_user(smc->send_buf, buff+cnt, cnt1);
 		}
-
+		
 		sc_int = SMC_READ_REG(INTR);
 #ifdef DISABLE_RECV_INT
 		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 0;
 #endif
 		sc_int_reg->send_fifo_last_byte_int_mask = 1;
 		SMC_WRITE_REG(INTR, sc_int|0x3FF);
-
+		
 		pr_dbg("write %d bytes\n", ret);
 
 		smc_hw_start_send(smc);
 	}
 
-
+	
 	mutex_unlock(&smc->lock);
+	
+	return ret;
+}
+
+static unsigned int smc_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	smc_dev_t *smc = (smc_dev_t*)filp->private_data;
+	unsigned int ret = 0;
+	unsigned long flags;
+	
+	poll_wait(filp, &smc->rd_wq, wait);
+	poll_wait(filp, &smc->wr_wq, wait);
+	
+	spin_lock_irqsave(&smc->slock, flags);
 
+	if(smc->recv_count) ret |= POLLIN|POLLRDNORM;
+	if(smc->send_count!=SEND_BUF_SIZE) ret |= POLLOUT|POLLWRNORM;
+	if(!smc->cardin) ret |= POLLERR;
+	
+	spin_unlock_irqrestore(&smc->slock, flags);
+	
 	return ret;
 }
+
 #endif
 
-static long smc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+static long smc_ioctl(struct file *file, unsigned int cmd, ulong arg)
 {
 	smc_dev_t *smc = (smc_dev_t*)file->private_data;
 	int ret = 0;
+	long cr;
 
 	switch(cmd) {
 		case AMSMC_IOC_RESET:
 		{
 			ret = mutex_lock_interruptible(&smc->lock);
 			if(ret) return ret;
-
+			
 			ret = smc_hw_reset(smc);
 			if(ret>=0) {
-				ret = copy_to_user((void*)arg, &smc->atr, sizeof(struct am_smc_atr));
-				if(ret<0) {
-					printk("ret =%d \n",ret);
-        				return ret;
-    				}
+				cr = copy_to_user((void*)arg, &smc->atr, sizeof(struct am_smc_atr));
 			}
-
+			
 			mutex_unlock(&smc->lock);
 		}
 		break;
@@ -1931,11 +2279,7 @@ static long smc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			int status;
 			ret = smc_hw_get_status(smc, &status);
 			if(ret>=0) {
-				ret = copy_to_user((void*)arg, &status, sizeof(int));
-				if(ret<0) {
-					printk("ret =%d \n",ret);
-        				return ret;
-    				}				
+				cr = copy_to_user((void*)arg, &status, sizeof(int));
 			}
 		}
 		break;
@@ -1943,9 +2287,9 @@ static long smc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			ret = mutex_lock_interruptible(&smc->lock);
 			if(ret) return ret;
-
+			
 			ret = smc_hw_active(smc);
-
+			
 			mutex_unlock(&smc->lock);
 		}
 		break;
@@ -1953,9 +2297,9 @@ static long smc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			ret = mutex_lock_interruptible(&smc->lock);
 			if(ret) return ret;
-
+			
 			ret = smc_hw_deactive(smc);
-
+			
 			mutex_unlock(&smc->lock);
 		}
 		break;
@@ -1963,12 +2307,9 @@ static long smc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			ret = mutex_lock_interruptible(&smc->lock);
 			if(ret) return ret;
-
-			ret = copy_to_user((void*)arg, &smc->param, sizeof(struct am_smc_param));
-			if(ret<0) {
-				printk("ret =%d \n",ret);
-        			return ret;
-    			}
+			
+			cr = copy_to_user((void*)arg, &smc->param, sizeof(struct am_smc_param));
+			
 			mutex_unlock(&smc->lock);
 		}
 		break;
@@ -1976,14 +2317,10 @@ static long smc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		{
 			ret = mutex_lock_interruptible(&smc->lock);
 			if(ret) return ret;
-
-			ret = copy_from_user(&smc->param, (void*)arg, sizeof(struct am_smc_param));
-			if(ret<0) {
-				printk("ret =%d \n",ret);
-        			return ret;
-    			}			
+			
+			cr = copy_from_user(&smc->param, (void*)arg, sizeof(struct am_smc_param));
 			ret = smc_hw_set_param(smc);
-
+			
 			mutex_unlock(&smc->lock);
 		}
 		break;
@@ -1991,54 +2328,10 @@ static long smc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			ret = -EINVAL;
 		break;
 	}
-
+	
 	return ret;
 }
 
-static unsigned int smc_poll(struct file *filp, struct poll_table_struct *wait)
-{
-    smc_dev_t *smc = (smc_dev_t*)filp->private_data;
-    unsigned int ret = 0;
-    unsigned long flags;
-
-#ifdef SMC_FIQ
-    bool can_read = false, can_write = false;
-    int temp_r_idx = smc_read_fiq_idx, temp_w_idx = smc_write_fiq_idx;
-    //printk(KERN_ALERT"11 going to poll and can_read:%d, can write:%d.\n", can_read, can_write);
-
-    poll_wait(filp, &smc->rd_wq, wait);
-    poll_wait(filp, &smc->wr_wq, wait);
-
-    can_read  = smc_read_write_check(true, temp_r_idx, temp_w_idx);
-    can_write = smc_read_write_check(false, temp_r_idx, temp_w_idx);
-
-    //printk(KERN_ALERT"22 going to poll and can_read:%d, can write:%d.\n", can_read, can_write);
-
-    //if(can_read) wake_up_interruptible(&smc->rd_wq);
-    //if(can_write) wake_up_interruptible(&smc->wr_wq);
-
-#else
-    poll_wait(filp, &smc->rd_wq, wait);
-    poll_wait(filp, &smc->wr_wq, wait);
-#endif
-
-    spin_lock_irqsave(&smc->slock, flags);
-
-#ifdef SMC_FIQ
-    if(can_read) ret |= POLLIN|POLLRDNORM; //0x41
-    if(can_write) ret |= POLLOUT|POLLWRNORM; //0x104
-    if(!smc_cardin) ret |= POLLERR;
-    smc->cardin = smc_cardin;//may be not a good idea to update here
-    //printk(KERN_ALERT"smc poll the ret is:0x%x,r/fiq_r:%d/%d, w/fiq_w:%d/%d.\n", ret,  smc_read_idx,temp_r_idx,smc_write_idx, temp_w_idx);
-#else
-    if(smc->recv_count) ret |= POLLIN|POLLRDNORM;
-    if(smc->send_count!=SEND_BUF_SIZE) ret |= POLLOUT|POLLWRNORM;
-    if(!smc->cardin) ret |= POLLERR;
-#endif
-    spin_unlock_irqrestore(&smc->slock, flags);
-
-    return ret;
-}
 
 static struct file_operations smc_fops =
 {
@@ -2055,118 +2348,87 @@ static int smc_probe(struct platform_device *pdev)
 {
 	smc_dev_t *smc = NULL;
 	int i, ret;
-
+	
 	mutex_lock(&smc_lock);
-
+	
 	for (i=0; i<SMC_DEV_COUNT; i++) {
 		if (!smc_dev[i].init) {
 			smc = &smc_dev[i];
 			break;
 		}
 	}
-
+	
 	if(smc) {
 		smc->init = 1;
 		smc->pdev = pdev;
 		dev_set_drvdata(&pdev->dev, smc);
-
+	
 		if ((ret=smc_dev_init(smc, i))<0) {
 			smc = NULL;
 		}
 	}
-
+	
 	mutex_unlock(&smc_lock);
-
+	
 	return smc ? 0 : -1;
 }
 
 static int smc_remove(struct platform_device *pdev)
 {
 	smc_dev_t *smc = (smc_dev_t*)dev_get_drvdata(&pdev->dev);
-
+	
 	mutex_lock(&smc_lock);
-
+	
 	smc_dev_deinit(smc);
-
-	if(smc->pinctrl)
-		devm_pinctrl_put(smc->pinctrl);
-
+	
 	mutex_unlock(&smc_lock);
-
+	
 	return 0;
 }
 
-static int smc_suspend(struct platform_device *dev, pm_message_t state)
-{
-    unsigned long flags;
-    smc_dev_t *smc = (smc_dev_t*)dev_get_drvdata(&dev->dev);
-
-    spin_lock_irqsave(&smc->slock, flags);
-    //printk(KERN_ALERT"The smc_suspend be called and card status is:%d.\n", smc_status);
-    //smc_status = SUSPEND_CARD_STATUS; //no use to set here
-    spin_unlock_irqrestore(&smc->slock, flags);
-
-    return 0;
-}
-
-static int smc_resume(struct platform_device *dev)
-{
-    unsigned long flags;
-    smc_dev_t *smc = (smc_dev_t*)dev_get_drvdata(&dev->dev);
-
-    spin_lock_irqsave(&smc->slock, flags);
-    //smc_status = SUSPEND_CARD_STATUS;
-    //printk(KERN_ALERT"The smc_resume be called and card status is:%d.\n", smc_status);
-    spin_unlock_irqrestore(&smc->slock, flags);
-
-    return 0;
-}
-
 #ifdef CONFIG_OF
-static const struct of_device_id meson6tv_smc_dt_match[]={
+static const struct of_device_id smc_dt_match[]={
 	{	.compatible = "amlogic,smartcard",
 	},
 	{},
 };
 #else
-#define meson6tv_smc_dt_match NULL
+#define smc_dt_match NULL
 #endif
 
 static struct platform_driver smc_driver = {
-        .resume = smc_resume,
-        .suspend = smc_suspend,
-        .probe		= smc_probe,
-        .remove		= smc_remove,
-        .driver		= {
-	        .name	= "amlogic-smc",
-	        .owner	= THIS_MODULE,
-		.of_match_table = meson6tv_smc_dt_match,
-        }
+	.probe		= smc_probe,
+	.remove		= smc_remove,	
+	.driver		= {
+		.name	= "amlogic-smc",
+		.owner	= THIS_MODULE,
+		.of_match_table = smc_dt_match,
+	},
 };
 
 static int __init smc_mod_init(void)
 {
 	int ret = -1;
-
+	
 	mutex_init(&smc_lock);
-
+	
 	smc_major = register_chrdev(0, SMC_DEV_NAME, &smc_fops);
 	if(smc_major<=0) {
 		mutex_destroy(&smc_lock);
 		pr_error("register chrdev error\n");
 		goto error_register_chrdev;
 	}
-
+	
 	if(class_register(&smc_class)<0) {
 		pr_error("register class error\n");
 		goto error_class_register;
 	}
-
+	
 	if(platform_driver_register(&smc_driver)<0) {
 		pr_error("register platform driver error\n");
 		goto error_platform_drv_register;
 	}
-
+	
 	return 0;
 error_platform_drv_register:
 	class_unregister(&smc_class);
diff --git a/drivers/amlogic/smartcard/smc_reg.h b/drivers/amlogic/smartcard/smc_reg.h
index b788ba0191f9..5d6a139ec4a2 100755
--- a/drivers/amlogic/smartcard/smc_reg.h
+++ b/drivers/amlogic/smartcard/smc_reg.h
@@ -32,6 +32,7 @@
 #define FREQ_DEFAULT 4000 //KHz
 #define FIFO_THRESHOLD_DEFAULT 1
 #define ETU_DIVIDER_CLOCK_HZ    24000 // KHz
+#define ETU_CLK_SEL  0
 #define ATR_HOLDOFF_EN 1
 #define ATR_CLK_MUX_DEFAULT 4
 #define ATR_HOLDOFF_TCNT_DEFAULT 255
@@ -42,7 +43,7 @@
 #define N_DEFAULT 0
 #define CWI_DEFAULT 13
 #define BWI_DEFAULT 4
-#define BGT_DEFAULT 20
+#define BGT_DEFAULT 22
 #define CLK_SRC_DEFAULT 0
 
 typedef struct SMCCARD_HW_Reg0
@@ -83,9 +84,11 @@ typedef struct SMC_ANSWER_TO_RST
 	unsigned atr_holdoff_tcnt: 8;       // Bit 23:16
 	unsigned atr_clk_mux: 3;            // Bit 26:24
 	unsigned atr_holdoff_en: 1;         // Bit 27
-	unsigned unused: 4;                 // Bit 31:28
+	unsigned etu_clk_sel: 2;            // Bit 29:28
+	unsigned unused: 2;                 // Bit 31:30
 #else
-	unsigned unused: 4;                 // Bit 31:28
+	unsigned unused: 2;                 // Bit 31:30
+	unsigned etu_clk_sel: 2;            // Bit 29:28
 	unsigned atr_holdoff_en: 1;         // Bit 27
 	unsigned atr_clk_mux: 3;            // Bit 26:24
 	unsigned atr_holdoff_tcnt: 8;       // Bit 23:16
diff --git a/include/linux/amlogic/amsmc.h b/include/linux/amlogic/amsmc.h
index fd8452c71514..85bfceacb3b3 100755
--- a/include/linux/amlogic/amsmc.h
+++ b/include/linux/amlogic/amsmc.h
@@ -44,10 +44,12 @@ struct am_smc_param {
 	int     recv_invert;
 	int     recv_lsb_msb;
 	int     recv_no_parity;
+	int     recv_parity;
 	int     xmit_invert;
 	int     xmit_lsb_msb;
 	int     xmit_retries;
 	int     xmit_repeat_dis;
+	int     xmit_parity;
 };
 
 #define AMSMC_IOC_MAGIC  'C'
-- 
2.19.0

