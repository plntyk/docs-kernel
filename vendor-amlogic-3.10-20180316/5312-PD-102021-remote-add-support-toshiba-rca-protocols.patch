From d7b89279a69ff29b2f33babbbec44537bda25aad Mon Sep 17 00:00:00 2001
From: "baoqi.wang" <baoqi.wang@amlogic.com>
Date: Fri, 9 Jan 2015 13:23:58 +0800
Subject: [PATCH 5312/5965] PD#102021: remote: add support toshiba & rca
 protocols

by zhimao peicai baoqi
---
 .../amlogic/input/new_remote/remote_func.c    | 709 +++++++++++++-----
 .../amlogic/input/new_remote/remote_main.c    | 274 ++++---
 .../amlogic/input/new_remote/remote_main.h    | 331 ++++----
 3 files changed, 830 insertions(+), 484 deletions(-)

diff --git a/drivers/amlogic/input/new_remote/remote_func.c b/drivers/amlogic/input/new_remote/remote_func.c
index 4800300ca5d1..e36e272ed9fb 100755
--- a/drivers/amlogic/input/new_remote/remote_func.c
+++ b/drivers/amlogic/input/new_remote/remote_func.c
@@ -35,6 +35,8 @@ static const remotereg_t *remoteregsTab[] = {
 	RDECODEMODE_SANYO,
 	RDECODEMODE_SKIPLEADER,
 	RDECODEMODE_SW,
+	RDECODEMODE_NEC_RCA_2IN1,
+	RDECODEMODE_NEC_TOSHIBA_2IN1,
 	RDECODEMODE_SW_NEC,
 	NULL,
 	RDECODEMODE_SW_DUOKAN
@@ -43,6 +45,7 @@ extern char *remote_log_buf;
 static int auto_repeat_count,repeat_count = 0;
 static void remote_rel_timer_sr(unsigned long data);
 static void remote_repeat_sr(unsigned long data);
+static void remote_rca_repeat_sr(unsigned long data);
 static int dbg_printk(const char *fmt, ...)
 {
 	char buf[100];
@@ -57,7 +60,8 @@ static int dbg_printk(const char *fmt, ...)
 	va_end(args);
 	return 0;
 }
-int set_remote_mode(int mode){
+int set_remote_mode(int mode)
+{
 	const remotereg_t *reg;
 	reg = remoteregsTab[mode];
 	while(CONFIG_END != reg->reg)
@@ -71,13 +75,14 @@ void setremotereg(const remotereg_t *r)
 	am_remote_write_reg(r->reg, r->val);
 	printk("[0x%x] = 0x%x\n", r->reg, r->val);
 }
-void config_sw_init_window(struct remote *remote_data){
-	switch(remote_data->work_mode){
+void config_sw_init_window(struct remote *remote_data)
+{
+	switch(remote_data->work_mode) {
 		case DECODEMODE_SW_NEC:
 			remote_data->bit_count = 32;
 			remote_data->debug_enable = 1;
-			remote_data->release_delay = 108;
-			remote_data->repeat_enable = 0;
+			remote_data->release_delay[remote_data->map_num]  = 108;
+			remote_data->repeat_enable  = 0;
 			remote_data->time_window[0] = 500;
 			remote_data->time_window[1] = 700;
 			remote_data->time_window[2] = 50;
@@ -115,41 +120,89 @@ void kdb_send_key(struct input_dev *dev, unsigned int scancode,
 
 void set_remote_init(struct remote *remote_data)
 {
-	if(remote_data->work_mode <= DECODEMODE_MAX){
-		if(remote_data->work_mode > DECODEMODE_NEC){
-			setup_timer(&remote_data->repeat_timer, remote_repeat_sr, 0);
+	if(remote_data->work_mode <= DECODEMODE_MAX) {
+		if(remote_data->work_mode > DECODEMODE_NEC) {
+			if(remote_data->work_mode == DECODEMODE_NEC_RCA_2IN1)
+				setup_timer(&remote_data->repeat_timer, remote_rca_repeat_sr, 0);
+			else
+				setup_timer(&remote_data->repeat_timer, remote_repeat_sr, 0);
 			printk("enter in sw repeat mode \n");
 		}
 		return ;
 	}
 	config_sw_init_window(remote_data);
 }
-void changeduokandecodeorder(struct remote *remote_data){
+void changeduokandecodeorder(struct remote *remote_data)
+{
 	unsigned int scancode = remote_data->cur_lsbkeycode;
 	remote_data->cur_lsbkeycode =((scancode&0x3)<<18)|((scancode&0xc)<<14)|((scancode&0x30)<<10)|\
-	((scancode&0xc0)<<6)|((scancode&0x300)<<2)|((scancode&0xc00)>>2)|((scancode&0x3000)>>6)|\
-	((scancode&0xc000)>>10)|((scancode&0x30000)>>14)|((scancode&0xc0000)>>18);
+				     ((scancode&0xc0)<<6)|((scancode&0x300)<<2)|((scancode&0xc00)>>2)|((scancode&0x3000)>>6)|\
+				     ((scancode&0xc000)>>10)|((scancode&0x30000)>>14)|((scancode&0xc0000)>>18);
 	if(remote_data->cur_lsbkeycode == 0x0003cccf)
-			remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
+		remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
 }
-void get_cur_scancode(struct remote *remote_data){
-	if(remote_data->work_mode== DECODEMODE_SANYO){
+void get_cur_scancode(struct remote *remote_data)
+{
+	int temp_cur_lsbkeycode =0;
+	if(remote_data->work_mode== DECODEMODE_SANYO) {
 		remote_data->cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
 		remote_data->cur_msbkeycode = am_remote_read_reg(FRAME_BODY1)&0x2ff;
-	}
-	else if(remote_data->work_mode > DECODEMODE_MAX){
+	} else if(remote_data->work_mode ==  DECODEMODE_NEC_RCA_2IN1) {
+		if((temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY)) != 0) { //new
+			remote_data->temp_work_mode = DECODEMODE_RCA;
+			remote_data->cur_lsbkeycode = temp_cur_lsbkeycode;
+			temp_cur_lsbkeycode = 0;
+		}
+		if((am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100)>>3&0x1) && (temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY-0x100)) != 0 ) { //old
+			remote_data->temp_work_mode = DECODEMODE_NEC;
+			remote_data->cur_lsbkeycode =  temp_cur_lsbkeycode;
+			temp_cur_lsbkeycode = 0;
+		}
+	} else if(remote_data->work_mode ==  DECODEMODE_NEC_TOSHIBA_2IN1) {
+		temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
+		if(temp_cur_lsbkeycode != 0) { //new
+			remote_data->temp_work_mode = DECODEMODE_TOSHIBA;
+			remote_data->cur_lsbkeycode = temp_cur_lsbkeycode;
+			temp_cur_lsbkeycode = 0;
+		}
+		if((am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100)>>3&0x1) && (temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY-0x100)) != 0 ) { //old
+			remote_data->temp_work_mode = DECODEMODE_NEC;
+			remote_data->cur_lsbkeycode =  temp_cur_lsbkeycode;
+			temp_cur_lsbkeycode = 0;
+		}
+	} else if(remote_data->work_mode > DECODEMODE_MAX) {
 		remote_data->cur_lsbkeycode = remote_data->cur_keycode;
 		if(remote_data->work_mode == DECODEMODE_SW_DUOKAN )
 			changeduokandecodeorder(remote_data);
-	}
-	else{
+	} else {
 		remote_data->cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
 	}
 
 }
-void get_cur_scanstatus(struct remote *remote_data){
+void get_cur_scanstatus(struct remote *remote_data)
+{
+	if(remote_data->work_mode ==  DECODEMODE_NEC_RCA_2IN1) {
+		if(remote_data->temp_work_mode == DECODEMODE_RCA) {
+			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
+		}
+		if(remote_data->temp_work_mode == DECODEMODE_NEC) {
+			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100);
+
+		}
+	} else if(remote_data->work_mode ==  DECODEMODE_NEC_TOSHIBA_2IN1) {
+		if(remote_data->temp_work_mode == DECODEMODE_TOSHIBA) {
+			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
+			if(remote_data->cur_lsbkeycode == 0x1 || remote_data->cur_lsbkeycode == 0x0) {
+				remote_data->frame_status = 0x1;
+				remote_data->cur_lsbkeycode =  0x0;
+			}
 
-	remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
+		}
+		if(remote_data->temp_work_mode == DECODEMODE_NEC) {
+			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100);
+		}
+	} else
+		remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
 
 }
 /*
@@ -171,18 +224,19 @@ void get_cur_scanstatus(struct remote *remote_data){
    DECODEMODE_SANYO,
    DECODEMODE_MAX*/
 
-unsigned int COMCAST_DOMAIN(struct remote *remote_data,int domain){
+unsigned int COMCAST_DOMAIN(struct remote *remote_data,int domain)
+{
 	return (remote_data->cur_keycode &0xff);
 }
 /*SANYO frame body
-  Leader + 13bit Address + 13bit (~Address) + 8bit Data + 8bit (~Data)   
+  Leader + 13bit Address + 13bit (~Address) + 8bit Data + 8bit (~Data)
  */
-unsigned int SANYO_DOMAIN(struct remote *remote_data,int domain){
-	if(domain){
+unsigned int SANYO_DOMAIN(struct remote *remote_data,int domain)
+{
+	if(domain) {
 		remote_data->frame_mode = 0;
 		return ((remote_data->cur_lsbkeycode >>8) &0xff);
-	}
-	else{
+	} else {
 		remote_data->frame_mode = 0;
 		return (((remote_data->cur_lsbkeycode >>29) &0x7) | ((remote_data->cur_msbkeycode<<3)&0x1fff));
 	}
@@ -191,10 +245,11 @@ unsigned int SANYO_DOMAIN(struct remote *remote_data,int domain){
 
 
  */
-unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain){
-	if(domain){
-		if(((remote_data->cur_lsbkeycode>>12)&0xfff)){
-			switch((remote_data->cur_lsbkeycode>>20)&0xf){
+unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
+{
+	if(domain) {
+		if(((remote_data->cur_lsbkeycode>>12)&0xfff)) {
+			switch((remote_data->cur_lsbkeycode>>20)&0xf) {
 				case 0x0://OEM mode
 					remote_data->frame_mode = 0;
 					return (remote_data->cur_lsbkeycode &0xff);
@@ -207,11 +262,10 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain){
 				case 0x3://Extended Game pad mode
 					remote_data->frame_mode = 3;
 					break;
-			}	
+			}
 			return (remote_data->cur_lsbkeycode &0xfffff);
-		}
-		else{
-			switch((remote_data->cur_lsbkeycode>>10)&0x3){
+		} else {
+			switch((remote_data->cur_lsbkeycode>>10)&0x3) {
 				case 0x0://OEM mode
 					remote_data->frame_mode = 0;
 					return (remote_data->cur_lsbkeycode &0xff);
@@ -227,10 +281,9 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain){
 			}
 			return (remote_data->cur_lsbkeycode &0xff);
 		}
-	}
-	else{
-		if(((remote_data->cur_lsbkeycode>>12)&0xfff)){
-			switch((remote_data->cur_lsbkeycode>>20)&0xf){
+	} else {
+		if(((remote_data->cur_lsbkeycode>>12)&0xfff)) {
+			switch((remote_data->cur_lsbkeycode>>20)&0xf) {
 				case 0x0://OEM mode
 					remote_data->frame_mode = 0;
 					return ((remote_data->cur_lsbkeycode>>12) &0x3f);
@@ -243,11 +296,10 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain){
 				case 0x3://Extended Game pad mode
 					remote_data->frame_mode = 3;
 					break;
-			}	
+			}
 			return 0;
-		}
-		else{
-			switch((remote_data->cur_lsbkeycode>>20)&0xf){
+		} else {
+			switch((remote_data->cur_lsbkeycode>>20)&0xf) {
 				case 0x0://Extended mode
 					remote_data->frame_mode = 0;
 				case 0x1://Extended Mouse mode
@@ -260,118 +312,155 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain){
 					remote_data->frame_mode = 3;
 					break;
 			}
-			return ((remote_data->cur_lsbkeycode>>8) &0x3); 
+			return ((remote_data->cur_lsbkeycode>>8) &0x3);
 		}
 	}
 
 }
 /*
-   8 bit address and 8 bit command length 
-   Address and command are transmitted twice for reliability 
-   Pulse distance modulation 
-   Carrier frequency of 38kHz 
-   Bit time of 1.125ms or 2.25ms 
+   8 bit address and 8 bit command length
+   Address and command are transmitted twice for reliability
+   Pulse distance modulation
+   Carrier frequency of 38kHz
+   Bit time of 1.125ms or 2.25ms
    NEC frame body
-	C15 ~ C8      C7 ~ C0    D15~D8      D7~D0
-	Header    ~Custom code   Custom code    Data Code ~Data Code
+   C15 ~ C8      C7 ~ C0    D15~D8      D7~D0
+   Header    ~Custom code   Custom code    Data Code ~Data Code
  */
-unsigned int NEC_DOMAIN(struct remote *remote_data,int domain){
-	if(domain) 
+unsigned int NEC_DOMAIN(struct remote *remote_data,int domain)
+{
+	if(domain) {
 		return ((remote_data->cur_lsbkeycode >>16) &0xff);//D15 ~ D8
-	else 
+	} else {
 		return ((remote_data->cur_lsbkeycode) &0xffff);// C7 ~ C0
+	}
 }
 /*
-   8 bit address and 8 bit command length 
-   Pulse distance modulation 
-   Carrier frequency of 38kHz 
-   Bit time of 1ms or 2ms 
+   8 bit address and 8 bit command length
+   Pulse distance modulation
+   Carrier frequency of 38kHz
+   Bit time of 1ms or 2ms
  */
-unsigned int MITSUBISHI_DOMAIN(struct remote *remote_data,int domain){
+unsigned int MITSUBISHI_DOMAIN(struct remote *remote_data,int domain)
+{
 	if(domain)
 		return (remote_data->cur_keycode & 0xff);
 	else
 		return ((remote_data->cur_lsbkeycode>>8) & 0xff);
 }
-unsigned int TOSHIBA_DOMAIN(struct remote *remote_data,int domain){
+unsigned int TOSHIBA_DOMAIN(struct remote *remote_data,int domain)
+{
 	if(domain)
-		return ((remote_data->cur_keycode >>8) &0xff);
+		return ((remote_data->cur_lsbkeycode >>16) &0xff);
 	else
-		return ((remote_data->cur_keycode >>16) &0xffff);
+		return ((remote_data->cur_lsbkeycode) &0xffff);
 }
 /*
-   Pulse width modulation 
-   Carrier frequency of 40kHz 
-   Bit time of 1.2ms or 0.6ms 
-   5-bit address and 7-bit command length (12-bit protocol) 
+   Pulse width modulation
+   Carrier frequency of 40kHz
+   Bit time of 1.2ms or 0.6ms
+   5-bit address and 7-bit command length (12-bit protocol)
  */
 
-unsigned int SONYSIRC_DOMAIN(struct remote *remote_data,int domain){
-	if(domain) 
+unsigned int SONYSIRC_DOMAIN(struct remote *remote_data,int domain)
+{
+	if(domain)
 		return ((remote_data->cur_lsbkeycode>>5) &0x7f);
-	else 
+	else
 		return (remote_data->cur_lsbkeycode&0x1f);
 }
-unsigned int RC5_DOMAIN(struct remote *remote_data,int domain){
-	if(domain) 
+unsigned int RC5_DOMAIN(struct remote *remote_data,int domain)
+{
+	if(domain)
 		return ((remote_data->cur_lsbkeycode>>5) &0x7f);
-	else 
+	else
 		return (remote_data->cur_lsbkeycode&0x1f);
 
 }
 
-unsigned int RC6_DOMAIN(struct remote *remote_data,int domain){
-	if(domain) 
+unsigned int RC6_DOMAIN(struct remote *remote_data,int domain)
+{
+	if(domain)
 		return ((remote_data->cur_lsbkeycode>>5) &0x7f);
-	else 
+	else
 		return (remote_data->cur_lsbkeycode&0x1f);
 
 }
 
-/*DUOKAN frame body																　　　　　　　　　
- C7 ~ C4    C3~C0      D7 ~ D4    D3~D0      P3~P0
- Header          Custom code              Data Code      Parity Code Stop Bit  */
+unsigned int RCA_DOMAIN(struct remote *remote_data,int domain)
+{
+	if(domain) {
+		return ((remote_data->cur_lsbkeycode) &0xff);
+	} else {
+		return ((remote_data->cur_lsbkeycode>>8)&0xf);
+	}
+
+}
+/*DUOKAN frame body                                                         eOPERATION_CTRL_REG2dd,0x0}, // hard decode mode
+  C7 ~ C4    C3~C0      D7 ~ D4    D3~D0      P3~P0
+  Header          Custom code              Data Code      Parity Code Stop Bit  */
 
-unsigned int DUOKAN_DOMAIN(struct remote *remote_data,int domain){
+unsigned int DUOKAN_DOMAIN(struct remote *remote_data,int domain)
+{
 	if(remote_data->cur_lsbkeycode == 0x0003cccf)// power key
-			remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
+		remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
 	if(domain)
 		return ((remote_data->cur_lsbkeycode >>4) &0xff);
-	else 
+	else
 		return ((remote_data->cur_lsbkeycode >>12) &0xff);
 }
-unsigned int KDB_NEC_DOMAIN(struct remote *remote_data,int domain){
+unsigned int KDB_NEC_DOMAIN(struct remote *remote_data,int domain)
+{
 	if(domain)
 		return ((remote_data->cur_lsbkeycode >>4) &0xff);
-	else 
+	else
 		return ((remote_data->cur_lsbkeycode >>12) &0xff);
 }
-unsigned int KDB_DUOKAN_DOMAIN(struct remote *remote_data,int domain){
+unsigned int KDB_DUOKAN_DOMAIN(struct remote *remote_data,int domain)
+{
 	if(domain)
 		return ((remote_data->cur_lsbkeycode >>4) &0xff);
 	else
 		return ((remote_data->cur_lsbkeycode >>12) &0xff);
 }
-unsigned int (*get_cur_key_domian[])(struct remote *remote_data,int domain)={
+unsigned int NULL_DUOKAN_DOMAIN(struct remote *remote_data,int domain)
+{
+	return 0;
+}
+unsigned int (*get_cur_key_domian[])(struct remote *remote_data,int domain)= {
 	NEC_DOMAIN,
 	DUOKAN_DOMAIN,
 	KDB_NEC_DOMAIN,
 	RCMM_DOMAIN,
 	COMCAST_DOMAIN,
 	MITSUBISHI_DOMAIN,
-	TOSHIBA_DOMAIN,
 	SONYSIRC_DOMAIN,
+	TOSHIBA_DOMAIN,
 	RC5_DOMAIN,
 	RC6_DOMAIN,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
+	NULL_DUOKAN_DOMAIN,
+	RCA_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
+	NULL_DUOKAN_DOMAIN,
 	KDB_DUOKAN_DOMAIN
 };
 
+int remote_hw_reprot_null_key(struct remote *remote_data)
+{
+	input_dbg("%s,it is a null key\n",__func__);
+	get_cur_scancode(remote_data);
+	get_cur_scanstatus(remote_data);
+	return 0;
+}
+irqreturn_t remote_null_bridge_isr(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
 int remote_hw_reprot_key(struct remote *remote_data)
 {
 	static int last_scan_code;
@@ -380,20 +469,17 @@ int remote_hw_reprot_key(struct remote *remote_data)
 	get_cur_scanstatus(remote_data);
 	if(remote_data->status)// repeat enable & come in S timer is open
 		return 0;
-	if (remote_data->cur_lsbkeycode) {	//key first press
-		if(remote_data->ig_custom_enable)
-		{
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);){
+	if (remote_data->cur_lsbkeycode) {  //key first press
+		if(remote_data->ig_custom_enable) {
+			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
 				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->work_mode](remote_data,CUSTOMDOMAIN)) {
 					//return -1;
 					i++;
-				}
-				else{
+				} else {
 					remote_data->map_num = i;
 					break;
 				}
-				if(i == ARRAY_SIZE(remote_data->custom_code))
-				{
+				if(i == ARRAY_SIZE(remote_data->custom_code)) {
 					input_dbg("Wrong custom code is 0x%08x\n", remote_data->cur_lsbkeycode);
 					return -1;
 				}
@@ -407,48 +493,220 @@ int remote_hw_reprot_key(struct remote *remote_data)
 		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN), 1,0);
 		remote_data->repeat_release_code = get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN);
 		remote_data->enable_repeat_falg = 1;
-		if((remote_data->work_mode > DECODEMODE_NEC) && remote_data->enable_repeat_falg){
+		if((remote_data->work_mode > DECODEMODE_NEC) && remote_data->enable_repeat_falg) {
 			if (remote_data->repeat_enable) {
 				remote_data->repeat_timer.data = (unsigned long)remote_data;
 				//here repeat  delay is time interval from the first frame end to first repeat end.
 				remote_data->repeat_tick = jiffies;
-				mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_delay));
+				mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num]));
 				remote_data->status = TIMER;
-			}
-			else{
+			} else {
 				setup_timer(&remote_data->rel_timer, remote_rel_timer_sr, 0);
 				mod_timer(&remote_data->timer,  jiffies );
 				remote_data->rel_timer.data = (unsigned long)remote_data;
-				mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay));
+				mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay[remote_data->map_num]));
 				remote_data->status = TIMER;
 			}
 		}
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++){
+		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
 			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
 				remote_data->want_repeat_enable = 1;
+			} else {
+				remote_data->want_repeat_enable = 0;
+			}
+		}
+
+		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
+			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num]);
+		}
+		if(remote_data->repeat_enable)
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
+		else
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
+	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
+#ifdef CONFIG_AML_HDMI_TX
+		extern int rc_long_press_pwr_key;
+		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
+			rc_long_press_pwr_key = 1;
+			cec_repeat = 10;
+		}
+		if(remote_data->repeat_release_code == 0x1a)
+			cec_repeat--;
+
+#endif
+		if (remote_data->repeat_enable) {
+			repeat_count++;
+			if (remote_data->repeat_tick < jiffies) {
+				if(repeat_count > 1)
+					remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
+				remote_data->repeat_tick += msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num]);
+			}
+		} else {
+			if (remote_data->timer.expires > jiffies) {
+				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]));
+			}
+			return -1;
+		}
+		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]) + msecs_to_jiffies(110));
+	}
+	last_scan_code = remote_data->cur_lsbkeycode;
+	remote_data->cur_keycode = last_scan_code;
+	remote_data->cur_lsbkeycode = 0;
+	remote_data->timer.data = (unsigned long)remote_data;
+	return 0;
+}
+int remote_hw_nec_rca_2in1_reprot_key(struct remote *remote_data)
+{
+	static int last_scan_code;
+	int i;
+	get_cur_scancode(remote_data);
+	get_cur_scanstatus(remote_data);
+	if(remote_data->status)// repeat enable & come in S timer is open
+		return 0;
+	if (remote_data->cur_lsbkeycode) {      //key first press
+		if(remote_data->ig_custom_enable) {
+			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->temp_work_mode](remote_data,CUSTOMDOMAIN)) {
+					//return -1;
+					i++;
+				} else {
+					remote_data->map_num = i;
+					break;
+				}
+				if(i == ARRAY_SIZE(remote_data->custom_code)) {
+					input_dbg("Wrong custom code is 0x%08x,temp_work_mode is %d\n", remote_data->cur_lsbkeycode,remote_data->temp_work_mode);
+					return -1;
+				}
+			}
+		}
+		repeat_count = 0;
+		if (remote_data->timer.expires > jiffies) {
+			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code , 0,0);
+		}
+		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN), 1,0);
+		remote_data->repeat_release_code = get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN);
+		remote_data->enable_repeat_falg = 1;
+		if((remote_data->temp_work_mode  == DECODEMODE_RCA) && (remote_data->enable_repeat_falg)) {
+			if (remote_data->repeat_enable) {
+				remote_data->repeat_timer.data = (unsigned long)remote_data;
+				//here repeat  delay is time interval from the first frame end to first repeat end.
+				remote_data->repeat_tick = jiffies;
+				mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num]));
+				remote_data->status = TIMER;
+			} else {
+				setup_timer(&remote_data->rel_timer, remote_rel_timer_sr, 0);
+				mod_timer(&remote_data->timer,  jiffies );
+				remote_data->rel_timer.data = (unsigned long)remote_data;
+				mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay[remote_data->map_num]));
+				remote_data->status = TIMER;
 			}
-			else{
+		}
+		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
+			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
+				remote_data->want_repeat_enable = 1;
+			} else {
 				remote_data->want_repeat_enable = 0;
 			}
 		}
 
 		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
-			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->input->rep[REP_DELAY]);
+			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num] );
 		}
 		if(remote_data->repeat_enable)
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_delay));
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
 		else
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_delay));
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
+	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
+#ifdef CONFIG_AML_HDMI_TX
+		extern int rc_long_press_pwr_key;
+		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
+			rc_long_press_pwr_key = 1;
+			cec_repeat = 10;
+		}
+		if(remote_data->repeat_release_code == 0x1a)
+			cec_repeat--;
+
+#endif
+		if (remote_data->repeat_enable) {
+			repeat_count++;
+			if (remote_data->repeat_tick < jiffies) {
+				if(repeat_count > 1)
+					remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
+				remote_data->repeat_tick += msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num] );
+			}
+		} else {
+			if (remote_data->timer.expires > jiffies) {
+				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]));
+			}
+			return -1;
+		}
+		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]) + msecs_to_jiffies(110));
 	}
-	else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg){	//repeate key
+	last_scan_code = remote_data->cur_lsbkeycode;
+	remote_data->cur_keycode = last_scan_code;
+	remote_data->cur_lsbkeycode = 0;
+	remote_data->timer.data = (unsigned long)remote_data;
+	return 0;
+}
+
+int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data)
+{
+	static int last_scan_code;
+	int i;
+	get_cur_scancode(remote_data);
+	get_cur_scanstatus(remote_data);
+	if (remote_data->cur_lsbkeycode) {      //key first press
+		if(remote_data->ig_custom_enable) {
+			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->temp_work_mode](remote_data,CUSTOMDOMAIN)) {
+					//return -1;
+					i++;
+				} else {
+					remote_data->map_num = i;
+					break;
+				}
+
+				if(i == ARRAY_SIZE(remote_data->custom_code)) {
+					input_dbg("Wrong custom code is 0x%08x,temp_work_mode is %d\n", remote_data->cur_lsbkeycode,remote_data->temp_work_mode);
+					return -1;
+				}
+			}
+		}
+		repeat_count = 0;
+		if (remote_data->timer.expires > jiffies) {
+			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code , 0,0);
+		}
+		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN), 1,0);
+		remote_data->repeat_release_code = get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN);
+		remote_data->enable_repeat_falg = 1;
+		if(remote_data->temp_work_mode  == DECODEMODE_TOSHIBA) {
+			// setting frame bit = 1;
+			am_remote_write_reg(OPERATION_CTRL_REG1,0x8000);
+		}
+		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
+			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
+				remote_data->want_repeat_enable = 1;
+			} else {
+				remote_data->want_repeat_enable = 0;
+			}
+		}
+
+		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
+			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num] );
+		}
+		if(remote_data->repeat_enable)
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
+		else
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
+	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
 #ifdef CONFIG_AML_HDMI_TX
-       extern int rc_long_press_pwr_key;
+		extern int rc_long_press_pwr_key;
 		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
-            	    rc_long_press_pwr_key = 1;
-		    cec_repeat = 10;
+			rc_long_press_pwr_key = 1;
+			cec_repeat = 10;
 		}
 		if(remote_data->repeat_release_code == 0x1a)
- 		    cec_repeat--;
+			cec_repeat--;
 
 #endif
 		if (remote_data->repeat_enable) {
@@ -456,21 +714,21 @@ int remote_hw_reprot_key(struct remote *remote_data)
 			if (remote_data->repeat_tick < jiffies) {
 				if(repeat_count > 1)
 					remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-				remote_data->repeat_tick += msecs_to_jiffies(remote_data->input->rep[REP_PERIOD]);
+				remote_data->repeat_tick += msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num] );
 			}
 		} else {
 			if (remote_data->timer.expires > jiffies) {
-				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay));
+				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]));
 			}
 			return -1;
 		}
-		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay) + msecs_to_jiffies(110));
+		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]) + msecs_to_jiffies(110));
 	}
 	last_scan_code = remote_data->cur_lsbkeycode;
 	remote_data->cur_keycode = last_scan_code;
 	remote_data->cur_lsbkeycode = 0;
 	remote_data->timer.data = (unsigned long)remote_data;
-	return 0;	
+	return 0;
 }
 static inline void kbd_software_mode_remote_send_key(unsigned long data)
 {
@@ -485,19 +743,16 @@ static inline void kbd_software_mode_remote_send_key(unsigned long data)
 				msecs_to_jiffies(remote_data->input->rep[REP_PERIOD]);
 		}
 	} else {
-		if(remote_data->ig_custom_enable)
-		{
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);){
+		if(remote_data->ig_custom_enable) {
+			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
 				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->work_mode](remote_data,CUSTOMDOMAIN)) {
 					//return -1;
 					i++;
-				}
-				else{
+				} else {
 					remote_data->map_num = i;
 					break;
 				}
-				if(i == ARRAY_SIZE(remote_data->custom_code))
-				{
+				if(i == ARRAY_SIZE(remote_data->custom_code)) {
 					input_dbg("Wrong custom code is 0x%08x\n", remote_data->cur_lsbkeycode);
 					return;
 				}
@@ -506,48 +761,64 @@ static inline void kbd_software_mode_remote_send_key(unsigned long data)
 		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN), 1,0);
 		remote_data->repeat_release_code = get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN);
 		remote_data->enable_repeat_falg = 1;
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++){
+		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
 			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
 				remote_data->want_repeat_enable = 1;
-			}
-			else{
+			} else {
 				remote_data->want_repeat_enable = 0;
 			}
 		}
 		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
 			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->input->rep[REP_DELAY]);
-		}		
+		}
+	}
+}
+static void remote_rca_repeat_sr(unsigned long data)
+{
+	struct remote *remote_data = (struct remote *)data;
+	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode ) {
+		repeat_count++;
+		if(repeat_count > 2)
+			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
+		remote_data->cur_lsbkeycode = 0;
+		remote_data->repeat_timer.data = (unsigned long)remote_data;
+		remote_data->timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_peroid[remote_data->map_num]));
+		mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num]));
+		remote_data->status = TIMER;
+	} else {
+		remote_data->status = NORMAL;
+		remote_data->timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->timer, jiffies+msecs_to_jiffies(1));
 	}
 }
 static void remote_repeat_sr(unsigned long data)
 {
 	struct remote *remote_data = (struct remote *)data;
-	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode){
-			auto_repeat_count++;
-			if(auto_repeat_count > 1)
-				remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-			remote_data->cur_lsbkeycode = 0;
-			remote_data->repeat_timer.data = (unsigned long)remote_data;
-			remote_data->timer.data = (unsigned long)remote_data;
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_peroid));
-			mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_peroid));
-			remote_data->status = TIMER;
-	}else{
-			remote_data->status = NORMAL;
-			remote_data->timer.data = (unsigned long)remote_data;
-			mod_timer(&remote_data->timer, jiffies+msecs_to_jiffies(1));
+	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode) {
+		auto_repeat_count++;
+		if(auto_repeat_count > 1)
+			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
+		remote_data->cur_lsbkeycode = 0;
+		remote_data->repeat_timer.data = (unsigned long)remote_data;
+		remote_data->timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num]));
+		remote_data->status = TIMER;
+	} else {
+		remote_data->status = NORMAL;
+		remote_data->timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->timer, jiffies+msecs_to_jiffies(1));
 	}
 }
 static void remote_rel_timer_sr(unsigned long data)
 {
 	struct remote *remote_data = (struct remote *)data;
-		if(remote_data->cur_keycode == remote_data->cur_lsbkeycode){
-			remote_data->cur_lsbkeycode = 0;
-			remote_data->rel_timer.data = (unsigned long)remote_data;
-			mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay));
-			remote_data->status = TIMER;
-		}
-		else
+	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode) {
+		remote_data->cur_lsbkeycode = 0;
+		remote_data->rel_timer.data = (unsigned long)remote_data;
+		mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay[remote_data->map_num]));
+		remote_data->status = TIMER;
+	} else
 		remote_data->status = NORMAL;
 
 
@@ -562,7 +833,7 @@ static int get_pulse_width(struct remote *remote_data )
 		remote_data->step == REMOTE_STATUS_LEADER ? "leader" :
 		remote_data->step == REMOTE_STATUS_DATA ? "data" :
 		remote_data->step == REMOTE_STATUS_SYNC ? "sync" : NULL;
-	dbg_printk("%02d:pulse_wdith:%d==>%s\n",
+	dbg_printk("%02d:pulse_wdith:%d==>%s\r\n",
 			remote_data->bit_count - remote_data->bit_num, pulse_width, state);
 	//sometimes we found remote  pulse width==0.        in order to sync machine state we modify it .
 	if (pulse_width == 0) {
@@ -608,51 +879,51 @@ static inline void kbd_software_mode_remote_data(struct remote *remote_data)
 	pulse_width = get_pulse_width(remote_data);
 	remote_data->step = REMOTE_STATUS_DATA;
 	switch (remote_data->work_mode) {
-	case DECODEMODE_SW_NEC:
-	if ((pulse_width > remote_data->time_window[2])
-			&& (pulse_width < remote_data->time_window[3])) {
-		remote_data->bit_num--;
-	} else if ((pulse_width > remote_data->time_window[4])
-			&& (pulse_width < remote_data->time_window[5])) {
-			remote_data->bit_num--;
-			remote_data->cur_keycode |= 1 << (remote_data->bit_count - remote_data->bit_num);
-	} else {
-		remote_data->step = REMOTE_STATUS_WAIT;
-	}
-	if (remote_data->bit_num == 0) {
-		remote_data->repeate_flag = 0;
-		remote_data->send_data = 1;
-		fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
-	}
-	break;
-	case DECODEMODE_SW_DUOKAN:
-		if ((pulse_width > remote_data->time_window[2])
-		    && (pulse_width < remote_data->time_window[3])) {
-			remote_data->bit_num -= 2;
-		} else if ((pulse_width > remote_data->time_window[4])
-		           && (pulse_width < remote_data->time_window[5])) {
-			remote_data->cur_keycode |=
-			    1 << (remote_data->bit_count - remote_data->bit_num);
-			remote_data->bit_num -= 2;
-		} else if ((pulse_width > remote_data->time_window[8])
-		           && (pulse_width < remote_data->time_window[9])) {
-			remote_data->cur_keycode |=
-			    2 << (remote_data->bit_count - remote_data->bit_num);
-			remote_data->bit_num -= 2;
-		} else if ((pulse_width > remote_data->time_window[10])
-		           && (pulse_width < remote_data->time_window[11])) {
-			remote_data->cur_keycode |=
-			    3 << (remote_data->bit_count - remote_data->bit_num);
-			remote_data->bit_num -= 2;
-		} else {
-			remote_data->step = REMOTE_STATUS_WAIT;
-		}
-		if (remote_data->bit_num == 0) {
-			remote_data->repeate_flag = 0;
-			remote_data->send_data = 1;
-			fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
-		}
-		break;
+		case DECODEMODE_SW_NEC:
+			if ((pulse_width > remote_data->time_window[2])
+					&& (pulse_width < remote_data->time_window[3])) {
+				remote_data->bit_num--;
+			} else if ((pulse_width > remote_data->time_window[4])
+					&& (pulse_width < remote_data->time_window[5])) {
+				remote_data->bit_num--;
+				remote_data->cur_keycode |= 1 << (remote_data->bit_count - remote_data->bit_num);
+			} else {
+				remote_data->step = REMOTE_STATUS_WAIT;
+			}
+			if (remote_data->bit_num == 0) {
+				remote_data->repeate_flag = 0;
+				remote_data->send_data = 1;
+				fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
+			}
+			break;
+		case DECODEMODE_SW_DUOKAN:
+			if ((pulse_width > remote_data->time_window[2])
+					&& (pulse_width < remote_data->time_window[3])) {
+				remote_data->bit_num -= 2;
+			} else if ((pulse_width > remote_data->time_window[4])
+					&& (pulse_width < remote_data->time_window[5])) {
+				remote_data->cur_keycode |=
+					1 << (remote_data->bit_count - remote_data->bit_num);
+				remote_data->bit_num -= 2;
+			} else if ((pulse_width > remote_data->time_window[8])
+					&& (pulse_width < remote_data->time_window[9])) {
+				remote_data->cur_keycode |=
+					2 << (remote_data->bit_count - remote_data->bit_num);
+				remote_data->bit_num -= 2;
+			} else if ((pulse_width > remote_data->time_window[10])
+					&& (pulse_width < remote_data->time_window[11])) {
+				remote_data->cur_keycode |=
+					3 << (remote_data->bit_count - remote_data->bit_num);
+				remote_data->bit_num -= 2;
+			} else {
+				remote_data->step = REMOTE_STATUS_WAIT;
+			}
+			if (remote_data->bit_num == 0) {
+				remote_data->repeate_flag = 0;
+				remote_data->send_data = 1;
+				fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
+			}
+			break;
 	}
 }
 
@@ -685,7 +956,7 @@ int remote_sw_reprot_key(struct remote *remote_data)
 			&& (remote_data->step <= REMOTE_STATUS_SYNC)) {
 		remote_data->step = REMOTE_STATUS_WAIT;
 	}
-	remote_data->last_jiffies = current_jiffies;	//ignore a little msecs
+	remote_data->last_jiffies = current_jiffies;    //ignore a little msecs
 	switch (remote_data->step) {
 		case REMOTE_STATUS_WAIT:
 			kbd_software_mode_remote_wait(remote_data);
@@ -709,36 +980,60 @@ irqreturn_t remote_bridge_isr(int irq, void *dev_id)
 {
 	struct remote *remote_data = (struct remote *)dev_id;
 
-	if (remote_data->send_data) {	//report key
+	if (remote_data->send_data) {   //report key
 		kbd_software_mode_remote_send_key((unsigned long)remote_data);
 		remote_data->send_data = 0;
 	}
 	remote_data->timer.data = (unsigned long)remote_data;
 	mod_timer(&remote_data->timer,
-			jiffies + msecs_to_jiffies(remote_data->release_delay));
+			jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num] ));
 	return IRQ_HANDLED;
 }
-void kdb_send_key(struct input_dev *dev, unsigned int scancode,unsigned int type,int event){
+void kdb_send_key(struct input_dev *dev, unsigned int scancode,unsigned int type,int event)
+{
 	return;
 }
-void remote_nec_report_release_key(struct remote *remote_data){
-	if(remote_data->enable_repeat_falg){
+void remote_nec_report_release_key(struct remote *remote_data)
+{
+	if(remote_data->enable_repeat_falg) {
 		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
 		remote_data->enable_repeat_falg = 0;
 	}
 }
-void remote_duokan_report_release_key(struct remote *remote_data){
-	if(remote_data->enable_repeat_falg){
+void remote_duokan_report_release_key(struct remote *remote_data)
+{
+	if(remote_data->enable_repeat_falg) {
 		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
 		remote_data->enable_repeat_falg = 0;
 		auto_repeat_count = 0;
 	}
 }
-void remote_sw_reprot_release_key(struct remote *remote_data){
-	if(remote_data->enable_repeat_falg){
+void remote_sw_reprot_release_key(struct remote *remote_data)
+{
+	if(remote_data->enable_repeat_falg) {
 		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
 		remote_data->enable_repeat_falg = 0;
-	}	
+	}
+}
+void remote_nec_rca_2in1_report_release_key(struct remote *remote_data)
+{
+	if(remote_data->enable_repeat_falg) {
+		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
+		remote_data->enable_repeat_falg = 0;
+	}
+}
+void remote_nec_toshiba_2in1_report_release_key(struct remote *remote_data)
+{
+	if(remote_data->enable_repeat_falg) {
+		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
+		remote_data->enable_repeat_falg = 0;
+		am_remote_write_reg(OPERATION_CTRL_REG1,0x9f40);
+
+	}
 }
 
+void remote_null_reprot_release_key(struct remote *remote_data)
+{
+
+}
 
diff --git a/drivers/amlogic/input/new_remote/remote_main.c b/drivers/amlogic/input/new_remote/remote_main.c
index 9c6ba3ec8eb1..c7f9b7a57f7e 100755
--- a/drivers/amlogic/input/new_remote/remote_main.c
+++ b/drivers/amlogic/input/new_remote/remote_main.c
@@ -45,8 +45,6 @@
 #include "remote_main.h"
 
 #undef NEW_BOARD_LEARNING_MODE
-
-//#define IR_CONTROL_HOLD_LAST_KEY    (1<<6)
 #define IR_CONTROL_DECODER_MODE     (3<<7)
 #define IR_CONTROL_SKIP_HEADER      (1<<7)
 #define IR_CONTROL_RESET            (1<<0)
@@ -73,63 +71,63 @@ static struct remote *gp_remote = NULL;
 char *remote_log_buf;
 // use 20 map for this driver
 static __u16 key_map[20][512];
-static  irqreturn_t (*remote_bridge_sw_isr[])(int irq, void *dev_id)={
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
+static  irqreturn_t (*remote_bridge_sw_isr[])(int irq, void *dev_id)= {
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
+	remote_null_bridge_isr,
 	remote_bridge_isr,
 	remote_bridge_isr,
 };
 
-static  int (*remote_report_key[])(struct remote *remote_data)={
+static  int (*remote_report_key[])(struct remote *remote_data)= {
 	remote_hw_reprot_key,
 	remote_hw_reprot_key,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	remote_sw_reprot_key		
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_reprot_null_key,
+	remote_hw_nec_rca_2in1_reprot_key,
+	remote_hw_nec_toshiba_2in1_reprot_key,
+	remote_sw_reprot_key
 };
 
-static  void (*remote_report_release_key[])(struct remote *remote_data)={
+static  void (*remote_report_release_key[])(struct remote *remote_data)= {
 	remote_nec_report_release_key,
 	remote_duokan_report_release_key,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_null_reprot_release_key,
+	remote_nec_rca_2in1_report_release_key,
+	remote_nec_toshiba_2in1_report_release_key,
 	remote_sw_reprot_release_key
 };
 static __u16 mouse_map[20][6];
@@ -149,11 +147,11 @@ int remote_printk(const char *fmt, ...)
 
 static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsigned int type,bool flag)
 {
-	
+
 	__u16 mouse_code = REL_X;
 	__s32 mouse_value = 0;
 	static unsigned int repeat_count = 0;
-	__s32 move_accelerate[] = {0, 6, 12, 20, 28, 36, 46, 58, 72, 88, 106, 126};
+	__s32 move_accelerate[] = {0, 2, 2, 4, 4, 6, 8, 10, 12, 14, 16, 18};
 	unsigned int i;
 
 	if(flag)
@@ -167,10 +165,10 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsi
 		return -1;
 	}
 	switch (type) {
-		case 1:		//press
+		case 1:     //press
 			repeat_count = 0;
 			break;
-		case 2:		//repeat
+		case 2:     //repeat
 			if (repeat_count >= ARRAY_SIZE(move_accelerate) - 1) {
 				repeat_count = ARRAY_SIZE(move_accelerate) - 1;
 			} else {
@@ -194,7 +192,7 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsi
 			mouse_code = REL_Y;
 			mouse_value = 1 + move_accelerate[repeat_count];
 			break;
-		case 4:		//up
+		case 4:     //up
 			mouse_code = REL_WHEEL;
 			mouse_value = 0x1;
 			break;
@@ -224,35 +222,31 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsi
 
 void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int type,int event)
 {
-	printk("remote_send_key \n");
-	if(scancode == FN_KEY_SCANCODE && type == 1)
-    {
-    	// switch from key to pointer
-        if(key_pointer_switch)
-        {
-            key_pointer_switch = false;
-            gp_remote->repeat_enable = 1;	
-            gp_remote->input->rep[REP_DELAY] = gp_remote->repeat_delay;
-            gp_remote->input->rep[REP_PERIOD] = gp_remote->repeat_peroid;
-        }
-        // switch from pointer to key
-        else
-        {
-            key_pointer_switch = true;
-            gp_remote->repeat_enable = 0;
-            gp_remote->input->rep[REP_DELAY] = 0xffffffff;
-            gp_remote->input->rep[REP_PERIOD] = 0xffffffff;
-        }
-    }
-
-    if(scancode == OK_KEY_SCANCODE && key_pointer_switch == false)
-    {
-       	 input_event(dev, EV_KEY, BTN_MOUSE, type);
-		 input_sync(dev);
-
-    	 return;
-     }
-	
+	printk("remote_send_key\n");
+	if(scancode == FN_KEY_SCANCODE && type == 1) {
+		// switch from key to pointer
+		if(key_pointer_switch) {
+			key_pointer_switch = false;
+			gp_remote->repeat_enable = 1;
+			gp_remote->input->rep[REP_DELAY] = gp_remote->repeat_delay[gp_remote->map_num];
+			gp_remote->input->rep[REP_PERIOD] = gp_remote->repeat_peroid[gp_remote->map_num];
+		}
+		// switch from pointer to key
+		else {
+			key_pointer_switch = true;
+			gp_remote->repeat_enable = 0;
+			gp_remote->input->rep[REP_DELAY] = 0xffffffff;
+			gp_remote->input->rep[REP_PERIOD] = 0xffffffff;
+		}
+	}
+
+	if(scancode == OK_KEY_SCANCODE && key_pointer_switch == false) {
+		input_event(dev, EV_KEY, BTN_MOUSE, type);
+		input_sync(dev);
+
+		return;
+	}
+
 	if (remote_mouse_event(dev, scancode, type,key_pointer_switch)) {
 		if (scancode > ARRAY_SIZE(key_map[gp_remote->map_num])) {
 			input_dbg("scancode is 0x%04x, out of key mapping.\n", scancode);
@@ -263,12 +257,14 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int
 			input_dbg("scancode is 0x%04x, invalid key is 0x%04x.\n", scancode, key_map[gp_remote->map_num][scancode]);
 			return;
 		}
-		if(type == 2 && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074){
+
+		if(type == 2 && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074) {
 			return;
-		}else{
+		} else {
 			input_event(dev, EV_KEY, key_map[gp_remote->map_num][scancode], type);
 			input_sync(dev);
 		}
+
 		switch (type) {
 			case 0:
 				input_dbg("release ircode = 0x%02x, scancode = 0x%04x, maptable = %d \n", scancode, key_map[gp_remote->map_num][scancode],gp_remote->map_num);
@@ -280,8 +276,8 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int
 				input_dbg("repeat ircode = 0x%02x, scancode = 0x%04x, maptable = %d \n", scancode, key_map[gp_remote->map_num][scancode],gp_remote->map_num);
 				break;
 		}
-		printk("%s sleep:%d\n", __func__, gp_remote->sleep);
-		if(gp_remote->sleep && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074){
+		input_dbg("%s sleep:%d\n", __func__, gp_remote->sleep);
+		if(gp_remote->sleep && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074) {
 			printk(" set AO_RTI_STATUS_REG2 0x4853ffff \n");
 			WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0x4853ffff); // tell uboot don't suspend
 		}
@@ -290,7 +286,7 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int
 
 static void disable_remote_irq(void)
 {
-	if (gp_remote->work_mode >= DECODEMODE_MAX){
+	if (gp_remote->work_mode >= DECODEMODE_MAX) {
 		disable_irq(NEC_REMOTE_IRQ_NO);
 	}
 }
@@ -303,25 +299,26 @@ static void enable_remote_irq(void)
 
 }
 
-void remote_reprot_key( struct remote * remote_data){
+void remote_reprot_key( struct remote * remote_data)
+{
 	remote_report_key[remote_data->work_mode](remote_data);
 }
 static void remote_release_timer_sr(unsigned long data)
 {
 	struct remote *remote_data = (struct remote *)data;
-	//key report release use timer interrupt 
+	//key report release use timer interrupt
 	remote_data->key_release_report = remote_report_release_key[remote_data->work_mode];
 	remote_data->key_release_report(remote_data);
 }
 
-static irqreturn_t remote_interrupt(int irq, void *dev_id){
+static irqreturn_t remote_interrupt(int irq, void *dev_id)
+{
 	tasklet_schedule(&tasklet);
 	return IRQ_HANDLED;
 }
 
 static void remote_fiq_interrupt(void)
 {
-	//struct remote *remote_data = (struct remote *)data;
 	remote_reprot_key(gp_remote);
 }
 
@@ -379,7 +376,7 @@ static int hardware_init(struct platform_device *pdev)
 	p=devm_pinctrl_get_select_default(&pdev->dev);
 	if (IS_ERR(p))
 		return -1;
-	set_remote_mode(DECODEMODE_NEC);
+	set_remote_mode(DECODEMODE_NEC_RCA_2IN1);
 	return request_irq(NEC_REMOTE_IRQ_NO, remote_interrupt, IRQF_SHARED, "keypad", (void *)remote_interrupt);
 }
 static int work_mode_config(unsigned int cur_mode)
@@ -393,7 +390,7 @@ static int work_mode_config(unsigned int cur_mode)
 	set_remote_init(gp_remote);
 	if(cur_mode == gp_remote->save_mode)
 		return 0;
-	if((cur_mode <= DECODEMODE_MAX)  && (gp_remote->save_mode > DECODEMODE_MAX) ){
+	if((cur_mode <= DECODEMODE_MAX)  && (gp_remote->save_mode > DECODEMODE_MAX) ) {
 		unregister_fiq_bridge_handle(&gp_remote->fiq_handle_item);
 		free_fiq(NEC_REMOTE_IRQ_NO, &remote_fiq_interrupt);
 		ret = request_irq(NEC_REMOTE_IRQ_NO, remote_interrupt, IRQF_SHARED, "keypad", (void *)remote_interrupt);
@@ -401,8 +398,7 @@ static int work_mode_config(unsigned int cur_mode)
 			printk(KERN_ERR "Remote: request_irq failed, ret=%d.\n", ret);
 			return ret;
 		}
-	}
-	else if((cur_mode > DECODEMODE_MAX)  && (gp_remote->save_mode < DECODEMODE_MAX)){
+	} else if((cur_mode > DECODEMODE_MAX)  && (gp_remote->save_mode < DECODEMODE_MAX)) {
 		free_irq(NEC_REMOTE_IRQ_NO, remote_interrupt);
 		gp_remote->fiq_handle_item.handle = remote_bridge_sw_isr[gp_remote->work_mode];
 		gp_remote->fiq_handle_item.key = (u32) gp_remote;
@@ -410,8 +406,7 @@ static int work_mode_config(unsigned int cur_mode)
 		register_fiq_bridge_handle(&gp_remote->fiq_handle_item);
 		desc->depth++;
 		request_fiq(NEC_REMOTE_IRQ_NO, remote_fiq_interrupt);
-	}
-	else{
+	} else {
 		printk("do nothing\n");
 	}
 	gp_remote->save_mode = cur_mode;
@@ -469,13 +464,13 @@ static long remote_config_ioctl(struct file *filp, unsigned int cmd, unsigned lo
 			mouse_map[remote->map_num][val >> 16] = val & 0xff;
 			break;
 		case REMOTE_IOC_SET_RELT_DELAY:
-			ret = copy_from_user(&remote->relt_delay, argp, sizeof(long));
+			ret = copy_from_user(&remote->relt_delay[remote->map_num], argp, sizeof(long));
 			break;
 		case REMOTE_IOC_SET_REPEAT_DELAY:
-			ret = copy_from_user(&remote->repeat_delay, argp, sizeof(long));
+			ret = copy_from_user(&remote->repeat_delay[remote->map_num], argp, sizeof(long));
 			break;
 		case REMOTE_IOC_SET_REPEAT_PERIOD:
-			ret = copy_from_user(&remote->repeat_peroid, argp, sizeof(long));
+			ret = copy_from_user(&remote->repeat_peroid[remote->map_num], argp, sizeof(long));
 			break;
 		case REMOTE_IOC_SET_REPEAT_ENABLE:
 			ret = copy_from_user(&remote->repeat_enable, argp, sizeof(long));
@@ -511,7 +506,7 @@ static long remote_config_ioctl(struct file *filp, unsigned int cmd, unsigned lo
 			am_remote_write_reg(DURATION_REG0, val);
 			break;
 		case REMOTE_IOC_SET_RELEASE_DELAY:
-			ret = copy_from_user(&remote->release_delay, argp, sizeof(long));
+			ret = copy_from_user(&remote->release_delay[remote->map_num], argp, sizeof(long));
 			break;
 			//SW
 		case REMOTE_IOC_SET_TW_LEADER_ACT:
@@ -549,8 +544,8 @@ static long remote_config_ioctl(struct file *filp, unsigned int cmd, unsigned lo
 	switch (cmd) {
 		case REMOTE_IOC_SET_REPEAT_ENABLE:
 			if (remote->repeat_enable) {
-				remote->input->rep[REP_DELAY] = remote->repeat_delay;
-				remote->input->rep[REP_PERIOD] = remote->repeat_peroid;
+				remote->input->rep[REP_DELAY] = remote->repeat_delay[remote->map_num] ;
+				remote->input->rep[REP_PERIOD] = remote->repeat_peroid[remote->map_num] ;
 			} else {
 				remote->input->rep[REP_DELAY] = 0xffffffff;
 				remote->input->rep[REP_PERIOD] = 0xffffffff;
@@ -597,11 +592,11 @@ static int register_remote_dev(struct remote *remote)
 	strcpy(remote->config_name, "amremote");
 	ret = register_chrdev(0, remote->config_name, &remote_fops);
 	if (ret <= 0) {
-		printk("register char dev tv error\n");
+		printk("register char dev tv error\r\n");
 		return ret;
 	}
 	remote->config_major = ret;
-	printk("remote config major:%d\n", ret);
+	printk("remote config major:%d\r\n", ret);
 	remote->config_class = class_create(THIS_MODULE, remote->config_name);
 	remote->config_dev = device_create(remote->config_class, NULL, MKDEV(remote->config_major, 0), NULL, remote->config_name);
 	return ret;
@@ -610,14 +605,15 @@ static int register_remote_dev(struct remote *remote)
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static void remote_early_suspend(struct early_suspend *handler)
 {
-	 printk("remote_early_suspend, set sleep 1 \n");
-	 gp_remote->sleep = 1;
-	 return;
+	printk("remote_early_suspend, set sleep 1 \n");
+	gp_remote->sleep = 1;
+	return;
 }
 #endif
 
-static const struct of_device_id remote_dt_match[]={
-	{	.compatible 	= "amlogic,aml_remote",
+static const struct of_device_id remote_dt_match[]= {
+	{
+		.compatible     = "amlogic,aml_remote",
 	},
 	{},
 };
@@ -635,7 +631,7 @@ static int remote_probe(struct platform_device *pdev)
 		return -1;
 	}
 	ret = of_property_read_u32(pdev->dev.of_node,"ao_baseaddr",&ao_baseaddr);
-	if(ret){
+	if(ret) {
 		printk("don't find  match ao_baseaddr\n");
 		return -1;
 	}
@@ -662,13 +658,15 @@ static int remote_probe(struct platform_device *pdev)
 	remote->input = input_dev;
 	remote->release_fdelay = KEY_RELEASE_DELAY;
 	remote->custom_code[remote->map_num] = 0xfb04;
-	remote->bit_count = 32;	
+	for(i=1; i<20; i++)
+		remote->custom_code[i] = 0xffff;
+	remote->bit_count = 32;
 	remote->last_jiffies = 0xffffffff;
 	remote->last_pulse_width = 0;
 	remote->step = REMOTE_STATUS_WAIT;
 	remote->sleep = 0;
 	//init logic0 logic1  time window
-	for(i = 0;i < 18;i++)
+	for(i = 0; i < 18; i++)
 		remote->time_window[i] = 0x1;
 	/* Disable the interrupt for the MPUIO keyboard */
 	for (i = 0; i < ARRAY_SIZE(key_map[remote->map_num]); i++) {
@@ -677,23 +675,23 @@ static int remote_probe(struct platform_device *pdev)
 	for (i = 0; i < ARRAY_SIZE(mouse_map); i++) {
 		mouse_map[remote->map_num][i] = 0xffff;
 	}
-	remote->repeat_delay = 250;
-	remote->repeat_peroid = 33;
+	remote->repeat_delay[remote->map_num]  = 250;
+	remote->repeat_peroid[remote->map_num]  = 33;
 	/* get the irq and init timer */
-	input_dbg("set drvdata completed\n");
+	input_dbg("set drvdata completed\r\n");
 	tasklet_enable(&tasklet);
 	tasklet.data = (unsigned long)remote;
 	setup_timer(&remote->timer, remote_release_timer_sr, 0);
-        /*read status & frame register to abandon last key from uboot*/
-	am_remote_read_reg(DURATION_REG1_AND_STATUS);	
-	am_remote_read_reg(FRAME_BODY);	
-	#ifdef CONFIG_HAS_EARLYSUSPEND
-    early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING + 1;
-    early_suspend.suspend = remote_early_suspend;
-    early_suspend.resume = NULL;
-    early_suspend.param = gp_remote;
-    register_early_suspend(&early_suspend);
-    #endif
+	/*read status & frame register to abandon last key from uboot*/
+	am_remote_read_reg(DURATION_REG1_AND_STATUS);
+	am_remote_read_reg(FRAME_BODY);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING + 1;
+	early_suspend.suspend = remote_early_suspend;
+	early_suspend.resume = NULL;
+	early_suspend.param = gp_remote;
+	register_early_suspend(&early_suspend);
+#endif
 
 	ret = device_create_file(&pdev->dev, &dev_attr_enable);
 	if (ret < 0) {
@@ -704,7 +702,7 @@ static int remote_probe(struct platform_device *pdev)
 		device_remove_file(&pdev->dev, &dev_attr_enable);
 		goto err1;
 	}
-	input_dbg("device_create_file completed\n");
+	input_dbg("device_create_file completed \r\n");
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) | BIT_MASK(EV_ABS);
 	input_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_MIDDLE);
 	input_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y) | BIT_MASK(REL_WHEEL);
@@ -729,7 +727,7 @@ static int remote_probe(struct platform_device *pdev)
 		printk(KERN_ERR "Unable to register keypad input device\n");
 		goto err2;
 	}
-	input_dbg("input_register_device completed\n");
+	input_dbg("input_register_device completed \r\n");
 	if (hardware_init(pdev)) {
 		goto err3;
 	}
@@ -753,7 +751,7 @@ static int remote_remove(struct platform_device *pdev)
 {
 	struct remote *remote = platform_get_drvdata(pdev);
 	/* disable keypad interrupt handling */
-	input_dbg("remove remote\n");
+	input_dbg("remove remote\r\n");
 	tasklet_disable(&tasklet);
 	tasklet_kill(&tasklet);
 	/* unregister everything */
@@ -761,7 +759,7 @@ static int remote_remove(struct platform_device *pdev)
 	free_pages((unsigned long)remote_log_buf, REMOTE_LOG_BUF_ORDER);
 	device_remove_file(&pdev->dev, &dev_attr_enable);
 	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
-	if(gp_remote->work_mode >= DECODEMODE_MAX){
+	if(gp_remote->work_mode >= DECODEMODE_MAX) {
 		free_fiq(NEC_REMOTE_IRQ_NO, remote_fiq_interrupt);
 		free_irq(BRIDGE_IRQ, gp_remote);
 	} else {
@@ -786,23 +784,23 @@ static int remote_resume(struct platform_device * pdev)
 {
 	printk("remote_resume To do remote resume\n");
 	printk("remote_resume make sure read frame enable ir interrupt\n");
-	am_remote_read_reg(DURATION_REG1_AND_STATUS);	
-	am_remote_read_reg(FRAME_BODY);	
+	am_remote_read_reg(DURATION_REG1_AND_STATUS);
+	am_remote_read_reg(FRAME_BODY);
 	if (READ_AOBUS_REG(AO_RTI_STATUS_REG2) == 0x1234abcd) {
 		input_event(gp_remote->input, EV_KEY, KEY_POWER, 1);
 		input_sync(gp_remote->input);
 		input_event(gp_remote->input, EV_KEY, KEY_POWER, 0);
 		input_sync(gp_remote->input);
-		
+
 		//aml_write_reg32(P_AO_RTC_ADDR0, (aml_read_reg32(P_AO_RTC_ADDR0) | (0x0000f000)));
 		WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0);
 	}
 	gp_remote->sleep = 0;
-        printk("to clear irq ...\n");
+	printk("to clear irq ...\n");
 	disable_irq(NEC_REMOTE_IRQ_NO);
-        udelay(1000);
+	udelay(1000);
 	enable_irq(NEC_REMOTE_IRQ_NO);
-		
+
 	return 0;
 }
 
@@ -821,7 +819,7 @@ static struct platform_driver remote_driver = {
 	.resume = remote_resume,
 	.driver = {
 		.name = "meson-remote",
-		.of_match_table = remote_dt_match,	
+		.of_match_table = remote_dt_match,
 	},
 };
 
diff --git a/drivers/amlogic/input/new_remote/remote_main.h b/drivers/amlogic/input/new_remote/remote_main.h
index c1864e810f66..b3da3cb00071 100755
--- a/drivers/amlogic/input/new_remote/remote_main.h
+++ b/drivers/amlogic/input/new_remote/remote_main.h
@@ -5,36 +5,36 @@
 #include <linux/timer.h>
 #include <plat/fiq_bridge.h>
 /*remote register*/
-#define LDR_ACTIVE 0x0     
-#define LDR_IDLE 0x4        
-#define LDR_REPEAT 0x8	 
-#define DURATION_REG0    0xc             
-#define OPERATION_CTRL_REG0 0x10                  
-#define FRAME_BODY 0x14     
-#define DURATION_REG1_AND_STATUS 0x18          
-#define OPERATION_CTRL_REG1 0x1c      
-#define OPERATION_CTRL_REG2 0x20 
-#define DURATION_REG2    0x24    
-#define DURATION_REG3    0x28    
-#define FRAME_BODY1 0x2c  
-#define CONFIG_END 0xff  
+#define LDR_ACTIVE 0x0
+#define LDR_IDLE 0x4
+#define LDR_REPEAT 0x8
+#define DURATION_REG0    0xc
+#define OPERATION_CTRL_REG0 0x10
+#define FRAME_BODY 0x14
+#define DURATION_REG1_AND_STATUS 0x18
+#define OPERATION_CTRL_REG1 0x1c
+#define OPERATION_CTRL_REG2 0x20
+#define DURATION_REG2    0x24
+#define DURATION_REG3    0x28
+#define FRAME_BODY1 0x2c
+#define CONFIG_END 0xff
 /*config remote register val*/
 typedef struct reg_s {
 	int reg;
 	unsigned int val;
 } remotereg_t;
-typedef enum{
+typedef enum {
 	NORMAL = 0,
 	TIMER = 1 ,
-}repeat_status;
+} repeat_status;
 
 /*
-   Decode_mode.(format selection) 
+   Decode_mode.(format selection)
    0x0 =NEC
    0x1= skip leader (just bits)
    0x2=measure width (software decode)
    0x3=MITSUBISHI
-   0x4=Thomson   
+   0x4=Thomson
    0x5=Toshiba
    0x6=Sony SIRC
    0x7=RC5
@@ -47,26 +47,29 @@ typedef enum{
    0xE=Comcast
    0xF=Sanyo
  */
-typedef enum{
+typedef enum {
 	DECODEMODE_NEC = 0,
 	DECODEMODE_DUOKAN = 1 ,
 	DECODEMODE_RCMM ,
 	DECODEMODE_SONYSIRC,
 	DECODEMODE_SKIPLEADER ,
-	DECODEMODE_SW,
 	DECODEMODE_MITSUBISHI,
 	DECODEMODE_THOMSON,
 	DECODEMODE_TOSHIBA,
 	DECODEMODE_RC5,
 	DECODEMODE_RESERVED,
 	DECODEMODE_RC6,
+	DECODEMODE_RCA,
 	DECODEMODE_COMCAST,
 	DECODEMODE_SANYO,
+	DECODEMODE_NEC_RCA_2IN1 = 14,
+	DECODEMODE_NEC_TOSHIBA_2IN1 = 15,
+	DECODEMODE_SW,
 	DECODEMODE_MAX ,
 	DECODEMODE_SW_NEC,
 	DECODEMODE_SW_DUOKAN
 
-}ddmode_t;
+} ddmode_t;
 
 /*remote config val*/
 /****************************************************************/
@@ -74,14 +77,14 @@ static const remotereg_t RDECODEMODE_NEC[] = {
 	{LDR_ACTIVE,((unsigned)477<<16) | ((unsigned)400<<0)},// NEC leader 9500us,max 477: (477* timebase = 20) = 9540 ;min 400 = 8000us
 	{LDR_IDLE, 248<<16 | 202<<0},// leader idle
 	{LDR_REPEAT,130<<16|110<<0}, // leader repeat
-	{DURATION_REG0,60<<16|48<<0 },// logic '0' or '00'      
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms         
-	{DURATION_REG1_AND_STATUS,(111<<20)|(100<<10)}, // logic '1' or '01'      
+	{DURATION_REG0,60<<16|48<<0 },// logic '0' or '00'
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
+	{DURATION_REG1_AND_STATUS,(111<<20)|(100<<10)}, // logic '1' or '01'
 	{OPERATION_CTRL_REG1,0x9f40},// boby long decode (8-13)
 	//{OPERATION_CTRL_REG1,0xbe40},// boby long decode (8-13)
 	{OPERATION_CTRL_REG2,0x0}, // hard decode mode
 	{DURATION_REG2,0},
-	{DURATION_REG3,0},  
+	{DURATION_REG3,0},
 	{CONFIG_END,            0      }
 };
 /****************************************************************/
@@ -89,8 +92,8 @@ static const remotereg_t RDECODEMODE_DUOKAN[] = {
 	{LDR_ACTIVE,53<<16 | 50<<0},
 	{LDR_IDLE, 31<<16 | 25<<0},
 	{LDR_REPEAT,30<<16 | 26<<0},
-	{DURATION_REG0,61<<16 | 55<<0 }, 
-	{OPERATION_CTRL_REG0,3<<28 |(0x5DC<<12)| 0x13}, //body frame 30ms         
+	{DURATION_REG0,61<<16 | 55<<0 },
+	{OPERATION_CTRL_REG0,3<<28 |(0x5DC<<12)| 0x13}, //body frame 30ms
 	{DURATION_REG1_AND_STATUS,(76<<20) | 69<<10},
 	{OPERATION_CTRL_REG1,0x9300},
 	{OPERATION_CTRL_REG2,0x10b},
@@ -103,13 +106,13 @@ static const remotereg_t RDECODEMODE_RCMM[] = {
 	{LDR_ACTIVE,25<<16 | 22<<0},
 	{LDR_IDLE, 14<<16 | 13<<0},
 	{LDR_REPEAT,14<<16 | 13<<0},
-	{DURATION_REG0,25<<16 | 21<<0 },          
-	{OPERATION_CTRL_REG0,3<<28 |(0x708<<12)| 0x13}, // body frame 28 or 36 ms        
-	{DURATION_REG1_AND_STATUS,33<<20 | 29<<10},        
+	{DURATION_REG0,25<<16 | 21<<0 },
+	{OPERATION_CTRL_REG0,3<<28 |(0x708<<12)| 0x13}, // body frame 28 or 36 ms
+	{DURATION_REG1_AND_STATUS,33<<20 | 29<<10},
 	{OPERATION_CTRL_REG1,0xbe40},
 	{OPERATION_CTRL_REG2,0xa},
 	{DURATION_REG2,39<<16 | 36<<0},
-	{DURATION_REG3,50<<16 | 46<<0},  
+	{DURATION_REG3,50<<16 | 46<<0},
 	{CONFIG_END,            0      }
 };
 /****************************************************************/
@@ -117,13 +120,13 @@ static const remotereg_t RDECODEMODE_SONYSIRC[] = {
 	{LDR_ACTIVE,130<<16 | 110<<0},
 	{LDR_IDLE, 33<<16 | 27<<0},
 	{LDR_REPEAT,33<<16 | 27<<0},
-	{DURATION_REG0,63<<16 | 56<<0 },          
-	{OPERATION_CTRL_REG0,3<<28 |(0x8ca<<12)| 0x13},  // body frame 45ms            
-	{DURATION_REG1_AND_STATUS,94<<20 | 82<<10},        
+	{DURATION_REG0,63<<16 | 56<<0 },
+	{OPERATION_CTRL_REG0,3<<28 |(0x8ca<<12)| 0x13},  // body frame 45ms
+	{DURATION_REG1_AND_STATUS,94<<20 | 82<<10},
 	{OPERATION_CTRL_REG1,0xbe40},
 	{OPERATION_CTRL_REG2,0x6},
 	{DURATION_REG2,0},
-	{DURATION_REG3,0},  
+	{DURATION_REG3,0},
 	{CONFIG_END,            0      }
 };
 
@@ -133,9 +136,9 @@ static const remotereg_t RDECODEMODE_MITSUBISHI[] = {
 	{LDR_ACTIVE,410<<16 | 390<<0},
 	{LDR_IDLE, 225<<16 | 200<<0},
 	{LDR_REPEAT,225<<16 | 200<<0},
-	{DURATION_REG0,60<<16 | 48<<0 },          
-	{OPERATION_CTRL_REG0,3<<28 |(0xBB8<<12)| 0x13},  //An IR command is repeated 60ms for as long as the key on the remote is held down. body frame 60ms            
-	{DURATION_REG1_AND_STATUS,110<<20 | 95<<10},        
+	{DURATION_REG0,60<<16 | 48<<0 },
+	{OPERATION_CTRL_REG0,3<<28 |(0xBB8<<12)| 0x13},  //An IR command is repeated 60ms for as long as the key on the remote is held down. body frame 60ms
+	{DURATION_REG1_AND_STATUS,110<<20 | 95<<10},
 	{OPERATION_CTRL_REG1,0xbe40},
 	{OPERATION_CTRL_REG2,0x3},
 	{DURATION_REG2,0},
@@ -148,9 +151,9 @@ static const remotereg_t RDECODEMODE_TOSHIBA[] = {
 	{LDR_ACTIVE,477<<16 | 389<<0},//TOSHIBA leader 9000us
 	{LDR_IDLE, 477<<16 | 389<<0},// leader idle
 	{LDR_REPEAT,460<<16|389<<0}, // leader repeat
-	{DURATION_REG0,60<<16|40<<0 },// logic '0' or '00'      
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},         
-	{DURATION_REG1_AND_STATUS,111<<20|100<<10},// logic '1' or '01'      
+	{DURATION_REG0,60<<16|40<<0 },// logic '0' or '00'
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},
+	{DURATION_REG1_AND_STATUS,111<<20|100<<10},// logic '1' or '01'
 	{OPERATION_CTRL_REG1,0xbe40},// boby long decode (8-13)
 	{OPERATION_CTRL_REG2,0x5}, // hard decode mode
 	{DURATION_REG2,0},
@@ -163,53 +166,53 @@ static const remotereg_t RDECODEMODE_THOMSON[] = {
 	{LDR_ACTIVE,477<<16 | 390<<0},// THOMSON leader 8000us,
 	{LDR_IDLE, 477<<16 | 390<<0},// leader idle
 	{LDR_REPEAT,460<<16|390<<0}, // leader repeat
-	{DURATION_REG0,80<<16|60<<0 },// logic '0' or '00'      
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},         
-	{DURATION_REG1_AND_STATUS,140<<20|120<<10},// logic '1' or '01'      
+	{DURATION_REG0,80<<16|60<<0 },// logic '0' or '00'
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},
+	{DURATION_REG1_AND_STATUS,140<<20|120<<10},// logic '1' or '01'
 	{OPERATION_CTRL_REG1,0xbe40},// boby long decode (8-13)
 	{OPERATION_CTRL_REG2,0x4}, // hard decode mode
 	{DURATION_REG2,0},
-	{DURATION_REG3,0},  
+	{DURATION_REG3,0},
 	{CONFIG_END,            0      }
 };
 /*********************************************************************/
 static const remotereg_t RDECODEMODE_COMCAST[] = {
 	{LDR_ACTIVE, 0   },
 	{LDR_IDLE,0  },
-	{LDR_REPEAT,0	},
-	{DURATION_REG0, 0},   
-	{OPERATION_CTRL_REG0,0},               
-	{DURATION_REG1_AND_STATUS,},        
+	{LDR_REPEAT,0   },
+	{DURATION_REG0, 0},
+	{OPERATION_CTRL_REG0,0},
+	{DURATION_REG1_AND_STATUS,},
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},  
+	{DURATION_REG3,},
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_SKIPLEADER[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,	},
-	{DURATION_REG0, },          
-	{OPERATION_CTRL_REG0,},               
-	{DURATION_REG1_AND_STATUS,},        
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},  
+	{DURATION_REG3,},
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_SW[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,	},
-	{DURATION_REG0, },          
-	{OPERATION_CTRL_REG0,},               
-	{DURATION_REG1_AND_STATUS,},        
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},  
+	{DURATION_REG3,},
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_SW_NEC[] = {
@@ -217,12 +220,12 @@ static const remotereg_t RDECODEMODE_SW_NEC[] = {
 	{LDR_IDLE, 248<<16 | 202<<0},// leader idle
 	{LDR_REPEAT,130<<16|110<<0}, // leader repeat
 	{DURATION_REG0,60<<16|48<<0 },// logic '0' or '00'
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms         
-	{DURATION_REG1_AND_STATUS,(111<<20)|(100<<10)}, // logic '1' or '01'      
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
+	{DURATION_REG1_AND_STATUS,(111<<20)|(100<<10)}, // logic '1' or '01'
 	{OPERATION_CTRL_REG1,0x8578},// boby long decode (8-13)
-	{OPERATION_CTRL_REG2,0x2}, // 
+	{OPERATION_CTRL_REG2,0x2}, //
 	{DURATION_REG2,0},
-	{DURATION_REG3,0},  
+	{DURATION_REG3,0},
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_SW_DUOKAN[] = {
@@ -238,43 +241,88 @@ static const remotereg_t RDECODEMODE_SW_DUOKAN[] = {
 	{DURATION_REG3,0},
 	{CONFIG_END,            0      }
 };
+static const remotereg_t RDECODEMODE_NEC_RCA_2IN1[] = {
+	// used old decode
+	{LDR_ACTIVE-0x100,((unsigned)477<<16) | ((unsigned)400<<0)},// NEC leader 9500us,max 477: (477* timebase = 20) = 9540 ;min 400 = 8000us
+	{LDR_IDLE-0x100, 248<<16 | 202<<0},// leader idle
+	{LDR_REPEAT-0x100,130<<16|110<<0}, // leader repeat
+	{DURATION_REG0-0x100,60<<16|48<<0 },// logic '0' or '00'
+	{OPERATION_CTRL_REG0-0x100,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
+	{DURATION_REG1_AND_STATUS-0x100,(111<<20)|(100<<10)}, // logic '1' or '01'
+	{OPERATION_CTRL_REG1-0x100,0xbe40},// boby long decode (9-13)
+	// used new decode
+	{LDR_ACTIVE,((unsigned)250<<16) | ((unsigned)160<<0)},//rca leader 4000us,200* timebase
+	{LDR_IDLE, 250<<16 | 160<<0},// leader idle 400
+	{LDR_REPEAT,250<<16|160<<0}, // leader repeat
+	{DURATION_REG0,100<<16|48<<0 },// logic '0' or '00' 1500us
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame
+	{DURATION_REG1_AND_STATUS,(150<<20)|(110<<10)}, // logic '1' or '01'     2500us
+	{OPERATION_CTRL_REG1,0x9740},// boby long decode (8-13) //framn len = 24bit
+	/*it may get the wrong customer value and key value from register if the value is set to 0x4,so the register value must set to 0x104*/
+	{OPERATION_CTRL_REG2,0x104},
+	{DURATION_REG2,0},
+	{DURATION_REG3,0},
+	{CONFIG_END,            0      }
+};
+static const remotereg_t RDECODEMODE_NEC_TOSHIBA_2IN1[] = {
+	// used old decode
+	{LDR_ACTIVE-0x100,((unsigned)477<<16) | ((unsigned)400<<0)},// NEC leader 9500us,max 477: (477* timebase = 20) = 9540 ;min 400 = 8000us
+	{LDR_IDLE-0x100, 248<<16 | 202<<0},// leader idle
+	{LDR_REPEAT-0x100,130<<16|110<<0}, // leader repeat
+	{DURATION_REG0-0x100,60<<16|48<<0 },// logic '0' or '00'
+	{OPERATION_CTRL_REG0-0x100,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
+	{DURATION_REG1_AND_STATUS-0x100,(111<<20)|(100<<10)}, // logic '1' or '01'
+	{OPERATION_CTRL_REG1-0x100,0xbe00},// boby long decode (9-13)
+	// used new decode
+	{LDR_ACTIVE,((unsigned)300<<16) | ((unsigned)160<<0)},//toshiba leader 4500us,20* timebase
+	{LDR_IDLE, 300<<16 | 160<<0},// leader idle 4500
+	{LDR_REPEAT,300<<16|160<<0}, // leader repeat
+	{DURATION_REG0,90<<16|48<<0 },// logic '0' or '00' 1200us
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame
+	{DURATION_REG1_AND_STATUS,(150<<20)|(100<<10)}, // logic '1' or '01'     2400us
+	{OPERATION_CTRL_REG1,0x9f40},// boby long decode (8-13) //framn len = 24bit
+	{OPERATION_CTRL_REG2,0x5},
+	{DURATION_REG2,0},
+	{DURATION_REG3,0},
+	{CONFIG_END,            0      }
+};
 static const remotereg_t RDECODEMODE_RC5[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,	},
-	{DURATION_REG0, },          
-	{OPERATION_CTRL_REG0,},               
-	{DURATION_REG1_AND_STATUS,},        
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},  
+	{DURATION_REG3,},
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_RESERVED[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,	},
-	{DURATION_REG0, },          
-	{OPERATION_CTRL_REG0,},               
-	{DURATION_REG1_AND_STATUS,},        
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},  
+	{DURATION_REG3,},
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_RC6[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,	},
-	{DURATION_REG0, },          
-	{OPERATION_CTRL_REG0,},               
-	{DURATION_REG1_AND_STATUS,},        
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},  
+	{DURATION_REG3,},
 	{CONFIG_END,            0      }
 };
 
@@ -283,14 +331,14 @@ static const remotereg_t RDECODEMODE_RC6[] = {
 static const remotereg_t RDECODEMODE_SANYO[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,	},
-	{DURATION_REG0, },          
-	{OPERATION_CTRL_REG0,},               
-	{DURATION_REG1_AND_STATUS,},        
+	{LDR_REPEAT,    },
+	{DURATION_REG0, },
+	{OPERATION_CTRL_REG0,},
+	{DURATION_REG1_AND_STATUS,},
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},  
+	{DURATION_REG3,},
 	{CONFIG_END,            0      }
 };
 
@@ -309,51 +357,52 @@ void setremotereg(const remotereg_t *r);
 
 
 //remote config  ioctl  cmd
-#define REMOTE_IOC_INFCODE_CONFIG	    _IOW_BAD('I',13,sizeof(short))
-#define REMOTE_IOC_RESET_KEY_MAPPING	    _IOW_BAD('I',3,sizeof(short))
-#define REMOTE_IOC_SET_KEY_MAPPING		    _IOW_BAD('I',4,sizeof(short))
+#define REMOTE_IOC_INFCODE_CONFIG       _IOW_BAD('I',13,sizeof(short))
+#define REMOTE_IOC_RESET_KEY_MAPPING        _IOW_BAD('I',3,sizeof(short))
+#define REMOTE_IOC_SET_KEY_MAPPING          _IOW_BAD('I',4,sizeof(short))
 #define REMOTE_IOC_SET_REPEAT_KEY_MAPPING   _IOW_BAD('I',20,sizeof(short))
-#define REMOTE_IOC_SET_MOUSE_MAPPING	    _IOW_BAD('I',5,sizeof(short))
-#define REMOTE_IOC_SET_REPEAT_DELAY		    _IOW_BAD('I',6,sizeof(short))
-#define REMOTE_IOC_SET_REPEAT_PERIOD	    _IOW_BAD('I',7,sizeof(short))
+#define REMOTE_IOC_SET_MOUSE_MAPPING        _IOW_BAD('I',5,sizeof(short))
+#define REMOTE_IOC_SET_REPEAT_DELAY         _IOW_BAD('I',6,sizeof(short))
+#define REMOTE_IOC_SET_REPEAT_PERIOD        _IOW_BAD('I',7,sizeof(short))
 
-#define REMOTE_IOC_SET_REPEAT_ENABLE		_IOW_BAD('I',8,sizeof(short))
-#define	REMOTE_IOC_SET_DEBUG_ENABLE			_IOW_BAD('I',9,sizeof(short))
-#define	REMOTE_IOC_SET_MODE					_IOW_BAD('I',10,sizeof(short))
+#define REMOTE_IOC_SET_REPEAT_ENABLE        _IOW_BAD('I',8,sizeof(short))
+#define REMOTE_IOC_SET_DEBUG_ENABLE         _IOW_BAD('I',9,sizeof(short))
+#define REMOTE_IOC_SET_MODE                 _IOW_BAD('I',10,sizeof(short))
+
+#define REMOTE_IOC_SET_CUSTOMCODE       _IOW_BAD('I',100,sizeof(short))
+#define REMOTE_IOC_SET_RELEASE_DELAY        _IOW_BAD('I',99,sizeof(short))
 
-#define REMOTE_IOC_SET_RELEASE_DELAY		_IOW_BAD('I',99,sizeof(short))
-#define REMOTE_IOC_SET_CUSTOMCODE   		_IOW_BAD('I',100,sizeof(short))
 //reg
-#define REMOTE_IOC_SET_REG_BASE_GEN			_IOW_BAD('I',101,sizeof(short))
-#define REMOTE_IOC_SET_REG_CONTROL			_IOW_BAD('I',102,sizeof(short))
-#define REMOTE_IOC_SET_REG_LEADER_ACT 		_IOW_BAD('I',103,sizeof(short))
-#define REMOTE_IOC_SET_REG_LEADER_IDLE 		_IOW_BAD('I',104,sizeof(short))
-#define REMOTE_IOC_SET_REG_REPEAT_LEADER 	_IOW_BAD('I',105,sizeof(short))
-#define REMOTE_IOC_SET_REG_BIT0_TIME		 _IOW_BAD('I',106,sizeof(short))
+#define REMOTE_IOC_SET_REG_BASE_GEN         _IOW_BAD('I',101,sizeof(short))
+#define REMOTE_IOC_SET_REG_CONTROL          _IOW_BAD('I',102,sizeof(short))
+#define REMOTE_IOC_SET_REG_LEADER_ACT       _IOW_BAD('I',103,sizeof(short))
+#define REMOTE_IOC_SET_REG_LEADER_IDLE      _IOW_BAD('I',104,sizeof(short))
+#define REMOTE_IOC_SET_REG_REPEAT_LEADER    _IOW_BAD('I',105,sizeof(short))
+#define REMOTE_IOC_SET_REG_BIT0_TIME         _IOW_BAD('I',106,sizeof(short))
 
 //sw
-#define REMOTE_IOC_SET_BIT_COUNT		 	_IOW_BAD('I',107,sizeof(short))
-#define REMOTE_IOC_SET_TW_LEADER_ACT		_IOW_BAD('I',108,sizeof(short))
-#define REMOTE_IOC_SET_TW_BIT0_TIME			_IOW_BAD('I',109,sizeof(short))
-#define REMOTE_IOC_SET_TW_BIT1_TIME			_IOW_BAD('I',110,sizeof(short))
-#define REMOTE_IOC_SET_TW_REPEATE_LEADER	_IOW_BAD('I',111,sizeof(short))
-
-#define REMOTE_IOC_GET_TW_LEADER_ACT		_IOR_BAD('I',112,sizeof(short))
-#define REMOTE_IOC_GET_TW_BIT0_TIME			_IOR_BAD('I',113,sizeof(short))
-#define REMOTE_IOC_GET_TW_BIT1_TIME			_IOR_BAD('I',114,sizeof(short))
-#define REMOTE_IOC_GET_TW_REPEATE_LEADER	_IOR_BAD('I',115,sizeof(short))
-
-#define REMOTE_IOC_GET_REG_BASE_GEN			_IOR_BAD('I',121,sizeof(short))
-#define REMOTE_IOC_GET_REG_CONTROL			_IOR_BAD('I',122,sizeof(short))
-#define REMOTE_IOC_GET_REG_LEADER_ACT 		_IOR_BAD('I',123,sizeof(short))
-#define REMOTE_IOC_GET_REG_LEADER_IDLE 		_IOR_BAD('I',124,sizeof(short))
-#define REMOTE_IOC_GET_REG_REPEAT_LEADER 	_IOR_BAD('I',125,sizeof(short))
-#define REMOTE_IOC_GET_REG_BIT0_TIME	 	_IOR_BAD('I',126,sizeof(short))
-#define REMOTE_IOC_GET_REG_FRAME_DATA		_IOR_BAD('I',127,sizeof(short))
-#define REMOTE_IOC_GET_REG_FRAME_STATUS		_IOR_BAD('I',128,sizeof(short))
-
-#define REMOTE_IOC_SET_TW_BIT2_TIME			_IOW_BAD('I',129,sizeof(short))
-#define REMOTE_IOC_SET_TW_BIT3_TIME			_IOW_BAD('I',130,sizeof(short))
+#define REMOTE_IOC_SET_BIT_COUNT            _IOW_BAD('I',107,sizeof(short))
+#define REMOTE_IOC_SET_TW_LEADER_ACT        _IOW_BAD('I',108,sizeof(short))
+#define REMOTE_IOC_SET_TW_BIT0_TIME         _IOW_BAD('I',109,sizeof(short))
+#define REMOTE_IOC_SET_TW_BIT1_TIME         _IOW_BAD('I',110,sizeof(short))
+#define REMOTE_IOC_SET_TW_REPEATE_LEADER    _IOW_BAD('I',111,sizeof(short))
+
+#define REMOTE_IOC_GET_TW_LEADER_ACT        _IOR_BAD('I',112,sizeof(short))
+#define REMOTE_IOC_GET_TW_BIT0_TIME         _IOR_BAD('I',113,sizeof(short))
+#define REMOTE_IOC_GET_TW_BIT1_TIME         _IOR_BAD('I',114,sizeof(short))
+#define REMOTE_IOC_GET_TW_REPEATE_LEADER    _IOR_BAD('I',115,sizeof(short))
+
+#define REMOTE_IOC_GET_REG_BASE_GEN         _IOR_BAD('I',121,sizeof(short))
+#define REMOTE_IOC_GET_REG_CONTROL          _IOR_BAD('I',122,sizeof(short))
+#define REMOTE_IOC_GET_REG_LEADER_ACT       _IOR_BAD('I',123,sizeof(short))
+#define REMOTE_IOC_GET_REG_LEADER_IDLE      _IOR_BAD('I',124,sizeof(short))
+#define REMOTE_IOC_GET_REG_REPEAT_LEADER    _IOR_BAD('I',125,sizeof(short))
+#define REMOTE_IOC_GET_REG_BIT0_TIME        _IOR_BAD('I',126,sizeof(short))
+#define REMOTE_IOC_GET_REG_FRAME_DATA       _IOR_BAD('I',127,sizeof(short))
+#define REMOTE_IOC_GET_REG_FRAME_STATUS     _IOR_BAD('I',128,sizeof(short))
+
+#define REMOTE_IOC_SET_TW_BIT2_TIME         _IOW_BAD('I',129,sizeof(short))
+#define REMOTE_IOC_SET_TW_BIT3_TIME         _IOW_BAD('I',130,sizeof(short))
 
 #define   REMOTE_IOC_SET_FN_KEY_SCANCODE     _IOW_BAD('I', 131, sizeof(short))
 #define   REMOTE_IOC_SET_LEFT_KEY_SCANCODE   _IOW_BAD('I', 132, sizeof(short))
@@ -363,13 +412,13 @@ void setremotereg(const remotereg_t *r);
 #define   REMOTE_IOC_SET_OK_KEY_SCANCODE     _IOW_BAD('I', 136, sizeof(short))
 #define   REMOTE_IOC_SET_PAGEUP_KEY_SCANCODE _IOW_BAD('I', 137, sizeof(short))
 #define   REMOTE_IOC_SET_PAGEDOWN_KEY_SCANCODE _IOW_BAD('I', 138, sizeof(short))
-#define   REMOTE_IOC_SET_RELT_DELAY	    _IOW_BAD('I',140,sizeof(short))
+#define   REMOTE_IOC_SET_RELT_DELAY     _IOW_BAD('I',140,sizeof(short))
 
-#define	REMOTE_HW_DECODER_STATUS_MASK		(0xf<<4)
-#define	REMOTE_HW_DECODER_STATUS_OK			(0<<4)
-#define	REMOTE_HW_DECODER_STATUS_TIMEOUT	(1<<4)
-#define	REMOTE_HW_DECODER_STATUS_LEADERERR	(2<<4)
-#define	REMOTE_HW_DECODER_STATUS_REPEATERR	(3<<4)
+#define REMOTE_HW_DECODER_STATUS_MASK       (0xf<<4)
+#define REMOTE_HW_DECODER_STATUS_OK         (0<<4)
+#define REMOTE_HW_DECODER_STATUS_TIMEOUT    (1<<4)
+#define REMOTE_HW_DECODER_STATUS_LEADERERR  (2<<4)
+#define REMOTE_HW_DECODER_STATUS_REPEATERR  (3<<4)
 
 /* software  decode status*/
 #define REMOTE_STATUS_WAIT       0
@@ -381,8 +430,8 @@ void setremotereg(const remotereg_t *r);
 #define KEYDOMIAN 1 // find key val vail data domain
 #define CUSTOMDOMAIN 0 // find key val vail custom domain
 /*phy page user debug*/
-#define REMOTE_LOG_BUF_LEN		 8192
-#define REMOTE_LOG_BUF_ORDER		1
+#define REMOTE_LOG_BUF_LEN       4098
+#define REMOTE_LOG_BUF_ORDER        1
 
 
 typedef int (*type_printk)(const char *fmt, ...);
@@ -398,13 +447,14 @@ struct remote {
 	int irq;
 	int save_mode;
 	int work_mode; // use ioctl config decode mode
+	int temp_work_mode; // use ioctl config decode mode
 	int frame_mode;// same protocol frame have diffrent mode
 	unsigned int register_data;
 	unsigned int frame_status;
 	unsigned int cur_keycode;
 	unsigned int cur_lsbkeycode; // rcv low 32bit save
 	unsigned int cur_msbkeycode; // rcv high 10bit save
-	unsigned int repeat_release_code;// save 
+	unsigned int repeat_release_code;// save
 	unsigned int last_keycode;
 	unsigned int repeate_flag;
 	unsigned int repeat_enable;
@@ -418,7 +468,7 @@ struct remote {
 	//use duble protocol release time
 	unsigned int release_fdelay; //frist protocol
 	unsigned int release_sdelay;// second protocol
-	unsigned int release_delay;
+	unsigned int release_delay[20];
 	// debug swtich
 	unsigned int debug_enable;
 	//sw
@@ -440,9 +490,9 @@ struct remote {
 	char config_name[20];
 	struct class *config_class;
 	struct device *config_dev;
-	unsigned int repeat_delay;
-	unsigned int relt_delay;
-	unsigned int repeat_peroid;
+	unsigned int repeat_delay[20];
+	unsigned int relt_delay[20];
+	unsigned int repeat_peroid[20];
 	//
 	int (*remote_reprot_press_key)(struct remote *);
 	int (*key_report)(struct remote *);
@@ -458,15 +508,18 @@ void kdb_send_key(struct input_dev *dev, unsigned int scancode,unsigned int type
 void remote_send_key(struct input_dev *dev, unsigned int scancode,
 		unsigned int type,int event);
 extern irqreturn_t remote_bridge_isr(int irq, void *dev_id);
+extern irqreturn_t remote_null_bridge_isr(int irq, void *dev_id);
+extern int remote_hw_reprot_null_key(struct remote *remote_data);
 extern int remote_hw_reprot_key(struct remote *remote_data);
+extern int remote_hw_nec_rca_2in1_reprot_key(struct remote *remote_data);
+extern int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data);
 extern int remote_sw_reprot_key(struct remote *remote_data);
 extern void remote_nec_report_release_key(struct remote *remote_data);
+extern void remote_nec_rca_2in1_report_release_key(struct remote *remote_data);
+extern void remote_nec_toshiba_2in1_report_release_key(struct remote *remote_data);
 extern void remote_duokan_report_release_key(struct remote *remote_data);
 extern void remote_sw_reprot_release_key(struct remote *remote_data);
-
-
-
-
+extern void remote_null_reprot_release_key(struct remote *remote_data);
 extern int register_fiq_bridge_handle(bridge_item_t * c_item);
 extern int unregister_fiq_bridge_handle(bridge_item_t * c_item);
 extern int fiq_bridge_pulse_trigger(bridge_item_t * c_item);
-- 
2.19.0

