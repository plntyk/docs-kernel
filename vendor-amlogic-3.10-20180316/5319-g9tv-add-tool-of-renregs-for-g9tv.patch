From 8e8baeebd6741d8908ca09b34db0b5c23a5fbe47 Mon Sep 17 00:00:00 2001
From: "bo.yang" <bo.yang@amlogic.com>
Date: Sat, 10 Jan 2015 16:34:05 +0800
Subject: [PATCH 5319/5965] g9tv: add tool of renregs for g9tv

---
 .../tools/genregs/c_always_on_pointer.awk     |    54 +
 .../tools/genregs/c_stb_define.awk            |    50 +
 .../mach-mesong9tv/tools/genregs/ddr3_reg.awk |    77 +
 .../mach-mesong9tv/tools/genregs/dmc_reg.awk  |    64 +
 .../tools/genregs/dos_register.awk            |    52 +
 .../mach-mesong9tv/tools/genregs/genregs.sh   |    23 +
 .../mach-mesong9tv/tools/genregs/hdmitx.awk   |    52 +
 .../mach-mesong9tv/tools/genregs/readme.txt   |    20 +
 .../mach-mesong9tv/tools/genregs/register.awk |   119 +
 .../tools/genregs/secure_apb.awk              |    61 +
 .../tools/genregs/ucode/c_always_on_pointer.h |   191 +
 .../tools/genregs/ucode/c_stb_define.h        |   491 +
 .../tools/genregs/ucode/ddr3_reg.h            |   881 ++
 .../tools/genregs/ucode/dmc_reg.h             |   378 +
 .../tools/genregs/ucode/dos_register.h        |  7800 ++++++++++
 .../tools/genregs/ucode/hdmitx.h              |    85 +
 .../tools/genregs/ucode/register.h            | 12778 ++++++++++++++++
 .../tools/genregs/ucode/secure_apb.h          |    81 +
 18 files changed, 23257 insertions(+)
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/c_always_on_pointer.awk
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/c_stb_define.awk
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/ddr3_reg.awk
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/dmc_reg.awk
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/dos_register.awk
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/genregs.sh
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/hdmitx.awk
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/readme.txt
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/register.awk
 create mode 100755 arch/arm/mach-mesong9tv/tools/genregs/secure_apb.awk
 create mode 100644 arch/arm/mach-mesong9tv/tools/genregs/ucode/c_always_on_pointer.h
 create mode 100644 arch/arm/mach-mesong9tv/tools/genregs/ucode/c_stb_define.h
 create mode 100644 arch/arm/mach-mesong9tv/tools/genregs/ucode/ddr3_reg.h
 create mode 100644 arch/arm/mach-mesong9tv/tools/genregs/ucode/dmc_reg.h
 create mode 100644 arch/arm/mach-mesong9tv/tools/genregs/ucode/dos_register.h
 create mode 100644 arch/arm/mach-mesong9tv/tools/genregs/ucode/hdmitx.h
 create mode 100644 arch/arm/mach-mesong9tv/tools/genregs/ucode/register.h
 create mode 100644 arch/arm/mach-mesong9tv/tools/genregs/ucode/secure_apb.h

diff --git a/arch/arm/mach-mesong9tv/tools/genregs/c_always_on_pointer.awk b/arch/arm/mach-mesong9tv/tools/genregs/c_always_on_pointer.awk
new file mode 100755
index 000000000000..627f31c9b5cc
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/c_always_on_pointer.awk
@@ -0,0 +1,54 @@
+#!/usr/bin/awk -f
+
+
+BEGIN {
+	print "/*"
+	print " * "ARGV[1]
+	print " */"
+}
+
+
+function printformat(REGNAME, REGADDR)
+{
+	REGLENG = length(REGNAME)
+
+	if (REGLENG < 8)
+		print "#define", REGNAME "\t\t\t\t\t"	REGADDR
+	else if (REGLENG >=  8  && REGLENG < 16)
+		print "#define", REGNAME "\t\t\t\t"	REGADDR
+	else if (REGLENG >= 16  && REGLENG < 24)
+		print "#define", REGNAME "\t\t\t"	REGADDR
+	else if (REGLENG >= 24  && REGLENG < 32)
+		print "#define", REGNAME "\t\t"		REGADDR
+	else if (REGLENG >= 32  && REGLENG < 40)
+		print "#define", REGNAME "\t"		REGADDR
+}
+
+
+
+#
+# start to analysis the following syntax code.
+# #define P_AO_RTI_STATUS_REG0        (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x00 << 2))
+# #define P_AO_RTI_STATUS_REG1        (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x01 << 2))
+#
+/^#define([[:space:]]*)P_AO_./ && NF == 14 {
+
+	# AO_RTC_ADDR are defined in secure_apb.h on Secure APB3 bus
+	if ($0 ~ /AO_RTC_ADDR/)
+		next
+
+	REGNAME = substr($2, 3, (length($2) - 2))
+	REGADDR = "(" $8 " " $9 " " $10 " " $11 " " $12 " " $13 " " $14
+
+	PHYNAME = "P_"REGNAME
+	PHYADDR = "AOBUS_REG_ADDR" "(" REGNAME ")"
+
+	printformat(REGNAME, REGADDR)
+	printformat(PHYNAME, PHYADDR)
+}
+
+
+END {
+	print "\n"
+}
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/c_stb_define.awk b/arch/arm/mach-mesong9tv/tools/genregs/c_stb_define.awk
new file mode 100755
index 000000000000..99107b6b6d8c
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/c_stb_define.awk
@@ -0,0 +1,50 @@
+#!/usr/bin/awk -f
+
+
+BEGIN {
+	print "/*"
+	print " * "ARGV[1]
+	print " */"
+}
+
+
+function printformat(REGNAME, REGADDR)
+{
+	REGLENG = length(REGNAME)
+
+	if (REGLENG < 8)
+		print "#define", REGNAME "\t\t\t\t\t"	REGADDR
+	else if (REGLENG >=  8  && REGLENG < 16)
+		print "#define", REGNAME "\t\t\t\t"	REGADDR
+	else if (REGLENG >= 16  && REGLENG < 24)
+		print "#define", REGNAME "\t\t\t"	REGADDR
+	else if (REGLENG >= 24  && REGLENG < 32)
+		print "#define", REGNAME "\t\t"		REGADDR
+	else if (REGLENG >= 32  && REGLENG < 40)
+		print "#define", REGNAME "\t"		REGADDR
+}
+
+
+
+#
+# start to analysis the following syntax code.
+# #define STB_VERSION                                0x1600
+# #define STB_VERSION_2                              0x1650
+#
+/^#define([[:space:]]*)([A-Z0-9_]+)([[:space:]]*)(0[xX][A-Fa-f0-9]+)/ {
+
+	REGNAME = $2
+	REGADDR = $3
+
+	PHYNAME = "P_"REGNAME
+	PHYADDR = "CBUS_REG_ADDR" "(" REGNAME ")"
+
+	printformat(REGNAME, REGADDR)
+	printformat(PHYNAME, PHYADDR)
+}
+
+
+END {
+	print "\n"
+}
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/ddr3_reg.awk b/arch/arm/mach-mesong9tv/tools/genregs/ddr3_reg.awk
new file mode 100755
index 000000000000..31da7d723f18
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/ddr3_reg.awk
@@ -0,0 +1,77 @@
+#!/usr/bin/awk -f
+
+
+BEGIN {
+	print "/*"
+	print " * "ARGV[1]
+	print " */"
+}
+
+
+function printformat(REGNAME, REGADDR)
+{
+	REGLENG = length(REGNAME)
+
+	if (REGLENG < 8)
+		print "#define", REGNAME "\t\t\t\t\t"	REGADDR
+	else if (REGLENG >=  8  && REGLENG < 16)
+		print "#define", REGNAME "\t\t\t\t"	REGADDR
+	else if (REGLENG >= 16  && REGLENG < 24)
+		print "#define", REGNAME "\t\t\t"	REGADDR
+	else if (REGLENG >= 24  && REGLENG < 32)
+		print "#define", REGNAME "\t\t"		REGADDR
+	else if (REGLENG >= 32  && REGLENG < 40)
+		print "#define", REGNAME "\t"		REGADDR
+}
+
+
+#
+# start to analysis the following syntax code.
+#
+# #define AM_DDR_PLL_CNTL     0xc8000400
+# #define AM_DDR_PLL_CNTL1    0xc8000404
+#
+/^#define([[:space:]]*)([A-Z0-9_]+)([[:space:]]*)(0[xX][A-Fa-f0-9]+)/  && NF == 3 {
+
+	REGNAME = $2
+	REGADDR = "0x" substr($3, 7, 10)
+
+	if (REGNAME ~ /^P_/)
+		REGNAME = substr(REGNAME, 3, length(REGNAME))
+
+	PHYNAME = "P_" REGNAME
+	PHYADDR = "MMC_REG_ADDR" "(" REGNAME ")"
+
+	printformat(REGNAME, REGADDR)
+	printformat(PHYNAME, PHYADDR)
+}
+
+
+#
+# start to analysis the following syntax code.
+#
+# #define P_DDR1_PUB_RIDR               0xc8003000 + (0x00 << 2)
+# #define P_DDR1_PUB_PIR                0xc8003000 + (0x01 << 2)
+#
+/^#define/ && NF == 7 {
+
+	REGNAME = $2
+	REGADDR = "0x" substr($3, 7, 10);
+	REGADDR = "(" REGADDR " " $4 " " $5 " " $6 " " $7 ")"
+
+	if (REGNAME ~ /^P_/)
+		REGNAME = substr(REGNAME, 3, length(REGNAME))
+
+	PHYNAME = "P_" REGNAME
+	PHYADDR = "MMC_REG_ADDR" "(" REGNAME ")"
+
+	printformat(REGNAME, REGADDR)
+	printformat(PHYNAME, PHYADDR)
+}
+
+
+
+END {
+	print "\n"
+}
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/dmc_reg.awk b/arch/arm/mach-mesong9tv/tools/genregs/dmc_reg.awk
new file mode 100755
index 000000000000..443139218743
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/dmc_reg.awk
@@ -0,0 +1,64 @@
+#!/usr/bin/awk -f
+
+
+BEGIN {
+	print "/*"
+	print " * "ARGV[1]
+	print " */"
+}
+
+
+function printformat(REGNAME, REGADDR)
+{
+	REGLENG = length(REGNAME)
+
+	if (REGLENG < 8)
+		print "#define", REGNAME "\t\t\t\t\t"	REGADDR
+	else if (REGLENG >=  8  && REGLENG < 16)
+		print "#define", REGNAME "\t\t\t\t"	REGADDR
+	else if (REGLENG >= 16  && REGLENG < 24)
+		print "#define", REGNAME "\t\t\t"	REGADDR
+	else if (REGLENG >= 24  && REGLENG < 32)
+		print "#define", REGNAME "\t\t"		REGADDR
+	else if (REGLENG >= 32  && REGLENG < 40)
+		print "#define", REGNAME "\t"		REGADDR
+}
+
+
+
+#
+# start to analysis the following syntax code.
+# #define DMC_REG_BASE      0xc8006000
+#
+/^#define([[:space:]]*)([[:alnum:]]+)/ && NF == 3 {
+
+	REGNAME = "S_"$2
+	REGADDR = "0x" substr($3, 7, 4);
+
+	printformat(REGNAME, REGADDR)
+}
+
+
+#
+# start to analysis the following syntax code.
+# #define DMC_REQ_CTRL        DMC_REG_BASE + (0x00 << 2)
+# #define DMC_SOFT_RST        DMC_REG_BASE + (0x01 << 2)
+#
+/^#define/ && /DMC_REG_BASE/ && NF == 7 {
+
+	REGNAME = $2
+	REGADDR = "(" "S_" $3 " " $4 " " $5 " " $6 " " $7 ")"
+
+	PHYNAME = "P_"REGNAME
+	PHYADDR = "MMC_REG_ADDR" "(" REGNAME ")"
+
+	printformat(REGNAME, REGADDR)
+	printformat(PHYNAME, PHYADDR)
+
+}
+
+
+END {
+	print "\n"
+}
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/dos_register.awk b/arch/arm/mach-mesong9tv/tools/genregs/dos_register.awk
new file mode 100755
index 000000000000..f08900e80f16
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/dos_register.awk
@@ -0,0 +1,52 @@
+#!/usr/bin/awk -f
+
+
+BEGIN {
+	print "/*"
+	print " * "ARGV[1]
+	print " */"
+}
+
+
+function printformat(REGNAME, REGADDR)
+{
+	REGLENG = length(REGNAME)
+
+	if (REGLENG < 8)
+		print "#define", REGNAME "\t\t\t\t\t"	REGADDR
+	else if (REGLENG >=  8  && REGLENG < 16)
+		print "#define", REGNAME "\t\t\t\t"	REGADDR
+	else if (REGLENG >= 16  && REGLENG < 24)
+		print "#define", REGNAME "\t\t\t"	REGADDR
+	else if (REGLENG >= 24  && REGLENG < 32)
+		print "#define", REGNAME "\t\t"		REGADDR
+	else if (REGLENG >= 32  && REGLENG < 40)
+		print "#define", REGNAME "\t"		REGADDR
+}
+
+
+#
+# start to analysis the following syntax code.
+# #define VDEC_ASSIST_MMC_CTRL0                      ((0x0001  << 2) + 0xd0050000)
+# #define VDEC_ASSIST_MMC_CTRL1                      ((0x0002  << 2) + 0xd0050000)
+#
+/^#define/ && NF == 7 {
+
+	REGNAME = $2
+
+	match($0, /(0[xX][A-Fa-f0-9]+)/)
+	REGADDR = substr($0, RSTART, RLENGTH)
+
+	REGBASE = "DOS_REG_ADDR"
+
+
+	printformat(REGNAME, REGADDR)
+	printformat("P_"REGNAME, REGBASE "(" REGNAME ")")
+}
+
+
+
+END {
+	print "\n"
+}
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/genregs.sh b/arch/arm/mach-mesong9tv/tools/genregs/genregs.sh
new file mode 100755
index 000000000000..21ef293bf266
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/genregs.sh
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+echo "/**"
+echo " * This file is automaticly generated by genregs.sh. Please do not edit it."
+echo " * Created at `date`"
+echo " */"
+echo ""
+
+echo "#ifndef __MACH_G9TV_REGISTER_H"
+echo "#define __MACH_G9TV_REGISTER_H"
+echo ""
+
+gawk -f register.awk			ucode/register.h
+gawk -f c_always_on_pointer.awk		ucode/c_always_on_pointer.h
+gawk -f dos_register.awk		ucode/dos_register.h
+gawk -f ddr3_reg.awk			ucode/ddr3_reg.h
+gawk -f dmc_reg.awk			ucode/dmc_reg.h
+gawk -f c_stb_define.awk		ucode/c_stb_define.h
+gawk -f secure_apb.awk			ucode/secure_apb.h
+gawk -f hdmitx.awk			ucode/hdmitx.h
+
+echo ""
+echo "#endif"
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/hdmitx.awk b/arch/arm/mach-mesong9tv/tools/genregs/hdmitx.awk
new file mode 100755
index 000000000000..ff2a8cbffb48
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/hdmitx.awk
@@ -0,0 +1,52 @@
+#!/usr/bin/awk -f
+
+
+BEGIN {
+	print "/*"
+	print " * "ARGV[1]
+	print " */"
+}
+
+
+function printformat(REGNAME, REGADDR)
+{
+	REGLENG = length(REGNAME)
+
+	if (REGLENG < 8)
+		print "#define", REGNAME "\t\t\t\t\t"	REGADDR
+	else if (REGLENG >=  8  && REGLENG < 16)
+		print "#define", REGNAME "\t\t\t\t"	REGADDR
+	else if (REGLENG >= 16  && REGLENG < 24)
+		print "#define", REGNAME "\t\t\t"	REGADDR
+	else if (REGLENG >= 24  && REGLENG < 32)
+		print "#define", REGNAME "\t\t"		REGADDR
+	else if (REGLENG >= 32  && REGLENG < 40)
+		print "#define", REGNAME "\t"		REGADDR
+}
+
+
+#
+# start to analysis the following syntax code.
+#
+# #define HDMITX_ADDR_PORT        0xd0042000  // TOP ADDR_PORT: 0xd0042000; DWC ADDR_PORT: 0xd0042010
+# #define HDMITX_DATA_PORT        0xd0042004  // TOP DATA_PORT: 0xd0042004; DWC DATA_PORT: 0xd0042014
+# #define HDMITX_CTRL_PORT        0xd0042008  // TOP CTRL_PORT: 0xd0042008; DWC CTRL_PORT: 0xd0042018
+#
+/^#define([[:space:]]*)HDMITX_([A-Z0-9_]+)([[:space:]]*)(0[xX][A-Fa-f0-9]+)/ {
+
+	REGNAME = $2
+	REGADDR = "0x" substr($3, 6, 10)
+
+	PHYNAME = "P_" REGNAME
+	PHYADDR = "APB_REG_ADDR" "(" REGNAME ")"
+
+	printformat(REGNAME, REGADDR)
+	printformat(PHYNAME, PHYADDR)
+}
+
+
+
+END {
+	print "\n"
+}
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/readme.txt b/arch/arm/mach-mesong9tv/tools/genregs/readme.txt
new file mode 100755
index 000000000000..efa40f5c484e
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/readme.txt
@@ -0,0 +1,20 @@
+genregs tool
+=============================================
+
+Use the following command to generate register.h automaticly:
+
+./genregs.sh > register_out.h
+
+Compare the generated file register_out.h with include/mach/register.h.
+And update include/mach/register.h.
+
+
+
+You can only generate one of the ucode header file.
+
+For example, you can use the following command to generate DMC register
+from the original ucode header file ucode/dmc_reg.h:
+
+./dmc_reg.awk ucode/dmc_reg.h > dmc_reg_out.h
+
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/register.awk b/arch/arm/mach-mesong9tv/tools/genregs/register.awk
new file mode 100755
index 000000000000..35422e515c3e
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/register.awk
@@ -0,0 +1,119 @@
+#!/usr/bin/awk -f
+
+
+BEGIN {
+	print "/*"
+	print " * "ARGV[1]
+	print " */"
+}
+
+
+function printformat(REGNAME, REGADDR)
+{
+	REGLENG = length(REGNAME)
+
+	if (REGLENG < 8)
+		print "#define", REGNAME "\t\t\t\t\t"	REGADDR
+	else if (REGLENG >=  8  && REGLENG < 16)
+		print "#define", REGNAME "\t\t\t\t"	REGADDR
+	else if (REGLENG >= 16  && REGLENG < 24)
+		print "#define", REGNAME "\t\t\t"	REGADDR
+	else if (REGLENG >= 24  && REGLENG < 32)
+		print "#define", REGNAME "\t\t"		REGADDR
+	else if (REGLENG >= 32  && REGLENG < 40)
+		print "#define", REGNAME "\t"		REGADDR
+}
+
+
+#
+# start to analysis the following syntax code.
+# #define VDIN0_OFFSET            0x00
+# #define VDIN1_OFFSET            0x70
+#
+/^#define([[:space:]]*)([A-Z0-9_]+)([[:space:]]*)(0[xX][A-Fa-f0-9]+)/{
+
+	REGNAME = $2
+	REGADDR = $3
+
+	printformat(REGNAME, REGADDR)
+}
+
+
+#
+# start to analysis the following syntax code.
+# #define STB_TOP_CONFIG	((0x16f0  << 2) + 0xc1100000)
+# #define VDIN_SCALE_COEF_IDX	((0x1200  << 2) + 0xd0100000)
+#
+/^#define/ && NF == 7 {
+
+	REGNAME = $2
+
+        if($2 ~/^SAR_ADC_/)
+                next
+
+	match($0, /(0[xX][A-Fa-f0-9]+)/)
+	REGADDR = substr($0, RSTART, RLENGTH)
+
+	if ($0 ~/0xc1100000/) {
+		REGBASE = "CBUS_REG_ADDR"
+	}
+	else if ($0 ~/0xd0100000/) {
+		REGBASE = "VCBUS_REG_ADDR"
+	}
+	else
+		next
+
+	printformat(REGNAME, REGADDR)
+	printformat("P_"REGNAME, REGBASE "(" REGNAME ")")
+}
+
+#
+# start to analysis the following syntax code.
+# #define STB_TOP_CONFIG	((0x16f0  << 2) + 0xc1100000)
+# #define VDIN_SCALE_COEF_IDX	((0x1200  << 2) + 0xd0100000)
+#
+/^#define/ && /HHI_HDMI_PLL_CNTL/ && NF == 7 {
+
+	REGNAME = $2
+
+	match($0, /(0[xX][A-Fa-f0-9]+)/)
+	REGADDR = substr($0, RSTART, RLENGTH)
+
+	if ($0 ~/0xc1100000/) {
+		REGBASE = "CBUS_REG_ADDR"
+	}
+	else if ($0 ~/0xd0100000/) {
+		REGBASE = "VCBUS_REG_ADDR"
+	}
+	else
+		next
+
+	sub(/HHI_HDMI_PLL_CNTL/, "HHI_VID_PLL_CNTL", REGNAME)
+
+	printformat(REGNAME, REGADDR)
+	printformat("P_"REGNAME, REGBASE "(" REGNAME ")")
+}
+
+
+#
+# start to analysis the following syntax code.
+# #define VDIN0_SCALE_COEF_IDX                    ((VDIN0_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
+# #define VDIN1_SCALE_COEF_IDX                    ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
+#
+/^#define/ && NF == 8 {
+
+	REGNAME = $2
+	REGADDR = $3" "$4" "$5" "$6" "$7$8
+
+	PHYNAME = "P_"REGNAME
+	PHYADDR = "VCBUS_REG_ADDR" "(" REGNAME ")"
+
+	printformat(REGNAME, REGADDR)
+	printformat(PHYNAME, PHYADDR)
+}
+
+
+END {
+	print "\n"
+}
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/secure_apb.awk b/arch/arm/mach-mesong9tv/tools/genregs/secure_apb.awk
new file mode 100755
index 000000000000..d666cbaa0c2e
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/secure_apb.awk
@@ -0,0 +1,61 @@
+#!/usr/bin/awk -f
+
+
+BEGIN {
+	print "/*"
+	print " * "ARGV[1]
+	print " */"
+}
+
+
+function printformat(REGNAME, REGADDR)
+{
+	REGLENG = length(REGNAME)
+
+	if (REGLENG < 8)
+		print "#define", REGNAME "\t\t\t\t\t"	REGADDR
+	else if (REGLENG >=  8  && REGLENG < 16)
+		print "#define", REGNAME "\t\t\t\t"	REGADDR
+	else if (REGLENG >= 16  && REGLENG < 24)
+		print "#define", REGNAME "\t\t\t"	REGADDR
+	else if (REGLENG >= 24  && REGLENG < 32)
+		print "#define", REGNAME "\t\t"		REGADDR
+	else if (REGLENG >= 32  && REGLENG < 40)
+		print "#define", REGNAME "\t"		REGADDR
+}
+
+/^\/\// && /Slot([[:space:]]*)0/ {
+	REGBASE = "SECBUS_REG_ADDR"
+}
+
+/^\/\// && /Slot([[:space:]]*)2/ {
+	REGBASE = "SECBUS2_REG_ADDR"
+}
+
+/^\/\// && /Slot([[:space:]]*)3/ {
+	REGBASE = "SECBUS3_REG_ADDR"
+}
+
+
+#
+# start to analysis the following syntax code.
+# #define VDEC_ASSIST_MMC_CTRL0                      0x0001
+# #define VDEC_ASSIST_MMC_CTRL1                      0x0002
+#
+/^#define([[:space:]]*)([A-Z0-9_]+)([[:space:]]*)(0[xX][A-Fa-f0-9]+)/{
+
+	REGNAME = $2
+	REGADDR = $3
+
+	PHYNAME = "P_"REGNAME
+	PHYADDR = REGBASE "(" REGNAME ")"
+
+	printformat(REGNAME, REGADDR)
+	printformat(PHYNAME, PHYADDR)
+}
+
+
+END {
+	print "\n"
+}
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/ucode/c_always_on_pointer.h b/arch/arm/mach-mesong9tv/tools/genregs/ucode/c_always_on_pointer.h
new file mode 100644
index 000000000000..b40329fa35a2
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/ucode/c_always_on_pointer.h
@@ -0,0 +1,191 @@
+
+#ifdef  C_ALWAYS_ON_POINTER_H
+#else 
+
+
+//#define AO_Wr(addr, data)   *(volatile unsigned long *)((0xc8100000)|((addr)<<2))=(data)
+//#define AO_Rd(addr)         *(volatile unsigned long *)((0xc8100000)|((addr)<<2))
+
+// -------------------------------------------------------------------
+// BASE #0
+// -------------------------------------------------------------------
+
+#define P_AO_RTI_STATUS_REG0        (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x00 << 2))
+#define P_AO_RTI_STATUS_REG1        (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x01 << 2))
+#define P_AO_RTI_STATUS_REG2        (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x02 << 2))
+
+#define P_AO_RTI_PWR_CNTL_REG1      (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x03 << 2))
+#define P_AO_RTI_PWR_CNTL_REG0      (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x04 << 2))
+#define P_AO_RTI_PIN_MUX_REG        (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x05 << 2))
+
+#define P_AO_WD_GPIO_REG            (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x06 << 2))
+
+#define P_AO_REMAP_REG0             (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x07 << 2))
+#define P_AO_REMAP_REG1             (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x08 << 2))
+#define P_AO_GPIO_O_EN_N            (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x09 << 2))
+#define P_AO_GPIO_I                 (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x0A << 2))
+
+#define P_AO_RTI_PULL_UP_REG        (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x0B << 2))
+// replaced with secure register
+// #define P_AO_RTI_JTAG_CODNFIG_REG   (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x0C << 2))
+#define P_AO_RTI_WD_MARK            (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x0D << 2))
+
+#define P_AO_CPU_CNTL               (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x0E << 2))
+
+#define P_AO_CPU_STAT               (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x0F << 2))
+
+
+#define P_AO_RTI_GEN_CNTL_REG0      (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x10 << 2))
+#define P_AO_WATCHDOG_REG           (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x11 << 2))
+#define P_AO_WATCHDOG_RESET         (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x12 << 2))
+
+#define P_AO_TIMER_REG              (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x13 << 2))
+#define P_AO_TIMERA_REG             (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x14 << 2))
+#define P_AO_TIMERE_REG             (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x15 << 2))
+
+#define P_AO_AHB2DDR_CNTL           (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x18 << 2))
+#define P_AO_TIMEBASE_CNTL          (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x19 << 2)) 
+
+#define P_AO_CRT_CLK_CNTL1          (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x1a << 2)) 
+
+#define P_AO_IRQ_MASK_FIQ_SEL       (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x20 << 2))
+#define P_AO_IRQ_GPIO_REG           (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x21 << 2))
+#define P_AO_IRQ_STAT               (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x22 << 2))
+#define P_AO_IRQ_STAT_CLR           (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x23 << 2))
+
+#define P_AO_SAR_CLK                (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x24 << 2))
+
+#define P_AO_DEBUG_REG0             (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x28 << 2))
+#define P_AO_DEBUG_REG1             (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x29 << 2))
+#define P_AO_DEBUG_REG2             (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x2a << 2))
+#define P_AO_DEBUG_REG3             (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x2b << 2))
+
+#define P_AO_IR_BLASTER_ADDR0       (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x30 << 2))
+#define P_AO_IR_BLASTER_ADDR1       (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x31 << 2))
+#define P_AO_IR_BLASTER_ADDR2       (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x32 << 2))
+
+// general Power control 
+#define P_AO_RTI_PWR_A9_CNTL0       (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x38 << 2))
+#define P_AO_RTI_PWR_A9_CNTL1       (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x39 << 2))
+#define P_AO_RTI_GEN_PWR_SLEEP0     (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x3a << 2))
+#define P_AO_RTI_GEN_PWR_ISO0       (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x3b << 2))
+
+#define P_AO_CEC_GEN_CNTL           (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x40 << 2))
+#define P_AO_CEC_RW_REG             (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x41 << 2))
+#define P_AO_CEC_INTR_MASKN         (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x42 << 2))
+#define P_AO_CEC_INTR_CLR           (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x43 << 2))
+#define P_AO_CEC_INTR_STAT          (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x44 << 2))
+
+#define P_AO_CRT_CLK_CNTL1          (volatile unsigned long *)(0xc8100000 | (0x00 << 10) | (0x1a << 2))
+// -------------------------------------------------------------------
+// BASE #1
+// -------------------------------------------------------------------
+#define P_AO_IR_DEC_LDR_ACTIVE      (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x20 << 2))
+#define P_AO_IR_DEC_LDR_IDLE        (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x21 << 2))
+#define P_AO_IR_DEC_LDR_REPEAT      (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x22 << 2))
+#define P_AO_IR_DEC_BIT_0           (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x23 << 2))
+#define P_AO_IR_DEC_REG0            (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x24 << 2))
+#define P_AO_IR_DEC_FRAME           (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x25 << 2))
+#define P_AO_IR_DEC_STATUS          (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x26 << 2))
+#define P_AO_IR_DEC_REG1            (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x27 << 2))
+
+// ----------------------------
+// UART
+// ----------------------------
+#define P_AO_UART_WFIFO             (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x30 << 2))
+#define P_AO_UART_RFIFO             (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x31 << 2))
+#define P_AO_UART_CONTROL           (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x32 << 2))
+#define P_AO_UART_STATUS            (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x33 << 2))
+#define P_AO_UART_MISC              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x34 << 2))
+#define P_AO_UART_REG5              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x35 << 2))
+
+// ----------------------------
+// UART2
+// ----------------------------
+#define P_AO_UART2_WFIFO             (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x38 << 2))
+#define P_AO_UART2_RFIFO             (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x39 << 2))
+#define P_AO_UART2_CONTROL           (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x3a << 2))
+#define P_AO_UART2_STATUS            (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x3b << 2))
+#define P_AO_UART2_MISC              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x3c << 2))
+#define P_AO_UART2_REG5              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x3d << 2))
+
+// ----------------------------
+// I2C Master (8)
+// ----------------------------
+#define P_AO_I2C_M_0_CONTROL_REG    (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x40 << 2))
+#define P_AO_I2C_M_0_SLAVE_ADDR     (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x41 << 2))
+#define P_AO_I2C_M_0_TOKEN_LIST0    (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x42 << 2))
+#define P_AO_I2C_M_0_TOKEN_LIST1    (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x43 << 2))
+#define P_AO_I2C_M_0_WDATA_REG0     (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x44 << 2))
+#define P_AO_I2C_M_0_WDATA_REG1     (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x45 << 2))
+#define P_AO_I2C_M_0_RDATA_REG0     (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x46 << 2))
+#define P_AO_I2C_M_0_RDATA_REG1     (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x47 << 2))
+// ----------------------------
+// I2C Slave (3)
+// ----------------------------
+#define P_AO_I2C_S_CONTROL_REG      (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x50 << 2))
+#define P_AO_I2C_S_SEND_REG         (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x51 << 2))
+#define P_AO_I2C_S_RECV_REG         (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x52 << 2))
+#define P_AO_I2C_S_CNTL1_REG        (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x53 << 2))
+
+// ---------------------------
+// PWM 
+// ---------------------------
+#define P_AO_PWM_PWM_A              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x54 << 2))
+#define P_AO_PWM_PWM_B              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x55 << 2))
+#define P_AO_PWM_MISC_REG_AB        (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x56 << 2))
+#define P_AO_PWM_DELTA_SIGMA_AB     (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x57 << 2))
+
+// ---------------------------
+// RTC (4)
+// ---------------------------
+// NOTE:  These are on the Secure APB3  bus
+// 
+// Not on the secure bus #define P_AO_RTC_ADDR0              (volatile unsigned long *)(0xDA004000 | (0xd0 << 2))
+// Not on the secure bus #define P_AO_RTC_ADDR1              (volatile unsigned long *)(0xDA004000 | (0xd1 << 2))
+// Not on the secure bus #define P_AO_RTC_ADDR2              (volatile unsigned long *)(0xDA004000 | (0xd2 << 2))
+// Not on the secure bus #define P_AO_RTC_ADDR3              (volatile unsigned long *)(0xDA004000 | (0xd3 << 2))
+// Not on the secure bus #define P_AO_RTC_ADDR4              (volatile unsigned long *)(0xDA004000 | (0xd4 << 2))
+#define P_AO_RTC_ADDR0              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0xd0 << 2))
+#define P_AO_RTC_ADDR1              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0xd1 << 2))
+#define P_AO_RTC_ADDR2              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0xd2 << 2))
+#define P_AO_RTC_ADDR3              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0xd3 << 2))
+#define P_AO_RTC_ADDR4              (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0xd4 << 2))
+
+#define P_AO_MF_IR_DEC_LDR_ACTIVE   (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x60 << 2))
+#define P_AO_MF_IR_DEC_LDR_IDLE     (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x61 << 2))
+#define P_AO_MF_IR_DEC_LDR_REPEAT   (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x62 << 2))
+#define P_AO_MF_IR_DEC_BIT_0        (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x63 << 2))
+#define P_AO_MF_IR_DEC_REG0         (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x64 << 2))
+#define P_AO_MF_IR_DEC_FRAME        (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x65 << 2))
+#define P_AO_MF_IR_DEC_STATUS       (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x66 << 2))
+#define P_AO_MF_IR_DEC_REG1         (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x67 << 2))
+#define P_AO_MF_IR_DEC_REG2         (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x68 << 2))
+#define P_AO_MF_IR_DEC_DURATN2      (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x69 << 2))
+#define P_AO_MF_IR_DEC_DURATN3      (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x6a << 2))
+#define P_AO_MF_IR_DEC_FRAME1       (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x6b << 2))
+#define P_AO_MF_IR_DEC_STATUS1      (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x6c << 2))   
+#define P_AO_MF_IR_DEC_STATUS2      (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x6d << 2))   
+#define P_AO_MF_IR_DEC_REG3         (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x6e << 2))   
+#define P_AO_MF_IR_DEC_FRAME_RSV0   (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x6f << 2))   
+#define P_AO_MF_IR_DEC_FRAME_RSV1   (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x70 << 2))   
+
+// ----------------------------
+// SAR ADC (16)
+// ----------------------------
+#define P_AO_SAR_ADC_REG0           (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x80 << 2))
+#define P_AO_SAR_ADC_CHAN_LIST      (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x81 << 2))
+#define P_AO_SAR_ADC_AVG_CNTL       (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x82 << 2))
+#define P_AO_SAR_ADC_REG3           (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x83 << 2))
+#define P_AO_SAR_ADC_DELAY          (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x84 << 2))
+#define P_AO_SAR_ADC_LAST_RD        (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x85 << 2))
+#define P_AO_SAR_ADC_FIFO_RD        (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x86 << 2))
+#define P_AO_SAR_ADC_AUX_SW         (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x87 << 2))
+#define P_AO_SAR_ADC_CHAN_10_SW     (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x88 << 2))
+#define P_AO_SAR_ADC_DETECT_IDLE_SW (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x89 << 2))
+#define P_AO_SAR_ADC_DELTA_10       (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x8a << 2))
+#define P_AO_SAR_ADC_REG11          (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x8b << 2))
+#define P_AO_SAR_ADC_REG12          (volatile unsigned long *)(0xc8100000 | (0x01 << 10) | (0x8c << 2))
+
+#endif      // C_ALWAYS_ON_POINTER_H
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/ucode/c_stb_define.h b/arch/arm/mach-mesong9tv/tools/genregs/ucode/c_stb_define.h
new file mode 100644
index 000000000000..be0b238eeb87
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/ucode/c_stb_define.h
@@ -0,0 +1,491 @@
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+// 
+// ./create_stb_define_for_C_code.pl
+// 
+// and was applied to the file
+// 
+// ./stb_define.h
+// 
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+// 
+#ifdef C_STB_DEFINE_H
+#else
+#define C_STB_DEFINE_H
+
+// synopsys translate_off
+// synopsys translate_on
+// There are two instantiations under one CBUS slave.  Each CBUS slave can support
+// 256 registers.  Each demux is allocated 128 registers so set the offset in
+// the middle
+// Copy this define but don't add a base address
+// process_header_copy_only_on 
+// process_header_copy_only_off 
+//========================================================================
+//  STB TOP Registers				    (8'hf0 - 8'hf7)
+//========================================================================
+// bit 25 -- use FAIL fro TS2
+// bit 24 -- use FAIL fro TS1
+// bit 23 -- use FAIL fro TS0
+// bit 22 -- invert fec_error for S2P1
+// bit 21 -- invert fec_data for S2P1
+// bit 20 -- invert fec_sync for S2P1
+// bit 19 -- invert fec_valid for S2P1
+// bit 18 -- invert fec_clk for S2P1
+// bit 17:16 -- fec_s_sel for S2P1  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
+// Bit 15 -- enable_des_pl_clk
+// Bit 14:13 -- reserved
+// Bit 12:10 -- ts_out_select, 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File
+// bit 9:8 -- des_i_sel 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
+// bit 7 -- enable_des_pl
+// bit 6 -- invert fec_error for S2P0
+// bit 5 -- invert fec_data for S2P0
+// bit 4 -- invert fec_sync for S2P0
+// bit 3 -- invert fec_valid for S2P0
+// bit 2 -- invert fec_clk for S2P0
+// bit 1:0 -- fec_s_sel for S2P0  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
+// 15:8 -- TS_package_length_sub_1 (default : 187)
+//  7:0 -- fec_sync_byte (default : 0x47)
+// Bit 23:16 -- file_m2ts_skip_bytes
+// Bit 15:8 -- des_out_dly
+// Bit 7:6 -- transport_scrambling_control_odd // should be 3
+// Bit 5 -- ts_hiu_enable
+// Bit 4:0 -- fec_clk_div
+// Bit 13:8 -- des ts pl state   -- Read Only
+// Bit 3:0 PID index to 8 PID to get key-set
+// auto increse after TS_PL_PID_DATA read/write
+// Bit 13 -- PID match disble
+// Bit 12:0 -- PID
+// process_header_no_copy_on   
+//
+// NOTE:  Don't process the demux registers using the standard create_headers.... perl script.
+//        Instead, since the demux has multiple instances (and many registers) use a separate
+//        script to create a separate stb_define.h for C-code.  
+//========================================================================
+//  STB Registers				    (8'h00 - 8'h4f)
+//
+//========================================================================
+// STB registers are 8'h0x
+// Bit 15:0 -- version number : 0x0002  (v0.01)
+#define STB_VERSION                                0x1600
+#define STB_VERSION_2                              0x1650
+#define STB_VERSION_3                              0x16a0
+#define STB_TEST_REG                               0x1601
+#define STB_TEST_REG_2                             0x1651
+#define STB_TEST_REG_3                             0x16a1
+// Bit 15 -- fec_core_select 1 - select descramble output
+// Bit 14:12 -  fec_select 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File 
+// Bit 11 -- FEC_CLK
+// Bit 10 -- SOP
+// Bit 9 -- D_VALID
+// Bit 8 -- D_FAIL
+// Bit 7:0 -- D_DATA 7:0
+#define FEC_INPUT_CONTROL                          0x1602
+#define FEC_INPUT_CONTROL_2                        0x1652
+#define FEC_INPUT_CONTROL_3                        0x16a2
+#define FEC_INPUT_DATA                             0x1603
+#define FEC_INPUT_DATA_2                           0x1653
+#define FEC_INPUT_DATA_3                           0x16a3
+// bit 31 -- enable_free_clk_fec_data_valid
+// bit 30 -- enable_free_clk_stb_reg
+// bit 29:22 -- reserved
+// bit 21 -- do_not_trust_pes_package_length
+// bit 20 (bit 4) -- Bypass use recoder path
+// bit 19 (bit 3) -- clear_PID_continuity_counter_valid
+// bit 18 (bit 2) -- Disable Splicing
+// bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES
+// bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES
+// Bit 15 - do not trust section length
+// Bit 14 - om cmd push even zero
+// Bit 13 - reserved
+// Bit 12 - SUB, OTHER PES interrupt at beginning of PES
+// Bit 11 - discard_av_package -- for ts_recorder use only 
+// Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter
+// Bit 9 - ts_recorder_enable
+// Bit 8 - (table_id == 0xff) means section_end
+// Bit 7 - do not send uncomplete section
+// Bit 6 - do not discard duplicate package
+// Bit 5 - search SOP when trasport_error_indicator
+// Bit 4 - stb demux enable
+// Bit 3 - do not reset state machine on SOP
+// Bit 2 - search SOP when error happened ( when ignore_fail_n_sop, will have this case)
+// Bit 1 - do not use SOP input ( check FEC sync byte instead )
+// Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)
+#define DEMUX_CONTROL                              0x1604
+#define DEMUX_CONTROL_2                            0x1654
+#define DEMUX_CONTROL_3                            0x16a4
+// bit 15:8 demux package length - 1 ( default : 187 )
+// bit 7:0 default is 0x47
+#define FEC_SYNC_BYTE                              0x1605
+#define FEC_SYNC_BYTE_2                            0x1655
+#define FEC_SYNC_BYTE_3                            0x16a5
+// bit 31:16 -- filter memory write data hi[31:16]
+// bit 15:0 -- filter memory write data low [15:0]
+#define FM_WR_DATA                                 0x1606
+#define FM_WR_DATA_2                               0x1656
+#define FM_WR_DATA_3                               0x16a6
+// bit 31:24 -- advanced setting hi
+// bit 23:16 -- advanced setting low
+// bit 15 -- filter memory write data request
+// bit 7:0 -- filter memory write addr
+#define FM_WR_ADDR                                 0x1607
+#define FM_WR_ADDR_2                               0x1657
+#define FM_WR_ADDR_3                               0x16a7
+// bit 13:8 demux state  -- read only
+// bit 7:4 -- maxnum section filter compare address
+// bit 3:0 -- maxnum PID filter compare address
+#define MAX_FM_COMP_ADDR                           0x1608
+#define MAX_FM_COMP_ADDR_2                         0x1658
+#define MAX_FM_COMP_ADDR_3                         0x16a8
+// bit 15 - transport_error_indicator
+// bit 14 - payload_unit_start_indicator
+// bit 13 - transport_priority
+// bit 12:0 - PID
+#define TS_HEAD_0                                  0x1609
+#define TS_HEAD_0_2                                0x1659
+#define TS_HEAD_0_3                                0x16a9
+// bit 7:6 transport_scrambling_control
+// bit 5:4 adaptation_field_control
+// bit 3:0 continuity_counter
+#define TS_HEAD_1                                  0x160a
+#define TS_HEAD_1_2                                0x165a
+#define TS_HEAD_1_3                                0x16aa
+// bit 15:12 -- om_cmd_count (read only)
+// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
+// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
+// bit   5:3 -- type_stb_om_w_rd (read only)
+// bit     2 -- unit_start_stb_om_w_rd (read only)
+// bit     1 -- om_cmd_overflow (read only)
+// bit     0 -- om_cmd_pending (read) 
+// bit     0 -- om_cmd_read_finished (write)
+#define OM_CMD_STATUS                              0x160b
+#define OM_CMD_STATUS_2                            0x165b
+#define OM_CMD_STATUS_3                            0x16ab
+// bit 15:9 // bit 14:8 -- count_stb_om_w_rd  (read only)
+// bit 8:0  // bit  7:0 -- start_stb_om_wa_rd (read only)
+#define OM_CMD_DATA                                0x160c
+#define OM_CMD_DATA_2                              0x165c
+#define OM_CMD_DATA_3                              0x16ac
+// bit 11:0 -- offset for section data
+#define OM_CMD_DATA2                               0x160d
+#define OM_CMD_DATA2_2                             0x165d
+#define OM_CMD_DATA2_3                             0x16ad
+// bit 31:16 -- base address for section buffer group 0 (*0x400 to get real address)
+// bit 15:0 -- base address for section buffer group 1 (*0x400 to get real address)
+#define SEC_BUFF_01_START                          0x160e
+#define SEC_BUFF_01_START_2                        0x165e
+#define SEC_BUFF_01_START_3                        0x16ae
+// bit 31:16 -- ba2e address for section buffer group 2 (*0x400 to get real address)
+// bit 15:0 -- base address for section buffer group 3 (*0x400 to get real address)
+#define SEC_BUFF_23_START                          0x160f
+#define SEC_BUFF_23_START_2                        0x165f
+#define SEC_BUFF_23_START_3                        0x16af
+// bit 3:0 -- section buffer size for group 0 (bit used,  for example, 10 means 1K)
+// bit 7:4 -- section buffer size for group 1
+// bit 11:8 -- section buffer size for group 2
+// bit 15:12 -- section buffer size for group 3
+#define SEC_BUFF_SIZE                              0x1610
+#define SEC_BUFF_SIZE_2                            0x1660
+#define SEC_BUFF_SIZE_3                            0x16b0
+// section buffer busy status for buff 31:0 ( Read Only )
+#define SEC_BUFF_BUSY                              0x1611
+#define SEC_BUFF_BUSY_2                            0x1661
+#define SEC_BUFF_BUSY_3                            0x16b1
+// section buffer write status for buff 31:0 -- Read
+// clear buffer status ( buff READY and BUSY ) -- write
+#define SEC_BUFF_READY                             0x1612
+#define SEC_BUFF_READY_2                           0x1662
+#define SEC_BUFF_READY_3                           0x16b2
+// bit 4:0 -- SEC_BUFFER_INDEX   RW
+// bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only
+// bit 14 -- output_section_buffer_valid
+// bit 15 -- section_reset_busy (Read Only)
+#define SEC_BUFF_NUMBER                            0x1613
+#define SEC_BUFF_NUMBER_2                          0x1663
+#define SEC_BUFF_NUMBER_3                          0x16b3
+// bit 9:5 -- BYPASS PID number
+// bit 4:0 -- PCR PID number
+#define ASSIGN_PID_NUMBER                          0x1614
+#define ASSIGN_PID_NUMBER_2                        0x1664
+#define ASSIGN_PID_NUMBER_3                        0x16b4
+// bit 15:0 -- stream_id filter bit enable
+// bit 7:0 -- stream_id filter target
+#define VIDEO_STREAM_ID                            0x1615
+#define VIDEO_STREAM_ID_2                          0x1665
+#define VIDEO_STREAM_ID_3                          0x16b5
+#define AUDIO_STREAM_ID                            0x1616
+#define AUDIO_STREAM_ID_2                          0x1666
+#define AUDIO_STREAM_ID_3                          0x16b6
+#define SUB_STREAM_ID                              0x1617
+#define SUB_STREAM_ID_2                            0x1667
+#define SUB_STREAM_ID_3                            0x16b7
+#define OTHER_STREAM_ID                            0x1618
+#define OTHER_STREAM_ID_2                          0x1668
+#define OTHER_STREAM_ID_3                          0x16b8
+// bit 12 -- PCR_EN
+// bit 11:0 -- PCR90K_DIV
+#define PCR90K_CTL                                 0x1619
+#define PCR90K_CTL_2                               0x1669
+#define PCR90K_CTL_3                               0x16b9
+// bit 15:0 -- PCR[31:0] R/W
+#define PCR_DEMUX                                  0x161a
+#define PCR_DEMUX_2                                0x166a
+#define PCR_DEMUX_3                                0x16ba
+// bit 15:0 -- VPTS[31:0] R/W
+#define VIDEO_PTS_DEMUX                            0x161b
+#define VIDEO_PTS_DEMUX_2                          0x166b
+#define VIDEO_PTS_DEMUX_3                          0x16bb
+// bit 15:0 -- VDTS[31:0] R/W
+#define VIDEO_DTS_DEMUX                            0x161c
+#define VIDEO_DTS_DEMUX_2                          0x166c
+#define VIDEO_DTS_DEMUX_3                          0x16bc
+// bit 15:0 -- APTS[31:0] R/W
+#define AUDIO_PTS_DEMUX                            0x161d
+#define AUDIO_PTS_DEMUX_2                          0x166d
+#define AUDIO_PTS_DEMUX_3                          0x16bd
+// bit 15:0 -- SPTS[31:0] R/W
+#define SUB_PTS_DEMUX                              0x161e
+#define SUB_PTS_DEMUX_2                            0x166e
+#define SUB_PTS_DEMUX_3                            0x16be
+// read -- status, write 1 clear status
+// bit 15 -- SUB_PTS[32]
+// bit 14 -- AUDIO_PTS[32]
+// bit 13 -- VIDEO_DTS[32]
+// bit 12 -- VIDEO_PTS[32]
+// bit 3 -- sub_pts_ready
+// bit 2 -- audio_pts_ready
+// bit 1 -- video_dts_ready
+// bit 0 -- video_pts_ready
+#define STB_PTS_DTS_STATUS                         0x161f
+#define STB_PTS_DTS_STATUS_2                       0x166f
+#define STB_PTS_DTS_STATUS_3                       0x16bf
+// bit 3:0 --
+//  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0] 
+//  1 -- stream_id[7:0], pes_header_bytes_left[7:0]
+//  2 -- pes_package_bytes_left[15:0]
+//  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]
+// 
+#define STB_DEBUG_INDEX                            0x1620
+#define STB_DEBUG_INDEX_2                          0x1670
+#define STB_DEBUG_INDEX_3                          0x16c0
+// read only
+#define STB_DEBUG_DATAUT_O                         0x1621
+#define STB_DEBUG_DATAUT_O_2                       0x1671
+#define STB_DEBUG_DATAUT_O_3                       0x16c1
+// default : 0x807f
+// bit 15:9  -- MAX OM DMA COUNT  (default: 0x40) 
+// bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)
+#define STBM_CTL_O                                 0x1622
+#define STBM_CTL_O_2                               0x1672
+#define STBM_CTL_O_3                               0x16c2
+// 15:0  WRITE 1 CLEAR to clear interrupt source
+// 9 -- splicing_point
+// 8 -- other_PES_int
+// 7 -- sub_PES_int 
+// 6 -- discontinuity
+// 5 -- duplicated_pack_found
+// 4 -- New PDTS ready
+// 3 -- om_cmd_buffer ready for access
+// 2 -- section buffer ready 
+// 1 -- transport_error_indicator
+// 0 -- TS ERROR PIN 
+#define STB_INT_STATUS                             0x1623
+#define STB_INT_STATUS_2                           0x1673
+#define STB_INT_STATUS_3                           0x16c3
+// Bit 5:3 - demux om write endian control for bypass
+// Bit 2:0 - demux om write endian control for section
+// When Bit 31 - 1 write will indicate all type use sepertate endian (Write Only)
+// Bit 23:21 - demux om write endian control for OTHER_PES_PACKET
+// Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET
+// Bit 17:15 - demux om write endian control for SUB_PACKET
+// Bit 14:12 - demux om write endian control for AUDIO_PACKET
+// Bit 11:9  - demux om write endian control for VIDEO_PACKET
+// 
+// When Bit 31 - 0 write will indicate all type else use Bit 8:6
+// Bit 8:6 - demux om write endian control for else
+#define DEMUX_ENDIAN                               0x1624
+#define DEMUX_ENDIAN_2                             0x1674
+#define DEMUX_ENDIAN_3                             0x16c4
+// Bit 15:8 -- last_burst_threshold
+// Bit 7 -- use hi_bsf interface
+// Bit 6:2 - fec_clk_div
+// Bit 1 ts_source_sel 
+// Bit 0 - Hiu TS generate enable 
+#define TS_HIU_CTL                                 0x1625
+#define TS_HIU_CTL_2                               0x1675
+#define TS_HIU_CTL_3                               0x16c5
+// bit 15:0 -- base address for section buffer start (*0x10000 to get real base)
+#define SEC_BUFF_BASE                              0x1626
+#define SEC_BUFF_BASE_2                            0x1676
+#define SEC_BUFF_BASE_3                            0x16c6
+// bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN
+// bit 10 -- mask bit for SUB_AHB_DMA_EN
+// bit 9 -- mask bit for BYPASS_AHB_DMA_EN
+// bit 8 -- mask bit for SECTION_AHB_DMA_EN
+// bit 7 -- mask bit for recoder stream
+// bit 6:0 -- mask bit for each type
+#define DEMUX_MEM_REQ_EN                           0x1627
+#define DEMUX_MEM_REQ_EN_2                         0x1677
+#define DEMUX_MEM_REQ_EN_3                         0x16c7
+// bit 31:0 -- vb_wr_ptr for video PDTS 
+#define VIDEO_PDTS_WR_PTR                          0x1628
+#define VIDEO_PDTS_WR_PTR_2                        0x1678
+#define VIDEO_PDTS_WR_PTR_3                        0x16c8
+// bit 31:0 -- ab_wr_ptr for audio PDTS
+#define AUDIO_PDTS_WR_PTR                          0x1629
+#define AUDIO_PDTS_WR_PTR_2                        0x1679
+#define AUDIO_PDTS_WR_PTR_3                        0x16c9
+// bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)
+#define SUB_WR_PTR                                 0x162a
+#define SUB_WR_PTR_2                               0x167a
+#define SUB_WR_PTR_3                               0x16ca
+// bit 19:0 -- SB_START (sb_start << 12 == byte address);  
+#define SB_START                                   0x162b
+#define SB_START_2                                 0x167b
+#define SB_START_3                                 0x16cb
+// bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun) 
+#define SB_LAST_ADDR                               0x162c
+#define SB_LAST_ADDR_2                             0x167c
+#define SB_LAST_ADDR_3                             0x16cc
+// bit 31:0 -- sb_wr_ptr for sub PES
+#define SB_PES_WR_PTR                              0x162d
+#define SB_PES_WR_PTR_2                            0x167d
+#define SB_PES_WR_PTR_3                            0x16cd
+// bit 31:16 -- ob_wr_ptr for other PES
+// bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)
+#define OTHER_WR_PTR                               0x162e
+#define OTHER_WR_PTR_2                             0x167e
+#define OTHER_WR_PTR_3                             0x16ce
+// bit 19:0 -- OB_START (ob_start << 12 == byte address);  
+#define OB_START                                   0x162f
+#define OB_START_2                                 0x167f
+#define OB_START_3                                 0x16cf
+// bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun) 
+#define OB_LAST_ADDR                               0x1630
+#define OB_LAST_ADDR_2                             0x1680
+#define OB_LAST_ADDR_3                             0x16d0
+// bit 31:0 -- ob_wr_ptr for sub PES
+#define OB_PES_WR_PTR                              0x1631
+#define OB_PES_WR_PTR_2                            0x1681
+#define OB_PES_WR_PTR_3                            0x16d1
+// 15:0  DEMUX interrupt MASK
+// 9 -- splicing_point
+// 8 -- other_PES_int
+// 7 -- sub_PES_int 
+// 6 -- discontinuity
+// 5 -- duplicated_pack_found
+// 4 -- New PDTS ready
+// 3 -- om_cmd_buffer ready for access
+// 2 -- section buffer ready 
+// 1 -- transport_error_indicator
+// 0 -- TS ERROR PIN 
+#define STB_INT_MASK                               0x1632
+#define STB_INT_MASK_2                             0x1682
+#define STB_INT_MASK_3                             0x16d2
+// 31:16 VIDEO PID filter data
+//15 -- splicing VIDEO PID change enable 
+//14:10 -- VIDEO PID FILTER ADDRESS
+// 9 -- PES splicing active (Read Only) 
+// 8 -- splicing active (Read Only)
+// 7:0  splicing countdown (Read Only)
+#define VIDEO_SPLICING_CTL                         0x1633
+#define VIDEO_SPLICING_CTL_2                       0x1683
+#define VIDEO_SPLICING_CTL_3                       0x16d3
+// 31:16 AUDIO PID filter data
+//15 -- splicing AUDIO PID change enable 
+//14:10 -- AUDIO PID FILTER ADDRESS
+// 9 -- PES splicing active (Read Only) 
+// 8 -- splicing active (Read Only)
+// 7:0  splicing countdown (Read Only)
+#define AUDIO_SPLICING_CTL                         0x1634
+#define AUDIO_SPLICING_CTL_2                       0x1684
+#define AUDIO_SPLICING_CTL_3                       0x16d4
+// 23:16 M2TS_SKIP_BYTES
+// 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)
+// 7:0  PACKAGE BYTE COUNT (Read Only)
+#define TS_PACKAGE_BYTE_COUNT                      0x1635
+#define TS_PACKAGE_BYTE_COUNT_2                    0x1685
+#define TS_PACKAGE_BYTE_COUNT_3                    0x16d5
+// 15:0 2 bytes strong sync add to PES
+#define PES_STRONG_SYNC                            0x1636
+#define PES_STRONG_SYNC_2                          0x1686
+#define PES_STRONG_SYNC_3                          0x16d6
+// bit 15 -- stb_om_ren
+// bit 14:11 -- reserved
+// bit  10:0 -- OM_DATA_RD_ADDR
+#define OM_DATA_RD_ADDR                            0x1637
+#define OM_DATA_RD_ADDR_2                          0x1687
+#define OM_DATA_RD_ADDR_3                          0x16d7
+// bit 15:0 -- OM_DATA_RD
+#define OM_DATA_RD                                 0x1638
+#define OM_DATA_RD_2                               0x1688
+#define OM_DATA_RD_3                               0x16d8
+// AUTO STOP SETTING for 32 channels
+// 4-nbits per channel
+// when write
+// bit 3 -- set section active
+// bit 2:0 -- auto stop after count (0 means never stop)
+// when read
+// bit 3 -- current active status (1 - active, 0 - stopped )
+// bit 2:0 -- count down to auto stop
+// section 31:24
+#define SECTION_AUTO_STOP_3                        0x1639
+#define SECTION_AUTO_STOP_3_2                      0x1689
+#define SECTION_AUTO_STOP_3_3                      0x16d9
+// section 23:16
+#define SECTION_AUTO_STOP_2                        0x163a
+#define SECTION_AUTO_STOP_2_2                      0x168a
+#define SECTION_AUTO_STOP_2_3                      0x16da
+// section 15:8
+#define SECTION_AUTO_STOP_1                        0x163b
+#define SECTION_AUTO_STOP_1_2                      0x168b
+#define SECTION_AUTO_STOP_1_3                      0x16db
+// section 7:0
+#define SECTION_AUTO_STOP_0                        0x163c
+#define SECTION_AUTO_STOP_0_2                      0x168c
+#define SECTION_AUTO_STOP_0_3                      0x16dc
+// bit 31:0 reset channel status - each bit reset each channel 
+// read -- 32 channel status 
+#define DEMUX_CHANNEL_RESET                        0x163d
+#define DEMUX_CHANNEL_RESET_2                      0x168d
+#define DEMUX_CHANNEL_RESET_3                      0x16dd
+#define DEMUX_SCRAMBLING_STATE                     0x163e
+#define DEMUX_SCRAMBLING_STATE_2                   0x168e
+#define DEMUX_SCRAMBLING_STATE_3                   0x16de
+#define DEMUX_CHANNEL_ACTIVITY                     0x163f
+#define DEMUX_CHANNEL_ACTIVITY_2                   0x168f
+#define DEMUX_CHANNEL_ACTIVITY_3                   0x16df
+// bit 4 -- video_stamp_use_dts
+// bit 3 -- audio_stamp_sync_1_en 
+// bit 2 -- audio_stamp_insert_en 
+// bit 1 -- video_stamp_sync_1_en 
+// bit 0 -- video_stamp_insert_en 
+#define DEMUX_STAMP_CTL                            0x1640
+#define DEMUX_STAMP_CTL_2                          0x1690
+#define DEMUX_STAMP_CTL_3                          0x16e0
+#define DEMUX_VIDEO_STAMP_SYNC_0                   0x1641
+#define DEMUX_VIDEO_STAMP_SYNC_0_2                 0x1691
+#define DEMUX_VIDEO_STAMP_SYNC_0_3                 0x16e1
+#define DEMUX_VIDEO_STAMP_SYNC_1                   0x1642
+#define DEMUX_VIDEO_STAMP_SYNC_1_2                 0x1692
+#define DEMUX_VIDEO_STAMP_SYNC_1_3                 0x16e2
+#define DEMUX_AUDIO_STAMP_SYNC_0                   0x1643
+#define DEMUX_AUDIO_STAMP_SYNC_0_2                 0x1693
+#define DEMUX_AUDIO_STAMP_SYNC_0_3                 0x16e3
+#define DEMUX_AUDIO_STAMP_SYNC_1                   0x1644
+#define DEMUX_AUDIO_STAMP_SYNC_1_2                 0x1694
+#define DEMUX_AUDIO_STAMP_SYNC_1_3                 0x16e4
+// Write : Bit[4:0] secter filter number for reset
+// Read  : select according to output_section_buffer_valid : 
+//         per bit per section buffer valid status
+//         or section_buffer_ignore
+#define DEMUX_SECTION_RESET                        0x1645
+#define DEMUX_SECTION_RESET_2                      0x1695
+#define DEMUX_SECTION_RESET_3                      0x16e5
+// process_header_no_copy_off   
+// synopsys translate_off
+// synopsys translate_on
+
+#endif // C_STB_DEFINE_H
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/ucode/ddr3_reg.h b/arch/arm/mach-mesong9tv/tools/genregs/ucode/ddr3_reg.h
new file mode 100644
index 000000000000..7bae5f260c63
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/ucode/ddr3_reg.h
@@ -0,0 +1,881 @@
+#define AM_DDR_PLL_CNTL     0xc8000400
+#define AM_DDR_PLL_CNTL1    0xc8000404
+#define AM_DDR_PLL_CNTL2    0xc8000408
+#define AM_DDR_PLL_CNTL3    0xc800040c
+#define AM_DDR_PLL_CNTL4    0xc8000410
+#define AM_DDR_PLL_STS      0xc8000414
+  //bit 31. DDR_PLL lock.
+  // bit 6:0.  DDR_PLL analog output for test. 
+
+#define P_DDR_CLK_CNTL     0xc8000418
+  //bit 31     ddr_pll_clk enable. enable the clock from DDR_PLL to clock generateion. 
+  // whenever change the DDR_PLL frequency, disable the clock, after the DDR_PLL locked, then enable it again. 
+  //bit 30.    ddr_pll_prod_test_en.  enable the clock to clock/32 which to clock frequency measurement and production test pin.
+  //bit 29.    clock setting update. becasue the register is in PCLK domain. use this pin to update the clock divider setting.
+  //bit 28.    clock generation logic soft reset. 0 = reset.
+  //bit 15:8   second level divider control.
+  //bit 15.    second level divider clock selection. 0 : from first stage clock divider. 1: from second stage clock divider.
+  //bit 14.    enable the  first stage clock output to the second stage clock output. 
+  //bit 13.    second stage clock counter enable.
+  //bit 12.    enable the second stage divider clock ouput. 
+  //bit 11.    enable the 4xclk to DDR PHY. 
+  //bit 8.     second stage divider selection. 0: /2.  1: /4.
+  //bit 7:0.   first stage clock control.   
+  //bit 7.     first stage clock selection. 0 : DDR_PLL clock output.  1: divider.
+  //bit 6.     pll_clk_en.  enable the pll clock output to the first stage clock output selection.
+  //bit 3.     first stage clock counter enable.
+  //bit 2.     first stage clock divider output enable.
+  //bit 1:0.   00:  /2.  01: /4. 10: /8. 11: /16.
+  
+#define P_DDR_CLK_STS      0xc800041c
+  //not used.
+  
+
+#define  P_DDR0_CLK_CTRL    0xc8000800
+//bit 9. invert the DDR PHY n_clk.   ( RF mode).
+//bit 8. disable the DDR PHY n_clk.
+//bit 7. not used. 
+//bit 6. force to disable PUB n_clk. 
+//bit 5. PUB auto clock gating enable. when the IP detected PCTL enter power down mode, use this bit to gating PUB n_clk.
+//bit 4. force to disable PCTL n_clk.
+//bit 3.  PCTL n_clk auto clock gating enable.  when the IP detected PCTL enter power down mode, use this bit to gating pctl n_clk.
+//bit 2. force to disable PUB PCLK. 
+//bit 1. PUB pclk auto clock gating enable.  when the IP detected PCTL enter power down mode,  use this bit to gating pub pclk. 
+//bit 0   PCTL PCLK enable.   When never configure PCTL register, we need to enable the APB clock 24 cycles earlier. after finished configure PCTL, 24 cycles later, we should disable this bit to save power.
+#define  P_DDR0_SOFT_RESET  0xc8000804
+//bit 3. pub n_clk domain soft reset.  1 active.
+//bit 2. pub p_clk domain soft reset.
+//bit 1. pctl n_clk domain soft reset.
+//bit 0. pctl p_clk domain soft reset.
+#define  P_DDR0_APD_CTRL    0xc8000808
+//bit 15:8.   power down enter latency. when IP checked the dfi_lp_req && dfi_lp_ack,  give PCTL and pub additional latency let them settle down, then gating the clock.
+//bit 7:0.  no active latency.  after c_active_in become to low, wait additional latency to check the pctl low power state.  
+
+#define  P_DDR0_PCTL_SCFG           0xc8000000
+#define  P_DDR0_PCTL_SCTL           0xc8000004
+#define  P_DDR0_PCTL_STAT           0xc8000008
+#define  P_DDR0_PCTL_INTRSTAT       0xc800000c
+#define  P_DDR0_PCTL_POWSTAT        0xc8000048
+#define  P_DDR0_PCTL_MRRSTAT0       0xc8000064
+#define  P_DDR0_PCTL_CMDTSTAT       0xc800004c
+#define  P_DDR0_PCTL_MCMD           0xc8000040
+#define  P_DDR0_PCTL_MRRSTAT1       0xc8000068
+#define  P_DDR0_PCTL_MRRCFG0       0xc8000060
+#define  P_DDR0_PCTL_CMDTSTATEN       0xc8000050
+#define  P_DDR0_PCTL_POWCTL       0xc8000044
+#define  P_DDR0_PCTL_PPCFG       0xc8000084
+#define  P_DDR0_PCTL_LPDDR23ZQCFG       0xc800008c
+#define  P_DDR0_PCTL_MCFG1       0xc800007c
+#define  P_DDR0_PCTL_MSTAT       0xc8000088
+#define  P_DDR0_PCTL_MCFG       0xc8000080
+#define  P_DDR0_PCTL_DTUAWDT       0xc80000b0
+#define  P_DDR0_PCTL_DTUPRD2       0xc80000a8
+#define  P_DDR0_PCTL_DTUPRD3       0xc80000ac
+#define  P_DDR0_PCTL_DTUNE       0xc800009c
+#define  P_DDR0_PCTL_DTUPDES       0xc8000094
+#define  P_DDR0_PCTL_DTUNA       0xc8000098
+#define  P_DDR0_PCTL_DTUPRD0       0xc80000a0
+#define  P_DDR0_PCTL_DTUPRD1       0xc80000a4
+#define  P_DDR0_PCTL_TCKSRE       0xc8000124
+#define  P_DDR0_PCTL_TZQCSI       0xc800011c
+#define  P_DDR0_PCTL_TINIT       0xc80000c4
+#define  P_DDR0_PCTL_TDPD       0xc8000144
+#define  P_DDR0_PCTL_TOGCNT1U       0xc80000c0
+#define  P_DDR0_PCTL_TCKE       0xc800012c
+#define  P_DDR0_PCTL_TMOD       0xc8000130
+#define  P_DDR0_PCTL_TEXSR       0xc800010c
+#define  P_DDR0_PCTL_TAL       0xc80000e4
+#define  P_DDR0_PCTL_TRTP       0xc8000100
+#define  P_DDR0_PCTL_TCKSRX       0xc8000128
+#define  P_DDR0_PCTL_TRTW       0xc80000e0
+#define  P_DDR0_PCTL_TCWL       0xc80000ec
+#define  P_DDR0_PCTL_TWR       0xc8000104
+#define  P_DDR0_PCTL_TCL       0xc80000e8
+#define  P_DDR0_PCTL_TDQS       0xc8000120
+#define  P_DDR0_PCTL_TRSTH       0xc80000c8
+#define  P_DDR0_PCTL_TRCD       0xc80000f8
+#define  P_DDR0_PCTL_TXP       0xc8000110
+#define  P_DDR0_PCTL_TOGCNT100N       0xc80000cc
+#define  P_DDR0_PCTL_TMRD       0xc80000d4
+#define  P_DDR0_PCTL_TRSTL       0xc8000134
+#define  P_DDR0_PCTL_TREFI       0xc80000d0
+#define  P_DDR0_PCTL_TRAS       0xc80000f0
+#define  P_DDR0_PCTL_TREFI_MEM_DDR3       0xc8000148
+#define  P_DDR0_PCTL_TWTR       0xc8000108
+#define  P_DDR0_PCTL_TRC       0xc80000f4
+#define  P_DDR0_PCTL_TRFC       0xc80000d8
+#define  P_DDR0_PCTL_TMRR       0xc800013c
+#define  P_DDR0_PCTL_TCKESR       0xc8000140
+#define  P_DDR0_PCTL_TZQCL       0xc8000138
+#define  P_DDR0_PCTL_TRRD       0xc80000fc
+#define  P_DDR0_PCTL_TRP       0xc80000dc
+#define  P_DDR0_PCTL_TZQCS       0xc8000118
+#define  P_DDR0_PCTL_TXPDLL       0xc8000114
+#define  P_DDR0_PCTL_ECCCFG       0xc8000180
+#define  P_DDR0_PCTL_ECCLOG       0xc800018c
+#define  P_DDR0_PCTL_ECCCLR       0xc8000188
+#define  P_DDR0_PCTL_ECCTST       0xc8000184
+#define  P_DDR0_PCTL_DTUWD0       0xc8000210
+#define  P_DDR0_PCTL_DTUWD1       0xc8000214
+#define  P_DDR0_PCTL_DTUWACTL       0xc8000200
+#define  P_DDR0_PCTL_DTULFSRRD       0xc8000238
+#define  P_DDR0_PCTL_DTUWD2       0xc8000218
+#define  P_DDR0_PCTL_DTUWD3       0xc800021c
+#define  P_DDR0_PCTL_DTULFSRWD       0xc8000234
+#define  P_DDR0_PCTL_DTURACTL       0xc8000204
+#define  P_DDR0_PCTL_DTUWDM       0xc8000220
+#define  P_DDR0_PCTL_DTURD0       0xc8000224
+#define  P_DDR0_PCTL_DTURD1       0xc8000228
+#define  P_DDR0_PCTL_DTURD2       0xc800022c
+#define  P_DDR0_PCTL_DTURD3       0xc8000230
+#define  P_DDR0_PCTL_DTUCFG       0xc8000208
+#define  P_DDR0_PCTL_DTUEAF       0xc800023c
+#define  P_DDR0_PCTL_DTUECTL       0xc800020c
+#define  P_DDR0_PCTL_DFIODTCFG1       0xc8000248
+#define  P_DDR0_PCTL_DFITCTRLDELAY       0xc8000240
+#define  P_DDR0_PCTL_DFIODTRANKMAP       0xc800024c
+#define  P_DDR0_PCTL_DFIODTCFG       0xc8000244
+#define  P_DDR0_PCTL_DFITPHYWRLAT       0xc8000254
+#define  P_DDR0_PCTL_DFITPHYWRDATA       0xc8000250
+#define  P_DDR0_PCTL_DFITRDDATAEN       0xc8000260
+#define  P_DDR0_PCTL_DFITPHYRDLAT       0xc8000264
+#define  P_DDR0_PCTL_DFITREFMSKI       0xc8000294
+#define  P_DDR0_PCTL_DFITPHYUPDTYPE0       0xc8000270
+#define  P_DDR0_PCTL_DFITPHYUPDTYPE1       0xc8000274
+#define  P_DDR0_PCTL_DFITCTRLUPDDLY       0xc8000288
+#define  P_DDR0_PCTL_DFITPHYUPDTYPE2       0xc8000278
+#define  P_DDR0_PCTL_DFITCTRLUPDMIN       0xc8000280
+#define  P_DDR0_PCTL_DFITPHYUPDTYPE3       0xc800027c
+#define  P_DDR0_PCTL_DFIUPDCFG       0xc8000290
+#define  P_DDR0_PCTL_DFITCTRLUPDMAX       0xc8000284
+#define  P_DDR0_PCTL_DFITCTRLUPDI       0xc8000298
+#define  P_DDR0_PCTL_DFITRRDLVLEN       0xc80002b8
+#define  P_DDR0_PCTL_DFITRSTAT0       0xc80002b0
+#define  P_DDR0_PCTL_DFITRWRLVLEN       0xc80002b4
+#define  P_DDR0_PCTL_DFITRCFG0       0xc80002ac
+#define  P_DDR0_PCTL_DFITRRDLVLGATEEN       0xc80002bc
+#define  P_DDR0_PCTL_DFISTSTAT0       0xc80002c0
+#define  P_DDR0_PCTL_DFISTPARLOG       0xc80002e0
+#define  P_DDR0_PCTL_DFITDRAMCLKEN       0xc80002d0
+#define  P_DDR0_PCTL_DFISTPARCLR       0xc80002dc
+#define  P_DDR0_PCTL_DFISTCFG0       0xc80002c4
+#define  P_DDR0_PCTL_DFISTCFG1       0xc80002c8
+#define  P_DDR0_PCTL_DFISTCFG2       0xc80002d8
+#define  P_DDR0_PCTL_DFITDRAMCLKDIS       0xc80002d4
+#define  P_DDR0_PCTL_DFILPCFG0       0xc80002f0
+#define  P_DDR0_PCTL_DFITRWRLVLDELAY0       0xc8000318
+#define  P_DDR0_PCTL_DFITRWRLVLDELAY1       0xc800031c
+#define  P_DDR0_PCTL_DFITRWRLVLDELAY2       0xc8000320
+#define  P_DDR0_PCTL_DFITRRDLVLRESP0       0xc800030c
+#define  P_DDR0_PCTL_DFITRRDLVLRESP1       0xc8000310
+#define  P_DDR0_PCTL_DFITRRDLVLRESP2       0xc8000314
+#define  P_DDR0_PCTL_DFITRWRLVLRESP0       0xc8000300
+#define  P_DDR0_PCTL_DFITRRDLVLDELAY0       0xc8000324
+#define  P_DDR0_PCTL_DFITRRDLVLDELAY1       0xc8000328
+#define  P_DDR0_PCTL_DFITRWRLVLRESP1       0xc8000304
+#define  P_DDR0_PCTL_DFITRRDLVLDELAY2       0xc800032c
+#define  P_DDR0_PCTL_DFITRWRLVLRESP2       0xc8000308
+#define  P_DDR0_PCTL_DFITRRDLVLGATEDELAY0       0xc8000330
+#define  P_DDR0_PCTL_DFITRCMD       0xc800033c
+#define  P_DDR0_PCTL_DFITRRDLVLGATEDELAY1       0xc8000334
+#define  P_DDR0_PCTL_DFITRRDLVLGATEDELAY2       0xc8000338
+#define  P_DDR0_PCTL_IPTR       0xc80003fc
+#define  P_DDR0_PCTL_IPVR       0xc80003f8
+
+ 
+#define  P_DDR0_PUB_RIDR               0xc8001000 + (0x00 << 2)
+#define  P_DDR0_PUB_PIR                0xc8001000 + (0x01 << 2)
+#define  P_DDR0_PUB_PGCR0              0xc8001000 + (0x02 << 2)
+#define  P_DDR0_PUB_PGCR1              0xc8001000 + (0x03 << 2)
+#define  P_DDR0_PUB_PGCR2              0xc8001000 + (0x04 << 2)
+#define  P_DDR0_PUB_PGCR3              0xc8001000 + (0x05 << 2)
+#define  P_DDR0_PUB_PGSR0              0xc8001000 + (0x06 << 2) 
+#define  P_DDR0_PUB_PGSR1              0xc8001000 + (0x07 << 2) 
+#define  P_DDR0_PUB_PLLCR              0xc8001000 + (0x08 << 2) 
+#define  P_DDR0_PUB_PTR0               0xc8001000 + (0x09 << 2) 
+#define  P_DDR0_PUB_PTR1               0xc8001000 + (0x0A << 2) 
+#define  P_DDR0_PUB_PTR2               0xc8001000 + (0x0B << 2) 
+#define  P_DDR0_PUB_PTR3               0xc8001000 + (0x0C << 2) 
+#define  P_DDR0_PUB_PTR4               0xc8001000 + (0x0D << 2) 
+#define  P_DDR0_PUB_ACMDLR             0xc8001000 + (0x0E << 2) 
+#define  P_DDR0_PUB_ACLCDLR            0xc8001000 + (0x0F << 2)
+#define  P_DDR0_PUB_ACBDLR0            0xc8001000 + (0x10 << 2)
+#define  P_DDR0_PUB_ACBDLR1            0xc8001000 + (0x11 << 2)
+#define  P_DDR0_PUB_ACBDLR2            0xc8001000 + (0x12 << 2)
+#define  P_DDR0_PUB_ACBDLR3            0xc8001000 + (0x13 << 2)
+#define  P_DDR0_PUB_ACBDLR4            0xc8001000 + (0x14 << 2)
+#define  P_DDR0_PUB_ACBDLR5            0xc8001000 + (0x15 << 2)
+#define  P_DDR0_PUB_ACBDLR6            0xc8001000 + (0x16 << 2)
+#define  P_DDR0_PUB_ACBDLR7            0xc8001000 + (0x17 << 2)
+#define  P_DDR0_PUB_ACBDLR8            0xc8001000 + (0x18 << 2)
+#define  P_DDR0_PUB_ACBDLR9            0xc8001000 + (0x19 << 2)
+#define  P_DDR0_PUB_ACIOCR0            0xc8001000 + (0x1A << 2)
+#define  P_DDR0_PUB_ACIOCR1            0xc8001000 + (0x1B << 2)
+#define  P_DDR0_PUB_ACIOCR2            0xc8001000 + (0x1C << 2)
+#define  P_DDR0_PUB_ACIOCR3            0xc8001000 + (0x1D << 2)
+#define  P_DDR0_PUB_ACIOCR4            0xc8001000 + (0x1E << 2)
+#define  P_DDR0_PUB_ACIOCR5            0xc8001000 + (0x1F << 2)
+#define  P_DDR0_PUB_DXCCR              0xc8001000 + (0x20 << 2) 
+#define  P_DDR0_PUB_DSGCR              0xc8001000 + (0x21 << 2) 
+#define  P_DDR0_PUB_DCR                0xc8001000 + (0x22 << 2) 
+#define  P_DDR0_PUB_DTPR0              0xc8001000 + (0x23 << 2) 
+#define  P_DDR0_PUB_DTPR1              0xc8001000 + (0x24 << 2) 
+#define  P_DDR0_PUB_DTPR2              0xc8001000 + (0x25 << 2) 
+#define  P_DDR0_PUB_DTPR3              0xc8001000 + (0x26 << 2)
+#define  P_DDR0_PUB_MR0                0xc8001000 + (0x27 << 2) 
+#define  P_DDR0_PUB_MR1                0xc8001000 + (0x28 << 2) 
+#define  P_DDR0_PUB_MR2                0xc8001000 + (0x29 << 2) 
+#define  P_DDR0_PUB_MR3                0xc8001000 + (0x2A << 2) 
+#define  P_DDR0_PUB_ODTCR              0xc8001000 + (0x2B << 2) 
+#define  P_DDR0_PUB_DTCR               0xc8001000 + (0x2C << 2) 
+#define  P_DDR0_PUB_DTAR0              0xc8001000 + (0x2D << 2) 
+#define  P_DDR0_PUB_DTAR1              0xc8001000 + (0x2E << 2) 
+#define  P_DDR0_PUB_DTAR2              0xc8001000 + (0x2F << 2) 
+#define  P_DDR0_PUB_DTAR3              0xc8001000 + (0x30 << 2) 
+#define  P_DDR0_PUB_DTDR0              0xc8001000 + (0x31 << 2) 
+#define  P_DDR0_PUB_DTDR1              0xc8001000 + (0x32 << 2) 
+#define  P_DDR0_PUB_DTEDR0             0xc8001000 + (0x33 << 2) 
+#define  P_DDR0_PUB_DTEDR1             0xc8001000 + (0x34 << 2) 
+#define  P_DDR0_PUB_RDIMMGCR0          0xc8001000 + (0x35 << 2) 
+#define  P_DDR0_PUB_RDIMMGCR1          0xc8001000 + (0x36 << 2) 
+#define  P_DDR0_PUB_RDIMMCR0           0xc8001000 + (0x37 << 2) 
+#define  P_DDR0_PUB_RDIMMCR1           0xc8001000 + (0x38 << 2) 
+#define  P_DDR0_PUB_GPR0               0xc8001000 + (0x39 << 2) 
+#define  P_DDR0_PUB_GPR1               0xc8001000 + (0x3A << 2) 
+#define  P_DDR0_PUB_CATR0              0xc8001000 + (0x3B << 2) 
+#define  P_DDR0_PUB_CATR1              0xc8001000 + (0x3C << 2) 
+//0x3D-0x5F reserved
+#define  P_DDR0_PUB_DCUAR              0xc8001000 + (0x60 << 2) 
+#define  P_DDR0_PUB_DCUDR              0xc8001000 + (0x61 << 2) 
+#define  P_DDR0_PUB_DCURR              0xc8001000 + (0x62 << 2) 
+#define  P_DDR0_PUB_DCULR              0xc8001000 + (0x63 << 2) 
+#define  P_DDR0_PUB_DCUGCR             0xc8001000 + (0x64 << 2) 
+#define  P_DDR0_PUB_DCUTPR             0xc8001000 + (0x65 << 2) 
+#define  P_DDR0_PUB_DCUSR0             0xc8001000 + (0x66 << 2) 
+#define  P_DDR0_PUB_DCUSR1             0xc8001000 + (0x67 << 2)
+//0x68-0x6F reserved 
+#define  P_DDR0_PUB_BISTRR             0xc8001000 + (0x70 << 2) 
+#define  P_DDR0_PUB_BISTWCR            0xc8001000 + (0x71 << 2) 
+#define  P_DDR0_PUB_BISTMSKR0          0xc8001000 + (0x72 << 2) 
+#define  P_DDR0_PUB_BISTMSKR1          0xc8001000 + (0x73 << 2) 
+#define  P_DDR0_PUB_BISTMSKR2          0xc8001000 + (0x74 << 2) 
+#define  P_DDR0_PUB_BISTLSR            0xc8001000 + (0x75 << 2) 
+#define  P_DDR0_PUB_BISTAR0            0xc8001000 + (0x76 << 2) 
+#define  P_DDR0_PUB_BISTAR1            0xc8001000 + (0x77 << 2) 
+#define  P_DDR0_PUB_BISTAR2            0xc8001000 + (0x78 << 2) 
+#define  P_DDR0_PUB_BISTUDPR           0xc8001000 + (0x79 << 2) 
+#define  P_DDR0_PUB_BISTGSR            0xc8001000 + (0x7A << 2) 
+#define  P_DDR0_PUB_BISTWER            0xc8001000 + (0x7B << 2) 
+#define  P_DDR0_PUB_BISTBER0           0xc8001000 + (0x7C << 2) 
+#define  P_DDR0_PUB_BISTBER1           0xc8001000 + (0x7D << 2) 
+#define  P_DDR0_PUB_BISTBER2           0xc8001000 + (0x7E << 2) 
+#define  P_DDR0_PUB_BISTBER3           0xc8001000 + (0x7F << 2) 
+#define  P_DDR0_PUB_BISTWCSR           0xc8001000 + (0x80 << 2) 
+#define  P_DDR0_PUB_BISTFWR0           0xc8001000 + (0x81 << 2) 
+#define  P_DDR0_PUB_BISTFWR1           0xc8001000 + (0x82 << 2) 
+#define  P_DDR0_PUB_BISTFWR2           0xc8001000 + (0x83 << 2)
+//0x84-0x8D reserved 
+#define  P_DDR0_PUB_IOVCR0             0xc8001000 + (0x8E << 2)
+#define  P_DDR0_PUB_IOVCR1             0xc8001000 + (0x8F << 2)
+#define  P_DDR0_PUB_ZQCR               0xc8001000 + (0x90 << 2)
+#define  P_DDR0_PUB_ZQ0PR              0xc8001000 + (0x91 << 2)
+#define  P_DDR0_PUB_ZQ0DR              0xc8001000 + (0x92 << 2)
+#define  P_DDR0_PUB_ZQ0SR              0xc8001000 + (0x93 << 2)
+//0x94 reserved
+#define  P_DDR0_PUB_ZQ1PR              0xc8001000 + (0x95 << 2)
+#define  P_DDR0_PUB_ZQ1DR              0xc8001000 + (0x96 << 2)
+#define  P_DDR0_PUB_ZQ1SR              0xc8001000 + (0x97 << 2)
+//0x98 reserved
+#define  P_DDR0_PUB_ZQ2PR              0xc8001000 + (0x99 << 2)
+#define  P_DDR0_PUB_ZQ2DR              0xc8001000 + (0x9A << 2)
+#define  P_DDR0_PUB_ZQ2SR              0xc8001000 + (0x9B << 2)
+//0x9c reserved
+#define  P_DDR0_PUB_ZQ3PR              0xc8001000 + (0x9D << 2)
+#define  P_DDR0_PUB_ZQ3DR              0xc8001000 + (0x9E << 2)
+#define  P_DDR0_PUB_ZQ3SR              0xc8001000 + (0x9F << 2)
+#define  P_DDR0_PUB_DX0GCR0            0xc8001000 + (0xA0 << 2) 
+#define  P_DDR0_PUB_DX0GCR1            0xc8001000 + (0xA1 << 2) 
+#define  P_DDR0_PUB_DX0GCR2            0xc8001000 + (0xA2 << 2) 
+#define  P_DDR0_PUB_DX0GCR3            0xc8001000 + (0xA3 << 2) 
+#define  P_DDR0_PUB_DX0GSR0            0xc8001000 + (0xA4 << 2) 
+#define  P_DDR0_PUB_DX0GSR1            0xc8001000 + (0xA5 << 2) 
+#define  P_DDR0_PUB_DX0GSR2            0xc8001000 + (0xA6 << 2)
+#define  P_DDR0_PUB_DX0BDLR0           0xc8001000 + (0xA7 << 2) 
+#define  P_DDR0_PUB_DX0BDLR1           0xc8001000 + (0xA8 << 2) 
+#define  P_DDR0_PUB_DX0BDLR2           0xc8001000 + (0xA9 << 2) 
+#define  P_DDR0_PUB_DX0BDLR3           0xc8001000 + (0xAA << 2) 
+#define  P_DDR0_PUB_DX0BDLR4           0xc8001000 + (0xAB << 2) 
+#define  P_DDR0_PUB_DX0BDLR5           0xc8001000 + (0xAC << 2)
+#define  P_DDR0_PUB_DX0BDLR6           0xc8001000 + (0xAD << 2)
+#define  P_DDR0_PUB_DX0LCDLR0          0xc8001000 + (0xAE << 2) 
+#define  P_DDR0_PUB_DX0LCDLR1          0xc8001000 + (0xAF << 2) 
+#define  P_DDR0_PUB_DX0LCDLR2          0xc8001000 + (0xB0 << 2) 
+#define  P_DDR0_PUB_DX0MDLR            0xc8001000 + (0xB1 << 2) 
+#define  P_DDR0_PUB_DX0GTR             0xc8001000 + (0xB2 << 2) 
+//0xB4-0xBF reserved
+#define  P_DDR0_PUB_DX1GCR0           0xc8001000 + (0xC0 << 2) 
+#define  P_DDR0_PUB_DX1GCR1           0xc8001000 + (0xC1 << 2) 
+#define  P_DDR0_PUB_DX1GCR2           0xc8001000 + (0xC2 << 2) 
+#define  P_DDR0_PUB_DX1GCR3           0xc8001000 + (0xC3 << 2) 
+#define  P_DDR0_PUB_DX1GSR0           0xc8001000 + (0xC4 << 2) 
+#define  P_DDR0_PUB_DX1GSR1           0xc8001000 + (0xC5 << 2) 
+#define  P_DDR0_PUB_DX1GSR2           0xc8001000 + (0xC6 << 2)
+#define  P_DDR0_PUB_DX1BDLR0          0xc8001000 + (0xC7 << 2) 
+#define  P_DDR0_PUB_DX1BDLR1          0xc8001000 + (0xC8 << 2) 
+#define  P_DDR0_PUB_DX1BDLR2          0xc8001000 + (0xC9 << 2) 
+#define  P_DDR0_PUB_DX1BDLR3          0xc8001000 + (0xCA << 2) 
+#define  P_DDR0_PUB_DX1BDLR4          0xc8001000 + (0xCB << 2) 
+#define  P_DDR0_PUB_DX1BDLR5           0xc8001000 + (0xCC << 2)
+#define  P_DDR0_PUB_DX1BDLR6           0xc8001000 + (0xCD << 2)
+#define  P_DDR0_PUB_DX1LCDLR0         0xc8001000 + (0xCE << 2) 
+#define  P_DDR0_PUB_DX1LCDLR1         0xc8001000 + (0xCF << 2) 
+#define  P_DDR0_PUB_DX1LCDLR2         0xc8001000 + (0xD0 << 2) 
+#define  P_DDR0_PUB_DX1MDLR           0xc8001000 + (0xD1 << 2) 
+#define  P_DDR0_PUB_DX1GTR            0xc8001000 + (0xD2 << 2) 
+#define  P_DDR0_PUB_DX2GCR0           0xc8001000 + (0xE0 << 2) 
+#define  P_DDR0_PUB_DX2GCR1           0xc8001000 + (0xE1 << 2) 
+#define  P_DDR0_PUB_DX2GCR2           0xc8001000 + (0xE2 << 2) 
+#define  P_DDR0_PUB_DX2GCR3           0xc8001000 + (0xE3 << 2) 
+#define  P_DDR0_PUB_DX2GSR0           0xc8001000 + (0xE4 << 2) 
+#define  P_DDR0_PUB_DX2GSR1           0xc8001000 + (0xE5 << 2) 
+#define  P_DDR0_PUB_DX2GSR2           0xc8001000 + (0xE6 << 2)
+#define  P_DDR0_PUB_DX2BDLR0          0xc8001000 + (0xE7 << 2) 
+#define  P_DDR0_PUB_DX2BDLR1          0xc8001000 + (0xE8 << 2) 
+#define  P_DDR0_PUB_DX2BDLR2          0xc8001000 + (0xE9 << 2) 
+#define  P_DDR0_PUB_DX2BDLR3          0xc8001000 + (0xEA << 2) 
+#define  P_DDR0_PUB_DX2BDLR4          0xc8001000 + (0xEB << 2) 
+#define  P_DDR0_PUB_DX2BDLR5          0xc8001000 + (0xEC << 2)
+#define  P_DDR0_PUB_DX2BDLR6          0xc8001000 + (0xED << 2)
+#define  P_DDR0_PUB_DX2LCDLR0         0xc8001000 + (0xEE << 2) 
+#define  P_DDR0_PUB_DX2LCDLR1         0xc8001000 + (0xEF << 2) 
+#define  P_DDR0_PUB_DX2LCDLR2         0xc8001000 + (0xF0 << 2) 
+#define  P_DDR0_PUB_DX2MDLR           0xc8001000 + (0xF1 << 2) 
+#define  P_DDR0_PUB_DX2GTR            0xc8001000 + (0xF2 << 2) 
+#define  P_DDR0_PUB_DX3GCR0           0xc8001000 + (0x100 << 2) 
+#define  P_DDR0_PUB_DX3GCR1           0xc8001000 + (0x101 << 2) 
+#define  P_DDR0_PUB_DX3GCR2           0xc8001000 + (0x102 << 2) 
+#define  P_DDR0_PUB_DX3GCR3           0xc8001000 + (0x103 << 2) 
+#define  P_DDR0_PUB_DX3GSR0           0xc8001000 + (0x104 << 2) 
+#define  P_DDR0_PUB_DX3GSR1           0xc8001000 + (0x105 << 2) 
+#define  P_DDR0_PUB_DX3GSR2           0xc8001000 + (0x106 << 2)
+#define  P_DDR0_PUB_DX3BDLR0          0xc8001000 + (0x107 << 2) 
+#define  P_DDR0_PUB_DX3BDLR1          0xc8001000 + (0x108 << 2) 
+#define  P_DDR0_PUB_DX3BDLR2          0xc8001000 + (0x109 << 2) 
+#define  P_DDR0_PUB_DX3BDLR3          0xc8001000 + (0x10A << 2) 
+#define  P_DDR0_PUB_DX3BDLR4          0xc8001000 + (0x10B << 2) 
+#define  P_DDR0_PUB_DX3BDLR5          0xc8001000 + (0x10C << 2)
+#define  P_DDR0_PUB_DX3BDLR6          0xc8001000 + (0x10D << 2)
+#define  P_DDR0_PUB_DX3LCDLR0         0xc8001000 + (0x10E << 2) 
+#define  P_DDR0_PUB_DX3LCDLR1         0xc8001000 + (0x10F << 2) 
+#define  P_DDR0_PUB_DX3LCDLR2         0xc8001000 + (0x110 << 2) 
+#define  P_DDR0_PUB_DX3MDLR           0xc8001000 + (0x111 << 2) 
+#define  P_DDR0_PUB_DX3GTR            0xc8001000 + (0x112 << 2) 
+#define  P_DDR0_PUB_DX4GCR0           0xc8001000 + (0x120 << 2) 
+#define  P_DDR0_PUB_DX4GCR1           0xc8001000 + (0x121 << 2) 
+#define  P_DDR0_PUB_DX4GCR2           0xc8001000 + (0x122 << 2) 
+#define  P_DDR0_PUB_DX4GCR3           0xc8001000 + (0x123 << 2) 
+#define  P_DDR0_PUB_DX4GSR0           0xc8001000 + (0x124 << 2) 
+#define  P_DDR0_PUB_DX4GSR1           0xc8001000 + (0x125 << 2) 
+#define  P_DDR0_PUB_DX4GSR2           0xc8001000 + (0x126 << 2)
+#define  P_DDR0_PUB_DX4BDLR0          0xc8001000 + (0x127 << 2) 
+#define  P_DDR0_PUB_DX4BDLR1          0xc8001000 + (0x128 << 2) 
+#define  P_DDR0_PUB_DX4BDLR2          0xc8001000 + (0x129 << 2) 
+#define  P_DDR0_PUB_DX4BDLR3          0xc8001000 + (0x12A << 2) 
+#define  P_DDR0_PUB_DX4BDLR4          0xc8001000 + (0x12B << 2) 
+#define  P_DDR0_PUB_DX4BDLR5          0xc8001000 + (0x12C << 2)
+#define  P_DDR0_PUB_DX4BDLR6          0xc8001000 + (0x12D << 2)
+#define  P_DDR0_PUB_DX4LCDLR0         0xc8001000 + (0x12E << 2) 
+#define  P_DDR0_PUB_DX4LCDLR1         0xc8001000 + (0x12F << 2) 
+#define  P_DDR0_PUB_DX4LCDLR2         0xc8001000 + (0x130 << 2) 
+#define  P_DDR0_PUB_DX4MDLR           0xc8001000 + (0x131 << 2) 
+#define  P_DDR0_PUB_DX4GTR            0xc8001000 + (0x132 << 2) 
+#define  P_DDR0_PUB_DX5GCR0           0xc8001000 + (0x140 << 2) 
+#define  P_DDR0_PUB_DX5GCR1           0xc8001000 + (0x141 << 2) 
+#define  P_DDR0_PUB_DX5GCR2           0xc8001000 + (0x142 << 2) 
+#define  P_DDR0_PUB_DX5GCR3           0xc8001000 + (0x143 << 2) 
+#define  P_DDR0_PUB_DX5GSR0           0xc8001000 + (0x144 << 2) 
+#define  P_DDR0_PUB_DX5GSR1           0xc8001000 + (0x145 << 2) 
+#define  P_DDR0_PUB_DX5GSR2           0xc8001000 + (0x146 << 2)
+#define  P_DDR0_PUB_DX5BDLR0          0xc8001000 + (0x147 << 2) 
+#define  P_DDR0_PUB_DX5BDLR1          0xc8001000 + (0x148 << 2) 
+#define  P_DDR0_PUB_DX5BDLR2          0xc8001000 + (0x149 << 2) 
+#define  P_DDR0_PUB_DX5BDLR3          0xc8001000 + (0x14A << 2) 
+#define  P_DDR0_PUB_DX5BDLR4          0xc8001000 + (0x14B << 2) 
+#define  P_DDR0_PUB_DX5BDLR5          0xc8001000 + (0x14C << 2)
+#define  P_DDR0_PUB_DX5BDLR6          0xc8001000 + (0x14D << 2)
+#define  P_DDR0_PUB_DX5LCDLR0         0xc8001000 + (0x14E << 2) 
+#define  P_DDR0_PUB_DX5LCDLR1         0xc8001000 + (0x14F << 2) 
+#define  P_DDR0_PUB_DX5LCDLR2         0xc8001000 + (0x150 << 2) 
+#define  P_DDR0_PUB_DX5MDLR           0xc8001000 + (0x151 << 2) 
+#define  P_DDR0_PUB_DX5GTR            0xc8001000 + (0x152 << 2) 
+#define  P_DDR0_PUB_DX6GCR0           0xc8001000 + (0x160 << 2) 
+#define  P_DDR0_PUB_DX6GCR1           0xc8001000 + (0x161 << 2) 
+#define  P_DDR0_PUB_DX6GCR2           0xc8001000 + (0x162 << 2) 
+#define  P_DDR0_PUB_DX6GCR3           0xc8001000 + (0x163 << 2) 
+#define  P_DDR0_PUB_DX6GSR0           0xc8001000 + (0x164 << 2) 
+#define  P_DDR0_PUB_DX6GSR1           0xc8001000 + (0x165 << 2) 
+#define  P_DDR0_PUB_DX6GSR2           0xc8001000 + (0x166 << 2)
+#define  P_DDR0_PUB_DX6BDLR0          0xc8001000 + (0x167 << 2) 
+#define  P_DDR0_PUB_DX6BDLR1          0xc8001000 + (0x168 << 2) 
+#define  P_DDR0_PUB_DX6BDLR2          0xc8001000 + (0x169 << 2) 
+#define  P_DDR0_PUB_DX6BDLR3          0xc8001000 + (0x16A << 2) 
+#define  P_DDR0_PUB_DX6BDLR4          0xc8001000 + (0x16B << 2) 
+#define  P_DDR0_PUB_DX6BDLR5          0xc8001000 + (0x16C << 2)
+#define  P_DDR0_PUB_DX6BDLR6          0xc8001000 + (0x16D << 2)
+#define  P_DDR0_PUB_DX6LCDLR0         0xc8001000 + (0x16E << 2) 
+#define  P_DDR0_PUB_DX6LCDLR1         0xc8001000 + (0x16F << 2) 
+#define  P_DDR0_PUB_DX6LCDLR2         0xc8001000 + (0x170 << 2) 
+#define  P_DDR0_PUB_DX6MDLR           0xc8001000 + (0x171 << 2) 
+#define  P_DDR0_PUB_DX6GTR            0xc8001000 + (0x172 << 2) 
+#define  P_DDR0_PUB_DX7GCR0           0xc8001000 + (0x180 << 2) 
+#define  P_DDR0_PUB_DX7GCR1           0xc8001000 + (0x181 << 2) 
+#define  P_DDR0_PUB_DX7GCR2           0xc8001000 + (0x182 << 2) 
+#define  P_DDR0_PUB_DX7GCR3           0xc8001000 + (0x183 << 2) 
+#define  P_DDR0_PUB_DX7GSR0           0xc8001000 + (0x184 << 2) 
+#define  P_DDR0_PUB_DX7GSR1           0xc8001000 + (0x185 << 2) 
+#define  P_DDR0_PUB_DX7GSR2           0xc8001000 + (0x186 << 2)
+#define  P_DDR0_PUB_DX7BDLR0          0xc8001000 + (0x187 << 2) 
+#define  P_DDR0_PUB_DX7BDLR1          0xc8001000 + (0x188 << 2) 
+#define  P_DDR0_PUB_DX7BDLR2          0xc8001000 + (0x189 << 2) 
+#define  P_DDR0_PUB_DX7BDLR3          0xc8001000 + (0x18A << 2) 
+#define  P_DDR0_PUB_DX7BDLR4          0xc8001000 + (0x18B << 2) 
+#define  P_DDR0_PUB_DX7BDLR5          0xc8001000 + (0x18C << 2)
+#define  P_DDR0_PUB_DX7BDLR6          0xc8001000 + (0x18D << 2)
+#define  P_DDR0_PUB_DX7LCDLR0         0xc8001000 + (0x18E << 2) 
+#define  P_DDR0_PUB_DX7LCDLR1         0xc8001000 + (0x18F << 2) 
+#define  P_DDR0_PUB_DX7LCDLR2         0xc8001000 + (0x190 << 2) 
+#define  P_DDR0_PUB_DX7MDLR           0xc8001000 + (0x191 << 2) 
+#define  P_DDR0_PUB_DX7GTR            0xc8001000 + (0x192 << 2) 
+#define  P_DDR0_PUB_DX8GCR0           0xc8001000 + (0x1A0 << 2) 
+#define  P_DDR0_PUB_DX8GCR1           0xc8001000 + (0x1A1 << 2) 
+#define  P_DDR0_PUB_DX8GCR2           0xc8001000 + (0x1A2 << 2) 
+#define  P_DDR0_PUB_DX8GCR3           0xc8001000 + (0x1A3 << 2) 
+#define  P_DDR0_PUB_DX8GSR0           0xc8001000 + (0x1A4 << 2) 
+#define  P_DDR0_PUB_DX8GSR1           0xc8001000 + (0x1A5 << 2) 
+#define  P_DDR0_PUB_DX8GSR2           0xc8001000 + (0x1A6 << 2)
+#define  P_DDR0_PUB_DX8BDLR0          0xc8001000 + (0x1A7 << 2)
+#define  P_DDR0_PUB_DX8BDLR1          0xc8001000 + (0x1A8 << 2)
+#define  P_DDR0_PUB_DX8BDLR2          0xc8001000 + (0x1A9 << 2)
+#define  P_DDR0_PUB_DX8BDLR3          0xc8001000 + (0x1AA << 2)
+#define  P_DDR0_PUB_DX8BDLR4          0xc8001000 + (0x1AB << 2)
+#define  P_DDR0_PUB_DX8BDLR5          0xc8001000 + (0x1AC << 2)
+#define  P_DDR0_PUB_DX8BDLR6          0xc8001000 + (0x1AD << 2)
+#define  P_DDR0_PUB_DX8LCDLR0         0xc8001000 + (0x1AE << 2)
+#define  P_DDR0_PUB_DX8LCDLR1         0xc8001000 + (0x1AF << 2)
+#define  P_DDR0_PUB_DX8LCDLR2         0xc8001000 + (0x1B0 << 2)
+#define  P_DDR0_PUB_DX8MDLR           0xc8001000 + (0x1B1 << 2)
+#define  P_DDR0_PUB_DX8GTR            0xc8001000 + (0x1B2 << 2)
+
+
+
+#define  P_DDR1_CLK_CTRL    0xc8002800
+#define  P_DDR1_SOFT_RESET  0xc8002804
+#define  P_DDR1_APD_CTRL    0xc8002808
+
+#define P_DDR1_PCTL_SCFG      0xc8002000
+#define P_DDR1_PCTL_SCTL      0xc8002004
+#define P_DDR1_PCTL_STAT      0xc8002008
+#define P_DDR1_PCTL_INTRSTAT      0xc800200c
+#define P_DDR1_PCTL_POWSTAT      0xc8002048
+#define P_DDR1_PCTL_MRRSTAT0      0xc8002064
+#define P_DDR1_PCTL_CMDTSTAT      0xc800204c
+#define P_DDR1_PCTL_MCMD      0xc8002040
+#define P_DDR1_PCTL_MRRSTAT1      0xc8002068
+#define P_DDR1_PCTL_MRRCFG0      0xc8002060
+#define P_DDR1_PCTL_CMDTSTATEN      0xc8002050
+#define P_DDR1_PCTL_POWCTL      0xc8002044
+#define P_DDR1_PCTL_PPCFG      0xc8002084
+#define P_DDR1_PCTL_LPDDR23ZQCFG      0xc800208c
+#define P_DDR1_PCTL_MCFG1      0xc800207c
+#define P_DDR1_PCTL_MSTAT      0xc8002088
+#define P_DDR1_PCTL_MCFG      0xc8002080
+#define P_DDR1_PCTL_DTUAWDT      0xc80020b0
+#define P_DDR1_PCTL_DTUPRD2      0xc80020a8
+#define P_DDR1_PCTL_DTUPRD3      0xc80020ac
+#define P_DDR1_PCTL_DTUNE      0xc800209c
+#define P_DDR1_PCTL_DTUPDES      0xc8002094
+#define P_DDR1_PCTL_DTUNA      0xc8002098
+#define P_DDR1_PCTL_DTUPRD0      0xc80020a0
+#define P_DDR1_PCTL_DTUPRD1      0xc80020a4
+#define P_DDR1_PCTL_TCKSRE      0xc8002124
+#define P_DDR1_PCTL_TZQCSI      0xc800211c
+#define P_DDR1_PCTL_TINIT      0xc80020c4
+#define P_DDR1_PCTL_TDPD      0xc8002144
+#define P_DDR1_PCTL_TOGCNT1U      0xc80020c0
+#define P_DDR1_PCTL_TCKE      0xc800212c
+#define P_DDR1_PCTL_TMOD      0xc8002130
+#define P_DDR1_PCTL_TEXSR      0xc800210c
+#define P_DDR1_PCTL_TAL      0xc80020e4
+#define P_DDR1_PCTL_TRTP      0xc8002100
+#define P_DDR1_PCTL_TCKSRX      0xc8002128
+#define P_DDR1_PCTL_TRTW      0xc80020e0
+#define P_DDR1_PCTL_TCWL      0xc80020ec
+#define P_DDR1_PCTL_TWR      0xc8002104
+#define P_DDR1_PCTL_TCL      0xc80020e8
+#define P_DDR1_PCTL_TDQS      0xc8002120
+#define P_DDR1_PCTL_TRSTH      0xc80020c8
+#define P_DDR1_PCTL_TRCD      0xc80020f8
+#define P_DDR1_PCTL_TXP      0xc8002110
+#define P_DDR1_PCTL_TOGCNT100N      0xc80020cc
+#define P_DDR1_PCTL_TMRD      0xc80020d4
+#define P_DDR1_PCTL_TRSTL      0xc8002134
+#define P_DDR1_PCTL_TREFI      0xc80020d0
+#define P_DDR1_PCTL_TRAS      0xc80020f0
+#define P_DDR1_PCTL_TREFI_MEM_DDR3      0xc8002148
+#define P_DDR1_PCTL_TWTR      0xc8002108
+#define P_DDR1_PCTL_TRC      0xc80020f4
+#define P_DDR1_PCTL_TRFC      0xc80020d8
+#define P_DDR1_PCTL_TMRR      0xc800213c
+#define P_DDR1_PCTL_TCKESR      0xc8002140
+#define P_DDR1_PCTL_TZQCL      0xc8002138
+#define P_DDR1_PCTL_TRRD      0xc80020fc
+#define P_DDR1_PCTL_TRP      0xc80020dc
+#define P_DDR1_PCTL_TZQCS      0xc8002118
+#define P_DDR1_PCTL_TXPDLL      0xc8002114
+#define P_DDR1_PCTL_ECCCFG      0xc8002180
+#define P_DDR1_PCTL_ECCLOG      0xc800218c
+#define P_DDR1_PCTL_ECCCLR      0xc8002188
+#define P_DDR1_PCTL_ECCTST      0xc8002184
+#define P_DDR1_PCTL_DTUWD0      0xc8002210
+#define P_DDR1_PCTL_DTUWD1      0xc8002214
+#define P_DDR1_PCTL_DTUWACTL      0xc8002200
+#define P_DDR1_PCTL_DTULFSRRD      0xc8002238
+#define P_DDR1_PCTL_DTUWD2      0xc8002218
+#define P_DDR1_PCTL_DTUWD3      0xc800221c
+#define P_DDR1_PCTL_DTULFSRWD      0xc8002234
+#define P_DDR1_PCTL_DTURACTL      0xc8002204
+#define P_DDR1_PCTL_DTUWDM      0xc8002220
+#define P_DDR1_PCTL_DTURD0      0xc8002224
+#define P_DDR1_PCTL_DTURD1      0xc8002228
+#define P_DDR1_PCTL_DTURD2      0xc800222c
+#define P_DDR1_PCTL_DTURD3      0xc8002230
+#define P_DDR1_PCTL_DTUCFG      0xc8002208
+#define P_DDR1_PCTL_DTUEAF      0xc800223c
+#define P_DDR1_PCTL_DTUECTL      0xc800220c
+#define P_DDR1_PCTL_DFIODTCFG1      0xc8002248
+#define P_DDR1_PCTL_DFITCTRLDELAY      0xc8002240
+#define P_DDR1_PCTL_DFIODTRANKMAP      0xc800224c
+#define P_DDR1_PCTL_DFIODTCFG      0xc8002244
+#define P_DDR1_PCTL_DFITPHYWRLAT      0xc8002254
+#define P_DDR1_PCTL_DFITPHYWRDATA      0xc8002250
+#define P_DDR1_PCTL_DFITRDDATAEN      0xc8002260
+#define P_DDR1_PCTL_DFITPHYRDLAT      0xc8002264
+#define P_DDR1_PCTL_DFITREFMSKI      0xc8002294
+#define P_DDR1_PCTL_DFITPHYUPDTYPE0      0xc8002270
+#define P_DDR1_PCTL_DFITPHYUPDTYPE1      0xc8002274
+#define P_DDR1_PCTL_DFITCTRLUPDDLY      0xc8002288
+#define P_DDR1_PCTL_DFITPHYUPDTYPE2      0xc8002278
+#define P_DDR1_PCTL_DFITCTRLUPDMIN      0xc8002280
+#define P_DDR1_PCTL_DFITPHYUPDTYPE3      0xc800227c
+#define P_DDR1_PCTL_DFIUPDCFG      0xc8002290
+#define P_DDR1_PCTL_DFITCTRLUPDMAX      0xc8002284
+#define P_DDR1_PCTL_DFITCTRLUPDI      0xc8002298
+#define P_DDR1_PCTL_DFITRRDLVLEN      0xc80022b8
+#define P_DDR1_PCTL_DFITRSTAT0      0xc80022b0
+#define P_DDR1_PCTL_DFITRWRLVLEN      0xc80022b4
+#define P_DDR1_PCTL_DFITRCFG0      0xc80022ac
+#define P_DDR1_PCTL_DFITRRDLVLGATEEN      0xc80022bc
+#define P_DDR1_PCTL_DFISTSTAT0      0xc80022c0
+#define P_DDR1_PCTL_DFISTPARLOG      0xc80022e0
+#define P_DDR1_PCTL_DFITDRAMCLKEN      0xc80022d0
+#define P_DDR1_PCTL_DFISTPARCLR      0xc80022dc
+#define P_DDR1_PCTL_DFISTCFG0      0xc80022c4
+#define P_DDR1_PCTL_DFISTCFG1      0xc80022c8
+#define P_DDR1_PCTL_DFISTCFG2      0xc80022d8
+#define P_DDR1_PCTL_DFITDRAMCLKDIS      0xc80022d4
+#define P_DDR1_PCTL_DFILPCFG0      0xc80022f0
+#define P_DDR1_PCTL_DFITRWRLVLDELAY0      0xc8002318
+#define P_DDR1_PCTL_DFITRWRLVLDELAY1      0xc800231c
+#define P_DDR1_PCTL_DFITRWRLVLDELAY2      0xc8002320
+#define P_DDR1_PCTL_DFITRRDLVLRESP0      0xc800230c
+#define P_DDR1_PCTL_DFITRRDLVLRESP1      0xc8002310
+#define P_DDR1_PCTL_DFITRRDLVLRESP2      0xc8002314
+#define P_DDR1_PCTL_DFITRWRLVLRESP0      0xc8002300
+#define P_DDR1_PCTL_DFITRRDLVLDELAY0      0xc8002324
+#define P_DDR1_PCTL_DFITRRDLVLDELAY1      0xc8002328
+#define P_DDR1_PCTL_DFITRWRLVLRESP1      0xc8002304
+#define P_DDR1_PCTL_DFITRRDLVLDELAY2      0xc800232c
+#define P_DDR1_PCTL_DFITRWRLVLRESP2      0xc8002308
+#define P_DDR1_PCTL_DFITRRDLVLGATEDELAY0      0xc8002330
+#define P_DDR1_PCTL_DFITRCMD      0xc800233c
+#define P_DDR1_PCTL_DFITRRDLVLGATEDELAY1      0xc8002334
+#define P_DDR1_PCTL_DFITRRDLVLGATEDELAY2      0xc8002338
+#define P_DDR1_PCTL_IPTR      0xc80023fc
+#define P_DDR1_PCTL_IPVR      0xc80023f8
+
+
+#define P_DDR1_PUB_RIDR               0xc8003000 + (0x00 << 2)
+#define P_DDR1_PUB_PIR                0xc8003000 + (0x01 << 2)
+#define P_DDR1_PUB_PGCR0              0xc8003000 + (0x02 << 2)
+#define P_DDR1_PUB_PGCR1              0xc8003000 + (0x03 << 2)
+#define P_DDR1_PUB_PGCR2              0xc8003000 + (0x04 << 2)
+#define P_DDR1_PUB_PGCR3              0xc8003000 + (0x05 << 2)
+#define P_DDR1_PUB_PGSR0              0xc8003000 + (0x06 << 2) 
+#define P_DDR1_PUB_PGSR1              0xc8003000 + (0x07 << 2) 
+#define P_DDR1_PUB_PLLCR              0xc8003000 + (0x08 << 2) 
+#define P_DDR1_PUB_PTR0               0xc8003000 + (0x09 << 2) 
+#define P_DDR1_PUB_PTR1               0xc8003000 + (0x0A << 2) 
+#define P_DDR1_PUB_PTR2               0xc8003000 + (0x0B << 2) 
+#define P_DDR1_PUB_PTR3               0xc8003000 + (0x0C << 2) 
+#define P_DDR1_PUB_PTR4               0xc8003000 + (0x0D << 2) 
+#define P_DDR1_PUB_ACMDLR             0xc8003000 + (0x0E << 2) 
+#define P_DDR1_PUB_ACLCDLR            0xc8003000 + (0x0F << 2)
+#define P_DDR1_PUB_ACBDLR0            0xc8003000 + (0x10 << 2)
+#define P_DDR1_PUB_ACBDLR1            0xc8003000 + (0x11 << 2)
+#define P_DDR1_PUB_ACBDLR2            0xc8003000 + (0x12 << 2)
+#define P_DDR1_PUB_ACBDLR3            0xc8003000 + (0x13 << 2)
+#define P_DDR1_PUB_ACBDLR4            0xc8003000 + (0x14 << 2)
+#define P_DDR1_PUB_ACBDLR5            0xc8003000 + (0x15 << 2)
+#define P_DDR1_PUB_ACBDLR6            0xc8003000 + (0x16 << 2)
+#define P_DDR1_PUB_ACBDLR7            0xc8003000 + (0x17 << 2)
+#define P_DDR1_PUB_ACBDLR8            0xc8003000 + (0x18 << 2)
+#define P_DDR1_PUB_ACBDLR9            0xc8003000 + (0x19 << 2)
+#define P_DDR1_PUB_ACIOCR0            0xc8003000 + (0x1A << 2)
+#define P_DDR1_PUB_ACIOCR1            0xc8003000 + (0x1B << 2)
+#define P_DDR1_PUB_ACIOCR2            0xc8003000 + (0x1C << 2)
+#define P_DDR1_PUB_ACIOCR3            0xc8003000 + (0x1D << 2)
+#define P_DDR1_PUB_ACIOCR4            0xc8003000 + (0x1E << 2)
+#define P_DDR1_PUB_ACIOCR5            0xc8003000 + (0x1F << 2)
+#define P_DDR1_PUB_DXCCR              0xc8003000 + (0x20 << 2) 
+#define P_DDR1_PUB_DSGCR              0xc8003000 + (0x21 << 2) 
+#define P_DDR1_PUB_DCR                0xc8003000 + (0x22 << 2) 
+#define P_DDR1_PUB_DTPR0              0xc8003000 + (0x23 << 2) 
+#define P_DDR1_PUB_DTPR1              0xc8003000 + (0x24 << 2) 
+#define P_DDR1_PUB_DTPR2              0xc8003000 + (0x25 << 2) 
+#define P_DDR1_PUB_DTPR3              0xc8003000 + (0x26 << 2)
+#define P_DDR1_PUB_MR0                0xc8003000 + (0x27 << 2) 
+#define P_DDR1_PUB_MR1                0xc8003000 + (0x28 << 2) 
+#define P_DDR1_PUB_MR2                0xc8003000 + (0x29 << 2) 
+#define P_DDR1_PUB_MR3                0xc8003000 + (0x2A << 2) 
+#define P_DDR1_PUB_ODTCR              0xc8003000 + (0x2B << 2) 
+#define P_DDR1_PUB_DTCR               0xc8003000 + (0x2C << 2) 
+#define P_DDR1_PUB_DTAR0              0xc8003000 + (0x2D << 2) 
+#define P_DDR1_PUB_DTAR1              0xc8003000 + (0x2E << 2) 
+#define P_DDR1_PUB_DTAR2              0xc8003000 + (0x2F << 2) 
+#define P_DDR1_PUB_DTAR3              0xc8003000 + (0x30 << 2) 
+#define P_DDR1_PUB_DTDR0              0xc8003000 + (0x31 << 2) 
+#define P_DDR1_PUB_DTDR1              0xc8003000 + (0x32 << 2) 
+#define P_DDR1_PUB_DTEDR0             0xc8003000 + (0x33 << 2) 
+#define P_DDR1_PUB_DTEDR1             0xc8003000 + (0x34 << 2) 
+#define P_DDR1_PUB_RDIMMGCR0          0xc8003000 + (0x35 << 2) 
+#define P_DDR1_PUB_RDIMMGCR1          0xc8003000 + (0x36 << 2) 
+#define P_DDR1_PUB_RDIMMCR0           0xc8003000 + (0x37 << 2) 
+#define P_DDR1_PUB_RDIMMCR1           0xc8003000 + (0x38 << 2) 
+#define P_DDR1_PUB_GPR0               0xc8003000 + (0x39 << 2) 
+#define P_DDR1_PUB_GPR1               0xc8003000 + (0x3A << 2) 
+#define P_DDR1_PUB_CATR0              0xc8003000 + (0x3B << 2) 
+#define P_DDR1_PUB_CATR1              0xc8003000 + (0x3C << 2) 
+#define P_DDR1_PUB_DCUAR              0xc8003000 + (0x60 << 2) 
+#define P_DDR1_PUB_DCUDR              0xc8003000 + (0x61 << 2) 
+#define P_DDR1_PUB_DCURR              0xc8003000 + (0x62 << 2) 
+#define P_DDR1_PUB_DCULR              0xc8003000 + (0x63 << 2) 
+#define P_DDR1_PUB_DCUGCR             0xc8003000 + (0x64 << 2) 
+#define P_DDR1_PUB_DCUTPR             0xc8003000 + (0x65 << 2) 
+#define P_DDR1_PUB_DCUSR0             0xc8003000 + (0x66 << 2) 
+#define P_DDR1_PUB_DCUSR1             0xc8003000 + (0x67 << 2) 
+#define P_DDR1_PUB_BISTRR             0xc8003000 + (0x70 << 2) 
+#define P_DDR1_PUB_BISTWCR            0xc8003000 + (0x71 << 2) 
+#define P_DDR1_PUB_BISTMSKR0          0xc8003000 + (0x72 << 2) 
+#define P_DDR1_PUB_BISTMSKR1          0xc8003000 + (0x73 << 2) 
+#define P_DDR1_PUB_BISTMSKR2          0xc8003000 + (0x74 << 2) 
+#define P_DDR1_PUB_BISTLSR            0xc8003000 + (0x75 << 2) 
+#define P_DDR1_PUB_BISTAR0            0xc8003000 + (0x76 << 2) 
+#define P_DDR1_PUB_BISTAR1            0xc8003000 + (0x77 << 2) 
+#define P_DDR1_PUB_BISTAR2            0xc8003000 + (0x78 << 2) 
+#define P_DDR1_PUB_BISTUDPR           0xc8003000 + (0x79 << 2) 
+#define P_DDR1_PUB_BISTGSR            0xc8003000 + (0x7A << 2) 
+#define P_DDR1_PUB_BISTWER            0xc8003000 + (0x7B << 2) 
+#define P_DDR1_PUB_BISTBER0           0xc8003000 + (0x7C << 2) 
+#define P_DDR1_PUB_BISTBER1           0xc8003000 + (0x7D << 2) 
+#define P_DDR1_PUB_BISTBER2           0xc8003000 + (0x7E << 2) 
+#define P_DDR1_PUB_BISTBER3           0xc8003000 + (0x7F << 2) 
+#define P_DDR1_PUB_BISTWCSR           0xc8003000 + (0x80 << 2) 
+#define P_DDR1_PUB_BISTFWR0           0xc8003000 + (0x81 << 2) 
+#define P_DDR1_PUB_BISTFWR1           0xc8003000 + (0x82 << 2) 
+#define P_DDR1_PUB_BISTFWR2           0xc8003000 + (0x83 << 2) 
+#define P_DDR1_PUB_IOVCR0             0xc8003000 + (0x8E << 2)
+#define P_DDR1_PUB_IOVCR1             0xc8003000 + (0x8F << 2)
+#define P_DDR1_PUB_ZQCR               0xc8003000 + (0x90 << 2)
+#define P_DDR1_PUB_ZQ0PR              0xc8003000 + (0x91 << 2)
+#define P_DDR1_PUB_ZQ0DR              0xc8003000 + (0x92 << 2)
+#define P_DDR1_PUB_ZQ0SR              0xc8003000 + (0x93 << 2)
+#define P_DDR1_PUB_ZQ1PR              0xc8003000 + (0x95 << 2)
+#define P_DDR1_PUB_ZQ1DR              0xc8003000 + (0x96 << 2)
+#define P_DDR1_PUB_ZQ1SR              0xc8003000 + (0x97 << 2)
+#define P_DDR1_PUB_ZQ2PR              0xc8003000 + (0x99 << 2)
+#define P_DDR1_PUB_ZQ2DR              0xc8003000 + (0x9A << 2)
+#define P_DDR1_PUB_ZQ2SR              0xc8003000 + (0x9B << 2)
+#define P_DDR1_PUB_ZQ3PR              0xc8003000 + (0x9D << 2)
+#define P_DDR1_PUB_ZQ3DR              0xc8003000 + (0x9E << 2)
+#define P_DDR1_PUB_ZQ3SR              0xc8003000 + (0x9F << 2)
+#define P_DDR1_PUB_DX0GCR0            0xc8003000 + (0xA0 << 2) 
+#define P_DDR1_PUB_DX0GCR1            0xc8003000 + (0xA1 << 2) 
+#define P_DDR1_PUB_DX0GCR2            0xc8003000 + (0xA2 << 2) 
+#define P_DDR1_PUB_DX0GCR3            0xc8003000 + (0xA3 << 2) 
+#define P_DDR1_PUB_DX0GSR0            0xc8003000 + (0xA4 << 2) 
+#define P_DDR1_PUB_DX0GSR1            0xc8003000 + (0xA5 << 2) 
+#define P_DDR1_PUB_DX0GSR2            0xc8003000 + (0xA6 << 2)
+#define P_DDR1_PUB_DX0BDLR0           0xc8003000 + (0xA7 << 2) 
+#define P_DDR1_PUB_DX0BDLR1           0xc8003000 + (0xA8 << 2) 
+#define P_DDR1_PUB_DX0BDLR2           0xc8003000 + (0xA9 << 2) 
+#define P_DDR1_PUB_DX0BDLR3           0xc8003000 + (0xAA << 2) 
+#define P_DDR1_PUB_DX0BDLR4           0xc8003000 + (0xAB << 2) 
+#define P_DDR1_PUB_DX0BDLR5           0xc8003000 + (0xAC << 2)
+#define P_DDR1_PUB_DX0BDLR6           0xc8003000 + (0xAD << 2)
+#define P_DDR1_PUB_DX0LCDLR0          0xc8003000 + (0xAE << 2) 
+#define P_DDR1_PUB_DX0LCDLR1          0xc8003000 + (0xAF << 2) 
+#define P_DDR1_PUB_DX0LCDLR2          0xc8003000 + (0xB0 << 2) 
+#define P_DDR1_PUB_DX0MDLR            0xc8003000 + (0xB1 << 2) 
+#define P_DDR1_PUB_DX0GTR             0xc8003000 + (0xB2 << 2) 
+#define P_DDR1_PUB_DX1GCR0           0xc8003000 + (0xC0 << 2) 
+#define P_DDR1_PUB_DX1GCR1           0xc8003000 + (0xC1 << 2) 
+#define P_DDR1_PUB_DX1GCR2           0xc8003000 + (0xC2 << 2) 
+#define P_DDR1_PUB_DX1GCR3           0xc8003000 + (0xC3 << 2) 
+#define P_DDR1_PUB_DX1GSR0           0xc8003000 + (0xC4 << 2) 
+#define P_DDR1_PUB_DX1GSR1           0xc8003000 + (0xC5 << 2) 
+#define P_DDR1_PUB_DX1GSR2           0xc8003000 + (0xC6 << 2)
+#define P_DDR1_PUB_DX1BDLR0          0xc8003000 + (0xC7 << 2) 
+#define P_DDR1_PUB_DX1BDLR1          0xc8003000 + (0xC8 << 2) 
+#define P_DDR1_PUB_DX1BDLR2          0xc8003000 + (0xC9 << 2) 
+#define P_DDR1_PUB_DX1BDLR3          0xc8003000 + (0xCA << 2) 
+#define P_DDR1_PUB_DX1BDLR4          0xc8003000 + (0xCB << 2) 
+#define P_DDR1_PUB_DX1BDLR5           0xc8003000 + (0xCC << 2)
+#define P_DDR1_PUB_DX1BDLR6           0xc8003000 + (0xCD << 2)
+#define P_DDR1_PUB_DX1LCDLR0         0xc8003000 + (0xCE << 2) 
+#define P_DDR1_PUB_DX1LCDLR1         0xc8003000 + (0xCF << 2) 
+#define P_DDR1_PUB_DX1LCDLR2         0xc8003000 + (0xD0 << 2) 
+#define P_DDR1_PUB_DX1MDLR           0xc8003000 + (0xD1 << 2) 
+#define P_DDR1_PUB_DX1GTR            0xc8003000 + (0xD2 << 2) 
+#define P_DDR1_PUB_DX2GCR0           0xc8003000 + (0xE0 << 2) 
+#define P_DDR1_PUB_DX2GCR1           0xc8003000 + (0xE1 << 2) 
+#define P_DDR1_PUB_DX2GCR2           0xc8003000 + (0xE2 << 2) 
+#define P_DDR1_PUB_DX2GCR3           0xc8003000 + (0xE3 << 2) 
+#define P_DDR1_PUB_DX2GSR0           0xc8003000 + (0xE4 << 2) 
+#define P_DDR1_PUB_DX2GSR1           0xc8003000 + (0xE5 << 2) 
+#define P_DDR1_PUB_DX2GSR2           0xc8003000 + (0xE6 << 2)
+#define P_DDR1_PUB_DX2BDLR0          0xc8003000 + (0xE7 << 2) 
+#define P_DDR1_PUB_DX2BDLR1          0xc8003000 + (0xE8 << 2) 
+#define P_DDR1_PUB_DX2BDLR2          0xc8003000 + (0xE9 << 2) 
+#define P_DDR1_PUB_DX2BDLR3          0xc8003000 + (0xEA << 2) 
+#define P_DDR1_PUB_DX2BDLR4          0xc8003000 + (0xEB << 2) 
+#define P_DDR1_PUB_DX2BDLR5          0xc8003000 + (0xEC << 2)
+#define P_DDR1_PUB_DX2BDLR6          0xc8003000 + (0xED << 2)
+#define P_DDR1_PUB_DX2LCDLR0         0xc8003000 + (0xEE << 2) 
+#define P_DDR1_PUB_DX2LCDLR1         0xc8003000 + (0xEF << 2) 
+#define P_DDR1_PUB_DX2LCDLR2         0xc8003000 + (0xF0 << 2) 
+#define P_DDR1_PUB_DX2MDLR           0xc8003000 + (0xF1 << 2) 
+#define P_DDR1_PUB_DX2GTR            0xc8003000 + (0xF2 << 2) 
+#define P_DDR1_PUB_DX3GCR0           0xc8003000 + (0x100 << 2) 
+#define P_DDR1_PUB_DX3GCR1           0xc8003000 + (0x101 << 2) 
+#define P_DDR1_PUB_DX3GCR2           0xc8003000 + (0x102 << 2) 
+#define P_DDR1_PUB_DX3GCR3           0xc8003000 + (0x103 << 2) 
+#define P_DDR1_PUB_DX3GSR0           0xc8003000 + (0x104 << 2) 
+#define P_DDR1_PUB_DX3GSR1           0xc8003000 + (0x105 << 2) 
+#define P_DDR1_PUB_DX3GSR2           0xc8003000 + (0x106 << 2)
+#define P_DDR1_PUB_DX3BDLR0          0xc8003000 + (0x107 << 2) 
+#define P_DDR1_PUB_DX3BDLR1          0xc8003000 + (0x108 << 2) 
+#define P_DDR1_PUB_DX3BDLR2          0xc8003000 + (0x109 << 2) 
+#define P_DDR1_PUB_DX3BDLR3          0xc8003000 + (0x10A << 2) 
+#define P_DDR1_PUB_DX3BDLR4          0xc8003000 + (0x10B << 2) 
+#define P_DDR1_PUB_DX3BDLR5          0xc8003000 + (0x10C << 2)
+#define P_DDR1_PUB_DX3BDLR6          0xc8003000 + (0x10D << 2)
+#define P_DDR1_PUB_DX3LCDLR0         0xc8003000 + (0x10E << 2) 
+#define P_DDR1_PUB_DX3LCDLR1         0xc8003000 + (0x10F << 2) 
+#define P_DDR1_PUB_DX3LCDLR2         0xc8003000 + (0x110 << 2) 
+#define P_DDR1_PUB_DX3MDLR           0xc8003000 + (0x111 << 2) 
+#define P_DDR1_PUB_DX3GTR            0xc8003000 + (0x112 << 2) 
+#define P_DDR1_PUB_DX4GCR0           0xc8003000 + (0x120 << 2) 
+#define P_DDR1_PUB_DX4GCR1           0xc8003000 + (0x121 << 2) 
+#define P_DDR1_PUB_DX4GCR2           0xc8003000 + (0x122 << 2) 
+#define P_DDR1_PUB_DX4GCR3           0xc8003000 + (0x123 << 2) 
+#define P_DDR1_PUB_DX4GSR0           0xc8003000 + (0x124 << 2) 
+#define P_DDR1_PUB_DX4GSR1           0xc8003000 + (0x125 << 2) 
+#define P_DDR1_PUB_DX4GSR2           0xc8003000 + (0x126 << 2)
+#define P_DDR1_PUB_DX4BDLR0          0xc8003000 + (0x127 << 2) 
+#define P_DDR1_PUB_DX4BDLR1          0xc8003000 + (0x128 << 2) 
+#define P_DDR1_PUB_DX4BDLR2          0xc8003000 + (0x129 << 2) 
+#define P_DDR1_PUB_DX4BDLR3          0xc8003000 + (0x12A << 2) 
+#define P_DDR1_PUB_DX4BDLR4          0xc8003000 + (0x12B << 2) 
+#define P_DDR1_PUB_DX4BDLR5          0xc8003000 + (0x12C << 2)
+#define P_DDR1_PUB_DX4BDLR6          0xc8003000 + (0x12D << 2)
+#define P_DDR1_PUB_DX4LCDLR0         0xc8003000 + (0x12E << 2) 
+#define P_DDR1_PUB_DX4LCDLR1         0xc8003000 + (0x12F << 2) 
+#define P_DDR1_PUB_DX4LCDLR2         0xc8003000 + (0x130 << 2) 
+#define P_DDR1_PUB_DX4MDLR           0xc8003000 + (0x131 << 2) 
+#define P_DDR1_PUB_DX4GTR            0xc8003000 + (0x132 << 2) 
+#define P_DDR1_PUB_DX5GCR0           0xc8003000 + (0x140 << 2) 
+#define P_DDR1_PUB_DX5GCR1           0xc8003000 + (0x141 << 2) 
+#define P_DDR1_PUB_DX5GCR2           0xc8003000 + (0x142 << 2) 
+#define P_DDR1_PUB_DX5GCR3           0xc8003000 + (0x143 << 2) 
+#define P_DDR1_PUB_DX5GSR0           0xc8003000 + (0x144 << 2) 
+#define P_DDR1_PUB_DX5GSR1           0xc8003000 + (0x145 << 2) 
+#define P_DDR1_PUB_DX5GSR2           0xc8003000 + (0x146 << 2)
+#define P_DDR1_PUB_DX5BDLR0          0xc8003000 + (0x147 << 2) 
+#define P_DDR1_PUB_DX5BDLR1          0xc8003000 + (0x148 << 2) 
+#define P_DDR1_PUB_DX5BDLR2          0xc8003000 + (0x149 << 2) 
+#define P_DDR1_PUB_DX5BDLR3          0xc8003000 + (0x14A << 2) 
+#define P_DDR1_PUB_DX5BDLR4          0xc8003000 + (0x14B << 2) 
+#define P_DDR1_PUB_DX5BDLR5          0xc8003000 + (0x14C << 2)
+#define P_DDR1_PUB_DX5BDLR6          0xc8003000 + (0x14D << 2)
+#define P_DDR1_PUB_DX5LCDLR0         0xc8003000 + (0x14E << 2) 
+#define P_DDR1_PUB_DX5LCDLR1         0xc8003000 + (0x14F << 2) 
+#define P_DDR1_PUB_DX5LCDLR2         0xc8003000 + (0x150 << 2) 
+#define P_DDR1_PUB_DX5MDLR           0xc8003000 + (0x151 << 2) 
+#define P_DDR1_PUB_DX5GTR            0xc8003000 + (0x152 << 2) 
+#define P_DDR1_PUB_DX6GCR0           0xc8003000 + (0x160 << 2) 
+#define P_DDR1_PUB_DX6GCR1           0xc8003000 + (0x161 << 2) 
+#define P_DDR1_PUB_DX6GCR2           0xc8003000 + (0x162 << 2) 
+#define P_DDR1_PUB_DX6GCR3           0xc8003000 + (0x163 << 2) 
+#define P_DDR1_PUB_DX6GSR0           0xc8003000 + (0x164 << 2) 
+#define P_DDR1_PUB_DX6GSR1           0xc8003000 + (0x165 << 2) 
+#define P_DDR1_PUB_DX6GSR2           0xc8003000 + (0x166 << 2)
+#define P_DDR1_PUB_DX6BDLR0          0xc8003000 + (0x167 << 2) 
+#define P_DDR1_PUB_DX6BDLR1          0xc8003000 + (0x168 << 2) 
+#define P_DDR1_PUB_DX6BDLR2          0xc8003000 + (0x169 << 2) 
+#define P_DDR1_PUB_DX6BDLR3          0xc8003000 + (0x16A << 2) 
+#define P_DDR1_PUB_DX6BDLR4          0xc8003000 + (0x16B << 2) 
+#define P_DDR1_PUB_DX6BDLR5          0xc8003000 + (0x16C << 2)
+#define P_DDR1_PUB_DX6BDLR6          0xc8003000 + (0x16D << 2)
+#define P_DDR1_PUB_DX6LCDLR0         0xc8003000 + (0x16E << 2) 
+#define P_DDR1_PUB_DX6LCDLR1         0xc8003000 + (0x16F << 2) 
+#define P_DDR1_PUB_DX6LCDLR2         0xc8003000 + (0x170 << 2) 
+#define P_DDR1_PUB_DX6MDLR           0xc8003000 + (0x171 << 2) 
+#define P_DDR1_PUB_DX6GTR            0xc8003000 + (0x172 << 2) 
+#define P_DDR1_PUB_DX7GCR0           0xc8003000 + (0x180 << 2) 
+#define P_DDR1_PUB_DX7GCR1           0xc8003000 + (0x181 << 2) 
+#define P_DDR1_PUB_DX7GCR2           0xc8003000 + (0x182 << 2) 
+#define P_DDR1_PUB_DX7GCR3           0xc8003000 + (0x183 << 2) 
+#define P_DDR1_PUB_DX7GSR0           0xc8003000 + (0x184 << 2) 
+#define P_DDR1_PUB_DX7GSR1           0xc8003000 + (0x185 << 2) 
+#define P_DDR1_PUB_DX7GSR2           0xc8003000 + (0x186 << 2)
+#define P_DDR1_PUB_DX7BDLR0          0xc8003000 + (0x187 << 2) 
+#define P_DDR1_PUB_DX7BDLR1          0xc8003000 + (0x188 << 2) 
+#define P_DDR1_PUB_DX7BDLR2          0xc8003000 + (0x189 << 2) 
+#define P_DDR1_PUB_DX7BDLR3          0xc8003000 + (0x18A << 2) 
+#define P_DDR1_PUB_DX7BDLR4          0xc8003000 + (0x18B << 2) 
+#define P_DDR1_PUB_DX7BDLR5          0xc8003000 + (0x18C << 2)
+#define P_DDR1_PUB_DX7BDLR6          0xc8003000 + (0x18D << 2)
+#define P_DDR1_PUB_DX7LCDLR0         0xc8003000 + (0x18E << 2) 
+#define P_DDR1_PUB_DX7LCDLR1         0xc8003000 + (0x18F << 2) 
+#define P_DDR1_PUB_DX7LCDLR2         0xc8003000 + (0x190 << 2) 
+#define P_DDR1_PUB_DX7MDLR           0xc8003000 + (0x191 << 2) 
+#define P_DDR1_PUB_DX7GTR            0xc8003000 + (0x192 << 2) 
+#define P_DDR1_PUB_DX8GCR0           0xc8003000 + (0x1A0 << 2) 
+#define P_DDR1_PUB_DX8GCR1           0xc8003000 + (0x1A1 << 2) 
+#define P_DDR1_PUB_DX8GCR2           0xc8003000 + (0x1A2 << 2) 
+#define P_DDR1_PUB_DX8GCR3           0xc8003000 + (0x1A3 << 2) 
+#define P_DDR1_PUB_DX8GSR0           0xc8003000 + (0x1A4 << 2) 
+#define P_DDR1_PUB_DX8GSR1           0xc8003000 + (0x1A5 << 2) 
+#define P_DDR1_PUB_DX8GSR2           0xc8003000 + (0x1A6 << 2)
+#define P_DDR1_PUB_DX8BDLR0          0xc8003000 + (0x1A7 << 2)
+#define P_DDR1_PUB_DX8BDLR1          0xc8003000 + (0x1A8 << 2)
+#define P_DDR1_PUB_DX8BDLR2          0xc8003000 + (0x1A9 << 2)
+#define P_DDR1_PUB_DX8BDLR3          0xc8003000 + (0x1AA << 2)
+#define P_DDR1_PUB_DX8BDLR4          0xc8003000 + (0x1AB << 2)
+#define P_DDR1_PUB_DX8BDLR5          0xc8003000 + (0x1AC << 2)
+#define P_DDR1_PUB_DX8BDLR6          0xc8003000 + (0x1AD << 2)
+#define P_DDR1_PUB_DX8LCDLR0         0xc8003000 + (0x1AE << 2)
+#define P_DDR1_PUB_DX8LCDLR1         0xc8003000 + (0x1AF << 2)
+#define P_DDR1_PUB_DX8LCDLR2         0xc8003000 + (0x1B0 << 2)
+#define P_DDR1_PUB_DX8MDLR           0xc8003000 + (0x1B1 << 2)
+#define P_DDR1_PUB_DX8GTR            0xc8003000 + (0x1B2 << 2)
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/ucode/dmc_reg.h b/arch/arm/mach-mesong9tv/tools/genregs/ucode/dmc_reg.h
new file mode 100644
index 000000000000..0782b68e1a69
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/ucode/dmc_reg.h
@@ -0,0 +1,378 @@
+#ifndef DMC_REG_DEFINE
+#define DMC_REG_DEFINE
+#define DMC_REG_BASE      0xc8006000
+
+#define MMC_Wr(addr,data) *(volatile unsigned long *) (addr ) = data
+#define MMC_Rd(addr) *(volatile unsigned long *) (addr)
+#define writel(v,c) *(volatile unsigned long *) (c ) = v
+#define readl(c)    *(volatile unsigned long *) (c )
+
+#define DMC_REQ_CTRL        DMC_REG_BASE + (0x00 << 2) 
+  //bit 11.  enable dmc request of chan 11. Audio
+  //bit 10.  enable dmc request of chan 10. Device.
+  //bit 9.   enable dmc request of chan 9.  VDEC2
+  //bit 8.   enable dmc request of chan 8.  HCODEC
+  //bit 7.   enable dmc request of chan 7.  VDEC
+  //bit 6.   enable dmc request of chan 6.  VDIN
+  //bit 5.   enable dmc request of chan 5.  VDISP2
+  //bit 4.   enable dmc request of chan 4.  VDISP
+  //bit 3.   enable dmc request of chan 3.  Mali
+  //bit 2.   enable dmc request of chan 2.  Mali
+  //bit 1.   enable dmc request of chan 1.  Mali
+  //bit 0.   enable dmc request of chan 0.  A9
+#define DMC_SOFT_RST        DMC_REG_BASE + (0x01 << 2)
+#define DMC_SOFT_RST1       DMC_REG_BASE + (0x02 << 2)
+#define DMC_RST_STS         DMC_REG_BASE + (0x03 << 2)
+#define DMC_RST_STS1        DMC_REG_BASE + (0x04 << 2)
+#define DMC_VERSION         DMC_REG_BASE + (0x05 << 2)
+   //read only default = 1.
+
+#define DMC_DDR_CTRL        DMC_REG_BASE + (0x10 << 2) 
+  //bit 27:24.   ddr chanel selection.
+                 //bit 27: 26 : 
+                     //2'b00 : address switch between 2 ddr channel using address bit 12. 
+                            //bit12 = 0 : ddr channel 0.  bit 12 = 1 : ddr channel 1.
+                            //if 2 ddr channel size is different, only switch the lower parts.     
+                     //2'b01 : address switch between 2 ddr channel using address bit 8. 
+                           //bit8 = 0 : ddr channel 0.  bit 8 = 1 : ddr channel 1.
+                           //if 2 ddr channel size is different, only switch the lower parts.     
+                    // 2'b10 : no switch between the 2 channels. use bit 24 as selection which one put lower address. 
+                              //bit 24 = 0:   channel 0 put to the lower address.
+                              //bit 24 = 1:   channel 1 put to the lower address.
+                    // 2'b11 :  all address goes to one DDR channel. use bit 24 to select which one. 
+                              //bit 24 = 0:   use channel 0;
+                              //bit 24 = 1:   use channel 1;
+  //bit 16.       bank page policy. 
+  //bit 13.       ddr1 address map bank mode  1 =  address switch between 4 banks. 0 = address switch between 2 banks.    
+  //bit 12        ddr1 rank size.  0, 1, one rank.  2 : 2 ranks.   
+  //bit 11:10      ddr1 row size.  2'b01 : A0~A12.   2'b10 : A0~A13.  2'b11 : A0~A14.  2'b00 : A0~A15. 
+  //bit 9:8      ddr1 col size.  2'b01 : A0~A8,    2'b10 : A0~A9.  
+  
+  //bit 5.       ddr0 address map bank mode  1 =  address switch between 4 banks. 0 = address switch between 2 banks.    
+  //bit 4        ddr0 rank size.  0, 1, one rank.  2 : 2 ranks.   
+  //bit 3:2      ddr0 row size.  2'b01 : A0~A12.   2'b10 : A0~A13.  2'b11 : A0~A14.  2'b00 : A0~A15. 
+  //bit 1:0      ddr0 col size.  2'b01 : A0~A8,    2'b10 : A0~A9.  
+#define DMC_DDR_CTRL1        DMC_REG_BASE + (0x11 << 2) 
+
+#define DC_CAV_LUT_DATAL          DMC_REG_BASE + (0x12 << 2)
+  //low 32 bits of canvas data which need to be configured to canvas memory. 
+#define DC_CAV_LUT_DATAH          DMC_REG_BASE + (0x13 << 2)
+  //high 32bits of cavnas data which need to be configured to canvas memory.
+#define DC_CAV_LUT_ADDR           DMC_REG_BASE + (0x14 << 2)
+  //bit 9:8.   write 9:8 2'b10. the canvas data will saved in canvas memory with addres 7:0.
+  //bit 7:0.   canvas address.
+#define DC_CAV_LUT_RDATAL          DMC_REG_BASE + (0x15 << 2)
+#define DC_CAV_LUT_RDATAH          DMC_REG_BASE + (0x16 << 2)
+#define DMC_2ARB_CTRL      DMC_REG_BASE + (0x20 << 2)
+
+#define DMC_REFR_CTRL1            DMC_REG_BASE + (0x23 << 2)
+  //bit23:15   tRFC waiting time, when hold nif command after refresh.
+  //bit 9      after refresh, hold nif command enable 
+  //bit 8      when refresh req,  hold nif command enable 
+  //bit 7      dmc to control auto_refresh enable
+  //bit 6:4    refresh number per refresh cycle..
+  //bit 3      pvt enable
+  //bit 2      zqc enable
+  //bit 1      ddr1 auto refresh dmc control select.
+  //bit 0      ddr0 auto refresh dmc control select.
+
+#define DMC_REFR_CTRL2             DMC_REG_BASE + (0x24 << 2) 
+  //bit 31:24   tZQCI
+  //bit 23:16   tPVTI
+  //bit 15:8    tREFI
+  //bit 7:0     t100ns
+
+#define DMC_PARB_CTRL             DMC_REG_BASE + (0x25 << 2) 
+  //bit 17.     default port1(MALI AXI port) urgent bit.
+  //bit 16      default port0(A9 AXI port ) urgent bit.
+  //bit 15:8    t_ugt_gap.   when the consecutive urgent request granted over the t_ugt_wd times, we allow the number of non urgent request was granted by the port arbiter.
+  //bit 7:0.    t_ugt_wd. 
+
+
+#define DMC_MON_CTRL2             DMC_REG_BASE + (0x26 << 2)
+   //bit 31.   qos_mon_en.    write 1 to trigger the enable. polling this bit 0, means finished.  or use interrupt to check finish. 
+   //bit 30.   qos_mon interrupt clear.  clear the qos monitor result.  read 1 = qos mon finish interrupt.
+   //bit 20.   qos_mon_trig_sel.  1 = vsync.  0 = timer. 
+   //bit 19:16.  qos monitor channel select.   select one at one time only.
+   //bit 15:0.   port select for the selected channel.
+#define DMC_MON_CTRL3             DMC_REG_BASE + (0x27 << 2)
+  // qos_mon_clk_timer.   How long to measure the bandwidth.
+
+
+#define DMC_MON_ALL_REQ_CNT       DMC_REG_BASE + (0x28 << 2)
+  // at the test period,  the whole MMC request time.
+#define DMC_MON_ALL_GRANT_CNT     DMC_REG_BASE + (0x29 << 2)
+  // at the test period,  the whole MMC granted data cycles. 64bits unit. 
+#define DMC_MON_ONE_GRANT_CNT     DMC_REG_BASE + (0x2a << 2)
+  // at the test period,  the granted data cycles for the selected channel and ports.
+
+#define DMC_CLKG_CTRL0      DMC_REG_BASE + (0x30 << 2)
+  //bit 28.  enalbe auto clock gating for qos monitor control. 
+  //bit 27.  enalbe auto clock gating for qos control. 
+  //bit 26.  enalbe auto clock gating for ddr1 write rsp generation. 
+  //bit 25.  enalbe auto clock gating for ddr0 write rsp generation. 
+  //bit 24.  enalbe auto clock gating for read rsp generation. 
+  //bit 23.  enalbe auto clock gating for ddr1 read back data buffer. 
+  //bit 22.  enalbe auto clock gating for ddr0 read back data buffer. 
+  //bit 21.  enalbe auto clock gating for ddr1 command filter. 
+  //bit 20.  enalbe auto clock gating for ddr0 command filter. 
+  //bit 19.  enalbe auto clock gating for ddr1 write reorder buffer. 
+  //bit 18.  enalbe auto clock gating for ddr0 write reorder buffer. 
+  //bit 17.  enalbe auto clock gating for ddr1 write data buffer. 
+  //bit 16.  enalbe auto clock gating for ddr0 write data buffer. 
+  //bit 15.  enalbe auto clock gating for ddr1 read reorder buffer. 
+  //bit 14.  enalbe auto clock gating for ddr0 read reorder buffer. 
+  //bit 13.  enalbe auto clock gating for read canvas. 
+  //bit 12.  enalbe auto clock gating for write canvas. 
+  //bit 11.  enalbe auto clock gating for chan 11.
+  //bit 10.  enalbe auto clock gating for chan 11.
+  //bit 9.   enalbe auto clock gating for chan 11.
+  //bit 8.   enalbe auto clock gating for chan 11.
+  //bit 7.   enalbe auto clock gating for chan 11.
+  //bit 6.   enalbe auto clock gating for chan 11.
+  //bit 5.   enalbe auto clock gating for chan 11.
+  //bit 4.   enalbe auto clock gating for chan 11.
+  //bit 3.   enalbe auto clock gating for chan 11.
+  //bit 2.   enalbe auto clock gating for chan 11.
+  //bit 1.   enalbe auto clock gating for chan 11.
+  //bit 0.   enalbe auto clock gating for chan 11.
+#define DMC_CLKG_CTRL1      DMC_REG_BASE + (0x31 << 2)
+  //bit 28.  force to disalbe the clock of qos monitor control. 
+  //bit 27.  force to disalbe the clock of qos control. 
+  //bit 26.  force to disalbe the clock of ddr1 write rsp generation. 
+  //bit 25.  force to disalbe the clock of ddr0 write rsp generation. 
+  //bit 24.  force to disalbe the clock of read rsp generation. 
+  //bit 23.  force to disalbe the clock of ddr1 read back data buffer. 
+  //bit 22.  force to disalbe the clock of ddr0 read back data buffer. 
+  //bit 21.  force to disalbe the clock of ddr1 command filter. 
+  //bit 20.  force to disalbe the clock of ddr0 command filter. 
+  //bit 19.  force to disalbe the clock of ddr1 write reorder buffer. 
+  //bit 18.  force to disalbe the clock of ddr0 write reorder buffer. 
+  //bit 17.  force to disalbe the clock of ddr1 write data buffer. 
+  //bit 16.  force to disalbe the clock of ddr0 write data buffer. 
+  //bit 15.  force to disalbe the clock of ddr1 read reorder buffer. 
+  //bit 14.  force to disalbe the clock of ddr0 read reorder buffer. 
+  //bit 13.  force to disalbe the clock of read canvas. 
+  //bit 12.  force to disalbe the clock of write canvas. 
+  //bit 11.  force to disalbe the clock of chan 11.
+  //bit 10.  force to disalbe the clock of chan 11.
+  //bit 9.   force to disalbe the clock of chan 11.
+  //bit 8.   force to disalbe the clock of chan 11.
+  //bit 7.   force to disalbe the clock of chan 11.
+  //bit 6.   force to disalbe the clock of chan 11.
+  //bit 5.   force to disalbe the clock of chan 11.
+  //bit 4.   force to disalbe the clock of chan 11.
+  //bit 3.   force to disalbe the clock of chan 11.
+  //bit 2.   force to disalbe the clock of chan 11.
+  //bit 1.   force to disalbe the clock of chan 11.
+  //bit 0.   force to disalbe the clock of chan 11.
+
+#define DMC_CHAN_STS            DMC_REG_BASE + (0x32 << 2)
+
+#define DMC_CMD_FILTER_CTRL1 DMC_REG_BASE + (0x40 << 2)
+   //bit 29:20  nugt read buf full access limit
+   //bit 19:10.  ugt read access limit.
+   //bit 9:0  nugt read access limit 
+
+#define DMC_CMD_FILTER_CTRL2 DMC_REG_BASE + (0x41 << 2)
+   //bit 29:20  ugt read buf full access limit
+   //bit 9:0  nugt write access pending limit 
+   //bit 19:10.  ugt write access pending limit.
+
+#define DMC_CMD_FILTER_CTRL3 DMC_REG_BASE + (0x42 << 2)
+  //bit 26:22  wbuf high level number
+  //bit 21:17  wbuf mid  level number
+  //bit 16:12  wbuf low level number
+  //bit 11:8   rbuf high level number
+  //bit 7:4    rbuf middle level number
+  //bit 3:0    rbuf low level number
+
+#define DMC_CMD_FILTER_CTRL4 DMC_REG_BASE + (0x43 << 2)
+  //bit 24:20.  tHIT latency.  page hit command latency for next same page not hit command.
+  //bit 19:15.  tIDLE latency. page idle command latency for next same page not hit command.
+  //bit 14:10.  tMISS latency. page miss command latency for next same page not hit command.
+  //bit 9:0.    rbuf idle timer to let the wbuf output.
+
+#define DMC_CMD_BUFFER_CTRL  DMC_REG_BASE + (0x44 << 2)
+  //bit 30:25  total write buffer number. default 32.
+  //bit 24:20  total read buffer number. default 16.
+  //bit 19:10  ugt age limit. over this age limit, this read buffer would turn to super urgent.
+  //bit 9:0  nugt age limit. over this age limit, this read buffer would turn to super urgent.
+
+#define DMC_AM0_CHAN_CTRL               DMC_REG_BASE + (0x60 << 2)
+#define DMC_AM0_HOLD_CTRL               DMC_REG_BASE + (0x61 << 2)
+#define DMC_AM0_QOS_INC    		DMC_REG_BASE + (0x62 << 2)
+#define DMC_AM0_QOS_INCBK  		DMC_REG_BASE + (0x63 << 2)
+#define DMC_AM0_QOS_DEC    		DMC_REG_BASE + (0x64 << 2)
+#define DMC_AM0_QOS_DECBK  		DMC_REG_BASE + (0x65 << 2)
+#define DMC_AM0_QOS_DIS    		DMC_REG_BASE + (0x66 << 2)
+#define DMC_AM0_QOS_DISBK  		DMC_REG_BASE + (0x67 << 2)
+#define DMC_AM0_QOS_CTRL0  		DMC_REG_BASE + (0x68 << 2)
+#define DMC_AM0_QOS_CTRL1  		DMC_REG_BASE + (0x69 << 2)
+
+#define DMC_AM1_CHAN_CTRL               DMC_REG_BASE + (0x6a << 2)
+#define DMC_AM1_HOLD_CTRL               DMC_REG_BASE + (0x6b << 2)
+#define DMC_AM1_QOS_INC    		DMC_REG_BASE + (0x6c << 2)
+#define DMC_AM1_QOS_INCBK  		DMC_REG_BASE + (0x6d << 2)
+#define DMC_AM1_QOS_DEC    		DMC_REG_BASE + (0x6e << 2)
+#define DMC_AM1_QOS_DECBK  		DMC_REG_BASE + (0x6f << 2)
+#define DMC_AM1_QOS_DIS    		DMC_REG_BASE + (0x70 << 2)
+#define DMC_AM1_QOS_DISBK  		DMC_REG_BASE + (0x71 << 2)
+#define DMC_AM1_QOS_CTRL0  		DMC_REG_BASE + (0x72 << 2)
+#define DMC_AM1_QOS_CTRL1  		DMC_REG_BASE + (0x73 << 2)
+
+#define DMC_AM2_CHAN_CTRL               DMC_REG_BASE + (0x74 << 2)
+#define DMC_AM2_HOLD_CTRL               DMC_REG_BASE + (0x75 << 2)
+#define DMC_AM2_QOS_INC    		DMC_REG_BASE + (0x76 << 2)
+#define DMC_AM2_QOS_INCBK  		DMC_REG_BASE + (0x77 << 2)
+#define DMC_AM2_QOS_DEC    		DMC_REG_BASE + (0x78 << 2)
+#define DMC_AM2_QOS_DECBK  		DMC_REG_BASE + (0x79 << 2)
+#define DMC_AM2_QOS_DIS    		DMC_REG_BASE + (0x7a << 2)
+#define DMC_AM2_QOS_DISBK  		DMC_REG_BASE + (0x7b << 2)
+#define DMC_AM2_QOS_CTRL0  		DMC_REG_BASE + (0x7c << 2)
+#define DMC_AM2_QOS_CTRL1  		DMC_REG_BASE + (0x7d << 2)
+
+#define DMC_AM3_CHAN_CTRL               DMC_REG_BASE + (0x7e << 2)
+#define DMC_AM3_HOLD_CTRL               DMC_REG_BASE + (0x7f << 2)
+#define DMC_AM3_QOS_INC    		DMC_REG_BASE + (0x80 << 2)
+#define DMC_AM3_QOS_INCBK  		DMC_REG_BASE + (0x81 << 2)
+#define DMC_AM3_QOS_DEC    		DMC_REG_BASE + (0x82 << 2)
+#define DMC_AM3_QOS_DECBK  		DMC_REG_BASE + (0x83 << 2)
+#define DMC_AM3_QOS_DIS    		DMC_REG_BASE + (0x84 << 2)
+#define DMC_AM3_QOS_DISBK  		DMC_REG_BASE + (0x85 << 2)
+#define DMC_AM3_QOS_CTRL0  		DMC_REG_BASE + (0x86 << 2)
+#define DMC_AM3_QOS_CTRL1  		DMC_REG_BASE + (0x87 << 2)
+
+#define DMC_AM4_CHAN_CTRL               DMC_REG_BASE + (0x88 << 2)
+#define DMC_AM4_HOLD_CTRL               DMC_REG_BASE + (0x89 << 2)
+#define DMC_AM4_QOS_INC    		DMC_REG_BASE + (0x8a << 2)
+#define DMC_AM4_QOS_INCBK  		DMC_REG_BASE + (0x8b << 2)
+#define DMC_AM4_QOS_DEC    		DMC_REG_BASE + (0x8c << 2)
+#define DMC_AM4_QOS_DECBK  		DMC_REG_BASE + (0x8d << 2)
+#define DMC_AM4_QOS_DIS    		DMC_REG_BASE + (0x8e << 2)
+#define DMC_AM4_QOS_DISBK  		DMC_REG_BASE + (0x8f << 2)
+#define DMC_AM4_QOS_CTRL0  		DMC_REG_BASE + (0x90 << 2)
+#define DMC_AM4_QOS_CTRL1  		DMC_REG_BASE + (0x91 << 2)
+
+#define DMC_AM5_CHAN_CTRL  	        DMC_REG_BASE + (0x92 << 2)
+#define DMC_AM5_HOLD_CTRL               DMC_REG_BASE + (0x93 << 2)
+#define DMC_AM5_QOS_INC    		DMC_REG_BASE + (0x94 << 2)
+#define DMC_AM5_QOS_INCBK  		DMC_REG_BASE + (0x95 << 2)
+#define DMC_AM5_QOS_DEC    		DMC_REG_BASE + (0x96 << 2)
+#define DMC_AM5_QOS_DECBK  		DMC_REG_BASE + (0x97 << 2)
+#define DMC_AM5_QOS_DIS    		DMC_REG_BASE + (0x98 << 2)
+#define DMC_AM5_QOS_DISBK  		DMC_REG_BASE + (0x99 << 2)
+#define DMC_AM5_QOS_CTRL0  		DMC_REG_BASE + (0x9a << 2)
+#define DMC_AM5_QOS_CTRL1  		DMC_REG_BASE + (0x9b << 2)
+
+#define DMC_AM6_CHAN_CTRL               DMC_REG_BASE + (0x9c << 2)
+#define DMC_AM6_HOLD_CTRL               DMC_REG_BASE + (0x9d << 2)
+#define DMC_AM6_QOS_INC    		DMC_REG_BASE + (0x9e << 2)
+#define DMC_AM6_QOS_INCBK  		DMC_REG_BASE + (0x9f << 2)
+#define DMC_AM6_QOS_DEC    		DMC_REG_BASE + (0xa0 << 2)
+#define DMC_AM6_QOS_DECBK  		DMC_REG_BASE + (0xa1 << 2)
+#define DMC_AM6_QOS_DIS    		DMC_REG_BASE + (0xa2 << 2)
+#define DMC_AM6_QOS_DISBK  		DMC_REG_BASE + (0xa3 << 2)
+#define DMC_AM6_QOS_CTRL0  		DMC_REG_BASE + (0xa4 << 2)
+#define DMC_AM6_QOS_CTRL1  		DMC_REG_BASE + (0xa5 << 2)
+
+#define DMC_AM7_CHAN_CTRL               DMC_REG_BASE + (0xa6 << 2)
+#define DMC_AM7_HOLD_CTRL               DMC_REG_BASE + (0xa7 << 2)
+#define DMC_AM7_QOS_INC    		DMC_REG_BASE + (0xa8 << 2)
+#define DMC_AM7_QOS_INCBK  		DMC_REG_BASE + (0xa9 << 2)
+#define DMC_AM7_QOS_DEC    		DMC_REG_BASE + (0xaa << 2)
+#define DMC_AM7_QOS_DECBK  		DMC_REG_BASE + (0xab << 2)
+#define DMC_AM7_QOS_DIS    		DMC_REG_BASE + (0xac << 2)
+#define DMC_AM7_QOS_DISBK  		DMC_REG_BASE + (0xad << 2)
+#define DMC_AM7_QOS_CTRL0  		DMC_REG_BASE + (0xae << 2)
+#define DMC_AM7_QOS_CTRL1  		DMC_REG_BASE + (0xaf << 2)
+
+#define DMC_AXI0_CHAN_CTRL              DMC_REG_BASE + (0xb0 << 2)
+#define DMC_AXI0_HOLD_CTRL              DMC_REG_BASE + (0xb1 << 2)
+#define DMC_AXI0_QOS_INC    		DMC_REG_BASE + (0xb2 << 2)
+#define DMC_AXI0_QOS_INCBK  		DMC_REG_BASE + (0xb3 << 2)
+#define DMC_AXI0_QOS_DEC    		DMC_REG_BASE + (0xb4 << 2)
+#define DMC_AXI0_QOS_DECBK  		DMC_REG_BASE + (0xb5 << 2)
+#define DMC_AXI0_QOS_DIS    		DMC_REG_BASE + (0xb6 << 2)
+#define DMC_AXI0_QOS_DISBK  		DMC_REG_BASE + (0xb7 << 2)
+#define DMC_AXI0_QOS_CTRL0  		DMC_REG_BASE + (0xb8 << 2)
+#define DMC_AXI0_QOS_CTRL1  		DMC_REG_BASE + (0xb9 << 2)
+
+#define DMC_AXI1_CHAN_CTRL              DMC_REG_BASE + (0xba << 2)
+#define DMC_AXI1_HOLD_CTRL              DMC_REG_BASE + (0xbb << 2)
+#define DMC_AXI1_QOS_INC    		DMC_REG_BASE + (0xbc << 2)
+#define DMC_AXI1_QOS_INCBK  		DMC_REG_BASE + (0xbd << 2)
+#define DMC_AXI1_QOS_DEC    		DMC_REG_BASE + (0xbe << 2)
+#define DMC_AXI1_QOS_DECBK  		DMC_REG_BASE + (0xbf << 2)
+#define DMC_AXI1_QOS_DIS    		DMC_REG_BASE + (0xc0 << 2)
+#define DMC_AXI1_QOS_DISBK  		DMC_REG_BASE + (0xc1 << 2)
+#define DMC_AXI1_QOS_CTRL0  		DMC_REG_BASE + (0xc2 << 2)
+#define DMC_AXI1_QOS_CTRL1  		DMC_REG_BASE + (0xc3 << 2)
+
+#define DMC_AXI2_CHAN_CTRL              DMC_REG_BASE + (0xc4 << 2)
+#define DMC_AXI2_HOLD_CTRL              DMC_REG_BASE + (0xc5 << 2)
+#define DMC_AXI2_QOS_INC    		DMC_REG_BASE + (0xc6 << 2)
+#define DMC_AXI2_QOS_INCBK  		DMC_REG_BASE + (0xc7 << 2)
+#define DMC_AXI2_QOS_DEC    		DMC_REG_BASE + (0xc8 << 2)
+#define DMC_AXI2_QOS_DECBK  		DMC_REG_BASE + (0xc9 << 2)
+#define DMC_AXI2_QOS_DIS    		DMC_REG_BASE + (0xca << 2)
+#define DMC_AXI2_QOS_DISBK  		DMC_REG_BASE + (0xcb << 2)
+#define DMC_AXI2_QOS_CTRL0  		DMC_REG_BASE + (0xcc << 2)
+#define DMC_AXI2_QOS_CTRL1  		DMC_REG_BASE + (0xcd << 2)
+
+#define DMC_AXI3_CHAN_CTRL              DMC_REG_BASE + (0xce << 2)
+#define DMC_AXI3_HOLD_CTRL              DMC_REG_BASE + (0xcf << 2)
+#define DMC_AXI3_QOS_INC    		DMC_REG_BASE + (0xd0 << 2)
+#define DMC_AXI3_QOS_INCBK  		DMC_REG_BASE + (0xd1 << 2)
+#define DMC_AXI3_QOS_DEC    		DMC_REG_BASE + (0xd2 << 2)
+#define DMC_AXI3_QOS_DECBK  		DMC_REG_BASE + (0xd3 << 2)
+#define DMC_AXI3_QOS_DIS    		DMC_REG_BASE + (0xd4 << 2)
+#define DMC_AXI3_QOS_DISBK  		DMC_REG_BASE + (0xd5 << 2)
+#define DMC_AXI3_QOS_CTRL0  		DMC_REG_BASE + (0xd6 << 2)
+#define DMC_AXI3_QOS_CTRL1  		DMC_REG_BASE + (0xd7 << 2)
+
+#define DMC_AXI4_CHAN_CTRL              DMC_REG_BASE + (0xd8 << 2)
+#define DMC_AXI4_HOLD_CTRL              DMC_REG_BASE + (0xd9 << 2)
+#define DMC_AXI4_QOS_INC    		DMC_REG_BASE + (0xda << 2)
+#define DMC_AXI4_QOS_INCBK  		DMC_REG_BASE + (0xdb << 2)
+#define DMC_AXI4_QOS_DEC    		DMC_REG_BASE + (0xdc << 2)
+#define DMC_AXI4_QOS_DECBK  		DMC_REG_BASE + (0xdd << 2)
+#define DMC_AXI4_QOS_DIS    		DMC_REG_BASE + (0xde << 2)
+#define DMC_AXI4_QOS_DISBK  		DMC_REG_BASE + (0xdf << 2)
+#define DMC_AXI4_QOS_CTRL0  		DMC_REG_BASE + (0xe0 << 2)
+#define DMC_AXI4_QOS_CTRL1  		DMC_REG_BASE + (0xe1 << 2)
+
+#define DMC_AXI5_CHAN_CTRL              DMC_REG_BASE + (0xe2 << 2)
+#define DMC_AXI5_HOLD_CTRL              DMC_REG_BASE + (0xe3 << 2)
+#define DMC_AXI5_QOS_INC    		DMC_REG_BASE + (0xe4 << 2)
+#define DMC_AXI5_QOS_INCBK  		DMC_REG_BASE + (0xe5 << 2)
+#define DMC_AXI5_QOS_DEC    		DMC_REG_BASE + (0xe6 << 2)
+#define DMC_AXI5_QOS_DECBK  		DMC_REG_BASE + (0xe7 << 2)
+#define DMC_AXI5_QOS_DIS    		DMC_REG_BASE + (0xe8 << 2)
+#define DMC_AXI5_QOS_DISBK  		DMC_REG_BASE + (0xe9 << 2)
+#define DMC_AXI5_QOS_CTRL0  		DMC_REG_BASE + (0xea << 2)
+#define DMC_AXI5_QOS_CTRL1  		DMC_REG_BASE + (0xeb << 2)
+
+#define DMC_AXI6_CHAN_CTRL              DMC_REG_BASE + (0xec << 2)
+#define DMC_AXI6_HOLD_CTRL              DMC_REG_BASE + (0xed << 2)
+#define DMC_AXI6_QOS_INC    		DMC_REG_BASE + (0xee << 2)
+#define DMC_AXI6_QOS_INCBK  		DMC_REG_BASE + (0xef << 2)
+#define DMC_AXI6_QOS_DEC    		DMC_REG_BASE + (0xf0 << 2)
+#define DMC_AXI6_QOS_DECBK  		DMC_REG_BASE + (0xf1 << 2)
+#define DMC_AXI6_QOS_DIS    		DMC_REG_BASE + (0xf2 << 2)
+#define DMC_AXI6_QOS_DISBK  		DMC_REG_BASE + (0xf3 << 2)
+#define DMC_AXI6_QOS_CTRL0  		DMC_REG_BASE + (0xf4 << 2)
+#define DMC_AXI6_QOS_CTRL1  		DMC_REG_BASE + (0xf5 << 2)
+
+#define DMC_AXI7_CHAN_CTRL              DMC_REG_BASE + (0xf6 << 2)
+#define DMC_AXI7_HOLD_CTRL              DMC_REG_BASE + (0xf7 << 2)
+#define DMC_AXI7_QOS_INC    		DMC_REG_BASE + (0xf8 << 2)
+#define DMC_AXI7_QOS_INCBK  		DMC_REG_BASE + (0xf9 << 2)
+#define DMC_AXI7_QOS_DEC    		DMC_REG_BASE + (0xfa << 2)
+#define DMC_AXI7_QOS_DECBK  		DMC_REG_BASE + (0xfb << 2)
+#define DMC_AXI7_QOS_DIS    		DMC_REG_BASE + (0xfc << 2)
+#define DMC_AXI7_QOS_DISBK  		DMC_REG_BASE + (0xfd << 2)
+#define DMC_AXI7_QOS_CTRL0  		DMC_REG_BASE + (0xfe << 2)
+#define DMC_AXI7_QOS_CTRL1  		DMC_REG_BASE + (0xff << 2)
+
+#endif
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/ucode/dos_register.h b/arch/arm/mach-mesong9tv/tools/genregs/ucode/dos_register.h
new file mode 100644
index 000000000000..ac7d47450830
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/ucode/dos_register.h
@@ -0,0 +1,7800 @@
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+// 
+// ./create_headers_from_dos_params_h.pl
+// 
+// and was applied to the file
+// 
+// ./dos_param.h
+// 
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+// 
+#ifdef DOS_REGISTER_H
+#else
+#define DOS_REGISTER_H
+
+
+//
+// Reading file:  ./dos_param.h
+//
+//------------------------------------------------------------------------------
+// Define all modules' base address under DOS 
+// APB allocation from 32'hd0050000
+//------------------------------------------------------------------------------
+// Define base address for VDEC module under DOS:
+//  DOS_VDEC_ASSIST_BASE_ADDR       14'h0000
+//  DOS_VDEC_MDEC_BASE_ADDR         14'h0900
+//  DOS_VDEC_VLD_BASE_ADDR          14'h0c00
+//  DOS_VDEC_IQIDCT_BASE_ADDR       14'h0e00
+//  DOS_VDEC_VCPU_BASE_ADDR         14'h0300
+//  DOS_VDEC_RESERVED_BASE_ADDR     14'h0f00 // Do not use this offset
+// Define base address for DOS top-level register module:
+//  DOS_TOP_BASE_ADDR               14'h3f00
+//------------------------------------------------------------------------------
+// VDEC_ASSIST module level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_ASSIST_CBUS_BASE = 0x00
+// -----------------------------------------------
+#define VDEC_ASSIST_MMC_CTRL0                      ((0x0001  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MMC_CTRL1                      ((0x0002  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MMC_CTRL2                      ((0x0003  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MMC_CTRL3                      ((0x0004  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT0                      ((0x0025  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT1                      ((0x0026  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT2                      ((0x0027  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT3                      ((0x0028  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT4                      ((0x0029  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT5                      ((0x002a  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT6                      ((0x002b  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT7                      ((0x002c  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT8                      ((0x002d  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INT9                      ((0x002e  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INTA                      ((0x002f  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INTB                      ((0x0030  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INTC                      ((0x0031  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INTD                      ((0x0032  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INTE                      ((0x0033  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR1_INTF                      ((0x0034  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT0                      ((0x0035  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT1                      ((0x0036  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT2                      ((0x0037  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT3                      ((0x0038  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT4                      ((0x0039  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT5                      ((0x003a  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT6                      ((0x003b  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT7                      ((0x003c  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT8                      ((0x003d  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INT9                      ((0x003e  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INTA                      ((0x003f  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INTB                      ((0x0040  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INTC                      ((0x0041  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INTD                      ((0x0042  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INTE                      ((0x0043  << 2) + 0xd0050000)
+#define VDEC_ASSIST_AMR2_INTF                      ((0x0044  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBX_SSEL                       ((0x0045  << 2) + 0xd0050000)
+#define VDEC_ASSIST_TIMER0_LO                      ((0x0060  << 2) + 0xd0050000)
+#define VDEC_ASSIST_TIMER0_HI                      ((0x0061  << 2) + 0xd0050000)
+#define VDEC_ASSIST_TIMER1_LO                      ((0x0062  << 2) + 0xd0050000)
+#define VDEC_ASSIST_TIMER1_HI                      ((0x0063  << 2) + 0xd0050000)
+#define VDEC_ASSIST_DMA_INT                        ((0x0064  << 2) + 0xd0050000)
+#define VDEC_ASSIST_DMA_INT_MSK                    ((0x0065  << 2) + 0xd0050000)
+#define VDEC_ASSIST_DMA_INT2                       ((0x0066  << 2) + 0xd0050000)
+#define VDEC_ASSIST_DMA_INT_MSK2                   ((0x0067  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX0_IRQ_REG                  ((0x0070  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX0_CLR_REG                  ((0x0071  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX0_MASK                     ((0x0072  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX0_FIQ_SEL                  ((0x0073  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX1_IRQ_REG                  ((0x0074  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX1_CLR_REG                  ((0x0075  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX1_MASK                     ((0x0076  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX1_FIQ_SEL                  ((0x0077  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX2_IRQ_REG                  ((0x0078  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX2_CLR_REG                  ((0x0079  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX2_MASK                     ((0x007a  << 2) + 0xd0050000)
+#define VDEC_ASSIST_MBOX2_FIQ_SEL                  ((0x007b  << 2) + 0xd0050000)
+//------------------------------------------------------------------------------
+// VDEC2_ASSIST module level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC2_ASSIST_CBUS_BASE = 0x00
+// -----------------------------------------------
+#define VDEC2_ASSIST_MMC_CTRL0                     ((0x2001  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MMC_CTRL1                     ((0x2002  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT0                     ((0x2025  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT1                     ((0x2026  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT2                     ((0x2027  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT3                     ((0x2028  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT4                     ((0x2029  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT5                     ((0x202a  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT6                     ((0x202b  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT7                     ((0x202c  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT8                     ((0x202d  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INT9                     ((0x202e  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INTA                     ((0x202f  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INTB                     ((0x2030  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INTC                     ((0x2031  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INTD                     ((0x2032  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INTE                     ((0x2033  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR1_INTF                     ((0x2034  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT0                     ((0x2035  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT1                     ((0x2036  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT2                     ((0x2037  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT3                     ((0x2038  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT4                     ((0x2039  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT5                     ((0x203a  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT6                     ((0x203b  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT7                     ((0x203c  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT8                     ((0x203d  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INT9                     ((0x203e  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INTA                     ((0x203f  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INTB                     ((0x2040  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INTC                     ((0x2041  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INTD                     ((0x2042  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INTE                     ((0x2043  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_AMR2_INTF                     ((0x2044  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBX_SSEL                      ((0x2045  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_TIMER0_LO                     ((0x2060  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_TIMER0_HI                     ((0x2061  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_TIMER1_LO                     ((0x2062  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_TIMER1_HI                     ((0x2063  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_DMA_INT                       ((0x2064  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_DMA_INT_MSK                   ((0x2065  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_DMA_INT2                      ((0x2066  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_DMA_INT_MSK2                  ((0x2067  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX0_IRQ_REG                 ((0x2070  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX0_CLR_REG                 ((0x2071  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX0_MASK                    ((0x2072  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX0_FIQ_SEL                 ((0x2073  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX1_IRQ_REG                 ((0x2074  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX1_CLR_REG                 ((0x2075  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX1_MASK                    ((0x2076  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX1_FIQ_SEL                 ((0x2077  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX2_IRQ_REG                 ((0x2078  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX2_CLR_REG                 ((0x2079  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX2_MASK                    ((0x207a  << 2) + 0xd0050000)
+#define VDEC2_ASSIST_MBOX2_FIQ_SEL                 ((0x207b  << 2) + 0xd0050000)
+//------------------------------------------------------------------------------
+// HCODEC_ASSIST module level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_ASSIST_CBUS_BASE = 0x00
+// -----------------------------------------------
+#define HCODEC_ASSIST_MMC_CTRL0                    ((0x1001  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MMC_CTRL1                    ((0x1002  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MMC_CTRL2                    ((0x1003  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MMC_CTRL3                    ((0x1004  << 2) + 0xd0050000)
+//cfg_soft_rst = mfdin_reg0_crst[0]; // Soft Reset
+//cfg_cg_cfe   = mfdin_reg0_crst[1]; // Clock Gating Forcing Enable
+//cfg_dbuf_rst = mfdin_reg0_crst[2]; // Reset DBUF information
+#define HCODEC_MFDIN_REG0_CRST                     ((0x1010  << 2) + 0xd0050000)
+//cfg_iformat       = mfdin_reg1_ctrl[3:0]; // Data In Format: 0 :CANVAS 422 YCbCr<-one canvas, 
+                                                     //        1 :CANVAS 444 YCbCr(or RGB)<-one canvas, 
+                                                     //        2 :CANVAS 420 Y<-one CrCb<-one (NV21)
+                                                     //        3 :CANVAS 420 Y<-one CbCr<-one (NV12)
+                                                     //        4 :CANVAS 420 Y<-one Cb<-one Cr<-one
+                                                     //        5 :CANVAS 444 Y<-one Cb<-one Cr<-one
+                                                     //        6~7: Reserved for other canvas mode
+                                                     //        8 :LINEAR RGB888 (24bit)
+                                                     //        9 :LINEAR RGB565 (16bit)
+                                                     //        10:LINEAR YUV422
+                                                     //        11:LINEAR YUV420 (Note:Legacy mode not supported)
+                                                     //        12~15: Reserved for other linear mode
+//cfg_oformat       = mfdin_reg1_ctrl[5:4];  // Data Out Format: 0:420 1:422 2:444 3:reserved
+//cfg_dsample_enable= mfdin_reg1_ctrl[6];    // Downsample Enable
+//cfg_dsample_trunc = mfdin_reg1_ctrl[7];    // Downsample Addition Option: 0:Round 1:Truncated
+//cfg_block_ysize   = mfdin_reg1_ctrl[8];    // 0:block-y-size=16, 1:block-y-size=8(for JPEG's efficiency)
+//cfg_interp_enable = mfdin_reg1_ctrl[9];    // Chroma Interpolation Enable
+//cfg_interp_mode   = mfdin_reg1_ctrl[11:10];// 0:average round 1:average truncated 2:repeat left 3:repeat right
+//cfg_r2y_enable    = mfdin_reg1_ctrl[12];   // RGb->YUV Enable
+//cfg_r2y_mode      = mfdin_reg1_ctrl[14:13];// RGb->YUV Mode
+//cfg_rgb565_mode   = mfdin_reg1_ctrl[15];   // RGB565 mode: 0:fill zero in tail 1:fill zero in head
+//cfg_reserved1     = mfdin_reg1_ctrl[18:16];// Reserved
+//cfg_soft_en       = mfdin_reg1_ctrl[19];   // Enable Soft Command
+//cfg_outofpic      = mfdin_reg1_ctrl[28:20];// Out Of Picture Control: [8]mode:0:extend 1:fixed, [7:0]fixed value
+//cfg_rd_blktype    = mfdin_reg1_ctrl[30:29];// Block Type: 0:H264_I_PIC_ALL_4x4, 1:H264_P_PIC_Y_16x16_C_8x8, 2:JPEG_ALL_8x8, 3:Reserved
+//cfg_rd_nonycintl  = mfdin_reg1_ctrl[31];   // 0:YC interleaved 1:YC non-interleaved(for JPEG)
+#define HCODEC_MFDIN_REG1_CTRL                     ((0x1011  << 2) + 0xd0050000)
+//mfdin_reg2: DEBUG Only Status
+#define HCODEC_MFDIN_REG2_STAT                     ((0x1012  << 2) + 0xd0050000)
+//cfg_canvas_index0  = mfdin_reg3_canv[7:0];  //canvas index 0
+//cfg_canvas_index1  = mfdin_reg3_canv[15:8]; //canvas index 1
+//cfg_canvas_index2  = mfdin_reg3_canv[23:16];//canvas index 2
+//cfg_canv_idx0_bppx = mfdin_reg3_canv[25:24];//canvas bytes per pixel in x direction for index0, 0:half 1:1 2:2 3:3
+//cfg_canv_idx1_bppx = mfdin_reg3_canv[27:26];//canvas bytes per pixel in x direction for index1, 0:half 1:1 2:2 3:3
+//cfg_canv_idx0_bppy = mfdin_reg3_canv[29:28];//canvas bytes per pixel in y direction for index0, 0:half 1:1 2:2 3:3
+//cfg_canv_idx1_bppy = mfdin_reg3_canv[31:30];//canvas bytes per pixel in y direction for index1, 0:half 1:1 2:2 3:3
+#define HCODEC_MFDIN_REG3_CANV                     ((0x1013  << 2) + 0xd0050000)
+//cfg_bytes_per_line  = mfdin_reg4_lnr0[15:0];  //linear Bytes per line
+//cfg_linear_bytes4p  = mfdin_reg4_lnr0[17:16]; //linear (Bytes per pixel) - 1
+//cfg_linear_dbl2line = mfdin_reg4_lnr0[18];    //linear double size for odd line
+#define HCODEC_MFDIN_REG4_LNR0                     ((0x1014  << 2) + 0xd0050000)
+//cfg_base_address    = mfdin_reg5_lnr1[31:0];  //linear base address
+#define HCODEC_MFDIN_REG5_LNR1                     ((0x1015  << 2) + 0xd0050000)
+//assign cfg_r2y_trunc     = mfdin_reg6_dcfg[9];   //RGb->YUV Addition Option: 0:Round 1:Truncated
+//assign cfg_dma_ugt       = mfdin_reg6_dcfg[8];   //DMA Urgent
+//assign cfg_dma_thread_id = mfdin_reg6_dcfg[7:6]; //DMA Thread ID
+//assign cfg_dma_burst_num = mfdin_reg6_dcfg[5:0]; //DMA Burst Number
+#define HCODEC_MFDIN_REG6_DCFG                     ((0x1016  << 2) + 0xd0050000)
+//cfg_soft_cmd = mfdin_reg7_scmd; // Soft Command [24:13]dmb_xb,[12:1]dmb_yb,[0]selfcleared request
+#define HCODEC_MFDIN_REG7_SCMD                     ((0x1017  << 2) + 0xd0050000)
+//cfg_pic_xsize = mfdin_reg8_dmbl[23:12]; //pixel (x,y) at the begining of last dmb in the picturem, picture x size
+//cfg_pic_ysize = mfdin_reg8_dmbl[11:0];  //picture y size
+#define HCODEC_MFDIN_REG8_DMBL                     ((0x1018  << 2) + 0xd0050000)
+//cfg_endian = mfdin_reg9_endn; //Endian Control
+#define HCODEC_MFDIN_REG9_ENDN                     ((0x1019  << 2) + 0xd0050000)
+//cfg_canv_biasx = mfdin_rega_cav1[23:12]; //canvas bias address x
+//cfg_canv_biasy = mfdin_rega_cav1[11:0];  //canvas bias address y
+#define HCODEC_MFDIN_REGA_CAV1                     ((0x101a  << 2) + 0xd0050000)
+//cfg_amp_en = mfdin_regb_ampc[24];      //Amplitude Enable
+//cfg_amp_cy = mfdin_regb_ampc[23:16];   //Amplitude Coeff Y
+//cfg_amp_cu = mfdin_regb_ampc[15:8];    //Amplitude Coeff U
+//cfg_amp_cv = mfdin_regb_ampc[7:0];     //Amplitude Coeff V
+#define HCODEC_MFDIN_REGB_AMPC                     ((0x101b  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT0                    ((0x1025  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT1                    ((0x1026  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT2                    ((0x1027  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT3                    ((0x1028  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT4                    ((0x1029  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT5                    ((0x102a  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT6                    ((0x102b  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT7                    ((0x102c  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT8                    ((0x102d  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INT9                    ((0x102e  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INTA                    ((0x102f  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INTB                    ((0x1030  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INTC                    ((0x1031  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INTD                    ((0x1032  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INTE                    ((0x1033  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR1_INTF                    ((0x1034  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT0                    ((0x1035  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT1                    ((0x1036  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT2                    ((0x1037  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT3                    ((0x1038  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT4                    ((0x1039  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT5                    ((0x103a  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT6                    ((0x103b  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT7                    ((0x103c  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT8                    ((0x103d  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INT9                    ((0x103e  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INTA                    ((0x103f  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INTB                    ((0x1040  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INTC                    ((0x1041  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INTD                    ((0x1042  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INTE                    ((0x1043  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_AMR2_INTF                    ((0x1044  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBX_SSEL                     ((0x1045  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_TIMER0_LO                    ((0x1060  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_TIMER0_HI                    ((0x1061  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_TIMER1_LO                    ((0x1062  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_TIMER1_HI                    ((0x1063  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_DMA_INT                      ((0x1064  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_DMA_INT_MSK                  ((0x1065  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_DMA_INT2                     ((0x1066  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_DMA_INT_MSK2                 ((0x1067  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX0_IRQ_REG                ((0x1070  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX0_CLR_REG                ((0x1071  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX0_MASK                   ((0x1072  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX0_FIQ_SEL                ((0x1073  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX1_IRQ_REG                ((0x1074  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX1_CLR_REG                ((0x1075  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX1_MASK                   ((0x1076  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX1_FIQ_SEL                ((0x1077  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX2_IRQ_REG                ((0x1078  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX2_CLR_REG                ((0x1079  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX2_MASK                   ((0x107a  << 2) + 0xd0050000)
+#define HCODEC_ASSIST_MBOX2_FIQ_SEL                ((0x107b  << 2) + 0xd0050000)
+//------------------------------------------------------------------------------
+// MDEC module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_MDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+#define MC_CTRL_REG                                ((0x0900  << 2) + 0xd0050000)
+#define MC_MB_INFO                                 ((0x0901  << 2) + 0xd0050000)
+#define MC_PIC_INFO                                ((0x0902  << 2) + 0xd0050000)
+#define MC_HALF_PEL_ONE                            ((0x0903  << 2) + 0xd0050000)
+#define MC_HALF_PEL_TWO                            ((0x0904  << 2) + 0xd0050000)
+#define POWER_CTL_MC                               ((0x0905  << 2) + 0xd0050000)
+#define MC_CMD                                     ((0x0906  << 2) + 0xd0050000)
+#define MC_CTRL0                                   ((0x0907  << 2) + 0xd0050000)
+#define MC_PIC_W_H                                 ((0x0908  << 2) + 0xd0050000)
+#define MC_STATUS0                                 ((0x0909  << 2) + 0xd0050000)
+#define MC_STATUS1                                 ((0x090a  << 2) + 0xd0050000)
+#define MC_CTRL1                                   ((0x090b  << 2) + 0xd0050000)
+#define MC_MIX_RATIO0                              ((0x090c  << 2) + 0xd0050000)
+#define MC_MIX_RATIO1                              ((0x090d  << 2) + 0xd0050000)
+#define MC_DP_MB_XY                                ((0x090e  << 2) + 0xd0050000)
+#define MC_OM_MB_XY                                ((0x090f  << 2) + 0xd0050000)
+#define PSCALE_RST                                 ((0x0910  << 2) + 0xd0050000)
+#define PSCALE_CTRL                                ((0x0911  << 2) + 0xd0050000)
+#define PSCALE_PICI_W                              ((0x0912  << 2) + 0xd0050000)
+#define PSCALE_PICI_H                              ((0x0913  << 2) + 0xd0050000)
+#define PSCALE_PICO_W                              ((0x0914  << 2) + 0xd0050000)
+#define PSCALE_PICO_H                              ((0x0915  << 2) + 0xd0050000)
+#define PSCALE_PICO_START_X                        ((0x0916  << 2) + 0xd0050000)
+#define PSCALE_PICO_START_Y                        ((0x0917  << 2) + 0xd0050000)
+#define PSCALE_DUMMY                               ((0x0918  << 2) + 0xd0050000)
+#define PSCALE_FILT0_COEF0                         ((0x0919  << 2) + 0xd0050000)
+#define PSCALE_FILT0_COEF1                         ((0x091a  << 2) + 0xd0050000)
+#define PSCALE_CMD_CTRL                            ((0x091b  << 2) + 0xd0050000)
+#define PSCALE_CMD_BLK_X                           ((0x091c  << 2) + 0xd0050000)
+#define PSCALE_CMD_BLK_Y                           ((0x091d  << 2) + 0xd0050000)
+#define PSCALE_STATUS                              ((0x091e  << 2) + 0xd0050000)
+#define PSCALE_BMEM_ADDR                           ((0x091f  << 2) + 0xd0050000)
+#define PSCALE_BMEM_DAT                            ((0x0920  << 2) + 0xd0050000)
+#define PSCALE_DRAM_BUF_CTRL                       ((0x0921  << 2) + 0xd0050000)
+#define PSCALE_MCMD_CTRL                           ((0x0922  << 2) + 0xd0050000)
+#define PSCALE_MCMD_XSIZE                          ((0x0923  << 2) + 0xd0050000)
+#define PSCALE_MCMD_YSIZE                          ((0x0924  << 2) + 0xd0050000)
+#define PSCALE_RBUF_START_BLKX                     ((0x0925  << 2) + 0xd0050000)
+#define PSCALE_RBUF_START_BLKY                     ((0x0926  << 2) + 0xd0050000)
+//`define PSCALE_RBUF_MB_WIDTH   8'h27
+#define PSCALE_PICO_SHIFT_XY                       ((0x0928  << 2) + 0xd0050000)
+#define PSCALE_CTRL1                               ((0x0929  << 2) + 0xd0050000)
+//Bit 15, wmask enable
+//Bit 14:13, filt0 srckey_less, 
+//Bit 12:11, filt1 srckey_less, in the case of the interpolated data is equal distance to 
+//key data and normal data, 00: select normal data, 01: select right data, 10: select key data
+//Bit 10:9, srckey mode, 00: equal, 01: less than or equal, 10: great than or equal
+//Bit 8, src key enable
+//Bit 7:0, y src key
+#define PSCALE_SRCKEY_CTRL0                        ((0x092a  << 2) + 0xd0050000)
+//Bit 15:8, cb src key
+//Bit 7:0, cr src key
+#define PSCALE_SRCKEY_CTRL1                        ((0x092b  << 2) + 0xd0050000)
+//Bit 22:16 canvas_rd_addr2
+//Bit 14:8 canvas_rd_addr1
+//Bit 6:0 canvas_rd_addr1
+#define PSCALE_CANVAS_RD_ADDR                      ((0x092c  << 2) + 0xd0050000)
+//Bit 22:16 canvas_wr_addr2
+//Bit 14:8 canvas_wr_addr1
+//Bit 6:0 canvas_wr_addr1
+#define PSCALE_CANVAS_WR_ADDR                      ((0x092d  << 2) + 0xd0050000)
+//bit 13:8 pscale thread ID and token 
+//bit 7 disable write response count adding to busy bit 
+//bit 5:0  pscale prearbitor burst num
+#define PSCALE_CTRL2                               ((0x092e  << 2) + 0xd0050000)
+//   31 - use_omem_mb_xy_auto
+//23:16 - omem_max_mb_x
+//15:8  - omem_mb_y_auto
+// 7:0  - omem_mb_x_auto
+#define HDEC_MC_OMEM_AUTO                          ((0x0930  << 2) + 0xd0050000)
+#define HDEC_MC_MBRIGHT_IDX                        ((0x0931  << 2) + 0xd0050000)
+#define HDEC_MC_MBRIGHT_RD                         ((0x0932  << 2) + 0xd0050000)
+#define MC_MPORT_CTRL                              ((0x0940  << 2) + 0xd0050000)
+#define MC_MPORT_DAT                               ((0x0941  << 2) + 0xd0050000)
+#define MC_WT_PRED_CTRL                            ((0x0942  << 2) + 0xd0050000)
+#define MC_MBBOT_ST_EVEN_ADDR                      ((0x0944  << 2) + 0xd0050000)
+#define MC_MBBOT_ST_ODD_ADDR                       ((0x0945  << 2) + 0xd0050000)
+#define MC_DPDN_MB_XY                              ((0x0946  << 2) + 0xd0050000)
+#define MC_OMDN_MB_XY                              ((0x0947  << 2) + 0xd0050000)
+#define MC_HCMDBUF_H                               ((0x0948  << 2) + 0xd0050000)
+#define MC_HCMDBUF_L                               ((0x0949  << 2) + 0xd0050000)
+#define MC_HCMD_H                                  ((0x094a  << 2) + 0xd0050000)
+#define MC_HCMD_L                                  ((0x094b  << 2) + 0xd0050000)
+#define MC_IDCT_DAT                                ((0x094c  << 2) + 0xd0050000)
+#define MC_CTRL_GCLK_CTRL                          ((0x094d  << 2) + 0xd0050000)
+#define MC_OTHER_GCLK_CTRL                         ((0x094e  << 2) + 0xd0050000)
+//Bit 29:24, mbbot thread ID and token 
+//Bit 21:16, mc read/write thread ID and token 
+//Bit 13:8,  mbbot pre-arbitor burst number 
+//Bit 5:0,   mc pre-arbitor burst number 
+#define MC_CTRL2                                   ((0x094f  << 2) + 0xd0050000)
+// `define DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define ANC1_CANVAS_ADDR      8'h80
+//`define ANC2_CANVAS_ADDR      8'h81
+//`define REC_CANVAS_ADDR       8'h89
+//`define MDEC_PIC_W          8'h8c
+//`define MDEC_PIC_H          8'h8d
+#define MDEC_PIC_DC_CTRL                           ((0x098e  << 2) + 0xd0050000)
+#define MDEC_PIC_DC_STATUS                         ((0x098f  << 2) + 0xd0050000)
+#define ANC0_CANVAS_ADDR                           ((0x0990  << 2) + 0xd0050000)
+#define ANC1_CANVAS_ADDR                           ((0x0991  << 2) + 0xd0050000)
+#define ANC2_CANVAS_ADDR                           ((0x0992  << 2) + 0xd0050000)
+#define ANC3_CANVAS_ADDR                           ((0x0993  << 2) + 0xd0050000)
+#define ANC4_CANVAS_ADDR                           ((0x0994  << 2) + 0xd0050000)
+#define ANC5_CANVAS_ADDR                           ((0x0995  << 2) + 0xd0050000)
+#define ANC6_CANVAS_ADDR                           ((0x0996  << 2) + 0xd0050000)
+#define ANC7_CANVAS_ADDR                           ((0x0997  << 2) + 0xd0050000)
+#define ANC8_CANVAS_ADDR                           ((0x0998  << 2) + 0xd0050000)
+#define ANC9_CANVAS_ADDR                           ((0x0999  << 2) + 0xd0050000)
+#define ANC10_CANVAS_ADDR                          ((0x099a  << 2) + 0xd0050000)
+#define ANC11_CANVAS_ADDR                          ((0x099b  << 2) + 0xd0050000)
+#define ANC12_CANVAS_ADDR                          ((0x099c  << 2) + 0xd0050000)
+#define ANC13_CANVAS_ADDR                          ((0x099d  << 2) + 0xd0050000)
+#define ANC14_CANVAS_ADDR                          ((0x099e  << 2) + 0xd0050000)
+#define ANC15_CANVAS_ADDR                          ((0x099f  << 2) + 0xd0050000)
+#define ANC16_CANVAS_ADDR                          ((0x09a0  << 2) + 0xd0050000)
+#define ANC17_CANVAS_ADDR                          ((0x09a1  << 2) + 0xd0050000)
+#define ANC18_CANVAS_ADDR                          ((0x09a2  << 2) + 0xd0050000)
+#define ANC19_CANVAS_ADDR                          ((0x09a3  << 2) + 0xd0050000)
+#define ANC20_CANVAS_ADDR                          ((0x09a4  << 2) + 0xd0050000)
+#define ANC21_CANVAS_ADDR                          ((0x09a5  << 2) + 0xd0050000)
+#define ANC22_CANVAS_ADDR                          ((0x09a6  << 2) + 0xd0050000)
+#define ANC23_CANVAS_ADDR                          ((0x09a7  << 2) + 0xd0050000)
+#define ANC24_CANVAS_ADDR                          ((0x09a8  << 2) + 0xd0050000)
+#define ANC25_CANVAS_ADDR                          ((0x09a9  << 2) + 0xd0050000)
+#define ANC26_CANVAS_ADDR                          ((0x09aa  << 2) + 0xd0050000)
+#define ANC27_CANVAS_ADDR                          ((0x09ab  << 2) + 0xd0050000)
+#define ANC28_CANVAS_ADDR                          ((0x09ac  << 2) + 0xd0050000)
+#define ANC29_CANVAS_ADDR                          ((0x09ad  << 2) + 0xd0050000)
+#define ANC30_CANVAS_ADDR                          ((0x09ae  << 2) + 0xd0050000)
+#define ANC31_CANVAS_ADDR                          ((0x09af  << 2) + 0xd0050000)
+#define DBKR_CANVAS_ADDR                           ((0x09b0  << 2) + 0xd0050000)
+#define DBKW_CANVAS_ADDR                           ((0x09b1  << 2) + 0xd0050000)
+#define REC_CANVAS_ADDR                            ((0x09b2  << 2) + 0xd0050000)
+//28:24, read/write, current canvas idx, used in h264 only now
+//23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+#define CURR_CANVAS_CTRL                           ((0x09b3  << 2) + 0xd0050000)
+#define MDEC_PIC_DC_THRESH                         ((0x09b8  << 2) + 0xd0050000)
+#define MDEC_PICR_BUF_STATUS                       ((0x09b9  << 2) + 0xd0050000)
+#define MDEC_PICW_BUF_STATUS                       ((0x09ba  << 2) + 0xd0050000)
+#define MCW_DBLK_WRRSP_CNT                         ((0x09bb  << 2) + 0xd0050000)
+#define MC_MBBOT_WRRSP_CNT                         ((0x09bc  << 2) + 0xd0050000)
+#define MDEC_PICW_BUF2_STATUS                      ((0x09bd  << 2) + 0xd0050000)
+#define WRRSP_FIFO_PICW_DBK                        ((0x09be  << 2) + 0xd0050000)
+#define WRRSP_FIFO_PICW_MC                         ((0x09bf  << 2) + 0xd0050000)
+#define AV_SCRATCH_0                               ((0x09c0  << 2) + 0xd0050000)
+#define AV_SCRATCH_1                               ((0x09c1  << 2) + 0xd0050000)
+#define AV_SCRATCH_2                               ((0x09c2  << 2) + 0xd0050000)
+#define AV_SCRATCH_3                               ((0x09c3  << 2) + 0xd0050000)
+#define AV_SCRATCH_4                               ((0x09c4  << 2) + 0xd0050000)
+#define AV_SCRATCH_5                               ((0x09c5  << 2) + 0xd0050000)
+#define AV_SCRATCH_6                               ((0x09c6  << 2) + 0xd0050000)
+#define AV_SCRATCH_7                               ((0x09c7  << 2) + 0xd0050000)
+#define AV_SCRATCH_8                               ((0x09c8  << 2) + 0xd0050000)
+#define AV_SCRATCH_9                               ((0x09c9  << 2) + 0xd0050000)
+#define AV_SCRATCH_A                               ((0x09ca  << 2) + 0xd0050000)
+#define AV_SCRATCH_B                               ((0x09cb  << 2) + 0xd0050000)
+#define AV_SCRATCH_C                               ((0x09cc  << 2) + 0xd0050000)
+#define AV_SCRATCH_D                               ((0x09cd  << 2) + 0xd0050000)
+#define AV_SCRATCH_E                               ((0x09ce  << 2) + 0xd0050000)
+#define AV_SCRATCH_F                               ((0x09cf  << 2) + 0xd0050000)
+#define AV_SCRATCH_G                               ((0x09d0  << 2) + 0xd0050000)
+#define AV_SCRATCH_H                               ((0x09d1  << 2) + 0xd0050000)
+#define AV_SCRATCH_I                               ((0x09d2  << 2) + 0xd0050000)
+#define AV_SCRATCH_J                               ((0x09d3  << 2) + 0xd0050000)
+#define AV_SCRATCH_K                               ((0x09d4  << 2) + 0xd0050000)
+#define AV_SCRATCH_L                               ((0x09d5  << 2) + 0xd0050000)
+#define AV_SCRATCH_M                               ((0x09d6  << 2) + 0xd0050000)
+#define AV_SCRATCH_N                               ((0x09d7  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_co_mb
+// bit[21:16] A_id_co_mb
+// bit[11:0] wrrsp_count_co_mb
+#define WRRSP_CO_MB                                ((0x09d8  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_dcac
+// bit[21:16] A_id_dcac
+// bit[11:0] wrrsp_count_dcac
+#define WRRSP_DCAC                                 ((0x09d9  << 2) + 0xd0050000)
+// bit[11:0] wrrsp_count_vld
+#define WRRSP_VLD                                  ((0x09da  << 2) + 0xd0050000)
+// doublew_cfg0[0];     //       Second Channel Enable, 1:Enable 0:Disable
+// doublew_cfg0[3:1];   // [2:0] Endian Control for Luma
+// doublew_cfg0[5:4];   // [1:0] Pixel sel by horizontal, 0x:1/2 10:left 11:right
+// doublew_cfg0[7:6];   // [1:0] Pixel sel by vertical,   0x:1/2 10:up 11:down
+// doublew_cfg0[8];     //       Size by horizontal, 0:original size 1: 1/2 shrunken size
+// doublew_cfg0[9];     //       Size by vertical,   0:original size 1: 1/2 shrunken size
+// doublew_cfg0[10];    //       1:Round 0:Truncation
+// doublew_cfg0[11];    //       DMA Urgent
+// doublew_cfg0[17:12]; // [5:0] DMA Burst Number
+// doublew_cfg0[23:18]; // [5:0] DMA ID
+// doublew_cfg0[26:24]; // [2:0] Endian Control for Chroma
+// doublew_cfg0[27];    //       Source from, 1:MCW 0:DBLK
+// doublew_cfg0[29:28]; // [1:0] 0x:select both top and bottom 10:select top 11:select bottom
+// doublew_cfg0[30];    //       0:no merge 1:automatic merge
+// doublew_cfg0[31];    //       0:Y addr no change 1:Y addr divided to half
+#define MDEC_DOUBLEW_CFG0                          ((0x09db  << 2) + 0xd0050000)
+// doublew_cfg1[7:0];   // [7:0] DMA Canvas Address for Luma
+// doublew_cfg1[15:8];  // [7:0] DMA Canvas Address for Chroma
+// doublew_cfg1[16];    //       Disable 1st Write - 
+// doublew_cfg1[17];    //       Reverse to original version - 
+// doublew_cfg1[18];    //       DMA Address Mode - 0:Canvas Mode 1:Non-Canvas Mode
+#define MDEC_DOUBLEW_CFG1                          ((0x09dc  << 2) + 0xd0050000)
+// doublew_cfg2[11:0];  //[11:0] vertical flip initial value
+// doublew_cfg2[15];    //       vertical flip enable
+// doublew_cfg2[24:16]; // [8:0] horizontal flip initial value
+// doublew_cfg2[31];    //       horizontal flip enable
+#define MDEC_DOUBLEW_CFG2                          ((0x09dd  << 2) + 0xd0050000)
+// doublew_cfg3[31:0];  //[31:0] non-canvas start address for Luma - 
+#define MDEC_DOUBLEW_CFG3                          ((0x09de  << 2) + 0xd0050000)
+// doublew_cfg4[31:0];  //[31:0] non-canvas start address for Chroma - 
+#define MDEC_DOUBLEW_CFG4                          ((0x09df  << 2) + 0xd0050000)
+// doublew_cfg5[12:0];  //[12:0] non-canvas picture width for Luma - 
+// doublew_cfg5[28:16]; //[12:0] non-canvas picture width for Chroma - 
+#define MDEC_DOUBLEW_CFG5                          ((0x09e0  << 2) + 0xd0050000)
+// doublew_cfg6: reserved
+#define MDEC_DOUBLEW_CFG6                          ((0x09e1  << 2) + 0xd0050000)
+// doublew_cfg7: reserved
+#define MDEC_DOUBLEW_CFG7                          ((0x09e2  << 2) + 0xd0050000)
+// doublew_status[11:0];//[11:0] wrrsp_count_doublew
+// doublew_status[12];  //       doublew_status_busy
+// doublew_status[13];  //       doublew_status_error
+#define MDEC_DOUBLEW_STATUS                        ((0x09e3  << 2) + 0xd0050000)
+//======================================
+//  MC Control Register Bits
+//
+//======================================
+// For bits, just copy the defines...don't translate to addresses
+    #define MC_ENABLE	    0x0001
+    //`define MC_RESET	    16'h0002
+    #define SKIP_MB		    0x0004
+
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+    #define INTRA_MB	    0x0001
+
+    #define BWD_PRED	    0x0004
+    #define FWD_PRED	    0x0008
+
+    #define FLD_MOT		    0x0100
+    #define FRM_16x8_MOT	0x0200
+    #define DUAL_PRM_MOT	0x0300
+
+    #define FRM_DCT		    0x0000	    // Bit 10
+    #define FLD_DCT		    0x0400
+
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+    #define I_PIC		    0x0001
+    #define P_PIC		    0x0002
+    #define B_PIC		    0x0003
+    
+    #define FLD_PIC		    0x0000	    // Bit 8
+    #define FRM_PIC		    0x0100	    
+//========================================================================
+// DBLK Register:  12'h950 - 12'h97f 
+//========================================================================
+#define DBLK_RST                                   ((0x0950  << 2) + 0xd0050000)
+#define DBLK_CTRL                                  ((0x0951  << 2) + 0xd0050000)
+#define DBLK_MB_WID_HEIGHT                         ((0x0952  << 2) + 0xd0050000)
+#define DBLK_STATUS                                ((0x0953  << 2) + 0xd0050000)
+#define DBLK_CMD_CTRL                              ((0x0954  << 2) + 0xd0050000)
+#define DBLK_MB_XY                                 ((0x0955  << 2) + 0xd0050000)
+#define DBLK_QP                                    ((0x0956  << 2) + 0xd0050000)
+#define DBLK_Y_BHFILT                              ((0x0957  << 2) + 0xd0050000)
+#define DBLK_Y_BHFILT_HIGH                         ((0x0958  << 2) + 0xd0050000)
+#define DBLK_Y_BVFILT                              ((0x0959  << 2) + 0xd0050000)
+#define DBLK_CB_BFILT                              ((0x095a  << 2) + 0xd0050000)
+#define DBLK_CR_BFILT                              ((0x095b  << 2) + 0xd0050000)
+#define DBLK_Y_HFILT                               ((0x095c  << 2) + 0xd0050000)
+#define DBLK_Y_HFILT_HIGH                          ((0x095d  << 2) + 0xd0050000)
+#define DBLK_Y_VFILT                               ((0x095e  << 2) + 0xd0050000)
+#define DBLK_CB_FILT                               ((0x095f  << 2) + 0xd0050000)
+#define DBLK_CR_FILT                               ((0x0960  << 2) + 0xd0050000)
+#define DBLK_BETAX_QP_SEL                          ((0x0961  << 2) + 0xd0050000)
+#define DBLK_CLIP_CTRL0                            ((0x0962  << 2) + 0xd0050000)
+#define DBLK_CLIP_CTRL1                            ((0x0963  << 2) + 0xd0050000)
+#define DBLK_CLIP_CTRL2                            ((0x0964  << 2) + 0xd0050000)
+#define DBLK_CLIP_CTRL3                            ((0x0965  << 2) + 0xd0050000)
+#define DBLK_CLIP_CTRL4                            ((0x0966  << 2) + 0xd0050000)
+#define DBLK_CLIP_CTRL5                            ((0x0967  << 2) + 0xd0050000)
+#define DBLK_CLIP_CTRL6                            ((0x0968  << 2) + 0xd0050000)
+#define DBLK_CLIP_CTRL7                            ((0x0969  << 2) + 0xd0050000)
+#define DBLK_CLIP_CTRL8                            ((0x096a  << 2) + 0xd0050000)
+#define DBLK_STATUS1                               ((0x096b  << 2) + 0xd0050000)
+#define DBLK_GCLK_FREE                             ((0x096c  << 2) + 0xd0050000)
+#define DBLK_GCLK_OFF                              ((0x096d  << 2) + 0xd0050000)
+#define DBLK_AVSFLAGS                              ((0x096e  << 2) + 0xd0050000)
+// bit 15:0
+#define DBLK_CBPY                                  ((0x0970  << 2) + 0xd0050000)
+// bit 11:8 -- deblk_cbpy_bottom
+// bit 7:4 -- deblk_cbpy_left
+// bit 3:0 -- deblk_cbpy_top
+#define DBLK_CBPY_ADJ                              ((0x0971  << 2) + 0xd0050000)
+// bit 7:0 -- deblk_cbpc
+#define DBLK_CBPC                                  ((0x0972  << 2) + 0xd0050000)
+// bit 15 -- bottom_mb
+// bit 14 -- left_mb
+// bit 13 -- top_mb
+// bit 12 -- reserved
+// bit 11:8 -- deblk_cbpc_bottom
+// bit 7:4 -- deblk_cbpc_left
+// bit 3:0 -- deblk_cbpc_top
+#define DBLK_CBPC_ADJ                              ((0x0973  << 2) + 0xd0050000)
+// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0} 
+// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0} 
+#define DBLK_VHMVD                                 ((0x0974  << 2) + 0xd0050000)
+// bit 13:12 -- right_vmvd
+// bit 11 -- right_above_vmvd
+// bit 10 -- left_below_hmvd
+// bit 9 -- disable_dblk_luma  
+// bit 8 -- disable_dblk_chroma
+// bit 7 -- bBelowRefDiff
+// bit 6 -- bLeftRefDiff
+// bit 5 -- bAboveRefDiff
+// bit 4 -- reserved
+// bit 3 -- s_below
+// bit 2 -- s_left
+// bit 1 -- s_above
+// bit 0 -- s 
+#define DBLK_STRONG                                ((0x0975  << 2) + 0xd0050000)
+// bit 14:10 -- PQUANT 
+// bit 9:5 -- left_PQUANT 
+// bit 4:0 -- top_PQUANT 
+#define DBLK_RV8_QUANT                             ((0x0976  << 2) + 0xd0050000)
+#define DBLK_CBUS_HCMD2                            ((0x0977  << 2) + 0xd0050000)
+#define DBLK_CBUS_HCMD1                            ((0x0978  << 2) + 0xd0050000)
+#define DBLK_CBUS_HCMD0                            ((0x0979  << 2) + 0xd0050000)
+#define DBLK_VLD_HCMD2                             ((0x097a  << 2) + 0xd0050000)
+#define DBLK_VLD_HCMD1                             ((0x097b  << 2) + 0xd0050000)
+#define DBLK_VLD_HCMD0                             ((0x097c  << 2) + 0xd0050000)
+#define DBLK_OST_YBASE                             ((0x097d  << 2) + 0xd0050000)
+#define DBLK_OST_CBCRDIFF                          ((0x097e  << 2) + 0xd0050000)
+//13:8 dblk thread ID and token 
+//5:0  dblk prearbitor burst num
+#define DBLK_CTRL1                                 ((0x097f  << 2) + 0xd0050000)
+// MCRCC_CTL1
+// 31:3  <reserved[23:0]>
+// 2     <cfg_field_pic>
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define MCRCC_CTL1                                 ((0x0980  << 2) + 0xd0050000)
+// MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define MCRCC_CTL2                                 ((0x0981  << 2) + 0xd0050000)
+// MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define MCRCC_CTL3                                 ((0x0982  << 2) + 0xd0050000)
+// bit[31:10] reserved
+// bit[9:0] sw_clock_gating control 
+// [9] vdec clk_en for assist and cbus.
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for assist
+// [5] vdec clk_en for dblk
+// [4] vdec clk_en for iqidct
+// [3] vdec clk_en for mc
+// [2] vdec clk_en for pic_dc
+// [1] vdec clk_en for psc
+// [0] vdec clk_en for vld
+#define GCLK_EN                                    ((0x0983  << 2) + 0xd0050000)
+// [0]  Reserved 
+// [1]  Reserved
+// [2]  Reset assist, mdec's CBUS
+// [3]  Reset mdec's VLD
+// [4]  Reset mdec's VLD
+// [5]  Reset mdec's VLD
+// [6]  Reset mdec's IQIDCT
+// [7]  Reset mdec's MC
+// [8]  Reset mdec's DBLK
+// [9]  Reset mdec's PIC_DC
+// [10] Reset mdec's Pscale
+// [11] Reset vcpu's MCPU
+// [12] Reset vcpu's CCPU
+// [13] Reset mmc_pre_arb
+#define MDEC_SW_RESET                              ((0x0984  << 2) + 0xd0050000)
+//DBLK last address 12'h97f
+//
+// Closing file:  mdec_regs.h
+//
+//------------------------------------------------------------------------------
+// VLD module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+#define VLD_STATUS_CTRL                            ((0x0c00  << 2) + 0xd0050000)
+//
+// bit 10 -- use_old_shift_en
+// bit 9 -- output_mv_not_pmv
+// bit 8:5 -- force_zigzag
+// bit 4 -- force_zigzag_en
+// bit 3 -- disable_viff_anempty_int
+// bit 2 -- disable_m2_ac_coeff_one_cycle
+// bit 1 -- forced_reset  force reset pmv
+// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+#define MPEG1_2_REG                                ((0x0c01  << 2) + 0xd0050000)
+#define F_CODE_REG                                 ((0x0c02  << 2) + 0xd0050000)
+#define PIC_HEAD_INFO                              ((0x0c03  << 2) + 0xd0050000)
+#define SLICE_VER_POS_PIC_TYPE                     ((0x0c04  << 2) + 0xd0050000)
+#define QP_VALUE_REG                               ((0x0c05  << 2) + 0xd0050000)
+#define MBA_INC                                    ((0x0c06  << 2) + 0xd0050000)
+#define MB_MOTION_MODE                             ((0x0c07  << 2) + 0xd0050000)
+//`define PACKET_BYTE_COUNT   8'h08
+// bit 15 -- force_search_startcode_en
+// bit 14 -- int_cpu_when_error (before do anything)
+// bit 13 -- vld_error_reset
+// bit 12 -- return_on_slice_header
+// bit 6 -- jpeg_ff00_en 
+// bit 5:0 -- vld_power_ctl
+#define POWER_CTL_VLD                              ((0x0c08  << 2) + 0xd0050000)
+#define MB_WIDTH                                   ((0x0c09  << 2) + 0xd0050000)
+#define SLICE_QP                                   ((0x0c0a  << 2) + 0xd0050000)
+// `define MB_X_MB_Y           8'h0b   /* current MBX and MBY                  */
+#define PRE_START_CODE                             ((0x0c0b  << 2) + 0xd0050000)
+#define SLICE_START_BYTE_01                        ((0x0c0c  << 2) + 0xd0050000)
+#define SLICE_START_BYTE_23                        ((0x0c0d  << 2) + 0xd0050000)
+#define RESYNC_MARKER_LENGTH                       ((0x0c0e  << 2) + 0xd0050000)
+// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+// bit[4:0] - buffer ID
+// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+#define DECODER_BUFFER_INFO                        ((0x0c0f  << 2) + 0xd0050000)
+#define FST_FOR_MV_X                               ((0x0c10  << 2) + 0xd0050000)
+#define FST_FOR_MV_Y                               ((0x0c11  << 2) + 0xd0050000)
+#define SCD_FOR_MV_X                               ((0x0c12  << 2) + 0xd0050000)
+#define SCD_FOR_MV_Y                               ((0x0c13  << 2) + 0xd0050000)
+#define FST_BAK_MV_X                               ((0x0c14  << 2) + 0xd0050000)
+#define FST_BAK_MV_Y                               ((0x0c15  << 2) + 0xd0050000)
+#define SCD_BAK_MV_X                               ((0x0c16  << 2) + 0xd0050000)
+#define SCD_BAK_MV_Y                               ((0x0c17  << 2) + 0xd0050000)
+// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+// bit 3 -- reserved
+// bit 2 -- weighting_prediction
+// bit 1 -- mb_weighting_flag
+// bit 0 -- slice_weighting_flag 
+#define VLD_DECODE_CONTROL                         ((0x0c18  << 2) + 0xd0050000)
+#define VLD_REVERVED_19                            ((0x0c19  << 2) + 0xd0050000)
+#define VIFF_BIT_CNT                               ((0x0c1a  << 2) + 0xd0050000)
+#define BYTE_ALIGN_PEAK_HI                         ((0x0c1b  << 2) + 0xd0050000)
+#define BYTE_ALIGN_PEAK_LO                         ((0x0c1c  << 2) + 0xd0050000)
+#define NEXT_ALIGN_PEAK                            ((0x0c1d  << 2) + 0xd0050000)
+// bit 19    : vc1_inv_intra_co_mb_ref_rd
+// bit 18    : vc1_inv_co_mb_ref_rd
+// bit 17    : vc1_inv_intra_co_mb_ref_wr
+// bit 16    : vc1_inv_co_mb_ref_wr
+// bit 15    : reserved
+// bit 14    : avs_drop_enable
+// bit 13:12 : avs_drop_ptr
+// bit 11:8  : avs_demu_ctl_reg
+// bit 7 : avs_enable
+// bit 6 : disable_dblk_hcmd
+// bit 5 : disable_mc_hcmd
+// bit 4 : first_mode3_set enable
+// bit 3 : first_mode3
+// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+// bit 0   : vc1_enable
+#define VC1_CONTROL_REG                            ((0x0c1e  << 2) + 0xd0050000)
+#define PMV1_X                                     ((0x0c20  << 2) + 0xd0050000)
+#define PMV1_Y                                     ((0x0c21  << 2) + 0xd0050000)
+#define PMV2_X                                     ((0x0c22  << 2) + 0xd0050000)
+#define PMV2_Y                                     ((0x0c23  << 2) + 0xd0050000)
+#define PMV3_X                                     ((0x0c24  << 2) + 0xd0050000)
+#define PMV3_Y                                     ((0x0c25  << 2) + 0xd0050000)
+#define PMV4_X                                     ((0x0c26  << 2) + 0xd0050000)
+#define PMV4_Y                                     ((0x0c27  << 2) + 0xd0050000)
+// Can't use the same address for different defines
+// Therefore, create a single define that covers both
+// Only appears to be used in micro-code since the VLD hardware is 
+// hard coded.
+// `define M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+// `define M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+#define M4_TABLE_SELECT                            ((0x0c28  << 2) + 0xd0050000)
+#define M4_CONTROL_REG                             ((0x0c29  << 2) + 0xd0050000)
+#define BLOCK_NUM                                  ((0x0c2a  << 2) + 0xd0050000)
+#define PATTERN_CODE                               ((0x0c2b  << 2) + 0xd0050000)
+#define MB_INFO                                    ((0x0c2c  << 2) + 0xd0050000)
+#define VLD_DC_PRED                                ((0x0c2d  << 2) + 0xd0050000)
+#define VLD_ERROR_MASK                             ((0x0c2e  << 2) + 0xd0050000)
+#define VLD_DC_PRED_C                              ((0x0c2f  << 2) + 0xd0050000)
+#define LAST_SLICE_MV_ADDR                         ((0x0c30  << 2) + 0xd0050000)
+#define LAST_MVX                                   ((0x0c31  << 2) + 0xd0050000)
+#define LAST_MVY                                   ((0x0c32  << 2) + 0xd0050000)
+#define VLD_C38                                    ((0x0c38  << 2) + 0xd0050000)
+#define VLD_C39                                    ((0x0c39  << 2) + 0xd0050000)
+#define VLD_STATUS                                 ((0x0c3a  << 2) + 0xd0050000)
+#define VLD_SHIFT_STATUS                           ((0x0c3b  << 2) + 0xd0050000)
+// `define VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+#define VOFF_STATUS                                ((0x0c3c  << 2) + 0xd0050000)
+#define VLD_C3D                                    ((0x0c3d  << 2) + 0xd0050000)
+#define VLD_DBG_INDEX                              ((0x0c3e  << 2) + 0xd0050000)
+// vld_buff_info -- (index == 0) 
+// Bit[7:6]  mv_UR_ready_cnt;
+// Bit[5]  vld_wr_idx
+// Bit[4]  iq_rd_idx
+// Bit[3]  vld_vi_block_rdy_1
+// Bit[2]  vld_vi_block_rdy_2
+// Bit[1]  voff_empty_1
+// Bit[0]  voff_empty_2
+// cabac_buff_info_0 -- (index == 1) 
+// Bit[31] shift_data_ready
+// Bit[30:29] Reserved
+// Bit[28:24] cabac_buffer_ptr
+// Bit[23:0] cabac_buffer
+// cabac_buff_info_1 -- (index == 2) 
+// Bit[31:29] Reserved
+// Bit[28:20] Drange
+// Bit[19:16] bin_count_4
+// Bit[15:13] Reserved
+// Bit[12:6] context_mem_do
+// Bit[5:3] coeff_state
+// Bit[2:0] mvd_state
+// h264_mv_present -- (index == 3) 
+// Bit[31:16] mv_present_l0
+// Bit[15:0] mv_present_l1
+// h264_mv_cal_info_0 -- (index == 4) 
+// [31:28] mv_cal_state
+// [27:24] direct_spatial_cnt
+// Bit[23:21] Reserved
+// Bit[20] mv_UR_ready_for_mv_cal
+// Bit[19] co_mb_mem_ready_for_mv_cal
+// Bit[18] mc_dblk_cmd_if_busy
+// Bit[17] h264_co_mb_wr_busy
+// Bit[16] H264_cbp_blk_ready
+// Bit[15] mc_hcmd_rrdy
+// Bit[14] mc_hcmd_srdy
+// Bit[13] mc_cmd_if_ready
+// Bit[12] mc_hcmd_mv_available
+// Bit[11:8] mc_cmd_if_state
+// Bit[7] dblk_hcmd_rrdy
+// Bit[6] dblk_hcmd_srdy
+// Bit[5] dblk_cmd_if_ready
+// Bit[4] dblk_hcmd_mv_available
+// Bit[3:0] dblk_cmd_if_state
+// h264_mv_cal_info_1 -- (index == 5) 
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l0
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l0
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l0
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l0
+// h264_mv_cal_info_2 -- (index == 6) 
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l1
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l1
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l1
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l1
+// h264_co_mb_info -- (index == 7)
+// Bit[31:26] Reserved
+// Bit[25] mv_scale_cal_busy
+// Bit[24:20] co_mv_count
+// Bit[19:16] co_mv_process_state
+// Bit[15] h264_co_mb_rd_busy
+// Bit[15] h264_co_mb_rd_ready
+// Bit[13:12] co_mv_transfer_block_cnt
+// Bit[11:8] co_mv_transfer_ptr
+// Bit[7] co_mv_POC_l1_busy
+// Bit[6] h264_weight_scale_cal_en
+// Bit[5] weight_cal_busy
+// Bit[4] weight_cal_not_finished
+// Bit[3:0] weight_process_state
+#define VLD_DBG_DATA                               ((0x0c3f  << 2) + 0xd0050000)
+// --------------------------------------------
+// VIFIFO DDR Interface
+// --------------------------------------------
+// The VIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define VLD_MEM_VIFIFO_START_PTR                   ((0x0c40  << 2) + 0xd0050000)
+// The current pointer points so some location between the START and END 
+// pointers.  The current pointer is a BYTE pointer.  That is, you can 
+// point to any BYTE address within the START/END range
+#define VLD_MEM_VIFIFO_CURR_PTR                    ((0x0c41  << 2) + 0xd0050000)
+#define VLD_MEM_VIFIFO_END_PTR                     ((0x0c42  << 2) + 0xd0050000)
+#define VLD_MEM_VIFIFO_BYTES_AVAIL                 ((0x0c43  << 2) + 0xd0050000)
+// VIFIFO FIFO Control
+// bit  [31:24] viff_empty_int_enable_cpu[7:0] 
+// bit  [23:16] viff_empty_int_enable_amrisc[7:0] 
+//   -bit 23 Video BUFFER < 0x400 Bytes
+//   -bit 22 Video BUFFER < 0x200 Bytes
+//   -bit 21 Video BUFFER < 0x100 Bytes
+//   -bit 20 Video BUFFER < 0x80 Bytes
+//   -bit 19 Video BUFFER < 0x40 Bytes
+//   -bit 18 Video BUFFER < 0x20 Bytes
+//   -bit 17 vififo  < 16 double words
+//   -bit 16 vififo  < 8 double words
+// bit  [15:13] unused
+// bit  [12]    A_urgent
+// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     init_with_cntl_init
+// bit  [6]     reserved
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define VLD_MEM_VIFIFO_CONTROL                     ((0x0c44  << 2) + 0xd0050000)
+// --------------------------------------------
+// VIFIFO Buffer Level Manager
+// --------------------------------------------
+#define VLD_MEM_VIFIFO_WP                          ((0x0c45  << 2) + 0xd0050000)
+#define VLD_MEM_VIFIFO_RP                          ((0x0c46  << 2) + 0xd0050000)
+#define VLD_MEM_VIFIFO_LEVEL                       ((0x0c47  << 2) + 0xd0050000)
+//
+// bit  [8]     use_parser_video2_wp
+// bit  [7]     vbuf2_out_manual
+// bit  [6]     vbuf_out_manual
+// bit  [5]     empty (ReadOnly)
+// bit  [4]     full (ReadOnly)
+// bit  [3:2]   reserved
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define VLD_MEM_VIFIFO_BUF_CNTL                    ((0x0c48  << 2) + 0xd0050000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define VLD_TIME_STAMP_CNTL                        ((0x0c49  << 2) + 0xd0050000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define VLD_TIME_STAMP_SYNC_0                      ((0x0c4a  << 2) + 0xd0050000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
+#define VLD_TIME_STAMP_SYNC_1                      ((0x0c4b  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_0
+#define VLD_TIME_STAMP_0                           ((0x0c4c  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_1
+#define VLD_TIME_STAMP_1                           ((0x0c4d  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_2
+#define VLD_TIME_STAMP_2                           ((0x0c4e  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_3
+#define VLD_TIME_STAMP_3                           ((0x0c4f  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define VLD_TIME_STAMP_LENGTH                      ((0x0c50  << 2) + 0xd0050000)
+// bit 15:0 vififo_rd_count
+#define VLD_MEM_VIFIFO_WRAP_COUNT                  ((0x0c51  << 2) + 0xd0050000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold 
+#define VLD_MEM_VIFIFO_MEM_CTL                     ((0x0c52  << 2) + 0xd0050000)
+#define VLD_MEM_VBUF_RD_PTR                        ((0x0c53  << 2) + 0xd0050000)
+#define VLD_MEM_VBUF2_RD_PTR                       ((0x0c54  << 2) + 0xd0050000)
+#define VLD_MEM_SWAP_ADDR                          ((0x0c55  << 2) + 0xd0050000)
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only)
+// bit [7] - swap busy (Read Only)
+// bit [6:2] - reserved
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define VLD_MEM_SWAP_CTL                           ((0x0c56  << 2) + 0xd0050000)
+//
+// Closing file:  vld_regs.h
+//
+//------------------------------------------------------------------------------
+// IQ/IDCT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+#define VCOP_CTRL_REG                              ((0x0e00  << 2) + 0xd0050000)
+#define QP_CTRL_REG                                ((0x0e01  << 2) + 0xd0050000)
+#define INTRA_QUANT_MATRIX                         ((0x0e02  << 2) + 0xd0050000)
+#define NON_I_QUANT_MATRIX                         ((0x0e03  << 2) + 0xd0050000)
+#define DC_SCALER                                  ((0x0e04  << 2) + 0xd0050000)
+#define DC_AC_CTRL                                 ((0x0e05  << 2) + 0xd0050000)
+// `define RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+#define DC_AC_SCALE_MUL                            ((0x0e06  << 2) + 0xd0050000)
+#define DC_AC_SCALE_DIV                            ((0x0e07  << 2) + 0xd0050000)
+// `define DC_AC_SCALE_RESULT  8'h06
+// `define RESERVED_E07        8'h07
+#define POWER_CTL_IQIDCT                           ((0x0e08  << 2) + 0xd0050000)
+#define RV_AI_Y_X                                  ((0x0e09  << 2) + 0xd0050000)
+#define RV_AI_U_X                                  ((0x0e0a  << 2) + 0xd0050000)
+#define RV_AI_V_X                                  ((0x0e0b  << 2) + 0xd0050000)
+// bit 15:0 will count up when rv_ai_mb finished when non zero
+// and rv_ai_mb_finished_int will be generate when this is not zero
+#define RV_AI_MB_COUNT                             ((0x0e0c  << 2) + 0xd0050000)
+// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+#define NEXT_INTRA_DMA_ADDRESS                     ((0x0e0d  << 2) + 0xd0050000)
+// Bit 0 -- constrained_intra_pred_flag for H264
+#define IQIDCT_CONTROL                             ((0x0e0e  << 2) + 0xd0050000)
+// Bit[31:19] Reserved
+// Bit[18] iq_waiting
+// Bit[17] iq_om_wr_idx
+// Bit[16] iq_om_rd_idx
+// Bit[15] iq_om_busy
+// Bit[14] iq_om_2_busy 
+// Bit[13] idx_fifo_0
+// Bit[12] idx_fifo_1
+// Bit[11] idx_fifo_2
+// Bit[10] idx_fifo_3
+// Bit[9] idx_fifo_4
+// Bit[8] idx_fifo_5
+// Bit[7] idx_fifo_6
+// Bit[6] idx_fifo_7
+// Bit[5:3] idx_fifo_wp
+// Bit[2:0] idx_fifo_rp
+#define IQIDCT_DEBUG_INFO_0                        ((0x0e0f  << 2) + 0xd0050000)
+// For RTL Simulation Only
+#define DEBLK_CMD                                  ((0x0e10  << 2) + 0xd0050000)
+// Bit[15+16] ds_mc_valid_2
+// Bit[14+16] new_idct1_rd_idx_2
+// Bit[13+16] new_idct1_wr_idx_2
+// Bit[12+16] idct1_buff0_busy_2
+// Bit[11+16] idct1_buff1_busy_2
+// Bit[10+16] new_idct1_busy_2
+// Bit[9+16] iq_om_8val_2
+// Bit[8+16] idct1_pipe_busy_2
+// Bit[7+16] wait_mb_left_finish_hold_2
+// Bit[6+16] new_idct2_rd_idx_2
+// Bit[5+16] new_idct2_wr_idx_2
+// Bit[4+16] idct2_buff0_busy_2
+// Bit[3+16] idct2_buff1_busy_2
+// Bit[2+16] idct2_en_2
+// Bit[1+16] new_idct2_busy_2
+// Bit[0+16] new_idct1_ready_2
+// Bit[15] ds_mc_valid_1
+// Bit[14] new_idct1_rd_idx_1
+// Bit[13] new_idct1_wr_idx_1
+// Bit[12] idct1_buff0_busy_1
+// Bit[11] idct1_buff1_busy_1
+// Bit[10] new_idct1_busy_1
+// Bit[9] iq_om_8val_1
+// Bit[8] idct1_pipe_busy_1
+// Bit[7] wait_mb_left_finish_hold_1
+// Bit[6] new_idct2_rd_idx_1
+// Bit[5] new_idct2_wr_idx_1
+// Bit[4] idct2_buff0_busy_1
+// Bit[3] idct2_buff1_busy_1
+// Bit[2] idct2_en_1
+// Bit[1] new_idct2_busy_1
+// Bit[0] new_idct1_ready_1
+#define IQIDCT_DEBUG_IDCT                          ((0x0e11  << 2) + 0xd0050000)
+// bit 31 -- convas_enable
+// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+// bit 23:16 -- convas_y_count
+// bit 15   -- dcac_dma_busy
+// bit 14   -- dcac_dma_urgent
+// bit 13:8 -- dcac_dma_count
+// bit 7    -- dcac_dma_rw
+// bit 6    -- dcac_skip_read_mode
+// bit 5:0  -- dcac_dma_offset
+#define DCAC_DMA_CTRL                              ((0x0e12  << 2) + 0xd0050000)
+// when (convas_enable == 0 )
+//   bit 31:0 dcac_dma_addr
+// when (convas_enable == 1 )
+//   bit 31:25 canvas_addr (7 bits)
+//   bit 24:12 convas_y_start ( 13 btis )
+//   bit 11:0  convas_x_start ( 12 btis )
+#define DCAC_DMA_ADDRESS                           ((0x0e13  << 2) + 0xd0050000)
+// bit 7:0 -- dcac_cpu_addr
+#define DCAC_CPU_ADDRESS                           ((0x0e14  << 2) + 0xd0050000)
+// bit 31:0 -- dcac_cpu_data
+#define DCAC_CPU_DATA                              ((0x0e15  << 2) + 0xd0050000)
+// bit 31:19 -- reserved
+// bit 18:16 -- block_num_reg -- Read-Only 
+// bit 15:0 -- dcac_mb_count
+#define DCAC_MB_COUNT                              ((0x0e16  << 2) + 0xd0050000)
+// bit 31:18 -- reserved
+// For H264 :
+//   bit 17:2 -- h264_quant 
+//   bit 11:6 -- h264_quant_c 
+//   bit  5:0 -- h264_quant_c 
+// For VC1 :
+//   bit    17 -- qindex_GT_8
+//   bit    16 -- HalfQPStep
+//   bit 15:12 -- eQuantMode 
+//   bit 11:6  -- AltPQuant 
+//   bit  5:0  -- PQuant 
+//             
+#define IQ_QUANT                                   ((0x0e17  << 2) + 0xd0050000)
+// bit 31:24  -- bitplane_width 
+// bit 23:16  -- bitplane_height 
+// bit 15:14  -- bitplane_start_x 
+// bit 13:12  -- bitplane_start_y 
+// bit 11:4   -- reserved
+// bit 3:1    -- bitplane_type
+// bit 0      -- bitplane_busy
+#define VC1_BITPLANE_CTL                           ((0x0e18  << 2) + 0xd0050000)
+    #define RAM_TEST_CMD        0x002
+    #define RAM_TEST_ADDR       0x003
+    #define RAM_TEST_DATAH      0x004
+    #define RAM_TEST_DATAL      0x005
+
+    #define RAM_TEST_RD_CMD	    0x0000
+    #define RAM_TEST_WR_CMD	    0x8000
+    #define IDCT_TM2_PT0	    0x0001
+    #define IDCT_TM2_PT1	    0x0002
+    #define IDCT_TM1_PT0	    0x0004
+    #define IDCT_TM1_PT1	    0x0008
+    #define IQ_OMEM_PT0	        0x0010
+    #define IQ_OMEM_PT1	        0x0020
+    #define MC_IMEM_PT0	        0x0040
+    #define ALL_RAM_PTS	        0x007f
+//======================================
+//  VCOP Control Register Bits
+//
+//======================================
+    //`define IQIDCT_RESET	    16'h0001	    // Bit 0
+    #define QM_WEN		    0x0002	    // Bit 1
+    #define IQIDCT_ENABLE	    0x0004	    // Bit 2
+    #define INTRA_QM	    0x0008	    // Bit 3	0 = Use default; 1 = use loaded
+    #define NINTRA_QM	    0x0010	    // Bit 4	0 = Use default; 1 = use loaded
+//======================================
+//  QP Control Register Bits
+//
+//======================================
+    #define INTRA_MODE	    0x0080	    // Bit 7
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+// Closing file:  iqidct_regs.h
+//
+//------------------------------------------------------------------------------
+// VCPU module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+#define MSP                                        ((0x0300  << 2) + 0xd0050000)
+#define MPSR                                       ((0x0301  << 2) + 0xd0050000)
+#define MINT_VEC_BASE                              ((0x0302  << 2) + 0xd0050000)
+#define MCPU_INTR_GRP                              ((0x0303  << 2) + 0xd0050000)
+#define MCPU_INTR_MSK                              ((0x0304  << 2) + 0xd0050000)
+#define MCPU_INTR_REQ                              ((0x0305  << 2) + 0xd0050000)
+#define MPC_P                                      ((0x0306  << 2) + 0xd0050000)
+#define MPC_D                                      ((0x0307  << 2) + 0xd0050000)
+#define MPC_E                                      ((0x0308  << 2) + 0xd0050000)
+#define MPC_W                                      ((0x0309  << 2) + 0xd0050000)
+#define MINDEX0_REG                                ((0x030a  << 2) + 0xd0050000)
+#define MINDEX1_REG                                ((0x030b  << 2) + 0xd0050000)
+#define MINDEX2_REG                                ((0x030c  << 2) + 0xd0050000)
+#define MINDEX3_REG                                ((0x030d  << 2) + 0xd0050000)
+#define MINDEX4_REG                                ((0x030e  << 2) + 0xd0050000)
+#define MINDEX5_REG                                ((0x030f  << 2) + 0xd0050000)
+#define MINDEX6_REG                                ((0x0310  << 2) + 0xd0050000)
+#define MINDEX7_REG                                ((0x0311  << 2) + 0xd0050000)
+#define MMIN_REG                                   ((0x0312  << 2) + 0xd0050000)
+#define MMAX_REG                                   ((0x0313  << 2) + 0xd0050000)
+#define MBREAK0_REG                                ((0x0314  << 2) + 0xd0050000)
+#define MBREAK1_REG                                ((0x0315  << 2) + 0xd0050000)
+#define MBREAK2_REG                                ((0x0316  << 2) + 0xd0050000)
+#define MBREAK3_REG                                ((0x0317  << 2) + 0xd0050000)
+#define MBREAK_TYPE                                ((0x0318  << 2) + 0xd0050000)
+#define MBREAK_CTRL                                ((0x0319  << 2) + 0xd0050000)
+#define MBREAK_STAUTS                              ((0x031a  << 2) + 0xd0050000)
+#define MDB_ADDR_REG                               ((0x031b  << 2) + 0xd0050000)
+#define MDB_DATA_REG                               ((0x031c  << 2) + 0xd0050000)
+#define MDB_CTRL                                   ((0x031d  << 2) + 0xd0050000)
+#define MSFTINT0                                   ((0x031e  << 2) + 0xd0050000)
+#define MSFTINT1                                   ((0x031f  << 2) + 0xd0050000)
+#define CSP                                        ((0x0320  << 2) + 0xd0050000)
+#define CPSR                                       ((0x0321  << 2) + 0xd0050000)
+#define CINT_VEC_BASE                              ((0x0322  << 2) + 0xd0050000)
+#define CCPU_INTR_GRP                              ((0x0323  << 2) + 0xd0050000)
+#define CCPU_INTR_MSK                              ((0x0324  << 2) + 0xd0050000)
+#define CCPU_INTR_REQ                              ((0x0325  << 2) + 0xd0050000)
+#define CPC_P                                      ((0x0326  << 2) + 0xd0050000)
+#define CPC_D                                      ((0x0327  << 2) + 0xd0050000)
+#define CPC_E                                      ((0x0328  << 2) + 0xd0050000)
+#define CPC_W                                      ((0x0329  << 2) + 0xd0050000)
+#define CINDEX0_REG                                ((0x032a  << 2) + 0xd0050000)
+#define CINDEX1_REG                                ((0x032b  << 2) + 0xd0050000)
+#define CINDEX2_REG                                ((0x032c  << 2) + 0xd0050000)
+#define CINDEX3_REG                                ((0x032d  << 2) + 0xd0050000)
+#define CINDEX4_REG                                ((0x032e  << 2) + 0xd0050000)
+#define CINDEX5_REG                                ((0x032f  << 2) + 0xd0050000)
+#define CINDEX6_REG                                ((0x0330  << 2) + 0xd0050000)
+#define CINDEX7_REG                                ((0x0331  << 2) + 0xd0050000)
+#define CMIN_REG                                   ((0x0332  << 2) + 0xd0050000)
+#define CMAX_REG                                   ((0x0333  << 2) + 0xd0050000)
+#define CBREAK0_REG                                ((0x0334  << 2) + 0xd0050000)
+#define CBREAK1_REG                                ((0x0335  << 2) + 0xd0050000)
+#define CBREAK2_REG                                ((0x0336  << 2) + 0xd0050000)
+#define CBREAK3_REG                                ((0x0337  << 2) + 0xd0050000)
+#define CBREAK_TYPE                                ((0x0338  << 2) + 0xd0050000)
+#define CBREAK_CTRL                                ((0x0339  << 2) + 0xd0050000)
+#define CBREAK_STAUTS                              ((0x033a  << 2) + 0xd0050000)
+#define CDB_ADDR_REG                               ((0x033b  << 2) + 0xd0050000)
+#define CDB_DATA_REG                               ((0x033c  << 2) + 0xd0050000)
+#define CDB_CTRL                                   ((0x033d  << 2) + 0xd0050000)
+#define CSFTINT0                                   ((0x033e  << 2) + 0xd0050000)
+#define CSFTINT1                                   ((0x033f  << 2) + 0xd0050000)
+#define IMEM_DMA_CTRL                              ((0x0340  << 2) + 0xd0050000)
+#define IMEM_DMA_ADR                               ((0x0341  << 2) + 0xd0050000)
+#define IMEM_DMA_COUNT                             ((0x0342  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_imem
+// bit[21:16] A_id_imem
+// bit[11:0] wrrsp_count_imem (reserved)
+#define WRRSP_IMEM                                 ((0x0343  << 2) + 0xd0050000)
+#define LMEM_DMA_CTRL                              ((0x0350  << 2) + 0xd0050000)
+#define LMEM_DMA_ADR                               ((0x0351  << 2) + 0xd0050000)
+#define LMEM_DMA_COUNT                             ((0x0352  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_lmem
+// bit[21:16] A_id_lmem
+// bit[11:0] wrrsp_count_lmem 
+#define WRRSP_LMEM                                 ((0x0353  << 2) + 0xd0050000)
+#define MAC_CTRL1                                  ((0x0360  << 2) + 0xd0050000)
+#define ACC0REG1                                   ((0x0361  << 2) + 0xd0050000)
+#define ACC1REG1                                   ((0x0362  << 2) + 0xd0050000)
+#define MAC_CTRL2                                  ((0x0370  << 2) + 0xd0050000)
+#define ACC0REG2                                   ((0x0371  << 2) + 0xd0050000)
+#define ACC1REG2                                   ((0x0372  << 2) + 0xd0050000)
+#define CPU_TRACE                                  ((0x0380  << 2) + 0xd0050000)
+//
+// Closing file:  vcpu_regs.h
+//
+//------------------------------------------------------------------------------
+// HENC module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  henc_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_HENC_CBUS_BASE = 0x0a
+// -----------------------------------------------
+#define HENC_SCRATCH_0                             ((0x1ac0  << 2) + 0xd0050000)
+#define HENC_SCRATCH_1                             ((0x1ac1  << 2) + 0xd0050000)
+#define HENC_SCRATCH_2                             ((0x1ac2  << 2) + 0xd0050000)
+#define HENC_SCRATCH_3                             ((0x1ac3  << 2) + 0xd0050000)
+#define HENC_SCRATCH_4                             ((0x1ac4  << 2) + 0xd0050000)
+#define HENC_SCRATCH_5                             ((0x1ac5  << 2) + 0xd0050000)
+#define HENC_SCRATCH_6                             ((0x1ac6  << 2) + 0xd0050000)
+#define HENC_SCRATCH_7                             ((0x1ac7  << 2) + 0xd0050000)
+#define HENC_SCRATCH_8                             ((0x1ac8  << 2) + 0xd0050000)
+#define HENC_SCRATCH_9                             ((0x1ac9  << 2) + 0xd0050000)
+#define HENC_SCRATCH_A                             ((0x1aca  << 2) + 0xd0050000)
+#define HENC_SCRATCH_B                             ((0x1acb  << 2) + 0xd0050000)
+#define HENC_SCRATCH_C                             ((0x1acc  << 2) + 0xd0050000)
+#define HENC_SCRATCH_D                             ((0x1acd  << 2) + 0xd0050000)
+#define HENC_SCRATCH_E                             ((0x1ace  << 2) + 0xd0050000)
+#define HENC_SCRATCH_F                             ((0x1acf  << 2) + 0xd0050000)
+#define HENC_SCRATCH_G                             ((0x1ad0  << 2) + 0xd0050000)
+#define HENC_SCRATCH_H                             ((0x1ad1  << 2) + 0xd0050000)
+#define HENC_SCRATCH_I                             ((0x1ad2  << 2) + 0xd0050000)
+#define HENC_SCRATCH_J                             ((0x1ad3  << 2) + 0xd0050000)
+#define HENC_SCRATCH_K                             ((0x1ad4  << 2) + 0xd0050000)
+#define HENC_SCRATCH_L                             ((0x1ad5  << 2) + 0xd0050000)
+#define HENC_SCRATCH_M                             ((0x1ad6  << 2) + 0xd0050000)
+#define HENC_SCRATCH_N                             ((0x1ad7  << 2) + 0xd0050000)
+// bit [7:0] data_feed_buff_id
+#define IE_DATA_FEED_BUFF_INFO                     ((0x1ad8  << 2) + 0xd0050000)
+//
+// Closing file:  henc_regs.h
+//
+//------------------------------------------------------------------------------
+// VLC module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  vlc_regs.h
+//
+//========================================================================
+//  VLC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_VLC_CBUS_BASE = 0x0d
+// -----------------------------------------------
+// Bit[31:28] - henc_status
+// Bit[27:8] - reserved
+// Bit[7]    mc_hcmd_buff_enable
+// Bit[6]    mc_hcmd_use_mc_hcmd_buff
+// Bit[5]    mc_hcmd_use_mc_hcmd_hw_start
+// Bit[4]    no_mc_out_null_non_skipped_mb
+// Bit[3]    mc_out_even_skipped_mb
+// Bit[2] - hcmd_enable
+// Bit[1] - vlc_control_enable (0 will treat as soft_reset)
+// Bit[0] - vlc_input_enable (enable input interface)
+#define VLC_STATUS_CTRL                            ((0x1d00  << 2) + 0xd0050000)
+// Bit[31:16] - Reserved
+// Bit [15]  - enable_free_clk_mc_hcmd_buff
+// Bit [14]  - enable_free_clk_reg
+// Bit [13]  - enable_free_clk_stream
+// Bit [12]  - enable_free_clk_pre_buff
+// Bit [11]  - enable_free_clk_vb_buff
+// Bit [10]  - enable_free_clk_dc_input
+// Bit [9]   - enable_free_clk_input
+// Bit [8]   - enable_free_clk_mv_cal
+// Bit [7]   - enable_free_clk_status
+// Bit [6]   - enable_free_clk_mc_dblk_cmd_if
+// Bit [5]   - disable_mvd_enc_finished
+// Bit [4]   - I16MB_share_ipred_mode_with_I4MB
+// Bit [3]   - fixed_picture_qp
+// Bit [2]   - use_set_b8_mode ( not used now)
+// Bit [1]   - use_set_mb_skip_run
+// Bit [0]   - pop_coeff_even_all_zero
+#define VLC_CONFIG                                 ((0x1d01  << 2) + 0xd0050000)
+// --------------------------------------------
+// Bitstream DDR Interface
+// --------------------------------------------
+#define VLC_VB_START_PTR                           ((0x1d10  << 2) + 0xd0050000)
+#define VLC_VB_END_PTR                             ((0x1d11  << 2) + 0xd0050000)
+#define VLC_VB_WR_PTR                              ((0x1d12  << 2) + 0xd0050000)
+// Read Only, VLC_VB_SW_RD_PTR or VLC_VB_HW_RD_PTR
+#define VLC_VB_RD_PTR                              ((0x1d13  << 2) + 0xd0050000)
+#define VLC_VB_SW_RD_PTR                           ((0x1d14  << 2) + 0xd0050000)
+// Read Only
+#define VLC_VB_LEFT                                ((0x1d15  << 2) + 0xd0050000)
+// VB FIFO Control
+// bit  [31:24] vb_full_int_enable_cpu[7:0] 
+// bit  [23:16] vb_full_int_enable_amrisc[7:0] 
+//   -bit 23 Video BUFFER LEFT < 0x400 Bytes
+//   -bit 22 Video BUFFER LEFT < 0x200 Bytes
+//   -bit 21 Video BUFFER LEFT < 0x100 Bytes
+//   -bit 20 Video BUFFER LEFT < 0x80 Bytes
+//   -bit 19 Video BUFFER LEFT < 0x40 Bytes
+//   -bit 18 Video BUFFER LEFT < 0x20 Bytes
+//   -bit 17 vbfifo left  < 16 double words (8x64bits)
+//   -bit 16 vbfifo left  < 8 double words (4x64bits)
+// bit  [15]    wr_ptr_int_enable_cpu
+// bit  [14]    wr_ptr_int_enable_amrisc
+// bit  [13]    wr_ptr_int (Read Only, write 1 will clear)
+// bit  [12]    vb_full_int_enable_cpu(Read Only)
+// bit  [11]    vb_full_int_enable_amrisc(Read Only)
+// bit  [10]    reserved
+// bit  [9]     use_vb_hw_rd_ptr
+// bit  [8]     vb_always_ready Set to 1 to ignore vb_level blocking DDR write
+// bit  [7]     vb_ready_for_transfer (Read Only)
+// bit  [6]     data_ready_for_transfer (Read Only)
+// bits [5:3]   vb_endian       Set VB Endian inside DDR memory 
+// bit  [2]     vb_write_busy   Read Only - indicate DDR write busy
+// bit  [1]     vb_write_en     Set to 1 to enable writing data to DDR memory
+// bit  [0]     vb_soft_reset   Soft reset  
+#define VLC_VB_CONTROL                             ((0x1d16  << 2) + 0xd0050000)
+// bit 31    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request  // default : 0
+// bit 30    A_urgent  // default : 0
+// bit 29:24 A_brst_num // default : 0x3f
+// bit 23:22 reserved
+// bit 21:16 A_id  // default : 0x20 
+// bit 15:0  vb_left_hold // default : 0 
+#define VLC_VB_MEM_CTL                             ((0x1d17  << 2) + 0xd0050000)
+// vb_wr_ptr address to generate interrupt
+#define VLC_VB_INT_PTR                             ((0x1d18  << 2) + 0xd0050000)
+// bit[31:12] reserved
+// bit[11:0] vlc_wrrsp_count
+#define VLC_WRRSP                                  ((0x1d19  << 2) + 0xd0050000)
+#define VLC_TOTAL_BYTES                            ((0x1d1a  << 2) + 0xd0050000)
+// bit  [31:26] reserved
+// bit  [25]    vb_flush
+// bit  [24]    vb_reg_ready  
+// bit  [23:16] vb_buff_left     -- Read only
+// bit  [15:8]  vb_buff_wr_point -- RW
+// bit  [7:0]   vb_buff_rd_point -- RW
+#define VLC_VB_BUFF                                ((0x1d1b  << 2) + 0xd0050000)
+// bit[31]    flush_vlc_pre_buff
+// bit[30:27] reserved
+// bit[26:24] vb_pre_buff_level
+// bit[23:0]  vb_pre_buff_data[55:32] 
+#define VLC_VB_PRE_BUFF_HI                         ((0x1d1c  << 2) + 0xd0050000)
+// bit[31:0] vb_pre_buff_data[31:0]
+#define VLC_VB_PRE_BUFF_LOW                        ((0x1d1d  << 2) + 0xd0050000)
+// bit[31]    stream_encap_enable  // 0x0000(00-03) will be changed to 0x000003(00-03) if enabled
+// bit[30:29] stream_encap_delay   // delay bytes for encap used 
+// bit[28:24] stream_buff_point
+// bit[23:0]  stream_buff_data 
+#define VLC_STREAM_BUFF                            ((0x1d1e  << 2) + 0xd0050000)
+// bit[31]    push_stream_block - Read Only (Will set if vb_buff full)
+// bit[30]    push_stream_busy  - Read Only (busy when output one byte from stream_buf (max 2 clocks for 8 bits push)
+// bit[29:28] stream_encap_status - Read Only
+// bit[27:21] reserved
+// Long Mode : (Amrisc need movilo and mvihi high to set stream_info)
+//   bit[20:16] push_stream_long_length (0 or 31 : Mid or Short mode)
+//   bit[15:0]  push_stream_data
+// Mid Mode : (Amrisc need movi to set stream_info) 
+//   bit[15:12]] push_stream_mid_length (1-12 : mid mode active, 0-short mode, 15 - byte align)
+//   bit[11:0]  push_stream_data
+// Short Mode : (Amrisc can use mtspi to push stream directely)
+//   bit[7:5] push_stream_short_length (0-5 : short length, else - invalid)
+//   bit[4:0]  push_stream_data
+#define VLC_PUSH_STREAM                            ((0x1d1f  << 2) + 0xd0050000)
+// bit[15:8] ELEMENT_LENGTH
+// bit[7:1]  reserved
+// bit[0]  Write - push start, Read - Push Busy
+#define VLC_PUSH_ELEMENT                           ((0x1d20  << 2) + 0xd0050000)
+#define VLC_ELEMENT_DATA                           ((0x1d21  << 2) + 0xd0050000)
+// bit[7] hcmd_intra_use_sw_info
+// bit[6] hcmd_use_sw_info
+// bit[5] always_use_info_0_cbp_blk
+// bit[4] always_update_info_0_cbp_blk
+// bit[3] reset_left_mb_wr
+// bit[2] reset_top_mb_wr
+// bit[1] set_left_mb_wr
+// bit[0] set_top_mb_wr
+#define VLC_SPECIAL_CTL                            ((0x1d22  << 2) + 0xd0050000)
+// bit[28]    left_intra
+// bit[27:22] left_quant
+// bit[21:16] left_quant_c
+// bit[12]    top_intra
+// bit[11:6]  top_quant
+// bit[5:0]   top_quant_c
+#define VLC_HCMD_T_L_INFO                          ((0x1d23  << 2) + 0xd0050000)
+// bit[12]    cur_intra
+// bit[11:6]  cur_quant
+// bit[5:0]   cur_quant_c
+#define VLC_HCMD_CUR_INFO                          ((0x1d24  << 2) + 0xd0050000)
+// --------------------------------------------
+// Picture VLC 
+// --------------------------------------------
+// (&(int|(~AND_enable))|(|(int&OR_enable)))
+// bit[31]    OR interrupt Enable Reserved
+// bit[30]    OR interrupt Enable for mv_busy
+// bit[29]    OR interrupt Enable for b8_mode_busy
+// bit[28]    OR interrupt Enable for mb_skip_run_busy
+// bit[27]    OR interrupt Enable for cbp_busy
+// bit[26]    OR interrupt Enable for Reserved
+// bit[25]    OR interrupt Enable for Reserved
+// bit[24]    OR interrupt Enable for mb_info_busy
+// bit[23]    AND interrupt Enable Reserved
+// bit[22]    AND interrupt Enable for mv_busy
+// bit[21]    AND interrupt Enable for b8_mode_busy
+// bit[20]    AND interrupt Enable for mb_skip_run_busy
+// bit[19]    AND interrupt Enable for cbp_busy 
+// bit[18]    AND interrupt Enable for Reserved
+// bit[17]    AND interrupt Enable for Reserved        
+// bit[16]    AND interrupt Enable for mb_info_busy
+// bit[15]    OR interrupt Enable Reserved
+// bit[14]    OR interrupt Enable for mvd
+// bit[13]    OR interrupt Enable for b8_mode
+// bit[12]    OR interrupt Enable for mb_skip_run
+// bit[11]    OR interrupt Enable for cbp_ready
+// bit[10]    OR interrupt Enable for c_ipred_mode_ready
+// bit[9]     OR interrupt Enable for ipred_mode_ready
+// bit[8]     OR interrupt Enable for mb_info_ready
+// bit[7]     AND interrupt Enable Reserved
+// bit[6]     AND interrupt Enable for mvd
+// bit[5]     AND interrupt Enable for b8_mode
+// bit[4]     AND interrupt Enable for mb_skip_run
+// bit[3]     AND interrupt Enable for cbp_ready
+// bit[2]     AND interrupt Enable for c_ipred_mode_ready
+// bit[1]     AND interrupt Enable for ipred_mode_ready
+// bit[0]     AND interrupt Enable for mb_info_ready
+#define VLC_INT_CONTROL                            ((0x1d30  << 2) + 0xd0050000)
+// Bit[31:16] picture_height
+// Bit[15:0]  picture_width
+#define VLC_PIC_SIZE                               ((0x1d31  << 2) + 0xd0050000)
+// [31:16] Reserved
+// [15:3] pic_width_in_mbs_minus1
+// [2:0]  picture_type 
+#define VLC_PIC_INFO                               ((0x1d32  << 2) + 0xd0050000)
+// Bit[31:16] MB_NR
+// Bit[15:8] MBY
+// Bit[7:0] MBX
+#define VLC_PIC_POSITION                           ((0x1d33  << 2) + 0xd0050000)
+// Bit[31] MV_busy
+// Bit[30:6] Reserved
+// Bit[15] Reserved
+// Bit[14] vlc_input_MV_busy
+// Bit[13] vlc_input_b8_mode_busy
+// Bit[12] vlc_input_mb_skip_run_busy
+// Bit[11] vlc_input_cbp_busy
+// Bit[10] Reserved
+// Bit[9]  Reserved
+// Bit[8] vlc_input_mb_info_busy
+// Bit[7] Reserved
+// Bit[6] mvd
+// Bit[5] b8_mode
+// Bit[4] mb_skip_run
+// Bit[3] cbp
+// Bit[2] c_ipred_mode
+// Bit[1] ipred_mode
+// Bit[0] mb_info ( mb_type, mb_x, mb_y)
+#define VLC_INPUT_STATUS                           ((0x1d34  << 2) + 0xd0050000)
+// Bit[31:28] detected_mb_type
+// Bit[27:16] mb_y 
+// Bit[15:4]  mb_x 
+// Bit[3:0]   mb_type
+#define VLC_MB_INFO                                ((0x1d35  << 2) + 0xd0050000)
+// commnad 0 -- no pending
+// normal command + 1 is pending command
+//
+// bit 31:28 -- pending command 7
+// bit 27:24 -- pending command 6
+// bit 23:20 -- pending command 5
+// bit 19:16 -- pending command 4
+// bit 15:12 -- pending command 3
+// bit 11:8  -- pending command 2
+// bit  7:4  -- pending command 1
+// bit  3:0  -- pending command 0
+#define VLC_ENC_PEND_CMD                           ((0x1d36  << 2) + 0xd0050000)
+// For I Slice
+// Bit[31:16] Reserved
+// Bit[15:0] IntraType 
+#define HENC_TOP_INFO_0                            ((0x1d37  << 2) + 0xd0050000)
+#define HENC_LEFT_INFO_0                           ((0x1d38  << 2) + 0xd0050000)
+// For I Slice
+// Bit[31:24] V_nnz
+// Bit[23:16] U_nnz
+// Bit[15:0]  Y_nnz 
+#define HENC_TOP_INFO_1                            ((0x1d39  << 2) + 0xd0050000)
+#define HENC_LEFT_INFO_1                           ((0x1d3a  << 2) + 0xd0050000)
+// bit[63:0] ipred_mode
+#define VLC_IPRED_MODE_HI                          ((0x1d3b  << 2) + 0xd0050000)
+#define VLC_IPRED_MODE_LO                          ((0x1d3c  << 2) + 0xd0050000)
+// bit[15:8] SE delta quant 
+// bit[7:0]  UE delta quant
+#define VLC_DELTA_QP                               ((0x1d3d  << 2) + 0xd0050000)
+// bit[31:16] Reserved
+// bit[15:12] Reserved
+// bit[11:8] c_ipred_mode 
+// bit[7:0] cbp
+#define VLC_MB_HEADER_INFO                         ((0x1d3e  << 2) + 0xd0050000)
+// bit[31:16] mb_skip_run
+// bit[15:0]  b8_mode
+#define VLC_P_MB_HEADER_INFO                       ((0x1d3f  << 2) + 0xd0050000)
+// bit[31]    write_ptr_update
+// bit[30]    read_ptr_update
+// bit[29:20] coeff_buf_level
+// bit[19:10] coeff_buf_write_ptr
+// bit[9:0]   coeff_buf_read_ptr
+#define VLC_COEFF_BUF_STATUS                       ((0x1d40  << 2) + 0xd0050000)
+// bit[31:10] Reserved
+// bit[9:0] read_req_addr
+#define VLC_COEFF_RD_REQ                           ((0x1d41  << 2) + 0xd0050000)
+// bit[20]   - coeff_buf_read_finished
+// bit[19]   - coeff_first
+// bit[18:4] - coeff_level 
+// bit[3:0]  - coeff_run 
+#define VLC_COEFF                                  ((0x1d42  << 2) + 0xd0050000)
+// bit[31]    - coeff_info_ready
+// bit[30:25] - Reserved
+// bit[24:15] - block_begin_addr
+// bit[14:11] - trailing_one_sign
+// bit[10:6]  - total_coeff 
+// bit[5:4]   - trailing_ones 
+// bit[3:0]   - total_zeros
+#define VLC_COEFF_INFO                             ((0x1d43  << 2) + 0xd0050000)
+// bit[31]    write_ptr_update
+// bit[30]    read_ptr_update
+// bit[29:25] Reserved
+// bit[24:20] dc_buf_level -- 0-16
+// bit[19:15] Reserved
+// bit[14:10] dc_buf_write_ptr
+// bit[9:5]   Reserved
+// bit[4:0]   dc_buf_read_ptr
+#define VLC_DC_BUF_STATUS                          ((0x1d44  << 2) + 0xd0050000)
+// bit[31:10] Reserved
+// bit[9:4]   Reserved
+// bit[3:0]   read_req_addr
+#define VLC_DC_RD_REQ                              ((0x1d45  << 2) + 0xd0050000)
+// bit[31:17] - Reserved
+// bit[16]   - dc_first
+// bit[15:1] - dc_level 
+// bit[0]    - dc_type  0 - CDC, 1 - LDC
+#define VLC_DC                                     ((0x1d46  << 2) + 0xd0050000)
+// bit[31]    - dc_info_ready
+// bit[30:25] - Reserved
+// bit[24:20] - Reserved
+// bit[19:15] - dc_idx_begin_addr
+// bit[14:11] - dc_trailing_one_sign
+// bit[10:6]  - dc_total_coeff 
+// bit[5:4]   - dc_trailing_ones 
+// bit[3:0]   - dc_total_zeros
+#define VLC_DC_INFO                                ((0x1d47  << 2) + 0xd0050000)
+// bit[31:4]  - Reserved
+// bit[3:0]   - mv_rw_idx  (auto increment when read/write VLC_MV) 
+#define VLC_MV_INDEX                               ((0x1d48  << 2) + 0xd0050000)
+// bit[31:16] - MVY
+// bit[15:0]  - MVX
+#define VLC_MV                                     ((0x1d49  << 2) + 0xd0050000)
+// bit[31:16] - MVY
+// bitp15:0]  - MVX
+// Write to HENC_TOP_MV_0 will cause previous U->UL, UR->U, and UR write
+// Read will read U MV only 
+#define HENC_TOP_MV_0                              ((0x1d4a  << 2) + 0xd0050000)
+#define HENC_TOP_MV_1                              ((0x1d4b  << 2) + 0xd0050000)
+#define HENC_TOP_MV_2                              ((0x1d4c  << 2) + 0xd0050000)
+#define HENC_TOP_MV_3                              ((0x1d4d  << 2) + 0xd0050000)
+#define HENC_LEFT_MV_0                             ((0x1d4e  << 2) + 0xd0050000)
+#define HENC_LEFT_MV_1                             ((0x1d4f  << 2) + 0xd0050000)
+#define HENC_LEFT_MV_2                             ((0x1d50  << 2) + 0xd0050000)
+#define HENC_LEFT_MV_3                             ((0x1d51  << 2) + 0xd0050000)
+// Bit[31:1] Reserved
+// Bit[0] top_left_mv_ready
+#define TOP_LEFT_READY                             ((0x1d52  << 2) + 0xd0050000)
+// Bit[31:16] Reserved
+// Bit[15:0] mb_skip_run
+#define MB_SKIP_RUN                                ((0x1d53  << 2) + 0xd0050000)
+// Bit[31:16] Reserved
+// Bit[15]    Reserved
+// Bit[14:13] rd_struct // 00 - frame, 10 - top field, 11 - bottom field
+// Bit[12:11] wr_struct // 00 - frame, 10 - top field, 11 - bottom field
+// Bit[10:5]  mv_buff_id
+// Bit[4:0]   mv_ref
+#define VLC_HCMD_CONFIG                            ((0x1d54  << 2) + 0xd0050000)
+// Bit[9:0] h264_dblk_info
+#define VLC_HCMD_DBLK_INFO                         ((0x1d55  << 2) + 0xd0050000)
+// Bit[3:0] vlc_dbg_idx
+#define VLC_DBG_IDX                                ((0x1d56  << 2) + 0xd0050000)
+// Read Only
+#define VLC_DBG_READ                               ((0x1d57  << 2) + 0xd0050000)
+// [   29] RW jpeg_comp2_ac_table_sel.                                                      Default 0.
+// [   28] RW jpeg_comp2_dc_table_sel.                                                      Default 0.
+// [26:25] RW jpeg_comp2_cnt_max.                                                           Default 0.
+// [   24] RW jpeg_comp2_en. Set 1 if the scan will include component 2 (Cr).               Default 0.
+// [   21] RW jpeg_comp1_ac_table_sel.                                                      Default 0.
+// [   20] RW jpeg_comp1_dc_table_sel.                                                      Default 0.
+// [18:17] RW jpeg_comp1_cnt_max.                                                           Default 0.
+// [   16] RW jpeg_comp1_en. Set 1 if the scan will include component 1 (Cb).               Default 0.
+// [   13] RW jpeg_comp0_ac_table_sel.                                                      Default 0.
+// [   12] RW jpeg_comp0_dc_table_sel.                                                      Default 0.
+// [10: 9] RW jpeg_comp0_cnt_max.                                                           Default 0.
+// [    8] RW jpeg_comp0_en. Set 1 if the scan will include component 0 (Y).                Default 0.
+// [    1] W  jpeg_coeff_init. Write 1 to this bit to initialize JPEG run length encoder.
+// [    0] RW jpeg_en. 0=Disable JPEG encoder; 1=Enable JPEG encoder.                       Default 0.
+#define VLC_JPEG_CTRL                              ((0x1d58  << 2) + 0xd0050000)
+// [   13] RW jpeg_coeff_buf_overfl. Write this bit to 1 to clear overfl.
+// [   12] RW jpeg_coeff_buf_undrfl. Write this bit to 1 to clear undrfl.
+// [   11] R  jpeg_coeff_buf_full.
+// [   10] R  jpeg_coeff_buf_empty.
+// [ 8: 0] R  jpeg_coeff_buf_level.
+#define VLC_JPEG_COEFF_BUF_STAT                    ((0x1d59  << 2) + 0xd0050000)
+// [   16] RW JPEG HUFFMAN table access mode. 0=Write; 1=Read.  Default 1.
+// [ 8: 0] RW JPEG HUFFMAN table addr.                          Default 0.
+#define VLC_HUFFMAN_ADDR                           ((0x1d5a  << 2) + 0xd0050000)
+// [19: 0] RW JPEG HUFFMAN table data.
+#define VLC_HUFFMAN_DATA                           ((0x1d5b  << 2) + 0xd0050000)
+// bit[31:0] enc_mv_bits - including b8_mode and mvd
+#define VLC_ENC_MV_BITS                            ((0x1d5c  << 2) + 0xd0050000)
+// bit[31:0] enc_coeff_bits - including cbp, token, trailing_sign, coeff_enc, h264_totzeros, h264_run
+#define VLC_ENC_COEFF_BITS                         ((0x1d5d  << 2) + 0xd0050000)
+//
+// Closing file:  vlc_regs.h
+//
+//------------------------------------------------------------------------------
+// QDCT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  qdct_regs.h
+//
+//========================================================================
+//  QDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_QDCT_CBUS_BASE = 0x0f
+// -----------------------------------------------
+// bit[31:28] - mb_info_state
+#define QDCT_STATUS_CTRL                           ((0x1f00  << 2) + 0xd0050000)
+// bit[18]    - enable_free_clk_sad_top
+// bit[17]    - enable_free_clk_ie_top
+// bit[16]    - enable_free_clk_ie_sub
+// bit[15]    - enable_free_clk_mc_out
+// bit[14]    - enable_free_clk_i_pred_top
+// bit[13]    - enable_free_clk_idct_top
+// bit[12]    - enable_free_clk_iq_top
+// bit[11]    - enable_free_clk_q_top
+// bit[10]    - enable_free_clk_dc_buff_8
+// bit[9]     - enable_free_clk_dct_top
+// bit[8]     - enable_free_clk_mb_info
+// bit[7]     - enable_free_clk_mb_buff
+// bit[6]     - enable_free_clk_reg
+// bit[5]     - ignore_1_include_2nd_half_c
+// bit[4]     - ignore_1_include_2nd_half
+// bit[3]     - ignore_t_p8x8
+// bit[2]     - not_ignore_dc
+// bit[1]     - ignore_small_lac_intra
+// bit[0]     - disable_fast_zero_block
+#define QDCT_CONFIG                                ((0x1f01  << 2) + 0xd0050000)
+// bit[31]    - ignore_lac_coeff_en
+// bit[30:26] - ignore_lac_coeff_else
+// bit[25:21] - ignore_lac_coeff_2 
+// bit[20:16] - ignore_lac_coeff_1 
+// bit[15]    - ignore_cac_coeff_en
+// bit[14:10] - ignore_cac_coeff_else
+// bit[9:5]   - ignore_cac_coeff_2 
+// bit[4:0]   - ignore_cac_coeff_1 
+#define IGNORE_CONFIG                              ((0x1f02  << 2) + 0xd0050000)
+// bit[31]    - ignore_t_lac_coeff_en
+// bit[30:26] - ignore_t_lac_coeff_else
+// bit[25:21] - ignore_t_lac_coeff_2 
+// bit[20:16] - ignore_t_lac_coeff_1 
+// bit[15:0]  - Reserved
+#define IGNORE_CONFIG_2                            ((0x1f03  << 2) + 0xd0050000)
+// --------------------------------------------
+// MB DATA DDR Interface
+// --------------------------------------------
+#define QDCT_MB_START_PTR                          ((0x1f10  << 2) + 0xd0050000)
+#define QDCT_MB_END_PTR                            ((0x1f11  << 2) + 0xd0050000)
+#define QDCT_MB_WR_PTR                             ((0x1f12  << 2) + 0xd0050000)
+#define QDCT_MB_RD_PTR                             ((0x1f13  << 2) + 0xd0050000)
+#define QDCT_MB_LEVEL                              ((0x1f14  << 2) + 0xd0050000)
+// bit  [31]    reserved
+// bit  [30]    no_wait_after_q_cdc
+// bit  [29]    ie_start_int_enable
+// bit  [28]    ignore_t_p8x8
+// bit  [27]    zero_mc_out_null_non_skipped_mb
+// bit  [26]    no_mc_out_null_non_skipped_mb
+// bit  [25]    mc_out_even_skipped_mb
+// bit  [24]    mc_out_wait_cbp_ready
+// bit  [23]    mc_out_wait_mb_type_ready
+// bit  [22]    i_pred_int_enable
+// bit  [21]    intra_sat8_enable
+// bit  [20]    ie_sub_enable
+// bit  [19]    i_pred_enable
+// bit  [18]    iq_enable
+// bit  [17]    idct_enable
+// bit  [16]    no_zero_coeff_mb
+// bit  [15]    add_zero_coeff_block
+// bit  [14]    mb_pause_enable
+// bit  [13]    q_enable
+// bit  [12]    dct_enable
+// bit  [11]    ignore_magic_word
+// bit  [10]    mb_info_en
+// bit  [9]     mb_info_soft_reset
+// bit  [8]     mb_always_ready Set to 1 to ignore mb_level blocking DDR read
+// bit  [7]     mb_ready_for_transfer (Read Only)
+// bit  [6]     data_ready_for_transfer (Read Only)
+// bits [5:3]   mb_endian       Set MB Endian inside DDR memory 
+// bit  [2]     mb_read_busy   Read Only - indicate DDR read busy
+// bit  [1]     mb_read_en     Set to 1 to enable reading data from DDR memory
+// bit  [0]     mb_soft_reset   Soft reset  
+#define QDCT_MB_CONTROL                            ((0x1f15  << 2) + 0xd0050000)
+// bit 31    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request  // default : 0
+// bit 30    A_urgent  // default : 0
+// bit 29:24 A_brst_num // default : 0x3f
+// bit 23    reserved
+// bit 22    read_till_zero
+// bit 21:16 A_id  // default : 0x21 
+// bit 15:0  mb_level_hold // default : 0 
+#define QDCT_MB_MEM_CTL                            ((0x1f16  << 2) + 0xd0050000)
+// bit  [31:24] reserved
+// bit  [23:16] vb_buff_level     -- Read only
+// bit  [15:8]  vb_buff_wr_point -- RW
+// bit  [7:0]   vb_buff_rd_point -- RW
+#define QDCT_MB_BUFF                               ((0x1f17  << 2) + 0xd0050000)
+// bit [31:0] mb infor data begin magic word - default : 0xa55aaa55
+#define QDCT_MB_MAGIC_WORD                         ((0x1f18  << 2) + 0xd0050000)
+// Read Only Register
+// bit[19]   dct_ready_1
+// bit[18]   dct_ready_0
+// bit[17]   dct_rd_idx
+// bit[16]   dct_wr_idx
+// bit[15]   dct_srdy
+// bit[14]   dct_rrdy
+// bit[13]   Reserved
+// bit[12:8] dct_block_number 
+// bit[7:4]  dct_rw_addr 
+// bit[3:0]  dct_status
+#define QDCT_DCT_STATUS                            ((0x1f19  << 2) + 0xd0050000)
+// bit[3:0]  q_status
+#define QDCT_Q_STATUS                              ((0x1f1a  << 2) + 0xd0050000)
+// bit[31:3] Reserved
+// bit[2:0]  picture_type
+#define QDCT_PIC_INFO                              ((0x1f1b  << 2) + 0xd0050000)
+// bit[31:28] Reserved
+// bit[27:22] I_pic_quant_c
+// bit[21:16] I_pic_quant
+// bit[15]    reserved
+// bit[14:12] quant_rem_c
+// bit[11:8]  quant_per_c
+// bit[7]     reserved
+// bit[6:4]   quant_rem
+// bit[3:0]   quant_per
+#define QDCT_Q_QUANT_I                             ((0x1f1c  << 2) + 0xd0050000)
+// bit[31:28] Reserved
+// bit[27:22] P_pic_quant_c
+// bit[21:16] P_pic_quant
+// bit[15]    reserved
+// bit[14:12] quant_rem_c
+// bit[11:8]  quant_per_c
+// bit[7]     reserved
+// bit[6:4]   quant_rem
+// bit[3:0]   quant_per
+#define QDCT_Q_QUANT_P                             ((0x1f1d  << 2) + 0xd0050000)
+// bit[31]    mb_info_pause
+// bit[30:16] pause_mby
+// bit[15:0]  pause_mbx
+#define QDCT_MB_PAUSE_CTL                          ((0x1f1e  << 2) + 0xd0050000)
+// bit[31]   top_control_ready_i_pred
+// bit[30:28]top_dma_status   
+// bit[27]   top_control_ready_ie
+// bit[26:24]Reserved
+// bit[23]   ul_mb
+// bit[22]   right_mb
+// bit[21]   top_mb
+// bit[20]   left_mb
+// bit[19:8] mb_x
+// bit[7:6]  i_pred_ref_idx_L 
+// bit[5:4]  i_pred_ref_idx_UL 
+// bit[3:2]  i_pred_ref_idx_U
+// bit[1:0]  i_pred_ref_idx_UR 
+#define QDCT_TOP_CONTROL                           ((0x1f1f  << 2) + 0xd0050000)
+// bit[31:0] top_base_addr - DDR Memory start address for save top Pixel
+#define QDCT_TOP_BASE_MEM                          ((0x1f20  << 2) + 0xd0050000)
+// bit 15:13 Reserved
+// bit 12    A_urgent  // default : 0
+// bit 11:6  A_brst_num // default : 0x3f
+// bit 5:0   A_id  // default : 0x22
+#define QDCT_TOP_MEM_CTL                           ((0x1f21  << 2) + 0xd0050000)
+// bit [11:0] top_wrrsp_count
+#define QDCT_TOP_WRRSP                             ((0x1f22  << 2) + 0xd0050000)
+// Bit[3:0] qdct_dbg_idx
+#define QDCT_DBG_IDX                               ((0x1f23  << 2) + 0xd0050000)
+// Read Only
+#define QDCT_DBG_READ                              ((0x1f24  << 2) + 0xd0050000)
+// [19:18] RW jdct_inflow_ctrl. JPEG DCT input flow control.                                Default 0.
+//            0=No halt;
+//            1=DCT halts request at end of each 8x8 block;
+//            2=DCT halts request at end of each MCU.
+// [17:16] RW jpeg_coeff_last_sel.                                                          Default 0.
+//            Select at which point to finish processing, give update to AmRISC so it can control the next step.
+//            0=Mark last coeff at the end of an 8x8 block;
+//            1=Mark at the end of an MCU;
+//            2=Mark at the end of a scan.
+// [   15] RW jpeg_quant_sel_comp2. 0=Comp2 select Quantization table 0; 1=Select table 1.  Default 0.
+// [   14] RW jpeg_v_factor_comp2. Component 2's vertical sampling factor.                  Default 0.
+// [   13] RW jpeg_h_factor_comp2. Component 2's horizontal sampling factor.                Default 0.
+// [   12] RW jpeg_comp2_en. Set 1 if the scan will include component 2 (Cr).               Default 0.
+// [   11] RW jpeg_quant_sel_comp1. 0=Comp1 select Quantization table 0; 1=Select table 1.  Default 0.
+// [   10] RW jpeg_v_factor_comp1. Component 1's vertical sampling factor.                  Default 0.
+// [    9] RW jpeg_h_factor_comp1. Component 1's horizontal sampling factor.                Default 0.
+// [    8] RW jpeg_comp1_en. Set 1 if the scan will include component 1 (Cb).               Default 0.
+// [    7] RW jpeg_quant_sel_comp0. 0=Comp0 select Quantization table 0; 1=Select table 1.  Default 0.
+// [    6] RW jpeg_v_factor_comp0. Component 0's vertical sampling factor.                  Default 0.
+// [    5] RW jpeg_h_factor_comp0. Component 0's horizontal sampling factor.                Default 0.
+// [    4] RW jpeg_comp0_en. Set 1 if the scan will include component 0 (Y).                Default 0.
+// [ 3: 1] RW jdct_intr_sel. JPEG DCT interrupt select.                                     Default 0.
+//            0=Disable intr;
+//            1=Intr at end of each 8x8 block of DCT input;
+//            2=Intr at end of each MCU of DCT input;
+//            3=Intr at end of a scan of DCT input;
+//            4=Intr at end of each 8x8 block of DCT output;
+//            5=Intr at end of each MCU of DCT output;
+//            6=Intr at end of a scan of DCT output.
+// [    0] RW jpeg_en. 0=Disable JPEG QDCT; 1=Enable JPEG QDCT.                             Default 0.
+#define QDCT_JPEG_CTRL                             ((0x1f25  << 2) + 0xd0050000)
+// [29:16] RW jpeg_x_end.   Picture X end.      Default 0.
+// [13: 0] RW jpeg_x_start. Picture X start.    Default 0.
+#define QDCT_JPEG_X_START_END                      ((0x1f26  << 2) + 0xd0050000)
+// [29:16] RW jpeg_y_end.   Picture Y end.      Default 0.
+// [13: 0] RW jpeg_y_start. Picture Y start.    Default 0.
+#define QDCT_JPEG_Y_START_END                      ((0x1f27  << 2) + 0xd0050000)
+// [    8] RW JPEG QUANT table access mode. 0=Write; 1=Read.    Default 1.
+// [ 5: 0] RW JPEG QUANT table addr.                            Default 0.
+#define QDCT_JPEG_QUANT_ADDR                       ((0x1f28  << 2) + 0xd0050000)
+// [31: 0] RW JPEG QUANT table data.
+#define QDCT_JPEG_QUANT_DATA                       ((0x1f29  << 2) + 0xd0050000)
+// [    1] W  resume_jdct.
+//            Write 1 to this bit will resume JPEG input engine when previously
+//            it is halted by QDCT_JPEG_CTRL.jdct_inflow_ctrl.
+// [    0] W  jpeg_sof.
+//            Write 1 to this bit will start JPEG input engine.
+#define QDCT_JPEG_SOF_RESUME                       ((0x1f2a  << 2) + 0xd0050000)
+// [31:30] R  dct_st.       jdct_ctrl state. 0=IDLE; 1=WAIT; 2=DCT_REQ.
+// [29:28] R  mfdin_comp.   Current component at pixel request to MFDIN.
+// [27:14] R  mfdin_y.      Current Y at pixel request to MFDIN.
+// [13: 0] R  mfdin_x.      Current X at pixel request to MFDIN.
+#define QDCT_JPEG_DCT_STATUS0                      ((0x1f2b  << 2) + 0xd0050000)
+// [15:12] R  JPEG Quant read MEM select.
+// [11: 8] R  JPEG DCT2 write MEM select.
+// [ 7: 4] R  JPEG DCT2 read MEM select.
+// [ 3: 0] R  JPEG DCT1 write MEM select.
+#define QDCT_JPEG_DCT_STATUS1                      ((0x1f2c  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff1.  Default 13'h1D90; // 7568 = 4096 * sqrt(2) * (cos(Pi/8) + sin(Pi/8)) // 7569
+// [12: 0] RW jdct_coeff0.  Default 13'h16A1; // 5793 = 4096 * sqrt(2)
+#define QDCT_JPEG_DCT_COEFF01                      ((0x1f2d  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff3.  Default 13'h0C3F; // 3135 = 4096 * sqrt(2) * (cos(Pi/8) - sin(Pi/8))
+// [12: 0] RW jdct_coeff2.  Default 13'h08A9; // 2217 = 4096 * sqrt(2) * sin(Pi/8) // 2215
+#define QDCT_JPEG_DCT_COEFF23                      ((0x1f2e  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff5.  Default 13'h046A; // 1130 = 4096 * (cos(3Pi/16) - sin(3Pi/16))
+// [12: 0] RW jdct_coeff4.  Default 13'h1631; // 5681 = 4096 * (cos(3Pi/16) + sin(3Pi/16)) // 5682
+#define QDCT_JPEG_DCT_COEFF45                      ((0x1f2f  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff7.  Default 13'h0C92; // 3218 = 4096 * (cos(Pi/16) - sin(Pi/16))
+// [12: 0] RW jdct_coeff6.  Default 13'h12D0; // 4816 = 4096 * (cos(Pi/16) + sin(Pi/16))
+#define QDCT_JPEG_DCT_COEFF67                      ((0x1f30  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff9.  Default 13'h0FB1; // 4017 = 4096 * cos(Pi/16)
+// [12: 0] RW jdct_coeff8.  Default 13'h0D4E; // 3406 = 4096 * cos(3Pi/16)
+#define QDCT_JPEG_DCT_COEFF89                      ((0x1f31  << 2) + 0xd0050000)
+#define QDCT_I_PRED_REF_WR_IDX                     ((0x1f32  << 2) + 0xd0050000)
+#define QDCT_I_PRED_REF_WR_DATA                    ((0x1f33  << 2) + 0xd0050000)
+// IE/ME share same cbus_base as QDCT
+// 
+// bit[31]  active_ur_block
+// bit[30]  active_ul_block
+// bit[9]   ie_c_wait_ie_pause
+// bit[8:4] max_ie_result_buff_count 
+// bit[3]   ie_wait_for_ie_result  // use for (max_ie_result_buff_count == 0) to wait every block
+// bit[2]   reserved
+// bit[1]   ie_enable
+// bit[0]   ie_soft_reset
+#define IE_CONTROL                                 ((0x1f40  << 2) + 0xd0050000)
+// bit[31:12] Reserved
+// bit[11:0]  mb_y
+#define IE_MB_POSITION                             ((0x1f41  << 2) + 0xd0050000)
+// bit[31:16] me_skip_run
+// bit[15:8]  reserved
+// bit [7:4]  me_b8_mode
+// bit [3:0]  ie_me_mb_type
+#define IE_ME_MB_INFO                              ((0x1f42  << 2) + 0xd0050000)
+// bit[3]   ie_result_buff_enable
+// bit[2]   ie_result_buff_soft_reset
+// bit[1]   sad_enable
+// bit[0]   sad_soft_reset
+#define SAD_CONTROL                                ((0x1f43  << 2) + 0xd0050000)
+// bit[31:16] - ie_result_buff_count - read only
+// bit[14:12] -current_ie_result (pred_mode) - read only
+// bit[11]  top_control_data_buff_wr_ptr - rd/wr 
+// bit[10]  top_control_data_buff_rd_ptr - rd/wr 
+// bit[9:5] ie_result_buff_wr_ptr        - rd/wr
+// bit[4:0] ie_result_buff_rd_ptr        - rd/wr
+#define IE_RESULT_BUFFER                           ((0x1f44  << 2) + 0xd0050000)
+// bit[63:0] ie_i4_pred_mode
+#define IE_I4_PRED_MODE_HI                         ((0x1f45  << 2) + 0xd0050000)
+#define IE_I4_PRED_MODE_LO                         ((0x1f46  << 2) + 0xd0050000)
+// bit [31:9] reserved
+// bit [8:4] i_pred_block_number
+// bit [3:0] ie_c_pred_mode
+#define IE_C_PRED_MODE                             ((0x1f47  << 2) + 0xd0050000)
+// 31:16 - Left, 0-select ie_pixel, 1-select mc_data_out
+// 15:0  - Top,  0-select ie_pixel, 1-select mc_data_out
+#define IE_CUR_REF_SEL                             ((0x1f48  << 2) + 0xd0050000)
+// bit[31]  enable_f_skip_1_step_3
+// bit[30]  enable_f_skip_1_step_2
+// bit[29]  enable_f_skip_1_step_1
+// bit[28]  step_3_enable
+// bit[27]  step_2_sub_pixel
+// bit[26]  always_f_skip_step_3 
+// bit[25]  always_f_skip_step_2 
+// bit[24]  always_f_skip_step_1
+// bit[23]  half_pixel_only
+// bit[22:11] reserved
+// bit[10:9] mv_flexable_ctl 00:0x40, 01:0x80, 10:0xc0, 11 : 0x100
+// bit[8]   no_md_ab_rd
+// bit[7]   use_dct_state
+// bit[6]   enable_free_clk_me_ctl
+// bit[5]   enable_free_clk_me_ab
+// bit[4]   enable_free_clk_me_cb
+// bit[3]   reserved
+// bit[2]   me_done_int_enable
+// bit[1]   me_enable
+// bit[0]   me_soft_reset
+#define ME_CONTROL                                 ((0x1f49  << 2) + 0xd0050000)
+// bit[31:28] Reserved
+// bit[27:16] me_start_mby
+// bit[15:12] Reserved
+// bit[11:0]  me_start_mbx
+#define ME_START_POSITION                          ((0x1f4a  << 2) + 0xd0050000)
+// bit [31:28] me_status - Read only
+// bit [27:24] me_cb_status  // current buffer
+// bit [23:20] me_ab_status  // anc buffer
+// bit [19]    Reserved
+// bit [18:16] me_ab_wr_ptr  // read only
+// bit [15:4]  me_last_mbx 
+// bit [3:1]   me_ab_rd_ptr  // read only
+// bit [0]     me_action
+#define ME_STATUS                                  ((0x1f4b  << 2) + 0xd0050000)
+// all Read-only
+// bit [31:28] Reserved
+// bit [27:16] me_ab_mbx
+// bit [15:14] me_cb_wr_ptr
+// bit [13:12] me_cb_rd_ptr
+// bit [11:0]  me_cb_mbx
+#define ME_DEBUG                                   ((0x1f4c  << 2) + 0xd0050000)
+// bit[29:24] step_3_skip_line 
+// bit[23:18] step_2_skip_line 
+// bit[17:12] step_1_skip_line 
+// bit[11:6]  step_0_skip_line 
+// bit[5:0]   read_skip_line 
+#define ME_SKIP_LINE                               ((0x1f4d  << 2) + 0xd0050000)
+// bit 15:13 Reserved
+// bit 12    A_urgent  // default : 0
+// bit 11:6  A_brst_num // default : 0x3f
+// bit 5:0   A_id  // default : 0x23
+#define ME_AB_MEM_CTL                              ((0x1f4e  << 2) + 0xd0050000)
+// bit[31:24] anc_pic_canvas
+// bit[23:12] max_me_mby_num
+// bit[11:0]  max_me_mbx_num 
+#define ME_PIC_INFO                                ((0x1f4f  << 2) + 0xd0050000)
+// bit [23:12] me_sad_enough_1
+// bit [11:0]  me_sad_enough_0
+#define ME_SAD_ENOUGH_01                           ((0x1f50  << 2) + 0xd0050000)
+// bit [23:12] me_sad_enough_3
+// bit [11:0]  me_sad_enough_2
+#define ME_SAD_ENOUGH_23                           ((0x1f51  << 2) + 0xd0050000)
+// bit [21:10] me_step0_big_sad
+// bit [9:5] me_step0_close_mv_y 
+// bit [4:0] me_step0_close_mv_x 
+#define ME_STEP0_CLOSE_MV                          ((0x1f52  << 2) + 0xd0050000)
+// bit[31:24] force_skip_sad_3
+// bit[23:16] force_skip_sad_2
+// bit[15:08] force_skip_sad_1
+// bit[07:00] force_skip_sad_0
+#define ME_F_SKIP_SAD                              ((0x1f53  << 2) + 0xd0050000)
+// bit[31:24] force_skip_weight_3
+// bit[23:16] force_skip_weight_2
+// bit[15:08] force_skip_weight_1
+// bit[07:00] force_skip_weight_0
+#define ME_F_SKIP_WEIGHT                           ((0x1f54  << 2) + 0xd0050000)
+// Merge when (
+//              (flex & me_merge_flex_en) | 
+//              (big_sad & me_merge_sad_en)|
+//              ((~me_merge_flex_en)&(~me_merge_sad_en))
+//            ) & 
+//            ( small_mv_diff |(~me_merge_small_mv_en))
+//            & (me_merge_flex_en | me_merge_sad_en | me_merge_small_mv_en)
+// bit[31]   me_merge_mv_en_16
+// bit[30]   me_merge_small_mv_en_16
+// bit[29]   me_merge_flex_en_16
+// bit[28]   me_merge_sad_en_16
+// bit[27]   me_merge_mv_en_8
+// bit[26]   me_merge_small_mv_en_8
+// bit[25]   me_merge_flex_en_8
+// bit[24]   me_merge_sad_en_8
+// bit[23:18] me_merge_mv_diff_16
+// bit[17:12] me_merge_mv_diff_8
+// bit[11:0] me_merge_min_sad
+#define ME_MV_MERGE_CTL                            ((0x1f55  << 2) + 0xd0050000)
+// bit[31:24] mv_step_weight_1 
+// bit[23:16] mv_pre_weight_1 
+// bit [15:0] mv_step_weight_0
+// bit[7:0]   mv_pre_weight_0 
+#define ME_MV_WEIGHT_01                            ((0x1f56  << 2) + 0xd0050000)
+// bit[31:24] mv_step_weight_3 
+// bit[23:16] mv_pre_weight_3
+// bit[15:8]  mv_step_weight_2 
+// bit[7:0]   mv_pre_weight_2
+#define ME_MV_WEIGHT_23                            ((0x1f57  << 2) + 0xd0050000)
+// bit[31:24] me_sad_range_inc_3
+// bit[23:16] me_sad_range_inc_2
+// bit[15:8] me_sad_range_inc_1
+// bit[7:0] me_sad_range_inc_0
+#define ME_SAD_RANGE_INC                           ((0x1f58  << 2) + 0xd0050000)
+// bit[31:19]  reserved
+// bit[18]     sub_relative_any_1_en
+// bit[17]     sub_relative_any_2_en
+// bit[16]     sub_relative_any_3_en
+// bit[15]     sub_relative_any_4_en
+// bit[14]     sub_relative_any_h_en
+// bit[13]     sub_make_non_flex_fix
+// bit[12]     sub_make_big_non_flex_fix
+// bit[11:8]   sub_normal_mv_diff_16
+// bit[7:4]    sub_normal_mv_diff_8
+// bit[3:2]    Reserved
+// bit[1]      sub_merge_enable_16
+// bit[0]      sub_merge_enable_8
+#define ME_SUB_MERGE_CTL                           ((0x1f59  << 2) + 0xd0050000)
+// bit[31:28]  sub_ref_mv_diff_near
+// bit[27:24]  sub_ref_mv_diff_near_flex
+// bit[23:20]  sub_ref_mv_diff
+// bit[19:16]  sub_ref_mv_diff_flex
+// bit[15:8]   sub_ref_mv_near_weight
+// bit[7:0]    sub_ref_mv_weight
+#define ME_SUB_REF_MV_CTL                          ((0x1f5a  << 2) + 0xd0050000)
+// bit[31:24]  sub_weight_max_sad
+// bit[23:16]  sub_any_range_sad
+// bit[15:8]   sub_any_min_sad
+// bit[7:0]    sub_any_max_sad
+#define ME_SUB_ANY_WEIGHT_SAD                      ((0x1f5b  << 2) + 0xd0050000)
+// bit[31:24]  sub_fix_sad
+// bit[23:16]  sub_fix_diff_sad
+// bit[15:8]   sub_sad_flex_adj
+// bit[7:0]    sub_big_non_flex_fix_sad
+#define ME_SUB_FIX_SAD                             ((0x1f5c  << 2) + 0xd0050000)
+// bit[31:24]  sub_fix_min_sad
+// bit[23:16]  sub_fix_min_diff_sad
+// bit[15:8]   sub_fix_min_sad_2
+// bit[7:0]    sub_fix_min_diff_sad_2
+#define ME_SUB_FIX_MIN_SAD                         ((0x1f5d  << 2) + 0xd0050000)
+// bit[31:24]  sub_snap_to_ref_max_sad
+// bit[23]     sub_snap_to_ref_non_flex
+// bit[22:16]  sub_snap_to_ref_mv_diff
+// bit[15:4]   sub_glitch_mv_sad
+// bit[3:0]    sub_glitch_mv_diff
+#define ME_SUB_SNAP_GLITCH                         ((0x1f5e  << 2) + 0xd0050000)
+// bit[31:20]  sad_act_limit
+// bit[19:8]   s_a_any_sad
+// bit[7]      Reserved
+// bit[6:5]    sub_merge_method
+// bit[4]      use_sub_act_result
+// bit[3]      s_a_rnd
+// bit[2]      Reserved
+// bit[1]      sub_act_en_16
+// bit[0]      sub_act_en
+#define ME_SUB_ACT_CTL                             ((0x1f5f  << 2) + 0xd0050000)
+//
+// Closing file:  qdct_regs.h
+//
+//------------------------------------------------------------------------------
+// HCODEC MDEC module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hcodec_mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_HDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+//`define HCODEC_MC_CTRL_REG         8'h00
+//`define HCODEC_MC_MB_INFO          8'h01
+//`define HCODEC_MC_PIC_INFO         8'h02
+//`define HCODEC_MC_HALF_PEL_ONE     8'h03
+//`define HCODEC_MC_HALF_PEL_TWO     8'h04
+//`define HCODEC_POWER_CTL_MC        8'h05
+//
+//`define HCODEC_MC_CMD			    8'h06
+//`define HCODEC_MC_CTRL0			8'h07
+//`define HCODEC_MC_PIC_W_H  	    8'h08     
+//`define HCODEC_MC_STATUS0		    8'h09
+//`define HCODEC_MC_STATUS1		    8'h0a
+//`define HCODEC_MC_CTRL1			8'h0b
+//`define HCODEC_MC_MIX_RATIO0	    8'h0c
+//`define HCODEC_MC_MIX_RATIO1	    8'h0d
+//`define HCODEC_MC_DP_MB_XY  	    8'h0e     //read only
+//`define HCODEC_MC_OM_MB_XY  	    8'h0f     //read only
+//
+//`define HCODEC_MC_MPORT_CTRL  	    8'h40    
+//`define HCODEC_MC_MPORT_DAT  	    8'h41     
+//`define HCODEC_MC_WT_PRED_CTRL  	8'h42     
+//`define HCODEC_MC_MBBOT_ST_EVEN_ADDR 8'h44     
+//`define HCODEC_MC_MBBOT_ST_ODD_ADDR 8'h45     
+//`define HCODEC_MC_DPDN_MB_XY        8'h46    //read only     
+//`define HCODEC_MC_OMDN_MB_XY        8'h47    //read only     
+//`define HCODEC_MC_HCMDBUF_H        8'h48     
+//`define HCODEC_MC_HCMDBUF_L        8'h49     
+//`define HCODEC_MC_HCMD_H           8'h4a     //read only     
+//`define HCODEC_MC_HCMD_L           8'h4b     //read only     
+//`define HCODEC_MC_IDCT_DAT         8'h4c 
+//
+//`define HCODEC_MC_CTRL_GCLK_CTRL   8'h4d 
+//`define HCODEC_MC_OTHER_GCLK_CTRL  8'h4e 
+//
+////Bit 29:24, mbbot thread ID and token 
+////Bit 21:16, mc read/write thread ID and token 
+////Bit 13:8,  mbbot pre-arbitor burst number 
+////Bit 5:0,   mc pre-arbitor burst number 
+//`define HCODEC_MC_CTRL2            8'h4f 
+//
+//// `define HCODEC_DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//
+////`define HCODEC_ANC1_CANVAS_ADDR      8'h80
+////`define HCODEC_ANC2_CANVAS_ADDR      8'h81
+//
+////`define HCODEC_REC_CANVAS_ADDR       8'h89
+//
+////`define HCODEC_MDEC_PIC_W          8'h8c
+////`define HCODEC_MDEC_PIC_H          8'h8d
+//`define HCODEC_MDEC_PIC_DC_CTRL    8'h8e
+//`define HCODEC_MDEC_PIC_DC_STATUS  8'h8f
+//
+//`define HCODEC_ANC0_CANVAS_ADDR      8'h90
+//`define HCODEC_ANC1_CANVAS_ADDR      8'h91
+//`define HCODEC_ANC2_CANVAS_ADDR      8'h92
+//`define HCODEC_ANC3_CANVAS_ADDR      8'h93
+//`define HCODEC_ANC4_CANVAS_ADDR      8'h94
+//`define HCODEC_ANC5_CANVAS_ADDR      8'h95
+//`define HCODEC_ANC6_CANVAS_ADDR      8'h96
+//`define HCODEC_ANC7_CANVAS_ADDR      8'h97
+//`define HCODEC_ANC8_CANVAS_ADDR      8'h98
+//`define HCODEC_ANC9_CANVAS_ADDR      8'h99
+//`define HCODEC_ANC10_CANVAS_ADDR     8'h9a
+//`define HCODEC_ANC11_CANVAS_ADDR     8'h9b
+//`define HCODEC_ANC12_CANVAS_ADDR     8'h9c
+//`define HCODEC_ANC13_CANVAS_ADDR     8'h9d
+//`define HCODEC_ANC14_CANVAS_ADDR     8'h9e
+//`define HCODEC_ANC15_CANVAS_ADDR     8'h9f
+//`define HCODEC_ANC16_CANVAS_ADDR     8'ha0
+//`define HCODEC_ANC17_CANVAS_ADDR     8'ha1
+//`define HCODEC_ANC18_CANVAS_ADDR     8'ha2
+//`define HCODEC_ANC19_CANVAS_ADDR     8'ha3
+//`define HCODEC_ANC20_CANVAS_ADDR     8'ha4
+//`define HCODEC_ANC21_CANVAS_ADDR     8'ha5
+//`define HCODEC_ANC22_CANVAS_ADDR     8'ha6
+//`define HCODEC_ANC23_CANVAS_ADDR     8'ha7
+//`define HCODEC_ANC24_CANVAS_ADDR     8'ha8
+//`define HCODEC_ANC25_CANVAS_ADDR     8'ha9
+//`define HCODEC_ANC26_CANVAS_ADDR     8'haa
+//`define HCODEC_ANC27_CANVAS_ADDR     8'hab
+//`define HCODEC_ANC28_CANVAS_ADDR     8'hac
+//`define HCODEC_ANC29_CANVAS_ADDR     8'had
+//`define HCODEC_ANC30_CANVAS_ADDR     8'hae
+//`define HCODEC_ANC31_CANVAS_ADDR     8'haf
+//
+//`define HCODEC_DBKR_CANVAS_ADDR      8'hb0
+//`define HCODEC_DBKW_CANVAS_ADDR      8'hb1
+//`define HCODEC_REC_CANVAS_ADDR       8'hb2
+//
+////28:24, read/write, current canvas idx, used in h264 only now
+////23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+//`define HCODEC_CURR_CANVAS_CTRL      8'hb3
+//
+//`define HCODEC_MDEC_PIC_DC_THRESH    8'hb8
+//`define HCODEC_MDEC_PICR_BUF_STATUS  8'hb9
+//`define HCODEC_MDEC_PICW_BUF_STATUS  8'hba
+//`define HCODEC_MCW_DBLK_WRRSP_CNT    8'hbb
+//
+//`define HCODEC_AV_SCRATCH_0          8'hc0
+//`define HCODEC_AV_SCRATCH_1          8'hc1
+//`define HCODEC_AV_SCRATCH_2          8'hc2
+//`define HCODEC_AV_SCRATCH_3          8'hc3
+//`define HCODEC_AV_SCRATCH_4          8'hc4
+//`define HCODEC_AV_SCRATCH_5          8'hc5
+//`define HCODEC_AV_SCRATCH_6          8'hc6
+//`define HCODEC_AV_SCRATCH_7          8'hc7
+//`define HCODEC_AV_SCRATCH_8          8'hc8
+//`define HCODEC_AV_SCRATCH_9          8'hc9
+//`define HCODEC_AV_SCRATCH_A          8'hca
+//`define HCODEC_AV_SCRATCH_B          8'hcb
+//`define HCODEC_AV_SCRATCH_C          8'hcc
+//`define HCODEC_AV_SCRATCH_D          8'hcd
+//`define HCODEC_AV_SCRATCH_E          8'hce
+//`define HCODEC_AV_SCRATCH_F          8'hcf
+//`define HCODEC_AV_SCRATCH_G          8'hd0
+//`define HCODEC_AV_SCRATCH_H          8'hd1
+//`define HCODEC_AV_SCRATCH_I          8'hd2
+//`define HCODEC_AV_SCRATCH_J          8'hd3
+//`define HCODEC_AV_SCRATCH_K          8'hd4
+//`define HCODEC_AV_SCRATCH_L          8'hd5
+//`define HCODEC_AV_SCRATCH_M          8'hd6
+//`define HCODEC_AV_SCRATCH_N          8'hd7
+//
+//// bit[29:24] A_brst_num_co_mb
+//// bit[21:16] A_id_co_mb
+//// bit[11:0] wrrsp_count_co_mb
+//`define HCODEC_WRRSP_CO_MB           8'hd8 
+//// bit[29:24] A_brst_num_dcac
+//// bit[21:16] A_id_dcac
+//// bit[11:0] wrrsp_count_dcac
+//`define HCODEC_WRRSP_DCAC            8'hd9 
+//
+////======================================
+////  MC Control Register Bits
+////
+////======================================
+//// For bits, just copy the defines...don't translate to addresses
+//    `define HCODEC_MC_ENABLE	    16'h0001
+//    //`define MC_RESET	    16'h0002
+//    `define HCODEC_SKIP_MB		    16'h0004
+//
+////======================================
+////  MB Info Register Bits
+////
+////======================================
+//    `define HCODEC_INTRA_MB	    16'h0001
+//
+//    `define HCODEC_BWD_PRED	    16'h0004
+//    `define HCODEC_FWD_PRED	    16'h0008
+//
+//    `define HCODEC_FLD_MOT		    16'h0100
+//    `define HCODEC_FRM_16x8_MOT	16'h0200
+//    `define HCODEC_DUAL_PRM_MOT	16'h0300
+//
+//    `define HCODEC_FRM_DCT		    16'h0000	    // Bit 10
+//    `define HCODEC_FLD_DCT		    16'h0400
+//
+////======================================
+////  MB Info Register Bits
+////
+////======================================
+//    `define HCODEC_I_PIC		    16'h0001
+//    `define HCODEC_P_PIC		    16'h0002
+//    `define HCODEC_B_PIC		    16'h0003
+//    
+//    `define HCODEC_FLD_PIC		    16'h0000	    // Bit 8
+//    `define HCODEC_FRM_PIC		    16'h0100	    
+//
+////========================================================================
+//// DBLK Register:  12'h950 - 12'h97f 
+////========================================================================
+//`define HCODEC_DBLK_RST                8'h50
+//`define HCODEC_DBLK_CTRL               8'h51
+//`define HCODEC_DBLK_MB_WID_HEIGHT      8'h52
+//`define HCODEC_DBLK_STATUS             8'h53
+//`define HCODEC_DBLK_CMD_CTRL           8'h54
+//`define HCODEC_DBLK_MB_XY              8'h55
+//`define HCODEC_DBLK_QP                 8'h56
+//`define HCODEC_DBLK_Y_BHFILT           8'h57
+//`define HCODEC_DBLK_Y_BHFILT_HIGH      8'h58
+//`define HCODEC_DBLK_Y_BVFILT           8'h59
+//`define HCODEC_DBLK_CB_BFILT           8'h5a
+//`define HCODEC_DBLK_CR_BFILT           8'h5b
+//`define HCODEC_DBLK_Y_HFILT            8'h5c
+//`define HCODEC_DBLK_Y_HFILT_HIGH       8'h5d
+//`define HCODEC_DBLK_Y_VFILT            8'h5e
+//`define HCODEC_DBLK_CB_FILT            8'h5f
+//`define HCODEC_DBLK_CR_FILT            8'h60
+//`define HCODEC_DBLK_BETAX_QP_SEL       8'h61
+//`define HCODEC_DBLK_CLIP_CTRL0         8'h62
+//`define HCODEC_DBLK_CLIP_CTRL1         8'h63
+//`define HCODEC_DBLK_CLIP_CTRL2         8'h64
+//`define HCODEC_DBLK_CLIP_CTRL3         8'h65
+//`define HCODEC_DBLK_CLIP_CTRL4         8'h66
+//`define HCODEC_DBLK_CLIP_CTRL5         8'h67
+//`define HCODEC_DBLK_CLIP_CTRL6         8'h68
+//`define HCODEC_DBLK_CLIP_CTRL7         8'h69
+//`define HCODEC_DBLK_CLIP_CTRL8         8'h6a
+//
+//`define HCODEC_DBLK_STATUS1            8'h6b
+//`define HCODEC_DBLK_GCLK_FREE          8'h6c
+//`define HCODEC_DBLK_GCLK_OFF           8'h6d
+//
+//`define HCODEC_DBLK_AVSFLAGS           8'h6e
+//
+//// bit 15:0
+//`define HCODEC_DBLK_CBPY               8'h70
+//// bit 11:8 -- deblk_cbpy_bottom
+//// bit 7:4 -- deblk_cbpy_left
+//// bit 3:0 -- deblk_cbpy_top
+//`define HCODEC_DBLK_CBPY_ADJ           8'h71
+//// bit 7:0 -- deblk_cbpc
+//`define HCODEC_DBLK_CBPC               8'h72
+//// bit 15 -- bottom_mb
+//// bit 14 -- left_mb
+//// bit 13 -- top_mb
+//// bit 12 -- reserved
+//// bit 11:8 -- deblk_cbpc_bottom
+//// bit 7:4 -- deblk_cbpc_left
+//// bit 3:0 -- deblk_cbpc_top
+//`define HCODEC_DBLK_CBPC_ADJ           8'h73
+//// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0} 
+//// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0} 
+//`define HCODEC_DBLK_VHMVD              8'h74
+//// bit 13:12 -- right_vmvd
+//// bit 11 -- right_above_vmvd
+//// bit 10 -- left_below_hmvd
+//// bit 9 -- disable_dblk_luma  
+//// bit 8 -- disable_dblk_chroma
+//// bit 7 -- bBelowRefDiff
+//// bit 6 -- bLeftRefDiff
+//// bit 5 -- bAboveRefDiff
+//// bit 4 -- reserved
+//// bit 3 -- s_below
+//// bit 2 -- s_left
+//// bit 1 -- s_above
+//// bit 0 -- s 
+//`define HCODEC_DBLK_STRONG             8'h75
+//// bit 14:10 -- PQUANT 
+//// bit 9:5 -- left_PQUANT 
+//// bit 4:0 -- top_PQUANT 
+//`define HCODEC_DBLK_RV8_QUANT          8'h76
+//
+//`define HCODEC_DBLK_CBUS_HCMD2         8'h77
+//`define HCODEC_DBLK_CBUS_HCMD1         8'h78
+//`define HCODEC_DBLK_CBUS_HCMD0         8'h79
+//`define HCODEC_DBLK_VLD_HCMD2          8'h7a
+//`define HCODEC_DBLK_VLD_HCMD1          8'h7b
+//`define HCODEC_DBLK_VLD_HCMD0          8'h7c
+//
+//`define HCODEC_DBLK_OST_YBASE          8'h7d
+//`define HCODEC_DBLK_OST_CBCRDIFF       8'h7e
+//
+////13:8 dblk thread ID and token 
+////5:0  dblk prearbitor burst num
+//`define HCODEC_DBLK_CTRL1              8'h7f
+//
+////DBLK last address 12'h97f
+//
+// Closing file:  hcodec_mdec_regs.h
+//
+//------------------------------------------------------------------------------
+// HCODEC VLD module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hcodec_vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+//
+//`define HCODEC_VLD_STATUS_CTRL     8'h00
+////
+//// bit 10 -- use_old_shift_en
+//// bit 9 -- output_mv_not_pmv
+//// bit 8:5 -- force_zigzag
+//// bit 4 -- force_zigzag_en
+//// bit 3 -- disable_viff_anempty_int
+//// bit 2 -- disable_m2_ac_coeff_one_cycle
+//// bit 1 -- forced_reset  force reset pmv
+//// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+//`define HCODEC_MPEG1_2_REG         8'h01
+//`define HCODEC_F_CODE_REG          8'h02
+//`define HCODEC_PIC_HEAD_INFO       8'h03
+//`define HCODEC_SLICE_VER_POS_PIC_TYPE  8'h04
+//`define HCODEC_QP_VALUE_REG        8'h05
+//`define HCODEC_MBA_INC             8'h06
+//`define HCODEC_MB_MOTION_MODE      8'h07
+////`define HCODEC_PACKET_BYTE_COUNT   8'h08
+//// bit 15 -- force_search_startcode_en
+//// bit 14 -- int_cpu_when_error (before do anything)
+//// bit 13 -- vld_error_reset
+//// bit 12 -- return_on_slice_header
+//// bit 6 -- jpeg_ff00_en 
+//// bit 5:0 -- vld_power_ctl
+//`define HCODEC_POWER_CTL_VLD       8'h08
+//
+//`define HCODEC_MB_WIDTH	    8'h09
+//`define HCODEC_SLICE_QP            8'h0a
+//// `define HCODEC_MB_X_MB_Y           8'h0b   // current MBX and MBY                  
+//`define HCODEC_PRE_START_CODE      8'h0b  // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define HCODEC_SLICE_START_BYTE_01 8'h0c  // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define HCODEC_SLICE_START_BYTE_23 8'h0d  // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define HCODEC_RESYNC_MARKER_LENGTH 8'h0e  // Does this exist in HW ? used in $ucode/mpeg4
+//
+//// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+//// bit[4:0] - buffer ID
+//// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+//`define HCODEC_DECODER_BUFFER_INFO  8'h0f  // Current Only Used for VC1 Interlace Field
+//
+//`define HCODEC_FST_FOR_MV_X        8'h10
+//`define HCODEC_FST_FOR_MV_Y        8'h11
+//`define HCODEC_SCD_FOR_MV_X        8'h12
+//`define HCODEC_SCD_FOR_MV_Y        8'h13
+//`define HCODEC_FST_BAK_MV_X        8'h14
+//`define HCODEC_FST_BAK_MV_Y        8'h15
+//`define HCODEC_SCD_BAK_MV_X        8'h16
+//`define HCODEC_SCD_BAK_MV_Y        8'h17
+//
+//// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+//// bit 3 -- reserved
+//// bit 2 -- weighting_prediction
+//// bit 1 -- mb_weighting_flag
+//// bit 0 -- slice_weighting_flag 
+//`define HCODEC_VLD_DECODE_CONTROL  8'h18
+//`define HCODEC_VLD_REVERVED_19     8'h19
+//
+//`define HCODEC_VIFF_BIT_CNT        8'h1a
+//`define HCODEC_BYTE_ALIGN_PEAK_HI  8'h1b 
+//`define HCODEC_BYTE_ALIGN_PEAK_LO  8'h1c
+//`define HCODEC_NEXT_ALIGN_PEAK     8'h1d  // Does this exist in HW ? used in $ucode/mpeg4
+//
+//// bit 19    : vc1_inv_intra_co_mb_ref_rd
+//// bit 18    : vc1_inv_co_mb_ref_rd
+//// bit 17    : vc1_inv_intra_co_mb_ref_wr
+//// bit 16    : vc1_inv_co_mb_ref_wr
+//// bit 15    : reserved
+//// bit 14    : avs_drop_enable
+//// bit 13:12 : avs_drop_ptr
+//// bit 11:8  : avs_demu_ctl_reg
+//// bit 7 : avs_enable
+//// bit 6 : disable_dblk_hcmd
+//// bit 5 : disable_mc_hcmd
+//// bit 4 : first_mode3_set enable
+//// bit 3 : first_mode3
+//// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+//// bit 0   : vc1_enable
+//`define HCODEC_VC1_CONTROL_REG     8'h1e
+//
+//`define HCODEC_PMV1_X              8'h20
+//`define HCODEC_PMV1_Y              8'h21
+//`define HCODEC_PMV2_X              8'h22
+//`define HCODEC_PMV2_Y              8'h23
+//`define HCODEC_PMV3_X              8'h24
+//`define HCODEC_PMV3_Y              8'h25
+//`define HCODEC_PMV4_X              8'h26
+//`define HCODEC_PMV4_Y              8'h27
+//// Can't use the same address for different defines
+//// Therefore, create a single define HCODEC_that covers both
+//// Only appears to be used in micro-code since the VLD hardware is 
+//// hard coded.
+//// `define HCODEC_M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+//// `define HCODEC_M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+//`define HCODEC_M4_TABLE_SELECT     8'h28  
+//`define HCODEC_M4_CONTROL_REG      8'h29
+//`define HCODEC_BLOCK_NUM           8'h2a  // Does this exist in HW ? Added from register_mp2.h
+//`define HCODEC_PATTERN_CODE        8'h2b  // Does this exist in HW ? Added from register_mp2.h
+//`define HCODEC_MB_INFO             8'h2c  // Does this exist in HW ? Added from register_mp2.h
+//`define HCODEC_VLD_DC_PRED         8'h2d  // Does this exist in HW ? Added from register_mp4.h
+//`define HCODEC_VLD_ERROR_MASK      8'h2e
+//`define HCODEC_VLD_DC_PRED_C       8'h2f  // Does this exist in HW ? Added from register_mp4.h
+//
+//`define HCODEC_LAST_SLICE_MV_ADDR  8'h30
+//`define HCODEC_LAST_MVX            8'h31
+//`define HCODEC_LAST_MVY            8'h32
+//
+//`define HCODEC_VLD_C38             8'h38
+//`define HCODEC_VLD_C39             8'h39
+//
+//`define HCODEC_VLD_STATUS          8'h3a  // Does this exist in HW ? used in $ucode/real/amrisc/rv.s
+//`define HCODEC_VLD_SHIFT_STATUS    8'h3b  // Does this exist in HW ? used in $ucode/real/amrisc/rv.s
+//// `define HCODEC_VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+//`define HCODEC_VOFF_STATUS         8'h3c  // Does this exist in HW ? used in $ucode/mpeg4
+//
+//`define HCODEC_VLD_C3D             8'h3d
+//
+//`define HCODEC_VLD_DBG_INDEX       8'h3e
+//
+//
+//// vld_buff_info -- (index == 0) 
+//// Bit[7:6]  mv_UR_ready_cnt;
+//// Bit[5]  vld_wr_idx
+//// Bit[4]  iq_rd_idx
+//// Bit[3]  vld_vi_block_rdy_1
+//// Bit[2]  vld_vi_block_rdy_2
+//// Bit[1]  voff_empty_1
+//// Bit[0]  voff_empty_2
+//
+//// cabac_buff_info_0 -- (index == 1) 
+//// Bit[31] shift_data_ready
+//// Bit[30:29] Reserved
+//// Bit[28:24] cabac_buffer_ptr
+//// Bit[23:0] cabac_buffer
+//
+//// cabac_buff_info_1 -- (index == 2) 
+//// Bit[31:29] Reserved
+//// Bit[28:20] Drange
+//// Bit[19:16] bin_count_4
+//// Bit[15:13] Reserved
+//// Bit[12:6] context_mem_do
+//// Bit[5:3] coeff_state
+//// Bit[2:0] mvd_state
+//
+//// h264_mv_present -- (index == 3) 
+//// Bit[31:16] mv_present_l0
+//// Bit[15:0] mv_present_l1
+//
+//// h264_mv_cal_info_0 -- (index == 4) 
+//// [31:28] mv_cal_state
+//// [27:24] direct_spatial_cnt
+//// Bit[23:21] Reserved
+//// Bit[20] mv_UR_ready_for_mv_cal
+//// Bit[19] co_mb_mem_ready_for_mv_cal
+//// Bit[18] mc_dblk_cmd_if_busy
+//// Bit[17] h264_co_mb_wr_busy
+//// Bit[16] H264_cbp_blk_ready
+//// Bit[15] mc_hcmd_rrdy
+//// Bit[14] mc_hcmd_srdy
+//// Bit[13] mc_cmd_if_ready
+//// Bit[12] mc_hcmd_mv_available
+//// Bit[11:8] mc_cmd_if_state
+//// Bit[7] dblk_hcmd_rrdy
+//// Bit[6] dblk_hcmd_srdy
+//// Bit[5] dblk_cmd_if_ready
+//// Bit[4] dblk_hcmd_mv_available
+//// Bit[3:0] dblk_cmd_if_state
+//
+//// h264_mv_cal_info_1 -- (index == 5) 
+////  Bit[31:29] Reserved
+////  Bit[28:24] total_mvd_num_l0
+////  Bit[23:21] Reserved
+////  Bit[20:16] mv_cal_ptr_l0
+////  Bit[15:13] Reserved
+////  Bit[12:8] mc_hcmd_ptr_l0
+////  Bit[7:5] Reserved
+////  Bit[4:0] dblk_hcmd_ptr_l0
+//
+//// h264_mv_cal_info_2 -- (index == 6) 
+////  Bit[31:29] Reserved
+////  Bit[28:24] total_mvd_num_l1
+////  Bit[23:21] Reserved
+////  Bit[20:16] mv_cal_ptr_l1
+////  Bit[15:13] Reserved
+////  Bit[12:8] mc_hcmd_ptr_l1
+////  Bit[7:5] Reserved
+////  Bit[4:0] dblk_hcmd_ptr_l1
+//
+//// h264_co_mb_info -- (index == 7)
+//// Bit[31:26] Reserved
+//// Bit[25] mv_scale_cal_busy
+//// Bit[24:20] co_mv_count
+//// Bit[19:16] co_mv_process_state
+//// Bit[15] h264_co_mb_rd_busy
+//// Bit[15] h264_co_mb_rd_ready
+//// Bit[13:12] co_mv_transfer_block_cnt
+//// Bit[11:8] co_mv_transfer_ptr
+//// Bit[7] co_mv_POC_l1_busy
+//// Bit[6] h264_weight_scale_cal_en
+//// Bit[5] weight_cal_busy
+//// Bit[4] weight_cal_not_finished
+//// Bit[3:0] weight_process_state
+//
+//`define HCODEC_VLD_DBG_DATA        8'h3f
+//// --------------------------------------------
+//// VIFIFO DDR Interface
+//// --------------------------------------------
+//// The VIFIFO start pointer into DDR memory is a 32-bit number
+//// The Start pointer will automatically be truncated to land on 
+//// an 8-byte boundary.  That is, bits [2:0] = 0;
+//`define HCODEC_VLD_MEM_VIFIFO_START_PTR        8'h40
+//// The current pointer points so some location between the START and END 
+//// pointers.  The current pointer is a BYTE pointer.  That is, you can 
+//// point to any BYTE address within the START/END range
+//`define HCODEC_VLD_MEM_VIFIFO_CURR_PTR         8'h41
+//`define HCODEC_VLD_MEM_VIFIFO_END_PTR          8'h42
+//`define HCODEC_VLD_MEM_VIFIFO_BYTES_AVAIL      8'h43
+//// VIFIFO FIFO Control
+//// bit  [31:24] viff_empty_int_enable_cpu[7:0] 
+//// bit  [23:16] viff_empty_int_enable_amrisc[7:0] 
+////   -bit 23 Video BUFFER < 0x400 Bytes
+////   -bit 22 Video BUFFER < 0x200 Bytes
+////   -bit 21 Video BUFFER < 0x100 Bytes
+////   -bit 20 Video BUFFER < 0x80 Bytes
+////   -bit 19 Video BUFFER < 0x40 Bytes
+////   -bit 18 Video BUFFER < 0x20 Bytes
+////   -bit 17 vififo  < 16 double words
+////   -bit 16 vififo  < 8 double words
+//// bit  [15:13] unused
+//// bit  [12]    A_urgent
+//// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+//// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+////                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+//// bit  [9]     Data Ready.     This bit is set when data can be popped
+//// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+////                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
+////                              After that you can pulse cntl_init to start over
+//// bit  [7]     init_with_cntl_init
+//// bit  [6]     reserved
+//// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+//// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+////                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+//// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+//// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+////                              and read masks, set this bit to 1 and then to 0
+////                              NOTE:  You don't need to pulse cntl_init if only the start address is
+////                              being changed
+//`define HCODEC_VLD_MEM_VIFIFO_CONTROL         8'h44
+//// --------------------------------------------
+//// VIFIFO Buffer Level Manager
+//// --------------------------------------------
+//`define HCODEC_VLD_MEM_VIFIFO_WP              8'h45 // Manual or Parser write pointer
+//`define HCODEC_VLD_MEM_VIFIFO_RP              8'h46
+//`define HCODEC_VLD_MEM_VIFIFO_LEVEL           8'h47 // must be low first to shadow low/high 16-bit words
+////
+//// bit  [8]     use_parser_video2_wp
+//// bit  [7]     vbuf2_out_manual
+//// bit  [6]     vbuf_out_manual
+//// bit  [5]     empty (ReadOnly)
+//// bit  [4]     full (ReadOnly)
+//// bit  [3:2]   reserved
+//// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+//// bit  [0]     Init            Set high then low after everything has been initialized
+//`define HCODEC_VLD_MEM_VIFIFO_BUF_CNTL        8'h48
+//
+//// bit 31:16 -- drop_bytes
+//// bit 15:14 -- drop_status (Read-Only)
+//// bit 13:12 -- sync_match_position (Read-Only)
+//// bit 11:6 -- reserved
+//// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
+//// bit 3 -- stamp_soft_reset
+//// bit 2 -- TIME_STAMP_length_enable
+//// bit 1 -- TIME_STAMP_sync64_enable
+//// bit 0 -- TIME_STAMP_enable
+//`define HCODEC_VLD_TIME_STAMP_CNTL            8'h49
+//// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+//`define HCODEC_VLD_TIME_STAMP_SYNC_0          8'h4a
+//// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
+//`define HCODEC_VLD_TIME_STAMP_SYNC_1          8'h4b
+//// bit 31:0 TIME_STAMP_0
+//`define HCODEC_VLD_TIME_STAMP_0               8'h4c
+//// bit 31:0 TIME_STAMP_1
+//`define HCODEC_VLD_TIME_STAMP_1               8'h4d
+//// bit 31:0 TIME_STAMP_2
+//`define HCODEC_VLD_TIME_STAMP_2               8'h4e
+//// bit 31:0 TIME_STAMP_3
+//`define HCODEC_VLD_TIME_STAMP_3               8'h4f
+//// bit 31:0 TIME_STAMP_LENGTH
+//`define HCODEC_VLD_TIME_STAMP_LENGTH          8'h50
+//
+//// bit 15:0 vififo_rd_count
+//`define HCODEC_VLD_MEM_VIFIFO_WRAP_COUNT      8'h51
+//
+//// bit 29:24 A_brst_num
+//// bit 21:16 A_id
+//// bit 15:0 level_hold 
+//`define HCODEC_VLD_MEM_VIFIFO_MEM_CTL         8'h52
+//
+//`define HCODEC_VLD_MEM_VBUF_RD_PTR            8'h53 // manual read address for VBUF1
+//`define HCODEC_VLD_MEM_VBUF2_RD_PTR           8'h54 // manual read address for VBUF2
+//
+//`define HCODEC_VLD_MEM_SWAP_ADDR              8'h55
+//// bit[23:16] - swap_d_count (Read Only)
+//// bit[15:8]  - swap_a_count (Read Only)
+//// bit [7] - swap busy (Read Only)
+//// bit [6:2] - reserved
+//// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+//// bit [0] - swap active
+//`define HCODEC_VLD_MEM_SWAP_CTL               8'h56
+//
+// Closing file:  hcodec_vld_regs.h
+//
+//------------------------------------------------------------------------------
+// HCODEC IQIDCT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hcodec_iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+//
+//`define HCODEC_VCOP_CTRL_REG       8'h00
+//`define HCODEC_QP_CTRL_REG         8'h01
+//`define HCODEC_INTRA_QUANT_MATRIX  8'h02
+//`define HCODEC_NON_I_QUANT_MATRIX  8'h03
+//`define HCODEC_DC_SCALER           8'h04
+//`define HCODEC_DC_AC_CTRL          8'h05
+//// `define HCODEC_RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+//`define HCODEC_DC_AC_SCALE_MUL     8'h06
+//`define HCODEC_DC_AC_SCALE_DIV     8'h07
+//// `define HCODEC_DC_AC_SCALE_RESULT  8'h06
+//// `define HCODEC_RESERVED_E07        8'h07
+//`define HCODEC_POWER_CTL_IQIDCT    8'h08
+//`define HCODEC_RV_AI_Y_X           8'h09
+//`define HCODEC_RV_AI_U_X           8'h0a
+//`define HCODEC_RV_AI_V_X           8'h0b
+//// bit 15:0 will count up when rv_ai_mb finished when non zero
+//// and rv_ai_mb_finished_int will be generate when this is not zero
+//`define HCODEC_RV_AI_MB_COUNT      8'h0c
+//// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+//`define HCODEC_NEXT_INTRA_DMA_ADDRESS 8'h0d
+//// Bit 0 -- constrained_intra_pred_flag for H264
+//`define HCODEC_IQIDCT_CONTROL         8'h0e
+//
+//
+//// Bit[31:19] Reserved
+//// Bit[18] iq_waiting
+//// Bit[17] iq_om_wr_idx
+//// Bit[16] iq_om_rd_idx
+//// Bit[15] iq_om_busy
+//// Bit[14] iq_om_2_busy 
+//// Bit[13] idx_fifo_0
+//// Bit[12] idx_fifo_1
+//// Bit[11] idx_fifo_2
+//// Bit[10] idx_fifo_3
+//// Bit[9] idx_fifo_4
+//// Bit[8] idx_fifo_5
+//// Bit[7] idx_fifo_6
+//// Bit[6] idx_fifo_7
+//// Bit[5:3] idx_fifo_wp
+//// Bit[2:0] idx_fifo_rp
+//
+//`define HCODEC_IQIDCT_DEBUG_INFO_0    8'h0f
+//
+//// For RTL Simulation Only
+//`define HCODEC_DEBLK_CMD              8'h10
+//
+//// Bit[15+16] ds_mc_valid_2
+//// Bit[14+16] new_idct1_rd_idx_2
+//// Bit[13+16] new_idct1_wr_idx_2
+//// Bit[12+16] idct1_buff0_busy_2
+//// Bit[11+16] idct1_buff1_busy_2
+//// Bit[10+16] new_idct1_busy_2
+//// Bit[9+16] iq_om_8val_2
+//// Bit[8+16] idct1_pipe_busy_2
+//
+//// Bit[7+16] wait_mb_left_finish_hold_2
+//// Bit[6+16] new_idct2_rd_idx_2
+//// Bit[5+16] new_idct2_wr_idx_2
+//// Bit[4+16] idct2_buff0_busy_2
+//// Bit[3+16] idct2_buff1_busy_2
+//// Bit[2+16] idct2_en_2
+//// Bit[1+16] new_idct2_busy_2
+//// Bit[0+16] new_idct1_ready_2
+//
+//// Bit[15] ds_mc_valid_1
+//// Bit[14] new_idct1_rd_idx_1
+//// Bit[13] new_idct1_wr_idx_1
+//// Bit[12] idct1_buff0_busy_1
+//// Bit[11] idct1_buff1_busy_1
+//// Bit[10] new_idct1_busy_1
+//// Bit[9] iq_om_8val_1
+//// Bit[8] idct1_pipe_busy_1
+//
+//// Bit[7] wait_mb_left_finish_hold_1
+//// Bit[6] new_idct2_rd_idx_1
+//// Bit[5] new_idct2_wr_idx_1
+//// Bit[4] idct2_buff0_busy_1
+//// Bit[3] idct2_buff1_busy_1
+//// Bit[2] idct2_en_1
+//// Bit[1] new_idct2_busy_1
+//// Bit[0] new_idct1_ready_1
+//
+//`define HCODEC_IQIDCT_DEBUG_IDCT      8'h11
+//
+//
+//
+//// bit 31 -- convas_enable
+//// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+//// bit 23:16 -- convas_y_count
+//// bit 15   -- dcac_dma_busy
+//// bit 14   -- dcac_dma_urgent
+//// bit 13:8 -- dcac_dma_count
+//// bit 7    -- dcac_dma_rw
+//// bit 6    -- dcac_skip_read_mode
+//// bit 5:0  -- dcac_dma_offset
+//`define HCODEC_DCAC_DMA_CTRL        8'h12
+//// when (convas_enable == 0 )
+////   bit 31:0 dcac_dma_addr
+//// when (convas_enable == 1 )
+////   bit 31:25 canvas_addr (7 bits)
+////   bit 24:12 convas_y_start ( 13 btis )
+////   bit 11:0  convas_x_start ( 12 btis )
+//`define HCODEC_DCAC_DMA_ADDRESS     8'h13
+//// bit 7:0 -- dcac_cpu_addr
+//`define HCODEC_DCAC_CPU_ADDRESS     8'h14
+//// bit 31:0 -- dcac_cpu_data
+//`define HCODEC_DCAC_CPU_DATA        8'h15
+//
+//// bit 31:19 -- reserved
+//// bit 18:16 -- block_num_reg -- Read-Only 
+//// bit 15:0 -- dcac_mb_count
+//`define HCODEC_DCAC_MB_COUNT        8'h16
+//
+//// bit 31:18 -- reserved
+//// For H264 :
+////   bit 17:2 -- h264_quant 
+////   bit 11:6 -- h264_quant_c 
+////   bit  5:0 -- h264_quant_c 
+//// For VC1 :
+////   bit    17 -- qindex_GT_8
+////   bit    16 -- HalfQPStep
+////   bit 15:12 -- eQuantMode 
+////   bit 11:6  -- AltPQuant 
+////   bit  5:0  -- PQuant 
+////             
+//`define HCODEC_IQ_QUANT             8'h17
+//
+//// bit 31:24  -- bitplane_width 
+//// bit 23:16  -- bitplane_height 
+//// bit 15:14  -- bitplane_start_x 
+//// bit 13:12  -- bitplane_start_y 
+//// bit 11:4   -- reserved
+//// bit 3:1    -- bitplane_type
+//// bit 0      -- bitplane_busy
+//`define HCODEC_VC1_BITPLANE_CTL     8'h18
+//
+//
+//
+//    `define HCODEC_RAM_TEST_CMD        12'h002
+//    `define HCODEC_RAM_TEST_ADDR       12'h003
+//    `define HCODEC_RAM_TEST_DATAH      12'h004
+//    `define HCODEC_RAM_TEST_DATAL      12'h005
+//
+//    `define HCODEC_RAM_TEST_RD_CMD	    16'h0000
+//    `define HCODEC_RAM_TEST_WR_CMD	    16'h8000
+//    `define HCODEC_IDCT_TM2_PT0	    16'h0001
+//    `define HCODEC_IDCT_TM2_PT1	    16'h0002
+//    `define HCODEC_IDCT_TM1_PT0	    16'h0004
+//    `define HCODEC_IDCT_TM1_PT1	    16'h0008
+//    `define HCODEC_IQ_OMEM_PT0	        16'h0010
+//    `define HCODEC_IQ_OMEM_PT1	        16'h0020
+//    `define HCODEC_MC_IMEM_PT0	        16'h0040
+//    `define HCODEC_ALL_RAM_PTS	        16'h007f
+//
+////======================================
+////  VCOP Control Register Bits
+////
+////======================================
+//    //`define HCODEC_IQIDCT_RESET	    16'h0001	    // Bit 0
+//    `define HCODEC_QM_WEN		    16'h0002	    // Bit 1
+//    `define HCODEC_IQIDCT_ENABLE	    16'h0004	    // Bit 2
+//    `define HCODEC_INTRA_QM	    16'h0008	    // Bit 3	0 = Use default; 1 = use loaded
+//    `define HCODEC_NINTRA_QM	    16'h0010	    // Bit 4	0 = Use default; 1 = use loaded
+//
+////======================================
+////  QP Control Register Bits
+////
+////======================================
+//    `define HCODEC_INTRA_MODE	    16'h0080	    // Bit 7
+//// Duplicate Address:  When actually used
+//// please move to a different address
+//// `define HCODEC_FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+//
+// Closing file:  hcodec_iqidct_regs.h
+//
+//------------------------------------------------------------------------------
+// HCODEC IQIDCT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hcodec_vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+//`define HCODEC_MSP                 8'h00
+//`define HCODEC_MPSR                8'h01
+//`define HCODEC_MINT_VEC_BASE       8'h02
+//`define HCODEC_MCPU_INTR_GRP       8'h03
+//`define HCODEC_MCPU_INTR_MSK       8'h04
+//`define HCODEC_MCPU_INTR_REQ       8'h05
+//`define HCODEC_MPC_P               8'h06
+//`define HCODEC_MPC_D               8'h07
+//`define HCODEC_MPC_E			    8'h08
+//`define HCODEC_MPC_W			    8'h09
+//`define HCODEC_MINDEX0_REG			8'h0a
+//`define HCODEC_MINDEX1_REG			8'h0b
+//`define HCODEC_MINDEX2_REG			8'h0c
+//`define HCODEC_MINDEX3_REG			8'h0d
+//`define HCODEC_MINDEX4_REG			8'h0e
+//`define HCODEC_MINDEX5_REG			8'h0f
+//`define HCODEC_MINDEX6_REG			8'h10
+//`define HCODEC_MINDEX7_REG			8'h11
+//`define HCODEC_MMIN_REG			8'h12
+//`define HCODEC_MMAX_REG			8'h13
+//`define HCODEC_MBREAK0_REG			8'h14
+//`define HCODEC_MBREAK1_REG			8'h15
+//`define HCODEC_MBREAK2_REG			8'h16
+//`define HCODEC_MBREAK3_REG			8'h17
+//`define HCODEC_MBREAK_TYPE			8'h18
+//`define HCODEC_MBREAK_CTRL			8'h19
+//`define HCODEC_MBREAK_STAUTS		8'h1a
+//`define HCODEC_MDB_ADDR_REG		8'h1b
+//`define HCODEC_MDB_DATA_REG		8'h1c
+//`define HCODEC_MDB_CTRL			8'h1d
+//`define HCODEC_MSFTINT0            8'h1e
+//`define HCODEC_MSFTINT1            8'h1f
+//
+//`define HCODEC_CSP                 8'h20
+//`define HCODEC_CPSR                8'h21
+//`define HCODEC_CINT_VEC_BASE       8'h22
+//`define HCODEC_CCPU_INTR_GRP       8'h23
+//`define HCODEC_CCPU_INTR_MSK       8'h24
+//`define HCODEC_CCPU_INTR_REQ       8'h25
+//`define HCODEC_CPC_P               8'h26
+//`define HCODEC_CPC_D               8'h27
+//`define HCODEC_CPC_E			    8'h28
+//`define HCODEC_CPC_W			    8'h29
+//`define HCODEC_CINDEX0_REG			8'h2a
+//`define HCODEC_CINDEX1_REG			8'h2b
+//`define HCODEC_CINDEX2_REG			8'h2c
+//`define HCODEC_CINDEX3_REG			8'h2d
+//`define HCODEC_CINDEX4_REG			8'h2e
+//`define HCODEC_CINDEX5_REG			8'h2f
+//`define HCODEC_CINDEX6_REG			8'h30
+//`define HCODEC_CINDEX7_REG			8'h31
+//`define HCODEC_CMIN_REG			8'h32
+//`define HCODEC_CMAX_REG			8'h33
+//`define HCODEC_CBREAK0_REG			8'h34
+//`define HCODEC_CBREAK1_REG			8'h35
+//`define HCODEC_CBREAK2_REG			8'h36
+//`define HCODEC_CBREAK3_REG			8'h37
+//`define HCODEC_CBREAK_TYPE			8'h38
+//`define HCODEC_CBREAK_CTRL			8'h39
+//`define HCODEC_CBREAK_STAUTS		8'h3a
+//`define HCODEC_CDB_ADDR_REG		8'h3b
+//`define HCODEC_CDB_DATA_REG		8'h3c
+//`define HCODEC_CDB_CTRL			8'h3d
+//`define HCODEC_CSFTINT0            8'h3e
+//`define HCODEC_CSFTINT1            8'h3f
+//
+//`define HCODEC_IMEM_DMA_CTRL       8'h40
+//`define HCODEC_IMEM_DMA_ADR        8'h41
+//`define HCODEC_IMEM_DMA_COUNT      8'h42
+//// bit[29:24] A_brst_num_imem
+//// bit[21:16] A_id_imem
+//// bit[11:0] wrrsp_count_imem (reserved)
+//`define HCODEC_WRRSP_IMEM          8'h43
+//
+//`define HCODEC_LMEM_DMA_CTRL       8'h50
+//`define HCODEC_LMEM_DMA_ADR        8'h51
+//`define HCODEC_LMEM_DMA_COUNT      8'h52
+//// bit[29:24] A_brst_num_lmem
+//// bit[21:16] A_id_lmem
+//// bit[11:0] wrrsp_count_lmem 
+//`define HCODEC_WRRSP_LMEM          8'h53
+//
+//`define HCODEC_MAC_CTRL1			8'h60
+//`define HCODEC_ACC0REG1			8'h61
+//`define HCODEC_ACC1REG1			8'h62
+//
+//`define HCODEC_MAC_CTRL2			8'h70
+//`define HCODEC_ACC0REG2			8'h71
+//`define HCODEC_ACC1REG2			8'h72
+//`define HCODEC_CPU_TRACE			8'h80
+//
+//
+// Closing file:  hcodec_vcpu_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_ASSIST module level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_ASSIST_CBUS_BASE = 0x00
+// -----------------------------------------------
+#define HEVC_ASSIST_AFIFO_CTRL                     ((0x3001  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AFIFO_CTRL1                    ((0x3002  << 2) + 0xd0050000)
+#define HEVC_ASSIST_GCLK_EN                        ((0x3003  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SW_RESET                       ((0x3004  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT0                      ((0x3025  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT1                      ((0x3026  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT2                      ((0x3027  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT3                      ((0x3028  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT4                      ((0x3029  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT5                      ((0x302a  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT6                      ((0x302b  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT7                      ((0x302c  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT8                      ((0x302d  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INT9                      ((0x302e  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INTA                      ((0x302f  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INTB                      ((0x3030  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INTC                      ((0x3031  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INTD                      ((0x3032  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INTE                      ((0x3033  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR1_INTF                      ((0x3034  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT0                      ((0x3035  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT1                      ((0x3036  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT2                      ((0x3037  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT3                      ((0x3038  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT4                      ((0x3039  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT5                      ((0x303a  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT6                      ((0x303b  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT7                      ((0x303c  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT8                      ((0x303d  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INT9                      ((0x303e  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INTA                      ((0x303f  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INTB                      ((0x3040  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INTC                      ((0x3041  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INTD                      ((0x3042  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INTE                      ((0x3043  << 2) + 0xd0050000)
+#define HEVC_ASSIST_AMR2_INTF                      ((0x3044  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBX_SSEL                       ((0x3045  << 2) + 0xd0050000)
+#define HEVC_ASSIST_TIMER0_LO                      ((0x3060  << 2) + 0xd0050000)
+#define HEVC_ASSIST_TIMER0_HI                      ((0x3061  << 2) + 0xd0050000)
+#define HEVC_ASSIST_TIMER1_LO                      ((0x3062  << 2) + 0xd0050000)
+#define HEVC_ASSIST_TIMER1_HI                      ((0x3063  << 2) + 0xd0050000)
+#define HEVC_ASSIST_DMA_INT                        ((0x3064  << 2) + 0xd0050000)
+#define HEVC_ASSIST_DMA_INT_MSK                    ((0x3065  << 2) + 0xd0050000)
+#define HEVC_ASSIST_DMA_INT2                       ((0x3066  << 2) + 0xd0050000)
+#define HEVC_ASSIST_DMA_INT_MSK2                   ((0x3067  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX0_IRQ_REG                  ((0x3070  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX0_CLR_REG                  ((0x3071  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX0_MASK                     ((0x3072  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX0_FIQ_SEL                  ((0x3073  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX1_IRQ_REG                  ((0x3074  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX1_CLR_REG                  ((0x3075  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX1_MASK                     ((0x3076  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX1_FIQ_SEL                  ((0x3077  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX2_IRQ_REG                  ((0x3078  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX2_CLR_REG                  ((0x3079  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX2_MASK                     ((0x307a  << 2) + 0xd0050000)
+#define HEVC_ASSIST_MBOX2_FIQ_SEL                  ((0x307b  << 2) + 0xd0050000)
+// bit[31:24] - read request
+// bit[23:16] - write request
+// bit[7] - disable_aml_axi_clk_gating
+// bit[3:0] - arb_switch_cnt
+#define HEVC_ASSIST_AXI_CTRL                       ((0x307c  << 2) + 0xd0050000)
+// bit[31:24] - read arb result
+// bit[23:16] - write arb result
+// bit[15:12] - read_ar_cnt
+// bit[11:8] - write_aw_cnt
+// bit[7] - arvalid_axi_s0
+// bit[6] - arready_axi_s0
+// bit[5] - awvalid_axi_s0
+// bit[4] - awready_axi_s0
+// bit[3:0] - write_fifo_cnt
+#define HEVC_ASSIST_AXI_STATUS                     ((0x307d  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_0                      ((0x30c0  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_1                      ((0x30c1  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_2                      ((0x30c2  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_3                      ((0x30c3  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_4                      ((0x30c4  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_5                      ((0x30c5  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_6                      ((0x30c6  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_7                      ((0x30c7  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_8                      ((0x30c8  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_9                      ((0x30c9  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_A                      ((0x30ca  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_B                      ((0x30cb  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_C                      ((0x30cc  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_D                      ((0x30cd  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_E                      ((0x30ce  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_F                      ((0x30cf  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_G                      ((0x30d0  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_H                      ((0x30d1  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_I                      ((0x30d2  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_J                      ((0x30d3  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_K                      ((0x30d4  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_L                      ((0x30d5  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_M                      ((0x30d6  << 2) + 0xd0050000)
+#define HEVC_ASSIST_SCRATCH_N                      ((0x30d7  << 2) + 0xd0050000)
+//------------------------------------------------------------------------------
+// HEVC_ASSIST module level register offset
+// Same as VDEC/HCODEC to avoid confusing software guy
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+//------------------------------------------------------------------------------
+// HEVC_PARSER module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_parser_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_PARSER_CBUS_BASE = 0x01
+// -----------------------------------------------
+// [31:0] After reset version, can be used for test scratch register 
+#define HEVC_PARSER_VERSION                        ((0x3100  << 2) + 0xd0050000)
+// [31:16] - axi_setting
+// [15]    - disable_stream_clock_gating
+// [14]    - wstrb_set
+// [6:4]   - stream_fetch_endian 
+// [3]     - use_parser_vbuf_wp
+// [2]     - use_parser_vbuf2_wp
+// [1]     - stream_fetch_busy - Read Only
+// [0]     - stream_fetch_enable
+#define HEVC_STREAM_CONTROL                        ((0x3101  << 2) + 0xd0050000)
+#define HEVC_STREAM_START_ADDR                     ((0x3102  << 2) + 0xd0050000)
+#define HEVC_STREAM_END_ADDR                       ((0x3103  << 2) + 0xd0050000)
+// SW stream_buffer_wr_ptr
+#define HEVC_STREAM_WR_PTR                         ((0x3104  << 2) + 0xd0050000)
+#define HEVC_STREAM_RD_PTR                         ((0x3105  << 2) + 0xd0050000)
+//[31:0] stream_buffer_level - read only
+#define HEVC_STREAM_LEVEL                          ((0x3106  << 2) + 0xd0050000)
+// [31:29] stream_buffer_hole 256*(4^0) bytes
+// [28:23] stream_fifo_hole 
+// [22:16] stream_fifo_level
+// [15]    stream_fifo_wr_ptr_update_en
+// [14:8]  stream_fifo_wr_ptr 
+// [7]     stream_fifo_rd_ptr_update_en
+// [6:0]   stream_fifo_rd_ptr 
+#define HEVC_STREAM_FIFO_CTL                       ((0x3107  << 2) + 0xd0050000)
+// [31:16] - Reserved
+// [15]    - disable_shift_clock_gating
+// [14]    - startcode_protect -- TODO
+// [8:6]   - sft_valid_wr_position (default : 3 (at least 24 bits available))
+// [5:4]   - emulate_code_length_sub_1(Default : 2)
+// [3]     - emulation_auto_on_startcode(Default : 0)
+// [2:1]   - start_code_length_sub_1(Default : 2)
+// [0]     - stream_shift_enable(Default : 0)
+#define HEVC_SHIFT_CONTROL                         ((0x3108  << 2) + 0xd0050000)
+// [31:0]  - max 4-bytes start code (Default : 0x00000100)
+#define HEVC_SHIFT_STARTCODE                       ((0x3109  << 2) + 0xd0050000)
+// [31:0]  - max 4-bytes emulate code (Default : 0x00000300)
+#define HEVC_SHIFT_EMULATECODE                     ((0x310a  << 2) + 0xd0050000)
+// [2]     - startcode_searching
+// [1]     - emulation_check_on
+// [0]     - startcode_check_on
+#define HEVC_SHIFT_STATUS                          ((0x310b  << 2) + 0xd0050000)
+// [31:0] hevc_shifted_data - read only
+#define HEVC_SHIFTED_DATA                          ((0x310c  << 2) + 0xd0050000)
+// [31:0] shift_byte_count[31:0]
+#define HEVC_SHIFT_BYTE_COUNT                      ((0x310d  << 2) + 0xd0050000)
+// [31:28] - shift_byte_count[35:32]
+// [27:20] - element_read_data[31:24]
+// [10]    - bytealign
+// [9]     - signed_element
+// [8]     - start_element_read
+// [7]     - shift_busy
+// [6:0]   - shift_bits
+#define HEVC_SHIFT_COMMAND                         ((0x310e  << 2) + 0xd0050000)
+// 31:8    - element_read_data[23:0]
+//  7:2    - element_read_length
+//  1:0    - element_read_state
+#define HEVC_ELEMENT_RESULT                        ((0x310f  << 2) + 0xd0050000)
+// [31:16] - cabac_buffer
+// [15]    - cabac_buffer_init
+// [14]    - cabac_context_init
+// [13]    - disable_cabac_clock_gating
+// [12]    - cabac_init_flag
+// [11:1]  - Reserved
+// [0]     - cabac_enable(Default : 0)
+#define HEVC_CABAC_CONTROL                         ((0x3110  << 2) + 0xd0050000)
+// [31:25] - chromaQPOffset_U
+// [24:18] - chromaQPOffset_V
+// [17:16] - MaxTrSize 0-4x4, 1-8x8, 2-16x16, 3-32x32
+// [15:14] - MinTrSize 0-4x4, 1-8x8, 2-16x16, 3-32x32
+// [13:12] - MaxCUSize 0-8x8, 1-16x16, 2-32x32, 3-64x64
+// [11:10] - MinCUSize 0-8x8, 1-16x16, 2-32x32, 3-64x64
+// [9]     - slice_sao_luma_flag
+// [8]     - slice_sao_chroma_flag
+// [7:2]   - slice_quant
+// [1:0]   - slice_type
+#define HEVC_PARSER_SLICE_INFO                     ((0x3111  << 2) + 0xd0050000)
+// bit[16]  - 0:command, 1:address(will auto increase when write command)
+// bit[15:0]- command or addr
+#define HEVC_PARSER_CMD_WRITE                      ((0x3112  << 2) + 0xd0050000)
+// [31:16] - reserved
+// [15]    - disable_parser_core_clock_gating
+// [14:1]  - Reserved
+// [0]     - parser_core_enable(Default : 0)
+#define HEVC_PARSER_CORE_CONTROL                   ((0x3113  << 2) + 0xd0050000)
+// [31:16] - pre_parser_cmd
+// [15]    - start_cmd_fetch/fetch_busy
+// [14]    - parser_cmd_ready
+// [13]    - pre_parser_cmd_ready
+// [12]    - do_not_wait_if_busy
+// [11:8]  - cmd_fetch_status // Read-only
+// [7:0]   - cmd_fetch_addr
+#define HEVC_PARSER_CMD_FETCH                      ((0x3114  << 2) + 0xd0050000)
+// [31:16] - parser_cmd
+// [9:5]   - parser_function
+// [4:0]   - cmd_status
+#define HEVC_PARSER_CMD_STATUS                     ((0x3115  << 2) + 0xd0050000)
+// [31]    - end_of_picture
+// [30]    - uiLeft
+// [39]    - uiTop
+// [28]    - uiTopRight
+// [27:24] - Reserved
+// [23:12] - uiLin 
+// [11:0]  - uiCol 
+#define HEVC_PARSER_LCU_INFO                       ((0x3116  << 2) + 0xd0050000)
+// 29:28 - min_cu_size_qp_delta
+// 27    - cu_qp_delta_enabled_flag
+// 26    - amp_enabled_flag
+// 25:23 - max_num_merge_cand
+// 22    - mvd_l1_zero_flag
+// 21:16 - num_ref_idx_l1_active
+// 15:10 - num_ref_idx_l0_active
+// 9:7   - max_transform_hierarchy_depth_inter 
+// 6:4   - max_transform_hierarchy_depth_intra 
+// 3     - transquant_bypass_enable_flag
+// 2     - constrained_intra_pred_flag
+// 1     - transform_skip_enabled_flag
+// 0     - sign_data_hiding_flag
+#define HEVC_PARSER_HEADER_INFO                    ((0x3117  << 2) + 0xd0050000)
+#define HEVC_PARSER_RESULT_0                       ((0x3118  << 2) + 0xd0050000)
+#define HEVC_PARSER_RESULT_1                       ((0x3119  << 2) + 0xd0050000)
+#define HEVC_PARSER_RESULT_2                       ((0x311a  << 2) + 0xd0050000)
+#define HEVC_PARSER_RESULT_3                       ((0x311b  << 2) + 0xd0050000)
+// bit[31:16] - quant[47:32]
+// bit[15:8]  - SkipFlag
+// bit[7]     - SliceEnd|end_of_picture
+// bit[6:3]   - SplitFlag_8
+// bit[2:1]   - SplitFlag_16
+// bit[0]     - SplitFlag_32
+#define HEVC_CABAC_TOP_INFO                        ((0x311c  << 2) + 0xd0050000)
+// bit[31:0]  - quant[31:0]
+#define HEVC_CABAC_TOP_INFO_2                      ((0x311d  << 2) + 0xd0050000)
+// bit[31:16] - quant[47:32]
+// bit[15:8]  - SkipFlag
+// bit[7]     - Reserved
+// bit[6:3]   - SplitFlag_8
+// bit[2:1]   - SplitFlag_16
+// bit[0]     - SplitFlag_32
+#define HEVC_CABAC_LEFT_INFO                       ((0x311e  << 2) + 0xd0050000)
+// bit[31:0]  - quant[31:0]
+#define HEVC_CABAC_LEFT_INFO_2                     ((0x311f  << 2) + 0xd0050000)
+// [31:29] - stream_buffer_empty_int_ctl (32bytes - 4k bytes) (default : 4 : 512 bytes interrupt) 
+// [28:26] - stream_fifo_empty_int_ctl (0 - 128)(default : 0 - 0 byte interrupt) 
+// [25]    - stream_buffer_empty_int_cpu_enable
+// [24]    - stream_buffer_empty_int_amrisc_enable
+// [23]    - stream_fifo_empty_int_cpu_enable
+// [22]    - stream_fifo_empty_int_amrisc_enable
+// [15]    - disable_parser_clock_gating
+// [8]     - dec_done_int_cpu_enable
+// [7]     - dec_done_int_amrisc_enable
+// [6]     - cmd_done_int_cpu_enable
+// [5]     - cmd_done_int_amrisc_enable
+// [4]     - startcode_found_int_cpu_enable
+// [3]     - startcode_found_int_amrisc_enable
+// [2]     - parser_int_cpu_level (default : 0(pulse))
+// [1]     - parser_int_amrisc_level (default : 0(pulse))
+// [0]     - parser_int_enable(Default : 0)
+#define HEVC_PARSER_INT_CONTROL                    ((0x3120  << 2) + 0xd0050000)
+// [7]     - stream_empty_int_cpu
+// [6]     - stream_empty_int_amrisc
+// [2]     - dec_done_int
+// [1]     - cmd_done_int
+// [0]     - startcode_found_int
+#define HEVC_PARSER_INT_STATUS                     ((0x3121  << 2) + 0xd0050000)
+// [31]    - parser_mpred_if_busy  -- Read Only
+// [8]     - sao_sw_pred_enable
+// [7]     - sao_top_save_even_no_sao
+// [6]     - disable_parser_sao_if_clock_gating
+// [5]     - parser_sao_if_en
+// [4]     - scaler_if_leave_one_more_space
+// [3]     - disable_parser_mpred_if_clock_gating
+// [2]     - parser_mpred_if_en
+// [1]     - disable_parser_scaler_if_clock_gating
+// [0]     - parser_scaler_if_en
+#define HEVC_PARSER_IF_CONTROL                     ((0x3122  << 2) + 0xd0050000)
+// [31:16] PicHeightInLumaSamples
+// [15:0]  PicWidthInLumaSamples
+#define HEVC_PARSER_PICTURE_SIZE                   ((0x3123  << 2) + 0xd0050000)
+// [31]    - start_lcu_mpred_cmd 
+// [30]    - lcu_decoding_start
+// [29]    - do_not_wait_if_busy
+// [23:0]  - lcu_idx
+#define HEVC_PARSER_LCU_START                      ((0x3124  << 2) + 0xd0050000)
+// [15:12] - pcm_sample_bit_depth_chroma
+// [11:8]  - pcm_sample_bit_depth_luma
+// [7:6]   - max_pcm_luma_coding_block_size
+// [5:4]   - min_pcm_luma_coding_block_size
+// [3:1]   - reserved
+// [0]     - pcm_enabled_flag
+#define HEVC_PARSER_HEADER_INFO2                   ((0x3125  << 2) + 0xd0050000)
+// Read Only
+// bit[23]    - 1'b1
+// bit[22]    - Reserved
+// bit[21:16] - quant_V 
+// bit[15]    - 1'b1
+// bit[14]    - Reserved
+// bit[13:8]  - quant_U 
+// bit[7]     - 1'b1
+// bit[6]     - Reserved
+// bit[5:0]   - quant_Y 
+#define HEVC_PARSER_QUANT_READ                     ((0x3126  << 2) + 0xd0050000)
+#define HEVC_PARSER_RESERVED_27                    ((0x3127  << 2) + 0xd0050000)
+// bit[15:8]  - skip_addr_SaoOffData 
+// bit[7:0]   - skip_addr_SaoMerge
+#define HEVC_PARSER_CMD_SKIP_0                     ((0x3128  << 2) + 0xd0050000)
+// bit[31:24] - skip_point_coding_unit_slice_type_RET 
+// bit[23:16] - skip_point_coding_unit_slice_type_B 
+// bit[15:8]  - skip_point_coding_unit_slice_type_P 
+// bit[7:0]   - skip_point_coding_unit_slice_type_I
+#define HEVC_PARSER_CMD_SKIP_1                     ((0x3129  << 2) + 0xd0050000)
+// bit[31:24] - reserved
+// bit[23:16] - skip_point_coding_unit_pred_mode_RET 
+// bit[15:8]  - skip_point_coding_unit_pred_mode_INTER
+// bit[7:0]   - skip_point_coding_unit_pred_mode_INTRA
+#define HEVC_PARSER_CMD_SKIP_2                     ((0x312a  << 2) + 0xd0050000)
+// Write :
+// [24:16] context_addr for dec_Bin 
+// [15:0]  parser_cmd 
+// Read result:
+// cabac_context_decodeBin,       // 31
+// cabac_context_decodeBinEP,     // 30
+// cabac_context_decodeBinTrm,    // 29
+// cabac_context_decodeBinBit,    // 28
+// parser_command,                // 27:22
+// cabac_context_ready,           // 21
+// cmd_status,                    // 20:16
+// cabac_manual_data              // 15:0
+// 
+#define HEVC_PARSER_MANUAL_CMD                     ((0x312b  << 2) + 0xd0050000)
+// bit [9:0] - Read adress : 
+//          address 0-255 stream_fifo (128x64)
+//          address 256-319 context_mem (256x7)
+//          address 320-448 parser_cmd_mem (256x16)
+#define HEVC_PARSER_MEM_RD_ADDR                    ((0x312c  << 2) + 0xd0050000)
+// bit [9:0] - Write adress : 
+//          address 0-255 stream_fifo (128x64)
+//          address 256-319 context_mem (256x7)
+//          address 512-640 parser_cmd_mem (256x16)
+#define HEVC_PARSER_MEM_WR_ADDR                    ((0x312d  << 2) + 0xd0050000)
+// bit[31:0] read/write data
+#define HEVC_PARSER_MEM_RW_DATA                    ((0x312e  << 2) + 0xd0050000)
+// [31:20] sao_lcu_x
+// [19:8]  sao_lcu_y
+// [7] sao_lcu_xy_update
+// [6:2] reserved
+// [1] sao_wait_up_read
+// [0] sao_wait_write
+#define HEVC_SAO_IF_STATUS                         ((0x3130  << 2) + 0xd0050000)
+// Y_offset_3,    // 31:26 
+// Y_offset_2,    // 25:20 
+// Y_offset_1,    // 19:14 
+// Y_offset_0,    // 13:8 
+// Y_typeAuxInfo[3:0], // 7:4 
+// Y_typeIdc,     // 3:1 [0, 1, 2, 3]-EO, [4,5]-BO+Y_typeAuxInfo[4] 
+// Y_modelIdc     // 0
+#define HEVC_SAO_IF_DATA_Y                         ((0x3131  << 2) + 0xd0050000)
+#define HEVC_SAO_IF_DATA_U                         ((0x3132  << 2) + 0xd0050000)
+#define HEVC_SAO_IF_DATA_V                         ((0x3133  << 2) + 0xd0050000)
+#define HEVC_STREAM_SWAP_ADDR                      ((0x3134  << 2) + 0xd0050000)
+// bit[31:24] - swap_wrrsp_count
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only)
+// bit [7] - swap busy (Read Only)
+// bit [6:3] - reserved
+// bit [2] - swap_wrrsp_count_update
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define HEVC_STREAM_SWAP_CTRL                      ((0x3135  << 2) + 0xd0050000)
+#define HEVC_IQIT_IF_WAIT_CNT                      ((0x3136  << 2) + 0xd0050000)
+#define HEVC_MPRED_IF_WAIT_CNT                     ((0x3137  << 2) + 0xd0050000)
+#define HEVC_SAO_IF_WAIT_CNT                       ((0x3138  << 2) + 0xd0050000)
+// bit[3:0] parser_debug_idx
+#define HEVC_PARSER_DEBUG_IDX                      ((0x313e  << 2) + 0xd0050000)
+// bit[31:0] parser_debug_dat -- read only
+#define HEVC_PARSER_DEBUG_DAT                      ((0x313f  << 2) + 0xd0050000)
+//
+// Closing file:  hevc_parser_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_MPRED module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_mpred_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_MPRED_CBUS_BASE = 0x02
+// -----------------------------------------------
+#define HEVC_MPRED_VERSION                         ((0x3200  << 2) + 0xd0050000)
+//  [31:0]  reversion               default:32'h00010001
+#define HEVC_MPRED_CTRL0                           ((0x3201  << 2) + 0xd0050000)
+// [1:0]    slice_type[1:0]
+// [2]      new_pic
+// [3]      new_tile
+// [4]      SliceSegment
+// [5]      TMVPFlag_en 
+// [6]      LDCFlag 
+// [7]      ColFromL0Flag 
+// [8]      reserved  
+// [9]      above_en  
+// [10]     mv_wr_en  
+// [11]     mv_rd_en  
+// [12]     col_isIntra  
+// [13]     reserved  
+// [14]     LongTerm_Curr  
+// [15]     LongTerm_Col  
+// [19:16]  lcu_size_log2[3:0]  
+// [23:20]  cu_size_log2[3:0]  
+// [26:24]  plevel[2:0]  
+// [31:27]  reserved  
+#define HEVC_MPRED_CTRL1                           ((0x3202  << 2) + 0xd0050000)
+//  [3:0]   MERGE_MAX_NUM_CANDS[3:0]
+//  [7:4]   AMVP_MAX_NUM_CANDS[3:0]
+//  [23:8]  reserved
+//  [24]    clk_forceon
+//  [31:25] reserved
+#define HEVC_MPRED_INT_EN                          ((0x3203  << 2) + 0xd0050000)
+//  [0]     mpred_int_enable
+//  [1]     mpred_int_amrisc_level
+//  [2]     mpred_int_cpu_level
+//  [3]     slice_done_int_amrisc_enable
+//  [4]     slice_done_int_cpu_enable
+//  [15]    disable_mpred_int_clock_gating
+#define HEVC_MPRED_INT_STATUS                      ((0x3204  << 2) + 0xd0050000)
+//  [0]     slice_done IRQ  
+//  [31]    write "1"=slice start(self clear,read always return "0")
+#define HEVC_MPRED_PIC_SIZE                        ((0x3205  << 2) + 0xd0050000)
+//  [15:0]  pic_width[15:0]
+//  [31:16] pic_height[15:0]
+#define HEVC_MPRED_PIC_SIZE_LCU                    ((0x3206  << 2) + 0xd0050000)
+//  [15:0]  lcu_x_num_1[15:0]   (=lcu_x_total-1)
+//  [31:16] lcu_y_num_1[15:0]   (=lcu_y_total-1)
+#define HEVC_MPRED_TILE_START                      ((0x3207  << 2) + 0xd0050000)
+//  [15:0]  tile_start_lcu_x[15:0]
+//  [31:16] tile_start_lcu_y[15:0]
+#define HEVC_MPRED_TILE_SIZE_LCU                   ((0x3208  << 2) + 0xd0050000)
+//  [15:0]  tile_width_lcu[15:0]
+//  [31:16] tile_height_lcu[15:0]
+#define HEVC_MPRED_REF_NUM                         ((0x3209  << 2) + 0xd0050000)
+//  [3:0]   refNum_L0[3:0]
+//  [11:8]  refNum_L1[3:0]
+//  [19:16] col_refNum_L0[3:0]
+//  [27:24] col_refNum_L1[3:0]
+#define HEVC_MPRED_LT_REF                          ((0x320a  << 2) + 0xd0050000)
+//  [00]    LongTerm_L0_Ref00
+//  [01]    LongTerm_L0_Ref01
+//  ......
+//  [15]    LongTerm_L0_Ref15
+//  [16]    LongTerm_L1_Ref00
+//  [17]    LongTerm_L1_Ref01
+//  ......
+//  [31]    LongTerm_L1_Ref15
+#define HEVC_MPRED_LT_COLREF                       ((0x320b  << 2) + 0xd0050000)
+//  [00]    LongTerm_Col_L0_Ref00
+//  [01]    LongTerm_Col_L0_Ref01
+//  ......
+//  [15]    LongTerm_Col_L0_Ref15
+//  [16]    LongTerm_Col_L1_Ref00
+//  [17]    LongTerm_Col_L1_Ref01
+//  ......
+//  [31]    LongTerm_Col_L1_Ref15
+#define HEVC_MPRED_REF_EN_L0                       ((0x320c  << 2) + 0xd0050000)
+//  [00]    L0_ref00_en
+//  [01]    L0_ref01_en
+//  ......
+//  [15]    L0_ref15_en
+#define HEVC_MPRED_REF_EN_L1                       ((0x320d  << 2) + 0xd0050000)
+//  [00]    L1_ref00_en
+//  [01]    L1_ref01_en
+//  ......
+//  [15]    L1_ref15_en
+#define HEVC_MPRED_COLREF_EN_L0                    ((0x320e  << 2) + 0xd0050000)
+//  [00]    COL_L0_ref00_en
+//  [01]    COL_L0_ref01_en
+//  ......
+//  [15]    COL_L0_ref15_en
+#define HEVC_MPRED_COLREF_EN_L1                    ((0x320f  << 2) + 0xd0050000)
+//  [00]    COL_L1_ref00_en
+//  [01]    COL_L1_ref01_en
+//  ......
+//  [15]    COL_L1_ref15_en
+#define HEVC_MPRED_AXI_WCTRL                       ((0x3210  << 2) + 0xd0050000)
+//  [11:8]  aw_id_set[3:0]
+#define HEVC_MPRED_AXI_RCTRL                       ((0x3211  << 2) + 0xd0050000)
+//  [11:8]  ar_id_set[3:0]
+#define HEVC_MPRED_ABV_START_ADDR                  ((0x3212  << 2) + 0xd0050000)
+#define HEVC_MPRED_MV_WR_START_ADDR                ((0x3213  << 2) + 0xd0050000)
+#define HEVC_MPRED_MV_RD_START_ADDR                ((0x3214  << 2) + 0xd0050000)
+#define HEVC_MPRED_MV_WPTR                         ((0x3215  << 2) + 0xd0050000)
+#define HEVC_MPRED_MV_RPTR                         ((0x3216  << 2) + 0xd0050000)
+#define HEVC_MPRED_MV_WR_ROW_JUMP                  ((0x3217  << 2) + 0xd0050000)
+#define HEVC_MPRED_MV_RD_ROW_JUMP                  ((0x3218  << 2) + 0xd0050000)
+#define HEVC_MPRED_CURR_LCU                        ((0x3219  << 2) + 0xd0050000)
+#define HEVC_MPRED_ABV_WPTR                        ((0x321a  << 2) + 0xd0050000)
+#define HEVC_MPRED_ABV_RPTR                        ((0x321b  << 2) + 0xd0050000)
+#define HEVC_MPRED_CTRL2                           ((0x321c  << 2) + 0xd0050000)
+#define HEVC_MPRED_CTRL3                           ((0x321d  << 2) + 0xd0050000)
+#define HEVC_MPRED_MV_WLCUY                        ((0x321e  << 2) + 0xd0050000)
+#define HEVC_MPRED_MV_RLCUY                        ((0x321f  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF00_POC                    ((0x3220  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF01_POC                    ((0x3221  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF02_POC                    ((0x3222  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF03_POC                    ((0x3223  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF04_POC                    ((0x3224  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF05_POC                    ((0x3225  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF06_POC                    ((0x3226  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF07_POC                    ((0x3227  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF08_POC                    ((0x3228  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF09_POC                    ((0x3229  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF10_POC                    ((0x322a  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF11_POC                    ((0x322b  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF12_POC                    ((0x322c  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF13_POC                    ((0x322d  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF14_POC                    ((0x322e  << 2) + 0xd0050000)
+#define HEVC_MPRED_L0_REF15_POC                    ((0x322f  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF00_POC                    ((0x3230  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF01_POC                    ((0x3231  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF02_POC                    ((0x3232  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF03_POC                    ((0x3233  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF04_POC                    ((0x3234  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF05_POC                    ((0x3235  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF06_POC                    ((0x3236  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF07_POC                    ((0x3237  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF08_POC                    ((0x3238  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF09_POC                    ((0x3239  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF10_POC                    ((0x323a  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF11_POC                    ((0x323b  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF12_POC                    ((0x323c  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF13_POC                    ((0x323d  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF14_POC                    ((0x323e  << 2) + 0xd0050000)
+#define HEVC_MPRED_L1_REF15_POC                    ((0x323f  << 2) + 0xd0050000)
+#define HEVC_MPRED_PIC_SIZE_EXT                    ((0x3240  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_MODE0                       ((0x3241  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_MODE1                       ((0x3242  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG2_MODE                       ((0x3243  << 2) + 0xd0050000)
+#define HEVC_MPRED_IMP_CMD0                        ((0x3244  << 2) + 0xd0050000)
+#define HEVC_MPRED_IMP_CMD1                        ((0x3245  << 2) + 0xd0050000)
+#define HEVC_MPRED_IMP_CMD2                        ((0x3246  << 2) + 0xd0050000)
+#define HEVC_MPRED_IMP_CMD3                        ((0x3247  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG2_DATA_0                     ((0x3248  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG2_DATA_1                     ((0x3249  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG2_DATA_2                     ((0x324a  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG2_DATA_3                     ((0x324b  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_DATA_0                      ((0x3250  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_DATA_1                      ((0x3251  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_DATA_2                      ((0x3252  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_DATA_3                      ((0x3253  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_DATA_4                      ((0x3254  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_DATA_5                      ((0x3255  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_DATA_6                      ((0x3256  << 2) + 0xd0050000)
+#define HEVC_MPRED_DBG_DATA_7                      ((0x3257  << 2) + 0xd0050000)
+#define HEVC_MPRED_CUR_POC                         ((0x3260  << 2) + 0xd0050000)
+#define HEVC_MPRED_COL_POC                         ((0x3261  << 2) + 0xd0050000)
+#define HEVC_MPRED_MV_RD_END_ADDR                  ((0x3262  << 2) + 0xd0050000)
+//
+// Closing file:  hevc_mpred_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_IPP module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_ipp_regs.h
+//
+// John A. Thodiyil
+// Register map for intra/inter/pcm pixel-prediction + MCRCC
+// August 14th, 2013
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_IPP_CBUS_BASE = 0x04
+// -----------------------------------------------
+#define HEVCD_IPP_TOP_CNTL                         ((0x3400  << 2) + 0xd0050000)
+// [0]      -- software reset ipp and mpp
+// [1]      -- enable ipp
+// [31:2]   -- reserved
+#define HEVCD_IPP_TOP_STATUS                       ((0x3401  << 2) + 0xd0050000)
+// [0]      -- ready for next tile/frame
+// [1]      -- ready for next ctb
+// [2]      -- ready for next slice
+// [31:3]   -- reserved
+#define HEVCD_IPP_TOP_FRMCONFIG                    ((0x3402  << 2) + 0xd0050000)
+// [14:0]   -- frame width in luma pixels
+// [30:16]  -- frame height in luma pixels
+#define HEVCD_IPP_TOP_TILECONFIG1                  ((0x3403  << 2) + 0xd0050000)
+// [11:0]   -- tile_width_in_lcu
+// [27:16]  -- tile_height_in_lcu
+#define HEVCD_IPP_TOP_TILECONFIG2                  ((0x3404  << 2) + 0xd0050000)
+// [11:0]   -- tile_offset_x_in_lcu
+// [27:16]  -- tile_offset_y_in_lcu
+#define HEVCD_IPP_TOP_TILECONFIG3                  ((0x3405  << 2) + 0xd0050000)
+// [0]      -- tiles_enabled_flag
+// [31:1]   -- reserved 
+#define HEVCD_IPP_TOP_LCUCONFIG                    ((0x3406  << 2) + 0xd0050000)
+// [6:0]    -- lcu size in pixels
+#define HEVCD_IPP_TOP_FRMCTL                       ((0x3407  << 2) + 0xd0050000)
+// [x]      -- start ipp tile decode
+#define HEVCD_IPP_CONFIG                           ((0x3408  << 2) + 0xd0050000)
+// [0]      -- ipp_strong_intra_smoothing_enable_flag
+// [1]      -- cfg_ipp_constrained_intra_pred_flag
+// [31:2]   -- reserved 
+#define HEVCD_IPP_LINEBUFF_BASE                    ((0x3409  << 2) + 0xd0050000)
+// [31:14]  -- intra-prediction line-buffer 16KByte axi address 
+// [13:0]   -- reserved 
+#define HEVCD_IPP_INTR_MASK                        ((0x340a  << 2) + 0xd0050000)
+// [0]      -- tile/frame ready 
+// [1]      -- ctb ready
+// [2]      -- slice ready
+// [31:3]   -- reserved
+#define HEVCD_IPP_AXIIF_CONFIG                     ((0x340b  << 2) + 0xd0050000)
+// [3:0]    -- little_endian
+// [5:4]    -- address_format 00:linear 01:32x32 10:64x32
+// [7:6]    -- reserved
+// [9:8]    -- Linear_LineAlignment 00:16byte 01:32byte 10:64byte
+// [11:10]  -- reserved
+// [12]     -- CbCr_byte_swap
+// [31:13]  -- reserved
+#define HEVCD_IPP_SWMPREDIF_CONFIG                 ((0x3410  << 2) + 0xd0050000)
+// [0]      -- swmpredif_enable
+// [31:1]   -- reserved
+#define HEVCD_IPP_SWMPREDIF_STATUS                 ((0x3411  << 2) + 0xd0050000)
+// [0]      -- swmpredif_rdy
+// [7:1]    -- reserved
+// [14:8]   -- swmpredif_fifospace
+// [31:15]  -- reserved
+#define HEVCD_IPP_SWMPREDIF_CTBINFO                ((0x3412  << 2) + 0xd0050000)
+// [10:0]   -- swmpredif_ctb_x
+// [15:11]  -- reserved
+// [26:16]  -- swmpredif_ctb_y
+// [30:27]  -- reserved
+// [31]     -- swmpredif_newslice
+#define HEVCD_IPP_SWMPREDIF_PUINFO0                ((0x3413  << 2) + 0xd0050000)
+// [31:0]   -- swmpredif_imp_cmd[31:0]
+#define HEVCD_IPP_SWMPREDIF_PUINFO1                ((0x3414  << 2) + 0xd0050000)
+// [31:0]   -- swmpredif_imp_cmd[63:32]
+#define HEVCD_IPP_SWMPREDIF_PUINFO2                ((0x3415  << 2) + 0xd0050000)
+// [31:0]   -- swmpredif_imp_cmd[95:64]
+#define HEVCD_IPP_SWMPREDIF_PUINFO3                ((0x3416  << 2) + 0xd0050000)
+// [31:0]   -- swmpredif_imp_cmd[127:96]
+//          writing to HEVCD_IPP_SWMPREDIF_PUINFO3 
+//          completes command, should be last to write. 
+#define HEVCD_IPP_DYNCLKGATE_CONFIG                ((0x3420  << 2) + 0xd0050000)
+// [0]      -- mpp_wpredict_clkgate_disbl
+// [1]      -- mpp_ref_fetch_clkgate_disbl
+// [2]      -- mpp_interpol_top_clkgate_disbl
+// [3]      -- mpp_axiIf_clkgate_disbl
+// [7:4]    -- reserved
+// [8]      -- ipp_res_fetch_clkgate_disbl
+// [9]      -- ipp_iqitIf_clkgate_disbl
+// [10]     -- ipp_dblkCmdIf_clkgate_disbl
+// [11]     -- ipp_dblkIf_clkgate_disbl
+// [12]     -- ipp_cntl_clkgate_disbl
+// [13]     -- ipp_nsamples_proc_clkgate_disbl
+// [14]     -- ipp_refroute_clkgate_disbl
+// [15]     -- ipp_spred_clkgate_disbl
+// [16]     -- ipp_reg_clkgate_disbl
+// [17]     -- ipp_recon_clkgate_disbl
+// [28:18]  -- reserved
+// [29]     -- master_mpp_clkgate_disbl
+// [30]     -- master_ipp_clkgate_disbl
+// [31]     -- master_ipp_mpp_clkgate_disbl
+#define HEVCD_IPP_DYNCLKGATE_STATUS                ((0x3421  << 2) + 0xd0050000)
+// [0]      -- mpp_wpredict_clkgate
+// [1]      -- mpp_ref_fetch_clkgate
+// [2]      -- mpp_interpol_top_clkgate
+// [3]      -- mpp_axiIf_clkgate
+// [7:4]    -- reserved
+// [8]      -- ipp_res_fetch_clkgate
+// [9]      -- ipp_iqitIf_clkgate
+// [10]     -- ipp_dblkCmdIf_clkgate
+// [11]     -- ipp_dblkIf_clkgate
+// [12]     -- ipp_cntl_clkgate
+// [13]     -- ipp_nsamples_proc_clkgate
+// [14]     -- ipp_refroute_clkgate
+// [15]     -- ipp_spred_clkgate
+// [16]     -- ipp_reg_clkgate
+// [17]     -- ipp_recon_clkgate
+// [30:18]  -- reserved
+// [31]     -- mcrcc_axi_clkgate
+#define HEVCD_IPP_DBG_SEL                          ((0x3430  << 2) + 0xd0050000)
+// [3:0]    -- module_level_sel
+// [7:4]    -- mpp_ipp_top_level
+// [8]      -- ipp_sel
+// [31:9]   -- reserved
+#define HEVCD_IPP_DBG_DATA                         ((0x3431  << 2) + 0xd0050000)
+// [31:0]   -- Debug information 
+//////////////////////////////////////////////////////////////////////////////
+///// MPP Registers                                       ////////////////////
+//////////////////////////////////////////////////////////////////////////////
+// Canvas Anchor to Axi-Address translation table
+#define HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR            ((0x3460  << 2) + 0xd0050000)
+// [0]      -- anc2axi canvas address translation table switch 0:sw 1:hw
+#define HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR             ((0x3461  << 2) + 0xd0050000)
+// [0]      -- anc2axi canvas address translation table access type 1:wr 0:rd
+// [15:8]   -- anc2axi canvas address translation table access index
+// [31:16]  -- anc2axi canvas address translation table access write data, 16KByte axi address
+#define HEVCD_MPP_ANC2AXI_TBL_WDATA_ADDR           ((0x3462  << 2) + 0xd0050000)
+// [x]      -- not used
+#define HEVCD_MPP_ANC2AXI_TBL_RDATA_ADDR           ((0x3463  << 2) + 0xd0050000)
+// [15:0]   -- anc2axi canvas address translation table access read data
+#define HEVCD_MPP_WEIGHTPRED_CNTL_ADDR             ((0x347b  << 2) + 0xd0050000)
+// [0]      -- weighted_pred_flag
+#define HEVCD_MPP_L0_WEIGHT_FLAG_ADDR              ((0x347c  << 2) + 0xd0050000)
+// [15:0]   -- luma_weght_flag0[15:0], indexed by refidx0
+// [31:16]  -- chroma_weght_flag0[15:0], indexed by refidx0
+#define HEVCD_MPP_L1_WEIGHT_FLAG_ADDR              ((0x347d  << 2) + 0xd0050000)
+// [15:0]   -- luma_weght_flag1[15:0], indexed by refidx1
+// [31:16]  -- chroma_weght_flag1[15:0], indexed by refidx1
+#define HEVCD_MPP_YLOG2WGHTDENOM_ADDR              ((0x347e  << 2) + 0xd0050000)
+// [3:0]    -- luma_log2_weight_denom
+#define HEVCD_MPP_DELTACLOG2WGHTDENOM_ADDR         ((0x347f  << 2) + 0xd0050000)
+// [4:0]    -- delta_chroma_log2_weight_denom
+#define HEVCD_MPP_WEIGHT_ADDR                      ((0x3480  << 2) + 0xd0050000)
+// [5:0]    -- weight_rw_addr
+// [0]      -- DELTA_WEIGHT0 
+// [1]      -- OFFSET0 
+// [2]      -- DELTA_WEIGHT1 
+// [3]      -- OFFSET1 
+// ......
+// [62]     -- DELTA_WEIGHT31
+// [63]     -- OFFSET31
+#define HEVCD_MPP_WEIGHT_DATA                      ((0x3481  << 2) + 0xd0050000)
+// For DELTA_WEIGHT :
+// [7:0]    -- delta_y_weight for refidx0:0
+// [15:8]   -- delta_cb_weight for refidx0:0
+// [23:16]  -- delta_cr_weight for refidx0:0
+// For OFFSET :
+// [7:0]    -- luma_offset for refidx0:0
+// [17:8]   -- delta_cb_offset for refidx0:0
+// [27:18]  -- delta_cr_offset for refidx0:0 
+// ID to Anchor-Canvas-Address table
+// [31:13]  reserved
+// [12:8]   access_index
+// [7:2]    reserved
+// [1]      auto_inc_read
+// [0]      auto_inc_write
+#define HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR        ((0x34c0  << 2) + 0xd0050000)
+// Id[4:0]  --> {AnchorAddrCr[7:0],AnchorAddrCb[7:0],AnchorAddrY[7:0]}
+#define HEVCD_MPP_ANC_CANVAS_DATA_ADDR             ((0x34c1  << 2) + 0xd0050000)
+//////////////////////////////////////////////////////////////////////////////
+///// MCRCC_AXI Registers                                 ////////////////////
+//////////////////////////////////////////////////////////////////////////////
+// HEVCD_MCRCC_CTL1
+// 31:12 <reserved[20:0]>
+// 11:10 <cfg_anc11_tb>                           // 01: top 10:bot 11:frame
+// 9:8   <cfg_anc10_tb>
+// 7:6   <cfg_anc01_tb>
+// 5:4   <cfg_anc00_tb>
+// 3     <cfg_clkgate_disbl>
+// 2     <cfg_field_pic>                           // not used for hevc
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define HEVCD_MCRCC_CTL1                           ((0x34f0  << 2) + 0xd0050000)
+// HEVCD_MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define HEVCD_MCRCC_CTL2                           ((0x34f1  << 2) + 0xd0050000)
+// HEVCD_MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define HEVCD_MCRCC_CTL3                           ((0x34f2  << 2) + 0xd0050000)
+// HEVCD_MCRCC_PERFMON_CTL                      
+// [0]      percount_reset 
+// [3:1]    perfcout_sel
+// [31:4]   reserved
+#define HEVCD_MCRCC_PERFMON_CTL                    ((0x34f3  << 2) + 0xd0050000)
+// HEVCD_MCRCC_PERFMON_DATA                      
+// [31:0]   percount_data 
+#define HEVCD_MCRCC_PERFMON_DATA                   ((0x34f4  << 2) + 0xd0050000)
+//
+// Closing file:  hevc_ipp_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_DBLK module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_dblk_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_DBLK_CBUS_BASE = 0x05
+// -----------------------------------------------
+//cfg0[0];        //software_reset
+//cfg0[1];        //status clear, only for axi error or pic_done
+//cfg0[2];        //clock_forced_on_all
+//cfg0[3];        //clock_forced_off_all
+//cfg0[11:8];     //PU FIFO Threshold   , 0:16 1:1 ... 1:15
+//cfg0[15:12];    //TU FIFO Threshold>>4, 0:16<<4 1:1<<4 ... 1:15<<4
+//cfg0[29:16];    //clock_forced_on_submodules
+#define HEVC_DBLK_CFG0                             ((0x3500  << 2) + 0xd0050000)
+//cfg1[1:0];      //ctb_size 0:64x64 1:32x32 2:16x16
+//cfg1[2];        //ignore_out_of_boundary
+//cfg1[3];        //pcm_loop_filter_disabled_flag
+//cfg1[8:4];      //pps_cb_qp_offset (-12~12,inclusive)
+//cfg1[13:9];     //pps_cr_qp_offset (-12~12,inclusive)
+//cfg1[14];       //ctbx,y swap in pu i/f
+//cfg1[15];       //sao_corner_45_degree_all_software_control
+#define HEVC_DBLK_CFG1                             ((0x3501  << 2) + 0xd0050000)
+//cfg2[15:0];     //picture_size_width
+//cfg2[31:16];    //picture_size_height
+#define HEVC_DBLK_CFG2                             ((0x3502  << 2) + 0xd0050000)
+//cfg3[3:0];      //parameter_axi_arid
+//cfg3[7:4];      //parameter_axi_awid
+//cfg3[11:8];     //parameter_axi_wid
+//cfg3[12];       //parameter_axi_not_check_write_response
+//cfg3[19:16];    //data_axi_arid
+//cfg3[23:20];    //data_axi_awid
+//cfg3[27:24];    //data_axi_wid
+//cfg3[28];       //data_axi_not_check_write_response
+#define HEVC_DBLK_CFG3                             ((0x3503  << 2) + 0xd0050000)
+//cfg4[31:0];     //parameter_axi_start_address
+#define HEVC_DBLK_CFG4                             ((0x3504  << 2) + 0xd0050000)
+//cfg5[31:0];     //data_axi_start_address
+#define HEVC_DBLK_CFG5                             ((0x3505  << 2) + 0xd0050000)
+//cfg6[9:0];      //tile_ctbx
+//cfg6[25:16];    //tile_ctby
+//cfg6[31];       //tile_enabled
+#define HEVC_DBLK_CFG6                             ((0x3506  << 2) + 0xd0050000)
+//cfg7[9:0];      //tile_ctbxsize
+//cfg7[25:16];    //tile_ctbysize
+#define HEVC_DBLK_CFG7                             ((0x3507  << 2) + 0xd0050000)
+//cfg8[9:0];      //start_ctbx, normally equals to tile_ctbx
+//cfg8[25:16];    //start_ctby, normally equals to tile_ctby
+//cfg8[31];       //start, self_cleared signal, normally set it at the begin of tile
+#define HEVC_DBLK_CFG8                             ((0x3508  << 2) + 0xd0050000)
+//cfg9[0]         //loop_filter_across_tiles_enabled_flag
+//cfg9[1]         //loop_filter_across_slices_enabled_flag
+//cfg9[2]         //deblocking_filter_disabled_flag
+//cfg9[6:3]       //beta_offset_div2 (-6~6,inclusive)
+//cfg9[10:7]      //tc_offset_div2 (-6~6,inclusive)
+#define HEVC_DBLK_CFG9                             ((0x3509  << 2) + 0xd0050000)
+//cfga[4:0]       //corner45degree{FIFO_CNT}
+//cfga[31:27]     //corner45degree{EN,FIFO_CLR,FIFO_PUSH,DATA,DATA_SEL}
+#define HEVC_DBLK_CFGA                             ((0x350a  << 2) + 0xd0050000)
+//TODO description
+#define HEVC_DBLK_STS0                             ((0x350b  << 2) + 0xd0050000)
+//TODO description
+#define HEVC_DBLK_STS1                             ((0x350c  << 2) + 0xd0050000)
+//
+// Closing file:  hevc_dblk_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_SAO module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_sao_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_SAO_CBUS_BASE = 0x06
+// -----------------------------------------------
+#define HEVC_SAO_VERSION                           ((0x3600  << 2) + 0xd0050000)
+//  [31:0]  reversion               default:32'h00010001
+#define HEVC_SAO_CTRL0                             ((0x3601  << 2) + 0xd0050000)
+//  [3:0]   lcu_size_log2
+#define HEVC_SAO_CTRL1                             ((0x3602  << 2) + 0xd0050000)
+//  [31:24] ar_fifo1_axi_thred 
+//  [23:16] ar_fifo0_axi_thred 
+//  [15:14] axi_linealign, 0-16bytes, 1-32bytes, 2-64bytes
+//  [13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32
+//  [11:08] axi_lendian_C
+//  [07:04] axi_lendian_Y
+//  [3]     reserved
+//  [2]     clk_forceon
+//  [1]     reserved
+//  [0]     reserved
+#define HEVC_SAO_INT_EN                            ((0x3603  << 2) + 0xd0050000)
+//  [0]     sao_int_enable
+//  [1]     sao_int_amrisc_level
+//  [2]     sao_int_cpu_level
+//  [3]     slice_done_int_amrisc_enable
+//  [4]     slice_done_int_cpu_enable
+//  [15]    disable_sao_int_clock_gating
+#define HEVC_SAO_INT_STATUS                        ((0x3604  << 2) + 0xd0050000)
+//  [0]     slice_done IRQ  
+//  [31]    write "1"=slice start(self clear,read always return "0")
+#define HEVC_SAO_PIC_SIZE                          ((0x3605  << 2) + 0xd0050000)
+//  [15:0]  pic_width[15:0]
+//  [31:16] pic_height[15:0]
+#define HEVC_SAO_PIC_SIZE_LCU                      ((0x3606  << 2) + 0xd0050000)
+//  [15:0]  lcu_x_num_1[15:0]   (=lcu_x_total-1)
+//  [31:16] lcu_y_num_1[15:0]   (=lcu_y_total-1)
+#define HEVC_SAO_TILE_START                        ((0x3607  << 2) + 0xd0050000)
+//  [15:0]  tile_start_lcu_x[15:0]
+//  [31:16] tile_start_lcu_y[15:0]
+#define HEVC_SAO_TILE_SIZE_LCU                     ((0x3608  << 2) + 0xd0050000)
+//  [15:0]  tile_width_lcu[15:0]
+//  [31:16] tile_height_lcu[15:0]
+#define HEVC_SAO_AXI_WCTRL                         ((0x3609  << 2) + 0xd0050000)
+#define HEVC_SAO_AXI_RCTRL                         ((0x360a  << 2) + 0xd0050000)
+#define HEVC_SAO_Y_START_ADDR                      ((0x360b  << 2) + 0xd0050000)
+#define HEVC_SAO_Y_LENGTH                          ((0x360c  << 2) + 0xd0050000)
+#define HEVC_SAO_C_START_ADDR                      ((0x360d  << 2) + 0xd0050000)
+#define HEVC_SAO_C_LENGTH                          ((0x360e  << 2) + 0xd0050000)
+#define HEVC_SAO_Y_WPTR                            ((0x360f  << 2) + 0xd0050000)
+#define HEVC_SAO_C_WPTR                            ((0x3610  << 2) + 0xd0050000)
+#define HEVC_SAO_ABV_START_ADDR                    ((0x3611  << 2) + 0xd0050000)
+#define HEVC_SAO_VB_WR_START_ADDR                  ((0x3612  << 2) + 0xd0050000)
+#define HEVC_SAO_VB_RD_START_ADDR                  ((0x3613  << 2) + 0xd0050000)
+#define HEVC_SAO_ABV_WPTR                          ((0x3614  << 2) + 0xd0050000)
+#define HEVC_SAO_ABV_RPTR                          ((0x3615  << 2) + 0xd0050000)
+#define HEVC_SAO_VB_WPTR                           ((0x3616  << 2) + 0xd0050000)
+#define HEVC_SAO_VB_RPTR                           ((0x3617  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_MODE0                         ((0x361e  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_MODE1                         ((0x361f  << 2) + 0xd0050000)
+#define HEVC_SAO_CTRL2                             ((0x3620  << 2) + 0xd0050000)
+#define HEVC_SAO_CTRL3                             ((0x3621  << 2) + 0xd0050000)
+#define HEVC_SAO_CTRL4                             ((0x3622  << 2) + 0xd0050000)
+#define HEVC_SAO_CTRL5                             ((0x3623  << 2) + 0xd0050000)
+#define HEVC_SAO_CTRL6                             ((0x3624  << 2) + 0xd0050000)
+#define HEVC_SAO_CTRL7                             ((0x3625  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_DATA_0                        ((0x3630  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_DATA_1                        ((0x3631  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_DATA_2                        ((0x3632  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_DATA_3                        ((0x3633  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_DATA_4                        ((0x3634  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_DATA_5                        ((0x3635  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_DATA_6                        ((0x3636  << 2) + 0xd0050000)
+#define HEVC_SAO_DBG_DATA_7                        ((0x3637  << 2) + 0xd0050000)
+//
+// Closing file:  hevc_sao_regs.h
+//
+//------------------------------------------------------------------------------
+// HEVC_IQIT module level register offset
+//------------------------------------------------------------------------------
+//
+// Reading file:  hevc_iqit_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HEVC_IQIT_CBUS_BASE = 0x07
+// -----------------------------------------------
+// [    2] RW en_freeclk.   0=Auto-gated clock for saving power;
+//                          1=Free running clock if something wrong with auto-gating.
+//                          Default 0.
+// [    1] RW enable_clk.   0=Disable clock; 1=Enable clock.        Default 0.
+// [    0] RW sw_reset.     0=Release from reset; 1=Apply reset.    Default 0.
+#define HEVC_IQIT_CLK_RST_CTRL                     ((0x3700  << 2) + 0xd0050000)
+// [ 5: 4] RW ctb_size.     0=8x8; 1=16x16; 2=32x32; 3=64x64.                       Default 0.
+// [    3] RW itr_skip_mode. For dealing with discrepancy between Spec and C model for transform_skip.
+//                          0=Follow Spec; 1=Follow C model.                        Default 0.
+// [    2] RW scalelist_mode. Applicable only when scalelist_en=1.
+//                          0=Use default scaling factor list;
+//                          1=Use scaling factor list define in bit stream.
+//                          Default 0.
+// [    1] RW scalelist_en. 0=Use flat scale; 1=Use scaling factor list.            Default 0.
+// [    0] RW diagscan_en.  0=Linear lookup dQ table; 1=Diagonally lookup dQ table. Default 0.
+#define HEVC_IQIT_DEQUANT_CTRL                     ((0x3701  << 2) + 0xd0050000)
+// [31:10] WR Reserved.                                 Default 0.
+// [ 9: 0] WR scalelut_addr.                            Default 0.
+#define HEVC_IQIT_SCALELUT_WR_ADDR                 ((0x3702  << 2) + 0xd0050000)
+// [31:10] RD Reserved.                                 Default 0.
+// [ 9: 0] RD scalelut_addr.                            Default 0.
+#define HEVC_IQIT_SCALELUT_RD_ADDR                 ((0x3703  << 2) + 0xd0050000)
+// [ 7: 0] RW LUT data.
+#define HEVC_IQIT_SCALELUT_DATA                    ((0x3704  << 2) + 0xd0050000)
+//---------------------------------------------------
+// tab_idx [2:0] - 
+//    0-5 use custom table index
+//    6 - reserved
+//    7 - use default table
+//---------------------------------------------------
+// [22:20] 4x4 tab 5 
+// [   19] reserved
+// [18:16] 4x4 tab 4
+// [   15] reserved
+// [14:12] 4x4 tab 3
+// [   11] reserved
+// [10: 8] 4x4 tab 2
+// [    7] reserved
+// [ 6: 4] 4x4 tab 1
+// [    3] reserved
+// [ 2: 0] 4x4 tab 0
+#define HEVC_IQIT_SCALELUT_IDX_4                   ((0x3705  << 2) + 0xd0050000)
+// [22:20] 8x8 tab 5 
+// [   19] reserved
+// [18:16] 8x8 tab 4
+// [   15] reserved
+// [14:12] 8x8 tab 3
+// [   11] reserved
+// [10: 8] 8x8 tab 2
+// [    7] reserved
+// [ 6: 4] 8x8 tab 1
+// [    3] reserved
+// [ 2: 0] 8x8 tab 0
+#define HEVC_IQIT_SCALELUT_IDX_8                   ((0x3706  << 2) + 0xd0050000)
+// [   31] reserved
+// [30:28] 32x32 tab 1
+// [   27] reserved
+// [26:24] 32x32 tab 0
+// [   23] reserved
+// [22:20] 16x16 tab 5 
+// [   19] reserved
+// [18:16] 16x16 tab 4
+// [   15] reserved
+// [14:12] 16x16 tab 3
+// [   11] reserved
+// [10: 8] 16x16 tab 2
+// [    7] reserved
+// [ 6: 4] 16x16 tab 1
+// [    3] reserved
+// [ 2: 0] 16x16 tab 0
+#define HEVC_IQIT_SCALELUT_IDX_16_32               ((0x3707  << 2) + 0xd0050000)
+// [ 7: 2] R  tuinfo_fifo_cnt.
+// [    1] R  fifo_has_room.
+// [    0] R  mem_init_done.
+#define HEVC_IQIT_STAT_GEN0                        ((0x3708  << 2) + 0xd0050000)
+// [   23] RW cntl_qp_cr_valid.
+// [21:16] RW cntl_qp_cr.
+// [   15] RW cntl_qp_cb_valid.
+// [13: 8] RW cntl_qp_cb.
+// [    7] RW cntl_qp_y_valid.
+// [ 5: 0] RW cntl_qp_y.
+#define HEVC_QP_WRITE                              ((0x3709  << 2) + 0xd0050000)
+// [   31] R  ipp_active.
+// [   30] R  itr2_active.
+// [   29] R  itr1_active.
+// [28:24] R  mem_spare_num.
+// [23:22] R  ipp_size.
+// [21:20] R  itr2_size.
+// [19:18] R  itr1_size.
+// [17:16] R  iq_size.
+// [15:12] R  ipp_mem_ptr.
+// [11: 8] R  itr2_mem_ptr.
+// [ 7: 4] R  itr1_mem_ptr.
+// [ 3: 0] R  iq_mem_ptr.
+#define HEVC_IQIT_STAT_GEN1                        ((0x370a  << 2) + 0xd0050000)
+//
+// Closing file:  hevc_iqit_regs.h
+//
+//------------------------------------------------------------------------------
+//  DOS top-level register offset
+//------------------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  DOS_TOP_CBUS_BASE = 0x3f
+// -----------------------------------------------
+// [0]  reserved
+// [1]  Reset Dos top level registers, except sw_reset0/1/2 which is only reset by external reset_n.
+// [2]  VDEC1 Reset assist, mdec's CBUS
+// [3]  VDEC1 Reset mdec's VLD
+// [4]  VDEC1 Reset mdec's VLD
+// [5]  VDEC1 Reset mdec's VLD
+// [6]  VDEC1 Reset mdec's IQIDCT
+// [7]  VDEC1 Reset mdec's MC
+// [8]  VDEC1 Reset mdec's DBLK
+// [9]  VDEC1 Reset mdec's PIC_DC
+// [10] VDEC1 Reset mdec's Pscale
+// [11] VDEC1 Reset vcpu's MCPU
+// [12] VDEC1 Reset vcpu's CCPU
+// [13] VDEC1 Reset mmc_pre_arb
+#define DOS_SW_RESET0                              ((0x3f00  << 2) + 0xd0050000)
+// [31:27] reserved
+// [26] hcodec clk_en for henc assist
+// [25:22] reserved
+// [21] hcodec clk_en for henc qdct
+// [20] hcodec clk_en for henc vlc
+// [19] hcodec clk_en for assist and cbus
+// [18] hcodec clk_en for ddr
+// [17] hcodec clk_en for vcpu
+// [16] hcodec clk_en for hdec assist
+// [15] hcodec clk_en for hdec dblk
+// [14] reserved
+// [13] hcodec clk_en for hdec mc
+// [12] hcodec clk_en for hdec pic_dc
+// [11:10] reserved
+// [9] vdec clk_en for vdec assist and cbus
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for mdec vld
+// [5] vdec clk_en for mdec psc
+// [4] vdec clk_en for mdec pic_dc
+// [3] vdec clk_en for mdec mc
+// [2] vdec clk_en for mdec iqidct
+// [1] vdec clk_en for mdec dblk
+// [0] vdec clk_en for mdec assist
+#define DOS_GCLK_EN0                               ((0x3f01  << 2) + 0xd0050000)
+#define DOS_GEN_CTRL0                              ((0x3f02  << 2) + 0xd0050000)
+#define DOS_APB_ERR_CTRL                           ((0x3f03  << 2) + 0xd0050000)
+#define DOS_APB_ERR_STAT                           ((0x3f04  << 2) + 0xd0050000)
+#define DOS_VDEC_INT_EN                            ((0x3f05  << 2) + 0xd0050000)
+#define DOS_HCODEC_INT_EN                          ((0x3f06  << 2) + 0xd0050000)
+// [0]  Reserved
+// [1]  Reserved
+// [2]  HCODEC Reset assist, hdec's CBUS
+// [3]  HCODEC Reset hdec's VLD
+// [4]  HCODEC Reset hdec's VLD
+// [5]  HCODEC Reset hdec's VLD
+// [6]  HCODEC Reset hdec's IQIDCT
+// [7]  HCODEC Reset hdec's MC
+// [8]  HCODEC Reset hdec's DBLK
+// [9]  HCODEC Reset hdec's PIC_DC
+// [10] HCODEC Reset hdec's Pscale
+// [11] HCODEC Reset vcpu's MCPU
+// [12] HCODEC Reset vcpu's CCPU
+// [13] HCODEC Reset mmc_pre_arb
+// [14] HCODEC Reserved
+// [15] HCODEC Reserved
+// [16] HCODEC Reset henc's VLC 
+#define DOS_SW_RESET1                              ((0x3f07  << 2) + 0xd0050000)
+// [0]  Reserved 
+// [1]  Reserved
+// [2]  VDEC2 Reset assist, mdec's CBUS
+// [3]  VDEC2 Reset mdec's VLD
+// [4]  VDEC2 Reset mdec's VLD
+// [5]  VDEC2 Reset mdec's VLD
+// [6]  VDEC2 Reset mdec's IQIDCT
+// [7]  VDEC2 Reset mdec's MC
+// [8]  VDEC2 Reset mdec's DBLK
+// [9]  VDEC2 Reset mdec's PIC_DC
+// [10] VDEC2 Reset mdec's Pscale
+// [11] VDEC2 Reset vcpu's MCPU
+// [12] VDEC2 Reset vcpu's CCPU
+// [13] VDEC2 Reset mmc_pre_arb
+#define DOS_SW_RESET2                              ((0x3f08  << 2) + 0xd0050000)
+// [31:10] Reserved
+// [9] vdec2 clk_en for assist and cbus.
+// [8] vdec2 clk_en for ddr;
+// [7] vdec2 clk_en for vcpu;
+// [6] vdec2 clk_en for mdec vld
+// [5] vdec2 clk_en for mdec psc
+// [4] vdec2 clk_en for mdec pic_dc
+// [3] vdec2 clk_en for mdec mc
+// [2] vdec2 clk_en for mdec iqidct
+// [1] vdec2 clk_en for mdec dblk
+// [0] vdec2 clk_en for mdec assist
+#define DOS_GCLK_EN1                               ((0x3f09  << 2) + 0xd0050000)
+#define DOS_VDEC2_INT_EN                           ((0x3f0a  << 2) + 0xd0050000)
+#define DOS_VDIN_LCNT                              ((0x3f0b  << 2) + 0xd0050000)
+#define DOS_VDIN_FCNT                              ((0x3f0c  << 2) + 0xd0050000)
+#define DOS_VDIN_CCTL                              ((0x3f0d  << 2) + 0xd0050000)
+#define DOS_SCRATCH0                               ((0x3f10  << 2) + 0xd0050000)
+#define DOS_SCRATCH1                               ((0x3f11  << 2) + 0xd0050000)
+#define DOS_SCRATCH2                               ((0x3f12  << 2) + 0xd0050000)
+#define DOS_SCRATCH3                               ((0x3f13  << 2) + 0xd0050000)
+#define DOS_SCRATCH4                               ((0x3f14  << 2) + 0xd0050000)
+#define DOS_SCRATCH5                               ((0x3f15  << 2) + 0xd0050000)
+#define DOS_SCRATCH6                               ((0x3f16  << 2) + 0xd0050000)
+#define DOS_SCRATCH7                               ((0x3f17  << 2) + 0xd0050000)
+#define DOS_SCRATCH8                               ((0x3f18  << 2) + 0xd0050000)
+#define DOS_SCRATCH9                               ((0x3f19  << 2) + 0xd0050000)
+#define DOS_SCRATCH10                              ((0x3f1a  << 2) + 0xd0050000)
+#define DOS_SCRATCH11                              ((0x3f1b  << 2) + 0xd0050000)
+#define DOS_SCRATCH12                              ((0x3f1c  << 2) + 0xd0050000)
+#define DOS_SCRATCH13                              ((0x3f1d  << 2) + 0xd0050000)
+#define DOS_SCRATCH14                              ((0x3f1e  << 2) + 0xd0050000)
+#define DOS_SCRATCH15                              ((0x3f1f  << 2) + 0xd0050000)
+#define DOS_SCRATCH16                              ((0x3f20  << 2) + 0xd0050000)
+#define DOS_SCRATCH17                              ((0x3f21  << 2) + 0xd0050000)
+#define DOS_SCRATCH18                              ((0x3f22  << 2) + 0xd0050000)
+#define DOS_SCRATCH19                              ((0x3f23  << 2) + 0xd0050000)
+#define DOS_SCRATCH20                              ((0x3f24  << 2) + 0xd0050000)
+#define DOS_SCRATCH21                              ((0x3f25  << 2) + 0xd0050000)
+#define DOS_SCRATCH22                              ((0x3f26  << 2) + 0xd0050000)
+#define DOS_SCRATCH23                              ((0x3f27  << 2) + 0xd0050000)
+#define DOS_SCRATCH24                              ((0x3f28  << 2) + 0xd0050000)
+#define DOS_SCRATCH25                              ((0x3f29  << 2) + 0xd0050000)
+#define DOS_SCRATCH26                              ((0x3f2a  << 2) + 0xd0050000)
+#define DOS_SCRATCH27                              ((0x3f2b  << 2) + 0xd0050000)
+#define DOS_SCRATCH28                              ((0x3f2c  << 2) + 0xd0050000)
+#define DOS_SCRATCH29                              ((0x3f2d  << 2) + 0xd0050000)
+#define DOS_SCRATCH30                              ((0x3f2e  << 2) + 0xd0050000)
+#define DOS_SCRATCH31                              ((0x3f2f  << 2) + 0xd0050000)
+#define DOS_MEM_PD_VDEC                            ((0x3f30  << 2) + 0xd0050000)
+#define DOS_MEM_PD_VDEC2                           ((0x3f31  << 2) + 0xd0050000)
+#define DOS_MEM_PD_HCODEC                          ((0x3f32  << 2) + 0xd0050000)
+#define DOS_MEM_PD_HEVC                            ((0x3f33  << 2) + 0xd0050000)
+#define DOS_SW_RESET3                              ((0x3f34  << 2) + 0xd0050000)
+#define DOS_GCLK_EN3                               ((0x3f35  << 2) + 0xd0050000)
+#define DOS_HEVC_INT_EN                            ((0x3f36  << 2) + 0xd0050000)
+// bit[31]    mcrcc_stall_en
+// bit[30:28] Reserved
+// bit[27:20] target_canvas
+// bit[19:10] target_mby
+// bit[ 9: 0] target_mbx
+#define DOS_VDEC_MCRCC_STALL_CTRL                  ((0x3f40  << 2) + 0xd0050000)
+#define DOS_VDEC_MCRCC_STALL2_CTRL                 ((0x3f42  << 2) + 0xd0050000)
+#define DOS_VDEC2_MCRCC_STALL_CTRL                 ((0x3f41  << 2) + 0xd0050000)
+#define DOS_VDEC2_MCRCC_STALL2_CTRL                ((0x3f43  << 2) + 0xd0050000)
+//
+// Closing file:  ./dos_param.h
+//
+//
+// Reading file:  mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_MDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+#define HCODEC_MC_CTRL_REG                         ((0x1900  << 2) + 0xd0050000)
+#define HCODEC_MC_MB_INFO                          ((0x1901  << 2) + 0xd0050000)
+#define HCODEC_MC_PIC_INFO                         ((0x1902  << 2) + 0xd0050000)
+#define HCODEC_MC_HALF_PEL_ONE                     ((0x1903  << 2) + 0xd0050000)
+#define HCODEC_MC_HALF_PEL_TWO                     ((0x1904  << 2) + 0xd0050000)
+#define HCODEC_POWER_CTL_MC                        ((0x1905  << 2) + 0xd0050000)
+#define HCODEC_MC_CMD                              ((0x1906  << 2) + 0xd0050000)
+#define HCODEC_MC_CTRL0                            ((0x1907  << 2) + 0xd0050000)
+#define HCODEC_MC_PIC_W_H                          ((0x1908  << 2) + 0xd0050000)
+#define HCODEC_MC_STATUS0                          ((0x1909  << 2) + 0xd0050000)
+#define HCODEC_MC_STATUS1                          ((0x190a  << 2) + 0xd0050000)
+#define HCODEC_MC_CTRL1                            ((0x190b  << 2) + 0xd0050000)
+#define HCODEC_MC_MIX_RATIO0                       ((0x190c  << 2) + 0xd0050000)
+#define HCODEC_MC_MIX_RATIO1                       ((0x190d  << 2) + 0xd0050000)
+#define HCODEC_MC_DP_MB_XY                         ((0x190e  << 2) + 0xd0050000)
+#define HCODEC_MC_OM_MB_XY                         ((0x190f  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_RST                          ((0x1910  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_CTRL                         ((0x1911  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_PICI_W                       ((0x1912  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_PICI_H                       ((0x1913  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_PICO_W                       ((0x1914  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_PICO_H                       ((0x1915  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_PICO_START_X                 ((0x1916  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_PICO_START_Y                 ((0x1917  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_DUMMY                        ((0x1918  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_FILT0_COEF0                  ((0x1919  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_FILT0_COEF1                  ((0x191a  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_CMD_CTRL                     ((0x191b  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_CMD_BLK_X                    ((0x191c  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_CMD_BLK_Y                    ((0x191d  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_STATUS                       ((0x191e  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_BMEM_ADDR                    ((0x191f  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_BMEM_DAT                     ((0x1920  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_DRAM_BUF_CTRL                ((0x1921  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_MCMD_CTRL                    ((0x1922  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_MCMD_XSIZE                   ((0x1923  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_MCMD_YSIZE                   ((0x1924  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_RBUF_START_BLKX              ((0x1925  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_RBUF_START_BLKY              ((0x1926  << 2) + 0xd0050000)
+//`define PSCALE_RBUF_MB_WIDTH   8'h27
+#define HCODEC_PSCALE_PICO_SHIFT_XY                ((0x1928  << 2) + 0xd0050000)
+#define HCODEC_PSCALE_CTRL1                        ((0x1929  << 2) + 0xd0050000)
+//Bit 15, wmask enable
+//Bit 14:13, filt0 srckey_less, 
+//Bit 12:11, filt1 srckey_less, in the case of the interpolated data is equal distance to 
+//key data and normal data, 00: select normal data, 01: select right data, 10: select key data
+//Bit 10:9, srckey mode, 00: equal, 01: less than or equal, 10: great than or equal
+//Bit 8, src key enable
+//Bit 7:0, y src key
+#define HCODEC_PSCALE_SRCKEY_CTRL0                 ((0x192a  << 2) + 0xd0050000)
+//Bit 15:8, cb src key
+//Bit 7:0, cr src key
+#define HCODEC_PSCALE_SRCKEY_CTRL1                 ((0x192b  << 2) + 0xd0050000)
+//Bit 22:16 canvas_rd_addr2
+//Bit 14:8 canvas_rd_addr1
+//Bit 6:0 canvas_rd_addr1
+#define HCODEC_PSCALE_CANVAS_RD_ADDR               ((0x192c  << 2) + 0xd0050000)
+//Bit 22:16 canvas_wr_addr2
+//Bit 14:8 canvas_wr_addr1
+//Bit 6:0 canvas_wr_addr1
+#define HCODEC_PSCALE_CANVAS_WR_ADDR               ((0x192d  << 2) + 0xd0050000)
+//bit 13:8 pscale thread ID and token 
+//bit 7 disable write response count adding to busy bit 
+//bit 5:0  pscale prearbitor burst num
+#define HCODEC_PSCALE_CTRL2                        ((0x192e  << 2) + 0xd0050000)
+//   31 - use_omem_mb_xy_auto
+//23:16 - omem_max_mb_x
+//15:8  - omem_mb_y_auto
+// 7:0  - omem_mb_x_auto
+#define HCODEC_HDEC_MC_OMEM_AUTO                   ((0x1930  << 2) + 0xd0050000)
+#define HCODEC_HDEC_MC_MBRIGHT_IDX                 ((0x1931  << 2) + 0xd0050000)
+#define HCODEC_HDEC_MC_MBRIGHT_RD                  ((0x1932  << 2) + 0xd0050000)
+#define HCODEC_MC_MPORT_CTRL                       ((0x1940  << 2) + 0xd0050000)
+#define HCODEC_MC_MPORT_DAT                        ((0x1941  << 2) + 0xd0050000)
+#define HCODEC_MC_WT_PRED_CTRL                     ((0x1942  << 2) + 0xd0050000)
+#define HCODEC_MC_MBBOT_ST_EVEN_ADDR               ((0x1944  << 2) + 0xd0050000)
+#define HCODEC_MC_MBBOT_ST_ODD_ADDR                ((0x1945  << 2) + 0xd0050000)
+#define HCODEC_MC_DPDN_MB_XY                       ((0x1946  << 2) + 0xd0050000)
+#define HCODEC_MC_OMDN_MB_XY                       ((0x1947  << 2) + 0xd0050000)
+#define HCODEC_MC_HCMDBUF_H                        ((0x1948  << 2) + 0xd0050000)
+#define HCODEC_MC_HCMDBUF_L                        ((0x1949  << 2) + 0xd0050000)
+#define HCODEC_MC_HCMD_H                           ((0x194a  << 2) + 0xd0050000)
+#define HCODEC_MC_HCMD_L                           ((0x194b  << 2) + 0xd0050000)
+#define HCODEC_MC_IDCT_DAT                         ((0x194c  << 2) + 0xd0050000)
+#define HCODEC_MC_CTRL_GCLK_CTRL                   ((0x194d  << 2) + 0xd0050000)
+#define HCODEC_MC_OTHER_GCLK_CTRL                  ((0x194e  << 2) + 0xd0050000)
+//Bit 29:24, mbbot thread ID and token 
+//Bit 21:16, mc read/write thread ID and token 
+//Bit 13:8,  mbbot pre-arbitor burst number 
+//Bit 5:0,   mc pre-arbitor burst number 
+#define HCODEC_MC_CTRL2                            ((0x194f  << 2) + 0xd0050000)
+// `define DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define ANC1_CANVAS_ADDR      8'h80
+//`define ANC2_CANVAS_ADDR      8'h81
+//`define REC_CANVAS_ADDR       8'h89
+//`define MDEC_PIC_W          8'h8c
+//`define MDEC_PIC_H          8'h8d
+#define HCODEC_MDEC_PIC_DC_CTRL                    ((0x198e  << 2) + 0xd0050000)
+#define HCODEC_MDEC_PIC_DC_STATUS                  ((0x198f  << 2) + 0xd0050000)
+#define HCODEC_ANC0_CANVAS_ADDR                    ((0x1990  << 2) + 0xd0050000)
+#define HCODEC_ANC1_CANVAS_ADDR                    ((0x1991  << 2) + 0xd0050000)
+#define HCODEC_ANC2_CANVAS_ADDR                    ((0x1992  << 2) + 0xd0050000)
+#define HCODEC_ANC3_CANVAS_ADDR                    ((0x1993  << 2) + 0xd0050000)
+#define HCODEC_ANC4_CANVAS_ADDR                    ((0x1994  << 2) + 0xd0050000)
+#define HCODEC_ANC5_CANVAS_ADDR                    ((0x1995  << 2) + 0xd0050000)
+#define HCODEC_ANC6_CANVAS_ADDR                    ((0x1996  << 2) + 0xd0050000)
+#define HCODEC_ANC7_CANVAS_ADDR                    ((0x1997  << 2) + 0xd0050000)
+#define HCODEC_ANC8_CANVAS_ADDR                    ((0x1998  << 2) + 0xd0050000)
+#define HCODEC_ANC9_CANVAS_ADDR                    ((0x1999  << 2) + 0xd0050000)
+#define HCODEC_ANC10_CANVAS_ADDR                   ((0x199a  << 2) + 0xd0050000)
+#define HCODEC_ANC11_CANVAS_ADDR                   ((0x199b  << 2) + 0xd0050000)
+#define HCODEC_ANC12_CANVAS_ADDR                   ((0x199c  << 2) + 0xd0050000)
+#define HCODEC_ANC13_CANVAS_ADDR                   ((0x199d  << 2) + 0xd0050000)
+#define HCODEC_ANC14_CANVAS_ADDR                   ((0x199e  << 2) + 0xd0050000)
+#define HCODEC_ANC15_CANVAS_ADDR                   ((0x199f  << 2) + 0xd0050000)
+#define HCODEC_ANC16_CANVAS_ADDR                   ((0x19a0  << 2) + 0xd0050000)
+#define HCODEC_ANC17_CANVAS_ADDR                   ((0x19a1  << 2) + 0xd0050000)
+#define HCODEC_ANC18_CANVAS_ADDR                   ((0x19a2  << 2) + 0xd0050000)
+#define HCODEC_ANC19_CANVAS_ADDR                   ((0x19a3  << 2) + 0xd0050000)
+#define HCODEC_ANC20_CANVAS_ADDR                   ((0x19a4  << 2) + 0xd0050000)
+#define HCODEC_ANC21_CANVAS_ADDR                   ((0x19a5  << 2) + 0xd0050000)
+#define HCODEC_ANC22_CANVAS_ADDR                   ((0x19a6  << 2) + 0xd0050000)
+#define HCODEC_ANC23_CANVAS_ADDR                   ((0x19a7  << 2) + 0xd0050000)
+#define HCODEC_ANC24_CANVAS_ADDR                   ((0x19a8  << 2) + 0xd0050000)
+#define HCODEC_ANC25_CANVAS_ADDR                   ((0x19a9  << 2) + 0xd0050000)
+#define HCODEC_ANC26_CANVAS_ADDR                   ((0x19aa  << 2) + 0xd0050000)
+#define HCODEC_ANC27_CANVAS_ADDR                   ((0x19ab  << 2) + 0xd0050000)
+#define HCODEC_ANC28_CANVAS_ADDR                   ((0x19ac  << 2) + 0xd0050000)
+#define HCODEC_ANC29_CANVAS_ADDR                   ((0x19ad  << 2) + 0xd0050000)
+#define HCODEC_ANC30_CANVAS_ADDR                   ((0x19ae  << 2) + 0xd0050000)
+#define HCODEC_ANC31_CANVAS_ADDR                   ((0x19af  << 2) + 0xd0050000)
+#define HCODEC_DBKR_CANVAS_ADDR                    ((0x19b0  << 2) + 0xd0050000)
+#define HCODEC_DBKW_CANVAS_ADDR                    ((0x19b1  << 2) + 0xd0050000)
+#define HCODEC_REC_CANVAS_ADDR                     ((0x19b2  << 2) + 0xd0050000)
+//28:24, read/write, current canvas idx, used in h264 only now
+//23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+#define HCODEC_CURR_CANVAS_CTRL                    ((0x19b3  << 2) + 0xd0050000)
+#define HCODEC_MDEC_PIC_DC_THRESH                  ((0x19b8  << 2) + 0xd0050000)
+#define HCODEC_MDEC_PICR_BUF_STATUS                ((0x19b9  << 2) + 0xd0050000)
+#define HCODEC_MDEC_PICW_BUF_STATUS                ((0x19ba  << 2) + 0xd0050000)
+#define HCODEC_MCW_DBLK_WRRSP_CNT                  ((0x19bb  << 2) + 0xd0050000)
+#define HCODEC_MC_MBBOT_WRRSP_CNT                  ((0x19bc  << 2) + 0xd0050000)
+#define HCODEC_MDEC_PICW_BUF2_STATUS               ((0x19bd  << 2) + 0xd0050000)
+#define HCODEC_WRRSP_FIFO_PICW_DBK                 ((0x19be  << 2) + 0xd0050000)
+#define HCODEC_WRRSP_FIFO_PICW_MC                  ((0x19bf  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_0                        ((0x19c0  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_1                        ((0x19c1  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_2                        ((0x19c2  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_3                        ((0x19c3  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_4                        ((0x19c4  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_5                        ((0x19c5  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_6                        ((0x19c6  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_7                        ((0x19c7  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_8                        ((0x19c8  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_9                        ((0x19c9  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_A                        ((0x19ca  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_B                        ((0x19cb  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_C                        ((0x19cc  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_D                        ((0x19cd  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_E                        ((0x19ce  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_F                        ((0x19cf  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_G                        ((0x19d0  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_H                        ((0x19d1  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_I                        ((0x19d2  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_J                        ((0x19d3  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_K                        ((0x19d4  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_L                        ((0x19d5  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_M                        ((0x19d6  << 2) + 0xd0050000)
+#define HCODEC_AV_SCRATCH_N                        ((0x19d7  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_co_mb
+// bit[21:16] A_id_co_mb
+// bit[11:0] wrrsp_count_co_mb
+#define HCODEC_WRRSP_CO_MB                         ((0x19d8  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_dcac
+// bit[21:16] A_id_dcac
+// bit[11:0] wrrsp_count_dcac
+#define HCODEC_WRRSP_DCAC                          ((0x19d9  << 2) + 0xd0050000)
+// bit[11:0] wrrsp_count_vld
+#define HCODEC_WRRSP_VLD                           ((0x19da  << 2) + 0xd0050000)
+// doublew_cfg0[0];     //       Second Channel Enable, 1:Enable 0:Disable
+// doublew_cfg0[3:1];   // [2:0] Endian Control for Luma
+// doublew_cfg0[5:4];   // [1:0] Pixel sel by horizontal, 0x:1/2 10:left 11:right
+// doublew_cfg0[7:6];   // [1:0] Pixel sel by vertical,   0x:1/2 10:up 11:down
+// doublew_cfg0[8];     //       Size by horizontal, 0:original size 1: 1/2 shrunken size
+// doublew_cfg0[9];     //       Size by vertical,   0:original size 1: 1/2 shrunken size
+// doublew_cfg0[10];    //       1:Round 0:Truncation
+// doublew_cfg0[11];    //       DMA Urgent
+// doublew_cfg0[17:12]; // [5:0] DMA Burst Number
+// doublew_cfg0[23:18]; // [5:0] DMA ID
+// doublew_cfg0[26:24]; // [2:0] Endian Control for Chroma
+// doublew_cfg0[27];    //       Source from, 1:MCW 0:DBLK
+// doublew_cfg0[29:28]; // [1:0] 0x:select both top and bottom 10:select top 11:select bottom
+// doublew_cfg0[30];    //       0:no merge 1:automatic merge
+// doublew_cfg0[31];    //       0:Y addr no change 1:Y addr divided to half
+#define HCODEC_MDEC_DOUBLEW_CFG0                   ((0x19db  << 2) + 0xd0050000)
+// doublew_cfg1[7:0];   // [7:0] DMA Canvas Address for Luma
+// doublew_cfg1[15:8];  // [7:0] DMA Canvas Address for Chroma
+// doublew_cfg1[16];    //       Disable 1st Write - 
+// doublew_cfg1[17];    //       Reverse to original version - 
+// doublew_cfg1[18];    //       DMA Address Mode - 0:Canvas Mode 1:Non-Canvas Mode
+#define HCODEC_MDEC_DOUBLEW_CFG1                   ((0x19dc  << 2) + 0xd0050000)
+// doublew_cfg2[11:0];  //[11:0] vertical flip initial value
+// doublew_cfg2[15];    //       vertical flip enable
+// doublew_cfg2[24:16]; // [8:0] horizontal flip initial value
+// doublew_cfg2[31];    //       horizontal flip enable
+#define HCODEC_MDEC_DOUBLEW_CFG2                   ((0x19dd  << 2) + 0xd0050000)
+// doublew_cfg3[31:0];  //[31:0] non-canvas start address for Luma - 
+#define HCODEC_MDEC_DOUBLEW_CFG3                   ((0x19de  << 2) + 0xd0050000)
+// doublew_cfg4[31:0];  //[31:0] non-canvas start address for Chroma - 
+#define HCODEC_MDEC_DOUBLEW_CFG4                   ((0x19df  << 2) + 0xd0050000)
+// doublew_cfg5[12:0];  //[12:0] non-canvas picture width for Luma - 
+// doublew_cfg5[28:16]; //[12:0] non-canvas picture width for Chroma - 
+#define HCODEC_MDEC_DOUBLEW_CFG5                   ((0x19e0  << 2) + 0xd0050000)
+// doublew_cfg6: reserved
+#define HCODEC_MDEC_DOUBLEW_CFG6                   ((0x19e1  << 2) + 0xd0050000)
+// doublew_cfg7: reserved
+#define HCODEC_MDEC_DOUBLEW_CFG7                   ((0x19e2  << 2) + 0xd0050000)
+// doublew_status[11:0];//[11:0] wrrsp_count_doublew
+// doublew_status[12];  //       doublew_status_busy
+// doublew_status[13];  //       doublew_status_error
+#define HCODEC_MDEC_DOUBLEW_STATUS                 ((0x19e3  << 2) + 0xd0050000)
+//======================================
+//  MC Control Register Bits
+//
+//======================================
+// For bits, just copy the defines...don't translate to addresses
+    //`define MC_RESET	    16'h0002
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//========================================================================
+// DBLK Register:  12'h950 - 12'h97f 
+//========================================================================
+#define HCODEC_DBLK_RST                            ((0x1950  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CTRL                           ((0x1951  << 2) + 0xd0050000)
+#define HCODEC_DBLK_MB_WID_HEIGHT                  ((0x1952  << 2) + 0xd0050000)
+#define HCODEC_DBLK_STATUS                         ((0x1953  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CMD_CTRL                       ((0x1954  << 2) + 0xd0050000)
+#define HCODEC_DBLK_MB_XY                          ((0x1955  << 2) + 0xd0050000)
+#define HCODEC_DBLK_QP                             ((0x1956  << 2) + 0xd0050000)
+#define HCODEC_DBLK_Y_BHFILT                       ((0x1957  << 2) + 0xd0050000)
+#define HCODEC_DBLK_Y_BHFILT_HIGH                  ((0x1958  << 2) + 0xd0050000)
+#define HCODEC_DBLK_Y_BVFILT                       ((0x1959  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CB_BFILT                       ((0x195a  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CR_BFILT                       ((0x195b  << 2) + 0xd0050000)
+#define HCODEC_DBLK_Y_HFILT                        ((0x195c  << 2) + 0xd0050000)
+#define HCODEC_DBLK_Y_HFILT_HIGH                   ((0x195d  << 2) + 0xd0050000)
+#define HCODEC_DBLK_Y_VFILT                        ((0x195e  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CB_FILT                        ((0x195f  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CR_FILT                        ((0x1960  << 2) + 0xd0050000)
+#define HCODEC_DBLK_BETAX_QP_SEL                   ((0x1961  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CLIP_CTRL0                     ((0x1962  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CLIP_CTRL1                     ((0x1963  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CLIP_CTRL2                     ((0x1964  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CLIP_CTRL3                     ((0x1965  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CLIP_CTRL4                     ((0x1966  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CLIP_CTRL5                     ((0x1967  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CLIP_CTRL6                     ((0x1968  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CLIP_CTRL7                     ((0x1969  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CLIP_CTRL8                     ((0x196a  << 2) + 0xd0050000)
+#define HCODEC_DBLK_STATUS1                        ((0x196b  << 2) + 0xd0050000)
+#define HCODEC_DBLK_GCLK_FREE                      ((0x196c  << 2) + 0xd0050000)
+#define HCODEC_DBLK_GCLK_OFF                       ((0x196d  << 2) + 0xd0050000)
+#define HCODEC_DBLK_AVSFLAGS                       ((0x196e  << 2) + 0xd0050000)
+// bit 15:0
+#define HCODEC_DBLK_CBPY                           ((0x1970  << 2) + 0xd0050000)
+// bit 11:8 -- deblk_cbpy_bottom
+// bit 7:4 -- deblk_cbpy_left
+// bit 3:0 -- deblk_cbpy_top
+#define HCODEC_DBLK_CBPY_ADJ                       ((0x1971  << 2) + 0xd0050000)
+// bit 7:0 -- deblk_cbpc
+#define HCODEC_DBLK_CBPC                           ((0x1972  << 2) + 0xd0050000)
+// bit 15 -- bottom_mb
+// bit 14 -- left_mb
+// bit 13 -- top_mb
+// bit 12 -- reserved
+// bit 11:8 -- deblk_cbpc_bottom
+// bit 7:4 -- deblk_cbpc_left
+// bit 3:0 -- deblk_cbpc_top
+#define HCODEC_DBLK_CBPC_ADJ                       ((0x1973  << 2) + 0xd0050000)
+// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0} 
+// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0} 
+#define HCODEC_DBLK_VHMVD                          ((0x1974  << 2) + 0xd0050000)
+// bit 13:12 -- right_vmvd
+// bit 11 -- right_above_vmvd
+// bit 10 -- left_below_hmvd
+// bit 9 -- disable_dblk_luma  
+// bit 8 -- disable_dblk_chroma
+// bit 7 -- bBelowRefDiff
+// bit 6 -- bLeftRefDiff
+// bit 5 -- bAboveRefDiff
+// bit 4 -- reserved
+// bit 3 -- s_below
+// bit 2 -- s_left
+// bit 1 -- s_above
+// bit 0 -- s 
+#define HCODEC_DBLK_STRONG                         ((0x1975  << 2) + 0xd0050000)
+// bit 14:10 -- PQUANT 
+// bit 9:5 -- left_PQUANT 
+// bit 4:0 -- top_PQUANT 
+#define HCODEC_DBLK_RV8_QUANT                      ((0x1976  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CBUS_HCMD2                     ((0x1977  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CBUS_HCMD1                     ((0x1978  << 2) + 0xd0050000)
+#define HCODEC_DBLK_CBUS_HCMD0                     ((0x1979  << 2) + 0xd0050000)
+#define HCODEC_DBLK_VLD_HCMD2                      ((0x197a  << 2) + 0xd0050000)
+#define HCODEC_DBLK_VLD_HCMD1                      ((0x197b  << 2) + 0xd0050000)
+#define HCODEC_DBLK_VLD_HCMD0                      ((0x197c  << 2) + 0xd0050000)
+#define HCODEC_DBLK_OST_YBASE                      ((0x197d  << 2) + 0xd0050000)
+#define HCODEC_DBLK_OST_CBCRDIFF                   ((0x197e  << 2) + 0xd0050000)
+//13:8 dblk thread ID and token 
+//5:0  dblk prearbitor burst num
+#define HCODEC_DBLK_CTRL1                          ((0x197f  << 2) + 0xd0050000)
+// MCRCC_CTL1
+// 31:3  <reserved[23:0]>
+// 2     <cfg_field_pic>
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define HCODEC_MCRCC_CTL1                          ((0x1980  << 2) + 0xd0050000)
+// MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define HCODEC_MCRCC_CTL2                          ((0x1981  << 2) + 0xd0050000)
+// MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define HCODEC_MCRCC_CTL3                          ((0x1982  << 2) + 0xd0050000)
+// bit[31:10] reserved
+// bit[9:0] sw_clock_gating control 
+// [9] vdec clk_en for assist and cbus.
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for assist
+// [5] vdec clk_en for dblk
+// [4] vdec clk_en for iqidct
+// [3] vdec clk_en for mc
+// [2] vdec clk_en for pic_dc
+// [1] vdec clk_en for psc
+// [0] vdec clk_en for vld
+#define HCODEC_GCLK_EN                             ((0x1983  << 2) + 0xd0050000)
+// [0]  Reserved 
+// [1]  Reserved
+// [2]  Reset assist, mdec's CBUS
+// [3]  Reset mdec's VLD
+// [4]  Reset mdec's VLD
+// [5]  Reset mdec's VLD
+// [6]  Reset mdec's IQIDCT
+// [7]  Reset mdec's MC
+// [8]  Reset mdec's DBLK
+// [9]  Reset mdec's PIC_DC
+// [10] Reset mdec's Pscale
+// [11] Reset vcpu's MCPU
+// [12] Reset vcpu's CCPU
+// [13] Reset mmc_pre_arb
+#define HCODEC_MDEC_SW_RESET                       ((0x1984  << 2) + 0xd0050000)
+//DBLK last address 12'h97f
+//
+// Closing file:  mdec_regs.h
+//
+//
+// Reading file:  mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_MDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+#define VDEC2_MC_CTRL_REG                          ((0x2900  << 2) + 0xd0050000)
+#define VDEC2_MC_MB_INFO                           ((0x2901  << 2) + 0xd0050000)
+#define VDEC2_MC_PIC_INFO                          ((0x2902  << 2) + 0xd0050000)
+#define VDEC2_MC_HALF_PEL_ONE                      ((0x2903  << 2) + 0xd0050000)
+#define VDEC2_MC_HALF_PEL_TWO                      ((0x2904  << 2) + 0xd0050000)
+#define VDEC2_POWER_CTL_MC                         ((0x2905  << 2) + 0xd0050000)
+#define VDEC2_MC_CMD                               ((0x2906  << 2) + 0xd0050000)
+#define VDEC2_MC_CTRL0                             ((0x2907  << 2) + 0xd0050000)
+#define VDEC2_MC_PIC_W_H                           ((0x2908  << 2) + 0xd0050000)
+#define VDEC2_MC_STATUS0                           ((0x2909  << 2) + 0xd0050000)
+#define VDEC2_MC_STATUS1                           ((0x290a  << 2) + 0xd0050000)
+#define VDEC2_MC_CTRL1                             ((0x290b  << 2) + 0xd0050000)
+#define VDEC2_MC_MIX_RATIO0                        ((0x290c  << 2) + 0xd0050000)
+#define VDEC2_MC_MIX_RATIO1                        ((0x290d  << 2) + 0xd0050000)
+#define VDEC2_MC_DP_MB_XY                          ((0x290e  << 2) + 0xd0050000)
+#define VDEC2_MC_OM_MB_XY                          ((0x290f  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_RST                           ((0x2910  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_CTRL                          ((0x2911  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_PICI_W                        ((0x2912  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_PICI_H                        ((0x2913  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_PICO_W                        ((0x2914  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_PICO_H                        ((0x2915  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_PICO_START_X                  ((0x2916  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_PICO_START_Y                  ((0x2917  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_DUMMY                         ((0x2918  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_FILT0_COEF0                   ((0x2919  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_FILT0_COEF1                   ((0x291a  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_CMD_CTRL                      ((0x291b  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_CMD_BLK_X                     ((0x291c  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_CMD_BLK_Y                     ((0x291d  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_STATUS                        ((0x291e  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_BMEM_ADDR                     ((0x291f  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_BMEM_DAT                      ((0x2920  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_DRAM_BUF_CTRL                 ((0x2921  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_MCMD_CTRL                     ((0x2922  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_MCMD_XSIZE                    ((0x2923  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_MCMD_YSIZE                    ((0x2924  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_RBUF_START_BLKX               ((0x2925  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_RBUF_START_BLKY               ((0x2926  << 2) + 0xd0050000)
+//`define PSCALE_RBUF_MB_WIDTH   8'h27
+#define VDEC2_PSCALE_PICO_SHIFT_XY                 ((0x2928  << 2) + 0xd0050000)
+#define VDEC2_PSCALE_CTRL1                         ((0x2929  << 2) + 0xd0050000)
+//Bit 15, wmask enable
+//Bit 14:13, filt0 srckey_less, 
+//Bit 12:11, filt1 srckey_less, in the case of the interpolated data is equal distance to 
+//key data and normal data, 00: select normal data, 01: select right data, 10: select key data
+//Bit 10:9, srckey mode, 00: equal, 01: less than or equal, 10: great than or equal
+//Bit 8, src key enable
+//Bit 7:0, y src key
+#define VDEC2_PSCALE_SRCKEY_CTRL0                  ((0x292a  << 2) + 0xd0050000)
+//Bit 15:8, cb src key
+//Bit 7:0, cr src key
+#define VDEC2_PSCALE_SRCKEY_CTRL1                  ((0x292b  << 2) + 0xd0050000)
+//Bit 22:16 canvas_rd_addr2
+//Bit 14:8 canvas_rd_addr1
+//Bit 6:0 canvas_rd_addr1
+#define VDEC2_PSCALE_CANVAS_RD_ADDR                ((0x292c  << 2) + 0xd0050000)
+//Bit 22:16 canvas_wr_addr2
+//Bit 14:8 canvas_wr_addr1
+//Bit 6:0 canvas_wr_addr1
+#define VDEC2_PSCALE_CANVAS_WR_ADDR                ((0x292d  << 2) + 0xd0050000)
+//bit 13:8 pscale thread ID and token 
+//bit 7 disable write response count adding to busy bit 
+//bit 5:0  pscale prearbitor burst num
+#define VDEC2_PSCALE_CTRL2                         ((0x292e  << 2) + 0xd0050000)
+//   31 - use_omem_mb_xy_auto
+//23:16 - omem_max_mb_x
+//15:8  - omem_mb_y_auto
+// 7:0  - omem_mb_x_auto
+#define VDEC2_HDEC_MC_OMEM_AUTO                    ((0x2930  << 2) + 0xd0050000)
+#define VDEC2_HDEC_MC_MBRIGHT_IDX                  ((0x2931  << 2) + 0xd0050000)
+#define VDEC2_HDEC_MC_MBRIGHT_RD                   ((0x2932  << 2) + 0xd0050000)
+#define VDEC2_MC_MPORT_CTRL                        ((0x2940  << 2) + 0xd0050000)
+#define VDEC2_MC_MPORT_DAT                         ((0x2941  << 2) + 0xd0050000)
+#define VDEC2_MC_WT_PRED_CTRL                      ((0x2942  << 2) + 0xd0050000)
+#define VDEC2_MC_MBBOT_ST_EVEN_ADDR                ((0x2944  << 2) + 0xd0050000)
+#define VDEC2_MC_MBBOT_ST_ODD_ADDR                 ((0x2945  << 2) + 0xd0050000)
+#define VDEC2_MC_DPDN_MB_XY                        ((0x2946  << 2) + 0xd0050000)
+#define VDEC2_MC_OMDN_MB_XY                        ((0x2947  << 2) + 0xd0050000)
+#define VDEC2_MC_HCMDBUF_H                         ((0x2948  << 2) + 0xd0050000)
+#define VDEC2_MC_HCMDBUF_L                         ((0x2949  << 2) + 0xd0050000)
+#define VDEC2_MC_HCMD_H                            ((0x294a  << 2) + 0xd0050000)
+#define VDEC2_MC_HCMD_L                            ((0x294b  << 2) + 0xd0050000)
+#define VDEC2_MC_IDCT_DAT                          ((0x294c  << 2) + 0xd0050000)
+#define VDEC2_MC_CTRL_GCLK_CTRL                    ((0x294d  << 2) + 0xd0050000)
+#define VDEC2_MC_OTHER_GCLK_CTRL                   ((0x294e  << 2) + 0xd0050000)
+//Bit 29:24, mbbot thread ID and token 
+//Bit 21:16, mc read/write thread ID and token 
+//Bit 13:8,  mbbot pre-arbitor burst number 
+//Bit 5:0,   mc pre-arbitor burst number 
+#define VDEC2_MC_CTRL2                             ((0x294f  << 2) + 0xd0050000)
+// `define DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define ANC1_CANVAS_ADDR      8'h80
+//`define ANC2_CANVAS_ADDR      8'h81
+//`define REC_CANVAS_ADDR       8'h89
+//`define MDEC_PIC_W          8'h8c
+//`define MDEC_PIC_H          8'h8d
+#define VDEC2_MDEC_PIC_DC_CTRL                     ((0x298e  << 2) + 0xd0050000)
+#define VDEC2_MDEC_PIC_DC_STATUS                   ((0x298f  << 2) + 0xd0050000)
+#define VDEC2_ANC0_CANVAS_ADDR                     ((0x2990  << 2) + 0xd0050000)
+#define VDEC2_ANC1_CANVAS_ADDR                     ((0x2991  << 2) + 0xd0050000)
+#define VDEC2_ANC2_CANVAS_ADDR                     ((0x2992  << 2) + 0xd0050000)
+#define VDEC2_ANC3_CANVAS_ADDR                     ((0x2993  << 2) + 0xd0050000)
+#define VDEC2_ANC4_CANVAS_ADDR                     ((0x2994  << 2) + 0xd0050000)
+#define VDEC2_ANC5_CANVAS_ADDR                     ((0x2995  << 2) + 0xd0050000)
+#define VDEC2_ANC6_CANVAS_ADDR                     ((0x2996  << 2) + 0xd0050000)
+#define VDEC2_ANC7_CANVAS_ADDR                     ((0x2997  << 2) + 0xd0050000)
+#define VDEC2_ANC8_CANVAS_ADDR                     ((0x2998  << 2) + 0xd0050000)
+#define VDEC2_ANC9_CANVAS_ADDR                     ((0x2999  << 2) + 0xd0050000)
+#define VDEC2_ANC10_CANVAS_ADDR                    ((0x299a  << 2) + 0xd0050000)
+#define VDEC2_ANC11_CANVAS_ADDR                    ((0x299b  << 2) + 0xd0050000)
+#define VDEC2_ANC12_CANVAS_ADDR                    ((0x299c  << 2) + 0xd0050000)
+#define VDEC2_ANC13_CANVAS_ADDR                    ((0x299d  << 2) + 0xd0050000)
+#define VDEC2_ANC14_CANVAS_ADDR                    ((0x299e  << 2) + 0xd0050000)
+#define VDEC2_ANC15_CANVAS_ADDR                    ((0x299f  << 2) + 0xd0050000)
+#define VDEC2_ANC16_CANVAS_ADDR                    ((0x29a0  << 2) + 0xd0050000)
+#define VDEC2_ANC17_CANVAS_ADDR                    ((0x29a1  << 2) + 0xd0050000)
+#define VDEC2_ANC18_CANVAS_ADDR                    ((0x29a2  << 2) + 0xd0050000)
+#define VDEC2_ANC19_CANVAS_ADDR                    ((0x29a3  << 2) + 0xd0050000)
+#define VDEC2_ANC20_CANVAS_ADDR                    ((0x29a4  << 2) + 0xd0050000)
+#define VDEC2_ANC21_CANVAS_ADDR                    ((0x29a5  << 2) + 0xd0050000)
+#define VDEC2_ANC22_CANVAS_ADDR                    ((0x29a6  << 2) + 0xd0050000)
+#define VDEC2_ANC23_CANVAS_ADDR                    ((0x29a7  << 2) + 0xd0050000)
+#define VDEC2_ANC24_CANVAS_ADDR                    ((0x29a8  << 2) + 0xd0050000)
+#define VDEC2_ANC25_CANVAS_ADDR                    ((0x29a9  << 2) + 0xd0050000)
+#define VDEC2_ANC26_CANVAS_ADDR                    ((0x29aa  << 2) + 0xd0050000)
+#define VDEC2_ANC27_CANVAS_ADDR                    ((0x29ab  << 2) + 0xd0050000)
+#define VDEC2_ANC28_CANVAS_ADDR                    ((0x29ac  << 2) + 0xd0050000)
+#define VDEC2_ANC29_CANVAS_ADDR                    ((0x29ad  << 2) + 0xd0050000)
+#define VDEC2_ANC30_CANVAS_ADDR                    ((0x29ae  << 2) + 0xd0050000)
+#define VDEC2_ANC31_CANVAS_ADDR                    ((0x29af  << 2) + 0xd0050000)
+#define VDEC2_DBKR_CANVAS_ADDR                     ((0x29b0  << 2) + 0xd0050000)
+#define VDEC2_DBKW_CANVAS_ADDR                     ((0x29b1  << 2) + 0xd0050000)
+#define VDEC2_REC_CANVAS_ADDR                      ((0x29b2  << 2) + 0xd0050000)
+//28:24, read/write, current canvas idx, used in h264 only now
+//23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+#define VDEC2_CURR_CANVAS_CTRL                     ((0x29b3  << 2) + 0xd0050000)
+#define VDEC2_MDEC_PIC_DC_THRESH                   ((0x29b8  << 2) + 0xd0050000)
+#define VDEC2_MDEC_PICR_BUF_STATUS                 ((0x29b9  << 2) + 0xd0050000)
+#define VDEC2_MDEC_PICW_BUF_STATUS                 ((0x29ba  << 2) + 0xd0050000)
+#define VDEC2_MCW_DBLK_WRRSP_CNT                   ((0x29bb  << 2) + 0xd0050000)
+#define VDEC2_MC_MBBOT_WRRSP_CNT                   ((0x29bc  << 2) + 0xd0050000)
+#define VDEC2_MDEC_PICW_BUF2_STATUS                ((0x29bd  << 2) + 0xd0050000)
+#define VDEC2_WRRSP_FIFO_PICW_DBK                  ((0x29be  << 2) + 0xd0050000)
+#define VDEC2_WRRSP_FIFO_PICW_MC                   ((0x29bf  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_0                         ((0x29c0  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_1                         ((0x29c1  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_2                         ((0x29c2  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_3                         ((0x29c3  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_4                         ((0x29c4  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_5                         ((0x29c5  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_6                         ((0x29c6  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_7                         ((0x29c7  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_8                         ((0x29c8  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_9                         ((0x29c9  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_A                         ((0x29ca  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_B                         ((0x29cb  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_C                         ((0x29cc  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_D                         ((0x29cd  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_E                         ((0x29ce  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_F                         ((0x29cf  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_G                         ((0x29d0  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_H                         ((0x29d1  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_I                         ((0x29d2  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_J                         ((0x29d3  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_K                         ((0x29d4  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_L                         ((0x29d5  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_M                         ((0x29d6  << 2) + 0xd0050000)
+#define VDEC2_AV_SCRATCH_N                         ((0x29d7  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_co_mb
+// bit[21:16] A_id_co_mb
+// bit[11:0] wrrsp_count_co_mb
+#define VDEC2_WRRSP_CO_MB                          ((0x29d8  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_dcac
+// bit[21:16] A_id_dcac
+// bit[11:0] wrrsp_count_dcac
+#define VDEC2_WRRSP_DCAC                           ((0x29d9  << 2) + 0xd0050000)
+// bit[11:0] wrrsp_count_vld
+#define VDEC2_WRRSP_VLD                            ((0x29da  << 2) + 0xd0050000)
+// doublew_cfg0[0];     //       Second Channel Enable, 1:Enable 0:Disable
+// doublew_cfg0[3:1];   // [2:0] Endian Control for Luma
+// doublew_cfg0[5:4];   // [1:0] Pixel sel by horizontal, 0x:1/2 10:left 11:right
+// doublew_cfg0[7:6];   // [1:0] Pixel sel by vertical,   0x:1/2 10:up 11:down
+// doublew_cfg0[8];     //       Size by horizontal, 0:original size 1: 1/2 shrunken size
+// doublew_cfg0[9];     //       Size by vertical,   0:original size 1: 1/2 shrunken size
+// doublew_cfg0[10];    //       1:Round 0:Truncation
+// doublew_cfg0[11];    //       DMA Urgent
+// doublew_cfg0[17:12]; // [5:0] DMA Burst Number
+// doublew_cfg0[23:18]; // [5:0] DMA ID
+// doublew_cfg0[26:24]; // [2:0] Endian Control for Chroma
+// doublew_cfg0[27];    //       Source from, 1:MCW 0:DBLK
+// doublew_cfg0[29:28]; // [1:0] 0x:select both top and bottom 10:select top 11:select bottom
+// doublew_cfg0[30];    //       0:no merge 1:automatic merge
+// doublew_cfg0[31];    //       0:Y addr no change 1:Y addr divided to half
+#define VDEC2_MDEC_DOUBLEW_CFG0                    ((0x29db  << 2) + 0xd0050000)
+// doublew_cfg1[7:0];   // [7:0] DMA Canvas Address for Luma
+// doublew_cfg1[15:8];  // [7:0] DMA Canvas Address for Chroma
+// doublew_cfg1[16];    //       Disable 1st Write - 
+// doublew_cfg1[17];    //       Reverse to original version - 
+// doublew_cfg1[18];    //       DMA Address Mode - 0:Canvas Mode 1:Non-Canvas Mode
+#define VDEC2_MDEC_DOUBLEW_CFG1                    ((0x29dc  << 2) + 0xd0050000)
+// doublew_cfg2[11:0];  //[11:0] vertical flip initial value
+// doublew_cfg2[15];    //       vertical flip enable
+// doublew_cfg2[24:16]; // [8:0] horizontal flip initial value
+// doublew_cfg2[31];    //       horizontal flip enable
+#define VDEC2_MDEC_DOUBLEW_CFG2                    ((0x29dd  << 2) + 0xd0050000)
+// doublew_cfg3[31:0];  //[31:0] non-canvas start address for Luma - 
+#define VDEC2_MDEC_DOUBLEW_CFG3                    ((0x29de  << 2) + 0xd0050000)
+// doublew_cfg4[31:0];  //[31:0] non-canvas start address for Chroma - 
+#define VDEC2_MDEC_DOUBLEW_CFG4                    ((0x29df  << 2) + 0xd0050000)
+// doublew_cfg5[12:0];  //[12:0] non-canvas picture width for Luma - 
+// doublew_cfg5[28:16]; //[12:0] non-canvas picture width for Chroma - 
+#define VDEC2_MDEC_DOUBLEW_CFG5                    ((0x29e0  << 2) + 0xd0050000)
+// doublew_cfg6: reserved
+#define VDEC2_MDEC_DOUBLEW_CFG6                    ((0x29e1  << 2) + 0xd0050000)
+// doublew_cfg7: reserved
+#define VDEC2_MDEC_DOUBLEW_CFG7                    ((0x29e2  << 2) + 0xd0050000)
+// doublew_status[11:0];//[11:0] wrrsp_count_doublew
+// doublew_status[12];  //       doublew_status_busy
+// doublew_status[13];  //       doublew_status_error
+#define VDEC2_MDEC_DOUBLEW_STATUS                  ((0x29e3  << 2) + 0xd0050000)
+//======================================
+//  MC Control Register Bits
+//
+//======================================
+// For bits, just copy the defines...don't translate to addresses
+    //`define MC_RESET	    16'h0002
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//========================================================================
+// DBLK Register:  12'h950 - 12'h97f 
+//========================================================================
+#define VDEC2_DBLK_RST                             ((0x2950  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CTRL                            ((0x2951  << 2) + 0xd0050000)
+#define VDEC2_DBLK_MB_WID_HEIGHT                   ((0x2952  << 2) + 0xd0050000)
+#define VDEC2_DBLK_STATUS                          ((0x2953  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CMD_CTRL                        ((0x2954  << 2) + 0xd0050000)
+#define VDEC2_DBLK_MB_XY                           ((0x2955  << 2) + 0xd0050000)
+#define VDEC2_DBLK_QP                              ((0x2956  << 2) + 0xd0050000)
+#define VDEC2_DBLK_Y_BHFILT                        ((0x2957  << 2) + 0xd0050000)
+#define VDEC2_DBLK_Y_BHFILT_HIGH                   ((0x2958  << 2) + 0xd0050000)
+#define VDEC2_DBLK_Y_BVFILT                        ((0x2959  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CB_BFILT                        ((0x295a  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CR_BFILT                        ((0x295b  << 2) + 0xd0050000)
+#define VDEC2_DBLK_Y_HFILT                         ((0x295c  << 2) + 0xd0050000)
+#define VDEC2_DBLK_Y_HFILT_HIGH                    ((0x295d  << 2) + 0xd0050000)
+#define VDEC2_DBLK_Y_VFILT                         ((0x295e  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CB_FILT                         ((0x295f  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CR_FILT                         ((0x2960  << 2) + 0xd0050000)
+#define VDEC2_DBLK_BETAX_QP_SEL                    ((0x2961  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CLIP_CTRL0                      ((0x2962  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CLIP_CTRL1                      ((0x2963  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CLIP_CTRL2                      ((0x2964  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CLIP_CTRL3                      ((0x2965  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CLIP_CTRL4                      ((0x2966  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CLIP_CTRL5                      ((0x2967  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CLIP_CTRL6                      ((0x2968  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CLIP_CTRL7                      ((0x2969  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CLIP_CTRL8                      ((0x296a  << 2) + 0xd0050000)
+#define VDEC2_DBLK_STATUS1                         ((0x296b  << 2) + 0xd0050000)
+#define VDEC2_DBLK_GCLK_FREE                       ((0x296c  << 2) + 0xd0050000)
+#define VDEC2_DBLK_GCLK_OFF                        ((0x296d  << 2) + 0xd0050000)
+#define VDEC2_DBLK_AVSFLAGS                        ((0x296e  << 2) + 0xd0050000)
+// bit 15:0
+#define VDEC2_DBLK_CBPY                            ((0x2970  << 2) + 0xd0050000)
+// bit 11:8 -- deblk_cbpy_bottom
+// bit 7:4 -- deblk_cbpy_left
+// bit 3:0 -- deblk_cbpy_top
+#define VDEC2_DBLK_CBPY_ADJ                        ((0x2971  << 2) + 0xd0050000)
+// bit 7:0 -- deblk_cbpc
+#define VDEC2_DBLK_CBPC                            ((0x2972  << 2) + 0xd0050000)
+// bit 15 -- bottom_mb
+// bit 14 -- left_mb
+// bit 13 -- top_mb
+// bit 12 -- reserved
+// bit 11:8 -- deblk_cbpc_bottom
+// bit 7:4 -- deblk_cbpc_left
+// bit 3:0 -- deblk_cbpc_top
+#define VDEC2_DBLK_CBPC_ADJ                        ((0x2973  << 2) + 0xd0050000)
+// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0} 
+// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0} 
+#define VDEC2_DBLK_VHMVD                           ((0x2974  << 2) + 0xd0050000)
+// bit 13:12 -- right_vmvd
+// bit 11 -- right_above_vmvd
+// bit 10 -- left_below_hmvd
+// bit 9 -- disable_dblk_luma  
+// bit 8 -- disable_dblk_chroma
+// bit 7 -- bBelowRefDiff
+// bit 6 -- bLeftRefDiff
+// bit 5 -- bAboveRefDiff
+// bit 4 -- reserved
+// bit 3 -- s_below
+// bit 2 -- s_left
+// bit 1 -- s_above
+// bit 0 -- s 
+#define VDEC2_DBLK_STRONG                          ((0x2975  << 2) + 0xd0050000)
+// bit 14:10 -- PQUANT 
+// bit 9:5 -- left_PQUANT 
+// bit 4:0 -- top_PQUANT 
+#define VDEC2_DBLK_RV8_QUANT                       ((0x2976  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CBUS_HCMD2                      ((0x2977  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CBUS_HCMD1                      ((0x2978  << 2) + 0xd0050000)
+#define VDEC2_DBLK_CBUS_HCMD0                      ((0x2979  << 2) + 0xd0050000)
+#define VDEC2_DBLK_VLD_HCMD2                       ((0x297a  << 2) + 0xd0050000)
+#define VDEC2_DBLK_VLD_HCMD1                       ((0x297b  << 2) + 0xd0050000)
+#define VDEC2_DBLK_VLD_HCMD0                       ((0x297c  << 2) + 0xd0050000)
+#define VDEC2_DBLK_OST_YBASE                       ((0x297d  << 2) + 0xd0050000)
+#define VDEC2_DBLK_OST_CBCRDIFF                    ((0x297e  << 2) + 0xd0050000)
+//13:8 dblk thread ID and token 
+//5:0  dblk prearbitor burst num
+#define VDEC2_DBLK_CTRL1                           ((0x297f  << 2) + 0xd0050000)
+// MCRCC_CTL1
+// 31:3  <reserved[23:0]>
+// 2     <cfg_field_pic>
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define VDEC2_MCRCC_CTL1                           ((0x2980  << 2) + 0xd0050000)
+// MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define VDEC2_MCRCC_CTL2                           ((0x2981  << 2) + 0xd0050000)
+// MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define VDEC2_MCRCC_CTL3                           ((0x2982  << 2) + 0xd0050000)
+// bit[31:10] reserved
+// bit[9:0] sw_clock_gating control 
+// [9] vdec clk_en for assist and cbus.
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for assist
+// [5] vdec clk_en for dblk
+// [4] vdec clk_en for iqidct
+// [3] vdec clk_en for mc
+// [2] vdec clk_en for pic_dc
+// [1] vdec clk_en for psc
+// [0] vdec clk_en for vld
+#define VDEC2_GCLK_EN                              ((0x2983  << 2) + 0xd0050000)
+// [0]  Reserved 
+// [1]  Reserved
+// [2]  Reset assist, mdec's CBUS
+// [3]  Reset mdec's VLD
+// [4]  Reset mdec's VLD
+// [5]  Reset mdec's VLD
+// [6]  Reset mdec's IQIDCT
+// [7]  Reset mdec's MC
+// [8]  Reset mdec's DBLK
+// [9]  Reset mdec's PIC_DC
+// [10] Reset mdec's Pscale
+// [11] Reset vcpu's MCPU
+// [12] Reset vcpu's CCPU
+// [13] Reset mmc_pre_arb
+#define VDEC2_MDEC_SW_RESET                        ((0x2984  << 2) + 0xd0050000)
+//DBLK last address 12'h97f
+//
+// Closing file:  mdec_regs.h
+//
+//
+// Reading file:  mdec_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_MDEC_CBUS_BASE = 0x09
+// -----------------------------------------------
+#define HEVC_MC_CTRL_REG                           ((0x3900  << 2) + 0xd0050000)
+#define HEVC_MC_MB_INFO                            ((0x3901  << 2) + 0xd0050000)
+#define HEVC_MC_PIC_INFO                           ((0x3902  << 2) + 0xd0050000)
+#define HEVC_MC_HALF_PEL_ONE                       ((0x3903  << 2) + 0xd0050000)
+#define HEVC_MC_HALF_PEL_TWO                       ((0x3904  << 2) + 0xd0050000)
+#define HEVC_POWER_CTL_MC                          ((0x3905  << 2) + 0xd0050000)
+#define HEVC_MC_CMD                                ((0x3906  << 2) + 0xd0050000)
+#define HEVC_MC_CTRL0                              ((0x3907  << 2) + 0xd0050000)
+#define HEVC_MC_PIC_W_H                            ((0x3908  << 2) + 0xd0050000)
+#define HEVC_MC_STATUS0                            ((0x3909  << 2) + 0xd0050000)
+#define HEVC_MC_STATUS1                            ((0x390a  << 2) + 0xd0050000)
+#define HEVC_MC_CTRL1                              ((0x390b  << 2) + 0xd0050000)
+#define HEVC_MC_MIX_RATIO0                         ((0x390c  << 2) + 0xd0050000)
+#define HEVC_MC_MIX_RATIO1                         ((0x390d  << 2) + 0xd0050000)
+#define HEVC_MC_DP_MB_XY                           ((0x390e  << 2) + 0xd0050000)
+#define HEVC_MC_OM_MB_XY                           ((0x390f  << 2) + 0xd0050000)
+#define HEVC_PSCALE_RST                            ((0x3910  << 2) + 0xd0050000)
+#define HEVC_PSCALE_CTRL                           ((0x3911  << 2) + 0xd0050000)
+#define HEVC_PSCALE_PICI_W                         ((0x3912  << 2) + 0xd0050000)
+#define HEVC_PSCALE_PICI_H                         ((0x3913  << 2) + 0xd0050000)
+#define HEVC_PSCALE_PICO_W                         ((0x3914  << 2) + 0xd0050000)
+#define HEVC_PSCALE_PICO_H                         ((0x3915  << 2) + 0xd0050000)
+#define HEVC_PSCALE_PICO_START_X                   ((0x3916  << 2) + 0xd0050000)
+#define HEVC_PSCALE_PICO_START_Y                   ((0x3917  << 2) + 0xd0050000)
+#define HEVC_PSCALE_DUMMY                          ((0x3918  << 2) + 0xd0050000)
+#define HEVC_PSCALE_FILT0_COEF0                    ((0x3919  << 2) + 0xd0050000)
+#define HEVC_PSCALE_FILT0_COEF1                    ((0x391a  << 2) + 0xd0050000)
+#define HEVC_PSCALE_CMD_CTRL                       ((0x391b  << 2) + 0xd0050000)
+#define HEVC_PSCALE_CMD_BLK_X                      ((0x391c  << 2) + 0xd0050000)
+#define HEVC_PSCALE_CMD_BLK_Y                      ((0x391d  << 2) + 0xd0050000)
+#define HEVC_PSCALE_STATUS                         ((0x391e  << 2) + 0xd0050000)
+#define HEVC_PSCALE_BMEM_ADDR                      ((0x391f  << 2) + 0xd0050000)
+#define HEVC_PSCALE_BMEM_DAT                       ((0x3920  << 2) + 0xd0050000)
+#define HEVC_PSCALE_DRAM_BUF_CTRL                  ((0x3921  << 2) + 0xd0050000)
+#define HEVC_PSCALE_MCMD_CTRL                      ((0x3922  << 2) + 0xd0050000)
+#define HEVC_PSCALE_MCMD_XSIZE                     ((0x3923  << 2) + 0xd0050000)
+#define HEVC_PSCALE_MCMD_YSIZE                     ((0x3924  << 2) + 0xd0050000)
+#define HEVC_PSCALE_RBUF_START_BLKX                ((0x3925  << 2) + 0xd0050000)
+#define HEVC_PSCALE_RBUF_START_BLKY                ((0x3926  << 2) + 0xd0050000)
+//`define PSCALE_RBUF_MB_WIDTH   8'h27
+#define HEVC_PSCALE_PICO_SHIFT_XY                  ((0x3928  << 2) + 0xd0050000)
+#define HEVC_PSCALE_CTRL1                          ((0x3929  << 2) + 0xd0050000)
+//Bit 15, wmask enable
+//Bit 14:13, filt0 srckey_less, 
+//Bit 12:11, filt1 srckey_less, in the case of the interpolated data is equal distance to 
+//key data and normal data, 00: select normal data, 01: select right data, 10: select key data
+//Bit 10:9, srckey mode, 00: equal, 01: less than or equal, 10: great than or equal
+//Bit 8, src key enable
+//Bit 7:0, y src key
+#define HEVC_PSCALE_SRCKEY_CTRL0                   ((0x392a  << 2) + 0xd0050000)
+//Bit 15:8, cb src key
+//Bit 7:0, cr src key
+#define HEVC_PSCALE_SRCKEY_CTRL1                   ((0x392b  << 2) + 0xd0050000)
+//Bit 22:16 canvas_rd_addr2
+//Bit 14:8 canvas_rd_addr1
+//Bit 6:0 canvas_rd_addr1
+#define HEVC_PSCALE_CANVAS_RD_ADDR                 ((0x392c  << 2) + 0xd0050000)
+//Bit 22:16 canvas_wr_addr2
+//Bit 14:8 canvas_wr_addr1
+//Bit 6:0 canvas_wr_addr1
+#define HEVC_PSCALE_CANVAS_WR_ADDR                 ((0x392d  << 2) + 0xd0050000)
+//bit 13:8 pscale thread ID and token 
+//bit 7 disable write response count adding to busy bit 
+//bit 5:0  pscale prearbitor burst num
+#define HEVC_PSCALE_CTRL2                          ((0x392e  << 2) + 0xd0050000)
+//   31 - use_omem_mb_xy_auto
+//23:16 - omem_max_mb_x
+//15:8  - omem_mb_y_auto
+// 7:0  - omem_mb_x_auto
+#define HEVC_HDEC_MC_OMEM_AUTO                     ((0x3930  << 2) + 0xd0050000)
+#define HEVC_HDEC_MC_MBRIGHT_IDX                   ((0x3931  << 2) + 0xd0050000)
+#define HEVC_HDEC_MC_MBRIGHT_RD                    ((0x3932  << 2) + 0xd0050000)
+#define HEVC_MC_MPORT_CTRL                         ((0x3940  << 2) + 0xd0050000)
+#define HEVC_MC_MPORT_DAT                          ((0x3941  << 2) + 0xd0050000)
+#define HEVC_MC_WT_PRED_CTRL                       ((0x3942  << 2) + 0xd0050000)
+#define HEVC_MC_MBBOT_ST_EVEN_ADDR                 ((0x3944  << 2) + 0xd0050000)
+#define HEVC_MC_MBBOT_ST_ODD_ADDR                  ((0x3945  << 2) + 0xd0050000)
+#define HEVC_MC_DPDN_MB_XY                         ((0x3946  << 2) + 0xd0050000)
+#define HEVC_MC_OMDN_MB_XY                         ((0x3947  << 2) + 0xd0050000)
+#define HEVC_MC_HCMDBUF_H                          ((0x3948  << 2) + 0xd0050000)
+#define HEVC_MC_HCMDBUF_L                          ((0x3949  << 2) + 0xd0050000)
+#define HEVC_MC_HCMD_H                             ((0x394a  << 2) + 0xd0050000)
+#define HEVC_MC_HCMD_L                             ((0x394b  << 2) + 0xd0050000)
+#define HEVC_MC_IDCT_DAT                           ((0x394c  << 2) + 0xd0050000)
+#define HEVC_MC_CTRL_GCLK_CTRL                     ((0x394d  << 2) + 0xd0050000)
+#define HEVC_MC_OTHER_GCLK_CTRL                    ((0x394e  << 2) + 0xd0050000)
+//Bit 29:24, mbbot thread ID and token 
+//Bit 21:16, mc read/write thread ID and token 
+//Bit 13:8,  mbbot pre-arbitor burst number 
+//Bit 5:0,   mc pre-arbitor burst number 
+#define HEVC_MC_CTRL2                              ((0x394f  << 2) + 0xd0050000)
+// `define DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
+//`define ANC1_CANVAS_ADDR      8'h80
+//`define ANC2_CANVAS_ADDR      8'h81
+//`define REC_CANVAS_ADDR       8'h89
+//`define MDEC_PIC_W          8'h8c
+//`define MDEC_PIC_H          8'h8d
+#define HEVC_MDEC_PIC_DC_CTRL                      ((0x398e  << 2) + 0xd0050000)
+#define HEVC_MDEC_PIC_DC_STATUS                    ((0x398f  << 2) + 0xd0050000)
+#define HEVC_ANC0_CANVAS_ADDR                      ((0x3990  << 2) + 0xd0050000)
+#define HEVC_ANC1_CANVAS_ADDR                      ((0x3991  << 2) + 0xd0050000)
+#define HEVC_ANC2_CANVAS_ADDR                      ((0x3992  << 2) + 0xd0050000)
+#define HEVC_ANC3_CANVAS_ADDR                      ((0x3993  << 2) + 0xd0050000)
+#define HEVC_ANC4_CANVAS_ADDR                      ((0x3994  << 2) + 0xd0050000)
+#define HEVC_ANC5_CANVAS_ADDR                      ((0x3995  << 2) + 0xd0050000)
+#define HEVC_ANC6_CANVAS_ADDR                      ((0x3996  << 2) + 0xd0050000)
+#define HEVC_ANC7_CANVAS_ADDR                      ((0x3997  << 2) + 0xd0050000)
+#define HEVC_ANC8_CANVAS_ADDR                      ((0x3998  << 2) + 0xd0050000)
+#define HEVC_ANC9_CANVAS_ADDR                      ((0x3999  << 2) + 0xd0050000)
+#define HEVC_ANC10_CANVAS_ADDR                     ((0x399a  << 2) + 0xd0050000)
+#define HEVC_ANC11_CANVAS_ADDR                     ((0x399b  << 2) + 0xd0050000)
+#define HEVC_ANC12_CANVAS_ADDR                     ((0x399c  << 2) + 0xd0050000)
+#define HEVC_ANC13_CANVAS_ADDR                     ((0x399d  << 2) + 0xd0050000)
+#define HEVC_ANC14_CANVAS_ADDR                     ((0x399e  << 2) + 0xd0050000)
+#define HEVC_ANC15_CANVAS_ADDR                     ((0x399f  << 2) + 0xd0050000)
+#define HEVC_ANC16_CANVAS_ADDR                     ((0x39a0  << 2) + 0xd0050000)
+#define HEVC_ANC17_CANVAS_ADDR                     ((0x39a1  << 2) + 0xd0050000)
+#define HEVC_ANC18_CANVAS_ADDR                     ((0x39a2  << 2) + 0xd0050000)
+#define HEVC_ANC19_CANVAS_ADDR                     ((0x39a3  << 2) + 0xd0050000)
+#define HEVC_ANC20_CANVAS_ADDR                     ((0x39a4  << 2) + 0xd0050000)
+#define HEVC_ANC21_CANVAS_ADDR                     ((0x39a5  << 2) + 0xd0050000)
+#define HEVC_ANC22_CANVAS_ADDR                     ((0x39a6  << 2) + 0xd0050000)
+#define HEVC_ANC23_CANVAS_ADDR                     ((0x39a7  << 2) + 0xd0050000)
+#define HEVC_ANC24_CANVAS_ADDR                     ((0x39a8  << 2) + 0xd0050000)
+#define HEVC_ANC25_CANVAS_ADDR                     ((0x39a9  << 2) + 0xd0050000)
+#define HEVC_ANC26_CANVAS_ADDR                     ((0x39aa  << 2) + 0xd0050000)
+#define HEVC_ANC27_CANVAS_ADDR                     ((0x39ab  << 2) + 0xd0050000)
+#define HEVC_ANC28_CANVAS_ADDR                     ((0x39ac  << 2) + 0xd0050000)
+#define HEVC_ANC29_CANVAS_ADDR                     ((0x39ad  << 2) + 0xd0050000)
+#define HEVC_ANC30_CANVAS_ADDR                     ((0x39ae  << 2) + 0xd0050000)
+#define HEVC_ANC31_CANVAS_ADDR                     ((0x39af  << 2) + 0xd0050000)
+#define HEVC_DBKR_CANVAS_ADDR                      ((0x39b0  << 2) + 0xd0050000)
+#define HEVC_DBKW_CANVAS_ADDR                      ((0x39b1  << 2) + 0xd0050000)
+#define HEVC_REC_CANVAS_ADDR                       ((0x39b2  << 2) + 0xd0050000)
+//28:24, read/write, current canvas idx, used in h264 only now
+//23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
+#define HEVC_CURR_CANVAS_CTRL                      ((0x39b3  << 2) + 0xd0050000)
+#define HEVC_MDEC_PIC_DC_THRESH                    ((0x39b8  << 2) + 0xd0050000)
+#define HEVC_MDEC_PICR_BUF_STATUS                  ((0x39b9  << 2) + 0xd0050000)
+#define HEVC_MDEC_PICW_BUF_STATUS                  ((0x39ba  << 2) + 0xd0050000)
+#define HEVC_MCW_DBLK_WRRSP_CNT                    ((0x39bb  << 2) + 0xd0050000)
+#define HEVC_MC_MBBOT_WRRSP_CNT                    ((0x39bc  << 2) + 0xd0050000)
+#define HEVC_MDEC_PICW_BUF2_STATUS                 ((0x39bd  << 2) + 0xd0050000)
+#define HEVC_WRRSP_FIFO_PICW_DBK                   ((0x39be  << 2) + 0xd0050000)
+#define HEVC_WRRSP_FIFO_PICW_MC                    ((0x39bf  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_0                          ((0x39c0  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_1                          ((0x39c1  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_2                          ((0x39c2  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_3                          ((0x39c3  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_4                          ((0x39c4  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_5                          ((0x39c5  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_6                          ((0x39c6  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_7                          ((0x39c7  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_8                          ((0x39c8  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_9                          ((0x39c9  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_A                          ((0x39ca  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_B                          ((0x39cb  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_C                          ((0x39cc  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_D                          ((0x39cd  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_E                          ((0x39ce  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_F                          ((0x39cf  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_G                          ((0x39d0  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_H                          ((0x39d1  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_I                          ((0x39d2  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_J                          ((0x39d3  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_K                          ((0x39d4  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_L                          ((0x39d5  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_M                          ((0x39d6  << 2) + 0xd0050000)
+#define HEVC_AV_SCRATCH_N                          ((0x39d7  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_co_mb
+// bit[21:16] A_id_co_mb
+// bit[11:0] wrrsp_count_co_mb
+#define HEVC_WRRSP_CO_MB                           ((0x39d8  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_dcac
+// bit[21:16] A_id_dcac
+// bit[11:0] wrrsp_count_dcac
+#define HEVC_WRRSP_DCAC                            ((0x39d9  << 2) + 0xd0050000)
+// bit[11:0] wrrsp_count_vld
+#define HEVC_WRRSP_VLD                             ((0x39da  << 2) + 0xd0050000)
+// doublew_cfg0[0];     //       Second Channel Enable, 1:Enable 0:Disable
+// doublew_cfg0[3:1];   // [2:0] Endian Control for Luma
+// doublew_cfg0[5:4];   // [1:0] Pixel sel by horizontal, 0x:1/2 10:left 11:right
+// doublew_cfg0[7:6];   // [1:0] Pixel sel by vertical,   0x:1/2 10:up 11:down
+// doublew_cfg0[8];     //       Size by horizontal, 0:original size 1: 1/2 shrunken size
+// doublew_cfg0[9];     //       Size by vertical,   0:original size 1: 1/2 shrunken size
+// doublew_cfg0[10];    //       1:Round 0:Truncation
+// doublew_cfg0[11];    //       DMA Urgent
+// doublew_cfg0[17:12]; // [5:0] DMA Burst Number
+// doublew_cfg0[23:18]; // [5:0] DMA ID
+// doublew_cfg0[26:24]; // [2:0] Endian Control for Chroma
+// doublew_cfg0[27];    //       Source from, 1:MCW 0:DBLK
+// doublew_cfg0[29:28]; // [1:0] 0x:select both top and bottom 10:select top 11:select bottom
+// doublew_cfg0[30];    //       0:no merge 1:automatic merge
+// doublew_cfg0[31];    //       0:Y addr no change 1:Y addr divided to half
+#define HEVC_MDEC_DOUBLEW_CFG0                     ((0x39db  << 2) + 0xd0050000)
+// doublew_cfg1[7:0];   // [7:0] DMA Canvas Address for Luma
+// doublew_cfg1[15:8];  // [7:0] DMA Canvas Address for Chroma
+// doublew_cfg1[16];    //       Disable 1st Write - 
+// doublew_cfg1[17];    //       Reverse to original version - 
+// doublew_cfg1[18];    //       DMA Address Mode - 0:Canvas Mode 1:Non-Canvas Mode
+#define HEVC_MDEC_DOUBLEW_CFG1                     ((0x39dc  << 2) + 0xd0050000)
+// doublew_cfg2[11:0];  //[11:0] vertical flip initial value
+// doublew_cfg2[15];    //       vertical flip enable
+// doublew_cfg2[24:16]; // [8:0] horizontal flip initial value
+// doublew_cfg2[31];    //       horizontal flip enable
+#define HEVC_MDEC_DOUBLEW_CFG2                     ((0x39dd  << 2) + 0xd0050000)
+// doublew_cfg3[31:0];  //[31:0] non-canvas start address for Luma - 
+#define HEVC_MDEC_DOUBLEW_CFG3                     ((0x39de  << 2) + 0xd0050000)
+// doublew_cfg4[31:0];  //[31:0] non-canvas start address for Chroma - 
+#define HEVC_MDEC_DOUBLEW_CFG4                     ((0x39df  << 2) + 0xd0050000)
+// doublew_cfg5[12:0];  //[12:0] non-canvas picture width for Luma - 
+// doublew_cfg5[28:16]; //[12:0] non-canvas picture width for Chroma - 
+#define HEVC_MDEC_DOUBLEW_CFG5                     ((0x39e0  << 2) + 0xd0050000)
+// doublew_cfg6: reserved
+#define HEVC_MDEC_DOUBLEW_CFG6                     ((0x39e1  << 2) + 0xd0050000)
+// doublew_cfg7: reserved
+#define HEVC_MDEC_DOUBLEW_CFG7                     ((0x39e2  << 2) + 0xd0050000)
+// doublew_status[11:0];//[11:0] wrrsp_count_doublew
+// doublew_status[12];  //       doublew_status_busy
+// doublew_status[13];  //       doublew_status_error
+#define HEVC_MDEC_DOUBLEW_STATUS                   ((0x39e3  << 2) + 0xd0050000)
+//======================================
+//  MC Control Register Bits
+//
+//======================================
+// For bits, just copy the defines...don't translate to addresses
+    //`define MC_RESET	    16'h0002
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//======================================
+//  MB Info Register Bits
+//
+//======================================
+//========================================================================
+// DBLK Register:  12'h950 - 12'h97f 
+//========================================================================
+#define HEVC_DBLK_RST                              ((0x3950  << 2) + 0xd0050000)
+#define HEVC_DBLK_CTRL                             ((0x3951  << 2) + 0xd0050000)
+#define HEVC_DBLK_MB_WID_HEIGHT                    ((0x3952  << 2) + 0xd0050000)
+#define HEVC_DBLK_STATUS                           ((0x3953  << 2) + 0xd0050000)
+#define HEVC_DBLK_CMD_CTRL                         ((0x3954  << 2) + 0xd0050000)
+#define HEVC_DBLK_MB_XY                            ((0x3955  << 2) + 0xd0050000)
+#define HEVC_DBLK_QP                               ((0x3956  << 2) + 0xd0050000)
+#define HEVC_DBLK_Y_BHFILT                         ((0x3957  << 2) + 0xd0050000)
+#define HEVC_DBLK_Y_BHFILT_HIGH                    ((0x3958  << 2) + 0xd0050000)
+#define HEVC_DBLK_Y_BVFILT                         ((0x3959  << 2) + 0xd0050000)
+#define HEVC_DBLK_CB_BFILT                         ((0x395a  << 2) + 0xd0050000)
+#define HEVC_DBLK_CR_BFILT                         ((0x395b  << 2) + 0xd0050000)
+#define HEVC_DBLK_Y_HFILT                          ((0x395c  << 2) + 0xd0050000)
+#define HEVC_DBLK_Y_HFILT_HIGH                     ((0x395d  << 2) + 0xd0050000)
+#define HEVC_DBLK_Y_VFILT                          ((0x395e  << 2) + 0xd0050000)
+#define HEVC_DBLK_CB_FILT                          ((0x395f  << 2) + 0xd0050000)
+#define HEVC_DBLK_CR_FILT                          ((0x3960  << 2) + 0xd0050000)
+#define HEVC_DBLK_BETAX_QP_SEL                     ((0x3961  << 2) + 0xd0050000)
+#define HEVC_DBLK_CLIP_CTRL0                       ((0x3962  << 2) + 0xd0050000)
+#define HEVC_DBLK_CLIP_CTRL1                       ((0x3963  << 2) + 0xd0050000)
+#define HEVC_DBLK_CLIP_CTRL2                       ((0x3964  << 2) + 0xd0050000)
+#define HEVC_DBLK_CLIP_CTRL3                       ((0x3965  << 2) + 0xd0050000)
+#define HEVC_DBLK_CLIP_CTRL4                       ((0x3966  << 2) + 0xd0050000)
+#define HEVC_DBLK_CLIP_CTRL5                       ((0x3967  << 2) + 0xd0050000)
+#define HEVC_DBLK_CLIP_CTRL6                       ((0x3968  << 2) + 0xd0050000)
+#define HEVC_DBLK_CLIP_CTRL7                       ((0x3969  << 2) + 0xd0050000)
+#define HEVC_DBLK_CLIP_CTRL8                       ((0x396a  << 2) + 0xd0050000)
+#define HEVC_DBLK_STATUS1                          ((0x396b  << 2) + 0xd0050000)
+#define HEVC_DBLK_GCLK_FREE                        ((0x396c  << 2) + 0xd0050000)
+#define HEVC_DBLK_GCLK_OFF                         ((0x396d  << 2) + 0xd0050000)
+#define HEVC_DBLK_AVSFLAGS                         ((0x396e  << 2) + 0xd0050000)
+// bit 15:0
+#define HEVC_DBLK_CBPY                             ((0x3970  << 2) + 0xd0050000)
+// bit 11:8 -- deblk_cbpy_bottom
+// bit 7:4 -- deblk_cbpy_left
+// bit 3:0 -- deblk_cbpy_top
+#define HEVC_DBLK_CBPY_ADJ                         ((0x3971  << 2) + 0xd0050000)
+// bit 7:0 -- deblk_cbpc
+#define HEVC_DBLK_CBPC                             ((0x3972  << 2) + 0xd0050000)
+// bit 15 -- bottom_mb
+// bit 14 -- left_mb
+// bit 13 -- top_mb
+// bit 12 -- reserved
+// bit 11:8 -- deblk_cbpc_bottom
+// bit 7:4 -- deblk_cbpc_left
+// bit 3:0 -- deblk_cbpc_top
+#define HEVC_DBLK_CBPC_ADJ                         ((0x3973  << 2) + 0xd0050000)
+// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0} 
+// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0} 
+#define HEVC_DBLK_VHMVD                            ((0x3974  << 2) + 0xd0050000)
+// bit 13:12 -- right_vmvd
+// bit 11 -- right_above_vmvd
+// bit 10 -- left_below_hmvd
+// bit 9 -- disable_dblk_luma  
+// bit 8 -- disable_dblk_chroma
+// bit 7 -- bBelowRefDiff
+// bit 6 -- bLeftRefDiff
+// bit 5 -- bAboveRefDiff
+// bit 4 -- reserved
+// bit 3 -- s_below
+// bit 2 -- s_left
+// bit 1 -- s_above
+// bit 0 -- s 
+#define HEVC_DBLK_STRONG                           ((0x3975  << 2) + 0xd0050000)
+// bit 14:10 -- PQUANT 
+// bit 9:5 -- left_PQUANT 
+// bit 4:0 -- top_PQUANT 
+#define HEVC_DBLK_RV8_QUANT                        ((0x3976  << 2) + 0xd0050000)
+#define HEVC_DBLK_CBUS_HCMD2                       ((0x3977  << 2) + 0xd0050000)
+#define HEVC_DBLK_CBUS_HCMD1                       ((0x3978  << 2) + 0xd0050000)
+#define HEVC_DBLK_CBUS_HCMD0                       ((0x3979  << 2) + 0xd0050000)
+#define HEVC_DBLK_VLD_HCMD2                        ((0x397a  << 2) + 0xd0050000)
+#define HEVC_DBLK_VLD_HCMD1                        ((0x397b  << 2) + 0xd0050000)
+#define HEVC_DBLK_VLD_HCMD0                        ((0x397c  << 2) + 0xd0050000)
+#define HEVC_DBLK_OST_YBASE                        ((0x397d  << 2) + 0xd0050000)
+#define HEVC_DBLK_OST_CBCRDIFF                     ((0x397e  << 2) + 0xd0050000)
+//13:8 dblk thread ID and token 
+//5:0  dblk prearbitor burst num
+#define HEVC_DBLK_CTRL1                            ((0x397f  << 2) + 0xd0050000)
+// MCRCC_CTL1
+// 31:3  <reserved[23:0]>
+// 2     <cfg_field_pic>
+// 1     <sw_rst>
+// 0     <bypass_en>
+#define HEVC_MCRCC_CTL1                            ((0x3980  << 2) + 0xd0050000)
+// MCRCC_CTL2
+// 31:24    <cfg_cache_anc01_c[7:0]>
+// 23:16    <cfg_cache_anc01_y[7:0]>
+// 15:8     <cfg_cache_anc00_c[7:0]>
+// 7:0      <cfg_cache_anc00_y[7:0]>
+#define HEVC_MCRCC_CTL2                            ((0x3981  << 2) + 0xd0050000)
+// MCRCC_CTL3
+// 31:24    <cfg_cache_anc11_c[7:0]>
+// 23:16    <cfg_cache_anc11_y[7:0]>
+// 15:8     <cfg_cache_anc10_c[7:0]>
+// 7:0      <cfg_cache_anc10_y[7:0]>
+#define HEVC_MCRCC_CTL3                            ((0x3982  << 2) + 0xd0050000)
+// bit[31:10] reserved
+// bit[9:0] sw_clock_gating control 
+// [9] vdec clk_en for assist and cbus.
+// [8] vdec clk_en for ddr
+// [7] vdec clk_en for vcpu
+// [6] vdec clk_en for assist
+// [5] vdec clk_en for dblk
+// [4] vdec clk_en for iqidct
+// [3] vdec clk_en for mc
+// [2] vdec clk_en for pic_dc
+// [1] vdec clk_en for psc
+// [0] vdec clk_en for vld
+#define HEVC_GCLK_EN                               ((0x3983  << 2) + 0xd0050000)
+// [0]  Reserved 
+// [1]  Reserved
+// [2]  Reset assist, mdec's CBUS
+// [3]  Reset mdec's VLD
+// [4]  Reset mdec's VLD
+// [5]  Reset mdec's VLD
+// [6]  Reset mdec's IQIDCT
+// [7]  Reset mdec's MC
+// [8]  Reset mdec's DBLK
+// [9]  Reset mdec's PIC_DC
+// [10] Reset mdec's Pscale
+// [11] Reset vcpu's MCPU
+// [12] Reset vcpu's CCPU
+// [13] Reset mmc_pre_arb
+#define HEVC_MDEC_SW_RESET                         ((0x3984  << 2) + 0xd0050000)
+//DBLK last address 12'h97f
+//
+// Closing file:  mdec_regs.h
+//
+//
+// Reading file:  vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+#define HCODEC_VLD_STATUS_CTRL                     ((0x1c00  << 2) + 0xd0050000)
+//
+// bit 10 -- use_old_shift_en
+// bit 9 -- output_mv_not_pmv
+// bit 8:5 -- force_zigzag
+// bit 4 -- force_zigzag_en
+// bit 3 -- disable_viff_anempty_int
+// bit 2 -- disable_m2_ac_coeff_one_cycle
+// bit 1 -- forced_reset  force reset pmv
+// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+#define HCODEC_MPEG1_2_REG                         ((0x1c01  << 2) + 0xd0050000)
+#define HCODEC_F_CODE_REG                          ((0x1c02  << 2) + 0xd0050000)
+#define HCODEC_PIC_HEAD_INFO                       ((0x1c03  << 2) + 0xd0050000)
+#define HCODEC_SLICE_VER_POS_PIC_TYPE              ((0x1c04  << 2) + 0xd0050000)
+#define HCODEC_QP_VALUE_REG                        ((0x1c05  << 2) + 0xd0050000)
+#define HCODEC_MBA_INC                             ((0x1c06  << 2) + 0xd0050000)
+#define HCODEC_MB_MOTION_MODE                      ((0x1c07  << 2) + 0xd0050000)
+//`define PACKET_BYTE_COUNT   8'h08
+// bit 15 -- force_search_startcode_en
+// bit 14 -- int_cpu_when_error (before do anything)
+// bit 13 -- vld_error_reset
+// bit 12 -- return_on_slice_header
+// bit 6 -- jpeg_ff00_en 
+// bit 5:0 -- vld_power_ctl
+#define HCODEC_POWER_CTL_VLD                       ((0x1c08  << 2) + 0xd0050000)
+#define HCODEC_MB_WIDTH                            ((0x1c09  << 2) + 0xd0050000)
+#define HCODEC_SLICE_QP                            ((0x1c0a  << 2) + 0xd0050000)
+// `define MB_X_MB_Y           8'h0b   /* current MBX and MBY                  */
+#define HCODEC_PRE_START_CODE                      ((0x1c0b  << 2) + 0xd0050000)
+#define HCODEC_SLICE_START_BYTE_01                 ((0x1c0c  << 2) + 0xd0050000)
+#define HCODEC_SLICE_START_BYTE_23                 ((0x1c0d  << 2) + 0xd0050000)
+#define HCODEC_RESYNC_MARKER_LENGTH                ((0x1c0e  << 2) + 0xd0050000)
+// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+// bit[4:0] - buffer ID
+// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+#define HCODEC_DECODER_BUFFER_INFO                 ((0x1c0f  << 2) + 0xd0050000)
+#define HCODEC_FST_FOR_MV_X                        ((0x1c10  << 2) + 0xd0050000)
+#define HCODEC_FST_FOR_MV_Y                        ((0x1c11  << 2) + 0xd0050000)
+#define HCODEC_SCD_FOR_MV_X                        ((0x1c12  << 2) + 0xd0050000)
+#define HCODEC_SCD_FOR_MV_Y                        ((0x1c13  << 2) + 0xd0050000)
+#define HCODEC_FST_BAK_MV_X                        ((0x1c14  << 2) + 0xd0050000)
+#define HCODEC_FST_BAK_MV_Y                        ((0x1c15  << 2) + 0xd0050000)
+#define HCODEC_SCD_BAK_MV_X                        ((0x1c16  << 2) + 0xd0050000)
+#define HCODEC_SCD_BAK_MV_Y                        ((0x1c17  << 2) + 0xd0050000)
+// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+// bit 3 -- reserved
+// bit 2 -- weighting_prediction
+// bit 1 -- mb_weighting_flag
+// bit 0 -- slice_weighting_flag 
+#define HCODEC_VLD_DECODE_CONTROL                  ((0x1c18  << 2) + 0xd0050000)
+#define HCODEC_VLD_REVERVED_19                     ((0x1c19  << 2) + 0xd0050000)
+#define HCODEC_VIFF_BIT_CNT                        ((0x1c1a  << 2) + 0xd0050000)
+#define HCODEC_BYTE_ALIGN_PEAK_HI                  ((0x1c1b  << 2) + 0xd0050000)
+#define HCODEC_BYTE_ALIGN_PEAK_LO                  ((0x1c1c  << 2) + 0xd0050000)
+#define HCODEC_NEXT_ALIGN_PEAK                     ((0x1c1d  << 2) + 0xd0050000)
+// bit 19    : vc1_inv_intra_co_mb_ref_rd
+// bit 18    : vc1_inv_co_mb_ref_rd
+// bit 17    : vc1_inv_intra_co_mb_ref_wr
+// bit 16    : vc1_inv_co_mb_ref_wr
+// bit 15    : reserved
+// bit 14    : avs_drop_enable
+// bit 13:12 : avs_drop_ptr
+// bit 11:8  : avs_demu_ctl_reg
+// bit 7 : avs_enable
+// bit 6 : disable_dblk_hcmd
+// bit 5 : disable_mc_hcmd
+// bit 4 : first_mode3_set enable
+// bit 3 : first_mode3
+// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+// bit 0   : vc1_enable
+#define HCODEC_VC1_CONTROL_REG                     ((0x1c1e  << 2) + 0xd0050000)
+#define HCODEC_PMV1_X                              ((0x1c20  << 2) + 0xd0050000)
+#define HCODEC_PMV1_Y                              ((0x1c21  << 2) + 0xd0050000)
+#define HCODEC_PMV2_X                              ((0x1c22  << 2) + 0xd0050000)
+#define HCODEC_PMV2_Y                              ((0x1c23  << 2) + 0xd0050000)
+#define HCODEC_PMV3_X                              ((0x1c24  << 2) + 0xd0050000)
+#define HCODEC_PMV3_Y                              ((0x1c25  << 2) + 0xd0050000)
+#define HCODEC_PMV4_X                              ((0x1c26  << 2) + 0xd0050000)
+#define HCODEC_PMV4_Y                              ((0x1c27  << 2) + 0xd0050000)
+// Can't use the same address for different defines
+// Therefore, create a single define that covers both
+// Only appears to be used in micro-code since the VLD hardware is 
+// hard coded.
+// `define M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+// `define M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+#define HCODEC_M4_TABLE_SELECT                     ((0x1c28  << 2) + 0xd0050000)
+#define HCODEC_M4_CONTROL_REG                      ((0x1c29  << 2) + 0xd0050000)
+#define HCODEC_BLOCK_NUM                           ((0x1c2a  << 2) + 0xd0050000)
+#define HCODEC_PATTERN_CODE                        ((0x1c2b  << 2) + 0xd0050000)
+#define HCODEC_MB_INFO                             ((0x1c2c  << 2) + 0xd0050000)
+#define HCODEC_VLD_DC_PRED                         ((0x1c2d  << 2) + 0xd0050000)
+#define HCODEC_VLD_ERROR_MASK                      ((0x1c2e  << 2) + 0xd0050000)
+#define HCODEC_VLD_DC_PRED_C                       ((0x1c2f  << 2) + 0xd0050000)
+#define HCODEC_LAST_SLICE_MV_ADDR                  ((0x1c30  << 2) + 0xd0050000)
+#define HCODEC_LAST_MVX                            ((0x1c31  << 2) + 0xd0050000)
+#define HCODEC_LAST_MVY                            ((0x1c32  << 2) + 0xd0050000)
+#define HCODEC_VLD_C38                             ((0x1c38  << 2) + 0xd0050000)
+#define HCODEC_VLD_C39                             ((0x1c39  << 2) + 0xd0050000)
+#define HCODEC_VLD_STATUS                          ((0x1c3a  << 2) + 0xd0050000)
+#define HCODEC_VLD_SHIFT_STATUS                    ((0x1c3b  << 2) + 0xd0050000)
+// `define VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+#define HCODEC_VOFF_STATUS                         ((0x1c3c  << 2) + 0xd0050000)
+#define HCODEC_VLD_C3D                             ((0x1c3d  << 2) + 0xd0050000)
+#define HCODEC_VLD_DBG_INDEX                       ((0x1c3e  << 2) + 0xd0050000)
+// vld_buff_info -- (index == 0) 
+// Bit[7:6]  mv_UR_ready_cnt;
+// Bit[5]  vld_wr_idx
+// Bit[4]  iq_rd_idx
+// Bit[3]  vld_vi_block_rdy_1
+// Bit[2]  vld_vi_block_rdy_2
+// Bit[1]  voff_empty_1
+// Bit[0]  voff_empty_2
+// cabac_buff_info_0 -- (index == 1) 
+// Bit[31] shift_data_ready
+// Bit[30:29] Reserved
+// Bit[28:24] cabac_buffer_ptr
+// Bit[23:0] cabac_buffer
+// cabac_buff_info_1 -- (index == 2) 
+// Bit[31:29] Reserved
+// Bit[28:20] Drange
+// Bit[19:16] bin_count_4
+// Bit[15:13] Reserved
+// Bit[12:6] context_mem_do
+// Bit[5:3] coeff_state
+// Bit[2:0] mvd_state
+// h264_mv_present -- (index == 3) 
+// Bit[31:16] mv_present_l0
+// Bit[15:0] mv_present_l1
+// h264_mv_cal_info_0 -- (index == 4) 
+// [31:28] mv_cal_state
+// [27:24] direct_spatial_cnt
+// Bit[23:21] Reserved
+// Bit[20] mv_UR_ready_for_mv_cal
+// Bit[19] co_mb_mem_ready_for_mv_cal
+// Bit[18] mc_dblk_cmd_if_busy
+// Bit[17] h264_co_mb_wr_busy
+// Bit[16] H264_cbp_blk_ready
+// Bit[15] mc_hcmd_rrdy
+// Bit[14] mc_hcmd_srdy
+// Bit[13] mc_cmd_if_ready
+// Bit[12] mc_hcmd_mv_available
+// Bit[11:8] mc_cmd_if_state
+// Bit[7] dblk_hcmd_rrdy
+// Bit[6] dblk_hcmd_srdy
+// Bit[5] dblk_cmd_if_ready
+// Bit[4] dblk_hcmd_mv_available
+// Bit[3:0] dblk_cmd_if_state
+// h264_mv_cal_info_1 -- (index == 5) 
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l0
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l0
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l0
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l0
+// h264_mv_cal_info_2 -- (index == 6) 
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l1
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l1
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l1
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l1
+// h264_co_mb_info -- (index == 7)
+// Bit[31:26] Reserved
+// Bit[25] mv_scale_cal_busy
+// Bit[24:20] co_mv_count
+// Bit[19:16] co_mv_process_state
+// Bit[15] h264_co_mb_rd_busy
+// Bit[15] h264_co_mb_rd_ready
+// Bit[13:12] co_mv_transfer_block_cnt
+// Bit[11:8] co_mv_transfer_ptr
+// Bit[7] co_mv_POC_l1_busy
+// Bit[6] h264_weight_scale_cal_en
+// Bit[5] weight_cal_busy
+// Bit[4] weight_cal_not_finished
+// Bit[3:0] weight_process_state
+#define HCODEC_VLD_DBG_DATA                        ((0x1c3f  << 2) + 0xd0050000)
+// --------------------------------------------
+// VIFIFO DDR Interface
+// --------------------------------------------
+// The VIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define HCODEC_VLD_MEM_VIFIFO_START_PTR            ((0x1c40  << 2) + 0xd0050000)
+// The current pointer points so some location between the START and END 
+// pointers.  The current pointer is a BYTE pointer.  That is, you can 
+// point to any BYTE address within the START/END range
+#define HCODEC_VLD_MEM_VIFIFO_CURR_PTR             ((0x1c41  << 2) + 0xd0050000)
+#define HCODEC_VLD_MEM_VIFIFO_END_PTR              ((0x1c42  << 2) + 0xd0050000)
+#define HCODEC_VLD_MEM_VIFIFO_BYTES_AVAIL          ((0x1c43  << 2) + 0xd0050000)
+// VIFIFO FIFO Control
+// bit  [31:24] viff_empty_int_enable_cpu[7:0] 
+// bit  [23:16] viff_empty_int_enable_amrisc[7:0] 
+//   -bit 23 Video BUFFER < 0x400 Bytes
+//   -bit 22 Video BUFFER < 0x200 Bytes
+//   -bit 21 Video BUFFER < 0x100 Bytes
+//   -bit 20 Video BUFFER < 0x80 Bytes
+//   -bit 19 Video BUFFER < 0x40 Bytes
+//   -bit 18 Video BUFFER < 0x20 Bytes
+//   -bit 17 vififo  < 16 double words
+//   -bit 16 vififo  < 8 double words
+// bit  [15:13] unused
+// bit  [12]    A_urgent
+// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     init_with_cntl_init
+// bit  [6]     reserved
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define HCODEC_VLD_MEM_VIFIFO_CONTROL              ((0x1c44  << 2) + 0xd0050000)
+// --------------------------------------------
+// VIFIFO Buffer Level Manager
+// --------------------------------------------
+#define HCODEC_VLD_MEM_VIFIFO_WP                   ((0x1c45  << 2) + 0xd0050000)
+#define HCODEC_VLD_MEM_VIFIFO_RP                   ((0x1c46  << 2) + 0xd0050000)
+#define HCODEC_VLD_MEM_VIFIFO_LEVEL                ((0x1c47  << 2) + 0xd0050000)
+//
+// bit  [8]     use_parser_video2_wp
+// bit  [7]     vbuf2_out_manual
+// bit  [6]     vbuf_out_manual
+// bit  [5]     empty (ReadOnly)
+// bit  [4]     full (ReadOnly)
+// bit  [3:2]   reserved
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define HCODEC_VLD_MEM_VIFIFO_BUF_CNTL             ((0x1c48  << 2) + 0xd0050000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define HCODEC_VLD_TIME_STAMP_CNTL                 ((0x1c49  << 2) + 0xd0050000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define HCODEC_VLD_TIME_STAMP_SYNC_0               ((0x1c4a  << 2) + 0xd0050000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
+#define HCODEC_VLD_TIME_STAMP_SYNC_1               ((0x1c4b  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_0
+#define HCODEC_VLD_TIME_STAMP_0                    ((0x1c4c  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_1
+#define HCODEC_VLD_TIME_STAMP_1                    ((0x1c4d  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_2
+#define HCODEC_VLD_TIME_STAMP_2                    ((0x1c4e  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_3
+#define HCODEC_VLD_TIME_STAMP_3                    ((0x1c4f  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define HCODEC_VLD_TIME_STAMP_LENGTH               ((0x1c50  << 2) + 0xd0050000)
+// bit 15:0 vififo_rd_count
+#define HCODEC_VLD_MEM_VIFIFO_WRAP_COUNT           ((0x1c51  << 2) + 0xd0050000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold 
+#define HCODEC_VLD_MEM_VIFIFO_MEM_CTL              ((0x1c52  << 2) + 0xd0050000)
+#define HCODEC_VLD_MEM_VBUF_RD_PTR                 ((0x1c53  << 2) + 0xd0050000)
+#define HCODEC_VLD_MEM_VBUF2_RD_PTR                ((0x1c54  << 2) + 0xd0050000)
+#define HCODEC_VLD_MEM_SWAP_ADDR                   ((0x1c55  << 2) + 0xd0050000)
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only)
+// bit [7] - swap busy (Read Only)
+// bit [6:2] - reserved
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define HCODEC_VLD_MEM_SWAP_CTL                    ((0x1c56  << 2) + 0xd0050000)
+//
+// Closing file:  vld_regs.h
+//
+//
+// Reading file:  vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+#define VDEC2_VLD_STATUS_CTRL                      ((0x2c00  << 2) + 0xd0050000)
+//
+// bit 10 -- use_old_shift_en
+// bit 9 -- output_mv_not_pmv
+// bit 8:5 -- force_zigzag
+// bit 4 -- force_zigzag_en
+// bit 3 -- disable_viff_anempty_int
+// bit 2 -- disable_m2_ac_coeff_one_cycle
+// bit 1 -- forced_reset  force reset pmv
+// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+#define VDEC2_MPEG1_2_REG                          ((0x2c01  << 2) + 0xd0050000)
+#define VDEC2_F_CODE_REG                           ((0x2c02  << 2) + 0xd0050000)
+#define VDEC2_PIC_HEAD_INFO                        ((0x2c03  << 2) + 0xd0050000)
+#define VDEC2_SLICE_VER_POS_PIC_TYPE               ((0x2c04  << 2) + 0xd0050000)
+#define VDEC2_QP_VALUE_REG                         ((0x2c05  << 2) + 0xd0050000)
+#define VDEC2_MBA_INC                              ((0x2c06  << 2) + 0xd0050000)
+#define VDEC2_MB_MOTION_MODE                       ((0x2c07  << 2) + 0xd0050000)
+//`define PACKET_BYTE_COUNT   8'h08
+// bit 15 -- force_search_startcode_en
+// bit 14 -- int_cpu_when_error (before do anything)
+// bit 13 -- vld_error_reset
+// bit 12 -- return_on_slice_header
+// bit 6 -- jpeg_ff00_en 
+// bit 5:0 -- vld_power_ctl
+#define VDEC2_POWER_CTL_VLD                        ((0x2c08  << 2) + 0xd0050000)
+#define VDEC2_MB_WIDTH                             ((0x2c09  << 2) + 0xd0050000)
+#define VDEC2_SLICE_QP                             ((0x2c0a  << 2) + 0xd0050000)
+// `define MB_X_MB_Y           8'h0b   /* current MBX and MBY                  */
+#define VDEC2_PRE_START_CODE                       ((0x2c0b  << 2) + 0xd0050000)
+#define VDEC2_SLICE_START_BYTE_01                  ((0x2c0c  << 2) + 0xd0050000)
+#define VDEC2_SLICE_START_BYTE_23                  ((0x2c0d  << 2) + 0xd0050000)
+#define VDEC2_RESYNC_MARKER_LENGTH                 ((0x2c0e  << 2) + 0xd0050000)
+// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+// bit[4:0] - buffer ID
+// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+#define VDEC2_DECODER_BUFFER_INFO                  ((0x2c0f  << 2) + 0xd0050000)
+#define VDEC2_FST_FOR_MV_X                         ((0x2c10  << 2) + 0xd0050000)
+#define VDEC2_FST_FOR_MV_Y                         ((0x2c11  << 2) + 0xd0050000)
+#define VDEC2_SCD_FOR_MV_X                         ((0x2c12  << 2) + 0xd0050000)
+#define VDEC2_SCD_FOR_MV_Y                         ((0x2c13  << 2) + 0xd0050000)
+#define VDEC2_FST_BAK_MV_X                         ((0x2c14  << 2) + 0xd0050000)
+#define VDEC2_FST_BAK_MV_Y                         ((0x2c15  << 2) + 0xd0050000)
+#define VDEC2_SCD_BAK_MV_X                         ((0x2c16  << 2) + 0xd0050000)
+#define VDEC2_SCD_BAK_MV_Y                         ((0x2c17  << 2) + 0xd0050000)
+// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+// bit 3 -- reserved
+// bit 2 -- weighting_prediction
+// bit 1 -- mb_weighting_flag
+// bit 0 -- slice_weighting_flag 
+#define VDEC2_VLD_DECODE_CONTROL                   ((0x2c18  << 2) + 0xd0050000)
+#define VDEC2_VLD_REVERVED_19                      ((0x2c19  << 2) + 0xd0050000)
+#define VDEC2_VIFF_BIT_CNT                         ((0x2c1a  << 2) + 0xd0050000)
+#define VDEC2_BYTE_ALIGN_PEAK_HI                   ((0x2c1b  << 2) + 0xd0050000)
+#define VDEC2_BYTE_ALIGN_PEAK_LO                   ((0x2c1c  << 2) + 0xd0050000)
+#define VDEC2_NEXT_ALIGN_PEAK                      ((0x2c1d  << 2) + 0xd0050000)
+// bit 19    : vc1_inv_intra_co_mb_ref_rd
+// bit 18    : vc1_inv_co_mb_ref_rd
+// bit 17    : vc1_inv_intra_co_mb_ref_wr
+// bit 16    : vc1_inv_co_mb_ref_wr
+// bit 15    : reserved
+// bit 14    : avs_drop_enable
+// bit 13:12 : avs_drop_ptr
+// bit 11:8  : avs_demu_ctl_reg
+// bit 7 : avs_enable
+// bit 6 : disable_dblk_hcmd
+// bit 5 : disable_mc_hcmd
+// bit 4 : first_mode3_set enable
+// bit 3 : first_mode3
+// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+// bit 0   : vc1_enable
+#define VDEC2_VC1_CONTROL_REG                      ((0x2c1e  << 2) + 0xd0050000)
+#define VDEC2_PMV1_X                               ((0x2c20  << 2) + 0xd0050000)
+#define VDEC2_PMV1_Y                               ((0x2c21  << 2) + 0xd0050000)
+#define VDEC2_PMV2_X                               ((0x2c22  << 2) + 0xd0050000)
+#define VDEC2_PMV2_Y                               ((0x2c23  << 2) + 0xd0050000)
+#define VDEC2_PMV3_X                               ((0x2c24  << 2) + 0xd0050000)
+#define VDEC2_PMV3_Y                               ((0x2c25  << 2) + 0xd0050000)
+#define VDEC2_PMV4_X                               ((0x2c26  << 2) + 0xd0050000)
+#define VDEC2_PMV4_Y                               ((0x2c27  << 2) + 0xd0050000)
+// Can't use the same address for different defines
+// Therefore, create a single define that covers both
+// Only appears to be used in micro-code since the VLD hardware is 
+// hard coded.
+// `define M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+// `define M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+#define VDEC2_M4_TABLE_SELECT                      ((0x2c28  << 2) + 0xd0050000)
+#define VDEC2_M4_CONTROL_REG                       ((0x2c29  << 2) + 0xd0050000)
+#define VDEC2_BLOCK_NUM                            ((0x2c2a  << 2) + 0xd0050000)
+#define VDEC2_PATTERN_CODE                         ((0x2c2b  << 2) + 0xd0050000)
+#define VDEC2_MB_INFO                              ((0x2c2c  << 2) + 0xd0050000)
+#define VDEC2_VLD_DC_PRED                          ((0x2c2d  << 2) + 0xd0050000)
+#define VDEC2_VLD_ERROR_MASK                       ((0x2c2e  << 2) + 0xd0050000)
+#define VDEC2_VLD_DC_PRED_C                        ((0x2c2f  << 2) + 0xd0050000)
+#define VDEC2_LAST_SLICE_MV_ADDR                   ((0x2c30  << 2) + 0xd0050000)
+#define VDEC2_LAST_MVX                             ((0x2c31  << 2) + 0xd0050000)
+#define VDEC2_LAST_MVY                             ((0x2c32  << 2) + 0xd0050000)
+#define VDEC2_VLD_C38                              ((0x2c38  << 2) + 0xd0050000)
+#define VDEC2_VLD_C39                              ((0x2c39  << 2) + 0xd0050000)
+#define VDEC2_VLD_STATUS                           ((0x2c3a  << 2) + 0xd0050000)
+#define VDEC2_VLD_SHIFT_STATUS                     ((0x2c3b  << 2) + 0xd0050000)
+// `define VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+#define VDEC2_VOFF_STATUS                          ((0x2c3c  << 2) + 0xd0050000)
+#define VDEC2_VLD_C3D                              ((0x2c3d  << 2) + 0xd0050000)
+#define VDEC2_VLD_DBG_INDEX                        ((0x2c3e  << 2) + 0xd0050000)
+// vld_buff_info -- (index == 0) 
+// Bit[7:6]  mv_UR_ready_cnt;
+// Bit[5]  vld_wr_idx
+// Bit[4]  iq_rd_idx
+// Bit[3]  vld_vi_block_rdy_1
+// Bit[2]  vld_vi_block_rdy_2
+// Bit[1]  voff_empty_1
+// Bit[0]  voff_empty_2
+// cabac_buff_info_0 -- (index == 1) 
+// Bit[31] shift_data_ready
+// Bit[30:29] Reserved
+// Bit[28:24] cabac_buffer_ptr
+// Bit[23:0] cabac_buffer
+// cabac_buff_info_1 -- (index == 2) 
+// Bit[31:29] Reserved
+// Bit[28:20] Drange
+// Bit[19:16] bin_count_4
+// Bit[15:13] Reserved
+// Bit[12:6] context_mem_do
+// Bit[5:3] coeff_state
+// Bit[2:0] mvd_state
+// h264_mv_present -- (index == 3) 
+// Bit[31:16] mv_present_l0
+// Bit[15:0] mv_present_l1
+// h264_mv_cal_info_0 -- (index == 4) 
+// [31:28] mv_cal_state
+// [27:24] direct_spatial_cnt
+// Bit[23:21] Reserved
+// Bit[20] mv_UR_ready_for_mv_cal
+// Bit[19] co_mb_mem_ready_for_mv_cal
+// Bit[18] mc_dblk_cmd_if_busy
+// Bit[17] h264_co_mb_wr_busy
+// Bit[16] H264_cbp_blk_ready
+// Bit[15] mc_hcmd_rrdy
+// Bit[14] mc_hcmd_srdy
+// Bit[13] mc_cmd_if_ready
+// Bit[12] mc_hcmd_mv_available
+// Bit[11:8] mc_cmd_if_state
+// Bit[7] dblk_hcmd_rrdy
+// Bit[6] dblk_hcmd_srdy
+// Bit[5] dblk_cmd_if_ready
+// Bit[4] dblk_hcmd_mv_available
+// Bit[3:0] dblk_cmd_if_state
+// h264_mv_cal_info_1 -- (index == 5) 
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l0
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l0
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l0
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l0
+// h264_mv_cal_info_2 -- (index == 6) 
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l1
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l1
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l1
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l1
+// h264_co_mb_info -- (index == 7)
+// Bit[31:26] Reserved
+// Bit[25] mv_scale_cal_busy
+// Bit[24:20] co_mv_count
+// Bit[19:16] co_mv_process_state
+// Bit[15] h264_co_mb_rd_busy
+// Bit[15] h264_co_mb_rd_ready
+// Bit[13:12] co_mv_transfer_block_cnt
+// Bit[11:8] co_mv_transfer_ptr
+// Bit[7] co_mv_POC_l1_busy
+// Bit[6] h264_weight_scale_cal_en
+// Bit[5] weight_cal_busy
+// Bit[4] weight_cal_not_finished
+// Bit[3:0] weight_process_state
+#define VDEC2_VLD_DBG_DATA                         ((0x2c3f  << 2) + 0xd0050000)
+// --------------------------------------------
+// VIFIFO DDR Interface
+// --------------------------------------------
+// The VIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define VDEC2_VLD_MEM_VIFIFO_START_PTR             ((0x2c40  << 2) + 0xd0050000)
+// The current pointer points so some location between the START and END 
+// pointers.  The current pointer is a BYTE pointer.  That is, you can 
+// point to any BYTE address within the START/END range
+#define VDEC2_VLD_MEM_VIFIFO_CURR_PTR              ((0x2c41  << 2) + 0xd0050000)
+#define VDEC2_VLD_MEM_VIFIFO_END_PTR               ((0x2c42  << 2) + 0xd0050000)
+#define VDEC2_VLD_MEM_VIFIFO_BYTES_AVAIL           ((0x2c43  << 2) + 0xd0050000)
+// VIFIFO FIFO Control
+// bit  [31:24] viff_empty_int_enable_cpu[7:0] 
+// bit  [23:16] viff_empty_int_enable_amrisc[7:0] 
+//   -bit 23 Video BUFFER < 0x400 Bytes
+//   -bit 22 Video BUFFER < 0x200 Bytes
+//   -bit 21 Video BUFFER < 0x100 Bytes
+//   -bit 20 Video BUFFER < 0x80 Bytes
+//   -bit 19 Video BUFFER < 0x40 Bytes
+//   -bit 18 Video BUFFER < 0x20 Bytes
+//   -bit 17 vififo  < 16 double words
+//   -bit 16 vififo  < 8 double words
+// bit  [15:13] unused
+// bit  [12]    A_urgent
+// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     init_with_cntl_init
+// bit  [6]     reserved
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define VDEC2_VLD_MEM_VIFIFO_CONTROL               ((0x2c44  << 2) + 0xd0050000)
+// --------------------------------------------
+// VIFIFO Buffer Level Manager
+// --------------------------------------------
+#define VDEC2_VLD_MEM_VIFIFO_WP                    ((0x2c45  << 2) + 0xd0050000)
+#define VDEC2_VLD_MEM_VIFIFO_RP                    ((0x2c46  << 2) + 0xd0050000)
+#define VDEC2_VLD_MEM_VIFIFO_LEVEL                 ((0x2c47  << 2) + 0xd0050000)
+//
+// bit  [8]     use_parser_video2_wp
+// bit  [7]     vbuf2_out_manual
+// bit  [6]     vbuf_out_manual
+// bit  [5]     empty (ReadOnly)
+// bit  [4]     full (ReadOnly)
+// bit  [3:2]   reserved
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define VDEC2_VLD_MEM_VIFIFO_BUF_CNTL              ((0x2c48  << 2) + 0xd0050000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define VDEC2_VLD_TIME_STAMP_CNTL                  ((0x2c49  << 2) + 0xd0050000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define VDEC2_VLD_TIME_STAMP_SYNC_0                ((0x2c4a  << 2) + 0xd0050000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
+#define VDEC2_VLD_TIME_STAMP_SYNC_1                ((0x2c4b  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_0
+#define VDEC2_VLD_TIME_STAMP_0                     ((0x2c4c  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_1
+#define VDEC2_VLD_TIME_STAMP_1                     ((0x2c4d  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_2
+#define VDEC2_VLD_TIME_STAMP_2                     ((0x2c4e  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_3
+#define VDEC2_VLD_TIME_STAMP_3                     ((0x2c4f  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define VDEC2_VLD_TIME_STAMP_LENGTH                ((0x2c50  << 2) + 0xd0050000)
+// bit 15:0 vififo_rd_count
+#define VDEC2_VLD_MEM_VIFIFO_WRAP_COUNT            ((0x2c51  << 2) + 0xd0050000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold 
+#define VDEC2_VLD_MEM_VIFIFO_MEM_CTL               ((0x2c52  << 2) + 0xd0050000)
+#define VDEC2_VLD_MEM_VBUF_RD_PTR                  ((0x2c53  << 2) + 0xd0050000)
+#define VDEC2_VLD_MEM_VBUF2_RD_PTR                 ((0x2c54  << 2) + 0xd0050000)
+#define VDEC2_VLD_MEM_SWAP_ADDR                    ((0x2c55  << 2) + 0xd0050000)
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only)
+// bit [7] - swap busy (Read Only)
+// bit [6:2] - reserved
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define VDEC2_VLD_MEM_SWAP_CTL                     ((0x2c56  << 2) + 0xd0050000)
+//
+// Closing file:  vld_regs.h
+//
+//
+// Reading file:  vld_regs.h
+//
+//========================================================================
+//  VLD module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VLD_CBUS_BASE = 0x0c
+// -----------------------------------------------
+#define HEVC_VLD_STATUS_CTRL                       ((0x3c00  << 2) + 0xd0050000)
+//
+// bit 10 -- use_old_shift_en
+// bit 9 -- output_mv_not_pmv
+// bit 8:5 -- force_zigzag
+// bit 4 -- force_zigzag_en
+// bit 3 -- disable_viff_anempty_int
+// bit 2 -- disable_m2_ac_coeff_one_cycle
+// bit 1 -- forced_reset  force reset pmv
+// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
+#define HEVC_MPEG1_2_REG                           ((0x3c01  << 2) + 0xd0050000)
+#define HEVC_F_CODE_REG                            ((0x3c02  << 2) + 0xd0050000)
+#define HEVC_PIC_HEAD_INFO                         ((0x3c03  << 2) + 0xd0050000)
+#define HEVC_SLICE_VER_POS_PIC_TYPE                ((0x3c04  << 2) + 0xd0050000)
+#define HEVC_QP_VALUE_REG                          ((0x3c05  << 2) + 0xd0050000)
+#define HEVC_MBA_INC                               ((0x3c06  << 2) + 0xd0050000)
+#define HEVC_MB_MOTION_MODE                        ((0x3c07  << 2) + 0xd0050000)
+//`define PACKET_BYTE_COUNT   8'h08
+// bit 15 -- force_search_startcode_en
+// bit 14 -- int_cpu_when_error (before do anything)
+// bit 13 -- vld_error_reset
+// bit 12 -- return_on_slice_header
+// bit 6 -- jpeg_ff00_en 
+// bit 5:0 -- vld_power_ctl
+#define HEVC_POWER_CTL_VLD                         ((0x3c08  << 2) + 0xd0050000)
+#define HEVC_MB_WIDTH                              ((0x3c09  << 2) + 0xd0050000)
+#define HEVC_SLICE_QP                              ((0x3c0a  << 2) + 0xd0050000)
+// `define MB_X_MB_Y           8'h0b   /* current MBX and MBY                  */
+#define HEVC_PRE_START_CODE                        ((0x3c0b  << 2) + 0xd0050000)
+#define HEVC_SLICE_START_BYTE_01                   ((0x3c0c  << 2) + 0xd0050000)
+#define HEVC_SLICE_START_BYTE_23                   ((0x3c0d  << 2) + 0xd0050000)
+#define HEVC_RESYNC_MARKER_LENGTH                  ((0x3c0e  << 2) + 0xd0050000)
+// bit[6:5] - frame/field info, 01 - top, 10 - bottom, 11 - frame
+// bit[4:0] - buffer ID
+// L0_BUFF_ID_0, L0_BUFF_ID_1, L1_BUFF_ID_0, L1_BUFF_ID_1
+#define HEVC_DECODER_BUFFER_INFO                   ((0x3c0f  << 2) + 0xd0050000)
+#define HEVC_FST_FOR_MV_X                          ((0x3c10  << 2) + 0xd0050000)
+#define HEVC_FST_FOR_MV_Y                          ((0x3c11  << 2) + 0xd0050000)
+#define HEVC_SCD_FOR_MV_X                          ((0x3c12  << 2) + 0xd0050000)
+#define HEVC_SCD_FOR_MV_Y                          ((0x3c13  << 2) + 0xd0050000)
+#define HEVC_FST_BAK_MV_X                          ((0x3c14  << 2) + 0xd0050000)
+#define HEVC_FST_BAK_MV_Y                          ((0x3c15  << 2) + 0xd0050000)
+#define HEVC_SCD_BAK_MV_X                          ((0x3c16  << 2) + 0xd0050000)
+#define HEVC_SCD_BAK_MV_Y                          ((0x3c17  << 2) + 0xd0050000)
+// Bit 7:4 -- read_buffer_interlace  0-progressive, 1-interlace, used in VC1
+// bit 3 -- reserved
+// bit 2 -- weighting_prediction
+// bit 1 -- mb_weighting_flag
+// bit 0 -- slice_weighting_flag 
+#define HEVC_VLD_DECODE_CONTROL                    ((0x3c18  << 2) + 0xd0050000)
+#define HEVC_VLD_REVERVED_19                       ((0x3c19  << 2) + 0xd0050000)
+#define HEVC_VIFF_BIT_CNT                          ((0x3c1a  << 2) + 0xd0050000)
+#define HEVC_BYTE_ALIGN_PEAK_HI                    ((0x3c1b  << 2) + 0xd0050000)
+#define HEVC_BYTE_ALIGN_PEAK_LO                    ((0x3c1c  << 2) + 0xd0050000)
+#define HEVC_NEXT_ALIGN_PEAK                       ((0x3c1d  << 2) + 0xd0050000)
+// bit 19    : vc1_inv_intra_co_mb_ref_rd
+// bit 18    : vc1_inv_co_mb_ref_rd
+// bit 17    : vc1_inv_intra_co_mb_ref_wr
+// bit 16    : vc1_inv_co_mb_ref_wr
+// bit 15    : reserved
+// bit 14    : avs_drop_enable
+// bit 13:12 : avs_drop_ptr
+// bit 11:8  : avs_demu_ctl_reg
+// bit 7 : avs_enable
+// bit 6 : disable_dblk_hcmd
+// bit 5 : disable_mc_hcmd
+// bit 4 : first_mode3_set enable
+// bit 3 : first_mode3
+// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
+// bit 0   : vc1_enable
+#define HEVC_VC1_CONTROL_REG                       ((0x3c1e  << 2) + 0xd0050000)
+#define HEVC_PMV1_X                                ((0x3c20  << 2) + 0xd0050000)
+#define HEVC_PMV1_Y                                ((0x3c21  << 2) + 0xd0050000)
+#define HEVC_PMV2_X                                ((0x3c22  << 2) + 0xd0050000)
+#define HEVC_PMV2_Y                                ((0x3c23  << 2) + 0xd0050000)
+#define HEVC_PMV3_X                                ((0x3c24  << 2) + 0xd0050000)
+#define HEVC_PMV3_Y                                ((0x3c25  << 2) + 0xd0050000)
+#define HEVC_PMV4_X                                ((0x3c26  << 2) + 0xd0050000)
+#define HEVC_PMV4_Y                                ((0x3c27  << 2) + 0xd0050000)
+// Can't use the same address for different defines
+// Therefore, create a single define that covers both
+// Only appears to be used in micro-code since the VLD hardware is 
+// hard coded.
+// `define M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+// `define M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
+#define HEVC_M4_TABLE_SELECT                       ((0x3c28  << 2) + 0xd0050000)
+#define HEVC_M4_CONTROL_REG                        ((0x3c29  << 2) + 0xd0050000)
+#define HEVC_BLOCK_NUM                             ((0x3c2a  << 2) + 0xd0050000)
+#define HEVC_PATTERN_CODE                          ((0x3c2b  << 2) + 0xd0050000)
+#define HEVC_MB_INFO                               ((0x3c2c  << 2) + 0xd0050000)
+#define HEVC_VLD_DC_PRED                           ((0x3c2d  << 2) + 0xd0050000)
+#define HEVC_VLD_ERROR_MASK                        ((0x3c2e  << 2) + 0xd0050000)
+#define HEVC_VLD_DC_PRED_C                         ((0x3c2f  << 2) + 0xd0050000)
+#define HEVC_LAST_SLICE_MV_ADDR                    ((0x3c30  << 2) + 0xd0050000)
+#define HEVC_LAST_MVX                              ((0x3c31  << 2) + 0xd0050000)
+#define HEVC_LAST_MVY                              ((0x3c32  << 2) + 0xd0050000)
+#define HEVC_VLD_C38                               ((0x3c38  << 2) + 0xd0050000)
+#define HEVC_VLD_C39                               ((0x3c39  << 2) + 0xd0050000)
+#define HEVC_VLD_STATUS                            ((0x3c3a  << 2) + 0xd0050000)
+#define HEVC_VLD_SHIFT_STATUS                      ((0x3c3b  << 2) + 0xd0050000)
+// `define VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
+#define HEVC_VOFF_STATUS                           ((0x3c3c  << 2) + 0xd0050000)
+#define HEVC_VLD_C3D                               ((0x3c3d  << 2) + 0xd0050000)
+#define HEVC_VLD_DBG_INDEX                         ((0x3c3e  << 2) + 0xd0050000)
+// vld_buff_info -- (index == 0) 
+// Bit[7:6]  mv_UR_ready_cnt;
+// Bit[5]  vld_wr_idx
+// Bit[4]  iq_rd_idx
+// Bit[3]  vld_vi_block_rdy_1
+// Bit[2]  vld_vi_block_rdy_2
+// Bit[1]  voff_empty_1
+// Bit[0]  voff_empty_2
+// cabac_buff_info_0 -- (index == 1) 
+// Bit[31] shift_data_ready
+// Bit[30:29] Reserved
+// Bit[28:24] cabac_buffer_ptr
+// Bit[23:0] cabac_buffer
+// cabac_buff_info_1 -- (index == 2) 
+// Bit[31:29] Reserved
+// Bit[28:20] Drange
+// Bit[19:16] bin_count_4
+// Bit[15:13] Reserved
+// Bit[12:6] context_mem_do
+// Bit[5:3] coeff_state
+// Bit[2:0] mvd_state
+// h264_mv_present -- (index == 3) 
+// Bit[31:16] mv_present_l0
+// Bit[15:0] mv_present_l1
+// h264_mv_cal_info_0 -- (index == 4) 
+// [31:28] mv_cal_state
+// [27:24] direct_spatial_cnt
+// Bit[23:21] Reserved
+// Bit[20] mv_UR_ready_for_mv_cal
+// Bit[19] co_mb_mem_ready_for_mv_cal
+// Bit[18] mc_dblk_cmd_if_busy
+// Bit[17] h264_co_mb_wr_busy
+// Bit[16] H264_cbp_blk_ready
+// Bit[15] mc_hcmd_rrdy
+// Bit[14] mc_hcmd_srdy
+// Bit[13] mc_cmd_if_ready
+// Bit[12] mc_hcmd_mv_available
+// Bit[11:8] mc_cmd_if_state
+// Bit[7] dblk_hcmd_rrdy
+// Bit[6] dblk_hcmd_srdy
+// Bit[5] dblk_cmd_if_ready
+// Bit[4] dblk_hcmd_mv_available
+// Bit[3:0] dblk_cmd_if_state
+// h264_mv_cal_info_1 -- (index == 5) 
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l0
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l0
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l0
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l0
+// h264_mv_cal_info_2 -- (index == 6) 
+//  Bit[31:29] Reserved
+//  Bit[28:24] total_mvd_num_l1
+//  Bit[23:21] Reserved
+//  Bit[20:16] mv_cal_ptr_l1
+//  Bit[15:13] Reserved
+//  Bit[12:8] mc_hcmd_ptr_l1
+//  Bit[7:5] Reserved
+//  Bit[4:0] dblk_hcmd_ptr_l1
+// h264_co_mb_info -- (index == 7)
+// Bit[31:26] Reserved
+// Bit[25] mv_scale_cal_busy
+// Bit[24:20] co_mv_count
+// Bit[19:16] co_mv_process_state
+// Bit[15] h264_co_mb_rd_busy
+// Bit[15] h264_co_mb_rd_ready
+// Bit[13:12] co_mv_transfer_block_cnt
+// Bit[11:8] co_mv_transfer_ptr
+// Bit[7] co_mv_POC_l1_busy
+// Bit[6] h264_weight_scale_cal_en
+// Bit[5] weight_cal_busy
+// Bit[4] weight_cal_not_finished
+// Bit[3:0] weight_process_state
+#define HEVC_VLD_DBG_DATA                          ((0x3c3f  << 2) + 0xd0050000)
+// --------------------------------------------
+// VIFIFO DDR Interface
+// --------------------------------------------
+// The VIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define HEVC_VLD_MEM_VIFIFO_START_PTR              ((0x3c40  << 2) + 0xd0050000)
+// The current pointer points so some location between the START and END 
+// pointers.  The current pointer is a BYTE pointer.  That is, you can 
+// point to any BYTE address within the START/END range
+#define HEVC_VLD_MEM_VIFIFO_CURR_PTR               ((0x3c41  << 2) + 0xd0050000)
+#define HEVC_VLD_MEM_VIFIFO_END_PTR                ((0x3c42  << 2) + 0xd0050000)
+#define HEVC_VLD_MEM_VIFIFO_BYTES_AVAIL            ((0x3c43  << 2) + 0xd0050000)
+// VIFIFO FIFO Control
+// bit  [31:24] viff_empty_int_enable_cpu[7:0] 
+// bit  [23:16] viff_empty_int_enable_amrisc[7:0] 
+//   -bit 23 Video BUFFER < 0x400 Bytes
+//   -bit 22 Video BUFFER < 0x200 Bytes
+//   -bit 21 Video BUFFER < 0x100 Bytes
+//   -bit 20 Video BUFFER < 0x80 Bytes
+//   -bit 19 Video BUFFER < 0x40 Bytes
+//   -bit 18 Video BUFFER < 0x20 Bytes
+//   -bit 17 vififo  < 16 double words
+//   -bit 16 vififo  < 8 double words
+// bit  [15:13] unused
+// bit  [12]    A_urgent
+// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     init_with_cntl_init
+// bit  [6]     reserved
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define HEVC_VLD_MEM_VIFIFO_CONTROL                ((0x3c44  << 2) + 0xd0050000)
+// --------------------------------------------
+// VIFIFO Buffer Level Manager
+// --------------------------------------------
+#define HEVC_VLD_MEM_VIFIFO_WP                     ((0x3c45  << 2) + 0xd0050000)
+#define HEVC_VLD_MEM_VIFIFO_RP                     ((0x3c46  << 2) + 0xd0050000)
+#define HEVC_VLD_MEM_VIFIFO_LEVEL                  ((0x3c47  << 2) + 0xd0050000)
+//
+// bit  [8]     use_parser_video2_wp
+// bit  [7]     vbuf2_out_manual
+// bit  [6]     vbuf_out_manual
+// bit  [5]     empty (ReadOnly)
+// bit  [4]     full (ReadOnly)
+// bit  [3:2]   reserved
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define HEVC_VLD_MEM_VIFIFO_BUF_CNTL               ((0x3c48  << 2) + 0xd0050000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define HEVC_VLD_TIME_STAMP_CNTL                   ((0x3c49  << 2) + 0xd0050000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define HEVC_VLD_TIME_STAMP_SYNC_0                 ((0x3c4a  << 2) + 0xd0050000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
+#define HEVC_VLD_TIME_STAMP_SYNC_1                 ((0x3c4b  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_0
+#define HEVC_VLD_TIME_STAMP_0                      ((0x3c4c  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_1
+#define HEVC_VLD_TIME_STAMP_1                      ((0x3c4d  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_2
+#define HEVC_VLD_TIME_STAMP_2                      ((0x3c4e  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_3
+#define HEVC_VLD_TIME_STAMP_3                      ((0x3c4f  << 2) + 0xd0050000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define HEVC_VLD_TIME_STAMP_LENGTH                 ((0x3c50  << 2) + 0xd0050000)
+// bit 15:0 vififo_rd_count
+#define HEVC_VLD_MEM_VIFIFO_WRAP_COUNT             ((0x3c51  << 2) + 0xd0050000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold 
+#define HEVC_VLD_MEM_VIFIFO_MEM_CTL                ((0x3c52  << 2) + 0xd0050000)
+#define HEVC_VLD_MEM_VBUF_RD_PTR                   ((0x3c53  << 2) + 0xd0050000)
+#define HEVC_VLD_MEM_VBUF2_RD_PTR                  ((0x3c54  << 2) + 0xd0050000)
+#define HEVC_VLD_MEM_SWAP_ADDR                     ((0x3c55  << 2) + 0xd0050000)
+// bit[23:16] - swap_d_count (Read Only)
+// bit[15:8]  - swap_a_count (Read Only)
+// bit [7] - swap busy (Read Only)
+// bit [6:2] - reserved
+// bit [1] - 1 - STORE to Memory, 0 - LOAD from Memory
+// bit [0] - swap active
+#define HEVC_VLD_MEM_SWAP_CTL                      ((0x3c56  << 2) + 0xd0050000)
+//
+// Closing file:  vld_regs.h
+//
+//
+// Reading file:  iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+#define HCODEC_VCOP_CTRL_REG                       ((0x1e00  << 2) + 0xd0050000)
+#define HCODEC_QP_CTRL_REG                         ((0x1e01  << 2) + 0xd0050000)
+#define HCODEC_INTRA_QUANT_MATRIX                  ((0x1e02  << 2) + 0xd0050000)
+#define HCODEC_NON_I_QUANT_MATRIX                  ((0x1e03  << 2) + 0xd0050000)
+#define HCODEC_DC_SCALER                           ((0x1e04  << 2) + 0xd0050000)
+#define HCODEC_DC_AC_CTRL                          ((0x1e05  << 2) + 0xd0050000)
+// `define RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+#define HCODEC_DC_AC_SCALE_MUL                     ((0x1e06  << 2) + 0xd0050000)
+#define HCODEC_DC_AC_SCALE_DIV                     ((0x1e07  << 2) + 0xd0050000)
+// `define DC_AC_SCALE_RESULT  8'h06
+// `define RESERVED_E07        8'h07
+#define HCODEC_POWER_CTL_IQIDCT                    ((0x1e08  << 2) + 0xd0050000)
+#define HCODEC_RV_AI_Y_X                           ((0x1e09  << 2) + 0xd0050000)
+#define HCODEC_RV_AI_U_X                           ((0x1e0a  << 2) + 0xd0050000)
+#define HCODEC_RV_AI_V_X                           ((0x1e0b  << 2) + 0xd0050000)
+// bit 15:0 will count up when rv_ai_mb finished when non zero
+// and rv_ai_mb_finished_int will be generate when this is not zero
+#define HCODEC_RV_AI_MB_COUNT                      ((0x1e0c  << 2) + 0xd0050000)
+// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+#define HCODEC_NEXT_INTRA_DMA_ADDRESS              ((0x1e0d  << 2) + 0xd0050000)
+// Bit 0 -- constrained_intra_pred_flag for H264
+#define HCODEC_IQIDCT_CONTROL                      ((0x1e0e  << 2) + 0xd0050000)
+// Bit[31:19] Reserved
+// Bit[18] iq_waiting
+// Bit[17] iq_om_wr_idx
+// Bit[16] iq_om_rd_idx
+// Bit[15] iq_om_busy
+// Bit[14] iq_om_2_busy 
+// Bit[13] idx_fifo_0
+// Bit[12] idx_fifo_1
+// Bit[11] idx_fifo_2
+// Bit[10] idx_fifo_3
+// Bit[9] idx_fifo_4
+// Bit[8] idx_fifo_5
+// Bit[7] idx_fifo_6
+// Bit[6] idx_fifo_7
+// Bit[5:3] idx_fifo_wp
+// Bit[2:0] idx_fifo_rp
+#define HCODEC_IQIDCT_DEBUG_INFO_0                 ((0x1e0f  << 2) + 0xd0050000)
+// For RTL Simulation Only
+#define HCODEC_DEBLK_CMD                           ((0x1e10  << 2) + 0xd0050000)
+// Bit[15+16] ds_mc_valid_2
+// Bit[14+16] new_idct1_rd_idx_2
+// Bit[13+16] new_idct1_wr_idx_2
+// Bit[12+16] idct1_buff0_busy_2
+// Bit[11+16] idct1_buff1_busy_2
+// Bit[10+16] new_idct1_busy_2
+// Bit[9+16] iq_om_8val_2
+// Bit[8+16] idct1_pipe_busy_2
+// Bit[7+16] wait_mb_left_finish_hold_2
+// Bit[6+16] new_idct2_rd_idx_2
+// Bit[5+16] new_idct2_wr_idx_2
+// Bit[4+16] idct2_buff0_busy_2
+// Bit[3+16] idct2_buff1_busy_2
+// Bit[2+16] idct2_en_2
+// Bit[1+16] new_idct2_busy_2
+// Bit[0+16] new_idct1_ready_2
+// Bit[15] ds_mc_valid_1
+// Bit[14] new_idct1_rd_idx_1
+// Bit[13] new_idct1_wr_idx_1
+// Bit[12] idct1_buff0_busy_1
+// Bit[11] idct1_buff1_busy_1
+// Bit[10] new_idct1_busy_1
+// Bit[9] iq_om_8val_1
+// Bit[8] idct1_pipe_busy_1
+// Bit[7] wait_mb_left_finish_hold_1
+// Bit[6] new_idct2_rd_idx_1
+// Bit[5] new_idct2_wr_idx_1
+// Bit[4] idct2_buff0_busy_1
+// Bit[3] idct2_buff1_busy_1
+// Bit[2] idct2_en_1
+// Bit[1] new_idct2_busy_1
+// Bit[0] new_idct1_ready_1
+#define HCODEC_IQIDCT_DEBUG_IDCT                   ((0x1e11  << 2) + 0xd0050000)
+// bit 31 -- convas_enable
+// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+// bit 23:16 -- convas_y_count
+// bit 15   -- dcac_dma_busy
+// bit 14   -- dcac_dma_urgent
+// bit 13:8 -- dcac_dma_count
+// bit 7    -- dcac_dma_rw
+// bit 6    -- dcac_skip_read_mode
+// bit 5:0  -- dcac_dma_offset
+#define HCODEC_DCAC_DMA_CTRL                       ((0x1e12  << 2) + 0xd0050000)
+// when (convas_enable == 0 )
+//   bit 31:0 dcac_dma_addr
+// when (convas_enable == 1 )
+//   bit 31:25 canvas_addr (7 bits)
+//   bit 24:12 convas_y_start ( 13 btis )
+//   bit 11:0  convas_x_start ( 12 btis )
+#define HCODEC_DCAC_DMA_ADDRESS                    ((0x1e13  << 2) + 0xd0050000)
+// bit 7:0 -- dcac_cpu_addr
+#define HCODEC_DCAC_CPU_ADDRESS                    ((0x1e14  << 2) + 0xd0050000)
+// bit 31:0 -- dcac_cpu_data
+#define HCODEC_DCAC_CPU_DATA                       ((0x1e15  << 2) + 0xd0050000)
+// bit 31:19 -- reserved
+// bit 18:16 -- block_num_reg -- Read-Only 
+// bit 15:0 -- dcac_mb_count
+#define HCODEC_DCAC_MB_COUNT                       ((0x1e16  << 2) + 0xd0050000)
+// bit 31:18 -- reserved
+// For H264 :
+//   bit 17:2 -- h264_quant 
+//   bit 11:6 -- h264_quant_c 
+//   bit  5:0 -- h264_quant_c 
+// For VC1 :
+//   bit    17 -- qindex_GT_8
+//   bit    16 -- HalfQPStep
+//   bit 15:12 -- eQuantMode 
+//   bit 11:6  -- AltPQuant 
+//   bit  5:0  -- PQuant 
+//             
+#define HCODEC_IQ_QUANT                            ((0x1e17  << 2) + 0xd0050000)
+// bit 31:24  -- bitplane_width 
+// bit 23:16  -- bitplane_height 
+// bit 15:14  -- bitplane_start_x 
+// bit 13:12  -- bitplane_start_y 
+// bit 11:4   -- reserved
+// bit 3:1    -- bitplane_type
+// bit 0      -- bitplane_busy
+#define HCODEC_VC1_BITPLANE_CTL                    ((0x1e18  << 2) + 0xd0050000)
+//======================================
+//  VCOP Control Register Bits
+//
+//======================================
+    //`define IQIDCT_RESET	    16'h0001	    // Bit 0
+//======================================
+//  QP Control Register Bits
+//
+//======================================
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+// Closing file:  iqidct_regs.h
+//
+//
+// Reading file:  iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+#define VDEC2_VCOP_CTRL_REG                        ((0x2e00  << 2) + 0xd0050000)
+#define VDEC2_QP_CTRL_REG                          ((0x2e01  << 2) + 0xd0050000)
+#define VDEC2_INTRA_QUANT_MATRIX                   ((0x2e02  << 2) + 0xd0050000)
+#define VDEC2_NON_I_QUANT_MATRIX                   ((0x2e03  << 2) + 0xd0050000)
+#define VDEC2_DC_SCALER                            ((0x2e04  << 2) + 0xd0050000)
+#define VDEC2_DC_AC_CTRL                           ((0x2e05  << 2) + 0xd0050000)
+// `define RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+#define VDEC2_DC_AC_SCALE_MUL                      ((0x2e06  << 2) + 0xd0050000)
+#define VDEC2_DC_AC_SCALE_DIV                      ((0x2e07  << 2) + 0xd0050000)
+// `define DC_AC_SCALE_RESULT  8'h06
+// `define RESERVED_E07        8'h07
+#define VDEC2_POWER_CTL_IQIDCT                     ((0x2e08  << 2) + 0xd0050000)
+#define VDEC2_RV_AI_Y_X                            ((0x2e09  << 2) + 0xd0050000)
+#define VDEC2_RV_AI_U_X                            ((0x2e0a  << 2) + 0xd0050000)
+#define VDEC2_RV_AI_V_X                            ((0x2e0b  << 2) + 0xd0050000)
+// bit 15:0 will count up when rv_ai_mb finished when non zero
+// and rv_ai_mb_finished_int will be generate when this is not zero
+#define VDEC2_RV_AI_MB_COUNT                       ((0x2e0c  << 2) + 0xd0050000)
+// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+#define VDEC2_NEXT_INTRA_DMA_ADDRESS               ((0x2e0d  << 2) + 0xd0050000)
+// Bit 0 -- constrained_intra_pred_flag for H264
+#define VDEC2_IQIDCT_CONTROL                       ((0x2e0e  << 2) + 0xd0050000)
+// Bit[31:19] Reserved
+// Bit[18] iq_waiting
+// Bit[17] iq_om_wr_idx
+// Bit[16] iq_om_rd_idx
+// Bit[15] iq_om_busy
+// Bit[14] iq_om_2_busy 
+// Bit[13] idx_fifo_0
+// Bit[12] idx_fifo_1
+// Bit[11] idx_fifo_2
+// Bit[10] idx_fifo_3
+// Bit[9] idx_fifo_4
+// Bit[8] idx_fifo_5
+// Bit[7] idx_fifo_6
+// Bit[6] idx_fifo_7
+// Bit[5:3] idx_fifo_wp
+// Bit[2:0] idx_fifo_rp
+#define VDEC2_IQIDCT_DEBUG_INFO_0                  ((0x2e0f  << 2) + 0xd0050000)
+// For RTL Simulation Only
+#define VDEC2_DEBLK_CMD                            ((0x2e10  << 2) + 0xd0050000)
+// Bit[15+16] ds_mc_valid_2
+// Bit[14+16] new_idct1_rd_idx_2
+// Bit[13+16] new_idct1_wr_idx_2
+// Bit[12+16] idct1_buff0_busy_2
+// Bit[11+16] idct1_buff1_busy_2
+// Bit[10+16] new_idct1_busy_2
+// Bit[9+16] iq_om_8val_2
+// Bit[8+16] idct1_pipe_busy_2
+// Bit[7+16] wait_mb_left_finish_hold_2
+// Bit[6+16] new_idct2_rd_idx_2
+// Bit[5+16] new_idct2_wr_idx_2
+// Bit[4+16] idct2_buff0_busy_2
+// Bit[3+16] idct2_buff1_busy_2
+// Bit[2+16] idct2_en_2
+// Bit[1+16] new_idct2_busy_2
+// Bit[0+16] new_idct1_ready_2
+// Bit[15] ds_mc_valid_1
+// Bit[14] new_idct1_rd_idx_1
+// Bit[13] new_idct1_wr_idx_1
+// Bit[12] idct1_buff0_busy_1
+// Bit[11] idct1_buff1_busy_1
+// Bit[10] new_idct1_busy_1
+// Bit[9] iq_om_8val_1
+// Bit[8] idct1_pipe_busy_1
+// Bit[7] wait_mb_left_finish_hold_1
+// Bit[6] new_idct2_rd_idx_1
+// Bit[5] new_idct2_wr_idx_1
+// Bit[4] idct2_buff0_busy_1
+// Bit[3] idct2_buff1_busy_1
+// Bit[2] idct2_en_1
+// Bit[1] new_idct2_busy_1
+// Bit[0] new_idct1_ready_1
+#define VDEC2_IQIDCT_DEBUG_IDCT                    ((0x2e11  << 2) + 0xd0050000)
+// bit 31 -- convas_enable
+// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+// bit 23:16 -- convas_y_count
+// bit 15   -- dcac_dma_busy
+// bit 14   -- dcac_dma_urgent
+// bit 13:8 -- dcac_dma_count
+// bit 7    -- dcac_dma_rw
+// bit 6    -- dcac_skip_read_mode
+// bit 5:0  -- dcac_dma_offset
+#define VDEC2_DCAC_DMA_CTRL                        ((0x2e12  << 2) + 0xd0050000)
+// when (convas_enable == 0 )
+//   bit 31:0 dcac_dma_addr
+// when (convas_enable == 1 )
+//   bit 31:25 canvas_addr (7 bits)
+//   bit 24:12 convas_y_start ( 13 btis )
+//   bit 11:0  convas_x_start ( 12 btis )
+#define VDEC2_DCAC_DMA_ADDRESS                     ((0x2e13  << 2) + 0xd0050000)
+// bit 7:0 -- dcac_cpu_addr
+#define VDEC2_DCAC_CPU_ADDRESS                     ((0x2e14  << 2) + 0xd0050000)
+// bit 31:0 -- dcac_cpu_data
+#define VDEC2_DCAC_CPU_DATA                        ((0x2e15  << 2) + 0xd0050000)
+// bit 31:19 -- reserved
+// bit 18:16 -- block_num_reg -- Read-Only 
+// bit 15:0 -- dcac_mb_count
+#define VDEC2_DCAC_MB_COUNT                        ((0x2e16  << 2) + 0xd0050000)
+// bit 31:18 -- reserved
+// For H264 :
+//   bit 17:2 -- h264_quant 
+//   bit 11:6 -- h264_quant_c 
+//   bit  5:0 -- h264_quant_c 
+// For VC1 :
+//   bit    17 -- qindex_GT_8
+//   bit    16 -- HalfQPStep
+//   bit 15:12 -- eQuantMode 
+//   bit 11:6  -- AltPQuant 
+//   bit  5:0  -- PQuant 
+//             
+#define VDEC2_IQ_QUANT                             ((0x2e17  << 2) + 0xd0050000)
+// bit 31:24  -- bitplane_width 
+// bit 23:16  -- bitplane_height 
+// bit 15:14  -- bitplane_start_x 
+// bit 13:12  -- bitplane_start_y 
+// bit 11:4   -- reserved
+// bit 3:1    -- bitplane_type
+// bit 0      -- bitplane_busy
+#define VDEC2_VC1_BITPLANE_CTL                     ((0x2e18  << 2) + 0xd0050000)
+//======================================
+//  VCOP Control Register Bits
+//
+//======================================
+    //`define IQIDCT_RESET	    16'h0001	    // Bit 0
+//======================================
+//  QP Control Register Bits
+//
+//======================================
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+// Closing file:  iqidct_regs.h
+//
+//
+// Reading file:  iqidct_regs.h
+//
+//========================================================================
+//  IQ/IDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_IQIDCT_CBUS_BASE = 0x0e
+// -----------------------------------------------
+#define HEVC_VCOP_CTRL_REG                         ((0x3e00  << 2) + 0xd0050000)
+#define HEVC_QP_CTRL_REG                           ((0x3e01  << 2) + 0xd0050000)
+#define HEVC_INTRA_QUANT_MATRIX                    ((0x3e02  << 2) + 0xd0050000)
+#define HEVC_NON_I_QUANT_MATRIX                    ((0x3e03  << 2) + 0xd0050000)
+#define HEVC_DC_SCALER                             ((0x3e04  << 2) + 0xd0050000)
+#define HEVC_DC_AC_CTRL                            ((0x3e05  << 2) + 0xd0050000)
+// `define RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
+#define HEVC_DC_AC_SCALE_MUL                       ((0x3e06  << 2) + 0xd0050000)
+#define HEVC_DC_AC_SCALE_DIV                       ((0x3e07  << 2) + 0xd0050000)
+// `define DC_AC_SCALE_RESULT  8'h06
+// `define RESERVED_E07        8'h07
+#define HEVC_POWER_CTL_IQIDCT                      ((0x3e08  << 2) + 0xd0050000)
+#define HEVC_RV_AI_Y_X                             ((0x3e09  << 2) + 0xd0050000)
+#define HEVC_RV_AI_U_X                             ((0x3e0a  << 2) + 0xd0050000)
+#define HEVC_RV_AI_V_X                             ((0x3e0b  << 2) + 0xd0050000)
+// bit 15:0 will count up when rv_ai_mb finished when non zero
+// and rv_ai_mb_finished_int will be generate when this is not zero
+#define HEVC_RV_AI_MB_COUNT                        ((0x3e0c  << 2) + 0xd0050000)
+// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
+#define HEVC_NEXT_INTRA_DMA_ADDRESS                ((0x3e0d  << 2) + 0xd0050000)
+// Bit 0 -- constrained_intra_pred_flag for H264
+#define HEVC_IQIDCT_CONTROL                        ((0x3e0e  << 2) + 0xd0050000)
+// Bit[31:19] Reserved
+// Bit[18] iq_waiting
+// Bit[17] iq_om_wr_idx
+// Bit[16] iq_om_rd_idx
+// Bit[15] iq_om_busy
+// Bit[14] iq_om_2_busy 
+// Bit[13] idx_fifo_0
+// Bit[12] idx_fifo_1
+// Bit[11] idx_fifo_2
+// Bit[10] idx_fifo_3
+// Bit[9] idx_fifo_4
+// Bit[8] idx_fifo_5
+// Bit[7] idx_fifo_6
+// Bit[6] idx_fifo_7
+// Bit[5:3] idx_fifo_wp
+// Bit[2:0] idx_fifo_rp
+#define HEVC_IQIDCT_DEBUG_INFO_0                   ((0x3e0f  << 2) + 0xd0050000)
+// For RTL Simulation Only
+#define HEVC_DEBLK_CMD                             ((0x3e10  << 2) + 0xd0050000)
+// Bit[15+16] ds_mc_valid_2
+// Bit[14+16] new_idct1_rd_idx_2
+// Bit[13+16] new_idct1_wr_idx_2
+// Bit[12+16] idct1_buff0_busy_2
+// Bit[11+16] idct1_buff1_busy_2
+// Bit[10+16] new_idct1_busy_2
+// Bit[9+16] iq_om_8val_2
+// Bit[8+16] idct1_pipe_busy_2
+// Bit[7+16] wait_mb_left_finish_hold_2
+// Bit[6+16] new_idct2_rd_idx_2
+// Bit[5+16] new_idct2_wr_idx_2
+// Bit[4+16] idct2_buff0_busy_2
+// Bit[3+16] idct2_buff1_busy_2
+// Bit[2+16] idct2_en_2
+// Bit[1+16] new_idct2_busy_2
+// Bit[0+16] new_idct1_ready_2
+// Bit[15] ds_mc_valid_1
+// Bit[14] new_idct1_rd_idx_1
+// Bit[13] new_idct1_wr_idx_1
+// Bit[12] idct1_buff0_busy_1
+// Bit[11] idct1_buff1_busy_1
+// Bit[10] new_idct1_busy_1
+// Bit[9] iq_om_8val_1
+// Bit[8] idct1_pipe_busy_1
+// Bit[7] wait_mb_left_finish_hold_1
+// Bit[6] new_idct2_rd_idx_1
+// Bit[5] new_idct2_wr_idx_1
+// Bit[4] idct2_buff0_busy_1
+// Bit[3] idct2_buff1_busy_1
+// Bit[2] idct2_en_1
+// Bit[1] new_idct2_busy_1
+// Bit[0] new_idct1_ready_1
+#define HEVC_IQIDCT_DEBUG_IDCT                     ((0x3e11  << 2) + 0xd0050000)
+// bit 31 -- convas_enable
+// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
+// bit 23:16 -- convas_y_count
+// bit 15   -- dcac_dma_busy
+// bit 14   -- dcac_dma_urgent
+// bit 13:8 -- dcac_dma_count
+// bit 7    -- dcac_dma_rw
+// bit 6    -- dcac_skip_read_mode
+// bit 5:0  -- dcac_dma_offset
+#define HEVC_DCAC_DMA_CTRL                         ((0x3e12  << 2) + 0xd0050000)
+// when (convas_enable == 0 )
+//   bit 31:0 dcac_dma_addr
+// when (convas_enable == 1 )
+//   bit 31:25 canvas_addr (7 bits)
+//   bit 24:12 convas_y_start ( 13 btis )
+//   bit 11:0  convas_x_start ( 12 btis )
+#define HEVC_DCAC_DMA_ADDRESS                      ((0x3e13  << 2) + 0xd0050000)
+// bit 7:0 -- dcac_cpu_addr
+#define HEVC_DCAC_CPU_ADDRESS                      ((0x3e14  << 2) + 0xd0050000)
+// bit 31:0 -- dcac_cpu_data
+#define HEVC_DCAC_CPU_DATA                         ((0x3e15  << 2) + 0xd0050000)
+// bit 31:19 -- reserved
+// bit 18:16 -- block_num_reg -- Read-Only 
+// bit 15:0 -- dcac_mb_count
+#define HEVC_DCAC_MB_COUNT                         ((0x3e16  << 2) + 0xd0050000)
+// bit 31:18 -- reserved
+// For H264 :
+//   bit 17:2 -- h264_quant 
+//   bit 11:6 -- h264_quant_c 
+//   bit  5:0 -- h264_quant_c 
+// For VC1 :
+//   bit    17 -- qindex_GT_8
+//   bit    16 -- HalfQPStep
+//   bit 15:12 -- eQuantMode 
+//   bit 11:6  -- AltPQuant 
+//   bit  5:0  -- PQuant 
+//             
+#define HEVC_IQ_QUANT                              ((0x3e17  << 2) + 0xd0050000)
+// bit 31:24  -- bitplane_width 
+// bit 23:16  -- bitplane_height 
+// bit 15:14  -- bitplane_start_x 
+// bit 13:12  -- bitplane_start_y 
+// bit 11:4   -- reserved
+// bit 3:1    -- bitplane_type
+// bit 0      -- bitplane_busy
+#define HEVC_VC1_BITPLANE_CTL                      ((0x3e18  << 2) + 0xd0050000)
+//======================================
+//  VCOP Control Register Bits
+//
+//======================================
+    //`define IQIDCT_RESET	    16'h0001	    // Bit 0
+//======================================
+//  QP Control Register Bits
+//
+//======================================
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
+//
+// Closing file:  iqidct_regs.h
+//
+//
+// Reading file:  vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+#define HCODEC_MSP                                 ((0x1300  << 2) + 0xd0050000)
+#define HCODEC_MPSR                                ((0x1301  << 2) + 0xd0050000)
+#define HCODEC_MINT_VEC_BASE                       ((0x1302  << 2) + 0xd0050000)
+#define HCODEC_MCPU_INTR_GRP                       ((0x1303  << 2) + 0xd0050000)
+#define HCODEC_MCPU_INTR_MSK                       ((0x1304  << 2) + 0xd0050000)
+#define HCODEC_MCPU_INTR_REQ                       ((0x1305  << 2) + 0xd0050000)
+#define HCODEC_MPC_P                               ((0x1306  << 2) + 0xd0050000)
+#define HCODEC_MPC_D                               ((0x1307  << 2) + 0xd0050000)
+#define HCODEC_MPC_E                               ((0x1308  << 2) + 0xd0050000)
+#define HCODEC_MPC_W                               ((0x1309  << 2) + 0xd0050000)
+#define HCODEC_MINDEX0_REG                         ((0x130a  << 2) + 0xd0050000)
+#define HCODEC_MINDEX1_REG                         ((0x130b  << 2) + 0xd0050000)
+#define HCODEC_MINDEX2_REG                         ((0x130c  << 2) + 0xd0050000)
+#define HCODEC_MINDEX3_REG                         ((0x130d  << 2) + 0xd0050000)
+#define HCODEC_MINDEX4_REG                         ((0x130e  << 2) + 0xd0050000)
+#define HCODEC_MINDEX5_REG                         ((0x130f  << 2) + 0xd0050000)
+#define HCODEC_MINDEX6_REG                         ((0x1310  << 2) + 0xd0050000)
+#define HCODEC_MINDEX7_REG                         ((0x1311  << 2) + 0xd0050000)
+#define HCODEC_MMIN_REG                            ((0x1312  << 2) + 0xd0050000)
+#define HCODEC_MMAX_REG                            ((0x1313  << 2) + 0xd0050000)
+#define HCODEC_MBREAK0_REG                         ((0x1314  << 2) + 0xd0050000)
+#define HCODEC_MBREAK1_REG                         ((0x1315  << 2) + 0xd0050000)
+#define HCODEC_MBREAK2_REG                         ((0x1316  << 2) + 0xd0050000)
+#define HCODEC_MBREAK3_REG                         ((0x1317  << 2) + 0xd0050000)
+#define HCODEC_MBREAK_TYPE                         ((0x1318  << 2) + 0xd0050000)
+#define HCODEC_MBREAK_CTRL                         ((0x1319  << 2) + 0xd0050000)
+#define HCODEC_MBREAK_STAUTS                       ((0x131a  << 2) + 0xd0050000)
+#define HCODEC_MDB_ADDR_REG                        ((0x131b  << 2) + 0xd0050000)
+#define HCODEC_MDB_DATA_REG                        ((0x131c  << 2) + 0xd0050000)
+#define HCODEC_MDB_CTRL                            ((0x131d  << 2) + 0xd0050000)
+#define HCODEC_MSFTINT0                            ((0x131e  << 2) + 0xd0050000)
+#define HCODEC_MSFTINT1                            ((0x131f  << 2) + 0xd0050000)
+#define HCODEC_CSP                                 ((0x1320  << 2) + 0xd0050000)
+#define HCODEC_CPSR                                ((0x1321  << 2) + 0xd0050000)
+#define HCODEC_CINT_VEC_BASE                       ((0x1322  << 2) + 0xd0050000)
+#define HCODEC_CCPU_INTR_GRP                       ((0x1323  << 2) + 0xd0050000)
+#define HCODEC_CCPU_INTR_MSK                       ((0x1324  << 2) + 0xd0050000)
+#define HCODEC_CCPU_INTR_REQ                       ((0x1325  << 2) + 0xd0050000)
+#define HCODEC_CPC_P                               ((0x1326  << 2) + 0xd0050000)
+#define HCODEC_CPC_D                               ((0x1327  << 2) + 0xd0050000)
+#define HCODEC_CPC_E                               ((0x1328  << 2) + 0xd0050000)
+#define HCODEC_CPC_W                               ((0x1329  << 2) + 0xd0050000)
+#define HCODEC_CINDEX0_REG                         ((0x132a  << 2) + 0xd0050000)
+#define HCODEC_CINDEX1_REG                         ((0x132b  << 2) + 0xd0050000)
+#define HCODEC_CINDEX2_REG                         ((0x132c  << 2) + 0xd0050000)
+#define HCODEC_CINDEX3_REG                         ((0x132d  << 2) + 0xd0050000)
+#define HCODEC_CINDEX4_REG                         ((0x132e  << 2) + 0xd0050000)
+#define HCODEC_CINDEX5_REG                         ((0x132f  << 2) + 0xd0050000)
+#define HCODEC_CINDEX6_REG                         ((0x1330  << 2) + 0xd0050000)
+#define HCODEC_CINDEX7_REG                         ((0x1331  << 2) + 0xd0050000)
+#define HCODEC_CMIN_REG                            ((0x1332  << 2) + 0xd0050000)
+#define HCODEC_CMAX_REG                            ((0x1333  << 2) + 0xd0050000)
+#define HCODEC_CBREAK0_REG                         ((0x1334  << 2) + 0xd0050000)
+#define HCODEC_CBREAK1_REG                         ((0x1335  << 2) + 0xd0050000)
+#define HCODEC_CBREAK2_REG                         ((0x1336  << 2) + 0xd0050000)
+#define HCODEC_CBREAK3_REG                         ((0x1337  << 2) + 0xd0050000)
+#define HCODEC_CBREAK_TYPE                         ((0x1338  << 2) + 0xd0050000)
+#define HCODEC_CBREAK_CTRL                         ((0x1339  << 2) + 0xd0050000)
+#define HCODEC_CBREAK_STAUTS                       ((0x133a  << 2) + 0xd0050000)
+#define HCODEC_CDB_ADDR_REG                        ((0x133b  << 2) + 0xd0050000)
+#define HCODEC_CDB_DATA_REG                        ((0x133c  << 2) + 0xd0050000)
+#define HCODEC_CDB_CTRL                            ((0x133d  << 2) + 0xd0050000)
+#define HCODEC_CSFTINT0                            ((0x133e  << 2) + 0xd0050000)
+#define HCODEC_CSFTINT1                            ((0x133f  << 2) + 0xd0050000)
+#define HCODEC_IMEM_DMA_CTRL                       ((0x1340  << 2) + 0xd0050000)
+#define HCODEC_IMEM_DMA_ADR                        ((0x1341  << 2) + 0xd0050000)
+#define HCODEC_IMEM_DMA_COUNT                      ((0x1342  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_imem
+// bit[21:16] A_id_imem
+// bit[11:0] wrrsp_count_imem (reserved)
+#define HCODEC_WRRSP_IMEM                          ((0x1343  << 2) + 0xd0050000)
+#define HCODEC_LMEM_DMA_CTRL                       ((0x1350  << 2) + 0xd0050000)
+#define HCODEC_LMEM_DMA_ADR                        ((0x1351  << 2) + 0xd0050000)
+#define HCODEC_LMEM_DMA_COUNT                      ((0x1352  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_lmem
+// bit[21:16] A_id_lmem
+// bit[11:0] wrrsp_count_lmem 
+#define HCODEC_WRRSP_LMEM                          ((0x1353  << 2) + 0xd0050000)
+#define HCODEC_MAC_CTRL1                           ((0x1360  << 2) + 0xd0050000)
+#define HCODEC_ACC0REG1                            ((0x1361  << 2) + 0xd0050000)
+#define HCODEC_ACC1REG1                            ((0x1362  << 2) + 0xd0050000)
+#define HCODEC_MAC_CTRL2                           ((0x1370  << 2) + 0xd0050000)
+#define HCODEC_ACC0REG2                            ((0x1371  << 2) + 0xd0050000)
+#define HCODEC_ACC1REG2                            ((0x1372  << 2) + 0xd0050000)
+#define HCODEC_CPU_TRACE                           ((0x1380  << 2) + 0xd0050000)
+//
+// Closing file:  vcpu_regs.h
+//
+//
+// Reading file:  vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+#define VDEC2_MSP                                  ((0x2300  << 2) + 0xd0050000)
+#define VDEC2_MPSR                                 ((0x2301  << 2) + 0xd0050000)
+#define VDEC2_MINT_VEC_BASE                        ((0x2302  << 2) + 0xd0050000)
+#define VDEC2_MCPU_INTR_GRP                        ((0x2303  << 2) + 0xd0050000)
+#define VDEC2_MCPU_INTR_MSK                        ((0x2304  << 2) + 0xd0050000)
+#define VDEC2_MCPU_INTR_REQ                        ((0x2305  << 2) + 0xd0050000)
+#define VDEC2_MPC_P                                ((0x2306  << 2) + 0xd0050000)
+#define VDEC2_MPC_D                                ((0x2307  << 2) + 0xd0050000)
+#define VDEC2_MPC_E                                ((0x2308  << 2) + 0xd0050000)
+#define VDEC2_MPC_W                                ((0x2309  << 2) + 0xd0050000)
+#define VDEC2_MINDEX0_REG                          ((0x230a  << 2) + 0xd0050000)
+#define VDEC2_MINDEX1_REG                          ((0x230b  << 2) + 0xd0050000)
+#define VDEC2_MINDEX2_REG                          ((0x230c  << 2) + 0xd0050000)
+#define VDEC2_MINDEX3_REG                          ((0x230d  << 2) + 0xd0050000)
+#define VDEC2_MINDEX4_REG                          ((0x230e  << 2) + 0xd0050000)
+#define VDEC2_MINDEX5_REG                          ((0x230f  << 2) + 0xd0050000)
+#define VDEC2_MINDEX6_REG                          ((0x2310  << 2) + 0xd0050000)
+#define VDEC2_MINDEX7_REG                          ((0x2311  << 2) + 0xd0050000)
+#define VDEC2_MMIN_REG                             ((0x2312  << 2) + 0xd0050000)
+#define VDEC2_MMAX_REG                             ((0x2313  << 2) + 0xd0050000)
+#define VDEC2_MBREAK0_REG                          ((0x2314  << 2) + 0xd0050000)
+#define VDEC2_MBREAK1_REG                          ((0x2315  << 2) + 0xd0050000)
+#define VDEC2_MBREAK2_REG                          ((0x2316  << 2) + 0xd0050000)
+#define VDEC2_MBREAK3_REG                          ((0x2317  << 2) + 0xd0050000)
+#define VDEC2_MBREAK_TYPE                          ((0x2318  << 2) + 0xd0050000)
+#define VDEC2_MBREAK_CTRL                          ((0x2319  << 2) + 0xd0050000)
+#define VDEC2_MBREAK_STAUTS                        ((0x231a  << 2) + 0xd0050000)
+#define VDEC2_MDB_ADDR_REG                         ((0x231b  << 2) + 0xd0050000)
+#define VDEC2_MDB_DATA_REG                         ((0x231c  << 2) + 0xd0050000)
+#define VDEC2_MDB_CTRL                             ((0x231d  << 2) + 0xd0050000)
+#define VDEC2_MSFTINT0                             ((0x231e  << 2) + 0xd0050000)
+#define VDEC2_MSFTINT1                             ((0x231f  << 2) + 0xd0050000)
+#define VDEC2_CSP                                  ((0x2320  << 2) + 0xd0050000)
+#define VDEC2_CPSR                                 ((0x2321  << 2) + 0xd0050000)
+#define VDEC2_CINT_VEC_BASE                        ((0x2322  << 2) + 0xd0050000)
+#define VDEC2_CCPU_INTR_GRP                        ((0x2323  << 2) + 0xd0050000)
+#define VDEC2_CCPU_INTR_MSK                        ((0x2324  << 2) + 0xd0050000)
+#define VDEC2_CCPU_INTR_REQ                        ((0x2325  << 2) + 0xd0050000)
+#define VDEC2_CPC_P                                ((0x2326  << 2) + 0xd0050000)
+#define VDEC2_CPC_D                                ((0x2327  << 2) + 0xd0050000)
+#define VDEC2_CPC_E                                ((0x2328  << 2) + 0xd0050000)
+#define VDEC2_CPC_W                                ((0x2329  << 2) + 0xd0050000)
+#define VDEC2_CINDEX0_REG                          ((0x232a  << 2) + 0xd0050000)
+#define VDEC2_CINDEX1_REG                          ((0x232b  << 2) + 0xd0050000)
+#define VDEC2_CINDEX2_REG                          ((0x232c  << 2) + 0xd0050000)
+#define VDEC2_CINDEX3_REG                          ((0x232d  << 2) + 0xd0050000)
+#define VDEC2_CINDEX4_REG                          ((0x232e  << 2) + 0xd0050000)
+#define VDEC2_CINDEX5_REG                          ((0x232f  << 2) + 0xd0050000)
+#define VDEC2_CINDEX6_REG                          ((0x2330  << 2) + 0xd0050000)
+#define VDEC2_CINDEX7_REG                          ((0x2331  << 2) + 0xd0050000)
+#define VDEC2_CMIN_REG                             ((0x2332  << 2) + 0xd0050000)
+#define VDEC2_CMAX_REG                             ((0x2333  << 2) + 0xd0050000)
+#define VDEC2_CBREAK0_REG                          ((0x2334  << 2) + 0xd0050000)
+#define VDEC2_CBREAK1_REG                          ((0x2335  << 2) + 0xd0050000)
+#define VDEC2_CBREAK2_REG                          ((0x2336  << 2) + 0xd0050000)
+#define VDEC2_CBREAK3_REG                          ((0x2337  << 2) + 0xd0050000)
+#define VDEC2_CBREAK_TYPE                          ((0x2338  << 2) + 0xd0050000)
+#define VDEC2_CBREAK_CTRL                          ((0x2339  << 2) + 0xd0050000)
+#define VDEC2_CBREAK_STAUTS                        ((0x233a  << 2) + 0xd0050000)
+#define VDEC2_CDB_ADDR_REG                         ((0x233b  << 2) + 0xd0050000)
+#define VDEC2_CDB_DATA_REG                         ((0x233c  << 2) + 0xd0050000)
+#define VDEC2_CDB_CTRL                             ((0x233d  << 2) + 0xd0050000)
+#define VDEC2_CSFTINT0                             ((0x233e  << 2) + 0xd0050000)
+#define VDEC2_CSFTINT1                             ((0x233f  << 2) + 0xd0050000)
+#define VDEC2_IMEM_DMA_CTRL                        ((0x2340  << 2) + 0xd0050000)
+#define VDEC2_IMEM_DMA_ADR                         ((0x2341  << 2) + 0xd0050000)
+#define VDEC2_IMEM_DMA_COUNT                       ((0x2342  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_imem
+// bit[21:16] A_id_imem
+// bit[11:0] wrrsp_count_imem (reserved)
+#define VDEC2_WRRSP_IMEM                           ((0x2343  << 2) + 0xd0050000)
+#define VDEC2_LMEM_DMA_CTRL                        ((0x2350  << 2) + 0xd0050000)
+#define VDEC2_LMEM_DMA_ADR                         ((0x2351  << 2) + 0xd0050000)
+#define VDEC2_LMEM_DMA_COUNT                       ((0x2352  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_lmem
+// bit[21:16] A_id_lmem
+// bit[11:0] wrrsp_count_lmem 
+#define VDEC2_WRRSP_LMEM                           ((0x2353  << 2) + 0xd0050000)
+#define VDEC2_MAC_CTRL1                            ((0x2360  << 2) + 0xd0050000)
+#define VDEC2_ACC0REG1                             ((0x2361  << 2) + 0xd0050000)
+#define VDEC2_ACC1REG1                             ((0x2362  << 2) + 0xd0050000)
+#define VDEC2_MAC_CTRL2                            ((0x2370  << 2) + 0xd0050000)
+#define VDEC2_ACC0REG2                             ((0x2371  << 2) + 0xd0050000)
+#define VDEC2_ACC1REG2                             ((0x2372  << 2) + 0xd0050000)
+#define VDEC2_CPU_TRACE                            ((0x2380  << 2) + 0xd0050000)
+//
+// Closing file:  vcpu_regs.h
+//
+//
+// Reading file:  vcpu_regs.h
+//
+//========================================================================
+//  VCPU module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_VDEC_VCPU_CBUS_BASE = 0x03
+// -----------------------------------------------
+#define HEVC_MSP                                   ((0x3300  << 2) + 0xd0050000)
+#define HEVC_MPSR                                  ((0x3301  << 2) + 0xd0050000)
+#define HEVC_MINT_VEC_BASE                         ((0x3302  << 2) + 0xd0050000)
+#define HEVC_MCPU_INTR_GRP                         ((0x3303  << 2) + 0xd0050000)
+#define HEVC_MCPU_INTR_MSK                         ((0x3304  << 2) + 0xd0050000)
+#define HEVC_MCPU_INTR_REQ                         ((0x3305  << 2) + 0xd0050000)
+#define HEVC_MPC_P                                 ((0x3306  << 2) + 0xd0050000)
+#define HEVC_MPC_D                                 ((0x3307  << 2) + 0xd0050000)
+#define HEVC_MPC_E                                 ((0x3308  << 2) + 0xd0050000)
+#define HEVC_MPC_W                                 ((0x3309  << 2) + 0xd0050000)
+#define HEVC_MINDEX0_REG                           ((0x330a  << 2) + 0xd0050000)
+#define HEVC_MINDEX1_REG                           ((0x330b  << 2) + 0xd0050000)
+#define HEVC_MINDEX2_REG                           ((0x330c  << 2) + 0xd0050000)
+#define HEVC_MINDEX3_REG                           ((0x330d  << 2) + 0xd0050000)
+#define HEVC_MINDEX4_REG                           ((0x330e  << 2) + 0xd0050000)
+#define HEVC_MINDEX5_REG                           ((0x330f  << 2) + 0xd0050000)
+#define HEVC_MINDEX6_REG                           ((0x3310  << 2) + 0xd0050000)
+#define HEVC_MINDEX7_REG                           ((0x3311  << 2) + 0xd0050000)
+#define HEVC_MMIN_REG                              ((0x3312  << 2) + 0xd0050000)
+#define HEVC_MMAX_REG                              ((0x3313  << 2) + 0xd0050000)
+#define HEVC_MBREAK0_REG                           ((0x3314  << 2) + 0xd0050000)
+#define HEVC_MBREAK1_REG                           ((0x3315  << 2) + 0xd0050000)
+#define HEVC_MBREAK2_REG                           ((0x3316  << 2) + 0xd0050000)
+#define HEVC_MBREAK3_REG                           ((0x3317  << 2) + 0xd0050000)
+#define HEVC_MBREAK_TYPE                           ((0x3318  << 2) + 0xd0050000)
+#define HEVC_MBREAK_CTRL                           ((0x3319  << 2) + 0xd0050000)
+#define HEVC_MBREAK_STAUTS                         ((0x331a  << 2) + 0xd0050000)
+#define HEVC_MDB_ADDR_REG                          ((0x331b  << 2) + 0xd0050000)
+#define HEVC_MDB_DATA_REG                          ((0x331c  << 2) + 0xd0050000)
+#define HEVC_MDB_CTRL                              ((0x331d  << 2) + 0xd0050000)
+#define HEVC_MSFTINT0                              ((0x331e  << 2) + 0xd0050000)
+#define HEVC_MSFTINT1                              ((0x331f  << 2) + 0xd0050000)
+#define HEVC_CSP                                   ((0x3320  << 2) + 0xd0050000)
+#define HEVC_CPSR                                  ((0x3321  << 2) + 0xd0050000)
+#define HEVC_CINT_VEC_BASE                         ((0x3322  << 2) + 0xd0050000)
+#define HEVC_CCPU_INTR_GRP                         ((0x3323  << 2) + 0xd0050000)
+#define HEVC_CCPU_INTR_MSK                         ((0x3324  << 2) + 0xd0050000)
+#define HEVC_CCPU_INTR_REQ                         ((0x3325  << 2) + 0xd0050000)
+#define HEVC_CPC_P                                 ((0x3326  << 2) + 0xd0050000)
+#define HEVC_CPC_D                                 ((0x3327  << 2) + 0xd0050000)
+#define HEVC_CPC_E                                 ((0x3328  << 2) + 0xd0050000)
+#define HEVC_CPC_W                                 ((0x3329  << 2) + 0xd0050000)
+#define HEVC_CINDEX0_REG                           ((0x332a  << 2) + 0xd0050000)
+#define HEVC_CINDEX1_REG                           ((0x332b  << 2) + 0xd0050000)
+#define HEVC_CINDEX2_REG                           ((0x332c  << 2) + 0xd0050000)
+#define HEVC_CINDEX3_REG                           ((0x332d  << 2) + 0xd0050000)
+#define HEVC_CINDEX4_REG                           ((0x332e  << 2) + 0xd0050000)
+#define HEVC_CINDEX5_REG                           ((0x332f  << 2) + 0xd0050000)
+#define HEVC_CINDEX6_REG                           ((0x3330  << 2) + 0xd0050000)
+#define HEVC_CINDEX7_REG                           ((0x3331  << 2) + 0xd0050000)
+#define HEVC_CMIN_REG                              ((0x3332  << 2) + 0xd0050000)
+#define HEVC_CMAX_REG                              ((0x3333  << 2) + 0xd0050000)
+#define HEVC_CBREAK0_REG                           ((0x3334  << 2) + 0xd0050000)
+#define HEVC_CBREAK1_REG                           ((0x3335  << 2) + 0xd0050000)
+#define HEVC_CBREAK2_REG                           ((0x3336  << 2) + 0xd0050000)
+#define HEVC_CBREAK3_REG                           ((0x3337  << 2) + 0xd0050000)
+#define HEVC_CBREAK_TYPE                           ((0x3338  << 2) + 0xd0050000)
+#define HEVC_CBREAK_CTRL                           ((0x3339  << 2) + 0xd0050000)
+#define HEVC_CBREAK_STAUTS                         ((0x333a  << 2) + 0xd0050000)
+#define HEVC_CDB_ADDR_REG                          ((0x333b  << 2) + 0xd0050000)
+#define HEVC_CDB_DATA_REG                          ((0x333c  << 2) + 0xd0050000)
+#define HEVC_CDB_CTRL                              ((0x333d  << 2) + 0xd0050000)
+#define HEVC_CSFTINT0                              ((0x333e  << 2) + 0xd0050000)
+#define HEVC_CSFTINT1                              ((0x333f  << 2) + 0xd0050000)
+#define HEVC_IMEM_DMA_CTRL                         ((0x3340  << 2) + 0xd0050000)
+#define HEVC_IMEM_DMA_ADR                          ((0x3341  << 2) + 0xd0050000)
+#define HEVC_IMEM_DMA_COUNT                        ((0x3342  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_imem
+// bit[21:16] A_id_imem
+// bit[11:0] wrrsp_count_imem (reserved)
+#define HEVC_WRRSP_IMEM                            ((0x3343  << 2) + 0xd0050000)
+#define HEVC_LMEM_DMA_CTRL                         ((0x3350  << 2) + 0xd0050000)
+#define HEVC_LMEM_DMA_ADR                          ((0x3351  << 2) + 0xd0050000)
+#define HEVC_LMEM_DMA_COUNT                        ((0x3352  << 2) + 0xd0050000)
+// bit[29:24] A_brst_num_lmem
+// bit[21:16] A_id_lmem
+// bit[11:0] wrrsp_count_lmem 
+#define HEVC_WRRSP_LMEM                            ((0x3353  << 2) + 0xd0050000)
+#define HEVC_MAC_CTRL1                             ((0x3360  << 2) + 0xd0050000)
+#define HEVC_ACC0REG1                              ((0x3361  << 2) + 0xd0050000)
+#define HEVC_ACC1REG1                              ((0x3362  << 2) + 0xd0050000)
+#define HEVC_MAC_CTRL2                             ((0x3370  << 2) + 0xd0050000)
+#define HEVC_ACC0REG2                              ((0x3371  << 2) + 0xd0050000)
+#define HEVC_ACC1REG2                              ((0x3372  << 2) + 0xd0050000)
+#define HEVC_CPU_TRACE                             ((0x3380  << 2) + 0xd0050000)
+//
+// Closing file:  vcpu_regs.h
+//
+//
+// Reading file:  henc_regs.h
+//
+//========================================================================
+//  MDEC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_HENC_CBUS_BASE = 0x0a
+// -----------------------------------------------
+#define HCODEC_HENC_SCRATCH_0                      ((0x1ac0  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_1                      ((0x1ac1  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_2                      ((0x1ac2  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_3                      ((0x1ac3  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_4                      ((0x1ac4  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_5                      ((0x1ac5  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_6                      ((0x1ac6  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_7                      ((0x1ac7  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_8                      ((0x1ac8  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_9                      ((0x1ac9  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_A                      ((0x1aca  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_B                      ((0x1acb  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_C                      ((0x1acc  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_D                      ((0x1acd  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_E                      ((0x1ace  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_F                      ((0x1acf  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_G                      ((0x1ad0  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_H                      ((0x1ad1  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_I                      ((0x1ad2  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_J                      ((0x1ad3  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_K                      ((0x1ad4  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_L                      ((0x1ad5  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_M                      ((0x1ad6  << 2) + 0xd0050000)
+#define HCODEC_HENC_SCRATCH_N                      ((0x1ad7  << 2) + 0xd0050000)
+// bit [7:0] data_feed_buff_id
+#define HCODEC_IE_DATA_FEED_BUFF_INFO              ((0x1ad8  << 2) + 0xd0050000)
+//
+// Closing file:  henc_regs.h
+//
+//
+// Reading file:  vlc_regs.h
+//
+//========================================================================
+//  VLC module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_VLC_CBUS_BASE = 0x0d
+// -----------------------------------------------
+// Bit[31:28] - henc_status
+// Bit[27:8] - reserved
+// Bit[7]    mc_hcmd_buff_enable
+// Bit[6]    mc_hcmd_use_mc_hcmd_buff
+// Bit[5]    mc_hcmd_use_mc_hcmd_hw_start
+// Bit[4]    no_mc_out_null_non_skipped_mb
+// Bit[3]    mc_out_even_skipped_mb
+// Bit[2] - hcmd_enable
+// Bit[1] - vlc_control_enable (0 will treat as soft_reset)
+// Bit[0] - vlc_input_enable (enable input interface)
+#define HCODEC_VLC_STATUS_CTRL                     ((0x1d00  << 2) + 0xd0050000)
+// Bit[31:16] - Reserved
+// Bit [15]  - enable_free_clk_mc_hcmd_buff
+// Bit [14]  - enable_free_clk_reg
+// Bit [13]  - enable_free_clk_stream
+// Bit [12]  - enable_free_clk_pre_buff
+// Bit [11]  - enable_free_clk_vb_buff
+// Bit [10]  - enable_free_clk_dc_input
+// Bit [9]   - enable_free_clk_input
+// Bit [8]   - enable_free_clk_mv_cal
+// Bit [7]   - enable_free_clk_status
+// Bit [6]   - enable_free_clk_mc_dblk_cmd_if
+// Bit [5]   - disable_mvd_enc_finished
+// Bit [4]   - I16MB_share_ipred_mode_with_I4MB
+// Bit [3]   - fixed_picture_qp
+// Bit [2]   - use_set_b8_mode ( not used now)
+// Bit [1]   - use_set_mb_skip_run
+// Bit [0]   - pop_coeff_even_all_zero
+#define HCODEC_VLC_CONFIG                          ((0x1d01  << 2) + 0xd0050000)
+// --------------------------------------------
+// Bitstream DDR Interface
+// --------------------------------------------
+#define HCODEC_VLC_VB_START_PTR                    ((0x1d10  << 2) + 0xd0050000)
+#define HCODEC_VLC_VB_END_PTR                      ((0x1d11  << 2) + 0xd0050000)
+#define HCODEC_VLC_VB_WR_PTR                       ((0x1d12  << 2) + 0xd0050000)
+// Read Only, VLC_VB_SW_RD_PTR or VLC_VB_HW_RD_PTR
+#define HCODEC_VLC_VB_RD_PTR                       ((0x1d13  << 2) + 0xd0050000)
+#define HCODEC_VLC_VB_SW_RD_PTR                    ((0x1d14  << 2) + 0xd0050000)
+// Read Only
+#define HCODEC_VLC_VB_LEFT                         ((0x1d15  << 2) + 0xd0050000)
+// VB FIFO Control
+// bit  [31:24] vb_full_int_enable_cpu[7:0] 
+// bit  [23:16] vb_full_int_enable_amrisc[7:0] 
+//   -bit 23 Video BUFFER LEFT < 0x400 Bytes
+//   -bit 22 Video BUFFER LEFT < 0x200 Bytes
+//   -bit 21 Video BUFFER LEFT < 0x100 Bytes
+//   -bit 20 Video BUFFER LEFT < 0x80 Bytes
+//   -bit 19 Video BUFFER LEFT < 0x40 Bytes
+//   -bit 18 Video BUFFER LEFT < 0x20 Bytes
+//   -bit 17 vbfifo left  < 16 double words (8x64bits)
+//   -bit 16 vbfifo left  < 8 double words (4x64bits)
+// bit  [15]    wr_ptr_int_enable_cpu
+// bit  [14]    wr_ptr_int_enable_amrisc
+// bit  [13]    wr_ptr_int (Read Only, write 1 will clear)
+// bit  [12]    vb_full_int_enable_cpu(Read Only)
+// bit  [11]    vb_full_int_enable_amrisc(Read Only)
+// bit  [10]    reserved
+// bit  [9]     use_vb_hw_rd_ptr
+// bit  [8]     vb_always_ready Set to 1 to ignore vb_level blocking DDR write
+// bit  [7]     vb_ready_for_transfer (Read Only)
+// bit  [6]     data_ready_for_transfer (Read Only)
+// bits [5:3]   vb_endian       Set VB Endian inside DDR memory 
+// bit  [2]     vb_write_busy   Read Only - indicate DDR write busy
+// bit  [1]     vb_write_en     Set to 1 to enable writing data to DDR memory
+// bit  [0]     vb_soft_reset   Soft reset  
+#define HCODEC_VLC_VB_CONTROL                      ((0x1d16  << 2) + 0xd0050000)
+// bit 31    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request  // default : 0
+// bit 30    A_urgent  // default : 0
+// bit 29:24 A_brst_num // default : 0x3f
+// bit 23:22 reserved
+// bit 21:16 A_id  // default : 0x20 
+// bit 15:0  vb_left_hold // default : 0 
+#define HCODEC_VLC_VB_MEM_CTL                      ((0x1d17  << 2) + 0xd0050000)
+// vb_wr_ptr address to generate interrupt
+#define HCODEC_VLC_VB_INT_PTR                      ((0x1d18  << 2) + 0xd0050000)
+// bit[31:12] reserved
+// bit[11:0] vlc_wrrsp_count
+#define HCODEC_VLC_WRRSP                           ((0x1d19  << 2) + 0xd0050000)
+#define HCODEC_VLC_TOTAL_BYTES                     ((0x1d1a  << 2) + 0xd0050000)
+// bit  [31:26] reserved
+// bit  [25]    vb_flush
+// bit  [24]    vb_reg_ready  
+// bit  [23:16] vb_buff_left     -- Read only
+// bit  [15:8]  vb_buff_wr_point -- RW
+// bit  [7:0]   vb_buff_rd_point -- RW
+#define HCODEC_VLC_VB_BUFF                         ((0x1d1b  << 2) + 0xd0050000)
+// bit[31]    flush_vlc_pre_buff
+// bit[30:27] reserved
+// bit[26:24] vb_pre_buff_level
+// bit[23:0]  vb_pre_buff_data[55:32] 
+#define HCODEC_VLC_VB_PRE_BUFF_HI                  ((0x1d1c  << 2) + 0xd0050000)
+// bit[31:0] vb_pre_buff_data[31:0]
+#define HCODEC_VLC_VB_PRE_BUFF_LOW                 ((0x1d1d  << 2) + 0xd0050000)
+// bit[31]    stream_encap_enable  // 0x0000(00-03) will be changed to 0x000003(00-03) if enabled
+// bit[30:29] stream_encap_delay   // delay bytes for encap used 
+// bit[28:24] stream_buff_point
+// bit[23:0]  stream_buff_data 
+#define HCODEC_VLC_STREAM_BUFF                     ((0x1d1e  << 2) + 0xd0050000)
+// bit[31]    push_stream_block - Read Only (Will set if vb_buff full)
+// bit[30]    push_stream_busy  - Read Only (busy when output one byte from stream_buf (max 2 clocks for 8 bits push)
+// bit[29:28] stream_encap_status - Read Only
+// bit[27:21] reserved
+// Long Mode : (Amrisc need movilo and mvihi high to set stream_info)
+//   bit[20:16] push_stream_long_length (0 or 31 : Mid or Short mode)
+//   bit[15:0]  push_stream_data
+// Mid Mode : (Amrisc need movi to set stream_info) 
+//   bit[15:12]] push_stream_mid_length (1-12 : mid mode active, 0-short mode, 15 - byte align)
+//   bit[11:0]  push_stream_data
+// Short Mode : (Amrisc can use mtspi to push stream directely)
+//   bit[7:5] push_stream_short_length (0-5 : short length, else - invalid)
+//   bit[4:0]  push_stream_data
+#define HCODEC_VLC_PUSH_STREAM                     ((0x1d1f  << 2) + 0xd0050000)
+// bit[15:8] ELEMENT_LENGTH
+// bit[7:1]  reserved
+// bit[0]  Write - push start, Read - Push Busy
+#define HCODEC_VLC_PUSH_ELEMENT                    ((0x1d20  << 2) + 0xd0050000)
+#define HCODEC_VLC_ELEMENT_DATA                    ((0x1d21  << 2) + 0xd0050000)
+// bit[7] hcmd_intra_use_sw_info
+// bit[6] hcmd_use_sw_info
+// bit[5] always_use_info_0_cbp_blk
+// bit[4] always_update_info_0_cbp_blk
+// bit[3] reset_left_mb_wr
+// bit[2] reset_top_mb_wr
+// bit[1] set_left_mb_wr
+// bit[0] set_top_mb_wr
+#define HCODEC_VLC_SPECIAL_CTL                     ((0x1d22  << 2) + 0xd0050000)
+// bit[28]    left_intra
+// bit[27:22] left_quant
+// bit[21:16] left_quant_c
+// bit[12]    top_intra
+// bit[11:6]  top_quant
+// bit[5:0]   top_quant_c
+#define HCODEC_VLC_HCMD_T_L_INFO                   ((0x1d23  << 2) + 0xd0050000)
+// bit[12]    cur_intra
+// bit[11:6]  cur_quant
+// bit[5:0]   cur_quant_c
+#define HCODEC_VLC_HCMD_CUR_INFO                   ((0x1d24  << 2) + 0xd0050000)
+// --------------------------------------------
+// Picture VLC 
+// --------------------------------------------
+// (&(int|(~AND_enable))|(|(int&OR_enable)))
+// bit[31]    OR interrupt Enable Reserved
+// bit[30]    OR interrupt Enable for mv_busy
+// bit[29]    OR interrupt Enable for b8_mode_busy
+// bit[28]    OR interrupt Enable for mb_skip_run_busy
+// bit[27]    OR interrupt Enable for cbp_busy
+// bit[26]    OR interrupt Enable for Reserved
+// bit[25]    OR interrupt Enable for Reserved
+// bit[24]    OR interrupt Enable for mb_info_busy
+// bit[23]    AND interrupt Enable Reserved
+// bit[22]    AND interrupt Enable for mv_busy
+// bit[21]    AND interrupt Enable for b8_mode_busy
+// bit[20]    AND interrupt Enable for mb_skip_run_busy
+// bit[19]    AND interrupt Enable for cbp_busy 
+// bit[18]    AND interrupt Enable for Reserved
+// bit[17]    AND interrupt Enable for Reserved        
+// bit[16]    AND interrupt Enable for mb_info_busy
+// bit[15]    OR interrupt Enable Reserved
+// bit[14]    OR interrupt Enable for mvd
+// bit[13]    OR interrupt Enable for b8_mode
+// bit[12]    OR interrupt Enable for mb_skip_run
+// bit[11]    OR interrupt Enable for cbp_ready
+// bit[10]    OR interrupt Enable for c_ipred_mode_ready
+// bit[9]     OR interrupt Enable for ipred_mode_ready
+// bit[8]     OR interrupt Enable for mb_info_ready
+// bit[7]     AND interrupt Enable Reserved
+// bit[6]     AND interrupt Enable for mvd
+// bit[5]     AND interrupt Enable for b8_mode
+// bit[4]     AND interrupt Enable for mb_skip_run
+// bit[3]     AND interrupt Enable for cbp_ready
+// bit[2]     AND interrupt Enable for c_ipred_mode_ready
+// bit[1]     AND interrupt Enable for ipred_mode_ready
+// bit[0]     AND interrupt Enable for mb_info_ready
+#define HCODEC_VLC_INT_CONTROL                     ((0x1d30  << 2) + 0xd0050000)
+// Bit[31:16] picture_height
+// Bit[15:0]  picture_width
+#define HCODEC_VLC_PIC_SIZE                        ((0x1d31  << 2) + 0xd0050000)
+// [31:16] Reserved
+// [15:3] pic_width_in_mbs_minus1
+// [2:0]  picture_type 
+#define HCODEC_VLC_PIC_INFO                        ((0x1d32  << 2) + 0xd0050000)
+// Bit[31:16] MB_NR
+// Bit[15:8] MBY
+// Bit[7:0] MBX
+#define HCODEC_VLC_PIC_POSITION                    ((0x1d33  << 2) + 0xd0050000)
+// Bit[31] MV_busy
+// Bit[30:6] Reserved
+// Bit[15] Reserved
+// Bit[14] vlc_input_MV_busy
+// Bit[13] vlc_input_b8_mode_busy
+// Bit[12] vlc_input_mb_skip_run_busy
+// Bit[11] vlc_input_cbp_busy
+// Bit[10] Reserved
+// Bit[9]  Reserved
+// Bit[8] vlc_input_mb_info_busy
+// Bit[7] Reserved
+// Bit[6] mvd
+// Bit[5] b8_mode
+// Bit[4] mb_skip_run
+// Bit[3] cbp
+// Bit[2] c_ipred_mode
+// Bit[1] ipred_mode
+// Bit[0] mb_info ( mb_type, mb_x, mb_y)
+#define HCODEC_VLC_INPUT_STATUS                    ((0x1d34  << 2) + 0xd0050000)
+// Bit[31:28] detected_mb_type
+// Bit[27:16] mb_y 
+// Bit[15:4]  mb_x 
+// Bit[3:0]   mb_type
+#define HCODEC_VLC_MB_INFO                         ((0x1d35  << 2) + 0xd0050000)
+// commnad 0 -- no pending
+// normal command + 1 is pending command
+//
+// bit 31:28 -- pending command 7
+// bit 27:24 -- pending command 6
+// bit 23:20 -- pending command 5
+// bit 19:16 -- pending command 4
+// bit 15:12 -- pending command 3
+// bit 11:8  -- pending command 2
+// bit  7:4  -- pending command 1
+// bit  3:0  -- pending command 0
+#define HCODEC_VLC_ENC_PEND_CMD                    ((0x1d36  << 2) + 0xd0050000)
+// For I Slice
+// Bit[31:16] Reserved
+// Bit[15:0] IntraType 
+#define HCODEC_HENC_TOP_INFO_0                     ((0x1d37  << 2) + 0xd0050000)
+#define HCODEC_HENC_LEFT_INFO_0                    ((0x1d38  << 2) + 0xd0050000)
+// For I Slice
+// Bit[31:24] V_nnz
+// Bit[23:16] U_nnz
+// Bit[15:0]  Y_nnz 
+#define HCODEC_HENC_TOP_INFO_1                     ((0x1d39  << 2) + 0xd0050000)
+#define HCODEC_HENC_LEFT_INFO_1                    ((0x1d3a  << 2) + 0xd0050000)
+// bit[63:0] ipred_mode
+#define HCODEC_VLC_IPRED_MODE_HI                   ((0x1d3b  << 2) + 0xd0050000)
+#define HCODEC_VLC_IPRED_MODE_LO                   ((0x1d3c  << 2) + 0xd0050000)
+// bit[15:8] SE delta quant 
+// bit[7:0]  UE delta quant
+#define HCODEC_VLC_DELTA_QP                        ((0x1d3d  << 2) + 0xd0050000)
+// bit[31:16] Reserved
+// bit[15:12] Reserved
+// bit[11:8] c_ipred_mode 
+// bit[7:0] cbp
+#define HCODEC_VLC_MB_HEADER_INFO                  ((0x1d3e  << 2) + 0xd0050000)
+// bit[31:16] mb_skip_run
+// bit[15:0]  b8_mode
+#define HCODEC_VLC_P_MB_HEADER_INFO                ((0x1d3f  << 2) + 0xd0050000)
+// bit[31]    write_ptr_update
+// bit[30]    read_ptr_update
+// bit[29:20] coeff_buf_level
+// bit[19:10] coeff_buf_write_ptr
+// bit[9:0]   coeff_buf_read_ptr
+#define HCODEC_VLC_COEFF_BUF_STATUS                ((0x1d40  << 2) + 0xd0050000)
+// bit[31:10] Reserved
+// bit[9:0] read_req_addr
+#define HCODEC_VLC_COEFF_RD_REQ                    ((0x1d41  << 2) + 0xd0050000)
+// bit[20]   - coeff_buf_read_finished
+// bit[19]   - coeff_first
+// bit[18:4] - coeff_level 
+// bit[3:0]  - coeff_run 
+#define HCODEC_VLC_COEFF                           ((0x1d42  << 2) + 0xd0050000)
+// bit[31]    - coeff_info_ready
+// bit[30:25] - Reserved
+// bit[24:15] - block_begin_addr
+// bit[14:11] - trailing_one_sign
+// bit[10:6]  - total_coeff 
+// bit[5:4]   - trailing_ones 
+// bit[3:0]   - total_zeros
+#define HCODEC_VLC_COEFF_INFO                      ((0x1d43  << 2) + 0xd0050000)
+// bit[31]    write_ptr_update
+// bit[30]    read_ptr_update
+// bit[29:25] Reserved
+// bit[24:20] dc_buf_level -- 0-16
+// bit[19:15] Reserved
+// bit[14:10] dc_buf_write_ptr
+// bit[9:5]   Reserved
+// bit[4:0]   dc_buf_read_ptr
+#define HCODEC_VLC_DC_BUF_STATUS                   ((0x1d44  << 2) + 0xd0050000)
+// bit[31:10] Reserved
+// bit[9:4]   Reserved
+// bit[3:0]   read_req_addr
+#define HCODEC_VLC_DC_RD_REQ                       ((0x1d45  << 2) + 0xd0050000)
+// bit[31:17] - Reserved
+// bit[16]   - dc_first
+// bit[15:1] - dc_level 
+// bit[0]    - dc_type  0 - CDC, 1 - LDC
+#define HCODEC_VLC_DC                              ((0x1d46  << 2) + 0xd0050000)
+// bit[31]    - dc_info_ready
+// bit[30:25] - Reserved
+// bit[24:20] - Reserved
+// bit[19:15] - dc_idx_begin_addr
+// bit[14:11] - dc_trailing_one_sign
+// bit[10:6]  - dc_total_coeff 
+// bit[5:4]   - dc_trailing_ones 
+// bit[3:0]   - dc_total_zeros
+#define HCODEC_VLC_DC_INFO                         ((0x1d47  << 2) + 0xd0050000)
+// bit[31:4]  - Reserved
+// bit[3:0]   - mv_rw_idx  (auto increment when read/write VLC_MV) 
+#define HCODEC_VLC_MV_INDEX                        ((0x1d48  << 2) + 0xd0050000)
+// bit[31:16] - MVY
+// bit[15:0]  - MVX
+#define HCODEC_VLC_MV                              ((0x1d49  << 2) + 0xd0050000)
+// bit[31:16] - MVY
+// bitp15:0]  - MVX
+// Write to HENC_TOP_MV_0 will cause previous U->UL, UR->U, and UR write
+// Read will read U MV only 
+#define HCODEC_HENC_TOP_MV_0                       ((0x1d4a  << 2) + 0xd0050000)
+#define HCODEC_HENC_TOP_MV_1                       ((0x1d4b  << 2) + 0xd0050000)
+#define HCODEC_HENC_TOP_MV_2                       ((0x1d4c  << 2) + 0xd0050000)
+#define HCODEC_HENC_TOP_MV_3                       ((0x1d4d  << 2) + 0xd0050000)
+#define HCODEC_HENC_LEFT_MV_0                      ((0x1d4e  << 2) + 0xd0050000)
+#define HCODEC_HENC_LEFT_MV_1                      ((0x1d4f  << 2) + 0xd0050000)
+#define HCODEC_HENC_LEFT_MV_2                      ((0x1d50  << 2) + 0xd0050000)
+#define HCODEC_HENC_LEFT_MV_3                      ((0x1d51  << 2) + 0xd0050000)
+// Bit[31:1] Reserved
+// Bit[0] top_left_mv_ready
+#define HCODEC_TOP_LEFT_READY                      ((0x1d52  << 2) + 0xd0050000)
+// Bit[31:16] Reserved
+// Bit[15:0] mb_skip_run
+#define HCODEC_MB_SKIP_RUN                         ((0x1d53  << 2) + 0xd0050000)
+// Bit[31:16] Reserved
+// Bit[15]    Reserved
+// Bit[14:13] rd_struct // 00 - frame, 10 - top field, 11 - bottom field
+// Bit[12:11] wr_struct // 00 - frame, 10 - top field, 11 - bottom field
+// Bit[10:5]  mv_buff_id
+// Bit[4:0]   mv_ref
+#define HCODEC_VLC_HCMD_CONFIG                     ((0x1d54  << 2) + 0xd0050000)
+// Bit[9:0] h264_dblk_info
+#define HCODEC_VLC_HCMD_DBLK_INFO                  ((0x1d55  << 2) + 0xd0050000)
+// Bit[3:0] vlc_dbg_idx
+#define HCODEC_VLC_DBG_IDX                         ((0x1d56  << 2) + 0xd0050000)
+// Read Only
+#define HCODEC_VLC_DBG_READ                        ((0x1d57  << 2) + 0xd0050000)
+// [   29] RW jpeg_comp2_ac_table_sel.                                                      Default 0.
+// [   28] RW jpeg_comp2_dc_table_sel.                                                      Default 0.
+// [26:25] RW jpeg_comp2_cnt_max.                                                           Default 0.
+// [   24] RW jpeg_comp2_en. Set 1 if the scan will include component 2 (Cr).               Default 0.
+// [   21] RW jpeg_comp1_ac_table_sel.                                                      Default 0.
+// [   20] RW jpeg_comp1_dc_table_sel.                                                      Default 0.
+// [18:17] RW jpeg_comp1_cnt_max.                                                           Default 0.
+// [   16] RW jpeg_comp1_en. Set 1 if the scan will include component 1 (Cb).               Default 0.
+// [   13] RW jpeg_comp0_ac_table_sel.                                                      Default 0.
+// [   12] RW jpeg_comp0_dc_table_sel.                                                      Default 0.
+// [10: 9] RW jpeg_comp0_cnt_max.                                                           Default 0.
+// [    8] RW jpeg_comp0_en. Set 1 if the scan will include component 0 (Y).                Default 0.
+// [    1] W  jpeg_coeff_init. Write 1 to this bit to initialize JPEG run length encoder.
+// [    0] RW jpeg_en. 0=Disable JPEG encoder; 1=Enable JPEG encoder.                       Default 0.
+#define HCODEC_VLC_JPEG_CTRL                       ((0x1d58  << 2) + 0xd0050000)
+// [   13] RW jpeg_coeff_buf_overfl. Write this bit to 1 to clear overfl.
+// [   12] RW jpeg_coeff_buf_undrfl. Write this bit to 1 to clear undrfl.
+// [   11] R  jpeg_coeff_buf_full.
+// [   10] R  jpeg_coeff_buf_empty.
+// [ 8: 0] R  jpeg_coeff_buf_level.
+#define HCODEC_VLC_JPEG_COEFF_BUF_STAT             ((0x1d59  << 2) + 0xd0050000)
+// [   16] RW JPEG HUFFMAN table access mode. 0=Write; 1=Read.  Default 1.
+// [ 8: 0] RW JPEG HUFFMAN table addr.                          Default 0.
+#define HCODEC_VLC_HUFFMAN_ADDR                    ((0x1d5a  << 2) + 0xd0050000)
+// [19: 0] RW JPEG HUFFMAN table data.
+#define HCODEC_VLC_HUFFMAN_DATA                    ((0x1d5b  << 2) + 0xd0050000)
+// bit[31:0] enc_mv_bits - including b8_mode and mvd
+#define HCODEC_VLC_ENC_MV_BITS                     ((0x1d5c  << 2) + 0xd0050000)
+// bit[31:0] enc_coeff_bits - including cbp, token, trailing_sign, coeff_enc, h264_totzeros, h264_run
+#define HCODEC_VLC_ENC_COEFF_BITS                  ((0x1d5d  << 2) + 0xd0050000)
+//
+// Closing file:  vlc_regs.h
+//
+//
+// Reading file:  qdct_regs.h
+//
+//========================================================================
+//  QDCT module level register offset
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DOS_HCODEC_QDCT_CBUS_BASE = 0x0f
+// -----------------------------------------------
+// bit[31:28] - mb_info_state
+#define HCODEC_QDCT_STATUS_CTRL                    ((0x1f00  << 2) + 0xd0050000)
+// bit[18]    - enable_free_clk_sad_top
+// bit[17]    - enable_free_clk_ie_top
+// bit[16]    - enable_free_clk_ie_sub
+// bit[15]    - enable_free_clk_mc_out
+// bit[14]    - enable_free_clk_i_pred_top
+// bit[13]    - enable_free_clk_idct_top
+// bit[12]    - enable_free_clk_iq_top
+// bit[11]    - enable_free_clk_q_top
+// bit[10]    - enable_free_clk_dc_buff_8
+// bit[9]     - enable_free_clk_dct_top
+// bit[8]     - enable_free_clk_mb_info
+// bit[7]     - enable_free_clk_mb_buff
+// bit[6]     - enable_free_clk_reg
+// bit[5]     - ignore_1_include_2nd_half_c
+// bit[4]     - ignore_1_include_2nd_half
+// bit[3]     - ignore_t_p8x8
+// bit[2]     - not_ignore_dc
+// bit[1]     - ignore_small_lac_intra
+// bit[0]     - disable_fast_zero_block
+#define HCODEC_QDCT_CONFIG                         ((0x1f01  << 2) + 0xd0050000)
+// bit[31]    - ignore_lac_coeff_en
+// bit[30:26] - ignore_lac_coeff_else
+// bit[25:21] - ignore_lac_coeff_2 
+// bit[20:16] - ignore_lac_coeff_1 
+// bit[15]    - ignore_cac_coeff_en
+// bit[14:10] - ignore_cac_coeff_else
+// bit[9:5]   - ignore_cac_coeff_2 
+// bit[4:0]   - ignore_cac_coeff_1 
+#define HCODEC_IGNORE_CONFIG                       ((0x1f02  << 2) + 0xd0050000)
+// bit[31]    - ignore_t_lac_coeff_en
+// bit[30:26] - ignore_t_lac_coeff_else
+// bit[25:21] - ignore_t_lac_coeff_2 
+// bit[20:16] - ignore_t_lac_coeff_1 
+// bit[15:0]  - Reserved
+#define HCODEC_IGNORE_CONFIG_2                     ((0x1f03  << 2) + 0xd0050000)
+// --------------------------------------------
+// MB DATA DDR Interface
+// --------------------------------------------
+#define HCODEC_QDCT_MB_START_PTR                   ((0x1f10  << 2) + 0xd0050000)
+#define HCODEC_QDCT_MB_END_PTR                     ((0x1f11  << 2) + 0xd0050000)
+#define HCODEC_QDCT_MB_WR_PTR                      ((0x1f12  << 2) + 0xd0050000)
+#define HCODEC_QDCT_MB_RD_PTR                      ((0x1f13  << 2) + 0xd0050000)
+#define HCODEC_QDCT_MB_LEVEL                       ((0x1f14  << 2) + 0xd0050000)
+// bit  [31]    reserved
+// bit  [30]    no_wait_after_q_cdc
+// bit  [29]    ie_start_int_enable
+// bit  [28]    ignore_t_p8x8
+// bit  [27]    zero_mc_out_null_non_skipped_mb
+// bit  [26]    no_mc_out_null_non_skipped_mb
+// bit  [25]    mc_out_even_skipped_mb
+// bit  [24]    mc_out_wait_cbp_ready
+// bit  [23]    mc_out_wait_mb_type_ready
+// bit  [22]    i_pred_int_enable
+// bit  [21]    intra_sat8_enable
+// bit  [20]    ie_sub_enable
+// bit  [19]    i_pred_enable
+// bit  [18]    iq_enable
+// bit  [17]    idct_enable
+// bit  [16]    no_zero_coeff_mb
+// bit  [15]    add_zero_coeff_block
+// bit  [14]    mb_pause_enable
+// bit  [13]    q_enable
+// bit  [12]    dct_enable
+// bit  [11]    ignore_magic_word
+// bit  [10]    mb_info_en
+// bit  [9]     mb_info_soft_reset
+// bit  [8]     mb_always_ready Set to 1 to ignore mb_level blocking DDR read
+// bit  [7]     mb_ready_for_transfer (Read Only)
+// bit  [6]     data_ready_for_transfer (Read Only)
+// bits [5:3]   mb_endian       Set MB Endian inside DDR memory 
+// bit  [2]     mb_read_busy   Read Only - indicate DDR read busy
+// bit  [1]     mb_read_en     Set to 1 to enable reading data from DDR memory
+// bit  [0]     mb_soft_reset   Soft reset  
+#define HCODEC_QDCT_MB_CONTROL                     ((0x1f15  << 2) + 0xd0050000)
+// bit 31    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request  // default : 0
+// bit 30    A_urgent  // default : 0
+// bit 29:24 A_brst_num // default : 0x3f
+// bit 23    reserved
+// bit 22    read_till_zero
+// bit 21:16 A_id  // default : 0x21 
+// bit 15:0  mb_level_hold // default : 0 
+#define HCODEC_QDCT_MB_MEM_CTL                     ((0x1f16  << 2) + 0xd0050000)
+// bit  [31:24] reserved
+// bit  [23:16] vb_buff_level     -- Read only
+// bit  [15:8]  vb_buff_wr_point -- RW
+// bit  [7:0]   vb_buff_rd_point -- RW
+#define HCODEC_QDCT_MB_BUFF                        ((0x1f17  << 2) + 0xd0050000)
+// bit [31:0] mb infor data begin magic word - default : 0xa55aaa55
+#define HCODEC_QDCT_MB_MAGIC_WORD                  ((0x1f18  << 2) + 0xd0050000)
+// Read Only Register
+// bit[19]   dct_ready_1
+// bit[18]   dct_ready_0
+// bit[17]   dct_rd_idx
+// bit[16]   dct_wr_idx
+// bit[15]   dct_srdy
+// bit[14]   dct_rrdy
+// bit[13]   Reserved
+// bit[12:8] dct_block_number 
+// bit[7:4]  dct_rw_addr 
+// bit[3:0]  dct_status
+#define HCODEC_QDCT_DCT_STATUS                     ((0x1f19  << 2) + 0xd0050000)
+// bit[3:0]  q_status
+#define HCODEC_QDCT_Q_STATUS                       ((0x1f1a  << 2) + 0xd0050000)
+// bit[31:3] Reserved
+// bit[2:0]  picture_type
+#define HCODEC_QDCT_PIC_INFO                       ((0x1f1b  << 2) + 0xd0050000)
+// bit[31:28] Reserved
+// bit[27:22] I_pic_quant_c
+// bit[21:16] I_pic_quant
+// bit[15]    reserved
+// bit[14:12] quant_rem_c
+// bit[11:8]  quant_per_c
+// bit[7]     reserved
+// bit[6:4]   quant_rem
+// bit[3:0]   quant_per
+#define HCODEC_QDCT_Q_QUANT_I                      ((0x1f1c  << 2) + 0xd0050000)
+// bit[31:28] Reserved
+// bit[27:22] P_pic_quant_c
+// bit[21:16] P_pic_quant
+// bit[15]    reserved
+// bit[14:12] quant_rem_c
+// bit[11:8]  quant_per_c
+// bit[7]     reserved
+// bit[6:4]   quant_rem
+// bit[3:0]   quant_per
+#define HCODEC_QDCT_Q_QUANT_P                      ((0x1f1d  << 2) + 0xd0050000)
+// bit[31]    mb_info_pause
+// bit[30:16] pause_mby
+// bit[15:0]  pause_mbx
+#define HCODEC_QDCT_MB_PAUSE_CTL                   ((0x1f1e  << 2) + 0xd0050000)
+// bit[31]   top_control_ready_i_pred
+// bit[30:28]top_dma_status   
+// bit[27]   top_control_ready_ie
+// bit[26:24]Reserved
+// bit[23]   ul_mb
+// bit[22]   right_mb
+// bit[21]   top_mb
+// bit[20]   left_mb
+// bit[19:8] mb_x
+// bit[7:6]  i_pred_ref_idx_L 
+// bit[5:4]  i_pred_ref_idx_UL 
+// bit[3:2]  i_pred_ref_idx_U
+// bit[1:0]  i_pred_ref_idx_UR 
+#define HCODEC_QDCT_TOP_CONTROL                    ((0x1f1f  << 2) + 0xd0050000)
+// bit[31:0] top_base_addr - DDR Memory start address for save top Pixel
+#define HCODEC_QDCT_TOP_BASE_MEM                   ((0x1f20  << 2) + 0xd0050000)
+// bit 15:13 Reserved
+// bit 12    A_urgent  // default : 0
+// bit 11:6  A_brst_num // default : 0x3f
+// bit 5:0   A_id  // default : 0x22
+#define HCODEC_QDCT_TOP_MEM_CTL                    ((0x1f21  << 2) + 0xd0050000)
+// bit [11:0] top_wrrsp_count
+#define HCODEC_QDCT_TOP_WRRSP                      ((0x1f22  << 2) + 0xd0050000)
+// Bit[3:0] qdct_dbg_idx
+#define HCODEC_QDCT_DBG_IDX                        ((0x1f23  << 2) + 0xd0050000)
+// Read Only
+#define HCODEC_QDCT_DBG_READ                       ((0x1f24  << 2) + 0xd0050000)
+// [19:18] RW jdct_inflow_ctrl. JPEG DCT input flow control.                                Default 0.
+//            0=No halt;
+//            1=DCT halts request at end of each 8x8 block;
+//            2=DCT halts request at end of each MCU.
+// [17:16] RW jpeg_coeff_last_sel.                                                          Default 0.
+//            Select at which point to finish processing, give update to AmRISC so it can control the next step.
+//            0=Mark last coeff at the end of an 8x8 block;
+//            1=Mark at the end of an MCU;
+//            2=Mark at the end of a scan.
+// [   15] RW jpeg_quant_sel_comp2. 0=Comp2 select Quantization table 0; 1=Select table 1.  Default 0.
+// [   14] RW jpeg_v_factor_comp2. Component 2's vertical sampling factor.                  Default 0.
+// [   13] RW jpeg_h_factor_comp2. Component 2's horizontal sampling factor.                Default 0.
+// [   12] RW jpeg_comp2_en. Set 1 if the scan will include component 2 (Cr).               Default 0.
+// [   11] RW jpeg_quant_sel_comp1. 0=Comp1 select Quantization table 0; 1=Select table 1.  Default 0.
+// [   10] RW jpeg_v_factor_comp1. Component 1's vertical sampling factor.                  Default 0.
+// [    9] RW jpeg_h_factor_comp1. Component 1's horizontal sampling factor.                Default 0.
+// [    8] RW jpeg_comp1_en. Set 1 if the scan will include component 1 (Cb).               Default 0.
+// [    7] RW jpeg_quant_sel_comp0. 0=Comp0 select Quantization table 0; 1=Select table 1.  Default 0.
+// [    6] RW jpeg_v_factor_comp0. Component 0's vertical sampling factor.                  Default 0.
+// [    5] RW jpeg_h_factor_comp0. Component 0's horizontal sampling factor.                Default 0.
+// [    4] RW jpeg_comp0_en. Set 1 if the scan will include component 0 (Y).                Default 0.
+// [ 3: 1] RW jdct_intr_sel. JPEG DCT interrupt select.                                     Default 0.
+//            0=Disable intr;
+//            1=Intr at end of each 8x8 block of DCT input;
+//            2=Intr at end of each MCU of DCT input;
+//            3=Intr at end of a scan of DCT input;
+//            4=Intr at end of each 8x8 block of DCT output;
+//            5=Intr at end of each MCU of DCT output;
+//            6=Intr at end of a scan of DCT output.
+// [    0] RW jpeg_en. 0=Disable JPEG QDCT; 1=Enable JPEG QDCT.                             Default 0.
+#define HCODEC_QDCT_JPEG_CTRL                      ((0x1f25  << 2) + 0xd0050000)
+// [29:16] RW jpeg_x_end.   Picture X end.      Default 0.
+// [13: 0] RW jpeg_x_start. Picture X start.    Default 0.
+#define HCODEC_QDCT_JPEG_X_START_END               ((0x1f26  << 2) + 0xd0050000)
+// [29:16] RW jpeg_y_end.   Picture Y end.      Default 0.
+// [13: 0] RW jpeg_y_start. Picture Y start.    Default 0.
+#define HCODEC_QDCT_JPEG_Y_START_END               ((0x1f27  << 2) + 0xd0050000)
+// [    8] RW JPEG QUANT table access mode. 0=Write; 1=Read.    Default 1.
+// [ 5: 0] RW JPEG QUANT table addr.                            Default 0.
+#define HCODEC_QDCT_JPEG_QUANT_ADDR                ((0x1f28  << 2) + 0xd0050000)
+// [31: 0] RW JPEG QUANT table data.
+#define HCODEC_QDCT_JPEG_QUANT_DATA                ((0x1f29  << 2) + 0xd0050000)
+// [    1] W  resume_jdct.
+//            Write 1 to this bit will resume JPEG input engine when previously
+//            it is halted by QDCT_JPEG_CTRL.jdct_inflow_ctrl.
+// [    0] W  jpeg_sof.
+//            Write 1 to this bit will start JPEG input engine.
+#define HCODEC_QDCT_JPEG_SOF_RESUME                ((0x1f2a  << 2) + 0xd0050000)
+// [31:30] R  dct_st.       jdct_ctrl state. 0=IDLE; 1=WAIT; 2=DCT_REQ.
+// [29:28] R  mfdin_comp.   Current component at pixel request to MFDIN.
+// [27:14] R  mfdin_y.      Current Y at pixel request to MFDIN.
+// [13: 0] R  mfdin_x.      Current X at pixel request to MFDIN.
+#define HCODEC_QDCT_JPEG_DCT_STATUS0               ((0x1f2b  << 2) + 0xd0050000)
+// [15:12] R  JPEG Quant read MEM select.
+// [11: 8] R  JPEG DCT2 write MEM select.
+// [ 7: 4] R  JPEG DCT2 read MEM select.
+// [ 3: 0] R  JPEG DCT1 write MEM select.
+#define HCODEC_QDCT_JPEG_DCT_STATUS1               ((0x1f2c  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff1.  Default 13'h1D90; // 7568 = 4096 * sqrt(2) * (cos(Pi/8) + sin(Pi/8)) // 7569
+// [12: 0] RW jdct_coeff0.  Default 13'h16A1; // 5793 = 4096 * sqrt(2)
+#define HCODEC_QDCT_JPEG_DCT_COEFF01               ((0x1f2d  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff3.  Default 13'h0C3F; // 3135 = 4096 * sqrt(2) * (cos(Pi/8) - sin(Pi/8))
+// [12: 0] RW jdct_coeff2.  Default 13'h08A9; // 2217 = 4096 * sqrt(2) * sin(Pi/8) // 2215
+#define HCODEC_QDCT_JPEG_DCT_COEFF23               ((0x1f2e  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff5.  Default 13'h046A; // 1130 = 4096 * (cos(3Pi/16) - sin(3Pi/16))
+// [12: 0] RW jdct_coeff4.  Default 13'h1631; // 5681 = 4096 * (cos(3Pi/16) + sin(3Pi/16)) // 5682
+#define HCODEC_QDCT_JPEG_DCT_COEFF45               ((0x1f2f  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff7.  Default 13'h0C92; // 3218 = 4096 * (cos(Pi/16) - sin(Pi/16))
+// [12: 0] RW jdct_coeff6.  Default 13'h12D0; // 4816 = 4096 * (cos(Pi/16) + sin(Pi/16))
+#define HCODEC_QDCT_JPEG_DCT_COEFF67               ((0x1f30  << 2) + 0xd0050000)
+// [28:16] RW jdct_coeff9.  Default 13'h0FB1; // 4017 = 4096 * cos(Pi/16)
+// [12: 0] RW jdct_coeff8.  Default 13'h0D4E; // 3406 = 4096 * cos(3Pi/16)
+#define HCODEC_QDCT_JPEG_DCT_COEFF89               ((0x1f31  << 2) + 0xd0050000)
+#define HCODEC_QDCT_I_PRED_REF_WR_IDX              ((0x1f32  << 2) + 0xd0050000)
+#define HCODEC_QDCT_I_PRED_REF_WR_DATA             ((0x1f33  << 2) + 0xd0050000)
+// IE/ME share same cbus_base as QDCT
+// 
+// bit[31]  active_ur_block
+// bit[30]  active_ul_block
+// bit[9]   ie_c_wait_ie_pause
+// bit[8:4] max_ie_result_buff_count 
+// bit[3]   ie_wait_for_ie_result  // use for (max_ie_result_buff_count == 0) to wait every block
+// bit[2]   reserved
+// bit[1]   ie_enable
+// bit[0]   ie_soft_reset
+#define HCODEC_IE_CONTROL                          ((0x1f40  << 2) + 0xd0050000)
+// bit[31:12] Reserved
+// bit[11:0]  mb_y
+#define HCODEC_IE_MB_POSITION                      ((0x1f41  << 2) + 0xd0050000)
+// bit[31:16] me_skip_run
+// bit[15:8]  reserved
+// bit [7:4]  me_b8_mode
+// bit [3:0]  ie_me_mb_type
+#define HCODEC_IE_ME_MB_INFO                       ((0x1f42  << 2) + 0xd0050000)
+// bit[3]   ie_result_buff_enable
+// bit[2]   ie_result_buff_soft_reset
+// bit[1]   sad_enable
+// bit[0]   sad_soft_reset
+#define HCODEC_SAD_CONTROL                         ((0x1f43  << 2) + 0xd0050000)
+// bit[31:16] - ie_result_buff_count - read only
+// bit[14:12] -current_ie_result (pred_mode) - read only
+// bit[11]  top_control_data_buff_wr_ptr - rd/wr 
+// bit[10]  top_control_data_buff_rd_ptr - rd/wr 
+// bit[9:5] ie_result_buff_wr_ptr        - rd/wr
+// bit[4:0] ie_result_buff_rd_ptr        - rd/wr
+#define HCODEC_IE_RESULT_BUFFER                    ((0x1f44  << 2) + 0xd0050000)
+// bit[63:0] ie_i4_pred_mode
+#define HCODEC_IE_I4_PRED_MODE_HI                  ((0x1f45  << 2) + 0xd0050000)
+#define HCODEC_IE_I4_PRED_MODE_LO                  ((0x1f46  << 2) + 0xd0050000)
+// bit [31:9] reserved
+// bit [8:4] i_pred_block_number
+// bit [3:0] ie_c_pred_mode
+#define HCODEC_IE_C_PRED_MODE                      ((0x1f47  << 2) + 0xd0050000)
+// 31:16 - Left, 0-select ie_pixel, 1-select mc_data_out
+// 15:0  - Top,  0-select ie_pixel, 1-select mc_data_out
+#define HCODEC_IE_CUR_REF_SEL                      ((0x1f48  << 2) + 0xd0050000)
+// bit[31]  enable_f_skip_1_step_3
+// bit[30]  enable_f_skip_1_step_2
+// bit[29]  enable_f_skip_1_step_1
+// bit[28]  step_3_enable
+// bit[27]  step_2_sub_pixel
+// bit[26]  always_f_skip_step_3 
+// bit[25]  always_f_skip_step_2 
+// bit[24]  always_f_skip_step_1
+// bit[23]  half_pixel_only
+// bit[22:11] reserved
+// bit[10:9] mv_flexable_ctl 00:0x40, 01:0x80, 10:0xc0, 11 : 0x100
+// bit[8]   no_md_ab_rd
+// bit[7]   use_dct_state
+// bit[6]   enable_free_clk_me_ctl
+// bit[5]   enable_free_clk_me_ab
+// bit[4]   enable_free_clk_me_cb
+// bit[3]   reserved
+// bit[2]   me_done_int_enable
+// bit[1]   me_enable
+// bit[0]   me_soft_reset
+#define HCODEC_ME_CONTROL                          ((0x1f49  << 2) + 0xd0050000)
+// bit[31:28] Reserved
+// bit[27:16] me_start_mby
+// bit[15:12] Reserved
+// bit[11:0]  me_start_mbx
+#define HCODEC_ME_START_POSITION                   ((0x1f4a  << 2) + 0xd0050000)
+// bit [31:28] me_status - Read only
+// bit [27:24] me_cb_status  // current buffer
+// bit [23:20] me_ab_status  // anc buffer
+// bit [19]    Reserved
+// bit [18:16] me_ab_wr_ptr  // read only
+// bit [15:4]  me_last_mbx 
+// bit [3:1]   me_ab_rd_ptr  // read only
+// bit [0]     me_action
+#define HCODEC_ME_STATUS                           ((0x1f4b  << 2) + 0xd0050000)
+// all Read-only
+// bit [31:28] Reserved
+// bit [27:16] me_ab_mbx
+// bit [15:14] me_cb_wr_ptr
+// bit [13:12] me_cb_rd_ptr
+// bit [11:0]  me_cb_mbx
+#define HCODEC_ME_DEBUG                            ((0x1f4c  << 2) + 0xd0050000)
+// bit[29:24] step_3_skip_line 
+// bit[23:18] step_2_skip_line 
+// bit[17:12] step_1_skip_line 
+// bit[11:6]  step_0_skip_line 
+// bit[5:0]   read_skip_line 
+#define HCODEC_ME_SKIP_LINE                        ((0x1f4d  << 2) + 0xd0050000)
+// bit 15:13 Reserved
+// bit 12    A_urgent  // default : 0
+// bit 11:6  A_brst_num // default : 0x3f
+// bit 5:0   A_id  // default : 0x23
+#define HCODEC_ME_AB_MEM_CTL                       ((0x1f4e  << 2) + 0xd0050000)
+// bit[31:24] anc_pic_canvas
+// bit[23:12] max_me_mby_num
+// bit[11:0]  max_me_mbx_num 
+#define HCODEC_ME_PIC_INFO                         ((0x1f4f  << 2) + 0xd0050000)
+// bit [23:12] me_sad_enough_1
+// bit [11:0]  me_sad_enough_0
+#define HCODEC_ME_SAD_ENOUGH_01                    ((0x1f50  << 2) + 0xd0050000)
+// bit [23:12] me_sad_enough_3
+// bit [11:0]  me_sad_enough_2
+#define HCODEC_ME_SAD_ENOUGH_23                    ((0x1f51  << 2) + 0xd0050000)
+// bit [21:10] me_step0_big_sad
+// bit [9:5] me_step0_close_mv_y 
+// bit [4:0] me_step0_close_mv_x 
+#define HCODEC_ME_STEP0_CLOSE_MV                   ((0x1f52  << 2) + 0xd0050000)
+// bit[31:24] force_skip_sad_3
+// bit[23:16] force_skip_sad_2
+// bit[15:08] force_skip_sad_1
+// bit[07:00] force_skip_sad_0
+#define HCODEC_ME_F_SKIP_SAD                       ((0x1f53  << 2) + 0xd0050000)
+// bit[31:24] force_skip_weight_3
+// bit[23:16] force_skip_weight_2
+// bit[15:08] force_skip_weight_1
+// bit[07:00] force_skip_weight_0
+#define HCODEC_ME_F_SKIP_WEIGHT                    ((0x1f54  << 2) + 0xd0050000)
+// Merge when (
+//              (flex & me_merge_flex_en) | 
+//              (big_sad & me_merge_sad_en)|
+//              ((~me_merge_flex_en)&(~me_merge_sad_en))
+//            ) & 
+//            ( small_mv_diff |(~me_merge_small_mv_en))
+//            & (me_merge_flex_en | me_merge_sad_en | me_merge_small_mv_en)
+// bit[31]   me_merge_mv_en_16
+// bit[30]   me_merge_small_mv_en_16
+// bit[29]   me_merge_flex_en_16
+// bit[28]   me_merge_sad_en_16
+// bit[27]   me_merge_mv_en_8
+// bit[26]   me_merge_small_mv_en_8
+// bit[25]   me_merge_flex_en_8
+// bit[24]   me_merge_sad_en_8
+// bit[23:18] me_merge_mv_diff_16
+// bit[17:12] me_merge_mv_diff_8
+// bit[11:0] me_merge_min_sad
+#define HCODEC_ME_MV_MERGE_CTL                     ((0x1f55  << 2) + 0xd0050000)
+// bit[31:24] mv_step_weight_1 
+// bit[23:16] mv_pre_weight_1 
+// bit [15:0] mv_step_weight_0
+// bit[7:0]   mv_pre_weight_0 
+#define HCODEC_ME_MV_WEIGHT_01                     ((0x1f56  << 2) + 0xd0050000)
+// bit[31:24] mv_step_weight_3 
+// bit[23:16] mv_pre_weight_3
+// bit[15:8]  mv_step_weight_2 
+// bit[7:0]   mv_pre_weight_2
+#define HCODEC_ME_MV_WEIGHT_23                     ((0x1f57  << 2) + 0xd0050000)
+// bit[31:24] me_sad_range_inc_3
+// bit[23:16] me_sad_range_inc_2
+// bit[15:8] me_sad_range_inc_1
+// bit[7:0] me_sad_range_inc_0
+#define HCODEC_ME_SAD_RANGE_INC                    ((0x1f58  << 2) + 0xd0050000)
+// bit[31:19]  reserved
+// bit[18]     sub_relative_any_1_en
+// bit[17]     sub_relative_any_2_en
+// bit[16]     sub_relative_any_3_en
+// bit[15]     sub_relative_any_4_en
+// bit[14]     sub_relative_any_h_en
+// bit[13]     sub_make_non_flex_fix
+// bit[12]     sub_make_big_non_flex_fix
+// bit[11:8]   sub_normal_mv_diff_16
+// bit[7:4]    sub_normal_mv_diff_8
+// bit[3:2]    Reserved
+// bit[1]      sub_merge_enable_16
+// bit[0]      sub_merge_enable_8
+#define HCODEC_ME_SUB_MERGE_CTL                    ((0x1f59  << 2) + 0xd0050000)
+// bit[31:28]  sub_ref_mv_diff_near
+// bit[27:24]  sub_ref_mv_diff_near_flex
+// bit[23:20]  sub_ref_mv_diff
+// bit[19:16]  sub_ref_mv_diff_flex
+// bit[15:8]   sub_ref_mv_near_weight
+// bit[7:0]    sub_ref_mv_weight
+#define HCODEC_ME_SUB_REF_MV_CTL                   ((0x1f5a  << 2) + 0xd0050000)
+// bit[31:24]  sub_weight_max_sad
+// bit[23:16]  sub_any_range_sad
+// bit[15:8]   sub_any_min_sad
+// bit[7:0]    sub_any_max_sad
+#define HCODEC_ME_SUB_ANY_WEIGHT_SAD               ((0x1f5b  << 2) + 0xd0050000)
+// bit[31:24]  sub_fix_sad
+// bit[23:16]  sub_fix_diff_sad
+// bit[15:8]   sub_sad_flex_adj
+// bit[7:0]    sub_big_non_flex_fix_sad
+#define HCODEC_ME_SUB_FIX_SAD                      ((0x1f5c  << 2) + 0xd0050000)
+// bit[31:24]  sub_fix_min_sad
+// bit[23:16]  sub_fix_min_diff_sad
+// bit[15:8]   sub_fix_min_sad_2
+// bit[7:0]    sub_fix_min_diff_sad_2
+#define HCODEC_ME_SUB_FIX_MIN_SAD                  ((0x1f5d  << 2) + 0xd0050000)
+// bit[31:24]  sub_snap_to_ref_max_sad
+// bit[23]     sub_snap_to_ref_non_flex
+// bit[22:16]  sub_snap_to_ref_mv_diff
+// bit[15:4]   sub_glitch_mv_sad
+// bit[3:0]    sub_glitch_mv_diff
+#define HCODEC_ME_SUB_SNAP_GLITCH                  ((0x1f5e  << 2) + 0xd0050000)
+// bit[31:20]  sad_act_limit
+// bit[19:8]   s_a_any_sad
+// bit[7]      Reserved
+// bit[6:5]    sub_merge_method
+// bit[4]      use_sub_act_result
+// bit[3]      s_a_rnd
+// bit[2]      Reserved
+// bit[1]      sub_act_en_16
+// bit[0]      sub_act_en
+#define HCODEC_ME_SUB_ACT_CTL                      ((0x1f5f  << 2) + 0xd0050000)
+//
+// Closing file:  qdct_regs.h
+//
+
+#endif // DOS_REGISTER_H
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/ucode/hdmitx.h b/arch/arm/mach-mesong9tv/tools/genregs/ucode/hdmitx.h
new file mode 100644
index 000000000000..4621c32f9dd4
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/ucode/hdmitx.h
@@ -0,0 +1,85 @@
+#ifndef HDMITX_H
+#define HDMITX_H
+
+// Device ID to differentiate HDMITX register access to TOP or DWC
+#define HDMITX_DEV_ID_TOP       0
+#define HDMITX_DEV_ID_DWC       1
+
+#define HDMITX_ADDR_PORT        0xd0042000  // TOP ADDR_PORT: 0xd0042000; DWC ADDR_PORT: 0xd0042010
+#define HDMITX_DATA_PORT        0xd0042004  // TOP DATA_PORT: 0xd0042004; DWC DATA_PORT: 0xd0042014
+#define HDMITX_CTRL_PORT        0xd0042008  // TOP CTRL_PORT: 0xd0042008; DWC CTRL_PORT: 0xd0042018
+
+#define INT_HDMITX_BASE_OFFSET  0x00000000  // INT TOP ADDR_PORT: 0xd0042000; INT DWC ADDR_PORT: 0xd0042010
+#define EXT_HDMITX_BASE_OFFSET  0x00000020  // EXT TOP ADDR_PORT: 0xd0042020; EXT DWC ADDR_PORT: 0xd0042030
+
+// Use the following functions to access the on-chip HDMITX modules by default
+extern void             hdmitx_wr_only_TOP (unsigned long base_offset, unsigned long addr, unsigned long data);
+extern void             hdmitx_wr_only_DWC (unsigned long base_offset, unsigned long addr, unsigned long data);
+extern void             hdmitx_wr_only_reg (unsigned long base_offset, unsigned char dev_id, unsigned long addr, unsigned long data);
+extern unsigned long    hdmitx_rd_TOP (unsigned long base_offset, unsigned long addr);
+extern unsigned long    hdmitx_rd_DWC (unsigned long base_offset, unsigned long addr);
+extern unsigned long    hdmitx_rd_reg (unsigned long base_offset, unsigned char dev_id, unsigned long addr);
+extern void             hdmitx_rd_check_TOP (unsigned long base_offset, unsigned long addr, unsigned long exp_data, unsigned long mask);
+extern void             hdmitx_rd_check_DWC (unsigned long base_offset, unsigned long addr, unsigned long exp_data, unsigned long mask);
+extern void             hdmitx_rd_check_reg (unsigned long base_offset, unsigned char dev_id, unsigned long addr, unsigned long exp_data, unsigned long mask);
+extern void             hdmitx_wr_TOP (unsigned long base_offset, unsigned long addr, unsigned long data);
+extern void             hdmitx_wr_DWC (unsigned long base_offset, unsigned long addr, unsigned long data);
+extern void             hdmitx_wr_reg (unsigned long base_offset, unsigned char dev_id, unsigned long addr, unsigned long data);
+extern void             hdmitx_poll_TOP (unsigned long base_offset, unsigned long addr, unsigned long exp_data, unsigned long mask);
+extern void             hdmitx_poll_DWC (unsigned long base_offset, unsigned long addr, unsigned long exp_data, unsigned long mask, unsigned long max_try);
+extern void             hdmitx_poll_reg (unsigned long base_offset, unsigned char dev_id, unsigned long addr, unsigned long exp_data, unsigned long mask);
+
+// Use the following functions to access the off-chip HDMI modules by default, input address the same as on-chip HDMI's,
+// the regisers accessed by these functions only exist in a simulation environment.
+
+
+
+extern void set_hdmi_audio_source (unsigned int src);
+
+extern void config_hdmi20_tx (  unsigned long   base_offset,            // Int/Ext TX address offset. =0 for internal TX; =0x20 for external TX (sim model).
+                                unsigned char   pixel_repeat,
+                                unsigned char   color_depth,            // Pixel bit width: 4=24-bit; 5=30-bit; 6=36-bit; 7=48-bit.
+                                unsigned char   input_color_format,     // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                                unsigned char   input_color_range,      // Pixel range: 0=limited; 1=full.
+                                unsigned char   output_color_format,    // Pixel format: 0=RGB444; 1=YCbCr422; 2=YCbCr444; 3=YCbCr420.
+                                unsigned char   output_color_range,     // Pixel range: 0=limited; 1=full.
+                                unsigned char   vic,                    // Video format identification code
+                                unsigned char   interlace,              // 0=Progressive; 1=Interlaced.
+                                unsigned char   vs_in_pol,              // VSync input polarity: 0=active low; 1=active high.
+                                unsigned char   hs_in_pol,              // HSync input polarity: 0=active low; 1=active high.
+                                unsigned long   active_pixels,          // Number of active pixels per line
+                                unsigned long   blank_pixels,           // Number of blank pixels per line
+                                unsigned long   active_lines,           // Number of active lines per field
+                                unsigned long   blank_lines,            // Number of blank lines per field
+                                unsigned long   front_porch,            // Number of pixels from DE end to HS start
+                                unsigned long   hsync_pixels,           // Number of pixels of HS pulse width
+                                unsigned long   eof_lines,              // HS count between last active line and start of VS.
+                                unsigned long   vsync_lines,            // HS count of VS width
+                                unsigned char   scrambler_en,
+                                unsigned char   tmds_clk_div4,          // 0:TMDS_CLK_rate=TMDS_Character_rate; 1:TMDS_CLK_rate=TMDS_Character_rate/4, for TMDS_Character_rate>340Mcsc.
+                                unsigned long   aud_n,                  // ACR N
+                                unsigned char   i2s_spdif,              // 0=SPDIF; 1=I2S. Note: Must select I2S if CHIP_HAVE_HDMI_RX is defined.
+                                unsigned char   i2s_8chan,              // 0=I2S 2-channel; 1=I2S 4 x 2-channel.
+                                unsigned char   audio_packet_type,      // 2=audio sample packet; 7=one bit audio; 8=DST audio packet; 9=HBR audio packet.
+                                unsigned char   hdcp_on,
+                                unsigned char   hdcp_an_sw,             // 0=AN is from HW; 1=AN is from SW register.
+                                unsigned long   hdcp_an_sw_val_hi,      // SW defined AN[63:32]
+                                unsigned long   hdcp_an_sw_val_lo);     // SW defined AN[31:0]
+
+extern void hdmi20_tx_read_edid (   unsigned long   base_offset,    // Int/Ext TX address offset. =0 for internal TX; =0x20 for external TX (sim model).
+                                    unsigned char*  rx_edid);
+
+extern unsigned long    hdmitx_scdc_rd          (unsigned long base_offset, unsigned long addr);
+extern void             hdmitx_scdc_rd_check    (unsigned long base_offset, unsigned long addr, unsigned long exp_data, unsigned long mask);
+extern void             hdmitx_scdc_wr_only     (unsigned long base_offset, unsigned long addr, unsigned long data);
+extern void             hdmitx_scdc_wr          (unsigned long base_offset, unsigned long addr, unsigned long data);
+
+// Internal functions:
+void hdmitx_csc_config (unsigned long base_offset,          // Int/Ext TX address offset. =0 for internal TX; =0x20 for external TX (sim model).
+                        unsigned char input_color_format,
+                        unsigned char output_color_format,
+                        unsigned char color_depth);
+void configure_hdcp_dpk (   unsigned long base_offset,      // Int/Ext TX address offset. =0 for internal TX; =0x20 for external TX (sim model).
+                            unsigned long sw_enc_key);
+
+#endif  /* HDMITX_H */
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/ucode/register.h b/arch/arm/mach-mesong9tv/tools/genregs/ucode/register.h
new file mode 100644
index 000000000000..cb6291b404f8
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/ucode/register.h
@@ -0,0 +1,12778 @@
+// ----------------------------------------------------------------------
+// This file is automatically generated from the script:
+// 
+// ./create_headers_from_register_map_h.pl
+// 
+// and was applied to the file
+// 
+// ./register_map.h
+// 
+// DO NOT EDIT!!!!!
+// ----------------------------------------------------------------------
+// 
+#ifdef REGISTER_H
+#else
+#define REGISTER_H
+
+
+#include "dos_register.h"
+#define Wr(addr, data) *(volatile unsigned long *)(addr)=(data)
+#define Rd(addr) *(volatile unsigned long *)(addr)
+#define Wr_reg_bits(reg, val, start, len) \
+  Wr(reg, ((Rd(reg) & ~(((1L<<(len))-1)<<(start))) | ((unsigned int)(val) << (start))))
+
+//
+// Reading file:  ./register_map.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Reading file:  stb_define.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  STB_CBUS_BASE = 0x16
+// -----------------------------------------------
+// There are two instantiations under one CBUS slave.  Each CBUS slave can support
+// 256 registers.  Each demux is allocated 128 registers so set the offset in
+// the middle
+// Copy this define but don't add a base address
+#define SECOND_DEMUX_OFFSET_0  0x50
+#define THIRD_DEMUX_OFFSET_0   0xa0
+//========================================================================
+//  STB TOP Registers				    (8'hf0 - 8'hf7)
+//========================================================================
+// bit 30:28 -- ciplus_o_sel
+// bit 27:26 -- ciplus_i_sel
+// bit 25 -- use FAIL fro TS2
+// bit 24 -- use FAIL fro TS1
+// bit 23 -- use FAIL fro TS0
+// bit 22 -- invert fec_error for S2P1
+// bit 21 -- invert fec_data for S2P1
+// bit 20 -- invert fec_sync for S2P1
+// bit 19 -- invert fec_valid for S2P1
+// bit 18 -- invert fec_clk for S2P1
+// bit 17:16 -- fec_s_sel for S2P1  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
+// Bit 15 -- enable_des_pl_clk
+// Bit 14:13 -- reserved
+// Bit 12:10 -- ts_out_select, 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File
+// bit 9:8 -- des_i_sel 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
+// bit 7 -- enable_des_pl
+// bit 6 -- invert fec_error for S2P0
+// bit 5 -- invert fec_data for S2P0
+// bit 4 -- invert fec_sync for S2P0
+// bit 3 -- invert fec_valid for S2P0
+// bit 2 -- invert fec_clk for S2P0
+// bit 1:0 -- fec_s_sel for S2P0  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
+#define STB_TOP_CONFIG                             ((0x16f0  << 2) + 0xc1100000)
+// 31:28 - s2p1_clk_div
+// 27:24 - s2p0_clk_div
+// 23    - s2p1_disable
+// 22    - s2p0_disable
+// 21    - Reserved
+// 20 -- TS_OUT_error_INVERT
+// 19 -- TS_OUT_data_INVERT
+// 18 -- TS_OUT_sync_INVERT
+// 17 -- TS_OUT_valid_INVERT
+// 16 -- TS_OUT_clk_INVERT
+// 15:8 -- TS_package_length_sub_1 (default : 187)
+//  7:0 -- fec_sync_byte (default : 0x47)
+#define TS_TOP_CONFIG                              ((0x16f1  << 2) + 0xc1100000)
+// Bit 23:16 -- file_m2ts_skip_bytes
+// Bit 15:8 -- des_out_dly
+// Bit 7:6 -- transport_scrambling_control_odd // should be 3
+// Bit 5 -- ts_hiu_enable
+// Bit 4:0 -- fec_clk_div
+#define TS_FILE_CONFIG                             ((0x16f2  << 2) + 0xc1100000)
+// Bit 13:8 -- des ts pl state   -- Read Only
+// Bit 3:0 PID index to 8 PID to get key-set
+// auto increse after TS_PL_PID_DATA read/write
+#define TS_PL_PID_INDEX                            ((0x16f3  << 2) + 0xc1100000)
+// Bit 13 -- PID match disble
+// Bit 12:0 -- PID
+#define TS_PL_PID_DATA                             ((0x16f4  << 2) + 0xc1100000)
+#define COMM_DESC_KEY0                             ((0x16f5  << 2) + 0xc1100000)
+#define COMM_DESC_KEY1                             ((0x16f6  << 2) + 0xc1100000)
+#define COMM_DESC_KEY_RW                           ((0x16f7  << 2) + 0xc1100000)
+// CI+ Register defines
+// Bits[31:0] of the key
+#define CIPLUS_KEY0                                ((0x16f8  << 2) + 0xc1100000)
+// Bits[63:32] of the key
+#define CIPLUS_KEY1                                ((0x16f9  << 2) + 0xc1100000)
+// Bits[95:64] of the key
+#define CIPLUS_KEY2                                ((0x16fa  << 2) + 0xc1100000)
+// Bits[127:96] of the key
+#define CIPLUS_KEY3                                ((0x16fb  << 2) + 0xc1100000)
+// bit[5] write AES IV B value
+// bit[4] write AES IV A value
+// bit[3] write AES B key
+// bit[2] write AES A key
+// bit[1] write DES B key
+// bit[0] write DES A key
+#define CIPLUS_KEY_WR                              ((0x16fc  << 2) + 0xc1100000)
+// [15:8]   TS out delay.  This controls the rate at which the CIplus module drives TS out
+// [3]      General enable for the ciplus module
+// [2]      AES CBC disable (default should be 0 to enable AES CBC)
+// [1]      AES Enable
+// [0]      DES Eanble
+#define CIPLUS_CONFIG                              ((0x16fd  << 2) + 0xc1100000)
+// bit[31:28] AES IV endian
+// bit[27:24] AES message out endian
+// bit[23:20] AES message in endian
+// bit[19:16] AES key endian
+// bit[15:11]  unused
+// bit[10:8]  DES message out endian
+// bit[6:4]   DES message in endian
+// bit[2:0]   DES key endian
+#define CIPLUS_ENDIAN                              ((0x16fe  << 2) + 0xc1100000)
+//
+// NOTE:  Don't process the demux registers using the standard create_headers.... perl script.
+//        Instead, since the demux has multiple instances (and many registers) use a separate
+//        script to create a separate stb_define.h for C-code.  
+//========================================================================
+//  STB Registers				    (8'h00 - 8'h4f)
+//
+//========================================================================
+// STB registers are 8'h0x
+// Bit 15:0 -- version number : 0x0002  (v0.01)
+// Bit 15 -- fec_core_select 1 - select descramble output
+// Bit 14:12 -  fec_select 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File 
+// Bit 11 -- FEC_CLK
+// Bit 10 -- SOP
+// Bit 9 -- D_VALID
+// Bit 8 -- D_FAIL
+// Bit 7:0 -- D_DATA 7:0
+// bit 31 -- enable_free_clk_fec_data_valid
+// bit 30 -- enable_free_clk_stb_reg
+// bit 29 -- reserved
+// bit 28 -- disable_pre_incomplete_section_fix
+// bit 27 -- pointer_field_multi_pre_en
+// bit 26 -- ignore_pre_incomplete_section
+// bit 25 -- video2_enable
+// bit 24:22 -- video2_type
+// bit 21 -- do_not_trust_pes_package_length
+// bit 20 (bit 4) -- Bypass use recoder path
+// bit 19 (bit 3) -- clear_PID_continuity_counter_valid
+// bit 18 (bit 2) -- Disable Splicing
+// bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES
+// bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES
+// Bit 15 - do not trust section length
+// Bit 14 - om cmd push even zero
+// Bit 13 - reserved
+// Bit 12 - SUB, OTHER PES interrupt at beginning of PES
+// Bit 11 - discard_av_package -- for ts_recorder use only 
+// Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter
+// Bit 9 - ts_recorder_enable
+// Bit 8 - (table_id == 0xff) means section_end
+// Bit 7 - do not send uncomplete section
+// Bit 6 - do not discard duplicate package
+// Bit 5 - search SOP when trasport_error_indicator
+// Bit 4 - stb demux enable
+// Bit 3 - do not reset state machine on SOP
+// Bit 2 - search SOP when error happened ( when ignore_fail_n_sop, will have this case)
+// Bit 1 - do not use SOP input ( check FEC sync byte instead )
+// Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)
+// bit 15:8 demux package length - 1 ( default : 187 )
+// bit 7:0 default is 0x47
+// bit 31:16 -- filter memory write data hi[31:16]
+// bit 15:0 -- filter memory write data low [15:0]
+// bit 31:24 -- advanced setting hi
+// bit 23:16 -- advanced setting low
+// bit 15 -- filter memory write data request
+// bit 7:0 -- filter memory write addr
+// bit 13:8 demux state  -- read only
+// bit 7:4 -- maxnum section filter compare address
+// bit 3:0 -- maxnum PID filter compare address
+// bit 15 - transport_error_indicator
+// bit 14 - payload_unit_start_indicator
+// bit 13 - transport_priority
+// bit 12:0 - PID
+// bit 7:6 transport_scrambling_control
+// bit 5:4 adaptation_field_control
+// bit 3:0 continuity_counter
+// bit 15:12 -- om_cmd_count (read only)
+// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
+// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
+// bit   5:3 -- type_stb_om_w_rd (read only)
+// bit     2 -- unit_start_stb_om_w_rd (read only)
+// bit     1 -- om_cmd_overflow (read only)
+// bit     0 -- om_cmd_pending (read) 
+// bit     0 -- om_cmd_read_finished (write)
+// bit 15:9 // bit 14:8 -- count_stb_om_w_rd  (read only)
+// bit 8:0  // bit  7:0 -- start_stb_om_wa_rd (read only)
+// bit 11:0 -- offset for section data
+// bit 31:16 -- base address for section buffer group 0 (*0x400 to get real address)
+// bit 15:0 -- base address for section buffer group 1 (*0x400 to get real address)
+// bit 31:16 -- ba2e address for section buffer group 2 (*0x400 to get real address)
+// bit 15:0 -- base address for section buffer group 3 (*0x400 to get real address)
+// bit 3:0 -- section buffer size for group 0 (bit used,  for example, 10 means 1K)
+// bit 7:4 -- section buffer size for group 1
+// bit 11:8 -- section buffer size for group 2
+// bit 15:12 -- section buffer size for group 3
+// section buffer busy status for buff 31:0 ( Read Only )
+// section buffer write status for buff 31:0 -- Read
+// clear buffer status ( buff READY and BUSY ) -- write
+// bit 4:0 -- SEC_BUFFER_INDEX   RW
+// bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only
+// bit 14 -- output_section_buffer_valid
+// bit 15 -- section_reset_busy (Read Only)
+// bit 9:5 -- BYPASS PID number
+// bit 4:0 -- PCR PID number
+// bit 15:0 -- stream_id filter bit enable
+// bit 7:0 -- stream_id filter target
+// bit 12 -- PCR_EN
+// bit 11:0 -- PCR90K_DIV
+// bit 15:0 -- PCR[31:0] R/W
+// bit 15:0 -- VPTS[31:0] R/W
+// bit 15:0 -- VDTS[31:0] R/W
+// bit 15:0 -- APTS[31:0] R/W
+// bit 15:0 -- SPTS[31:0] R/W
+// read -- status, write 1 clear status
+// bit 15 -- SUB_PTS[32]
+// bit 14 -- AUDIO_PTS[32]
+// bit 13 -- VIDEO_DTS[32]
+// bit 12 -- VIDEO_PTS[32]
+// bit 3 -- sub_pts_ready
+// bit 2 -- audio_pts_ready
+// bit 1 -- video_dts_ready
+// bit 0 -- video_pts_ready
+// bit 3:0 --
+//  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0] 
+//  1 -- stream_id[7:0], pes_header_bytes_left[7:0]
+//  2 -- pes_package_bytes_left[15:0]
+//  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]
+// 
+// read only
+// default : 0x807f
+// bit 15:9  -- MAX OM DMA COUNT  (default: 0x40) 
+// bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)
+// 15:0  WRITE 1 CLEAR to clear interrupt source
+// 9 -- splicing_point
+// 8 -- other_PES_int
+// 7 -- sub_PES_int 
+// 6 -- discontinuity
+// 5 -- duplicated_pack_found
+// 4 -- New PDTS ready
+// 3 -- om_cmd_buffer ready for access
+// 2 -- section buffer ready 
+// 1 -- transport_error_indicator
+// 0 -- TS ERROR PIN 
+// Bit 5:3 - demux om write endian control for bypass
+// Bit 2:0 - demux om write endian control for section
+// When Bit 31 - 1 write will indicate all type use sepertate endian (Write Only)
+// Bit 23:21 - demux om write endian control for OTHER_PES_PACKET
+// Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET
+// Bit 17:15 - demux om write endian control for SUB_PACKET
+// Bit 14:12 - demux om write endian control for AUDIO_PACKET
+// Bit 11:9  - demux om write endian control for VIDEO_PACKET
+// 
+// When Bit 31 - 0 write will indicate all type else use Bit 8:6
+// Bit 8:6 - demux om write endian control for else
+// Bit 15:8 -- last_burst_threshold
+// Bit 7 -- use hi_bsf interface
+// Bit 6:2 - fec_clk_div
+// Bit 1 ts_source_sel 
+// Bit 0 - Hiu TS generate enable 
+// bit 15:0 -- base address for section buffer start (*0x10000 to get real base)
+// bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN
+// bit 10 -- mask bit for SUB_AHB_DMA_EN
+// bit 9 -- mask bit for BYPASS_AHB_DMA_EN
+// bit 8 -- mask bit for SECTION_AHB_DMA_EN
+// bit 7 -- mask bit for recoder stream
+// bit 6:0 -- mask bit for each type
+// bit 31:0 -- vb_wr_ptr for video PDTS 
+// bit 31:0 -- ab_wr_ptr for audio PDTS
+// bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)
+// bit 19:0 -- SB_START (sb_start << 12 == byte address);  
+// bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun) 
+// bit 31:0 -- sb_wr_ptr for sub PES
+// bit 31:16 -- ob_wr_ptr for other PES
+// bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)
+// bit 19:0 -- OB_START (ob_start << 12 == byte address);  
+// bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun) 
+// bit 31:0 -- ob_wr_ptr for sub PES
+// 15:0  DEMUX interrupt MASK
+// 9 -- splicing_point
+// 8 -- other_PES_int
+// 7 -- sub_PES_int 
+// 6 -- discontinuity
+// 5 -- duplicated_pack_found
+// 4 -- New PDTS ready
+// 3 -- om_cmd_buffer ready for access
+// 2 -- section buffer ready 
+// 1 -- transport_error_indicator
+// 0 -- TS ERROR PIN 
+// 31:16 VIDEO PID filter data
+//15 -- splicing VIDEO PID change enable 
+//14:10 -- VIDEO PID FILTER ADDRESS
+// 9 -- PES splicing active (Read Only) 
+// 8 -- splicing active (Read Only)
+// 7:0  splicing countdown (Read Only)
+// 31:16 AUDIO PID filter data
+//15 -- splicing AUDIO PID change enable 
+//14:10 -- AUDIO PID FILTER ADDRESS
+// 9 -- PES splicing active (Read Only) 
+// 8 -- splicing active (Read Only)
+// 7:0  splicing countdown (Read Only)
+// 23:16 M2TS_SKIP_BYTES
+// 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)
+// 7:0  PACKAGE BYTE COUNT (Read Only)
+// 15:0 2 bytes strong sync add to PES
+// bit 15 -- stb_om_ren
+// bit 14:11 -- reserved
+// bit  10:0 -- OM_DATA_RD_ADDR
+// bit 15:0 -- OM_DATA_RD
+// AUTO STOP SETTING for 32 channels
+// 4-nbits per channel
+// when write
+// bit 3 -- set section active
+// bit 2:0 -- auto stop after count (0 means never stop)
+// when read
+// bit 3 -- current active status (1 - active, 0 - stopped )
+// bit 2:0 -- count down to auto stop
+// section 31:24
+// section 23:16
+// section 15:8
+// section 7:0
+// bit 31:0 reset channel status - each bit reset each channel 
+// read -- 32 channel status 
+// bit 4 -- video_stamp_use_dts
+// bit 3 -- audio_stamp_sync_1_en 
+// bit 2 -- audio_stamp_insert_en 
+// bit 1 -- video_stamp_sync_1_en 
+// bit 0 -- video_stamp_insert_en 
+// Write : Bit[4:0] secter filter number for reset
+// Read  : select according to output_section_buffer_valid : 
+//         per bit per section buffer valid status
+//         or section_buffer_ignore
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  stb_define.h
+//
+//
+// Reading file:  periphs_reg.h
+//
+// $periphs/rtl/periphs_core register defines for the 
+// APB bus
+// -------------------------------------------------------------------
+// PSEL Group #0:  0x000 ~ 0xFF
+// -------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PERIPHS0_CBUS_BASE = 0x20
+// -----------------------------------------------
+// The following are handled by $periphs/rtl/periphs_reg.v
+#define PREG_CTLREG0_ADDR                          ((0x2000  << 2) + 0xc1100000)
+// ----------------------------
+#define PREG_PAD_GPIO6_EN_N                        ((0x2008  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO6_O                           ((0x2009  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO6_I                           ((0x200a  << 2) + 0xc1100000)
+// ----------------------------
+// ----------------------------
+#define PREG_JTAG_GPIO_ADDR                        ((0x200b  << 2) + 0xc1100000)
+// ----------------------------
+// Pre-defined GPIO addresses
+// ----------------------------
+#define PREG_PAD_GPIO0_EN_N                        ((0x200c  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO0_O                           ((0x200d  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO0_I                           ((0x200e  << 2) + 0xc1100000)
+// ----------------------------
+#define PREG_PAD_GPIO1_EN_N                        ((0x200f  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO1_O                           ((0x2010  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO1_I                           ((0x2011  << 2) + 0xc1100000)
+// ----------------------------
+#define PREG_PAD_GPIO2_EN_N                        ((0x2012  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO2_O                           ((0x2013  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO2_I                           ((0x2014  << 2) + 0xc1100000)
+// ----------------------------
+#define PREG_PAD_GPIO3_EN_N                        ((0x2015  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO3_O                           ((0x2016  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO3_I                           ((0x2017  << 2) + 0xc1100000)
+// ----------------------------
+#define PREG_PAD_GPIO4_EN_N                        ((0x2018  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO4_O                           ((0x2019  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO4_I                           ((0x201a  << 2) + 0xc1100000)
+// ----------------------------
+#define PREG_PAD_GPIO5_EN_N                        ((0x201b  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO5_O                           ((0x201c  << 2) + 0xc1100000)
+#define PREG_PAD_GPIO5_I                           ((0x201d  << 2) + 0xc1100000)
+// ----------------------------
+// A9 and L2 cache
+// ----------------------------
+#define A9_STATUS1                                 ((0x201f  << 2) + 0xc1100000)
+#define A9_CFG0                                    ((0x2020  << 2) + 0xc1100000)
+#define A9_CFG1                                    ((0x2021  << 2) + 0xc1100000)
+#define A9_CFG2                                    ((0x2022  << 2) + 0xc1100000)
+#define A9_PERIPH_BASE                             ((0x2023  << 2) + 0xc1100000)
+#define A9_L2_REG_BASE                             ((0x2024  << 2) + 0xc1100000)
+#define A9_L2_STATUS                               ((0x2025  << 2) + 0xc1100000)
+#define A9_POR_CFG                                 ((0x2026  << 2) + 0xc1100000)
+#define A9_STATUS2                                 ((0x2027  << 2) + 0xc1100000)
+#define AXI_REG_EN                                 ((0x2028  << 2) + 0xc1100000)
+#define A9_CFG3                                    ((0x2029  << 2) + 0xc1100000)
+#define A9_CFG4                                    ((0x202a  << 2) + 0xc1100000)
+#define A9_STATUS3                                 ((0x202b  << 2) + 0xc1100000)
+// ----------------------------
+// Pin Mux  (9)
+// ----------------------------
+#define PERIPHS_PIN_MUX_0                          ((0x202c  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_1                          ((0x202d  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_2                          ((0x202e  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_3                          ((0x202f  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_4                          ((0x2030  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_5                          ((0x2031  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_6                          ((0x2032  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_7                          ((0x2033  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_8                          ((0x2034  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_9                          ((0x2035  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_10                         ((0x2036  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_11                         ((0x2037  << 2) + 0xc1100000)
+#define PERIPHS_PIN_MUX_12                         ((0x2038  << 2) + 0xc1100000)
+// ----------------------------
+// Pad conntrols
+// ----------------------------
+#define PAD_PULL_UP_REG6                           ((0x2039  << 2) + 0xc1100000)
+#define PAD_PULL_UP_REG0                           ((0x203a  << 2) + 0xc1100000)
+#define PAD_PULL_UP_REG1                           ((0x203b  << 2) + 0xc1100000)
+#define PAD_PULL_UP_REG2                           ((0x203c  << 2) + 0xc1100000)
+#define PAD_PULL_UP_REG3                           ((0x203d  << 2) + 0xc1100000)
+#define PAD_PULL_UP_REG4                           ((0x203e  << 2) + 0xc1100000)
+#define PAD_PULL_UP_REG5                           ((0x203f  << 2) + 0xc1100000)
+// ----------------------------
+// Random (2)
+// ----------------------------
+#define RAND64_ADDR0                               ((0x2040  << 2) + 0xc1100000)
+#define RAND64_ADDR1                               ((0x2041  << 2) + 0xc1100000)
+// ---------------------------
+// Ethernet (1)
+// ----------------------------
+#define PREG_ETHERNET_ADDR0                        ((0x2042  << 2) + 0xc1100000)
+// ---------------------------
+// AM_ANALOG_TOP
+// ----------------------------
+#define PREG_AM_ANALOG_ADDR                        ((0x2043  << 2) + 0xc1100000)
+// ---------------------------
+// Mali55 (1)
+// ----------------------------
+#define PREG_MALI_BYTE_CNTL                        ((0x2044  << 2) + 0xc1100000)
+// ---------------------------
+// WIFI (1)
+// ----------------------------
+#define PREG_WIFI_CNTL                             ((0x2045  << 2) + 0xc1100000)
+#define PAD_PULL_UP_EN_REG0                        ((0x2048  << 2) + 0xc1100000)
+#define PAD_PULL_UP_EN_REG1                        ((0x2049  << 2) + 0xc1100000)
+#define PAD_PULL_UP_EN_REG2                        ((0x204a  << 2) + 0xc1100000)
+#define PAD_PULL_UP_EN_REG3                        ((0x204b  << 2) + 0xc1100000)
+#define PAD_PULL_UP_EN_REG4                        ((0x204c  << 2) + 0xc1100000)
+#define PAD_PULL_UP_EN_REG5                        ((0x204d  << 2) + 0xc1100000)
+#define PAD_PULL_UP_EN_REG6                        ((0x204e  << 2) + 0xc1100000)
+// ---------------------------
+// SATA 
+// ----------------------------
+#define PREG_ETH_REG0                              ((0x2050  << 2) + 0xc1100000)
+#define PREG_ETH_REG1                              ((0x2051  << 2) + 0xc1100000)
+// `define PREG_SATA_REG2                      8'h52
+// `define PREG_SATA_REG3                      8'h53
+// `define PREG_SATA_REG4                      8'h54
+// `define PREG_SATA_REG5                      8'h55
+// ---------------------------
+// Generic production test
+// ----------------------------
+#define PROD_TEST_REG0                             ((0x2060  << 2) + 0xc1100000)
+#define PROD_TEST_REG1                             ((0x2061  << 2) + 0xc1100000)
+#define PROD_TEST_REG2                             ((0x2062  << 2) + 0xc1100000)
+#define PROD_TEST_REG3                             ((0x2063  << 2) + 0xc1100000)
+// ---------------------------
+// am_analog_top
+// ----------------------------
+#define METAL_REVISION                             ((0x206a  << 2) + 0xc1100000)
+#define ADC_TOP_MISC                               ((0x206b  << 2) + 0xc1100000)
+#define DPLL_TOP_MISC                              ((0x206c  << 2) + 0xc1100000)
+#define ANALOG_TOP_MISC                            ((0x206d  << 2) + 0xc1100000)
+#define AM_ANALOG_TOP_REG0                         ((0x206e  << 2) + 0xc1100000)
+#define AM_ANALOG_TOP_REG1                         ((0x206f  << 2) + 0xc1100000)
+// ---------------------------
+// Sticky regs
+// ----------------------------
+#define PREG_STICKY_REG0                           ((0x207c  << 2) + 0xc1100000)
+#define PREG_STICKY_REG1                           ((0x207d  << 2) + 0xc1100000)
+#define PREG_WRITE_ONCE_REG                        ((0x207e  << 2) + 0xc1100000)
+// ---------------------------
+// AM Ring Oscillator 
+// ----------------------------
+#define AM_RING_OSC_REG0                           ((0x207f  << 2) + 0xc1100000)
+// Control whether to provide random number to HDMITX20
+#define HDMITX20_RNDNUM                            ((0x2080  << 2) + 0xc1100000)
+// -------------------------------------------------------------------
+// PSEL Group #1:  0x400 ~ 0x7FF
+// -------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PERIPHS1_CBUS_BASE = 0x21
+// -----------------------------------------------
+// ----------------------------
+// $usb/rtl/usb_reg.v   (8)
+// ----------------------------
+// Moved to base 8'h22
+// `define USB_ADDR0                      8'h00
+// `define USB_ADDR1                      8'h01
+// `define USB_ADDR2                      8'h02
+// `define USB_ADDR3                      8'h03
+// `define USB_ADDR4                      8'h04
+// `define USB_ADDR5                      8'h05
+// `define USB_ADDR6                      8'h06
+// `define USB_ADDR7                      8'h07
+// `define USB_ADDR8                      8'h08
+// `define USB_ADDR9                      8'h09
+// `define USB_ADDR10                     8'h0a
+// `define USB_ADDR11                     8'h0b
+// `define USB_ADDR12                     8'h0c
+// `define USB_ADDR13                     8'h0d
+// `define USB_ADDR14                     8'h0e
+// `define USB_ADDR15                     8'h0f
+// ----------------------------
+// Smart Card (8)
+// ----------------------------
+#define SMARTCARD_REG0                             ((0x2110  << 2) + 0xc1100000)
+#define SMARTCARD_REG1                             ((0x2111  << 2) + 0xc1100000)
+#define SMARTCARD_REG2                             ((0x2112  << 2) + 0xc1100000)
+#define SMARTCARD_STATUS                           ((0x2113  << 2) + 0xc1100000)
+#define SMARTCARD_INTR                             ((0x2114  << 2) + 0xc1100000)
+#define SMARTCARD_REG5                             ((0x2115  << 2) + 0xc1100000)
+#define SMARTCARD_REG6                             ((0x2116  << 2) + 0xc1100000)
+#define SMARTCARD_FIFO                             ((0x2117  << 2) + 0xc1100000)
+#define SMARTCARD_REG8                             ((0x2118  << 2) + 0xc1100000)
+// ----------------------------
+// IR Remote (8)
+// ----------------------------
+#define IR_DEC_LDR_ACTIVE                          ((0x2120  << 2) + 0xc1100000)
+#define IR_DEC_LDR_IDLE                            ((0x2121  << 2) + 0xc1100000)
+#define IR_DEC_LDR_REPEAT                          ((0x2122  << 2) + 0xc1100000)
+#define IR_DEC_BIT_0                               ((0x2123  << 2) + 0xc1100000)
+#define IR_DEC_REG0                                ((0x2124  << 2) + 0xc1100000)
+#define IR_DEC_FRAME                               ((0x2125  << 2) + 0xc1100000)
+#define IR_DEC_STATUS                              ((0x2126  << 2) + 0xc1100000)
+#define IR_DEC_REG1                                ((0x2127  << 2) + 0xc1100000)
+// ----------------------------
+// Demod Sampling
+// ----------------------------
+#define DEMOD_ADC_SAMPLING                         ((0x212d  << 2) + 0xc1100000)
+// ----------------------------
+// WIFI
+// ----------------------------
+// `define WIFI_ADC_SAMPLING               8'h2e
+// `define WIFI_ADC_READBACK               8'h2f
+// ----------------------------
+// UART0
+// ----------------------------
+#define UART0_WFIFO                                ((0x2130  << 2) + 0xc1100000)
+#define UART0_RFIFO                                ((0x2131  << 2) + 0xc1100000)
+#define UART0_CONTROL                              ((0x2132  << 2) + 0xc1100000)
+#define UART0_STATUS                               ((0x2133  << 2) + 0xc1100000)
+#define UART0_MISC                                 ((0x2134  << 2) + 0xc1100000)
+#define UART0_REG5                                 ((0x2135  << 2) + 0xc1100000)
+// ----------------------------
+// UART1
+// ----------------------------
+#define UART1_WFIFO                                ((0x2137  << 2) + 0xc1100000)
+#define UART1_RFIFO                                ((0x2138  << 2) + 0xc1100000)
+#define UART1_CONTROL                              ((0x2139  << 2) + 0xc1100000)
+#define UART1_STATUS                               ((0x213a  << 2) + 0xc1100000)
+#define UART1_MISC                                 ((0x213b  << 2) + 0xc1100000)
+#define UART1_REG5                                 ((0x213c  << 2) + 0xc1100000)
+// ----------------------------
+// I2C Master (8)
+// ----------------------------
+#define I2C_M_0_CONTROL_REG                        ((0x2140  << 2) + 0xc1100000)
+    #define     I2C_M_MANUAL_SDA_I        26
+    #define     I2C_M_MANUAL_SCL_I        25
+    #define     I2C_M_MANUAL_SDA_O        24
+    #define     I2C_M_MANUAL_SCL_O        23
+    #define     I2C_M_MANUAL_EN           22
+    #define     I2C_M_DELAY_MSB           21
+    #define     I2C_M_DELAY_LSB           12
+    #define     I2C_M_DATA_CNT_MSB        11
+    #define     I2C_M_DATA_CNT_LSB        8
+    #define     I2C_M_CURR_TOKEN_MSB      7
+    #define     I2C_M_CURR_TOKEN_LSB      4
+    #define     I2C_M_ERROR               3
+    #define     I2C_M_STATUS              2
+    #define     I2C_M_ACK_IGNORE          1
+    #define     I2C_M_START               0
+#define I2C_M_0_SLAVE_ADDR                         ((0x2141  << 2) + 0xc1100000)
+#define I2C_M_0_TOKEN_LIST0                        ((0x2142  << 2) + 0xc1100000)
+#define I2C_M_0_TOKEN_LIST1                        ((0x2143  << 2) + 0xc1100000)
+#define I2C_M_0_WDATA_REG0                         ((0x2144  << 2) + 0xc1100000)
+#define I2C_M_0_WDATA_REG1                         ((0x2145  << 2) + 0xc1100000)
+#define I2C_M_0_RDATA_REG0                         ((0x2146  << 2) + 0xc1100000)
+#define I2C_M_0_RDATA_REG1                         ((0x2147  << 2) + 0xc1100000)
+// ----------------------------
+// I2C Slave (3)
+// ----------------------------
+#define I2C_S_CONTROL_REG                          ((0x2150  << 2) + 0xc1100000)
+#define I2C_S_SEND_REG                             ((0x2151  << 2) + 0xc1100000)
+#define I2C_S_RECV_REG                             ((0x2152  << 2) + 0xc1100000)
+#define I2C_S_CNTL1_REG                            ((0x2153  << 2) + 0xc1100000)
+// ----------------------------
+// PWM / DS A/B
+// ----------------------------
+#define PWM_PWM_A                                  ((0x2154  << 2) + 0xc1100000)
+#define PWM_PWM_B                                  ((0x2155  << 2) + 0xc1100000)
+#define PWM_MISC_REG_AB                            ((0x2156  << 2) + 0xc1100000)
+#define PWM_DELTA_SIGMA_AB                         ((0x2157  << 2) + 0xc1100000)
+// ---------------------------
+// EFUSE (4)
+// ----------------------------
+// Moved to the Secure APB3 bus
+// `define EFUSE_CNTL0                     8'h58
+// `define EFUSE_CNTL1                     8'h59
+// `define EFUSE_CNTL2                     8'h5a
+// `define EFUSE_CNTL3                     8'h5b
+// `define EFUSE_CNTL4                     8'h5c
+// ---------------------------------------------
+// Separate APB slave that shares the CBUS/APB
+// register space of the static registers
+// ---------------------------------------------
+#define ATAPI_IDEREG0                              ((0x2160  << 2) + 0xc1100000)
+   #define IDE_UDMA_PIO_STATE         15
+   #define IDE_BUSY                   14
+   #define IDE_ERROR_BIT              13
+   #define IDE_DMARQ_BIT              12
+   #define IDE_IORDY_BIT              11
+   #define IDE_IORDY_EN_BIT           10
+   #define IDE_DIS_CSEL_BIT            9
+   #define IDE_CSEL_BIT                8
+   #define IDE_IRQ14                   2
+   #define IDE_ATAPI_GPIO_EN           3
+   #define IDE_DMARQ_FULL              1
+   #define IDE_ENABLE                  0
+#define ATAPI_IDEREG1                              ((0x2161  << 2) + 0xc1100000)
+#define ATAPI_IDEREG2                              ((0x2162  << 2) + 0xc1100000)
+    #define IDE_XFER_CNT_MSB_BIT      18
+    #define IDE_XFER_CNT_LSB_BIT       0
+#define ATAPI_CYCTIME                              ((0x2163  << 2) + 0xc1100000)
+#define ATAPI_IDETIME                              ((0x2164  << 2) + 0xc1100000)
+#define ATAPI_PIO_TIMING                           ((0x2165  << 2) + 0xc1100000)
+#define ATAPI_TABLE_ADD_REG                        ((0x2166  << 2) + 0xc1100000)
+#define ATAPI_IDEREG3                              ((0x2167  << 2) + 0xc1100000)
+#define ATAPI_UDMA_REG0                            ((0x2168  << 2) + 0xc1100000)
+#define ATAPI_UDMA_REG1                            ((0x2169  << 2) + 0xc1100000)
+// Room for registers here
+#define TRANS_PWMA_REG0                            ((0x2170  << 2) + 0xc1100000)
+#define TRANS_PWMA_REG1                            ((0x2171  << 2) + 0xc1100000)
+#define TRANS_PWMA_MUX0                            ((0x2172  << 2) + 0xc1100000)
+#define TRANS_PWMA_MUX1                            ((0x2173  << 2) + 0xc1100000)
+#define TRANS_PWMA_MUX2                            ((0x2174  << 2) + 0xc1100000)
+#define TRANS_PWMA_MUX3                            ((0x2175  << 2) + 0xc1100000)
+#define TRANS_PWMA_MUX4                            ((0x2176  << 2) + 0xc1100000)
+#define TRANS_PWMA_MUX5                            ((0x2177  << 2) + 0xc1100000)
+#define TRANS_PWMB_REG0                            ((0x2178  << 2) + 0xc1100000)
+#define TRANS_PWMB_REG1                            ((0x2179  << 2) + 0xc1100000)
+#define TRANS_PWMB_MUX0                            ((0x217a  << 2) + 0xc1100000)
+#define TRANS_PWMB_MUX1                            ((0x217b  << 2) + 0xc1100000)
+#define TRANS_PWMB_MUX2                            ((0x217c  << 2) + 0xc1100000)
+#define TRANS_PWMB_MUX3                            ((0x217d  << 2) + 0xc1100000)
+#define TRANS_PWMB_MUX4                            ((0x217e  << 2) + 0xc1100000)
+#define TRANS_PWMB_MUX5                            ((0x217f  << 2) + 0xc1100000)
+// ----------------------------
+// NAND (21)
+// ----------------------------
+#define NAND_START                                 ((0x2180  << 2) + 0xc1100000)
+#define NAND_ADR_CMD                               ((0x218a  << 2) + 0xc1100000)
+#define NAND_ADR_STS                               ((0x218b  << 2) + 0xc1100000)
+#define NAND_END                                   ((0x218f  << 2) + 0xc1100000)
+// ----------------------------
+// PWM / DS C/D
+// ----------------------------
+#define PWM_PWM_C                                  ((0x2194  << 2) + 0xc1100000)
+#define PWM_PWM_D                                  ((0x2195  << 2) + 0xc1100000)
+#define PWM_MISC_REG_CD                            ((0x2196  << 2) + 0xc1100000)
+#define PWM_DELTA_SIGMA_CD                         ((0x2197  << 2) + 0xc1100000)
+// ----------------------------
+// ISP_FLASH_LED_CTRL
+// ----------------------------
+//bit 31, reg_led_en //rising pulse start, falling pulse stop for torch mode
+//bit 30, reg_inc_i_st_lat //for as3685, dynamic increase current during st_latch
+//bit 29:28, reg_inv_en_pol //bit[29], invert en1, bit [28], invert en2
+//bit 27, reg_switch_en1en2  //switch output en1 and en2. For IS3231: en1 is EN, en2 is mode. 
+//bit 26, reg_force_off_mode //1: reset state machine at the falling edge no matter which state it is in
+//bit 25, reg_hold_nonstd_off_mode //hold the non-std led_off signal input before state "OFF"
+//bit 24, reg_flash_mode_timeout_en  //force to exit the Tlat state when time out, for flash mode protection
+//bit 23, reg_en1_st_ini_level //en1 level during state ST_INI
+//bit 22, reg_en2_st_set_mp_level //en2 level during state ST_SET_MP_HI, ST_SET_MP_LO
+//bit 21, reg_en1_st_off_level //en1 level during state ST_OFF
+//bit 20, reg_en2_st_off_level //en2 level during state ST_OFF
+//bit 19:12, reg_en1_mp_num  //en1 multi pulse number, up to 256 step current control
+//bit 10:0, reg_t_st_ini //Max: 85.2 us under 24M clock input
+#define ISP_LED_CTRL                               ((0x2198  << 2) + 0xc1100000)
+//bit 31:21, reg_t_en1_inc_i_st_lat_cnt //Max: 85.2us under 24M. for as3685, dynamic increase current during st_latch
+//bit 20:10, reg_t_en2_lo_st_ini //Max: 85.2 us under 24M clock input
+//bit 9:0, reg_t_en2_hi1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
+#define ISP_LED_TIMING1                            ((0x2199  << 2) + 0xc1100000)
+//bit 31:21, reg_t_en1_mp_hi_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
+//bit 20:10, reg_t_en1_mp_lo_cnt //Max: 85.2 us under 24M clock input, mp means multi pulse
+//bit 9:0, reg_t_en2_lo1_st_lat_cnt //42.62us @24M, EN2 can output hi-lo-hi during ST_LATCH, this is the first lo -duration
+#define ISP_LED_TIMING2                            ((0x219a  << 2) + 0xc1100000)
+//bit 30:28, RO state
+//bit 25:0, reg_flash_mode_timeout_cnt //up to 2.79s at 24Mhz clk input
+#define ISP_LED_TIMING3                            ((0x219b  << 2) + 0xc1100000)
+//bit 25:0, reg_t_st_lat_cnt //up to 2.79s, keep the led on if it's 26'h3ffffff under torch mode
+#define ISP_LED_TIMING4                            ((0x219c  << 2) + 0xc1100000)
+//bit 31:26, reg_t_st_off_cnt[5:0] //up to 85.2us OFF state.
+//bit 25:0, reg_t_en2_hi2_st_lat_cnt //EN2 can output hi-lo-hi during ST_LATCH, this is the second hi -duration
+#define ISP_LED_TIMING5                            ((0x219d  << 2) + 0xc1100000)
+//bit 30:26, reg_t_st_off_cnt[10:6] //up to 85.2us OFF state.
+//bit 25:0, reg_t_en1_st_lat_hold_cnt //to make sure Tlat to meat it's minimum request 500us (since non-std led_off signal may comes in anytime)
+#define ISP_LED_TIMING6                            ((0x219e  << 2) + 0xc1100000)
+// ----------------------------
+// SAR ADC (16)
+// ----------------------------
+#define SAR_ADC_REG0                               ((0x21a0  << 2) + 0xc1100000)
+#define SAR_ADC_CHAN_LIST                          ((0x21a1  << 2) + 0xc1100000)
+#define SAR_ADC_AVG_CNTL                           ((0x21a2  << 2) + 0xc1100000)
+#define SAR_ADC_REG3                               ((0x21a3  << 2) + 0xc1100000)
+#define SAR_ADC_DELAY                              ((0x21a4  << 2) + 0xc1100000)
+#define SAR_ADC_LAST_RD                            ((0x21a5  << 2) + 0xc1100000)
+#define SAR_ADC_FIFO_RD                            ((0x21a6  << 2) + 0xc1100000)
+#define SAR_ADC_AUX_SW                             ((0x21a7  << 2) + 0xc1100000)
+#define SAR_ADC_CHAN_10_SW                         ((0x21a8  << 2) + 0xc1100000)
+#define SAR_ADC_DETECT_IDLE_SW                     ((0x21a9  << 2) + 0xc1100000)
+#define SAR_ADC_DELTA_10                           ((0x21aa  << 2) + 0xc1100000)
+// ----------------------------
+// CTouch (16)
+// ----------------------------
+#define PWM_PWM_E                                  ((0x21b0  << 2) + 0xc1100000)
+#define PWM_PWM_F                                  ((0x21b1  << 2) + 0xc1100000)
+#define PWM_MISC_REG_EF                            ((0x21b2  << 2) + 0xc1100000)
+#define PWM_DELTA_SIGMA_EF                         ((0x21b3  << 2) + 0xc1100000)
+// ----------------------------
+// UART2
+// ----------------------------
+#define UART2_WFIFO                                ((0x21c0  << 2) + 0xc1100000)
+#define UART2_RFIFO                                ((0x21c1  << 2) + 0xc1100000)
+#define UART2_CONTROL                              ((0x21c2  << 2) + 0xc1100000)
+#define UART2_STATUS                               ((0x21c3  << 2) + 0xc1100000)
+#define UART2_MISC                                 ((0x21c4  << 2) + 0xc1100000)
+#define UART2_REG5                                 ((0x21c5  << 2) + 0xc1100000)
+// ----------------------------
+// UART3
+// ----------------------------
+#define UART3_WFIFO                                ((0x21c8  << 2) + 0xc1100000)
+#define UART3_RFIFO                                ((0x21c9  << 2) + 0xc1100000)
+#define UART3_CONTROL                              ((0x21ca  << 2) + 0xc1100000)
+#define UART3_STATUS                               ((0x21cb  << 2) + 0xc1100000)
+#define UART3_MISC                                 ((0x21cc  << 2) + 0xc1100000)
+#define UART3_REG5                                 ((0x21cd  << 2) + 0xc1100000)
+// ---------------------------
+// RTC (4)
+// ---------------------------
+#define RTC_ADDR0                                  ((0x21d0  << 2) + 0xc1100000)
+#define RTC_ADDR1                                  ((0x21d1  << 2) + 0xc1100000)
+#define RTC_ADDR2                                  ((0x21d2  << 2) + 0xc1100000)
+#define RTC_ADDR3                                  ((0x21d3  << 2) + 0xc1100000)
+#define RTC_ADDR4                                  ((0x21d4  << 2) + 0xc1100000)
+// ----------------------------
+// clock measure (4)
+// ----------------------------
+#define MSR_CLK_DUTY                               ((0x21d6  << 2) + 0xc1100000)
+#define MSR_CLK_REG0                               ((0x21d7  << 2) + 0xc1100000)
+#define MSR_CLK_REG1                               ((0x21d8  << 2) + 0xc1100000)
+#define MSR_CLK_REG2                               ((0x21d9  << 2) + 0xc1100000)
+#define MSR_CLK_REG3                               ((0x21da  << 2) + 0xc1100000)
+#define MSR_CLK_REG4                               ((0x21db  << 2) + 0xc1100000)
+#define MSR_CLK_REG5                               ((0x21de  << 2) + 0xc1100000)
+// ----------------------------
+// LED PWM
+// ----------------------------
+// `define LED_PWM_REG0                    8'hda
+// `define LED_PWM_REG1                    8'hdb
+// `define LED_PWM_REG2                    8'hdc
+// `define LED_PWM_REG3                    8'hdd
+// `define LED_PWM_REG4                    8'hde
+// `define LED_PWM_REG5                    8'hdf
+// `define LED_PWM_REG6                    8'he0
+// ----------------------------
+// VGHL PWM
+// ----------------------------
+// `define VGHL_PWM_REG0                   8'he1
+// `define VGHL_PWM_REG1                   8'he2
+// `define VGHL_PWM_REG2                   8'he3
+// `define VGHL_PWM_REG3                   8'he4
+// `define VGHL_PWM_REG4                   8'he5
+// `define VGHL_PWM_REG5                   8'he6
+// `define VGHL_PWM_REG6                   8'he7
+// ----------------------------
+// I2C Master
+// ----------------------------
+#define I2C_M_1_CONTROL_REG                        ((0x21f0  << 2) + 0xc1100000)
+#define I2C_M_1_SLAVE_ADDR                         ((0x21f1  << 2) + 0xc1100000)
+#define I2C_M_1_TOKEN_LIST0                        ((0x21f2  << 2) + 0xc1100000)
+#define I2C_M_1_TOKEN_LIST1                        ((0x21f3  << 2) + 0xc1100000)
+#define I2C_M_1_WDATA_REG0                         ((0x21f4  << 2) + 0xc1100000)
+#define I2C_M_1_WDATA_REG1                         ((0x21f5  << 2) + 0xc1100000)
+#define I2C_M_1_RDATA_REG0                         ((0x21f6  << 2) + 0xc1100000)
+#define I2C_M_1_RDATA_REG1                         ((0x21f7  << 2) + 0xc1100000)
+// ----------------------------
+// I2C Master
+// ----------------------------
+#define I2C_M_2_CONTROL_REG                        ((0x21f8  << 2) + 0xc1100000)
+#define I2C_M_2_SLAVE_ADDR                         ((0x21f9  << 2) + 0xc1100000)
+#define I2C_M_2_TOKEN_LIST0                        ((0x21fa  << 2) + 0xc1100000)
+#define I2C_M_2_TOKEN_LIST1                        ((0x21fb  << 2) + 0xc1100000)
+#define I2C_M_2_WDATA_REG0                         ((0x21fc  << 2) + 0xc1100000)
+#define I2C_M_2_WDATA_REG1                         ((0x21fd  << 2) + 0xc1100000)
+#define I2C_M_2_RDATA_REG0                         ((0x21fe  << 2) + 0xc1100000)
+#define I2C_M_2_RDATA_REG1                         ((0x21ff  << 2) + 0xc1100000)
+// -------------------------------------------------------------------
+// PSEL Group #2:  0x800 ~ 0xbFF
+// -------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PERIPHS2_CBUS_BASE = 0x22
+// -----------------------------------------------
+#define USB_ADDR0                                  ((0x2200  << 2) + 0xc1100000)
+#define USB_ADDR1                                  ((0x2201  << 2) + 0xc1100000)
+#define USB_ADDR2                                  ((0x2202  << 2) + 0xc1100000)
+#define USB_ADDR3                                  ((0x2203  << 2) + 0xc1100000)
+#define USB_ADDR4                                  ((0x2204  << 2) + 0xc1100000)
+#define USB_ADDR5                                  ((0x2205  << 2) + 0xc1100000)
+#define USB_ADDR6                                  ((0x2206  << 2) + 0xc1100000)
+#define USB_ADDR7                                  ((0x2207  << 2) + 0xc1100000)
+#define USB_ADDR8                                  ((0x2208  << 2) + 0xc1100000)
+#define USB_ADDR9                                  ((0x2209  << 2) + 0xc1100000)
+#define USB_ADDR10                                 ((0x220a  << 2) + 0xc1100000)
+#define USB_ADDR11                                 ((0x220b  << 2) + 0xc1100000)
+#define USB_ADDR12                                 ((0x220c  << 2) + 0xc1100000)
+#define USB_ADDR13                                 ((0x220d  << 2) + 0xc1100000)
+#define USB_ADDR14                                 ((0x220e  << 2) + 0xc1100000)
+#define USB_ADDR15                                 ((0x220f  << 2) + 0xc1100000)
+#define USB_ADDR16                                 ((0x2210  << 2) + 0xc1100000)
+#define USB_ADDR17                                 ((0x2211  << 2) + 0xc1100000)
+#define USB_ADDR18                                 ((0x2212  << 2) + 0xc1100000)
+#define USB_ADDR19                                 ((0x2213  << 2) + 0xc1100000)
+#define USB_ADDR20                                 ((0x2214  << 2) + 0xc1100000)
+#define USB_ADDR21                                 ((0x2215  << 2) + 0xc1100000)
+#define USB_ADDR22                                 ((0x2216  << 2) + 0xc1100000)
+#define USB_ADDR23                                 ((0x2217  << 2) + 0xc1100000)
+#define USB_ADDR24                                 ((0x2218  << 2) + 0xc1100000)
+#define USB_ADDR25                                 ((0x2219  << 2) + 0xc1100000)
+#define USB_ADDR26                                 ((0x221a  << 2) + 0xc1100000)
+#define USB_ADDR27                                 ((0x221b  << 2) + 0xc1100000)
+#define USB_ADDR28                                 ((0x221c  << 2) + 0xc1100000)
+#define USB_ADDR29                                 ((0x221d  << 2) + 0xc1100000)
+#define USB_ADDR30                                 ((0x221e  << 2) + 0xc1100000)
+#define USB_ADDR31                                 ((0x221f  << 2) + 0xc1100000)
+// ----------------------------
+// SANA (Stream Analyzer)
+// ----------------------------
+// [31:16] - ddr_setting
+// [15]    - disable_stream_clock_gating
+// [14:13] - mem_pd_ctl_sana
+// [6:4]   - stream_fetch_endian 
+// [3]     - use_parser_vbuf_wp
+// [2]     - use_parser_vbuf2_wp
+// [1]     - stream_fetch_busy - Read Only
+// [0]     - stream_fetch_enable
+#define SANA_STREAM_CONTROL                        ((0x2220  << 2) + 0xc1100000)
+#define SANA_STREAM_START_ADDR                     ((0x2221  << 2) + 0xc1100000)
+#define SANA_STREAM_END_ADDR                       ((0x2222  << 2) + 0xc1100000)
+// SW stream_buffer_wr_ptr
+#define SANA_STREAM_WR_PTR                         ((0x2223  << 2) + 0xc1100000)
+#define SANA_STREAM_RD_PTR                         ((0x2224  << 2) + 0xc1100000)
+//[31:0] stream_buffer_level - read only
+#define SANA_STREAM_LEVEL                          ((0x2225  << 2) + 0xc1100000)
+// [31:29] stream_buffer_hole 256*(4^0) bytes
+// [28:23] stream_fifo_hole 
+// [22:16] stream_fifo_level
+// [15]    stream_fifo_wr_ptr_update_en
+// [14:8]  stream_fifo_wr_ptr 
+// [7]     stream_fifo_rd_ptr_update_en
+// [6:0]   stream_fifo_rd_ptr 
+#define SANA_STREAM_FIFO_CTL                       ((0x2226  << 2) + 0xc1100000)
+// [31:18] - Reserved
+// [17]    - sana_int_enable
+// [16]    - sana_int_level (default : 0(pulse))
+// [15]    - disable_shift_clock_gating
+// [14]    - startcode_protect -- TODO
+// [8:6]   - sft_valid_wr_position (default : 3 (at least 24 bits available))
+// [5:4]   - emulate_code_length_sub_1(Default : 2)
+// [3]     - emulation_auto_on_startcode(Default : 0)
+// [2:1]   - start_code_length_sub_1(Default : 2)
+// [0]     - stream_shift_enable(Default : 0)
+#define SANA_SHIFT_CONTROL                         ((0x2227  << 2) + 0xc1100000)
+// [31:0]  - max 4-bytes start code (Default : 0x00000100)
+#define SANA_SHIFT_STARTCODE                       ((0x2228  << 2) + 0xc1100000)
+// [31:0]  - max 4-bytes emulate code (Default : 0x00000300)
+#define SANA_SHIFT_EMULATECODE                     ((0x2229  << 2) + 0xc1100000)
+// [3]     - sana_int
+// [2]     - startcode_searching
+// [1]     - emulation_check_on
+// [0]     - startcode_check_on
+#define SANA_SHIFT_STATUS                          ((0x222a  << 2) + 0xc1100000)
+// [31:0] sana_shifted_data - read only
+#define SANA_SHIFTED_DATA                          ((0x222b  << 2) + 0xc1100000)
+// [31:0] shift_byte_count[31:0]
+#define SANA_SHIFT_BYTE_COUNT                      ((0x222c  << 2) + 0xc1100000)
+// [31:28] - shift_byte_count[35:32]
+// [27:20] - element_read_data[31:24]
+// [10]    - bytealign
+// [9]     - signed_element
+// [8]     - start_element_read
+// [7]     - shift_busy
+// [6:0]   - shift_bits
+#define SANA_SHIFT_COMMAND                         ((0x222d  << 2) + 0xc1100000)
+// 31:8    - element_read_data[23:0]
+//  7:2    - element_read_length
+//  1:0    - element_read_state
+#define SANA_ELEMENT_RESULT                        ((0x222e  << 2) + 0xc1100000)
+// support up to 8 masters, one bit per master
+// 23:16   - lock_release (Write 1 to release)
+// 15:8    - lock_req (write 1 to request)
+//  7:0    - lock_result (Read Only)
+#define ATOM_LOCK                                  ((0x222f  << 2) + 0xc1100000)
+// ----------------------------
+// BLKMV (9)
+// ----------------------------
+#define NDMA_CNTL_REG0                             ((0x2270  << 2) + 0xc1100000)
+    #define NDMA_STATUS                 26
+    #define NDMA_PERIODIC_INT_DLY_MSB   25
+    #define NDMA_PERIODIC_INT_DLY_LSB   16
+    #define NDMA_PERIODIC_INT_EN        15
+    #define NDMA_ENABLE                 14
+    #define NDMA_AHB_DELAY_MSB          13
+    #define NDMA_AHB_DELAY_LSB          0
+#define NDMA_TABLE_ADD_REG                         ((0x2272  << 2) + 0xc1100000)
+#define NDMA_TDES_KEY_LO                           ((0x2273  << 2) + 0xc1100000)
+#define NDMA_TDES_KEY_HI                           ((0x2274  << 2) + 0xc1100000)
+#define NDMA_TDES_CONTROL                          ((0x2275  << 2) + 0xc1100000)
+#define NDMA_RIJNDAEL_CONTROL                      ((0x2276  << 2) + 0xc1100000)
+#define NDMA_RIJNDAEL_RK_FIFO                      ((0x2277  << 2) + 0xc1100000)
+#define NDMA_CRC_OUT                               ((0x2278  << 2) + 0xc1100000)
+#define NDMA_THREAD_REG                            ((0x2279  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_START0                   ((0x2280  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_CURR0                    ((0x2281  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_END0                     ((0x2282  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_START1                   ((0x2283  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_CURR1                    ((0x2284  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_END1                     ((0x2285  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_START2                   ((0x2286  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_CURR2                    ((0x2287  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_END2                     ((0x2288  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_START3                   ((0x2289  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_CURR3                    ((0x228a  << 2) + 0xc1100000)
+#define NDMA_THREAD_TABLE_END3                     ((0x228b  << 2) + 0xc1100000)
+#define NDMA_CNTL_REG1                             ((0x228c  << 2) + 0xc1100000)
+#define NDMA_AES_KEY_0                             ((0x2290  << 2) + 0xc1100000)
+#define NDMA_AES_KEY_1                             ((0x2291  << 2) + 0xc1100000)
+#define NDMA_AES_KEY_2                             ((0x2292  << 2) + 0xc1100000)
+#define NDMA_AES_KEY_3                             ((0x2293  << 2) + 0xc1100000)
+#define NDMA_AES_KEY_4                             ((0x2294  << 2) + 0xc1100000)
+#define NDMA_AES_KEY_5                             ((0x2295  << 2) + 0xc1100000)
+#define NDMA_AES_KEY_6                             ((0x2296  << 2) + 0xc1100000)
+#define NDMA_AES_KEY_7                             ((0x2297  << 2) + 0xc1100000)
+#define NDMA_AES_IV_0                              ((0x2298  << 2) + 0xc1100000)
+#define NDMA_AES_IV_1                              ((0x2299  << 2) + 0xc1100000)
+#define NDMA_AES_IV_2                              ((0x229a  << 2) + 0xc1100000)
+#define NDMA_AES_IV_3                              ((0x229b  << 2) + 0xc1100000)
+#define NDMA_AES_REG0                              ((0x229c  << 2) + 0xc1100000)
+// -------------------------------------------------------------------
+// PSEL Group #3:  0xc00 ~ 0xFFF
+// -------------------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PERIPHS3_CBUS_BASE = 0x23
+// -----------------------------------------------
+// ---------------------------
+// STREAM (8)
+// ---------------------------
+// bit 31:24 -- event_length
+// bit 23:22 -- bus_1st_sel_1  //00-gpio, 01-reserved, 10-addr, 11-data 
+// bit 21:20 -- bus_2nd_sel_1
+// bit 19:18 -- bus_1st_sel_0
+// bit 17:16 -- bus_2nd_sel_0
+// bit 15:0 -- set output value (output 1 will read according to external input) 
+#define STREAM_EVENT_INFO                          ((0x2300  << 2) + 0xc1100000)
+// bit 31    -- force_parity_1
+// bit 30    -- LSB_first
+// bit 31:20 -- reserved
+// bit 19:16 -- toggle point index
+// bit 15:8  -- output togle point1
+// bit 7:0   -- output togle point0 (0xff means input) 
+#define STREAM_OUTPUT_CONFIG                       ((0x2301  << 2) + 0xc1100000)
+// bit 31:24 -- clock_divide_ext
+// bit 23:20 -- s_bus_start ( sclk, sdataout, sdatain)  // 0 means no s_bus used
+// bit 19    -- no_sclk_on_pin // will use internal write clock and read clock (like RS232) 
+// bit 18    -- invert_sclk_in
+// bit 17    -- sdata_send_busy  // indicate one data is sending -- read only
+// bit 16    -- one_sdata_received // set when one sdata is received, can write 0 to clear 
+// bit 15    -- sdata_parity  // (write -- 0-even, 1-odd) (read -- received parity check)
+// bit 14    -- sdata_send_type  // 0 -- 8 bits  1 -- 32 bits ( for fujitsu only )
+// bit 13    -- sdata_receive_type // 0 -- 8 bits only  1 -- 8/32 bits 
+// bit 12    -- invert_request_out
+// bit 11:8  -- request_out_sel  // 0 means disable output
+// bit 7:0   --  stop_request_count 
+#define C_D_BUS_CONTROL                            ((0x2302  << 2) + 0xc1100000)
+// bit 31:0  -- serial data (write: output one data, read: input data)
+#define C_DATA                                     ((0x2303  << 2) + 0xc1100000)
+// bit 31:28 bus_width_1
+// bit 27:24 bus_start_pin_1
+// bit 23:16 bus_sel_chang_point_1 
+// bit 15:12 bus_width_0
+// bit 11:08 bus_start_pin_0
+// bit 07:00 bus_sel_chang_point_0 
+#define STREAM_BUS_CONFIG                          ((0x2304  << 2) + 0xc1100000)
+// bit 31:24 clock_divide
+// bit 23:20 clock_output_sel  -- 0 means disable clock output
+// bit 19 -- inc_event_addr
+// bit 18 -- async_fifo_endian
+// bit 17 -- send_to_async_fifo
+// bit 16 -- data_in_serial_lsb
+// bit 15 -- invert_no_wait_condition_0
+// bit 14 -- invert_no_wait_condition_1
+// bit 13 -- invert_no_wait_condition_2
+// bit 12 -- invert_data_bus
+// bit 11 -- invert_clock_in
+// bit 10 -- event_wait_clk_en
+// bit 9 -- data_in_serial
+// bit 8 -- invert_data_in_clk 
+// bit 7:4  -- data_in_begin
+// bit 3:0  -- data_in_clk_sel
+#define STREAM_DATA_IN_CONFIG                      ((0x2305  << 2) + 0xc1100000)
+// wait condition and irq should not be connected to 0, 0 means disable)
+// bit 31:28 -- no_wait_condition_0   (0 means disable this condition)
+// bit 27:24 -- no_wait_condition_1   (0 means disable this condition)
+// bit 23:20 -- no_wait_condition_2   (0 means disable this condition)
+// bit 19:16 -- irq_input_sel         (0 means disable this interrupt)
+// bit 15:13 -- interrupt_status (read) clear status (write) (ext 0, ext 1, transfer end)
+// bit 12 -- enable_sdata_irq
+// bit 11 -- invert_irq_0
+// bit 10 -- invert_irq_1
+// bit  9 -- enable_transfer_end_irq
+// bit  8 -- enable_second_ext_irq
+// bit 7:0 -- no_wait_condition_check_point (0xff means no check)
+#define STREAM_WAIT_IRQ_CONFIG                     ((0x2306  << 2) + 0xc1100000)
+// bit 31:24 -- event address
+// bit 23:16 -- event data
+// bit 15:1 -- event repeat times  (0 means one time event)
+// bit 0  -- Start Event (write) event_busy (read)
+#define STREAM_EVENT_CTL                           ((0x2307  << 2) + 0xc1100000)
+// ---------------------------
+// SDIO (8)
+// ---------------------------
+// `define C_SDIO_HIGH16                   8'h00 
+// bit 31:0 -- cmd_argument/MS_SHORT_DATA_WRITE
+#define CMD_ARGUMENT                               ((0x2308  << 2) + 0xc1100000)
+// bit 31:24 -- repeat_package_times/MS_SHORT_DATA_WRITE_NUMBER
+// bit 21   -- use_int_window
+// bit 20   -- cmd_send_data/MS_HAVE_LONG_DATA_WRITE
+// bit 19   -- check_busy_on_dat0 (used for R1b response)
+// bit 18   -- response_crc7_from_8
+// bit 17   -- response_have_data/MS_HAVE_LONG_DATA_READ
+// bit 16   -- response_do_not_have_crc7/MS_SHORT_DATA_DO_NOT_HAVE_CRC16
+// bit 15:8 -- cmd_response_bits (00 means no response) /MS_SHORT_DATA_READ_NUMBER
+// bit 7:0 -- cmd_command/MS_TPC
+#define CMD_SEND                                   ((0x2309  << 2) + 0xc1100000)
+// bit 31:29 -- sdio_write_CRC_ok_status
+// bit 28:23 -- sdio_write_Nwr
+// bit 22:21 -- m_endian
+// bit 20    -- bus_width
+// bit 19    -- data_latch_at_negedge (normally at posedge)
+// bit 18    -- do_not_delay_data (normally delay one clock)
+// bit 17:12 -- cmd_argument_bits (before CRC, normally : 39) 
+// bit 11 -- cmd_out_at_posedge (normally at negedge)
+// bit 10 -- cmd_disable_CRC
+// bit 9:0 -- cmd_clk_divide
+#define SDIO_CONFIG                                ((0x230a  << 2) + 0xc1100000)
+// bit 31:19 -- sdio_timing_out_count
+// bit 18 -- arc_timing_out_int_en
+// bit 17 -- amrisc_timing_out_int_en
+// bit 16 -- sdio_timig_out_int   -- write 1 clear this int bit
+// bit 15:12 -- sdio_status_info  -- used for change infor between ARC and Amrisc
+// bit 11 -- sdio_set_soft_int -- write 1 to this bit will set sdio_soft_int , read out is m_req_sdio
+// bit 10 -- sdio_soft_int   -- write 1 clear this int bit
+// bit 9 -- sdio_cmd_int   -- write 1 clear this int bit
+// bit 8 -- sdio_if_int   -- write 1 clear this int bit
+// bit 7 -- sdio_data_write_crc16_ok -- Read-Only
+// bit 6 -- sdio_data_read_crc16_ok  -- Read-Only
+// bit 5 -- sdio_response_crc7_ok    -- Read-Only
+// bit 4 -- sdio_cmd_busy            -- Read-Only
+// bit 3:0 -- sdio_status            -- Read-Only
+#define SDIO_STATUS_IRQ                            ((0x230b  << 2) + 0xc1100000)
+// bit 31 -- halt_hole 0 -- 8 bits 1 -- 16 bits
+// bit 30 -- force_halt
+// bit 29:24 -- sdio_force_data_read (read_only)
+// bit 23:22 -- disable_mem_halt (write and read)
+// bit 21:16 -- sdio_force_output_en 
+// bit 15 -- soft_reset
+// bit 14 -- sdio_force_enable
+// bit 13:8 -- sdio_force_data/sdio_read_data
+// bit 7:6 -- sdio_if_int_config 
+// bit 5 -- arc_soft_int_en
+// bit 4 -- arc_cmd_int_en
+// bit 3 -- arc_if_int_en
+// bit 2 -- amrisc_soft_int_en
+// bit 1 -- amrisc_cmd_int_en
+// bit 0 -- amrisc_if_int_en
+#define SDIO_IRQ_CONFIG                            ((0x230c  << 2) + 0xc1100000)
+// bit 27:16 -- data_catch_finish_point
+// (
+// bit 15:12 -- response_read_index  
+// bit 9 -- data_catch_readout_en
+// bit 8 -- write_read_out_index
+// ) this bits only write when write_read_out_index = 1
+// bit 11 -- sdio_1_data_swap01 
+// bit 10 -- sdio_0_data_on_1 
+// bit 7:6 -- data_catch_level 
+// bit 5 -- stream_8_bits_mode
+// bit 4 -- stream_enable
+// bit 3 -- ms_sclk_always
+// bit 2 -- ms_enable
+// bit 1:0 -- SDIO_port_sel //00-sdio1, 01-sdio2, 02-sdio3
+#define SDIO_MULT_CONFIG                           ((0x230d  << 2) + 0xc1100000)
+// bit 31:0 -- m_addr_sdio
+#define SDIO_M_ADDR                                ((0x230e  << 2) + 0xc1100000)
+// bit 31    -- CRC_status_4line
+// bit 30    -- data_rw_do_not_have_crc16/MS_LONG_DATA_DO_NOT_HAVE_CRC16
+// bit 29:16 -- data_rw_number/MS_LONG_DATA_NUMBER 
+// bit 15:0 -- cmd_argument_ext/MS_SHORT_DATA_EXTENSION
+#define SDIO_EXTENSION                             ((0x230f  << 2) + 0xc1100000)
+// ----------------------------
+// ASYNC FIFO (4)
+// ----------------------------
+#define ASYNC_FIFO_REG0                            ((0x2310  << 2) + 0xc1100000)
+#define ASYNC_FIFO_REG1                            ((0x2311  << 2) + 0xc1100000)
+    #define ASYNC_FIFO_FLUSH_STATUS     31
+    #define ASYNC_FIFO_ERR              30
+    #define ASYNC_FIFO_FIFO_EMPTY       29
+    #define ASYNC_FIFO_TO_HIU           24
+    #define ASYNC_FIFO_FLUSH            23
+    #define ASYNC_FIFO_RESET            22
+    #define ASYNC_FIFO_WRAP_EN          21
+    #define ASYNC_FIFO_FLUSH_EN         20
+    #define ASYNC_FIFO_RESIDUAL_MSB     19
+    #define ASYNC_FIFO_RESIDUAL_LSB     15
+    #define ASYNC_FIFO_FLUSH_CNT_MSB    14
+    #define ASYNC_FIFO_FLUSH_CNT_LSB    0
+#define ASYNC_FIFO_REG2                            ((0x2312  << 2) + 0xc1100000)
+    #define ASYNC_FIFO_FIFO_FULL        26
+    #define ASYNC_FIFO_FILL_STATUS      25
+    #define ASYNC_FIFO_SOURCE_MSB       24
+    #define ASYNC_FIFO_SOURCE_LSB       23
+    #define ASYNC_FIFO_ENDIAN_MSB       22
+    #define ASYNC_FIFO_ENDIAN_LSB       21
+    #define ASYNC_FIFO_FILL_EN          20
+    #define ASYNC_FIFO_FILL_CNT_MSB     19
+    #define ASYNC_FIFO_FILL_CNT_LSB     0
+#define ASYNC_FIFO_REG3                            ((0x2313  << 2) + 0xc1100000)
+    #define ASYNC_FLUSH_SIZE_IRQ_MSB    15
+    #define ASYNC_FLUSH_SIZE_IRQ_LSB    0
+// ----------------------------
+// ASYNC FIFO (4)
+// ----------------------------
+#define ASYNC_FIFO2_REG0                           ((0x2314  << 2) + 0xc1100000)
+#define ASYNC_FIFO2_REG1                           ((0x2315  << 2) + 0xc1100000)
+#define ASYNC_FIFO2_REG2                           ((0x2316  << 2) + 0xc1100000)
+#define ASYNC_FIFO2_REG3                           ((0x2317  << 2) + 0xc1100000)
+// ----------------------------
+// SDIO_AHB_CBUS (2)
+// ----------------------------
+// bit   17    -- arc_ahb_cbus_int_en
+// bit   16    -- amrisc_ahb_cbus_int_en
+// bit 15:8    -- SDIO_FIFO_count
+// bit  7:4    -- m_req_count
+// bit    3    -- reserved
+// bit    2    -- m_write_cbus
+// bit    1    -- m_req_cbus
+// bit    0    -- sdio_ahb_cbus_enable
+#define SDIO_AHB_CBUS_CTRL                         ((0x2318  << 2) + 0xc1100000)
+// m_rd_data[31:0] when (m_write_cbus == 0)  CBUS write
+// m_wr_data[31:0] when (m_write_cbus == 1)  CBUS read
+#define SDIO_AHB_CBUS_M_DATA                       ((0x2319  << 2) + 0xc1100000)
+// ----------------------------
+// SPI 
+// ----------------------------
+#define SPI_FLASH_CMD                              ((0x2320  << 2) + 0xc1100000)
+    #define SPI_FLASH_READ    31
+    #define SPI_FLASH_WREN    30
+    #define SPI_FLASH_WRDI    29
+    #define SPI_FLASH_RDID    28
+    #define SPI_FLASH_RDSR    27
+    #define SPI_FLASH_WRSR    26
+    #define SPI_FLASH_PP      25
+    #define SPI_FLASH_SE      24
+    #define SPI_FLASH_BE      23
+    #define SPI_FLASH_CE      22
+    #define SPI_FLASH_DP      21
+    #define SPI_FLASH_RES     20
+    #define SPI_HPM           19
+    #define SPI_FLASH_USR     18
+    #define SPI_FLASH_USR_ADDR 15
+    #define SPI_FLASH_USR_DUMMY 14
+    #define SPI_FLASH_USR_DIN   13
+    #define SPI_FLASH_USR_DOUT   12
+    #define SPI_FLASH_USR_DUMMY_BLEN   10
+    #define SPI_FLASH_USR_CMD     0
+#define SPI_FLASH_ADDR                             ((0x2321  << 2) + 0xc1100000)
+    #define SPI_FLASH_BYTES_LEN 24
+    #define SPI_FLASH_ADDR_START 0
+#define SPI_FLASH_CTRL                             ((0x2322  << 2) + 0xc1100000)
+    #define SPI_ENABLE_AHB    17
+    #define SPI_SST_AAI       16
+    #define SPI_RES_RID       15
+    #define SPI_FREAD_DUAL    14
+    #define SPI_READ_READ_EN  13
+    #define SPI_CLK_DIV0      12
+    #define SPI_CLKCNT_N      8
+    #define SPI_CLKCNT_H      4
+    #define SPI_CLKCNT_L      0
+#define SPI_FLASH_CTRL1                            ((0x2323  << 2) + 0xc1100000)
+#define SPI_FLASH_STATUS                           ((0x2324  << 2) + 0xc1100000)
+#define SPI_FLASH_CTRL2                            ((0x2325  << 2) + 0xc1100000)
+#define SPI_FLASH_CLOCK                            ((0x2326  << 2) + 0xc1100000)
+#define SPI_FLASH_USER                             ((0x2327  << 2) + 0xc1100000)
+#define SPI_FLASH_USER1                            ((0x2328  << 2) + 0xc1100000)
+#define SPI_FLASH_USER2                            ((0x2329  << 2) + 0xc1100000)
+#define SPI_FLASH_USER3                            ((0x232a  << 2) + 0xc1100000)
+#define SPI_FLASH_USER4                            ((0x232b  << 2) + 0xc1100000)
+#define SPI_FLASH_SLAVE                            ((0x232c  << 2) + 0xc1100000)
+#define SPI_FLASH_SLAVE1                           ((0x232d  << 2) + 0xc1100000)
+#define SPI_FLASH_SLAVE2                           ((0x232e  << 2) + 0xc1100000)
+#define SPI_FLASH_SLAVE3                           ((0x232f  << 2) + 0xc1100000)
+#define SPI_FLASH_C0                               ((0x2330  << 2) + 0xc1100000)
+#define SPI_FLASH_C1                               ((0x2331  << 2) + 0xc1100000)
+#define SPI_FLASH_C2                               ((0x2332  << 2) + 0xc1100000)
+#define SPI_FLASH_C3                               ((0x2333  << 2) + 0xc1100000)
+#define SPI_FLASH_C4                               ((0x2334  << 2) + 0xc1100000)
+#define SPI_FLASH_C5                               ((0x2335  << 2) + 0xc1100000)
+#define SPI_FLASH_C6                               ((0x2336  << 2) + 0xc1100000)
+#define SPI_FLASH_C7                               ((0x2337  << 2) + 0xc1100000)
+#define SPI_FLASH_B8                               ((0x2338  << 2) + 0xc1100000)
+#define SPI_FLASH_B9                               ((0x2339  << 2) + 0xc1100000)
+#define SPI_FLASH_B10                              ((0x233a  << 2) + 0xc1100000)
+#define SPI_FLASH_B11                              ((0x233b  << 2) + 0xc1100000)
+#define SPI_FLASH_B12                              ((0x233c  << 2) + 0xc1100000)
+#define SPI_FLASH_B13                              ((0x233d  << 2) + 0xc1100000)
+#define SPI_FLASH_B14                              ((0x233e  << 2) + 0xc1100000)
+#define SPI_FLASH_B15                              ((0x233f  << 2) + 0xc1100000)
+// ----------------------------
+// I2C Master
+// ----------------------------
+#define I2C_M_3_CONTROL_REG                        ((0x2348  << 2) + 0xc1100000)
+#define I2C_M_3_SLAVE_ADDR                         ((0x2349  << 2) + 0xc1100000)
+#define I2C_M_3_TOKEN_LIST0                        ((0x234a  << 2) + 0xc1100000)
+#define I2C_M_3_TOKEN_LIST1                        ((0x234b  << 2) + 0xc1100000)
+#define I2C_M_3_WDATA_REG0                         ((0x234c  << 2) + 0xc1100000)
+#define I2C_M_3_WDATA_REG1                         ((0x234d  << 2) + 0xc1100000)
+#define I2C_M_3_RDATA_REG0                         ((0x234e  << 2) + 0xc1100000)
+#define I2C_M_3_RDATA_REG1                         ((0x234f  << 2) + 0xc1100000)
+// ----------------------------
+// SPICC
+// ----------------------------
+#define SPICC_RXDATA                               ((0x2360  << 2) + 0xc1100000)
+#define SPICC_TXDATA                               ((0x2361  << 2) + 0xc1100000)
+#define SPICC_CONREG                               ((0x2362  << 2) + 0xc1100000)
+#define SPICC_INTREG                               ((0x2363  << 2) + 0xc1100000)
+#define SPICC_DMAREG                               ((0x2364  << 2) + 0xc1100000)
+#define SPICC_STATREG                              ((0x2365  << 2) + 0xc1100000)
+#define SPICC_PERIODREG                            ((0x2366  << 2) + 0xc1100000)
+#define SPICC_TESTREG                              ((0x2367  << 2) + 0xc1100000)
+#define SPICC_DRADDR                               ((0x2368  << 2) + 0xc1100000)
+#define SPICC_DWADDR                               ((0x2369  << 2) + 0xc1100000)
+// ----------------------------
+// SDHC (SDIO #2)
+// ----------------------------
+#define SD_REG0_ARGU                               ((0x2380  << 2) + 0xc1100000)
+#define SD_REG1_SEND                               ((0x2381  << 2) + 0xc1100000)
+#define SD_REG2_CNTL                               ((0x2382  << 2) + 0xc1100000)
+#define SD_REG3_STAT                               ((0x2383  << 2) + 0xc1100000)
+#define SD_REG4_CLKC                               ((0x2384  << 2) + 0xc1100000)
+#define SD_REG5_ADDR                               ((0x2385  << 2) + 0xc1100000)
+#define SD_REG6_PDMA                               ((0x2386  << 2) + 0xc1100000)
+#define SD_REG7_MISC                               ((0x2387  << 2) + 0xc1100000)
+#define SD_REG8_DATA                               ((0x2388  << 2) + 0xc1100000)
+#define SD_REG9_ICTL                               ((0x2389  << 2) + 0xc1100000)
+#define SD_REGA_ISTA                               ((0x238a  << 2) + 0xc1100000)
+#define SD_REGB_SRST                               ((0x238b  << 2) + 0xc1100000)
+#define SD_REGC_ESTA                               ((0x238c  << 2) + 0xc1100000)
+#define SD_REGD_ENHC                               ((0x238d  << 2) + 0xc1100000)
+#define SD_REGE_CLK2                               ((0x238e  << 2) + 0xc1100000)
+//
+// Closing file:  periphs_reg.h
+//
+//
+// Reading file:  isa_reg.h
+//
+// $isa/rtl/isa_core register defines for the APB bus
+// CBUS base slave address
+// -----------------------------------------------
+// CBUS_BASE:  ISA_CBUS_BASE = 0x26
+// -----------------------------------------------
+// Up to 256 registers for this base
+#define ISA_DEBUG_REG0                             ((0x2600  << 2) + 0xc1100000)
+#define ISA_DEBUG_REG1                             ((0x2601  << 2) + 0xc1100000)
+#define ISA_DEBUG_REG2                             ((0x2602  << 2) + 0xc1100000)
+#define ISA_DEBUG_REG3                             ((0x2603  << 2) + 0xc1100000)
+#define ISA_PLL_CLK_SIM0                           ((0x2608  << 2) + 0xc1100000)
+#define ISA_CNTL_REG0                              ((0x2609  << 2) + 0xc1100000)
+// -----------------------------------------------------------
+#define AO_CPU_IRQ_IN0_INTR_STAT                   ((0x2610  << 2) + 0xc1100000)
+#define AO_CPU_IRQ_IN0_INTR_STAT_CLR               ((0x2611  << 2) + 0xc1100000)
+#define AO_CPU_IRQ_IN0_INTR_MASK                   ((0x2612  << 2) + 0xc1100000)
+#define AO_CPU_IRQ_IN0_INTR_FIRQ_SEL               ((0x2613  << 2) + 0xc1100000)
+// define MEDIA_CPU_IRQ_IN1_INTR_STAT           8'h14
+// define MEDIA_CPU_IRQ_IN1_INTR_STAT_CLR       8'h15
+// define MEDIA_CPU_IRQ_IN1_INTR_MASK           8'h16
+// define MEDIA_CPU_IRQ_IN1_INTR_FIRQ_SEL       8'h17
+// 
+// define MEDIA_CPU_IRQ_IN2_INTR_STAT              8'h18
+// define MEDIA_CPU_IRQ_IN2_INTR_STAT_CLR          8'h19
+// define MEDIA_CPU_IRQ_IN2_INTR_MASK              8'h1a
+// define MEDIA_CPU_IRQ_IN2_INTR_FIRQ_SEL          8'h1b
+// 
+// define MEDIA_CPU_IRQ_IN3_INTR_STAT            8'h1c
+// define MEDIA_CPU_IRQ_IN3_INTR_STAT_CLR        8'h1d
+// define MEDIA_CPU_IRQ_IN3_INTR_MASK            8'h1e
+// define MEDIA_CPU_IRQ_IN3_INTR_FIRQ_SEL        8'h1f
+#define GPIO_INTR_EDGE_POL                         ((0x2620  << 2) + 0xc1100000)
+#define GPIO_INTR_GPIO_SEL0                        ((0x2621  << 2) + 0xc1100000)
+#define GPIO_INTR_GPIO_SEL1                        ((0x2622  << 2) + 0xc1100000)
+#define GPIO_INTR_FILTER_SEL0                      ((0x2623  << 2) + 0xc1100000)
+// `define GLOBAL_INTR_DISABLE                 8'h24    never used
+#define MEDIA_CPU_INTR_STAT                        ((0x2628  << 2) + 0xc1100000)
+#define MEDIA_CPU_INTR_STAT_CLR                    ((0x2629  << 2) + 0xc1100000)
+#define MEDIA_CPU_INTR_MASK                        ((0x262a  << 2) + 0xc1100000)
+#define MEDIA_CPU_INTR_FIRQ_SEL                    ((0x262b  << 2) + 0xc1100000)
+// -----------------------------------------------------------
+#define ISA_BIST_REG0                              ((0x2630  << 2) + 0xc1100000)
+#define ISA_BIST_REG1                              ((0x2631  << 2) + 0xc1100000)
+// -----------------------------------------------------------
+#define WATCHDOG_TC                                ((0x2640  << 2) + 0xc1100000)
+#define WATCHDOG_RESET                             ((0x2641  << 2) + 0xc1100000)
+// -----------------------------------------------------------
+#define AHB_ARBITER_REG                            ((0x2642  << 2) + 0xc1100000)
+#define AHB_ARBDEC_REG                             ((0x2643  << 2) + 0xc1100000)
+#define AHB_ARBITER2_REG                           ((0x264a  << 2) + 0xc1100000)
+#define DEVICE_MMCP_CNTL                           ((0x264b  << 2) + 0xc1100000)
+#define AUDIO_MMCP_CNTL                            ((0x264c  << 2) + 0xc1100000)
+// -----------------------------------------------------------
+#define ISA_TIMER_MUX                              ((0x2650  << 2) + 0xc1100000)
+#define ISA_TIMERA                                 ((0x2651  << 2) + 0xc1100000)
+#define ISA_TIMERB                                 ((0x2652  << 2) + 0xc1100000)
+#define ISA_TIMERC                                 ((0x2653  << 2) + 0xc1100000)
+#define ISA_TIMERD                                 ((0x2654  << 2) + 0xc1100000)
+#define ISA_TIMERE                                 ((0x2655  << 2) + 0xc1100000)
+#define FBUF_ADDR                                  ((0x2656  << 2) + 0xc1100000)
+    #define VIDEO_FRM_BUF_MSB_BIT      23 
+    #define VIDEO_FRM_BUF_LSB_BIT       2 
+#define SDRAM_CTL0                                 ((0x2657  << 2) + 0xc1100000)
+#define SDRAM_CTL2                                 ((0x2658  << 2) + 0xc1100000)
+//`define AO_CPU_CTL                          8'h59
+#define SDRAM_CTL4                                 ((0x265a  << 2) + 0xc1100000)
+#define SDRAM_CTL5                                 ((0x265b  << 2) + 0xc1100000)
+#define SDRAM_CTL6                                 ((0x265c  << 2) + 0xc1100000)
+#define SDRAM_CTL7                                 ((0x265d  << 2) + 0xc1100000)
+#define SDRAM_CTL8                                 ((0x265e  << 2) + 0xc1100000)
+#define AHB_MP4_MC_CTL                             ((0x265f  << 2) + 0xc1100000)
+#define MEDIA_CPU_PCR                              ((0x2660  << 2) + 0xc1100000)
+#define MEDIA_CPU_CTL                              ((0x2661  << 2) + 0xc1100000)
+#define ISA_TIMER_MUX1                             ((0x2664  << 2) + 0xc1100000)
+#define ISA_TIMERF                                 ((0x2665  << 2) + 0xc1100000)
+#define ISA_TIMERG                                 ((0x2666  << 2) + 0xc1100000)
+#define ISA_TIMERH                                 ((0x2667  << 2) + 0xc1100000)
+#define ISA_TIMERI                                 ((0x2668  << 2) + 0xc1100000)
+// ---------------------------------------------
+#define ABUF_WR_CTL0                               ((0x2670  << 2) + 0xc1100000)
+    #define ABUF_WR_INT_EN	    31
+    #define ABUF_WR_INT_POS_MSB      30 
+    #define ABUF_WR_INT_POS_LSB      16 
+    #define ABUF_WR_BLK_SIZE_MSB     14 
+    #define ABUF_WR_BLK_SIZE_LSB      0
+#define ABUF_WR_CTL1                               ((0x2671  << 2) + 0xc1100000)
+    #define ABUF_WR_INT_EN	    31
+    #define ABUF_WR_INT_POS_MSB      30 
+    #define ABUF_WR_INT_POS_LSB      16 
+    #define ABUF_WR_BLK_SIZE_MSB     14 
+    #define ABUF_WR_BLK_SIZE_LSB      0
+#define ABUF_WR_CTL2                               ((0x2672  << 2) + 0xc1100000)
+    #define ABUF_WR_CUR_FF_CNT_MSB   21
+    #define ABUF_WR_CUR_FF_CNT_LSB   16
+    #define ABUF_WR_CUR_BLK_MSB      14
+    #define ABUF_WR_CUR_BLK_LSB       0   
+#define ABUF_WR_CTL3                               ((0x2673  << 2) + 0xc1100000)
+    #define ABUF_WR_AHB_RST_PLS       3
+    #define ABUF_WR_FF_CLR_PLS        2
+    #define ABUF_WR_PLY_RPT_LVL	     1
+    #define ABUF_WR_FF_PAUSE_LVL      0
+#define ABUF_RD_CTL0                               ((0x2674  << 2) + 0xc1100000)
+#define ABUF_RD_CTL1                               ((0x2675  << 2) + 0xc1100000)
+    #define ABUF_RD_INT_EN	    31
+    #define ABUF_RD_INT_POS_MSB      30 
+    #define ABUF_RD_INT_POS_LSB      16 
+    #define ABUF_RD_BLK_SIZE_MSB     14 
+    #define ABUF_RD_BLK_SIZE_LSB      0   
+#define ABUF_RD_CTL2                               ((0x2676  << 2) + 0xc1100000)
+    #define ABUF_RD_CUR_FF_CNT_MSB   21
+    #define ABUF_RD_CUR_FF_CNT_LSB   16
+    #define ABUF_RD_CUR_BLK_MSB      14
+    #define ABUF_RD_CUR_BLK_LSB       0   
+#define ABUF_RD_CTL3                               ((0x2677  << 2) + 0xc1100000)
+    #define ABUF_RD_PLY_ONCE_PLS      4
+    #define ABUF_RD_AHB_RST_PLS       3
+    #define ABUF_RD_FF_CLR_PLS        2
+    #define ABUF_RD_PLY_RPT_LVL	     1
+    #define ABUF_RD_FF_PAUSE_LVL      0
+#define ABUF_ARB_CTL0                              ((0x2678  << 2) + 0xc1100000)
+#define ABUF_FIFO_CTL0                             ((0x2679  << 2) + 0xc1100000)
+    #define AIUout_FIFO_THRESHOLD_MSB 11
+    #define AIUout_FIFO_THRESHOLD_LSB 6 
+    #define AIUin_FIFO_THRESHOLD_MSB  5
+    #define AIUin_FIFO_THRESHOLD_LSB  0
+// ---------------------------------------------
+#define AHB_BRIDGE_CNTL_WR                         ((0x2680  << 2) + 0xc1100000)
+#define AHB_BRIDGE_REMAP0                          ((0x2681  << 2) + 0xc1100000)
+#define AHB_BRIDGE_REMAP1                          ((0x2682  << 2) + 0xc1100000)
+#define AHB_BRIDGE_REMAP2                          ((0x2683  << 2) + 0xc1100000)
+#define AHB_BRIDGE_REMAP3                          ((0x2684  << 2) + 0xc1100000)
+#define AHB_BRIDGE_CNTL_REG1                       ((0x2685  << 2) + 0xc1100000)
+#define AHB_BRIDGE_CNTL_REG2                       ((0x2686  << 2) + 0xc1100000)
+// ---------------------------------------------
+// ----------------------------------------------
+// `define SYS_CPU_0_IRQ_IN0_INTR_STAT         8'h90
+// `define SYS_CPU_0_IRQ_IN0_INTR_STAT_CLR     8'h91
+// `define SYS_CPU_0_IRQ_IN0_INTR_MASK         8'h92
+// `define SYS_CPU_0_IRQ_IN0_INTR_FIRQ_SEL     8'h93
+// `define SYS_CPU_0_IRQ_IN1_INTR_STAT         8'h94
+// `define SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR     8'h95
+// `define SYS_CPU_0_IRQ_IN1_INTR_MASK         8'h96
+// `define SYS_CPU_0_IRQ_IN1_INTR_FIRQ_SEL     8'h97
+// `define SYS_CPU_0_IRQ_IN2_INTR_STAT         8'h98
+// `define SYS_CPU_0_IRQ_IN2_INTR_STAT_CLR     8'h99
+// `define SYS_CPU_0_IRQ_IN2_INTR_MASK         8'h9a
+// `define SYS_CPU_0_IRQ_IN2_INTR_FIRQ_SEL     8'h9b
+// `define SYS_CPU_0_IRQ_IN3_INTR_STAT         8'h9c
+// `define SYS_CPU_0_IRQ_IN3_INTR_STAT_CLR     8'h9d
+// `define SYS_CPU_0_IRQ_IN3_INTR_MASK         8'h9e
+// `define SYS_CPU_0_IRQ_IN3_INTR_FIRQ_SEL     8'h9f
+// ----------------------------------------------
+// `define SYS_CPU_1_IRQ_IN0_INTR_STAT         8'ha0
+// `define SYS_CPU_1_IRQ_IN0_INTR_STAT_CLR     8'ha1
+// `define SYS_CPU_1_IRQ_IN0_INTR_MASK         8'ha2
+// `define SYS_CPU_1_IRQ_IN0_INTR_FIRQ_SEL     8'ha3
+//  
+// `define SYS_CPU_1_IRQ_IN1_INTR_STAT         8'ha4
+// `define SYS_CPU_1_IRQ_IN1_INTR_STAT_CLR     8'ha5
+// `define SYS_CPU_1_IRQ_IN1_INTR_MASK         8'ha6
+// `define SYS_CPU_1_IRQ_IN1_INTR_FIRQ_SEL     8'ha7
+//  
+// `define SYS_CPU_1_IRQ_IN2_INTR_STAT         8'ha8
+// `define SYS_CPU_1_IRQ_IN2_INTR_STAT_CLR     8'ha9
+// `define SYS_CPU_1_IRQ_IN2_INTR_MASK         8'haa
+// `define SYS_CPU_1_IRQ_IN2_INTR_FIRQ_SEL     8'hab
+//  
+// `define SYS_CPU_1_IRQ_IN3_INTR_STAT         8'hac
+// `define SYS_CPU_1_IRQ_IN3_INTR_STAT_CLR     8'had
+// `define SYS_CPU_1_IRQ_IN3_INTR_MASK         8'hae
+// `define SYS_CPU_1_IRQ_IN3_INTR_FIRQ_SEL     8'haf
+// ----------------------------------------------
+// `define MEDIA_CPU_IRQ_IN4_INTR_STAT         8'hb0
+// `define MEDIA_CPU_IRQ_IN4_INTR_STAT_CLR     8'hb1
+// `define MEDIA_CPU_IRQ_IN4_INTR_MASK         8'hb2
+// `define MEDIA_CPU_IRQ_IN4_INTR_FIRQ_SEL     8'hb3
+// `define SYS_CPU_0_IRQ_IN4_INTR_STAT         8'hb4
+// `define SYS_CPU_0_IRQ_IN4_INTR_STAT_CLR     8'hb5
+// `define SYS_CPU_0_IRQ_IN4_INTR_MASK         8'hb6
+// `define SYS_CPU_0_IRQ_IN4_INTR_FIRQ_SEL     8'hb7
+// `define SYS_CPU_1_IRQ_IN4_INTR_STAT         8'hb8
+// `define SYS_CPU_1_IRQ_IN4_INTR_STAT_CLR     8'hb9
+// `define SYS_CPU_1_IRQ_IN4_INTR_MASK         8'hba
+// `define SYS_CPU_1_IRQ_IN4_INTR_FIRQ_SEL     8'hbb
+// `define SYS_CPU_2_IRQ_IN4_INTR_STAT         8'hbc
+// `define SYS_CPU_2_IRQ_IN4_INTR_STAT_CLR     8'hbd
+// `define SYS_CPU_2_IRQ_IN4_INTR_MASK         8'hbe
+// `define SYS_CPU_2_IRQ_IN4_INTR_FIRQ_SEL     8'hbf
+// ----------------------------------------------
+// `define SYS_CPU_2_IRQ_IN0_INTR_STAT         8'hc0
+// `define SYS_CPU_2_IRQ_IN0_INTR_STAT_CLR     8'hc1
+// `define SYS_CPU_2_IRQ_IN0_INTR_MASK         8'hc2
+// `define SYS_CPU_2_IRQ_IN0_INTR_FIRQ_SEL     8'hc3
+// `define SYS_CPU_2_IRQ_IN1_INTR_STAT         8'hc4
+// `define SYS_CPU_2_IRQ_IN1_INTR_STAT_CLR     8'hc5
+// `define SYS_CPU_2_IRQ_IN1_INTR_MASK         8'hc6
+// `define SYS_CPU_2_IRQ_IN1_INTR_FIRQ_SEL     8'hc7
+// `define SYS_CPU_2_IRQ_IN2_INTR_STAT         8'hc8
+// `define SYS_CPU_2_IRQ_IN2_INTR_STAT_CLR     8'hc9
+// `define SYS_CPU_2_IRQ_IN2_INTR_MASK         8'hca
+// `define SYS_CPU_2_IRQ_IN2_INTR_FIRQ_SEL     8'hcb
+// `define SYS_CPU_2_IRQ_IN3_INTR_STAT         8'hcc
+// `define SYS_CPU_2_IRQ_IN3_INTR_STAT_CLR     8'hcd
+// `define SYS_CPU_2_IRQ_IN3_INTR_MASK         8'hce
+// `define SYS_CPU_2_IRQ_IN3_INTR_FIRQ_SEL     8'hcf
+// ----------------------------------------------
+// `define SYS_CPU_3_IRQ_IN0_INTR_STAT         8'hd0
+// `define SYS_CPU_3_IRQ_IN0_INTR_STAT_CLR     8'hd1
+// `define SYS_CPU_3_IRQ_IN0_INTR_MASK         8'hd2
+// `define SYS_CPU_3_IRQ_IN0_INTR_FIRQ_SEL     8'hd3
+// `define SYS_CPU_3_IRQ_IN1_INTR_STAT         8'hd4
+// `define SYS_CPU_3_IRQ_IN1_INTR_STAT_CLR     8'hd5
+// `define SYS_CPU_3_IRQ_IN1_INTR_MASK         8'hd6
+// `define SYS_CPU_3_IRQ_IN1_INTR_FIRQ_SEL     8'hd7
+// `define SYS_CPU_3_IRQ_IN2_INTR_STAT         8'hd8
+// `define SYS_CPU_3_IRQ_IN2_INTR_STAT_CLR     8'hd9
+// `define SYS_CPU_3_IRQ_IN2_INTR_MASK         8'hda
+// `define SYS_CPU_3_IRQ_IN2_INTR_FIRQ_SEL     8'hdb
+// `define SYS_CPU_3_IRQ_IN3_INTR_STAT         8'hdc
+// `define SYS_CPU_3_IRQ_IN3_INTR_STAT_CLR     8'hdd
+// `define SYS_CPU_3_IRQ_IN3_INTR_MASK         8'hde
+// `define SYS_CPU_3_IRQ_IN3_INTR_FIRQ_SEL     8'hdf
+// ----------------------------------------------
+// `define SYS_CPU_3_IRQ_IN4_INTR_STAT         8'he0
+// `define SYS_CPU_3_IRQ_IN4_INTR_STAT_CLR     8'he1
+// `define SYS_CPU_3_IRQ_IN4_INTR_MASK         8'he2
+// `define SYS_CPU_3_IRQ_IN4_INTR_FIRQ_SEL     8'he3
+// `define MEDIA_CPU_IRQ_IN5_INTR_STAT         8'he4
+// `define MEDIA_CPU_IRQ_IN5_INTR_STAT_CLR     8'he5
+// `define MEDIA_CPU_IRQ_IN5_INTR_MASK         8'he6
+// `define MEDIA_CPU_IRQ_IN5_INTR_FIRQ_SEL     8'he7
+// `define SYS_CPU_0_IRQ_IN5_INTR_STAT         8'he8
+// `define SYS_CPU_0_IRQ_IN5_INTR_STAT_CLR     8'he9
+// `define SYS_CPU_0_IRQ_IN5_INTR_MASK         8'hea
+// `define SYS_CPU_0_IRQ_IN5_INTR_FIRQ_SEL     8'heb
+//
+// Closing file:  isa_reg.h
+//
+//
+// Reading file:  bt656_reg.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// ----------------------------
+// BT656 0x2d  
+// ----------------------------
+// -----------------------------------------------
+// CBUS_BASE:  BT656_CBUS_BASE = 0x13
+// -----------------------------------------------
+#define BT_CTRL                                    ((0x1340  << 2) + 0xc1100000)
+    #define BT_SOFT_RESET           31      // Soft reset
+    #define BT_JPEG_START           30  
+    #define BT_JPEG_IGNORE_BYTES    18     //20:18
+    #define BT_JPEG_IGNORE_LAST     17
+    #define BT_UPDATE_ST_SEL        16 
+    #define BT_COLOR_REPEAT         15
+    #define BT_VIDEO_MODE           13     // 14:13
+    #define BT_AUTO_FMT             12   
+    #define BT_PROG_MODE            11
+    #define BT_JPEG_MODE            10
+    #define BT_XCLK27_EN_BIT        9      // 1 : xclk27 is input.     0 : xclk27 is output.
+    #define BT_FID_EN_BIT           8       // 1 : enable use FID port.
+    #define BT_CLK27_SEL_BIT        7       // 1 : external xclk27      0 : internal clk27.
+    #define BT_CLK27_PHASE_BIT      6       // 1 : no inverted          0 : inverted.
+    #define BT_ACE_MODE_BIT         5       // 1 : auto cover error by hardware.
+    #define BT_SLICE_MODE_BIT       4       // 1 : no ancillay flag     0 : with ancillay flag.
+    #define BT_FMT_MODE_BIT         3       // 1 : ntsc                 0 : pal.
+    #define BT_REF_MODE_BIT         2       // 1 : from bit stream.     0 : from ports.
+    #define BT_MODE_BIT             1       // 1 : BT656 model          0 : SAA7118 mode.
+    #define BT_EN_BIT               0       // 1 : enable.
+#define BT_VBISTART                                ((0x1341  << 2) + 0xc1100000)
+#define BT_VBIEND                                  ((0x1342  << 2) + 0xc1100000)
+#define BT_FIELDSADR                               ((0x1343  << 2) + 0xc1100000)
+#define BT_LINECTRL                                ((0x1344  << 2) + 0xc1100000)
+#define BT_VIDEOSTART                              ((0x1345  << 2) + 0xc1100000)
+#define BT_VIDEOEND                                ((0x1346  << 2) + 0xc1100000)
+#define BT_SLICELINE0                              ((0x1347  << 2) + 0xc1100000)
+#define BT_SLICELINE1                              ((0x1348  << 2) + 0xc1100000)
+#define BT_PORT_CTRL                               ((0x1349  << 2) + 0xc1100000)
+  #define BT_HSYNC_PHASE      0
+  #define BT_VSYNC_PHASE      1
+  #define BT_HSYNC_PULSE      2
+  #define BT_VSYNC_PULSE      3
+  #define BT_FID_PHASE        4
+  #define BT_FID_HSVS         5
+  #define BT_IDQ_EN           6
+  #define BT_IDQ_PHASE        7
+  #define BT_D8B              8
+  #define BT_10BTO8B          9
+  #define BT_FID_DELAY       10    //12:10
+  #define BT_VSYNC_DELAY     13    //
+  #define BT_HSYNC_DELAY     16
+#define BT_SWAP_CTRL                               ((0x134a  << 2) + 0xc1100000)
+#define BT_ANCISADR                                ((0x134b  << 2) + 0xc1100000)
+#define BT_ANCIEADR                                ((0x134c  << 2) + 0xc1100000)
+#define BT_AFIFO_CTRL                              ((0x134d  << 2) + 0xc1100000)
+#define BT_601_CTRL0                               ((0x134e  << 2) + 0xc1100000)
+#define BT_601_CTRL1                               ((0x134f  << 2) + 0xc1100000)
+#define BT_601_CTRL2                               ((0x1350  << 2) + 0xc1100000)
+#define BT_601_CTRL3                               ((0x1351  << 2) + 0xc1100000)
+#define BT_FIELD_LUMA                              ((0x1352  << 2) + 0xc1100000)
+#define BT_RAW_CTRL                                ((0x1353  << 2) + 0xc1100000)
+#define BT_STATUS                                  ((0x1354  << 2) + 0xc1100000)
+#define BT_INT_CTRL                                ((0x1355  << 2) + 0xc1100000)
+#define BT_ANCI_STATUS                             ((0x1356  << 2) + 0xc1100000)
+#define BT_VLINE_STATUS                            ((0x1357  << 2) + 0xc1100000)
+#define BT_AFIFO_PTR                               ((0x1358  << 2) + 0xc1100000)
+#define BT_JPEGBYTENUM                             ((0x1359  << 2) + 0xc1100000)
+#define BT_ERR_CNT                                 ((0x135a  << 2) + 0xc1100000)
+#define BT_JPEG_STATUS0                            ((0x135b  << 2) + 0xc1100000)
+#define BT_JPEG_STATUS1                            ((0x135c  << 2) + 0xc1100000)
+#define BT_LCNT_STATUS                             ((0x135d  << 2) + 0xc1100000)
+#define BT_PCNT_STATUS                             ((0x135e  << 2) + 0xc1100000)
+#define BT656_ADDR_END                             ((0x135f  << 2) + 0xc1100000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  bt656_reg.h
+//
+// TEMP DEFINES
+// -----------------------------------------------
+// CBUS_BASE:  PERIPHS4_CBUS_BASE = 0x24
+// -----------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PERIPHS5_CBUS_BASE = 0x25
+// -----------------------------------------------
+// For iq_om_width change for RealVideo
+#define IQ_OM_WIDTH                                ((0x2510  << 2) + 0xc1100000)
+//`define IQ_OM_WIDTH_12
+#define DBG_ADDR_START                             ((0x2ff0  << 2) + 0xc1100000)
+#define DBG_ADDR_END                               ((0x2fff  << 2) + 0xc1100000)
+#define DBG_CTRL                                   ((0x2ff1  << 2) + 0xc1100000)
+#define DBG_LED                                    ((0x2ff2  << 2) + 0xc1100000)
+#define DBG_SWITCH                                 ((0x2ff3  << 2) + 0xc1100000)
+#define DBG_VERSION                                ((0x2ff4  << 2) + 0xc1100000)
+//========================================================================
+//  Global Control Registers			    (12'h000 - 12'h0ff)
+//
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  RESET_CBUS_BASE = 0x11
+// -----------------------------------------------
+#define VERSION_CTRL                               ((0x1100  << 2) + 0xc1100000)
+#define RESET0_REGISTER                            ((0x1101  << 2) + 0xc1100000)
+#define RESET1_REGISTER                            ((0x1102  << 2) + 0xc1100000)
+#define RESET2_REGISTER                            ((0x1103  << 2) + 0xc1100000)
+#define RESET3_REGISTER                            ((0x1104  << 2) + 0xc1100000)
+#define RESET4_REGISTER                            ((0x1105  << 2) + 0xc1100000)
+#define RESET5_REGISTER                            ((0x1106  << 2) + 0xc1100000)
+#define RESET6_REGISTER                            ((0x1107  << 2) + 0xc1100000)
+#define RESET7_REGISTER                            ((0x1108  << 2) + 0xc1100000)
+#define RESET0_MASK                                ((0x1110  << 2) + 0xc1100000)
+#define RESET1_MASK                                ((0x1111  << 2) + 0xc1100000)
+#define RESET2_MASK                                ((0x1112  << 2) + 0xc1100000)
+#define RESET3_MASK                                ((0x1113  << 2) + 0xc1100000)
+#define RESET4_MASK                                ((0x1114  << 2) + 0xc1100000)
+#define RESET5_MASK                                ((0x1115  << 2) + 0xc1100000)
+#define RESET6_MASK                                ((0x1116  << 2) + 0xc1100000)
+#define CRT_MASK                                   ((0x1117  << 2) + 0xc1100000)
+#define RESET7_MASK                                ((0x1118  << 2) + 0xc1100000)
+#define RESET0_LEVEL                               ((0x1120  << 2) + 0xc1100000)
+#define RESET1_LEVEL                               ((0x1121  << 2) + 0xc1100000)
+#define RESET2_LEVEL                               ((0x1122  << 2) + 0xc1100000)
+#define RESET3_LEVEL                               ((0x1123  << 2) + 0xc1100000)
+#define RESET4_LEVEL                               ((0x1124  << 2) + 0xc1100000)
+#define RESET5_LEVEL                               ((0x1125  << 2) + 0xc1100000)
+#define RESET6_LEVEL                               ((0x1126  << 2) + 0xc1100000)
+#define RESET7_LEVEL                               ((0x1127  << 2) + 0xc1100000)
+//======================================
+//  Reset Register Bits	
+//
+//======================================
+    #define HIU_RESET	    0x0001
+    #define VLD_RESET	    0x0002
+    #define IQIDCT_RESET	0x0004
+    #define MC_RESET	    0x0008
+    #define DCU_RESET	    0x0010
+    #define VIU_RESET	    0x0020
+    #define AIU_RESET	    0x0040
+    #define CPU_RESET	    0x0080
+    #define AC3_RESET	    0x0100
+    #define MPEG_RESET	    0x0200
+//========================================================================
+//  Host uP Interface				    (12'h100 - 12'h2ff)
+//
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  HIU_CBUS_BASE = 0x10
+// -----------------------------------------------
+#define SCR_HIU                                    ((0x100b  << 2) + 0xc1100000)
+#define HPG_TIMER                                  ((0x100f  << 2) + 0xc1100000)
+#define HHI_GP0_PLL_CNTL                           ((0x1010  << 2) + 0xc1100000)
+#define HHI_GP0_PLL_CNTL2                          ((0x1011  << 2) + 0xc1100000)
+#define HHI_GP0_PLL_CNTL3                          ((0x1012  << 2) + 0xc1100000)
+#define HHI_GP0_PLL_CNTL4                          ((0x1013  << 2) + 0xc1100000)
+#define HHI_GP0_PLL_CNTL5                          ((0x1014  << 2) + 0xc1100000)
+#define HHI_GP1_PLL_CNTL                           ((0x1016  << 2) + 0xc1100000)
+#define HHI_GP1_PLL_CNTL2                          ((0x1017  << 2) + 0xc1100000)
+#define HHI_GP1_PLL_CNTL3                          ((0x1018  << 2) + 0xc1100000)
+#define HHI_GP1_PLL_CNTL4                          ((0x1019  << 2) + 0xc1100000)
+#define HHI_GP1_PLL_CNTL5                          ((0x101a  << 2) + 0xc1100000)
+#define HHI_CADC_CNTL                              ((0x1020  << 2) + 0xc1100000)
+#define HHI_CADC_CNTL2                             ((0x1021  << 2) + 0xc1100000)
+#define HHI_CADC_CNTL3                             ((0x1022  << 2) + 0xc1100000)
+#define HHI_CADC_CNTL4                             ((0x1023  << 2) + 0xc1100000)
+#define HHI_CADC_CNTL5                             ((0x1024  << 2) + 0xc1100000)
+#define HHI_CADC_CNTL6                             ((0x1025  << 2) + 0xc1100000)
+#define HHI_DADC_CNTL                              ((0x1027  << 2) + 0xc1100000)
+#define HHI_DADC_CNTL2                             ((0x1028  << 2) + 0xc1100000)
+#define HHI_DADC_RDBK0_I                           ((0x1029  << 2) + 0xc1100000)
+#define HHI_DADC_CNTL3                             ((0x102a  << 2) + 0xc1100000)
+#define HHI_DADC_CNTL4                             ((0x102b  << 2) + 0xc1100000)
+#define HARM_ASB_MB0                               ((0x1030  << 2) + 0xc1100000)
+#define HARM_ASB_MB1                               ((0x1031  << 2) + 0xc1100000)
+#define HARM_ASB_MB2                               ((0x1032  << 2) + 0xc1100000)
+#define HARM_ASB_MB3                               ((0x1033  << 2) + 0xc1100000)
+#define HASB_ARM_MB0                               ((0x1034  << 2) + 0xc1100000)
+#define HASB_ARM_MB1                               ((0x1035  << 2) + 0xc1100000)
+#define HASB_ARM_MB2                               ((0x1036  << 2) + 0xc1100000)
+#define HASB_ARM_MB3                               ((0x1037  << 2) + 0xc1100000)
+#define HHI_TIMER90K                               ((0x103b  << 2) + 0xc1100000)
+#define HHI_MEM_PD_REG0                            ((0x1040  << 2) + 0xc1100000)
+//VIU1
+//bit 29:28 mem_pd_vi_sharp,  2'b00: Sharpness line buffer memory power on, 2'b11: power down
+//bit 29:28 mem_pd_vi_dipost, 2'b00: Deinterlace - di_post memory power on, 2'b11: power down
+//bit 27:26 mem_pd_vi_dipre,  2'b00: Deinterlace - di_pre memory power on, 2'b11: power down
+//bit 25:24 mem_pd_vi_prot3,  2'b00: picture rotation3 memory power on, 2'b11: power down
+//bit 23:22 mem_pd_vi_prot2,  2'b00: picture rotation2 memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vi_prot1,  2'b00: picture rotation1 memory power on, 2'b11: power down
+//bit 19:18 mem_pd_vi_vdin1,  2'b00: vdin1 memory power on, 2'b11: power down
+//bit 17:16 mem_pd_vi_vdin0,  2'b00: vdin0 memory power on, 2'b11: power down
+//bit 15:14 mem_pd_vi_osd_sc, 2'b00: osd_scaler memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi_scale,  2'b00: scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi_ofifo,  2'b00: vpp output fifo memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi_chroma, 2'b00: color management module memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi_vd2,    2'b00: vd2 memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi_vd1,    2'b00: vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi_osd2,   2'b00: osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi_osd1,   2'b00: osd1 memory power on, 2'b11: power down
+#define HHI_VPU_MEM_PD_REG0                        ((0x1041  << 2) + 0xc1100000)
+//bit 29:28 mem_pd_atv_dmd,   2'b00: ATV DMD memory power on, 2'b11: power down
+//bit 29:28 mem_pd_cvd2,      2'b00: CVD2 memory power on, 2'b11: power down
+//bit 27:26 mem_pd_isp,       2'b00: ISP memory power on, 2'b11: power down
+//bit 25:24 mem_pd_venci_int, 2'b00: cvbs- enci interface memory power on, 2'b11: power down
+//bit 23:22 mem_pd_venc_l_top,2'b00: panel - encl top memory power on, 2'b11: power down
+//bit 21:20 mem_pd_vencp_int, 2'b00: hdmi - encp interface memory power on, 2'b11: power down
+//bit 13:12 mem_pd_vi2_osd_sc,2'b00: viu2 OSD scaler memory power on, 2'b11: power down
+//bit 11:10 mem_pd_vi2_scale, 2'b00: viu2 scaler memory power on, 2'b11: power down
+//bit 9:8   mem_pd_vi2_ofifo, 2'b00: viu2 vpp output fifo memory power on, 2'b11: power down
+//bit 7:6   mem_pd_vi2_chroma,2'b00: viu2 color management module memory power on, 2'b11: power down
+//bit 5:4   mem_pd_vi2_vd1,   2'b00: viu2 vd1 memory power on, 2'b11: power down
+//bit 3:2   mem_pd_vi2_osd2,  2'b00: viu2 osd2 memory power on, 2'b11: power down
+//bit 1:0   mem_pd_vi2_osd1,  2'b00: viu2 osd1 memory power on, 2'b11: power down
+#define HHI_VPU_MEM_PD_REG1                        ((0x1042  << 2) + 0xc1100000)
+#define HHI_DEMOD_MEM_PD_REG                       ((0x1043  << 2) + 0xc1100000)
+#define HHI_AUD_DAC_CTRL                           ((0x1044  << 2) + 0xc1100000)
+// `define HHI_VIID_PLL_CNTL4      8'h46 // video PLL read back
+// `define HHI_VIID_PLL_CNTL       8'h47 // Video PLL control, word 1
+// `define HHI_VIID_PLL_CNTL2      8'h48 // Video PLL control, word 2
+// `define HHI_VIID_PLL_CNTL3      8'h49 // Video PLL control, word 3
+#define HHI_VIID_CLK_DIV                           ((0x104a  << 2) + 0xc1100000)
+#define HHI_VIID_CLK_CNTL                          ((0x104b  << 2) + 0xc1100000)
+#define HHI_VIID_DIVIDER_CNTL                      ((0x104c  << 2) + 0xc1100000)
+// Gated clock enables.  There are 64 enables for the MPEG clocks and 32 enables for other clock domains
+#define HHI_GCLK_MPEG0                             ((0x1050  << 2) + 0xc1100000)
+#define HHI_GCLK_MPEG1                             ((0x1051  << 2) + 0xc1100000)
+#define HHI_GCLK_MPEG2                             ((0x1052  << 2) + 0xc1100000)
+#define HHI_GCLK_OTHER                             ((0x1054  << 2) + 0xc1100000)
+#define HHI_GCLK_AO                                ((0x1055  << 2) + 0xc1100000)
+#define HHI_SYS_CPU_CLK_CNTL1                      ((0x1057  << 2) + 0xc1100000)
+// PLL Controls
+#define HHI_VID_CLK_DIV                            ((0x1059  << 2) + 0xc1100000)
+#define HHI_MPEG_CLK_CNTL                          ((0x105d  << 2) + 0xc1100000)
+#define HHI_AUD_CLK_CNTL                           ((0x105e  << 2) + 0xc1100000)
+#define HHI_VID_CLK_CNTL                           ((0x105f  << 2) + 0xc1100000)
+#define HHI_WIFI_CLK_CNTL                          ((0x1060  << 2) + 0xc1100000)
+#define HHI_WIFI_PLL_CNTL                          ((0x1061  << 2) + 0xc1100000)
+#define HHI_WIFI_PLL_CNTL2                         ((0x1062  << 2) + 0xc1100000)
+#define HHI_WIFI_PLL_CNTL3                         ((0x1063  << 2) + 0xc1100000)
+#define HHI_AUD_CLK_CNTL2                          ((0x1064  << 2) + 0xc1100000)
+#define HHI_VID_CLK_CNTL2                          ((0x1065  << 2) + 0xc1100000)
+#define HHI_VID_DIVIDER_CNTL                       ((0x1066  << 2) + 0xc1100000)
+#define HHI_SYS_CPU_CLK_CNTL                       ((0x1067  << 2) + 0xc1100000)
+#define HHI_VID_PLL_CLK_DIV                        ((0x1068  << 2) + 0xc1100000)
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL        8'h68 // DDR PLL control, word 1
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL2       8'h69 // DDR PLL control, word 2
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL3       8'h6a // DDR PLL control, word 3
+// Moved to Martin's domain `define HHI_DDR_PLL_CNTL4       8'h6b // DDR PLL control, word 3
+#define HHI_MALI_CLK_CNTL                          ((0x106c  << 2) + 0xc1100000)
+#define HHI_MIPI_PHY_CLK_CNTL                      ((0x106e  << 2) + 0xc1100000)
+#define HHI_VPU_CLK_CNTL                           ((0x106f  << 2) + 0xc1100000)
+#define HHI_OTHER_PLL_CNTL                         ((0x1070  << 2) + 0xc1100000)
+#define HHI_OTHER_PLL_CNTL2                        ((0x1071  << 2) + 0xc1100000)
+#define HHI_OTHER_PLL_CNTL3                        ((0x1072  << 2) + 0xc1100000)
+#define HHI_HDMI_CLK_CNTL                          ((0x1073  << 2) + 0xc1100000)
+#define HHI_DEMOD_CLK_CNTL                         ((0x1074  << 2) + 0xc1100000)
+#define HHI_SATA_CLK_CNTL                          ((0x1075  << 2) + 0xc1100000)
+#define HHI_ETH_CLK_CNTL                           ((0x1076  << 2) + 0xc1100000)
+#define HHI_CLK_DOUBLE_CNTL                        ((0x1077  << 2) + 0xc1100000)
+#define HHI_VDEC_CLK_CNTL                          ((0x1078  << 2) + 0xc1100000)
+#define HHI_VDEC2_CLK_CNTL                         ((0x1079  << 2) + 0xc1100000)
+#define HHI_VDEC3_CLK_CNTL                         ((0x107a  << 2) + 0xc1100000)
+#define HHI_VDEC4_CLK_CNTL                         ((0x107b  << 2) + 0xc1100000)
+// `define HHI_SYS_CPU_AUTO_CLK0        8'h78   never used
+// `define HHI_SYS_CPU_AUTO_CLK1        8'h79   never used
+// `define HHI_MEDIA_CPU_AUTO_CLK0    8'h7a     never used
+// `define HHI_MEDIA_CPU_AUTO_CLK1    8'h7b     never used
+#define HHI_HDMI_AFC_CNTL                          ((0x107f  << 2) + 0xc1100000)
+#define HHI_HDMIRX_CLK_CNTL                        ((0x1080  << 2) + 0xc1100000)
+#define HHI_HDMIRX_AUD_CLK_CNTL                    ((0x1081  << 2) + 0xc1100000)
+#define HHI_EDP_APB_CLK_CNTL                       ((0x1082  << 2) + 0xc1100000)
+#define HHI_VID_PLL_MOD_CNTL0                      ((0x1084  << 2) + 0xc1100000)
+#define HHI_VID_PLL_MOD_LOW_TCNT                   ((0x1085  << 2) + 0xc1100000)
+#define HHI_VID_PLL_MOD_HIGH_TCNT                  ((0x1086  << 2) + 0xc1100000)
+#define HHI_VID_PLL_MOD_NOM_TCNT                   ((0x1087  << 2) + 0xc1100000)
+// Removed `define HHI_DDR_CLK_CNTL            8'h88 
+#define HHI_32K_CLK_CNTL                           ((0x1089  << 2) + 0xc1100000)
+#define HHI_GEN_CLK_CNTL                           ((0x108a  << 2) + 0xc1100000)
+#define HHI_GEN_CLK_CNTL2                          ((0x108b  << 2) + 0xc1100000)
+#define HHI_JTAG_CONFIG                            ((0x108e  << 2) + 0xc1100000)
+#define HHI_VAFE_CLKXTALIN_CNTL                    ((0x108f  << 2) + 0xc1100000)
+#define HHI_VAFE_CLKOSCIN_CNTL                     ((0x1090  << 2) + 0xc1100000)
+#define HHI_VAFE_CLKIN_CNTL                        ((0x1091  << 2) + 0xc1100000)
+#define HHI_TVFE_AUTOMODE_CLK_CNTL                 ((0x1092  << 2) + 0xc1100000)
+#define HHI_VAFE_CLKPI_CNTL                        ((0x1093  << 2) + 0xc1100000)
+#define HHI_VDIN_MEAS_CLK_CNTL                     ((0x1094  << 2) + 0xc1100000)
+// `define HHI_PCM2_CLK_CNTL           8'h95
+#define HHI_PCM_CLK_CNTL                           ((0x1096  << 2) + 0xc1100000)
+#define HHI_NAND_CLK_CNTL                          ((0x1097  << 2) + 0xc1100000)
+#define HHI_ISP_LED_CLK_CNTL                       ((0x1098  << 2) + 0xc1100000)
+#define HHI_EDP_TX_PHY_CNTL0                       ((0x109c  << 2) + 0xc1100000)
+#define HHI_EDP_TX_PHY_CNTL1                       ((0x109d  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL                              ((0x10a0  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL2                             ((0x10a1  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL3                             ((0x10a2  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL4                             ((0x10a3  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL5                             ((0x10a4  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL6                             ((0x10a5  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL7                             ((0x10a6  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL8                             ((0x10a7  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL9                             ((0x10a8  << 2) + 0xc1100000)
+#define HHI_MPLL_CNTL10                            ((0x10a9  << 2) + 0xc1100000)
+#define HHI_ADC_PLL_CNTL                           ((0x10aa  << 2) + 0xc1100000)
+#define HHI_ADC_PLL_CNTL2                          ((0x10ab  << 2) + 0xc1100000)
+#define HHI_ADC_PLL_CNTL3                          ((0x10ac  << 2) + 0xc1100000)
+#define HHI_ADC_PLL_CNTL4                          ((0x10ad  << 2) + 0xc1100000)
+#define HHI_AUDCLK_PLL_CNTL                        ((0x10b0  << 2) + 0xc1100000)
+#define HHI_AUDCLK_PLL_CNTL2                       ((0x10b1  << 2) + 0xc1100000)
+#define HHI_AUDCLK_PLL_CNTL3                       ((0x10b2  << 2) + 0xc1100000)
+#define HHI_AUDCLK_PLL_CNTL4                       ((0x10b3  << 2) + 0xc1100000)
+#define HHI_AUDCLK_PLL_CNTL5                       ((0x10b4  << 2) + 0xc1100000)
+#define HHI_AUDCLK_PLL_CNTL6                       ((0x10b5  << 2) + 0xc1100000)
+#define HHI_L2_DDR_CLK_CNTL                        ((0x10b6  << 2) + 0xc1100000)
+#define HHI_VDAC_CNTL0                             ((0x10bd  << 2) + 0xc1100000)
+#define HHI_VDAC_CNTL1                             ((0x10be  << 2) + 0xc1100000)
+#define HHI_SYS_PLL_CNTL                           ((0x10c0  << 2) + 0xc1100000)
+#define HHI_SYS_PLL_CNTL2                          ((0x10c1  << 2) + 0xc1100000)
+#define HHI_SYS_PLL_CNTL3                          ((0x10c2  << 2) + 0xc1100000)
+#define HHI_SYS_PLL_CNTL4                          ((0x10c3  << 2) + 0xc1100000)
+#define HHI_SYS_PLL_CNTL5                          ((0x10c4  << 2) + 0xc1100000)
+#define HHI_DPLL_TOP_0                             ((0x10c6  << 2) + 0xc1100000)
+#define HHI_DPLL_TOP_1                             ((0x10c7  << 2) + 0xc1100000)
+#define HHI_HDMI_PLL_CNTL                          ((0x10c8  << 2) + 0xc1100000)
+#define HHI_HDMI_PLL_CNTL2                         ((0x10c9  << 2) + 0xc1100000)
+#define HHI_HDMI_PLL_CNTL3                         ((0x10ca  << 2) + 0xc1100000)
+#define HHI_HDMI_PLL_CNTL4                         ((0x10cb  << 2) + 0xc1100000)
+#define HHI_HDMI_PLL_CNTL5                         ((0x10cc  << 2) + 0xc1100000)
+#define HHI_HDMI_PLL_CNTL6                         ((0x10cd  << 2) + 0xc1100000)
+#define HHI_DSI_LVDS_EDP_CNTL0                     ((0x10d1  << 2) + 0xc1100000)
+#define HHI_DSI_LVDS_EDP_CNTL1                     ((0x10d2  << 2) + 0xc1100000)
+#define HHI_CSI_PHY_CNTL0                          ((0x10d3  << 2) + 0xc1100000)
+#define HHI_CSI_PHY_CNTL1                          ((0x10d4  << 2) + 0xc1100000)
+#define HHI_CSI_PHY_CNTL2                          ((0x10d5  << 2) + 0xc1100000)
+#define HHI_CSI_PHY_CNTL3                          ((0x10d6  << 2) + 0xc1100000)
+#define HHI_CSI_PHY_CNTL4                          ((0x10d7  << 2) + 0xc1100000)
+#define HHI_DIF_CSI_PHY_CNTL0                      ((0x10d8  << 2) + 0xc1100000)
+#define HHI_DIF_CSI_PHY_CNTL1                      ((0x10d9  << 2) + 0xc1100000)
+#define HHI_DIF_CSI_PHY_CNTL2                      ((0x10da  << 2) + 0xc1100000)
+#define HHI_DIF_CSI_PHY_CNTL3                      ((0x10db  << 2) + 0xc1100000)
+#define HHI_DIF_CSI_PHY_CNTL4                      ((0x10dc  << 2) + 0xc1100000)
+#define HHI_DIF_CSI_PHY_CNTL5                      ((0x10dd  << 2) + 0xc1100000)
+#define HHI_LVDS_TX_PHY_CNTL0                      ((0x10de  << 2) + 0xc1100000)
+#define HHI_LVDS_TX_PHY_CNTL1                      ((0x10df  << 2) + 0xc1100000)
+#define HHI_VID2_PLL_CNTL                          ((0x10e0  << 2) + 0xc1100000)
+#define HHI_VID2_PLL_CNTL2                         ((0x10e1  << 2) + 0xc1100000)
+#define HHI_VID2_PLL_CNTL3                         ((0x10e2  << 2) + 0xc1100000)
+#define HHI_VID2_PLL_CNTL4                         ((0x10e3  << 2) + 0xc1100000)
+#define HHI_VID2_PLL_CNTL5                         ((0x10e4  << 2) + 0xc1100000)
+#define HHI_VID2_PLL_CNTL6                         ((0x10e5  << 2) + 0xc1100000)
+#define HHI_HDMI_PHY_CNTL0                         ((0x10e8  << 2) + 0xc1100000)
+#define HHI_HDMI_PHY_CNTL1                         ((0x10e9  << 2) + 0xc1100000)
+#define HHI_HDMI_PHY_CNTL2                         ((0x10ea  << 2) + 0xc1100000)
+#define HHI_HDMI_PHY_CNTL3                         ((0x10eb  << 2) + 0xc1100000)
+#define HHI_VID_LOCK_CLK_CNTL                      ((0x10f2  << 2) + 0xc1100000)
+#define HHI_ATV_DMD_SYS_CLK_CNTL                   ((0x10f3  << 2) + 0xc1100000)
+#define HHI_HDMIRX_AUD_PLL_CNTL                    ((0x10f8  << 2) + 0xc1100000)
+#define HHI_HDMIRX_AUD_PLL_CNTL2                   ((0x10f9  << 2) + 0xc1100000)
+#define HHI_HDMIRX_AUD_PLL_CNTL3                   ((0x10fa  << 2) + 0xc1100000)
+#define HHI_HDMIRX_AUD_PLL_CNTL4                   ((0x10fb  << 2) + 0xc1100000)
+#define HHI_HDMIRX_AUD_PLL_CNTL5                   ((0x10fc  << 2) + 0xc1100000)
+#define HHI_HDMIRX_AUD_PLL_CNTL6                   ((0x10fd  << 2) + 0xc1100000)
+//-----------------------------------------------------------
+// PARSER 
+//-----------------------------------------------------------
+// -----------------------------------------------
+// CBUS_BASE:  PARSER_CBUS_BASE = 0x29
+// -----------------------------------------------
+// bit 31:8 -- es_pack_size
+// bit 7:6 -- es_type     00-Video, 01-Audio, 10-Subtitle
+// bit 5 -- es_write
+// bit 4 -- es_passthrough
+// bit 3 -- insert_before_es_write
+// bit 2 -- discard_cmd
+// bit 1 -- search_cmd
+// bit 0 -- Parser Busy
+#define PARSER_CONTROL                             ((0x2960  << 2) + 0xc1100000)
+// Write
+//   bit 31:0 begin address for parser fetch
+// Read
+//   32 bit current fetch address
+#define PARSER_FETCH_ADDR                          ((0x2961  << 2) + 0xc1100000)
+// Write
+//   bit 31 circle buffer indicator
+//   bit 30 check_buffer_stop_addr
+//   bit 29:27 fetch endian 
+//   bit 26:0 buffer size ( Bytes )
+// Special command:
+//   when bit 26:0 == 27'h0
+//     then bit 29    -- stream_passthrough_enable
+//          bit 28:27 -- stream_passthrough_type
+// Read
+//   6:5 cmd_rd_ptr 
+//   4:3 cmd_wr_ptr 
+//   2:0 cmd_number 
+#define PARSER_FETCH_CMD                           ((0x2962  << 2) + 0xc1100000)
+// 31:0 stop_fetch_addr
+#define PARSER_FETCH_STOP_ADDR                     ((0x2963  << 2) + 0xc1100000)
+// 31:0 stop_fetch_addr - current_write_addr  // read only
+#define PARSER_FETCH_LEVEL                         ((0x2964  << 2) + 0xc1100000)
+// bit 31 - fetch_dma_urgent
+// bit 30 - stream_dma_urgent
+// bit 29 - force_pfifo_ren
+// bit 28 - pfifo_peak_enable
+// bit 27 - enable_free_clk_parser_reg
+// bit 26 -
+// bit 25:24 - parser_src_sel (00 - fetch, 01 - aux1, 10 - aux2 11 - aux3)
+// bit 23:16 - pfifo_empty_count
+// bit 15:12 - max_es_write_cycle (x16x64bits) 
+// 11:10 - start code width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )  
+// 9:8 - pfifo data access width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )  
+// 7:0 - empty room for fetch data ( max_fetch_cycle ) x64 bits
+#define PARSER_CONFIG                              ((0x2965  << 2) + 0xc1100000)
+// bit 24:16 -- pfifo_level
+// bit 9:0 -- point to byte address
+#define PFIFO_WR_PTR                               ((0x2966  << 2) + 0xc1100000)
+// bit 9:0 -- point to byte address
+#define PFIFO_RD_PTR                               ((0x2967  << 2) + 0xc1100000)
+// bit 31:0 -- 8/16/24/32 bits data acording to pfifo_data_width
+#define PFIFO_DATA                                 ((0x2968  << 2) + 0xc1100000)
+// bit 31:0 -- parser search pattern 
+#define PARSER_SEARCH_PATTERN                      ((0x2969  << 2) + 0xc1100000)
+// bit 31:0 -- parser search mask ( 0 - disable bit match test )
+#define PARSER_SEARCH_MASK                         ((0x296a  << 2) + 0xc1100000)
+// bit 31:16 -- parser_int_disable_count
+// bit 15:8 -- Parser interrupt enable for host cpu 
+// bit 7:0 -- Parser interrupt enable for Amrisc 
+#define PARSER_INT_ENABLE                          ((0x296b  << 2) + 0xc1100000)
+// Bit 7 -- fetch_cmd_finished
+// Bit 6:5 -- reserved
+// Bit 4 -- parse finished
+// Bit 3 -- discard finished
+// Bit 2 -- insert zero finished
+// Bit 1 -- Action Finished Except Search Start Code
+// Bit 0 -- Search match interrupt (StartCode found)
+// Read 7:0 int status
+// Write will clear (bit based) 
+#define PARSER_INT_STATUS                          ((0x296c  << 2) + 0xc1100000)
+// 15    - SCR_32_READ_OUT (Read Only)
+// 14    - SCR_32_data_valid
+// 13    - SCR_32_data
+// 12    - SCR_count_en
+// 11:0  - SCR90K_DIV
+#define PARSER_SCR_CTL                             ((0x296d  << 2) + 0xc1100000)
+// bit 31:0 SCR value
+#define PARSER_SCR                                 ((0x296e  << 2) + 0xc1100000)
+// bit 31:24 -- insert_loop_number
+// bit 23:21 -- 
+// bit 20:16 -- insert_byte_number 
+// bit 15:0 -- discard number
+#define PARSER_PARAMETER                           ((0x296f  << 2) + 0xc1100000)
+// bit 31:0 -- insert data // write only
+// write to PARSER_CONTROL will reset the write position
+// continous write to this address can write upto 16 bytes 
+#define PARSER_INSERT_DATA                         ((0x2970  << 2) + 0xc1100000)
+// Bit 31:24 -- Reserved Stream_ID
+// Bit 23:16 -- Sub Stream_ID
+// Bit 15:8  -- Audio Stream_ID
+// Bit 7:0   -- Video Stream_ID
+#define VAS_STREAM_ID                              ((0x2971  << 2) + 0xc1100000)
+// Bit 31:0 -- VIDEO_DTS
+#define VIDEO_DTS                                  ((0x2972  << 2) + 0xc1100000)
+// Bit 31:0 -- VIDEO_PTS
+#define VIDEO_PTS                                  ((0x2973  << 2) + 0xc1100000)
+// Bit 31:0 -- VIDEO_PTS_DTS_WR_PTR
+#define VIDEO_PTS_DTS_WR_PTR                       ((0x2974  << 2) + 0xc1100000)
+// Bit 31:0 -- AUDIO_PTS
+#define AUDIO_PTS                                  ((0x2975  << 2) + 0xc1100000)
+// Bit 31:0 -- AUDIO_PTS_WR_PTR
+#define AUDIO_PTS_WR_PTR                           ((0x2976  << 2) + 0xc1100000)
+// bit 31:20 -- stream_es_count ( Read Only)
+// bit 19 -- req_pending ( parser ddr_A_fifo ) (Read Only)
+// bit 18 -- stream_es_passthrough_enable
+// bit 17:16 -- stream_es_passthrough_type
+// bit 15:13 -- VIDEO2 Ees_write Endian
+// bit 12 -- VIDEO2 using manual read point
+// bit 11:9 -- SUB Ees_write Endian 
+// bit 8 -- SUB using manual read point
+// bit 7:5 -- AUDIO Ees_write Endian 
+// bit 4 -- AUDIO using manual read point
+// bit 3:1 -- VIDEO Ees_write Endian 
+// bit 0 -- VIDEO using manual read point
+#define PARSER_ES_CONTROL                          ((0x2977  << 2) + 0xc1100000)
+// Bit 31:0 PFIFO_MONITOR
+#define PFIFO_MONITOR                              ((0x2978  << 2) + 0xc1100000)
+// --------------------------------------------
+// PARSER_VIDEO DDR Interface
+// --------------------------------------------
+// The PARSER_VIDEO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define PARSER_VIDEO_START_PTR                     ((0x2980  << 2) + 0xc1100000)
+#define PARSER_VIDEO_END_PTR                       ((0x2981  << 2) + 0xc1100000)
+// --------------------------------------------
+// PARSER_VIDEO Buffer Level Manager
+// --------------------------------------------
+#define PARSER_VIDEO_WP                            ((0x2982  << 2) + 0xc1100000)
+#define PARSER_VIDEO_RP                            ((0x2983  << 2) + 0xc1100000)
+#define PARSER_VIDEO_HOLE                          ((0x2984  << 2) + 0xc1100000)
+// --------------------------------------------
+// PARSER_AUDIO DDR Interface
+// --------------------------------------------
+// The PARSER_AUDIO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define PARSER_AUDIO_START_PTR                     ((0x2985  << 2) + 0xc1100000)
+#define PARSER_AUDIO_END_PTR                       ((0x2986  << 2) + 0xc1100000)
+// --------------------------------------------
+// PARSER_AUDIO Buffer Level Manager
+// --------------------------------------------
+#define PARSER_AUDIO_WP                            ((0x2987  << 2) + 0xc1100000)
+#define PARSER_AUDIO_RP                            ((0x2988  << 2) + 0xc1100000)
+#define PARSER_AUDIO_HOLE                          ((0x2989  << 2) + 0xc1100000)
+// --------------------------------------------
+// PARSER_SUB DDR Interface
+// --------------------------------------------
+// The PARSER_SUB start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define PARSER_SUB_START_PTR                       ((0x298a  << 2) + 0xc1100000)
+#define PARSER_SUB_END_PTR                         ((0x298b  << 2) + 0xc1100000)
+// --------------------------------------------
+// PARSER_SUB Buffer Level Manager
+// --------------------------------------------
+#define PARSER_SUB_WP                              ((0x298c  << 2) + 0xc1100000)
+#define PARSER_SUB_RP                              ((0x298d  << 2) + 0xc1100000)
+#define PARSER_SUB_HOLE                            ((0x298e  << 2) + 0xc1100000)
+// Bit[31] dma_busy
+// Bit[30] cur_fetch_or_es_write
+// Bit[29:28] reserved
+// Bit[27:24] fetch_status
+// Bit[23:0] buffer_cycles_left
+#define PARSER_FETCH_INFO                          ((0x298f  << 2) + 0xc1100000)
+// Bit[31:28] ctl_status
+// Bit[27:24] insert_byte_offset
+// Bit[23:0] es_pack_left_cycle
+#define PARSER_STATUS                              ((0x2990  << 2) + 0xc1100000)
+// Bit [31:16] AUDIO_wrap_count
+// Bit  [15:0] VIDEO_wrap_count
+#define PARSER_AV_WRAP_COUNT                       ((0x2991  << 2) + 0xc1100000)
+// bit[29:24] A_brst_num_parser
+// bit[21:16] A_id_parser
+// bit[11:0] wrrsp_count_parser
+#define WRRSP_PARSER                               ((0x2992  << 2) + 0xc1100000)
+// `define CSS_cmd             12'h200   // address of css command and indirect register
+// `define CSS_cntl            12'h201   // css control register
+// `define CSS_data            12'h202   // indirect register
+// `define CSS_id1_data  	    12'h203   // ID data for the first and second bytes
+// `define CSS_id2_data  	    12'h204   // ID data for the third and fourth bytes
+//CPPM registers
+// `define CPPM_IFIFO_CTRL		12'h210	  //CPPM input FIFO control
+// `define CPPM_C2BC_KEY		12'h211	  //CPPM C2 Block Cipher Key register
+// `define CPPM_C2BC_DIN		12'h212	  //CPPM C2 Block Cipher data input register
+// `define CPPM_C2BC_DOUT		12'h213   //CPPM C2 Block Cipher data result register
+// `define CPPM_CMD			12'h214   //CPPM command and control register
+// `define CPPM_CTRL_STATUS	12'h215   //CPPM control status, mainly for debug 
+// `define CPPM_IFIFO_DATA		12'h216   //CPPM input FIFO data pop port, just for debug 
+// --------------------------------------------
+// PARSER_VIDEO2 DDR Interface
+// --------------------------------------------
+// The PARSER_VIDEO2 start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define PARSER_VIDEO2_START_PTR                    ((0x2993  << 2) + 0xc1100000)
+#define PARSER_VIDEO2_END_PTR                      ((0x2994  << 2) + 0xc1100000)
+// --------------------------------------------
+// PARSER_VIDEO2 Buffer Level Manager
+// --------------------------------------------
+#define PARSER_VIDEO2_WP                           ((0x2995  << 2) + 0xc1100000)
+#define PARSER_VIDEO2_RP                           ((0x2996  << 2) + 0xc1100000)
+#define PARSER_VIDEO2_HOLE                         ((0x2997  << 2) + 0xc1100000)
+// Bit [31:16] AUDIO_wrap_count
+// Bit  [15:0] VIDEO2_wrap_count
+#define PARSER_AV2_WRAP_COUNT                      ((0x2998  << 2) + 0xc1100000)
+// DDR registers
+//`define USE_DDR2
+//========================================================================
+//  DVIN Registers				    (12'h2e0 - 12'h2ef)
+//
+//========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  DVIN_CBUS_BASE = 0x12
+// -----------------------------------------------
+// Bit 31:12 Rsrv
+// Bit 11:10 RW, vs_hs_tim_ctrl: Controls which edge of HS/VS the active pixel/line is related:
+//                               bit[0]=0: start of active pixel is counted from the rising edge of HS;
+//                               bit[0]=1: start of active pixel is counted from the falling edge of HS;
+//                               bit[1]=0: start of active line is counted from the rising edge of VS;
+//                               bit[1]=1: start of active line is counted from the falling edge of VS.
+// Bit     9 RW, sample_clk_neg: 1=invert input dvin_clk
+// Bit  8: 7 RW, mode_422to444: 0=No convertion; 1=Rsrv; 2=Convert 422 to 444, use previous C value; 3=Convert 422 to 444, use average C value.
+// Bit  6: 5 RW, de_mode: 0x=ignore input DE signal, use internal detection to to determine active pixel;
+//                        10=during active pixel, if DE is low, replace input data with the last good data before DE goes low;
+//                        11=Active pixel is determined by DE, no internal detection.
+// Bit     4 RW, ext_field_sel: 1=Select external input Field, 0=Use internal detected Field.
+// Bit     3 RW, field_pol_inv: set to 1 if input Field is low active and ext_field_sel=1
+// Bit     2 RW, de_pol_inv: set to 1 if input DE is low active
+// Bit     1 RW, vs_pol_inv: set to 1 if input VS is low active
+// Bit     0 RW, hs_pol_inv: set to 1 if input HS is low active
+#define DVIN_FRONT_END_CTRL                        ((0x12e0  << 2) + 0xc1100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, hs_lead_vs_odd_max: Criteria for HW detecting odd/even Field internally: max clock cycles allowed for HS
+//                                   active edge to lead before VS active edge, in odd field. Failing it the field is even.
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, hs_lead_vs_odd_min: Criteria for HW detecting odd/even Field internally -- min clock cycles allowed for HS
+//                                   active edge to lead before VS active edge, in odd field. Failing it the field is even.
+#define DVIN_HS_LEAD_VS_ODD                        ((0x12e1  << 2) + 0xc1100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, active_start_pix_fo
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, active_start_pix_fe
+#define DVIN_ACTIVE_START_PIX                      ((0x12e2  << 2) + 0xc1100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, active_start_line_fo
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, active_start_line_fe
+#define DVIN_ACTIVE_START_LINE                     ((0x12e3  << 2) + 0xc1100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, field_height_m1
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, line_width_m1
+#define DVIN_DISPLAY_SIZE                          ((0x12e4  << 2) + 0xc1100000)
+// Bit    31 Rsrv
+// Bit    30 R,  vs_in_polarity: 0=active high; 1=active low.
+// Bit    29 R,  hs_in_polarity: 0=active high; 1=active low.
+// Bit    28 R,  field_odd
+// Bit 27:16 R,  hs_lead_vs_cnt
+// Bit 15: 4 Rsrv
+// Bit  3: 1 RW, data_comp_map: Re-map input data to form YCbCr.
+//                              0=YCbCr is {[29:20], [19:10], [ 9: 0]};
+//                              1=YCbCr is {[29:20], [ 9: 0], [19:10]};
+//                              2=YCbCr is {[ 9: 0], [29:20], [19:10]};
+//                              3=YCbCr is {[19:10], [29:20], [ 9: 0]};
+//                              4=YCbCr is {[19:10], [ 9: 0], [29:20]};
+//                              5=YCbCr is {[ 9: 0], [19:10], [29:20]};
+//                              6,7=Rsrv
+// Bit     0 RW, dvin_enable
+#define DVIN_CTRL_STAT                             ((0x12e5  << 2) + 0xc1100000)
+//========================================================================
+//  DOS registers				    APB allocation from 32'hd0050000
+//
+//========================================================================
+//=======================================================================
+// XIF module
+// `include "xregs.h"
+    #define X_INT_ADR           0x400
+    #define GPIO_ADR            0x401
+    #define GPIO_ADR_H8         0x402 
+    #define WFIFO_DEPTH         8          
+    #define WFIFO_PointerWidth  3
+    #define WFIFO_WORDSIZE      32
+// MAC module
+// move them to cpu domain.
+//`define CLR_ACC_MAC         12'h410   
+//`define CLR_ACC_MAC2        12'h411   
+//`define ACC_0               12'h412
+//`define ACC_1               12'h413
+//`define ACC_2               12'h414
+//`define ACC_3               12'h415
+//========================================================================
+//  Audio Interface				    (12'h500 - 12'h5ff)
+//
+//========================================================================
+//
+// Reading file:  aregs.h
+//
+//========================================================================
+//  Audio Interface                                 (8'h00 - 8'hff)
+//  Modified : Xuyun Chen Jan 2001
+//========================================================================
+// Number of bytes expected per NON-PCM frame, including the header.
+// 16 bits.  
+// -----------------------------------------------
+// CBUS_BASE:  AIU_CBUS_BASE = 0x15
+// -----------------------------------------------
+#define AIU_958_BPF                                ((0x1500  << 2) + 0xc1100000)
+// Value of burst_info used in IEC958 preamble for a NON-PCM frame. See
+// ATSC AC-3 spec Annex B. 16 bits.
+#define AIU_958_BRST                               ((0x1501  << 2) + 0xc1100000)
+// Value of length_code used in IEC958 preamble for an NON-PCM frame. See
+// ATSC AC-3 spec Annex B. 16 bits.
+#define AIU_958_LENGTH                             ((0x1502  << 2) + 0xc1100000)
+// How many subframes to padd around the NON-PCM frame. This will 
+// be set to 'd3072 if it is a AC-3 audio stream.
+// 16 bits
+#define AIU_958_PADDSIZE                           ((0x1503  << 2) + 0xc1100000)
+// 16'd3072
+// Misc. control settings for IEC958 interface
+// Bit 15:14 pcm_sample_ctl, 00-pcm_no_sample, 01-pcm_sample_up, 10-pcm_sample_down, 11-pcm_sample_down_drop
+// Bit 13: if true, force each audio data to left or right according to the bit attached with the audio data
+//         This bit should be used with Register AIU_958_force_left(0x505) together
+// Bit 12: if true, the U(user data) is from the stream otherwise it is filled by 
+//                   zero while encoding iec958 frame
+// Bit 11   : if true big endian(highword,lowword) otherwise little endian(lowword,highword)
+//            for 32bit mode 
+// Bit 10:8 : shift number for 32 bit mode
+// Bit 7  : 32 bit mode turn on while This bit is true and Bit 1 is true 
+// Bit 6:5 : Specifies output alignment for 16 bit pcm data.
+//          00 : dout = {8'b0, din};
+//          01 : dout = {4'b0, din, 4'b0};
+//          10 : dout = {      din, 8'b0};
+// Bit 4  : True if data should be sent out MSB first. LSB first is the
+//          default in the spec.
+// Bit 3  : True if msb should be extended (only used with 16 bit pcm data.)
+// Bit 2  : True if msb of PCM data should be inverted.
+// Bit 1  : True if PCM data is 16 bits wide. False if 24 bit or 32bit mode.
+// Bit 0  : True if source data is non-PCM data. False if it is PCM data.
+#define AIU_958_MISC                               ((0x1504  << 2) + 0xc1100000)
+// 14'b0_0_0_000_0_0000001
+// A write to this register specifies that the next pcm sample sent out
+// of the iec958 interface should go into the _left_ channel.
+#define AIU_958_FORCE_LEFT                         ((0x1505  << 2) + 0xc1100000)
+//Read Only
+//bit 6:0  how many data discarded in the last dma after one frame data finish transfering to AIU 
+// should used together with register AIU_958_dcu_ff_ctrl
+#define AIU_958_DISCARD_NUM                        ((0x1506  << 2) + 0xc1100000)
+//bit 15:8  : A read from this register indicates the IEC958 FIFO count value 
+//bit 7 :  ai_958_req_size if ture, set to 8 bits interface, used to handle odd frame continous read  
+//bit 6 :  continue seeking and dont discard the rest data in one dma after frame end
+//bit 5 :  if true, byte by byte seeking, otherwise word by word seeking
+//bit 4 :  if true, the function for sync head seeking is enabled
+//bit 3:2 :	IEC958 interrupt mode
+// There are two conditions to generate interrupt. The First condition is that one frame data
+// have been finished writing into FIFO. The second condition is at least some data of the current 
+// frame have been read out(refer to Register AIU_958_ffrdout_thd)
+//			00: interrupt is not generated
+//			10:	interrupt is generated if the first condition is true 
+//			01:	interrupt is generated if the second condition is true 
+//			11:	interrupt is generated if both of the conditions are true 
+//bit 1: fifo auto disable, High means after one frame data put into the FIFO, the FIFO
+//					will automatically disabled
+//bit 0: fifo enable
+#define AIU_958_DCU_FF_CTRL                        ((0x1507  << 2) + 0xc1100000)
+// 'b0_0_1_11_1_0
+// channel status registers for Left channel
+// chstat_l0[15:0] contains bits 15:0 of the channel status word. Note
+// that bit zero of the channel status word is sent out first.
+// chstat_l1[15:0] contains bits 31:16 of the channel status word.
+#define AIU_958_CHSTAT_L0                          ((0x1508  << 2) + 0xc1100000)
+#define AIU_958_CHSTAT_L1                          ((0x1509  << 2) + 0xc1100000)
+// Control register for IEC958 interface
+// Bit 9:8 what to do if there is a fifo underrun
+//         00 => insert 24'h000000
+//         01 => insert mute constant as defined below
+//         10 => repeat last l/r samples
+// Bit 7:5 mute constant
+//         000 => 24'h000000
+//         001 => 24'h800000
+//         010 => 24'h080000
+//         011 => 24'h008000
+//         100 => 24'h000001
+//         101 => 24'h000010
+//         110 => 24'h000100
+// Bit 4   mute left speaker
+// Bit 3   mute right speaker
+// Bit 2:1 swap channels
+//         00 : L R => L R
+//         01 : L R => L L
+//         10 : L R => R R
+//         11 : L R => R L
+// Bit 0   Set this bit to hold iec958 interface after the current
+//         subframe has been completely transmitted.
+#define AIU_958_CTRL                               ((0x150a  << 2) + 0xc1100000)
+// 10'b00_000_00_00_0
+// A write operation to this register will cause one of the output samples
+// to be repeated. This can be used to switch the left and the right
+// channels.
+#define AIU_958_RPT                                ((0x150b  << 2) + 0xc1100000)
+// Channel swap and mute control register.
+// Bit 15: Mute extra left channel
+// Bit 14: Mute extra right channel
+// Bit 13: Mute center
+// Bit 12: Mute subwoofer
+// Bit 11: Mute surround left
+// Bit 10: Mute surround right
+// Bit  9: Mute left
+// Bit  8: Mute right
+// Bit 7:6 Channel swap for xtra dac
+// Bit 5:4 Channel swap for sub/center dac
+// Bit 3:2 Channel swap for surround dac
+// Bit 1:0 Channel swap for main l/r dac
+// Channel swap possibilities:
+// 00 : L R => L R
+// 01 : L R => L L
+// 10 : L R => R R
+// 11 : L R => R L
+#define AIU_I2S_MUTE_SWAP                          ((0x150c  << 2) + 0xc1100000)
+// 16'b0
+// Bit 0 : 0=> single two channel stream
+//         1=> four two channel streams
+#define AIU_I2S_SOURCE_DESC                        ((0x150d  << 2) + 0xc1100000)
+// Median filter control register
+// Bit 1:  0=> data is offset binary
+//         1=> data is signed
+// Bit 0:  enable median filter
+#define AIU_I2S_MED_CTRL                           ((0x150e  << 2) + 0xc1100000)
+// 2'b10
+// Median filter threshold constant
+// 16 bits
+#define AIU_I2S_MED_THRESH                         ((0x150f  << 2) + 0xc1100000)
+// 16'h8000
+// Describes dac's connected to I2S interface
+// Bit 7:  sign extend sample before downshift.
+// Bit 6:4 payload downshift constant
+// Bit 3:  mute constant
+//         0 => 'h0000000
+//         1 => 'h800000
+// Bit 2:  send msb first
+// Bit 1:0 Size of payload
+//         Note that this parameter used to be called "size of dacs"
+//         It is now called the payload size since a 24 bit payload can
+//         actually be connected to any size of dac. The dac will simply
+//         disregard the extra bits.
+//         00 => 16 bit, alrclk = aoclk/32 
+//         01 => 20 bit, alrclk = aoclk/40 
+//         10 => 24 bit, alrclk = aoclk/48 
+//		   11 => 24 bit, but alrclk = aoclk/64 
+#define AIU_I2S_DAC_CFG                            ((0x1510  << 2) + 0xc1100000)
+// 8'b0_000_1_1_10
+// A write to this register will cause the interface to repeat the current
+// sample. Can be used to regain synchronization.
+// A read from this register indicates that the next sample to be sent
+// out of the interface should go into the _left_ channel of the dac.
+#define AIU_I2S_SYNC                               ((0x1511  << 2) + 0xc1100000)
+// Misc regs
+// Bit 4 if true, force each audio data to left or right according to the bit attached with the audio data
+//         This bit should be used with Register AIU_i2s_sync(0x511) together
+// Bit 3:  Same Audio source for IEC958 and I2s stream 0, both from i2s buffer 
+// Bit 2:  Set this bit to put i2s interface in hold mode
+// Bit 1:0 How to handle underruns
+//         00 => send zeros
+//         01 => send 'h800000
+//         10 => repeat last samples
+#define AIU_I2S_MISC                               ((0x1512  << 2) + 0xc1100000)
+// 5'b0
+// Bit 7:0 Audio output config.
+//			2 bits for each dac, 7:6 for dac3, 5:4 for dac2,
+//								 3:2 for dac1, 1:0 for dac0
+//			For each 2bits: 00: connect channel0-1 to the dac
+//							01: connect channel2-3 to the dac
+//							10: connect channel4-5 to the dac
+//							11: connect channel6-7 to the dac
+#define AIU_I2S_OUT_CFG                            ((0x1513  << 2) + 0xc1100000)
+// 8'b0_000000_0
+#define AIU_I2S_FF_CTRL                            ((0x1514  << 2) + 0xc1100000)
+// A write to this register resets the AIU
+//Bit 3 reset slow domain iec958
+//Bit 2 soft reset iec958 fast domain
+//Bit 1 reset slow domain i2s
+//Bit 0 soft reset i2s fast domain
+#define AIU_RST_SOFT                               ((0x1515  << 2) + 0xc1100000)
+// Clock generation control register
+// Bit 15: enable_ddr_arb, set low to reset
+// Bit 14:13 parser_A_addr_sel  00-A_addr_aififo2, 01-A_addr_iec958, 10-A_addr_aififo, 11-A_addr_i2s
+// Bit 12: 958 divisor more, if true, divided by 2, 4, 6, 8
+// Bit 11: amclk output divisor
+//			0 => dont divide
+//			1 => divide by 2		
+// Bit 10: clock source selection
+//        0 => aiclk from pin
+//        1 => ai_pll_clk from pll
+// Bit 9:8 alrclk skew
+//         00 => alrclk transitions at the same time msb is sent
+//         01 => alrclk transitions on the cycle before msb is sent
+//         10 => alrclk transitions on the cycle after msb is sent
+// Bit 7: invert alrclk
+// Bit 6: invert aoclk
+// Bit 5:4 958 divisor
+//        00 => divide by 1
+//        01 => divide by 2
+//		  10 => divide by 3
+//		  11 => divide by 4
+// Bit 3:2 i2s divisor. NOTE: this value is ignored if AIU_clk_ctrl_more[5:0] != 0 
+//         00 => divide by 1
+//         01 => divide by 2
+//         10 => divide by 4
+//         11 => divide by 8
+// Bit 1: enable 958 divider
+// Bit 0: enable i2s divider
+#define AIU_CLK_CTRL                               ((0x1516  << 2) + 0xc1100000)
+// 13'b0_0_1_01_1_1_10_11_0_0
+// Misc settings that determine the type of adc that is
+// connected to the AIU. Reverb mode is deleted.
+// Bit 12:  selects adc input
+// Bit 11:10 adc size
+//           00 => 16 bits
+//           01 => 18 bits
+//           10 => 20 bits
+//           11 => 24 bits
+// Bit 9:8   adc l/r swap mode
+//           00 => stereo
+//           01 => send the right adc input to both l and r speakers
+//           01 => send the left adc input to both l and r speakers
+//           11 => sum the left and right inputs and forward to
+//                both speakers
+// Bit 7:5 adata/lrclk skew mode
+// Bit 4   1=>invert the adc's lrclk (This is the lrclk going _out_
+//         of the chip.
+// Bit 3   1=>Latch the data on the positive edge of the _internal_
+//         aoclk.
+// Bit 2   1=>adc data is in signed 2's complement mode
+#define AIU_MIX_ADCCFG                             ((0x1517  << 2) + 0xc1100000)
+// 12'b01_00_001_1_0_1_00
+// Control register that can be changed dynamically. These control
+// signals are synchronized internally.
+// Bit 12:  if true, toggle each mixed audio data to left or right channel
+// Bit 11:  abuf din left selection, if true, select bit 24 of the data from abuf
+//		    otherwise select bit 25 of the data from abuf
+// Bit 10:9  mix sync select, when music, mic and abuf are mixed togather, the main
+//			 sync source can be selected
+//     00: not sync source
+//	   01: music data is the main sync source
+//	   10: abuf input data is the main sync source
+//	   11: music and abuf togather as the sync source
+// Bit 8:  0=> data from abuf is offset binary
+//         1=> data from abuf is signed
+// Bit 7:6 the source for data from aiu to abuf 
+//           00 => mic
+//           01 => mic saled + abuf scaled 
+//           10 => mic scaled + abuf scaled + music scaled
+//			 11 => music
+// Bit 5   channel from aiu to abuf is on
+// Bit 4   channel from abuf to aiu is on
+// Bit 3   mic is on
+// Bit 2   music is on
+// Bit 1   if true the mixed data are outputed to i2s dac channel,
+//			otherwise the mixed data are outputed to IEC958 output 
+// Bit 0   if true music source for mixing is from i2s buffer, 
+//			otherwise music source is from iec958 buffer
+#define AIU_MIX_CTRL                               ((0x1518  << 2) + 0xc1100000)
+// 11'b01_1_01_0_0_0_1_1_1
+// Bit    15 invert_audin_sclk.
+// Bit    14 enable_adc_sclk.
+// Bit 13: 8 divisor_adc_sclk.
+// Bit     7 invert_acodec_adc_sclk.
+// Bit     6 hdmitx_sel_aoclkx2: 0=Select cts_clk_i958 as AIU clk to hdmi_tx_audio_master_clk; 1=Select cts_aoclkx2_int as AIU clk to hdmi_tx_audio_master_clk;
+// Bit  5: 0 More control on i2s divisor. For backward compatiblity, this value is ignored if is 0,
+//           if non-zero, it takes effect over AIU_clk_ctrl[3:2].
+//           0=i2s divisor will use the old value in AIU_clk_ctrl[3:2] (divide by 1/2/4/8)
+//           1=divide by 2;
+//           2=divide by 3;
+//           3=divide by 4;
+//           ... and so on ...
+//           63=divide by 64.
+#define AIU_CLK_CTRL_MORE                          ((0x1519  << 2) + 0xc1100000)
+// A read from this register pops 16 bits of data off the 958
+// fifo. A write has no effect.
+#define AIU_958_POP                                ((0x151a  << 2) + 0xc1100000)
+//gain register for mixing
+// for each gain, 
+//			 00000: x 0
+//			 00001: x 1
+//			 00010: x 2
+//           00011: x 3
+//			 00100: x 4
+//			 00101: x 5
+//			 00110: x 6
+//			......
+//           01110: x14
+//           01111: x15
+//           10000: x 0
+//           10001: x 1/16
+//           10010: x 2/16
+//           10011: x 3/16
+//           10100: x 4/16
+//			......
+//           11110: x 14/16
+//           11111: x 15/16
+//Bit 14:10 mic gain
+//Bit 9:5 	abuf gain
+//Bit 4:0 music gain
+#define AIU_MIX_GAIN                               ((0x151b  << 2) + 0xc1100000)
+// 15'b00001_00001_00001
+//sync head seeking is supported. The  maxinium length of sync head is
+//48-bit-wide.(in byte by byte seeking mode, the maximium is 44-bit-wide).
+//It is consisted of 3 words (synword1_synword2_syncword3).
+//You can configure the sync head pattern by using sync mask(mask1_mask2_mask3).  
+//For example. AC-3 sync head is a 16-bit word(0b77), so syncword1 is set as 0b77, 
+//mask1 is 0000(not set), mask2 and mask3 is all masked.
+#define AIU_958_SYNWORD1                           ((0x151c  << 2) + 0xc1100000)
+//16'h0b77  //ac-3 sync head
+#define AIU_958_SYNWORD2                           ((0x151d  << 2) + 0xc1100000)
+//16'h0000  
+#define AIU_958_SYNWORD3                           ((0x151e  << 2) + 0xc1100000)
+//16'h0000
+#define AIU_958_SYNWORD1_MASK                      ((0x151f  << 2) + 0xc1100000)
+//16'h0000 //16-bit ac-3 sync_head
+#define AIU_958_SYNWORD2_MASK                      ((0x1520  << 2) + 0xc1100000)
+//16'hffff
+#define AIU_958_SYNWORD3_MASK                      ((0x1521  << 2) + 0xc1100000)
+//16'hffff
+//fifo read-out threshold, one condition to generate interrupt is met after fifo readout counter
+//reach this value in a frame, please refer to register AIU_958_dcu_ff_ctrl
+#define AIU_958_FFRDOUT_THD                        ((0x1522  << 2) + 0xc1100000)
+//'h0004
+//For pause burst sequence adding, one pause burst sequence is consist of a serious
+// pause burst.
+//This register defines the length of each pause burst in a pause burst sequence. The size of the
+//preamble(Pa, Pb, Pc, Pd) is not counted, but the size of stuff data is counted.
+#define AIU_958_LENGTH_PER_PAUSE                   ((0x1523  << 2) + 0xc1100000)
+//'h0000
+//This reigster defines the number of pause burst in a pause burst sequence.
+//Bit 15  if true, one pause burst sequence will be added 
+//Bit 14:0 the number of pause burst in a pause burst sequence
+#define AIU_958_PAUSE_NUM                          ((0x1524  << 2) + 0xc1100000)
+//'h0000
+//The first 16-bit in the payload of pause burst sequence (gap_length)
+#define AIU_958_PAUSE_PAYLOAD                      ((0x1525  << 2) + 0xc1100000)
+//'h0000
+//For auto pause function, when enabled, pause burst sequence will be automatically added if the data in
+// 958 fifo is less than auto_pause threshold and if fifo is disabled.
+//Bit 15   if true, auto pause function enable
+//Bit 14   pause pack option, just for debugging and adding one option
+//Bit 7:0  auto_pause threshold
+#define AIU_958_AUTO_PAUSE                         ((0x1526  << 2) + 0xc1100000)
+//'h0000
+//pause burst sequence payload length( = AIU_958_pause_num * AIU_958_length_per_pause)
+#define AIU_958_PAUSE_PD_LENGTH                    ((0x1527  << 2) + 0xc1100000)
+//'h0000
+// Bit 15:12 Rsrv.
+// Bit 11: 0 dac_lrclk_div: Default is 48-1=47, which means lrclk is sclk divide by 48.
+#define AIU_CODEC_DAC_LRCLK_CTRL                   ((0x1528  << 2) + 0xc1100000)
+//'h002f
+// Bit 15:14 Rsrv.
+// Bit    13 inv_audin_lrclk: whether to invert lrclk before output to Audin
+// Bit    12 inv_acodec_adc_lrclk: whether to invert lrclk before output to Audio Codec
+// Bit 11: 0 adc_lrclk_div: Default is 48-1=47, which means lrclk is sclk divide by 48.
+#define AIU_CODEC_ADC_LRCLK_CTRL                   ((0x1529  << 2) + 0xc1100000)
+//'h002f
+// Bit 15:6 Rsrv.
+// Bit  5: 4 hdmi_data_sel: 00=output 0, disable hdmi data; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+// Bit  3: 2 Rsrv.
+// Bit  1: 0 hdmi_clk_sel: 00=Disable output hdmi clock; 01=Select pcm clock; 10=Select AIU clk; 11=Not allowed.
+#define AIU_HDMI_CLK_DATA_CTRL                     ((0x152a  << 2) + 0xc1100000)
+//'h0000
+// Bit 15:6 Rsrv.
+// Bit  5: 4 acodec_data_sel: 00=output 0, disable acodec_sdin; 01=Select pcm data; 10=Select AIU I2S data; 11=Not allowed.
+// Bit  3: 2 Rsrv.
+// Bit  1: 0 acodec_clk_sel: 00=Disable output acodec_sclk; 01=Select pcm clock; 10=Select AIU aoclk; 11=Not allowed.
+#define AIU_CODEC_CLK_DATA_CTRL                    ((0x152b  << 2) + 0xc1100000)
+//'h0000
+// channel status registers for right channel
+// chstat_r0[15:0] contains bits 15:0 of the channel status word. Note
+// that bit zero of the channel status word is sent out first.
+// chstat_r1[15:0] contains bits 31:16 of the channel status word.
+#define AIU_958_CHSTAT_R0                          ((0x1530  << 2) + 0xc1100000)
+#define AIU_958_CHSTAT_R1                          ((0x1531  << 2) + 0xc1100000)
+//Bit 1 	if true, turn on Digital output Valid control
+//Bit 0		0: output 0, 1: output 1 to the valid bit in audio digital output when Bit 1 is true
+#define AIU_958_VALID_CTRL                         ((0x1532  << 2) + 0xc1100000)
+//-----------------------------------------------------------------------------
+// Audio Amplifier controls
+//-----------------------------------------------------------------------------
+#define AIU_AUDIO_AMP_REG0                         ((0x153c  << 2) + 0xc1100000)
+#define AIU_AUDIO_AMP_REG1                         ((0x153d  << 2) + 0xc1100000)
+#define AIU_AUDIO_AMP_REG2                         ((0x153e  << 2) + 0xc1100000)
+#define AIU_AUDIO_AMP_REG3                         ((0x153f  << 2) + 0xc1100000)
+//-----------------------------------------------------------------------------
+//add for AIFIFO2 channel
+//-----------------------------------------------------------------------------
+//Bit 3 	CRC pop aififo2 enable
+//Bit 2		writing to this bit to 1 causes CRC module reset
+//Bit 1		unused
+//Bit 0		writing to this bit to 1 causes AIFIFO2 soft reset
+#define AIU_AIFIFO2_CTRL                           ((0x1540  << 2) + 0xc1100000)
+//'h0000
+//AIFIFO2 status register
+//Bit 4:0		//how many bits left in the first pop register
+#define AIU_AIFIFO2_STATUS                         ((0x1541  << 2) + 0xc1100000)
+//Same fucntion as the AIGBIT of AIFIFO in CDROM module
+//write to this register how many bits wanna pop, 
+//and reading this register gets the corresponding bits data
+#define AIU_AIFIFO2_GBIT                           ((0x1542  << 2) + 0xc1100000)
+//Same function as the AICLB of AIFIFO in CDROM module
+//return the leading zeros by reading this registers
+#define AIU_AIFIFO2_CLB                            ((0x1543  << 2) + 0xc1100000)
+//CRC control register, read/write
+//Bit 0		CRC caculation start
+//Bit 1		CRC core soft reset
+//Bit 2		CRC input register clear
+//Bit 3		CRC pop data from FIFO enable
+//Bit 13:8	CRC polynomial equation order, between 1 to 32
+#define AIU_CRC_CTRL                               ((0x1544  << 2) + 0xc1100000)
+//16'h1000
+//CRC status register, read only
+//Bit 7:4	CRC internal shift register bit select, just for debug purpose
+//Bit 3		CRC internal shift register data valid, just for debug purpose
+//Bit 2		CRC input register data valid
+//Bit 1		CRC result, 1: CRC not correct, 0: CRC correct
+//Bit 0		CRC state,  1: CRC busy, 0: CRC idle
+#define AIU_CRC_STATUS                             ((0x1545  << 2) + 0xc1100000)
+//CRC internal shift register, read only, for debug purpose
+#define AIU_CRC_SHIFT_REG                          ((0x1546  << 2) + 0xc1100000)
+//CRC data input register, read/write
+#define AIU_CRC_IREG                               ((0x1547  << 2) + 0xc1100000)
+//16'h0000
+//CRC calculation register high-bit part [31:16], read/write
+#define AIU_CRC_CAL_REG1                           ((0x1548  << 2) + 0xc1100000)
+//CRC calculation register low-bit part [15:0], read/write
+#define AIU_CRC_CAL_REG0                           ((0x1549  << 2) + 0xc1100000)
+//32'h00000000
+//CRC polynomial coefficient high-bit part [31:16], read/write
+#define AIU_CRC_POLY_COEF1                         ((0x154a  << 2) + 0xc1100000)
+//CRC polynomial coefficient low-bit part [15:0], read/write
+#define AIU_CRC_POLY_COEF0                         ((0x154b  << 2) + 0xc1100000)
+//32'h80050000			default CRC-16
+//CRC frame size, high-bit part [19:16], read/write
+#define AIU_CRC_BIT_SIZE1                          ((0x154c  << 2) + 0xc1100000)
+//CRC frame size, low-bit part [15:0],	 read/write
+#define AIU_CRC_BIT_SIZE0                          ((0x154d  << 2) + 0xc1100000)
+//20'hfffff
+//how many bits have been processed right now in the current frame, read only
+//high-bit part [19:16]
+#define AIU_CRC_BIT_CNT1                           ((0x154e  << 2) + 0xc1100000)
+//low-bit part [15:0]
+#define AIU_CRC_BIT_CNT0                           ((0x154f  << 2) + 0xc1100000)
+// -------------------------------------
+// AMCLK Measurement
+// -------------------------------------
+// Used to measure the amclk frequency
+#define AIU_AMCLK_GATE_HI                          ((0x1550  << 2) + 0xc1100000)
+#define AIU_AMCLK_GATE_LO                          ((0x1551  << 2) + 0xc1100000)
+#define AIU_AMCLK_MSR                              ((0x1552  << 2) + 0xc1100000)
+#define AIU_AUDAC_CTRL0                            ((0x1553  << 2) + 0xc1100000)
+// -------------------------------------
+// Super Simple Delta Sigma DAC
+// -------------------------------------
+// bit 15   1 = invert the clock to the analog filter
+// bit 14   1 = digital mute
+// bit 13   1 = enable analog mute (in the analog block)
+// bit 12   1 = enable Right channel 3 in the analog block
+// bit 11   1 = enable Left  channel 3 in the analog block
+// bit 10   1 = enable Right channel 2 in the analog block
+// bit  9   1 = enable Left  channel 2 in the analog block
+// bit  8   1 = enable Right channel 1 in the analog block
+// bit  7   1 = enable Left  channel 1 in the analog block
+// bit  6   1 = enable Right channel 0 in the analog block
+// bit  5   1 = enable Left  channel 0 in the analog block
+// bit  4:  bit select for serial input data
+// bit  3:  invert alrclk used by the delta-sigma DAC
+// bit  2:  1 = use serial I2S data.  0 = use parallel audio data
+// bits 1:0 Which data to send to the delta-sigma DAC
+//              11 = use channel 3 data
+//              10 = use channel 2 data
+//              01 = use channel 1 data
+//              00 = use channel 0 data
+#define AIU_DELTA_SIGMA0                           ((0x1555  << 2) + 0xc1100000)
+// Delta Sigma MUTE Value
+#define AIU_DELTA_SIGMA1                           ((0x1556  << 2) + 0xc1100000)
+// Additional Audio filter controls
+#define AIU_DELTA_SIGMA2                           ((0x1557  << 2) + 0xc1100000)
+//Bit 14, left channel Delta Sigma modulator soft reset
+//Bit 13, right channel Delta Sigma modulator soft reset
+//Bit 12, left channel Delta Sigma modulator internal state clear enable when it is unstable
+//Bit 11, right channel Delta Sigma modulator internal state clear enable when it is unstable
+//Bit 10, left channel Delta Sigma detect unstable state enable
+//Bit  9, right channel Delta Sigma detect unstable state enable
+//Bit  8, dither high pass filter enable in the Delta Sigma loop
+//Bit 7:6, reserved
+//Bit 5:0, Delta Sigma input data gain  0/32 ~ 63/32
+//default: 16'h3
+#define AIU_DELTA_SIGMA3                           ((0x1558  << 2) + 0xc1100000)
+//15:8, Added Delta Sigma DC level, range:+-1/2, minimium: +-1/128 (assume max is -1 ~ +1)
+//7:0, max same sequence number, used for unstable detection
+//default: 16'h0
+#define AIU_DELTA_SIGMA4                           ((0x1559  << 2) + 0xc1100000)
+//Bit 15:8, square wave divide num
+//Bit 7:0, square wave amplitude, -1/4 ~ 1/4, minimium: +-1/1024
+//default: 16'h0
+#define AIU_DELTA_SIGMA5                           ((0x155a  << 2) + 0xc1100000)
+//Bit 11:8, loop dither amplitude2, 0/32 ~ 15/32
+//Bit 7:4,  loop dither amplitude1, 0/32 ~ 15/32
+//Bit 3:0,  loop dither amplitude0, 0/32 ~ 15/32
+//default: 16'h0
+#define AIU_DELTA_SIGMA6                           ((0x155b  << 2) + 0xc1100000)
+//Bit 15:8, loop dithering threshold1   0, 1/512, 2/512 ... 1/2
+//Bit 7:0,  loop dithering threshold0   0, 1/512, 2/512 ... 1/2
+//default: 16'h0
+#define AIU_DELTA_SIGMA7                           ((0x155c  << 2) + 0xc1100000)
+//read only
+//Bit 15:8  left channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
+//          It will saturate to 255, if more than 255 time
+//Bit 7:0   left channel max same sequence number
+#define AIU_DELTA_SIGMA_LCNTS                      ((0x155d  << 2) + 0xc1100000)
+//read only
+//Bit 15:8  right channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
+//          It will saturate to 255, if more than 255 time
+//Bit 7:0   right channel max same sequence number
+#define AIU_DELTA_SIGMA_RCNTS                      ((0x155e  << 2) + 0xc1100000)
+// --------------------------------------------
+// I2S DDR Interface
+// --------------------------------------------
+// The I2S start pointer into DDR memory is a 32-bit number
+#define AIU_MEM_I2S_START_PTR                      ((0x1560  << 2) + 0xc1100000)
+#define AIU_MEM_I2S_RD_PTR                         ((0x1561  << 2) + 0xc1100000)
+#define AIU_MEM_I2S_END_PTR                        ((0x1562  << 2) + 0xc1100000)
+// There are two masks that control how data is read:
+// [31:16] IRQ block.
+// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
+// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
+#define AIU_MEM_I2S_MASKS                          ((0x1563  << 2) + 0xc1100000)
+// I2S FIFO Control
+// bits [11:10] Select which hardware pointer to use to control the buffer
+//              level:
+//                  00 = parser 
+//                  01 = audin_fifo0_wrpt 
+//                  1x = audin_fifo1_wrpt 
+// bit  [9]     Use level control: 1 = use buffer level control
+// bit  [8]     Read Only.  This bit is 1 when there is data available for reading
+// bit  [7]     Read only.  This bit will be high when we're fetching data from the DDR memory
+//              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
+//              After that you can pulse cntl_init to start over
+// bit  [6]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR
+// bits [5:3]   endian:  see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading data from the FIFO
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+#define AIU_MEM_I2S_CONTROL                        ((0x1564  << 2) + 0xc1100000)
+// --------------------------------------------
+// IEC958 DDR Interface
+// --------------------------------------------
+// The IEC958 start pointer into DDR memory is a 32-bit number
+#define AIU_MEM_IEC958_START_PTR                   ((0x1565  << 2) + 0xc1100000)
+#define AIU_MEM_IEC958_RD_PTR                      ((0x1566  << 2) + 0xc1100000)
+#define AIU_MEM_IEC958_END_PTR                     ((0x1567  << 2) + 0xc1100000)
+// There are two masks that control how data is read:
+// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
+// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
+#define AIU_MEM_IEC958_MASKS                       ((0x1568  << 2) + 0xc1100000)
+// IEC958 FIFO Control
+// bit  [31]    A_urgent
+// bit  [30]    ch_always_8
+// bit  [29:24] rdata_rd_base_begin ( used for select from different channel ) 
+// bit  [23:14] reserved
+// bit  [13]    cntl_sim_en
+// bit  [12]    cntl_use_level
+// bit  [11]    Read only.      This bit will be set to 1 when there is data in the FIFO to process
+// bit  [10]    Read only.  This bit will be high when we're fetching data from the DDR memory
+//              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
+//              After that you can pulse cntl_init to start over
+// bit  [9]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
+//                              the FIFO to the rest of the IEC958 logic
+// bit  [8]     mode_raw:       Set this bit to 1 to tell the IEC958 FIFO to read
+//                              and process data linearly for raw data.  
+// bit  [7]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR.  Only valid when mode_raw = 0
+// bit  [6]     cntl_rd_ddr     Set this bit to read if you want AIU_MEM_IEC958_RD_PTR and
+//                              AIU_MEM_IEC958_RD_PTR_HIGH to refer to the pointer into DDR memory.
+//                              Otherwise, the curr_ptr registers refer to the byte address of the data
+//                              at the output of the FIFO to the rest of the IEC958 logic
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+#define AIU_MEM_IEC958_CONTROL                     ((0x1569  << 2) + 0xc1100000)
+// --------------------------------------------
+// AIFIFO2 DDR Interface
+// --------------------------------------------
+// The AIFIFO2 start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define AIU_MEM_AIFIFO2_START_PTR                  ((0x156a  << 2) + 0xc1100000)
+// The current pointer points so some location between the START and END 
+// pointers.  The current pointer is a BYTE pointer.  That is, you can 
+// point to any BYTE address within the START/END range
+#define AIU_MEM_AIFIFO2_CURR_PTR                   ((0x156b  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO2_END_PTR                    ((0x156c  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO2_BYTES_AVAIL                ((0x156d  << 2) + 0xc1100000)
+// AIFIFO2 FIFO Control
+// bit  [15:11] unused
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
+//                              the FIFO to getbit
+// bit  [6]     unused  
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define AIU_MEM_AIFIFO2_CONTROL                    ((0x156e  << 2) + 0xc1100000)
+// --------------------------------------------
+// AIFIFO2 Buffer Level Manager
+// --------------------------------------------
+#define AIU_MEM_AIFIFO2_MAN_WP                     ((0x156f  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO2_MAN_RP                     ((0x1570  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO2_LEVEL                      ((0x1571  << 2) + 0xc1100000)
+//
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define AIU_MEM_AIFIFO2_BUF_CNTL                   ((0x1572  << 2) + 0xc1100000)
+// --------------------------------------------
+// I2S Buffer Level Manager
+// --------------------------------------------
+#define AIU_MEM_I2S_MAN_WP                         ((0x1573  << 2) + 0xc1100000)
+#define AIU_MEM_I2S_MAN_RP                         ((0x1574  << 2) + 0xc1100000)
+#define AIU_MEM_I2S_LEVEL                          ((0x1575  << 2) + 0xc1100000)
+//
+// bit  [1]     mode            0 = parser (or audin_fifo0 or audin_fifo1), 
+//                              1 for manual write pointer 
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define AIU_MEM_I2S_BUF_CNTL                       ((0x1576  << 2) + 0xc1100000)
+#define AIU_MEM_I2S_BUF_WRAP_COUNT                 ((0x1577  << 2) + 0xc1100000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold 
+#define AIU_MEM_I2S_MEM_CTL                        ((0x1578  << 2) + 0xc1100000)
+//-----------------------------------------------------------------------------
+// Additional IEC958 registers (new feature)
+//-----------------------------------------------------------------------------
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold 
+#define AIU_MEM_IEC958_MEM_CTL                     ((0x1579  << 2) + 0xc1100000)
+#define AIU_MEM_IEC958_WRAP_COUNT                  ((0x157a  << 2) + 0xc1100000)
+#define AIU_MEM_IEC958_IRQ_LEVEL                   ((0x157b  << 2) + 0xc1100000)
+#define AIU_MEM_IEC958_MAN_WP                      ((0x157c  << 2) + 0xc1100000)
+#define AIU_MEM_IEC958_MAN_RP                      ((0x157d  << 2) + 0xc1100000)
+#define AIU_MEM_IEC958_LEVEL                       ((0x157e  << 2) + 0xc1100000)
+#define AIU_MEM_IEC958_BUF_CNTL                    ((0x157f  << 2) + 0xc1100000)
+//-----------------------------------------------------------------------------
+// add for AIFIFO channel (old $cdrom/rtl/cdr_top/getbit)
+//-----------------------------------------------------------------------------
+// Bit 3 	CRC pop aififo enable
+// Bit 2		writing to this bit to 1 causes CRC module reset
+// Bit 1		enable aififo
+// Bit 0		writing to this bit to 1 causes aififo soft reset
+#define AIU_AIFIFO_CTRL                            ((0x1580  << 2) + 0xc1100000)
+//'h0000
+// AIFIFO status register
+// Bit 13		//aififo request to dcu status
+// Bit 12		//dcu select status
+// Bit 11:5		//aififo word counter number 
+// Bit 4:0		//how many bits left in the first pop register
+#define AIU_AIFIFO_STATUS                          ((0x1581  << 2) + 0xc1100000)
+// Same fucntion as the AIGBIT of AIFIFO in CDROM module
+// write to this register how many bits wanna pop, 
+// and reading this register gets the corresponding bits data
+#define AIU_AIFIFO_GBIT                            ((0x1582  << 2) + 0xc1100000)
+// Same function as the AICLB of AIFIFO in CDROM module
+// return the leading zeros by reading this registers
+#define AIU_AIFIFO_CLB                             ((0x1583  << 2) + 0xc1100000)
+// --------------------------------------------
+// AIFIFO DDR Interface
+// --------------------------------------------
+// The AIFIFO start pointer into DDR memory is a 32-bit number
+// The Start pointer will automatically be truncated to land on 
+// an 8-byte boundary.  That is, bits [2:0] = 0;
+#define AIU_MEM_AIFIFO_START_PTR                   ((0x1584  << 2) + 0xc1100000)
+// The current pointer points so some location between the START and END 
+// pointers.  The current pointer is a BYTE pointer.  That is, you can 
+// point to any BYTE address within the START/END range
+#define AIU_MEM_AIFIFO_CURR_PTR                    ((0x1585  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO_END_PTR                     ((0x1586  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO_BYTES_AVAIL                 ((0x1587  << 2) + 0xc1100000)
+// AIFIFO FIFO Control
+// bit  [15:11] unused
+// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
+//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
+// bit  [9]     Data Ready.     This bit is set when data can be popped
+// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
+//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
+//                              After that you can pulse cntl_init to start over
+// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
+//                              the FIFO to getbit
+// bit  [6]     unused  
+// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
+// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
+//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
+// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
+// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
+//                              and read masks, set this bit to 1 and then to 0
+//                              NOTE:  You don't need to pulse cntl_init if only the start address is
+//                              being changed
+#define AIU_MEM_AIFIFO_CONTROL                     ((0x1588  << 2) + 0xc1100000)
+// --------------------------------------------
+// AIFIFO Buffer Level Manager
+// --------------------------------------------
+#define AIU_MEM_AIFIFO_MAN_WP                      ((0x1589  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO_MAN_RP                      ((0x158a  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO_LEVEL                       ((0x158b  << 2) + 0xc1100000)
+//
+// bit  [1]     manual mode     Set to 1 for manual write pointer mode
+// bit  [0]     Init            Set high then low after everything has been initialized
+#define AIU_MEM_AIFIFO_BUF_CNTL                    ((0x158c  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO_BUF_WRAP_COUNT              ((0x158d  << 2) + 0xc1100000)
+#define AIU_MEM_AIFIFO2_BUF_WRAP_COUNT             ((0x158e  << 2) + 0xc1100000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold 
+#define AIU_MEM_AIFIFO_MEM_CTL                     ((0x158f  << 2) + 0xc1100000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define AIFIFO_TIME_STAMP_CNTL                     ((0x1590  << 2) + 0xc1100000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define AIFIFO_TIME_STAMP_SYNC_0                   ((0x1591  << 2) + 0xc1100000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
+#define AIFIFO_TIME_STAMP_SYNC_1                   ((0x1592  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_0
+#define AIFIFO_TIME_STAMP_0                        ((0x1593  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_1
+#define AIFIFO_TIME_STAMP_1                        ((0x1594  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_2
+#define AIFIFO_TIME_STAMP_2                        ((0x1595  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_3
+#define AIFIFO_TIME_STAMP_3                        ((0x1596  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define AIFIFO_TIME_STAMP_LENGTH                   ((0x1597  << 2) + 0xc1100000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define AIFIFO2_TIME_STAMP_CNTL                    ((0x1598  << 2) + 0xc1100000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define AIFIFO2_TIME_STAMP_SYNC_0                  ((0x1599  << 2) + 0xc1100000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
+#define AIFIFO2_TIME_STAMP_SYNC_1                  ((0x159a  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_0
+#define AIFIFO2_TIME_STAMP_0                       ((0x159b  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_1
+#define AIFIFO2_TIME_STAMP_1                       ((0x159c  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_2
+#define AIFIFO2_TIME_STAMP_2                       ((0x159d  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_3
+#define AIFIFO2_TIME_STAMP_3                       ((0x159e  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define AIFIFO2_TIME_STAMP_LENGTH                  ((0x159f  << 2) + 0xc1100000)
+// bit 31:16 -- drop_bytes
+// bit 15:14 -- drop_status (Read-Only)
+// bit 13:12 -- sync_match_position (Read-Only)
+// bit 11:6 -- reserved
+// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
+// bit 3 -- stamp_soft_reset
+// bit 2 -- TIME_STAMP_length_enable
+// bit 1 -- TIME_STAMP_sync64_enable
+// bit 0 -- TIME_STAMP_enable
+#define IEC958_TIME_STAMP_CNTL                     ((0x15a0  << 2) + 0xc1100000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
+#define IEC958_TIME_STAMP_SYNC_0                   ((0x15a1  << 2) + 0xc1100000)
+// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
+#define IEC958_TIME_STAMP_SYNC_1                   ((0x15a2  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_0
+#define IEC958_TIME_STAMP_0                        ((0x15a3  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_1
+#define IEC958_TIME_STAMP_1                        ((0x15a4  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_2
+#define IEC958_TIME_STAMP_2                        ((0x15a5  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_3
+#define IEC958_TIME_STAMP_3                        ((0x15a6  << 2) + 0xc1100000)
+// bit 31:0 TIME_STAMP_LENGTH
+#define IEC958_TIME_STAMP_LENGTH                   ((0x15a7  << 2) + 0xc1100000)
+// bit 29:24 A_brst_num
+// bit 21:16 A_id
+// bit 15:0 level_hold 
+#define AIU_MEM_AIFIFO2_MEM_CTL                    ((0x15a8  << 2) + 0xc1100000)
+// --------------------------------------------
+// CBUS_DDR interface for I2S_FAST
+// --------------------------------------------
+// bit[31:26] unused
+// bit[25]      A_req       level
+// bit[24]      data_req    If this bit is 1, then (a_req_cnt != 'h0)
+// bit[23:16]   a_req_cnt   This value corresponds to the number of 32-bit words 
+//                          requested by the i2s_fast() module
+// bit[15:7]    unused
+// bit[6]                   Set this bit to mux in the cbus_ddr_interface
+// bit[5]                   Set this bit to allow back to back A_req's to be serviced
+// bit[4]                   Set this bit to generate an IRQ on the first A_req
+//                          If this bit is 0, then an IRQ is generated after all requests 
+//                          are completed and how many 32-bit words to send is calculated.
+// bit[3:1]                 Endian
+// bit[0]                   Set this bit enable the cbus_ddr_interface
+#define AIU_I2S_CBUS_DDR_CNTL                      ((0x15a9  << 2) + 0xc1100000)
+// 32-bit data to write to the cbus_ddr interface
+#define AIU_I2S_CBUS_DDR_WDATA                     ((0x15aa  << 2) + 0xc1100000)
+// First address associated with the first request by the i2s_fast() to read DDR data
+#define AIU_I2S_CBUS_DDR_ADDR                      ((0x15ab  << 2) + 0xc1100000)
+//
+// Closing file:  aregs.h
+//
+//========================================================================
+//  CDROM Interface                                 (12'h600 - 12'h6ff)
+//
+//========================================================================
+//========================================================================
+//	registers for ge2d (12'h8a0 - 12'h8ff)
+//========================================================================
+//
+// Reading file:  ge2d_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//===========================================================================
+// GE2D Registers    0x8a0 - 0x8ff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  GE2D_CBUS_BASE = 0x18
+// -----------------------------------------------
+//Bit 31, destination bytemask only if destination bitmask is enable
+//Bit 30, destination bitmask enable
+//Bit 29, source2 key  enable
+//Bit 28, source2 key  mode, 0: mask data when match, 1: mask data when unmatch
+//Bit 27, source1 key  enable
+//Bit 26, source1 key  mode, 0: mask data when match, 1: mask data when unmatch
+//Bit 25:24, dst1 8bit mode component selection, 
+//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
+//Bit 23  dst clip mode, 0: write inside clip window, 1: write outside clip window
+//Bit 22:17,  reserved
+//Bit 16:15, src2 8bit mode component selection, 
+//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
+//Bit 14     src2 fill mode, 0: repeat data, 1: fill default color
+//Bit 13:12  src2 picture struct, 00: frame, 10: even, 11: odd
+//Bit 11     src1 x direction yc ration, 0: 1:1, 1: 2:1
+//Bit 10     src1 y direction yc ration, 0: 1:1, 1: 2:1
+//Bit 9:7    reserved
+//Bit 6:5,   src1  8bit mode component selection, 
+//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
+//Bit 4      src1 fill mode, 0: repeat data, 1: fill default color
+//Bit 3      src1 lookup table enable
+//Bit 2:1    src1 picture struct, 00: frame, 10: even, 11: odd
+//Bit 0      src1 separate buffer enable
+#define GE2D_GEN_CTRL0                             ((0x18a0  << 2) + 0xc1100000)
+//Bit 31, soft rst
+//Bit 30, dst write response counter reset  
+//Bit 29, disable adding dst write response count to busy bit 
+//Bit 28:26, reserved
+//bit 25:24, interrupt control, if bit[0] true, generate interrupt when one command done,
+//                              if bit[1] true, generate interrupt when ge2d change from busy to not busy
+//Bit 23:22 src2 burst size control
+//Bit 21:16 src1 burst size control, 5:4, yfifo, 3:2, cbfifo, 1:0, crfifo
+//          each 2bit, 00: 24 64bitword, 01: 32 64bitword, 10: 48 64bitwords, 11: 64 64bitwords  
+//Bit 15:14, dst1 picture struct, 00: frame, 10:top, 11: bottom
+//Bit 13:12, bit 13 if true, force read src1, bit 12 if true, force read src2
+//Bit 11, dst2 request urgent enable
+//Bit 10, src1 request urgent enable
+//Bit 9,  src2 request urgent enable
+//Bit 8,  dst1 request urgent enable
+//Bit 7:0 src1 global alpha
+#define GE2D_GEN_CTRL1                             ((0x18a1  << 2) + 0xc1100000)
+//Bit31      alpha conversion mode in alu, 0: alpha_out = (alpha !=0) ? alpha +1 : 0; 
+//                 otherwise, alpha_out = (alpha < 128) ? alpha: alpha + 1;
+//Bit30      color conversion mode in alu, 0: color_out = (color != 0) ? color +1: 0;
+//                 otherwise, color_out = (color < 128) ? color: color + 1;
+//Bit29      src1_gb_alpha_en, As = src1_gb_alpha_en ? Asr * Ag: Asr
+//Bit28      dst1_color_round_mode, 0: truncate, 1: + 0.5 rounding
+//Bit27      src2_color_expand_mode, 0: add 0, 1: add MSBs 
+//Bit26      src2_alpha_expand_mode, 0: add 0, 1: add MSBs 
+//Bit25      src1_color_expand_mode, 0: add 0, 1: add MSBs 
+//Bit24      src1_alpha_expand_mode, 0: add 0, 1: add MSBs 
+//Bit 23     if true, dst little endian, otherwise big endian
+//Bit 22:19 dst1 color_map
+//        dst1_format=0                  : output 8-bit;
+//        dst1_format=1, dst1_color_map=1: output 16-bit YCbCr  655;
+//        dst1_format=1, dst1_color_map=2: output 16-bit YCbCr  844;
+//        dst1_format=1, dst1_color_map=3: output 16-bit YCbCrA 6442;
+//        dst1_format=1, dst1_color_map=4: output 16-bit YCbCrA 4444;
+//        dst1_format=1, dst1_color_map=5: output 16-bit YCbCr  565;
+//        dst1_format=1, dst1_color_map=6: output 16-bit AYCbCr 4444;
+//        dst1_format=1, dst1_color_map=7: output 16-bit AYCbCr 1555;
+//        dst1_format=1, dst1_color_map=8: output 16-bit YCbCrA 4642;
+//        dst1_format=1, dst1_color_map=9: output 16-bit CbCr   88;
+//        dst1_format=1, dst1_color_map=10:output 16-bit CrCb   88;
+//        dst1_format=2, dst1_color_map=0: output 24-bit YCbCr  888;
+//        dst1_format=2, dst1_color_map=1: output 24-bit YCbCrA 5658;
+//        dst1_format=2, dst1_color_map=2: output 24-bit AYCbCr 8565;
+//        dst1_format=2, dst1_color_map=3: output 24-bit YCbCrA 6666;
+//        dst1_format=2, dst1_color_map=4: output 24-bit AYCbCr 6666;
+//        dst1_format=2, dst1_color_map=5: output 24-bit CrCbY  888;
+//        dst1_format=3, dst1_color_map=0: output 32-bit YCbCrA 8888;
+//        dst1_format=3, dst1_color_map=1: output 32-bit AYCbCr 8888;
+//        dst1_format=3, dst1_color_map=2: output 32-bit ACrCbY 8888;
+//        dst1_format=3, dst1_color_map=3: output 32-bit CrCbYA 8888.
+//Bit 17:16 dst1_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
+//Bit 15    if true, src2 little endian, otherwise big endian
+//Bit 14:11  src2 color_map
+//        src2_format=0                 : output 8-bit;
+//        src2_format=1, src2_color_map=1: output 16-bit YCbCr  655;
+//        src2_format=1, src2_color_map=2: output 16-bit YCbCr  844;
+//        src2_format=1, src2_color_map=3: output 16-bit YCbCrA 6442;
+//        src2_format=1, src2_color_map=4: output 16-bit YCbCrA 4444;
+//        src2_format=1, src2_color_map=5: output 16-bit YCbCr  565;
+//        src2_format=1, src2_color_map=6: output 16-bit AYCbCr 4444;
+//        src2_format=1, src2_color_map=7: output 16-bit AYCbCr 1555;
+//        src2_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
+//        src2_format=2, src2_color_map=0: output 24-bit YCbCr  888;
+//        src2_format=2, src2_color_map=1: output 24-bit YCbCrA 5658;
+//        src2_format=2, src2_color_map=2: output 24-bit AYCbCr 8565;
+//        src2_format=2, src2_color_map=3: output 24-bit YCbCrA 6666;
+//        src2_format=2, src2_color_map=4: output 24-bit AYCbCr 6666;
+//        src2_format=2, src2_color_map=5: output 24-bit CrCbY  888;
+//        src2_format=3, src2_color_map=0: output 32-bit YCbCrA 8888;
+//        src2_format=3, src2_color_map=1: output 32-bit AYCbCr 8888;
+//        src2_format=3, src2_color_map=2: output 32-bit ACrCbY 8888;
+//        src2_format=3, src2_color_map=3: output 32-bit CrCbYA 8888.
+//Bit 9:8 src2 format, 00: 8bit, 01:16bit, 10:24bit 11: 32bit
+//Bit 7     if true, src1 little endian, otherwise big endian
+//Bit 6:3   src1 color_map
+//        src1_format=0                 : output 8-bit;
+//        src1_format=1, src1_color_map=0: output 4:2:2  (Y0Cb0Y1Cr0);
+//        src1_format=1, src1_color_map=1: output 16-bit YCbCr  655;
+//        src1_format=1, src1_color_map=2: output 16-bit YCbCr  844;
+//        src1_format=1, src1_color_map=3: output 16-bit YCbCrA 6442;
+//        src1_format=1, src1_color_map=4: output 16-bit YCbCrA 4444;
+//        src1_format=1, src1_color_map=5: output 16-bit YCbCr  565;
+//        src1_format=1, src1_color_map=6: output 16-bit AYCbCr 4444;
+//        src1_format=1, src1_color_map=7: output 16-bit AYCbCr 1555;
+//        src1_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
+//        src1_format=2, src1_color_map=0: output 24-bit YCbCr  888;
+//        src1_format=2, src1_color_map=1: output 24-bit YCbCrA 5658;
+//        src1_format=2, src1_color_map=2: output 24-bit AYCbCr 8565;
+//        src1_format=2, src1_color_map=3: output 24-bit YCbCrA 6666;
+//        src1_format=2, src1_color_map=4: output 24-bit AYCbCr 6666;
+//        src1_format=2, src1_color_map=5: output 24-bit CrCbY  888;
+//        src1_format=2, src1_color_map=14:output 8-bit Y and 16-bit CbCr;
+//        src1_format=2, src1_color_map=15:output 8-bit Y and 16-bit CrCb;
+//        src1_format=3, src1_color_map=0: output 32-bit YCbCrA 8888;
+//        src1_format=3, src1_color_map=1: output 32-bit AYCbCr 8888;
+//        src1_format=3, src1_color_map=2: output 32-bit ACrCbY 8888;
+//        src1_format=3, src1_color_map=3: output 32-bit CrCbYA 8888.     
+//Bit 1:0 src1 format, 00: 8bit, 01:16bit/4:2:2, 10:24bit 11: 32bit 
+#define GE2D_GEN_CTRL2                             ((0x18a2  << 2) + 0xc1100000)
+//Bit 9     if true, all src2 data use default color
+//Bit 8     if true, all src1 data use default color
+//Bit 7     if true, dst x/y swap 
+//Bit 6     if true, dst x direction reversely read
+//Bit 5     if true, dst y direction reversely read
+//Bit 4     if true, src2 x direction reversely read
+//Bit 3     if true, src2 y direction reversely read
+//Bit 2     if true, src1 x direction reversely read
+//Bit 1     if true, src1 y direction reversely read
+//Bit 0     cmd write
+#define GE2D_CMD_CTRL                              ((0x18a3  << 2) + 0xc1100000)
+//Read only
+//Bit 28:17 dst write response counter, for debug only
+//Bit 16:7  ge2d_dp status, for debug only
+//Bit 6     read src1 cmd ready
+//Bit 5     read src2 cmd ready
+//Bit 4     pre dpcmd ready
+//Bit 3     ge2d dpcmd ready
+//Bit 2     ge2d buffer command valid
+//Bit 1     ge2d current command valid
+//Bit 0     ge2d busy
+#define GE2D_STATUS0                               ((0x18a4  << 2) + 0xc1100000)
+//
+//Read only
+// Bit 29:16 ge2d_dst1_status, for debug only
+// Bit    15 ge2d_rd_src2 core.fifo_empty
+// Bit    14 ge2d_rd_src2 core.fifo_overflow
+// Bit 13:12 ge2d_rd_src2 core.req_st
+// Bit    11 ge2d_rd_src2 cmd_if.cmd_err, true if cmd_format=1
+// Bit    10 ge2d_rd_src2 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
+// Bit     9 ge2d_rd_src1 luma_core(chroma_core).fifo_empty
+// Bit     8 ge2d_rd_src1 luma_core(chroma_core).fifo_overflow
+// Bit  7: 6 ge2d_rd_src1 chroma_core.req_st_cr
+// Bit  5: 4 ge2d_rd_src1 chroma_core.req_st_cb
+// Bit  3: 2 ge2d_rd_src1 luma_core.req_st_y
+// Bit     1 ge2d_rd_src1 cmd_if.stat_read_window_err, 1=reading/clipping window setting exceed limit
+// Bit     0 ge2d_rd_src1 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
+#define GE2D_STATUS1                               ((0x18a5  << 2) + 0xc1100000)
+//SRC1 default clolor
+//{Y,Cb,Cr,A}/{R,G,B,A}
+#define GE2D_SRC1_DEF_COLOR                        ((0x18a6  << 2) + 0xc1100000)
+//Bit 31, SRC1 clip x start extra, if true, one more data is read for chroma
+//Bit 28:16, SRC1 clip x start
+//Bit 15, SRC1 clip x end extra, if true, one more data is read for chroma
+//Bit 12:0, SRC1 clip x end
+#define GE2D_SRC1_CLIPX_START_END                  ((0x18a7  << 2) + 0xc1100000)
+//Bit 31, SRC1 clip y start extra, if true, one more data is read for chroma
+//Bit 28:16, SRC1 clip y start
+//Bit 15, SRC1 clip y end extra, if true, one more data is read for chroma
+//Bit 12:0, SRC1 clip y end
+#define GE2D_SRC1_CLIPY_START_END                  ((0x18a8  << 2) + 0xc1100000)
+//Bit 31:24, SRC1 canvas address0
+//Bit 23:16, SRC1 canvas address1
+//Bit 15:8, SRC1 canvas address2
+#define GE2D_SRC1_CANVAS                           ((0x18a9  << 2) + 0xc1100000)
+//Bit 31, SRC1 x start extra bit1, if true, one more chroma data is read for x even start chroma data when y/c ratio = 2
+//             or x even/odd start chroma extra data when y/c ratio = 1
+//Bit 30, SRC1 x start extra bit0, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
+//Bit 29:16, SRC1 x start, signed data
+//Bit 15, SRC1 x end extra bit1, if true, one more chroma data is read for x odd end chroma data when y/c ratio = 2
+//             or x even/odd end chroma extra data when y/c ratio = 1
+//Bit 14, SRC1 x end extra bit0, if true, one more chroma data is read for x even end chroma data when y/c ratio = 2
+//Bit 13:0, SRC1 x end, signed data
+#define GE2D_SRC1_X_START_END                      ((0x18aa  << 2) + 0xc1100000)
+//Bit 31, SRC1 y start extra, if true, one more chroma data is read for y even start chroma data when y/c ratio = 2
+//             or y even/odd start chroma extra data when y/c ratio = 1
+//Bit 30, SRC1 y start extra, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
+//Bit 28:16, SRC1 y start
+//Bit 15, SRC1 y end extra bit1, if true, one more chroma data is read for y odd end chroma data when y/c ratio = 2
+//             or y even/odd end chroma extra data when y/c ratio = 1
+//Bit 14, SRC1 y end extra bit0, if true, one more chroma data is read for y even end chroma data when y/c ratio = 2
+//Bit 12:0, SRC1 y end
+#define GE2D_SRC1_Y_START_END                      ((0x18ab  << 2) + 0xc1100000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define GE2D_SRC1_LUT_ADDR                         ((0x18ac  << 2) + 0xc1100000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define GE2D_SRC1_LUT_DAT                          ((0x18ad  << 2) + 0xc1100000)
+//Bit 19, if true, horizontal formatter using repeat to get the pixel, otherwise using interpolation
+//Bit 18, horizontal formatter en
+//Bit 17, if true, vertical formatter using repeat to get the pixel, otherwise using interpolation
+//Bit 16, vertical formatter en
+//Bit 15:8 X direction chroma phase,  
+//          [7:4] for x direction even start/end chroma phase when y/c ratio = 2
+//                or start/end even/odd chroma phase  when y/c ratio = 1 
+//          [3:0] for x direction odd start/end chroma phase only when y/c ration = 2
+//Bit 7:0  Y direction chroma phase, 
+//          [7:4] for y direction even start/end chroma phase when y/c ratio = 2
+//          or start/end even/odd chroma phase  when y/c ratio = 1 
+//          [3:0] for y direction odd start/end chroma phase only when y/c ration = 2 
+#define GE2D_SRC1_FMT_CTRL                         ((0x18ae  << 2) + 0xc1100000)
+//SRC2 default clolor
+//{Y,Cb,Cr,A}/{R,G,B,A}
+#define GE2D_SRC2_DEF_COLOR                        ((0x18af  << 2) + 0xc1100000)
+//Bit 28:16, SRC2 clip x start
+//Bit 12:0, SRC2 clip x end
+#define GE2D_SRC2_CLIPX_START_END                  ((0x18b0  << 2) + 0xc1100000)
+//Bit 28:16, SRC2 clip y start
+//Bit 12:0, SRC2 clip y end
+#define GE2D_SRC2_CLIPY_START_END                  ((0x18b1  << 2) + 0xc1100000)
+//Bit 28:16, SRC2 x start
+//Bit 12:0, SRC2 x end
+#define GE2D_SRC2_X_START_END                      ((0x18b2  << 2) + 0xc1100000)
+//Bit 28:16, SRC2 y start
+//Bit 12:0, SRC2 y end
+#define GE2D_SRC2_Y_START_END                      ((0x18b3  << 2) + 0xc1100000)
+//Bit 28:16, DST clip x start
+//Bit 12:0, DST clip x end
+#define GE2D_DST_CLIPX_START_END                   ((0x18b4  << 2) + 0xc1100000)
+//
+//Bit 28:16, DST clip y start
+//Bit 12:0, DST clip y end
+#define GE2D_DST_CLIPY_START_END                   ((0x18b5  << 2) + 0xc1100000)
+//Bit 28:16, DST x start
+//Bit 12:0, DST x end
+#define GE2D_DST_X_START_END                       ((0x18b6  << 2) + 0xc1100000)
+//
+//Bit 28:16, DST x start
+//Bit 12:0, DST x end
+#define GE2D_DST_Y_START_END                       ((0x18b7  << 2) + 0xc1100000)
+//Bit 23:16 DST2 canvas address
+//Bit 15:8 SRC2 canvas address
+//Bit 7:0 DST1 canvas address
+#define GE2D_SRC2_DST_CANVAS                       ((0x18b8  << 2) + 0xc1100000)
+//vertical scaler phase step
+//Bit 28:0,  5.24 format
+#define GE2D_VSC_START_PHASE_STEP                  ((0x18b9  << 2) + 0xc1100000)
+//phase slope 
+//Bit 24:0, bit 24 signed bit
+#define GE2D_VSC_PHASE_SLOPE                       ((0x18ba  << 2) + 0xc1100000)
+//Bit 30:29, vertical repeat line0 number 
+//Bit 23:0, vertical scaler initial phase
+#define GE2D_VSC_INI_CTRL                          ((0x18bb  << 2) + 0xc1100000)
+//horizontal scaler phase step
+//Bit 28:0,  5.24 format
+#define GE2D_HSC_START_PHASE_STEP                  ((0x18bc  << 2) + 0xc1100000)
+//phase slope 
+//Bit 24:0, bit 24 signed bit
+#define GE2D_HSC_PHASE_SLOPE                       ((0x18bd  << 2) + 0xc1100000)
+//Bit 30:29, horizontal repeat line0 number 
+//Bit 23:0, horizontal scaler initial phase
+#define GE2D_HSC_INI_CTRL                          ((0x18be  << 2) + 0xc1100000)
+//Bit 31:24, advance number in this round, if horizontal scaler is working on dividing mode
+//Bit 23:0, horizontal scaler advance phase in this round, if horizontal scaler is working on dividing mode 
+#define GE2D_HSC_ADV_CTRL                          ((0x18bf  << 2) + 0xc1100000)
+//Bit 30, vertical nearest mode enable, must set vt_bank_length = 4
+//Bit 29, horizontal nearest mode enable, must set hz_bank_length = 4 
+//Bit 28, horizontal scaler dividing mode enable
+//Bit 27:15, horizontal dividing length, if bit 28 is enable
+//Bit 14, pre horizontal scaler enable 
+//Bit 13, pre vertical scale enable
+//Bit 12, vertical scale enable
+//Bit 11, horizontal scaler enable
+//Bit 9, if true, treat horizontal repeat line number(GE2D_HSC_INI_CTRL bit 30:29) as repeating line, 
+//        otherwise using treat horizontal repeat line number as minus line number. 
+//Bit 8, if true, treat vertical repeat line number(GE2D_VSC_INI_CTRL bit 30:29) as repeating line, 
+//        otherwise using treat vertical repeat line number as minus line number. 
+//Bit 7, if true, always use phase0 in vertical scaler
+//Bit 6:4, vertical scaler bank length
+//Bit 3, if true, always use phase0 in horizontal scaler
+//Bit 2:0, horizontal scaler bank length
+#define GE2D_SC_MISC_CTRL                          ((0x18c0  << 2) + 0xc1100000)
+//Read only
+//vertical scaler next round integer pixel pointer, signed data
+//Bit 13:0
+#define GE2D_VSC_NRND_POINT                        ((0x18c1  << 2) + 0xc1100000)
+//Read only
+//vertical scaler next round phase
+//bit 23:0
+#define GE2D_VSC_NRND_PHASE                        ((0x18c2  << 2) + 0xc1100000)
+//Read only
+//horizontal scaler next round integer pixel pointer, signed data
+//Bit 13:0
+#define GE2D_HSC_NRND_POINT                        ((0x18c3  << 2) + 0xc1100000)
+//Read only
+//horizontal scaler next round phase
+//bit 23:0
+#define GE2D_HSC_NRND_PHASE                        ((0x18c4  << 2) + 0xc1100000)
+//
+//Bit 28:20, pre_offset0
+//Bit 18:10, pre_offset1 
+//Bit 8:0,   pre_offset2
+#define GE2D_MATRIX_PRE_OFFSET                     ((0x18c5  << 2) + 0xc1100000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define GE2D_MATRIX_COEF00_01                      ((0x18c6  << 2) + 0xc1100000)
+//Bit 28:16 coef02
+//Bit 12:0  coef10
+#define GE2D_MATRIX_COEF02_10                      ((0x18c7  << 2) + 0xc1100000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define GE2D_MATRIX_COEF11_12                      ((0x18c8  << 2) + 0xc1100000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define GE2D_MATRIX_COEF20_21                      ((0x18c9  << 2) + 0xc1100000)
+//Bit 28:16 coef22
+//Bit 7    input y/cb/cr saturation enable
+//Bit 0    conversion matrix enable
+#define GE2D_MATRIX_COEF22_CTRL                    ((0x18ca  << 2) + 0xc1100000)
+//Bit 28:20, offset0
+//Bit 18:10, offset1 
+//Bit 8:0,   offset2
+#define GE2D_MATRIX_OFFSET                         ((0x18cb  << 2) + 0xc1100000)
+//Bit 26:25, SRC1 color multiplier alpha selection
+//           if 00, Cs = Csr
+//           if 01, Cs = Csr * Asr * Ag (if source is not premultiplied)
+//           if 10, Cs = Csr * Ag (if source is premultipied)
+//Bit 24    SRC2 color multiplier alpha selection 
+//          if 0, no multiplier, Cd = Cdr,  otherwise, Cd = Cdr * Ad.   
+//Bit 22:12 ALU color operation
+//          bit10:8 Blending Mode Parameter
+//            3'b000: ADD               Cs*Fs + Cd*Fd
+//            3'b001: SUBTRACT          Cs*Fs - Cd*Fd
+//            3'b010: REVERSE SUBTRACT  Cd*Fd - Cs*Fs
+//            3'b011: MIN               min(Cs*Fs, Cd*Fd)
+//            3'b100: MAX               max(Cs*Fs, Cd*Fd)
+//            3'b101: LOGIC OP          Cs op Cd
+//          bit7:4 Source Color Blending Factor CFs
+//            4'b0000: ZERO                        0
+//            4'b0001: ONE                         1
+//            4'b0010: SRC_COLOR                   Cs(RGBs)
+//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
+//            4'b0100: DST_COLOR                   Cd(RGBd)
+//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
+//            4'b0110: SRC_ALPHA                   As
+//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
+//            4'b1000: DST_ALPHA                   Ad
+//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
+//            4'b1010: CONST_COLOR                 Cc(RGBc)
+//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
+//            4'b1100: CONST_ALPHA                 Ac
+//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
+//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
+//          bit3:0 dest Color Blending Factor CFd, when bit10:8 != LOGIC OP
+//            4'b0000: ZERO                        0
+//            4'b0001: ONE                         1
+//            4'b0010: SRC_COLOR                   Cs(RGBs)
+//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
+//            4'b0100: DST_COLOR                   Cd(RGBd)
+//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
+//            4'b0110: SRC_ALPHA                   As
+//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
+//            4'b1000: DST_ALPHA                   Ad
+//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
+//            4'b1010: CONST_COLOR                 Cc(RGBc)
+//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
+//            4'b1100: CONST_ALPHA                 Ac
+//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
+//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
+//          bit3:0 logic operations, when bit10:8 == LOGIC OP
+//            4'b0000: CLEAR                       0
+//            4'b0001: COPY                        s
+//            4'b0010: NOOP                        d
+//            4'b0011: SET                         1
+//            4'b0100: COPY_INVERT                 ~s
+//            4'b0101: INVERT                      ~d
+//            4'b0110: AND_REVERSE                 s & ~d
+//            4'b0111: OR_REVERSE                  s | ~d
+//            4'b1000: AND                         s & d
+//            4'b1001: OR                          s | d
+//            4'b1010: NAND                        ~(s & d)
+//            4'b1011: NOR                         ~(s | d)
+//            4'b1100: XOR                         s ^ d
+//            4'b1101: EQUIV                       ~(s ^ d)
+//            4'b1110: AND_INVERTED                ~s & d
+//            4'b1111: OR_INVERTED                 ~s | d
+//Bit 10:0  ALU alpha operation
+//            bit10:8 Blending Equation Math Operation
+//              3'b000: ADD               As*Fs + Ad*Fd
+//              3'b001: SUBTRACT          As*Fs - Ad*Fd
+//              3'b010: REVERSE SUBTRACT  Ad*Fd - As*Fs
+//              3'b011: MIN               min(As*Fs, Ad*Fd)
+//              3'b100: MAX               max(As*Fs, Ad*Fd)
+//              3'b101: LOGIC OP          As op Ad
+//            bit7:4 Source alpha Blending Factor AFs
+//              4'b0000                       0
+//              4'b0001                       1
+//              4'b0010                       As
+//              4'b0011                       1 - As
+//              4'b0100                       Ad
+//              4'b0101                       1 - Ad
+//              4'b0110                       Ac
+//              4'b0111                       1 - Ac
+//               ....                         reserved
+//            bit3:0 Destination alpha Blending Factor AFd, when bit10:8 != LOGIC OP
+//              4'b0000                       0
+//              4'b0001                       1
+//              4'b0010                       As
+//              4'b0011                       1 - As
+//              4'b0100                       Ad
+//              4'b0101                       1 - Ad
+//              4'b0110                       Ac
+//              4'b0111                       1 - Ac
+//               ....                         reserved
+//            bit3:0 logic operations, when bit10:8 == LOGIC OP
+//              4'b0000: CLEAR                       0
+//              4'b0001: COPY                        s
+//              4'b0010: NOOP                        d
+//              4'b0011: SET                         1
+//              4'b0100: COPY_INVERT                 ~s
+//              4'b0101: INVERT                      ~d
+//              4'b0110: AND_REVERSE                 s & ~d
+//              4'b0111: OR_REVERSE                  s | ~d
+//              4'b1000: AND                         s & d
+//              4'b1001: OR                          s | d
+//              4'b1010: NAND                        ~(s & d)
+//              4'b1011: NOR                         ~(s | d)
+//              4'b1100: XOR                         s ^ d
+//              4'b1101: EQUIV                       ~(s ^ d)
+//              4'b1110: AND_INVERTED                ~s & d
+//              4'b1111: OR_INVERTED                 ~s | d
+#define GE2D_ALU_OP_CTRL                           ((0x18cc  << 2) + 0xc1100000)
+//bit 31:0 (RGBA,YCBCRA)
+#define GE2D_ALU_CONST_COLOR                       ((0x18cd  << 2) + 0xc1100000)
+//SRC1 Key
+//31:0 
+#define GE2D_SRC1_KEY                              ((0x18ce  << 2) + 0xc1100000)
+//SRC1 Key Mask
+//31:0 
+#define GE2D_SRC1_KEY_MASK                         ((0x18cf  << 2) + 0xc1100000)
+//SRC2 Key
+//31:0 
+#define GE2D_SRC2_KEY                              ((0x18d0  << 2) + 0xc1100000)
+//SRC2 Key Mask
+//31:0 
+#define GE2D_SRC2_KEY_MASK                         ((0x18d1  << 2) + 0xc1100000)
+//Destination Bit Mask
+//31:0 
+#define GE2D_DST_BITMASK                           ((0x18d2  << 2) + 0xc1100000)
+//Bit 31    DP onoff mode, 0: on_counter means how many pixels will output before ge2d turns off
+//                         1: on_counter means how many clocks will ge2d turn on before ge2d turns off
+//Bit 30:16     DP on counter
+//Bit 15        0: vd_format doesnt have onoff mode, 1: vd format has onoff mode
+//Bit 14:0      DP off counter
+#define GE2D_DP_ONOFF_CTRL                         ((0x18d3  << 2) + 0xc1100000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients 
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
+//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8	    type of index, 0: vertical coef
+//						   1: horizontal coef
+//Bit 6:0 	coef index
+#define GE2D_SCALE_COEF_IDX                        ((0x18d4  << 2) + 0xc1100000)
+//coefficients for vertical filter and horizontal filter
+#define GE2D_SCALE_COEF                            ((0x18d5  << 2) + 0xc1100000)
+//Bit 24    src2 alpha fill mode: together with GE2D_GEN_CTRL0[4](fill_mode), define what alpha values are used
+//                                for the area outside the clipping window. As below:
+//                                fill_mode=0, alpha_fill_mode=0 : use inner alpha, (or default_alpha if src data have no alpha values);
+//                                fill_mode=0, alpha_fill_mode=1 : use outside_alpha;
+//                                fill_mode=1, alpha_fill_mode=0 : use default_alpha;
+//                                fill_mode=1, alpha_fill_mode=1 : use outside_alpha.
+//Bit 23:16 src2 outside alpha
+//Bit 8     src1 alpha fill mode, refer to src2 alpha fill mode above. 
+//Bit 7:0   src1 outside alpha
+#define GE2D_SRC_OUTSIDE_ALPHA                     ((0x18d6  << 2) + 0xc1100000)
+//Bit 31       antiflick enable
+//Bit 24       1: alpha value for the first line use repeated alpha, 0: use bit 23:16 as the first line alpha 
+//Bit 23:16     register value for the first line alpha when bit 24 is 1 
+//Bit 8        1: alpha value for the last line use repeated alpha, 0: use bit 7:0 as the last line alpha 
+//Bit 7:0      register value for the last line alpha when bit 8 is 1 
+#define GE2D_ANTIFLICK_CTRL0                       ((0x18d8  << 2) + 0xc1100000)
+//Bit 25,    rgb_sel, 1: antiflick RGBA, 0: antiflick YCbCrA 
+//Bit 24,    cbcr_en, 1: also filter cbcr in case of antiflicking YCbCrA, 0: no filter on cbcr in case of antiflicking YCbCrA
+//Bit 23:16, R mult coef for converting RGB to Y
+//Bit 15:8,  G mult coef for converting RGB to Y
+//Bit 7:0,   B mult coef for converting RGB to Y
+//Y = (R * y_r + G * y_g + B * y_b) / 256
+#define GE2D_ANTIFLICK_CTRL1                       ((0x18d9  << 2) + 0xc1100000)
+//Bit 31:24, Y threhold1, when   0<Y<=th1, use filter0;
+//Bit 23:16, color antiflick filter0 n3
+//Bit 15:8,  color antiflick filter0 n2
+//Bit 7:0,   color antiflick filter0 n1
+//Y = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
+#define GE2D_ANTIFLICK_COLOR_FILT0                 ((0x18da  << 2) + 0xc1100000)
+//Bit 31:24, Y threhold2, when th1<Y<=th2, use filter1;
+//Bit 23:16, color antiflick filter1 n3
+//Bit 15:8,  color antiflick filter1 n2
+//Bit 7:0,   color antiflick filter1 n1
+#define GE2D_ANTIFLICK_COLOR_FILT1                 ((0x18db  << 2) + 0xc1100000)
+//Bit 31:24, Y threhold3, when th2<Y<=th3, use filter2; Y>th3, use filter3
+//Bit 23:16, color antiflick filter2 n3
+//Bit 15:8,  color antiflick filter2 n2
+//Bit 7:0,   color antiflick filter2 n1
+#define GE2D_ANTIFLICK_COLOR_FILT2                 ((0x18dc  << 2) + 0xc1100000)
+//Bit 23:16, color antiflick filter3 n3
+//Bit 15:8,  color antiflick filter3 n2
+//Bit 7:0,   color antiflick filter3 n1
+#define GE2D_ANTIFLICK_COLOR_FILT3                 ((0x18dd  << 2) + 0xc1100000)
+//Bit 31:24, Alpha threhold1, when   0<Alpha<=th1, use filter0;
+//Bit 23:16, Alpha antiflick filter0 n3
+//Bit 15:8,  Alpha antiflick filter0 n2
+//Bit 7:0,   Alpha antiflick filter0 n1
+//Alpha = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
+#define GE2D_ANTIFLICK_ALPHA_FILT0                 ((0x18de  << 2) + 0xc1100000)
+//Bit 31:24, Alpha threhold2, when th1<Alpha<=th2, use filter1;
+//Bit 23:16, Alpha antiflick filter1 n3
+//Bit 15:8,  Alpha antiflick filter1 n2
+//Bit 7:0,   Alpha antiflick filter1 n1
+#define GE2D_ANTIFLICK_ALPHA_FILT1                 ((0x18df  << 2) + 0xc1100000)
+//Bit 31:24, Alpha threhold3, when th2<Alpha<=th3, use filter2; Alpha>th3, use filter3
+//Bit 23:16, Alpha antiflick filter2 n3
+//Bit 15:8,  Alpha antiflick filter2 n2
+//Bit 7:0,   Alpha antiflick filter2 n1
+#define GE2D_ANTIFLICK_ALPHA_FILT2                 ((0x18e0  << 2) + 0xc1100000)
+//Bit 23:16, Alpha antiflick filter3 n3
+//Bit 15:8,  Alpha antiflick filter3 n2
+//Bit 7:0,   Alpha antiflick filter3 n1
+#define GE2D_ANTIFLICK_ALPHA_FILT3                 ((0x18e1  << 2) + 0xc1100000)
+//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
+//Bit 30:22 din_offset (signed data)
+//Bit 21:14 map_coef (unsigned data)
+//Bit 13:10 map_sr (unsigned data)
+//Bit 9:1   dout_offset (signed data)
+//Bit 0     enable
+#define GE2D_SRC1_RANGE_MAP_Y_CTRL                 ((0x18e3  << 2) + 0xc1100000)
+//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
+//Bit 30:22 din_offset (signed data)
+//Bit 21:14 map_coef (unsigned data)
+//Bit 13:10 map_sr (unsigned data)
+//Bit 9:1   dout_offset (signed data)
+//Bit 0     enable
+#define GE2D_SRC1_RANGE_MAP_CB_CTRL                ((0x18e4  << 2) + 0xc1100000)
+//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
+//Bit 30:22 din_offset (signed data)
+//Bit 21:14 map_coef (unsigned data)
+//Bit 13:10 map_sr (unsigned data)
+//Bit 9:1   dout_offset (signed data)
+//Bit 0     enable
+#define GE2D_SRC1_RANGE_MAP_CR_CTRL                ((0x18e5  << 2) + 0xc1100000)
+//Bit 21:16     src1 prearbitor burst number
+//Bit 13:8      src2 prearbitor burst number
+//Bit 5:0       dst prearbitor burst number
+#define GE2D_ARB_BURST_NUM                         ((0x18e6  << 2) + 0xc1100000)
+//each 6bit ID, high 4bit are thread ID, low 2bits are the token
+//Bit 21:16 src1 ID
+//Bit 13:8 src2 ID
+//Bit 5:0  dst ID
+#define GE2D_TID_TOKEN                             ((0x18e7  << 2) + 0xc1100000)
+//Bit 31:28 dst2_bytemask_val. 1-bit mask for each byte (8-bit). Applicable only if both dst_bitmask_en=1 and dst_bytemask_only=1.
+//Bit 27:26, dst2 picture struct, 00: frame, 10:top, 11: bottom
+//Bit 25:24, dst2 8bit mode component selection, 
+//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
+//Bit 22:19 dst2 color_map
+//        dst2_format=0                  : output 8-bit;
+//        dst2_format=1, dst2_color_map=1: output 16-bit YCbCr  655;
+//        dst2_format=1, dst2_color_map=2: output 16-bit YCbCr  844;
+//        dst2_format=1, dst2_color_map=3: output 16-bit YCbCrA 6442;
+//        dst2_format=1, dst2_color_map=4: output 16-bit YCbCrA 4444;
+//        dst2_format=1, dst2_color_map=5: output 16-bit YCbCr  565;
+//        dst2_format=1, dst2_color_map=6: output 16-bit AYCbCr 4444;
+//        dst2_format=1, dst2_color_map=7: output 16-bit AYCbCr 1555;
+//        dst2_format=1, dst2_color_map=8: output 16-bit YCbCrA 4642;
+//        dst2_format=1, dst2_color_map=9: output 16-bit CbCr   88;
+//        dst2_format=1, dst2_color_map=10:output 16-bit CrCb   88;
+//        dst2_format=2, dst2_color_map=0: output 24-bit YCbCr  888;
+//        dst2_format=2, dst2_color_map=1: output 24-bit YCbCrA 5658;
+//        dst2_format=2, dst2_color_map=2: output 24-bit AYCbCr 8565;
+//        dst2_format=2, dst2_color_map=3: output 24-bit YCbCrA 6666;
+//        dst2_format=2, dst2_color_map=4: output 24-bit AYCbCr 6666;
+//        dst2_format=2, dst2_color_map=5: output 24-bit CrCbY  888;
+//        dst2_format=3, dst2_color_map=0: output 32-bit YCbCrA 8888;
+//        dst2_format=3, dst2_color_map=1: output 32-bit AYCbCr 8888;
+//        dst2_format=3, dst2_color_map=2: output 32-bit ACrCbY 8888;
+//        dst2_format=3, dst2_color_map=3: output 32-bit CrCbYA 8888.
+//Bit 17:16 dst2_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
+//Bit 15     reserved
+//Bit 14     dst2_color_round_mode, 0: truncate, 1: + 0.5 rounding
+//Bit 13:12, dst2_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
+//Bit 11:10, dst2_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
+//Bit     9 reserved
+//Bit     8, dst2_enable. 0: disable dst2 (default); 1=enable dst2.
+//Bit  7: 6 reserved
+//Bit  5: 4, dst1_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
+//Bit  3: 2, dst1_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
+//Bit     1 reserved
+//Bit     0, dst1_enable. 0: disable dst1; 1=enable dst1 (default).
+#define GE2D_GEN_CTRL3                             ((0x18e8  << 2) + 0xc1100000)
+//Read only
+// Bit 13:0 ge2d_dst2_status, for debug only
+#define GE2D_STATUS2                               ((0x18e9  << 2) + 0xc1100000)
+//bit 0, if true, disable bug fix about the dp_out_done/scale_out_done(test1823) hang issue when scaling down ratio is high.
+#define GE2D_GEN_CTRL4                             ((0x18ea  << 2) + 0xc1100000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ge2d_regs.h
+//
+//========================================================================
+//  DSP Co-Processor Registers			    ( 8'he00 - 12'hfff)
+//
+//========================================================================
+// Duplicate Address:  When actually used
+// please move to a different address
+// `define AUDIO_COP_CTL1      12'hf00  // r & w; r-> 6'h00,bsmod[2:0],acmod[2:0],lfeon,nfchans[2:0]
+#define AUDIO_COP_CTL2                             ((0x1f01  << 2) + 0xc1100000)
+//  f02 -f0d are special regs , not in ac3_reg.h, but used by CPU for AC3 operations
+#define OPERAND_M_CTL                              ((0x1f02  << 2) + 0xc1100000)
+#define OPERAND1_ADDR                              ((0x1f03  << 2) + 0xc1100000)
+#define OPERAND2_ADDR                              ((0x1f04  << 2) + 0xc1100000)
+#define RESULT_M_CTL                               ((0x1f05  << 2) + 0xc1100000)
+#define RESULT1_ADDR                               ((0x1f06  << 2) + 0xc1100000)
+#define RESULT2_ADDR                               ((0x1f07  << 2) + 0xc1100000)
+#define ADD_SHFT_CTL                               ((0x1f08  << 2) + 0xc1100000)
+#define OPERAND_ONE_H                              ((0x1f09  << 2) + 0xc1100000)
+#define OPERAND_ONE_L                              ((0x1f0a  << 2) + 0xc1100000)
+#define OPERAND_TWO_H                              ((0x1f0b  << 2) + 0xc1100000)
+#define OPERAND_TWO_L                              ((0x1f0c  << 2) + 0xc1100000)
+#define RESULT_H                                   ((0x1f0d  << 2) + 0xc1100000)
+#define RESULT_M                                   ((0x1f0e  << 2) + 0xc1100000)
+// special reg 
+#define RESULT_L                                   ((0x1f0f  << 2) + 0xc1100000)
+// 
+#define WMEM_R_PTR                                 ((0x1f10  << 2) + 0xc1100000)
+#define WMEM_W_PTR                                 ((0x1f11  << 2) + 0xc1100000)
+#define AUDIO_LAYER                                ((0x1f20  << 2) + 0xc1100000)
+#define AC3_DECODING                               ((0x1f21  << 2) + 0xc1100000)
+#define AC3_DYNAMIC                                ((0x1f22  << 2) + 0xc1100000)
+#define AC3_MELODY                                 ((0x1f23  << 2) + 0xc1100000)
+#define AC3_VOCAL                                  ((0x1f24  << 2) + 0xc1100000)
+//======================================
+//  CPU Assist module
+//
+//======================================
+// -----------------------------------------------
+// CBUS_BASE:  ASSIST_CBUS_BASE = 0x1f
+// -----------------------------------------------
+//`define ASSIST_AMR_MBOX1_INT          8'h4d
+//`define ASSIST_AMR_MBOX2_INT          8'h4e
+#define ASSIST_AMR_SCRATCH0                        ((0x1f4f  << 2) + 0xc1100000)
+#define ASSIST_AMR_SCRATCH1                        ((0x1f50  << 2) + 0xc1100000)
+#define ASSIST_AMR_SCRATCH2                        ((0x1f51  << 2) + 0xc1100000)
+#define ASSIST_AMR_SCRATCH3                        ((0x1f52  << 2) + 0xc1100000)
+#define ASSIST_HW_REV                              ((0x1f53  << 2) + 0xc1100000)
+//`define ASSIST_CBUS_ARB               8'h54
+#define ASSIST_POR_CONFIG                          ((0x1f55  << 2) + 0xc1100000)
+#define ASSIST_SPARE16_REG1                        ((0x1f56  << 2) + 0xc1100000)
+#define ASSIST_SPARE16_REG2                        ((0x1f57  << 2) + 0xc1100000)
+#define ASSIST_SPARE8_REG1                         ((0x1f58  << 2) + 0xc1100000)
+#define ASSIST_SPARE8_REG2                         ((0x1f59  << 2) + 0xc1100000)
+// Duplicate Address...when used please move to a new address
+// `define TO_AMRISC_REG                 8'h59 // for amrisc
+#define ASSIST_SPARE8_REG3                         ((0x1f5a  << 2) + 0xc1100000)
+// Duplicate Address...when used please move to a new address
+// `define FROM_AMRISC_REG               8'h5a // for amrisc
+// Duplicate Address...when used please move to a new address
+// `define MPEG2_DECODER_CONTROL         8'h5b // for amrisc
+#define AC3_CTRL_REG1                              ((0x1f5b  << 2) + 0xc1100000)
+#define AC3_CTRL_REG2                              ((0x1f5c  << 2) + 0xc1100000)
+#define AC3_CTRL_REG3                              ((0x1f5d  << 2) + 0xc1100000)
+#define AC3_CTRL_REG4                              ((0x1f5e  << 2) + 0xc1100000)
+//`define ASSIST_PMEM_SPLIT             8'h5f
+#define ASSIST_GEN_CNTL                            ((0x1f68  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX0_IRQ_REG                    ((0x1f70  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX0_CLR_REG                    ((0x1f71  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX0_MASK                       ((0x1f72  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX0_FIQ_SEL                    ((0x1f73  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX1_IRQ_REG                    ((0x1f74  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX1_CLR_REG                    ((0x1f75  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX1_MASK                       ((0x1f76  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX1_FIQ_SEL                    ((0x1f77  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX2_IRQ_REG                    ((0x1f78  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX2_CLR_REG                    ((0x1f79  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX2_MASK                       ((0x1f7a  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX2_FIQ_SEL                    ((0x1f7b  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX3_IRQ_REG                    ((0x1f7c  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX3_CLR_REG                    ((0x1f7d  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX3_MASK                       ((0x1f7e  << 2) + 0xc1100000)
+#define EE_ASSIST_MBOX3_FIQ_SEL                    ((0x1f7f  << 2) + 0xc1100000)
+// -----------------------------------------------
+// CBUS_BASE:  AUD_CBUS_BASE = 0x28
+// -----------------------------------------------
+// ----------------------------
+// AUDIN (64)
+// ----------------------------
+#define AUDIN_SPDIF_MODE                           ((0x2800  << 2) + 0xc1100000)
+    #define SPDIF_EN                31
+    #define SPDIF_INT_EN            30
+    #define SPDIF_BURST_PRE_INT_EN  29
+    #define SPDIF_TIE_0             24
+    #define SPDIF_SAMPLE_SEL        23
+    #define SPDIF_REVERSE_EN        22
+    #define SPDIF_BIT_ORDER         20
+    #define SPDIF_CHNL_ORDER        19
+    #define SPDIF_DATA_TYPE_SEL     18
+    #define SPDIF_XTDCLK_UPD_ITVL   14   //16:14
+    #define SPDIF_CLKNUM_54U        0     //13:0 
+#define AUDIN_SPDIF_FS_CLK_RLTN                    ((0x2801  << 2) + 0xc1100000)
+    #define SPDIF_CLKNUM_192K  24     //29:24 
+    #define SPDIF_CLKNUM_96K   18     //23:18 
+    #define SPDIF_CLKNUM_48K   12     //17:12 
+    #define SPDIF_CLKNUM_44K   6     // 11:6
+    #define SPDIF_CLKNUM_32K   0     // 5:0
+#define AUDIN_SPDIF_CHNL_STS_A                     ((0x2802  << 2) + 0xc1100000)
+#define AUDIN_SPDIF_CHNL_STS_B                     ((0x2803  << 2) + 0xc1100000)
+#define AUDIN_SPDIF_MISC                           ((0x2804  << 2) + 0xc1100000)
+#define AUDIN_SPDIF_NPCM_PCPD                      ((0x2805  << 2) + 0xc1100000)
+#define AUDIN_SPDIF_END                            ((0x280f  << 2) + 0xc1100000)
+#define AUDIN_I2SIN_CTRL                           ((0x2810  << 2) + 0xc1100000)
+    #define I2SIN_DIR       0    // I2S CLK and LRCLK direction. 0 : input 1 : output.
+    #define I2SIN_CLK_SEL    1    // I2S clk selection : 0 : from pad input. 1 : from AIU.
+    #define I2SIN_LRCLK_SEL 2
+    #define I2SIN_POS_SYNC  3
+    #define I2SIN_LRCLK_SKEW 4    // 6:4
+    #define I2SIN_LRCLK_INVT 7
+    #define I2SIN_SIZE       8    //9:8 : 0 16 bit. 1 : 18 bits 2 : 20 bits 3 : 24bits.
+    #define I2SIN_CHAN_EN   10    //13:10. 
+    #define I2SIN_EN        15
+// Bit 31:15    Rsrv.
+// Bit 14:12 RW HDMI-RX SPDIF channel status select to report on AUDIN_DECODE_CHANNEL_STATUS_A_*: 0=select channel 1; 1=channel 2; ...; 7=channel 8.
+// Bit 11: 8 RW HDMI-RX SPDIF channel status extraction enable, 1-bit per channel pair. To enable, SPDIF input source also must select 1.
+// Bit  7: 6    Rsrv.
+// Bit  5: 4 RW SPDIF input source select. 0=Default, select chip external; 1=select HDMI RX output; 2/3=Rsrv.
+// Bit  3: 2    Rsrv.
+// Bit  1: 0 RW I2S input source select. 0=Default, select chip external; 1=select audio codec output; 2=select HDMI RX output; 3=Rsrv.
+#define AUDIN_SOURCE_SEL                           ((0x2811  << 2) + 0xc1100000)
+// The following registers control the new alternative decoder -- hdmi_tx_audio_decoder, in audin module
+// Bit 31:25    Rsrv.
+// Bit    24 RW SPDIF enable.
+// Bit 23:22    Rsrv.
+// Bit 21:20 RW i2s_block_start_src: 0=left channel 0 is approved as block start generator, ..., 3=left channel 3 is the block start generator.
+// Bit 19:17    Rsrv.
+// Bit    16 RW I2S enable.
+// Bit 15: 8 RW audio_channel_alloc: Usage indication of up to 8 channels. If the correspoinding bit is 1, then this channel is used.
+//                                   E.g.: In 2-channel audio, it is 00000011
+// Bit     7 RW hdmi_tx_audio_decoder input sel: 0=SPDIF; 1=I2S.
+// Bit     6 RW i2s_channel_config: 0=2-channel; 1=8-channel.
+// Bit  5: 4 RW i2s_format_select: 0=left-justify; 1=right-justify; 2=I2S format; 3=DSP format.
+// Bit  3: 2 RW i2s_bit_width: 0=16-bit; 1=18-bit; 2=20-bit; 3=24-bit.
+// Bit     1 RW ws polarity: 0=0 is left, 1 is right; 1=1 is left, 0 is right.
+// Bit     0 RW For SPDIF mode, 0=use channel status from input data; 1=use channel status from registers;
+//              For I2S mode, 0=one-bit audio; 1=I2S.
+#define AUDIN_DECODE_FORMAT                        ((0x2812  << 2) + 0xc1100000)
+// Bit 31:25    Rsrv.
+// Bit    24 R  channel_status stablility indicator.
+// Bit 23:16 RW Valid bits for audio sample packet. [7] for valid_sp3_right, [6] for valid_sp3_left, ..., [1] for valid_sp0_right, [0] for valid_sp0_left.
+// Bit 15: 8 RW User bits for audio sample packet. [7] for user_sp3_right, [6] for user_sp3_left, ..., [1] for user_sp0_right, [0] for user_sp0_left.
+// Bit  7: 4 RW cntl_init_discard: Number of initial hdmi_tx_audio_decoder samples to discard from reset.
+// Bit     3 RW cntl_invert_i2s_lrclk: Invert WS before input to hdmi_tx_audio_decoder.
+// Bit     2 RW audio_valid_overwrite: Valid bit selection in audio packet. 0=use input data; 1=use
+// Bit     1 RW audio_user_overwrite: User bit selection in audio packet. 0=use input data; 1=use
+// Bit     0 RW audio_sample_valid: sample non-flat indication. 0=flat, non-valid; 1=non-flat, valid.
+#define AUDIN_DECODE_CONTROL_STATUS                ((0x2813  << 2) + 0xc1100000)
+// IEC958 192-bit channel status: muxed between 8 channels, channel selection by AUDIN_SOURCE_SEL[14:12]
+#define AUDIN_DECODE_CHANNEL_STATUS_A_0            ((0x2814  << 2) + 0xc1100000)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_1            ((0x2815  << 2) + 0xc1100000)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_2            ((0x2816  << 2) + 0xc1100000)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_3            ((0x2817  << 2) + 0xc1100000)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_4            ((0x2818  << 2) + 0xc1100000)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_5            ((0x2819  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_START                          ((0x2820  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_END                            ((0x2821  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_PTR                            ((0x2822  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_INTR                           ((0x2823  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_RDPTR                          ((0x2824  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_CTRL                           ((0x2825  << 2) + 0xc1100000)
+    #define AUDIN_FIFO0_EN       0
+    #define AUDIN_FIFO0_RST      1
+    #define AUDIN_FIFO0_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
+         
+    #define AUDIN_FIFO0_DIN_SEL  3
+            // 0     spdifIN
+            // 1     i2Sin
+            // 2     PCMIN
+            // 3     HDMI in
+            // 4     DEMODULATOR IN
+    #define AUDIN_FIFO0_ENDIAN   8    //10:8   data endian control.
+    #define AUDIN_FIFO0_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
+    #define AUDIN_FIFO0_UG       15    // urgent request enable.
+    #define AUDIN_FIFO0_HOLD0_EN  19  
+    #define AUDIN_FIFO0_HOLD1_EN  20
+    #define AUDIN_FIFO0_HOLD2_EN  21
+    #define AUDIN_FIFO0_HOLD0_SEL 22   // 23:22
+    #define AUDIN_FIFO0_HOLD1_SEL 24   // 25:24
+    #define AUDIN_FIFO0_HOLD2_SEL 26   // 27:26
+    #define AUDIN_FIFO0_HOLD_LVL  28   // 27:26
+
+
+#define AUDIN_FIFO0_CTRL1                          ((0x2826  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_LVL0                           ((0x2827  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_LVL1                           ((0x2828  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_LVL2                           ((0x2829  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_REQID                          ((0x2830  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_WRAP                           ((0x2831  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_START                          ((0x2833  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_END                            ((0x2834  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_PTR                            ((0x2835  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_INTR                           ((0x2836  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_RDPTR                          ((0x2837  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_CTRL                           ((0x2838  << 2) + 0xc1100000)
+    #define AUDIN_FIFO1_EN       0
+    #define AUDIN_FIFO1_RST      1
+    #define AUDIN_FIFO1_LOAD     2    //write 1 to load address to AUDIN_FIFO0.
+         
+    #define AUDIN_FIFO1_DIN_SEL  3
+            // 0     spdifIN
+            // 1     i2Sin
+            // 2     PCMIN
+            // 3     HDMI in
+            // 4     DEMODULATOR IN
+    #define AUDIN_FIFO1_ENDIAN   8    //10:8   data endian control.
+    #define AUDIN_FIFO1_CHAN     11    //14:11   channel number.  in M1 suppose there's only 1 channel and 2 channel.
+    #define AUDIN_FIFO1_UG       15    // urgent request enable.
+    #define AUDIN_FIFO1_HOLD0_EN  19  
+    #define AUDIN_FIFO1_HOLD1_EN  20
+    #define AUDIN_FIFO1_HOLD2_EN  21
+    #define AUDIN_FIFO1_HOLD0_SEL 22   // 23:22
+    #define AUDIN_FIFO1_HOLD1_SEL 24   // 25:24
+    #define AUDIN_FIFO1_HOLD2_SEL 26   // 27:26
+    #define AUDIN_FIFO1_HOLD_LVL  28   // 27:26
+#define AUDIN_FIFO1_CTRL1                          ((0x2839  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_LVL0                           ((0x2840  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_LVL1                           ((0x2841  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_LVL2                           ((0x2842  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_REQID                          ((0x2843  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_WRAP                           ((0x2844  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_START                          ((0x2845  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_END                            ((0x2846  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_PTR                            ((0x2847  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_INTR                           ((0x2848  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_RDPTR                          ((0x2849  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_CTRL                           ((0x284a  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_CTRL1                          ((0x284b  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_LVL0                           ((0x284c  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_LVL1                           ((0x284d  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_LVL2                           ((0x284e  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_REQID                          ((0x284f  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_WRAP                           ((0x2850  << 2) + 0xc1100000)
+#define AUDIN_INT_CTRL                             ((0x2851  << 2) + 0xc1100000)
+#define AUDIN_FIFO_INT                             ((0x2852  << 2) + 0xc1100000)
+#define PCMIN_CTRL0                                ((0x2860  << 2) + 0xc1100000)
+#define PCMIN_CTRL1                                ((0x2861  << 2) + 0xc1100000)
+//`define PCMIN1_CTRL0                     8'h62 
+//`define PCMIN1_CTRL1                     8'h63 
+#define PCMOUT_CTRL0                               ((0x2870  << 2) + 0xc1100000)
+#define PCMOUT_CTRL1                               ((0x2871  << 2) + 0xc1100000)
+#define PCMOUT_CTRL2                               ((0x2872  << 2) + 0xc1100000)
+#define PCMOUT_CTRL3                               ((0x2873  << 2) + 0xc1100000)
+//`define PCMOUT1_CTRL0                    8'h74
+//`define PCMOUT1_CTRL1                    8'h75
+//`define PCMOUT1_CTRL2                    8'h76
+//`define PCMOUT1_CTRL3                    8'h77
+#define AUDOUT_CTRL                                ((0x2880  << 2) + 0xc1100000)
+#define AUDOUT_CTRL1                               ((0x2881  << 2) + 0xc1100000)
+#define AUDOUT_BUF0_STA                            ((0x2882  << 2) + 0xc1100000)
+#define AUDOUT_BUF0_EDA                            ((0x2883  << 2) + 0xc1100000)
+#define AUDOUT_BUF0_WPTR                           ((0x2884  << 2) + 0xc1100000)
+#define AUDOUT_BUF1_STA                            ((0x2885  << 2) + 0xc1100000)
+#define AUDOUT_BUF1_EDA                            ((0x2886  << 2) + 0xc1100000)
+#define AUDOUT_BUF1_WPTR                           ((0x2887  << 2) + 0xc1100000)
+#define AUDOUT_FIFO_RPTR                           ((0x2888  << 2) + 0xc1100000)
+#define AUDOUT_INTR_PTR                            ((0x2889  << 2) + 0xc1100000)
+#define AUDOUT_FIFO_STS                            ((0x288a  << 2) + 0xc1100000)
+//`define AUDOUT1_CTRL                     8'h90
+//`define AUDOUT1_CTRL1                    8'h91
+//`define AUDOUT1_BUF0_STA                 8'h92
+//`define AUDOUT1_BUF0_EDA                 8'h93
+//`define AUDOUT1_BUF0_WPTR                8'h94
+//`define AUDOUT1_BUF1_STA                 8'h95
+//`define AUDOUT1_BUF1_EDA                 8'h96
+//`define AUDOUT1_BUF1_WPTR                8'h97
+//`define AUDOUT1_FIFO_RPTR                8'h98
+//`define AUDOUT1_INTR_PTR                 8'h99
+//`define AUDOUT1_FIFO_STS                 8'h9a
+//// Bit 31: 0 RW cntl_mute_val: Use this value during mute, if cntl_mute_mode=2.
+//`define AUDIN_MUTE_VAL                 8'h35
+#define AUDIN_HDMI_MEAS_CTRL                       ((0x28a0  << 2) + 0xc1100000)
+#define AUDIN_HDMI_MEAS_CYCLES_M1                  ((0x28a1  << 2) + 0xc1100000)
+#define AUDIN_HDMI_MEAS_INTR_MASKN                 ((0x28a2  << 2) + 0xc1100000)
+#define AUDIN_HDMI_MEAS_INTR_STAT                  ((0x28a3  << 2) + 0xc1100000)
+#define AUDIN_HDMI_REF_CYCLES_STAT_0               ((0x28a4  << 2) + 0xc1100000)
+#define AUDIN_HDMI_REF_CYCLES_STAT_1               ((0x28a5  << 2) + 0xc1100000)
+#define AUDIN_HDMIRX_AFIFO_STAT                    ((0x28a6  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_PIO_STS                        ((0x28b0  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_PIO_RDL                        ((0x28b1  << 2) + 0xc1100000)
+#define AUDIN_FIFO0_PIO_RDH                        ((0x28b2  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_PIO_STS                        ((0x28b3  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_PIO_RDL                        ((0x28b4  << 2) + 0xc1100000)
+#define AUDIN_FIFO1_PIO_RDH                        ((0x28b5  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_PIO_STS                        ((0x28b6  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_PIO_RDL                        ((0x28b7  << 2) + 0xc1100000)
+#define AUDIN_FIFO2_PIO_RDH                        ((0x28b8  << 2) + 0xc1100000)
+#define AUDOUT_FIFO_PIO_STS                        ((0x28b9  << 2) + 0xc1100000)
+#define AUDOUT_FIFO_PIO_WRL                        ((0x28ba  << 2) + 0xc1100000)
+#define AUDOUT_FIFO_PIO_WRH                        ((0x28bb  << 2) + 0xc1100000)
+//`define AUDOUT1_FIFO_PIO_STS		8'hbc
+//`define AUDOUT1_FIFO_PIO_WRL        	8'hbd
+//`define AUDOUT1_FIFO_PIO_WRH        	8'hbe
+#define AUD_RESAMPLE_CTRL0                         ((0x28bf  << 2) + 0xc1100000)
+#define AUD_RESAMPLE_CTRL1                         ((0x28c0  << 2) + 0xc1100000)
+#define AUD_RESAMPLE_STATUS                        ((0x28c1  << 2) + 0xc1100000)
+#define AUDIN_ADDR_END                             ((0x28c2  << 2) + 0xc1100000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./register_map.h
+//
+//
+// Reading file:  ./vcbus_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//===========================================================================
+// VDIN   
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VDIN_VCBUS_BASE = 0x12
+// -----------------------------------------------
+//VDIN0        8'h00 - 8'h6f
+//VDIN1        8'h70 - 8'hdf
+#define VDIN0_OFFSET            0x00
+#define VDIN1_OFFSET            0x70
+
+#define VDIN_SCALE_COEF_IDX                        ((0x1200  << 2) + 0xd0100000)
+#define VDIN_SCALE_COEF                            ((0x1201  << 2) + 0xd0100000)
+//bit 31,   mpeg_to_vdin_sel, 0: mpeg source to NR directly, 1: mpeg source pass through here
+//bit 30,   mpeg_field info which can be written by software
+//Bit 29,   force go_field, pulse signal
+//Bit 28,   force go_line, pulse signal
+//Bit 27,   enable mpeg_go_field input signal
+//Bit 26:20, hold lines
+//Bit 19,   delay go_field function enable
+//Bit 18:12, delay go_field line number 
+//Bit 11:10, component2 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
+//Bit 9:8, component1 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
+//Bit 7:6, component0 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
+//Bit 5,   input window selection function enable
+//Bit 4, enable VDIN common data input, otherwise there will be no video data input
+//Bit 3:0 vdin selection, 1: mpeg_in from dram, 2: bt656 input, 3: component input, 4: tvdecoder input, 5: hdmi rx input, 6: digtial video input, 7: loopback from Viu1, 8: MIPI.
+#define VDIN_COM_CTRL0                             ((0x1202  << 2) + 0xd0100000)
+//Bit 28:16 active_max_pix_cnt, readonly
+//Bit 12:0  active_max_pix_cnt_shadow, readonly
+#define VDIN_ACTIVE_MAX_PIX_CNT_STATUS             ((0x1203  << 2) + 0xd0100000)
+//Bit 28:16 go_line_cnt, readonly
+//Bit 12:0  active_line_cnt, readonly
+#define VDIN_LCNT_STATUS                           ((0x1204  << 2) + 0xd0100000)
+//Readonly
+//Bit [14:3] lfifo_buf_cnt
+//Bit 2, vdin_direct_done status
+//Bit 1, vdin_nr_done status
+//Bit 0, field
+#define VDIN_COM_STATUS0                           ((0x1205  << 2) + 0xd0100000)
+//Readonly
+//Bit 31, vdi4 fifo overflow
+//Bit 29:24, vdi3_asfifo_cnt
+//Bit 23, vdi3 fifo overflow
+//Bit 21:16, vdi3_asfifo_cnt
+//Bit 15, vdi2 fifo overflow
+//Bit 13:8, vdi2_asfifo_cnt
+//Bit 7, vdi1 fifo overflow
+//Bit 5:0, vdi1_asfifo_cnt
+#define VDIN_COM_STATUS1                           ((0x1206  << 2) + 0xd0100000)
+//Bit 28:16 go_line_cnt_shadow, readonly
+//Bit 12:0  active_line_cnt_shadow, readonly
+#define VDIN_LCNT_SHADOW_STATUS                    ((0x1207  << 2) + 0xd0100000)
+//each 8bit asfifo_ctrl is following:
+//Bit 7, DE  enable 
+//Bit 6, go field enable 
+//Bit 5, go line enable 
+//Bit 4, if true, negative active input vsync
+//Bit 3, if true, negative active input hsync
+//Bit 2, vsync soft reset fifo enable
+//Bit 1, overflow status clear
+//Bit 0 asfifo soft reset, level signal
+//Bit 7:0 vdi1 asfifo_ctrl 
+//Bit 23:16 vdi2 asfifo_ctrl 
+#define VDIN_ASFIFO_CTRL0                          ((0x1208  << 2) + 0xd0100000)
+//Bit 7:0 vdi3 asfifo_ctrl 
+//Bit 23:16 vdi4 asfifo_ctrl 
+#define VDIN_ASFIFO_CTRL1                          ((0x1209  << 2) + 0xd0100000)
+//Bit 28:16 input width minus 1, after the window function
+//Bit 12:0  output width minus 1
+#define VDIN_WIDTHM1I_WIDTHM1O                     ((0x120a  << 2) + 0xd0100000)
+//Bit 20:17 prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode, 
+//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
+//Bit 16:15 sp422_mode, special mode for the component1 and component2, 00: normal case, 01: 32 64 32, 10: 0 64 64 0, 11: 16 96 16
+//Bit 14:8, hsc_ini_pixi_ptr, signed data, only useful when short_lineo_en is true
+//Bit 7, prehsc_en
+//Bit 6, hsc_en,
+//Bit 5, hsc_short_lineo_en, short line output enable
+//Bit 4, hsc_nearest_en
+//Bit 3, hsc_phase0_always_en
+//Bit 2:0, hsc_bank_length
+#define VDIN_SC_MISC_CTRL                          ((0x120b  << 2) + 0xd0100000)
+//Bit 28:24, integer portion
+//Bit 23:0, fraction portion
+#define VDIN_HSC_PHASE_STEP                        ((0x120c  << 2) + 0xd0100000)
+//Bit 30:29    hscale rpt_p0_num
+//Bit 28:24    hscale ini_rcv_num
+//Bit 23:0     hscale ini_phase
+#define VDIN_HSC_INI_CTRL                          ((0x120d  << 2) + 0xd0100000)
+//Read only
+//Bit 23, vdi7 fifo overflow
+//Bit 21:16, vdi7_asfifo_cnt
+//Bit 15, vdi6 fifo overflow
+//Bit 13:8, vdi6_asfifo_cnt
+//Bit 7, vdi5 fifo overflow
+//Bit 5:0, vdi5_asfifo_cnt
+#define VDIN_COM_STATUS2                           ((0x120e  << 2) + 0xd0100000)
+//Bit 25:16 asfifo decimate control
+//Bit 25, if true, decimation counter sync with first valid DE in the field, 
+//otherwise the decimation counter is not sync with external signal 
+//Bit 24, decimation de enable
+//Bit 23:20, decimation phase, which counter value use to decimate, 
+//Bit 19:16, decimation number, 0: not decimation, 1: decimation 2, 2: decimation 3 .... 
+//Bit 7:0 vdi5 asfifo_ctrl 
+#define VDIN_ASFIFO_CTRL2                          ((0x120f  << 2) + 0xd0100000)
+//Bit 7,  highlight_en
+//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
+//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing 
+//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing 
+//Bit 1   mat1 conversion matrix enable
+//Bit 0   mat0 conversion matrix enable
+#define VDIN_MATRIX_CTRL                           ((0x1210  << 2) + 0xd0100000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define VDIN_MATRIX_COEF00_01                      ((0x1211  << 2) + 0xd0100000)
+//Bit 28:16 coef02 
+//Bit 12:0  coef10 
+#define VDIN_MATRIX_COEF02_10                      ((0x1212  << 2) + 0xd0100000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define VDIN_MATRIX_COEF11_12                      ((0x1213  << 2) + 0xd0100000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define VDIN_MATRIX_COEF20_21                      ((0x1214  << 2) + 0xd0100000)
+#define VDIN_MATRIX_COEF22                         ((0x1215  << 2) + 0xd0100000)
+//Bit 26:16 offset0
+//Bit 10:0  offset1
+#define VDIN_MATRIX_OFFSET0_1                      ((0x1216  << 2) + 0xd0100000)
+//Bit 10:0  offset2
+#define VDIN_MATRIX_OFFSET2                        ((0x1217  << 2) + 0xd0100000)
+//Bit 26:16 pre_offset0
+//Bit 10:0  pre_offset1
+#define VDIN_MATRIX_PRE_OFFSET0_1                  ((0x1218  << 2) + 0xd0100000)
+//Bit 10:0  pre_offset2
+#define VDIN_MATRIX_PRE_OFFSET2                    ((0x1219  << 2) + 0xd0100000)
+//12:0 lfifo_buf_size
+#define VDIN_LFIFO_CTRL                            ((0x121a  << 2) + 0xd0100000)
+#define VDIN_COM_GCLK_CTRL                         ((0x121b  << 2) + 0xd0100000)
+//12:0 VDIN input interface width minus 1, before the window function, after the de decimation
+#define VDIN_INTF_WIDTHM1                          ((0x121c  << 2) + 0xd0100000)
+//Bit 15          //default== 0, urgent_ctrl_en
+//Bit 14          //default== 0, urgent_wr, if true for write buffer
+//Bit 13          //default== 0, out_inv_en
+//Bit 12          //default == 0, urgent_ini_value
+//Bit 11:6        //default == 0, up_th  up threshold
+//Bit 5:0         //default == 0, dn_th  dn threshold
+#define VDIN_LFIFO_URG_CTRL                        ((0x121e  << 2) + 0xd0100000)
+//Bit 8, 1: discard data before line fifo, 0: normal mode
+//Bit 7:0 Write chroma canvas address
+#define VDIN_WR_CTRL2                              ((0x121f  << 2) + 0xd0100000)
+//Bit 31:30 hconv_mode, Applicable only to bit[13:12]=0 or 2. 0: Output every even pixels' CbCr;
+//                                                            1: Output every odd pixels' CbCr;
+//                                                            2: Output an average value per even&odd pair of pixels;
+//                                                            3: Output all CbCr. (This does NOT apply to bit[13:12]=0 -- 4:2:2 mode.)
+//Bit 29 no_clk_gate: disable vid_wr_mif clock gating function.
+//Bit 28 clear write response counter in the vdin write memory interface 
+//Bit 27 eol_sel, 1: use eol as the line end indication, 0: use width as line end indication in the vdin write memory interface
+//Bit 26 vcp_nr_en. Only used in VDIN0. NOT used in VDIN1.
+//Bit 25 vcp_wr_en. Only used in VDIN0. NOT used in VDIN1.
+//Bit 24 vcp_in_en. Only used in VDIN0. NOT used in VDIN1.
+//Bit 23 vdin frame reset enble, if true, it will provide frame reset during go_field(vsync) to the modules after that 
+//Bit 22 vdin line fifo soft reset enable, meaning, if true line fifo will reset during go_field (vsync)
+//Bit 21 vdin direct write done status clear bit 
+//Bit 20 vdin NR write done status clear bit 
+//Bit 18 swap_cbcr. Applicable only to bit[13:12]=2. 0: Output CbCr (NV12); 1: Output CrCb (NV21).
+//Bit 17:16 vconv_mode, Applicable only to bit[13:12]=2. 0: Output every even lines' CbCr;
+//                                                       1: Output every odd lines' CbCr;
+//                                                       2: Reserved;
+//                                                       3: Output all CbCr.
+//Bit 13:12 vdin write format, 0: 4:2:2 to luma canvas, 1: 4:4:4 to luma canvas,
+//                             2: Y to luma canvas, CbCr to chroma canvas. For NV12/21, also define Bit 31:30, 17:16, and bit 18.
+//Bit 11 vdin write canvas double buffer enable, means the canvas address will be latched by vsync before using 
+//Bit 10 1: disable ctrl_reg write pulse which will reset internal counter. when bit 11 is 1, this bit should be 1.
+//Bit 9 vdin write request urgent
+//Bit 8 vdin write request enable
+//Bit 7:0 Write luma canvas address
+#define VDIN_WR_CTRL                               ((0x1220  << 2) + 0xd0100000)
+//Bit 29, if true, horizontal reverse
+//Bit 28:16 start
+//Bit 12:0  end
+#define VDIN_WR_H_START_END                        ((0x1221  << 2) + 0xd0100000)
+//Bit 29, if true, vertical reverse
+//Bit 28:16 start
+//Bit 12:0  end
+#define VDIN_WR_V_START_END                        ((0x1222  << 2) + 0xd0100000)
+//Bit 24:20, integer portion
+//Bit 19:0, fraction portion
+#define VDIN_VSC_PHASE_STEP                        ((0x1223  << 2) + 0xd0100000)
+//Bit 23, vsc_en, vertical scaler enable
+//Bit 21 vsc_phase0_always_en, when scale up, you have to set it to 1
+//Bit 20:16 ini skip_line_num
+//Bit 15:0 vscaler ini_phase 
+#define VDIN_VSC_INI_CTRL                          ((0x1224  << 2) + 0xd0100000)
+//Bit 12:0, scaler input height minus 1
+#define VDIN_SCIN_HEIGHTM1                         ((0x1225  << 2) + 0xd0100000)
+//Bit 23:16, dummy component 0
+//Bit 15:8, dummy component 1
+//Bit 7:0, dummy component 2
+#define VDIN_DUMMY_DATA                            ((0x1226  << 2) + 0xd0100000)
+//Read only 
+//Bit 29:20 component 0
+//Bit 19:10 component 1
+//Bit 9:0 component 2
+#define VDIN_MATRIX_PROBE_COLOR                    ((0x1228  << 2) + 0xd0100000)
+//Bit 23:16 component 0
+//Bit 15:8  component 1
+//Bit 7:0 component 2
+#define VDIN_MATRIX_HL_COLOR                       ((0x1229  << 2) + 0xd0100000)
+//28:16 probe x, postion
+//12:0  probe y, position  
+#define VDIN_MATRIX_PROBE_POS                      ((0x122a  << 2) + 0xd0100000)
+#define VDIN_CHROMA_ADDR_PORT                      ((0x122b  << 2) + 0xd0100000)
+#define VDIN_CHROMA_DATA_PORT                      ((0x122c  << 2) + 0xd0100000)
+//
+#define VDIN_CM_BRI_CON_CTRL                       ((0x122d  << 2) + 0xd0100000)
+//Bit 17  clk_cyc_cnt_clr, if true, clear this register
+//Bit 16 if true, use vpu clock to count one line, otherwise use actually hsync to count line_cnt 
+//Bit 15:0   line width using vpu clk
+#define VDIN_GO_LINE_CTRL                          ((0x122f  << 2) + 0xd0100000)
+//Bit 10:9  ldim_stts_din_sel, 00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din 
+//Bit 8     ldim_stts_en
+//Bit 6:5   hist_dnlp_low   the real pixels in each bins got by VDIN_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
+//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
+//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
+//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
+#define VDIN_HIST_CTRL                             ((0x1230  << 2) + 0xd0100000)
+//Bit 28:16 hist_hstart  horizontal start value to define hist window
+//Bit 12:0  hist_hend    horizontal end value to define hist window
+#define VDIN_HIST_H_START_END                      ((0x1231  << 2) + 0xd0100000)
+//Bit 28:16 hist_vstart  vertical start value to define hist window
+//Bit 12:0  hist_vend    vertical end value to define hist window
+#define VDIN_HIST_V_START_END                      ((0x1232  << 2) + 0xd0100000)
+//Bit 15:8  hist_max    maximum value 
+//Bit 7:0   hist_min    minimum value 
+//read only
+#define VDIN_HIST_MAX_MIN                          ((0x1233  << 2) + 0xd0100000)
+//Bit 31:0  hist_spl_rd
+//counts for the total luma value 
+//read only
+#define VDIN_HIST_SPL_VAL                          ((0x1234  << 2) + 0xd0100000)
+//Bit 21:0  hist_spl_pixel_count
+//counts for the total calculated pixels
+//read only
+#define VDIN_HIST_SPL_PIX_CNT                      ((0x1235  << 2) + 0xd0100000)
+//Bit 31:0  hist_chroma_sum
+//counts for the total chroma value 
+//read only
+#define VDIN_HIST_CHROMA_SUM                       ((0x1236  << 2) + 0xd0100000)
+//Bit 31:16 higher hist bin
+//Bit 15:0  lower hist bin
+//0-255 are splited to 64 bins evenly, and VDIN_DNLP_HISTXX
+//are the statistic number of pixels that within each bin.
+//VDIN_DNLP_HIST00[15:0]  counts for the first  bin
+//VDIN_DNLP_HIST00[31:16] counts for the second bin
+//VDIN_DNLP_HIST01[15:0]  counts for the third  bin
+//VDIN_DNLP_HIST01[31:16] counts for the fourth bin
+//etc...
+//read only
+#define VDIN_DNLP_HIST00                           ((0x1237  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST01                           ((0x1238  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST02                           ((0x1239  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST03                           ((0x123a  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST04                           ((0x123b  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST05                           ((0x123c  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST06                           ((0x123d  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST07                           ((0x123e  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST08                           ((0x123f  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST09                           ((0x1240  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST10                           ((0x1241  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST11                           ((0x1242  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST12                           ((0x1243  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST13                           ((0x1244  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST14                           ((0x1245  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST15                           ((0x1246  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST16                           ((0x1247  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST17                           ((0x1248  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST18                           ((0x1249  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST19                           ((0x124a  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST20                           ((0x124b  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST21                           ((0x124c  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST22                           ((0x124d  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST23                           ((0x124e  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST24                           ((0x124f  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST25                           ((0x1250  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST26                           ((0x1251  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST27                           ((0x1252  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST28                           ((0x1253  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST29                           ((0x1254  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST30                           ((0x1255  << 2) + 0xd0100000)
+#define VDIN_DNLP_HIST31                           ((0x1256  << 2) + 0xd0100000)
+//Bit 31, local dimming statistic enable
+//Bit 28, eol enable
+//Bit 27:25, vertical line overlap number for max finding
+//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
+//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
+//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
+//Bit 15, 1: region read index auto increase per read to VDIN_LDIM_STTS_HIST_READ_REGION 
+//Bit 6:0, region read index
+#define VDIN_LDIM_STTS_HIST_REGION_IDX             ((0x1257  << 2) + 0xd0100000)
+//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
+//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
+//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
+//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
+//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
+//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
+//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
+//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
+//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
+//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
+//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
+//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
+#define VDIN_LDIM_STTS_HIST_SET_REGION             ((0x1258  << 2) + 0xd0100000)
+//REGION STATISTIC DATA READ OUT PORT, bit 29:20 max_comp2, bit 19:10 max_comp1, bit 9:0 max_comp0
+#define VDIN_LDIM_STTS_HIST_READ_REGION            ((0x1259  << 2) + 0xd0100000)
+//Bit 18, reset bit, high active
+//Bit 17, if true, widen hs/vs pulse
+//Bit 16  vsync total counter always accumulating enable
+//Bit 14:12, select hs/vs of video input channel to measure, 0: no selection, 1: vdi1, 2: vid2, 3: vid3, 4:vid4, 5:vdi5, 6:vid6, 7:vdi7, 8: vdi8
+//Bit 11:4, vsync_span, define how many vsync span need to measure 
+//Bit 2:0  meas_hs_index, index to select which HS counter/range
+#define VDIN_MEAS_CTRL0                            ((0x125a  << 2) + 0xd0100000)
+//Read only
+//19:16     meas_ind_total_count_n, every number of sync_span vsyncs, this count add 1
+//15:0      high bit portion of vsync total counter
+#define VDIN_MEAS_VS_COUNT_HI                      ((0x125b  << 2) + 0xd0100000)
+//Read only
+//31:0, low bit portion of vsync total counter 
+#define VDIN_MEAS_VS_COUNT_LO                      ((0x125c  << 2) + 0xd0100000)
+//according to the meas_hs_index in register VDIN_MEAS_CTRL0
+//meas_hs_index == 0, first hs range
+//meas_hs_index == 1, second hs range
+//meas_hs_index == 2, third hs range
+//meas_hs_index == 3, fourth hs range 
+//bit 28:16 count_start
+//bit 12:0 count_end
+#define VDIN_MEAS_HS_RANGE                         ((0x125d  << 2) + 0xd0100000)
+//Read only
+//according to the meas_hs_index in register VDIN_MEAS_CTRL0,
+//meas_hs_index == 0, first range hs counter,
+//meas_hs_index == 1, second range hs coutner
+//meas_hs_index == 2, third range hs coutner
+//meas_hs_index == 3, fourth range hs coutner
+//23:0
+#define VDIN_MEAS_HS_COUNT                         ((0x125e  << 2) + 0xd0100000)
+//Bit 8      white_enable
+//Bit 7:0    blkbar_white_level
+#define VDIN_BLKBAR_CTRL1                          ((0x125f  << 2) + 0xd0100000)
+// Bit 31:24 blkbar_black_level    threshold to judge a black point
+// Bit 23:21 Reserved
+// Bit 20:8  blkbar_hwidth         left and right region width
+// Bit 7:5   blkbar_comp_sel       select yin or uin or vin to be the valid input
+// Bit 4     blkbar_sw_statistic_en enable software statistic of each block black points number
+// Bit 3     blkbar_det_en       
+// Bit 2:1   blkbar_din_sel        
+// bit blkbar_det_top_en
+#define VDIN_BLKBAR_CTRL0                          ((0x1260  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_hstart.        Left region start
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_hend.          Right region end
+#define VDIN_BLKBAR_H_START_END                    ((0x1261  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_vstart        
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_vend
+#define VDIN_BLKBAR_V_START_END                    ((0x1262  << 2) + 0xd0100000)
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_cnt_threshold. threshold to judge whether a block is totally black  
+#define VDIN_BLKBAR_CNT_THRESHOLD                  ((0x1263  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_row_th1.       //threshold of the top blackbar
+// Bit 15:13 Reserved
+// bit 12:0  blkbar_row_th2        //threshold of the bottom blackbar
+#define VDIN_BLKBAR_ROW_TH1_TH2                    ((0x1264  << 2) + 0xd0100000)
+//Readonly
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_ind_left_start. horizontal start of the left region in the current searching
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_ind_left_end.   horizontal end of the left region in the current searching
+#define VDIN_BLKBAR_IND_LEFT_START_END             ((0x1265  << 2) + 0xd0100000)
+//Readonly
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_ind_right_start.horizontal start of the right region in the current searching
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_ind_right_end.  horizontal end of the right region in the current searching
+#define VDIN_BLKBAR_IND_RIGHT_START_END            ((0x1266  << 2) + 0xd0100000)
+//Readonly
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_ind_left1_cnt.  Black pixel counter. left part of the left region
+#define VDIN_BLKBAR_IND_LEFT1_CNT                  ((0x1267  << 2) + 0xd0100000)
+//Readonly
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_ind_left2_cnt.  Black pixel counter. right part of the left region
+#define VDIN_BLKBAR_IND_LEFT2_CNT                  ((0x1268  << 2) + 0xd0100000)
+//Readonly
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_ind_right1_cnt. Black pixel counter. left part of the right region
+#define VDIN_BLKBAR_IND_RIGHT1_CNT                 ((0x1269  << 2) + 0xd0100000)
+//Readonly
+// Bit 31:20 Reserved
+// Bit 19:0  blkbar_ind_right2_cnt. Black pixel counter. right part of the right region
+#define VDIN_BLKBAR_IND_RIGHT2_CNT                 ((0x126a  << 2) + 0xd0100000)
+//Readonly
+// Bit 31:30 Resersed
+// Bit 29    blkbar_ind_black_det_done. LEFT/RIGHT Black detection done
+// Bit 28:16 blkbar_top_pos.            Top black bar position
+// Bit 15:13 Reserved.
+// Bit 12:0  blkbar_bot_pos.            Bottom black bar position
+#define VDIN_BLKBAR_STATUS0                        ((0x126b  << 2) + 0xd0100000)
+//Readonly
+// Bit 31:29 Reserved
+// Bit 28:16 blkbar_left_pos.       Left black bar posiont
+// Bit 15:13 Reserved
+// Bit 12:0  blkbar_right_pos.      Right black bar position
+#define VDIN_BLKBAR_STATUS1                        ((0x126c  << 2) + 0xd0100000)
+//Bit 28:16 input window H start
+//Bit 12:0  input window H end
+#define VDIN_WIN_H_START_END                       ((0x126d  << 2) + 0xd0100000)
+//Bit 28:16 input window H start
+//Bit 12:0  input window V start
+#define VDIN_WIN_V_START_END                       ((0x126e  << 2) + 0xd0100000)
+//Bit 23:16 vdi8 asfifo_ctrl 
+//Bit 15:8 vdi7 asfifo_ctrl 
+//Bit 7:0 vdi6 asfifo_ctrl 
+#define VDIN_ASFIFO_CTRL3                          ((0x126f  << 2) + 0xd0100000)
+
+//VDIN0        8'h00 - 8'h7f
+#define VDIN0_SCALE_COEF_IDX                    ((VDIN0_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
+#define VDIN0_SCALE_COEF                        ((VDIN0_OFFSET << 2) + VDIN_SCALE_COEF                   )
+#define VDIN0_COM_CTRL0                         ((VDIN0_OFFSET << 2) + VDIN_COM_CTRL0                    )
+#define VDIN0_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN0_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
+#define VDIN0_LCNT_STATUS                       ((VDIN0_OFFSET << 2) + VDIN_LCNT_STATUS                  )
+#define VDIN0_COM_STATUS0                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS0                  )
+#define VDIN0_COM_STATUS1                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS1                  )
+#define VDIN0_LCNT_SHADOW_STATUS                ((VDIN0_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
+#define VDIN0_ASFIFO_CTRL0                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
+#define VDIN0_ASFIFO_CTRL1                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
+#define VDIN0_WIDTHM1I_WIDTHM1O                 ((VDIN0_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
+#define VDIN0_SC_MISC_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
+#define VDIN0_HSC_PHASE_STEP                    ((VDIN0_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
+#define VDIN0_HSC_INI_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
+#define VDIN0_COM_STATUS2                       ((VDIN0_OFFSET << 2) + VDIN_COM_STATUS2                  )
+#define VDIN0_ASFIFO_CTRL2                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
+#define VDIN0_MATRIX_CTRL                       ((VDIN0_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
+#define VDIN0_MATRIX_COEF00_01                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
+#define VDIN0_MATRIX_COEF02_10                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
+#define VDIN0_MATRIX_COEF11_12                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
+#define VDIN0_MATRIX_COEF20_21                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
+#define VDIN0_MATRIX_COEF22                     ((VDIN0_OFFSET << 2) + VDIN_MATRIX_COEF22                )
+#define VDIN0_MATRIX_OFFSET0_1                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
+#define VDIN0_MATRIX_OFFSET2                    ((VDIN0_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
+#define VDIN0_MATRIX_PRE_OFFSET0_1              ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
+#define VDIN0_MATRIX_PRE_OFFSET2                ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
+#define VDIN0_LFIFO_CTRL                        ((VDIN0_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
+#define VDIN0_COM_GCLK_CTRL                     ((VDIN0_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
+#define VDIN0_INTF_WIDTHM1                      ((VDIN0_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
+#define VDIN0_WR_CTRL2                          ((VDIN0_OFFSET << 2) + VDIN_WR_CTRL2                     )
+#define VDIN0_WR_CTRL                           ((VDIN0_OFFSET << 2) + VDIN_WR_CTRL                      )
+#define VDIN0_WR_H_START_END                    ((VDIN0_OFFSET << 2) + VDIN_WR_H_START_END               )
+#define VDIN0_WR_V_START_END                    ((VDIN0_OFFSET << 2) + VDIN_WR_V_START_END               )
+#define VDIN0_VSC_PHASE_STEP                    ((VDIN0_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
+#define VDIN0_VSC_INI_CTRL                      ((VDIN0_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
+#define VDIN0_SCIN_HEIGHTM1                     ((VDIN0_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
+#define VDIN0_DUMMY_DATA                        ((VDIN0_OFFSET << 2) + VDIN_DUMMY_DATA                   )
+#define VDIN0_MATRIX_PROBE_COLOR                ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
+#define VDIN0_MATRIX_HL_COLOR                   ((VDIN0_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
+#define VDIN0_MATRIX_PROBE_POS                  ((VDIN0_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
+#define VDIN0_CHROMA_ADDR_PORT                  ((VDIN0_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
+#define VDIN0_CHROMA_DATA_PORT                  ((VDIN0_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
+#define VDIN0_CM_BRI_CON_CTRL                   ((VDIN0_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
+#define VDIN0_HIST_CTRL                         ((VDIN0_OFFSET << 2) + VDIN_HIST_CTRL                    )
+#define VDIN0_HIST_H_START_END                  ((VDIN0_OFFSET << 2) + VDIN_HIST_H_START_END             )
+#define VDIN0_HIST_V_START_END                  ((VDIN0_OFFSET << 2) + VDIN_HIST_V_START_END             )
+#define VDIN0_HIST_MAX_MIN                      ((VDIN0_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
+#define VDIN0_HIST_SPL_VAL                      ((VDIN0_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
+#define VDIN0_HIST_SPL_PIX_CNT                  ((VDIN0_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
+#define VDIN0_HIST_CHROMA_SUM                   ((VDIN0_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
+#define VDIN0_DNLP_HIST00                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST00                  )
+#define VDIN0_DNLP_HIST01                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST01                  )
+#define VDIN0_DNLP_HIST02                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST02                  )
+#define VDIN0_DNLP_HIST03                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST03                  )
+#define VDIN0_DNLP_HIST04                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST04                  )
+#define VDIN0_DNLP_HIST05                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST05                  )
+#define VDIN0_DNLP_HIST06                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST06                  )
+#define VDIN0_DNLP_HIST07                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST07                  )
+#define VDIN0_DNLP_HIST08                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST08                  )
+#define VDIN0_DNLP_HIST09                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST09                  )
+#define VDIN0_DNLP_HIST10                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST10                  )
+#define VDIN0_DNLP_HIST11                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST11                  )
+#define VDIN0_DNLP_HIST12                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST12                  )
+#define VDIN0_DNLP_HIST13                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST13                  )
+#define VDIN0_DNLP_HIST14                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST14                  )
+#define VDIN0_DNLP_HIST15                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST15                  )
+#define VDIN0_DNLP_HIST16                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST16                  )
+#define VDIN0_DNLP_HIST17                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST17                  )
+#define VDIN0_DNLP_HIST18                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST18                  )
+#define VDIN0_DNLP_HIST19                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST19                  )
+#define VDIN0_DNLP_HIST20                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST20                  )
+#define VDIN0_DNLP_HIST21                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST21                  )
+#define VDIN0_DNLP_HIST22                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST22                  )
+#define VDIN0_DNLP_HIST23                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST23                  )
+#define VDIN0_DNLP_HIST24                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST24                  )
+#define VDIN0_DNLP_HIST25                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST25                  )
+#define VDIN0_DNLP_HIST26                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST26                  )
+#define VDIN0_DNLP_HIST27                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST27                  )
+#define VDIN0_DNLP_HIST28                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST28                  )
+#define VDIN0_DNLP_HIST29                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST29                  )
+#define VDIN0_DNLP_HIST30                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST30                  )
+#define VDIN0_DNLP_HIST31                       ((VDIN0_OFFSET << 2) + VDIN_DNLP_HIST31                  )
+#define VDIN0_LDIM_STTS_HIST_REGION_IDX         ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_REGION_IDX    )
+#define VDIN0_LDIM_STTS_HIST_SET_REGION         ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_SET_REGION    )
+#define VDIN0_LDIM_STTS_HIST_READ_REGION        ((VDIN0_OFFSET << 2) + VDIN_LDIM_STTS_HIST_READ_REGION   )
+#define VDIN0_MEAS_CTRL0                        ((VDIN0_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
+#define VDIN0_MEAS_VS_COUNT_HI                  ((VDIN0_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
+#define VDIN0_MEAS_VS_COUNT_LO                  ((VDIN0_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
+#define VDIN0_MEAS_HS_RANGE                     ((VDIN0_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
+#define VDIN0_MEAS_HS_COUNT                     ((VDIN0_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
+#define VDIN0_BLKBAR_CTRL1                      ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
+#define VDIN0_BLKBAR_CTRL0                      ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
+#define VDIN0_BLKBAR_H_START_END                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
+#define VDIN0_BLKBAR_V_START_END                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
+#define VDIN0_BLKBAR_CNT_THRESHOLD              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
+#define VDIN0_BLKBAR_ROW_TH1_TH2                ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
+#define VDIN0_BLKBAR_IND_LEFT_START_END         ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
+#define VDIN0_BLKBAR_IND_RIGHT_START_END        ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
+#define VDIN0_BLKBAR_IND_LEFT1_CNT              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
+#define VDIN0_BLKBAR_IND_LEFT2_CNT              ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
+#define VDIN0_BLKBAR_IND_RIGHT1_CNT             ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
+#define VDIN0_BLKBAR_IND_RIGHT2_CNT             ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
+#define VDIN0_BLKBAR_STATUS0                    ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
+#define VDIN0_BLKBAR_STATUS1                    ((VDIN0_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
+#define VDIN0_WIN_H_START_END                   ((VDIN0_OFFSET << 2) + VDIN_WIN_H_START_END              )
+#define VDIN0_WIN_V_START_END                   ((VDIN0_OFFSET << 2) + VDIN_WIN_V_START_END              )
+#define VDIN0_ASFIFO_CTRL3                      ((VDIN0_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )
+
+//VDIN1        8'h70 - 8'hdf
+#define VDIN1_SCALE_COEF_IDX                    ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
+#define VDIN1_SCALE_COEF                        ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF                   )
+#define VDIN1_COM_CTRL0                         ((VDIN1_OFFSET << 2) + VDIN_COM_CTRL0                    )
+#define VDIN1_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN1_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
+#define VDIN1_LCNT_STATUS                       ((VDIN1_OFFSET << 2) + VDIN_LCNT_STATUS                  )
+#define VDIN1_COM_STATUS0                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS0                  )
+#define VDIN1_COM_STATUS1                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS1                  )
+#define VDIN1_LCNT_SHADOW_STATUS                ((VDIN1_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
+#define VDIN1_ASFIFO_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
+#define VDIN1_ASFIFO_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
+#define VDIN1_WIDTHM1I_WIDTHM1O                 ((VDIN1_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
+#define VDIN1_SC_MISC_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
+#define VDIN1_HSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
+#define VDIN1_HSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
+#define VDIN1_COM_STATUS2                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS2                  )
+#define VDIN1_ASFIFO_CTRL2                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
+#define VDIN1_MATRIX_CTRL                       ((VDIN1_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
+#define VDIN1_MATRIX_COEF00_01                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
+#define VDIN1_MATRIX_COEF02_10                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
+#define VDIN1_MATRIX_COEF11_12                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
+#define VDIN1_MATRIX_COEF20_21                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
+#define VDIN1_MATRIX_COEF22                     ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF22                )
+#define VDIN1_MATRIX_OFFSET0_1                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
+#define VDIN1_MATRIX_OFFSET2                    ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
+#define VDIN1_MATRIX_PRE_OFFSET0_1              ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
+#define VDIN1_MATRIX_PRE_OFFSET2                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
+#define VDIN1_LFIFO_CTRL                        ((VDIN1_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
+#define VDIN1_COM_GCLK_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
+#define VDIN1_INTF_WIDTHM1                      ((VDIN1_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
+#define VDIN1_WR_CTRL2                          ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL2                     )
+#define VDIN1_WR_CTRL                           ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL                      )
+#define VDIN1_WR_H_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_H_START_END               )
+#define VDIN1_WR_V_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_V_START_END               )
+#define VDIN1_VSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
+#define VDIN1_VSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
+#define VDIN1_SCIN_HEIGHTM1                     ((VDIN1_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
+#define VDIN1_DUMMY_DATA                        ((VDIN1_OFFSET << 2) + VDIN_DUMMY_DATA                   )
+#define VDIN1_MATRIX_PROBE_COLOR                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
+#define VDIN1_MATRIX_HL_COLOR                   ((VDIN1_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
+#define VDIN1_MATRIX_PROBE_POS                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
+#define VDIN1_CHROMA_ADDR_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
+#define VDIN1_CHROMA_DATA_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
+#define VDIN1_CM_BRI_CON_CTRL                   ((VDIN1_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
+#define VDIN1_HIST_CTRL                         ((VDIN1_OFFSET << 2) + VDIN_HIST_CTRL                    )
+#define VDIN1_HIST_H_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_H_START_END             )
+#define VDIN1_HIST_V_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_V_START_END             )
+#define VDIN1_HIST_MAX_MIN                      ((VDIN1_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
+#define VDIN1_HIST_SPL_VAL                      ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
+#define VDIN1_HIST_SPL_PIX_CNT                  ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
+#define VDIN1_HIST_CHROMA_SUM                   ((VDIN1_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
+#define VDIN1_DNLP_HIST00                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST00                  )
+#define VDIN1_DNLP_HIST01                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST01                  )
+#define VDIN1_DNLP_HIST02                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST02                  )
+#define VDIN1_DNLP_HIST03                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST03                  )
+#define VDIN1_DNLP_HIST04                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST04                  )
+#define VDIN1_DNLP_HIST05                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST05                  )
+#define VDIN1_DNLP_HIST06                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST06                  )
+#define VDIN1_DNLP_HIST07                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST07                  )
+#define VDIN1_DNLP_HIST08                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST08                  )
+#define VDIN1_DNLP_HIST09                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST09                  )
+#define VDIN1_DNLP_HIST10                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST10                  )
+#define VDIN1_DNLP_HIST11                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST11                  )
+#define VDIN1_DNLP_HIST12                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST12                  )
+#define VDIN1_DNLP_HIST13                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST13                  )
+#define VDIN1_DNLP_HIST14                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST14                  )
+#define VDIN1_DNLP_HIST15                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST15                  )
+#define VDIN1_DNLP_HIST16                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST16                  )
+#define VDIN1_DNLP_HIST17                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST17                  )
+#define VDIN1_DNLP_HIST18                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST18                  )
+#define VDIN1_DNLP_HIST19                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST19                  )
+#define VDIN1_DNLP_HIST20                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST20                  )
+#define VDIN1_DNLP_HIST21                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST21                  )
+#define VDIN1_DNLP_HIST22                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST22                  )
+#define VDIN1_DNLP_HIST23                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST23                  )
+#define VDIN1_DNLP_HIST24                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST24                  )
+#define VDIN1_DNLP_HIST25                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST25                  )
+#define VDIN1_DNLP_HIST26                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST26                  )
+#define VDIN1_DNLP_HIST27                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST27                  )
+#define VDIN1_DNLP_HIST28                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST28                  )
+#define VDIN1_DNLP_HIST29                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST29                  )
+#define VDIN1_DNLP_HIST30                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST30                  )
+#define VDIN1_DNLP_HIST31                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST31                  )
+#define VDIN1_LDIM_STTS_HIST_REGION_IDX         ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_REGION_IDX    )
+#define VDIN1_LDIM_STTS_HIST_SET_REGION         ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_SET_REGION    )
+#define VDIN1_LDIM_STTS_HIST_READ_REGION        ((VDIN1_OFFSET << 2) + VDIN_LDIM_STTS_HIST_READ_REGION   )
+#define VDIN1_MEAS_CTRL0                        ((VDIN1_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
+#define VDIN1_MEAS_VS_COUNT_HI                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
+#define VDIN1_MEAS_VS_COUNT_LO                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
+#define VDIN1_MEAS_HS_RANGE                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
+#define VDIN1_MEAS_HS_COUNT                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
+#define VDIN1_BLKBAR_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
+#define VDIN1_BLKBAR_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
+#define VDIN1_BLKBAR_H_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
+#define VDIN1_BLKBAR_V_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
+#define VDIN1_BLKBAR_CNT_THRESHOLD              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
+#define VDIN1_BLKBAR_ROW_TH1_TH2                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
+#define VDIN1_BLKBAR_IND_LEFT_START_END         ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
+#define VDIN1_BLKBAR_IND_RIGHT_START_END        ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
+#define VDIN1_BLKBAR_IND_LEFT1_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
+#define VDIN1_BLKBAR_IND_LEFT2_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
+#define VDIN1_BLKBAR_IND_RIGHT1_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
+#define VDIN1_BLKBAR_IND_RIGHT2_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
+#define VDIN1_BLKBAR_STATUS0                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
+#define VDIN1_BLKBAR_STATUS1                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
+#define VDIN1_WIN_H_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_H_START_END              )
+#define VDIN1_WIN_V_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_V_START_END              )
+#define VDIN1_ASFIFO_CTRL3                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )
+
+//`define LCD_VCBUS_BASE               8'h14
+//
+// Reading file:  lcd_regs.h
+//
+// -----------------------------------------------
+// CBUS_BASE:  LCD_VCBUS_BASE = 0x14
+// -----------------------------------------------
+//========================================================================
+//LCD DRV     12'h480~12'h4ef
+//=======================================================================
+#define L_GAMMA_CNTL_PORT                          ((0x1400  << 2) + 0xd0100000)
+#define L_GAMMA_DATA_PORT                          ((0x1401  << 2) + 0xd0100000)
+#define L_GAMMA_ADDR_PORT                          ((0x1402  << 2) + 0xd0100000)
+#define L_GAMMA_VCOM_HSWITCH_ADDR                  ((0x1403  << 2) + 0xd0100000)
+#define L_RGB_BASE_ADDR                            ((0x1405  << 2) + 0xd0100000)
+#define L_RGB_COEFF_ADDR                           ((0x1406  << 2) + 0xd0100000)
+#define L_POL_CNTL_ADDR                            ((0x1407  << 2) + 0xd0100000)
+#define L_DITH_CNTL_ADDR                           ((0x1408  << 2) + 0xd0100000)
+#define L_GAMMA_PROBE_CTRL                         ((0x1409  << 2) + 0xd0100000)
+//read only
+#define L_GAMMA_PROBE_COLOR_L                      ((0x140a  << 2) + 0xd0100000)
+#define L_GAMMA_PROBE_COLOR_H                      ((0x140b  << 2) + 0xd0100000)
+#define L_GAMMA_PROBE_HL_COLOR                     ((0x140c  << 2) + 0xd0100000)
+#define L_GAMMA_PROBE_POS_X                        ((0x140d  << 2) + 0xd0100000)
+#define L_GAMMA_PROBE_POS_Y                        ((0x140e  << 2) + 0xd0100000)
+#define L_STH1_HS_ADDR                             ((0x1410  << 2) + 0xd0100000)
+#define L_STH1_HE_ADDR                             ((0x1411  << 2) + 0xd0100000)
+#define L_STH1_VS_ADDR                             ((0x1412  << 2) + 0xd0100000)
+#define L_STH1_VE_ADDR                             ((0x1413  << 2) + 0xd0100000)
+#define L_STH2_HS_ADDR                             ((0x1414  << 2) + 0xd0100000)
+#define L_STH2_HE_ADDR                             ((0x1415  << 2) + 0xd0100000)
+#define L_STH2_VS_ADDR                             ((0x1416  << 2) + 0xd0100000)
+#define L_STH2_VE_ADDR                             ((0x1417  << 2) + 0xd0100000)
+#define L_OEH_HS_ADDR                              ((0x1418  << 2) + 0xd0100000)
+#define L_OEH_HE_ADDR                              ((0x1419  << 2) + 0xd0100000)
+#define L_OEH_VS_ADDR                              ((0x141a  << 2) + 0xd0100000)
+#define L_OEH_VE_ADDR                              ((0x141b  << 2) + 0xd0100000)
+#define L_VCOM_HSWITCH_ADDR                        ((0x141c  << 2) + 0xd0100000)
+#define L_VCOM_VS_ADDR                             ((0x141d  << 2) + 0xd0100000)
+#define L_VCOM_VE_ADDR                             ((0x141e  << 2) + 0xd0100000)
+#define L_CPV1_HS_ADDR                             ((0x141f  << 2) + 0xd0100000)
+#define L_CPV1_HE_ADDR                             ((0x1420  << 2) + 0xd0100000)
+#define L_CPV1_VS_ADDR                             ((0x1421  << 2) + 0xd0100000)
+#define L_CPV1_VE_ADDR                             ((0x1422  << 2) + 0xd0100000)
+#define L_CPV2_HS_ADDR                             ((0x1423  << 2) + 0xd0100000)
+#define L_CPV2_HE_ADDR                             ((0x1424  << 2) + 0xd0100000)
+#define L_CPV2_VS_ADDR                             ((0x1425  << 2) + 0xd0100000)
+#define L_CPV2_VE_ADDR                             ((0x1426  << 2) + 0xd0100000)
+#define L_STV1_HS_ADDR                             ((0x1427  << 2) + 0xd0100000)
+#define L_STV1_HE_ADDR                             ((0x1428  << 2) + 0xd0100000)
+#define L_STV1_VS_ADDR                             ((0x1429  << 2) + 0xd0100000)
+#define L_STV1_VE_ADDR                             ((0x142a  << 2) + 0xd0100000)
+#define L_STV2_HS_ADDR                             ((0x142b  << 2) + 0xd0100000)
+#define L_STV2_HE_ADDR                             ((0x142c  << 2) + 0xd0100000)
+#define L_STV2_VS_ADDR                             ((0x142d  << 2) + 0xd0100000)
+#define L_STV2_VE_ADDR                             ((0x142e  << 2) + 0xd0100000)
+#define L_OEV1_HS_ADDR                             ((0x142f  << 2) + 0xd0100000)
+#define L_OEV1_HE_ADDR                             ((0x1430  << 2) + 0xd0100000)
+#define L_OEV1_VS_ADDR                             ((0x1431  << 2) + 0xd0100000)
+#define L_OEV1_VE_ADDR                             ((0x1432  << 2) + 0xd0100000)
+#define L_OEV2_HS_ADDR                             ((0x1433  << 2) + 0xd0100000)
+#define L_OEV2_HE_ADDR                             ((0x1434  << 2) + 0xd0100000)
+#define L_OEV2_VS_ADDR                             ((0x1435  << 2) + 0xd0100000)
+#define L_OEV2_VE_ADDR                             ((0x1436  << 2) + 0xd0100000)
+#define L_OEV3_HS_ADDR                             ((0x1437  << 2) + 0xd0100000)
+#define L_OEV3_HE_ADDR                             ((0x1438  << 2) + 0xd0100000)
+#define L_OEV3_VS_ADDR                             ((0x1439  << 2) + 0xd0100000)
+#define L_OEV3_VE_ADDR                             ((0x143a  << 2) + 0xd0100000)
+#define L_LCD_PWR_ADDR                             ((0x143b  << 2) + 0xd0100000)
+#define L_LCD_PWM0_LO_ADDR                         ((0x143c  << 2) + 0xd0100000)
+#define L_LCD_PWM0_HI_ADDR                         ((0x143d  << 2) + 0xd0100000)
+#define L_LCD_PWM1_LO_ADDR                         ((0x143e  << 2) + 0xd0100000)
+#define L_LCD_PWM1_HI_ADDR                         ((0x143f  << 2) + 0xd0100000)
+#define L_INV_CNT_ADDR                             ((0x1440  << 2) + 0xd0100000)
+#define L_TCON_MISC_SEL_ADDR                       ((0x1441  << 2) + 0xd0100000)
+#define L_DUAL_PORT_CNTL_ADDR                      ((0x1442  << 2) + 0xd0100000)
+#define MLVDS_CLK_CTL1_HI                          ((0x1443  << 2) + 0xd0100000)
+#define MLVDS_CLK_CTL1_LO                          ((0x1444  << 2) + 0xd0100000)
+//  [31:30] enable mlvds clocks
+//  [24]    mlvds_clk_half_delay       24 // Bit 0
+//  [23:0]  mlvds_clk_pattern           0 // Bit 23:0
+#define L_TCON_DOUBLE_CTL                          ((0x1449  << 2) + 0xd0100000)
+#define L_TCON_PATTERN_HI                          ((0x144a  << 2) + 0xd0100000)
+#define L_TCON_PATTERN_LO                          ((0x144b  << 2) + 0xd0100000)
+#define LDIM_BL_ADDR_PORT                          ((0x144e  << 2) + 0xd0100000)
+#define LDIM_BL_DATA_PORT                          ((0x144f  << 2) + 0xd0100000)
+#define L_DE_HS_ADDR                               ((0x1451  << 2) + 0xd0100000)
+#define L_DE_HE_ADDR                               ((0x1452  << 2) + 0xd0100000)
+#define L_DE_VS_ADDR                               ((0x1453  << 2) + 0xd0100000)
+#define L_DE_VE_ADDR                               ((0x1454  << 2) + 0xd0100000)
+#define L_HSYNC_HS_ADDR                            ((0x1455  << 2) + 0xd0100000)
+#define L_HSYNC_HE_ADDR                            ((0x1456  << 2) + 0xd0100000)
+#define L_HSYNC_VS_ADDR                            ((0x1457  << 2) + 0xd0100000)
+#define L_HSYNC_VE_ADDR                            ((0x1458  << 2) + 0xd0100000)
+#define L_VSYNC_HS_ADDR                            ((0x1459  << 2) + 0xd0100000)
+#define L_VSYNC_HE_ADDR                            ((0x145a  << 2) + 0xd0100000)
+#define L_VSYNC_VS_ADDR                            ((0x145b  << 2) + 0xd0100000)
+#define L_VSYNC_VE_ADDR                            ((0x145c  << 2) + 0xd0100000)
+// bit 8 -- vfifo_mcu_enable
+// bit 7 -- halt_vs_de
+// bit 6 -- R8G8B8_format
+// bit 5 -- R6G6B6_format (round to 6 bits)
+// bit 4 -- R5G6B5_format
+// bit 3 -- dac_dith_sel
+// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
+// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
+// bit 0 -- lcd_mcu_enable
+#define L_LCD_MCU_CTL                              ((0x145d  << 2) + 0xd0100000)
+//**************************************************************************
+//*  Dual port mLVDS registers
+//**************************************************************************
+// bit 3 - enable_u_dual_mlvds_dp_clk
+// bit 2 - enable_u_map_mlvds_r_clk
+// bit 1 - enable_u_map_mlvds_l_clk
+// bit 0 - dual_mlvds_en
+//`define DUAL_MLVDS_CTL                8'h60  
+// bit[12:0] - dual_mlvds_line_start 
+//`define DUAL_MLVDS_LINE_START         8'h61 
+// bit[12:0] - dual_mlvds_line_end 
+//`define DUAL_MLVDS_LINE_END           8'h62 
+// bit[12:0] - dual_mlvds_w_pixel_start_l 
+//`define DUAL_MLVDS_PIXEL_W_START_L    8'h63 
+// bit[12:0] - dual_mlvds_w_pixel_end_l 
+//`define DUAL_MLVDS_PIXEL_W_END_L      8'h64 
+// bit[12:0] - dual_mlvds_w_pixel_start_r 
+//`define DUAL_MLVDS_PIXEL_W_START_R    8'h65 
+// bit[12:0] - dual_mlvds_w_pixel_end_r 
+//`define DUAL_MLVDS_PIXEL_W_END_R      8'h66 
+// bit[12:0] - dual_mlvds_r_pixel_start_l 
+//`define DUAL_MLVDS_PIXEL_R_START_L    8'h67 
+// bit[12:0] - dual_mlvds_r_pixel_cnt_l 
+//`define DUAL_MLVDS_PIXEL_R_CNT_L      8'h68 
+// bit[12:0] - dual_mlvds_r_pixel_start_r 
+//`define DUAL_MLVDS_PIXEL_R_START_R    8'h69 
+// bit[12:0] - dual_mlvds_r_pixel_cnt_r 
+//`define DUAL_MLVDS_PIXEL_R_CNT_R      8'h6a
+// bit[15]   - v_inversion_en
+// bit[12:0] - v_inversion_pixel
+//`define V_INVERSION_PIXEL             8'h70
+// bit[15]   - v_inversion_sync_en
+// bit[12:0] - v_inversion_line 
+//`define V_INVERSION_LINE              8'h71
+// bit[15:12]  - v_loop_r
+// bit[11:10]  - v_pattern_1_r
+// bit[9:8]    - v_pattern_0_r
+// bit[7:4]    - v_loop_l
+// bit[3:2]    - v_pattern_1_l
+// bit[1:0]    - v_pattern_0_l
+//`define V_INVERSION_CONTROL           8'h72
+//`define MLVDS2_CONTROL           8'h74
+   #define     mLVDS2_RESERVED  15    // 15
+   #define     mLVDS2_double_pattern  14    // 14
+   #define     mLVDS2_ins_reset  8    // 13:8  // each channel has one bit
+   #define     mLVDS2_dual_gate  7
+   #define     mLVDS2_bit_num    6    // 0-6Bits, 1-8Bits
+   #define     mLVDS2_pair_num   5    // 0-3Pairs, 1-6Pairs
+   #define     mLVDS2_msb_first  4
+   #define     mLVDS2_PORT_SWAP  3
+   #define     mLVDS2_MLSB_SWAP  2
+   #define     mLVDS2_PN_SWAP    1
+   #define     mLVDS2_en         0
+//`define MLVDS2_CONFIG_HI         8'h75
+//`define MLVDS2_CONFIG_LO         8'h76
+   #define     mLVDS2_reset_offset         29 // Bit 31:29 
+   #define     mLVDS2_reset_length         23 // Bit 28:23
+   #define     mLVDS2_config_reserved      20 // Bit 22:20
+   #define     mLVDS2_reset_start_bit12    19 // Bit 19
+   #define     mLVDS2_data_write_toggle    18
+   #define     mLVDS2_data_write_ini       17
+   #define     mLVDS2_data_latch_1_toggle  16
+   #define     mLVDS2_data_latch_1_ini     15
+   #define     mLVDS2_data_latch_0_toggle  14
+   #define     mLVDS2_data_latch_0_ini     13
+   #define     mLVDS2_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
+   #define     mLVDS2_reset_start           0 // Bit 11:0
+#define MLVDS2_DUAL_GATE_WR_START                  ((0x1477  << 2) + 0xd0100000)
+   #define     mlvds2_dual_gate_wr_start    0 // Bit 12:0
+#define MLVDS2_DUAL_GATE_WR_END                    ((0x1478  << 2) + 0xd0100000)
+   #define     mlvds2_dual_gate_wr_end      0 // Bit 12:0
+#define MLVDS2_DUAL_GATE_RD_START                  ((0x1479  << 2) + 0xd0100000)
+   #define     mlvds2_dual_gate_rd_start    0 // Bit 12:0
+#define MLVDS2_DUAL_GATE_RD_END                    ((0x147a  << 2) + 0xd0100000)
+   #define     mlvds2_dual_gate_rd_end      0 // Bit 12:0
+#define MLVDS2_SECOND_RESET_CTL                    ((0x147b  << 2) + 0xd0100000)
+   #define     mLVDS2_2nd_reset_start       0 // Bit 12:0
+#define MLVDS2_DUAL_GATE_CTL_HI                    ((0x147c  << 2) + 0xd0100000)
+#define MLVDS2_DUAL_GATE_CTL_LO                    ((0x147d  << 2) + 0xd0100000)
+   #define     mlvds2_tcon_field_en        24 // Bit 7:0
+   #define     mlvds2_dual_gate_reserved   21 // Bit 2:0
+   #define     mlvds2_scan_mode_start_line_bit12 20 // Bit 0
+   #define     mlvds2_scan_mode_odd        16 // Bit 3:0
+   #define     mlvds2_scan_mode_even       12 // Bit 3:0
+   #define     mlvds2_scan_mode_start_line  0 // Bit 11:0
+#define MLVDS2_RESET_CONFIG_HI                     ((0x147e  << 2) + 0xd0100000)
+#define MLVDS2_RESET_CONFIG_LO                     ((0x147f  << 2) + 0xd0100000)
+   #define     mLVDS2_reset_range_enable   31 // Bit 0
+   #define     mLVDS2_reset_range_inv      30 // Bit 0
+   #define     mLVDS2_reset_config_res1    29 // Bit 0
+   #define     mLVDS2_reset_range_line_0   16 // Bit 11:0
+   #define     mLVDS2_reset_config_res3    13 // Bit 2:0
+   #define     mLVDS2_reset_range_line_1    0 // Bit 11:0
+//
+//**************************************************************************
+//*  Vbyone registers  (Note: no MinLVDS in G9tv, share the register)
+//**************************************************************************
+#define VBO_CTRL_L                                 ((0x1460  << 2) + 0xd0100000)
+#define VBO_CTRL_H                                 ((0x1461  << 2) + 0xd0100000)
+#define VBO_SOFT_RST                               ((0x1462  << 2) + 0xd0100000)
+#define VBO_LANES                                  ((0x1463  << 2) + 0xd0100000)
+#define VBO_VIN_CTRL                               ((0x1464  << 2) + 0xd0100000)
+#define VBO_ACT_VSIZE                              ((0x1465  << 2) + 0xd0100000)
+#define VBO_REGION_00                              ((0x1466  << 2) + 0xd0100000)
+#define VBO_REGION_01                              ((0x1467  << 2) + 0xd0100000)
+#define VBO_REGION_02                              ((0x1468  << 2) + 0xd0100000)
+#define VBO_REGION_03                              ((0x1469  << 2) + 0xd0100000)
+#define VBO_VBK_CTRL_0                             ((0x146a  << 2) + 0xd0100000)
+#define VBO_VBK_CTRL_1                             ((0x146b  << 2) + 0xd0100000)
+#define VBO_HBK_CTRL                               ((0x146c  << 2) + 0xd0100000)
+#define VBO_PXL_CTRL                               ((0x146d  << 2) + 0xd0100000)
+#define VBO_LANE_SKEW_L                            ((0x146e  << 2) + 0xd0100000)
+#define VBO_LANE_SKEW_H                            ((0x146f  << 2) + 0xd0100000)
+#define VBO_GCLK_LANE_L                            ((0x1470  << 2) + 0xd0100000)
+#define VBO_GCLK_LANE_H                            ((0x1471  << 2) + 0xd0100000)
+#define VBO_GCLK_MAIN                              ((0x1472  << 2) + 0xd0100000)
+#define VBO_STATUS_L                               ((0x1473  << 2) + 0xd0100000)
+#define VBO_STATUS_H                               ((0x1474  << 2) + 0xd0100000)
+#define VBO_LANE_OUTPUT                            ((0x1475  << 2) + 0xd0100000)
+#define LCD_PORT_SWAP                              ((0x1476  << 2) + 0xd0100000)
+//**************************************************************************
+//*  NOTE::    When Programming the Gamma, please turn off the IRQ service *
+//**************************************************************************
+#define GAMMA_CNTL_PORT                            ((0x1480  << 2) + 0xd0100000)
+   #define  GAMMA_VCOM_POL    7     //RW
+   #define  GAMMA_RVS_OUT     6     //RW
+   #define  ADR_RDY           5     //Read Only
+   #define  WR_RDY            4     //Read Only
+   #define  RD_RDY            3     //Read Only
+   #define  GAMMA_TR          2     //RW
+   #define  GAMMA_SET         1     //RW
+   #define  GAMMA_EN          0     //RW
+#define GAMMA_DATA_PORT                            ((0x1481  << 2) + 0xd0100000)
+#define GAMMA_ADDR_PORT                            ((0x1482  << 2) + 0xd0100000)
+   #define  H_RD              12
+   #define  H_AUTO_INC        11
+   #define  H_SEL_R           10
+   #define  H_SEL_G           9
+   #define  H_SEL_B           8
+   #define  HADR_MSB          7            //7:0
+   #define  HADR              0            //7:0
+#define GAMMA_VCOM_HSWITCH_ADDR                    ((0x1483  << 2) + 0xd0100000)
+#define RGB_BASE_ADDR                              ((0x1485  << 2) + 0xd0100000)
+#define RGB_COEFF_ADDR                             ((0x1486  << 2) + 0xd0100000)
+#define POL_CNTL_ADDR                              ((0x1487  << 2) + 0xd0100000)
+   #define   DCLK_SEL             14    //FOR DCLK OUTPUT
+   #define   TCON_VSYNC_SEL_DVI   11    //FOR RGB format DVI output
+   #define   TCON_HSYNC_SEL_DVI   10    //FOR RGB format DVI output
+   #define   TCON_DE_SEL_DVI      9     //FOR RGB format DVI output
+   #define   CPH3_POL         8
+   #define   CPH2_POL         7
+   #define   CPH1_POL         6
+   #define   TCON_DE_SEL      5
+   #define   TCON_VS_SEL      4
+   #define   TCON_HS_SEL      3
+   #define   DE_POL           2
+   #define   VS_POL           1
+   #define   HS_POL           0
+#define DITH_CNTL_ADDR                             ((0x1488  << 2) + 0xd0100000)
+   #define  DITH10_EN         10
+   #define  DITH8_EN          9
+   #define  DITH_MD           8
+   #define  DITH10_CNTL_MSB   7          //7:4
+   #define  DITH10_CNTL       4          //7:4
+   #define  DITH8_CNTL_MSB    3          //3:0
+   #define  DITH8_CNTL        0          //3:0
+//Bit 1 highlight_en 
+//Bit 0 probe_en
+#define GAMMA_PROBE_CTRL                           ((0x1489  << 2) + 0xd0100000)
+//read only
+//Bit [15:0]  probe_color[15:0]
+#define GAMMA_PROBE_COLOR_L                        ((0x148a  << 2) + 0xd0100000)
+//Read only
+//Bit 15: if true valid probed color
+//Bit [13:0]  probe_color[29:16]
+#define GAMMA_PROBE_COLOR_H                        ((0x148b  << 2) + 0xd0100000)
+//bit 15:0, 5:6:5 color
+#define GAMMA_PROBE_HL_COLOR                       ((0x148c  << 2) + 0xd0100000)
+//12:0 pos_x
+#define GAMMA_PROBE_POS_X                          ((0x148d  << 2) + 0xd0100000)
+//12:0 pos_y
+#define GAMMA_PROBE_POS_Y                          ((0x148e  << 2) + 0xd0100000)
+#define STH1_HS_ADDR                               ((0x1490  << 2) + 0xd0100000)
+#define STH1_HE_ADDR                               ((0x1491  << 2) + 0xd0100000)
+#define STH1_VS_ADDR                               ((0x1492  << 2) + 0xd0100000)
+#define STH1_VE_ADDR                               ((0x1493  << 2) + 0xd0100000)
+#define STH2_HS_ADDR                               ((0x1494  << 2) + 0xd0100000)
+#define STH2_HE_ADDR                               ((0x1495  << 2) + 0xd0100000)
+#define STH2_VS_ADDR                               ((0x1496  << 2) + 0xd0100000)
+#define STH2_VE_ADDR                               ((0x1497  << 2) + 0xd0100000)
+#define OEH_HS_ADDR                                ((0x1498  << 2) + 0xd0100000)
+#define OEH_HE_ADDR                                ((0x1499  << 2) + 0xd0100000)
+#define OEH_VS_ADDR                                ((0x149a  << 2) + 0xd0100000)
+#define OEH_VE_ADDR                                ((0x149b  << 2) + 0xd0100000)
+#define VCOM_HSWITCH_ADDR                          ((0x149c  << 2) + 0xd0100000)
+#define VCOM_VS_ADDR                               ((0x149d  << 2) + 0xd0100000)
+#define VCOM_VE_ADDR                               ((0x149e  << 2) + 0xd0100000)
+#define CPV1_HS_ADDR                               ((0x149f  << 2) + 0xd0100000)
+#define CPV1_HE_ADDR                               ((0x14a0  << 2) + 0xd0100000)
+#define CPV1_VS_ADDR                               ((0x14a1  << 2) + 0xd0100000)
+#define CPV1_VE_ADDR                               ((0x14a2  << 2) + 0xd0100000)
+#define CPV2_HS_ADDR                               ((0x14a3  << 2) + 0xd0100000)
+#define CPV2_HE_ADDR                               ((0x14a4  << 2) + 0xd0100000)
+#define CPV2_VS_ADDR                               ((0x14a5  << 2) + 0xd0100000)
+#define CPV2_VE_ADDR                               ((0x14a6  << 2) + 0xd0100000)
+#define STV1_HS_ADDR                               ((0x14a7  << 2) + 0xd0100000)
+#define STV1_HE_ADDR                               ((0x14a8  << 2) + 0xd0100000)
+#define STV1_VS_ADDR                               ((0x14a9  << 2) + 0xd0100000)
+#define STV1_VE_ADDR                               ((0x14aa  << 2) + 0xd0100000)
+#define STV2_HS_ADDR                               ((0x14ab  << 2) + 0xd0100000)
+#define STV2_HE_ADDR                               ((0x14ac  << 2) + 0xd0100000)
+#define STV2_VS_ADDR                               ((0x14ad  << 2) + 0xd0100000)
+#define STV2_VE_ADDR                               ((0x14ae  << 2) + 0xd0100000)
+#define OEV1_HS_ADDR                               ((0x14af  << 2) + 0xd0100000)
+#define OEV1_HE_ADDR                               ((0x14b0  << 2) + 0xd0100000)
+#define OEV1_VS_ADDR                               ((0x14b1  << 2) + 0xd0100000)
+#define OEV1_VE_ADDR                               ((0x14b2  << 2) + 0xd0100000)
+#define OEV2_HS_ADDR                               ((0x14b3  << 2) + 0xd0100000)
+#define OEV2_HE_ADDR                               ((0x14b4  << 2) + 0xd0100000)
+#define OEV2_VS_ADDR                               ((0x14b5  << 2) + 0xd0100000)
+#define OEV2_VE_ADDR                               ((0x14b6  << 2) + 0xd0100000)
+#define OEV3_HS_ADDR                               ((0x14b7  << 2) + 0xd0100000)
+#define OEV3_HE_ADDR                               ((0x14b8  << 2) + 0xd0100000)
+#define OEV3_VS_ADDR                               ((0x14b9  << 2) + 0xd0100000)
+#define OEV3_VE_ADDR                               ((0x14ba  << 2) + 0xd0100000)
+#define LCD_PWR_ADDR                               ((0x14bb  << 2) + 0xd0100000)
+   #define      LCD_VDD        5
+   #define      LCD_VBL        4
+   #define      LCD_GPI_MSB    3
+   #define      LCD_GPIO       0
+#define LCD_PWM0_LO_ADDR                           ((0x14bc  << 2) + 0xd0100000)
+#define LCD_PWM0_HI_ADDR                           ((0x14bd  << 2) + 0xd0100000)
+#define LCD_PWM1_LO_ADDR                           ((0x14be  << 2) + 0xd0100000)
+#define LCD_PWM1_HI_ADDR                           ((0x14bf  << 2) + 0xd0100000)
+#define INV_CNT_ADDR                               ((0x14c0  << 2) + 0xd0100000)
+   #define     INV_EN          4
+   #define     INV_CNT_MSB     3
+   #define     INV_CNT         0
+#define TCON_MISC_SEL_ADDR                         ((0x14c1  << 2) + 0xd0100000)
+   #define     STH2_SEL        12
+   #define     STH1_SEL        11
+   #define     OEH_SEL         10
+   #define     VCOM_SEL         9
+   #define     DB_LINE_SW       8
+   #define     CPV2_SEL         7
+   #define     CPV1_SEL         6
+   #define     STV2_SEL         5
+   #define     STV1_SEL         4
+   #define     OEV_UNITE        3
+   #define     OEV3_SEL         2
+   #define     OEV2_SEL         1
+   #define     OEV1_SEL         0
+#define DUAL_PORT_CNTL_ADDR                        ((0x14c2  << 2) + 0xd0100000)
+   #define     OUTPUT_YUV       15
+   #define     DUAL_IDF         12   // 14:12
+   #define     DUAL_ISF         9    // 11:9
+   #define     LCD_ANALOG_SEL_CPH3   8
+   #define     LCD_ANALOG_3PHI_CLK_SEL   7
+   #define     LCD_LVDS_SEL54   6
+   #define     LCD_LVDS_SEL27   5
+   #define     LCD_TTL_SEL      4
+   #define     DUAL_LVDC_EN     3
+   #define     PORT_SWP         2
+   #define     RGB_SWP          1
+   #define     BIT_SWP          0
+#define MLVDS_CONTROL                              ((0x14c3  << 2) + 0xd0100000)
+   #define     mLVDS_RESERVED  15    // 15
+   #define     mLVDS_double_pattern  14    // 14
+   #define     mLVDS_ins_reset  8    // 13:8  // each channel has one bit
+   #define     mLVDS_dual_gate  7
+   #define     mLVDS_bit_num    6    // 0-6Bits, 1-8Bits
+   #define     mLVDS_pair_num   5    // 0-3Pairs, 1-6Pairs
+   #define     mLVDS_msb_first  4
+   #define     mLVDS_PORT_SWAP  3
+   #define     mLVDS_MLSB_SWAP  2
+   #define     mLVDS_PN_SWAP    1
+   #define     mLVDS_en         0
+#define MLVDS_RESET_PATTERN_HI                     ((0x14c4  << 2) + 0xd0100000)
+#define MLVDS_RESET_PATTERN_LO                     ((0x14c5  << 2) + 0xd0100000)
+   #define     mLVDS_reset_pattern  0 // Bit 47:16
+#define MLVDS_RESET_PATTERN_EXT                    ((0x14c6  << 2) + 0xd0100000)
+   #define     mLVDS_reset_pattern_ext  0 // Bit 15:0
+#define MLVDS_CONFIG_HI                            ((0x14c7  << 2) + 0xd0100000)
+#define MLVDS_CONFIG_LO                            ((0x14c8  << 2) + 0xd0100000)
+   #define     mLVDS_reset_offset         29 // Bit 31:29 
+   #define     mLVDS_reset_length         23 // Bit 28:23
+   #define     mLVDS_config_reserved      20 // Bit 22:20
+   #define     mLVDS_reset_start_bit12    19 // Bit 19
+   #define     mLVDS_data_write_toggle    18
+   #define     mLVDS_data_write_ini       17
+   #define     mLVDS_data_latch_1_toggle  16
+   #define     mLVDS_data_latch_1_ini     15
+   #define     mLVDS_data_latch_0_toggle  14
+   #define     mLVDS_data_latch_0_ini     13
+   #define     mLVDS_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
+   #define     mLVDS_reset_start           0 // Bit 11:0
+#define TCON_DOUBLE_CTL                            ((0x14c9  << 2) + 0xd0100000)
+   #define     tcon_double_ini          8 // Bit 7:0
+   #define     tcon_double_inv          0 // Bit 7:0
+#define TCON_PATTERN_HI                            ((0x14ca  << 2) + 0xd0100000)
+#define TCON_PATTERN_LO                            ((0x14cb  << 2) + 0xd0100000)
+   #define     tcon_pattern_loop_data     16 // Bit 15:0
+   #define     tcon_pattern_loop_start    12 // Bit 3:0
+   #define     tcon_pattern_loop_end       8 // Bit 3:0
+   #define     tcon_pattern_enable         0 // Bit 7:0
+#define TCON_CONTROL_HI                            ((0x14cc  << 2) + 0xd0100000)
+#define TCON_CONTROL_LO                            ((0x14cd  << 2) + 0xd0100000)
+   #define     tcon_pclk_enable           26 // Bit 5:0 (enable pclk on TCON channel 7 to 2)
+   #define     tcon_pclk_div              24 // Bit 1:0 (control phy clok divide 2,4,6,8)
+   #define     tcon_delay                  0 // Bit 23:0 (3 bit for each channel)
+#define LVDS_BLANK_DATA_HI                         ((0x14ce  << 2) + 0xd0100000)
+#define LVDS_BLANK_DATA_LO                         ((0x14cf  << 2) + 0xd0100000)
+   #define     LVDS_blank_data_reserved 30  // 31:30
+   #define     LVDS_blank_data_r        20  // 29:20
+   #define     LVDS_blank_data_g        10  // 19:10
+   #define     LVDS_blank_data_b         0  //  9:0
+#define LVDS_PACK_CNTL_ADDR                        ((0x14d0  << 2) + 0xd0100000)
+   #define     LVDS_USE_TCON    7
+   #define     LVDS_DUAL        6
+   #define     PN_SWP           5
+   #define     LSB_FIRST        4
+   #define     LVDS_RESV        3
+   #define     ODD_EVEN_SWP     2
+   #define     LVDS_REPACK      0
+// New from M3 :
+// Bit 15:12 -- Enable OFFSET Double Generate(TOCN7-TCON4)
+// Bit 11:0 -- de_hs(old tcon) second offset_hs (new tcon)
+#define DE_HS_ADDR                                 ((0x14d1  << 2) + 0xd0100000)
+// New from M3 :
+// Bit 15:12 -- Enable OFFSET Double Generate(TOCN3-TCON0)
+#define DE_HE_ADDR                                 ((0x14d2  << 2) + 0xd0100000)
+#define DE_VS_ADDR                                 ((0x14d3  << 2) + 0xd0100000)
+#define DE_VE_ADDR                                 ((0x14d4  << 2) + 0xd0100000)
+#define HSYNC_HS_ADDR                              ((0x14d5  << 2) + 0xd0100000)
+#define HSYNC_HE_ADDR                              ((0x14d6  << 2) + 0xd0100000)
+#define HSYNC_VS_ADDR                              ((0x14d7  << 2) + 0xd0100000)
+#define HSYNC_VE_ADDR                              ((0x14d8  << 2) + 0xd0100000)
+#define VSYNC_HS_ADDR                              ((0x14d9  << 2) + 0xd0100000)
+#define VSYNC_HE_ADDR                              ((0x14da  << 2) + 0xd0100000)
+#define VSYNC_VS_ADDR                              ((0x14db  << 2) + 0xd0100000)
+#define VSYNC_VE_ADDR                              ((0x14dc  << 2) + 0xd0100000)
+// bit 8 -- vfifo_mcu_enable
+// bit 7 -- halt_vs_de
+// bit 6 -- R8G8B8_format
+// bit 5 -- R6G6B6_format (round to 6 bits)
+// bit 4 -- R5G6B5_format
+// bit 3 -- dac_dith_sel
+// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
+// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
+// bit 0 -- lcd_mcu_enable
+#define LCD_MCU_CTL                                ((0x14dd  << 2) + 0xd0100000)
+// ReadOnly 
+//   R5G6B5 when R5G6B5_format
+//   G8R8   when R8G8B8_format
+//   G5R10  Other
+#define LCD_MCU_DATA_0                             ((0x14de  << 2) + 0xd0100000)
+// ReadOnly
+//   G8B8   when R8G8B8_format
+//   G5B10  Other
+#define LCD_MCU_DATA_1                             ((0x14df  << 2) + 0xd0100000)
+// LVDS
+#define LVDS_GEN_CNTL                              ((0x14e0  << 2) + 0xd0100000)
+#define LVDS_PHY_CNTL0                             ((0x14e1  << 2) + 0xd0100000)
+#define LVDS_PHY_CNTL1                             ((0x14e2  << 2) + 0xd0100000)
+#define LVDS_PHY_CNTL2                             ((0x14e3  << 2) + 0xd0100000)
+#define LVDS_PHY_CNTL3                             ((0x14e4  << 2) + 0xd0100000)
+#define LVDS_PHY_CNTL4                             ((0x14e5  << 2) + 0xd0100000)
+#define LVDS_PHY_CNTL5                             ((0x14e6  << 2) + 0xd0100000)
+#define LVDS_SRG_TEST                              ((0x14e8  << 2) + 0xd0100000)
+#define LVDS_BIST_MUX0                             ((0x14e9  << 2) + 0xd0100000)
+#define LVDS_BIST_MUX1                             ((0x14ea  << 2) + 0xd0100000)
+#define LVDS_BIST_FIXED0                           ((0x14eb  << 2) + 0xd0100000)
+#define LVDS_BIST_FIXED1                           ((0x14ec  << 2) + 0xd0100000)
+#define LVDS_BIST_CNTL0                            ((0x14ed  << 2) + 0xd0100000)
+#define LVDS_CLKB_CLKA                             ((0x14ee  << 2) + 0xd0100000)
+#define LVDS_PHY_CLK_CNTL                          ((0x14ef  << 2) + 0xd0100000)
+#define LVDS_SER_EN                                ((0x14f0  << 2) + 0xd0100000)
+#define LVDS_PHY_CNTL6                             ((0x14f1  << 2) + 0xd0100000)
+#define LVDS_PHY_CNTL7                             ((0x14f2  << 2) + 0xd0100000)
+#define LVDS_PHY_CNTL8                             ((0x14f3  << 2) + 0xd0100000)
+#define MLVDS_CLK_CTL0_HI                          ((0x14f4  << 2) + 0xd0100000)
+#define MLVDS_CLK_CTL0_LO                          ((0x14f5  << 2) + 0xd0100000)
+   #define     mlvds_clk_pattern_reserved 31 // Bit 31
+   #define     mpclk_dly                  28 // Bit 2:0 
+   #define     mpclk_div                  26 // Bit 1:0 (control phy clok divide 2,4,6,8)
+   #define     use_mpclk                  25 // Bit 0
+   #define     mlvds_clk_half_delay       24 // Bit 0
+   #define     mlvds_clk_pattern           0 // Bit 23:0
+#define MLVDS_DUAL_GATE_WR_START                   ((0x14f6  << 2) + 0xd0100000)
+   #define     mlvds_dual_gate_wr_start    0 // Bit 12:0
+#define MLVDS_DUAL_GATE_WR_END                     ((0x14f7  << 2) + 0xd0100000)
+   #define     mlvds_dual_gate_wr_end      0 // Bit 12:0
+#define MLVDS_DUAL_GATE_RD_START                   ((0x14f8  << 2) + 0xd0100000)
+   #define     mlvds_dual_gate_rd_start    0 // Bit 12:0
+#define MLVDS_DUAL_GATE_RD_END                     ((0x14f9  << 2) + 0xd0100000)
+   #define     mlvds_dual_gate_rd_end      0 // Bit 12:0
+#define MLVDS_SECOND_RESET_CTL                     ((0x14fa  << 2) + 0xd0100000)
+   #define     mLVDS_2nd_reset_start       0 // Bit 12:0
+#define MLVDS_DUAL_GATE_CTL_HI                     ((0x14fb  << 2) + 0xd0100000)
+#define MLVDS_DUAL_GATE_CTL_LO                     ((0x14fc  << 2) + 0xd0100000)
+   #define     mlvds_tcon_field_en        24 // Bit 7:0
+   #define     mlvds_dual_gate_reserved   21 // Bit 2:0
+   #define     mlvds_scan_mode_start_line_bit12 20 // Bit 0
+   #define     mlvds_scan_mode_odd        16 // Bit 3:0
+   #define     mlvds_scan_mode_even       12 // Bit 3:0
+   #define     mlvds_scan_mode_start_line  0 // Bit 11:0
+#define MLVDS_RESET_CONFIG_HI                      ((0x14fd  << 2) + 0xd0100000)
+#define MLVDS_RESET_CONFIG_LO                      ((0x14fe  << 2) + 0xd0100000)
+   #define     mLVDS_reset_range_enable   31 // Bit 0
+   #define     mLVDS_reset_range_inv      30 // Bit 0
+   #define     mLVDS_reset_config_res1    29 // Bit 0
+   #define     mLVDS_reset_range_line_0   16 // Bit 11:0
+   #define     mLVDS_reset_config_res3    13 // Bit 2:0
+   #define     mLVDS_reset_range_line_1    0 // Bit 11:0
+//===============================================================
+//LCD DRIVER BASE   END
+//===============================================================
+//
+// Closing file:  lcd_regs.h
+//
+//`define VPP2_VCBUS_BASE              8'h19
+//
+// Reading file:  vpp2_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  VPP2_VCBUS_BASE = 0x19
+// -----------------------------------------------
+//===========================================================================
+// Video postprocesing Registers 
+//===========================================================================
+// dummy data used in the VPP preblend and scaler
+// Bit 23:16    
+// Bit 15:8     CB
+// Bit 7:0      CR 
+#define VPP2_DUMMY_DATA                            ((0x1900  << 2) + 0xd0100000)
+//input line length used in VPP
+#define VPP2_LINE_IN_LENGTH                        ((0x1901  << 2) + 0xd0100000)
+//input Picture height used in VPP
+#define VPP2_PIC_IN_HEIGHT                         ((0x1902  << 2) + 0xd0100000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients 
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15    index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)  
+//Bit 14    1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 13    if true, vertical separated coef enable
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered 
+//Bit 6:0   coef index
+#define VPP2_SCALE_COEF_IDX                        ((0x1903  << 2) + 0xd0100000)
+//coefficients for vertical filter and horizontal filter
+#define VPP2_SCALE_COEF                            ((0x1904  << 2) + 0xd0100000)
+//these following registers are the absolute line address pointer for output divided screen
+//The output divided screen is shown in the following:
+//
+//  --------------------------   <------ line zero
+//      . 
+//      .
+//      .           region0        <---------- nonlinear region or nonscaling region    
+//      .
+//  ---------------------------  
+//  ---------------------------  <------ region1_startp 
+//      .
+//      .           region1         <---------- nonlinear region
+//      .
+//      .
+//  ---------------------------  
+//  ---------------------------  <------ region2_startp
+//      .
+//      .           region2         <---------- linear region
+//      .
+//      .
+//  ---------------------------  
+//  ---------------------------  <------ region3_startp
+//      .
+//      .           region3         <---------- nonlinear region
+//      .
+//      .
+//  ---------------------------  
+//  ---------------------------  <------ region4_startp
+//      .
+//      .           region4         <---------- nonlinear region or nonoscaling region
+//      .
+//      .
+//  ---------------------------  <------ region4_endp
+//Bit 28:16 region1 startp
+//Bit 12:0 region2 startp
+#define VPP2_VSC_REGION12_STARTP                   ((0x1905  << 2) + 0xd0100000)
+//Bit 28:16 region3 startp
+//Bit 12:0 region4 startp
+#define VPP2_VSC_REGION34_STARTP                   ((0x1906  << 2) + 0xd0100000)
+#define VPP2_VSC_REGION4_ENDP                      ((0x1907  << 2) + 0xd0100000)
+//vertical start phase step, (source/dest)*(2^24)
+//Bit 27:24 integer part 
+//Bit 23:0  fraction part
+#define VPP2_VSC_START_PHASE_STEP                  ((0x1908  << 2) + 0xd0100000)
+//vertical scaler region0 phase slope, Bit24 signed bit
+#define VPP2_VSC_REGION0_PHASE_SLOPE               ((0x1909  << 2) + 0xd0100000)
+//vertical scaler region1 phase slope, Bit24 signed bit
+#define VPP2_VSC_REGION1_PHASE_SLOPE               ((0x190a  << 2) + 0xd0100000)
+//vertical scaler region3 phase slope, Bit24 signed bit
+#define VPP2_VSC_REGION3_PHASE_SLOPE               ((0x190b  << 2) + 0xd0100000)
+//vertical scaler region4 phase slope, Bit24 signed bit
+#define VPP2_VSC_REGION4_PHASE_SLOPE               ((0x190c  << 2) + 0xd0100000)
+//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X, 
+//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
+//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
+//Bit 16     0: progressive output, 1: interlace output
+//Bit 15     vertical scaler output line0 in advance or not for bottom field
+//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
+//Bit 11:8   vertical scaler initial receiving  number for bottom field   
+//Bit 7      vertical scaler output line0 in advance or not for top field
+//Bit 6:5    vertical scaler initial repeat line0 number for top field
+//Bit 3:0    vertical scaler initial receiving  number for top field   
+#define VPP2_VSC_PHASE_CTRL                        ((0x190d  << 2) + 0xd0100000)
+//Bit 31:16  vertical scaler field initial phase for bottom field
+//Bit 15:0  vertical scaler field initial phase for top field
+#define VPP2_VSC_INI_PHASE                         ((0x190e  << 2) + 0xd0100000)
+//Bit 28:16 region1 startp
+//Bit 12:0 region2 startp
+#define VPP2_HSC_REGION12_STARTP                   ((0x1910  << 2) + 0xd0100000)
+//Bit 28:16 region3 startp
+//Bit 12:0 region4 startp
+#define VPP2_HSC_REGION34_STARTP                   ((0x1911  << 2) + 0xd0100000)
+#define VPP2_HSC_REGION4_ENDP                      ((0x1912  << 2) + 0xd0100000)
+//horizontal start phase step, (source/dest)*(2^24)
+//Bit 27:24 integer part 
+//Bit 23:0  fraction part
+#define VPP2_HSC_START_PHASE_STEP                  ((0x1913  << 2) + 0xd0100000)
+//horizontal scaler region0 phase slope, Bit24 signed bit
+#define VPP2_HSC_REGION0_PHASE_SLOPE               ((0x1914  << 2) + 0xd0100000)
+//horizontal scaler region1 phase slope, Bit24 signed bit
+#define VPP2_HSC_REGION1_PHASE_SLOPE               ((0x1915  << 2) + 0xd0100000)
+//horizontal scaler region3 phase slope, Bit24 signed bit
+#define VPP2_HSC_REGION3_PHASE_SLOPE               ((0x1916  << 2) + 0xd0100000)
+//horizontal scaler region4 phase slope, Bit24 signed bit
+#define VPP2_HSC_REGION4_PHASE_SLOPE               ((0x1917  << 2) + 0xd0100000)
+//Bit 22:21   horizontal scaler initial repeat pixel0 number
+//Bit 19:16   horizontal scaler initial receiving number   
+//Bit 15:0    horizontal scaler top field initial phase
+#define VPP2_HSC_PHASE_CTRL                        ((0x1918  << 2) + 0xd0100000)
+// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
+//                 just for special usage, more flexibility
+// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
+// Bit 20 prehsc_en
+// Bit 19 prevsc_en
+// Bit 18 vsc_en
+// Bit 17 hsc_en
+// Bit 16 scale_top_en
+// Bit 15 video1 scale out enable
+// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler 
+// Bit 10:8 horizontal scaler bank length
+// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
+// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler 
+// Bit 2:0 vertical scaler bank length
+#define VPP2_SC_MISC                               ((0x1919  << 2) + 0xd0100000)
+// preblend video1 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP2_PREBLEND_VD1_H_START_END              ((0x191a  << 2) + 0xd0100000)
+// preblend video1 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP2_PREBLEND_VD1_V_START_END              ((0x191b  << 2) + 0xd0100000)
+// postblend video1 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP2_POSTBLEND_VD1_H_START_END             ((0x191c  << 2) + 0xd0100000)
+// postblend video1 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP2_POSTBLEND_VD1_V_START_END             ((0x191d  << 2) + 0xd0100000)
+// preblend horizontal size
+#define VPP2_PREBLEND_H_SIZE                       ((0x1920  << 2) + 0xd0100000)
+// postblend horizontal size
+#define VPP2_POSTBLEND_H_SIZE                      ((0x1921  << 2) + 0xd0100000)
+//VPP hold lines
+//Bit 29:24
+//Bit 21:16
+//Bit 15:8     preblend hold lines
+//Bit 7:0      postblend hold lines
+#define VPP2_HOLD_LINES                            ((0x1922  << 2) + 0xd0100000)
+//Bit 25   if true, change screen to one color value for preblender
+//Bit 24   if true, change screen to one color value for postblender
+// Bit 23:16 one color Y
+// Bit 15:8 one color Cb
+// Bit  7:0 one color  Cr
+#define VPP2_BLEND_ONECOLOR_CTRL                   ((0x1923  << 2) + 0xd0100000)
+//Read Only, VPP preblend current_x, current_y
+//Bit 28:16 current_x
+//Bit 12:0 current_y
+#define VPP2_PREBLEND_CURRENT_XY                   ((0x1924  << 2) + 0xd0100000)
+//Read Only, VPP postblend current_x, current_y
+//Bit 28:16 current_x
+//Bit 12:0 current_y
+#define VPP2_POSTBLEND_CURRENT_XY                  ((0x1925  << 2) + 0xd0100000)
+// Bit 31  vd1_bgosd_exchange_en for preblend
+// Bit 30  vd1_bgosd_exchange_en for postblend
+// bit 28   color management enable
+// Bit 27,  reserved 
+// Bit 26:18, reserved
+// Bit 17, osd2 enable for preblend
+// Bit 16, osd1 enable for preblend
+// Bit 15, reserved
+// Bit 14, vd1 enable for preblend
+// Bit 13, osd2 enable for postblend
+// Bit 12, osd1 enable for postblend
+// Bit 11, reserved
+// Bit 10, vd1 enable for postblend
+// Bit 9,  if true, osd1 is alpha premultipiled 
+// Bit 8,  if true, osd2 is alpha premultipiled 
+// Bit 7,  postblend module enable
+// Bit 6,  preblend module enable
+// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
+// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
+// Bit 3,  
+// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
+//           the aync fifo will be reseted.
+// Bit 1,     
+// Bit 0    if true, the output result of VPP is saturated
+#define VPP2_MISC                                  ((0x1926  << 2) + 0xd0100000)
+//Bit 31:20 ofifo line length minus 1
+//Bit 19  if true invert input vs
+//Bit 18  if true invert input hs
+//Bit 17  force top/bottom field, enable
+//Bit 16  force top/bottom field, 0: top, 1: bottom
+//Bit 15  force one go_field, one pluse, write only
+//Bit 14  force one go_line, one pluse, write only
+//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
+#define VPP2_OFIFO_SIZE                            ((0x1927  << 2) + 0xd0100000)
+//Read only
+//Bit 28:17 current scale out fifo counter
+//Bit 16:12 current afifo counter
+//Bit 11:0 current ofifo counter
+#define VPP2_FIFO_STATUS                           ((0x1928  << 2) + 0xd0100000)
+// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable 
+// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable 
+// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable 
+// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable 
+#define VPP2_SMOKE_CTRL                            ((0x1929  << 2) + 0xd0100000)
+//smoke can be used only when that blending is disable and then be used as smoke function
+//smoke1 for OSD1 chanel
+//smoke2 for OSD2 chanel
+//31:24 Y
+//23:16 Cb
+//15:8 Cr
+//7:0 Alpha
+#define VPP2_SMOKE1_VAL                            ((0x192a  << 2) + 0xd0100000)
+#define VPP2_SMOKE2_VAL                            ((0x192b  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP2_SMOKE1_H_START_END                    ((0x192d  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP2_SMOKE1_V_START_END                    ((0x192e  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP2_SMOKE2_H_START_END                    ((0x192f  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP2_SMOKE2_V_START_END                    ((0x1930  << 2) + 0xd0100000)
+//Bit 27:16 scale out fifo line length minus 1
+//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
+#define VPP2_SCO_FIFO_CTRL                         ((0x1933  << 2) + 0xd0100000)
+//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
+//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode, 
+//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
+//Bit 23 horizontal scaler double pixel mode
+//Bit 22:21   horizontal scaler initial repeat pixel0 number1
+//Bit 19:16   horizontal scaler initial receiving number1   
+//Bit 15:0    horizontal scaler top field initial phase1
+#define VPP2_HSC_PHASE_CTRL1                       ((0x1934  << 2) + 0xd0100000)
+//for 3D quincunx sub-sampling
+//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
+//22:20  prehsc pattern start
+//18:16 prehsc pattern end
+//15:8 pattern, each patten 1 bit, from lsb -> msb
+//6:4  pattern start
+//2:0  pattern end
+#define VPP2_HSC_INI_PAT_CTRL                      ((0x1935  << 2) + 0xd0100000)
+//Bit 3         minus black level enable for vadj2
+//Bit 2         Video adjustment enable for vadj2
+//Bit 1         minus black level enable for vadj1
+//Bit 0         Video adjustment enable for vadj1
+#define VPP2_VADJ_CTRL                             ((0x1940  << 2) + 0xd0100000)
+//Bit 16:8  brightness, signed value
+//Bit 7:0   contrast, unsigned value, contrast from  0 <= contrast <2
+#define VPP2_VADJ1_Y                               ((0x1941  << 2) + 0xd0100000)
+//cb' = cb*ma + cr*mb
+//cr' = cb*mc + cr*md
+//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
+#define VPP2_VADJ1_MA_MB                           ((0x1942  << 2) + 0xd0100000)
+#define VPP2_VADJ1_MC_MD                           ((0x1943  << 2) + 0xd0100000)
+//Bit 16:8  brightness, signed value
+//Bit 7:0   contrast, unsigned value, contrast from  0 <= contrast <2
+#define VPP2_VADJ2_Y                               ((0x1944  << 2) + 0xd0100000)
+//cb' = cb*ma + cr*mb
+//cr' = cb*mc + cr*md
+//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
+#define VPP2_VADJ2_MA_MB                           ((0x1945  << 2) + 0xd0100000)
+#define VPP2_VADJ2_MC_MD                           ((0x1946  << 2) + 0xd0100000)
+//Read only 
+//Bit 31, if it is true, it means this probe is valid in the last field/frame
+//Bit 29:20 component 0
+//Bit 19:10 component 1
+//Bit 9:0 component 2
+#define VPP2_MATRIX_PROBE_COLOR                    ((0x195c  << 2) + 0xd0100000)
+//Bit 23:16 component 0
+//Bit 15:8  component 1
+//Bit 7:0 component 2
+#define VPP2_MATRIX_HL_COLOR                       ((0x195d  << 2) + 0xd0100000)
+//28:16 probe x, postion
+//12:0  probe y, position  
+#define VPP2_MATRIX_PROBE_POS                      ((0x195e  << 2) + 0xd0100000)
+//Bit 16,  highlight_en
+//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
+//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix,
+//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix
+//Bit 5    vd1 conversion matrix enable
+//Bit 4    reserved
+//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
+//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
+//Bit 0    post conversion matrix enable
+#define VPP2_MATRIX_CTRL                           ((0x195f  << 2) + 0xd0100000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define VPP2_MATRIX_COEF00_01                      ((0x1960  << 2) + 0xd0100000)
+//Bit 28:16 coef02 
+//Bit 12:0  coef10 
+#define VPP2_MATRIX_COEF02_10                      ((0x1961  << 2) + 0xd0100000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define VPP2_MATRIX_COEF11_12                      ((0x1962  << 2) + 0xd0100000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define VPP2_MATRIX_COEF20_21                      ((0x1963  << 2) + 0xd0100000)
+#define VPP2_MATRIX_COEF22                         ((0x1964  << 2) + 0xd0100000)
+//Bit 26:16 offset0
+//Bit 10:0  offset1
+#define VPP2_MATRIX_OFFSET0_1                      ((0x1965  << 2) + 0xd0100000)
+//Bit 10:0  offset2
+#define VPP2_MATRIX_OFFSET2                        ((0x1966  << 2) + 0xd0100000)
+//Bit 26:16 pre_offset0
+//Bit 10:0  pre_offset1
+#define VPP2_MATRIX_PRE_OFFSET0_1                  ((0x1967  << 2) + 0xd0100000)
+//Bit 10:0  pre_offset2
+#define VPP2_MATRIX_PRE_OFFSET2                    ((0x1968  << 2) + 0xd0100000)
+// dummy data used in the VPP postblend
+// Bit 23:16    Y
+// Bit 15:8     CB
+// Bit 7:0      CR 
+#define VPP2_DUMMY_DATA1                           ((0x1969  << 2) + 0xd0100000)
+//Bit 31 gainoff module enable
+//Bit 26:16 gain0, 1.10 unsigned data
+//Bit 10:0  gain1, 1.10 unsigned dat
+#define VPP2_GAINOFF_CTRL0                         ((0x196a  << 2) + 0xd0100000)
+//Bit 26:16 gain2, 1.10 unsigned data
+//Bit 10:0, offset0, signed data
+#define VPP2_GAINOFF_CTRL1                         ((0x196b  << 2) + 0xd0100000)
+//Bit 26:16, offset1, signed data
+//Bit 10:0, offset2, signed data
+#define VPP2_GAINOFF_CTRL2                         ((0x196c  << 2) + 0xd0100000)
+//Bit 26:16, pre_offset0, signed data 
+//Bit 10:0, pre_offset1, signed data 
+#define VPP2_GAINOFF_CTRL3                         ((0x196d  << 2) + 0xd0100000)
+//Bit 10:0, pre_offset2, signed data 
+#define VPP2_GAINOFF_CTRL4                         ((0x196e  << 2) + 0xd0100000)
+//only two registers used in the color management, which are defined in the chroma_reg.h
+#define VPP2_CHROMA_ADDR_PORT                      ((0x1970  << 2) + 0xd0100000)
+#define VPP2_CHROMA_DATA_PORT                      ((0x1971  << 2) + 0xd0100000)
+//`include "chroma_reg.h"       //defined inside is the indirect addressed registers
+//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
+//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock 
+//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again 
+//because the register itself canot be set again without clk
+//Bit 31:0
+#define VPP2_GCLK_CTRL0                            ((0x1972  << 2) + 0xd0100000)
+//Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
+//Bit 9:0
+#define VPP2_GCLK_CTRL1                            ((0x1973  << 2) + 0xd0100000)
+//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
+//Bit 11:0
+#define VPP2_SC_GCLK_CTRL                          ((0x1974  << 2) + 0xd0100000)
+//Bit 17:9 VD1 alpha for preblend
+//Bit 8:0 VD1 alpha for postblend
+#define VPP2_MISC1                                 ((0x1976  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region03 output value
+//Bit 23:16     bottom of region02 output value
+//Bit 15:8      bottom of region01 output value
+//Bit 7:0       bottom of region00 output value
+#define VPP2_DNLP_CTRL_00                          ((0x1981  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region07 output value
+//Bit 23:16     bottom of region06 output value
+//Bit 15:8      bottom of region05 output value
+//Bit 7:0       bottom of region04 output value
+#define VPP2_DNLP_CTRL_01                          ((0x1982  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region11 output value
+//Bit 23:16     bottom of region10 output value
+//Bit 15:8      bottom of region09 output value
+//Bit 7:0       bottom of region08 output value
+#define VPP2_DNLP_CTRL_02                          ((0x1983  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region15 output value
+//Bit 23:16     bottom of region14 output value
+//Bit 15:8      bottom of region13 output value
+//Bit 7:0       bottom of region12 output value
+#define VPP2_DNLP_CTRL_03                          ((0x1984  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region19 output value
+//Bit 23:16     bottom of region18 output value
+//Bit 15:8      bottom of region17 output value
+//Bit 7:0       bottom of region16 output value
+#define VPP2_DNLP_CTRL_04                          ((0x1985  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region23 output value
+//Bit 23:16     bottom of region22 output value
+//Bit 15:8      bottom of region21 output value
+//Bit 7:0       bottom of region20 output value
+#define VPP2_DNLP_CTRL_05                          ((0x1986  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region27 output value
+//Bit 23:16     bottom of region26 output value
+//Bit 15:8      bottom of region25 output value
+//Bit 7:0       bottom of region24 output value
+#define VPP2_DNLP_CTRL_06                          ((0x1987  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region31 output value
+//Bit 23:16     bottom of region30 output value
+//Bit 15:8      bottom of region29 output value
+//Bit 7:0       bottom of region28 output value
+#define VPP2_DNLP_CTRL_07                          ((0x1988  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region35 output value
+//Bit 23:16     bottom of region34 output value
+//Bit 15:8      bottom of region33 output value
+//Bit 7:0       bottom of region32 output value
+#define VPP2_DNLP_CTRL_08                          ((0x1989  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region39 output value
+//Bit 23:16     bottom of region38 output value
+//Bit 15:8      bottom of region37 output value
+//Bit 7:0       bottom of region36 output value
+#define VPP2_DNLP_CTRL_09                          ((0x198a  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region43 output value
+//Bit 23:16     bottom of region42 output value
+//Bit 15:8      bottom of region41 output value
+//Bit 7:0       bottom of region40 output value
+#define VPP2_DNLP_CTRL_10                          ((0x198b  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region47 output value
+//Bit 23:16     bottom of region46 output value
+//Bit 15:8      bottom of region45 output value
+//Bit 7:0       bottom of region44 output value
+#define VPP2_DNLP_CTRL_11                          ((0x198c  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region51 output value
+//Bit 23:16     bottom of region50 output value
+//Bit 15:8      bottom of region49 output value
+//Bit 7:0       bottom of region48 output value
+#define VPP2_DNLP_CTRL_12                          ((0x198d  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region55 output value
+//Bit 23:16     bottom of region54 output value
+//Bit 15:8      bottom of region53 output value
+//Bit 7:0       bottom of region52 output value
+#define VPP2_DNLP_CTRL_13                          ((0x198e  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region59 output value
+//Bit 23:16     bottom of region58 output value
+//Bit 15:8      bottom of region57 output value
+//Bit 7:0       bottom of region56 output value
+#define VPP2_DNLP_CTRL_14                          ((0x198f  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region63 output value
+//Bit 23:16     bottom of region62 output value
+//Bit 15:8      bottom of region61 output value
+//Bit 7:0       bottom of region60 output value
+#define VPP2_DNLP_CTRL_15                          ((0x1990  << 2) + 0xd0100000)
+//Bit 20 reserved
+//Bit 19 reserved
+//Bit 18 demo dynamic nonlinear luma processing enable
+//Bit 17 reserved
+//Bit 16 reserved
+//Bit 15:14, 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
+//Bit 4 reserved
+//Bit 3 reserved
+//Bit 2 dynamic nonlinear luma processing enable
+//Bit 1 reserved
+//Bit 0 reserved
+#define VPP2_VE_ENABLE_CTRL                        ((0x19a1  << 2) + 0xd0100000)
+//Bit 12:0, demo left or top screen width
+#define VPP2_VE_DEMO_LEFT_TOP_SCREEN_WIDTH         ((0x19a2  << 2) + 0xd0100000)
+#define VPP2_VE_DEMO_CENTER_BAR                    ((0x19a3  << 2) + 0xd0100000)
+//28:16  ve_line_length
+//12:0   ve_pic_height
+#define VPP2_VE_H_V_SIZE                           ((0x19a4  << 2) + 0xd0100000)
+//Bit 10   reset bit, high active
+//Bit 9    0: measuring rising edge, 1: measuring falling edge
+//Bit 8    if true, accumulate the counter number, otherwise not
+//Bit 7:0  vsync_span, define how many vsync span need to measure 
+#define VPP2_VDO_MEAS_CTRL                         ((0x19a8  << 2) + 0xd0100000)
+//Read only
+//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
+//15:0, high bit portion of counter
+#define VPP2_VDO_MEAS_VS_COUNT_HI                  ((0x19a9  << 2) + 0xd0100000)
+//Read only
+//31:0, low bit portion of counter
+#define VPP2_VDO_MEAS_VS_COUNT_LO                  ((0x19aa  << 2) + 0xd0100000)
+//vertical scaler phase step
+//Bit 27:0,  4.24 format
+#define VPP2_OSD_VSC_PHASE_STEP                    ((0x19c0  << 2) + 0xd0100000)
+//Bit 31:16, botttom vertical scaler initial phase
+//Bit 15:0, top vertical scaler initial phase
+#define VPP2_OSD_VSC_INI_PHASE                     ((0x19c1  << 2) + 0xd0100000)
+//Bit 24    osd vertical Scaler enable
+//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
+//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
+//Bit 20    osd_vsc_phase0_always_en
+//Bit 19    osd_vsc_nearest_en
+//Bit 17:16 osd_vsc_bot_rpt_l0_num
+//Bit 14:11 osd_vsc_bot_ini_rcv_num
+//Bit 9:8   osd_vsc_top_rpt_l0_num
+//Bit 6:3   osd_vsc_top_ini_rcv_num
+//Bit 2:0   osd_vsc_bank_length 
+#define VPP2_OSD_VSC_CTRL0                         ((0x19c2  << 2) + 0xd0100000)
+//horizontal scaler phase step
+//Bit 27:0,  4.24 format
+#define VPP2_OSD_HSC_PHASE_STEP                    ((0x19c3  << 2) + 0xd0100000)
+//Bit 31:16, horizontal scaler initial phase1
+//Bit 15:0, horizontal scaler initial phase0
+#define VPP2_OSD_HSC_INI_PHASE                     ((0x19c4  << 2) + 0xd0100000)
+//Bit 22   osd horizontal scaler enable
+//Bit 21   osd_hsc_double_pix_mode
+//Bit 20   osd_hsc_phase0_always_en
+//Bit 19   osd_hsc_nearest_en
+//Bit 17:16 osd_hsc_rpt_p0_num1
+//Bit 14:11 osd_hsc_ini_rcv_num1
+//Bit 9:8   osd_hsc_rpt_p0_num0
+//Bit 6:3   osd_hsc_ini_rcv_num0
+//Bit 2:0   osd_hsc_bank_length
+#define VPP2_OSD_HSC_CTRL0                         ((0x19c5  << 2) + 0xd0100000)
+//for 3D quincunx sub-sampling
+//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
+//bit 6:4  pattern start
+//bit 2:0  pattern end
+#define VPP2_OSD_HSC_INI_PAT_CTRL                  ((0x19c6  << 2) + 0xd0100000)
+//bit 31:24, componet 0
+//bit 23:16, component 1
+//bit 15:8, component 2
+//bit 7:0 component 3, alpha
+#define VPP2_OSD_SC_DUMMY_DATA                     ((0x19c7  << 2) + 0xd0100000)
+//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
+//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
+//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
+//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
+//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
+//Bit 3 osd scaler path enable 
+//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
+#define VPP2_OSD_SC_CTRL0                          ((0x19c8  << 2) + 0xd0100000)
+//Bit 28:16 OSD scaler input width minus 1
+//Bit 12:0 OSD scaler input height minus 1
+#define VPP2_OSD_SCI_WH_M1                         ((0x19c9  << 2) + 0xd0100000)
+//Bit 28:16 OSD scaler output horizontal start
+//Bit 12:0 OSD scaler output horizontal end
+#define VPP2_OSD_SCO_H_START_END                   ((0x19ca  << 2) + 0xd0100000)
+//Bit 28:16 OSD scaler output vertical start
+//Bit 12:0 OSD scaler output vertical end
+#define VPP2_OSD_SCO_V_START_END                   ((0x19cb  << 2) + 0xd0100000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients 
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
+//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
+//Bit 6:0 	coef index
+#define VPP2_OSD_SCALE_COEF_IDX                    ((0x19cc  << 2) + 0xd0100000)
+//coefficients for vertical filter and horizontal filter
+#define VPP2_OSD_SCALE_COEF                        ((0x19cd  << 2) + 0xd0100000)
+//Bit 12:0 line number use to generate interrupt when line == this number
+#define VPP2_INT_LINE_NUM                          ((0x19ce  << 2) + 0xd0100000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vpp2_regs.h
+//
+//`define VIU_VCBUS_BASE                8'h1a    
+//
+// Reading file:  vregs.h
+//
+//===========================================================================
+// Video Interface Registers    0xa00 - 0xaff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VIU_VCBUS_BASE = 0x1a
+// -----------------------------------------------
+#define VIU_ADDR_START                             ((0x1a00  << 2) + 0xd0100000)
+#define VIU_ADDR_END                               ((0x1aff  << 2) + 0xd0100000)
+//`define TRACE_REG 8'ff
+//------------------------------------------------------------------------------
+// VIU top-level registers
+//------------------------------------------------------------------------------
+// Bit  0 RW, osd1_reset
+// Bit  1 RW, osd2_reset
+// Bit  2 RW, vd1_reset
+// Bit  3 RW, vd1_fmt_reset
+// Bit  4 RW, vd2_reset
+// Bit  5 RW, vd2_fmt_reset
+// Bit  6 RW, di_dsr1to2_reset
+// Bit  7 RW, vpp_reset
+// Bit  8 RW, di_if1_reset
+// Bit  9 RW, di_if1_fmt_reset
+// Bit 10 RW, di_inp_reset
+// Bit 11 RW, di_inp_fmt_reset
+// Bit 12 RW, di_mem_reset
+// Bit 13 RW, di_mem_fmt_reset
+// Bit 14 RW, di_nr_wr_mif_reset
+// Bit 15 RW, dein_wr_mif_reset
+// Bit 16 RW, di_chan2_mif_reset
+// Bit 17 RW, di_mtn_wr_mif_reset
+// Bit 18 RW, di_mtn_rd_mif_reset
+// Bit 19 RW, di_mad_reset
+// Bit 20 RW, vdin0_reset
+// Bit 21 RW, vdin1_reset
+// Bit 22 RW, nrin_mux_reset
+// Bit 23 RW, vdin0_wr_reset
+// Bit 24 RW, vdin1_wr_reset
+// Bit 25 RW, reserved
+// Bit 26 RW, d2d3_reset
+// Bit 27 RW, di_cont_wr_mif_reset
+// Bit 28 RW, di_cont_rd_mif_reset
+#define VIU_SW_RESET                               ((0x1a01  << 2) + 0xd0100000)
+#define VIU_SW_RESET0                              ((0x1a02  << 2) + 0xd0100000)
+// Bit 0 RW, software reset for mcvecrd_mif
+// Bit 1 RW, software reset for mcinfowr_mif
+// Bit 2 RW, software reset for mcinford_mif
+//7:0 fix_disable
+#define VIU_MISC_CTRL0                             ((0x1a06  << 2) + 0xd0100000)
+#define D2D3_INTF_LENGTH                           ((0x1a08  << 2) + 0xd0100000)
+// Bit 31:30 vdin0 dout splitter, bit 0 turns on vdin0 to old path, bit 1 turns on vdin0 to d2d3_intf vdin0 input path        
+// Bit 29:28 vdin1 dout splitter, bit 0 turns on vdin1 to old path, bit 1 turns on vdin1 to d2d3_intf vdin1 input path  
+// Bit 27:26 NR write dout splitter, bit 0 turns on NR write to old path, bit 1 turns on NR WR to d2d3_intf NR WR input path  
+// Bit 23 if true, turn on clk_d2d3_reg (register clock)
+// Bit 22 if true, turn on clk_d2d3
+// Bit 21 reg_v1_go_line
+// Bit 20 reg_v1_go_field   
+// Bit 19 reg_v0_go_field
+// Bit 18:16 v1_gofld_sel, 000: display go_field/go_line, 001: DI pre_frame_rst/go_line, 010: vdin0 go_field/go_line, 
+//011: vdin1 go_field/go_line, otherwise: force go_field by reg_v1_go_field(bit20), force go_line by reg_v1_go_line(bit21)
+// Bit 15:13 v0_gofld_sel, 000: display go_field, 001: DI pre_frame_rst, 010: vdin0 go_field, 011: vdin1 go_field, otherwise: force go_field by
+// reg_v0_go_field(bit19)
+// Bit 12:6 hole_lines for d2d3 depth read interface
+// Bit 5:4 d2d3_v1_sel, 2'b01: video display read interface(DI or vd1 fomart output), 2'b10: scale output, otherwise nothing as v1
+// Bit 3 use_vdin_eol, if true, use vdin eol as the v0_eol, otherwise using length to get the v0_eol
+// Bit 2:0  d2d3_v0_sel  001: vdin0, 010: vdin1, 011: NRW, 100: video display read interface(DI or vd1 fomart output), 101: vpp scale output
+//
+#define D2D3_INTF_CTRL0                            ((0x1a09  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// OSD1 registers
+//------------------------------------------------------------------------------
+// Bit    31 Reserved
+// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
+//                                0=use gated clock for low power.
+// Bit    29 R, test_rd_dsr
+// Bit    28 R, osd_done
+// Bit 27:24 R, osd_blk_mode
+// Bit 23:22 R, osd_blk_ptr
+// Bit    21 R, osd_enable
+//
+// Bit 20:12 RW, global_alpha
+// Bit    11 RW, test_rd_en
+// Bit 10: 9 Reserved for control signals
+// Bit  8: 5 RW, ctrl_mtch_y
+// Bit     4 RW, ctrl_422to444
+// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
+//                               Bit 1 to enable block 1, and so on.
+#define VIU_OSD1_CTRL_STAT                         ((0x1a10  << 2) + 0xd0100000)
+// Bit 31:26 Reserved
+// Bit 25:16 R, fifo_count
+// Bit 15: 6 Reserved
+// Bit  5: 4 RW, hold_fifo_lines[6:5]
+// Bit     3 RW, rgb2yuv_full_range
+// Bit     2 RW, alpha_9b_mode
+// Bit     1 RW, reserved
+// Bit     0 RW, color_expand_mode
+#define VIU_OSD1_CTRL_STAT2                        ((0x1a2d  << 2) + 0xd0100000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define VIU_OSD1_COLOR_ADDR                        ((0x1a11  << 2) + 0xd0100000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define VIU_OSD1_COLOR                             ((0x1a12  << 2) + 0xd0100000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define VIU_OSD1_TCOLOR_AG0                        ((0x1a17  << 2) + 0xd0100000)
+#define VIU_OSD1_TCOLOR_AG1                        ((0x1a18  << 2) + 0xd0100000)
+#define VIU_OSD1_TCOLOR_AG2                        ((0x1a19  << 2) + 0xd0100000)
+#define VIU_OSD1_TCOLOR_AG3                        ((0x1a1a  << 2) + 0xd0100000)
+// Bit 31:30 Reserved
+// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
+// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
+// Bit 27:24 Reserved
+// Bit 23:16 RW, tbl_addr
+// Bit    15 RW, little_endian: 0=big endian, 1=little endian
+// Bit    14 RW, rpt_y
+// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
+//                            pixel; 11=Interpolate with the average value
+//                            between previous and next pixel.
+// Bit 11: 8 RW, osd_blk_mode
+// Bit     7 RW, rgb_en
+// Bit     6 RW, tc_alpha_en
+// Bit  5: 2 RW, color_matrix
+// Bit     1 RW, interlace_en
+// Bit     0 RW, interlace_sel_odd
+#define VIU_OSD1_BLK0_CFG_W0                       ((0x1a1b  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK1_CFG_W0                       ((0x1a1f  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK2_CFG_W0                       ((0x1a23  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK3_CFG_W0                       ((0x1a27  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, x_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, x_start
+#define VIU_OSD1_BLK0_CFG_W1                       ((0x1a1c  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK1_CFG_W1                       ((0x1a20  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK2_CFG_W1                       ((0x1a24  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK3_CFG_W1                       ((0x1a28  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, y_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, y_start
+#define VIU_OSD1_BLK0_CFG_W2                       ((0x1a1d  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK1_CFG_W2                       ((0x1a21  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK2_CFG_W2                       ((0x1a25  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK3_CFG_W2                       ((0x1a29  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, h_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, h_start
+#define VIU_OSD1_BLK0_CFG_W3                       ((0x1a1e  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK1_CFG_W3                       ((0x1a22  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK2_CFG_W3                       ((0x1a26  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK3_CFG_W3                       ((0x1a2a  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, v_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, v_start
+#define VIU_OSD1_BLK0_CFG_W4                       ((0x1a13  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK1_CFG_W4                       ((0x1a14  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK2_CFG_W4                       ((0x1a15  << 2) + 0xd0100000)
+#define VIU_OSD1_BLK3_CFG_W4                       ((0x1a16  << 2) + 0xd0100000)
+// Bit    31 RW, burst_len_sel[2] of [2:0]
+// Bit    30 RW, byte_swap: In addition to endian control, further define
+//               whether to swap upper and lower byte within a 16-bit mem word.
+//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
+// Bit 29:22 R,  Reserved
+// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
+// Bit    19 R,  fifo_overflow
+//
+// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
+// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
+// Bit  9: 5 RW, hold_fifo_lines[4:0]
+// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
+// Bit     3 RW, fifo_sync_rst
+// Bit  2: 1 RW, endian
+// Bit     0 RW, urgent
+#define VIU_OSD1_FIFO_CTRL_STAT                    ((0x1a2b  << 2) + 0xd0100000)
+// Bit 31:24 R, Y or R
+// Bit 23:16 R, Cb or G
+// Bit 15: 8 R, Cr or B
+// Bit  7: 0 R, Output Alpha[8:1]
+#define VIU_OSD1_TEST_RDDATA                       ((0x1a2c  << 2) + 0xd0100000)
+// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
+// Bit 12: 0 RW, effective FIFO size when prot_en=1.
+#define VIU_OSD1_PROT_CTRL                         ((0x1a2e  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// OSD2 registers
+//------------------------------------------------------------------------------
+// Bit    31 Reserved
+// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
+//                                0=use gated clock for low power.
+// Bit    29 R, test_rd_dsr
+// Bit    28 R, osd_done
+// Bit 27:24 R, osd_blk_mode
+// Bit 23:22 R, osd_blk_ptr
+// Bit    21 R, osd_enable
+//
+// Bit 20:12 RW, global_alpha
+// Bit    11 RW, test_rd_en
+// Bit    10 RW, hl2_en
+// Bit     9 RW, hl1_en
+// Bit  8: 5 RW, ctrl_mtch_y
+// Bit     4 RW, ctrl_422to444
+// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
+//                               Bit 1 to enable block 1, and so on.
+#define VIU_OSD2_CTRL_STAT                         ((0x1a30  << 2) + 0xd0100000)
+// Bit 31:26 Reserved
+// Bit 25:16 R, fifo_count
+// Bit 15: 6 Reserved
+// Bit  5: 4 RW, hold_fifo_lines[6:5]
+// Bit     3 RW, rgb2yuv_full_range
+// Bit     2 RW, alpha_9b_mode
+// Bit     1 RW, reserved
+// Bit     0 RW, color_expand_mode
+#define VIU_OSD2_CTRL_STAT2                        ((0x1a4d  << 2) + 0xd0100000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define VIU_OSD2_COLOR_ADDR                        ((0x1a31  << 2) + 0xd0100000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define VIU_OSD2_COLOR                             ((0x1a32  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, hl[1-2]_h/v_start
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, hl[1-2]_h/v_end
+#define VIU_OSD2_HL1_H_START_END                   ((0x1a33  << 2) + 0xd0100000)
+#define VIU_OSD2_HL1_V_START_END                   ((0x1a34  << 2) + 0xd0100000)
+#define VIU_OSD2_HL2_H_START_END                   ((0x1a35  << 2) + 0xd0100000)
+#define VIU_OSD2_HL2_V_START_END                   ((0x1a36  << 2) + 0xd0100000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define VIU_OSD2_TCOLOR_AG0                        ((0x1a37  << 2) + 0xd0100000)
+#define VIU_OSD2_TCOLOR_AG1                        ((0x1a38  << 2) + 0xd0100000)
+#define VIU_OSD2_TCOLOR_AG2                        ((0x1a39  << 2) + 0xd0100000)
+#define VIU_OSD2_TCOLOR_AG3                        ((0x1a3a  << 2) + 0xd0100000)
+// Bit 31:24 Reserved
+// Bit 23:16 RW, tbl_addr
+// Bit    15 RW, little_endian: 0=big endian, 1=little endian
+// Bit    14 RW, rpt_y
+// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
+//                            pixel; 11=Interpolate with the average value
+//                            between previous and next pixel.
+// Bit 11: 8 RW, osd_blk_mode
+// Bit     7 RW, rgb_en
+// Bit     6 RW, tc_alpha_en
+// Bit  5: 2 RW, color_matrix
+// Bit     1 RW, interlace_en
+// Bit     0 RW, interlace_sel_odd
+#define VIU_OSD2_BLK0_CFG_W0                       ((0x1a3b  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK1_CFG_W0                       ((0x1a3f  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK2_CFG_W0                       ((0x1a43  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK3_CFG_W0                       ((0x1a47  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, x_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, x_start
+#define VIU_OSD2_BLK0_CFG_W1                       ((0x1a3c  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK1_CFG_W1                       ((0x1a40  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK2_CFG_W1                       ((0x1a44  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK3_CFG_W1                       ((0x1a48  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, y_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, y_start
+#define VIU_OSD2_BLK0_CFG_W2                       ((0x1a3d  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK1_CFG_W2                       ((0x1a41  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK2_CFG_W2                       ((0x1a45  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK3_CFG_W2                       ((0x1a49  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, h_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, h_start
+#define VIU_OSD2_BLK0_CFG_W3                       ((0x1a3e  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK1_CFG_W3                       ((0x1a42  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK2_CFG_W3                       ((0x1a46  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK3_CFG_W3                       ((0x1a4a  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, v_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, v_start
+#define VIU_OSD2_BLK0_CFG_W4                       ((0x1a64  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK1_CFG_W4                       ((0x1a65  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK2_CFG_W4                       ((0x1a66  << 2) + 0xd0100000)
+#define VIU_OSD2_BLK3_CFG_W4                       ((0x1a67  << 2) + 0xd0100000)
+// Bit    31 RW, burst_len_sel[2] of [2:0]
+// Bit    30 RW, byte_swap: In addition to endian control, further define
+//               whether to swap upper and lower byte within a 16-bit mem word.
+//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
+// Bit 29:22 R,  Reserved
+// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
+// Bit    19 R,  fifo_overflow
+//
+// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
+// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
+// Bit  9: 5 RW, hold_fifo_lines[4:0]
+// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
+// Bit     3 RW, fifo_sync_rst
+// Bit  2: 1 RW, endian
+// Bit     0 RW, urgent
+#define VIU_OSD2_FIFO_CTRL_STAT                    ((0x1a4b  << 2) + 0xd0100000)
+// Bit 31:24 R, Y or R
+// Bit 23:16 R, Cb or G
+// Bit 15: 8 R, Cr or B
+// Bit  7: 0 R, Output Alpha[8:1]
+#define VIU_OSD2_TEST_RDDATA                       ((0x1a4c  << 2) + 0xd0100000)
+// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
+// Bit 12: 0 RW, effective FIFO size when prot_en=1.
+#define VIU_OSD2_PROT_CTRL                         ((0x1a4e  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// VD1 path
+//------------------------------------------------------------------------------
+#define VD1_IF0_GEN_REG                            ((0x1a50  << 2) + 0xd0100000)
+#define VD1_IF0_CANVAS0                            ((0x1a51  << 2) + 0xd0100000)
+#define VD1_IF0_CANVAS1                            ((0x1a52  << 2) + 0xd0100000)
+#define VD1_IF0_LUMA_X0                            ((0x1a53  << 2) + 0xd0100000)
+#define VD1_IF0_LUMA_Y0                            ((0x1a54  << 2) + 0xd0100000)
+#define VD1_IF0_CHROMA_X0                          ((0x1a55  << 2) + 0xd0100000)
+#define VD1_IF0_CHROMA_Y0                          ((0x1a56  << 2) + 0xd0100000)
+#define VD1_IF0_LUMA_X1                            ((0x1a57  << 2) + 0xd0100000)
+#define VD1_IF0_LUMA_Y1                            ((0x1a58  << 2) + 0xd0100000)
+#define VD1_IF0_CHROMA_X1                          ((0x1a59  << 2) + 0xd0100000)
+#define VD1_IF0_CHROMA_Y1                          ((0x1a5a  << 2) + 0xd0100000)
+#define VD1_IF0_RPT_LOOP                           ((0x1a5b  << 2) + 0xd0100000)
+#define VD1_IF0_LUMA0_RPT_PAT                      ((0x1a5c  << 2) + 0xd0100000)
+#define VD1_IF0_CHROMA0_RPT_PAT                    ((0x1a5d  << 2) + 0xd0100000)
+#define VD1_IF0_LUMA1_RPT_PAT                      ((0x1a5e  << 2) + 0xd0100000)
+#define VD1_IF0_CHROMA1_RPT_PAT                    ((0x1a5f  << 2) + 0xd0100000)
+#define VD1_IF0_LUMA_PSEL                          ((0x1a60  << 2) + 0xd0100000)
+#define VD1_IF0_CHROMA_PSEL                        ((0x1a61  << 2) + 0xd0100000)
+#define VD1_IF0_DUMMY_PIXEL                        ((0x1a62  << 2) + 0xd0100000)
+#define VD1_IF0_LUMA_FIFO_SIZE                     ((0x1a63  << 2) + 0xd0100000)
+#define VD1_IF0_RANGE_MAP_Y                        ((0x1a6a  << 2) + 0xd0100000)
+#define VD1_IF0_RANGE_MAP_CB                       ((0x1a6b  << 2) + 0xd0100000)
+#define VD1_IF0_RANGE_MAP_CR                       ((0x1a6c  << 2) + 0xd0100000)
+#define VD1_IF0_GEN_REG2                           ((0x1a6d  << 2) + 0xd0100000)
+#define VD1_IF0_PROT_CNTL                          ((0x1a6e  << 2) + 0xd0100000)
+#define VD1_IF0_URGENT_CTRL                        ((0x1a6f  << 2) + 0xd0100000)
+//Bit 31    it true, disable clock, otherwise enable clock
+//Bit 30    soft rst bit
+//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
+//Bit 27:24 horizontal formatter initial phase
+//Bit 23    horizontal formatter repeat pixel 0 enable
+//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
+//Bit 20    horizontal formatter enable
+//Bit 19    if true, always use phase0 while vertical formater, meaning always
+//          repeat data, no interpolation
+//Bit 18    if true, disable vertical formatter chroma repeat last line
+//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
+//Bit 16    veritcal formatter repeat line 0 enable
+//Bit 15:12 vertical formatter skip line num at the beginning
+//Bit 11:8  vertical formatter initial phase
+//Bit 7:1   vertical formatter phase step (3.4)  
+//Bit 0     vertical formatter enable
+#define VIU_VD1_FMT_CTRL                           ((0x1a68  << 2) + 0xd0100000)
+//Bit 27:16  horizontal formatter width
+//Bit 11:0   vertical formatter width
+#define VIU_VD1_FMT_W                              ((0x1a69  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// VD2 path
+//------------------------------------------------------------------------------
+#define VD2_IF0_GEN_REG                            ((0x1a70  << 2) + 0xd0100000)
+#define VD2_IF0_CANVAS0                            ((0x1a71  << 2) + 0xd0100000)
+#define VD2_IF0_CANVAS1                            ((0x1a72  << 2) + 0xd0100000)
+#define VD2_IF0_LUMA_X0                            ((0x1a73  << 2) + 0xd0100000)
+#define VD2_IF0_LUMA_Y0                            ((0x1a74  << 2) + 0xd0100000)
+#define VD2_IF0_CHROMA_X0                          ((0x1a75  << 2) + 0xd0100000)
+#define VD2_IF0_CHROMA_Y0                          ((0x1a76  << 2) + 0xd0100000)
+#define VD2_IF0_LUMA_X1                            ((0x1a77  << 2) + 0xd0100000)
+#define VD2_IF0_LUMA_Y1                            ((0x1a78  << 2) + 0xd0100000)
+#define VD2_IF0_CHROMA_X1                          ((0x1a79  << 2) + 0xd0100000)
+#define VD2_IF0_CHROMA_Y1                          ((0x1a7a  << 2) + 0xd0100000)
+#define VD2_IF0_RPT_LOOP                           ((0x1a7b  << 2) + 0xd0100000)
+#define VD2_IF0_LUMA0_RPT_PAT                      ((0x1a7c  << 2) + 0xd0100000)
+#define VD2_IF0_CHROMA0_RPT_PAT                    ((0x1a7d  << 2) + 0xd0100000)
+#define VD2_IF0_LUMA1_RPT_PAT                      ((0x1a7e  << 2) + 0xd0100000)
+#define VD2_IF0_CHROMA1_RPT_PAT                    ((0x1a7f  << 2) + 0xd0100000)
+#define VD2_IF0_LUMA_PSEL                          ((0x1a80  << 2) + 0xd0100000)
+#define VD2_IF0_CHROMA_PSEL                        ((0x1a81  << 2) + 0xd0100000)
+#define VD2_IF0_DUMMY_PIXEL                        ((0x1a82  << 2) + 0xd0100000)
+#define VD2_IF0_LUMA_FIFO_SIZE                     ((0x1a83  << 2) + 0xd0100000)
+#define VD2_IF0_RANGE_MAP_Y                        ((0x1a8a  << 2) + 0xd0100000)
+#define VD2_IF0_RANGE_MAP_CB                       ((0x1a8b  << 2) + 0xd0100000)
+#define VD2_IF0_RANGE_MAP_CR                       ((0x1a8c  << 2) + 0xd0100000)
+#define VD2_IF0_GEN_REG2                           ((0x1a8d  << 2) + 0xd0100000)
+#define VD2_IF0_PROT_CNTL                          ((0x1a8e  << 2) + 0xd0100000)
+#define VD2_IF0_URGENT_CTRL                        ((0x1a8f  << 2) + 0xd0100000)
+//Bit 31    it true, disable clock, otherwise enable clock
+//Bit 30    soft rst bit
+//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
+//Bit 27:24 horizontal formatter initial phase
+//Bit 23    horizontal formatter repeat pixel 0 enable
+//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
+//Bit 20    horizontal formatter enable
+//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
+//Bit 16    veritcal formatter repeat line 0 enable
+//Bit 15:12 vertical formatter skip line num at the beginning
+//Bit 11:8  vertical formatter initial phase
+//Bit 7:1   vertical formatter phase step (3.4)  
+//Bit 0     vertical formatter enable
+#define VIU_VD2_FMT_CTRL                           ((0x1a88  << 2) + 0xd0100000)
+//Bit 27:16  horizontal formatter width
+//Bit 11:0   vertical formatter width
+#define VIU_VD2_FMT_W                              ((0x1a89  << 2) + 0xd0100000)
+//todo add comment
+#define LDIM_STTS_GCLK_CTRL0                       ((0x1a90  << 2) + 0xd0100000)
+#define LDIM_STTS_CTRL0                            ((0x1a91  << 2) + 0xd0100000)
+#define LDIM_STTS_WIDTHM1_HEIGHTM1                 ((0x1a92  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_COEF00_01                 ((0x1a93  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_COEF02_10                 ((0x1a94  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_COEF11_12                 ((0x1a95  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_COEF20_21                 ((0x1a96  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_COEF22                    ((0x1a97  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_OFFSET0_1                 ((0x1a98  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_OFFSET2                   ((0x1a99  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_PRE_OFFSET0_1             ((0x1a9a  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_PRE_OFFSET2               ((0x1a9b  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_HL_COLOR                  ((0x1a9c  << 2) + 0xd0100000)
+#define LDIM_STTS_MATRIX_PROBE_POS                 ((0x1a9d  << 2) + 0xd0100000)
+//read only
+#define LDIM_STTS_MATRIX_PROBE_COLOR               ((0x1a9e  << 2) + 0xd0100000)
+//Bit 31, local dimming statistic enable
+//Bit 29, 1: output region histogram 16bit 0:output region histogram 20bit 
+//Bit 28, eol enable
+//Bit 27:25, vertical line overlap number for max finding
+//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
+//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
+//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
+//Bit 15:14, 1: region read index auto increase per block read finished to VDIN_LDIM_STTS_HIST_READ_REGION 
+//			 2: region read index auto increase per read finished to VDIN_LDIM_STTS_HIST_READ_REGION
+//			 0/3: disable read index self increase
+//Bit 13:8, region read sub index, which mux the hist & max-finding result to cbus port, refer to LDIM_STTS_HIST_READ_REGION
+//Bit 6:0, region read index
+#define LDIM_STTS_HIST_REGION_IDX                  ((0x1aa0  << 2) + 0xd0100000)
+//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
+//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
+//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
+//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
+//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
+//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
+//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
+//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
+//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
+//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
+//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
+//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
+//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
+#define LDIM_STTS_HIST_SET_REGION                  ((0x1aa1  << 2) + 0xd0100000)
+//if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data. 
+//if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0. 
+//output sequence as rd_sub_idx from 0~47: {max_comp2, comp0_hist0}, {max_comp1, comp0_hist1}, {max_comp0, comp0_hist2}, 
+//										   comp0_hist3 ... comp2_hist16
+//if LDIM_STTS_HIST_REGION_IDX[29] == 1, that is output hist with 16bit data. 
+//if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0. 
+//output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
+//										   comp0_hist3 ... comp2_hist16
+//if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data. 
+//if LDIM_STTS_HIST_REGION_IDX[21] == 1, that is output 32hist bins in comp 0. 
+//output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
+//										   comp0_hist3 ...comp0_hist31 ... comp1_hist16
+#define LDIM_STTS_HIST_READ_REGION                 ((0x1aa2  << 2) + 0xd0100000)
+//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di if1 chroma path
+//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di if1 luma path
+#define DI_IF1_URGENT_CTRL                         ((0x1aa3  << 2) + 0xd0100000)
+//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
+//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
+#define DI_INP_URGENT_CTRL                         ((0x1aa4  << 2) + 0xd0100000)
+//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di mem chroma path
+//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di mem luma path
+#define DI_MEM_URGENT_CTRL                         ((0x1aa5  << 2) + 0xd0100000)
+//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di chan2 chroma path
+//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di chan2 luma path
+#define DI_CHAN2_URGENT_CTRL                       ((0x1aa6  << 2) + 0xd0100000)
+//DEINTERLACE module start from 8'h90 end to 8'hff
+// -----------------------------------------------
+// CBUS_BASE:  MAD_VCBUS_BASE = 0x17
+// -----------------------------------------------
+#define DI_PRE_CTRL                                ((0x1700  << 2) + 0xd0100000)
+// bit 31,      cbus_pre_frame_rst
+// bit 30,      cbus_pre_soft_rst
+// bit 29,      pre_field_num 
+// bit 27:26,   mode_444c422
+// bit 25,      di_cont_read_en
+// bit 24:23,   mode_422c444
+// bit 22,      mtn_after_nr
+// bit 21:16,   pre_hold_fifo_lines
+// bit 15,      nr_wr_by
+// bit 14,      use_vdin_go_line
+// bit 13,      di_prevdin_en
+// bit 12,      di_pre_viu_link
+// bit 11,      di_pre_repeat
+// bit 10,      di_pre_drop_1st
+// bit  9,      di_buf2_en
+// bit  8,      di_chan2_en
+// bit  7,      prenr_hist_en
+// bit  6,      chan2_hist_en
+// bit  5,      hist_check_en
+// bit  4,      check_after_nr
+// bit  3,      check222p_en
+// bit  2,      check322p_en
+// bit  1,      mtn_en
+// bit  0,      nr_en
+#define DI_POST_CTRL                               ((0x1701  << 2) + 0xd0100000)
+// bit 31,      cbus_post_frame_rst
+// bit 30,      cbus_post_soft_rst
+// bit 29,      post_field_num
+// bit 21:16,   post_hold_fifo_lines
+// bit 13,      prepost_link
+// bit 12,      di_post_viu_link
+// bit 11,      di_post_repeat
+// bit 10,      di_post_drop_1st
+// bit  9,      mif0_to_vpp_en
+// bit  8,      di_vpp_out_en
+// bit  7,      di_wr_bk_en
+// bit  6,      di_mux_en
+// bit  5,      di_blend_en
+// bit  4,      di_mtnp_read_en
+// bit  3,      di_mtn_buf_en
+// bit  2,      di_ei_en
+// bit  1,      di_buf1_en
+// bit  0,      di_buf0_en
+#define DI_POST_SIZE                               ((0x1702  << 2) + 0xd0100000)
+//bit 28:16,    vsize1post
+//bit 12:0,     hsize1post
+#define DI_PRE_SIZE                                ((0x1703  << 2) + 0xd0100000)
+//bit 28:16,    vsize1pre
+//bit 12:0,     hsize1pre
+#define DI_EI_CTRL0                                ((0x1704  << 2) + 0xd0100000)
+//bit 23:16,    ei0_filter[2:+]  abs_diff_left>filter && ...right>filter && ...top>filter && ...bot>filter -> filter
+//bit 15:8,     ei0_threshold[2:+] 
+//bit 3,        ei0_vertical
+//bit 2,        ei0_bpscf2
+//bit 1,        ei0_bpsfar1
+#define DI_EI_CTRL1                                ((0x1705  << 2) + 0xd0100000)
+//bit 31:24,    ei0_diff
+//bit 23:16,    ei0_angle45
+//bit 15:8,     ei0_peak
+//bit 7:0,      ei0_cross
+#define DI_EI_CTRL2                                ((0x1706  << 2) + 0xd0100000)
+//bit 31:24,    ei0_close2
+//bit 23:16,    ei0_close1
+//bit 15:8,     ei0_far2
+//bit 7:0,      ei0_far1
+#define DI_NR_CTRL0                                ((0x1707  << 2) + 0xd0100000)
+//bit 26,       nr_cue_en
+//bit 25,       nr2_en
+#define DI_NR_CTRL1                                ((0x1708  << 2) + 0xd0100000)
+//bit 31:30,    mot_p1txtcore_mode  
+//bit 29:24,    mot_p1txtcore_clmt  
+//bit 21:16,    mot_p1txtcore_ylmt  
+//bit 15:8,     mot_p1txtcore_crate  
+//bit 7:0,      mot_p1txtcore_yrate  
+#define DI_NR_CTRL2                                ((0x1709  << 2) + 0xd0100000)
+//bit 29:24,    mot_curtxtcore_clmt  
+//bit 21:16,    mot_curtxtcore_ylmt  
+//bit 15:8,     mot_curtxtcore_crate  
+//bit 7:0,      mot_curtxtcore_yrate  
+//`define DI_NR_CTRL3               8'h0a
+//no use
+//`define DI_MTN_CTRL               8'h0b
+//no use
+#define DI_MTN_CTRL1                               ((0x170c  << 2) + 0xd0100000)
+//bit 13 ,      me enable
+//bit 12 ,      me autoenable
+//bit 11:8,		mtn_paramtnthd
+//bit 7:0,      mtn_parafltthd
+#define DI_BLEND_CTRL                              ((0x170d  << 2) + 0xd0100000)
+//bit 31,      blend_1_en         
+//bit 30,      blend_mtn_lpf      
+//bit 28,      post_mb_en         
+//bit 27,      blend_mtn3p_max    
+//bit 26,      blend_mtn3p_min    
+//bit 25,      blend_mtn3p_ave    
+//bit 24,      blend_mtn3p_maxtb  
+//bit 23,      blend_mtn_flt_en   
+//bit 22,      blend_data_flt_en  
+//bit 21:20,   blend_top_mode     
+//bit 19,      blend_reg3_enable  
+//bit 18,      blend_reg2_enable  
+//bit 17,      blend_reg1_enable  
+//bit 16,      blend_reg0_enable  
+//bit 15:14,   blend_reg3_mode    
+//bit 13:12,   blend_reg2_mode    
+//bit 11:10,   blend_reg1_mode    
+//bit 9:8,     blend_reg0_mode    
+//bit 7:0,     kdeint             
+//`define DI_BLEND_CTRL1            8'h0e
+//no use
+//`define DI_BLEND_CTRL2            8'h0f
+//no use
+#define DI_BLEND_REG0_X                            ((0x1710  << 2) + 0xd0100000)
+//bit 27:16,   blend_reg0_startx
+//bit 11:0,    blend_reg0_endx
+#define DI_BLEND_REG0_Y                            ((0x1711  << 2) + 0xd0100000)
+#define DI_BLEND_REG1_X                            ((0x1712  << 2) + 0xd0100000)
+#define DI_BLEND_REG1_Y                            ((0x1713  << 2) + 0xd0100000)
+#define DI_BLEND_REG2_X                            ((0x1714  << 2) + 0xd0100000)
+#define DI_BLEND_REG2_Y                            ((0x1715  << 2) + 0xd0100000)
+#define DI_BLEND_REG3_X                            ((0x1716  << 2) + 0xd0100000)
+#define DI_BLEND_REG3_Y                            ((0x1717  << 2) + 0xd0100000)
+#define DI_CLKG_CTRL                               ((0x1718  << 2) + 0xd0100000)
+//bit 31:24,   pre_gclk_ctrl     no clk gate control. if ==1, module clk is not gated (always on). [3] for pulldown,[2] for mtn_1,[1] for mtn_0,[0] for nr
+//bit 23:16,   post_gclk_ctrl    no clk gate control. [4] for ei_1, [3] for ei_0,[2] for ei_top, [1] for blend_1, [0] for blend_0
+//bit 1,       di_gate_all       clk shut down. if ==1 , all di clock shut down
+//bit 0,       di_no_clk_gate    no clk gate control.     if di_gated_all==0 and di_no_clk_gate ==1, all di clock is always working.                         
+#define DI_EI_CTRL3                                ((0x1719  << 2) + 0xd0100000)
+//bit 31,      reg_ei_1
+//bit 30,      reg_demon_en
+//bit 26:24,   reg_demon_mux
+//bit 23:20,   reg_right_win
+//bit 19:16,   reg_left_win
+//bit 7:4,     reg_ei_sadm_quatize_margin
+//bit 1:0,     reg_ei_sad_relative_mode
+#define DI_EI_CTRL4                                ((0x171a  << 2) + 0xd0100000)
+//bit 29,      reg_ei_caldrt_ambliike2_biasvertical
+//bit 28:24,   reg_ei_caldrt_addxla2list_drtmax
+//bit 22:20,   reg_ei_caldrt_addxla2list_signm0th
+//bit 19,      reg_ei_caldrt_addxla2list_mode
+//bit 18:16,   reg_ei_signm_sad_cor_rate
+//bit 15:12,   reg_ei_signm_sadi_cor_rate
+//bit 11:6,    reg_ei_signm_sadi_cor_ofst
+//bit 5:0,     reg_ei_signm_sad_ofst
+#define DI_EI_CTRL5                                ((0x171b  << 2) + 0xd0100000)
+//bit 30:28,   reg_ei_caldrt_cnflcctchk_frcverthrd
+//bit 26:24,   reg_ei_caldrt_cnflctchk_mg
+//bit 23:22,   reg_ei_caldrt_cnflctchk_ws
+//bit 21,      reg_ei_caldrt_cnflctchk_en
+//bit 20,      reg_ei_caldrt_verfrc_final_en
+//bit 19,      reg_ei_caldrt_verfrc_retimflt_en
+//bit 18:16,   reg_ei_caldrt_verftc_eithratemth
+//bit 15,      reg_ei_caldrt_verfrc_retiming_en
+//bit 14:12,   reg_ei_caldrt_verfrc_bothratemth
+//bit 11:9,    reg_ei_caldrt_ver_thrd
+//bit 8:4,     reg_ei_caldrt_addxla2list_drtmin
+//bit 3:0,     reg_ei_caldrt_addxla2list_drtlimit
+#define DI_EI_CTRL6                                ((0x171c  << 2) + 0xd0100000)
+//bit 31:24,   reg_ei_caldrt_abext_sad12thhig
+//bit 23:16,   reg_ei_caldrt_abext_sad00thlow
+//bit 15:8,    reg_ei_caldrt_abext_sad12thlow
+//bit 6:4,     reg_ei_caldrt_abext_ratemth
+//bit 2:0,     reg_ei_caldrt_abext_drtthrd
+#define DI_EI_CTRL7                                ((0x171d  << 2) + 0xd0100000)
+//bit 29,      reg_ei_caldrt_xlanopeak_codien
+//bit 28:24,   reg_ei_caldrt_xlanopeak_drtmax
+//bit 23,      reg_ei_caldrt_xlanopeak_en
+//bit 28:24,   reg_ei_caldrt_abext_monotrnd_alpha
+//bit 28:24,   reg_ei_caldrt_abext_mononum12_thrd
+//bit 28:24,   reg_ei_caldrt_abext_mononum00_thrd
+//bit 28:24,   reg_ei_caldrt_abext_sad00rate
+//bit 28:24,   reg_ei_caldrt_abext_sad12rate
+//bit 28:24,   reg_ei_caldrt_abext_sad00thhig          
+#define DI_EI_CTRL8                                ((0x171e  << 2) + 0xd0100000)
+//bit 30:28,   reg_ei_assign_headtail_magin
+//bit 26:24,   reg_ei_retime_lastcurpncnfltchk_mode
+//bit 22:21,   reg_ei_retime_lastcurpncnfltchk_drtth
+//bit 20,      reg_ei_caldrt_histchk_cnfid
+//bit 19:16,   reg_ei_caldrt_histchk_thrd
+//bit 15,      reg_ei_caldrt_histchk_abext
+//bit 14,      reg_ei_caldrt_histchk_npen
+//bit 13:11,   reg_ei_caldrt_amblike2_drtmg
+//bit 10:8,    reg_ei_caldrt_amblike2_valmg
+//bit 7:4,     reg_ei_caldrt_amblike2_alpha
+//bit 3:0,     reg_ei_caldrt_amblike2_drtth
+#define DI_EI_CTRL9                                ((0x171f  << 2) + 0xd0100000)
+//bit 31:28,   reg_ei_caldrt_hcnfcheck_frcvert_xla_th3
+//bit 27,      reg_ei_caldrt_hcnfcheck_frcvert_xla_en
+//bit 26:24,   reg_ei_caldrt_conf_drtth
+//bit 23:20,   reg_ei_caldrt_conf_absdrtth
+//bit 19:18,   reg_ei_caldrt_abcheck_mode1
+//bit 17:16,   reg_ei_caldrt_abcheck_mode0
+//bit 15:12,   reg_ei_caldrt_abcheck_drth1
+//bit 11:8,    reg_ei_caldrt_abcheck_drth0
+//bit 6:4,     reg_ei_caldrt_abpnchk1_th
+//bit 1,       reg_ei_caldrt_abpnchk1_en
+//bit 0,       reg_ei_caldrt_abpnchk0_en
+#define DI_EI_CTRL10                               ((0x1793  << 2) + 0xd0100000)
+//bit 31:28,   reg_ei_caldrt_hstrrgchk_drtth
+//bit 27:24,   reg_ei_caldrt_hstrrgchk_frcverthrd
+//bit 23:20,   reg_ei_caldrt_hstrrgchk_mg
+//bit 19,      reg_ei_caldrt_hstrrgchk_1sidnul
+//bit 18,      reg_ei_caldrt_hstrrgchk_excpcnf
+//bit 17:16,   reg_ei_caldrt_hstrrgchk_ws
+//bit 15,      reg_ei_caldrt_hstrrgchk_en
+//bit 14:13,   reg_ei_caldrt_hpncheck_mode
+//bit 12,      reg_ei_caldrt_hpncheck_mute
+//bit 11:9,    reg_ei_caldrt_hcnfcheck_mg2
+//bit 8:6,     reg_ei_caldrt_hcnfcheck_mg1
+//bit 5:4,     reg_ei_caldrt_hcnfcheck_mode
+//bit 3:0,     reg_ei_caldrt_hcnfcheck_mg2
+#define DI_EI_CTRL11                               ((0x179e  << 2) + 0xd0100000)
+//bit 30:29,   reg_ei_amb_detect_mode
+//bit 28:24,   reg_ei_amb_detect_winth
+//bit 23:21,   reg_ei_amb_decide_rppth
+//bit 20:19,   reg_ei_retime_lastmappncnfltchk_drtth
+//bit 18:16,   reg_ei_retime_lastmappncnfltchk_mode
+//bit 15:14,   reg_ei_retime_lastmapvertfrcchk_mode
+//bit 13:12,   reg_ei_retime_lastvertfrcchk_mode
+//bit 11:8,    reg_ei_retime_lastpnchk_drtth
+//bit 6,       reg_ei_retime_lastpnchk_en
+//bit 5:4,     reg_ei_retime_mode
+//bit 3,       reg_ei_retime_last_en
+//bit 2,       reg_ei_retime_ab_en
+//bit 1,       reg_ei_caldrt_hstrvertfrcchk_en
+//bit 0,       reg_ei_caldrt_hstrrgchk_mode
+#define DI_EI_CTRL12                               ((0x179f  << 2) + 0xd0100000)
+//bit 31:28,   reg_ei_drtdelay2_lmt
+//bit 27:26,   reg_ei_drtdelay2_notver_lrwin
+//bit 25:24,   reg_ei_drtdelay_mode
+//bit 23,      reg_ei_drtdelay2_mode
+//bit 22:20,   reg_ei_assign_xla_signm0th
+//bit 19,      reg_ei_assign_pkbiasvert_en
+//bit 18,      reg_ei_assign_xla_en
+//bit 17:16,   reg_ei_assign_xla_mode
+//bit 15:12,   reg_ei_assign_nlfilter_magin
+//bit 11:8,    reg_ei_localsearch_maxrange
+//bit 7:4,     reg_ei_xla_drtth
+//bit 3:0,     reg_ei_flatmsad_thrd
+#define DI_EI_CTRL13                               ((0x17a8  << 2) + 0xd0100000)
+//bit 27:24,   reg_ei_int_drt2x_chrdrt_limit
+//bit 23:20,   reg_ei_int_drt16x_core
+//bit 19:16,   reg_ei_int_drtdelay2_notver_cancv
+//bit 15:8,    reg_ei_int_drtdelay2_notver_sadth
+//bit 7:0,     reg_ei_int_drtdelay2_vlddrt_sadth
+#define DI_EI_XWIN0                                ((0x1798  << 2) + 0xd0100000)
+//bit 27:16,   ei_xend0
+//bit 11:0,    ei_xstart0
+#define DI_EI_XWIN1                                ((0x1799  << 2) + 0xd0100000)
+// DEINTERLACE mode check.
+#define DI_MC_REG0_X                               ((0x1720  << 2) + 0xd0100000)
+//bit 27:16,   mc_reg0_start_x 
+//bit 11:0,    mc_reg0_end_x 
+#define DI_MC_REG0_Y                               ((0x1721  << 2) + 0xd0100000)
+#define DI_MC_REG1_X                               ((0x1722  << 2) + 0xd0100000)
+#define DI_MC_REG1_Y                               ((0x1723  << 2) + 0xd0100000)
+#define DI_MC_REG2_X                               ((0x1724  << 2) + 0xd0100000)
+#define DI_MC_REG2_Y                               ((0x1725  << 2) + 0xd0100000)
+#define DI_MC_REG3_X                               ((0x1726  << 2) + 0xd0100000)
+#define DI_MC_REG3_Y                               ((0x1727  << 2) + 0xd0100000)
+#define DI_MC_REG4_X                               ((0x1728  << 2) + 0xd0100000)
+#define DI_MC_REG4_Y                               ((0x1729  << 2) + 0xd0100000)
+#define DI_MC_32LVL0                               ((0x172a  << 2) + 0xd0100000)
+//bit 31:24,   mc_reg2_32lvl
+//bit 23:16,   mc_reg1_32lvl
+//bit 15:8,    mc_reg0_32lvl
+//bit 7:0,     field_32lvl
+#define DI_MC_32LVL1                               ((0x172b  << 2) + 0xd0100000)
+//bit 15:8,    mc_reg3_32lvl
+//bit 7:0,     mc_reg4_32lvl
+#define DI_MC_22LVL0                               ((0x172c  << 2) + 0xd0100000)
+//bit 31:16,   mc_reg0_22lvl
+//bit 15:0,    field_22lvl
+#define DI_MC_22LVL1                               ((0x172d  << 2) + 0xd0100000)
+//bit 31:16,   mc_reg2_22lvl
+//bit 15:0,    mc_reg1_22lvl
+#define DI_MC_22LVL2                               ((0x172e  << 2) + 0xd0100000)
+//bit 31:16,   mc_reg4_22lvl
+//bit 15:0,    mc_reg3_22lvl
+#define DI_MC_CTRL                                 ((0x172f  << 2) + 0xd0100000)
+//bit 4,       mc_reg4_en 
+//bit 3,       mc_reg3_en 
+//bit 2,       mc_reg2_en 
+//bit 1,       mc_reg1_en 
+//bit 0,       mc_reg0_en 
+#define DI_INTR_CTRL                               ((0x1730  << 2) + 0xd0100000)
+#define DI_INFO_ADDR                               ((0x1731  << 2) + 0xd0100000)
+#define DI_INFO_DATA                               ((0x1732  << 2) + 0xd0100000)
+#define DI_PRE_HOLD                                ((0x1733  << 2) + 0xd0100000)
+#define DI_MTN_1_CTRL1                             ((0x1740  << 2) + 0xd0100000)
+//bit 31,      mtn_1_en
+//bit 30,      mtn_init
+//bit 29,      di2nr_txt_en
+//bit 28,      di2nr_txt_mode
+//bit 27:24,   mtn_def
+//bit 23:16,   mtn_adp_yc
+//bit 15:8,    mtn_adp_2c
+//bit 7:0,     mtn_adp_2y
+#define DI_MTN_1_CTRL2                             ((0x1741  << 2) + 0xd0100000)
+//bit 31:24,   mtn_ykinter
+//bit 23:16,   mtn_ckinter
+//bit 15:8,    mtn_ykintra
+//bit  7:0,    mtn_ckintra
+#define DI_MTN_1_CTRL3                             ((0x1742  << 2) + 0xd0100000)
+//bit 31:24,   mtn_tyrate 
+//bit 23:16,   mtn_tcrate
+//bit 15: 8,   mtn_mxcmby
+//bit  7: 0,   mtn_mxcmbc
+#define DI_MTN_1_CTRL4                             ((0x1743  << 2) + 0xd0100000)
+//bit 31:24,   mtn_tcorey
+//bit 23:16,   mtn_tcorec
+//bit 15: 8,   mtn_minth
+//bit  7: 0,   mtn_maxth
+#define DI_MTN_1_CTRL5                             ((0x1744  << 2) + 0xd0100000)
+//bit 31:28,   mtn_m1b_extnd
+//bit 27:24,   mtn_m1b_errod
+//bit 19:18,   mtn_replace_cbyy
+//bit 17:16,   mtn_replace_ybyc
+//bit 15: 8,   mtn_core_ykinter
+//bit  7: 0,   mtn_core_ckinter
+#define DI_MTN_1_CTRL6                             ((0x17a9  << 2) + 0xd0100000)
+//bit 31:24,   mtn_m1b_extnd
+//bit 23:16,   mtn_m1b_errod
+//bit 15: 8,   mtn_core_ykinter
+//bit  7: 0,   mtn_core_ckinter
+#define DI_MTN_1_CTRL7                             ((0x17aa  << 2) + 0xd0100000)
+//bit 31:24,   mtn_core_mxcmby
+//bit 23:16,   mtn_core_mxcmbc
+//bit 15: 8,   mtn_core_y     
+//bit  7: 0,   mtn_core_c     
+#define DI_MTN_1_CTRL8                             ((0x17ab  << 2) + 0xd0100000)
+//bit 31:24,   mtn_fcore_ykinter
+//bit 23:16,   mtn_fcore_ckinter
+//bit 15: 8,   mtn_fcore_ykintra
+//bit  7: 0,   mtn_fcore_ckintra
+#define DI_MTN_1_CTRL9                             ((0x17ac  << 2) + 0xd0100000)
+//bit 31:24,   mtn_fcore_2yrate 
+//bit 23:16,   mtn_fcore_2crate
+//bit 15: 8,   mtn_fcore_y     
+//bit  7: 0,   mtn_fcore_c     
+#define DI_MTN_1_CTRL10                            ((0x17ad  << 2) + 0xd0100000)
+//bit 27:24,   mtn_motfld0 
+//bit 19:16,   mtn_stlfld0  
+//bit 11: 8,   mtn_motfld1  
+//bit  3: 0,   mtn_stlfld1  
+#define DI_MTN_1_CTRL11                            ((0x17ae  << 2) + 0xd0100000)
+//bit 27:24,   mtn_smotevn
+//bit 20:16,   mtn_smotodd
+//bit 11: 8,   mtn_sstlevn
+//bit  4: 0,   mtn_sstlodd
+#define DI_MTN_1_CTRL12                            ((0x17af  << 2) + 0xd0100000)
+//bit 31:24,   mtn_mgain
+//bit 17:16,   mtn_mmode
+//bit 15: 8,   mtn_sthrd
+//bit  4: 0,   mtn_sgain
+//// DET 3D REG DEFINE BEGIN ////
+//// 8'h34~8'h3f
+#define DET3D_MOTN_CFG                             ((0x1734  << 2) + 0xd0100000)
+//Bit 16,	reg_det3d_intr_en	        Det3d interrupt enable
+//Bit 9:8,	reg_Det3D_Motion_Mode	    U2  Different mode for Motion Calculation of Luma and Chroma: 
+//                                      0: MotY, 1: (2*MotY + (MotU + MotV))/4; 2: Max(MotY, MotU,MotV); 3:Max(MotY, (MotU+MotV)/2)
+//Bit 7:4,	reg_Det3D_Motion_Core_Rate	U4  K Rate to Edge (HV) details for coring of Motion Calculations, normalized to 32
+//Bit 3:0,	reg_Det3D_Motion_Core_Thrd	U4  2X: static coring value for Motion Detection.
+#define DET3D_CB_CFG                               ((0x1735  << 2) + 0xd0100000)
+//Bit 7:4,	reg_Det3D_ChessBd_NHV_ofst	U4,  Noise immune offset for NON-Horizotnal or vertical combing detection.  
+//Bit 3:0,	reg_Det3D_ChessBd_HV_ofst	U4,  Noise immune offset for Horizotnal or vertical combing detection.  
+#define DET3D_SPLT_CFG                             ((0x1736  << 2) + 0xd0100000)
+//Bit 7:4,	reg_Det3D_SplitValid_ratio	U4,  Ratio between max_value and the avg_value of the edge mapping for split line valid detection. 
+//                                      The smaller of this value, the easier of the split line detected. 
+//Bit 3:0,	reg_Det3D_AvgIdx_ratio	    U4,  Ratio to the avg_value of the edge mapping for split line position estimation. 
+//                                      The smaller of this value, the more samples will be added to the estimation.
+#define DET3D_HV_MUTE                              ((0x1737  << 2) + 0xd0100000)
+//Bit 23:20, reg_Det3D_Edge_Ver_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Top and Bottom border part. 
+//Bit 19:16, reg_Det3D_Edge_Hor_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Left and right border part. 
+//Bit 15:12, reg_Det3D_ChessBd_Ver_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part 
+//Bit 11:8,	 reg_Det3D_ChessBd_Hor_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part 
+//Bit 7:4,	 reg_Det3D_STA8X8_Ver_Mute	U4  1X: Vertical pixels to be mute from 8x8 statistics calculation in each block. 
+//Bit 3:0,	 reg_Det3D_STA8X8_Hor_Mute	U4  1X: Horizontal pixels to be mute from 8x8 statistics calculation in each block. 
+#define DET3D_MAT_STA_P1M1                         ((0x1738  << 2) + 0xd0100000)
+//Bit 31:24, reg_Det3D_STA8X8_P1_K0_R8	U8  SAD to SAI ratio to decide P1, normalized to 256 (0.8)
+//Bit 23:16, reg_Det3D_STA8X8_P1_K1_R7	U8  SAD to ENG ratio to decide P1, normalized to 128 (0.5)
+//Bit 15:8,	 reg_Det3D_STA8X8_M1_K0_R6	U8  SAD to SAI ratio to decide M1, normalized to 64  (1.1)
+//Bit 7:0,	 reg_Det3D_STA8X8_M1_K1_R6	U8  SAD to ENG ratio to decide M1, normalized to 64  (0.8)
+#define DET3D_MAT_STA_P1TH                         ((0x1739  << 2) + 0xd0100000)
+//Bit 23:16, reg_Det3D_STAYUV_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (100)   
+//Bit 15:8,	 reg_Det3D_STAEDG_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (80)
+//Bit 7:0,	 reg_Det3D_STAMOT_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (48)
+#define DET3D_MAT_STA_M1TH                         ((0x173a  << 2) + 0xd0100000)
+//Bit 23:16, reg_Det3D_STAYUV_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (100)
+//Bit 15:8,	 reg_Det3D_STAEDG_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (80)
+//Bit 7:0,	 reg_Det3D_STAMOT_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (64)
+#define DET3D_MAT_STA_RSFT                         ((0x173b  << 2) + 0xd0100000)
+//Bit 5:4,	 reg_Det3D_STAYUV_RSHFT	    U2  YUV statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping: 
+//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
+//Bit 3:2,	 reg_Det3D_STAEDG_RSHFT	    U2  Horizontal and Vertical Edge Statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping: 
+//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
+//Bit 1:0,	 reg_Det3D_STAMOT_RSHFT	    U2  Motion SAD and SAI calculation result right shift bits to accommodate the 12bits clipping: 
+//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
+#define DET3D_MAT_SYMTC_TH                         ((0x173c  << 2) + 0xd0100000)
+//Bit 31:24, reg_Det3D_STALUM_symtc_Th	  U8  threshold to decide if the Luma statistics is TB or LR symmetric. 
+//Bit 23:16, reg_Det3D_STACHR_symtc_Th	  U8  threshold to decide if the Chroma (UV) statistics is TB or LR symmetric. 
+//Bit 15:8,	 reg_Det3D_STAEDG_symtc_Th	  U8  threshold to decide if the Horizontal and Vertical Edge statistics is TB or LR symmetric. 
+//Bit 7:0,	 reg_Det3D_STAMOT_symtc_Th	  U8  threshold to decide if the Motion statistics is TB or LR symmetric. 
+#define DET3D_RO_DET_CB_HOR                        ((0x173d  << 2) + 0xd0100000)
+//Bit 31:16, RO_Det3D_ChessBd_NHor_value    U16  X64: number of Pixels of Horizontally Surely NOT matching Chessboard pattern.
+//Bit 15:0,	 RO_Det3D_ChessBd_Hor_value	    U16  X64: number of Pixels of Horizontally Surely matching Chessboard pattern.
+#define DET3D_RO_DET_CB_VER                        ((0x173e  << 2) + 0xd0100000)
+//Bit 31:16, RO_Det3D_ChessBd_NVer_value	U16  X64: number of Pixels of Vertically Surely NOT matching Chessboard pattern.
+//Bit 15:0,	 RO_Det3D_ChessBd_Ver_value	    U16  X64: number of Pixels of Vertically Surely matching Chessboard pattern.
+#define DET3D_RO_SPLT_HT                           ((0x173f  << 2) + 0xd0100000)
+//Bit 24,	 RO_Det3D_Split_HT_valid	U1  horizontal LR split border detected valid signal for top half picture
+//Bit 20:16, RO_Det3D_Split_HT_pxnum	U5  number of pixels included for the LR split position estimation for top half picture
+//Bit 9:0,	 RO_Det3D_Split_HT_idxX4	S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+//// DET 3D REG DEFINE END ////
+//// NR2 REG DEFINE BEGIN////
+#define NR2_MET_NM_CTRL                            ((0x1745  << 2) + 0xd0100000)
+//Bit 28,	   reg_NM_reset	          Reset to the status of the Loop filter.
+//Bit 27:24,   reg_NM_calc_length	  Length mode of the Noise measurement sample number for statistics.
+//                                    0:  256 samples;    1: 512 samples;    2: 1024 samples;   X: 2^(8+x) samples
+//Bit 23:20,   reg_NM_inc_step	      Loop filter input gain increase step. 
+//Bit 19:16,   reg_NM_dec_step	      Loop filter input gain decrease step. 
+//Bit 15:8,	   reg_NM_YHPmot_thrd	  Luma channel HP portion motion for condition of pixels included in Luma Noise measurement. 
+//Bit 7:0,	   reg_NM_CHPmot_thrd	  Chroma channel HP portion motion for condition of pixels included in Chroma Noise measurement. 
+#define NR2_MET_NM_YCTRL                           ((0x1746  << 2) + 0xd0100000)
+//Bit 31:28,   reg_NM_YPLL_target	      Target rate of NM_Ynoise_thrd to mean of the Luma Noise 
+//Bit 27:24,   reg_NM_YLPmot_thrd	      Luma channel LP portion motion for condition of pixels included in Luma Noise measurement. 
+//Bit 23:16,   reg_NM_YHPmot_thrd_min	  Minimum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement. 
+//Bit 15:8,	   reg_NM_YHPmot_thrd_max	  Maximum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement. 
+//Bit 7:0,	   reg_NM_Ylock_rate	      Rate to decide whether the Luma noise measurement is lock or not.
+#define NR2_MET_NM_CCTRL                           ((0x1747  << 2) + 0xd0100000)
+//Bit 31:28,	reg_NM_CPLL_target	     Target rate of NM_Cnoise_thrd to mean of the Chroma Noise 
+//Bit 27:24,	reg_NM_CLPmot_thrd	     Chroma channel LP portion motion for condition of pixels included in Chroma Noise measurement. 
+//Bit 23:16,	reg_NM_CHPmot_thrd_min	 Minimum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement. 
+//Bit 15:8,	    reg_NM_CHPmot_thrd_max	 Maximum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement. 
+//Bit 7:0,	    reg_NM_Clock_rate	     Rate to decide whether the Chroma noise measurement is lock or not;
+#define NR2_MET_NM_TNR                             ((0x1748  << 2) + 0xd0100000)
+//Bit 25,	    ro_NM_TNR_Ylock	         Read-only register to tell ifLuma channel noise measurement is locked or not. 
+//Bit 24,	    ro_NM_TNR_Clock	         Read-only register to tell if Chroma channel noise measurement is locked or not. 
+//Bit 23:12,	ro_NM_TNR_Ylevel	     Read-only register to give Luma channel noise level. It was 16x of pixel difference in 8 bits of YHPmot. 
+//Bit 11:0,	ro_NM_TNR_Clevel	         Read-only register to give Chroma channel noise level. It was 16x of pixel difference in 8 bits of CHPmot. 
+#define NR2_MET_NMFRM_TNR_YLEV                     ((0x1749  << 2) + 0xd0100000)
+//Bit 28:0,	ro_NMFrm_TNR_Ylevel	         Frame based Read-only register to give Luma channel noise level within one frame/field. 
+#define NR2_MET_NMFRM_TNR_YCNT                     ((0x174a  << 2) + 0xd0100000)
+//Bit 23:0,	ro_NMFrm_TNR_Ycount	         Number ofLuma channel pixels included in Frame/Field based noise level measurement.
+#define NR2_MET_NMFRM_TNR_CLEV                     ((0x174b  << 2) + 0xd0100000)
+//Bit 28:0,	ro_NMFrm_TNR_Clevel	         Frame based Read-only register to give Chroma channel noise level within one frame/field.
+#define NR2_MET_NMFRM_TNR_CCNT                     ((0x174c  << 2) + 0xd0100000)
+//Bit 23:0,	ro_NMFrm_TNR_Ccount	         Number of Chroma channel pixels included in Frame/Field based noise level measurement. 
+#define NR2_3DEN_MODE                              ((0x174d  << 2) + 0xd0100000)
+//Bit 6:4,	Blend_3dnr_en_r	
+//Bit 2:0,	Blend_3dnr_en_l	
+#define NR2_IIR_CTRL                               ((0x174e  << 2) + 0xd0100000)
+//Bit 15:14, reg_LP_IIR_8bit_mode	LP IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
+//                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
+//Bit 13:12, reg_LP_IIR_mute_mode	Mode for the LP IIR mute,
+//Bit 11:8,	 reg_LP_IIR_mute_thrd	Threshold of LP IIR mute to avoid ghost:
+//Bit 7:6,	 reg_HP_IIR_8bit_mode	IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
+//                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
+//Bit 5:4,	reg_HP_IIR_mute_mode	Mode for theLP IIR mute
+//Bit 3:0,	reg_HP_IIR_mute_thrd	Threshold of HP IIR mute to avoid ghost
+//
+#define NR2_SW_EN                                  ((0x174f  << 2) + 0xd0100000)
+//Bit 17:8,	Clk_gate_ctrl	
+//Bit 7,	Cfr_enable	
+//Bit 5,	Det3d_en	
+//Bit 4,	Nr2_proc_en	
+//Bit 0,	Nr2_sw_en	
+#define NR2_FRM_SIZE                               ((0x1750  << 2) + 0xd0100000)
+//Bit 27:16,  Frm_heigh	Frame/field height
+//Bit 11: 0,  Frm_width	Frame/field width
+#define NR2_SNR_SAD_CFG                            ((0x1751  << 2) + 0xd0100000)
+//Bit 12,	reg_MATNR_SNR_SAD_CenRPL	U1, Enable signal for Current pixel position SAD to be replaced by SAD_min.0: do not replace Current pixel position SAD by SAD_min;1: do replacements
+//Bit 11:8,	reg_MATNR_SNR_SAD_coring	Coring value of the intra-frame SAD. sum = (sum - reg_MATNR_SNR_SAD_coring);sum = (sum<0) ? 0: (sum>255)? 255: sum;
+//Bit 6:5,	reg_MATNR_SNR_SAD_WinMod	Unsigned, Intra-frame SAD matching window mode:0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
+//Bit 4:0,	Sad_coef_num	            Sad coeffient
+#define NR2_MATNR_SNR_OS                           ((0x1752  << 2) + 0xd0100000)
+//Bit 7:4,	reg_MATNR_SNR_COS	    SNR Filter overshoot control margin for UV channel (X2 to u10 scale)
+//Bit 3:0,	reg_MATNR_SNR_YOS	    SNR Filter overshoot control margin for luma channel (X2 to u10 scale)
+#define NR2_MATNR_SNR_NRM_CFG                      ((0x1753  << 2) + 0xd0100000)
+//Bit 23:16,	reg_MATNR_SNR_NRM_ofst	Edge based SNR boosting normalization offset to SAD_max ;
+//Bit 15:8,	    reg_MATNR_SNR_NRM_max	Edge based SNR boosting normalization Max value
+//Bit 7:0,	    reg_MATNR_SNR_NRM_min	Edge based SNR boosting normalization Min value
+#define NR2_MATNR_SNR_NRM_GAIN                     ((0x1754  << 2) + 0xd0100000)
+//Bit 15:8,	reg_MATNR_SNR_NRM_Cgain	Edge based SNR boosting normalization Gain for Chrm channel (norm 32 as 1)
+//Bit 7:0,	reg_MATNR_SNR_NRM_Ygain	Edge based SNR boosting normalization Gain for Luma channel (norm 32 as 1)
+#define NR2_MATNR_SNR_LPF_CFG                      ((0x1755  << 2) + 0xd0100000)
+//Bit 23:16,reg_MATNR_SNRLPF_SADmaxTH	U8,  Threshold to SADmax to use TNRLPF to replace SNRLPF. i.e.if (SAD_max<reg_MATNR_SNRLPF_SADmaxTH) SNRLPF_yuv[k] = TNRLPF_yuv[k];
+//Bit 13:11,reg_MATNR_SNRLPF_Cmode	    LPF based SNR filtering mode on CHRM channel:
+//                                      0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 4 4 3]/16;  
+//                                      4: TNRLPF;  5 : CurLPF3x3_yuv[];  6: CurLPF3o3_yuv[]  7: CurLPF3x5_yuv[]
+//Bit 10:8,	reg_MATNR_SNRLPF_Ymode	    LPF based SNR filtering mode on LUMA channel:
+//                                      0: gradient LPF //Bit [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8;3: gradient LPF [5 4 4 3]/16;      
+//                                      4: TNRLPF;               5 : CurLPF3x3_yuv[];       6: CurLPF3o3_yuv[]         7: CurLPF3x5_yuv[]
+//Bit 7:4,	reg_MATNR_SNRLPF_SADmin3TH	Offset threshold to SAD_min to Discard SAD_min3 corresponding pixel in LPF SNR filtering. (X8 to u8 scale) 
+//Bit 3:0,	reg_MATNR_SNRLPF_SADmin2TH	Offset threshold to SAD_min to Discard SAD_min2 corresponding pixel in LPF SNR filtering. (X8 to u8 scale) 
+#define NR2_MATNR_SNR_USF_GAIN                     ((0x1756  << 2) + 0xd0100000)
+//Bit 15:8,	reg_MATNR_SNR_USF_Cgain	    Un-sharp (HP) compensate back Chrm portion gain, (norm 64 as 1)
+//Bit 7:0,	reg_MATNR_SNR_USF_Ygain	    Un-sharp (HP) compensate back Luma portion gain, (norm 64 as 1)
+#define NR2_MATNR_SNR_EDGE2B                       ((0x1757  << 2) + 0xd0100000)
+//Bit 15:8,	reg_MATNR_SNR_Edge2Beta_ofst	U8,  Offset for Beta based on Edge.
+//Bit 7:0,	reg_MATNR_SNR_Edge2Beta_gain	U8.  Gain to SAD_min for Beta based on Edge. (norm 16 as 1) 
+#define NR2_MATNR_BETA_EGAIN                       ((0x1758  << 2) + 0xd0100000)
+//Bit 15:8,	reg_MATNR_CBeta_Egain	U8,  Gain to Edge based Beta for Chrm channel. (normalized to 32 as 1)
+//Bit 7:0,	reg_MATNR_YBeta_Egain	U8,  Gain to Edge based Beta for Luma channel. (normalized to 32 as 1)
+#define NR2_MATNR_BETA_BRT                         ((0x1759  << 2) + 0xd0100000)
+//Bit 31:28,	reg_MATNR_beta_BRT_limt_hi	U4,  Beta adjustment based on Brightness high side Limit. (X16 to u8 scale)
+//Bit 27:24,	reg_MATNR_beta_BRT_slop_hi	U4,  Beta adjustment based on Brightness high side slope. Normalized to 16 as 1
+//Bit 23:16,	reg_MATNR_beta_BRT_thrd_hi	U8,  Beta adjustment based on Brightness high threshold.(u8 scale)
+//Bit 15:12,	reg_MATNR_beta_BRT_limt_lo	U4,  Beta adjustment based on Brightness low side Limit. (X16 to u8 scale)
+//Bit 11:8,	    reg_MATNR_beta_BRT_slop_lo	U4,  Beta adjustment based on Brightness low side slope. Normalized to 16 as 1
+//Bit 7:0,	    reg_MATNR_beta_BRT_thrd_lo	U8,  Beta adjustment based on Brightness low threshold.(u8 scale)
+#define NR2_MATNR_XBETA_CFG                        ((0x175a  << 2) + 0xd0100000)
+//Bit 19:18,	reg_MATNR_CBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Chrm channel;  
+//Bit 17:16,	reg_MATNR_YBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Luma channel;
+//Bit 15: 8,	reg_MATNR_CBeta_Ofst	    U8,  Offset to Beta for Chrm channel.(after beta_edge and beta_motion mux)
+//Bit  7: 0,	reg_MATNR_YBeta_Ofst	    U8,  Offset to Beta for Luma channel.(after beta_edge and beta_motion mux)
+#define NR2_MATNR_YBETA_SCL                        ((0x175b  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_YBeta_scale_min	U8,  Final step Beta scale low limit for Luma channel;
+//Bit 23:16,	reg_MATNR_YBeta_scale_max	U8,  Final step Beta scale high limit for Luma channe;
+//Bit 15: 8,	reg_MATNR_YBeta_scale_gain	U8,  Final step Beta scale Gain for Luma channel (normalized 32 to 1);
+//Bit 7 : 0,	reg_MATNR_YBeta_scale_ofst	S8,  Final step Beta scale offset for Luma channel ;
+#define NR2_MATNR_CBETA_SCL                        ((0x175c  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_CBeta_scale_min	Final step Beta scale low limit for Chrm channel.Similar to Y
+//Bit 23:16,	reg_MATNR_CBeta_scale_max	U8,  Final step Beta scale high limit for Chrm channel.Similar to Y
+//Bit 15: 8,	reg_MATNR_CBeta_scale_gain	U8,  Final step Beta scale Gain for Chrm channel Similar to Y
+//Bit  7: 0,	reg_MATNR_CBeta_scale_ofst	S8,  Final step Beta scale offset for Chrm channel Similar to Y
+#define NR2_SNR_MASK                               ((0x175d  << 2) + 0xd0100000)
+//Bit 20:0, 	SAD_MSK	                    Valid signal in the 3x7 SAD surface
+#define NR2_SAD2NORM_LUT0                          ((0x175e  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_SAD2Norm_LUT_3	SAD convert normal LUT node 3
+//Bit 23:16,	reg_MATNR_SAD2Norm_LUT_2	SAD convert normal LUT node 2
+//Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_1	SAD convert normal LUT node 1
+//Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_0	SAD convert normal LUT node 0
+#define NR2_SAD2NORM_LUT1                          ((0x175f  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_SAD2Norm_LUT_7	SAD convert normal LUT node 7
+//Bit 23:16,	reg_MATNR_SAD2Norm_LUT_6	SAD convert normal LUT node 6
+//Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_5	SAD convert normal LUT node 5
+//Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_4	SAD convert normal LUT node 4
+#define NR2_SAD2NORM_LUT2                          ((0x1760  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_SAD2Norm_LUT_11	SAD convert normal LUT node 11
+//Bit 23:16,	reg_MATNR_SAD2Norm_LUT_10	SAD convert normal LUT node 10
+//Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_9	SAD convert normal LUT node 9
+//Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_8	SAD convert normal LUT node 8
+#define NR2_SAD2NORM_LUT3                          ((0x1761  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_SAD2Norm_LUT_15	SAD convert normal LUT node 15
+//Bit 23:16,	reg_MATNR_SAD2Norm_LUT_14	SAD convert normal LUT node 14
+//Bit 15:8,	reg_MATNR_SAD2Norm_LUT_13	SAD convert normal LUT node 13
+//Bit 7:0,	reg_MATNR_SAD2Norm_LUT_12	SAD convert normal LUT node 12
+#define NR2_EDGE2BETA_LUT0                         ((0x1762  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_Edge2Beta_LUT_3	Edge convert beta LUT node 3
+//Bit 23:16,	reg_MATNR_Edge2Beta_LUT_2	Edge convert beta LUT node 2
+//Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_1	Edge convert beta LUT node 1
+//Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_0	Edge convert beta LUT node 0
+#define NR2_EDGE2BETA_LUT1                         ((0x1763  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_Edge2Beta_LUT_7	Edge convert beta LUT node 7
+//Bit 23:16,	reg_MATNR_Edge2Beta_LUT_6	Edge convert beta LUT node 6
+//Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_5	Edge convert beta LUT node 5
+//Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_4	Edge convert beta LUT node 4
+#define NR2_EDGE2BETA_LUT2                         ((0x1764  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_Edge2Beta_LUT_11	Edge convert beta LUT node 11
+//Bit 23:16,	reg_MATNR_Edge2Beta_LUT_10	Edge convert beta LUT node 10
+//Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_9	Edge convert beta LUT node 9
+//Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_8	Edge convert beta LUT node 8
+#define NR2_EDGE2BETA_LUT3                         ((0x1765  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_Edge2Beta_LUT_15	Edge convert beta LUT node 15
+//Bit 23:16,	reg_MATNR_Edge2Beta_LUT_14	Edge convert beta LUT node 14
+//Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_13	Edge convert beta LUT node 13
+//Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_12	Edge convert beta LUT node 12
+#define NR2_MOTION2BETA_LUT0                       ((0x1766  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_Mot2Beta_LUT_3	Motion convert beta LUT node 3
+//Bit 23:16,	reg_MATNR_Mot2Beta_LUT_2	Motion convert beta LUT node 2
+//Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_1	Motion convert beta LUT node 1
+//Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_0	Motion convert beta LUT node 0
+#define NR2_MOTION2BETA_LUT1                       ((0x1767  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_Mot2Beta_LUT_7	Motion convert beta LUT node 7
+//Bit 23:16,	reg_MATNR_Mot2Beta_LUT_6	Motion convert beta LUT node 6
+//Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_5	Motion convert beta LUT node 5
+//Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_4	Motion convert beta LUT node 4
+#define NR2_MOTION2BETA_LUT2                       ((0x1768  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_Mot2Beta_LUT_11	Motion convert beta LUT node 11
+//Bit 23:16,	reg_MATNR_Mot2Beta_LUT_10	Motion convert beta LUT node 10
+//Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_9	Motion convert beta LUT node 9
+//Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_8	Motion convert beta LUT node 8
+#define NR2_MOTION2BETA_LUT3                       ((0x1769  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_Mot2Beta_LUT_15	Motion convert beta LUT node 15
+//Bit 23:16,	reg_MATNR_Mot2Beta_LUT_14	Motion convert beta LUT node 14
+//Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_13	Motion convert beta LUT node 13
+//Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_12	Motion convert beta LUT node 12
+#define NR2_MATNR_MTN_CRTL                         ((0x176a  << 2) + 0xd0100000)
+//Bit 25:24,	reg_MATNR_Vmtn_use_mode	    Motion_yuvV channel motion selection mode:0: Vmot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)  
+//Bit 21:20,	reg_MATNR_Umtn_use_mode	    Motion_yuvU channel motion selection mode:0:Umot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)  
+//Bit 17:16,	reg_MATNR_Ymtn_use_mode	    Motion_yuvLuma channel motion selection mode:0:  Ymot, 1: Ymot/2 + (Umot+Vmot)/4; 2: Ymot/2 + max(Umot,Vmot)/2; 3:  max(Ymot,Umot, Vmot)   
+//Bit 13:12,	reg_MATNR_mtn_txt_mode	    Texture detection mode for adaptive coring of HP motion
+//Bit  9: 8,	reg_MATNR_mtn_cor_mode	    Coring selection mode based on texture detection;
+//Bit  6: 4,	reg_MATNR_mtn_hpf_mode	    video mode of current and previous frame/field for MotHPF_yuv[k] calculation:
+//Bit  2: 0,	reg_MATNR_mtn_lpf_mode	    LPF video mode of current and previous frame/field for MotLPF_yuv[k] calculation:
+#define NR2_MATNR_MTN_CRTL2                        ((0x176b  << 2) + 0xd0100000)
+//Bit 18:16,	reg_MATNR_iir_BS_Ymode	    IIR TNR filter Band split filter mode for Luma LPF result generation (Cur and Prev);
+//Bit 15: 8,	reg_MATNR_mtnb_alpLP_Cgain	Scale of motion_brthp_uv to motion_brtlp_uv, normalized to 32 as 1
+//Bit  7: 0,	reg_MATNR_mtnb_alpLP_Ygain	Scale of motion_brthp_y to motion_brtlp_y, normalized to 32 as 1
+#define NR2_MATNR_MTN_COR                          ((0x176c  << 2) + 0xd0100000)
+//Bit 15:12,	reg_MATNR_mtn_cor_Cofst	    Coring Offset for Chroma Motion.
+//Bit 11: 8,	reg_MATNR_mtn_cor_Cgain	    Gain to texture based coring for Chroma Motion. Normalized to 16 as 1
+//Bit  7: 4,	reg_MATNR_mtn_cor_Yofst	    Coring Offset for Luma Motion.
+//Bit  3: 0,	reg_MATNR_mtn_cor_Ygain	    Gain to texture based coring for Luma Motion. Normalized to 16 as 1
+#define NR2_MATNR_MTN_GAIN                         ((0x176d  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_mtn_hp_Cgain	Gain to MotHPF_yuv[k] Chrm channel for motion calculation, normalized to 64 as 1
+//Bit 23:16,	reg_MATNR_mtn_hp_Ygain	Gain to MotHPF_yuv[k] Luma channel for motion calculation, normalized to 64 as 1
+//Bit 15: 8,	reg_MATNR_mtn_lp_Cgain	Gain to MotLPF_yuv[k] Chrm channel for motion calculation, normalized to 32 as 1
+//Bit  7: 0,	reg_MATNR_mtn_lp_Ygain	Gain to MotLPF_yuv[k] Luma channel for motion calculation, normalized to 32 as 1
+#define NR2_MATNR_DEGHOST                          ((0x176e  << 2) + 0xd0100000)
+//Bit 8,	reg_MATNR_DeGhost_En	Enable signal for DeGhost function:0: disable; 1: enable  
+//Bit 7:4,	reg_MATNR_DeGhost_COS	DeGhost Overshoot margin for UV channel, (X2 to u10 scale)
+//Bit 3:0,	reg_MATNR_DeGhost_YOS	DeGhost Overshoot margin for Luma channel, (X2 to u10 scale)
+#define NR2_MATNR_ALPHALP_LUT0                     ((0x176f  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_AlphaLP_LUT_3	    Matnr low-pass filter alpha LUT node 3
+//Bit 23:16,	reg_MATNR_AlphaLP_LUT_2	    Matnr low-pass filter alpha LUT node 2
+//Bit 15: 8,	reg_MATNR_AlphaLP_LUT_1	    Matnr low-pass filter alpha LUT node 1
+//Bit  7: 0,	reg_MATNR_AlphaLP_LUT_0	    Matnr low-pass filter alpha LUT node 0
+#define NR2_MATNR_ALPHALP_LUT1                     ((0x1770  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_AlphaLP_LUT_7	    Matnr low-pass filter alpha LUT node 7
+//Bit 23:16,	reg_MATNR_AlphaLP_LUT_6	    Matnr low-pass filter alpha LUT node 6
+//Bit 15: 8,	reg_MATNR_AlphaLP_LUT_5	    Matnr low-pass filter alpha LUT node 5
+//Bit  7: 0,	reg_MATNR_AlphaLP_LUT_4	    Matnr low-pass filter alpha LUT node 4
+#define NR2_MATNR_ALPHALP_LUT2                     ((0x1771  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_AlphaLP_LUT_11	Matnr low-pass filter alpha LUT node 11
+//Bit 23:16,	reg_MATNR_AlphaLP_LUT_10	Matnr low-pass filter alpha LUT node 10
+//Bit 15: 8,	reg_MATNR_AlphaLP_LUT_9	    Matnr low-pass filter alpha LUT node 9
+//Bit  7: 0,	reg_MATNR_AlphaLP_LUT_8	    Matnr low-pass filter alpha LUT node 8
+#define NR2_MATNR_ALPHALP_LUT3                     ((0x1772  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_AlphaLP_LUT_15	Matnr low-pass filter alpha LUT node 15
+//Bit 23:16,	reg_MATNR_AlphaLP_LUT_14	Matnr low-pass filter alpha LUT node 14
+//Bit 15: 8,	reg_MATNR_AlphaLP_LUT_13	Matnr low-pass filter alpha LUT node 13
+//Bit  7: 0,	reg_MATNR_AlphaLP_LUT_12	Matnr low-pass filter alpha LUT node 12
+#define NR2_MATNR_ALPHAHP_LUT0                     ((0x1773  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_AlphaHP_LUT_3	    Matnr high-pass filter alpha LUT node 3
+//Bit 23:16,	reg_MATNR_AlphaHP_LUT_2	    Matnr high-pass filter alpha LUT node 2
+//Bit 15: 8,	reg_MATNR_AlphaHP_LUT_1	    Matnr high-pass filter alpha LUT node 1
+//Bit  7: 0,	reg_MATNR_AlphaHP_LUT_0	    Matnr high-pass filter alpha LUT node 0
+#define NR2_MATNR_ALPHAHP_LUT1                     ((0x1774  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_AlphaHP_LUT_7	    Matnr high-pass filter alpha LUT node 7
+//Bit 23:16,	reg_MATNR_AlphaHP_LUT_6	    Matnr high-pass filter alpha LUT node 6
+//Bit 15: 8,	reg_MATNR_AlphaHP_LUT_5	    Matnr high-pass filter alpha LUT node 5
+//Bit  7: 0,	reg_MATNR_AlphaHP_LUT_4	    Matnr high-pass filter alpha LUT node 4
+#define NR2_MATNR_ALPHAHP_LUT2                     ((0x1775  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_AlphaHP_LUT_11	Matnr high-pass filter alpha LUT node 11
+//Bit 23:16,	reg_MATNR_AlphaHP_LUT_10	Matnr high-pass filter alpha LUT node 10
+//Bit 15: 8,	reg_MATNR_AlphaHP_LUT_9	    Matnr high-pass filter alpha LUT node 9
+//Bit  7: 0,	reg_MATNR_AlphaHP_LUT_8	    Matnr high-pass filter alpha LUT node 8
+#define NR2_MATNR_ALPHAHP_LUT3                     ((0x1776  << 2) + 0xd0100000)
+//Bit 31:24,	reg_MATNR_AlphaHP_LUT_15	Matnr high-pass filter alpha LUT node 15
+//Bit 23:16,	reg_MATNR_AlphaHP_LUT_14	Matnr high-pass filter alpha LUT node 14
+//Bit 15: 8,	reg_MATNR_AlphaHP_LUT_13	Matnr high-pass filter alpha LUT node 13
+//Bit  7: 0,	reg_MATNR_AlphaHP_LUT_12	Matnr high-pass filter alpha LUT node 12
+#define NR2_MATNR_MTNB_BRT                         ((0x1777  << 2) + 0xd0100000)
+//Bit 31:28,	reg_MATNR_mtnb_BRT_limt_hi	Motion adjustment based on Brightness high side Limit. (X16 to u8 scale)
+//Bit 27:24,	reg_MATNR_mtnb_BRT_slop_hi	Motion adjustment based on Brightness high side slope. Normalized to 16 as 1
+//Bit 23:16,	reg_MATNR_mtnb_BRT_thrd_hi	Motion adjustment based on Brightness high threshold.(u8 scale)
+//Bit 15:12,	reg_MATNR_mtnb_BRT_limt_lo	Motion adjustment based on Brightness low side Limit. (X16 to u8 scale)
+//Bit 11: 8,	reg_MATNR_mtnb_BRT_slop_lo	Motion adjustment based on Brightness low side slope. Normalized to 16 as 1
+//Bit  7: 0,	reg_MATNR_mtnb_BRT_thrd_lo	Motion adjustment based on Brightness low threshold.(u8 scale)
+#define NR2_CUE_MODE                               ((0x1778  << 2) + 0xd0100000)
+//Bit 9,	Cue_enable_r	        Cue right half frame enable
+//Bit 8,	Cue_enable_l            Cue left half frame enable 
+//Bit 6:4,	reg_CUE_CON_RPLC_mode	U3, CUE pixel chroma replace mode;
+//Bit 2:0,	reg_CUE_CHRM_FLT_mode	U3, CUE improvement filter mode,
+#define NR2_CUE_CON_MOT_TH                         ((0x1779  << 2) + 0xd0100000)
+//Bit 31:24,	reg_CUE_CON_Cmot_thrd2	U8,  Motion Detection threshold of up/down two rows,  Chroma channel in Chroma Up-sampling Error (CUE) Detection (tighter). 
+//Bit 23:16,	reg_CUE_CON_Ymot_thrd2	U8,  Motion Detection threshold of up/mid/down three rows,  Luma channel in Chroma Up-sampling Error (CUE) Detection (tighter). 
+//Bit 15: 8,	reg_CUE_CON_Cmot_thrd	U8,  Motion Detection threshold of up/down two rows, Chroma channel in Chroma Up-sampling Error (CUE) Detection.
+//Bit  7: 0,	reg_CUE_CON_Ymot_thrd	U8,  Motion Detection threshold of up/mid/down three rows, Luma channel in Chroma Up-sampling Error (CUE) Detection. 
+#define NR2_CUE_CON_DIF0                           ((0x177a  << 2) + 0xd0100000)
+//Bit 15:8,	reg_CUE_CON_difP1_thrd	    U8,  P1 field Intra-Field top/below line chroma difference threshold, 
+//Bit 7:0,	reg_CUE_CON_difCur_thrd	    U8,  Current Field/Frame Intra-Field up/down line chroma difference threshold, 
+#define NR2_CUE_CON_DIF1                           ((0x177b  << 2) + 0xd0100000)
+//Bit 19:16,	reg_CUE_CON_rate0	    U4,  The Krate to decide CUE by relationship between CUE_diflG and CUE_difEG 
+//Bit 15: 8,	reg_CUE_CON_difEG_thrd	U8,  Theshold to the difference between current Field/Frame middle line to down line color channel(CUE_difEG). 
+//Bit  7: 0,	reg_CUE_CON_diflG_thrd	U8,  Threshold to the difference between P1 field top line to current Field/Frame down line color channel (CUE_diflG).
+#define NR2_CUE_CON_DIF2                           ((0x177c  << 2) + 0xd0100000)
+//Bit 19:16,	reg_CUE_CON_rate1	    U4,  The Krate to decide CUE by relationship between CUE_difnC and CUE_difEC 
+//Bit 15: 8,	reg_CUE_CON_difEC_thrd	U8,  Theshold to the difference between current Field/Frame middle line to up line color channel(CUE_difEC). 
+//Bit  7: 0,	reg_CUE_CON_difnC_thrd	U8,  Threshold to the difference between P1 field bot line to current Field/Frame up line color channel (CUE_difnC). 
+#define NR2_CUE_CON_DIF3                           ((0x177d  << 2) + 0xd0100000)
+//Bit 19:16,	reg_CUE_CON_rate2	    U4,  The Krate to decide CUE by relationship between CUE_difP1 and CUE_difEP1 
+//Bit 15: 8,	reg_CUE_CON_difEP1_thrd	U8,  Inter-Field top/below line to current field/frame middle line chroma difference (CUE_difEP1) threshold. 
+//Bit  7: 0,	reg_CUE_CON_difP1_thrd2	U8,  P1 field Intra-Field top/below line chroma difference threshold (tighter), 
+#define NR2_CUE_PRG_DIF                            ((0x177e  << 2) + 0xd0100000)
+//Bit 20,	    reg_CUE_PRG_Enable	    Enable bit for progressive video CUE detection.If interlace input video, 
+//Bit 19:16,	reg_CUE_PRG_rate	    U3,  The Krate to decide CUE by relationship between CUE_difCur and (CUE_difEC+CUE_difEG) 
+//Bit 15: 8,	reg_CUE_PRG_difCEG_thrd	U8,  Current Frame Intra-Field up-mid and mid-down line chroma difference threshold for progressive video CUE detection, 
+//Bit  7: 0,	reg_CUE_PRG_difCur_thrd	U8,  Current Frame Intra-Field up/down line chroma difference threshold, 
+#define NR2_CONV_MODE                              ((0x177f  << 2) + 0xd0100000)
+//Bit 3:2,	Conv_c444_mode	The format convert mode about 422 to 444 when data read out line buffer
+//Bit 1:0,	Conv_c422_mode	the format convert mode about 444 to 422 when data write to line buffer 
+//// NR2 REG DEFINE END ////
+//// DET 3D REG DEFINE BEGIN ////
+////  8'h80~8'h8f
+#define DET3D_RO_SPLT_HB                           ((0x1780  << 2) + 0xd0100000)
+//Bit 24,	    RO_Det3D_Split_HB_valid	    U1   horizontal LR split border detected valid signal for top half picture
+//Bit 20:16,	RO_Det3D_Split_HB_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
+//Bit  9: 0,	RO_Det3D_Split_HB_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+#define DET3D_RO_SPLT_VL                           ((0x1781  << 2) + 0xd0100000)
+//Bit 24,	    RO_Det3D_Split_VL_valid	    U1   horizontal LR split border detected valid signal for top half picture
+//Bit 20:16,	RO_Det3D_Split_VL_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
+//Bit  9: 0,	RO_Det3D_Split_VL_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+#define DET3D_RO_SPLT_VR                           ((0x1782  << 2) + 0xd0100000)
+//Bit 24   ,	RO_Det3D_Split_VR_valid	    U1   horizontal LR split border detected valid signal for top half picture
+//Bit 20:16,	RO_Det3D_Split_VR_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
+//Bit  9: 0,	RO_Det3D_Split_VR_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
+#define DET3D_RO_MAT_LUMA_LR                       ((0x1783  << 2) + 0xd0100000)
+//Bit 15:0,	RO_Luma_LR_score	 S2*8  LUMA statistics left right decision score for each band (8bands vertically), 
+//                               it can be -1/0/1:-1: most likely not LR symmetric 0: not sure 1: most likely LR symmetric
+//Bit 7:0,	RO_Luma_LR_symtc	 U1*8  Luma statistics left right pure symmetric for each band (8bands vertically), 
+//                               it can be 0/1: 0: not sure 1: most likely LR is pure symmetric
+//Bit 4:0,	RO_Luma_LR_sum	     S5  Total score of 8x8 Luma statistics for LR like decision, 
+//                               the larger this score, the more confidence that this is a LR 3D video. It is sum of  RO_Luma_LR_score[0~7]
+#define DET3D_RO_MAT_LUMA_TB                       ((0x1784  << 2) + 0xd0100000)
+//Bit 15:0,	RO_Luma_TB_score	 S2*8  LUMA statistics Top/Bottom decision score for each band (8bands Horizontally), 
+//Bit 7:0,	RO_Luma_TB_symtc	 Luma statistics Top/Bottompure symmetric for each band (8bands Horizontally), 
+//Bit 4:0,	RO_Luma_TB_sum	     Total score of 8x8 Luma statistics for TB like decision, 
+#define DET3D_RO_MAT_CHRU_LR                       ((0x1785  << 2) + 0xd0100000)
+//Bit 15:0,	RO_ChrU_LR_score	S2*8  LUMA statistics left right decision score for each band (8bands vertically), 
+//Bit 7:0,	RO_ChrU_LR_symtc	CHRU statistics left right pure symmetric for each band (8bands vertically), 
+//Bit 4:0,	RO_ChrU_LR_sum	    Total score of 8x8 ChrU statistics for LR like decision, 
+#define DET3D_RO_MAT_CHRU_TB                       ((0x1786  << 2) + 0xd0100000)
+//Bit 15:0,	RO_ChrU_TB_score	S2*8  CHRU statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_ChrU_TB_symtc	CHRU statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_ChrU_TB_sum	    Total score of 8x8 ChrU statistics for TB like decision
+#define DET3D_RO_MAT_CHRV_LR                       ((0x1787  << 2) + 0xd0100000)
+//Bit 15:0,	RO_ChrV_LR_score	S2*8  CHRUstatistics left right decision score for each band (8bands vertically)
+//Bit 7:0,	RO_ChrV_LR_symtc	CHRV statistics left right pure symmetric for each band (8bands vertically)
+//Bit 4:0,	RO_ChrV_LR_sum	    Total score of 8x8 ChrV statistics for LR like decision
+#define DET3D_RO_MAT_CHRV_TB                       ((0x1788  << 2) + 0xd0100000)
+//Bit 15:0,	RO_ChrV_TB_score	CHRV statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_ChrV_TB_symtc	CHRV statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_ChrV_TB_sum	    Total score of 8x8 ChrV statistics for TB like decision
+#define DET3D_RO_MAT_HEDG_LR                       ((0x1789  << 2) + 0xd0100000)
+//Bit 15:0,	RO_Hedg_LR_score	Horizontal Edge statistics left right decision score for each band (8bands vertically)
+//Bit 7:0,	RO_Hedg_LR_symtc	Horizontal Edge statistics left right pure symmetric for each band (8bands vertically)
+//Bit 4:0,	RO_Hedg_LR_sum	    Total score of 8x8 Hedg statistics for LR like decision
+#define DET3D_RO_MAT_HEDG_TB                       ((0x178a  << 2) + 0xd0100000)
+//Bit 15:0,	RO_Hedg_TB_score	Horizontal Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_Hedg_TB_symtc	Horizontal Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_Hedg_TB_sum	    Total score of 8x8 Hedg statistics for TB like decision
+#define DET3D_RO_MAT_VEDG_LR                       ((0x178b  << 2) + 0xd0100000)
+//Bit 15:0,	RO_Vedg_LR_score	Vertical Edge statistics left right decision score for each band (8bands vertically)
+//Bit 7:0,	RO_Vedg_LR_symtc	Vertical Edge statistics left right pure symmetric for each band (8bands vertically)
+//Bit 4:0,	RO_Vedg_LR_sum	    Total score of 8x8 Vedg statistics for LR like decision
+#define DET3D_RO_MAT_VEDG_TB                       ((0x178c  << 2) + 0xd0100000)
+//Bit 15:0,	RO_Vedg_TB_score	Vertical Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_Vedg_TB_symtc	Vertical Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_Vedg_TB_sum	    Total score of 8x8 Vedg statistics for TB like decision
+#define DET3D_RO_MAT_MOTN_LR                       ((0x178d  << 2) + 0xd0100000)
+//Bit 15:0,	RO_Motn_LR_score	Motion statistics left right decision score for each band (8bands vertically)
+//Bit 7:0,	RO_Motn_LR_symtc	Motion statistics left right pure symmetric for each band (8bands vertically)
+//Bit 4:0,	RO_Motn_LR_sum	    Total score of 8x8 Motion statistics for LR like decision
+#define DET3D_RO_MAT_MOTN_TB                       ((0x178e  << 2) + 0xd0100000)
+//Bit 15:0,	RO_Motn_TB_score	Motion statistics Top/Bottom decision score for each band (8bands Horizontally)
+//Bit 7:0,	RO_Motn_TB_symtc	Motion statistics Top/Bottompure symmetric for each band (8bands Horizontally)
+//Bit 4:0,	RO_Motn_TB_sum	    Total score of 8x8 Motion statistics for TB like decision
+#define DET3D_RO_FRM_MOTN                          ((0x178f  << 2) + 0xd0100000)
+//Bit 15:0,	RO_Det3D_Frame_Motion	U16  frame based motion value sum for still image decision in FW.
+/// mat ram read enter addr
+#define DET3D_RAMRD_ADDR_PORT                      ((0x179a  << 2) + 0xd0100000)
+#define DET3D_RAMRD_DATA_PORT                      ((0x179b  << 2) + 0xd0100000)
+#define NR2_CFR_PARA_CFG0                          ((0x179c  << 2) + 0xd0100000)
+//Bit 8,	reg_CFR_CurDif_luma_mode	Current Field Top/Bot line Luma difference calculation mode
+//Bit 7:6,	reg_MACFR_frm_phase	        U2  This will be a field based phase register that need to be set by FW phase to phase: 
+//                                      this will be calculated based on dbdr_phase of the specific line of this frame. 
+//                                      u1: dbdr_phase=1, center line is DB in current line;  dbdr_phase=2, center line is Dr in current line;
+//Bit 5:4,	reg_CFR_CurDif_tran_mode	U2  Current Field Top/Bot line Luma/Chroma transition level calculation mode, 
+//Bit 3:2,	reg_CFR_alpha_mode	        U2  Alpha selection mode for CFR block from curAlp and motAlp i.e. 0: motAlp; 1: (motAlp+curAlp)/2; 2: min(motAlp,curAlp); 3: max(motAlp,curAlp);
+//Bit 1:0,	reg_CFR_Motion_Luma_mode	U2  LumaMotion Calculation mode for MA-CFR. 0: top/bot Lumma motion;   1: middle Luma Motion 2: top/bot + middle motion; 3: max(top/tot motion, middle motion)
+#define NR2_CFR_PARA_CFG1                          ((0x179d  << 2) + 0xd0100000)
+//Bit 23:16,	reg_CFR_alpha_gain	    gain to map muxed curAlp and motAlp to alpha that will be used for final blending.
+//Bit 15: 8,	reg_CFR_Motion_ofst	    Offset to Motion to calculate the motAlp, e,g:motAlp= reg_CFR_Motion_ofst- Motion;This register can be seen as the level of motion that we consider it at moving.
+//Bit  7: 0,	reg_CFR_CurDif_gain	    gain to CurDif to map to alpha, normalized to 32;
+//// DET 3D REG DEFINE END ////
+#define DI_NR_1_CTRL0                              ((0x1794  << 2) + 0xd0100000)
+#define DI_NR_1_CTRL1                              ((0x1795  << 2) + 0xd0100000)
+#define DI_NR_1_CTRL2                              ((0x1796  << 2) + 0xd0100000)
+#define DI_NR_1_CTRL3                              ((0x1797  << 2) + 0xd0100000)
+#define DI_CONTWR_X                                ((0x17a0  << 2) + 0xd0100000)
+#define DI_CONTWR_Y                                ((0x17a1  << 2) + 0xd0100000)
+#define DI_CONTWR_CTRL                             ((0x17a2  << 2) + 0xd0100000)
+#define DI_CONTPRD_X                               ((0x17a3  << 2) + 0xd0100000)
+#define DI_CONTPRD_Y                               ((0x17a4  << 2) + 0xd0100000)
+#define DI_CONTP2RD_X                              ((0x17a5  << 2) + 0xd0100000)
+#define DI_CONTP2RD_Y                              ((0x17a6  << 2) + 0xd0100000)
+#define DI_CONTRD_CTRL                             ((0x17a7  << 2) + 0xd0100000)
+#define DI_NRWR_X                                  ((0x17c0  << 2) + 0xd0100000)
+#define DI_NRWR_Y                                  ((0x17c1  << 2) + 0xd0100000)
+#define DI_NRWR_CTRL                               ((0x17c2  << 2) + 0xd0100000)
+#define DI_MTNWR_X                                 ((0x17c3  << 2) + 0xd0100000)
+#define DI_MTNWR_Y                                 ((0x17c4  << 2) + 0xd0100000)
+#define DI_MTNWR_CTRL                              ((0x17c5  << 2) + 0xd0100000)
+#define DI_DIWR_X                                  ((0x17c6  << 2) + 0xd0100000)
+#define DI_DIWR_Y                                  ((0x17c7  << 2) + 0xd0100000)
+#define DI_DIWR_CTRL                               ((0x17c8  << 2) + 0xd0100000)
+//`define DI_MTNCRD_X               8'hc9
+//`define DI_MTNCRD_Y               8'hca
+#define DI_MTNPRD_X                                ((0x17cb  << 2) + 0xd0100000)
+#define DI_MTNPRD_Y                                ((0x17cc  << 2) + 0xd0100000)
+#define DI_MTNRD_CTRL                              ((0x17cd  << 2) + 0xd0100000)
+#define DI_INP_GEN_REG                             ((0x17ce  << 2) + 0xd0100000)
+#define DI_INP_CANVAS0                             ((0x17cf  << 2) + 0xd0100000)
+#define DI_INP_LUMA_X0                             ((0x17d0  << 2) + 0xd0100000)
+#define DI_INP_LUMA_Y0                             ((0x17d1  << 2) + 0xd0100000)
+#define DI_INP_CHROMA_X0                           ((0x17d2  << 2) + 0xd0100000)
+#define DI_INP_CHROMA_Y0                           ((0x17d3  << 2) + 0xd0100000)
+#define DI_INP_RPT_LOOP                            ((0x17d4  << 2) + 0xd0100000)
+#define DI_INP_LUMA0_RPT_PAT                       ((0x17d5  << 2) + 0xd0100000)
+#define DI_INP_CHROMA0_RPT_PAT                     ((0x17d6  << 2) + 0xd0100000)
+#define DI_INP_DUMMY_PIXEL                         ((0x17d7  << 2) + 0xd0100000)
+#define DI_INP_LUMA_FIFO_SIZE                      ((0x17d8  << 2) + 0xd0100000)
+#define DI_INP_RANGE_MAP_Y                         ((0x17ba  << 2) + 0xd0100000)
+#define DI_INP_RANGE_MAP_CB                        ((0x17bb  << 2) + 0xd0100000)
+#define DI_INP_RANGE_MAP_CR                        ((0x17bc  << 2) + 0xd0100000)
+#define DI_INP_GEN_REG2                            ((0x1791  << 2) + 0xd0100000)
+#define DI_INP_FMT_CTRL                            ((0x17d9  << 2) + 0xd0100000)
+#define DI_INP_FMT_W                               ((0x17da  << 2) + 0xd0100000)
+#define DI_MEM_GEN_REG                             ((0x17db  << 2) + 0xd0100000)
+#define DI_MEM_CANVAS0                             ((0x17dc  << 2) + 0xd0100000)
+#define DI_MEM_LUMA_X0                             ((0x17dd  << 2) + 0xd0100000)
+#define DI_MEM_LUMA_Y0                             ((0x17de  << 2) + 0xd0100000)
+#define DI_MEM_CHROMA_X0                           ((0x17df  << 2) + 0xd0100000)
+#define DI_MEM_CHROMA_Y0                           ((0x17e0  << 2) + 0xd0100000)
+#define DI_MEM_RPT_LOOP                            ((0x17e1  << 2) + 0xd0100000)
+#define DI_MEM_LUMA0_RPT_PAT                       ((0x17e2  << 2) + 0xd0100000)
+#define DI_MEM_CHROMA0_RPT_PAT                     ((0x17e3  << 2) + 0xd0100000)
+#define DI_MEM_DUMMY_PIXEL                         ((0x17e4  << 2) + 0xd0100000)
+#define DI_MEM_LUMA_FIFO_SIZE                      ((0x17e5  << 2) + 0xd0100000)
+#define DI_MEM_RANGE_MAP_Y                         ((0x17bd  << 2) + 0xd0100000)
+#define DI_MEM_RANGE_MAP_CB                        ((0x17be  << 2) + 0xd0100000)
+#define DI_MEM_RANGE_MAP_CR                        ((0x17bf  << 2) + 0xd0100000)
+#define DI_MEM_GEN_REG2                            ((0x1792  << 2) + 0xd0100000)
+#define DI_MEM_FMT_CTRL                            ((0x17e6  << 2) + 0xd0100000)
+#define DI_MEM_FMT_W                               ((0x17e7  << 2) + 0xd0100000)
+#define DI_IF1_GEN_REG                             ((0x17e8  << 2) + 0xd0100000)
+#define DI_IF1_CANVAS0                             ((0x17e9  << 2) + 0xd0100000)
+#define DI_IF1_LUMA_X0                             ((0x17ea  << 2) + 0xd0100000)
+#define DI_IF1_LUMA_Y0                             ((0x17eb  << 2) + 0xd0100000)
+#define DI_IF1_CHROMA_X0                           ((0x17ec  << 2) + 0xd0100000)
+#define DI_IF1_CHROMA_Y0                           ((0x17ed  << 2) + 0xd0100000)
+#define DI_IF1_RPT_LOOP                            ((0x17ee  << 2) + 0xd0100000)
+#define DI_IF1_LUMA0_RPT_PAT                       ((0x17ef  << 2) + 0xd0100000)
+#define DI_IF1_CHROMA0_RPT_PAT                     ((0x17f0  << 2) + 0xd0100000)
+#define DI_IF1_DUMMY_PIXEL                         ((0x17f1  << 2) + 0xd0100000)
+#define DI_IF1_LUMA_FIFO_SIZE                      ((0x17f2  << 2) + 0xd0100000)
+#define DI_IF1_RANGE_MAP_Y                         ((0x17fc  << 2) + 0xd0100000)
+#define DI_IF1_RANGE_MAP_CB                        ((0x17fd  << 2) + 0xd0100000)
+#define DI_IF1_RANGE_MAP_CR                        ((0x17fe  << 2) + 0xd0100000)
+#define DI_IF1_GEN_REG2                            ((0x1790  << 2) + 0xd0100000)
+#define DI_IF1_FMT_CTRL                            ((0x17f3  << 2) + 0xd0100000)
+#define DI_IF1_FMT_W                               ((0x17f4  << 2) + 0xd0100000)
+#define DI_CHAN2_GEN_REG                           ((0x17f5  << 2) + 0xd0100000)
+#define DI_CHAN2_CANVAS0                           ((0x17f6  << 2) + 0xd0100000)
+#define DI_CHAN2_LUMA_X0                           ((0x17f7  << 2) + 0xd0100000)
+#define DI_CHAN2_LUMA_Y0                           ((0x17f8  << 2) + 0xd0100000)
+#define DI_CHAN2_CHROMA_X0                         ((0x17f9  << 2) + 0xd0100000)
+#define DI_CHAN2_CHROMA_Y0                         ((0x17fa  << 2) + 0xd0100000)
+#define DI_CHAN2_RPT_LOOP                          ((0x17fb  << 2) + 0xd0100000)
+#define DI_CHAN2_LUMA0_RPT_PAT                     ((0x17b0  << 2) + 0xd0100000)
+#define DI_CHAN2_CHROMA0_RPT_PAT                   ((0x17b1  << 2) + 0xd0100000)
+#define DI_CHAN2_DUMMY_PIXEL                       ((0x17b2  << 2) + 0xd0100000)
+#define DI_CHAN2_LUMA_FIFO_SIZE                    ((0x17b3  << 2) + 0xd0100000)
+#define DI_CHAN2_RANGE_MAP_Y                       ((0x17b4  << 2) + 0xd0100000)
+#define DI_CHAN2_RANGE_MAP_CB                      ((0x17b5  << 2) + 0xd0100000)
+#define DI_CHAN2_RANGE_MAP_CR                      ((0x17b6  << 2) + 0xd0100000)
+#define DI_CHAN2_GEN_REG2                          ((0x17b7  << 2) + 0xd0100000)
+#define DI_CHAN2_FMT_CTRL                          ((0x17b8  << 2) + 0xd0100000)
+#define DI_CHAN2_FMT_W                             ((0x17b9  << 2) + 0xd0100000)
+#define DI_CANVAS_URGENT0                          ((0x170a  << 2) + 0xd0100000)
+#define DI_CANVAS_URGENT1                          ((0x170b  << 2) + 0xd0100000)
+#define DI_CANVAS_URGENT2                          ((0x170e  << 2) + 0xd0100000)
+//
+// Closing file:  vregs.h
+//
+//`define  VENC_VCBUS_BASE              8'h1b
+//
+// Reading file:  venc_regs.h
+//
+//===========================================================================
+// Video Interface Registers    0xa00 - 0xbff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VENC_VCBUS_BASE = 0x1b
+// -----------------------------------------------
+// bit 15:8 -- vfifo2vd_vd_sel
+// bit 0 -- vfifo2vd_en
+#define ENCP_VFIFO2VD_CTL                          ((0x1b58  << 2) + 0xd0100000)
+// bit 12:0 -- vfifo2vd_pixel_start 
+#define ENCP_VFIFO2VD_PIXEL_START                  ((0x1b59  << 2) + 0xd0100000)
+// bit 12:00 -- vfifo2vd_pixel_end   
+#define ENCP_VFIFO2VD_PIXEL_END                    ((0x1b5a  << 2) + 0xd0100000)
+// bit 10:0 -- vfifo2vd_line_top_start 
+#define ENCP_VFIFO2VD_LINE_TOP_START               ((0x1b5b  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_top_end   
+#define ENCP_VFIFO2VD_LINE_TOP_END                 ((0x1b5c  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_bot_start 
+#define ENCP_VFIFO2VD_LINE_BOT_START               ((0x1b5d  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_bot_end   
+#define ENCP_VFIFO2VD_LINE_BOT_END                 ((0x1b5e  << 2) + 0xd0100000)
+// Route the hsync and vsync signals round the chip. There are three
+// sources and users of these signals: VIU, internal video encoder, and
+// the pins on the chip. Some muxing is still being done in the VIU. It
+// was not moved to the venc module so that the same exact VIU code could
+// be used both in Twister and Twister2000.
+// Bit 2: venc_sync_source (1=>pins, 0=>viu)
+// Bit 1: viu_sync_source (1=>pins, 0=>venc)
+// Bit 0: vpins_sync_source (1=>venc, 0=>viu)
+#define VENC_SYNC_ROUTE                            ((0x1b60  << 2) + 0xd0100000)
+#define VENC_VIDEO_EXSRC                           ((0x1b61  << 2) + 0xd0100000)
+#define VENC_DVI_SETTING                           ((0x1b62  << 2) + 0xd0100000)
+#define VENC_C656_CTRL                             ((0x1b63  << 2) + 0xd0100000)
+#define VENC_UPSAMPLE_CTRL0                        ((0x1b64  << 2) + 0xd0100000)
+#define VENC_UPSAMPLE_CTRL1                        ((0x1b65  << 2) + 0xd0100000)
+#define VENC_UPSAMPLE_CTRL2                        ((0x1b66  << 2) + 0xd0100000)
+// Invert control for tcon output
+// bit[15:14] -- vsync, hsync, 
+// bit[13:0] --  oev3, oev2, cpv2, cph3, cph2, cph1, oeh, vcom, stv2, stv1, cpv1, oev1, sth1, sth2
+#define TCON_INVERT_CTL                            ((0x1b67  << 2) + 0xd0100000)
+#define VENC_VIDEO_PROG_MODE                       ((0x1b68  << 2) + 0xd0100000)
+//---- Venc pixel/line info
+#define VENC_ENCI_LINE                             ((0x1b69  << 2) + 0xd0100000)
+#define VENC_ENCI_PIXEL                            ((0x1b6a  << 2) + 0xd0100000)
+#define VENC_ENCP_LINE                             ((0x1b6b  << 2) + 0xd0100000)
+#define VENC_ENCP_PIXEL                            ((0x1b6c  << 2) + 0xd0100000)
+//---- Status
+#define VENC_STATA                                 ((0x1b6d  << 2) + 0xd0100000)
+//---- Interrupt setting
+#define VENC_INTCTRL                               ((0x1b6e  << 2) + 0xd0100000)
+#define VENC_INTFLAG                               ((0x1b6f  << 2) + 0xd0100000)
+//--------- Video test configuration
+#define VENC_VIDEO_TST_EN                          ((0x1b70  << 2) + 0xd0100000)
+#define VENC_VIDEO_TST_MDSEL                       ((0x1b71  << 2) + 0xd0100000)
+#define VENC_VIDEO_TST_Y                           ((0x1b72  << 2) + 0xd0100000)
+#define VENC_VIDEO_TST_CB                          ((0x1b73  << 2) + 0xd0100000)
+#define VENC_VIDEO_TST_CR                          ((0x1b74  << 2) + 0xd0100000)
+#define VENC_VIDEO_TST_CLRBAR_STRT                 ((0x1b75  << 2) + 0xd0100000)
+#define VENC_VIDEO_TST_CLRBAR_WIDTH                ((0x1b76  << 2) + 0xd0100000)
+#define VENC_VIDEO_TST_VDCNT_STSET                 ((0x1b77  << 2) + 0xd0100000)
+//----- Video dac setting
+#define VENC_VDAC_DACSEL0                          ((0x1b78  << 2) + 0xd0100000)
+#define VENC_VDAC_DACSEL1                          ((0x1b79  << 2) + 0xd0100000)
+#define VENC_VDAC_DACSEL2                          ((0x1b7a  << 2) + 0xd0100000)
+#define VENC_VDAC_DACSEL3                          ((0x1b7b  << 2) + 0xd0100000)
+#define VENC_VDAC_DACSEL4                          ((0x1b7c  << 2) + 0xd0100000)
+#define VENC_VDAC_DACSEL5                          ((0x1b7d  << 2) + 0xd0100000)
+#define VENC_VDAC_SETTING                          ((0x1b7e  << 2) + 0xd0100000)
+#define VENC_VDAC_TST_VAL                          ((0x1b7f  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC0_GAINCTRL                    ((0x1bf0  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC0_OFFSET                      ((0x1bf1  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC1_GAINCTRL                    ((0x1bf2  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC1_OFFSET                      ((0x1bf3  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC2_GAINCTRL                    ((0x1bf4  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC2_OFFSET                      ((0x1bf5  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC3_GAINCTRL                    ((0x1bf6  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC3_OFFSET                      ((0x1bf7  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC4_GAINCTRL                    ((0x1bf8  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC4_OFFSET                      ((0x1bf9  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC5_GAINCTRL                    ((0x1bfa  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC5_OFFSET                      ((0x1bfb  << 2) + 0xd0100000)
+#define VENC_VDAC_FIFO_CTRL                        ((0x1bfc  << 2) + 0xd0100000)
+#define ENCL_TCON_INVERT_CTL                       ((0x1bfd  << 2) + 0xd0100000)
+//
+// Closing file:  venc_regs.h
+//
+//
+// Reading file:  enc480p_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//===========================================================================
+// Video Encoder 480p Registers    0xb80 - 0xbef
+//===========================================================================
+//-------- Video basic setting
+#define ENCP_VIDEO_EN                              ((0x1b80  << 2) + 0xd0100000)
+#define ENCP_VIDEO_SYNC_MODE                       ((0x1b81  << 2) + 0xd0100000)
+#define ENCP_MACV_EN                               ((0x1b82  << 2) + 0xd0100000)
+#define ENCP_VIDEO_Y_SCL                           ((0x1b83  << 2) + 0xd0100000)
+#define ENCP_VIDEO_PB_SCL                          ((0x1b84  << 2) + 0xd0100000)
+#define ENCP_VIDEO_PR_SCL                          ((0x1b85  << 2) + 0xd0100000)
+#define ENCP_VIDEO_SYNC_SCL                        ((0x1b86  << 2) + 0xd0100000)
+#define ENCP_VIDEO_MACV_SCL                        ((0x1b87  << 2) + 0xd0100000)
+#define ENCP_VIDEO_Y_OFFST                         ((0x1b88  << 2) + 0xd0100000)
+#define ENCP_VIDEO_PB_OFFST                        ((0x1b89  << 2) + 0xd0100000)
+#define ENCP_VIDEO_PR_OFFST                        ((0x1b8a  << 2) + 0xd0100000)
+#define ENCP_VIDEO_SYNC_OFFST                      ((0x1b8b  << 2) + 0xd0100000)
+#define ENCP_VIDEO_MACV_OFFST                      ((0x1b8c  << 2) + 0xd0100000)
+//----- Video mode
+#define ENCP_VIDEO_MODE                            ((0x1b8d  << 2) + 0xd0100000)
+#define ENCP_VIDEO_MODE_ADV                        ((0x1b8e  << 2) + 0xd0100000)
+//--------------- Debug pins
+#define ENCP_DBG_PX_RST                            ((0x1b90  << 2) + 0xd0100000)
+#define ENCP_DBG_LN_RST                            ((0x1b91  << 2) + 0xd0100000)
+#define ENCP_DBG_PX_INT                            ((0x1b92  << 2) + 0xd0100000)
+#define ENCP_DBG_LN_INT                            ((0x1b93  << 2) + 0xd0100000)
+//----------- Video Advanced setting
+#define ENCP_VIDEO_YFP1_HTIME                      ((0x1b94  << 2) + 0xd0100000)
+#define ENCP_VIDEO_YFP2_HTIME                      ((0x1b95  << 2) + 0xd0100000)
+#define ENCP_VIDEO_YC_DLY                          ((0x1b96  << 2) + 0xd0100000)
+#define ENCP_VIDEO_MAX_PXCNT                       ((0x1b97  << 2) + 0xd0100000)
+#define ENCP_VIDEO_HSPULS_BEGIN                    ((0x1b98  << 2) + 0xd0100000)
+#define ENCP_VIDEO_HSPULS_END                      ((0x1b99  << 2) + 0xd0100000)
+#define ENCP_VIDEO_HSPULS_SWITCH                   ((0x1b9a  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VSPULS_BEGIN                    ((0x1b9b  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VSPULS_END                      ((0x1b9c  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VSPULS_BLINE                    ((0x1b9d  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VSPULS_ELINE                    ((0x1b9e  << 2) + 0xd0100000)
+#define ENCP_VIDEO_EQPULS_BEGIN                    ((0x1b9f  << 2) + 0xd0100000)
+#define ENCP_VIDEO_EQPULS_END                      ((0x1ba0  << 2) + 0xd0100000)
+#define ENCP_VIDEO_EQPULS_BLINE                    ((0x1ba1  << 2) + 0xd0100000)
+#define ENCP_VIDEO_EQPULS_ELINE                    ((0x1ba2  << 2) + 0xd0100000)
+#define ENCP_VIDEO_HAVON_END                       ((0x1ba3  << 2) + 0xd0100000)
+#define ENCP_VIDEO_HAVON_BEGIN                     ((0x1ba4  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VAVON_ELINE                     ((0x1baf  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VAVON_BLINE                     ((0x1ba6  << 2) + 0xd0100000)
+#define ENCP_VIDEO_HSO_BEGIN                       ((0x1ba7  << 2) + 0xd0100000)
+#define ENCP_VIDEO_HSO_END                         ((0x1ba8  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VSO_BEGIN                       ((0x1ba9  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VSO_END                         ((0x1baa  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VSO_BLINE                       ((0x1bab  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VSO_ELINE                       ((0x1bac  << 2) + 0xd0100000)
+#define ENCP_VIDEO_SYNC_WAVE_CURVE                 ((0x1bad  << 2) + 0xd0100000)
+#define ENCP_VIDEO_MAX_LNCNT                       ((0x1bae  << 2) + 0xd0100000)
+#define ENCP_VIDEO_SY_VAL                          ((0x1bb0  << 2) + 0xd0100000)
+#define ENCP_VIDEO_SY2_VAL                         ((0x1bb1  << 2) + 0xd0100000)
+#define ENCP_VIDEO_BLANKY_VAL                      ((0x1bb2  << 2) + 0xd0100000)
+#define ENCP_VIDEO_BLANKPB_VAL                     ((0x1bb3  << 2) + 0xd0100000)
+#define ENCP_VIDEO_BLANKPR_VAL                     ((0x1bb4  << 2) + 0xd0100000)
+#define ENCP_VIDEO_HOFFST                          ((0x1bb5  << 2) + 0xd0100000)
+#define ENCP_VIDEO_VOFFST                          ((0x1bb6  << 2) + 0xd0100000)
+#define ENCP_VIDEO_RGB_CTRL                        ((0x1bb7  << 2) + 0xd0100000)
+#define ENCP_VIDEO_FILT_CTRL                       ((0x1bb8  << 2) + 0xd0100000)
+#define ENCP_VIDEO_OFLD_VPEQ_OFST                  ((0x1bb9  << 2) + 0xd0100000)
+#define ENCP_VIDEO_OFLD_VOAV_OFST                  ((0x1bba  << 2) + 0xd0100000)
+#define ENCP_VIDEO_MATRIX_CB                       ((0x1bbb  << 2) + 0xd0100000)
+#define ENCP_VIDEO_MATRIX_CR                       ((0x1bbc  << 2) + 0xd0100000)
+#define ENCP_VIDEO_RGBIN_CTRL                      ((0x1bbd  << 2) + 0xd0100000)
+//------------------Macrovision advanced setting
+#define ENCP_MACV_BLANKY_VAL                       ((0x1bc0  << 2) + 0xd0100000)
+#define ENCP_MACV_MAXY_VAL                         ((0x1bc1  << 2) + 0xd0100000)
+#define ENCP_MACV_1ST_PSSYNC_STRT                  ((0x1bc2  << 2) + 0xd0100000)
+#define ENCP_MACV_PSSYNC_STRT                      ((0x1bc3  << 2) + 0xd0100000)
+#define ENCP_MACV_AGC_STRT                         ((0x1bc4  << 2) + 0xd0100000)
+#define ENCP_MACV_AGC_END                          ((0x1bc5  << 2) + 0xd0100000)
+#define ENCP_MACV_WAVE_END                         ((0x1bc6  << 2) + 0xd0100000)
+#define ENCP_MACV_STRTLINE                         ((0x1bc7  << 2) + 0xd0100000)
+#define ENCP_MACV_ENDLINE                          ((0x1bc8  << 2) + 0xd0100000)
+#define ENCP_MACV_TS_CNT_MAX_L                     ((0x1bc9  << 2) + 0xd0100000)
+#define ENCP_MACV_TS_CNT_MAX_H                     ((0x1bca  << 2) + 0xd0100000)
+#define ENCP_MACV_TIME_DOWN                        ((0x1bcb  << 2) + 0xd0100000)
+#define ENCP_MACV_TIME_LO                          ((0x1bcc  << 2) + 0xd0100000)
+#define ENCP_MACV_TIME_UP                          ((0x1bcd  << 2) + 0xd0100000)
+#define ENCP_MACV_TIME_RST                         ((0x1bce  << 2) + 0xd0100000)
+//---------------- VBI control -------------------
+#define ENCP_VBI_CTRL                              ((0x1bd0  << 2) + 0xd0100000)
+#define ENCP_VBI_SETTING                           ((0x1bd1  << 2) + 0xd0100000)
+#define ENCP_VBI_BEGIN                             ((0x1bd2  << 2) + 0xd0100000)
+#define ENCP_VBI_WIDTH                             ((0x1bd3  << 2) + 0xd0100000)
+#define ENCP_VBI_HVAL                              ((0x1bd4  << 2) + 0xd0100000)
+#define ENCP_VBI_DATA0                             ((0x1bd5  << 2) + 0xd0100000)
+#define ENCP_VBI_DATA1                             ((0x1bd6  << 2) + 0xd0100000)
+//----------------C656 OUT Control------------- Grant
+#define C656_HS_ST                                 ((0x1be0  << 2) + 0xd0100000)
+#define C656_HS_ED                                 ((0x1be1  << 2) + 0xd0100000)
+#define C656_VS_LNST_E                             ((0x1be2  << 2) + 0xd0100000)
+#define C656_VS_LNST_O                             ((0x1be3  << 2) + 0xd0100000)
+#define C656_VS_LNED_E                             ((0x1be4  << 2) + 0xd0100000)
+#define C656_VS_LNED_O                             ((0x1be5  << 2) + 0xd0100000)
+#define C656_FS_LNST                               ((0x1be6  << 2) + 0xd0100000)
+#define C656_FS_LNED                               ((0x1be7  << 2) + 0xd0100000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  enc480p_regs.h
+//
+//
+// Reading file:  enci_regs.h
+//
+//===========================================================================
+// Video Interface Registers    0xb00 - 0xb57
+//===========================================================================
+#define ENCI_VIDEO_MODE                            ((0x1b00  << 2) + 0xd0100000)
+#define ENCI_VIDEO_MODE_ADV                        ((0x1b01  << 2) + 0xd0100000)
+#define ENCI_VIDEO_FSC_ADJ                         ((0x1b02  << 2) + 0xd0100000)
+#define ENCI_VIDEO_BRIGHT                          ((0x1b03  << 2) + 0xd0100000)
+#define ENCI_VIDEO_CONT                            ((0x1b04  << 2) + 0xd0100000)
+#define ENCI_VIDEO_SAT                             ((0x1b05  << 2) + 0xd0100000)
+#define ENCI_VIDEO_HUE                             ((0x1b06  << 2) + 0xd0100000)
+#define ENCI_VIDEO_SCH                             ((0x1b07  << 2) + 0xd0100000)
+#define ENCI_SYNC_MODE                             ((0x1b08  << 2) + 0xd0100000)
+#define ENCI_SYNC_CTRL                             ((0x1b09  << 2) + 0xd0100000)
+#define ENCI_SYNC_HSO_BEGIN                        ((0x1b0a  << 2) + 0xd0100000)
+#define ENCI_SYNC_HSO_END                          ((0x1b0b  << 2) + 0xd0100000)
+#define ENCI_SYNC_VSO_EVN                          ((0x1b0c  << 2) + 0xd0100000)
+#define ENCI_SYNC_VSO_ODD                          ((0x1b0d  << 2) + 0xd0100000)
+#define ENCI_SYNC_VSO_EVNLN                        ((0x1b0e  << 2) + 0xd0100000)
+#define ENCI_SYNC_VSO_ODDLN                        ((0x1b0f  << 2) + 0xd0100000)
+#define ENCI_SYNC_HOFFST                           ((0x1b10  << 2) + 0xd0100000)
+#define ENCI_SYNC_VOFFST                           ((0x1b11  << 2) + 0xd0100000)
+#define ENCI_SYNC_ADJ                              ((0x1b12  << 2) + 0xd0100000)
+#define ENCI_RGB_SETTING                           ((0x1b13  << 2) + 0xd0100000)
+//`define	ENCI_CMPN_MATRIX_CB		8'h14
+//`define	ENCI_CMPN_MATRIX_CR		8'h15
+#define ENCI_DE_H_BEGIN                            ((0x1b16  << 2) + 0xd0100000)
+#define ENCI_DE_H_END                              ((0x1b17  << 2) + 0xd0100000)
+#define ENCI_DE_V_BEGIN_EVEN                       ((0x1b18  << 2) + 0xd0100000)
+#define ENCI_DE_V_END_EVEN                         ((0x1b19  << 2) + 0xd0100000)
+#define ENCI_DE_V_BEGIN_ODD                        ((0x1b1a  << 2) + 0xd0100000)
+#define ENCI_DE_V_END_ODD                          ((0x1b1b  << 2) + 0xd0100000)
+#define ENCI_VBI_SETTING                           ((0x1b20  << 2) + 0xd0100000)
+#define ENCI_VBI_CCDT_EVN                          ((0x1b21  << 2) + 0xd0100000)
+#define ENCI_VBI_CCDT_ODD                          ((0x1b22  << 2) + 0xd0100000)
+#define ENCI_VBI_CC525_LN                          ((0x1b23  << 2) + 0xd0100000)
+#define ENCI_VBI_CC625_LN                          ((0x1b24  << 2) + 0xd0100000)
+#define ENCI_VBI_WSSDT                             ((0x1b25  << 2) + 0xd0100000)
+#define ENCI_VBI_WSS_LN                            ((0x1b26  << 2) + 0xd0100000)
+#define ENCI_VBI_CGMSDT_L                          ((0x1b27  << 2) + 0xd0100000)
+#define ENCI_VBI_CGMSDT_H                          ((0x1b28  << 2) + 0xd0100000)
+#define ENCI_VBI_CGMS_LN                           ((0x1b29  << 2) + 0xd0100000)
+#define ENCI_VBI_TTX_HTIME                         ((0x1b2a  << 2) + 0xd0100000)
+#define ENCI_VBI_TTX_LN                            ((0x1b2b  << 2) + 0xd0100000)
+#define ENCI_VBI_TTXDT0                            ((0x1b2c  << 2) + 0xd0100000)
+#define ENCI_VBI_TTXDT1                            ((0x1b2d  << 2) + 0xd0100000)
+#define ENCI_VBI_TTXDT2                            ((0x1b2e  << 2) + 0xd0100000)
+#define ENCI_VBI_TTXDT3                            ((0x1b2f  << 2) + 0xd0100000)
+#define ENCI_MACV_N0                               ((0x1b30  << 2) + 0xd0100000)
+#define ENCI_MACV_N1                               ((0x1b31  << 2) + 0xd0100000)
+#define ENCI_MACV_N2                               ((0x1b32  << 2) + 0xd0100000)
+#define ENCI_MACV_N3                               ((0x1b33  << 2) + 0xd0100000)
+#define ENCI_MACV_N4                               ((0x1b34  << 2) + 0xd0100000)
+#define ENCI_MACV_N5                               ((0x1b35  << 2) + 0xd0100000)
+#define ENCI_MACV_N6                               ((0x1b36  << 2) + 0xd0100000)
+#define ENCI_MACV_N7                               ((0x1b37  << 2) + 0xd0100000)
+#define ENCI_MACV_N8                               ((0x1b38  << 2) + 0xd0100000)
+#define ENCI_MACV_N9                               ((0x1b39  << 2) + 0xd0100000)
+#define ENCI_MACV_N10                              ((0x1b3a  << 2) + 0xd0100000)
+#define ENCI_MACV_N11                              ((0x1b3b  << 2) + 0xd0100000)
+#define ENCI_MACV_N12                              ((0x1b3c  << 2) + 0xd0100000)
+#define ENCI_MACV_N13                              ((0x1b3d  << 2) + 0xd0100000)
+#define ENCI_MACV_N14                              ((0x1b3e  << 2) + 0xd0100000)
+#define ENCI_MACV_N15                              ((0x1b3f  << 2) + 0xd0100000)
+#define ENCI_MACV_N16                              ((0x1b40  << 2) + 0xd0100000)
+#define ENCI_MACV_N17                              ((0x1b41  << 2) + 0xd0100000)
+#define ENCI_MACV_N18                              ((0x1b42  << 2) + 0xd0100000)
+#define ENCI_MACV_N19                              ((0x1b43  << 2) + 0xd0100000)
+#define ENCI_MACV_N20                              ((0x1b44  << 2) + 0xd0100000)
+#define ENCI_MACV_N21                              ((0x1b45  << 2) + 0xd0100000)
+#define ENCI_MACV_N22                              ((0x1b46  << 2) + 0xd0100000)
+//`define	ENCI_MACV_P_AGC			8'h47
+#define ENCI_DBG_PX_RST                            ((0x1b48  << 2) + 0xd0100000)
+#define ENCI_DBG_FLDLN_RST                         ((0x1b49  << 2) + 0xd0100000)
+#define ENCI_DBG_PX_INT                            ((0x1b4a  << 2) + 0xd0100000)
+#define ENCI_DBG_FLDLN_INT                         ((0x1b4b  << 2) + 0xd0100000)
+#define ENCI_DBG_MAXPX                             ((0x1b4c  << 2) + 0xd0100000)
+#define ENCI_DBG_MAXLN                             ((0x1b4d  << 2) + 0xd0100000)
+#define ENCI_MACV_MAX_AMP                          ((0x1b50  << 2) + 0xd0100000)
+#define ENCI_MACV_PULSE_LO                         ((0x1b51  << 2) + 0xd0100000)
+#define ENCI_MACV_PULSE_HI                         ((0x1b52  << 2) + 0xd0100000)
+#define ENCI_MACV_BKP_MAX                          ((0x1b53  << 2) + 0xd0100000)
+#define ENCI_CFILT_CTRL                            ((0x1b54  << 2) + 0xd0100000)
+#define ENCI_CFILT7                                ((0x1b55  << 2) + 0xd0100000)
+#define ENCI_YC_DELAY                              ((0x1b56  << 2) + 0xd0100000)
+#define ENCI_VIDEO_EN                              ((0x1b57  << 2) + 0xd0100000)
+//
+// Closing file:  enci_regs.h
+//
+//`define  VENC2_VCBUS_BASE             8'h1c
+//
+// Reading file:  venc2_regs.h
+//
+//===========================================================================
+// Venc Registers (Cont.)    0xc00 - 0xcff (VENC registers 0xc00 - 0xcef; RDMA registers 0xcf0 - 0xcff)
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VENC2_VCBUS_BASE = 0x1c
+// -----------------------------------------------
+// Program video control signals from ENCI core to DVI/HDMI interface
+#define ENCI_DVI_HSO_BEGIN                         ((0x1c00  << 2) + 0xd0100000)
+#define ENCI_DVI_HSO_END                           ((0x1c01  << 2) + 0xd0100000)
+#define ENCI_DVI_VSO_BLINE_EVN                     ((0x1c02  << 2) + 0xd0100000)
+#define ENCI_DVI_VSO_BLINE_ODD                     ((0x1c03  << 2) + 0xd0100000)
+#define ENCI_DVI_VSO_ELINE_EVN                     ((0x1c04  << 2) + 0xd0100000)
+#define ENCI_DVI_VSO_ELINE_ODD                     ((0x1c05  << 2) + 0xd0100000)
+#define ENCI_DVI_VSO_BEGIN_EVN                     ((0x1c06  << 2) + 0xd0100000)
+#define ENCI_DVI_VSO_BEGIN_ODD                     ((0x1c07  << 2) + 0xd0100000)
+#define ENCI_DVI_VSO_END_EVN                       ((0x1c08  << 2) + 0xd0100000)
+#define ENCI_DVI_VSO_END_ODD                       ((0x1c09  << 2) + 0xd0100000)
+// Define cmpt and cvbs cb/cr delay after ENCI chroma filters
+// Bit 15:12 RW, enci_cb_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
+// Bit 11: 8 RW, enci_cr_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
+// Bit  7: 4 RW, enci_cb_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
+// Bit  3: 0 RW, enci_cr_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
+#define ENCI_CFILT_CTRL2                           ((0x1c0a  << 2) + 0xd0100000)
+#define ENCI_DACSEL_0                              ((0x1c0b  << 2) + 0xd0100000)
+#define ENCI_DACSEL_1                              ((0x1c0c  << 2) + 0xd0100000)
+#define ENCP_DACSEL_0                              ((0x1c0d  << 2) + 0xd0100000)
+#define ENCP_DACSEL_1                              ((0x1c0e  << 2) + 0xd0100000)
+#define ENCP_MAX_LINE_SWITCH_POINT                 ((0x1c0f  << 2) + 0xd0100000)
+#define ENCI_TST_EN                                ((0x1c10  << 2) + 0xd0100000)
+#define ENCI_TST_MDSEL                             ((0x1c11  << 2) + 0xd0100000)
+#define ENCI_TST_Y                                 ((0x1c12  << 2) + 0xd0100000)
+#define ENCI_TST_CB                                ((0x1c13  << 2) + 0xd0100000)
+#define ENCI_TST_CR                                ((0x1c14  << 2) + 0xd0100000)
+#define ENCI_TST_CLRBAR_STRT                       ((0x1c15  << 2) + 0xd0100000)
+#define ENCI_TST_CLRBAR_WIDTH                      ((0x1c16  << 2) + 0xd0100000)
+#define ENCI_TST_VDCNT_STSET                       ((0x1c17  << 2) + 0xd0100000)
+// bit 15:8 -- vfifo2vd_vd_sel
+// bit 7 -- vfifo2vd_drop
+// bit 6:1 -- vfifo2vd_delay
+// bit 0 -- vfifo2vd_en
+#define ENCI_VFIFO2VD_CTL                          ((0x1c18  << 2) + 0xd0100000)
+// bit 12:0 -- vfifo2vd_pixel_start 
+#define ENCI_VFIFO2VD_PIXEL_START                  ((0x1c19  << 2) + 0xd0100000)
+// bit 12:00 -- vfifo2vd_pixel_end   
+#define ENCI_VFIFO2VD_PIXEL_END                    ((0x1c1a  << 2) + 0xd0100000)
+// bit 10:0 -- vfifo2vd_line_top_start 
+#define ENCI_VFIFO2VD_LINE_TOP_START               ((0x1c1b  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_top_end   
+#define ENCI_VFIFO2VD_LINE_TOP_END                 ((0x1c1c  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_bot_start 
+#define ENCI_VFIFO2VD_LINE_BOT_START               ((0x1c1d  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_bot_end   
+#define ENCI_VFIFO2VD_LINE_BOT_END                 ((0x1c1e  << 2) + 0xd0100000)
+#define ENCI_VFIFO2VD_CTL2                         ((0x1c1f  << 2) + 0xd0100000)
+// bit 15:8 -- vfifo2vd_vd_sel
+// bit 7 -- vfifo2vd_drop
+// bit 6:1 -- vfifo2vd_delay
+// bit 0 -- vfifo2vd_en
+#define ENCT_VFIFO2VD_CTL                          ((0x1c20  << 2) + 0xd0100000)
+// bit 12:0 -- vfifo2vd_pixel_start 
+#define ENCT_VFIFO2VD_PIXEL_START                  ((0x1c21  << 2) + 0xd0100000)
+// bit 12:00 -- vfifo2vd_pixel_end   
+#define ENCT_VFIFO2VD_PIXEL_END                    ((0x1c22  << 2) + 0xd0100000)
+// bit 10:0 -- vfifo2vd_line_top_start 
+#define ENCT_VFIFO2VD_LINE_TOP_START               ((0x1c23  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_top_end   
+#define ENCT_VFIFO2VD_LINE_TOP_END                 ((0x1c24  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_bot_start 
+#define ENCT_VFIFO2VD_LINE_BOT_START               ((0x1c25  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_bot_end   
+#define ENCT_VFIFO2VD_LINE_BOT_END                 ((0x1c26  << 2) + 0xd0100000)
+#define ENCT_VFIFO2VD_CTL2                         ((0x1c27  << 2) + 0xd0100000)
+#define ENCT_TST_EN                                ((0x1c28  << 2) + 0xd0100000)
+#define ENCT_TST_MDSEL                             ((0x1c29  << 2) + 0xd0100000)
+#define ENCT_TST_Y                                 ((0x1c2a  << 2) + 0xd0100000)
+#define ENCT_TST_CB                                ((0x1c2b  << 2) + 0xd0100000)
+#define ENCT_TST_CR                                ((0x1c2c  << 2) + 0xd0100000)
+#define ENCT_TST_CLRBAR_STRT                       ((0x1c2d  << 2) + 0xd0100000)
+#define ENCT_TST_CLRBAR_WIDTH                      ((0x1c2e  << 2) + 0xd0100000)
+#define ENCT_TST_VDCNT_STSET                       ((0x1c2f  << 2) + 0xd0100000)
+// Program video control signals from ENCP core to DVI/HDMI interface
+#define ENCP_DVI_HSO_BEGIN                         ((0x1c30  << 2) + 0xd0100000)
+#define ENCP_DVI_HSO_END                           ((0x1c31  << 2) + 0xd0100000)
+#define ENCP_DVI_VSO_BLINE_EVN                     ((0x1c32  << 2) + 0xd0100000)
+#define ENCP_DVI_VSO_BLINE_ODD                     ((0x1c33  << 2) + 0xd0100000)
+#define ENCP_DVI_VSO_ELINE_EVN                     ((0x1c34  << 2) + 0xd0100000)
+#define ENCP_DVI_VSO_ELINE_ODD                     ((0x1c35  << 2) + 0xd0100000)
+#define ENCP_DVI_VSO_BEGIN_EVN                     ((0x1c36  << 2) + 0xd0100000)
+#define ENCP_DVI_VSO_BEGIN_ODD                     ((0x1c37  << 2) + 0xd0100000)
+#define ENCP_DVI_VSO_END_EVN                       ((0x1c38  << 2) + 0xd0100000)
+#define ENCP_DVI_VSO_END_ODD                       ((0x1c39  << 2) + 0xd0100000)
+#define ENCP_DE_H_BEGIN                            ((0x1c3a  << 2) + 0xd0100000)
+#define ENCP_DE_H_END                              ((0x1c3b  << 2) + 0xd0100000)
+#define ENCP_DE_V_BEGIN_EVEN                       ((0x1c3c  << 2) + 0xd0100000)
+#define ENCP_DE_V_END_EVEN                         ((0x1c3d  << 2) + 0xd0100000)
+#define ENCP_DE_V_BEGIN_ODD                        ((0x1c3e  << 2) + 0xd0100000)
+#define ENCP_DE_V_END_ODD                          ((0x1c3f  << 2) + 0xd0100000)
+// Bit 15:11 - sync length
+// Bit 10:0 - sync start line
+#define ENCI_SYNC_LINE_LENGTH                      ((0x1c40  << 2) + 0xd0100000)
+// Bit 15 - sync_pulse_enable
+// Bit 12:0 - sync start pixel
+#define ENCI_SYNC_PIXEL_EN                         ((0x1c41  << 2) + 0xd0100000)
+// Bit 15 - enci_sync_enable
+// Bit 14 - encp_sync_enable
+// Bit 13 - enct_sync_enable
+// Bit 12 - short_fussy_sync
+// Bit 11 - fussy_sync_enable
+// Bit 10:0 - sync target line
+#define ENCI_SYNC_TO_LINE_EN                       ((0x1c42  << 2) + 0xd0100000)
+// Bit 12:0 - sync target pixel
+#define ENCI_SYNC_TO_PIXEL                         ((0x1c43  << 2) + 0xd0100000)
+// Bit 15:11 - sync length
+// Bit 10:0 - sync start line
+#define ENCP_SYNC_LINE_LENGTH                      ((0x1c44  << 2) + 0xd0100000)
+// Bit 15 - sync_pulse_enable
+// Bit 12:0 - sync start pixel
+#define ENCP_SYNC_PIXEL_EN                         ((0x1c45  << 2) + 0xd0100000)
+// Bit 15 - enci_sync_enable
+// Bit 14 - encp_sync_enable
+// Bit 13 - enct_sync_enable
+// Bit 12 - short_fussy_sync
+// Bit 11 - fussy_sync_enable
+// Bit 10:0 - sync target line
+#define ENCP_SYNC_TO_LINE_EN                       ((0x1c46  << 2) + 0xd0100000)
+// Bit 12:0 - sync target pixel
+#define ENCP_SYNC_TO_PIXEL                         ((0x1c47  << 2) + 0xd0100000)
+// Bit 15:11 - sync length
+// Bit 10:0 - sync start line
+#define ENCT_SYNC_LINE_LENGTH                      ((0x1c48  << 2) + 0xd0100000)
+// Bit 15 - sync_pulse_enable
+// Bit 12:0 - sync start pixel
+#define ENCT_SYNC_PIXEL_EN                         ((0x1c49  << 2) + 0xd0100000)
+// Bit 15 - enci_sync_enable
+// Bit 14 - encp_sync_enable
+// Bit 13 - enct_sync_enable
+// Bit 12 - short_fussy_sync
+// Bit 11 - fussy_sync_enable
+// Bit 10:0 - sync target line
+#define ENCT_SYNC_TO_LINE_EN                       ((0x1c4a  << 2) + 0xd0100000)
+// Bit 12:0 - sync target pixel
+#define ENCT_SYNC_TO_PIXEL                         ((0x1c4b  << 2) + 0xd0100000)
+// Bit 15:11 - sync length
+// Bit 10:0 - sync start line
+#define ENCL_SYNC_LINE_LENGTH                      ((0x1c4c  << 2) + 0xd0100000)
+// Bit 15 - sync_pulse_enable
+// Bit 12:0 - sync start pixel
+#define ENCL_SYNC_PIXEL_EN                         ((0x1c4d  << 2) + 0xd0100000)
+// Bit 15 - enci_sync_enable
+// Bit 14 - encp_sync_enable
+// Bit 13 - enct_sync_enable
+// Bit 12 - short_fussy_sync
+// Bit 11 - fussy_sync_enable
+// Bit 10:0 - sync target line
+#define ENCL_SYNC_TO_LINE_EN                       ((0x1c4e  << 2) + 0xd0100000)
+// Bit 12:0 - sync target pixel
+#define ENCL_SYNC_TO_PIXEL                         ((0x1c4f  << 2) + 0xd0100000)
+// bit    3 cfg_encp_lcd_scaler_bypass. 1=Do not scale LCD input data;
+//                                      0=Scale LCD input data to y [16*4,235*4], c [16*4,240*4].
+// bit    2 cfg_encp_vadj_scaler_bypass. 1=Do not scale data to enc480p_vadj;
+//                                       0=Scale enc480p_vadj input data to y [16*4,235*4], c [16*4,240*4].
+// bit    1 cfg_vfifo2vd_out_scaler_bypass. 1=Do not scale vfifo2vd's output vdata;
+//                                          0=Scale vfifo2vd's output vdata to y [16,235], c [16,240].
+// bit    0 cfg_vfifo_din_full_range. 1=Data from viu fifo is full range [0,1023];
+//                                    0=Data from viu fifo is y [16*4,235*4], c [16*4,240*4].
+#define ENCP_VFIFO2VD_CTL2                         ((0x1c50  << 2) + 0xd0100000)
+// bit 15:1 Reserved.
+// bit    0 cfg_int_dvi_sel_rgb. Applicable for using on-chip hdmi tx module only. This bit controls correct bit-mapping from
+//          Venc to hdmi_tx depending on whether YCbCr or RGB mode.
+//                               1=Map data bit from Venc to hdmi_tx for RGB mode;
+//                               0=Default. Map data bit from Venc to hdmi_tx for YCbCr mode.
+#define VENC_DVI_SETTING_MORE                      ((0x1c51  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC4_FILT_CTRL0                  ((0x1c54  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC4_FILT_CTRL1                  ((0x1c55  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC5_FILT_CTRL0                  ((0x1c56  << 2) + 0xd0100000)
+#define VENC_VDAC_DAC5_FILT_CTRL1                  ((0x1c57  << 2) + 0xd0100000)
+//Bit 0   filter_en
+#define VENC_VDAC_DAC0_FILT_CTRL0                  ((0x1c58  << 2) + 0xd0100000)
+//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
+//Bit 15:8, coef1,
+//Bit 7:0, coef0, 
+#define VENC_VDAC_DAC0_FILT_CTRL1                  ((0x1c59  << 2) + 0xd0100000)
+//Bit 0   filter_en
+#define VENC_VDAC_DAC1_FILT_CTRL0                  ((0x1c5a  << 2) + 0xd0100000)
+//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
+//Bit 15:8, coef1,
+//Bit 7:0, coef0, 
+#define VENC_VDAC_DAC1_FILT_CTRL1                  ((0x1c5b  << 2) + 0xd0100000)
+//Bit 0   filter_en
+#define VENC_VDAC_DAC2_FILT_CTRL0                  ((0x1c5c  << 2) + 0xd0100000)
+//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
+//Bit 15:8, coef1,
+//Bit 7:0, coef0, 
+#define VENC_VDAC_DAC2_FILT_CTRL1                  ((0x1c5d  << 2) + 0xd0100000)
+//Bit 0   filter_en
+#define VENC_VDAC_DAC3_FILT_CTRL0                  ((0x1c5e  << 2) + 0xd0100000)
+//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
+//Bit 15:8, coef1,
+//Bit 7:0, coef0, 
+#define VENC_VDAC_DAC3_FILT_CTRL1                  ((0x1c5f  << 2) + 0xd0100000)
+//===========================================================================
+// ENCT registers
+#define ENCT_VIDEO_EN                              ((0x1c60  << 2) + 0xd0100000)
+#define ENCT_VIDEO_Y_SCL                           ((0x1c61  << 2) + 0xd0100000)
+#define ENCT_VIDEO_PB_SCL                          ((0x1c62  << 2) + 0xd0100000)
+#define ENCT_VIDEO_PR_SCL                          ((0x1c63  << 2) + 0xd0100000)
+#define ENCT_VIDEO_Y_OFFST                         ((0x1c64  << 2) + 0xd0100000)
+#define ENCT_VIDEO_PB_OFFST                        ((0x1c65  << 2) + 0xd0100000)
+#define ENCT_VIDEO_PR_OFFST                        ((0x1c66  << 2) + 0xd0100000)
+//----- Video mode
+#define ENCT_VIDEO_MODE                            ((0x1c67  << 2) + 0xd0100000)
+#define ENCT_VIDEO_MODE_ADV                        ((0x1c68  << 2) + 0xd0100000)
+//--------------- Debug pins
+#define ENCT_DBG_PX_RST                            ((0x1c69  << 2) + 0xd0100000)
+#define ENCT_DBG_LN_RST                            ((0x1c6a  << 2) + 0xd0100000)
+#define ENCT_DBG_PX_INT                            ((0x1c6b  << 2) + 0xd0100000)
+#define ENCT_DBG_LN_INT                            ((0x1c6c  << 2) + 0xd0100000)
+//----------- Video Advanced setting
+#define ENCT_VIDEO_YFP1_HTIME                      ((0x1c6d  << 2) + 0xd0100000)
+#define ENCT_VIDEO_YFP2_HTIME                      ((0x1c6e  << 2) + 0xd0100000)
+#define ENCT_VIDEO_YC_DLY                          ((0x1c6f  << 2) + 0xd0100000)
+#define ENCT_VIDEO_MAX_PXCNT                       ((0x1c70  << 2) + 0xd0100000)
+#define ENCT_VIDEO_HAVON_END                       ((0x1c71  << 2) + 0xd0100000)
+#define ENCT_VIDEO_HAVON_BEGIN                     ((0x1c72  << 2) + 0xd0100000)
+#define ENCT_VIDEO_VAVON_ELINE                     ((0x1c73  << 2) + 0xd0100000)
+#define ENCT_VIDEO_VAVON_BLINE                     ((0x1c74  << 2) + 0xd0100000)
+#define ENCT_VIDEO_HSO_BEGIN                       ((0x1c75  << 2) + 0xd0100000)
+#define ENCT_VIDEO_HSO_END                         ((0x1c76  << 2) + 0xd0100000)
+#define ENCT_VIDEO_VSO_BEGIN                       ((0x1c77  << 2) + 0xd0100000)
+#define ENCT_VIDEO_VSO_END                         ((0x1c78  << 2) + 0xd0100000)
+#define ENCT_VIDEO_VSO_BLINE                       ((0x1c79  << 2) + 0xd0100000)
+#define ENCT_VIDEO_VSO_ELINE                       ((0x1c7a  << 2) + 0xd0100000)
+#define ENCT_VIDEO_MAX_LNCNT                       ((0x1c7b  << 2) + 0xd0100000)
+#define ENCT_VIDEO_BLANKY_VAL                      ((0x1c7c  << 2) + 0xd0100000)
+#define ENCT_VIDEO_BLANKPB_VAL                     ((0x1c7d  << 2) + 0xd0100000)
+#define ENCT_VIDEO_BLANKPR_VAL                     ((0x1c7e  << 2) + 0xd0100000)
+#define ENCT_VIDEO_HOFFST                          ((0x1c7f  << 2) + 0xd0100000)
+#define ENCT_VIDEO_VOFFST                          ((0x1c80  << 2) + 0xd0100000)
+#define ENCT_VIDEO_RGB_CTRL                        ((0x1c81  << 2) + 0xd0100000)
+#define ENCT_VIDEO_FILT_CTRL                       ((0x1c82  << 2) + 0xd0100000)
+#define ENCT_VIDEO_OFLD_VPEQ_OFST                  ((0x1c83  << 2) + 0xd0100000)
+#define ENCT_VIDEO_OFLD_VOAV_OFST                  ((0x1c84  << 2) + 0xd0100000)
+#define ENCT_VIDEO_MATRIX_CB                       ((0x1c85  << 2) + 0xd0100000)
+#define ENCT_VIDEO_MATRIX_CR                       ((0x1c86  << 2) + 0xd0100000)
+#define ENCT_VIDEO_RGBIN_CTRL                      ((0x1c87  << 2) + 0xd0100000)
+#define ENCT_MAX_LINE_SWITCH_POINT                 ((0x1c88  << 2) + 0xd0100000)
+#define ENCT_DACSEL_0                              ((0x1c89  << 2) + 0xd0100000)
+#define ENCT_DACSEL_1                              ((0x1c8a  << 2) + 0xd0100000)
+//===========================================================================
+// For ENCL
+//===========================================================================
+// bit 15:8 -- vfifo2vd_vd_sel
+// bit 7 -- vfifo2vd_drop
+// bit 6:1 -- vfifo2vd_delay
+// bit 0 -- vfifo2vd_en
+#define ENCL_VFIFO2VD_CTL                          ((0x1c90  << 2) + 0xd0100000)
+// bit 12:0 -- vfifo2vd_pixel_start 
+#define ENCL_VFIFO2VD_PIXEL_START                  ((0x1c91  << 2) + 0xd0100000)
+// bit 12:00 -- vfifo2vd_pixel_end   
+#define ENCL_VFIFO2VD_PIXEL_END                    ((0x1c92  << 2) + 0xd0100000)
+// bit 10:0 -- vfifo2vd_line_top_start 
+#define ENCL_VFIFO2VD_LINE_TOP_START               ((0x1c93  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_top_end   
+#define ENCL_VFIFO2VD_LINE_TOP_END                 ((0x1c94  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_bot_start 
+#define ENCL_VFIFO2VD_LINE_BOT_START               ((0x1c95  << 2) + 0xd0100000)
+// bit 10:00 -- vfifo2vd_line_bot_end   
+#define ENCL_VFIFO2VD_LINE_BOT_END                 ((0x1c96  << 2) + 0xd0100000)
+#define ENCL_VFIFO2VD_CTL2                         ((0x1c97  << 2) + 0xd0100000)
+#define ENCL_TST_EN                                ((0x1c98  << 2) + 0xd0100000)
+#define ENCL_TST_MDSEL                             ((0x1c99  << 2) + 0xd0100000)
+#define ENCL_TST_Y                                 ((0x1c9a  << 2) + 0xd0100000)
+#define ENCL_TST_CB                                ((0x1c9b  << 2) + 0xd0100000)
+#define ENCL_TST_CR                                ((0x1c9c  << 2) + 0xd0100000)
+#define ENCL_TST_CLRBAR_STRT                       ((0x1c9d  << 2) + 0xd0100000)
+#define ENCL_TST_CLRBAR_WIDTH                      ((0x1c9e  << 2) + 0xd0100000)
+#define ENCL_TST_VDCNT_STSET                       ((0x1c9f  << 2) + 0xd0100000)
+//===========================================================================
+// ENCL registers
+#define ENCL_VIDEO_EN                              ((0x1ca0  << 2) + 0xd0100000)
+#define ENCL_VIDEO_Y_SCL                           ((0x1ca1  << 2) + 0xd0100000)
+#define ENCL_VIDEO_PB_SCL                          ((0x1ca2  << 2) + 0xd0100000)
+#define ENCL_VIDEO_PR_SCL                          ((0x1ca3  << 2) + 0xd0100000)
+#define ENCL_VIDEO_Y_OFFST                         ((0x1ca4  << 2) + 0xd0100000)
+#define ENCL_VIDEO_PB_OFFST                        ((0x1ca5  << 2) + 0xd0100000)
+#define ENCL_VIDEO_PR_OFFST                        ((0x1ca6  << 2) + 0xd0100000)
+//----- Video mode
+#define ENCL_VIDEO_MODE                            ((0x1ca7  << 2) + 0xd0100000)
+#define ENCL_VIDEO_MODE_ADV                        ((0x1ca8  << 2) + 0xd0100000)
+//--------------- Debug pins
+#define ENCL_DBG_PX_RST                            ((0x1ca9  << 2) + 0xd0100000)
+#define ENCL_DBG_LN_RST                            ((0x1caa  << 2) + 0xd0100000)
+#define ENCL_DBG_PX_INT                            ((0x1cab  << 2) + 0xd0100000)
+#define ENCL_DBG_LN_INT                            ((0x1cac  << 2) + 0xd0100000)
+//----------- Video Advanced setting
+#define ENCL_VIDEO_YFP1_HTIME                      ((0x1cad  << 2) + 0xd0100000)
+#define ENCL_VIDEO_YFP2_HTIME                      ((0x1cae  << 2) + 0xd0100000)
+#define ENCL_VIDEO_YC_DLY                          ((0x1caf  << 2) + 0xd0100000)
+#define ENCL_VIDEO_MAX_PXCNT                       ((0x1cb0  << 2) + 0xd0100000)
+#define ENCL_VIDEO_HAVON_END                       ((0x1cb1  << 2) + 0xd0100000)
+#define ENCL_VIDEO_HAVON_BEGIN                     ((0x1cb2  << 2) + 0xd0100000)
+#define ENCL_VIDEO_VAVON_ELINE                     ((0x1cb3  << 2) + 0xd0100000)
+#define ENCL_VIDEO_VAVON_BLINE                     ((0x1cb4  << 2) + 0xd0100000)
+#define ENCL_VIDEO_HSO_BEGIN                       ((0x1cb5  << 2) + 0xd0100000)
+#define ENCL_VIDEO_HSO_END                         ((0x1cb6  << 2) + 0xd0100000)
+#define ENCL_VIDEO_VSO_BEGIN                       ((0x1cb7  << 2) + 0xd0100000)
+#define ENCL_VIDEO_VSO_END                         ((0x1cb8  << 2) + 0xd0100000)
+#define ENCL_VIDEO_VSO_BLINE                       ((0x1cb9  << 2) + 0xd0100000)
+#define ENCL_VIDEO_VSO_ELINE                       ((0x1cba  << 2) + 0xd0100000)
+#define ENCL_VIDEO_MAX_LNCNT                       ((0x1cbb  << 2) + 0xd0100000)
+#define ENCL_VIDEO_BLANKY_VAL                      ((0x1cbc  << 2) + 0xd0100000)
+#define ENCL_VIDEO_BLANKPB_VAL                     ((0x1cbd  << 2) + 0xd0100000)
+#define ENCL_VIDEO_BLANKPR_VAL                     ((0x1cbe  << 2) + 0xd0100000)
+#define ENCL_VIDEO_HOFFST                          ((0x1cbf  << 2) + 0xd0100000)
+#define ENCL_VIDEO_VOFFST                          ((0x1cc0  << 2) + 0xd0100000)
+#define ENCL_VIDEO_RGB_CTRL                        ((0x1cc1  << 2) + 0xd0100000)
+#define ENCL_VIDEO_FILT_CTRL                       ((0x1cc2  << 2) + 0xd0100000)
+#define ENCL_VIDEO_OFLD_VPEQ_OFST                  ((0x1cc3  << 2) + 0xd0100000)
+#define ENCL_VIDEO_OFLD_VOAV_OFST                  ((0x1cc4  << 2) + 0xd0100000)
+#define ENCL_VIDEO_MATRIX_CB                       ((0x1cc5  << 2) + 0xd0100000)
+#define ENCL_VIDEO_MATRIX_CR                       ((0x1cc6  << 2) + 0xd0100000)
+#define ENCL_VIDEO_RGBIN_CTRL                      ((0x1cc7  << 2) + 0xd0100000)
+#define ENCL_MAX_LINE_SWITCH_POINT                 ((0x1cc8  << 2) + 0xd0100000)
+#define ENCL_DACSEL_0                              ((0x1cc9  << 2) + 0xd0100000)
+#define ENCL_DACSEL_1                              ((0x1cca  << 2) + 0xd0100000)
+//===========================================================================
+// RDMA Registers       0xcf0 - 0xcff
+// Bit 31: 0 RW AHB start address for manual start DMA
+#define RDMA_AHB_START_ADDR_MAN                    ((0x1cf0  << 2) + 0xd0100000)
+// Bit 31: 0 RW AHB end address for manual start DMA
+#define RDMA_AHB_END_ADDR_MAN                      ((0x1cf1  << 2) + 0xd0100000)
+// Bit 31: 0 RW AHB start address for auto start source 1
+#define RDMA_AHB_START_ADDR_1                      ((0x1cf2  << 2) + 0xd0100000)
+// Bit 31: 0 RW AHB end address for auto start source 1
+#define RDMA_AHB_END_ADDR_1                        ((0x1cf3  << 2) + 0xd0100000)
+// Bit 31: 0 RW AHB start address for auto start source 2
+#define RDMA_AHB_START_ADDR_2                      ((0x1cf4  << 2) + 0xd0100000)
+// Bit 31: 0 RW AHB end address for auto start source 2
+#define RDMA_AHB_END_ADDR_2                        ((0x1cf5  << 2) + 0xd0100000)
+// Bit 31: 0 RW AHB start address for auto start source 3
+#define RDMA_AHB_START_ADDR_3                      ((0x1cf6  << 2) + 0xd0100000)
+// Bit 31: 0 RW AHB end address for auto start source 3
+#define RDMA_AHB_END_ADDR_3                        ((0x1cf7  << 2) + 0xd0100000)
+// Auto start DMA control:
+// Bit 31:24 RW ctrl_enable_int_3. Interrupt inputs enable mask for source 3.
+// Bit 23:16 RW ctrl_enable_int_2. Interrupt inputs enable mask for source 2.
+// Bit 15: 8 RW ctrl_enable_int_1. Interrupt inputs enable mask for source 1.
+// Bit     7 RW ctrl_cbus_write_3. Register read/write mode for auto-start 3. 1=Register write; 0=Register read.
+// Bit     6 RW ctrl_cbus_write_3. Register read/write mode for auto-start 2. 1=Register write; 0=Register read.
+// Bit     5 RW ctrl_cbus_write_3. Register read/write mode for auto-start 1. 1=Register write; 0=Register read.
+// Bit     4 R  Rsrv.
+// Bit     3 RW ctrl_cbus_addr_incr_3. 1=Incremental register access for auto-start 3; 0=Non-incremental (individual) register access.
+// Bit     2 RW ctrl_cbus_addr_incr_2. 1=Incremental register access for auto-start 2; 0=Non-incremental (individual) register access.
+// Bit     1 RW ctrl_cbus_addr_incr_1. 1=Incremental register access for auto-start 1; 0=Non-incremental (individual) register access.
+// Bit     0 R  Rsrv.
+#define RDMA_ACCESS_AUTO                           ((0x1cf8  << 2) + 0xd0100000)
+// Manual start DMA control:
+// Bit 31: 3 R  Rsrv.
+// Bit     2 RW ctrl_cbus_write_man. Register read/write mode for manual-start. 1=Register write; 0=Register read.
+// Bit     1 RW ctrl_cbus_addr_incr_man. 1=Incremental register access for manual-start; 0=Non-incremental (individual) register access.
+// Bit     0 W  ctrl_start_man. Write 1 to this bit to manual-start DMA. This bit always read back 0.
+#define RDMA_ACCESS_MAN                            ((0x1cf9  << 2) + 0xd0100000)
+// RDMA general control:
+// Bit 31:25 R  Rsrv.
+// Bit    24 W  ctrl_clr_rdma_done_int. Write 1 to reset rdma_int level to 0. No need to clear this bit.
+// Bit 23:19 R  Rsrv.
+// Bit 18:13 R  Rsrv.
+// Bit 12: 7 R  Rsrv.
+// Bit     6 RW ctrl_ddr_urgent.
+// Bit  5: 4 RW ctrl_ahb_wr_burst_size. 0=ABH write request burst size 16;
+//                                      1=ABH write request burst size 24;
+//                                      2=ABH write request burst size 32;
+//                                      3=ABH write request burst size 48.
+// Bit  3: 2 RW ctrl_ahb_rd_burst_size. 0=ABH read request burst size 16;
+//                                      1=ABH read request burst size 24;
+//                                      2=ABH read request burst size 32;
+//                                      3=ABH read request burst size 48.
+// Bit     1 RW ctrl_sw_reset. 1=Reset RDMA logics except register.
+// Bit     0 RW ctrl_free_clk_enable. 0=Default, Enable clock gating. 1=No clock gating, enable free clock.
+#define RDMA_CTRL                                  ((0x1cfa  << 2) + 0xd0100000)
+// Read only.
+// Bit 31:29 R  Rsrv.
+// Bit    28 R  rdma_done_int.
+// Bit 27:25 R  Rsrv.
+// Bit 24:18 R  ahb_wrfifo_cnt. FIFO for buffering CBus read data to be sent to AHB
+// Bit 17:11 R  ahb_rdfifo_cnt. FIFO for buffering data read from AHB.
+// Bit 10: 8 R  ddr_req_st. =0 -- Idle; !=0 -- AHB interfacing ongoing.
+// Bit  7: 4 R  curr_req. Latest requests that is being/been serviced. E.g. 0000=Idle; 0010=Latest serviced request is Req 1.
+// Bit  3: 0 R  req_latch. Requests that are yet to be serviced. E.g. 0000=No request; 0001=Req 0 waiting; 1100=Req 2 and 3 waiting.
+#define RDMA_STATUS                                ((0x1cfb  << 2) + 0xd0100000)
+//
+// Closing file:  venc2_regs.h
+//
+//`define VPP_VCBUS_BASE			     8'h1d
+//
+// Reading file:  vpp_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  VPP_VCBUS_BASE = 0x1d
+// -----------------------------------------------
+//===========================================================================
+// Video postprocesing Registers 
+//===========================================================================
+// dummy data used in the VPP preblend and scaler
+// Bit 23:16    Y
+// Bit 15:8     CB
+// Bit 7:0      CR 
+#define VPP_DUMMY_DATA                             ((0x1d00  << 2) + 0xd0100000)
+//input line length used in VPP
+#define VPP_LINE_IN_LENGTH                         ((0x1d01  << 2) + 0xd0100000)
+//input Picture height used in VPP
+#define VPP_PIC_IN_HEIGHT                          ((0x1d02  << 2) + 0xd0100000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients 
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
+//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 13    if true, vertical separated coef enable
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered 
+//Bit 6:0 	coef index
+#define VPP_SCALE_COEF_IDX                         ((0x1d03  << 2) + 0xd0100000)
+//coefficients for vertical filter and horizontal filter
+#define VPP_SCALE_COEF                             ((0x1d04  << 2) + 0xd0100000)
+//these following registers are the absolute line address pointer for output divided screen
+//The output divided screen is shown in the following:
+//
+//  --------------------------   <------ line zero
+//		. 
+//		.
+//		.		    region0        <---------- nonlinear region or nonscaling region	
+//		.
+//  ---------------------------  
+//  ---------------------------  <------ region1_startp 
+//		.
+//		.           region1         <---------- nonlinear region
+//		.
+//		.
+//  ---------------------------  
+//  ---------------------------  <------ region2_startp
+//		.
+//		.           region2         <---------- linear region
+//		.
+//		.
+//  ---------------------------  
+//  ---------------------------  <------ region3_startp
+//		.
+//		.           region3         <---------- nonlinear region
+//		.
+//		.
+//  ---------------------------  
+//  ---------------------------  <------ region4_startp
+//		.
+//		.           region4         <---------- nonlinear region or nonoscaling region
+//		.
+//		.
+//  ---------------------------  <------ region4_endp
+//Bit 28:16 region1 startp
+//Bit 12:0 region2 startp
+#define VPP_VSC_REGION12_STARTP                    ((0x1d05  << 2) + 0xd0100000)
+//Bit 28:16 region3 startp
+//Bit 12:0 region4 startp
+#define VPP_VSC_REGION34_STARTP                    ((0x1d06  << 2) + 0xd0100000)
+#define VPP_VSC_REGION4_ENDP                       ((0x1d07  << 2) + 0xd0100000)
+//vertical start phase step, (source/dest)*(2^24)
+//Bit 27:24 integer part 
+//Bit 23:0	fraction part
+#define VPP_VSC_START_PHASE_STEP                   ((0x1d08  << 2) + 0xd0100000)
+//vertical scaler region0 phase slope, Bit24 signed bit
+#define VPP_VSC_REGION0_PHASE_SLOPE                ((0x1d09  << 2) + 0xd0100000)
+//vertical scaler region1 phase slope, Bit24 signed bit
+#define VPP_VSC_REGION1_PHASE_SLOPE                ((0x1d0a  << 2) + 0xd0100000)
+//vertical scaler region3 phase slope, Bit24 signed bit
+#define VPP_VSC_REGION3_PHASE_SLOPE                ((0x1d0b  << 2) + 0xd0100000)
+//vertical scaler region4 phase slope, Bit24 signed bit
+#define VPP_VSC_REGION4_PHASE_SLOPE                ((0x1d0c  << 2) + 0xd0100000)
+//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X, 
+//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
+//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
+//Bit 16     0: progressive output, 1: interlace output
+//Bit 15     vertical scaler output line0 in advance or not for bottom field
+//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
+//Bit 11:8   vertical scaler initial receiving  number for bottom field   
+//Bit 7      vertical scaler output line0 in advance or not for top field
+//Bit 6:5    vertical scaler initial repeat line0 number for top field
+//Bit 3:0    vertical scaler initial receiving  number for top field   
+#define VPP_VSC_PHASE_CTRL                         ((0x1d0d  << 2) + 0xd0100000)
+//Bit 31:16  vertical scaler field initial phase for bottom field
+//Bit 15:0  vertical scaler field initial phase for top field
+#define VPP_VSC_INI_PHASE                          ((0x1d0e  << 2) + 0xd0100000)
+//Bit 28:16 region1 startp
+//Bit 12:0 region2 startp
+#define VPP_HSC_REGION12_STARTP                    ((0x1d10  << 2) + 0xd0100000)
+//Bit 28:16 region3 startp
+//Bit 12:0 region4 startp
+#define VPP_HSC_REGION34_STARTP                    ((0x1d11  << 2) + 0xd0100000)
+#define VPP_HSC_REGION4_ENDP                       ((0x1d12  << 2) + 0xd0100000)
+//horizontal start phase step, (source/dest)*(2^24)
+//Bit 27:24 integer part 
+//Bit 23:0	fraction part
+#define VPP_HSC_START_PHASE_STEP                   ((0x1d13  << 2) + 0xd0100000)
+//horizontal scaler region0 phase slope, Bit24 signed bit
+#define VPP_HSC_REGION0_PHASE_SLOPE                ((0x1d14  << 2) + 0xd0100000)
+//horizontal scaler region1 phase slope, Bit24 signed bit
+#define VPP_HSC_REGION1_PHASE_SLOPE                ((0x1d15  << 2) + 0xd0100000)
+//horizontal scaler region3 phase slope, Bit24 signed bit
+#define VPP_HSC_REGION3_PHASE_SLOPE                ((0x1d16  << 2) + 0xd0100000)
+//horizontal scaler region4 phase slope, Bit24 signed bit
+#define VPP_HSC_REGION4_PHASE_SLOPE                ((0x1d17  << 2) + 0xd0100000)
+//Bit 22:21   horizontal scaler initial repeat pixel0 number0
+//Bit 19:16   horizontal scaler initial receiving number0   
+//Bit 15:0    horizontal scaler top field initial phase0
+#define VPP_HSC_PHASE_CTRL                         ((0x1d18  << 2) + 0xd0100000)
+// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
+//                 just for special usage, more flexibility
+// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
+// Bit 20 prehsc_en
+// Bit 19 prevsc_en
+// Bit 18 vsc_en
+// Bit 17 hsc_en
+// Bit 16 scale_top_en
+// Bit 15 video1 scale out enable
+// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler 
+// Bit 10:8 horizontal scaler bank length
+// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
+// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler 
+// Bit 2:0 vertical scaler bank length
+#define VPP_SC_MISC                                ((0x1d19  << 2) + 0xd0100000)
+// preblend video1 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_PREBLEND_VD1_H_START_END               ((0x1d1a  << 2) + 0xd0100000)
+// preblend video1 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_PREBLEND_VD1_V_START_END               ((0x1d1b  << 2) + 0xd0100000)
+// postblend video1 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_POSTBLEND_VD1_H_START_END              ((0x1d1c  << 2) + 0xd0100000)
+// postblend video1 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_POSTBLEND_VD1_V_START_END              ((0x1d1d  << 2) + 0xd0100000)
+// preblend/postblend video2 horizontal start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_BLEND_VD2_H_START_END                  ((0x1d1e  << 2) + 0xd0100000)
+// preblend/postblend video2 vertical start and end
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_BLEND_VD2_V_START_END                  ((0x1d1f  << 2) + 0xd0100000)
+// preblend horizontal size
+#define VPP_PREBLEND_H_SIZE                        ((0x1d20  << 2) + 0xd0100000)
+// postblend horizontal size
+#define VPP_POSTBLEND_H_SIZE                       ((0x1d21  << 2) + 0xd0100000)
+//VPP hold lines
+//Bit 29:24
+//Bit 21:16
+//Bit 15:8     preblend hold lines
+//Bit 7:0      postblend hold lines
+#define VPP_HOLD_LINES                             ((0x1d22  << 2) + 0xd0100000)
+//Bit 25   if true, change screen to one color value for preblender
+//Bit 24   if true, change screen to one color value for postblender
+// Bit 23:16 one color Y
+// Bit 15:8 one color Cb
+// Bit  7:0 one color  Cr
+#define VPP_BLEND_ONECOLOR_CTRL                    ((0x1d23  << 2) + 0xd0100000)
+//Read Only, VPP preblend current_x, current_y
+//Bit 28:16 current_x
+//Bit 12:0 current_y
+#define VPP_PREBLEND_CURRENT_XY                    ((0x1d24  << 2) + 0xd0100000)
+//Read Only, VPP postblend current_x, current_y
+//Bit 28:16 current_x
+//Bit 12:0 current_y
+#define VPP_POSTBLEND_CURRENT_XY                   ((0x1d25  << 2) + 0xd0100000)
+// Bit 31  vd1_bgosd_exchange_en for preblend
+// Bit 30  vd1_bgosd_exchange_en for postblend
+// Bit 28   color management enable
+// Bit 27,  if true, vd2 use viu2 output as the input, otherwise use normal vd2 from memory 
+// Bit 26:18, vd2 alpha
+// Bit 17, osd2 enable for preblend
+// Bit 16, osd1 enable for preblend
+// Bit 15, vd2 enable for preblend
+// Bit 14, vd1 enable for preblend
+// Bit 13, osd2 enable for postblend
+// Bit 12, osd1 enable for postblend
+// Bit 11, vd2 enable for postblend
+// Bit 10, vd1 enable for postblend
+// Bit 9,  if true, osd1 is alpha premultipiled 
+// Bit 8,  if true, osd2 is alpha premultipiled 
+// Bit 7,  postblend module enable
+// Bit 6,  preblend module enable
+// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
+// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
+// Bit 3,  
+// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
+//			 the aync fifo will be reseted.
+// Bit 1,	  
+// Bit 0	if true, the output result of VPP is saturated
+#define VPP_MISC                                   ((0x1d26  << 2) + 0xd0100000)
+//Bit 31:20 ofifo line length minus 1
+//Bit 19  if true invert input vs
+//Bit 18  if true invert input hs
+//Bit 17  force top/bottom field, enable
+//Bit 16  force top/bottom field, 0: top, 1: bottom
+//Bit 15  force one go_field, one pluse, write only
+//Bit 14  force one go_line, one pluse, write only
+//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
+#define VPP_OFIFO_SIZE                             ((0x1d27  << 2) + 0xd0100000)
+//Read only
+//Bit 28:18 current scale out fifo counter
+//Bit 17:13 current afifo counter
+//Bit 12:0 current ofifo counter
+#define VPP_FIFO_STATUS                            ((0x1d28  << 2) + 0xd0100000)
+// Bit 5 SMOKE3 postblend enable only when postblend vd2 is not enable 
+// Bit 4 SMOKE3 preblend enable only when preblend vd2 is not enable 
+// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable 
+// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable 
+// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable 
+// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable 
+#define VPP_SMOKE_CTRL                             ((0x1d29  << 2) + 0xd0100000)
+//smoke can be used only when that blending is disable and then be used as smoke function
+//smoke1 for OSD1 chanel
+//smoke2 for OSD2 chanel
+//smoke3 for VD2 chanel
+//31:24 Y
+//23:16 Cb
+//15:8 Cr
+//7:0 Alpha
+#define VPP_SMOKE1_VAL                             ((0x1d2a  << 2) + 0xd0100000)
+#define VPP_SMOKE2_VAL                             ((0x1d2b  << 2) + 0xd0100000)
+#define VPP_SMOKE3_VAL                             ((0x1d2c  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_SMOKE1_H_START_END                     ((0x1d2d  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_SMOKE1_V_START_END                     ((0x1d2e  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_SMOKE2_H_START_END                     ((0x1d2f  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_SMOKE2_V_START_END                     ((0x1d30  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_SMOKE3_H_START_END                     ((0x1d31  << 2) + 0xd0100000)
+//Bit 28:16 start
+//Bit 12:0 end
+#define VPP_SMOKE3_V_START_END                     ((0x1d32  << 2) + 0xd0100000)
+//Bit 27:16 scale out fifo line length minus 1
+//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
+#define VPP_SCO_FIFO_CTRL                          ((0x1d33  << 2) + 0xd0100000)
+//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
+//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode, 
+//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
+//Bit 23 horizontal scaler double pixel mode
+//Bit 22:21   horizontal scaler initial repeat pixel0 number1
+//Bit 19:16   horizontal scaler initial receiving number1   
+//Bit 15:0    horizontal scaler top field initial phase1
+#define VPP_HSC_PHASE_CTRL1                        ((0x1d34  << 2) + 0xd0100000)
+//for 3D quincunx sub-sampling
+//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
+//22:20  prehsc pattern start
+//18:16 prehsc pattern end
+//15:8 hsc pattern, each patten 1 bit, from lsb -> msb
+//6:4  hsc pattern start
+//2:0  hsc pattern end
+#define VPP_HSC_INI_PAT_CTRL                       ((0x1d35  << 2) + 0xd0100000)
+//Bit 3			minus black level enable for vadj2
+//Bit 2			Video adjustment enable for vadj2
+//Bit 1			minus black level enable for vadj1
+//Bit 0			Video adjustment enable for vadj1
+#define VPP_VADJ_CTRL                              ((0x1d40  << 2) + 0xd0100000)
+//Bit 16:8  brightness, signed value
+//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
+#define VPP_VADJ1_Y                                ((0x1d41  << 2) + 0xd0100000)
+//cb' = cb*ma + cr*mb
+//cr' = cb*mc + cr*md
+//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
+#define VPP_VADJ1_MA_MB                            ((0x1d42  << 2) + 0xd0100000)
+#define VPP_VADJ1_MC_MD                            ((0x1d43  << 2) + 0xd0100000)
+//Bit 16:8  brightness, signed value
+//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
+#define VPP_VADJ2_Y                                ((0x1d44  << 2) + 0xd0100000)
+//cb' = cb*ma + cr*mb
+//cr' = cb*mc + cr*md
+//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
+#define VPP_VADJ2_MA_MB                            ((0x1d45  << 2) + 0xd0100000)
+#define VPP_VADJ2_MC_MD                            ((0x1d46  << 2) + 0xd0100000)
+//Bit 2 horizontal chroma sharp/blur selection, 0:sharp, 1: blur  
+//Bit 1 horizontal luma sharp/blur selection, 0:sharp, 1: blur  
+//Bit 0 horizontal sharpness enable
+#define VPP_HSHARP_CTRL                            ((0x1d50  << 2) + 0xd0100000)
+//{1'b0,threhsold} < diff
+//Bit 26:16  luma threshold0
+//Bit 10:0   luma threshold1    
+#define VPP_HSHARP_LUMA_THRESH01                   ((0x1d51  << 2) + 0xd0100000)
+//
+//Bit 26:16  luma threshold2
+//Bit 10:0   luma threshold3    
+#define VPP_HSHARP_LUMA_THRESH23                   ((0x1d52  << 2) + 0xd0100000)
+//Bit 26:16  chroma threshold0
+//Bit 10:0   chroma threshold1    
+#define VPP_HSHARP_CHROMA_THRESH01                 ((0x1d53  << 2) + 0xd0100000)
+//Bit 26:16  chroma threshold2
+//Bit 10:0   chroma threshold3    
+#define VPP_HSHARP_CHROMA_THRESH23                 ((0x1d54  << 2) + 0xd0100000)
+//Bit 23:16 luma gain2
+//Bit 15:8  luma gain1
+//Bit 7:0   luma gain0
+#define VPP_HSHARP_LUMA_GAIN                       ((0x1d55  << 2) + 0xd0100000)
+//
+//Bit 23:16 chroma gain2
+//Bit 15:8  chroma gain1
+//Bit 7:0   chroma gain0
+#define VPP_HSHARP_CHROMA_GAIN                     ((0x1d56  << 2) + 0xd0100000)
+//Read only 
+//Bit 31, if it is true, it means this probe is valid in the last field/frame
+//Bit 29:20 component 0
+//Bit 19:10 component 1
+//Bit 9:0 component 2
+#define VPP_MATRIX_PROBE_COLOR                     ((0x1d5c  << 2) + 0xd0100000)
+#define VPP_MATRIX_PROBE_COLOR1                    ((0x1dd7  << 2) + 0xd0100000)
+//Bit 23:16 component 0
+//Bit 15:8  component 1
+//Bit 7:0 component 2
+#define VPP_MATRIX_HL_COLOR                        ((0x1d5d  << 2) + 0xd0100000)
+//28:16 probe x, postion
+//12:0  probe y, position  
+#define VPP_MATRIX_PROBE_POS                       ((0x1d5e  << 2) + 0xd0100000)
+//Bit 16,  highlight_en
+//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
+//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix, 010: select vd2 matrix
+//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix, 10: select vd2 matrix
+//Bit 5    vd1 conversion matrix enable
+//Bit 4    vd2 conversion matrix enable
+//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
+//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
+//Bit 0    post conversion matrix enable
+#define VPP_MATRIX_CTRL                            ((0x1d5f  << 2) + 0xd0100000)
+//Bit 28:16 coef00
+//Bit 12:0  coef01
+#define VPP_MATRIX_COEF00_01                       ((0x1d60  << 2) + 0xd0100000)
+//Bit 28:16 coef02 
+//Bit 12:0  coef10 
+#define VPP_MATRIX_COEF02_10                       ((0x1d61  << 2) + 0xd0100000)
+//Bit 28:16 coef11
+//Bit 12:0  coef12
+#define VPP_MATRIX_COEF11_12                       ((0x1d62  << 2) + 0xd0100000)
+//Bit 28:16 coef20
+//Bit 12:0  coef21
+#define VPP_MATRIX_COEF20_21                       ((0x1d63  << 2) + 0xd0100000)
+#define VPP_MATRIX_COEF22                          ((0x1d64  << 2) + 0xd0100000)
+//Bit 26:16 offset0
+//Bit 10:0  offset1
+#define VPP_MATRIX_OFFSET0_1                       ((0x1d65  << 2) + 0xd0100000)
+//Bit 10:0  offset2
+#define VPP_MATRIX_OFFSET2                         ((0x1d66  << 2) + 0xd0100000)
+//Bit 26:16 pre_offset0
+//Bit 10:0  pre_offset1
+#define VPP_MATRIX_PRE_OFFSET0_1                   ((0x1d67  << 2) + 0xd0100000)
+//Bit 10:0  pre_offset2
+#define VPP_MATRIX_PRE_OFFSET2                     ((0x1d68  << 2) + 0xd0100000)
+// dummy data used in the VPP postblend
+// Bit 23:16    Y
+// Bit 15:8     CB
+// Bit 7:0      CR 
+#define VPP_DUMMY_DATA1                            ((0x1d69  << 2) + 0xd0100000)
+//Bit 31 gainoff module enable
+//Bit 26:16 gain0, 1.10 unsigned data
+//Bit 10:0  gain1, 1.10 unsigned dat
+#define VPP_GAINOFF_CTRL0                          ((0x1d6a  << 2) + 0xd0100000)
+//Bit 26:16 gain2, 1.10 unsigned data
+//Bit 10:0, offset0, signed data
+#define VPP_GAINOFF_CTRL1                          ((0x1d6b  << 2) + 0xd0100000)
+//Bit 26:16, offset1, signed data
+//Bit 10:0, offset2, signed data
+#define VPP_GAINOFF_CTRL2                          ((0x1d6c  << 2) + 0xd0100000)
+//Bit 26:16, pre_offset0, signed data 
+//Bit 10:0, pre_offset1, signed data 
+#define VPP_GAINOFF_CTRL3                          ((0x1d6d  << 2) + 0xd0100000)
+//Bit 10:0, pre_offset2, signed data 
+#define VPP_GAINOFF_CTRL4                          ((0x1d6e  << 2) + 0xd0100000)
+//only two registers used in the color management, which are defined in the chroma_reg.h
+//`define VPP_CHROMA_ADDR_PORT    8'h70
+//`define VPP_CHROMA_DATA_PORT    8'h71
+//
+// Reading file:  chroma_reg.h
+//
+//**********************************************************************************
+//* Copyright (c) 2008, AMLOGIC Inc.
+//* All rights reserved
+//**********************************************************************************
+//* File :  chroma_reg.v
+//* Author : Terrence Wang
+//* Date : Dec 2008
+//* Description :  
+//*
+//********************************************************************************** 
+//* Modification History:
+//* Date    Modified By         Reason
+//**********************************************************************************
+// synopsys translate_off
+// synopsys translate_on
+#define VPP_CHROMA_ADDR_PORT                       ((0x1d70  << 2) + 0xd0100000)
+#define VPP_CHROMA_DATA_PORT                       ((0x1d71  << 2) + 0xd0100000)
+//`define CHROMA_ADDR_PORT        8'h67
+//`define CHROMA_DATA_PORT        8'h68
+
+//  CHROMA_GAIN_REG_XX(00-07)
+//  hue gain, sat gain function control
+//  Bit 31      reg_sat_en                  enable sat adjustment in current region
+//  Bit 27      reg_sat_increase            sat adjustment increase or decrease
+//                                          1'b1: increase  1'b0: decrease
+//  Bit 26:25   reg_sat_central_en          sat adjustment with central biggest or one side biggest
+//                                          2'b01 central biggest   2'b00 one side biggest
+//  Bit 24      reg_sat_shape               when sat adjustment one side biggest, define left or right
+//                                          1'b1: left side biggest 1'b0 right side biggest  
+//  Bit 23:16   reg_sat_gain                define the sat gain when sat adjustment
+//                                          0x00-0xff
+//  Bit 15      reg_hue_en                  enable hue adjustment in current region
+//  Bit 11      reg_hue_clockwise           hue adjustment clockwise or anti-clockwise
+//                                          1'b1: clockwise 1'b0: anti-clockwise
+//  Bit 10:9    reg_hue_central_en          when hue adjustment, parabola curve or non-symmetry curve
+//                                          1'b1: parabola curve    1'b0: non-symmetry curve
+//  Bit 8       reg_hue_shape               when non-symmetry curve, define which side change more
+//                                          1'b1: right side change more    1'b0: left side change more
+//  Bit 7:0     reg_hue_gain                define the hue gain when hue adjustment
+//                                          0x00-0x80, note: should be no bigger than 0x80
+
+    #define CHROMA_GAIN_REG00       0x00
+
+
+//  HUE_HUE_RANGE_REG_XX(00-07)
+//  hue range select
+//  Bit 31:24   no use now
+//  Bit 23:16   reg_hue_shift_range         define the angle of target region
+//                                          0x00-0xff,(0x100 means 120 degree though it can not be set)
+//                                          must be greater or equal than 8'd8
+//  Bit 15      reg_symmetry_en             this is used for create one symmetry region
+//                                          the symmetry region hue_shift_start = reg_hue_hue_shift_start + reg_hue_shift_range<<5
+//                                          the symmetry region hue_shift_range = reg_hue_shift_range
+//                                          in symmetry region, all the sat and hue setting will be same with original region, 
+//                                          except reg_hue_shape, reg_sat_shape, reg_hue_clockwise will be reversed
+//  Bit 14:0    reg_hue_hue_shift_start     define the start angle of target region
+//                                          0x6000 means 360 degree
+//                                          only region 0 and 1 can exceed 360 degrees.
+
+    #define HUE_HUE_RANGE_REG00     0x01
+
+
+//  HUE_RANGE_INV_REG_XX
+//  Calculation should be follow
+//  HUE_RANGE_INV_REG0X[15:0] = ((1<<20)/HUE_HUE_RANGE_REG0X[23:16]+1)>>1
+//  HUE_RANGE_INV_REG_XX is to used to save divider
+
+    #define HUE_RANGE_INV_REG00     0x02
+
+
+
+//  for belowing each low, high, low_slope, high_slope group:
+//            a_____________b
+//            /             \               a = low  + 2^low_slope
+//           /               \              b = high - 2^high_slope
+//          /                 \             low_slope <= 7; high_slope <= 7
+//         /                   \            b >= a
+//  ______/_____________________\________
+//       low                    high
+//
+//
+//  HUE_LUM_RANGE_REG_XX(00-07)
+//  luma range selection for hue adjustment
+//  Bit 31:24   reg_sat_lum_low             define the low level of luma value for sat adjustment
+//                                          0x00-0xff
+//  Bit 23:20   reg_hue_lum_high_slope      define the slope area below high level of luma value for hue adjustment
+//                                          0x00-0x07
+//  Bit 19:16   reg_hue_lum_low_slope       define the slope area above low  level of luma value for hue adjustment
+//                                          0x00-0x07
+//  Bit 15:8    reg_hue_lum_high            define the high level of luma value for hue adjustment
+//                                          0x00-0xff
+//  Bit 7:0     reg_hue_lum_low             define the low  level of luma value for hue adjustment
+//                                          0x00-0xff
+
+    #define HUE_LUM_RANGE_REG00     0x03
+
+//  HUE_SAT_RANGE_REG_XX(00-07)
+//  sat range selection for hue adjustment
+//  Bit 31:24   reg_sat_lum_high            define the high level of luma value for sat adjustment
+//                                          0x00-0xff
+//  Bit 23:20   reg_hue_sat_high_slope      define the slope area below high level of sat value for hue adjustment
+//                                          0x00-0x07
+//  Bit 19:16   reg_hue_sat_low_slope       define the slope area above low  level of sat value for hue adjustment
+//                                          0x00-0x07
+//  Bit 15:8    reg_hue_sat_high            define the high level of sat value for hue adjustment
+//                                          0x00-0xff
+//  Bit 7:0     reg_hue_sat_low             define the low  level of sat value for hue adjustment
+//                                          0x00-0xff
+
+    #define HUE_SAT_RANGE_REG00     0x04
+
+//  SAT_SAT_RANGE_REG_XX(00-07)
+//  sat range selection for hue adjustment
+//  Bit 31:28   reg_sat_lum_high_slope      define the slope area below high level of luma value for sat adjustment
+//                                          0x00-0x07
+//  Bit 27:24   reg_sat_lum_low_slope       define the slope area above low  level of luma value for sat adjustment
+//                                          0x00-0x07
+//  Bit 23:20   reg_sat_sat_high_slope      define the slope area below high level of sat value for sat adjustment
+//                                          0x00-0x07
+//  Bit 19:16   reg_sat_sat_low_slope       define the slope area above low  level of sat value for sat adjustment
+//                                          0x00-0x07
+//  Bit 15:8    reg_sat_sat_high            define the high level of sat value for sat adjustment
+//                                          0x00-0xff
+//  Bit 7:0     reg_sat_sat_low             define the low  level of sat value for sat adjustment
+//                                          0x00-0xff
+
+    #define SAT_SAT_RANGE_REG00     0x05
+
+
+    #define CHROMA_GAIN_REG01       0x06
+    #define HUE_HUE_RANGE_REG01     0x07
+    #define HUE_RANGE_INV_REG01     0x08
+    #define HUE_LUM_RANGE_REG01     0x09
+    #define HUE_SAT_RANGE_REG01     0x0a
+    #define SAT_SAT_RANGE_REG01     0x0b
+
+    #define CHROMA_GAIN_REG02       0x0c
+    #define HUE_HUE_RANGE_REG02     0x0d
+    #define HUE_RANGE_INV_REG02     0x0e
+    #define HUE_LUM_RANGE_REG02     0x0f
+    #define HUE_SAT_RANGE_REG02     0x10
+    #define SAT_SAT_RANGE_REG02     0x11
+
+
+    #define CHROMA_GAIN_REG03       0x12
+    #define HUE_HUE_RANGE_REG03     0x13
+    #define HUE_RANGE_INV_REG03     0x14
+    #define HUE_LUM_RANGE_REG03     0x15
+    #define HUE_SAT_RANGE_REG03     0x16
+    #define SAT_SAT_RANGE_REG03     0x17
+
+    #define CHROMA_GAIN_REG04       0x18
+    #define HUE_HUE_RANGE_REG04     0x19
+    #define HUE_RANGE_INV_REG04     0x1a
+    #define HUE_LUM_RANGE_REG04     0x1b
+    #define HUE_SAT_RANGE_REG04     0x1c
+    #define SAT_SAT_RANGE_REG04     0x1d
+
+    #define CHROMA_GAIN_REG05       0x1e
+    #define HUE_HUE_RANGE_REG05     0x1f
+    #define HUE_RANGE_INV_REG05     0x20
+    #define HUE_LUM_RANGE_REG05     0x21
+    #define HUE_SAT_RANGE_REG05     0x22
+    #define SAT_SAT_RANGE_REG05     0x23
+
+    #define CHROMA_GAIN_REG06       0x24
+    #define HUE_HUE_RANGE_REG06     0x25
+    #define HUE_RANGE_INV_REG06     0x26
+    #define HUE_LUM_RANGE_REG06     0x27
+    #define HUE_SAT_RANGE_REG06     0x28
+    #define SAT_SAT_RANGE_REG06     0x29
+
+    #define CHROMA_GAIN_REG07       0x2a
+    #define HUE_HUE_RANGE_REG07     0x2b
+    #define HUE_RANGE_INV_REG07     0x2c
+    #define HUE_LUM_RANGE_REG07     0x2d
+    #define HUE_SAT_RANGE_REG07     0x2e
+    #define SAT_SAT_RANGE_REG07     0x2f
+
+//  REG_CHROMA_CONTROL
+//  Bit 31      reg_chroma_en               enable color manage function
+//                                          1'b1: enable    1'b0: bypass
+//  Bit 6       sat_sel                     uv_max or u^2+v^2 selected as sat for reference
+//                                          1'b1: uv_max(default)   1'b0: u^2+v^2
+//  Bit 5       uv_adj_en                   final uv_adjust enable
+//                                          1'b1: enable    1'b0: bypass
+//  Bit 2       hue_en                      rgb to hue enable
+//                                          1'b1: enable(default)   1'b0: bypass
+//  Bit 1:0     csc_sel                     define input YUV with different color type
+//                                          2'b00: 601(16-235)  2'b01: 709(16-235)
+//                                          2'b10: 601(0-255)   2'b11: 709(0-255)
+    #define REG_CHROMA_CONTROL      0x30   // default 32h'80000024
+    #define REG_DEMO_CENTER_BAR     0x31   // default 32h'0
+    #define REG_DEMO_HLIGHT_MODE    0x32   // default 32h'0
+    #define REG_DEMO_OWR_DATA       0x33   // default 32h'0
+
+
+////===========================================////
+//// CM2 ADDR
+////===========================================////
+
+    #define SAT_BYYB_NODE_REG0          0x200   // default 32'h0
+//Bit 31:24, sat_byyb_node3    the 4th node
+//Bit 23:16, sat_byyb_node2    the 3th node
+//Bit 15: 8, sat_byyb_node1    signed, the 2th node about saturation
+//Bit  7: 0, sat_byyb_node0    signed, the 1th node about saturation
+//gain offset along y coordinate,the gain normalized to 128 as "1"
+    
+	#define SAT_BYYB_NODE_REG1          0x201   // default 32'h0
+//Bit 31:24, sat_byyb_node7     the 8th node
+//Bit 23:16, sat_byyb_node6     the 7th node
+//Bit 15: 8, sat_byyb_node5     signed, the 6th node about saturation
+//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation
+//gain offset along y coordinate,the gain normalized to 128 as "1"
+
+    #define SAT_BYYB_NODE_REG2          0x202   // default 32'h0
+//Bit 31: 8, reserved
+//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation
+
+
+    #define SAT_SRC_NODE_REG            0x203   // default 32'h0
+//Bit 31:28, reserved 
+//Bit 27:16, sat_src_node1  
+//Bit 15:12, reserved 
+//Bit 11: 0, sat_src_node0     usigned, threshold of input saturation for  first and second piece
+
+    #define CM_ENH_SFT_MODE_REG         0x204   // default 32'h0
+//Bit 31: 9, reserved
+//Bit  8: 6, hue_lsft_mode        hue offset adjustments scale 
+//Bit  5: 4, luma_lsft_mode       luma offset adjustments scale for reg_cm2_adj_luma_via_hue
+//Bit  3: 2, sat_byy_rsft_mode    saturation gain adjustments scale for reg_cm2_adj_sat_via_y
+//Bit  1: 0, sat_byhs_rsft_mode   saturation gain adjustments scale for reg_cm2_adj_sat_via_hs[:][:] 0:no scale up/down 1:dnscale by 2(-128,127)/2
+
+    #define FRM_SIZE_REG                0x205   // default 32'h0
+//Bit 31:29, reserved 
+//Bit 28:16, reg_frm_height       the frame height size 
+//Bit 15:13, reserved 
+//Bit 12: 0, reg_frm_width        the frame width size 
+
+    #define FITLER_CFG_REG              0x206   // default 32'h0
+//Bit 31: 5, reserved 
+//Bit  4: 4, inteleav_mod         horizontal interleave filter(zero-padding) for 3D considerations 0:using non-zero padding lpf 1:using zero-padding lpf
+//Bit  3: 2, lpf_slt_uv           apply cm on lp portion or original video pixels options
+//Bit  1: 0, lpf_slt_y            apply cm on lp portion or original video pixels options
+
+    #define CM_GLOBAL_GAIN_REG          0x207   // default 32'h0
+//Bit 31:28, reserved 
+//Bit 27:16, cm2_global_sat     global saturation gain for general color adjustments(0~4095 <=> 0~8),512 normalized to "1"
+//Bit 15:12, reserved 
+//Bit 11: 0, cm2_global_hue     global hue offsets for general color adjustments(0~4095 <=> 0~360 degree) 
+
+    #define CM_ENH_CTL_REG              0x208   // default 32'h0
+//Bit  31:7, reserved
+//Bit     6, hue_adj_en        cm2 hue adjustments
+//Bit     5, sat_adj_en        cm2 saturation adjustments
+//Bit     4, luma_adj_en       enable siganl for cm2 luma adjustments 
+//Bit     3, reserved
+//Bit     2, cm2_filt_en       apply cm on lp portion enable
+//Bit     1, cm2_en            cm2 enable siganl
+//Bit     0, cm1_en
+
+    #define ROI_X_SCOPE_REG             0x209   // default 32'h0
+//Bit 31:29, reserved 
+//Bit 28:16, roi_x_end      ending col index of the region of interest
+//Bit 15:13, reserved 
+//Bit 12: 0, roi_x_beg      start col index of the region of interest
+  
+   #define ROI_Y_SCOPE_REG             0x20a   // default 32'h0
+//Bit 31:29, reserved 
+//Bit 28:16, roi_y_end      ending row index of the region of interest
+//Bit 15:13, reserved 
+//Bit 12: 0, roi_y_beg      start row index of the region of interest
+
+    #define POI_XY_DIR_REG              0x20b   // default 32'h0
+//Bit 31:29, reserved 
+//Bit 28:16, poi_y_dir      ending row index of the region of interest
+//Bit 15:13, reserved 
+//Bit 12: 0, poi_x_dir      start row index of the region of interest
+
+    #define COI_Y_SCOPE_REG             0x20c   // default 32'h0
+//Bit 31:16, reserved 
+//Bit 15: 8, coi_y_end       
+//Bit  7: 0, coi_y_beg       
+
+    #define COI_H_SCOPE_REG             0x20d   // default 32'h0
+//Bit 31:28, reserved 
+//Bit 27:16, coi_h_end 
+//Bit 15:12, reserved 
+//Bit 11: 0, coi_h_beg        lower bound of hue value for color of interest ,12 bits precision 
+
+    #define COI_S_SCOPE_REG             0x20e   // default 32'h0
+//Bit 31:28, reserved 
+//Bit 27:16, coi_s_end        
+//Bit 15:12, reserved 
+//Bit 11: 0, coi_s_beg        lower bound of sat value for color of interest ,12 bits precision 
+    #define IFO_MODE_REG                0x20f   // default 32'h0
+//Bit 31:8, reserved 
+//Bit  7:6, ifo_mode3 
+//Bit  5:4, ifo_mode2 
+//Bit  3:2, ifo_mode1 
+//Bit  1:0, ifo_mode0 
+    #define POI_RPL_MODE_REG            0x210   // default 32'h0
+//Bit 31:4, reserved 
+//Bit  3:0, poi_rpl_mode          enhance mode control of pixels inside and outside region of interest bit[3:2]control roi 
+    #define DEMO_OWR_YHS_REG            0x211   // default 32'h0
+//Bit 31: 0, demo_owr_yhs
+ 
+    #define DEMO_POI_Y_REG              0x212   // default 32'h0
+//Bit 31: 8, reserved 
+//Bit  7: 0, luma_data_poi_r       only get locked higher 8bits
+    #define DEMO_POI_H_REG              0x213   // default 32'h0
+//Bit 31: 12, reserved 
+//Bit 11: 0, hue_data_poi_r        only get locked higher 12bits
+    #define DEMO_POI_S_REG              0x214   // default 32'h0
+//Bit 31: 12, reserved 
+//Bit 11: 0, sat_data_poi_r         only get locked higher 12bits
+    //#define LUMA_BYH_LIMT_REG           0x215   // default 32'h0
+    #define LUMA_ADJ_LIMT_REG           0x215   // default 32'h0
+//Bit 31:24, reserved 
+//Bit 23:16, luma_lmt_satslp         slope to do the luma adjustment degrade
+//Bit 15:12, reserved 
+//Bit 11:0, luma_lmt_satth           threshold to saturation
+    #define SAT_ADJ_LIMT_REG            0x216   // default 32'h0
+//Bit 31:24, reserved 
+//Bit 23:16, sat_lmt_satslp        slope to do the adjustment degrade
+//Bit 15:12, reserved 
+//Bit 11:0, sat_lmt_satth          threshold to saturation
+    #define HUE_ADJ_LIMT_REG            0x217   // default 32'h0
+//Bit 31: 24, reserved 
+//Bit 23: 16, hue_lmt_satslp        slope to do the adjustment degrade
+//Bit 15: 12, reserved 
+//Bit 11: 0,  hue_lmt_satth          threshold to saturation
+    #define UVHS_OFST_REG               0x218   // default 32'h0
+//Bit 31: 24, hs2uv_v_ofst 
+//Bit 23: 16, hs2uv_u_ofst 
+//Bit 15: 8,  uv2hs_v_ofst 
+//Bit  7: 0,  uv2hs_u_ofst 
+    #define HUE_CFG_PARA_REG            0x219   // default 32'h0
+//Bit 31: 17, reserved 
+//Bit     16, hue_protect_en 
+//Bit 15: 13, cm2_hue_byhs_mode   
+//Bit     12, cm2_hue_div_mode    
+//Bit 11: 0, cm2_before_hue_ofst 
+    #define DEMO_SPLT_CFG_REG           0x21a   // default 32'h0
+//Bit 31: 22, reserved 
+//Bit 21: 20, demo_split_mode  
+//Bit 19: 16, demo_split_width        slope to do the adjustment degrade
+//Bit 15: 13, reserved 
+//Bit 12: 0,  demo_split_post           threshold to saturation
+    #define DEMO_SPLT_YHS_REG           0x21b   // default 32'h0    
+//Bit 31: 0,  demo_splt_yhs             threshold to saturation
+    
+    #define XVYCC_YSCP_REG              0x21c   // default 32'h0    
+//Bit 31: 28, reserved 
+//Bit 27: 16, xvycc_y_max 
+//Bit 15: 12, reserved 
+//Bit 11: 0, xvycc_y_min 
+    #define XVYCC_USCP_REG              0x21d   // default 32'h0    
+//Bit 31: 28, reserved 
+//Bit 27: 16, xvycc_u_max 
+//Bit 15: 12, reserved 
+//Bit 11: 0, xvycc_u_min 
+    #define XVYCC_VSCP_REG              0x21e   // default 32'h0    
+//Bit 31: 28, reserved 
+//Bit 27: 16, xvycc_v_max 
+//Bit 15: 12, reserved 
+//Bit 11: 0, xvycc_v_min 
+
+////========= NODE 0 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H00      0x100   // default 32'H0
+//Bit 31: 24, reg_cm2_adj_sat_via_hs_2  
+//Bit 23: 16, reg_cm2_adj_sat_via_hs_1  
+//Bit 15: 8,  reg_cm2_adj_sat_via_hs_0  
+//Bit  7: 0, reg_cm2_adj_luma_via_h  
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H00      0x101   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H00      0x102   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H00      0x103   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H00      0x104   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 1 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H01      0x108   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H01      0x109   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H01      0x10a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H01      0x10b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H01      0x10c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 2 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H02      0x110   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H02      0x111   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H02      0x112   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H02      0x113   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H02      0x114   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 3 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H03      0x118   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H03      0x119   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H03      0x11a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H03      0x11b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H03      0x11c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 4 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H04      0x120   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H04      0x121   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H04      0x122   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H04      0x123   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H04      0x124   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 5 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H05      0x128   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H05      0x129   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H05      0x12a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H05      0x12b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H05      0x12c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 6 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H06      0x130   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H06      0x131   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H06      0x132   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H06      0x133   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H06      0x134   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 7 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H07      0x138   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H07      0x139   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H07      0x13a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H07      0x13b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H07      0x13c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 8 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H08      0x140   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H08      0x141   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H08      0x142   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H08      0x143   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H08      0x144   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 9 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H09      0x148   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H09      0x149   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H09      0x14a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H09      0x14b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H09      0x14c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 10 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H10      0x150   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H10      0x151   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H10      0x152   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H10      0x153   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H10      0x154   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 11 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H11      0x158   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H11      0x159   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H11      0x15a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H11      0x15b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H11      0x15c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 12 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H12      0x160   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H12      0x161   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H12      0x162   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H12      0x163   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H12      0x164   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+////========= NODE 13 COEFFICIENT ==============////
+
+    #define REG_CM2_ENH_COEFF0_H13      0x168   // default 32'H0
+                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx 
+                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
+    #define REG_CM2_ENH_COEFF1_H13      0x169   // default 32'H0
+                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx 
+                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
+    #define REG_CM2_ENH_COEFF2_H13      0x16a   // default 32'H0
+                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx 
+                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
+    #define REG_CM2_ENH_COEFF3_H13      0x16b   // default 32'H0
+                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx 
+                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
+    #define REG_CM2_ENH_COEFF4_H13      0x16c   // default 32'H0
+                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx 
+                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx
+
+
+/* Constraints 
+0)
+  there are 16 regions totally. 8 regions are for hue adjustment, 8 regions are for sat adjustment.
+  the hue range of the 16 regions can be set to overlap, but if overlap, the hue range(start and end) must be same.
+  the 8 regions for hue adjustment should not overlap. if corresponding reg_hue_en_00 - 07 == 1
+  the 8 regions for hue adjustment are defined by: (example are for region 0)
+    a) hue:
+        start: reg_hue_hue_shift_start_00[14:0]
+        end:
+        if reg_symmetry_en_00 == 0
+        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
+        if reg_symmetry_en_00 == 1
+        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
+    b) sat:
+        start: reg_hue_sat_low_00 
+        end:   reg_hue_sat_high_00  
+
+  the 8 regions for sat adjustment should not overlap. if corresponding reg_sat_en_00 - 07 == 1
+  the 8 regions for sat adjustment are defined by: (example are for region 0)
+    a) hue: same as that for hue adjustment.
+        start: reg_hue_hue_shift_start_00[14:0]
+        end:
+        if reg_symmetry_en_00 == 0
+        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
+        if reg_symmetry_en_00 == 1
+        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
+    b) sat:
+        start: reg_sat_sat_low_00
+        end:   reg_sat_sat_high_00  
+
+1)
+  reg_hue_hue_shift_range_00[7:0]:
+  reg_hue_hue_shift_range_01[7:0]:
+  reg_hue_hue_shift_range_02[7:0]:
+  reg_hue_hue_shift_range_03[7:0]:
+  reg_hue_hue_shift_range_04[7:0]:
+  reg_hue_hue_shift_range_05[7:0]:
+  reg_hue_hue_shift_range_06[7:0]:
+  reg_hue_hue_shift_range_07[7:0]:
+  must be greater or equal than 8'd8, so as reg_hue_range_inv_regxx can be represented by 0.0000_0000_xxxx_xxxx_xxxx_xxxx
+
+2)
+  all regions of 0-7 should meet below requirement. below is just an example for region 7.
+  (reg_hue_lum_high_07 - reg_hue_lum_low_07) >= 
+        (1<<reg_hue_lum_low_slope_07) + (1<<reg_hue_lum_high_slope_07)
+
+  (reg_hue_sat_high_07 - reg_hue_sat_low_07) >=
+        (1<<reg_hue_sat_low_slope_07) + (1<<reg_hue_sat_high_slope_07)
+
+  (reg_sat_lum_high_07 - reg_sat_lum_low_07) >=
+        (1<<reg_sat_lum_low_slope_07) + (1<<reg_sat_lum_high_slope_07)
+
+  (reg_sat_sat_high_07 - reg_sat_sat_low_07) >=
+        (1<<reg_sat_sat_low_slope_07) + (1<<reg_sat_sat_high_slope_07)
+
+3)
+  all of reg_hue_hue_shift_start_00[14:0] ~ 07[14:0] < 0x6000.
+  only region 0 and 1 can exceed 360 degrees. ie:
+    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) can greater than 0x6000.
+    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_01<<5) can greater than 0x6000.
+  but below should be met:
+    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
+    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
+    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1
+    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1
+
+  others could not exceed 360 degrees. ie:
+    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<5) < 0x6000. if reg_symmetry_en_02 (to 7) == 0.
+    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<6) < 0x6000. if reg_symmetry_en_02 (to 7) == 1.
+
+4)
+  reg_hue_gain_00[7:0] <= 0x80.
+  reg_hue_gain_01[7:0] <= 0x80.
+  reg_hue_gain_02[7:0] <= 0x80.
+  reg_hue_gain_03[7:0] <= 0x80.
+  reg_hue_gain_04[7:0] <= 0x80.
+  reg_hue_gain_05[7:0] <= 0x80.
+  reg_hue_gain_06[7:0] <= 0x80.
+  reg_hue_gain_07[7:0] <= 0x80.
+
+5)
+  below registers can only have two setting: 00 and 01.
+    reg_hue_central_en_00[1:0]  .. _07[1:0]
+    reg_sat_central_en_00[1:0]  .. _07[1:0]
+
+6)
+  all reg_..._slope_00-07 should not be greater than 7, ie: maximum value is 7.
+   for example: below is for region 0:
+   reg_hue_lum_low_slope_00[3:0]  <= 7
+   reg_hue_lum_high_slope_00[3:0] <= 7
+   reg_hue_sat_low_slope_00[3:0]  <= 7
+   reg_hue_sat_high_slope_00[3:0] <= 7
+   reg_sat_lum_low_slope_00[3:0]  <= 7
+   reg_sat_lum_high_slope_00[3:0] <= 7
+   reg_sat_sat_low_slope_00[3:0]  <= 7
+   reg_sat_sat_high_slope_00[3:0] <= 7
+*/
+
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  chroma_reg.h
+//
+//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
+//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock 
+//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again 
+//because the register itself canot be set again without clk
+//Bit 31:0
+#define VPP_GCLK_CTRL0                             ((0x1d72  << 2) + 0xd0100000)
+//(front_lti), (front_cti), Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
+//Bit 13:0
+#define VPP_GCLK_CTRL1                             ((0x1d73  << 2) + 0xd0100000)
+//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
+//Bit 11:0
+#define VPP_SC_GCLK_CTRL                           ((0x1d74  << 2) + 0xd0100000)
+//Bit 17:9 VD1 alpha for preblend
+//Bit 8:0 VD1 alpha for postblend
+#define VPP_MISC1                                  ((0x1d76  << 2) + 0xd0100000)
+//Bit 31:0 super scalar clock control 
+#define VPP_SRSCL_GCLK_CTRL                        ((0x1d77  << 2) + 0xd0100000)
+//Bit 31:0 OSD super scalar clock control 
+#define VPP_OSDSR_GCLK_CTRL                        ((0x1d78  << 2) + 0xd0100000)
+//Bit 31:0 vvycc clock control 
+#define VPP_XVYCC_GCLK_CTRL                        ((0x1d79  << 2) + 0xd0100000)
+//Bit 31:24     blackext_start
+//Bit 23:16     blackext_slope1
+//Bit 15:8      blackext_midpt
+//Bit 7:0       blackext_slope2
+#define VPP_BLACKEXT_CTRL                          ((0x1d80  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region03 output value
+//Bit 23:16     bottom of region02 output value
+//Bit 15:8      bottom of region01 output value
+//Bit 7:0       bottom of region00 output value
+#define VPP_DNLP_CTRL_00                           ((0x1d81  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region07 output value
+//Bit 23:16     bottom of region06 output value
+//Bit 15:8      bottom of region05 output value
+//Bit 7:0       bottom of region04 output value
+#define VPP_DNLP_CTRL_01                           ((0x1d82  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region11 output value
+//Bit 23:16     bottom of region10 output value
+//Bit 15:8      bottom of region09 output value
+//Bit 7:0       bottom of region08 output value
+#define VPP_DNLP_CTRL_02                           ((0x1d83  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region15 output value
+//Bit 23:16     bottom of region14 output value
+//Bit 15:8      bottom of region13 output value
+//Bit 7:0       bottom of region12 output value
+#define VPP_DNLP_CTRL_03                           ((0x1d84  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region19 output value
+//Bit 23:16     bottom of region18 output value
+//Bit 15:8      bottom of region17 output value
+//Bit 7:0       bottom of region16 output value
+#define VPP_DNLP_CTRL_04                           ((0x1d85  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region23 output value
+//Bit 23:16     bottom of region22 output value
+//Bit 15:8      bottom of region21 output value
+//Bit 7:0       bottom of region20 output value
+#define VPP_DNLP_CTRL_05                           ((0x1d86  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region27 output value
+//Bit 23:16     bottom of region26 output value
+//Bit 15:8      bottom of region25 output value
+//Bit 7:0       bottom of region24 output value
+#define VPP_DNLP_CTRL_06                           ((0x1d87  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region31 output value
+//Bit 23:16     bottom of region30 output value
+//Bit 15:8      bottom of region29 output value
+//Bit 7:0       bottom of region28 output value
+#define VPP_DNLP_CTRL_07                           ((0x1d88  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region35 output value
+//Bit 23:16     bottom of region34 output value
+//Bit 15:8      bottom of region33 output value
+//Bit 7:0       bottom of region32 output value
+#define VPP_DNLP_CTRL_08                           ((0x1d89  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region39 output value
+//Bit 23:16     bottom of region38 output value
+//Bit 15:8      bottom of region37 output value
+//Bit 7:0       bottom of region36 output value
+#define VPP_DNLP_CTRL_09                           ((0x1d8a  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region43 output value
+//Bit 23:16     bottom of region42 output value
+//Bit 15:8      bottom of region41 output value
+//Bit 7:0       bottom of region40 output value
+#define VPP_DNLP_CTRL_10                           ((0x1d8b  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region47 output value
+//Bit 23:16     bottom of region46 output value
+//Bit 15:8      bottom of region45 output value
+//Bit 7:0       bottom of region44 output value
+#define VPP_DNLP_CTRL_11                           ((0x1d8c  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region51 output value
+//Bit 23:16     bottom of region50 output value
+//Bit 15:8      bottom of region49 output value
+//Bit 7:0       bottom of region48 output value
+#define VPP_DNLP_CTRL_12                           ((0x1d8d  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region55 output value
+//Bit 23:16     bottom of region54 output value
+//Bit 15:8      bottom of region53 output value
+//Bit 7:0       bottom of region52 output value
+#define VPP_DNLP_CTRL_13                           ((0x1d8e  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region59 output value
+//Bit 23:16     bottom of region58 output value
+//Bit 15:8      bottom of region57 output value
+//Bit 7:0       bottom of region56 output value
+#define VPP_DNLP_CTRL_14                           ((0x1d8f  << 2) + 0xd0100000)
+//Bit 31:24     bottom of region63 output value
+//Bit 23:16     bottom of region62 output value
+//Bit 15:8      bottom of region61 output value
+//Bit 7:0       bottom of region60 output value
+#define VPP_DNLP_CTRL_15                           ((0x1d90  << 2) + 0xd0100000)
+//Bit 28        vlti_step
+//Bit 27        vlti_step2
+//Bit 26:25     hlti_step
+//Bit 24:20     peaking_gain_h1
+//Bit 19:15     peaking_gain_h2
+//Bit 14:10     peaking_gain_h3
+//Bit 9:5       peaking_gain_h4
+//Bit 4:0       peaking_gain_h5
+#define VPP_PEAKING_HGAIN                          ((0x1d91  << 2) + 0xd0100000)
+//Bit 31        hsvsharp_buf_en
+//Bit 30        hsvsharp_buf_c5line_mode
+//Bit 29:25     peaking_gain_v1
+//Bit 24:20     peaking_gain_v2
+//Bit 19:15     peaking_gain_v3
+//Bit 14:10     peaking_gain_v4
+//Bit 9:5       peaking_gain_v5
+//Bit 4:0       peaking_gain_v6
+#define VPP_PEAKING_VGAIN                          ((0x1d92  << 2) + 0xd0100000)
+//Bit 31:26     hpeaking_slope1
+//Bit 25:20     hpeaking_slope2
+//Bit 19:12     hpeaking_slope_th1
+//Bit 11:6      vpeaking_slope1
+//Bit 5:0       vpeaking_slope2
+#define VPP_PEAKING_NLP_1                          ((0x1d93  << 2) + 0xd0100000)
+//Bit 31:24     hpeaking_slope_th2
+//Bit 23:16     hpeaking_nlp_coring_th
+//Bit 15:8      hpeaking_nlp_pgain
+//Bit 7:0       hpeaking_nlp_ngain
+#define VPP_PEAKING_NLP_2                          ((0x1d94  << 2) + 0xd0100000)
+//Bit 31:24     vpeaking_slope_th1
+//Bit 23:18     speaking_slope1
+//Bit 17:12     speaking_slope2
+//Bit 11:4      speaking_slope_th1
+//Bit 3:0       peaking_coring_gain
+#define VPP_PEAKING_NLP_3                          ((0x1d95  << 2) + 0xd0100000)
+//Bit 31:24     vpeaking_slope_th2
+//Bit 23:16     vpeaking_nlp_coring_th
+//Bit 15:8      vpeaking_nlp_pgain
+//Bit 7:0       vpeaking_nlp_ngain
+#define VPP_PEAKING_NLP_4                          ((0x1d96  << 2) + 0xd0100000)
+//Bit 31:24     speaking_slope_th2
+//Bit 23:16     speaking_nlp_coring_th
+//Bit 15:8      speaking_nlp_pgain
+//Bit 7:0       speaking_nlp_ngain
+#define VPP_PEAKING_NLP_5                          ((0x1d97  << 2) + 0xd0100000)
+//Bit 31:24     peaking_coring_th_l
+//Bit 23:16     peaking_coring_th_h
+//Bit 15:12     vlimit_high_coef
+//Bit 11:8      vlimit_low_coef
+//Bit 7:4       hlimit_high_coef
+//Bit 3:0       hlimit_low_coef
+#define VPP_SHARP_LIMIT                            ((0x1d98  << 2) + 0xd0100000)
+//Bit 31:24     vlti_neg_gain
+//Bit 23:16     vlti_pos_gain
+//Bit 15:8      vlti_threshold
+//Bit 7:0       vlti_blend_factor
+#define VPP_VLTI_CTRL                              ((0x1d99  << 2) + 0xd0100000)
+//Bit 31:24     hlti_neg_gain
+//Bit 23:16     hlti_pos_gain
+//Bit 15:8      hlti_threshold
+//Bit 7:0       hlti_blend_factor
+#define VPP_HLTI_CTRL                              ((0x1d9a  << 2) + 0xd0100000)
+//Bit 30        cti_c444to422_en
+//Bit 29:28     cti_vfilter_type
+//Bit 27        cti_c422to444_en
+//Bit 26:24     cti_step2
+//Bit 23:21     cti_step
+//Bit 20:16     cti_blend_factor
+//Bit 15        cti_median_mode
+//Bit 14:8      cti_threshold
+//Bit 7:0       cti_gain
+#define VPP_CTI_CTRL                               ((0x1d9b  << 2) + 0xd0100000)
+//Bit 29        blue_stretch_cb_inc
+//Bit 28        blue_stretch_cr_inc
+//Bit 27        the MSB of blue_stretch_error_crp_inv[11:0]
+//Bit 26        the MSB of blue_stretch_error_crn_inv[11:0]
+//Bit 25        the MSB of blue_stretch_error_cbp_inv[11:0]
+//Bit 24        the MSB of blue_stretch_error_cbn_inv[11:0]
+//Bit 23:16     blue_stretch_gain
+//Bit 15:8      blue_stretch_gain_cb4cr
+//Bit 7:0       blue_stretch_luma_high
+#define VPP_BLUE_STRETCH_1                         ((0x1d9c  << 2) + 0xd0100000)
+//Bit 31:27     blue_stretch_error_crp
+//Bit 26:16     the 11 LSB of blue_stretch_error_crp_inv[11:0]
+//Bit 15:11     blue_stretch_error_crn
+//Bit 10:0      the 11 LSB of blue_stretch_error_crn_inv[11:0]
+#define VPP_BLUE_STRETCH_2                         ((0x1d9d  << 2) + 0xd0100000)
+//Bit 31:27     blue_stretch_error_cbp
+//Bit 26:16     the 11 LSB of blue_stretch_error_cbp_inv[11:0]
+//Bit 15:11     blue_stretch_error_cbn
+//Bit 10:0      the 11 LSB of blue_stretch_error_cbn_inv[11:0]
+#define VPP_BLUE_STRETCH_3                         ((0x1d9e  << 2) + 0xd0100000)
+//Bit 25:16 bypass_ccoring_ythd
+//Bit 15:8, Chroma coring threshold
+//Bit 3:0, Chroma coring slope
+#define VPP_CCORING_CTRL                           ((0x1da0  << 2) + 0xd0100000)
+//Bit 20 demo chroma coring enable
+//Bit 19 demo black enxtension enable
+//Bit 18 demo dynamic nonlinear luma processing enable
+//Bit 17 demo hsvsharp enable
+//Bit 16 demo bluestretch enable
+//Bit 15:14, 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
+//Bit 4 chroma coring enable
+//Bit 3 black enxtension enable
+//Bit 2 dynamic nonlinear luma processing enable
+//Bit 1 hsvsharp enable
+//Bit 0 bluestretch enable
+#define VPP_VE_ENABLE_CTRL                         ((0x1da1  << 2) + 0xd0100000)
+//Bit 12:0, demo left or top screen width
+#define VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH          ((0x1da2  << 2) + 0xd0100000)
+#define VPP_VE_DEMO_CENTER_BAR                     ((0x1da3  << 2) + 0xd0100000)
+//28:16  ve_line_length
+//12:0   ve_pic_height
+#define VPP_VE_H_V_SIZE                            ((0x1da4  << 2) + 0xd0100000)
+//28:16  psr_line_length
+//12:0   psr_pic_height
+#define VPP_PSR_H_V_SIZE                           ((0x1da5  << 2) + 0xd0100000)
+//28:16  vppin_line_length
+//12:0   vppin_pic_height
+#define VPP_IN_H_V_SIZE                            ((0x1da6  << 2) + 0xd0100000)
+//Bit 10   reset bit, high active
+//Bit 9    0: measuring rising edge, 1: measuring falling edge
+//Bit 8    if true, accumulate the counter number, otherwise not
+//Bit 7:0  vsync_span, define how many vsync span need to measure 
+#define VPP_VDO_MEAS_CTRL                          ((0x1da8  << 2) + 0xd0100000)
+//Read only
+//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
+//15:0, high bit portion of counter
+#define VPP_VDO_MEAS_VS_COUNT_HI                   ((0x1da9  << 2) + 0xd0100000)
+//Read only
+//31:0, low bit portion of counter
+#define VPP_VDO_MEAS_VS_COUNT_LO                   ((0x1daa  << 2) + 0xd0100000)
+//bit 11:9 vd2_sel,  001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection             
+//bit 8:6 vd1_l_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
+//bit 5:3 vd1_r_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
+//note: the source vd1_l_sel selected cannot be used as the source of vd1_r_sel or vd2_sel
+// vd1_r_sel is useful only vd1_interleave_mode is not 00. And the source vd1_r_sel used can not used for the vd2_sel any more.  
+//bit 2:0 vd1_interleave_mode, 000: no interleave, 001: pixel interleaving, 010: line interleaving, 011: 2 pixel interleaving, 
+// 100: 2 line interleaving
+#define VPP_INPUT_CTRL                             ((0x1dab  << 2) + 0xd0100000)
+//bit 25:24 cti_bpf_sel
+//bit 20:16 cti_blend_factor_gama
+//bit 12:8 cti_blend_factor_beta
+//bit 4:0 cti_blend_factor_alpha
+#define VPP_CTI_CTRL2                              ((0x1dac  << 2) + 0xd0100000)
+#define VPP_PEAKING_SAT_THD1                       ((0x1dad  << 2) + 0xd0100000)
+#define VPP_PEAKING_SAT_THD2                       ((0x1dae  << 2) + 0xd0100000)
+#define VPP_PEAKING_SAT_THD3                       ((0x1daf  << 2) + 0xd0100000)
+#define VPP_PEAKING_SAT_THD4                       ((0x1db0  << 2) + 0xd0100000)
+#define VPP_PEAKING_SAT_THD5                       ((0x1db1  << 2) + 0xd0100000)
+#define VPP_PEAKING_SAT_THD6                       ((0x1db2  << 2) + 0xd0100000)
+#define VPP_PEAKING_SAT_THD7                       ((0x1db3  << 2) + 0xd0100000)
+#define VPP_PEAKING_SAT_THD8                       ((0x1db4  << 2) + 0xd0100000)
+#define VPP_PEAKING_SAT_THD9                       ((0x1db5  << 2) + 0xd0100000)
+#define VPP_PEAKING_GAIN_ADD1                      ((0x1db6  << 2) + 0xd0100000)
+#define VPP_PEAKING_GAIN_ADD2                      ((0x1db7  << 2) + 0xd0100000)
+//bit 23:16 peaking_dnlp_gain, u5.3, DNLP effect
+//bit 15:8  peaking_factor
+//bit 5     peaking_dnlp_demo_en
+//bit 4     peaking_dnlp_en
+//bit 3:0   peaking_filter_sel
+#define VPP_PEAKING_DNLP                           ((0x1db8  << 2) + 0xd0100000)
+//bit 24    sharp_demo_win_en
+//bit 23:12 sharp_demo_win_vend
+//bit 11:0  sharp_demo_win_vstart
+#define VPP_SHARP_DEMO_WIN_CTRL1                   ((0x1db9  << 2) + 0xd0100000)
+//bit 23:12 sharp_demo_win_hend
+//bit 11:0  sharp_demo_win_hstart
+#define VPP_SHARP_DEMO_WIN_CTRL2                   ((0x1dba  << 2) + 0xd0100000)
+//Bit 31:24     front_hlti_neg_gain
+//Bit 23:16     front_hlti_pos_gain
+//Bit 15:8      front_hlti_threshold
+//Bit 7:0       front_hlti_blend_factor
+#define VPP_FRONT_HLTI_CTRL                        ((0x1dbb  << 2) + 0xd0100000)
+//Bit 31        front_enable, enable the front LTI&CTI before scaler
+//Bit 26:24     front_cti_step2
+//Bit 23:21     front_cti_step
+//Bit 20:16     front_cti_blend_factor
+//Bit 15        front_cti_median_mode
+//Bit 14:8      front_cti_threshold
+//Bit 7:0       front_cti_gain
+#define VPP_FRONT_CTI_CTRL                         ((0x1dbc  << 2) + 0xd0100000)
+//bit 29:28 front_hlti_step
+//bit 25:24 front_cti_bpf_sel
+//bit 20:16 front_cti_blend_factor_gama
+//bit 12:8  front_cti_blend_factor_beta
+//bit 4:0   front_cti_blend_factor_alpha
+#define VPP_FRONT_CTI_CTRL2                        ((0x1dbd  << 2) + 0xd0100000)
+//vertical scaler phase step
+//Bit 27:0,  4.24 format
+#define VPP_OSD_VSC_PHASE_STEP                     ((0x1dc0  << 2) + 0xd0100000)
+//Bit 31:16, botttom vertical scaler initial phase
+//Bit 15:0, top vertical scaler initial phase
+#define VPP_OSD_VSC_INI_PHASE                      ((0x1dc1  << 2) + 0xd0100000)
+//Bit 24    osd vertical Scaler enable
+//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
+//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
+//Bit 20    osd_vsc_phase0_always_en
+//Bit 19    osd_vsc_nearest_en
+//Bit 17:16 osd_vsc_bot_rpt_l0_num
+//Bit 14:11 osd_vsc_bot_ini_rcv_num
+//Bit 9:8   osd_vsc_top_rpt_l0_num
+//Bit 6:3   osd_vsc_top_ini_rcv_num
+//Bit 2:0   osd_vsc_bank_length 
+#define VPP_OSD_VSC_CTRL0                          ((0x1dc2  << 2) + 0xd0100000)
+//horizontal scaler phase step
+//Bit 27:0,  4.24 format
+#define VPP_OSD_HSC_PHASE_STEP                     ((0x1dc3  << 2) + 0xd0100000)
+//Bit 31:16, horizontal scaler initial phase1
+//Bit 15:0, horizontal scaler initial phase0
+#define VPP_OSD_HSC_INI_PHASE                      ((0x1dc4  << 2) + 0xd0100000)
+//Bit 22   osd horizontal scaler enable
+//Bit 21   osd_hsc_double_pix_mode
+//Bit 20   osd_hsc_phase0_always_en
+//Bit 19   osd_hsc_nearest_en
+//Bit 17:16 osd_hsc_rpt_p0_num1
+//Bit 14:11 osd_hsc_ini_rcv_num1
+//Bit 9:8   osd_hsc_rpt_p0_num0
+//Bit 6:3   osd_hsc_ini_rcv_num0
+//Bit 2:0   osd_hsc_bank_length
+#define VPP_OSD_HSC_CTRL0                          ((0x1dc5  << 2) + 0xd0100000)
+//for 3D quincunx sub-sampling
+//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
+//bit 6:4  pattern start
+//bit 2:0  pattern end
+#define VPP_OSD_HSC_INI_PAT_CTRL                   ((0x1dc6  << 2) + 0xd0100000)
+//bit 31:24, componet 0
+//bit 23:16, component 1
+//bit 15:8, component 2
+//bit 7:0 component 3, alpha
+#define VPP_OSD_SC_DUMMY_DATA                      ((0x1dc7  << 2) + 0xd0100000)
+//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
+//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
+//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
+//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
+//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
+//Bit 3 osd scaler path enable 
+//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
+#define VPP_OSD_SC_CTRL0                           ((0x1dc8  << 2) + 0xd0100000)
+//Bit 28:16 OSD scaler input width minus 1
+//Bit 12:0 OSD scaler input height minus 1
+#define VPP_OSD_SCI_WH_M1                          ((0x1dc9  << 2) + 0xd0100000)
+//Bit 28:16 OSD scaler output horizontal start
+//Bit 12:0 OSD scaler output horizontal end
+#define VPP_OSD_SCO_H_START_END                    ((0x1dca  << 2) + 0xd0100000)
+//Bit 28:16 OSD scaler output vertical start
+//Bit 12:0 OSD scaler output vertical end
+#define VPP_OSD_SCO_V_START_END                    ((0x1dcb  << 2) + 0xd0100000)
+//Because there are many coefficients used in the vertical filter and horizontal filters,
+//indirect access the coefficients of vertical filter and horizontal filter is used.
+//For vertical filter, there are 33x4 coefficients 
+//For horizontal filter, there are 33x4 coefficients
+//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
+//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
+//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
+//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
+//Bit 6:0 	coef index
+#define VPP_OSD_SCALE_COEF_IDX                     ((0x1dcc  << 2) + 0xd0100000)
+//coefficients for vertical filter and horizontal filter
+#define VPP_OSD_SCALE_COEF                         ((0x1dcd  << 2) + 0xd0100000)
+//Bit 12:0 line number use to generate interrupt when line == this number
+#define VPP_INT_LINE_NUM                           ((0x1dce  << 2) + 0xd0100000)
+#define VPP_XVYCC_MISC                             ((0x1dcf  << 2) + 0xd0100000)
+// new add lti/cti in 120924
+//Bit  3: 0        //default== 0  reg_hlti_dn_flt_coe[0]
+//Bit  7: 4        //default== 0  reg_hlti_dn_flt_coe[1]
+//Bit 11: 8        //default== 0  reg_hlti_dn_flt_coe[2]
+//Bit 15:12        //default== 2  reg_hlti_dn_flt_coe[3]
+//Bit 19:16        //default== 4  reg_hlti_dn_flt_coe[4]
+//Bit 22:20        //default== 3  reg_hlti_dn_flt_nrm  u3: 3~7
+#define VPP_HLTI_DN_FLT                            ((0x1dd0  << 2) + 0xd0100000)
+//Bit  7: 0        //default== 8  reg_hlti_bst_gain  u8, norm 16 as "1"
+//Bit 15: 8        //default== 20 reg_hlti_bst_core  u8, norm 32 as "1"
+//Bit 23:16        //default== 32 reg_hlti_oob_gain  u8, norm 32 as "1"
+//Bit 28:24        //default== 0  reg_hlti_oob_core  u5                                  
+#define VPP_HLTI_GAIN                              ((0x1dd1  << 2) + 0xd0100000)
+//Bit  7: 0        //default== 2  reg_hlti_clp_ofst  u8, 
+//Bit     8        //default== 0  reg_hlti_clp_mode  u1, 
+//Bit 11: 9        //default== 1  reg_hlti_clp_wind  u3, 
+//Bit 14:12        //default== 1  reg_hlti_bst_fltr  u3, 
+//Bit    15        //default== 1  reg_hlti_enable    u1, 
+#define VPP_HLTI_PARA                              ((0x1dd2  << 2) + 0xd0100000)
+//Bit  3: 0        //default== 0  reg_hcti_dn_flt_coe[0]
+//Bit  7: 4        //default== 0  reg_hcti_dn_flt_coe[1]
+//Bit 11: 8        //default== 1  reg_hcti_dn_flt_coe[2]
+//Bit 15:12        //default== 2  reg_hcti_dn_flt_coe[3]
+//Bit 19:16        //default== 2  reg_hcti_dn_flt_coe[4]
+//Bit 22:20        //default== 3  reg_hcti_dn_flt_nrm   u3: 3~7
+#define VPP_HCTI_DN_FLT                            ((0x1dd3  << 2) + 0xd0100000)
+//Bit 7: 0        //default== 48 reg_hcti_bst_gain  u8, norm 16 as "1"
+//Bit15: 8        //default== 17 reg_hcti_bst_core  u8, norm 32 as "1"
+//Bit23:16        //default== 16 reg_hcti_oob_gain  u8, norm 32 as "1"
+//Bit28:24        //default==  0 reg_hcti_oob_core  u5
+#define VPP_HCTI_GAIN                              ((0x1dd4  << 2) + 0xd0100000)
+//Bit  7: 0        //default==  0 reg_hcti_clp_ofst  u8, 
+//Bit     8        //default==  1 reg_hcti_clp_mode  u1, 
+//Bit 11: 9        //default==  3 reg_hcti_clp_wind  u3, 
+//Bit 14:12        //default==  6 reg_hcti_bst_fltr  u3, 
+//Bit    15        //default==  1 reg_hcti_enable    u1, 
+#define VPP_HCTI_PARA                              ((0x1dd5  << 2) + 0xd0100000)
+//Bit  7: 0        //default== 48 reg_vcti_bst_gain  u8, normalize 16 as "1"
+//Bit 15: 8        //default== 10 reg_vcti_bst_core  u8
+//Bit 19:16        //default== 10 reg_vcti_clp_ofst  u4
+//Bit    20        //default==  1 reg_vcti_clp_wind  u1, 0: wind 3, 1: wind5
+#define VPP_VCTI_PARA                              ((0x1dd6  << 2) + 0xd0100000)
+//`define VPP_MATRIX_PROBE_COLOR1 8'hd7  //defined before
+//Bit 15          //default== 0, urgent_ctrl_en
+//Bit 14          //default== 0, urgent_wr, if true for write buffer
+//Bit 13          //default== 0, out_inv_en
+//Bit 12          //default == 0, urgent_ini_value
+//Bit 11:6        //default == 0, up_th  up threshold
+//Bit 5:0         //default == 0, dn_th  dn threshold
+#define VPP_OFIFO_URG_CTRL                         ((0x1dd8  << 2) + 0xd0100000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vpp_regs.h
+//
+//`define VIU2_VCBUS_BASE                8'h1e     
+//
+// Reading file:  v2regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//===========================================================================
+// Video Interface 2 Registers    0xe00 - 0xeff
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VIU2_VCBUS_BASE = 0x1e
+// -----------------------------------------------
+#define VIU2_ADDR_START                            ((0x1e00  << 2) + 0xd0100000)
+#define VIU2_ADDR_END                              ((0x1eff  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// VIU2 top-level registers
+//------------------------------------------------------------------------------
+// Bit  0 RW, osd1_reset
+// Bit  1 RW, osd2_reset
+// Bit  2 RW, vd1_reset
+// Bit  3 RW, vd1_fmt_reset
+// Bit  7 RW, vpp_reset
+#define VIU2_SW_RESET                              ((0x1e01  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// OSD1 registers
+//------------------------------------------------------------------------------
+// Bit    31 Reserved
+// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
+//                                0=use gated clock for low power.
+// Bit    29 R, test_rd_dsr
+// Bit    28 R, osd_done
+// Bit 27:24 R, osd_blk_mode
+// Bit 23:22 R, osd_blk_ptr
+// Bit    21 R, osd_enable
+//
+// Bit 20:12 RW, global_alpha
+// Bit    11 RW, test_rd_en
+// Bit 10: 9 Reserved for control signals
+// Bit  8: 5 RW, ctrl_mtch_y
+// Bit     4 RW, ctrl_422to444
+// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
+//                               Bit 1 to enable block 1, and so on.
+#define VIU2_OSD1_CTRL_STAT                        ((0x1e10  << 2) + 0xd0100000)
+// Bit 31:26 Reserved
+// Bit 25:16 R, fifo_count
+// Bit 15: 6 Reserved
+// Bit  5: 4 RW, hold_fifo_lines[6:5]
+// Bit     3 RW, rgb2yuv_full_range
+// Bit     2 RW, alpha_9b_mode
+// Bit     1 RW, reserved
+// Bit     0 RW, color_expand_mode
+#define VIU2_OSD1_CTRL_STAT2                       ((0x1e2d  << 2) + 0xd0100000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define VIU2_OSD1_COLOR_ADDR                       ((0x1e11  << 2) + 0xd0100000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define VIU2_OSD1_COLOR                            ((0x1e12  << 2) + 0xd0100000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define VIU2_OSD1_TCOLOR_AG0                       ((0x1e17  << 2) + 0xd0100000)
+#define VIU2_OSD1_TCOLOR_AG1                       ((0x1e18  << 2) + 0xd0100000)
+#define VIU2_OSD1_TCOLOR_AG2                       ((0x1e19  << 2) + 0xd0100000)
+#define VIU2_OSD1_TCOLOR_AG3                       ((0x1e1a  << 2) + 0xd0100000)
+// Bit 31:30 Reserved
+// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
+// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
+// Bit 27:24 Reserved
+// Bit 23:16 RW, tbl_addr
+// Bit    15 RW, little_endian: 0=big endian, 1=little endian
+// Bit    14 RW, rpt_y
+// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
+//                            pixel; 11=Interpolate with the average value
+//                            between previous and next pixel.
+// Bit 11: 8 RW, osd_blk_mode
+// Bit     7 RW, rgb_en
+// Bit     6 RW, tc_alpha_en
+// Bit  5: 2 RW, color_matrix
+// Bit     1 RW, interlace_en
+// Bit     0 RW, interlace_sel_odd
+#define VIU2_OSD1_BLK0_CFG_W0                      ((0x1e1b  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK1_CFG_W0                      ((0x1e1f  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK2_CFG_W0                      ((0x1e23  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK3_CFG_W0                      ((0x1e27  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, x_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, x_start
+#define VIU2_OSD1_BLK0_CFG_W1                      ((0x1e1c  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK1_CFG_W1                      ((0x1e20  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK2_CFG_W1                      ((0x1e24  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK3_CFG_W1                      ((0x1e28  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, y_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, y_start
+#define VIU2_OSD1_BLK0_CFG_W2                      ((0x1e1d  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK1_CFG_W2                      ((0x1e21  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK2_CFG_W2                      ((0x1e25  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK3_CFG_W2                      ((0x1e29  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, h_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, h_start
+#define VIU2_OSD1_BLK0_CFG_W3                      ((0x1e1e  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK1_CFG_W3                      ((0x1e22  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK2_CFG_W3                      ((0x1e26  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK3_CFG_W3                      ((0x1e2a  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, v_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, v_start
+#define VIU2_OSD1_BLK0_CFG_W4                      ((0x1e13  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK1_CFG_W4                      ((0x1e14  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK2_CFG_W4                      ((0x1e15  << 2) + 0xd0100000)
+#define VIU2_OSD1_BLK3_CFG_W4                      ((0x1e16  << 2) + 0xd0100000)
+// Bit    31 RW, burst_len_sel[2] of [2:0]
+// Bit    30 RW, byte_swap: In addition to endian control, further define
+//               whether to swap upper and lower byte within a 16-bit mem word.
+//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
+// Bit 29:22 R,  Reserved
+// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
+// Bit    19 R,  fifo_overflow
+//
+// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
+// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
+// Bit  9: 5 RW, hold_fifo_lines[4:0]
+// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
+// Bit     3 RW, fifo_sync_rst
+// Bit  2: 1 RW, endian
+// Bit     0 RW, urgent
+#define VIU2_OSD1_FIFO_CTRL_STAT                   ((0x1e2b  << 2) + 0xd0100000)
+// Bit 31:24 R, Y or R
+// Bit 23:16 R, Cb or G
+// Bit 15: 8 R, Cr or B
+// Bit  7: 0 R, Output Alpha[8:1]
+#define VIU2_OSD1_TEST_RDDATA                      ((0x1e2c  << 2) + 0xd0100000)
+// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
+// Bit 12: 0 RW, effective FIFO size when prot_en=1.
+#define VIU2_OSD1_PROT_CTRL                        ((0x1e2e  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// OSD2 registers
+//------------------------------------------------------------------------------
+// Bit    31 Reserved
+// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
+//                                0=use gated clock for low power.
+// Bit    29 R, test_rd_dsr
+// Bit    28 R, osd_done
+// Bit 27:24 R, osd_blk_mode
+// Bit 23:22 R, osd_blk_ptr
+// Bit    21 R, osd_enable
+//
+// Bit 20:12 RW, global_alpha
+// Bit    11 RW, test_rd_en
+// Bit    10 RW, hl2_en
+// Bit     9 RW, hl1_en
+// Bit  8: 5 RW, ctrl_mtch_y
+// Bit     4 RW, ctrl_422to444
+// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
+//                               Bit 1 to enable block 1, and so on.
+#define VIU2_OSD2_CTRL_STAT                        ((0x1e30  << 2) + 0xd0100000)
+// Bit 31:26 Reserved
+// Bit 25:16 R, fifo_count
+// Bit 15: 6 Reserved
+// Bit  5: 4 RW, hold_fifo_lines[6:5]
+// Bit     3 RW, rgb2yuv_full_range
+// Bit     2 RW, alpha_9b_mode
+// Bit     1 RW, reserved
+// Bit     0 RW, color_expand_mode
+#define VIU2_OSD2_CTRL_STAT2                       ((0x1e4d  << 2) + 0xd0100000)
+// Bit 31: 9 Reserved
+// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
+// Bit  7: 0 RW, lut_addr
+#define VIU2_OSD2_COLOR_ADDR                       ((0x1e31  << 2) + 0xd0100000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define VIU2_OSD2_COLOR                            ((0x1e32  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, hl[1-2]_h/v_start
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, hl[1-2]_h/v_end
+#define VIU2_OSD2_HL1_H_START_END                  ((0x1e33  << 2) + 0xd0100000)
+#define VIU2_OSD2_HL1_V_START_END                  ((0x1e34  << 2) + 0xd0100000)
+#define VIU2_OSD2_HL2_H_START_END                  ((0x1e35  << 2) + 0xd0100000)
+#define VIU2_OSD2_HL2_V_START_END                  ((0x1e36  << 2) + 0xd0100000)
+// Bit 31:24 RW, Y or R
+// Bit 23:16 RW, Cb or G
+// Bit 15: 8 RW, Cr or B
+// Bit  7: 0 RW, Alpha
+#define VIU2_OSD2_TCOLOR_AG0                       ((0x1e37  << 2) + 0xd0100000)
+#define VIU2_OSD2_TCOLOR_AG1                       ((0x1e38  << 2) + 0xd0100000)
+#define VIU2_OSD2_TCOLOR_AG2                       ((0x1e39  << 2) + 0xd0100000)
+#define VIU2_OSD2_TCOLOR_AG3                       ((0x1e3a  << 2) + 0xd0100000)
+// Bit 31:24 Reserved
+// Bit 23:16 RW, tbl_addr
+// Bit    15 RW, little_endian: 0=big endian, 1=little endian
+// Bit    14 RW, rpt_y
+// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
+//                            pixel; 11=Interpolate with the average value
+//                            between previous and next pixel.
+// Bit 11: 8 RW, osd_blk_mode
+// Bit     7 RW, rgb_en
+// Bit     6 RW, tc_alpha_en
+// Bit  5: 2 RW, color_matrix
+// Bit     1 RW, interlace_en
+// Bit     0 RW, interlace_sel_odd
+#define VIU2_OSD2_BLK0_CFG_W0                      ((0x1e3b  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK1_CFG_W0                      ((0x1e3f  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK2_CFG_W0                      ((0x1e43  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK3_CFG_W0                      ((0x1e47  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, x_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, x_start
+#define VIU2_OSD2_BLK0_CFG_W1                      ((0x1e3c  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK1_CFG_W1                      ((0x1e40  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK2_CFG_W1                      ((0x1e44  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK3_CFG_W1                      ((0x1e48  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, y_end
+// Bit 15:13 Reserved
+// Bit 12: 0 RW, y_start
+#define VIU2_OSD2_BLK0_CFG_W2                      ((0x1e3d  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK1_CFG_W2                      ((0x1e41  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK2_CFG_W2                      ((0x1e45  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK3_CFG_W2                      ((0x1e49  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, h_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, h_start
+#define VIU2_OSD2_BLK0_CFG_W3                      ((0x1e3e  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK1_CFG_W3                      ((0x1e42  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK2_CFG_W3                      ((0x1e46  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK3_CFG_W3                      ((0x1e4a  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, v_end
+// Bit 15:12 Reserved
+// Bit 11: 0 RW, v_start
+#define VIU2_OSD2_BLK0_CFG_W4                      ((0x1e64  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK1_CFG_W4                      ((0x1e65  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK2_CFG_W4                      ((0x1e66  << 2) + 0xd0100000)
+#define VIU2_OSD2_BLK3_CFG_W4                      ((0x1e67  << 2) + 0xd0100000)
+// Bit    31 RW, burst_len_sel[2] of [2:0]
+// Bit    30 RW, byte_swap: In addition to endian control, further define
+//               whether to swap upper and lower byte within a 16-bit mem word.
+//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
+// Bit 29:22 R,  Reserved
+// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
+// Bit    19 R,  fifo_overflow
+//
+// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
+// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
+// Bit  9: 5 RW, hold_fifo_lines[4:0]
+// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
+// Bit     3 RW, fifo_sync_rst
+// Bit  2: 1 RW, endian
+// Bit     0 RW, urgent
+#define VIU2_OSD2_FIFO_CTRL_STAT                   ((0x1e4b  << 2) + 0xd0100000)
+// Bit 31:24 R, Y or R
+// Bit 23:16 R, Cb or G
+// Bit 15: 8 R, Cr or B
+// Bit  7: 0 R, Output Alpha[8:1]
+#define VIU2_OSD2_TEST_RDDATA                      ((0x1e4c  << 2) + 0xd0100000)
+// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
+// Bit 12: 0 RW, effective FIFO size when prot_en=1.
+#define VIU2_OSD2_PROT_CTRL                        ((0x1e4e  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// VD1 path
+//------------------------------------------------------------------------------
+#define VIU2_VD1_IF0_GEN_REG                       ((0x1e50  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_CANVAS0                       ((0x1e51  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_CANVAS1                       ((0x1e52  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_LUMA_X0                       ((0x1e53  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_LUMA_Y0                       ((0x1e54  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_CHROMA_X0                     ((0x1e55  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_CHROMA_Y0                     ((0x1e56  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_LUMA_X1                       ((0x1e57  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_LUMA_Y1                       ((0x1e58  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_CHROMA_X1                     ((0x1e59  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_CHROMA_Y1                     ((0x1e5a  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_RPT_LOOP                      ((0x1e5b  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_LUMA0_RPT_PAT                 ((0x1e5c  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_CHROMA0_RPT_PAT               ((0x1e5d  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_LUMA1_RPT_PAT                 ((0x1e5e  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_CHROMA1_RPT_PAT               ((0x1e5f  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_LUMA_PSEL                     ((0x1e60  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_CHROMA_PSEL                   ((0x1e61  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_DUMMY_PIXEL                   ((0x1e62  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_LUMA_FIFO_SIZE                ((0x1e63  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_RANGE_MAP_Y                   ((0x1e6a  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_RANGE_MAP_CB                  ((0x1e6b  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_RANGE_MAP_CR                  ((0x1e6c  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_GEN_REG2                      ((0x1e6d  << 2) + 0xd0100000)
+#define VIU2_VD1_IF0_PROT_CNTL                     ((0x1e6e  << 2) + 0xd0100000)
+//Bit 31    it true, disable clock, otherwise enable clock
+//Bit 30    soft rst bit
+//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
+//Bit 27:24 horizontal formatter initial phase
+//Bit 23    horizontal formatter repeat pixel 0 enable
+//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
+//Bit 20    horizontal formatter enable
+//Bit 19    if true, always use phase0 while vertical formater, meaning always
+//          repeat data, no interpolation
+//Bit 18    if true, disable vertical formatter chroma repeat last line
+//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
+//Bit 16    veritcal formatter repeat line 0 enable
+//Bit 15:12 vertical formatter skip line num at the beginning
+//Bit 11:8  vertical formatter initial phase
+//Bit 7:1   vertical formatter phase step (3.4)  
+//Bit 0     vertical formatter enable
+#define VIU2_VD1_FMT_CTRL                          ((0x1e68  << 2) + 0xd0100000)
+//Bit 27:16  horizontal formatter width
+//Bit 11:0   vertical formatter width
+#define VIU2_VD1_FMT_W                             ((0x1e69  << 2) + 0xd0100000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  v2regs.h
+//
+//======================================================================
+//   vpu  register.
+//======================================================================
+// -----------------------------------------------
+// CBUS_BASE:  VPU_VCBUS_BASE = 0x27
+// -----------------------------------------------
+#define VPU_OSD1_MMC_CTRL                          ((0x2701  << 2) + 0xd0100000)
+#define VPU_OSD2_MMC_CTRL                          ((0x2702  << 2) + 0xd0100000)
+#define VPU_VD1_MMC_CTRL                           ((0x2703  << 2) + 0xd0100000)
+#define VPU_VD2_MMC_CTRL                           ((0x2704  << 2) + 0xd0100000)
+#define VPU_DI_IF1_MMC_CTRL                        ((0x2705  << 2) + 0xd0100000)
+#define VPU_DI_MEM_MMC_CTRL                        ((0x2706  << 2) + 0xd0100000)
+#define VPU_DI_INP_MMC_CTRL                        ((0x2707  << 2) + 0xd0100000)
+#define VPU_DI_MTNRD_MMC_CTRL                      ((0x2708  << 2) + 0xd0100000)
+#define VPU_DI_CHAN2_MMC_CTRL                      ((0x2709  << 2) + 0xd0100000)
+#define VPU_DI_MTNWR_MMC_CTRL                      ((0x270a  << 2) + 0xd0100000)
+#define VPU_DI_NRWR_MMC_CTRL                       ((0x270b  << 2) + 0xd0100000)
+#define VPU_DI_DIWR_MMC_CTRL                       ((0x270c  << 2) + 0xd0100000)
+#define VPU_VDIN0_MMC_CTRL                         ((0x270d  << 2) + 0xd0100000)
+#define VPU_VDIN1_MMC_CTRL                         ((0x270e  << 2) + 0xd0100000)
+#define VPU_BT656_MMC_CTRL                         ((0x270f  << 2) + 0xd0100000)
+#define VPU_TVD3D_MMC_CTRL                         ((0x2710  << 2) + 0xd0100000)
+#define VPU_TVDVBI_MMC_CTRL                        ((0x2711  << 2) + 0xd0100000)
+//Read only
+//`define     VPU_TVDVBI_VSLATCH_ADDR   8'h12
+//Read only
+//`define     VPU_TVDVBI_WRRSP_ADDR 8'h13
+#define VPU_VDIN_PRE_ARB_CTRL                      ((0x2714  << 2) + 0xd0100000)
+#define VPU_VDISP_PRE_ARB_CTRL                     ((0x2715  << 2) + 0xd0100000)
+#define VPU_VPUARB2_PRE_ARB_CTRL                   ((0x2716  << 2) + 0xd0100000)
+#define VPU_OSD3_MMC_CTRL                          ((0x2717  << 2) + 0xd0100000)
+#define VPU_OSD4_MMC_CTRL                          ((0x2718  << 2) + 0xd0100000)
+#define VPU_VD3_MMC_CTRL                           ((0x2719  << 2) + 0xd0100000)
+// [31:11] Reserved.
+// [10: 8] cntl_viu_vdin_sel_data. Select VIU to VDIN data path, must clear it first before changing the path selection:
+//          3'b000=Disable VIU to VDIN path;
+//          3'b001=Enable VIU of ENC_I domain to VDIN;
+//          3'b010=Enable VIU of ENC_P domain to VDIN;
+//          3'b100=Enable VIU of ENC_T domain to VDIN;
+// [ 6: 4] cntl_viu_vdin_sel_clk. Select which clock to VDIN path, must clear it first before changing the clock:
+//          3'b000=Disable VIU to VDIN clock;
+//          3'b001=Select encI clock to VDIN;
+//          3'b010=Select encP clock to VDIN;
+//          3'b100=Select encT clock to VDIN;
+// [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
+//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
+// [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
+//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
+#define VPU_VIU_VENC_MUX_CTRL                      ((0x271a  << 2) + 0xd0100000)
+// [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
+// [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
+// [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
+//                          0=output CrYCb(BRG);
+//                          1=output YCbCr(RGB);
+//                          2=output YCrCb(RBG);
+//                          3=output CbCrY(GBR);
+//                          4=output CbYCr(GRB);
+//                          5=output CrCbY(BGR);
+//                          6,7=Rsrv.
+// [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
+// [    3] inv_vsync. 1=Invert Vsync polarity.
+// [    2] inv_hsync. 1=Invert Hsync polarity.
+// [ 1: 0] src_sel. 0=Disable output to HDMI; 1=Select VENC_I output to HDMI; 2=Select VENC_P output.
+#define VPU_HDMI_SETTING                           ((0x271b  << 2) + 0xd0100000)
+#define ENCI_INFO_READ                             ((0x271c  << 2) + 0xd0100000)
+#define ENCP_INFO_READ                             ((0x271d  << 2) + 0xd0100000)
+#define ENCT_INFO_READ                             ((0x271e  << 2) + 0xd0100000)
+#define ENCL_INFO_READ                             ((0x271f  << 2) + 0xd0100000)
+// Bit  0 RW, viu_rst_n
+// Bit  1 RW, vdin_mmc_arb_rst_n
+// Bit  2 RW, vdisp_mmc_arb_rst_n
+// Bit  3 RW, vpuarb2_mmc_arb_rst_n
+#define VPU_SW_RESET                               ((0x2720  << 2) + 0xd0100000)
+//Bit 30     d2d3_depr_req_sel,  0:vdisp_pre_arb, 1: vpuarb2_pre_arb
+//Bit 27:22  d2d3_depr_brst_num
+//Bit 21:16  d2d3_depr_id
+//Bit 14     d2d3_depw_req_sel, 0: vdin_pre_arb, 1: vdisp_pre_arb
+//Bit 11:6   d2d3_depw_brst_num
+//Bit 5:0    d2d3_depw_id
+#define VPU_D2D3_MMC_CTRL                          ((0x2721  << 2) + 0xd0100000)
+//Bit 30     mtn_contrd_req_pre,  0:disp1_arb, 1: vdin_pre_arb
+//Bit 27:22  mtn_contrd_brst_num
+//Bit 21:16  mtn_contrd_id
+//Bit 14     mtn_contwr_req_pre, 0: vdisp1_arb, 1: vdin_pre_arb
+//Bit 11:6   mtn_contwr_brst_num
+//Bit 5:0    mtn_contwr_id
+#define VPU_CONT_MMC_CTRL                          ((0x2722  << 2) + 0xd0100000)
+// Bit  6 RW, gclk_mpeg_vpu_misc
+// Bit  5 RW, gclk_mpeg_venc_l_top
+// Bit  4 RW, gclk_mpeg_vencl_int
+// Bit  3 RW, gclk_mpeg_vencp_int
+// Bit  2 RW, gclk_mpeg_vi2_top
+// Bit  1 RW, gclk_mpeg_vi_top
+// Bit  0 RW, gclk_mpeg_venc_p_top
+#define VPU_CLK_GATE                               ((0x2723  << 2) + 0xd0100000)
+//Bit    12 RW, rdma_pre
+//Bit 11: 6 RW, rdma_num
+//Bit  5: 0 RW, rdma_id
+#define VPU_RDMA_MMC_CTRL                          ((0x2724  << 2) + 0xd0100000)
+#define VPU_MEM_PD_REG0                            ((0x2725  << 2) + 0xd0100000)
+#define VPU_MEM_PD_REG1                            ((0x2726  << 2) + 0xd0100000)
+// [   31] hdmi_data_ovr_en: 1=Enable overriding data input to HDMI TX with hdmi_data_ovr[29:0]. 0=No override. Default 0.
+// [   30] Reserved.                                                                                            Default 0
+// [29: 0] hdmi_data_ovr.                                                                                       Default 0.
+#define VPU_HDMI_DATA_OVR                          ((0x2727  << 2) + 0xd0100000)
+//Bit    15 RW, prot1_sel_osd4
+//Bit    14 RW, prot1_sel_osd3
+//Bit    13 RW, prot1_sel_osd2
+//Bit    12 RW, prot1_sel_osd1
+//Bit 11: 6 RW, prot1_brst_num
+//Bit  5: 0 RW, prot1_id
+#define VPU_PROT1_MMC_CTRL                         ((0x2728  << 2) + 0xd0100000)
+//Bit    14 RW, prot2_sel_vd3
+//Bit    13 RW, prot2_sel_vd2
+//Bit    12 RW, prot2_sel_vd1
+//Bit 11: 6 RW, prot2_brst_num
+//Bit  5: 0 RW, prot2_id
+#define VPU_PROT2_MMC_CTRL                         ((0x2729  << 2) + 0xd0100000)
+//Bit    14 RW, prot3_sel_vd3
+//Bit    13 RW, prot3_sel_vd2
+//Bit    12 RW, prot3_sel_vd1
+//Bit 11: 6 RW, prot3_brst_num
+//Bit  5: 0 RW, prot3_id
+#define VPU_PROT3_MMC_CTRL                         ((0x272a  << 2) + 0xd0100000)
+//Bit 29:24 RW, s3_brst_num
+//Bit 21:16 RW, s2_brst_num
+//Bit 13: 8 RW, s1_brst_num
+//Bit  5: 0 RW, s0_brst_num
+#define VPU_ARB4_V1_MMC_CTRL                       ((0x272b  << 2) + 0xd0100000)
+//Bit 29:24 RW, s3_brst_num
+//Bit 21:16 RW, s2_brst_num
+//Bit 13: 8 RW, s1_brst_num
+//Bit  5: 0 RW, s0_brst_num
+#define VPU_ARB4_V2_MMC_CTRL                       ((0x272c  << 2) + 0xd0100000)
+//Bit 27:22 RW, mcvecwr_num
+//Bit 21:16 RW, mcvecwr_id
+//Bit 11:6  RW, mcvecrd_num
+//Bit 5:0   RW, mcvecrd_id
+#define VPU_MCVEC_MMC_CTRL                         ((0x272d  << 2) + 0xd0100000)
+//Bit 27:22 RW, mcinfwr_num
+//Bit 21:16 RW, mcinfwr_id
+//Bit 11:6  RW, mcinfrd_num
+//Bit 5:0   RW, mcinfrd_id
+#define VPU_MCINF_MMC_CTRL                         ((0x272e  << 2) + 0xd0100000)
+//Bit 31    reg_vpu_pwm_inv, 1: invert the pwm signal, active low
+//Bit 30:29 reg_vpu_pwm_src_sel, 00: encl, enct, encp
+//Bit 28:16 reg_vpu_pwm_v_end0 
+//Bit 12:0  reg_vpu_pwm_v_start0 
+#define VPU_VPU_PWM_V0                             ((0x2730  << 2) + 0xd0100000)
+//Bit 28:16 reg_vpu_pwm_v_end1 
+//Bit 12:0  reg_vpu_pwm_v_start1 
+#define VPU_VPU_PWM_V1                             ((0x2731  << 2) + 0xd0100000)
+//Bit 28:16 reg_vpu_pwm_v_end2 
+//Bit 12:0  reg_vpu_pwm_v_start2 
+#define VPU_VPU_PWM_V2                             ((0x2732  << 2) + 0xd0100000)
+//Bit 28:16 reg_vpu_pwm_v_end3 
+//Bit 12:0  reg_vpu_pwm_v_start3 
+#define VPU_VPU_PWM_V3                             ((0x2733  << 2) + 0xd0100000)
+//Bit 28:16 reg_vpu_pwm_h_end0 
+//Bit 12:0  reg_vpu_pwm_h_start0 
+#define VPU_VPU_PWM_H0                             ((0x2734  << 2) + 0xd0100000)
+//Bit 28:16 reg_vpu_pwm_h_end1 
+//Bit 12:0  reg_vpu_pwm_h_start1 
+#define VPU_VPU_PWM_H1                             ((0x2735  << 2) + 0xd0100000)
+//Bit 28:16 reg_vpu_pwm_h_end2 
+//Bit 12:0  reg_vpu_pwm_h_start2 
+#define VPU_VPU_PWM_H2                             ((0x2736  << 2) + 0xd0100000)
+//Bit 28:16 reg_vpu_pwm_h_end3 
+//Bit 12:0  reg_vpu_pwm_h_start3 
+#define VPU_VPU_PWM_H3                             ((0x2737  << 2) + 0xd0100000)
+//Bit 18   reg_vpu_3d_go_high_fld_pol: 0: go high at field 0, 1: go high at field 1
+//Bit 17   reg_vpu_3d_sync_setting_vsync_latch
+//Bit 16   reg_vpu_3d_sync_enable
+//Bit 14:8 reg_vpu_3d_sync_v_end   
+//Bit 6:0  reg_vpu_3d_sync_v_start 
+#define VPU_VPU_3D_SYNC1                           ((0x2738  << 2) + 0xd0100000)
+//Bit 28:16 reg_vpu_3d_sync_h_end   
+//Bit 12:0  reg_vpu_3d_sync_h_start 
+#define VPU_VPU_3D_SYNC2                           ((0x2739  << 2) + 0xd0100000)
+//Bit 4    csi2_pre, 1: using vpu pre arbiter0, 0: using vpu pre arbiter2
+//Bit 2:1  isp_in_sel, 01: select bt656, 10: select Mipi CSI2, otherwise select nothing  
+//Bit 0,   if true, force vencl clk enable, otherwise, it might auto turn off by mipi DSI 
+#define VPU_MISC_CTRL                              ((0x2740  << 2) + 0xd0100000)
+#define VPU_ISP_GCLK_CTRL0                         ((0x2741  << 2) + 0xd0100000)
+#define VPU_ISP_GCLK_CTRL1                         ((0x2742  << 2) + 0xd0100000)
+#define VPU_HDMI_FMT_CTRL                          ((0x2743  << 2) + 0xd0100000)
+#define VPU_VDIN_ASYNC_HOLD_CTRL                   ((0x2744  << 2) + 0xd0100000)
+#define VPU_VDISP_ASYNC_HOLD_CTRL                  ((0x2745  << 2) + 0xd0100000)
+#define VPU_VPUARB2_ASYNC_HOLD_CTRL                ((0x2746  << 2) + 0xd0100000)
+//    vdin_urg_ctrl_o <=  vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[0] |
+//                        vdin0_lff_urg_ctrl & vpu_arb_urg_ctrl[1] | 
+//                        vdin1_lff_urg_ctrl & vpu_arb_urg_ctrl[2];
+//
+//    vdisp_urg_ctrl_o <= vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[3] |
+//                        vdin0_lff_urg_ctrl & vpu_arb_urg_ctrl[4] | 
+//                        vdin1_lff_urg_ctrl & vpu_arb_urg_ctrl[5];
+//
+//    vpuarb2_urg_ctrl_o <= vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[6] |
+//                          vdin0_lff_urg_ctrl & vpu_arb_urg_ctrl[7] | 
+//                          vdin1_lff_urg_ctrl & vpu_arb_urg_ctrl[8];
+#define VPU_ARB_URG_CTRL                           ((0x2747  << 2) + 0xd0100000)
+// Picture Rotate (PROT) module 1 (for OSD) registers:
+#define VPU_PROT1_CLK_GATE                         ((0x2750  << 2) + 0xd0100000)
+#define VPU_PROT1_GEN_CNTL                         ((0x2751  << 2) + 0xd0100000)
+#define VPU_PROT1_X_START_END                      ((0x2752  << 2) + 0xd0100000)
+#define VPU_PROT1_Y_START_END                      ((0x2753  << 2) + 0xd0100000)
+#define VPU_PROT1_Y_LEN_STEP                       ((0x2754  << 2) + 0xd0100000)
+#define VPU_PROT1_RPT_LOOP                         ((0x2755  << 2) + 0xd0100000)
+#define VPU_PROT1_RPT_PAT                          ((0x2756  << 2) + 0xd0100000)
+#define VPU_PROT1_DDR                              ((0x2757  << 2) + 0xd0100000)
+#define VPU_PROT1_RBUF_ROOM                        ((0x2758  << 2) + 0xd0100000)
+#define VPU_PROT1_STAT_0                           ((0x2759  << 2) + 0xd0100000)
+#define VPU_PROT1_STAT_1                           ((0x275a  << 2) + 0xd0100000)
+#define VPU_PROT1_STAT_2                           ((0x275b  << 2) + 0xd0100000)
+#define VPU_PROT1_REQ_ONOFF                        ((0x275c  << 2) + 0xd0100000)
+// Picture Rotate (PROT) module 2 (for VD) registers:
+#define VPU_PROT2_CLK_GATE                         ((0x2760  << 2) + 0xd0100000)
+#define VPU_PROT2_GEN_CNTL                         ((0x2761  << 2) + 0xd0100000)
+#define VPU_PROT2_X_START_END                      ((0x2762  << 2) + 0xd0100000)
+#define VPU_PROT2_Y_START_END                      ((0x2763  << 2) + 0xd0100000)
+#define VPU_PROT2_Y_LEN_STEP                       ((0x2764  << 2) + 0xd0100000)
+#define VPU_PROT2_RPT_LOOP                         ((0x2765  << 2) + 0xd0100000)
+#define VPU_PROT2_RPT_PAT                          ((0x2766  << 2) + 0xd0100000)
+#define VPU_PROT2_DDR                              ((0x2767  << 2) + 0xd0100000)
+#define VPU_PROT2_RBUF_ROOM                        ((0x2768  << 2) + 0xd0100000)
+#define VPU_PROT2_STAT_0                           ((0x2769  << 2) + 0xd0100000)
+#define VPU_PROT2_STAT_1                           ((0x276a  << 2) + 0xd0100000)
+#define VPU_PROT2_STAT_2                           ((0x276b  << 2) + 0xd0100000)
+#define VPU_PROT2_REQ_ONOFF                        ((0x276c  << 2) + 0xd0100000)
+// Picture Rotate (PROT) module 3 (for VD) registers:
+#define VPU_PROT3_CLK_GATE                         ((0x2770  << 2) + 0xd0100000)
+#define VPU_PROT3_GEN_CNTL                         ((0x2771  << 2) + 0xd0100000)
+#define VPU_PROT3_X_START_END                      ((0x2772  << 2) + 0xd0100000)
+#define VPU_PROT3_Y_START_END                      ((0x2773  << 2) + 0xd0100000)
+#define VPU_PROT3_Y_LEN_STEP                       ((0x2774  << 2) + 0xd0100000)
+#define VPU_PROT3_RPT_LOOP                         ((0x2775  << 2) + 0xd0100000)
+#define VPU_PROT3_RPT_PAT                          ((0x2776  << 2) + 0xd0100000)
+#define VPU_PROT3_DDR                              ((0x2777  << 2) + 0xd0100000)
+#define VPU_PROT3_RBUF_ROOM                        ((0x2778  << 2) + 0xd0100000)
+#define VPU_PROT3_STAT_0                           ((0x2779  << 2) + 0xd0100000)
+#define VPU_PROT3_STAT_1                           ((0x277a  << 2) + 0xd0100000)
+#define VPU_PROT3_STAT_2                           ((0x277b  << 2) + 0xd0100000)
+#define VPU_PROT3_REQ_ONOFF                        ((0x277c  << 2) + 0xd0100000)
+//========================================================================
+//  MIPI CSI2 Controller Adaptor    (16'h2a00 - 16'h2aff)
+//
+//========================================================================
+//`define  CSI2_VCBUS_BASE            8'h2a
+//`include "csi2_regs.h"
+//======================================================================
+// D2D3 registers 
+//======================================================================
+//`define     D2D3_VCBUS_BASE         8'h2b
+//
+// Reading file:  d2d3_regs.h
+//
+//===========================================================================
+// D2D3 Registers    0x - 0x
+//===========================================================================
+// -----------------------------------------------
+// CBUS_BASE:  D2D3_VCBUS_BASE = 0x2b
+// -----------------------------------------------
+//------------------------------------------------------------------------------
+// D2D3 top-level registers
+//------------------------------------------------------------------------------
+// Bit 31    RW, rd_lock_en,     1 to allow update some read-only registers based on filed
+// Bit 30    RW, sw_rst_nobuf,   1 to reset the whole d2d3 unit
+// Bit 29:28 RW, clk_auto_dis,   [29] DBR clock disable
+//                               [28] DPG clock disable
+// Bit 27:16 RW, clk_ctrl,       [27:26] gated clock control for register unit 
+//                               [25:24] gated clock control for DBR unit
+//                               [23:22] gated clock control for LBDG unit
+//                               [21:20] gated clock control for MBDG unit
+//                               [19:18] gated clock control for CBDG unit
+//                               [17:16] gated clock control for DBLD unit and SCD81 unit
+// Bit 15:12 Reserved  
+// Bit 11    RW, lo_chroma_sign, 0: negate the u/v component of DBR left channel video output, 1: bypass
+// Bit 10    RW, ro_chroma_sign, 0: negate the u/v component of DBR right channel video output, 1: bypass
+// Bit 9     RW, vi0_chroma_sign, 0: negate the u/v component of DPG video input, 1: bypass   
+// Bit 8     RW, vi1_chroma_sign, 0: negate the u/v component of DBR video input, 1: bypass
+// Bit 7:5   Reserved 
+// Bit 4     RW, lg_en,          Enable the LBDG unit and LBDG clock        
+// Bit 3     RW, mg_en,          Enable the MBDG unit and MBDG clock
+// Bit 2     RW, cg_en,          Enable the CBDG unit and CBDG clock
+// Bit 1     RW, dbr_en,         Enable the DBR unit and DBR clock
+// Bit 0     RW, dpg_en,         Enable the DPG unit and clock except sub-unit CBDG, MBDG and LBDG
+#define D2D3_GLB_CTRL                              ((0x2b00  << 2) + 0xd0100000)
+// Indicate the input picture size in DPG unit
+// Bit 31:16 RW, szx_vi_m1,      The horizontal size minus 1
+// Bit 15:0  RW, szy_vi_m1,      The vertical size minus 1
+#define D2D3_DPG_INPIC_SIZE                        ((0x2b01  << 2) + 0xd0100000)
+// Indicate the output picture size in DBR unit
+// Bit 31:16 RW, szx_vo_m1,      The horizontal size minus 1
+// Bit 15:0  RW, szy_vo_m1,      The vertical size minus 1
+#define D2D3_DBR_OUTPIC_SIZE                       ((0x2b02  << 2) + 0xd0100000)
+// Indicate the rectangular window to generate the "depth" in DPG unit 
+// Bit 31:16 RW, dg_win_x_start, Horizontal start position, count from 0
+// Bit 15:0  RW, dg_win_x_end,   Horizontal end position, count from 0
+#define D2D3_DGEN_WIN_HOR                          ((0x2b03  << 2) + 0xd0100000)
+// Indicate the rectangular window to generate the "depth" in DPG unit 
+// Bit 31:16 RW, dg_win_y_start, Vertical start position, count from 0
+// Bit 15:0  RW, dg_win_y_end,   Vertical end position, count from 0
+#define D2D3_DGEN_WIN_VER                          ((0x2b04  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// CBDG SCU18 SCD81 SCD81_PRE registers
+// cg: color based depth generate module
+// scu18: scale up module
+// scd81: scale down module
+// scd81_pre: scd81 pre-scale-down module
+//------------------------------------------------------------------------------
+// Indicate parameters of pre-scale-down unit
+// Bit 31:16 RW, scd81_hphs_step, horizontal step
+// Bit 15:0  RW, scd81_hphs_ini, horizontal initial phase
+#define D2D3_PRE_SCD_H                             ((0x2b05  << 2) + 0xd0100000)
+// Bit 31:16 RW, scu18_iniph,    initial phase in SCU18, 
+//                               [23:16] indicate the horizontal phase offset from the first data of every line
+//                               [31:24] indicate the vertical phase offset from the first line of every frame
+// Bit 15:12 Reserved
+// Bit 11    RW, scd81_predrop_en, 1 to enable scd81 pre-scale-down function
+// Bit 10:9  RW, cg_csc_sel,     Color Space Conversion(CSC) matrix mode selector in CBDG 
+//                               0: BT.601 (16-235/240)
+//                               1: BT.709 (16-235/240)
+//                               2: BT.601 (0-255)
+//                               3: BT.709 (0-255)
+// Bit 8     RW, scu18_rep_en,   1 to double each line of the SCU18 output 
+// Bit 7:4   RW, scu18_factor,   up-scale factor in SCU18 on DBR input depth data 
+//                               [7:6] for vertical, 0->1:1, 1->1:2, 2->1:4, 3->1:8
+//                               [5:4] for horizontal, 0->1:1, 1->1:2, 2->1:4, 3->1:8
+// Bit 3:0   RW, scd81_factor,   down-scale factor in SCD81 on DPG source video 
+//                               [3:2] for vertical, 0->1:1, 1->2:1, 2->4:1, 3->8:1
+//                               [1:0] for horizontal, 0->1:1, 1->2:1, 2->4:1, 3->8:1
+#define D2D3_SCALER_CTRL                           ((0x2b06  << 2) + 0xd0100000)
+// Bit 31:24 RW, cg_rpg_dth,     the down |r-g| threshold for sky detect 
+// Bit 23:16 RW, cg_rpg_uth,     the up |r-g| threshold for sky detect 
+// Bit 15:8  RW, cg_lum_dth,     the down Y threshold for sky detect  
+// Bit 7:0   RW, cg_lum_uth,     the up Y threshold for sky detect  
+#define D2D3_CG_THRESHOLD_1                        ((0x2b07  << 2) + 0xd0100000)
+// Bit 31:24 RW, cg_rpb_dth,     the down |r-b| threshold for sky detect
+// Bit 23:16 RW, cg_rpb_uth,     the up |r-b| threshold for sky detect
+// Bit 15:8  RW, cg_bpg_dth,     the down |b-g| threshold for sky detect
+// Bit 7:0   RW, cg_bpg_uth,     the up |b-g| threshold for sky detect 
+#define D2D3_CG_THRESHOLD_2                        ((0x2b08  << 2) + 0xd0100000)
+// Bit 31:24 RW, cg_vp_rel_k,    parameter to calculate vanish point reliability
+// Bit 23:16 RW, cg_vp_y_thr,    the max limitation to calculate the vanish-point's vertical position
+// Bit 15:8  RW, cg_meet_dval,   signed depth value in the sky-bitmap 
+// Bit 7:0   RW, cg_unmt_dval,   signed depth value not in the sky-bitmap
+#define D2D3_CG_PARAM_1                            ((0x2b09  << 2) + 0xd0100000)
+// Bit 31:16 RW, cg_vpos_thr,    Maximal vertical limitation for sky-bit map when cg_vpos_en=1 and cg_vpos_adpt_en=0
+// Bit 15:8  Reserved
+// Bit 7     RW, cg_vpos_en,     1 to enable the max vertical limitation for sky-bitmap
+// Bit 6     RW, cg_vpos_adpt_en, 1 to enable the adaptive max vertical limitation for sky-bitmap. 
+//                               It is only valid when cg_vpos_en=1.
+//                               The max vertical limitation is the previous field's vanish-point (vertical position) if cg_vpos_adpt_en=1. 
+// Bit 5:4   RW, cg_lpf_bypass,  bypass of low pass filter 
+//                               [5]:Vertical bypass, 1: bypass the vertical LPF on the CBDG depth
+//                               [4]:Horizontal bypass, 1: bypass the horizontal LPF on the CBDG depth
+// Bit 3:0   RW, cg_vp_rel_s,    parameter to calculate vanish point reliability
+#define D2D3_CG_PARAM_2                            ((0x2b0a  << 2) + 0xd0100000)
+// Indicate parameters of pre-scale-down unit
+// Bit 31:16 RW, scd81_vphs_step, vertical step
+// Bit 15:0  RW, scd81_vphs_ini, vertical initial phase
+#define D2D3_PRE_SCD_V                             ((0x2b0b  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// D2P registers
+// d2p: depth to parallax transform module
+//------------------------------------------------------------------------------
+// Bit 31:24 RW, d2p_brdwid,     Horizontal boundary width for parallax, the parallax value would be forced to 0 in boundary, 
+//                               the d2p_brdwid should not 0 when D2P_WRAP is enabled
+// Bit 23:22 Reserved
+// Bit 21:20 RW, d2p_lomode,     line output mode, 
+//                               0:whole line is left or right;  1:whole line is left or right;
+//                               2:left/right pixel interleaved;  3:left/right half-line interleaved
+// Bit 19    RW, d2p_neg,        1 to exchange the left and right parallax value
+// Bit 18    Reserved 
+// Bit 17    RW, d2p_wrap_en,    1 to enable D2P_WRAP unit
+// Bit 16    RW, d2p_lar,        Indicate the first output for left or right, 0: left; 1: right
+// Bit 15    RW, d2p_lr_switch,  enable left/right flag filed switch automatically, only valid when parallax output mode is field interleaved
+// Bit 14    RW, d2p_1dtolr,     enable to generate 2 parallax data (left and right) from one depth
+// Bit 13:12 RW, d2p_out_mode,   Parallax output mode 
+//                               0:left/right pixel interleaved; 1:line or half line interleaved; 2:field interleaved
+// Bit 11:8  RW, d2p_smode,      Shift mode,
+//                               0: no shift; 1: enable left shift;
+//                               2: enable right shift; 3: both left and right shift are enabled
+// Bit 7:0   RW, d2p_offset,     depth offset, signed, 
+#define D2D3_D2P_PARAM_1                           ((0x2b0c  << 2) + 0xd0100000)
+// Bit 31:24 RW, d2p_pg0,        positive parallax gain when Parallax value < pt
+// Bit 23:16 RW, d2p_pg1,        positive parallax gain when Parallax value >= pt
+// Bit 15:8  RW, d2p_pt,         unsigned value used to separate the positive parallax range
+// Bit 7:0   RW, d2p_plimit,     The limitation for positive parallax
+#define D2D3_D2P_PARAM_2                           ((0x2b0d  << 2) + 0xd0100000)
+// Bit 31:24 RW, d2p_ng0,        negative parallax gain when Parallax value > -nt
+// Bit 23:16 RW, d2p_ng1,        negative parallax gain when Parallax value <= -nt
+// Bit 15:8  RW, d2p_nt,         unsigned value used to separate the negative parallax range
+// Bit 7:0   RW, d2p_nlimit,     The limitation for negative parallax
+#define D2D3_D2P_PARAM_3                           ((0x2b0e  << 2) + 0xd0100000)
+// Indicate step parameters of SCU18 unit
+// Bit 31:17 Reserved
+// Bit 16    RW, scu18_step_en,   step set enable in SCU18
+// Bit 15:8  RW, scu18_hphs_step, horizontal step in SCU18
+// Bit 7:0   RW, scu18_vphs_step, vertical step in SCU18
+#define D2D3_SCU18_STEP                            ((0x2b0f  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// LBDG and DBLD registers
+// lg: luma based depth generate module
+// db: depth blending module
+//------------------------------------------------------------------------------
+// Bit 31:22 Reserved
+// Bit 21:20 RW, db_lpf_bpcoeff, [21]:Vertical factor of low pass filter, 
+//                               1: Vfactor = 0/0/64/0/0, 0: Vfactor = {db_vf_a,db_vf_b,db_vf_c,db_vf_b,db_vf_a}, see D2D3_CTRL_15
+//                               [20]:Horizontal factor of low pass filter, 
+//                               1: Hfactor = 0/0/64/0/0, 0: Hfactor = {db_hf_a,db_hf_b,db_hf_c,db_hf_b,db_hf_a}, see D2D3_CTRL_14
+// Bit 19:18 RW, lg_lpf_bpcoeff, [19]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
+//                               [18]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
+// Bit 17:16 RW, cg_lpf_bpcoeff, [17]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
+//                               [16]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
+// Bit 15:10 Reserved
+// Bit 9:8   RW, db_lpf_bypass,  [9] 1 to bypass the vertical LPF on the DBLD depth
+//                               [8] 1 to bypass the horizontal LPF on the DBLD depth
+// Bit 7:6   RW, lg_lpf_bypass,  [7] 1 to bypass the vertical LPF on the LBDG depth
+//                               [6] 1 to bypass the horizontal LPF on the LBDG depth
+// Bit 5:0   RW, lg_kc,          gain of CPL(v-u+256-y) to calculate the depth in LBDG
+#define D2D3_DPF_LPF_CTRL                          ((0x2b10  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// DBLD registers
+// db: depth blending module
+//------------------------------------------------------------------------------
+// Bit 31:24 RW, db_g2_cg,       gain of CBDG depth in DBLD
+// Bit 23:16 RW, db_o2_cg,       offset of CBDG depth in DBLD
+// Bit 15:8  RW, db_g1_cg,       gain of CBDG depth using for summary in DBLD
+// Bit 7:0   RW, db_o1_cg,       offset of CBDG depth using for summary in DBLD
+#define D2D3_DBLD_CG_PARAM                         ((0x2b11  << 2) + 0xd0100000)
+// Bit 31:24 RW, db_g2_mg,       gain of MBDG depth in DBLD
+// Bit 23:16 RW, db_o2_mg,       offset of MBDG depth in DBLD
+// Bit 15:8  RW, db_g1_mg,       gain of MBDG depth using for summary in DBLD
+// Bit 7:0   RW, db_o1_mg,       offset of MBDG depth using for summary in DBLD
+#define D2D3_DBLD_MG_PARAM                         ((0x2b12  << 2) + 0xd0100000)
+// Bit 31:24 RW, db_g2_lg,       gain of LBDG depth in DBLD
+// Bit 23:16 RW, db_o2_lg,       offset of LBDG depth in DBLD
+// Bit 15:8  RW, db_g1_lg,       gain of LBDG depth using for summary in DBLD
+// Bit 7:0   RW, db_o1_lg,       offset of LBDG depth using for summary in DBLD
+#define D2D3_DBLD_LG_PARAM                         ((0x2b13  << 2) + 0xd0100000)
+// Bit 31:24 RW, db_factor,      unsigned gain of difference in DBLD
+// Bit 23:16 RW, db_hf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+// Bit 15:8  RW, db_hf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+// Bit 7:0   RW, db_hf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+#define D2D3_DBLD_LPF_HCOEFF                       ((0x2b14  << 2) + 0xd0100000)
+// Bit 31:24 RW, db_owin_fill,   signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
+// Bit 23:16 RW, db_vf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+// Bit 15:8  RW, db_vf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+// Bit 7:0   RW, db_vf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
+#define D2D3_DBLD_LPF_VCOEFF                       ((0x2b15  << 2) + 0xd0100000)
+// Bit 31:28 RW, hist_depth_idx,     
+// Bit 27:26 Reserved   
+// Bit 25    RW, mbdg_dep_neg,   1 to negate the output data of MBDG
+// Bit 24    RW, lbdg_dep_neg,   1 to negate the output data of LBDG
+// Bit 23:16 RW, db_f1_ctrl,     MUX1 selector
+//                               [1:0] MUX1 path1 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
+//                               [3:2] MUX1 path2 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
+//                               [6:4] MUX1 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX1out0, others:summary
+//                               [7] MUX1OUT0 selector, 0:MIN (MUX1PATH1,MUX1Path2), 1:MAX (MUX1Path1,MUX1Path2)
+// Bit 15:8  RW, db_f2_ctrl,     MUX2 selector
+//                               [1:0] MUX2 path1 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
+//                               [3:2] MUX2 path2 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
+//                               [6:4] MUX2 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX2out0, others:MUX2out0
+//                               [7] MUX2OUT0 selector, 0:MIN (MUX2PATH1,MUX2Path2), 1:MAX (MUX2Path1,MUX2Path2)
+// Bit 7:4   RW, db_fifo0_sel,   the source input of FIFO0
+//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG others:reserved
+// Bit 3:0   RW, db_fifo1_sel,   the source input of FIFO1
+//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG 4: from FIFO0; others:reserved
+#define D2D3_DBLD_PATH_CTRL                        ((0x2b16  << 2) + 0xd0100000)
+// Indicate the input picture size in SCU18 unit
+// Bit 31:16 RW, szy_scui,       The vertical size 
+// Bit 15:0  RW, szx_scui,       The horizontal size 
+#define D2D3_SCU18_INPIC_SIZE                      ((0x2b17  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// MBDG registers
+// mg: model based depth generate module
+//------------------------------------------------------------------------------
+// Bit 31:18 Reserved
+// Bit 17    RW, mg_vp_en,       mdg vanish point enable, not used
+// Bit 16    RW, mg_sw_en,       1 to use the software forced parameter for the point D, U and C in MBDG
+// Bit 15:8  RW, mg_owin_fill,   Signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
+// Bit 7     RW, mg_iir_en,      1 to enable the 2-taps IIR filter in MBDG
+// Bit 6:0   RW, mg_iir,         [6]: 1 to bypass the 2-taps IIR filter in MBDG
+//                               [5:0]:Unsigned coefficient of the 2-taps IIR filter in MBDG
+//                               [6]:bypass, 1:bypass, 0:not bypass
+#define D2D3_MBDG_CTRL                             ((0x2b18  << 2) + 0xd0100000)
+// Bit 31:28 RW, mg_dtl_pxl_left, Max pixel number (1<< mg_dtl_pxl_left) using in the left window for activities in MBDG
+// Bit 27:24 RW, mg_dtl_pxl_right, Max pixel number (1<< mg_dtl_pxl_right) using in the right window for activities in MBDG
+// Bit 23:16 RW, mg_cx_sw,       Depth of point C in horizontal curve in MBDG for software forced
+// Bit 15:8  RW, mg_ux_sw,       Depth of point U in horizontal curve in MBDG for software forced
+// Bit 7:0   RW, mg_dx_sw,       Depth of point D in horizontal curve in MBDG for software forced
+#define D2D3_MBDG_PARAM_0                          ((0x2b19  << 2) + 0xd0100000)
+// Bit 31:28 RW, mg_dtl_pxl_up,  Max pixel number (1<< mg_dtl_pxl_up) using in the top window for activities in MBDG
+// Bit 27:24 RW, mg_dtl_pxl_dn,  Max pixel number (1<< mg_dtl_pxl_dn) using in the bottom window for activities in MBDG
+// Bit 23:16 RW, mg_cy_sw,       Depth of point C in vertical curve in MBDG for software forced       
+// Bit 15:8  RW, mg_uy_sw,       Depth of point U in vertical curve in MBDG for software forced
+// Bit 7:0   RW, mg_dy_sw,       Depth of point D in vertical curve in MBDG for software forced
+#define D2D3_MBDG_PARAM_1                          ((0x2b1a  << 2) + 0xd0100000)
+// Bit 31:24 RW, mg_dtl_ln_up,   Line number in the top window for activities in MBDG
+// Bit 23:16 RW, mg_dtl_ln_dn,   Line number in the bottom window for activities in MBDG
+// Bit 15:8  RW, mg_dtl_ln_left, Column number in the left window for activities in MBDG
+// Bit 7:0   RW, mg_dtl_ln_right,Column number in the right window for activities in MBDG
+#define D2D3_MBDG_PARAM_2                          ((0x2b1b  << 2) + 0xd0100000)
+// Bit 31:24 RW, mg_y_max,       Software initial depth of point D and U in vertical curve
+// Bit 23:16 RW, mg_y_min,       Software initial depth of point C in vertical curve
+// Bit 15:8  RW, mg_x_max,       Software initial depth of point D and U in horizontal curve
+// Bit 7:0   RW, mg_x_min,       Software initial depth of point C in horizontal curve
+#define D2D3_MBDG_PARAM_3                          ((0x2b1c  << 2) + 0xd0100000)
+// Bit 31:27 Reserved
+// Bit 26    RW, mg_y_adapt_en,  1 to enable the adaptive mode for point U/D in vertical curve calculation
+// Bit 25    RW, mg_xmm_adapt_en, 1 to enable the XMM adaptive mode for point U/D in horizontal curve calculation
+// Bit 24    RW, mg_x_adapt_en,  1 to enable the adaptive mode for point U/D in horizontal curve calculation
+// Bit 23:20 RW, mg_ytrans_1,    Shifter controller in vertical curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
+// Bit 19:16 RW, mg_xtrans_1,    Shifter controller in horizontal curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
+// Bit 15:8  RW, mg_yk_0,        The based activities value of the ACT for vertical curve
+// Bit 7:0   RW, mg_xk_0,        The based activities value of the ACT for horizontal curve
+#define D2D3_MBDG_PARAM_4                          ((0x2b1d  << 2) + 0xd0100000)
+// Bit 31:24 RW, mg_ysu3,        Quantized value 3 in vertical curve adaptive calculation
+// Bit 23:16 RW, mg_ysu2,        Quantized value 2 in vertical curve adaptive calculation
+// Bit 15:8  RW, mg_ysu1,        Quantized value 1 in vertical curve adaptive calculation
+// Bit 7:0   RW, mg_ysu0,        Quantized value 0 in vertical curve adaptive calculation
+#define D2D3_MBDG_PARAM_5                          ((0x2b1e  << 2) + 0xd0100000)
+// Bit 31:24 RW, mg_xsu3,        Quantized value 3 in horizontal curve adaptive calculation
+// Bit 23:16 RW, mg_xsu2,        Quantized value 2 in horizontal curve adaptive calculation
+// Bit 15:8  RW, mg_xsu1,        Quantized value 1 in horizontal curve adaptive calculation
+// Bit 7:0   RW, mg_xsu0,        Quantized value 0 in horizontal curve adaptive calculation
+#define D2D3_MBDG_PARAM_6                          ((0x2b1f  << 2) + 0xd0100000)
+// Bit 31:16 Reserved 
+// Bit 15:8  RW, mg_xsu4,        Quantized value 4 in horizontal curve adaptive calculation
+// Bit 7:0   RW, mg_ysu4,        Quantized value 4 in vertical curve adaptive calculation
+#define D2D3_MBDG_PARAM_7                          ((0x2b20  << 2) + 0xd0100000)
+// Bit 31:28 RW, dbg_hscnt_sel   see DBG_STATUS_2
+// Bit 27:25 Reserved 
+// Bit 24    RW, dbg_dbr_en,     1 to enable debug mode in DBR
+// Bit 23:16 RW, dbg_force_data, Forced data in debug mode
+// Bit 15:12 RW, dbg_bld_ctrl,   debug controller for DBLD
+//                               [12]:enable;  [13]: 0 for passive mode, 0 for handshake mode
+//                               [15:14]: 0 for constant mode, 1 for step1 mode
+// Bit 11:8  RW, dbg_mg_ctrl,    debug controller for MBDG
+//                               [8]:enable;  [9]: 0 for passive mode, 0 for handshake mode
+//                               [11:10]: 0 for constant mode, 1 for step1 mode
+// Bit 7:4   RW, dbg_cg_ctrl,    debug controller for CBDG
+//                               [4]:enable;  [5]: 0 for passive mode, 0 for handshake mode
+//                               [7:6]: 0 for constant mode, 1 for step1 mode
+// Bit 3:0   RW, dbg_lg_ctrl,    debug controller for LBDG
+//                               [0]:enable;  [1]: 0 for passive mode, 0 for handshake mode
+//                               [3:2]: 0 for constant mode, 1 for step1 mode
+#define D2D3_DBG_CTRL                              ((0x2b23  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// DWMIF registers
+//------------------------------------------------------------------------------
+// Bit 31:18 Reserved 
+// Bit 17    RW, dw_x_rev        0: Normal write data from left to right in horizontal
+//                               1: Reversed write data from left to right in horizontal
+// Bit 16    RW, dw_y_rev        0: Normal write data from top to bottom in horizontal
+//                               1: Reversed write data from bottom to top in horizontal  
+// Bit 15    RW, dw_done_clr     1 to clear register depw_done (DWMIF_STATUS)
+// Bit 14    RW, dw_little_endian, 0: data is ordered in big-endian, 1: little endian
+// Bit 13:12 RW, dw_pic_struct,  0:read every line, 1:reserved, 2:read even line, 3:read odd line
+// Bit 11    RW, dw_urgent,      urgent index
+// Bit 10    RW, dw_clr_wrrsp,   1:clear the write fifo counter
+// Bit 9     RW, dw_canvas_wr,   canvas write initialization again
+// Bit 8     RW, dw_req_en,      1 to enable write request
+// Bit 7:0   RW, dw_canvas_index,Canvas index for the MSB of memory address for memory write
+#define D2D3_DWMIF_CTRL                            ((0x2b24  << 2) + 0xd0100000)
+// Bit 31    Reserved
+// Bit 30:16 RW, dw_end_x,       Horizontal end position for memory write, count by BYTE
+// Bit 15    Reserved
+// Bit 14:0  RW, dw_start_x,     Horizontal start position for memory write, count by BYTE
+#define D2D3_DWMIF_HPOS                            ((0x2b25  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, dw_end_y,       Vertical end position for memory write, count by BYTE
+// Bit 15:13 Reserved
+// Bit 12:0  RW, dw_start_y,     Vertical start position for memory write, count by BYTE
+#define D2D3_DWMIF_VPOS                            ((0x2b26  << 2) + 0xd0100000)
+// Bit 31:28 Reserved
+// Bit 27:16 RW, dw_vsizem1,     Vertical size for memory write, equal the size minus 1
+// Bit 15:12 Reserved
+// Bit 11:0  RW, dw_hsizem1,     Horizontal size for memory write, equal the size minus 1
+#define D2D3_DWMIF_SIZE                            ((0x2b27  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// DRMIF registers
+//------------------------------------------------------------------------------
+// Bit 31:18 Reserved
+// Bit 17    RW, dr_y_rev,       0: Normal Read data from top to bottom in horizontal
+//                               1: Reversed read data from bottom to top in horizontal
+// Bit 16    RW, dr_x_rev,       0: Normal Read data from left to right in horizontal
+//                               1: Reversed read data from right to left in horizontal
+// Bit 15    RW, dr_clr_fifo_error, 1 to clear the overflow flag of the sticky FIFO
+// Bit 14    RW, dr_little_endian, 0: data is ordered in big-endian; 1: little-endian
+// Bit 13:12 RW, dr_pic_struct,  0: progressive;  1: Reserved;
+//                               2: interlaced, even line;  3: interlaced, odd line
+// Bit 11    RW, dr_urgent,      urgent index, no use in this system
+// Bit 10:9  RW, dr_burst_size,  Burst read length for each request; 0=24,1=32,2=48,3=64
+// Bit 8     RW, dr_req_en,      1 to enable read request
+// Bit 7:0   RW, dr_canvas_index, Canvas index for the MSB of memory address for memory read
+#define D2D3_DRMIF_CTRL                            ((0x2b28  << 2) + 0xd0100000)
+// Bit 31    Reserved
+// Bit 30:16 RW, dr_end_x,       Horizontal end position for memory read, count by BYTE
+// Bit 15    Reserved
+// Bit 14:0  RW, dr_start_x,     Horizontal start position for memory read, count by BYTE
+#define D2D3_DRMIF_HPOS                            ((0x2b29  << 2) + 0xd0100000)
+// Bit 31:29 Reserved
+// Bit 28:16 RW, dr_end_y,       Vertical end position for memory read, count by BYTE
+// Bit 15:13 Reserved
+// Bit 12:0  RW, dr_start_y,     Vertical start position for memory read, count by BYTE
+#define D2D3_DRMIF_VPOS                            ((0x2b2a  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// PDR registers
+// ddd: parallax based render
+//------------------------------------------------------------------------------
+// Bit 31:8  Reserved
+// Bit 7     RW, ddd_brdlpf_en,  1 to enable the smooth filter on the depth around the boundary
+// Bit 6     RW, ddd_extn_black, 1 to enable the function to fill black colour when interpolated pixels is outside the picture in DBR
+// Bit 5     RW, ddd_wrap_en,    Reserved
+// Bit 4     RW, ddd_hhalf,      1 to indicate the left/right line length is a half of original line. 
+// Bit 3:2   RW, ddd_out_mode,   Reserved
+// Bit 1:0   RW, ddd_lomode,     wrap & pbr interleave mode:                                        
+//                               2'b0x: whole line is left or right;                           
+//                               2'b10: d2p_lar=1(D2P_PARAM_1), rlrlrlrl inteleave in one line,
+//                                      d2p_lar=0(D2P_PARAM_1), lrlrlrlr inteleave in one line,      
+//                               2'b11: d2p_lar=1(D2P_PARAM_1), rrrrrlllll, half line is right, another half is left,
+//                                      d2p_lar=0(D2P_PARAM_1), lllllrrrrr, half line is left, another half is right,
+#define D2D3_DBR_DDD_CTRL                          ((0x2b2c  << 2) + 0xd0100000)
+// Bit 31:0  RW, ddd_dbg_ctrl,   no use
+#define D2D3_DBR_DDD_DBG                           ((0x2b2d  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// LRDMX registers
+//------------------------------------------------------------------------------
+// Bit 31:9  Reserved
+// Bit 8     RW, lr_merge,       1: all the left/right input go to the left channel output
+// Bit 7:6   RW, lrd_ff0_sel,    FF0 source selector
+//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
+// Bit 5:4   RW, lrd_ff1_sel,    FF1 source selector
+//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
+// Bit 3:2   RW, lrd_lout_sel,   left channel DEMUX
+//                               00: ff0  01:ff1   10: left input  11:right input
+// Bit 1:0   RW, lrd_rout_sel,   right channel DEMUX
+//                               00: ff1  01:ff0   10: left input  11:right input 
+#define D2D3_DBR_LRDMX_CTRL                        ((0x2b2f  << 2) + 0xd0100000)
+//------------------------------------------------------------------------------
+// Read Only registers
+//------------------------------------------------------------------------------
+// Bit 31:24 RO, ro_cg_vprel,    vanish point's reliability in CBDG
+// Bit 23:12 RO, ro_cg_vpx,      vanish point's X-Axis in CBDG
+// Bit 11:0  RO, ro_cg_vpy,      vanish point's Y-Axis in CBDG
+#define D2D3_CBDG_STATUS_1                         ((0x2b30  << 2) + 0xd0100000)
+// Bit 31:24 RO, ro_mg_cx[7:0],  X-Axis of point C in horizontal curve in MBDG
+// Bit 23:16 RO, ro_mg_ux,       Depth value of point U in horizontal curve in MBDG
+// Bit 15:8  RO, ro_mg_dx,       Depth value of point D in horizontal curve in MBDG
+// Bit 7:0   RO, ro_mg_minx,     Depth value of point C in horizontal curve in MBDG
+#define D2D3_MBDG_STATUS_1                         ((0x2b31  << 2) + 0xd0100000)
+// Bit 31:24 RO, ro_mg_cy[7:0],  X-Axis of point C in vertical curve in MBDG
+// Bit 23:16 RO, ro_mg_uy,       Depth value of point U in vertical curve in MBDG
+// Bit 15:8  RO, ro_mg_dy,       Depth value of point D in vertical curve in MBDG
+// Bit 7:0   RO, ro_mg_miny,     Depth value of point C in vertical curve in MBDG
+#define D2D3_MBDG_STATUS_2                         ((0x2b32  << 2) + 0xd0100000)
+// Bit 31    RO, ro_wrap_status, 1 indicate the D2P_WRAP is busy to perform the initialization
+// Bit 30:8  Reserved 
+// Bit 7:4   RO, ro_mg_cy[11:8], X-Axis of point C in vertical curve in MBDG
+// Bit 3:0   RO, ro_mg_cx[11:8], X-Axis of point C in horizontal curve in MBDG
+#define D2D3_MBDG_STATUS_3                         ((0x2b33  << 2) + 0xd0100000)
+// Bit 31:21 Reserved 
+// Bit 20:0  RO, ro_mg_sum_u,    ACT(top): activities of the top part
+#define D2D3_MBDG_STATUS_4                         ((0x2b34  << 2) + 0xd0100000)
+// Bit 31:21 Reserved 
+// Bit 20:0  RO, ro_mg_sum_d,    ACT(bottom): activities of the bottom part
+#define D2D3_MBDG_STATUS_5                         ((0x2b35  << 2) + 0xd0100000)
+// Bit 31:21 Reserved 
+// Bit 20:0  RO, ro_mg_sum_l,    ACT(left): activities of the left part
+#define D2D3_MBDG_STATUS_6                         ((0x2b36  << 2) + 0xd0100000)
+// Bit 31:21 Reserved  
+// Bit 20:0  RO, ro_mg_sum_r,    ACT(right): activities of the right part
+#define D2D3_MBDG_STATUS_7                         ((0x2b37  << 2) + 0xd0100000)
+// Bit 31:0 dbg_handshake_ro0,   handshake signal for debug, internal srdy and rrdy
+#define D2D3_DBG_STATUS_1                          ((0x2b38  << 2) + 0xd0100000)
+// Bit 31:0 dbg_hscnt,           dbg_hscnt_sel == 4'h0, output lg hscnt
+//                               dbg_hscnt_sel == 4'h1, output cg hscnt
+//                               dbg_hscnt_sel == 4'h2, output mg hscnt
+//                               dbg_hscnt_sel == 4'h3, output bld hscnt
+//                               dbg_hscnt_sel == other value, output 32'h0
+#define D2D3_DBG_STATUS_2                          ((0x2b39  << 2) + 0xd0100000)
+// Bit 31:0 RO, drmif_status,    drmif module internal status
+#define D2D3_DRMIF_STATUS                          ((0x2b3a  << 2) + 0xd0100000)
+// Bit 31:2 RO, Reserved
+// Bit 1:0  RO, d2d3_status0,    [1]: depw_done, one field depth write to ddr has done
+//                               [0]: dwmif_pending_ddr_wrrsp, 1 to indicate write response from ddr
+#define D2D3_DWMIF_STATUS                          ((0x2b3b  << 2) + 0xd0100000)
+// Bit 31:24 Reserved  
+// Bit 23:0  RO, ro_meet_sum,    register sumxy_sum_dbg in CBDG
+#define D2D3_CBDG_STATUS_2                         ((0x2b3c  << 2) + 0xd0100000)
+// Bit 31:20 Reserved  
+// Bit 19:0  RO, ro_hist_depth,  
+#define D2D3_DBLD_STATUS                           ((0x2b3d  << 2) + 0xd0100000)
+// Bit 31:0 Reserved  
+#define D2D3_RESEV_STATUS1                         ((0x2b3e  << 2) + 0xd0100000)
+// Bit 31:0  Reserved  
+#define D2D3_RESEV_STATUS2                         ((0x2b3f  << 2) + 0xd0100000)
+//
+// Closing file:  d2d3_regs.h
+//
+//========================================================================
+//  MIPI DSI Host Controller        (16'h2c00 - 16'h2cff)
+//
+//========================================================================
+//`define  DSI_VCBUS_BASE             8'h2c
+//`include "dsi_regs.h"
+//========================================================================
+//  ISP register    (16'h2d00 - 16'h2dff)
+//========================================================================
+//`define ISP_VCBUS_BASE                   8'h2d
+//`include "isp_reg.h"
+//========================================================================
+//  VI_HIST_SPL register    (16'h2e00 - 16'h2eff)
+//========================================================================
+//`define VI_HIST_SPL_VCBUS_BASE                   8'h2e
+//
+// Reading file:  vi_hist_spl_reg.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// ----------------------------
+// VI_HIST_SPL 0x2e  
+// ----------------------------
+// -----------------------------------------------
+// CBUS_BASE:  VI_HIST_SPL_VCBUS_BASE = 0x2e
+// -----------------------------------------------
+//BIT 14: 34bin only, 0&255 and other 32bins
+//Bit 13:11 hist_din_sel, 00: from vdin0 dout,  1: from vdin1, 2: from nr dout, 3: di output, 4: vpp output, 5: vd1_din, 6: vd2_din, 7:osd1_dout
+//Bit 10:8   hist_din_comp_mux, mux of [29:22], [19:12], [9:2] for hist detect
+//Bit 7:5   hist_dnlp_low   the real pixels in each bins got by VI_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
+//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
+//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
+//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
+#define VI_HIST_CTRL                               ((0x2e00  << 2) + 0xd0100000)
+//Bit 28:16 hist_hstart  horizontal start value to define hist window
+//Bit 12:0  hist_hend    horizontal end value to define hist window
+#define VI_HIST_H_START_END                        ((0x2e01  << 2) + 0xd0100000)
+//Bit 28:16 hist_vstart  vertical start value to define hist window
+//Bit 12:0  hist_vend    vertical end value to define hist window
+#define VI_HIST_V_START_END                        ((0x2e02  << 2) + 0xd0100000)
+//Bit 15:8  hist_max    maximum value 
+//Bit 7:0   hist_min    minimum value 
+//read only
+#define VI_HIST_MAX_MIN                            ((0x2e03  << 2) + 0xd0100000)
+//Bit 31:0  hist_spl_rd
+//counts for the total luma value 
+//read only
+#define VI_HIST_SPL_VAL                            ((0x2e04  << 2) + 0xd0100000)
+//Bit 21:0  hist_spl_pixel_count
+//counts for the total calculated pixels
+//read only
+#define VI_HIST_SPL_PIX_CNT                        ((0x2e05  << 2) + 0xd0100000)
+//Bit 31:0  hist_chroma_sum
+//counts for the total chroma value 
+//read only
+#define VI_HIST_CHROMA_SUM                         ((0x2e06  << 2) + 0xd0100000)
+//Bit 31:16 higher hist bin
+//Bit 15:0  lower hist bin
+//0-255 are splited to 64 bins evenly, and VI_DNLP_HISTXX
+//are the statistic number of pixels that within each bin.
+//VI_DNLP_HIST00[15:0]  counts for the first  bin
+//VI_DNLP_HIST00[31:16] counts for the second bin
+//VI_DNLP_HIST01[15:0]  counts for the third  bin
+//VI_DNLP_HIST01[31:16] counts for the fourth bin
+//etc...
+//read only
+#define VI_DNLP_HIST00                             ((0x2e07  << 2) + 0xd0100000)
+#define VI_DNLP_HIST01                             ((0x2e08  << 2) + 0xd0100000)
+#define VI_DNLP_HIST02                             ((0x2e09  << 2) + 0xd0100000)
+#define VI_DNLP_HIST03                             ((0x2e0a  << 2) + 0xd0100000)
+#define VI_DNLP_HIST04                             ((0x2e0b  << 2) + 0xd0100000)
+#define VI_DNLP_HIST05                             ((0x2e0c  << 2) + 0xd0100000)
+#define VI_DNLP_HIST06                             ((0x2e0d  << 2) + 0xd0100000)
+#define VI_DNLP_HIST07                             ((0x2e0e  << 2) + 0xd0100000)
+#define VI_DNLP_HIST08                             ((0x2e0f  << 2) + 0xd0100000)
+#define VI_DNLP_HIST09                             ((0x2e10  << 2) + 0xd0100000)
+#define VI_DNLP_HIST10                             ((0x2e11  << 2) + 0xd0100000)
+#define VI_DNLP_HIST11                             ((0x2e12  << 2) + 0xd0100000)
+#define VI_DNLP_HIST12                             ((0x2e13  << 2) + 0xd0100000)
+#define VI_DNLP_HIST13                             ((0x2e14  << 2) + 0xd0100000)
+#define VI_DNLP_HIST14                             ((0x2e15  << 2) + 0xd0100000)
+#define VI_DNLP_HIST15                             ((0x2e16  << 2) + 0xd0100000)
+#define VI_DNLP_HIST16                             ((0x2e17  << 2) + 0xd0100000)
+#define VI_DNLP_HIST17                             ((0x2e18  << 2) + 0xd0100000)
+#define VI_DNLP_HIST18                             ((0x2e19  << 2) + 0xd0100000)
+#define VI_DNLP_HIST19                             ((0x2e1a  << 2) + 0xd0100000)
+#define VI_DNLP_HIST20                             ((0x2e1b  << 2) + 0xd0100000)
+#define VI_DNLP_HIST21                             ((0x2e1c  << 2) + 0xd0100000)
+#define VI_DNLP_HIST22                             ((0x2e1d  << 2) + 0xd0100000)
+#define VI_DNLP_HIST23                             ((0x2e1e  << 2) + 0xd0100000)
+#define VI_DNLP_HIST24                             ((0x2e1f  << 2) + 0xd0100000)
+#define VI_DNLP_HIST25                             ((0x2e20  << 2) + 0xd0100000)
+#define VI_DNLP_HIST26                             ((0x2e21  << 2) + 0xd0100000)
+#define VI_DNLP_HIST27                             ((0x2e22  << 2) + 0xd0100000)
+#define VI_DNLP_HIST28                             ((0x2e23  << 2) + 0xd0100000)
+#define VI_DNLP_HIST29                             ((0x2e24  << 2) + 0xd0100000)
+#define VI_DNLP_HIST30                             ((0x2e25  << 2) + 0xd0100000)
+#define VI_DNLP_HIST31                             ((0x2e26  << 2) + 0xd0100000)
+#define VI_DNLP_HIST32                             ((0x2e27  << 2) + 0xd0100000)
+//Bit 28:16 hist_pic_height  active input data window height
+//Bit 12:0  hist_pic_width   active input data window width
+#define VI_HIST_PIC_SIZE                           ((0x2e28  << 2) + 0xd0100000)
+//Bit 15:8 hist_pix_white_value: >= this value will be white pixel
+//Bit 7:0 hist_pix_black_value: <= this value will be black pixel
+#define VI_HIST_BLACK_WHITE_VALUE                  ((0x2e29  << 2) + 0xd0100000)
+#define VI_HIST_GCLK_CTRL                          ((0x2e2a  << 2) + 0xd0100000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vi_hist_spl_reg.h
+//
+//`define MCDI_VCBUS_BASE                8'h2f
+//
+// Reading file:  mcdi_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  MCDI_VCBUS_BASE = 0x2f
+// -----------------------------------------------
+////=================================================================////
+//// memc di core 0
+////=================================================================////
+#define MCDI_HV_SIZEIN                             ((0x2f00  << 2) + 0xd0100000)
+//Bit 31:29, reserved  
+//Bit 28:16, reg_mcdi_hsize               image horizontal size (number of cols)   default=1024 
+//Bit 15:13, reserved                       
+//Bit 12: 0, reg_mcdi_vsize               image vertical size   (number of rows)   default=1024
+#define MCDI_HV_BLKSIZEIN                          ((0x2f01  << 2) + 0xd0100000)
+//Bit    31, reg_mcdi_vrev					 default = 0
+//Bit    30, reg_mcdi_hrev					 default = 0
+//Bit 29:28, reserved
+//Bit 27:16, reg_mcdi_blkhsize               image horizontal blk size (number of cols)   default=1024 
+//Bit 15:13, reserved                       
+//Bit 11: 0, reg_mcdi_blkvsize               image vertical blk size   (number of rows)   default=1024
+#define MCDI_BLKTOTAL                              ((0x2f02  << 2) + 0xd0100000)
+//Bit 31:24, reserved
+//Bit 23: 0, reg_mcdi_blktotal
+#define MCDI_MOTINEN                               ((0x2f03  << 2) + 0xd0100000)
+//Bit 31: 2, reserved
+//Bit     1, reg_mcdi_motionrefen.           enable motion refinement of MA, default = 1
+//Bit     0, reg_mcdi_motionparadoxen.       enable motion paradox detection, default = 1
+#define MCDI_CTRL_MODE                             ((0x2f04  << 2) + 0xd0100000)
+//Bit 31:28, reserved 
+//Bit 27:26, reg_mcdi_lmvlocken	             0:disable, 1: use max Lmv, 2: use no-zero Lmv, lmv lock enable mode, default = 2			
+//Bit 25,    reg_mcdi_reldetrptchken         
+//                                           0: unable; 1: enable, enable repeat pattern check (not repeat mv detection) in rel det part, default = 1
+//Bit 24,    reg_mcdi_reldetgmvpd22chken     
+//                                           0: unable; 1: enable, enable pull-down 22 mode check in gmv lock mode for rel det, default = 1
+//Bit 23,    reg_mcdi_pd22chken
+//                                           0: unable; 1: enable, enable pull-down 22 mode check (lock) function, default = 1      
+//Bit 22,    reg_mcdi_reldetlpfen
+//                                           0: unable; 1: enable, enable det value lpf, default = 1 
+//Bit 21,    reg_mcdi_reldetlmvpd22chken
+//                                           0: unable; 1: enable, enable pull-down 22 mode check in lmv lock mode for rel det, default = 1      
+//Bit 20,    reg_mcdi_reldetlmvdifchken
+//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1  
+//Bit 19,    reg_mcdi_reldetgmvdifchken
+//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1 
+//Bit 18,    reg_mcdi_reldetpd22chken
+//                                           0: unable; 1: enable, enable pull-down 22 mode check for rel det refinement, default = 1
+//Bit 17,    reg_mcdi_reldetfrqchken
+//                                           0: unable; 1: enable, enable mv frequency check in rel det, default = 1  
+//Bit 16,    reg_mcdi_qmeen
+//                                           0: unable; 1: enable, enable quarter motion estimation, defautl = 1  
+//Bit 15,    reg_mcdi_refrptmven
+//                                           0: unable; 1: enable, use repeat mv in refinement, default = 1 
+//Bit 14,    reg_mcdi_refgmven
+//                                           0: unable; 1: enable, use gmv in refinement, default = 1  
+//Bit 13,    reg_mcdi_reflmven
+//                                           0: unable; 1: enable, use lmvs in refinement, default = 1  
+//Bit 12,    reg_mcdi_refnmven
+//                                           0: unable; 1: enable, use neighoring mvs in refinement, default = 1  
+//Bit 11,    reserved  
+//Bit 10,    reg_mcdi_referrfrqchken		 
+//                                           0: unable; 1: enable, enable mv frquency check while finding min err in ref, default = 1  
+//Bit 9,     reg_mcdi_refen					 
+//                                           0: unable; 1: enable, enable mv refinement, default = 1  
+//Bit 8,     reg_mcdi_horlineen				 
+//                                           0: unable; 1: enable,enable horizontal lines detection by sad map, default = 1  
+//Bit 7,     reg_mcdi_highvertfrqdeten		 
+//                                           0: unable; 1: enable, enable high vertical frequency pattern detection, default = 1  
+//Bit 6,     reg_mcdi_gmvlocken				 
+//                                           0: unable; 1: enable, enable gmv lock mode, default = 1
+//Bit 5,     reg_mcdi_rptmven	             
+//                                           0: unable; 1: enable, enable repeat pattern detection, default = 1  
+//Bit 4,     reg_mcdi_gmven                  
+//                                           0: unable; 1: enable, enable global motion estimation, default = 1   
+//Bit 3,     reg_mcdi_lmven                  
+//                                           0: unable; 1: enable, enable line mv estimation for hme, default = 1  
+//Bit 2,     reg_mcdi_chkedgeen		         
+//                                           0: unable; 1: enable, enable check edge function, default = 1
+//Bit 1,     reg_mcdi_txtdeten			     
+//                                           0: unable; 1: enable, enable texture detection, default = 1 
+//Bit 0,     reg_mcdi_memcen                  
+//                                           0: unable; 1: enable, enable of memc di, default = 1
+#define MCDI_UNI_MVDST                             ((0x2f05  << 2) + 0xd0100000)
+//Bit 31:20, reserved  
+//Bit 19:17, reg_mcdi_unimvdstabsseg0                     segment0 for uni-mv abs, default = 1
+//Bit 16:12, reg_mcdi_unimvdstabsseg1                     segment1 for uni-mv abs, default = 15
+//Bit 11: 8, reg_mcdi_unimvdstabsdifgain0	          2/2, gain0 of uni-mv abs dif for segment0, normalized 2 to '1', default = 2 
+//Bit  7: 5, reg_mcdi_unimvdstabsdifgain1                 2/2, gain1 of uni-mv abs dif for segment1, normalized 2 to '1', default = 2             
+//Bit  4: 2, reg_mcdi_unimvdstabsdifgain2                 2/2, gain2 of uni-mv abs dif beyond segment1, normalized 2 to '1', default = 2              
+//Bit  1: 0, reg_mcdi_unimvdstsgnshft		          shift for neighboring distance of uni-mv, default = 0
+#define MCDI_BI_MVDST                              ((0x2f06  << 2) + 0xd0100000)
+//Bit 31:20, reserved  
+//Bit 19:17, reg_mcdi_bimvdstabsseg0                      segment0 for bi-mv abs, default = 1
+//Bit 16:12, reg_mcdi_bimvdstabsseg1                      segment1 for bi-mv abs, default = 9
+//Bit 11: 8, reg_mcdi_bimvdstabsdifgain0	          6/2, gain0 of bi-mv abs dif for segment0, normalized 2 to '1', default = 6
+//Bit  7: 5, reg_mcdi_bimvdstabsdifgain1                  3/2, gain1 of bi-mvabs dif for segment1, normalized 2 to '1', default = 3          
+//Bit  4: 2, reg_mcdi_bimvdstabsdifgain2                  2/2, gain2 of bi-mvabs dif beyond segment1, normalized 2 to '1', default = 2             
+//Bit  1: 0, reg_mcdi_bimvdstsgnshft	                  shift for neighboring distance of bi-mv, default = 0
+#define MCDI_SAD_GAIN                              ((0x2f07  << 2) + 0xd0100000)
+//Bit 31:19, reserved  
+//Bit 18:17, reg_mcdi_unisadcorepxlgain                   uni-sad core pixels gain, default = 3
+//Bit 16,    reg_mcdi_unisadcorepxlnormen                 enable uni-sad core pixels normalization, default = 0 
+//Bit 15:11, reserved
+//Bit 10: 9, reg_mcdi_bisadcorepxlgain                    bi-sad core pixels gain, default = 3
+//Bit  8,    reg_mcdi_bisadcorepxlnormen                  enable bi-sad core pixels normalization, default = 1 
+//Bit  7: 3, reserved
+//Bit  2: 1, reg_mcdi_biqsadcorepxlgain                   bi-qsad core pixels gain, default = 3
+//Bit  0,    reg_mcdi_biqsadcorepxlnormen                 enable bi-qsad core pixels normalization, default = 1              
+#define MCDI_TXT_THD                               ((0x2f08  << 2) + 0xd0100000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_txtminmaxdifthd,                    min max dif threshold (>=) for texture detection, default = 24
+//Bit 15: 8, reg_mcdi_txtmeandifthd,                      mean dif threshold (<) for texture detection, default = 9
+//Bit  7: 3, reserved
+//Bit  2: 0, reg_mcdi_txtdetthd,                          texture detecting threshold, 0~4, default = 2
+#define MCDI_FLT_MODESEL                           ((0x2f09  << 2) + 0xd0100000)
+//Bit 31	 reserved
+//Bit 30:28, reg_mcdi_flthorlineselmode                   mode for horizontal line detecting flat calculation, default = 1, same as below
+//Bit 27	 reserved
+//Bit 26:24, reg_mcdi_fltgmvselmode                       mode for gmv flat calculation, default = 4, same as below
+//Bit 23,	 reserved
+//Bit 22:20, reg_mcdi_fltsadselmode                       mode for sad flat calculation, default = 2, same as below
+//Bit 19,	 reserved
+//Bit 18:16, reg_mcdi_fltbadwselmode                      mode for badw flat calculation, default = 3, same as below
+//Bit 15,	 reserved
+//Bit 14:12, reg_mcdi_fltrptmvselmode                     mode for repeat mv flat calculation, default = 4, same as below
+//Bit 11,	 reserved
+//Bit 10: 8, reg_mcdi_fltbadrelselmode                    mode for bad rel flat calculation, default = 4, same as below
+//Bit  7,	 reserved
+//Bit  6: 4, reg_mcdi_fltcolcfdselmode                    mode for col cfd flat calculation, default = 2, same as below
+//Bit  3,	 reserved
+//Bit  2: 0, reg_mcdi_fltpd22chkselmode                   mode for pd22 check flat calculation, default = 2, # 0:cur dif h, 1: cur dif v, 2: pre dif h, 3: pre dif v, 4: cur flt, 5: pre flt, 6: cur+pre, 7: max all(cur,pre)
+#define MCDI_CHK_EDGE_THD                          ((0x2f0a  << 2) + 0xd0100000)
+//Bit 23:28, reserved.
+//Bit 27:24, reg_mcdi_chkedgedifsadthd.                   thd (<=) for sad dif check, 0~8, default = 1
+//Bit 23:16, reserved.
+//Bit 15:12, reg_mcdi_chkedgemaxedgethd.                  max drt of edge, default = 15
+//Bit 11: 8, reg_mcdi_chkedgeminedgethd.                  min drt of edge, default = 2
+//Bit     7, reserved.
+//Bit  6: 0, reg_mcdi_chkedgevdifthd.                     thd for vertical dif in check edge, default = 14
+#define MCDI_CHK_EDGE_GAIN_OFFST                   ((0x2f0b  << 2) + 0xd0100000)
+//Bit 31:24, reserved.
+//Bit 23:20, reg_mcdi_chkedgedifthd1.                     thd1 for edge dif check (<=), default = 4
+//Bit 19:16, reg_mcdi_chkedgedifthd0.                     thd0 for edge dif check (>=), default = 15
+//Bit   :15, reserved.
+//Bit 14:10, reg_mcdi_chkedgechklen.                      total check length for edge check, 1~24 (>0), default = 24
+//Bit  9: 8, reg_mcdi_chkedgeedgesel.                     final edge select mode, 0: original start edge, 1: lpf start edge, 2: orignal start+end edge, 3: lpf start+end edge, default = 1
+//Bit  7: 3, reg_mcdi_chkedgesaddstgain.                  distance gain for sad calc while getting edges, default = 4
+//Bit     2, reg_mcdi_chkedgechkmode.                     edge used in check mode, 0: original edge, 1: lpf edge, defautl = 1
+//Bit     1, reg_mcdi_chkedgestartedge.                   edge mode for start edge, 0: original edge, 1: lpf edge, defautl = 0
+//Bit     0, reg_mcdi_chkedgeedgelpf.                     edge lpf mode, 0:[0,2,4,2,0], 1:[1,2,2,2,1], default = 0
+#define MCDI_LMV_RT                                ((0x2f0c  << 2) + 0xd0100000)
+//BIt 31:15, reserved
+//Bit 14:12, reg_mcdi_lmvvalidmode                        valid mode for lmv calc., 100b: use char det, 010b: use flt, 001b: use hori flg
+//Bit 11:10, reg_mcdi_lmvgainmvmode                       four modes of mv selection for lmv weight calucluation, default = 1
+//                                                        0: cur(x-3), lst(x-1,x,x+1); 1: cur(x-4,x-3), lst(x,x+1); 2: cur(x-5,x-4,x-3), lst(x-1,x,x+1,x+2,x+3); 3: cur(x-6,x-5,x-4,x-3), lst(x-1,x,x+1,x+2);
+//Bit  9,    reg_mcdi_lmvinitmode                         initial lmvs at first row of input field, 0: intial value = 0; 1: inital = 32 (invalid), default = 0
+//Bit  8,    reserved
+//Bit  7: 4, reg_mcdi_lmvrt0                              ratio of max mv, default = 5
+//Bit  3: 0, reg_mcdi_lmvrt1                              ratio of second max mv, default = 5
+#define MCDI_LMV_GAINTHD                           ((0x2f0d  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_lmvvxmaxgain                        max gain of lmv weight, default = 96
+//Bit 23,    reserved
+//Bit 22:20, reg_mcdi_lmvdifthd0                          dif threshold 0 (<) for small lmv, default = 1
+//Bit 19:17, reg_mcdi_lmvdifthd1                          dif threshold 1 (<) for median lmv, default = 2
+//Bit 16:14, reg_mcdi_lmvdifthd2                          dif threshold 2 (<) for large lmv, default = 3
+//Bit 13: 8, reg_mcdi_lmvnumlmt                           least/limit number of (total number - max0), default = 20
+//Bit  7: 0, reg_mcdi_lmvfltthd                           flt cnt thd (<) for lmv, default = 9
+#define MCDI_RPTMV_THD0                            ((0x2f0e  << 2) + 0xd0100000)
+//Bit 31:25, reg_mcdi_rptmvslpthd2			  slope thd (>=) between i and i+3/i-3 (i+4/i-4), default = 64
+//Bit 24:20, reg_mcdi_rptmvslpthd1                        slope thd (>=) between i and i+2/i-2, default = 4
+//Bit 19:10, reg_mcdi_rptmvampthd2                        amplitude thd (>=) between max and min, when count cycles, default = 300
+//Bit  9: 0, reg_mcdi_rptmvampthd1                        amplitude thd (>=) between average of max and min, default = 400
+#define MCDI_RPTMV_THD1                            ((0x2f0f  << 2) + 0xd0100000)
+//Bit 31:28, reserved
+//Bit 27:25, reg_mcdi_rptmvcyccntthd                      thd (>=) of total cycles count, default = 2
+//Bit 24:21, reg_mcdi_rptmvcycdifthd                      dif thd (<) of cycles length, default = 3
+//Bit 20:18, reg_mcdi_rptmvcycvldthd                      thd (>) of valid cycles number, default = 1
+//Bit 17:15, reg_mcdi_rptmvhalfcycminthd                  min length thd (>=) of half cycle, default = 2
+//Bit 14:11, reg_mcdi_rptmvhalfcycdifthd                  neighboring half cycle length dif thd (<), default = 5
+//Bit 10: 8, reg_mcdi_rptmvminmaxcntthd                   least number of valid max and min, default = 2
+//Bit  7: 5, reg_mcdi_rptmvcycminthd                      min length thd (>=) of cycles, default = 2
+//Bit  4: 0, reg_mcdi_rptmvcycmaxthd                      max length thd (<) of cycles, default = 17
+#define MCDI_RPTMV_THD2                            ((0x2f10  << 2) + 0xd0100000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_rptmvhdifthd0                       higher hdif thd (>=) (vertical edge) for rpt detection, default = 8
+//Bit 15: 8, reg_mcdi_rptmvhdifthd1                       hdif thd (>=) (slope edge) for rpt detection, default = 4
+//Bit  7: 0, reg_mcdi_rptmvvdifthd                        vdif thd (>=) (slope edge) for rpt detection, default = 1
+#define MCDI_RPTMV_SAD                             ((0x2f11  << 2) + 0xd0100000)
+//Bit 31:26, reserved
+//Bit 25:16, reg_mcdi_rptmvsaddifthdgain                  7x3x(16/16), gain for sad dif thd in rpt mv detection, 0~672, normalized 16 as '1', default = 336
+//Bit 15:10, reserved
+//Bit  9: 0, reg_mcdi_rptmvsaddifthdoffst                 offset for sad dif thd in rpt mv detection, -512~511, default = 16
+#define MCDI_RPTMV_FLG                             ((0x2f12  << 2) + 0xd0100000)
+//Bit 31:18,  reserved                                    
+//Bit 17:16,  reg_mcdi_rptmvmode                          select mode of mvs for repeat motion estimation, 0: hmv, 1: qmv/2, 2 or 3: qmv/4, default = 2
+//Bit 15: 8,  reg_mcdi_rptmvflgcntthd                     thd (>=) of min count number for rptmv of whole field, for rptmv estimation, default = 64
+//Bit  7: 5,  reserved
+//Bit  4: 0,  reg_mcdi_rptmvflgcntrt                      4/32, ratio for repeat mv flag count, normalized 32 as '1', set 31 to 32, 
+#define MCDI_RPTMV_GAIN                            ((0x2f13  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_rptmvlftgain                        up repeat mv gain for hme, default = 96
+//Bit 23:16, reg_mcdi_rptmvuplftgain                      up left repeat mv gain for hme, default = 32
+//Bit 15: 8, reg_mcdi_rptmvupgain                         up repeat mv gain for hme, default = 64
+//Bit  7: 0, reg_mcdi_rptmvuprightgain                    up right repeat mv gain for hme, default = 32
+#define MCDI_GMV_RT                                ((0x2f14  << 2) + 0xd0100000)
+//Bit 31,    reserved
+//Bit 30:24, reg_mcdi_gmvmtnrt0                           ratio 0 for motion senario, set 127 to 128, normalized 128 as '1', default =32
+//Bit 23,    reserved
+//Bit 22:16, reg_mcdi_gmvmtnrt1                           ratio 1 for motion senario, set 127 to 128, normalized 128 as '1', default = 56
+//Bit 15,    reserved
+//Bit 14: 8, reg_mcdi_gmvstlrt0                           ratio 0 for still senario, set 127 to 128, normalized 128 as '1', default = 56
+//Bit  7,    reserved
+//Bit  6: 0, reg_mcdi_gmvstlrt1                           ratio 1 for still senario, set 127 to 128, normalized 128 as '1', default = 80
+#define MCDI_GMV_GAIN                              ((0x2f15  << 2) + 0xd0100000)
+//Bit 31:25, reg_mcdi_gmvzeromvlockrt0                    ratio 0 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 100
+//Bit 24:18, reg_mcdi_gmvzeromvlockrt1                    ratio 1 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 112
+//Bit 17:16, reg_mcdi_gmvvalidmode                        valid mode for gmv calc., 10b: use flt, 01b: use hori flg, default = 3
+//Bit 15: 8, reg_mcdi_gmvvxgain                           gmv's vx gain when gmv locked for hme, default = 0
+//Bit  7: 0, reg_mcdi_gmvfltthd                           flat thd (<) for gmv calc. default = 3
+#define MCDI_HOR_SADOFST                           ((0x2f16  << 2) + 0xd0100000)
+//Bit 31:25, reserved
+//Bit 24:16, reg_mcdi_horsaddifthdgain                    21*1/8, gain/divisor for sad dif threshold in hor line detection, normalized 8 as '1', default = 21
+//Bit 15: 8, reg_mcdi_horsaddifthdoffst                   offset for sad dif threshold in hor line detection, -128~127, default = 0
+//Bit  7: 0, reg_mcdi_horvdifthd                          threshold (>=) of vertical dif of next block for horizontal line detection, default = 24
+#define MCDI_REF_MV_NUM                            ((0x2f17  << 2) + 0xd0100000)
+//Bit 31: 2, reserved
+//Bit  1: 0, reg_mcdi_refmcmode.         motion compensated mode used in refinement, 0: pre, 1: next, 2: (pre+next)/2, default = 0
+#define MCDI_REF_BADW_THD_GAIN                     ((0x2f18  << 2) + 0xd0100000)
+//Bit 31:28, reserved 
+//Bit 27:24, reg_mcdi_refbadwcnt2gain.   gain for badwv count num==3, default = 6
+//Bit 23:20, reg_mcdi_refbadwcnt1gain.   gain for badwv count num==2, default = 3
+//Bit 19:16, reg_mcdi_refbadwcnt0gain.   gain for badwv count num==1, default = 1
+//Bit 15:12, reg_mcdi_refbadwthd3.       threshold 3 for detect badweave with largest average luma, default = 4
+//Bit 11: 8, reg_mcdi_refbadwthd2.       threshold 2 for detect badweave with third smallest average luma, default = 3
+//Bit  7: 4, reg_mcdi_refbadwthd1.       threshold 1 for detect badweave with second smallest average luma, default = 2
+//Bit  3: 0, reg_mcdi_refbadwthd0.       threshold 0 for detect badweave with smallest average luma, default = 1
+#define MCDI_REF_BADW_SUM_GAIN                     ((0x2f19  << 2) + 0xd0100000)
+//Bit 31:13, reserved
+//Bit 12: 8, reg_mcdi_refbadwsumgain0.   sum gain for r channel, 0~16, default = 8
+//Bit  7: 5, reserved
+//Bit     4, reg_mcdi_refbadwcalcmode.   mode for badw calculation, 0:sum, 1:max, default = 0
+//Bit  3: 0, reserved
+#define MCDI_REF_BS_THD_GAIN                       ((0x2f1a  << 2) + 0xd0100000)
+//Bit 31:28, reg_mcdi_refbsudgain1.      up & down block stregth gain1, normalized to 8 as '1', default = 2
+//Bit 27:24, reg_mcdi_refbsudgain0.      up & down block stregth gain0, normalized to 8 as '1', default = 4
+//Bit 23:19, reserved
+//Bit 18:16, reg_mcdi_refbslftgain.      left block strength gain, default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_refbsthd1.         threshold 1 for detect block stregth in refinment, default = 16
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_refbsthd0.         threshold 0 for detect block stregth in refinment, default = 8
+#define MCDI_REF_ERR_GAIN0                         ((0x2f1b  << 2) + 0xd0100000)
+//Bit    31, reserved
+//Bit 30:24, reg_mcdi_referrnbrdstgain.            neighoring mv distances gain for err calc. in ref, normalized to 8 as '1', default = 48
+//Bit 23:20, reserved
+//Bit 19:16, reg_mcdi_referrbsgain.                bs gain for err calc. in ref, normalized to 8 as '1', default = 4
+//Bit    15, reserved
+//Bit 14: 8, reg_mcdi_referrbadwgain.              badw gain for err calc. in ref, normalized to 8 as '1', default = 64
+//Bit  7: 4, reserved
+//Bit  3: 0, reg_mcdi_referrsadgain.               sad gain for err calc. in ref, normalized to 8 as '1', default = 4
+#define MCDI_REF_ERR_GAIN1                         ((0x2f1c  << 2) + 0xd0100000)
+//Bit 31:20, reserved
+//Bit 19:16, reg_mcdi_referrchkedgegain.           check edge gain for err calc. in ref, normalized to 8 as '1', default = 4
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_referrlmvgain.               (locked) lmv gain for err calc. in ref, normalized to 8 as '1', default = 0
+//Bit  7: 4, reserved
+//Bit  3: 0, reg_mcdi_referrgmvgain.               (locked) gmv gain for err calc. in ref, normalized to 8 as '1', default = 0
+#define MCDI_REF_ERR_FRQ_CHK                       ((0x2f1d  << 2) + 0xd0100000)
+//Bit 31:28, reserved
+//Bit 27:24, reg_mcdi_referrfrqgain.               gain for mv frquency, normalized to 4 as '1', default = 10
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_referrfrqmax.                max gain for mv frquency check, default = 31
+//Bit    15, reserved
+//Bit 14:12, reg_mcdi_ref_errfrqmvdifthd2.         mv dif threshold 2 (<) for mv frquency check, default = 3
+//Bit    11, reserved
+//Bit 10: 8, reg_mcdi_ref_errfrqmvdifthd1.         mv dif threshold 1 (<) for mv frquency check, default = 2
+//Bit     7, reserved
+//Bit  6: 4, reg_mcdi_ref_errfrqmvdifthd0.         mv dif threshold 0 (<) for mv frquency check, default = 1
+//Bit  3: 0, reserved
+#define MCDI_QME_LPF_MSK                           ((0x2f1e  << 2) + 0xd0100000)
+//Bit 31:28, reserved
+//Bit 27:24, reg_mcdi_qmechkedgelpfmsk0.           lpf mask0 for chk edge in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
+//Bit 23:20, reserved
+//Bit 19:16, reg_mcdi_qmebslpfmsk0.                lpf mask0 for bs in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_qmebadwlpfmsk0.              lpf mask0 for badw in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
+//Bit  7: 4, reserved
+//Bit  3: 0, reg_mcdi_qmesadlpfmsk0.               lpf mask0 for sad in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
+#define MCDI_REL_DIF_THD_02                        ((0x2f1f  << 2) + 0xd0100000)
+//Bit 31:24, reserved.
+//Bit 23:16, reg_mcdi_reldifthd2.                  thd (<) for (hdif+vdif), default = 9
+//Bit 15: 8, reg_mcdi_reldifthd1.                  thd (<) for (vdif), default = 5
+//Bit  7: 0, reg_mcdi_reldifthd0.                  thd (>=) for (hdif-vdif), default = 48
+#define MCDI_REL_DIF_THD_34                        ((0x2f20  << 2) + 0xd0100000)
+//Bit 31:16, reserved.
+//Bit 15: 8, reg_mcdi_reldifthd4.                  thd (<) for (hdif), default = 255
+//Bit  7: 0, reg_mcdi_reldifthd3.                  thd (>=) for (vdif-hdif), default = 48
+#define MCDI_REL_BADW_GAIN_OFFST_01                ((0x2f21  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_relbadwoffst1.               offset for badw adj, for flat block, -128~127, default = 0
+//Bit 23:16, reg_mcdi_relbadwgain1.                gain for badw adj, for flat block, default = 128
+//Bit 15: 8, reg_mcdi_relbadwoffst0.               offset for badw adj, for vertical block, -128~127, default = 0
+//Bit  7: 0, reg_mcdi_relbadwgain0.                gain for badw adj, for vertical block, default = 160
+#define MCDI_REL_BADW_GAIN_OFFST_23                ((0x2f22  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_relbadwoffst3.               offset for badw adj, for other block, -128~127, default = 0
+//Bit 23:16, reg_mcdi_relbadwgain3.                gain for badw adj, for other block, default = 48
+//Bit 15: 8, reg_mcdi_relbadwoffst2.               offset for badw adj, for horizontal block, -128~127, default = 0
+//Bit  7: 0, reg_mcdi_relbadwgain2.                gain for badw adj, for horizontal block, default = 48
+#define MCDI_REL_BADW_THD_GAIN_OFFST               ((0x2f23  << 2) + 0xd0100000)
+//Bit 31:23, reserved.
+//Bit 22:16, reg_mcdi_relbadwoffst.                offset for badw thd adj, -64~63, default = 0
+//Bit 15: 8, reserved.
+//Bit  7: 0, reg_mcdi_relbadwthdgain.              gain0 for badw thd adj, normalized to 16 as '1', default = 16
+#define MCDI_REL_BADW_THD_MIN_MAX                  ((0x2f24  << 2) + 0xd0100000)
+//Bit 31:18, reserved.
+//Bit 17: 8, reg_mcdi_relbadwthdmax.               max for badw thd adj, default = 256
+//Bit  7: 0, reg_mcdi_relbadwthdmin.               min for badw thd adj, default = 16
+#define MCDI_REL_SAD_GAIN_OFFST_01                 ((0x2f25  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_relsadoffst1.                offset for sad adj, for flat block, -128~127, default = 0
+//Bit 23:20, reserved.
+//Bit 19:16, reg_mcdi_relsadgain1.                 gain for sad adj, for flat block, normalized to 8 as '1', default = 8
+//Bit 15: 8, reg_mcdi_relsadoffst0.                offset for sad adj, for vertical block, -128~127, default = 0
+//Bit  7: 4, reserved.
+//Bit  3: 0, reg_mcdi_relsadgain0.                 gain for sad adj, for vertical block, normalized to 8 as '1', default = 6
+#define MCDI_REL_SAD_GAIN_OFFST_23                 ((0x2f26  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_relsadoffst3.                offset for sad adj, for other block, -128~127, default = 0
+//Bit 23:20, reserved.
+//Bit 19:16, reg_mcdi_relsadgain3.                 gain for sad adj, for other block, normalized to 8 as '1', default = 8
+//Bit 15: 8, reg_mcdi_relsadoffst2.                offset for sad adj, for horizontal block, -128~127, default = 0
+//Bit  7: 4, reserved.
+//Bit  3: 0, reg_mcdi_relsadgain2.                 gain for sad adj, for horizontal block, normalized to 8 as '1', default = 12
+#define MCDI_REL_SAD_THD_GAIN_OFFST                ((0x2f27  << 2) + 0xd0100000)
+//Bit 31:24, reserved.
+//Bit 23:16, reg_mcdi_relsadoffst.                 offset for sad thd adj, -128~127, default = 0
+//Bit 15:10, reserved.
+//Bit  9: 0, reg_mcdi_relsadthdgain.               gain for sad thd adj, 21*2/16, normalized to 16 as '1', default = 42
+#define MCDI_REL_SAD_THD_MIN_MAX                   ((0x2f28  << 2) + 0xd0100000)
+//Bit 31:27, reserved.
+//Bit 26:16, reg_mcdi_relsadthdmax.                max for sad thd adj, 21*32, default = 672
+//Bit 15: 9, reserved.
+//Bit  8: 0, reg_mcdi_relsadthdmin.                min for sad thd adj, 21*2, default = 42
+#define MCDI_REL_DET_GAIN_00                       ((0x2f29  << 2) + 0xd0100000)
+//Bit 31:21, reserved.
+//Bit 20:16, reg_mcdi_reldetbsgain0.               gain0 (gmv locked) for bs, for det. calc. normalized to 16 as '1', default = 8
+//Bit 15:14, reserved.
+//Bit 13: 8, reg_mcdi_reldetbadwgain0.             gain0 (gmv locked) for badw, for det. calc. normalized to 16 as '1', default = 12
+//Bit  7: 5, reserved.
+//Bit  4: 0, reg_mcdi_reldetsadgain0.              gain0 (gmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
+#define MCDI_REL_DET_GAIN_01                       ((0x2f2a  << 2) + 0xd0100000)
+//Bit 31:14, reserved.
+//Bit 12: 8, reg_mcdi_reldetchkedgegain0.          gain0 (gmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 2
+//Bit     7, reserved.
+//Bit  6: 0, reg_mcdi_reldetnbrdstgain0.           gain0 (gmv locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 24
+#define MCDI_REL_DET_GAIN_10                       ((0x2f2b  << 2) + 0xd0100000)
+//Bit 31:21, reserved.
+//Bit 20:16, reg_mcdi_reldetbsgain1.               gain1 (lmv locked) for bs, for det. calc. normalized to 16 as '1', default = 0
+//Bit 15:14, reserved.
+//Bit 13: 8, reg_mcdi_reldetbadwgain1.             gain1 (lmv locked) for badw, for det. calc. normalized to 16 as '1', default = 8
+//Bit  7: 5, reserved.
+//Bit  4: 0, reg_mcdi_reldetsadgain1.              gain1 (lmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
+#define MCDI_REL_DET_GAIN_11                       ((0x2f2c  << 2) + 0xd0100000)
+//Bit 31:14, reserved.
+//Bit 12: 8, reg_mcdi_reldetchkedgegain1.          gain1 (lmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 0
+//Bit     7, reserved.
+//Bit  6: 0, reg_mcdi_reldetnbrdstgain1.           gain1 (lmv locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 24
+#define MCDI_REL_DET_GAIN_20                       ((0x2f2d  << 2) + 0xd0100000)
+//Bit 31:21, reserved.
+//Bit 20:16, reg_mcdi_reldetbsgain2.               gain2 (no locked) for bs, for det. calc. normalized to 16 as '1', default = 12
+//Bit 15:14, reserved.
+//Bit 13: 8, reg_mcdi_reldetbadwgain2.             gain2 (no locked) for badw, for det. calc. normalized to 16 as '1', default = 32
+//Bit  7: 5, reserved.
+//Bit  4: 0, reg_mcdi_reldetsadgain2.              gain2 (no locked) for qsad, for det. calc. normalized to 16 as '1', default = 16
+#define MCDI_REL_DET_GAIN_21                       ((0x2f2e  << 2) + 0xd0100000)
+//Bit 31:26, reserved
+//Bit 25:16, reg_mcdi_reldetoffst.                 offset for rel calculation, for det. calc. -512~511,  default = 0
+//Bit 15:14, reserved.
+//Bit 12: 8, reg_mcdi_reldetchkedgegain2.          gain2 (no locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 10
+//Bit     7, reserved.
+//Bit  6: 0, reg_mcdi_reldetnbrdstgain2.           gain2 (no locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 32
+#define MCDI_REL_DET_GMV_DIF_CHK                   ((0x2f2f  << 2) + 0xd0100000)
+//Bit 31:24, reserved.
+//Bit 23:16, reg_mcdi_reldetgmvfltthd.             flat thd (>=) for gmv lock decision, default = 0
+//Bit    15, reserved.
+//Bit 14:12, reg_mcdi_reldetgmvdifthd.             dif thd (>=) for current mv different from gmv for gmv dif check, actually used in Lmv lock check, default = 3
+//Bit    11, reserved.
+//Bit 10: 8, reg_mcdi_reldetgmvdifmin.             min mv dif for gmv dif check, default = 1, note: dif between reg_mcdi_rel_det_gmv_dif_max and reg_mcdi_rel_det_gmv_dif_min should be; 0,1,3,7, not work for others 
+//Bit  7: 4, reg_mcdi_reldetgmvdifmax.             max mv dif for gmv dif check, default = 4
+//Bit  3: 1, reserved
+//Bit     0, reg_mcdi_reldetgmvdifmvmode.          mv mode used for gmv dif check, 0: use refmv, 1: use qmv, default = 0
+#define MCDI_REL_DET_LMV_DIF_CHK                   ((0x2f30  << 2) + 0xd0100000)
+//Bit 31:24, reserved.
+//Bit 23:16, reg_mcdi_reldetlmvfltthd.             flat thd (>=) for lmv lock decision, default = 12
+//Bit 15:14, reserved.
+//Bit 13:12, reg_mcdi_reldetlmvlockchkmode.        lmv lock check mode, 0:cur Lmv, 1: cur & (last | next), 2: last & cur & next Lmv, default = 1
+//Bit    11, reserved.
+//Bit 10: 8, reg_mcdi_reldetlmvdifmin.             min mv dif for lmv dif check, default = 1, note: dif between reg_mcdi_rel_det_lmv_dif_max and reg_mcdi_rel_det_lmv_dif_min should be; 0,1,3,7, not work for others 
+//Bit  7: 4, reg_mcdi_reldetlmvdifmax.             max mv dif for lmv dif check, default = 4
+//Bit  3: 1, reserved
+//Bit     0, reg_mcdi_reldetlmvdifmvmode.          mv mode used for lmv dif check, 0: use refmv, 1: use qmv, default = 0
+#define MCDI_REL_DET_FRQ_CHK                       ((0x2f31  << 2) + 0xd0100000)
+//Bit 31:12, reserved.
+//Bit 11: 8, reg_mcdi_reldetfrqgain.               gain for frequency check, normalized to 4 as '1', default = 10
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetfrqmax.                max value for frequency check, default = 31
+#define MCDI_REL_DET_PD22_CHK                      ((0x2f32  << 2) + 0xd0100000)
+//Bit 31:18, reserved.
+//Bit 17: 8, reg_mcdi_reldetpd22chkoffst.          offset for pd22 check happened, default = 512
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetpd22chkgain.           gain for pd22 check happened, normalized to 8 as '1', default = 12
+#define MCDI_REL_DET_RPT_CHK_ROW                   ((0x2f33  << 2) + 0xd0100000)
+//Bit 31:27, reserved
+//Bit 26:16, reg_mcdi_reldetrptchkendrow.          end row (<) number for repeat check, default = 2047
+//Bit 15:11, reserved
+//Bit 10: 0, reg_mcdi_reldetrptchkstartrow.        start row (>=) number for repeat check, default = 0
+#define MCDI_REL_DET_RPT_CHK_GAIN_QMV              ((0x2f34  << 2) + 0xd0100000)
+//Bit 31:30, reserved
+//Bit 29:24, reg_mcdi_reldetrptchkqmvmax.          max thd (<) of abs qmv for repeat check, default = 15, note that quarter mv's range is -63~63
+//Bit 23:22, reserved
+//Bit 21:16, reg_mcdi_reldetrptchkqmvmin.          min thd (>=) of abs qmv for repeat check, default = 10, note that quarter mv's range is -63~63
+//Bit    15, reserved/
+//Bit 14: 4, reg_mcdi_reldetrptchkoffst.           offset for repeat check, default = 512
+//Bit  3: 0, reg_mcdi_reldetrptchkgain.            gain for repeat check, normalized to 8 as '1', default = 4
+#define MCDI_REL_DET_RPT_CHK_THD_0                 ((0x2f35  << 2) + 0xd0100000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_reldetrptchkzerosadthd.      zero sad thd (<) for repeat check, default = 255
+//Bit 15:14, reserved.
+//Bit 13: 8, reg_mcdi_reldetrptchkzerobadwthd.     zero badw thd (>=) for repeat check, default = 16
+//Bit  7: 4, reserved
+//Bit  3: 0, reg_mcdi_reldetrptchkfrqdifthd.       frequency dif thd (<) for repeat check, 0~10, default = 5
+#define MCDI_REL_DET_RPT_CHK_THD_1                 ((0x2f36  << 2) + 0xd0100000)
+//Bit 31:16, reserved
+//Bit 15: 8, reg_mcdi_reldetrptchkvdifthd.         vertical dif thd (<) for repeat check, default = 16
+//Bit  7: 0, reg_mcdi_reldetrptchkhdifthd.         horizontal dif thd (>=) for repeat check, default = 16
+#define MCDI_REL_DET_LPF_DIF_THD                   ((0x2f37  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_reldetlpfdifthd3.            hdif thd (<) for lpf selection of horizontal block, default = 9
+//Bit 23:16, reg_mcdi_reldetlpfdifthd2.            vdif-hdif thd (>=) for lpf selection of horizontal block, default = 48
+//Bit 15: 8, reg_mcdi_reldetlpfdifthd1.            vdif thd (<) for lpf selection of vertical block, default = 9
+//Bit  7: 0, reg_mcdi_reldetlpfdifthd0.            hdif-vdif thd (>=) for lpf selection of vertical block, default = 48
+#define MCDI_REL_DET_LPF_MSK_00_03                 ((0x2f38  << 2) + 0xd0100000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk03.              det lpf mask03 for gmv/lmv locked mode, 0~16, default = 1
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk02.              det lpf mask02 for gmv/lmv locked mode, 0~16, default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk01.              det lpf mask01 for gmv/lmv locked mode, 0~16, default = 5
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk00.              det lpf mask00 for gmv/lmv locked mode, 0~16, default = 8
+#define MCDI_REL_DET_LPF_MSK_04_12                 ((0x2f39  << 2) + 0xd0100000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk12.              det lpf mask12 for vertical blocks, 0~16, default = 0
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk11.              det lpf mask11 for vertical blocks, 0~16, default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk10.              det lpf mask10 for vertical blocks, 0~16, default = 16
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk04.              det lpf mask04 for gmv/lmv locked mode, 0~16, default = 1
+#define MCDI_REL_DET_LPF_MSK_13_21                 ((0x2f3a  << 2) + 0xd0100000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk21.              det lpf mask21 for horizontal blocks, 0~16, default = 6
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk20.              det lpf mask20 for horizontal blocks, 0~16, default = 8
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk14.              det lpf mask14 for vertical blocks, 0~16, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk13.              det lpf mask13 for vertical blocks, 0~16, default = 0
+#define MCDI_REL_DET_LPF_MSK_22_30                 ((0x2f3b  << 2) + 0xd0100000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk30.              det lpf mask30 for other blocks, 0~16, default = 16
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk24.              det lpf mask24 for horizontal blocks, 0~16, default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk23.              det lpf mask23 for horizontal blocks, 0~16, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk22.              det lpf mask22 for horizontal blocks, 0~16, default = 1
+#define MCDI_REL_DET_LPF_MSK_31_34                 ((0x2f3c  << 2) + 0xd0100000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_reldetlpfmsk34.              det lpf mask34 for other blocks, 0~16, default = 0
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_reldetlpfmsk33.              det lpf mask33 for other blocks, 0~16, default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_reldetlpfmsk32.              det lpf mask32 for other blocks, 0~16, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_reldetlpfmsk31.              det lpf mask31 for other blocks, 0~16, default = 0
+//Note: there are four group lpf masks from addr 37~3b, each group sum equal to 16.
+#define MCDI_REL_DET_MIN                           ((0x2f3d  << 2) + 0xd0100000)
+//Bit 31: 7, reserved
+//Bit  6: 0, reg_mcdi_reldetmin.                   min of detected value, default = 16
+#define MCDI_REL_DET_LUT_0_3                       ((0x2f3e  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_reldetmaplut3.               default = 8
+//Bit 23:16, reg_mcdi_reldetmaplut2.               default = 4
+//Bit 15: 8, reg_mcdi_reldetmaplut1.               default = 2
+//Bit  7: 0, reg_mcdi_reldetmaplut0.               default = 0
+#define MCDI_REL_DET_LUT_4_7                       ((0x2f3f  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_reldetmaplut7.               default = 64
+//Bit 23:16, reg_mcdi_reldetmaplut6.               default = 48
+//Bit 15: 8, reg_mcdi_reldetmaplut5.               default = 32
+//Bit  7: 0, reg_mcdi_reldetmaplut4.               default = 16
+#define MCDI_REL_DET_LUT_8_11                      ((0x2f40  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_reldetmaplut11.              default = 160
+//Bit 23:16, reg_mcdi_reldetmaplut10.              default = 128
+//Bit 15: 8, reg_mcdi_reldetmaplut9.               default = 96
+//Bit  7: 0, reg_mcdi_reldetmaplut8.               default = 80
+#define MCDI_REL_DET_LUT_12_15                     ((0x2f41  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_reldetmaplut15.              default = 255
+//Bit 23:16, reg_mcdi_reldetmaplut14.              default = 240
+//Bit 15: 8, reg_mcdi_reldetmaplut13.              default = 224
+//Bit  7: 0, reg_mcdi_reldetmaplut12.              default = 192
+#define MCDI_REL_DET_COL_CFD_THD                   ((0x2f42  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_reldetcolcfdfltthd.          thd for flat smaller than (<) of column cofidence, default = 5
+//Bit 23:16, reg_mcdi_reldetcolcfdthd1.            thd for rel larger than (>=) in rel calc. mode col confidence without gmv locking, default = 160
+//Bit 15: 8, reg_mcdi_reldetcolcfdthd0.            thd for rel larger than (>=) in rel calc. mode col confidence when gmv locked, default = 100
+//Bit  7: 2, reg_mcdi_reldetcolcfdbadwthd.         thd for badw larger than (>=) in qbadw calc. mode of column cofidence, default = 16
+//Bit     1, reserved
+//Bit     0, reg_mcdi_reldetcolcfdcalcmode.        calc. mode for column cofidence, 0: use rel, 1: use qbadw, default = 0
+#define MCDI_REL_DET_COL_CFD_AVG_LUMA              ((0x2f43  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_reldetcolcfdavgmin1.         avg luma min1 (>=) for column cofidence, valid between 16~235, default = 235
+//Bit 23:16, reg_mcdi_reldetcolcfdavgmax1.         avg luma max1 (<)  for column cofidence, valid between 16~235, default = 235
+//Bit 15: 8, reg_mcdi_reldetcolcfdavgmin0.         avg luma min0 (>=) for column cofidence, valid between 16~235, default = 16
+//Bit  7: 0, reg_mcdi_reldetcolcfdavgmax0.         avg luma max0 (<)  for column cofidence, valid between 16~235, default = 21
+#define MCDI_REL_DET_BAD_THD_0                     ((0x2f44  << 2) + 0xd0100000)
+//Bit 31:16, reserved
+//Bit 15: 8, reg_mcdi_reldetbadsadthd.             thd (>=) for bad sad, default = 120 (480/4)
+//Bit  7: 6, reserved
+//Bit  5: 0, reg_mcdi_reldetbadbadwthd.            thd (>=) for bad badw, 0~42, default = 12
+#define MCDI_REL_DET_BAD_THD_1                     ((0x2f45  << 2) + 0xd0100000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_reldetbadrelfltthd.          thd (>=) of flat for bad rel detection, default = 4
+//Bit 15: 8, reg_mcdi_reldetbadrelthd1.            thd (>=) for bad rel without gmv/lmv locked, default = 160
+//Bit  7: 0, reg_mcdi_reldetbadrelthd0.            thd (>=) for bad rel with gmv/lmv locked, default = 120
+#define MCDI_PD22_CHK_THD                          ((0x2f46  << 2) + 0xd0100000)
+//Bit 31:25, reserved
+//Bit 24:16, reg_mcdi_pd22chksaddifthd.            sad dif thd (>=) for (pd22chksad - qsad) for pd22 check, default = 64
+//Bit 15:14, reserved
+//Bit 13: 8, reg_mcdi_pd22chkqmvthd.               thd (>=) of abs qmv for pd22 check, default = 2
+//Bit  7: 0, reg_mcdi_pd22chkfltthd.               thd (>=) of flat for pd22 check, default = 4
+#define MCDI_PD22_CHK_GAIN_OFFST_0                 ((0x2f47  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_pd22chkedgeoffst0.           offset0 of pd22chkedge from right film22 phase, -128~127, default = 0
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_pd22chkedgegain0.            gain0 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_pd22chkbadwoffst0.           offset0 of pd22chkbadw from right film22 phase, -8~7, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_pd22chkbadwgain0.            gain0 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 8
+#define MCDI_PD22_CHK_GAIN_OFFST_1                 ((0x2f48  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_pd22chkedgeoffst1.           offset1 of pd22chkedge from right film22 phase, -128~127, default = 0
+//Bit 23:21, reserved
+//Bit 20:16, reg_mcdi_pd22chkedgegain1.            gain1 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_pd22chkbadwoffst1.           offset1 of pd22chkbadw from right film22 phase, -8~7, default = 0
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_pd22chkbadwgain1.            gain1 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 12
+#define MCDI_LMV_LOCK_CNT_THD_GAIN                 ((0x2f49  << 2) + 0xd0100000)
+//Bit 31:20, reserved
+//Bit 19:16, reg_mcdi_lmvlockcntmax.               max lmv lock count number, default = 6
+//Bit 15:12, reg_mcdi_lmvlockcntoffst.             offset for lmv lock count, -8~7, default =  0
+//Bit 11: 8, reg_mcdi_lmvlockcntgain.              gain for lmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_lmvlockcntthd.               lmv count thd (>=) before be locked, 1~31, default = 4 
+#define MCDI_LMV_LOCK_ABS_DIF_THD                  ((0x2f4a  << 2) + 0xd0100000)
+//Bit 31:27, reserved
+//Bit 26:24, reg_mcdi_lmvlockdifthd2.              lmv dif thd for third part, before locked, default = 1
+//Bit    23, reserved
+//Bit 22:20, reg_mcdi_lmvlockdifthd1.              lmv dif thd for second part, before locked, default = 1
+//Bit    19, reserved
+//Bit 18:16, reg_mcdi_lmvlockdifthd0.              lmv dif thd for first part, before locked, default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_lmvlockabsmax.               max abs (<) of lmv to be locked, default = 24 
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_lmvlockabsmin.               min abs (>=) of lmv to be locked, default = 1 
+#define MCDI_LMV_LOCK_ROW                          ((0x2f4b  << 2) + 0xd0100000)
+//Bit 31:27, reserved
+//Bit 26:16, reg_mcdi_lmvlockendrow.               end row (<) for lmv lock, default = 2047
+//Bit 15:11, reserved
+//Bit 10: 0, reg_mcdi_lmvlockstartrow.             start row (>=) for lmv lock, default = 0
+#define MCDI_LMV_LOCK_RT_MODE                      ((0x2f4c  << 2) + 0xd0100000)
+//Bit 31:27, reserved
+//Bit 26:24, reg_mcdi_lmvlockextmode.              extend lines for lmv lock check, check how many lines for lmv locking, default = 2
+//Bit 23:16, reg_mcdi_lmvlockfltcntrt.             ratio of flt cnt for lock check, normalized 256 as '1', 255 is set to 256, default = 32
+//Bit 15: 8, reg_mcdi_lmvlocklmvcntrt1.            ratio when use non-zero lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 48
+//Bit  7: 0, reg_mcdi_lmvlocklmvcntrt0.            ratio when use max lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 106
+#define MCDI_GMV_LOCK_CNT_THD_GAIN                 ((0x2f4d  << 2) + 0xd0100000)
+//Bit 31:20, reserved
+//Bit 19:16, reg_mcdi_gmvlockcntmax.               max gmv lock count number, default = 6
+//Bit 15:12, reg_mcdi_gmvlockcntoffst.             offset for gmv lock count, -8~7, default =  0
+//Bit 11: 8, reg_mcdi_gmvlockcntgain.              gain for gmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_gmvlockcntthd.               gmv count thd (>=) before be locked, 1~31, default = 4 
+#define MCDI_GMV_LOCK_ABS_DIF_THD                  ((0x2f4e  << 2) + 0xd0100000)
+//Bit 31:27, reserved
+//Bit 26:24, reg_mcdi_gmvlockdifthd2.              gmv dif thd for third part, before locked, default = 3
+//Bit    23, reserved
+//Bit 22:20, reg_mcdi_gmvlockdifthd1.              gmv dif thd for second part, before locked, default = 2
+//Bit    19, reserved
+//Bit 18:16, reg_mcdi_gmvlockdifthd0.              gmv dif thd for first part, before locked, default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_gmvlockabsmax.               max abs of gmv to be locked, default = 15 
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_gmvlockabsmin.               min abs of gmv to be locked, default = 1 
+#define MCDI_HIGH_VERT_FRQ_DIF_THD                 ((0x2f4f  << 2) + 0xd0100000)
+//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifthd.     high_vert_frq field average luma dif thd (>=), 3*Blk_Width*Blk_Height, set by software, default = 103680
+#define MCDI_HIGH_VERT_FRQ_DIF_DIF_THD             ((0x2f50  << 2) + 0xd0100000)
+//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifdifthd.  high_vert_frq field average luma dif's dif thd (<), 3*Blk_Width*Blk_Height, set by software, default = 103680
+#define MCDI_HIGH_VERT_FRQ_RT_GAIN                 ((0x2f51  << 2) + 0xd0100000)
+//Bit 31:20, reserved
+//Bit 19:16, reg_mcdi_highvertfrqcntthd.           high_vert_frq count thd (>=) before locked, 1~31, default = 4
+//Bit 15: 8, reg_mcdi_highvertfrqbadsadrt.         ratio for high_vert_frq bad sad count, normalized 256 as '1', 255 is set to 256, default = 24
+//Bit  7: 0, reg_mcdi_highvertfrqbadbadwrt.        ratio for high_vert_frq badw count, normalized 256 as '1', 255 is set to 256, default = 130
+#define MCDI_MOTION_PARADOX_THD                    ((0x2f52  << 2) + 0xd0100000)
+//Bit 31:29, reserved
+//Bit 28:24, reg_mcdi_motionparadoxcntthd.         motion paradox count thd (>=) before locked, 1~31, default = 4
+//Bit 23:22, reserved
+//Bit 21:16, reg_mcdi_motionparadoxgmvthd.         abs gmv thd (<) of motion paradox, 0~32, note that 32 means invalid gmv, be careful, default = 32 
+//Bit 15: 0, reserved
+#define MCDI_MOTION_PARADOX_RT                     ((0x2f53  << 2) + 0xd0100000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_motionparadoxbadsadrt.       ratio for field bad sad count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 24
+//Bit 15: 8, reg_mcdi_motionparadoxbadrelrt.       ratio for field bad reliabilty count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 120
+//Bit  7: 0, reg_mcdi_motionparadoxmtnrt.          ratio for field motion count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 218
+#define MCDI_MOTION_REF_THD                        ((0x2f54  << 2) + 0xd0100000)
+//Bit 31:24, reserved
+//Bit 23:20, reg_mcdi_motionrefoffst.              motion ref additive offset, default = 15
+//Bit 19:16, reg_mcdi_motionrefgain.               motion ref gain, normalized 8 as '1', default = 8
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_motionrefrptmvthd.           abs thd (>=) of rpt mv (0~31, 32 means invalid) for motion ref, default = 1
+//Bit  7: 2, reg_mcdi_motionrefqmvthd.             min thd (>=) of abs qmv for motion ref, note that quarter mv's range is -63~63, default = 2
+//Bit  1: 0, reg_mcdi_motionreflpfmode.            Mv and (8 x repeat flg) 's lpf mode of motion refinement, 0: no lpf, 1: [1 2 1], 2: [1 2 2 2 1], default = 1
+#define MCDI_REL_COL_REF_RT                        ((0x2f55  << 2) + 0xd0100000)
+//Bit 31: 8, reserved
+//Bit  7: 0, reg_mcdi_relcolrefrt.                 ratio for column cofidence level against column number, for refinement, default = 135
+#define MCDI_PD22_CHK_THD_RT                       ((0x2f56  << 2) + 0xd0100000)
+//Bit 31:27, reserved
+//Bit 26:16, reg_mcdi_pd22chkfltcntrt.             ratio for flat count of field pulldown 22 check, normalized 2048 as '1', 2047 is set to 2048, default = 1
+//Bit 15: 8, reg_mcdi_pd22chkcntrt.                ratio of pulldown 22 check count, normalized 256 as '1', 255 is set to 256, default = 100
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_pd22chkcntthd.               thd (>=) for pd22 count before locked, 1~31, default = 4
+#define MCDI_CHAR_DET_DIF_THD                      ((0x2f57  << 2) + 0xd0100000)
+//Bit 31:24, reserved
+//Bit 23:16, reg_mcdi_chardetminmaxdifthd.         thd (>=) for dif between min and max value, default = 64
+//Bit 15: 8, reg_mcdi_chardetmaxdifthd.            thd (<) for dif between max value, default = 17
+//Bit  7: 0, reg_mcdi_chardetmindifthd.            thd (<) for dif between min value, default = 17
+#define MCDI_CHAR_DET_CNT_THD                      ((0x2f58  << 2) + 0xd0100000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_chardettotcntthd.            thd (>=) for total count, 0~21, default = 18
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_chardetmaxcntthd.            thd (>=) for max count, 0~21, default = 1
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_chardetmincntthd.            thd (>=) for min count, 0~21, default = 1
+#define MCDI_FIELD_MV                              ((0x2f60  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_pd22chkcnt                   
+//Bit 23:16, reg_mcdi_fieldgmvcnt
+//Bit    15, reg_mcdi_pd22chkflg
+//Bit    14, reg_mcdi_fieldgmvlock
+//Bit 13: 8, reg_mcdi_fieldrptmv.    	           last field rpt mv 
+//Bit  7: 6, reserved
+//Bit  5: 0, reg_mcdi_fieldgmv.                    last field gmv 
+#define MCDI_FIELD_HVF_PRDX_CNT                    ((0x2f61  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_motionparadoxcnt.
+//Bit 23:17, reserved
+//Bit    16, reg_mcdi_motionparadoxflg.
+//Bit 15: 8, reg_mcdi_highvertfrqcnt.    
+//Bit  7: 4, reserved	          
+//Bit  3: 2, reg_mcdi_highvertfrqphase.
+//Bit     1, reserved
+//Bit     0, reg_mcdi_highvertfrqflg.              
+#define MCDI_FIELD_LUMA_AVG_SUM_0                  ((0x2f62  << 2) + 0xd0100000)
+//Bit 31: 0, reg_mcdi_fld_luma_avg_sum0.           
+#define MCDI_FIELD_LUMA_AVG_SUM_1                  ((0x2f63  << 2) + 0xd0100000)
+//Bit 31: 0, reg_mcdi_fld_luma_avg_sum1.
+#define MCDI_YCBCR_BLEND_CRTL                      ((0x2f64  << 2) + 0xd0100000)
+//Bit 31:16, reserved
+//Bit 15: 8, reg_mcdi_ycbcrblendgain.              ycbcr blending gain for cbcr in ycbcr. default = 0
+//Bit  7: 2, reserved.
+//Bit  1: 0, reg_mcdi_ycbcrblendmode.              0:y+cmb(cb,cr), 1:med(r,g,b), 2:max(r,g,b), default = 2              
+#define MCDI_MCVECWR_CANVAS_SIZE                   ((0x2f65  << 2) + 0xd0100000)
+#define MCDI_MCVECRD_CANVAS_SIZE                   ((0x2f66  << 2) + 0xd0100000)
+#define MCDI_MCINFOWR_CANVAS_SIZE                  ((0x2f67  << 2) + 0xd0100000)
+#define MCDI_MCINFORD_CANVAS_SIZE                  ((0x2f68  << 2) + 0xd0100000)
+#define MCDI_MCVECWR_X                             ((0x2f92  << 2) + 0xd0100000)
+#define MCDI_MCVECWR_Y                             ((0x2f93  << 2) + 0xd0100000)
+#define MCDI_MCVECWR_CTRL                          ((0x2f94  << 2) + 0xd0100000)
+#define MCDI_MCVECRD_X                             ((0x2f95  << 2) + 0xd0100000)
+#define MCDI_MCVECRD_Y                             ((0x2f96  << 2) + 0xd0100000)
+#define MCDI_MCVECRD_CTRL                          ((0x2f97  << 2) + 0xd0100000)
+#define MCDI_MCINFOWR_X                            ((0x2f98  << 2) + 0xd0100000)
+#define MCDI_MCINFOWR_Y                            ((0x2f99  << 2) + 0xd0100000)
+#define MCDI_MCINFOWR_CTRL                         ((0x2f9a  << 2) + 0xd0100000)
+#define MCDI_MCINFORD_X                            ((0x2f9b  << 2) + 0xd0100000)
+#define MCDI_MCINFORD_Y                            ((0x2f9c  << 2) + 0xd0100000)
+#define MCDI_MCINFORD_CTRL                         ((0x2f9d  << 2) + 0xd0100000)
+// ================================================================== MC registers ========================================================================================================
+#define MCDI_MC_CRTL                               ((0x2f70  << 2) + 0xd0100000)
+//Bit 31: 9, reserved
+//Bit     8, reg_mcdi_mcpreflg.                    flag to use previous field for MC, 0:forward field, 1: previous field, default = 1 
+//Bit     7, reg_mcdi_mcrelrefbycolcfden.          enable rel refinement by column cofidence in mc blending, default = 1
+//Bit  6: 5, reg_mcdi_mclpfen.                     enable mc pixles/rel lpf, 0:disable, 1: lpf rel, 2: lpf mc pxls, 3: lpf both rel and mc pxls, default = 0
+//Bit  4: 2, reg_mcdi_mcdebugmode.                 enable mc debug mode, 0:disable, 1: split left/right, 2: split top/bottom, 3: debug mv, 4: debug rel, default = 0
+//Bit  1: 0, reg_mcdi_mcen.                        mcdi enable mode, 0:disable, 1: blend with ma, 2: full mc, default = 1
+#define MCDI_MC_LPF_MSK_0                          ((0x2f71  << 2) + 0xd0100000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk02.                  mc lpf coef. 2 for pixel 0 of current block, normalized 16 as '1', default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk01.                  mc lpf coef. 1 for pixel 0 of current block, normalized 16 as '1', default = 9
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk00.                  mc lpf coef. 0 for pixel 0 of current block, normalized 16 as '1', default = 7
+#define MCDI_MC_LPF_MSK_1                          ((0x2f72  << 2) + 0xd0100000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk12.                  mc lpf coef. 2 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 0
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk11.                  mc lpf coef. 1 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 11
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk10.                  mc lpf coef. 0 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 5
+#define MCDI_MC_LPF_MSK_2                          ((0x2f73  << 2) + 0xd0100000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk22.                  mc lpf coef. 2 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk21.                  mc lpf coef. 1 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 14
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk20.                  mc lpf coef. 0 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
+#define MCDI_MC_LPF_MSK_3                          ((0x2f74  << 2) + 0xd0100000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk32.                  mc lpf coef. 2 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 5
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk31.                  mc lpf coef. 1 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 11
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk30.                  mc lpf coef. 0 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 0
+#define MCDI_MC_LPF_MSK_4                          ((0x2f75  << 2) + 0xd0100000)
+//Bit 31:21, reserved
+//Bit 20:16, reg_mcdi_mclpfmsk42.                  mc lpf coef. 2 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 7
+//Bit 15:13, reserved
+//Bit 12: 8, reg_mcdi_mclpfmsk41.                  mc lpf coef. 1 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 9
+//Bit  7: 5, reserved
+//Bit  4: 0, reg_mcdi_mclpfmsk40.                  mc lpf coef. 0 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 0
+#define MCDI_MC_REL_GAIN_OFFST_0                   ((0x2f76  << 2) + 0xd0100000)
+//Bit 31:26, reserved
+//Bit    25, reg_mcdi_mcmotionparadoxflg.          flag of motion paradox, initial with 0 and read from software, default = 0
+//Bit    24, reg_mcdi_mchighvertfrqflg.            flag of high vert frq, initial with 0 and read from software, default = 0
+//Bit 23:16, reg_mcdi_mcmotionparadoxoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 128
+//Bit 15:12, reserved
+//Bit 11: 8, reg_mcdi_mcmotionparadoxgain.         gain for rel (MC blending coef.) refinement if motion paradox detected before MC blending, normalized 8 as '1', set 15 to 16, default = 8
+//Bit  7: 4, reg_mcdi_mchighvertfrqoffst.          minus offset (alpha - offset) for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, default = 15
+//Bit  3: 0, reg_mcdi_mchighvertfrqgain.           gain for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, normalized 8 as '1', set 15 to 16, default = 8
+#define MCDI_MC_REL_GAIN_OFFST_1                   ((0x2f77  << 2) + 0xd0100000)
+//Bit 31:24, reg_mcdi_mcoutofboundrayoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending before MC blending, default = 255
+//Bit 23:20, reserved
+//Bit 19:16, reg_mcdi_mcoutofboundraygain.         gain for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending, normalized 8 as '1', set 15 to 16, default = 8
+//Bit 15: 8, reg_mcdi_mcrelrefbycolcfdoffst.       offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 255
+//Bit  7: 4, reserved.
+//Bit  3: 0, reg_mcdi_mcrelrefbycolcfdgain.        gain for rel (MC blending coef.) refinement if column cofidence failed before MC blending, normalized 8 as '1', set 15 to 16, default = 8
+#define MCDI_MC_COL_CFD_0                          ((0x2f78  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_0.                    column cofidence value 0 read from software. initial = 0
+#define MCDI_MC_COL_CFD_1                          ((0x2f79  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_1.                    column cofidence value 1 read from software. initial = 0
+#define MCDI_MC_COL_CFD_2                          ((0x2f7a  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_2.                    column cofidence value 2 read from software. initial = 0
+#define MCDI_MC_COL_CFD_3                          ((0x2f7b  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_3.                    column cofidence value 3 read from software. initial = 0
+#define MCDI_MC_COL_CFD_4                          ((0x2f7c  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_4.                    column cofidence value 4 read from software. initial = 0
+#define MCDI_MC_COL_CFD_5                          ((0x2f7d  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_5.                    column cofidence value 5 read from software. initial = 0
+#define MCDI_MC_COL_CFD_6                          ((0x2f7e  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_6.                    column cofidence value 6 read from software. initial = 0
+#define MCDI_MC_COL_CFD_7                          ((0x2f7f  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_7.                    column cofidence value 7 read from software. initial = 0
+#define MCDI_MC_COL_CFD_8                          ((0x2f80  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_8.                    column cofidence value 8 read from software. initial = 0
+#define MCDI_MC_COL_CFD_9                          ((0x2f81  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_9.                    column cofidence value 9 read from software. initial = 0
+#define MCDI_MC_COL_CFD_10                         ((0x2f82  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_10.                   column cofidence value 10 read from software. initial = 0
+#define MCDI_MC_COL_CFD_11                         ((0x2f83  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_11.                   column cofidence value 11 read from software. initial = 0
+#define MCDI_MC_COL_CFD_12                         ((0x2f84  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_12.                   column cofidence value 12 read from software. initial = 0
+#define MCDI_MC_COL_CFD_13                         ((0x2f85  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_13.                   column cofidence value 13 read from software. initial = 0
+#define MCDI_MC_COL_CFD_14                         ((0x2f86  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_14.                   column cofidence value 14 read from software. initial = 0
+#define MCDI_MC_COL_CFD_15                         ((0x2f87  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_15.                   column cofidence value 15 read from software. initial = 0
+#define MCDI_MC_COL_CFD_16                         ((0x2f88  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_16.                   column cofidence value 16 read from software. initial = 0
+#define MCDI_MC_COL_CFD_17                         ((0x2f89  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_17.                   column cofidence value 17 read from software. initial = 0
+#define MCDI_MC_COL_CFD_18                         ((0x2f8a  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_18.                   column cofidence value 18 read from software. initial = 0
+#define MCDI_MC_COL_CFD_19                         ((0x2f8b  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_19.                   column cofidence value 19 read from software. initial = 0
+#define MCDI_MC_COL_CFD_20                         ((0x2f8c  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_20.                   column cofidence value 20 read from software. initial = 0
+#define MCDI_MC_COL_CFD_21                         ((0x2f8d  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_21.                   column cofidence value 21 read from software. initial = 0
+#define MCDI_MC_COL_CFD_22                         ((0x2f8e  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_22.                   column cofidence value 22 read from software. initial = 0
+#define MCDI_MC_COL_CFD_23                         ((0x2f8f  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_23.                   column cofidence value 23 read from software. initial = 0
+#define MCDI_MC_COL_CFD_24                         ((0x2f90  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_24.                   column cofidence value 24 read from software. initial = 0
+#define MCDI_MC_COL_CFD_25                         ((0x2f91  << 2) + 0xd0100000)
+//Bit 31: 0, mcdi_mc_col_cfd_25.                   column cofidence value 25 read from software. initial = 0
+// ===================================================================================== PRE RO Registers ==========================================================================================
+#define MCDI_RO_FLD_LUMA_AVG_SUM                   ((0x2fa0  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_fldlumaavgsum.                block's luma avg sum of current filed (block based). initial = 0
+#define MCDI_RO_GMV_VLD_CNT                        ((0x2fa1  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_gmvvldcnt.                    valid gmv's count of pre one filed (block based). initial = 0
+#define MCDI_RO_RPT_FLG_CNT                        ((0x2fa2  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_rptflgcnt.                    repeat mv's count of pre one filed (block based). initial = 0
+#define MCDI_RO_FLD_BAD_SAD_CNT                    ((0x2fa3  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_fldbadsadcnt.                 bad sad count of whole pre one field (block based). initial = 0
+#define MCDI_RO_FLD_BAD_BADW_CNT                   ((0x2fa4  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_fldbadbadwcnt.                bad badw count of whole pre one field (block based). initial = 0
+#define MCDI_RO_FLD_BAD_REL_CNT                    ((0x2fa5  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_fldbadrelcnt.                 bad rel count of whole pre one field (block based). initial = 0
+#define MCDI_RO_FLD_MTN_CNT                        ((0x2fa6  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_fldmtncnt.                    motion count of whole pre one field (pixel based). initial = 0
+#define MCDI_RO_FLD_VLD_CNT                        ((0x2fa7  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_fldvldcnt.                    valid motion count of whole pre one field (pixel based). initial = 0
+#define MCDI_RO_FLD_PD_22_PRE_CNT                  ((0x2fa8  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_fldpd22precnt.                prevoius pd22 check count of whole pre one field (block based). initial = 0
+#define MCDI_RO_FLD_PD_22_FOR_CNT                  ((0x2fa9  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_fldpd22forcnt.                forward pd22 check count of whole pre one field (block based). initial = 0
+#define MCDI_RO_FLD_PD_22_FLT_CNT                  ((0x2faa  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_fldpd22fltcnt.                flat count (for pd22 check) of whole pre one field (block based). initial = 0
+#define MCDI_RO_HIGH_VERT_FRQ_FLG                  ((0x2fab  << 2) + 0xd0100000)
+//Bit 31:16, reserved.
+//Bit 15: 8, ro_mcdi_highvertfrqcnt.               high vertical frequency count till prevoius one field. initial = 0
+//Bit  7: 3, reserved.
+//Bit  2: 1, ro_mcdi_highvertfrqphase.             high vertical frequency phase of prevoius one field. initial = 2
+//Bit     0, ro_mcdi_highvertfrqflg.               high vertical frequency flag of prevoius one field. initial = 0
+#define MCDI_RO_GMV_LOCK_FLG                       ((0x2fac  << 2) + 0xd0100000)
+//Bit 31:16, reserved.
+//Bit 15: 8, ro_mcdi_gmvlckcnt.                    global mv lock count till prevoius one field. initial = 0
+//Bit  7: 2, ro_mcdi_gmv.                          global mv of prevoius one field. -31~31, initial = 32 (invalid value)
+//Bit     1, ro_mcdi_zerogmvlckflg.                zero global mv lock flag of prevoius one field. initial = 0
+//Bit     0, ro_mcdi_gmvlckflg.                    global mv lock flag of prevoius one field. initial = 0
+#define MCDI_RO_RPT_MV                             ((0x2fad  << 2) + 0xd0100000)
+//Bit 5: 0, ro_mcdi_rptmv.                         repeate mv of prevoius one field. -31~31, initial = 32 (invalid value)
+#define MCDI_RO_MOTION_PARADOX_FLG                 ((0x2fae  << 2) + 0xd0100000)
+//Bit 31:16, reserved.
+//Bit 15: 8, ro_mcdi_motionparadoxcnt.             motion paradox count till prevoius one field. initial = 0
+//Bit  7: 1, reserved. 
+//Bit     0, ro_mcdi_motionparadoxflg.             motion paradox flag of prevoius one field. initial = 0
+#define MCDI_RO_PD_22_FLG                          ((0x2faf  << 2) + 0xd0100000)
+//Bit 31:16, reserved.
+//Bit 15: 8, ro_mcdi_pd22cnt.                      pull down 22 count till prevoius one field. initial = 0
+//Bit  7: 1, reserved. 
+//Bit     0, ro_mcdi_pd22flg.                      pull down 22 flag of prevoius one field. initial = 0
+#define MCDI_RO_COL_CFD_0                          ((0x2fb0  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_0.                    column cofidence value 0. initial = 0
+#define MCDI_RO_COL_CFD_1                          ((0x2fb1  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_1.                    column cofidence value 1. initial = 0
+#define MCDI_RO_COL_CFD_2                          ((0x2fb2  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_2.                    column cofidence value 2. initial = 0
+#define MCDI_RO_COL_CFD_3                          ((0x2fb3  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_3.                    column cofidence value 3. initial = 0
+#define MCDI_RO_COL_CFD_4                          ((0x2fb4  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_4.                    column cofidence value 4. initial = 0
+#define MCDI_RO_COL_CFD_5                          ((0x2fb5  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_5.                    column cofidence value 5. initial = 0
+#define MCDI_RO_COL_CFD_6                          ((0x2fb6  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_6.                    column cofidence value 6. initial = 0
+#define MCDI_RO_COL_CFD_7                          ((0x2fb7  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_7.                    column cofidence value 7. initial = 0
+#define MCDI_RO_COL_CFD_8                          ((0x2fb8  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_8.                    column cofidence value 8. initial = 0
+#define MCDI_RO_COL_CFD_9                          ((0x2fb9  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_9.                    column cofidence value 9. initial = 0
+#define MCDI_RO_COL_CFD_10                         ((0x2fba  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_10.                   column cofidence value 10. initial = 0
+#define MCDI_RO_COL_CFD_11                         ((0x2fbb  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_11.                   column cofidence value 11. initial = 0
+#define MCDI_RO_COL_CFD_12                         ((0x2fbc  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_12.                   column cofidence value 12. initial = 0
+#define MCDI_RO_COL_CFD_13                         ((0x2fbd  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_13.                   column cofidence value 13. initial = 0
+#define MCDI_RO_COL_CFD_14                         ((0x2fbe  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_14.                   column cofidence value 14. initial = 0
+#define MCDI_RO_COL_CFD_15                         ((0x2fbf  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_15.                   column cofidence value 15. initial = 0
+#define MCDI_RO_COL_CFD_16                         ((0x2fc0  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_16.                   column cofidence value 16. initial = 0
+#define MCDI_RO_COL_CFD_17                         ((0x2fc1  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_17.                   column cofidence value 17. initial = 0
+#define MCDI_RO_COL_CFD_18                         ((0x2fc2  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_18.                   column cofidence value 18. initial = 0
+#define MCDI_RO_COL_CFD_19                         ((0x2fc3  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_19.                   column cofidence value 19. initial = 0
+#define MCDI_RO_COL_CFD_20                         ((0x2fc4  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_20.                   column cofidence value 20. initial = 0
+#define MCDI_RO_COL_CFD_21                         ((0x2fc5  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_21.                   column cofidence value 21. initial = 0
+#define MCDI_RO_COL_CFD_22                         ((0x2fc6  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_22.                   column cofidence value 22. initial = 0
+#define MCDI_RO_COL_CFD_23                         ((0x2fc7  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_23.                   column cofidence value 23. initial = 0
+#define MCDI_RO_COL_CFD_24                         ((0x2fc8  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_24.                   column cofidence value 24. initial = 0
+#define MCDI_RO_COL_CFD_25                         ((0x2fc9  << 2) + 0xd0100000)
+//Bit 31: 0, ro_mcdi_col_cfd_25.                   column cofidence value 25. initial = 0
+// add space 8'hd0-8'hef
+//
+// Reading file:  dipd_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// using 8'he0-8'hef
+#define DIPD_COMB_CTRL0                            ((0x2fd0  << 2) + 0xd0100000)
+//Bit 31:0,								reg_pd_comb_ctrl0
+#define DIPD_COMB_CTRL1                            ((0x2fd1  << 2) + 0xd0100000)
+//Bit 31:0,								reg_pd_comb_ctrl1
+#define DIPD_COMB_CTRL2                            ((0x2fd2  << 2) + 0xd0100000)
+//Bit 31:0,								reg_pd_comb_ctrl2
+#define DIPD_COMB_CTRL3                            ((0x2fd3  << 2) + 0xd0100000)
+//Bit 31:0,								reg_pd_comb_ctrl3
+#define DIPD_COMB_CTRL4                            ((0x2fd4  << 2) + 0xd0100000)
+//Bit 31:0,								reg_pd_comb_ctrl4
+#define DIPD_COMB_CTRL5                            ((0x2fd5  << 2) + 0xd0100000)
+//Bit 31:0,								reg_pd_comb_ctrl5
+#define DIPD_RO_COMB_0                             ((0x2fd6  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_0
+#define DIPD_RO_COMB_1                             ((0x2fd7  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_1
+#define DIPD_RO_COMB_2                             ((0x2fd8  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_2
+#define DIPD_RO_COMB_3                             ((0x2fd9  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_3
+#define DIPD_RO_COMB_4                             ((0x2fda  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_4
+#define DIPD_RO_COMB_5                             ((0x2fdb  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_5
+#define DIPD_RO_COMB_6                             ((0x2fdc  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_6
+#define DIPD_RO_COMB_7                             ((0x2fdd  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_7
+#define DIPD_RO_COMB_8                             ((0x2fde  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_8
+#define DIPD_RO_COMB_9                             ((0x2fdf  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_9
+#define DIPD_RO_COMB_10                            ((0x2fe0  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_10
+#define DIPD_RO_COMB_11                            ((0x2fe1  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_11
+#define DIPD_RO_COMB_12                            ((0x2fe2  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_12
+#define DIPD_RO_COMB_13                            ((0x2fe3  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_13
+#define DIPD_RO_COMB_14                            ((0x2fe4  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_14
+#define DIPD_RO_COMB_15                            ((0x2fe5  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_15
+#define DIPD_RO_COMB_16                            ((0x2fe6  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_16
+#define DIPD_RO_COMB_17                            ((0x2fe7  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_17
+#define DIPD_RO_COMB_18                            ((0x2fe8  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_18
+#define DIPD_RO_COMB_19                            ((0x2fe9  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_19
+#define DIPD_RO_COMB_20                            ((0x2fea  << 2) + 0xd0100000)
+//Bit 31:0,								ro_pd_comb_20
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  dipd_regs.h
+//
+// addr space 8'hf0-8'hff 
+//
+// Reading file:  nr3_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  VPPB_VCBUS_BASE = 0xfe
+// -----------------------------------------------
+// using 8'hf0-8'hff
+#define NR3_MODE                                   ((0xfef0  << 2) + 0xd0100000)
+//Bit    5,   reg_3dnr_nr3_vtxt_mode         ;
+//Bit    4,   reg_3dnr_nr3_cbyy_ignor_coop   ; // u1: ignore coop condition for cbyy motion decision
+//Bit    3,   reg_3dnr_nr3_ybyc_ignor_cnoop  ; // u1: ignore cnoop condition for ybyc motion decision
+//Bit  2:0,   reg_3dnr_nr3_suremot_txt_mode  ; // u3: 0: cur, 1:p2; 2: (cur+p2)/2; 3/up: min(cur,p2)
+#define NR3_COOP_PARA                              ((0xfef1  << 2) + 0xd0100000)
+//Bit 21:20,   reg_3dnr_nr3_coop_mode         ; // u2  0 original pixel 1: [1 2 1]/4 lpf; 2: [1 2 2 2 1]/8; 3: 3x3 lpf
+//Bit 19:16,   reg_3dnr_nr3_coop_ratio        ; // u4  cur and p2 color oop decision ratio:  (avg1<(MAX(sat0,sat2)*ratio/8 + ofst));	
+//Bit 15:8,    reg_3dnr_nr3_coop_ofset        ; // s8  cur and p2 color oop decision ofst:  (avg1<(MAX(sat0,sat2)*ratio/8 + ofst));	
+//Bit  7:0,    reg_3dnr_nr3_coop_sat_thrd     ; // u8  cur and p2 color oop decision min(sat0,sat1) threshold;		
+#define NR3_CNOOP_GAIN                             ((0xfef2  << 2) + 0xd0100000)
+//Bit 23:20,   reg_3dnr_nr3_cnoop_ratio0      ; // u4   cur and p2 color noop decision ratio0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));		
+//Bit 19:16,   reg_3dnr_nr3_cnoop_ratio1      ; // u4	cur and p2 color noop decision ratio1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
+//Bit 15:8,    reg_3dnr_nr3_cnoop_ofset0      ; // s8	cur and p2 color noop decision ofset0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));
+//Bit  7:0,    reg_3dnr_nr3_cnoop_ofset1      ; // s8   cur and p2 color noop decision ofset1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
+#define NR3_YMOT_PARA                              ((0xfef3  << 2) + 0xd0100000)
+//Bit    19,   reg_3dnr_nr3_ymot_only_en      ; // u1: enable signal for ignor chroma motion: (ytxt &coop)
+//Bit    18,   reg_3dnr_nr3_ymot_only_cmtmode ; // u1: 0: cmot=ymot; 1: cmot = MIN(ymot, cmot)
+//Bit 17:16,   reg_3dnr_nr3_ymot_only_txtmode ; // u2: 0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
+//Bit 15:8,    reg_3dnr_nr3_ymot_only_txtthrd ; // u8: threshold to luma texture to decide use ymot only
+//Bit  7:0,    reg_3dnr_nr3_ymot_only_motthrd ; // u8: threshold to luma motion to decide use ymot only
+#define NR3_CMOT_PARA                              ((0xfef4  << 2) + 0xd0100000)
+//Bit    19,   reg_3dnr_nr3_cmot_only_en      ; // u1: enable signal for ignor luma motion: (ctxt &cnoop)
+//Bit    18,   reg_3dnr_nr3_cmot_only_ymtmode ; // u1: 0: ymot=cmot+ymot/4; 1: ymot = MIN(ymot, cmot)
+//Bit 17:16,   reg_3dnr_nr3_cmot_only_txtmode ; // u2: 0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
+//Bit 15:8,    reg_3dnr_nr3_cmot_only_txtthrd ; // u8: threshold to chroma texture to decide use cmot only
+//Bit  7:0,    reg_3dnr_nr3_cmot_only_motthrd ; // u8: threshold to chroma motion to decide use cmot only
+#define NR3_SUREMOT_YGAIN                          ((0xfef5  << 2) + 0xd0100000)
+//Bit 31:24,   reg_3dnr_nr3_suremot_dec_yrate ; // u8: (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit 23:16,   reg_3dnr_nr3_suremot_dec_yofst ; // u8: lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit 15:8,    reg_3dnr_nr3_suremot_frc_ygain ; // u8: (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit  7:0,    reg_3dnr_nr3_suremot_frc_yofst ; // u8: lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+#define NR3_SUREMOT_CGAIN                          ((0xfef6  << 2) + 0xd0100000)
+//Bit 31:24,   reg_3dnr_nr3_suremot_dec_crate ; // u8: (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit 23:16,   reg_3dnr_nr3_suremot_dec_cofst ; // u8: lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit 15:8,    reg_3dnr_nr3_suremot_frc_cgain ; // u8: (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+//Bit  7:0,    reg_3dnr_nr3_suremot_frc_cofst ; // u8: lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  nr3_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  mcdi_regs.h
+//
+//  VPU_VLOCK register    (16'h3000 - 16'h30ff)
+//========================================================================
+//`define VPU_VLOCK_VCBUS_BASE                   8'h30
+//
+// Reading file:  vpu_vlock_reg.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// ----------------------------
+// VPU_VLOCK 0x30  
+// ----------------------------
+// -----------------------------------------------
+// CBUS_BASE:  VPU_VLOCK_VCBUS_BASE = 0x30
+// -----------------------------------------------
+#define VPU_VLOCK_CTRL                             ((0x3000  << 2) + 0xd0100000)
+#define VPU_VLOCK_MISC_CTRL                        ((0x3001  << 2) + 0xd0100000)
+#define VPU_VLOCK_LOOP0_ACCUM_LMT                  ((0x3002  << 2) + 0xd0100000)
+#define VPU_VLOCK_LOOP0_CTRL0                      ((0x3003  << 2) + 0xd0100000)
+#define VPU_VLOCK_LOOP1_CTRL0                      ((0x3004  << 2) + 0xd0100000)
+#define VPU_VLOCK_LOOP1_IMISSYNC_MAX               ((0x3005  << 2) + 0xd0100000)
+#define VPU_VLOCK_LOOP1_IMISSYNC_MIN               ((0x3006  << 2) + 0xd0100000)
+#define VPU_VLOCK_OVWRITE_ACCUM0                   ((0x3007  << 2) + 0xd0100000)
+#define VPU_VLOCK_OVWRITE_ACCUM1                   ((0x3008  << 2) + 0xd0100000)
+#define VPU_VLOCK_OUTPUT0_CAPT_LMT                 ((0x3009  << 2) + 0xd0100000)
+#define VPU_VLOCK_OUTPUT0_PLL_LMT                  ((0x300a  << 2) + 0xd0100000)
+#define VPU_VLOCK_OUTPUT1_CAPT_LMT                 ((0x300b  << 2) + 0xd0100000)
+#define VPU_VLOCK_OUTPUT1_PLL_LMT                  ((0x300c  << 2) + 0xd0100000)
+#define VPU_VLOCK_LOOP1_PHSDIF_TGT                 ((0x300d  << 2) + 0xd0100000)
+#define VPU_VLOCK_RO_LOOP0_ACCUM                   ((0x300e  << 2) + 0xd0100000)
+#define VPU_VLOCK_RO_LOOP1_ACCUM                   ((0x300f  << 2) + 0xd0100000)
+#define VPU_VLOCK_OROW_OCOL_MAX                    ((0x3010  << 2) + 0xd0100000)
+#define VPU_VLOCK_RO_VS_I_DIST                     ((0x3011  << 2) + 0xd0100000)
+#define VPU_VLOCK_RO_VS_O_DIST                     ((0x3012  << 2) + 0xd0100000)
+#define VPU_VLOCK_RO_LINE_PIX_ADJ                  ((0x3013  << 2) + 0xd0100000)
+#define VPU_VLOCK_RO_OUTPUT_00_01                  ((0x3014  << 2) + 0xd0100000)
+#define VPU_VLOCK_RO_OUTPUT_10_11                  ((0x3015  << 2) + 0xd0100000)
+#define VPU_VLOCK_MX4096                           ((0x3016  << 2) + 0xd0100000)
+#define VPU_VLOCK_STBDET_WIN0_WIN1                 ((0x3017  << 2) + 0xd0100000)
+#define VPU_VLOCK_STBDET_CLP                       ((0x3018  << 2) + 0xd0100000)
+#define VPU_VLOCK_STBDET_ABS_WIN0                  ((0x3019  << 2) + 0xd0100000)
+#define VPU_VLOCK_STBDET_ABS_WIN1                  ((0x301a  << 2) + 0xd0100000)
+#define VPU_VLOCK_STBDET_SGN_WIN0                  ((0x301b  << 2) + 0xd0100000)
+#define VPU_VLOCK_STBDET_SGN_WIN1                  ((0x301c  << 2) + 0xd0100000)
+#define VPU_VLOCK_ADJ_EN_SYNC_CTRL                 ((0x301d  << 2) + 0xd0100000)
+#define VPU_VLOCK_GCLK_EN                          ((0x301e  << 2) + 0xd0100000)
+#define VPU_VLOCK_LOOP1_ACCUM_LMT                  ((0x301f  << 2) + 0xd0100000)
+#define VPU_VLOCK_RO_M_INT_FRAC                    ((0x3020  << 2) + 0xd0100000)
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  vpu_vlock_reg.h
+//
+//`define VPPB_VCBUS_BASE                8'h31 
+//
+// Reading file:  srscl_reg.h
+//
+// synopsys translate_off
+// synopsys translate_on
+// -----------------------------------------------
+// CBUS_BASE:  VPPB_VCBUS_BASE = 0x31
+// -----------------------------------------------
+////=================================================================////
+//// super scaler core 0
+////=================================================================////
+#define SRSCL0_HV_SIZEIN                           ((0x3100  << 2) + 0xd0100000)
+//Bit 31:29, reserved  
+//Bit 28:16, reg_srscl0_hsize               image horizontal size (number of cols)   default=1024 
+//Bit 15:13, reserved                       
+//Bit 12: 0, reg_srscl0_vsize               image vertical size   (number of rows)   default=1024
+#define SRSCL0_CTRL_MODE                           ((0x3101  << 2) + 0xd0100000)
+//Bit 31:15, reserved     
+//Bit 14,    reg_srscl0_horz_outphs          phase for super-scalar output under xVx1H ration: 0: 0 phase, 1: 1/2 phase     default = 0
+//Bit 13,    reg_srscl0_cmpmux_aft           u1: 0 no swap anf for YUV->YUV; 1, swapped and for GBR-RGB; default = 0
+//Bit 12,    reg_srscl0_cmpmux_bef           u1: 0 no swap anf for YUV->YUV; 1, swapped and for RGB->GBR; default = 0
+//Bit 11,    reg_srscl0_bic_norm             normalization of bicubical: 0: 128|128; 1: 64|64  default = 0
+//Bit 10,    reg_srscl0_3dint_mode           option for line-by-line 3D cases     default = 0
+//Bit 9,     reg_srscl0_3dint_hadj_cub       option for using cubic interpolation for horizontal adjacent pixels     default = 0
+//Bit 8,     reg_srscl0_vert_outphs          phase for super-scalar output under 1Vx2H ration: 0: 0 phase, 1: 1/2 phase     default = 0
+//Bit 7,     reg_srscl0_cuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
+//Bit 6,     reg_srscl0_yuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
+//Bit 5,     reg_srscl0_cuse_bic             inside demo window luma use bicubical interpolation 
+//                                           0: demo window us SR scalar for chroma channel;  
+//                                           1: demo window use Bi-cubic scalar for chroma channel        default = 0
+//Bit 4,     reg_srscl0_yuse_bic             inside demo window luma use bicubical interpolation 
+//                                           0: demo window us SR scalar for luma channel;  
+//                                           1: demo window use Bi-cubic scalar for luma channel        default = 0
+//Bit 3,     reg_srscl0_use_3lrln            Options to extend 3 lines low-resolution data to 5-lines for SR scalar, (for core_0):
+//                                           0: normal working mode, using 5 lines 
+//                                           1: extend effective 3 lines to 5 lines; (will be used in line-by-line 3D contents)         default = 
+//Bit 2,     reg_srscl0_vert_ratio           Vertical scalar ratio of Super Scalar core_0;
+//                                           0: 1x scale; 1: 2x scale;    default = 
+//Bit 1,     reg_srscl0_hori_ratio           Horizontal scalar ratio of Super Scalar core_0;
+//                                           0: 1x scale; 1: 2x scale;    default = 
+//Bit 0,     reg_srscl0_enable               Enable of Super Scalar core_0: 
+//                                           0: disable (bypass) 1: enable    default = 
+#define SRSCL0_YBIC_HCOEF                          ((0x3102  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl0_y_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                          Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl0_y_bic_hcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl0_y_bic_hcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl0_y_bic_hcoef0         the same as above; default=-8
+#define SRSCL0_CBIC_HCOEF                          ((0x3103  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl0_c_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl0_c_bic_hcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl0_c_bic_hcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl0_c_bic_hcoef0         the same as above; default=-8
+#define SRSCL0_YBIC_VCOEF                          ((0x3104  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl0_y_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl0_y_bic_vcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl0_y_bic_vcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl0_y_bic_vcoef0         the same as above; default=-8
+#define SRSCL0_CBIC_VCOEF                          ((0x3105  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl0_c_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl0_c_bic_vcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl0_c_bic_vcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl0_c_bic_vcoef0         the same as above; default=-8
+#define SRSCL0_VAR_PARA                            ((0x3106  << 2) + 0xd0100000)
+//Bit 31:26, reserved  
+//Bit 25:24, reg_srscl0_var_adja_rs          Horizontal/vertical adjacent pixel noise normalized variance value right shift bits.  default= 2   
+//Bit 23:16, reg_srscl0_var_adja             Horizontal/vertical adjacent pixel noise normalized variance value. 
+//                                           Var2 = (2^(11+rs))/gain; default= 68
+//Bit 15:10, reserved  
+//Bit  9: 8, reg_srscl0_var_diag_rs          Diagonal pixel noise normalized variance value right shift bits. default= 3    
+//Bit  7: 0, reg_srscl0_var_diag             Diagonal pixel noise normalized variance value. Var2 = (2^(11+rs))/gain; default= 68
+#define SRSCL0_CONST_PARA                          ((0x3107  << 2) + 0xd0100000)
+//Bit 31:16, reserved  
+//Bit 15: 8, reg_srscl0_c_adja               Constant for d_adja calculation from wk_nrm; Normalize 128 as 1 default= 32     
+//Bit  7: 0, reg_srscl0_c_diag               Constant for d_diag calculation from wk_nrm; Normalize 128 as 1 default= 32
+#define SRSCL0_RKE_EXTWIN                          ((0x3108  << 2) + 0xd0100000)
+//Bit 31:23, reserved  
+//Bit 22:20, reg_srscl0_rke_extwin         Window size for Rke horizontal extension: Win_size = 2x+1 scope: 0~5;  default= 4
+//Bit 19:16, reg_srscl0_rke_coring         Coring to Rke default= 10
+//Bit 15:13, reserved  
+//Bit 12: 8, reg_srscl0_rke_extwin_core    Coring to Rks before local window maximum value calculation     default= 10 
+//Bit  7: 0, reg_srscl0_rke_extwin_rate    Rate to blender strength (gamma), gamma is used to blend local maximum Rke and current Rke; the rate is normalized to 16 as 1  default= 12
+#define SRSCL0_UK_GRAD2DDIAG_TH_RATE               ((0x3109  << 2) + 0xd0100000)
+//reg_srscl0_uk_grad2ddiag (0 1 5 6)  Wk_nrm to d_diag mapping curve parameter for UK calculation:         
+//Bit 31:24, reg_srscl0_uk_grad2ddiag_rate1 rate1, d_diag level trasition rate 2nd towards 3rd piece;   default = 20;
+//Bit 23:16, reg_srscl0_uk_grad2ddiag_rate0 rate0, d_diag level trasition rate 2nd towards 1st piece;   default = 80;
+//Bit 15: 8, reg_srscl0_uk_grad2ddiag_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
+//Bit  7: 0, reg_srscl0_uk_grad2ddiag_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
+#define SRSCL0_UK_GRAD2DDIAG_LIMIT                 ((0x310a  << 2) + 0xd0100000)
+//reg_srscl0_uk_grad2ddiag (2 3 4)            
+//Bit 31:24, reserved 
+//Bit 23:16, reg_srscl0_uk_grad2ddiag_lv2   lev2, d_diag level limit for 3rd piece;   default = 128;
+//Bit 15: 8, reg_srscl0_uk_grad2ddiag_lv1   lev1, d_diag level limit for 2nd piece;   default = 128;
+//Bit  7: 0, reg_srscl0_uk_grad2ddiag_lv0   lev0, d_diag level limit for 1st piece;   default = 128;
+#define SRSCL0_UK_GRAD2DADJA_TH_RATE               ((0x310b  << 2) + 0xd0100000)
+//reg_srscl0_uk_grad2adja (0 1 5 6)  Wk_nrm to d_adja mapping curve parameter for UK calculation:         
+//Bit 31:24, reg_srscl0_uk_grad2dadja_rate1 rate1, d_adja level trasition rate 2nd towards 3rd piece;   default = 20;
+//Bit 23:16, reg_srscl0_uk_grad2dadja_rate0 rate0, d_adja level trasition rate 2nd towards 1st piece;   default = 80;
+//Bit 15: 8, reg_srscl0_uk_grad2dadja_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
+//Bit  7: 0, reg_srscl0_uk_grad2dadja_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
+#define SRSCL0_UK_GRAD2DADJA_LIMIT                 ((0x310c  << 2) + 0xd0100000)
+//reg_srscl0_uk_grad2dadja (2 3 4)            
+//Bit 31:24, reserved    
+//Bit 23:16, reg_srscl0_uk_grad2dadja_lv2   lev2, d_adja level limit for 3rd piece;   default = 128;
+//Bit 15: 8, reg_srscl0_uk_grad2dadja_lv1   lev1, d_adja level limit for 2nd piece;   default = 128;
+//Bit  7: 0, reg_srscl0_uk_grad2dadja_lv0   lev0, d_adja level limit for 1st piece;   default = 128;
+#define SRSCL0_UK_BST_GAIN                         ((0x310d  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl0_bst_cgain           Gain to Uk_diag, normalized to 32 as 1  default = 122;
+//Bit 23:16, reg_srscl0_bst_ygain           Gain to Uk_adja, normalized to 32 as 1  default = 122;
+//Bit 15: 8, reg_srscl0_uk_adja_gain        Boost gain to delta component of SR scalar refine for luma channel. It is applied to tDiv.
+//                                          Normalized to 128 as 1  default = 58;
+//Bit  7: 0, reg_srscl0_uk_diag_gain        Boost gain to delta component of SR scalar refine for chroma channel. It is applied to tDiv.
+//                                          Normalized to 128 as 1  default = 80;
+#define SRSCL0_HVBLEND_TH                          ((0x310e  << 2) + 0xd0100000)
+//Bit 31:29, reserved 
+//Bit 28:24, reg_srscl0_hvblend_th3         Rate threshold to decide HV protection blend rate, default = 8;
+//Bit 23:21, reserved 
+//Bit 20:16, reg_srscl0_hvblend_th2         the same as above;  default = 8;
+//Bit 15:13, reserved 
+//Bit 12: 8, reg_srscl0_hvblend_th1         the same as above;  default = 4;
+//Bit  7: 5, reserved 
+//Bit  4: 0, reg_srscl0_hvblend_th0         the same as above;  default = 4;
+#define SRSCL0_DEMO_WIND_TB                        ((0x310f  << 2) + 0xd0100000)
+//Bit 31:29, reserved 
+//Bit 28:16, reg_srscl0_demo_wind_top       Demo mode window vertical top boundary range;  default = 8191;
+//Bit 15:13, reserved 
+//Bit 12: 0, reg_srscl0_demo_wind_bot       Demo mode window vertical bottom boundary range;  default = 0;
+#define SRSCL0_DEMO_WIND_LR                        ((0x3110  << 2) + 0xd0100000)
+//Bit 31:29, reserved 
+//Bit 28:16, reg_srscl0_demo_wind_right     Demo mode window vertical right boundary range;  default = 8191;
+//Bit 15:13, reserved 
+//Bit 12: 0, reg_srscl0_demo_wind_left      Demo mode window vertical left boundary range;  default = 0;
+#define SRSCL0_INT_BLANK_NUM                       ((0x3111  << 2) + 0xd0100000)
+//Bit 31:21, reserved  
+//Bit    20, reg_srscl0_rst_syn_en          for syn same control reg to rst_n posedge. default=0;  
+//Bit 19:16, reg_srscl0_inbuf_hsk_stuff     default=2
+//Bit 15: 8, reg_srscl0_int_vbk_num         interpolation vertical   blank num   default=24
+//Bit  7: 0, reg_srscl0_int_hbk_num         interpolation horizontal blank num   default=8
+#define SRSCL0_YBIC_HCOEF0                         ((0x3112  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl0_y_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl0_y_bic_hcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl0_y_bic_hcoef01         the same as above; default=128                        
+//Bit  7: 0, reg_srscl0_y_bic_hcoef00         the same as above; default=0
+#define SRSCL0_CBIC_HCOEF0                         ((0x3113  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl0_c_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl0_c_bic_hcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl0_c_bic_hcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl0_c_bic_hcoef00         the same as above; default=0
+#define SRSCL0_YBIC_VCOEF0                         ((0x3114  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl0_y_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl0_y_bic_vcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl0_y_bic_vcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl0_y_bic_vcoef00         the same as above; default=0
+#define SRSCL0_CBIC_VCOEF0                         ((0x3115  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl0_c_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl0_c_bic_vcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl0_c_bic_vcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl0_c_bic_vcoef00         the same as above; default=0
+////=================================================================////
+//// super scaler core 1
+////=================================================================////
+#define SRSCL1_HV_SIZEIN                           ((0x3118  << 2) + 0xd0100000)
+//Bit 31:29, reserved  
+//Bit 28:16, reg_srscl1_hsize               image horizontal size (number of cols)   default=2048 
+//Bit 15:13, reserved                       
+//Bit 12: 0, reg_srscl1_vsize               image vertical size   (number of rows)   default=2048
+#define SRSCL1_CTRL_MODE                           ((0x3119  << 2) + 0xd0100000)
+//Bit 31:15, reserved     
+//Bit 14,    reg_srscl1_horz_outphs          phase for super-scalar output under xVx1H ration: 0: 0 phase, 1: 1/2 phase     default = 0
+//Bit 13,    reg_srscl1_cmpmux_aft           u1: 0 no swap anf for YUV->YUV; 1, swapped and for GBR-RGB; default = 0
+//Bit 12,    reg_srscl1_cmpmux_bef           u1: 0 no swap anf for YUV->YUV; 1, swapped and for RGB->GBR; default = 0
+//Bit 11,    reg_srscl1_bic_norm             normalization of bicubical: 0: 128|128; 1: 64|64  default = 0
+//Bit 10,    reg_srscl1_3dint_mode           option for line-by-line 3D cases     default = 0
+//Bit 9,     reg_srscl1_3dint_hadj_cub       option for using cubic interpolation for horizontal adjacent pixels     default = 0
+//Bit 8,     reg_srscl1_vert_outphs          phase for super-scalar output under 1Vx2H ration: 0: 0 phase, 1: 1/2 phase     default = 0
+//Bit 7,     reg_srscl1_cuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
+//Bit 6,     reg_srscl1_yuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
+//Bit 5,     reg_srscl1_cuse_bic             inside demo window luma use bicubical interpolation 
+//                                           0: demo window us SR scalar for chroma channel;  
+//                                           1: demo window use Bi-cubic scalar for chroma channel        default = 0
+//Bit 4,     reg_srscl1_yuse_bic             inside demo window luma use bicubical interpolation 
+//                                           0: demo window us SR scalar for luma channel;  
+//                                           1: demo window use Bi-cubic scalar for luma channel        default = 0
+//Bit 3,     reg_srscl1_use_3lrln            Options to extend 3 lines low-resolution data to 5-lines for SR scalar, (for core_0):
+//                                           0: normal working mode, using 5 lines 
+//                                           1: extend effective 3 lines to 5 lines; (will be used in line-by-line 3D contents)         default = 
+//Bit 2,     reg_srscl1_vert_ratio           Vertical scalar ratio of Super Scalar core_0;
+//                                           0: 1x scale; 1: 2x scale;    default = 
+//Bit 1,     reg_srscl1_hori_ratio           Horizontal scalar ratio of Super Scalar core_0;
+//                                           0: 1x scale; 1: 2x scale;    default = 
+//Bit 0,     reg_srscl1_enable               Enable of Super Scalar core_0: 
+//                                           0: disable (bypass) 1: enable    default = 
+#define SRSCL1_YBIC_HCOEF                          ((0x311a  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_y_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_y_bic_hcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_y_bic_hcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_y_bic_hcoef0         the same as above; default=-8
+#define SRSCL1_CBIC_HCOEF                          ((0x311b  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_c_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_c_bic_hcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_c_bic_hcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_c_bic_hcoef0         the same as above; default=-8
+#define SRSCL1_YBIC_VCOEF                          ((0x311c  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_y_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_y_bic_vcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_y_bic_vcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_y_bic_vcoef0         the same as above; default=-8
+#define SRSCL1_CBIC_VCOEF                          ((0x311d  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_c_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_c_bic_vcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_c_bic_vcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_c_bic_vcoef0         the same as above; default=-8
+#define SRSCL1_VAR_PARA                            ((0x311e  << 2) + 0xd0100000)
+//Bit 31:26, reserved  
+//Bit 25:24, reg_srscl1_var_adja_rs          Horizontal/vertical adjacent pixel noise normalized variance value right shift bits.  default= 2   
+//Bit 23:16, reg_srscl1_var_adja             Horizontal/vertical adjacent pixel noise normalized variance value. 
+//                                           Var2 = (2^(11+rs))/gain; default= 68
+//Bit 15:10, reserved  
+//Bit  9: 8, reg_srscl1_var_diag_rs          Diagonal pixel noise normalized variance value right shift bits. default= 3    
+//Bit  7: 0, reg_srscl1_var_diag             Diagonal pixel noise normalized variance value. Var2 = (2^(11+rs))/gain; default= 68
+#define SRSCL1_CONST_PARA                          ((0x311f  << 2) + 0xd0100000)
+//Bit 31:16, reserved  
+//Bit 15: 8, reg_srscl1_c_adja               Constant for d_adja calculation from wk_nrm; Normalize 128 as 1 default= 32     
+//Bit  7: 0, reg_srscl1_c_diag               Constant for d_diag calculation from wk_nrm; Normalize 128 as 1 default= 32
+#define SRSCL1_RKE_EXTWIN                          ((0x3120  << 2) + 0xd0100000)
+//Bit 31:23, reserved  
+//Bit 22:20, reg_srscl1_rke_extwin         Window size for Rke horizontal extension: Win_size = 2x+1 scope: 0~5;  default= 4
+//Bit 19:16, reg_srscl1_rke_coring         Coring to Rke default= 10
+//Bit 15:13, reserved  
+//Bit 12: 8, reg_srscl1_rke_extwin_core    Coring to Rks before local window maximum value calculation     default= 10 
+//Bit  7: 0, reg_srscl1_rke_extwin_rate    Rate to blender strength (gamma), gamma is used to blend local maximum Rke and current Rke; the rate is normalized to 16 as 1  default= 12
+#define SRSCL1_UK_GRAD2DDIAG_TH_RATE               ((0x3121  << 2) + 0xd0100000)
+//reg_srscl1_uk_grad2ddiag (0 1 5 6)  Wk_nrm to d_diag mapping curve parameter for UK calculation:         
+//Bit 31:24, reg_srscl1_uk_grad2ddiag_rate1 rate1, d_diag level trasition rate 2nd towards 3rd piece;   default = 20;
+//Bit 23:16, reg_srscl1_uk_grad2ddiag_rate0 rate0, d_diag level trasition rate 2nd towards 1st piece;   default = 80;
+//Bit 15: 8, reg_srscl1_uk_grad2ddiag_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
+//Bit  7: 0, reg_srscl1_uk_grad2ddiag_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
+#define SRSCL1_UK_GRAD2DDIAG_LIMIT                 ((0x3122  << 2) + 0xd0100000)
+//reg_srscl1_uk_grad2ddiag (2 3 4)            
+//Bit 31:24, reserved 
+//Bit 23:16, reg_srscl1_uk_grad2ddiag_lv2   lev2, d_diag level limit for 3rd piece;   default = 128;
+//Bit 15: 8, reg_srscl1_uk_grad2ddiag_lv1   lev1, d_diag level limit for 2nd piece;   default = 128;
+//Bit  7: 0, reg_srscl1_uk_grad2ddiag_lv0   lev0, d_diag level limit for 1st piece;   default = 128;
+#define SRSCL1_UK_GRAD2DADJA_TH_RATE               ((0x3123  << 2) + 0xd0100000)
+//reg_srscl1_uk_grad2adja (0 1 5 6)  Wk_nrm to d_adja mapping curve parameter for UK calculation:         
+//Bit 31:24, reg_srscl1_uk_grad2dadja_rate1 rate1, d_adja level trasition rate 2nd towards 3rd piece;   default = 20;
+//Bit 23:16, reg_srscl1_uk_grad2dadja_rate0 rate0, d_adja level trasition rate 2nd towards 1st piece;   default = 80;
+//Bit 15: 8, reg_srscl1_uk_grad2dadja_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
+//Bit  7: 0, reg_srscl1_uk_grad2dadja_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
+#define SRSCL1_UK_GRAD2DADJA_LIMIT                 ((0x3124  << 2) + 0xd0100000)
+//reg_srscl1_uk_grad2dadja (2 3 4)            
+//Bit 31:24, reserved    
+//Bit 23:16, reg_srscl1_uk_grad2dadja_lv2   lev2, d_adja level limit for 3rd piece;   default = 128;
+//Bit 15: 8, reg_srscl1_uk_grad2dadja_lv1   lev1, d_adja level limit for 2nd piece;   default = 128;
+//Bit  7: 0, reg_srscl1_uk_grad2dadja_lv0   lev0, d_adja level limit for 1st piece;   default = 128;
+#define SRSCL1_UK_BST_GAIN                         ((0x3125  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_bst_cgain           Gain to Uk_diag, normalized to 32 as 1  default = 122;
+//Bit 23:16, reg_srscl1_bst_ygain           Gain to Uk_adja, normalized to 32 as 1  default = 122;
+//Bit 15: 8, reg_srscl1_uk_adja_gain        Boost gain to delta component of SR scalar refine for luma channel. It is applied to tDiv.
+//                                          Normalized to 128 as 1  default = 58;
+//Bit  7: 0, reg_srscl1_uk_diag_gain        Boost gain to delta component of SR scalar refine for chroma channel. It is applied to tDiv.
+//                                          Normalized to 128 as 1  default = 80;
+#define SRSCL1_HVBLEND_TH                          ((0x3126  << 2) + 0xd0100000)
+//Bit 31:29, reserved 
+//Bit 28:24, reg_srscl1_hvblend_th3         Rate threshold to decide HV protection blend rate, default = 8;
+//Bit 23:21, reserved 
+//Bit 20:16, reg_srscl1_hvblend_th2         the same as above;  default = 8;
+//Bit 15:13, reserved 
+//Bit 12: 8, reg_srscl1_hvblend_th1         the same as above;  default = 4;
+//Bit  7: 5, reserved 
+//Bit  4: 0, reg_srscl1_hvblend_th0         the same as above;  default = 4;
+#define SRSCL1_DEMO_WIND_TB                        ((0x3127  << 2) + 0xd0100000)
+//Bit 31:29, reserved 
+//Bit 28:16, reg_srscl1_demo_wind_top       Demo mode window vertical top boundary range;  default = 8191;
+//Bit 15:13, reserved 
+//Bit 12: 0, reg_srscl1_demo_wind_bot       Demo mode window vertical bottom boundary range;  default = 0;
+#define SRSCL1_DEMO_WIND_LR                        ((0x3128  << 2) + 0xd0100000)
+//Bit 31:29, reserved 
+//Bit 28:16, reg_srscl1_demo_wind_right     Demo mode window vertical right boundary range;  default = 8191;
+//Bit 15:13, reserved 
+//Bit 12: 0, reg_srscl1_demo_wind_left      Demo mode window vertical left boundary range;  default = 0;
+#define SRSCL1_INT_BLANK_NUM                       ((0x3129  << 2) + 0xd0100000)
+//Bit 31:21, reserved  
+//Bit    20, reg_srscl1_rst_syn_en          for syn same control reg to rst_n posedge. default=0;
+//Bit 19:16, reg_srscl1_inbuf_hsk_stuff     default=2
+//Bit 15: 8, reg_srscl1_int_vbk_num         interpolation vertical   blank num   default=24
+//Bit  7: 0, reg_srscl1_int_hbk_num         interpolation horizontal blank num   default=8
+#define SRSCL_FRM_END_STAT                         ((0x312a  << 2) + 0xd0100000)
+//Bit 31: 1, reserved  
+//Bit     0, reg_frm_end_stat               frame end status   default=0
+#define SRSCL1_YBIC_HCOEF0                         ((0x312b  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_y_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_y_bic_hcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_y_bic_hcoef01         the same as above; default=128                        
+//Bit  7: 0, reg_srscl1_y_bic_hcoef00         the same as above; default=0
+#define SRSCL1_CBIC_HCOEF0                         ((0x312c  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_c_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_c_bic_hcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_c_bic_hcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl1_c_bic_hcoef00         the same as above; default=0
+#define SRSCL1_YBIC_VCOEF0                         ((0x312d  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_y_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_y_bic_vcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_y_bic_vcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl1_y_bic_vcoef00         the same as above; default=0
+#define SRSCL1_CBIC_VCOEF0                         ((0x312e  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_c_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_c_bic_vcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_c_bic_vcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl1_c_bic_vcoef00         the same as above; default=0
+////=================================================================////
+//// super scaler core 1
+////=================================================================////
+#define OSDSR_HV_SIZEIN                            ((0x3130  << 2) + 0xd0100000)
+//Bit 31:29, reserved  
+//Bit 28:16, reg_srscl1_hsize               image horizontal size (number of cols)   default=2048 
+//Bit 15:13, reserved                       
+//Bit 12: 0, reg_srscl1_vsize               image vertical size   (number of rows)   default=2048
+#define OSDSR_CTRL_MODE                            ((0x3131  << 2) + 0xd0100000)
+//Bit 31:16, reserved     
+//Bit 15,    reg_srscl1_cmpmux_aft           u1: 0 no swap anf for YUV->YUV; 1, swapped and for GBR-RGB; default = 0
+//Bit 14,    reg_srscl1_cmpmux_bef           u1: 0 no swap anf for YUV->YUV; 1, swapped and for RGB->GBR; default = 0
+//Bit 13,    reg_srscl1_bic_norm             normalization of bicubical: 0: 128|128; 1: 64|64  default = 0
+//Bit 12,    reg_srscl1_3dint_mode           option for line-by-line 3D cases     default = 0
+//Bit 11,    reg_srscl1_3dint_hadj_cub       option for using cubic interpolation for horizontal adjacent pixels     default = 0
+//Bit 10,    reg_srscl1_3dint_phase          phase for super-scalar output under 1Vx2H ration: 0: 0 phase, 1: 1/2 phase     default = 0
+//Bit 9,     reg_srscl1_cuse_bic_od          outside demo window chroma use bicubical interpolation    default = 0
+//Bit 8,     reg_srscl1_yuse_bic_od          outside demo window luma use bicubical interpolation    default = 0
+//Bit 7,     reg_srscl1_ause_bic_od          outside demo window alpha use bicubical interpolation    default = 0
+//Bit 6,     reg_srscl1_cuse_bic             inside demo window luma use bicubical interpolation 
+//                                           0: demo window us SR scalar for chroma channel;  
+//                                           1: demo window use Bi-cubic scalar for chroma channel        default = 0
+//Bit 5,     reg_srscl1_yuse_bic             inside demo window luma use bicubical interpolation 
+//                                           0: demo window us SR scalar for luma channel;  
+//                                           1: demo window use Bi-cubic scalar for luma channel        default = 0
+//Bit 4,     reg_srscl1_ause_bic             inside demo window alpha use bicubical interpolation 
+//                                           0: demo window us SR scalar for alpha channel;  
+//                                           1: demo window use Bi-cubic scalar for alpha channel        default = 0
+//Bit 3,     reg_srscl1_use_3lrln            Options to extend 3 lines low-resolution data to 5-lines for SR scalar, (for core_0):
+//                                           0: normal working mode, using 5 lines 
+//                                           1: extend effective 3 lines to 5 lines; (will be used in line-by-line 3D contents)         default = 
+//Bit 2,     reg_srscl1_vert_ratio           Vertical scalar ratio of Super Scalar core_0;
+//                                           0: 1x scale; 1: 2x scale;    default = 
+//Bit 1,     reg_srscl1_hori_ratio           Horizontal scalar ratio of Super Scalar core_0;
+//                                           0: 1x scale; 1: 2x scale;    default = 
+//Bit 0,     reg_srscl1_enable               Enable of Super Scalar core_0: 
+//                                           0: disable (bypass) 1: enable    default = 
+#define OSDSR_ABIC_HCOEF                           ((0x3132  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_a_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of alpha channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_a_bic_hcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_a_bic_hcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_a_bic_hcoef0         the same as above; default=-8
+#define OSDSR_YBIC_HCOEF                           ((0x3133  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_y_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_y_bic_hcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_y_bic_hcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_y_bic_hcoef0         the same as above; default=-8
+#define OSDSR_CBIC_HCOEF                           ((0x3134  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_c_bic_hcoef3         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_c_bic_hcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_c_bic_hcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_c_bic_hcoef0         the same as above; default=-8
+#define OSDSR_ABIC_VCOEF                           ((0x3135  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_a_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of alpha channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_a_bic_vcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_a_bic_vcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_a_bic_vcoef0         the same as above; default=-8
+#define OSDSR_YBIC_VCOEF                           ((0x3136  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_y_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_y_bic_vcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_y_bic_vcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_y_bic_vcoef0         the same as above; default=-8
+#define OSDSR_CBIC_VCOEF                           ((0x3137  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_c_bic_vcoef3         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                           Filter will be normalized to 128 as 1; default=-8                         
+//Bit 23:16, reg_srscl1_c_bic_vcoef2         the same as above; default=72                         
+//Bit 15: 8, reg_srscl1_c_bic_vcoef1         the same as above; default=72                         
+//Bit  7: 0, reg_srscl1_c_bic_vcoef0         the same as above; default=-8
+#define OSDSR_VAR_PARA                             ((0x3138  << 2) + 0xd0100000)
+//Bit 31:26, reserved  
+//Bit 25:24, reg_srscl1_var_adja_rs          Horizontal/vertical adjacent pixel noise normalized variance value right shift bits.  default= 2   
+//Bit 23:16, reg_srscl1_var_adja             Horizontal/vertical adjacent pixel noise normalized variance value. 
+//                                           Var2 = (2^(11+rs))/gain; default= 68
+//Bit 15:10, reserved  
+//Bit  9: 8, reg_srscl1_var_diag_rs          Diagonal pixel noise normalized variance value right shift bits. default= 3    
+//Bit  7: 0, reg_srscl1_var_diag             Diagonal pixel noise normalized variance value. Var2 = (2^(11+rs))/gain; default= 68
+#define OSDSR_CONST_PARA                           ((0x3139  << 2) + 0xd0100000)
+//Bit 31:16, reserved  
+//Bit 15: 8, reg_srscl1_c_adja               Constant for d_adja calculation from wk_nrm; Normalize 128 as 1 default= 32     
+//Bit  7: 0, reg_srscl1_c_diag               Constant for d_diag calculation from wk_nrm; Normalize 128 as 1 default= 32
+#define OSDSR_RKE_EXTWIN                           ((0x313a  << 2) + 0xd0100000)
+//Bit 31:23, reserved  
+//Bit 22:20, reg_srscl1_rke_extwin         Window size for Rke horizontal extension: Win_size = 2x+1 scope: 0~5;  default= 4
+//Bit 19:16, reg_srscl1_rke_coring         Coring to Rke default= 10
+//Bit 15:13, reserved  
+//Bit 12: 8, reg_srscl1_rke_extwin_core    Coring to Rks before local window maximum value calculation     default= 10 
+//Bit  7: 0, reg_srscl1_rke_extwin_rate    Rate to blender strength (gamma), gamma is used to blend local maximum Rke and current Rke; the rate is normalized to 16 as 1  default= 12
+#define OSDSR_UK_GRAD2DDIAG_TH_RATE                ((0x313b  << 2) + 0xd0100000)
+//reg_srscl1_uk_grad2ddiag (0 1 5 6)  Wk_nrm to d_diag mapping curve parameter for UK calculation:         
+//Bit 31:24, reg_srscl1_uk_grad2ddiag_rate1 rate1, d_diag level trasition rate 2nd towards 3rd piece;   default = 20;
+//Bit 23:16, reg_srscl1_uk_grad2ddiag_rate0 rate0, d_diag level trasition rate 2nd towards 1st piece;   default = 80;
+//Bit 15: 8, reg_srscl1_uk_grad2ddiag_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
+//Bit  7: 0, reg_srscl1_uk_grad2ddiag_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
+#define OSDSR_UK_GRAD2DDIAG_LIMIT                  ((0x313c  << 2) + 0xd0100000)
+//reg_srscl1_uk_grad2ddiag (2 3 4)            
+//Bit 31:24, reserved 
+//Bit 23:16, reg_srscl1_uk_grad2ddiag_lv2   lev2, d_diag level limit for 3rd piece;   default = 128;
+//Bit 15: 8, reg_srscl1_uk_grad2ddiag_lv1   lev1, d_diag level limit for 2nd piece;   default = 128;
+//Bit  7: 0, reg_srscl1_uk_grad2ddiag_lv0   lev0, d_diag level limit for 1st piece;   default = 128;
+#define OSDSR_UK_GRAD2DADJA_TH_RATE                ((0x313d  << 2) + 0xd0100000)
+//reg_srscl1_uk_grad2adja (0 1 5 6)  Wk_nrm to d_adja mapping curve parameter for UK calculation:         
+//Bit 31:24, reg_srscl1_uk_grad2dadja_rate1 rate1, d_adja level trasition rate 2nd towards 3rd piece;   default = 20;
+//Bit 23:16, reg_srscl1_uk_grad2dadja_rate0 rate0, d_adja level trasition rate 2nd towards 1st piece;   default = 80;
+//Bit 15: 8, reg_srscl1_uk_grad2dadja_th1   th1, threshold to (c+wk_nrm) for second/3rd piece;   default = 60;
+//Bit  7: 0, reg_srscl1_uk_grad2dadja_th0   th0, threshold to (c+wk_nrm) for first/second piece;   default = 25;
+#define OSDSR_UK_GRAD2DADJA_LIMIT                  ((0x313e  << 2) + 0xd0100000)
+//reg_srscl1_uk_grad2dadja (2 3 4)            
+//Bit 31:24, reserved    
+//Bit 23:16, reg_srscl1_uk_grad2dadja_lv2   lev2, d_adja level limit for 3rd piece;   default = 128;
+//Bit 15: 8, reg_srscl1_uk_grad2dadja_lv1   lev1, d_adja level limit for 2nd piece;   default = 128;
+//Bit  7: 0, reg_srscl1_uk_grad2dadja_lv0   lev0, d_adja level limit for 1st piece;   default = 128;
+#define OSDSR_UK_BST_GAIN                          ((0x313f  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_bst_cgain           Gain to Uk_diag, normalized to 32 as 1  default = 122;
+//Bit 23:16, reg_srscl1_bst_ygain           Gain to Uk_adja, normalized to 32 as 1  default = 122;
+//Bit 15: 8, reg_srscl1_uk_adja_gain        Boost gain to delta component of SR scalar refine for luma channel. It is applied to tDiv.
+//                                          Normalized to 128 as 1  default = 58;
+//Bit  7: 0, reg_srscl1_uk_diag_gain        Boost gain to delta component of SR scalar refine for chroma channel. It is applied to tDiv.
+//                                          Normalized to 128 as 1  default = 80;
+#define OSDSR_HVBLEND_TH                           ((0x3140  << 2) + 0xd0100000)
+//Bit 31:29, reserved 
+//Bit 28:24, reg_srscl1_hvblend_th3         Rate threshold to decide HV protection blend rate, default = 8;
+//Bit 23:21, reserved 
+//Bit 20:16, reg_srscl1_hvblend_th2         the same as above;  default = 8;
+//Bit 15:13, reserved 
+//Bit 12: 8, reg_srscl1_hvblend_th1         the same as above;  default = 4;
+//Bit  7: 5, reserved 
+//Bit  4: 0, reg_srscl1_hvblend_th0         the same as above;  default = 4;
+#define OSDSR_DEMO_WIND_TB                         ((0x3141  << 2) + 0xd0100000)
+//Bit 31:29, reserved 
+//Bit 28:16, reg_srscl1_demo_wind_top       Demo mode window vertical top boundary range;  default = 8191;
+//Bit 15:13, reserved 
+//Bit 12: 0, reg_srscl1_demo_wind_bot       Demo mode window vertical bottom boundary range;  default = 0;
+#define OSDSR_DEMO_WIND_LR                         ((0x3142  << 2) + 0xd0100000)
+//Bit 31:29, reserved 
+//Bit 28:16, reg_srscl1_demo_wind_right     Demo mode window vertical right boundary range;  default = 8191;
+//Bit 15:13, reserved 
+//Bit 12: 0, reg_srscl1_demo_wind_left      Demo mode window vertical left boundary range;  default = 0;
+#define OSDSR_INT_BLANK_NUM                        ((0x3143  << 2) + 0xd0100000)
+//Bit 31:21, reserved  
+//Bit    20, reg_srscl1_rst_syn_en          for syn same control reg to rst_n posedge. default=0;
+//Bit 19:16, reg_srscl1_inbuf_hsk_stuff     default=2
+//Bit 15: 8, reg_srscl1_int_vbk_num         interpolation vertical   blank num   default=24
+//Bit  7: 0, reg_srscl1_int_hbk_num         interpolation horizontal blank num   default=8
+#define OSDSR_FRM_END_STAT                         ((0x3144  << 2) + 0xd0100000)
+//Bit 31: 1, reserved  
+//Bit     0, reg_frm_end_stat               frame end status   default=0
+#define OSDSR_ABIC_HCOEF0                          ((0x3145  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_a_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_a_bic_hcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_a_bic_hcoef01         the same as above; default=128                        
+//Bit  7: 0, reg_srscl1_a_bic_hcoef00         the same as above; default=0
+#define OSDSR_YBIC_HCOEF0                          ((0x3146  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_y_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_y_bic_hcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_y_bic_hcoef01         the same as above; default=128                        
+//Bit  7: 0, reg_srscl1_y_bic_hcoef00         the same as above; default=0
+#define OSDSR_CBIC_HCOEF0                          ((0x3147  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_c_bic_hcoef03         Horizontal bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_c_bic_hcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_c_bic_hcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl1_c_bic_hcoef00         the same as above; default=0
+#define OSDSR_ABIC_VCOEF0                          ((0x3148  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_a_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_a_bic_vcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_a_bic_vcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl1_a_bic_vcoef00         the same as above; default=0
+#define OSDSR_YBIC_VCOEF0                          ((0x3149  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_y_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of luma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_y_bic_vcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_y_bic_vcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl1_y_bic_vcoef00         the same as above; default=0
+#define OSDSR_CBIC_VCOEF0                          ((0x314a  << 2) + 0xd0100000)
+//Bit 31:24, reg_srscl1_c_bic_vcoef03         Vertical bi-cubic filter of 0.5 phase of chroma channel (for core_0)
+//                                            Filter will be normalized to 128 as 1; default=0                         
+//Bit 23:16, reg_srscl1_c_bic_vcoef02         the same as above; default=0                         
+//Bit 15: 8, reg_srscl1_c_bic_vcoef01         the same as above; default=128                         
+//Bit  7: 0, reg_srscl1_c_bic_vcoef00         the same as above; default=0
+//
+// Reading file:  xvycc_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//    `define XVYCC_VCBUS_BASE	   8'hfe
+#define XVYCC_INV_LUT_Y_ADDR_PORT                  ((0x3158  << 2) + 0xd0100000)
+//Bit 31:7, reserved  
+//Bit  6:0,  xvycc_inv_lut_y_addr;
+#define XVYCC_INV_LUT_Y_DATA_PORT                  ((0x3159  << 2) + 0xd0100000)
+//Bit 31:12, reserved  
+//Bit  11:0, xvycc_inv_lut_y_data;
+#define XVYCC_INV_LUT_U_ADDR_PORT                  ((0x315a  << 2) + 0xd0100000)
+//Bit 31:6, reserved  
+//Bit  5:0,  xvycc_inv_lut_u_addr;
+#define XVYCC_INV_LUT_U_DATA_PORT                  ((0x315b  << 2) + 0xd0100000)
+//Bit 31:12, reserved  
+//Bit  11:0, xvycc_inv_lut_u_data;
+#define XVYCC_INV_LUT_V_ADDR_PORT                  ((0x315c  << 2) + 0xd0100000)
+//Bit 31:6, reserved  
+//Bit  5:0,  xvycc_inv_lut_v_addr;
+#define XVYCC_INV_LUT_V_DATA_PORT                  ((0x315d  << 2) + 0xd0100000)
+//Bit 31:12, reserved  
+//Bit  11:0, xvycc_inv_lut_v_data;
+#define XVYCC_LUT_R_ADDR_PORT                      ((0x315e  << 2) + 0xd0100000)
+//Bit 31:7, reserved  
+//Bit  6:0,  xvycc_lut_r_addr;
+#define XVYCC_LUT_R_DATA_PORT                      ((0x315f  << 2) + 0xd0100000)
+//Bit 31:10, reserved  
+//Bit  9:0,  xvycc_lut_r_data;
+#define XVYCC_LUT_G_ADDR_PORT                      ((0x3160  << 2) + 0xd0100000)
+//Bit 31:7, reserved  
+//Bit  6:0,  xvycc_lut_g_addr;
+#define XVYCC_LUT_G_DATA_PORT                      ((0x3161  << 2) + 0xd0100000)
+//Bit 31:10, reserved  
+//Bit  9:0,  xvycc_lut_g_data;
+#define XVYCC_LUT_B_ADDR_PORT                      ((0x3162  << 2) + 0xd0100000)
+//Bit 31:7, reserved  
+//Bit  6:0,  xvycc_lut_b_addr;
+#define XVYCC_LUT_B_DATA_PORT                      ((0x3163  << 2) + 0xd0100000)
+//Bit 31:10, reserved  
+//Bit  9:0,  xvycc_lut_b_data;
+#define XVYCC_INV_LUT_CTL                          ((0x3164  << 2) + 0xd0100000)
+//Bit 31:15, reserved  
+//Bit 14:12, reg_xvycc_cmpr_invlut_enable    enable for xvycc compression inverse-lut [2] for Y, [1] for U, [0] for V default=0
+//Bit 11:10, reg_xvycc_cmpr_invlut_vscl_1   v LUT input scale for positive portion   default=0
+//Bit  9: 8, reg_xvycc_cmpr_invlut_vscl_0   v LUT input scale for negative portion   default=0
+//Bit  7: 6, reg_xvycc_cmpr_invlut_uscl_1   u LUT input scale for positive portion   default=0
+//Bit  5: 4, reg_xvycc_cmpr_invlut_uscl_0   u LUT input scale for negative portion   default=0
+//Bit  3: 2, reg_xvycc_cmpr_invlut_yscl_1   y LUT input scale for positive portion   default=0
+//Bit  1: 0, reg_xvycc_cmpr_invlut_yscl_0   y LUT input scale for negative portion   default=0
+#define XVYCC_LUT_CTL                              ((0x3165  << 2) + 0xd0100000)
+//Bit 31: 7, reserved  
+//Bit  6: 4, reg_xvycc_lut_enable  LUT enable [6] for R, [5] for G, [4] for B  default=0
+//Bit  3: 2, reg_xvycc_lut_scl_1   LUT input scale for positive portion   default=0
+//Bit  1: 0, reg_xvycc_lut_scl_0   LUT input scale for negative portion   default=0
+#define XVYCC_VADJ1_CURV_0                         ((0x3166  << 2) + 0xd0100000)
+//Bit 31:24, vadj1_softcon_curv0_ci                         default=0
+//Bit 23:12, vadj1_softcon_curv0_b                          default=0
+//Bit 11: 0, vadj1_softcon_curv0_a                          default=0
+#define XVYCC_VADJ1_CURV_1                         ((0x3167  << 2) + 0xd0100000)
+//Bit 31:13, reserved
+//Bit 12: 4, vadj1_softcon_curv0_g                          default=0
+//Bit     3, reserved
+//Bit  2: 0, vadj1_softcon_curv0_cs                         default=0
+#define XVYCC_VADJ1_CURV_2                         ((0x3168  << 2) + 0xd0100000)
+//Bit 31:24, vadj1_softcon_curv1_ci                         default=0
+//Bit 23:12, vadj1_softcon_curv1_b                          default=0
+//Bit 11: 0, vadj1_softcon_curv1_a                          default=0
+#define XVYCC_VADJ1_CURV_3                         ((0x3169  << 2) + 0xd0100000)
+//Bit 31:13, reserved
+//Bit 12: 4, vadj1_softcon_curv1_g                          default=0
+//Bit     3, reserved
+//Bit  2: 0, vadj1_softcon_curv1_cs                         default=0
+#define XVYCC_VADJ2_CURV_0                         ((0x316a  << 2) + 0xd0100000)
+//Bit 31:24, vadj2_softcon_curv0_ci                         default=0
+//Bit 23:12, vadj2_softcon_curv0_b                          default=0
+//Bit 11: 0, vadj2_softcon_curv0_a                          default=0
+#define XVYCC_VADJ2_CURV_1                         ((0x316b  << 2) + 0xd0100000)
+//Bit 31:13, reserved
+//Bit 12: 4, vadj2_softcon_curv0_g                          default=0
+//Bit     3, reserved
+//Bit  2: 0, vadj2_softcon_curv0_cs                         default=0
+#define XVYCC_VADJ2_CURV_2                         ((0x316c  << 2) + 0xd0100000)
+//Bit 31:24, vadj2_softcon_curv1_ci                         default=0
+//Bit 23:12, vadj2_softcon_curv1_b                          default=0
+//Bit 11: 0, vadj2_softcon_curv1_a                          default=0
+#define XVYCC_VADJ2_CURV_3                         ((0x316d  << 2) + 0xd0100000)
+//Bit 31:13, reserved
+//Bit 12: 4, vadj2_softcon_curv1_g                          default=0
+//Bit     3, reserved
+//Bit  2: 0, vadj2_softcon_curv1_cs                         default=0
+#define XVYCC_VD1_RGB_CTRST                        ((0x3170  << 2) + 0xd0100000)
+//Bit 31:28, reserved    
+//Bit 27:16, reg_vd1_rgb_ctrst        u12, contrast in rgb.      default=1024
+//Bit 15:14, reserved  
+//Bit 13: 4, reg_vd1_rgb_ctrst_blklvl u10, contrast blacklevel   default=64 
+//Bit  3: 2, reserved  
+//Bit     1, reg_vd1_rgbbst_en         u1, enable rgbbst         default=0 
+//Bit     0, reg_vd1_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1 
+#define XVYCC_VD1_RGB_BRGHT                        ((0x3171  << 2) + 0xd0100000)
+//Bit 31:16, reserved
+//Bit 15: 4, reg_vd1_rgb_brght        s12, brightness level in rgb domain                              default=0 
+//Bit  3: 2, reserved
+//Bit     1, reg_vd1_rgb_brght_prt     u1, enalbe signal to protect saturation in rgb                  default=1
+//Bit     0, reg_vd1_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
+#define XVYCC_VD1_RGB_DLUT_0_3                     ((0x3172  << 2) + 0xd0100000)
+//Bit 31:24, reg_vd1_rgbbst_dlut0      u8,   default = 255
+//Bit 23:16, reg_vd1_rgbbst_dlut1      u8,   default = 205
+//Bit 15: 8, reg_vd1_rgbbst_dlut2      u8,   default = 171
+//Bit  7: 0, reg_vd1_rgbbst_dlut3      u8,   default = 147 
+#define XVYCC_VD1_RGB_DLUT_4_7                     ((0x3173  << 2) + 0xd0100000)
+//Bit 31:24, reg_vd1_rgbbst_dlut4      u8,   default = 128
+//Bit 23:16, reg_vd1_rgbbst_dlut5      u8,   default = 113
+//Bit 15: 8, reg_vd1_rgbbst_dlut6      u8,   default = 102
+//Bit  7: 0, reg_vd1_rgbbst_dlut7      u8,   default = 93 
+#define XVYCC_VD1_RGB_DLUT_8_11                    ((0x3174  << 2) + 0xd0100000)
+//Bit 31:24, reg_vd1_rgbbst_dlut8      u8,   default = 85
+//Bit 23:16, reg_vd1_rgbbst_dlut9      u8,   default = 78
+//Bit 15: 8, reg_vd1_rgbbst_dlut10     u8,   default = 73
+//Bit  7: 0, reg_vd1_rgbbst_dlut11     u8,   default = 68 
+#define XVYCC_POST_RGB_CTRST                       ((0x3175  << 2) + 0xd0100000)
+//Bit 31:28, reserved    
+//Bit 27:16, reg_post_rgb_ctrst        u12, contrast in rgb.      default=1024
+//Bit 15:14, reserved  
+//Bit 13: 4, reg_post_rgb_ctrst_blklvl u10, contrast blacklevel   default=64 
+//Bit  3: 2, reserved 
+//Bit     1, reg_post_rgbbst_en         u1, enable rgbbst         default=0 
+//Bit     0, reg_post_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1 
+#define XVYCC_POST_RGB_BRGHT                       ((0x3176  << 2) + 0xd0100000)
+//Bit 31:16, reserved
+//Bit 15: 4, reg_post_rgb_brght        s12, brightness level in rgb domain                              default=0 
+//Bit  3: 2, reserved
+//Bit     1, reg_post_rgb_brght_prt     u1, enalbe signal to protect saturation in rgb                  default=1
+//Bit     0, reg_post_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
+#define XVYCC_POST_RGB_DLUT_0_3                    ((0x3177  << 2) + 0xd0100000)
+//Bit 31:24, reg_post_rgbbst_dlut0      u8,   default = 255
+//Bit 23:16, reg_post_rgbbst_dlut1      u8,   default = 205
+//Bit 15: 8, reg_post_rgbbst_dlut2      u8,   default = 171
+//Bit  7: 0, reg_post_rgbbst_dlut3      u8,   default = 147 
+#define XVYCC_POST_RGB_DLUT_4_7                    ((0x3178  << 2) + 0xd0100000)
+//Bit 31:24, reg_post_rgbbst_dlut4      u8,   default = 128
+//Bit 23:16, reg_post_rgbbst_dlut5      u8,   default = 113
+//Bit 15: 8, reg_post_rgbbst_dlut6      u8,   default = 102
+//Bit  7: 0, reg_post_rgbbst_dlut7      u8,   default = 93 
+#define XVYCC_POST_RGB_DLUT_8_11                   ((0x3179  << 2) + 0xd0100000)
+//Bit 31:24, reg_post_rgbbst_dlut8      u8,   default = 85
+//Bit 23:16, reg_post_rgbbst_dlut9      u8,   default = 78
+//Bit 15: 8, reg_post_rgbbst_dlut10     u8,   default = 73
+//Bit  7: 0, reg_post_rgbbst_dlut11     u8,   default = 68 
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  xvycc_regs.h
+//
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//  index + data
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+//// // note there are some space in the header
+//// 
+//// 
+//// //////////////////////////////////////////////////////////////////////////////////////////////////////
+//// // read-only registers
+//// //////////////////////////////////////////////////////////////////////////////////////////////////////
+//// 
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  srscl_reg.h
+//
+//
+// Reading file:  sharp_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+#define SHARP_HVSIZE                               ((0x3180  << 2) + 0xd0100000)
+//Bit 31:29,        reserved                           
+//Bit 28:16,        reg_pknr_hsize                                                                                                              . unsigned  , default = 1920
+//Bit 15:13,        reserved                           
+//Bit 12: 0,        reg_pknr_vsize                                                                                                              . unsigned  , default = 1080
+#define SHARP_HVBLANK_NUM                          ((0x3181  << 2) + 0xd0100000)
+//Bit 31:16,        reserved                           
+//Bit 15: 8,        reg_pknr_hblank_num                                                                                                         . unsigned  , default = 20   
+//Bit  7: 0,        reg_pknr_vblank_num                                                                                                         . unsigned  , default = 60   
+#define NR_GAUSSIAN_MODE                           ((0x3182  << 2) + 0xd0100000)
+//Bit 31: 5,        reserved                           
+//Bit  4,            reg_nr_gau_ymode                            : 0 3x3 filter; 1: 5x5 filter                                                   . unsigned  , default = 1   
+//Bit  3: 1,        reserved                           
+//Bit  0,            reg_nr_gau_cmode                            : 0 3x3 filter; 1: 5x5 filter                                                   . unsigned  , default = 1   
+#define PK_HVCON_LPF_MODE                          ((0x3183  << 2) + 0xd0100000)
+//Bit 31:30,        reserved                           
+//Bit 29:28,        reg_pk_hconhpf_mode                         : 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter         . unsigned  , default = 2   
+//Bit 27:26,        reserved                           
+//Bit 25:24,        reg_pk_hconbpf_mode                         : 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter         . unsigned  , default = 2   
+//Bit 23:22,        reserved                           
+//Bit 21:20,        reg_pk_hconlbpf_mode                        : 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter         . unsigned  , default = 2   
+//Bit 19:18,        reserved                           
+//Bit 17:16,        reg_pk_hconllbpf_mode                       : 0: no vertical filter;1:[1 2 1]'/4 filter; 2/3: [1 2 2 2 1]'/8 filter         . unsigned  , default = 2   
+//Bit 15:14,        reserved                           
+//Bit 13:12,        reg_pk_vconhpf_mode                         : 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. unsigned  , default = 2   
+//Bit 11:10,        reserved                           
+//Bit  9: 8,        reg_pk_vconbpf_mode                         : 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. unsigned  , default = 2   
+//Bit  7: 6,        reserved                           
+//Bit  5: 4,        reg_pk_vconlbpf_mode                        : 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. unsigned  , default = 2   
+//Bit  3: 2,        reserved                           
+//Bit  1: 0,        reg_pk_vconllbpf_mode                       : 0: no horizontal filter;1:[1 2 1]/4 filter; 2: [1 2 2 2 1]/8 filter; 3: [1 2 3 4 3 2 1]/16 filter. unsigned  , default = 2   
+#define PK_CON_BLEND_GAIN                          ((0x3184  << 2) + 0xd0100000)
+//Bit 31:28,        reg_pk_hpcon_hpgain                         : 8 as normalized 1                                                             . unsigned  , default = 4   
+//Bit 27:24,        reg_pk_hpcon_bpgain                         : 8 as normalized 1                                                             . unsigned  , default = 4   
+//Bit 23:20,        reg_pk_hpcon_lbpgain                        : 8 as normalized 1                                                             . unsigned  , default = 0   
+//Bit 19:16,        reg_pk_hpcon_llbpgain                       : 8 as normalized 1                                                             . unsigned  , default = 0   
+//Bit 15:12,        reg_pk_bpcon_hpgain                         : 8 as normalized 1                                                             . unsigned  , default = 0   
+//Bit 11: 8,        reg_pk_bpcon_bpgain                         : 8 as normalized 1                                                             . unsigned  , default = 2   
+//Bit  7: 4,        reg_pk_bpcon_lbpgain                        : 8 as normalized 1                                                             . unsigned  , default = 6   
+//Bit  3: 0,        reg_pk_bpcon_llbpgain                       : 8 as normalized 1                                                             . unsigned  , default = 0   
+#define PK_CON_2CIRHPGAIN_TH_RATE                  ((0x3185  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_cirhpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 25  
+//Bit 23:16,        reg_pk_cirhpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 60  
+//Bit 15: 8,        reg_pk_cirhpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 80  
+//Bit  7: 0,        reg_pk_cirhpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 20  
+#define PK_CON_2CIRHPGAIN_LIMIT                    ((0x3186  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_cirhpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 96  
+//Bit 23:16,        reg_pk_cirhpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 96  
+//Bit 15: 8,        reg_pk_cirhpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 5   
+//Bit  7: 0,        reserved                           
+#define PK_CON_2CIRBPGAIN_TH_RATE                  ((0x3187  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_cirbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 20  
+//Bit 23:16,        reg_pk_cirbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same).. unsigned  , default = 50  
+//Bit 15: 8,        reg_pk_cirbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 50  
+//Bit  7: 0,        reg_pk_cirbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 25  
+#define PK_CON_2CIRBPGAIN_LIMIT                    ((0x3188  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_cirbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 40  
+//Bit 23:16,        reg_pk_cirbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 40  
+//Bit 15: 8,        reg_pk_cirbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 5   
+//Bit  7: 0,        reserved                           
+#define PK_CON_2DRTHPGAIN_TH_RATE                  ((0x3189  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_drthpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 25  
+//Bit 23:16,        reg_pk_drthpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 60  
+//Bit 15: 8,        reg_pk_drthpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 80  
+//Bit  7: 0,        reg_pk_drthpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 20  
+#define PK_CON_2DRTHPGAIN_LIMIT                    ((0x318a  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_drthpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction).. unsigned  , default = 90  
+//Bit 23:16,        reg_pk_drthpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 96  
+//Bit 15: 8,        reg_pk_drthpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 5   
+//Bit  7: 0,        reserved                           
+#define PK_CON_2DRTBPGAIN_TH_RATE                  ((0x318b  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_drtbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 20  
+//Bit 23:16,        reg_pk_drtbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50  
+//Bit 15: 8,        reg_pk_drtbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50  
+//Bit  7: 0,        reg_pk_drtbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 25  
+#define PK_CON_2DRTBPGAIN_LIMIT                    ((0x318c  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_drtbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 40  
+//Bit 23:16,        reg_pk_drtbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 40  
+//Bit 15: 8,        reg_pk_drtbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 5   
+//Bit  7: 0,        reserved                           
+#define PK_CIRFB_LPF_MODE                          ((0x318d  << 2) + 0xd0100000)
+//Bit 31:30,        reserved                           
+//Bit 29:28,        reg_cirhp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1   
+//Bit 27:26,        reserved                           
+//Bit 25:24,        reg_cirhp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1   
+//Bit 23:22,        reserved                           
+//Bit 21:20,        reg_cirhp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1   
+//Bit 19:14,        reserved                           
+//Bit 13:12,        reg_cirbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1   
+//Bit 11:10,        reserved                           
+//Bit  9: 8,        reg_cirbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1   
+//Bit  7: 6,        reserved                           
+//Bit  5: 4,        reg_cirbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1   
+//Bit  3: 0,        reserved                           
+#define PK_DRTFB_LPF_MODE                          ((0x318e  << 2) + 0xd0100000)
+//Bit 31:30,        reserved                           
+//Bit 29:28,        reg_drthp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1   
+//Bit 27:26,        reserved                           
+//Bit 25:24,        reg_drthp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1   
+//Bit 23:22,        reserved                           
+//Bit 21:20,        reg_drthp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1   
+//Bit 19:14,        reserved                           
+//Bit 13:12,        reg_drtbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1   
+//Bit 11:10,        reserved                           
+//Bit  9: 8,        reg_drtbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1   
+//Bit  7: 6,        reserved                           
+//Bit  5: 4,        reg_drtbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1   
+//Bit  3: 0,        reserved                           
+#define PK_CIRFB_HP_CORING                         ((0x318f  << 2) + 0xd0100000)
+//Bit 31:22,        reserved                           
+//Bit 21:16,        reg_cirhp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 4   
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_cirhp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 4   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_cirhp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 4   
+#define PK_CIRFB_BP_CORING                         ((0x3190  << 2) + 0xd0100000)
+//Bit 31:22,        reserved                           
+//Bit 21:16,        reg_cirbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 4   
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_cirbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 4   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_cirbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 4   
+#define PK_DRTFB_HP_CORING                         ((0x3191  << 2) + 0xd0100000)
+//Bit 31:22,        reserved                           
+//Bit 21:16,        reg_drthp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 4   
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_drthp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 4   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_drthp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 4   
+#define PK_DRTFB_BP_CORING                         ((0x3192  << 2) + 0xd0100000)
+//Bit 31:22,        reserved                           
+//Bit 21:16,        reg_drtbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 4   
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_drtbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 4   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_drtbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 4   
+#define PK_CIRFB_BLEND_GAIN                        ((0x3193  << 2) + 0xd0100000)
+//Bit 31:28,        reg_hp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
+//Bit 27:24,        reg_hp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
+//Bit 23:20,        reg_hp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
+//Bit 19:16,        reserved                           
+//Bit 15:12,        reg_bp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
+//Bit 11: 8,        reg_bp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
+//Bit  7: 4,        reg_bp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8   
+//Bit  3: 0,        reserved                           
+#define NR_ALPY_SSD_GAIN_OFST                      ((0x3194  << 2) + 0xd0100000)
+//Bit 31:16,        reserved                           
+//Bit 15: 8,        reg_nr_alp0_ssd_gain                        : gain to max ssd normalized 16 as '1'                                          . unsigned  , default = 16  
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_nr_alp0_ssd_ofst                        : offset to ssd before dividing to min_err                                      . signed    , default = -2  
+#define NR_ALP0Y_ERR2CURV_TH_RATE                  ((0x3195  << 2) + 0xd0100000)
+//Bit 31:24,        reg_nr_alp0_minerr_ypar0                    : threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255.. unsigned  , default = 10  
+//Bit 23:16,        reg_nr_alp0_minerr_ypar1                    : threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25  
+//Bit 15: 8,        reg_nr_alp0_minerr_ypar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80  
+//Bit  7: 0,        reg_nr_alp0_minerr_ypar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64  
+#define NR_ALP0Y_ERR2CURV_LIMIT                    ((0x3196  << 2) + 0xd0100000)
+//Bit 31:24,        reg_nr_alp0_minerr_ypar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63  
+//Bit 23:16,        reg_nr_alp0_minerr_ypar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0   
+//Bit 15: 8,        reg_nr_alp0_minerr_ypar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63  
+//Bit  7: 0,        reserved                           
+#define NR_ALP0C_ERR2CURV_TH_RATE                  ((0x3197  << 2) + 0xd0100000)
+//Bit 31:24,        reg_nr_alp0_minerr_cpar0                    : threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur.. unsigned  , default = 10  
+//Bit 23:16,        reg_nr_alp0_minerr_cpar1                    : threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25  
+//Bit 15: 8,        reg_nr_alp0_minerr_cpar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80  
+//Bit  7: 0,        reg_nr_alp0_minerr_cpar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64  
+#define NR_ALP0C_ERR2CURV_LIMIT                    ((0x3198  << 2) + 0xd0100000)
+//Bit 31:24,        reg_nr_alp0_minerr_cpar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63  
+//Bit 23:16,        reg_nr_alp0_minerr_cpar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0   
+//Bit 15: 8,        reg_nr_alp0_minerr_cpar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63  
+//Bit  7: 0,        reserved                           
+#define NR_ALP0_MIN_MAX                            ((0x3199  << 2) + 0xd0100000)
+//Bit 31:30,        reserved                           
+//Bit 29:24,        reg_nr_alp0_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 2   
+//Bit 23:22,        reserved                           
+//Bit 21:16,        reg_nr_alp0_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63  
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_nr_alp0_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 2   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_nr_alp0_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63  
+#define NR_ALP1_MIERR_CORING                       ((0x319a  << 2) + 0xd0100000)
+//Bit 31:17,        reserved                           
+//Bit 16,            reg_nr_alp1_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 0   
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_nr_alp1_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 0   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_nr_alp1_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 3   
+#define NR_ALP1_ERR2CURV_TH_RATE                   ((0x319b  << 2) + 0xd0100000)
+//Bit 31:24,        reg_nr_alp1_minerr_par0                     : threshold0 of curve to map mierr to alp1 for luma/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255.. unsigned  , default = 0   
+//Bit 23:16,        reg_nr_alp1_minerr_par1                     : threshold1 of curve to map mierr to alp1 for luma/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255.. unsigned  , default = 24  
+//Bit 15: 8,        reg_nr_alp1_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope.. unsigned  , default = 0   
+//Bit  7: 0,        reg_nr_alp1_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255. unsigned  , default = 20  
+#define NR_ALP1_ERR2CURV_LIMIT                     ((0x319c  << 2) + 0xd0100000)
+//Bit 31:24,        reg_nr_alp1_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255.. unsigned  , default = 0   
+//Bit 23:16,        reg_nr_alp1_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255.. unsigned  , default = 16  
+//Bit 15: 8,        reg_nr_alp1_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255.255 before. unsigned  , default = 63  
+//Bit  7: 0,        reserved                           
+#define NR_ALP1_MIN_MAX                            ((0x319d  << 2) + 0xd0100000)
+//Bit 31:30,        reserved                           
+//Bit 29:24,        reg_nr_alp1_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0   
+//Bit 23:22,        reserved                           
+//Bit 21:16,        reg_nr_alp1_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63  
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_nr_alp1_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_nr_alp1_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63  
+#define PK_ALP2_MIERR_CORING                       ((0x319e  << 2) + 0xd0100000)
+//Bit 31:17,        reserved                           
+//Bit 16,            reg_pk_alp2_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 1   
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_pk_alp2_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 13  
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_pk_alp2_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 1   
+#define PK_ALP2_ERR2CURV_TH_RATE                   ((0x319f  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_alp2_minerr_par0                     : threshold0 of curve to map mierr to alp2 for luma channel, this will be set value of flat region mierr that no need peaking.. unsigned  , default = 0   
+//Bit 23:16,        reg_pk_alp2_minerr_par1                     : threshold1 of curve to map mierr to alp2 for luma  channel,this will be set value of texture region mierr that can not do peaking. 0~255.. unsigned  , default = 24  
+//Bit 15: 8,        reg_pk_alp2_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 0   
+//Bit  7: 0,        reg_pk_alp2_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 20  
+#define PK_ALP2_ERR2CURV_LIMIT                     ((0x31a0  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_alp2_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for flat region. 0~255.. unsigned  , default = 0   
+//Bit 23:16,        reg_pk_alp2_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for misc region. 0~255.. unsigned  , default = 16  
+//Bit 15: 8,        reg_pk_alp2_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for texture region. 0~255. default = 63;. unsigned  , default = 255 
+//Bit  7: 0,        reserved                           
+#define PK_ALP2_MIN_MAX                            ((0x31a1  << 2) + 0xd0100000)
+//Bit 31:14,        reserved                           
+//Bit 13: 8,        reg_pk_alp2_min                             : normalized to 64 as '1'                                                       . unsigned  , default = 0   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_pk_alp2_max                             : normalized to 64 as '1'                                                       . unsigned  , default = 63  
+#define PK_FINALGAIN_HP_BP                         ((0x31a2  << 2) + 0xd0100000)
+//Bit 31:16,        reserved                           
+//Bit 15: 8,        reg_hp_final_gain                           : gain to highpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 40  
+//Bit  7: 0,        reg_bp_final_gain                           : gain to bandpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 30  
+#define PK_OS_HORZ_CORE_GAIN                       ((0x31a3  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_os_hsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8   
+//Bit 23:16,        reg_pk_os_hsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20  
+//Bit 15: 8,        reg_pk_os_hmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2   
+//Bit  7: 0,        reg_pk_os_hmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20  
+#define PK_OS_VERT_CORE_GAIN                       ((0x31a4  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_os_vsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8   
+//Bit 23:16,        reg_pk_os_vsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20  
+//Bit 15: 8,        reg_pk_os_vmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2   
+//Bit  7: 0,        reg_pk_os_vmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20  
+#define PK_OS_ADPT_MISC                            ((0x31a5  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_os_minerr_core                       : coring to minerr for adaptive overshoot margin. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 40  
+//Bit 23:16,        reg_pk_os_minerr_gain                       : gain to minerr based adaptive overshoot margin. normalized to 64 as '1'. 0~255;. unsigned  , default = 6   
+//Bit 15: 8,        reg_pk_os_adpt_max                          : maximum limit adaptive overshoot margin (4x). 0~255;                          . unsigned  , default = 200 
+//Bit  7: 0,        reg_pk_os_adpt_min                          : minimun limit adaptive overshoot margin (1x). 0~255;                          . unsigned  , default = 20  
+#define PK_OS_STATIC                               ((0x31a6  << 2) + 0xd0100000)
+//Bit 31:30,        reserved                           
+//Bit 29:28,        reg_pk_osh_mode                             : 0~3: (2x+1) window in H direction                                             . unsigned  , default = 2   
+//Bit 27:26,        reserved                           
+//Bit 25:24,        reg_pk_osv_mode                             : 0~3: (2x+1) window in V direction                                             . unsigned  , default = 2   
+//Bit 23:22,        reserved                           
+//Bit 21:12,        reg_pk_os_down                              : static negative overshoot margin. 0~1023;                                     . unsigned  , default = 200 
+//Bit 11:10,        reserved                           
+//Bit  9: 0,        reg_pk_os_up                                : static positive overshoot margin. 0~1023;                                     . unsigned  , default = 200 
+#define PK_NR_ENABLE                               ((0x31a7  << 2) + 0xd0100000)
+//Bit 31: 4,        reserved                           
+//Bit  3: 2,        reg_3d_mode                                 , 0: no 3D; 1: L/R; 2: T/B; 3: horizontal interleaved, dft = 0                                             //. unsigned  , default = 0   
+//Bit  1,            reg_pk_en                                                                                                                   . unsigned  , default = 1   
+//Bit  0,            reg_nr_en                                                                                                                   . unsigned  , default = 1   
+#define PK_DRT_SAD_MISC                            ((0x31a8  << 2) + 0xd0100000)
+//Bit 31:24,        reg_pk_sad_ver_gain                         : gain to sad[4], 16 normalized to "1";                                         . unsigned  , default = 24  
+//Bit 23:16,        reg_pk_sad_hor_gain                         : gain to sad[0], 16 normalized to "1";                                         . unsigned  , default = 24  
+//Bit 15:11,        reserved                           
+//Bit 10: 9,        reg_pk_bias_diag                            : bias towards diag                                                             . unsigned  , default = 0   
+//Bit  8,            reg_pk_debug_edge                           : show color for edge                                                           . unsigned  , default = 0   
+//Bit  7: 5,        reserved                           
+//Bit  4: 0,        reg_pk_drt_force                            : force direction of drt peaking filter, h2b: 0:hp drt force, 1: bp drt force; 2: bp+hp drt force, 3: no force;. unsigned  , default = 24  
+#define NR_TI_DNLP_BLEND                           ((0x31a9  << 2) + 0xd0100000)
+//Bit 31:11,        reserved                           
+//Bit 10: 8,        reg_dnlp_input_mode                         : dnlp input options. 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os). unsigned  , default = 4   
+//Bit  7: 4,        reserved                           
+//Bit  3: 2,        reg_nr_cti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:cti; 2: (nr+cti)/2; 3:cti + dlt_nr  . unsigned  , default = 1   
+//Bit  1: 0,        reg_nr_lti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:lti; 2: (nr+lti)/2; 3:lti + dlt_nr  . unsigned  , default = 1   
+////////////////////////////////////////////////////////////////////////////////
+// new ti regsters from here
+////////////////////////////////////////////////////////////////////////////////
+#define LTI_DIR_CORE_ALPHA                         ((0x31aa  << 2) + 0xd0100000)
+//Bit 31:30,        reserved                           
+//Bit 29:24,        reg_adp_lti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 10  
+//Bit 23:20,        reserved                           
+//Bit 19:16,        reg_adp_lti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0   
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_adp_lti_dir_alpmin                      : min value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=10              . unsigned  , default = 0   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_adp_lti_dir_alpmax                      : max value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=63              . unsigned  , default = 63  
+#define CTI_DIR_ALPHA                              ((0x31ab  << 2) + 0xd0100000)
+//Bit 31:30,        reserved                           
+//Bit 29:24,        reg_adp_cti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 5   
+//Bit 23:20,        reserved                           
+//Bit 19:16,        reg_adp_cti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0   
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_adp_cti_dir_alpmin                      : min value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=10             . unsigned  , default = 0   
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_adp_cti_dir_alpmax                      : max value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=63             . unsigned  , default = 63  
+#define LTI_CTI_DF_GAIN                            ((0x31ac  << 2) + 0xd0100000)
+//Bit 31:30,        reserved                           
+//Bit 29:24,        reg_adp_lti_hdf_gain                        : 8 normalized to "1";  default = 16                                            . unsigned  , default = 16  
+//Bit 23:22,        reserved                           
+//Bit 21:16,        reg_adp_lti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12  
+//Bit 15:14,        reserved                           
+//Bit 13: 8,        reg_adp_cti_hdf_gain                        : 8 normalized to "1";  default = 16                                            . unsigned  , default = 16  
+//Bit  7: 6,        reserved                           
+//Bit  5: 0,        reg_adp_cti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12  
+#define LTI_CTI_DIR_AC_DBG                         ((0x31ad  << 2) + 0xd0100000)
+//Bit 31,            reserved                           
+//Bit 30,            reg_adp_lti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf                                               . unsigned  , default = 1   
+//Bit 29,            reserved                           
+//Bit 28,            reg_adp_lti_dir_difmode                     : 0: y_dif; 1: y_dif + (u_dif+v_dif)/2;                                         . unsigned  , default = 0   
+//Bit 27,            reserved                           
+//Bit 26,            reg_adp_cti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf  dft=1                                        . unsigned  , default = 1   
+//Bit 25:24,        reg_adp_cti_dir_difmode                     : 0: (u_dif+v_dif); 1: y_dif/2 + (u_dif+v_dif)*3/4; 2: y_dif + (u_dif+v_dif)/2; 3: y_dif*2 (not recomended). unsigned  , default = 0   
+//Bit 23:22,        reg_adp_hvlti_dcblend_mode                  : 0: hlti_dc; 1:vlti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 3   
+//Bit 21:20,        reg_adp_hvcti_dcblend_mode                  : 0: hcti_dc; 1:vcti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 3   
+//Bit 19:18,        reg_adp_hvlti_acblend_mode                  : hlti_ac; 1:vlti_ac; 2: add  3;:adaptive to alpha                              . unsigned  , default = 3   
+//Bit 17:16,        reg_adp_hvcti_acblend_mode                  : hcti_ac; 1:vcti_ac; 2: add  3;: adaptive to alpha                             . unsigned  , default = 3   
+//Bit 15,            reserved                           
+//Bit 14:12,        reg_adp_hlti_debug                          , for hlti debug, default = 0                                                   . unsigned  , default = 0   
+//Bit 11,            reserved                           
+//Bit 10: 8,        reg_adp_vlti_debug                          , for vlti debug, default = 0                                                   . unsigned  , default = 0   
+//Bit  7,            reserved                           
+//Bit  6: 4,        reg_adp_hcti_debug                          , for hcti debug, default = 0                                                   . unsigned  , default = 0   
+//Bit  3,            reserved                           
+//Bit  2: 0,        reg_adp_vcti_debug                          , for vcti debug, default = 0                                                   . unsigned  , default = 0   
+#define HCTI_FLT_CLP_DC                            ((0x31ae  << 2) + 0xd0100000)
+//Bit 31:29,        reserved                           
+//Bit 28,            reg_adp_hcti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1   
+//Bit 27:26,        reg_adp_hcti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8  3:[1 0 2 0 1]/4, default = 3    . unsigned  , default = 3   
+//Bit 25:24,        reg_adp_hcti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 2. unsigned  , default = 2   
+//Bit 23:22,        reg_adp_hcti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3     . unsigned  , default = 3   
+//Bit 21:20,        reg_adp_hcti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 2        . unsigned  , default = 2   
+//Bit 19:18,        reg_adp_hcti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 2        . unsigned  , default = 2   
+//Bit 17:16,        reg_adp_hcti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 2       . unsigned  , default = 2   
+//Bit 15:12,        reg_adp_hcti_hard_clp_win                   , window size, 0~8, default = 7                                                 . unsigned  , default = 7   
+//Bit 11: 8,        reg_adp_hcti_hard_win_min                   , window size, 0~8, default = 3                                                 . unsigned  , default = 3   
+//Bit  7: 5,        reserved                           
+//Bit  4,            reg_adp_hcti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 1                                   . unsigned  , default = 1   
+//Bit  3,            reserved                           
+//Bit  2: 0,        reg_adp_hcti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 0    . unsigned  , default = 0   
+#define HCTI_BST_GAIN                              ((0x31af  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_hcti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 80                         . unsigned  , default = 80  
+//Bit 23:16,        reg_adp_hcti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 96                          . unsigned  , default = 96  
+//Bit 15: 8,        reg_adp_hcti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 64                          . unsigned  , default = 64  
+//Bit  7: 0,        reg_adp_hcti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 16                       . unsigned  , default = 16  
+#define HCTI_BST_CORE                              ((0x31b0  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_hcti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 0                          . unsigned  , default = 0   
+//Bit 23:16,        reg_adp_hcti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 0                           . unsigned  , default = 0   
+//Bit 15: 8,        reg_adp_hcti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 0                           . unsigned  , default = 0   
+//Bit  7: 0,        reg_adp_hcti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 0                        . unsigned  , default = 0   
+#define HCTI_CON_2_GAIN_0                          ((0x31b1  << 2) + 0xd0100000)
+//Bit 31:29,        reg_adp_hcti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: .... default = 2. unsigned  , default = 2   
+//Bit 28:26,        reg_adp_hcti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 3                       . unsigned  , default = 3   
+//Bit 25:24,        reg_adp_hcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 1               . unsigned  , default = 1   
+//Bit 23:16,        reg_adp_hcti_con_2_gain0                    , default = 25                                                                  . unsigned  , default = 25  
+//Bit 15: 8,        reg_adp_hcti_con_2_gain1                    , default = 60                                                                  . unsigned  , default = 60  
+//Bit  7: 0,        reg_adp_hcti_con_2_gain2                    0;, default = 0                                                                 . unsigned  , default = 0   
+#define HCTI_CON_2_GAIN_1                          ((0x31b2  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_hcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96  
+//Bit 23:16,        reg_adp_hcti_con_2_gain4                    5;, default = 5                                                                 . unsigned  , default = 5   
+//Bit 15: 8,        reg_adp_hcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80  
+//Bit  7: 0,        reg_adp_hcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20  
+#define HCTI_OS_MARGIN                             ((0x31b3  << 2) + 0xd0100000)
+//Bit 31: 8,        reserved                           
+//Bit  7: 0,        reg_adp_hcti_os_margin                      : margin for hcti overshoot, default = 0                                        . unsigned  , default = 0   
+#define HLTI_FLT_CLP_DC                            ((0x31b4  << 2) + 0xd0100000)
+//Bit 31:29,        reserved                           
+//Bit 28,            reg_adp_hlti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1   
+//Bit 27:26,        reg_adp_hlti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2   
+//Bit 25:24,        reg_adp_hlti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 2. unsigned  , default = 2   
+//Bit 23:22,        reg_adp_hlti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2   
+//Bit 21:20,        reg_adp_hlti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 2        . unsigned  , default = 2   
+//Bit 19:18,        reg_adp_hlti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 2        . unsigned  , default = 2   
+//Bit 17:16,        reg_adp_hlti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 2       . unsigned  , default = 2   
+//Bit 15:12,        reg_adp_hlti_hard_clp_win                   , window size, 0~8, default = 2                                                 . unsigned  , default = 2   
+//Bit 11: 8,        reg_adp_hlti_hard_win_min                   , window size, 0~8, default = 1                                                 . unsigned  , default = 1   
+//Bit  7: 5,        reserved                           
+//Bit  4,            reg_adp_hlti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 0                                   . unsigned  , default = 0   
+//Bit  3,            reserved                           
+//Bit  2: 0,        reg_adp_hlti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 4    . unsigned  , default = 4   
+#define HLTI_BST_GAIN                              ((0x31b5  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_hlti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 40                         . unsigned  , default = 40  
+//Bit 23:16,        reg_adp_hlti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 48                          . unsigned  , default = 48  
+//Bit 15: 8,        reg_adp_hlti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 32                          . unsigned  , default = 32  
+//Bit  7: 0,        reg_adp_hlti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 16                       . unsigned  , default = 16  
+#define HLTI_BST_CORE                              ((0x31b6  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_hlti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 5                          . unsigned  , default = 5   
+//Bit 23:16,        reg_adp_hlti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 5                           . unsigned  , default = 5   
+//Bit 15: 8,        reg_adp_hlti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 5                           . unsigned  , default = 5   
+//Bit  7: 0,        reg_adp_hlti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 3                        . unsigned  , default = 3   
+#define HLTI_CON_2_GAIN_0                          ((0x31b7  << 2) + 0xd0100000)
+//Bit 31:29,        reg_adp_hlti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: ....., default = 2. unsigned  , default = 2   
+//Bit 28:26,        reg_adp_hlti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 3                       . unsigned  , default = 3   
+//Bit 25:24,        reg_adp_hlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 1               . unsigned  , default = 1   
+//Bit 23:16,        reg_adp_hlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25  
+//Bit 15: 8,        reg_adp_hlti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60  
+//Bit  7: 0,        reg_adp_hlti_con_2_gain2                    0;, default = 90                                                                . unsigned  , default = 90  
+#define HLTI_CON_2_GAIN_1                          ((0x31b8  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_hlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96  
+//Bit 23:16,        reg_adp_hlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95  
+//Bit 15: 8,        reg_adp_hlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80  
+//Bit  7: 0,        reg_adp_hlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20  
+#define HLTI_OS_MARGIN                             ((0x31b9  << 2) + 0xd0100000)
+//Bit 31: 8,        reserved                           
+//Bit  7: 0,        reg_adp_hlti_os_margin                      : margin for hlti overshoot, default = 0                                        . unsigned  , default = 0   
+#define VLTI_FLT_CON_CLP                           ((0x31ba  << 2) + 0xd0100000)
+//Bit 31:15,        reserved                           
+//Bit 14,            reg_adp_vlti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1   
+//Bit 13:12,        reg_adp_vlti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
+//Bit 11:10,        reg_adp_vlti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
+//Bit  9: 8,        reg_adp_vlti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
+//Bit  7: 6,        reg_adp_vlti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
+//Bit  5: 4,        reg_adp_vlti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 2                         . unsigned  , default = 2   
+//Bit  3,            reserved                           
+//Bit  2,            reg_adp_vlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 1               . unsigned  , default = 1   
+//Bit  1,            reserved                           
+//Bit  0,            reg_adp_vlti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 1                        . unsigned  , default = 1   
+#define VLTI_BST_GAIN                              ((0x31bb  << 2) + 0xd0100000)
+//Bit 31:24,        reserved                           
+//Bit 23:16,        reg_adp_vlti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 32                                 . unsigned  , default = 32  
+//Bit 15: 8,        reg_adp_vlti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 32                             . unsigned  , default = 32  
+//Bit  7: 0,        reg_adp_vlti_bst_gain2                      : gain to boost filter usf, default = 32                                        . unsigned  , default = 32  
+#define VLTI_BST_CORE                              ((0x31bc  << 2) + 0xd0100000)
+//Bit 31:24,        reserved                           
+//Bit 23:16,        reg_adp_vlti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 5                                . unsigned  , default = 5   
+//Bit 15: 8,        reg_adp_vlti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 5                            . unsigned  , default = 5   
+//Bit  7: 0,        reg_adp_vlti_bst_core2                      : coring to boost filter usf, default = 3                                       . unsigned  , default = 3   
+#define VLTI_CON_2_GAIN_0                          ((0x31bd  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_vlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25  
+//Bit 23:16,        reg_adp_vlti_con_2_gain1                    60;, default = 69                                                               . unsigned  , default = 60  
+//Bit 15: 8,        reg_adp_vlti_con_2_gain2                    0;, default = 90                                                                . unsigned  , default = 90  
+//Bit  7: 0,        reg_adp_vlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96  
+#define VLTI_CON_2_GAIN_1                          ((0x31be  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_vlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95  
+//Bit 23:16,        reg_adp_vlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80  
+//Bit 15: 8,        reg_adp_vlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20  
+//Bit  7: 0,        reg_adp_vlti_os_margin                      : margin for vlti overshoot, default = 0                                        . unsigned  , default = 0   
+#define VCTI_FLT_CON_CLP                           ((0x31bf  << 2) + 0xd0100000)
+//Bit 31:15,        reserved                           
+//Bit 14,            reg_adp_vcti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1   
+//Bit 13:12,        reg_adp_vcti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
+//Bit 11:10,        reg_adp_vcti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
+//Bit  9: 8,        reg_adp_vcti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
+//Bit  7: 6,        reg_adp_vcti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 3       . unsigned  , default = 3   
+//Bit  5: 4,        reg_adp_vcti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 2                         . unsigned  , default = 2   
+//Bit  3,            reserved                           
+//Bit  2,            reg_adp_vcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 1               . unsigned  , default = 1   
+//Bit  1,            reserved                           
+//Bit  0,            reg_adp_vcti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 1                        . unsigned  , default = 1   
+#define VCTI_BST_GAIN                              ((0x31c0  << 2) + 0xd0100000)
+//Bit 31:24,        reserved                           
+//Bit 23:16,        reg_adp_vcti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 0                                  . unsigned  , default = 0   
+//Bit 15: 8,        reg_adp_vcti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 0                              . unsigned  , default = 0   
+//Bit  7: 0,        reg_adp_vcti_bst_gain2                      : gain to boost filter usf, default = 0                                         . unsigned  , default = 0   
+#define VCTI_BST_CORE                              ((0x31c1  << 2) + 0xd0100000)
+//Bit 31:24,        reserved                           
+//Bit 23:16,        reg_adp_vcti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 0                                . unsigned  , default = 0   
+//Bit 15: 8,        reg_adp_vcti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 0                            . unsigned  , default = 0   
+//Bit  7: 0,        reg_adp_vcti_bst_core2                      : coring to boost filter usf, default = 0                                       . unsigned  , default = 0   
+#define VCTI_CON_2_GAIN_0                          ((0x31c2  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_vcti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25  
+//Bit 23:16,        reg_adp_vcti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60  
+//Bit 15: 8,        reg_adp_vcti_con_2_gain2                    0;, default = 90                                                                . unsigned  , default = 90  
+//Bit  7: 0,        reg_adp_vcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96  
+#define VCTI_CON_2_GAIN_1                          ((0x31c3  << 2) + 0xd0100000)
+//Bit 31:24,        reg_adp_vcti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95  
+//Bit 23:16,        reg_adp_vcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80  
+//Bit 15: 8,        reg_adp_vcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20  
+//Bit  7: 0,        reg_adp_vcti_os_margin                      : margin for vcti overshoot, default = 0                                        . unsigned  , default = 0   
+#define SHARP_3DLIMIT                              ((0x31c4  << 2) + 0xd0100000)
+//Bit 31:29,        reserved                           
+//Bit 28:16,        reg_3d_mid_width                            ,width of left part of 3d input, dft = half size of input width  default = 0    . unsigned  , default = 960 
+//Bit 15:13,        reserved                           
+//Bit 12: 0,        reg_3d_mid_height                           ,height of left part of 3d input, dft = half size of input height  default = 0  . unsigned  , default = 540 
+#define DNLP_EN                                    ((0x31c5  << 2) + 0xd0100000)
+//Bit 31: 1,        reserved                           
+//Bit  0,            reg_dnlp_en                                                                                                                 . unsigned  , default = 1   
+#define DNLP_00                                    ((0x31c6  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid0                             : dnlp00                                                                        . unsigned  , default = 32'h08060402
+#define DNLP_01                                    ((0x31c7  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid1                             : dnlp01                                                                        . unsigned  , default = 32'h100e0c0a
+#define DNLP_02                                    ((0x31c8  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid2                             : dnlp02                                                                        . unsigned  , default = 32'h1a171412
+#define DNLP_03                                    ((0x31c9  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid3                             : dnlp03                                                                        . unsigned  , default = 32'h2824201d
+#define DNLP_04                                    ((0x31ca  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid4                             : dnlp04                                                                        . unsigned  , default = 32'h3834302c
+#define DNLP_05                                    ((0x31cb  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid5                             : dnlp05                                                                        . unsigned  , default = 32'h4b45403c
+#define DNLP_06                                    ((0x31cc  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid6                             : dnlp06                                                                        . unsigned  , default = 32'h605b5550
+#define DNLP_07                                    ((0x31cd  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid7                             : dnlp07                                                                        . unsigned  , default = 32'h80787068
+#define DNLP_08                                    ((0x31ce  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid8                             : dnlp08                                                                        . unsigned  , default = 32'ha0989088
+#define DNLP_09                                    ((0x31cf  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid9                             : dnlp09                                                                        . unsigned  , default = 32'hb8b2aca6
+#define DNLP_10                                    ((0x31d0  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid10                            : dnlp10                                                                        . unsigned  , default = 32'hc8c4c0bc
+#define DNLP_11                                    ((0x31d1  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid11                            : dnlp11                                                                        . unsigned  , default = 32'hd4d2cecb
+#define DNLP_12                                    ((0x31d2  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid12                            : dnlp12                                                                        . unsigned  , default = 32'hdad8d7d6
+#define DNLP_13                                    ((0x31d3  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid13                            : dnlp13                                                                        . unsigned  , default = 32'he2e0dedc
+#define DNLP_14                                    ((0x31d4  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid14                            : dnlp14                                                                        . unsigned  , default = 32'hf0ece8e4
+#define DNLP_15                                    ((0x31d5  << 2) + 0xd0100000)
+//Bit 31: 0,        reg_dnlp_ygrid15                            : dnlp15                                                                        . unsigned  , default = 32'hfffcf8f4
+#define DEMO_CRTL                                  ((0x31d6  << 2) + 0xd0100000)
+//Bit 31:19,        reserved                           
+//Bit 18:17,        demo_disp_position                                                                                                          . unsigned  , default = 2   
+//Bit 16,            demo_hsvsharp_enable                                                                                                        . unsigned  , default = 0   
+//Bit 15:13,        reserved                           
+//Bit 12: 0,        demo_left_top_screen_width                  :                                                                               . unsigned  , default = 360 
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  sharp_regs.h
+//
+// synopsys translate_off
+// synopsys translate_on
+//
+// Closing file:  ./vcbus_regs.h
+//
+
+#include "no_enct.h"
+
+#endif // REGISTER_H
+
diff --git a/arch/arm/mach-mesong9tv/tools/genregs/ucode/secure_apb.h b/arch/arm/mach-mesong9tv/tools/genregs/ucode/secure_apb.h
new file mode 100644
index 000000000000..cc26fa9350a9
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/tools/genregs/ucode/secure_apb.h
@@ -0,0 +1,81 @@
+#ifndef SECURE_APB_H
+#define SECURE_APB_H
+
+//
+// Secure APB3 Slot 0 Registers
+//
+#define EFUSE_CNTL0                     0x0
+#define EFUSE_CNTL1                     0x1
+#define EFUSE_CNTL2                     0x2
+#define EFUSE_CNTL3                     0x3
+#define EFUSE_CNTL4                     0x4
+
+#define EFUSE_Wr_reg(addr, data)  *(volatile unsigned long *)(0xDA000000 | (addr << 2) ) = (data)
+#define EFUSE_Rd_reg(addr)        *(volatile unsigned long *)(0xDA000000 | (addr << 2) )
+
+//
+// Secure APB3 Slot 2 Registers
+//
+#define AO_SECURE_REG0                  0x00
+#define AO_SECURE_REG1                  0x01
+#define AO_SECURE_REG2                  0x02
+
+#define AO_RTC_ADDR0                    0xd0
+#define AO_RTC_ADDR1                    0xd1
+#define AO_RTC_ADDR2                    0xd2
+#define AO_RTC_ADDR3                    0xd3
+#define AO_RTC_ADDR4                    0xd4
+
+#define Secure_APB_slot2_Wr_reg(addr, data)  *(volatile unsigned long *)(0xDA004000 | (addr << 2) ) = (data)
+#define Secure_APB_slot2_Rd_reg(addr)        *(volatile unsigned long *)(0xDA004000 | (addr << 2) )
+// 
+// Secure APB3 Slot 3 registers
+//
+#define SEC_BLKMV_AES_REG0              0x00
+#define SEC_BLKMV_AES_W0                0x01
+#define SEC_BLKMV_AES_W1                0x02
+#define SEC_BLKMV_AES_W2                0x03
+#define SEC_BLKMV_AES_W3                0x04
+#define SEC_BLKMV_AES_R0                0x05
+#define SEC_BLKMV_AES_R1                0x06
+#define SEC_BLKMV_AES_R2                0x07
+#define SEC_BLKMV_AES_R3                0x08
+#define SEC_BLKMV_TDES_LAST_IV_LO       0x09
+#define SEC_BLKMV_TDES_LAST_IV_HI       0x0a
+#define SEC_BLKMV_AES_IV_0              0x0b
+#define SEC_BLKMV_AES_IV_1              0x0c
+#define SEC_BLKMV_AES_IV_2              0x0d
+#define SEC_BLKMV_AES_IV_3              0x0e
+
+#define SEC_BLKMV_AES_KEY_0             0x10
+#define SEC_BLKMV_AES_KEY_1             0x11
+#define SEC_BLKMV_AES_KEY_2             0x12
+#define SEC_BLKMV_AES_KEY_3             0x13
+#define SEC_BLKMV_AES_KEY_4             0x14
+#define SEC_BLKMV_AES_KEY_5             0x15
+#define SEC_BLKMV_AES_KEY_6             0x16
+#define SEC_BLKMV_AES_KEY_7             0x17
+
+#define SEC_BLKMV_THREAD_TABLE_START0   0x18
+#define SEC_BLKMV_THREAD_TABLE_CURR0    0x19
+#define SEC_BLKMV_THREAD_TABLE_END0     0x1a
+
+#define SEC_BLKMV_THREAD_TABLE_START1   0x1b
+#define SEC_BLKMV_THREAD_TABLE_CURR1    0x1c
+#define SEC_BLKMV_THREAD_TABLE_END1     0x1d
+
+#define SEC_BLKMV_THREAD_TABLE_START2   0x1e
+#define SEC_BLKMV_THREAD_TABLE_CURR2    0x1f
+#define SEC_BLKMV_THREAD_TABLE_END2     0x20
+
+#define SEC_BLKMV_THREAD_TABLE_START3   0x21
+#define SEC_BLKMV_THREAD_TABLE_CURR3    0x22
+#define SEC_BLKMV_THREAD_TABLE_END3     0x23
+
+#define SEC_BLKMV_GEN_REG0              0x24
+
+
+#define Secure_APB_slot3_Wr_reg(addr, data)  *(volatile unsigned long *)(0xDA006000 | (addr << 2) ) = (data)
+#define Secure_APB_slot3_Rd_reg(addr)        *(volatile unsigned long *)(0xDA006000 | (addr << 2) )
+
+#endif
-- 
2.19.0

