From 43d64c7879a7763e0c53d035969de907ad9d31a5 Mon Sep 17 00:00:00 2001
From: Matthew Shyu <matthew.shyu@amlogic.com>
Date: Tue, 10 Feb 2015 17:34:53 +0800
Subject: [PATCH 5414/5965] Crypto: Async HW AES and TDES driver

Change-Id: I34c27c9bf5c0e147fc3b2b525c39c6910e874f43
---
 arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd     |   13 +-
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |   11 +
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |   10 +
 arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd  |   10 +
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |    9 +
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |   10 +
 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd  |   10 +
 arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd  |   10 +
 arch/arm/boot/dts/amlogic/meson8_k200a_1G.dtd |   11 +-
 .../dts/amlogic/meson8_k200a_1G_hdmiin.dtd    |   11 +-
 arch/arm/boot/dts/amlogic/meson8_k200a_2G.dtd |   11 +-
 .../boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd |   11 +-
 .../dts/amlogic/meson8_k200a_2G_hdmiin.dtd    |   11 +-
 .../dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd |   10 +-
 .../meson8_k200b_1G_emmc_sdhc_hdmiin.dtd      |   10 +-
 .../dts/amlogic/meson8_k200b_1G_emmc_sdio.dtd |   10 +-
 .../meson8_k200b_1G_emmc_sdio_hdmiin.dtd      |   10 +-
 .../boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd |   10 +-
 .../dts/amlogic/meson8_k200b_2G_emmc_sdhc.dtd |   10 +-
 .../dts/amlogic/meson8_k200b_2G_emmc_sdio.dtd |   10 +-
 .../dts/amlogic/meson8_k200b_2G_hdmiin.dtd    |   10 +-
 arch/arm/boot/dts/amlogic/meson8_pxp.dtd      |   13 +-
 arch/arm/boot/dts/amlogic/meson8_skt.dtd      |   13 +-
 arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd |   14 +-
 .../boot/dts/amlogic/meson8b_m101_512M.dtd    |   14 +-
 arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd |   14 +-
 arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd |   13 +-
 .../boot/dts/amlogic/meson8b_m200_1G_iptv.dtd |   13 +-
 .../boot/dts/amlogic/meson8b_m201C_512M.dtd   |   13 +-
 arch/arm/boot/dts/amlogic/meson8b_m201_1G.dtd |   13 +-
 .../boot/dts/amlogic/meson8b_m202_512M.dtd    |   13 +-
 arch/arm/boot/dts/amlogic/meson8b_m203a.dtd   |   13 +-
 arch/arm/boot/dts/amlogic/meson8b_m203b.dtd   |   13 +-
 arch/arm/boot/dts/amlogic/meson8b_pxp.dtd     |   13 +-
 arch/arm/boot/dts/amlogic/meson8b_skt.dtd     |   13 +-
 arch/arm/boot/dts/amlogic/meson8m2_n01_2G.dtd |   11 +-
 .../arm/boot/dts/amlogic/meson8m2_n100_1G.dtd |   11 +
 .../boot/dts/amlogic/meson8m2_n101_512M.dtd   |   10 +
 .../boot/dts/amlogic/meson8m2_n200C_1G.dtd    |   11 +-
 .../boot/dts/amlogic/meson8m2_n200C_2G.dtd    |   11 +-
 .../arm/boot/dts/amlogic/meson8m2_n200_1G.dtd |   10 +-
 .../arm/boot/dts/amlogic/meson8m2_n200_2G.dtd |   10 +-
 arch/arm/boot/dts/amlogic/meson8m2_pxp.dtd    |   13 +-
 arch/arm/boot/dts/amlogic/meson8m2_skt.dtd    |   13 +-
 arch/arm/configs/meson8_defconfig             |    1 +
 arch/arm/configs/meson8b_defconfig            |    1 +
 drivers/amlogic/crypto/Kconfig                |    8 -
 drivers/amlogic/crypto/Makefile               |    3 +-
 drivers/amlogic/crypto/aml-aes.c              |  955 ++++++++++++
 drivers/amlogic/crypto/aml-crypto.c           | 1308 +++--------------
 drivers/amlogic/crypto/aml-crypto.h           |   62 +-
 drivers/amlogic/crypto/aml-tdes.c             |  916 ++++++++++++
 drivers/amlogic/crypto/crypto_dev.c           |  511 -------
 53 files changed, 2496 insertions(+), 1772 deletions(-)
 mode change 100755 => 100644 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
 mode change 100755 => 100644 arch/arm/configs/meson8_defconfig
 mode change 100755 => 100644 drivers/amlogic/crypto/Kconfig
 mode change 100755 => 100644 drivers/amlogic/crypto/Makefile
 create mode 100644 drivers/amlogic/crypto/aml-aes.c
 mode change 100755 => 100644 drivers/amlogic/crypto/aml-crypto.c
 mode change 100755 => 100644 drivers/amlogic/crypto/aml-crypto.h
 create mode 100644 drivers/amlogic/crypto/aml-tdes.c
 delete mode 100755 drivers/amlogic/crypto/crypto_dev.c

diff --git a/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd b/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd
index fc84c867bbed..71be80a0b2d7 100755
--- a/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_ZeBu.dtd
@@ -1182,10 +1182,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
old mode 100755
new mode 100644
index f66786f7eb7b..75e48e056f17
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -2164,6 +2164,17 @@ sdio{
 	firmware_timeout=<6>;
 	suspend_timeout=<6>;
 	};
+
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
+
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index d25b00f14382..b68343a04e3b 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -2144,6 +2144,16 @@ sdio{
         status = "okay";
     };
 
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
+
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
index 4d14669bcfd7..a6eebbb7dbf6 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
@@ -2078,6 +2078,16 @@ sdio{
         status = "okay";
     };
 
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
+
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index e133796806ea..9ed527aee39d 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -2006,6 +2006,15 @@ sdio{
         status = "okay";
     };
 
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index ec2037828605..d59ce917161a 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -2029,6 +2029,16 @@ lcd_LD070WX4:lcd_LD070WX4{
         status = "okay";
     };
 
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
+
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
index ba1af2bdc116..3889f170412d 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
@@ -2070,6 +2070,16 @@ lcd_LD070WX4:lcd_LD070WX4{
         status = "okay";
     };
 
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
+
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
index 39b46b7001e9..cd69c8f9245c 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
@@ -2107,6 +2107,16 @@ lcd_LD070WX4:lcd_LD070WX4{
         status = "okay";
     };
 
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
+
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200a_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200a_1G.dtd
index 0f01eaaaac2b..5c3008d279ad 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200a_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200a_1G.dtd
@@ -1434,9 +1434,14 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
     };
 
 /// **************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200a_1G_hdmiin.dtd b/arch/arm/boot/dts/amlogic/meson8_k200a_1G_hdmiin.dtd
index 10efcdb01355..29a980e1b969 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200a_1G_hdmiin.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200a_1G_hdmiin.dtd
@@ -1445,9 +1445,14 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
     };
 
 /// **************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200a_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k200a_2G.dtd
index 212bee9082d0..41d039d78b74 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200a_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200a_2G.dtd
@@ -1293,9 +1293,14 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
     };
 
 /// **************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd
index a09d9ffb242b..8f9df40d3672 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_4k2k.dtd
@@ -1234,9 +1234,14 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
     };
 
 /// **************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200a_2G_hdmiin.dtd b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_hdmiin.dtd
index ec7b3d7fdeb4..a365d1c9cd99 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200a_2G_hdmiin.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200a_2G_hdmiin.dtd
@@ -1252,9 +1252,14 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
     };
 
 /// **************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd
index d5c15e76ed71..a50345043484 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc.dtd
@@ -1458,11 +1458,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc_hdmiin.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc_hdmiin.dtd
index 2006ddbed02a..4883742b3f7d 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc_hdmiin.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdhc_hdmiin.dtd
@@ -1451,11 +1451,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdio.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdio.dtd
index b6bd3e2d2723..3493c4d10a9e 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdio.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdio.dtd
@@ -1426,11 +1426,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdio_hdmiin.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdio_hdmiin.dtd
index f52e38677e9e..b16b53064462 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdio_hdmiin.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_1G_emmc_sdio_hdmiin.dtd
@@ -1439,11 +1439,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd
index 3b51c352ea08..9f1feb241fd3 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_4k2k.dtd
@@ -1368,11 +1368,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_emmc_sdhc.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_emmc_sdhc.dtd
index a6d30d7be504..ca079eb17a80 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_emmc_sdhc.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_emmc_sdhc.dtd
@@ -1403,11 +1403,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_emmc_sdio.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_emmc_sdio.dtd
index 8a7b0d439917..066dae80c7d5 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_emmc_sdio.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_emmc_sdio.dtd
@@ -1401,11 +1401,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_hdmiin.dtd b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_hdmiin.dtd
index f891995e6648..388b81c97afb 100755
--- a/arch/arm/boot/dts/amlogic/meson8_k200b_2G_hdmiin.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k200b_2G_hdmiin.dtd
@@ -1318,11 +1318,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8_pxp.dtd b/arch/arm/boot/dts/amlogic/meson8_pxp.dtd
index d86d0a65dae0..fc6d05e29114 100755
--- a/arch/arm/boot/dts/amlogic/meson8_pxp.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_pxp.dtd
@@ -1172,10 +1172,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8_skt.dtd b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
index 9f7f752f464d..cd324fadd948 100755
--- a/arch/arm/boot/dts/amlogic/meson8_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_skt.dtd
@@ -1381,10 +1381,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd
index 53b74f7ba061..d2d9851d8ce9 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd
@@ -1904,10 +1904,16 @@ void root_func(){
 		firmware_timeout=<6>;
 		suspend_timeout=<6>;
 	};
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8b_m101_512M.dtd
index a7c22ef53266..3487b00b9c2a 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m101_512M.dtd
@@ -1738,10 +1738,16 @@ void root_func(){
 		firmware_timeout=<6>;
 		suspend_timeout=<6>;
 	};
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
index be0670e39237..79f10dc624f2 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
@@ -1885,10 +1885,16 @@ void root_func(){
 		firmware_timeout=<6>;
 		suspend_timeout=<6>;
 	};
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd
index 9b5b0fd34824..112d75c3ecb2 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd
@@ -1466,10 +1466,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m200_1G_iptv.dtd b/arch/arm/boot/dts/amlogic/meson8b_m200_1G_iptv.dtd
index ff899ce39a48..e86b87820d65 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m200_1G_iptv.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m200_1G_iptv.dtd
@@ -1455,10 +1455,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m201C_512M.dtd b/arch/arm/boot/dts/amlogic/meson8b_m201C_512M.dtd
index 11c328e0bfc3..5c1d3c8d5d6f 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m201C_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m201C_512M.dtd
@@ -1519,10 +1519,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m201_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m201_1G.dtd
index 310b0a28dabb..264345e03403 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m201_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m201_1G.dtd
@@ -1513,10 +1513,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m202_512M.dtd b/arch/arm/boot/dts/amlogic/meson8b_m202_512M.dtd
index 3c171cea438e..faf236880176 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m202_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m202_512M.dtd
@@ -1414,10 +1414,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m203a.dtd b/arch/arm/boot/dts/amlogic/meson8b_m203a.dtd
index 5d9e989a6681..0c72bdb3365a 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m203a.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m203a.dtd
@@ -1415,10 +1415,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m203b.dtd b/arch/arm/boot/dts/amlogic/meson8b_m203b.dtd
index 9650c1921b39..2644e1dc3040 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_m203b.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m203b.dtd
@@ -1415,10 +1415,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_pxp.dtd b/arch/arm/boot/dts/amlogic/meson8b_pxp.dtd
index 28039efb2e10..b3ab560e3d39 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_pxp.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_pxp.dtd
@@ -1381,10 +1381,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8b_skt.dtd b/arch/arm/boot/dts/amlogic/meson8b_skt.dtd
index 25a696314c86..9773029aaefd 100755
--- a/arch/arm/boot/dts/amlogic/meson8b_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_skt.dtd
@@ -1480,10 +1480,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n01_2G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n01_2G.dtd
index 2e526f5ba1a8..2b562ee61b45 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n01_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n01_2G.dtd
@@ -770,9 +770,14 @@
         status = "okay";
     };
 
-    crypto_device{
-        compatible = "amlogic,crypto-device";
-        dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
     };
 
     gpio:gpio{
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd
index f13180ee3b9c..aff3c2e25624 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd
@@ -2134,6 +2134,17 @@ sdio{
 	firmware_timeout=<6>;
 	suspend_timeout=<6>;
 	};
+
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
+
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd
index 84f11a4a4791..fe334a05989e 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd
@@ -2003,6 +2003,16 @@ sdio{
         status = "okay";
     };
 
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
+
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n200C_1G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n200C_1G.dtd
index 66c944ed6042..6baf9edf53bc 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n200C_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n200C_1G.dtd
@@ -1407,11 +1407,16 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n200C_2G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n200C_2G.dtd
index 4ef86e1524ba..15b0d4a1e3c6 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n200C_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n200C_2G.dtd
@@ -1399,9 +1399,14 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
     };
 
 /// **************************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd
index afb9f6398a98..d82578522207 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd
@@ -1437,11 +1437,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n200_2G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n200_2G.dtd
index 130f774b4d61..3c0adbfdade9 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_n200_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n200_2G.dtd
@@ -1410,11 +1410,15 @@ sdio{
         status = "okay";
     };
 
-    crypto_device{
-       compatible = "amlogic,crypto-device";
-       dev_name = "crypto_device";
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
     };
 
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 /// **************************************************************************************
 /// -   GPIO
 //$$ MODULE="GPIO"
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_pxp.dtd b/arch/arm/boot/dts/amlogic/meson8m2_pxp.dtd
index 7f72a2d5cd1c..5e937bf80595 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_pxp.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_pxp.dtd
@@ -1393,10 +1393,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_skt.dtd b/arch/arm/boot/dts/amlogic/meson8m2_skt.dtd
index 110b1ad9f79f..b2261a25871c 100755
--- a/arch/arm/boot/dts/amlogic/meson8m2_skt.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_skt.dtd
@@ -1369,10 +1369,15 @@ void root_func(){
         status = "okay";
     };
 
-//    crypto_device{
-//       compatible = "amlogic,crypto-device";
-//       dev_name = "crypto_device";
-//    };
+    aml_aes{
+       compatible = "amlogic,aes";
+       dev_name = "aml_aes";
+    };
+
+    aml_tdes{
+       compatible = "amlogic,des,tdes";
+       dev_name = "aml_tdes";
+    };
 
 /// **************************************************************************************
 /// -   GPIO
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
old mode 100755
new mode 100644
index fa36f97ba76a..80823ef1c323
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -485,5 +485,6 @@ CONFIG_SECURITY_NETWORK=y
 CONFIG_SECURITY_SELINUX=y
 CONFIG_CRYPTO_PCBC=y
 CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
 CONFIG_CRC_T10DIF=y
 CONFIG_CRC7=y
diff --git a/arch/arm/configs/meson8b_defconfig b/arch/arm/configs/meson8b_defconfig
index 6adf5f704924..39f4be1f7d82 100644
--- a/arch/arm/configs/meson8b_defconfig
+++ b/arch/arm/configs/meson8b_defconfig
@@ -462,5 +462,6 @@ CONFIG_SECURITY_NETWORK=y
 CONFIG_SECURITY_SELINUX=y
 CONFIG_CRYPTO_PCBC=y
 CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
 CONFIG_CRC_T10DIF=y
 CONFIG_CRC7=y
diff --git a/drivers/amlogic/crypto/Kconfig b/drivers/amlogic/crypto/Kconfig
old mode 100755
new mode 100644
index 5e0e62a9bfcc..711e58e90cfc
--- a/drivers/amlogic/crypto/Kconfig
+++ b/drivers/amlogic/crypto/Kconfig
@@ -7,12 +7,4 @@ config CRYPTO_AML_HW_CRYPRO
 	select CRYPTO_BLKCIPHER
 	select CRYPTO_HASH
 	default y
-
-config CRYPTO_DEVICE_DRIVER
-  bool "crypto device for user interface"
-	select CRYPTO_ALGAPI
-	select CRYPTO_BLKCIPHER
-	select CRYPTO_HASH
-  default y
-  
 endmenu
diff --git a/drivers/amlogic/crypto/Makefile b/drivers/amlogic/crypto/Makefile
old mode 100755
new mode 100644
index d5cafe11bd42..c44257431048
--- a/drivers/amlogic/crypto/Makefile
+++ b/drivers/amlogic/crypto/Makefile
@@ -1,2 +1,3 @@
+obj-$(CONFIG_CRYPTO_AML_HW_CRYPRO) 				+= aml-aes.o
+obj-$(CONFIG_CRYPTO_AML_HW_CRYPRO) 				+= aml-tdes.o
 obj-$(CONFIG_CRYPTO_AML_HW_CRYPRO) 				+= aml-crypto.o
-obj-$(CONFIG_CRYPTO_DEVICE_DRIVER) 				+= crypto_dev.o
diff --git a/drivers/amlogic/crypto/aml-aes.c b/drivers/amlogic/crypto/aml-aes.c
new file mode 100644
index 000000000000..73840d1c047d
--- /dev/null
+++ b/drivers/amlogic/crypto/aml-aes.c
@@ -0,0 +1,955 @@
+/*
+ * Cryptographic API.
+ *
+ * Support for Amlogic AES HW acceleration.
+ *
+ * Copyright (c) 2014 Amlogic Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Some ideas are borrowed from atmel-aes.c driver.
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/hw_random.h>
+#include <linux/platform_device.h>
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/algapi.h>
+#include <crypto/aes.h>
+#include <crypto/hash.h>
+#include <crypto/internal/hash.h>
+#include <mach/cpu.h>
+#include <mach/register.h>
+#include <mach/io.h>
+#include <mach/mod_gate.h>
+#include "aml-crypto.h"
+
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+/* AES flags */
+#define AES_FLAGS_MODE_MASK	0x07
+#define AES_FLAGS_ENCRYPT	BIT(0)
+#define AES_FLAGS_CBC		BIT(1)
+#define AES_FLAGS_CTR		BIT(2)
+
+#define AES_FLAGS_INIT		BIT(8)
+#define AES_FLAGS_DMA		BIT(9)
+#define AES_FLAGS_BUSY		BIT(10)
+
+#define AML_AES_QUEUE_LENGTH	50
+#define AML_AES_DMA_THRESHOLD		16
+
+uint8_t USE_SECURE_THREAD;
+unsigned char    ndma_aes_table_block[NDMA_TABLE_SIZE + 32];
+#define NDMA_AES_TABLE_START (((unsigned long)ndma_aes_table_block+0x1f)\
+		&(~0x1f))
+unsigned long    ndma_aes_table_ptr;
+
+struct aml_aes_dev;
+
+struct aml_aes_ctx {
+	struct aml_aes_dev *dd;
+
+	int		keylen;
+	u32		key[AES_KEYSIZE_256 / sizeof(u32)];
+
+	u16		block_size;
+};
+
+struct aml_aes_reqctx {
+	unsigned long mode;
+};
+
+struct aml_aes_dev {
+	struct list_head	list;
+
+	struct aml_aes_ctx	*ctx;
+	struct device		*dev;
+	int	irq;
+
+	unsigned long		flags;
+	int	err;
+
+	spinlock_t		lock;
+	struct crypto_queue	queue;
+
+	struct tasklet_struct	done_task;
+	struct tasklet_struct	queue_task;
+
+	struct ablkcipher_request	*req;
+	size_t	total;
+
+	struct scatterlist	*in_sg;
+	size_t			in_offset;
+	struct scatterlist	*out_sg;
+	size_t			out_offset;
+
+	size_t	buflen;
+	size_t	dma_size;
+
+	void	*buf_in;
+	dma_addr_t	dma_addr_in;
+
+	void	*buf_out;
+	dma_addr_t	dma_addr_out;
+	dma_addr_t	dma_descript_tab;
+};
+
+struct aml_aes_drv {
+	struct list_head	dev_list;
+	spinlock_t		lock;
+};
+
+static struct aml_aes_drv aml_aes = {
+	.dev_list = LIST_HEAD_INIT(aml_aes.dev_list),
+	.lock = __SPIN_LOCK_UNLOCKED(aml_aes.lock),
+};
+
+static void set_aes_key_normal(u32 *key, unsigned int keylen)
+{
+	cbus_wr_reg(NDMA_AES_REG0, ((cbus_rd_reg(NDMA_AES_REG0) & ~(0x3 << 8))
+				| (AES_THREAD_INDEX << 8)));
+	cbus_wr_reg(NDMA_AES_KEY_0, *key);
+	cbus_wr_reg(NDMA_AES_KEY_1, *(key+1));
+	cbus_wr_reg(NDMA_AES_KEY_2, *(key+2));
+	cbus_wr_reg(NDMA_AES_KEY_3, *(key+3));
+	if (keylen > AES_KEYSIZE_128) {
+		cbus_wr_reg(NDMA_AES_KEY_4, *(key+4));
+		cbus_wr_reg(NDMA_AES_KEY_5, *(key+5));
+	}
+	if (keylen > AES_KEYSIZE_192) {
+		cbus_wr_reg(NDMA_AES_KEY_6, *(key+6));
+		cbus_wr_reg(NDMA_AES_KEY_7, *(key+7));
+	}
+}
+
+static void set_aes_key_secure(u32 *key, unsigned int keylen)
+{
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_REG0,
+			(secure_apb_slot3_rd_reg(SEC_BLKMV_AES_REG0)
+			& ~(0x3 << 4))
+			| (AES_THREAD_INDEX << 4));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_KEY_0, *key);
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_KEY_1, *(key+1));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_KEY_2, *(key+2));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_KEY_3, *(key+3));
+	if (keylen > AES_KEYSIZE_128) {
+		secure_apb_slot3_wr_reg(SEC_BLKMV_AES_KEY_4, *(key+4));
+		secure_apb_slot3_wr_reg(SEC_BLKMV_AES_KEY_5, *(key+5));
+	}
+	if (keylen > AES_KEYSIZE_192) {
+		secure_apb_slot3_wr_reg(SEC_BLKMV_AES_KEY_6, *(key+6));
+		secure_apb_slot3_wr_reg(SEC_BLKMV_AES_KEY_7, *(key+7));
+	}
+}
+
+static void set_aes_key(u32 *key, unsigned int keylen)
+{
+	if (USE_SECURE_THREAD)
+		set_aes_key_secure(key, keylen);
+	else
+		set_aes_key_normal(key, keylen);
+}
+
+static void set_aes_iv_normal(unsigned long *iv)
+{
+	cbus_wr_reg(NDMA_AES_REG0, ((cbus_rd_reg(NDMA_AES_REG0)
+				& ~(0x3 << 8))
+				| (AES_THREAD_INDEX << 8)));
+	cbus_wr_reg(NDMA_AES_IV_0, *iv);
+	cbus_wr_reg(NDMA_AES_IV_1, *(iv+1));
+	cbus_wr_reg(NDMA_AES_IV_2, *(iv+2));
+	cbus_wr_reg(NDMA_AES_IV_3, *(iv+3));
+}
+
+static void set_aes_iv_big_endian_normal(unsigned long *iv)
+{
+	cbus_wr_reg(NDMA_AES_REG0, ((cbus_rd_reg(NDMA_AES_REG0)
+				& ~(0x3 << 8))
+				| (AES_THREAD_INDEX << 8)));
+	cbus_wr_reg(NDMA_AES_IV_3, swap_ulong32(*iv));
+	cbus_wr_reg(NDMA_AES_IV_2, swap_ulong32(*(iv+1)));
+	cbus_wr_reg(NDMA_AES_IV_1, swap_ulong32(*(iv+2)));
+	cbus_wr_reg(NDMA_AES_IV_0, swap_ulong32(*(iv+3)));
+}
+
+static void set_aes_iv_secure(unsigned long *iv)
+{
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_REG0,
+			(secure_apb_slot3_rd_reg(SEC_BLKMV_AES_REG0)
+			& ~(0x3 << 4))
+			| (AES_THREAD_INDEX << 4));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_IV_0, *iv);
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_IV_1, *(iv+1));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_IV_2, *(iv+2));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_IV_3, *(iv+3));
+}
+
+static void set_aes_iv_big_endian_secure(unsigned long *iv)
+{
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_REG0,
+			(secure_apb_slot3_rd_reg(SEC_BLKMV_AES_REG0)
+			& ~(0x3 << 4))
+			| (AES_THREAD_INDEX << 4));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_IV_3, swap_ulong32(*iv));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_IV_2, swap_ulong32(*(iv+1)));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_IV_1, swap_ulong32(*(iv+2)));
+	secure_apb_slot3_wr_reg(SEC_BLKMV_AES_IV_0, swap_ulong32(*(iv+3)));
+}
+
+static void set_aes_iv(unsigned long *iv)
+{
+	if (USE_SECURE_THREAD)
+		set_aes_iv_secure(iv);
+	else
+		set_aes_iv_normal(iv);
+}
+
+static void set_aes_iv_big_endian(unsigned long *iv)
+{
+	if (USE_SECURE_THREAD)
+		set_aes_iv_big_endian_secure(iv);
+	else
+		set_aes_iv_big_endian_normal(iv);
+}
+
+static int aml_aes_sg_copy(struct scatterlist **sg, size_t *offset,
+		void *buf, size_t buflen, size_t total, int out)
+{
+	unsigned int count, off = 0;
+
+	while (buflen && total) {
+		count = min((*sg)->length - *offset, total);
+		count = min(count, buflen);
+
+		if (!count)
+			return off;
+
+		scatterwalk_map_and_copy(buf + off, *sg, *offset, count, out);
+
+		off += count;
+		buflen -= count;
+		*offset += count;
+		total -= count;
+
+		if (*offset == (*sg)->length) {
+			*sg = sg_next(*sg);
+			if (*sg)
+				*offset = 0;
+			else
+				total = 0;
+		}
+	}
+
+	return off;
+}
+
+static struct aml_aes_dev *aml_aes_find_dev(struct aml_aes_ctx *ctx)
+{
+	struct aml_aes_dev *aes_dd = NULL;
+	struct aml_aes_dev *tmp;
+
+	spin_lock_bh(&aml_aes.lock);
+	if (!ctx->dd) {
+		list_for_each_entry(tmp, &aml_aes.dev_list, list) {
+			aes_dd = tmp;
+			break;
+		}
+		ctx->dd = aes_dd;
+	} else {
+		aes_dd = ctx->dd;
+	}
+
+	spin_unlock_bh(&aml_aes.lock);
+
+	return aes_dd;
+}
+
+static int aml_aes_hw_init(struct aml_aes_dev *dd)
+{
+	cbus_wr_reg(AM_RING_OSC_REG0, 0x1);
+	cbus_wr_reg(NDMA_CNTL_REG1, cbus_rd_reg(NDMA_CNTL_REG1) & 0xfffffffe);
+	/* enable module clk */
+	switch_mod_gate_by_type(MOD_BLK_MOV, 1);
+#if 0 /* Let's control secure registers inside secure os */
+	if (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR)
+			>= MESON_CPU_MAJOR_ID_M8B) {
+		if (USE_SECURE_THREAD) {
+			secure_apb_slot3_wr_reg(SEC_BLKMV_GEN_REG0,
+				((secure_apb_slot3_rd_reg(SEC_BLKMV_GEN_REG0)
+				 & ~(0xf << 8))
+				 | (SEC_ALLOWED_MASK << 8)));
+			secure_apb_slot3_wr_reg(SEC_BLKMV_GEN_REG0,
+				((secure_apb_slot3_rd_reg(SEC_BLKMV_GEN_REG0)
+				 & ~(0xf << 4))
+				 | (AES_THREAD_INDEX << 4)));
+		} else {
+			secure_apb_slot3_wr_reg(SEC_BLKMV_GEN_REG0,
+				((secure_apb_slot3_rd_reg(SEC_BLKMV_GEN_REG0)
+				 | (0xf << 8))));
+			secure_apb_slot3_wr_reg(SEC_BLKMV_GEN_REG0,
+				(secure_apb_slot3_rd_reg(SEC_BLKMV_GEN_REG0)
+				 & ~(0xf << 0)));
+		}
+	} else {
+		USE_SECURE_THREAD = 0;
+	}
+#endif
+	if (!(dd->flags & AES_FLAGS_INIT)) {
+		dd->flags |= AES_FLAGS_INIT;
+		dd->err = 0;
+	}
+
+	return 0;
+}
+
+static void aml_aes_finish_req(struct aml_aes_dev *dd, int err)
+{
+	struct ablkcipher_request *req = dd->req;
+	dd->flags &= ~AES_FLAGS_BUSY;
+	req->base.complete(&req->base, err);
+}
+
+
+static int aml_aes_crypt_dma(struct aml_aes_dev *dd,
+		dma_addr_t dma_addr_in, dma_addr_t dma_addr_out,
+		int length, unsigned long restart)
+{
+	unsigned long mode;
+	unsigned long type;
+#if AML_CRYPTO_DEBUG
+	int i = 0;
+#endif
+	dd->dma_size = length;
+
+	dma_sync_single_for_device(dd->dev, dma_addr_in, length,
+			DMA_TO_DEVICE);
+
+	dd->flags |= AES_FLAGS_DMA;
+
+	mode = MODE_ECB;
+
+	if (dd->flags & AES_FLAGS_CBC)
+		mode = MODE_CBC;
+	else if (dd->flags & AES_FLAGS_CTR)
+		mode = MODE_CTR;
+
+	type = ((mode & 0x3)<<3)|
+		(((dd->flags & AES_FLAGS_ENCRYPT) ? 1 : 0) << 2)|
+		((dd->ctx->keylen == AES_KEYSIZE_128) ? 0 :
+		((dd->ctx->keylen == AES_KEYSIZE_192) ? 1 : 2));
+	ndma_add_descriptor_1d(
+			ndma_aes_table_ptr, /* table location */
+			1,                  /* irq */
+			restart,            /* restart */
+			0,                  /* pre_endian*/
+			0,                  /* post_endian */
+			type,               /* keytype + cryptodir */
+			dd->dma_size,       /* bytes_to_move */
+			INLINE_TYPE_AES,    /* inlinetype */
+			dma_addr_in,        /* src_addr */
+			dma_addr_out);      /* dest_addr */
+
+	dma_sync_single_for_device(dd->dev, dd->dma_descript_tab,
+			NDMA_TABLE_SIZE, DMA_TO_DEVICE);
+	if (USE_SECURE_THREAD)
+		ndma_set_table_position_secure(AES_THREAD_INDEX,
+				dd->dma_descript_tab, NDMA_TABLE_SIZE);
+	else
+		ndma_set_table_position(AES_THREAD_INDEX,
+				dd->dma_descript_tab, NDMA_TABLE_SIZE);
+	ndma_set_table_count(AES_THREAD_INDEX, 1);
+
+#if AML_CRYPTO_DEBUG
+	for (i = 0x2270; i < 0x229d; i++)
+		pr_err("reg(%4x) = 0x%8lx\n", i, cbus_rd_reg(i));
+
+	for (i = 0; i < 8; i++)
+		pr_err("table addr(%d) = 0x%8lx\n", i,
+				*(unsigned long *)(ndma_aes_table_ptr + i * 4));
+#endif
+
+	ndma_start(AES_THREAD_INDEX);
+
+	return 0;
+}
+
+static int aml_aes_crypt_dma_start(struct aml_aes_dev *dd,
+		unsigned long restart)
+{
+	int err = 0;
+	size_t count;
+	dma_addr_t addr_in, addr_out;
+
+	/* use cache buffers */
+	count = aml_aes_sg_copy(&dd->in_sg, &dd->in_offset,
+			dd->buf_in, dd->buflen, dd->total, 0);
+	addr_in = dd->dma_addr_in;
+	addr_out = dd->dma_addr_out;
+	dd->total -= count;
+
+	err = aml_aes_crypt_dma(dd, addr_in, addr_out, count, restart);
+
+	return err;
+}
+
+static int aml_aes_write_ctrl(struct aml_aes_dev *dd)
+{
+	int err = 0;
+	err = aml_aes_hw_init(dd);
+
+	if (err)
+		return err;
+
+	set_aes_key(dd->ctx->key, dd->ctx->keylen);
+
+	if (dd->flags & AES_FLAGS_CBC)
+		set_aes_iv(dd->req->info);
+	else if (dd->flags & AES_FLAGS_CTR)
+		set_aes_iv_big_endian(dd->req->info);
+
+	return err;
+}
+
+static int aml_aes_handle_queue(struct aml_aes_dev *dd,
+		struct ablkcipher_request *req)
+{
+	struct crypto_async_request *async_req, *backlog;
+	struct aml_aes_ctx *ctx;
+	struct aml_aes_reqctx *rctx;
+	unsigned long flags;
+	int err, ret = 0;
+
+	spin_lock_irqsave(&dd->lock, flags);
+	if (req)
+		ret = ablkcipher_enqueue_request(&dd->queue, req);
+
+	if (dd->flags & AES_FLAGS_BUSY) {
+		spin_unlock_irqrestore(&dd->lock, flags);
+		return ret;
+	}
+	backlog = crypto_get_backlog(&dd->queue);
+	async_req = crypto_dequeue_request(&dd->queue);
+	if (async_req)
+		dd->flags |= AES_FLAGS_BUSY;
+	spin_unlock_irqrestore(&dd->lock, flags);
+
+	if (!async_req)
+		return ret;
+
+	if (backlog)
+		backlog->complete(backlog, -EINPROGRESS);
+
+	req = ablkcipher_request_cast(async_req);
+
+	/* assign new request to device */
+	dd->req = req;
+	dd->total = req->nbytes;
+	dd->in_offset = 0;
+	dd->in_sg = req->src;
+	dd->out_offset = 0;
+	dd->out_sg = req->dst;
+
+	rctx = ablkcipher_request_ctx(req);
+	ctx = crypto_ablkcipher_ctx(crypto_ablkcipher_reqtfm(req));
+	rctx->mode &= AES_FLAGS_MODE_MASK;
+	dd->flags = (dd->flags & ~AES_FLAGS_MODE_MASK) | rctx->mode;
+	dd->ctx = ctx;
+	ctx->dd = dd;
+
+	err = aml_aes_write_ctrl(dd);
+	if (!err) {
+		if (dd->total % AML_AES_DMA_THRESHOLD == 0)
+			err = aml_aes_crypt_dma_start(dd, 1);
+		else {
+			pr_err("size %d is not multiple of %d",
+					dd->total, AML_AES_DMA_THRESHOLD);
+			err = -EINVAL;
+		}
+	}
+	if (err) {
+		/* aes_task will not finish it, so do it here */
+		aml_aes_finish_req(dd, err);
+		tasklet_schedule(&dd->queue_task);
+	}
+
+	return ret;
+}
+
+static int aml_aes_crypt_dma_stop(struct aml_aes_dev *dd)
+{
+	int err = -EINVAL;
+	size_t count;
+
+	if (dd->flags & AES_FLAGS_DMA) {
+		err = 0;
+		dma_sync_single_for_cpu(dd->dev, dd->dma_descript_tab,
+				NDMA_TABLE_SIZE, DMA_TO_DEVICE);
+		dma_sync_single_for_device(dd->dev, dd->dma_addr_out,
+				dd->dma_size, DMA_FROM_DEVICE);
+
+		/* copy data */
+		count = aml_aes_sg_copy(&dd->out_sg, &dd->out_offset,
+				dd->buf_out, dd->buflen, dd->dma_size, 1);
+		if (count != dd->dma_size) {
+			err = -EINVAL;
+			pr_err("not all data converted: %u\n", count);
+		}
+		dd->flags &= ~AES_FLAGS_DMA;
+	}
+
+	return err;
+}
+
+
+static int aml_aes_buff_init(struct aml_aes_dev *dd)
+{
+	int err = -ENOMEM;
+
+	dd->buf_in = (void *)__get_free_pages(GFP_KERNEL, 0);
+	dd->buf_out = (void *)__get_free_pages(GFP_KERNEL, 0);
+	dd->buflen = PAGE_SIZE;
+	dd->buflen &= ~(AES_BLOCK_SIZE - 1);
+
+	if (!dd->buf_in || !dd->buf_out) {
+		dev_err(dd->dev, "unable to alloc pages.\n");
+		goto err_alloc;
+	}
+
+	/* MAP here */
+	dd->dma_addr_in = dma_map_single(dd->dev, dd->buf_in,
+			dd->buflen, DMA_TO_DEVICE);
+	if (dma_mapping_error(dd->dev, dd->dma_addr_in)) {
+		dev_err(dd->dev, "dma %d bytes error\n", dd->buflen);
+		err = -EINVAL;
+		goto err_map_in;
+	}
+
+	dd->dma_addr_out = dma_map_single(dd->dev, dd->buf_out,
+			dd->buflen, DMA_FROM_DEVICE);
+	if (dma_mapping_error(dd->dev, dd->dma_addr_out)) {
+		dev_err(dd->dev, "dma %d bytes error\n", dd->buflen);
+		err = -EINVAL;
+		goto err_map_out;
+	}
+
+	dd->dma_descript_tab = dma_map_single(dd->dev,
+			(void *)ndma_aes_table_ptr,
+			NDMA_TABLE_SIZE, DMA_TO_DEVICE);
+
+	if (dma_mapping_error(dd->dev, dd->dma_descript_tab)) {
+		dev_err(dd->dev, "dma descriptor error\n");
+		err = -EINVAL;
+		goto err_map_descriptor;
+	}
+
+	return 0;
+
+err_map_descriptor:
+	dma_unmap_single(dd->dev, dd->dma_descript_tab, NDMA_TABLE_SIZE,
+			DMA_TO_DEVICE);
+
+err_map_out:
+	dma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,
+			DMA_TO_DEVICE);
+err_map_in:
+	free_page((unsigned long)dd->buf_out);
+	free_page((unsigned long)dd->buf_in);
+err_alloc:
+	if (err)
+		pr_err("error: %d\n", err);
+	return err;
+}
+
+static void aml_aes_buff_cleanup(struct aml_aes_dev *dd)
+{
+	dma_unmap_single(dd->dev, dd->dma_addr_out, dd->buflen,
+			DMA_FROM_DEVICE);
+	dma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,
+			DMA_TO_DEVICE);
+	free_page((unsigned long)dd->buf_out);
+	free_page((unsigned long)dd->buf_in);
+}
+
+static int aml_aes_crypt(struct ablkcipher_request *req, unsigned long mode)
+{
+	struct aml_aes_ctx *ctx = crypto_ablkcipher_ctx(
+			crypto_ablkcipher_reqtfm(req));
+	struct aml_aes_reqctx *rctx = ablkcipher_request_ctx(req);
+	struct aml_aes_dev *dd;
+
+	if (!IS_ALIGNED(req->nbytes, AES_BLOCK_SIZE)) {
+		pr_err("request size is not exact amount of AES blocks\n");
+		return -EINVAL;
+	}
+	ctx->block_size = AES_BLOCK_SIZE;
+
+	dd = aml_aes_find_dev(ctx);
+	if (!dd)
+		return -ENODEV;
+
+	rctx->mode = mode;
+
+	return aml_aes_handle_queue(dd, req);
+}
+
+static int aml_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
+		unsigned int keylen)
+{
+	struct aml_aes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
+
+	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&
+			keylen != AES_KEYSIZE_256) {
+		crypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		return -EINVAL;
+	}
+
+	memcpy(ctx->key, key, keylen);
+	ctx->keylen = keylen;
+
+	return 0;
+}
+
+static int aml_aes_ecb_encrypt(struct ablkcipher_request *req)
+{
+	return aml_aes_crypt(req,
+			AES_FLAGS_ENCRYPT);
+}
+
+static int aml_aes_ecb_decrypt(struct ablkcipher_request *req)
+{
+	return aml_aes_crypt(req,
+			0);
+}
+
+static int aml_aes_cbc_encrypt(struct ablkcipher_request *req)
+{
+	return aml_aes_crypt(req,
+			AES_FLAGS_ENCRYPT | AES_FLAGS_CBC);
+}
+
+static int aml_aes_cbc_decrypt(struct ablkcipher_request *req)
+{
+	return aml_aes_crypt(req,
+			AES_FLAGS_CBC);
+}
+
+static int aml_aes_ctr_encrypt(struct ablkcipher_request *req)
+{
+	return aml_aes_crypt(req,
+			AES_FLAGS_ENCRYPT | AES_FLAGS_CTR);
+}
+
+static int aml_aes_ctr_decrypt(struct ablkcipher_request *req)
+{
+	/* XXX: use encrypt to replace for decrypt */
+	return aml_aes_crypt(req,
+			AES_FLAGS_ENCRYPT | AES_FLAGS_CTR);
+}
+
+static int aml_aes_cra_init(struct crypto_tfm *tfm)
+{
+	tfm->crt_ablkcipher.reqsize = sizeof(struct aml_aes_reqctx);
+
+	return 0;
+}
+
+static void aml_aes_cra_exit(struct crypto_tfm *tfm)
+{
+}
+
+static struct crypto_alg aes_algs[] = {
+	{
+		.cra_name         = "ecb(aes)",
+		.cra_driver_name  = "ecb-aes-aml",
+		.cra_priority   = 300,
+		.cra_flags      = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize  = AES_BLOCK_SIZE,
+		.cra_ctxsize    = sizeof(struct aml_aes_ctx),
+		.cra_alignmask  = 0,
+		.cra_type       = &crypto_ablkcipher_type,
+		.cra_module     = THIS_MODULE,
+		.cra_init       = aml_aes_cra_init,
+		.cra_exit       = aml_aes_cra_exit,
+		.cra_u.ablkcipher = {
+			.min_keysize	=    AES_MIN_KEY_SIZE,
+			.max_keysize	=    AES_MAX_KEY_SIZE,
+			.ivsize		=    AES_BLOCK_SIZE,
+			.setkey		=    aml_aes_setkey,
+			.encrypt	=    aml_aes_ecb_encrypt,
+			.decrypt	=    aml_aes_ecb_decrypt,
+		}
+	},
+	{
+		.cra_name         = "cbc(aes)",
+		.cra_driver_name  = "cbc-aes-aml",
+		.cra_priority   = 300,
+		.cra_flags      = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize  = AES_BLOCK_SIZE,
+		.cra_ctxsize    = sizeof(struct aml_aes_ctx),
+		.cra_alignmask  = 0,
+		.cra_type       = &crypto_ablkcipher_type,
+		.cra_module     = THIS_MODULE,
+		.cra_init       = aml_aes_cra_init,
+		.cra_exit       = aml_aes_cra_exit,
+		.cra_u.ablkcipher = {
+			.min_keysize	=    AES_MIN_KEY_SIZE,
+			.max_keysize	=    AES_MAX_KEY_SIZE,
+			.ivsize		=    AES_BLOCK_SIZE,
+			.setkey		=    aml_aes_setkey,
+			.encrypt	=    aml_aes_cbc_encrypt,
+			.decrypt	=    aml_aes_cbc_decrypt,
+		}
+	},
+	{
+		.cra_name        = "ctr(aes)",
+		.cra_driver_name = "ctr-aes-aml",
+		.cra_priority    = 300,
+		.cra_flags      = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize  = AES_BLOCK_SIZE,
+		.cra_ctxsize    = sizeof(struct aml_aes_ctx),
+		.cra_alignmask  = 0,
+		.cra_type       = &crypto_ablkcipher_type,
+		.cra_module     = THIS_MODULE,
+		.cra_init       = aml_aes_cra_init,
+		.cra_exit       = aml_aes_cra_exit,
+		.cra_u.ablkcipher = {
+			.min_keysize	=    AES_MIN_KEY_SIZE,
+			.max_keysize	=    AES_MAX_KEY_SIZE,
+			.ivsize		=    AES_BLOCK_SIZE,
+			.setkey		=    aml_aes_setkey,
+			.encrypt	=    aml_aes_ctr_encrypt,
+			.decrypt	=    aml_aes_ctr_decrypt,
+		}
+	}
+};
+
+static void aml_aes_queue_task(unsigned long data)
+{
+	struct aml_aes_dev *dd = (struct aml_aes_dev *)data;
+	aml_aes_handle_queue(dd, NULL);
+}
+
+static void aml_aes_done_task(unsigned long data)
+{
+	struct aml_aes_dev *dd = (struct aml_aes_dev *) data;
+	int err;
+#if AML_CRYPTO_DEBUG
+	int i = 0;
+#endif
+
+	err = aml_aes_crypt_dma_stop(dd);
+
+#if AML_CRYPTO_DEBUG
+	for (i = 0x2270; i < 0x228D; i++)
+		pr_err("reg(%4x) = 0x%8lx\n", i, cbus_rd_reg(i));
+
+	for (i = 0; i < 8; i++) {
+		pr_err("table addr(%d) = 0x%8lx\n", i,
+				*(unsigned long *)(ndma_aes_table_ptr + i * 4));
+	}
+#endif
+	err = dd->err ? : err;
+
+	if (dd->total && !err) {
+		if (!err)
+			err = aml_aes_crypt_dma_start(dd, 0);
+		if (!err)
+			return; /* DMA started. Not fininishing. */
+	}
+
+	aml_aes_finish_req(dd, err);
+	aml_aes_handle_queue(dd, NULL);
+}
+
+static irqreturn_t aml_aes_irq(int irq, void *dev_id)
+{
+	struct aml_aes_dev *aes_dd = dev_id;
+
+	if (!(cbus_rd_reg(NDMA_TABLE_ADD_REG)
+				& (0xF << (AES_THREAD_INDEX * 8)))) {
+		if (AES_FLAGS_BUSY & aes_dd->flags) {
+			tasklet_schedule(&aes_dd->done_task);
+			return IRQ_HANDLED;
+		} else {
+			return IRQ_NONE;
+		}
+	} else {
+		pr_err("aes not completed yet?\n");
+	}
+
+
+	return IRQ_NONE;
+}
+
+static void aml_aes_unregister_algs(struct aml_aes_dev *dd)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(aes_algs); i++)
+		crypto_unregister_alg(&aes_algs[i]);
+}
+
+static int aml_aes_register_algs(struct aml_aes_dev *dd)
+{
+	int err, i, j;
+
+	for (i = 0; i < ARRAY_SIZE(aes_algs); i++) {
+		err = crypto_register_alg(&aes_algs[i]);
+		if (err)
+			goto err_aes_algs;
+	}
+
+	return 0;
+
+err_aes_algs:
+	for (j = 0; j < i; j++)
+		crypto_unregister_alg(&aes_algs[j]);
+
+	return err;
+}
+
+static int aml_aes_probe(struct platform_device *pdev)
+{
+	struct aml_aes_dev *aes_dd;
+	struct device *dev = &pdev->dev;
+	int err;
+
+	ndma_aes_table_ptr = NDMA_AES_TABLE_START;
+
+	aes_dd = kzalloc(sizeof(struct aml_aes_dev), GFP_KERNEL);
+	if (aes_dd == NULL) {
+		dev_err(dev, "unable to alloc data struct.\n");
+		err = -ENOMEM;
+		goto aes_dd_err;
+	}
+
+	aes_dd->dev = dev;
+
+	platform_set_drvdata(pdev, aes_dd);
+
+	INIT_LIST_HEAD(&aes_dd->list);
+
+	tasklet_init(&aes_dd->done_task, aml_aes_done_task,
+			(unsigned long)aes_dd);
+	tasklet_init(&aes_dd->queue_task, aml_aes_queue_task,
+			(unsigned long)aes_dd);
+
+	crypto_init_queue(&aes_dd->queue, AML_AES_QUEUE_LENGTH);
+
+	aes_dd->irq = INT_NDMA;
+
+	err = request_irq(aes_dd->irq, aml_aes_irq, IRQF_SHARED, "aml-aes",
+			aes_dd);
+	if (err) {
+		dev_err(dev, "unable to request aes irq.\n");
+		goto aes_irq_err;
+	}
+
+	err = aml_aes_hw_init(aes_dd);
+	if (err)
+		goto err_aes_buff;
+
+	err = aml_aes_buff_init(aes_dd);
+	if (err)
+		goto err_aes_buff;
+
+	spin_lock(&aml_aes.lock);
+	list_add_tail(&aes_dd->list, &aml_aes.dev_list);
+	spin_unlock(&aml_aes.lock);
+
+	err = aml_aes_register_algs(aes_dd);
+	if (err)
+		goto err_algs;
+
+	dev_info(dev, "Aml AES\n");
+
+	return 0;
+
+err_algs:
+	spin_lock(&aml_aes.lock);
+	list_del(&aes_dd->list);
+	spin_unlock(&aml_aes.lock);
+	aml_aes_buff_cleanup(aes_dd);
+err_aes_buff:
+	free_irq(aes_dd->irq, aes_dd);
+aes_irq_err:
+	tasklet_kill(&aes_dd->done_task);
+	tasklet_kill(&aes_dd->queue_task);
+	kfree(aes_dd);
+	aes_dd = NULL;
+aes_dd_err:
+	dev_err(dev, "initialization failed.\n");
+
+	return err;
+}
+
+static int aml_aes_remove(struct platform_device *pdev)
+{
+	static struct aml_aes_dev *aes_dd;
+
+	aes_dd = platform_get_drvdata(pdev);
+	if (!aes_dd)
+		return -ENODEV;
+	spin_lock(&aml_aes.lock);
+	list_del(&aes_dd->list);
+	spin_unlock(&aml_aes.lock);
+
+	aml_aes_unregister_algs(aes_dd);
+
+	tasklet_kill(&aes_dd->done_task);
+	tasklet_kill(&aes_dd->queue_task);
+
+	if (aes_dd->irq > 0)
+		free_irq(aes_dd->irq, aes_dd);
+
+	kfree(aes_dd);
+	aes_dd = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id aml_aes_dt_match[] = {
+	{	.compatible = "amlogic,aes",
+	},
+	{},
+};
+#else
+#define aml_aes_dt_match NULL
+#endif
+
+static struct platform_driver aml_aes_driver = {
+	.probe		= aml_aes_probe,
+	.remove		= aml_aes_remove,
+	.driver		= {
+		.name	= "aml_aes",
+		.owner	= THIS_MODULE,
+		.of_match_table = aml_aes_dt_match,
+	},
+};
+
+module_platform_driver(aml_aes_driver);
+
+MODULE_DESCRIPTION("Aml AES hw acceleration support.");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("matthew.shyu <matthew.shyu@amlogic.com>");
+#endif
diff --git a/drivers/amlogic/crypto/aml-crypto.c b/drivers/amlogic/crypto/aml-crypto.c
old mode 100755
new mode 100644
index 3d838ee0fd6f..1adb3690a2b8
--- a/drivers/amlogic/crypto/aml-crypto.c
+++ b/drivers/amlogic/crypto/aml-crypto.c
@@ -1,1146 +1,238 @@
-/* Copyright (C) 2004-2006, Advanced Micro Devices, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
 
-#include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/crypto.h>
-#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/hw_random.h>
+#include <linux/platform_device.h>
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/scatterlist.h>
 #include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <crypto/scatterwalk.h>
 #include <crypto/algapi.h>
-#include <crypto/aes.h>
-#include <crypto/des.h>
-
-#include <asm/io.h>
-#include <asm/delay.h>
-#include <mach/am_regs.h>
-
+#include <crypto/internal/hash.h>
+#include <mach/cpu.h>
+#include <mach/register.h>
+#include <mach/io.h>
+#include <mach/mod_gate.h>
 #include "aml-crypto.h"
 
-/* Static structures */
-
-#define AML_CRYPTO_DEBUG    0
-
-static spinlock_t lock;
-
-#define Wr(addr, data)  *(volatile unsigned long *)(CBUS_REG_ADDR(addr))=data
-#define Rd(addr)        *(volatile unsigned long *)(CBUS_REG_ADDR(addr))
-
 // ---------------------------------------------------------------------
 // DMA descriptor table support
 // ---------------------------------------------------------------------
-// There are 4 threads in the DMA...
-// Allocate descriptor table pointers
-#define NDMA_table_size     (32*4)
-unsigned char    NDMA_table_block[NDMA_table_size+32];
-unsigned long    NDMA_table_ptr;
-unsigned long    NDMA_table_ptr_start[4];
-unsigned long    NDMA_table_ptr_curr[4];
-unsigned long    NDMA_table_ptr_end[4];
-
-#define NDMA_TABLE_START    (((unsigned long)NDMA_table_block+0x1f)&(~0x1f))
-
-static unsigned long swap_ulong32(unsigned long val)
+unsigned long swap_ulong32(unsigned long val)
 {
-    unsigned char *p = (unsigned char *)&val;
-
-    return ((*p)<<24)+((*(p+1))<<16)+((*(p+2))<<8)+((*(p+3))<<0);
-}
-
-
-// --------------------------------------------------------
-static void    write_KEY_IV( 
-    unsigned long addr,
-    unsigned long data_hi,
-    unsigned long data_lo )
-{
-    unsigned long temp;
-
-    temp = swap_ulong32(data_lo);
-    Wr(NDMA_TDES_KEY_LO, temp);
-    temp = swap_ulong32(data_hi);
-    Wr(NDMA_TDES_KEY_HI, temp);
-
-    // Write the key
-    Wr(NDMA_TDES_CONTROL, ((1 << 31) | (addr << 0)) );
-}
-
-// --------------------------------------------------------
-static void    write_modes( 
-    unsigned long addr,
-    unsigned long cbc_en,
-    unsigned long decrypt,
-    unsigned long des_modes )
-{
-    // Write the key
-    Wr( NDMA_TDES_CONTROL, ((1 << 30)           | 
-                            (des_modes << 6)    |
-                            (cbc_en << 5)       |
-                            (decrypt << 4)      |
-                            (addr << 0)) );
-}
-
-void init_table_addr( unsigned long thread_num)
-{
-    memset((char *)NDMA_table_ptr,0,NDMA_table_size);
-    NDMA_table_ptr_start[thread_num] = NDMA_table_ptr;
-    NDMA_table_ptr_curr[thread_num]= NDMA_table_ptr;
-    NDMA_table_ptr_end[thread_num]= NDMA_table_ptr+NDMA_table_size;
+	unsigned char *p = (unsigned char *)&val;
 
+	return ((*p)<<24)+((*(p+1))<<16)+((*(p+2))<<8)+((*(p+3))<<0);
 }
 
 // --------------------------------------------
 //          NDMA_set_table_position
 // --------------------------------------------
-static void    NDMA_set_table_position( unsigned long thread_num,unsigned long table_start, unsigned long size)
-{
-    unsigned long table_end;
-    table_end = table_start+size;
- 
-    switch( thread_num ) {
-        case 3: Wr( NDMA_THREAD_TABLE_START3, table_start );
-                Wr( NDMA_THREAD_TABLE_END3, table_end );
-                // Pulse thread init to register the new start/end locations
-                Wr( NDMA_THREAD_REG, Rd(NDMA_THREAD_REG) | (1 << 27) );
-                break;
-        case 2: Wr( NDMA_THREAD_TABLE_START2, table_start );
-                Wr( NDMA_THREAD_TABLE_END2, table_end );
-                // Pulse thread init to register the new start/end locations
-                Wr( NDMA_THREAD_REG, Rd(NDMA_THREAD_REG) | (1 << 26) );
-                break;
-        case 1: Wr( NDMA_THREAD_TABLE_START1, table_start );
-                Wr( NDMA_THREAD_TABLE_END1, table_end );
-                // Pulse thread init to register the new start/end locations
-                Wr( NDMA_THREAD_REG, Rd(NDMA_THREAD_REG) | (1 << 25) );
-                break;
-        case 0: Wr( NDMA_THREAD_TABLE_START0, table_start );
-                Wr( NDMA_THREAD_TABLE_END0, table_end );
-                // Pulse thread init to register the new start/end locations
-                Wr( NDMA_THREAD_REG, Rd(NDMA_THREAD_REG) | (1 << 24) );
-                break;
-    }
-}
-
-
-// --------------------------------------------
-//          NDMA_add_descriptor_1d
-// --------------------------------------------
-static void    NDMA_add_descriptor_1d(
-unsigned long   thread_num,
-unsigned long   irq,
-unsigned long   restart,
-unsigned long   pre_endian,
-unsigned long   post_endian,
-unsigned long   type,
-unsigned long   bytes_to_move,
-unsigned long   inlinetype,
-unsigned long   src_addr,
-unsigned long   dest_addr )
-{
-    volatile unsigned long *p = (volatile unsigned long *)NDMA_table_ptr_curr[thread_num];
-    unsigned long curr_key;
-    unsigned long keytype;
-    unsigned long cryptodir;
-    unsigned long mode;
-    
-    (*p++) =  (0x01 << 30)          |       // owned by CPU
-              (pre_endian << 27)    |
-              (0 << 26)             |
-              (0 << 25)             |
-              (inlinetype << 22)             |       // TDES in-place processing
-              (irq  << 21)          |
-              (0 << 0);                     // thread slice
-
-    (*p++) =  src_addr;
-
-    (*p++) =  dest_addr;
-
-    (*p++) =  bytes_to_move & 0x01FFFFFF;
-
-    (*p++) =  0x00000000;       // 2D entry
-  
-    (*p++) =  0x00000000;       // 2D entry
- 
-    // Prepare the pointer for the next descriptor boundary
-    // inline processing + bytes to move extension
-    switch(inlinetype) {
-        case INLINE_TYPE_TDES: // TDES
-        		curr_key = (type&0x3);
-            (*p++) =  (restart << 6)      |
-              (curr_key << 3)     |
-              (post_endian << 0);
-            break;
-        case INLINE_TYPE_DIVX: // DIVX
-            (*p++) = post_endian & 0x7;
-            break;
-        case INLINE_TYPE_CRC: // CRC
-            (*p++) = post_endian & 0x7;
-            break;
-        case INLINE_TYPE_AES: // AES 
-        		keytype= (type&0x3);
-        		cryptodir = ((type>>2)&1);
-			mode = ((type>>3)&3);
-            (*p++) = (pre_endian<<0) |
-               (post_endian<<4)  |
-               (keytype<<8)  |
-               (cryptodir<<10)|
-               (((restart)?1:0)<<11)|
-               (mode<<12);		
-            break;    
-        default:
-            *p++ = 0;
-            break;
-    }
-    *p=0;
-
-
-    if( NDMA_table_ptr_curr[thread_num] == NDMA_table_ptr_end[thread_num] ) {
-        NDMA_table_ptr_curr[thread_num] = NDMA_table_ptr_start[thread_num];
-    } else {
-        NDMA_table_ptr_curr[thread_num] += 32; // point to the next location (8-4 byte table entries)
-    }
-}
-
-void NDMA_set_table_count(unsigned long thread_num,unsigned int cnt)
-{
-    Wr(NDMA_TABLE_ADD_REG, (thread_num << 8) | (cnt << 0) ); 
-}
-
-// --------------------------------------------
-//              NDMA_start()
-// --------------------------------------------
-// Start the block move procedure
-//
-static void    NDMA_start(unsigned long thread_num)
-{
-    Wr( NDMA_CNTL_REG0,  (Rd(NDMA_CNTL_REG0)  | (1 << 14))                  );   // Enable
-    Wr( NDMA_THREAD_REG, (Rd(NDMA_THREAD_REG) | (1 << (thread_num + 8)))    );
-}
-
-// --------------------------------------------
-//              NDMA_wait_for_completion()
-// --------------------------------------------
-// Wait for all block moves to complete
-//
-static void    NDMA_wait_for_completion(unsigned long thread_num)
-{   
-    if( !NDMA_table_ptr_start[thread_num] ) {  // there are no table entries
-        return;
-    }
-
-    while( (Rd(NDMA_TABLE_ADD_REG) & (0xF << (thread_num*8))) ) { }
-}
-
-static void set_tdes_key(unsigned long *key,unsigned int keylen,int idx,int dir)
-{
-    idx = (idx*4);
-
-    if(dir)
-    {
-        write_KEY_IV(idx+0, *(key+2*2),*(key+2*2+1));
-        write_KEY_IV(idx+1, *(key+1*2),*(key+1*2+1));    
-        write_KEY_IV(idx+2, *(key),*(key+1));
-    }
-    else
-    {
-        write_KEY_IV(idx+0, *(key),*(key+1));
-        write_KEY_IV(idx+1, *(key+1*2),*(key+1*2+1));
-        write_KEY_IV(idx+2, *(key+2*2),*(key+2*2+1));
-    }
-
-    if(keylen == DES_KEY_SIZE*3)
-    {
-        write_KEY_IV(idx+3, 0xffffffff,0x00000000); 
-    }
-    else
-    {
-        write_KEY_IV(idx+3, *(key+3*2),*(key+3*2+1));
-    }
-}
-
-unsigned int
-aml_tdes_crypt(struct aml_crypto_ctx *op)
-{
-    unsigned long iflags;
-    unsigned int tab_start;
-#if AML_CRYPTO_DEBUG 
-    int i;
-#endif
-    //int ret;
-    
-    if (op->len == 0)
-        return 0;
-
-    /* Start the critical section */
-    spin_lock_irqsave(&lock, iflags);
-
-    set_tdes_key(op->key, op->key_len,0,op->dir);
-    write_modes(0,          // unsigned long addr, 
-                    op->mode,          // unsigned long cbc_en, 
-                    op->dir,          // unsigned long decrypt, 
-                    (op->dir==1)? 5:2);        // unsigned long des_modes );
-
-    init_table_addr(op->threadidx);
-    
-    op->dma_src = dma_map_single(NULL, (void *)op->src, op->len, DMA_TO_DEVICE);
-    if(op->src != op->dst)
-        op->dma_dest = dma_map_single(NULL, (void *)op->dst, op->len, DMA_TO_DEVICE);
-    else
-        op->dma_dest = op->dma_src;
-    
-    NDMA_add_descriptor_1d(
-                        op->threadidx,              // unsigned long    thread_num
-                        0,              // unsigned long   irq,
-                        0,              // unsigned long   restart
-                        7,              // 0 unsigned long   pre_endian,
-                        7,              // unsigned long   post_endian,
-                        0,              // unsigned long   curr_key,
-                        op->len,              // unsigned long   bytes_to_move,
-                        INLINE_TYPE_TDES,   //inlinetype
-                        op->dma_src,     // unsigned long   src_addr,
-                        op->dma_dest);   // unsigned long   dest_addr )
-
-    tab_start = dma_map_single(NULL, (void *)NDMA_table_ptr, NDMA_table_size, DMA_TO_DEVICE);
-    //printk("bus addr = %8x,phy addr=%8x\n",NDMA_table_ptr,tab_start);
-    NDMA_set_table_position( 0, tab_start, NDMA_table_size );
-    NDMA_set_table_count(op->threadidx,1);  
-
-#if AML_CRYPTO_DEBUG
-    for(i=0x2270;i<0x228D;i++)
-        printk("reg(%4x) = 0x%8x\n",i,Rd(i));
-
-    for(i=0;i<8;i++)
-    {
-        printk("table addr(%d) = 0x%8x\n",i,*(unsigned long *)(NDMA_table_ptr+i*4));
-    }
-#endif
-
-    NDMA_start(op->threadidx);
-    NDMA_wait_for_completion(op->threadidx);
-
-    dma_unmap_single(NULL, tab_start, NDMA_table_size, DMA_FROM_DEVICE);
-    dma_unmap_single(NULL, op->dma_src, op->len,DMA_FROM_DEVICE);
-    if(op->dma_dest!=op->dma_src)
-        dma_unmap_single(NULL, op->dma_dest, op->len,DMA_FROM_DEVICE);
-#if AML_CRYPTO_DEBUG
-    for(i=0x2270;i<0x228D;i++)
-        printk("reg(%4x) = 0x%8x\n",i,Rd(i));
-
-    for(i=0;i<8;i++)
-    {
-        printk("table addr(%d) = 0x%8x\n",i,*(unsigned long *)(NDMA_table_ptr+i*4));
-    }
-#endif
-    spin_unlock_irqrestore(&lock, iflags);
-
-    return op->len;
-}
-
-static void set_aes_key(unsigned long *key,unsigned int keylen)
-{
-    Wr(NDMA_AES_KEY_0, *key);
-    Wr(NDMA_AES_KEY_1, *(key+1));
-    Wr(NDMA_AES_KEY_2, *(key+2));
-    Wr(NDMA_AES_KEY_3, *(key+3));
-    if(keylen>AES_KEYSIZE_128)
-    {
-    	Wr(NDMA_AES_KEY_4, *(key+4));
-    	Wr(NDMA_AES_KEY_5, *(key+5));
-    }
-    if(keylen>AES_KEYSIZE_192)
-    {
-      Wr(NDMA_AES_KEY_6, *(key+6));
-      Wr(NDMA_AES_KEY_7, *(key+7));
-    }    
-}
-
-static void set_aes_iv(unsigned long *iv)
-{
-    Wr(NDMA_AES_IV_0, *iv);
-    Wr(NDMA_AES_IV_1, *(iv+1));
-    Wr(NDMA_AES_IV_2, *(iv+2));
-    Wr(NDMA_AES_IV_3, *(iv+3));
-}
-
-static void set_aes_iv_big_endian(unsigned long *iv)
-{
-    Wr(NDMA_AES_IV_3, swap_ulong32(*iv));
-    Wr(NDMA_AES_IV_2, swap_ulong32(*(iv+1)));
-    Wr(NDMA_AES_IV_1, swap_ulong32(*(iv+2)));
-    Wr(NDMA_AES_IV_0, swap_ulong32(*(iv+3)));
-}
-//now only support decrypto
-unsigned int
-aml_aes_crypt(struct aml_crypto_ctx *op, unsigned long restart)
-{
-    unsigned long iflags;
-    unsigned int tab_start;
-    unsigned long type;
-#if AML_CRYPTO_DEBUG 
-    int i;
-#endif
-    //int ret;
-#if 0
-	char aes_key[16] = {0x7e,0x24,0x06,0x78,0x17,0xfa,0xe0,0xd7,
-	                                 0x43,0xd6,0xce,0x1f,0x32,0x53,0x91,0x63};
-       char aes_counter[16]= {0x00,0x6c,0xb6,0xdb,0xc0,0x54,0x3b,0x59,
-	   	                          0xda,0x48,0xd9,0x0b,0x00,0x00,0x00,0x01};
-       char aes_string[32] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
-	   	                        0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
-	   	                        0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
-	   	                        0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f};
-
-	op->len =32;
-	memcpy(op->src,aes_string,op->len);
-	memcpy(op->key,aes_key,16);
-	memcpy(op->iv,aes_counter,16);
-#endif
-
-    if (op->len == 0)
-        return 0;
-
-    /* Start the critical section */
-    spin_lock_irqsave(&lock, iflags);
-
-    set_aes_key(op->key, op->key_len);
-    if (op->mode == MODE_CBC)
-    	set_aes_iv(op->iv);
-    else if (op->mode == MODE_CTR) {
-        set_aes_iv_big_endian(op->iv);
-    }
-    	                    	
-    init_table_addr(op->threadidx);
-
-    op->dma_src = dma_map_single(NULL, (void *)op->src, op->len, DMA_TO_DEVICE);
-    if(op->src != op->dst)
-        op->dma_dest = dma_map_single(NULL, (void *)op->dst, op->len, DMA_TO_DEVICE);
-    else
-        op->dma_dest = op->dma_src;
-    
-    type = ((op->mode&0x3)<<3)|
-		(((op->dir==DIR_DECRYPT)?0:1)<<2)|
-    	     ((op->key_len==AES_KEYSIZE_128)?0:((op->key_len==AES_KEYSIZE_192)?1:2));
-    NDMA_add_descriptor_1d(
-                        op->threadidx,              // unsigned long    thread_num
-                        0,              // unsigned long   irq,
-                        restart,              // unsigned long   restart
-                        0,              // 0 unsigned long   pre_endian,
-                        0,              // unsigned long   post_endian,
-                        type,              // unsigned long   keytype + cryptodir,
-                        op->len,              // unsigned long   bytes_to_move,
-                        INLINE_TYPE_AES,   //inlinetype
-                        op->dma_src,     // unsigned long   src_addr,
-                        op->dma_dest);   // unsigned long   dest_addr )
-
-    tab_start = dma_map_single(NULL, (void *)NDMA_table_ptr, NDMA_table_size, DMA_TO_DEVICE);
-    //printk("bus addr = %8x,phy addr=%8x\n",NDMA_table_ptr,tab_start);
-    NDMA_set_table_position( 0, tab_start, NDMA_table_size );
-    NDMA_set_table_count(op->threadidx,1);  
-
-#if AML_CRYPTO_DEBUG
-    for(i=0x2270;i<0x229d;i++)
-        printk("reg(%4x) = 0x%8x\n",i,Rd(i));
-
-    for(i=0;i<8;i++)
-    {
-        printk("table addr(%d) = 0x%8x\n",i,*(unsigned long *)(NDMA_table_ptr+i*4));
-    }
-#endif
-
-    NDMA_start(op->threadidx);
-    NDMA_wait_for_completion(op->threadidx);
-
-    dma_unmap_single(NULL, tab_start, NDMA_table_size, DMA_FROM_DEVICE);
-    dma_unmap_single(NULL, op->dma_src, op->len,DMA_FROM_DEVICE);
-    if(op->dma_dest!=op->dma_src)
-        dma_unmap_single(NULL, op->dma_dest, op->len,DMA_FROM_DEVICE);
-#if AML_CRYPTO_DEBUG
-    for(i=0x2270;i<0x229d;i++)
-        printk("reg(%4x) = 0x%8x\n",i,Rd(i));
-
-    for(i=0;i<8;i++)
-    {
-        printk("table addr(%d) = 0x%8x\n",i,*(unsigned long *)(NDMA_table_ptr+i*4));
-    }	
-#endif
-#if 0
-    for(i=0;i<32;i++)
-    {
-        printk("dst(%d) = 0x%x\n",i,*((unsigned char *)op->dst + i));
-    }
-#endif
-    spin_unlock_irqrestore(&lock, iflags);
-
-    return op->len;
-}
-
-static int aml_tdes_setkey_blk(struct crypto_tfm *tfm, const u8 *key,
-		unsigned int len)
-{
-    struct aml_crypto_ctx *op = crypto_tfm_ctx(tfm);
-    
-    op->key_len = len;
-
-    if ((len > TDES_KEY_LENGTH) ||(len<DES_KEY_SIZE*3)){
-        printk("aml_ecb_tdes key len is wrong.\n");
-        return 1;
-    }
-
-    memcpy(op->key, key, len);
-    return 0;
-}
-
-/************************
-tdes ecb  crypto
-*************************/
-static int
-aml_ecb_tdes_decrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-
-    if ((op->key_len > TDES_KEY_LENGTH) ||(op->key_len<DES_KEY_SIZE*3)){
-        printk("aml_ecb_tdes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-
-    //printk("blkcipher_walk_virt return %d\n",err);
-    while((nbytes = walk.nbytes)) {  
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_ECB;
-        op->len = nbytes - (nbytes % TDES_MIN_BLOCK_SIZE);
-        op->dir = DIR_DECRYPT;
-        op->threadidx = 0;
-        ret = aml_tdes_crypt(op);
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-        //printk("blkcipher_walk_done return %d nbyte = 0x%x\n",err,nbytes);
-    }
-
-    return err;
-}
-
-static int
-aml_ecb_tdes_encrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-
-    if ((op->key_len > TDES_KEY_LENGTH) ||(op->key_len<DES_KEY_SIZE*3)){
-        printk("aml_ecb_tdes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-    //printk("blkcipher_walk_virt return %d\n",err);
-    while((nbytes = walk.nbytes)) {
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_ECB;
-        op->len = nbytes - (nbytes % TDES_MIN_BLOCK_SIZE);
-        op->dir = DIR_ENCRYPT;
-        op->threadidx = 0;
-        ret = aml_tdes_crypt(op);
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-        //printk("blkcipher_walk_done return %d nbyte = 0x%x\n",err,nbytes);
-    }
-
-    return err;
-}
-
-static struct crypto_alg aml_ecb_tdes_alg = {
-	.cra_name			=	"ecb(tdes)",
-	.cra_driver_name	=	"ecb-tdes-aml",
-	.cra_priority		=	300,
-	.cra_flags			=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	TDES_MIN_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct aml_crypto_ctx),
-	.cra_alignmask		=	0,
-	.cra_type			=	&crypto_blkcipher_type,
-	.cra_module			=	THIS_MODULE,
-	.cra_list			=	LIST_HEAD_INIT(aml_ecb_tdes_alg.cra_list),
-	.cra_u				=	{
-		.blkcipher	=	{
-                     .min_keysize	=	TDES_KEY_LENGTH-8,
-			.max_keysize	=	TDES_KEY_LENGTH,
-			.setkey			=	aml_tdes_setkey_blk,
-			.encrypt		=	aml_ecb_tdes_encrypt,
-			.decrypt		=	aml_ecb_tdes_decrypt,
-		}
+void ndma_set_table_position(unsigned long thread_num,
+		unsigned long table_start, unsigned long size)
+{
+	unsigned long table_end;
+	table_end = table_start+size;
+
+	switch (thread_num) {
+	case 3:
+		cbus_wr_reg(NDMA_THREAD_TABLE_START3, table_start);
+		cbus_wr_reg(NDMA_THREAD_TABLE_END3, table_end);
+		/* Pulse thread init to register the new start/end locations */
+		cbus_wr_reg(NDMA_THREAD_REG,
+				cbus_rd_reg(NDMA_THREAD_REG) | (1 << 27));
+		break;
+	case 2:
+		cbus_wr_reg(NDMA_THREAD_TABLE_START2, table_start);
+		cbus_wr_reg(NDMA_THREAD_TABLE_END2, table_end);
+		/* Pulse thread init to register the new start/end locations */
+		cbus_wr_reg(NDMA_THREAD_REG,
+				cbus_rd_reg(NDMA_THREAD_REG) | (1 << 26));
+		break;
+	case 1:
+		cbus_wr_reg(NDMA_THREAD_TABLE_START1, table_start);
+		cbus_wr_reg(NDMA_THREAD_TABLE_END1, table_end);
+		/* Pulse thread init to register the new start/end locations */
+		cbus_wr_reg(NDMA_THREAD_REG,
+				cbus_rd_reg(NDMA_THREAD_REG) | (1 << 25));
+		break;
+	case 0:
+		cbus_wr_reg(NDMA_THREAD_TABLE_START0, table_start);
+		cbus_wr_reg(NDMA_THREAD_TABLE_END0, table_end);
+		/* Pulse thread init to register the new start/end locations */
+		cbus_wr_reg(NDMA_THREAD_REG,
+				cbus_rd_reg(NDMA_THREAD_REG) | (1 << 24));
+		break;
 	}
-};
-
-/************************
-tdes cbc  crypto
-*************************/
-static int
-aml_cbc_tdes_decrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-
-    if ((op->key_len > TDES_KEY_LENGTH) ||(op->key_len<DES_KEY_SIZE*3)){
-        printk("aml_cbc_tdes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-    
-    while((nbytes = walk.nbytes)) {  
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_CBC;
-        op->len = nbytes - (nbytes % TDES_MIN_BLOCK_SIZE);
-        op->dir = DIR_DECRYPT;
-        op->threadidx = 0;
-        ret = aml_tdes_crypt(op);
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-    }
-
-    return err;
-}
-
-static int
-aml_cbc_tdes_encrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-
-    if ((op->key_len > TDES_KEY_LENGTH) ||(op->key_len<DES_KEY_SIZE*3)){
-        printk("aml_cbc_tdes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-    while((nbytes = walk.nbytes)) {
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_CBC;
-        op->len = nbytes - (nbytes % TDES_MIN_BLOCK_SIZE);
-        op->dir = DIR_ENCRYPT;
-        op->threadidx = 0;
-        ret = aml_tdes_crypt(op);
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-    }
-
-    return err;
 }
 
-static struct crypto_alg aml_cbc_tdes_alg = {
-	.cra_name			=	"cbc(tdes)",
-	.cra_driver_name	=	"cbc-tdes-aml",
-	.cra_priority		=	300,
-	.cra_flags			=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	TDES_MIN_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct aml_crypto_ctx),
-	.cra_alignmask		=	0,
-	.cra_type			=	&crypto_blkcipher_type,
-	.cra_module			=	THIS_MODULE,
-	.cra_list			=	LIST_HEAD_INIT(aml_cbc_tdes_alg.cra_list),
-	.cra_u				=	{
-		.blkcipher	=	{
-                     .min_keysize	=	TDES_KEY_LENGTH-8,
-			.max_keysize	=	TDES_KEY_LENGTH,
-			.setkey			=	aml_tdes_setkey_blk,
-			.encrypt		=	aml_cbc_tdes_encrypt,
-			.decrypt		=	aml_cbc_tdes_decrypt,
-		}
+void ndma_set_table_position_secure(unsigned long thread_num,
+		unsigned long table_start, unsigned long size)
+{
+	unsigned long table_end;
+	table_end = table_start+size;
+	switch (thread_num) {
+	case 3:
+		secure_apb_slot3_wr_reg(SEC_BLKMV_THREAD_TABLE_START3,
+				table_start);
+		secure_apb_slot3_wr_reg(SEC_BLKMV_THREAD_TABLE_END3, table_end);
+		/* Pulse thread init to register the new start/end locations */
+		cbus_wr_reg(NDMA_THREAD_REG,
+				cbus_rd_reg(NDMA_THREAD_REG) | (1 << 27));
+		break;
+	case 2:
+		secure_apb_slot3_wr_reg(SEC_BLKMV_THREAD_TABLE_START2,
+				table_start);
+		secure_apb_slot3_wr_reg(SEC_BLKMV_THREAD_TABLE_END2, table_end);
+		/* Pulse thread init to register the new start/end locations */
+		cbus_wr_reg(NDMA_THREAD_REG,
+				cbus_rd_reg(NDMA_THREAD_REG) | (1 << 26));
+		break;
+	case 1:
+		secure_apb_slot3_wr_reg(SEC_BLKMV_THREAD_TABLE_START1,
+				table_start);
+		secure_apb_slot3_wr_reg(SEC_BLKMV_THREAD_TABLE_END1, table_end);
+		/* Pulse thread init to register the new start/end locations */
+		cbus_wr_reg(NDMA_THREAD_REG,
+				cbus_rd_reg(NDMA_THREAD_REG) | (1 << 25));
+		break;
+	case 0:
+		secure_apb_slot3_wr_reg(SEC_BLKMV_THREAD_TABLE_START0,
+				table_start);
+		secure_apb_slot3_wr_reg(SEC_BLKMV_THREAD_TABLE_END0, table_end);
+		/* Pulse thread init to register the new start/end locations */
+		cbus_wr_reg(NDMA_THREAD_REG,
+				cbus_rd_reg(NDMA_THREAD_REG) | (1 << 24));
+		break;
 	}
-};
-
-/************************
-aes ecb  crypto
-*************************/
-static int aml_ecb_aes_setkey_blk(struct crypto_tfm *tfm, const u8 *key,
-		unsigned int len)
-{
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
-		printk("aes alg by hardware is not support on this chip.\n");
-    return 1;
-#else	
-    struct aml_crypto_ctx *op = crypto_tfm_ctx(tfm);
-    
-    if (len != AES_KEYSIZE_192 && len != AES_KEYSIZE_256 && len != AES_KEYSIZE_128) {
-        printk("aml_ecb_aes key len is wrong.\n");
-        return 1;
-    }
-    op->key_len = len;
-    memcpy(op->key, key, len);
-    return 0;
-#endif
 }
-
-static int
-aml_ecb_aes_encrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
-		printk("ecb-aes alg by hardware is not support on this chip.\n");
-    return 1;
-#else	 
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-
-    if (op->key_len != AES_KEYSIZE_192 && op->key_len != AES_KEYSIZE_256 && op->key_len != AES_KEYSIZE_128) {
-        printk("aml_ecb_aes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-    while((nbytes = walk.nbytes)) {
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_ECB;
-        op->len = nbytes - (nbytes % AES_BLOCK_SIZE);
-        op->dir = DIR_ENCRYPT;
-        op->threadidx = 0;
-        ret = aml_aes_crypt(op, 0);
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-    }
-
-    return err;
-#endif
-}
-
-static int
-aml_ecb_aes_decrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
-		printk("ecb-aes alg by hardware is not support on this chip.\n");
-    return 1;
-#else	
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-
-    if (op->key_len != AES_KEYSIZE_192 && op->key_len != AES_KEYSIZE_256 && op->key_len != AES_KEYSIZE_128) {
-        printk("aml_ecb_aes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-    while((nbytes = walk.nbytes)) {
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_ECB;
-        op->len = nbytes - (nbytes % AES_BLOCK_SIZE);
-        op->dir = DIR_DECRYPT;
-        op->threadidx = 0;
-        ret = aml_aes_crypt(op, 0);
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-    }
-
-    return err;
-#endif
-}
-
-static struct crypto_alg aml_ecb_aes_alg = {
-	.cra_name			=	"ecb-aes-aml",
-	.cra_driver_name	=	"ecb-aes-aml",
-	.cra_priority		=	300,
-	.cra_flags			=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	AES_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct aml_crypto_ctx),
-	.cra_alignmask		=	0,
-	.cra_type			=	&crypto_blkcipher_type,
-	.cra_module			=	THIS_MODULE,
-	.cra_list			=	LIST_HEAD_INIT(aml_ecb_aes_alg.cra_list),
-	.cra_u				=	{
-		.blkcipher	=	{
-                     .min_keysize	=	AES_MIN_KEY_SIZE,
-			.max_keysize	=	AES_MAX_KEY_SIZE,
-			.setkey			=	aml_ecb_aes_setkey_blk,
-			.encrypt		=	aml_ecb_aes_encrypt,
-			.decrypt		=	aml_ecb_aes_decrypt,
-		}
-	}
-};
-
-
-/************************
-aes cbc  crypto
-*************************/
-static int aml_cbc_aes_setkey_blk(struct crypto_tfm *tfm, const u8 *key,
-		unsigned int len)
-{
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
-		printk("aes alg by hardware is not support on this chip.\n");
-    return 1;
-#else	
-    struct aml_crypto_ctx *op = crypto_tfm_ctx(tfm);
-    int ivsize = AES_BLOCK_SIZE;
-    int keysize = len-ivsize;
-    
-    if (keysize != AES_KEYSIZE_192 && keysize != AES_KEYSIZE_256 && keysize != AES_KEYSIZE_128) {
-        printk("aml_ecb_aes key len is wrong.\n");
-        return 1;
-    }
-    op->key_len = keysize;
-    memcpy(op->key, key, keysize);
-    memcpy(op->iv,key+keysize,ivsize);
-    return 0;
-#endif
-}
-
-static int
-aml_cbc_aes_encrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
-		printk("cbc-aes alg by hardware is not support on this chip.\n");
-    return 1;
-#else	 
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-    unsigned long restart = 1;
-
-    if (op->key_len != AES_KEYSIZE_192 && op->key_len != AES_KEYSIZE_256 && op->key_len != AES_KEYSIZE_128) {
-        printk("aml_cbc_aes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-    while((nbytes = walk.nbytes)) {
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_CBC;
-        op->len = nbytes - (nbytes % AES_BLOCK_SIZE);
-        op->dir = DIR_ENCRYPT;
-        op->threadidx = 0;
-        ret = aml_aes_crypt(op, restart);
-        restart = 0;
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-    }
-
-    return err;
-#endif
-}
-
-static int
-aml_cbc_aes_decrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
-{
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
-		printk("cbc-aes alg by hardware is not support on this chip.\n");
-    return 1;
-#else	
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-    unsigned long restart = 1;
-
-    if (op->key_len != AES_KEYSIZE_192 && op->key_len != AES_KEYSIZE_256 && op->key_len != AES_KEYSIZE_128) {
-        printk("aml_cbc_aes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-    while((nbytes = walk.nbytes)) {
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_CBC;
-        op->len = nbytes - (nbytes % AES_BLOCK_SIZE);
-        op->dir = DIR_DECRYPT;
-        op->threadidx = 0;
-        ret = aml_aes_crypt(op, restart);
-        restart = 0;
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-    }
-
-    return err;
-#endif
-}
-
-static struct crypto_alg aml_cbc_aes_alg = {
-	.cra_name			=	"cbc-aes-aml",
-	.cra_driver_name	=	"cbc-aes-aml",
-	.cra_priority		=	300,
-	.cra_flags			=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	AES_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct aml_crypto_ctx),
-	.cra_alignmask		=	0,
-	.cra_type			=	&crypto_blkcipher_type,
-	.cra_module			=	THIS_MODULE,
-	.cra_list			=	LIST_HEAD_INIT(aml_cbc_aes_alg.cra_list),
-	.cra_u				=	{
-		.blkcipher	=	{
-                     .min_keysize	=	AES_MIN_KEY_SIZE+AES_BLOCK_SIZE,
-			.max_keysize	=	AES_MAX_KEY_SIZE+AES_BLOCK_SIZE,
-			.setkey			=	aml_cbc_aes_setkey_blk,
-			.encrypt		=	aml_cbc_aes_encrypt,
-			.decrypt		=	aml_cbc_aes_decrypt,
-		}
+/* --------------------------------------------
+   ndma_add_descriptor_1d
+   -------------------------------------------- */
+void  ndma_add_descriptor_1d(
+		unsigned long   table,
+		unsigned long   irq,
+		unsigned long   restart,
+		unsigned long   pre_endian,
+		unsigned long   post_endian,
+		unsigned long   type,
+		unsigned long   bytes_to_move,
+		unsigned long   inlinetype,
+		unsigned long   src_addr,
+		unsigned long   dest_addr)
+{
+	unsigned long *p = (unsigned long *) table;
+	unsigned long curr_key;
+	unsigned long keytype;
+	unsigned long cryptodir;
+	unsigned long mode;
+
+	(*p++) =  (0x01 << 30)        | /* owned by CPU */
+		(pre_endian << 27)    |
+		(0 << 26)             |
+		(0 << 25)             |
+		(inlinetype << 22)    | /* TDES in-place processing */
+		(irq  << 21)          |
+		(0 << 0);                     /* thread slice */
+
+	(*p++) =  src_addr;
+
+	(*p++) =  dest_addr;
+
+	(*p++) =  bytes_to_move & 0x01FFFFFF;
+
+	(*p++) =  0x00000000;       /* 2D entry */
+
+	(*p++) =  0x00000000;       /* 2D entry */
+
+	/* Prepare the pointer for the next descriptor boundary
+	   inline processing + bytes to move extension */
+	switch (inlinetype) {
+	case INLINE_TYPE_TDES:
+		curr_key = (type & 0x3);
+		(*p++) =  (restart << 6)      |
+			(curr_key << 3)     |
+			(post_endian << 0);
+		break;
+	case INLINE_TYPE_DIVX:
+		(*p++) = post_endian & 0x7;
+		break;
+	case INLINE_TYPE_CRC:
+		(*p++) = post_endian & 0x7;
+		break;
+	case INLINE_TYPE_AES:
+		keytype = (type & 0x3);
+		cryptodir = ((type >> 2) & 1);
+		mode = ((type >> 3) & 3);
+		(*p++) = (pre_endian << 0) |
+			(post_endian << 4)  |
+			(keytype << 8)  |
+			(cryptodir << 10)|
+			(((restart) ? 1 : 0) << 11)|
+			(mode << 12) |
+			(0 << 14) | /* 128 bit ctr */
+			(0xf << 16); /* big endian */
+		break;
+	default:
+		*p++ = 0;
+		break;
 	}
-};
+	*p = 0;
 
-/************************
-aes ctr  crypto
-*************************/
-static int aml_ctr_aes_setkey_blk(struct crypto_tfm *tfm, const u8 *key,
-		unsigned int len)
-{
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
-		printk("aes alg by hardware is not support on this chip.\n");
-    return 1;
-#else	
-    struct aml_crypto_ctx *op = crypto_tfm_ctx(tfm);
-    int ivsize = AES_BLOCK_SIZE;
-    int keysize = len-ivsize;
-    
-    if (keysize != AES_KEYSIZE_192 && keysize != AES_KEYSIZE_256 && keysize != AES_KEYSIZE_128) {
-        printk("aml_ecb_aes key len is wrong.\n");
-        return 1;
-    }
-    op->key_len = keysize;
-    memcpy(op->key, key, keysize);
-    memcpy(op->iv,key+keysize,ivsize);
-    return 0;
-#endif
 }
 
-static int
-aml_ctr_aes_encrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
+void ndma_set_table_count(unsigned long thread_num, unsigned int cnt)
 {
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
-		printk("cbc-aes alg by hardware is not support on this chip.\n");
-    return 1;
-#else	 
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-
-    unsigned long restart = 1;
-    if (op->key_len != AES_KEYSIZE_192 && op->key_len != AES_KEYSIZE_256 && op->key_len != AES_KEYSIZE_128) {
-        printk("aml_cbc_aes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-    while((nbytes = walk.nbytes)) {
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_CTR;
-        op->len = nbytes - (nbytes % AES_BLOCK_SIZE);
-        op->dir = DIR_ENCRYPT;
-        op->threadidx = 0;
-        ret = aml_aes_crypt(op, restart);
-        restart = 0;
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-    }
-
-    return err;
-#endif
+	cbus_wr_reg(NDMA_TABLE_ADD_REG, (thread_num << 8) | (cnt << 0));
 }
 
-static int
-aml_ctr_aes_decrypt(struct blkcipher_desc *desc,
-		  struct scatterlist *dst, struct scatterlist *src,
-		  unsigned int nbytes)
+/* --------------------------------------------
+   ndma_start()
+   --------------------------------------------
+   Start the block move procedure
+*/
+void ndma_start(unsigned long thread_num)
 {
-#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
-		printk("cbc-aes alg by hardware is not support on this chip.\n");
-    return 1;
-#else	
-    struct aml_crypto_ctx *op = crypto_blkcipher_ctx(desc->tfm);
-    struct blkcipher_walk walk;
-    int err=0, ret;
-    unsigned long restart = 1;
-
-    if (op->key_len != AES_KEYSIZE_192 && op->key_len != AES_KEYSIZE_256 && op->key_len != AES_KEYSIZE_128) {
-        printk("aml_cbc_aes key len is wrong.\n");
-        return 1;
-    }
-
-    blkcipher_walk_init(&walk, dst, src, nbytes);
-    err = blkcipher_walk_virt(desc, &walk);
-    while((nbytes = walk.nbytes)) {
-        op->src = walk.src.virt.addr,
-        op->dst = walk.dst.virt.addr;
-        op->mode = MODE_CTR;
-        op->len = nbytes - (nbytes % AES_BLOCK_SIZE);
-        op->dir = DIR_DECRYPT;
-        op->threadidx = 0;
-        ret = aml_aes_crypt(op, restart);
-        restart = 0;
-
-        nbytes -= ret;
-        err = blkcipher_walk_done(desc, &walk, nbytes);
-    }
-
-    return err;
-#endif
+	/* Enable */
+	cbus_wr_reg(NDMA_CNTL_REG0,
+			(cbus_rd_reg(NDMA_CNTL_REG0)  | (1 << NDMA_ENABLE)));
+	cbus_wr_reg(NDMA_THREAD_REG,
+			(cbus_rd_reg(NDMA_THREAD_REG)
+			 | (1 << (thread_num + 8))));
 }
 
-static struct crypto_alg aml_ctr_aes_alg = {
-	.cra_name			=	"ctr-aes-aml",
-	.cra_driver_name	=	"ctr-aes-aml",
-	.cra_priority		=	300,
-	.cra_flags			=	CRYPTO_ALG_TYPE_BLKCIPHER,
-	.cra_blocksize		=	AES_BLOCK_SIZE,
-	.cra_ctxsize		=	sizeof(struct aml_crypto_ctx),
-	.cra_alignmask		=	0,
-	.cra_type			=	&crypto_blkcipher_type,
-	.cra_module			=	THIS_MODULE,
-	.cra_list			=	LIST_HEAD_INIT(aml_ctr_aes_alg.cra_list),
-	.cra_u				=	{
-		.blkcipher	=	{
-                     .min_keysize	=	AES_MIN_KEY_SIZE+AES_BLOCK_SIZE,
-			.max_keysize	=	AES_MAX_KEY_SIZE+AES_BLOCK_SIZE,
-			.setkey			=	aml_ctr_aes_setkey_blk,
-			.encrypt		=	aml_ctr_aes_encrypt,
-			.decrypt		=	aml_ctr_aes_decrypt,
-		}
-	}
-};
-#define blkmove_thread_idx  2
-unsigned int
-aml_blkmove(unsigned char * dst,unsigned char * src,unsigned long count)
+void ndma_stop(unsigned long thread_num)
 {
-    unsigned long iflags;
-    unsigned int tab_start;
-    unsigned int dma_src;
-    unsigned int dma_dest;
-    
-    if (count == 0)
-        return 0;
-
-    if(dst==src)
-        return 0;
-    
-    if(count>0x1ffffff)
-    {
-        printk("aml_blkmove count is too large!\n");
-        return -1;
-    }
-    /* Start the critical section */
-    spin_lock_irqsave(&lock, iflags);
-    init_table_addr(blkmove_thread_idx);
-    
-    dma_src = dma_map_single(NULL, (void *)src, count, DMA_TO_DEVICE);
-    dma_dest = dma_map_single(NULL, (void *)dst, count, DMA_TO_DEVICE);
-    NDMA_add_descriptor_1d(
-                        blkmove_thread_idx,              // unsigned long    thread_num
-                        0,              // unsigned long   irq,
-                        0,              // unsigned long   restart
-                        0,              // 0 unsigned long   pre_endian,
-                        0,              // unsigned long   post_endian,
-                        0,              // unsigned long   curr_key,
-                        count,              // unsigned long   bytes_to_move,
-                        INLINE_TYPE_NORMAL,   //inlinetype
-                        dma_src,     // unsigned long   src_addr,
-                        dma_dest);   // unsigned long   dest_addr )
-
-    tab_start = dma_map_single(NULL, (void *)NDMA_table_ptr, NDMA_table_size, DMA_TO_DEVICE);
-    //printk("bus addr = %8x,phy addr=%8x\n",NDMA_table_ptr,tab_start);
-    NDMA_set_table_position( blkmove_thread_idx, tab_start, NDMA_table_size );
-    NDMA_set_table_count(blkmove_thread_idx,1);  
-
-    NDMA_start(blkmove_thread_idx);
-    NDMA_wait_for_completion(blkmove_thread_idx);
-
-    dma_unmap_single(NULL, tab_start, NDMA_table_size, DMA_FROM_DEVICE);
-    dma_unmap_single(NULL, dma_src, count,DMA_FROM_DEVICE);
-    dma_unmap_single(NULL, dma_dest, count,DMA_FROM_DEVICE);
-    spin_unlock_irqrestore(&lock, iflags);
-
-    return 0;
+	cbus_wr_reg(NDMA_THREAD_REG,
+			cbus_rd_reg(NDMA_THREAD_REG)
+			& ~(1 << (thread_num + 8)));
+	/* If no threads enabled, then shut down the DMA engine completely */
+	if (!(cbus_rd_reg(NDMA_THREAD_REG) & (0xF << 8)))
+		cbus_wr_reg(NDMA_CNTL_REG0,
+				cbus_rd_reg(NDMA_CNTL_REG0)
+				& ~(1 << NDMA_ENABLE));
 }
-EXPORT_SYMBOL(aml_blkmove);
-
-static int __init aml_hw_crypto_init(void)
-{
-    int ret;
 
-    NDMA_table_ptr = NDMA_TABLE_START;
-    
-    printk("aml_hw_crypto initialization.\n");   
-    if ((ret = crypto_register_alg(&aml_ecb_tdes_alg)))
-        goto efail;
+/* --------------------------------------------
+   ndma_wait_for_completion()
+   --------------------------------------------
+   Wait for all block moves to complete */
 
-    if ((ret = crypto_register_alg(&aml_cbc_tdes_alg)))
-        goto efail;
-
-    if ((ret = crypto_register_alg(&aml_ecb_aes_alg)))
-        goto efail;
-
-    if ((ret = crypto_register_alg(&aml_cbc_aes_alg)))
-        goto efail;	
-	
-    if ((ret = crypto_register_alg(&aml_ctr_aes_alg)))
-        goto efail;		
-	
-    return 0;
-efail:
-    printk(KERN_ERR "aml_hw_crypto initialization failed.\n");
-    return ret;
-}
-module_init(aml_hw_crypto_init);
-
-static void __exit aml_hw_crypto_exit(void)
+void ndma_wait_for_completion(unsigned long thread_num)
 {
-    crypto_unregister_alg(&aml_ecb_tdes_alg);
-    crypto_unregister_alg(&aml_cbc_tdes_alg);
-    crypto_unregister_alg(&aml_ecb_aes_alg);
-    crypto_unregister_alg(&aml_cbc_aes_alg);
-    crypto_unregister_alg(&aml_ctr_aes_alg);
+	while ((cbus_rd_reg(NDMA_TABLE_ADD_REG) & (0xF << (thread_num*8))))
+		;
 }
-module_exit(aml_hw_crypto_exit);
-
-MODULE_AUTHOR("qi.duan <qi.duan@amlogic.om>");
-MODULE_DESCRIPTION("Support for amlogic's cryptographic engine");
-MODULE_LICENSE("GPL");
 
diff --git a/drivers/amlogic/crypto/aml-crypto.h b/drivers/amlogic/crypto/aml-crypto.h
old mode 100755
new mode 100644
index 0c4316d58a77..0c6b38d3f3ec
--- a/drivers/amlogic/crypto/aml-crypto.h
+++ b/drivers/amlogic/crypto/aml-crypto.h
@@ -6,9 +6,22 @@
  * (at your option) any later version.
  */
 
-#ifndef _GEODE_AES_H_
-#define _GEODE_AES_H_
+#ifndef _AML_CRYPTO_H_
+#define _AML_CRYPTO_H_
 
+#define AML_CRYPTO_DEBUG    0
+
+#define secure_apb_slot3_wr_reg(addr, data)  \
+	aml_write_reg32(SECBUS3_REG_ADDR(addr), data)
+#define secure_apb_slot3_rd_reg(addr)        \
+	aml_read_reg32(SECBUS3_REG_ADDR(addr))
+
+#define cbus_wr_reg(addr, data)  \
+	aml_write_reg32(CBUS_REG_ADDR(addr), data)
+#define cbus_rd_reg(addr)        \
+	aml_read_reg32(CBUS_REG_ADDR(addr))
+
+#define NDMA_TABLE_SIZE     (32)
 /* driver logic flags */
 #define TDES_KEY_LENGTH 32
 #define TDES_MIN_BLOCK_SIZE 8
@@ -27,7 +40,9 @@
 #define INLINE_TYPE_AES              4
 
 #define NDMA_CNTL_REG0                             0x2270
+    #define NDMA_AES_STATUS             12
     #define NDMA_ENABLE                 14
+    #define NDMA_STATUS                 26
 #define NDMA_TABLE_ADD_REG                         0x2272
 #define NDMA_TDES_KEY_LO                           0x2273
 #define NDMA_TDES_KEY_HI                           0x2274
@@ -63,26 +78,29 @@
 #define NDMA_AES_IV_3                              0x229b
 #define NDMA_AES_REG0                             0x229c
 
-struct aml_crypto_ctx {
-    unsigned long key[8];
-    unsigned long iv[4];
-    int key_len;
-    void *src;
-    void *dst;
-    unsigned long mode;
-    unsigned long dir;
-    int len;
-    int threadidx;
-
-    unsigned int dma_src;
-    unsigned int dma_dest;
-};
+#define TDES_THREAD_INDEX 2
+#define AES_THREAD_INDEX 3
+#define SEC_ALLOWED_MASK 0xc /* thread 0 and 1 are secure*/
 
+unsigned long swap_ulong32(unsigned long val);
+void ndma_set_table_position(unsigned long thread_num,
+		unsigned long table_start, unsigned long size);
+void ndma_set_table_position_secure(unsigned long thread_num,
+		unsigned long table_start, unsigned long size);
+void ndma_add_descriptor_1d(
+		unsigned long   table,
+		unsigned long   irq,
+		unsigned long   restart,
+		unsigned long   pre_endian,
+		unsigned long   post_endian,
+		unsigned long   type,
+		unsigned long   bytes_to_move,
+		unsigned long   inlinetype,
+		unsigned long   src_addr,
+		unsigned long   dest_addr);
 
-#define AES_MAXNR 14
-struct aes_key_st {
-    unsigned int rd_key[4 *(AES_MAXNR + 1)];
-    int rounds;
-};
-typedef struct aes_key_st AES_KEY;
+void ndma_set_table_count(unsigned long thread_num, unsigned int cnt);
+void ndma_start(unsigned long thread_num);
+void ndma_stop(unsigned long thread_num);
+void ndma_wait_for_completion(unsigned long thread_num);
 #endif
diff --git a/drivers/amlogic/crypto/aml-tdes.c b/drivers/amlogic/crypto/aml-tdes.c
new file mode 100644
index 000000000000..29fc1b5b407a
--- /dev/null
+++ b/drivers/amlogic/crypto/aml-tdes.c
@@ -0,0 +1,916 @@
+/*
+ * Cryptographic API.
+ *
+ * Support for Amlogic TDES HW acceleration.
+ *
+ * Copyright (c) 2014 Amlogic Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Some ideas are borrowed from atmel-tdes.c driver.
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/hw_random.h>
+#include <linux/platform_device.h>
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/algapi.h>
+#include <crypto/des.h>
+#include <crypto/hash.h>
+#include <crypto/internal/hash.h>
+#include <mach/mod_gate.h>
+#include "aml-crypto.h"
+
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6)
+/* TDES flags */
+#define TDES_FLAGS_MODE_MASK	0x03
+#define TDES_FLAGS_ENCRYPT	BIT(0)
+#define TDES_FLAGS_CBC		BIT(1)
+
+#define TDES_FLAGS_INIT		BIT(8)
+#define TDES_FLAGS_DMA		BIT(9)
+#define TDES_FLAGS_BUSY		BIT(10)
+
+#define AML_TDES_QUEUE_LENGTH	50
+#define TDES_KEY_STARTING_IDX 0
+
+unsigned char    ndma_tdes_table_block[NDMA_TABLE_SIZE + 32];
+#define NDMA_TDES_TABLE_START (((unsigned long)ndma_tdes_table_block + 0x1f)\
+		& (~0x1f))
+unsigned long    ndma_tdes_table_ptr;
+
+struct aml_tdes_dev;
+
+struct aml_tdes_ctx {
+	struct aml_tdes_dev *dd;
+
+	int		keylen;
+	u32		key[3*DES_KEY_SIZE / sizeof(u32)];
+
+	u16		block_size;
+};
+
+struct aml_tdes_reqctx {
+	unsigned long mode;
+};
+
+struct aml_tdes_dev {
+	struct list_head	list;
+
+	struct aml_tdes_ctx	*ctx;
+	struct device		*dev;
+	int	irq;
+
+	unsigned long		flags;
+	int	err;
+
+	spinlock_t		lock;
+	struct crypto_queue	queue;
+
+	struct tasklet_struct	done_task;
+	struct tasklet_struct	queue_task;
+
+	struct ablkcipher_request	*req;
+	size_t	total;
+
+	struct scatterlist	*in_sg;
+	size_t			in_offset;
+	struct scatterlist	*out_sg;
+	size_t			out_offset;
+
+	size_t	buflen;
+	size_t	dma_size;
+
+	void	*buf_in;
+	dma_addr_t	dma_addr_in;
+
+	void	*buf_out;
+	dma_addr_t	dma_addr_out;
+	dma_addr_t	dma_descript_tab;
+};
+
+struct aml_tdes_drv {
+	struct list_head	dev_list;
+	spinlock_t		lock;
+};
+
+static struct aml_tdes_drv aml_tdes = {
+	.dev_list = LIST_HEAD_INIT(aml_tdes.dev_list),
+	.lock = __SPIN_LOCK_UNLOCKED(aml_tdes.lock),
+};
+
+static void write_key_iv(unsigned long addr, unsigned long data_hi,
+		unsigned long data_lo)
+{
+	unsigned long temp;
+
+	temp = swap_ulong32(data_lo);
+	cbus_wr_reg(NDMA_TDES_KEY_LO, temp);
+	temp = swap_ulong32(data_hi);
+	cbus_wr_reg(NDMA_TDES_KEY_HI, temp);
+
+	/* write the key */
+	cbus_wr_reg(NDMA_TDES_CONTROL, ((1 << 31) | (addr << 0)));
+}
+
+static void write_modes(unsigned long cbc_en,
+		unsigned long decrypt, unsigned long des_modes)
+{
+	/* Write the key */
+	cbus_wr_reg(NDMA_TDES_CONTROL, ((1 << 30)
+				| (des_modes << 6)
+				| (cbc_en << 5)
+				| (decrypt << 4)));
+}
+
+
+static void set_tdes_key(u32 *key, u32 keylen, u32 idx, u32 dir)
+{
+	idx = (idx * 4);
+
+	if (dir) {
+		if (keylen == DES_KEY_SIZE * 2) {
+			write_key_iv(idx + 0, *(key), *(key + 1));
+			write_key_iv(idx + 1, *(key + 1 * 2),
+					*(key + 1 * 2 + 1));
+			write_key_iv(idx + 2, *(key), *(key + 1));
+		} else {
+			write_key_iv(idx + 0, *(key + 2 * 2),
+					*(key + 2 * 2 + 1));
+			write_key_iv(idx + 1, *(key + 1 * 2),
+					*(key + 1 * 2 + 1));
+			write_key_iv(idx + 2, *(key), *(key + 1));
+		}
+	} else {
+		if (keylen == DES_KEY_SIZE * 2) {
+			write_key_iv(idx + 0, *(key), *(key + 1));
+			write_key_iv(idx + 1, *(key + 1 * 2),
+					*(key + 1 * 2 + 1));
+			write_key_iv(idx + 2, *(key), *(key + 1));
+		} else {
+			write_key_iv(idx + 0, *(key), *(key+1));
+			write_key_iv(idx + 1, *(key + 1 * 2),
+					*(key + 1 * 2 + 1));
+			write_key_iv(idx + 2, *(key + 2 * 2),
+					*(key + 2 * 2 + 1));
+		}
+	}
+}
+
+static void set_tdes_iv(u32 *iv, u32 idx)
+{
+	idx = (idx * 4);
+	if (!iv)
+		write_key_iv(idx + 3, 0xffffffff, 0x00000000);
+	else
+		write_key_iv(idx + 3, *(iv), *(iv + 1));
+}
+
+static int aml_tdes_sg_copy(struct scatterlist **sg, size_t *offset,
+		void *buf, size_t buflen, size_t total, int out)
+{
+	unsigned int count, off = 0;
+
+	while (buflen && total) {
+		count = min((*sg)->length - *offset, total);
+		count = min(count, buflen);
+
+		if (!count)
+			return off;
+
+		scatterwalk_map_and_copy(buf + off, *sg, *offset, count, out);
+
+		off += count;
+		buflen -= count;
+		*offset += count;
+		total -= count;
+
+		if (*offset == (*sg)->length) {
+			*sg = sg_next(*sg);
+			if (*sg)
+				*offset = 0;
+			else
+				total = 0;
+		}
+	}
+
+	return off;
+}
+
+static struct aml_tdes_dev *aml_tdes_find_dev(struct aml_tdes_ctx *ctx)
+{
+	struct aml_tdes_dev *tdes_dd = NULL;
+	struct aml_tdes_dev *tmp;
+
+	spin_lock_bh(&aml_tdes.lock);
+	if (!ctx->dd) {
+		list_for_each_entry(tmp, &aml_tdes.dev_list, list) {
+			tdes_dd = tmp;
+			break;
+		}
+		ctx->dd = tdes_dd;
+	} else {
+		tdes_dd = ctx->dd;
+	}
+
+	spin_unlock_bh(&aml_tdes.lock);
+
+	return tdes_dd;
+}
+
+static int aml_tdes_hw_init(struct aml_tdes_dev *dd)
+{
+	cbus_wr_reg(AM_RING_OSC_REG0, 0x1);
+	cbus_wr_reg(NDMA_CNTL_REG1, cbus_rd_reg(NDMA_CNTL_REG1) & 0xfffffffe);
+	/* enable module clk */
+	switch_mod_gate_by_type(MOD_BLK_MOV, 1);
+
+	if (!(dd->flags & TDES_FLAGS_INIT)) {
+		dd->flags |= TDES_FLAGS_INIT;
+		dd->err = 0;
+	}
+
+	return 0;
+}
+
+static void aml_tdes_finish_req(struct aml_tdes_dev *dd, int err)
+{
+	struct ablkcipher_request *req = dd->req;
+	dd->flags &= ~TDES_FLAGS_BUSY;
+	req->base.complete(&req->base, err);
+}
+
+
+static int aml_tdes_crypt_dma(struct aml_tdes_dev *dd,
+		dma_addr_t dma_addr_in, dma_addr_t dma_addr_out,
+		int length, unsigned long restart)
+{
+	unsigned long mode;
+#if AML_CRYPTO_DEBUG
+	int i = 0;
+#endif
+	dd->dma_size = length;
+
+	dma_sync_single_for_device(dd->dev, dma_addr_in, length,
+			DMA_TO_DEVICE);
+
+	dd->flags |= TDES_FLAGS_DMA;
+
+	mode = MODE_ECB;
+
+	if (dd->flags & TDES_FLAGS_CBC)
+		mode = MODE_CBC;
+
+	ndma_add_descriptor_1d(
+			ndma_tdes_table_ptr,  /* table location */
+			1,                    /* irq */
+			restart,              /* restart */
+			7,                    /* pre_endian */
+			7,                    /* post_endian */
+			TDES_KEY_STARTING_IDX,/* keytype + cryptodir */
+			dd->dma_size,         /* bytes_to_move */
+			INLINE_TYPE_TDES,     /* inlinetype */
+			dma_addr_in,          /* src_addr */
+			dma_addr_out);        /* dest_addr */
+
+	dma_sync_single_for_device(dd->dev, dd->dma_descript_tab,
+			NDMA_TABLE_SIZE, DMA_TO_DEVICE);
+	ndma_set_table_position(TDES_THREAD_INDEX,
+			dd->dma_descript_tab, NDMA_TABLE_SIZE);
+	ndma_set_table_count(TDES_THREAD_INDEX, 1);
+
+#if AML_CRYPTO_DEBUG
+	for (i = 0x2270; i < 0x229d; i++)
+		pr_err("reg(%4x) = 0x%8lx\n", i, cbus_rd_reg(i));
+
+	for (i = 0; i < 8; i++) {
+		pr_err("table addr(%d) = 0x%8lx\n", i,
+			*(unsigned long *)(ndma_tdes_table_ptr + i * 4));
+	}
+#endif
+
+	ndma_start(TDES_THREAD_INDEX);
+
+	return 0;
+}
+
+static int aml_tdes_crypt_dma_start(struct aml_tdes_dev *dd,
+		unsigned long restart)
+{
+	int err = 0;
+	size_t count;
+	dma_addr_t addr_in, addr_out;
+
+	/* use cache buffers */
+	count = aml_tdes_sg_copy(&dd->in_sg, &dd->in_offset,
+			dd->buf_in, dd->buflen, dd->total, 0);
+	addr_in = dd->dma_addr_in;
+	addr_out = dd->dma_addr_out;
+	dd->total -= count;
+
+	err = aml_tdes_crypt_dma(dd, addr_in, addr_out, count, restart);
+
+	return err;
+}
+
+static int aml_tdes_write_ctrl(struct aml_tdes_dev *dd)
+{
+	int err = 0;
+	unsigned int tdes_mode = 0;
+	unsigned int crypt = 0;
+	err = aml_tdes_hw_init(dd);
+
+	if (err)
+		return err;
+
+	if (dd->flags & TDES_FLAGS_CBC)
+		tdes_mode = 1;
+	else
+		tdes_mode = 0;
+
+	if (dd->flags & TDES_FLAGS_ENCRYPT)
+		crypt = 0;
+	else
+		crypt = 1;
+
+	write_modes(tdes_mode,          /* cbc_en */
+			crypt,          /* decrypt */
+			(crypt == 1) ? 5 : 2); /* des_modes */
+
+	set_tdes_key(dd->ctx->key, dd->ctx->keylen,
+			TDES_KEY_STARTING_IDX, crypt);
+	if (dd->flags & TDES_FLAGS_CBC)
+		set_tdes_iv(dd->req->info, TDES_KEY_STARTING_IDX);
+	else
+		set_tdes_iv(NULL, TDES_KEY_STARTING_IDX);
+
+	return err;
+}
+
+static int aml_tdes_handle_queue(struct aml_tdes_dev *dd,
+		struct ablkcipher_request *req)
+{
+	struct crypto_async_request *async_req, *backlog;
+	struct aml_tdes_ctx *ctx;
+	struct aml_tdes_reqctx *rctx;
+	unsigned long flags;
+	int err, ret = 0;
+
+	spin_lock_irqsave(&dd->lock, flags);
+	if (req)
+		ret = ablkcipher_enqueue_request(&dd->queue, req);
+
+	if (dd->flags & TDES_FLAGS_BUSY) {
+		spin_unlock_irqrestore(&dd->lock, flags);
+		return ret;
+	}
+	backlog = crypto_get_backlog(&dd->queue);
+	async_req = crypto_dequeue_request(&dd->queue);
+	if (async_req)
+		dd->flags |= TDES_FLAGS_BUSY;
+	spin_unlock_irqrestore(&dd->lock, flags);
+
+	if (!async_req)
+		return ret;
+
+	if (backlog)
+		backlog->complete(backlog, -EINPROGRESS);
+
+	req = ablkcipher_request_cast(async_req);
+
+	/* assign new request to device */
+	dd->req = req;
+	dd->total = req->nbytes;
+	dd->in_offset = 0;
+	dd->in_sg = req->src;
+	dd->out_offset = 0;
+	dd->out_sg = req->dst;
+
+	rctx = ablkcipher_request_ctx(req);
+	ctx = crypto_ablkcipher_ctx(crypto_ablkcipher_reqtfm(req));
+	rctx->mode &= TDES_FLAGS_MODE_MASK;
+	dd->flags = (dd->flags & ~TDES_FLAGS_MODE_MASK) | rctx->mode;
+	dd->ctx = ctx;
+	ctx->dd = dd;
+
+	err = aml_tdes_write_ctrl(dd);
+	if (!err)
+		err = aml_tdes_crypt_dma_start(dd, 1);
+
+	if (err) {
+		/* tdes_task will not finish it, so do it here */
+		aml_tdes_finish_req(dd, err);
+		tasklet_schedule(&dd->queue_task);
+	}
+
+	return ret;
+}
+
+static int aml_tdes_crypt_dma_stop(struct aml_tdes_dev *dd)
+{
+	int err = -EINVAL;
+	size_t count;
+
+	if (dd->flags & TDES_FLAGS_DMA) {
+		err = 0;
+		dma_sync_single_for_cpu(dd->dev, dd->dma_descript_tab,
+				NDMA_TABLE_SIZE, DMA_TO_DEVICE);
+		dma_sync_single_for_device(dd->dev, dd->dma_addr_out,
+				dd->dma_size, DMA_FROM_DEVICE);
+
+		/* copy data */
+		count = aml_tdes_sg_copy(&dd->out_sg, &dd->out_offset,
+				dd->buf_out, dd->buflen, dd->dma_size, 1);
+		if (count != dd->dma_size) {
+			err = -EINVAL;
+			pr_err("not all data converted: %u\n", count);
+		}
+		dd->flags &= ~TDES_FLAGS_DMA;
+	}
+
+	return err;
+}
+
+
+static int aml_tdes_buff_init(struct aml_tdes_dev *dd)
+{
+	int err = -ENOMEM;
+
+	dd->buf_in = (void *)__get_free_pages(GFP_KERNEL, 0);
+	dd->buf_out = (void *)__get_free_pages(GFP_KERNEL, 0);
+	dd->buflen = PAGE_SIZE;
+	dd->buflen &= ~(DES_BLOCK_SIZE - 1);
+
+	if (!dd->buf_in || !dd->buf_out) {
+		dev_err(dd->dev, "unable to alloc pages.\n");
+		goto err_alloc;
+	}
+
+	/* MAP here */
+	dd->dma_addr_in = dma_map_single(dd->dev, dd->buf_in,
+			dd->buflen, DMA_TO_DEVICE);
+	if (dma_mapping_error(dd->dev, dd->dma_addr_in)) {
+		dev_err(dd->dev, "dma %d bytes error\n", dd->buflen);
+		err = -EINVAL;
+		goto err_map_in;
+	}
+
+	dd->dma_addr_out = dma_map_single(dd->dev, dd->buf_out,
+			dd->buflen, DMA_FROM_DEVICE);
+	if (dma_mapping_error(dd->dev, dd->dma_addr_out)) {
+		dev_err(dd->dev, "dma %d bytes error\n", dd->buflen);
+		err = -EINVAL;
+		goto err_map_out;
+	}
+
+	dd->dma_descript_tab = dma_map_single(dd->dev,
+			(void *)ndma_tdes_table_ptr,
+			NDMA_TABLE_SIZE, DMA_TO_DEVICE);
+
+	if (dma_mapping_error(dd->dev, dd->dma_descript_tab)) {
+		dev_err(dd->dev, "dma descriptor error\n");
+		err = -EINVAL;
+		goto err_map_descriptor;
+	}
+
+	return 0;
+
+err_map_descriptor:
+	dma_unmap_single(dd->dev, dd->dma_descript_tab, NDMA_TABLE_SIZE,
+			DMA_TO_DEVICE);
+
+err_map_out:
+	dma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,
+			DMA_TO_DEVICE);
+err_map_in:
+	free_page((unsigned long)dd->buf_out);
+	free_page((unsigned long)dd->buf_in);
+err_alloc:
+	if (err)
+		pr_err("error: %d\n", err);
+	return err;
+}
+
+static void aml_tdes_buff_cleanup(struct aml_tdes_dev *dd)
+{
+	dma_unmap_single(dd->dev, dd->dma_addr_out, dd->buflen,
+			DMA_FROM_DEVICE);
+	dma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,
+			DMA_TO_DEVICE);
+	free_page((unsigned long)dd->buf_out);
+	free_page((unsigned long)dd->buf_in);
+}
+
+static int aml_tdes_crypt(struct ablkcipher_request *req, unsigned long mode)
+{
+	struct aml_tdes_ctx *ctx = crypto_ablkcipher_ctx(
+			crypto_ablkcipher_reqtfm(req));
+	struct aml_tdes_reqctx *rctx = ablkcipher_request_ctx(req);
+	struct aml_tdes_dev *dd;
+
+	if (!IS_ALIGNED(req->nbytes, DES_BLOCK_SIZE)) {
+		pr_err("request size is not exact amount of TDES blocks\n");
+		return -EINVAL;
+	}
+	ctx->block_size = DES_BLOCK_SIZE;
+
+	dd = aml_tdes_find_dev(ctx);
+	if (!dd)
+		return -ENODEV;
+
+	rctx->mode = mode;
+
+	return aml_tdes_handle_queue(dd, req);
+}
+
+static int aml_des_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
+		unsigned int keylen)
+{
+	u32 tmp[DES_EXPKEY_WORDS];
+	int err;
+	struct crypto_tfm *ctfm = crypto_ablkcipher_tfm(tfm);
+	struct aml_tdes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
+
+	if (keylen != DES_KEY_SIZE) {
+		crypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		return -EINVAL;
+	}
+
+	err = des_ekey(tmp, key);
+	if (err == 0 && (ctfm->crt_flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
+		ctfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;
+		return -EINVAL;
+	}
+
+	memcpy(ctx->key, key, keylen);
+	ctx->keylen = keylen;
+
+	return 0;
+}
+
+static int aml_tdes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
+		unsigned int keylen)
+{
+	struct aml_tdes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
+
+	if ((keylen != 2*DES_KEY_SIZE) && (keylen != 3*DES_KEY_SIZE)) {
+		crypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		return -EINVAL;
+	}
+
+	memcpy(ctx->key, key, keylen);
+	ctx->keylen = keylen;
+
+	return 0;
+}
+
+static int aml_tdes_ecb_encrypt(struct ablkcipher_request *req)
+{
+	return aml_tdes_crypt(req,
+			TDES_FLAGS_ENCRYPT);
+}
+
+static int aml_tdes_ecb_decrypt(struct ablkcipher_request *req)
+{
+	return aml_tdes_crypt(req,
+			0);
+}
+
+static int aml_tdes_cbc_encrypt(struct ablkcipher_request *req)
+{
+	return aml_tdes_crypt(req,
+			TDES_FLAGS_ENCRYPT | TDES_FLAGS_CBC);
+}
+
+static int aml_tdes_cbc_decrypt(struct ablkcipher_request *req)
+{
+	return aml_tdes_crypt(req,
+			TDES_FLAGS_CBC);
+}
+
+static int aml_tdes_cra_init(struct crypto_tfm *tfm)
+{
+	tfm->crt_ablkcipher.reqsize = sizeof(struct aml_tdes_reqctx);
+
+	return 0;
+}
+
+static void aml_tdes_cra_exit(struct crypto_tfm *tfm)
+{
+}
+
+static struct crypto_alg tdes_algs[] = {
+	{
+		.cra_name        = "ecb(des)",
+		.cra_driver_name = "ecb-des-aml",
+		.cra_priority  =  300,
+		.cra_flags     =  CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize =  DES_BLOCK_SIZE,
+		.cra_ctxsize   =  sizeof(struct aml_tdes_ctx),
+		.cra_alignmask =  0,
+		.cra_type      =  &crypto_ablkcipher_type,
+		.cra_module    =  THIS_MODULE,
+		.cra_init      =  aml_tdes_cra_init,
+		.cra_exit      =  aml_tdes_cra_exit,
+		.cra_u.ablkcipher = {
+			.min_keysize	=    DES_KEY_SIZE,
+			.max_keysize	=    DES_KEY_SIZE,
+			.setkey		=    aml_des_setkey,
+			.encrypt	=    aml_tdes_ecb_encrypt,
+			.decrypt	=    aml_tdes_ecb_decrypt,
+		}
+	},
+	{
+		.cra_name        =  "cbc(des)",
+		.cra_driver_name =  "cbc-des-aml",
+		.cra_priority  =  300,
+		.cra_flags     =  CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize =  DES_BLOCK_SIZE,
+		.cra_ctxsize   =  sizeof(struct aml_tdes_ctx),
+		.cra_alignmask =  0,
+		.cra_type      =  &crypto_ablkcipher_type,
+		.cra_module    =  THIS_MODULE,
+		.cra_init      =  aml_tdes_cra_init,
+		.cra_exit      =  aml_tdes_cra_exit,
+		.cra_u.ablkcipher = {
+			.min_keysize	=    DES_KEY_SIZE,
+			.max_keysize	=    DES_KEY_SIZE,
+			.ivsize		=    DES_BLOCK_SIZE,
+			.setkey		=    aml_des_setkey,
+			.encrypt	=    aml_tdes_cbc_encrypt,
+			.decrypt	=    aml_tdes_cbc_decrypt,
+		}
+	},
+	{
+		.cra_name        = "ecb(des3_ede)",
+		.cra_driver_name = "ecb-tdes-aml",
+		.cra_priority   = 300,
+		.cra_flags      = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize  = DES_BLOCK_SIZE,
+		.cra_ctxsize    = sizeof(struct aml_tdes_ctx),
+		.cra_alignmask  = 0,
+		.cra_type       = &crypto_ablkcipher_type,
+		.cra_module     = THIS_MODULE,
+		.cra_init       = aml_tdes_cra_init,
+		.cra_exit       = aml_tdes_cra_exit,
+		.cra_u.ablkcipher = {
+			.min_keysize	=    2 * DES_KEY_SIZE,
+			.max_keysize	=    3 * DES_KEY_SIZE,
+			.setkey		=    aml_tdes_setkey,
+			.encrypt	=    aml_tdes_ecb_encrypt,
+			.decrypt	=    aml_tdes_ecb_decrypt,
+		}
+	},
+	{
+		.cra_name        = "cbc(des3_ede)",
+		.cra_driver_name = "cbc-tdes-aml",
+		.cra_priority  = 300,
+		.cra_flags     = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize = DES_BLOCK_SIZE,
+		.cra_ctxsize   = sizeof(struct aml_tdes_ctx),
+		.cra_alignmask = 0,
+		.cra_type      = &crypto_ablkcipher_type,
+		.cra_module    = THIS_MODULE,
+		.cra_init      = aml_tdes_cra_init,
+		.cra_exit      = aml_tdes_cra_exit,
+		.cra_u.ablkcipher =       {
+			.min_keysize = 2 * DES_KEY_SIZE,
+			.max_keysize = 3 * DES_KEY_SIZE,
+			.ivsize	     = DES_BLOCK_SIZE,
+			.setkey	     = aml_tdes_setkey,
+			.encrypt     = aml_tdes_cbc_encrypt,
+			.decrypt     = aml_tdes_cbc_decrypt,
+		}
+	}
+};
+
+static void aml_tdes_queue_task(unsigned long data)
+{
+	struct aml_tdes_dev *dd = (struct aml_tdes_dev *)data;
+	aml_tdes_handle_queue(dd, NULL);
+}
+
+static void aml_tdes_done_task(unsigned long data)
+{
+	struct aml_tdes_dev *dd = (struct aml_tdes_dev *) data;
+	int err;
+#if AML_CRYPTO_DEBUG
+	int i = 0;
+#endif
+
+	err = aml_tdes_crypt_dma_stop(dd);
+
+#if AML_CRYPTO_DEBUG
+	for (i = 0x2270; i < 0x228D; i++)
+		pr_err("reg(%4x) = 0x%8lx\n", i, cbus_rd_reg(i));
+
+	for (i = 0; i < 8; i++) {
+		pr_err("table addr(%d) = 0x%8lx\n", i,
+			*(unsigned long *)(ndma_tdes_table_ptr + i * 4));
+	}
+#endif
+	err = dd->err ? : err;
+
+	if (dd->total && !err) {
+		if (!err)
+			err = aml_tdes_crypt_dma_start(dd, 0);
+		if (!err)
+			return; /* DMA started. Not fininishing. */
+	}
+
+	aml_tdes_finish_req(dd, err);
+	aml_tdes_handle_queue(dd, NULL);
+}
+
+static irqreturn_t aml_tdes_irq(int irq, void *dev_id)
+{
+	struct aml_tdes_dev *tdes_dd = dev_id;
+
+	if (!(cbus_rd_reg(NDMA_TABLE_ADD_REG)
+				& (0xF << (TDES_THREAD_INDEX * 8)))) {
+		if (TDES_FLAGS_BUSY & tdes_dd->flags) {
+			tasklet_schedule(&tdes_dd->done_task);
+			return IRQ_HANDLED;
+		} else {
+			return IRQ_NONE;
+		}
+	} else {
+		pr_err("tdes not completed yet?\n");
+	}
+
+
+	return IRQ_NONE;
+}
+
+static void aml_tdes_unregister_algs(struct aml_tdes_dev *dd)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(tdes_algs); i++)
+		crypto_unregister_alg(&tdes_algs[i]);
+}
+
+static int aml_tdes_register_algs(struct aml_tdes_dev *dd)
+{
+	int err, i, j;
+
+	for (i = 0; i < ARRAY_SIZE(tdes_algs); i++) {
+		err = crypto_register_alg(&tdes_algs[i]);
+		if (err)
+			goto err_tdes_algs;
+	}
+
+	return 0;
+
+err_tdes_algs:
+	for (j = 0; j < i; j++)
+		crypto_unregister_alg(&tdes_algs[j]);
+
+	return err;
+}
+
+static int aml_tdes_probe(struct platform_device *pdev)
+{
+	struct aml_tdes_dev *tdes_dd;
+	struct device *dev = &pdev->dev;
+	int err;
+
+	ndma_tdes_table_ptr = NDMA_TDES_TABLE_START;
+
+	tdes_dd = kzalloc(sizeof(struct aml_tdes_dev), GFP_KERNEL);
+	if (tdes_dd == NULL) {
+		dev_err(dev, "unable to alloc data struct.\n");
+		err = -ENOMEM;
+		goto tdes_dd_err;
+	}
+
+	tdes_dd->dev = dev;
+
+	platform_set_drvdata(pdev, tdes_dd);
+
+	INIT_LIST_HEAD(&tdes_dd->list);
+
+	tasklet_init(&tdes_dd->done_task, aml_tdes_done_task,
+			(unsigned long)tdes_dd);
+	tasklet_init(&tdes_dd->queue_task, aml_tdes_queue_task,
+			(unsigned long)tdes_dd);
+
+	crypto_init_queue(&tdes_dd->queue, AML_TDES_QUEUE_LENGTH);
+
+	tdes_dd->irq = INT_NDMA;
+
+	err = request_irq(tdes_dd->irq, aml_tdes_irq, IRQF_SHARED, "aml-tdes",
+			tdes_dd);
+	if (err) {
+		dev_err(dev, "unable to request tdes irq.\n");
+		goto tdes_irq_err;
+	}
+
+	err = aml_tdes_hw_init(tdes_dd);
+	if (err)
+		goto err_tdes_buff;
+
+	err = aml_tdes_buff_init(tdes_dd);
+	if (err)
+		goto err_tdes_buff;
+
+	spin_lock(&aml_tdes.lock);
+	list_add_tail(&tdes_dd->list, &aml_tdes.dev_list);
+	spin_unlock(&aml_tdes.lock);
+
+	err = aml_tdes_register_algs(tdes_dd);
+	if (err)
+		goto err_algs;
+
+	dev_info(dev, "Aml TDES\n");
+
+	return 0;
+
+err_algs:
+	spin_lock(&aml_tdes.lock);
+	list_del(&tdes_dd->list);
+	spin_unlock(&aml_tdes.lock);
+	aml_tdes_buff_cleanup(tdes_dd);
+err_tdes_buff:
+	free_irq(tdes_dd->irq, tdes_dd);
+tdes_irq_err:
+	tasklet_kill(&tdes_dd->done_task);
+	tasklet_kill(&tdes_dd->queue_task);
+	kfree(tdes_dd);
+	tdes_dd = NULL;
+tdes_dd_err:
+	dev_err(dev, "initialization failed.\n");
+
+	return err;
+}
+
+static int aml_tdes_remove(struct platform_device *pdev)
+{
+	static struct aml_tdes_dev *tdes_dd;
+
+	tdes_dd = platform_get_drvdata(pdev);
+	if (!tdes_dd)
+		return -ENODEV;
+	spin_lock(&aml_tdes.lock);
+	list_del(&tdes_dd->list);
+	spin_unlock(&aml_tdes.lock);
+
+	aml_tdes_unregister_algs(tdes_dd);
+
+	tasklet_kill(&tdes_dd->done_task);
+	tasklet_kill(&tdes_dd->queue_task);
+
+	if (tdes_dd->irq > 0)
+		free_irq(tdes_dd->irq, tdes_dd);
+
+	kfree(tdes_dd);
+	tdes_dd = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id aml_tdes_dt_match[] = {
+	{	.compatible = "amlogic,des,tdes",
+	},
+	{},
+};
+#else
+#define aml_tdes_dt_match NULL
+#endif
+
+static struct platform_driver aml_tdes_driver = {
+	.probe		= aml_tdes_probe,
+	.remove		= aml_tdes_remove,
+	.driver		= {
+		.name	= "aml_tdes",
+		.owner	= THIS_MODULE,
+		.of_match_table = aml_tdes_dt_match,
+	},
+};
+
+module_platform_driver(aml_tdes_driver);
+
+MODULE_DESCRIPTION("Aml TDES hw acceleration support.");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("matthew.shyu <matthew.shyu@amlogic.com>");
+#endif
diff --git a/drivers/amlogic/crypto/crypto_dev.c b/drivers/amlogic/crypto/crypto_dev.c
deleted file mode 100755
index aab718825469..000000000000
--- a/drivers/amlogic/crypto/crypto_dev.c
+++ /dev/null
@@ -1,511 +0,0 @@
-/*
- *  /drivers/amlogic/crypto/crypto_dev.c
- *
- *  Driver for amlogic crypto api for user...
- *
- *
- *  Copyright (C) 2013 Amlogic. By Qi.Duan
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/ioport.h>
-#include <linux/init.h>
-#include <linux/ctype.h>
-#include <linux/console.h>
-#include <linux/sysrq.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/mm.h>
-#include <linux/nmi.h>
-#include <linux/mutex.h>
-#include <linux/slab.h>
-#include <asm/io.h>
-#include <crypto/hash.h>
-#include <linux/err.h>
-#include <linux/gfp.h>
-#include <linux/scatterlist.h>
-#include <linux/string.h>
-#include <crypto/algapi.h>
-#include <linux/of.h>
-
-#define CRYPTO_STATUS_NONE      0
-#define CRYPTO_STATUS_START     1
-#define CRYPTO_STATUS_FINISH    2
-#define CRYPTO_STATUS_ERROR     3
-
-static DECLARE_WAIT_QUEUE_HEAD(crypto_wq);
-typedef struct crypto_device_struct{
-    char algname[32];
-
-    unsigned int    keyaddr;
-    unsigned int    keysize;
-
-    unsigned int    srcaddr;
-    unsigned int    dstaddr;
-    unsigned int    size;
-
-    char    dir;
-
-    char    status;
-}crypto_device_t;
-
-static struct crypto_device_struct crypt_info;
-
-int crypto_done(crypto_device_t * pcrypt_info)
-{
-    struct crypto_blkcipher *tfm;
-    struct blkcipher_desc desc;
-    struct scatterlist sg[1];
-    int keysize = pcrypt_info->keysize;
-    char *key;
-    char *src;
-    int ret=CRYPTO_STATUS_ERROR;
-    unsigned int min_block_size,pad_byte;
-    
-    tfm = crypto_alloc_blkcipher(pcrypt_info->algname, 0, CRYPTO_ALG_ASYNC);
-    if (IS_ERR(tfm)) {
-	printk("failed to load transform for %s: %ld\n",pcrypt_info->algname,PTR_ERR(tfm));       
-	return ret;
-    }
-
-    desc.tfm = tfm;
-    desc.flags = 0;
-
-    min_block_size = crypto_blkcipher_blocksize(tfm);
-    if(min_block_size!=0)
-    {
-        pad_byte = pcrypt_info->size%min_block_size;
-    }
-    else
-        pad_byte = 0;
-
-    if((strcmp(pcrypt_info->algname,"cbc-aes-aml")==0)||(strcmp(pcrypt_info->algname,"ctr-aes-aml")==0))
-    {
-        keysize +=16; 
-    }
-    key = (char *)kmalloc(keysize,GFP_KERNEL);
-    if(key==NULL)
-    {
-        return ret;
-    }
-    if(copy_from_user((void *)key,(void*)pcrypt_info->keyaddr,keysize))
-	{
-		kfree(key);
-		return ret;
-	}
-    
-    src = (char *)kmalloc(pcrypt_info->size,GFP_KERNEL);
-    if(src==NULL)
-    {
-        kfree(key);
-        return ret;
-    }
-    if(copy_from_user((void *)src,(void*)pcrypt_info->srcaddr,pcrypt_info->size))
-	{	
-		kfree(src);
-		kfree(key);
-		return ret;
-	}
- 
-    sg_init_table(sg, 1);
-    sg_set_buf(&sg[0], src, pcrypt_info->size-pad_byte);
-            
-    ret = crypto_blkcipher_setkey(tfm, (unsigned char *)key, keysize);
-    if (ret) {
-	printk("setkey() failed flags=%x\n",
-			crypto_blkcipher_get_flags(tfm));
-	goto out;
-    }
-
-    if(pcrypt_info->dir == 0)
-        ret = crypto_blkcipher_encrypt(&desc, sg, sg, pcrypt_info->size-pad_byte);
-    else
-        ret = crypto_blkcipher_decrypt(&desc, sg, sg, pcrypt_info->size-pad_byte);
-    if (ret)
-    {
-        printk("crypt() failed %x\n",ret);
-        ret =  CRYPTO_STATUS_ERROR;
-        goto out;
-     }
-
-    if(copy_to_user((void *)pcrypt_info->dstaddr,src,pcrypt_info->size))
-		goto out;
-
-    ret = CRYPTO_STATUS_FINISH;
-out:
-
-    kfree(src);
-    kfree(key);
-    
-    crypto_free_blkcipher(tfm);
-
-    return ret;
-}
-
-static ssize_t crypto_algname_show(struct device *_dev,
-                          struct device_attribute *attr,
-			     char *buf);
-static ssize_t crypto_algname_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count);
-static ssize_t crypto_keyaddr_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf);
-static ssize_t crypto_keyaddr_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count);
-static ssize_t crypto_keysize_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf);
-static ssize_t crypto_keysize_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count);
-static ssize_t crypto_srcaddr_show(struct device *_dev,
-                          struct device_attribute *attr,
-			     char *buf);
-static ssize_t crypto_srcaddr_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count);
-static ssize_t crypto_dstaddr_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf);
-static ssize_t crypto_dstaddr_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count);
-static ssize_t crypto_size_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf);
-static ssize_t crypto_size_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count);
-static ssize_t crypto_dir_show(struct device *_dev,
-                          struct device_attribute *attr,
-			     char *buf);
-static ssize_t crypto_dir_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count);
-static ssize_t crypto_status_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf);
-static ssize_t crypto_status_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count);
-
-
-DEVICE_ATTR(algname, S_IRUGO | S_IWUSR, crypto_algname_show, crypto_algname_store);
-DEVICE_ATTR(keyaddr, S_IRUGO | S_IWUSR, crypto_keyaddr_show, crypto_keyaddr_store);
-DEVICE_ATTR(keysize, S_IRUGO | S_IWUSR, crypto_keysize_show, crypto_keysize_store);
-DEVICE_ATTR(srcaddr, S_IRUGO | S_IWUSR, crypto_srcaddr_show, crypto_srcaddr_store);
-DEVICE_ATTR(dstaddr, S_IRUGO | S_IWUSR, crypto_dstaddr_show, crypto_dstaddr_store);
-DEVICE_ATTR(size, S_IRUGO | S_IWUSR, crypto_size_show, crypto_size_store);
-DEVICE_ATTR(dir, S_IRUGO | S_IWUSR, crypto_dir_show, crypto_dir_store);
-DEVICE_ATTR(status, S_IRUGO | S_IWUSR, crypto_status_show, crypto_status_store);
-
-
-static ssize_t crypto_algname_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-
-	
-	if (pcrypt_info->algname!= NULL) {
-		return snprintf(buf,strlen(pcrypt_info->algname) + 1,"%s", pcrypt_info->algname);
-	} else {
-		dev_err(_dev, "Invalid alg name\n");
-		return sprintf(buf, "invalid alg name\n");
-	}
-}
-
-
-static ssize_t crypto_algname_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-
-	strcpy(pcrypt_info->algname,buf);
-
-	return count;
-	
-}
-
-static ssize_t crypto_keyaddr_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-
-	return snprintf(buf, sizeof("00000000\n") + 1,"%x\n", pcrypt_info->keyaddr);
-}
-
-/**
- * Store the value in the register of PHY power
- * 
- * 
- */
-static ssize_t crypto_keyaddr_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-	pcrypt_info->keyaddr = simple_strtoul(buf,NULL,16);
-
-	return count;
-	
-}
-
-static ssize_t crypto_keysize_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-
-	return snprintf(buf, sizeof("32\n") + 1,"%d\n", pcrypt_info->keysize);
-}
-
-/**
- * Store the value in the register of PHY power
- * 
- * 
- */
-static ssize_t crypto_keysize_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-	pcrypt_info->keysize = simple_strtoul(buf,NULL,10);
-
-	return count;
-	
-}
-
-static ssize_t crypto_srcaddr_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-
-	return snprintf(buf, sizeof("00000000\n") + 1,"%x\n", pcrypt_info->srcaddr);
-}
-
-/**
- * Store the value in the register of PHY power
- * 
- * 
- */
-static ssize_t crypto_srcaddr_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-	pcrypt_info->srcaddr = simple_strtoul(buf,NULL,16);
-
-	return count;
-	
-}
-
-static ssize_t crypto_dstaddr_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-
-	return snprintf(buf, sizeof("00000000\n") + 1,"%x\n", pcrypt_info->dstaddr);
-}
-
-/**
- * Store the value in the register of PHY power
- * 
- * 
- */
-static ssize_t crypto_dstaddr_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-	pcrypt_info->dstaddr = simple_strtoul(buf,NULL,16);
-
-	return count;
-	
-}
-
-static ssize_t crypto_size_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-
-	return snprintf(buf, sizeof("00000000\n") + 1,"%x\n", pcrypt_info->size);
-}
-
-/**
- * Store the value in the register of PHY power
- * 
- * 
- */
-static ssize_t crypto_size_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-	pcrypt_info->size = simple_strtoul(buf,NULL,16);
-
-	return count;
-	
-}
-
-static ssize_t crypto_dir_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-
-	return snprintf(buf, sizeof("1\n") + 1,"%d\n", pcrypt_info->dir);
-}
-
-/**
- * Store the value in the register of PHY power
- * 
- * 
- */
-static ssize_t crypto_dir_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-	pcrypt_info->dir = simple_strtoul(buf,NULL,10);
-
-	return count;
-	
-}
-
-static ssize_t crypto_status_show(struct device *_dev,
-			     struct device_attribute *attr,
-			     char *buf)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-
-    if (pcrypt_info->status < CRYPTO_STATUS_FINISH)
-        wait_event_interruptible(crypto_wq, pcrypt_info->status >= CRYPTO_STATUS_FINISH );
-	return snprintf(buf, sizeof("1\n") + 1,"%d\n", pcrypt_info->status);
-}
-
-/**
- * Store the value in the register of PHY power
- * 
- * 
- */
-static ssize_t crypto_status_store(struct device *_dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	crypto_device_t * pcrypt_info = dev_get_drvdata(_dev);
-	pcrypt_info->status = simple_strtoul(buf,NULL,10);
-
-       if(pcrypt_info->status==CRYPTO_STATUS_START)
-       {
-            pcrypt_info->status = CRYPTO_STATUS_NONE;
-            pcrypt_info->status = crypto_done(pcrypt_info);
-            wake_up_interruptible(&crypto_wq);
-       }
-
-	return count;
-	
-}
-    
-/******************************************************/
-static void create_device_attribs(struct device *dev)
-{
-    device_create_file(dev, &dev_attr_algname);
-    device_create_file(dev, &dev_attr_keyaddr);
-    device_create_file(dev, &dev_attr_keysize);
-    device_create_file(dev, &dev_attr_srcaddr);
-    device_create_file(dev, &dev_attr_dstaddr);
-    device_create_file(dev, &dev_attr_size);
-    device_create_file(dev, &dev_attr_dir);
-    device_create_file(dev, &dev_attr_status);
-         
-}
-static void remove_device_attribs(struct device *dev)
-{
-    device_remove_file(dev, &dev_attr_algname);
-    device_remove_file(dev, &dev_attr_keyaddr);
-    device_remove_file(dev, &dev_attr_keysize);
-    device_remove_file(dev, &dev_attr_srcaddr);
-    device_remove_file(dev, &dev_attr_dstaddr);
-    device_remove_file(dev, &dev_attr_size);
-    device_remove_file(dev, &dev_attr_dir);
-    device_remove_file(dev, &dev_attr_status);
-    
-}
-
-/******************************************************/
-static int crypto_dev_probe(struct platform_device *pdev) 
-{
-	int ret = 0;
-
-	memset(&crypt_info,0,sizeof(struct crypto_device_struct));
-
-	dev_set_drvdata(&pdev->dev,&crypt_info);
-	create_device_attribs(&pdev->dev);
-	
-	return ret;
-}
-
-
-
-static int crypto_dev_remove(struct platform_device *pdev) 
-{
-	remove_device_attribs(&pdev->dev);
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id crypto_device_dt_match[]={
-	{	.compatible = "amlogic,crypto-device",
-	},
-	{},
-};
-#else
-#define amlogic_cpufreq_meson_dt_match NULL
-#endif
-
-static struct platform_driver crypto_dev_driver = { 
-	.probe = crypto_dev_probe, 
-	.remove = crypto_dev_remove, 
-//	.shutdown
-//	.resume
-//	.suspend
-	.driver = {
-			.name = "crypto_device",						
-			.owner = THIS_MODULE,
-			.of_match_table = crypto_device_dt_match,
-	}, 
-};
-
-static int __init crypto_dev_init(void) 
-{
-	init_waitqueue_head(&crypto_wq);
-	return platform_driver_register(&crypto_dev_driver);
-}
-
-static void __exit crypto_dev_exit(void) 
-{
-	platform_driver_unregister(&crypto_dev_driver);
-} 
-
-arch_initcall(crypto_dev_init);
-module_exit(crypto_dev_exit);
-
-MODULE_AUTHOR("AMLOGIC");
-MODULE_DESCRIPTION("crypto device for user can use crypto alg in kernel");
-MODULE_LICENSE("GPL");
-
-- 
2.19.0

