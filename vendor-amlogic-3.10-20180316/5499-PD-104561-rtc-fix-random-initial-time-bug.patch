From 8106be0b5f9b1f9c149acbaf9512df4cb4f6a541 Mon Sep 17 00:00:00 2001
From: Zhenfei Li <zhenfei.li@amlogic.com>
Date: Wed, 25 Mar 2015 19:28:16 +0800
Subject: [PATCH 5499/5965] PD#104561: rtc: fix random initial time bug.

Change-Id: If0786faa0b452a38c829627d385cbdaa5674092b
---
 drivers/amlogic/power/aml_pmu/aml_pmu.c   |  564 +++---
 drivers/amlogic/power/aml_pmu_of_common.c |  572 +++---
 drivers/amlogic/power/axp_power/axp-mfd.c |  750 ++++----
 drivers/amlogic/power/ricoh/ricoh_pmu.c   |  422 ++---
 drivers/amlogic/rtc/Kconfig               |   22 +-
 drivers/amlogic/rtc/Makefile              |    6 +-
 drivers/amlogic/rtc/aml_rtc.c             | 1930 +++++++++++----------
 include/linux/amlogic/aml_pmu_common.h    |    2 +
 8 files changed, 2153 insertions(+), 2115 deletions(-)
 mode change 100755 => 100644 drivers/amlogic/power/aml_pmu/aml_pmu.c
 mode change 100755 => 100644 drivers/amlogic/power/aml_pmu_of_common.c
 mode change 100755 => 100644 drivers/amlogic/power/axp_power/axp-mfd.c
 mode change 100755 => 100644 drivers/amlogic/power/ricoh/ricoh_pmu.c
 mode change 100755 => 100644 drivers/amlogic/rtc/Kconfig
 mode change 100755 => 100644 drivers/amlogic/rtc/Makefile
 mode change 100755 => 100644 drivers/amlogic/rtc/aml_rtc.c
 mode change 100755 => 100644 include/linux/amlogic/aml_pmu_common.h

diff --git a/drivers/amlogic/power/aml_pmu/aml_pmu.c b/drivers/amlogic/power/aml_pmu/aml_pmu.c
old mode 100755
new mode 100644
index 2f7577cc6b0e..78505a5226ac
--- a/drivers/amlogic/power/aml_pmu/aml_pmu.c
+++ b/drivers/amlogic/power/aml_pmu/aml_pmu.c
@@ -15,16 +15,16 @@
 
 #ifdef CONFIG_AMLOGIC_USB
 #ifdef CONFIG_AML1212
-static struct notifier_block aml1212_otg_nb;                            // notifier_block for OTG issue
-static struct notifier_block aml1212_usb_nb;                            // notifier_block for USB charger issue
+static struct notifier_block aml1212_otg_nb;				// notifier_block for OTG issue
+static struct notifier_block aml1212_usb_nb;				// notifier_block for USB charger issue
 #endif
 #ifdef CONFIG_AML1216
-static struct notifier_block aml1216_otg_nb;                            // notifier_block for OTG issue
-static struct notifier_block aml1216_usb_nb;                            // notifier_block for USB charger issue
+static struct notifier_block aml1216_otg_nb;				// notifier_block for OTG issue
+static struct notifier_block aml1216_usb_nb;				// notifier_block for USB charger issue
 #endif
 #ifdef CONFIG_AML1218
-static struct notifier_block aml1218_otg_nb;                            // notifier_block for OTG issue
-static struct notifier_block aml1218_usb_nb;                            // notifier_block for USB charger issue
+static struct notifier_block aml1218_otg_nb;				// notifier_block for OTG issue
+static struct notifier_block aml1218_usb_nb;				// notifier_block for USB charger issue
 #endif
 extern int dwc_otg_power_register_notifier(struct notifier_block *nb);
 extern int dwc_otg_power_unregister_notifier(struct notifier_block *nb);
@@ -33,13 +33,13 @@ extern int dwc_otg_charger_detect_unregister_notifier(struct notifier_block *nb)
 #endif
 
 #ifdef CONFIG_AML1216
-struct i2c_client *g_aml1216_client = NULL; 
+struct i2c_client *g_aml1216_client = NULL;
 #endif
 #ifdef CONFIG_AML1218
-struct i2c_client *g_aml1218_client = NULL; 
+struct i2c_client *g_aml1218_client = NULL;
 #endif
 #ifdef CONFIG_AML1212
-struct i2c_client *g_aml1212_client = NULL; 
+struct i2c_client *g_aml1212_client = NULL;
 #endif
 static const struct i2c_device_id aml_pmu_id_table[] = {
 #ifdef CONFIG_AML1212
@@ -56,106 +56,110 @@ static const struct i2c_device_id aml_pmu_id_table[] = {
 MODULE_DEVICE_TABLE(i2c, aml_pmu_id_table);
 
 #ifdef CONFIG_OF
-#define DEBUG_TREE      0
-#define DEBUG_PARSE     0
+#define DEBUG_TREE		0
+#define DEBUG_PARSE		0
 #define DBG(format, args...) printk("[AML_PMU]%s, "format, __func__, ##args)
 
 /*
  * must make sure value is 32 bit when use this macro
  * otherwise you should use another variable to get result value
  */
-#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)        \
-    if (of_property_read_u32(node, prop_name, (u32*)(&value))) {        \
-        DBG("failed to get property: %s\n", prop_name);                 \
-        goto exception;                                                 \
-    }                                                                   \
-    if (DEBUG_PARSE) {                                                  \
-        DBG("get property:%25s, value:0x%08x, dec:%8d\n",               \
-            prop_name, value, value);                                   \
-    }
-
-#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)            \
-    if (of_property_read_string(node, prop_name, (const char **)&value)) {  \
-        DBG("failed to get property: %s\n", prop_name);                     \
-        goto exception;                                                     \
-    }                                                                       \
-    if (DEBUG_PARSE) {                                                      \
-        DBG("get property:%25s, value:%s\n",                                \
-            prop_name, value);                                              \
-    }
-
-#define ALLOC_DEVICES(return_pointer, size, flag)                       \
-    return_pointer = kzalloc(size, flag);                               \
-    if (!return_pointer) {                                              \
-        DBG("%d, allocate "#return_pointer" failed\n", __LINE__);       \
-        return -ENOMEM;                                                 \
-    } 
+#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)	\
+	if (of_property_read_u32(node, prop_name, (u32*)(&value))) {	\
+		DBG("failed to get property: %s\n", prop_name);		\
+		goto exception;						\
+	}								\
+	if (DEBUG_PARSE) {						\
+		DBG("get property:%25s, value:0x%08x, dec:%8d\n",	\
+			prop_name, value, value);			\
+	}
+
+#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)			\
+	if (of_property_read_string(node, prop_name, (const char **)&value)) {		\
+		DBG("failed to get property: %s\n", prop_name);				\
+		goto exception;								\
+	}										\
+	if (DEBUG_PARSE) {								\
+		DBG("get property:%25s, value:%s\n",					\
+			prop_name, value);						\
+	}
+
+#define ALLOC_DEVICES(return_pointer, size, flag)					\
+	return_pointer = kzalloc(size, flag);						\
+	if (!return_pointer) {								\
+		DBG("%d, allocate "#return_pointer" failed\n", __LINE__);		\
+		return -ENOMEM;								\
+	}
 
 #if DEBUG_TREE
 char msg_buf[100];
 static void scan_node_tree(struct device_node *top_node, int off)
 {
-    if (!top_node) {
-        return;
-    }
-    if (!off) {
-        printk("device tree is :\n");
-    }
-    while (top_node) {
-        memset(msg_buf, ' ', sizeof(msg_buf));
-        sprintf(msg_buf + off, "|--%s\n", top_node->name);
-        printk(msg_buf);
-        scan_node_tree(top_node->child, off + 4);
-        top_node = top_node->sibling;
-    }
+	if (!top_node) {
+		return;
+	}
+	if (!off) {
+		printk("device tree is :\n");
+	}
+	while (top_node) {
+		memset(msg_buf, ' ', sizeof(msg_buf));
+		sprintf(msg_buf + off, "|--%s\n", top_node->name);
+		printk(msg_buf);
+		scan_node_tree(top_node->child, off + 4);
+		top_node = top_node->sibling;
+	}
 }
-#endif      
+#endif
 
 static int setup_supply_data(struct device_node *node, struct amlogic_pmu_init *s_data)
 {
-    struct device_node *b_node;
-    struct battery_parameter *battery;
-    phandle fhandle;
-
-    PARSE_UINT32_PROPERTY(node, "soft_limit_to99", s_data->soft_limit_to99, parse_failed);
-    PARSE_UINT32_PROPERTY(node, "board_battery",   fhandle,                 parse_failed);
-    PARSE_UINT32_PROPERTY(node, "vbus_dcin_short_connect", s_data->vbus_dcin_short_connect, parse_failed);
-    b_node = of_find_node_by_phandle(fhandle);
-    if (!b_node) {
-        DBG("find battery node failed, current:%s\n", node->name);
-    }
-    ALLOC_DEVICES(battery, sizeof(*battery), GFP_KERNEL);
-    if (parse_battery_parameters(b_node, battery)) {
-        DBG("failed to parse battery parameter, node:%s\n", b_node->name);
-        kfree(battery);
-    } else {
-        s_data->board_battery = battery;                                // attach to axp_supply_init_data 
-    }
-    return 0;
+	struct device_node *b_node;
+	struct battery_parameter *battery;
+	phandle fhandle;
+
+	PARSE_UINT32_PROPERTY(node, "soft_limit_to99", s_data->soft_limit_to99, parse_failed);
+	if (of_property_read_u32(node, "board_battery", (u32*)(&fhandle))) {
+		set_board_battery_status(0);
+		goto parse_failed;
+	}
+	PARSE_UINT32_PROPERTY(node, "vbus_dcin_short_connect", s_data->vbus_dcin_short_connect, parse_failed);
+	b_node = of_find_node_by_phandle(fhandle);
+	if (!b_node) {
+		DBG("find battery node failed, current:%s\n", node->name);
+	}
+	ALLOC_DEVICES(battery, sizeof(*battery), GFP_KERNEL);
+	if (parse_battery_parameters(b_node, battery)) {
+		DBG("failed to parse battery parameter, node:%s\n", b_node->name);
+		kfree(battery);
+	} else {
+		set_board_battery_status(1);
+		s_data->board_battery = battery; // attach to axp_supply_init_data
+	}
+	return 0;
 
 parse_failed:
-    return -EINVAL;
+	return -EINVAL;
 }
 
 static int setup_platform_pmu_init_data(struct device_node *node, struct amlogic_pmu_init *pdata)
 {
-    if (setup_supply_data(node, pdata)) {
-        return  -EINVAL;
-    }
+	if (setup_supply_data(node, pdata)) {
+		return  -EINVAL;
+	}
 
-    return 0;
+	return 0;
 }
 
 static struct i2c_device_id *find_id_table_by_name(const struct i2c_device_id *look_table, char *name)
 {
-    while (look_table->name && look_table->name[0]) {
-        printk("table name:%s, name:%s\n", look_table->name, name);
-        if (!strcmp(look_table->name, name)) {
-            return (struct i2c_device_id *)look_table;
-        }
-        look_table++;
-    }
-    return NULL;
+	while (look_table->name && look_table->name[0]) {
+		printk("table name:%s, name:%s\n", look_table->name, name);
+		if (!strcmp(look_table->name, name)) {
+			return (struct i2c_device_id *)look_table;
+		}
+		look_table++;
+	}
+	return NULL;
 }
 static struct amlogic_pmu_init *init_data;
 #endif /* CONFIG_OF */
@@ -164,57 +168,57 @@ static struct amlogic_pmu_init *init_data;
 extern struct aml_pmu_driver aml1216_pmu_driver;
 static int aml_1216_convert_id_to_dcdc(uint32_t id)
 {
-    int dcdc = 0; 
-    switch (id) {
-    case AML_DVFS_ID_VCCK:
-        dcdc = 1;
-        break;
-
-    case AML_DVFS_ID_VDDEE:
-        dcdc = 2;
-        break;
-
-    case AML_DVFS_ID_DDR:
-        dcdc = 3;
-        break;
-
-    default:
-        break;
-    }
-    return dcdc;
+	int dcdc = 0;
+	switch (id) {
+	case AML_DVFS_ID_VCCK:
+		dcdc = 1;
+		break;
+
+	case AML_DVFS_ID_VDDEE:
+		dcdc = 2;
+		break;
+
+	case AML_DVFS_ID_DDR:
+		dcdc = 3;
+		break;
+
+	default:
+		break;
+	}
+	return dcdc;
 }
 
 static int aml1216_set_voltage(uint32_t id, uint32_t min_uV, uint32_t max_uV)
 {
-    int dcdc = aml_1216_convert_id_to_dcdc(id);
-    uint32_t vol = 0;
-    
-    if (min_uV > max_uV) {
-        return -1;    
-    }
-    vol = (min_uV + max_uV) / 2;
-    if (dcdc >= 1 && dcdc <= 3) {
-        return aml1216_set_dcdc_voltage(dcdc, vol);
-    }
-    return -EINVAL;
+	int dcdc = aml_1216_convert_id_to_dcdc(id);
+	uint32_t vol = 0;
+
+	if (min_uV > max_uV) {
+		return -1;
+	}
+	vol = (min_uV + max_uV) / 2;
+	if (dcdc >= 1 && dcdc <= 3) {
+		return aml1216_set_dcdc_voltage(dcdc, vol);
+	}
+	return -EINVAL;
 }
 
 static int aml1216_get_voltage(uint32_t id, uint32_t *uV)
 {
-    int dcdc = aml_1216_convert_id_to_dcdc(id);
+	int dcdc = aml_1216_convert_id_to_dcdc(id);
 
-    if (dcdc >= 1 && dcdc <= 3) {
-        return aml1216_get_dcdc_voltage(dcdc, uV);    
-    }
+	if (dcdc >= 1 && dcdc <= 3) {
+		return aml1216_get_dcdc_voltage(dcdc, uV);
+	}
 
-    return -EINVAL;
+	return -EINVAL;
 }
 
 struct aml_dvfs_driver aml1216_dvfs_driver = {
-    .name        = "aml1216-dvfs",
-    .id_mask     = (AML_DVFS_ID_VCCK | AML_DVFS_ID_VDDEE | AML_DVFS_ID_DDR),
-    .set_voltage = aml1216_set_voltage, 
-    .get_voltage = aml1216_get_voltage,
+	.name		= "aml1216-dvfs",
+	.id_mask	= (AML_DVFS_ID_VCCK | AML_DVFS_ID_VDDEE | AML_DVFS_ID_DDR),
+	.set_voltage	= aml1216_set_voltage,
+	.get_voltage	= aml1216_get_voltage,
 };
 
 #endif
@@ -223,174 +227,174 @@ struct aml_dvfs_driver aml1216_dvfs_driver = {
 extern struct aml_pmu_driver aml1218_pmu_driver;
 static int aml_1218_convert_id_to_dcdc(uint32_t id)
 {
-    int dcdc = 0; 
-    switch (id) {
-    case AML_DVFS_ID_VCCK:
-        dcdc = 4;
-        break;
-
-    case AML_DVFS_ID_VDDEE:
-        dcdc = 2;
-        break;
-
-    case AML_DVFS_ID_DDR:
-        dcdc = 3;
-        break;
-
-    default:
-        break;
-    }
-    return dcdc;
+	int dcdc = 0;
+	switch (id) {
+	case AML_DVFS_ID_VCCK:
+		dcdc = 4;
+		break;
+
+	case AML_DVFS_ID_VDDEE:
+		dcdc = 2;
+		break;
+
+	case AML_DVFS_ID_DDR:
+		dcdc = 3;
+		break;
+
+	default:
+		break;
+	}
+	return dcdc;
 }
 
 static int aml1218_set_voltage(uint32_t id, uint32_t min_uV, uint32_t max_uV)
 {
-    int dcdc = aml_1218_convert_id_to_dcdc(id);
-    uint32_t vol = 0;
-    
-    if (min_uV > max_uV) {
-        return -1;    
-    }
-    vol = (min_uV + max_uV) / 2;
-    if (dcdc >= 1 && dcdc <= 4) {
-        return aml1218_set_dcdc_voltage(dcdc, vol);
-    }
-    return -EINVAL;
+	int dcdc = aml_1218_convert_id_to_dcdc(id);
+	uint32_t vol = 0;
+
+	if (min_uV > max_uV) {
+		return -1;
+	}
+	vol = (min_uV + max_uV) / 2;
+	if (dcdc >= 1 && dcdc <= 4) {
+		return aml1218_set_dcdc_voltage(dcdc, vol);
+	}
+	return -EINVAL;
 }
 
 static int aml1218_get_voltage(uint32_t id, uint32_t *uV)
 {
-    int dcdc = aml_1218_convert_id_to_dcdc(id);
+	int dcdc = aml_1218_convert_id_to_dcdc(id);
 
-    if (dcdc >= 1 && dcdc <= 4) {
-        return aml1218_get_dcdc_voltage(dcdc, uV);    
-    }
+	if (dcdc >= 1 && dcdc <= 4) {
+		return aml1218_get_dcdc_voltage(dcdc, uV);
+	}
 
-    return -EINVAL;
+	return -EINVAL;
 }
 
 struct aml_dvfs_driver aml1218_dvfs_driver = {
-    .name        = "aml1218-dvfs",
-    .id_mask     = (AML_DVFS_ID_VCCK | AML_DVFS_ID_VDDEE | AML_DVFS_ID_DDR),
-    .set_voltage = aml1218_set_voltage, 
-    .get_voltage = aml1218_get_voltage,
+	.name		= "aml1218-dvfs",
+	.id_mask	= (AML_DVFS_ID_VCCK | AML_DVFS_ID_VDDEE | AML_DVFS_ID_DDR),
+	.set_voltage	= aml1218_set_voltage,
+	.get_voltage	= aml1218_get_voltage,
 };
 #endif
 
 static int aml_pmu_check_device(struct i2c_client *client)
 {
-    int ret;
-    uint8_t buf[2] = {}; 
-    struct i2c_msg msg[] = { 
-        {   
-            .addr  = client->addr & 0xff,
-            .flags = 0,
-            .len   = sizeof(buf),
-            .buf   = buf,
-        },  
-        {   
-            .addr  = client->addr & 0xff,
-            .flags = I2C_M_RD,
-            .len   = 1,
-            .buf   = &buf[1],
-        }   
-    };  
-
-    ret = i2c_transfer(client->adapter, msg, 2); 
-    if (ret < 0) {
-        DBG("%s: i2c transfer for %x failed, ret:%d\n", __func__, client->addr, ret);
-        return ret;
-    }   
-    return 0;
+	int ret;
+	uint8_t buf[2] = {};
+	struct i2c_msg msg[] = {
+		{
+			.addr  = client->addr & 0xff,
+			.flags = 0,
+			.len   = sizeof(buf),
+			.buf   = buf,
+		},
+		{
+			.addr  = client->addr & 0xff,
+			.flags = I2C_M_RD,
+			.len   = 1,
+			.buf   = &buf[1],
+		}
+	};
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		DBG("%s: i2c transfer for %x failed, ret:%d\n", __func__, client->addr, ret);
+		return ret;
+	}
+	return 0;
 }
 
 static int aml_pmu_probe(struct i2c_client *client,
-				  const struct i2c_device_id *id)
+				const struct i2c_device_id *id)
 {
 #ifdef CONFIG_OF
-    char   *sub_type = NULL;
-    struct  platform_device *pdev;
-    struct  i2c_device_id *type = NULL;
-	int     ret;
-    
-    if (aml_pmu_check_device(client)) {
-        return -ENODEV;    
-    }
-    /*
-     * allocate and regist AML1212 devices, then kernel will probe driver for AML1212
-     */
+	char   *sub_type = NULL;
+	struct  platform_device *pdev;
+	struct  i2c_device_id *type = NULL;
+	int	ret;
+
+	if (aml_pmu_check_device(client)) {
+		return -ENODEV;
+	}
+	/*
+	* allocate and regist AML1212 devices, then kernel will probe driver for AML1212
+	*/
 #if DEBUG_TREE
-    scan_node_tree(client->dev.of_node, 0);
+	scan_node_tree(client->dev.of_node, 0);
 #endif
-    init_data = kzalloc(sizeof(*init_data), GFP_KERNEL);
-    if (!init_data) {
-        DBG("%s, allocate initialize data failed\n", __func__);
-        return -ENOMEM;
-    }
-    setup_platform_pmu_init_data(client->dev.of_node, init_data);
-    PARSE_STRING_PROPERTY(client->dev.of_node, "sub_type", sub_type, out_free_chip);
-    type = find_id_table_by_name(aml_pmu_id_table, sub_type);
-    if (!type) {                                                        // sub type is not supported
-        DBG("sub_type of '%s' is not match, abort\n", sub_type);
-        goto out_free_chip;
-    }
+	init_data = kzalloc(sizeof(*init_data), GFP_KERNEL);
+	if (!init_data) {
+		DBG("%s, allocate initialize data failed\n", __func__);
+		return -ENOMEM;
+	}
+	setup_platform_pmu_init_data(client->dev.of_node, init_data);
+	PARSE_STRING_PROPERTY(client->dev.of_node, "sub_type", sub_type, out_free_chip);
+	type = find_id_table_by_name(aml_pmu_id_table, sub_type);
+	if (!type) {														// sub type is not supported
+		DBG("sub_type of '%s' is not match, abort\n", sub_type);
+		goto out_free_chip;
+	}
 
 #ifdef CONFIG_AML1212
-    if (type->driver_data == 0) {
-        g_aml1212_client = client;     
-        aml_pmu_register_driver(&aml1212_driver);
-    #ifdef CONFIG_AMLOGIC_USB
-        aml1212_otg_nb.notifier_call = aml1212_otg_change;
-        aml1212_usb_nb.notifier_call = aml1212_usb_charger;
-        dwc_otg_power_register_notifier(&aml1212_otg_nb);
-        dwc_otg_charger_detect_register_notifier(&aml1212_usb_nb);
-    #endif
-    }
+	if (type->driver_data == 0) {
+		g_aml1212_client = client;
+		aml_pmu_register_driver(&aml1212_driver);
+	#ifdef CONFIG_AMLOGIC_USB
+		aml1212_otg_nb.notifier_call = aml1212_otg_change;
+		aml1212_usb_nb.notifier_call = aml1212_usb_charger;
+		dwc_otg_power_register_notifier(&aml1212_otg_nb);
+		dwc_otg_charger_detect_register_notifier(&aml1212_usb_nb);
+	#endif
+	}
 #endif
 #ifdef CONFIG_AML1216
-    if (type->driver_data == 1) {
-        g_aml1216_client = client;            
-    #if defined(CONFIG_AML_DVFS) && defined(CONFIG_AML1216)
-        aml_dvfs_register_driver(&aml1216_dvfs_driver);
-    #endif
-    #ifdef CONFIG_AMLOGIC_USB
-        aml1216_otg_nb.notifier_call = aml1216_otg_change;
-        aml1216_usb_nb.notifier_call = aml1216_usb_charger;
-        dwc_otg_power_register_notifier(&aml1216_otg_nb);
-        dwc_otg_charger_detect_register_notifier(&aml1216_usb_nb);
-    #endif
-        aml_pmu_register_driver(&aml1216_pmu_driver);
-    }
+	if (type->driver_data == 1) {
+		g_aml1216_client = client;
+	#if defined(CONFIG_AML_DVFS) && defined(CONFIG_AML1216)
+		aml_dvfs_register_driver(&aml1216_dvfs_driver);
+	#endif
+	#ifdef CONFIG_AMLOGIC_USB
+		aml1216_otg_nb.notifier_call = aml1216_otg_change;
+		aml1216_usb_nb.notifier_call = aml1216_usb_charger;
+		dwc_otg_power_register_notifier(&aml1216_otg_nb);
+		dwc_otg_charger_detect_register_notifier(&aml1216_usb_nb);
+	#endif
+		aml_pmu_register_driver(&aml1216_pmu_driver);
+	}
 #endif
 #ifdef CONFIG_AML1218
-    if (type->driver_data == 2) {
-        g_aml1218_client = client;            
-    #if defined(CONFIG_AML_DVFS) && defined(CONFIG_AML1218)
-        aml_dvfs_register_driver(&aml1218_dvfs_driver);
-    #endif
-    #ifdef CONFIG_AMLOGIC_USB
-        aml1218_otg_nb.notifier_call = aml1218_otg_change;
-        aml1218_usb_nb.notifier_call = aml1218_usb_charger;
-        dwc_otg_power_register_notifier(&aml1218_otg_nb);
-        dwc_otg_charger_detect_register_notifier(&aml1218_usb_nb);
-    #endif
-        aml_pmu_register_driver(&aml1218_pmu_driver);
-    }
+	if (type->driver_data == 2) {
+		g_aml1218_client = client;
+	#if defined(CONFIG_AML_DVFS) && defined(CONFIG_AML1218)
+		aml_dvfs_register_driver(&aml1218_dvfs_driver);
+	#endif
+	#ifdef CONFIG_AMLOGIC_USB
+		aml1218_otg_nb.notifier_call = aml1218_otg_change;
+		aml1218_usb_nb.notifier_call = aml1218_usb_charger;
+		dwc_otg_power_register_notifier(&aml1218_otg_nb);
+		dwc_otg_charger_detect_register_notifier(&aml1218_usb_nb);
+	#endif
+		aml_pmu_register_driver(&aml1218_pmu_driver);
+	}
 #endif
-    pdev = platform_device_alloc(sub_type, 0);
-    if (pdev == NULL) {
-        printk(">> %s, allocate platform device failed\n", __func__);
-        return -ENOMEM;
-    }
-    pdev->dev.parent        = &client->dev;
-    pdev->dev.platform_data =  init_data; 
-    ret = platform_device_add(pdev);
-    if (ret) {
-        printk(">> %s, add platform device failed\n", __func__);
-        platform_device_del(pdev);
-        return -EINVAL;
-    }
-    i2c_set_clientdata(client, pdev); 
+	pdev = platform_device_alloc(sub_type, 0);
+	if (pdev == NULL) {
+		printk(">> %s, allocate platform device failed\n", __func__);
+		return -ENOMEM;
+	}
+	pdev->dev.parent		= &client->dev;
+	pdev->dev.platform_data =  init_data;
+	ret = platform_device_add(pdev);
+	if (ret) {
+		printk(">> %s, add platform device failed\n", __func__);
+		platform_device_del(pdev);
+		return -EINVAL;
+	}
+	i2c_set_clientdata(client, pdev);
 
 out_free_chip:
 #endif  /* CONFIG_OF */
@@ -399,40 +403,40 @@ out_free_chip:
 
 static int aml_pmu_remove(struct i2c_client *client)
 {
-    struct platform_device *pdev = i2c_get_clientdata(client);
+	struct platform_device *pdev = i2c_get_clientdata(client);
 
 #ifdef CONFIG_AML1212
-    g_aml1212_client = NULL;
-    aml_pmu_clear_driver();
-    dwc_otg_power_unregister_notifier(&aml1212_otg_nb);
-    dwc_otg_charger_detect_unregister_notifier(&aml1212_usb_nb);
+	g_aml1212_client = NULL;
+	aml_pmu_clear_driver();
+	dwc_otg_power_unregister_notifier(&aml1212_otg_nb);
+	dwc_otg_charger_detect_unregister_notifier(&aml1212_usb_nb);
 #endif
 #ifdef CONFIG_AML1216
-    g_aml1216_client = NULL;
+	g_aml1216_client = NULL;
 #if defined(CONFIG_AML_DVFS) && defined(CONFIG_AML1216)
-    aml_dvfs_unregister_driver(&aml1216_dvfs_driver);
+	aml_dvfs_unregister_driver(&aml1216_dvfs_driver);
 #endif
-    aml_pmu_clear_driver();
-    dwc_otg_power_unregister_notifier(&aml1216_otg_nb);
-    dwc_otg_charger_detect_unregister_notifier(&aml1216_usb_nb);
+	aml_pmu_clear_driver();
+	dwc_otg_power_unregister_notifier(&aml1216_otg_nb);
+	dwc_otg_charger_detect_unregister_notifier(&aml1216_usb_nb);
 #endif
 #ifdef CONFIG_AML1218
-    g_aml1218_client = NULL;
+	g_aml1218_client = NULL;
 #if defined(CONFIG_AML_DVFS) && defined(CONFIG_AML1218)
-    aml_dvfs_unregister_driver(&aml1218_dvfs_driver);
+	aml_dvfs_unregister_driver(&aml1218_dvfs_driver);
 #endif
-    aml_pmu_clear_driver();
-    dwc_otg_power_unregister_notifier(&aml1218_otg_nb);
-    dwc_otg_charger_detect_unregister_notifier(&aml1218_usb_nb);
+	aml_pmu_clear_driver();
+	dwc_otg_power_unregister_notifier(&aml1218_otg_nb);
+	dwc_otg_charger_detect_unregister_notifier(&aml1218_usb_nb);
 #endif
-    platform_device_del(pdev);
+	platform_device_del(pdev);
 
 	return 0;
 }
 
 #ifdef CONFIG_OF
 static const struct of_device_id amlogic_pmu_match_id = {
-        .compatible = "amlogic_pmu",
+		.compatible = "amlogic_pmu",
 };
 #endif
 
@@ -440,18 +444,18 @@ static struct i2c_driver aml_pmu_driver = {
 	.driver	= {
 		.name	= "amlogic_pmu",
 		.owner	= THIS_MODULE,
-    #ifdef CONFIG_OF
-        .of_match_table = &amlogic_pmu_match_id,
-    #endif
+	#ifdef CONFIG_OF
+		.of_match_table = &amlogic_pmu_match_id,
+	#endif
 	},
-	.probe		= aml_pmu_probe,
-	.remove		= aml_pmu_remove,
+	.probe	= aml_pmu_probe,
+	.remove	= aml_pmu_remove,
 	.id_table	= aml_pmu_id_table,
 };
 
 static int __init aml_pmu_init(void)
 {
-    printk("%s, %d\n", __func__, __LINE__);
+	printk("%s, %d\n", __func__, __LINE__);
 	return i2c_add_driver(&aml_pmu_driver);
 }
 arch_initcall(aml_pmu_init);
diff --git a/drivers/amlogic/power/aml_pmu_of_common.c b/drivers/amlogic/power/aml_pmu_of_common.c
old mode 100755
new mode 100644
index 6905f5454e18..630ca61e746f
--- a/drivers/amlogic/power/aml_pmu_of_common.c
+++ b/drivers/amlogic/power/aml_pmu_of_common.c
@@ -22,171 +22,171 @@
 #include <linux/amlogic/battery_parameter.h>
 #include <linux/amlogic/aml_pmu_common.h>
 
-#define AML_I2C_BUS_AO     0
-#define AML_I2C_BUS_A       1
-#define AML_I2C_BUS_B       2
+#define AML_I2C_BUS_AO		0
+#define AML_I2C_BUS_A		1
+#define AML_I2C_BUS_B		2
 
-#define DEBUG_TREE      0
-#define DEBUG_PARSE     0
+#define DEBUG_TREE		0
+#define DEBUG_PARSE		0
 #define DBG(format, args...) printk("%s, "format, __func__, ##args)
 
 /*
  * must make sure value is 32 bit when use this macro
  * otherwise you should use another variable to get result value
  */
-#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)        \
-    if (of_property_read_u32(node, prop_name, (u32*)(&value))) {        \
-        DBG("failed to get property: %s\n", prop_name);                 \
-        goto exception;                                                 \
-    }                                                                   \
-    if (DEBUG_PARSE) {                                                  \
-        DBG("get property:%25s, value:0x%08x, dec:%8d\n",               \
-            prop_name, value, value);                                   \
-    }
-
-#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)                \
-    if (of_property_read_string(node, prop_name, (const char **)&value)) {      \
-        DBG("failed to get property: %s\n", prop_name);                 \
-        goto exception;                                                 \
-    }                                                                   \
-    if (DEBUG_PARSE) {                                                  \
-        DBG("get property:%25s, value:%s\n",                            \
-            prop_name, value);                                          \
-    }
+#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)		\
+	if (of_property_read_u32(node, prop_name, (u32*)(&value))) {		\
+		DBG("failed to get property: %s\n", prop_name);			\
+		goto exception;							\
+	}									\
+	if (DEBUG_PARSE) {							\
+		DBG("get property:%25s, value:0x%08x, dec:%8d\n",		\
+			prop_name, value, value);				\
+	}
+
+#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)		\
+	if (of_property_read_string(node, prop_name, (const char **)&value)) {	\
+		DBG("failed to get property: %s\n", prop_name);			\
+		goto exception;							\
+	}									\
+	if (DEBUG_PARSE) {							\
+		DBG("get property:%25s, value:%s\n",				\
+			prop_name, value);					\
+	}
 
 /*
  * common API for callback and drivers
  */
-static void    *pmu_callback_mutex     = NULL;
-static struct aml_pmu_driver *g_driver = NULL;
-static struct aml_pmu_api *g_aml_pmu_api = NULL;
+static void *pmu_callback_mutex			= NULL;
+static struct aml_pmu_driver *g_driver		= NULL;
+static struct aml_pmu_api *g_aml_pmu_api	= NULL;
 
 struct pmu_callback_group {
-    char                        name[20];
-    void                       *private;
-    pmu_callback                callback;
-    struct pmu_callback_group *next;
+	char			name[20];
+	void			*private;
+	pmu_callback		callback;
+	struct pmu_callback_group *next;
 };
 
 static struct pmu_callback_group *g_callbacks = NULL;
 
 int aml_pmu_register_callback(pmu_callback callback, void *pdata, char *name)
 {
-    struct pmu_callback_group *cg = NULL, *cn;
-
-    if (!pmu_callback_mutex) {
-        pmu_callback_mutex = pmu_alloc_mutex();
-        if (!pmu_callback_mutex) {
-            printk("%s, allocate mutex failed\n", __func__);
-            return -ENOMEM;
-        }
-    }
-    pmu_mutex_lock(pmu_callback_mutex);
-    cg = kzalloc(sizeof(*cg), GFP_KERNEL);
-    if (!cg) {
-        printk("%s, allocate callback failed\n", __func__);
-        pmu_mutex_unlock(pmu_callback_mutex);
-        return -ENOMEM; 
-    }
-    cg->callback = callback;
-    cg->private  = pdata;
-    strcpy(cg->name, name);
-    if (!g_callbacks) {                                                 // add first callback
-        g_callbacks = cg;
-        printk("callback %s registed, cg:%p\n", cg->name, cg);
-        pmu_mutex_unlock(pmu_callback_mutex);
-        return 0;
-    }
-    for (cn = g_callbacks; cn->next; cn = cn->next) {
-        if (name && !strcmp(cn->name, name)) {
-            printk("%s, callback %s is already exist\n", __func__, name);
-            pmu_mutex_unlock(pmu_callback_mutex);
-            return -EINVAL;
-        }
-    }
-    cn->next = cg;
-    printk("callback %s registed, cg:%p\n", cg->name, cg);
-    pmu_mutex_unlock(pmu_callback_mutex);
-    return 0;
+	struct pmu_callback_group *cg = NULL, *cn;
+
+	if (!pmu_callback_mutex) {
+		pmu_callback_mutex = pmu_alloc_mutex();
+		if (!pmu_callback_mutex) {
+			printk("%s, allocate mutex failed\n", __func__);
+			return -ENOMEM;
+		}
+	}
+	pmu_mutex_lock(pmu_callback_mutex);
+	cg = kzalloc(sizeof(*cg), GFP_KERNEL);
+	if (!cg) {
+		printk("%s, allocate callback failed\n", __func__);
+		pmu_mutex_unlock(pmu_callback_mutex);
+		return -ENOMEM;
+	}
+	cg->callback = callback;
+	cg->private  = pdata;
+	strcpy(cg->name, name);
+	if (!g_callbacks) {		// add first callback
+		g_callbacks = cg;
+		printk("callback %s registed, cg:%p\n", cg->name, cg);
+		pmu_mutex_unlock(pmu_callback_mutex);
+		return 0;
+	}
+	for (cn = g_callbacks; cn->next; cn = cn->next) {
+		if (name && !strcmp(cn->name, name)) {
+			printk("%s, callback %s is already exist\n", __func__, name);
+			pmu_mutex_unlock(pmu_callback_mutex);
+			return -EINVAL;
+		}
+	}
+	cn->next = cg;
+	printk("callback %s registed, cg:%p\n", cg->name, cg);
+	pmu_mutex_unlock(pmu_callback_mutex);
+	return 0;
 }
 EXPORT_SYMBOL(aml_pmu_register_callback);
 
 int aml_pmu_unregister_callback(char *name)
 {
-    struct pmu_callback_group *cn, *tmp = g_callbacks;
-    int find = 0;
-    pmu_mutex_lock(pmu_callback_mutex);
-    if (name && !strcmp(tmp->name, name)) {                             // first node is target
-        g_callbacks = g_callbacks->next;    
-        kfree(tmp);
-        printk("%s, callback %s unregisted\n", __func__, name);
-        find = 1;
-    }
-    if (g_callbacks) {
-        for (cn = g_callbacks->next; cn; cn = cn->next) {
-            if (name && !strcmp(cn->name, name)) {
-                tmp->next = cn->next;
-                kfree(cn);
-                printk("%s, callback %s unregisted\n", __func__, name);
-                find = 1;
-                break;
-            }
-            tmp = tmp->next;
-        }
-    }
-    pmu_mutex_unlock(pmu_callback_mutex);
-    if (!find) {
-        printk("%s, callback %s not find\n", __func__, name);
-        return -1;
-    }
-    return 0;
+	struct pmu_callback_group *cn, *tmp = g_callbacks;
+	int find = 0;
+	pmu_mutex_lock(pmu_callback_mutex);
+	if (name && !strcmp(tmp->name, name)) {		// first node is target
+		g_callbacks = g_callbacks->next;
+		kfree(tmp);
+		printk("%s, callback %s unregisted\n", __func__, name);
+		find = 1;
+	}
+	if (g_callbacks) {
+		for (cn = g_callbacks->next; cn; cn = cn->next) {
+			if (name && !strcmp(cn->name, name)) {
+				tmp->next = cn->next;
+				kfree(cn);
+				printk("%s, callback %s unregisted\n", __func__, name);
+				find = 1;
+				break;
+			}
+			tmp = tmp->next;
+		}
+	}
+	pmu_mutex_unlock(pmu_callback_mutex);
+	if (!find) {
+		printk("%s, callback %s not find\n", __func__, name);
+		return -1;
+	}
+	return 0;
 }
 EXPORT_SYMBOL(aml_pmu_unregister_callback);
 
 void aml_pmu_do_callbacks(struct aml_charger *charger)
 {
-    struct pmu_callback_group *cn;
-
-    if (g_callbacks) {
-        pmu_mutex_lock(pmu_callback_mutex);
-        for (cn = g_callbacks; cn; cn = cn->next) {
-            if (cn->callback) {
-                cn->callback(charger, cn->private);    
-            }
-        }
-        pmu_mutex_unlock(pmu_callback_mutex);
-    }
+	struct pmu_callback_group *cn;
+
+	if (g_callbacks) {
+		pmu_mutex_lock(pmu_callback_mutex);
+		for (cn = g_callbacks; cn; cn = cn->next) {
+			if (cn->callback) {
+				cn->callback(charger, cn->private);
+			}
+		}
+		pmu_mutex_unlock(pmu_callback_mutex);
+	}
 }
 EXPORT_SYMBOL(aml_pmu_do_callbacks);
 
 long aml_pmu_get_ts(void)
 {
-    struct timespec ts; 
-    ktime_get_ts(&ts);
-    return ts.tv_sec;
+	struct timespec ts;
+	ktime_get_ts(&ts);
+	return ts.tv_sec;
 }
 EXPORT_SYMBOL(aml_pmu_get_ts);
 
 int aml_pmu_register_api(struct aml_pmu_api *api)
 {
-    if (!api || g_aml_pmu_api) {
-        printk("%s, invalid input, api:%p\n", __func__, g_aml_pmu_api);    
-        return -EINVAL;
-    }
-    g_aml_pmu_api = api;
-    return 0;
+	if (!api || g_aml_pmu_api) {
+		printk("%s, invalid input, api:%p\n", __func__, g_aml_pmu_api);
+		return -EINVAL;
+	}
+	g_aml_pmu_api = api;
+	return 0;
 }
 EXPORT_SYMBOL(aml_pmu_register_api);
 
 void aml_pmu_clear_api(void)
 {
-    g_aml_pmu_api = NULL;    
+	g_aml_pmu_api = NULL;
 }
 EXPORT_SYMBOL(aml_pmu_clear_api);
 
 struct aml_pmu_api *aml_pmu_get_api(void)
 {
-    return g_aml_pmu_api;    
+	return g_aml_pmu_api;
 }
 EXPORT_SYMBOL(aml_pmu_get_api);
 
@@ -196,30 +196,30 @@ EXPORT_SYMBOL(aml_pmu_get_api);
  */
 int aml_pmu_register_driver(struct aml_pmu_driver *driver)
 {
-    if (driver == NULL) {
-        printk("%s, ERROR:NULL driver\n", __func__);    
-        return -1;
-    }
-    if (g_driver != NULL) {
-        printk("%s, ERROR:driver %s has alread registed\n", __func__, driver->name);
-        return -1;
-    }
-    if (!driver->pmu_get_coulomb || !driver->pmu_update_status) {
-        printk("%s, lost important functions\n", __func__);
-        return -1;
-    }
-    g_driver = driver;
-
-    return 0;
+	if (driver == NULL) {
+		printk("%s, ERROR:NULL driver\n", __func__);
+		return -1;
+	}
+	if (g_driver != NULL) {
+		printk("%s, ERROR:driver %s has alread registed\n", __func__, driver->name);
+		return -1;
+	}
+	if (!driver->pmu_get_coulomb || !driver->pmu_update_status) {
+		printk("%s, lost important functions\n", __func__);
+		return -1;
+	}
+	g_driver = driver;
+
+	return 0;
 }
 EXPORT_SYMBOL(aml_pmu_register_driver);
 
 /*
  * clear pmu drivers which already registered;
  */
-void aml_pmu_clear_driver(void) 
+void aml_pmu_clear_driver(void)
 {
-    g_driver = NULL;
+	g_driver = NULL;
 }
 EXPORT_SYMBOL(aml_pmu_clear_driver);
 
@@ -228,7 +228,7 @@ EXPORT_SYMBOL(aml_pmu_clear_driver);
  */
 struct aml_pmu_driver* aml_pmu_get_driver(void)
 {
-    return g_driver;
+	return g_driver;
 }
 EXPORT_SYMBOL(aml_pmu_get_driver);
 
@@ -238,178 +238,192 @@ EXPORT_SYMBOL(aml_pmu_get_driver);
  */
 int parse_battery_parameters(struct device_node *node, struct battery_parameter *battery)
 {
-    unsigned int *curve;
-    char *bat_name = NULL;
-
-    PARSE_UINT32_PROPERTY(node, "pmu_twi_id",             battery->pmu_twi_id,              parse_failed); 
-    PARSE_UINT32_PROPERTY(node, "pmu_irq_id",             battery->pmu_irq_id,              parse_failed); 
-    PARSE_UINT32_PROPERTY(node, "pmu_twi_addr",           battery->pmu_twi_addr,            parse_failed); 
-    PARSE_UINT32_PROPERTY(node, "pmu_battery_rdc",        battery->pmu_battery_rdc,         parse_failed); 
-    PARSE_UINT32_PROPERTY(node, "pmu_battery_cap",        battery->pmu_battery_cap,         parse_failed); 
-    PARSE_UINT32_PROPERTY(node, "pmu_battery_technology", battery->pmu_battery_technology,  parse_failed); 
-    PARSE_STRING_PROPERTY(node, "pmu_battery_name",       bat_name,                         parse_failed);
-    /*
-     * of_property_read_string only change output pointer address,
-     * so need copy string from pointed address to array.
-     */
-    if (bat_name) {
-        strcpy(battery->pmu_battery_name, bat_name);    
-    }
-    PARSE_UINT32_PROPERTY(node, "pmu_init_chgvol",        battery->pmu_init_chgvol,         parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_init_chgend_rate",   battery->pmu_init_chgend_rate,    parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_init_chg_enabled",   battery->pmu_init_chg_enabled,    parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_init_adc_freq",      battery->pmu_init_adc_freq,       parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_init_adc_freqc",     battery->pmu_init_adc_freqc,      parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_init_chg_pretime",   battery->pmu_init_chg_pretime,    parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_init_chg_csttime",   battery->pmu_init_chg_csttime,    parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_init_chgcur",        battery->pmu_init_chgcur,         parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_suspend_chgcur",     battery->pmu_suspend_chgcur,      parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_resume_chgcur",      battery->pmu_resume_chgcur,       parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_shutdown_chgcur",    battery->pmu_shutdown_chgcur,     parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_usbcur_limit",       battery->pmu_usbcur_limit,        parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_usbcur",             battery->pmu_usbcur,              parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_usbvol_limit",       battery->pmu_usbvol_limit,        parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_usbvol",             battery->pmu_usbvol,              parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_pwroff_vol",         battery->pmu_pwroff_vol,          parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_pwron_vol",          battery->pmu_pwron_vol,           parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_pekoff_time",        battery->pmu_pekoff_time,         parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_pekoff_en",          battery->pmu_pekoff_en,           parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_peklong_time",       battery->pmu_peklong_time,        parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_pwrok_time",         battery->pmu_pwrok_time,          parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_pwrnoe_time",        battery->pmu_pwrnoe_time,         parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_intotp_en",          battery->pmu_intotp_en,           parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_pekon_time",         battery->pmu_pekon_time,          parse_failed);
-    PARSE_UINT32_PROPERTY(node, "pmu_charge_efficiency",  battery->pmu_charge_efficiency,   parse_failed);
-    /*
-     * These 4 members are not "MUST HAVE", so if parse failed, just keep going
-     */
-    PARSE_UINT32_PROPERTY(node, "pmu_ntc_enable",         battery->pmu_ntc_enable,          parse_next1);
+	unsigned int *curve;
+	char *bat_name = NULL;
+
+	PARSE_UINT32_PROPERTY(node, "pmu_twi_id", battery->pmu_twi_id, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_irq_id", battery->pmu_irq_id, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_twi_addr", battery->pmu_twi_addr, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_battery_rdc", battery->pmu_battery_rdc, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_battery_cap", battery->pmu_battery_cap, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_battery_technology", battery->pmu_battery_technology,  parse_failed);
+	PARSE_STRING_PROPERTY(node, "pmu_battery_name", bat_name, parse_failed);
+	/*
+	* of_property_read_string only change output pointer address,
+	* so need copy string from pointed address to array.
+	*/
+	if (bat_name) {
+		strcpy(battery->pmu_battery_name, bat_name);
+	}
+	PARSE_UINT32_PROPERTY(node, "pmu_init_chgvol", battery->pmu_init_chgvol, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_init_chgend_rate", battery->pmu_init_chgend_rate, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_init_chg_enabled", battery->pmu_init_chg_enabled, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_init_adc_freq", battery->pmu_init_adc_freq, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_init_adc_freqc", battery->pmu_init_adc_freqc, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_init_chg_pretime", battery->pmu_init_chg_pretime, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_init_chg_csttime", battery->pmu_init_chg_csttime, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_init_chgcur", battery->pmu_init_chgcur, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_suspend_chgcur", battery->pmu_suspend_chgcur,parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_resume_chgcur", battery->pmu_resume_chgcur, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_shutdown_chgcur", battery->pmu_shutdown_chgcur, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_usbcur_limit", battery->pmu_usbcur_limit, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_usbcur", battery->pmu_usbcur, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_usbvol_limit", battery->pmu_usbvol_limit, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_usbvol", battery->pmu_usbvol, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_pwroff_vol", battery->pmu_pwroff_vol, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_pwron_vol", battery->pmu_pwron_vol, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_pekoff_time", battery->pmu_pekoff_time, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_pekoff_en", battery->pmu_pekoff_en, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_peklong_time", battery->pmu_peklong_time, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_pwrok_time", battery->pmu_pwrok_time, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_pwrnoe_time", battery->pmu_pwrnoe_time, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_intotp_en", battery->pmu_intotp_en, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_pekon_time", battery->pmu_pekon_time, parse_failed);
+	PARSE_UINT32_PROPERTY(node, "pmu_charge_efficiency", battery->pmu_charge_efficiency, parse_failed);
+	/*
+	* These 4 members are not "MUST HAVE", so if parse failed, just keep going
+	*/
+	PARSE_UINT32_PROPERTY(node, "pmu_ntc_enable", battery->pmu_ntc_enable, parse_next1);
 parse_next1:
-    PARSE_UINT32_PROPERTY(node, "pmu_ntc_ts_current",     battery->pmu_ntc_ts_current,      parse_next2);
+	PARSE_UINT32_PROPERTY(node, "pmu_ntc_ts_current", battery->pmu_ntc_ts_current, parse_next2);
 parse_next2:
-    PARSE_UINT32_PROPERTY(node, "pmu_ntc_lowtempvol",     battery->pmu_ntc_lowtempvol,      parse_next3);
+	PARSE_UINT32_PROPERTY(node, "pmu_ntc_lowtempvol", battery->pmu_ntc_lowtempvol, parse_next3);
 parse_next3:
-    PARSE_UINT32_PROPERTY(node, "pmu_ntc_hightempvol",    battery->pmu_ntc_hightempvol,     parse_next4);
+	PARSE_UINT32_PROPERTY(node, "pmu_ntc_hightempvol", battery->pmu_ntc_hightempvol, parse_next4);
 parse_next4:
-    curve = (unsigned int *)battery->pmu_bat_curve;
-    if (of_property_read_u32_array(node, 
-                                   "pmu_bat_curve", 
-                                   curve, 
-                                   sizeof(battery->pmu_bat_curve) / sizeof(int))) {
-        DBG("failed to read battery curve\n");
-        goto parse_failed;
-    }
-    return 0;
+	curve = (unsigned int *)battery->pmu_bat_curve;
+	if (of_property_read_u32_array(node,
+					"pmu_bat_curve",
+					curve,
+					sizeof(battery->pmu_bat_curve) / sizeof(int))) {
+		DBG("failed to read battery curve\n");
+		goto parse_failed;
+	}
+	return 0;
 
 parse_failed:
-    return -EINVAL;
+	return -EINVAL;
 }
 EXPORT_SYMBOL(parse_battery_parameters);
 
+static int board_has_batt = 0;
+void set_board_battery_status(int has)
+{
+	board_has_batt = has ? 1 : 0;
+	printk("board_has_battery:%s\n", has ? "true" : "false");
+}
+EXPORT_SYMBOL(set_board_battery_status);
+
+int board_has_battery(void)
+{
+	return board_has_batt;
+}
+EXPORT_SYMBOL(board_has_battery);
+
 static int aml_pmus_probe(struct platform_device *pdev)
 {
-    struct device_node      *pmu_node = pdev->dev.of_node;
-    struct device_node      *child;
-    struct i2c_board_info   board_info;
-    struct i2c_adapter      *adapter;
-    struct i2c_client       *client;
-    //struct property         *prop;
-    //int    val;
-    int    err;
-    int    addr;
-    int    bus_type = -1;
-    const  char *str;
-
-    for_each_child_of_node(pmu_node, child) {
-        /* register exist pmu */
-        printk("%s, child name:%s\n", __func__, child->name);
-        err = of_property_read_string(child, "i2c_bus", &str);
-        if (err) {
-            printk("%s, get 'i2c_bus' failed, ret:%d\n", __func__, err);
-            continue;
-        }
-        printk("%s, i2c_bus:%s\n", __func__, str);
-        if (!strncmp(str, "i2c_bus_ao", 10)) { 
-            bus_type = AML_I2C_BUS_AO;
-        } else if (!strncmp(str, "i2c_bus_b", 9)) {
-            bus_type = AML_I2C_BUS_B;
-        } else if (!strncmp(str, "i2c_bus_a", 9)) {
-            bus_type = AML_I2C_BUS_A;
-        } else {
-            bus_type = AML_I2C_BUS_AO; 
-        }
-        err = of_property_read_string(child, "status", &str);
-        if (err) {
-            printk("%s, get 'status' failed, ret:%d\n", __func__, err);
-            continue;
-        }
-        if (strcmp(str, "okay") && strcmp(str, "ok")) {              // status is not OK, do not probe it
-            printk("%s, device %s status is %s, stop probe it\n", __func__, child->name, str); 
-            continue;
-        }
-        err = of_property_read_u32(child, "reg", &addr);
-        if (err) {
-            printk("%s, get 'reg' failed, ret:%d\n", __func__, err);
-            continue;
-        }
-        memset(&board_info, 0, sizeof(board_info));
-        adapter = i2c_get_adapter(bus_type);
-        if (!adapter) {
-            printk("%s, wrong i2c adapter:%d\n", __func__, bus_type);
-        }
-        err = of_property_read_string(child, "compatible", &str);
-        if (err) {
-            printk("%s, get 'compatible' failed, ret:%d\n", __func__, err);
-            continue;
-        }
-        strncpy(board_info.type, str, I2C_NAME_SIZE);
-        board_info.addr = addr;
-        board_info.of_node = child;                                     // for device driver
-        client = i2c_new_device(adapter, &board_info);
-        if (!client) {
-            printk("%s, allocate i2c_client failed\n", __func__);    
-            continue;
-        }
-        printk("Allocate new i2c device: adapter:%d, addr:0x%x, node name:%s, type:%s\n", 
-               bus_type, addr, child->name, str);
-    }
-    return 0;
-}    
+	struct device_node	*pmu_node = pdev->dev.of_node;
+	struct device_node	*child;
+	struct i2c_board_info	board_info;
+	struct i2c_adapter	*adapter;
+	struct i2c_client	*client;
+	//struct property	*prop;
+	//int	val;
+	int	err;
+	int	addr;
+	int	bus_type = -1;
+	const  char *str;
+
+	for_each_child_of_node(pmu_node, child) {
+		/* register exist pmu */
+		printk("%s, child name:%s\n", __func__, child->name);
+		err = of_property_read_string(child, "i2c_bus", &str);
+		if (err) {
+			printk("%s, get 'i2c_bus' failed, ret:%d\n", __func__, err);
+			continue;
+		}
+		printk("%s, i2c_bus:%s\n", __func__, str);
+		if (!strncmp(str, "i2c_bus_ao", 10)) {
+			bus_type = AML_I2C_BUS_AO;
+		} else if (!strncmp(str, "i2c_bus_b", 9)) {
+			bus_type = AML_I2C_BUS_B;
+		} else if (!strncmp(str, "i2c_bus_a", 9)) {
+			bus_type = AML_I2C_BUS_A;
+		} else {
+			bus_type = AML_I2C_BUS_AO;
+		}
+		err = of_property_read_string(child, "status", &str);
+		if (err) {
+			printk("%s, get 'status' failed, ret:%d\n", __func__, err);
+			continue;
+		}
+		if (strcmp(str, "okay") && strcmp(str, "ok")) {		// status is not OK, do not probe it
+			printk("%s, device %s status is %s, stop probe it\n", __func__, child->name, str);
+			continue;
+		}
+		err = of_property_read_u32(child, "reg", &addr);
+		if (err) {
+			printk("%s, get 'reg' failed, ret:%d\n", __func__, err);
+			continue;
+		}
+		memset(&board_info, 0, sizeof(board_info));
+		adapter = i2c_get_adapter(bus_type);
+		if (!adapter) {
+			printk("%s, wrong i2c adapter:%d\n", __func__, bus_type);
+		}
+		err = of_property_read_string(child, "compatible", &str);
+		if (err) {
+			printk("%s, get 'compatible' failed, ret:%d\n", __func__, err);
+			continue;
+		}
+		strncpy(board_info.type, str, I2C_NAME_SIZE);
+		board_info.addr = addr;
+		board_info.of_node = child;	// for device driver
+		client = i2c_new_device(adapter, &board_info);
+		if (!client) {
+			printk("%s, allocate i2c_client failed\n", __func__);
+			continue;
+		}
+		printk("Allocate new i2c device: adapter:%d, addr:0x%x, node name:%s, type:%s\n",
+				bus_type, addr, child->name, str);
+	}
+	return 0;
+}
 
 static int aml_pmus_remove(struct platform_device *pdev)
 {
-    /* nothing to do */ 
-    return 0;
+	/* nothing to do */
+	return 0;
 }
 
 static const struct of_device_id aml_pmu_dt_match[] = {
-    {
-        .compatible = "amlogic, aml_pmu_prober",
-    },
-    {}
+	{
+		.compatible = "amlogic, aml_pmu_prober",
+	},
+	{}
 };
 
-static  struct platform_driver aml_pmu_prober = { 
-    .probe      = aml_pmus_probe,
-    .remove     = aml_pmus_remove,
-    .driver     = { 
-        .name   = "aml_pmu_prober",
-        .owner  = THIS_MODULE,
-        .of_match_table = aml_pmu_dt_match,
-    },  
+static  struct platform_driver aml_pmu_prober = {
+	.probe		= aml_pmus_probe,
+	.remove		= aml_pmus_remove,
+	.driver		= {
+		.name		= "aml_pmu_prober",
+		.owner		= THIS_MODULE,
+		.of_match_table	= aml_pmu_dt_match,
+	},
 };
 
 static int __init aml_pmu_probe_init(void)
 {
-    int ret;
-    printk("call %s in\n", __func__);
-    ret = platform_driver_register(&aml_pmu_prober);
-    return ret;
+	int ret;
+	printk("call %s in\n", __func__);
+	ret = platform_driver_register(&aml_pmu_prober);
+	return ret;
 }
 
 static void __exit aml_pmu_probe_exit(void)
 {
-    platform_driver_unregister(&aml_pmu_prober);
+	platform_driver_unregister(&aml_pmu_prober);
 }
 
 subsys_initcall(aml_pmu_probe_init);
diff --git a/drivers/amlogic/power/axp_power/axp-mfd.c b/drivers/amlogic/power/axp_power/axp-mfd.c
old mode 100755
new mode 100644
index b311075ea4aa..4bfc3b8a333b
--- a/drivers/amlogic/power/axp_power/axp-mfd.c
+++ b/drivers/amlogic/power/axp_power/axp-mfd.c
@@ -30,8 +30,8 @@
 #ifdef CONFIG_OF
 
 #ifdef CONFIG_AMLOGIC_USB
-static struct notifier_block axp20_otg_nb;                            // notifier_block for OTG issue
-static struct notifier_block axp20_usb_nb;                            // notifier_block for USB charger issue
+static struct notifier_block axp20_otg_nb;		// notifier_block for OTG issue
+static struct notifier_block axp20_usb_nb;		// notifier_block for USB charger issue
 extern int dwc_otg_power_register_notifier(struct notifier_block *nb);
 extern int dwc_otg_power_unregister_notifier(struct notifier_block *nb);
 extern int dwc_otg_charger_detect_register_notifier(struct notifier_block *nb);
@@ -45,15 +45,15 @@ extern int dwc_otg_charger_detect_unregister_notifier(struct notifier_block *nb)
  */
 /* Reverse engineered partly from Platformx drivers */
 enum axp_regls {
-    vcc_ldo1 = 0,
-    vcc_ldo2,
-    vcc_ldo3,
-    vcc_ldo4,
-    vcc_ldo5,
-
-    vcc_buck2,
-    vcc_buck3,
-    vcc_ldoio0,
+	vcc_ldo1 = 0,
+	vcc_ldo2,
+	vcc_ldo3,
+	vcc_ldo4,
+	vcc_ldo5,
+
+	vcc_buck2,
+	vcc_buck3,
+	vcc_ldoio0,
 };
 
 /* The values of the various regulator constraints are obviously dependent
@@ -65,258 +65,258 @@ enum axp_regls {
  * in an lcd on the IM2 for example!).
  */
 static struct regulator_consumer_supply ldo1_data[] = {
-    {
-        .supply = "VDD_RTC",
-    },
+	{
+		.supply = "VDD_RTC",
+	},
 };
 
 
 static struct regulator_consumer_supply ldo2_data[] = {
-    {
-        .supply = "VDDIO_AO",
-    },
+	{
+		.supply = "VDDIO_AO",
+	},
 };
 
 static struct regulator_consumer_supply ldo3_data[] = {
-    {
-        .supply = "AVDD2.5V",
-    },
+	{
+		.supply = "AVDD2.5V",
+	},
 };
 
 static struct regulator_consumer_supply ldo4_data[] = {
-    {
-        .supply = "AVDD3.0V",
-    },
+	{
+		.supply = "AVDD3.0V",
+	},
 };
 
 static struct regulator_consumer_supply ldoio0_data[] = {
-    {
-        .supply = "POWER_MISC",
-    },
+	{
+		.supply = "POWER_MISC",
+	},
 };
 
 
 static struct regulator_consumer_supply buck2_data[] = {
-    {
-        .supply = "DDR3_1.5V",
-    },
+	{
+		.supply = "DDR3_1.5V",
+	},
 };
 
 static struct regulator_consumer_supply buck3_data[] = {
-    {
-        .supply = "VDD_AO",
-    },
+	{
+		.supply = "VDD_AO",
+	},
 };
 
 static struct regulator_init_data axp_regl_init_data[] = {
-    [vcc_ldo1] = {
-        .constraints = { /* board default 1.25V */
-            .name = "axp20_ldo1",
-            .min_uV =  1300 * 1000,
-            .max_uV =  1300 * 1000,
-        },
-        .num_consumer_supplies = ARRAY_SIZE(ldo1_data),
-        .consumer_supplies = ldo1_data,
-    },
-    [vcc_ldo2] = {
-        .constraints = { /* board default 3.0V */
-            .name = "axp20_ldo2",
-            .min_uV = 1800000,
-            .max_uV = 3300000,
-            .valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
-            .initial_state = PM_SUSPEND_STANDBY,
-            .state_standby = {
-                //.uV = ldo2_vol * 1000,
-                .enabled = 1,
-            }
-        },
-        .num_consumer_supplies = ARRAY_SIZE(ldo2_data),
-        .consumer_supplies = ldo2_data,
-    },
-    [vcc_ldo3] = {
-        .constraints = {/* default is 1.8V */
-            .name = "axp20_ldo3",
-            .min_uV =  700 * 1000,
-            .max_uV =  3500* 1000,
-            .valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
-            .initial_state = PM_SUSPEND_STANDBY,
-            .state_standby = {
-                //.uV = ldo3_vol * 1000,
-                .enabled = 1,
-            }
-        },
-        .num_consumer_supplies = ARRAY_SIZE(ldo3_data),
-        .consumer_supplies = ldo3_data,
-    },
-    [vcc_ldo4] = {
-        .constraints = {
-            /* board default is 3.3V */
-            .name = "axp20_ldo4",
-            .min_uV = 1250000,
-            .max_uV = 3300000,
-            .valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
-            .initial_state = PM_SUSPEND_STANDBY,
-            .state_standby = {
-                //.uV = ldo4_vol * 1000,
-                .enabled = 1,
-            }
-        },
-        .num_consumer_supplies = ARRAY_SIZE(ldo4_data),
-        .consumer_supplies = ldo4_data,
-    },
-    [vcc_buck2] = {
-        .constraints = { /* default 1.5V */
-            .name = "axp20_buck2",
-            .min_uV = 700 * 1000,
-            .max_uV = 2275 * 1000,
-            .valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
-            .initial_state = PM_SUSPEND_STANDBY,
-            .state_standby = {
-                .uV = 1500 * 1000,  //axp_cfg.dcdc2_vol * 1000,
-                .enabled = 1,
-            }
-        },
-        .num_consumer_supplies = ARRAY_SIZE(buck2_data),
-        .consumer_supplies = buck2_data,
-    },
-    [vcc_buck3] = {
-        .constraints = { /* default 1.2V */
-            .name = "axp20_buck3",
-            .min_uV = 700 * 1000,
-            .max_uV = 3500 * 1000,
-            .valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
-            .initial_state = PM_SUSPEND_STANDBY,
-            .state_standby = {
-                .uV = 1200 * 1000,  //axp_cfg.dcdc3_vol * 1000,
-                .enabled = 1,
-            }
-        },
-        .num_consumer_supplies = ARRAY_SIZE(buck3_data),
-        .consumer_supplies = buck3_data,
-    },
-    [vcc_ldoio0] = {
-        .constraints = { /* default 2.5V */
-            .name = "axp20_ldoio0",
-            .min_uV = 1800 * 1000,
-            .max_uV = 3300 * 1000,
-            .valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
-        },
-        .num_consumer_supplies = ARRAY_SIZE(ldoio0_data),
-        .consumer_supplies = ldoio0_data,
-    },
+	[vcc_ldo1] = {
+		.constraints = { /* board default 1.25V */
+			.name = "axp20_ldo1",
+			.min_uV =  1300 * 1000,
+			.max_uV =  1300 * 1000,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo1_data),
+		.consumer_supplies = ldo1_data,
+	},
+	[vcc_ldo2] = {
+		.constraints = { /* board default 3.0V */
+			.name = "axp20_ldo2",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = ldo2_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo2_data),
+		.consumer_supplies = ldo2_data,
+	},
+	[vcc_ldo3] = {
+		.constraints = {/* default is 1.8V */
+			.name = "axp20_ldo3",
+			.min_uV =  700 * 1000,
+			.max_uV =  3500* 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = ldo3_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo3_data),
+		.consumer_supplies = ldo3_data,
+	},
+	[vcc_ldo4] = {
+		.constraints = {
+			/* board default is 3.3V */
+			.name = "axp20_ldo4",
+			.min_uV = 1250000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = ldo4_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo4_data),
+		.consumer_supplies = ldo4_data,
+	},
+	[vcc_buck2] = {
+		.constraints = { /* default 1.5V */
+			.name = "axp20_buck2",
+			.min_uV = 700 * 1000,
+			.max_uV = 2275 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				.uV = 1500 * 1000,  //axp_cfg.dcdc2_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck2_data),
+		.consumer_supplies = buck2_data,
+	},
+	[vcc_buck3] = {
+		.constraints = { /* default 1.2V */
+			.name = "axp20_buck3",
+			.min_uV = 700 * 1000,
+			.max_uV = 3500 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				.uV = 1200 * 1000,  //axp_cfg.dcdc3_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck3_data),
+		.consumer_supplies = buck3_data,
+	},
+	[vcc_ldoio0] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp20_ldoio0",
+			.min_uV = 1800 * 1000,
+			.max_uV = 3300 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldoio0_data),
+		.consumer_supplies = ldoio0_data,
+	},
 };
 
 static struct axp_funcdev_info axp_regldevs[] = {
-    {
-        .name = "axp20-regulator",
-        .id = AXP20_ID_LDO1,
-        .platform_data = &axp_regl_init_data[vcc_ldo1],
-    }, {
-        .name = "axp20-regulator",
-        .id = AXP20_ID_LDO2,
-        .platform_data = &axp_regl_init_data[vcc_ldo2],
-    }, {
-        .name = "axp20-regulator",
-        .id = AXP20_ID_LDO3,
-        .platform_data = &axp_regl_init_data[vcc_ldo3],
-    }, {
-        .name = "axp20-regulator",
-        .id = AXP20_ID_LDO4,
-        .platform_data = &axp_regl_init_data[vcc_ldo4],
-    }, {
-        .name = "axp20-regulator",
-        .id = AXP20_ID_BUCK2,
-        .platform_data = &axp_regl_init_data[vcc_buck2],
-    }, {
-        .name = "axp20-regulator",
-        .id = AXP20_ID_BUCK3,
-        .platform_data = &axp_regl_init_data[vcc_buck3],
-    }, {
-        .name = "axp20-regulator",
-        .id = AXP20_ID_LDOIO0,
-        .platform_data = &axp_regl_init_data[vcc_ldoio0],
-    },
+	{
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO1,
+		.platform_data = &axp_regl_init_data[vcc_ldo1],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO2,
+		.platform_data = &axp_regl_init_data[vcc_ldo2],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO3,
+		.platform_data = &axp_regl_init_data[vcc_ldo3],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO4,
+		.platform_data = &axp_regl_init_data[vcc_ldo4],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_BUCK2,
+		.platform_data = &axp_regl_init_data[vcc_buck2],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_BUCK3,
+		.platform_data = &axp_regl_init_data[vcc_buck3],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDOIO0,
+		.platform_data = &axp_regl_init_data[vcc_ldoio0],
+	},
 };
 
 static struct axp_supply_init_data axp_sply_init_data = {
 	/*
-	 * if you have board specific call functions, add them here
-	 */
-  //.led_control     =  led_control,
-    .soft_limit_to99 =  0,
-    .para            =  NULL,                       // para will pass to g24_pmu_call_back
+	* if you have board specific call functions, add them here
+	*/
+	//.led_control		=  led_control,
+	.soft_limit_to99 	=  0,
+	.para			=  NULL,	// para will pass to g24_pmu_call_back
 };
 
 static struct axp_funcdev_info axp_splydev[]={
-    {
-        .name = "axp20-supplyer",
+	{
+		.name = "axp20-supplyer",
 		.id = AXP20_ID_SUPPLY,
 		.platform_data = &axp_sply_init_data,
-    },
+	},
 };
 #ifdef CONFIG_SUPPORT_USB_BURNING
 static axp_gpio_cfg_t axp_init_gpio_cfg[] = {
-		{
-        .gpio = AXP_GPIO0,			//AXP202 GPIO0 ==> 3G VCC 
-        .dir = AXP_GPIO_OUTPUT,
-        .level = AXP_GPIO_HIGH,		//set AXP202 GPIO0 high
-    },
-    {
-        .gpio = AXP_GPIO1,			//AXP202 GPIO1 ==> VCCX2 
-        .dir = AXP_GPIO_OUTPUT,
-        .level = AXP_GPIO_HIGH,		//set AXP202 GPIO1 high
-    },
-    {
-        .gpio = AXP_GPIO2,			//AXP202 GPIO2 ==> HEMI2V_EN 
-        .dir = AXP_GPIO_OUTPUT,
-        .level = AXP_GPIO_LOW,		//set AXP202 GPIO2 low
-    },
-    {
-        .gpio = AXP_GPIO3,			//AXP202 GPIO3 ==> VCCX3 
-        .dir = AXP_GPIO_OUTPUT,
-        .level = AXP_GPIO_HIGH,		//set AXP202 GPIO3 high
-    },
-    AXPGPIO_CFG_END_ITEM
+	{
+		.gpio = AXP_GPIO0,		//AXP202 GPIO0 ==> 3G VCC
+		.dir = AXP_GPIO_OUTPUT,
+		.level = AXP_GPIO_HIGH,		//set AXP202 GPIO0 high
+	},
+	{
+		.gpio = AXP_GPIO1,		//AXP202 GPIO1 ==> VCCX2
+		.dir = AXP_GPIO_OUTPUT,
+		.level = AXP_GPIO_HIGH,		//set AXP202 GPIO1 high
+	},
+	{
+		.gpio = AXP_GPIO2,		//AXP202 GPIO2 ==> HEMI2V_EN
+		.dir = AXP_GPIO_OUTPUT,
+		.level = AXP_GPIO_LOW,		//set AXP202 GPIO2 low
+	},
+	{
+		.gpio = AXP_GPIO3,		//AXP202 GPIO3 ==> VCCX3
+		.dir = AXP_GPIO_OUTPUT,
+		.level = AXP_GPIO_HIGH,		//set AXP202 GPIO3 high
+	},
+	AXPGPIO_CFG_END_ITEM
 };
 #else
 static axp_gpio_cfg_t axp_init_gpio_cfg[] = {
-    {
-        .gpio = AXP_GPIO1,			//AXP202 GPIO1 ==> VCCX2 
-        .dir = AXP_GPIO_OUTPUT,
-        .level = AXP_GPIO_LOW,		//set AXP202 GPIO1 low
-    },
-    {
-        .gpio = AXP_GPIO2,			//AXP202 GPIO2 ==> HEMI2V_EN 
-        .dir = AXP_GPIO_OUTPUT,
-        .level = AXP_GPIO_LOW,		//set AXP202 GPIO2 low
-    },
-    AXPGPIO_CFG_END_ITEM
+	{
+		.gpio = AXP_GPIO1,		//AXP202 GPIO1 ==> VCCX2
+		.dir = AXP_GPIO_OUTPUT,
+		.level = AXP_GPIO_LOW,		//set AXP202 GPIO1 low
+	},
+	{
+		.gpio = AXP_GPIO2,		//AXP202 GPIO2 ==> HEMI2V_EN
+		.dir = AXP_GPIO_OUTPUT,
+		.level = AXP_GPIO_LOW,		//set AXP202 GPIO2 low
+	},
+	AXPGPIO_CFG_END_ITEM
 };
 #endif
 
 static struct axp_funcdev_info axp_gpiodev[]={
-    {   .name = "axp20-gpio",
-        .id = AXP20_ID_GPIO,
-        .platform_data = axp_init_gpio_cfg,
-    },
+	{   .name = "axp20-gpio",
+		.id = AXP20_ID_GPIO,
+		.platform_data = axp_init_gpio_cfg,
+	},
 };
 
 static struct axp_platform_data axp_pdata = {
-    .num_regl_devs = ARRAY_SIZE(axp_regldevs),
-    .num_sply_devs = ARRAY_SIZE(axp_splydev),
-    .num_gpio_devs = ARRAY_SIZE(axp_gpiodev),
-    .regl_devs = axp_regldevs,
-    .sply_devs = axp_splydev,
-    .gpio_devs = axp_gpiodev,
-    .gpio_base = 0,
+	.num_regl_devs = ARRAY_SIZE(axp_regldevs),
+	.num_sply_devs = ARRAY_SIZE(axp_splydev),
+	.num_gpio_devs = ARRAY_SIZE(axp_gpiodev),
+	.regl_devs = axp_regldevs,
+	.sply_devs = axp_splydev,
+	.gpio_devs = axp_gpiodev,
+	.gpio_base = 0,
 };
-#endif              /* CONFIG_OF */
+#endif	/* CONFIG_OF */
 
 static inline int is_ac_online(void)
 {
 	uint8_t val;
 	axp_read(&axp->dev,0x00, &val);
-	if(val & ((1<<7) | (1<<5)))
+	if (val & ((1<<7) | (1<<5)))
 	{
 		return 1;
 	}
@@ -333,17 +333,17 @@ static void axp_mfd_irq_work(struct work_struct *work)
 	uint64_t irqs = 0;
 
 	printk("[AXP]========================in irq=====================\n");
-	
+
 	while (1) {
 		if (chip->ops->read_irqs(chip, &irqs))
 			break;
 
 		printk("%s->%d:irqs = 0x%x\n",__FUNCTION__,__LINE__,(int) irqs);
-		
+
 		irqs &= chip->irqs_enabled;
-		
+
 		printk("%s->%d: chip->irqs_enabled = 0x%x\n",__FUNCTION__,__LINE__,(int) chip->irqs_enabled);
-		
+
 		if (irqs == 0)
 			break;
 
@@ -368,22 +368,22 @@ static irqreturn_t axp_mfd_irq_handler(int irq, void *data)
 
 static struct axp_mfd_chip_ops axp_mfd_ops[] = {
 	[0] = {
-		.init_chip    = axp18_init_chip,
+		.init_chip	= axp18_init_chip,
 		.enable_irqs  = axp18_enable_irqs,
 		.disable_irqs = axp18_disable_irqs,
-		.read_irqs    = axp18_read_irqs,
+		.read_irqs	= axp18_read_irqs,
 	},
 	[1] = {
-		.init_chip    = axp19_init_chip,
+		.init_chip	= axp19_init_chip,
 		.enable_irqs  = axp19_enable_irqs,
 		.disable_irqs = axp19_disable_irqs,
-		.read_irqs    = axp19_read_irqs,
+		.read_irqs	= axp19_read_irqs,
 	},
 	[2] = {
-		.init_chip    = axp20_init_chip,
+		.init_chip	= axp20_init_chip,
 		.enable_irqs  = axp20_enable_irqs,
 		.disable_irqs = axp20_disable_irqs,
-		.read_irqs    = axp20_read_irqs,
+		.read_irqs	= axp20_read_irqs,
 	},
 };
 
@@ -398,7 +398,7 @@ MODULE_DEVICE_TABLE(i2c, axp_mfd_id_table);
 int axp_mfd_create_attrs(struct axp_mfd_chip *chip)
 {
 	int j,ret;
-	if(chip->type ==  AXP19){
+	if (chip->type ==  AXP19) {
 		for (j = 0; j < ARRAY_SIZE(axp19_mfd_attrs); j++) {
 			ret = device_create_file(chip->dev,&axp19_mfd_attrs[j]);
 			if (ret)
@@ -412,7 +412,7 @@ int axp_mfd_create_attrs(struct axp_mfd_chip *chip)
 			goto sysfs_failed2;
 		}
 	}
-	else if (chip->type ==  AXP20){
+	else if (chip->type ==  AXP20) {
 		for (j = 0; j < ARRAY_SIZE(axp20_mfd_attrs); j++) {
 			ret = device_create_file(chip->dev,&axp20_mfd_attrs[j]);
 			if (ret)
@@ -471,24 +471,24 @@ static int  axp_mfd_add_subdevs(struct axp_mfd_chip *chip,
 
 	/* register for power supply */
 	for (i = 0; i < pdata->num_sply_devs; i++) {
-	    sply_dev = &pdata->sply_devs[i];
-    	pdev = platform_device_alloc(sply_dev->name, sply_dev->id);
-	    pdev->dev.parent = chip->dev;
-	    pdev->dev.platform_data = sply_dev->platform_data;
-	    ret = platform_device_add(pdev);
-	    if (ret)
-		    goto failed;
+		sply_dev = &pdata->sply_devs[i];
+		pdev = platform_device_alloc(sply_dev->name, sply_dev->id);
+		pdev->dev.parent = chip->dev;
+		pdev->dev.platform_data = sply_dev->platform_data;
+		ret = platform_device_add(pdev);
+		if (ret)
+			goto failed;
 	}
 
 	/* register for gpio */
 	for (i = 0; i < pdata->num_gpio_devs; i++) {
-        gpio_dev = &pdata->gpio_devs[i];
-        pdev = platform_device_alloc(gpio_dev->name, gpio_dev->id);
-        pdev->dev.parent = chip->dev;
-        pdev->dev.platform_data = gpio_dev->platform_data;
-        ret = platform_device_add(pdev);
-	    if (ret)
-            goto failed;
+		gpio_dev = &pdata->gpio_devs[i];
+		pdev = platform_device_alloc(gpio_dev->name, gpio_dev->id);
+		pdev->dev.parent = chip->dev;
+		pdev->dev.platform_data = gpio_dev->platform_data;
+		ret = platform_device_add(pdev);
+		if (ret)
+			goto failed;
 	}
 
 	return 0;
@@ -498,189 +498,193 @@ failed:
 	return ret;
 }
 
- void axp_power_off(void)
+void axp_power_off(void)
 {
-    printk("[axp] send power-off command!\n");
-    mdelay(20);
+	printk("[axp] send power-off command!\n");
+	mdelay(20);
 	axp_set_bits(&axp->dev, POWER20_OFF_CTL, 0x80);
-    mdelay(20);
-    printk("[axp] warning!!! axp can't power-off, maybe some error happend!\n");
+	mdelay(20);
+	printk("[axp] warning!!! axp can't power-off, maybe some error happend!\n");
 }
 EXPORT_SYMBOL_GPL(axp_power_off);
 
 #ifdef CONFIG_OF
-#define DEBUG_TREE      0
-#define DEBUG_PARSE     0
+#define DEBUG_TREE	0
+#define DEBUG_PARSE	0
 #define DBG(format, args...) printk("[AXP]%s, "format, __func__, ##args)
 
 /*
  * must make sure value is 32 bit when use this macro
  * otherwise you should use another variable to get result value
  */
-#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)        \
-    if (of_property_read_u32(node, prop_name, (u32*)(&value))) {        \
-        DBG("failed to get property: %s\n", prop_name);                 \
-        goto exception;                                                 \
-    }                                                                   \
-    if (DEBUG_PARSE) {                                                  \
-        DBG("get property:%25s, value:0x%08x, dec:%8d\n",               \
-            prop_name, value, value);                                   \
-    }
-
-#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)                \
-    if (of_property_read_string(node, prop_name, (const char **)&value)) {      \
-        DBG("failed to get property: %s\n", prop_name);                         \
-        goto exception;                                                         \
-    }                                                                           \
-    if (DEBUG_PARSE) {                                                          \
-        DBG("get property:%25s, value:%s\n",                                    \
-            prop_name, value);                                                  \
-    }
-
-#define ALLOC_DEVICES(return_pointer, size, flag)                       \
-    return_pointer = kzalloc(size, flag);                               \
-    if (!return_pointer) {                                              \
-        DBG("%d, allocate "#return_pointer" failed\n", __LINE__);       \
-        return -ENOMEM;                                                 \
-    } 
-    
+#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)		\
+	if (of_property_read_u32(node, prop_name, (u32*)(&value))) {		\
+		DBG("failed to get property: %s\n", prop_name);			\
+		goto exception;							\
+	}									\
+	if (DEBUG_PARSE) {							\
+		DBG("get property:%25s, value:0x%08x, dec:%8d\n",		\
+			prop_name, value, value);				\
+	}
+
+#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)		\
+	if (of_property_read_string(node, prop_name, (const char **)&value)) {	\
+		DBG("failed to get property: %s\n", prop_name);			\
+		goto exception;							\
+	}									\
+	if (DEBUG_PARSE) {							\
+		DBG("get property:%25s, value:%s\n",				\
+			prop_name, value);					\
+	}
+
+#define ALLOC_DEVICES(return_pointer, size, flag)				\
+	return_pointer = kzalloc(size, flag);					\
+	if (!return_pointer) {							\
+		DBG("%d, allocate "#return_pointer" failed\n", __LINE__);	\
+		return -ENOMEM;							\
+	}
+
 #if DEBUG_TREE
 char msg_buf[100];
 void scan_node_tree(struct device_node *top_node, int off)
 {
-    struct device_node *child;
-    if (!top_node) {
-        return;    
-    }
-    if (!off) {
-        printk("device tree is :\n");
-    }
-    while (top_node) {
-        memset(msg_buf, ' ', sizeof(msg_buf));
-        sprintf(msg_buf + off, "|--%s\n", top_node->name);
-        printk(msg_buf);
-        scan_node_tree(top_node->child, off + 4);
-        top_node = top_node->sibling;
-    }
+	struct device_node *child;
+	if (!top_node) {
+		return;
+	}
+	if (!off) {
+		printk("device tree is :\n");
+	}
+	while (top_node) {
+		memset(msg_buf, ' ', sizeof(msg_buf));
+		sprintf(msg_buf + off, "|--%s\n", top_node->name);
+		printk(msg_buf);
+		scan_node_tree(top_node->child, off + 4);
+		top_node = top_node->sibling;
+	}
 }
 #endif
 
 int setup_supply_data(struct device_node *node, struct axp_supply_init_data *s_data)
 {
-    struct device_node *b_node;
-    struct battery_parameter *battery;
-    phandle fhandle;
-
-    PARSE_UINT32_PROPERTY(node, "soft_limit_to99", s_data->soft_limit_to99, parse_failed);
-    PARSE_UINT32_PROPERTY(node, "board_battery",   fhandle,                 parse_failed);
-    b_node = of_find_node_by_phandle(fhandle);
-    if (!b_node) {
-        DBG("find battery node failed, current:%s\n", node->name);
-    }
-    ALLOC_DEVICES(battery, sizeof(*battery), GFP_KERNEL);
-    if (parse_battery_parameters(b_node, battery)) {
-        DBG("failed to parse battery parameter, node:%s\n", b_node->name);
-        kfree(battery);
-    } else {
-        s_data->board_battery = battery;                                // attach to axp_supply_init_data 
-    }
-    return 0;
+	struct device_node *b_node;
+	struct battery_parameter *battery;
+	phandle fhandle;
+
+	PARSE_UINT32_PROPERTY(node, "soft_limit_to99", s_data->soft_limit_to99, parse_failed);
+	if (of_property_read_u32(node, "board_battery", (u32*)(&fhandle))) {
+		set_board_battery_status(0);
+		goto parse_failed;
+	}
+	b_node = of_find_node_by_phandle(fhandle);
+	if (!b_node) {
+		DBG("find battery node failed, current:%s\n", node->name);
+	}
+	ALLOC_DEVICES(battery, sizeof(*battery), GFP_KERNEL);
+	if (parse_battery_parameters(b_node, battery)) {
+		DBG("failed to parse battery parameter, node:%s\n", b_node->name);
+		kfree(battery);
+	} else {
+		set_board_battery_status(1);
+		s_data->board_battery = battery;	// attach to axp_supply_init_data
+	}
+	return 0;
 
 parse_failed:
-    return -EINVAL;
+	return -EINVAL;
 }
 
 int setup_platform_pmu_init_data(struct device_node *node, struct axp_platform_data *pdata)
 {
-    struct axp_supply_init_data *s_data;
-    struct regulator_init_data  *buck2 = NULL, *buck3 = NULL;
-    uint32_t tmp, i;
-
-    s_data = (struct axp_supply_init_data*)pdata->sply_devs[0].platform_data;
-    for (i = 0; i < pdata->num_regl_devs; i++) {
-        if (pdata->regl_devs[i].id == AXP20_ID_BUCK2) {
-            buck2 = (struct regulator_init_data *)pdata->regl_devs[i].platform_data;
-        }
-        if (pdata->regl_devs[i].id == AXP20_ID_BUCK3) {
-            buck3 = (struct regulator_init_data *)pdata->regl_devs[i].platform_data;
-        }
-    }
-    if (setup_supply_data(node, s_data)) {
-        return  -EINVAL; 
-    }
-    /*
-     * if there are not assigned propertys of dc2/dc3 voltage, just leave them to 
-     * default value.
-     */
-    if (buck2) {
-        PARSE_UINT32_PROPERTY(node, "ddr_voltage", tmp, setup1);
-        buck2->constraints.state_standby.uV = tmp;
-    }
+	struct axp_supply_init_data *s_data;
+	struct regulator_init_data  *buck2 = NULL, *buck3 = NULL;
+	uint32_t tmp, i;
+
+	s_data = (struct axp_supply_init_data*)pdata->sply_devs[0].platform_data;
+	for (i = 0; i < pdata->num_regl_devs; i++) {
+		if (pdata->regl_devs[i].id == AXP20_ID_BUCK2) {
+			buck2 = (struct regulator_init_data *)pdata->regl_devs[i].platform_data;
+		}
+		if (pdata->regl_devs[i].id == AXP20_ID_BUCK3) {
+			buck3 = (struct regulator_init_data *)pdata->regl_devs[i].platform_data;
+		}
+	}
+	if (setup_supply_data(node, s_data)) {
+		return  -EINVAL;
+	}
+	/*
+	* if there are not assigned propertys of dc2/dc3 voltage, just leave them to
+	* default value.
+	*/
+	if (buck2) {
+		PARSE_UINT32_PROPERTY(node, "ddr_voltage", tmp, setup1);
+		buck2->constraints.state_standby.uV = tmp;
+	}
 setup1:
-    if (buck3) {
-        PARSE_UINT32_PROPERTY(node, "vddao_voltage", tmp, setup2);
-        buck3->constraints.state_standby.uV = tmp;
-    }
+	if (buck3) {
+		PARSE_UINT32_PROPERTY(node, "vddao_voltage", tmp, setup2);
+		buck3->constraints.state_standby.uV = tmp;
+	}
 setup2:
 
-    return 0;
+	return 0;
 }
 
 struct i2c_device_id *find_id_table_by_name(const struct i2c_device_id *look_table, char *name)
 {
-    while (look_table->name && look_table->name[0]) {
-        if (!strcmp(look_table->name, name)) {
-            return (struct i2c_device_id *)look_table;    
-        }
-        look_table++;
-    }
-    return NULL;
+	while (look_table->name && look_table->name[0]) {
+		if (!strcmp(look_table->name, name)) {
+			return (struct i2c_device_id *)look_table;
+		}
+		look_table++;
+	}
+	return NULL;
 }
 #endif
 
 static int  axp_mfd_probe(struct i2c_client *client,
-				  const struct i2c_device_id *id)
+				const struct i2c_device_id *id)
 {
 #ifdef CONFIG_OF
-    struct i2c_device_id *type;
-    char   *sub_type = NULL;
+	struct i2c_device_id *type;
+	char   *sub_type = NULL;
 #else
 	struct axp_platform_data *pdata = client->dev.platform_data;
 #endif
 	struct axp_mfd_chip *chip;
-    int ret = 0;
+	int ret = 0;
 
 	chip = kzalloc(sizeof(struct axp_mfd_chip), GFP_KERNEL);
 	if (chip == NULL)
 		return -ENOMEM;
 #ifdef CONFIG_OF
 #if DEBUG_TREE
-    scan_node_tree(client->dev.of_node, 0);
+	scan_node_tree(client->dev.of_node, 0);
 #endif
-    setup_platform_pmu_init_data(client->dev.of_node, &axp_pdata);
-    PARSE_STRING_PROPERTY(client->dev.of_node, "sub_type", sub_type, out_free_chip);
-    type = find_id_table_by_name(axp_mfd_id_table, sub_type);
-    if (!type) {                                                        // sub type is not supported
-        DBG("sub_type of '%s' is not match, abort\n", sub_type);
-        goto out_free_chip; 
-    }
+	setup_platform_pmu_init_data(client->dev.of_node, &axp_pdata);
+	PARSE_STRING_PROPERTY(client->dev.of_node, "sub_type", sub_type, out_free_chip);
+	type = find_id_table_by_name(axp_mfd_id_table, sub_type);
+	if (!type) {														// sub type is not supported
+		DBG("sub_type of '%s' is not match, abort\n", sub_type);
+		goto out_free_chip;
+	}
 #endif
 #ifdef CONFIG_AW_AXP20
-    if (type->driver_data == 2) {
-    #ifdef CONFIG_AMLOGIC_USB
-        axp20_otg_nb.notifier_call = axp202_otg_change;
-        axp20_usb_nb.notifier_call = axp202_usb_charger;
-        dwc_otg_power_register_notifier(&axp20_otg_nb);
-        dwc_otg_charger_detect_register_notifier(&axp20_usb_nb);
-    #endif
-    }
+	if (type->driver_data == 2) {
+	#ifdef CONFIG_AMLOGIC_USB
+		axp20_otg_nb.notifier_call = axp202_otg_change;
+		axp20_usb_nb.notifier_call = axp202_usb_charger;
+		dwc_otg_power_register_notifier(&axp20_otg_nb);
+		dwc_otg_charger_detect_register_notifier(&axp20_usb_nb);
+	#endif
+	}
 #endif
 	axp = client;
 
 	chip->client = client;
 	chip->dev = &client->dev;
 #ifdef CONFIG_OF
-    chip->ops = &axp_mfd_ops[type->driver_data];
+	chip->ops = &axp_mfd_ops[type->driver_data];
 #else
 	chip->ops = &axp_mfd_ops[id->driver_data];
 #endif
@@ -694,15 +698,15 @@ static int  axp_mfd_probe(struct i2c_client *client,
 	ret = chip->ops->init_chip(chip);
 	if (ret)
 		goto out_free_chip;
-    /*
+	/*
 	ret = request_irq(client->irq, axp_mfd_irq_handler,
-		IRQF_DISABLED, "axp_mfd", chip);
-  	if (ret) {
-  		dev_err(&client->dev, "failed to request irq %d\n",
-  				client->irq);
-  		goto out_free_chip;
-  	}
-    */
+				IRQF_DISABLED, "axp_mfd", chip);
+	if (ret) {
+		dev_err(&client->dev, "failed to request irq %d\n",
+				client->irq);
+		goto out_free_chip;
+	}
+	*/
 
 #ifdef CONFIG_OF
 	ret = axp_mfd_add_subdevs(chip, &axp_pdata);
@@ -713,11 +717,11 @@ static int  axp_mfd_probe(struct i2c_client *client,
 		goto out_free_irq;
 
 	/* PM hookup */
-	if(!pm_power_off)
+	if (!pm_power_off)
 		pm_power_off = axp_power_off;
 
 	ret = axp_mfd_create_attrs(chip);
-	if(ret){
+	if (ret) {
 		return ret;
 	}
 
@@ -748,7 +752,7 @@ static int  axp_mfd_remove(struct i2c_client *client)
 
 #ifdef CONFIG_OF
 static const struct of_device_id aml_axp_match_id = {
-    .compatible = "axp_mfd",
+	.compatible = "axp_mfd",
 };
 #endif
 
@@ -756,9 +760,9 @@ static struct i2c_driver axp_mfd_driver = {
 	.driver	= {
 		.name	= "axp_mfd",
 		.owner	= THIS_MODULE,
-    #ifdef CONFIG_OF
-        .of_match_table = &aml_axp_match_id,
-    #endif
+	#ifdef CONFIG_OF
+	.of_match_table = &aml_axp_match_id,
+	#endif
 	},
 	.probe		= axp_mfd_probe,
 	.remove		= axp_mfd_remove,
diff --git a/drivers/amlogic/power/ricoh/ricoh_pmu.c b/drivers/amlogic/power/ricoh/ricoh_pmu.c
old mode 100755
new mode 100644
index e8dd3736f138..bd463ff7a43a
--- a/drivers/amlogic/power/ricoh/ricoh_pmu.c
+++ b/drivers/amlogic/power/ricoh/ricoh_pmu.c
@@ -14,15 +14,15 @@
 #endif
 
 #ifdef CONFIG_AMLOGIC_USB
-static struct notifier_block rn5t618_otg_nb;                            // notifier_block for OTG issue
-static struct notifier_block rn5t618_usb_nb;                            // notifier_block for USB charger issue
+static struct notifier_block rn5t618_otg_nb;					// notifier_block for OTG issue
+static struct notifier_block rn5t618_usb_nb;					// notifier_block for USB charger issue
 extern int dwc_otg_power_register_notifier(struct notifier_block *nb);
 extern int dwc_otg_power_unregister_notifier(struct notifier_block *nb);
 extern int dwc_otg_charger_detect_register_notifier(struct notifier_block *nb);
 extern int dwc_otg_charger_detect_unregister_notifier(struct notifier_block *nb);
 #endif
 
-struct i2c_client *g_rn5t618_client = NULL; 
+struct i2c_client *g_rn5t618_client = NULL;
 static const struct i2c_device_id ricoh_pmu_id_table[] = {
 #ifdef CONFIG_RN5T618
 	{ "rn5t618", 0},
@@ -33,131 +33,135 @@ MODULE_DEVICE_TABLE(i2c, ricoh_pmu_id_table);
 
 static const char *ricoh_pmu_sub_driver[] = {
 #ifdef CONFIG_RN5T618
-    RN5T618_DRIVER_NAME,
+	RN5T618_DRIVER_NAME,
 #endif
 };
 
 #ifdef CONFIG_OF
-#define DEBUG_TREE      0
-#define DEBUG_PARSE     0
+#define DEBUG_TREE	0
+#define DEBUG_PARSE	0
 #define DBG(format, args...) printk("[RICOH]%s, "format, __func__, ##args)
 
 /*
  * must make sure value is 32 bit when use this macro
  * otherwise you should use another variable to get result value
  */
-#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)        \
-    if (of_property_read_u32(node, prop_name, (u32*)(&value))) {        \
-        DBG("failed to get property: %s\n", prop_name);                 \
-        goto exception;                                                 \
-    }                                                                   \
-    if (DEBUG_PARSE) {                                                  \
-        DBG("get property:%25s, value:0x%08x, dec:%8d\n",               \
-            prop_name, value, value);                                   \
-    }
-
-#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)            \
-    if (of_property_read_string(node, prop_name, (const char **)&value)) {  \
-        DBG("failed to get property: %s\n", prop_name);                     \
-        goto exception;                                                     \
-    }                                                                       \
-    if (DEBUG_PARSE) {                                                      \
-        DBG("get property:%25s, value:%s\n",                                \
-            prop_name, value);                                              \
-    }
-
-#define ALLOC_DEVICES(return_pointer, size, flag)                       \
-    return_pointer = kzalloc(size, flag);                               \
-    if (!return_pointer) {                                              \
-        DBG("%d, allocate "#return_pointer" failed\n", __LINE__);       \
-        return -ENOMEM;                                                 \
-    } 
-    
+#define PARSE_UINT32_PROPERTY(node, prop_name, value, exception)		\
+	if (of_property_read_u32(node, prop_name, (u32*)(&value))) {		\
+		DBG("failed to get property: %s\n", prop_name);			\
+		goto exception;							\
+	}									\
+	if (DEBUG_PARSE) {							\
+		DBG("get property:%25s, value:0x%08x, dec:%8d\n",		\
+			prop_name, value, value);				\
+	}
+
+#define PARSE_STRING_PROPERTY(node, prop_name, value, exception)		\
+	if (of_property_read_string(node, prop_name, (const char **)&value)) {  \
+		DBG("failed to get property: %s\n", prop_name);			\
+		goto exception;							\
+	}									\
+	if (DEBUG_PARSE) {							\
+		DBG("get property:%25s, value:%s\n",				\
+			prop_name, value);					\
+	}
+
+#define ALLOC_DEVICES(return_pointer, size, flag)				\
+	return_pointer = kzalloc(size, flag);					\
+	if (!return_pointer) {							\
+		DBG("%d, allocate "#return_pointer" failed\n", __LINE__);	\
+		return -ENOMEM;							\
+	}
+
 #if DEBUG_TREE
 char msg_buf[100];
 static void scan_node_tree(struct device_node *top_node, int off)
 {
-    if (!top_node) {
-        return;    
-    }
-    if (!off) {
-        printk("device tree is :\n");
-    }
-    while (top_node) {
-        memset(msg_buf, ' ', sizeof(msg_buf));
-        sprintf(msg_buf + off, "|--%s\n", top_node->name);
-        printk(msg_buf);
-        scan_node_tree(top_node->child, off + 4);
-        top_node = top_node->sibling;
-    }
+	if (!top_node) {
+		return;
+	}
+	if (!off) {
+		printk("device tree is :\n");
+	}
+	while (top_node) {
+		memset(msg_buf, ' ', sizeof(msg_buf));
+		sprintf(msg_buf + off, "|--%s\n", top_node->name);
+		printk(msg_buf);
+		scan_node_tree(top_node->child, off + 4);
+		top_node = top_node->sibling;
+	}
 }
 #endif
 
 static int setup_supply_data(struct device_node *node, struct ricoh_pmu_init_data *s_data)
 {
-    int err;
-    struct device_node *b_node;
-    struct battery_parameter *battery;
-    phandle fhandle;
-
-    err = of_property_read_bool(node, "reset-to-system");
-    if (err) {
-        s_data->reset_to_system = 1;    
-    }
-    PARSE_UINT32_PROPERTY(node, "soft_limit_to99", s_data->soft_limit_to99, parse_failed);
-    PARSE_UINT32_PROPERTY(node, "board_battery",   fhandle,                 parse_failed);
-    PARSE_UINT32_PROPERTY(node, "vbus_dcin_short_connect", s_data->vbus_dcin_short_connect, parse_failed);
-    b_node = of_find_node_by_phandle(fhandle);
-    if (!b_node) {
-        DBG("find battery node failed, current:%s\n", node->name);
-    }
-    ALLOC_DEVICES(battery, sizeof(*battery), GFP_KERNEL);
-    if (parse_battery_parameters(b_node, battery)) {
-        DBG("failed to parse battery parameter, node:%s\n", b_node->name);
-        kfree(battery);
-    } else {
-        s_data->board_battery = battery;                                // attach to axp_supply_init_data 
-    }
-    return 0;
+	int err;
+	struct device_node *b_node;
+	struct battery_parameter *battery;
+	phandle fhandle;
+
+	err = of_property_read_bool(node, "reset-to-system");
+	if (err) {
+		s_data->reset_to_system = 1;
+	}
+	PARSE_UINT32_PROPERTY(node, "soft_limit_to99", s_data->soft_limit_to99, parse_failed);
+	if (of_property_read_u32(node, "board_battery", (u32*)(&fhandle))) {
+		set_board_battery_status(0);
+		goto parse_failed;
+	}
+	PARSE_UINT32_PROPERTY(node, "vbus_dcin_short_connect", s_data->vbus_dcin_short_connect, parse_failed);
+	b_node = of_find_node_by_phandle(fhandle);
+	if (!b_node) {
+		DBG("find battery node failed, current:%s\n", node->name);
+	}
+	ALLOC_DEVICES(battery, sizeof(*battery), GFP_KERNEL);
+	if (parse_battery_parameters(b_node, battery)) {
+		DBG("failed to parse battery parameter, node:%s\n", b_node->name);
+		kfree(battery);
+	} else {
+		set_board_battery_status(1);
+		s_data->board_battery = battery;	// attach to axp_supply_init_data
+	}
+	return 0;
 
 parse_failed:
-    return -EINVAL;
+	return -EINVAL;
 }
 
 static int setup_platform_pmu_init_data(struct device_node *node, struct ricoh_pmu_init_data *pdata)
 {
-    if (setup_supply_data(node, pdata)) {
-        return  -EINVAL; 
-    }
-#if 0                                       // not used right now
-    /*
-     * if there are not assigned propertys of dc2/dc3 voltage, just leave them to 
-     * default value.
-     */
-    if (buck2) {
-        PARSE_UINT32_PROPERTY(node, "ddr_voltage", tmp, setup1);
-        buck2->constraints.state_standby.uV = tmp;
-    }
+	if (setup_supply_data(node, pdata)) {
+		return  -EINVAL;
+	}
+#if 0							// not used right now
+	/*
+	* if there are not assigned propertys of dc2/dc3 voltage, just leave them to
+	* default value.
+	*/
+	if (buck2) {
+		PARSE_UINT32_PROPERTY(node, "ddr_voltage", tmp, setup1);
+		buck2->constraints.state_standby.uV = tmp;
+	}
 setup1:
-    if (buck3) {
-        PARSE_UINT32_PROPERTY(node, "vddao_voltage", tmp, setup2);
-        buck3->constraints.state_standby.uV = tmp;
-    }
+	if (buck3) {
+		PARSE_UINT32_PROPERTY(node, "vddao_voltage", tmp, setup2);
+		buck3->constraints.state_standby.uV = tmp;
+	}
 setup2:
 #endif
 
-    return 0;
+	return 0;
 }
 
 static struct i2c_device_id *find_id_table_by_name(const struct i2c_device_id *look_table, char *name)
 {
-    while (look_table->name && look_table->name[0]) {
-        if (!strcmp(look_table->name, name)) {
-            return (struct i2c_device_id *)look_table;    
-        }
-        look_table++;
-    }
-    return NULL;
+	while (look_table->name && look_table->name[0]) {
+		if (!strcmp(look_table->name, name)) {
+			return (struct i2c_device_id *)look_table;
+		}
+		look_table++;
+	}
+	return NULL;
 }
 static struct ricoh_pmu_init_data *init_data;
 #endif /* CONFIG_OF */
@@ -165,143 +169,143 @@ static struct ricoh_pmu_init_data *init_data;
 #if defined(CONFIG_AML_DVFS) && defined(CONFIG_RN5T618)
 int convert_id_to_dcdc(uint32_t id)
 {
-    int dcdc = 0; 
-    switch (id) {
-    case AML_DVFS_ID_VCCK:
-        dcdc = 1;
-        break;
-
-    case AML_DVFS_ID_VDDEE:
-        dcdc = 2;
-        break;
-
-    case AML_DVFS_ID_DDR:
-        dcdc = 3;
-        break;
-
-    default:
-        break;
-    }
-    return dcdc;
+	int dcdc = 0;
+	switch (id) {
+	case AML_DVFS_ID_VCCK:
+		dcdc = 1;
+		break;
+
+	case AML_DVFS_ID_VDDEE:
+		dcdc = 2;
+		break;
+
+	case AML_DVFS_ID_DDR:
+		dcdc = 3;
+		break;
+
+	default:
+		break;
+	}
+	return dcdc;
 }
 
 static int rn5t618_set_voltage(uint32_t id, uint32_t min_uV, uint32_t max_uV)
 {
-    int dcdc = convert_id_to_dcdc(id);
-    uint32_t vol = 0;
-    
-    if (min_uV > max_uV) {
-        return -1;    
-    }
-    vol = (min_uV + max_uV) / 2;
-    if (dcdc >= 1 && dcdc <= 3) {
-        return rn5t618_set_dcdc_voltage(dcdc, vol);
-    }
-    return -EINVAL;
+	int dcdc = convert_id_to_dcdc(id);
+	uint32_t vol = 0;
+
+	if (min_uV > max_uV) {
+		return -1;
+	}
+	vol = (min_uV + max_uV) / 2;
+	if (dcdc >= 1 && dcdc <= 3) {
+		return rn5t618_set_dcdc_voltage(dcdc, vol);
+	}
+	return -EINVAL;
 }
 
 static int rn5t618_get_voltage(uint32_t id, uint32_t *uV)
 {
-    int dcdc = convert_id_to_dcdc(id);
+	int dcdc = convert_id_to_dcdc(id);
 
-    if (dcdc >= 1 && dcdc <= 3) {
-        return rn5t618_get_dcdc_voltage(dcdc, uV);    
-    }
+	if (dcdc >= 1 && dcdc <= 3) {
+		return rn5t618_get_dcdc_voltage(dcdc, uV);
+	}
 
-    return -EINVAL;
+	return -EINVAL;
 }
 
 struct aml_dvfs_driver rn5t618_dvfs_driver = {
-    .name        = "rn5t618-dvfs",
-    .id_mask     = (AML_DVFS_ID_VCCK | AML_DVFS_ID_VDDEE | AML_DVFS_ID_DDR),
-    .set_voltage = rn5t618_set_voltage, 
-    .get_voltage = rn5t618_get_voltage,
+	.name		= "rn5t618-dvfs",
+	.id_mask	= (AML_DVFS_ID_VCCK | AML_DVFS_ID_VDDEE | AML_DVFS_ID_DDR),
+	.set_voltage	= rn5t618_set_voltage,
+	.get_voltage	= rn5t618_get_voltage,
 };
 #endif
 extern struct aml_pmu_driver rn5t618_pmu_driver;
 
 static int ricoh_pmu_check_device(struct i2c_client *client)
 {
-    int ret = -1;
+	int ret = -1;
 
-    ret = i2c_smbus_read_byte(client);
-    if (ret < 0) {
-        RICOH_DBG("%s, i2c xfer failed, ret:%d\n", __func__, ret);
-    }
-    return ret;
+	ret = i2c_smbus_read_byte(client);
+	if (ret < 0) {
+		RICOH_DBG("%s, i2c xfer failed, ret:%d\n", __func__, ret);
+	}
+	return ret;
 }
 
 static int ricoh_pmu_probe(struct i2c_client *client,
-                           const struct i2c_device_id *id)
+				const struct i2c_device_id *id)
 {
 #ifdef CONFIG_OF
-    char   *sub_type = NULL;
+	char   *sub_type = NULL;
 #endif
-    struct i2c_device_id *type = NULL;
-    struct platform_device *pdev;
+	struct i2c_device_id *type = NULL;
+	struct platform_device *pdev;
 	int ret;
-    
-    ret = ricoh_pmu_check_device(client);                               // check client device first
-    if (ret < 0) {
-        return ret; 
-    }
+
+	ret = ricoh_pmu_check_device(client);		// check client device first
+	if (ret < 0) {
+		return ret;
+	}
 #ifdef CONFIG_OF
 #if DEBUG_TREE
-    scan_node_tree(client->dev.of_node, 0);
+	scan_node_tree(client->dev.of_node, 0);
 #endif
-    init_data = kzalloc(sizeof(*init_data), GFP_KERNEL);
-    if (!init_data) {
-        DBG("%s, allocate initialize data failed\n", __func__);
-        return -ENOMEM;    
-    }
-    setup_platform_pmu_init_data(client->dev.of_node, init_data);
-    PARSE_STRING_PROPERTY(client->dev.of_node, "sub_type", sub_type, out_free_chip);
-    type = find_id_table_by_name(ricoh_pmu_id_table, sub_type);
-    if (!type) {                                                        // sub type is not supported
-        DBG("sub_type of '%s' is not match, abort\n", sub_type);
-        goto out_free_chip; 
-    }
+	init_data = kzalloc(sizeof(*init_data), GFP_KERNEL);
+	if (!init_data) {
+		DBG("%s, allocate initialize data failed\n", __func__);
+		return -ENOMEM;
+	}
+	setup_platform_pmu_init_data(client->dev.of_node, init_data);
+	PARSE_STRING_PROPERTY(client->dev.of_node, "sub_type", sub_type, out_free_chip);
+	type = find_id_table_by_name(ricoh_pmu_id_table, sub_type);
+	if (!type) {														// sub type is not supported
+		DBG("sub_type of '%s' is not match, abort\n", sub_type);
+		goto out_free_chip;
+	}
 #else
-#ifdef CONFIG_RN5T618 
-    type = find_id_table_by_name(ricoh_pmu_id_table, "rn5t618");
+#ifdef CONFIG_RN5T618
+	type = find_id_table_by_name(ricoh_pmu_id_table, "rn5t618");
 #endif
 #endif /* CONFIG_OF */
 
 #ifdef CONFIG_RN5T618
-    if (type->driver_data == 0) {
-        g_rn5t618_client = client;            
-    #if defined(CONFIG_AML_DVFS) && defined(CONFIG_RN5T618)
-        aml_dvfs_register_driver(&rn5t618_dvfs_driver);
-    #endif
-        aml_pmu_register_driver(&rn5t618_pmu_driver);
-    #ifdef CONFIG_AMLOGIC_USB
-        rn5t618_otg_nb.notifier_call = rn5t618_otg_change;
-        rn5t618_usb_nb.notifier_call = rn5t618_usb_charger;
-        dwc_otg_power_register_notifier(&rn5t618_otg_nb);
-        dwc_otg_charger_detect_register_notifier(&rn5t618_usb_nb);
-    #endif
-        RICOH_DBG("%s, %d\n", __func__, __LINE__);
-        rn5t618_get_saved_coulomb();
-    }
+	if (type->driver_data == 0) {
+		g_rn5t618_client = client;
+	#if defined(CONFIG_AML_DVFS) && defined(CONFIG_RN5T618)
+		aml_dvfs_register_driver(&rn5t618_dvfs_driver);
+	#endif
+		aml_pmu_register_driver(&rn5t618_pmu_driver);
+	#ifdef CONFIG_AMLOGIC_USB
+		rn5t618_otg_nb.notifier_call = rn5t618_otg_change;
+		rn5t618_usb_nb.notifier_call = rn5t618_usb_charger;
+		dwc_otg_power_register_notifier(&rn5t618_otg_nb);
+		dwc_otg_charger_detect_register_notifier(&rn5t618_usb_nb);
+	#endif
+		RICOH_DBG("%s, %d\n", __func__, __LINE__);
+		rn5t618_get_saved_coulomb();
+	}
 #endif
-    /*
-     * allocate and regist devices, then kernel will probe drivers
-     */
-    pdev = platform_device_alloc(ricoh_pmu_sub_driver[type->driver_data], 0);
-    if (pdev == NULL) {
-        printk(">> %s, allocate platform device failed\n", __func__);
-        return -ENOMEM;
-    }
-    pdev->dev.parent        = &client->dev;
-    pdev->dev.platform_data =  init_data; 
-    ret = platform_device_add(pdev);
-    printk(KERN_DEBUG "%s, %d\n", __func__, __LINE__);
-    if (ret) {
-        printk(">> %s, add platform device failed\n", __func__);
-        platform_device_del(pdev);
-        return -EINVAL;
-    }
-    i2c_set_clientdata(client, pdev); 
+	/*
+	* allocate and regist devices, then kernel will probe drivers
+	*/
+	pdev = platform_device_alloc(ricoh_pmu_sub_driver[type->driver_data], 0);
+	if (pdev == NULL) {
+		printk(">> %s, allocate platform device failed\n", __func__);
+		return -ENOMEM;
+	}
+	pdev->dev.parent		= &client->dev;
+	pdev->dev.platform_data =  init_data;
+	ret = platform_device_add(pdev);
+	printk(KERN_DEBUG "%s, %d\n", __func__, __LINE__);
+	if (ret) {
+		printk(">> %s, add platform device failed\n", __func__);
+		platform_device_del(pdev);
+		return -EINVAL;
+	}
+	i2c_set_clientdata(client, pdev);
 
 out_free_chip:
 
@@ -310,23 +314,23 @@ out_free_chip:
 
 static int ricoh_pmu_remove(struct i2c_client *client)
 {
-    struct platform_device *pdev = i2c_get_clientdata(client);
+	struct platform_device *pdev = i2c_get_clientdata(client);
 
 #ifdef CONFIG_RN5T618
-    g_rn5t618_client = NULL;
+	g_rn5t618_client = NULL;
 #if defined(CONFIG_AML_DVFS) && defined(CONFIG_RN5T618)
-    aml_dvfs_unregister_driver(&rn5t618_dvfs_driver);
+	aml_dvfs_unregister_driver(&rn5t618_dvfs_driver);
 #endif
-    aml_pmu_clear_driver();
+	aml_pmu_clear_driver();
 #ifdef CONFIG_AMLOGIC_USB
-    dwc_otg_power_unregister_notifier(&rn5t618_otg_nb);
-    dwc_otg_charger_detect_unregister_notifier(&rn5t618_usb_nb);
+	dwc_otg_power_unregister_notifier(&rn5t618_otg_nb);
+	dwc_otg_charger_detect_unregister_notifier(&rn5t618_usb_nb);
 #endif  /* CONFIG_AMLOGIC_USB */
-#endif  /* CONFIG_RN5T618     */
+#endif  /* CONFIG_RN5T618 */
 
-    platform_device_del(pdev);
+	platform_device_del(pdev);
 #ifdef CONFIG_OF
-    kfree(init_data);
+	kfree(init_data);
 #endif
 
 	return 0;
@@ -334,7 +338,7 @@ static int ricoh_pmu_remove(struct i2c_client *client)
 
 #ifdef CONFIG_OF
 static const struct of_device_id ricoh_pmu_match_id = {
-    .compatible = "ricoh_pmu",
+	.compatible = "ricoh_pmu",
 };
 #endif
 
@@ -342,9 +346,9 @@ static struct i2c_driver ricoh_pmu_driver = {
 	.driver	= {
 		.name	= "ricoh_pmu",
 		.owner	= THIS_MODULE,
-    #ifdef CONFIG_OF
-        .of_match_table = &ricoh_pmu_match_id,
-    #endif
+	#ifdef CONFIG_OF
+		.of_match_table = &ricoh_pmu_match_id,
+	#endif
 	},
 	.probe		= ricoh_pmu_probe,
 	.remove		= ricoh_pmu_remove,
diff --git a/drivers/amlogic/rtc/Kconfig b/drivers/amlogic/rtc/Kconfig
old mode 100755
new mode 100644
index 95223996196f..e877e2601f21
--- a/drivers/amlogic/rtc/Kconfig
+++ b/drivers/amlogic/rtc/Kconfig
@@ -1,11 +1,11 @@
-# Amlogic RTC
-
-
-config AML_RTC
-    bool "RTC support"
-    default y
-    select RTC_CLASS
-    help
-      This is the Amlogic internal RTC driver
-      
-
+# Amlogic RTC
+
+
+config AML_RTC
+    bool "RTC support"
+    default y
+    select RTC_CLASS
+    help
+      This is the Amlogic internal RTC driver
+
+
diff --git a/drivers/amlogic/rtc/Makefile b/drivers/amlogic/rtc/Makefile
old mode 100755
new mode 100644
index 413545035c1b..91d9a797c86b
--- a/drivers/amlogic/rtc/Makefile
+++ b/drivers/amlogic/rtc/Makefile
@@ -1,4 +1,4 @@
-#
-#Makefile for the rtc dirver
-#
+#
+#Makefile for the rtc dirver
+#
 obj-$(CONFIG_AML_RTC)+= aml_rtc.o
\ No newline at end of file
diff --git a/drivers/amlogic/rtc/aml_rtc.c b/drivers/amlogic/rtc/aml_rtc.c
old mode 100755
new mode 100644
index 91448bfdc06e..3031fe05d173
--- a/drivers/amlogic/rtc/aml_rtc.c
+++ b/drivers/amlogic/rtc/aml_rtc.c
@@ -1,960 +1,970 @@
-/*
-* this driver is written for the internal rtc for M1
-*/
-
-#include<linux/module.h>
-#include<linux/platform_device.h>
-#include<linux/rtc.h>
-#include<linux/slab.h>
-#include<asm/delay.h>
-#include<mach/am_regs.h>
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-#include <plat/io.h>
-#endif
-
- #include <linux/of.h>
-
-int c_dbg_lvl = 0;
-#define RTC_DBG(lvl, x...) do{ if(c_dbg_lvl & lvl) printk(x);} while(0)
-#define RTC_DBG_VAL 1 << 0
-#define RTC_DBG_WR 1 << 1
-
-// Define register AO_RTC_ADDR0 bit map
-#define RTC_REG0_BIT_sclk_static     20
-#define RTC_REG0_BIT_ildo_ctrl_1      7
-#define RTC_REG0_BIT_ildo_ctrl_0      6
-#define RTC_REG0_BIT_test_mode      	5
-#define RTC_REG0_BIT_test_clk         4
-#define RTC_REG0_BIT_test_bypass    	3
-#define RTC_REG0_BIT_sdi              2
-#define RTC_REG0_BIT_sen              1
-#define RTC_REG0_BIT_sclk             0
-
-// Define register AO_RTC_ADDR1 bit map
-#define RTC_REG1_BIT_gpo_to_dig     	3
-#define RTC_REG1_BIT_gpi_to_dig      	2
-#define RTC_REG1_BIT_s_ready          1
-#define RTC_REG1_BIT_sdo              0
-
-// Define register AO_RTC_ADDR3 bit map
-#define RTC_REG3_BIT_count_always   	17
-
-// Define RTC serial protocal
-#define RTC_SER_DATA_BITS           	32
-#define RTC_SER_ADDR_BITS           	3
-
-
-#define s_ready                  			1 << RTC_REG1_BIT_s_ready  
-#define s_do                       		1 << RTC_REG1_BIT_sdo
-#define RESET_RETRY_TIMES           	3
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-#if (defined(CONFIG_MESON_TRUSTZONE) && defined(CONFIG_ARCH_MESON6))
-#include <mach/meson-secure.h>
-#define WR_RTC(addr, data)         meson_secure_reg_write(P_##addr, data)
-#define RD_RTC(addr)               meson_secure_reg_read(P_##addr)	
-#else
-#define WR_RTC(addr, data)         aml_write_reg32(P_##addr, data)
-#define RD_RTC(addr)               aml_read_reg32(P_##addr)	
-#endif
-#else
-#define WR_RTC(addr, data)         WRITE_AOBUS_REG(addr, data)
-#define RD_RTC(addr)                   READ_AOBUS_REG(addr)
-#endif
-
-#define RTC_sbus_LOW(x)             WR_RTC(AO_RTC_ADDR0, \
-                                                                      (RD_RTC(AO_RTC_ADDR0) & \
-                                                                      ~((1<<RTC_REG0_BIT_sen)|(1<<RTC_REG0_BIT_sclk)|(1<<RTC_REG0_BIT_sdi))))
-                                                                      
-#define RTC_sdi_HIGH(x)             WR_RTC(AO_RTC_ADDR0, \
-                                                                  (RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sdi) ))
-                                                                  
-#define RTC_sdi_LOW(x)               WR_RTC(AO_RTC_ADDR0, \
-                                                                   (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sdi) ))
-                                                                   
-#define RTC_sen_HIGH(x)             WR_RTC(AO_RTC_ADDR0, \
-                                                                   (RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sen) ))
-                                                                   
-#define RTC_sen_LOW(x)               WR_RTC(AO_RTC_ADDR0, \
-                                                                    (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sen) ))
-                                                                    
-#define RTC_sclk_HIGH(x)             WR_RTC(AO_RTC_ADDR0, \
-                                                                    (RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk)))
-                                                                    
-#define RTC_sclk_LOW(x)               WR_RTC(AO_RTC_ADDR0, \
-                                                                      (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk)))
-                                                                      
-#define RTC_sdo_READBIT             (RD_RTC(AO_RTC_ADDR1)&(1<<RTC_REG1_BIT_sdo))
-
-#define RTC_sclk_static_HIGH(x)   WR_RTC(AO_RTC_ADDR0, \
-                                                                      (RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk_static)))
-                                                                      
-#define RTC_sclk_static_LOW(x)      WR_RTC(AO_RTC_ADDR0, \
-                                                                        (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk_static)))
-
-#define RTC_count_always_HIGH(x)     WR_RTC(AO_RTC_ADDR3, \
-                                                                       (RD_RTC(AO_RTC_ADDR3) |(1<<RTC_REG3_BIT_count_always)))
-#define RTC_count_always_LOW(x)      WR_RTC(AO_RTC_ADDR3, \
-                                                                              (RD_RTC(AO_RTC_ADDR3) & ~(1<<RTC_REG3_BIT_count_always)))
-
-#define RTC_Sdo_READBIT                       RD_RTC(AO_RTC_ADDR1)&s_do`
-
-
-//#define RTC_SER_REG_DATA_NOTIFIER   0xb41b// Define RTC register address mapping
-
-//#define P_ISA_TIMERE                (volatile unsigned long *)0xc1109954
-
-// Define RTC register address mapping
-#define RTC_COUNTER_ADDR            0
-#define RTC_GPO_COUNTER_ADDR        1
-#define RTC_SEC_ADJUST_ADDR         2
-#define RTC_UNUSED_ADDR_0           3
-#define RTC_REGMEM_ADDR_0           4
-#define RTC_REGMEM_ADDR_1           5
-#define RTC_REGMEM_ADDR_2           6
-#define RTC_REGMEM_ADDR_3           7
-
-static int  check_osc_clk(void);
-
-int get_rtc_status(void)
-{
-	static int rtc_fail = -1;
-	//if (rtc_fail < 0) {
-		if (check_osc_clk() < 0) {
-			printk("rtc clock error\n");
-			rtc_fail = 1;
-		} else
-			rtc_fail = 0;
-	//}
-	return rtc_fail;
-}
-static DEFINE_SPINLOCK(com_lock);
-
-struct aml_rtc_priv{
-	struct 				rtc_device *rtc;
-  unsigned long base_addr;
-	struct timer_list timer;
-	struct work_struct work;
-	struct workqueue_struct *rtc_work_queue;
-};
-
-static void reset_gpo_work(struct work_struct *work);
-static int get_gpo_flag(void);
-
-static void delay_us(int us)
-{
-	udelay(us);
-}
-
-static void rtc_comm_delay(void)
-{        
-	delay_us(5);
-}
-
-static void rtc_sclk_pulse(void)
-{
-	//unsigned flags;
-	
-	//local_irq_save(flags);
-
-	rtc_comm_delay();
-	RTC_sclk_HIGH(1);
-	rtc_comm_delay();
-	RTC_sclk_LOW(0);
-
-	//local_irq_restore(flags);
-}
-
-#if 1
-static int  check_osc_clk(void)
-{
-	unsigned long   osc_clk_count1; 
-	unsigned long   osc_clk_count2; 
-
-	// Enable count always
-	WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3) | (1 << 17));       
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- check os clk_1\n");
-	/* Wait for 50uS.  32.768khz is 30.5uS.  This should be long  
-	   enough for one full cycle of 32.768 khz                  
-	*/
-	osc_clk_count1 = RD_RTC(AO_RTC_ADDR2);     
-			
-	RTC_DBG(RTC_DBG_VAL, "the aml_rtc os clk 1 is %d\n", 
-				(unsigned int)osc_clk_count1);									
-	delay_us( 50 );   
-	osc_clk_count2 = RD_RTC(AO_RTC_ADDR2);    
-	RTC_DBG(RTC_DBG_VAL, "the aml_rtc os clk 2 is %d\n", 
-				(unsigned int)osc_clk_count2);
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- check os clk_2\n");
-	// disable count always  
-	WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3) & ~(1 << 17));    
-
-	if( osc_clk_count1 == osc_clk_count2 ) { 
-		RTC_DBG(RTC_DBG_VAL, "The osc_clk is not running now!"
-	       			" need to invcrease the power!\n");
-		return(-1); 
-	}
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc : check_os_clk\n");
-	   
-	return(0);
-
-}
-#endif
-void rtc_ser_static_write_auto (unsigned long static_reg_data_in)
-{
-    unsigned long data32;
-    
-    // Program MSB 15-8
-    data32  = (static_reg_data_in >> 8) & 0xff;
-    //WRITE_AOBUS_REG(AO_RTC_ADDR4,data32);
-	WR_RTC(AO_RTC_ADDR4, data32);
-
-    // Program LSB 7-0, and start serializing
-    //data32  = READ_AOBUS_REG(AO_RTC_ADDR0);
-    data32  = RD_RTC(AO_RTC_ADDR0);
-    data32 |= 1                           << 17; // auto_serialize_start 
-    data32 &= ~(0xff << 24);
-    data32 |= (static_reg_data_in & 0xff) << 24; // auto_static_reg
-    //WRITE_AOBUS_REG(AO_RTC_ADDR0,data32);
-    WR_RTC(AO_RTC_ADDR0,data32);
-    // Poll auto_serializer_busy bit until it's low (IDLE)
-    //while ((READ_AOBUS_REG(AO_RTC_ADDR0)) & 1<<22) {}
-    while ((RD_RTC(AO_RTC_ADDR0)) & 1<<22) {}
-}
-
-
-static void rtc_reset_s_ready(void)
-{
-	//RTC_RESET_BIT_HIGH(1);
-	delay_us(100);
-	return;
-}
-
-static int rtc_wait_s_ready(void)
-{
-	int i = 40000;
-	int try_cnt = 0;
-	if (get_rtc_status())
-		return i;
-	/*
-	while (i--){
-		if((*(volatile unsigned *)AO_RTC_ADDR1)&s_ready)
-			break;
-		}
-	return i;
-	*/
-	while (!(RD_RTC(AO_RTC_ADDR1)&s_ready)) {
-		i--;
-		if(i == 0){
-			if(try_cnt > RESET_RETRY_TIMES){
-				break;
-			}
-			rtc_reset_s_ready();
-			try_cnt++;
-			i = 40000;
-		}
-	}
-	
-	return i;
-}
-
-
-static int rtc_comm_init(void)
-{
-	RTC_sbus_LOW(0);
-	if(rtc_wait_s_ready()>0){
-		RTC_sen_HIGH(1);
-		return 0;
-	}
-	return -1;
-}
-
-
-static void rtc_send_bit(unsigned val)
-{
-	if (val)
-		RTC_sdi_HIGH(1);
-	else
-		RTC_sdi_LOW(0);
-	rtc_sclk_pulse();
-}
-
-static void rtc_send_addr_data(unsigned type, unsigned val)
-{
-	unsigned cursor = (type? (1<<(RTC_SER_ADDR_BITS-1))
-					 : (1<<(RTC_SER_DATA_BITS-1)));
-		
-	while(cursor) {
-		rtc_send_bit(val&cursor);
-		cursor >>= 1;
-	}
-}
-
-static void rtc_get_data(unsigned *val)
-{
-	int i;
-	RTC_DBG(RTC_DBG_VAL, "rtc-aml -- rtc get data \n");
-	for (i=0; i<RTC_SER_DATA_BITS; i++) {
-		rtc_sclk_pulse();
-		*val <<= 1;
-		*val  |= RTC_sdo_READBIT;
-	}
-}
-
-static void rtc_set_mode(unsigned mode)
-{
-	RTC_sen_LOW(0);
-	if (mode)
-		RTC_sdi_HIGH (1);//WRITE
-	else
-		RTC_sdi_LOW(0);  //READ
-		rtc_sclk_pulse();
-		RTC_sdi_LOW(0);
-}
-
-static void static_register_write(unsigned data);
-static void	 _ser_access_write_locked(unsigned long addr, unsigned long data);
-static void aml_rtc_reset(void)
-{
-    if (get_rtc_status())
-        return;
-	printk("error, the rtc serial communication abnormal,"
-		" reset the rtc!\n");
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	WRITE_AOBUS_REG(AO_RTI_GEN_CNTL_REG0, 
-			READ_AOBUS_REG(AO_RTI_GEN_CNTL_REG0)|1<<21);
-	udelay(5);
-	WRITE_AOBUS_REG(AO_RTI_GEN_CNTL_REG0, 
-			READ_AOBUS_REG(AO_RTI_GEN_CNTL_REG0)&(~(1<<21)));
-	static_register_write(0x180a);
-	_ser_access_write_locked(RTC_GPO_COUNTER_ADDR,0x500000);
-#else
-	WRITE_CBUS_REG(RESET3_REGISTER, 0x1<<3);
-#endif
-}
-
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-extern int run_arc_program_rtc(void);
-extern int stop_ao_cpu(void);
-#endif
-
-static unsigned int _ser_access_read_locked(unsigned long addr)
-{
-	unsigned val = 0;
-	int s_nrdy_cnt = 0;
-	int rst_times = 0;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	int ret = 0;
-#endif
-	if (get_rtc_status())
-		return 0;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	ret = stop_ao_cpu();
-#endif
-	while(rtc_comm_init()<0){
-		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- rtc_common_init fail\n");
-		if(s_nrdy_cnt>RESET_RETRY_TIMES) {
-			s_nrdy_cnt = 0;
-			rst_times++;
-			if (rst_times > 3) {
-				printk("_ser_access_read_locked error\n");
-				goto out;
-			}
-			aml_rtc_reset();
-		}
-		rtc_reset_s_ready( );
-		s_nrdy_cnt++;
-	}
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- ser_access_read_3\n");
-	rtc_send_addr_data(1,addr);
-	rtc_set_mode(0); //Read
-	rtc_get_data(&val);
-out:
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	if (ret >= 0)
-		run_arc_program_rtc();
-#endif
-	return val;
-}
-
-static void _ser_access_write_locked(unsigned long addr, unsigned long data)
-{
-	int s_nrdy_cnt = 0;
-	int rst_times = 0;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	int ret = 0;
-#endif
-	if (get_rtc_status())
-		return;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	ret = stop_ao_cpu();
-#endif
-	while(rtc_comm_init()<0){
-		
-		if(s_nrdy_cnt>RESET_RETRY_TIMES) {
-			s_nrdy_cnt = 0;
-			rst_times++;
-			if (rst_times > 3) {
-				printk("_ser_access_write_locked error\n");
-				goto out;
-			}
-			aml_rtc_reset();
-			printk("error: rtc serial communication abnormal!\n");
-			//return -1;
-		}
-		rtc_reset_s_ready( );
-		s_nrdy_cnt++;
-	}
-	rtc_send_addr_data(0,data);
-	rtc_send_addr_data(1,addr);
-	rtc_set_mode(1); //Write
-out:
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	if (ret >= 0)
-		run_arc_program_rtc();
-#endif
-	return;
-}
-
-static unsigned int ser_access_read(unsigned long addr)
-{
-	unsigned val = 0;
-	unsigned long flags;
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc --ser_access_read_1\n");
-	/*if(check_osc_clk() < 0){
-		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- the osc clk does not work\n");
-		return val;
-	}*/
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- ser_access_read_2\n");
-	spin_lock_irqsave(&com_lock, flags);
-	val = _ser_access_read_locked(addr);
-	spin_unlock_irqrestore(&com_lock, flags);
-
-	return val;
-}
-
-static int ser_access_write(unsigned long addr, unsigned long data)
-{
-	unsigned long flags;
-	
-	spin_lock_irqsave(&com_lock, flags);
-	_ser_access_write_locked(addr, data);
-	spin_unlock_irqrestore(&com_lock, flags);
-	rtc_wait_s_ready();
-
-	return 0;
-}
-
-/***************************************************************************/
-int rtc_reset_gpo(struct device *dev, unsigned level)
-{
-	unsigned data = 0;
-	data |= 1<<20;
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	if(level){
-		data |= 1<<22;         //gpo pin level high
-		}
-#else
-	//reset mode
-	if(!level){
-		data |= 1<<22;         //gpo pin level high
-	}
-#endif	
-	
-	ser_access_write(RTC_GPO_COUNTER_ADDR, data);
-	rtc_wait_s_ready();
-	
-	return 0;
-}
-
-typedef struct alarm_data_s {
-	int level;
-	unsigned alarm_sec;   //in s
-} alarm_data_t;
-
-/*
- * Return RTC_GPO_COUNTER bit-24 value.
- */
-int aml_rtc_alarm_status(void)
-{
-	u32 data32 = ser_access_read(RTC_GPO_COUNTER_ADDR);
-	RTC_DBG(RTC_DBG_VAL, "%s() RTC_GPO_COUNTER=%x\n", __func__, data32);
-	return (data32 & (1 << 24));
-}
-
-//set the rtc alarm
-//after alarm_data->alarm_sec, the gpo lvl will be //alarm_data->level 
-int rtc_set_alarm_aml(struct device *dev, alarm_data_t *alarm_data) {
-	unsigned data = 0;
-	//reset the gpo level
-	
-	rtc_reset_gpo(dev, !(alarm_data->level));
-
-	data |= 2 << 20;    //output defined level after time
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	data |= (alarm_data->level & 1) << 22;    //
-#else
-	data |= (!(alarm_data->level & 1)) << 22;    //
-#endif
-	if(alarm_data->alarm_sec >= 1024*1024){
-		return -1;
-	}
-
-	data |= alarm_data->alarm_sec - 1;
-	
-	printk("write alarm data: %u\n", data);
-	ser_access_write(RTC_GPO_COUNTER_ADDR, data);
-	rtc_wait_s_ready();
-	rtc_comm_delay();
-
-	data = ser_access_read(RTC_GPO_COUNTER_ADDR);
-
-	printk("read alarm data: %u\n", data);
-	printk("read alarm count: %u\n", ser_access_read(RTC_COUNTER_ADDR));
-
-	return 0;
-}
-
-/*************************************************************************/
-
-
-// -----------------------------------------------------------------------------
-//                    Function: rtc_ser_static_write_manual
-// Use part of the serial bus: sclk_static, sdi and sen to shift
-// in a 16-bit static data. Manual mode.
-// -----------------------------------------------------------------------------
-//static void rtc_ser_static_write_manual (unsigned int static_reg_data_in)
-//{    
-//	int i;        
-//       RTC_DBG(RTC_DBG_VAL, "rtc_ser_static_write_manual: data=0x%0/x\n",
-//				 static_reg_data_in);   
-//
-//	// Initialize: sen low for 1 clock cycle   
-//	RTC_sen_LOW(0);    
-//	RTC_sclk_static_LOW(0);    
-//	RTC_sclk_static_HIGH(1);    
-//	RTC_sen_HIGH(1);    
-//	RTC_sclk_static_LOW(0);   
-//	  
-//        // Shift in 16-bit known sequence    
-//	 for (i = 15; i >= 0; i --) {    
-//	 	
-//	     if ((RTC_SER_REG_DATA_NOTIFIER >> i) & 0x1) {            
-//		   RTC_sdi_HIGH(1);        
-//	     }
-//		 else {            
-//		   RTC_sdi_LOW(0);        
-//	     }     
-//			
-//	    RTC_sclk_static_HIGH(1);        
-//	    RTC_sclk_static_LOW(0);   
-//	 }    
-//	 
-//	  // 1 clock cycle turn around    
-//	  RTC_sdi_LOW(0);    
-//	  RTC_sclk_static_HIGH(1);    
-//	  RTC_sclk_static_LOW(0);  
-//	  
-//	  // Shift in 16-bit static register data    
-//	  for (i = 15; i >= 0; i --) {       
-//	  	if ((static_reg_data_in >> i) & 0x1) {            
-//		    RTC_sdi_HIGH(1);        
-//		} 
-//		else {            
-//		    RTC_sdi_LOW(0);        
-//		}        
-//		RTC_sclk_static_HIGH(1);        
-//		RTC_sclk_static_LOW(0);    
-//	   }    
-//	  
-//	  // One more clock cycle to complete write    
-//	  RTC_sen_LOW(0);    
-//	  RTC_sdi_LOW(0);    
-//	  RTC_sclk_static_HIGH(1);    
-//	  RTC_sclk_static_LOW(0);
-//} 
-
-
-static void static_register_write(unsigned data)
-{
-	rtc_ser_static_write_auto(data);	
-}
-
-static int aml_rtc_read_time(struct device *dev, struct rtc_time *tm)
-{
-	unsigned int time_t;
-	
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc: read rtc time\n");
-	time_t = ser_access_read(RTC_COUNTER_ADDR);
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc: have read the rtc time,"
-			" time is %d\n", time_t);
-	if ((int)time_t < 0) {
-		RTC_DBG(RTC_DBG_VAL, "aml_rtc: time(%d) < 0,"
-				" reset to 0", time_t);
-		time_t = 0;
-	}   
-	rtc_time_to_tm(time_t, tm);
-	
-	return 0;
-}
-
-static int aml_rtc_write_time(struct device *dev, struct rtc_time *tm)
-{
-      unsigned long time_t;
-
-      rtc_tm_to_time(tm, &time_t);
-     
-      RTC_DBG(RTC_DBG_VAL, "aml_rtc : write the rtc time, "
-      			"time is %ld\n", time_t);
-      ser_access_write(RTC_COUNTER_ADDR, time_t);
-      RTC_DBG(RTC_DBG_VAL, "aml_rtc : the time has been written\n");
-
-      return 0;
-}
-
-static int aml_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
-{
-	alarm_data_t alarm_data;
-	unsigned long alarm_secs, cur_secs;
-	struct rtc_time cur_time;
-	int ret;
-	struct aml_rtc_priv *priv;
-
-	priv = dev_get_drvdata(dev);
-	//rtc_tm_to_time(&alarm->time, &secs);
-	
-	if (alarm->enabled) {
-		alarm_data.level = 0;
-		ret = rtc_tm_to_time(&alarm->time, &alarm_secs);
-		if (ret)
-			return ret;
-		aml_rtc_read_time(dev, &cur_time);
-		ret = rtc_tm_to_time(&cur_time, &cur_secs);
-		if(alarm_secs >= cur_secs) {
-			/*3 seconds later then we real wanted, 
-			  we do not need the alarm very acurate.*/
-			alarm_data.alarm_sec = alarm_secs - cur_secs + 3; 
-		} else
-			alarm_data.alarm_sec =  0;
-
-		rtc_set_alarm_aml(dev, &alarm_data);
-	} else {
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else	
-    	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif    	
-		queue_work(priv->rtc_work_queue, &priv->work);
-	}
-	return 0;
-}
-
-#define AUTO_RESUME_INTERVAL 8
-static int aml_rtc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-#ifdef CONFIG_MESON_SUSPEND_TEST
-	alarm_data_t alarm_data;
-	static int suspend_time = 0;
-	alarm_data.alarm_sec = AUTO_RESUME_INTERVAL;
-        alarm_data.level = 0;
-	rtc_set_alarm_aml(&pdev->dev, &alarm_data);
-	printk("suspend %d times, system will up %ds later!\n", 
-			++suspend_time, alarm_data.alarm_sec);
-#endif /* CONFIG_MESON_SUSPEND_TEST */
-	return 0;
-}
-int aml_rtc_resume(struct platform_device *pdev)
-{	
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else		
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif						
-	
-	printk("resume reset gpo !\n");
-	return 0;
-}
-
-static char *rtc_reg[8]={
-	"RTC_COUNTER    ",
-	"RTC_GPO_COUNTER",
-	"RTC_SEC_ADJUST ",
-	"UNUSED         ",
-	"RTC_REGMEM_0   ",
-	"RTC_REGMEM_1   ",
-	"RTC_REGMEM_2   ",
-	"RTC_REGMEM_3   "
-};
-						
-static ssize_t show_rtc_reg(struct class *class, 
-			struct class_attribute *attr,	char *buf)
-{
-	int i;
-	
-	printk("enter function: %s \n",__FUNCTION__);
-		
-	for (i = 0; i < 8; i++) {
-		printk(" %20s : 0x%x \n",rtc_reg[i],ser_access_read(i));
-	}
-	
-	return 0;
-}
-
-static const struct rtc_class_ops aml_rtc_ops ={
-	.read_time = aml_rtc_read_time,
-	.set_time = aml_rtc_write_time,
-	.set_alarm = aml_rtc_set_alarm,
-};
-
-static struct class_attribute rtc_class_attrs[] = {
-	__ATTR(rtc_reg_log, S_IRUGO | S_IWUSR, show_rtc_reg, NULL),
-	__ATTR_NULL
-};
-
-static struct class aml_rtc_class = {
-	.name = "aml_rtc",
-	.class_attrs = rtc_class_attrs,
-};
-
-
-#ifdef CONFIG_SECURITYKEY
-extern int get_aml_key_kernel(const char* key_name, unsigned char* data, int ascii_flag);
-extern int extenal_api_key_set_version(char *devvesion);
-#endif
-
-static int aml_rtc_probe(struct platform_device *pdev)
-{
-	struct aml_rtc_priv *priv;
-	struct device_node* aml_rtc_node = pdev->dev.of_node;
-	int ret;
-	int sec_adjust = 0;
-
-#ifdef CONFIG_SECURITYKEY
-	static char keyexamples[4096];
-#endif
-#ifdef CONFIG_SECURITYKEY
-	ret = extenal_api_key_set_version("auto3");
-	if(ret >=0){
-		ret = get_aml_key_kernel("keyexample", keyexamples, 1);
-		if(ret >= 0){
-			printk("key name:keyexample, key data:%s\n",keyexamples);
-		}
-		else{
-			printk("get keyexample fail, %s:%d\n",__func__,__LINE__);
-		}
-	}
-#endif
-
-	priv = (struct aml_rtc_priv *)kzalloc(sizeof(*priv), GFP_KERNEL);
-
-	if(!priv)
-		return -ENOMEM;
-
-	INIT_WORK(&priv->work, reset_gpo_work);
-	platform_set_drvdata(pdev, priv);
-
-	priv->rtc_work_queue = create_singlethread_workqueue("rtc");
-	if (priv->rtc_work_queue == NULL) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	
-	/* platform setup code should have handled this; sigh */
-	if (!device_can_wakeup(&pdev->dev))
-		device_init_wakeup(&pdev->dev, 1);
-
-	priv->rtc = rtc_device_register("aml_rtc", &pdev->dev, &
-						aml_rtc_ops, THIS_MODULE);
-
-	if(IS_ERR(priv->rtc)){
-		ret = PTR_ERR(priv->rtc);
-		goto out;
-	}
-
-	//ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-	//static_register_write(0x0004);
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
-	ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else
-	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif	
-	rtc_wait_s_ready();
-	
-	ret = of_property_read_u32(aml_rtc_node, "sec_adjust", &sec_adjust);
-	if (!ret) {
-		ser_access_write(RTC_SEC_ADJUST_ADDR, 1<<23 | 10<<19 | 1735 );
-		rtc_wait_s_ready();
-	} 
-
-	//check_osc_clk();
-	//ser_access_write(RTC_COUNTER_ADDR, 0);
-	ret = class_register(&aml_rtc_class);
-	if(ret){
-		printk(" class register nand_class fail!\n");
-	}	
-	
-	return 0;
-
-out:
-	if(priv->rtc_work_queue)
-		destroy_workqueue(priv->rtc_work_queue);
-	kfree(priv);
-	return ret;
-}
-
-static int get_gpo_flag(void)
-{
-	u32 data32 = 0;
-	int ret = 0;
-
-	data32 = ser_access_read(RTC_GPO_COUNTER_ADDR);
-	
-	RTC_DBG(RTC_DBG_VAL, "%s() RTC_GPO_COUNTER=%x\n", __func__, data32);
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
-	ret = !(data32 & (1 << 24));
-#else
-    ret = !!(data32 & (1 << 24));
-#endif
-	
-	return ret;
-}
-
-unsigned int aml_read_rtc_mem_reg(unsigned char reg_id)
-{
-	unsigned char reg_array[] = {
-		RTC_REGMEM_ADDR_0,
-		RTC_REGMEM_ADDR_1,
-		RTC_REGMEM_ADDR_2,
-		RTC_REGMEM_ADDR_3,
-	};
-	if (reg_id > 4)
-		return 0;
-	return  ser_access_read(reg_array[reg_id]);
-}
-EXPORT_SYMBOL(aml_read_rtc_mem_reg);
-
-int aml_write_rtc_mem_reg(unsigned char reg_id, unsigned int data)
-{
-	unsigned char reg_array[] = {
-		RTC_REGMEM_ADDR_0,
-		RTC_REGMEM_ADDR_1,
-		RTC_REGMEM_ADDR_2,
-		RTC_REGMEM_ADDR_3,
-	};
-	if (reg_id > 4)
-		return 0;
-	return  ser_access_write(reg_array[reg_id], data);
-}
-EXPORT_SYMBOL(aml_write_rtc_mem_reg);
-
-unsigned int aml_get_rtc_counter(void)
-{
-    unsigned int val;
-    val = ser_access_read(RTC_COUNTER_ADDR);
-    return val;
-}
-EXPORT_SYMBOL(aml_get_rtc_counter);
-
-static void reset_gpo_work(struct work_struct *work)
-{
-	int count = 5;
-	
-	while (get_gpo_flag()) {
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else		
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif						
-		count--;
-		if(count <= 0) {
-			printk("error: can not reset gpo !\n");
-			//count = 5;
-			return;
-			//panic("gpo can not be reset");
-		}
-	}
-	
-	printk("reset gpo !\n");
-
-}
-#if 0
-static int power_down_gpo(unsigned long data)
-{
-	struct aml_rtc_priv *priv = (struct aml_rtc_priv *)data;
-	queue_work(priv->rtc_work_queue, &priv->work);
-	
-	return 0;
-}
-#endif
-static void aml_rtc_shutdown(struct platform_device *pdev)
-{
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
-	ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else	
-	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif    
-//    return 0;
-}
-
-static int aml_rtc_remove(struct platform_device *dev)
-{
-	struct aml_rtc_priv *priv = platform_get_drvdata(dev);
-	rtc_device_unregister(priv->rtc);
-	if (priv->rtc_work_queue)
-		destroy_workqueue(priv->rtc_work_queue);
-	del_timer(&priv->timer);
-	kfree(priv);
-	return 0;
-}
-
-//#ifdef CONFIG_OF
-static const struct of_device_id meson6_rtc_dt_match[]={
-	{ .compatible = "amlogic,aml_rtc"},
-	{},
-};
-/*#else
-#define meson6_rtc_dt_match NULL
-#endif*/
-
-struct platform_driver aml_rtc_driver = {
-	.driver = {
-		.name = "aml_rtc",
-		.owner = THIS_MODULE,
-		.of_match_table=meson6_rtc_dt_match,
-	},
-	.probe = aml_rtc_probe,
-//	.remove = __devexit_p(aml_rtc_remove),
-	.remove = (aml_rtc_remove),
-	.suspend = aml_rtc_suspend,
-	.resume=aml_rtc_resume,
-	.shutdown = aml_rtc_shutdown,
-};
-
-static int  __init aml_rtc_init(void)
-{
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	static_register_write(0x180a);
-#else	
-	static_register_write(0x3c0a);
-#endif
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc --aml_rtc_init\n");
-	return platform_driver_register(&aml_rtc_driver);
-}
-
-static void __init aml_rtc_exit(void)
-{
-       return platform_driver_unregister(&aml_rtc_driver);
-}
-
-module_init(aml_rtc_init);
-module_exit(aml_rtc_exit);
-
-MODULE_DESCRIPTION("Amlogic internal rtc driver");
-MODULE_LICENSE("GPL");
+/*
+* this driver is written for the internal rtc for M1
+*/
+
+#include<linux/module.h>
+#include<linux/platform_device.h>
+#include<linux/rtc.h>
+#include<linux/slab.h>
+#include<asm/delay.h>
+#include<mach/am_regs.h>
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#include <plat/io.h>
+#endif
+
+ #include <linux/of.h>
+
+int c_dbg_lvl = 0;
+#define RTC_DBG(lvl, x...) do{ if (c_dbg_lvl & lvl) printk(x);} while (0)
+#define RTC_DBG_VAL 1 << 0
+#define RTC_DBG_WR 1 << 1
+
+// Define register AO_RTC_ADDR0 bit map
+#define RTC_REG0_BIT_sclk_static	20
+#define RTC_REG0_BIT_ildo_ctrl_1	7
+#define RTC_REG0_BIT_ildo_ctrl_0	6
+#define RTC_REG0_BIT_test_mode		5
+#define RTC_REG0_BIT_test_clk		4
+#define RTC_REG0_BIT_test_bypass	3
+#define RTC_REG0_BIT_sdi		2
+#define RTC_REG0_BIT_sen		1
+#define RTC_REG0_BIT_sclk		0
+
+// Define register AO_RTC_ADDR1 bit map
+#define RTC_REG1_BIT_gpo_to_dig		3
+#define RTC_REG1_BIT_gpi_to_dig		2
+#define RTC_REG1_BIT_s_ready		1
+#define RTC_REG1_BIT_sdo		0
+
+// Define register AO_RTC_ADDR3 bit map
+#define RTC_REG3_BIT_count_always	17
+
+// Define RTC serial protocal
+#define RTC_SER_DATA_BITS		32
+#define RTC_SER_ADDR_BITS		3
+
+
+#define s_ready				1 << RTC_REG1_BIT_s_ready
+#define s_do				1 << RTC_REG1_BIT_sdo
+#define RESET_RETRY_TIMES		3
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#if (defined(CONFIG_MESON_TRUSTZONE) && defined(CONFIG_ARCH_MESON6))
+#include <mach/meson-secure.h>
+#define WR_RTC(addr, data)		meson_secure_reg_write(P_##addr, data)
+#define RD_RTC(addr)			meson_secure_reg_read(P_##addr)
+#else
+#define WR_RTC(addr, data)		aml_write_reg32(P_##addr, data)
+#define RD_RTC(addr)			aml_read_reg32(P_##addr)
+#endif
+#else
+#define WR_RTC(addr, data)		WRITE_AOBUS_REG(addr, data)
+#define RD_RTC(addr)			READ_AOBUS_REG(addr)
+#endif
+
+#define RTC_sbus_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
+					(RD_RTC(AO_RTC_ADDR0) & \
+					~((1<<RTC_REG0_BIT_sen)|(1<<RTC_REG0_BIT_sclk)|(1<<RTC_REG0_BIT_sdi))))
+
+#define RTC_sdi_HIGH(x)			WR_RTC(AO_RTC_ADDR0, \
+					(RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sdi) ))
+
+#define RTC_sdi_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
+					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sdi) ))
+
+#define RTC_sen_HIGH(x)			WR_RTC(AO_RTC_ADDR0, \
+					(RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sen) ))
+
+#define RTC_sen_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
+					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sen) ))
+
+#define RTC_sclk_HIGH(x)		WR_RTC(AO_RTC_ADDR0, \
+					(RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk)))
+
+#define RTC_sclk_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
+					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk)))
+
+#define RTC_sdo_READBIT			(RD_RTC(AO_RTC_ADDR1)&(1<<RTC_REG1_BIT_sdo))
+
+#define RTC_sclk_static_HIGH(x)		WR_RTC(AO_RTC_ADDR0, \
+					(RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk_static)))
+
+#define RTC_sclk_static_LOW(x)		WR_RTC(AO_RTC_ADDR0, \
+					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk_static)))
+
+#define RTC_count_always_HIGH(x)	WR_RTC(AO_RTC_ADDR3, \
+					(RD_RTC(AO_RTC_ADDR3) |(1<<RTC_REG3_BIT_count_always)))
+#define RTC_count_always_LOW(x)		WR_RTC(AO_RTC_ADDR3, \
+					(RD_RTC(AO_RTC_ADDR3) & ~(1<<RTC_REG3_BIT_count_always)))
+
+#define RTC_Sdo_READBIT			RD_RTC(AO_RTC_ADDR1)&s_do`
+
+
+//#define RTC_SER_REG_DATA_NOTIFIER   0xb41b// Define RTC register address mapping
+
+//#define P_ISA_TIMERE			(volatile unsigned long *)0xc1109954
+
+// Define RTC register address mapping
+#define RTC_COUNTER_ADDR		0
+#define RTC_GPO_COUNTER_ADDR		1
+#define RTC_SEC_ADJUST_ADDR		2
+#define RTC_UNUSED_ADDR_0		3
+#define RTC_REGMEM_ADDR_0		4
+#define RTC_REGMEM_ADDR_1		5
+#define RTC_REGMEM_ADDR_2		6
+#define RTC_REGMEM_ADDR_3		7
+
+static int  check_osc_clk(void);
+
+int get_rtc_status(void)
+{
+	static int rtc_fail = -1;
+	//if (rtc_fail < 0) {
+		if (check_osc_clk() < 0) {
+			printk("rtc clock error\n");
+			rtc_fail = 1;
+		} else
+			rtc_fail = 0;
+	//}
+	return rtc_fail;
+}
+static DEFINE_SPINLOCK(com_lock);
+
+struct aml_rtc_priv{
+	struct 				rtc_device *rtc;
+  unsigned long base_addr;
+	struct timer_list timer;
+	struct work_struct work;
+	struct workqueue_struct *rtc_work_queue;
+};
+
+static void reset_gpo_work(struct work_struct *work);
+static int get_gpo_flag(void);
+
+static void delay_us(int us)
+{
+	udelay(us);
+}
+
+static void rtc_comm_delay(void)
+{
+	delay_us(5);
+}
+
+static void rtc_sclk_pulse(void)
+{
+	//unsigned flags;
+
+	//local_irq_save(flags);
+
+	rtc_comm_delay();
+	RTC_sclk_HIGH(1);
+	rtc_comm_delay();
+	RTC_sclk_LOW(0);
+
+	//local_irq_restore(flags);
+}
+
+#if 1
+static int  check_osc_clk(void)
+{
+	unsigned long   osc_clk_count1;
+	unsigned long   osc_clk_count2;
+
+	// Enable count always
+	WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3) | (1 << 17));
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- check os clk_1\n");
+	/* Wait for 50uS.  32.768khz is 30.5uS.  This should be long
+	   enough for one full cycle of 32.768 khz
+	*/
+	osc_clk_count1 = RD_RTC(AO_RTC_ADDR2);
+
+	RTC_DBG(RTC_DBG_VAL, "the aml_rtc os clk 1 is %d\n",
+				(unsigned int)osc_clk_count1);
+	delay_us( 50 );
+	osc_clk_count2 = RD_RTC(AO_RTC_ADDR2);
+	RTC_DBG(RTC_DBG_VAL, "the aml_rtc os clk 2 is %d\n",
+				(unsigned int)osc_clk_count2);
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- check os clk_2\n");
+	// disable count always
+	WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3) & ~(1 << 17));
+
+	if ( osc_clk_count1 == osc_clk_count2 ) {
+		RTC_DBG(RTC_DBG_VAL, "The osc_clk is not running now!"
+				" need to invcrease the power!\n");
+		return(-1);
+	}
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc : check_os_clk\n");
+
+	return(0);
+
+}
+#endif
+void rtc_ser_static_write_auto (unsigned long static_reg_data_in)
+{
+	unsigned long data32;
+
+	// Program MSB 15-8
+	data32  = (static_reg_data_in >> 8) & 0xff;
+	//WRITE_AOBUS_REG(AO_RTC_ADDR4,data32);
+	WR_RTC(AO_RTC_ADDR4, data32);
+
+	// Program LSB 7-0, and start serializing
+	//data32  = READ_AOBUS_REG(AO_RTC_ADDR0);
+	data32  = RD_RTC(AO_RTC_ADDR0);
+	data32 |= 1 << 17; // auto_serialize_start
+	data32 &= ~(0xff << 24);
+	data32 |= (static_reg_data_in & 0xff) << 24; // auto_static_reg
+	//WRITE_AOBUS_REG(AO_RTC_ADDR0,data32);
+	WR_RTC(AO_RTC_ADDR0,data32);
+	// Poll auto_serializer_busy bit until it's low (IDLE)
+	//while ((READ_AOBUS_REG(AO_RTC_ADDR0)) & 1<<22) {}
+	while ((RD_RTC(AO_RTC_ADDR0)) & 1<<22) {}
+}
+
+
+static void rtc_reset_s_ready(void)
+{
+	//RTC_RESET_BIT_HIGH(1);
+	delay_us(100);
+	return;
+}
+
+static int rtc_wait_s_ready(void)
+{
+	int i = 40000;
+	int try_cnt = 0;
+	if (get_rtc_status())
+		return i;
+	/*
+	while (i--) {
+		if ((*(volatile unsigned *)AO_RTC_ADDR1)&s_ready)
+			break;
+		}
+	return i;
+	*/
+	while (!(RD_RTC(AO_RTC_ADDR1)&s_ready)) {
+		i--;
+		if (i == 0) {
+			if (try_cnt > RESET_RETRY_TIMES) {
+				break;
+			}
+			rtc_reset_s_ready();
+			try_cnt++;
+			i = 40000;
+		}
+	}
+
+	return i;
+}
+
+
+static int rtc_comm_init(void)
+{
+	RTC_sbus_LOW(0);
+	if (rtc_wait_s_ready()>0) {
+		RTC_sen_HIGH(1);
+		return 0;
+	}
+	return -1;
+}
+
+
+static void rtc_send_bit(unsigned val)
+{
+	if (val)
+		RTC_sdi_HIGH(1);
+	else
+		RTC_sdi_LOW(0);
+	rtc_sclk_pulse();
+}
+
+static void rtc_send_addr_data(unsigned type, unsigned val)
+{
+	unsigned cursor = (type? (1<<(RTC_SER_ADDR_BITS-1))
+				: (1<<(RTC_SER_DATA_BITS-1)));
+
+	while (cursor) {
+		rtc_send_bit(val&cursor);
+		cursor >>= 1;
+	}
+}
+
+static void rtc_get_data(unsigned *val)
+{
+	int i;
+	RTC_DBG(RTC_DBG_VAL, "rtc-aml -- rtc get data \n");
+	for (i=0; i<RTC_SER_DATA_BITS; i++) {
+		rtc_sclk_pulse();
+		*val <<= 1;
+		*val  |= RTC_sdo_READBIT;
+	}
+}
+
+static void rtc_set_mode(unsigned mode)
+{
+	RTC_sen_LOW(0);
+	if (mode)
+		RTC_sdi_HIGH (1);//WRITE
+	else
+		RTC_sdi_LOW(0);  //READ
+		rtc_sclk_pulse();
+		RTC_sdi_LOW(0);
+}
+
+static void static_register_write(unsigned data);
+static void _ser_access_write_locked(unsigned long addr, unsigned long data);
+static void aml_rtc_reset(void)
+{
+	if (get_rtc_status())
+		return;
+	printk("error, the rtc serial communication abnormal,"
+		" reset the rtc!\n");
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	WRITE_AOBUS_REG(AO_RTI_GEN_CNTL_REG0,
+			READ_AOBUS_REG(AO_RTI_GEN_CNTL_REG0)|1<<21);
+	udelay(5);
+	WRITE_AOBUS_REG(AO_RTI_GEN_CNTL_REG0,
+			READ_AOBUS_REG(AO_RTI_GEN_CNTL_REG0)&(~(1<<21)));
+	static_register_write(0x180a);
+	_ser_access_write_locked(RTC_GPO_COUNTER_ADDR,0x500000);
+#else
+	WRITE_CBUS_REG(RESET3_REGISTER, 0x1<<3);
+#endif
+}
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+extern int run_arc_program_rtc(void);
+extern int stop_ao_cpu(void);
+#endif
+
+static unsigned int _ser_access_read_locked(unsigned long addr)
+{
+	unsigned val = 0;
+	int s_nrdy_cnt = 0;
+	int rst_times = 0;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	int ret = 0;
+#endif
+	if (get_rtc_status())
+		return 0;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	ret = stop_ao_cpu();
+#endif
+	while (rtc_comm_init()<0) {
+		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- rtc_common_init fail\n");
+		if (s_nrdy_cnt>RESET_RETRY_TIMES) {
+			s_nrdy_cnt = 0;
+			rst_times++;
+			if (rst_times > 3) {
+				printk("_ser_access_read_locked error\n");
+				goto out;
+			}
+			aml_rtc_reset();
+		}
+		rtc_reset_s_ready( );
+		s_nrdy_cnt++;
+	}
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- ser_access_read_3\n");
+	rtc_send_addr_data(1,addr);
+	rtc_set_mode(0); //Read
+	rtc_get_data(&val);
+out:
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	if (ret >= 0)
+		run_arc_program_rtc();
+#endif
+	return val;
+}
+
+static void _ser_access_write_locked(unsigned long addr, unsigned long data)
+{
+	int s_nrdy_cnt = 0;
+	int rst_times = 0;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	int ret = 0;
+#endif
+	if (get_rtc_status())
+		return;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	ret = stop_ao_cpu();
+#endif
+	while (rtc_comm_init()<0) {
+
+		if (s_nrdy_cnt>RESET_RETRY_TIMES) {
+			s_nrdy_cnt = 0;
+			rst_times++;
+			if (rst_times > 3) {
+				printk("_ser_access_write_locked error\n");
+				goto out;
+			}
+			aml_rtc_reset();
+			printk("error: rtc serial communication abnormal!\n");
+			//return -1;
+		}
+		rtc_reset_s_ready( );
+		s_nrdy_cnt++;
+	}
+	rtc_send_addr_data(0,data);
+	rtc_send_addr_data(1,addr);
+	rtc_set_mode(1); //Write
+out:
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	if (ret >= 0)
+		run_arc_program_rtc();
+#endif
+	return;
+}
+
+static unsigned int ser_access_read(unsigned long addr)
+{
+	unsigned val = 0;
+	unsigned long flags;
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc --ser_access_read_1\n");
+	/*if (check_osc_clk() < 0) {
+		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- the osc clk does not work\n");
+		return val;
+	}*/
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- ser_access_read_2\n");
+	spin_lock_irqsave(&com_lock, flags);
+	val = _ser_access_read_locked(addr);
+	spin_unlock_irqrestore(&com_lock, flags);
+
+	return val;
+}
+
+static int ser_access_write(unsigned long addr, unsigned long data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&com_lock, flags);
+	_ser_access_write_locked(addr, data);
+	spin_unlock_irqrestore(&com_lock, flags);
+	rtc_wait_s_ready();
+
+	return 0;
+}
+
+/***************************************************************************/
+int rtc_reset_gpo(struct device *dev, unsigned level)
+{
+	unsigned data = 0;
+	data |= 1<<20;
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	if (level) {
+		data |= 1<<22;	//gpo pin level high
+		}
+#else
+	//reset mode
+	if (!level) {
+		data |= 1<<22;	//gpo pin level high
+	}
+#endif
+
+	ser_access_write(RTC_GPO_COUNTER_ADDR, data);
+	rtc_wait_s_ready();
+
+	return 0;
+}
+
+typedef struct alarm_data_s {
+	int level;
+	unsigned alarm_sec;   //in s
+} alarm_data_t;
+
+/*
+ * Return RTC_GPO_COUNTER bit-24 value.
+ */
+int aml_rtc_alarm_status(void)
+{
+	u32 data32 = ser_access_read(RTC_GPO_COUNTER_ADDR);
+	RTC_DBG(RTC_DBG_VAL, "%s() RTC_GPO_COUNTER=%x\n", __func__, data32);
+	return (data32 & (1 << 24));
+}
+
+//set the rtc alarm
+//after alarm_data->alarm_sec, the gpo lvl will be //alarm_data->level
+int rtc_set_alarm_aml(struct device *dev, alarm_data_t *alarm_data) {
+	unsigned data = 0;
+	//reset the gpo level
+
+	rtc_reset_gpo(dev, !(alarm_data->level));
+
+	data |= 2 << 20;	//output defined level after time
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	data |= (alarm_data->level & 1) << 22;	//
+#else
+	data |= (!(alarm_data->level & 1)) << 22;	//
+#endif
+	if (alarm_data->alarm_sec >= 1024*1024) {
+		return -1;
+	}
+
+	data |= alarm_data->alarm_sec - 1;
+
+	printk("write alarm data: %u\n", data);
+	ser_access_write(RTC_GPO_COUNTER_ADDR, data);
+	rtc_wait_s_ready();
+	rtc_comm_delay();
+
+	data = ser_access_read(RTC_GPO_COUNTER_ADDR);
+
+	printk("read alarm data: %u\n", data);
+	printk("read alarm count: %u\n", ser_access_read(RTC_COUNTER_ADDR));
+
+	return 0;
+}
+
+/*************************************************************************/
+
+
+// -----------------------------------------------------------------------------
+//					Function: rtc_ser_static_write_manual
+// Use part of the serial bus: sclk_static, sdi and sen to shift
+// in a 16-bit static data. Manual mode.
+// -----------------------------------------------------------------------------
+//static void rtc_ser_static_write_manual (unsigned int static_reg_data_in)
+//{
+//	int i;
+//	RTC_DBG(RTC_DBG_VAL, "rtc_ser_static_write_manual: data=0x%0/x\n",
+//		static_reg_data_in);
+//
+//	// Initialize: sen low for 1 clock cycle
+//	RTC_sen_LOW(0);
+//	RTC_sclk_static_LOW(0);
+//	RTC_sclk_static_HIGH(1);
+//	RTC_sen_HIGH(1);
+//	RTC_sclk_static_LOW(0);
+//
+//		// Shift in 16-bit known sequence
+//	for (i = 15; i >= 0; i --) {
+//
+//		if ((RTC_SER_REG_DATA_NOTIFIER >> i) & 0x1) {
+//			RTC_sdi_HIGH(1);
+//		}
+//		else {
+//			RTC_sdi_LOW(0);
+//		}
+//
+//		RTC_sclk_static_HIGH(1);
+//		RTC_sclk_static_LOW(0);
+//	}
+//
+//	// 1 clock cycle turn around
+//	RTC_sdi_LOW(0);
+//	RTC_sclk_static_HIGH(1);
+//	RTC_sclk_static_LOW(0);
+//
+//	// Shift in 16-bit static register data
+//	for (i = 15; i >= 0; i --) {
+//		if ((static_reg_data_in >> i) & 0x1) {
+//			RTC_sdi_HIGH(1);
+//		}
+//		else {
+//			RTC_sdi_LOW(0);
+//		}
+//		RTC_sclk_static_HIGH(1);
+//		RTC_sclk_static_LOW(0);
+//	}
+//
+//	// One more clock cycle to complete write
+//	RTC_sen_LOW(0);
+//	RTC_sdi_LOW(0);
+//	RTC_sclk_static_HIGH(1);
+//	RTC_sclk_static_LOW(0);
+//}
+
+
+static void static_register_write(unsigned data)
+{
+	rtc_ser_static_write_auto(data);
+}
+
+static int aml_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned int time_t;
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc: read rtc time\n");
+	time_t = ser_access_read(RTC_COUNTER_ADDR);
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc: have read the rtc time,"
+			" time is %d\n", time_t);
+	if ((int)time_t < 0) {
+		RTC_DBG(RTC_DBG_VAL, "aml_rtc: time(%d) < 0,"
+				" reset to 0", time_t);
+		time_t = 0;
+	}
+	rtc_time_to_tm(time_t, tm);
+
+	return 0;
+}
+
+static int aml_rtc_write_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long time_t;
+
+	rtc_tm_to_time(tm, &time_t);
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc : write the rtc time, "
+		"time is %ld\n", time_t);
+	ser_access_write(RTC_COUNTER_ADDR, time_t);
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc : the time has been written\n");
+
+	return 0;
+}
+
+static int aml_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	alarm_data_t alarm_data;
+	unsigned long alarm_secs, cur_secs;
+	struct rtc_time cur_time;
+	int ret;
+	struct aml_rtc_priv *priv;
+
+	priv = dev_get_drvdata(dev);
+	//rtc_tm_to_time(&alarm->time, &secs);
+
+	if (alarm->enabled) {
+		alarm_data.level = 0;
+		ret = rtc_tm_to_time(&alarm->time, &alarm_secs);
+		if (ret)
+			return ret;
+		aml_rtc_read_time(dev, &cur_time);
+		ret = rtc_tm_to_time(&cur_time, &cur_secs);
+		if (alarm_secs >= cur_secs) {
+			/*3 seconds later then we real wanted,
+			  we do not need the alarm very acurate.*/
+			alarm_data.alarm_sec = alarm_secs - cur_secs + 3;
+		} else
+			alarm_data.alarm_sec =  0;
+
+		rtc_set_alarm_aml(dev, &alarm_data);
+	} else {
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif
+		queue_work(priv->rtc_work_queue, &priv->work);
+	}
+	return 0;
+}
+
+#define AUTO_RESUME_INTERVAL 8
+static int aml_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+#ifdef CONFIG_MESON_SUSPEND_TEST
+	alarm_data_t alarm_data;
+	static int suspend_time = 0;
+	alarm_data.alarm_sec = AUTO_RESUME_INTERVAL;
+		alarm_data.level = 0;
+	rtc_set_alarm_aml(&pdev->dev, &alarm_data);
+	printk("suspend %d times, system will up %ds later!\n",
+			++suspend_time, alarm_data.alarm_sec);
+#endif /* CONFIG_MESON_SUSPEND_TEST */
+	return 0;
+}
+int aml_rtc_resume(struct platform_device *pdev)
+{
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif
+
+	printk("resume reset gpo !\n");
+	return 0;
+}
+
+static char *rtc_reg[8]={
+	"RTC_COUNTER	",
+	"RTC_GPO_COUNTER",
+	"RTC_SEC_ADJUST ",
+	"UNUSED		 ",
+	"RTC_REGMEM_0   ",
+	"RTC_REGMEM_1   ",
+	"RTC_REGMEM_2   ",
+	"RTC_REGMEM_3   "
+};
+
+static ssize_t show_rtc_reg(struct class *class,
+			struct class_attribute *attr,	char *buf)
+{
+	int i;
+
+	printk("enter function: %s \n",__FUNCTION__);
+
+	for (i = 0; i < 8; i++) {
+		printk(" %20s : 0x%x \n",rtc_reg[i],ser_access_read(i));
+	}
+
+	return 0;
+}
+
+static const struct rtc_class_ops aml_rtc_ops ={
+	.read_time = aml_rtc_read_time,
+	.set_time = aml_rtc_write_time,
+	.set_alarm = aml_rtc_set_alarm,
+};
+
+static struct class_attribute rtc_class_attrs[] = {
+	__ATTR(rtc_reg_log, S_IRUGO | S_IWUSR, show_rtc_reg, NULL),
+	__ATTR_NULL
+};
+
+static struct class aml_rtc_class = {
+	.name = "aml_rtc",
+	.class_attrs = rtc_class_attrs,
+};
+
+
+#ifdef CONFIG_SECURITYKEY
+extern int get_aml_key_kernel(const char* key_name, unsigned char* data, int ascii_flag);
+extern int extenal_api_key_set_version(char *devvesion);
+#endif
+
+#define RTC_INIT_MARSK	0x13208d83
+extern unsigned int aml_read_rtc_mem_reg(unsigned char reg_id);
+extern int aml_write_rtc_mem_reg(unsigned char reg_id, unsigned int data);
+extern int board_has_battery(void);
+
+static int aml_rtc_probe(struct platform_device *pdev)
+{
+	struct aml_rtc_priv *priv;
+	struct device_node* aml_rtc_node = pdev->dev.of_node;
+	int ret;
+	int sec_adjust = 0;
+
+#ifdef CONFIG_SECURITYKEY
+	static char keyexamples[4096];
+#endif
+#ifdef CONFIG_SECURITYKEY
+	ret = extenal_api_key_set_version("auto3");
+	if (ret >=0) {
+		ret = get_aml_key_kernel("keyexample", keyexamples, 1);
+		if (ret >= 0) {
+			printk("key name:keyexample, key data:%s\n",keyexamples);
+		}
+		else{
+			printk("get keyexample fail, %s:%d\n",__func__,__LINE__);
+		}
+	}
+#endif
+
+	priv = (struct aml_rtc_priv *)kzalloc(sizeof(*priv), GFP_KERNEL);
+
+	if (!priv)
+		return -ENOMEM;
+
+	INIT_WORK(&priv->work, reset_gpo_work);
+	platform_set_drvdata(pdev, priv);
+
+	priv->rtc_work_queue = create_singlethread_workqueue("rtc");
+	if (priv->rtc_work_queue == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* platform setup code should have handled this; sigh */
+	if (!device_can_wakeup(&pdev->dev))
+		device_init_wakeup(&pdev->dev, 1);
+
+	priv->rtc = rtc_device_register("aml_rtc", &pdev->dev, &
+						aml_rtc_ops, THIS_MODULE);
+
+	if (IS_ERR(priv->rtc)) {
+		ret = PTR_ERR(priv->rtc);
+		goto out;
+	}
+
+	//ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+	//static_register_write(0x0004);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else
+	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif
+	rtc_wait_s_ready();
+
+	ret = of_property_read_u32(aml_rtc_node, "sec_adjust", &sec_adjust);
+	if (!ret) {
+		ser_access_write(RTC_SEC_ADJUST_ADDR, 1<<23 | 10<<19 | 1735 );
+		rtc_wait_s_ready();
+	}
+
+	//check_osc_clk();
+	if (!board_has_battery() &&
+		RTC_INIT_MARSK != aml_read_rtc_mem_reg(3)) {
+		ser_access_write(RTC_COUNTER_ADDR, 0);
+		aml_write_rtc_mem_reg(3, RTC_INIT_MARSK);
+	}
+
+	ret = class_register(&aml_rtc_class);
+	if (ret) {
+		printk(" class register nand_class fail!\n");
+	}
+
+	return 0;
+
+out:
+	if (priv->rtc_work_queue)
+		destroy_workqueue(priv->rtc_work_queue);
+	kfree(priv);
+	return ret;
+}
+
+static int get_gpo_flag(void)
+{
+	u32 data32 = 0;
+	int ret = 0;
+
+	data32 = ser_access_read(RTC_GPO_COUNTER_ADDR);
+
+	RTC_DBG(RTC_DBG_VAL, "%s() RTC_GPO_COUNTER=%x\n", __func__, data32);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	ret = !(data32 & (1 << 24));
+#else
+	ret = !!(data32 & (1 << 24));
+#endif
+
+	return ret;
+}
+
+unsigned int aml_read_rtc_mem_reg(unsigned char reg_id)
+{
+	unsigned char reg_array[] = {
+		RTC_REGMEM_ADDR_0,
+		RTC_REGMEM_ADDR_1,
+		RTC_REGMEM_ADDR_2,
+		RTC_REGMEM_ADDR_3,
+	};
+	if (reg_id > 4)
+		return 0;
+	return  ser_access_read(reg_array[reg_id]);
+}
+EXPORT_SYMBOL(aml_read_rtc_mem_reg);
+
+int aml_write_rtc_mem_reg(unsigned char reg_id, unsigned int data)
+{
+	unsigned char reg_array[] = {
+		RTC_REGMEM_ADDR_0,
+		RTC_REGMEM_ADDR_1,
+		RTC_REGMEM_ADDR_2,
+		RTC_REGMEM_ADDR_3,
+	};
+	if (reg_id > 4)
+		return 0;
+	return  ser_access_write(reg_array[reg_id], data);
+}
+EXPORT_SYMBOL(aml_write_rtc_mem_reg);
+
+unsigned int aml_get_rtc_counter(void)
+{
+	unsigned int val;
+	val = ser_access_read(RTC_COUNTER_ADDR);
+	return val;
+}
+EXPORT_SYMBOL(aml_get_rtc_counter);
+
+static void reset_gpo_work(struct work_struct *work)
+{
+	int count = 5;
+
+	while (get_gpo_flag()) {
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif
+		count--;
+		if (count <= 0) {
+			printk("error: can not reset gpo !\n");
+			//count = 5;
+			return;
+			//panic("gpo can not be reset");
+		}
+	}
+
+	printk("reset gpo !\n");
+
+}
+#if 0
+static int power_down_gpo(unsigned long data)
+{
+	struct aml_rtc_priv *priv = (struct aml_rtc_priv *)data;
+	queue_work(priv->rtc_work_queue, &priv->work);
+
+	return 0;
+}
+#endif
+static void aml_rtc_shutdown(struct platform_device *pdev)
+{
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else
+	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif
+//	return 0;
+}
+
+static int aml_rtc_remove(struct platform_device *dev)
+{
+	struct aml_rtc_priv *priv = platform_get_drvdata(dev);
+	rtc_device_unregister(priv->rtc);
+	if (priv->rtc_work_queue)
+		destroy_workqueue(priv->rtc_work_queue);
+	del_timer(&priv->timer);
+	kfree(priv);
+	return 0;
+}
+
+//#ifdef CONFIG_OF
+static const struct of_device_id meson6_rtc_dt_match[]={
+	{ .compatible = "amlogic,aml_rtc"},
+	{},
+};
+/*#else
+#define meson6_rtc_dt_match NULL
+#endif*/
+
+struct platform_driver aml_rtc_driver = {
+	.driver = {
+		.name = "aml_rtc",
+		.owner = THIS_MODULE,
+		.of_match_table=meson6_rtc_dt_match,
+	},
+	.probe = aml_rtc_probe,
+//	.remove = __devexit_p(aml_rtc_remove),
+	.remove = (aml_rtc_remove),
+	.suspend = aml_rtc_suspend,
+	.resume=aml_rtc_resume,
+	.shutdown = aml_rtc_shutdown,
+};
+
+static int  __init aml_rtc_init(void)
+{
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	static_register_write(0x180a);
+#else
+	static_register_write(0x3c0a);
+#endif
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc --aml_rtc_init\n");
+	return platform_driver_register(&aml_rtc_driver);
+}
+
+static void __init aml_rtc_exit(void)
+{
+	return platform_driver_unregister(&aml_rtc_driver);
+}
+
+module_init(aml_rtc_init);
+module_exit(aml_rtc_exit);
+
+MODULE_DESCRIPTION("Amlogic internal rtc driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/amlogic/aml_pmu_common.h b/include/linux/amlogic/aml_pmu_common.h
old mode 100755
new mode 100644
index 764f5bfd8429..91240fdbefe4
--- a/include/linux/amlogic/aml_pmu_common.h
+++ b/include/linux/amlogic/aml_pmu_common.h
@@ -96,6 +96,8 @@ extern struct aml_pmu_api *aml_pmu_get_api(void);
 extern void   aml_pmu_clear_driver(void);
 extern void   aml_pmu_do_callbacks(struct aml_charger *charger);
 extern struct aml_pmu_driver* aml_pmu_get_driver(void);
+extern void   set_board_battery_status(int);
+extern int    board_has_battery(void);
 
 extern struct aml_pmu_api *aml_pmu_get_api(void);
 #endif /* __AML_PMU_COMMON_H__ */
-- 
2.19.0

