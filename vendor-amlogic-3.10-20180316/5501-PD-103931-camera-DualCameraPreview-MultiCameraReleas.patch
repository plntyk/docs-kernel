From 20f0d8df34fb409f9d802d4d555863f4f931744c Mon Sep 17 00:00:00 2001
From: Guosong Zhou <guosong.zhou@amlogic.com>
Date: Tue, 17 Mar 2015 14:14:21 +0800
Subject: [PATCH 5501/5965] PD#103931: camera: DualCameraPreview,
 MultiCameraRelease cts problem

Change-Id: If7cf20efd14e674de6de96969982ffb55cb7491b
Signed-off-by: Guosong Zhou <guosong.zhou@amlogic.com>
---
 drivers/amlogic/camera/common/vm.c | 2931 +++++++++---------
 drivers/amlogic/camera/sp0838.c    | 3437 +++++++++++----------
 drivers/amlogic/camera/sp2518.c    | 4543 +++++++++++++++-------------
 include/linux/amlogic/vmapi.h      |   33 +-
 4 files changed, 5737 insertions(+), 5207 deletions(-)

diff --git a/drivers/amlogic/camera/common/vm.c b/drivers/amlogic/camera/common/vm.c
index f757451c0df6..46326d0a3145 100755
--- a/drivers/amlogic/camera/common/vm.c
+++ b/drivers/amlogic/camera/common/vm.c
@@ -45,15 +45,15 @@
 #include <media/videobuf-dma-sg.h>
 #include <media/videobuf-res.h>
 
-#include <linux/amlogic/vmapi.h>
+#include <linux/amlogic/vmapi.h>
 #include <linux/amlogic/tvin/tvin_v4l2.h>
 #include <linux/ctype.h>
 #include <linux/of.h>
-
-#include <linux/sizes.h>
-#include <linux/dma-mapping.h>
+
+#include <linux/sizes.h>
+#include <linux/dma-mapping.h>
 #include <linux/of_fdt.h>
-#include <linux/dma-contiguous.h>
+#include <linux/dma-contiguous.h>
 
 /*class property info.*/
 #include "vmcls.h"
@@ -81,16 +81,20 @@ static int VM_CANVAS_ID = 24;
 #endif
 
 static vm_device_t  vm_device;
-static int vm_skip_count = 0 ; //deprecated
-#if 0
-new interface please refer to http://wiki-china.amlogic.com/%E5%86%85%E9%83%A8%E4%B
-A%BA%E5%91%98%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D
-%97%E5%BC%80%E5%8F%91/Camera/tvin_parm_description
-#endif
-
+static int vm_skip_count = 0 ; //deprecated
+static bool isvmused = false;
+
+#if 0
+new interface please refer to http://wiki-china.amlogic.com/%E5%86%85%E9%83%A8%E4%B
+A%BA%E5%91%98%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D
+%97%E5%BC%80%E5%8F%91/Camera/tvin_parm_description
+#endif
+
 static int test_zoom = 0;
 
-static void vm_cache_flush(unsigned buf_start , unsigned buf_size);
+static void vm_cache_this_flush(unsigned buf_start , unsigned buf_size, vm_init_t* info);
+static void vm_cache_flush(unsigned buf_start , unsigned buf_size);
+
 static inline void vm_vf_put_from_provider(vframe_t *vf);
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
 #define INCPTR(p) ptr_atomic_wrap_inc(&p)
@@ -98,60 +102,60 @@ static inline void vm_vf_put_from_provider(vframe_t *vf);
 
 #define VM_DEPTH_16_CANVAS VM_CANVAS_INDEX         //for single canvas use ,RGB16, YUV422,etc
 
-#define VM_DEPTH_24_CANVAS (VM_CANVAS_INDEX+2)
+#define VM_DEPTH_24_CANVAS (VM_CANVAS_INDEX + 2)
 
-#define VM_DEPTH_8_CANVAS_Y  (VM_CANVAS_INDEX+4)     // for Y/CbCr 4:2:0
-#define VM_DEPTH_8_CANVAS_UV (VM_CANVAS_INDEX+5)
-#define VM_DEPTH_8_CANVAS_U (VM_CANVAS_INDEX+7)
-#define VM_DEPTH_8_CANVAS_V (VM_CANVAS_INDEX+8)
+#define VM_DEPTH_8_CANVAS_Y  (VM_CANVAS_INDEX + 4)     // for Y/CbCr 4:2:0
+#define VM_DEPTH_8_CANVAS_UV (VM_CANVAS_INDEX + 5)
+#define VM_DEPTH_8_CANVAS_U (VM_CANVAS_INDEX + 7)
+#define VM_DEPTH_8_CANVAS_V (VM_CANVAS_INDEX + 8)
 
-#define VM_RES_CANVAS_INDEX (VM_CANVAS_INDEX+9)
-#define VM_RES_CANVAS_INDEX_U (VM_CANVAS_INDEX+10)
-#define VM_RES_CANVAS_INDEX_V (VM_CANVAS_INDEX+11)
+#define VM_RES_CANVAS_INDEX (VM_CANVAS_INDEX + 9)
+#define VM_RES_CANVAS_INDEX_U (VM_CANVAS_INDEX + 10)
+#define VM_RES_CANVAS_INDEX_V (VM_CANVAS_INDEX + 11)
 #define VM_RES_CANVAS_INDEX_UV VM_RES_CANVAS_INDEX_U
 
-#define VM_DMA_CANVAS_INDEX (VM_CANVAS_INDEX+14)
+#define VM_DMA_CANVAS_INDEX (VM_CANVAS_INDEX + 14)
 
-#define VM_CANVAS_MX (VM_CANVAS_INDEX+15)
+#define VM_CANVAS_MX (VM_CANVAS_INDEX + 15)
 
 #ifdef CONFIG_AMLOGIC_CAPTURE_FRAME_ROTATE
-static int vmdecbuf_size[] ={
-			0x13B3000,//5M
-			0xc00000,//3M
-			0x753000,//2M
-			0x4b0000,//1M3
-			0x300000,//1M
-			0x12c000,//VGA
-			0x4b000,//QVGA
-			};
-static struct v4l2_frmsize_discrete canvas_config_wh[]={
-					{2624,2624},
-					{2048,2048},
-					{1600,1600},
-					{1280,1280},
-					{1024,1024},
-					{640,640},
-					{320,320},
-				    };
+static int vmdecbuf_size[] = {
+            0x13B3000,//5M
+            0xc00000,//3M
+            0x753000,//2M
+            0x4b0000,//1M3
+            0x300000,//1M
+            0x12c000,//VGA
+            0x4b000,//QVGA
+            };
+static struct v4l2_frmsize_discrete canvas_config_wh[] = {
+                    {2624,2624},
+                    {2048,2048},
+                    {1600,1600},
+                    {1280,1280},
+                    {1024,1024},
+                    {640,640},
+                    {320,320},
+                    };
 #else
-static int vmdecbuf_size[] ={
-			0xEE5000,//5M
-			0x900000,//3M
-			0x591000,//2M
-			0x384000,//1M3
-			0x240000,//1M
-			0xF0000,//VGA
-			0x3C000,//QVGA
-			};
-static struct v4l2_frmsize_discrete canvas_config_wh[]={
-					{2624,1984},
-					{2048,1536},
-					{1600,1216},
-					{1280,960},
-					{1024,768},
-					{640,512},
-					{320,256},
-				    };
+static int vmdecbuf_size[] = {
+            0xEE5000,//5M
+            0x900000,//3M
+            0x591000,//2M
+            0x384000,//1M3
+            0x240000,//1M
+            0xF0000,//VGA
+            0x3C000,//QVGA
+            };
+static struct v4l2_frmsize_discrete canvas_config_wh[] = {
+                    {2624,1984},
+                    {2048,1536},
+                    {1600,1216},
+                    {1280,960},
+                    {1024,768},
+                    {640,512},
+                    {320,256},
+                    };
 #endif
 #define GE2D_ENDIAN_SHIFT        24
 #define GE2D_ENDIAN_MASK            (0x1 << GE2D_ENDIAN_SHIFT)
@@ -165,19 +169,19 @@ static DEFINE_SPINLOCK(lock);
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
 static inline void ptr_atomic_wrap_inc(u32 *ptr)
 {
-	u32 i = *ptr;
-	i++;
-	if (i >= VM_POOL_SIZE)
-		i = 0;
-	*ptr = i;
+    u32 i = *ptr;
+    i++;
+    if (i >= VM_POOL_SIZE)
+        i = 0;
+    *ptr = i;
 }
 #endif
 
-
-
+
+
 int start_vm_task(void) ;
 int start_simulate_task(void);
-
+
 
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
 static struct vframe_s vfpool[MAX_VF_POOL_SIZE];
@@ -187,6 +191,7 @@ static s32 fill_ptr, get_ptr, putting_ptr, put_ptr;
 #endif
 struct semaphore  vb_start_sema;
 struct semaphore  vb_done_sema;
+struct mutex  vm_lock;
 
 static wait_queue_head_t frame_ready;
 atomic_t waiting_flag = ATOMIC_INIT(0);
@@ -209,109 +214,109 @@ static int prepare_vframe(vframe_t *vf);
 #ifdef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
 static vframe_t *local_vf_peek(void)
 {
-	vframe_t *vf = NULL;
-	vf = vm_vf_peek_from_provider();
-	if(vf){
-		if(vm_skip_count > 0){
-			vm_skip_count--;	
-			vm_vf_get_from_provider();	
-			vm_vf_put_from_provider(vf); 
-			vf = NULL;						
-		}
-	}
-	return vf;
+    vframe_t *vf = NULL;
+    vf = vm_vf_peek_from_provider();
+    if (vf) {
+        if (vm_skip_count > 0) {
+            vm_skip_count--;
+            vm_vf_get_from_provider();
+            vm_vf_put_from_provider(vf);
+            vf = NULL;
+        }
+    }
+    return vf;
 }
 
 static vframe_t *local_vf_get(void)
 {
-	return vm_vf_get_from_provider();
+    return vm_vf_get_from_provider();
 }
 
 static void local_vf_put(vframe_t *vf)
 {
-	if(vf)
-		vm_vf_put_from_provider(vf);
-	return;
+    if (vf)
+        vm_vf_put_from_provider(vf);
+    return;
 }
 #else
 
 static inline u32 index2canvas(u32 index)
 {
-	int i;
-	int start_canvas, count;
-	u32 canvas_tab[6] ;
-	vdin_v4l2_ops_t * vops = get_vdin_v4l2_ops();
-	vops->get_tvin_canvas_info(&start_canvas,&count);
-	VM_POOL_SIZE  = count ;
-	VF_POOL_SIZE  = count ;
-	VM_CANVAS_ID = start_canvas;
-	for(i =0; i< count; i++)
-		canvas_tab[i] =  VM_CANVAS_INDEX +i;
-	return canvas_tab[index];
+    int i;
+    int start_canvas, count;
+    u32 canvas_tab[6] ;
+    vdin_v4l2_ops_t * vops = get_vdin_v4l2_ops();
+    vops->get_tvin_canvas_info(&start_canvas,&count);
+    VM_POOL_SIZE  = count ;
+    VF_POOL_SIZE  = count ;
+    VM_CANVAS_ID = start_canvas;
+    for (i =0; i< count; i++)
+        canvas_tab[i] =  VM_CANVAS_INDEX +i;
+    return canvas_tab[index];
 }
 
 static struct vframe_s* vm_vf_peek(void *op_arg)
 {
-	vframe_t *vf = NULL;
-	vf = vm_vf_peek_from_provider();
-	if(vf){
-		if(vm_skip_count > 0){
-			vm_skip_count--;
-			vm_vf_get_from_provider();
-			vm_vf_put_from_provider(vf);
-			vf = NULL;
-		}
-	}
+    vframe_t *vf = NULL;
+    vf = vm_vf_peek_from_provider();
+    if (vf) {
+        if (vm_skip_count > 0) {
+            vm_skip_count--;
+            vm_vf_get_from_provider();
+            vm_vf_put_from_provider(vf);
+            vf = NULL;
+        }
+    }
     return vf;
 }
 
 static struct vframe_s* vm_vf_get(void *op_arg)
 {
-	return vm_vf_get_from_provider();
+    return vm_vf_get_from_provider();
 }
 
 static void vm_vf_put(vframe_t *vf, void* op_arg)
 {
-	prepare_vframe(vf);
+    prepare_vframe(vf);
 }
 
 static int vm_vf_states(vframe_states_t *states, void* op_arg)
 {
-	return 0;
+    return 0;
 }
 
 static vframe_t *local_vf_peek(void)
 {
-	if (get_ptr == fill_ptr)
-		return NULL;
-	return &vfpool[get_ptr];
+    if (get_ptr == fill_ptr)
+        return NULL;
+    return &vfpool[get_ptr];
 }
 
 static vframe_t *local_vf_get(void)
 {
-	vframe_t *vf;
+    vframe_t *vf;
 
-	if (get_ptr == fill_ptr)
-		return NULL;
-	vf = &vfpool[get_ptr];
-	INCPTR(get_ptr);
-	return vf;
+    if (get_ptr == fill_ptr)
+        return NULL;
+    vf = &vfpool[get_ptr];
+    INCPTR(get_ptr);
+    return vf;
 }
 
 static void local_vf_put(vframe_t *vf)
 {
-	int i;
-	int  canvas_addr;
-	if(!vf)
-		return;
-	INCPTR(putting_ptr);
-	for (i = 0; i < VF_POOL_SIZE; i++) {
-		canvas_addr = index2canvas(i);
-		if(vf->canvas0Addr == canvas_addr ){
-			vfbuf_use[i] = 0;
-			vm_vf_put_from_provider(vf);
-		}
-	}
+    int i;
+    int  canvas_addr;
+    if (!vf)
+        return;
+    INCPTR(putting_ptr);
+    for (i = 0; i < VF_POOL_SIZE; i++) {
+        canvas_addr = index2canvas(i);
+        if (vf->canvas0Addr == canvas_addr ) {
+            vfbuf_use[i] = 0;
+            vm_vf_put_from_provider(vf);
+        }
+    }
 }
 #endif
 
@@ -323,15 +328,15 @@ static void local_vf_put(vframe_t *vf)
     states->vf_pool_size = VF_POOL_SIZE;
 
     i = put_ptr - fill_ptr;
-    if (i < 0) i += VF_POOL_SIZE;
+    if  (i < 0)  i += VF_POOL_SIZE;
     states->buf_free_num = i;
 
     i = putting_ptr - put_ptr;
-    if (i < 0) i += VF_POOL_SIZE;
+    if  (i < 0)  i += VF_POOL_SIZE;
     states->buf_recycle_num = i;
 
     i = fill_ptr - get_ptr;
-    if (i < 0) i += VF_POOL_SIZE;
+    if  (i < 0)  i += VF_POOL_SIZE;
     states->buf_avail_num = i;
 
     spin_unlock_irqrestore(&lock, flags);
@@ -340,31 +345,31 @@ static void local_vf_put(vframe_t *vf)
 
 static int vm_receiver_event_fun(int type, void *data, void *private_data)
 {
-	switch(type){
-	case VFRAME_EVENT_PROVIDER_VFRAME_READY:
-		//if (atomic_read(&waiting_flag)) {
-			wake_up_interruptible(&frame_ready);
-		//	atomic_set(&waiting_flag, 0);
-	       //}
-		//up(&vb_start_sema);
-		//printk("vdin frame ready !!!!!\n");
-		break;
-	case VFRAME_EVENT_PROVIDER_START:
-		//printk("vm register!!!!!\n");
-		vf_vm_reg_provider();
-		vm_skip_count = 0;
-		test_zoom = 0;
-		break;
-	case VFRAME_EVENT_PROVIDER_UNREG:
-		//printk("vm unregister!!!!!\n");
-		vm_local_init();
-		vf_vm_unreg_provider();
-		//printk("vm unregister succeed!!!!!");
-		break;
-	default:
-		break;
-	}
-	return 0;
+    switch (type) {
+    case VFRAME_EVENT_PROVIDER_VFRAME_READY:
+        //if  (atomic_read(&waiting_flag))  {
+            wake_up_interruptible(&frame_ready);
+        //  atomic_set(&waiting_flag, 0);
+           //}
+        //up(&vb_start_sema);
+        //printk("vdin frame ready !!!!!\n");
+        break;
+    case VFRAME_EVENT_PROVIDER_START:
+        //printk("vm register!!!!!\n");
+        vf_vm_reg_provider();
+        vm_skip_count = 0;
+        test_zoom = 0;
+        break;
+    case VFRAME_EVENT_PROVIDER_UNREG:
+        //printk("vm unregister!!!!!\n");
+        vm_local_init();
+        vf_vm_unreg_provider();
+        //printk("vm unregister succeed!!!!!\n");
+        break;
+    default:
+        break;
+    }
+    return 0;
 }
 
 static vframe_receiver_op_t vm_vf_receiver =
@@ -375,10 +380,10 @@ static vframe_receiver_op_t vm_vf_receiver =
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
 static const struct vframe_operations_s vm_vf_provider =
 {
-	.peek = vm_vf_peek,
-	.get  = vm_vf_get,
-	.put  = vm_vf_put,
-	.vf_states = vm_vf_states,
+    .peek = vm_vf_peek,
+    .get  = vm_vf_get,
+    .put  = vm_vf_put,
+    .vf_states = vm_vf_states,
 };
 
 static struct vframe_provider_s vm_vf_prov;
@@ -388,26 +393,26 @@ static struct vframe_receiver_s vm_vf_recv;
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
 int get_unused_vm_index(void)
 {
-	int i;
-	for (i = 0; i < VF_POOL_SIZE; i++){
-		if(vfbuf_use[i] == 0)
-			return i;
-	}
-	return -1;
+    int i;
+    for (i = 0; i < VF_POOL_SIZE; i++) {
+        if (vfbuf_use[i] == 0)
+            return i;
+    }
+    return -1;
 }
 static int prepare_vframe(vframe_t *vf)
 {
-	vframe_t* new_vf;
-	int index;
-
-	index = get_unused_vm_index();
-	if(index < 0)
-		return -1;
-	new_vf = &vfpool[fill_ptr];
-	memcpy(new_vf, vf, sizeof(vframe_t));
-	vfbuf_use[index]++;
-	INCPTR(fill_ptr);
-	return 0;
+    vframe_t* new_vf;
+    int index;
+
+    index = get_unused_vm_index();
+    if (index < 0)
+        return -1;
+    new_vf = &vfpool[fill_ptr];
+    memcpy(new_vf, vf, sizeof(vframe_t));
+    vfbuf_use[index]++;
+    INCPTR(fill_ptr);
+    return 0;
 }
 #endif
 
@@ -422,23 +427,23 @@ void vm_local_init(void)
 {
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
     int i;
-    for(i=0;i<MAX_VF_POOL_SIZE;i++)
+    for (i=0; i < MAX_VF_POOL_SIZE; i++)
     {
         vfbuf_use[i] = 0;
     }
-    fill_ptr=get_ptr=putting_ptr=put_ptr=0;
+    fill_ptr = get_ptr = putting_ptr = put_ptr = 0;
 #endif
     return;
 }
 
 static vframe_receiver_op_t* vf_vm_unreg_provider(void)
 {
-//    ulong flags;    
+//    ulong flags;
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
-	vf_unreg_provider(&vm_vf_prov);
+    vf_unreg_provider(&vm_vf_prov);
 #endif
-	stop_vm_task();
-//    spin_lock_irqsave(&lock, flags); 
+    stop_vm_task();
+//    spin_lock_irqsave(&lock, flags);
 //    vfp = NULL;
 //    spin_unlock_irqrestore(&lock, flags);
     return (vframe_receiver_op_t*)NULL;
@@ -448,15 +453,15 @@ EXPORT_SYMBOL(vf_vm_unreg_provider);
 static vframe_receiver_op_t* vf_vm_reg_provider( )
 {
     ulong flags;
-
+    //int ret;
     spin_lock_irqsave(&lock, flags);
     spin_unlock_irqrestore(&lock, flags);
     vm_buffer_init();
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
     vf_reg_provider(&vm_vf_prov);
 #endif
-    start_vm_task();   
-#if 0   
+    start_vm_task();
+#if 0
     start_simulate_task();
 #endif
     return &vm_vf_receiver;
@@ -465,7 +470,7 @@ EXPORT_SYMBOL(vf_vm_reg_provider);
 
 /*static const struct vframe_provider_s * vm_vf_get_vfp_from_provider(void)
 {
-	return vfp;
+    return vfp;
 } */
 
 static inline vframe_t *vm_vf_peek_from_provider(void)
@@ -492,11 +497,11 @@ static inline vframe_t *vm_vf_get_from_provider(void)
 
 static inline void vm_vf_put_from_provider(vframe_t *vf)
 {
-	struct vframe_provider_s *vfp;
-	vfp = vf_get_provider(RECEIVER_NAME);
-	if (!(vfp && vfp->ops && vfp->ops->peek))
-		return;
-	vfp->ops->put(vf,vfp->op_arg);
+    struct vframe_provider_s *vfp;
+    vfp = vf_get_provider(RECEIVER_NAME);
+    if (!(vfp && vfp->ops && vfp->ops->peek))
+        return;
+    vfp->ops->put(vf,vfp->op_arg);
 }
 
 /************************************************
@@ -504,44 +509,44 @@ static inline void vm_vf_put_from_provider(vframe_t *vf)
 *   main task functions.
 *
 *************************************************/
-static unsigned int print_ifmt=0;
-module_param(print_ifmt, uint, 0644);
-MODULE_PARM_DESC(print_ifmt, "print input format\n");
-
-static int get_input_format(vframe_t* vf)
-{
-        int format= GE2D_FORMAT_M24_NV21;
-        if(vf->type&VIDTYPE_VIU_422){
-                if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
-                        format =  GE2D_FORMAT_S16_YUV422|(GE2D_FORMAT_S16_YUV422B & (3<<3));
-                }else if(vf->type &VIDTYPE_INTERLACE_TOP){
-                        format =  GE2D_FORMAT_S16_YUV422|(GE2D_FORMAT_S16_YUV422T & (3<<3));
-                }else{
-                        format =  GE2D_FORMAT_S16_YUV422;
-                }
-        }else if(vf->type&VIDTYPE_VIU_NV21){
-                if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
-                        format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21B & (3<<3));
-                }else if(vf->type &VIDTYPE_INTERLACE_TOP){
-                        format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21T & (3<<3));
-                }else{
-                        format =  GE2D_FORMAT_M24_NV21;
-                }
-        } else{
-                if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
-                        format =  GE2D_FORMAT_M24_YUV420|(GE2D_FMT_M24_YUV420B & (3<<3));
-                }else if(vf->type &VIDTYPE_INTERLACE_TOP){
-                        format =  GE2D_FORMAT_M24_YUV420|(GE2D_FORMAT_M24_YUV420T & (3<<3));
-                }else{
-                        format =  GE2D_FORMAT_M24_YUV420;
-                }
-        }
-        if (1==print_ifmt) {
-                printk("VIDTYPE_VIU_NV21=%x, vf->type=%x, format=%x, w=%d, h=%d\n", VIDTYPE_VIU_NV21, vf->type, format, vf->width, vf->height);
-                print_ifmt = 0;
-        }
-        return format;
-}
+static unsigned int print_ifmt=0;
+module_param(print_ifmt, uint, 0644);
+MODULE_PARM_DESC(print_ifmt, "print input format\n");
+
+static int get_input_format(vframe_t* vf)
+{
+        int format= GE2D_FORMAT_M24_NV21;
+        if (vf->type & VIDTYPE_VIU_422) {
+                if (vf->type & VIDTYPE_INTERLACE_BOTTOM) {
+                        format =  GE2D_FORMAT_S16_YUV422 | (GE2D_FORMAT_S16_YUV422B & (3 << 3));
+                } else if (vf->type & VIDTYPE_INTERLACE_TOP) {
+                        format =  GE2D_FORMAT_S16_YUV422 | (GE2D_FORMAT_S16_YUV422T & (3 << 3));
+                } else {
+                        format =  GE2D_FORMAT_S16_YUV422;
+                }
+        } else if (vf->type & VIDTYPE_VIU_NV21) {
+                if (vf->type & VIDTYPE_INTERLACE_BOTTOM) {
+                        format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21B & (3<<3));
+                } else if (vf->type & VIDTYPE_INTERLACE_TOP) {
+                        format =  GE2D_FORMAT_M24_NV21 | (GE2D_FORMAT_M24_NV21T & (3 << 3));
+                } else {
+                        format =  GE2D_FORMAT_M24_NV21;
+                }
+        } else {
+                if (vf->type & VIDTYPE_INTERLACE_BOTTOM) {
+                        format =  GE2D_FORMAT_M24_YUV420 | (GE2D_FMT_M24_YUV420B & (3 << 3));
+                } else if (vf->type & VIDTYPE_INTERLACE_TOP) {
+                        format =  GE2D_FORMAT_M24_YUV420 | (GE2D_FORMAT_M24_YUV420T & (3 << 3));
+                } else {
+                        format =  GE2D_FORMAT_M24_YUV420;
+                }
+        }
+        if (1 == print_ifmt) {
+                printk("VIDTYPE_VIU_NV21=%x, vf->type=%x, format=%x, w=%d, h=%d\n", VIDTYPE_VIU_NV21, vf->type, format, vf->width, vf->height);
+                print_ifmt = 0;
+        }
+        return format;
+}
 
 #ifdef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
 static int calc_zoom(int* top ,int* left , int* bottom, int* right, int zoom)
@@ -553,7 +558,7 @@ static int calc_zoom(int* top ,int* left , int* bottom, int* right, int zoom)
     u32 ratio_x = 0;
     u32 ratio_y = 0;
 
-    if(zoom<100)
+    if (zoom < 100)
         zoom = 100;
 
     video_top = *top;
@@ -602,223 +607,223 @@ static int calc_zoom(int* top ,int* left , int* bottom, int* right, int zoom)
 
 static int  get_input_frame(display_frame_t* frame ,vframe_t* vf,int zoom)
 {
-	int ret = 0;
-	int top, left,  bottom ,right;
-	if (!vf)
-		return -1;
-
-	frame->frame_top = 0;
-	frame->frame_left = 0 ;
-	frame->frame_width = vf->width;
-	frame->frame_height = vf->height;
-	top = 0;
-	left = 0;
-	bottom = vf->height -1;
-	right = vf->width - 1;
+    int ret = 0;
+    int top, left,  bottom ,right;
+    if (!vf)
+        return -1;
+
+    frame->frame_top = 0;
+    frame->frame_left = 0 ;
+    frame->frame_width = vf->width;
+    frame->frame_height = vf->height;
+    top = 0;
+    left = 0;
+    bottom = vf->height -1;
+    right = vf->width - 1;
 #ifdef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
-	ret = calc_zoom(&top ,&left , &bottom, &right,zoom);
+    ret = calc_zoom(&top ,&left , &bottom, &right,zoom);
 #else
-	ret = get_curren_frame_para(&top ,&left , &bottom, &right);
+    ret = get_curren_frame_para(&top ,&left , &bottom, &right);
 #endif
-	if(ret >= 0 ){
-  		frame->content_top     =  top&(~1);
-		frame->content_left    =  left&(~1);
-		frame->content_width   =  vf->width - 2*frame->content_left ;
-		frame->content_height  =  vf->height - 2*frame->content_top;
-	}else{
-		frame->content_top     = 0;
-		frame->content_left    =  0 ;
-		frame->content_width   = vf->width;
-		frame->content_height  = vf->height;
-	}
-	return 0;
+    if (ret >= 0 ) {
+        frame->content_top     =  top&(~1);
+        frame->content_left    =  left&(~1);
+        frame->content_width   =  vf->width - 2*frame->content_left ;
+        frame->content_height  =  vf->height - 2*frame->content_top;
+    } else {
+        frame->content_top     = 0;
+        frame->content_left    =  0 ;
+        frame->content_width   = vf->width;
+        frame->content_height  = vf->height;
+    }
+    return 0;
 }
 
 static int get_output_format(int v4l2_format)
 {
-	int format = GE2D_FORMAT_S24_YUV444;
-	switch(v4l2_format){
-	case V4L2_PIX_FMT_RGB565X:
-		format = GE2D_FORMAT_S16_RGB_565;
-		break;
-	case V4L2_PIX_FMT_YUV444:
-		format = GE2D_FORMAT_S24_YUV444;
-		break;
-	case V4L2_PIX_FMT_VYUY:
-		format = GE2D_FORMAT_S16_YUV422;
-		break;
-	case V4L2_PIX_FMT_BGR24:
-		format = GE2D_FORMAT_S24_RGB ;
-		break;
-	case V4L2_PIX_FMT_RGB24:
-		format = GE2D_FORMAT_S24_BGR;
-		break;
-	case V4L2_PIX_FMT_NV12:
+    int format = GE2D_FORMAT_S24_YUV444;
+    switch (v4l2_format) {
+    case V4L2_PIX_FMT_RGB565X:
+        format = GE2D_FORMAT_S16_RGB_565;
+        break;
+    case V4L2_PIX_FMT_YUV444:
+        format = GE2D_FORMAT_S24_YUV444;
+        break;
+    case V4L2_PIX_FMT_VYUY:
+        format = GE2D_FORMAT_S16_YUV422;
+        break;
+    case V4L2_PIX_FMT_BGR24:
+        format = GE2D_FORMAT_S24_RGB ;
+        break;
+    case V4L2_PIX_FMT_RGB24:
+        format = GE2D_FORMAT_S24_BGR;
+        break;
+    case V4L2_PIX_FMT_NV12:
 #ifdef GE2D_NV
-		format = GE2D_FORMAT_M24_NV12;
-		break;
+        format = GE2D_FORMAT_M24_NV12;
+        break;
 #endif
-	case V4L2_PIX_FMT_NV21:
+    case V4L2_PIX_FMT_NV21:
 #ifdef GE2D_NV
-		format = GE2D_FORMAT_M24_NV21;
-		break;
+        format = GE2D_FORMAT_M24_NV21;
+        break;
 #endif
-	case V4L2_PIX_FMT_YUV420:
-	case V4L2_PIX_FMT_YVU420:
-		format = GE2D_FORMAT_S8_Y;
-		break;
-	default:
-	break;
-	}
-	return format;
+    case V4L2_PIX_FMT_YUV420:
+    case V4L2_PIX_FMT_YVU420:
+        format = GE2D_FORMAT_S8_Y;
+        break;
+    default:
+    break;
+    }
+    return format;
 }
 
 static vm_output_para_t output_para = {0,0,0,0,0,0,-1,-1,0,0,0};
 
 typedef struct vm_dma_contig_memory {
-	u32 magic;
-	void *vaddr;
-	dma_addr_t dma_handle;
-	unsigned long size;
-	int is_userptr;
+    u32 magic;
+    void *vaddr;
+    dma_addr_t dma_handle;
+    unsigned long size;
+    int is_userptr;
 }vm_contig_memory_t;
 
 int is_need_ge2d_pre_process(void)
 {
-	int ret = 0;
-	switch(output_para.v4l2_format) {
-	case  V4L2_PIX_FMT_RGB565X:
-	case  V4L2_PIX_FMT_YUV444:
-	case  V4L2_PIX_FMT_VYUY:
-	case  V4L2_PIX_FMT_BGR24:
-	case  V4L2_PIX_FMT_RGB24:
-	case  V4L2_PIX_FMT_YUV420:
-	case  V4L2_PIX_FMT_YVU420:
-	case  V4L2_PIX_FMT_NV12:
-	case  V4L2_PIX_FMT_NV21:
-		ret = 1;
-		break;
-	default:
-		break;
-	}
-	return ret;
+    int ret = 0;
+    switch (output_para.v4l2_format) {
+    case  V4L2_PIX_FMT_RGB565X:
+    case  V4L2_PIX_FMT_YUV444:
+    case  V4L2_PIX_FMT_VYUY:
+    case  V4L2_PIX_FMT_BGR24:
+    case  V4L2_PIX_FMT_RGB24:
+    case  V4L2_PIX_FMT_YUV420:
+    case  V4L2_PIX_FMT_YVU420:
+    case  V4L2_PIX_FMT_NV12:
+    case  V4L2_PIX_FMT_NV21:
+        ret = 1;
+        break;
+    default:
+        break;
+    }
+    return ret;
 }
 
 int is_need_sw_post_process(void)
 {
-	int ret = 0;
-	switch(output_para.v4l2_memory){
-	case MAGIC_DC_MEM:
-	case MAGIC_RE_MEM:
-		goto exit;
-		break;
-	case MAGIC_SG_MEM:
-	case MAGIC_VMAL_MEM:
-	default:
-		ret = 1;
-		break;
-	}
+    int ret = 0;
+    switch (output_para.v4l2_memory) {
+    case MAGIC_DC_MEM:
+    case MAGIC_RE_MEM:
+        goto exit;
+        break;
+    case MAGIC_SG_MEM:
+    case MAGIC_VMAL_MEM:
+    default:
+        ret = 1;
+        break;
+    }
 exit:
     return ret;
 }
 
 int get_canvas_index(int v4l2_format, int *depth)
 {
-	int canvas = VM_DEPTH_16_CANVAS;
-	*depth = 16;
-	switch(v4l2_format){
-	case V4L2_PIX_FMT_RGB565X:
-	case V4L2_PIX_FMT_VYUY:
-		canvas = VM_DEPTH_16_CANVAS;
-		*depth = 16 ;
-		break;
-	case V4L2_PIX_FMT_YUV444:
-	case V4L2_PIX_FMT_BGR24:
-	case V4L2_PIX_FMT_RGB24:
-		canvas = VM_DEPTH_24_CANVAS;
-		*depth = 24;
-		break;
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21:
+    int canvas = VM_DEPTH_16_CANVAS;
+    *depth = 16;
+    switch (v4l2_format) {
+    case V4L2_PIX_FMT_RGB565X:
+    case V4L2_PIX_FMT_VYUY:
+        canvas = VM_DEPTH_16_CANVAS;
+        *depth = 16 ;
+        break;
+    case V4L2_PIX_FMT_YUV444:
+    case V4L2_PIX_FMT_BGR24:
+    case V4L2_PIX_FMT_RGB24:
+        canvas = VM_DEPTH_24_CANVAS;
+        *depth = 24;
+        break;
+    case V4L2_PIX_FMT_NV12:
+    case V4L2_PIX_FMT_NV21:
 #ifdef GE2D_NV
-		canvas = VM_DEPTH_8_CANVAS_Y | (VM_DEPTH_8_CANVAS_UV<<8);
+        canvas = VM_DEPTH_8_CANVAS_Y | (VM_DEPTH_8_CANVAS_UV << 8);
 #else
-		canvas = VM_DEPTH_8_CANVAS_Y|(VM_DEPTH_8_CANVAS_U<<8)|(VM_DEPTH_8_CANVAS_V<<16);
+        canvas = VM_DEPTH_8_CANVAS_Y | (VM_DEPTH_8_CANVAS_U << 8) | (VM_DEPTH_8_CANVAS_V << 16);
 #endif
-		*depth = 12;
-		break;
-	case V4L2_PIX_FMT_YUV420:
-	case V4L2_PIX_FMT_YVU420:
-		canvas = VM_DEPTH_8_CANVAS_Y|(VM_DEPTH_8_CANVAS_U<<8)|(VM_DEPTH_8_CANVAS_V<<16);
-		*depth = 12;
-		break;
-	default:
-		break;
-	}
-	return canvas;
+        *depth = 12;
+        break;
+    case V4L2_PIX_FMT_YUV420:
+    case V4L2_PIX_FMT_YVU420:
+        canvas = VM_DEPTH_8_CANVAS_Y | (VM_DEPTH_8_CANVAS_U << 8) | (VM_DEPTH_8_CANVAS_V << 16);
+        *depth = 12;
+        break;
+    default:
+        break;
+    }
+    return canvas;
 }
 
 int get_canvas_index_res(int ext_canvas, int v4l2_format, int *depth, int width, int height, unsigned buf)
 {
-	int canvas = ext_canvas;
-	*depth = 16;
-	switch(v4l2_format){
-	case V4L2_PIX_FMT_RGB565X:
-	case V4L2_PIX_FMT_VYUY:
-		canvas = ext_canvas&0xff;
-		*depth = 16 ;
-		canvas_config(canvas,
-			(unsigned long)buf,
-			width*2, height,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		break;
-	case V4L2_PIX_FMT_YUV444:
-	case V4L2_PIX_FMT_BGR24:
-	case V4L2_PIX_FMT_RGB24:
-		canvas = ext_canvas&0xff;
-		*depth = 24;
-		canvas_config(canvas,
-			(unsigned long)buf,
-			width*3, height,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		break; 
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21: 
-		canvas_config(ext_canvas&0xff,
-			(unsigned long)buf,
-			width, height,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config((ext_canvas&0xff00)>>8,
-			(unsigned long)(buf+width*height),
-			width, height/2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas = ext_canvas&0xffff;
-		*depth = 12;   
-		break;
-	case V4L2_PIX_FMT_YVU420:
-	case V4L2_PIX_FMT_YUV420:
-		canvas_config(ext_canvas&0xff,
-			(unsigned long)buf,
-			width, height,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config((ext_canvas&0xff00)>>8,
-			(unsigned long)(buf+width*height),
-			width/2, height/2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config((ext_canvas&0xff0000)>>16,
-			(unsigned long)(buf+width*height*5/4),
-			width/2, height/2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas = ext_canvas&0xffffff;
-		*depth = 12;
-		break;
-	default:
-	break;
-	}
-	return canvas;
-}
-
-#if 0
+    int canvas = ext_canvas;
+    *depth = 16;
+    switch (v4l2_format) {
+    case V4L2_PIX_FMT_RGB565X:
+    case V4L2_PIX_FMT_VYUY:
+        canvas = ext_canvas&0xff;
+        *depth = 16 ;
+        canvas_config(canvas,
+            (unsigned long)buf,
+            width*2, height,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        break;
+    case V4L2_PIX_FMT_YUV444:
+    case V4L2_PIX_FMT_BGR24:
+    case V4L2_PIX_FMT_RGB24:
+        canvas = ext_canvas&0xff;
+        *depth = 24;
+        canvas_config(canvas,
+            (unsigned long)buf,
+            width*3, height,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        break;
+    case V4L2_PIX_FMT_NV12:
+    case V4L2_PIX_FMT_NV21:
+        canvas_config(ext_canvas&0xff,
+            (unsigned long)buf,
+            width, height,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config((ext_canvas&0xff00)>>8,
+            (unsigned long)(buf+width*height),
+            width, height/2,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas = ext_canvas&0xffff;
+        *depth = 12;
+        break;
+    case V4L2_PIX_FMT_YVU420:
+    case V4L2_PIX_FMT_YUV420:
+        canvas_config(ext_canvas&0xff,
+            (unsigned long)buf,
+            width, height,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config((ext_canvas&0xff00)>>8,
+            (unsigned long)(buf+width*height),
+            width/2, height/2,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config((ext_canvas&0xff0000)>>16,
+            (unsigned long)(buf+width*height*5/4),
+            width/2, height/2,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas = ext_canvas&0xffffff;
+        *depth = 12;
+        break;
+    default:
+    break;
+    }
+    return canvas;
+}
+
+#if 0
 static void vm_dump_mem(char *path, void *phy_addr, vm_output_para_t* para)
 {
         struct file *filp = NULL;
@@ -830,7 +835,7 @@ static void vm_dump_mem(char *path, void *phy_addr, vm_output_para_t* para)
         set_fs(KERNEL_DS);
         filp = filp_open(path,O_RDWR|O_CREAT,0666);
 
-        if(IS_ERR(filp)){
+        if (IS_ERR(filp)) {
                 printk(KERN_ERR"create %s error.\n",path);
                 return;
         }
@@ -843,181 +848,259 @@ static void vm_dump_mem(char *path, void *phy_addr, vm_output_para_t* para)
         filp_close(filp,NULL);
         set_fs(old_fs);
 }
-
-static void vm_x_mem(char *path, vm_output_para_t* para)
-{
-        struct file *filp = NULL;
-        loff_t pos = 0;
-        void * buf = NULL;
-        unsigned int size = para->bytesperline * para->height;
-        unsigned int canvas_index = para->index;
-        canvas_t cv;
-
-        mm_segment_t old_fs = get_fs();
-        set_fs(KERNEL_DS);
-        filp = filp_open(path, O_CREAT|O_RDWR|O_APPEND,0666);
-
-        if(IS_ERR(filp)){
-                printk(KERN_ERR"failed to create %s, error %p.\n", path, filp);
-                return;
-        }
-
-        for (; canvas_index !=0; canvas_index >>= 8)
-        {
-                canvas_read (canvas_index&0xff, &cv);
-                //printk("index=%lx,canvas.addr=%lx, w=%d, h=%d\n",
-                //        canvas_index, cv.addr, cv.width, cv.height);
-
-                buf = phys_to_virt(cv.addr);
-
-                size = cv.width * cv.height;
-
-                vfs_write(filp, buf, size, &pos);
-                vfs_fsync(filp, 0);
-        }
-        filp_close(filp,NULL);
-        set_fs(old_fs);
-}
-#endif
+
+static void vm_x_mem(char *path, vm_output_para_t* para)
+{
+        struct file *filp = NULL;
+        loff_t pos = 0;
+        void * buf = NULL;
+        unsigned int size = para->bytesperline * para->height;
+        unsigned int canvas_index = para->index;
+        canvas_t cv;
+
+        mm_segment_t old_fs = get_fs();
+        set_fs(KERNEL_DS);
+        filp = filp_open(path, O_CREAT|O_RDWR|O_APPEND,0666);
+
+        if (IS_ERR(filp)) {
+                printk(KERN_ERR"failed to create %s, error %p.\n", path, filp);
+                return;
+        }
+
+        for (; canvas_index != 0; canvas_index >>= 8)
+        {
+                canvas_read (canvas_index&0xff, &cv);
+                //printk("index=%lx,canvas.addr=%lx, w=%d, h=%d\n",
+                //        canvas_index, cv.addr, cv.width, cv.height);
+
+                buf = phys_to_virt(cv.addr);
+
+                size = cv.width * cv.height;
+
+                vfs_write(filp, buf, size, &pos);
+                vfs_fsync(filp, 0);
+        }
+        filp_close(filp,NULL);
+        set_fs(old_fs);
+}
+#endif
+
+int vm_fill_this_buffer(struct videobuf_buffer* vb , vm_output_para_t* para, vm_init_t* info)
+{
+    //vm_contig_memory_t *mem = NULL;
+    resource_size_t buf_start;
+    int buf_size;
+    int depth=0;
+    int ret = -1;
+    int canvas_index = -1 ;
+    int v4l2_format = V4L2_PIX_FMT_YUV444;
+    int magic = 0;
+    struct videobuf_buffer buf={0};
+    buf_start = info->buffer_start;
+    buf_size = info->vm_buf_size;
+    if (!para)
+        return -1;
+    if (info->isused == false)
+        return -2;
+#if 0
+    if (!vb)
+        goto exit;
+#else
+    if (!vb) {
+        buf.width = 640;
+        buf.height = 480;
+        magic = MAGIC_VMAL_MEM ;
+        v4l2_format =  V4L2_PIX_FMT_YUV444 ;
+        vb = &buf;
+    }
+    if (!task_running) {
+        return ret;
+    }
+#endif
+    v4l2_format = para->v4l2_format;
+    magic = para->v4l2_memory;
+    switch (magic) {
+    case   MAGIC_DC_MEM:
+        //mem = vb->priv;
+        canvas_config(VM_DMA_CANVAS_INDEX,
+              (dma_addr_t)para->vaddr,
+              vb->bytesperline, vb->height,
+              CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_index =  VM_DMA_CANVAS_INDEX ;
+        depth = (vb->bytesperline <<3)/vb->width;
+        break;
+    case  MAGIC_RE_MEM:
+        if (para->ext_canvas != 0)
+            canvas_index = get_canvas_index_res(para->ext_canvas,v4l2_format,&depth,vb->width,(para->height==0)?vb->height:para->height,(unsigned)para->vaddr);
+        else
+            canvas_index =  get_canvas_index_res((VM_RES_CANVAS_INDEX|(VM_RES_CANVAS_INDEX_U<<8)|(VM_RES_CANVAS_INDEX_V<<16)),v4l2_format,&depth,vb->width,vb->height,(unsigned)para->vaddr);
+        break;
+    case  MAGIC_SG_MEM:
+    case  MAGIC_VMAL_MEM:
+        if (buf_start && buf_size)
+            canvas_index = get_canvas_index(v4l2_format,&depth);
+        break;
+    default:
+        canvas_index = VM_DEPTH_16_CANVAS ;
+        break;
+    }
+    output_para.width = vb->width;
+    output_para.height = vb->height;
+    output_para.bytesperline  = (vb->width *depth) >> 3;
+    output_para.index = canvas_index ;
+    output_para.v4l2_format = v4l2_format ;
+    output_para.v4l2_memory = magic ;
+    output_para.mirror = para->mirror;
+    output_para.zoom = para->zoom;
+    output_para.angle = para->angle;
+    output_para.vaddr = para->vaddr;
+    output_para.ext_canvas = (magic == MAGIC_RE_MEM)?para->ext_canvas:0;
+    up(&vb_start_sema);
+    ret = down_interruptible(&vb_done_sema);
+    if (magic == MAGIC_RE_MEM)
+        vm_cache_this_flush((unsigned)para->vaddr, output_para.bytesperline*((para->height==0)?output_para.height:para->height), info);
+    return ret;
+}
 
 int vm_fill_buffer(struct videobuf_buffer* vb , vm_output_para_t* para)
 {
-	//vm_contig_memory_t *mem = NULL;
-	resource_size_t buf_start;
-	int buf_size;
-	int depth=0;
-	int ret = -1;
-	int canvas_index = -1 ;
-	int v4l2_format = V4L2_PIX_FMT_YUV444;
-	int magic = 0;
-	struct videobuf_buffer buf={0};
-	get_vm_buf_info( &buf_start,&buf_size, NULL);
-	if(!para)
-		return -1;
-#if 0    
-	if(!vb)
-		goto exit;
+    //vm_contig_memory_t *mem = NULL;
+    resource_size_t buf_start;
+    int buf_size;
+    int depth=0;
+    int ret = -1;
+    int canvas_index = -1 ;
+    int v4l2_format = V4L2_PIX_FMT_YUV444;
+    int magic = 0;
+    struct videobuf_buffer buf={0};
+    get_vm_buf_info( &buf_start,&buf_size, NULL);
+
+    if (!para)
+        return -1;
+#if 0
+    if (!vb)
+        goto exit;
 #else
-	if(!vb) {
-		buf.width = 640;
-		buf.height = 480;
-		magic = MAGIC_VMAL_MEM ;
-		v4l2_format =  V4L2_PIX_FMT_YUV444 ;
-		vb = &buf;
-	}
-	if(!task_running){
-		return ret;
-	}
+    if (!vb) {
+        buf.width = 640;
+        buf.height = 480;
+        magic = MAGIC_VMAL_MEM ;
+        v4l2_format =  V4L2_PIX_FMT_YUV444 ;
+        vb = &buf;
+    }
+    if (!task_running) {
+        return ret;
+    }
 #endif
-	v4l2_format = para->v4l2_format;
-	magic = para->v4l2_memory;
-	switch(magic){
-	case   MAGIC_DC_MEM:
-		//mem = vb->priv;
-		canvas_config(VM_DMA_CANVAS_INDEX,
-			  (dma_addr_t)para->vaddr,
-			  vb->bytesperline, vb->height,
-			  CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);        
-		canvas_index =  VM_DMA_CANVAS_INDEX ;
-		depth =  (vb->bytesperline <<3)/vb->width;
-		break;
-	case  MAGIC_RE_MEM:
-		if(para->ext_canvas!=0)
-		    canvas_index = get_canvas_index_res(para->ext_canvas,v4l2_format,&depth,vb->width,(para->height==0)?vb->height:para->height,(unsigned)para->vaddr);
-		else
-		    canvas_index =  get_canvas_index_res((VM_RES_CANVAS_INDEX|(VM_RES_CANVAS_INDEX_U<<8)|(VM_RES_CANVAS_INDEX_V<<16)),v4l2_format,&depth,vb->width,vb->height,(unsigned)para->vaddr);
-		break;
-	case  MAGIC_SG_MEM:
-	case  MAGIC_VMAL_MEM:
-		if(buf_start && buf_size)
-			canvas_index = get_canvas_index(v4l2_format,&depth);
-		break;
-	default:
-		canvas_index = VM_DEPTH_16_CANVAS ;
-		break;
-	}
-	output_para.width = vb->width;
-	output_para.height = vb->height;
-	output_para.bytesperline  = (vb->width *depth)>>3;
-	output_para.index = canvas_index ;
-	output_para.v4l2_format  = v4l2_format ;
-	output_para.v4l2_memory   = magic ;
-	output_para.mirror = para->mirror;
-	output_para.zoom= para->zoom;
-	output_para.angle= para->angle;
-	output_para.vaddr = para->vaddr;
-	output_para.ext_canvas = (magic == MAGIC_RE_MEM)?para->ext_canvas:0;
-	up(&vb_start_sema);
-	ret = down_interruptible(&vb_done_sema);
-	if(magic == MAGIC_RE_MEM)
-		vm_cache_flush((unsigned)para->vaddr, output_para.bytesperline*((para->height==0)?output_para.height:para->height));
-	return ret;
-}
-
-int vm_fill_buffer2(struct vb2_buffer *vb, vm_output_para_t *para)
-{
-        int depth=0;
-        int ret = -1;
-        int canvas_index = -1 ;
-        int v4l2_format = V4L2_PIX_FMT_YUV444;
-        int magic = 0;
-        if(!para)
-                return -1;
-
-        if(!task_running){
-                return ret;
-        }
-
-        v4l2_format = para->v4l2_format;
-        magic = para->v4l2_memory;
-        switch(magic){
-                case   MAGIC_DC_MEM:
-                        printk("not support\n");
-                        break;
-                case  MAGIC_RE_MEM:
-                        if(para->ext_canvas!=0)
-                                canvas_index = get_canvas_index_res(para->ext_canvas,
-                                                v4l2_format,
-                                                &depth,
-                                                para->width,
-                                                para->height,
-                                                (unsigned)para->vaddr);
-                        else
-                                canvas_index =  get_canvas_index_res(
-                                                (VM_RES_CANVAS_INDEX|(VM_RES_CANVAS_INDEX_U<<8)|(VM_RES_CANVAS_INDEX_V<<16)),
-                                                v4l2_format,&depth,
-                                                para->width,
-                                                para->height,
-                                                (unsigned)para->vaddr);
-                        break;
-                case  MAGIC_SG_MEM:
-                        printk("not support\n");
-                        break;
-                case  MAGIC_VMAL_MEM:
-                        printk("not support\n");
-                        break;
-                default:
-                        canvas_index = VM_DEPTH_16_CANVAS ;
-                        break;
-        }
-        output_para.width = para->width;
-        output_para.height = para->height;
-        output_para.bytesperline  = (output_para.width *depth)>>3;
-        output_para.index = canvas_index ;
-        output_para.v4l2_format  = para->v4l2_format ;
-        output_para.v4l2_memory  = para->v4l2_memory;
-        output_para.mirror = para->mirror;
-        output_para.zoom= para->zoom;
-        output_para.angle= para->angle;
-        output_para.vaddr = para->vaddr;
-        output_para.ext_canvas = (magic == MAGIC_RE_MEM)?para->ext_canvas:0;
-        up(&vb_start_sema);
-        ret = down_interruptible(&vb_done_sema);
-        if(magic == MAGIC_RE_MEM)
-                vm_cache_flush((unsigned)para->vaddr,
-                                output_para.bytesperline*((para->height==0)?output_para.height:para->height));
-        return ret;
-}
+    v4l2_format = para->v4l2_format;
+    magic = para->v4l2_memory;
+    switch (magic) {
+    case   MAGIC_DC_MEM:
+        //mem = vb->priv;
+        canvas_config(VM_DMA_CANVAS_INDEX,
+              (dma_addr_t)para->vaddr,
+              vb->bytesperline, vb->height,
+              CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_index =  VM_DMA_CANVAS_INDEX ;
+        depth =  (vb->bytesperline <<3)/vb->width;
+        break;
+    case  MAGIC_RE_MEM:
+        if (para->ext_canvas != 0)
+            canvas_index = get_canvas_index_res(para->ext_canvas,v4l2_format,&depth,vb->width,(para->height==0)?vb->height:para->height,(unsigned)para->vaddr);
+        else
+            canvas_index =  get_canvas_index_res((VM_RES_CANVAS_INDEX|(VM_RES_CANVAS_INDEX_U<<8)|(VM_RES_CANVAS_INDEX_V<<16)),v4l2_format,&depth,vb->width,vb->height,(unsigned)para->vaddr);
+        break;
+    case  MAGIC_SG_MEM:
+    case  MAGIC_VMAL_MEM:
+        if (buf_start && buf_size)
+            canvas_index = get_canvas_index(v4l2_format,&depth);
+        break;
+    default:
+        canvas_index = VM_DEPTH_16_CANVAS ;
+        break;
+    }
+    output_para.width = vb->width;
+    output_para.height = vb->height;
+    output_para.bytesperline  = (vb->width *depth)>>3;
+    output_para.index = canvas_index ;
+    output_para.v4l2_format  = v4l2_format ;
+    output_para.v4l2_memory   = magic ;
+    output_para.mirror = para->mirror;
+    output_para.zoom= para->zoom;
+    output_para.angle= para->angle;
+    output_para.vaddr = para->vaddr;
+    output_para.ext_canvas = (magic == MAGIC_RE_MEM)?para->ext_canvas:0;
+    up(&vb_start_sema);
+    ret = down_interruptible(&vb_done_sema);
+    if (magic == MAGIC_RE_MEM)
+        vm_cache_flush((unsigned)para->vaddr, output_para.bytesperline*((para->height==0)?output_para.height:para->height));
+    return ret;
+}
+
+int vm_fill_buffer2(struct vb2_buffer *vb, vm_output_para_t *para)
+{
+        int depth=0;
+        int ret = -1;
+        int canvas_index = -1 ;
+        int v4l2_format = V4L2_PIX_FMT_YUV444;
+        int magic = 0;
+        if (!para)
+                return -1;
+
+        if (!task_running) {
+                return ret;
+        }
+
+        v4l2_format = para->v4l2_format;
+        magic = para->v4l2_memory;
+        switch (magic) {
+                case   MAGIC_DC_MEM:
+                        printk("not support\n");
+                        break;
+                case  MAGIC_RE_MEM:
+                        if (para->ext_canvas != 0)
+                                canvas_index = get_canvas_index_res(para->ext_canvas,
+                                                v4l2_format,
+                                                &depth,
+                                                para->width,
+                                                para->height,
+                                                (unsigned)para->vaddr);
+                        else
+                                canvas_index =  get_canvas_index_res(
+                                                (VM_RES_CANVAS_INDEX|(VM_RES_CANVAS_INDEX_U<<8)|(VM_RES_CANVAS_INDEX_V<<16)),
+                                                v4l2_format,&depth,
+                                                para->width,
+                                                para->height,
+                                                (unsigned)para->vaddr);
+                        break;
+                case  MAGIC_SG_MEM:
+                        printk("not support\n");
+                        break;
+                case  MAGIC_VMAL_MEM:
+                        printk("not support\n");
+                        break;
+                default:
+                        canvas_index = VM_DEPTH_16_CANVAS ;
+                        break;
+        }
+        output_para.width = para->width;
+        output_para.height = para->height;
+        output_para.bytesperline  = (output_para.width *depth)>>3;
+        output_para.index = canvas_index ;
+        output_para.v4l2_format  = para->v4l2_format ;
+        output_para.v4l2_memory  = para->v4l2_memory;
+        output_para.mirror = para->mirror;
+        output_para.zoom= para->zoom;
+        output_para.angle= para->angle;
+        output_para.vaddr = para->vaddr;
+        output_para.ext_canvas = (magic == MAGIC_RE_MEM)?para->ext_canvas:0;
+        up(&vb_start_sema);
+        ret = down_interruptible(&vb_done_sema);
+        if (magic == MAGIC_RE_MEM)
+                vm_cache_flush((unsigned)para->vaddr,
+                                output_para.bytesperline*((para->height==0)?output_para.height:para->height));
+        return ret;
+}
 
 /*for decoder input processing
     1. output window should 1:1 as source frame size
@@ -1026,428 +1109,427 @@ int vm_fill_buffer2(struct vb2_buffer *vb, vm_output_para_t *para)
 */
 int vm_ge2d_pre_process(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
 {
-	int ret;
-	int src_top ,src_left ,src_width, src_height;
-	canvas_t cs0,cs1,cs2,cd;
-	int current_mirror = 0;
-	int cur_angle = 0;
-	display_frame_t input_frame={0};
-	ret = get_input_frame(&input_frame , vf,output_para.zoom);
-	src_top = input_frame.content_top;
-	src_left = input_frame.content_left;
-	src_width = input_frame.content_width;
-	src_height = input_frame.content_height;
-	if(test_zoom){
-		test_zoom = 0;
-		printk("top is %d , left is %d , width is %d , height is %d\n",input_frame.content_top ,input_frame.content_left,input_frame.content_width,input_frame.content_height);
-	}
+    int ret;
+    int src_top ,src_left ,src_width, src_height;
+    canvas_t cs0,cs1,cs2,cd;
+    int current_mirror = 0;
+    int cur_angle = 0;
+    display_frame_t input_frame = {0};
+    ret = get_input_frame(&input_frame , vf,output_para.zoom);
+    src_top = input_frame.content_top;
+    src_left = input_frame.content_left;
+    src_width = input_frame.content_width;
+    src_height = input_frame.content_height;
+    if (test_zoom) {
+        test_zoom = 0;
+        printk("top is %d , left is %d , width is %d , height is %d\n",input_frame.content_top ,input_frame.content_left,input_frame.content_width,input_frame.content_height);
+    }
 #ifdef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
-	current_mirror = output_para.mirror;
-	if(current_mirror < 0)
-		current_mirror = 0;
+    current_mirror = output_para.mirror;
+    if (current_mirror < 0)
+        current_mirror = 0;
 #else
-	current_mirror = camera_mirror_flag;
+    current_mirror = camera_mirror_flag;
 #endif
 
 #ifdef CONFIG_AMLOGIC_CAPTURE_FRAME_ROTATE
-	cur_angle = output_para.angle;
-	if(current_mirror == 1)
-		cur_angle = (360 - cur_angle%360);
-	else
-		cur_angle = cur_angle%360;
+    cur_angle = output_para.angle;
+    if (current_mirror == 1)
+        cur_angle = (360 - cur_angle%360);
+    else
+        cur_angle = cur_angle%360;
 #endif
-	/* data operating. */ 
-	ge2d_config->alu_const_color= 0;//0x000000ff;
-	ge2d_config->bitmask_en  = 0;
-	ge2d_config->src1_gb_alpha = 0;//0xff;
-	ge2d_config->dst_xy_swap = 0;
-
-	canvas_read(vf->canvas0Addr&0xff,&cs0);
-	canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-	canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-	ge2d_config->src_planes[0].addr = cs0.addr;
-	ge2d_config->src_planes[0].w = cs0.width;
-	ge2d_config->src_planes[0].h = cs0.height;
-	ge2d_config->src_planes[1].addr = cs1.addr;
-	ge2d_config->src_planes[1].w = cs1.width;
-	ge2d_config->src_planes[1].h = cs1.height;
-	ge2d_config->src_planes[2].addr = cs2.addr;
-	ge2d_config->src_planes[2].w = cs2.width;
-	ge2d_config->src_planes[2].h = cs2.height;
-	canvas_read(output_para.index&0xff,&cd);
-	ge2d_config->dst_planes[0].addr = cd.addr;
-	ge2d_config->dst_planes[0].w = cd.width;
-	ge2d_config->dst_planes[0].h = cd.height;
-	ge2d_config->src_key.key_enable = 0;
-	ge2d_config->src_key.key_mask = 0;
-	ge2d_config->src_key.key_mode = 0;
-	ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-	ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config->src_para.format = get_input_format(vf);
-	ge2d_config->src_para.fill_color_en = 0;
-	ge2d_config->src_para.fill_mode = 0;
-	ge2d_config->src_para.x_rev = 0;
-	ge2d_config->src_para.y_rev = 0;
-	ge2d_config->src_para.color = 0xffffffff;
-	ge2d_config->src_para.top = 0;
-	ge2d_config->src_para.left = 0;
-	ge2d_config->src_para.width = vf->width;
-	ge2d_config->src_para.height = vf->height;
-	/* printk("vf_width is %d , vf_height is %d \n",vf->width ,vf->height); */
-	ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config->dst_para.canvas_index = output_para.index&0xff;
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(output_para.index&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+    ge2d_config->src_para.height = vf->height;
+    /* printk("vf_width is %d , vf_height is %d \n",vf->width ,vf->height); */
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index = output_para.index&0xff;
 #ifdef GE2D_NV
-	if((output_para.v4l2_format != V4L2_PIX_FMT_YUV420)
-		&& (output_para.v4l2_format != V4L2_PIX_FMT_YVU420))
-		ge2d_config->dst_para.canvas_index = output_para.index;
+    if ((output_para.v4l2_format != V4L2_PIX_FMT_YUV420)
+        && (output_para.v4l2_format != V4L2_PIX_FMT_YVU420))
+        ge2d_config->dst_para.canvas_index = output_para.index;
 #endif
-	ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config->dst_para.format = get_output_format(output_para.v4l2_format)|GE2D_LITTLE_ENDIAN;
-	ge2d_config->dst_para.fill_color_en = 0;
-	ge2d_config->dst_para.fill_mode = 0;
-	ge2d_config->dst_para.x_rev = 0;
-	ge2d_config->dst_para.y_rev = 0;
-	ge2d_config->dst_para.color = 0;
-	ge2d_config->dst_para.top = 0;
-	ge2d_config->dst_para.left = 0;
-	ge2d_config->dst_para.width = output_para.width;
-	ge2d_config->dst_para.height = output_para.height;
-
-	if(current_mirror==1){
-		ge2d_config->dst_para.x_rev = 1;
-		ge2d_config->dst_para.y_rev = 0;
-	}else if(current_mirror==2){
-		ge2d_config->dst_para.x_rev = 0;
-		ge2d_config->dst_para.y_rev = 1;
-	}else{
-		ge2d_config->dst_para.x_rev = 0;
-		ge2d_config->dst_para.y_rev = 0;
-	}
-
-	if(cur_angle==90){
-		ge2d_config->dst_xy_swap = 1;
-		ge2d_config->dst_para.x_rev ^= 1;
-	}else if(cur_angle==180){
-		ge2d_config->dst_para.x_rev ^= 1;
-		ge2d_config->dst_para.y_rev ^= 1;
-	}else if(cur_angle==270){
-		ge2d_config->dst_xy_swap = 1;
-		ge2d_config->dst_para.y_rev ^= 1;
-	}
-
-	if(ge2d_context_config_ex(context,ge2d_config)<0) {
-		printk("++ge2d configing error.\n");
-		return -1;
-	}
-	stretchblt_noalpha(context,src_left ,src_top ,src_width, src_height,0,0,output_para.width,output_para.height);
-
-	/* for cr of  yuv420p or yuv420sp. */
-	if((output_para.v4l2_format==V4L2_PIX_FMT_YUV420)
-		||(output_para.v4l2_format==V4L2_PIX_FMT_YVU420)){
-		/* for cb. */
-		canvas_read((output_para.index>>8)&0xff,&cd);
-		ge2d_config->dst_planes[0].addr = cd.addr;
-		ge2d_config->dst_planes[0].w = cd.width;
-		ge2d_config->dst_planes[0].h = cd.height;
-		ge2d_config->dst_para.canvas_index=(output_para.index>>8)&0xff;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = get_output_format(output_para.v4l2_format)|GE2D_LITTLE_ENDIAN;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = output_para.width;
+    ge2d_config->dst_para.height = output_para.height;
+
+    if (current_mirror == 1) {
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev = 0;
+    } else if (current_mirror == 2) {
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 1;
+    } else {
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 0;
+    }
+
+    if (cur_angle == 90) {
+        ge2d_config->dst_xy_swap = 1;
+        ge2d_config->dst_para.x_rev ^= 1;
+    } else if (cur_angle == 180) {
+        ge2d_config->dst_para.x_rev ^= 1;
+        ge2d_config->dst_para.y_rev ^= 1;
+    } else if (cur_angle == 270) {
+        ge2d_config->dst_xy_swap = 1;
+        ge2d_config->dst_para.y_rev ^= 1;
+    }
+
+    if (ge2d_context_config_ex(context,ge2d_config) < 0) {
+        printk("++ge2d configing error.\n");
+        return -1;
+    }
+    stretchblt_noalpha(context,src_left ,src_top ,src_width, src_height,0,0,output_para.width,output_para.height);
+
+    /* for cr of  yuv420p or yuv420sp. */
+    if ((output_para.v4l2_format == V4L2_PIX_FMT_YUV420)
+        ||(output_para.v4l2_format == V4L2_PIX_FMT_YVU420)) {
+        /* for cb. */
+        canvas_read((output_para.index >> 8) & 0xff, &cd);
+        ge2d_config->dst_planes[0].addr = cd.addr;
+        ge2d_config->dst_planes[0].w = cd.width;
+        ge2d_config->dst_planes[0].h = cd.height;
+        ge2d_config->dst_para.canvas_index=(output_para.index>>8)&0xff;
 #ifndef GE2D_NV
-		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
-#else
-		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CR|GE2D_LITTLE_ENDIAN;
-#endif
-		ge2d_config->dst_para.width = output_para.width/2;
-		ge2d_config->dst_para.height = output_para.height/2;
-		ge2d_config->dst_xy_swap = 0;
-
-		if(current_mirror==1){
-			ge2d_config->dst_para.x_rev = 1;
-			ge2d_config->dst_para.y_rev = 0;
-		}else if(current_mirror==2){
-			ge2d_config->dst_para.x_rev = 0;
-			ge2d_config->dst_para.y_rev = 1;
-		}else{
-			ge2d_config->dst_para.x_rev = 0;
-			ge2d_config->dst_para.y_rev = 0;
-		}
-
-		if(cur_angle==90){
-			ge2d_config->dst_xy_swap = 1;
-			ge2d_config->dst_para.x_rev ^= 1;
-		}else if(cur_angle==180){
-			ge2d_config->dst_para.x_rev ^= 1;
-			ge2d_config->dst_para.y_rev ^= 1;
-		}else if(cur_angle==270){
-			ge2d_config->dst_xy_swap = 1;
-			ge2d_config->dst_para.y_rev ^= 1;
-		}
-	
-		if(ge2d_context_config_ex(context,ge2d_config)<0) {
-			printk("++ge2d configing error.\n");
-			return -1;
-		}
-		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
-			0, 0, ge2d_config->dst_para.width,ge2d_config->dst_para.height);
-	}
+        ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
+#else
+        ge2d_config->dst_para.format=GE2D_FORMAT_S8_CR|GE2D_LITTLE_ENDIAN;
+#endif
+        ge2d_config->dst_para.width = output_para.width/2;
+        ge2d_config->dst_para.height = output_para.height/2;
+        ge2d_config->dst_xy_swap = 0;
+
+        if (current_mirror == 1) {
+            ge2d_config->dst_para.x_rev = 1;
+            ge2d_config->dst_para.y_rev = 0;
+        } else if (current_mirror == 2) {
+            ge2d_config->dst_para.x_rev = 0;
+            ge2d_config->dst_para.y_rev = 1;
+        } else {
+            ge2d_config->dst_para.x_rev = 0;
+            ge2d_config->dst_para.y_rev = 0;
+        }
+
+        if (cur_angle == 90) {
+            ge2d_config->dst_xy_swap = 1;
+            ge2d_config->dst_para.x_rev ^= 1;
+        } else if (cur_angle == 180) {
+            ge2d_config->dst_para.x_rev ^= 1;
+            ge2d_config->dst_para.y_rev ^= 1;
+        } else if (cur_angle==270) {
+            ge2d_config->dst_xy_swap = 1;
+            ge2d_config->dst_para.y_rev ^= 1;
+        }
+
+        if (ge2d_context_config_ex(context,ge2d_config) < 0) {
+            printk("++ge2d configing error.\n");
+            return -1;
+        }
+        stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+            0, 0, ge2d_config->dst_para.width,ge2d_config->dst_para.height);
+    }
 #ifndef GE2D_NV
-	else if (output_para.v4l2_format==V4L2_PIX_FMT_NV12||
-				output_para.v4l2_format==V4L2_PIX_FMT_NV21) {
-		canvas_read((output_para.index>>8)&0xff,&cd);
-		ge2d_config->dst_planes[0].addr = cd.addr;
-		ge2d_config->dst_planes[0].w = cd.width;
-		ge2d_config->dst_planes[0].h = cd.height;
-		ge2d_config->dst_para.canvas_index=(output_para.index>>8)&0xff;
-		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
-		ge2d_config->dst_para.width = output_para.width/2;
-		ge2d_config->dst_para.height = output_para.height/2;
-		ge2d_config->dst_xy_swap = 0;
-
-		if(current_mirror==1){
-			ge2d_config->dst_para.x_rev = 1;
-			ge2d_config->dst_para.y_rev = 0;
-		}else if(current_mirror==2){
-			ge2d_config->dst_para.x_rev = 0;
-			ge2d_config->dst_para.y_rev = 1;
-		}else{
-			ge2d_config->dst_para.x_rev = 0;
-			ge2d_config->dst_para.y_rev = 0;
-		}
-
-		if(cur_angle==90){
-			ge2d_config->dst_xy_swap = 1;
-			ge2d_config->dst_para.x_rev ^= 1;
-		}else if(cur_angle==180){
-			ge2d_config->dst_para.x_rev ^= 1;
-			ge2d_config->dst_para.y_rev ^= 1;
-		}else if(cur_angle==270){
-			ge2d_config->dst_xy_swap = 1;
-			ge2d_config->dst_para.y_rev ^= 1;
-		}
-
-		if(ge2d_context_config_ex(context,ge2d_config)<0) {
-			printk("++ge2d configing error.\n");
-			return -1;
-		}
-		stretchblt_noalpha(context,src_left ,src_top ,src_width, src_height,0,0,ge2d_config->dst_para.width,ge2d_config->dst_para.height);
-	}
+    else if (output_para.v4l2_format==V4L2_PIX_FMT_NV12||
+                output_para.v4l2_format==V4L2_PIX_FMT_NV21) {
+        canvas_read((output_para.index>>8)&0xff,&cd);
+        ge2d_config->dst_planes[0].addr = cd.addr;
+        ge2d_config->dst_planes[0].w = cd.width;
+        ge2d_config->dst_planes[0].h = cd.height;
+        ge2d_config->dst_para.canvas_index=(output_para.index>>8)&0xff;
+        ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
+        ge2d_config->dst_para.width = output_para.width/2;
+        ge2d_config->dst_para.height = output_para.height/2;
+        ge2d_config->dst_xy_swap = 0;
+
+        if (current_mirror == 1) {
+            ge2d_config->dst_para.x_rev = 1;
+            ge2d_config->dst_para.y_rev = 0;
+        } else if (current_mirror == 2) {
+            ge2d_config->dst_para.x_rev = 0;
+            ge2d_config->dst_para.y_rev = 1;
+        } else {
+            ge2d_config->dst_para.x_rev = 0;
+            ge2d_config->dst_para.y_rev = 0;
+        }
+
+        if (cur_angle == 90) {
+            ge2d_config->dst_xy_swap = 1;
+            ge2d_config->dst_para.x_rev ^= 1;
+        } else if (cur_angle == 180) {
+            ge2d_config->dst_para.x_rev ^= 1;
+            ge2d_config->dst_para.y_rev ^= 1;
+        } else if (cur_angle == 270) {
+            ge2d_config->dst_xy_swap = 1;
+            ge2d_config->dst_para.y_rev ^= 1;
+        }
+
+        if (ge2d_context_config_ex(context,ge2d_config) < 0) {
+            printk("++ge2d configing error.\n");
+            return -1;
+        }
+        stretchblt_noalpha(context,src_left ,src_top ,src_width, src_height,0,0,ge2d_config->dst_para.width,ge2d_config->dst_para.height);
+    }
 #endif
 
-	/* for cb of yuv420p or yuv420sp. */
-	if(output_para.v4l2_format==V4L2_PIX_FMT_YUV420||
-		output_para.v4l2_format==V4L2_PIX_FMT_YVU420
+    /* for cb of yuv420p or yuv420sp. */
+    if (output_para.v4l2_format == V4L2_PIX_FMT_YUV420 ||
+        output_para.v4l2_format == V4L2_PIX_FMT_YVU420
 #ifndef GE2D_NV
-		||output_para.v4l2_format==V4L2_PIX_FMT_NV12||
-		output_para.v4l2_format==V4L2_PIX_FMT_NV21
+        || output_para.v4l2_format == V4L2_PIX_FMT_NV12 ||
+        output_para.v4l2_format == V4L2_PIX_FMT_NV21
 #endif
-			) {
-		canvas_read((output_para.index>>16)&0xff,&cd);
-		ge2d_config->dst_planes[0].addr = cd.addr;
-		ge2d_config->dst_planes[0].w = cd.width;
-		ge2d_config->dst_planes[0].h = cd.height;
-		ge2d_config->dst_para.canvas_index=(output_para.index>>16)&0xff;
+            ) {
+        canvas_read((output_para.index>>16)&0xff,&cd);
+        ge2d_config->dst_planes[0].addr = cd.addr;
+        ge2d_config->dst_planes[0].w = cd.width;
+        ge2d_config->dst_planes[0].h = cd.height;
+        ge2d_config->dst_para.canvas_index=(output_para.index>>16)&0xff;
 #ifndef GE2D_NV
-		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CR|GE2D_LITTLE_ENDIAN;
-#else
-		ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
-#endif
-		ge2d_config->dst_para.width = output_para.width/2;
-		ge2d_config->dst_para.height = output_para.height/2;
-		ge2d_config->dst_xy_swap = 0;
-
-		if(current_mirror==1){
-			ge2d_config->dst_para.x_rev = 1;
-			ge2d_config->dst_para.y_rev = 0;
-		}else if(current_mirror==2){
-			ge2d_config->dst_para.x_rev = 0;
-			ge2d_config->dst_para.y_rev = 1;
-		}else{
-			ge2d_config->dst_para.x_rev = 0;
-			ge2d_config->dst_para.y_rev = 0;
-		}
-
-		if(cur_angle==90){
-			ge2d_config->dst_xy_swap = 1;
-			ge2d_config->dst_para.x_rev ^= 1;
-		}else if(cur_angle==180){
-			ge2d_config->dst_para.x_rev ^= 1;
-			ge2d_config->dst_para.y_rev ^= 1;
-		}else if(cur_angle==270){
-			ge2d_config->dst_xy_swap = 1;
-			ge2d_config->dst_para.y_rev ^= 1;
-		}
-
-		if(ge2d_context_config_ex(context,ge2d_config)<0) {
-			printk("++ge2d configing error.\n");
-			return -1;
-		}
-		stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
-			0, 0, ge2d_config->dst_para.width, ge2d_config->dst_para.height);
-	}
-	return output_para.index;
+        ge2d_config->dst_para.format=GE2D_FORMAT_S8_CR|GE2D_LITTLE_ENDIAN;
+#else
+        ge2d_config->dst_para.format=GE2D_FORMAT_S8_CB|GE2D_LITTLE_ENDIAN;
+#endif
+        ge2d_config->dst_para.width = output_para.width/2;
+        ge2d_config->dst_para.height = output_para.height/2;
+        ge2d_config->dst_xy_swap = 0;
+
+        if (current_mirror == 1) {
+            ge2d_config->dst_para.x_rev = 1;
+            ge2d_config->dst_para.y_rev = 0;
+        } else if (current_mirror == 2) {
+            ge2d_config->dst_para.x_rev = 0;
+            ge2d_config->dst_para.y_rev = 1;
+        } else {
+            ge2d_config->dst_para.x_rev = 0;
+            ge2d_config->dst_para.y_rev = 0;
+        }
+
+        if (cur_angle == 90) {
+            ge2d_config->dst_xy_swap = 1;
+            ge2d_config->dst_para.x_rev ^= 1;
+        } else if (cur_angle == 180) {
+            ge2d_config->dst_para.x_rev ^= 1;
+            ge2d_config->dst_para.y_rev ^= 1;
+        } else if (cur_angle == 270) {
+            ge2d_config->dst_xy_swap = 1;
+            ge2d_config->dst_para.y_rev ^= 1;
+        }
+
+        if (ge2d_context_config_ex(context,ge2d_config) < 0) {
+            printk("++ge2d configing error.\n");
+            return -1;
+        }
+        stretchblt_noalpha(context, src_left, src_top, src_width, src_height,
+            0, 0, ge2d_config->dst_para.width, ge2d_config->dst_para.height);
+    }
+    return output_para.index;
 }
 
 int vm_sw_post_process(int canvas , int addr)
 {
-	int poss=0,posd=0;
-	int i=0;
-	void __iomem * buffer_y_start;
-	void __iomem * buffer_u_start;
-	void __iomem * buffer_v_start = 0;
-	struct io_mapping *mapping_wc;
-	int offset = 0;
-	canvas_t canvas_work_y;
-	canvas_t canvas_work_u;
-	canvas_t canvas_work_v;
-    if(!addr){
-        return -1;
-    }
-	get_vm_buf_info( NULL, NULL, &mapping_wc);
-	if(!mapping_wc){
-		return -1;
-	}
-	
-	canvas_read(canvas&0xff,&canvas_work_y);
-	offset = 0;
-	buffer_y_start = io_mapping_map_atomic_wc( mapping_wc, offset);
-	if(buffer_y_start == NULL) {
-		printk(" vm.postprocess:mapping buffer error\n");
-		return -1;
-	}
-	if (output_para.v4l2_format == V4L2_PIX_FMT_BGR24||
-				output_para.v4l2_format == V4L2_PIX_FMT_RGB24||
-				output_para.v4l2_format== V4L2_PIX_FMT_RGB565X) {
-		for(i=0;i<output_para.height;i++) {
-			memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.bytesperline);
-			poss+=output_para.bytesperline;
-			posd+= canvas_work_y.width;
-		}
-		io_mapping_unmap_atomic( buffer_y_start );
-
-	} else if (output_para.v4l2_format== V4L2_PIX_FMT_NV12||
-				output_para.v4l2_format== V4L2_PIX_FMT_NV21) {
+    int poss=0,posd=0;
+    int i=0;
+    void __iomem * buffer_y_start;
+    void __iomem * buffer_u_start;
+    void __iomem * buffer_v_start = 0;
+    struct io_mapping *mapping_wc;
+    int offset = 0;
+    canvas_t canvas_work_y;
+    canvas_t canvas_work_u;
+    canvas_t canvas_work_v;
+    if (!addr) {
+        return -1;
+    }
+    get_vm_buf_info( NULL, NULL, &mapping_wc);
+    if (!mapping_wc) {
+        return -1;
+    }
+    canvas_read(canvas&0xff,&canvas_work_y);
+    offset = 0;
+    buffer_y_start = io_mapping_map_atomic_wc( mapping_wc, offset);
+    if (buffer_y_start == NULL) {
+        printk(" vm.postprocess:mapping buffer error\n");
+        return -1;
+    }
+    if (output_para.v4l2_format == V4L2_PIX_FMT_BGR24||
+                output_para.v4l2_format == V4L2_PIX_FMT_RGB24||
+                output_para.v4l2_format== V4L2_PIX_FMT_RGB565X) {
+        for (i=0; i < output_para.height; i++) {
+            memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.bytesperline);
+            poss+=output_para.bytesperline;
+            posd+= canvas_work_y.width;
+        }
+        io_mapping_unmap_atomic( buffer_y_start );
+
+    } else if (output_para.v4l2_format== V4L2_PIX_FMT_NV12||
+                output_para.v4l2_format== V4L2_PIX_FMT_NV21) {
 #ifdef GE2D_NV
-		unsigned uv_width = output_para.width;
-		unsigned uv_height = output_para.height>>1;
-		posd = 0;
-		for(i=output_para.height;i>0;i--) { /* copy y */
-			memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.width);
-			poss+=output_para.width;
-			posd+= canvas_work_y.width;
-		}
-		io_mapping_unmap_atomic( buffer_y_start );
-
-		posd=0;
-		canvas_read((canvas>>8)&0xff,&canvas_work_u);
-		offset = canvas_work_u.addr - canvas_work_y.addr;
-		buffer_u_start = io_mapping_map_atomic_wc( mapping_wc, offset);
-		for(i=uv_height; i > 0; i--) { /* copy uv */
-			memcpy((void *)(addr+poss), (void *)(buffer_u_start+posd), uv_width);
-			poss += uv_width;
-			posd+= canvas_work_u.width;
-		}
-
-		io_mapping_unmap_atomic( buffer_u_start );
+        unsigned uv_width = output_para.width;
+        unsigned uv_height = output_para.height>>1;
+        posd = 0;
+        for (i = output_para.height; i > 0; i--) { /* copy y */
+            memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.width);
+            poss+=output_para.width;
+            posd+= canvas_work_y.width;
+        }
+        io_mapping_unmap_atomic( buffer_y_start );
+
+        posd=0;
+        canvas_read((canvas>>8)&0xff,&canvas_work_u);
+        offset = canvas_work_u.addr - canvas_work_y.addr;
+        buffer_u_start = io_mapping_map_atomic_wc( mapping_wc, offset);
+        for (i = uv_height; i > 0; i--) { /* copy uv */
+            memcpy((void *)(addr+poss), (void *)(buffer_u_start+posd), uv_width);
+            poss += uv_width;
+            posd += canvas_work_u.width;
+        }
+
+        io_mapping_unmap_atomic( buffer_u_start );
 #else
-		char* dst_buff=NULL;
-		char* src_buff=NULL;
-		char* src2_buff=NULL;
-		canvas_read((canvas>>8)&0xff,&canvas_work_u);
-		poss = posd = 0 ;
-		for(i=0;i<output_para.height;i+=2) { /* copy y */
-			memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.width);
-			poss+=output_para.width;
-			posd+= canvas_work_y.width;
-			memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.width);
-			poss+=output_para.width;
-			posd+= canvas_work_y.width;
-		}	
-		io_mapping_unmap_atomic( buffer_y_start );
-
-		posd=0;
-		canvas_read((canvas>>16)&0xff,&canvas_work_v);
-		offset = canvas_work_u.addr - canvas_work_y.addr;
-		buffer_u_start = io_mapping_map_atomic_wc( mapping_wc, offset);
-		offset = canvas_work_v.addr - canvas_work_y.addr;
-		buffer_v_start = io_mapping_map_atomic_wc( mapping_wc, offset );
-
-		dst_buff= (char*)addr+output_para.width* output_para.height;
-		src_buff = (char*)buffer_u_start;
-		src2_buff= (char*)buffer_v_start;
-		if(output_para.v4l2_format== V4L2_PIX_FMT_NV12) {
-			for(i = 0 ;i < output_para.height/2; i++){
-				interleave_uv(src_buff, src2_buff, dst_buff, output_para.width/2);
-				src_buff +=  canvas_work_u.width;
-				src2_buff += 	canvas_work_v.width;
-				dst_buff += output_para.width;
-			}
-		} else {
-			for(i = 0 ;i < output_para.height/2; i++){
-				interleave_uv(src2_buff, src_buff, dst_buff, output_para.width/2);
-				src_buff +=  canvas_work_u.width;
-				src2_buff += 	canvas_work_v.width;
-				dst_buff += output_para.width;
-			}
-		}
-
-
-		io_mapping_unmap_atomic( buffer_u_start );
-		io_mapping_unmap_atomic( buffer_v_start );
+        char* dst_buff=NULL;
+        char* src_buff=NULL;
+        char* src2_buff=NULL;
+        canvas_read((canvas >> 8) & 0xff, &canvas_work_u);
+        poss = posd = 0 ;
+        for (i = 0; i < output_para.height; i += 2) { /* copy y */
+            memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.width);
+            poss+=output_para.width;
+            posd+= canvas_work_y.width;
+            memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.width);
+            poss+=output_para.width;
+            posd+= canvas_work_y.width;
+        }
+        io_mapping_unmap_atomic( buffer_y_start );
+
+        posd=0;
+        canvas_read((canvas>>16)&0xff,&canvas_work_v);
+        offset = canvas_work_u.addr - canvas_work_y.addr;
+        buffer_u_start = io_mapping_map_atomic_wc( mapping_wc, offset);
+        offset = canvas_work_v.addr - canvas_work_y.addr;
+        buffer_v_start = io_mapping_map_atomic_wc( mapping_wc, offset );
+
+        dst_buff= (char*)addr+output_para.width* output_para.height;
+        src_buff = (char*)buffer_u_start;
+        src2_buff= (char*)buffer_v_start;
+        if (output_para.v4l2_format == V4L2_PIX_FMT_NV12) {
+            for (i = 0 ;i < output_para.height/2; i++) {
+                interleave_uv(src_buff, src2_buff, dst_buff, output_para.width/2);
+                src_buff +=  canvas_work_u.width;
+                src2_buff +=    canvas_work_v.width;
+                dst_buff += output_para.width;
+            }
+        } else {
+            for (i = 0 ; i < output_para.height/2; i++) {
+                interleave_uv(src2_buff, src_buff, dst_buff, output_para.width/2);
+                src_buff +=  canvas_work_u.width;
+                src2_buff +=    canvas_work_v.width;
+                dst_buff += output_para.width;
+            }
+        }
+
+
+        io_mapping_unmap_atomic( buffer_u_start );
+        io_mapping_unmap_atomic( buffer_v_start );
 #endif
-	} else if ( (output_para.v4l2_format == V4L2_PIX_FMT_YUV420)
-			||(output_para.v4l2_format == V4L2_PIX_FMT_YVU420)){
-		int uv_width = output_para.width>>1;
-		int uv_height = output_para.height>>1;
-
-		posd=0;
-		for(i=output_para.height;i>0;i--) { /* copy y */
-			memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.width);
-			poss+=output_para.width;
-			posd+= canvas_work_y.width;
-		}
-		io_mapping_unmap_atomic( buffer_y_start );
-    	
-		posd=0;
-		canvas_read((canvas>>8)&0xff,&canvas_work_u);
-		offset = canvas_work_u.addr - canvas_work_y.addr;
-		buffer_u_start = io_mapping_map_atomic_wc( mapping_wc, offset);
-
-		canvas_read((canvas>>16)&0xff,&canvas_work_v);
-		offset = canvas_work_v.addr - canvas_work_y.addr;
-		buffer_v_start = io_mapping_map_atomic_wc( mapping_wc, offset );
+    } else if ((output_para.v4l2_format == V4L2_PIX_FMT_YUV420)
+            ||(output_para.v4l2_format == V4L2_PIX_FMT_YVU420)) {
+        int uv_width = output_para.width>>1;
+        int uv_height = output_para.height>>1;
+
+        posd=0;
+        for (i = output_para.height; i > 0; i--) { /* copy y */
+            memcpy((void *)(addr+poss),(void *)(buffer_y_start+posd),output_para.width);
+            poss+=output_para.width;
+            posd+= canvas_work_y.width;
+        }
+        io_mapping_unmap_atomic( buffer_y_start );
+
+        posd=0;
+        canvas_read((canvas>>8)&0xff,&canvas_work_u);
+        offset = canvas_work_u.addr - canvas_work_y.addr;
+        buffer_u_start = io_mapping_map_atomic_wc( mapping_wc, offset);
+
+        canvas_read((canvas>>16)&0xff,&canvas_work_v);
+        offset = canvas_work_v.addr - canvas_work_y.addr;
+        buffer_v_start = io_mapping_map_atomic_wc( mapping_wc, offset );
 
 #ifndef GE2D_NV
-		if(output_para.v4l2_format == V4L2_PIX_FMT_YUV420)
+        if (output_para.v4l2_format == V4L2_PIX_FMT_YUV420)
 #else
-		if(output_para.v4l2_format == V4L2_PIX_FMT_YVU420)
+        if (output_para.v4l2_format == V4L2_PIX_FMT_YVU420)
 #endif
-		{
-			for(i=uv_height;i>0;i--) { /* copy y */
-				memcpy((void *)(addr+poss),(void *)(buffer_u_start+posd),uv_width);
-				poss+=uv_width;
-				posd+= canvas_work_u.width;
-			}
-			posd=0;
-			for(i=uv_height;i>0;i--) { /* copy y */
-				memcpy((void *)(addr+poss),(void *)(buffer_v_start+posd),uv_width);
-				poss+=uv_width;
-				posd+= canvas_work_v.width;
-			}
-		}else{
-			for(i=uv_height;i>0;i--) { /* copy v */
-				memcpy((void *)(addr+poss),(void *)(buffer_v_start+posd),uv_width);
-				poss+=uv_width;
-				posd+= canvas_work_v.width;
-			}
-			posd=0;
-			for(i=uv_height;i>0;i--) { /* copy u */
-				memcpy((void *)(addr+poss),(void *)(buffer_u_start+posd),uv_width);
-				poss+=uv_width;
-				posd+= canvas_work_u.width;
-			}
-		}
-		io_mapping_unmap_atomic( buffer_u_start );
-		io_mapping_unmap_atomic( buffer_v_start );
-	}
-	return 0;
+        {
+            for (i = uv_height; i > 0; i--) { /* copy y */
+                memcpy((void *)(addr+poss),(void *)(buffer_u_start+posd),uv_width);
+                poss += uv_width;
+                posd += canvas_work_u.width;
+            }
+            posd=0;
+            for (i = uv_height; i > 0; i--) { /* copy y */
+                memcpy((void *)(addr+poss),(void *)(buffer_v_start+posd),uv_width);
+                poss += uv_width;
+                posd += canvas_work_v.width;
+            }
+        } else {
+            for (i = uv_height; i > 0; i--) { /* copy v */
+                memcpy((void *)(addr+poss),(void *)(buffer_v_start+posd),uv_width);
+                poss += uv_width;
+                posd += canvas_work_v.width;
+            }
+            posd=0;
+            for (i = uv_height; i > 0; i--) { /* copy u */
+                memcpy((void *)(addr+poss),(void *)(buffer_u_start+posd),uv_width);
+                poss += uv_width;
+                posd += canvas_work_u.width;
+            }
+        }
+        io_mapping_unmap_atomic( buffer_u_start );
+        io_mapping_unmap_atomic( buffer_v_start );
+    }
+    return 0;
 }
 
 static struct task_struct *task=NULL;
@@ -1455,110 +1537,110 @@ static struct task_struct *simulate_task_fd=NULL;
 
 static bool is_vf_available(void)
 {
-    return ((local_vf_peek()!=NULL)||(!task_running));
+    return ((local_vf_peek() != NULL) || (!task_running));
 }
 
 /* static int reset_frame = 1; */
 static int vm_task(void *data) {
-	int ret = 0;
-	vframe_t *vf;
-	int src_canvas;
-	//vm_device_t *devp = (vm_device_t*) data;
-	struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1 };
-	ge2d_context_t *context=create_ge2d_work_queue();
-	config_para_ex_t ge2d_config;
+    int ret = 0;
+    vframe_t *vf;
+    int src_canvas;
+    //vm_device_t *devp = (vm_device_t*) data;
+    struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1 };
+    ge2d_context_t *context = create_ge2d_work_queue();
+    config_para_ex_t ge2d_config;
 
 #ifdef CONFIG_AMLCAP_LOG_TIME_USEFORFRAMES
-	struct timeval start;
-	struct timeval end;
-	unsigned long time_use=0;
+    struct timeval start;
+    struct timeval end;
+    unsigned long time_use=0;
 #endif
 
-	memset(&ge2d_config,0,sizeof(config_para_ex_t));
-	amlog_level(LOG_LEVEL_HIGH,"vm task is running\n ");
-	sched_setscheduler(current, SCHED_FIFO, &param);
-	allow_signal(SIGTERM);
-	while(1) {
-		ret = down_interruptible(&vb_start_sema);
-		if (kthread_should_stop()){
-			up(&vb_done_sema);
-			break;
-		}
-
-		/* wait for frame from 656 provider until 500ms runs out */
-		//vf = local_vf_peek();
-		wait_event_interruptible_timeout(frame_ready, is_vf_available(),msecs_to_jiffies(5000));
-                  
-		if(!task_running){
-			up(&vb_done_sema);
-			goto vm_exit;
-			break;
-		}
-
-		/* start to convert frame. */
+    memset(&ge2d_config,0,sizeof(config_para_ex_t));
+    amlog_level(LOG_LEVEL_HIGH,"vm task is running\n ");
+    sched_setscheduler(current, SCHED_FIFO, &param);
+    allow_signal(SIGTERM);
+    while (1) {
+        ret = down_interruptible(&vb_start_sema);
+        if (kthread_should_stop()) {
+            up(&vb_done_sema);
+            break;
+        }
+
+        /* wait for frame from 656 provider until 500ms runs out */
+        //vf = local_vf_peek();
+        wait_event_interruptible_timeout(frame_ready, is_vf_available(),msecs_to_jiffies(5000));
+
+        if (!task_running) {
+            up(&vb_done_sema);
+            goto vm_exit;
+            break;
+        }
+
+        /* start to convert frame. */
 #ifdef CONFIG_AMLCAP_LOG_TIME_USEFORFRAMES
-		do_gettimeofday(&start);
+        do_gettimeofday(&start);
 #endif
-		vf = local_vf_get();
-		if (vf) {
-			src_canvas = vf->canvas0Addr;
+        vf = local_vf_get();
+        if (vf) {
+            src_canvas = vf->canvas0Addr;
 
-			/* step1 convert 422 format to other format.*/
-			if (is_need_ge2d_pre_process())
-				src_canvas = vm_ge2d_pre_process(vf,context,&ge2d_config);
+            /* step1 convert 422 format to other format.*/
+            if (is_need_ge2d_pre_process())
+                src_canvas = vm_ge2d_pre_process(vf,context,&ge2d_config);
 #if 0
-			if (devp->dump == 2) {
-				vm_dump_mem(devp->dump_path, (void *)output_para.vaddr, &output_para);
-				devp->dump = 0;
-			}
+            if (devp->dump == 2) {
+                vm_dump_mem(devp->dump_path, (void *)output_para.vaddr, &output_para);
+                devp->dump = 0;
+            }
 #endif
-			local_vf_put(vf);
+            local_vf_put(vf);
 #ifdef CONFIG_AMLCAP_LOG_TIME_USEFORFRAMES
-			do_gettimeofday(&end);
-			time_use = (end.tv_sec - start.tv_sec)*1000 +
-					(end.tv_usec - start.tv_usec) / 1000;
-			printk("step 1, ge2d use: %ldms\n", time_use);
-			do_gettimeofday(&start);
+            do_gettimeofday(&end);
+            time_use = (end.tv_sec - start.tv_sec)*1000 +
+                    (end.tv_usec - start.tv_usec) / 1000;
+            printk("step 1, ge2d use: %ldms\n", time_use);
+            do_gettimeofday(&start);
 #endif
 
-			/* step2 copy to user memory. */
-			if (is_need_sw_post_process())
-				vm_sw_post_process(src_canvas ,output_para.vaddr);
+            /* step2 copy to user memory. */
+            if (is_need_sw_post_process())
+                vm_sw_post_process(src_canvas ,output_para.vaddr);
 #ifdef CONFIG_AMLCAP_LOG_TIME_USEFORFRAMES
-			do_gettimeofday(&end);
-			time_use = (end.tv_sec - start.tv_sec) * 1000+
-					(end.tv_usec - start.tv_usec) / 1000;
-			printk("step 2, memcpy use: %ldms\n", time_use);
+            do_gettimeofday(&end);
+            time_use = (end.tv_sec - start.tv_sec) * 1000+
+                    (end.tv_usec - start.tv_usec) / 1000;
+            printk("step 2, memcpy use: %ldms\n", time_use);
 #endif
-		}
-		if (kthread_should_stop()){
-			up(&vb_done_sema);
-			break;
-		}
-		up(&vb_done_sema);
-	}
-vm_exit:
-	destroy_ge2d_work_queue(context);
-	while(!kthread_should_stop()){
-	/* 	   may not call stop, wait..
+        }
+        if (kthread_should_stop()) {
+            up(&vb_done_sema);
+            break;
+        }
+        up(&vb_done_sema);
+    }
+vm_exit:
+    destroy_ge2d_work_queue(context);
+    while (!kthread_should_stop()) {
+    /*     may not call stop, wait..
                    it is killed by SIGTERM,eixt on down_interruptible
-		   if not call stop,this thread may on do_exit and
-		   kthread_stop may not work good;
-	*/
-		msleep(10);
-	}
-	return ret;
+           if not call stop,this thread may on do_exit and
+           kthread_stop may not work good;
+    */
+        msleep(10);
+    }
+    return ret;
 }
 
 /*simulate v4l2 device to request filling buffer,only for test use*/
 static int simulate_task(void *data)
 {
-	while (1) {
-		msleep(50);    
-		vm_fill_buffer(NULL,NULL);
-		printk("simulate succeed\n");
-	}
-	return 0;
+    while (1) {
+        msleep(50);
+        vm_fill_buffer(NULL,NULL);
+        printk("simulate succeed\n");
+    }
+    return 0;
 }
 
 /************************************************
@@ -1568,116 +1650,117 @@ static int simulate_task(void *data)
 *************************************************/
 int vm_buffer_init(void)
 {
-	int i;
-	u32 canvas_width, canvas_height;
-	u32 decbuf_size;
-	resource_size_t buf_start;
-	unsigned int buf_size;
-	int buf_num = 0;
-	int local_pool_size = 0;
-
-	get_vm_buf_info(&buf_start,&buf_size, NULL);
-	sema_init(&vb_start_sema,0);
-	sema_init(&vb_done_sema,0);
-
-	if(!buf_start || !buf_size)
-		goto exit;
-
-	for(i=0; i<ARRAY_SIZE(vmdecbuf_size);i++){
-		if( buf_size >= vmdecbuf_size[i])
-			break;
-	}
-	if(i==ARRAY_SIZE(vmdecbuf_size)){
-		printk("vmbuf size=%d less than the smallest vmbuf size%d\n",
-			buf_size, vmdecbuf_size[i-1]);
-		return -1;
-	}
-
-	canvas_width = canvas_config_wh[i].width;//1920;
-	canvas_height = canvas_config_wh[i].height;//1200;
-	decbuf_size = vmdecbuf_size[i];//0x700000;
-	buf_num  = buf_size/decbuf_size;
-
-	if(buf_num > 0)
-		local_pool_size   = 1;
-	else {
-		local_pool_size = 0;
-		printk("need at least one buffer to handle 1920*1080 data.\n");
-	}
-
-	for (i = 0; i < local_pool_size; i++)
-	{
-		canvas_config((VM_DEPTH_16_CANVAS+i),
-			(unsigned long)(buf_start + i * decbuf_size),
-			canvas_width*2, canvas_height,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config((VM_DEPTH_24_CANVAS+i),
-			(unsigned long)(buf_start + i * decbuf_size),
-			canvas_width*3, canvas_height,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config((VM_DEPTH_8_CANVAS_Y+ i),
-			(unsigned long)(buf_start + i*decbuf_size/2),
-			canvas_width, canvas_height,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config(VM_DEPTH_8_CANVAS_UV + i,
-			(unsigned long)(buf_start + (i+1)*decbuf_size/2),
-			canvas_width, canvas_height/2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-
-		canvas_config((VM_DEPTH_8_CANVAS_U + i),
-			(unsigned long)(buf_start + (i+1)*decbuf_size/2),
-			canvas_width/2, canvas_height/2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		canvas_config((VM_DEPTH_8_CANVAS_V + i),
-			(unsigned long)(buf_start + (i+3)*decbuf_size/4),
-			canvas_width/2, canvas_height/2,
-			CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+    int i;
+    u32 canvas_width, canvas_height;
+    u32 decbuf_size;
+    resource_size_t buf_start;
+    unsigned int buf_size;
+    int buf_num = 0;
+    int local_pool_size = 0;
+
+    get_vm_buf_info(&buf_start,&buf_size, NULL);
+    sema_init(&vb_start_sema,0);
+    sema_init(&vb_done_sema,0);
+    mutex_init(&vm_lock);
+
+    if (!buf_start || !buf_size)
+        goto exit;
+
+    for (i = 0; i < ARRAY_SIZE(vmdecbuf_size); i++) {
+        if ( buf_size >= vmdecbuf_size[i])
+            break;
+    }
+    if (i == ARRAY_SIZE(vmdecbuf_size)) {
+        printk("vmbuf size=%d less than the smallest vmbuf size%d\n",
+            buf_size, vmdecbuf_size[i-1]);
+        return -1;
+    }
+
+    canvas_width = canvas_config_wh[i].width;//1920;
+    canvas_height = canvas_config_wh[i].height;//1200;
+    decbuf_size = vmdecbuf_size[i];//0x700000;
+    buf_num  = buf_size/decbuf_size;
+
+    if (buf_num > 0)
+        local_pool_size   = 1;
+    else {
+        local_pool_size = 0;
+        printk("need at least one buffer to handle 1920*1080 data.\n");
+    }
+
+    for (i = 0; i < local_pool_size; i++)
+    {
+        canvas_config((VM_DEPTH_16_CANVAS+i),
+            (unsigned long)(buf_start + i * decbuf_size),
+            canvas_width*2, canvas_height,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config((VM_DEPTH_24_CANVAS+i),
+            (unsigned long)(buf_start + i * decbuf_size),
+            canvas_width*3, canvas_height,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config((VM_DEPTH_8_CANVAS_Y+ i),
+            (unsigned long)(buf_start + i*decbuf_size/2),
+            canvas_width, canvas_height,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config(VM_DEPTH_8_CANVAS_UV + i,
+            (unsigned long)(buf_start + (i+1)*decbuf_size/2),
+            canvas_width, canvas_height/2,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+
+        canvas_config((VM_DEPTH_8_CANVAS_U + i),
+            (unsigned long)(buf_start + (i+1)*decbuf_size/2),
+            canvas_width/2, canvas_height/2,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+        canvas_config((VM_DEPTH_8_CANVAS_V + i),
+            (unsigned long)(buf_start + (i+3)*decbuf_size/4),
+            canvas_width/2, canvas_height/2,
+            CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
-		vfbuf_use[i] = 0;
+        vfbuf_use[i] = 0;
 #endif
-	}
+    }
 exit:
-	return 0;
+    return 0;
 
 }
 
 int start_vm_task(void) {
-	/* init the device. */
-	vm_local_init();
-	if(!task) {
-		task=kthread_create(vm_task, &vm_device,"vm");
-		if(IS_ERR(task)) {
-			amlog_level(LOG_LEVEL_HIGH, "thread creating error.\n");
-			return -1;
-		}
-		init_waitqueue_head(&frame_ready);
-		wake_up_process(task);
-	}
+    /* init the device. */
+    vm_local_init();
+    if (!task) {
+        task=kthread_create(vm_task, &vm_device,"vm");
+        if (IS_ERR(task)) {
+            amlog_level(LOG_LEVEL_HIGH, "thread creating error.\n");
+            return -1;
+        }
+        init_waitqueue_head(&frame_ready);
+        wake_up_process(task);
+    }
     task_running = 1;
     vm_device.task_running = task_running;
-	return 0;
+    return 0;
 }
 
 int start_simulate_task(void)
 {
-	if(!simulate_task_fd) {
-		simulate_task_fd=kthread_create(simulate_task,0,"vm");
-		if(IS_ERR(simulate_task_fd)) {
-			amlog_level(LOG_LEVEL_HIGH, "thread creating error.\n");
-			return -1;
-		}
-		wake_up_process(simulate_task_fd);
-	}
-	return 0;
+    if (!simulate_task_fd) {
+        simulate_task_fd = kthread_create(simulate_task,0,"vm");
+        if (IS_ERR(simulate_task_fd)) {
+            amlog_level(LOG_LEVEL_HIGH, "thread creating error.\n");
+            return -1;
+        }
+        wake_up_process(simulate_task_fd);
+    }
+    return 0;
 }
 
 
-void stop_vm_task(void) {
-    if(task){
+void stop_vm_task(void) {
+    if (task) {
         task_running = 0;
         vm_device.task_running = task_running;
-        send_sig(SIGTERM, task, 1);
-        up(&vb_start_sema);
+        send_sig(SIGTERM, task, 1);
+        up(&vb_start_sema);
         wake_up_interruptible(&frame_ready);
         kthread_stop(task);
         task = NULL;
@@ -1695,14 +1778,14 @@ void stop_vm_task(void) {
 static int vm_enable_flag=0;
 
 int get_vm_status() {
-	return vm_enable_flag;
+    return vm_enable_flag;
 }
 
 void set_vm_status(int flag) {
-	if(flag >= 0)
-		vm_enable_flag=flag;
-	else
-		vm_enable_flag=0;
+    if (flag >= 0)
+        vm_enable_flag = flag;
+    else
+        vm_enable_flag = 0;
 }
 
 /***********************************************************************
@@ -1710,97 +1793,113 @@ void set_vm_status(int flag) {
 * file op section.
 *
 ************************************************************************/
-
-void set_vm_buf_info(resource_size_t start,unsigned int size) {
-	vm_device.buffer_start=start;
-	vm_device.buffer_size=size;
-	vm_device.mapping = io_mapping_create_wc( start, size );
-	amlog_level(LOG_LEVEL_HIGH,"#############%p\n",vm_device.mapping);
-}
-
-
-void unset_vm_buf_info(void)
-{
-    if(vm_device.mapping)
-    {
-        io_mapping_free( vm_device.mapping);
-        vm_device.mapping = 0;
+
+void set_vm_buf_info(resource_size_t start,unsigned int size) {
+    vm_device.buffer_start = start;
+    vm_device.buffer_size = size;
+    vm_device.mapping = io_mapping_create_wc( start, size );
+    amlog_level(LOG_LEVEL_HIGH,"#############%p\n",vm_device.mapping);
+}
+
+void unset_vm_buf_info(void)
+{
+    if (vm_device.mapping)
+    {
+        io_mapping_free( vm_device.mapping);
+        vm_device.mapping = 0;
         vm_device.buffer_start=0;
         vm_device.buffer_size=0;
-    }
-}
-
-void get_vm_buf_info(resource_size_t* start,unsigned int* size,struct io_mapping **mapping) {
-	if(start)
-		*start = vm_device.buffer_start;
-	if(size)
-		*size = vm_device.buffer_size;
-	if( mapping )
-		*mapping = vm_device.mapping;
+    }
+}
+
+void unset_vm_buf_res(vm_init_t* info)
+{
+    if (info->mapping)
+    {
+        io_mapping_free(info->mapping);
+        info->mapping = 0;
+        info->buffer_start = 0;
+    }
+}
+
+void get_vm_buf_info(resource_size_t* start,unsigned int* size,struct io_mapping **mapping) {
+    if (start)
+        *start = vm_device.buffer_start;
+    if (size)
+        *size = vm_device.buffer_size;
+    if ( mapping )
+        *mapping = vm_device.mapping;
 }
 
 /*
 static void vm_dma_flush(unsigned buf_start , unsigned buf_size )
 {
-	if(vm_device.dev){
-		if((buf_start>=vm_device.buffer_start)&&((buf_start+buf_size)<=(vm_device.buffer_start + vm_device.buffer_size)))
-			dma_sync_single_for_device(vm_device.dev,buf_start ,buf_size, DMA_TO_DEVICE);
-	}
+    if (vm_device.dev) {
+        if ((buf_start >= vm_device.buffer_start) && ((buf_start+buf_size) <= (vm_device.buffer_start + vm_device.buffer_size)))
+            dma_sync_single_for_device(vm_device.dev,buf_start ,buf_size, DMA_TO_DEVICE);
+    }
 }
 */
 
-static void vm_cache_flush(unsigned buf_start , unsigned buf_size )
+static void vm_cache_this_flush(unsigned buf_start , unsigned buf_size , vm_init_t* info)
 {
-	if(vm_device.dev){
-		if((buf_start>=vm_device.buffer_start)&&((buf_start+buf_size)<=(vm_device.buffer_start + vm_device.buffer_size)))
-			dma_sync_single_for_cpu(vm_device.dev , buf_start, buf_size, DMA_FROM_DEVICE);
-	}
+    if (vm_device.dev) {
+        if ((buf_start >= info->buffer_start) && ((buf_start+buf_size) <= (info->buffer_start + info->vm_buf_size)))
+            dma_sync_single_for_cpu(vm_device.dev , buf_start, buf_size, DMA_FROM_DEVICE);
+    }
 }
 
+static void vm_cache_flush(unsigned buf_start , unsigned buf_size )
+{
+    if (vm_device.dev) {
+        if ((buf_start >= vm_device.buffer_start) && ((buf_start + buf_size) <= (vm_device.buffer_start + vm_device.buffer_size)))
+            dma_sync_single_for_cpu(vm_device.dev , buf_start, buf_size, DMA_FROM_DEVICE);
+    }
+}
 
 static int vm_open(struct inode *inode, struct file *file)
 {
-	 ge2d_context_t *context=NULL;
-	 amlog_level(LOG_LEVEL_LOW,"open one vm device\n");
-	 file->private_data=context;
-	 vm_device.open_count++;
-	 return 0;
+     ge2d_context_t *context = NULL;
+     amlog_level(LOG_LEVEL_LOW,"open one vm device\n");
+     file->private_data = context;
+     vm_device.open_count++;
+     return 0;
 }
 
 static long vm_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
 {
-	int  ret=0 ;
-	ge2d_context_t *context;
-	void  __user* argp;
-
-	context=(ge2d_context_t *)filp->private_data;
-	argp =(void __user*)args;
-	switch (cmd)
-   	{
-	case VM_IOC_2OSD0:
-		break;
-	case VM_IOC_ENABLE_PP:
-		break;
-	case VM_IOC_CONFIG_FRAME:
-		break;
-	default :
-		return -ENOIOCTLCMD;
-	}
- 	return ret;
+    int  ret=0 ;
+    ge2d_context_t *context;
+    void  __user* argp;
+
+    context = (ge2d_context_t *)filp->private_data;
+    argp = (void __user*)args;
+    switch (cmd)
+    {
+    case VM_IOC_2OSD0:
+        break;
+    case VM_IOC_ENABLE_PP:
+        break;
+    case VM_IOC_CONFIG_FRAME:
+        break;
+    default :
+        return -ENOIOCTLCMD;
+    }
+    return ret;
 }
 
 static int vm_release(struct inode *inode, struct file *file)
 {
-	ge2d_context_t *context=(ge2d_context_t *)file->private_data;
+    ge2d_context_t *context = (ge2d_context_t *)file->private_data;
 
-	if(context && (0==destroy_ge2d_work_queue(context)))
-	{
-		vm_device.open_count--;
+    if (context && (0 == destroy_ge2d_work_queue(context)))
+    {
+        vm_device.open_count--;
 
-		return 0;
-	}
-	amlog_level(LOG_LEVEL_LOW,"release one vm device\n");
-	return -1;
+        return 0;
+    }
+    amlog_level(LOG_LEVEL_LOW,"release one vm device\n");
+    return -1;
 }
 
 /***********************************************************************
@@ -1810,10 +1909,10 @@ static int vm_release(struct inode *inode, struct file *file)
 ************************************************************************/
 
 static const struct file_operations vm_fops = {
-	.owner = THIS_MODULE,
-	.open = vm_open,
-	.unlocked_ioctl = vm_ioctl,
-	.release = vm_release,
+    .owner = THIS_MODULE,
+    .open = vm_open,
+    .unlocked_ioctl = vm_ioctl,
+    .release = vm_release,
 };
 
 static ssize_t vm_attr_show(struct device *dev, struct device_attribute *attr, char *buf)
@@ -1822,7 +1921,7 @@ static ssize_t vm_attr_show(struct device *dev, struct device_attribute *attr, c
         vm_device_t *devp;
 
         devp = dev_get_drvdata(dev);
-        if (0 == devp->task_running){
+        if (0 == devp->task_running) {
                 len += sprintf(buf+len, "vm does not start\n");
                 return len;
         }
@@ -1839,20 +1938,20 @@ static ssize_t vm_attr_store(struct device *dev,struct device_attribute *attr,co
         char *buf_orig, *ps, *token;
         char *parm[6] = {NULL};
 
-        if(!buf)
+        if (!buf)
                 return len;
 
         buf_orig = kstrdup(buf, GFP_KERNEL);
         //printk(KERN_INFO "input cmd : %s",buf_orig);
         devp = dev_get_drvdata(dev);
-        if (0 == devp->task_running){
+        if (0 == devp->task_running) {
                 len += sprintf((char *)buf+len, "vm does not start\n");
                 return len;
         }
 
         ps = buf_orig;
         while (1) {
-                if ( n >=ARRAY_SIZE(parm) ){
+                if (n >= ARRAY_SIZE(parm)) {
                         printk("parm array overflow, n=%d, ARRAY_SIZE(parm)=%d\n", n, ARRAY_SIZE(parm));
                         return len;
                 }
@@ -1864,11 +1963,11 @@ static ssize_t vm_attr_store(struct device *dev,struct device_attribute *attr,co
                 parm[n++] = token;
         }
 
-        if ( 0 == strcmp(parm[0],"before")){
+        if (0 == strcmp(parm[0],"before")) {
                 devp->dump = 1;
                 devp->dump_path = parm[1];
                 printk("this not support\n");
-        } else if ( 0 == strcmp(parm[0],"after")){
+        } else if (0 == strcmp(parm[0],"after")) {
                 devp->dump = 2;
                 devp->dump_path = parm[1];
                 printk("after ge2d processed, store to %s\n", parm[1]);
@@ -1882,124 +1981,188 @@ static DEVICE_ATTR(dump, 0664, vm_attr_show, vm_attr_store);
 
 int init_vm_device(void)
 {
-	int  ret=0;
-
-	strcpy(vm_device.name,"vm");
-	ret=register_chrdev(0,vm_device.name,&vm_fops);
-	if(ret <=0)
-	{
-		amlog_level(LOG_LEVEL_HIGH,"register vm device error\n");
-		return  ret ;
-	}
-	vm_device.major=ret;
-	vm_device.dbg_enable=0;
-	amlog_level(LOG_LEVEL_LOW,"vm_dev major:%d\n",ret);
-
-	vm_device.cla = init_vm_cls();
-	if(vm_device.cla == NULL)
-		return -1;
-	vm_device.dev=device_create(vm_device.cla,NULL,MKDEV(vm_device.major,0)
-						,NULL,vm_device.name);
-	if (IS_ERR(vm_device.dev)) {
-		amlog_level(LOG_LEVEL_HIGH,"create vm device error\n");
-		goto unregister_dev;
-	}
-
-	//dump func
-	device_create_file( vm_device.dev, &dev_attr_dump);
-	vm_device.dump = 0;
-
-	dev_set_drvdata( vm_device.dev,  &vm_device);
-	platform_set_drvdata( vm_device.pdev,  &vm_device);
-
-	if(vm_buffer_init()<0) goto unregister_dev;
+    int  ret=0;
+
+    strcpy(vm_device.name,"vm");
+    ret=register_chrdev(0,vm_device.name,&vm_fops);
+    if (ret <= 0)
+    {
+        amlog_level(LOG_LEVEL_HIGH,"register vm device error\n");
+        return  ret ;
+    }
+    vm_device.major=ret;
+    vm_device.dbg_enable=0;
+    amlog_level(LOG_LEVEL_LOW,"vm_dev major:%d\n",ret);
+
+    vm_device.cla = init_vm_cls();
+    if (vm_device.cla == NULL)
+        return -1;
+    vm_device.dev = device_create(vm_device.cla,NULL,MKDEV(vm_device.major,0)
+                        ,NULL,vm_device.name);
+    if (IS_ERR(vm_device.dev)) {
+        amlog_level(LOG_LEVEL_HIGH,"create vm device error\n");
+        goto unregister_dev;
+    }
+
+    //dump func
+    device_create_file(vm_device.dev, &dev_attr_dump);
+    vm_device.dump = 0;
+
+    dev_set_drvdata(vm_device.dev, &vm_device);
+    platform_set_drvdata(vm_device.pdev, &vm_device);
+
+    if (vm_buffer_init() < 0) goto unregister_dev;
 #ifndef CONFIG_AMLOGIC_VM_DISABLE_VIDEOLAYER
-	vf_provider_init(&vm_vf_prov, PROVIDER_NAME ,&vm_vf_provider, NULL);	
+    vf_provider_init(&vm_vf_prov, PROVIDER_NAME ,&vm_vf_provider, NULL);
 #endif
-	//vf_reg_provider(&vm_vf_prov);
-	vf_receiver_init(&vm_vf_recv, RECEIVER_NAME, &vm_vf_receiver, NULL);
-	vf_reg_receiver(&vm_vf_recv);
-	return 0;
+    //vf_reg_provider(&vm_vf_prov);
+    vf_receiver_init(&vm_vf_recv, RECEIVER_NAME, &vm_vf_receiver, NULL);
+    vf_reg_receiver(&vm_vf_recv);
+    return 0;
 
 unregister_dev:
-	class_unregister(vm_device.cla);
-	return -1;
+    class_unregister(vm_device.cla);
+    return -1;
 }
 
 int uninit_vm_device(void)
 {
-	stop_vm_task();
-	if(vm_device.cla)
-	{
-		if(vm_device.dev)
-		device_destroy(vm_device.cla, MKDEV(vm_device.major, 0));
-		vm_device.dev = NULL;
-		class_unregister(vm_device.cla);
-	}
-
-	unregister_chrdev(vm_device.major, vm_device.name);
-	return  0;
-}
-
-
-#ifdef CONFIG_CMA
-void set_vm_buf_info(resource_size_t start,unsigned int size);
-void unset_vm_buf_info(void);
-
-static size_t vm_buf_size;
-static struct page *vm_pages;
-
-int vm_init_buf(size_t size)
-{
-
-    if(size ==0)
-        return -1;
-
-    if(vm_pages && vm_buf_size != 0)
-    {
-        pr_warn("%s cma space already in use, phys %d size %dk\n", __func__, page_to_phys(vm_pages), size/1024);
-        dma_release_from_contiguous(&vm_device.pdev->dev, vm_pages, vm_buf_size/PAGE_SIZE); 
-    }
-
-    vm_pages = dma_alloc_from_contiguous(&vm_device.pdev->dev, size/PAGE_SIZE, 0);
-    if(vm_pages)
-    {
-        dma_addr_t phys;
-        phys = page_to_phys(vm_pages);
-        pr_info("%s: allocating phys %d, size %dk\n", __func__, phys, size/1024);
-        set_vm_buf_info(phys, size);
-        vm_buf_size = size;
-        return 0;
-    }
-    else
-    {
-        pr_err("CMA failed to allocate dma buffer\n");
-        return -ENOMEM;
-    }
-}
-
-EXPORT_SYMBOL(vm_init_buf);
-
-void vm_deinit_buf()
-{
-    if(0 == vm_buf_size)
-    {
-        pr_warn("vm buf size equals 0\n");
-        return;
-    }
-    unset_vm_buf_info();
-    if(vm_pages)
-    {
-        dma_release_from_contiguous(&vm_device.pdev->dev, vm_pages, vm_buf_size/PAGE_SIZE); 
-        vm_buf_size = 0;
-    }
-}
-
-EXPORT_SYMBOL(vm_deinit_buf);
-#endif
-
-
-
+    stop_vm_task();
+    if (vm_device.cla)
+    {
+        if (vm_device.dev)
+        device_destroy(vm_device.cla, MKDEV(vm_device.major, 0));
+        vm_device.dev = NULL;
+        class_unregister(vm_device.cla);
+    }
+
+    unregister_chrdev(vm_device.major, vm_device.name);
+    return  0;
+}
+
+
+#ifdef CONFIG_CMA
+void set_vm_buf_info(resource_size_t start,unsigned int size);
+void unset_vm_buf_info(void);
+void unset_vm_buf_res(vm_init_t* info);
+
+static size_t vm_buf_size;
+static struct page *vm_pages;
+
+int vm_init_buf(size_t size)
+{
+    if (size == 0)
+        return -1;
+
+    if (vm_pages && vm_buf_size != 0)
+    {
+        pr_warn("%s cma space already in use, phys %d size %dk\n", __func__, page_to_phys(vm_pages), size/1024);
+        dma_release_from_contiguous(&vm_device.pdev->dev, vm_pages, vm_buf_size/PAGE_SIZE);
+    }
+    vm_pages = dma_alloc_from_contiguous(&vm_device.pdev->dev, size/PAGE_SIZE, 0);
+    if (vm_pages)
+    {
+        dma_addr_t phys;
+        phys = page_to_phys(vm_pages);
+        pr_info("%s: allocating phys %d, size %dk\n", __func__, phys, size/1024);
+        set_vm_buf_info(phys, size);
+        vm_buf_size = size;
+        return 0;
+    }
+    else
+    {
+        pr_err("CMA failed to allocate dma buffer\n");
+        return -ENOMEM;
+    }
+}
+EXPORT_SYMBOL(vm_init_buf);
+
+void vm_deinit_buf(void)
+{
+    if (0 == vm_buf_size)
+    {
+        pr_warn("vm buf size equals 0\n");
+        return;
+    }
+    unset_vm_buf_info();
+    if (vm_pages)
+    {
+        dma_release_from_contiguous(&vm_device.pdev->dev, vm_pages, vm_buf_size/PAGE_SIZE);
+        vm_buf_size = 0;
+    }
+}
+EXPORT_SYMBOL(vm_deinit_buf);
+#endif
+
+#ifdef CONFIG_CMA
+int vm_init_resource(size_t size, vm_init_t* info)
+{
+    if (size == 0)
+        return -1;
+
+    if (info->vm_pages && info->vm_buf_size != 0)
+    {
+        pr_warn("%s cma space already in use, phys %d size %dk\n",__func__, page_to_phys(info->vm_pages), size/1024);
+        dma_release_from_contiguous(&vm_device.pdev->dev, info->vm_pages, info->vm_buf_size/PAGE_SIZE);
+    }
+    info->vm_pages = dma_alloc_from_contiguous(&vm_device.pdev->dev, size/PAGE_SIZE, 0);
+    if (info->vm_pages)
+    {
+        dma_addr_t phys;
+        phys = page_to_phys(info->vm_pages);
+        pr_info("%s: allocating phys %d, size %dk\n", __func__, phys, size/1024);
+        info->buffer_start = phys;
+        info->vm_buf_size = size;
+        info->mapping = io_mapping_create_wc( phys, size );
+        info->mem_alloc_succeed = true;
+        mutex_lock(&vm_lock);
+        if (!isvmused) {
+            info->isused = true;
+            isvmused = true;
+        } else {
+            info->isused = false;
+        }
+        mutex_unlock(&vm_lock);
+        return 0;
+    }
+    else
+    {
+        info->mem_alloc_succeed = false;
+        pr_err("CMA failed to allocate dma buffer\n");
+        return -ENOMEM;
+    }
+}
+
+EXPORT_SYMBOL(vm_init_resource);
+
+void vm_deinit_resource(vm_init_t* info)
+{
+    mutex_lock(&vm_lock);
+    isvmused = false;
+    mutex_unlock(&vm_lock);
+    if (0 == info->vm_buf_size)
+    {
+        pr_warn("vm buf size equals 0\n");
+        return;
+    }
+    unset_vm_buf_res(info);
+
+    if (info->vm_pages)
+    {
+        dma_release_from_contiguous(&vm_device.pdev->dev, info->vm_pages, info->vm_buf_size/PAGE_SIZE);
+        info->vm_buf_size = 0;
+        info->vm_pages = NULL;
+        info->isused = false;
+        info->mem_alloc_succeed = false;
+    }
+}
+
+EXPORT_SYMBOL(vm_deinit_resource);
+
+#endif
+
+
+
 /*******************************************************************
  *
  * interface for Linux driver
@@ -2012,23 +2175,23 @@ MODULE_AMLOG(AMLOG_DEFAULT_LEVEL, 0xff, LOG_LEVEL_DESC, LOG_MASK_DESC);
 static int vm_driver_probe(struct platform_device *pdev)
 {
 #ifndef CONFIG_CMA
-	phys_addr_t buf_start;
-	unsigned int buf_size;
-//	struct resource *mem;
+    phys_addr_t buf_start;
+    unsigned int buf_size;
+//  struct resource *mem;
     int idx;
-
+
 #if 0
-	if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0)))
-	{
-		buf_start = 0;
-		buf_size = 0;
-	} else {
-		buf_start = (char *)mem->start;
-		buf_size = mem->end - mem->start + 1;
-	}
+    if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0)))
+    {
+        buf_start = 0;
+        buf_size = 0;
+    } else {
+        buf_start = (char *)mem->start;
+        buf_size = mem->end - mem->start + 1;
+    }
 #else
      idx = find_reserve_block(pdev->dev.of_node->name,0);
-     if(idx < 0){
+     if (idx < 0) {
          buf_start = 0;
          buf_size = 0;
          amlog_level(LOG_LEVEL_HIGH, "vm memory resource undefined.\n");
@@ -2038,28 +2201,28 @@ static int vm_driver_probe(struct platform_device *pdev)
          buf_start = (phys_addr_t)get_reserve_block_addr(idx);
          buf_size = (unsigned int)get_reserve_block_size(idx);
      }
-#endif 
-	set_vm_buf_info(buf_start,buf_size);
-#endif
-
-
-	vm_device.pdev = pdev;
-	init_vm_device();
-	return 0;
+#endif
+    set_vm_buf_info(buf_start,buf_size);
+#endif
+
+
+    vm_device.pdev = pdev;
+    init_vm_device();
+    return 0;
 }
 
 static int vm_drv_remove(struct platform_device *plat_dev)
 {
-	uninit_vm_device();
-	io_mapping_free( vm_device.mapping);
-	return 0;
+    uninit_vm_device();
+    io_mapping_free(vm_device.mapping);
+    return 0;
 }
 
 #ifdef CONFIG_USE_OF
-static const struct of_device_id amlogic_vm_dt_match[]={
-	{	.compatible = "amlogic,vm",
-	},
-	{},
+static const struct of_device_id amlogic_vm_dt_match[] = {
+    {   .compatible = "amlogic,vm",
+    },
+    {},
 };
 #else
 #define amlogic_vm_dt_match NULL
@@ -2067,35 +2230,35 @@ static const struct of_device_id amlogic_vm_dt_match[]={
 
 /* general interface for a linux driver .*/
 static struct platform_driver vm_drv = {
-	.probe  = vm_driver_probe,
-	.remove = vm_drv_remove,
-	.driver = {
-		.name = "vm",
-		.owner = THIS_MODULE,
-		.of_match_table = amlogic_vm_dt_match,
-	}
+    .probe  = vm_driver_probe,
+    .remove = vm_drv_remove,
+    .driver = {
+        .name = "vm",
+        .owner = THIS_MODULE,
+        .of_match_table = amlogic_vm_dt_match,
+    }
 };
 
 static int __init
 vm_init_module(void)
 {
-	int err;
+    int err;
 
-
-	amlog_level(LOG_LEVEL_HIGH,"vm_init\n");
-	if ((err = platform_driver_register(&vm_drv))) {
-		printk(KERN_ERR "Failed to register vm driver (error=%d\n", err);
-		return err;
-	}
 
-	return err;
+    amlog_level(LOG_LEVEL_HIGH,"vm_init\n");
+    if ((err = platform_driver_register(&vm_drv))) {
+        printk(KERN_ERR "Failed to register vm driver (error=%d\n", err);
+        return err;
+    }
+
+    return err;
 }
 
 static void __exit
 vm_remove_module(void)
 {
-	platform_driver_unregister(&vm_drv);
-	amlog_level(LOG_LEVEL_HIGH,"vm module removed.\n");
+    platform_driver_unregister(&vm_drv);
+    amlog_level(LOG_LEVEL_HIGH,"vm module removed.\n");
 }
 
 module_init(vm_init_module);
diff --git a/drivers/amlogic/camera/sp0838.c b/drivers/amlogic/camera/sp0838.c
index c579624ef6f9..288066ee9e99 100755
--- a/drivers/amlogic/camera/sp0838.c
+++ b/drivers/amlogic/camera/sp0838.c
@@ -30,6 +30,7 @@
 #include <linux/highmem.h>
 #include <linux/freezer.h>
 #include <media/videobuf-res.h>
+#include <media/videobuf-vmalloc.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 #include <linux/wakelock.h>
@@ -116,7 +117,7 @@
 #define SP0838_CAMERA_MINOR_VERSION 7
 #define SP0838_CAMERA_RELEASE 0
 #define SP0838_CAMERA_VERSION \
-	KERNEL_VERSION(SP0838_CAMERA_MAJOR_VERSION, SP0838_CAMERA_MINOR_VERSION, SP0838_CAMERA_RELEASE)
+    KERNEL_VERSION(SP0838_CAMERA_MAJOR_VERSION, SP0838_CAMERA_MINOR_VERSION, SP0838_CAMERA_RELEASE)
 
 MODULE_DESCRIPTION("sp0838 On Board");
 MODULE_AUTHOR("amlogic-sh");
@@ -148,112 +149,112 @@ static struct vdin_v4l2_ops_s *vops;
 /* supported controls */
 static struct v4l2_queryctrl sp0838_qctrl[] = {
 {
-		.id            = V4L2_CID_DO_WHITE_BALANCE,
-		.type          = V4L2_CTRL_TYPE_MENU,
-		.name          = "white balance",
-		.minimum       = 0,
-		.maximum       = 6,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_EXPOSURE,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "exposure",
-		.minimum       = 0,
-		.maximum       = 8,
-		.step          = 0x1,
-		.default_value = 4,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_COLORFX,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "effect",
-		.minimum       = 0,
-		.maximum       = 6,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_WHITENESS,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "banding",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_BLUE_BALANCE,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "scene mode",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_HFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on horizontal",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_VFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on vertical",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_ZOOM_ABSOLUTE,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Zoom, Absolute",
-		.minimum       = 100,
-		.maximum       = 300,
-		.step          = 20,
-		.default_value = 100,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id		= V4L2_CID_ROTATE,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-		.name		= "Rotate",
-		.minimum	= 0,
-		.maximum	= 270,
-		.step		= 90,
-		.default_value	= 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}
+        .id            = V4L2_CID_DO_WHITE_BALANCE,
+        .type          = V4L2_CTRL_TYPE_MENU,
+        .name          = "white balance",
+        .minimum       = 0,
+        .maximum       = 6,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_EXPOSURE,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "exposure",
+        .minimum       = 0,
+        .maximum       = 8,
+        .step          = 0x1,
+        .default_value = 4,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_COLORFX,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "effect",
+        .minimum       = 0,
+        .maximum       = 6,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_WHITENESS,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "banding",
+        .minimum       = 0,
+        .maximum       = 1,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_BLUE_BALANCE,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "scene mode",
+        .minimum       = 0,
+        .maximum       = 1,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_HFLIP,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "flip on horizontal",
+        .minimum       = 0,
+        .maximum       = 1,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_VFLIP,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "flip on vertical",
+        .minimum       = 0,
+        .maximum       = 1,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_ZOOM_ABSOLUTE,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "Zoom, Absolute",
+        .minimum       = 100,
+        .maximum       = 300,
+        .step          = 20,
+        .default_value = 100,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id     = V4L2_CID_ROTATE,
+        .type       = V4L2_CTRL_TYPE_INTEGER,
+        .name       = "Rotate",
+        .minimum    = 0,
+        .maximum    = 270,
+        .step       = 90,
+        .default_value  = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    }
 };
 
 static struct v4l2_frmivalenum sp0838_frmivalenum[]={
     {
-        .index 		= 0,
-        .pixel_format	= V4L2_PIX_FMT_NV21,
-        .width		= 640,
-        .height		= 480,
-        .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+        .index      = 0,
+        .pixel_format   = V4L2_PIX_FMT_NV21,
+        .width      = 640,
+        .height     = 480,
+        .type       = V4L2_FRMIVAL_TYPE_DISCRETE,
         {
-            .discrete	={
-                .numerator	= 1,
-                .denominator	= 15,
+            .discrete   ={
+                .numerator  = 1,
+                .denominator    = 15,
             }
         }
     },{
-        .index 		= 1,
-        .pixel_format	= V4L2_PIX_FMT_NV21,
-        .width		= 1600,
-        .height		= 1200,
-        .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+        .index      = 1,
+        .pixel_format   = V4L2_PIX_FMT_NV21,
+        .width      = 1600,
+        .height     = 1200,
+        .type       = V4L2_FRMIVAL_TYPE_DISCRETE,
         {
-            .discrete	={
-                .numerator	= 1,
-                .denominator	= 5,
+            .discrete   ={
+                .numerator  = 1,
+                .denominator    = 5,
             }
         }
     },
@@ -315,11 +316,11 @@ typedef struct {
 
 sp0838_qmenu_set_t sp0838_qmenu_set[] = {
     {
-        .id         	= V4L2_CID_DO_WHITE_BALANCE,
+        .id             = V4L2_CID_DO_WHITE_BALANCE,
         .num            = ARRAY_SIZE(sp0838_qmenu_wbmode),
         .sp0838_qmenu   = sp0838_qmenu_wbmode,
     },{
-        .id         	= V4L2_CID_POWER_LINE_FREQUENCY,
+        .id             = V4L2_CID_POWER_LINE_FREQUENCY,
         .num            = ARRAY_SIZE(sp0838_qmenu_anti_banding_mode),
         .sp0838_qmenu   = sp0838_qmenu_anti_banding_mode,
     },
@@ -328,513 +329,514 @@ sp0838_qmenu_set_t sp0838_qmenu_set[] = {
 static int vidioc_querymenu(struct file *file, void *priv,
                 struct v4l2_querymenu *a)
 {
-	int i, j;
-
-	for (i = 0; i < ARRAY_SIZE(sp0838_qmenu_set); i++)
-	if (a->id && a->id == sp0838_qmenu_set[i].id) {
-	    for(j = 0; j < sp0838_qmenu_set[i].num; j++)
-		if (a->index == sp0838_qmenu_set[i].sp0838_qmenu[j].index) {
-			memcpy(a, &( sp0838_qmenu_set[i].sp0838_qmenu[j]),
-				sizeof(*a));
-			return (0);
-		}
-	}
+    int i, j;
+
+    for (i = 0; i < ARRAY_SIZE(sp0838_qmenu_set); i++)
+    if (a->id && a->id == sp0838_qmenu_set[i].id) {
+        for (j = 0; j < sp0838_qmenu_set[i].num; j++)
+        if (a->index == sp0838_qmenu_set[i].sp0838_qmenu[j].index) {
+            memcpy(a, &( sp0838_qmenu_set[i].sp0838_qmenu[j]),
+                sizeof(*a));
+            return (0);
+        }
+    }
 
-	return -EINVAL;
+    return -EINVAL;
 }
 #define dprintk(dev, level, fmt, arg...) \
-	v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
+    v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
 
 /* ------------------------------------------------------------------
-	Basic structures
+    Basic structures
    ------------------------------------------------------------------*/
 
 struct sp0838_fmt {
-	char  *name;
-	u32   fourcc;          /* v4l2 format id */
-	int   depth;
+    char  *name;
+    u32   fourcc;          /* v4l2 format id */
+    int   depth;
 };
 
 static struct sp0838_fmt formats[] = {
-	{
-		.name     = "RGB565 (BE)",
-		.fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
-		.depth    = 16,
-	},
-
-	{
-		.name     = "RGB888 (24)",
-		.fourcc   = V4L2_PIX_FMT_RGB24, /* 24  RGB-8-8-8 */
-		.depth    = 24,
-	},
-	{
-		.name     = "BGR888 (24)",
-		.fourcc   = V4L2_PIX_FMT_BGR24, /* 24  BGR-8-8-8 */
-		.depth    = 24,
-	},
-	{
-		.name     = "12  Y/CbCr 4:2:0",
-		.fourcc   = V4L2_PIX_FMT_NV12,
-		.depth    = 12,
-	},
-	{
-		.name     = "12  Y/CbCr 4:2:0",
-		.fourcc   = V4L2_PIX_FMT_NV21,
-		.depth    = 12,
-	},
-	{
-		.name     = "YUV420P",
-		.fourcc   = V4L2_PIX_FMT_YUV420,
-		.depth    = 12,
-	},
-	{
-		.name     = "YVU420P",
-		.fourcc   = V4L2_PIX_FMT_YVU420,
-		.depth    = 12,
-	}
+    {
+        .name     = "RGB565 (BE)",
+        .fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
+        .depth    = 16,
+    },
+
+    {
+        .name     = "RGB888 (24)",
+        .fourcc   = V4L2_PIX_FMT_RGB24, /* 24  RGB-8-8-8 */
+        .depth    = 24,
+    },
+    {
+        .name     = "BGR888 (24)",
+        .fourcc   = V4L2_PIX_FMT_BGR24, /* 24  BGR-8-8-8 */
+        .depth    = 24,
+    },
+    {
+        .name     = "12  Y/CbCr 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV12,
+        .depth    = 12,
+    },
+    {
+        .name     = "12  Y/CbCr 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV21,
+        .depth    = 12,
+    },
+    {
+        .name     = "YUV420P",
+        .fourcc   = V4L2_PIX_FMT_YUV420,
+        .depth    = 12,
+    },
+    {
+        .name     = "YVU420P",
+        .fourcc   = V4L2_PIX_FMT_YVU420,
+        .depth    = 12,
+    }
 };
 
-static struct sp0838_fmt *get_format(struct v4l2_format *f){
-	struct sp0838_fmt *fmt;
-	unsigned int k;
+static struct sp0838_fmt *get_format(struct v4l2_format *f) {
+    struct sp0838_fmt *fmt;
+    unsigned int k;
 
-	for (k = 0; k < ARRAY_SIZE(formats); k++) {
-		fmt = &formats[k];
-		if (fmt->fourcc == f->fmt.pix.pixelformat)
-			break;
-	}
+    for (k = 0; k < ARRAY_SIZE(formats); k++) {
+        fmt = &formats[k];
+        if (fmt->fourcc == f->fmt.pix.pixelformat)
+            break;
+    }
 
-	if (k == ARRAY_SIZE(formats))
-		return NULL;
+    if (k == ARRAY_SIZE(formats))
+        return NULL;
 
-	return &formats[k];
+    return &formats[k];
 }
 
 struct sg_to_addr {
-	int pos;
-	struct scatterlist *sg;
+    int pos;
+    struct scatterlist *sg;
 };
 
 /* buffer for one video frame */
 struct sp0838_buffer {
-	/* common v4l buffer stuff -- must be first */
-	struct videobuf_buffer vb;
+    /* common v4l buffer stuff -- must be first */
+    struct videobuf_buffer vb;
+
+    struct sp0838_fmt        *fmt;
 
-	struct sp0838_fmt        *fmt;
-	
-	unsigned int canvas_id;
+    unsigned int canvas_id;
 };
 
 struct sp0838_dmaqueue {
-	struct list_head       active;
-
-	/* thread for generating video stream*/
-	struct task_struct         *kthread;
-	wait_queue_head_t          wq;
-	/* Counters to control fps rate */
-	int                        frame;
-	int                        ini_jiffies;
+    struct list_head       active;
+
+    /* thread for generating video stream*/
+    struct task_struct         *kthread;
+    wait_queue_head_t          wq;
+    /* Counters to control fps rate */
+    int                        frame;
+    int                        ini_jiffies;
 };
 
 static LIST_HEAD(sp0838_devicelist);
 
 struct sp0838_device {
-	struct list_head			sp0838_devicelist;
-	struct v4l2_subdev			sd;
-	struct v4l2_device			v4l2_dev;
+    struct list_head            sp0838_devicelist;
+    struct v4l2_subdev          sd;
+    struct v4l2_device          v4l2_dev;
 
-	spinlock_t                 slock;
-	struct mutex				mutex;
+    spinlock_t                 slock;
+    struct mutex                mutex;
 
-	int                        users;
+    int                        users;
 
-	/* various device info */
-	struct video_device        *vdev;
+    /* various device info */
+    struct video_device        *vdev;
 
-	struct sp0838_dmaqueue       vidq;
+    struct sp0838_dmaqueue       vidq;
 
-	/* Several counters */
-	unsigned long              jiffies;
+    /* Several counters */
+    unsigned long              jiffies;
 
-	/* Input Number */
-	int			   input;
+    /* Input Number */
+    int            input;
 
-	/* platform device data from board initting. */
-	aml_cam_info_t  cam_info;
-	
-	/* wake lock */
-	struct wake_lock	wake_lock;
+    /* platform device data from board initting. */
+    aml_cam_info_t  cam_info;
 
-	/* Control 'registers' */
-	int 			   qctl_regs[ARRAY_SIZE(sp0838_qctrl)];
+    /* wake lock */
+    struct wake_lock    wake_lock;
+
+    /* Control 'registers' */
+    int                qctl_regs[ARRAY_SIZE(sp0838_qctrl)];
+    vm_init_t vminfo;
 };
 
 static inline struct sp0838_device *to_dev(struct v4l2_subdev *sd)
 {
-	return container_of(sd, struct sp0838_device, sd);
+    return container_of(sd, struct sp0838_device, sd);
 }
 
 struct sp0838_fh {
-	struct sp0838_device            *dev;
-
-	/* video capture */
-	struct sp0838_fmt            *fmt;
-	unsigned int               width, height;
-	struct videobuf_queue      vb_vidq;
-
-	struct videobuf_res_privdata res;
-	enum v4l2_buf_type         type;
-	int			   input; 	/* Input Number on bars */
-	int  stream_on;
-	unsigned int		f_flags;
+    struct sp0838_device            *dev;
+
+    /* video capture */
+    struct sp0838_fmt            *fmt;
+    unsigned int               width, height;
+    struct videobuf_queue      vb_vidq;
+
+    struct videobuf_res_privdata res;
+    enum v4l2_buf_type         type;
+    int            input;   /* Input Number on bars */
+    int  stream_on;
+    unsigned int        f_flags;
 };
 
 /*static inline struct sp0838_fh *to_fh(struct sp0838_device *dev)
 {
-	return container_of(dev, struct sp0838_fh, dev);
+    return container_of(dev, struct sp0838_fh, dev);
 }*/
 
-static struct v4l2_frmsize_discrete sp0838_prev_resolution[]= //should include 320x240 and 640x480, those two size are used for recording
+static struct v4l2_frmsize_discrete sp0838_prev_resolution[] = //should include 320x240 and 640x480, those two size are used for recording
 {
-	{320,240},
-	{352,288},
-	{640,480},
+    {176,144},
+    {320,240},
+    {352,288},
+    {640,480},
 };
 
-static struct v4l2_frmsize_discrete sp0838_pic_resolution[]=
+static struct v4l2_frmsize_discrete sp0838_pic_resolution[] =
 {
-	{640,480},
+    {640,480},
 };
 
 /* ------------------------------------------------------------------
-	reg spec of SP0838
+    reg spec of SP0838
    ------------------------------------------------------------------*/
 
 struct aml_camera_i2c_fig1_s SP0838_script[] = {
 //INIT
-	
-	{0xfd,0x00},
-	{0x1B,0x02},
-	{0x27,0xe8},
-	{0x28,0x0B},
-	{0x32,0x00},
-	{0x22,0xc0},
-	{0x26,0x10},
-	{0x31,0x10},
-	{0x5f,0x11},
-	{0xfd,0x01},
-	{0x25,0x1a},
-	{0x26,0xfb},
-	{0x28,SP0838_P1_0x28},
-	{0x29,SP0838_P1_0x29},
-	{0xfd,0x00},
-	{0xe7,0x03},
-	{0xe7,0x00},
-	{0xfd,0x01},
-	{0x31,0x00},
-	{0x32,0x18},
-	{0x4d,0xdc},
-	{0x4e,0x53},
-	{0x41,0x8c},
-	{0x42,0x57},
-	{0x55,0xff},
-	{0x56,0x00},
-	{0x59,0x82},
-	{0x5a,0x00},
-	{0x5d,0xff},
-	{0x5e,0x6f},
-	{0x57,0xff},
-	{0x58,0x00},
-	{0x5b,0xff},
-	{0x5c,0xa8},
-	{0x5f,0x75},
-	{0x60,0x00},
-	/*{0x2d,0x00},
-	{0x2e,0x00},
-	{0x30,0x00},
-	{0x33,0x00},
-	{0x34,0x00},
-	{0x37,0x00},
-	{0x38,0x00},*/
-	{0x2f,0x80},
-	{0xfd,0x00},
-	{0x33,0x6f},
-	{0x51,0x3f},
-	{0x52,0x09},
-	{0x53,0x00},
-	{0x54,0x00},
-	{0x55,0x10},
-	{0x4f,0x08},
-	{0x50,0x08},
-	{0x57,SP0838_P0_0x57},//Raw filter debut start
-	{0x58,SP0838_P0_0x58},
-	{0x59,SP0838_P0_0x59},
-	{0x56,SP0838_P0_0x56},
-	{0x5a,SP0838_P0_0x5a},
-	{0x5b,SP0838_P0_0x5b},
-	{0x5c,SP0838_P0_0x5c},//Raw filter debut end 
-	{0x65,SP0838_P0_0x65},//Sharpness debug start
-	{0x66,SP0838_P0_0x66},
-	{0x67,SP0838_P0_0x67},
-	{0x68,SP0838_P0_0x68},
-	{0x69,0x7f},
-	{0x6a,0x01},
-	{0x6b,SP0838_P0_0x6b},
-	{0x6c,SP0838_P0_0x6c},
-	{0x6d,SP0838_P0_0x6d},//Edge gain normal
-	{0x6e,SP0838_P0_0x6e},//Edge gain normal
-	{0x6f,0x7f},
-	{0x70,0x01},
-	{0x71,SP0838_P0_0x71}, //          
-	{0x72,SP0838_P0_0x72}, //        
-	{0x73,SP0838_P0_0x73}, //    
-	{0x74,SP0838_P0_0x74}, //    
-	{0x75,0x7f},
-	{0x76,0x01},
-	{0xcb,0x07},
-	{0xcc,0x04},
-	{0xce,0xff},
-	{0xcf,0x10},
-	{0xd0,0x20},
-	{0xd1,0x00},
-	{0xd2,0x1c},
-	{0xd3,0x16},
-	{0xd4,0x00},
-	{0xd6,0x1c},
-	{0xd7,0x16},
-	{0xdd,SP0838_P0_0xdd},//Contrast
-	{0xde,SP0838_P0_0xde},//HEQ&Saturation debug end
-	#if 0
-	{0x7f,0xd7},
-	{0x80,0xbc},
-	{0x81,0xed},
-	{0x82,0xd7},
-	{0x83,0xd4},
-	{0x84,0xd6},
-	{0x85,0xff},
-	{0x86,0x89},
-	{0x87,0xf8},
-	{0x88,0x3c},
-	{0x89,0x33},
-	{0x8a,0x0f},
-	#else //sp_yc 20140626
-	{0x7f,SP0838_P0_0x7f},//Color Correction start
-	{0x80,0xbc},
-	{0x81,0x00},
-	{0x82,0xd7},
-	{0x83,0xf0},
-	{0x84,0xb9},
-	{0x85,0xff},
-	{0x86,0x89},
-	{0x87,SP0838_P0_0x87},                        
-	{0x88,0x0c},
-	{0x89,0x33},
-	{0x8a,0x0f},
-	#endif
-	{0x8b,0x0 },
-	{0x8c,0x1a},
-	{0x8d,0x29},
-	{0x8e,0x41},
-	{0x8f,0x62},
-	{0x90,0x7c},
-	{0x91,0x90},
-	{0x92,0xa2},
-	{0x93,0xaf},
-	{0x94,0xbc},
-	{0x95,0xc5},
-	{0x96,0xcd},
-	{0x97,0xd5},
-	{0x98,0xdd},
-	{0x99,0xe5},
-	{0x9a,0xed},
-	{0x9b,0xf5},
-	{0xfd,0x01},
-	{0x8d,0xfd},
-	{0x8e,0xff},
-	{0xfd,0x00},
-	{0xca,0xcf},
-	{0xd8,SP0838_P0_0xd8},//UV outdoor
-	{0xd9,SP0838_P0_0xd9},//UV indoor 
-	{0xda,SP0838_P0_0xda},//UV dummy
-	{0xdb,SP0838_P0_0xdb},//UV lowlight
-	{0xb9,0x00},
-	{0xba,0x04},
-	{0xbb,0x08},
-	{0xbc,0x10},
-	{0xbd,0x20},
-	{0xbe,0x30},
-	{0xbf,0x40},
-	{0xc0,0x50},
-	{0xc1,0x60},
-	{0xc2,0x70},
-	{0xc3,0x80},
-	{0xc4,0x90},
-	{0xc5,0xA0},
-	{0xc6,0xB0},
-	{0xc7,0xC0},
-	{0xc8,0xD0},
-	{0xc9,0xE0},
-	{0xfd,0x01},
-	{0x89,0xf0},
-	{0x8a,0xff},
-	{0xfd,0x00},
-	{0xe8,0x30},
-	{0xe9,0x30},
-	{0xea,0x40},
-	{0xf4,0x1b},
-	{0xf5,0x80},
-	{0xf7,SP0838_P0_0xf7},//AE target
-	{0xf8,SP0838_P0_0xf8},
-	{0xf9,SP0838_P0_0xf9},//AE target 
-	{0xfa,SP0838_P0_0xfa},
-	{0xfd,0x01},
-	{0x09,0x31},
-	{0x0a,0x85},
-	{0x0b,0x0b},
-	{0x14,0x20},
-	{0x15,0x0f},
-
-	//sensor AE settings:
-	/*
-	{0xfd,0x00},
-	{0x05,0x00},
-	{0x06,0x00},
-	{0x09,0x03},
-	{0x0a,0x04},
-	{0xf0,0x4a},
-	{0xf1,0x00},
-	{0xf2,0x59},
-	{0xf5,0x72},
-	{0xfd,0x01},
-	{0x00,0xac},
-	{0x0f,0x5a},
-	{0x16,0x5a},
-	{0x17,0x9c},
-	{0x18,0xa4},
-	{0x1b,0x5a},
-	{0x1c,0xa4},
-	{0xb4,0x20},
-	{0xb5,0x3a},
-	{0xb6,0x46},
-	{0xb9,0x40},
-	{0xba,0x4f},
-	{0xbb,0x47},
-	{0xbc,0x45},
-	{0xbd,0x43},
-	{0xbe,0x42},
-	{0xbf,0x42},
-	{0xc0,0x42},
-	{0xc1,0x41},
-	{0xc2,0x41},
-	{0xc3,0x41},
-	{0xc4,0x41},
-	{0xc5,0x70},
-	{0xc6,0x41},
-	{0xca,0x70},
-	{0xcb,0x0c},
-	{0xfd,0x00},
-	*/
-	{0xfd,0x00},
-	{0x05,0x00},
-	{0x06,0x00},
-	{0x09,0x01},
-	{0x0a,0x76},
-	{0xf0,0x62},
-	{0xf1,0x00},
-	{0xf2,0x5f},
-	{0xf5,0x78},
-	{0xfd,0x01},//P1
-	{0x00,0xba},
-	{0x0f,0x60},
-	{0x16,0x60},
-	{0x17,0xa2},
-	{0x18,0xaa},
-	{0x1b,0x60},
-	{0x1c,0xaa},
-	{0xb4,0x20},
-	{0xb5,0x3a},
-	{0xb6,0x5e},
-	{0xb9,0x40},
-	{0xba,0x4f},
-	{0xbb,0x47},
-	{0xbc,0x45},
-	{0xbd,0x43},
-	{0xbe,0x42},
-	{0xbf,0x42},
-	{0xc0,0x42},
-	{0xc1,0x41},
-	{0xc2,0x41},
-	{0xc3,0x41},
-	{0xc4,0x41},
-	{0xc5,0x78},
-	{0xc6,0x41},
-	{0xca,0x70},
-	{0xcb,0xc },
-	{0xfd,0x00},
-
-
-	{0xfd,0x00},
-	{0x32,0x15},
-	{0x34,0x66},
-	{0x35,0x40},
-	{0x36,0x80},
-	{0xFF,0xFF},
+    {0xfd,0x00},
+    {0x1B,0x02},
+    {0x27,0xe8},
+    {0x28,0x0B},
+    {0x32,0x00},
+    {0x22,0xc0},
+    {0x26,0x10},
+    {0x31,0x10},
+    {0x5f,0x11},
+    {0xfd,0x01},
+    {0x25,0x1a},
+    {0x26,0xfb},
+    {0x28,SP0838_P1_0x28},
+    {0x29,SP0838_P1_0x29},
+    {0xfd,0x00},
+    {0xe7,0x03},
+    {0xe7,0x00},
+    {0xfd,0x01},
+    {0x31,0x00},
+    {0x32,0x18},
+    {0x4d,0xdc},
+    {0x4e,0x53},
+    {0x41,0x8c},
+    {0x42,0x57},
+    {0x55,0xff},
+    {0x56,0x00},
+    {0x59,0x82},
+    {0x5a,0x00},
+    {0x5d,0xff},
+    {0x5e,0x6f},
+    {0x57,0xff},
+    {0x58,0x00},
+    {0x5b,0xff},
+    {0x5c,0xa8},
+    {0x5f,0x75},
+    {0x60,0x00},
+    /*{0x2d,0x00},
+    {0x2e,0x00},
+    {0x30,0x00},
+    {0x33,0x00},
+    {0x34,0x00},
+    {0x37,0x00},
+    {0x38,0x00},*/
+    {0x2f,0x80},
+    {0xfd,0x00},
+    {0x33,0x6f},
+    {0x51,0x3f},
+    {0x52,0x09},
+    {0x53,0x00},
+    {0x54,0x00},
+    {0x55,0x10},
+    {0x4f,0x08},
+    {0x50,0x08},
+    {0x57,SP0838_P0_0x57},//Raw filter debut start
+    {0x58,SP0838_P0_0x58},
+    {0x59,SP0838_P0_0x59},
+    {0x56,SP0838_P0_0x56},
+    {0x5a,SP0838_P0_0x5a},
+    {0x5b,SP0838_P0_0x5b},
+    {0x5c,SP0838_P0_0x5c},//Raw filter debut end
+    {0x65,SP0838_P0_0x65},//Sharpness debug start
+    {0x66,SP0838_P0_0x66},
+    {0x67,SP0838_P0_0x67},
+    {0x68,SP0838_P0_0x68},
+    {0x69,0x7f},
+    {0x6a,0x01},
+    {0x6b,SP0838_P0_0x6b},
+    {0x6c,SP0838_P0_0x6c},
+    {0x6d,SP0838_P0_0x6d},//Edge gain normal
+    {0x6e,SP0838_P0_0x6e},//Edge gain normal
+    {0x6f,0x7f},
+    {0x70,0x01},
+    {0x71,SP0838_P0_0x71}, //
+    {0x72,SP0838_P0_0x72}, //
+    {0x73,SP0838_P0_0x73}, //
+    {0x74,SP0838_P0_0x74}, //
+    {0x75,0x7f},
+    {0x76,0x01},
+    {0xcb,0x07},
+    {0xcc,0x04},
+    {0xce,0xff},
+    {0xcf,0x10},
+    {0xd0,0x20},
+    {0xd1,0x00},
+    {0xd2,0x1c},
+    {0xd3,0x16},
+    {0xd4,0x00},
+    {0xd6,0x1c},
+    {0xd7,0x16},
+    {0xdd,SP0838_P0_0xdd},//Contrast
+    {0xde,SP0838_P0_0xde},//HEQ&Saturation debug end
+    #if 0
+    {0x7f,0xd7},
+    {0x80,0xbc},
+    {0x81,0xed},
+    {0x82,0xd7},
+    {0x83,0xd4},
+    {0x84,0xd6},
+    {0x85,0xff},
+    {0x86,0x89},
+    {0x87,0xf8},
+    {0x88,0x3c},
+    {0x89,0x33},
+    {0x8a,0x0f},
+    #else //sp_yc 20140626
+    {0x7f,SP0838_P0_0x7f},//Color Correction start
+    {0x80,0xbc},
+    {0x81,0x00},
+    {0x82,0xd7},
+    {0x83,0xf0},
+    {0x84,0xb9},
+    {0x85,0xff},
+    {0x86,0x89},
+    {0x87,SP0838_P0_0x87},
+    {0x88,0x0c},
+    {0x89,0x33},
+    {0x8a,0x0f},
+    #endif
+    {0x8b,0x0 },
+    {0x8c,0x1a},
+    {0x8d,0x29},
+    {0x8e,0x41},
+    {0x8f,0x62},
+    {0x90,0x7c},
+    {0x91,0x90},
+    {0x92,0xa2},
+    {0x93,0xaf},
+    {0x94,0xbc},
+    {0x95,0xc5},
+    {0x96,0xcd},
+    {0x97,0xd5},
+    {0x98,0xdd},
+    {0x99,0xe5},
+    {0x9a,0xed},
+    {0x9b,0xf5},
+    {0xfd,0x01},
+    {0x8d,0xfd},
+    {0x8e,0xff},
+    {0xfd,0x00},
+    {0xca,0xcf},
+    {0xd8,SP0838_P0_0xd8},//UV outdoor
+    {0xd9,SP0838_P0_0xd9},//UV indoor
+    {0xda,SP0838_P0_0xda},//UV dummy
+    {0xdb,SP0838_P0_0xdb},//UV lowlight
+    {0xb9,0x00},
+    {0xba,0x04},
+    {0xbb,0x08},
+    {0xbc,0x10},
+    {0xbd,0x20},
+    {0xbe,0x30},
+    {0xbf,0x40},
+    {0xc0,0x50},
+    {0xc1,0x60},
+    {0xc2,0x70},
+    {0xc3,0x80},
+    {0xc4,0x90},
+    {0xc5,0xA0},
+    {0xc6,0xB0},
+    {0xc7,0xC0},
+    {0xc8,0xD0},
+    {0xc9,0xE0},
+    {0xfd,0x01},
+    {0x89,0xf0},
+    {0x8a,0xff},
+    {0xfd,0x00},
+    {0xe8,0x30},
+    {0xe9,0x30},
+    {0xea,0x40},
+    {0xf4,0x1b},
+    {0xf5,0x80},
+    {0xf7,SP0838_P0_0xf7},//AE target
+    {0xf8,SP0838_P0_0xf8},
+    {0xf9,SP0838_P0_0xf9},//AE target
+    {0xfa,SP0838_P0_0xfa},
+    {0xfd,0x01},
+    {0x09,0x31},
+    {0x0a,0x85},
+    {0x0b,0x0b},
+    {0x14,0x20},
+    {0x15,0x0f},
+
+    //sensor AE settings:
+    /*
+    {0xfd,0x00},
+    {0x05,0x00},
+    {0x06,0x00},
+    {0x09,0x03},
+    {0x0a,0x04},
+    {0xf0,0x4a},
+    {0xf1,0x00},
+    {0xf2,0x59},
+    {0xf5,0x72},
+    {0xfd,0x01},
+    {0x00,0xac},
+    {0x0f,0x5a},
+    {0x16,0x5a},
+    {0x17,0x9c},
+    {0x18,0xa4},
+    {0x1b,0x5a},
+    {0x1c,0xa4},
+    {0xb4,0x20},
+    {0xb5,0x3a},
+    {0xb6,0x46},
+    {0xb9,0x40},
+    {0xba,0x4f},
+    {0xbb,0x47},
+    {0xbc,0x45},
+    {0xbd,0x43},
+    {0xbe,0x42},
+    {0xbf,0x42},
+    {0xc0,0x42},
+    {0xc1,0x41},
+    {0xc2,0x41},
+    {0xc3,0x41},
+    {0xc4,0x41},
+    {0xc5,0x70},
+    {0xc6,0x41},
+    {0xca,0x70},
+    {0xcb,0x0c},
+    {0xfd,0x00},
+    */
+    {0xfd,0x00},
+    {0x05,0x00},
+    {0x06,0x00},
+    {0x09,0x01},
+    {0x0a,0x76},
+    {0xf0,0x62},
+    {0xf1,0x00},
+    {0xf2,0x5f},
+    {0xf5,0x78},
+    {0xfd,0x01},//P1
+    {0x00,0xba},
+    {0x0f,0x60},
+    {0x16,0x60},
+    {0x17,0xa2},
+    {0x18,0xaa},
+    {0x1b,0x60},
+    {0x1c,0xaa},
+    {0xb4,0x20},
+    {0xb5,0x3a},
+    {0xb6,0x5e},
+    {0xb9,0x40},
+    {0xba,0x4f},
+    {0xbb,0x47},
+    {0xbc,0x45},
+    {0xbd,0x43},
+    {0xbe,0x42},
+    {0xbf,0x42},
+    {0xc0,0x42},
+    {0xc1,0x41},
+    {0xc2,0x41},
+    {0xc3,0x41},
+    {0xc4,0x41},
+    {0xc5,0x78},
+    {0xc6,0x41},
+    {0xca,0x70},
+    {0xcb,0xc },
+    {0xfd,0x00},
+
+
+    {0xfd,0x00},
+    {0x32,0x15},
+    {0x34,0x66},
+    {0x35,0x40},
+    {0x36,0x80},
+    {0xFF,0xFF},
 };
 
 //load GT2005 parameters
 void SP0838_init_regs(struct sp0838_device *dev)
 {
-	int i=0;//,j;
-	unsigned char buf[2];
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	
-	while (1) {
-		buf[0] = SP0838_script[i].addr;
-		buf[1] = SP0838_script[i].val;
-		if(SP0838_script[i].val==0xff&&SP0838_script[i].addr==0xff){
-			printk("SP0838_write_regs success in initial SP0838.\n");
-			break;
-		}
-		if((i2c_put_byte_add8(client,buf, 2)) < 0){
-			printk("fail in initial SP0838. \n");
-			return;
-		}
-		i++;
-	}
-	return;
+    int i=0;//,j;
+    unsigned char buf[2];
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+    if (!dev->vminfo.isused)
+        return;
+
+    while (1) {
+        buf[0] = SP0838_script[i].addr;
+        buf[1] = SP0838_script[i].val;
+        if (SP0838_script[i].val == 0xff && SP0838_script[i].addr == 0xff) {
+            printk("SP0838_write_regs success in initial SP0838.\n");
+            break;
+        }
+        if ((i2c_put_byte_add8(client,buf, 2)) < 0) {
+            printk("fail in initial SP0838. \n");
+            return;
+        }
+        i++;
+    }
+    return;
 
 }
 
 #if 0
 static struct aml_camera_i2c_fig1_s resolution_320x240_script[] = {
-	{0xfd, 0x00},
-	{0x47, 0x00},
-	{0x48, 0x78},
-	{0x49, 0x00},
-	{0x4a, 0xf0},
-	{0x4b, 0x00},
-	{0x4c, 0xa0},
-	{0x4d, 0x01},
-	{0x4e, 0x40},
-                
-	{0xff, 0xff}
+    {0xfd, 0x00},
+    {0x47, 0x00},
+    {0x48, 0x78},
+    {0x49, 0x00},
+    {0x4a, 0xf0},
+    {0x4b, 0x00},
+    {0x4c, 0xa0},
+    {0x4d, 0x01},
+    {0x4e, 0x40},
+    {0xff, 0xff}
 
 };
 #endif
 static struct aml_camera_i2c_fig1_s resolution_640x480_script[] = {
 #if 1
-	{0xfd, 0x00},
-	{0x47, 0x00},
-	{0x48, 0x00},
-	{0x49, 0x01},
-	{0x4a, 0xe0},
-	{0x4b, 0x00},
-	{0x4c, 0x00},
-	{0x4d, 0x02},
-	{0x4e, 0x80},
-		
-		
-	{0xff, 0xff}
+    {0xfd, 0x00},
+    {0x47, 0x00},
+    {0x48, 0x00},
+    {0x49, 0x01},
+    {0x4a, 0xe0},
+    {0x4b, 0x00},
+    {0x4c, 0x00},
+    {0x4d, 0x02},
+    {0x4e, 0x80},
+    {0xff, 0xff}
  #endif
 
 
@@ -843,231 +845,242 @@ static struct aml_camera_i2c_fig1_s resolution_640x480_script[] = {
 
 static int set_flip(struct sp0838_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char temp;
-	unsigned char buf[2];
-	temp = i2c_get_byte_add8(client, 0x31);
-	temp &= 0x9f;
-	temp |= dev->cam_info.m_flip << 5;
-	temp |= dev->cam_info.v_flip << 6;
-	buf[0] = 0x31;
-	buf[1] = temp;
-	if((i2c_put_byte_add8(client,buf, 2)) < 0) {
-		printk("fail in setting sensor orientation\n");
-		return -1;
-	}
-	return 0;
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    unsigned char temp;
+    unsigned char buf[2];
+
+    if (!dev->vminfo.isused)
+        return 0;
+
+    temp = i2c_get_byte_add8(client, 0x31);
+    temp &= 0x9f;
+    temp |= dev->cam_info.m_flip << 5;
+    temp |= dev->cam_info.v_flip << 6;
+    buf[0] = 0x31;
+    buf[1] = temp;
+    if ((i2c_put_byte_add8(client,buf, 2)) < 0) {
+        printk("fail in setting sensor orientation\n");
+        return -1;
+    }
+    return 0;
 }
 
 static void sp0838_set_resolution(struct sp0838_device *dev,int height,int width)
 {
-	int i=0;
-	unsigned char buf[2];
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	struct aml_camera_i2c_fig1_s* resolution_script;
-
-	printk("set resolution 640X480\n");
-	resolution_script = resolution_640x480_script;
-	sp0838_h_active = 640;
-	sp0838_v_active = 478; //480 
-	sp0838_frmintervals_active.denominator 	= 15;
-	sp0838_frmintervals_active.numerator	= 1;
-	
-	while(1) {
-		buf[0] = resolution_script[i].addr;
-		buf[1] = resolution_script[i].val;
-		if(resolution_script[i].val==0xff&&resolution_script[i].addr==0xff) {
-		    break;
-		}
-		if((i2c_put_byte_add8(client,buf, 2)) < 0) {
-		    printk("fail in setting resolution \n");
-		    return;
-		}
-		i++;
-	}
-    	set_flip(dev);
+    int i=0;
+    unsigned char buf[2];
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    struct aml_camera_i2c_fig1_s* resolution_script;
+
+    if (!dev->vminfo.isused)
+        return;
+
+    printk("set resolution 640X480\n");
+    resolution_script = resolution_640x480_script;
+    sp0838_h_active = 640;
+    sp0838_v_active = 478; //480
+    sp0838_frmintervals_active.denominator = 15;
+    sp0838_frmintervals_active.numerator = 1;
+
+    while (1) {
+        buf[0] = resolution_script[i].addr;
+        buf[1] = resolution_script[i].val;
+        if (resolution_script[i].val == 0xff && resolution_script[i].addr == 0xff) {
+            break;
+        }
+        if ((i2c_put_byte_add8(client,buf, 2)) < 0) {
+            printk("fail in setting resolution \n");
+            return;
+        }
+        i++;
+    }
+        set_flip(dev);
 }
 /*************************************************************************
 * FUNCTION
-*	set_SP0838_param_wb
+*   set_SP0838_param_wb
 *
 * DESCRIPTION
-*	SP0838 wb setting.
+*   SP0838 wb setting.
 *
 * PARAMETERS
-*	none
+*   none
 *
 * RETURNS
-*	None
+*   None
 *
 * GLOBALS AFFECTED  
 *
 *************************************************************************/
 void set_SP0838_param_wb(struct sp0838_device *dev,enum  camera_wb_flip_e para)
 {
-//	kal_uint16 rgain=0x80, ggain=0x80, bgain=0x80;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-
-	unsigned char buf[4];
-
-	unsigned char  temp_reg;
-	//temp_reg=sp0a19_read_byte(0x22);
-	//buf[0]=0x22; //SP0A19 enable auto wb
-	buf[0]=0x32;
-	temp_reg=i2c_get_byte_add8(client,buf[0]);
-
-	printk(" camera set_SP0A19_param_wb=%d. \n ",para);
-	switch (para) {
-	case CAM_WB_AUTO:
-		buf[0]=0xfd;
-		buf[1]=0x01;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x28;
-		buf[1]=0x5a;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x29;
-		buf[1]=0x62;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x32;
-		buf[1]=0x15;  //temp_reg|0x10;	  // SP0A19 AWB enable bit[1]	ie. 0x02;
-		i2c_put_byte_add8(client,buf,2);
-		break;
-
-	case CAM_WB_CLOUD:
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-
-		buf[0]=0x32;
-		buf[1]=0x05;//temp_reg&~0x10;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x01;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x28;
-		buf[1]=0x88;//71
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x29;
-		buf[1]=0x42;//41
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-		break;
-
-	case CAM_WB_DAYLIGHT:	// tai yang guang
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-
-		buf[0]=0x32;
-		buf[1]=0x05;//temp_reg&~0x10;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x01;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x28;
-		buf[1]=0x6b;//b0
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x29;
-		buf[1]=0x48;//70
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-		break;
-
-	case CAM_WB_INCANDESCENCE:	 // bai re guang
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-
-		buf[0]=0x32;
-		buf[1]=0x05;//temp_reg&~0x10;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x01;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x28;
-		buf[1]=0x41;//6b
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x29;
-		buf[1]=0x71;//48
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-		break;
-
-	case CAM_WB_FLUORESCENT:   //ri guang deng
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-
-		buf[0]=0x32;
-		buf[1]=0x05;//temp_reg&~0x10;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x01;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x28;
-		buf[1]=0x5a;//98
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x29;
-		buf[1]=0x62;//c0
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-		break;
-
-	case CAM_WB_TUNGSTEN:	// wu si deng
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-
-		buf[0]=0x32;
-		buf[1]=0x05;//temp_reg&~0x10;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x01;
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x28;
-		buf[1]=0x4e;//41
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0x29;
-		buf[1]=0x68;//71
-		i2c_put_byte_add8(client,buf,2);
-		buf[0]=0xfd;
-		buf[1]=0x00;
-		i2c_put_byte_add8(client,buf,2);
-		break;
-
-	case CAM_WB_MANUAL:
-		// TODO
-		break;
-	default:
-		break;
-	}
-//	kal_sleep_task(20);
+//  kal_uint16 rgain=0x80, ggain=0x80, bgain=0x80;
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+    unsigned char buf[4];
+
+    unsigned char  temp_reg;
+    //temp_reg=sp0a19_read_byte(0x22);
+    //buf[0]=0x22; //SP0A19 enable auto wb
+    buf[0]=0x32;
+
+    if (!dev->vminfo.isused)
+        return;
+
+    temp_reg=i2c_get_byte_add8(client,buf[0]);
+
+    printk(" camera set_SP0A19_param_wb=%d. \n ",para);
+    switch (para) {
+    case CAM_WB_AUTO:
+        buf[0]=0xfd;
+        buf[1]=0x01;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x28;
+        buf[1]=0x5a;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x29;
+        buf[1]=0x62;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x32;
+        buf[1]=0x15;  //temp_reg|0x10;    // SP0A19 AWB enable bit[1]   ie. 0x02;
+        i2c_put_byte_add8(client,buf,2);
+        break;
+
+    case CAM_WB_CLOUD:
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+
+        buf[0]=0x32;
+        buf[1]=0x05;//temp_reg&~0x10;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x01;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x28;
+        buf[1]=0x88;//71
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x29;
+        buf[1]=0x42;//41
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+        break;
+
+    case CAM_WB_DAYLIGHT:   // tai yang guang
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+
+        buf[0]=0x32;
+        buf[1]=0x05;//temp_reg&~0x10;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x01;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x28;
+        buf[1]=0x6b;//b0
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x29;
+        buf[1]=0x48;//70
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+        break;
+
+    case CAM_WB_INCANDESCENCE:   // bai re guang
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+
+        buf[0]=0x32;
+        buf[1]=0x05;//temp_reg&~0x10;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x01;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x28;
+        buf[1]=0x41;//6b
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x29;
+        buf[1]=0x71;//48
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+        break;
+
+    case CAM_WB_FLUORESCENT:   //ri guang deng
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+
+        buf[0]=0x32;
+        buf[1]=0x05;//temp_reg&~0x10;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x01;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x28;
+        buf[1]=0x5a;//98
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x29;
+        buf[1]=0x62;//c0
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+        break;
+
+    case CAM_WB_TUNGSTEN:   // wu si deng
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+
+        buf[0]=0x32;
+        buf[1]=0x05;//temp_reg&~0x10;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x01;
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x28;
+        buf[1]=0x4e;//41
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0x29;
+        buf[1]=0x68;//71
+        i2c_put_byte_add8(client,buf,2);
+        buf[0]=0xfd;
+        buf[1]=0x00;
+        i2c_put_byte_add8(client,buf,2);
+        break;
+
+    case CAM_WB_MANUAL:
+        // TODO
+        break;
+    default:
+        break;
+    }
+//  kal_sleep_task(20);
 }
 
 
 /*************************************************************************
 * FUNCTION
-*	SP0838_night_mode
+*   SP0838_night_mode
 *
 * DESCRIPTION
-*	This function night mode of SP0838.
+*   This function night mode of SP0838.
 *
 * PARAMETERS
-*	none
+*   none
 *
 * RETURNS
-*	None
+*   None
 *
 * GLOBALS AFFECTED
 *
@@ -1078,16 +1091,16 @@ void SP0838_night_mode(struct sp0838_device *dev,enum  camera_night_mode_flip_e
 }
 /*************************************************************************
 * FUNCTION
-*	SP0838_night_mode
+*   SP0838_night_mode
 *
 * DESCRIPTION
-*	This function night mode of SP0838.
+*   This function night mode of SP0838.
 *
 * PARAMETERS
-*	none
+*   none
 *
 * RETURNS
-*	None
+*   None
 *
 * GLOBALS AFFECTED
 *
@@ -1102,108 +1115,111 @@ void SP0838_set_param_banding(struct sp0838_device *dev,enum  camera_night_mode_
 
 /*************************************************************************
 * FUNCTION
-*	set_SP0838_param_exposure
+*   set_SP0838_param_exposure
 *
 * DESCRIPTION
-*	SP0838 exposure setting.
+*   SP0838 exposure setting.
 *
 * PARAMETERS
-*	none
+*   none
 *
 * RETURNS
-*	None
+*   None
 *
 * GLOBALS AFFECTED   
 *
 *************************************************************************/
 void set_SP0838_param_exposure(struct sp0838_device *dev,enum camera_exposure_e para)//
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-
-	unsigned char buf1[2];
-	unsigned char buf2[2];
-
-	switch (para) {
-	case EXPOSURE_N4_STEP:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0xc0;
-		break;
-	case EXPOSURE_N3_STEP:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0xd0;
-		break;
-	case EXPOSURE_N2_STEP:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0xe0;
-		break;
-	case EXPOSURE_N1_STEP:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0xf0;
-		break;
-	case EXPOSURE_0_STEP:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0x00;//6a
-		break;
-	case EXPOSURE_P1_STEP:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0x10;
-		break;
-	case EXPOSURE_P2_STEP:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0x20;
-		break;
-	case EXPOSURE_P3_STEP:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0x30;
-		break;
-	case EXPOSURE_P4_STEP:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0x40;
-		break;
-	default:
-		buf1[0]=0xfd;
-		buf1[1]=0x00;
-		buf2[0]=0xdc;
-		buf2[1]=0x00;
-		break; 
-	} 
-	//msleep(300);	
-	i2c_put_byte_add8(client,buf1,2);
-	i2c_put_byte_add8(client,buf2,2);
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+    unsigned char buf1[2];
+    unsigned char buf2[2];
+
+    if (!dev->vminfo.isused)
+        return;
+
+    switch (para) {
+    case EXPOSURE_N4_STEP:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0xc0;
+        break;
+    case EXPOSURE_N3_STEP:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0xd0;
+        break;
+    case EXPOSURE_N2_STEP:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0xe0;
+        break;
+    case EXPOSURE_N1_STEP:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0xf0;
+        break;
+    case EXPOSURE_0_STEP:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0x00;//6a
+        break;
+    case EXPOSURE_P1_STEP:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0x10;
+        break;
+    case EXPOSURE_P2_STEP:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0x20;
+        break;
+    case EXPOSURE_P3_STEP:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0x30;
+        break;
+    case EXPOSURE_P4_STEP:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0x40;
+        break;
+    default:
+        buf1[0]=0xfd;
+        buf1[1]=0x00;
+        buf2[0]=0xdc;
+        buf2[1]=0x00;
+        break;
+    }
+    //msleep(300);
+    i2c_put_byte_add8(client,buf1,2);
+    i2c_put_byte_add8(client,buf2,2);
 
 }
 
 
 /*************************************************************************
 * FUNCTION
-*	set_SP0838_param_effect
+*   set_SP0838_param_effect
 *
 * DESCRIPTION
-*	SP0838 effect setting.
+*   SP0838 effect setting.
 *
 * PARAMETERS
-*	none
+*   none
 *
 * RETURNS
-*	None
+*   None
 *
 * GLOBALS AFFECTED  
 *
@@ -1216,111 +1232,111 @@ void set_SP0838_param_effect(struct sp0838_device *dev,enum camera_effect_flip_e
 
 unsigned char v4l_2_sp0838(int val)
 {
-	int ret=val/0x20;
-	if(ret<4) return ret*0x20+0x80;
-	else if(ret<8) return ret*0x20+0x20;
-	else return 0;
+    int ret=val/0x20;
+    if (ret < 4) return ret * 0x20 + 0x80;
+    else if (ret<8) return ret * 0x20 + 0x20;
+    else return 0;
 }
 
 static int convert_canvas_index(unsigned int v4l2_format, unsigned int start_canvas)
 {
-	int canvas = start_canvas;
-
-	switch(v4l2_format){
-	case V4L2_PIX_FMT_RGB565X:
-	case V4L2_PIX_FMT_VYUY:
-		canvas = start_canvas;
-		break;
-	case V4L2_PIX_FMT_YUV444:
-	case V4L2_PIX_FMT_BGR24:
-	case V4L2_PIX_FMT_RGB24:
-		canvas = start_canvas;
-		break; 
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21: 
-		canvas = start_canvas | ((start_canvas+1)<<8);
-		break;
-	case V4L2_PIX_FMT_YVU420:
-	case V4L2_PIX_FMT_YUV420:
-		if(V4L2_PIX_FMT_YUV420 == v4l2_format){
-			canvas = start_canvas|((start_canvas+1)<<8)|((start_canvas+2)<<16);
-		}else{
-			canvas = start_canvas|((start_canvas+2)<<8)|((start_canvas+1)<<16);
-		}
-		break;
-	default:
-		break;
-	}
-	return canvas;
+    int canvas = start_canvas;
+
+    switch (v4l2_format) {
+    case V4L2_PIX_FMT_RGB565X:
+    case V4L2_PIX_FMT_VYUY:
+        canvas = start_canvas;
+        break;
+    case V4L2_PIX_FMT_YUV444:
+    case V4L2_PIX_FMT_BGR24:
+    case V4L2_PIX_FMT_RGB24:
+        canvas = start_canvas;
+        break;
+    case V4L2_PIX_FMT_NV12:
+    case V4L2_PIX_FMT_NV21:
+        canvas = start_canvas | ((start_canvas + 1) << 8);
+        break;
+    case V4L2_PIX_FMT_YVU420:
+    case V4L2_PIX_FMT_YUV420:
+        if (V4L2_PIX_FMT_YUV420 == v4l2_format) {
+            canvas = start_canvas | ((start_canvas + 1) << 8) | ((start_canvas + 2) << 16);
+        }else{
+            canvas = start_canvas | ((start_canvas + 2) << 8) | ((start_canvas + 1) << 16);
+        }
+        break;
+    default:
+        break;
+    }
+    return canvas;
 }
 
 static int sp0838_setting(struct sp0838_device *dev,int PROP_ID,int value )
 {
-	int ret=0;
-	//unsigned char cur_val;
-	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	switch(PROP_ID)  {
-	case V4L2_CID_DO_WHITE_BALANCE:
-		if(sp0838_qctrl[0].default_value!=value){
-			sp0838_qctrl[0].default_value=value;
-			set_SP0838_param_wb(dev,value);
-			printk(KERN_INFO " set camera  white_balance=%d. \n ",value);
-		}
-		break;
-	case V4L2_CID_EXPOSURE:
-		if(sp0838_qctrl[1].default_value!=value){
-			sp0838_qctrl[1].default_value=value;
-			set_SP0838_param_exposure(dev,value);
-			printk(KERN_INFO " set camera  exposure=%d. \n ",value);
-		}
-		break;
-	case V4L2_CID_COLORFX:
-		if(sp0838_qctrl[2].default_value!=value){
-			sp0838_qctrl[2].default_value=value;
-			set_SP0838_param_effect(dev,value);
-			printk(KERN_INFO " set camera  effect=%d. \n ",value);
-		}
-		break;
-	case V4L2_CID_WHITENESS:
-		if(sp0838_qctrl[3].default_value!=value){
-			sp0838_qctrl[3].default_value=value;
-			SP0838_set_param_banding(dev,value);
-			printk(KERN_INFO " set camera  banding=%d. \n ",value);
-		}
-		break;
-	case V4L2_CID_BLUE_BALANCE:
-		if(sp0838_qctrl[4].default_value!=value){
-			sp0838_qctrl[4].default_value=value;
-			SP0838_night_mode(dev,value);
-			printk(KERN_INFO " set camera  scene mode=%d. \n ",value);
-		}
-		break;
-	case V4L2_CID_HFLIP:    /* set flip on H. */          
-		value = value & 0x3;
-		if(sp0838_qctrl[5].default_value!=value){
-			sp0838_qctrl[5].default_value=value;
-			printk(" set camera  h filp =%d. \n ",value);
-		}
-		break;
-	case V4L2_CID_VFLIP:    /* set flip on V. */         
-		break;
-	case V4L2_CID_ZOOM_ABSOLUTE:
-		if(sp0838_qctrl[7].default_value!=value){
-			sp0838_qctrl[7].default_value=value;
-			//printk(KERN_INFO " set camera  zoom mode=%d. \n ",value);
-		}
-		break;
-	case V4L2_CID_ROTATE:
-		if(sp0838_qctrl[8].default_value!=value){
-			sp0838_qctrl[8].default_value=value;
-			printk(" set camera  rotate =%d. \n ",value);
-		}
-		break;
-	default:
-		ret=-1;
-		break;
-	}
-	return ret;
+    int ret=0;
+    //unsigned char cur_val;
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    switch (PROP_ID) {
+    case V4L2_CID_DO_WHITE_BALANCE:
+        if (sp0838_qctrl[0].default_value != value) {
+            sp0838_qctrl[0].default_value = value;
+            set_SP0838_param_wb(dev,value);
+            printk(KERN_INFO " set camera  white_balance=%d. \n ",value);
+        }
+        break;
+    case V4L2_CID_EXPOSURE:
+        if (sp0838_qctrl[1].default_value != value) {
+            sp0838_qctrl[1].default_value = value;
+            set_SP0838_param_exposure(dev,value);
+            printk(KERN_INFO " set camera  exposure=%d. \n ",value);
+        }
+        break;
+    case V4L2_CID_COLORFX:
+        if (sp0838_qctrl[2].default_value != value) {
+            sp0838_qctrl[2].default_value = value;
+            set_SP0838_param_effect(dev,value);
+            printk(KERN_INFO " set camera  effect=%d. \n ",value);
+        }
+        break;
+    case V4L2_CID_WHITENESS:
+        if (sp0838_qctrl[3].default_value != value) {
+            sp0838_qctrl[3].default_value = value;
+            SP0838_set_param_banding(dev,value);
+            printk(KERN_INFO " set camera  banding=%d. \n ",value);
+        }
+        break;
+    case V4L2_CID_BLUE_BALANCE:
+        if (sp0838_qctrl[4].default_value != value) {
+            sp0838_qctrl[4].default_value = value;
+            SP0838_night_mode(dev,value);
+            printk(KERN_INFO " set camera  scene mode=%d. \n ",value);
+        }
+        break;
+    case V4L2_CID_HFLIP:    /* set flip on H. */
+        value = value & 0x3;
+        if (sp0838_qctrl[5].default_value != value) {
+            sp0838_qctrl[5].default_value = value;
+            printk(" set camera  h filp =%d. \n ",value);
+        }
+        break;
+    case V4L2_CID_VFLIP:    /* set flip on V. */
+        break;
+    case V4L2_CID_ZOOM_ABSOLUTE:
+        if (sp0838_qctrl[7].default_value != value) {
+            sp0838_qctrl[7].default_value = value;
+            //printk(KERN_INFO " set camera  zoom mode=%d. \n ",value);
+        }
+        break;
+    case V4L2_CID_ROTATE:
+        if (sp0838_qctrl[8].default_value != value) {
+            sp0838_qctrl[8].default_value = value;
+            printk(" set camera  rotate =%d. \n ",value);
+        }
+        break;
+    default:
+        ret = -1;
+        break;
+    }
+    return ret;
 
 }
 
@@ -1331,1020 +1347,1173 @@ static int sp0838_setting(struct sp0838_device *dev,int PROP_ID,int value )
 }*/
 
 /* ------------------------------------------------------------------
-	DMA and thread functions
+    DMA and thread functions
    ------------------------------------------------------------------*/
 
-#define TSTAMP_MIN_Y	24
-#define TSTAMP_MAX_Y	(TSTAMP_MIN_Y + 15)
-#define TSTAMP_INPUT_X	10
-#define TSTAMP_MIN_X	(54 + TSTAMP_INPUT_X)
+#define TSTAMP_MIN_Y    24
+#define TSTAMP_MAX_Y    (TSTAMP_MIN_Y + 15)
+#define TSTAMP_INPUT_X  10
+#define TSTAMP_MIN_X    (54 + TSTAMP_INPUT_X)
 
 static void sp0838_fillbuff(struct sp0838_fh *fh, struct sp0838_buffer *buf)
 {
-	struct sp0838_device *dev = fh->dev;
-	void *vbuf = (void *)videobuf_to_res(&buf->vb);
-	vm_output_para_t para = {0};
-	dprintk(dev,1,"%s\n", __func__);
-	if (!vbuf)
-		return;
+    int ret;
+    void *vbuf;
+    vm_output_para_t para = {0};
+    struct sp0838_device *dev = fh->dev;
+    if (dev->vminfo.mem_alloc_succeed) {
+        vbuf = (void *)videobuf_to_res(&buf->vb);
+    } else {
+        vbuf = videobuf_to_vmalloc(&buf->vb);
+    }
+    dprintk(dev,1,"%s\n", __func__);
+    if (!vbuf)
+        return;
  /*  0x18221223 indicate the memory type is MAGIC_VMAL_MEM*/
-	if(buf->canvas_id == 0)
-		buf->canvas_id = convert_canvas_index(fh->fmt->fourcc, CAMERA_USER_CANVAS_INDEX+buf->vb.i*3);
-	para.v4l2_format = fh->fmt->fourcc;
-	para.v4l2_memory = MAGIC_RE_MEM;
-	para.zoom = sp0838_qctrl[7].default_value;
-	para.vaddr = (unsigned)vbuf;
-	para.angle =sp0838_qctrl[8].default_value;
-	para.ext_canvas = buf->canvas_id;
-        para.width = buf->vb.width;
-        para.height = buf->vb.height;
-	vm_fill_buffer(&buf->vb,&para);
-	buf->vb.state = VIDEOBUF_DONE;
+    if (dev->vminfo.mem_alloc_succeed) {
+        if (buf->canvas_id == 0)
+            buf->canvas_id = convert_canvas_index(fh->fmt->fourcc, CAMERA_USER_CANVAS_INDEX + buf->vb.i * 3);
+        para.v4l2_memory = MAGIC_RE_MEM;
+    } else {
+        para.v4l2_memory = MAGIC_VMAL_MEM;
+    }
+    para.v4l2_format = fh->fmt->fourcc;
+    para.zoom = sp0838_qctrl[7].default_value;
+    para.vaddr = (unsigned)vbuf;
+    para.angle =sp0838_qctrl[8].default_value;
+    para.ext_canvas = buf->canvas_id;
+    para.width = buf->vb.width;
+    para.height = buf->vb.height;
+    ret = vm_fill_this_buffer(&buf->vb,&para,&dev->vminfo);
+/*if the vm is not used by sensor ,we let vm_fill_this_buffer() return -2*/
+    if (ret == -2) {
+        msleep(100);
+    }
+    buf->vb.state = VIDEOBUF_DONE;
 }
 
 static void sp0838_thread_tick(struct sp0838_fh *fh)
 {
-	struct sp0838_buffer *buf;
-	struct sp0838_device *dev = fh->dev;
-	struct sp0838_dmaqueue *dma_q = &dev->vidq;
-
-	unsigned long flags = 0;
-
-	dprintk(dev, 1, "Thread tick\n");
-	if(!fh->stream_on){
-		dprintk(dev, 1, "sensor doesn't stream on\n");
-		return ;
-	}
-
-	spin_lock_irqsave(&dev->slock, flags);
-	if (list_empty(&dma_q->active)) {
-		dprintk(dev, 1, "No active queue to serve\n");
-		goto unlock;
-	}
-
-	buf = list_entry(dma_q->active.next,
-			 struct sp0838_buffer, vb.queue);
-	dprintk(dev, 1, "%s\n", __func__);
-	dprintk(dev, 1, "list entry get buf is %x\n",(unsigned)buf);
-
-	if(!(fh->f_flags & O_NONBLOCK)){
-		/* Nobody is waiting on this buffer, return */
-		if (!waitqueue_active(&buf->vb.done))
-			goto unlock;
-	}
-	buf->vb.state = VIDEOBUF_ACTIVE;
-
-	list_del(&buf->vb.queue);
-
-	do_gettimeofday(&buf->vb.ts);
-
-	/* Fill buffer */
-	spin_unlock_irqrestore(&dev->slock, flags);
-	sp0838_fillbuff(fh, buf);
-	dprintk(dev, 1, "filled buffer %p\n", buf);
-
-	wake_up(&buf->vb.done);
-	dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
-	return;
+    struct sp0838_buffer *buf;
+    struct sp0838_device *dev = fh->dev;
+    struct sp0838_dmaqueue *dma_q = &dev->vidq;
+
+    unsigned long flags = 0;
+
+    dprintk(dev, 1, "Thread tick\n");
+    if (!fh->stream_on) {
+        dprintk(dev, 1, "sensor doesn't stream on\n");
+        return ;
+    }
+
+    spin_lock_irqsave(&dev->slock, flags);
+    if (list_empty(&dma_q->active)) {
+        dprintk(dev, 1, "No active queue to serve\n");
+        goto unlock;
+    }
+
+    buf = list_entry(dma_q->active.next,
+             struct sp0838_buffer, vb.queue);
+    dprintk(dev, 1, "%s\n", __func__);
+    dprintk(dev, 1, "list entry get buf is %x\n",(unsigned)buf);
+
+    if (!(fh->f_flags & O_NONBLOCK)) {
+        /* Nobody is waiting on this buffer, return */
+        if (!waitqueue_active(&buf->vb.done))
+            goto unlock;
+    }
+    buf->vb.state = VIDEOBUF_ACTIVE;
+
+    list_del(&buf->vb.queue);
+
+    do_gettimeofday(&buf->vb.ts);
+
+    /* Fill buffer */
+    spin_unlock_irqrestore(&dev->slock, flags);
+    sp0838_fillbuff(fh, buf);
+    dprintk(dev, 1, "filled buffer %p\n", buf);
+
+    wake_up(&buf->vb.done);
+    dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
+    return;
 unlock:
-	spin_unlock_irqrestore(&dev->slock, flags);
-	return;
+    spin_unlock_irqrestore(&dev->slock, flags);
+    return;
 }
 
-#define frames_to_ms(frames)					\
-	((frames * WAKE_NUMERATOR * 1000) / WAKE_DENOMINATOR)
+#define frames_to_ms(frames)                    \
+    ((frames * WAKE_NUMERATOR * 1000) / WAKE_DENOMINATOR)
 
 static void sp0838_sleep(struct sp0838_fh *fh)
 {
-	struct sp0838_device *dev = fh->dev;
-	struct sp0838_dmaqueue *dma_q = &dev->vidq;
+    struct sp0838_device *dev = fh->dev;
+    struct sp0838_dmaqueue *dma_q = &dev->vidq;
 
-	DECLARE_WAITQUEUE(wait, current);
+    DECLARE_WAITQUEUE(wait, current);
 
-	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
-		(unsigned long)dma_q);
+    dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
+        (unsigned long)dma_q);
 
-	add_wait_queue(&dma_q->wq, &wait);
-	if (kthread_should_stop())
-		goto stop_task;
+    add_wait_queue(&dma_q->wq, &wait);
+    if (kthread_should_stop())
+        goto stop_task;
 
-	/* Calculate time to wake up */
-	//timeout = msecs_to_jiffies(frames_to_ms(1));
+    /* Calculate time to wake up */
+    //timeout = msecs_to_jiffies(frames_to_ms(1));
 
-	sp0838_thread_tick(fh);
+    sp0838_thread_tick(fh);
 
-	schedule_timeout_interruptible(2);
+    schedule_timeout_interruptible(2);
 
 stop_task:
-	remove_wait_queue(&dma_q->wq, &wait);
-	try_to_freeze();
+    remove_wait_queue(&dma_q->wq, &wait);
+    try_to_freeze();
 }
 
 static int sp0838_thread(void *data)
 {
-	struct sp0838_fh  *fh = data;
-	struct sp0838_device *dev = fh->dev;
+    struct sp0838_fh  *fh = data;
+    struct sp0838_device *dev = fh->dev;
 
-	dprintk(dev, 1, "thread started\n");
+    dprintk(dev, 1, "thread started\n");
 
-	set_freezable();
+    set_freezable();
 
-	for (;;) {
-		sp0838_sleep(fh);
+    for (; ;) {
+        sp0838_sleep(fh);
 
-		if (kthread_should_stop())
-			break;
-	}
-	dprintk(dev, 1, "thread: exit\n");
-	return 0;
+        if (kthread_should_stop())
+            break;
+    }
+    dprintk(dev, 1, "thread: exit\n");
+    return 0;
 }
 
 static int sp0838_start_thread(struct sp0838_fh *fh)
 {
-	struct sp0838_device *dev = fh->dev;
-	struct sp0838_dmaqueue *dma_q = &dev->vidq;
+    struct sp0838_device *dev = fh->dev;
+    struct sp0838_dmaqueue *dma_q = &dev->vidq;
 
-	dma_q->frame = 0;
-	dma_q->ini_jiffies = jiffies;
+    dma_q->frame = 0;
+    dma_q->ini_jiffies = jiffies;
 
-	dprintk(dev, 1, "%s\n", __func__);
+    dprintk(dev, 1, "%s\n", __func__);
 
-	dma_q->kthread = kthread_run(sp0838_thread, fh, "sp0838");
+    dma_q->kthread = kthread_run(sp0838_thread, fh, "sp0838");
 
-	if (IS_ERR(dma_q->kthread)) {
-		v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
-		return PTR_ERR(dma_q->kthread);
-	}
-	/* Wakes thread */
-	wake_up_interruptible(&dma_q->wq);
+    if (IS_ERR(dma_q->kthread)) {
+        v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
+        return PTR_ERR(dma_q->kthread);
+    }
+    /* Wakes thread */
+    wake_up_interruptible(&dma_q->wq);
 
-	dprintk(dev, 1, "returning from %s\n", __func__);
-	return 0;
+    dprintk(dev, 1, "returning from %s\n", __func__);
+    return 0;
 }
 
 static void sp0838_stop_thread(struct sp0838_dmaqueue  *dma_q)
 {
-	struct sp0838_device *dev = container_of(dma_q, struct sp0838_device, vidq);
-
-	dprintk(dev, 1, "%s\n", __func__);
-	/* shutdown control thread */
-	if (dma_q->kthread) {
-		kthread_stop(dma_q->kthread);
-		dma_q->kthread = NULL;
-	}
+    struct sp0838_device *dev = container_of(dma_q, struct sp0838_device, vidq);
+
+    dprintk(dev, 1, "%s\n", __func__);
+    /* shutdown control thread */
+    if (dma_q->kthread) {
+        kthread_stop(dma_q->kthread);
+        dma_q->kthread = NULL;
+    }
 }
 
 /* ------------------------------------------------------------------
-	Videobuf operations
+    Videobuf operations
    ------------------------------------------------------------------*/
 static int
-buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
-{
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp0838_fh *fh = container_of(res, struct sp0838_fh, res);
-	struct sp0838_device *dev  = fh->dev;
-	//int bytes = fh->fmt->depth >> 3 ;
-	int height = fh->height;
-	if(height==1080)
-                   height = 1088;
-	*size = (fh->width*height*fh->fmt->depth)>>3;
-	if (0 == *count)
-		*count = 32;
-
-	while (*size * *count > vid_limit * 1024 * 1024)
-		(*count)--;
-
-	dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
-		*count, *size);
-
-	return 0;
+res_buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+    struct videobuf_res_privdata *res = vq->priv_data;
+    struct sp0838_fh *fh = container_of(res, struct sp0838_fh, res);
+    struct sp0838_device *dev  = fh->dev;
+    //int bytes = fh->fmt->depth >> 3 ;
+    int height = fh->height;
+    if (height == 1080)
+       height = 1088;
+    *size = (fh->width*height*fh->fmt->depth) >> 3;
+    if (0 == *count)
+        *count = 32;
+
+    while (*size * *count > vid_limit * 1024 * 1024)
+        (*count)--;
+
+    dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
+        *count, *size);
+    return 0;
 }
 
-static void free_buffer(struct videobuf_queue *vq, struct sp0838_buffer *buf)
+static int
+vmall_buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
 {
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp0838_fh *fh = container_of(res, struct sp0838_fh, res);
-	struct sp0838_device *dev  = fh->dev;
-
-	dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
+    struct sp0838_fh  *fh = vq->priv_data;
+    struct sp0838_device *dev  = fh->dev;
+    //int bytes = fh->fmt->depth >> 3 ;
+    *size = (fh->width*fh->height*fh->fmt->depth)>>3;
+    if (0 == *count)
+    *count = 32;
+
+    while (*size * *count > vid_limit * 1024 * 1024)
+    (*count)--;
+
+    dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
+    *count, *size);
+    return 0;
+}
 
-	videobuf_waiton(vq, &buf->vb, 0, 0);
-	if (in_interrupt())
-		BUG();
+static void res_free_buffer(struct videobuf_queue *vq, struct sp0838_buffer *buf)
+{
+    struct sp0838_fh *fh;
+    struct sp0838_device *dev;
+    struct videobuf_res_privdata *res = vq->priv_data;
+    fh = container_of(res, struct sp0838_fh, res);
+    dev = fh->dev;
+
+    dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
+
+    videobuf_waiton(vq, &buf->vb, 0, 0);
+    if (in_interrupt())
+        BUG();
+    videobuf_res_free(vq, &buf->vb);
+    dprintk(dev, 1, "free_buffer: freed\n");
+    buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
 
-	videobuf_res_free(vq, &buf->vb);
-	dprintk(dev, 1, "free_buffer: freed\n");
-	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+static void vmall_free_buffer(struct videobuf_queue *vq, struct sp0838_buffer *buf)
+{
+    struct sp0838_fh *fh;
+    struct sp0838_device *dev;
+    fh = vq->priv_data;
+    dev = fh->dev;
+
+    dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
+
+    videobuf_waiton(vq, &buf->vb, 0, 0);
+    if (in_interrupt())
+        BUG();
+    videobuf_vmalloc_free(&buf->vb);
+    dprintk(dev, 1, "free_buffer: freed\n");
+    buf->vb.state = VIDEOBUF_NEEDS_INIT;
 }
 
 #define norm_maxw() 1024
 #define norm_maxh() 768
 static int
-buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
-						enum v4l2_field field)
+res_buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+                        enum v4l2_field field)
 {
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp0838_fh *fh = container_of(res, struct sp0838_fh, res);
-	struct sp0838_device    *dev = fh->dev;
-	struct sp0838_buffer *buf = container_of(vb, struct sp0838_buffer, vb);
-	int rc;
-	//int bytes = fh->fmt->depth >> 3 ;
-	dprintk(dev, 1, "%s, field=%d\n", __func__, field);
+    struct sp0838_fh *fh;
+    struct sp0838_device *dev;
+    struct sp0838_buffer *buf;
+    int rc;
+    struct videobuf_res_privdata *res = vq->priv_data;
+    fh = container_of(res, struct sp0838_fh, res);
+    dev = fh->dev;
+    buf = container_of(vb, struct sp0838_buffer, vb);
+    //int bytes = fh->fmt->depth >> 3 ;
+    dprintk(dev, 1, "%s, field=%d\n", __func__, field);
 
-	BUG_ON(NULL == fh->fmt);
+    BUG_ON(NULL == fh->fmt);
 
-	if (fh->width  < 48 || fh->width  > norm_maxw() ||
-	    fh->height < 32 || fh->height > norm_maxh())
-		return -EINVAL;
+    if (fh->width  < 48 || fh->width  > norm_maxw() ||
+        fh->height < 32 || fh->height > norm_maxh())
+        return -EINVAL;
 
-	buf->vb.size = fh->width*fh->height*fh->fmt->depth >> 3;
-	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
-		return -EINVAL;
+    buf->vb.size = fh->width * fh->height * fh->fmt->depth >> 3;
+    if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+        return -EINVAL;
 
-	/* These properties only change when queue is idle, see s_fmt */
-	buf->fmt       = fh->fmt;
-	buf->vb.width  = fh->width;
-	buf->vb.height = fh->height;
-	buf->vb.field  = field;
+    /* These properties only change when queue is idle, see s_fmt */
+    buf->fmt       = fh->fmt;
+    buf->vb.width  = fh->width;
+    buf->vb.height = fh->height;
+    buf->vb.field  = field;
 
-	//precalculate_bars(fh);
+    //precalculate_bars(fh);
 
-	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
-		rc = videobuf_iolock(vq, &buf->vb, NULL);
-		if (rc < 0)
-			goto fail;
-	}
+    if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+        rc = videobuf_iolock(vq, &buf->vb, NULL);
+        if (rc < 0)
+            goto fail;
+    }
 
-	buf->vb.state = VIDEOBUF_PREPARED;
+    buf->vb.state = VIDEOBUF_PREPARED;
 
-	return 0;
+    return 0;
 
 fail:
-	free_buffer(vq, buf);
-	return rc;
+    res_free_buffer(vq, buf);
+    return rc;
+}
+
+static int
+vmall_buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+                        enum v4l2_field field)
+{
+    struct sp0838_fh *fh;
+    struct sp0838_device *dev;
+    struct sp0838_buffer *buf;
+    int rc;
+    fh = vq->priv_data;
+    dev = fh->dev;
+    buf = container_of(vb, struct sp0838_buffer, vb);
+    //int bytes = fh->fmt->depth >> 3 ;
+    dprintk(dev, 1, "%s, field=%d\n", __func__, field);
+
+    BUG_ON(NULL == fh->fmt);
+
+    if (fh->width  < 48 || fh->width  > norm_maxw() ||
+        fh->height < 32 || fh->height > norm_maxh())
+        return -EINVAL;
+
+    buf->vb.size = fh->width*fh->height*fh->fmt->depth >> 3;
+    if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+        return -EINVAL;
+
+    /* These properties only change when queue is idle, see s_fmt */
+    buf->fmt       = fh->fmt;
+    buf->vb.width  = fh->width;
+    buf->vb.height = fh->height;
+    buf->vb.field  = field;
+
+    //precalculate_bars(fh);
+
+    if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+        rc = videobuf_iolock(vq, &buf->vb, NULL);
+        if (rc < 0)
+            goto fail;
+    }
+
+    buf->vb.state = VIDEOBUF_PREPARED;
+
+    return 0;
+
+fail:
+    vmall_free_buffer(vq, buf);
+    return rc;
 }
 
 static void
-buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+res_buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
 {
-	struct sp0838_buffer    *buf  = container_of(vb, struct sp0838_buffer, vb);
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp0838_fh *fh = container_of(res, struct sp0838_fh, res);
-	struct sp0838_device       *dev  = fh->dev;
-	struct sp0838_dmaqueue *vidq = &dev->vidq;
+    struct sp0838_fh *fh;
+    struct sp0838_device *dev;
+    struct sp0838_dmaqueue *vidq;
+    struct sp0838_buffer *buf  = container_of(vb, struct sp0838_buffer, vb);
+    struct videobuf_res_privdata *res = vq->priv_data;
+    fh = container_of(res, struct sp0838_fh, res);
+    dev = fh->dev;
+    vidq = &dev->vidq;
+
+    dprintk(dev, 1, "%s\n", __func__);
+    buf->vb.state = VIDEOBUF_QUEUED;
+    list_add_tail(&buf->vb.queue, &vidq->active);
+}
 
-	dprintk(dev, 1, "%s\n", __func__);
-	buf->vb.state = VIDEOBUF_QUEUED;
-	list_add_tail(&buf->vb.queue, &vidq->active);
+static void
+vmall_buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+    struct sp0838_fh *fh;
+    struct sp0838_device *dev;
+    struct sp0838_dmaqueue *vidq;
+    struct sp0838_buffer *buf  = container_of(vb, struct sp0838_buffer, vb);
+    fh = vq->priv_data;
+    dev = fh->dev;
+    vidq = &dev->vidq;
+
+    dprintk(dev, 1, "%s\n", __func__);
+    buf->vb.state = VIDEOBUF_QUEUED;
+    list_add_tail(&buf->vb.queue, &vidq->active);
 }
 
-static void buffer_release(struct videobuf_queue *vq,
-			   struct videobuf_buffer *vb)
+static void res_buffer_release(struct videobuf_queue *vq,
+               struct videobuf_buffer *vb)
 {
-	struct sp0838_buffer   *buf  = container_of(vb, struct sp0838_buffer, vb);
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp0838_fh *fh = container_of(res, struct sp0838_fh, res);
-	struct sp0838_device      *dev  = (struct sp0838_device *)fh->dev;
+    struct sp0838_fh *fh;
+    struct sp0838_device *dev;
+    struct sp0838_buffer   *buf  = container_of(vb, struct sp0838_buffer, vb);
+    struct videobuf_res_privdata *res = vq->priv_data;
+    fh = container_of(res, struct sp0838_fh, res);
+    dev = (struct sp0838_device *)fh->dev;
 
-	dprintk(dev, 1, "%s\n", __func__);
+    dprintk(dev, 1, "%s\n", __func__);
 
-	free_buffer(vq, buf);
+    res_free_buffer(vq, buf);
 }
 
-static struct videobuf_queue_ops sp0838_video_qops = {
-	.buf_setup      = buffer_setup,
-	.buf_prepare    = buffer_prepare,
-	.buf_queue      = buffer_queue,
-	.buf_release    = buffer_release,
+static void vmall_buffer_release(struct videobuf_queue *vq,
+               struct videobuf_buffer *vb)
+{
+    struct sp0838_fh *fh;
+    struct sp0838_device *dev;
+    struct sp0838_buffer   *buf  = container_of(vb, struct sp0838_buffer, vb);
+    fh = vq->priv_data;
+    dev = (struct sp0838_device *)fh->dev;
+
+    dprintk(dev, 1, "%s\n", __func__);
+
+    vmall_free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops sp0838_video_vmall_qops = {
+    .buf_setup      = vmall_buffer_setup,
+    .buf_prepare    = vmall_buffer_prepare,
+    .buf_queue      = vmall_buffer_queue,
+    .buf_release    = vmall_buffer_release,
+};
+
+static struct videobuf_queue_ops sp0838_video_res_qops = {
+    .buf_setup      = res_buffer_setup,
+    .buf_prepare    = res_buffer_prepare,
+    .buf_queue      = res_buffer_queue,
+    .buf_release    = res_buffer_release,
 };
 
 /* ------------------------------------------------------------------
-	IOCTL vidioc handling
+    IOCTL vidioc handling
    ------------------------------------------------------------------*/
 static int vidioc_querycap(struct file *file, void  *priv,
-					struct v4l2_capability *cap)
-{
-	struct sp0838_fh  *fh  = priv;
-	struct sp0838_device *dev = fh->dev;
-
-	strcpy(cap->driver, "sp0838");
-	strcpy(cap->card, "sp0838.canvas");
-	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
-	cap->version = SP0838_CAMERA_VERSION;
-	cap->capabilities =	V4L2_CAP_VIDEO_CAPTURE |
-				V4L2_CAP_STREAMING     |
-				V4L2_CAP_READWRITE;
-	return 0;
+                    struct v4l2_capability *cap)
+{
+    struct sp0838_fh  *fh  = priv;
+    struct sp0838_device *dev = fh->dev;
+
+    strcpy(cap->driver, "sp0838");
+    strcpy(cap->card, "sp0838.canvas");
+    strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+    cap->version = SP0838_CAMERA_VERSION;
+    cap->capabilities = V4L2_CAP_VIDEO_CAPTURE |
+                V4L2_CAP_STREAMING     |
+                V4L2_CAP_READWRITE;
+    return 0;
 }
 
 static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
-					struct v4l2_fmtdesc *f)
+                    struct v4l2_fmtdesc *f)
 {
-	struct sp0838_fmt *fmt;
+    struct sp0838_fmt *fmt;
 
-	if (f->index >= ARRAY_SIZE(formats))
-		return -EINVAL;
+    if (f->index >= ARRAY_SIZE(formats))
+        return -EINVAL;
 
-	fmt = &formats[f->index];
+    fmt = &formats[f->index];
 
-	strlcpy(f->description, fmt->name, sizeof(f->description));
-	f->pixelformat = fmt->fourcc;
-	return 0;
+    strlcpy(f->description, fmt->name, sizeof(f->description));
+    f->pixelformat = fmt->fourcc;
+    return 0;
 }
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
         unsigned int k;
 
-	if(fival->index > ARRAY_SIZE(sp0838_frmivalenum))
-		return -EINVAL;
-	
-	for(k =0; k< ARRAY_SIZE(sp0838_frmivalenum); k++) {
-		if( (fival->index==sp0838_frmivalenum[k].index)&&
-				(fival->pixel_format ==sp0838_frmivalenum[k].pixel_format )&&
-				(fival->width=sp0838_frmivalenum[k].width)&&
-				(fival->height==sp0838_frmivalenum[k].height)){
-			memcpy( fival, &sp0838_frmivalenum[k], sizeof(struct v4l2_frmivalenum));
-			return 0;
-		}
-	}
-
-	return -EINVAL;
+    if (fival->index > ARRAY_SIZE(sp0838_frmivalenum))
+        return -EINVAL;
+
+    for (k = 0; k < ARRAY_SIZE(sp0838_frmivalenum); k++) {
+        if ((fival->index == sp0838_frmivalenum[k].index) &&
+                (fival->pixel_format == sp0838_frmivalenum[k].pixel_format ) &&
+                (fival->width=sp0838_frmivalenum[k].width) &&
+                (fival->height==sp0838_frmivalenum[k].height)) {
+            memcpy( fival, &sp0838_frmivalenum[k], sizeof(struct v4l2_frmivalenum));
+            return 0;
+        }
+    }
+
+    return -EINVAL;
 
 }
 static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
-					struct v4l2_format *f)
+                    struct v4l2_format *f)
 {
-	struct sp0838_fh *fh = priv;
-
-	f->fmt.pix.width        = fh->width;
-	f->fmt.pix.height       = fh->height;
-	f->fmt.pix.field        = fh->vb_vidq.field;
-	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
-	f->fmt.pix.bytesperline =
-		(f->fmt.pix.width * fh->fmt->depth) >> 3;
-	f->fmt.pix.sizeimage =
-		f->fmt.pix.height * f->fmt.pix.bytesperline;
-
-	return (0);
+    struct sp0838_fh *fh = priv;
+
+    f->fmt.pix.width        = fh->width;
+    f->fmt.pix.height       = fh->height;
+    f->fmt.pix.field        = fh->vb_vidq.field;
+    f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+    f->fmt.pix.bytesperline =
+        (f->fmt.pix.width * fh->fmt->depth) >> 3;
+    f->fmt.pix.sizeimage =
+        f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+    return (0);
 }
 
 static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
-			struct v4l2_format *f)
-{
-	struct sp0838_fh  *fh  = priv;
-	struct sp0838_device *dev = fh->dev;
-	struct sp0838_fmt *fmt;
-	enum v4l2_field field;
-	unsigned int maxw, maxh;
-
-	fmt = get_format(f);
-	if (!fmt) {
-		dprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",
-			f->fmt.pix.pixelformat);
-		return -EINVAL;
-	}
-
-	field = f->fmt.pix.field;
-
-	if (field == V4L2_FIELD_ANY) {
-		field = V4L2_FIELD_INTERLACED;
-	} else if (V4L2_FIELD_INTERLACED != field) {
-		dprintk(dev, 1, "Field type invalid.\n");
-		return -EINVAL;
-	}
-
-	maxw  = norm_maxw();
-	maxh  = norm_maxh();
-
-	f->fmt.pix.field = field;
-	v4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,
-			      &f->fmt.pix.height, 32, maxh, 0, 0);
-	f->fmt.pix.bytesperline =
-		(f->fmt.pix.width * fmt->depth) >> 3;
-	f->fmt.pix.sizeimage =
-		f->fmt.pix.height * f->fmt.pix.bytesperline;
-
-	return 0;
+            struct v4l2_format *f)
+{
+    struct sp0838_fh  *fh  = priv;
+    struct sp0838_device *dev = fh->dev;
+    struct sp0838_fmt *fmt;
+    enum v4l2_field field;
+    unsigned int maxw, maxh;
+
+    fmt = get_format(f);
+    if (!fmt) {
+        dprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",
+            f->fmt.pix.pixelformat);
+        return -EINVAL;
+    }
+
+    field = f->fmt.pix.field;
+
+    if (field == V4L2_FIELD_ANY) {
+        field = V4L2_FIELD_INTERLACED;
+    } else if (V4L2_FIELD_INTERLACED != field) {
+        dprintk(dev, 1, "Field type invalid.\n");
+        return -EINVAL;
+    }
+
+    maxw  = norm_maxw();
+    maxh  = norm_maxh();
+
+    f->fmt.pix.field = field;
+    v4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,
+                  &f->fmt.pix.height, 32, maxh, 0, 0);
+    f->fmt.pix.bytesperline =
+        (f->fmt.pix.width * fmt->depth) >> 3;
+    f->fmt.pix.sizeimage =
+        f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+    return 0;
 }
 
 /*FIXME: This seems to be generic enough to be at videodev2 */
 static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
-					struct v4l2_format *f)
-{
-	struct sp0838_fh *fh = priv;
-	struct videobuf_queue *q = &fh->vb_vidq;
-	int ret;
-	
-	f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN-1) ) & (~(CANVAS_WIDTH_ALIGN-1));
-	if ((f->fmt.pix.pixelformat==V4L2_PIX_FMT_YVU420) ||
-			(f->fmt.pix.pixelformat==V4L2_PIX_FMT_YUV420)){
-		f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN*2-1) ) & (~(CANVAS_WIDTH_ALIGN*2-1));
-	}
-
-	ret = vidioc_try_fmt_vid_cap(file, fh, f);
-	if (ret < 0)
-		return ret;
-
-	mutex_lock(&q->vb_lock);
-
-	if (videobuf_queue_is_busy(&fh->vb_vidq)) {
-		dprintk(fh->dev, 1, "%s queue busy\n", __func__);
-		ret = -EBUSY;
-		goto out;
-	}
-
-	fh->fmt           = get_format(f);
-	fh->width         = f->fmt.pix.width;
-	fh->height        = f->fmt.pix.height;
-	fh->vb_vidq.field = f->fmt.pix.field;
-	fh->type          = f->type;
+                    struct v4l2_format *f)
+{
+    struct sp0838_fh *fh = priv;
+    struct videobuf_queue *q = &fh->vb_vidq;
+    int ret;
+
+    f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN-1) ) & (~(CANVAS_WIDTH_ALIGN-1));
+    if ((f->fmt.pix.pixelformat == V4L2_PIX_FMT_YVU420) ||
+            (f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUV420)) {
+        f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN*2-1) ) & (~(CANVAS_WIDTH_ALIGN*2-1));
+    }
+
+    ret = vidioc_try_fmt_vid_cap(file, fh, f);
+    if (ret < 0)
+        return ret;
+
+    mutex_lock(&q->vb_lock);
+
+    if (videobuf_queue_is_busy(&fh->vb_vidq)) {
+        dprintk(fh->dev, 1, "%s queue busy\n", __func__);
+        ret = -EBUSY;
+        goto out;
+    }
+
+    fh->fmt           = get_format(f);
+    fh->width         = f->fmt.pix.width;
+    fh->height        = f->fmt.pix.height;
+    fh->vb_vidq.field = f->fmt.pix.field;
+    fh->type          = f->type;
 #if 1
-	if(f->fmt.pix.pixelformat==V4L2_PIX_FMT_RGB24){
-		sp0838_set_resolution(fh->dev,fh->height,fh->width);
-	} else {
-		sp0838_set_resolution(fh->dev,fh->height,fh->width);
-	}
+    if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {
+        sp0838_set_resolution(fh->dev,fh->height,fh->width);
+    } else {
+        sp0838_set_resolution(fh->dev,fh->height,fh->width);
+    }
 #endif
-	ret = 0;
+    ret = 0;
 out:
-	mutex_unlock(&q->vb_lock);
+    mutex_unlock(&q->vb_lock);
 
-	return ret;
+    return ret;
 }
 
 static int vidioc_g_parm(struct file *file, void *priv,
         struct v4l2_streamparm *parms)
 {
-	struct sp0838_fh *fh = priv;
-	struct sp0838_device *dev = fh->dev;
-	struct v4l2_captureparm *cp = &parms->parm.capture;
-	
-	dprintk(dev,3,"vidioc_g_parm\n");
-	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-	
-	memset(cp, 0, sizeof(struct v4l2_captureparm));
-	cp->capability = V4L2_CAP_TIMEPERFRAME;
-	
-	cp->timeperframe = sp0838_frmintervals_active;
-	printk("g_parm,deno=%d, numerator=%d\n", cp->timeperframe.denominator,
-	        cp->timeperframe.numerator );
-	return 0;
+    struct sp0838_fh *fh = priv;
+    struct sp0838_device *dev = fh->dev;
+    struct v4l2_captureparm *cp = &parms->parm.capture;
+
+    dprintk(dev,3,"vidioc_g_parm\n");
+    if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+        return -EINVAL;
+
+    memset(cp, 0, sizeof(struct v4l2_captureparm));
+    cp->capability = V4L2_CAP_TIMEPERFRAME;
+
+    cp->timeperframe = sp0838_frmintervals_active;
+    printk("g_parm,deno=%d, numerator=%d\n", cp->timeperframe.denominator,
+            cp->timeperframe.numerator );
+    return 0;
 }
 static int vidioc_reqbufs(struct file *file, void *priv,
-			  struct v4l2_requestbuffers *p)
+              struct v4l2_requestbuffers *p)
 {
-	struct sp0838_fh  *fh = priv;
+    struct sp0838_fh  *fh = priv;
 
-	return (videobuf_reqbufs(&fh->vb_vidq, p));
+    return (videobuf_reqbufs(&fh->vb_vidq, p));
 }
 
 static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
 {
-	struct sp0838_fh  *fh = priv;
+    struct sp0838_fh  *fh = priv;
 
         int ret = videobuf_querybuf(&fh->vb_vidq, p);
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	if(ret == 0){
-		p->reserved  = convert_canvas_index(fh->fmt->fourcc, CAMERA_USER_CANVAS_INDEX + p->index*3);
-	}else{
-		p->reserved = 0;
-	}
+    if (ret == 0) {
+        p->reserved  = convert_canvas_index(fh->fmt->fourcc, CAMERA_USER_CANVAS_INDEX + p->index * 3);
+    } else {
+        p->reserved = 0;
+    }
 #endif
-	return ret;
+    return ret;
 }
 
 static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
 {
-	struct sp0838_fh *fh = priv;
+    struct sp0838_fh *fh = priv;
 
-	return (videobuf_qbuf(&fh->vb_vidq, p));
+    return (videobuf_qbuf(&fh->vb_vidq, p));
 }
 
 static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
 {
-	struct sp0838_fh  *fh = priv;
+    struct sp0838_fh  *fh = priv;
 
-	return (videobuf_dqbuf(&fh->vb_vidq, p,
-				file->f_flags & O_NONBLOCK));
+    return (videobuf_dqbuf(&fh->vb_vidq, p,
+                file->f_flags & O_NONBLOCK));
 }
 
 #ifdef CONFIG_VIDEO_V4L1_COMPAT
 static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
 {
-	struct sp0838_fh  *fh = priv;
+    struct sp0838_fh  *fh = priv;
 
-	return videobuf_cgmbuf(&fh->vb_vidq, mbuf, 8);
+    return videobuf_cgmbuf(&fh->vb_vidq, mbuf, 8);
 }
 #endif
 
 static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 {
-	struct sp0838_fh  *fh = priv;
-	vdin_parm_t para;
-	int ret = 0 ;
-	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-	if (i != fh->type)
-		return -EINVAL;
-	memset( &para, 0, sizeof( para ));
-	para.port  = TVIN_PORT_CAMERA;
-	para.fmt = TVIN_SIG_FMT_MAX;
-	para.frame_rate = sp0838_frmintervals_active.denominator;
-	para.h_active = sp0838_h_active;
-	para.v_active = sp0838_v_active;
-	para.hsync_phase = 0;
-	para.vsync_phase = 1;
-	para.hs_bp = 0;
-	para.vs_bp = 2;
-	para.cfmt = TVIN_YVYU422;
+    struct sp0838_fh  *fh = priv;
+    vdin_parm_t para;
+    int ret = 0 ;
+    if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+        return -EINVAL;
+    if (i != fh->type)
+        return -EINVAL;
+    memset( &para, 0, sizeof( para ));
+    para.port  = TVIN_PORT_CAMERA;
+    para.fmt = TVIN_SIG_FMT_MAX;
+    para.frame_rate = sp0838_frmintervals_active.denominator;
+    para.h_active = sp0838_h_active;
+    para.v_active = sp0838_v_active;
+    para.hsync_phase = 0;
+    para.vsync_phase = 1;
+    para.hs_bp = 0;
+    para.vs_bp = 2;
+    para.cfmt = TVIN_YVYU422;
         para.dfmt = TVIN_YVYU422;
-	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.skip_count =  2; //skip_num
-	printk("0a19,h=%d, v=%d, frame_rate=%d\n", sp0838_h_active, sp0838_v_active, sp0838_frmintervals_active.denominator);
-	ret =  videobuf_streamon(&fh->vb_vidq);
-	if(ret == 0){
-		vops->start_tvin_service(0,&para);
-		fh->stream_on        = 1;
-	}
-	return ret;
+    para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
+    para.skip_count =  2; //skip_num
+    printk("0a19,h=%d, v=%d, frame_rate=%d\n", sp0838_h_active, sp0838_v_active, sp0838_frmintervals_active.denominator);
+    ret =  videobuf_streamon(&fh->vb_vidq);
+    if (ret == 0) {
+        if (fh->dev->vminfo.isused) {
+            vops->start_tvin_service(0,&para);
+        }
+        fh->stream_on        = 1;
+    }
+    return ret;
 }
 
 static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
 {
-	struct sp0838_fh  *fh = priv;
-
-	int ret = 0 ;
-	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-	if (i != fh->type)
-		return -EINVAL;
-	ret = videobuf_streamoff(&fh->vb_vidq);
-	if(ret == 0 ){
-		vops->stop_tvin_service(0);
-		fh->stream_on        = 0;
-	}
-	return ret;
+    struct sp0838_fh  *fh = priv;
+
+    int ret = 0 ;
+    if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+        return -EINVAL;
+    if (i != fh->type)
+        return -EINVAL;
+    ret = videobuf_streamoff(&fh->vb_vidq);
+    if (ret == 0 ) {
+        if (fh->dev->vminfo.isused) {
+            vops->stop_tvin_service(0);
+        }
+        fh->stream_on        = 0;
+    }
+    return ret;
 }
 
 static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsizeenum *fsize)
 {
-	int ret = 0,i=0;
-	struct sp0838_fmt *fmt = NULL;
-	struct v4l2_frmsize_discrete *frmsize = NULL;
-	for (i = 0; i < ARRAY_SIZE(formats); i++) {
-		if (formats[i].fourcc == fsize->pixel_format){
-			fmt = &formats[i];
-			break;
-		}
-	}
-	if (fmt == NULL)
-		return -EINVAL;
-	if ((fmt->fourcc == V4L2_PIX_FMT_NV21)
-		||(fmt->fourcc == V4L2_PIX_FMT_NV12)
-		||(fmt->fourcc == V4L2_PIX_FMT_YUV420)
-		||(fmt->fourcc == V4L2_PIX_FMT_YVU420)
-		){
-		if (fsize->index >= ARRAY_SIZE(sp0838_prev_resolution))
-			return -EINVAL;
-		frmsize = &sp0838_prev_resolution[fsize->index];
-		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-		fsize->discrete.width = frmsize->width;
-		fsize->discrete.height = frmsize->height;
-	}
-	else if(fmt->fourcc == V4L2_PIX_FMT_RGB24){
-		if (fsize->index >= ARRAY_SIZE(sp0838_pic_resolution))
-			return -EINVAL;
-		frmsize = &sp0838_pic_resolution[fsize->index];
-		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-		fsize->discrete.width = frmsize->width;
-		fsize->discrete.height = frmsize->height;
-	}
-	return ret;
+    int ret = 0,i=0;
+    struct sp0838_fmt *fmt = NULL;
+    struct v4l2_frmsize_discrete *frmsize = NULL;
+    for (i = 0; i < ARRAY_SIZE(formats); i++) {
+        if (formats[i].fourcc == fsize->pixel_format) {
+            fmt = &formats[i];
+            break;
+        }
+    }
+    if (fmt == NULL)
+        return -EINVAL;
+    if ((fmt->fourcc == V4L2_PIX_FMT_NV21)
+        ||(fmt->fourcc == V4L2_PIX_FMT_NV12)
+        ||(fmt->fourcc == V4L2_PIX_FMT_YUV420)
+        ||(fmt->fourcc == V4L2_PIX_FMT_YVU420)
+        ) {
+        if (fsize->index >= ARRAY_SIZE(sp0838_prev_resolution))
+            return -EINVAL;
+        frmsize = &sp0838_prev_resolution[fsize->index];
+        fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+        fsize->discrete.width = frmsize->width;
+        fsize->discrete.height = frmsize->height;
+    }
+    else if (fmt->fourcc == V4L2_PIX_FMT_RGB24) {
+        if (fsize->index >= ARRAY_SIZE(sp0838_pic_resolution))
+            return -EINVAL;
+        frmsize = &sp0838_pic_resolution[fsize->index];
+        fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+        fsize->discrete.width = frmsize->width;
+        fsize->discrete.height = frmsize->height;
+    }
+    return ret;
 }
 
 static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
-	return 0;
+    return 0;
 }
 
 /* only one input in this sample driver */
 static int vidioc_enum_input(struct file *file, void *priv,
-				struct v4l2_input *inp)
+                struct v4l2_input *inp)
 {
-	//if (inp->index >= NUM_INPUTS)
-		//return -EINVAL;
+    //if (inp->index >= NUM_INPUTS)
+        //return -EINVAL;
 
-	inp->type = V4L2_INPUT_TYPE_CAMERA;
-	inp->std = V4L2_STD_525_60;
-	sprintf(inp->name, "Camera %u", inp->index);
+    inp->type = V4L2_INPUT_TYPE_CAMERA;
+    inp->std = V4L2_STD_525_60;
+    sprintf(inp->name, "Camera %u", inp->index);
 
-	return (0);
+    return (0);
 }
 
 static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
 {
-	struct sp0838_fh *fh = priv;
-	struct sp0838_device *dev = fh->dev;
+    struct sp0838_fh *fh = priv;
+    struct sp0838_device *dev = fh->dev;
 
-	*i = dev->input;
+    *i = dev->input;
 
-	return (0);
+    return (0);
 }
 
 static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
 {
-	struct sp0838_fh *fh = priv;
-	struct sp0838_device *dev = fh->dev;
+    struct sp0838_fh *fh = priv;
+    struct sp0838_device *dev = fh->dev;
 
-	//if (i >= NUM_INPUTS)
-		//return -EINVAL;
+    //if (i >= NUM_INPUTS)
+        //return -EINVAL;
 
-	dev->input = i;
-	//precalculate_bars(fh);
+    dev->input = i;
+    //precalculate_bars(fh);
 
-	return (0);
+    return (0);
 }
 
-	/* --- controls ---------------------------------------------- */
+    /* --- controls ---------------------------------------------- */
 static int vidioc_queryctrl(struct file *file, void *priv,
-			    struct v4l2_queryctrl *qc)
+                struct v4l2_queryctrl *qc)
 {
-	int i;
+    int i;
 
-	for (i = 0; i < ARRAY_SIZE(sp0838_qctrl); i++)
-		if (qc->id && qc->id == sp0838_qctrl[i].id) {
-			memcpy(qc, &(sp0838_qctrl[i]),
-				sizeof(*qc));
-			return (0);
-		}
+    for (i = 0; i < ARRAY_SIZE(sp0838_qctrl); i++)
+        if (qc->id && qc->id == sp0838_qctrl[i].id) {
+            memcpy(qc, &(sp0838_qctrl[i]),
+                sizeof(*qc));
+            return (0);
+        }
 
-	return -EINVAL;
+    return -EINVAL;
 }
 
 static int vidioc_g_ctrl(struct file *file, void *priv,
-			 struct v4l2_control *ctrl)
+             struct v4l2_control *ctrl)
 {
-	struct sp0838_fh *fh = priv;
-	struct sp0838_device *dev = fh->dev;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(sp0838_qctrl); i++)
-		if (ctrl->id == sp0838_qctrl[i].id) {
-			ctrl->value = dev->qctl_regs[i];
-			return 0;
-		}
+    struct sp0838_fh *fh = priv;
+    struct sp0838_device *dev = fh->dev;
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(sp0838_qctrl); i++)
+        if (ctrl->id == sp0838_qctrl[i].id) {
+            ctrl->value = dev->qctl_regs[i];
+            return 0;
+        }
 
-	return -EINVAL;
+    return -EINVAL;
 }
 
 static int vidioc_s_ctrl(struct file *file, void *priv,
-				struct v4l2_control *ctrl)
-{
-	struct sp0838_fh *fh = priv;
-	struct sp0838_device *dev = fh->dev;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(sp0838_qctrl); i++)
-		if (ctrl->id == sp0838_qctrl[i].id) {
-			if (ctrl->value < sp0838_qctrl[i].minimum ||
-			    ctrl->value > sp0838_qctrl[i].maximum ||
-			    sp0838_setting(dev,ctrl->id,ctrl->value)<0) {
-				return -ERANGE;
-			}
-			dev->qctl_regs[i] = ctrl->value;
-			return 0;
-		}
-	return -EINVAL;
+                struct v4l2_control *ctrl)
+{
+    struct sp0838_fh *fh = priv;
+    struct sp0838_device *dev = fh->dev;
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(sp0838_qctrl); i++)
+        if (ctrl->id == sp0838_qctrl[i].id) {
+            if (ctrl->value < sp0838_qctrl[i].minimum ||
+                ctrl->value > sp0838_qctrl[i].maximum ||
+                sp0838_setting(dev,ctrl->id,ctrl->value)<0) {
+                return -ERANGE;
+            }
+            dev->qctl_regs[i] = ctrl->value;
+            return 0;
+        }
+    return -EINVAL;
 }
 
 /* ------------------------------------------------------------------
-	File operations for the device
+    File operations for the device
    ------------------------------------------------------------------*/
 
 static int sp0838_open(struct file *file)
 {
-	struct sp0838_device *dev = video_drvdata(file);
-	struct sp0838_fh *fh = NULL;
-	int retval = 0;
-	resource_size_t mem_start = 0;
-	unsigned int mem_size = 0;
+    struct sp0838_device *dev = video_drvdata(file);
+    struct sp0838_fh *fh = NULL;
+    int retval = 0;
 #if CONFIG_CMA
-	retval = vm_init_buf(16*SZ_1M);
-	if(retval <0)
-		return -1;
+    vm_init_resource(16*SZ_1M, &dev->vminfo);
 #endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	switch_mod_gate_by_name("ge2d", 1);
-#endif		
-	aml_cam_init(&dev->cam_info);	
-	
-	SP0838_init_regs(dev);
-	msleep(100);//40
-	mutex_lock(&dev->mutex);
-	dev->users++;
-	if (dev->users > 1) {
-		dev->users--;
-		mutex_unlock(&dev->mutex);
-		return -EBUSY;
-	}
-
-	dprintk(dev, 1, "open %s type=%s users=%d\n",
-		video_device_node_name(dev->vdev),
-		v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
-
-    	/* init video dma queues */
-	INIT_LIST_HEAD(&dev->vidq.active);
-	init_waitqueue_head(&dev->vidq.wq);
-	spin_lock_init(&dev->slock);
-	/* allocate + initialize per filehandle data */
-	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
-	if (NULL == fh) {
-		dev->users--;
-		retval = -ENOMEM;
-	}
-	mutex_unlock(&dev->mutex);
-
-	if (retval)
-		return retval;
-
-	wake_lock(&(dev->wake_lock));
-	file->private_data = fh;
-	fh->dev      = dev;
-
-	fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	fh->fmt      = &formats[6];
-	fh->width    = 640;
-	fh->height   = 480;
-	fh->stream_on = 0 ;
-	fh->f_flags  = file->f_flags;
-	/* Resets frame counters */
-	dev->jiffies = jiffies;
-
-//	TVIN_SIG_FMT_CAMERA_640X480P_30Hz,
-//	TVIN_SIG_FMT_CAMERA_800X600P_30Hz,
-//	TVIN_SIG_FMT_CAMERA_1024X768P_30Hz, // 190
-//	TVIN_SIG_FMT_CAMERA_1920X1080P_30Hz,
-//	TVIN_SIG_FMT_CAMERA_1280X720P_30Hz,
-
-	get_vm_buf_info(&mem_start, &mem_size, NULL);
-	fh->res.start = mem_start;
-	fh->res.end = mem_start+mem_size-1;
-	fh->res.magic = MAGIC_RE_MEM;
-	fh->res.priv = NULL;
-	videobuf_queue_res_init(&fh->vb_vidq, &sp0838_video_qops,
-	NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
-	sizeof(struct sp0838_buffer), (void*)&fh->res, NULL);
-
-	sp0838_start_thread(fh);
-
-	return 0;
+    switch_mod_gate_by_name("ge2d", 1);
+#endif
+    if (dev->vminfo.isused) {
+        aml_cam_init(&dev->cam_info);
+    }
+
+    SP0838_init_regs(dev);
+    msleep(100);//40
+    mutex_lock(&dev->mutex);
+    dev->users++;
+    if (dev->users > 1) {
+        dev->users--;
+        mutex_unlock(&dev->mutex);
+        return -EBUSY;
+    }
+
+    dprintk(dev, 1, "open %s type=%s users=%d\n",
+        video_device_node_name(dev->vdev),
+        v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
+
+        /* init video dma queues */
+    INIT_LIST_HEAD(&dev->vidq.active);
+    init_waitqueue_head(&dev->vidq.wq);
+    spin_lock_init(&dev->slock);
+    /* allocate + initialize per filehandle data */
+    fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+    if (NULL == fh) {
+        dev->users--;
+        retval = -ENOMEM;
+    }
+    mutex_unlock(&dev->mutex);
+
+    if (retval)
+        return retval;
+
+    wake_lock(&(dev->wake_lock));
+    file->private_data = fh;
+    fh->dev      = dev;
+
+    fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    fh->fmt      = &formats[6];
+    fh->width    = 640;
+    fh->height   = 480;
+    fh->stream_on = 0 ;
+    fh->f_flags  = file->f_flags;
+    /* Resets frame counters */
+    dev->jiffies = jiffies;
+
+//  TVIN_SIG_FMT_CAMERA_640X480P_30Hz,
+//  TVIN_SIG_FMT_CAMERA_800X600P_30Hz,
+//  TVIN_SIG_FMT_CAMERA_1024X768P_30Hz, // 190
+//  TVIN_SIG_FMT_CAMERA_1920X1080P_30Hz,
+//  TVIN_SIG_FMT_CAMERA_1280X720P_30Hz,
+
+    if (dev->vminfo.mem_alloc_succeed) {
+        fh->res.start = dev->vminfo.buffer_start;
+        fh->res.end = dev->vminfo.buffer_start + dev->vminfo.vm_buf_size - 1;
+        fh->res.magic = MAGIC_RE_MEM;
+        fh->res.priv = NULL;
+        videobuf_queue_res_init(&fh->vb_vidq, &sp0838_video_res_qops,
+        NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
+        sizeof(struct sp0838_buffer), (void*)&fh->res, NULL);
+    } else {
+        videobuf_queue_vmalloc_init(&fh->vb_vidq, &sp0838_video_vmall_qops,
+        NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
+        sizeof(struct sp0838_buffer), fh, NULL);
+    }
+
+    sp0838_start_thread(fh);
+
+    return 0;
 }
 
 static ssize_t
 sp0838_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
 {
-	struct sp0838_fh *fh = file->private_data;
+    struct sp0838_fh *fh = file->private_data;
 
-	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		return videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,
-					file->f_flags & O_NONBLOCK);
-	}
-	return 0;
+    if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+        return videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,
+                    file->f_flags & O_NONBLOCK);
+    }
+    return 0;
 }
 
 static unsigned int
 sp0838_poll(struct file *file, struct poll_table_struct *wait)
 {
-	struct sp0838_fh        *fh = file->private_data;
-	struct sp0838_device       *dev = fh->dev;
-	struct videobuf_queue *q = &fh->vb_vidq;
+    struct sp0838_fh        *fh = file->private_data;
+    struct sp0838_device       *dev = fh->dev;
+    struct videobuf_queue *q = &fh->vb_vidq;
 
-	dprintk(dev, 1, "%s\n", __func__);
+    dprintk(dev, 1, "%s\n", __func__);
 
-	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)
-		return POLLERR;
+    if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)
+        return POLLERR;
 
-	return videobuf_poll_stream(file, q, wait);
+    return videobuf_poll_stream(file, q, wait);
 }
 
 static int sp0838_close(struct file *file)
 {
-	struct sp0838_fh         *fh = file->private_data;
-	struct sp0838_device *dev       = fh->dev;
-	struct sp0838_dmaqueue *vidq = &dev->vidq;
-	struct video_device  *vdev = video_devdata(file);
-	sp0838_have_open=0;
-
-	sp0838_stop_thread(vidq);
-	videobuf_stop(&fh->vb_vidq);
-	if(fh->stream_on){
-	    vops->stop_tvin_service(0);
-	}
-	videobuf_mmap_free(&fh->vb_vidq);
+    struct sp0838_fh         *fh = file->private_data;
+    struct sp0838_device *dev       = fh->dev;
+    struct sp0838_dmaqueue *vidq = &dev->vidq;
+    struct video_device  *vdev = video_devdata(file);
+    sp0838_have_open=0;
+    sp0838_stop_thread(vidq);
+    videobuf_stop(&fh->vb_vidq);
+    if (fh->stream_on) {
+        if (dev->vminfo.isused) {
+            vops->stop_tvin_service(0);
+        }
+    }
+    videobuf_mmap_free(&fh->vb_vidq);
 
-	kfree(fh);
+    kfree(fh);
 
-	mutex_lock(&dev->mutex);
-	dev->users--;
-	mutex_unlock(&dev->mutex);
+    mutex_lock(&dev->mutex);
+    dev->users--;
+    mutex_unlock(&dev->mutex);
 
-	dprintk(dev, 1, "close called (dev=%s, users=%d)\n",
-		video_device_node_name(vdev), dev->users);
+    dprintk(dev, 1, "close called (dev=%s, users=%d)\n",
+        video_device_node_name(vdev), dev->users);
 #if 1
-	sp0838_qctrl[0].default_value=0;
-	sp0838_qctrl[1].default_value=4;
-	sp0838_qctrl[2].default_value=0;
-	sp0838_qctrl[3].default_value=0;
-	sp0838_qctrl[4].default_value=0;
-
-	sp0838_frmintervals_active.numerator = 1;
-	sp0838_frmintervals_active.denominator = 15;
-	//power_down_sp0838(dev);
+    sp0838_qctrl[0].default_value=0;
+    sp0838_qctrl[1].default_value=4;
+    sp0838_qctrl[2].default_value=0;
+    sp0838_qctrl[3].default_value=0;
+    sp0838_qctrl[4].default_value=0;
+
+    sp0838_frmintervals_active.numerator = 1;
+    sp0838_frmintervals_active.denominator = 15;
+    //power_down_sp0838(dev);
 #endif
-	aml_cam_uninit(&dev->cam_info);
-	
+    aml_cam_uninit(&dev->cam_info);
+
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	switch_mod_gate_by_name("ge2d", 0);
-#endif	
-	wake_unlock(&(dev->wake_lock));
+    switch_mod_gate_by_name("ge2d", 0);
+#endif
+    wake_unlock(&(dev->wake_lock));
 #ifdef CONFIG_CMA
-    vm_deinit_buf();
+    vm_deinit_resource(&dev->vminfo);
 #endif
-	return 0;
+
+    return 0;
 }
 
 static int sp0838_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct sp0838_fh  *fh = file->private_data;
-	struct sp0838_device *dev = fh->dev;
-	int ret;
+    struct sp0838_fh  *fh = file->private_data;
+    struct sp0838_device *dev = fh->dev;
+    int ret;
 
-	dprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
+    dprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
 
-	ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
+    ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
 
-	dprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",
-		(unsigned long)vma->vm_start,
-		(unsigned long)vma->vm_end-(unsigned long)vma->vm_start,
-		ret);
+    dprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",
+        (unsigned long)vma->vm_start,
+        (unsigned long)vma->vm_end-(unsigned long)vma->vm_start,
+        ret);
 
-	return ret;
+    return ret;
 }
 
 static const struct v4l2_file_operations sp0838_fops = {
-	.owner		= THIS_MODULE,
-	.open           = sp0838_open,
-	.release        = sp0838_close,
-	.read           = sp0838_read,
-	.poll		= sp0838_poll,
-	.ioctl          = video_ioctl2, /* V4L2 ioctl handler */
-	.mmap           = sp0838_mmap,
+    .owner      = THIS_MODULE,
+    .open           = sp0838_open,
+    .release        = sp0838_close,
+    .read           = sp0838_read,
+    .poll       = sp0838_poll,
+    .ioctl          = video_ioctl2, /* V4L2 ioctl handler */
+    .mmap           = sp0838_mmap,
 };
 
 static const struct v4l2_ioctl_ops sp0838_ioctl_ops = {
-	.vidioc_querycap      = vidioc_querycap,
-	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
-	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
-	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
-	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
-	.vidioc_reqbufs       = vidioc_reqbufs,
-	.vidioc_querybuf      = vidioc_querybuf,
-	.vidioc_qbuf          = vidioc_qbuf,
-	.vidioc_dqbuf         = vidioc_dqbuf,
-	.vidioc_s_std         = vidioc_s_std,
-	.vidioc_enum_input    = vidioc_enum_input,
-	.vidioc_g_input       = vidioc_g_input,
-	.vidioc_s_input       = vidioc_s_input,
-	.vidioc_queryctrl     = vidioc_queryctrl,
-	.vidioc_querymenu     = vidioc_querymenu,
-	.vidioc_g_ctrl        = vidioc_g_ctrl,
-	.vidioc_s_ctrl        = vidioc_s_ctrl,
-	.vidioc_streamon      = vidioc_streamon,
-	.vidioc_streamoff     = vidioc_streamoff,
-	.vidioc_enum_framesizes = vidioc_enum_framesizes,
-	.vidioc_g_parm = vidioc_g_parm,
-	.vidioc_enum_frameintervals = vidioc_enum_frameintervals,
+    .vidioc_querycap      = vidioc_querycap,
+    .vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+    .vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+    .vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+    .vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+    .vidioc_reqbufs       = vidioc_reqbufs,
+    .vidioc_querybuf      = vidioc_querybuf,
+    .vidioc_qbuf          = vidioc_qbuf,
+    .vidioc_dqbuf         = vidioc_dqbuf,
+    .vidioc_s_std         = vidioc_s_std,
+    .vidioc_enum_input    = vidioc_enum_input,
+    .vidioc_g_input       = vidioc_g_input,
+    .vidioc_s_input       = vidioc_s_input,
+    .vidioc_queryctrl     = vidioc_queryctrl,
+    .vidioc_querymenu     = vidioc_querymenu,
+    .vidioc_g_ctrl        = vidioc_g_ctrl,
+    .vidioc_s_ctrl        = vidioc_s_ctrl,
+    .vidioc_streamon      = vidioc_streamon,
+    .vidioc_streamoff     = vidioc_streamoff,
+    .vidioc_enum_framesizes = vidioc_enum_framesizes,
+    .vidioc_g_parm = vidioc_g_parm,
+    .vidioc_enum_frameintervals = vidioc_enum_frameintervals,
 #ifdef CONFIG_VIDEO_V4L1_COMPAT
-	.vidiocgmbuf          = vidiocgmbuf,
+    .vidiocgmbuf          = vidiocgmbuf,
 #endif
 };
 
 static struct video_device sp0838_template = {
-	.name		= "sp0838_v4l",
-	.fops           = &sp0838_fops,
-	.ioctl_ops 	= &sp0838_ioctl_ops,
-	.release	= video_device_release,
+    .name       = "sp0838_v4l",
+    .fops           = &sp0838_fops,
+    .ioctl_ops  = &sp0838_ioctl_ops,
+    .release    = video_device_release,
 
-	.tvnorms              = V4L2_STD_525_60,
-	.current_norm         = V4L2_STD_NTSC_M,
+    .tvnorms              = V4L2_STD_525_60,
+    .current_norm         = V4L2_STD_NTSC_M,
 };
 
 static int sp0838_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
-	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SP0838, 0); 
-	//return v4l2_chip_ident_i2c_client(client, chip,  V4L2_IDENT_GT2005, 0); 
+    return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SP0838, 0);
+    //return v4l2_chip_ident_i2c_client(client, chip,  V4L2_IDENT_GT2005, 0);
 }
 
 static const struct v4l2_subdev_core_ops sp0838_core_ops = {
-	.g_chip_ident = sp0838_g_chip_ident,
+    .g_chip_ident = sp0838_g_chip_ident,
 };
 
 static const struct v4l2_subdev_ops sp0838_ops = {
-	.core = &sp0838_core_ops,
+    .core = &sp0838_core_ops,
 };
 
 static int sp0838_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
-{
-	aml_cam_info_t* plat_dat;
-	int err;
-	struct sp0838_device *t;
-	struct v4l2_subdev *sd;
-	vops = get_vdin_v4l2_ops();
-	v4l_info(client, "chip found @ 0x%x (%s)\n",
-			client->addr << 1, client->adapter->name);
-	t = kzalloc(sizeof(*t), GFP_KERNEL);
-	if (t == NULL)
-		return -ENOMEM;
-	sd = &t->sd;
-	v4l2_i2c_subdev_init(sd, client, &sp0838_ops);
-
-	plat_dat = (aml_cam_info_t*)client->dev.platform_data;
-	
-	/* Now create a video4linux device */
-	mutex_init(&t->mutex);
-
-	/* Now create a video4linux device */
-	t->vdev = video_device_alloc();
-	if (t->vdev == NULL) {
-		kfree(t);
-		kfree(client);
-		return -ENOMEM;
-	}
-	memcpy(t->vdev, &sp0838_template, sizeof(*t->vdev));
-
-	video_set_drvdata(t->vdev, t);
-
-	wake_lock_init(&(t->wake_lock),WAKE_LOCK_SUSPEND, "sp0838");
-	
-	/* Register it */
-	if (plat_dat) {
-		memcpy(&t->cam_info, plat_dat, sizeof(aml_cam_info_t));
-		if (plat_dat->front_back >=0)  
-			video_nr = plat_dat->front_back;
-	} else {
-		printk("camera sp0838: have no platform data\n");
-		kfree(t);
-		kfree(client);
-		return -1;
-	}
-	
-	t->cam_info.version = SP0838_DRIVER_VERSION;
-	if (aml_cam_info_reg(&t->cam_info) < 0)
-		printk("reg caminfo error\n");
-	
-	err = video_register_device(t->vdev, VFL_TYPE_GRABBER, video_nr);
-	if (err < 0) {
-		video_device_release(t->vdev);
-		kfree(t);
-		return err;
-	}
-
-
-
-	return 0;
+            const struct i2c_device_id *id)
+{
+    aml_cam_info_t* plat_dat;
+    int err;
+    struct sp0838_device *t;
+    struct v4l2_subdev *sd;
+
+    vops = get_vdin_v4l2_ops();
+    v4l_info(client, "chip found @ 0x%x (%s)\n",
+            client->addr << 1, client->adapter->name);
+    t = kzalloc(sizeof(*t), GFP_KERNEL);
+    if (t == NULL)
+        return -ENOMEM;
+    sd = &t->sd;
+    v4l2_i2c_subdev_init(sd, client, &sp0838_ops);
+
+    plat_dat = (aml_cam_info_t*)client->dev.platform_data;
+
+    memset(&t->vminfo,0,sizeof(vm_init_t));
+
+    /* Now create a video4linux device */
+    mutex_init(&t->mutex);
+
+    /* Now create a video4linux device */
+    t->vdev = video_device_alloc();
+    if (t->vdev == NULL) {
+        kfree(t);
+        kfree(client);
+        return -ENOMEM;
+    }
+    memcpy(t->vdev, &sp0838_template, sizeof(*t->vdev));
+
+    video_set_drvdata(t->vdev, t);
+
+    wake_lock_init(&(t->wake_lock),WAKE_LOCK_SUSPEND, "sp0838");
+
+    /* Register it */
+    if (plat_dat) {
+        memcpy(&t->cam_info, plat_dat, sizeof(aml_cam_info_t));
+        if (plat_dat->front_back >=0)
+            video_nr = plat_dat->front_back;
+    } else {
+        printk("camera sp0838: have no platform data\n");
+        kfree(t);
+        kfree(client);
+        return -1;
+    }
+
+    t->cam_info.version = SP0838_DRIVER_VERSION;
+    if (aml_cam_info_reg(&t->cam_info) < 0)
+        printk("reg caminfo error\n");
+
+    err = video_register_device(t->vdev, VFL_TYPE_GRABBER, video_nr);
+    if (err < 0) {
+        video_device_release(t->vdev);
+        kfree(t);
+        return err;
+    }
+
+
+
+    return 0;
 }
 
 static int sp0838_remove(struct i2c_client *client)
 {
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct sp0838_device *t = to_dev(sd);
-
-	video_unregister_device(t->vdev);
-	v4l2_device_unregister_subdev(sd);
-	wake_lock_destroy(&(t->wake_lock));
-	aml_cam_info_unreg(&t->cam_info);
-	kfree(t);
-	return 0;
+    struct v4l2_subdev *sd = i2c_get_clientdata(client);
+    struct sp0838_device *t = to_dev(sd);
+
+    video_unregister_device(t->vdev);
+    v4l2_device_unregister_subdev(sd);
+    wake_lock_destroy(&(t->wake_lock));
+    aml_cam_info_unreg(&t->cam_info);
+    kfree(t);
+    return 0;
 }
 
 static const struct i2c_device_id sp0838_id[] = {
-	{ "sp0838", 0 },
-	{ }
+    { "sp0838", 0 },
+    { }
 };
 MODULE_DEVICE_TABLE(i2c, sp0838_id);
 
 static struct i2c_driver sp0838_i2c_driver = {
-	.driver = {
-		.name = "sp0838",
-	},
-	.probe = sp0838_probe,
-	.remove = sp0838_remove,
-	.id_table = sp0838_id,
+    .driver = {
+        .name = "sp0838",
+    },
+    .probe = sp0838_probe,
+    .remove = sp0838_remove,
+    .id_table = sp0838_id,
 };
 
 module_i2c_driver(sp0838_i2c_driver);
diff --git a/drivers/amlogic/camera/sp2518.c b/drivers/amlogic/camera/sp2518.c
index a5e3063b658d..5c61dfafaea0 100755
--- a/drivers/amlogic/camera/sp2518.c
+++ b/drivers/amlogic/camera/sp2518.c
@@ -30,6 +30,7 @@
 #include <linux/highmem.h>
 #include <linux/freezer.h>
 #include <media/videobuf-res.h>
+#include <media/videobuf-vmalloc.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 #include <linux/wakelock.h>
@@ -58,8 +59,8 @@
 #define SP2518_CAMERA_MINOR_VERSION 7
 #define SP2518_CAMERA_RELEASE 0
 #define SP2518_CAMERA_VERSION \
-	KERNEL_VERSION(SP2518_CAMERA_MAJOR_VERSION, SP2518_CAMERA_MINOR_VERSION, SP2518_CAMERA_RELEASE)
-	
+    KERNEL_VERSION(SP2518_CAMERA_MAJOR_VERSION, SP2518_CAMERA_MINOR_VERSION, SP2518_CAMERA_RELEASE)
+
 #define SP2518_DRIVER_VERSION "SP2518-COMMON-01-140722"
 
 //unsigned short DGain_shutter,AGain_shutter,DGain_shutterH,DGain_shutterL,AGain_shutterH,AGain_shutterL,shutterH,shutterL,shutter;
@@ -67,16 +68,17 @@
 static struct i2c_client * g_i2c_client;
 static u32 cur_reg=0;
 static u8 cur_val;
+static u8 is_first_time_open = 0;
 
  typedef enum
 
 {
 
-	DCAMERA_FLICKER_50HZ = 0,
+    DCAMERA_FLICKER_50HZ = 0,
 
-	DCAMERA_FLICKER_60HZ,
+    DCAMERA_FLICKER_60HZ,
 
-	FLICKER_MAX
+    FLICKER_MAX
 
 }DCAMERA_FLICKER;
 static unsigned short Antiflicker = DCAMERA_FLICKER_50HZ;
@@ -106,97 +108,98 @@ static int sp2518_h_active=1568;//800;
 static int sp2518_v_active=1176;//600;
 
 static int sp2518_have_open=0;
+
 static struct v4l2_fract sp2518_frmintervals_active = {
     .numerator = 1,
     .denominator = 15,
 };
 
-static int sp2518_night_or_normal = 0;	//add by sp_yjp,20120905
+static int sp2518_night_or_normal = 0;  //add by sp_yjp,20120905
 static struct vdin_v4l2_ops_s *vops;
 /* supported controls */
 static struct v4l2_queryctrl sp2518_qctrl[] = {
-	{
-		.id            = V4L2_CID_DO_WHITE_BALANCE,
-		.type          = V4L2_CTRL_TYPE_MENU,
-		.name          = "white balance",
-		.minimum       = CAM_WB_AUTO,
-		.maximum       = CAM_WB_FLUORESCENT ,
-		.step          = 0x1,
-		.default_value = CAM_WB_AUTO,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_EXPOSURE,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "exposure",
-		.minimum       = 0,
-		.maximum       = 8,
-		.step          = 0x1,
-		.default_value = 4,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_COLORFX,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "effect",
-		.minimum       = 0,
-		.maximum       = 6,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_POWER_LINE_FREQUENCY,
-		.type          = V4L2_CTRL_TYPE_MENU,
-		.name          = "banding",
-		.minimum       = CAM_BANDING_50HZ,
-		.maximum       = CAM_BANDING_60HZ,
-		.step          = 0x1,
-		.default_value = CAM_BANDING_50HZ,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_BLUE_BALANCE,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "scene mode",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_HFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on horizontal",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_VFLIP,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "flip on vertical",
-		.minimum       = 0,
-		.maximum       = 1,
-		.step          = 0x1,
-		.default_value = 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id            = V4L2_CID_ZOOM_ABSOLUTE,
-		.type          = V4L2_CTRL_TYPE_INTEGER,
-		.name          = "Zoom, Absolute",
-		.minimum       = 100,
-		.maximum       = 300,
-		.step          = 20,
-		.default_value = 100,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	},{
-		.id		= V4L2_CID_ROTATE,
-		.type		= V4L2_CTRL_TYPE_INTEGER,
-		.name		= "Rotate",
-		.minimum	= 0,
-		.maximum	= 270,
-		.step		= 90,
-		.default_value	= 0,
-		.flags         = V4L2_CTRL_FLAG_SLIDER,
-	}
+    {
+        .id            = V4L2_CID_DO_WHITE_BALANCE,
+        .type          = V4L2_CTRL_TYPE_MENU,
+        .name          = "white balance",
+        .minimum       = CAM_WB_AUTO,
+        .maximum       = CAM_WB_FLUORESCENT ,
+        .step          = 0x1,
+        .default_value = CAM_WB_AUTO,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_EXPOSURE,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "exposure",
+        .minimum       = 0,
+        .maximum       = 8,
+        .step          = 0x1,
+        .default_value = 4,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_COLORFX,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "effect",
+        .minimum       = 0,
+        .maximum       = 6,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_POWER_LINE_FREQUENCY,
+        .type          = V4L2_CTRL_TYPE_MENU,
+        .name          = "banding",
+        .minimum       = CAM_BANDING_50HZ,
+        .maximum       = CAM_BANDING_60HZ,
+        .step          = 0x1,
+        .default_value = CAM_BANDING_50HZ,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_BLUE_BALANCE,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "scene mode",
+        .minimum       = 0,
+        .maximum       = 1,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_HFLIP,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "flip on horizontal",
+        .minimum       = 0,
+        .maximum       = 1,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_VFLIP,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "flip on vertical",
+        .minimum       = 0,
+        .maximum       = 1,
+        .step          = 0x1,
+        .default_value = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id            = V4L2_CID_ZOOM_ABSOLUTE,
+        .type          = V4L2_CTRL_TYPE_INTEGER,
+        .name          = "Zoom, Absolute",
+        .minimum       = 100,
+        .maximum       = 300,
+        .step          = 20,
+        .default_value = 100,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    },{
+        .id     = V4L2_CID_ROTATE,
+        .type       = V4L2_CTRL_TYPE_INTEGER,
+        .name       = "Rotate",
+        .minimum    = 0,
+        .maximum    = 270,
+        .step       = 90,
+        .default_value  = 0,
+        .flags         = V4L2_CTRL_FLAG_SLIDER,
+    }
 };
 struct v4l2_querymenu sp2518_qmenu_wbmode[] = {
     {
@@ -235,39 +238,39 @@ struct v4l2_querymenu sp2518_qmenu_wbmode[] = {
 struct v4l2_querymenu sp2518_qmenu_anti_banding_mode[] = {
     {
         .id         = V4L2_CID_POWER_LINE_FREQUENCY,
-        .index      = CAM_BANDING_50HZ, 
+        .index      = CAM_BANDING_50HZ,
         .name       = "50hz",
         .reserved   = 0,
     },{
         .id         = V4L2_CID_POWER_LINE_FREQUENCY,
-        .index      = CAM_BANDING_60HZ, 
+        .index      = CAM_BANDING_60HZ,
         .name       = "60hz",
         .reserved   = 0,
     },
 };
 static struct v4l2_frmivalenum sp2518_frmivalenum[]={
     {
-        .index 		= 0,
-        .pixel_format	= V4L2_PIX_FMT_NV21,
-        .width		= 640,
-        .height		= 480,
-        .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+        .index      = 0,
+        .pixel_format   = V4L2_PIX_FMT_NV21,
+        .width      = 640,
+        .height     = 480,
+        .type       = V4L2_FRMIVAL_TYPE_DISCRETE,
         {
-            .discrete	={
-                .numerator	= 1,
-                .denominator	= 15,
+            .discrete   ={
+                .numerator  = 1,
+                .denominator    = 15,
             }
         }
     },{
-        .index 		= 1,
-        .pixel_format	= V4L2_PIX_FMT_NV21,
-        .width		= 1600,
-        .height		= 1200,
-        .type		= V4L2_FRMIVAL_TYPE_DISCRETE,
+        .index      = 1,
+        .pixel_format   = V4L2_PIX_FMT_NV21,
+        .width      = 1600,
+        .height     = 1200,
+        .type       = V4L2_FRMIVAL_TYPE_DISCRETE,
         {
-            .discrete	={
-                .numerator	= 1,
-                .denominator	= 5,
+            .discrete   ={
+                .numerator  = 1,
+                .denominator    = 5,
             }
         }
     },
@@ -282,11 +285,11 @@ typedef struct {
 
 sp2518_qmenu_set_t sp2518_qmenu_set[] = {
     {
-        .id         	= V4L2_CID_DO_WHITE_BALANCE,
+        .id             = V4L2_CID_DO_WHITE_BALANCE,
         .num            = ARRAY_SIZE(sp2518_qmenu_wbmode),
         .sp2518_qmenu   = sp2518_qmenu_wbmode,
     },{
-        .id         	= V4L2_CID_POWER_LINE_FREQUENCY,
+        .id             = V4L2_CID_POWER_LINE_FREQUENCY,
         .num            = ARRAY_SIZE(sp2518_qmenu_anti_banding_mode),
         .sp2518_qmenu   = sp2518_qmenu_anti_banding_mode,
     },
@@ -295,177 +298,179 @@ sp2518_qmenu_set_t sp2518_qmenu_set[] = {
 static int vidioc_querymenu(struct file *file, void *priv,
                 struct v4l2_querymenu *a)
 {
-	int i, j;
+    int i, j;
 
-	for (i = 0; i < ARRAY_SIZE(sp2518_qmenu_set); i++)
-	if (a->id && a->id == sp2518_qmenu_set[i].id) {
-	    for(j = 0; j < sp2518_qmenu_set[i].num; j++)
-		if (a->index == sp2518_qmenu_set[i].sp2518_qmenu[j].index) {
-			memcpy(a, &( sp2518_qmenu_set[i].sp2518_qmenu[j]),
-				sizeof(*a));
-			return (0);
-		}
-	}
+    for (i = 0; i < ARRAY_SIZE(sp2518_qmenu_set); i++)
+    if (a->id && a->id == sp2518_qmenu_set[i].id) {
+        for (j = 0; j < sp2518_qmenu_set[i].num; j++)
+        if (a->index == sp2518_qmenu_set[i].sp2518_qmenu[j].index) {
+            memcpy(a, &( sp2518_qmenu_set[i].sp2518_qmenu[j]),
+                sizeof(*a));
+            return (0);
+        }
+    }
 
-	return -EINVAL;
+    return -EINVAL;
 }
 
 #define dprintk(dev, level, fmt, arg...) \
-	v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
+    v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
 
 /* ------------------------------------------------------------------
-	Basic structures
+    Basic structures
    ------------------------------------------------------------------*/
 
 struct sp2518_fmt {
-	char  *name;
-	u32   fourcc;          /* v4l2 format id */
-	int   depth;
+    char  *name;
+    u32   fourcc;          /* v4l2 format id */
+    int   depth;
 };
 
 static struct sp2518_fmt formats[] = {
-	{
-		.name     = "RGB565 (BE)",
-		.fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
-		.depth    = 16,
-	},{
-		.name     = "RGB888 (24)",
-		.fourcc   = V4L2_PIX_FMT_RGB24, /* 24  RGB-8-8-8 */
-		.depth    = 24,
-	},{
-		.name     = "BGR888 (24)",
-		.fourcc   = V4L2_PIX_FMT_BGR24, /* 24  BGR-8-8-8 */
-		.depth    = 24,
-	},{
-		.name     = "12  Y/CbCr 4:2:0",
-		.fourcc   = V4L2_PIX_FMT_NV12,
-		.depth    = 12,
-	},{
-		.name     = "12  Y/CbCr 4:2:0",
-		.fourcc   = V4L2_PIX_FMT_NV21,
-		.depth    = 12,
-	},{
-		.name     = "YUV420P",
-		.fourcc   = V4L2_PIX_FMT_YUV420,
-		.depth    = 12,
-	},{
-		.name     = "YVU420P",
-		.fourcc   = V4L2_PIX_FMT_YVU420,
-		.depth    = 12,
-	}
+    {
+        .name     = "RGB565 (BE)",
+        .fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
+        .depth    = 16,
+    },{
+        .name     = "RGB888 (24)",
+        .fourcc   = V4L2_PIX_FMT_RGB24, /* 24  RGB-8-8-8 */
+        .depth    = 24,
+    },{
+        .name     = "BGR888 (24)",
+        .fourcc   = V4L2_PIX_FMT_BGR24, /* 24  BGR-8-8-8 */
+        .depth    = 24,
+    },{
+        .name     = "12  Y/CbCr 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV12,
+        .depth    = 12,
+    },{
+        .name     = "12  Y/CbCr 4:2:0",
+        .fourcc   = V4L2_PIX_FMT_NV21,
+        .depth    = 12,
+    },{
+        .name     = "YUV420P",
+        .fourcc   = V4L2_PIX_FMT_YUV420,
+        .depth    = 12,
+    },{
+        .name     = "YVU420P",
+        .fourcc   = V4L2_PIX_FMT_YVU420,
+        .depth    = 12,
+    }
 };
 
 static struct sp2518_fmt *get_format(struct v4l2_format *f)
 {
-	struct sp2518_fmt *fmt;
-	unsigned int k;
+    struct sp2518_fmt *fmt;
+    unsigned int k;
 
-	for (k = 0; k < ARRAY_SIZE(formats); k++) {
-		fmt = &formats[k];
-		if (fmt->fourcc == f->fmt.pix.pixelformat)
-			break;
-	}
+    for (k = 0; k < ARRAY_SIZE(formats); k++) {
+        fmt = &formats[k];
+        if (fmt->fourcc == f->fmt.pix.pixelformat)
+            break;
+    }
 
-	if (k == ARRAY_SIZE(formats))
-		return NULL;
+    if (k == ARRAY_SIZE(formats))
+        return NULL;
 
-	return &formats[k];
+    return &formats[k];
 }
 
 struct sg_to_addr {
-	int pos;
-	struct scatterlist *sg;
+    int pos;
+    struct scatterlist *sg;
 };
 
 /* buffer for one video frame */
 struct sp2518_buffer {
-	/* common v4l buffer stuff -- must be first */
-	struct videobuf_buffer vb;
+    /* common v4l buffer stuff -- must be first */
+    struct videobuf_buffer vb;
+
+    struct sp2518_fmt        *fmt;
 
-	struct sp2518_fmt        *fmt;
-	
-	unsigned int canvas_id;
+    unsigned int canvas_id;
 };
 
 struct sp2518_dmaqueue {
-	struct list_head       active;
-
-	/* thread for generating video stream*/
-	struct task_struct         *kthread;
-	wait_queue_head_t          wq;
-	/* Counters to control fps rate */
-	int                        frame;
-	int                        ini_jiffies;
+    struct list_head       active;
+
+    /* thread for generating video stream*/
+    struct task_struct         *kthread;
+    wait_queue_head_t          wq;
+    /* Counters to control fps rate */
+    int                        frame;
+    int                        ini_jiffies;
 };
 
 static LIST_HEAD(sp2518_devicelist);
 
 struct sp2518_device {
-	struct list_head			sp2518_devicelist;
-	struct v4l2_subdev			sd;
-	struct v4l2_device			v4l2_dev;
+    struct list_head            sp2518_devicelist;
+    struct v4l2_subdev          sd;
+    struct v4l2_device          v4l2_dev;
 
-	spinlock_t                 slock;
-	struct mutex				mutex;
+    spinlock_t                 slock;
+    struct mutex                mutex;
 
-	int                        users;
+    int                        users;
 
-	/* various device info */
-	struct video_device        *vdev;
+    /* various device info */
+    struct video_device        *vdev;
 
-	struct sp2518_dmaqueue       vidq;
+    struct sp2518_dmaqueue       vidq;
 
-	/* Several counters */
-	unsigned long              jiffies;
+    /* Several counters */
+    unsigned long              jiffies;
 
-	/* Input Number */
-	int			   input;
+    /* Input Number */
+    int            input;
 
-	/* platform device data from board initting. */
-	aml_cam_info_t  cam_info;
+    /* platform device data from board initting. */
+    aml_cam_info_t  cam_info;
 
-	/* wake lock */
-	struct wake_lock	wake_lock;
-	/* Control 'registers' */
-	int 			   qctl_regs[ARRAY_SIZE(sp2518_qctrl)];
+    /* wake lock */
+    struct wake_lock    wake_lock;
+    /* Control 'registers' */
+    int                qctl_regs[ARRAY_SIZE(sp2518_qctrl)];
+    vm_init_t vminfo;
 };
 
 static inline struct sp2518_device *to_dev(struct v4l2_subdev *sd)
 {
-	return container_of(sd, struct sp2518_device, sd);
+    return container_of(sd, struct sp2518_device, sd);
 }
 
 struct sp2518_fh {
-	struct sp2518_device            *dev;
-
-	/* video capture */
-	struct sp2518_fmt            *fmt;
-	unsigned int               width, height;
-	struct videobuf_queue      vb_vidq;
-
-	struct videobuf_res_privdata res;
-	enum v4l2_buf_type         type;
-	int			   input; 	/* Input Number on bars */
-	int  stream_on;
-	unsigned int		f_flags;
+    struct sp2518_device            *dev;
+
+    /* video capture */
+    struct sp2518_fmt            *fmt;
+    unsigned int               width, height;
+    struct videobuf_queue      vb_vidq;
+
+    struct videobuf_res_privdata res;
+    enum v4l2_buf_type         type;
+    int            input;   /* Input Number on bars */
+    int  stream_on;
+    unsigned int        f_flags;
 };
 
 /*static inline struct sp2518_fh *to_fh(struct sp2518_device *dev)
 {
-	return container_of(dev, struct sp2518_fh, dev);
+    return container_of(dev, struct sp2518_fh, dev);
 }*/
 
 static struct v4l2_frmsize_discrete sp2518_prev_resolution[]= //should include 352x288 and 640x480, those two size are used for recording
 {
-	{320,240},
-	{352,288},
-	{640,480},
+    {176,144},
+    {320,240},
+    {352,288},
+    {640,480},
 };
 
 static struct v4l2_frmsize_discrete sp2518_pic_resolution[]=
 {
-	{1600,1200},
-	{800,600}
+    {1600,1200},
+    {800,600}
 };
 
 #ifndef SP2518_MIRROR
@@ -476,145 +481,145 @@ static struct v4l2_frmsize_discrete sp2518_pic_resolution[]=
 #endif
 
 /* ------------------------------------------------------------------
-	reg spec of SP2518
+    reg spec of SP2518
    ------------------------------------------------------------------*/
 
 struct aml_camera_i2c_fig_s SP2518_script[] = {
-	{0xfd,0x00},
-	{0x1b,0x02},//maximum drv ability
-	{0x0e,0x01},
-	{0x0f,0x2f},
-	{0x10,0x2e},
-	{0x11,0x00},
-	{0x12,0x4f},
-	{0x14,0x20},
-	{0x16,0x02},
-	{0x17,0x10},
-	{0x1a,0x1f},
-	{0x1e,0x81},
-	{0x21,0x00},
-	{0x22,0x1b},
-	{0x25,0x10},
-	{0x26,0x25},
-	{0x27,0x6d},
-	{0x2c,0x31},//Ronlus remove balck dot0x45},
-	{0x2d,0x75},
-	{0x2e,0x38},//sxga 0x18
-	{0x31,0x00},//mirror upside down
-	{0x44,0x03},
-	{0x6f,0x00},
-	{0xa0,0x04},
-	{0x5f,0x01},
-	{0x32,0x00},
-	{0xfd,0x01},
-	{0x2c,0x00},
-	{0x2d,0x00},
-	{0xfd,0x00},
-	{0xfb,0x83},
-	{0xf4,0x09},
-	//Pregain
-	{0xfd,0x01},
-	{0xc6,0x90},
-	{0xc7,0x90},
-	{0xc8,0x90},
-	{0xc9,0x90},
-	//blacklevel
-	{0xfd,0x00},
-	{0x65,0x08},
-	{0x66,0x08},
-	{0x67,0x08},
-	{0x68,0x08},
-	//rpc
-	{0xfd,0x00},
-	{0xe0,0x6c},
-	{0xe1,0x54},
-	{0xe2,0x48},
-	{0xe3,0x40},
-	{0xe4,0x40},
-	{0xe5,0x3e},
-	{0xe6,0x3e},
-	{0xe8,0x3a},
-	{0xe9,0x3a},
-	{0xea,0x3a},
-	{0xeb,0x38},
-	{0xf5,0x38},
-	{0xf6,0x38},
-	{0xfd,0x01},
-	{0x94,0xc0},//f8
-	{0x95,0x38},
-	{0x9c,0x6c},
-	{0x9d,0x38},	
-	#if defined(EM668_V1)
-	///SI50_SP2518 UXGA 24MEclk 2PLL 1DIV 50Hz fix 9fps
-	///ae setting
-	{0xfd , 0x00},
-	{0x03 , 0x02},
-	{0x04 , 0xb8},
-	{0x05 , 0x00},
-	{0x06 , 0x00},
-	{0x07 , 0x00},
-	{0x08 , 0x00},
-	{0x09 , 0x00},
-	{0x0a , 0x6c},
-	{0x2f , 0x00},
-	{0x30 , 0x04},
-	{0xf0 , 0x74},
-	{0xf1 , 0x00},
-	{0xfd , 0x01},
-	{0x90 , 0x0b},
-	{0x92 , 0x01},
-	{0x98 , 0x74},
-	{0x99 , 0x00},
-	{0x9a , 0x01},
-	{0x9b , 0x00},
-	///Status
-	{0xfd , 0x01},
-	{0xce , 0xfc},
-	{0xcf , 0x04},
-	{0xd0 , 0xfc},
-	{0xd1 , 0x04},
-	{0xd7 , 0x70},
-	{0xd8 , 0x00},
-	{0xd9 , 0x74},
-	{0xda , 0x00},
-	{0xfd , 0x00},
-	#else
-	///SI50_SP2518 UXGA 24MEclk 3PLL 1DIV 50Hz 10-13fps
-	///ae setting
-	/*
-	{0xfd,0x00},
-	{0x03,0x03},
-	{0x04,0xf6},
-	{0x05,0x00},
-	{0x06,0x00},
-	{0x07,0x00},
-	{0x08,0x00},
-	{0x09,0x00},
-	{0x0a,0x8b},
-	{0x2f,0x00},
-	{0x30,0x08},
-	{0xf0,0xa9},
-	{0xf1,0x00},
-	{0xfd,0x01},
-	{0x90,0x0a},
-	{0x92,0x01},
-	{0x98,0xa9},
-	{0x99,0x00},
-	{0x9a,0x01},
-	{0x9b,0x00},
-	///Status 
-	{0xfd,0x01},
-	{0xce,0x9a},
-	{0xcf,0x06},
-	{0xd0,0x9a},
-	{0xd1,0x06},
-	{0xd7,0xa5},
-	{0xd8,0x00},
-	{0xd9,0xa9},
-	{0xda,0x00},
-	{0xfd,0x00},
-	*/
-//ae setting 13-12fps	
+    {0xfd,0x00},
+    {0x1b,0x02},//maximum drv ability
+    {0x0e,0x01},
+    {0x0f,0x2f},
+    {0x10,0x2e},
+    {0x11,0x00},
+    {0x12,0x4f},
+    {0x14,0x20},
+    {0x16,0x02},
+    {0x17,0x10},
+    {0x1a,0x1f},
+    {0x1e,0x81},
+    {0x21,0x00},
+    {0x22,0x1b},
+    {0x25,0x10},
+    {0x26,0x25},
+    {0x27,0x6d},
+    {0x2c,0x31},//Ronlus remove balck dot0x45},
+    {0x2d,0x75},
+    {0x2e,0x38},//sxga 0x18
+    {0x31,0x00},//mirror upside down
+    {0x44,0x03},
+    {0x6f,0x00},
+    {0xa0,0x04},
+    {0x5f,0x01},
+    {0x32,0x00},
+    {0xfd,0x01},
+    {0x2c,0x00},
+    {0x2d,0x00},
+    {0xfd,0x00},
+    {0xfb,0x83},
+    {0xf4,0x09},
+    //Pregain
+    {0xfd,0x01},
+    {0xc6,0x90},
+    {0xc7,0x90},
+    {0xc8,0x90},
+    {0xc9,0x90},
+    //blacklevel
+    {0xfd,0x00},
+    {0x65,0x08},
+    {0x66,0x08},
+    {0x67,0x08},
+    {0x68,0x08},
+    //rpc
+    {0xfd,0x00},
+    {0xe0,0x6c},
+    {0xe1,0x54},
+    {0xe2,0x48},
+    {0xe3,0x40},
+    {0xe4,0x40},
+    {0xe5,0x3e},
+    {0xe6,0x3e},
+    {0xe8,0x3a},
+    {0xe9,0x3a},
+    {0xea,0x3a},
+    {0xeb,0x38},
+    {0xf5,0x38},
+    {0xf6,0x38},
+    {0xfd,0x01},
+    {0x94,0xc0},//f8
+    {0x95,0x38},
+    {0x9c,0x6c},
+    {0x9d,0x38},
+    #if defined(EM668_V1)
+    ///SI50_SP2518 UXGA 24MEclk 2PLL 1DIV 50Hz fix 9fps
+    ///ae setting
+    {0xfd , 0x00},
+    {0x03 , 0x02},
+    {0x04 , 0xb8},
+    {0x05 , 0x00},
+    {0x06 , 0x00},
+    {0x07 , 0x00},
+    {0x08 , 0x00},
+    {0x09 , 0x00},
+    {0x0a , 0x6c},
+    {0x2f , 0x00},
+    {0x30 , 0x04},
+    {0xf0 , 0x74},
+    {0xf1 , 0x00},
+    {0xfd , 0x01},
+    {0x90 , 0x0b},
+    {0x92 , 0x01},
+    {0x98 , 0x74},
+    {0x99 , 0x00},
+    {0x9a , 0x01},
+    {0x9b , 0x00},
+    ///Status
+    {0xfd , 0x01},
+    {0xce , 0xfc},
+    {0xcf , 0x04},
+    {0xd0 , 0xfc},
+    {0xd1 , 0x04},
+    {0xd7 , 0x70},
+    {0xd8 , 0x00},
+    {0xd9 , 0x74},
+    {0xda , 0x00},
+    {0xfd , 0x00},
+    #else
+    ///SI50_SP2518 UXGA 24MEclk 3PLL 1DIV 50Hz 10-13fps
+    ///ae setting
+    /*
+    {0xfd,0x00},
+    {0x03,0x03},
+    {0x04,0xf6},
+    {0x05,0x00},
+    {0x06,0x00},
+    {0x07,0x00},
+    {0x08,0x00},
+    {0x09,0x00},
+    {0x0a,0x8b},
+    {0x2f,0x00},
+    {0x30,0x08},
+    {0xf0,0xa9},
+    {0xf1,0x00},
+    {0xfd,0x01},
+    {0x90,0x0a},
+    {0x92,0x01},
+    {0x98,0xa9},
+    {0x99,0x00},
+    {0x9a,0x01},
+    {0x9b,0x00},
+    ///Status
+    {0xfd,0x01},
+    {0xce,0x9a},
+    {0xcf,0x06},
+    {0xd0,0x9a},
+    {0xd1,0x06},
+    {0xd7,0xa5},
+    {0xd8,0x00},
+    {0xd9,0xa9},
+    {0xda,0x00},
+    {0xfd,0x00},
+    */
+//ae setting 13-12fps
 {0xfd,0x00},
 {0x03,0x03},
 {0x04,0xf6},
@@ -647,305 +652,305 @@ struct aml_camera_i2c_fig_s SP2518_script[] = {
 {0xda,0x00},
 {0xfd,0x00},
 
-	#endif
-	
-	{0xfd,0x01},
-	{0xca,0x30},//mean dummy2low
-	{0xcb,0x50},//mean low2dummy
-	{0xcc,0xc0},//f8;rpc low
-	{0xcd,0xc0},//rpc dummy
-	{0xd5,0x80},//mean normal2dummy
-	{0xd6,0x90},//mean dummy2normal
-	{0xfd,0x00},  
-	//lens shading for 979C-171A\181A
-	{0xfd,0x00},
-	{0xa1,0x20},
-	{0xa2,0x20},
-	{0xa3,0x20},
-	{0xa4,0xff},
-	{0xa5,0x80},
-	{0xa6,0x80},
-	{0xfd,0x01},
-	{0x64,0x22},//28
-	{0x65,0x1e},//25
-	{0x66,0x1e},//2a
-	{0x67,0x1a},//25
-	{0x68,0x1c},//25
-	{0x69,0x1c},//29
-	{0x6a,0x1a},//28
-	{0x6b,0x16},//20
-	{0x6c,0x1a},//22
-	{0x6d,0x1a},//22
-	{0x6e,0x1a},//22
-	{0x6f,0x16},//1c
-	{0xb8,0x04},//0a
-	{0xb9,0x13},//0a
-	{0xba,0x00},//23
-	{0xbb,0x03},//14
-	{0xbc,0x03},//08
-	{0xbd,0x11},//08
-	{0xbe,0x00},//12
-	{0xbf,0x02},//00
-	{0xc0,0x04},//05
-	{0xc1,0x0e},//05
-	{0xc2,0x00},//18
-	{0xc3,0x05},//08   
-	//raw filter
-	{0xfd,0x01},
-	{0xde,0x0f},
-	{0xfd,0x00},
-	{0x57,0x08},//raw_dif_thr
-	{0x58,0x08},//a
-	{0x56,0x08},//a
-	{0x59,0x10},
-	//R\B
-	{0x5a,0xa0},//raw_rb_fac_outdoor
-	{0xc4,0xa0},//60raw_rb_fac_indoor
-	{0x43,0xa0},//40raw_rb_fac_dummy  
-	{0xad,0x40},//raw_rb_fac_low  
-	//GrGb 
-	{0x4f,0xa0},//raw_gf_fac_outdoor
-	{0xc3,0xa0},//60raw_gf_fac_indoor
-	{0x3f,0xa0},//40raw_gf_fac_dummy
-	{0x42,0x40},//raw_gf_fac_low
-	{0xc2,0x15},
-	//GrGb
-	{0xb6,0x80},//raw_gflt_fac_outdoor
-	{0xb7,0x80},//60raw_gflt_fac_normal
-	{0xb8,0x40},//40raw_gflt_fac_dummy
-	{0xb9,0x20},//raw_gflt_fac_low
-	//GrGb
-	{0xfd,0x01},
-	{0x50,0x0c},//raw_grgb_thr
-	{0x51,0x0c},
-	{0x52,0x10},
-	{0x53,0x10},
-	{0xfd,0x00},	
-	// awb1
-	{0xfd,0x01},
-	{0x11,0x10},
-	{0x12,0x1f},
-	{0x16,0x1c},
-	{0x18,0x00},
-	{0x19,0x00},
-	{0x1b,0x96},
-	{0x1a,0x9a},//95
-	{0x1e,0x2f},
-	{0x1f,0x29},
-	{0x20,0xff},
-	{0x22,0xff},  
-	{0x28,0xce},
-	{0x29,0x8a},
-	{0xfd,0x00},
-	{0xe7,0x03},
-	{0xe7,0x00},
-	{0xfd,0x01},
-	{0x2a,0xf0},
-	{0x2b,0x10},
-	{0x2e,0x04},
-	{0x2f,0x18},
-	{0x21,0x60},
-	{0x23,0x60},
-	{0x8b,0xab},
-	{0x8f,0x12},
-	//awb2
-	{0xfd,0x01},
-	{0x1a,0x80},
-	{0x1b,0x80},
-	{0x43,0x80},
-	//d65
-	{0x35,0xd6},//d6;b0
-	{0x36,0xf0},//f0;d1;e9
-	{0x37,0x7a},//8a;70
-	{0x38,0x9a},//dc;9a;af
-	//indoor
-	{0x39,0xab},
-	{0x3a,0xca},
-	{0x3b,0xa3},
-	{0x3c,0xc1},
-	//f
-	{0x31,0x82},//7d
-	{0x32,0xa5},//a0;74
-	{0x33,0xd6},//d2
-	{0x34,0xec},//e8
-	{0x3d,0xa5},//a7;88
-	{0x3e,0xc2},//be;bb
-	{0x3f,0xa7},//b3;ad
-	{0x40,0xc5},//c5;d0
-	//Color Correction				  
-	{0xfd,0x01},
-	{0x1c,0xc0},
-	{0x1d,0x95},
-	{0xa0,0xa6},//b8 
-	{0xa1,0xda},//;d5
-	{0xa2,0x00},//;f2
-	{0xa3,0x06},//;e8
-	{0xa4,0xb2},//;95
-	{0xa5,0xc7},//;03
-	{0xa6,0x00},//;f2
-	{0xa7,0xce},//;c4
-	{0xa8,0xb2},//;ca
-	{0xa9,0x0c},//;3c
-	{0xaa,0x30},//;03
-	{0xab,0x0c},//;0f
-	{0xac,0xc0},//b8 
-	{0xad,0xc0},//d5
-	{0xae,0x00},//f2
-	{0xaf,0xf2},//e8
-	{0xb0,0xa6},//95
-	{0xb1,0xe8},//03
-	{0xb2,0x00},//f2
-	{0xb3,0xe7},//c4
-	{0xb4,0x99},//ca
-	{0xb5,0x0c},//3c
-	{0xb6,0x33},//03
-	{0xb7,0x0c},//0f
-	//Saturation
-	{0xfd,0x00},
-	{0xbf,0x01},
-	{0xbe,0xbb},
-	{0xc0,0xb0},
-	{0xc1,0xf0},
-	{0xd3,0x77},
-	{0xd4,0x77},
-	{0xd6,0x77},
-	{0xd7,0x77},
-	{0xd8,0x77},
-	{0xd9,0x77},
-	{0xda,0x77},
-	{0xdb,0x77},
-	//uv_dif
-	{0xfd,0x00},
-	{0xf3,0x03},
-	{0xb0,0x00},
-	{0xb1,0x23},
-	//gamma1
-	{0xfd,0x00},//
-	{0x8b,0x0 },//0 ;0	
-	{0x8c,0xA },//14;A 
-	{0x8d,0x13},//24;13
-	{0x8e,0x25},//3a;25
-	{0x8f,0x43},//59;43
-	{0x90,0x5D},//6f;5D
-	{0x91,0x74},//84;74
-	{0x92,0x88},//95;88
-	{0x93,0x9A},//a3;9A
-	{0x94,0xA9},//b1;A9
-	{0x95,0xB5},//be;B5
-	{0x96,0xC0},//c7;C0
-	{0x97,0xCA},//d1;CA
-	{0x98,0xD4},//d9;D4
-	{0x99,0xDD},//e1;DD
-	{0x9a,0xE6},//e9;E6
-	{0x9b,0xEF},//f1;EF
-	{0xfd,0x01},//01;01
-	{0x8d,0xF7},//f9;F7
-	{0x8e,0xFF},//ff;FF
-	//gamma2   
-	{0xfd,0x00},//
-	{0x78,0x0 },//0   
-	{0x79,0xA },//14
-	{0x7a,0x13},//24
-	{0x7b,0x25},//3a
-	{0x7c,0x43},//59
-	{0x7d,0x5D},//6f
-	{0x7e,0x74},//84
-	{0x7f,0x88},//95
-	{0x80,0x9A},//a3
-	{0x81,0xA9},//b1
-	{0x82,0xB5},//be
-	{0x83,0xC0},//c7
-	{0x84,0xCA},//d1
-	{0x85,0xD4},//d9
-	{0x86,0xDD},//e1
-	{0x87,0xE6},//e9
-	{0x88,0xEF},//f1
-	{0x89,0xF7},//f9
-	{0x8a,0xFF},//ff
-	//gamma_ae  
-	{0xfd,0x01},
-	{0x96,0x46},
-	{0x97,0x14},
-	{0x9f,0x06},
-	//HEQ
-	{0xfd,0x00},//
-	{0xdd,0x80},//
-	{0xde,0x88},//a0 0x95//
-	{0xdf,0x80},//
-	//Ytarget 
-	{0xfd,0x00},// 
-	{0xec,0x70},//6a
-	{0xed,0x86},//7c
-	{0xee,0x70},//65
-	{0xef,0x86},//78
-	{0xf7,0x80},//78
-	{0xf8,0x74},//6e
-	{0xf9,0x80},//74
-	{0xfa,0x74},//6a 
-	//sharpen
-	{0xfd,0x01},
-	{0xdf,0x0f},
-	{0xe5,0x10},
-	{0xe7,0x10},
-	{0xe8,0x20},
-	{0xec,0x20},
-	{0xe9,0x20},
-	{0xed,0x20},
-	{0xea,0x10},
-	{0xef,0x10},
-	{0xeb,0x10},
-	{0xf0,0x10},
-	//;gw
-	{0xfd,0x01},//
-	{0x70,0x76},//
-	{0x7b,0x40},//
-	{0x81,0x30},//
-	//;Y_offset
-	{0xfd,0x00},
-	{0xb2,0x1f},
-	{0xb3,0x0f},
-	{0xb4,0x30},
-	{0xb5,0x50},
-	//;CNR
-	{0xfd,0x00},
-	{0x5b,0x20},
-	{0x61,0x80},
-	{0x77,0x80},
-	{0xca,0x80},
-	//;YNR  
-	{0xab,0x00},
-	{0xac,0x02},
-	{0xae,0x08},
-	{0xaf,0x20},
-	{0xfd,0x00},
-	{0x31, 0x10 | (SP2518_FLIP<<6) | (SP2518_MIRROR<<5)},
-	{0x32,0x0d},
-	{0x33,0xcf},//ef
-	{0x34,0x3f},
-	{0x35,0x41},//0xc0
-	{0x1b,0x1a},//02
-#if 0	
-	//set selution 640*480
-	{0xfd , 0x00},
-	{0x4b , 0x00},
-	{0x4c , 0x00},
-	{0x47 , 0x00},
-	{0x48 , 0x00},
-	{0xfd , 0x01},
-	{0x06 , 0x00},
-	{0x07 , 0x40},
-	{0x08 , 0x00},
-	{0x09 , 0x40},
-	{0x0a , 0x02},
-	{0x0b , 0x58},
-	{0x0c , 0x03},
-	{0x0d , 0x20},
-	{0x0e , 0x01},
-	{0xfd , 0x00},
-#endif	
-	{0xe7,0x03},
-	{0xe7,0x00},
-	{0xff,0xff},
+    #endif
+
+    {0xfd,0x01},
+    {0xca,0x30},//mean dummy2low
+    {0xcb,0x50},//mean low2dummy
+    {0xcc,0xc0},//f8;rpc low
+    {0xcd,0xc0},//rpc dummy
+    {0xd5,0x80},//mean normal2dummy
+    {0xd6,0x90},//mean dummy2normal
+    {0xfd,0x00},
+    //lens shading for 979C-171A\181A
+    {0xfd,0x00},
+    {0xa1,0x20},
+    {0xa2,0x20},
+    {0xa3,0x20},
+    {0xa4,0xff},
+    {0xa5,0x80},
+    {0xa6,0x80},
+    {0xfd,0x01},
+    {0x64,0x22},//28
+    {0x65,0x1e},//25
+    {0x66,0x1e},//2a
+    {0x67,0x1a},//25
+    {0x68,0x1c},//25
+    {0x69,0x1c},//29
+    {0x6a,0x1a},//28
+    {0x6b,0x16},//20
+    {0x6c,0x1a},//22
+    {0x6d,0x1a},//22
+    {0x6e,0x1a},//22
+    {0x6f,0x16},//1c
+    {0xb8,0x04},//0a
+    {0xb9,0x13},//0a
+    {0xba,0x00},//23
+    {0xbb,0x03},//14
+    {0xbc,0x03},//08
+    {0xbd,0x11},//08
+    {0xbe,0x00},//12
+    {0xbf,0x02},//00
+    {0xc0,0x04},//05
+    {0xc1,0x0e},//05
+    {0xc2,0x00},//18
+    {0xc3,0x05},//08
+    //raw filter
+    {0xfd,0x01},
+    {0xde,0x0f},
+    {0xfd,0x00},
+    {0x57,0x08},//raw_dif_thr
+    {0x58,0x08},//a
+    {0x56,0x08},//a
+    {0x59,0x10},
+    //R\B
+    {0x5a,0xa0},//raw_rb_fac_outdoor
+    {0xc4,0xa0},//60raw_rb_fac_indoor
+    {0x43,0xa0},//40raw_rb_fac_dummy
+    {0xad,0x40},//raw_rb_fac_low
+    //GrGb 
+    {0x4f,0xa0},//raw_gf_fac_outdoor
+    {0xc3,0xa0},//60raw_gf_fac_indoor
+    {0x3f,0xa0},//40raw_gf_fac_dummy
+    {0x42,0x40},//raw_gf_fac_low
+    {0xc2,0x15},
+    //GrGb
+    {0xb6,0x80},//raw_gflt_fac_outdoor
+    {0xb7,0x80},//60raw_gflt_fac_normal
+    {0xb8,0x40},//40raw_gflt_fac_dummy
+    {0xb9,0x20},//raw_gflt_fac_low
+    //GrGb
+    {0xfd,0x01},
+    {0x50,0x0c},//raw_grgb_thr
+    {0x51,0x0c},
+    {0x52,0x10},
+    {0x53,0x10},
+    {0xfd,0x00},
+    // awb1
+    {0xfd,0x01},
+    {0x11,0x10},
+    {0x12,0x1f},
+    {0x16,0x1c},
+    {0x18,0x00},
+    {0x19,0x00},
+    {0x1b,0x96},
+    {0x1a,0x9a},//95
+    {0x1e,0x2f},
+    {0x1f,0x29},
+    {0x20,0xff},
+    {0x22,0xff},
+    {0x28,0xce},
+    {0x29,0x8a},
+    {0xfd,0x00},
+    {0xe7,0x03},
+    {0xe7,0x00},
+    {0xfd,0x01},
+    {0x2a,0xf0},
+    {0x2b,0x10},
+    {0x2e,0x04},
+    {0x2f,0x18},
+    {0x21,0x60},
+    {0x23,0x60},
+    {0x8b,0xab},
+    {0x8f,0x12},
+    //awb2
+    {0xfd,0x01},
+    {0x1a,0x80},
+    {0x1b,0x80},
+    {0x43,0x80},
+    //d65
+    {0x35,0xd6},//d6;b0
+    {0x36,0xf0},//f0;d1;e9
+    {0x37,0x7a},//8a;70
+    {0x38,0x9a},//dc;9a;af
+    //indoor
+    {0x39,0xab},
+    {0x3a,0xca},
+    {0x3b,0xa3},
+    {0x3c,0xc1},
+    //f
+    {0x31,0x82},//7d
+    {0x32,0xa5},//a0;74
+    {0x33,0xd6},//d2
+    {0x34,0xec},//e8
+    {0x3d,0xa5},//a7;88
+    {0x3e,0xc2},//be;bb
+    {0x3f,0xa7},//b3;ad
+    {0x40,0xc5},//c5;d0
+    //Color Correction
+    {0xfd,0x01},
+    {0x1c,0xc0},
+    {0x1d,0x95},
+    {0xa0,0xa6},//b8
+    {0xa1,0xda},//;d5
+    {0xa2,0x00},//;f2
+    {0xa3,0x06},//;e8
+    {0xa4,0xb2},//;95
+    {0xa5,0xc7},//;03
+    {0xa6,0x00},//;f2
+    {0xa7,0xce},//;c4
+    {0xa8,0xb2},//;ca
+    {0xa9,0x0c},//;3c
+    {0xaa,0x30},//;03
+    {0xab,0x0c},//;0f
+    {0xac,0xc0},//b8
+    {0xad,0xc0},//d5
+    {0xae,0x00},//f2
+    {0xaf,0xf2},//e8
+    {0xb0,0xa6},//95
+    {0xb1,0xe8},//03
+    {0xb2,0x00},//f2
+    {0xb3,0xe7},//c4
+    {0xb4,0x99},//ca
+    {0xb5,0x0c},//3c
+    {0xb6,0x33},//03
+    {0xb7,0x0c},//0f
+    //Saturation
+    {0xfd,0x00},
+    {0xbf,0x01},
+    {0xbe,0xbb},
+    {0xc0,0xb0},
+    {0xc1,0xf0},
+    {0xd3,0x77},
+    {0xd4,0x77},
+    {0xd6,0x77},
+    {0xd7,0x77},
+    {0xd8,0x77},
+    {0xd9,0x77},
+    {0xda,0x77},
+    {0xdb,0x77},
+    //uv_dif
+    {0xfd,0x00},
+    {0xf3,0x03},
+    {0xb0,0x00},
+    {0xb1,0x23},
+    //gamma1
+    {0xfd,0x00},//
+    {0x8b,0x0 },//0 ;0
+    {0x8c,0xA },//14;A
+    {0x8d,0x13},//24;13
+    {0x8e,0x25},//3a;25
+    {0x8f,0x43},//59;43
+    {0x90,0x5D},//6f;5D
+    {0x91,0x74},//84;74
+    {0x92,0x88},//95;88
+    {0x93,0x9A},//a3;9A
+    {0x94,0xA9},//b1;A9
+    {0x95,0xB5},//be;B5
+    {0x96,0xC0},//c7;C0
+    {0x97,0xCA},//d1;CA
+    {0x98,0xD4},//d9;D4
+    {0x99,0xDD},//e1;DD
+    {0x9a,0xE6},//e9;E6
+    {0x9b,0xEF},//f1;EF
+    {0xfd,0x01},//01;01
+    {0x8d,0xF7},//f9;F7
+    {0x8e,0xFF},//ff;FF
+    //gamma2
+    {0xfd,0x00},//
+    {0x78,0x0 },//0
+    {0x79,0xA },//14
+    {0x7a,0x13},//24
+    {0x7b,0x25},//3a
+    {0x7c,0x43},//59
+    {0x7d,0x5D},//6f
+    {0x7e,0x74},//84
+    {0x7f,0x88},//95
+    {0x80,0x9A},//a3
+    {0x81,0xA9},//b1
+    {0x82,0xB5},//be
+    {0x83,0xC0},//c7
+    {0x84,0xCA},//d1
+    {0x85,0xD4},//d9
+    {0x86,0xDD},//e1
+    {0x87,0xE6},//e9
+    {0x88,0xEF},//f1
+    {0x89,0xF7},//f9
+    {0x8a,0xFF},//ff
+    //gamma_ae
+    {0xfd,0x01},
+    {0x96,0x46},
+    {0x97,0x14},
+    {0x9f,0x06},
+    //HEQ
+    {0xfd,0x00},//
+    {0xdd,0x80},//
+    {0xde,0x88},//a0 0x95//
+    {0xdf,0x80},//
+    //Ytarget
+    {0xfd,0x00},//
+    {0xec,0x70},//6a
+    {0xed,0x86},//7c
+    {0xee,0x70},//65
+    {0xef,0x86},//78
+    {0xf7,0x80},//78
+    {0xf8,0x74},//6e
+    {0xf9,0x80},//74
+    {0xfa,0x74},//6a
+    //sharpen
+    {0xfd,0x01},
+    {0xdf,0x0f},
+    {0xe5,0x10},
+    {0xe7,0x10},
+    {0xe8,0x20},
+    {0xec,0x20},
+    {0xe9,0x20},
+    {0xed,0x20},
+    {0xea,0x10},
+    {0xef,0x10},
+    {0xeb,0x10},
+    {0xf0,0x10},
+    //;gw
+    {0xfd,0x01},//
+    {0x70,0x76},//
+    {0x7b,0x40},//
+    {0x81,0x30},//
+    //;Y_offset
+    {0xfd,0x00},
+    {0xb2,0x1f},
+    {0xb3,0x0f},
+    {0xb4,0x30},
+    {0xb5,0x50},
+    //;CNR
+    {0xfd,0x00},
+    {0x5b,0x20},
+    {0x61,0x80},
+    {0x77,0x80},
+    {0xca,0x80},
+    //;YNR
+    {0xab,0x00},
+    {0xac,0x02},
+    {0xae,0x08},
+    {0xaf,0x20},
+    {0xfd,0x00},
+    {0x31, 0x10 | (SP2518_FLIP<<6) | (SP2518_MIRROR<<5)},
+    {0x32,0x0d},
+    {0x33,0xcf},//ef
+    {0x34,0x3f},
+    {0x35,0x41},//0xc0
+    {0x1b,0x1a},//02
+#if 0
+    //set selution 640*480
+    {0xfd , 0x00},
+    {0x4b , 0x00},
+    {0x4c , 0x00},
+    {0x47 , 0x00},
+    {0x48 , 0x00},
+    {0xfd , 0x01},
+    {0x06 , 0x00},
+    {0x07 , 0x40},
+    {0x08 , 0x00},
+    {0x09 , 0x40},
+    {0x0a , 0x02},
+    {0x0b , 0x58},
+    {0x0c , 0x03},
+    {0x0d , 0x20},
+    {0x0e , 0x01},
+    {0xfd , 0x00},
+#endif
+    {0xe7,0x03},
+    {0xe7,0x00},
+    {0xff,0xff},
 };
 
 //load SP2518 parameters
@@ -954,39 +959,42 @@ void SP2518_init_regs(struct sp2518_device *dev)
    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
     int i=0;
 
+    if (!dev->vminfo.isused)
+        return;
+
     while(1)
     {
-        if (SP2518_script[i].val==0xff&&SP2518_script[i].addr==0xff)
+        if (SP2518_script[i].val == 0xff && SP2518_script[i].addr == 0xff)
         {
-        	printk("SP2518_write_regs success in initial SP2518.\n");
-        	break;
+            printk("SP2518_write_regs success in initial SP2518.\n");
+            break;
         }
-        if((i2c_put_byte_add8_new(client,SP2518_script[i].addr, SP2518_script[i].val)) < 0)
+        if ((i2c_put_byte_add8_new(client,SP2518_script[i].addr, SP2518_script[i].val)) < 0)
         {
-        	printk("fail in initial SP2518. \n");
-		return;
-		}
-		i++;
+            printk("fail in initial SP2518. \n");
+            return;
+        }
+        i++;
     }
-	/*
+    /*
     aml_plat_cam_data_t* plat_dat= (aml_plat_cam_data_t*)client->dev.platform_data;
-    if (plat_dat&&plat_dat->custom_init_script) {
-		i=0;
-		aml_camera_i2c_fig_t*  custom_script = (aml_camera_i2c_fig_t*)plat_dat->custom_init_script;
-		while(1)
-		{
-			if (custom_script[i].val==0xff&&custom_script[i].addr==0xff)
-			{
-				printk("SP2518_write_custom_regs success in initial SP2518.\n");
-				break;
-			}
-			if((i2c_put_byte_add8_new(client,custom_script[i].addr, custom_script[i].val)) < 0)
-			{
-				printk("fail in initial SP2518 custom_regs. \n");
-				return;
-			}
-			i++;
-		}
+    if  (plat_dat && plat_dat->custom_init_script)  {
+        i=0;
+        aml_camera_i2c_fig_t*  custom_script = (aml_camera_i2c_fig_t*)plat_dat->custom_init_script;
+        while (1)
+        {
+            if  (custom_script[i].val == 0xff && custom_script[i].addr == 0xff)
+            {
+                printk("SP2518_write_custom_regs success in initial SP2518.\n");
+                break;
+            }
+            if  ((i2c_put_byte_add8_new(client,custom_script[i].addr, custom_script[i].val)) < 0)
+            {
+                printk("fail in initial SP2518 custom_regs. \n");
+                return;
+            }
+            i++;
+        }
     }
     */
     return;
@@ -1009,65 +1017,68 @@ void SP2518_init_regs(struct sp2518_device *dev)
 *************************************************************************/
 void SP2518_set_param_wb(struct sp2518_device *dev,enum  camera_wb_flip_e para)//white balance
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-
-	switch (para)
-	{
-
-		case CAM_WB_AUTO://auto
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0x28,0xce);
-			i2c_put_byte_add8_new(client,0x29,0x8a);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x32,0x0d);
-			break;
-
-		case CAM_WB_CLOUD: //cloud
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0x28,0xe2);
-			i2c_put_byte_add8_new(client,0x29,0x82);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x32,0x05);
-			break;
-
-		case CAM_WB_DAYLIGHT: //
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0x28,0xc1);
-			i2c_put_byte_add8_new(client,0x29,0x88);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x32,0x05);
-			break;
-
-		case CAM_WB_INCANDESCENCE:
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0x28,0x7b);
-			i2c_put_byte_add8_new(client,0x29,0xd3);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x32,0x05);
-			break;
-
-		case CAM_WB_TUNGSTEN:
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0x28,0xae);
-			i2c_put_byte_add8_new(client,0x29,0xcc);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x32,0x05);
-			break;
-
-		case CAM_WB_FLUORESCENT:
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0x28,0xb4);
-			i2c_put_byte_add8_new(client,0x29,0xc4);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x32,0x05);
-			break;
-
-		case CAM_WB_MANUAL:
-		    	// TODO
-			break;
-		default:
-			break;
-	}
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+    if (!dev->vminfo.isused)
+        return;
+
+    switch (para)
+    {
+
+        case CAM_WB_AUTO://auto
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x28,0xce);
+            i2c_put_byte_add8_new(client,0x29,0x8a);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x32,0x0d);
+            break;
+
+        case CAM_WB_CLOUD: //cloud
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x28,0xe2);
+            i2c_put_byte_add8_new(client,0x29,0x82);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x32,0x05);
+            break;
+
+        case CAM_WB_DAYLIGHT: //
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x28,0xc1);
+            i2c_put_byte_add8_new(client,0x29,0x88);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x32,0x05);
+            break;
+
+        case CAM_WB_INCANDESCENCE:
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x28,0x7b);
+            i2c_put_byte_add8_new(client,0x29,0xd3);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x32,0x05);
+            break;
+
+        case CAM_WB_TUNGSTEN:
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x28,0xae);
+            i2c_put_byte_add8_new(client,0x29,0xcc);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x32,0x05);
+            break;
+
+        case CAM_WB_FLUORESCENT:
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x28,0xb4);
+            i2c_put_byte_add8_new(client,0x29,0xc4);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x32,0x05);
+            break;
+
+        case CAM_WB_MANUAL:
+                // TODO
+            break;
+        default:
+            break;
+    }
 
 
 } /* SP2518_set_param_wb */
@@ -1089,70 +1100,72 @@ void SP2518_set_param_wb(struct sp2518_device *dev,enum  camera_wb_flip_e para)/
 *************************************************************************/
 void SP2518_set_param_exposure(struct sp2518_device *dev,enum camera_exposure_e para)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
+    if (!dev->vminfo.isused)
+        return;
 
     switch (para)
-	{
+    {
+
+        case EXPOSURE_N4_STEP:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0xc0);//-40
+            break;
+
+
+
+        case EXPOSURE_N3_STEP:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0xd0);//-30
+            break;
 
-		case EXPOSURE_N4_STEP:
-			i2c_put_byte_add8_new(client,0xfd , 0x00);
-			i2c_put_byte_add8_new(client,0xdc , 0xc0);//-40
-			break;
 
+        case EXPOSURE_N2_STEP:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0xe0);//-20
+            break;
 
 
-		case EXPOSURE_N3_STEP:
-			i2c_put_byte_add8_new(client,0xfd , 0x00);    
-			i2c_put_byte_add8_new(client,0xdc , 0xd0);//-30
-			break;
+        case EXPOSURE_N1_STEP:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0xf0);//-10
+            break;
 
+        case EXPOSURE_0_STEP:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0x00);//00
+            break;
 
-		case EXPOSURE_N2_STEP:
-			i2c_put_byte_add8_new(client,0xfd , 0x00);    
-			i2c_put_byte_add8_new(client,0xdc , 0xe0);//-20
-			break;
+        case EXPOSURE_P1_STEP:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0x10);//10
+            break;
 
+        case EXPOSURE_P2_STEP:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0x20);//20
+            break;
 
-		case EXPOSURE_N1_STEP:
-			i2c_put_byte_add8_new(client,0xfd , 0x00);    
-			i2c_put_byte_add8_new(client,0xdc , 0xf0);//-10
-			break;
-			
-		case EXPOSURE_0_STEP:
-			i2c_put_byte_add8_new(client,0xfd , 0x00);    
-			i2c_put_byte_add8_new(client,0xdc , 0x00);//00
-			break;
-			
-		case EXPOSURE_P1_STEP:
-			i2c_put_byte_add8_new(client,0xfd , 0x00);    
-			i2c_put_byte_add8_new(client,0xdc , 0x10);//10
-			break;
-			
-		case EXPOSURE_P2_STEP:
-			i2c_put_byte_add8_new(client,0xfd , 0x00);    
-			i2c_put_byte_add8_new(client,0xdc , 0x20);//20
-			break;
+        case EXPOSURE_P3_STEP:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0x30);//30
+            break;
 
-		case EXPOSURE_P3_STEP:
-			i2c_put_byte_add8_new(client,0xfd , 0x00);    
-			i2c_put_byte_add8_new(client,0xdc , 0x30);//30
-			break;
-					
-		case EXPOSURE_P4_STEP:	
-			i2c_put_byte_add8_new(client,0xfd , 0x00);    
-			i2c_put_byte_add8_new(client,0xdc , 0x40);//40
-			break;
+        case EXPOSURE_P4_STEP:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0x40);//40
+            break;
 
-		default:
-			i2c_put_byte_add8_new(client,0xfd , 0x00);    
-			i2c_put_byte_add8_new(client,0xdc , 0x00);//00
-			break;
-				//break;
+        default:
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0xdc , 0x00);//00
+            break;
+                //break;
 
 
 
-	}
+    }
 
 
 } /* SP2518_set_param_exposure */
@@ -1174,57 +1187,59 @@ void SP2518_set_param_exposure(struct sp2518_device *dev,enum camera_exposure_e
 *************************************************************************/
 void SP2518_set_param_effect(struct sp2518_device *dev,enum camera_effect_flip_e para)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 
+    if (!dev->vminfo.isused)
+        return;
 
     switch (para)
-	{
-		case CAM_EFFECT_ENC_NORMAL:
-			i2c_put_byte_add8_new(client,0xfd, 0x00);
-			i2c_put_byte_add8_new(client,0x62, 0x00);
-			i2c_put_byte_add8_new(client,0x63, 0x80);
-			i2c_put_byte_add8_new(client,0x64, 0x80);
-			break;
-
-		case CAM_EFFECT_ENC_GRAYSCALE:
-			i2c_put_byte_add8_new(client,0xfd, 0x00);
-			i2c_put_byte_add8_new(client,0x62, 0x20);
-			i2c_put_byte_add8_new(client,0x63, 0x80);
-			i2c_put_byte_add8_new(client,0x64, 0x80);
-			break;
-
-		case CAM_EFFECT_ENC_SEPIA:
-			i2c_put_byte_add8_new(client,0xfd, 0x00);
-			i2c_put_byte_add8_new(client,0x62, 0x10);
-			i2c_put_byte_add8_new(client,0x63, 0xb0);
-			i2c_put_byte_add8_new(client,0x64, 0x40);
-			break;
-
-		case CAM_EFFECT_ENC_SEPIAGREEN:
-			i2c_put_byte_add8_new(client,0xfd, 0x00);
-			i2c_put_byte_add8_new(client,0x62, 0x10);
-			i2c_put_byte_add8_new(client,0x63, 0x50);
-			i2c_put_byte_add8_new(client,0x64, 0x50);
-			break;
-
-		case CAM_EFFECT_ENC_SEPIABLUE:
-			i2c_put_byte_add8_new(client,0xfd, 0x00);
-			i2c_put_byte_add8_new(client,0x62, 0x10);
-			i2c_put_byte_add8_new(client,0x63, 0x80);
-			i2c_put_byte_add8_new(client,0x64, 0xb0);
-			break;
-
-		case CAM_EFFECT_ENC_COLORINV:
-			i2c_put_byte_add8_new(client,0xfd, 0x00);
-			i2c_put_byte_add8_new(client,0x62, 0x04);
-			i2c_put_byte_add8_new(client,0x63, 0x80);
-			i2c_put_byte_add8_new(client,0x64, 0x80);
-
-			break;
-
-		default:
-			break;
-	}
+    {
+        case CAM_EFFECT_ENC_NORMAL:
+            i2c_put_byte_add8_new(client,0xfd, 0x00);
+            i2c_put_byte_add8_new(client,0x62, 0x00);
+            i2c_put_byte_add8_new(client,0x63, 0x80);
+            i2c_put_byte_add8_new(client,0x64, 0x80);
+            break;
+
+        case CAM_EFFECT_ENC_GRAYSCALE:
+            i2c_put_byte_add8_new(client,0xfd, 0x00);
+            i2c_put_byte_add8_new(client,0x62, 0x20);
+            i2c_put_byte_add8_new(client,0x63, 0x80);
+            i2c_put_byte_add8_new(client,0x64, 0x80);
+            break;
+
+        case CAM_EFFECT_ENC_SEPIA:
+            i2c_put_byte_add8_new(client,0xfd, 0x00);
+            i2c_put_byte_add8_new(client,0x62, 0x10);
+            i2c_put_byte_add8_new(client,0x63, 0xb0);
+            i2c_put_byte_add8_new(client,0x64, 0x40);
+            break;
+
+        case CAM_EFFECT_ENC_SEPIAGREEN:
+            i2c_put_byte_add8_new(client,0xfd, 0x00);
+            i2c_put_byte_add8_new(client,0x62, 0x10);
+            i2c_put_byte_add8_new(client,0x63, 0x50);
+            i2c_put_byte_add8_new(client,0x64, 0x50);
+            break;
+
+        case CAM_EFFECT_ENC_SEPIABLUE:
+            i2c_put_byte_add8_new(client,0xfd, 0x00);
+            i2c_put_byte_add8_new(client,0x62, 0x10);
+            i2c_put_byte_add8_new(client,0x63, 0x80);
+            i2c_put_byte_add8_new(client,0x64, 0xb0);
+            break;
+
+        case CAM_EFFECT_ENC_COLORINV:
+            i2c_put_byte_add8_new(client,0xfd, 0x00);
+            i2c_put_byte_add8_new(client,0x62, 0x04);
+            i2c_put_byte_add8_new(client,0x63, 0x80);
+            i2c_put_byte_add8_new(client,0x64, 0x80);
+
+            break;
+
+        default:
+            break;
+    }
 
 
 
@@ -1248,615 +1263,628 @@ void SP2518_set_param_effect(struct sp2518_device *dev,enum camera_effect_flip_e
 *************************************************************************/
 void SP2518_set_night_mode(struct sp2518_device *dev,enum  camera_night_mode_flip_e enable)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);	
-	
-	if (enable)
-	{
-		sp2518_night_or_normal = 1;	//=1,night mode; =0,normal mode	//add by sp_yjp,20120905
-		i2c_put_byte_add8_new(client,0xfd,0x0 );
-		i2c_put_byte_add8_new(client,0xb2,SP2518_LOWLIGHT_Y0ffset);
-		i2c_put_byte_add8_new(client,0xb3,0x1f);
-		if(Antiflicker== DCAMERA_FLICKER_50HZ)
-		{
-			i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x32,0x05);
-			printk("night mode 50hz\n");
-			#ifdef CLK24M_48M
-
-			//capture preview night 48M 50hz fix 6FPS maxgain 
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x03,0x00);	//0x01	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x04,0x09);	//0xd4	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x09,0x02);
-			i2c_put_byte_add8_new(client,0x0a,0x64); 
-			i2c_put_byte_add8_new(client,0xf0,0x4e);
-			i2c_put_byte_add8_new(client,0xf1,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x01); 
-			i2c_put_byte_add8_new(client,0x90,0x10);
-			i2c_put_byte_add8_new(client,0x92,0x01);
-			i2c_put_byte_add8_new(client,0x98,0x4e);
-			i2c_put_byte_add8_new(client,0x99,0x00);
-			i2c_put_byte_add8_new(client,0x9a,0x01);
-			i2c_put_byte_add8_new(client,0x9b,0x00);				  
-
-			// status				
-
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0xce,0xe0);
-			i2c_put_byte_add8_new(client,0xcf,0x04);
-			i2c_put_byte_add8_new(client,0xd0,0xe0);
-			i2c_put_byte_add8_new(client,0xd1,0x04);
-			i2c_put_byte_add8_new(client,0xd7,0x4a);//exp_nr_outd_8lsb
-			i2c_put_byte_add8_new(client,0xd8,0x00);
-			i2c_put_byte_add8_new(client,0xd9,0x4e);//exp_outd_nr_8lsb
-			i2c_put_byte_add8_new(client,0xda,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-
-			
-			#elif  defined(CLK24M_72M)
-
-			//capture preview night 72M 50hz fix 6FPS maxgain									   
-
-			i2c_put_byte_add8_new(client,0xfd , 0x00);
-			i2c_put_byte_add8_new(client,0x03 , 0x00);	//0x01	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x04 , 0x09);	//0xd4	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x05 , 0x00);
-			i2c_put_byte_add8_new(client,0x06 , 0x00);
-			i2c_put_byte_add8_new(client,0x07 , 0x00);
-			i2c_put_byte_add8_new(client,0x08 , 0x00);
-			i2c_put_byte_add8_new(client,0x09 , 0x05);
-			i2c_put_byte_add8_new(client,0x0a , 0x66);
-			i2c_put_byte_add8_new(client,0xf0 , 0x4e);
-			i2c_put_byte_add8_new(client,0xf1 , 0x00);
-			i2c_put_byte_add8_new(client,0xfd , 0x01);
-			i2c_put_byte_add8_new(client,0x90 , 0x10);
-			i2c_put_byte_add8_new(client,0x92 , 0x01);
-			i2c_put_byte_add8_new(client,0x98 , 0x4e);
-			i2c_put_byte_add8_new(client,0x99 , 0x00);
-			i2c_put_byte_add8_new(client,0x9a , 0x01);
-			i2c_put_byte_add8_new(client,0x9b , 0x00);
-
-			//Status							  
-
-			i2c_put_byte_add8_new(client,0xfd , 0x01);
-			i2c_put_byte_add8_new(client,0xce , 0xe0);
-			i2c_put_byte_add8_new(client,0xcf , 0x04);
-			i2c_put_byte_add8_new(client,0xd0 , 0xe0);
-			i2c_put_byte_add8_new(client,0xd1 , 0x04);
-			i2c_put_byte_add8_new(client,0xd7 , 0x4a);
-			i2c_put_byte_add8_new(client,0xd8 , 0x00);
-			i2c_put_byte_add8_new(client,0xd9 , 0x4e);
-			i2c_put_byte_add8_new(client,0xda , 0x00);
-			i2c_put_byte_add8_new(client,0xfd , 0x00);
-			#endif
-			i2c_put_byte_add8_new(client,0xe7,0x03);	//add by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0xe7,0x00);			
-
-		}
-		else
-		{
-			i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x32,0x05);
-			printk("night mode 60hz\n");
-
-			#ifdef CLK24M_48M
-
-			//capture preview night 48M 60hz fix 6FPS maxgain
-
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x03,0x00);	//0x01	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x04,0x06);	//0x86	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x09,0x02);
-			i2c_put_byte_add8_new(client,0x0a,0x64);
-			i2c_put_byte_add8_new(client,0xf0,0x41);
-			i2c_put_byte_add8_new(client,0xf1,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0x90,0x14); 
-			i2c_put_byte_add8_new(client,0x92,0x01);
-			i2c_put_byte_add8_new(client,0x98,0x41);
-			i2c_put_byte_add8_new(client,0x99,0x00);
-			i2c_put_byte_add8_new(client,0x9a,0x01);
-			i2c_put_byte_add8_new(client,0x9b,0x00);
-
-			// status				
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0xce,0x14);
-			i2c_put_byte_add8_new(client,0xcf,0x05);
-			i2c_put_byte_add8_new(client,0xd0,0x14);
-			i2c_put_byte_add8_new(client,0xd1,0x05);
-			i2c_put_byte_add8_new(client,0xd7,0x3d);//exp_nr_outd_8lsb
-			i2c_put_byte_add8_new(client,0xd8,0x00);
-			i2c_put_byte_add8_new(client,0xd9,0x41);//exp_outd_nr_8lsb
-			i2c_put_byte_add8_new(client,0xda,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-
-			#elif  defined(CLK24M_72M)
-
-			//capture preview night 72M 60hz fix 6FPS maxgain	
-			i2c_put_byte_add8_new(client,0xfd , 0x00);
-			i2c_put_byte_add8_new(client,0x03 , 0x01);	//0x01	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x04 , 0x06);	//0x86	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x05 , 0x00);
-			i2c_put_byte_add8_new(client,0x06 , 0x00);
-			i2c_put_byte_add8_new(client,0x07 , 0x00);
-			i2c_put_byte_add8_new(client,0x08 , 0x00);
-			i2c_put_byte_add8_new(client,0x09 , 0x05);
-			i2c_put_byte_add8_new(client,0x0a , 0x66);
-			i2c_put_byte_add8_new(client,0xf0 , 0x41);
-			i2c_put_byte_add8_new(client,0xf1 , 0x00);
-			i2c_put_byte_add8_new(client,0xfd , 0x01);
-			i2c_put_byte_add8_new(client,0x90 , 0x14);
-			i2c_put_byte_add8_new(client,0x92 , 0x01);
-			i2c_put_byte_add8_new(client,0x98 , 0x41);
-			i2c_put_byte_add8_new(client,0x99 , 0x00);
-			i2c_put_byte_add8_new(client,0x9a , 0x01);
-			i2c_put_byte_add8_new(client,0x9b , 0x00);
-
-			//Status	
-			i2c_put_byte_add8_new(client,0xfd , 0x01);
-			i2c_put_byte_add8_new(client,0xce , 0x14);
-			i2c_put_byte_add8_new(client,0xcf , 0x05);
-			i2c_put_byte_add8_new(client,0xd0 , 0x14);
-			i2c_put_byte_add8_new(client,0xd1 , 0x05);
-			i2c_put_byte_add8_new(client,0xd7 , 0x3d);
-			i2c_put_byte_add8_new(client,0xd8 , 0x00);
-			i2c_put_byte_add8_new(client,0xd9 , 0x41);
-			i2c_put_byte_add8_new(client,0xda , 0x00);
-			i2c_put_byte_add8_new(client,0xfd , 0x00);
-			#endif	
-
-			i2c_put_byte_add8_new(client,0xe7,0x03);	//add by sp_yjp,20120905
- 			i2c_put_byte_add8_new(client,0xe7,0x00);
-
-		}
-	}
-	else
-	{
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+    if (!dev->vminfo.isused)
+        return;
+
+    if (enable)
+    {
+        sp2518_night_or_normal = 1; //=1,night mode; =0,normal mode //add by sp_yjp,20120905
+        i2c_put_byte_add8_new(client,0xfd,0x0 );
+        i2c_put_byte_add8_new(client,0xb2,SP2518_LOWLIGHT_Y0ffset);
+        i2c_put_byte_add8_new(client,0xb3,0x1f);
+        if (Antiflicker == DCAMERA_FLICKER_50HZ)
+        {
+            i2c_put_byte_add8_new(client,0xfd,0x00);    //disable AE,add by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x32,0x05);
+            printk("night mode 50hz\n");
+            #ifdef CLK24M_48M
+
+            //capture preview night 48M 50hz fix 6FPS maxgain
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x03,0x00);    //0x01  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x04,0x09);    //0xd4  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x09,0x02);
+            i2c_put_byte_add8_new(client,0x0a,0x64);
+            i2c_put_byte_add8_new(client,0xf0,0x4e);
+            i2c_put_byte_add8_new(client,0xf1,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x90,0x10);
+            i2c_put_byte_add8_new(client,0x92,0x01);
+            i2c_put_byte_add8_new(client,0x98,0x4e);
+            i2c_put_byte_add8_new(client,0x99,0x00);
+            i2c_put_byte_add8_new(client,0x9a,0x01);
+            i2c_put_byte_add8_new(client,0x9b,0x00);
+
+            // status
+
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0xce,0xe0);
+            i2c_put_byte_add8_new(client,0xcf,0x04);
+            i2c_put_byte_add8_new(client,0xd0,0xe0);
+            i2c_put_byte_add8_new(client,0xd1,0x04);
+            i2c_put_byte_add8_new(client,0xd7,0x4a);//exp_nr_outd_8lsb
+            i2c_put_byte_add8_new(client,0xd8,0x00);
+            i2c_put_byte_add8_new(client,0xd9,0x4e);//exp_outd_nr_8lsb
+            i2c_put_byte_add8_new(client,0xda,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+
+
+            #elif  defined(CLK24M_72M)
+
+            //capture preview night 72M 50hz fix 6FPS maxgain
+
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0x03 , 0x00);  //0x01  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x04 , 0x09);  //0xd4  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x05 , 0x00);
+            i2c_put_byte_add8_new(client,0x06 , 0x00);
+            i2c_put_byte_add8_new(client,0x07 , 0x00);
+            i2c_put_byte_add8_new(client,0x08 , 0x00);
+            i2c_put_byte_add8_new(client,0x09 , 0x05);
+            i2c_put_byte_add8_new(client,0x0a , 0x66);
+            i2c_put_byte_add8_new(client,0xf0 , 0x4e);
+            i2c_put_byte_add8_new(client,0xf1 , 0x00);
+            i2c_put_byte_add8_new(client,0xfd , 0x01);
+            i2c_put_byte_add8_new(client,0x90 , 0x10);
+            i2c_put_byte_add8_new(client,0x92 , 0x01);
+            i2c_put_byte_add8_new(client,0x98 , 0x4e);
+            i2c_put_byte_add8_new(client,0x99 , 0x00);
+            i2c_put_byte_add8_new(client,0x9a , 0x01);
+            i2c_put_byte_add8_new(client,0x9b , 0x00);
+
+            //Status
+
+            i2c_put_byte_add8_new(client,0xfd , 0x01);
+            i2c_put_byte_add8_new(client,0xce , 0xe0);
+            i2c_put_byte_add8_new(client,0xcf , 0x04);
+            i2c_put_byte_add8_new(client,0xd0 , 0xe0);
+            i2c_put_byte_add8_new(client,0xd1 , 0x04);
+            i2c_put_byte_add8_new(client,0xd7 , 0x4a);
+            i2c_put_byte_add8_new(client,0xd8 , 0x00);
+            i2c_put_byte_add8_new(client,0xd9 , 0x4e);
+            i2c_put_byte_add8_new(client,0xda , 0x00);
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            #endif
+            i2c_put_byte_add8_new(client,0xe7,0x03);    //add by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0xe7,0x00);
+
+        }
+        else
+        {
+            i2c_put_byte_add8_new(client,0xfd,0x00);    //disable AE,add by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x32,0x05);
+            printk("night mode 60hz\n");
+
+            #ifdef CLK24M_48M
+
+            //capture preview night 48M 60hz fix 6FPS maxgain
+
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x03,0x00);    //0x01  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x04,0x06);    //0x86  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x09,0x02);
+            i2c_put_byte_add8_new(client,0x0a,0x64);
+            i2c_put_byte_add8_new(client,0xf0,0x41);
+            i2c_put_byte_add8_new(client,0xf1,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x90,0x14);
+            i2c_put_byte_add8_new(client,0x92,0x01);
+            i2c_put_byte_add8_new(client,0x98,0x41);
+            i2c_put_byte_add8_new(client,0x99,0x00);
+            i2c_put_byte_add8_new(client,0x9a,0x01);
+            i2c_put_byte_add8_new(client,0x9b,0x00);
+
+            // status
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0xce,0x14);
+            i2c_put_byte_add8_new(client,0xcf,0x05);
+            i2c_put_byte_add8_new(client,0xd0,0x14);
+            i2c_put_byte_add8_new(client,0xd1,0x05);
+            i2c_put_byte_add8_new(client,0xd7,0x3d);//exp_nr_outd_8lsb
+            i2c_put_byte_add8_new(client,0xd8,0x00);
+            i2c_put_byte_add8_new(client,0xd9,0x41);//exp_outd_nr_8lsb
+            i2c_put_byte_add8_new(client,0xda,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+
+            #elif  defined(CLK24M_72M)
+
+            //capture preview night 72M 60hz fix 6FPS maxgain
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            i2c_put_byte_add8_new(client,0x03 , 0x01);  //0x01  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x04 , 0x06);  //0x86  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x05 , 0x00);
+            i2c_put_byte_add8_new(client,0x06 , 0x00);
+            i2c_put_byte_add8_new(client,0x07 , 0x00);
+            i2c_put_byte_add8_new(client,0x08 , 0x00);
+            i2c_put_byte_add8_new(client,0x09 , 0x05);
+            i2c_put_byte_add8_new(client,0x0a , 0x66);
+            i2c_put_byte_add8_new(client,0xf0 , 0x41);
+            i2c_put_byte_add8_new(client,0xf1 , 0x00);
+            i2c_put_byte_add8_new(client,0xfd , 0x01);
+            i2c_put_byte_add8_new(client,0x90 , 0x14);
+            i2c_put_byte_add8_new(client,0x92 , 0x01);
+            i2c_put_byte_add8_new(client,0x98 , 0x41);
+            i2c_put_byte_add8_new(client,0x99 , 0x00);
+            i2c_put_byte_add8_new(client,0x9a , 0x01);
+            i2c_put_byte_add8_new(client,0x9b , 0x00);
+
+            //Status
+            i2c_put_byte_add8_new(client,0xfd , 0x01);
+            i2c_put_byte_add8_new(client,0xce , 0x14);
+            i2c_put_byte_add8_new(client,0xcf , 0x05);
+            i2c_put_byte_add8_new(client,0xd0 , 0x14);
+            i2c_put_byte_add8_new(client,0xd1 , 0x05);
+            i2c_put_byte_add8_new(client,0xd7 , 0x3d);
+            i2c_put_byte_add8_new(client,0xd8 , 0x00);
+            i2c_put_byte_add8_new(client,0xd9 , 0x41);
+            i2c_put_byte_add8_new(client,0xda , 0x00);
+            i2c_put_byte_add8_new(client,0xfd , 0x00);
+            #endif
+
+            i2c_put_byte_add8_new(client,0xe7,0x03);    //add by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0xe7,0x00);
+
+        }
+    }
+    else
+    {
         //i2c_put_byte_add8_new(client,); //Camera Enable night mode  1/5 Frame rate //zyy test
-		sp2518_night_or_normal = 0;	//=1,night mode; =0,normal mode	//add by sp_yjp,20120905
-		
-		i2c_put_byte_add8_new(client,0xfd,0x00);
-		i2c_put_byte_add8_new(client,0xb2,SP2518_NORMAL_Y0ffset);
-		i2c_put_byte_add8_new(client,0xb3,0x1f);
-
-		if(Antiflicker== DCAMERA_FLICKER_50HZ)
-		{
-			i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x32,0x05);
-			printk("normal mode 50hz\n");	
-			#ifdef CLK24M_48M
-			//capture preview daylight 48M 50hz fix 9FPS maxgain  
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x03,0x00);	//0x02	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x04,0x09);	//0xbe	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x09,0x00);
-			i2c_put_byte_add8_new(client,0x0a,0x64); 
-			i2c_put_byte_add8_new(client,0xf0,0x75);
-			i2c_put_byte_add8_new(client,0xf1,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x01);	
-			i2c_put_byte_add8_new(client,0x90,0x0b);	
-			i2c_put_byte_add8_new(client,0x92,0x01);
-			i2c_put_byte_add8_new(client,0x98,0x75);
-			i2c_put_byte_add8_new(client,0x99,0x00);
-			i2c_put_byte_add8_new(client,0x9a,0x01);
-			i2c_put_byte_add8_new(client,0x9b,0x00);				                  
-			
-			// status               
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0xce,0x07);
-			i2c_put_byte_add8_new(client,0xcf,0x05);
-			i2c_put_byte_add8_new(client,0xd0,0x07);
-			i2c_put_byte_add8_new(client,0xd1,0x05);
-			i2c_put_byte_add8_new(client,0xd7,0x71);//exp_nr_outd_8lsb
-			i2c_put_byte_add8_new(client,0xd8,0x00);
-			i2c_put_byte_add8_new(client,0xd9,0x75);//exp_outd_nr_8lsb
-			i2c_put_byte_add8_new(client,0xda,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-
-			#elif  defined(CLK24M_72M)	
-			//capture preview daylight 72M 50hz 10-13FPS maxgain
-			///SI50_SP2518 UXGA 24MEclk 3PLL 1DIV 50Hz 10-13fps
-			///ae setting
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x03,0x00);	//0x03	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x04,0x09);	//0xf6	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x09,0x00);
-			i2c_put_byte_add8_new(client,0x0a,0x8b);
-			i2c_put_byte_add8_new(client,0xf0,0xa9);
-			i2c_put_byte_add8_new(client,0xf1,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0x90,0x0a);
-			i2c_put_byte_add8_new(client,0x92,0x01);
-			i2c_put_byte_add8_new(client,0x98,0xa9);
-			i2c_put_byte_add8_new(client,0x99,0x00);
-			i2c_put_byte_add8_new(client,0x9a,0x01);
-			i2c_put_byte_add8_new(client,0x9b,0x00);
-			///Status 
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0xce,0x9a);
-			i2c_put_byte_add8_new(client,0xcf,0x06);
-			i2c_put_byte_add8_new(client,0xd0,0x9a);
-			i2c_put_byte_add8_new(client,0xd1,0x06);
-			i2c_put_byte_add8_new(client,0xd7,0xa5);
-			i2c_put_byte_add8_new(client,0xd8,0x00);
-			i2c_put_byte_add8_new(client,0xd9,0xa9);
-			i2c_put_byte_add8_new(client,0xda,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x00);      
-			#endif	      
-
-			i2c_put_byte_add8_new(client,0xe7,0x03);	//add by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0xe7,0x00);
-		}
-		else
-		{
-			i2c_put_byte_add8_new(client,0xfd,0x00);	//disable AE,add by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x32,0x05);
-			printk("normal mode 60hz\n");	
-			#ifdef CLK24M_48M
-			//capture preview daylight 48M 60Hz fix 9FPS maxgain   
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x03,0x00);	//0x02	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x04,0x09); 	//0x4c	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x09,0x00);
-			i2c_put_byte_add8_new(client,0x0a,0x5e); 
-			i2c_put_byte_add8_new(client,0xf0,0x62);
-			i2c_put_byte_add8_new(client,0xf1,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x01);	
-			i2c_put_byte_add8_new(client,0x90,0x0d);	
-			i2c_put_byte_add8_new(client,0x92,0x01);
-			i2c_put_byte_add8_new(client,0x98,0x62);
-			i2c_put_byte_add8_new(client,0x99,0x00);
-			i2c_put_byte_add8_new(client,0x9a,0x01);
-			i2c_put_byte_add8_new(client,0x9b,0x00);
-			
-			// status               
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0xce,0xfa);
-			i2c_put_byte_add8_new(client,0xcf,0x04);
-			i2c_put_byte_add8_new(client,0xd0,0xfa);
-			i2c_put_byte_add8_new(client,0xd1,0x04);
-			i2c_put_byte_add8_new(client,0xd7,0x5e);//exp_nr_outd_8lsb
-			i2c_put_byte_add8_new(client,0xd8,0x00);
-			i2c_put_byte_add8_new(client,0xd9,0x62);//exp_outd_nr_8lsb
-			i2c_put_byte_add8_new(client,0xda,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			#elif  defined(CLK24M_72M)  
-			//capture preview daylight 72M 60Hz 10-13FPS maxgain
-			///SI50_SP2518 UXGA 24MEclk 3PLL 1DIV 60Hz 10-13fps
-			///ae setting
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			i2c_put_byte_add8_new(client,0x03,0x00);	//0x03	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x04,0x09);  	//0x4e	modify by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0x09,0x00);
-			i2c_put_byte_add8_new(client,0x0a,0x8a);  
-			i2c_put_byte_add8_new(client,0xf0,0x8d);
-			i2c_put_byte_add8_new(client,0xf1,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0x90,0x0c);
-			i2c_put_byte_add8_new(client,0x92,0x01);
-			i2c_put_byte_add8_new(client,0x98,0x8d);
-			i2c_put_byte_add8_new(client,0x99,0x00);
-			i2c_put_byte_add8_new(client,0x9a,0x01);
-			i2c_put_byte_add8_new(client,0x9b,0x00);
-			///Status
-			i2c_put_byte_add8_new(client,0xfd,0x01);
-			i2c_put_byte_add8_new(client,0xce,0x9c);
-			i2c_put_byte_add8_new(client,0xcf,0x06);
-			i2c_put_byte_add8_new(client,0xd0,0x9c);
-			i2c_put_byte_add8_new(client,0xd1,0x06);
-			i2c_put_byte_add8_new(client,0xd7,0x89);
-			i2c_put_byte_add8_new(client,0xd8,0x00);
-			i2c_put_byte_add8_new(client,0xd9,0x8d);
-			i2c_put_byte_add8_new(client,0xda,0x00);
-			i2c_put_byte_add8_new(client,0xfd,0x00);
-			#endif	
-
-			i2c_put_byte_add8_new(client,0xe7,0x03);	//add by sp_yjp,20120905
-			i2c_put_byte_add8_new(client,0xe7,0x00);
-		}
-	//i2c_put_byte_add8_new(client,); //Disable night mode  1/2 Frame rate
-	}
-	i2c_put_byte_add8_new(client,0xfd,0x00);	//enable AE,add by sp_yjp,20120905
-	i2c_put_byte_add8_new(client,0x32,0x0d);
+        sp2518_night_or_normal = 0; //=1,night mode; =0,normal mode //add by sp_yjp,20120905
+
+        i2c_put_byte_add8_new(client,0xfd,0x00);
+        i2c_put_byte_add8_new(client,0xb2,SP2518_NORMAL_Y0ffset);
+        i2c_put_byte_add8_new(client,0xb3,0x1f);
+
+        if (Antiflicker == DCAMERA_FLICKER_50HZ)
+        {
+            i2c_put_byte_add8_new(client,0xfd,0x00);    //disable AE,add by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x32,0x05);
+            printk("normal mode 50hz\n");
+            #ifdef CLK24M_48M
+            //capture preview daylight 48M 50hz fix 9FPS maxgain
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x03,0x00);    //0x02  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x04,0x09);    //0xbe  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x09,0x00);
+            i2c_put_byte_add8_new(client,0x0a,0x64);
+            i2c_put_byte_add8_new(client,0xf0,0x75);
+            i2c_put_byte_add8_new(client,0xf1,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x90,0x0b);
+            i2c_put_byte_add8_new(client,0x92,0x01);
+            i2c_put_byte_add8_new(client,0x98,0x75);
+            i2c_put_byte_add8_new(client,0x99,0x00);
+            i2c_put_byte_add8_new(client,0x9a,0x01);
+            i2c_put_byte_add8_new(client,0x9b,0x00);
+
+            // status
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0xce,0x07);
+            i2c_put_byte_add8_new(client,0xcf,0x05);
+            i2c_put_byte_add8_new(client,0xd0,0x07);
+            i2c_put_byte_add8_new(client,0xd1,0x05);
+            i2c_put_byte_add8_new(client,0xd7,0x71);//exp_nr_outd_8lsb
+            i2c_put_byte_add8_new(client,0xd8,0x00);
+            i2c_put_byte_add8_new(client,0xd9,0x75);//exp_outd_nr_8lsb
+            i2c_put_byte_add8_new(client,0xda,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+
+            #elif  defined(CLK24M_72M)
+            //capture preview daylight 72M 50hz 10-13FPS maxgain
+            ///SI50_SP2518 UXGA 24MEclk 3PLL 1DIV 50Hz 10-13fps
+            ///ae setting
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x03,0x00);    //0x03  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x04,0x09);    //0xf6  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x09,0x00);
+            i2c_put_byte_add8_new(client,0x0a,0x8b);
+            i2c_put_byte_add8_new(client,0xf0,0xa9);
+            i2c_put_byte_add8_new(client,0xf1,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x90,0x0a);
+            i2c_put_byte_add8_new(client,0x92,0x01);
+            i2c_put_byte_add8_new(client,0x98,0xa9);
+            i2c_put_byte_add8_new(client,0x99,0x00);
+            i2c_put_byte_add8_new(client,0x9a,0x01);
+            i2c_put_byte_add8_new(client,0x9b,0x00);
+            ///Status
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0xce,0x9a);
+            i2c_put_byte_add8_new(client,0xcf,0x06);
+            i2c_put_byte_add8_new(client,0xd0,0x9a);
+            i2c_put_byte_add8_new(client,0xd1,0x06);
+            i2c_put_byte_add8_new(client,0xd7,0xa5);
+            i2c_put_byte_add8_new(client,0xd8,0x00);
+            i2c_put_byte_add8_new(client,0xd9,0xa9);
+            i2c_put_byte_add8_new(client,0xda,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            #endif
+
+            i2c_put_byte_add8_new(client,0xe7,0x03);    //add by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0xe7,0x00);
+        }
+        else
+        {
+            i2c_put_byte_add8_new(client,0xfd,0x00);    //disable AE,add by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x32,0x05);
+            printk("normal mode 60hz\n");
+            #ifdef CLK24M_48M
+            //capture preview daylight 48M 60Hz fix 9FPS maxgain
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x03,0x00);    //0x02  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x04,0x09);    //0x4c  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x09,0x00);
+            i2c_put_byte_add8_new(client,0x0a,0x5e);
+            i2c_put_byte_add8_new(client,0xf0,0x62);
+            i2c_put_byte_add8_new(client,0xf1,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x90,0x0d);
+            i2c_put_byte_add8_new(client,0x92,0x01);
+            i2c_put_byte_add8_new(client,0x98,0x62);
+            i2c_put_byte_add8_new(client,0x99,0x00);
+            i2c_put_byte_add8_new(client,0x9a,0x01);
+            i2c_put_byte_add8_new(client,0x9b,0x00);
+
+            // status
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0xce,0xfa);
+            i2c_put_byte_add8_new(client,0xcf,0x04);
+            i2c_put_byte_add8_new(client,0xd0,0xfa);
+            i2c_put_byte_add8_new(client,0xd1,0x04);
+            i2c_put_byte_add8_new(client,0xd7,0x5e);//exp_nr_outd_8lsb
+            i2c_put_byte_add8_new(client,0xd8,0x00);
+            i2c_put_byte_add8_new(client,0xd9,0x62);//exp_outd_nr_8lsb
+            i2c_put_byte_add8_new(client,0xda,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            #elif  defined(CLK24M_72M)
+            //capture preview daylight 72M 60Hz 10-13FPS maxgain
+            ///SI50_SP2518 UXGA 24MEclk 3PLL 1DIV 60Hz 10-13fps
+            ///ae setting
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            i2c_put_byte_add8_new(client,0x03,0x00);    //0x03  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x04,0x09);    //0x4e  modify by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0x09,0x00);
+            i2c_put_byte_add8_new(client,0x0a,0x8a);
+            i2c_put_byte_add8_new(client,0xf0,0x8d);
+            i2c_put_byte_add8_new(client,0xf1,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0x90,0x0c);
+            i2c_put_byte_add8_new(client,0x92,0x01);
+            i2c_put_byte_add8_new(client,0x98,0x8d);
+            i2c_put_byte_add8_new(client,0x99,0x00);
+            i2c_put_byte_add8_new(client,0x9a,0x01);
+            i2c_put_byte_add8_new(client,0x9b,0x00);
+            ///Status
+            i2c_put_byte_add8_new(client,0xfd,0x01);
+            i2c_put_byte_add8_new(client,0xce,0x9c);
+            i2c_put_byte_add8_new(client,0xcf,0x06);
+            i2c_put_byte_add8_new(client,0xd0,0x9c);
+            i2c_put_byte_add8_new(client,0xd1,0x06);
+            i2c_put_byte_add8_new(client,0xd7,0x89);
+            i2c_put_byte_add8_new(client,0xd8,0x00);
+            i2c_put_byte_add8_new(client,0xd9,0x8d);
+            i2c_put_byte_add8_new(client,0xda,0x00);
+            i2c_put_byte_add8_new(client,0xfd,0x00);
+            #endif
+
+            i2c_put_byte_add8_new(client,0xe7,0x03);    //add by sp_yjp,20120905
+            i2c_put_byte_add8_new(client,0xe7,0x00);
+        }
+    //i2c_put_byte_add8_new(client,); //Disable night mode  1/2 Frame rate
+    }
+    i2c_put_byte_add8_new(client,0xfd,0x00);    //enable AE,add by sp_yjp,20120905
+    i2c_put_byte_add8_new(client,0x32,0x0d);
 }    /* SP2518_NightMode */
 void SP2518_set_param_banding(struct sp2518_device *dev,enum  camera_banding_flip_e banding)
 {
-	//struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	//unsigned char buf[4];
-	
-	switch(banding) {
-	case CAM_BANDING_50HZ: 		
-		Antiflicker = DCAMERA_FLICKER_50HZ;
-		printk( " set_SP2518_anti_flicker  50hz\n" );
-		break;
-	case CAM_BANDING_60HZ:
-		Antiflicker = DCAMERA_FLICKER_60HZ;
-		printk( " set_SP2518_anti_flicker  60hz\n" );
-		break;
-	default:
-		break;
-	}
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    //unsigned char buf[4];
+
+    switch (banding) {
+    case CAM_BANDING_50HZ:
+        Antiflicker = DCAMERA_FLICKER_50HZ;
+        printk( " set_SP2518_anti_flicker  50hz\n" );
+        break;
+    case CAM_BANDING_60HZ:
+        Antiflicker = DCAMERA_FLICKER_60HZ;
+        printk( " set_SP2518_anti_flicker  60hz\n" );
+        break;
+    default:
+        break;
+    }
 
 }
 
 static int set_flip(struct sp2518_device *dev)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	unsigned char temp;
-	unsigned char buf[2];
-	temp = i2c_get_byte_add8(client, 0x31);
-	temp &= 0x9f;
-	temp |= dev->cam_info.m_flip << 5;
-	temp |= dev->cam_info.v_flip << 6;
-	buf[0] = 0x31;
-	buf[1] = temp;
-	if((i2c_put_byte_add8(client,buf, 2)) < 0) {
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    unsigned char temp;
+    unsigned char buf[2];
+
+    if (!dev->vminfo.isused)
+        return 0;
+
+    temp = i2c_get_byte_add8(client, 0x31);
+    temp &= 0x9f;
+    temp |= dev->cam_info.m_flip << 5;
+    temp |= dev->cam_info.v_flip << 6;
+    buf[0] = 0x31;
+    buf[1] = temp;
+    if ((i2c_put_byte_add8(client,buf, 2)) < 0) {
             printk("fail in setting sensor orientation\n");
             return -1;
-	}
-       
-	return 0;
-}	
+    }
+
+    return 0;
+}
 
 void SP2518_set_resolution(struct sp2518_device *dev,int height,int width)
 {
 
-	//int ret;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	printk("---------- %s : height %d  width  %d \n " , __FUNCTION__,height,width);
-	if((width<1600)&&(height<1198)){
-		//800*600
-		printk("----------  :   aaaa \n " );
+    //int ret;
+    //struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+    printk("---------- %s : height %d  width  %d \n " , __FUNCTION__,height,width);
+
+    if (!dev->vminfo.isused)
+        return;
+
+    if ((width<1600) && (height<1198)) {
+        //800*600
+        printk("----------  :   aaaa \n " );
 #if 0
-		i2c_put_byte_add8_new(client,0xfd , 0x01);
-		i2c_put_byte_add8_new(client,0x06 , 0x00);
-		i2c_put_byte_add8_new(client,0x07 , 0x40);
-		i2c_put_byte_add8_new(client,0x08 , 0x00);
-		i2c_put_byte_add8_new(client,0x09 , 0x40);
-		i2c_put_byte_add8_new(client,0x0a , 0x02);
-		i2c_put_byte_add8_new(client,0x0b , 0x58);
-		i2c_put_byte_add8_new(client,0x0c , 0x03);
-		i2c_put_byte_add8_new(client,0x0d , 0x20);
-		i2c_put_byte_add8_new(client,0x0e , 0x00);
-		//i2c_put_byte_add8_new(client,0x0f , 0x01);
-		//i2c_put_byte_add8_new(client,0xfd , 0x00);
-		//i2c_put_byte_add8_new(client,0x2f , 0x08);
+        i2c_put_byte_add8_new(client,0xfd , 0x01);
+        i2c_put_byte_add8_new(client,0x06 , 0x00);
+        i2c_put_byte_add8_new(client,0x07 , 0x40);
+        i2c_put_byte_add8_new(client,0x08 , 0x00);
+        i2c_put_byte_add8_new(client,0x09 , 0x40);
+        i2c_put_byte_add8_new(client,0x0a , 0x02);
+        i2c_put_byte_add8_new(client,0x0b , 0x58);
+        i2c_put_byte_add8_new(client,0x0c , 0x03);
+        i2c_put_byte_add8_new(client,0x0d , 0x20);
+        i2c_put_byte_add8_new(client,0x0e , 0x00);
+        //i2c_put_byte_add8_new(client,0x0f , 0x01);
+        //i2c_put_byte_add8_new(client,0xfd , 0x00);
+        //i2c_put_byte_add8_new(client,0x2f , 0x08);
 //#else
-		i2c_put_byte_add8_new(client,0xfd , 0x00);
-		i2c_put_byte_add8_new(client,0x4b , 0x00);
-		i2c_put_byte_add8_new(client,0x4c , 0x00);
-		i2c_put_byte_add8_new(client,0x47 , 0x00);
-		i2c_put_byte_add8_new(client,0x48 , 0x00);
-		i2c_put_byte_add8_new(client,0xfd , 0x01);	
-		i2c_put_byte_add8_new(client,0x06 , 0x00);
-		i2c_put_byte_add8_new(client,0x07 , 0x40);
-		i2c_put_byte_add8_new(client,0x08 , 0x00);
-		i2c_put_byte_add8_new(client,0x09 , 0x40);
-		i2c_put_byte_add8_new(client,0x0a , 0x02);
-		i2c_put_byte_add8_new(client,0x0b , 0x58);
-		i2c_put_byte_add8_new(client,0x0c , 0x03);
-		i2c_put_byte_add8_new(client,0x0d , 0x20);
-		i2c_put_byte_add8_new(client,0x0e , 0x01);
-		i2c_put_byte_add8_new(client,0xfd , 0x00);
-#endif		
-               mdelay(100);
-               sp2518_frmintervals_active.denominator 	= 15;
-               sp2518_frmintervals_active.numerator	= 1;
-		//sp2518_h_active=800;
-		//sp2518_v_active=600;
-		
-		}
-		else	if(width>=1600&&height>=1198 ){
-		//1600x1200
-		printk("----------  :  bbbb \n " );
-
-		i2c_put_byte_add8_new(client,0xfd , 0x01);
-		i2c_put_byte_add8_new(client,0x06 , 0x00);
-		i2c_put_byte_add8_new(client,0x07 , 0x40);
-		i2c_put_byte_add8_new(client,0x08 , 0x00);
-		i2c_put_byte_add8_new(client,0x09 , 0x40);
-		i2c_put_byte_add8_new(client,0x0a , 0x02);
-		i2c_put_byte_add8_new(client,0x0b , 0x58);
-		i2c_put_byte_add8_new(client,0x0c , 0x03);
-		i2c_put_byte_add8_new(client,0x0d , 0x20);
-		i2c_put_byte_add8_new(client,0x0e , 0x00);//resize_en
-		i2c_put_byte_add8_new(client,0x0f , 0x00);
-		i2c_put_byte_add8_new(client,0xfd , 0x00);
-		i2c_put_byte_add8_new(client,0x2f , 0x00);
-
+        i2c_put_byte_add8_new(client,0xfd , 0x00);
+        i2c_put_byte_add8_new(client,0x4b , 0x00);
+        i2c_put_byte_add8_new(client,0x4c , 0x00);
+        i2c_put_byte_add8_new(client,0x47 , 0x00);
+        i2c_put_byte_add8_new(client,0x48 , 0x00);
+        i2c_put_byte_add8_new(client,0xfd , 0x01);
+        i2c_put_byte_add8_new(client,0x06 , 0x00);
+        i2c_put_byte_add8_new(client,0x07 , 0x40);
+        i2c_put_byte_add8_new(client,0x08 , 0x00);
+        i2c_put_byte_add8_new(client,0x09 , 0x40);
+        i2c_put_byte_add8_new(client,0x0a , 0x02);
+        i2c_put_byte_add8_new(client,0x0b , 0x58);
+        i2c_put_byte_add8_new(client,0x0c , 0x03);
+        i2c_put_byte_add8_new(client,0x0d , 0x20);
+        i2c_put_byte_add8_new(client,0x0e , 0x01);
+        i2c_put_byte_add8_new(client,0xfd , 0x00);
+#endif
+               //mdelay(100);
+               sp2518_frmintervals_active.denominator   = 15;
+               sp2518_frmintervals_active.numerator = 1;
+        //sp2518_h_active=800;
+        //sp2518_v_active=600;
+        }
+        else    if (width >= 1600 && height >= 1198 ) {
+        //1600x1200
+        printk("----------  :  bbbb \n " );
+#if 0
+        i2c_put_byte_add8_new(client,0xfd , 0x01);
+        i2c_put_byte_add8_new(client,0x06 , 0x00);
+        i2c_put_byte_add8_new(client,0x07 , 0x40);
+        i2c_put_byte_add8_new(client,0x08 , 0x00);
+        i2c_put_byte_add8_new(client,0x09 , 0x40);
+        i2c_put_byte_add8_new(client,0x0a , 0x02);
+        i2c_put_byte_add8_new(client,0x0b , 0x58);
+        i2c_put_byte_add8_new(client,0x0c , 0x03);
+        i2c_put_byte_add8_new(client,0x0d , 0x20);
+        i2c_put_byte_add8_new(client,0x0e , 0x00);//resize_en
+        i2c_put_byte_add8_new(client,0x0f , 0x00);
+        i2c_put_byte_add8_new(client,0xfd , 0x00);
+        i2c_put_byte_add8_new(client,0x2f , 0x00);
+#endif
 /*****************************88
-		UXGA_Cap = 1;
-		ret = i2c_put_byte_add8_new(client, 0x0300, 0xc1);
-
-		shutterH = i2c_put_byte_add8_new(client, 0x0012);
-		shutterL = i2c_put_byte_add8_new(client, 0x0013);
-		AGain_shutterH = i2c_put_byte_add8_new(client, 0x0014);
-		AGain_shutterL = i2c_put_byte_add8_new(client, 0x0015);
-		DGain_shutterH = i2c_put_byte_add8_new(client, 0x0016);
-		DGain_shutterL = i2c_put_byte_add8_new(client, 0x0017);
-		//AGain_shutter = ((AGain_shutterH<<8)|(AGain_shutterL&0xff));
-		DGain_shutter = (DGain_shutterH<<8|(DGain_shutterL&0xff));
-		DGain_shutter = DGain_shutter>>2;
-		shutter =( (shutterH<<8)|(shutterL&0xff));
-		//shutter = shutter/2;
-		ret = i2c_put_byte_add8_new(client, 0x0300, 0x41);
-		ret = i2c_put_byte_add8_new(client, 0x0304, shutter>>8);
-		ret = i2c_put_byte_add8_new(client, 0x0305, shutter&0xff);
-
-		ret = i2c_put_byte_add8_new(client, 0x0307, AGain_shutterL);
-		ret = i2c_put_byte_add8_new(client, 0x0306, AGain_shutterH);
-		ret = i2c_put_byte_add8_new(client, 0x0308, DGain_shutter);
-		*******************/
-		mdelay(100);
-               sp2518_frmintervals_active.denominator 	= 5;
-               sp2518_frmintervals_active.numerator	= 1;
-		sp2518_h_active=1568;
-		sp2518_v_active=1176;//1200;
-		
-
-		}
-		set_flip(dev);
-		printk( " 2011-----11-----30--------- \n ");
+        UXGA_Cap = 1;
+        ret = i2c_put_byte_add8_new(client, 0x0300, 0xc1);
+
+        shutterH = i2c_put_byte_add8_new(client, 0x0012);
+        shutterL = i2c_put_byte_add8_new(client, 0x0013);
+        AGain_shutterH = i2c_put_byte_add8_new(client, 0x0014);
+        AGain_shutterL = i2c_put_byte_add8_new(client, 0x0015);
+        DGain_shutterH = i2c_put_byte_add8_new(client, 0x0016);
+        DGain_shutterL = i2c_put_byte_add8_new(client, 0x0017);
+        //AGain_shutter = ((AGain_shutterH<<8)|(AGain_shutterL&0xff));
+        DGain_shutter = (DGain_shutterH<<8|(DGain_shutterL&0xff));
+        DGain_shutter = DGain_shutter>>2;
+        shutter =( (shutterH<<8)|(shutterL&0xff));
+        //shutter = shutter/2;
+        ret = i2c_put_byte_add8_new(client, 0x0300, 0x41);
+        ret = i2c_put_byte_add8_new(client, 0x0304, shutter>>8);
+        ret = i2c_put_byte_add8_new(client, 0x0305, shutter&0xff);
+
+        ret = i2c_put_byte_add8_new(client, 0x0307, AGain_shutterL);
+        ret = i2c_put_byte_add8_new(client, 0x0306, AGain_shutterH);
+        ret = i2c_put_byte_add8_new(client, 0x0308, DGain_shutter);
+        *******************/
+        //mdelay(100);
+               sp2518_frmintervals_active.denominator   = 5;
+               sp2518_frmintervals_active.numerator = 1;
+        sp2518_h_active=1568;
+        sp2518_v_active=1176;//1200;
+
+        }
+        set_flip(dev);
+        printk( " 2011-----11-----30--------- \n ");
 
 }    /* SP2518_set_resolution */
 
 unsigned char v4l_2_sp2518(int val)
 {
-	int ret=val/0x20;
-	if(ret<4) return ret*0x20+0x80;
-	else if(ret<8) return ret*0x20+0x20;
-	else return 0;
+    int ret = val/0x20;
+    if (ret < 4) return ret*0x20+0x80;
+    else if (ret < 8) return ret*0x20+0x20;
+    else return 0;
 }
 
 static int convert_canvas_index(unsigned int v4l2_format, unsigned int start_canvas)
 {
-	int canvas = start_canvas;
-
-	switch(v4l2_format){
-	case V4L2_PIX_FMT_RGB565X:
-	case V4L2_PIX_FMT_VYUY:
-		canvas = start_canvas;
-		break;
-	case V4L2_PIX_FMT_YUV444:
-	case V4L2_PIX_FMT_BGR24:
-	case V4L2_PIX_FMT_RGB24:
-		canvas = start_canvas;
-		break; 
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21: 
-		canvas = start_canvas | ((start_canvas+1)<<8);
-		break;
-	case V4L2_PIX_FMT_YVU420:
-	case V4L2_PIX_FMT_YUV420:
-		if(V4L2_PIX_FMT_YUV420 == v4l2_format){
-			canvas = start_canvas|((start_canvas+1)<<8)|((start_canvas+2)<<16);
-		}else{
-			canvas = start_canvas|((start_canvas+2)<<8)|((start_canvas+1)<<16);
-		}
-		break;
-	default:
-		break;
-	}
-	return canvas;
+    int canvas = start_canvas;
+
+    switch (v4l2_format) {
+    case V4L2_PIX_FMT_RGB565X:
+    case V4L2_PIX_FMT_VYUY:
+        canvas = start_canvas;
+        break;
+    case V4L2_PIX_FMT_YUV444:
+    case V4L2_PIX_FMT_BGR24:
+    case V4L2_PIX_FMT_RGB24:
+        canvas = start_canvas;
+        break;
+    case V4L2_PIX_FMT_NV12:
+    case V4L2_PIX_FMT_NV21:
+        canvas = start_canvas | ((start_canvas + 1) << 8);
+        break;
+    case V4L2_PIX_FMT_YVU420:
+    case V4L2_PIX_FMT_YUV420:
+        if (V4L2_PIX_FMT_YUV420 == v4l2_format) {
+            canvas = start_canvas | ((start_canvas + 1) << 8) | ((start_canvas + 2) << 16);
+        } else {
+            canvas = start_canvas | ((start_canvas + 2) << 8) | ((start_canvas + 1) << 16);
+        }
+        break;
+    default:
+        break;
+    }
+    return canvas;
 }
 
 static int sp2518_setting(struct sp2518_device *dev,int PROP_ID,int value )
 {
 #if 1 //zyy test
-	int ret=0;
-	//unsigned char cur_val;
-	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
-	switch(PROP_ID)  {
-	case V4L2_CID_BRIGHTNESS:
-		dprintk(dev, 1, "setting brightned:%d\n",v4l_2_sp2518(value));
-		ret=i2c_put_byte_add8_new(client,0xdc,v4l_2_sp2518(value));
-		break;
-	case V4L2_CID_CONTRAST:
-		ret=i2c_put_byte_add8_new(client,0xde, value);
-		break;
-	case V4L2_CID_SATURATION:
-		ret=i2c_put_byte_add8_new(client,0xd9, value);
-		break;
+    int ret=0;
+    //unsigned char cur_val;
+    struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+    if (!dev->vminfo.isused)
+        return 0;
+
+    switch (PROP_ID)  {
+    case V4L2_CID_BRIGHTNESS:
+        dprintk(dev, 1, "setting brightned:%d\n",v4l_2_sp2518(value));
+        ret=i2c_put_byte_add8_new(client,0xdc,v4l_2_sp2518(value));
+        break;
+    case V4L2_CID_CONTRAST:
+        ret=i2c_put_byte_add8_new(client,0xde, value);
+        break;
+    case V4L2_CID_SATURATION:
+        ret=i2c_put_byte_add8_new(client,0xd9, value);
+        break;
 #if 0
-	case V4L2_CID_EXPOSURE:
-		ret=i2c_put_byte_add8_new(client,0xdc, value);
-		break;
+    case V4L2_CID_EXPOSURE:
+        ret=i2c_put_byte_add8_new(client,0xdc, value);
+        break;
 #endif
 #if 0
-	case V4L2_CID_HFLIP:    /* set flip on H. */
-		ret=i2c_put_byte_add8_new(client,0x0101);
-		if(ret>0) {
-			cur_val=(char)ret;
-			if(value!=0)
-				cur_val=cur_val|0x1;
-			else
-				cur_val=cur_val&0xFE;
-			ret=i2c_put_byte_add8_new(client,0x0101,cur_val);
-			if(ret<0) dprintk(dev, 1, "V4L2_CID_HFLIP setting error\n");
-		}  else {
-			dprintk(dev, 1, "vertical read error\n");
-		}
-		break;
-	case V4L2_CID_VFLIP:    /* set flip on V. */
-		ret=i2c_put_byte_add8_new(client,0x0101);
-		if(ret>0) {
-			cur_val=(char)ret;
-			if(value!=0)
-				cur_val=cur_val|0x02;
-			else
-				cur_val=cur_val&0xFD;
-			ret=i2c_put_byte_add8_new(client,0x0101,cur_val);
-		} else {
-			dprintk(dev, 1, "vertical read error\n");
-		}
-		break;
+    case V4L2_CID_HFLIP:    /* set flip on H. */
+        ret=i2c_put_byte_add8_new(client,0x0101);
+        if (ret > 0) {
+            cur_val=(char)ret;
+            if (value != 0)
+                cur_val=cur_val|0x1;
+            else
+                cur_val=cur_val&0xFE;
+            ret=i2c_put_byte_add8_new(client,0x0101,cur_val);
+            if (ret < 0) dprintk(dev, 1, "V4L2_CID_HFLIP setting error\n");
+        }  else {
+            dprintk(dev, 1, "vertical read error\n");
+        }
+        break;
+    case V4L2_CID_VFLIP:    /* set flip on V. */
+        ret = i2c_put_byte_add8_new(client,0x0101);
+        if (ret > 0) {
+            cur_val = (char)ret;
+            if (value != 0)
+                cur_val = cur_val | 0x02;
+            else
+                cur_val = cur_val & 0xFD;
+            ret = i2c_put_byte_add8_new(client,0x0101,cur_val);
+        } else {
+            dprintk(dev, 1, "vertical read error\n");
+        }
+        break;
 #endif
-	case V4L2_CID_DO_WHITE_BALANCE:
-        if(sp2518_qctrl[0].default_value!=value){
-			sp2518_qctrl[0].default_value=value;
-			SP2518_set_param_wb(dev,value);
-			printk(KERN_INFO " set camera  white_balance=%d. \n ",value);
-        	}
-		break;
-	case V4L2_CID_EXPOSURE:
-        if(sp2518_qctrl[1].default_value!=value){
-			sp2518_qctrl[1].default_value=value;
-			SP2518_set_param_exposure(dev,value);
-			printk(KERN_INFO " set camera  exposure=%d. \n ",value);
-        	}
-		break;
-	case V4L2_CID_COLORFX:
-        if(sp2518_qctrl[2].default_value!=value){
-			sp2518_qctrl[2].default_value=value;
-			//SP2518_set_param_effect(dev,value);
-			printk(KERN_INFO " set camera  effect=%d. \n ",value);
-        	}
-		break;
-	case V4L2_CID_WHITENESS:
-		 if(sp2518_qctrl[3].default_value!=value){
-			sp2518_qctrl[3].default_value=value;
-			printk("@@@SP_000:SP2518_set_param_banding,value=%d\n",value);
-			SP2518_set_param_banding(dev,value);
-
-			printk("@@@SP_111:sp2518_night_or_normal = %d",sp2518_night_or_normal);
-			SP2518_set_night_mode(dev,sp2518_night_or_normal);	//add by sp_yjp,20120905
-			printk(KERN_INFO " set camera  banding=%d. \n ",value);
-        	}
-		break;
-	case V4L2_CID_BLUE_BALANCE:
-		 if(sp2518_qctrl[4].default_value!=value){
-			sp2518_qctrl[4].default_value=value;
-			printk("@@@SP_222:SP2518_set_night_mode,night mode=%d\n",value);
-			printk("@@@SP_333:sp2518_night_or_normal = %d",sp2518_night_or_normal);
-			SP2518_set_night_mode(dev,value);
-			printk(KERN_INFO " set camera  scene mode=%d. \n ",value);
-        	}
-		break;
-	case V4L2_CID_HFLIP:    /* set flip on H. */          
-		value = value & 0x3;
-		if(sp2518_qctrl[5].default_value!=value){
-			sp2518_qctrl[5].default_value=value;
-			printk(" set camera  h filp =%d. \n ",value);
-		}
-		break;
-	case V4L2_CID_VFLIP:    /* set flip on V. */         
-		break;
-	case V4L2_CID_ZOOM_ABSOLUTE:
-		if(sp2518_qctrl[7].default_value!=value){
-			sp2518_qctrl[7].default_value=value;
-			//printk(KERN_INFO " set camera  zoom mode=%d. \n ",value);
-		}
-		break;
-	case V4L2_CID_ROTATE:
-		if(sp2518_qctrl[8].default_value!=value){
-			sp2518_qctrl[8].default_value=value;
-			printk(" set camera  rotate =%d. \n ",value);
-		}
-	default:
-		ret=-1;
-		break;
-	}
-	return ret;
+    case V4L2_CID_DO_WHITE_BALANCE:
+        if (sp2518_qctrl[0].default_value != value) {
+            sp2518_qctrl[0].default_value = value;
+            SP2518_set_param_wb(dev,value);
+            printk(KERN_INFO " set camera  white_balance=%d. \n ",value);
+            }
+        break;
+    case V4L2_CID_EXPOSURE:
+        if (sp2518_qctrl[1].default_value != value) {
+            sp2518_qctrl[1].default_value = value;
+            SP2518_set_param_exposure(dev,value);
+            printk(KERN_INFO " set camera  exposure=%d. \n ",value);
+            }
+        break;
+    case V4L2_CID_COLORFX:
+        if (sp2518_qctrl[2].default_value != value) {
+            sp2518_qctrl[2].default_value = value;
+            //SP2518_set_param_effect(dev,value);
+            printk(KERN_INFO " set camera  effect=%d. \n ",value);
+            }
+        break;
+    case V4L2_CID_WHITENESS:
+         if (sp2518_qctrl[3].default_value != value) {
+            sp2518_qctrl[3].default_value = value;
+            printk("@@@SP_000:SP2518_set_param_banding,value=%d\n",value);
+            SP2518_set_param_banding(dev,value);
+
+            printk("@@@SP_111:sp2518_night_or_normal = %d",sp2518_night_or_normal);
+            SP2518_set_night_mode(dev,sp2518_night_or_normal);  //add by sp_yjp,20120905
+            printk(KERN_INFO " set camera  banding=%d. \n ",value);
+            }
+        break;
+    case V4L2_CID_BLUE_BALANCE:
+         if (sp2518_qctrl[4].default_value != value) {
+            sp2518_qctrl[4].default_value = value;
+            printk("@@@SP_222:SP2518_set_night_mode,night mode=%d\n",value);
+            printk("@@@SP_333:sp2518_night_or_normal = %d",sp2518_night_or_normal);
+            SP2518_set_night_mode(dev,value);
+            printk(KERN_INFO " set camera  scene mode=%d. \n ",value);
+            }
+        break;
+    case V4L2_CID_HFLIP:    /* set flip on H. */
+        value = value & 0x3;
+        if (sp2518_qctrl[5].default_value != value) {
+            sp2518_qctrl[5].default_value = value;
+            printk(" set camera  h filp =%d. \n ",value);
+        }
+        break;
+    case V4L2_CID_VFLIP:    /* set flip on V. */
+        break;
+    case V4L2_CID_ZOOM_ABSOLUTE:
+        if (sp2518_qctrl[7].default_value != value) {
+            sp2518_qctrl[7].default_value = value;
+            //printk(KERN_INFO " set camera  zoom mode=%d. \n ",value);
+        }
+        break;
+    case V4L2_CID_ROTATE:
+        if (sp2518_qctrl[8].default_value != value) {
+            sp2518_qctrl[8].default_value = value;
+            printk(" set camera  rotate =%d. \n ",value);
+        }
+    default:
+        ret = -1;
+        break;
+    }
+    return ret;
 #endif
 }
 
@@ -1866,339 +1894,483 @@ static void power_down_sp2518(struct sp2518_device *dev)
 }
 
 /* ------------------------------------------------------------------
-	DMA and thread functions
+    DMA and thread functions
    ------------------------------------------------------------------*/
 
-#define TSTAMP_MIN_Y	24
-#define TSTAMP_MAX_Y	(TSTAMP_MIN_Y + 15)
-#define TSTAMP_INPUT_X	10
-#define TSTAMP_MIN_X	(54 + TSTAMP_INPUT_X)
+#define TSTAMP_MIN_Y    24
+#define TSTAMP_MAX_Y    (TSTAMP_MIN_Y + 15)
+#define TSTAMP_INPUT_X  10
+#define TSTAMP_MIN_X    (54 + TSTAMP_INPUT_X)
 
 static void sp2518_fillbuff(struct sp2518_fh *fh, struct sp2518_buffer *buf)
 {
-	struct sp2518_device *dev = fh->dev;
-	void *vbuf = (void *)videobuf_to_res(&buf->vb);
-	vm_output_para_t para = {0};
-	dprintk(dev,1,"%s\n", __func__);
-	if (!vbuf)
-		return;
-	/*  0x18221223 indicate the memory type is MAGIC_VMAL_MEM*/
-	if(buf->canvas_id == 0)
-           buf->canvas_id = convert_canvas_index(fh->fmt->fourcc, CAMERA_USER_CANVAS_INDEX+buf->vb.i*3);
-	para.mirror = sp2518_qctrl[5].default_value&3;// not set
-	para.v4l2_format = fh->fmt->fourcc;
-	para.v4l2_memory = MAGIC_RE_MEM;
-	para.zoom = sp2518_qctrl[7].default_value;
-	para.angle = sp2518_qctrl[8].default_value;
-	para.vaddr = (unsigned)vbuf;
-	para.ext_canvas = buf->canvas_id;
-        para.width = buf->vb.width;
-        para.height = buf->vb.height;
-	vm_fill_buffer(&buf->vb,&para);
-	buf->vb.state = VIDEOBUF_DONE;
+    int ret;
+    void *vbuf;
+    vm_output_para_t para = {0};
+    struct sp2518_device *dev = fh->dev;
+    if (dev->vminfo.mem_alloc_succeed) {
+        vbuf = (void *)videobuf_to_res(&buf->vb);
+    } else {
+        vbuf = videobuf_to_vmalloc(&buf->vb);
+    }
+    dprintk(dev,1,"%s\n", __func__);
+    if (!vbuf)
+        return;
+    /*  0x18221223 indicate the memory type is MAGIC_VMAL_MEM*/
+    if (dev->vminfo.mem_alloc_succeed) {
+    if (buf->canvas_id == 0)
+       buf->canvas_id = convert_canvas_index(fh->fmt->fourcc, CAMERA_USER_CANVAS_INDEX + buf->vb.i * 3);
+       para.v4l2_memory = MAGIC_RE_MEM;
+    } else {
+       para.v4l2_memory = MAGIC_VMAL_MEM;
+    }
+    para.mirror = sp2518_qctrl[5].default_value & 3;// not set
+    para.v4l2_format = fh->fmt->fourcc;
+    para.zoom = sp2518_qctrl[7].default_value;
+    para.angle = sp2518_qctrl[8].default_value;
+    para.vaddr = (unsigned)vbuf;
+    para.ext_canvas = buf->canvas_id;
+    para.width = buf->vb.width;
+    para.height = buf->vb.height;
+    ret = vm_fill_this_buffer(&buf->vb,&para,&dev->vminfo);
+/*if the vm is not used by sensor ,we let vm_fill_this_buffer() return -2*/
+    if (ret == -2) {
+        msleep(40);
+    }
+    buf->vb.state = VIDEOBUF_DONE;
 }
 
 static void sp2518_thread_tick(struct sp2518_fh *fh)
 {
-	struct sp2518_buffer *buf;
-	struct sp2518_device *dev = fh->dev;
-	struct sp2518_dmaqueue *dma_q = &dev->vidq;
+    struct sp2518_buffer *buf;
+    struct sp2518_device *dev = fh->dev;
+    struct sp2518_dmaqueue *dma_q = &dev->vidq;
 
-	unsigned long flags = 0;
+    unsigned long flags = 0;
 
-	dprintk(dev, 1, "Thread tick\n");
-       if(!fh->stream_on){
+    dprintk(dev, 1, "Thread tick\n");
+       if (!fh->stream_on) {
             dprintk(dev, 1, "sensor doesn't stream on\n");
             return ;
        }
-	spin_lock_irqsave(&dev->slock, flags);
-	if (list_empty(&dma_q->active)) {
-		dprintk(dev, 1, "No active queue to serve\n");
-		goto unlock;
-	}
-
-	buf = list_entry(dma_q->active.next,
-			 struct sp2518_buffer, vb.queue);
+    spin_lock_irqsave(&dev->slock, flags);
+    if (list_empty(&dma_q->active)) {
+        dprintk(dev, 1, "No active queue to serve\n");
+        goto unlock;
+    }
+
+    buf = list_entry(dma_q->active.next,
+             struct sp2518_buffer, vb.queue);
        dprintk(dev, 1, "%s\n", __func__);
        dprintk(dev, 1, "list entry get buf is %x\n",(unsigned)buf);
 
-       if(!(fh->f_flags & O_NONBLOCK)){
+       if (!(fh->f_flags & O_NONBLOCK)) {
            /* Nobody is waiting on this buffer, return */
            if (!waitqueue_active(&buf->vb.done))
                goto unlock;
        }
        buf->vb.state = VIDEOBUF_ACTIVE;
 
-	list_del(&buf->vb.queue);
+    list_del(&buf->vb.queue);
 
-	do_gettimeofday(&buf->vb.ts);
+    do_gettimeofday(&buf->vb.ts);
 
-	/* Fill buffer */
-	spin_unlock_irqrestore(&dev->slock, flags);
-	sp2518_fillbuff(fh, buf);
-	dprintk(dev, 1, "filled buffer %p\n", buf);
+    /* Fill buffer */
+    spin_unlock_irqrestore(&dev->slock, flags);
+    sp2518_fillbuff(fh, buf);
+    dprintk(dev, 1, "filled buffer %p\n", buf);
 
-	wake_up(&buf->vb.done);
-	dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
-	return;
+    wake_up(&buf->vb.done);
+    dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
+    return;
 unlock:
-	spin_unlock_irqrestore(&dev->slock, flags);
-	return;
+    spin_unlock_irqrestore(&dev->slock, flags);
+    return;
 }
 
-#define frames_to_ms(frames)					\
-	((frames * WAKE_NUMERATOR * 1000) / WAKE_DENOMINATOR)
+#define frames_to_ms(frames)                    \
+    ((frames * WAKE_NUMERATOR * 1000) / WAKE_DENOMINATOR)
 
 static void sp2518_sleep(struct sp2518_fh *fh)
 {
-	struct sp2518_device *dev = fh->dev;
-	struct sp2518_dmaqueue *dma_q = &dev->vidq;
+    struct sp2518_device *dev = fh->dev;
+    struct sp2518_dmaqueue *dma_q = &dev->vidq;
 
-	DECLARE_WAITQUEUE(wait, current);
+    DECLARE_WAITQUEUE(wait, current);
 
-	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
-		(unsigned long)dma_q);
+    dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
+        (unsigned long)dma_q);
 
-	add_wait_queue(&dma_q->wq, &wait);
-	if (kthread_should_stop())
-		goto stop_task;
+    add_wait_queue(&dma_q->wq, &wait);
+    if (kthread_should_stop())
+        goto stop_task;
 
-	/* Calculate time to wake up */
-	//timeout = msecs_to_jiffies(frames_to_ms(1));
+    /* Calculate time to wake up */
+    //timeout = msecs_to_jiffies(frames_to_ms(1));
 
-	sp2518_thread_tick(fh);
+    sp2518_thread_tick(fh);
 
-	schedule_timeout_interruptible(2);
+    schedule_timeout_interruptible(2);
 
 stop_task:
-	remove_wait_queue(&dma_q->wq, &wait);
-	try_to_freeze();
+    remove_wait_queue(&dma_q->wq, &wait);
+    try_to_freeze();
 }
 
 static int sp2518_thread(void *data)
 {
-	struct sp2518_fh  *fh = data;
-	struct sp2518_device *dev = fh->dev;
+    struct sp2518_fh  *fh = data;
+    struct sp2518_device *dev = fh->dev;
 
-	dprintk(dev, 1, "thread started\n");
+    dprintk(dev, 1, "thread started\n");
 
-	set_freezable();
+    set_freezable();
 
-	for (;;) {
-		sp2518_sleep(fh);
+    for (; ;) {
+        sp2518_sleep(fh);
 
-		if (kthread_should_stop())
-			break;
-	}
-	dprintk(dev, 1, "thread: exit\n");
-	return 0;
+        if (kthread_should_stop())
+            break;
+    }
+    dprintk(dev, 1, "thread: exit\n");
+    return 0;
 }
 
 static int sp2518_start_thread(struct sp2518_fh *fh)
 {
-	struct sp2518_device *dev = fh->dev;
-	struct sp2518_dmaqueue *dma_q = &dev->vidq;
+    struct sp2518_device *dev = fh->dev;
+    struct sp2518_dmaqueue *dma_q = &dev->vidq;
 
-	dma_q->frame = 0;
-	dma_q->ini_jiffies = jiffies;
+    dma_q->frame = 0;
+    dma_q->ini_jiffies = jiffies;
 
-	dprintk(dev, 1, "%s\n", __func__);
+    dprintk(dev, 1, "%s\n", __func__);
 
-	dma_q->kthread = kthread_run(sp2518_thread, fh, "sp2518");
+    dma_q->kthread = kthread_run(sp2518_thread, fh, "sp2518");
 
-	if (IS_ERR(dma_q->kthread)) {
-		v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
-		return PTR_ERR(dma_q->kthread);
-	}
-	/* Wakes thread */
-	wake_up_interruptible(&dma_q->wq);
+    if (IS_ERR(dma_q->kthread)) {
+        v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
+        return PTR_ERR(dma_q->kthread);
+    }
+    /* Wakes thread */
+    wake_up_interruptible(&dma_q->wq);
 
-	dprintk(dev, 1, "returning from %s\n", __func__);
-	return 0;
+    dprintk(dev, 1, "returning from %s\n", __func__);
+    return 0;
 }
 
 static void sp2518_stop_thread(struct sp2518_dmaqueue  *dma_q)
 {
-	struct sp2518_device *dev = container_of(dma_q, struct sp2518_device, vidq);
+    struct sp2518_device *dev = container_of(dma_q, struct sp2518_device, vidq);
 
-	dprintk(dev, 1, "%s\n", __func__);
-	/* shutdown control thread */
-	if (dma_q->kthread) {
-		kthread_stop(dma_q->kthread);
-		dma_q->kthread = NULL;
-	}
+    dprintk(dev, 1, "%s\n", __func__);
+    /* shutdown control thread */
+    if (dma_q->kthread) {
+        kthread_stop(dma_q->kthread);
+        dma_q->kthread = NULL;
+    }
 }
 
 /* ------------------------------------------------------------------
-	Videobuf operations
+    Videobuf operations
    ------------------------------------------------------------------*/
 static int
-buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+vmall_buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+    struct sp2518_fh  *fh = vq->priv_data;
+    struct sp2518_device *dev  = fh->dev;
+    //int bytes = fh->fmt->depth >> 3 ;
+    *size = (fh->width*fh->height*fh->fmt->depth)>>3;
+    if (0 == *count)
+    *count = 32;
+
+    while (*size * *count > vid_limit * 1024 * 1024)
+    (*count)--;
+
+    dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
+    *count, *size);
+
+    return 0;
+}
+
+static int
+res_buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
 {
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp2518_fh *fh = container_of(res, struct sp2518_fh, res);
-	struct sp2518_device *dev  = fh->dev;
+    struct videobuf_res_privdata *res = vq->priv_data;
+    struct sp2518_fh *fh = container_of(res, struct sp2518_fh, res);
+    struct sp2518_device *dev  = fh->dev;
     //int bytes = fh->fmt->depth >> 3 ;
-	int height = fh->height;
-	if(height==1080)
-		height = 1088;
-	*size = (fh->width*height*fh->fmt->depth)>>3;
-	if (0 == *count)
-		*count = 32;
+    int height = fh->height;
+    if (height == 1080)
+        height = 1088;
+    *size = (fh->width * height * fh->fmt->depth) >> 3;
+    if (0 == *count)
+        *count = 32;
+
+    while (*size * *count > vid_limit * 1024 * 1024)
+        (*count)--;
+
+    dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
+        *count, *size);
+
+    return 0;
+}
 
-	while (*size * *count > vid_limit * 1024 * 1024)
-		(*count)--;
+static void free_vmall_buffer(struct videobuf_queue *vq, struct sp2518_buffer *buf)
+{
+    struct sp2518_fh *fh;
+    struct sp2518_device *dev;
+    fh = vq->priv_data;
+    dev = fh->dev;
 
-	dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
-		*count, *size);
+    dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
 
-	return 0;
+    videobuf_waiton(vq, &buf->vb, 0, 0);
+    if (in_interrupt())
+        BUG();
+    videobuf_vmalloc_free(&buf->vb);
+    dprintk(dev, 1, "free_vmall_buffer: freed\n");
+    buf->vb.state = VIDEOBUF_NEEDS_INIT;
 }
 
-static void free_buffer(struct videobuf_queue *vq, struct sp2518_buffer *buf)
+static void free_res_buffer(struct videobuf_queue *vq, struct sp2518_buffer *buf)
 {
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp2518_fh *fh = container_of(res, struct sp2518_fh, res);
-	struct sp2518_device *dev  = fh->dev;
+    struct sp2518_fh *fh;
+    struct sp2518_device *dev;
+    struct videobuf_res_privdata *res = vq->priv_data;
+    fh = container_of(res, struct sp2518_fh, res);
+    dev = fh->dev;
 
-	dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
-       videobuf_waiton(vq, &buf->vb, 0, 0); 
-	if (in_interrupt())
-		BUG();
+    dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
 
-	videobuf_res_free(vq, &buf->vb);
-	dprintk(dev, 1, "free_buffer: freed\n");
-	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+    videobuf_waiton(vq, &buf->vb, 0, 0);
+    if (in_interrupt())
+        BUG();
+    videobuf_res_free(vq, &buf->vb);
+    dprintk(dev, 1, "free_res_buffer: freed\n");
+    buf->vb.state = VIDEOBUF_NEEDS_INIT;
 }
 
 #define norm_maxw() 1920
 #define norm_maxh() 1600
 static int
-buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
-						enum v4l2_field field)
-{
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp2518_fh *fh = container_of(res, struct sp2518_fh, res);
-	struct sp2518_device    *dev = fh->dev;
-	struct sp2518_buffer *buf = container_of(vb, struct sp2518_buffer, vb);
-	int rc;
+vmall_buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+                        enum v4l2_field field)
+{
+    struct sp2518_fh *fh;
+    struct sp2518_device *dev;
+    struct sp2518_buffer *buf;
+    int rc;
+    fh  = vq->priv_data;
+    dev = fh->dev;
+    buf = container_of(vb, struct sp2518_buffer, vb);
     //int bytes = fh->fmt->depth >> 3 ;
-	dprintk(dev, 1, "%s, field=%d\n", __func__, field);
+    dprintk(dev, 1, "%s, field=%d\n", __func__, field);
 
-	BUG_ON(NULL == fh->fmt);
+    BUG_ON(NULL == fh->fmt);
 
-	if (fh->width  < 48 || fh->width  > norm_maxw() ||
-	    fh->height < 32 || fh->height > norm_maxh())
-		return -EINVAL;
+    if (fh->width  < 48 || fh->width  > norm_maxw() ||
+        fh->height < 32 || fh->height > norm_maxh())
+        return -EINVAL;
 
-	buf->vb.size = (fh->width*fh->height*fh->fmt->depth)>>3;
-	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
-		return -EINVAL;
+    buf->vb.size = (fh->width * fh->height * fh->fmt->depth) >> 3;
+    if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+        return -EINVAL;
 
-	/* These properties only change when queue is idle, see s_fmt */
-	buf->fmt       = fh->fmt;
-	buf->vb.width  = fh->width;
-	buf->vb.height = fh->height;
-	buf->vb.field  = field;
+    /* These properties only change when queue is idle, see s_fmt */
+    buf->fmt       = fh->fmt;
+    buf->vb.width  = fh->width;
+    buf->vb.height = fh->height;
+    buf->vb.field  = field;
 
-	//precalculate_bars(fh);
+    //precalculate_bars(fh);
 
-	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
-		rc = videobuf_iolock(vq, &buf->vb, NULL);
-		if (rc < 0)
-			goto fail;
-	}
+    if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+        rc = videobuf_iolock(vq, &buf->vb, NULL);
+        if (rc < 0)
+            goto fail;
+    }
 
-	buf->vb.state = VIDEOBUF_PREPARED;
+    buf->vb.state = VIDEOBUF_PREPARED;
 
-	return 0;
+    return 0;
 
 fail:
-	free_buffer(vq, buf);
-	return rc;
+    free_vmall_buffer(vq, buf);
+    return rc;
+}
+
+static int
+res_buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+                        enum v4l2_field field)
+{
+    struct sp2518_fh *fh;
+    struct sp2518_device *dev;
+    struct sp2518_buffer *buf;
+    int rc;
+    struct videobuf_res_privdata *res = vq->priv_data;
+    fh = container_of(res, struct sp2518_fh, res);
+    dev = fh->dev;
+    buf = container_of(vb, struct sp2518_buffer, vb);
+    //int bytes = fh->fmt->depth >> 3 ;
+    dprintk(dev, 1, "%s, field=%d\n", __func__, field);
+
+    BUG_ON(NULL == fh->fmt);
+
+    if (fh->width  < 48 || fh->width  > norm_maxw() ||
+        fh->height < 32 || fh->height > norm_maxh())
+        return -EINVAL;
+
+    buf->vb.size = (fh->width * fh->height * fh->fmt->depth) >> 3;
+    if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+        return -EINVAL;
+
+    /* These properties only change when queue is idle, see s_fmt */
+    buf->fmt       = fh->fmt;
+    buf->vb.width  = fh->width;
+    buf->vb.height = fh->height;
+    buf->vb.field  = field;
+
+    //precalculate_bars(fh);
+
+    if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+        rc = videobuf_iolock(vq, &buf->vb, NULL);
+        if (rc < 0)
+            goto fail;
+    }
+
+    buf->vb.state = VIDEOBUF_PREPARED;
+
+    return 0;
+
+fail:
+    free_res_buffer(vq, buf);
+    return rc;
+}
+
+static void
+res_buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+    struct sp2518_fh *fh;
+    struct sp2518_device *dev;
+    struct sp2518_dmaqueue *vidq;
+    struct sp2518_buffer *buf  = container_of(vb, struct sp2518_buffer, vb);
+    struct videobuf_res_privdata *res = vq->priv_data;
+    fh = container_of(res, struct sp2518_fh, res);
+    dev = fh->dev;
+    vidq = &dev->vidq;
+
+    dprintk(dev, 1, "%s\n", __func__);
+    buf->vb.state = VIDEOBUF_QUEUED;
+    list_add_tail(&buf->vb.queue, &vidq->active);
 }
 
 static void
-buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+vmall_buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+    struct sp2518_fh *fh;
+    struct sp2518_device *dev;
+    struct sp2518_dmaqueue *vidq;
+    struct sp2518_buffer *buf  = container_of(vb, struct sp2518_buffer, vb);
+    fh = vq->priv_data;
+    dev = fh->dev;
+    vidq = &dev->vidq;
+
+    dprintk(dev, 1, "%s\n", __func__);
+    buf->vb.state = VIDEOBUF_QUEUED;
+    list_add_tail(&buf->vb.queue, &vidq->active);
+}
+
+static void res_buffer_release(struct videobuf_queue *vq,
+               struct videobuf_buffer *vb)
 {
-	struct sp2518_buffer    *buf  = container_of(vb, struct sp2518_buffer, vb);
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp2518_fh *fh = container_of(res, struct sp2518_fh, res);
-	struct sp2518_device       *dev  = fh->dev;
-	struct sp2518_dmaqueue *vidq = &dev->vidq;
+    struct sp2518_fh *fh;
+    struct sp2518_device *dev;
+    struct sp2518_buffer   *buf  = container_of(vb, struct sp2518_buffer, vb);
+    struct videobuf_res_privdata *res = vq->priv_data;
+    fh = container_of(res, struct sp2518_fh, res);
+    dev = (struct sp2518_device *)fh->dev;
+
+    dprintk(dev, 1, "%s\n", __func__);
 
-	dprintk(dev, 1, "%s\n", __func__);
-	buf->vb.state = VIDEOBUF_QUEUED;
-	list_add_tail(&buf->vb.queue, &vidq->active);
+    free_res_buffer(vq, buf);
 }
 
-static void buffer_release(struct videobuf_queue *vq,
-			   struct videobuf_buffer *vb)
+static void vmall_buffer_release(struct videobuf_queue *vq,
+               struct videobuf_buffer *vb)
 {
-	struct sp2518_buffer   *buf  = container_of(vb, struct sp2518_buffer, vb);
-	struct videobuf_res_privdata *res = vq->priv_data;
-	struct sp2518_fh *fh = container_of(res, struct sp2518_fh, res);
-	struct sp2518_device      *dev  = (struct sp2518_device *)fh->dev;
+    struct sp2518_fh *fh;
+    struct sp2518_device *dev;
+    struct sp2518_buffer   *buf  = container_of(vb, struct sp2518_buffer, vb);
+    fh   = vq->priv_data;
+    dev = (struct sp2518_device *)fh->dev;
 
-	dprintk(dev, 1, "%s\n", __func__);
+    dprintk(dev, 1, "%s\n", __func__);
 
-	free_buffer(vq, buf);
+    free_vmall_buffer(vq, buf);
 }
 
-static struct videobuf_queue_ops sp2518_video_qops = {
-	.buf_setup      = buffer_setup,
-	.buf_prepare    = buffer_prepare,
-	.buf_queue      = buffer_queue,
-	.buf_release    = buffer_release,
+static struct videobuf_queue_ops sp2518_video_vmall_qops = {
+    .buf_setup      = vmall_buffer_setup,
+    .buf_prepare    = vmall_buffer_prepare,
+    .buf_queue      = vmall_buffer_queue,
+    .buf_release    = vmall_buffer_release,
+};
+
+static struct videobuf_queue_ops sp2518_video_res_qops = {
+    .buf_setup      = res_buffer_setup,
+    .buf_prepare    = res_buffer_prepare,
+    .buf_queue      = res_buffer_queue,
+    .buf_release    = res_buffer_release,
 };
 
 /* ------------------------------------------------------------------
-	IOCTL vidioc handling
+    IOCTL vidioc handling
    ------------------------------------------------------------------*/
 static int vidioc_querycap(struct file *file, void  *priv,
-					struct v4l2_capability *cap)
-{
-	struct sp2518_fh  *fh  = priv;
-	struct sp2518_device *dev = fh->dev;
-
-	strcpy(cap->driver, "sp2518");
-	strcpy(cap->card, "sp2518.canvas");
-	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
-	cap->version = SP2518_CAMERA_VERSION;
-	cap->capabilities =	V4L2_CAP_VIDEO_CAPTURE |
-				V4L2_CAP_STREAMING     |
-				V4L2_CAP_READWRITE;
-	return 0;
+                    struct v4l2_capability *cap)
+{
+    struct sp2518_fh  *fh  = priv;
+    struct sp2518_device *dev = fh->dev;
+
+    strcpy(cap->driver, "sp2518");
+    strcpy(cap->card, "sp2518.canvas");
+    strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+    cap->version = SP2518_CAMERA_VERSION;
+    cap->capabilities = V4L2_CAP_VIDEO_CAPTURE |
+                V4L2_CAP_STREAMING     |
+                V4L2_CAP_READWRITE;
+    return 0;
 }
 
 static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
-					struct v4l2_fmtdesc *f)
+                    struct v4l2_fmtdesc *f)
 {
-	struct sp2518_fmt *fmt;
+    struct sp2518_fmt *fmt;
 
-	if (f->index >= ARRAY_SIZE(formats))
-		return -EINVAL;
+    if (f->index >= ARRAY_SIZE(formats))
+        return -EINVAL;
 
-	fmt = &formats[f->index];
+    fmt = &formats[f->index];
 
-	strlcpy(f->description, fmt->name, sizeof(f->description));
-	f->pixelformat = fmt->fourcc;
-	return 0;
+    strlcpy(f->description, fmt->name, sizeof(f->description));
+    f->pixelformat = fmt->fourcc;
+    return 0;
 }
 static int vidioc_enum_frameintervals(struct file *file, void *priv,
         struct v4l2_frmivalenum *fival)
 {
     unsigned int k;
 
-    if(fival->index > ARRAY_SIZE(sp2518_frmivalenum))
+    if (fival->index > ARRAY_SIZE(sp2518_frmivalenum))
         return -EINVAL;
 
-    for(k =0; k< ARRAY_SIZE(sp2518_frmivalenum); k++)
+    for (k = 0; k < ARRAY_SIZE(sp2518_frmivalenum); k++)
     {
-        if( (fival->index==sp2518_frmivalenum[k].index)&&
-                (fival->pixel_format ==sp2518_frmivalenum[k].pixel_format )&&
-                (fival->width==sp2518_frmivalenum[k].width)&&
-                (fival->height==sp2518_frmivalenum[k].height)){
+        if ((fival->index == sp2518_frmivalenum[k].index) &&
+                (fival->pixel_format == sp2518_frmivalenum[k].pixel_format) &&
+                (fival->width == sp2518_frmivalenum[k].width) &&
+                (fival->height == sp2518_frmivalenum[k].height)) {
             memcpy( fival, &sp2518_frmivalenum[k], sizeof(struct v4l2_frmivalenum));
             return 0;
         }
@@ -2209,108 +2381,108 @@ static int vidioc_enum_frameintervals(struct file *file, void *priv,
 }
 
 static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
-					struct v4l2_format *f)
+                    struct v4l2_format *f)
 {
-	struct sp2518_fh *fh = priv;
+    struct sp2518_fh *fh = priv;
 
-	f->fmt.pix.width        = fh->width;
-	f->fmt.pix.height       = fh->height;
-	f->fmt.pix.field        = fh->vb_vidq.field;
-	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
-	f->fmt.pix.bytesperline =
-		(f->fmt.pix.width * fh->fmt->depth) >> 3;
-	f->fmt.pix.sizeimage =
-		f->fmt.pix.height * f->fmt.pix.bytesperline;
+    f->fmt.pix.width        = fh->width;
+    f->fmt.pix.height       = fh->height;
+    f->fmt.pix.field        = fh->vb_vidq.field;
+    f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+    f->fmt.pix.bytesperline =
+        (f->fmt.pix.width * fh->fmt->depth) >> 3;
+    f->fmt.pix.sizeimage =
+        f->fmt.pix.height * f->fmt.pix.bytesperline;
 
-	return (0);
+    return (0);
 }
 
 static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
-			struct v4l2_format *f)
-{
-	struct sp2518_fh  *fh  = priv;
-	struct sp2518_device *dev = fh->dev;
-	struct sp2518_fmt *fmt;
-	enum v4l2_field field;
-	unsigned int maxw, maxh;
-
-	fmt = get_format(f);
-	if (!fmt) {
-		dprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",
-			f->fmt.pix.pixelformat);
-		return -EINVAL;
-	}
-
-	field = f->fmt.pix.field;
-
-	if (field == V4L2_FIELD_ANY) {
-		field = V4L2_FIELD_INTERLACED;
-	} else if (V4L2_FIELD_INTERLACED != field) {
-		dprintk(dev, 1, "Field type invalid.\n");
-		return -EINVAL;
-	}
-
-	maxw  = norm_maxw();
-	maxh  = norm_maxh();
-
-	f->fmt.pix.field = field;
-	v4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,
-			      &f->fmt.pix.height, 32, maxh, 0, 0);
-	f->fmt.pix.bytesperline =
-		(f->fmt.pix.width * fmt->depth) >> 3;
-	f->fmt.pix.sizeimage =
-		f->fmt.pix.height * f->fmt.pix.bytesperline;
-
-	return 0;
+            struct v4l2_format *f)
+{
+    struct sp2518_fh  *fh  = priv;
+    struct sp2518_device *dev = fh->dev;
+    struct sp2518_fmt *fmt;
+    enum v4l2_field field;
+    unsigned int maxw, maxh;
+
+    fmt = get_format(f);
+    if (!fmt) {
+        dprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",
+            f->fmt.pix.pixelformat);
+        return -EINVAL;
+    }
+
+    field = f->fmt.pix.field;
+
+    if (field == V4L2_FIELD_ANY) {
+        field = V4L2_FIELD_INTERLACED;
+    } else if (V4L2_FIELD_INTERLACED != field) {
+        dprintk(dev, 1, "Field type invalid.\n");
+        return -EINVAL;
+    }
+
+    maxw  = norm_maxw();
+    maxh  = norm_maxh();
+
+    f->fmt.pix.field = field;
+    v4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,
+                  &f->fmt.pix.height, 32, maxh, 0, 0);
+    f->fmt.pix.bytesperline =
+        (f->fmt.pix.width * fmt->depth) >> 3;
+    f->fmt.pix.sizeimage =
+        f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+    return 0;
 }
 
 /*FIXME: This seems to be generic enough to be at videodev2 */
 static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
-					struct v4l2_format *f)
-{
-	struct sp2518_fh *fh = priv;
-	struct videobuf_queue *q = &fh->vb_vidq;
-	struct sp2518_device *dev = fh->dev;
-	int ret;
-
-	f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN-1) ) & (~(CANVAS_WIDTH_ALIGN-1));
-	if ((f->fmt.pix.pixelformat==V4L2_PIX_FMT_YVU420) ||
-			(f->fmt.pix.pixelformat==V4L2_PIX_FMT_YUV420)){
-		f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN*2-1) ) & (~(CANVAS_WIDTH_ALIGN*2-1));
-	}
-
-	ret = vidioc_try_fmt_vid_cap(file, fh, f);
-	if (ret < 0)
-		return ret;
-
-	mutex_lock(&q->vb_lock);
-
-	if (videobuf_queue_is_busy(&fh->vb_vidq)) {
-		dprintk(fh->dev, 1, "%s queue busy\n", __func__);
-		ret = -EBUSY;
-		goto out;
-	}
-
-	fh->fmt           = get_format(f);
-	fh->width         = f->fmt.pix.width;
-	fh->height        = f->fmt.pix.height;
-	fh->vb_vidq.field = f->fmt.pix.field;
-	fh->type          = f->type;
-	#if 1
-	set_flip(dev);
-	if(f->fmt.pix.pixelformat==V4L2_PIX_FMT_RGB24){
-		vidio_set_fmt_ticks=1;
-		SP2518_set_resolution(dev,fh->height,fh->width);
-		}
-	else if(vidio_set_fmt_ticks==1){
-		SP2518_set_resolution(dev,fh->height,fh->width);
-		}
-	#endif
-	ret = 0;
+                    struct v4l2_format *f)
+{
+    struct sp2518_fh *fh = priv;
+    struct videobuf_queue *q = &fh->vb_vidq;
+    struct sp2518_device *dev = fh->dev;
+    int ret;
+
+    f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN-1) ) & (~(CANVAS_WIDTH_ALIGN-1));
+    if ((f->fmt.pix.pixelformat == V4L2_PIX_FMT_YVU420) ||
+            (f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUV420)) {
+        f->fmt.pix.width = (f->fmt.pix.width + (CANVAS_WIDTH_ALIGN*2-1) ) & (~(CANVAS_WIDTH_ALIGN*2-1));
+    }
+
+    ret = vidioc_try_fmt_vid_cap(file, fh, f);
+    if (ret < 0)
+        return ret;
+
+    mutex_lock(&q->vb_lock);
+
+    if (videobuf_queue_is_busy(&fh->vb_vidq)) {
+        dprintk(fh->dev, 1, "%s queue busy\n", __func__);
+        ret = -EBUSY;
+        goto out;
+    }
+
+    fh->fmt           = get_format(f);
+    fh->width         = f->fmt.pix.width;
+    fh->height        = f->fmt.pix.height;
+    fh->vb_vidq.field = f->fmt.pix.field;
+    fh->type          = f->type;
+    #if 1
+    set_flip(dev);
+    if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {
+        vidio_set_fmt_ticks = 1;
+        SP2518_set_resolution(dev,fh->height,fh->width);
+        }
+    else if (vidio_set_fmt_ticks == 1) {
+        SP2518_set_resolution(dev,fh->height,fh->width);
+        }
+    #endif
+    ret = 0;
 out:
-	mutex_unlock(&q->vb_lock);
+    mutex_unlock(&q->vb_lock);
 
-	return ret;
+    return ret;
 }
 
 static int vidioc_g_parm(struct file *file, void *priv,
@@ -2336,297 +2508,303 @@ static int vidioc_g_parm(struct file *file, void *priv,
 
 
 static int vidioc_reqbufs(struct file *file, void *priv,
-			  struct v4l2_requestbuffers *p)
+              struct v4l2_requestbuffers *p)
 {
-	struct sp2518_fh  *fh = priv;
+    struct sp2518_fh  *fh = priv;
 
-	return (videobuf_reqbufs(&fh->vb_vidq, p));
+    return (videobuf_reqbufs(&fh->vb_vidq, p));
 }
 
 static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
 {
-	struct sp2518_fh  *fh = priv;
+    struct sp2518_fh  *fh = priv;
 
         int ret = videobuf_querybuf(&fh->vb_vidq, p);
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	if(ret == 0){
-		p->reserved  = convert_canvas_index(fh->fmt->fourcc, CAMERA_USER_CANVAS_INDEX + p->index*3);
-	}else{
-		p->reserved = 0;
-	}
+    if (ret == 0) {
+        p->reserved  = convert_canvas_index(fh->fmt->fourcc, CAMERA_USER_CANVAS_INDEX + p->index * 3);
+    }else{
+        p->reserved = 0;
+    }
 #endif
-	return ret;
+    return ret;
 }
 
 static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
 {
-	struct sp2518_fh *fh = priv;
+    struct sp2518_fh *fh = priv;
 
-	return (videobuf_qbuf(&fh->vb_vidq, p));
+    return (videobuf_qbuf(&fh->vb_vidq, p));
 }
 
 static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
 {
-	struct sp2518_fh  *fh = priv;
+    struct sp2518_fh  *fh = priv;
 
-	return (videobuf_dqbuf(&fh->vb_vidq, p,
-				file->f_flags & O_NONBLOCK));
+    return (videobuf_dqbuf(&fh->vb_vidq, p,
+                file->f_flags & O_NONBLOCK));
 }
 
 #ifdef CONFIG_VIDEO_V4L1_COMPAT
 static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
 {
-	struct sp2518_fh  *fh = priv;
+    struct sp2518_fh  *fh = priv;
 
-	return videobuf_cgmbuf(&fh->vb_vidq, mbuf, 8);
+    return videobuf_cgmbuf(&fh->vb_vidq, mbuf, 8);
 }
 #endif
 
 static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
 {
-	struct sp2518_fh  *fh = priv;
-	vdin_parm_t para;
+    struct sp2518_fh  *fh = priv;
+    vdin_parm_t para;
         int ret = 0 ;
-	printk(KERN_INFO " vidioc_streamon+++ \n ");	
-	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-	if (i != fh->type)
-		return -EINVAL;
-
-	memset( &para, 0, sizeof( para ));
-	para.port  = TVIN_PORT_CAMERA;
-	para.fmt = TVIN_SIG_FMT_MAX;
-	para.frame_rate = sp2518_frmintervals_active.denominator;
-	para.h_active = sp2518_h_active;
-	para.v_active = sp2518_v_active;
-	para.hsync_phase = 0;
-	para.vsync_phase = 1;
-	para.hs_bp = 0;
-	para.vs_bp = 24;
-	para.cfmt = TVIN_YUV422;
+    printk(KERN_INFO " vidioc_streamon+++ \n ");
+    if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+        return -EINVAL;
+    if (i != fh->type)
+        return -EINVAL;
+
+    memset( &para, 0, sizeof( para ));
+    para.port  = TVIN_PORT_CAMERA;
+    para.fmt = TVIN_SIG_FMT_MAX;
+    para.frame_rate = sp2518_frmintervals_active.denominator;
+    para.h_active = sp2518_h_active;
+    para.v_active = sp2518_v_active;
+    para.hsync_phase = 0;
+    para.vsync_phase = 1;
+    para.hs_bp = 0;
+    para.vs_bp = 24;
+    para.cfmt = TVIN_YUV422;
         para.dfmt = TVIN_YUV422;
-	para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;	
-	para.skip_count =  2; //skip_num
+    para.scan_mode = TVIN_SCAN_MODE_PROGRESSIVE;
 
-	ret =  videobuf_streamon(&fh->vb_vidq);
-	if(ret == 0){
+    if (is_first_time_open == 0) {
+        para.skip_count =  2;//2; //skip_num
+        is_first_time_open = 1;
+    } else {
+        para.skip_count =  0;
+    }
+
+    ret =  videobuf_streamon(&fh->vb_vidq);
+    if (ret == 0) {
+        if (fh->dev->vminfo.isused) {
             vops->start_tvin_service(0,&para);
-            fh->stream_on        = 1;
-	}
-	return ret;
+        }
+        fh->stream_on        = 1;
+    }
+    return ret;
 }
 
 static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
 {
-	struct sp2518_fh  *fh = priv;
+    struct sp2518_fh  *fh = priv;
 
        int ret = 0 ;
-	printk(KERN_INFO " vidioc_streamoff+++ \n ");
-	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-	if (i != fh->type)
-		return -EINVAL;
-	ret = videobuf_streamoff(&fh->vb_vidq);
-	if(ret == 0 ){
+    printk(KERN_INFO " vidioc_streamoff+++ \n ");
+    if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+        return -EINVAL;
+    if (i != fh->type)
+        return -EINVAL;
+    ret = videobuf_streamoff(&fh->vb_vidq);
+    if (ret == 0) {
+        if (fh->dev->vminfo.isused) {
             vops->stop_tvin_service(0);
-            fh->stream_on        = 0;
-	}
-	return ret;
+        }
+        fh->stream_on        = 0;
+    }
+    return ret;
 }
 
 static int vidioc_enum_framesizes(struct file *file, void *fh,struct v4l2_frmsizeenum *fsize)
 {
-	int ret = 0,i=0;
-	struct sp2518_fmt *fmt = NULL;
-	struct v4l2_frmsize_discrete *frmsize = NULL;
-	for (i = 0; i < ARRAY_SIZE(formats); i++) {
-		if (formats[i].fourcc == fsize->pixel_format){
-			fmt = &formats[i];
-			break;
-		}
-	}
-	if (fmt == NULL)
-		return -EINVAL;
-	if ((fmt->fourcc == V4L2_PIX_FMT_NV21)
-		||(fmt->fourcc == V4L2_PIX_FMT_NV12)
-		||(fmt->fourcc == V4L2_PIX_FMT_YVU420)
-		||(fmt->fourcc == V4L2_PIX_FMT_YUV420))
-	{
-		if (fsize->index >= ARRAY_SIZE(sp2518_prev_resolution))
-			return -EINVAL;
-		frmsize = &sp2518_prev_resolution[fsize->index];
-		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-		fsize->discrete.width = frmsize->width;
-		fsize->discrete.height = frmsize->height;
-	}
-	else if(fmt->fourcc == V4L2_PIX_FMT_RGB24){
-		if (fsize->index >= ARRAY_SIZE(sp2518_pic_resolution))
-			return -EINVAL;
-		frmsize = &sp2518_pic_resolution[fsize->index];
-		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-		fsize->discrete.width = frmsize->width;
-		fsize->discrete.height = frmsize->height;
-	}
-	return ret;
+    int ret = 0,i=0;
+    struct sp2518_fmt *fmt = NULL;
+    struct v4l2_frmsize_discrete *frmsize = NULL;
+    for (i = 0; i < ARRAY_SIZE(formats); i++) {
+        if (formats[i].fourcc == fsize->pixel_format) {
+            fmt = &formats[i];
+            break;
+        }
+    }
+    if (fmt == NULL)
+        return -EINVAL;
+    if ((fmt->fourcc == V4L2_PIX_FMT_NV21)
+        || (fmt->fourcc == V4L2_PIX_FMT_NV12)
+        || (fmt->fourcc == V4L2_PIX_FMT_YVU420)
+        || (fmt->fourcc == V4L2_PIX_FMT_YUV420))
+    {
+        if (fsize->index >= ARRAY_SIZE(sp2518_prev_resolution))
+            return -EINVAL;
+        frmsize = &sp2518_prev_resolution[fsize->index];
+        fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+        fsize->discrete.width = frmsize->width;
+        fsize->discrete.height = frmsize->height;
+    }
+    else if (fmt->fourcc == V4L2_PIX_FMT_RGB24) {
+        if (fsize->index >= ARRAY_SIZE(sp2518_pic_resolution))
+            return -EINVAL;
+        frmsize = &sp2518_pic_resolution[fsize->index];
+        fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+        fsize->discrete.width = frmsize->width;
+        fsize->discrete.height = frmsize->height;
+    }
+    return ret;
 }
 
 static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)
 {
-	return 0;
+    return 0;
 }
 
 /* only one input in this sample driver */
 static int vidioc_enum_input(struct file *file, void *priv,
-				struct v4l2_input *inp)
+                struct v4l2_input *inp)
 {
-	//if (inp->index >= NUM_INPUTS)
-		//return -EINVAL;
+    //if  (inp->index >= NUM_INPUTS)
+        //return -EINVAL;
 
-	inp->type = V4L2_INPUT_TYPE_CAMERA;
-	inp->std = V4L2_STD_525_60;
-	sprintf(inp->name, "Camera %u", inp->index);
+    inp->type = V4L2_INPUT_TYPE_CAMERA;
+    inp->std = V4L2_STD_525_60;
+    sprintf(inp->name, "Camera %u", inp->index);
 
-	return (0);
+    return (0);
 }
 
 static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
 {
-	struct sp2518_fh *fh = priv;
-	struct sp2518_device *dev = fh->dev;
+    struct sp2518_fh *fh = priv;
+    struct sp2518_device *dev = fh->dev;
 
-	*i = dev->input;
+    *i = dev->input;
 
-	return (0);
+    return (0);
 }
 
 static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
 {
-	struct sp2518_fh *fh = priv;
-	struct sp2518_device *dev = fh->dev;
+    struct sp2518_fh *fh = priv;
+    struct sp2518_device *dev = fh->dev;
 
-	//if (i >= NUM_INPUTS)
-		//return -EINVAL;
+    //if  (i >= NUM_INPUTS)
+        //return -EINVAL;
 
-	dev->input = i;
-	//precalculate_bars(fh);
+    dev->input = i;
+    //precalculate_bars(fh);
 
-	return (0);
+    return (0);
 }
 
-	/* --- controls ---------------------------------------------- */
+    /* --- controls ---------------------------------------------- */
 static int vidioc_queryctrl(struct file *file, void *priv,
-			    struct v4l2_queryctrl *qc)
+                struct v4l2_queryctrl *qc)
 {
-	int i;
+    int i;
 
-	for (i = 0; i < ARRAY_SIZE(sp2518_qctrl); i++)
-		if (qc->id && qc->id == sp2518_qctrl[i].id) {
-			memcpy(qc, &(sp2518_qctrl[i]),
-				sizeof(*qc));
-			return (0);
-		}
+    for (i = 0; i < ARRAY_SIZE(sp2518_qctrl); i++)
+        if (qc->id && qc->id == sp2518_qctrl[i].id) {
+            memcpy(qc, &(sp2518_qctrl[i]),
+                sizeof(*qc));
+            return (0);
+        }
 
-	return -EINVAL;
+    return -EINVAL;
 }
 
 static int vidioc_g_ctrl(struct file *file, void *priv,
-			 struct v4l2_control *ctrl)
+             struct v4l2_control *ctrl)
 {
-	struct sp2518_fh *fh = priv;
-	struct sp2518_device *dev = fh->dev;
-	int i;
+    struct sp2518_fh *fh = priv;
+    struct sp2518_device *dev = fh->dev;
+    int i;
 
-	for (i = 0; i < ARRAY_SIZE(sp2518_qctrl); i++)
-		if (ctrl->id == sp2518_qctrl[i].id) {
-			ctrl->value = dev->qctl_regs[i];
-			return 0;
-		}
+    for (i = 0; i < ARRAY_SIZE(sp2518_qctrl); i++)
+        if (ctrl->id == sp2518_qctrl[i].id) {
+            ctrl->value = dev->qctl_regs[i];
+            return 0;
+        }
 
-	return -EINVAL;
+    return -EINVAL;
 }
 
 static int vidioc_s_ctrl(struct file *file, void *priv,
-				struct v4l2_control *ctrl)
-{
-	struct sp2518_fh *fh = priv;
-	struct sp2518_device *dev = fh->dev;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(sp2518_qctrl); i++)
-		if (ctrl->id == sp2518_qctrl[i].id) {
-			if (ctrl->value < sp2518_qctrl[i].minimum ||
-			    ctrl->value > sp2518_qctrl[i].maximum ||
-			    sp2518_setting(dev,ctrl->id,ctrl->value)<0) {
-				return -ERANGE;
-			}
-			dev->qctl_regs[i] = ctrl->value;
-			return 0;
-		}
-	return -EINVAL;
+                struct v4l2_control *ctrl)
+{
+    struct sp2518_fh *fh = priv;
+    struct sp2518_device *dev = fh->dev;
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(sp2518_qctrl); i++)
+        if (ctrl->id == sp2518_qctrl[i].id) {
+            if (ctrl->value < sp2518_qctrl[i].minimum ||
+                ctrl->value > sp2518_qctrl[i].maximum ||
+                sp2518_setting(dev,ctrl->id,ctrl->value)<0) {
+                return -ERANGE;
+            }
+            dev->qctl_regs[i] = ctrl->value;
+            return 0;
+        }
+    return -EINVAL;
 }
 
 /* ------------------------------------------------------------------
-	File operations for the device
+    File operations for the device
    ------------------------------------------------------------------*/
 
 static int sp2518_open(struct file *file)
 {
-	struct sp2518_device *dev = video_drvdata(file);
-	struct sp2518_fh *fh = NULL;
-	int retval = 0;
-	resource_size_t mem_start = 0;
-	unsigned int mem_size = 0;
+    struct sp2518_device *dev = video_drvdata(file);
+    struct sp2518_fh *fh = NULL;
+    int retval = 0;
 #if CONFIG_CMA
-    retval = vm_init_buf(16*SZ_1M);
-    if(retval <0)
-        return -1;
+    vm_init_resource(16*SZ_1M, &dev->vminfo);
 #endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	switch_mod_gate_by_name("ge2d", 1);
-#endif		
-
-	aml_cam_init(&dev->cam_info);
-	SP2518_init_regs(dev);
-	msleep(40);
-	mutex_lock(&dev->mutex);
-	dev->users++;
-	if (dev->users > 1) {
-		dev->users--;
-		mutex_unlock(&dev->mutex);
-		return -EBUSY;
-	}
-
-	dprintk(dev, 1, "open %s type=%s users=%d\n",
-		video_device_node_name(dev->vdev),
-		v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
-
-    	/* init video dma queues */
-	INIT_LIST_HEAD(&dev->vidq.active);
-	init_waitqueue_head(&dev->vidq.wq);
+    switch_mod_gate_by_name("ge2d", 1);
+#endif
+
+    aml_cam_init(&dev->cam_info);
+    SP2518_init_regs(dev);
+    msleep(40);
+    mutex_lock(&dev->mutex);
+    dev->users++;
+    if (dev->users > 1) {
+        dev->users--;
+        mutex_unlock(&dev->mutex);
+        return -EBUSY;
+    }
+
+    dprintk(dev, 1, "open %s type=%s users=%d\n",
+        video_device_node_name(dev->vdev),
+        v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
+
+        /* init video dma queues */
+    INIT_LIST_HEAD(&dev->vidq.active);
+    init_waitqueue_head(&dev->vidq.wq);
     spin_lock_init(&dev->slock);
-	/* allocate + initialize per filehandle data */
-	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
-	if (NULL == fh) {
-		dev->users--;
-		retval = -ENOMEM;
-	}
-	mutex_unlock(&dev->mutex);
-
-	if (retval)
-		return retval;
-
-	wake_lock(&(dev->wake_lock));
-	file->private_data = fh;
-	fh->dev      = dev;
-
-	fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	fh->fmt      = &formats[0];
-	fh->width    = 1600;//640//zyy
-	fh->height   = 1198;//1200;//480
-	fh->stream_on = 0 ;
-	fh->f_flags  = file->f_flags;
-	/* Resets frame counters */
-	dev->jiffies = jiffies;
+    /* allocate + initialize per filehandle data */
+    fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+    if (NULL == fh) {
+        dev->users--;
+        retval = -ENOMEM;
+    }
+    mutex_unlock(&dev->mutex);
+
+    if (retval)
+        return retval;
+
+    wake_lock(&(dev->wake_lock));
+    file->private_data = fh;
+    fh->dev      = dev;
+
+    fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    fh->fmt      = &formats[0];
+    fh->width    = 1600;//640//zyy
+    fh->height   = 1198;//1200;//480
+    fh->stream_on = 0 ;
+    fh->f_flags  = file->f_flags;
+    /* Resets frame counters */
+    dev->jiffies = jiffies;
 
 //    TVIN_SIG_FMT_CAMERA_640X480P_30Hz,
 //    TVIN_SIG_FMT_CAMERA_800X600P_30Hz,
@@ -2634,249 +2812,256 @@ static int sp2518_open(struct file *file)
 //    TVIN_SIG_FMT_CAMERA_1920X1080P_30Hz,
 //    TVIN_SIG_FMT_CAMERA_1280X720P_30Hz,
 
-	get_vm_buf_info(&mem_start, &mem_size, NULL);
-	fh->res.start = mem_start;
-	fh->res.end = mem_start+mem_size-1;
-	fh->res.magic = MAGIC_RE_MEM;
-	fh->res.priv = NULL;
-	videobuf_queue_res_init(&fh->vb_vidq, &sp2518_video_qops,
-			NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
-	sizeof(struct sp2518_buffer), (void*)&fh->res, NULL);
-
-	sp2518_start_thread(fh);
-	sp2518_have_open = 1;
-	return 0;
+    if (dev->vminfo.mem_alloc_succeed) {
+        fh->res.start = dev->vminfo.buffer_start;
+        fh->res.end = dev->vminfo.buffer_start + dev->vminfo.vm_buf_size - 1;
+        fh->res.magic = MAGIC_RE_MEM;
+        fh->res.priv = NULL;
+        videobuf_queue_res_init(&fh->vb_vidq, &sp2518_video_res_qops,
+                NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
+        sizeof(struct sp2518_buffer), (void*)&fh->res, NULL);
+    } else {
+        videobuf_queue_vmalloc_init(&fh->vb_vidq, &sp2518_video_vmall_qops,
+        NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
+        sizeof(struct sp2518_buffer), fh, NULL);
+    }
+
+    sp2518_start_thread(fh);
+    sp2518_have_open = 1;
+    return 0;
 }
 
 static ssize_t
 sp2518_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
 {
-	struct sp2518_fh *fh = file->private_data;
+    struct sp2518_fh *fh = file->private_data;
 
-	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		return videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,
-					file->f_flags & O_NONBLOCK);
-	}
-	return 0;
+    if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+        return videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,
+                    file->f_flags & O_NONBLOCK);
+    }
+    return 0;
 }
 
 static unsigned int
 sp2518_poll(struct file *file, struct poll_table_struct *wait)
 {
-	struct sp2518_fh        *fh = file->private_data;
-	struct sp2518_device       *dev = fh->dev;
-	struct videobuf_queue *q = &fh->vb_vidq;
+    struct sp2518_fh        *fh = file->private_data;
+    struct sp2518_device       *dev = fh->dev;
+    struct videobuf_queue *q = &fh->vb_vidq;
 
-	dprintk(dev, 1, "%s\n", __func__);
+    dprintk(dev, 1, "%s\n", __func__);
 
-	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)
-		return POLLERR;
+    if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)
+        return POLLERR;
 
-	return videobuf_poll_stream(file, q, wait);
+    return videobuf_poll_stream(file, q, wait);
 }
 
 static int sp2518_close(struct file *file)
 {
-	struct sp2518_fh         *fh = file->private_data;
-	struct sp2518_device *dev       = fh->dev;
-	struct sp2518_dmaqueue *vidq = &dev->vidq;
-	struct video_device  *vdev = video_devdata(file);
-	sp2518_have_open = 0;
-	sp2518_stop_thread(vidq);
-	videobuf_stop(&fh->vb_vidq);
-	if(fh->stream_on){
+    struct sp2518_fh         *fh = file->private_data;
+    struct sp2518_device *dev       = fh->dev;
+    struct sp2518_dmaqueue *vidq = &dev->vidq;
+    struct video_device  *vdev = video_devdata(file);
+    sp2518_have_open = 0;
+    is_first_time_open = 0;
+    sp2518_stop_thread(vidq);
+    videobuf_stop(&fh->vb_vidq);
+    if (fh->stream_on) {
+        if (dev->vminfo.isused) {
             vops->stop_tvin_service(0);
-	}
-	videobuf_mmap_free(&fh->vb_vidq);
-
-	kfree(fh);
+        }
+    }
+    videobuf_mmap_free(&fh->vb_vidq);
+    kfree(fh);
 
-	mutex_lock(&dev->mutex);
-	dev->users--;
-	mutex_unlock(&dev->mutex);
+    mutex_lock(&dev->mutex);
+    dev->users--;
+    mutex_unlock(&dev->mutex);
 
-	dprintk(dev, 1, "close called (dev=%s, users=%d)\n",
-		video_device_node_name(vdev), dev->users);
+    dprintk(dev, 1, "close called (dev=%s, users=%d)\n",
+        video_device_node_name(vdev), dev->users);
 #if 1
-	sp2518_h_active=1568;//800//zyy
-	sp2518_v_active=1176;//1200;//600
-	sp2518_qctrl[0].default_value=0;
-	sp2518_qctrl[1].default_value=4;
-	sp2518_qctrl[2].default_value=0;
-	sp2518_qctrl[3].default_value=0;
-	sp2518_qctrl[4].default_value=0;
-
-	sp2518_qctrl[5].default_value=0;
-	sp2518_qctrl[7].default_value=100;
-	sp2518_qctrl[8].default_value=0;
-	sp2518_frmintervals_active.numerator = 1;
-	sp2518_frmintervals_active.denominator = 15;
-	power_down_sp2518(dev);
+    sp2518_h_active=1568;//800//zyy
+    sp2518_v_active=1176;//1200;//600
+    sp2518_qctrl[0].default_value=0;
+    sp2518_qctrl[1].default_value=4;
+    sp2518_qctrl[2].default_value=0;
+    sp2518_qctrl[3].default_value=0;
+    sp2518_qctrl[4].default_value=0;
+
+    sp2518_qctrl[5].default_value=0;
+    sp2518_qctrl[7].default_value=100;
+    sp2518_qctrl[8].default_value=0;
+    sp2518_frmintervals_active.numerator = 1;
+    sp2518_frmintervals_active.denominator = 15;
+    power_down_sp2518(dev);
 #endif
        aml_cam_uninit(&dev->cam_info);
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	switch_mod_gate_by_name("ge2d", 0);
-#endif		
-	wake_unlock(&(dev->wake_lock));
+    switch_mod_gate_by_name("ge2d", 0);
+#endif
+    wake_unlock(&(dev->wake_lock));
 #ifdef CONFIG_CMA
-    vm_deinit_buf();
+    vm_deinit_resource(&dev->vminfo);
 #endif
-	return 0;
+    return 0;
 }
 
 static int sp2518_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct sp2518_fh  *fh = file->private_data;
-	struct sp2518_device *dev = fh->dev;
-	int ret;
+    struct sp2518_fh  *fh = file->private_data;
+    struct sp2518_device *dev = fh->dev;
+    int ret;
 
-	dprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
+    dprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
 
-	ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
+    ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
 
-	dprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",
-		(unsigned long)vma->vm_start,
-		(unsigned long)vma->vm_end-(unsigned long)vma->vm_start,
-		ret);
+    dprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",
+        (unsigned long)vma->vm_start,
+        (unsigned long)vma->vm_end-(unsigned long)vma->vm_start,
+        ret);
 
-	return ret;
+    return ret;
 }
 
 static const struct v4l2_file_operations sp2518_fops = {
-	.owner		= THIS_MODULE,
-	.open           = sp2518_open,
-	.release        = sp2518_close,
-	.read           = sp2518_read,
-	.poll		= sp2518_poll,
-	.ioctl          = video_ioctl2, /* V4L2 ioctl handler */
-	.mmap           = sp2518_mmap,
+    .owner      = THIS_MODULE,
+    .open           = sp2518_open,
+    .release        = sp2518_close,
+    .read           = sp2518_read,
+    .poll       = sp2518_poll,
+    .ioctl          = video_ioctl2, /* V4L2 ioctl handler */
+    .mmap           = sp2518_mmap,
 };
 
 static const struct v4l2_ioctl_ops sp2518_ioctl_ops = {
-	.vidioc_querycap      = vidioc_querycap,
-	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
-	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
-	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
-	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
-	.vidioc_reqbufs       = vidioc_reqbufs,
-	.vidioc_querybuf      = vidioc_querybuf,
-	.vidioc_qbuf          = vidioc_qbuf,
-	.vidioc_dqbuf         = vidioc_dqbuf,
-	.vidioc_s_std         = vidioc_s_std,
-	.vidioc_enum_input    = vidioc_enum_input,
-	.vidioc_g_input       = vidioc_g_input,
-	.vidioc_s_input       = vidioc_s_input,
-	.vidioc_queryctrl     = vidioc_queryctrl,
-	.vidioc_querymenu     = vidioc_querymenu,
-	.vidioc_g_ctrl        = vidioc_g_ctrl,
-	.vidioc_s_ctrl        = vidioc_s_ctrl,
-	.vidioc_streamon      = vidioc_streamon,
-	.vidioc_streamoff     = vidioc_streamoff,
-	.vidioc_enum_framesizes = vidioc_enum_framesizes,
-	.vidioc_g_parm = vidioc_g_parm,
-	.vidioc_enum_frameintervals = vidioc_enum_frameintervals,
+    .vidioc_querycap      = vidioc_querycap,
+    .vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+    .vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+    .vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+    .vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+    .vidioc_reqbufs       = vidioc_reqbufs,
+    .vidioc_querybuf      = vidioc_querybuf,
+    .vidioc_qbuf          = vidioc_qbuf,
+    .vidioc_dqbuf         = vidioc_dqbuf,
+    .vidioc_s_std         = vidioc_s_std,
+    .vidioc_enum_input    = vidioc_enum_input,
+    .vidioc_g_input       = vidioc_g_input,
+    .vidioc_s_input       = vidioc_s_input,
+    .vidioc_queryctrl     = vidioc_queryctrl,
+    .vidioc_querymenu     = vidioc_querymenu,
+    .vidioc_g_ctrl        = vidioc_g_ctrl,
+    .vidioc_s_ctrl        = vidioc_s_ctrl,
+    .vidioc_streamon      = vidioc_streamon,
+    .vidioc_streamoff     = vidioc_streamoff,
+    .vidioc_enum_framesizes = vidioc_enum_framesizes,
+    .vidioc_g_parm = vidioc_g_parm,
+    .vidioc_enum_frameintervals = vidioc_enum_frameintervals,
 #ifdef CONFIG_VIDEO_V4L1_COMPAT
-	.vidiocgmbuf          = vidiocgmbuf,
+    .vidiocgmbuf          = vidiocgmbuf,
 #endif
 };
 
 static struct video_device sp2518_template = {
-	.name		= "sp2518_v4l",
-	.fops           = &sp2518_fops,
-	.ioctl_ops 	= &sp2518_ioctl_ops,
-	.release	= video_device_release,
+    .name       = "sp2518_v4l",
+    .fops           = &sp2518_fops,
+    .ioctl_ops  = &sp2518_ioctl_ops,
+    .release    = video_device_release,
 
-	.tvnorms              = V4L2_STD_525_60,
-	.current_norm         = V4L2_STD_NTSC_M,
+    .tvnorms              = V4L2_STD_525_60,
+    .current_norm         = V4L2_STD_NTSC_M,
 };
 
 static int sp2518_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
-	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SP2518, 0);
+    return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SP2518, 0);
 }
 
 static const struct v4l2_subdev_core_ops sp2518_core_ops = {
-	.g_chip_ident = sp2518_g_chip_ident,
+    .g_chip_ident = sp2518_g_chip_ident,
 };
 
 static const struct v4l2_subdev_ops sp2518_ops = {
-	.core = &sp2518_core_ops,
+    .core = &sp2518_core_ops,
 };
 
 static ssize_t sp2518_show(struct device *dev, struct device_attribute *attr, char *_buf)
 {
-	return sprintf(_buf, "0x%02x=0x%02x\n", cur_reg, cur_val);
+    return sprintf(_buf, "0x%02x=0x%02x\n", cur_reg, cur_val);
 }
 
 static u32 strtol(const char *nptr, int base)
 {
-	u32 ret;
-	if(!nptr || (base!=16 && base!=10 && base!=8))
-	{
-		printk("%s(): NULL pointer input\n", __FUNCTION__);
-		return -1;
-	}
-	for(ret=0; *nptr; nptr++)
-	{
-		if((base==16 && *nptr>='A' && *nptr<='F') || 
-			(base==16 && *nptr>='a' && *nptr<='f') || 
-			(base>=10 && *nptr>='0' && *nptr<='9') ||
-			(base>=8 && *nptr>='0' && *nptr<='7') )
-		{
-			ret *= base;
-			if(base==16 && *nptr>='A' && *nptr<='F')
-				ret += *nptr-'A'+10;
-			else if(base==16 && *nptr>='a' && *nptr<='f')
-				ret += *nptr-'a'+10;
-			else if(base>=10 && *nptr>='0' && *nptr<='9')
-				ret += *nptr-'0';
-			else if(base>=8 && *nptr>='0' && *nptr<='7')
-				ret += *nptr-'0';
-		}
-		else
-			return ret;
-	}
-	return ret;
+    u32 ret;
+    if (!nptr || (base != 16 && base != 10 && base != 8))
+    {
+        printk("%s(): NULL pointer input\n", __FUNCTION__);
+        return -1;
+    }
+    for (ret=0; *nptr; nptr++)
+    {
+        if ((base == 16 && *nptr >= 'A' && *nptr <= 'F') ||
+            (base == 16 && *nptr >= 'a' && *nptr <= 'f') ||
+            (base >= 10 && *nptr >= '0' && *nptr <= '9') ||
+            (base >= 8  && *nptr >= '0' && *nptr <= '7') )
+        {
+            ret *= base;
+            if (base == 16 && *nptr >= 'A' && *nptr <= 'F')
+                ret += *nptr-'A'+10;
+            else if (base == 16 && *nptr >= 'a' && *nptr <= 'f')
+                ret += *nptr-'a'+10;
+            else if (base >= 10 && *nptr >= '0' && *nptr <= '9')
+                ret += *nptr-'0';
+            else if (base >= 8 && *nptr >= '0' && *nptr <= '7')
+                ret += *nptr-'0';
+        }
+        else
+            return ret;
+    }
+    return ret;
 }
 
 static ssize_t sp2518_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *_buf, size_t _count)
-{
-	const char * p=_buf;
-	u16 reg;
-	u8 val;
-
-	if(!strncmp(_buf, "get", strlen("get")))
-	{
-		p+=strlen("get");
-		cur_reg=(u32)strtol(p, 16);
-		val=i2c_get_byte_add8(g_i2c_client, cur_reg);
-		printk("%s(): get 0x%04x=0x%02x\n", __FUNCTION__, cur_reg, val);
-        cur_val=val;
-	}
-	else if(!strncmp(_buf, "put", strlen("put")))
-	{
-		p+=strlen("put");
-		reg=strtol(p, 16);
-		p=strchr(_buf, '=');
-		if(p)
-		{
-			++ p;
-			val=strtol(p, 16);
-			i2c_put_byte_add8_new(g_i2c_client, reg, val);
-			printk("%s(): set 0x%04x=0x%02x\n", __FUNCTION__, reg, val);
-		}
-		else
-			printk("%s(): Bad string format input!\n", __FUNCTION__);
-	}
-	else
-		printk("%s(): Bad string format input!\n", __FUNCTION__);
-	
-	return _count;
-} 
+                    struct device_attribute *attr,
+                    const char *_buf, size_t _count)
+{
+    const char * p=_buf;
+    u16 reg;
+    u8 val;
+
+    if (!strncmp(_buf, "get", strlen("get")))
+    {
+        p += strlen("get");
+        cur_reg = (u32)strtol(p, 16);
+        val = i2c_get_byte_add8(g_i2c_client, cur_reg);
+        printk("%s(): get 0x%04x=0x%02x\n", __FUNCTION__, cur_reg, val);
+        cur_val = val;
+    }
+    else if (!strncmp(_buf, "put", strlen("put")))
+    {
+        p += strlen("put");
+        reg = strtol(p, 16);
+        p = strchr(_buf, '=');
+        if (p)
+        {
+            ++ p;
+            val = strtol(p, 16);
+            i2c_put_byte_add8_new(g_i2c_client, reg, val);
+            printk("%s(): set 0x%04x=0x%02x\n", __FUNCTION__, reg, val);
+        }
+        else
+            printk("%s(): Bad string format input!\n", __FUNCTION__);
+    }
+    else
+        printk("%s(): Bad string format input!\n", __FUNCTION__);
+
+    return _count;
+}
 
 static ssize_t name_show(struct device *dev, struct device_attribute *attr, char *_buf)
 {
@@ -2889,116 +3074,118 @@ static struct class *  sp2518_class = NULL;
 static DEVICE_ATTR(sp2518, 0666, sp2518_show, sp2518_store);
 static DEVICE_ATTR(name, 0666, name_show, NULL);
 
-#define  EMDOOR_DEBUG_SP2518	1  
+#define  EMDOOR_DEBUG_SP2518    1
 #ifdef EMDOOR_DEBUG_SP2518
 unsigned int sp2518_reg_addr;
 static struct i2c_client *sp2518_client;
 
-static ssize_t sp2518_show_mine(struct kobject *kobj, struct kobj_attribute *attr,			
-	       char *buf)
-{	
-	unsigned  char dat;
-	dat = i2c_get_byte_add8(sp2518_client, sp2518_reg_addr);
-	return sprintf(buf, "REG[0x%x]=0x%x\n", sp2518_reg_addr, dat);
+static ssize_t sp2518_show_mine(struct kobject *kobj, struct kobj_attribute *attr,
+           char *buf)
+{
+    unsigned  char dat;
+    dat = i2c_get_byte_add8(sp2518_client, sp2518_reg_addr);
+    return sprintf(buf, "REG[0x%x]=0x%x\n", sp2518_reg_addr, dat);
 }
 
-static ssize_t sp2518_store_mine(struct kobject *kobj, struct kobj_attribute *attr,			 
-	      const char *buf, size_t count)
-{	
-	int tmp;
-	unsigned short reg;
-	unsigned char val;
-	tmp = simple_strtoul(buf, NULL, 16);
-	//sscanf(buf, "%du", &tmp);
-	if(tmp < 0xff){
-		sp2518_reg_addr = tmp;
-	}
-	else {
-		reg = (tmp >> 8) & 0xFFFF; //reg
-		sp2518_reg_addr = reg;
-		val = tmp & 0xFF;        //val
-		i2c_put_byte_add8_new(sp2518_client, reg, val);
-	}
-	
-	return count;
+static ssize_t sp2518_store_mine(struct kobject *kobj, struct kobj_attribute *attr,
+          const char *buf, size_t count)
+{
+    int tmp;
+    unsigned short reg;
+    unsigned char val;
+    tmp = simple_strtoul(buf, NULL, 16);
+    //sscanf(buf, "%du", &tmp);
+    if (tmp < 0xff) {
+        sp2518_reg_addr = tmp;
+    }
+    else {
+        reg = (tmp >> 8) & 0xFFFF; //reg
+        sp2518_reg_addr = reg;
+        val = tmp & 0xFF;        //val
+        i2c_put_byte_add8_new(sp2518_client, reg, val);
+    }
+
+    return count;
 }
 
 
-static struct kobj_attribute sp2518_attribute =	__ATTR(sp2518, 0666, sp2518_show_mine, sp2518_store_mine);
+static struct kobj_attribute sp2518_attribute = __ATTR(sp2518, 0666, sp2518_show_mine, sp2518_store_mine);
 
 
-static struct attribute *sp2518_attrs[] = {	
-	&sp2518_attribute.attr,	
-	NULL,	
+static struct attribute *sp2518_attrs[] = {
+    &sp2518_attribute.attr,
+    NULL,
 };
 
 
 static const struct attribute_group sp2518_group =
 {
-	.attrs = sp2518_attrs,
+    .attrs = sp2518_attrs,
 };
-#endif	
+#endif
 
 static int sp2518_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
-{
-	int err;
-	struct sp2518_device *t;
-	struct v4l2_subdev *sd;
-	aml_cam_info_t* plat_dat;
-	vops = get_vdin_v4l2_ops();
-	v4l_info(client, "chip found @ 0x%x (%s)\n",
-			client->addr << 1, client->adapter->name);
-	t = kzalloc(sizeof(*t), GFP_KERNEL);
-	//modify correct i2c addr--- 0x30
-	client->addr = 0x30;
-	if (t == NULL)
-		return -ENOMEM;
-	sd = &t->sd;
-	v4l2_i2c_subdev_init(sd, client, &sp2518_ops);
-	plat_dat= (aml_cam_info_t*)client->dev.platform_data;
-
-	/* test if devices exist. */
-
-	/* Now create a video4linux device */
-	mutex_init(&t->mutex);
-
-	/* Now create a video4linux device */
-	t->vdev = video_device_alloc();
-	if (t->vdev == NULL) {
-		kfree(t);
-		kfree(client);
-		return -ENOMEM;
-	}
-	memcpy(t->vdev, &sp2518_template, sizeof(*t->vdev));
-
-	video_set_drvdata(t->vdev, t);
-
-	wake_lock_init(&(t->wake_lock),WAKE_LOCK_SUSPEND, "spa2518");
-	/* Register it */
-	if (plat_dat) {
-		memcpy(&t->cam_info, plat_dat, sizeof(aml_cam_info_t));
-		if (plat_dat->front_back >=0)  video_nr = plat_dat->front_back;
-	} else {
-	    printk("camera sp2518: have no platform data\n");
+            const struct i2c_device_id *id)
+{
+    int err;
+    struct sp2518_device *t;
+    struct v4l2_subdev *sd;
+    aml_cam_info_t* plat_dat;
+
+    vops = get_vdin_v4l2_ops();
+    v4l_info(client, "chip found @ 0x%x (%s)\n",
+            client->addr << 1, client->adapter->name);
+    t = kzalloc(sizeof(*t), GFP_KERNEL);
+    //modify correct i2c addr--- 0x30
+    client->addr = 0x30;
+    if (t == NULL)
+        return -ENOMEM;
+    sd = &t->sd;
+    v4l2_i2c_subdev_init(sd, client, &sp2518_ops);
+    plat_dat= (aml_cam_info_t*)client->dev.platform_data;
+
+    /* test if devices exist. */
+    memset(&t->vminfo,0,sizeof(vm_init_t));
+
+    /* Now create a video4linux device */
+    mutex_init(&t->mutex);
+
+    /* Now create a video4linux device */
+    t->vdev = video_device_alloc();
+    if (t->vdev == NULL) {
+        kfree(t);
+        kfree(client);
+        return -ENOMEM;
+    }
+    memcpy(t->vdev, &sp2518_template, sizeof(*t->vdev));
+
+    video_set_drvdata(t->vdev, t);
+
+    wake_lock_init(&(t->wake_lock),WAKE_LOCK_SUSPEND, "spa2518");
+    /* Register it */
+    if (plat_dat) {
+        memcpy(&t->cam_info, plat_dat, sizeof(aml_cam_info_t));
+        if (plat_dat->front_back >= 0)  video_nr = plat_dat->front_back;
+    } else {
+        printk("camera sp2518: have no platform data\n");
            kfree(t);
-	    return -1; 	
-	}
-	
-	t->cam_info.version = SP2518_DRIVER_VERSION;
-	if (aml_cam_info_reg(&t->cam_info) < 0)
-		printk("reg caminfo error\n");
-	
-	err = video_register_device(t->vdev, VFL_TYPE_GRABBER, video_nr);
-	if (err < 0) {
-		video_device_release(t->vdev);
-		kfree(t);
-		return err;
-	}
+        return -1;
+    }
+
+    t->cam_info.version = SP2518_DRIVER_VERSION;
+    if (aml_cam_info_reg(&t->cam_info) < 0)
+        printk("reg caminfo error\n");
+
+    err = video_register_device(t->vdev, VFL_TYPE_GRABBER, video_nr);
+    if (err < 0) {
+        video_device_release(t->vdev);
+        kfree(t);
+        return err;
+    }
 
 
     sp2518_class = class_create(THIS_MODULE, "sp2518");
-    if (IS_ERR(sp2518_class)) 
+    if (IS_ERR(sp2518_class))
     {
         printk("Create class sp2518.\n");
         return -ENOMEM;
@@ -3008,42 +3195,42 @@ static int sp2518_probe(struct i2c_client *client,
     device_create_file(sp2518_dev, &dev_attr_name);
 
     g_i2c_client=client;
-	
+
 #ifdef EMDOOR_DEBUG_SP2518
-	sp2518_client = client;
-	err = sysfs_create_group(&client->dev.kobj, &sp2518_group);
-#endif	
+    sp2518_client = client;
+    err = sysfs_create_group(&client->dev.kobj, &sp2518_group);
+#endif
 
     return 0;
 }
 
 static int sp2518_remove(struct i2c_client *client)
 {
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct sp2518_device *t = to_dev(sd);
+    struct v4l2_subdev *sd = i2c_get_clientdata(client);
+    struct sp2518_device *t = to_dev(sd);
 
-	video_unregister_device(t->vdev);
-	v4l2_device_unregister_subdev(sd);
-	wake_lock_destroy(&(t->wake_lock));
-	aml_cam_info_unreg(&t->cam_info);
-	kfree(t);
-	return 0;
+    video_unregister_device(t->vdev);
+    v4l2_device_unregister_subdev(sd);
+    wake_lock_destroy(&(t->wake_lock));
+    aml_cam_info_unreg(&t->cam_info);
+    kfree(t);
+    return 0;
 }
 
 
 static const struct i2c_device_id sp2518_id[] = {
-	{ "sp2518", 0 },
-	{ }
+    { "sp2518", 0 },
+    { }
 };
 MODULE_DEVICE_TABLE(i2c, sp2518_id);
 
 static struct i2c_driver sp2518_i2c_driver = {
-	.driver = {
-		.name = "sp2518",
-	},
-	.probe = sp2518_probe,
-	.remove = sp2518_remove,
-	.id_table = sp2518_id,
+    .driver = {
+        .name = "sp2518",
+    },
+    .probe = sp2518_probe,
+    .remove = sp2518_remove,
+    .id_table = sp2518_id,
 };
 
 module_i2c_driver(sp2518_i2c_driver);
diff --git a/include/linux/amlogic/vmapi.h b/include/linux/amlogic/vmapi.h
index 4349e91ee2d6..fd2c3343033d 100755
--- a/include/linux/amlogic/vmapi.h
+++ b/include/linux/amlogic/vmapi.h
@@ -2,25 +2,36 @@
 #define VM_API_INCLUDE_
 
 typedef struct vm_output_para{
-	int width;
-	int height;
-	int bytesperline;
-	int v4l2_format;
-	int index;
-	int v4l2_memory;
-	int zoom;     // set -1 as invalid
-	int mirror;   // set -1 as invalid
-	int angle;
-	unsigned vaddr;
-	unsigned int ext_canvas;
+    int width;
+    int height;
+    int bytesperline;
+    int v4l2_format;
+    int index;
+    int v4l2_memory;
+    int zoom;     // set -1 as invalid
+    int mirror;   // set -1 as invalid
+    int angle;
+    unsigned vaddr;
+    unsigned int ext_canvas;
 }vm_output_para_t;
 struct videobuf_buffer;
+typedef struct vm_init_s {
+    size_t vm_buf_size;
+    struct page *vm_pages;
+    resource_size_t buffer_start;
+    struct io_mapping *mapping;
+    bool isused;
+    bool mem_alloc_succeed;
+}vm_init_t;
+int vm_fill_this_buffer(struct videobuf_buffer* vb , vm_output_para_t* para, vm_init_t* info);
 int vm_fill_buffer(struct videobuf_buffer* vb , vm_output_para_t* para);
 
 #ifdef CONFIG_CMA
 
 int vm_init_buf(size_t size);
+int vm_init_resource(size_t size, vm_init_t* info);
 void vm_deinit_buf(void);
+void vm_deinit_resource(vm_init_t* info);
 void vm_reserve_cma(void);
 #endif
 
-- 
2.19.0

