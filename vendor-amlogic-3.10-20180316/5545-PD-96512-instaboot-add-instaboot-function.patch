From 1bf575a00e508758b0fad92544e58e82d27c19aa Mon Sep 17 00:00:00 2001
From: Zhenfei Li <zhenfei.li@amlogic.com>
Date: Wed, 8 Apr 2015 13:24:10 +0800
Subject: [PATCH 5545/5965] PD:#96512: instaboot: add instaboot function.

Change-Id: I23c7f093f26a50f87b353cd7e471b1b7b2daef95
---
 arch/arm/Kconfig                              |   5 +
 arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd |   0
 arch/arm/configs/meson8b_defconfig            |   2 +-
 arch/arm/kernel/Makefile                      |   1 +
 arch/arm/kernel/hibernate.c                   | 106 +++++++++
 arch/arm/mach-meson8/power_gate.c             |  50 ++++
 arch/arm/mach-meson8b/power_gate.c            |  48 ++++
 arch/arm/mm/cache-l2x0.c                      |   2 +-
 arch/arm/mm/init.c                            |  10 +
 drivers/amlogic/Kconfig                       |   0
 drivers/amlogic/Makefile                      |   2 +
 drivers/amlogic/display/lcd/aml_lcd.c         |  11 +-
 drivers/amlogic/display/osd/Makefile          |   2 +
 drivers/amlogic/display/osd/osd_dev.c         |  18 ++
 drivers/amlogic/display/osd/osd_hw.c          |  30 ++-
 drivers/amlogic/display/osd/osd_main.c        |  46 +++-
 drivers/amlogic/display/osd/osd_progressbar.c | 215 +++++++++++++++++
 drivers/amlogic/display/osd/osd_rdma.c        |  16 +-
 drivers/amlogic/display/vout/lcdoutc.c        |  11 +-
 drivers/amlogic/display/vout/tvconf.c         |  53 ++++-
 drivers/amlogic/display/vout/vout_notify.c    |  18 +-
 drivers/amlogic/display/vout/vout_serve.c     |  54 ++++-
 drivers/amlogic/display/vout/vout_serve.h     |   2 +-
 drivers/amlogic/display/vout2/tvconf2.c       |   4 +-
 drivers/amlogic/display/vout2/vout2_notify.c  |   8 +-
 drivers/amlogic/ethernet/phy/am_ip101.c       |   6 +
 drivers/amlogic/ethernet/phy/am_rtl8211f.c    |  15 ++
 drivers/amlogic/instaboot/Makefile            |   1 +
 drivers/amlogic/instaboot/instaboot_hook.c    | 225 ++++++++++++++++++
 drivers/amlogic/instaboot/instaboot_kernel.c  | 141 +++++++++++
 drivers/amlogic/power/aml_pmu/aml1216-sply.c  |   6 +-
 drivers/amlogic/power/aml_pmu/aml1218-sply.c  |   6 +-
 drivers/amlogic/power/axp_power/axp20-sply.c  |   6 +-
 drivers/amlogic/power/ricoh/rn5t618-sply.c    |   6 +-
 drivers/amlogic/uart/uart/meson_uart.c        |  55 ++++-
 drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.c |   9 +-
 drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.h |   3 +-
 .../usb/dwc_otg/310/dwc_otg_hcd_linux.c       |   9 +-
 drivers/base/power/main.c                     |  16 +-
 .../net/ethernet/stmicro/stmmac/stmmac_mdio.c |  12 +-
 .../ethernet/stmicro/stmmac/stmmac_platform.c |  12 +-
 drivers/of/fdt.c                              |  21 +-
 drivers/usb/core/hcd.c                        |   7 +
 include/linux/amlogic/instaboot/instaboot.h   |  65 +++++
 include/linux/amlogic/osd/osd_hw.h            |   3 +-
 include/linux/amlogic/vout/vout_notify.h      | 204 ++++++++--------
 include/linux/pm.h                            |   3 +
 include/linux/suspend.h                       |   5 +
 init/do_mounts.c                              |  22 ++
 kernel/power/Kconfig                          |   5 +
 kernel/power/Makefile                         |   3 +-
 kernel/power/hibernate.c                      |  75 +++++-
 kernel/power/power.h                          |   4 +-
 kernel/power/snapshot.c                       |  93 ++++++--
 kernel/printk.c                               |   2 +-
 lib/lzo/lzo1x_decompress_safe.c               |  18 +-
 lib/lzo/lzodefs.h                             |  15 +-
 57 files changed, 1552 insertions(+), 235 deletions(-)
 mode change 100755 => 100644 arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd
 create mode 100644 arch/arm/kernel/hibernate.c
 mode change 100755 => 100644 drivers/amlogic/Kconfig
 mode change 100755 => 100644 drivers/amlogic/Makefile
 mode change 100755 => 100644 drivers/amlogic/display/osd/Makefile
 mode change 100755 => 100644 drivers/amlogic/display/osd/osd_main.c
 create mode 100644 drivers/amlogic/display/osd/osd_progressbar.c
 mode change 100755 => 100644 drivers/amlogic/ethernet/phy/am_rtl8211f.c
 create mode 100644 drivers/amlogic/instaboot/Makefile
 create mode 100644 drivers/amlogic/instaboot/instaboot_hook.c
 create mode 100644 drivers/amlogic/instaboot/instaboot_kernel.c
 mode change 100755 => 100644 drivers/amlogic/uart/uart/meson_uart.c
 create mode 100644 include/linux/amlogic/instaboot/instaboot.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index ad24017b77d8..87c7e283009a 100755
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -2271,6 +2271,11 @@ config ARCH_SUSPEND_POSSIBLE
 config ARM_CPU_SUSPEND
 	def_bool PM_SLEEP
 
+config ARCH_HIBERNATION_POSSIBLE
+	bool
+	depends on MMU
+	default y if ARCH_SUSPEND_POSSIBLE
+
 endmenu
 
 source "net/Kconfig"
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m200_1G.dtd
old mode 100755
new mode 100644
diff --git a/arch/arm/configs/meson8b_defconfig b/arch/arm/configs/meson8b_defconfig
index 54250992c527..098c968c6b9a 100644
--- a/arch/arm/configs/meson8b_defconfig
+++ b/arch/arm/configs/meson8b_defconfig
@@ -464,4 +464,4 @@ CONFIG_CRYPTO_PCBC=y
 CONFIG_CRYPTO_TWOFISH=y
 CONFIG_CRYPTO_USER_API_SKCIPHER=y
 CONFIG_CRC_T10DIF=y
-CONFIG_CRC7=y
+CONFIG_CRC7=y
\ No newline at end of file
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index 5f3338eacad2..52c39ad84b5a 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -32,6 +32,7 @@ obj-$(CONFIG_ARTHUR)		+= arthur.o
 obj-$(CONFIG_ISA_DMA)		+= dma-isa.o
 obj-$(CONFIG_PCI)		+= bios32.o isa.o
 obj-$(CONFIG_ARM_CPU_SUSPEND)	+= sleep.o suspend.o
+obj-$(CONFIG_HIBERNATION)	+= hibernate.o
 obj-$(CONFIG_SMP)		+= smp.o smp_tlb.o
 obj-$(CONFIG_HAVE_ARM_SCU)	+= smp_scu.o
 obj-$(CONFIG_HAVE_ARM_TWD)	+= smp_twd.o
diff --git a/arch/arm/kernel/hibernate.c b/arch/arm/kernel/hibernate.c
new file mode 100644
index 000000000000..eb58ca408369
--- /dev/null
+++ b/arch/arm/kernel/hibernate.c
@@ -0,0 +1,106 @@
+/*
+ * Hibernation support specific for ARM
+ *
+ * Derived from work on ARM hibernation support by:
+ *
+ * Ubuntu project, hibernation support for mach-dove
+ * Copyright (C) 2010 Nokia Corporation (Hiroshi Doyu)
+ * Copyright (C) 2010 Texas Instruments, Inc. (Teerth Reddy et al.)
+ *  https://lkml.org/lkml/2010/6/18/4
+ *  https://lists.linux-foundation.org/pipermail/linux-pm/2010-June/027422.html
+ *  https://patchwork.kernel.org/patch/96442/
+ *
+ * Copyright (C) 2006 Rafael J. Wysocki <rjw@sisk.pl>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+
+#include <linux/mm.h>
+#include <linux/suspend.h>
+#include <asm/system_misc.h>
+#include <asm/idmap.h>
+#include <asm/suspend.h>
+#include <asm/memory.h>
+
+extern const void __nosave_begin, __nosave_end;
+
+int pfn_is_nosave(unsigned long pfn)
+{
+	unsigned long nosave_begin_pfn = __pa(&__nosave_begin) >> PAGE_SHIFT;
+	unsigned long nosave_end_pfn = PAGE_ALIGN(__pa(&__nosave_end)) >> PAGE_SHIFT;
+	return (pfn >= nosave_begin_pfn) && (pfn < nosave_end_pfn);
+}
+
+void notrace save_processor_state(void)
+{
+	WARN_ON(num_online_cpus() != 1);
+	local_fiq_disable();
+}
+
+void notrace restore_processor_state(void)
+{
+	local_fiq_enable();
+}
+
+/*
+ * Snapshot kernel memory and reset the system.
+ *
+ * swsusp_save() is executed in the suspend finisher so that the CPU
+ * context pointer and memory are part of the saved image, which is
+ * required by the resume kernel image to restart execution from
+ * swsusp_arch_suspend().
+ *
+ * soft_restart is not technically needed, but is used to get success
+ * returned from cpu_suspend.
+ *
+ * When soft reboot completes, the hibernation snapshot is written out.
+ */
+static int notrace arch_save_image(unsigned long unused)
+{
+	int ret;
+
+	ret = swsusp_save();
+	if (ret == 0)
+		soft_restart(virt_to_phys(cpu_resume));
+	return ret;
+}
+
+/*
+ * Save the current CPU state before suspend / poweroff.
+ */
+int notrace swsusp_arch_suspend(void)
+{
+	return cpu_suspend(0, arch_save_image);
+}
+
+/*
+ * Restore page contents for physical pages that were in use during loading
+ * hibernation image.  Switch to idmap_pgd so the physical page tables
+ * are overwritten with the same contents.
+ */
+static void notrace arch_restore_image(void *unused)
+{
+	struct pbe *pbe;
+
+	cpu_switch_mm(idmap_pgd, &init_mm);
+	for (pbe = restore_pblist; pbe; pbe = pbe->next)
+		copy_page(pbe->orig_address, pbe->address);
+
+	soft_restart(virt_to_phys(cpu_resume));
+}
+
+static u64 resume_stack[PAGE_SIZE/2/sizeof(u64)] __nosavedata;
+
+/*
+ * Resume from the hibernation image.
+ * Due to the kernel heap / data restore, stack contents change underneath
+ * and that would make function calls impossible; switch to a temporary
+ * stack within the nosave region to avoid that problem.
+ */
+int swsusp_arch_resume(void)
+{
+	extern void call_with_stack(void (*fn)(void *), void *arg, void *sp);
+	call_with_stack(arch_restore_image, 0,
+		resume_stack + ARRAY_SIZE(resume_stack));
+	return 0;
+}
diff --git a/arch/arm/mach-meson8/power_gate.c b/arch/arm/mach-meson8/power_gate.c
index 39bbd1605147..2111fa02400f 100755
--- a/arch/arm/mach-meson8/power_gate.c
+++ b/arch/arm/mach-meson8/power_gate.c
@@ -7,6 +7,9 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/hardirq.h>
+#ifdef CONFIG_HIBERNATION
+#include <linux/syscore_ops.h>
+#endif
 
 short GCLK_ref[GCLK_IDX_MAX];
 EXPORT_SYMBOL(GCLK_ref);
@@ -580,6 +583,49 @@ void switch_lcd_mod_gate(int flag)
 }
 EXPORT_SYMBOL(switch_lcd_mod_gate);
 
+#ifdef CONFIG_HIBERNATION
+static unsigned long gates_reg0, gates_reg1, gates_reg2;
+static unsigned long gates_reg_other, gates_reg_ao;
+#define GATES_REG0_MASK	(0x200000)
+#define GATES_REG2_MASK	(0x18)
+#define GATES_REG_OTHER_MASK (0x7d007fe)
+static int gates_suspend(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&gate_lock, flags);
+	gates_reg0 = READ_CBUS_REG(HHI_GCLK_MPEG0) & (~GATES_REG0_MASK);
+	gates_reg1 = READ_CBUS_REG(HHI_GCLK_MPEG1);
+	gates_reg2 = READ_CBUS_REG(HHI_GCLK_MPEG2) & (~GATES_REG2_MASK);
+	gates_reg_other = READ_CBUS_REG(HHI_GCLK_OTHER) & (~GATES_REG_OTHER_MASK);
+	gates_reg_ao = READ_CBUS_REG(HHI_GCLK_AO);
+	spin_unlock_irqrestore(&gate_lock, flags);
+
+	return 0;
+}
+
+static void gates_resume(void)
+{
+	unsigned long flags, temp;
+	spin_lock_irqsave(&gate_lock, flags);
+	temp = READ_CBUS_REG(HHI_GCLK_MPEG0) & GATES_REG0_MASK;
+	WRITE_CBUS_REG(HHI_GCLK_MPEG0, gates_reg0 | temp);
+	WRITE_CBUS_REG(HHI_GCLK_MPEG1, gates_reg1);
+	temp = READ_CBUS_REG(HHI_GCLK_MPEG2) & GATES_REG2_MASK;
+	WRITE_CBUS_REG(HHI_GCLK_MPEG2, gates_reg2 | temp);
+	temp = READ_CBUS_REG(HHI_GCLK_OTHER) & GATES_REG_OTHER_MASK;
+	WRITE_CBUS_REG(HHI_GCLK_OTHER, gates_reg_other | temp);
+	WRITE_CBUS_REG(HHI_GCLK_AO, gates_reg_ao);
+	spin_unlock_irqrestore(&gate_lock, flags);
+}
+
+static struct syscore_ops gates_ops = {
+	.suspend = gates_suspend,
+	.resume = gates_resume,
+	.shutdown = NULL,
+};
+
+#endif
+
 void power_gate_init(void)
 {
 	GATE_INIT(DDR);
@@ -706,6 +752,10 @@ static struct class_attribute aml_mod_attrs[]={
 static int __init mode_gate_mgr_init(void)
 {
 	int ret = 0, i = 0;
+#ifdef CONFIG_HIBERNATION
+	INIT_LIST_HEAD(&gates_ops.node);
+	register_syscore_ops(&gates_ops);
+#endif
 	power_gate_init();
 	mod_gate_clsp = class_create(THIS_MODULE, "aml_mod");
 	if(IS_ERR(mod_gate_clsp)){
diff --git a/arch/arm/mach-meson8b/power_gate.c b/arch/arm/mach-meson8b/power_gate.c
index 04b0bac8c8d9..5dc31c53ecb2 100755
--- a/arch/arm/mach-meson8b/power_gate.c
+++ b/arch/arm/mach-meson8b/power_gate.c
@@ -7,6 +7,9 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/hardirq.h>
+#ifdef CONFIG_HIBERNATION
+#include <linux/syscore_ops.h>
+#endif
 
 short GCLK_ref[GCLK_IDX_MAX];
 EXPORT_SYMBOL(GCLK_ref);
@@ -581,6 +584,47 @@ void switch_lcd_mod_gate(int flag)
 }
 EXPORT_SYMBOL(switch_lcd_mod_gate);
 
+#ifdef CONFIG_HIBERNATION
+static unsigned long gates_reg0, gates_reg1, gates_reg2;
+static unsigned long gates_reg_other, gates_reg_ao;
+#define GATES_REG2_MASK	(0x18)
+#define GATES_REG_OTHER_MASK (0x75007fe)
+static int gates_suspend(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&gate_lock, flags);
+	gates_reg0 = READ_CBUS_REG(HHI_GCLK_MPEG0);
+	gates_reg1 = READ_CBUS_REG(HHI_GCLK_MPEG1);
+	gates_reg2 = READ_CBUS_REG(HHI_GCLK_MPEG2) & (~GATES_REG2_MASK);
+	gates_reg_other = READ_CBUS_REG(HHI_GCLK_OTHER) & (~GATES_REG_OTHER_MASK);
+	gates_reg_ao = READ_CBUS_REG(HHI_GCLK_AO);
+	spin_unlock_irqrestore(&gate_lock, flags);
+
+	return 0;
+}
+
+static void gates_resume(void)
+{
+	unsigned long flags, temp;
+	spin_lock_irqsave(&gate_lock, flags);
+	WRITE_CBUS_REG(HHI_GCLK_MPEG0, gates_reg0);
+	WRITE_CBUS_REG(HHI_GCLK_MPEG1, gates_reg1);
+	temp = READ_CBUS_REG(HHI_GCLK_MPEG2) & GATES_REG2_MASK;
+	WRITE_CBUS_REG(HHI_GCLK_MPEG2, gates_reg2 | temp);
+	temp = READ_CBUS_REG(HHI_GCLK_OTHER) & GATES_REG_OTHER_MASK;
+	WRITE_CBUS_REG(HHI_GCLK_OTHER, gates_reg_other | temp);
+	WRITE_CBUS_REG(HHI_GCLK_AO, gates_reg_ao);
+	spin_unlock_irqrestore(&gate_lock, flags);
+}
+
+static struct syscore_ops gates_ops = {
+	.suspend = gates_suspend,
+	.resume = gates_resume,
+	.shutdown = NULL,
+};
+
+#endif
+
 void power_gate_init(void)
 {
 	GATE_INIT(DDR);
@@ -708,6 +752,10 @@ static struct class_attribute aml_mod_attrs[]={
 static int __init mode_gate_mgr_init(void)
 {
 	int ret = 0, i = 0;
+#ifdef CONFIG_HIBERNATION
+	INIT_LIST_HEAD(&gates_ops.node);
+	register_syscore_ops(&gates_ops);
+#endif
 	power_gate_init();
 	mod_gate_clsp = class_create(THIS_MODULE, "aml_mod");
 	if(IS_ERR(mod_gate_clsp)){
diff --git a/arch/arm/mm/cache-l2x0.c b/arch/arm/mm/cache-l2x0.c
index 9b5017902a0d..b16261430363 100755
--- a/arch/arm/mm/cache-l2x0.c
+++ b/arch/arm/mm/cache-l2x0.c
@@ -730,7 +730,7 @@ static void aurora_save(void)
 	l2x0_saved_regs.aux_ctrl = readl_relaxed(l2x0_base + L2X0_AUX_CTRL);
 }
 
-static void l2x0_resume(void)
+void l2x0_resume(void)
 {
 	if (!(readl_relaxed(l2x0_base + L2X0_CTRL) & L2X0_CTRL_EN)) {
 		/* restore aux ctrl and enable l2 */
diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index 1ab66303b016..239f856d1747 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -34,6 +34,11 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 
+#ifdef CONFIG_HIBERNATION
+#include <linux/suspend.h>
+#include <asm/xen/page.h>
+#endif
+
 #include "mm.h"
 
 static unsigned long phys_initrd_start __initdata = 0;
@@ -699,6 +704,11 @@ void __init mem_init(void)
 #undef MLM
 #undef MLK_ROUNDUP
 
+#ifdef CONFIG_HIBERNATION
+	register_nosave_region((unsigned long)virt_to_pfn(_text),
+		 (unsigned long)virt_to_pfn(_etext));
+#endif
+
 	/*
 	 * Check boundaries twice: Some fundamental inconsistencies can
 	 * be detected at build time already.
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
old mode 100755
new mode 100644
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
old mode 100755
new mode 100644
index 937a1db02c63..49f4fe0c3c85
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -131,6 +131,8 @@ endif
 
 obj-$(CONFIG_AMLOGIC_ION) += ion_dev/
 
+obj-$(CONFIG_HIBERNATION) += instaboot/
+
 obj-y += crypto/
 
 #obj-$(CONFIG_MESON_TRUSTZONE) += trustzone/
diff --git a/drivers/amlogic/display/lcd/aml_lcd.c b/drivers/amlogic/display/lcd/aml_lcd.c
index d944e756007d..95081e566f80 100755
--- a/drivers/amlogic/display/lcd/aml_lcd.c
+++ b/drivers/amlogic/display/lcd/aml_lcd.c
@@ -1580,8 +1580,11 @@ static int lcd_module_disable(vmode_t cur_vmod)
     return 0;
 }
 #ifdef  CONFIG_PM
-static int lcd_suspend(void)
+static int lcd_suspend(int pm_event)
 {
+    /* in freeze process do not turn off the display devices */
+    if (pm_event == PM_EVENT_FREEZE)
+        return 0;
     BUG_ON(pDev==NULL);
     PRINT_INFO("lcd_suspend \n");
     //_disable_backlight();
@@ -1597,9 +1600,13 @@ static int lcd_suspend(void)
    // panel_power_off();
     return 0;
 }
-static int lcd_resume(void)
+static int lcd_resume(int pm_event)
 {
     PRINT_INFO("lcd_resume\n");
+    /* in thaw/restore process do not reset the display mode */
+    if (pm_event == PM_EVENT_THAW
+            || pm_event == PM_EVENT_RESTORE)
+        return 0;
 
     //panel_power_on();
    // mdelay(panel_power_on_delay);
diff --git a/drivers/amlogic/display/osd/Makefile b/drivers/amlogic/display/osd/Makefile
old mode 100755
new mode 100644
index 186a7011ba2f..58d2b6a34a46
--- a/drivers/amlogic/display/osd/Makefile
+++ b/drivers/amlogic/display/osd/Makefile
@@ -13,6 +13,8 @@ endif
 
 obj-$(CONFIG_VSYNC_RDMA) += osd_rdma.o
 
+obj-$(CONFIG_HIBERNATION) +=  osd_progressbar.o
+
 EXTRA_CFLAGS += -Iinclude/linux/osd/ -Idrivers/staging/android/
 
 
diff --git a/drivers/amlogic/display/osd/osd_dev.c b/drivers/amlogic/display/osd/osd_dev.c
index 93165b5b0e77..635e38845e6d 100755
--- a/drivers/amlogic/display/osd/osd_dev.c
+++ b/drivers/amlogic/display/osd/osd_dev.c
@@ -384,3 +384,21 @@ void osddev_resume(void)
 {
 	osd_resume_hw();
 }
+#ifdef CONFIG_HIBERNATION
+extern void  osd_freeze_hw(void);
+extern void  osd_thaw_hw(void);
+extern void  osd_restore_hw(void);
+
+void  osddev_freeze(void)
+{
+	osd_freeze_hw();
+}
+void osddev_thaw(void)
+{
+	osd_thaw_hw();
+}
+void osddev_restore(void)
+{
+	osd_restore_hw();
+}
+#endif
diff --git a/drivers/amlogic/display/osd/osd_hw.c b/drivers/amlogic/display/osd/osd_hw.c
index 89e5d558bfaf..e35cf6df44d7 100644
--- a/drivers/amlogic/display/osd/osd_hw.c
+++ b/drivers/amlogic/display/osd/osd_hw.c
@@ -3226,7 +3226,9 @@ void osd_cursor_hw(s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w, u32 osd_h,
 
 void  osd_suspend_hw(void)
 {
-	osd_hw.reg_status_save = aml_read_reg32(P_VPP_MISC) & OSD_RELATIVE_BITS;
+	osd_rdma_enable(0);
+	osd_hw.reg_status_save[0] =
+		aml_read_reg32(P_VPP_MISC) & OSD_RELATIVE_BITS;
 
 	//aml_clr_reg32_mask(P_VPP_MISC, OSD_RELATIVE_BITS);
 	VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, OSD_RELATIVE_BITS);
@@ -3239,13 +3241,37 @@ void  osd_suspend_hw(void)
 void osd_resume_hw(void)
 {
 	//aml_set_reg32_mask(P_VPP_MISC, osd_hw.reg_status_save);
-	VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, osd_hw.reg_status_save);
+	VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, osd_hw.reg_status_save[0]);
+	osd_rdma_enable(1);
 
 	printk("osd_resumed\n");
 
 	return ;
 }
 
+#ifdef CONFIG_HIBERNATION
+void  osd_freeze_hw(void)
+{
+	osd_rdma_enable(0);
+	printk("osd_freezed\n");
+
+	return ;
+}
+void osd_thaw_hw(void)
+{
+	printk("osd_thawed\n");
+	osd_rdma_enable(1);
+	return;
+}
+void osd_restore_hw(void)
+{
+	osd_rdma_enable(1);
+	printk("osd_restored\n");
+
+	return;
+}
+#endif
+
 MODULE_PARM_DESC(osd_h_filter_mode, "\n osd_h_filter_mode \n");
 module_param(osd_h_filter_mode, int, 0664);
 
diff --git a/drivers/amlogic/display/osd/osd_main.c b/drivers/amlogic/display/osd/osd_main.c
old mode 100755
new mode 100644
index 2370440e76ea..e61d803a1022
--- a/drivers/amlogic/display/osd/osd_main.c
+++ b/drivers/amlogic/display/osd/osd_main.c
@@ -70,7 +70,7 @@ osd_info_t  osd_info={
 
 MODULE_AMLOG(AMLOG_DEFAULT_LEVEL, 0x0, LOG_LEVEL_DESC, LOG_MASK_DESC);
 
-static myfb_dev_t  *gp_fbdev_list[OSD_COUNT]={NULL,NULL};
+myfb_dev_t  *gp_fbdev_list[OSD_COUNT]={NULL,NULL};
 
 static DEFINE_MUTEX(dbg_mutex);
 static char request2XScaleValue[32];
@@ -494,8 +494,7 @@ static int osd_open(struct fb_info *info, int arg)
 }
 
 
-static int
-osd_blank(int blank_mode, struct fb_info *info)
+int osd_blank(int blank_mode, struct fb_info *info)
 {
  	osddev_enable((blank_mode != 0) ? 0 : 1,info->node);
 
@@ -660,6 +659,7 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd , void *
 static struct notifier_block osd_notifier_nb = {
 	.notifier_call	= osd_notify_callback,
 };
+
 static ssize_t store_preblend_enable(struct device *device, struct device_attribute *attr,
 			 const char *buf, size_t count)
 {
@@ -1568,7 +1568,6 @@ static int osd_resume(struct platform_device * dev)
 		return 0;
 	}
 #endif
-
 #ifdef CONFIG_HAS_EARLYSUSPEND
     if (early_suspend_flag)
         return 0;
@@ -1578,6 +1577,34 @@ static int osd_resume(struct platform_device * dev)
 }
 #endif 
 
+#ifdef CONFIG_HIBERNATION
+extern void osddev_freeze(void);
+extern void osddev_thaw(void);
+extern void osddev_restore(void);
+
+static int osd_freeze(struct device *dev)
+{
+    printk("**** %s ****\n", __FUNCTION__);
+    osddev_freeze();
+    return 0;
+}
+
+static int osd_thaw(struct device *dev)
+{
+    printk("**** %s ****\n", __FUNCTION__);
+    osddev_thaw();
+    return 0;
+}
+
+static int osd_restore(struct device *dev)
+{
+    printk("**** %s ****\n", __FUNCTION__);
+    osddev_restore();
+    return 0;
+}
+#endif
+
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static void osd_early_suspend(struct early_suspend *h)
 {
@@ -1972,6 +1999,14 @@ static const struct of_device_id meson_fb_dt_match[]={
 	{},
 };
 
+#ifdef CONFIG_HIBERNATION
+struct dev_pm_ops osd_pm = {
+	.freeze		= osd_freeze,
+	.thaw		= osd_thaw,
+	.restore	= osd_restore,
+};
+#endif
+
 static struct platform_driver
 osd_driver = {
     .probe      = osd_probe,
@@ -1983,6 +2018,9 @@ osd_driver = {
     .driver     = {
         .name   = "mesonfb",
         .of_match_table=meson_fb_dt_match,
+#ifdef CONFIG_HIBERNATION
+        .pm     = &osd_pm,
+#endif
     }
 };
 
diff --git a/drivers/amlogic/display/osd/osd_progressbar.c b/drivers/amlogic/display/osd/osd_progressbar.c
new file mode 100644
index 000000000000..7512d7a0dae4
--- /dev/null
+++ b/drivers/amlogic/display/osd/osd_progressbar.c
@@ -0,0 +1,215 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/wait.h>
+#include <linux/of_fdt.h>
+#include <linux/console.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/osd/osd_dev.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/logo/logo_dev.h>
+#include <linux/amlogic/logo/logo_dev_osd.h>
+#include <linux/amlogic/logo/dev_ge2d.h>
+#include <mach/mod_gate.h>
+
+extern myfb_dev_t  *gp_fbdev_list[OSD_COUNT];
+extern int osd_blank(int blank_mode, struct fb_info *info);
+
+typedef struct{
+	ge2d_context_t  *ge2d_context;
+	const vinfo_t *vinfo;
+	src_dst_info_t  op_info;
+	u32 bar_border;
+	u32 bar_width;
+	u32 bar_height;
+} osd_progress_bar_t;
+
+static osd_progress_bar_t progress_bar;
+
+static int init_fb1_first (const vinfo_t *vinfo)
+{
+	struct osd_ctl_s  osd_ctl;
+	const color_bit_define_t  *color;
+	u32 reg = 0, data32 = 0;
+	int ret = 0;
+
+	ret = find_reserve_block("mesonfb", 1);
+	if (ret < 0) {
+		amlog_level(LOG_LEVEL_HIGH,
+			"can not find mesonfb1 reserve block\n");
+		return -EFAULT;
+	}
+
+	osd_ctl.addr = (phys_addr_t)get_reserve_block_addr(ret);
+
+	osd_ctl.index = 1; //fb1
+	color=&default_color_format_array[31];
+
+	osd_ctl.xres=vinfo->width;
+	osd_ctl.yres=vinfo->height;
+	osd_ctl.xres_virtual=osd_ctl.xres;
+	osd_ctl.yres_virtual=osd_ctl.yres;
+	osd_ctl.disp_start_x=0;
+	osd_ctl.disp_end_x=osd_ctl.xres -1;
+	osd_ctl.disp_start_y=0;
+	osd_ctl.disp_end_y=osd_ctl.yres-1;
+
+	reg = osd_ctl.index==0?P_VIU_OSD1_BLK0_CFG_W0:P_VIU_OSD2_BLK0_CFG_W0;
+	data32 = aml_read_reg32(reg)&(~(0xf<<8));
+	data32 |=  color->hw_blkmode<< 8; /* osd_blk_mode */
+	aml_write_reg32(reg, data32);
+
+	amlog_level(LOG_LEVEL_HIGH, "osd_ctl.addr is 0x%08x, osd_ctl.xres is %d,"
+		" osd_ctl.yres is %d\n", osd_ctl.addr,
+			osd_ctl.xres, osd_ctl.yres);
+	osd_setup(&osd_ctl, \
+		0, \
+		0, \
+		osd_ctl.xres, \
+		osd_ctl.yres, \
+		osd_ctl.xres_virtual, \
+		osd_ctl.yres_virtual, \
+		osd_ctl.disp_start_x, \
+		osd_ctl.disp_start_y, \
+		osd_ctl.disp_end_x, \
+		osd_ctl.disp_end_y, \
+		osd_ctl.addr, \
+		color, \
+		osd_ctl.index);
+
+	return SUCCESS;
+}
+
+int osd_show_progress_bar(u32 percent) {
+	static u32 progress= 0;
+	u32 step =1;
+	//wait_queue_head_t  wait_head;
+	myfb_dev_t *fb_dev;
+	ge2d_context_t  *context = progress_bar.ge2d_context;
+	src_dst_info_t  *op_info = &progress_bar.op_info;
+
+	if (NULL == context) {
+		//osd_init_progress_bar();
+		printk("context is NULL\n");
+		return -1;
+	}
+	if (NULL == (fb_dev = gp_fbdev_list[1])) {
+		amlog_level(LOG_LEVEL_HIGH, "fb1 should exit!!!");
+		return -EFAULT;
+	}
+	switch_mod_gate_by_name("ge2d", 1);
+	//init_waitqueue_head(&wait_head);
+
+	while (progress < percent) {
+		/*
+		printk("progress is %d, x: [%d], y: [%d], w: [%d], h: [%d]\n",
+			progress, op_info->dst_rect.x, op_info->dst_rect.y,
+			op_info->dst_rect.w, op_info->dst_rect.h);
+		*/
+
+		dev_ge2d_cmd(context,CMD_FILLRECT,op_info);
+		//wait_event_interruptible_timeout(wait_head,0,4);
+		progress+=step;
+		op_info->dst_rect.x+=op_info->dst_rect.w;
+		op_info->color-=(0xff*step/100)<<16; //color change smoothly.
+	}
+	switch_mod_gate_by_name("ge2d", 0);
+	if (100 == percent) {
+		progress = 0;
+		//console_lock();
+		//osd_blank(1,fb_dev->fb_info);
+		//console_unlock();
+	}
+	return SUCCESS;
+}
+EXPORT_SYMBOL(osd_show_progress_bar);
+
+int osd_init_progress_bar(void) {
+	src_dst_info_t  *op_info = &progress_bar.op_info;
+	const vinfo_t *vinfo = progress_bar.vinfo;
+	config_para_t	ge2d_config;
+	myfb_dev_t *fb_dev;
+	u32 step =1;
+
+	memset(&progress_bar, 0, sizeof(osd_progress_bar_t));
+
+	vinfo = get_current_vinfo();
+	/*
+	pr_info("vinfo->name is %s, vinfo->mode is %d, vinfo->width: [%d],"
+		" vinfo->height: [%d], vinfo->screen_real_width: [%d],"
+		" vinfo->screen_real_height: [%d]\n",
+		vinfo->name, vinfo->mode, vinfo->width, vinfo->height,
+		vinfo->screen_real_width, vinfo->screen_real_height);
+	*/
+	progress_bar.bar_border =
+		(((vinfo->field_height?vinfo->field_height:vinfo->height)*4/720)>>2)<<2;
+	progress_bar.bar_width =
+		(((vinfo->width*200/1280)>>2)<<2) + progress_bar.bar_border;
+	progress_bar.bar_height =
+		(((vinfo->field_height?vinfo->field_height:vinfo->height)*32/720)>>2)<<2;
+
+	if (SUCCESS == init_fb1_first(vinfo)) {
+		if (NULL == (fb_dev = gp_fbdev_list[1])) {
+			amlog_level(LOG_LEVEL_HIGH, "fb1 should exit!!!");
+			return -EFAULT;
+		}
+
+		switch_mod_gate_by_name("ge2d", 1);
+		ge2d_config.src_dst_type = OSD1_OSD1;
+		ge2d_config.alu_const_color = 0x000000ff;
+		progress_bar.ge2d_context = dev_ge2d_setup(&ge2d_config);
+		if (NULL == progress_bar.ge2d_context) {
+			pr_info("ge2d_context is NULL!!!!!!\n");
+			return -OUTPUT_DEV_SETUP_FAIL;
+		}
+		amlog_level(LOG_LEVEL_HIGH, "progress bar setup ge2d device OK\n");
+		//clear dst rect
+		op_info->color = 0x000000bf;
+		op_info->dst_rect.x = 0;
+		op_info->dst_rect.y = 0;
+		op_info->dst_rect.w = vinfo->width;
+		op_info->dst_rect.h =
+			vinfo->field_height?vinfo->field_height:vinfo->height;
+		dev_ge2d_cmd(progress_bar.ge2d_context,CMD_FILLRECT,op_info);
+		/*
+		pr_info("clear dst:%d-%d-%d-%d\n",
+			op_info->dst_rect.x,op_info->dst_rect.y,
+			op_info->dst_rect.w,op_info->dst_rect.h);
+		*/
+		// show fb1
+		console_lock();
+		osd_blank(0,fb_dev->fb_info);
+		console_unlock();
+		op_info->color=0x555555ff;
+		op_info->dst_rect.x =
+			(vinfo->width/2)-progress_bar.bar_width;
+		op_info->dst_rect.y =
+			((vinfo->field_height?vinfo->field_height:vinfo->height)*9)/10;
+		op_info->dst_rect.w = progress_bar.bar_width*2;
+		op_info->dst_rect.h = progress_bar.bar_height;
+		/*
+		pr_info("fill==dst:%d-%d-%d-%d\n",
+			op_info->dst_rect.x,op_info->dst_rect.y,
+			op_info->dst_rect.w,op_info->dst_rect.h);
+		*/
+		dev_ge2d_cmd(progress_bar.ge2d_context,CMD_FILLRECT,op_info);
+		switch_mod_gate_by_name("ge2d", 0);
+	} else {
+		amlog_level(LOG_LEVEL_HIGH, "fb1 init failed, exit!!!");
+		return -EFAULT;
+	}
+
+	// initial op info before draw actrualy
+	op_info->dst_rect.x += progress_bar.bar_border;
+	op_info->dst_rect.y += progress_bar.bar_border;
+	op_info->dst_rect.w =
+		(progress_bar.bar_width-progress_bar.bar_border)*2*step/100;
+	op_info->dst_rect.h =
+		progress_bar.bar_height-progress_bar.bar_border*2;
+	op_info->color = 0xffffff;
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(osd_init_progress_bar);
+
diff --git a/drivers/amlogic/display/osd/osd_rdma.c b/drivers/amlogic/display/osd/osd_rdma.c
index 55b0052140d3..ab4cedc49d1d 100644
--- a/drivers/amlogic/display/osd/osd_rdma.c
+++ b/drivers/amlogic/display/osd/osd_rdma.c
@@ -25,6 +25,7 @@
  */
 #include "osd_rdma.h"
 #include <linux/amlogic/amlog.h>
+#include <linux/delay.h>
 
 static rdma_table_item_t *rdma_table = NULL;
 static u32		   table_paddr = 0;
@@ -238,13 +239,23 @@ int reset_rdma(void)
 }
 EXPORT_SYMBOL(reset_rdma);
 
+static DEFINE_MUTEX(rdma_mutex);
+
 int osd_rdma_enable(u32  enable)
 {
 	if (!osd_rdma_init_flat)
 		osd_rdma_init();
-
-	if (enable == rdma_enable) return 0;
+	mutex_lock(&rdma_mutex);
+	if (enable == rdma_enable) {
+		mutex_unlock(&rdma_mutex);
+		return 0;
+	}
 	rdma_enable = enable;
+	while (aml_read_reg32(P_RDMA_STATUS) & 0x0fffff0f) {
+		printk("rdma still work£¬ RDMA_STATUS: 0x%x\n",
+				aml_read_reg32(P_RDMA_STATUS));
+		msleep(10);
+	}
 	if (enable) {
 		aml_write_reg32(START_ADDR, table_paddr);
 		//enable then start it.
@@ -252,6 +263,7 @@ int osd_rdma_enable(u32  enable)
 		start_osd_rdma(RDMA_CHANNEL_INDEX);
 	} else
 		stop_rdma(RDMA_CHANNEL_INDEX);
+	mutex_unlock(&rdma_mutex);
 	return 1;
 }
 EXPORT_SYMBOL(osd_rdma_enable);
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index 86a465e1289b..5525d1f223bc 100755
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -397,8 +397,11 @@ static int lcd_vout_disable(vmode_t cur_vmod)
 }
 
 #ifdef  CONFIG_PM
-static int lcd_suspend(void)
+static int lcd_suspend(int pm_event)
 {
+    /* in freeze process do not turn off the display devices */
+    if (pm_event == PM_EVENT_FREEZE)
+        return 0;
     mutex_lock(&lcd_vout_mutex);
     BUG_ON(pDev==NULL);
     printk("lcd_suspend\n");
@@ -407,8 +410,12 @@ static int lcd_suspend(void)
     mutex_unlock(&lcd_vout_mutex);
     return 0;
 }
-static int lcd_resume(void)
+static int lcd_resume(int pm_event)
 {
+    /* in thaw/restore process do not open the display */
+    if (pm_event == PM_EVENT_THAW
+            || pm_event == PM_EVENT_RESTORE)
+        return 0;
     mutex_lock(&lcd_vout_mutex);
     printk("lcd_resume\n");
     _lcd_module_enable();
diff --git a/drivers/amlogic/display/vout/tvconf.c b/drivers/amlogic/display/vout/tvconf.c
index a57bccc797fc..c2ad124f5de8 100644
--- a/drivers/amlogic/display/vout/tvconf.c
+++ b/drivers/amlogic/display/vout/tvconf.c
@@ -39,6 +39,9 @@
 #include <linux/ctype.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <mach/am_regs.h>
+#ifdef CONFIG_HIBERNATION
+#include <linux/syscore_ops.h>
+#endif
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 #include <mach/vpu.h>
@@ -53,7 +56,8 @@
 
 #define PIN_MUX_REG_0	  0x202c
 #define P_PIN_MUX_REG_0  CBUS_REG_ADDR(PIN_MUX_REG_0)
-static    disp_module_info_t    *info;
+static    disp_module_info_t	disp_module_info __nosavedata;
+static    disp_module_info_t    *info __nosavedata;
 static void  parse_vdac_setting(char *para);
 
 SET_TV_CLASS_ATTR(vdac_setting,parse_vdac_setting)
@@ -1220,8 +1224,11 @@ static int tv_set_vframe_rate_end_hint(void)
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 extern void cvbs_cntl_output(unsigned int open);
 #endif
-static int tv_suspend(void)
+static int tv_suspend(int pm_event)
 {
+	/* in freeze process do not turn off the display devices */
+	if (pm_event == PM_EVENT_FREEZE)
+		return 0;
 	video_dac_disable();
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	cvbs_cntl_output(0);
@@ -1229,8 +1236,12 @@ static int tv_suspend(void)
 
 	return 0;
 }
-static int tv_resume(void)
+static int tv_resume(int pm_event)
 {
+	/* in thaw/restore process do not reset the display mode */
+	if (pm_event == PM_EVENT_THAW
+		|| pm_event == PM_EVENT_RESTORE)
+		return 0;
 	video_dac_enable(0xff);
 	tv_set_current_vmode(info->vinfo->mode);
 	return 0;
@@ -1351,18 +1362,44 @@ static int  create_tv_attr(disp_module_info_t* info)
 
 	return   0;
 }
+
+#ifdef CONFIG_HIBERNATION
+struct class  *info_base_class;
+static int tvconf_suspend(void)
+{
+	info_base_class = info->base_class;
+	return 0;
+}
+
+static void tvconf_resume(void)
+{
+	info->base_class = info_base_class;
+}
+
+static struct syscore_ops tvconf_ops = {
+	.suspend = tvconf_suspend,
+	.resume = tvconf_resume,
+	.shutdown = NULL,
+};
+#endif
+
 static int __init tv_init_module(void)
 {
 	int  ret ;
 
-	info=(disp_module_info_t*)kmalloc(sizeof(disp_module_info_t),GFP_KERNEL) ;
-    printk("%s\n", __func__);
+#ifdef CONFIG_HIBERNATION
+	INIT_LIST_HEAD(&tvconf_ops.node);
+	register_syscore_ops(&tvconf_ops);
+#endif
+
+	info=&disp_module_info;
+	printk("%s\n", __func__);
 
-	if (!info)
+	/*if (!info)
 	{
 		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"can't alloc display info struct\n");
 		return -ENOMEM;
-	}
+	}*/
 	
 	memset(info, 0, sizeof(disp_module_info_t));
 
@@ -1404,7 +1441,7 @@ static __exit void tv_exit_module(void)
 	if(info)
 	{
 		unregister_chrdev(info->major,info->name)	;
-		kfree(info);
+		//kfree(info);
 	}
 	vout_unregister_server(&tv_server);
 	
diff --git a/drivers/amlogic/display/vout/vout_notify.c b/drivers/amlogic/display/vout/vout_notify.c
index 8848c1d5b741..006dca189195 100755
--- a/drivers/amlogic/display/vout/vout_notify.c
+++ b/drivers/amlogic/display/vout/vout_notify.c
@@ -16,8 +16,8 @@
 
 
 static BLOCKING_NOTIFIER_HEAD(vout_notifier_list);
-static  DEFINE_MUTEX(vout_mutex)  ;
-static  vout_module_t  vout_module={
+static DEFINE_MUTEX(vout_mutex);
+static vout_module_t  vout_module={
 		.vout_server_list={&vout_module.vout_server_list,&vout_module.vout_server_list},
 		.curr_vout_server=NULL,	
 };
@@ -147,7 +147,7 @@ void wakeup_early_suspend_proc(void)
 	wake_up_flag = 1;
 }
 #endif
-int vout_suspend(void)
+int vout_suspend(int pm_event)
 {
 	int ret=0 ;
 	vout_server_t  *p_server = vout_module.curr_vout_server;
@@ -166,14 +166,14 @@ int vout_suspend(void)
 	{
 		if(p_server->op.vout_suspend)
 		{
-			ret = p_server->op.vout_suspend() ;
+			ret = p_server->op.vout_suspend(pm_event) ;
 		}
 	}
 	mutex_unlock(&vout_mutex);
 	return ret;
 }
 EXPORT_SYMBOL(vout_suspend);
-int vout_resume(void)
+int vout_resume(int pm_event)
 {
 	vout_server_t  *p_server = vout_module.curr_vout_server;
 
@@ -182,7 +182,7 @@ int vout_resume(void)
 	{
 		if (p_server->op.vout_resume)
 		{
-			p_server->op.vout_resume() ; //ignore error when resume.
+			p_server->op.vout_resume(pm_event) ; //ignore error when resume.
 		}
 	}
 	
@@ -193,6 +193,7 @@ EXPORT_SYMBOL(vout_resume);
 /*
 *interface export to client who want to set current vmode.
 */
+extern void update_vout_mode_attr(const vinfo_t* vinfo);
 int set_current_vmode(vmode_t mode)
 {
 	int r=-1;
@@ -207,6 +208,11 @@ int set_current_vmode(vmode_t mode)
 			vout_module.curr_vout_server=p_server;
 			r=p_server->op.set_vmode(mode);
 			//break;  do not exit , should disable other modules
+			if (vout_module.curr_vout_server)
+			{
+				BUG_ON(vout_module.curr_vout_server->op.get_vinfo == NULL);
+				update_vout_mode_attr(vout_module.curr_vout_server->op.get_vinfo());
+			}
 		}
 		else
 		{
diff --git a/drivers/amlogic/display/vout/vout_serve.c b/drivers/amlogic/display/vout/vout_serve.c
index 4ce12bdb79aa..8aa1e1acabef 100755
--- a/drivers/amlogic/display/vout/vout_serve.c
+++ b/drivers/amlogic/display/vout/vout_serve.c
@@ -64,6 +64,15 @@ SET_VOUT_CLASS_ATTR(axis,set_vout_window)
 SET_VOUT_CLASS_ATTR(wr_reg,write_reg)
 SET_VOUT_CLASS_ATTR(rd_reg,read_reg)
 
+void update_vout_mode_attr(const vinfo_t* vinfo)
+{
+	if (vinfo == NULL) {
+		printk("error vinfo is null\n");
+		return;
+	} else
+		printk("vinfo mode is: %s\n", vinfo->name);
+	snprintf(mode,40,"%s",vinfo->name);
+}
 
 static  vout_info_t	vout_info;
 int power_level=0;
@@ -357,13 +366,13 @@ static int  create_vout_attr(void)
 
 #ifdef  CONFIG_PM
 static int  meson_vout_suspend(struct platform_device *pdev, pm_message_t state)
-{	
+{
 #ifdef CONFIG_HAS_EARLYSUSPEND
     if (early_suspend_flag)
         return 0;
 #endif
-	vout_suspend();
-	return 0;
+    vout_suspend(PM_EVENT_SUSPEND);
+    return 0;
 }
 
 static int  meson_vout_resume(struct platform_device *pdev)
@@ -378,11 +387,31 @@ static int  meson_vout_resume(struct platform_device *pdev)
     if (early_suspend_flag)
         return 0;
 #endif
-	vout_resume();
-	return 0;
+    vout_resume(PM_EVENT_RESUME);
+    return 0;
 }
 #endif 
 
+#ifdef CONFIG_HIBERNATION
+static int  meson_vout_freeze(struct device *dev)
+{
+    vout_suspend(PM_EVENT_FREEZE);
+    return 0;
+}
+
+static int  meson_vout_thaw(struct device *dev)
+{
+    vout_resume(PM_EVENT_THAW);
+    return 0;
+}
+
+static int  meson_vout_restore(struct device *dev)
+{
+    vout_resume(PM_EVENT_RESTORE);
+    return 0;
+}
+#endif
+
 #ifdef CONFIG_SCREEN_ON_EARLY
 void resume_vout_early(void)
 {
@@ -402,7 +431,7 @@ static void meson_vout_early_suspend(struct early_suspend *h)
     if (early_suspend_flag)
         return;
     //meson_vout_suspend((struct platform_device *)h->param, PMSG_SUSPEND);
-    vout_suspend();
+    vout_suspend(PM_EVENT_SUSPEND);
     early_suspend_flag = 1;
 }
 
@@ -412,7 +441,7 @@ static void meson_vout_late_resume(struct early_suspend *h)
         return;
     early_suspend_flag = 0;
     //meson_vout_resume((struct platform_device *)h->param);
-    vout_resume();
+    vout_resume(PM_EVENT_RESUME);
 }
 #endif
 
@@ -477,6 +506,14 @@ static const struct of_device_id meson_vout_dt_match[]={
 	{},
 };
 
+#ifdef CONFIG_HIBERNATION
+struct dev_pm_ops vout_pm = {
+	.freeze		= meson_vout_freeze,
+	.thaw		= meson_vout_thaw,
+	.restore	= meson_vout_restore,
+};
+#endif
+
 static struct platform_driver
 vout_driver = {
     .probe      = meson_vout_probe,
@@ -488,6 +525,9 @@ vout_driver = {
     .driver     = {
         .name   = "mesonvout",
         .of_match_table=meson_vout_dt_match,
+#ifdef CONFIG_HIBERNATION
+        .pm	= &vout_pm,
+#endif
     }
 };
 static int __init vout_init_module(void)
diff --git a/drivers/amlogic/display/vout/vout_serve.h b/drivers/amlogic/display/vout/vout_serve.h
index b9e465ce81a3..3978fff1852b 100755
--- a/drivers/amlogic/display/vout/vout_serve.h
+++ b/drivers/amlogic/display/vout/vout_serve.h
@@ -54,7 +54,7 @@ typedef struct {
 	mutex_unlock(&vout_mutex); }			
 		
 #define    SET_VOUT_CLASS_ATTR(name,op)    \
-static  char    name[40] ;				  \
+static  char    name[40] __nosavedata;				  \
 static ssize_t aml_vout_attr_##name##_show(struct class  * cla, struct class_attribute *attr, char *buf)   \
 {  											\
 	SHOW_INFO(name)  	\
diff --git a/drivers/amlogic/display/vout2/tvconf2.c b/drivers/amlogic/display/vout2/tvconf2.c
index 958706e106c9..b63c54ef23db 100755
--- a/drivers/amlogic/display/vout2/tvconf2.c
+++ b/drivers/amlogic/display/vout2/tvconf2.c
@@ -613,12 +613,12 @@ static int tv_module_disable(vmode_t cur_vmod)
 	return 0;
 }
 #ifdef  CONFIG_PM
-static int tv_suspend(void)
+static int tv_suspend(int pm_event)
 {
 	video_dac_disable();
 	return 0;
 }
-static int tv_resume(void)
+static int tv_resume(int pm_event)
 {
 	video_dac_enable(0xff);
 	tv_set_current_vmode(info->vinfo->mode);
diff --git a/drivers/amlogic/display/vout2/vout2_notify.c b/drivers/amlogic/display/vout2/vout2_notify.c
index 2870740bf460..cc482bdb5371 100755
--- a/drivers/amlogic/display/vout2/vout2_notify.c
+++ b/drivers/amlogic/display/vout2/vout2_notify.c
@@ -89,7 +89,7 @@ vmode_t get_current_vmode2(void)
 	return mode;
 }
 EXPORT_SYMBOL(get_current_vmode2);
-int vout2_suspend(void)
+int vout2_suspend(int pm_event)
 {
 	int ret=0 ;
 	vout_server_t  *p_server = vout_module.curr_vout_server;
@@ -99,7 +99,7 @@ int vout2_suspend(void)
 	{
 		if(p_server->op.vout_suspend)
 		{
-			ret = p_server->op.vout_suspend() ;
+			ret = p_server->op.vout_suspend(pm_event) ;
 		}
 	}
 	
@@ -107,7 +107,7 @@ int vout2_suspend(void)
 	return ret;
 }
 EXPORT_SYMBOL(vout2_suspend);
-int vout2_resume(void)
+int vout2_resume(int pm_event)
 {
 	vout_server_t  *p_server = vout_module.curr_vout_server;
 
@@ -116,7 +116,7 @@ int vout2_resume(void)
 	{
 		if (p_server->op.vout_resume)
 		{
-			p_server->op.vout_resume() ; //ignore error when resume.
+			p_server->op.vout_resume(pm_event) ; //ignore error when resume.
 		}
 	}
 	
diff --git a/drivers/amlogic/ethernet/phy/am_ip101.c b/drivers/amlogic/ethernet/phy/am_ip101.c
index b1a2a27ce52e..f54e7415f30a 100644
--- a/drivers/amlogic/ethernet/phy/am_ip101.c
+++ b/drivers/amlogic/ethernet/phy/am_ip101.c
@@ -54,6 +54,7 @@ MODULE_LICENSE("GPL");
 #define IP101G_DIO_PIN_DCR			0x1a
 #define OFF 1
 #define ON  0
+#if 0
 static void off_analog(struct phy_device *phydev, int off)
 {
 	int ana;
@@ -65,6 +66,7 @@ static void off_analog(struct phy_device *phydev, int off)
 	else
 		phy_write(phydev, IP101G_SPEC_CTRL_STATUS, (ana & ~IP101G_ANALOG_OFF));
 }
+#endif
 static int ip175c_config_init(struct phy_device *phydev)
 {
 	int err, i;
@@ -266,7 +268,9 @@ static int ip101a_g_genphy_suspend(struct phy_device *phydev)
 {
 	int value;
 	printk("**************ip101 sd*****************\n");
+#if 0
 	off_analog(phydev, OFF);
+#endif
 	value = phy_read(phydev, MII_BMCR);
 	phy_write(phydev, MII_BMCR, (value | BMCR_PDOWN));
 	return 0;
@@ -275,7 +279,9 @@ static int ip101a_g_genphy_resume(struct phy_device *phydev)
 {
 	int value;
 	printk("**************ip101 re*****************\n");
+#if 0
 	off_analog(phydev, ON);
+#endif
 	value = phy_read(phydev, MII_BMCR);
 	phy_write(phydev, MII_BMCR, (value & ~BMCR_PDOWN));
 	return 0;
diff --git a/drivers/amlogic/ethernet/phy/am_rtl8211f.c b/drivers/amlogic/ethernet/phy/am_rtl8211f.c
old mode 100755
new mode 100644
index d64b1af6c24d..47e5ab2be5e4
--- a/drivers/amlogic/ethernet/phy/am_rtl8211f.c
+++ b/drivers/amlogic/ethernet/phy/am_rtl8211f.c
@@ -40,6 +40,21 @@ static int rtl8211e_config_intr(struct phy_device *phydev)
 static int rtl8211e_config_init(struct phy_device *phydev)
 {
 	int val;
+	int bmcr;
+	/* pr_info("aml_init_rtl8211f phy\n"); */
+	bmcr = phy_read(phydev, MII_BMCR);
+	if (bmcr < 0)
+		return bmcr;
+	bmcr |= BMCR_RESET;
+	bmcr = phy_write(phydev, MII_BMCR, bmcr);
+	if (bmcr < 0)
+		return bmcr;
+
+	do {
+		bmcr = phy_read(phydev, MII_BMCR);
+		if (bmcr < 0)
+			return bmcr;
+	} while (bmcr & BMCR_RESET);
 /* we want to disable eee */
         phy_write(phydev, RTL8211F_MMD_CTRL, 0x7);
 
diff --git a/drivers/amlogic/instaboot/Makefile b/drivers/amlogic/instaboot/Makefile
new file mode 100644
index 000000000000..07501d6d9661
--- /dev/null
+++ b/drivers/amlogic/instaboot/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_HIBERNATION) += instaboot_hook.o instaboot_kernel.o
\ No newline at end of file
diff --git a/drivers/amlogic/instaboot/instaboot_hook.c b/drivers/amlogic/instaboot/instaboot_hook.c
new file mode 100644
index 000000000000..928fc1b51d66
--- /dev/null
+++ b/drivers/amlogic/instaboot/instaboot_hook.c
@@ -0,0 +1,225 @@
+#include <linux/amlogic/instaboot/instaboot.h>
+#include <linux/kernel.h>
+#include <linux/mm_types.h>
+
+static aml_istbt_int_void_fun_t aml_istbt_dev_ready_hook = NULL;
+int aml_istbt_dev_ready(void)
+{
+	if (aml_istbt_dev_ready_hook)
+		return aml_istbt_dev_ready_hook();
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+		return -1;
+	}
+}
+
+static aml_istbt_void_fmode_fun_t aml_istbt_swsusp_close_hook = NULL;
+void swsusp_close(fmode_t mode)
+{
+	if (aml_istbt_swsusp_close_hook)
+		aml_istbt_swsusp_close_hook(mode);
+	else
+		pr_err("%s NULL\n", __FUNCTION__);
+}
+
+static aml_istbt_int_uintp_func_t aml_istbt_swsusp_read_hook = NULL;
+int swsusp_read(unsigned int *flags_p)
+{
+	if (aml_istbt_swsusp_read_hook)
+		return aml_istbt_swsusp_read_hook(flags_p);
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+		return -1;
+	}
+}
+
+static aml_istbt_int_uint_func_t aml_istbt_swsusp_write_hook = NULL;
+int swsusp_write(unsigned int flags)
+{
+	if (aml_istbt_swsusp_write_hook)
+		return aml_istbt_swsusp_write_hook(flags);
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+		return -1;
+	}
+}
+
+static aml_istbt_int_int_func_t aml_istbt_swsusp_check_hook = NULL;
+int swsusp_check(int wrapsnapshot)
+{
+	if (aml_istbt_swsusp_check_hook)
+		return aml_istbt_swsusp_check_hook(wrapsnapshot);
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+		return -1;
+	}
+}
+
+static aml_istbt_int_void_fun_t aml_istbt_swsusp_unmark_hook = NULL;
+int swsusp_unmark(void)
+{
+	if (aml_istbt_swsusp_unmark_hook)
+		return aml_istbt_swsusp_unmark_hook();
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+		return -1;
+	}
+}
+
+static aml_istbt_void_voidp_int_func_t aml_istbt_free_image_page_hook = NULL;
+void istbt_free_image_page(void *addr, int clear_nosave_free)
+{
+	if (aml_istbt_free_image_page_hook)
+		aml_istbt_free_image_page_hook(addr, clear_nosave_free);
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+	}
+	return;
+}
+
+static aml_istbt_pagep_gfp_func_t aml_istbt_alloc_image_page_hook = NULL;
+struct page *istbt_alloc_image_page(gfp_t gfp_mask)
+{
+	if (aml_istbt_alloc_image_page_hook)
+		return aml_istbt_alloc_image_page_hook(gfp_mask);
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+		return NULL;
+	}
+}
+
+static aml_istbt_int_ulong_func_t aml_istbt_pfn_touchable_hook = NULL;
+int istbt_pfn_touchable(unsigned long pfn)
+{
+	if (aml_istbt_pfn_touchable_hook)
+		return aml_istbt_pfn_touchable_hook(pfn);
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+		return -1;
+	}
+}
+
+static aml_istbt_void_ulong_func_t aml_istbt_pfn_destory_hook = NULL;
+void istbt_pfn_destory(unsigned long pfn)
+{
+	if (aml_istbt_pfn_destory_hook)
+		aml_istbt_pfn_destory_hook(pfn);
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+	}
+	return;
+}
+
+static aml_istbt_void_longp_longp_func_t aml_istbt_copy_page_hook = NULL;
+void istbt_copy_page(long *dst, long *src)
+{
+	if (aml_istbt_copy_page_hook)
+		aml_istbt_copy_page_hook(dst, src);
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+	}
+	return;
+}
+
+static aml_istbt_int_void_fun_t aml_istbt_init_mem_hook = NULL;
+int istbt_init_mem(void)
+{
+	if (aml_istbt_init_mem_hook)
+		return aml_istbt_init_mem_hook();
+	else {
+		pr_err("%s NULL\n", __FUNCTION__);
+		return -1;
+	}
+}
+
+int aml_istbt_reg_fun(aml_istbt_fun_t fun_type, void* fun_p)
+{
+	switch (fun_type) {
+	case AML_ISTBT_DEV_READY:
+		aml_istbt_dev_ready_hook = fun_p;
+		break;
+	case AML_ISTBT_SWSUSP_CLOSE:
+		aml_istbt_swsusp_close_hook = fun_p;
+		break;
+	case AML_ISTBT_SWSUSP_READ:
+		aml_istbt_swsusp_read_hook = fun_p;
+		break;
+	case AML_ISTBT_SWSUSP_WRITE:
+		aml_istbt_swsusp_write_hook = fun_p;
+		break;
+	case AML_ISTBT_SWSUSP_CHECK:
+		aml_istbt_swsusp_check_hook = fun_p;
+		break;
+	case AML_ISTBT_SWSUSP_UNMARK:
+		aml_istbt_swsusp_unmark_hook = fun_p;
+		break;
+	case AML_ISTBT_ALLOC_IMAGE_PAGE:
+		aml_istbt_alloc_image_page_hook = fun_p;
+		break;
+	case AML_ISTBT_FREE_IMAGE_PAGE:
+		aml_istbt_free_image_page_hook = fun_p;
+		break;
+	case AML_ISTBT_INIT_MEM:
+		aml_istbt_init_mem_hook = fun_p;
+		break;
+	case AML_ISTBT_PFN_TOUCHABLE:
+		aml_istbt_pfn_touchable_hook = fun_p;
+		break;
+	case AML_ISTBT_PFN_DESTORY:
+		aml_istbt_pfn_destory_hook = fun_p;
+		break;
+	case AML_ISTBT_COPY_PAGE:
+		aml_istbt_copy_page_hook = fun_p;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(aml_istbt_reg_fun);
+
+int aml_istbt_unreg_fun(aml_istbt_fun_t fun_type)
+{
+	switch (fun_type) {
+	case AML_ISTBT_DEV_READY:
+		aml_istbt_dev_ready_hook = NULL;
+		break;
+	case AML_ISTBT_SWSUSP_CLOSE:
+		aml_istbt_swsusp_close_hook = NULL;
+		break;
+	case AML_ISTBT_SWSUSP_READ:
+		aml_istbt_swsusp_read_hook = NULL;
+		break;
+	case AML_ISTBT_SWSUSP_WRITE:
+		aml_istbt_swsusp_write_hook = NULL;
+		break;
+	case AML_ISTBT_SWSUSP_CHECK:
+		aml_istbt_swsusp_check_hook = NULL;
+		break;
+	case AML_ISTBT_SWSUSP_UNMARK:
+		aml_istbt_swsusp_unmark_hook = NULL;
+		break;
+	case AML_ISTBT_ALLOC_IMAGE_PAGE:
+		aml_istbt_alloc_image_page_hook = NULL;
+		break;
+	case AML_ISTBT_FREE_IMAGE_PAGE:
+		aml_istbt_free_image_page_hook = NULL;
+		break;
+	case AML_ISTBT_INIT_MEM:
+		aml_istbt_init_mem_hook = NULL;
+		break;
+	case AML_ISTBT_PFN_TOUCHABLE:
+		aml_istbt_pfn_touchable_hook = NULL;
+		break;
+	case AML_ISTBT_PFN_DESTORY:
+		aml_istbt_pfn_destory_hook = NULL;
+		break;
+	case AML_ISTBT_COPY_PAGE:
+		aml_istbt_copy_page_hook = NULL;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(aml_istbt_unreg_fun);
\ No newline at end of file
diff --git a/drivers/amlogic/instaboot/instaboot_kernel.c b/drivers/amlogic/instaboot/instaboot_kernel.c
new file mode 100644
index 000000000000..a37a1eb93e28
--- /dev/null
+++ b/drivers/amlogic/instaboot/instaboot_kernel.c
@@ -0,0 +1,141 @@
+#include <linux/amlogic/instaboot/instaboot.h>
+#include <linux/export.h>
+#include <linux/atomic.h>
+#include <linux/init.h>
+#include <linux/printk.h>
+
+atomic_t snapshot_device_available = ATOMIC_INIT(1);
+
+extern int snapshot_read_next(struct snapshot_handle *handle);
+int aml_snapshot_read_next(struct snapshot_handle *handle)
+{
+	return snapshot_read_next(handle);
+}
+EXPORT_SYMBOL(aml_snapshot_read_next);
+
+extern int snapshot_write_next(struct snapshot_handle *handle);
+int aml_snapshot_write_next(struct snapshot_handle *handle)
+{
+	return snapshot_write_next(handle);
+}
+EXPORT_SYMBOL(aml_snapshot_write_next);
+
+extern void snapshot_write_finalize(struct snapshot_handle *handle);
+void aml_snapshot_write_finalize(struct snapshot_handle *handle)
+{
+	snapshot_write_finalize(handle);
+}
+EXPORT_SYMBOL(aml_snapshot_write_finalize);
+
+extern unsigned long snapshot_get_image_size(void);
+unsigned long aml_snapshot_get_image_size(void)
+{
+	return snapshot_get_image_size();
+}
+EXPORT_SYMBOL(aml_snapshot_get_image_size);
+
+extern int snapshot_image_loaded(struct snapshot_handle *handle);
+int aml_snapshot_image_loaded(struct snapshot_handle *handle)
+{
+	return snapshot_image_loaded(handle);
+}
+EXPORT_SYMBOL(aml_snapshot_image_loaded);
+
+extern dev_t swsusp_resume_device;
+dev_t aml_get_swsusp_resume_device(void)
+{
+	printk("swsusp_resume_device: %u\n", (unsigned int)swsusp_resume_device);
+	return swsusp_resume_device;
+}
+EXPORT_SYMBOL(aml_get_swsusp_resume_device);
+
+extern void end_swap_bio_read(struct bio *bio, int err);
+end_swap_bio_read_p_t aml_get_end_swap_bio_read(void)
+{
+	end_swap_bio_read_p_t fun_p;
+	fun_p = end_swap_bio_read;
+	return end_swap_bio_read;
+}
+EXPORT_SYMBOL(aml_get_end_swap_bio_read);
+
+extern unsigned int nr_free_highpages (void);
+unsigned int aml_nr_free_highpages (void)
+{
+	return nr_free_highpages();
+}
+EXPORT_SYMBOL(aml_nr_free_highpages);
+
+extern void bio_set_pages_dirty(struct bio *bio);
+void aml_bio_set_pages_dirty(struct bio *bio)
+{
+	bio_set_pages_dirty(bio);
+}
+EXPORT_SYMBOL(aml_bio_set_pages_dirty);
+
+/*
+   in kernel booting process, acquire some memory for device probe,
+   which will not be crush when recovery the instaboot image.
+*/
+static int alloc_permission = 1;
+struct reserve_mem{
+	unsigned long long startaddr;
+	unsigned long long size;
+	unsigned int flag;		/* 0: high memory  1:low memory */
+	char name[16];			/* limit: device name must < 14; */
+};
+
+#define MAX_RESERVE_BLOCK  32
+
+struct reserve_mgr{
+	int count;
+	unsigned long long start_memory_addr;
+	unsigned long long total_memory;
+	unsigned long long current_addr_from_low;
+	unsigned long long current_addr_from_high;
+	struct reserve_mem reserve[MAX_RESERVE_BLOCK];
+};
+
+extern struct reserve_mgr *get_reserve_mgr(void);
+extern unsigned long long get_reserve_base(void);
+
+void* aml_boot_alloc_mem(size_t size)
+{
+	phys_addr_t buf;
+	struct reserve_mgr* rsv_mgr;
+	struct reserve_mem* prm;
+	unsigned long addr = 0;
+	int i;
+	unsigned long long base_addr;
+
+	if (!alloc_permission) {
+		pr_err("%s can only be useful in booting time\n", __FUNCTION__);
+		return NULL;
+	}
+
+	base_addr = get_reserve_base();
+
+	rsv_mgr = get_reserve_mgr();
+	if (!rsv_mgr)
+		return NULL;
+
+	for (i = 0; i < rsv_mgr->count; i++) {
+		prm = &rsv_mgr->reserve[i];
+		if ((!(prm->flag & 2)) && prm->size > size) {
+			addr = (unsigned long)(prm->startaddr + base_addr);
+			break;
+		}
+	}
+
+	buf = (phys_addr_t)phys_to_virt(addr);
+	/* pr_info("alloc nosave buffer: 0x%x\n", buf); */
+
+	return (void*)buf;
+}
+EXPORT_SYMBOL(aml_boot_alloc_mem);
+
+static int __init aml_boot_complete(void)
+{
+	alloc_permission = 0;
+	return 0;
+}
+late_initcall(aml_boot_complete);
\ No newline at end of file
diff --git a/drivers/amlogic/power/aml_pmu/aml1216-sply.c b/drivers/amlogic/power/aml_pmu/aml1216-sply.c
index eb3917a5a730..5007dbf6d681 100755
--- a/drivers/amlogic/power/aml_pmu/aml1216-sply.c
+++ b/drivers/amlogic/power/aml_pmu/aml1216-sply.c
@@ -50,7 +50,7 @@
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static struct early_suspend aml1216_early_suspend;
 static int    in_early_suspend = 0; 
-static int    early_power_status = 0;
+static int    early_power_status = -1;
 static struct wake_lock aml1216_lock;
 #endif
 struct aml1216_supply           *g_aml1216_supply  = NULL;
@@ -1453,7 +1453,7 @@ static void aml1216_lateresume(struct early_suspend *h)
         input_report_key(aml1216_power_key, KEY_POWER, 0);                  // cancel power key 
         input_sync(aml1216_power_key);
     }
-    early_power_status = supply->aml_charger.ext_valid; 
+    early_power_status = -1;
     in_early_suspend = 0;
     wake_unlock(&aml1216_lock);
 }
@@ -1704,7 +1704,7 @@ static int aml1216_suspend(struct platform_device *dev, pm_message_t state)
         }
     }
 #ifdef CONFIG_HAS_EARLYSUSPEND
-    if (early_power_status != supply->aml_charger.ext_valid) {
+    if ((early_power_status != supply->aml_charger.ext_valid) && (early_power_status != -1)) {
         AML1216_DBG("%s, power status changed, prev:%x, now:%x, exit suspend process\n", 
                 __func__, early_power_status, supply->aml_charger.ext_valid);
         input_report_key(aml1216_power_key, KEY_POWER, 1);              // assume power key pressed 
diff --git a/drivers/amlogic/power/aml_pmu/aml1218-sply.c b/drivers/amlogic/power/aml_pmu/aml1218-sply.c
index 0466823aaf5f..437e1494c68e 100755
--- a/drivers/amlogic/power/aml_pmu/aml1218-sply.c
+++ b/drivers/amlogic/power/aml_pmu/aml1218-sply.c
@@ -50,7 +50,7 @@
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static struct early_suspend aml1218_early_suspend;
 static int    in_early_suspend = 0; 
-static int    early_power_status = 0;
+static int    early_power_status = -1;
 static struct wake_lock aml1218_lock;
 #endif
 struct aml1218_supply           *g_aml1218_supply  = NULL;
@@ -1480,7 +1480,7 @@ static void aml1218_lateresume(struct early_suspend *h)
         input_report_key(aml1218_power_key, KEY_POWER, 0);                  // cancel power key 
         input_sync(aml1218_power_key);
     }
-    early_power_status = supply->aml_charger.ext_valid; 
+    early_power_status = -1;
     in_early_suspend = 0;
     wake_unlock(&aml1218_lock);
 }
@@ -1731,7 +1731,7 @@ static int aml1218_suspend(struct platform_device *dev, pm_message_t state)
         }
     }
 #ifdef CONFIG_HAS_EARLYSUSPEND
-    if (early_power_status != supply->aml_charger.ext_valid) {
+    if ((early_power_status != supply->aml_charger.ext_valid) && (early_power_status != -1)) {
         AML1218_DBG("%s, power status changed, prev:%x, now:%x, exit suspend process\n", 
                 __func__, early_power_status, supply->aml_charger.ext_valid);
         input_report_key(aml1218_power_key, KEY_POWER, 1);              // assume power key pressed 
diff --git a/drivers/amlogic/power/axp_power/axp20-sply.c b/drivers/amlogic/power/axp_power/axp20-sply.c
index 2f136ab719d7..f6b6b6697b3f 100755
--- a/drivers/amlogic/power/axp_power/axp20-sply.c
+++ b/drivers/amlogic/power/axp_power/axp20-sply.c
@@ -1689,7 +1689,7 @@ static void axp_charging_monitor(struct work_struct *work)
 
 
 #if defined CONFIG_HAS_EARLYSUSPEND
-static int early_power_status = 0;
+static int early_power_status = -1;
 static void axp_earlysuspend(struct early_suspend *h)
 {
     struct axp20_supply *supply = (struct axp20_supply *)h->param;
@@ -1713,7 +1713,7 @@ static void axp_lateresume(struct early_suspend *h)
     axp_set_charge_current(axp_pmu_battery->pmu_resume_chgcur);     //set charging current
 #endif
     if (axp_pmu_battery) {
-        early_power_status = supply->aml_charger.ext_valid;
+        early_power_status = -1;
         input_report_key(powerkeydev, KEY_POWER, 0);                    // cancel power key 
         input_sync(powerkeydev);
     }
@@ -1995,7 +1995,7 @@ static int axp20_suspend(struct platform_device *dev, pm_message_t state)
         api->pmu_suspend_process(charger);
     }
 #ifdef CONFIG_HAS_EARLYSUSPEND
-    if (early_power_status != supply->aml_charger.ext_valid) {
+    if ((early_power_status != supply->aml_charger.ext_valid) && (early_power_status != -1)) {
         AXP_PMU_DBG("%s, power status changed, prev:%x, now:%x, exit suspend process\n",
                     __func__, early_power_status, supply->aml_charger.ext_valid);
         input_report_key(powerkeydev, KEY_POWER, 1);                    // assume power key pressed 
diff --git a/drivers/amlogic/power/ricoh/rn5t618-sply.c b/drivers/amlogic/power/ricoh/rn5t618-sply.c
index 4088cdf7bd5c..cc557936327c 100755
--- a/drivers/amlogic/power/ricoh/rn5t618-sply.c
+++ b/drivers/amlogic/power/ricoh/rn5t618-sply.c
@@ -1447,7 +1447,7 @@ static void rn5t618_charging_monitor(struct work_struct *work)
 }
 
 #if defined CONFIG_HAS_EARLYSUSPEND
-static int early_power_status = 0;
+static int early_power_status = -1;
 static void rn5t618_earlysuspend(struct early_suspend *h)
 {
     struct rn5t618_supply *supply = (struct rn5t618_supply *)h->param;
@@ -1465,7 +1465,7 @@ static void rn5t618_lateresume(struct early_suspend *h)
     schedule_work(&supply->work.work);                                      // update for upper layer 
     if (rn5t618_battery) {
         rn5t618_set_charge_current(rn5t618_battery->pmu_resume_chgcur);
-        early_power_status = supply->aml_charger.ext_valid; 
+        early_power_status = -1;
         input_report_key(rn5t618_power_key, KEY_POWER, 0);                  // cancel power key 
         input_sync(rn5t618_power_key);
     }
@@ -1744,7 +1744,7 @@ static int rn5t618_suspend(struct platform_device *dev, pm_message_t state)
         } 
     }
 #ifdef CONFIG_HAS_EARLYSUSPEND
-    if (early_power_status != supply->aml_charger.ext_valid) {
+    if ((early_power_status != supply->aml_charger.ext_valid) && (early_power_status != -1)) {
         RICOH_DBG("%s, power status changed, prev:%x, now:%x, exit suspend process\n", 
                   __func__, early_power_status, supply->aml_charger.ext_valid);
         input_report_key(rn5t618_power_key, KEY_POWER, 1);              // assume power key pressed 
diff --git a/drivers/amlogic/uart/uart/meson_uart.c b/drivers/amlogic/uart/uart/meson_uart.c
old mode 100755
new mode 100644
index 18b12130e558..c7e861624dfa
--- a/drivers/amlogic/uart/uart/meson_uart.c
+++ b/drivers/amlogic/uart/uart/meson_uart.c
@@ -129,8 +129,13 @@ struct meson_uart_port {
 
 	wait_queue_head_t	open_wait;
 	wait_queue_head_t	close_wait;
-    /* bt wake control ops */
-    struct bt_wake_ops *bt_ops;
+	/* bt wake control ops */
+	struct bt_wake_ops *bt_ops;
+
+	/* hibernation reg saving */
+#ifdef CONFIG_HIBERNATION
+	am_uart_t regv;
+#endif
 
 	spinlock_t rd_lock;
 	spinlock_t wr_lock;
@@ -1159,6 +1164,41 @@ static int meson_uart_suspend(struct platform_device *pdev, pm_message_t state)
     return 0;
 }
 
+#ifdef CONFIG_HIBERNATION
+static int meson_uart_freeze(struct device *dev)
+{
+    struct platform_device *pdev;
+    struct meson_uart_port *mup;
+
+    pdev = to_platform_device(dev);
+    mup = (struct meson_uart_port *)platform_get_drvdata(pdev);
+
+    mup->regv.mode = readl(&(mup->uart->mode));
+
+    printk("%s freeze, mode: %lx\n", mup->name, mup->regv.mode);
+
+    return 0;
+}
+
+static int meson_uart_thaw(struct device *dev)
+{
+    return 0;
+}
+
+static int meson_uart_restore(struct device *dev)
+{
+    struct platform_device *pdev;
+    struct meson_uart_port *mup;
+
+    pdev = to_platform_device(dev);
+    mup = (struct meson_uart_port *)platform_get_drvdata(pdev);
+
+    writel(mup->regv.mode, &(mup->uart->mode));
+    printk("%s restore, mode: %x\n", mup->name, readl(&(mup->uart->mode)));
+    return 0;
+}
+#endif
+
 struct console meson_serial_console = {
 	.name		= MESON_SERIAL_NAME,
 	.write		= meson_serial_console_write,
@@ -1232,6 +1272,14 @@ static struct uart_driver meson_uart_driver = {
 	.minor		= MESON_SERIAL_MINOR,
 };
 
+#ifdef CONFIG_HIBERNATION
+struct dev_pm_ops meson_uart_pm = {
+	.freeze		= meson_uart_freeze,
+	.thaw		= meson_uart_thaw,
+	.restore	= meson_uart_restore,
+};
+#endif
+
 static  struct platform_driver meson_uart_platform_driver = {
 	.probe		= meson_uart_probe,
 	.remove		= meson_uart_remove,
@@ -1242,6 +1290,9 @@ static  struct platform_driver meson_uart_platform_driver = {
 		.name	= "mesonuart",
 		.owner	= THIS_MODULE,
 		.of_match_table=meson_uart_dt_match,
+#ifdef CONFIG_HIBERNATION
+		.pm	= &meson_uart_pm,
+#endif
 	},
 };
 void get_next_node(struct meson_uart_list *cur_col, struct meson_uart_struct *co_struct,
diff --git a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.c b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.c
index 0820de183fe6..f52eba0303c3 100755
--- a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.c
+++ b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.c
@@ -520,7 +520,9 @@ int dwc_otg_hcd_suspend(dwc_otg_hcd_t * hcd)
 {
 	hcd->core_if->suspend_mode = 1;
 	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD SUSPEND\n");
-	dwc_otg_hcd_power_save(hcd, 0);
+
+	if (!hcd->pm_freeze_flag)
+		dwc_otg_hcd_power_save(hcd, 0);
 
  	return 0;
 }
@@ -529,7 +531,6 @@ extern void dwc_otg_power_notifier_call(char is_power_on);
 /** dwc_otg_hcd resume  */
 int dwc_otg_hcd_resume(dwc_otg_hcd_t *hcd)
 {
-
 	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD RESUME\n");
 
 	hcd->ssplit_lock = 0;
@@ -540,7 +541,9 @@ int dwc_otg_hcd_resume(dwc_otg_hcd_t *hcd)
 	}
 
 	hcd->core_if->suspend_mode = 0;
-	dwc_otg_hcd_power_save(hcd, 1);
+
+	if (!hcd->pm_freeze_flag)
+		dwc_otg_hcd_power_save(hcd, 1);
 	
 	return 0;
 }
diff --git a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.h b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.h
index c27513e94f21..7a6244600006 100755
--- a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.h
+++ b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd.h
@@ -576,6 +576,7 @@ struct dwc_otg_hcd {
 #endif
 	uint8_t  ssplit_lock;
 	uint8_t  auto_pm_suspend_flag;
+	uint8_t  pm_freeze_flag;
 };
 
 /** @name Transaction Execution Functions */
@@ -824,4 +825,4 @@ void dwc_otg_hcd_save_data_toggle(dwc_hc_t * hc,
 #define dwc_sample_frrem(_hcd, _qh, _letter)
 #endif
 #endif
-#endif /* DWC_DEVICE_ONLY */
\ No newline at end of file
+#endif /* DWC_DEVICE_ONLY */
diff --git a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd_linux.c b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd_linux.c
index 2c3f83c38e9a..9e143c3b3c3b 100755
--- a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd_linux.c
+++ b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_hcd_linux.c
@@ -717,11 +717,13 @@ int hcd_suspend(struct usb_hcd *hcd)
 {
 	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd);
 	dwc_otg_hcd->auto_pm_suspend_flag = (hcd->flags>>31)&1;
+	dwc_otg_hcd->pm_freeze_flag = (hcd->flags >> 30) & 1;
 
 	DWC_DEBUGPL(DBG_HCD, "HCD SUSPEND\n");
 
 	dwc_otg_hcd_suspend(dwc_otg_hcd);
 	hcd->flags &= (~(1<<31));
+	hcd->flags &= (~(1<<30));
 
 	return 0;
 }
@@ -731,11 +733,14 @@ int hcd_resume(struct usb_hcd *hcd)
 {
 	dwc_otg_hcd_t *dwc_otg_hcd = hcd_to_dwc_otg_hcd(hcd);
 	dwc_otg_hcd->auto_pm_suspend_flag = (hcd->flags>>31)&1;
-	
+	dwc_otg_hcd->pm_freeze_flag = (hcd->flags >> 30) & 1;
+
 	DWC_DEBUGPL(DBG_HCD, "HCD RESUME\n");
-	
+
 	dwc_otg_hcd_resume(dwc_otg_hcd);
 	hcd->flags &= (~(1<<31));
+	hcd->flags &= (~(1<<30));
+
 	return 0;
 }
 
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index df62645b3677..cef7ad3035ef 100755
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -234,15 +234,24 @@ static pm_callback_t pm_op(const struct dev_pm_ops *ops, pm_message_t state)
 #ifdef CONFIG_HIBERNATE_CALLBACKS
 	case PM_EVENT_FREEZE:
 	case PM_EVENT_QUIESCE:
-		return ops->freeze;
+		if (ops->freeze)
+			return ops->freeze;
+		else
+			return ops->suspend;
 	case PM_EVENT_HIBERNATE:
 		return ops->poweroff;
 	case PM_EVENT_THAW:
 	case PM_EVENT_RECOVER:
-		return ops->thaw;
+		if (ops->thaw)
+			return ops->thaw;
+		else
+			return ops->resume;
 		break;
 	case PM_EVENT_RESTORE:
-		return ops->restore;
+		if (ops->restore)
+			return ops->restore;
+		else
+			return ops->resume;
 #endif /* CONFIG_HIBERNATE_CALLBACKS */
 	}
 
@@ -1190,6 +1199,7 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 	pr_info("suspend %s+ @ %i, parent: %s\n",
 				dev_name(dev), task_pid_nr(current),
 				dev->parent ? dev_name(dev->parent) : "none");
+
 	error = dpm_run_callback(callback, dev, state, info);
 
  End:
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
index 65f6a8d09f54..297eee00c57b 100755
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
@@ -262,10 +262,6 @@ int stmmac_mdio_register(struct net_device *ndev)
 				irqlist[addr] = mdio_bus_data->probed_phy_irq;
 				phydev->irq = mdio_bus_data->probed_phy_irq;
 			}
-#ifdef CONFIG_DWMAC_MESON
-			irqlist[addr] = PHY_POLL;
-			phydev->irq = PHY_POLL;
-#endif
 			/*
 			 * If we're  going to bind the MAC to this PHY bus,
 			 * and no PHY number was provided to the MAC,
@@ -273,6 +269,14 @@ int stmmac_mdio_register(struct net_device *ndev)
 			 */
 			if (priv->plat->phy_addr == -1)
 				priv->plat->phy_addr = addr;
+#ifdef CONFIG_DWMAC_MESON
+			if (!((phydev->phy_id  == 0x001cc916)&& (addr == 0)))
+			{
+				priv->plat->phy_addr = addr;
+				phydev->irq = PHY_POLL;
+				irqlist[addr] = PHY_POLL;
+			}
+#endif
 
 			act = (priv->plat->phy_addr == addr);
 			switch (phydev->irq) {
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
index 23bc67d1e477..476af12fc9d3 100755
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -471,26 +471,18 @@ static int stmmac_pltfr_resume(struct device *dev)
 int stmmac_pltfr_freeze(struct device *dev)
 {
         int ret;
-        struct plat_stmmacenet_data *plat_dat = dev_get_platdata(dev);
         struct net_device *ndev = dev_get_drvdata(dev);
-        struct platform_device *pdev = to_platform_device(dev);
 
         ret = stmmac_freeze(ndev);
-        if (plat_dat->exit)
-		plat_dat->exit(pdev, plat_dat->bsp_priv);
 
         return ret;
 }
 
 int stmmac_pltfr_restore(struct device *dev)
 {
-        struct plat_stmmacenet_data *plat_dat = dev_get_platdata(dev);
         struct net_device *ndev = dev_get_drvdata(dev);
-        struct platform_device *pdev = to_platform_device(dev);
-
-        if (plat_dat->init)
-                plat_dat->init(pdev,plat_dat->bsp_priv);
-
+        printk("ethernet--------------------->restore ethernet\n");
+        //return stmmac_resume(ndev);
         return stmmac_restore(ndev);
 }
 
diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 4c95d754dfd7..187a97acfb17 100755
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -655,7 +655,6 @@ struct reserve_mgr{
 struct reserve_mgr Reserve_Manager;
 struct reserve_mgr * pReserve_Manager;
 
-
 int init_reserve_mgr(void)
 {
 	pReserve_Manager = &Reserve_Manager;
@@ -665,11 +664,23 @@ int init_reserve_mgr(void)
 	return 0;
 }
 
+struct reserve_mgr *get_reserve_mgr(void)
+{
+	return pReserve_Manager;
+}
+EXPORT_SYMBOL(get_reserve_mgr);
+
 unsigned long long get_reserve_end(void)
 {
 	return pReserve_Manager->current_addr_from_low+aml_reserved_start+EARLY_RESERVED_MEM_SIZE-1;
 }
 
+unsigned long long get_reserve_base(void)
+{
+	return aml_reserved_start+EARLY_RESERVED_MEM_SIZE;
+}
+EXPORT_SYMBOL(get_reserve_base);
+
 unsigned long long get_high_reserve_size(void)
 {
 	return pReserve_Manager->current_addr_from_high;
@@ -746,6 +757,7 @@ int __init early_init_dt_scan_reserve_memory(unsigned long node, const char *una
 {
 	__be32 *mem, *endp;
 	char * need_iomap=NULL;
+	char * hib_use=NULL;
 	unsigned int iomap_flag = 0;
 	unsigned long l;
 	int idx=0;
@@ -770,6 +782,12 @@ int __init early_init_dt_scan_reserve_memory(unsigned long node, const char *una
 			iomap_flag = 1;
 		}
 
+		hib_use = of_get_flat_dt_prop(node,"mem-usable",&l);
+		if (hib_use && (strcmp(hib_use,"false") == 0))
+		{
+			iomap_flag |= 2;
+		}
+
 		prm = &pReserve_Manager->reserve[pReserve_Manager->count];
 
 		if(iomap_flag)
@@ -901,6 +919,7 @@ int __init early_init_dt_scan_memory(unsigned long node, const char *uname,
 				prm->startaddr + aml_reserved_start+EARLY_RESERVED_MEM_SIZE ,
 				prm->startaddr + prm->size + aml_reserved_start+EARLY_RESERVED_MEM_SIZE,
 				(unsigned long)(prm->size >> 20));
+
 		}
 		else
 		{
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index c71200421024..dd84cb49215b 100755
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2051,6 +2051,9 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 		hcd->state = HC_STATE_QUIESCING;
 		if(PMSG_IS_AUTO(msg))
 			hcd->flags |= (1<<31);
+		if (PMSG_IS_HIBERNATION(msg))
+			hcd->flags |= (1<<30);
+
 		status = hcd->driver->bus_suspend(hcd);
 	}
 	if (status == 0) {
@@ -2099,8 +2102,12 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 		return 0;
 
 	hcd->state = HC_STATE_RESUMING;
+
 	if(PMSG_IS_AUTO(msg))
 		hcd->flags |= (1<<31);
+	if (PMSG_IS_HIBERNATION(msg))
+		hcd->flags |= (1<<30);
+
 	status = hcd->driver->bus_resume(hcd);
 	clear_bit(HCD_FLAG_WAKEUP_PENDING, &hcd->flags);
 	if (status == 0) {
diff --git a/include/linux/amlogic/instaboot/instaboot.h b/include/linux/amlogic/instaboot/instaboot.h
new file mode 100644
index 000000000000..0f2435eaa5d4
--- /dev/null
+++ b/include/linux/amlogic/instaboot/instaboot.h
@@ -0,0 +1,65 @@
+#ifndef _INSTABOOT_H__
+#define _INSTABOOT_H__
+#include <linux/bio.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+struct snapshot_handle;
+typedef int (* aml_istbt_int_void_fun_t)(void);
+typedef void (* aml_istbt_void_fmode_fun_t)(fmode_t mode);
+typedef int (* aml_istbt_int_uintp_func_t)(unsigned int* p);
+typedef int (* aml_istbt_int_uint_func_t)(unsigned int ui);
+typedef int (* aml_istbt_int_int_func_t)(int i);
+typedef void (* end_swap_bio_read_p_t)(struct bio *bio, int err);
+typedef void (* aml_istbt_void_voidp_int_func_t)(void *, int);
+typedef struct page* (* aml_istbt_pagep_gfp_func_t)(gfp_t );
+typedef int (* aml_istbt_int_ulong_func_t)(unsigned long);
+typedef void (* aml_istbt_void_ulong_func_t)(unsigned long);
+typedef void (* aml_istbt_void_longp_longp_func_t)(long *, long *);
+
+typedef enum {
+	AML_ISTBT_DEV_READY = 0,
+	AML_ISTBT_SWSUSP_CLOSE,
+	AML_ISTBT_SWSUSP_READ,
+	AML_ISTBT_SWSUSP_WRITE,
+	AML_ISTBT_SWSUSP_CHECK,
+	AML_ISTBT_SWSUSP_UNMARK,
+	AML_ISTBT_ALLOC_IMAGE_PAGE,
+	AML_ISTBT_FREE_IMAGE_PAGE,
+	AML_ISTBT_INIT_MEM,
+	AML_ISTBT_PFN_TOUCHABLE,
+	AML_ISTBT_PFN_DESTORY,
+	AML_ISTBT_COPY_PAGE,
+	AML_ISTBT_FUN_MAX,
+} aml_istbt_fun_t;
+
+/* realized in module */
+extern int aml_istbt_dev_ready(void);
+extern void swsusp_close(fmode_t mode);
+extern int swsusp_read(unsigned int *flags_p);
+extern int swsusp_write(unsigned int flags);
+extern int swsusp_check(int wrapsnapshot);
+extern int swsusp_unmark(void);
+extern struct page *istbt_alloc_image_page(gfp_t gfp_mask);
+extern void istbt_free_image_page(void *addr, int clear_nosave_free);
+extern int istbt_init_mem(void);
+extern int istbt_pfn_touchable(unsigned long pfn);
+extern void istbt_pfn_destory(unsigned long pfn);
+extern void istbt_copy_page(long *dst, long *src);
+
+/* realized in kernel */
+extern int aml_snapshot_read_next(struct snapshot_handle *handle);
+extern int aml_snapshot_write_next(struct snapshot_handle *handle);
+extern void aml_snapshot_write_finalize(struct snapshot_handle *handle);
+extern unsigned long aml_snapshot_get_image_size(void);
+extern int aml_snapshot_image_loaded(struct snapshot_handle *handle);
+extern dev_t aml_get_swsusp_resume_device(void);
+
+extern end_swap_bio_read_p_t aml_get_end_swap_bio_read(void);
+extern unsigned int aml_nr_free_highpages (void);
+extern void aml_bio_set_pages_dirty(struct bio *bio);
+
+extern void* aml_boot_alloc_rsvmem(size_t size);
+
+extern int aml_istbt_reg_fun(aml_istbt_fun_t fun_type, void* fun_p);
+extern int aml_istbt_unreg_fun(aml_istbt_fun_t fun_type);
+#endif /* _INSTABOOT_H__ */
\ No newline at end of file
diff --git a/include/linux/amlogic/osd/osd_hw.h b/include/linux/amlogic/osd/osd_hw.h
index e206c167731a..6b709d3e3f7e 100755
--- a/include/linux/amlogic/osd/osd_hw.h
+++ b/include/linux/amlogic/osd/osd_hw.h
@@ -7,6 +7,7 @@
 #define HW_OSD_COUNT					2
 #define HW_OSD_BLOCK_COUNT			4
 #define HW_OSD_BLOCK_REG_COUNT		(HW_OSD_BLOCK_COUNT*2)
+#define HIBERNATE_OSD_SAVE_REG_COUNT		9
 
 typedef  enum{
 	OSD1=0,
@@ -124,7 +125,7 @@ typedef  struct {
 	u32  			color_key[HW_OSD_COUNT];
 	u32				color_key_enable[HW_OSD_COUNT];
 	u32				enable[HW_OSD_COUNT];
-	u32				reg_status_save;
+	u32				reg_status_save[HIBERNATE_OSD_SAVE_REG_COUNT];
 	bridge_item_t 		fiq_handle_item;
 	osd_scale_t		scale[HW_OSD_COUNT];
 	osd_freescale_t	free_scale[HW_OSD_COUNT];
diff --git a/include/linux/amlogic/vout/vout_notify.h b/include/linux/amlogic/vout/vout_notify.h
index 7b0e04917b2b..45d2b2ec36fe 100755
--- a/include/linux/amlogic/vout/vout_notify.h
+++ b/include/linux/amlogic/vout/vout_notify.h
@@ -1,102 +1,102 @@
-/*
- * Amlogic Apollo
- * frame buffer driver
- *
- * Copyright (C) 2009 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- *
- * Author:	jianfeng_wang
- *
- */
-#ifndef  VOUT_NOTIFY_H
-#define  VOUT_NOTIFY_H
-
-#include <linux/notifier.h>
-#include <linux/list.h>
-#include <linux/pm.h>
-#include "vinfo.h"
-
-typedef struct 
-{
-    const vinfo_t* (*get_vinfo)(void);
-    int	           (*set_vmode)(vmode_t);
-    vmode_t        (*validate_vmode)(char *);
-    int            (*vmode_is_supported)(vmode_t);
-    int            (*disable)(vmode_t );
-    int            (*set_vframe_rate_hint)(int);
-    int            (*set_vframe_rate_end_hint)(void);
-    int            (*vout_suspend)(void);
-    int            (*vout_resume)(void);
-}vout_op_t ;
-
-
-typedef  struct list_head  list_head_T;
-
-
-typedef struct 
-{
-	list_head_T  list;
-	char  	  *name;
-	vout_op_t  op;
-} vout_server_t;
-
-typedef struct {
-	list_head_T   vout_server_list;
-	vout_server_t *curr_vout_server;
-}vout_module_t;
-
-extern int vout_register_client(struct notifier_block * ) ;
-extern int vout_unregister_client(struct notifier_block *) ;
-extern int vout_register_server(vout_server_t *);
-extern int vout_unregister_server(vout_server_t*  );
-extern int vout_notifier_call_chain(unsigned long, void *) ;
-
-extern const vinfo_t *get_current_vinfo(void);
-extern vmode_t get_current_vmode(void);
-extern int set_current_vmode(vmode_t);
-extern vmode_t validate_vmode(char *);
-extern int set_vframe_rate_hint(int);
-extern int set_vframe_rate_end_hint(void);
-
-extern int vout_suspend(void); 
-extern int vout_resume(void);
-
-extern int get_power_level(void);
-
-
-#define VOUT_EVENT_MODE_CHANGE		0x00010000	
-#define VOUT_EVENT_OSD_BLANK			0x00020000
-#define VOUT_EVENT_OSD_DISP_AXIS			0x00030000
-#define  VOUT_EVENT_OSD_PREBLEND_ENABLE		0x00040000
-
-/* vout2 */
-extern int vout2_register_client(struct notifier_block * ) ;
-extern int vout2_unregister_client(struct notifier_block *) ;
-extern int vout2_register_server(vout_server_t *);
-extern int vout2_unregister_server(vout_server_t*  );
-extern int vout2_notifier_call_chain(unsigned long, void *) ;
-
-extern const vinfo_t *get_current_vinfo2(void);
-extern vmode_t get_current_vmode2(void);
-extern int set_current_vmode2(vmode_t);
-extern vmode_t validate_vmode2(char *);
-extern void  set_vout2_mode_internal(char * name);
-
-extern int vout2_suspend(void); 
-extern int vout2_resume(void);
-/**/
-
-#endif /* VOUT_NOTIFY_H */
+/*
+ * Amlogic Apollo
+ * frame buffer driver
+ *
+ * Copyright (C) 2009 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:	jianfeng_wang
+ *
+ */
+#ifndef  VOUT_NOTIFY_H
+#define  VOUT_NOTIFY_H
+
+#include <linux/notifier.h>
+#include <linux/list.h>
+#include <linux/pm.h>
+#include "vinfo.h"
+
+typedef struct
+{
+	const vinfo_t*	(*get_vinfo)(void);
+	int		(*set_vmode)(vmode_t);
+	vmode_t		(*validate_vmode)(char *);
+	int		(*vmode_is_supported)(vmode_t);
+	int		(*disable)(vmode_t );
+	int		(*set_vframe_rate_hint)(int);
+	int		(*set_vframe_rate_end_hint)(void);
+	int		(*vout_suspend)(int);
+	int		(*vout_resume)(int);
+}vout_op_t ;
+
+
+typedef  struct list_head  list_head_T;
+
+
+typedef struct
+{
+	list_head_T	list;
+	char		*name;
+	vout_op_t	op;
+} vout_server_t;
+
+typedef struct {
+	list_head_T   vout_server_list;
+	vout_server_t *curr_vout_server;
+}vout_module_t;
+
+extern int vout_register_client(struct notifier_block * ) ;
+extern int vout_unregister_client(struct notifier_block *) ;
+extern int vout_register_server(vout_server_t *);
+extern int vout_unregister_server(vout_server_t*  );
+extern int vout_notifier_call_chain(unsigned long, void *) ;
+
+extern const vinfo_t *get_current_vinfo(void);
+extern vmode_t get_current_vmode(void);
+extern int set_current_vmode(vmode_t);
+extern vmode_t validate_vmode(char *);
+extern int set_vframe_rate_hint(int);
+extern int set_vframe_rate_end_hint(void);
+
+extern int vout_suspend(int);
+extern int vout_resume(int);
+
+extern int get_power_level(void);
+
+
+#define VOUT_EVENT_MODE_CHANGE			0x00010000
+#define VOUT_EVENT_OSD_BLANK			0x00020000
+#define VOUT_EVENT_OSD_DISP_AXIS		0x00030000
+#define  VOUT_EVENT_OSD_PREBLEND_ENABLE		0x00040000
+
+/* vout2 */
+extern int vout2_register_client(struct notifier_block * ) ;
+extern int vout2_unregister_client(struct notifier_block *) ;
+extern int vout2_register_server(vout_server_t *);
+extern int vout2_unregister_server(vout_server_t*  );
+extern int vout2_notifier_call_chain(unsigned long, void *) ;
+
+extern const vinfo_t *get_current_vinfo2(void);
+extern vmode_t get_current_vmode2(void);
+extern int set_current_vmode2(vmode_t);
+extern vmode_t validate_vmode2(char *);
+extern void  set_vout2_mode_internal(char * name);
+
+extern int vout2_suspend(int pm_event);
+extern int vout2_resume(int pm_event);
+/**/
+
+#endif /* VOUT_NOTIFY_H */
diff --git a/include/linux/pm.h b/include/linux/pm.h
index a224c7f5c377..38710877973f 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -443,6 +443,9 @@ const struct dev_pm_ops name = { \
 					{ .event = PM_EVENT_AUTO_RESUME, })
 
 #define PMSG_IS_AUTO(msg)	(((msg).event & PM_EVENT_AUTO) != 0)
+#define PMSG_IS_HIBERNATION(msg)	((((msg).event & PM_EVENT_FREEZE) != 0) | \
+									(((msg).event & PM_EVENT_THAW) != 0) | \
+									(((msg).event & PM_EVENT_RESTORE) != 0))
 
 /**
  * Device run-time power management status.
diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d4e3f16d5e89..ffae8e74648b 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -8,6 +8,9 @@
 #include <linux/mm.h>
 #include <linux/freezer.h>
 #include <asm/errno.h>
+#if defined(CONFIG_ARCH_HIBERNATION_POSSIBLE)
+#include <asm/suspend.h>
+#endif
 
 #ifdef CONFIG_VT
 extern void pm_set_vt_switch(int);
@@ -320,6 +323,8 @@ extern unsigned long get_safe_page(gfp_t gfp_mask);
 extern void hibernation_set_ops(const struct platform_hibernation_ops *ops);
 extern int hibernate(void);
 extern bool system_entering_hibernation(void);
+asmlinkage int swsusp_save(void);
+extern struct pbe *restore_pblist;
 #else /* CONFIG_HIBERNATION */
 static inline void register_nosave_region(unsigned long b, unsigned long e) {}
 static inline void register_nosave_region_late(unsigned long b, unsigned long e) {}
diff --git a/init/do_mounts.c b/init/do_mounts.c
index a2b49f2c1bd8..65120c60a7d5 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -97,6 +97,20 @@ no_match:
 	return 0;
 }
 
+static int match_dev_by_name(struct device *dev, const void *data)
+{
+	const char* name = data;
+
+	//printk("cmp partition dev: %s, name: %s\n", dev_name(dev), name);
+
+	if (!strstr(name, dev_name(dev)))
+		goto no_match;
+
+	return 1;
+no_match:
+	return 0;
+}
+
 
 /**
  * devt_from_partuuid - looks up the dev_t of a partition by its UUID
@@ -207,6 +221,7 @@ dev_t name_to_dev_t(char *name)
 	char s[32];
 	char *p;
 	dev_t res = 0;
+	struct device *dev = NULL;
 	int part;
 
 #ifdef CONFIG_BLOCK
@@ -252,6 +267,13 @@ dev_t name_to_dev_t(char *name)
 	if (res)
 		goto done;
 
+	dev = class_find_device(&block_class, NULL, name,
+				&match_dev_by_name);
+
+	if (dev) {
+		res = dev->devt;
+		goto done;
+	}
 	/*
 	 * try non-existent, but valid partition, which may only exist
 	 * after revalidating the disk, like partitioned md devices
diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig
index 66eb1b050e83..73b02c17cdbf 100755
--- a/kernel/power/Kconfig
+++ b/kernel/power/Kconfig
@@ -348,3 +348,8 @@ config SUSPEND_TIME
 	  Prints the time spent in suspend in the kernel log, and
 	  keeps statistics on the time spent in suspend in
 	  /sys/kernel/debug/suspend_time
+
+config MK_SNAPSHOT_ONLY
+	bool "make the snapshot image only"
+	depends on HIBERNATION
+	default n
\ No newline at end of file
diff --git a/kernel/power/Makefile b/kernel/power/Makefile
index 3dac2c0a7e0d..0e1be0fea50f 100755
--- a/kernel/power/Makefile
+++ b/kernel/power/Makefile
@@ -7,8 +7,7 @@ obj-$(CONFIG_VT_CONSOLE_SLEEP)	+= console.o
 obj-$(CONFIG_FREEZER)		+= process.o
 obj-$(CONFIG_SUSPEND)		+= suspend.o
 obj-$(CONFIG_PM_TEST_SUSPEND)	+= suspend_test.o
-obj-$(CONFIG_HIBERNATION)	+= hibernate.o snapshot.o swap.o user.o \
-				   block_io.o
+obj-$(CONFIG_HIBERNATION)	+= hibernate.o snapshot.o
 obj-$(CONFIG_PM_AUTOSLEEP)	+= autosleep.o
 #obj-$(CONFIG_PM_WAKELOCKS)	+= wakelock.o
 obj-$(CONFIG_WAKELOCK)		+= wakelock_android.o
diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c
index b26f5f1e773e..83209a115994 100644
--- a/kernel/power/hibernate.c
+++ b/kernel/power/hibernate.c
@@ -28,10 +28,11 @@
 #include <linux/syscore_ops.h>
 #include <linux/ctype.h>
 #include <linux/genhd.h>
+#include <linux/amlogic/instaboot/instaboot.h>
 
 #include "power.h"
 
-
+static int wipeinstaboot;
 static int nocompress;
 static int noresume;
 static int resume_wait;
@@ -41,6 +42,18 @@ dev_t swsusp_resume_device;
 sector_t swsusp_resume_block;
 int in_suspend __nosavedata;
 
+#ifndef CONFIG_MK_SNAPSHOT_ONLY
+extern int osd_show_progress_bar(u32 percent);
+extern int osd_init_progress_bar(void);
+#endif
+
+extern void l2x0_resume(void);
+
+#define BOOT_TYPE_NORMAL	0
+#define BOOT_TYPE_FAST		1
+
+static int boot_type __nosavedata;
+
 enum {
 	HIBERNATION_INVALID,
 	HIBERNATION_PLATFORM,
@@ -291,6 +304,7 @@ static int create_image(int platform_mode)
 	if (error)
 		printk(KERN_ERR "PM: Error %d creating hibernation image\n",
 			error);
+	l2x0_resume();
 	/* Restore control flow magically appears here */
 	restore_processor_state();
 	if (!in_suspend) {
@@ -574,6 +588,7 @@ int hibernation_platform_enter(void)
 	return error;
 }
 
+#ifndef CONFIG_MK_SNAPSHOT_ONLY
 /**
  * power_down - Shut the machine down for hibernation.
  *
@@ -624,6 +639,7 @@ static void power_down(void)
 	printk(KERN_CRIT "PM: Please power down manually\n");
 	while(1);
 }
+#endif /* CONFIG_MK_SNAPSHOT_ONLY */
 
 /**
  * hibernate - Carry out system hibernation, including saving the image.
@@ -664,6 +680,11 @@ int hibernate(void)
 	if (in_suspend) {
 		unsigned int flags = 0;
 
+#ifndef CONFIG_MK_SNAPSHOT_ONLY
+		osd_init_progress_bar();
+		osd_show_progress_bar(1);
+#endif
+
 		if (hibernation_mode == HIBERNATION_PLATFORM)
 			flags |= SF_PLATFORM_MODE;
 		if (nocompress)
@@ -671,11 +692,19 @@ int hibernate(void)
 		else
 		        flags |= SF_CRC32_MODE;
 
+		if (!swsusp_resume_device)
+			swsusp_resume_device = name_to_dev_t(resume_file);
+
 		pr_debug("PM: writing image.\n");
+#ifndef CONFIG_MK_SNAPSHOT_ONLY
+		osd_show_progress_bar(5);
+#endif
 		error = swsusp_write(flags);
 		swsusp_free();
+#ifndef CONFIG_MK_SNAPSHOT_ONLY
 		if (!error)
 			power_down();
+#endif
 		in_suspend = 0;
 		pm_restore_gfp_mask();
 	} else {
@@ -699,7 +728,6 @@ int hibernate(void)
 	return error;
 }
 
-
 /**
  * software_resume - Resume from a saved hibernation image.
  *
@@ -715,17 +743,22 @@ int hibernate(void)
  * attempts to recover gracefully and make the kernel return to the normal mode
  * of operation.
  */
-static int software_resume(void)
+int software_resume(void)
 {
 	int error;
 	unsigned int flags;
 
+	boot_type = BOOT_TYPE_NORMAL;
+
 	/*
 	 * If the user said "noresume".. bail out early.
 	 */
 	if (noresume)
 		return 0;
 
+	if (aml_istbt_dev_ready() < 0)
+		return 0;
+
 	/*
 	 * name_to_dev_t() below takes a sysfs buffer mutex when sysfs
 	 * is configured into the kernel. Since the regular hibernate
@@ -746,14 +779,13 @@ static int software_resume(void)
 		goto Unlock;
 	}
 
-	pr_debug("PM: Checking hibernation image partition %s\n", resume_file);
-
 	if (resume_delay) {
 		printk(KERN_INFO "Waiting %dsec before reading resume device...\n",
 			resume_delay);
 		ssleep(resume_delay);
 	}
 
+
 	/* Check if the device is there */
 	swsusp_resume_device = name_to_dev_t(resume_file);
 
@@ -792,7 +824,7 @@ static int software_resume(void)
 		MAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));
 
 	pr_debug("PM: Looking for hibernation image.\n");
-	error = swsusp_check();
+	error = swsusp_check(wipeinstaboot);
 	if (error)
 		goto Unlock;
 
@@ -823,10 +855,13 @@ static int software_resume(void)
 
 	error = swsusp_read(&flags);
 	swsusp_close(FMODE_READ);
-	if (!error)
+	if (!error) {
+		boot_type = BOOT_TYPE_FAST;
 		hibernation_restore(flags & SF_PLATFORM_MODE);
+	}
 
 	printk(KERN_ERR "PM: Failed to load hibernation image, recovering.\n");
+	boot_type = BOOT_TYPE_NORMAL;
 	swsusp_free();
 	thaw_processes();
  Done:
@@ -844,6 +879,7 @@ close_finish:
 	swsusp_close(FMODE_READ);
 	goto Finish;
 }
+EXPORT_SYMBOL(software_resume);
 
 late_initcall(software_resume);
 
@@ -1038,11 +1074,27 @@ static ssize_t reserved_size_store(struct kobject *kobj,
 
 power_attr(reserved_size);
 
+static ssize_t boot_type_show(struct kobject *kobj,
+				  struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", boot_type ? "fast" : "normal");
+}
+
+static struct kobj_attribute boot_type_attr = {
+	.attr	= {
+		.name = __stringify(boot_type),
+		.mode = 0444,
+	},
+	.show	= boot_type_show,
+	.store	= NULL,
+};
+
 static struct attribute * g[] = {
 	&disk_attr.attr,
 	&resume_attr.attr,
 	&image_size_attr.attr,
 	&reserved_size_attr.attr,
+	&boot_type_attr.attr,
 	NULL,
 };
 
@@ -1051,7 +1103,6 @@ static struct attribute_group attr_group = {
 	.attrs = g,
 };
 
-
 static int __init pm_disk_init(void)
 {
 	return sysfs_create_group(power_kobj, &attr_group);
@@ -1059,7 +1110,6 @@ static int __init pm_disk_init(void)
 
 core_initcall(pm_disk_init);
 
-
 static int __init resume_setup(char *str)
 {
 	if (noresume)
@@ -1091,6 +1141,12 @@ static int __init hibernate_setup(char *str)
 	return 1;
 }
 
+static int __init  wipeinstaboot_setup(char *str)
+{
+	wipeinstaboot = 1;
+	return 1;
+}
+
 static int __init noresume_setup(char *str)
 {
 	noresume = 1;
@@ -1109,6 +1165,7 @@ static int __init resumedelay_setup(char *str)
 	return 1;
 }
 
+__setup("wipeinstaboot", wipeinstaboot_setup);
 __setup("noresume", noresume_setup);
 __setup("resume_offset=", resume_offset_setup);
 __setup("resume=", resume_setup);
diff --git a/kernel/power/power.h b/kernel/power/power.h
index 18e99b355163..fea5f0a3c5c8 100755
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -138,7 +138,7 @@ extern int snapshot_image_loaded(struct snapshot_handle *handle);
 /* If unset, the snapshot device cannot be open. */
 extern atomic_t snapshot_device_available;
 
-extern sector_t alloc_swapdev_block(int swap);
+extern sector_t alloc_swapdev_block(void);
 extern void free_all_swap_pages(int swap);
 extern int swsusp_swap_in_use(void);
 
@@ -151,7 +151,7 @@ extern int swsusp_swap_in_use(void);
 #define SF_CRC32_MODE	        4
 
 /* kernel/power/hibernate.c */
-extern int swsusp_check(void);
+extern int swsusp_check(int wrapsnapshot);
 extern void swsusp_free(void);
 extern int swsusp_read(unsigned int *flags_p);
 extern int swsusp_write(unsigned int flags);
diff --git a/kernel/power/snapshot.c b/kernel/power/snapshot.c
index 91c04f16e79c..3e82688312e7 100644
--- a/kernel/power/snapshot.c
+++ b/kernel/power/snapshot.c
@@ -34,11 +34,13 @@
 #include <asm/tlbflush.h>
 #include <asm/io.h>
 
+#include <linux/amlogic/instaboot/instaboot.h>
+
 #include "power.h"
 
 static int swsusp_page_is_free(struct page *);
-static void swsusp_set_page_forbidden(struct page *);
-static void swsusp_unset_page_forbidden(struct page *);
+void swsusp_set_page_forbidden(struct page *);
+void swsusp_unset_page_forbidden(struct page *);
 
 /*
  * Number of bytes to reserve for memory allocations made by device drivers
@@ -92,7 +94,7 @@ static void *buffer;
 
 static unsigned int allocated_unsafe_pages;
 
-static void *get_image_page(gfp_t gfp_mask, int safe_needed)
+void *get_image_page(gfp_t gfp_mask, int safe_needed)
 {
 	void *res;
 
@@ -110,12 +112,18 @@ static void *get_image_page(gfp_t gfp_mask, int safe_needed)
 	}
 	return res;
 }
+EXPORT_SYMBOL(get_image_page);
 
 unsigned long get_safe_page(gfp_t gfp_mask)
 {
 	return (unsigned long)get_image_page(gfp_mask, PG_SAFE);
 }
-
+#ifdef CONFIG_INSTABOOT_MEM_MG
+static inline struct page* alloc_image_page(gfp_t gfp_mask)
+{
+	return istbt_alloc_image_page(gfp_mask);
+}
+#else
 static struct page *alloc_image_page(gfp_t gfp_mask)
 {
 	struct page *page;
@@ -127,12 +135,18 @@ static struct page *alloc_image_page(gfp_t gfp_mask)
 	}
 	return page;
 }
+#endif
 
 /**
  *	free_image_page - free page represented by @addr, allocated with
  *	get_image_page (page flags set by it must be cleared)
  */
-
+#ifdef CONFIG_INSTABOOT_MEM_MG
+static inline void free_image_page(void *addr, int clear_nosave_free)
+{
+	istbt_free_image_page(addr, clear_nosave_free);
+}
+#else
 static inline void free_image_page(void *addr, int clear_nosave_free)
 {
 	struct page *page;
@@ -147,6 +161,7 @@ static inline void free_image_page(void *addr, int clear_nosave_free)
 
 	__free_page(page);
 }
+#endif
 
 /* struct linked_page is used to build chains of pages */
 
@@ -650,10 +665,10 @@ __register_nosave_region(unsigned long start_pfn, unsigned long end_pfn,
  * Set bits in this map correspond to the page frames the contents of which
  * should not be saved during the suspend.
  */
-static struct memory_bitmap *forbidden_pages_map;
+struct memory_bitmap *forbidden_pages_map;
 
 /* Set bits in this map correspond to free page frames. */
-static struct memory_bitmap *free_pages_map;
+struct memory_bitmap *free_pages_map;
 
 /*
  * Each page frame allocated for creating the image is marked by setting the
@@ -665,6 +680,19 @@ void swsusp_set_page_free(struct page *page)
 	if (free_pages_map)
 		memory_bm_set_bit(free_pages_map, page_to_pfn(page));
 }
+EXPORT_SYMBOL(swsusp_set_page_free);
+
+struct memory_bitmap *swsusp_get_forbidden_pages_map(void)
+{
+	return forbidden_pages_map;
+}
+EXPORT_SYMBOL(swsusp_get_forbidden_pages_map);
+
+struct memory_bitmap *swsusp_get_free_pages_map(void)
+{
+	return free_pages_map;
+}
+EXPORT_SYMBOL(swsusp_get_free_pages_map);
 
 static int swsusp_page_is_free(struct page *page)
 {
@@ -677,12 +705,14 @@ void swsusp_unset_page_free(struct page *page)
 	if (free_pages_map)
 		memory_bm_clear_bit(free_pages_map, page_to_pfn(page));
 }
+EXPORT_SYMBOL(swsusp_unset_page_free);
 
-static void swsusp_set_page_forbidden(struct page *page)
+void swsusp_set_page_forbidden(struct page *page)
 {
 	if (forbidden_pages_map)
 		memory_bm_set_bit(forbidden_pages_map, page_to_pfn(page));
 }
+EXPORT_SYMBOL(swsusp_set_page_forbidden);
 
 int swsusp_page_is_forbidden(struct page *page)
 {
@@ -690,11 +720,12 @@ int swsusp_page_is_forbidden(struct page *page)
 		memory_bm_test_bit(forbidden_pages_map, page_to_pfn(page)) : 0;
 }
 
-static void swsusp_unset_page_forbidden(struct page *page)
+void swsusp_unset_page_forbidden(struct page *page)
 {
 	if (forbidden_pages_map)
 		memory_bm_clear_bit(forbidden_pages_map, page_to_pfn(page));
 }
+EXPORT_SYMBOL(swsusp_unset_page_forbidden);
 
 /**
  *	mark_nosave_pages - set bits corresponding to the page frames the
@@ -744,6 +775,9 @@ int create_basic_memory_bitmaps(void)
 
 	BUG_ON(forbidden_pages_map || free_pages_map);
 
+#ifdef CONFIG_INSTABOOT_MEM_MG
+	istbt_init_mem();
+#endif
 	bm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);
 	if (!bm1)
 		return -ENOMEM;
@@ -958,6 +992,12 @@ static unsigned int count_data_pages(void)
 /* This is needed, because copy_page and memcpy are not usable for copying
  * task structs.
  */
+#ifdef CONFIG_INSTABOOT_MEM_MG
+static inline void do_copy_page(long *dst, long *src)
+{
+	istbt_copy_page(dst, src);
+}
+#else
 static inline void do_copy_page(long *dst, long *src)
 {
 	int n;
@@ -965,7 +1005,7 @@ static inline void do_copy_page(long *dst, long *src)
 	for (n = PAGE_SIZE / sizeof(long); n; n--)
 		*dst++ = *src++;
 }
-
+#endif
 
 /**
  *	safe_copy_page - check if the page we are going to copy is marked as
@@ -1096,12 +1136,26 @@ void swsusp_free(void)
 		for (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)
 			if (pfn_valid(pfn)) {
 				struct page *page = pfn_to_page(pfn);
-
-				if (swsusp_page_is_forbidden(page) &&
-				    swsusp_page_is_free(page)) {
-					swsusp_unset_page_forbidden(page);
-					swsusp_unset_page_free(page);
-					__free_page(page);
+#ifdef CONFIG_INSTABOOT_MEM_MG
+				if (!istbt_pfn_touchable(pfn)) {
+					if (forbidden_pages_map)
+						memory_bm_clear_bit(forbidden_pages_map, pfn);
+
+					if (free_pages_map)
+						memory_bm_clear_bit(free_pages_map, pfn);
+
+					istbt_pfn_destory(pfn);
+
+				} else
+#endif
+				{
+
+					if (swsusp_page_is_forbidden(page) &&
+							swsusp_page_is_free(page)) {
+						swsusp_unset_page_forbidden(page);
+						swsusp_unset_page_free(page);
+						__free_page(page);
+					}
 				}
 			}
 	}
@@ -1230,7 +1284,12 @@ static void free_unnecessary_pages(void)
 
 	while (to_free_normal > 0 || to_free_highmem > 0) {
 		unsigned long pfn = memory_bm_next_pfn(&copy_bm);
-		struct page *page = pfn_to_page(pfn);
+		struct page *page;
+#ifdef CONFIG_INSTABOOT_MEM_MG
+		while (!istbt_pfn_touchable(pfn))
+			pfn = memory_bm_next_pfn(&copy_bm);
+#endif
+		page = pfn_to_page(pfn);
 
 		if (PageHighMem(page)) {
 			if (!to_free_highmem)
diff --git a/kernel/printk.c b/kernel/printk.c
index 4b213412294b..aecd61bc0882 100755
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -62,7 +62,7 @@ extern void printascii(char *);
 #define MINIMUM_CONSOLE_LOGLEVEL 1 /* Minimum loglevel we let people use */
 #define DEFAULT_CONSOLE_LOGLEVEL 7 /* anything MORE serious than KERN_DEBUG */
 
-int console_printk[4] = {
+int __nosavedata console_printk[4] = {
 	DEFAULT_CONSOLE_LOGLEVEL,	/* console_loglevel */
 	DEFAULT_MESSAGE_LOGLEVEL,	/* default_message_loglevel */
 	MINIMUM_CONSOLE_LOGLEVEL,	/* minimum_console_loglevel */
diff --git a/lib/lzo/lzo1x_decompress_safe.c b/lib/lzo/lzo1x_decompress_safe.c
index 569985d522d5..d554607d9cb4 100644
--- a/lib/lzo/lzo1x_decompress_safe.c
+++ b/lib/lzo/lzo1x_decompress_safe.c
@@ -10,7 +10,6 @@
  *  Nitin Gupta <nitingupta910@gmail.com>
  *  Richard Purdie <rpurdie@openedhand.com>
  */
-
 #ifndef STATIC
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -18,13 +17,11 @@
 #include <asm/unaligned.h>
 #include <linux/lzo.h>
 #include "lzodefs.h"
-
 #define HAVE_IP(x)      ((size_t)(ip_end - ip) >= (size_t)(x))
 #define HAVE_OP(x)      ((size_t)(op_end - op) >= (size_t)(x))
 #define NEED_IP(x)      if (!HAVE_IP(x)) goto input_overrun
 #define NEED_OP(x)      if (!HAVE_OP(x)) goto output_overrun
 #define TEST_LB(m_pos)  if ((m_pos) < out) goto lookbehind_overrun
-
 int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 			  unsigned char *out, size_t *out_len)
 {
@@ -35,10 +32,8 @@ int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 	const unsigned char *m_pos;
 	const unsigned char * const ip_end = in + in_len;
 	unsigned char * const op_end = out + *out_len;
-
 	op = out;
 	ip = in;
-
 	if (unlikely(in_len < 3))
 		goto input_overrun;
 	if (*ip > 17) {
@@ -49,7 +44,6 @@ int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 		}
 		goto copy_literal_run;
 	}
-
 	for (;;) {
 		t = *ip++;
 		if (t < 16) {
@@ -72,9 +66,11 @@ copy_literal_run:
 						COPY8(op, ip);
 						op += 8;
 						ip += 8;
+#  if !defined(__arm__)
 						COPY8(op, ip);
 						op += 8;
 						ip += 8;
+#  endif
 					} while (ip < ie);
 					ip = ie;
 					op = oe;
@@ -159,9 +155,11 @@ copy_literal_run:
 					COPY8(op, m_pos);
 					op += 8;
 					m_pos += 8;
+#  if !defined(__arm__)
 					COPY8(op, m_pos);
 					op += 8;
 					m_pos += 8;
+#  endif
 				} while (op < oe);
 				op = oe;
 				if (HAVE_IP(6)) {
@@ -209,29 +207,23 @@ match_next:
 			}
 		}
 	}
-
 eof_found:
 	*out_len = op - out;
 	return (t != 3       ? LZO_E_ERROR :
 		ip == ip_end ? LZO_E_OK :
 		ip <  ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN);
-
 input_overrun:
 	*out_len = op - out;
 	return LZO_E_INPUT_OVERRUN;
-
 output_overrun:
 	*out_len = op - out;
 	return LZO_E_OUTPUT_OVERRUN;
-
 lookbehind_overrun:
 	*out_len = op - out;
 	return LZO_E_LOOKBEHIND_OVERRUN;
 }
 #ifndef STATIC
 EXPORT_SYMBOL_GPL(lzo1x_decompress_safe);
-
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("LZO1X Decompressor");
-
-#endif
+#endif
\ No newline at end of file
diff --git a/lib/lzo/lzodefs.h b/lib/lzo/lzodefs.h
index 6710b83ce72e..caa05fe5a891 100644
--- a/lib/lzo/lzodefs.h
+++ b/lib/lzo/lzodefs.h
@@ -10,10 +10,14 @@
  *  Nitin Gupta <nitingupta910@gmail.com>
  *  Richard Purdie <rpurdie@openedhand.com>
  */
-
-
+#if 1 && defined(__arm__) && ((__LINUX_ARM_ARCH__ >= 6) || defined(__ARM_FEATURE_UNALIGNED))
+#define CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS 1
+#define COPY4(dst, src)	\
+		* (u32 *) (void *) (dst) = * (const u32 *) (const void *) (src)
+#else
 #define COPY4(dst, src)	\
 		put_unaligned(get_unaligned((const u32 *)(src)), (u32 *)(dst))
+#endif
 #if defined(__x86_64__)
 #define COPY8(dst, src)	\
 		put_unaligned(get_unaligned((const u64 *)(src)), (u64 *)(dst))
@@ -21,7 +25,6 @@
 #define COPY8(dst, src)	\
 		COPY4(dst, src); COPY4((dst) + 4, (src) + 4)
 #endif
-
 #if defined(__BIG_ENDIAN) && defined(__LITTLE_ENDIAN)
 #error "conflicting endian definitions"
 #elif defined(__x86_64__)
@@ -32,12 +35,10 @@
 #elif defined(__arm__) && (__LINUX_ARM_ARCH__ >= 5)
 #define LZO_USE_CTZ32	1
 #endif
-
 #define M1_MAX_OFFSET	0x0400
 #define M2_MAX_OFFSET	0x0800
 #define M3_MAX_OFFSET	0x4000
 #define M4_MAX_OFFSET	0xbfff
-
 #define M1_MIN_LEN	2
 #define M1_MAX_LEN	2
 #define M2_MIN_LEN	3
@@ -46,14 +47,12 @@
 #define M3_MAX_LEN	33
 #define M4_MIN_LEN	3
 #define M4_MAX_LEN	9
-
 #define M1_MARKER	0
 #define M2_MARKER	64
 #define M3_MARKER	32
 #define M4_MARKER	16
-
 #define lzo_dict_t      unsigned short
 #define D_BITS		13
 #define D_SIZE		(1u << D_BITS)
 #define D_MASK		(D_SIZE - 1)
-#define D_HIGH		((D_MASK >> 1) + 1)
+#define D_HIGH		((D_MASK >> 1) + 1)
\ No newline at end of file
-- 
2.19.0

